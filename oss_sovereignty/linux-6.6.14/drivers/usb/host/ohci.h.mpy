{
  "module_name": "ohci.h",
  "hash_id": "44a890e4eda27959896c5d7bf9ec99f6dfe4c1fd9993d48907703dde0c978957",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci.h",
  "human_readable_source": " \n \n\n \ntypedef __u32 __bitwise __hc32;\ntypedef __u16 __bitwise __hc16;\n\n \nstruct ed {\n\t \n\t__hc32\t\t\thwINFO;       \n\t \n#define ED_DEQUEUE\t(1 << 27)\n\t \n#define ED_ISO\t\t(1 << 15)\n#define ED_SKIP\t\t(1 << 14)\n#define ED_LOWSPEED\t(1 << 13)\n#define ED_OUT\t\t(0x01 << 11)\n#define ED_IN\t\t(0x02 << 11)\n\t__hc32\t\t\thwTailP;\t \n\t__hc32\t\t\thwHeadP;\t \n#define ED_C\t\t(0x02)\t\t\t \n#define ED_H\t\t(0x01)\t\t\t \n\t__hc32\t\t\thwNextED;\t \n\n\t \n\tdma_addr_t\t\tdma;\t\t \n\tstruct td\t\t*dummy;\t\t \n\n\t \n\tstruct ed\t\t*ed_next;\t \n\tstruct ed\t\t*ed_prev;\t \n\tstruct list_head\ttd_list;\t \n\tstruct list_head\tin_use_list;\n\n\t \n\tu8\t\t\tstate;\t\t \n#define ED_IDLE\t\t0x00\t\t \n#define ED_UNLINK\t0x01\t\t \n#define ED_OPER\t\t0x02\t\t \n\n\tu8\t\t\ttype;\t\t \n\n\t \n\tu8\t\t\tbranch;\n\tu16\t\t\tinterval;\n\tu16\t\t\tload;\n\tu16\t\t\tlast_iso;\t \n\n\t \n\tu16\t\t\ttick;\n\n\t \n\tunsigned\t\ttakeback_wdh_cnt;\n\tstruct td\t\t*pending_td;\n#define\tOKAY_TO_TAKEBACK(ohci, ed)\t\t\t\\\n\t\t((int) (ohci->wdh_cnt - ed->takeback_wdh_cnt) >= 0)\n\n} __attribute__ ((aligned(16)));\n\n#define ED_MASK\t((u32)~0x0f)\t\t \n\n\n \nstruct td {\n\t \n\t__hc32\t\thwINFO;\t\t \n\n\t \n#define TD_CC       0xf0000000\t\t\t \n#define TD_CC_GET(td_p) ((td_p >>28) & 0x0f)\n\n#define TD_DI       0x00E00000\t\t\t \n#define TD_DI_SET(X) (((X) & 0x07)<< 21)\n\t \n#define TD_DONE     0x00020000\t\t\t \n#define TD_ISO      0x00010000\t\t\t \n\n\t \n#define TD_EC       0x0C000000\t\t\t \n#define TD_T        0x03000000\t\t\t \n#define TD_T_DATA0  0x02000000\t\t\t\t \n#define TD_T_DATA1  0x03000000\t\t\t\t \n#define TD_T_TOGGLE 0x00000000\t\t\t\t \n#define TD_DP       0x00180000\t\t\t \n#define TD_DP_SETUP 0x00000000\t\t\t \n#define TD_DP_IN    0x00100000\t\t\t\t \n#define TD_DP_OUT   0x00080000\t\t\t\t \n\t\t\t\t\t\t\t \n#define TD_R        0x00040000\t\t\t \n\n\t \n\n\t__hc32\t\thwCBP;\t\t \n\t__hc32\t\thwNextTD;\t \n\t__hc32\t\thwBE;\t\t \n\n\t \n#define MAXPSW\t2\n\t__hc16\t\thwPSW [MAXPSW];\n\n\t \n\t__u8\t\tindex;\n\tstruct ed\t*ed;\n\tstruct td\t*td_hash;\t \n\tstruct td\t*next_dl_td;\n\tstruct urb\t*urb;\n\n\tdma_addr_t\ttd_dma;\t\t \n\tdma_addr_t\tdata_dma;\t \n\n\tstruct list_head td_list;\t \n} __attribute__ ((aligned(32)));\t \n\n#define TD_MASK\t((u32)~0x1f)\t\t \n\n \n#define TD_CC_NOERROR      0x00\n#define TD_CC_CRC          0x01\n#define TD_CC_BITSTUFFING  0x02\n#define TD_CC_DATATOGGLEM  0x03\n#define TD_CC_STALL        0x04\n#define TD_DEVNOTRESP      0x05\n#define TD_PIDCHECKFAIL    0x06\n#define TD_UNEXPECTEDPID   0x07\n#define TD_DATAOVERRUN     0x08\n#define TD_DATAUNDERRUN    0x09\n     \n#define TD_BUFFEROVERRUN   0x0C\n#define TD_BUFFERUNDERRUN  0x0D\n     \n#define TD_NOTACCESSED     0x0F\n\n\n \nstatic const int __maybe_unused cc_to_error [16] = {\n\t                0,\n\t                -EILSEQ,\n\t                -EPROTO,\n\t                -EILSEQ,\n\t                -EPIPE,\n\t                -ETIME,\n\t                -EPROTO,\n\t                -EPROTO,\n\t                -EOVERFLOW,\n\t                -EREMOTEIO,\n\t                -EIO,\n\t                -EIO,\n\t                -ECOMM,\n\t                -ENOSR,\n\t                -EALREADY,\n\t                -EALREADY\n};\n\n\n \nstruct ohci_hcca {\n#define NUM_INTS 32\n\t__hc32\tint_table [NUM_INTS];\t \n\n\t \n\t__hc32\tframe_no;\t\t \n\t__hc32\tdone_head;\t\t \n\tu8\treserved_for_hc [116];\n\tu8\twhat [4];\t\t \n} __attribute__ ((aligned(256)));\n\n \nstruct ohci_regs {\n\t \n\t__hc32\trevision;\n\t__hc32\tcontrol;\n\t__hc32\tcmdstatus;\n\t__hc32\tintrstatus;\n\t__hc32\tintrenable;\n\t__hc32\tintrdisable;\n\n\t \n\t__hc32\thcca;\n\t__hc32\ted_periodcurrent;\n\t__hc32\ted_controlhead;\n\t__hc32\ted_controlcurrent;\n\t__hc32\ted_bulkhead;\n\t__hc32\ted_bulkcurrent;\n\t__hc32\tdonehead;\n\n\t \n\t__hc32\tfminterval;\n\t__hc32\tfmremaining;\n\t__hc32\tfmnumber;\n\t__hc32\tperiodicstart;\n\t__hc32\tlsthresh;\n\n\t \n\tstruct\tohci_roothub_regs {\n\t\t__hc32\ta;\n\t\t__hc32\tb;\n\t\t__hc32\tstatus;\n#define MAX_ROOT_PORTS\t15\t \n\t\t__hc32\tportstatus [MAX_ROOT_PORTS];\n\t} roothub;\n\n\t \n\n} __attribute__ ((aligned(32)));\n\n\n \n\n \n#define OHCI_CTRL_CBSR\t(3 << 0)\t \n#define OHCI_CTRL_PLE\t(1 << 2)\t \n#define OHCI_CTRL_IE\t(1 << 3)\t \n#define OHCI_CTRL_CLE\t(1 << 4)\t \n#define OHCI_CTRL_BLE\t(1 << 5)\t \n#define OHCI_CTRL_HCFS\t(3 << 6)\t \n#define OHCI_CTRL_IR\t(1 << 8)\t \n#define OHCI_CTRL_RWC\t(1 << 9)\t \n#define OHCI_CTRL_RWE\t(1 << 10)\t \n\n \n#\tdefine OHCI_USB_RESET\t(0 << 6)\n#\tdefine OHCI_USB_RESUME\t(1 << 6)\n#\tdefine OHCI_USB_OPER\t(2 << 6)\n#\tdefine OHCI_USB_SUSPEND\t(3 << 6)\n\n \n#define OHCI_HCR\t(1 << 0)\t \n#define OHCI_CLF\t(1 << 1)\t \n#define OHCI_BLF\t(1 << 2)\t \n#define OHCI_OCR\t(1 << 3)\t \n#define OHCI_SOC\t(3 << 16)\t \n\n \n#define OHCI_INTR_SO\t(1 << 0)\t \n#define OHCI_INTR_WDH\t(1 << 1)\t \n#define OHCI_INTR_SF\t(1 << 2)\t \n#define OHCI_INTR_RD\t(1 << 3)\t \n#define OHCI_INTR_UE\t(1 << 4)\t \n#define OHCI_INTR_FNO\t(1 << 5)\t \n#define OHCI_INTR_RHSC\t(1 << 6)\t \n#define OHCI_INTR_OC\t(1 << 30)\t \n#define OHCI_INTR_MIE\t(1 << 31)\t \n\n\n \n\n \n#define RH_PS_CCS            0x00000001\t\t \n#define RH_PS_PES            0x00000002\t\t \n#define RH_PS_PSS            0x00000004\t\t \n#define RH_PS_POCI           0x00000008\t\t \n#define RH_PS_PRS            0x00000010\t\t \n#define RH_PS_PPS            0x00000100\t\t \n#define RH_PS_LSDA           0x00000200\t\t \n#define RH_PS_CSC            0x00010000\t\t \n#define RH_PS_PESC           0x00020000\t\t \n#define RH_PS_PSSC           0x00040000\t\t \n#define RH_PS_OCIC           0x00080000\t\t \n#define RH_PS_PRSC           0x00100000\t\t \n\n \n#define RH_HS_LPS\t     0x00000001\t\t \n#define RH_HS_OCI\t     0x00000002\t\t \n#define RH_HS_DRWE\t     0x00008000\t\t \n#define RH_HS_LPSC\t     0x00010000\t\t \n#define RH_HS_OCIC\t     0x00020000\t\t \n#define RH_HS_CRWE\t     0x80000000\t\t \n\n \n#define RH_B_DR\t\t0x0000ffff\t\t \n#define RH_B_PPCM\t0xffff0000\t\t \n\n \n#define\tRH_A_NDP\t(0xff << 0)\t\t \n#define\tRH_A_PSM\t(1 << 8)\t\t \n#define\tRH_A_NPS\t(1 << 9)\t\t \n#define\tRH_A_DT\t\t(1 << 10)\t\t \n#define\tRH_A_OCPM\t(1 << 11)\t\t \n#define\tRH_A_NOCP\t(1 << 12)\t\t \n#define\tRH_A_POTPGT\t(0xff << 24)\t\t \n\n\n \ntypedef struct urb_priv {\n\tstruct ed\t\t*ed;\n\tu16\t\t\tlength;\t\t\n\tu16\t\t\ttd_cnt;\t\t\n\tstruct list_head\tpending;\n\tstruct td\t\t*td[];\t\t\n\n} urb_priv_t;\n\n#define TD_HASH_SIZE    64     \n\n#define TD_HASH_FUNC(td_dma) ((td_dma ^ (td_dma >> 6)) % TD_HASH_SIZE)\n\n\n \n\nenum ohci_rh_state {\n\tOHCI_RH_HALTED,\n\tOHCI_RH_SUSPENDED,\n\tOHCI_RH_RUNNING\n};\n\nstruct ohci_hcd {\n\tspinlock_t\t\tlock;\n\n\t \n\tstruct ohci_regs __iomem *regs;\n\n\t \n\tstruct ohci_hcca\t*hcca;\n\tdma_addr_t\t\thcca_dma;\n\n\tstruct ed\t\t*ed_rm_list;\t\t \n\n\tstruct ed\t\t*ed_bulktail;\t\t \n\tstruct ed\t\t*ed_controltail;\t \n\tstruct ed\t\t*periodic [NUM_INTS];\t \n\n\tvoid (*start_hnp)(struct ohci_hcd *ohci);\n\n\t \n\tstruct dma_pool\t\t*td_cache;\n\tstruct dma_pool\t\t*ed_cache;\n\tstruct td\t\t*td_hash [TD_HASH_SIZE];\n\tstruct td\t\t*dl_start, *dl_end;\t \n\tstruct list_head\tpending;\n\tstruct list_head\teds_in_use;\t \n\n\t \n\tenum ohci_rh_state\trh_state;\n\tint\t\t\tnum_ports;\n\tint\t\t\tload [NUM_INTS];\n\tu32\t\t\thc_control;\t \n\tunsigned long\t\tnext_statechange;\t \n\tu32\t\t\tfminterval;\t\t \n\tunsigned\t\tautostop:1;\t \n\tunsigned\t\tworking:1;\n\tunsigned\t\trestart_work:1;\n\n\tunsigned long\t\tflags;\t\t \n#define\tOHCI_QUIRK_AMD756\t0x01\t\t\t \n#define\tOHCI_QUIRK_SUPERIO\t0x02\t\t\t \n#define\tOHCI_QUIRK_INITRESET\t0x04\t\t\t \n#define\tOHCI_QUIRK_BE_DESC\t0x08\t\t\t \n#define\tOHCI_QUIRK_BE_MMIO\t0x10\t\t\t \n#define\tOHCI_QUIRK_ZFMICRO\t0x20\t\t\t \n#define\tOHCI_QUIRK_NEC\t\t0x40\t\t\t \n#define\tOHCI_QUIRK_FRAME_NO\t0x80\t\t\t \n#define\tOHCI_QUIRK_HUB_POWER\t0x100\t\t\t \n#define\tOHCI_QUIRK_AMD_PLL\t0x200\t\t\t \n#define\tOHCI_QUIRK_AMD_PREFETCH\t0x400\t\t\t \n#define\tOHCI_QUIRK_GLOBAL_SUSPEND\t0x800\t\t \n#define\tOHCI_QUIRK_QEMU\t\t0x1000\t\t\t \n\n\t\n\n\tunsigned\t\tprev_frame_no;\n\tunsigned\t\twdh_cnt, prev_wdh_cnt;\n\tu32\t\t\tprev_donehead;\n\tstruct timer_list\tio_watchdog;\n\n\tstruct work_struct\tnec_work;\t \n\n\tstruct dentry\t\t*debug_dir;\n\n\t \n\tunsigned long           priv[] __aligned(sizeof(s64));\n\n};\n\n#ifdef CONFIG_USB_PCI\nstatic inline int quirk_nec(struct ohci_hcd *ohci)\n{\n\treturn ohci->flags & OHCI_QUIRK_NEC;\n}\nstatic inline int quirk_zfmicro(struct ohci_hcd *ohci)\n{\n\treturn ohci->flags & OHCI_QUIRK_ZFMICRO;\n}\nstatic inline int quirk_amdiso(struct ohci_hcd *ohci)\n{\n\treturn ohci->flags & OHCI_QUIRK_AMD_PLL;\n}\nstatic inline int quirk_amdprefetch(struct ohci_hcd *ohci)\n{\n\treturn ohci->flags & OHCI_QUIRK_AMD_PREFETCH;\n}\n#else\nstatic inline int quirk_nec(struct ohci_hcd *ohci)\n{\n\treturn 0;\n}\nstatic inline int quirk_zfmicro(struct ohci_hcd *ohci)\n{\n\treturn 0;\n}\nstatic inline int quirk_amdiso(struct ohci_hcd *ohci)\n{\n\treturn 0;\n}\nstatic inline int quirk_amdprefetch(struct ohci_hcd *ohci)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic inline struct ohci_hcd *hcd_to_ohci (struct usb_hcd *hcd)\n{\n\treturn (struct ohci_hcd *) (hcd->hcd_priv);\n}\nstatic inline struct usb_hcd *ohci_to_hcd (const struct ohci_hcd *ohci)\n{\n\treturn container_of ((void *) ohci, struct usb_hcd, hcd_priv);\n}\n\n \n\n#define ohci_dbg(ohci, fmt, args...) \\\n\tdev_dbg (ohci_to_hcd(ohci)->self.controller , fmt , ## args )\n#define ohci_err(ohci, fmt, args...) \\\n\tdev_err (ohci_to_hcd(ohci)->self.controller , fmt , ## args )\n#define ohci_info(ohci, fmt, args...) \\\n\tdev_info (ohci_to_hcd(ohci)->self.controller , fmt , ## args )\n#define ohci_warn(ohci, fmt, args...) \\\n\tdev_warn (ohci_to_hcd(ohci)->self.controller , fmt , ## args )\n\n \n\n \n\n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_DESC\n#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN\n#define big_endian_desc(ohci)\t(ohci->flags & OHCI_QUIRK_BE_DESC)\n#else\n#define big_endian_desc(ohci)\t1\t\t \n#endif\n#else\n#define big_endian_desc(ohci)\t0\t\t \n#endif\n\n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\n#ifdef CONFIG_USB_OHCI_LITTLE_ENDIAN\n#define big_endian_mmio(ohci)\t(ohci->flags & OHCI_QUIRK_BE_MMIO)\n#else\n#define big_endian_mmio(ohci)\t1\t\t \n#endif\n#else\n#define big_endian_mmio(ohci)\t0\t\t \n#endif\n\n \nstatic inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,\n\t\t\t\t\t__hc32 __iomem * regs)\n{\n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\n\treturn big_endian_mmio(ohci) ?\n\t\treadl_be (regs) :\n\t\treadl (regs);\n#else\n\treturn readl (regs);\n#endif\n}\n\nstatic inline void _ohci_writel (const struct ohci_hcd *ohci,\n\t\t\t\t const unsigned int val, __hc32 __iomem *regs)\n{\n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\n\tbig_endian_mmio(ohci) ?\n\t\twritel_be (val, regs) :\n\t\twritel (val, regs);\n#else\n\t\twritel (val, regs);\n#endif\n}\n\n#define ohci_readl(o,r)\t\t_ohci_readl(o,r)\n#define ohci_writel(o,v,r)\t_ohci_writel(o,v,r)\n\n\n \n\n \nstatic inline __hc16 cpu_to_hc16 (const struct ohci_hcd *ohci, const u16 x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\t(__force __hc16)cpu_to_be16(x) :\n\t\t(__force __hc16)cpu_to_le16(x);\n}\n\nstatic inline __hc16 cpu_to_hc16p (const struct ohci_hcd *ohci, const u16 *x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tcpu_to_be16p(x) :\n\t\tcpu_to_le16p(x);\n}\n\nstatic inline __hc32 cpu_to_hc32 (const struct ohci_hcd *ohci, const u32 x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\t(__force __hc32)cpu_to_be32(x) :\n\t\t(__force __hc32)cpu_to_le32(x);\n}\n\nstatic inline __hc32 cpu_to_hc32p (const struct ohci_hcd *ohci, const u32 *x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tcpu_to_be32p(x) :\n\t\tcpu_to_le32p(x);\n}\n\n \nstatic inline u16 hc16_to_cpu (const struct ohci_hcd *ohci, const __hc16 x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tbe16_to_cpu((__force __be16)x) :\n\t\tle16_to_cpu((__force __le16)x);\n}\n\nstatic inline u16 hc16_to_cpup (const struct ohci_hcd *ohci, const __hc16 *x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tbe16_to_cpup((__force __be16 *)x) :\n\t\tle16_to_cpup((__force __le16 *)x);\n}\n\nstatic inline u32 hc32_to_cpu (const struct ohci_hcd *ohci, const __hc32 x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tbe32_to_cpu((__force __be32)x) :\n\t\tle32_to_cpu((__force __le32)x);\n}\n\nstatic inline u32 hc32_to_cpup (const struct ohci_hcd *ohci, const __hc32 *x)\n{\n\treturn big_endian_desc(ohci) ?\n\t\tbe32_to_cpup((__force __be32 *)x) :\n\t\tle32_to_cpup((__force __le32 *)x);\n}\n\n \n\n \n\nstatic inline u16 ohci_frame_no(const struct ohci_hcd *ohci)\n{\n\tu32 tmp;\n\tif (big_endian_desc(ohci)) {\n\t\ttmp = be32_to_cpup((__force __be32 *)&ohci->hcca->frame_no);\n\t\tif (!(ohci->flags & OHCI_QUIRK_FRAME_NO))\n\t\t\ttmp >>= 16;\n\t} else\n\t\ttmp = le32_to_cpup((__force __le32 *)&ohci->hcca->frame_no);\n\n\treturn (u16)tmp;\n}\n\nstatic inline __hc16 *ohci_hwPSWp(const struct ohci_hcd *ohci,\n                                 const struct td *td, int index)\n{\n\treturn (__hc16 *)(big_endian_desc(ohci) ?\n\t\t\t&td->hwPSW[index ^ 1] : &td->hwPSW[index]);\n}\n\nstatic inline u16 ohci_hwPSW(const struct ohci_hcd *ohci,\n                               const struct td *td, int index)\n{\n\treturn hc16_to_cpup(ohci, ohci_hwPSWp(ohci, td, index));\n}\n\n \n\n#define\tFI\t\t\t0x2edf\t\t \n#define\tFSMP(fi)\t\t(0x7fff & ((6 * ((fi) - 210)) / 7))\n#define\tFIT\t\t\t(1 << 31)\n#define LSTHRESH\t\t0x628\t\t \n\nstatic inline void periodic_reinit (struct ohci_hcd *ohci)\n{\n\tu32\tfi = ohci->fminterval & 0x03fff;\n\tu32\tfit = ohci_readl(ohci, &ohci->regs->fminterval) & FIT;\n\n\tohci_writel (ohci, (fit ^ FIT) | ohci->fminterval,\n\t\t\t\t\t\t&ohci->regs->fminterval);\n\tohci_writel (ohci, ((9 * fi) / 10) & 0x3fff,\n\t\t\t\t\t\t&ohci->regs->periodicstart);\n}\n\n \n#define read_roothub(hc, register, mask) ({ \\\n\tu32 temp = ohci_readl (hc, &hc->regs->roothub.register); \\\n\tif (temp == -1) \\\n\t\thc->rh_state = OHCI_RH_HALTED; \\\n\telse if (hc->flags & OHCI_QUIRK_AMD756) \\\n\t\twhile (temp & mask) \\\n\t\t\ttemp = ohci_readl (hc, &hc->regs->roothub.register); \\\n\ttemp; })\n\nstatic inline u32 roothub_a (struct ohci_hcd *hc)\n\t{ return read_roothub (hc, a, 0xfc0fe000); }\nstatic inline u32 roothub_b (struct ohci_hcd *hc)\n\t{ return ohci_readl (hc, &hc->regs->roothub.b); }\nstatic inline u32 roothub_status (struct ohci_hcd *hc)\n\t{ return ohci_readl (hc, &hc->regs->roothub.status); }\nstatic inline u32 roothub_portstatus (struct ohci_hcd *hc, int i)\n\t{ return read_roothub (hc, portstatus [i], 0xffe0fce0); }\n\n \n\nstruct ohci_driver_overrides {\n\tconst char\t*product_desc;\n\tsize_t\t\textra_priv_size;\n\tint\t\t(*reset)(struct usb_hcd *hcd);\n};\n\nextern void\tohci_init_driver(struct hc_driver *drv,\n\t\t\t\tconst struct ohci_driver_overrides *over);\nextern int\tohci_restart(struct ohci_hcd *ohci);\nextern int\tohci_setup(struct usb_hcd *hcd);\nextern int\tohci_suspend(struct usb_hcd *hcd, bool do_wakeup);\nextern int\tohci_resume(struct usb_hcd *hcd, bool hibernated);\nextern int\tohci_hub_control(struct usb_hcd\t*hcd, u16 typeReq, u16 wValue,\n\t\t\t\t u16 wIndex, char *buf, u16 wLength);\nextern int\tohci_hub_status_data(struct usb_hcd *hcd, char *buf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}