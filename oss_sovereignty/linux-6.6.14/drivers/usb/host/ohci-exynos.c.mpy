{
  "module_name": "ohci-exynos.c",
  "hash_id": "9638419205753b45d32a2d4fc790a237d463dfd075aef587a8f771e04752690e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ohci.h\"\n\n#define DRIVER_DESC \"OHCI Exynos driver\"\n\nstatic struct hc_driver __read_mostly exynos_ohci_hc_driver;\n\n#define to_exynos_ohci(hcd) (struct exynos_ohci_hcd *)(hcd_to_ohci(hcd)->priv)\n\n#define PHY_NUMBER 3\n\nstruct exynos_ohci_hcd {\n\tstruct clk *clk;\n\tstruct device_node *of_node;\n\tstruct phy *phy[PHY_NUMBER];\n\tbool legacy_phy;\n};\n\nstatic int exynos_ohci_get_phy(struct device *dev,\n\t\t\t\tstruct exynos_ohci_hcd *exynos_ohci)\n{\n\tstruct device_node *child;\n\tstruct phy *phy;\n\tint phy_number, num_phys;\n\tint ret;\n\n\t \n\tnum_phys = of_count_phandle_with_args(dev->of_node, \"phys\",\n\t\t\t\t\t      \"#phy-cells\");\n\tfor (phy_number = 0; phy_number < num_phys; phy_number++) {\n\t\tphy = devm_of_phy_get_by_index(dev, dev->of_node, phy_number);\n\t\tif (IS_ERR(phy))\n\t\t\treturn PTR_ERR(phy);\n\t\texynos_ohci->phy[phy_number] = phy;\n\t}\n\tif (num_phys > 0)\n\t\treturn 0;\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tret = of_property_read_u32(child, \"reg\", &phy_number);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to parse device tree\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (phy_number >= PHY_NUMBER) {\n\t\t\tdev_err(dev, \"Invalid number of PHYs\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tphy = devm_of_phy_optional_get(dev, child, NULL);\n\t\texynos_ohci->phy[phy_number] = phy;\n\t\tif (IS_ERR(phy)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\t}\n\n\texynos_ohci->legacy_phy = true;\n\treturn 0;\n}\n\nstatic int exynos_ohci_phy_enable(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ohci_hcd *exynos_ohci = to_exynos_ohci(hcd);\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; ret == 0 && i < PHY_NUMBER; i++)\n\t\tret = phy_power_on(exynos_ohci->phy[i]);\n\tif (ret)\n\t\tfor (i--; i >= 0; i--)\n\t\t\tphy_power_off(exynos_ohci->phy[i]);\n\n\treturn ret;\n}\n\nstatic void exynos_ohci_phy_disable(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ohci_hcd *exynos_ohci = to_exynos_ohci(hcd);\n\tint i;\n\n\tfor (i = 0; i < PHY_NUMBER; i++)\n\t\tphy_power_off(exynos_ohci->phy[i]);\n}\n\nstatic int exynos_ohci_probe(struct platform_device *pdev)\n{\n\tstruct exynos_ohci_hcd *exynos_ohci;\n\tstruct usb_hcd *hcd;\n\tstruct resource *res;\n\tint irq;\n\tint err;\n\n\t \n\terr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\thcd = usb_create_hcd(&exynos_ohci_hc_driver,\n\t\t\t\t&pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tdev_err(&pdev->dev, \"Unable to create HCD\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\texynos_ohci = to_exynos_ohci(hcd);\n\n\terr = exynos_ohci_get_phy(&pdev->dev, exynos_ohci);\n\tif (err)\n\t\tgoto fail_clk;\n\n\texynos_ohci->clk = devm_clk_get(&pdev->dev, \"usbhost\");\n\n\tif (IS_ERR(exynos_ohci->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get usbhost clock\\n\");\n\t\terr = PTR_ERR(exynos_ohci->clk);\n\t\tgoto fail_clk;\n\t}\n\n\terr = clk_prepare_enable(exynos_ohci->clk);\n\tif (err)\n\t\tgoto fail_clk;\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto fail_io;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto fail_io;\n\t}\n\n\tplatform_set_drvdata(pdev, hcd);\n\n\terr = exynos_ohci_phy_enable(&pdev->dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable USB phy\\n\");\n\t\tgoto fail_io;\n\t}\n\n\t \n\texynos_ohci->of_node = pdev->dev.of_node;\n\tif (exynos_ohci->legacy_phy)\n\t\tpdev->dev.of_node = NULL;\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to add USB HCD\\n\");\n\t\tgoto fail_add_hcd;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\nfail_add_hcd:\n\texynos_ohci_phy_disable(&pdev->dev);\n\tpdev->dev.of_node = exynos_ohci->of_node;\nfail_io:\n\tclk_disable_unprepare(exynos_ohci->clk);\nfail_clk:\n\tusb_put_hcd(hcd);\n\treturn err;\n}\n\nstatic void exynos_ohci_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct exynos_ohci_hcd *exynos_ohci = to_exynos_ohci(hcd);\n\n\tpdev->dev.of_node = exynos_ohci->of_node;\n\n\tusb_remove_hcd(hcd);\n\n\texynos_ohci_phy_disable(&pdev->dev);\n\n\tclk_disable_unprepare(exynos_ohci->clk);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic void exynos_ohci_shutdown(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tif (hcd->driver->shutdown)\n\t\thcd->driver->shutdown(hcd);\n}\n\n#ifdef CONFIG_PM\nstatic int exynos_ohci_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ohci_hcd *exynos_ohci = to_exynos_ohci(hcd);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint rc = ohci_suspend(hcd, do_wakeup);\n\n\tif (rc)\n\t\treturn rc;\n\n\texynos_ohci_phy_disable(dev);\n\n\tclk_disable_unprepare(exynos_ohci->clk);\n\n\treturn 0;\n}\n\nstatic int exynos_ohci_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd\t\t\t= dev_get_drvdata(dev);\n\tstruct exynos_ohci_hcd *exynos_ohci\t= to_exynos_ohci(hcd);\n\tint ret;\n\n\tclk_prepare_enable(exynos_ohci->clk);\n\n\tret = exynos_ohci_phy_enable(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable USB phy\\n\");\n\t\tclk_disable_unprepare(exynos_ohci->clk);\n\t\treturn ret;\n\t}\n\n\tohci_resume(hcd, false);\n\n\treturn 0;\n}\n#else\n#define exynos_ohci_suspend\tNULL\n#define exynos_ohci_resume\tNULL\n#endif\n\nstatic const struct ohci_driver_overrides exynos_overrides __initconst = {\n\t.extra_priv_size =\tsizeof(struct exynos_ohci_hcd),\n};\n\nstatic const struct dev_pm_ops exynos_ohci_pm_ops = {\n\t.suspend\t= exynos_ohci_suspend,\n\t.resume\t\t= exynos_ohci_resume,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id exynos_ohci_match[] = {\n\t{ .compatible = \"samsung,exynos4210-ohci\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_ohci_match);\n#endif\n\nstatic struct platform_driver exynos_ohci_driver = {\n\t.probe\t\t= exynos_ohci_probe,\n\t.remove_new\t= exynos_ohci_remove,\n\t.shutdown\t= exynos_ohci_shutdown,\n\t.driver = {\n\t\t.name\t= \"exynos-ohci\",\n\t\t.pm\t= &exynos_ohci_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(exynos_ohci_match),\n\t}\n};\nstatic int __init ohci_exynos_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&exynos_ohci_hc_driver, &exynos_overrides);\n\treturn platform_driver_register(&exynos_ohci_driver);\n}\nmodule_init(ohci_exynos_init);\n\nstatic void __exit ohci_exynos_cleanup(void)\n{\n\tplatform_driver_unregister(&exynos_ohci_driver);\n}\nmodule_exit(ohci_exynos_cleanup);\n\nMODULE_ALIAS(\"platform:exynos-ohci\");\nMODULE_AUTHOR(\"Jingoo Han <jg1.han@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}