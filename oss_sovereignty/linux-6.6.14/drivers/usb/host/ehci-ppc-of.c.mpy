{
  "module_name": "ehci-ppc-of.c",
  "hash_id": "cbb55925b305dd1a3df97012fee01deeeedf40cb5a09457f96418ad8383a6eff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-ppc-of.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/signal.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n\n\nstatic const struct hc_driver ehci_ppc_of_hc_driver = {\n\t.description\t\t= hcd_name,\n\t.product_desc\t\t= \"OF EHCI\",\n\t.hcd_priv_size\t\t= sizeof(struct ehci_hcd),\n\n\t \n\t.irq\t\t\t= ehci_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n\t \n\t.reset\t\t\t= ehci_setup,\n\t.start\t\t\t= ehci_run,\n\t.stop\t\t\t= ehci_stop,\n\t.shutdown\t\t= ehci_shutdown,\n\n\t \n\t.urb_enqueue\t\t= ehci_urb_enqueue,\n\t.urb_dequeue\t\t= ehci_urb_dequeue,\n\t.endpoint_disable\t= ehci_endpoint_disable,\n\t.endpoint_reset\t\t= ehci_endpoint_reset,\n\n\t \n\t.get_frame_number\t= ehci_get_frame,\n\n\t \n\t.hub_status_data\t= ehci_hub_status_data,\n\t.hub_control\t\t= ehci_hub_control,\n#ifdef\tCONFIG_PM\n\t.bus_suspend\t\t= ehci_bus_suspend,\n\t.bus_resume\t\t= ehci_bus_resume,\n#endif\n\t.relinquish_port\t= ehci_relinquish_port,\n\t.port_handed_over\t= ehci_port_handed_over,\n\n\t.clear_tt_buffer_complete\t= ehci_clear_tt_buffer_complete,\n};\n\n\n \n#define PPC440EPX_EHCI0_INSREG_BMT\t(0x1 << 0)\nstatic int\nppc44x_enable_bmt(struct device_node *dn)\n{\n\t__iomem u32 *insreg_virt;\n\n\tinsreg_virt = of_iomap(dn, 1);\n\tif (!insreg_virt)\n\t\treturn  -EINVAL;\n\n\tout_be32(insreg_virt + 3, PPC440EPX_EHCI0_INSREG_BMT);\n\n\tiounmap(insreg_virt);\n\treturn 0;\n}\n\n\nstatic int ehci_hcd_ppc_of_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd\t*ehci = NULL;\n\tstruct resource res;\n\tint irq;\n\tint rv;\n\n\tstruct device_node *np;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdev_dbg(&op->dev, \"initializing PPC-OF USB Controller\\n\");\n\n\trv = of_address_to_resource(dn, 0, &res);\n\tif (rv)\n\t\treturn rv;\n\n\thcd = usb_create_hcd(&ehci_ppc_of_hc_driver, &op->dev, \"PPC-OF USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = res.start;\n\thcd->rsrc_len = resource_size(&res);\n\n\tirq = irq_of_parse_and_map(dn, 0);\n\tif (!irq) {\n\t\tdev_err(&op->dev, \"%s: irq_of_parse_and_map failed\\n\",\n\t\t\t__FILE__);\n\t\trv = -EBUSY;\n\t\tgoto err_irq;\n\t}\n\n\thcd->regs = devm_ioremap_resource(&op->dev, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\trv = PTR_ERR(hcd->regs);\n\t\tgoto err_ioremap;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\tnp = of_find_compatible_node(NULL, NULL, \"ibm,usb-ohci-440epx\");\n\tif (np != NULL) {\n\t\t \n\t\tif (!of_address_to_resource(np, 0, &res))\n\t\t\tehci->ohci_hcctrl_reg =\n\t\t\t\tdevm_ioremap(&op->dev,\n\t\t\t\t\t     res.start + OHCI_HCCTRL_OFFSET,\n\t\t\t\t\t     OHCI_HCCTRL_LEN);\n\t\telse\n\t\t\tpr_debug(\"%s: no ohci offset in fdt\\n\", __FILE__);\n\t\tif (!ehci->ohci_hcctrl_reg) {\n\t\t\tpr_debug(\"%s: ioremap for ohci hcctrl failed\\n\", __FILE__);\n\t\t} else {\n\t\t\tehci->has_amcc_usb23 = 1;\n\t\t}\n\t\tof_node_put(np);\n\t}\n\n\tif (of_property_read_bool(dn, \"big-endian\")) {\n\t\tehci->big_endian_mmio = 1;\n\t\tehci->big_endian_desc = 1;\n\t}\n\tif (of_property_read_bool(dn, \"big-endian-regs\"))\n\t\tehci->big_endian_mmio = 1;\n\tif (of_property_read_bool(dn, \"big-endian-desc\"))\n\t\tehci->big_endian_desc = 1;\n\n\tehci->caps = hcd->regs;\n\n\tif (of_device_is_compatible(dn, \"ibm,usb-ehci-440epx\")) {\n\t\trv = ppc44x_enable_bmt(dn);\n\t\tehci_dbg(ehci, \"Break Memory Transfer (BMT) is %senabled!\\n\",\n\t\t\t\trv ? \"NOT \": \"\");\n\t}\n\n\trv = usb_add_hcd(hcd, irq, 0);\n\tif (rv)\n\t\tgoto err_ioremap;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\nerr_ioremap:\n\tirq_dispose_mapping(irq);\nerr_irq:\n\tusb_put_hcd(hcd);\n\n\treturn rv;\n}\n\n\nstatic void ehci_hcd_ppc_of_remove(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\n\tstruct device_node *np;\n\tstruct resource res;\n\n\tdev_dbg(&op->dev, \"stopping PPC-OF USB Controller\\n\");\n\n\tusb_remove_hcd(hcd);\n\n\tirq_dispose_mapping(hcd->irq);\n\n\t \n\tif (ehci->has_amcc_usb23) {\n\t\tnp = of_find_compatible_node(NULL, NULL, \"ibm,usb-ohci-440epx\");\n\t\tif (np != NULL) {\n\t\t\tif (!of_address_to_resource(np, 0, &res))\n\t\t\t\tif (!request_mem_region(res.start,\n\t\t\t\t\t\t\t    0x4, hcd_name))\n\t\t\t\t\tset_ohci_hcfs(ehci, 1);\n\t\t\t\telse\n\t\t\t\t\trelease_mem_region(res.start, 0x4);\n\t\t\telse\n\t\t\t\tpr_debug(\"%s: no ohci offset in fdt\\n\", __FILE__);\n\t\t\tof_node_put(np);\n\t\t}\n\t}\n\tusb_put_hcd(hcd);\n}\n\n\nstatic const struct of_device_id ehci_hcd_ppc_of_match[] = {\n\t{\n\t\t.compatible = \"usb-ehci\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehci_hcd_ppc_of_match);\n\n\nstatic struct platform_driver ehci_hcd_ppc_of_driver = {\n\t.probe\t\t= ehci_hcd_ppc_of_probe,\n\t.remove_new\t= ehci_hcd_ppc_of_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name = \"ppc-of-ehci\",\n\t\t.of_match_table = ehci_hcd_ppc_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}