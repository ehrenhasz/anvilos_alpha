{
  "module_name": "ehci-mv.c",
  "hash_id": "f79360c0f9abf7690e4cf12d244342c1b6e024140cb6993ff1c3b0b2d6b00fc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-mv.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/of.h>\n#include <linux/platform_data/mv_usb.h>\n#include <linux/io.h>\n\n#include <linux/usb/hcd.h>\n\n#include \"ehci.h\"\n\n \n#define U2x_CAPREGS_OFFSET       0x100\n\n#define CAPLENGTH_MASK         (0xff)\n\n#define hcd_to_ehci_hcd_mv(h) ((struct ehci_hcd_mv *)hcd_to_ehci(h)->priv)\n\nstruct ehci_hcd_mv {\n\t \n\tint mode;\n\n\tvoid __iomem *base;\n\tvoid __iomem *cap_regs;\n\tvoid __iomem *op_regs;\n\n\tstruct usb_phy *otg;\n\tstruct clk *clk;\n\n\tstruct phy *phy;\n\n\tint (*set_vbus)(unsigned int vbus);\n};\n\nstatic int mv_ehci_enable(struct ehci_hcd_mv *ehci_mv)\n{\n\tint retval;\n\n\tretval = clk_prepare_enable(ehci_mv->clk);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = phy_init(ehci_mv->phy);\n\tif (retval)\n\t\tclk_disable_unprepare(ehci_mv->clk);\n\n\treturn retval;\n}\n\nstatic void mv_ehci_disable(struct ehci_hcd_mv *ehci_mv)\n{\n\tphy_exit(ehci_mv->phy);\n\tclk_disable_unprepare(ehci_mv->clk);\n}\n\nstatic int mv_ehci_reset(struct usb_hcd *hcd)\n{\n\tstruct device *dev = hcd->self.controller;\n\tstruct ehci_hcd_mv *ehci_mv = hcd_to_ehci_hcd_mv(hcd);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tu32 status;\n\tint retval;\n\n\tif (ehci_mv == NULL) {\n\t\tdev_err(dev, \"Can not find private ehci data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thcd->has_tt = 1;\n\n\tretval = ehci_setup(hcd);\n\tif (retval)\n\t\tdev_err(dev, \"ehci_setup failed %d\\n\", retval);\n\n\tif (of_usb_get_phy_mode(dev->of_node) == USBPHY_INTERFACE_MODE_HSIC) {\n\t\tstatus = ehci_readl(ehci, &ehci->regs->port_status[0]);\n\t\tstatus |= PORT_TEST_FORCE;\n\t\tehci_writel(ehci, status, &ehci->regs->port_status[0]);\n\t\tstatus &= ~PORT_TEST_FORCE;\n\t\tehci_writel(ehci, status, &ehci->regs->port_status[0]);\n\t}\n\n\treturn retval;\n}\n\nstatic struct hc_driver __read_mostly ehci_platform_hc_driver;\n\nstatic const struct ehci_driver_overrides platform_overrides __initconst = {\n\t.reset =\t\tmv_ehci_reset,\n\t.extra_priv_size =\tsizeof(struct ehci_hcd_mv),\n};\n\nstatic int mv_ehci_probe(struct platform_device *pdev)\n{\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tstruct ehci_hcd_mv *ehci_mv;\n\tstruct resource *r;\n\tint retval;\n\tu32 offset;\n\tu32 status;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&ehci_platform_hc_driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hcd);\n\tehci_mv = hcd_to_ehci_hcd_mv(hcd);\n\n\tehci_mv->mode = MV_USB_MODE_HOST;\n\tif (pdata) {\n\t\tehci_mv->mode = pdata->mode;\n\t\tehci_mv->set_vbus = pdata->set_vbus;\n\t}\n\n\tehci_mv->phy = devm_phy_optional_get(&pdev->dev, \"usb\");\n\tif (IS_ERR(ehci_mv->phy)) {\n\t\tretval = PTR_ERR(ehci_mv->phy);\n\t\tif (retval != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"Failed to get phy.\\n\");\n\t\tgoto err_put_hcd;\n\t}\n\n\tehci_mv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ehci_mv->clk)) {\n\t\tdev_err(&pdev->dev, \"error getting clock\\n\");\n\t\tretval = PTR_ERR(ehci_mv->clk);\n\t\tgoto err_put_hcd;\n\t}\n\n\tehci_mv->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(ehci_mv->base)) {\n\t\tretval = PTR_ERR(ehci_mv->base);\n\t\tgoto err_put_hcd;\n\t}\n\n\tretval = mv_ehci_enable(ehci_mv);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"init phy error %d\\n\", retval);\n\t\tgoto err_put_hcd;\n\t}\n\n\tehci_mv->cap_regs =\n\t\t(void __iomem *) ((unsigned long) ehci_mv->base + U2x_CAPREGS_OFFSET);\n\toffset = readl(ehci_mv->cap_regs) & CAPLENGTH_MASK;\n\tehci_mv->op_regs =\n\t\t(void __iomem *) ((unsigned long) ehci_mv->cap_regs + offset);\n\n\thcd->rsrc_start = r->start;\n\thcd->rsrc_len = resource_size(r);\n\thcd->regs = ehci_mv->op_regs;\n\n\tretval = platform_get_irq(pdev, 0);\n\tif (retval < 0)\n\t\tgoto err_disable_clk;\n\thcd->irq = retval;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = (struct ehci_caps __iomem *) ehci_mv->cap_regs;\n\n\tif (ehci_mv->mode == MV_USB_MODE_OTG) {\n\t\tehci_mv->otg = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\n\t\tif (IS_ERR(ehci_mv->otg)) {\n\t\t\tretval = PTR_ERR(ehci_mv->otg);\n\n\t\t\tif (retval == -ENXIO)\n\t\t\t\tdev_info(&pdev->dev, \"MV_USB_MODE_OTG \"\n\t\t\t\t\t\t\"must have CONFIG_USB_PHY enabled\\n\");\n\t\t\telse\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\t\"unable to find transceiver\\n\");\n\t\t\tgoto err_disable_clk;\n\t\t}\n\n\t\tretval = otg_set_host(ehci_mv->otg->otg, &hcd->self);\n\t\tif (retval < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"unable to register with transceiver\\n\");\n\t\t\tretval = -ENODEV;\n\t\t\tgoto err_disable_clk;\n\t\t}\n\t\t \n\t\tmv_ehci_disable(ehci_mv);\n\t} else {\n\t\tif (ehci_mv->set_vbus)\n\t\t\tehci_mv->set_vbus(1);\n\n\t\tretval = usb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\n\t\tif (retval) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to add hcd with err %d\\n\", retval);\n\t\t\tgoto err_set_vbus;\n\t\t}\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t}\n\n\tif (of_usb_get_phy_mode(pdev->dev.of_node) == USBPHY_INTERFACE_MODE_HSIC) {\n\t\tstatus = ehci_readl(ehci, &ehci->regs->port_status[0]);\n\t\t \n\t\tstatus |= BIT(25);\n\t\tstatus &= ~GENMASK(31, 30);\n\t\tehci_writel(ehci, status, &ehci->regs->port_status[0]);\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t \"successful find EHCI device with regs 0x%p irq %d\"\n\t\t \" working in %s mode\\n\", hcd->regs, hcd->irq,\n\t\t ehci_mv->mode == MV_USB_MODE_OTG ? \"OTG\" : \"Host\");\n\n\treturn 0;\n\nerr_set_vbus:\n\tif (ehci_mv->set_vbus)\n\t\tehci_mv->set_vbus(0);\nerr_disable_clk:\n\tmv_ehci_disable(ehci_mv);\nerr_put_hcd:\n\tusb_put_hcd(hcd);\n\n\treturn retval;\n}\n\nstatic void mv_ehci_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct ehci_hcd_mv *ehci_mv = hcd_to_ehci_hcd_mv(hcd);\n\n\tif (hcd->rh_registered)\n\t\tusb_remove_hcd(hcd);\n\n\tif (!IS_ERR_OR_NULL(ehci_mv->otg))\n\t\totg_set_host(ehci_mv->otg->otg, NULL);\n\n\tif (ehci_mv->mode == MV_USB_MODE_HOST) {\n\t\tif (ehci_mv->set_vbus)\n\t\t\tehci_mv->set_vbus(0);\n\n\t\tmv_ehci_disable(ehci_mv);\n\t}\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct platform_device_id ehci_id_table[] = {\n\t{\"pxa-u2oehci\", 0},\n\t{\"pxa-sph\", 0},\n\t{},\n};\n\nstatic void mv_ehci_shutdown(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tif (!hcd->rh_registered)\n\t\treturn;\n\n\tif (hcd->driver->shutdown)\n\t\thcd->driver->shutdown(hcd);\n}\n\nstatic const struct of_device_id ehci_mv_dt_ids[] = {\n\t{ .compatible = \"marvell,pxau2o-ehci\", },\n\t{},\n};\n\nstatic struct platform_driver ehci_mv_driver = {\n\t.probe = mv_ehci_probe,\n\t.remove_new = mv_ehci_remove,\n\t.shutdown = mv_ehci_shutdown,\n\t.driver = {\n\t\t.name = \"mv-ehci\",\n\t\t.bus = &platform_bus_type,\n\t\t.of_match_table = ehci_mv_dt_ids,\n\t},\n\t.id_table = ehci_id_table,\n};\n\nstatic int __init ehci_platform_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\n\treturn platform_driver_register(&ehci_mv_driver);\n}\nmodule_init(ehci_platform_init);\n\nstatic void __exit ehci_platform_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_mv_driver);\n}\nmodule_exit(ehci_platform_cleanup);\n\nMODULE_DESCRIPTION(\"Marvell EHCI driver\");\nMODULE_AUTHOR(\"Chao Xie <chao.xie@marvell.com>\");\nMODULE_AUTHOR(\"Neil Zhang <zhangwm@marvell.com>\");\nMODULE_ALIAS(\"mv-ehci\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(of, ehci_mv_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}