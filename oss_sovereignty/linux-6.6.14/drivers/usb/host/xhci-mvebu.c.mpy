{
  "module_name": "xhci-mvebu.c",
  "hash_id": "5e8f10224445315a6e06699844c99ab9d50eaa12f3d85f5124d506ff32606698",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-mvebu.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mbus.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"xhci-mvebu.h\"\n#include \"xhci.h\"\n\n#define USB3_MAX_WINDOWS\t4\n#define USB3_WIN_CTRL(w)\t(0x0 + ((w) * 8))\n#define USB3_WIN_BASE(w)\t(0x4 + ((w) * 8))\n\nstatic void xhci_mvebu_mbus_config(void __iomem *base,\n\t\t\tconst struct mbus_dram_target_info *dram)\n{\n\tint win;\n\n\t \n\tfor (win = 0; win < USB3_MAX_WINDOWS; win++) {\n\t\twritel(0, base + USB3_WIN_CTRL(win));\n\t\twritel(0, base + USB3_WIN_BASE(win));\n\t}\n\n\t \n\tfor (win = 0; win < dram->num_cs; win++) {\n\t\tconst struct mbus_dram_window *cs = &dram->cs[win];\n\n\t\twritel(((cs->size - 1) & 0xffff0000) | (cs->mbus_attr << 8) |\n\t\t       (dram->mbus_dram_target_id << 4) | 1,\n\t\t       base + USB3_WIN_CTRL(win));\n\n\t\twritel((cs->base & 0xffff0000), base + USB3_WIN_BASE(win));\n\t}\n}\n\nint xhci_mvebu_mbus_init_quirk(struct usb_hcd *hcd)\n{\n\tstruct device *dev = hcd->self.controller;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct resource\t*res;\n\tvoid __iomem *base;\n\tconst struct mbus_dram_target_info *dram;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\t \n\tbase = ioremap(res->start, resource_size(res));\n\tif (!base)\n\t\treturn -ENODEV;\n\n\tdram = mv_mbus_dram_info();\n\txhci_mvebu_mbus_config(base, dram);\n\n\t \n\tiounmap(base);\n\n\treturn 0;\n}\n\nint xhci_mvebu_a3700_init_quirk(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\n\t \n\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}