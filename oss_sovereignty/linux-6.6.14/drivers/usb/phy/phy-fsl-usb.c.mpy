{
  "module_name": "phy-fsl-usb.c",
  "hash_id": "7e9408f365a900f87ddecb64b36c2330ce307901af20997cad8c94b3018390b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-fsl-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/workqueue.h>\n#include <linux/time.h>\n#include <linux/fsl_devices.h>\n#include <linux/platform_device.h>\n#include <linux/uaccess.h>\n\n#include <asm/unaligned.h>\n\n#include \"phy-fsl-usb.h\"\n\n#ifdef VERBOSE\n#define VDBG(fmt, args...) pr_debug(\"[%s]  \" fmt, \\\n\t\t\t\t __func__, ## args)\n#else\n#define VDBG(stuff...)\tdo {} while (0)\n#endif\n\n#define DRIVER_VERSION \"Rev. 1.55\"\n#define DRIVER_AUTHOR \"Jerry Huang/Li Yang\"\n#define DRIVER_DESC \"Freescale USB OTG Transceiver Driver\"\n#define DRIVER_INFO DRIVER_DESC \" \" DRIVER_VERSION\n\nstatic const char driver_name[] = \"fsl-usb2-otg\";\n\nconst pm_message_t otg_suspend_state = {\n\t.event = 1,\n};\n\n#define HA_DATA_PULSE\n\nstatic struct usb_dr_mmap *usb_dr_regs;\nstatic struct fsl_otg *fsl_otg_dev;\nstatic int srp_wait_done;\n\n \nstruct fsl_otg_timer *a_wait_vrise_tmr, *a_wait_bcon_tmr, *a_aidl_bdis_tmr,\n\t*b_ase0_brst_tmr, *b_se0_srp_tmr;\n\n \nstruct fsl_otg_timer *b_data_pulse_tmr, *b_vbus_pulse_tmr, *b_srp_fail_tmr,\n\t*b_srp_wait_tmr, *a_wait_enum_tmr;\n\nstatic struct list_head active_timers;\n\nstatic const struct fsl_otg_config fsl_otg_initdata = {\n\t.otg_port = 1,\n};\n\n#ifdef CONFIG_PPC32\nstatic u32 _fsl_readl_be(const unsigned __iomem *p)\n{\n\treturn in_be32(p);\n}\n\nstatic u32 _fsl_readl_le(const unsigned __iomem *p)\n{\n\treturn in_le32(p);\n}\n\nstatic void _fsl_writel_be(u32 v, unsigned __iomem *p)\n{\n\tout_be32(p, v);\n}\n\nstatic void _fsl_writel_le(u32 v, unsigned __iomem *p)\n{\n\tout_le32(p, v);\n}\n\nstatic u32 (*_fsl_readl)(const unsigned __iomem *p);\nstatic void (*_fsl_writel)(u32 v, unsigned __iomem *p);\n\n#define fsl_readl(p)\t\t(*_fsl_readl)((p))\n#define fsl_writel(v, p)\t(*_fsl_writel)((v), (p))\n\n#else\n#define fsl_readl(addr)\t\treadl(addr)\n#define fsl_writel(val, addr)\twritel(val, addr)\n#endif  \n\nint write_ulpi(u8 addr, u8 data)\n{\n\tu32 temp;\n\n\ttemp = 0x60000000 | (addr << 16) | data;\n\tfsl_writel(temp, &usb_dr_regs->ulpiview);\n\treturn 0;\n}\n\n \n \n\n \nvoid fsl_otg_chrg_vbus(struct otg_fsm *fsm, int on)\n{\n\tu32 tmp;\n\n\ttmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\n\n\tif (on)\n\t\t \n\t\ttmp = (tmp & ~OTGSC_CTRL_VBUS_DISCHARGE) |\n\t\t\tOTGSC_CTRL_VBUS_CHARGE;\n\telse\n\t\t \n\t\ttmp &= ~OTGSC_CTRL_VBUS_CHARGE;\n\n\tfsl_writel(tmp, &usb_dr_regs->otgsc);\n}\n\n \nvoid fsl_otg_dischrg_vbus(int on)\n{\n\tu32 tmp;\n\n\ttmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\n\n\tif (on)\n\t\t \n\t\ttmp = (tmp & ~OTGSC_CTRL_VBUS_CHARGE) |\n\t\t\tOTGSC_CTRL_VBUS_DISCHARGE;\n\telse\n\t\t \n\t\ttmp &= ~OTGSC_CTRL_VBUS_DISCHARGE;\n\n\tfsl_writel(tmp, &usb_dr_regs->otgsc);\n}\n\n \nvoid fsl_otg_drv_vbus(struct otg_fsm *fsm, int on)\n{\n\tu32 tmp;\n\n\tif (on) {\n\t\ttmp = fsl_readl(&usb_dr_regs->portsc) & ~PORTSC_W1C_BITS;\n\t\tfsl_writel(tmp | PORTSC_PORT_POWER, &usb_dr_regs->portsc);\n\t} else {\n\t\ttmp = fsl_readl(&usb_dr_regs->portsc) &\n\t\t      ~PORTSC_W1C_BITS & ~PORTSC_PORT_POWER;\n\t\tfsl_writel(tmp, &usb_dr_regs->portsc);\n\t}\n}\n\n \nvoid fsl_otg_loc_conn(struct otg_fsm *fsm, int on)\n{\n\tu32 tmp;\n\n\ttmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\n\n\tif (on)\n\t\ttmp |= OTGSC_CTRL_DATA_PULSING;\n\telse\n\t\ttmp &= ~OTGSC_CTRL_DATA_PULSING;\n\n\tfsl_writel(tmp, &usb_dr_regs->otgsc);\n}\n\n \nvoid fsl_otg_loc_sof(struct otg_fsm *fsm, int on)\n{\n\tu32 tmp;\n\n\ttmp = fsl_readl(&fsl_otg_dev->dr_mem_map->portsc) & ~PORTSC_W1C_BITS;\n\tif (on)\n\t\ttmp |= PORTSC_PORT_FORCE_RESUME;\n\telse\n\t\ttmp |= PORTSC_PORT_SUSPEND;\n\n\tfsl_writel(tmp, &fsl_otg_dev->dr_mem_map->portsc);\n\n}\n\n \nvoid fsl_otg_start_pulse(struct otg_fsm *fsm)\n{\n\tu32 tmp;\n\n\tsrp_wait_done = 0;\n#ifdef HA_DATA_PULSE\n\ttmp = fsl_readl(&usb_dr_regs->otgsc) & ~OTGSC_INTSTS_MASK;\n\ttmp |= OTGSC_HA_DATA_PULSE;\n\tfsl_writel(tmp, &usb_dr_regs->otgsc);\n#else\n\tfsl_otg_loc_conn(1);\n#endif\n\n\tfsl_otg_add_timer(fsm, b_data_pulse_tmr);\n}\n\nvoid b_data_pulse_end(unsigned long foo)\n{\n#ifdef HA_DATA_PULSE\n#else\n\tfsl_otg_loc_conn(0);\n#endif\n\n\t \n\tfsl_otg_pulse_vbus();\n}\n\nvoid fsl_otg_pulse_vbus(void)\n{\n\tsrp_wait_done = 0;\n\tfsl_otg_chrg_vbus(&fsl_otg_dev->fsm, 1);\n\t \n\tfsl_otg_add_timer(&fsl_otg_dev->fsm, b_vbus_pulse_tmr);\n}\n\nvoid b_vbus_pulse_end(unsigned long foo)\n{\n\tfsl_otg_chrg_vbus(&fsl_otg_dev->fsm, 0);\n\n\t \n\tfsl_otg_dischrg_vbus(1);\n\tfsl_otg_add_timer(&fsl_otg_dev->fsm, b_srp_wait_tmr);\n}\n\nvoid b_srp_end(unsigned long foo)\n{\n\tfsl_otg_dischrg_vbus(0);\n\tsrp_wait_done = 1;\n\n\tif ((fsl_otg_dev->phy.otg->state == OTG_STATE_B_SRP_INIT) &&\n\t    fsl_otg_dev->fsm.b_sess_vld)\n\t\tfsl_otg_dev->fsm.b_srp_done = 1;\n}\n\n \nvoid a_wait_enum(unsigned long foo)\n{\n\tVDBG(\"a_wait_enum timeout\\n\");\n\tif (!fsl_otg_dev->phy.otg->host->b_hnp_enable)\n\t\tfsl_otg_add_timer(&fsl_otg_dev->fsm, a_wait_enum_tmr);\n\telse\n\t\totg_statemachine(&fsl_otg_dev->fsm);\n}\n\n \nvoid set_tmout(unsigned long indicator)\n{\n\t*(int *)indicator = 1;\n}\n\n \nint fsl_otg_init_timers(struct otg_fsm *fsm)\n{\n\t \n\ta_wait_vrise_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_VRISE,\n\t\t\t\t(unsigned long)&fsm->a_wait_vrise_tmout);\n\tif (!a_wait_vrise_tmr)\n\t\treturn -ENOMEM;\n\n\ta_wait_bcon_tmr = otg_timer_initializer(&set_tmout, TA_WAIT_BCON,\n\t\t\t\t(unsigned long)&fsm->a_wait_bcon_tmout);\n\tif (!a_wait_bcon_tmr)\n\t\treturn -ENOMEM;\n\n\ta_aidl_bdis_tmr = otg_timer_initializer(&set_tmout, TA_AIDL_BDIS,\n\t\t\t\t(unsigned long)&fsm->a_aidl_bdis_tmout);\n\tif (!a_aidl_bdis_tmr)\n\t\treturn -ENOMEM;\n\n\tb_ase0_brst_tmr = otg_timer_initializer(&set_tmout, TB_ASE0_BRST,\n\t\t\t\t(unsigned long)&fsm->b_ase0_brst_tmout);\n\tif (!b_ase0_brst_tmr)\n\t\treturn -ENOMEM;\n\n\tb_se0_srp_tmr = otg_timer_initializer(&set_tmout, TB_SE0_SRP,\n\t\t\t\t(unsigned long)&fsm->b_se0_srp);\n\tif (!b_se0_srp_tmr)\n\t\treturn -ENOMEM;\n\n\tb_srp_fail_tmr = otg_timer_initializer(&set_tmout, TB_SRP_FAIL,\n\t\t\t\t(unsigned long)&fsm->b_srp_done);\n\tif (!b_srp_fail_tmr)\n\t\treturn -ENOMEM;\n\n\ta_wait_enum_tmr = otg_timer_initializer(&a_wait_enum, 10,\n\t\t\t\t(unsigned long)&fsm);\n\tif (!a_wait_enum_tmr)\n\t\treturn -ENOMEM;\n\n\t \n\tb_srp_wait_tmr = otg_timer_initializer(&b_srp_end, TB_SRP_WAIT, 0);\n\tif (!b_srp_wait_tmr)\n\t\treturn -ENOMEM;\n\n\tb_data_pulse_tmr = otg_timer_initializer(&b_data_pulse_end,\n\t\t\t\tTB_DATA_PLS, 0);\n\tif (!b_data_pulse_tmr)\n\t\treturn -ENOMEM;\n\n\tb_vbus_pulse_tmr = otg_timer_initializer(&b_vbus_pulse_end,\n\t\t\t\tTB_VBUS_PLS, 0);\n\tif (!b_vbus_pulse_tmr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nvoid fsl_otg_uninit_timers(void)\n{\n\t \n\tkfree(a_wait_vrise_tmr);\n\tkfree(a_wait_bcon_tmr);\n\tkfree(a_aidl_bdis_tmr);\n\tkfree(b_ase0_brst_tmr);\n\tkfree(b_se0_srp_tmr);\n\tkfree(b_srp_fail_tmr);\n\tkfree(a_wait_enum_tmr);\n\n\t \n\tkfree(b_srp_wait_tmr);\n\tkfree(b_data_pulse_tmr);\n\tkfree(b_vbus_pulse_tmr);\n}\n\nstatic struct fsl_otg_timer *fsl_otg_get_timer(enum otg_fsm_timer t)\n{\n\tstruct fsl_otg_timer *timer;\n\n\t \n\tswitch (t) {\n\tcase A_WAIT_VRISE:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase A_WAIT_BCON:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase A_AIDL_BDIS:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase B_ASE0_BRST:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase B_SE0_SRP:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase B_SRP_FAIL:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tcase A_WAIT_ENUM:\n\t\ttimer = a_wait_vrise_tmr;\n\t\tbreak;\n\tdefault:\n\t\ttimer = NULL;\n\t}\n\n\treturn timer;\n}\n\n \nvoid fsl_otg_add_timer(struct otg_fsm *fsm, void *gtimer)\n{\n\tstruct fsl_otg_timer *timer = gtimer;\n\tstruct fsl_otg_timer *tmp_timer;\n\n\t \n\tlist_for_each_entry(tmp_timer, &active_timers, list)\n\t    if (tmp_timer == timer) {\n\t\ttimer->count = timer->expires;\n\t\treturn;\n\t}\n\ttimer->count = timer->expires;\n\tlist_add_tail(&timer->list, &active_timers);\n}\n\nstatic void fsl_otg_fsm_add_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\n{\n\tstruct fsl_otg_timer *timer;\n\n\ttimer = fsl_otg_get_timer(t);\n\tif (!timer)\n\t\treturn;\n\n\tfsl_otg_add_timer(fsm, timer);\n}\n\n \nvoid fsl_otg_del_timer(struct otg_fsm *fsm, void *gtimer)\n{\n\tstruct fsl_otg_timer *timer = gtimer;\n\tstruct fsl_otg_timer *tmp_timer, *del_tmp;\n\n\tlist_for_each_entry_safe(tmp_timer, del_tmp, &active_timers, list)\n\t\tif (tmp_timer == timer)\n\t\t\tlist_del(&timer->list);\n}\n\nstatic void fsl_otg_fsm_del_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\n{\n\tstruct fsl_otg_timer *timer;\n\n\ttimer = fsl_otg_get_timer(t);\n\tif (!timer)\n\t\treturn;\n\n\tfsl_otg_del_timer(fsm, timer);\n}\n\n \nvoid otg_reset_controller(void)\n{\n\tu32 command;\n\n\tcommand = fsl_readl(&usb_dr_regs->usbcmd);\n\tcommand |= (1 << 1);\n\tfsl_writel(command, &usb_dr_regs->usbcmd);\n\twhile (fsl_readl(&usb_dr_regs->usbcmd) & (1 << 1))\n\t\t;\n}\n\n \nint fsl_otg_start_host(struct otg_fsm *fsm, int on)\n{\n\tstruct usb_otg *otg = fsm->otg;\n\tstruct device *dev;\n\tstruct fsl_otg *otg_dev =\n\t\tcontainer_of(otg->usb_phy, struct fsl_otg, phy);\n\tu32 retval = 0;\n\n\tif (!otg->host)\n\t\treturn -ENODEV;\n\tdev = otg->host->controller;\n\n\t \n\tfsm->a_vbus_vld =\n\t\t!!(fsl_readl(&usb_dr_regs->otgsc) & OTGSC_STS_A_VBUS_VALID);\n\tif (on) {\n\t\t \n\t\tif (otg_dev->host_working)\n\t\t\tgoto end;\n\t\telse {\n\t\t\totg_reset_controller();\n\t\t\tVDBG(\"host on......\\n\");\n\t\t\tif (dev->driver->pm && dev->driver->pm->resume) {\n\t\t\t\tretval = dev->driver->pm->resume(dev);\n\t\t\t\tif (fsm->id) {\n\t\t\t\t\t \n\t\t\t\t\tfsl_otg_drv_vbus(fsm, 1);\n\t\t\t\t\t \n\t\t\t\t\twrite_ulpi(0x0c, 0x20);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\totg_dev->host_working = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!otg_dev->host_working)\n\t\t\tgoto end;\n\t\telse {\n\t\t\tVDBG(\"host off......\\n\");\n\t\t\tif (dev && dev->driver) {\n\t\t\t\tif (dev->driver->pm && dev->driver->pm->suspend)\n\t\t\t\t\tretval = dev->driver->pm->suspend(dev);\n\t\t\t\tif (fsm->id)\n\t\t\t\t\t \n\t\t\t\t\tfsl_otg_drv_vbus(fsm, 0);\n\t\t\t}\n\t\t\totg_dev->host_working = 0;\n\t\t}\n\t}\nend:\n\treturn retval;\n}\n\n \nint fsl_otg_start_gadget(struct otg_fsm *fsm, int on)\n{\n\tstruct usb_otg *otg = fsm->otg;\n\tstruct device *dev;\n\n\tif (!otg->gadget || !otg->gadget->dev.parent)\n\t\treturn -ENODEV;\n\n\tVDBG(\"gadget %s\\n\", on ? \"on\" : \"off\");\n\tdev = otg->gadget->dev.parent;\n\n\tif (on) {\n\t\tif (dev->driver->resume)\n\t\t\tdev->driver->resume(dev);\n\t} else {\n\t\tif (dev->driver->suspend)\n\t\t\tdev->driver->suspend(dev, otg_suspend_state);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int fsl_otg_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct fsl_otg *otg_dev;\n\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\totg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);\n\tif (otg_dev != fsl_otg_dev)\n\t\treturn -ENODEV;\n\n\totg->host = host;\n\n\totg_dev->fsm.a_bus_drop = 0;\n\totg_dev->fsm.a_bus_req = 1;\n\n\tif (host) {\n\t\tVDBG(\"host off......\\n\");\n\n\t\totg->host->otg_port = fsl_otg_initdata.otg_port;\n\t\totg->host->is_b_host = otg_dev->fsm.id;\n\t\t \n\t\totg_dev->host_working = 1;\n\t\tschedule_delayed_work(&otg_dev->otg_event, 100);\n\t\treturn 0;\n\t} else {\n\t\t \n\t\tif (!(fsl_readl(&otg_dev->dr_mem_map->otgsc) &\n\t\t      OTGSC_STS_USB_ID)) {\n\t\t\t \n\t\t\tstruct otg_fsm *fsm = &otg_dev->fsm;\n\n\t\t\totg->state = OTG_STATE_UNDEFINED;\n\t\t\tfsm->protocol = PROTO_UNDEF;\n\t\t}\n\t}\n\n\totg_dev->host_working = 0;\n\n\totg_statemachine(&otg_dev->fsm);\n\n\treturn 0;\n}\n\n \nstatic int fsl_otg_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\tstruct usb_gadget *gadget)\n{\n\tstruct fsl_otg *otg_dev;\n\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\totg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);\n\tVDBG(\"otg_dev 0x%x\\n\", (int)otg_dev);\n\tVDBG(\"fsl_otg_dev 0x%x\\n\", (int)fsl_otg_dev);\n\tif (otg_dev != fsl_otg_dev)\n\t\treturn -ENODEV;\n\n\tif (!gadget) {\n\t\tif (!otg->default_a)\n\t\t\totg->gadget->ops->vbus_draw(otg->gadget, 0);\n\t\tusb_gadget_vbus_disconnect(otg->gadget);\n\t\totg->gadget = 0;\n\t\totg_dev->fsm.b_bus_req = 0;\n\t\totg_statemachine(&otg_dev->fsm);\n\t\treturn 0;\n\t}\n\n\totg->gadget = gadget;\n\totg->gadget->is_a_peripheral = !otg_dev->fsm.id;\n\n\totg_dev->fsm.b_bus_req = 1;\n\n\t \n\tpr_debug(\"ID pin=%d\\n\", otg_dev->fsm.id);\n\tif (otg_dev->fsm.id == 1) {\n\t\tfsl_otg_start_host(&otg_dev->fsm, 0);\n\t\totg_drv_vbus(&otg_dev->fsm, 0);\n\t\tfsl_otg_start_gadget(&otg_dev->fsm, 1);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void fsl_otg_event(struct work_struct *work)\n{\n\tstruct fsl_otg *og = container_of(work, struct fsl_otg, otg_event.work);\n\tstruct otg_fsm *fsm = &og->fsm;\n\n\tif (fsm->id) {\t\t \n\t\tfsl_otg_start_host(fsm, 0);\n\t\totg_drv_vbus(fsm, 0);\n\t\tfsl_otg_start_gadget(fsm, 1);\n\t}\n}\n\n \nstatic int fsl_otg_start_srp(struct usb_otg *otg)\n{\n\tstruct fsl_otg *otg_dev;\n\n\tif (!otg || otg->state != OTG_STATE_B_IDLE)\n\t\treturn -ENODEV;\n\n\totg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);\n\tif (otg_dev != fsl_otg_dev)\n\t\treturn -ENODEV;\n\n\totg_dev->fsm.b_bus_req = 1;\n\totg_statemachine(&otg_dev->fsm);\n\n\treturn 0;\n}\n\n \nstatic int fsl_otg_start_hnp(struct usb_otg *otg)\n{\n\tstruct fsl_otg *otg_dev;\n\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\totg_dev = container_of(otg->usb_phy, struct fsl_otg, phy);\n\tif (otg_dev != fsl_otg_dev)\n\t\treturn -ENODEV;\n\n\tpr_debug(\"start_hnp...\\n\");\n\n\t \n\totg_dev->fsm.a_bus_req = 0;\n\totg_statemachine(&otg_dev->fsm);\n\n\treturn 0;\n}\n\n \nirqreturn_t fsl_otg_isr(int irq, void *dev_id)\n{\n\tstruct otg_fsm *fsm = &((struct fsl_otg *)dev_id)->fsm;\n\tstruct usb_otg *otg = ((struct fsl_otg *)dev_id)->phy.otg;\n\tu32 otg_int_src, otg_sc;\n\n\totg_sc = fsl_readl(&usb_dr_regs->otgsc);\n\totg_int_src = otg_sc & OTGSC_INTSTS_MASK & (otg_sc >> 8);\n\n\t \n\tfsl_writel(otg_sc, &usb_dr_regs->otgsc);\n\n\t \n\tfsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;\n\totg->default_a = (fsm->id == 0);\n\n\t \n\tif (otg_int_src) {\n\t\tif (otg_int_src & OTGSC_INTSTS_USB_ID) {\n\t\t\tfsm->id = (otg_sc & OTGSC_STS_USB_ID) ? 1 : 0;\n\t\t\totg->default_a = (fsm->id == 0);\n\t\t\t \n\t\t\tif (fsm->id)\n\t\t\t\tfsm->b_conn = 0;\n\t\t\telse\n\t\t\t\tfsm->a_conn = 0;\n\n\t\t\tif (otg->host)\n\t\t\t\totg->host->is_b_host = fsm->id;\n\t\t\tif (otg->gadget)\n\t\t\t\totg->gadget->is_a_peripheral = !fsm->id;\n\t\t\tVDBG(\"ID int (ID is %d)\\n\", fsm->id);\n\n\t\t\tif (fsm->id) {\t \n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&((struct fsl_otg *)dev_id)->otg_event,\n\t\t\t\t\t100);\n\t\t\t} else {\t \n\t\t\t\tcancel_delayed_work(&\n\t\t\t\t\t\t    ((struct fsl_otg *)dev_id)->\n\t\t\t\t\t\t    otg_event);\n\t\t\t\tfsl_otg_start_gadget(fsm, 0);\n\t\t\t\totg_drv_vbus(fsm, 1);\n\t\t\t\tfsl_otg_start_host(fsm, 1);\n\t\t\t}\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\t}\n\treturn IRQ_NONE;\n}\n\nstatic struct otg_fsm_ops fsl_otg_ops = {\n\t.chrg_vbus = fsl_otg_chrg_vbus,\n\t.drv_vbus = fsl_otg_drv_vbus,\n\t.loc_conn = fsl_otg_loc_conn,\n\t.loc_sof = fsl_otg_loc_sof,\n\t.start_pulse = fsl_otg_start_pulse,\n\n\t.add_timer = fsl_otg_fsm_add_timer,\n\t.del_timer = fsl_otg_fsm_del_timer,\n\n\t.start_host = fsl_otg_start_host,\n\t.start_gadget = fsl_otg_start_gadget,\n};\n\n \nstatic int fsl_otg_conf(struct platform_device *pdev)\n{\n\tstruct fsl_otg *fsl_otg_tc;\n\tint status;\n\n\tif (fsl_otg_dev)\n\t\treturn 0;\n\n\t \n\tfsl_otg_tc = kzalloc(sizeof(struct fsl_otg), GFP_KERNEL);\n\tif (!fsl_otg_tc)\n\t\treturn -ENOMEM;\n\n\tfsl_otg_tc->phy.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);\n\tif (!fsl_otg_tc->phy.otg) {\n\t\tkfree(fsl_otg_tc);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&fsl_otg_tc->otg_event, fsl_otg_event);\n\n\tINIT_LIST_HEAD(&active_timers);\n\tstatus = fsl_otg_init_timers(&fsl_otg_tc->fsm);\n\tif (status) {\n\t\tpr_info(\"Couldn't init OTG timers\\n\");\n\t\tgoto err;\n\t}\n\tmutex_init(&fsl_otg_tc->fsm.lock);\n\n\t \n\tfsl_otg_tc->fsm.ops = &fsl_otg_ops;\n\n\t \n\tfsl_otg_tc->phy.label = DRIVER_DESC;\n\tfsl_otg_tc->phy.dev = &pdev->dev;\n\n\tfsl_otg_tc->phy.otg->usb_phy = &fsl_otg_tc->phy;\n\tfsl_otg_tc->phy.otg->set_host = fsl_otg_set_host;\n\tfsl_otg_tc->phy.otg->set_peripheral = fsl_otg_set_peripheral;\n\tfsl_otg_tc->phy.otg->start_hnp = fsl_otg_start_hnp;\n\tfsl_otg_tc->phy.otg->start_srp = fsl_otg_start_srp;\n\n\tfsl_otg_dev = fsl_otg_tc;\n\n\t \n\tstatus = usb_add_phy(&fsl_otg_tc->phy, USB_PHY_TYPE_USB2);\n\tif (status) {\n\t\tpr_warn(FSL_OTG_NAME \": unable to register OTG transceiver.\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfsl_otg_uninit_timers();\n\tkfree(fsl_otg_tc->phy.otg);\n\tkfree(fsl_otg_tc);\n\treturn status;\n}\n\n \nint usb_otg_start(struct platform_device *pdev)\n{\n\tstruct fsl_otg *p_otg;\n\tstruct usb_phy *otg_trans = usb_get_phy(USB_PHY_TYPE_USB2);\n\tstruct otg_fsm *fsm;\n\tint status;\n\tstruct resource *res;\n\tu32 temp;\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tp_otg = container_of(otg_trans, struct fsl_otg, phy);\n\tfsm = &p_otg->fsm;\n\n\t \n\tSET_OTG_STATE(otg_trans, OTG_STATE_UNDEFINED);\n\tfsm->otg = p_otg->phy.otg;\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENXIO;\n\n\t \n\n\tusb_dr_regs = ioremap(res->start, sizeof(struct usb_dr_mmap));\n\tp_otg->dr_mem_map = (struct usb_dr_mmap *)usb_dr_regs;\n\tpdata->regs = (void *)usb_dr_regs;\n\n\tif (pdata->init && pdata->init(pdev) != 0)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_PPC32\n\tif (pdata->big_endian_mmio) {\n\t\t_fsl_readl = _fsl_readl_be;\n\t\t_fsl_writel = _fsl_writel_be;\n\t} else {\n\t\t_fsl_readl = _fsl_readl_le;\n\t\t_fsl_writel = _fsl_writel_le;\n\t}\n#endif\n\n\t \n\tp_otg->irq = platform_get_irq(pdev, 0);\n\tif (p_otg->irq < 0)\n\t\treturn p_otg->irq;\n\tstatus = request_irq(p_otg->irq, fsl_otg_isr,\n\t\t\t\tIRQF_SHARED, driver_name, p_otg);\n\tif (status) {\n\t\tdev_dbg(p_otg->phy.dev, \"can't get IRQ %d, error %d\\n\",\n\t\t\tp_otg->irq, status);\n\t\tiounmap(p_otg->dr_mem_map);\n\t\tkfree(p_otg->phy.otg);\n\t\tkfree(p_otg);\n\t\treturn status;\n\t}\n\n\t \n\ttemp = fsl_readl(&p_otg->dr_mem_map->usbcmd);\n\ttemp &= ~USB_CMD_RUN_STOP;\n\tfsl_writel(temp, &p_otg->dr_mem_map->usbcmd);\n\n\t \n\ttemp = fsl_readl(&p_otg->dr_mem_map->usbcmd);\n\ttemp |= USB_CMD_CTRL_RESET;\n\tfsl_writel(temp, &p_otg->dr_mem_map->usbcmd);\n\n\t \n\twhile (fsl_readl(&p_otg->dr_mem_map->usbcmd) & USB_CMD_CTRL_RESET)\n\t\t;\n\n\t \n\ttemp = USB_MODE_STREAM_DISABLE | (pdata->es ? USB_MODE_ES : 0);\n\tfsl_writel(temp, &p_otg->dr_mem_map->usbmode);\n\n\t \n\ttemp = fsl_readl(&p_otg->dr_mem_map->portsc);\n\ttemp &= ~(PORTSC_PHY_TYPE_SEL | PORTSC_PTW);\n\tswitch (pdata->phy_mode) {\n\tcase FSL_USB2_PHY_ULPI:\n\t\ttemp |= PORTSC_PTS_ULPI;\n\t\tbreak;\n\tcase FSL_USB2_PHY_UTMI_WIDE:\n\t\ttemp |= PORTSC_PTW_16BIT;\n\t\tfallthrough;\n\tcase FSL_USB2_PHY_UTMI:\n\t\ttemp |= PORTSC_PTS_UTMI;\n\t\tfallthrough;\n\tdefault:\n\t\tbreak;\n\t}\n\tfsl_writel(temp, &p_otg->dr_mem_map->portsc);\n\n\tif (pdata->have_sysif_regs) {\n\t\t \n\t\ttemp = __raw_readl(&p_otg->dr_mem_map->control);\n\t\ttemp |= USB_CTRL_IOENB;\n\t\t__raw_writel(temp, &p_otg->dr_mem_map->control);\n\t}\n\n\t \n\ttemp = fsl_readl(&p_otg->dr_mem_map->otgsc);\n\ttemp &= ~OTGSC_INTERRUPT_ENABLE_BITS_MASK;\n\ttemp |= OTGSC_INTERRUPT_STATUS_BITS_MASK | OTGSC_CTRL_VBUS_DISCHARGE;\n\tfsl_writel(temp, &p_otg->dr_mem_map->otgsc);\n\n\t \n\tif (fsl_readl(&p_otg->dr_mem_map->otgsc) & OTGSC_STS_USB_ID) {\n\t\tp_otg->phy.otg->state = OTG_STATE_UNDEFINED;\n\t\tp_otg->fsm.id = 1;\n\t} else {\n\t\tp_otg->phy.otg->state = OTG_STATE_A_IDLE;\n\t\tp_otg->fsm.id = 0;\n\t}\n\n\tpr_debug(\"initial ID pin=%d\\n\", p_otg->fsm.id);\n\n\t \n\ttemp = fsl_readl(&p_otg->dr_mem_map->otgsc);\n\ttemp |= OTGSC_INTR_USB_ID_EN;\n\ttemp &= ~(OTGSC_CTRL_VBUS_DISCHARGE | OTGSC_INTR_1MS_TIMER_EN);\n\tfsl_writel(temp, &p_otg->dr_mem_map->otgsc);\n\n\treturn 0;\n}\n\nstatic int fsl_otg_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tif (!dev_get_platdata(&pdev->dev))\n\t\treturn -ENODEV;\n\n\t \n\tret = fsl_otg_conf(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Couldn't configure OTG module\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = usb_otg_start(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Can't init FSL OTG device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void fsl_otg_remove(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tusb_remove_phy(&fsl_otg_dev->phy);\n\tfree_irq(fsl_otg_dev->irq, fsl_otg_dev);\n\n\tiounmap((void *)usb_dr_regs);\n\n\tfsl_otg_uninit_timers();\n\tkfree(fsl_otg_dev->phy.otg);\n\tkfree(fsl_otg_dev);\n\n\tif (pdata->exit)\n\t\tpdata->exit(pdev);\n}\n\nstruct platform_driver fsl_otg_driver = {\n\t.probe = fsl_otg_probe,\n\t.remove_new = fsl_otg_remove,\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.owner = THIS_MODULE,\n\t},\n};\n\nmodule_platform_driver(fsl_otg_driver);\n\nMODULE_DESCRIPTION(DRIVER_INFO);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}