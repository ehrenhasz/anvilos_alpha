{
  "module_name": "phy-mv-usb.c",
  "hash_id": "d47a35e4e81eb01ce110b60d01fa7c9e522cebd110f92e07cf7647d7d9674aee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-mv-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/proc_fs.h>\n#include <linux/clk.h>\n#include <linux/workqueue.h>\n#include <linux/platform_device.h>\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/hcd.h>\n#include <linux/platform_data/mv_usb.h>\n\n#include \"phy-mv-usb.h\"\n\n#define\tDRIVER_DESC\t\"Marvell USB OTG transceiver driver\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char driver_name[] = \"mv-otg\";\n\nstatic char *state_string[] = {\n\t\"undefined\",\n\t\"b_idle\",\n\t\"b_srp_init\",\n\t\"b_peripheral\",\n\t\"b_wait_acon\",\n\t\"b_host\",\n\t\"a_idle\",\n\t\"a_wait_vrise\",\n\t\"a_wait_bcon\",\n\t\"a_host\",\n\t\"a_suspend\",\n\t\"a_peripheral\",\n\t\"a_wait_vfall\",\n\t\"a_vbus_err\"\n};\n\nstatic int mv_otg_set_vbus(struct usb_otg *otg, bool on)\n{\n\tstruct mv_otg *mvotg = container_of(otg->usb_phy, struct mv_otg, phy);\n\tif (mvotg->pdata->set_vbus == NULL)\n\t\treturn -ENODEV;\n\n\treturn mvotg->pdata->set_vbus(on);\n}\n\nstatic int mv_otg_set_host(struct usb_otg *otg,\n\t\t\t   struct usb_bus *host)\n{\n\totg->host = host;\n\n\treturn 0;\n}\n\nstatic int mv_otg_set_peripheral(struct usb_otg *otg,\n\t\t\t\t struct usb_gadget *gadget)\n{\n\totg->gadget = gadget;\n\n\treturn 0;\n}\n\nstatic void mv_otg_run_state_machine(struct mv_otg *mvotg,\n\t\t\t\t     unsigned long delay)\n{\n\tdev_dbg(&mvotg->pdev->dev, \"transceiver is updated\\n\");\n\tif (!mvotg->qwork)\n\t\treturn;\n\n\tqueue_delayed_work(mvotg->qwork, &mvotg->work, delay);\n}\n\nstatic void mv_otg_timer_await_bcon(struct timer_list *t)\n{\n\tstruct mv_otg *mvotg = from_timer(mvotg, t,\n\t\t\t\t\t  otg_ctrl.timer[A_WAIT_BCON_TIMER]);\n\n\tmvotg->otg_ctrl.a_wait_bcon_timeout = 1;\n\n\tdev_info(&mvotg->pdev->dev, \"B Device No Response!\\n\");\n\n\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\tmv_otg_run_state_machine(mvotg, 0);\n\t\tspin_unlock(&mvotg->wq_lock);\n\t}\n}\n\nstatic int mv_otg_cancel_timer(struct mv_otg *mvotg, unsigned int id)\n{\n\tstruct timer_list *timer;\n\n\tif (id >= OTG_TIMER_NUM)\n\t\treturn -EINVAL;\n\n\ttimer = &mvotg->otg_ctrl.timer[id];\n\n\tif (timer_pending(timer))\n\t\tdel_timer(timer);\n\n\treturn 0;\n}\n\nstatic int mv_otg_set_timer(struct mv_otg *mvotg, unsigned int id,\n\t\t\t    unsigned long interval)\n{\n\tstruct timer_list *timer;\n\n\tif (id >= OTG_TIMER_NUM)\n\t\treturn -EINVAL;\n\n\ttimer = &mvotg->otg_ctrl.timer[id];\n\tif (timer_pending(timer)) {\n\t\tdev_err(&mvotg->pdev->dev, \"Timer%d is already running\\n\", id);\n\t\treturn -EBUSY;\n\t}\n\n\ttimer->expires = jiffies + interval;\n\tadd_timer(timer);\n\n\treturn 0;\n}\n\nstatic int mv_otg_reset(struct mv_otg *mvotg)\n{\n\tu32 tmp;\n\tint ret;\n\n\t \n\ttmp = readl(&mvotg->op_regs->usbcmd);\n\ttmp &= ~USBCMD_RUN_STOP;\n\twritel(tmp, &mvotg->op_regs->usbcmd);\n\n\t \n\twritel(USBCMD_CTRL_RESET, &mvotg->op_regs->usbcmd);\n\n\tret = readl_poll_timeout_atomic(&mvotg->op_regs->usbcmd, tmp,\n\t\t\t\t(tmp & USBCMD_CTRL_RESET), 10, 10000);\n\tif (ret < 0) {\n\t\tdev_err(&mvotg->pdev->dev,\n\t\t\t\"Wait for RESET completed TIMEOUT\\n\");\n\t\treturn ret;\n\t}\n\n\twritel(0x0, &mvotg->op_regs->usbintr);\n\ttmp = readl(&mvotg->op_regs->usbsts);\n\twritel(tmp, &mvotg->op_regs->usbsts);\n\n\treturn 0;\n}\n\nstatic void mv_otg_init_irq(struct mv_otg *mvotg)\n{\n\tu32 otgsc;\n\n\tmvotg->irq_en = OTGSC_INTR_A_SESSION_VALID\n\t    | OTGSC_INTR_A_VBUS_VALID;\n\tmvotg->irq_status = OTGSC_INTSTS_A_SESSION_VALID\n\t    | OTGSC_INTSTS_A_VBUS_VALID;\n\n\tif (mvotg->pdata->vbus == NULL) {\n\t\tmvotg->irq_en |= OTGSC_INTR_B_SESSION_VALID\n\t\t    | OTGSC_INTR_B_SESSION_END;\n\t\tmvotg->irq_status |= OTGSC_INTSTS_B_SESSION_VALID\n\t\t    | OTGSC_INTSTS_B_SESSION_END;\n\t}\n\n\tif (mvotg->pdata->id == NULL) {\n\t\tmvotg->irq_en |= OTGSC_INTR_USB_ID;\n\t\tmvotg->irq_status |= OTGSC_INTSTS_USB_ID;\n\t}\n\n\totgsc = readl(&mvotg->op_regs->otgsc);\n\totgsc |= mvotg->irq_en;\n\twritel(otgsc, &mvotg->op_regs->otgsc);\n}\n\nstatic void mv_otg_start_host(struct mv_otg *mvotg, int on)\n{\n#ifdef CONFIG_USB\n\tstruct usb_otg *otg = mvotg->phy.otg;\n\tstruct usb_hcd *hcd;\n\n\tif (!otg->host)\n\t\treturn;\n\n\tdev_info(&mvotg->pdev->dev, \"%s host\\n\", on ? \"start\" : \"stop\");\n\n\thcd = bus_to_hcd(otg->host);\n\n\tif (on) {\n\t\tusb_add_hcd(hcd, hcd->irq, IRQF_SHARED);\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t} else {\n\t\tusb_remove_hcd(hcd);\n\t}\n#endif  \n}\n\nstatic void mv_otg_start_periphrals(struct mv_otg *mvotg, int on)\n{\n\tstruct usb_otg *otg = mvotg->phy.otg;\n\n\tif (!otg->gadget)\n\t\treturn;\n\n\tdev_info(mvotg->phy.dev, \"gadget %s\\n\", on ? \"on\" : \"off\");\n\n\tif (on)\n\t\tusb_gadget_vbus_connect(otg->gadget);\n\telse\n\t\tusb_gadget_vbus_disconnect(otg->gadget);\n}\n\nstatic void otg_clock_enable(struct mv_otg *mvotg)\n{\n\tclk_prepare_enable(mvotg->clk);\n}\n\nstatic void otg_clock_disable(struct mv_otg *mvotg)\n{\n\tclk_disable_unprepare(mvotg->clk);\n}\n\nstatic int mv_otg_enable_internal(struct mv_otg *mvotg)\n{\n\tint retval = 0;\n\n\tif (mvotg->active)\n\t\treturn 0;\n\n\tdev_dbg(&mvotg->pdev->dev, \"otg enabled\\n\");\n\n\totg_clock_enable(mvotg);\n\tif (mvotg->pdata->phy_init) {\n\t\tretval = mvotg->pdata->phy_init(mvotg->phy_regs);\n\t\tif (retval) {\n\t\t\tdev_err(&mvotg->pdev->dev,\n\t\t\t\t\"init phy error %d\\n\", retval);\n\t\t\totg_clock_disable(mvotg);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tmvotg->active = 1;\n\n\treturn 0;\n\n}\n\nstatic int mv_otg_enable(struct mv_otg *mvotg)\n{\n\tif (mvotg->clock_gating)\n\t\treturn mv_otg_enable_internal(mvotg);\n\n\treturn 0;\n}\n\nstatic void mv_otg_disable_internal(struct mv_otg *mvotg)\n{\n\tif (mvotg->active) {\n\t\tdev_dbg(&mvotg->pdev->dev, \"otg disabled\\n\");\n\t\tif (mvotg->pdata->phy_deinit)\n\t\t\tmvotg->pdata->phy_deinit(mvotg->phy_regs);\n\t\totg_clock_disable(mvotg);\n\t\tmvotg->active = 0;\n\t}\n}\n\nstatic void mv_otg_disable(struct mv_otg *mvotg)\n{\n\tif (mvotg->clock_gating)\n\t\tmv_otg_disable_internal(mvotg);\n}\n\nstatic void mv_otg_update_inputs(struct mv_otg *mvotg)\n{\n\tstruct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;\n\tu32 otgsc;\n\n\totgsc = readl(&mvotg->op_regs->otgsc);\n\n\tif (mvotg->pdata->vbus) {\n\t\tif (mvotg->pdata->vbus->poll() == VBUS_HIGH) {\n\t\t\totg_ctrl->b_sess_vld = 1;\n\t\t\totg_ctrl->b_sess_end = 0;\n\t\t} else {\n\t\t\totg_ctrl->b_sess_vld = 0;\n\t\t\totg_ctrl->b_sess_end = 1;\n\t\t}\n\t} else {\n\t\totg_ctrl->b_sess_vld = !!(otgsc & OTGSC_STS_B_SESSION_VALID);\n\t\totg_ctrl->b_sess_end = !!(otgsc & OTGSC_STS_B_SESSION_END);\n\t}\n\n\tif (mvotg->pdata->id)\n\t\totg_ctrl->id = !!mvotg->pdata->id->poll();\n\telse\n\t\totg_ctrl->id = !!(otgsc & OTGSC_STS_USB_ID);\n\n\tif (mvotg->pdata->otg_force_a_bus_req && !otg_ctrl->id)\n\t\totg_ctrl->a_bus_req = 1;\n\n\totg_ctrl->a_sess_vld = !!(otgsc & OTGSC_STS_A_SESSION_VALID);\n\totg_ctrl->a_vbus_vld = !!(otgsc & OTGSC_STS_A_VBUS_VALID);\n\n\tdev_dbg(&mvotg->pdev->dev, \"%s: \", __func__);\n\tdev_dbg(&mvotg->pdev->dev, \"id %d\\n\", otg_ctrl->id);\n\tdev_dbg(&mvotg->pdev->dev, \"b_sess_vld %d\\n\", otg_ctrl->b_sess_vld);\n\tdev_dbg(&mvotg->pdev->dev, \"b_sess_end %d\\n\", otg_ctrl->b_sess_end);\n\tdev_dbg(&mvotg->pdev->dev, \"a_vbus_vld %d\\n\", otg_ctrl->a_vbus_vld);\n\tdev_dbg(&mvotg->pdev->dev, \"a_sess_vld %d\\n\", otg_ctrl->a_sess_vld);\n}\n\nstatic void mv_otg_update_state(struct mv_otg *mvotg)\n{\n\tstruct mv_otg_ctrl *otg_ctrl = &mvotg->otg_ctrl;\n\tint old_state = mvotg->phy.otg->state;\n\n\tswitch (old_state) {\n\tcase OTG_STATE_UNDEFINED:\n\t\tmvotg->phy.otg->state = OTG_STATE_B_IDLE;\n\t\tfallthrough;\n\tcase OTG_STATE_B_IDLE:\n\t\tif (otg_ctrl->id == 0)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_IDLE;\n\t\telse if (otg_ctrl->b_sess_vld)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_B_PERIPHERAL;\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif (!otg_ctrl->b_sess_vld || otg_ctrl->id == 0)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_B_IDLE;\n\t\tbreak;\n\tcase OTG_STATE_A_IDLE:\n\t\tif (otg_ctrl->id)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_B_IDLE;\n\t\telse if (!(otg_ctrl->a_bus_drop) &&\n\t\t\t (otg_ctrl->a_bus_req || otg_ctrl->a_srp_det))\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\tif (otg_ctrl->a_vbus_vld)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_WAIT_BCON;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tif (otg_ctrl->id || otg_ctrl->a_bus_drop\n\t\t    || otg_ctrl->a_wait_bcon_timeout) {\n\t\t\tmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\n\t\t\tmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_WAIT_VFALL;\n\t\t\totg_ctrl->a_bus_req = 0;\n\t\t} else if (!otg_ctrl->a_vbus_vld) {\n\t\t\tmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\n\t\t\tmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_VBUS_ERR;\n\t\t} else if (otg_ctrl->b_conn) {\n\t\t\tmv_otg_cancel_timer(mvotg, A_WAIT_BCON_TIMER);\n\t\t\tmvotg->otg_ctrl.a_wait_bcon_timeout = 0;\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_HOST;\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\tif (otg_ctrl->id || !otg_ctrl->b_conn\n\t\t    || otg_ctrl->a_bus_drop)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_WAIT_BCON;\n\t\telse if (!otg_ctrl->a_vbus_vld)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_VBUS_ERR;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\tif (otg_ctrl->id\n\t\t    || (!otg_ctrl->b_conn && otg_ctrl->a_sess_vld)\n\t\t    || otg_ctrl->a_bus_req)\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_IDLE;\n\t\tbreak;\n\tcase OTG_STATE_A_VBUS_ERR:\n\t\tif (otg_ctrl->id || otg_ctrl->a_clr_err\n\t\t    || otg_ctrl->a_bus_drop) {\n\t\t\totg_ctrl->a_clr_err = 0;\n\t\t\tmvotg->phy.otg->state = OTG_STATE_A_WAIT_VFALL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void mv_otg_work(struct work_struct *work)\n{\n\tstruct mv_otg *mvotg;\n\tstruct usb_otg *otg;\n\tint old_state;\n\n\tmvotg = container_of(to_delayed_work(work), struct mv_otg, work);\n\nrun:\n\t \n\totg = mvotg->phy.otg;\n\told_state = otg->state;\n\n\tif (!mvotg->active)\n\t\treturn;\n\n\tmv_otg_update_inputs(mvotg);\n\tmv_otg_update_state(mvotg);\n\n\tif (old_state != mvotg->phy.otg->state) {\n\t\tdev_info(&mvotg->pdev->dev, \"change from state %s to %s\\n\",\n\t\t\t state_string[old_state],\n\t\t\t state_string[mvotg->phy.otg->state]);\n\n\t\tswitch (mvotg->phy.otg->state) {\n\t\tcase OTG_STATE_B_IDLE:\n\t\t\totg->default_a = 0;\n\t\t\tif (old_state == OTG_STATE_B_PERIPHERAL)\n\t\t\t\tmv_otg_start_periphrals(mvotg, 0);\n\t\t\tmv_otg_reset(mvotg);\n\t\t\tmv_otg_disable(mvotg);\n\t\t\tusb_phy_set_event(&mvotg->phy, USB_EVENT_NONE);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_PERIPHERAL:\n\t\t\tmv_otg_enable(mvotg);\n\t\t\tmv_otg_start_periphrals(mvotg, 1);\n\t\t\tusb_phy_set_event(&mvotg->phy, USB_EVENT_ENUMERATED);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_IDLE:\n\t\t\totg->default_a = 1;\n\t\t\tmv_otg_enable(mvotg);\n\t\t\tif (old_state == OTG_STATE_A_WAIT_VFALL)\n\t\t\t\tmv_otg_start_host(mvotg, 0);\n\t\t\tmv_otg_reset(mvotg);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_WAIT_VRISE:\n\t\t\tmv_otg_set_vbus(otg, 1);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_WAIT_BCON:\n\t\t\tif (old_state != OTG_STATE_A_HOST)\n\t\t\t\tmv_otg_start_host(mvotg, 1);\n\t\t\tmv_otg_set_timer(mvotg, A_WAIT_BCON_TIMER,\n\t\t\t\t\t T_A_WAIT_BCON);\n\t\t\t \n\t\t\tmvotg->otg_ctrl.b_conn = 1;\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_HOST:\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_WAIT_VFALL:\n\t\t\t \n\t\t\tmvotg->otg_ctrl.b_conn = 0;\n\t\t\tmv_otg_set_vbus(otg, 0);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_VBUS_ERR:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tgoto run;\n\t}\n}\n\nstatic irqreturn_t mv_otg_irq(int irq, void *dev)\n{\n\tstruct mv_otg *mvotg = dev;\n\tu32 otgsc;\n\n\totgsc = readl(&mvotg->op_regs->otgsc);\n\twritel(otgsc, &mvotg->op_regs->otgsc);\n\n\t \n\tif (mvotg->pdata->vbus)\n\t\tif ((otgsc & OTGSC_STS_USB_ID) &&\n\t\t    !(otgsc & OTGSC_INTSTS_USB_ID))\n\t\t\treturn IRQ_NONE;\n\n\tif ((otgsc & mvotg->irq_status) == 0)\n\t\treturn IRQ_NONE;\n\n\tmv_otg_run_state_machine(mvotg, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mv_otg_inputs_irq(int irq, void *dev)\n{\n\tstruct mv_otg *mvotg = dev;\n\n\t \n\tif (!mvotg->active) {\n\t\tmv_otg_enable(mvotg);\n\t\tmv_otg_init_irq(mvotg);\n\t}\n\n\tmv_otg_run_state_machine(mvotg, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t\na_bus_req_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct mv_otg *mvotg = dev_get_drvdata(dev);\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t mvotg->otg_ctrl.a_bus_req);\n}\n\nstatic ssize_t\na_bus_req_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct mv_otg *mvotg = dev_get_drvdata(dev);\n\n\tif (count > 2)\n\t\treturn -1;\n\n\t \n\tif (mvotg->phy.otg->state != OTG_STATE_B_IDLE\n\t    && mvotg->phy.otg->state != OTG_STATE_A_IDLE)\n\t\treturn -1;\n\n\t \n\tmv_otg_enable(mvotg);\n\tmv_otg_init_irq(mvotg);\n\n\tif (buf[0] == '1') {\n\t\tmvotg->otg_ctrl.a_bus_req = 1;\n\t\tmvotg->otg_ctrl.a_bus_drop = 0;\n\t\tdev_dbg(&mvotg->pdev->dev,\n\t\t\t\"User request: a_bus_req = 1\\n\");\n\n\t\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\t\tmv_otg_run_state_machine(mvotg, 0);\n\t\t\tspin_unlock(&mvotg->wq_lock);\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(a_bus_req);\n\nstatic ssize_t\na_clr_err_store(struct device *dev, struct device_attribute *attr,\n\t      const char *buf, size_t count)\n{\n\tstruct mv_otg *mvotg = dev_get_drvdata(dev);\n\tif (!mvotg->phy.otg->default_a)\n\t\treturn -1;\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tif (buf[0] == '1') {\n\t\tmvotg->otg_ctrl.a_clr_err = 1;\n\t\tdev_dbg(&mvotg->pdev->dev,\n\t\t\t\"User request: a_clr_err = 1\\n\");\n\t}\n\n\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\tmv_otg_run_state_machine(mvotg, 0);\n\t\tspin_unlock(&mvotg->wq_lock);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_WO(a_clr_err);\n\nstatic ssize_t\na_bus_drop_show(struct device *dev, struct device_attribute *attr,\n\t       char *buf)\n{\n\tstruct mv_otg *mvotg = dev_get_drvdata(dev);\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\",\n\t\t\t mvotg->otg_ctrl.a_bus_drop);\n}\n\nstatic ssize_t\na_bus_drop_store(struct device *dev, struct device_attribute *attr,\n\t       const char *buf, size_t count)\n{\n\tstruct mv_otg *mvotg = dev_get_drvdata(dev);\n\tif (!mvotg->phy.otg->default_a)\n\t\treturn -1;\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tif (buf[0] == '0') {\n\t\tmvotg->otg_ctrl.a_bus_drop = 0;\n\t\tdev_dbg(&mvotg->pdev->dev,\n\t\t\t\"User request: a_bus_drop = 0\\n\");\n\t} else if (buf[0] == '1') {\n\t\tmvotg->otg_ctrl.a_bus_drop = 1;\n\t\tmvotg->otg_ctrl.a_bus_req = 0;\n\t\tdev_dbg(&mvotg->pdev->dev,\n\t\t\t\"User request: a_bus_drop = 1\\n\");\n\t\tdev_dbg(&mvotg->pdev->dev,\n\t\t\t\"User request: and a_bus_req = 0\\n\");\n\t}\n\n\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\tmv_otg_run_state_machine(mvotg, 0);\n\t\tspin_unlock(&mvotg->wq_lock);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(a_bus_drop);\n\nstatic struct attribute *inputs_attrs[] = {\n\t&dev_attr_a_bus_req.attr,\n\t&dev_attr_a_clr_err.attr,\n\t&dev_attr_a_bus_drop.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group inputs_attr_group = {\n\t.name = \"inputs\",\n\t.attrs = inputs_attrs,\n};\n\nstatic const struct attribute_group *mv_otg_groups[] = {\n\t&inputs_attr_group,\n\tNULL,\n};\n\nstatic void mv_otg_remove(struct platform_device *pdev)\n{\n\tstruct mv_otg *mvotg = platform_get_drvdata(pdev);\n\n\tif (mvotg->qwork)\n\t\tdestroy_workqueue(mvotg->qwork);\n\n\tmv_otg_disable(mvotg);\n\n\tusb_remove_phy(&mvotg->phy);\n}\n\nstatic int mv_otg_probe(struct platform_device *pdev)\n{\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct mv_otg *mvotg;\n\tstruct usb_otg *otg;\n\tstruct resource *r;\n\tint retval = 0, i;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to get platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tmvotg = devm_kzalloc(&pdev->dev, sizeof(*mvotg), GFP_KERNEL);\n\tif (!mvotg)\n\t\treturn -ENOMEM;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mvotg);\n\n\tmvotg->pdev = pdev;\n\tmvotg->pdata = pdata;\n\n\tmvotg->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(mvotg->clk))\n\t\treturn PTR_ERR(mvotg->clk);\n\n\tmvotg->qwork = create_singlethread_workqueue(\"mv_otg_queue\");\n\tif (!mvotg->qwork) {\n\t\tdev_dbg(&pdev->dev, \"cannot create workqueue for OTG\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&mvotg->work, mv_otg_work);\n\n\t \n\tmvotg->pdev = pdev;\n\tmvotg->phy.dev = &pdev->dev;\n\tmvotg->phy.otg = otg;\n\tmvotg->phy.label = driver_name;\n\n\totg->state = OTG_STATE_UNDEFINED;\n\totg->usb_phy = &mvotg->phy;\n\totg->set_host = mv_otg_set_host;\n\totg->set_peripheral = mv_otg_set_peripheral;\n\totg->set_vbus = mv_otg_set_vbus;\n\n\tfor (i = 0; i < OTG_TIMER_NUM; i++)\n\t\ttimer_setup(&mvotg->otg_ctrl.timer[i],\n\t\t\t    mv_otg_timer_await_bcon, 0);\n\n\tr = platform_get_resource_byname(mvotg->pdev,\n\t\t\t\t\t IORESOURCE_MEM, \"phyregs\");\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no phy I/O memory resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tmvotg->phy_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (mvotg->phy_regs == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map phy I/O memory\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tr = platform_get_resource_byname(mvotg->pdev,\n\t\t\t\t\t IORESOURCE_MEM, \"capregs\");\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no I/O memory resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tmvotg->cap_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (mvotg->cap_regs == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map I/O memory\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\t \n\tretval = mv_otg_enable_internal(mvotg);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"mv otg enable error %d\\n\", retval);\n\t\tgoto err_destroy_workqueue;\n\t}\n\n\tmvotg->op_regs =\n\t\t(struct mv_otg_regs __iomem *) ((unsigned long) mvotg->cap_regs\n\t\t\t+ (readl(mvotg->cap_regs) & CAPLENGTH_MASK));\n\n\tif (pdata->id) {\n\t\tretval = devm_request_threaded_irq(&pdev->dev, pdata->id->irq,\n\t\t\t\t\t\tNULL, mv_otg_inputs_irq,\n\t\t\t\t\t\tIRQF_ONESHOT, \"id\", mvotg);\n\t\tif (retval) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Failed to request irq for ID\\n\");\n\t\t\tpdata->id = NULL;\n\t\t}\n\t}\n\n\tif (pdata->vbus) {\n\t\tmvotg->clock_gating = 1;\n\t\tretval = devm_request_threaded_irq(&pdev->dev, pdata->vbus->irq,\n\t\t\t\t\t\tNULL, mv_otg_inputs_irq,\n\t\t\t\t\t\tIRQF_ONESHOT, \"vbus\", mvotg);\n\t\tif (retval) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"Failed to request irq for VBUS, \"\n\t\t\t\t \"disable clock gating\\n\");\n\t\t\tmvotg->clock_gating = 0;\n\t\t\tpdata->vbus = NULL;\n\t\t}\n\t}\n\n\tif (pdata->disable_otg_clock_gating)\n\t\tmvotg->clock_gating = 0;\n\n\tmv_otg_reset(mvotg);\n\tmv_otg_init_irq(mvotg);\n\n\tr = platform_get_resource(mvotg->pdev, IORESOURCE_IRQ, 0);\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no IRQ resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_disable_clk;\n\t}\n\n\tmvotg->irq = r->start;\n\tif (devm_request_irq(&pdev->dev, mvotg->irq, mv_otg_irq, IRQF_SHARED,\n\t\t\tdriver_name, mvotg)) {\n\t\tdev_err(&pdev->dev, \"Request irq %d for OTG failed\\n\",\n\t\t\tmvotg->irq);\n\t\tmvotg->irq = 0;\n\t\tretval = -ENODEV;\n\t\tgoto err_disable_clk;\n\t}\n\n\tretval = usb_add_phy(&mvotg->phy, USB_PHY_TYPE_USB2);\n\tif (retval < 0) {\n\t\tdev_err(&pdev->dev, \"can't register transceiver, %d\\n\",\n\t\t\tretval);\n\t\tgoto err_disable_clk;\n\t}\n\n\tspin_lock_init(&mvotg->wq_lock);\n\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\tmv_otg_run_state_machine(mvotg, 2 * HZ);\n\t\tspin_unlock(&mvotg->wq_lock);\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t \"successful probe OTG device %s clock gating.\\n\",\n\t\t mvotg->clock_gating ? \"with\" : \"without\");\n\n\treturn 0;\n\nerr_disable_clk:\n\tmv_otg_disable_internal(mvotg);\nerr_destroy_workqueue:\n\tdestroy_workqueue(mvotg->qwork);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\nstatic int mv_otg_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct mv_otg *mvotg = platform_get_drvdata(pdev);\n\n\tif (mvotg->phy.otg->state != OTG_STATE_B_IDLE) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"OTG state is not B_IDLE, it is %d!\\n\",\n\t\t\t mvotg->phy.otg->state);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!mvotg->clock_gating)\n\t\tmv_otg_disable_internal(mvotg);\n\n\treturn 0;\n}\n\nstatic int mv_otg_resume(struct platform_device *pdev)\n{\n\tstruct mv_otg *mvotg = platform_get_drvdata(pdev);\n\tu32 otgsc;\n\n\tif (!mvotg->clock_gating) {\n\t\tmv_otg_enable_internal(mvotg);\n\n\t\totgsc = readl(&mvotg->op_regs->otgsc);\n\t\totgsc |= mvotg->irq_en;\n\t\twritel(otgsc, &mvotg->op_regs->otgsc);\n\n\t\tif (spin_trylock(&mvotg->wq_lock)) {\n\t\t\tmv_otg_run_state_machine(mvotg, 0);\n\t\t\tspin_unlock(&mvotg->wq_lock);\n\t\t}\n\t}\n\treturn 0;\n}\n#endif\n\nstatic struct platform_driver mv_otg_driver = {\n\t.probe = mv_otg_probe,\n\t.remove_new = mv_otg_remove,\n\t.driver = {\n\t\t   .name = driver_name,\n\t\t   .dev_groups = mv_otg_groups,\n\t\t   },\n#ifdef CONFIG_PM\n\t.suspend = mv_otg_suspend,\n\t.resume = mv_otg_resume,\n#endif\n};\nmodule_platform_driver(mv_otg_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}