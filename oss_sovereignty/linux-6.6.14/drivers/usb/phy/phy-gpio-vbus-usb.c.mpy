{
  "module_name": "phy-gpio-vbus-usb.c",
  "hash_id": "59e0fff7f6d804458d526534153c3405a948633cb445a75e03e6cc9d12c391c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-gpio-vbus-usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/workqueue.h>\n\n#include <linux/regulator/consumer.h>\n\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n\n\n \nstruct gpio_vbus_data {\n\tstruct gpio_desc\t*vbus_gpiod;\n\tstruct gpio_desc\t*pullup_gpiod;\n\tstruct usb_phy\t\tphy;\n\tstruct device          *dev;\n\tstruct regulator       *vbus_draw;\n\tint\t\t\tvbus_draw_enabled;\n\tunsigned\t\tmA;\n\tstruct delayed_work\twork;\n\tint\t\t\tvbus;\n\tint\t\t\tirq;\n};\n\n\n \n#define VBUS_IRQ_FLAGS \\\n\t(IRQF_SHARED | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)\n\n\n \nstatic void set_vbus_draw(struct gpio_vbus_data *gpio_vbus, unsigned mA)\n{\n\tstruct regulator *vbus_draw = gpio_vbus->vbus_draw;\n\tint enabled;\n\tint ret;\n\n\tif (!vbus_draw)\n\t\treturn;\n\n\tenabled = gpio_vbus->vbus_draw_enabled;\n\tif (mA) {\n\t\tregulator_set_current_limit(vbus_draw, 0, 1000 * mA);\n\t\tif (!enabled) {\n\t\t\tret = regulator_enable(vbus_draw);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tgpio_vbus->vbus_draw_enabled = 1;\n\t\t}\n\t} else {\n\t\tif (enabled) {\n\t\t\tret = regulator_disable(vbus_draw);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tgpio_vbus->vbus_draw_enabled = 0;\n\t\t}\n\t}\n\tgpio_vbus->mA = mA;\n}\n\nstatic int is_vbus_powered(struct gpio_vbus_data *gpio_vbus)\n{\n\treturn gpiod_get_value(gpio_vbus->vbus_gpiod);\n}\n\nstatic void gpio_vbus_work(struct work_struct *work)\n{\n\tstruct gpio_vbus_data *gpio_vbus =\n\t\tcontainer_of(work, struct gpio_vbus_data, work.work);\n\tint status, vbus;\n\n\tif (!gpio_vbus->phy.otg->gadget)\n\t\treturn;\n\n\tvbus = is_vbus_powered(gpio_vbus);\n\tif ((vbus ^ gpio_vbus->vbus) == 0)\n\t\treturn;\n\tgpio_vbus->vbus = vbus;\n\n\t \n\n\tif (vbus) {\n\t\tstatus = USB_EVENT_VBUS;\n\t\tgpio_vbus->phy.otg->state = OTG_STATE_B_PERIPHERAL;\n\t\tgpio_vbus->phy.last_event = status;\n\t\tusb_gadget_vbus_connect(gpio_vbus->phy.otg->gadget);\n\n\t\t \n\t\tset_vbus_draw(gpio_vbus, 100);\n\n\t\t \n\t\tif (gpio_vbus->pullup_gpiod)\n\t\t\tgpiod_set_value(gpio_vbus->pullup_gpiod, 1);\n\n\t\tatomic_notifier_call_chain(&gpio_vbus->phy.notifier,\n\t\t\t\t\t   status, gpio_vbus->phy.otg->gadget);\n\t\tusb_phy_set_event(&gpio_vbus->phy, USB_EVENT_ENUMERATED);\n\t} else {\n\t\t \n\t\tif (gpio_vbus->pullup_gpiod)\n\t\t\tgpiod_set_value(gpio_vbus->pullup_gpiod, 0);\n\n\t\tset_vbus_draw(gpio_vbus, 0);\n\n\t\tusb_gadget_vbus_disconnect(gpio_vbus->phy.otg->gadget);\n\t\tstatus = USB_EVENT_NONE;\n\t\tgpio_vbus->phy.otg->state = OTG_STATE_B_IDLE;\n\t\tgpio_vbus->phy.last_event = status;\n\n\t\tatomic_notifier_call_chain(&gpio_vbus->phy.notifier,\n\t\t\t\t\t   status, gpio_vbus->phy.otg->gadget);\n\t\tusb_phy_set_event(&gpio_vbus->phy, USB_EVENT_NONE);\n\t}\n}\n\n \nstatic irqreturn_t gpio_vbus_irq(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\n\tstruct usb_otg *otg = gpio_vbus->phy.otg;\n\n\tdev_dbg(&pdev->dev, \"VBUS %s (gadget: %s)\\n\",\n\t\tis_vbus_powered(gpio_vbus) ? \"supplied\" : \"inactive\",\n\t\totg->gadget ? otg->gadget->name : \"none\");\n\n\tif (otg->gadget)\n\t\tschedule_delayed_work(&gpio_vbus->work, msecs_to_jiffies(100));\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int gpio_vbus_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\tstruct usb_gadget *gadget)\n{\n\tstruct gpio_vbus_data *gpio_vbus;\n\tstruct platform_device *pdev;\n\n\tgpio_vbus = container_of(otg->usb_phy, struct gpio_vbus_data, phy);\n\tpdev = to_platform_device(gpio_vbus->dev);\n\n\tif (!gadget) {\n\t\tdev_dbg(&pdev->dev, \"unregistering gadget '%s'\\n\",\n\t\t\totg->gadget->name);\n\n\t\t \n\t\tif (gpio_vbus->pullup_gpiod)\n\t\t\tgpiod_set_value(gpio_vbus->pullup_gpiod, 0);\n\n\t\tset_vbus_draw(gpio_vbus, 0);\n\n\t\tusb_gadget_vbus_disconnect(otg->gadget);\n\t\totg->state = OTG_STATE_UNDEFINED;\n\n\t\totg->gadget = NULL;\n\t\treturn 0;\n\t}\n\n\totg->gadget = gadget;\n\tdev_dbg(&pdev->dev, \"registered gadget '%s'\\n\", gadget->name);\n\n\t \n\tgpio_vbus->vbus = 0;  \n\tgpio_vbus_irq(gpio_vbus->irq, pdev);\n\treturn 0;\n}\n\n \nstatic int gpio_vbus_set_power(struct usb_phy *phy, unsigned mA)\n{\n\tstruct gpio_vbus_data *gpio_vbus;\n\n\tgpio_vbus = container_of(phy, struct gpio_vbus_data, phy);\n\n\tif (phy->otg->state == OTG_STATE_B_PERIPHERAL)\n\t\tset_vbus_draw(gpio_vbus, mA);\n\treturn 0;\n}\n\n \nstatic int gpio_vbus_set_suspend(struct usb_phy *phy, int suspend)\n{\n\tstruct gpio_vbus_data *gpio_vbus;\n\n\tgpio_vbus = container_of(phy, struct gpio_vbus_data, phy);\n\n\t \n\treturn gpio_vbus_set_power(phy, suspend ? 0 : gpio_vbus->mA);\n}\n\n \n\nstatic int gpio_vbus_probe(struct platform_device *pdev)\n{\n\tstruct gpio_vbus_data *gpio_vbus;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tint err, irq;\n\tunsigned long irqflags;\n\n\tgpio_vbus = devm_kzalloc(&pdev->dev, sizeof(struct gpio_vbus_data),\n\t\t\t\t GFP_KERNEL);\n\tif (!gpio_vbus)\n\t\treturn -ENOMEM;\n\n\tgpio_vbus->phy.otg = devm_kzalloc(&pdev->dev, sizeof(struct usb_otg),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!gpio_vbus->phy.otg)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, gpio_vbus);\n\tgpio_vbus->dev = &pdev->dev;\n\tgpio_vbus->phy.label = \"gpio-vbus\";\n\tgpio_vbus->phy.dev = gpio_vbus->dev;\n\tgpio_vbus->phy.set_power = gpio_vbus_set_power;\n\tgpio_vbus->phy.set_suspend = gpio_vbus_set_suspend;\n\n\tgpio_vbus->phy.otg->state = OTG_STATE_UNDEFINED;\n\tgpio_vbus->phy.otg->usb_phy = &gpio_vbus->phy;\n\tgpio_vbus->phy.otg->set_peripheral = gpio_vbus_set_peripheral;\n\n\t \n\tgpio_vbus->vbus_gpiod = devm_gpiod_get(dev, \"vbus\", GPIOD_IN);\n\tif (IS_ERR(gpio_vbus->vbus_gpiod)) {\n\t\terr = PTR_ERR(gpio_vbus->vbus_gpiod);\n\t\tdev_err(&pdev->dev, \"can't request vbus gpio, err: %d\\n\", err);\n\t\treturn err;\n\t}\n\tgpiod_set_consumer_name(gpio_vbus->vbus_gpiod, \"vbus_detect\");\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (res) {\n\t\tirq = res->start;\n\t\tirqflags = (res->flags & IRQF_TRIGGER_MASK) | IRQF_SHARED;\n\t} else {\n\t\tirq = gpiod_to_irq(gpio_vbus->vbus_gpiod);\n\t\tirqflags = VBUS_IRQ_FLAGS;\n\t}\n\n\tgpio_vbus->irq = irq;\n\n\t \n\tgpio_vbus->pullup_gpiod = devm_gpiod_get_optional(dev, \"pullup\",\n\t\t\t\t\t\t\t  GPIOD_OUT_LOW);\n\tif (IS_ERR(gpio_vbus->pullup_gpiod)) {\n\t\terr = PTR_ERR(gpio_vbus->pullup_gpiod);\n\t\tdev_err(&pdev->dev, \"can't request pullup gpio, err: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\tif (gpio_vbus->pullup_gpiod)\n\t\tgpiod_set_consumer_name(gpio_vbus->pullup_gpiod, \"udc_pullup\");\n\n\terr = devm_request_irq(&pdev->dev, irq, gpio_vbus_irq, irqflags,\n\t\t\t       \"vbus_detect\", pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"can't request irq %i, err: %d\\n\",\n\t\t\tirq, err);\n\t\treturn err;\n\t}\n\n\tINIT_DELAYED_WORK(&gpio_vbus->work, gpio_vbus_work);\n\n\tgpio_vbus->vbus_draw = devm_regulator_get(&pdev->dev, \"vbus_draw\");\n\tif (IS_ERR(gpio_vbus->vbus_draw)) {\n\t\tdev_dbg(&pdev->dev, \"can't get vbus_draw regulator, err: %ld\\n\",\n\t\t\tPTR_ERR(gpio_vbus->vbus_draw));\n\t\tgpio_vbus->vbus_draw = NULL;\n\t}\n\n\t \n\terr = usb_add_phy(&gpio_vbus->phy, USB_PHY_TYPE_USB2);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"can't register transceiver, err: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\t \n\n\treturn 0;\n}\n\nstatic void gpio_vbus_remove(struct platform_device *pdev)\n{\n\tstruct gpio_vbus_data *gpio_vbus = platform_get_drvdata(pdev);\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tcancel_delayed_work_sync(&gpio_vbus->work);\n\n\tusb_remove_phy(&gpio_vbus->phy);\n}\n\n#ifdef CONFIG_PM\nstatic int gpio_vbus_pm_suspend(struct device *dev)\n{\n\tstruct gpio_vbus_data *gpio_vbus = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(gpio_vbus->irq);\n\n\treturn 0;\n}\n\nstatic int gpio_vbus_pm_resume(struct device *dev)\n{\n\tstruct gpio_vbus_data *gpio_vbus = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(gpio_vbus->irq);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops gpio_vbus_dev_pm_ops = {\n\t.suspend\t= gpio_vbus_pm_suspend,\n\t.resume\t\t= gpio_vbus_pm_resume,\n};\n#endif\n\nMODULE_ALIAS(\"platform:gpio-vbus\");\n\n \nstatic const struct of_device_id gpio_vbus_of_match[] = {\n\t{\n\t\t.compatible = \"gpio-usb-b-connector\",\n\t},\n\t{},\n};\n\nstatic struct platform_driver gpio_vbus_driver = {\n\t.driver = {\n\t\t.name  = \"gpio-vbus\",\n#ifdef CONFIG_PM\n\t\t.pm = &gpio_vbus_dev_pm_ops,\n#endif\n\t\t.of_match_table = gpio_vbus_of_match,\n\t},\n\t.probe\t\t= gpio_vbus_probe,\n\t.remove_new\t= gpio_vbus_remove,\n};\n\nmodule_platform_driver(gpio_vbus_driver);\n\nMODULE_DESCRIPTION(\"simple GPIO controlled OTG transceiver driver\");\nMODULE_AUTHOR(\"Philipp Zabel\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}