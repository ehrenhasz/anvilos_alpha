{
  "module_name": "phy-tegra-usb.c",
  "hash_id": "46d495199e44e4afc6e2337dfc5cf49455a25b766aae8faf087b77ad182d43b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-tegra-usb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/resource.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include <linux/regulator/consumer.h>\n\n#include <linux/usb/ehci_def.h>\n#include <linux/usb/of.h>\n#include <linux/usb/tegra_usb_phy.h>\n#include <linux/usb/ulpi.h>\n\n#define ULPI_VIEWPORT\t\t\t\t0x170\n\n \n#define TEGRA_USB_PORTSC1\t\t\t0x184\n#define TEGRA_USB_PORTSC1_PTS(x)\t\t(((x) & 0x3) << 30)\n#define TEGRA_USB_PORTSC1_PHCD\t\t\tBIT(23)\n\n \n#define TEGRA_USB_HOSTPC1_DEVLC\t\t\t0x1b4\n#define TEGRA_USB_HOSTPC1_DEVLC_PTS(x)\t\t(((x) & 0x7) << 29)\n#define TEGRA_USB_HOSTPC1_DEVLC_PHCD\t\tBIT(22)\n\n \n#define TEGRA_PORTSC1_RWC_BITS\t(PORT_CSC | PORT_PEC | PORT_OCC)\n\n#define USB_SUSP_CTRL\t\t\t\t0x400\n#define   USB_WAKE_ON_RESUME_EN\t\t\tBIT(2)\n#define   USB_WAKE_ON_CNNT_EN_DEV\t\tBIT(3)\n#define   USB_WAKE_ON_DISCON_EN_DEV\t\tBIT(4)\n#define   USB_SUSP_CLR\t\t\t\tBIT(5)\n#define   USB_PHY_CLK_VALID\t\t\tBIT(7)\n#define   UTMIP_RESET\t\t\t\tBIT(11)\n#define   UHSIC_RESET\t\t\t\tBIT(11)\n#define   UTMIP_PHY_ENABLE\t\t\tBIT(12)\n#define   ULPI_PHY_ENABLE\t\t\tBIT(13)\n#define   USB_SUSP_SET\t\t\t\tBIT(14)\n#define   USB_WAKEUP_DEBOUNCE_COUNT(x)\t\t(((x) & 0x7) << 16)\n\n#define USB_PHY_VBUS_SENSORS\t\t\t0x404\n#define   B_SESS_VLD_WAKEUP_EN\t\t\tBIT(14)\n#define   A_SESS_VLD_WAKEUP_EN\t\t\tBIT(22)\n#define   A_VBUS_VLD_WAKEUP_EN\t\t\tBIT(30)\n\n#define USB_PHY_VBUS_WAKEUP_ID\t\t\t0x408\n#define   ID_INT_EN\t\t\t\tBIT(0)\n#define   ID_CHG_DET\t\t\t\tBIT(1)\n#define   VBUS_WAKEUP_INT_EN\t\t\tBIT(8)\n#define   VBUS_WAKEUP_CHG_DET\t\t\tBIT(9)\n#define   VBUS_WAKEUP_STS\t\t\tBIT(10)\n#define   VBUS_WAKEUP_WAKEUP_EN\t\t\tBIT(30)\n\n#define USB1_LEGACY_CTRL\t\t\t0x410\n#define   USB1_NO_LEGACY_MODE\t\t\tBIT(0)\n#define   USB1_VBUS_SENSE_CTL_MASK\t\t(3 << 1)\n#define   USB1_VBUS_SENSE_CTL_VBUS_WAKEUP\t(0 << 1)\n#define   USB1_VBUS_SENSE_CTL_AB_SESS_VLD_OR_VBUS_WAKEUP \\\n\t\t\t\t\t\t(1 << 1)\n#define   USB1_VBUS_SENSE_CTL_AB_SESS_VLD\t(2 << 1)\n#define   USB1_VBUS_SENSE_CTL_A_SESS_VLD\t(3 << 1)\n\n#define ULPI_TIMING_CTRL_0\t\t\t0x424\n#define   ULPI_OUTPUT_PINMUX_BYP\t\tBIT(10)\n#define   ULPI_CLKOUT_PINMUX_BYP\t\tBIT(11)\n\n#define ULPI_TIMING_CTRL_1\t\t\t0x428\n#define   ULPI_DATA_TRIMMER_LOAD\t\tBIT(0)\n#define   ULPI_DATA_TRIMMER_SEL(x)\t\t(((x) & 0x7) << 1)\n#define   ULPI_STPDIRNXT_TRIMMER_LOAD\t\tBIT(16)\n#define   ULPI_STPDIRNXT_TRIMMER_SEL(x)\t\t(((x) & 0x7) << 17)\n#define   ULPI_DIR_TRIMMER_LOAD\t\t\tBIT(24)\n#define   ULPI_DIR_TRIMMER_SEL(x)\t\t(((x) & 0x7) << 25)\n\n#define UTMIP_PLL_CFG1\t\t\t\t0x804\n#define   UTMIP_XTAL_FREQ_COUNT(x)\t\t(((x) & 0xfff) << 0)\n#define   UTMIP_PLLU_ENABLE_DLY_COUNT(x)\t(((x) & 0x1f) << 27)\n\n#define UTMIP_XCVR_CFG0\t\t\t\t0x808\n#define   UTMIP_XCVR_SETUP(x)\t\t\t(((x) & 0xf) << 0)\n#define   UTMIP_XCVR_SETUP_MSB(x)\t\t((((x) & 0x70) >> 4) << 22)\n#define   UTMIP_XCVR_LSRSLEW(x)\t\t\t(((x) & 0x3) << 8)\n#define   UTMIP_XCVR_LSFSLEW(x)\t\t\t(((x) & 0x3) << 10)\n#define   UTMIP_FORCE_PD_POWERDOWN\t\tBIT(14)\n#define   UTMIP_FORCE_PD2_POWERDOWN\t\tBIT(16)\n#define   UTMIP_FORCE_PDZI_POWERDOWN\t\tBIT(18)\n#define   UTMIP_XCVR_LSBIAS_SEL\t\t\tBIT(21)\n#define   UTMIP_XCVR_HSSLEW(x)\t\t\t(((x) & 0x3) << 4)\n#define   UTMIP_XCVR_HSSLEW_MSB(x)\t\t((((x) & 0x1fc) >> 2) << 25)\n\n#define UTMIP_BIAS_CFG0\t\t\t\t0x80c\n#define   UTMIP_OTGPD\t\t\t\tBIT(11)\n#define   UTMIP_BIASPD\t\t\t\tBIT(10)\n#define   UTMIP_HSSQUELCH_LEVEL(x)\t\t(((x) & 0x3) << 0)\n#define   UTMIP_HSDISCON_LEVEL(x)\t\t(((x) & 0x3) << 2)\n#define   UTMIP_HSDISCON_LEVEL_MSB(x)\t\t((((x) & 0x4) >> 2) << 24)\n\n#define UTMIP_HSRX_CFG0\t\t\t\t0x810\n#define   UTMIP_ELASTIC_LIMIT(x)\t\t(((x) & 0x1f) << 10)\n#define   UTMIP_IDLE_WAIT(x)\t\t\t(((x) & 0x1f) << 15)\n\n#define UTMIP_HSRX_CFG1\t\t\t\t0x814\n#define   UTMIP_HS_SYNC_START_DLY(x)\t\t(((x) & 0x1f) << 1)\n\n#define UTMIP_TX_CFG0\t\t\t\t0x820\n#define   UTMIP_FS_PREABMLE_J\t\t\tBIT(19)\n#define   UTMIP_HS_DISCON_DISABLE\t\tBIT(8)\n\n#define UTMIP_MISC_CFG0\t\t\t\t0x824\n#define   UTMIP_DPDM_OBSERVE\t\t\tBIT(26)\n#define   UTMIP_DPDM_OBSERVE_SEL(x)\t\t(((x) & 0xf) << 27)\n#define   UTMIP_DPDM_OBSERVE_SEL_FS_J\t\tUTMIP_DPDM_OBSERVE_SEL(0xf)\n#define   UTMIP_DPDM_OBSERVE_SEL_FS_K\t\tUTMIP_DPDM_OBSERVE_SEL(0xe)\n#define   UTMIP_DPDM_OBSERVE_SEL_FS_SE1\t\tUTMIP_DPDM_OBSERVE_SEL(0xd)\n#define   UTMIP_DPDM_OBSERVE_SEL_FS_SE0\t\tUTMIP_DPDM_OBSERVE_SEL(0xc)\n#define   UTMIP_SUSPEND_EXIT_ON_EDGE\t\tBIT(22)\n\n#define UTMIP_MISC_CFG1\t\t\t\t0x828\n#define   UTMIP_PLL_ACTIVE_DLY_COUNT(x)\t\t(((x) & 0x1f) << 18)\n#define   UTMIP_PLLU_STABLE_COUNT(x)\t\t(((x) & 0xfff) << 6)\n\n#define UTMIP_DEBOUNCE_CFG0\t\t\t0x82c\n#define   UTMIP_BIAS_DEBOUNCE_A(x)\t\t(((x) & 0xffff) << 0)\n\n#define UTMIP_BAT_CHRG_CFG0\t\t\t0x830\n#define   UTMIP_PD_CHRG\t\t\t\tBIT(0)\n\n#define UTMIP_SPARE_CFG0\t\t\t0x834\n#define   FUSE_SETUP_SEL\t\t\tBIT(3)\n\n#define UTMIP_XCVR_CFG1\t\t\t\t0x838\n#define   UTMIP_FORCE_PDDISC_POWERDOWN\t\tBIT(0)\n#define   UTMIP_FORCE_PDCHRP_POWERDOWN\t\tBIT(2)\n#define   UTMIP_FORCE_PDDR_POWERDOWN\t\tBIT(4)\n#define   UTMIP_XCVR_TERM_RANGE_ADJ(x)\t\t(((x) & 0xf) << 18)\n\n#define UTMIP_BIAS_CFG1\t\t\t\t0x83c\n#define   UTMIP_BIAS_PDTRK_COUNT(x)\t\t(((x) & 0x1f) << 3)\n\n \n#define USB_USBMODE\t\t\t\t0x1f8\n#define   USB_USBMODE_MASK\t\t\t(3 << 0)\n#define   USB_USBMODE_HOST\t\t\t(3 << 0)\n#define   USB_USBMODE_DEVICE\t\t\t(2 << 0)\n\n#define PMC_USB_AO\t\t\t\t0xf0\n#define   VBUS_WAKEUP_PD_P0\t\t\tBIT(2)\n#define   ID_PD_P0\t\t\t\tBIT(3)\n\nstatic DEFINE_SPINLOCK(utmip_pad_lock);\nstatic unsigned int utmip_pad_count;\n\nstruct tegra_xtal_freq {\n\tunsigned int freq;\n\tu8 enable_delay;\n\tu8 stable_count;\n\tu8 active_delay;\n\tu8 xtal_freq_count;\n\tu16 debounce;\n};\n\nstatic const struct tegra_xtal_freq tegra_freq_table[] = {\n\t{\n\t\t.freq = 12000000,\n\t\t.enable_delay = 0x02,\n\t\t.stable_count = 0x2F,\n\t\t.active_delay = 0x04,\n\t\t.xtal_freq_count = 0x76,\n\t\t.debounce = 0x7530,\n\t},\n\t{\n\t\t.freq = 13000000,\n\t\t.enable_delay = 0x02,\n\t\t.stable_count = 0x33,\n\t\t.active_delay = 0x05,\n\t\t.xtal_freq_count = 0x7F,\n\t\t.debounce = 0x7EF4,\n\t},\n\t{\n\t\t.freq = 19200000,\n\t\t.enable_delay = 0x03,\n\t\t.stable_count = 0x4B,\n\t\t.active_delay = 0x06,\n\t\t.xtal_freq_count = 0xBB,\n\t\t.debounce = 0xBB80,\n\t},\n\t{\n\t\t.freq = 26000000,\n\t\t.enable_delay = 0x04,\n\t\t.stable_count = 0x66,\n\t\t.active_delay = 0x09,\n\t\t.xtal_freq_count = 0xFE,\n\t\t.debounce = 0xFDE8,\n\t},\n};\n\nstatic inline struct tegra_usb_phy *to_tegra_usb_phy(struct usb_phy *u_phy)\n{\n\treturn container_of(u_phy, struct tegra_usb_phy, u_phy);\n}\n\nstatic void set_pts(struct tegra_usb_phy *phy, u8 pts_val)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tif (phy->soc_config->has_hostpc) {\n\t\tval = readl_relaxed(base + TEGRA_USB_HOSTPC1_DEVLC);\n\t\tval &= ~TEGRA_USB_HOSTPC1_DEVLC_PTS(~0);\n\t\tval |= TEGRA_USB_HOSTPC1_DEVLC_PTS(pts_val);\n\t\twritel_relaxed(val, base + TEGRA_USB_HOSTPC1_DEVLC);\n\t} else {\n\t\tval = readl_relaxed(base + TEGRA_USB_PORTSC1);\n\t\tval &= ~TEGRA_PORTSC1_RWC_BITS;\n\t\tval &= ~TEGRA_USB_PORTSC1_PTS(~0);\n\t\tval |= TEGRA_USB_PORTSC1_PTS(pts_val);\n\t\twritel_relaxed(val, base + TEGRA_USB_PORTSC1);\n\t}\n}\n\nstatic void set_phcd(struct tegra_usb_phy *phy, bool enable)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tif (phy->soc_config->has_hostpc) {\n\t\tval = readl_relaxed(base + TEGRA_USB_HOSTPC1_DEVLC);\n\t\tif (enable)\n\t\t\tval |= TEGRA_USB_HOSTPC1_DEVLC_PHCD;\n\t\telse\n\t\t\tval &= ~TEGRA_USB_HOSTPC1_DEVLC_PHCD;\n\t\twritel_relaxed(val, base + TEGRA_USB_HOSTPC1_DEVLC);\n\t} else {\n\t\tval = readl_relaxed(base + TEGRA_USB_PORTSC1) & ~PORT_RWC_BITS;\n\t\tif (enable)\n\t\t\tval |= TEGRA_USB_PORTSC1_PHCD;\n\t\telse\n\t\t\tval &= ~TEGRA_USB_PORTSC1_PHCD;\n\t\twritel_relaxed(val, base + TEGRA_USB_PORTSC1);\n\t}\n}\n\nstatic int utmip_pad_open(struct tegra_usb_phy *phy)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(phy->pad_clk);\n\tif (ret) {\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to enable UTMI-pads clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&utmip_pad_lock);\n\n\tret = reset_control_deassert(phy->pad_rst);\n\tif (ret) {\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to initialize UTMI-pads reset: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tret = reset_control_assert(phy->pad_rst);\n\tif (ret) {\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to assert UTMI-pads reset: %d\\n\", ret);\n\t\tgoto unlock;\n\t}\n\n\tudelay(1);\n\n\tret = reset_control_deassert(phy->pad_rst);\n\tif (ret)\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to deassert UTMI-pads reset: %d\\n\", ret);\nunlock:\n\tspin_unlock(&utmip_pad_lock);\n\n\tclk_disable_unprepare(phy->pad_clk);\n\n\treturn ret;\n}\n\nstatic int utmip_pad_close(struct tegra_usb_phy *phy)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(phy->pad_clk);\n\tif (ret) {\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to enable UTMI-pads clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(phy->pad_rst);\n\tif (ret)\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to assert UTMI-pads reset: %d\\n\", ret);\n\n\tudelay(1);\n\n\tclk_disable_unprepare(phy->pad_clk);\n\n\treturn ret;\n}\n\nstatic int utmip_pad_power_on(struct tegra_usb_phy *phy)\n{\n\tstruct tegra_utmip_config *config = phy->config;\n\tvoid __iomem *base = phy->pad_regs;\n\tu32 val;\n\tint err;\n\n\terr = clk_prepare_enable(phy->pad_clk);\n\tif (err)\n\t\treturn err;\n\n\tspin_lock(&utmip_pad_lock);\n\n\tif (utmip_pad_count++ == 0) {\n\t\tval = readl_relaxed(base + UTMIP_BIAS_CFG0);\n\t\tval &= ~(UTMIP_OTGPD | UTMIP_BIASPD);\n\n\t\tif (phy->soc_config->requires_extra_tuning_parameters) {\n\t\t\tval &= ~(UTMIP_HSSQUELCH_LEVEL(~0) |\n\t\t\t\tUTMIP_HSDISCON_LEVEL(~0) |\n\t\t\t\tUTMIP_HSDISCON_LEVEL_MSB(~0));\n\n\t\t\tval |= UTMIP_HSSQUELCH_LEVEL(config->hssquelch_level);\n\t\t\tval |= UTMIP_HSDISCON_LEVEL(config->hsdiscon_level);\n\t\t\tval |= UTMIP_HSDISCON_LEVEL_MSB(config->hsdiscon_level);\n\t\t}\n\t\twritel_relaxed(val, base + UTMIP_BIAS_CFG0);\n\t}\n\n\tif (phy->pad_wakeup) {\n\t\tphy->pad_wakeup = false;\n\t\tutmip_pad_count--;\n\t}\n\n\tspin_unlock(&utmip_pad_lock);\n\n\tclk_disable_unprepare(phy->pad_clk);\n\n\treturn 0;\n}\n\nstatic int utmip_pad_power_off(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->pad_regs;\n\tu32 val;\n\tint ret;\n\n\tret = clk_prepare_enable(phy->pad_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&utmip_pad_lock);\n\n\tif (!utmip_pad_count) {\n\t\tdev_err(phy->u_phy.dev, \"UTMIP pad already powered off\\n\");\n\t\tret = -EINVAL;\n\t\tgoto ulock;\n\t}\n\n\t \n\tif (phy->wakeup_enabled) {\n\t\tphy->pad_wakeup = true;\n\t\tutmip_pad_count++;\n\t}\n\n\tif (--utmip_pad_count == 0) {\n\t\tval = readl_relaxed(base + UTMIP_BIAS_CFG0);\n\t\tval |= UTMIP_OTGPD | UTMIP_BIASPD;\n\t\twritel_relaxed(val, base + UTMIP_BIAS_CFG0);\n\t}\nulock:\n\tspin_unlock(&utmip_pad_lock);\n\n\tclk_disable_unprepare(phy->pad_clk);\n\n\treturn ret;\n}\n\nstatic int utmi_wait_register(void __iomem *reg, u32 mask, u32 result)\n{\n\tu32 tmp;\n\n\treturn readl_relaxed_poll_timeout(reg, tmp, (tmp & mask) == result,\n\t\t\t\t\t  2000, 6000);\n}\n\nstatic void utmi_phy_clk_disable(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\t \n\tif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID, 0) == 0)\n\t\treturn;\n\n\tif (phy->is_legacy_phy) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval |= USB_SUSP_SET;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\t\tusleep_range(10, 100);\n\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval &= ~USB_SUSP_SET;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\t} else {\n\t\tset_phcd(phy, true);\n\t}\n\n\tif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID, 0))\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Timeout waiting for PHY to stabilize on disable\\n\");\n}\n\nstatic void utmi_phy_clk_enable(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\t \n\tif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID,\n\t\t\t       USB_PHY_CLK_VALID) == 0)\n\t\treturn;\n\n\tif (phy->is_legacy_phy) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval |= USB_SUSP_CLR;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\t\tusleep_range(10, 100);\n\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval &= ~USB_SUSP_CLR;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\t} else {\n\t\tset_phcd(phy, false);\n\t}\n\n\tif (utmi_wait_register(base + USB_SUSP_CTRL, USB_PHY_CLK_VALID,\n\t\t\t       USB_PHY_CLK_VALID))\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Timeout waiting for PHY to stabilize on enable\\n\");\n}\n\nstatic int utmi_phy_power_on(struct tegra_usb_phy *phy)\n{\n\tstruct tegra_utmip_config *config = phy->config;\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\tint err;\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval |= UTMIP_RESET;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\tif (phy->is_legacy_phy) {\n\t\tval = readl_relaxed(base + USB1_LEGACY_CTRL);\n\t\tval |= USB1_NO_LEGACY_MODE;\n\t\twritel_relaxed(val, base + USB1_LEGACY_CTRL);\n\t}\n\n\tval = readl_relaxed(base + UTMIP_TX_CFG0);\n\tval |= UTMIP_FS_PREABMLE_J;\n\twritel_relaxed(val, base + UTMIP_TX_CFG0);\n\n\tval = readl_relaxed(base + UTMIP_HSRX_CFG0);\n\tval &= ~(UTMIP_IDLE_WAIT(~0) | UTMIP_ELASTIC_LIMIT(~0));\n\tval |= UTMIP_IDLE_WAIT(config->idle_wait_delay);\n\tval |= UTMIP_ELASTIC_LIMIT(config->elastic_limit);\n\twritel_relaxed(val, base + UTMIP_HSRX_CFG0);\n\n\tval = readl_relaxed(base + UTMIP_HSRX_CFG1);\n\tval &= ~UTMIP_HS_SYNC_START_DLY(~0);\n\tval |= UTMIP_HS_SYNC_START_DLY(config->hssync_start_delay);\n\twritel_relaxed(val, base + UTMIP_HSRX_CFG1);\n\n\tval = readl_relaxed(base + UTMIP_DEBOUNCE_CFG0);\n\tval &= ~UTMIP_BIAS_DEBOUNCE_A(~0);\n\tval |= UTMIP_BIAS_DEBOUNCE_A(phy->freq->debounce);\n\twritel_relaxed(val, base + UTMIP_DEBOUNCE_CFG0);\n\n\tval = readl_relaxed(base + UTMIP_MISC_CFG0);\n\tval &= ~UTMIP_SUSPEND_EXIT_ON_EDGE;\n\twritel_relaxed(val, base + UTMIP_MISC_CFG0);\n\n\tif (!phy->soc_config->utmi_pll_config_in_car_module) {\n\t\tval = readl_relaxed(base + UTMIP_MISC_CFG1);\n\t\tval &= ~(UTMIP_PLL_ACTIVE_DLY_COUNT(~0) |\n\t\t\tUTMIP_PLLU_STABLE_COUNT(~0));\n\t\tval |= UTMIP_PLL_ACTIVE_DLY_COUNT(phy->freq->active_delay) |\n\t\t\tUTMIP_PLLU_STABLE_COUNT(phy->freq->stable_count);\n\t\twritel_relaxed(val, base + UTMIP_MISC_CFG1);\n\n\t\tval = readl_relaxed(base + UTMIP_PLL_CFG1);\n\t\tval &= ~(UTMIP_XTAL_FREQ_COUNT(~0) |\n\t\t\tUTMIP_PLLU_ENABLE_DLY_COUNT(~0));\n\t\tval |= UTMIP_XTAL_FREQ_COUNT(phy->freq->xtal_freq_count) |\n\t\t\tUTMIP_PLLU_ENABLE_DLY_COUNT(phy->freq->enable_delay);\n\t\twritel_relaxed(val, base + UTMIP_PLL_CFG1);\n\t}\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval &= ~USB_WAKE_ON_RESUME_EN;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\tif (phy->mode != USB_DR_MODE_HOST) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval &= ~(USB_WAKE_ON_CNNT_EN_DEV | USB_WAKE_ON_DISCON_EN_DEV);\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\t\tval = readl_relaxed(base + USB_PHY_VBUS_WAKEUP_ID);\n\t\tval &= ~VBUS_WAKEUP_WAKEUP_EN;\n\t\tval &= ~(ID_CHG_DET | VBUS_WAKEUP_CHG_DET);\n\t\twritel_relaxed(val, base + USB_PHY_VBUS_WAKEUP_ID);\n\n\t\tval = readl_relaxed(base + USB_PHY_VBUS_SENSORS);\n\t\tval &= ~(A_VBUS_VLD_WAKEUP_EN | A_SESS_VLD_WAKEUP_EN);\n\t\tval &= ~(B_SESS_VLD_WAKEUP_EN);\n\t\twritel_relaxed(val, base + USB_PHY_VBUS_SENSORS);\n\n\t\tval = readl_relaxed(base + UTMIP_BAT_CHRG_CFG0);\n\t\tval &= ~UTMIP_PD_CHRG;\n\t\twritel_relaxed(val, base + UTMIP_BAT_CHRG_CFG0);\n\t} else {\n\t\tval = readl_relaxed(base + UTMIP_BAT_CHRG_CFG0);\n\t\tval |= UTMIP_PD_CHRG;\n\t\twritel_relaxed(val, base + UTMIP_BAT_CHRG_CFG0);\n\t}\n\n\terr = utmip_pad_power_on(phy);\n\tif (err)\n\t\treturn err;\n\n\tval = readl_relaxed(base + UTMIP_XCVR_CFG0);\n\tval &= ~(UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\n\t\t UTMIP_FORCE_PDZI_POWERDOWN | UTMIP_XCVR_LSBIAS_SEL |\n\t\t UTMIP_XCVR_SETUP(~0) | UTMIP_XCVR_SETUP_MSB(~0) |\n\t\t UTMIP_XCVR_LSFSLEW(~0) | UTMIP_XCVR_LSRSLEW(~0));\n\n\tif (!config->xcvr_setup_use_fuses) {\n\t\tval |= UTMIP_XCVR_SETUP(config->xcvr_setup);\n\t\tval |= UTMIP_XCVR_SETUP_MSB(config->xcvr_setup);\n\t}\n\tval |= UTMIP_XCVR_LSFSLEW(config->xcvr_lsfslew);\n\tval |= UTMIP_XCVR_LSRSLEW(config->xcvr_lsrslew);\n\n\tif (phy->soc_config->requires_extra_tuning_parameters) {\n\t\tval &= ~(UTMIP_XCVR_HSSLEW(~0) | UTMIP_XCVR_HSSLEW_MSB(~0));\n\t\tval |= UTMIP_XCVR_HSSLEW(config->xcvr_hsslew);\n\t\tval |= UTMIP_XCVR_HSSLEW_MSB(config->xcvr_hsslew);\n\t}\n\twritel_relaxed(val, base + UTMIP_XCVR_CFG0);\n\n\tval = readl_relaxed(base + UTMIP_XCVR_CFG1);\n\tval &= ~(UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\n\t\t UTMIP_FORCE_PDDR_POWERDOWN | UTMIP_XCVR_TERM_RANGE_ADJ(~0));\n\tval |= UTMIP_XCVR_TERM_RANGE_ADJ(config->term_range_adj);\n\twritel_relaxed(val, base + UTMIP_XCVR_CFG1);\n\n\tval = readl_relaxed(base + UTMIP_BIAS_CFG1);\n\tval &= ~UTMIP_BIAS_PDTRK_COUNT(~0);\n\tval |= UTMIP_BIAS_PDTRK_COUNT(0x5);\n\twritel_relaxed(val, base + UTMIP_BIAS_CFG1);\n\n\tval = readl_relaxed(base + UTMIP_SPARE_CFG0);\n\tif (config->xcvr_setup_use_fuses)\n\t\tval |= FUSE_SETUP_SEL;\n\telse\n\t\tval &= ~FUSE_SETUP_SEL;\n\twritel_relaxed(val, base + UTMIP_SPARE_CFG0);\n\n\tif (!phy->is_legacy_phy) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval |= UTMIP_PHY_ENABLE;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\t}\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval &= ~UTMIP_RESET;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\tif (phy->is_legacy_phy) {\n\t\tval = readl_relaxed(base + USB1_LEGACY_CTRL);\n\t\tval &= ~USB1_VBUS_SENSE_CTL_MASK;\n\t\tval |= USB1_VBUS_SENSE_CTL_A_SESS_VLD;\n\t\twritel_relaxed(val, base + USB1_LEGACY_CTRL);\n\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval &= ~USB_SUSP_SET;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\t}\n\n\tutmi_phy_clk_enable(phy);\n\n\tif (phy->soc_config->requires_usbmode_setup) {\n\t\tval = readl_relaxed(base + USB_USBMODE);\n\t\tval &= ~USB_USBMODE_MASK;\n\t\tif (phy->mode == USB_DR_MODE_HOST)\n\t\t\tval |= USB_USBMODE_HOST;\n\t\telse\n\t\t\tval |= USB_USBMODE_DEVICE;\n\t\twritel_relaxed(val, base + USB_USBMODE);\n\t}\n\n\tif (!phy->is_legacy_phy)\n\t\tset_pts(phy, 0);\n\n\treturn 0;\n}\n\nstatic int utmi_phy_power_off(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\t \n\tif (phy->wakeup_enabled && phy->mode != USB_DR_MODE_HOST)\n\t\treadl_relaxed_poll_timeout(base + USB_PHY_VBUS_WAKEUP_ID,\n\t\t\t\t\t   val, !(val & VBUS_WAKEUP_STS),\n\t\t\t\t\t   5000, 100000);\n\n\tutmi_phy_clk_disable(phy);\n\n\t \n\tif (!phy->wakeup_enabled) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval |= UTMIP_RESET;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\t}\n\n\tval = readl_relaxed(base + UTMIP_BAT_CHRG_CFG0);\n\tval |= UTMIP_PD_CHRG;\n\twritel_relaxed(val, base + UTMIP_BAT_CHRG_CFG0);\n\n\tif (!phy->wakeup_enabled) {\n\t\tval = readl_relaxed(base + UTMIP_XCVR_CFG0);\n\t\tval |= UTMIP_FORCE_PD_POWERDOWN | UTMIP_FORCE_PD2_POWERDOWN |\n\t\t       UTMIP_FORCE_PDZI_POWERDOWN;\n\t\twritel_relaxed(val, base + UTMIP_XCVR_CFG0);\n\t}\n\n\tval = readl_relaxed(base + UTMIP_XCVR_CFG1);\n\tval |= UTMIP_FORCE_PDDISC_POWERDOWN | UTMIP_FORCE_PDCHRP_POWERDOWN |\n\t       UTMIP_FORCE_PDDR_POWERDOWN;\n\twritel_relaxed(val, base + UTMIP_XCVR_CFG1);\n\n\tif (phy->wakeup_enabled) {\n\t\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\t\tval &= ~USB_WAKEUP_DEBOUNCE_COUNT(~0);\n\t\tval |= USB_WAKEUP_DEBOUNCE_COUNT(5);\n\t\tval |= USB_WAKE_ON_RESUME_EN;\n\t\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\t\t \n\t\tif (phy->mode != USB_DR_MODE_HOST) {\n\t\t\tval = readl_relaxed(base + USB_PHY_VBUS_WAKEUP_ID);\n\t\t\tval |= VBUS_WAKEUP_WAKEUP_EN;\n\t\t\tval &= ~(ID_CHG_DET | VBUS_WAKEUP_CHG_DET);\n\t\t\twritel_relaxed(val, base + USB_PHY_VBUS_WAKEUP_ID);\n\n\t\t\tval = readl_relaxed(base + USB_PHY_VBUS_SENSORS);\n\t\t\tval |= A_VBUS_VLD_WAKEUP_EN;\n\t\t\twritel_relaxed(val, base + USB_PHY_VBUS_SENSORS);\n\t\t}\n\t}\n\n\treturn utmip_pad_power_off(phy);\n}\n\nstatic void utmi_phy_preresume(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tval = readl_relaxed(base + UTMIP_TX_CFG0);\n\tval |= UTMIP_HS_DISCON_DISABLE;\n\twritel_relaxed(val, base + UTMIP_TX_CFG0);\n}\n\nstatic void utmi_phy_postresume(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tval = readl_relaxed(base + UTMIP_TX_CFG0);\n\tval &= ~UTMIP_HS_DISCON_DISABLE;\n\twritel_relaxed(val, base + UTMIP_TX_CFG0);\n}\n\nstatic void utmi_phy_restore_start(struct tegra_usb_phy *phy,\n\t\t\t\t   enum tegra_usb_phy_port_speed port_speed)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tval = readl_relaxed(base + UTMIP_MISC_CFG0);\n\tval &= ~UTMIP_DPDM_OBSERVE_SEL(~0);\n\tif (port_speed == TEGRA_USB_PHY_PORT_SPEED_LOW)\n\t\tval |= UTMIP_DPDM_OBSERVE_SEL_FS_K;\n\telse\n\t\tval |= UTMIP_DPDM_OBSERVE_SEL_FS_J;\n\twritel_relaxed(val, base + UTMIP_MISC_CFG0);\n\tusleep_range(1, 10);\n\n\tval = readl_relaxed(base + UTMIP_MISC_CFG0);\n\tval |= UTMIP_DPDM_OBSERVE;\n\twritel_relaxed(val, base + UTMIP_MISC_CFG0);\n\tusleep_range(10, 100);\n}\n\nstatic void utmi_phy_restore_end(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\n\tval = readl_relaxed(base + UTMIP_MISC_CFG0);\n\tval &= ~UTMIP_DPDM_OBSERVE;\n\twritel_relaxed(val, base + UTMIP_MISC_CFG0);\n\tusleep_range(10, 100);\n}\n\nstatic int ulpi_phy_power_on(struct tegra_usb_phy *phy)\n{\n\tvoid __iomem *base = phy->regs;\n\tu32 val;\n\tint err;\n\n\tgpiod_set_value_cansleep(phy->reset_gpio, 1);\n\n\terr = clk_prepare_enable(phy->clk);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(5000, 6000);\n\n\tgpiod_set_value_cansleep(phy->reset_gpio, 0);\n\n\tusleep_range(1000, 2000);\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval |= UHSIC_RESET;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\tval = readl_relaxed(base + ULPI_TIMING_CTRL_0);\n\tval |= ULPI_OUTPUT_PINMUX_BYP | ULPI_CLKOUT_PINMUX_BYP;\n\twritel_relaxed(val, base + ULPI_TIMING_CTRL_0);\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval |= ULPI_PHY_ENABLE;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\tval = 0;\n\twritel_relaxed(val, base + ULPI_TIMING_CTRL_1);\n\n\tval |= ULPI_DATA_TRIMMER_SEL(4);\n\tval |= ULPI_STPDIRNXT_TRIMMER_SEL(4);\n\tval |= ULPI_DIR_TRIMMER_SEL(4);\n\twritel_relaxed(val, base + ULPI_TIMING_CTRL_1);\n\tusleep_range(10, 100);\n\n\tval |= ULPI_DATA_TRIMMER_LOAD;\n\tval |= ULPI_STPDIRNXT_TRIMMER_LOAD;\n\tval |= ULPI_DIR_TRIMMER_LOAD;\n\twritel_relaxed(val, base + ULPI_TIMING_CTRL_1);\n\n\t \n\terr = usb_phy_io_write(phy->ulpi, 0x40, 0x08);\n\tif (err) {\n\t\tdev_err(phy->u_phy.dev, \"ULPI write failed: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\terr = usb_phy_io_write(phy->ulpi, 0x80, 0x0B);\n\tif (err) {\n\t\tdev_err(phy->u_phy.dev, \"ULPI write failed: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval |= USB_SUSP_CLR;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\tusleep_range(100, 1000);\n\n\tval = readl_relaxed(base + USB_SUSP_CTRL);\n\tval &= ~USB_SUSP_CLR;\n\twritel_relaxed(val, base + USB_SUSP_CTRL);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(phy->clk);\n\n\treturn err;\n}\n\nstatic int ulpi_phy_power_off(struct tegra_usb_phy *phy)\n{\n\tgpiod_set_value_cansleep(phy->reset_gpio, 1);\n\tusleep_range(5000, 6000);\n\tclk_disable_unprepare(phy->clk);\n\n\t \n\tif (WARN_ON_ONCE(phy->wakeup_enabled)) {\n\t\tulpi_phy_power_on(phy);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_usb_phy_power_on(struct tegra_usb_phy *phy)\n{\n\tint err;\n\n\tif (phy->powered_on)\n\t\treturn 0;\n\n\tif (phy->is_ulpi_phy)\n\t\terr = ulpi_phy_power_on(phy);\n\telse\n\t\terr = utmi_phy_power_on(phy);\n\tif (err)\n\t\treturn err;\n\n\tphy->powered_on = true;\n\n\t \n\tusleep_range(2000, 2500);\n\n\treturn 0;\n}\n\nstatic int tegra_usb_phy_power_off(struct tegra_usb_phy *phy)\n{\n\tint err;\n\n\tif (!phy->powered_on)\n\t\treturn 0;\n\n\tif (phy->is_ulpi_phy)\n\t\terr = ulpi_phy_power_off(phy);\n\telse\n\t\terr = utmi_phy_power_off(phy);\n\tif (err)\n\t\treturn err;\n\n\tphy->powered_on = false;\n\n\treturn 0;\n}\n\nstatic void tegra_usb_phy_shutdown(struct usb_phy *u_phy)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\n\tif (WARN_ON(!phy->freq))\n\t\treturn;\n\n\tusb_phy_set_wakeup(u_phy, false);\n\ttegra_usb_phy_power_off(phy);\n\n\tif (!phy->is_ulpi_phy)\n\t\tutmip_pad_close(phy);\n\n\tregulator_disable(phy->vbus);\n\tclk_disable_unprepare(phy->pll_u);\n\n\tphy->freq = NULL;\n}\n\nstatic irqreturn_t tegra_usb_phy_isr(int irq, void *data)\n{\n\tu32 val, int_mask = ID_CHG_DET | VBUS_WAKEUP_CHG_DET;\n\tstruct tegra_usb_phy *phy = data;\n\tvoid __iomem *base = phy->regs;\n\n\t \n\tval = readl_relaxed(base + USB_PHY_VBUS_WAKEUP_ID);\n\twritel_relaxed(val, base + USB_PHY_VBUS_WAKEUP_ID);\n\n\treturn val & int_mask ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic int tegra_usb_phy_set_wakeup(struct usb_phy *u_phy, bool enable)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\tvoid __iomem *base = phy->regs;\n\tint ret = 0;\n\tu32 val;\n\n\tif (phy->wakeup_enabled && phy->mode != USB_DR_MODE_HOST &&\n\t    phy->irq > 0) {\n\t\tdisable_irq(phy->irq);\n\n\t\tval = readl_relaxed(base + USB_PHY_VBUS_WAKEUP_ID);\n\t\tval &= ~(ID_INT_EN | VBUS_WAKEUP_INT_EN);\n\t\twritel_relaxed(val, base + USB_PHY_VBUS_WAKEUP_ID);\n\n\t\tenable_irq(phy->irq);\n\n\t\tfree_irq(phy->irq, phy);\n\n\t\tphy->wakeup_enabled = false;\n\t}\n\n\tif (enable && phy->mode != USB_DR_MODE_HOST && phy->irq > 0) {\n\t\tret = request_irq(phy->irq, tegra_usb_phy_isr, IRQF_SHARED,\n\t\t\t\t  dev_name(phy->u_phy.dev), phy);\n\t\tif (!ret) {\n\t\t\tdisable_irq(phy->irq);\n\n\t\t\t \n\t\t\tval = readl_relaxed(base + USB_PHY_VBUS_WAKEUP_ID);\n\t\t\tval |= ID_INT_EN | VBUS_WAKEUP_INT_EN;\n\t\t\twritel_relaxed(val, base + USB_PHY_VBUS_WAKEUP_ID);\n\n\t\t\tenable_irq(phy->irq);\n\t\t} else {\n\t\t\tdev_err(phy->u_phy.dev,\n\t\t\t\t\"Failed to request interrupt: %d\", ret);\n\t\t\tenable = false;\n\t\t}\n\t}\n\n\tphy->wakeup_enabled = enable;\n\n\treturn ret;\n}\n\nstatic int tegra_usb_phy_set_suspend(struct usb_phy *u_phy, int suspend)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\tint ret;\n\n\tif (WARN_ON(!phy->freq))\n\t\treturn -EINVAL;\n\n\t \n\tif (phy->irq > 0)\n\t\tdisable_irq(phy->irq);\n\n\tif (suspend)\n\t\tret = tegra_usb_phy_power_off(phy);\n\telse\n\t\tret = tegra_usb_phy_power_on(phy);\n\n\tif (phy->irq > 0)\n\t\tenable_irq(phy->irq);\n\n\treturn ret;\n}\n\nstatic int tegra_usb_phy_configure_pmc(struct tegra_usb_phy *phy)\n{\n\tint err, val = 0;\n\n\t \n\tif (!phy->pmc_regmap)\n\t\treturn 0;\n\n\t \n\tif (!phy->soc_config->requires_pmc_ao_power_up)\n\t\treturn 0;\n\n\t \n\tif (phy->mode != USB_DR_MODE_HOST)\n\t\tval |= VBUS_WAKEUP_PD_P0 << phy->instance * 4;\n\n\t \n\tif (phy->mode == USB_DR_MODE_OTG)\n\t\tval |= ID_PD_P0 << phy->instance * 4;\n\n\t \n\terr = regmap_set_bits(phy->pmc_regmap, PMC_USB_AO, val);\n\tif (err) {\n\t\tdev_err(phy->u_phy.dev, \"Failed to disable PMC AO: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tusleep_range(10, 100);\n\n\t \n\terr = regmap_clear_bits(phy->pmc_regmap, PMC_USB_AO, val);\n\tif (err) {\n\t\tdev_err(phy->u_phy.dev, \"Failed to enable PMC AO: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\tusleep_range(10000, 15000);\n\n\treturn 0;\n}\n\nstatic int tegra_usb_phy_init(struct usb_phy *u_phy)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\tunsigned long parent_rate;\n\tunsigned int i;\n\tint err;\n\n\tif (WARN_ON(phy->freq))\n\t\treturn 0;\n\n\terr = clk_prepare_enable(phy->pll_u);\n\tif (err)\n\t\treturn err;\n\n\tparent_rate = clk_get_rate(clk_get_parent(phy->pll_u));\n\tfor (i = 0; i < ARRAY_SIZE(tegra_freq_table); i++) {\n\t\tif (tegra_freq_table[i].freq == parent_rate) {\n\t\t\tphy->freq = &tegra_freq_table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!phy->freq) {\n\t\tdev_err(phy->u_phy.dev, \"Invalid pll_u parent rate %ld\\n\",\n\t\t\tparent_rate);\n\t\terr = -EINVAL;\n\t\tgoto disable_clk;\n\t}\n\n\terr = regulator_enable(phy->vbus);\n\tif (err) {\n\t\tdev_err(phy->u_phy.dev,\n\t\t\t\"Failed to enable USB VBUS regulator: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\tif (!phy->is_ulpi_phy) {\n\t\terr = utmip_pad_open(phy);\n\t\tif (err)\n\t\t\tgoto disable_vbus;\n\t}\n\n\terr = tegra_usb_phy_configure_pmc(phy);\n\tif (err)\n\t\tgoto close_phy;\n\n\terr = tegra_usb_phy_power_on(phy);\n\tif (err)\n\t\tgoto close_phy;\n\n\treturn 0;\n\nclose_phy:\n\tif (!phy->is_ulpi_phy)\n\t\tutmip_pad_close(phy);\n\ndisable_vbus:\n\tregulator_disable(phy->vbus);\n\ndisable_clk:\n\tclk_disable_unprepare(phy->pll_u);\n\n\tphy->freq = NULL;\n\n\treturn err;\n}\n\nvoid tegra_usb_phy_preresume(struct usb_phy *u_phy)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\n\tif (!phy->is_ulpi_phy)\n\t\tutmi_phy_preresume(phy);\n}\nEXPORT_SYMBOL_GPL(tegra_usb_phy_preresume);\n\nvoid tegra_usb_phy_postresume(struct usb_phy *u_phy)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\n\tif (!phy->is_ulpi_phy)\n\t\tutmi_phy_postresume(phy);\n}\nEXPORT_SYMBOL_GPL(tegra_usb_phy_postresume);\n\nvoid tegra_ehci_phy_restore_start(struct usb_phy *u_phy,\n\t\t\t\t  enum tegra_usb_phy_port_speed port_speed)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\n\tif (!phy->is_ulpi_phy)\n\t\tutmi_phy_restore_start(phy, port_speed);\n}\nEXPORT_SYMBOL_GPL(tegra_ehci_phy_restore_start);\n\nvoid tegra_ehci_phy_restore_end(struct usb_phy *u_phy)\n{\n\tstruct tegra_usb_phy *phy = to_tegra_usb_phy(u_phy);\n\n\tif (!phy->is_ulpi_phy)\n\t\tutmi_phy_restore_end(phy);\n}\nEXPORT_SYMBOL_GPL(tegra_ehci_phy_restore_end);\n\nstatic int read_utmi_param(struct platform_device *pdev, const char *param,\n\t\t\t   u8 *dest)\n{\n\tu32 value;\n\tint err;\n\n\terr = of_property_read_u32(pdev->dev.of_node, param, &value);\n\tif (err)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to read USB UTMI parameter %s: %d\\n\",\n\t\t\tparam, err);\n\telse\n\t\t*dest = value;\n\n\treturn err;\n}\n\nstatic int utmi_phy_probe(struct tegra_usb_phy *tegra_phy,\n\t\t\t  struct platform_device *pdev)\n{\n\tstruct tegra_utmip_config *config;\n\tstruct resource *res;\n\tint err;\n\n\ttegra_phy->is_ulpi_phy = false;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get UTMI pad regs\\n\");\n\t\treturn  -ENXIO;\n\t}\n\n\t \n\ttegra_phy->pad_regs = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t\t   resource_size(res));\n\tif (!tegra_phy->pad_regs) {\n\t\tdev_err(&pdev->dev, \"Failed to remap UTMI pad regs\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttegra_phy->config = devm_kzalloc(&pdev->dev, sizeof(*config),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!tegra_phy->config)\n\t\treturn -ENOMEM;\n\n\tconfig = tegra_phy->config;\n\n\terr = read_utmi_param(pdev, \"nvidia,hssync-start-delay\",\n\t\t\t      &config->hssync_start_delay);\n\tif (err)\n\t\treturn err;\n\n\terr = read_utmi_param(pdev, \"nvidia,elastic-limit\",\n\t\t\t      &config->elastic_limit);\n\tif (err)\n\t\treturn err;\n\n\terr = read_utmi_param(pdev, \"nvidia,idle-wait-delay\",\n\t\t\t      &config->idle_wait_delay);\n\tif (err)\n\t\treturn err;\n\n\terr = read_utmi_param(pdev, \"nvidia,term-range-adj\",\n\t\t\t      &config->term_range_adj);\n\tif (err)\n\t\treturn err;\n\n\terr = read_utmi_param(pdev, \"nvidia,xcvr-lsfslew\",\n\t\t\t      &config->xcvr_lsfslew);\n\tif (err)\n\t\treturn err;\n\n\terr = read_utmi_param(pdev, \"nvidia,xcvr-lsrslew\",\n\t\t\t      &config->xcvr_lsrslew);\n\tif (err)\n\t\treturn err;\n\n\tif (tegra_phy->soc_config->requires_extra_tuning_parameters) {\n\t\terr = read_utmi_param(pdev, \"nvidia,xcvr-hsslew\",\n\t\t\t\t      &config->xcvr_hsslew);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = read_utmi_param(pdev, \"nvidia,hssquelch-level\",\n\t\t\t\t      &config->hssquelch_level);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = read_utmi_param(pdev, \"nvidia,hsdiscon-level\",\n\t\t\t\t      &config->hsdiscon_level);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tconfig->xcvr_setup_use_fuses = of_property_read_bool(\n\t\tpdev->dev.of_node, \"nvidia,xcvr-setup-use-fuses\");\n\n\tif (!config->xcvr_setup_use_fuses) {\n\t\terr = read_utmi_param(pdev, \"nvidia,xcvr-setup\",\n\t\t\t\t      &config->xcvr_setup);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_usb_phy_put_pmc_device(void *dev)\n{\n\tput_device(dev);\n}\n\nstatic int tegra_usb_phy_parse_pmc(struct device *dev,\n\t\t\t\t   struct tegra_usb_phy *phy)\n{\n\tstruct platform_device *pmc_pdev;\n\tstruct of_phandle_args args;\n\tint err;\n\n\terr = of_parse_phandle_with_fixed_args(dev->of_node, \"nvidia,pmc\",\n\t\t\t\t\t       1, 0, &args);\n\tif (err) {\n\t\tif (err != -ENOENT)\n\t\t\treturn err;\n\n\t\tdev_warn_once(dev, \"nvidia,pmc is missing, please update your device-tree\\n\");\n\t\treturn 0;\n\t}\n\n\tpmc_pdev = of_find_device_by_node(args.np);\n\tof_node_put(args.np);\n\tif (!pmc_pdev)\n\t\treturn -ENODEV;\n\n\terr = devm_add_action_or_reset(dev, tegra_usb_phy_put_pmc_device,\n\t\t\t\t       &pmc_pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tif (!platform_get_drvdata(pmc_pdev))\n\t\treturn -EPROBE_DEFER;\n\n\tphy->pmc_regmap = dev_get_regmap(&pmc_pdev->dev, \"usb_sleepwalk\");\n\tif (!phy->pmc_regmap)\n\t\treturn -EINVAL;\n\n\tphy->instance = args.args[0];\n\n\treturn 0;\n}\n\nstatic const struct tegra_phy_soc_config tegra20_soc_config = {\n\t.utmi_pll_config_in_car_module = false,\n\t.has_hostpc = false,\n\t.requires_usbmode_setup = false,\n\t.requires_extra_tuning_parameters = false,\n\t.requires_pmc_ao_power_up = false,\n};\n\nstatic const struct tegra_phy_soc_config tegra30_soc_config = {\n\t.utmi_pll_config_in_car_module = true,\n\t.has_hostpc = true,\n\t.requires_usbmode_setup = true,\n\t.requires_extra_tuning_parameters = true,\n\t.requires_pmc_ao_power_up = true,\n};\n\nstatic const struct of_device_id tegra_usb_phy_id_table[] = {\n\t{ .compatible = \"nvidia,tegra30-usb-phy\", .data = &tegra30_soc_config },\n\t{ .compatible = \"nvidia,tegra20-usb-phy\", .data = &tegra20_soc_config },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_usb_phy_id_table);\n\nstatic int tegra_usb_phy_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct tegra_usb_phy *tegra_phy;\n\tenum usb_phy_interface phy_type;\n\tstruct reset_control *reset;\n\tstruct gpio_desc *gpiod;\n\tstruct resource *res;\n\tstruct usb_phy *phy;\n\tint err;\n\n\ttegra_phy = devm_kzalloc(&pdev->dev, sizeof(*tegra_phy), GFP_KERNEL);\n\tif (!tegra_phy)\n\t\treturn -ENOMEM;\n\n\ttegra_phy->soc_config = of_device_get_match_data(&pdev->dev);\n\ttegra_phy->irq = platform_get_irq_optional(pdev, 0);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get I/O memory\\n\");\n\t\treturn  -ENXIO;\n\t}\n\n\t \n\ttegra_phy->regs = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t       resource_size(res));\n\tif (!tegra_phy->regs) {\n\t\tdev_err(&pdev->dev, \"Failed to remap I/O memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttegra_phy->is_legacy_phy =\n\t\tof_property_read_bool(np, \"nvidia,has-legacy-mode\");\n\n\tif (of_property_present(np, \"dr_mode\"))\n\t\ttegra_phy->mode = usb_get_dr_mode(&pdev->dev);\n\telse\n\t\ttegra_phy->mode = USB_DR_MODE_HOST;\n\n\tif (tegra_phy->mode == USB_DR_MODE_UNKNOWN) {\n\t\tdev_err(&pdev->dev, \"dr_mode is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttegra_phy->vbus = devm_regulator_get(&pdev->dev, \"vbus\");\n\tif (IS_ERR(tegra_phy->vbus))\n\t\treturn PTR_ERR(tegra_phy->vbus);\n\n\ttegra_phy->pll_u = devm_clk_get(&pdev->dev, \"pll_u\");\n\terr = PTR_ERR_OR_ZERO(tegra_phy->pll_u);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to get pll_u clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = tegra_usb_phy_parse_pmc(&pdev->dev, tegra_phy);\n\tif (err) {\n\t\tdev_err_probe(&pdev->dev, err, \"Failed to get PMC regmap\\n\");\n\t\treturn err;\n\t}\n\n\tphy_type = of_usb_get_phy_mode(np);\n\tswitch (phy_type) {\n\tcase USBPHY_INTERFACE_MODE_UTMI:\n\t\terr = utmi_phy_probe(tegra_phy, pdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttegra_phy->pad_clk = devm_clk_get(&pdev->dev, \"utmi-pads\");\n\t\terr = PTR_ERR_OR_ZERO(tegra_phy->pad_clk);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to get UTMIP pad clock: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\treset = devm_reset_control_get_optional_shared(&pdev->dev,\n\t\t\t\t\t\t\t       \"utmi-pads\");\n\t\terr = PTR_ERR_OR_ZERO(reset);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to get UTMI-pads reset: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\ttegra_phy->pad_rst = reset;\n\t\tbreak;\n\n\tcase USBPHY_INTERFACE_MODE_ULPI:\n\t\ttegra_phy->is_ulpi_phy = true;\n\n\t\ttegra_phy->clk = devm_clk_get(&pdev->dev, \"ulpi-link\");\n\t\terr = PTR_ERR_OR_ZERO(tegra_phy->clk);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to get ULPI clock: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tgpiod = devm_gpiod_get(&pdev->dev, \"nvidia,phy-reset\",\n\t\t\t\t       GPIOD_OUT_HIGH);\n\t\terr = PTR_ERR_OR_ZERO(gpiod);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Request failed for reset GPIO: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = gpiod_set_consumer_name(gpiod, \"ulpi_phy_reset_b\");\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to set up reset GPIO name: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\ttegra_phy->reset_gpio = gpiod;\n\n\t\tphy = devm_otg_ulpi_create(&pdev->dev,\n\t\t\t\t\t   &ulpi_viewport_access_ops, 0);\n\t\tif (!phy) {\n\t\t\tdev_err(&pdev->dev, \"Failed to create ULPI OTG\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\ttegra_phy->ulpi = phy;\n\t\ttegra_phy->ulpi->io_priv = tegra_phy->regs + ULPI_VIEWPORT;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"phy_type %u is invalid or unsupported\\n\",\n\t\t\tphy_type);\n\t\treturn -EINVAL;\n\t}\n\n\ttegra_phy->u_phy.dev = &pdev->dev;\n\ttegra_phy->u_phy.init = tegra_usb_phy_init;\n\ttegra_phy->u_phy.shutdown = tegra_usb_phy_shutdown;\n\ttegra_phy->u_phy.set_wakeup = tegra_usb_phy_set_wakeup;\n\ttegra_phy->u_phy.set_suspend = tegra_usb_phy_set_suspend;\n\n\tplatform_set_drvdata(pdev, tegra_phy);\n\n\treturn usb_add_phy_dev(&tegra_phy->u_phy);\n}\n\nstatic void tegra_usb_phy_remove(struct platform_device *pdev)\n{\n\tstruct tegra_usb_phy *tegra_phy = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&tegra_phy->u_phy);\n}\n\nstatic struct platform_driver tegra_usb_phy_driver = {\n\t.probe\t\t= tegra_usb_phy_probe,\n\t.remove_new\t= tegra_usb_phy_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"tegra-phy\",\n\t\t.of_match_table = tegra_usb_phy_id_table,\n\t},\n};\nmodule_platform_driver(tegra_usb_phy_driver);\n\nMODULE_DESCRIPTION(\"Tegra USB PHY driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}