{
  "module_name": "phy-ulpi.c",
  "hash_id": "39379d099b22a565b9129dd967e925f6ede8be16ad7e2cca5c96ca586bff02c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-ulpi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/usb.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/ulpi.h>\n\n\nstruct ulpi_info {\n\tunsigned int\tid;\n\tchar\t\t*name;\n};\n\n#define ULPI_ID(vendor, product) (((vendor) << 16) | (product))\n#define ULPI_INFO(_id, _name)\t\t\\\n\t{\t\t\t\t\\\n\t\t.id\t= (_id),\t\\\n\t\t.name\t= (_name),\t\\\n\t}\n\n \nstatic struct ulpi_info ulpi_ids[] = {\n\tULPI_INFO(ULPI_ID(0x04cc, 0x1504), \"NXP ISP1504\"),\n\tULPI_INFO(ULPI_ID(0x0424, 0x0006), \"SMSC USB331x\"),\n\tULPI_INFO(ULPI_ID(0x0424, 0x0007), \"SMSC USB3320\"),\n\tULPI_INFO(ULPI_ID(0x0424, 0x0009), \"SMSC USB334x\"),\n\tULPI_INFO(ULPI_ID(0x0451, 0x1507), \"TI TUSB1210\"),\n};\n\nstatic int ulpi_set_otg_flags(struct usb_phy *phy)\n{\n\tunsigned int flags = ULPI_OTG_CTRL_DP_PULLDOWN |\n\t\t\t     ULPI_OTG_CTRL_DM_PULLDOWN;\n\n\tif (phy->flags & ULPI_OTG_ID_PULLUP)\n\t\tflags |= ULPI_OTG_CTRL_ID_PULLUP;\n\n\t \n\tif (phy->flags & ULPI_OTG_DP_PULLDOWN_DIS)\n\t\tflags &= ~ULPI_OTG_CTRL_DP_PULLDOWN;\n\n\tif (phy->flags & ULPI_OTG_DM_PULLDOWN_DIS)\n\t\tflags &= ~ULPI_OTG_CTRL_DM_PULLDOWN;\n\n\tif (phy->flags & ULPI_OTG_EXTVBUSIND)\n\t\tflags |= ULPI_OTG_CTRL_EXTVBUSIND;\n\n\treturn usb_phy_io_write(phy, flags, ULPI_OTG_CTRL);\n}\n\nstatic int ulpi_set_fc_flags(struct usb_phy *phy)\n{\n\tunsigned int flags = 0;\n\n\t \n\tif (phy->flags & ULPI_FC_HS)\n\t\tflags |= ULPI_FUNC_CTRL_HIGH_SPEED;\n\telse if (phy->flags & ULPI_FC_LS)\n\t\tflags |= ULPI_FUNC_CTRL_LOW_SPEED;\n\telse if (phy->flags & ULPI_FC_FS4LS)\n\t\tflags |= ULPI_FUNC_CTRL_FS4LS;\n\telse\n\t\tflags |= ULPI_FUNC_CTRL_FULL_SPEED;\n\n\tif (phy->flags & ULPI_FC_TERMSEL)\n\t\tflags |= ULPI_FUNC_CTRL_TERMSELECT;\n\n\t \n\tif (phy->flags & ULPI_FC_OP_NODRV)\n\t\tflags |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\n\telse if (phy->flags & ULPI_FC_OP_DIS_NRZI)\n\t\tflags |= ULPI_FUNC_CTRL_OPMODE_DISABLE_NRZI;\n\telse if (phy->flags & ULPI_FC_OP_NSYNC_NEOP)\n\t\tflags |= ULPI_FUNC_CTRL_OPMODE_NOSYNC_NOEOP;\n\telse\n\t\tflags |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\n\n\t \n\tflags |= ULPI_FUNC_CTRL_SUSPENDM;\n\n\treturn usb_phy_io_write(phy, flags, ULPI_FUNC_CTRL);\n}\n\nstatic int ulpi_set_ic_flags(struct usb_phy *phy)\n{\n\tunsigned int flags = 0;\n\n\tif (phy->flags & ULPI_IC_AUTORESUME)\n\t\tflags |= ULPI_IFC_CTRL_AUTORESUME;\n\n\tif (phy->flags & ULPI_IC_EXTVBUS_INDINV)\n\t\tflags |= ULPI_IFC_CTRL_EXTERNAL_VBUS;\n\n\tif (phy->flags & ULPI_IC_IND_PASSTHRU)\n\t\tflags |= ULPI_IFC_CTRL_PASSTHRU;\n\n\tif (phy->flags & ULPI_IC_PROTECT_DIS)\n\t\tflags |= ULPI_IFC_CTRL_PROTECT_IFC_DISABLE;\n\n\treturn usb_phy_io_write(phy, flags, ULPI_IFC_CTRL);\n}\n\nstatic int ulpi_set_flags(struct usb_phy *phy)\n{\n\tint ret;\n\n\tret = ulpi_set_otg_flags(phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ulpi_set_ic_flags(phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ulpi_set_fc_flags(phy);\n}\n\nstatic int ulpi_check_integrity(struct usb_phy *phy)\n{\n\tint ret, i;\n\tunsigned int val = 0x55;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tret = usb_phy_io_write(phy, val, ULPI_SCRATCH);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = usb_phy_io_read(phy, ULPI_SCRATCH);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (ret != val) {\n\t\t\tpr_err(\"ULPI integrity check: failed!\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tval = val << 1;\n\t}\n\n\tpr_info(\"ULPI integrity check: passed.\\n\");\n\n\treturn 0;\n}\n\nstatic int ulpi_init(struct usb_phy *phy)\n{\n\tint i, vid, pid, ret;\n\tu32 ulpi_id = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = usb_phy_io_read(phy, ULPI_PRODUCT_ID_HIGH - i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tulpi_id = (ulpi_id << 8) | ret;\n\t}\n\tvid = ulpi_id & 0xffff;\n\tpid = ulpi_id >> 16;\n\n\tpr_info(\"ULPI transceiver vendor/product ID 0x%04x/0x%04x\\n\", vid, pid);\n\n\tfor (i = 0; i < ARRAY_SIZE(ulpi_ids); i++) {\n\t\tif (ulpi_ids[i].id == ULPI_ID(vid, pid)) {\n\t\t\tpr_info(\"Found %s ULPI transceiver.\\n\",\n\t\t\t\tulpi_ids[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = ulpi_check_integrity(phy);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ulpi_set_flags(phy);\n}\n\nstatic int ulpi_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct usb_phy *phy = otg->usb_phy;\n\tunsigned int flags = usb_phy_io_read(phy, ULPI_IFC_CTRL);\n\n\tif (!host) {\n\t\totg->host = NULL;\n\t\treturn 0;\n\t}\n\n\totg->host = host;\n\n\tflags &= ~(ULPI_IFC_CTRL_6_PIN_SERIAL_MODE |\n\t\t   ULPI_IFC_CTRL_3_PIN_SERIAL_MODE |\n\t\t   ULPI_IFC_CTRL_CARKITMODE);\n\n\tif (phy->flags & ULPI_IC_6PIN_SERIAL)\n\t\tflags |= ULPI_IFC_CTRL_6_PIN_SERIAL_MODE;\n\telse if (phy->flags & ULPI_IC_3PIN_SERIAL)\n\t\tflags |= ULPI_IFC_CTRL_3_PIN_SERIAL_MODE;\n\telse if (phy->flags & ULPI_IC_CARKIT)\n\t\tflags |= ULPI_IFC_CTRL_CARKITMODE;\n\n\treturn usb_phy_io_write(phy, flags, ULPI_IFC_CTRL);\n}\n\nstatic int ulpi_set_vbus(struct usb_otg *otg, bool on)\n{\n\tstruct usb_phy *phy = otg->usb_phy;\n\tunsigned int flags = usb_phy_io_read(phy, ULPI_OTG_CTRL);\n\n\tflags &= ~(ULPI_OTG_CTRL_DRVVBUS | ULPI_OTG_CTRL_DRVVBUS_EXT);\n\n\tif (on) {\n\t\tif (phy->flags & ULPI_OTG_DRVVBUS)\n\t\t\tflags |= ULPI_OTG_CTRL_DRVVBUS;\n\n\t\tif (phy->flags & ULPI_OTG_DRVVBUS_EXT)\n\t\t\tflags |= ULPI_OTG_CTRL_DRVVBUS_EXT;\n\t}\n\n\treturn usb_phy_io_write(phy, flags, ULPI_OTG_CTRL);\n}\n\nstatic void otg_ulpi_init(struct usb_phy *phy, struct usb_otg *otg,\n\t\t\t  struct usb_phy_io_ops *ops,\n\t\t\t  unsigned int flags)\n{\n\tphy->label\t= \"ULPI\";\n\tphy->flags\t= flags;\n\tphy->io_ops\t= ops;\n\tphy->otg\t= otg;\n\tphy->init\t= ulpi_init;\n\n\totg->usb_phy\t= phy;\n\totg->set_host\t= ulpi_set_host;\n\totg->set_vbus\t= ulpi_set_vbus;\n}\n\nstruct usb_phy *\notg_ulpi_create(struct usb_phy_io_ops *ops,\n\t\tunsigned int flags)\n{\n\tstruct usb_phy *phy;\n\tstruct usb_otg *otg;\n\n\tphy = kzalloc(sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn NULL;\n\n\totg = kzalloc(sizeof(*otg), GFP_KERNEL);\n\tif (!otg) {\n\t\tkfree(phy);\n\t\treturn NULL;\n\t}\n\n\totg_ulpi_init(phy, otg, ops, flags);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(otg_ulpi_create);\n\nstruct usb_phy *\ndevm_otg_ulpi_create(struct device *dev,\n\t\t     struct usb_phy_io_ops *ops,\n\t\t     unsigned int flags)\n{\n\tstruct usb_phy *phy;\n\tstruct usb_otg *otg;\n\n\tphy = devm_kzalloc(dev, sizeof(*phy), GFP_KERNEL);\n\tif (!phy)\n\t\treturn NULL;\n\n\totg = devm_kzalloc(dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg) {\n\t\tdevm_kfree(dev, phy);\n\t\treturn NULL;\n\t}\n\n\totg_ulpi_init(phy, otg, ops, flags);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_otg_ulpi_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}