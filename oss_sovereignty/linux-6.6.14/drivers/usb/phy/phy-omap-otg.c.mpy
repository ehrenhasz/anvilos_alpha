{
  "module_name": "phy-omap-otg.c",
  "hash_id": "844b064df17359295811108439096500a7d8104e65eec22d08cc9e512a11853a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-omap-otg.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/err.h>\n#include <linux/extcon.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/usb-omap1.h>\n\nstruct otg_device {\n\tvoid __iomem\t\t\t*base;\n\tbool\t\t\t\tid;\n\tbool\t\t\t\tvbus;\n\tstruct extcon_dev\t\t*extcon;\n\tstruct notifier_block\t\tvbus_nb;\n\tstruct notifier_block\t\tid_nb;\n};\n\n#define OMAP_OTG_CTRL\t\t0x0c\n#define OMAP_OTG_ASESSVLD\t(1 << 20)\n#define OMAP_OTG_BSESSEND\t(1 << 19)\n#define OMAP_OTG_BSESSVLD\t(1 << 18)\n#define OMAP_OTG_VBUSVLD\t(1 << 17)\n#define OMAP_OTG_ID\t\t(1 << 16)\n#define OMAP_OTG_XCEIV_OUTPUTS \\\n\t(OMAP_OTG_ASESSVLD | OMAP_OTG_BSESSEND | OMAP_OTG_BSESSVLD | \\\n\t OMAP_OTG_VBUSVLD  | OMAP_OTG_ID)\n\nstatic void omap_otg_ctrl(struct otg_device *otg_dev, u32 outputs)\n{\n\tu32 l;\n\n\tl = readl(otg_dev->base + OMAP_OTG_CTRL);\n\tl &= ~OMAP_OTG_XCEIV_OUTPUTS;\n\tl |= outputs;\n\twritel(l, otg_dev->base + OMAP_OTG_CTRL);\n}\n\nstatic void omap_otg_set_mode(struct otg_device *otg_dev)\n{\n\tif (!otg_dev->id && otg_dev->vbus)\n\t\t \n\t\tomap_otg_ctrl(otg_dev, OMAP_OTG_ID | OMAP_OTG_BSESSVLD);\n\telse if (otg_dev->vbus)\n\t\t \n\t\tomap_otg_ctrl(otg_dev, OMAP_OTG_ASESSVLD);\n\telse if (!otg_dev->id)\n\t\t \n\t\tomap_otg_ctrl(otg_dev, OMAP_OTG_ID | OMAP_OTG_BSESSEND);\n}\n\nstatic int omap_otg_id_notifier(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct otg_device *otg_dev = container_of(nb, struct otg_device, id_nb);\n\n\totg_dev->id = event;\n\tomap_otg_set_mode(otg_dev);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int omap_otg_vbus_notifier(struct notifier_block *nb,\n\t\t\t\t  unsigned long event, void *ptr)\n{\n\tstruct otg_device *otg_dev = container_of(nb, struct otg_device,\n\t\t\t\t\t\t  vbus_nb);\n\n\totg_dev->vbus = event;\n\tomap_otg_set_mode(otg_dev);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int omap_otg_probe(struct platform_device *pdev)\n{\n\tconst struct omap_usb_config *config = pdev->dev.platform_data;\n\tstruct otg_device *otg_dev;\n\tstruct extcon_dev *extcon;\n\tint ret;\n\tu32 rev;\n\n\tif (!config || !config->extcon)\n\t\treturn -ENODEV;\n\n\textcon = extcon_get_extcon_dev(config->extcon);\n\tif (IS_ERR(extcon))\n\t\treturn PTR_ERR(extcon);\n\n\totg_dev = devm_kzalloc(&pdev->dev, sizeof(*otg_dev), GFP_KERNEL);\n\tif (!otg_dev)\n\t\treturn -ENOMEM;\n\n\totg_dev->base = devm_ioremap_resource(&pdev->dev, &pdev->resource[0]);\n\tif (IS_ERR(otg_dev->base))\n\t\treturn PTR_ERR(otg_dev->base);\n\n\totg_dev->extcon = extcon;\n\totg_dev->id_nb.notifier_call = omap_otg_id_notifier;\n\totg_dev->vbus_nb.notifier_call = omap_otg_vbus_notifier;\n\n\tret = devm_extcon_register_notifier(&pdev->dev, extcon,\n\t\t\t\t\tEXTCON_USB_HOST, &otg_dev->id_nb);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_extcon_register_notifier(&pdev->dev, extcon,\n\t\t\t\t\tEXTCON_USB, &otg_dev->vbus_nb);\n\tif (ret) {\n\t\treturn ret;\n\t}\n\n\totg_dev->id = extcon_get_state(extcon, EXTCON_USB_HOST);\n\totg_dev->vbus = extcon_get_state(extcon, EXTCON_USB);\n\tomap_otg_set_mode(otg_dev);\n\n\trev = readl(otg_dev->base);\n\n\tdev_info(&pdev->dev,\n\t\t \"OMAP USB OTG controller rev %d.%d (%s, id=%d, vbus=%d)\\n\",\n\t\t (rev >> 4) & 0xf, rev & 0xf, config->extcon, otg_dev->id,\n\t\t otg_dev->vbus);\n\n\tplatform_set_drvdata(pdev, otg_dev);\n\n\treturn 0;\n}\n\nstatic struct platform_driver omap_otg_driver = {\n\t.probe\t\t= omap_otg_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"omap_otg\",\n\t},\n};\nmodule_platform_driver(omap_otg_driver);\n\nMODULE_DESCRIPTION(\"OMAP USB OTG controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Aaro Koskinen <aaro.koskinen@iki.fi>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}