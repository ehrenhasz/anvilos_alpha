{
  "module_name": "phy.c",
  "hash_id": "549d578168823e6b30f17ff64bf47f40717ae27bf86295c960b639c290c679f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/usb/phy.h>\n\n \n#define DEFAULT_SDP_CUR_MIN\t2\n#define DEFAULT_SDP_CUR_MAX\t500\n#define DEFAULT_SDP_CUR_MIN_SS\t150\n#define DEFAULT_SDP_CUR_MAX_SS\t900\n#define DEFAULT_DCP_CUR_MIN\t500\n#define DEFAULT_DCP_CUR_MAX\t5000\n#define DEFAULT_CDP_CUR_MIN\t1500\n#define DEFAULT_CDP_CUR_MAX\t5000\n#define DEFAULT_ACA_CUR_MIN\t1500\n#define DEFAULT_ACA_CUR_MAX\t5000\n\nstatic LIST_HEAD(phy_list);\nstatic DEFINE_SPINLOCK(phy_lock);\n\nstruct phy_devm {\n\tstruct usb_phy *phy;\n\tstruct notifier_block *nb;\n};\n\nstatic const char *const usb_chger_type[] = {\n\t[UNKNOWN_TYPE]\t\t\t= \"USB_CHARGER_UNKNOWN_TYPE\",\n\t[SDP_TYPE]\t\t\t= \"USB_CHARGER_SDP_TYPE\",\n\t[CDP_TYPE]\t\t\t= \"USB_CHARGER_CDP_TYPE\",\n\t[DCP_TYPE]\t\t\t= \"USB_CHARGER_DCP_TYPE\",\n\t[ACA_TYPE]\t\t\t= \"USB_CHARGER_ACA_TYPE\",\n};\n\nstatic const char *const usb_chger_state[] = {\n\t[USB_CHARGER_DEFAULT]\t= \"USB_CHARGER_DEFAULT\",\n\t[USB_CHARGER_PRESENT]\t= \"USB_CHARGER_PRESENT\",\n\t[USB_CHARGER_ABSENT]\t= \"USB_CHARGER_ABSENT\",\n};\n\nstatic struct usb_phy *__usb_find_phy(struct list_head *list,\n\tenum usb_phy_type type)\n{\n\tstruct usb_phy  *phy = NULL;\n\n\tlist_for_each_entry(phy, list, head) {\n\t\tif (phy->type != type)\n\t\t\tcontinue;\n\n\t\treturn phy;\n\t}\n\n\treturn ERR_PTR(-ENODEV);\n}\n\nstatic struct usb_phy *__of_usb_find_phy(struct device_node *node)\n{\n\tstruct usb_phy  *phy;\n\n\tif (!of_device_is_available(node))\n\t\treturn ERR_PTR(-ENODEV);\n\n\tlist_for_each_entry(phy, &phy_list, head) {\n\t\tif (node != phy->dev->of_node)\n\t\t\tcontinue;\n\n\t\treturn phy;\n\t}\n\n\treturn ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic struct usb_phy *__device_to_usb_phy(const struct device *dev)\n{\n\tstruct usb_phy *usb_phy;\n\n\tlist_for_each_entry(usb_phy, &phy_list, head) {\n\t\tif (usb_phy->dev == dev)\n\t\t\treturn usb_phy;\n\t}\n\n\treturn NULL;\n}\n\nstatic void usb_phy_set_default_current(struct usb_phy *usb_phy)\n{\n\tusb_phy->chg_cur.sdp_min = DEFAULT_SDP_CUR_MIN;\n\tusb_phy->chg_cur.sdp_max = DEFAULT_SDP_CUR_MAX;\n\tusb_phy->chg_cur.dcp_min = DEFAULT_DCP_CUR_MIN;\n\tusb_phy->chg_cur.dcp_max = DEFAULT_DCP_CUR_MAX;\n\tusb_phy->chg_cur.cdp_min = DEFAULT_CDP_CUR_MIN;\n\tusb_phy->chg_cur.cdp_max = DEFAULT_CDP_CUR_MAX;\n\tusb_phy->chg_cur.aca_min = DEFAULT_ACA_CUR_MIN;\n\tusb_phy->chg_cur.aca_max = DEFAULT_ACA_CUR_MAX;\n}\n\n \nstatic void usb_phy_notify_charger_work(struct work_struct *work)\n{\n\tstruct usb_phy *usb_phy = container_of(work, struct usb_phy, chg_work);\n\tunsigned int min, max;\n\n\tswitch (usb_phy->chg_state) {\n\tcase USB_CHARGER_PRESENT:\n\t\tusb_phy_get_charger_current(usb_phy, &min, &max);\n\n\t\tatomic_notifier_call_chain(&usb_phy->notifier, max, usb_phy);\n\t\tbreak;\n\tcase USB_CHARGER_ABSENT:\n\t\tusb_phy_set_default_current(usb_phy);\n\n\t\tatomic_notifier_call_chain(&usb_phy->notifier, 0, usb_phy);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(usb_phy->dev, \"Unknown USB charger state: %d\\n\",\n\t\t\t usb_phy->chg_state);\n\t\treturn;\n\t}\n\n\tkobject_uevent(&usb_phy->dev->kobj, KOBJ_CHANGE);\n}\n\nstatic int usb_phy_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct usb_phy *usb_phy;\n\tchar uchger_state[50] = { 0 };\n\tchar uchger_type[50] = { 0 };\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\tusb_phy = __device_to_usb_phy(dev);\n\tspin_unlock_irqrestore(&phy_lock, flags);\n\n\tif (!usb_phy)\n\t\treturn -ENODEV;\n\n\tsnprintf(uchger_state, ARRAY_SIZE(uchger_state),\n\t\t \"USB_CHARGER_STATE=%s\", usb_chger_state[usb_phy->chg_state]);\n\n\tsnprintf(uchger_type, ARRAY_SIZE(uchger_type),\n\t\t \"USB_CHARGER_TYPE=%s\", usb_chger_type[usb_phy->chg_type]);\n\n\tif (add_uevent_var(env, uchger_state))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, uchger_type))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void __usb_phy_get_charger_type(struct usb_phy *usb_phy)\n{\n\tif (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_SDP) > 0) {\n\t\tusb_phy->chg_type = SDP_TYPE;\n\t\tusb_phy->chg_state = USB_CHARGER_PRESENT;\n\t} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_CDP) > 0) {\n\t\tusb_phy->chg_type = CDP_TYPE;\n\t\tusb_phy->chg_state = USB_CHARGER_PRESENT;\n\t} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_DCP) > 0) {\n\t\tusb_phy->chg_type = DCP_TYPE;\n\t\tusb_phy->chg_state = USB_CHARGER_PRESENT;\n\t} else if (extcon_get_state(usb_phy->edev, EXTCON_CHG_USB_ACA) > 0) {\n\t\tusb_phy->chg_type = ACA_TYPE;\n\t\tusb_phy->chg_state = USB_CHARGER_PRESENT;\n\t} else {\n\t\tusb_phy->chg_type = UNKNOWN_TYPE;\n\t\tusb_phy->chg_state = USB_CHARGER_ABSENT;\n\t}\n\n\tschedule_work(&usb_phy->chg_work);\n}\n\n \nstatic int usb_phy_get_charger_type(struct notifier_block *nb,\n\t\t\t\t    unsigned long state, void *data)\n{\n\tstruct usb_phy *usb_phy = container_of(nb, struct usb_phy, type_nb);\n\n\t__usb_phy_get_charger_type(usb_phy);\n\treturn NOTIFY_OK;\n}\n\n \nvoid usb_phy_set_charger_current(struct usb_phy *usb_phy, unsigned int mA)\n{\n\tswitch (usb_phy->chg_type) {\n\tcase SDP_TYPE:\n\t\tif (usb_phy->chg_cur.sdp_max == mA)\n\t\t\treturn;\n\n\t\tusb_phy->chg_cur.sdp_max = (mA > DEFAULT_SDP_CUR_MAX_SS) ?\n\t\t\tDEFAULT_SDP_CUR_MAX_SS : mA;\n\t\tbreak;\n\tcase DCP_TYPE:\n\t\tif (usb_phy->chg_cur.dcp_max == mA)\n\t\t\treturn;\n\n\t\tusb_phy->chg_cur.dcp_max = (mA > DEFAULT_DCP_CUR_MAX) ?\n\t\t\tDEFAULT_DCP_CUR_MAX : mA;\n\t\tbreak;\n\tcase CDP_TYPE:\n\t\tif (usb_phy->chg_cur.cdp_max == mA)\n\t\t\treturn;\n\n\t\tusb_phy->chg_cur.cdp_max = (mA > DEFAULT_CDP_CUR_MAX) ?\n\t\t\tDEFAULT_CDP_CUR_MAX : mA;\n\t\tbreak;\n\tcase ACA_TYPE:\n\t\tif (usb_phy->chg_cur.aca_max == mA)\n\t\t\treturn;\n\n\t\tusb_phy->chg_cur.aca_max = (mA > DEFAULT_ACA_CUR_MAX) ?\n\t\t\tDEFAULT_ACA_CUR_MAX : mA;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tschedule_work(&usb_phy->chg_work);\n}\nEXPORT_SYMBOL_GPL(usb_phy_set_charger_current);\n\n \nvoid usb_phy_get_charger_current(struct usb_phy *usb_phy,\n\t\t\t\t unsigned int *min, unsigned int *max)\n{\n\tswitch (usb_phy->chg_type) {\n\tcase SDP_TYPE:\n\t\t*min = usb_phy->chg_cur.sdp_min;\n\t\t*max = usb_phy->chg_cur.sdp_max;\n\t\tbreak;\n\tcase DCP_TYPE:\n\t\t*min = usb_phy->chg_cur.dcp_min;\n\t\t*max = usb_phy->chg_cur.dcp_max;\n\t\tbreak;\n\tcase CDP_TYPE:\n\t\t*min = usb_phy->chg_cur.cdp_min;\n\t\t*max = usb_phy->chg_cur.cdp_max;\n\t\tbreak;\n\tcase ACA_TYPE:\n\t\t*min = usb_phy->chg_cur.aca_min;\n\t\t*max = usb_phy->chg_cur.aca_max;\n\t\tbreak;\n\tdefault:\n\t\t*min = 0;\n\t\t*max = 0;\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_phy_get_charger_current);\n\n \nvoid usb_phy_set_charger_state(struct usb_phy *usb_phy,\n\t\t\t       enum usb_charger_state state)\n{\n\tif (usb_phy->chg_state == state || !usb_phy->charger_detect)\n\t\treturn;\n\n\tusb_phy->chg_state = state;\n\tif (usb_phy->chg_state == USB_CHARGER_PRESENT)\n\t\tusb_phy->chg_type = usb_phy->charger_detect(usb_phy);\n\telse\n\t\tusb_phy->chg_type = UNKNOWN_TYPE;\n\n\tschedule_work(&usb_phy->chg_work);\n}\nEXPORT_SYMBOL_GPL(usb_phy_set_charger_state);\n\nstatic void devm_usb_phy_release(struct device *dev, void *res)\n{\n\tstruct usb_phy *phy = *(struct usb_phy **)res;\n\n\tusb_put_phy(phy);\n}\n\nstatic void devm_usb_phy_release2(struct device *dev, void *_res)\n{\n\tstruct phy_devm *res = _res;\n\n\tif (res->nb)\n\t\tusb_unregister_notifier(res->phy, res->nb);\n\tusb_put_phy(res->phy);\n}\n\nstatic int devm_usb_phy_match(struct device *dev, void *res, void *match_data)\n{\n\tstruct usb_phy **phy = res;\n\n\treturn *phy == match_data;\n}\n\nstatic void usb_charger_init(struct usb_phy *usb_phy)\n{\n\tusb_phy->chg_type = UNKNOWN_TYPE;\n\tusb_phy->chg_state = USB_CHARGER_DEFAULT;\n\tusb_phy_set_default_current(usb_phy);\n\tINIT_WORK(&usb_phy->chg_work, usb_phy_notify_charger_work);\n}\n\nstatic int usb_add_extcon(struct usb_phy *x)\n{\n\tint ret;\n\n\tif (of_property_read_bool(x->dev->of_node, \"extcon\")) {\n\t\tx->edev = extcon_get_edev_by_phandle(x->dev, 0);\n\t\tif (IS_ERR(x->edev))\n\t\t\treturn PTR_ERR(x->edev);\n\n\t\tx->id_edev = extcon_get_edev_by_phandle(x->dev, 1);\n\t\tif (IS_ERR(x->id_edev)) {\n\t\t\tx->id_edev = NULL;\n\t\t\tdev_info(x->dev, \"No separate ID extcon device\\n\");\n\t\t}\n\n\t\tif (x->vbus_nb.notifier_call) {\n\t\t\tret = devm_extcon_register_notifier(x->dev, x->edev,\n\t\t\t\t\t\t\t    EXTCON_USB,\n\t\t\t\t\t\t\t    &x->vbus_nb);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register VBUS notifier failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tx->type_nb.notifier_call = usb_phy_get_charger_type;\n\n\t\t\tret = devm_extcon_register_notifier(x->dev, x->edev,\n\t\t\t\t\t\t\t    EXTCON_CHG_USB_SDP,\n\t\t\t\t\t\t\t    &x->type_nb);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register extcon USB SDP failed.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_extcon_register_notifier(x->dev, x->edev,\n\t\t\t\t\t\t\t    EXTCON_CHG_USB_CDP,\n\t\t\t\t\t\t\t    &x->type_nb);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register extcon USB CDP failed.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_extcon_register_notifier(x->dev, x->edev,\n\t\t\t\t\t\t\t    EXTCON_CHG_USB_DCP,\n\t\t\t\t\t\t\t    &x->type_nb);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register extcon USB DCP failed.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tret = devm_extcon_register_notifier(x->dev, x->edev,\n\t\t\t\t\t\t\t    EXTCON_CHG_USB_ACA,\n\t\t\t\t\t\t\t    &x->type_nb);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register extcon USB ACA failed.\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tif (x->id_nb.notifier_call) {\n\t\t\tstruct extcon_dev *id_ext;\n\n\t\t\tif (x->id_edev)\n\t\t\t\tid_ext = x->id_edev;\n\t\t\telse\n\t\t\t\tid_ext = x->edev;\n\n\t\t\tret = devm_extcon_register_notifier(x->dev, id_ext,\n\t\t\t\t\t\t\t    EXTCON_USB_HOST,\n\t\t\t\t\t\t\t    &x->id_nb);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(x->dev,\n\t\t\t\t\t\"register ID notifier failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (x->type_nb.notifier_call)\n\t\t__usb_phy_get_charger_type(x);\n\n\treturn 0;\n}\n\n \nstruct usb_phy *devm_usb_get_phy(struct device *dev, enum usb_phy_type type)\n{\n\tstruct usb_phy **ptr, *phy;\n\n\tptr = devres_alloc(devm_usb_phy_release, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tphy = usb_get_phy(type);\n\tif (!IS_ERR(phy)) {\n\t\t*ptr = phy;\n\t\tdevres_add(dev, ptr);\n\t} else\n\t\tdevres_free(ptr);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_usb_get_phy);\n\n \nstruct usb_phy *usb_get_phy(enum usb_phy_type type)\n{\n\tstruct usb_phy\t*phy = NULL;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\n\tphy = __usb_find_phy(&phy_list, type);\n\tif (IS_ERR(phy) || !try_module_get(phy->dev->driver->owner)) {\n\t\tpr_debug(\"PHY: unable to find transceiver of type %s\\n\",\n\t\t\tusb_phy_type_string(type));\n\t\tif (!IS_ERR(phy))\n\t\t\tphy = ERR_PTR(-ENODEV);\n\n\t\tgoto err0;\n\t}\n\n\tget_device(phy->dev);\n\nerr0:\n\tspin_unlock_irqrestore(&phy_lock, flags);\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(usb_get_phy);\n\n \nstruct  usb_phy *devm_usb_get_phy_by_node(struct device *dev,\n\t\t\t\t\t  struct device_node *node,\n\t\t\t\t\t  struct notifier_block *nb)\n{\n\tstruct usb_phy\t*phy = ERR_PTR(-ENOMEM);\n\tstruct phy_devm\t*ptr;\n\tunsigned long\tflags;\n\n\tptr = devres_alloc(devm_usb_phy_release2, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr) {\n\t\tdev_dbg(dev, \"failed to allocate memory for devres\\n\");\n\t\tgoto err0;\n\t}\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\n\tphy = __of_usb_find_phy(node);\n\tif (IS_ERR(phy)) {\n\t\tdevres_free(ptr);\n\t\tgoto err1;\n\t}\n\n\tif (!try_module_get(phy->dev->driver->owner)) {\n\t\tphy = ERR_PTR(-ENODEV);\n\t\tdevres_free(ptr);\n\t\tgoto err1;\n\t}\n\tif (nb)\n\t\tusb_register_notifier(phy, nb);\n\tptr->phy = phy;\n\tptr->nb = nb;\n\tdevres_add(dev, ptr);\n\n\tget_device(phy->dev);\n\nerr1:\n\tspin_unlock_irqrestore(&phy_lock, flags);\n\nerr0:\n\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_usb_get_phy_by_node);\n\n \nstruct usb_phy *devm_usb_get_phy_by_phandle(struct device *dev,\n\tconst char *phandle, u8 index)\n{\n\tstruct device_node *node;\n\tstruct usb_phy\t*phy;\n\n\tif (!dev->of_node) {\n\t\tdev_dbg(dev, \"device does not have a device node entry\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tnode = of_parse_phandle(dev->of_node, phandle, index);\n\tif (!node) {\n\t\tdev_dbg(dev, \"failed to get %s phandle in %pOF node\\n\", phandle,\n\t\t\tdev->of_node);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tphy = devm_usb_get_phy_by_node(dev, node, NULL);\n\tof_node_put(node);\n\treturn phy;\n}\nEXPORT_SYMBOL_GPL(devm_usb_get_phy_by_phandle);\n\n \nvoid devm_usb_put_phy(struct device *dev, struct usb_phy *phy)\n{\n\tint r;\n\n\tr = devres_destroy(dev, devm_usb_phy_release, devm_usb_phy_match, phy);\n\tdev_WARN_ONCE(dev, r, \"couldn't find PHY resource\\n\");\n}\nEXPORT_SYMBOL_GPL(devm_usb_put_phy);\n\n \nvoid usb_put_phy(struct usb_phy *x)\n{\n\tif (x) {\n\t\tstruct module *owner = x->dev->driver->owner;\n\n\t\tput_device(x->dev);\n\t\tmodule_put(owner);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_put_phy);\n\n \nint usb_add_phy(struct usb_phy *x, enum usb_phy_type type)\n{\n\tint\t\tret = 0;\n\tunsigned long\tflags;\n\tstruct usb_phy\t*phy;\n\n\tif (x->type != USB_PHY_TYPE_UNDEFINED) {\n\t\tdev_err(x->dev, \"not accepting initialized PHY %s\\n\", x->label);\n\t\treturn -EINVAL;\n\t}\n\n\tusb_charger_init(x);\n\tret = usb_add_extcon(x);\n\tif (ret)\n\t\treturn ret;\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&x->notifier);\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\n\tlist_for_each_entry(phy, &phy_list, head) {\n\t\tif (phy->type == type) {\n\t\t\tret = -EBUSY;\n\t\t\tdev_err(x->dev, \"transceiver type %s already exists\\n\",\n\t\t\t\t\t\tusb_phy_type_string(type));\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tx->type = type;\n\tlist_add_tail(&x->head, &phy_list);\n\nout:\n\tspin_unlock_irqrestore(&phy_lock, flags);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_add_phy);\n\nstatic struct device_type usb_phy_dev_type = {\n\t.name = \"usb_phy\",\n\t.uevent = usb_phy_uevent,\n};\n\n \nint usb_add_phy_dev(struct usb_phy *x)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (!x->dev) {\n\t\tdev_err(x->dev, \"no device provided for PHY\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tusb_charger_init(x);\n\tret = usb_add_extcon(x);\n\tif (ret)\n\t\treturn ret;\n\n\tx->dev->type = &usb_phy_dev_type;\n\n\tATOMIC_INIT_NOTIFIER_HEAD(&x->notifier);\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\tlist_add_tail(&x->head, &phy_list);\n\tspin_unlock_irqrestore(&phy_lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_add_phy_dev);\n\n \nvoid usb_remove_phy(struct usb_phy *x)\n{\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&phy_lock, flags);\n\tif (x)\n\t\tlist_del(&x->head);\n\tspin_unlock_irqrestore(&phy_lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_remove_phy);\n\n \nvoid usb_phy_set_event(struct usb_phy *x, unsigned long event)\n{\n\tx->last_event = event;\n}\nEXPORT_SYMBOL_GPL(usb_phy_set_event);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}