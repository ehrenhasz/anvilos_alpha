{
  "module_name": "phy-mxs-usb.c",
  "hash_id": "47bc940d1deba8b2c61727b3625632f564715c3a241fc063a4f6f8d8b4ab37c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-mxs-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/usb/otg.h>\n#include <linux/stmp_device.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/iopoll.h>\n\n#define DRIVER_NAME \"mxs_phy\"\n\n \n#define HW_USBPHY_PWD\t\t\t\t0x00\n#define HW_USBPHY_TX\t\t\t\t0x10\n#define HW_USBPHY_CTRL\t\t\t\t0x30\n#define HW_USBPHY_CTRL_SET\t\t\t0x34\n#define HW_USBPHY_CTRL_CLR\t\t\t0x38\n\n#define HW_USBPHY_DEBUG_SET\t\t\t0x54\n#define HW_USBPHY_DEBUG_CLR\t\t\t0x58\n\n#define HW_USBPHY_IP\t\t\t\t0x90\n#define HW_USBPHY_IP_SET\t\t\t0x94\n#define HW_USBPHY_IP_CLR\t\t\t0x98\n\n#define GM_USBPHY_TX_TXCAL45DP(x)            (((x) & 0xf) << 16)\n#define GM_USBPHY_TX_TXCAL45DN(x)            (((x) & 0xf) << 8)\n#define GM_USBPHY_TX_D_CAL(x)                (((x) & 0xf) << 0)\n\n \n#define HW_USBPHY_PLL_SIC\t\t\t0xa0\n#define HW_USBPHY_PLL_SIC_SET\t\t\t0xa4\n#define HW_USBPHY_PLL_SIC_CLR\t\t\t0xa8\n\n#define BM_USBPHY_CTRL_SFTRST\t\t\tBIT(31)\n#define BM_USBPHY_CTRL_CLKGATE\t\t\tBIT(30)\n#define BM_USBPHY_CTRL_OTG_ID_VALUE\t\tBIT(27)\n#define BM_USBPHY_CTRL_ENAUTOSET_USBCLKS\tBIT(26)\n#define BM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE\tBIT(25)\n#define BM_USBPHY_CTRL_ENVBUSCHG_WKUP\t\tBIT(23)\n#define BM_USBPHY_CTRL_ENIDCHG_WKUP\t\tBIT(22)\n#define BM_USBPHY_CTRL_ENDPDMCHG_WKUP\t\tBIT(21)\n#define BM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD\tBIT(20)\n#define BM_USBPHY_CTRL_ENAUTOCLR_CLKGATE\tBIT(19)\n#define BM_USBPHY_CTRL_ENAUTO_PWRON_PLL\t\tBIT(18)\n#define BM_USBPHY_CTRL_ENUTMILEVEL3\t\tBIT(15)\n#define BM_USBPHY_CTRL_ENUTMILEVEL2\t\tBIT(14)\n#define BM_USBPHY_CTRL_ENHOSTDISCONDETECT\tBIT(1)\n\n#define BM_USBPHY_IP_FIX                       (BIT(17) | BIT(18))\n\n#define BM_USBPHY_DEBUG_CLKGATE\t\t\tBIT(30)\n \n#define BM_USBPHY_PLL_LOCK\t\t\tBIT(31)\n#define BM_USBPHY_PLL_REG_ENABLE\t\tBIT(21)\n#define BM_USBPHY_PLL_BYPASS\t\t\tBIT(16)\n#define BM_USBPHY_PLL_POWER\t\t\tBIT(12)\n#define BM_USBPHY_PLL_EN_USB_CLKS\t\tBIT(6)\n\n \n#define ANADIG_ANA_MISC0\t\t\t0x150\n#define ANADIG_ANA_MISC0_SET\t\t\t0x154\n#define ANADIG_ANA_MISC0_CLR\t\t\t0x158\n\n#define ANADIG_USB1_CHRG_DETECT_SET\t\t0x1b4\n#define ANADIG_USB1_CHRG_DETECT_CLR\t\t0x1b8\n#define ANADIG_USB2_CHRG_DETECT_SET\t\t0x214\n#define ANADIG_USB1_CHRG_DETECT_EN_B\t\tBIT(20)\n#define ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B\tBIT(19)\n#define ANADIG_USB1_CHRG_DETECT_CHK_CONTACT\tBIT(18)\n\n#define ANADIG_USB1_VBUS_DET_STAT\t\t0x1c0\n#define ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID\tBIT(3)\n\n#define ANADIG_USB1_CHRG_DET_STAT\t\t0x1d0\n#define ANADIG_USB1_CHRG_DET_STAT_DM_STATE\tBIT(2)\n#define ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED\tBIT(1)\n#define ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT\tBIT(0)\n\n#define ANADIG_USB2_VBUS_DET_STAT\t\t0x220\n\n#define ANADIG_USB1_LOOPBACK_SET\t\t0x1e4\n#define ANADIG_USB1_LOOPBACK_CLR\t\t0x1e8\n#define ANADIG_USB1_LOOPBACK_UTMI_TESTSTART\tBIT(0)\n\n#define ANADIG_USB2_LOOPBACK_SET\t\t0x244\n#define ANADIG_USB2_LOOPBACK_CLR\t\t0x248\n\n#define ANADIG_USB1_MISC\t\t\t0x1f0\n#define ANADIG_USB2_MISC\t\t\t0x250\n\n#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG\tBIT(12)\n#define BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG_SL BIT(11)\n\n#define BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID\tBIT(3)\n#define BM_ANADIG_USB2_VBUS_DET_STAT_VBUS_VALID\tBIT(3)\n\n#define BM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST1\tBIT(2)\n#define BM_ANADIG_USB1_LOOPBACK_TSTI_TX_EN\tBIT(5)\n#define BM_ANADIG_USB2_LOOPBACK_UTMI_DIG_TST1\tBIT(2)\n#define BM_ANADIG_USB2_LOOPBACK_TSTI_TX_EN\tBIT(5)\n\n#define BM_ANADIG_USB1_MISC_RX_VPIN_FS\t\tBIT(29)\n#define BM_ANADIG_USB1_MISC_RX_VMIN_FS\t\tBIT(28)\n#define BM_ANADIG_USB2_MISC_RX_VPIN_FS\t\tBIT(29)\n#define BM_ANADIG_USB2_MISC_RX_VMIN_FS\t\tBIT(28)\n\n#define to_mxs_phy(p) container_of((p), struct mxs_phy, phy)\n\n \n#define MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS\tBIT(0)\n\n \n#define MXS_PHY_ABNORMAL_IN_SUSPEND\t\tBIT(1)\n\n \n#define MXS_PHY_SENDING_SOF_TOO_FAST\t\tBIT(2)\n\n \n#define MXS_PHY_NEED_IP_FIX\t\t\tBIT(3)\n\n \n#define MXS_PHY_TX_CAL45_MIN\t\t\t35\n#define MXS_PHY_TX_CAL45_MAX\t\t\t54\n#define MXS_PHY_TX_D_CAL_MIN\t\t\t79\n#define MXS_PHY_TX_D_CAL_MAX\t\t\t119\n\nstruct mxs_phy_data {\n\tunsigned int flags;\n};\n\nstatic const struct mxs_phy_data imx23_phy_data = {\n\t.flags = MXS_PHY_ABNORMAL_IN_SUSPEND | MXS_PHY_SENDING_SOF_TOO_FAST,\n};\n\nstatic const struct mxs_phy_data imx6q_phy_data = {\n\t.flags = MXS_PHY_SENDING_SOF_TOO_FAST |\n\t\tMXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS |\n\t\tMXS_PHY_NEED_IP_FIX,\n};\n\nstatic const struct mxs_phy_data imx6sl_phy_data = {\n\t.flags = MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS |\n\t\tMXS_PHY_NEED_IP_FIX,\n};\n\nstatic const struct mxs_phy_data vf610_phy_data = {\n\t.flags = MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS |\n\t\tMXS_PHY_NEED_IP_FIX,\n};\n\nstatic const struct mxs_phy_data imx6sx_phy_data = {\n\t.flags = MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS,\n};\n\nstatic const struct mxs_phy_data imx6ul_phy_data = {\n\t.flags = MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS,\n};\n\nstatic const struct mxs_phy_data imx7ulp_phy_data = {\n};\n\nstatic const struct of_device_id mxs_phy_dt_ids[] = {\n\t{ .compatible = \"fsl,imx6sx-usbphy\", .data = &imx6sx_phy_data, },\n\t{ .compatible = \"fsl,imx6sl-usbphy\", .data = &imx6sl_phy_data, },\n\t{ .compatible = \"fsl,imx6q-usbphy\", .data = &imx6q_phy_data, },\n\t{ .compatible = \"fsl,imx23-usbphy\", .data = &imx23_phy_data, },\n\t{ .compatible = \"fsl,vf610-usbphy\", .data = &vf610_phy_data, },\n\t{ .compatible = \"fsl,imx6ul-usbphy\", .data = &imx6ul_phy_data, },\n\t{ .compatible = \"fsl,imx7ulp-usbphy\", .data = &imx7ulp_phy_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_phy_dt_ids);\n\nstruct mxs_phy {\n\tstruct usb_phy phy;\n\tstruct clk *clk;\n\tconst struct mxs_phy_data *data;\n\tstruct regmap *regmap_anatop;\n\tint port_id;\n\tu32 tx_reg_set;\n\tu32 tx_reg_mask;\n};\n\nstatic inline bool is_imx6q_phy(struct mxs_phy *mxs_phy)\n{\n\treturn mxs_phy->data == &imx6q_phy_data;\n}\n\nstatic inline bool is_imx6sl_phy(struct mxs_phy *mxs_phy)\n{\n\treturn mxs_phy->data == &imx6sl_phy_data;\n}\n\nstatic inline bool is_imx7ulp_phy(struct mxs_phy *mxs_phy)\n{\n\treturn mxs_phy->data == &imx7ulp_phy_data;\n}\n\n \nstatic void mxs_phy_clock_switch_delay(void)\n{\n\tusleep_range(300, 400);\n}\n\nstatic void mxs_phy_tx_init(struct mxs_phy *mxs_phy)\n{\n\tvoid __iomem *base = mxs_phy->phy.io_priv;\n\tu32 phytx;\n\n\t \n\tif (mxs_phy->tx_reg_mask) {\n\t\tphytx = readl(base + HW_USBPHY_TX);\n\t\tphytx &= ~mxs_phy->tx_reg_mask;\n\t\tphytx |= mxs_phy->tx_reg_set;\n\t\twritel(phytx, base + HW_USBPHY_TX);\n\t}\n}\n\nstatic int mxs_phy_pll_enable(void __iomem *base, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tu32 value;\n\n\t\twritel(BM_USBPHY_PLL_REG_ENABLE, base + HW_USBPHY_PLL_SIC_SET);\n\t\twritel(BM_USBPHY_PLL_BYPASS, base + HW_USBPHY_PLL_SIC_CLR);\n\t\twritel(BM_USBPHY_PLL_POWER, base + HW_USBPHY_PLL_SIC_SET);\n\t\tret = readl_poll_timeout(base + HW_USBPHY_PLL_SIC,\n\t\t\tvalue, (value & BM_USBPHY_PLL_LOCK) != 0,\n\t\t\t100, 10000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\twritel(BM_USBPHY_PLL_EN_USB_CLKS, base +\n\t\t\t\tHW_USBPHY_PLL_SIC_SET);\n\t} else {\n\t\twritel(BM_USBPHY_PLL_EN_USB_CLKS, base +\n\t\t\t\tHW_USBPHY_PLL_SIC_CLR);\n\t\twritel(BM_USBPHY_PLL_POWER, base + HW_USBPHY_PLL_SIC_CLR);\n\t\twritel(BM_USBPHY_PLL_BYPASS, base + HW_USBPHY_PLL_SIC_SET);\n\t\twritel(BM_USBPHY_PLL_REG_ENABLE, base + HW_USBPHY_PLL_SIC_CLR);\n\t}\n\n\treturn ret;\n}\n\nstatic int mxs_phy_hw_init(struct mxs_phy *mxs_phy)\n{\n\tint ret;\n\tvoid __iomem *base = mxs_phy->phy.io_priv;\n\n\tif (is_imx7ulp_phy(mxs_phy)) {\n\t\tret = mxs_phy_pll_enable(base, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = stmp_reset_block(base + HW_USBPHY_CTRL);\n\tif (ret)\n\t\tgoto disable_pll;\n\n\t \n\twritel(0, base + HW_USBPHY_PWD);\n\n\t \n\twritel(BM_USBPHY_CTRL_ENAUTOSET_USBCLKS |\n\t\tBM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE |\n\t\tBM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD |\n\t\tBM_USBPHY_CTRL_ENAUTOCLR_CLKGATE |\n\t\tBM_USBPHY_CTRL_ENAUTO_PWRON_PLL |\n\t\tBM_USBPHY_CTRL_ENUTMILEVEL2 |\n\t\tBM_USBPHY_CTRL_ENUTMILEVEL3,\n\t       base + HW_USBPHY_CTRL_SET);\n\n\tif (mxs_phy->data->flags & MXS_PHY_NEED_IP_FIX)\n\t\twritel(BM_USBPHY_IP_FIX, base + HW_USBPHY_IP_SET);\n\n\tif (mxs_phy->regmap_anatop) {\n\t\tunsigned int reg = mxs_phy->port_id ?\n\t\t\tANADIG_USB1_CHRG_DETECT_SET :\n\t\t\tANADIG_USB2_CHRG_DETECT_SET;\n\t\t \n\t\tregmap_write(mxs_phy->regmap_anatop, reg,\n\t\t\t     ANADIG_USB1_CHRG_DETECT_EN_B |\n\t\t\t     ANADIG_USB1_CHRG_DETECT_CHK_CHRG_B);\n\t}\n\n\tmxs_phy_tx_init(mxs_phy);\n\n\treturn 0;\n\ndisable_pll:\n\tif (is_imx7ulp_phy(mxs_phy))\n\t\tmxs_phy_pll_enable(base, false);\n\treturn ret;\n}\n\n \nstatic bool mxs_phy_get_vbus_status(struct mxs_phy *mxs_phy)\n{\n\tunsigned int vbus_value = 0;\n\n\tif (!mxs_phy->regmap_anatop)\n\t\treturn false;\n\n\tif (mxs_phy->port_id == 0)\n\t\tregmap_read(mxs_phy->regmap_anatop,\n\t\t\tANADIG_USB1_VBUS_DET_STAT,\n\t\t\t&vbus_value);\n\telse if (mxs_phy->port_id == 1)\n\t\tregmap_read(mxs_phy->regmap_anatop,\n\t\t\tANADIG_USB2_VBUS_DET_STAT,\n\t\t\t&vbus_value);\n\n\tif (vbus_value & BM_ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void __mxs_phy_disconnect_line(struct mxs_phy *mxs_phy, bool disconnect)\n{\n\tvoid __iomem *base = mxs_phy->phy.io_priv;\n\tu32 reg;\n\n\tif (disconnect)\n\t\twritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\n\t\t\tbase + HW_USBPHY_DEBUG_CLR);\n\n\tif (mxs_phy->port_id == 0) {\n\t\treg = disconnect ? ANADIG_USB1_LOOPBACK_SET\n\t\t\t: ANADIG_USB1_LOOPBACK_CLR;\n\t\tregmap_write(mxs_phy->regmap_anatop, reg,\n\t\t\tBM_ANADIG_USB1_LOOPBACK_UTMI_DIG_TST1 |\n\t\t\tBM_ANADIG_USB1_LOOPBACK_TSTI_TX_EN);\n\t} else if (mxs_phy->port_id == 1) {\n\t\treg = disconnect ? ANADIG_USB2_LOOPBACK_SET\n\t\t\t: ANADIG_USB2_LOOPBACK_CLR;\n\t\tregmap_write(mxs_phy->regmap_anatop, reg,\n\t\t\tBM_ANADIG_USB2_LOOPBACK_UTMI_DIG_TST1 |\n\t\t\tBM_ANADIG_USB2_LOOPBACK_TSTI_TX_EN);\n\t}\n\n\tif (!disconnect)\n\t\twritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\n\t\t\tbase + HW_USBPHY_DEBUG_SET);\n\n\t \n\tif (disconnect)\n\t\tusleep_range(500, 1000);\n}\n\nstatic bool mxs_phy_is_otg_host(struct mxs_phy *mxs_phy)\n{\n\treturn mxs_phy->phy.last_event == USB_EVENT_ID;\n}\n\nstatic void mxs_phy_disconnect_line(struct mxs_phy *mxs_phy, bool on)\n{\n\tbool vbus_is_on = false;\n\tenum usb_phy_events last_event = mxs_phy->phy.last_event;\n\n\t \n\tif (!(mxs_phy->data->flags & MXS_PHY_DISCONNECT_LINE_WITHOUT_VBUS))\n\t\treturn;\n\n\t \n\tif (!mxs_phy->regmap_anatop)\n\t\treturn;\n\n\tvbus_is_on = mxs_phy_get_vbus_status(mxs_phy);\n\n\tif (on && ((!vbus_is_on && !mxs_phy_is_otg_host(mxs_phy))\n\t\t|| (last_event == USB_EVENT_VBUS)))\n\t\t__mxs_phy_disconnect_line(mxs_phy, true);\n\telse\n\t\t__mxs_phy_disconnect_line(mxs_phy, false);\n\n}\n\nstatic int mxs_phy_init(struct usb_phy *phy)\n{\n\tint ret;\n\tstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\n\n\tmxs_phy_clock_switch_delay();\n\tret = clk_prepare_enable(mxs_phy->clk);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mxs_phy_hw_init(mxs_phy);\n}\n\nstatic void mxs_phy_shutdown(struct usb_phy *phy)\n{\n\tstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\n\tu32 value = BM_USBPHY_CTRL_ENVBUSCHG_WKUP |\n\t\t\tBM_USBPHY_CTRL_ENDPDMCHG_WKUP |\n\t\t\tBM_USBPHY_CTRL_ENIDCHG_WKUP |\n\t\t\tBM_USBPHY_CTRL_ENAUTOSET_USBCLKS |\n\t\t\tBM_USBPHY_CTRL_ENAUTOCLR_USBCLKGATE |\n\t\t\tBM_USBPHY_CTRL_ENAUTOCLR_PHY_PWD |\n\t\t\tBM_USBPHY_CTRL_ENAUTOCLR_CLKGATE |\n\t\t\tBM_USBPHY_CTRL_ENAUTO_PWRON_PLL;\n\n\twritel(value, phy->io_priv + HW_USBPHY_CTRL_CLR);\n\twritel(0xffffffff, phy->io_priv + HW_USBPHY_PWD);\n\n\twritel(BM_USBPHY_CTRL_CLKGATE,\n\t       phy->io_priv + HW_USBPHY_CTRL_SET);\n\n\tif (is_imx7ulp_phy(mxs_phy))\n\t\tmxs_phy_pll_enable(phy->io_priv, false);\n\n\tclk_disable_unprepare(mxs_phy->clk);\n}\n\nstatic bool mxs_phy_is_low_speed_connection(struct mxs_phy *mxs_phy)\n{\n\tunsigned int line_state;\n\t \n\tunsigned int dp_bit = BM_ANADIG_USB1_MISC_RX_VPIN_FS,\n\t\t     dm_bit = BM_ANADIG_USB1_MISC_RX_VMIN_FS;\n\tunsigned int reg = ANADIG_USB1_MISC;\n\n\t \n\tif (!mxs_phy->regmap_anatop)\n\t\treturn false;\n\n\tif (mxs_phy->port_id == 0)\n\t\treg = ANADIG_USB1_MISC;\n\telse if (mxs_phy->port_id == 1)\n\t\treg = ANADIG_USB2_MISC;\n\n\tregmap_read(mxs_phy->regmap_anatop, reg, &line_state);\n\n\tif ((line_state & (dp_bit | dm_bit)) ==  dm_bit)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int mxs_phy_suspend(struct usb_phy *x, int suspend)\n{\n\tint ret;\n\tstruct mxs_phy *mxs_phy = to_mxs_phy(x);\n\tbool low_speed_connection, vbus_is_on;\n\n\tlow_speed_connection = mxs_phy_is_low_speed_connection(mxs_phy);\n\tvbus_is_on = mxs_phy_get_vbus_status(mxs_phy);\n\n\tif (suspend) {\n\t\t \n\t\tif (low_speed_connection & vbus_is_on) {\n\t\t\t \n\t\t\tmxs_phy_clock_switch_delay();\n\t\t\twritel(0xffbfffff, x->io_priv + HW_USBPHY_PWD);\n\t\t} else {\n\t\t\twritel(0xffffffff, x->io_priv + HW_USBPHY_PWD);\n\t\t}\n\t\twritel(BM_USBPHY_CTRL_CLKGATE,\n\t\t       x->io_priv + HW_USBPHY_CTRL_SET);\n\t\tclk_disable_unprepare(mxs_phy->clk);\n\t} else {\n\t\tmxs_phy_clock_switch_delay();\n\t\tret = clk_prepare_enable(mxs_phy->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\twritel(BM_USBPHY_CTRL_CLKGATE,\n\t\t       x->io_priv + HW_USBPHY_CTRL_CLR);\n\t\twritel(0, x->io_priv + HW_USBPHY_PWD);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxs_phy_set_wakeup(struct usb_phy *x, bool enabled)\n{\n\tstruct mxs_phy *mxs_phy = to_mxs_phy(x);\n\tu32 value = BM_USBPHY_CTRL_ENVBUSCHG_WKUP |\n\t\t\tBM_USBPHY_CTRL_ENDPDMCHG_WKUP |\n\t\t\t\tBM_USBPHY_CTRL_ENIDCHG_WKUP;\n\tif (enabled) {\n\t\tmxs_phy_disconnect_line(mxs_phy, true);\n\t\twritel_relaxed(value, x->io_priv + HW_USBPHY_CTRL_SET);\n\t} else {\n\t\twritel_relaxed(value, x->io_priv + HW_USBPHY_CTRL_CLR);\n\t\tmxs_phy_disconnect_line(mxs_phy, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxs_phy_on_connect(struct usb_phy *phy,\n\t\tenum usb_device_speed speed)\n{\n\tdev_dbg(phy->dev, \"%s device has connected\\n\",\n\t\t(speed == USB_SPEED_HIGH) ? \"HS\" : \"FS/LS\");\n\n\tif (speed == USB_SPEED_HIGH)\n\t\twritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\n\t\t       phy->io_priv + HW_USBPHY_CTRL_SET);\n\n\treturn 0;\n}\n\nstatic int mxs_phy_on_disconnect(struct usb_phy *phy,\n\t\tenum usb_device_speed speed)\n{\n\tdev_dbg(phy->dev, \"%s device has disconnected\\n\",\n\t\t(speed == USB_SPEED_HIGH) ? \"HS\" : \"FS/LS\");\n\n\t \n\tif (readl(phy->io_priv + HW_USBPHY_CTRL) &\n\t\t\tBM_USBPHY_CTRL_ENHOSTDISCONDETECT)\n\t\twritel(BM_USBPHY_CTRL_ENHOSTDISCONDETECT,\n\t\t       phy->io_priv + HW_USBPHY_CTRL_CLR);\n\n\treturn 0;\n}\n\n#define MXS_USB_CHARGER_DATA_CONTACT_TIMEOUT\t100\nstatic int mxs_charger_data_contact_detect(struct mxs_phy *x)\n{\n\tstruct regmap *regmap = x->regmap_anatop;\n\tint i, stable_contact_count = 0;\n\tu32 val;\n\n\t \n\tregmap_read(regmap, ANADIG_USB1_VBUS_DET_STAT, &val);\n\tif (!(val & ANADIG_USB1_VBUS_DET_STAT_VBUS_VALID)) {\n\t\tdev_err(x->phy.dev, \"vbus is not valid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tregmap_write(regmap, ANADIG_USB1_CHRG_DETECT_CLR,\n\t\t\t\tANADIG_USB1_CHRG_DETECT_EN_B);\n\t \n\tregmap_write(regmap, ANADIG_USB1_CHRG_DETECT_SET,\n\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CONTACT |\n\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CHRG_B);\n\n\t \n\tfor (i = 0; i < MXS_USB_CHARGER_DATA_CONTACT_TIMEOUT; i++) {\n\t\tregmap_read(regmap, ANADIG_USB1_CHRG_DET_STAT, &val);\n\t\tif (val & ANADIG_USB1_CHRG_DET_STAT_PLUG_CONTACT) {\n\t\t\tstable_contact_count++;\n\t\t\tif (stable_contact_count > 5)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tusleep_range(5000, 10000);\n\t\t} else {\n\t\t\tstable_contact_count = 0;\n\t\t\tusleep_range(5000, 6000);\n\t\t}\n\t}\n\n\tif (i == MXS_USB_CHARGER_DATA_CONTACT_TIMEOUT) {\n\t\tdev_err(x->phy.dev,\n\t\t\t\"Data pin can't make good contact.\\n\");\n\t\t \n\t\tregmap_write(regmap, ANADIG_USB1_CHRG_DETECT_SET,\n\t\t\t\tANADIG_USB1_CHRG_DETECT_EN_B |\n\t\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CHRG_B);\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic enum usb_charger_type mxs_charger_primary_detection(struct mxs_phy *x)\n{\n\tstruct regmap *regmap = x->regmap_anatop;\n\tenum usb_charger_type chgr_type = UNKNOWN_TYPE;\n\tu32 val;\n\n\t \n\tregmap_write(regmap, ANADIG_USB1_CHRG_DETECT_CLR,\n\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CONTACT |\n\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CHRG_B);\n\n\tmsleep(100);\n\n\t \n\tregmap_read(regmap, ANADIG_USB1_CHRG_DET_STAT, &val);\n\tif (!(val & ANADIG_USB1_CHRG_DET_STAT_CHRG_DETECTED)) {\n\t\tchgr_type = SDP_TYPE;\n\t\tdev_dbg(x->phy.dev, \"It is a standard downstream port\\n\");\n\t}\n\n\t \n\tregmap_write(regmap, ANADIG_USB1_CHRG_DETECT_SET,\n\t\t\tANADIG_USB1_CHRG_DETECT_EN_B |\n\t\t\tANADIG_USB1_CHRG_DETECT_CHK_CHRG_B);\n\n\treturn chgr_type;\n}\n\n \nstatic enum usb_charger_type mxs_charger_secondary_detection(struct mxs_phy *x)\n{\n\tstruct regmap *regmap = x->regmap_anatop;\n\tint val;\n\n\tmsleep(80);\n\n\tregmap_read(regmap, ANADIG_USB1_CHRG_DET_STAT, &val);\n\tif (val & ANADIG_USB1_CHRG_DET_STAT_DM_STATE) {\n\t\tdev_dbg(x->phy.dev, \"It is a dedicate charging port\\n\");\n\t\treturn DCP_TYPE;\n\t} else {\n\t\tdev_dbg(x->phy.dev, \"It is a charging downstream port\\n\");\n\t\treturn CDP_TYPE;\n\t}\n}\n\nstatic enum usb_charger_type mxs_phy_charger_detect(struct usb_phy *phy)\n{\n\tstruct mxs_phy *mxs_phy = to_mxs_phy(phy);\n\tstruct regmap *regmap = mxs_phy->regmap_anatop;\n\tvoid __iomem *base = phy->io_priv;\n\tenum usb_charger_type chgr_type = UNKNOWN_TYPE;\n\n\tif (!regmap)\n\t\treturn UNKNOWN_TYPE;\n\n\tif (mxs_charger_data_contact_detect(mxs_phy))\n\t\treturn chgr_type;\n\n\tchgr_type = mxs_charger_primary_detection(mxs_phy);\n\n\tif (chgr_type != SDP_TYPE) {\n\t\t \n\t\twritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\n\t\t\t\tbase + HW_USBPHY_DEBUG_CLR);\n\t\tregmap_write(regmap, ANADIG_USB1_LOOPBACK_SET,\n\t\t\t\tANADIG_USB1_LOOPBACK_UTMI_TESTSTART);\n\n\t\tchgr_type = mxs_charger_secondary_detection(mxs_phy);\n\n\t\t \n\t\tregmap_write(regmap, ANADIG_USB1_LOOPBACK_CLR,\n\t\t\t\tANADIG_USB1_LOOPBACK_UTMI_TESTSTART);\n\t\twritel_relaxed(BM_USBPHY_DEBUG_CLKGATE,\n\t\t\t\tbase + HW_USBPHY_DEBUG_SET);\n\t}\n\n\treturn chgr_type;\n}\n\nstatic int mxs_phy_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct mxs_phy *mxs_phy;\n\tint ret;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 val;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"can't get the clock, err=%ld\", PTR_ERR(clk));\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tmxs_phy = devm_kzalloc(&pdev->dev, sizeof(*mxs_phy), GFP_KERNEL);\n\tif (!mxs_phy)\n\t\treturn -ENOMEM;\n\n\t \n\tif (of_property_present(np, \"fsl,anatop\")) {\n\t\tmxs_phy->regmap_anatop = syscon_regmap_lookup_by_phandle\n\t\t\t(np, \"fsl,anatop\");\n\t\tif (IS_ERR(mxs_phy->regmap_anatop)) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"failed to find regmap for anatop\\n\");\n\t\t\treturn PTR_ERR(mxs_phy->regmap_anatop);\n\t\t}\n\t}\n\n\t \n\tif (!of_property_read_u32(np, \"fsl,tx-cal-45-dn-ohms\", &val) &&\n\t    val >= MXS_PHY_TX_CAL45_MIN && val <= MXS_PHY_TX_CAL45_MAX) {\n\t\t \n\t\tval = (MXS_PHY_TX_CAL45_MAX - val) * 0xF\n\t\t\t/ (MXS_PHY_TX_CAL45_MAX - MXS_PHY_TX_CAL45_MIN);\n\t\tmxs_phy->tx_reg_mask |= GM_USBPHY_TX_TXCAL45DN(~0);\n\t\tmxs_phy->tx_reg_set  |= GM_USBPHY_TX_TXCAL45DN(val);\n\t}\n\n\tif (!of_property_read_u32(np, \"fsl,tx-cal-45-dp-ohms\", &val) &&\n\t    val >= MXS_PHY_TX_CAL45_MIN && val <= MXS_PHY_TX_CAL45_MAX) {\n\t\t \n\t\tval = (MXS_PHY_TX_CAL45_MAX - val) * 0xF\n\t\t\t/ (MXS_PHY_TX_CAL45_MAX - MXS_PHY_TX_CAL45_MIN);\n\t\tmxs_phy->tx_reg_mask |= GM_USBPHY_TX_TXCAL45DP(~0);\n\t\tmxs_phy->tx_reg_set  |= GM_USBPHY_TX_TXCAL45DP(val);\n\t}\n\n\tif (!of_property_read_u32(np, \"fsl,tx-d-cal\", &val) &&\n\t    val >= MXS_PHY_TX_D_CAL_MIN && val <= MXS_PHY_TX_D_CAL_MAX) {\n\t\t \n\t\tval = ((MXS_PHY_TX_D_CAL_MAX - val) * 0xF\n\t\t\t+ (MXS_PHY_TX_D_CAL_MAX - MXS_PHY_TX_D_CAL_MIN) * 2/3)\n\t\t\t/ (MXS_PHY_TX_D_CAL_MAX - MXS_PHY_TX_D_CAL_MIN);\n\t\tmxs_phy->tx_reg_mask |= GM_USBPHY_TX_D_CAL(~0);\n\t\tmxs_phy->tx_reg_set  |= GM_USBPHY_TX_D_CAL(val);\n\t}\n\n\tret = of_alias_get_id(np, \"usbphy\");\n\tif (ret < 0)\n\t\tdev_dbg(&pdev->dev, \"failed to get alias id, errno %d\\n\", ret);\n\tmxs_phy->port_id = ret;\n\n\tmxs_phy->phy.io_priv\t\t= base;\n\tmxs_phy->phy.dev\t\t= &pdev->dev;\n\tmxs_phy->phy.label\t\t= DRIVER_NAME;\n\tmxs_phy->phy.init\t\t= mxs_phy_init;\n\tmxs_phy->phy.shutdown\t\t= mxs_phy_shutdown;\n\tmxs_phy->phy.set_suspend\t= mxs_phy_suspend;\n\tmxs_phy->phy.notify_connect\t= mxs_phy_on_connect;\n\tmxs_phy->phy.notify_disconnect\t= mxs_phy_on_disconnect;\n\tmxs_phy->phy.type\t\t= USB_PHY_TYPE_USB2;\n\tmxs_phy->phy.set_wakeup\t\t= mxs_phy_set_wakeup;\n\tmxs_phy->phy.charger_detect\t= mxs_phy_charger_detect;\n\n\tmxs_phy->clk = clk;\n\tmxs_phy->data = of_device_get_match_data(&pdev->dev);\n\n\tplatform_set_drvdata(pdev, mxs_phy);\n\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\treturn usb_add_phy_dev(&mxs_phy->phy);\n}\n\nstatic void mxs_phy_remove(struct platform_device *pdev)\n{\n\tstruct mxs_phy *mxs_phy = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&mxs_phy->phy);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void mxs_phy_enable_ldo_in_suspend(struct mxs_phy *mxs_phy, bool on)\n{\n\tunsigned int reg = on ? ANADIG_ANA_MISC0_SET : ANADIG_ANA_MISC0_CLR;\n\n\t \n\tif (!mxs_phy->regmap_anatop)\n\t\treturn;\n\n\tif (is_imx6q_phy(mxs_phy))\n\t\tregmap_write(mxs_phy->regmap_anatop, reg,\n\t\t\tBM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG);\n\telse if (is_imx6sl_phy(mxs_phy))\n\t\tregmap_write(mxs_phy->regmap_anatop,\n\t\t\treg, BM_ANADIG_ANA_MISC0_STOP_MODE_CONFIG_SL);\n}\n\nstatic int mxs_phy_system_suspend(struct device *dev)\n{\n\tstruct mxs_phy *mxs_phy = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tmxs_phy_enable_ldo_in_suspend(mxs_phy, true);\n\n\treturn 0;\n}\n\nstatic int mxs_phy_system_resume(struct device *dev)\n{\n\tstruct mxs_phy *mxs_phy = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tmxs_phy_enable_ldo_in_suspend(mxs_phy, false);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(mxs_phy_pm, mxs_phy_system_suspend,\n\t\tmxs_phy_system_resume);\n\nstatic struct platform_driver mxs_phy_driver = {\n\t.probe = mxs_phy_probe,\n\t.remove_new = mxs_phy_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = mxs_phy_dt_ids,\n\t\t.pm = &mxs_phy_pm,\n\t },\n};\n\nstatic int __init mxs_phy_module_init(void)\n{\n\treturn platform_driver_register(&mxs_phy_driver);\n}\npostcore_initcall(mxs_phy_module_init);\n\nstatic void __exit mxs_phy_module_exit(void)\n{\n\tplatform_driver_unregister(&mxs_phy_driver);\n}\nmodule_exit(mxs_phy_module_exit);\n\nMODULE_ALIAS(\"platform:mxs-usb-phy\");\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_AUTHOR(\"Richard Zhao <richard.zhao@freescale.com>\");\nMODULE_DESCRIPTION(\"Freescale MXS USB PHY driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}