{
  "module_name": "phy-am335x-control.c",
  "hash_id": "1024bb71d348b7dabf0d566414ba6034ed45f906d419f1f24952441b96d702f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-am335x-control.c",
  "human_readable_source": "\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/usb/otg.h>\n#include \"phy-am335x-control.h\"\n\nstruct am335x_control_usb {\n\tstruct device *dev;\n\tvoid __iomem *phy_reg;\n\tvoid __iomem *wkup;\n\tspinlock_t lock;\n\tstruct phy_control phy_ctrl;\n};\n\n#define AM335X_USB0_CTRL\t\t0x0\n#define AM335X_USB1_CTRL\t\t0x8\n#define AM335x_USB_WKUP\t\t\t0x0\n\n#define USBPHY_CM_PWRDN\t\t(1 << 0)\n#define USBPHY_OTG_PWRDN\t(1 << 1)\n#define USBPHY_OTGVDET_EN\t(1 << 19)\n#define USBPHY_OTGSESSEND_EN\t(1 << 20)\n\n#define AM335X_PHY0_WK_EN\t(1 << 0)\n#define AM335X_PHY1_WK_EN\t(1 << 8)\n\nstatic void am335x_phy_wkup(struct  phy_control *phy_ctrl, u32 id, bool on)\n{\n\tstruct am335x_control_usb *usb_ctrl;\n\tu32 val;\n\tu32 reg;\n\n\tusb_ctrl = container_of(phy_ctrl, struct am335x_control_usb, phy_ctrl);\n\n\tswitch (id) {\n\tcase 0:\n\t\treg = AM335X_PHY0_WK_EN;\n\t\tbreak;\n\tcase 1:\n\t\treg = AM335X_PHY1_WK_EN;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tspin_lock(&usb_ctrl->lock);\n\tval = readl(usb_ctrl->wkup);\n\n\tif (on)\n\t\tval |= reg;\n\telse\n\t\tval &= ~reg;\n\n\twritel(val, usb_ctrl->wkup);\n\tspin_unlock(&usb_ctrl->lock);\n}\n\nstatic void am335x_phy_power(struct phy_control *phy_ctrl, u32 id,\n\t\t\t\tenum usb_dr_mode dr_mode, bool on)\n{\n\tstruct am335x_control_usb *usb_ctrl;\n\tu32 val;\n\tu32 reg;\n\n\tusb_ctrl = container_of(phy_ctrl, struct am335x_control_usb, phy_ctrl);\n\n\tswitch (id) {\n\tcase 0:\n\t\treg = AM335X_USB0_CTRL;\n\t\tbreak;\n\tcase 1:\n\t\treg = AM335X_USB1_CTRL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tval = readl(usb_ctrl->phy_reg + reg);\n\tif (on) {\n\t\tif (dr_mode == USB_DR_MODE_HOST) {\n\t\t\tval &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN |\n\t\t\t\t\tUSBPHY_OTGVDET_EN);\n\t\t\tval |= USBPHY_OTGSESSEND_EN;\n\t\t} else {\n\t\t\tval &= ~(USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN);\n\t\t\tval |= USBPHY_OTGVDET_EN | USBPHY_OTGSESSEND_EN;\n\t\t}\n\t} else {\n\t\tval |= USBPHY_CM_PWRDN | USBPHY_OTG_PWRDN;\n\t}\n\n\twritel(val, usb_ctrl->phy_reg + reg);\n\n\t \n\tif (on)\n\t\tmdelay(1);\n}\n\nstatic const struct phy_control ctrl_am335x = {\n\t.phy_power = am335x_phy_power,\n\t.phy_wkup = am335x_phy_wkup,\n};\n\nstatic const struct of_device_id omap_control_usb_id_table[] = {\n\t{ .compatible = \"ti,am335x-usb-ctrl-module\", .data = &ctrl_am335x },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, omap_control_usb_id_table);\n\nstatic struct platform_driver am335x_control_driver;\nstatic int match(struct device *dev, const void *data)\n{\n\tconst struct device_node *node = (const struct device_node *)data;\n\treturn dev->of_node == node &&\n\t\tdev->driver == &am335x_control_driver.driver;\n}\n\nstruct phy_control *am335x_get_phy_control(struct device *dev)\n{\n\tstruct device_node *node;\n\tstruct am335x_control_usb *ctrl_usb;\n\n\tnode = of_parse_phandle(dev->of_node, \"ti,ctrl_mod\", 0);\n\tif (!node)\n\t\treturn NULL;\n\n\tdev = bus_find_device(&platform_bus_type, NULL, node, match);\n\tof_node_put(node);\n\tif (!dev)\n\t\treturn NULL;\n\n\tctrl_usb = dev_get_drvdata(dev);\n\tput_device(dev);\n\tif (!ctrl_usb)\n\t\treturn NULL;\n\treturn &ctrl_usb->phy_ctrl;\n}\nEXPORT_SYMBOL_GPL(am335x_get_phy_control);\n\nstatic int am335x_control_usb_probe(struct platform_device *pdev)\n{\n\tstruct am335x_control_usb *ctrl_usb;\n\tconst struct of_device_id *of_id;\n\tconst struct phy_control *phy_ctrl;\n\n\tof_id = of_match_node(omap_control_usb_id_table, pdev->dev.of_node);\n\tif (!of_id)\n\t\treturn -EINVAL;\n\n\tphy_ctrl = of_id->data;\n\n\tctrl_usb = devm_kzalloc(&pdev->dev, sizeof(*ctrl_usb), GFP_KERNEL);\n\tif (!ctrl_usb)\n\t\treturn -ENOMEM;\n\n\tctrl_usb->dev = &pdev->dev;\n\n\tctrl_usb->phy_reg = devm_platform_ioremap_resource_byname(pdev, \"phy_ctrl\");\n\tif (IS_ERR(ctrl_usb->phy_reg))\n\t\treturn PTR_ERR(ctrl_usb->phy_reg);\n\n\tctrl_usb->wkup = devm_platform_ioremap_resource_byname(pdev, \"wakeup\");\n\tif (IS_ERR(ctrl_usb->wkup))\n\t\treturn PTR_ERR(ctrl_usb->wkup);\n\n\tspin_lock_init(&ctrl_usb->lock);\n\tctrl_usb->phy_ctrl = *phy_ctrl;\n\n\tdev_set_drvdata(ctrl_usb->dev, ctrl_usb);\n\treturn 0;\n}\n\nstatic struct platform_driver am335x_control_driver = {\n\t.probe\t\t= am335x_control_usb_probe,\n\t.driver\t\t= {\n\t\t.name\t= \"am335x-control-usb\",\n\t\t.of_match_table = omap_control_usb_id_table,\n\t},\n};\n\nmodule_platform_driver(am335x_control_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}