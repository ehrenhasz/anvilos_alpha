{
  "module_name": "phy-twl6030-usb.c",
  "hash_id": "0f32114bc3b8ff1f57242b389579fb613a1d071be5611105d513c001ea9b99a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-twl6030-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/usb/musb.h>\n#include <linux/usb/phy_companion.h>\n#include <linux/phy/omap_usb.h>\n#include <linux/mfd/twl.h>\n#include <linux/regulator/consumer.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n\n \n#define USB_VENDOR_ID_LSB\t\t0x00\n#define USB_VENDOR_ID_MSB\t\t0x01\n#define USB_PRODUCT_ID_LSB\t\t0x02\n#define USB_PRODUCT_ID_MSB\t\t0x03\n#define USB_VBUS_CTRL_SET\t\t0x04\n#define USB_VBUS_CTRL_CLR\t\t0x05\n#define USB_ID_CTRL_SET\t\t\t0x06\n#define USB_ID_CTRL_CLR\t\t\t0x07\n#define USB_VBUS_INT_SRC\t\t0x08\n#define USB_VBUS_INT_LATCH_SET\t\t0x09\n#define USB_VBUS_INT_LATCH_CLR\t\t0x0A\n#define USB_VBUS_INT_EN_LO_SET\t\t0x0B\n#define USB_VBUS_INT_EN_LO_CLR\t\t0x0C\n#define USB_VBUS_INT_EN_HI_SET\t\t0x0D\n#define USB_VBUS_INT_EN_HI_CLR\t\t0x0E\n#define USB_ID_INT_SRC\t\t\t0x0F\n#define USB_ID_INT_LATCH_SET\t\t0x10\n#define USB_ID_INT_LATCH_CLR\t\t0x11\n\n#define USB_ID_INT_EN_LO_SET\t\t0x12\n#define USB_ID_INT_EN_LO_CLR\t\t0x13\n#define USB_ID_INT_EN_HI_SET\t\t0x14\n#define USB_ID_INT_EN_HI_CLR\t\t0x15\n#define USB_OTG_ADP_CTRL\t\t0x16\n#define USB_OTG_ADP_HIGH\t\t0x17\n#define USB_OTG_ADP_LOW\t\t\t0x18\n#define USB_OTG_ADP_RISE\t\t0x19\n#define USB_OTG_REVISION\t\t0x1A\n\n \n#define TWL6030_MISC2\t\t\t0xE5\n#define TWL6030_CFG_LDO_PD2\t\t0xF5\n#define TWL6030_BACKUP_REG\t\t0xFA\n\n#define STS_HW_CONDITIONS\t\t0x21\n\n \n#define STS_HW_CONDITIONS\t\t0x21\n#define STS_USB_ID\t\t\tBIT(2)\n\n \n#define VUSB_CFG_TRANS\t\t\t0x71\n#define VUSB_CFG_STATE\t\t\t0x72\n#define VUSB_CFG_VOLTAGE\t\t0x73\n\n \n\n#define CHARGERUSB_CTRL1\t\t0x8\n\n#define CONTROLLER_STAT1\t\t0x03\n#define\tVBUS_DET\t\t\tBIT(2)\n\nstruct twl6030_usb {\n\tstruct phy_companion\tcomparator;\n\tstruct device\t\t*dev;\n\n\t \n\tspinlock_t\t\tlock;\n\n\tstruct regulator\t\t*usb3v3;\n\n\t \n\tstruct delayed_work\tget_status_work;\n\n\t \n\tstruct work_struct\tset_vbus_work;\n\n\tint\t\t\tirq1;\n\tint\t\t\tirq2;\n\tenum musb_vbus_id_status linkstat;\n\tu8\t\t\tasleep;\n\tbool\t\t\tvbus_enable;\n};\n\n#define\tcomparator_to_twl(x) container_of((x), struct twl6030_usb, comparator)\n\n \n\nstatic inline int twl6030_writeb(struct twl6030_usb *twl, u8 module,\n\t\t\t\t\t\tu8 data, u8 address)\n{\n\tint ret = 0;\n\n\tret = twl_i2c_write_u8(module, data, address);\n\tif (ret < 0)\n\t\tdev_err(twl->dev,\n\t\t\t\"Write[0x%x] Error %d\\n\", address, ret);\n\treturn ret;\n}\n\nstatic inline u8 twl6030_readb(struct twl6030_usb *twl, u8 module, u8 address)\n{\n\tu8 data;\n\tint ret;\n\n\tret = twl_i2c_read_u8(module, &data, address);\n\tif (ret >= 0)\n\t\tret = data;\n\telse\n\t\tdev_err(twl->dev,\n\t\t\t\"readb[0x%x,0x%x] Error %d\\n\",\n\t\t\t\t\tmodule, address, ret);\n\treturn ret;\n}\n\nstatic int twl6030_start_srp(struct phy_companion *comparator)\n{\n\tstruct twl6030_usb *twl = comparator_to_twl(comparator);\n\n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x24, USB_VBUS_CTRL_SET);\n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x84, USB_VBUS_CTRL_SET);\n\n\tmdelay(100);\n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0xa0, USB_VBUS_CTRL_CLR);\n\n\treturn 0;\n}\n\nstatic int twl6030_usb_ldo_init(struct twl6030_usb *twl)\n{\n\t \n\ttwl6030_writeb(twl, TWL6030_MODULE_ID0, 0x1, TWL6030_BACKUP_REG);\n\n\t \n\ttwl6030_writeb(twl, TWL6030_MODULE_ID0, 0x1, TWL6030_CFG_LDO_PD2);\n\n\t \n\ttwl6030_writeb(twl, TWL6030_MODULE_ID0, 0x10, TWL6030_MISC2);\n\n\ttwl->usb3v3 = regulator_get(twl->dev, \"usb\");\n\tif (IS_ERR(twl->usb3v3))\n\t\treturn -ENODEV;\n\n\t \n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x4, USB_VBUS_CTRL_SET);\n\n\t \n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x14, USB_ID_CTRL_SET);\n\n\treturn 0;\n}\n\nstatic ssize_t vbus_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct twl6030_usb *twl = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&twl->lock, flags);\n\n\tswitch (twl->linkstat) {\n\tcase MUSB_VBUS_VALID:\n\t       ret = snprintf(buf, PAGE_SIZE, \"vbus\\n\");\n\t       break;\n\tcase MUSB_ID_GROUND:\n\t       ret = snprintf(buf, PAGE_SIZE, \"id\\n\");\n\t       break;\n\tcase MUSB_VBUS_OFF:\n\t       ret = snprintf(buf, PAGE_SIZE, \"none\\n\");\n\t       break;\n\tdefault:\n\t       ret = snprintf(buf, PAGE_SIZE, \"UNKNOWN\\n\");\n\t}\n\tspin_unlock_irqrestore(&twl->lock, flags);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(vbus);\n\nstatic struct attribute *twl6030_attrs[] = {\n\t&dev_attr_vbus.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(twl6030);\n\nstatic irqreturn_t twl6030_usb_irq(int irq, void *_twl)\n{\n\tstruct twl6030_usb *twl = _twl;\n\tenum musb_vbus_id_status status = MUSB_UNKNOWN;\n\tu8 vbus_state, hw_state;\n\tint ret;\n\n\thw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\n\n\tvbus_state = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,\n\t\t\t\t\t\tCONTROLLER_STAT1);\n\tif (!(hw_state & STS_USB_ID)) {\n\t\tif (vbus_state & VBUS_DET) {\n\t\t\tret = regulator_enable(twl->usb3v3);\n\t\t\tif (ret)\n\t\t\t\tdev_err(twl->dev, \"Failed to enable usb3v3\\n\");\n\n\t\t\ttwl->asleep = 1;\n\t\t\tstatus = MUSB_VBUS_VALID;\n\t\t\ttwl->linkstat = status;\n\t\t\tret = musb_mailbox(status);\n\t\t\tif (ret)\n\t\t\t\ttwl->linkstat = MUSB_UNKNOWN;\n\t\t} else {\n\t\t\tif (twl->linkstat != MUSB_UNKNOWN) {\n\t\t\t\tstatus = MUSB_VBUS_OFF;\n\t\t\t\ttwl->linkstat = status;\n\t\t\t\tret = musb_mailbox(status);\n\t\t\t\tif (ret)\n\t\t\t\t\ttwl->linkstat = MUSB_UNKNOWN;\n\t\t\t\tif (twl->asleep) {\n\t\t\t\t\tregulator_disable(twl->usb3v3);\n\t\t\t\t\ttwl->asleep = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tsysfs_notify(&twl->dev->kobj, NULL, \"vbus\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t twl6030_usbotg_irq(int irq, void *_twl)\n{\n\tstruct twl6030_usb *twl = _twl;\n\tenum musb_vbus_id_status status = MUSB_UNKNOWN;\n\tu8 hw_state;\n\tint ret;\n\n\thw_state = twl6030_readb(twl, TWL6030_MODULE_ID0, STS_HW_CONDITIONS);\n\n\tif (hw_state & STS_USB_ID) {\n\t\tret = regulator_enable(twl->usb3v3);\n\t\tif (ret)\n\t\t\tdev_err(twl->dev, \"Failed to enable usb3v3\\n\");\n\n\t\ttwl->asleep = 1;\n\t\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_CLR);\n\t\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_SET);\n\t\tstatus = MUSB_ID_GROUND;\n\t\ttwl->linkstat = status;\n\t\tret = musb_mailbox(status);\n\t\tif (ret)\n\t\t\ttwl->linkstat = MUSB_UNKNOWN;\n\t} else  {\n\t\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_CLR);\n\t\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);\n\t}\n\ttwl6030_writeb(twl, TWL_MODULE_USB, status, USB_ID_INT_LATCH_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void twl6030_status_work(struct work_struct *work)\n{\n\tstruct twl6030_usb *twl = container_of(work, struct twl6030_usb,\n\t\t\t\t\t       get_status_work.work);\n\n\ttwl6030_usb_irq(twl->irq2, twl);\n\ttwl6030_usbotg_irq(twl->irq1, twl);\n}\n\nstatic int twl6030_enable_irq(struct twl6030_usb *twl)\n{\n\ttwl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);\n\ttwl6030_interrupt_unmask(0x05, REG_INT_MSK_LINE_C);\n\ttwl6030_interrupt_unmask(0x05, REG_INT_MSK_STS_C);\n\n\ttwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\n\t\t\t\tREG_INT_MSK_LINE_C);\n\ttwl6030_interrupt_unmask(TWL6030_CHARGER_CTRL_INT_MASK,\n\t\t\t\tREG_INT_MSK_STS_C);\n\n\treturn 0;\n}\n\nstatic void otg_set_vbus_work(struct work_struct *data)\n{\n\tstruct twl6030_usb *twl = container_of(data, struct twl6030_usb,\n\t\t\t\t\t\t\t\tset_vbus_work);\n\n\t \n\n\tif (twl->vbus_enable)\n\t\ttwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE, 0x40,\n\t\t\t\t\t\t\tCHARGERUSB_CTRL1);\n\telse\n\t\ttwl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE, 0x00,\n\t\t\t\t\t\t\tCHARGERUSB_CTRL1);\n}\n\nstatic int twl6030_set_vbus(struct phy_companion *comparator, bool enabled)\n{\n\tstruct twl6030_usb *twl = comparator_to_twl(comparator);\n\n\ttwl->vbus_enable = enabled;\n\tschedule_work(&twl->set_vbus_work);\n\n\treturn 0;\n}\n\nstatic int twl6030_usb_probe(struct platform_device *pdev)\n{\n\tu32 ret;\n\tstruct twl6030_usb\t*twl;\n\tint\t\t\tstatus, err;\n\tstruct device_node\t*np = pdev->dev.of_node;\n\tstruct device\t\t*dev = &pdev->dev;\n\n\tif (!np) {\n\t\tdev_err(dev, \"no DT info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttwl = devm_kzalloc(dev, sizeof(*twl), GFP_KERNEL);\n\tif (!twl)\n\t\treturn -ENOMEM;\n\n\ttwl->dev\t\t= &pdev->dev;\n\ttwl->irq1\t\t= platform_get_irq(pdev, 0);\n\ttwl->irq2\t\t= platform_get_irq(pdev, 1);\n\ttwl->linkstat\t\t= MUSB_UNKNOWN;\n\n\tif (twl->irq1 < 0)\n\t\treturn twl->irq1;\n\tif (twl->irq2 < 0)\n\t\treturn twl->irq2;\n\n\ttwl->comparator.set_vbus\t= twl6030_set_vbus;\n\ttwl->comparator.start_srp\t= twl6030_start_srp;\n\n\tret = omap_usb2_set_comparator(&twl->comparator);\n\tif (ret == -ENODEV) {\n\t\tdev_info(&pdev->dev, \"phy not ready, deferring probe\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\t \n\tspin_lock_init(&twl->lock);\n\n\terr = twl6030_usb_ldo_init(twl);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"ldo init failed\\n\");\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, twl);\n\n\tINIT_WORK(&twl->set_vbus_work, otg_set_vbus_work);\n\tINIT_DELAYED_WORK(&twl->get_status_work, twl6030_status_work);\n\n\tstatus = request_threaded_irq(twl->irq1, NULL, twl6030_usbotg_irq,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\"twl6030_usb\", twl);\n\tif (status < 0) {\n\t\tdev_err(&pdev->dev, \"can't get IRQ %d, err %d\\n\",\n\t\t\ttwl->irq1, status);\n\t\tgoto err_put_regulator;\n\t}\n\n\tstatus = request_threaded_irq(twl->irq2, NULL, twl6030_usb_irq,\n\t\t\tIRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\"twl6030_usb\", twl);\n\tif (status < 0) {\n\t\tdev_err(&pdev->dev, \"can't get IRQ %d, err %d\\n\",\n\t\t\ttwl->irq2, status);\n\t\tgoto err_free_irq1;\n\t}\n\n\ttwl->asleep = 0;\n\ttwl6030_enable_irq(twl);\n\tschedule_delayed_work(&twl->get_status_work, HZ);\n\tdev_info(&pdev->dev, \"Initialized TWL6030 USB module\\n\");\n\n\treturn 0;\n\nerr_free_irq1:\n\tfree_irq(twl->irq1, twl);\nerr_put_regulator:\n\tregulator_put(twl->usb3v3);\n\n\treturn status;\n}\n\nstatic void twl6030_usb_remove(struct platform_device *pdev)\n{\n\tstruct twl6030_usb *twl = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&twl->get_status_work);\n\ttwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\n\t\tREG_INT_MSK_LINE_C);\n\ttwl6030_interrupt_mask(TWL6030_USBOTG_INT_MASK,\n\t\t\tREG_INT_MSK_STS_C);\n\tfree_irq(twl->irq1, twl);\n\tfree_irq(twl->irq2, twl);\n\tregulator_put(twl->usb3v3);\n\tcancel_work_sync(&twl->set_vbus_work);\n}\n\nstatic const struct of_device_id twl6030_usb_id_table[] = {\n\t{ .compatible = \"ti,twl6030-usb\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, twl6030_usb_id_table);\n\nstatic struct platform_driver twl6030_usb_driver = {\n\t.probe\t\t= twl6030_usb_probe,\n\t.remove_new\t= twl6030_usb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"twl6030_usb\",\n\t\t.of_match_table = of_match_ptr(twl6030_usb_id_table),\n\t\t.dev_groups = twl6030_groups,\n\t},\n};\n\nstatic int __init twl6030_usb_init(void)\n{\n\treturn platform_driver_register(&twl6030_usb_driver);\n}\nsubsys_initcall(twl6030_usb_init);\n\nstatic void __exit twl6030_usb_exit(void)\n{\n\tplatform_driver_unregister(&twl6030_usb_driver);\n}\nmodule_exit(twl6030_usb_exit);\n\nMODULE_ALIAS(\"platform:twl6030_usb\");\nMODULE_AUTHOR(\"Hema HK <hemahk@ti.com>\");\nMODULE_DESCRIPTION(\"TWL6030 USB transceiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}