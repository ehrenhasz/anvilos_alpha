{
  "module_name": "phy-tahvo.c",
  "hash_id": "5186110d6763b045d8da980613ea185c47791dd2423d017fd4e98e61012c70a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-tahvo.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/usb.h>\n#include <linux/extcon-provider.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb/otg.h>\n#include <linux/mfd/retu.h>\n#include <linux/usb/gadget.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_NAME     \"tahvo-usb\"\n\n#define TAHVO_REG_IDSR\t0x02\n#define TAHVO_REG_USBR\t0x06\n\n#define USBR_SLAVE_CONTROL\t(1 << 8)\n#define USBR_VPPVIO_SW\t\t(1 << 7)\n#define USBR_SPEED\t\t(1 << 6)\n#define USBR_REGOUT\t\t(1 << 5)\n#define USBR_MASTER_SW2\t\t(1 << 4)\n#define USBR_MASTER_SW1\t\t(1 << 3)\n#define USBR_SLAVE_SW\t\t(1 << 2)\n#define USBR_NSUSPEND\t\t(1 << 1)\n#define USBR_SEMODE\t\t(1 << 0)\n\n#define TAHVO_MODE_HOST\t\t0\n#define TAHVO_MODE_PERIPHERAL\t1\n\nstruct tahvo_usb {\n\tstruct platform_device\t*pt_dev;\n\tstruct usb_phy\t\tphy;\n\tint\t\t\tvbus_state;\n\tstruct mutex\t\tserialize;\n\tstruct clk\t\t*ick;\n\tint\t\t\tirq;\n\tint\t\t\ttahvo_mode;\n\tstruct extcon_dev\t*extcon;\n};\n\nstatic const unsigned int tahvo_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\n\tEXTCON_NONE,\n};\n\nstatic ssize_t vbus_show(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct tahvo_usb *tu = dev_get_drvdata(device);\n\treturn sprintf(buf, \"%s\\n\", tu->vbus_state ? \"on\" : \"off\");\n}\nstatic DEVICE_ATTR_RO(vbus);\n\nstatic void check_vbus_state(struct tahvo_usb *tu)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\n\tint reg, prev_state;\n\n\treg = retu_read(rdev, TAHVO_REG_IDSR);\n\tif (reg & TAHVO_STAT_VBUS) {\n\t\tswitch (tu->phy.otg->state) {\n\t\tcase OTG_STATE_B_IDLE:\n\t\t\t \n\t\t\tif (tu->phy.otg->gadget)\n\t\t\t\tusb_gadget_vbus_connect(tu->phy.otg->gadget);\n\t\t\ttu->phy.otg->state = OTG_STATE_B_PERIPHERAL;\n\t\t\tusb_phy_set_event(&tu->phy, USB_EVENT_ENUMERATED);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_IDLE:\n\t\t\t \n\t\t\ttu->phy.otg->state = OTG_STATE_A_HOST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tdev_info(&tu->pt_dev->dev, \"USB cable connected\\n\");\n\t} else {\n\t\tswitch (tu->phy.otg->state) {\n\t\tcase OTG_STATE_B_PERIPHERAL:\n\t\t\tif (tu->phy.otg->gadget)\n\t\t\t\tusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\n\t\t\ttu->phy.otg->state = OTG_STATE_B_IDLE;\n\t\t\tusb_phy_set_event(&tu->phy, USB_EVENT_NONE);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_HOST:\n\t\t\ttu->phy.otg->state = OTG_STATE_A_IDLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tdev_info(&tu->pt_dev->dev, \"USB cable disconnected\\n\");\n\t}\n\n\tprev_state = tu->vbus_state;\n\ttu->vbus_state = reg & TAHVO_STAT_VBUS;\n\tif (prev_state != tu->vbus_state) {\n\t\textcon_set_state_sync(tu->extcon, EXTCON_USB, tu->vbus_state);\n\t\tsysfs_notify(&tu->pt_dev->dev.kobj, NULL, \"vbus_state\");\n\t}\n}\n\nstatic void tahvo_usb_become_host(struct tahvo_usb *tu)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\n\n\textcon_set_state_sync(tu->extcon, EXTCON_USB_HOST, true);\n\n\t \n\tretu_write(rdev, TAHVO_REG_USBR, USBR_REGOUT | USBR_NSUSPEND |\n\t\t   USBR_MASTER_SW2 | USBR_MASTER_SW1);\n\ttu->phy.otg->state = OTG_STATE_A_IDLE;\n\n\tcheck_vbus_state(tu);\n}\n\nstatic void tahvo_usb_stop_host(struct tahvo_usb *tu)\n{\n\ttu->phy.otg->state = OTG_STATE_A_IDLE;\n}\n\nstatic void tahvo_usb_become_peripheral(struct tahvo_usb *tu)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\n\n\textcon_set_state_sync(tu->extcon, EXTCON_USB_HOST, false);\n\n\t \n\tretu_write(rdev, TAHVO_REG_USBR, USBR_SLAVE_CONTROL | USBR_REGOUT |\n\t\t   USBR_NSUSPEND | USBR_SLAVE_SW);\n\ttu->phy.otg->state = OTG_STATE_B_IDLE;\n\n\tcheck_vbus_state(tu);\n}\n\nstatic void tahvo_usb_stop_peripheral(struct tahvo_usb *tu)\n{\n\tif (tu->phy.otg->gadget)\n\t\tusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\n\ttu->phy.otg->state = OTG_STATE_B_IDLE;\n}\n\nstatic void tahvo_usb_power_off(struct tahvo_usb *tu)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\n\n\t \n\tif (tu->phy.otg->gadget)\n\t\tusb_gadget_vbus_disconnect(tu->phy.otg->gadget);\n\n\t \n\tretu_write(rdev, TAHVO_REG_USBR, 0);\n\ttu->phy.otg->state = OTG_STATE_UNDEFINED;\n}\n\nstatic int tahvo_usb_set_suspend(struct usb_phy *dev, int suspend)\n{\n\tstruct tahvo_usb *tu = container_of(dev, struct tahvo_usb, phy);\n\tstruct retu_dev *rdev = dev_get_drvdata(tu->pt_dev->dev.parent);\n\tu16 w;\n\n\tdev_dbg(&tu->pt_dev->dev, \"%s\\n\", __func__);\n\n\tw = retu_read(rdev, TAHVO_REG_USBR);\n\tif (suspend)\n\t\tw &= ~USBR_NSUSPEND;\n\telse\n\t\tw |= USBR_NSUSPEND;\n\tretu_write(rdev, TAHVO_REG_USBR, w);\n\n\treturn 0;\n}\n\nstatic int tahvo_usb_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct tahvo_usb *tu = container_of(otg->usb_phy, struct tahvo_usb,\n\t\t\t\t\t    phy);\n\n\tmutex_lock(&tu->serialize);\n\n\tif (host == NULL) {\n\t\tif (tu->tahvo_mode == TAHVO_MODE_HOST)\n\t\t\ttahvo_usb_power_off(tu);\n\t\totg->host = NULL;\n\t\tmutex_unlock(&tu->serialize);\n\t\treturn 0;\n\t}\n\n\tif (tu->tahvo_mode == TAHVO_MODE_HOST) {\n\t\totg->host = NULL;\n\t\ttahvo_usb_become_host(tu);\n\t}\n\n\totg->host = host;\n\n\tmutex_unlock(&tu->serialize);\n\n\treturn 0;\n}\n\nstatic int tahvo_usb_set_peripheral(struct usb_otg *otg,\n\t\t\t\t    struct usb_gadget *gadget)\n{\n\tstruct tahvo_usb *tu = container_of(otg->usb_phy, struct tahvo_usb,\n\t\t\t\t\t    phy);\n\n\tmutex_lock(&tu->serialize);\n\n\tif (!gadget) {\n\t\tif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\n\t\t\ttahvo_usb_power_off(tu);\n\t\ttu->phy.otg->gadget = NULL;\n\t\tmutex_unlock(&tu->serialize);\n\t\treturn 0;\n\t}\n\n\ttu->phy.otg->gadget = gadget;\n\tif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\n\t\ttahvo_usb_become_peripheral(tu);\n\n\tmutex_unlock(&tu->serialize);\n\n\treturn 0;\n}\n\nstatic irqreturn_t tahvo_usb_vbus_interrupt(int irq, void *_tu)\n{\n\tstruct tahvo_usb *tu = _tu;\n\n\tmutex_lock(&tu->serialize);\n\tcheck_vbus_state(tu);\n\tmutex_unlock(&tu->serialize);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic ssize_t otg_mode_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct tahvo_usb *tu = dev_get_drvdata(device);\n\n\tswitch (tu->tahvo_mode) {\n\tcase TAHVO_MODE_HOST:\n\t\treturn sprintf(buf, \"host\\n\");\n\tcase TAHVO_MODE_PERIPHERAL:\n\t\treturn sprintf(buf, \"peripheral\\n\");\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic ssize_t otg_mode_store(struct device *device,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct tahvo_usb *tu = dev_get_drvdata(device);\n\tint r;\n\n\tmutex_lock(&tu->serialize);\n\tif (count >= 4 && strncmp(buf, \"host\", 4) == 0) {\n\t\tif (tu->tahvo_mode == TAHVO_MODE_PERIPHERAL)\n\t\t\ttahvo_usb_stop_peripheral(tu);\n\t\ttu->tahvo_mode = TAHVO_MODE_HOST;\n\t\tif (tu->phy.otg->host) {\n\t\t\tdev_info(device, \"HOST mode: host controller present\\n\");\n\t\t\ttahvo_usb_become_host(tu);\n\t\t} else {\n\t\t\tdev_info(device, \"HOST mode: no host controller, powering off\\n\");\n\t\t\ttahvo_usb_power_off(tu);\n\t\t}\n\t\tr = strlen(buf);\n\t} else if (count >= 10 && strncmp(buf, \"peripheral\", 10) == 0) {\n\t\tif (tu->tahvo_mode == TAHVO_MODE_HOST)\n\t\t\ttahvo_usb_stop_host(tu);\n\t\ttu->tahvo_mode = TAHVO_MODE_PERIPHERAL;\n\t\tif (tu->phy.otg->gadget) {\n\t\t\tdev_info(device, \"PERIPHERAL mode: gadget driver present\\n\");\n\t\t\ttahvo_usb_become_peripheral(tu);\n\t\t} else {\n\t\t\tdev_info(device, \"PERIPHERAL mode: no gadget driver, powering off\\n\");\n\t\t\ttahvo_usb_power_off(tu);\n\t\t}\n\t\tr = strlen(buf);\n\t} else {\n\t\tr = -EINVAL;\n\t}\n\tmutex_unlock(&tu->serialize);\n\n\treturn r;\n}\nstatic DEVICE_ATTR_RW(otg_mode);\n\nstatic struct attribute *tahvo_attrs[] = {\n\t&dev_attr_vbus.attr,\n\t&dev_attr_otg_mode.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(tahvo);\n\nstatic int tahvo_usb_probe(struct platform_device *pdev)\n{\n\tstruct retu_dev *rdev = dev_get_drvdata(pdev->dev.parent);\n\tstruct tahvo_usb *tu;\n\tint ret;\n\n\ttu = devm_kzalloc(&pdev->dev, sizeof(*tu), GFP_KERNEL);\n\tif (!tu)\n\t\treturn -ENOMEM;\n\n\ttu->phy.otg = devm_kzalloc(&pdev->dev, sizeof(*tu->phy.otg),\n\t\t\t\t   GFP_KERNEL);\n\tif (!tu->phy.otg)\n\t\treturn -ENOMEM;\n\n\ttu->pt_dev = pdev;\n\n\t \n#ifdef CONFIG_TAHVO_USB_HOST_BY_DEFAULT\n\ttu->tahvo_mode = TAHVO_MODE_HOST;\n#else\n\ttu->tahvo_mode = TAHVO_MODE_PERIPHERAL;\n#endif\n\n\tmutex_init(&tu->serialize);\n\n\ttu->ick = devm_clk_get(&pdev->dev, \"usb_l4_ick\");\n\tif (!IS_ERR(tu->ick))\n\t\tclk_enable(tu->ick);\n\n\t \n\ttu->vbus_state = retu_read(rdev, TAHVO_REG_IDSR) & TAHVO_STAT_VBUS;\n\n\ttu->extcon = devm_extcon_dev_allocate(&pdev->dev, tahvo_cable);\n\tif (IS_ERR(tu->extcon)) {\n\t\tdev_err(&pdev->dev, \"failed to allocate memory for extcon\\n\");\n\t\tret = PTR_ERR(tu->extcon);\n\t\tgoto err_disable_clk;\n\t}\n\n\tret = devm_extcon_dev_register(&pdev->dev, tu->extcon);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register extcon device: %d\\n\",\n\t\t\tret);\n\t\tgoto err_disable_clk;\n\t}\n\n\t \n\textcon_set_state_sync(tu->extcon, EXTCON_USB_HOST,\n\t\t\t       tu->tahvo_mode == TAHVO_MODE_HOST);\n\textcon_set_state_sync(tu->extcon, EXTCON_USB, tu->vbus_state);\n\n\t \n\ttahvo_usb_power_off(tu);\n\ttu->phy.dev = &pdev->dev;\n\ttu->phy.otg->state = OTG_STATE_UNDEFINED;\n\ttu->phy.label = DRIVER_NAME;\n\ttu->phy.set_suspend = tahvo_usb_set_suspend;\n\n\ttu->phy.otg->usb_phy = &tu->phy;\n\ttu->phy.otg->set_host = tahvo_usb_set_host;\n\ttu->phy.otg->set_peripheral = tahvo_usb_set_peripheral;\n\n\tret = usb_add_phy(&tu->phy, USB_PHY_TYPE_USB2);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"cannot register USB transceiver: %d\\n\",\n\t\t\tret);\n\t\tgoto err_disable_clk;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, tu);\n\n\ttu->irq = ret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\tgoto err_remove_phy;\n\tret = request_threaded_irq(tu->irq, NULL, tahvo_usb_vbus_interrupt,\n\t\t\t\t   IRQF_ONESHOT,\n\t\t\t\t   \"tahvo-vbus\", tu);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not register tahvo-vbus irq: %d\\n\",\n\t\t\tret);\n\t\tgoto err_remove_phy;\n\t}\n\n\treturn 0;\n\nerr_remove_phy:\n\tusb_remove_phy(&tu->phy);\nerr_disable_clk:\n\tif (!IS_ERR(tu->ick))\n\t\tclk_disable(tu->ick);\n\n\treturn ret;\n}\n\nstatic void tahvo_usb_remove(struct platform_device *pdev)\n{\n\tstruct tahvo_usb *tu = platform_get_drvdata(pdev);\n\n\tfree_irq(tu->irq, tu);\n\tusb_remove_phy(&tu->phy);\n\tif (!IS_ERR(tu->ick))\n\t\tclk_disable(tu->ick);\n}\n\nstatic struct platform_driver tahvo_usb_driver = {\n\t.probe\t\t= tahvo_usb_probe,\n\t.remove_new\t= tahvo_usb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"tahvo-usb\",\n\t\t.dev_groups = tahvo_groups,\n\t},\n};\nmodule_platform_driver(tahvo_usb_driver);\n\nMODULE_DESCRIPTION(\"Tahvo USB transceiver driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Juha Yrj\u00f6l\u00e4, Tony Lindgren, and Timo Ter\u00e4s\");\nMODULE_AUTHOR(\"Aaro Koskinen <aaro.koskinen@iki.fi>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}