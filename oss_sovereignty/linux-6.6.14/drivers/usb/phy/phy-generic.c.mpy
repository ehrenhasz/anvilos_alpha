{
  "module_name": "phy-generic.c",
  "hash_id": "752e504da31e179b516264a93521e0758cada0c5fc942324768a4cfaffb098de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-generic.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/usb_phy_generic.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n\n#include \"phy-generic.h\"\n\n#define VBUS_IRQ_FLAGS \\\n\t(IRQF_SHARED | IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | \\\n\t\tIRQF_ONESHOT)\n\nstruct platform_device *usb_phy_generic_register(void)\n{\n\treturn platform_device_register_simple(\"usb_phy_generic\",\n\t\t\tPLATFORM_DEVID_AUTO, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(usb_phy_generic_register);\n\nvoid usb_phy_generic_unregister(struct platform_device *pdev)\n{\n\tplatform_device_unregister(pdev);\n}\nEXPORT_SYMBOL_GPL(usb_phy_generic_unregister);\n\nstatic int nop_set_suspend(struct usb_phy *x, int suspend)\n{\n\tstruct usb_phy_generic *nop = dev_get_drvdata(x->dev);\n\n\tif (!IS_ERR(nop->clk)) {\n\t\tif (suspend)\n\t\t\tclk_disable_unprepare(nop->clk);\n\t\telse\n\t\t\tclk_prepare_enable(nop->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic void nop_reset(struct usb_phy_generic *nop)\n{\n\tif (!nop->gpiod_reset)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(nop->gpiod_reset, 1);\n\tusleep_range(10000, 20000);\n\tgpiod_set_value_cansleep(nop->gpiod_reset, 0);\n}\n\n \nstatic void nop_set_vbus_draw(struct usb_phy_generic *nop, unsigned mA)\n{\n\tstruct regulator *vbus_draw = nop->vbus_draw;\n\tint enabled;\n\tint ret;\n\n\tif (!vbus_draw)\n\t\treturn;\n\n\tenabled = nop->vbus_draw_enabled;\n\tif (mA) {\n\t\tregulator_set_current_limit(vbus_draw, 0, 1000 * mA);\n\t\tif (!enabled) {\n\t\t\tret = regulator_enable(vbus_draw);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tnop->vbus_draw_enabled = 1;\n\t\t}\n\t} else {\n\t\tif (enabled) {\n\t\t\tret = regulator_disable(vbus_draw);\n\t\t\tif (ret < 0)\n\t\t\t\treturn;\n\t\t\tnop->vbus_draw_enabled = 0;\n\t\t}\n\t}\n\tnop->mA = mA;\n}\n\n\nstatic irqreturn_t nop_gpio_vbus_thread(int irq, void *data)\n{\n\tstruct usb_phy_generic *nop = data;\n\tstruct usb_otg *otg = nop->phy.otg;\n\tint vbus, status;\n\n\tvbus = gpiod_get_value(nop->gpiod_vbus);\n\tif ((vbus ^ nop->vbus) == 0)\n\t\treturn IRQ_HANDLED;\n\tnop->vbus = vbus;\n\n\tif (vbus) {\n\t\tstatus = USB_EVENT_VBUS;\n\t\totg->state = OTG_STATE_B_PERIPHERAL;\n\t\tnop->phy.last_event = status;\n\n\t\t \n\t\tnop_set_vbus_draw(nop, 100);\n\n\t\tatomic_notifier_call_chain(&nop->phy.notifier, status,\n\t\t\t\t\t   otg->gadget);\n\t} else {\n\t\tnop_set_vbus_draw(nop, 0);\n\n\t\tstatus = USB_EVENT_NONE;\n\t\totg->state = OTG_STATE_B_IDLE;\n\t\tnop->phy.last_event = status;\n\n\t\tatomic_notifier_call_chain(&nop->phy.notifier, status,\n\t\t\t\t\t   otg->gadget);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nint usb_gen_phy_init(struct usb_phy *phy)\n{\n\tstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\n\tint ret;\n\n\tif (!IS_ERR(nop->vcc)) {\n\t\tif (regulator_enable(nop->vcc))\n\t\t\tdev_err(phy->dev, \"Failed to enable power\\n\");\n\t}\n\n\tif (!IS_ERR(nop->clk)) {\n\t\tret = clk_prepare_enable(nop->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnop_reset(nop);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_gen_phy_init);\n\nvoid usb_gen_phy_shutdown(struct usb_phy *phy)\n{\n\tstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\n\n\tgpiod_set_value_cansleep(nop->gpiod_reset, 1);\n\n\tif (!IS_ERR(nop->clk))\n\t\tclk_disable_unprepare(nop->clk);\n\n\tif (!IS_ERR(nop->vcc)) {\n\t\tif (regulator_disable(nop->vcc))\n\t\t\tdev_err(phy->dev, \"Failed to disable power\\n\");\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_gen_phy_shutdown);\n\nstatic int nop_set_peripheral(struct usb_otg *otg, struct usb_gadget *gadget)\n{\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\tif (!gadget) {\n\t\totg->gadget = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\totg->gadget = gadget;\n\tif (otg->state == OTG_STATE_B_PERIPHERAL)\n\t\tatomic_notifier_call_chain(&otg->usb_phy->notifier,\n\t\t\t\t\t   USB_EVENT_VBUS, otg->gadget);\n\telse\n\t\totg->state = OTG_STATE_B_IDLE;\n\treturn 0;\n}\n\nstatic int nop_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\tif (!host) {\n\t\totg->host = NULL;\n\t\treturn -ENODEV;\n\t}\n\n\totg->host = host;\n\treturn 0;\n}\n\nint usb_phy_gen_create_phy(struct device *dev, struct usb_phy_generic *nop)\n{\n\tenum usb_phy_type type = USB_PHY_TYPE_USB2;\n\tint err = 0;\n\n\tu32 clk_rate = 0;\n\tbool needs_clk = false;\n\n\tif (dev->of_node) {\n\t\tstruct device_node *node = dev->of_node;\n\n\t\tif (of_property_read_u32(node, \"clock-frequency\", &clk_rate))\n\t\t\tclk_rate = 0;\n\n\t\tneeds_clk = of_property_read_bool(node, \"clocks\");\n\t}\n\tnop->gpiod_reset = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t   GPIOD_ASIS);\n\terr = PTR_ERR_OR_ZERO(nop->gpiod_reset);\n\tif (!err) {\n\t\tnop->gpiod_vbus = devm_gpiod_get_optional(dev,\n\t\t\t\t\t\t \"vbus-detect\",\n\t\t\t\t\t\t GPIOD_ASIS);\n\t\terr = PTR_ERR_OR_ZERO(nop->gpiod_vbus);\n\t}\n\n\tif (err)\n\t\treturn dev_err_probe(dev, err,\n\t\t\t\t     \"Error requesting RESET or VBUS GPIO\\n\");\n\tif (nop->gpiod_reset)\n\t\tgpiod_direction_output(nop->gpiod_reset, 1);\n\n\tnop->phy.otg = devm_kzalloc(dev, sizeof(*nop->phy.otg),\n\t\t\tGFP_KERNEL);\n\tif (!nop->phy.otg)\n\t\treturn -ENOMEM;\n\n\tnop->clk = devm_clk_get(dev, \"main_clk\");\n\tif (IS_ERR(nop->clk)) {\n\t\tdev_dbg(dev, \"Can't get phy clock: %ld\\n\",\n\t\t\t\t\tPTR_ERR(nop->clk));\n\t\tif (needs_clk)\n\t\t\treturn PTR_ERR(nop->clk);\n\t}\n\n\tif (!IS_ERR(nop->clk) && clk_rate) {\n\t\terr = clk_set_rate(nop->clk, clk_rate);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Error setting clock rate\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tnop->vcc = devm_regulator_get_optional(dev, \"vcc\");\n\tif (IS_ERR(nop->vcc) && PTR_ERR(nop->vcc) != -ENODEV)\n\t\treturn dev_err_probe(dev, PTR_ERR(nop->vcc),\n\t\t\t\t     \"could not get vcc regulator\\n\");\n\n\tnop->vbus_draw = devm_regulator_get_exclusive(dev, \"vbus\");\n\tif (PTR_ERR(nop->vbus_draw) == -ENODEV)\n\t\tnop->vbus_draw = NULL;\n\tif (IS_ERR(nop->vbus_draw))\n\t\treturn dev_err_probe(dev, PTR_ERR(nop->vbus_draw),\n\t\t\t\t     \"could not get vbus regulator\\n\");\n\n\tnop->dev\t\t= dev;\n\tnop->phy.dev\t\t= nop->dev;\n\tnop->phy.label\t\t= \"nop-xceiv\";\n\tnop->phy.set_suspend\t= nop_set_suspend;\n\tnop->phy.type\t\t= type;\n\n\tnop->phy.otg->state\t\t= OTG_STATE_UNDEFINED;\n\tnop->phy.otg->usb_phy\t\t= &nop->phy;\n\tnop->phy.otg->set_host\t\t= nop_set_host;\n\tnop->phy.otg->set_peripheral\t= nop_set_peripheral;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_phy_gen_create_phy);\n\nstatic int usb_phy_generic_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *dn = dev->of_node;\n\tstruct usb_phy_generic\t*nop;\n\tint err;\n\n\tnop = devm_kzalloc(dev, sizeof(*nop), GFP_KERNEL);\n\tif (!nop)\n\t\treturn -ENOMEM;\n\n\terr = usb_phy_gen_create_phy(dev, nop);\n\tif (err)\n\t\treturn err;\n\tif (nop->gpiod_vbus) {\n\t\terr = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\t\t\tgpiod_to_irq(nop->gpiod_vbus),\n\t\t\t\t\t\tNULL, nop_gpio_vbus_thread,\n\t\t\t\t\t\tVBUS_IRQ_FLAGS, \"vbus_detect\",\n\t\t\t\t\t\tnop);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"can't request irq %i, err: %d\\n\",\n\t\t\t\tgpiod_to_irq(nop->gpiod_vbus), err);\n\t\t\treturn err;\n\t\t}\n\t\tnop->phy.otg->state = gpiod_get_value(nop->gpiod_vbus) ?\n\t\t\tOTG_STATE_B_PERIPHERAL : OTG_STATE_B_IDLE;\n\t}\n\n\tnop->phy.init\t\t= usb_gen_phy_init;\n\tnop->phy.shutdown\t= usb_gen_phy_shutdown;\n\n\terr = usb_add_phy_dev(&nop->phy);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"can't register transceiver, err: %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tplatform_set_drvdata(pdev, nop);\n\n\tdevice_set_wakeup_capable(&pdev->dev,\n\t\t\t\t  of_property_read_bool(dn, \"wakeup-source\"));\n\n\treturn 0;\n}\n\nstatic void usb_phy_generic_remove(struct platform_device *pdev)\n{\n\tstruct usb_phy_generic *nop = platform_get_drvdata(pdev);\n\n\tusb_remove_phy(&nop->phy);\n}\n\nstatic const struct of_device_id nop_xceiv_dt_ids[] = {\n\t{ .compatible = \"usb-nop-xceiv\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, nop_xceiv_dt_ids);\n\nstatic struct platform_driver usb_phy_generic_driver = {\n\t.probe\t\t= usb_phy_generic_probe,\n\t.remove_new\t= usb_phy_generic_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"usb_phy_generic\",\n\t\t.of_match_table = nop_xceiv_dt_ids,\n\t},\n};\n\nstatic int __init usb_phy_generic_init(void)\n{\n\treturn platform_driver_register(&usb_phy_generic_driver);\n}\nsubsys_initcall(usb_phy_generic_init);\n\nstatic void __exit usb_phy_generic_exit(void)\n{\n\tplatform_driver_unregister(&usb_phy_generic_driver);\n}\nmodule_exit(usb_phy_generic_exit);\n\nMODULE_ALIAS(\"platform:usb_phy_generic\");\nMODULE_AUTHOR(\"Texas Instruments Inc\");\nMODULE_DESCRIPTION(\"NOP USB Transceiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}