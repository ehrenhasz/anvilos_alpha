{
  "module_name": "phy-ab8500-usb.c",
  "hash_id": "ff5e37984388e838474df1b1a905b694785e99b37918e89669a16b25f3c096c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/phy/phy-ab8500-usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/usb/otg.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/mfd/abx500.h>\n#include <linux/mfd/abx500/ab8500.h>\n#include <linux/usb/musb-ux500.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pinctrl/consumer.h>\n\n \n#define AB8500_MAIN_WD_CTRL_REG 0x01\n\n \n#define AB8500_USB_LINE_STAT_REG 0x80\n#define AB8505_USB_LINE_STAT_REG 0x94\n#define AB8500_USB_PHY_CTRL_REG 0x8A\n\n \n#define AB8500_BANK12_ACCESS 0x00\n\n \n#define AB8500_USB_PHY_TUNE1 0x05\n#define AB8500_USB_PHY_TUNE2 0x06\n#define AB8500_USB_PHY_TUNE3 0x07\n\n \n#define AB8500_IT_SOURCE2_REG 0x01\n\n#define AB8500_BIT_OTG_STAT_ID (1 << 0)\n#define AB8500_BIT_PHY_CTRL_HOST_EN (1 << 0)\n#define AB8500_BIT_PHY_CTRL_DEVICE_EN (1 << 1)\n#define AB8500_BIT_WD_CTRL_ENABLE (1 << 0)\n#define AB8500_BIT_WD_CTRL_KICK (1 << 1)\n#define AB8500_BIT_SOURCE2_VBUSDET (1 << 7)\n\n#define AB8500_WD_KICK_DELAY_US 100  \n#define AB8500_WD_V11_DISABLE_DELAY_US 100  \n#define AB8500_V20_31952_DISABLE_DELAY_US 100  \n\n \nenum ab8500_usb_link_status {\n\tUSB_LINK_NOT_CONFIGURED_8500 = 0,\n\tUSB_LINK_STD_HOST_NC_8500,\n\tUSB_LINK_STD_HOST_C_NS_8500,\n\tUSB_LINK_STD_HOST_C_S_8500,\n\tUSB_LINK_HOST_CHG_NM_8500,\n\tUSB_LINK_HOST_CHG_HS_8500,\n\tUSB_LINK_HOST_CHG_HS_CHIRP_8500,\n\tUSB_LINK_DEDICATED_CHG_8500,\n\tUSB_LINK_ACA_RID_A_8500,\n\tUSB_LINK_ACA_RID_B_8500,\n\tUSB_LINK_ACA_RID_C_NM_8500,\n\tUSB_LINK_ACA_RID_C_HS_8500,\n\tUSB_LINK_ACA_RID_C_HS_CHIRP_8500,\n\tUSB_LINK_HM_IDGND_8500,\n\tUSB_LINK_RESERVED_8500,\n\tUSB_LINK_NOT_VALID_LINK_8500,\n};\n\nenum ab8505_usb_link_status {\n\tUSB_LINK_NOT_CONFIGURED_8505 = 0,\n\tUSB_LINK_STD_HOST_NC_8505,\n\tUSB_LINK_STD_HOST_C_NS_8505,\n\tUSB_LINK_STD_HOST_C_S_8505,\n\tUSB_LINK_CDP_8505,\n\tUSB_LINK_RESERVED0_8505,\n\tUSB_LINK_RESERVED1_8505,\n\tUSB_LINK_DEDICATED_CHG_8505,\n\tUSB_LINK_ACA_RID_A_8505,\n\tUSB_LINK_ACA_RID_B_8505,\n\tUSB_LINK_ACA_RID_C_NM_8505,\n\tUSB_LINK_RESERVED2_8505,\n\tUSB_LINK_RESERVED3_8505,\n\tUSB_LINK_HM_IDGND_8505,\n\tUSB_LINK_CHARGERPORT_NOT_OK_8505,\n\tUSB_LINK_CHARGER_DM_HIGH_8505,\n\tUSB_LINK_PHYEN_NO_VBUS_NO_IDGND_8505,\n\tUSB_LINK_STD_UPSTREAM_NO_IDGNG_NO_VBUS_8505,\n\tUSB_LINK_STD_UPSTREAM_8505,\n\tUSB_LINK_CHARGER_SE1_8505,\n\tUSB_LINK_CARKIT_CHGR_1_8505,\n\tUSB_LINK_CARKIT_CHGR_2_8505,\n\tUSB_LINK_ACA_DOCK_CHGR_8505,\n\tUSB_LINK_SAMSUNG_BOOT_CBL_PHY_EN_8505,\n\tUSB_LINK_SAMSUNG_BOOT_CBL_PHY_DISB_8505,\n\tUSB_LINK_SAMSUNG_UART_CBL_PHY_EN_8505,\n\tUSB_LINK_SAMSUNG_UART_CBL_PHY_DISB_8505,\n\tUSB_LINK_MOTOROLA_FACTORY_CBL_PHY_EN_8505,\n};\n\nenum ab8500_usb_mode {\n\tUSB_IDLE = 0,\n\tUSB_PERIPHERAL,\n\tUSB_HOST,\n\tUSB_DEDICATED_CHG,\n\tUSB_UART\n};\n\n \n#define AB8500_USB_FLAG_USE_LINK_STATUS_IRQ\t(1 << 0)\n \n#define AB8500_USB_FLAG_USE_ID_WAKEUP_IRQ\t(1 << 1)\n \n#define AB8500_USB_FLAG_USE_VBUS_DET_IRQ\t(1 << 2)\n \n#define AB8500_USB_FLAG_USE_AB_IDDET\t\t(1 << 3)\n \n#define AB8500_USB_FLAG_REGULATOR_SET_VOLTAGE\t(1 << 4)\n\nstruct ab8500_usb {\n\tstruct usb_phy phy;\n\tstruct device *dev;\n\tstruct ab8500 *ab8500;\n\tunsigned vbus_draw;\n\tstruct work_struct phy_dis_work;\n\tenum ab8500_usb_mode mode;\n\tstruct clk *sysclk;\n\tstruct regulator *v_ape;\n\tstruct regulator *v_musb;\n\tstruct regulator *v_ulpi;\n\tint saved_v_ulpi;\n\tint previous_link_status_state;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_sleep;\n\tbool enabled_charging_detection;\n\tunsigned int flags;\n};\n\nstatic inline struct ab8500_usb *phy_to_ab(struct usb_phy *x)\n{\n\treturn container_of(x, struct ab8500_usb, phy);\n}\n\nstatic void ab8500_usb_wd_workaround(struct ab8500_usb *ab)\n{\n\tabx500_set_register_interruptible(ab->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WD_CTRL_REG,\n\t\tAB8500_BIT_WD_CTRL_ENABLE);\n\n\tudelay(AB8500_WD_KICK_DELAY_US);\n\n\tabx500_set_register_interruptible(ab->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WD_CTRL_REG,\n\t\t(AB8500_BIT_WD_CTRL_ENABLE\n\t\t| AB8500_BIT_WD_CTRL_KICK));\n\n\tudelay(AB8500_WD_V11_DISABLE_DELAY_US);\n\n\tabx500_set_register_interruptible(ab->dev,\n\t\tAB8500_SYS_CTRL2_BLOCK,\n\t\tAB8500_MAIN_WD_CTRL_REG,\n\t\t0);\n}\n\nstatic void ab8500_usb_regulator_enable(struct ab8500_usb *ab)\n{\n\tint ret, volt;\n\n\tret = regulator_enable(ab->v_ape);\n\tif (ret)\n\t\tdev_err(ab->dev, \"Failed to enable v-ape\\n\");\n\n\tif (ab->flags & AB8500_USB_FLAG_REGULATOR_SET_VOLTAGE) {\n\t\tab->saved_v_ulpi = regulator_get_voltage(ab->v_ulpi);\n\t\tif (ab->saved_v_ulpi < 0)\n\t\t\tdev_err(ab->dev, \"Failed to get v_ulpi voltage\\n\");\n\n\t\tret = regulator_set_voltage(ab->v_ulpi, 1300000, 1350000);\n\t\tif (ret < 0)\n\t\t\tdev_err(ab->dev, \"Failed to set the Vintcore to 1.3V, ret=%d\\n\",\n\t\t\t\t\tret);\n\n\t\tret = regulator_set_load(ab->v_ulpi, 28000);\n\t\tif (ret < 0)\n\t\t\tdev_err(ab->dev, \"Failed to set optimum mode (ret=%d)\\n\",\n\t\t\t\t\tret);\n\t}\n\n\tret = regulator_enable(ab->v_ulpi);\n\tif (ret)\n\t\tdev_err(ab->dev, \"Failed to enable vddulpivio18\\n\");\n\n\tif (ab->flags & AB8500_USB_FLAG_REGULATOR_SET_VOLTAGE) {\n\t\tvolt = regulator_get_voltage(ab->v_ulpi);\n\t\tif ((volt != 1300000) && (volt != 1350000))\n\t\t\tdev_err(ab->dev, \"Vintcore is not set to 1.3V volt=%d\\n\",\n\t\t\t\t\tvolt);\n\t}\n\n\tret = regulator_enable(ab->v_musb);\n\tif (ret)\n\t\tdev_err(ab->dev, \"Failed to enable musb_1v8\\n\");\n}\n\nstatic void ab8500_usb_regulator_disable(struct ab8500_usb *ab)\n{\n\tint ret;\n\n\tregulator_disable(ab->v_musb);\n\n\tregulator_disable(ab->v_ulpi);\n\n\t \n\tif (ab->flags & AB8500_USB_FLAG_REGULATOR_SET_VOLTAGE) {\n\t\tif (ab->saved_v_ulpi > 0) {\n\t\t\tret = regulator_set_voltage(ab->v_ulpi,\n\t\t\t\t\tab->saved_v_ulpi, ab->saved_v_ulpi);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(ab->dev, \"Failed to set the Vintcore to %duV, ret=%d\\n\",\n\t\t\t\t\t\tab->saved_v_ulpi, ret);\n\t\t}\n\n\t\tret = regulator_set_load(ab->v_ulpi, 0);\n\t\tif (ret < 0)\n\t\t\tdev_err(ab->dev, \"Failed to set optimum mode (ret=%d)\\n\",\n\t\t\t\t\tret);\n\t}\n\n\tregulator_disable(ab->v_ape);\n}\n\nstatic void ab8500_usb_wd_linkstatus(struct ab8500_usb *ab, u8 bit)\n{\n\t \n\tif (is_ab8500_2p0(ab->ab8500)) {\n\t\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\t\tbit, bit);\n\t\tudelay(AB8500_V20_31952_DISABLE_DELAY_US);\n\t}\n}\n\nstatic void ab8500_usb_phy_enable(struct ab8500_usb *ab, bool sel_host)\n{\n\tu8 bit;\n\tbit = sel_host ? AB8500_BIT_PHY_CTRL_HOST_EN :\n\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN;\n\n\t \n\tab->pinctrl = pinctrl_get_select(ab->dev, PINCTRL_STATE_DEFAULT);\n\tif (IS_ERR(ab->pinctrl))\n\t\tdev_err(ab->dev, \"could not get/set default pinstate\\n\");\n\n\tif (clk_prepare_enable(ab->sysclk))\n\t\tdev_err(ab->dev, \"can't prepare/enable clock\\n\");\n\n\tab8500_usb_regulator_enable(ab);\n\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tbit, bit);\n}\n\nstatic void ab8500_usb_phy_disable(struct ab8500_usb *ab, bool sel_host)\n{\n\tu8 bit;\n\tbit = sel_host ? AB8500_BIT_PHY_CTRL_HOST_EN :\n\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN;\n\n\tab8500_usb_wd_linkstatus(ab, bit);\n\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tbit, 0);\n\n\t \n\tab8500_usb_wd_workaround(ab);\n\n\tclk_disable_unprepare(ab->sysclk);\n\n\tab8500_usb_regulator_disable(ab);\n\n\tif (!IS_ERR(ab->pinctrl)) {\n\t\t \n\t\tab->pins_sleep = pinctrl_lookup_state(ab->pinctrl,\n\t\t\t\tPINCTRL_STATE_SLEEP);\n\n\t\tif (IS_ERR(ab->pins_sleep))\n\t\t\tdev_dbg(ab->dev, \"could not get sleep pinstate\\n\");\n\t\telse if (pinctrl_select_state(ab->pinctrl, ab->pins_sleep))\n\t\t\tdev_err(ab->dev, \"could not set pins to sleep state\\n\");\n\n\t\t \n\t\tpinctrl_put(ab->pinctrl);\n\t}\n}\n\n#define ab8500_usb_host_phy_en(ab)\tab8500_usb_phy_enable(ab, true)\n#define ab8500_usb_host_phy_dis(ab)\tab8500_usb_phy_disable(ab, true)\n#define ab8500_usb_peri_phy_en(ab)\tab8500_usb_phy_enable(ab, false)\n#define ab8500_usb_peri_phy_dis(ab)\tab8500_usb_phy_disable(ab, false)\n\nstatic int ab8505_usb_link_status_update(struct ab8500_usb *ab,\n\t\tenum ab8505_usb_link_status lsts)\n{\n\tenum ux500_musb_vbus_id_status event = 0;\n\n\tdev_dbg(ab->dev, \"ab8505_usb_link_status_update %d\\n\", lsts);\n\n\t \n\tif (ab->previous_link_status_state == USB_LINK_ACA_RID_A_8505 &&\n\t\t\t(lsts == USB_LINK_STD_HOST_NC_8505))\n\t\treturn 0;\n\n\tab->previous_link_status_state = lsts;\n\n\tswitch (lsts) {\n\tcase USB_LINK_ACA_RID_B_8505:\n\t\tevent = UX500_MUSB_RIDB;\n\t\tfallthrough;\n\tcase USB_LINK_NOT_CONFIGURED_8505:\n\tcase USB_LINK_RESERVED0_8505:\n\tcase USB_LINK_RESERVED1_8505:\n\tcase USB_LINK_RESERVED2_8505:\n\tcase USB_LINK_RESERVED3_8505:\n\t\tab->mode = USB_IDLE;\n\t\tab->phy.otg->default_a = false;\n\t\tab->vbus_draw = 0;\n\t\tif (event != UX500_MUSB_RIDB)\n\t\t\tevent = UX500_MUSB_NONE;\n\t\t \n\t\tab->phy.otg->state = OTG_STATE_B_IDLE;\n\t\tusb_phy_set_event(&ab->phy, USB_EVENT_NONE);\n\t\tbreak;\n\n\tcase USB_LINK_ACA_RID_C_NM_8505:\n\t\tevent = UX500_MUSB_RIDC;\n\t\tfallthrough;\n\tcase USB_LINK_STD_HOST_NC_8505:\n\tcase USB_LINK_STD_HOST_C_NS_8505:\n\tcase USB_LINK_STD_HOST_C_S_8505:\n\tcase USB_LINK_CDP_8505:\n\t\tif (ab->mode == USB_IDLE) {\n\t\t\tab->mode = USB_PERIPHERAL;\n\t\t\tab8500_usb_peri_phy_en(ab);\n\t\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\t\tUX500_MUSB_PREPARE, &ab->vbus_draw);\n\t\t\tusb_phy_set_event(&ab->phy, USB_EVENT_ENUMERATED);\n\t\t}\n\t\tif (event != UX500_MUSB_RIDC)\n\t\t\tevent = UX500_MUSB_VBUS;\n\t\tbreak;\n\n\tcase USB_LINK_ACA_RID_A_8505:\n\tcase USB_LINK_ACA_DOCK_CHGR_8505:\n\t\tevent = UX500_MUSB_RIDA;\n\t\tfallthrough;\n\tcase USB_LINK_HM_IDGND_8505:\n\t\tif (ab->mode == USB_IDLE) {\n\t\t\tab->mode = USB_HOST;\n\t\t\tab8500_usb_host_phy_en(ab);\n\t\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\t\tUX500_MUSB_PREPARE, &ab->vbus_draw);\n\t\t}\n\t\tab->phy.otg->default_a = true;\n\t\tif (event != UX500_MUSB_RIDA)\n\t\t\tevent = UX500_MUSB_ID;\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tbreak;\n\n\tcase USB_LINK_DEDICATED_CHG_8505:\n\t\tab->mode = USB_DEDICATED_CHG;\n\t\tevent = UX500_MUSB_CHARGER;\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tusb_phy_set_event(&ab->phy, USB_EVENT_CHARGER);\n\t\tbreak;\n\n\t \n\tcase USB_LINK_SAMSUNG_UART_CBL_PHY_EN_8505:\n\tcase USB_LINK_SAMSUNG_UART_CBL_PHY_DISB_8505:\n\t\tif (ab->mode == USB_IDLE) {\n\t\t\tab->mode = USB_UART;\n\t\t\tab8500_usb_peri_phy_en(ab);\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ab8500_usb_link_status_update(struct ab8500_usb *ab,\n\t\tenum ab8500_usb_link_status lsts)\n{\n\tenum ux500_musb_vbus_id_status event = 0;\n\n\tdev_dbg(ab->dev, \"ab8500_usb_link_status_update %d\\n\", lsts);\n\n\t \n\tif (ab->previous_link_status_state == USB_LINK_HM_IDGND_8500 &&\n\t\t\t(lsts == USB_LINK_STD_HOST_C_NS_8500 ||\n\t\t\t lsts == USB_LINK_STD_HOST_NC_8500))\n\t\treturn 0;\n\n\tif (ab->previous_link_status_state == USB_LINK_ACA_RID_A_8500 &&\n\t\t\tlsts == USB_LINK_STD_HOST_NC_8500)\n\t\treturn 0;\n\n\tab->previous_link_status_state = lsts;\n\n\tswitch (lsts) {\n\tcase USB_LINK_ACA_RID_B_8500:\n\t\tevent = UX500_MUSB_RIDB;\n\t\tfallthrough;\n\tcase USB_LINK_NOT_CONFIGURED_8500:\n\tcase USB_LINK_NOT_VALID_LINK_8500:\n\t\tab->mode = USB_IDLE;\n\t\tab->phy.otg->default_a = false;\n\t\tab->vbus_draw = 0;\n\t\tif (event != UX500_MUSB_RIDB)\n\t\t\tevent = UX500_MUSB_NONE;\n\t\t \n\t\tab->phy.otg->state = OTG_STATE_B_IDLE;\n\t\tusb_phy_set_event(&ab->phy, USB_EVENT_NONE);\n\t\tbreak;\n\n\tcase USB_LINK_ACA_RID_C_NM_8500:\n\tcase USB_LINK_ACA_RID_C_HS_8500:\n\tcase USB_LINK_ACA_RID_C_HS_CHIRP_8500:\n\t\tevent = UX500_MUSB_RIDC;\n\t\tfallthrough;\n\tcase USB_LINK_STD_HOST_NC_8500:\n\tcase USB_LINK_STD_HOST_C_NS_8500:\n\tcase USB_LINK_STD_HOST_C_S_8500:\n\tcase USB_LINK_HOST_CHG_NM_8500:\n\tcase USB_LINK_HOST_CHG_HS_8500:\n\tcase USB_LINK_HOST_CHG_HS_CHIRP_8500:\n\t\tif (ab->mode == USB_IDLE) {\n\t\t\tab->mode = USB_PERIPHERAL;\n\t\t\tab8500_usb_peri_phy_en(ab);\n\t\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\t\tUX500_MUSB_PREPARE, &ab->vbus_draw);\n\t\t\tusb_phy_set_event(&ab->phy, USB_EVENT_ENUMERATED);\n\t\t}\n\t\tif (event != UX500_MUSB_RIDC)\n\t\t\tevent = UX500_MUSB_VBUS;\n\t\tbreak;\n\n\tcase USB_LINK_ACA_RID_A_8500:\n\t\tevent = UX500_MUSB_RIDA;\n\t\tfallthrough;\n\tcase USB_LINK_HM_IDGND_8500:\n\t\tif (ab->mode == USB_IDLE) {\n\t\t\tab->mode = USB_HOST;\n\t\t\tab8500_usb_host_phy_en(ab);\n\t\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\t\tUX500_MUSB_PREPARE, &ab->vbus_draw);\n\t\t}\n\t\tab->phy.otg->default_a = true;\n\t\tif (event != UX500_MUSB_RIDA)\n\t\t\tevent = UX500_MUSB_ID;\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tbreak;\n\n\tcase USB_LINK_DEDICATED_CHG_8500:\n\t\tab->mode = USB_DEDICATED_CHG;\n\t\tevent = UX500_MUSB_CHARGER;\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tusb_phy_set_event(&ab->phy, USB_EVENT_CHARGER);\n\t\tbreak;\n\n\tcase USB_LINK_RESERVED_8500:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int abx500_usb_link_status_update(struct ab8500_usb *ab)\n{\n\tu8 reg;\n\tint ret = 0;\n\n\tif (is_ab8500(ab->ab8500)) {\n\t\tenum ab8500_usb_link_status lsts;\n\n\t\tret = abx500_get_register_interruptible(ab->dev,\n\t\t\t\tAB8500_USB, AB8500_USB_LINE_STAT_REG, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlsts = (reg >> 3) & 0x0F;\n\t\tret = ab8500_usb_link_status_update(ab, lsts);\n\t} else if (is_ab8505(ab->ab8500)) {\n\t\tenum ab8505_usb_link_status lsts;\n\n\t\tret = abx500_get_register_interruptible(ab->dev,\n\t\t\t\tAB8500_USB, AB8505_USB_LINE_STAT_REG, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tlsts = (reg >> 3) & 0x1F;\n\t\tret = ab8505_usb_link_status_update(ab, lsts);\n\t}\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t ab8500_usb_disconnect_irq(int irq, void *data)\n{\n\tstruct ab8500_usb *ab = (struct ab8500_usb *) data;\n\tenum usb_phy_events event = USB_EVENT_NONE;\n\n\t \n\tif (ab->mode == USB_HOST) {\n\t\tab->phy.otg->default_a = false;\n\t\tab->vbus_draw = 0;\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tab8500_usb_host_phy_dis(ab);\n\t\tab->mode = USB_IDLE;\n\t}\n\n\tif (ab->mode == USB_PERIPHERAL) {\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tevent, &ab->vbus_draw);\n\t\tab8500_usb_peri_phy_dis(ab);\n\t\tatomic_notifier_call_chain(&ab->phy.notifier,\n\t\t\t\tUX500_MUSB_CLEAN, &ab->vbus_draw);\n\t\tab->mode = USB_IDLE;\n\t\tab->phy.otg->default_a = false;\n\t\tab->vbus_draw = 0;\n\t}\n\n\tif (ab->mode == USB_UART) {\n\t\tab8500_usb_peri_phy_dis(ab);\n\t\tab->mode = USB_IDLE;\n\t}\n\n\tif (is_ab8500_2p0(ab->ab8500)) {\n\t\tif (ab->mode == USB_DEDICATED_CHG) {\n\t\t\tab8500_usb_wd_linkstatus(ab,\n\t\t\t\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN);\n\t\t\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\t\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN, 0);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t ab8500_usb_link_status_irq(int irq, void *data)\n{\n\tstruct ab8500_usb *ab = (struct ab8500_usb *)data;\n\n\tabx500_usb_link_status_update(ab);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ab8500_usb_phy_disable_work(struct work_struct *work)\n{\n\tstruct ab8500_usb *ab = container_of(work, struct ab8500_usb,\n\t\t\t\t\t\tphy_dis_work);\n\n\tif (!ab->phy.otg->host)\n\t\tab8500_usb_host_phy_dis(ab);\n\n\tif (!ab->phy.otg->gadget)\n\t\tab8500_usb_peri_phy_dis(ab);\n}\n\nstatic int ab8500_usb_set_suspend(struct usb_phy *x, int suspend)\n{\n\t \n\treturn 0;\n}\n\nstatic int ab8500_usb_set_peripheral(struct usb_otg *otg,\n\t\t\t\t\tstruct usb_gadget *gadget)\n{\n\tstruct ab8500_usb *ab;\n\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\tab = phy_to_ab(otg->usb_phy);\n\n\tab->phy.otg->gadget = gadget;\n\n\t \n\n\tif ((ab->mode != USB_IDLE) && !gadget) {\n\t\tab->mode = USB_IDLE;\n\t\tschedule_work(&ab->phy_dis_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int ab8500_usb_set_host(struct usb_otg *otg, struct usb_bus *host)\n{\n\tstruct ab8500_usb *ab;\n\n\tif (!otg)\n\t\treturn -ENODEV;\n\n\tab = phy_to_ab(otg->usb_phy);\n\n\tab->phy.otg->host = host;\n\n\t \n\n\tif ((ab->mode != USB_IDLE) && !host) {\n\t\tab->mode = USB_IDLE;\n\t\tschedule_work(&ab->phy_dis_work);\n\t}\n\n\treturn 0;\n}\n\nstatic void ab8500_usb_restart_phy(struct ab8500_usb *ab)\n{\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN,\n\t\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN);\n\n\tudelay(100);\n\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tAB8500_BIT_PHY_CTRL_DEVICE_EN,\n\t\t\t0);\n\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tAB8500_BIT_PHY_CTRL_HOST_EN,\n\t\t\tAB8500_BIT_PHY_CTRL_HOST_EN);\n\n\tudelay(100);\n\n\tabx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_USB, AB8500_USB_PHY_CTRL_REG,\n\t\t\tAB8500_BIT_PHY_CTRL_HOST_EN,\n\t\t\t0);\n}\n\nstatic int ab8500_usb_regulator_get(struct ab8500_usb *ab)\n{\n\tint err;\n\n\tab->v_ape = devm_regulator_get(ab->dev, \"v-ape\");\n\tif (IS_ERR(ab->v_ape)) {\n\t\tdev_err(ab->dev, \"Could not get v-ape supply\\n\");\n\t\terr = PTR_ERR(ab->v_ape);\n\t\treturn err;\n\t}\n\n\tab->v_ulpi = devm_regulator_get(ab->dev, \"vddulpivio18\");\n\tif (IS_ERR(ab->v_ulpi)) {\n\t\tdev_err(ab->dev, \"Could not get vddulpivio18 supply\\n\");\n\t\terr = PTR_ERR(ab->v_ulpi);\n\t\treturn err;\n\t}\n\n\tab->v_musb = devm_regulator_get(ab->dev, \"musb_1v8\");\n\tif (IS_ERR(ab->v_musb)) {\n\t\tdev_err(ab->dev, \"Could not get musb_1v8 supply\\n\");\n\t\terr = PTR_ERR(ab->v_musb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int ab8500_usb_irq_setup(struct platform_device *pdev,\n\t\tstruct ab8500_usb *ab)\n{\n\tint err;\n\tint irq;\n\n\tif (ab->flags & AB8500_USB_FLAG_USE_LINK_STATUS_IRQ) {\n\t\tirq = platform_get_irq_byname(pdev, \"USB_LINK_STATUS\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\tab8500_usb_link_status_irq,\n\t\t\t\tIRQF_NO_SUSPEND | IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\"usb-link-status\", ab);\n\t\tif (err < 0) {\n\t\t\tdev_err(ab->dev, \"request_irq failed for link status irq\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (ab->flags & AB8500_USB_FLAG_USE_ID_WAKEUP_IRQ) {\n\t\tirq = platform_get_irq_byname(pdev, \"ID_WAKEUP_F\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\tab8500_usb_disconnect_irq,\n\t\t\t\tIRQF_NO_SUSPEND | IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\"usb-id-fall\", ab);\n\t\tif (err < 0) {\n\t\t\tdev_err(ab->dev, \"request_irq failed for ID fall irq\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (ab->flags & AB8500_USB_FLAG_USE_VBUS_DET_IRQ) {\n\t\tirq = platform_get_irq_byname(pdev, \"VBUS_DET_F\");\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\terr = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\tab8500_usb_disconnect_irq,\n\t\t\t\tIRQF_NO_SUSPEND | IRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\"usb-vbus-fall\", ab);\n\t\tif (err < 0) {\n\t\t\tdev_err(ab->dev, \"request_irq failed for Vbus fall irq\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ab8500_usb_set_ab8500_tuning_values(struct ab8500_usb *ab)\n{\n\tint err;\n\n\t \n\terr = abx500_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEVELOPMENT, AB8500_BANK12_ACCESS, 0x01);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to enable bank12 access err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE1, 0xC8);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE1 register err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE2, 0x00);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE2 register err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE3, 0x78);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE3 register err=%d\\n\",\n\t\t\t\terr);\n\n\t \n\terr = abx500_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEVELOPMENT, AB8500_BANK12_ACCESS, 0x00);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to switch bank12 access err=%d\\n\",\n\t\t\t\terr);\n}\n\nstatic void ab8500_usb_set_ab8505_tuning_values(struct ab8500_usb *ab)\n{\n\tint err;\n\n\t \n\terr = abx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEVELOPMENT, AB8500_BANK12_ACCESS,\n\t\t\t0x01, 0x01);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to enable bank12 access err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE1,\n\t\t\t0xC8, 0xC8);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE1 register err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE2,\n\t\t\t0x60, 0x60);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE2 register err=%d\\n\",\n\t\t\t\terr);\n\n\terr = abx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEBUG, AB8500_USB_PHY_TUNE3,\n\t\t\t0xFC, 0x80);\n\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to set PHY_TUNE3 register err=%d\\n\",\n\t\t\t\terr);\n\n\t \n\terr = abx500_mask_and_set_register_interruptible(ab->dev,\n\t\t\tAB8500_DEVELOPMENT, AB8500_BANK12_ACCESS,\n\t\t\t0x00, 0x00);\n\tif (err < 0)\n\t\tdev_err(ab->dev, \"Failed to switch bank12 access err=%d\\n\",\n\t\t\t\terr);\n}\n\nstatic int ab8500_usb_probe(struct platform_device *pdev)\n{\n\tstruct ab8500_usb\t*ab;\n\tstruct ab8500\t\t*ab8500;\n\tstruct usb_otg\t\t*otg;\n\tint err;\n\tint rev;\n\n\tab8500 = dev_get_drvdata(pdev->dev.parent);\n\trev = abx500_get_chip_id(&pdev->dev);\n\n\tif (is_ab8500_1p1_or_earlier(ab8500)) {\n\t\tdev_err(&pdev->dev, \"Unsupported AB8500 chip rev=%d\\n\", rev);\n\t\treturn -ENODEV;\n\t}\n\n\tab = devm_kzalloc(&pdev->dev, sizeof(*ab), GFP_KERNEL);\n\tif (!ab)\n\t\treturn -ENOMEM;\n\n\totg = devm_kzalloc(&pdev->dev, sizeof(*otg), GFP_KERNEL);\n\tif (!otg)\n\t\treturn -ENOMEM;\n\n\tab->dev\t\t\t= &pdev->dev;\n\tab->ab8500\t\t= ab8500;\n\tab->phy.dev\t\t= ab->dev;\n\tab->phy.otg\t\t= otg;\n\tab->phy.label\t\t= \"ab8500\";\n\tab->phy.set_suspend\t= ab8500_usb_set_suspend;\n\tab->phy.otg->state\t= OTG_STATE_UNDEFINED;\n\n\totg->usb_phy\t\t= &ab->phy;\n\totg->set_host\t\t= ab8500_usb_set_host;\n\totg->set_peripheral\t= ab8500_usb_set_peripheral;\n\n\tif (is_ab8500(ab->ab8500)) {\n\t\tab->flags |= AB8500_USB_FLAG_USE_LINK_STATUS_IRQ |\n\t\t\tAB8500_USB_FLAG_USE_ID_WAKEUP_IRQ |\n\t\t\tAB8500_USB_FLAG_USE_VBUS_DET_IRQ |\n\t\t\tAB8500_USB_FLAG_REGULATOR_SET_VOLTAGE;\n\t} else if (is_ab8505(ab->ab8500)) {\n\t\tab->flags |= AB8500_USB_FLAG_USE_LINK_STATUS_IRQ |\n\t\t\tAB8500_USB_FLAG_USE_ID_WAKEUP_IRQ |\n\t\t\tAB8500_USB_FLAG_USE_VBUS_DET_IRQ |\n\t\t\tAB8500_USB_FLAG_REGULATOR_SET_VOLTAGE;\n\t}\n\n\t \n\tif (is_ab8500_2p0_or_earlier(ab->ab8500))\n\t\tab->flags &= ~AB8500_USB_FLAG_REGULATOR_SET_VOLTAGE;\n\n\tplatform_set_drvdata(pdev, ab);\n\n\t \n\tINIT_WORK(&ab->phy_dis_work, ab8500_usb_phy_disable_work);\n\n\terr = ab8500_usb_regulator_get(ab);\n\tif (err)\n\t\treturn err;\n\n\tab->sysclk = devm_clk_get(ab->dev, \"sysclk\");\n\tif (IS_ERR(ab->sysclk)) {\n\t\tdev_err(ab->dev, \"Could not get sysclk.\\n\");\n\t\treturn PTR_ERR(ab->sysclk);\n\t}\n\n\terr = ab8500_usb_irq_setup(pdev, ab);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = usb_add_phy(&ab->phy, USB_PHY_TYPE_USB2);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't register transceiver\\n\");\n\t\treturn err;\n\t}\n\n\tif (is_ab8500(ab->ab8500) && !is_ab8500_2p0_or_earlier(ab->ab8500))\n\t\t \n\t\tab8500_usb_set_ab8500_tuning_values(ab);\n\telse if (is_ab8505(ab->ab8500))\n\t\t \n\t\tab8500_usb_set_ab8505_tuning_values(ab);\n\n\t \n\tab8500_usb_wd_workaround(ab);\n\n\t \n\tab8500_usb_restart_phy(ab);\n\n\tabx500_usb_link_status_update(ab);\n\n\tdev_info(&pdev->dev, \"revision 0x%2x driver initialized\\n\", rev);\n\n\treturn 0;\n}\n\nstatic void ab8500_usb_remove(struct platform_device *pdev)\n{\n\tstruct ab8500_usb *ab = platform_get_drvdata(pdev);\n\n\tcancel_work_sync(&ab->phy_dis_work);\n\n\tusb_remove_phy(&ab->phy);\n\n\tif (ab->mode == USB_HOST)\n\t\tab8500_usb_host_phy_dis(ab);\n\telse if (ab->mode == USB_PERIPHERAL)\n\t\tab8500_usb_peri_phy_dis(ab);\n}\n\nstatic const struct platform_device_id ab8500_usb_devtype[] = {\n\t{ .name = \"ab8500-usb\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(platform, ab8500_usb_devtype);\n\nstatic struct platform_driver ab8500_usb_driver = {\n\t.probe\t\t= ab8500_usb_probe,\n\t.remove_new\t= ab8500_usb_remove,\n\t.id_table\t= ab8500_usb_devtype,\n\t.driver\t\t= {\n\t\t.name\t= \"abx5x0-usb\",\n\t},\n};\n\nstatic int __init ab8500_usb_init(void)\n{\n\treturn platform_driver_register(&ab8500_usb_driver);\n}\nsubsys_initcall(ab8500_usb_init);\n\nstatic void __exit ab8500_usb_exit(void)\n{\n\tplatform_driver_unregister(&ab8500_usb_driver);\n}\nmodule_exit(ab8500_usb_exit);\n\nMODULE_AUTHOR(\"ST-Ericsson AB\");\nMODULE_DESCRIPTION(\"AB8500 family usb transceiver driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}