{
  "module_name": "isp1760-if.c",
  "hash_id": "f01b43a0746a7d71b526b461a24962f302d47bb3600fec07bfd653794d6c0850",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/isp1760/isp1760-if.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n\n#include \"isp1760-core.h\"\n#include \"isp1760-regs.h\"\n\n#ifdef CONFIG_USB_PCI\n#include <linux/pci.h>\n#endif\n\n#ifdef CONFIG_USB_PCI\nstatic int isp1761_pci_init(struct pci_dev *dev)\n{\n\tresource_size_t mem_start;\n\tresource_size_t mem_length;\n\tu8 __iomem *iobase;\n\tu8 latency, limit;\n\tint retry_count;\n\tu32 reg_data;\n\n\t \n\tmem_start = pci_resource_start(dev, 3);\n\tmem_length = pci_resource_len(dev, 3);\n\tif (mem_length < 0xffff) {\n\t\tprintk(KERN_ERR \"memory length for this resource is wrong\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!request_mem_region(mem_start, mem_length, \"ISP-PCI\")) {\n\t\tprintk(KERN_ERR \"host controller already in use\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tiobase = ioremap(mem_start, mem_length);\n\tif (!iobase) {\n\t\tprintk(KERN_ERR \"Error ioremap failed\\n\");\n\t\trelease_mem_region(mem_start, mem_length);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tpci_read_config_byte(dev, PCI_LATENCY_TIMER, &latency);\n\tif (latency) {\n\t\tpci_read_config_byte(dev, PCI_MAX_LAT, &limit);\n\t\tif (limit && limit < latency)\n\t\t\tpci_write_config_byte(dev, PCI_LATENCY_TIMER, limit);\n\t}\n\n\t \n\tretry_count = 20;\n\treg_data = 0;\n\twhile ((reg_data != 0xFACE) && retry_count) {\n\t\t \n\t\twritel(0xface, iobase + ISP176x_HC_SCRATCH);\n\t\tudelay(100);\n\t\treg_data = readl(iobase + ISP176x_HC_SCRATCH) & 0x0000ffff;\n\t\tretry_count--;\n\t}\n\n\tiounmap(iobase);\n\trelease_mem_region(mem_start, mem_length);\n\n\t \n\tif (reg_data != 0xFACE) {\n\t\tdev_err(&dev->dev, \"scratch register mismatch %x\\n\", reg_data);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmem_start = pci_resource_start(dev, 0);\n\tmem_length = pci_resource_len(dev, 0);\n\n\tif (!request_mem_region(mem_start, mem_length, \"ISP1761 IO MEM\")) {\n\t\tprintk(KERN_ERR \"request region #1\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tiobase = ioremap(mem_start, mem_length);\n\tif (!iobase) {\n\t\tprintk(KERN_ERR \"ioremap #1\\n\");\n\t\trelease_mem_region(mem_start, mem_length);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n#define PLX_INT_CSR_REG 0x68\n\treg_data = readl(iobase + PLX_INT_CSR_REG);\n\treg_data |= 0x900;\n\twritel(reg_data, iobase + PLX_INT_CSR_REG);\n\n\t \n\tiounmap(iobase);\n\trelease_mem_region(mem_start, mem_length);\n\n\treturn 0;\n}\n\nstatic int isp1761_pci_probe(struct pci_dev *dev,\n\t\tconst struct pci_device_id *id)\n{\n\tunsigned int devflags = 0;\n\tint ret;\n\n\tif (!dev->irq)\n\t\treturn -ENODEV;\n\n\tif (pci_enable_device(dev) < 0)\n\t\treturn -ENODEV;\n\n\tret = isp1761_pci_init(dev);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tpci_set_master(dev);\n\n\tret = isp1760_register(&dev->resource[3], dev->irq, 0, &dev->dev,\n\t\t\t       devflags);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tpci_disable_device(dev);\n\treturn ret;\n}\n\nstatic void isp1761_pci_remove(struct pci_dev *dev)\n{\n\tisp1760_unregister(&dev->dev);\n\n\tpci_disable_device(dev);\n}\n\nstatic void isp1761_pci_shutdown(struct pci_dev *dev)\n{\n\tprintk(KERN_ERR \"ips1761_pci_shutdown\\n\");\n}\n\nstatic const struct pci_device_id isp1760_plx[] = {\n\t{\n\t\t.class          = PCI_CLASS_BRIDGE_OTHER << 8,\n\t\t.class_mask     = ~0,\n\t\t.vendor\t\t= PCI_VENDOR_ID_PLX,\n\t\t.device\t\t= 0x5406,\n\t\t.subvendor\t= PCI_VENDOR_ID_PLX,\n\t\t.subdevice\t= 0x9054,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, isp1760_plx);\n\nstatic struct pci_driver isp1761_pci_driver = {\n\t.name =         \"isp1760\",\n\t.id_table =     isp1760_plx,\n\t.probe =        isp1761_pci_probe,\n\t.remove =       isp1761_pci_remove,\n\t.shutdown =     isp1761_pci_shutdown,\n};\n#endif\n\nstatic int isp1760_plat_probe(struct platform_device *pdev)\n{\n\tunsigned long irqflags;\n\tunsigned int devflags = 0;\n\tstruct resource *mem_res;\n\tint irq;\n\tint ret;\n\n\tmem_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tirqflags = irq_get_trigger_type(irq);\n\n\tif (IS_ENABLED(CONFIG_OF) && pdev->dev.of_node) {\n\t\tstruct device_node *dp = pdev->dev.of_node;\n\t\tu32 bus_width = 0;\n\n\t\tif (of_device_is_compatible(dp, \"nxp,usb-isp1761\"))\n\t\t\tdevflags |= ISP1760_FLAG_ISP1761;\n\n\t\tif (of_device_is_compatible(dp, \"nxp,usb-isp1763\"))\n\t\t\tdevflags |= ISP1760_FLAG_ISP1763;\n\n\t\t \n\t\tof_property_read_u32(dp, \"bus-width\", &bus_width);\n\t\tif (bus_width == 16)\n\t\t\tdevflags |= ISP1760_FLAG_BUS_WIDTH_16;\n\t\telse if (bus_width == 8)\n\t\t\tdevflags |= ISP1760_FLAG_BUS_WIDTH_8;\n\n\t\tif (usb_get_dr_mode(&pdev->dev) == USB_DR_MODE_PERIPHERAL)\n\t\t\tdevflags |= ISP1760_FLAG_PERIPHERAL_EN;\n\n\t\tif (of_property_read_bool(dp, \"analog-oc\"))\n\t\t\tdevflags |= ISP1760_FLAG_ANALOG_OC;\n\n\t\tif (of_property_read_bool(dp, \"dack-polarity\"))\n\t\t\tdevflags |= ISP1760_FLAG_DACK_POL_HIGH;\n\n\t\tif (of_property_read_bool(dp, \"dreq-polarity\"))\n\t\t\tdevflags |= ISP1760_FLAG_DREQ_POL_HIGH;\n\t} else {\n\t\tpr_err(\"isp1760: no platform data\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = isp1760_register(mem_res, irq, irqflags, &pdev->dev, devflags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpr_info(\"ISP1760 USB device initialised\\n\");\n\treturn 0;\n}\n\nstatic void isp1760_plat_remove(struct platform_device *pdev)\n{\n\tisp1760_unregister(&pdev->dev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id isp1760_of_match[] = {\n\t{ .compatible = \"nxp,usb-isp1760\", },\n\t{ .compatible = \"nxp,usb-isp1761\", },\n\t{ .compatible = \"nxp,usb-isp1763\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, isp1760_of_match);\n#endif\n\nstatic struct platform_driver isp1760_plat_driver = {\n\t.probe\t= isp1760_plat_probe,\n\t.remove_new = isp1760_plat_remove,\n\t.driver\t= {\n\t\t.name\t= \"isp1760\",\n\t\t.of_match_table = of_match_ptr(isp1760_of_match),\n\t},\n};\n\nstatic int __init isp1760_init(void)\n{\n\tint ret, any_ret = -ENODEV;\n\n\tisp1760_init_kmem_once();\n\n\tret = platform_driver_register(&isp1760_plat_driver);\n\tif (!ret)\n\t\tany_ret = 0;\n#ifdef CONFIG_USB_PCI\n\tret = pci_register_driver(&isp1761_pci_driver);\n\tif (!ret)\n\t\tany_ret = 0;\n#endif\n\n\tif (any_ret)\n\t\tisp1760_deinit_kmem_cache();\n\treturn any_ret;\n}\nmodule_init(isp1760_init);\n\nstatic void __exit isp1760_exit(void)\n{\n\tplatform_driver_unregister(&isp1760_plat_driver);\n#ifdef CONFIG_USB_PCI\n\tpci_unregister_driver(&isp1761_pci_driver);\n#endif\n\tisp1760_deinit_kmem_cache();\n}\nmodule_exit(isp1760_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}