{
  "module_name": "isp1760-udc.c",
  "hash_id": "6a3857edd876cb355e011033963c0011bb2ced912fed14ef004dbf4af53f0a95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/isp1760/isp1760-udc.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n\n#include \"isp1760-core.h\"\n#include \"isp1760-regs.h\"\n#include \"isp1760-udc.h\"\n\n#define ISP1760_VBUS_POLL_INTERVAL\tmsecs_to_jiffies(500)\n\nstruct isp1760_request {\n\tstruct usb_request req;\n\tstruct list_head queue;\n\tstruct isp1760_ep *ep;\n\tunsigned int packet_size;\n};\n\nstatic inline struct isp1760_udc *gadget_to_udc(struct usb_gadget *gadget)\n{\n\treturn container_of(gadget, struct isp1760_udc, gadget);\n}\n\nstatic inline struct isp1760_ep *ep_to_udc_ep(struct usb_ep *ep)\n{\n\treturn container_of(ep, struct isp1760_ep, ep);\n}\n\nstatic inline struct isp1760_request *req_to_udc_req(struct usb_request *req)\n{\n\treturn container_of(req, struct isp1760_request, req);\n}\n\nstatic u32 isp1760_udc_read(struct isp1760_udc *udc, u16 field)\n{\n\treturn isp1760_field_read(udc->fields, field);\n}\n\nstatic void isp1760_udc_write(struct isp1760_udc *udc, u16 field, u32 val)\n{\n\tisp1760_field_write(udc->fields, field, val);\n}\n\nstatic u32 isp1760_udc_read_raw(struct isp1760_udc *udc, u16 reg)\n{\n\t__le32 val;\n\n\tregmap_raw_read(udc->regs, reg, &val, 4);\n\n\treturn le32_to_cpu(val);\n}\n\nstatic u16 isp1760_udc_read_raw16(struct isp1760_udc *udc, u16 reg)\n{\n\t__le16 val;\n\n\tregmap_raw_read(udc->regs, reg, &val, 2);\n\n\treturn le16_to_cpu(val);\n}\n\nstatic void isp1760_udc_write_raw(struct isp1760_udc *udc, u16 reg, u32 val)\n{\n\t__le32 val_le = cpu_to_le32(val);\n\n\tregmap_raw_write(udc->regs, reg, &val_le, 4);\n}\n\nstatic void isp1760_udc_write_raw16(struct isp1760_udc *udc, u16 reg, u16 val)\n{\n\t__le16 val_le = cpu_to_le16(val);\n\n\tregmap_raw_write(udc->regs, reg, &val_le, 2);\n}\n\nstatic void isp1760_udc_set(struct isp1760_udc *udc, u32 field)\n{\n\tisp1760_udc_write(udc, field, 0xFFFFFFFF);\n}\n\nstatic void isp1760_udc_clear(struct isp1760_udc *udc, u32 field)\n{\n\tisp1760_udc_write(udc, field, 0);\n}\n\nstatic bool isp1760_udc_is_set(struct isp1760_udc *udc, u32 field)\n{\n\treturn !!isp1760_udc_read(udc, field);\n}\n \n\nstatic struct isp1760_ep *isp1760_udc_find_ep(struct isp1760_udc *udc,\n\t\t\t\t\t      u16 index)\n{\n\tunsigned int i;\n\n\tif (index == 0)\n\t\treturn &udc->ep[0];\n\n\tfor (i = 1; i < ARRAY_SIZE(udc->ep); ++i) {\n\t\tif (udc->ep[i].addr == index)\n\t\t\treturn udc->ep[i].desc ? &udc->ep[i] : NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic void __isp1760_udc_select_ep(struct isp1760_udc *udc,\n\t\t\t\t    struct isp1760_ep *ep, int dir)\n{\n\tisp1760_udc_write(udc, DC_ENDPIDX, ep->addr & USB_ENDPOINT_NUMBER_MASK);\n\n\tif (dir == USB_DIR_IN)\n\t\tisp1760_udc_set(udc, DC_EPDIR);\n\telse\n\t\tisp1760_udc_clear(udc, DC_EPDIR);\n}\n\n \nstatic void isp1760_udc_select_ep(struct isp1760_udc *udc,\n\t\t\t\t  struct isp1760_ep *ep)\n{\n\t__isp1760_udc_select_ep(udc, ep, ep->addr & USB_ENDPOINT_DIR_MASK);\n}\n\n \nstatic void isp1760_udc_ctrl_send_status(struct isp1760_ep *ep, int dir)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\n\t \n\tif (dir == USB_DIR_IN)\n\t\tisp1760_udc_clear(udc, DC_EPDIR);\n\telse\n\t\tisp1760_udc_set(udc, DC_EPDIR);\n\n\tisp1760_udc_write(udc, DC_ENDPIDX, 1);\n\tisp1760_udc_set(udc, DC_STATUS);\n\n\t \n\tudc->ep0_state = ISP1760_CTRL_SETUP;\n}\n\n \nstatic void isp1760_udc_request_complete(struct isp1760_ep *ep,\n\t\t\t\t\t struct isp1760_request *req,\n\t\t\t\t\t int status)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tunsigned long flags;\n\n\tdev_dbg(ep->udc->isp->dev, \"completing request %p with status %d\\n\",\n\t\treq, status);\n\n\treq->ep = NULL;\n\treq->req.status = status;\n\treq->req.complete(&ep->ep, &req->req);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (status == 0 && ep->addr == 0 && udc->ep0_dir == USB_DIR_OUT)\n\t\tisp1760_udc_ctrl_send_status(ep, USB_DIR_OUT);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic void isp1760_udc_ctrl_send_stall(struct isp1760_ep *ep)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tunsigned long flags;\n\n\tdev_dbg(ep->udc->isp->dev, \"%s(ep%02x)\\n\", __func__, ep->addr);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\t__isp1760_udc_select_ep(udc, ep, USB_DIR_OUT);\n\tisp1760_udc_set(udc, DC_STALL);\n\t__isp1760_udc_select_ep(udc, ep, USB_DIR_IN);\n\tisp1760_udc_set(udc, DC_STALL);\n\n\t \n\tudc->ep0_state = ISP1760_CTRL_SETUP;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\n \n\n \nstatic bool isp1760_udc_receive(struct isp1760_ep *ep,\n\t\t\t\tstruct isp1760_request *req)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tunsigned int len;\n\tu32 *buf;\n\tint i;\n\n\tisp1760_udc_select_ep(udc, ep);\n\tlen = isp1760_udc_read(udc, DC_BUFLEN);\n\n\tdev_dbg(udc->isp->dev, \"%s: received %u bytes (%u/%u done)\\n\",\n\t\t__func__, len, req->req.actual, req->req.length);\n\n\tlen = min(len, req->req.length - req->req.actual);\n\n\tif (!len) {\n\t\t \n\t\tisp1760_udc_set(udc, DC_CLBUF);\n\t\treturn false;\n\t}\n\n\tbuf = req->req.buf + req->req.actual;\n\n\t \n\tfor (i = len; i > 2; i -= 4, ++buf)\n\t\t*buf = isp1760_udc_read_raw(udc, ISP176x_DC_DATAPORT);\n\tif (i > 0)\n\t\t*(u16 *)buf = isp1760_udc_read_raw16(udc, ISP176x_DC_DATAPORT);\n\n\treq->req.actual += len;\n\n\t \n\n\tdev_dbg(udc->isp->dev,\n\t\t\"%s: req %p actual/length %u/%u maxpacket %u packet size %u\\n\",\n\t\t__func__, req, req->req.actual, req->req.length, ep->maxpacket,\n\t\tlen);\n\n\tep->rx_pending = false;\n\n\t \n\tif (req->req.actual == req->req.length || len < ep->maxpacket) {\n\t\tlist_del(&req->queue);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void isp1760_udc_transmit(struct isp1760_ep *ep,\n\t\t\t\t struct isp1760_request *req)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tu32 *buf = req->req.buf + req->req.actual;\n\tint i;\n\n\treq->packet_size = min(req->req.length - req->req.actual,\n\t\t\t       ep->maxpacket);\n\n\tdev_dbg(udc->isp->dev, \"%s: transferring %u bytes (%u/%u done)\\n\",\n\t\t__func__, req->packet_size, req->req.actual,\n\t\treq->req.length);\n\n\t__isp1760_udc_select_ep(udc, ep, USB_DIR_IN);\n\n\tif (req->packet_size)\n\t\tisp1760_udc_write(udc, DC_BUFLEN, req->packet_size);\n\n\t \n\tfor (i = req->packet_size; i > 2; i -= 4, ++buf)\n\t\tisp1760_udc_write_raw(udc, ISP176x_DC_DATAPORT, *buf);\n\tif (i > 0)\n\t\tisp1760_udc_write_raw16(udc, ISP176x_DC_DATAPORT, *(u16 *)buf);\n\n\tif (ep->addr == 0)\n\t\tisp1760_udc_set(udc, DC_DSEN);\n\tif (!req->packet_size)\n\t\tisp1760_udc_set(udc, DC_VENDP);\n}\n\nstatic void isp1760_ep_rx_ready(struct isp1760_ep *ep)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tstruct isp1760_request *req;\n\tbool complete;\n\n\tspin_lock(&udc->lock);\n\n\tif (ep->addr == 0 && udc->ep0_state != ISP1760_CTRL_DATA_OUT) {\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"%s: invalid ep0 state %u\\n\", __func__,\n\t\t\tudc->ep0_state);\n\t\treturn;\n\t}\n\n\tif (ep->addr != 0 && !ep->desc) {\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"%s: ep%02x is disabled\\n\", __func__,\n\t\t\tep->addr);\n\t\treturn;\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\tep->rx_pending = true;\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"%s: ep%02x (%p) has no request queued\\n\",\n\t\t\t__func__, ep->addr, ep);\n\t\treturn;\n\t}\n\n\treq = list_first_entry(&ep->queue, struct isp1760_request,\n\t\t\t       queue);\n\tcomplete = isp1760_udc_receive(ep, req);\n\n\tspin_unlock(&udc->lock);\n\n\tif (complete)\n\t\tisp1760_udc_request_complete(ep, req, 0);\n}\n\nstatic void isp1760_ep_tx_complete(struct isp1760_ep *ep)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\tstruct isp1760_request *complete = NULL;\n\tstruct isp1760_request *req;\n\tbool need_zlp;\n\n\tspin_lock(&udc->lock);\n\n\tif (ep->addr == 0 && udc->ep0_state != ISP1760_CTRL_DATA_IN) {\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"TX IRQ: invalid endpoint state %u\\n\",\n\t\t\tudc->ep0_state);\n\t\treturn;\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\t \n\t\tif (ep->addr == 0) {\n\t\t\tisp1760_udc_ctrl_send_status(ep, USB_DIR_IN);\n\t\t\tspin_unlock(&udc->lock);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"%s: ep%02x has no request queued\\n\",\n\t\t\t__func__, ep->addr);\n\t\treturn;\n\t}\n\n\treq = list_first_entry(&ep->queue, struct isp1760_request,\n\t\t\t       queue);\n\treq->req.actual += req->packet_size;\n\n\tneed_zlp = req->req.actual == req->req.length &&\n\t\t   !(req->req.length % ep->maxpacket) &&\n\t\t   req->packet_size && req->req.zero;\n\n\tdev_dbg(udc->isp->dev,\n\t\t\"TX IRQ: req %p actual/length %u/%u maxpacket %u packet size %u zero %u need zlp %u\\n\",\n\t\t req, req->req.actual, req->req.length, ep->maxpacket,\n\t\t req->packet_size, req->req.zero, need_zlp);\n\n\t \n\tif (req->req.actual == req->req.length && !need_zlp) {\n\t\tcomplete = req;\n\t\tlist_del(&req->queue);\n\n\t\tif (ep->addr == 0)\n\t\t\tisp1760_udc_ctrl_send_status(ep, USB_DIR_IN);\n\n\t\tif (!list_empty(&ep->queue))\n\t\t\treq = list_first_entry(&ep->queue,\n\t\t\t\t\t       struct isp1760_request, queue);\n\t\telse\n\t\t\treq = NULL;\n\t}\n\n\t \n\tif (req)\n\t\tisp1760_udc_transmit(ep, req);\n\n\tspin_unlock(&udc->lock);\n\n\tif (complete)\n\t\tisp1760_udc_request_complete(ep, complete, 0);\n}\n\nstatic int __isp1760_udc_set_halt(struct isp1760_ep *ep, bool halt)\n{\n\tstruct isp1760_udc *udc = ep->udc;\n\n\tdev_dbg(udc->isp->dev, \"%s: %s halt on ep%02x\\n\", __func__,\n\t\thalt ? \"set\" : \"clear\", ep->addr);\n\n\tif (ep->desc && usb_endpoint_xfer_isoc(ep->desc)) {\n\t\tdev_dbg(udc->isp->dev, \"%s: ep%02x is isochronous\\n\", __func__,\n\t\t\tep->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tisp1760_udc_select_ep(udc, ep);\n\n\tif (halt)\n\t\tisp1760_udc_set(udc, DC_STALL);\n\telse\n\t\tisp1760_udc_clear(udc, DC_STALL);\n\n\tif (ep->addr == 0) {\n\t\t \n\t\t__isp1760_udc_select_ep(udc, ep, USB_DIR_IN);\n\t\tif (halt)\n\t\t\tisp1760_udc_set(udc, DC_STALL);\n\t\telse\n\t\t\tisp1760_udc_clear(udc, DC_STALL);\n\t} else if (!halt) {\n\t\t \n\t\tisp1760_udc_clear(udc, DC_EPENABLE);\n\t\tisp1760_udc_set(udc, DC_EPENABLE);\n\n\t\t \n\t\tif ((ep->addr & USB_DIR_IN) && !list_empty(&ep->queue)) {\n\t\t\tstruct isp1760_request *req;\n\n\t\t\treq = list_first_entry(&ep->queue,\n\t\t\t\t\t       struct isp1760_request, queue);\n\t\t\tisp1760_udc_transmit(ep, req);\n\t\t}\n\t}\n\n\tep->halted = halt;\n\n\treturn 0;\n}\n\n \n\nstatic int isp1760_udc_get_status(struct isp1760_udc *udc,\n\t\t\t\t  const struct usb_ctrlrequest *req)\n{\n\tstruct isp1760_ep *ep;\n\tu16 status;\n\n\tif (req->wLength != cpu_to_le16(2) || req->wValue != cpu_to_le16(0))\n\t\treturn -EINVAL;\n\n\tswitch (req->bRequestType) {\n\tcase USB_DIR_IN | USB_RECIP_DEVICE:\n\t\tstatus = udc->devstatus;\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_RECIP_INTERFACE:\n\t\tstatus = 0;\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_RECIP_ENDPOINT:\n\t\tep = isp1760_udc_find_ep(udc, le16_to_cpu(req->wIndex));\n\t\tif (!ep)\n\t\t\treturn -EINVAL;\n\n\t\tstatus = 0;\n\t\tif (ep->halted)\n\t\t\tstatus |= 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tisp1760_udc_set(udc, DC_EPDIR);\n\tisp1760_udc_write(udc, DC_ENDPIDX, 1);\n\n\tisp1760_udc_write(udc, DC_BUFLEN, 2);\n\n\tisp1760_udc_write_raw16(udc, ISP176x_DC_DATAPORT, status);\n\n\tisp1760_udc_set(udc, DC_DSEN);\n\n\tdev_dbg(udc->isp->dev, \"%s: status 0x%04x\\n\", __func__, status);\n\n\treturn 0;\n}\n\nstatic int isp1760_udc_set_address(struct isp1760_udc *udc, u16 addr)\n{\n\tif (addr > 127) {\n\t\tdev_dbg(udc->isp->dev, \"invalid device address %u\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (udc->gadget.state != USB_STATE_DEFAULT &&\n\t    udc->gadget.state != USB_STATE_ADDRESS) {\n\t\tdev_dbg(udc->isp->dev, \"can't set address in state %u\\n\",\n\t\t\tudc->gadget.state);\n\t\treturn -EINVAL;\n\t}\n\n\tusb_gadget_set_state(&udc->gadget, addr ? USB_STATE_ADDRESS :\n\t\t\t     USB_STATE_DEFAULT);\n\n\tisp1760_udc_write(udc, DC_DEVADDR, addr);\n\tisp1760_udc_set(udc, DC_DEVEN);\n\n\tspin_lock(&udc->lock);\n\tisp1760_udc_ctrl_send_status(&udc->ep[0], USB_DIR_OUT);\n\tspin_unlock(&udc->lock);\n\n\treturn 0;\n}\n\nstatic bool isp1760_ep0_setup_standard(struct isp1760_udc *udc,\n\t\t\t\t       struct usb_ctrlrequest *req)\n{\n\tbool stall;\n\n\tswitch (req->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\treturn isp1760_udc_get_status(udc, req);\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tswitch (req->bRequestType) {\n\t\tcase USB_DIR_OUT | USB_RECIP_DEVICE: {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\n\t\tcase USB_DIR_OUT | USB_RECIP_ENDPOINT: {\n\t\t\tu16 index = le16_to_cpu(req->wIndex);\n\t\t\tstruct isp1760_ep *ep;\n\n\t\t\tif (req->wLength != cpu_to_le16(0) ||\n\t\t\t    req->wValue != cpu_to_le16(USB_ENDPOINT_HALT))\n\t\t\t\treturn true;\n\n\t\t\tep = isp1760_udc_find_ep(udc, index);\n\t\t\tif (!ep)\n\t\t\t\treturn true;\n\n\t\t\tspin_lock(&udc->lock);\n\n\t\t\t \n\t\t\tif (!ep->wedged)\n\t\t\t\tstall = __isp1760_udc_set_halt(ep, false);\n\t\t\telse\n\t\t\t\tstall = false;\n\n\t\t\tif (!stall)\n\t\t\t\tisp1760_udc_ctrl_send_status(&udc->ep[0],\n\t\t\t\t\t\t\t     USB_DIR_OUT);\n\n\t\t\tspin_unlock(&udc->lock);\n\t\t\treturn stall;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_SET_FEATURE:\n\t\tswitch (req->bRequestType) {\n\t\tcase USB_DIR_OUT | USB_RECIP_DEVICE: {\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\n\t\tcase USB_DIR_OUT | USB_RECIP_ENDPOINT: {\n\t\t\tu16 index = le16_to_cpu(req->wIndex);\n\t\t\tstruct isp1760_ep *ep;\n\n\t\t\tif (req->wLength != cpu_to_le16(0) ||\n\t\t\t    req->wValue != cpu_to_le16(USB_ENDPOINT_HALT))\n\t\t\t\treturn true;\n\n\t\t\tep = isp1760_udc_find_ep(udc, index);\n\t\t\tif (!ep)\n\t\t\t\treturn true;\n\n\t\t\tspin_lock(&udc->lock);\n\n\t\t\tstall = __isp1760_udc_set_halt(ep, true);\n\t\t\tif (!stall)\n\t\t\t\tisp1760_udc_ctrl_send_status(&udc->ep[0],\n\t\t\t\t\t\t\t     USB_DIR_OUT);\n\n\t\t\tspin_unlock(&udc->lock);\n\t\t\treturn stall;\n\t\t}\n\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\n\t\t\treturn true;\n\n\t\treturn isp1760_udc_set_address(udc, le16_to_cpu(req->wValue));\n\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (req->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\n\t\t\treturn true;\n\n\t\tif (udc->gadget.state != USB_STATE_ADDRESS &&\n\t\t    udc->gadget.state != USB_STATE_CONFIGURED)\n\t\t\treturn true;\n\n\t\tstall = udc->driver->setup(&udc->gadget, req) < 0;\n\t\tif (stall)\n\t\t\treturn true;\n\n\t\tusb_gadget_set_state(&udc->gadget, req->wValue ?\n\t\t\t\t     USB_STATE_CONFIGURED : USB_STATE_ADDRESS);\n\n\t\t \n\t\treturn false;\n\n\tdefault:\n\t\treturn udc->driver->setup(&udc->gadget, req) < 0;\n\t}\n}\n\nstatic void isp1760_ep0_setup(struct isp1760_udc *udc)\n{\n\tunion {\n\t\tstruct usb_ctrlrequest r;\n\t\tu32 data[2];\n\t} req;\n\tunsigned int count;\n\tbool stall = false;\n\n\tspin_lock(&udc->lock);\n\n\tisp1760_udc_set(udc, DC_EP0SETUP);\n\n\tcount = isp1760_udc_read(udc, DC_BUFLEN);\n\tif (count != sizeof(req)) {\n\t\tspin_unlock(&udc->lock);\n\n\t\tdev_err(udc->isp->dev, \"invalid length %u for setup packet\\n\",\n\t\t\tcount);\n\n\t\tisp1760_udc_ctrl_send_stall(&udc->ep[0]);\n\t\treturn;\n\t}\n\n\treq.data[0] = isp1760_udc_read_raw(udc, ISP176x_DC_DATAPORT);\n\treq.data[1] = isp1760_udc_read_raw(udc, ISP176x_DC_DATAPORT);\n\n\tif (udc->ep0_state != ISP1760_CTRL_SETUP) {\n\t\tspin_unlock(&udc->lock);\n\t\tdev_dbg(udc->isp->dev, \"unexpected SETUP packet\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (!req.r.wLength)\n\t\tudc->ep0_state = ISP1760_CTRL_STATUS;\n\telse if (req.r.bRequestType & USB_DIR_IN)\n\t\tudc->ep0_state = ISP1760_CTRL_DATA_IN;\n\telse\n\t\tudc->ep0_state = ISP1760_CTRL_DATA_OUT;\n\n\tudc->ep0_dir = req.r.bRequestType & USB_DIR_IN;\n\tudc->ep0_length = le16_to_cpu(req.r.wLength);\n\n\tspin_unlock(&udc->lock);\n\n\tdev_dbg(udc->isp->dev,\n\t\t\"%s: bRequestType 0x%02x bRequest 0x%02x wValue 0x%04x wIndex 0x%04x wLength 0x%04x\\n\",\n\t\t__func__, req.r.bRequestType, req.r.bRequest,\n\t\tle16_to_cpu(req.r.wValue), le16_to_cpu(req.r.wIndex),\n\t\tle16_to_cpu(req.r.wLength));\n\n\tif ((req.r.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tstall = isp1760_ep0_setup_standard(udc, &req.r);\n\telse\n\t\tstall = udc->driver->setup(&udc->gadget, &req.r) < 0;\n\n\tif (stall)\n\t\tisp1760_udc_ctrl_send_stall(&udc->ep[0]);\n}\n\n \n\nstatic int isp1760_ep_enable(struct usb_ep *ep,\n\t\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tstruct isp1760_udc *udc = uep->udc;\n\tunsigned long flags;\n\tunsigned int type;\n\n\tdev_dbg(uep->udc->isp->dev, \"%s\\n\", __func__);\n\n\t \n\tif (desc->bDescriptorType != USB_DT_ENDPOINT ||\n\t    desc->bEndpointAddress == 0 ||\n\t    desc->bEndpointAddress != uep->addr ||\n\t    le16_to_cpu(desc->wMaxPacketSize) > ep->maxpacket) {\n\t\tdev_dbg(udc->isp->dev,\n\t\t\t\"%s: invalid descriptor type %u addr %02x ep addr %02x max packet size %u/%u\\n\",\n\t\t\t__func__, desc->bDescriptorType,\n\t\t\tdesc->bEndpointAddress, uep->addr,\n\t\t\tle16_to_cpu(desc->wMaxPacketSize), ep->maxpacket);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ttype = ISP176x_DC_ENDPTYP_ISOC;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\ttype = ISP176x_DC_ENDPTYP_BULK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttype = ISP176x_DC_ENDPTYP_INTERRUPT;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tdefault:\n\t\tdev_dbg(udc->isp->dev, \"%s: control endpoints unsupported\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tuep->desc = desc;\n\tuep->maxpacket = le16_to_cpu(desc->wMaxPacketSize);\n\tuep->rx_pending = false;\n\tuep->halted = false;\n\tuep->wedged = false;\n\n\tisp1760_udc_select_ep(udc, uep);\n\n\tisp1760_udc_write(udc, DC_FFOSZ, uep->maxpacket);\n\tisp1760_udc_write(udc, DC_BUFLEN, uep->maxpacket);\n\n\tisp1760_udc_write(udc, DC_ENDPTYP, type);\n\tisp1760_udc_set(udc, DC_EPENABLE);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int isp1760_ep_disable(struct usb_ep *ep)\n{\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tstruct isp1760_udc *udc = uep->udc;\n\tstruct isp1760_request *req, *nreq;\n\tLIST_HEAD(req_list);\n\tunsigned long flags;\n\n\tdev_dbg(udc->isp->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!uep->desc) {\n\t\tdev_dbg(udc->isp->dev, \"%s: endpoint not enabled\\n\", __func__);\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tuep->desc = NULL;\n\tuep->maxpacket = 0;\n\n\tisp1760_udc_select_ep(udc, uep);\n\tisp1760_udc_clear(udc, DC_EPENABLE);\n\tisp1760_udc_clear(udc, DC_ENDPTYP);\n\n\t \n\n\tlist_splice_init(&uep->queue, &req_list);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tlist_for_each_entry_safe(req, nreq, &req_list, queue) {\n\t\tlist_del(&req->queue);\n\t\tisp1760_udc_request_complete(uep, req, -ESHUTDOWN);\n\t}\n\n\treturn 0;\n}\n\nstatic struct usb_request *isp1760_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct isp1760_request *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treturn &req->req;\n}\n\nstatic void isp1760_ep_free_request(struct usb_ep *ep, struct usb_request *_req)\n{\n\tstruct isp1760_request *req = req_to_udc_req(_req);\n\n\tkfree(req);\n}\n\nstatic int isp1760_ep_queue(struct usb_ep *ep, struct usb_request *_req,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct isp1760_request *req = req_to_udc_req(_req);\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tstruct isp1760_udc *udc = uep->udc;\n\tbool complete = false;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tdev_dbg(udc->isp->dev,\n\t\t\"%s: req %p (%u bytes%s) ep %p(0x%02x)\\n\", __func__, _req,\n\t\t_req->length, _req->zero ? \" (zlp)\" : \"\", uep, uep->addr);\n\n\treq->ep = uep;\n\n\tif (uep->addr == 0) {\n\t\tif (_req->length != udc->ep0_length &&\n\t\t    udc->ep0_state != ISP1760_CTRL_DATA_IN) {\n\t\t\tdev_dbg(udc->isp->dev,\n\t\t\t\t\"%s: invalid length %u for req %p\\n\",\n\t\t\t\t__func__, _req->length, req);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tswitch (udc->ep0_state) {\n\t\tcase ISP1760_CTRL_DATA_IN:\n\t\t\tdev_dbg(udc->isp->dev, \"%s: transmitting req %p\\n\",\n\t\t\t\t__func__, req);\n\n\t\t\tlist_add_tail(&req->queue, &uep->queue);\n\t\t\tisp1760_udc_transmit(uep, req);\n\t\t\tbreak;\n\n\t\tcase ISP1760_CTRL_DATA_OUT:\n\t\t\tlist_add_tail(&req->queue, &uep->queue);\n\t\t\t__isp1760_udc_select_ep(udc, uep, USB_DIR_OUT);\n\t\t\tisp1760_udc_set(udc, DC_DSEN);\n\t\t\tbreak;\n\n\t\tcase ISP1760_CTRL_STATUS:\n\t\t\tcomplete = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(udc->isp->dev, \"%s: invalid ep0 state\\n\",\n\t\t\t\t__func__);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} else if (uep->desc) {\n\t\tbool empty = list_empty(&uep->queue);\n\n\t\tlist_add_tail(&req->queue, &uep->queue);\n\t\tif ((uep->addr & USB_DIR_IN) && !uep->halted && empty)\n\t\t\tisp1760_udc_transmit(uep, req);\n\t\telse if (!(uep->addr & USB_DIR_IN) && uep->rx_pending)\n\t\t\tcomplete = isp1760_udc_receive(uep, req);\n\t} else {\n\t\tdev_dbg(udc->isp->dev,\n\t\t\t\"%s: can't queue request to disabled ep%02x\\n\",\n\t\t\t__func__, uep->addr);\n\t\tret = -ESHUTDOWN;\n\t}\n\ndone:\n\tif (ret < 0)\n\t\treq->ep = NULL;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (complete)\n\t\tisp1760_udc_request_complete(uep, req, 0);\n\n\treturn ret;\n}\n\nstatic int isp1760_ep_dequeue(struct usb_ep *ep, struct usb_request *_req)\n{\n\tstruct isp1760_request *req = req_to_udc_req(_req);\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tstruct isp1760_udc *udc = uep->udc;\n\tunsigned long flags;\n\n\tdev_dbg(uep->udc->isp->dev, \"%s(ep%02x)\\n\", __func__, uep->addr);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (req->ep != uep)\n\t\treq = NULL;\n\telse\n\t\tlist_del(&req->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (!req)\n\t\treturn -EINVAL;\n\n\tisp1760_udc_request_complete(uep, req, -ECONNRESET);\n\treturn 0;\n}\n\nstatic int __isp1760_ep_set_halt(struct isp1760_ep *uep, bool stall, bool wedge)\n{\n\tstruct isp1760_udc *udc = uep->udc;\n\tint ret;\n\n\tif (!uep->addr) {\n\t\t \n\t\tif (WARN_ON(udc->ep0_state == ISP1760_CTRL_SETUP || !stall ||\n\t\t\t     wedge)) {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (uep->addr && !uep->desc) {\n\t\tdev_dbg(udc->isp->dev, \"%s: ep%02x is disabled\\n\", __func__,\n\t\t\tuep->addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (uep->addr & USB_DIR_IN) {\n\t\t \n\t\tif (!list_empty(&uep->queue)) {\n\t\t\tdev_dbg(udc->isp->dev,\n\t\t\t\t\"%s: ep%02x has request pending\\n\", __func__,\n\t\t\t\tuep->addr);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tret = __isp1760_udc_set_halt(uep, stall);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!uep->addr) {\n\t\t \n\t\tudc->ep0_state = ISP1760_CTRL_SETUP;\n\t\treturn 0;\n\t}\n\n\tif (wedge)\n\t\tuep->wedged = true;\n\telse if (!stall)\n\t\tuep->wedged = false;\n\n\treturn 0;\n}\n\nstatic int isp1760_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(uep->udc->isp->dev, \"%s: %s halt on ep%02x\\n\", __func__,\n\t\tvalue ? \"set\" : \"clear\", uep->addr);\n\n\tspin_lock_irqsave(&uep->udc->lock, flags);\n\tret = __isp1760_ep_set_halt(uep, value, false);\n\tspin_unlock_irqrestore(&uep->udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int isp1760_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tunsigned long flags;\n\tint ret;\n\n\tdev_dbg(uep->udc->isp->dev, \"%s: set wedge on ep%02x)\\n\", __func__,\n\t\tuep->addr);\n\n\tspin_lock_irqsave(&uep->udc->lock, flags);\n\tret = __isp1760_ep_set_halt(uep, true, true);\n\tspin_unlock_irqrestore(&uep->udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void isp1760_ep_fifo_flush(struct usb_ep *ep)\n{\n\tstruct isp1760_ep *uep = ep_to_udc_ep(ep);\n\tstruct isp1760_udc *udc = uep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tisp1760_udc_select_ep(udc, uep);\n\n\t \n\tisp1760_udc_set(udc, DC_CLBUF);\n\tisp1760_udc_set(udc, DC_CLBUF);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic const struct usb_ep_ops isp1760_ep_ops = {\n\t.enable = isp1760_ep_enable,\n\t.disable = isp1760_ep_disable,\n\t.alloc_request = isp1760_ep_alloc_request,\n\t.free_request = isp1760_ep_free_request,\n\t.queue = isp1760_ep_queue,\n\t.dequeue = isp1760_ep_dequeue,\n\t.set_halt = isp1760_ep_set_halt,\n\t.set_wedge = isp1760_ep_set_wedge,\n\t.fifo_flush = isp1760_ep_fifo_flush,\n};\n\n \n\n \nstatic void isp1760_udc_connect(struct isp1760_udc *udc)\n{\n\tusb_gadget_set_state(&udc->gadget, USB_STATE_POWERED);\n\tmod_timer(&udc->vbus_timer, jiffies + ISP1760_VBUS_POLL_INTERVAL);\n}\n\n \nstatic void isp1760_udc_disconnect(struct isp1760_udc *udc)\n{\n\tif (udc->gadget.state < USB_STATE_POWERED)\n\t\treturn;\n\n\tdev_dbg(udc->isp->dev, \"Device disconnected in state %u\\n\",\n\t\t udc->gadget.state);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tusb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);\n\n\tif (udc->driver->disconnect)\n\t\tudc->driver->disconnect(&udc->gadget);\n\n\tdel_timer(&udc->vbus_timer);\n\n\t \n}\n\nstatic void isp1760_udc_init_hw(struct isp1760_udc *udc)\n{\n\tu32 intconf = udc->is_isp1763 ? ISP1763_DC_INTCONF : ISP176x_DC_INTCONF;\n\tu32 intena = udc->is_isp1763 ? ISP1763_DC_INTENABLE :\n\t\t\t\t\t\tISP176x_DC_INTENABLE;\n\n\t \n\tisp1760_reg_write(udc->regs, intconf,\n\t\t\t  ISP176x_DC_CDBGMOD_ACK | ISP176x_DC_DDBGMODIN_ACK |\n\t\t\t  ISP176x_DC_DDBGMODOUT_ACK);\n\n\tisp1760_reg_write(udc->regs, intena, DC_IEPRXTX(7) |\n\t\t\t  DC_IEPRXTX(6) | DC_IEPRXTX(5) | DC_IEPRXTX(4) |\n\t\t\t  DC_IEPRXTX(3) | DC_IEPRXTX(2) | DC_IEPRXTX(1) |\n\t\t\t  DC_IEPRXTX(0) | ISP176x_DC_IEP0SETUP |\n\t\t\t  ISP176x_DC_IEVBUS | ISP176x_DC_IERESM |\n\t\t\t  ISP176x_DC_IESUSP | ISP176x_DC_IEHS_STA |\n\t\t\t  ISP176x_DC_IEBRST);\n\n\tif (udc->connected)\n\t\tisp1760_set_pullup(udc->isp, true);\n\n\tisp1760_udc_set(udc, DC_DEVEN);\n}\n\nstatic void isp1760_udc_reset(struct isp1760_udc *udc)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tisp1760_udc_init_hw(udc);\n\n\tudc->ep0_state = ISP1760_CTRL_SETUP;\n\tudc->gadget.speed = USB_SPEED_FULL;\n\n\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic void isp1760_udc_suspend(struct isp1760_udc *udc)\n{\n\tif (udc->gadget.state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tif (udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n}\n\nstatic void isp1760_udc_resume(struct isp1760_udc *udc)\n{\n\tif (udc->gadget.state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tif (udc->driver->resume)\n\t\tudc->driver->resume(&udc->gadget);\n}\n\n \n\nstatic int isp1760_udc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\n\treturn isp1760_udc_read(udc, DC_FRAMENUM);\n}\n\nstatic int isp1760_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\n\tdev_dbg(udc->isp->dev, \"%s\\n\", __func__);\n\treturn -ENOTSUPP;\n}\n\nstatic int isp1760_udc_set_selfpowered(struct usb_gadget *gadget,\n\t\t\t\t       int is_selfpowered)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\n\tif (is_selfpowered)\n\t\tudc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\n\telse\n\t\tudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\n\treturn 0;\n}\n\nstatic int isp1760_udc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\n\tisp1760_set_pullup(udc->isp, is_on);\n\tudc->connected = is_on;\n\n\treturn 0;\n}\n\nstatic int isp1760_udc_start(struct usb_gadget *gadget,\n\t\t\t     struct usb_gadget_driver *driver)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\tunsigned long flags;\n\n\t \n\tif (driver->max_speed < USB_SPEED_FULL) {\n\t\tdev_err(udc->isp->dev, \"Invalid gadget driver\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (udc->driver) {\n\t\tdev_err(udc->isp->dev, \"UDC already has a gadget driver\\n\");\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tudc->driver = driver;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tdev_dbg(udc->isp->dev, \"starting UDC with driver %s\\n\",\n\t\tdriver->function);\n\n\tudc->devstatus = 0;\n\tudc->connected = true;\n\n\tusb_gadget_set_state(&udc->gadget, USB_STATE_ATTACHED);\n\n\t \n\tisp1760_udc_set(udc, DC_GLINTENA);\n\n\tisp1760_udc_init_hw(udc);\n\n\tdev_dbg(udc->isp->dev, \"UDC started with driver %s\\n\",\n\t\tdriver->function);\n\n\treturn 0;\n}\n\nstatic int isp1760_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct isp1760_udc *udc = gadget_to_udc(gadget);\n\tu32 mode_reg = udc->is_isp1763 ? ISP1763_DC_MODE : ISP176x_DC_MODE;\n\tunsigned long flags;\n\n\tdev_dbg(udc->isp->dev, \"%s\\n\", __func__);\n\n\tdel_timer_sync(&udc->vbus_timer);\n\n\tisp1760_reg_write(udc->regs, mode_reg, 0);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->driver = NULL;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops isp1760_udc_ops = {\n\t.get_frame = isp1760_udc_get_frame,\n\t.wakeup = isp1760_udc_wakeup,\n\t.set_selfpowered = isp1760_udc_set_selfpowered,\n\t.pullup = isp1760_udc_pullup,\n\t.udc_start = isp1760_udc_start,\n\t.udc_stop = isp1760_udc_stop,\n};\n\n \n\nstatic u32 isp1760_udc_irq_get_status(struct isp1760_udc *udc)\n{\n\tu32 status;\n\n\tif (udc->is_isp1763) {\n\t\tstatus = isp1760_reg_read(udc->regs, ISP1763_DC_INTERRUPT)\n\t\t\t& isp1760_reg_read(udc->regs, ISP1763_DC_INTENABLE);\n\t\tisp1760_reg_write(udc->regs, ISP1763_DC_INTERRUPT, status);\n\t} else {\n\t\tstatus = isp1760_reg_read(udc->regs, ISP176x_DC_INTERRUPT)\n\t\t\t& isp1760_reg_read(udc->regs, ISP176x_DC_INTENABLE);\n\t\tisp1760_reg_write(udc->regs, ISP176x_DC_INTERRUPT, status);\n\t}\n\n\treturn status;\n}\n\nstatic irqreturn_t isp1760_udc_irq(int irq, void *dev)\n{\n\tstruct isp1760_udc *udc = dev;\n\tunsigned int i;\n\tu32 status;\n\n\tstatus = isp1760_udc_irq_get_status(udc);\n\n\tif (status & ISP176x_DC_IEVBUS) {\n\t\tdev_dbg(udc->isp->dev, \"%s(VBUS)\\n\", __func__);\n\t\t \n\t\tspin_lock(&udc->lock);\n\t\tisp1760_udc_connect(udc);\n\t\tspin_unlock(&udc->lock);\n\t}\n\n\tif (status & ISP176x_DC_IEBRST) {\n\t\tdev_dbg(udc->isp->dev, \"%s(BRST)\\n\", __func__);\n\n\t\tisp1760_udc_reset(udc);\n\t}\n\n\tfor (i = 0; i <= 7; ++i) {\n\t\tstruct isp1760_ep *ep = &udc->ep[i*2];\n\n\t\tif (status & DC_IEPTX(i)) {\n\t\t\tdev_dbg(udc->isp->dev, \"%s(EPTX%u)\\n\", __func__, i);\n\t\t\tisp1760_ep_tx_complete(ep);\n\t\t}\n\n\t\tif (status & DC_IEPRX(i)) {\n\t\t\tdev_dbg(udc->isp->dev, \"%s(EPRX%u)\\n\", __func__, i);\n\t\t\tisp1760_ep_rx_ready(i ? ep - 1 : ep);\n\t\t}\n\t}\n\n\tif (status & ISP176x_DC_IEP0SETUP) {\n\t\tdev_dbg(udc->isp->dev, \"%s(EP0SETUP)\\n\", __func__);\n\n\t\tisp1760_ep0_setup(udc);\n\t}\n\n\tif (status & ISP176x_DC_IERESM) {\n\t\tdev_dbg(udc->isp->dev, \"%s(RESM)\\n\", __func__);\n\t\tisp1760_udc_resume(udc);\n\t}\n\n\tif (status & ISP176x_DC_IESUSP) {\n\t\tdev_dbg(udc->isp->dev, \"%s(SUSP)\\n\", __func__);\n\n\t\tspin_lock(&udc->lock);\n\t\tif (!isp1760_udc_is_set(udc, DC_VBUSSTAT))\n\t\t\tisp1760_udc_disconnect(udc);\n\t\telse\n\t\t\tisp1760_udc_suspend(udc);\n\t\tspin_unlock(&udc->lock);\n\t}\n\n\tif (status & ISP176x_DC_IEHS_STA) {\n\t\tdev_dbg(udc->isp->dev, \"%s(HS_STA)\\n\", __func__);\n\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t}\n\n\treturn status ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic void isp1760_udc_vbus_poll(struct timer_list *t)\n{\n\tstruct isp1760_udc *udc = from_timer(udc, t, vbus_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!(isp1760_udc_is_set(udc, DC_VBUSSTAT)))\n\t\tisp1760_udc_disconnect(udc);\n\telse if (udc->gadget.state >= USB_STATE_POWERED)\n\t\tmod_timer(&udc->vbus_timer,\n\t\t\t  jiffies + ISP1760_VBUS_POLL_INTERVAL);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\n \n\nstatic void isp1760_udc_init_eps(struct isp1760_udc *udc)\n{\n\tunsigned int i;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tfor (i = 0; i < ARRAY_SIZE(udc->ep); ++i) {\n\t\tstruct isp1760_ep *ep = &udc->ep[i];\n\t\tunsigned int ep_num = (i + 1) / 2;\n\t\tbool is_in = !(i & 1);\n\n\t\tep->udc = udc;\n\n\t\tINIT_LIST_HEAD(&ep->queue);\n\n\t\tep->addr = (ep_num && is_in ? USB_DIR_IN : USB_DIR_OUT)\n\t\t\t | ep_num;\n\t\tep->desc = NULL;\n\n\t\tsprintf(ep->name, \"ep%u%s\", ep_num,\n\t\t\tep_num ? (is_in ? \"in\" : \"out\") : \"\");\n\n\t\tep->ep.ops = &isp1760_ep_ops;\n\t\tep->ep.name = ep->name;\n\n\t\t \n\t\tif (ep_num == 0) {\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep, 64);\n\t\t\tep->ep.caps.type_control = true;\n\t\t\tep->ep.caps.dir_in = true;\n\t\t\tep->ep.caps.dir_out = true;\n\t\t\tep->maxpacket = 64;\n\t\t\tudc->gadget.ep0 = &ep->ep;\n\t\t} else {\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep, 512);\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t\tep->maxpacket = 0;\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\t}\n\n\t\tif (is_in)\n\t\t\tep->ep.caps.dir_in = true;\n\t\telse\n\t\t\tep->ep.caps.dir_out = true;\n\t}\n}\n\nstatic int isp1760_udc_init(struct isp1760_udc *udc)\n{\n\tu32 mode_reg = udc->is_isp1763 ? ISP1763_DC_MODE : ISP176x_DC_MODE;\n\tu16 scratch;\n\tu32 chipid;\n\n\t \n\tisp1760_udc_write(udc, DC_SCRATCH, 0xbabe);\n\tchipid = isp1760_udc_read(udc, DC_CHIP_ID_HIGH) << 16;\n\tchipid |= isp1760_udc_read(udc, DC_CHIP_ID_LOW);\n\tscratch = isp1760_udc_read(udc, DC_SCRATCH);\n\n\tif (scratch != 0xbabe) {\n\t\tdev_err(udc->isp->dev,\n\t\t\t\"udc: scratch test failed (0x%04x/0x%08x)\\n\",\n\t\t\tscratch, chipid);\n\t\treturn -ENODEV;\n\t}\n\n\tif (chipid != 0x00011582 && chipid != 0x00158210 &&\n\t    chipid != 0x00176320) {\n\t\tdev_err(udc->isp->dev, \"udc: invalid chip ID 0x%08x\\n\", chipid);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tisp1760_udc_set(udc, DC_SFRESET);\n\tusleep_range(10000, 11000);\n\tisp1760_reg_write(udc->regs, mode_reg, 0);\n\tusleep_range(10000, 11000);\n\n\treturn 0;\n}\n\nint isp1760_udc_register(struct isp1760_device *isp, int irq,\n\t\t\t unsigned long irqflags)\n{\n\tstruct isp1760_udc *udc = &isp->udc;\n\tint ret;\n\n\tudc->irq = -1;\n\tudc->isp = isp;\n\n\tspin_lock_init(&udc->lock);\n\ttimer_setup(&udc->vbus_timer, isp1760_udc_vbus_poll, 0);\n\n\tret = isp1760_udc_init(udc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tudc->irqname = kasprintf(GFP_KERNEL, \"%s (udc)\", dev_name(isp->dev));\n\tif (!udc->irqname)\n\t\treturn -ENOMEM;\n\n\tret = request_irq(irq, isp1760_udc_irq, IRQF_SHARED | irqflags,\n\t\t\t  udc->irqname, udc);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tudc->irq = irq;\n\n\t \n\tudc->gadget.ops = &isp1760_udc_ops;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.name = \"isp1761_udc\";\n\n\tisp1760_udc_init_eps(udc);\n\n\tret = usb_add_gadget_udc(isp->dev, &udc->gadget);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tif (udc->irq >= 0)\n\t\tfree_irq(udc->irq, udc);\n\tkfree(udc->irqname);\n\n\treturn ret;\n}\n\nvoid isp1760_udc_unregister(struct isp1760_device *isp)\n{\n\tstruct isp1760_udc *udc = &isp->udc;\n\n\tif (!udc->isp)\n\t\treturn;\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tfree_irq(udc->irq, udc);\n\tkfree(udc->irqname);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}