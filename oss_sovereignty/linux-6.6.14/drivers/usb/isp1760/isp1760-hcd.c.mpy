{
  "module_name": "isp1760-hcd.c",
  "hash_id": "6f152e30f9528b244772d3fc09986e315d5f038e038f037e97ce507685f0aa2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/isp1760/isp1760-hcd.c",
  "human_readable_source": "\n \n#include <linux/gpio/consumer.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <asm/unaligned.h>\n#include <asm/cacheflush.h>\n\n#include \"isp1760-core.h\"\n#include \"isp1760-hcd.h\"\n#include \"isp1760-regs.h\"\n\nstatic struct kmem_cache *qtd_cachep;\nstatic struct kmem_cache *qh_cachep;\nstatic struct kmem_cache *urb_listitem_cachep;\n\ntypedef void (packet_enqueue)(struct usb_hcd *hcd, struct isp1760_qh *qh,\n\t\tstruct isp1760_qtd *qtd);\n\nstatic inline struct isp1760_hcd *hcd_to_priv(struct usb_hcd *hcd)\n{\n\treturn *(struct isp1760_hcd **)hcd->hcd_priv;\n}\n\n#define dw_to_le32(x)\t(cpu_to_le32((__force u32)x))\n#define le32_to_dw(x)\t((__force __dw)(le32_to_cpu(x)))\n\n \n#define DELETE_URB\t\t(0x0008)\n#define NO_TRANSFER_ACTIVE\t(0xffffffff)\n\n \ntypedef __u32 __bitwise __dw;\nstruct ptd {\n\t__dw dw0;\n\t__dw dw1;\n\t__dw dw2;\n\t__dw dw3;\n\t__dw dw4;\n\t__dw dw5;\n\t__dw dw6;\n\t__dw dw7;\n};\n\nstruct ptd_le32 {\n\t__le32 dw0;\n\t__le32 dw1;\n\t__le32 dw2;\n\t__le32 dw3;\n\t__le32 dw4;\n\t__le32 dw5;\n\t__le32 dw6;\n\t__le32 dw7;\n};\n\n#define PTD_OFFSET\t\t0x0400\n#define ISO_PTD_OFFSET\t\t0x0400\n#define INT_PTD_OFFSET\t\t0x0800\n#define ATL_PTD_OFFSET\t\t0x0c00\n#define PAYLOAD_OFFSET\t\t0x1000\n\n#define ISP_BANK_0\t\t0x00\n#define ISP_BANK_1\t\t0x01\n#define ISP_BANK_2\t\t0x02\n#define ISP_BANK_3\t\t0x03\n\n#define TO_DW(x)\t((__force __dw)x)\n#define TO_U32(x)\t((__force u32)x)\n\n  \n  \n#define DW0_VALID_BIT\t\t\tTO_DW(1)\n#define FROM_DW0_VALID(x)\t\t(TO_U32(x) & 0x01)\n#define TO_DW0_LENGTH(x)\t\tTO_DW((((u32)x) << 3))\n#define TO_DW0_MAXPACKET(x)\t\tTO_DW((((u32)x) << 18))\n#define TO_DW0_MULTI(x)\t\t\tTO_DW((((u32)x) << 29))\n#define TO_DW0_ENDPOINT(x)\t\tTO_DW((((u32)x) << 31))\n \n#define TO_DW1_DEVICE_ADDR(x)\t\tTO_DW((((u32)x) << 3))\n#define TO_DW1_PID_TOKEN(x)\t\tTO_DW((((u32)x) << 10))\n#define DW1_TRANS_BULK\t\t\tTO_DW(((u32)2 << 12))\n#define DW1_TRANS_INT\t\t\tTO_DW(((u32)3 << 12))\n#define DW1_TRANS_SPLIT\t\t\tTO_DW(((u32)1 << 14))\n#define DW1_SE_USB_LOSPEED\t\tTO_DW(((u32)2 << 16))\n#define TO_DW1_PORT_NUM(x)\t\tTO_DW((((u32)x) << 18))\n#define TO_DW1_HUB_NUM(x)\t\tTO_DW((((u32)x) << 25))\n \n#define TO_DW2_DATA_START_ADDR(x)\tTO_DW((((u32)x) << 8))\n#define TO_DW2_RL(x)\t\t\tTO_DW(((x) << 25))\n#define FROM_DW2_RL(x)\t\t\t((TO_U32(x) >> 25) & 0xf)\n \n#define FROM_DW3_NRBYTESTRANSFERRED(x)\t\tTO_U32((x) & 0x3fff)\n#define FROM_DW3_SCS_NRBYTESTRANSFERRED(x)\tTO_U32((x) & 0x07ff)\n#define TO_DW3_NAKCOUNT(x)\t\tTO_DW(((x) << 19))\n#define FROM_DW3_NAKCOUNT(x)\t\t((TO_U32(x) >> 19) & 0xf)\n#define TO_DW3_CERR(x)\t\t\tTO_DW(((x) << 23))\n#define FROM_DW3_CERR(x)\t\t((TO_U32(x) >> 23) & 0x3)\n#define TO_DW3_DATA_TOGGLE(x)\t\tTO_DW(((x) << 25))\n#define FROM_DW3_DATA_TOGGLE(x)\t\t((TO_U32(x) >> 25) & 0x1)\n#define TO_DW3_PING(x)\t\t\tTO_DW(((x) << 26))\n#define FROM_DW3_PING(x)\t\t((TO_U32(x) >> 26) & 0x1)\n#define DW3_ERROR_BIT\t\t\tTO_DW((1 << 28))\n#define DW3_BABBLE_BIT\t\t\tTO_DW((1 << 29))\n#define DW3_HALT_BIT\t\t\tTO_DW((1 << 30))\n#define DW3_ACTIVE_BIT\t\t\tTO_DW((1 << 31))\n#define FROM_DW3_ACTIVE(x)\t\t((TO_U32(x) >> 31) & 0x01)\n\n#define INT_UNDERRUN\t\t\t(1 << 2)\n#define INT_BABBLE\t\t\t(1 << 1)\n#define INT_EXACT\t\t\t(1 << 0)\n\n#define SETUP_PID\t(2)\n#define IN_PID\t\t(1)\n#define OUT_PID\t\t(0)\n\n \n#define RL_COUNTER\t(0)\n#define NAK_COUNTER\t(0)\n#define ERR_COUNTER\t(3)\n\nstruct isp1760_qtd {\n\tu8 packet_type;\n\tvoid *data_buffer;\n\tu32 payload_addr;\n\n\t \n\tstruct list_head qtd_list;\n\tstruct urb *urb;\n\tsize_t length;\n\tsize_t actual_length;\n\n\t \n\t \n\t \n\t \n\t \n#define QTD_ENQUEUED\t\t0\n#define QTD_PAYLOAD_ALLOC\t1\n#define QTD_XFER_STARTED\t2\n#define QTD_XFER_COMPLETE\t3\n#define QTD_RETIRE\t\t4\n\tu32 status;\n};\n\n \nstruct isp1760_qh {\n\tstruct list_head qh_list;\n\tstruct list_head qtd_list;\n\tu32 toggle;\n\tu32 ping;\n\tint slot;\n\tint tt_buffer_dirty;\t \n};\n\nstruct urb_listitem {\n\tstruct list_head urb_list;\n\tstruct urb *urb;\n};\n\nstatic const u32 isp176x_hc_portsc1_fields[] = {\n\t[PORT_OWNER]\t\t= BIT(13),\n\t[PORT_POWER]\t\t= BIT(12),\n\t[PORT_LSTATUS]\t\t= BIT(10),\n\t[PORT_RESET]\t\t= BIT(8),\n\t[PORT_SUSPEND]\t\t= BIT(7),\n\t[PORT_RESUME]\t\t= BIT(6),\n\t[PORT_PE]\t\t= BIT(2),\n\t[PORT_CSC]\t\t= BIT(1),\n\t[PORT_CONNECT]\t\t= BIT(0),\n};\n\n \nstatic u32 isp1760_hcd_read(struct usb_hcd *hcd, u32 field)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\treturn isp1760_field_read(priv->fields, field);\n}\n\n \nstatic void isp1760_hcd_portsc1_set_clear(struct isp1760_hcd *priv, u32 field,\n\t\t\t\t\t  u32 val)\n{\n\tu32 bit = isp176x_hc_portsc1_fields[field];\n\tu16 portsc1_reg = priv->is_isp1763 ? ISP1763_HC_PORTSC1 :\n\t\tISP176x_HC_PORTSC1;\n\tu32 port_status = readl(priv->base + portsc1_reg);\n\n\tif (val)\n\t\twritel(port_status | bit, priv->base + portsc1_reg);\n\telse\n\t\twritel(port_status & ~bit, priv->base + portsc1_reg);\n}\n\nstatic void isp1760_hcd_write(struct usb_hcd *hcd, u32 field, u32 val)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (unlikely((field >= PORT_OWNER && field <= PORT_CONNECT)))\n\t\treturn isp1760_hcd_portsc1_set_clear(priv, field, val);\n\n\tisp1760_field_write(priv->fields, field, val);\n}\n\nstatic void isp1760_hcd_set(struct usb_hcd *hcd, u32 field)\n{\n\tisp1760_hcd_write(hcd, field, 0xFFFFFFFF);\n}\n\nstatic void isp1760_hcd_clear(struct usb_hcd *hcd, u32 field)\n{\n\tisp1760_hcd_write(hcd, field, 0);\n}\n\nstatic int isp1760_hcd_set_and_wait(struct usb_hcd *hcd, u32 field,\n\t\t\t\t    u32 timeout_us)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 val;\n\n\tisp1760_hcd_set(hcd, field);\n\n\treturn regmap_field_read_poll_timeout(priv->fields[field], val,\n\t\t\t\t\t      val, 0, timeout_us);\n}\n\nstatic int isp1760_hcd_set_and_wait_swap(struct usb_hcd *hcd, u32 field,\n\t\t\t\t\t u32 timeout_us)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 val;\n\n\tisp1760_hcd_set(hcd, field);\n\n\treturn regmap_field_read_poll_timeout(priv->fields[field], val,\n\t\t\t\t\t      !val, 0, timeout_us);\n}\n\nstatic int isp1760_hcd_clear_and_wait(struct usb_hcd *hcd, u32 field,\n\t\t\t\t      u32 timeout_us)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 val;\n\n\tisp1760_hcd_clear(hcd, field);\n\n\treturn regmap_field_read_poll_timeout(priv->fields[field], val,\n\t\t\t\t\t      !val, 0, timeout_us);\n}\n\nstatic bool isp1760_hcd_is_set(struct usb_hcd *hcd, u32 field)\n{\n\treturn !!isp1760_hcd_read(hcd, field);\n}\n\nstatic bool isp1760_hcd_ppc_is_set(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (priv->is_isp1763)\n\t\treturn true;\n\n\treturn isp1760_hcd_is_set(hcd, HCS_PPC);\n}\n\nstatic u32 isp1760_hcd_n_ports(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (priv->is_isp1763)\n\t\treturn 1;\n\n\treturn isp1760_hcd_read(hcd, HCS_N_PORTS);\n}\n\n \nstatic void bank_reads8(void __iomem *src_base, u32 src_offset, u32 bank_addr,\n\t\t\t\t\t\t\t__u32 *dst, u32 bytes)\n{\n\t__u32 __iomem *src;\n\tu32 val;\n\t__u8 *src_byteptr;\n\t__u8 *dst_byteptr;\n\n\tsrc = src_base + (bank_addr | src_offset);\n\n\tif (src_offset < PAYLOAD_OFFSET) {\n\t\twhile (bytes >= 4) {\n\t\t\t*dst = readl_relaxed(src);\n\t\t\tbytes -= 4;\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\t} else {\n\t\twhile (bytes >= 4) {\n\t\t\t*dst = __raw_readl(src);\n\t\t\tbytes -= 4;\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\treturn;\n\n\t \n\tif (src_offset < PAYLOAD_OFFSET)\n\t\tval = readl_relaxed(src);\n\telse\n\t\tval = __raw_readl(src);\n\n\tdst_byteptr = (void *) dst;\n\tsrc_byteptr = (void *) &val;\n\twhile (bytes > 0) {\n\t\t*dst_byteptr = *src_byteptr;\n\t\tdst_byteptr++;\n\t\tsrc_byteptr++;\n\t\tbytes--;\n\t}\n}\n\nstatic void isp1760_mem_read(struct usb_hcd *hcd, u32 src_offset, void *dst,\n\t\t\t     u32 bytes)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tisp1760_reg_write(priv->regs, ISP176x_HC_MEMORY, src_offset);\n\tndelay(100);\n\n\tbank_reads8(priv->base, src_offset, ISP_BANK_0, dst, bytes);\n}\n\n \nstatic void isp1763_mem_read(struct usb_hcd *hcd, u16 srcaddr,\n\t\t\t     u16 *dstptr, u32 bytes)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\t \n\tisp1760_reg_write(priv->regs, ISP1763_HC_MEMORY, srcaddr);\n\tndelay(100);  \n\n\t \n\twhile (bytes >= 2) {\n\t\t*dstptr = __raw_readw(priv->base + ISP1763_HC_DATA);\n\t\tbytes -= 2;\n\t\tdstptr++;\n\t}\n\n\t \n\tif (bytes <= 0)\n\t\treturn;\n\n\t*((u8 *)dstptr) = (u8)(readw(priv->base + ISP1763_HC_DATA) & 0xFF);\n}\n\nstatic void mem_read(struct usb_hcd *hcd, u32 src_offset, __u32 *dst,\n\t\t     u32 bytes)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (!priv->is_isp1763)\n\t\treturn isp1760_mem_read(hcd, src_offset, (u16 *)dst, bytes);\n\n\tisp1763_mem_read(hcd, (u16)src_offset, (u16 *)dst, bytes);\n}\n\nstatic void isp1760_mem_write(void __iomem *dst_base, u32 dst_offset,\n\t\t\t      __u32 const *src, u32 bytes)\n{\n\t__u32 __iomem *dst;\n\n\tdst = dst_base + dst_offset;\n\n\tif (dst_offset < PAYLOAD_OFFSET) {\n\t\twhile (bytes >= 4) {\n\t\t\twritel_relaxed(*src, dst);\n\t\t\tbytes -= 4;\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\t} else {\n\t\twhile (bytes >= 4) {\n\t\t\t__raw_writel(*src, dst);\n\t\t\tbytes -= 4;\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\t}\n\n\tif (!bytes)\n\t\treturn;\n\t \n\n\tif (dst_offset < PAYLOAD_OFFSET)\n\t\twritel_relaxed(*src, dst);\n\telse\n\t\t__raw_writel(*src, dst);\n}\n\nstatic void isp1763_mem_write(struct usb_hcd *hcd, u16 dstaddr, u16 *src,\n\t\t\t      u32 bytes)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\t \n\tisp1760_reg_write(priv->regs, ISP1763_HC_MEMORY, dstaddr);\n\tndelay(100);  \n\n\twhile (bytes >= 2) {\n\t\t \n\t\t__raw_writew(*src, priv->base + ISP1763_HC_DATA);\n\t\tbytes -= 2;\n\t\tsrc++;\n\t}\n\n\t \n\tif (bytes <= 0)\n\t\treturn;\n\n\t \n\twritew(*((u8 *)src), priv->base + ISP1763_HC_DATA);\n}\n\nstatic void mem_write(struct usb_hcd *hcd, u32 dst_offset, __u32 *src,\n\t\t      u32 bytes)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (!priv->is_isp1763)\n\t\treturn isp1760_mem_write(priv->base, dst_offset, src, bytes);\n\n\tisp1763_mem_write(hcd, dst_offset, (u16 *)src, bytes);\n}\n\n \nstatic void isp1760_ptd_read(struct usb_hcd *hcd, u32 ptd_offset, u32 slot,\n\t\t\t     struct ptd *ptd)\n{\n\tu16 src_offset = ptd_offset + slot * sizeof(*ptd);\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tisp1760_reg_write(priv->regs, ISP176x_HC_MEMORY, src_offset);\n\tndelay(90);\n\n\tbank_reads8(priv->base, src_offset, ISP_BANK_0, (void *)ptd,\n\t\t    sizeof(*ptd));\n}\n\nstatic void isp1763_ptd_read(struct usb_hcd *hcd, u32 ptd_offset, u32 slot,\n\t\t\t     struct ptd *ptd)\n{\n\tu16 src_offset = ptd_offset + slot * sizeof(*ptd);\n\tstruct ptd_le32 le32_ptd;\n\n\tisp1763_mem_read(hcd, src_offset, (u16 *)&le32_ptd, sizeof(le32_ptd));\n\t \n\tptd->dw0 = le32_to_dw(le32_ptd.dw0);\n\tptd->dw1 = le32_to_dw(le32_ptd.dw1);\n\tptd->dw2 = le32_to_dw(le32_ptd.dw2);\n\tptd->dw3 = le32_to_dw(le32_ptd.dw3);\n\tptd->dw4 = le32_to_dw(le32_ptd.dw4);\n\tptd->dw5 = le32_to_dw(le32_ptd.dw5);\n\tptd->dw6 = le32_to_dw(le32_ptd.dw6);\n\tptd->dw7 = le32_to_dw(le32_ptd.dw7);\n}\n\nstatic void ptd_read(struct usb_hcd *hcd, u32 ptd_offset, u32 slot,\n\t\t     struct ptd *ptd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (!priv->is_isp1763)\n\t\treturn isp1760_ptd_read(hcd, ptd_offset, slot, ptd);\n\n\tisp1763_ptd_read(hcd, ptd_offset, slot, ptd);\n}\n\nstatic void isp1763_ptd_write(struct usb_hcd *hcd, u32 ptd_offset, u32 slot,\n\t\t\t      struct ptd *cpu_ptd)\n{\n\tu16 dst_offset = ptd_offset + slot * sizeof(*cpu_ptd);\n\tstruct ptd_le32 ptd;\n\n\tptd.dw0 = dw_to_le32(cpu_ptd->dw0);\n\tptd.dw1 = dw_to_le32(cpu_ptd->dw1);\n\tptd.dw2 = dw_to_le32(cpu_ptd->dw2);\n\tptd.dw3 = dw_to_le32(cpu_ptd->dw3);\n\tptd.dw4 = dw_to_le32(cpu_ptd->dw4);\n\tptd.dw5 = dw_to_le32(cpu_ptd->dw5);\n\tptd.dw6 = dw_to_le32(cpu_ptd->dw6);\n\tptd.dw7 = dw_to_le32(cpu_ptd->dw7);\n\n\tisp1763_mem_write(hcd, dst_offset,  (u16 *)&ptd.dw0,\n\t\t\t  8 * sizeof(ptd.dw0));\n}\n\nstatic void isp1760_ptd_write(void __iomem *base, u32 ptd_offset, u32 slot,\n\t\t\t      struct ptd *ptd)\n{\n\tu32 dst_offset = ptd_offset + slot * sizeof(*ptd);\n\n\t \n\tisp1760_mem_write(base, dst_offset + sizeof(ptd->dw0),\n\t\t\t  (__force u32 *)&ptd->dw1, 7 * sizeof(ptd->dw1));\n\twmb();\n\tisp1760_mem_write(base, dst_offset, (__force u32 *)&ptd->dw0,\n\t\t\t  sizeof(ptd->dw0));\n}\n\nstatic void ptd_write(struct usb_hcd *hcd, u32 ptd_offset, u32 slot,\n\t\t      struct ptd *ptd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (!priv->is_isp1763)\n\t\treturn isp1760_ptd_write(priv->base, ptd_offset, slot, ptd);\n\n\tisp1763_ptd_write(hcd, ptd_offset, slot, ptd);\n}\n\n \nstatic void init_memory(struct isp1760_hcd *priv)\n{\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint i, j, curr;\n\tu32 payload_addr;\n\n\tpayload_addr = PAYLOAD_OFFSET;\n\n\tfor (i = 0, curr = 0; i < ARRAY_SIZE(mem->blocks); i++, curr += j) {\n\t\tfor (j = 0; j < mem->blocks[i]; j++) {\n\t\t\tpriv->memory_pool[curr + j].start = payload_addr;\n\t\t\tpriv->memory_pool[curr + j].size = mem->blocks_size[i];\n\t\t\tpriv->memory_pool[curr + j].free = 1;\n\t\t\tpayload_addr += priv->memory_pool[curr + j].size;\n\t\t}\n\t}\n\n\tWARN_ON(payload_addr - priv->memory_pool[0].start >\n\t\tmem->payload_area_size);\n}\n\nstatic void alloc_mem(struct usb_hcd *hcd, struct isp1760_qtd *qtd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint i;\n\n\tWARN_ON(qtd->payload_addr);\n\n\tif (!qtd->length)\n\t\treturn;\n\n\tfor (i = 0; i < mem->payload_blocks; i++) {\n\t\tif (priv->memory_pool[i].size >= qtd->length &&\n\t\t\t\tpriv->memory_pool[i].free) {\n\t\t\tpriv->memory_pool[i].free = 0;\n\t\t\tqtd->payload_addr = priv->memory_pool[i].start;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void free_mem(struct usb_hcd *hcd, struct isp1760_qtd *qtd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint i;\n\n\tif (!qtd->payload_addr)\n\t\treturn;\n\n\tfor (i = 0; i < mem->payload_blocks; i++) {\n\t\tif (priv->memory_pool[i].start == qtd->payload_addr) {\n\t\t\tWARN_ON(priv->memory_pool[i].free);\n\t\t\tpriv->memory_pool[i].free = 1;\n\t\t\tqtd->payload_addr = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdev_err(hcd->self.controller, \"%s: Invalid pointer: %08x\\n\",\n\t\t\t\t\t\t__func__, qtd->payload_addr);\n\tWARN_ON(1);\n\tqtd->payload_addr = 0;\n}\n\n \nstatic int ehci_reset(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\thcd->state = HC_STATE_HALT;\n\tpriv->next_statechange = jiffies;\n\n\treturn isp1760_hcd_set_and_wait_swap(hcd, CMD_RESET, 250 * 1000);\n}\n\nstatic struct isp1760_qh *qh_alloc(gfp_t flags)\n{\n\tstruct isp1760_qh *qh;\n\n\tqh = kmem_cache_zalloc(qh_cachep, flags);\n\tif (!qh)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&qh->qh_list);\n\tINIT_LIST_HEAD(&qh->qtd_list);\n\tqh->slot = -1;\n\n\treturn qh;\n}\n\nstatic void qh_free(struct isp1760_qh *qh)\n{\n\tWARN_ON(!list_empty(&qh->qtd_list));\n\tWARN_ON(qh->slot > -1);\n\tkmem_cache_free(qh_cachep, qh);\n}\n\n \nstatic int priv_init(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 isoc_cache;\n\tu32 isoc_thres;\n\tint i;\n\n\tspin_lock_init(&priv->lock);\n\n\tfor (i = 0; i < QH_END; i++)\n\t\tINIT_LIST_HEAD(&priv->qh_list[i]);\n\n\t \n\tpriv->periodic_size = DEFAULT_I_TDPS;\n\n\tif (priv->is_isp1763) {\n\t\tpriv->i_thresh = 2;\n\t\treturn 0;\n\t}\n\n\t \n\tisoc_cache = isp1760_hcd_read(hcd, HCC_ISOC_CACHE);\n\tisoc_thres = isp1760_hcd_read(hcd, HCC_ISOC_THRES);\n\n\t \n\tif (isoc_cache)\n\t\tpriv->i_thresh = 8;\n\telse  \n\t\tpriv->i_thresh = 2 + isoc_thres;\n\n\treturn 0;\n}\n\nstatic int isp1760_hc_setup(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 atx_reset;\n\tint result;\n\tu32 scratch;\n\tu32 pattern;\n\n\tif (priv->is_isp1763)\n\t\tpattern = 0xcafe;\n\telse\n\t\tpattern = 0xdeadcafe;\n\n\tisp1760_hcd_write(hcd, HC_SCRATCH, pattern);\n\n\t \n\tisp1760_hcd_read(hcd, HC_CHIP_ID_HIGH);\n\tscratch = isp1760_hcd_read(hcd, HC_SCRATCH);\n\tif (scratch != pattern) {\n\t\tdev_err(hcd->self.controller, \"Scratch test failed. 0x%08x\\n\",\n\t\t\tscratch);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tisp1760_hcd_clear(hcd, ISO_BUF_FILL);\n\tisp1760_hcd_clear(hcd, INT_BUF_FILL);\n\tisp1760_hcd_clear(hcd, ATL_BUF_FILL);\n\n\tisp1760_hcd_set(hcd, HC_ATL_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_INT_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_ISO_PTD_SKIPMAP);\n\n\tresult = ehci_reset(hcd);\n\tif (result)\n\t\treturn result;\n\n\t \n\n\t \n\tif (priv->is_isp1763)\n\t\tatx_reset = SW_RESET_RESET_ATX;\n\telse\n\t\tatx_reset = ALL_ATX_RESET;\n\n\tisp1760_hcd_set(hcd, atx_reset);\n\tmdelay(10);\n\tisp1760_hcd_clear(hcd, atx_reset);\n\n\tif (priv->is_isp1763) {\n\t\tisp1760_hcd_set(hcd, HW_OTG_DISABLE);\n\t\tisp1760_hcd_set(hcd, HW_SW_SEL_HC_DC_CLEAR);\n\t\tisp1760_hcd_set(hcd, HW_HC_2_DIS_CLEAR);\n\t\tmdelay(10);\n\n\t\tisp1760_hcd_set(hcd, HW_INTF_LOCK);\n\t}\n\n\tisp1760_hcd_set(hcd, HC_INT_IRQ_ENABLE);\n\tisp1760_hcd_set(hcd, HC_ATL_IRQ_ENABLE);\n\n\treturn priv_init(hcd);\n}\n\nstatic u32 base_to_chip(u32 base)\n{\n\treturn ((base - 0x400) >> 3);\n}\n\nstatic int last_qtd_of_urb(struct isp1760_qtd *qtd, struct isp1760_qh *qh)\n{\n\tstruct urb *urb;\n\n\tif (list_is_last(&qtd->qtd_list, &qh->qtd_list))\n\t\treturn 1;\n\n\turb = qtd->urb;\n\tqtd = list_entry(qtd->qtd_list.next, typeof(*qtd), qtd_list);\n\treturn (qtd->urb != urb);\n}\n\n \n#define\tEHCI_TUNE_CERR\t\t3\t \n#define\tEHCI_TUNE_RL_HS\t\t4\t \n#define\tEHCI_TUNE_RL_TT\t\t0\n#define\tEHCI_TUNE_MULT_HS\t1\t \n#define\tEHCI_TUNE_MULT_TT\t1\n#define\tEHCI_TUNE_FLS\t\t2\t \n\nstatic void create_ptd_atl(struct isp1760_qh *qh,\n\t\t\tstruct isp1760_qtd *qtd, struct ptd *ptd)\n{\n\tu32 maxpacket;\n\tu32 multi;\n\tu32 rl = RL_COUNTER;\n\tu32 nak = NAK_COUNTER;\n\n\tmemset(ptd, 0, sizeof(*ptd));\n\n\t \n\tmaxpacket = usb_maxpacket(qtd->urb->dev, qtd->urb->pipe);\n\tmulti =  1 + ((maxpacket >> 11) & 0x3);\n\tmaxpacket &= 0x7ff;\n\n\t \n\tptd->dw0 = DW0_VALID_BIT;\n\tptd->dw0 |= TO_DW0_LENGTH(qtd->length);\n\tptd->dw0 |= TO_DW0_MAXPACKET(maxpacket);\n\tptd->dw0 |= TO_DW0_ENDPOINT(usb_pipeendpoint(qtd->urb->pipe));\n\n\t \n\tptd->dw1 = TO_DW((usb_pipeendpoint(qtd->urb->pipe) >> 1));\n\tptd->dw1 |= TO_DW1_DEVICE_ADDR(usb_pipedevice(qtd->urb->pipe));\n\tptd->dw1 |= TO_DW1_PID_TOKEN(qtd->packet_type);\n\n\tif (usb_pipebulk(qtd->urb->pipe))\n\t\tptd->dw1 |= DW1_TRANS_BULK;\n\telse if  (usb_pipeint(qtd->urb->pipe))\n\t\tptd->dw1 |= DW1_TRANS_INT;\n\n\tif (qtd->urb->dev->speed != USB_SPEED_HIGH) {\n\t\t \n\n\t\tptd->dw1 |= DW1_TRANS_SPLIT;\n\t\tif (qtd->urb->dev->speed == USB_SPEED_LOW)\n\t\t\tptd->dw1 |= DW1_SE_USB_LOSPEED;\n\n\t\tptd->dw1 |= TO_DW1_PORT_NUM(qtd->urb->dev->ttport);\n\t\tptd->dw1 |= TO_DW1_HUB_NUM(qtd->urb->dev->tt->hub->devnum);\n\n\t\t \n\t\tif (usb_pipeint(qtd->urb->pipe) &&\n\t\t\t\t(qtd->urb->dev->speed == USB_SPEED_LOW))\n\t\t\tptd->dw1 |= DW1_SE_USB_LOSPEED;\n\n\t\trl = 0;\n\t\tnak = 0;\n\t} else {\n\t\tptd->dw0 |= TO_DW0_MULTI(multi);\n\t\tif (usb_pipecontrol(qtd->urb->pipe) ||\n\t\t\t\t\t\tusb_pipebulk(qtd->urb->pipe))\n\t\t\tptd->dw3 |= TO_DW3_PING(qh->ping);\n\t}\n\t \n\tptd->dw2 = 0;\n\tptd->dw2 |= TO_DW2_DATA_START_ADDR(base_to_chip(qtd->payload_addr));\n\tptd->dw2 |= TO_DW2_RL(rl);\n\n\t \n\tptd->dw3 |= TO_DW3_NAKCOUNT(nak);\n\tptd->dw3 |= TO_DW3_DATA_TOGGLE(qh->toggle);\n\tif (usb_pipecontrol(qtd->urb->pipe)) {\n\t\tif (qtd->data_buffer == qtd->urb->setup_packet)\n\t\t\tptd->dw3 &= ~TO_DW3_DATA_TOGGLE(1);\n\t\telse if (last_qtd_of_urb(qtd, qh))\n\t\t\tptd->dw3 |= TO_DW3_DATA_TOGGLE(1);\n\t}\n\n\tptd->dw3 |= DW3_ACTIVE_BIT;\n\t \n\tptd->dw3 |= TO_DW3_CERR(ERR_COUNTER);\n}\n\nstatic void transform_add_int(struct isp1760_qh *qh,\n\t\t\tstruct isp1760_qtd *qtd, struct ptd *ptd)\n{\n\tu32 usof;\n\tu32 period;\n\n\t \n\n\tif (qtd->urb->dev->speed == USB_SPEED_HIGH) {\n\t\t \n\t\tperiod = qtd->urb->interval >> 3;\n\n\t\tif (qtd->urb->interval > 4)\n\t\t\tusof = 0x01;  \n\t\telse if (qtd->urb->interval > 2)\n\t\t\tusof = 0x22;  \n\t\telse if (qtd->urb->interval > 1)\n\t\t\tusof = 0x55;  \n\t\telse\n\t\t\tusof = 0xff;  \n\t} else {\n\t\t \n\t\tperiod = qtd->urb->interval;\n\t\tusof = 0x0f;\t\t \n\n\t\t \n\t\t \n\t\tptd->dw5 = TO_DW(0xff);  \n\t}\n\n\tperiod = period >> 1; \n\tperiod &= 0xf8;  \n\n\tptd->dw2 |= TO_DW(period);\n\tptd->dw4 = TO_DW(usof);\n}\n\nstatic void create_ptd_int(struct isp1760_qh *qh,\n\t\t\tstruct isp1760_qtd *qtd, struct ptd *ptd)\n{\n\tcreate_ptd_atl(qh, qtd, ptd);\n\ttransform_add_int(qh, qtd, ptd);\n}\n\nstatic void isp1760_urb_done(struct usb_hcd *hcd, struct urb *urb)\n__releases(priv->lock)\n__acquires(priv->lock)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tif (!urb->unlinked) {\n\t\tif (urb->status == -EINPROGRESS)\n\t\t\turb->status = 0;\n\t}\n\n\tif (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {\n\t\tvoid *ptr;\n\t\tfor (ptr = urb->transfer_buffer;\n\t\t     ptr < urb->transfer_buffer + urb->transfer_buffer_length;\n\t\t     ptr += PAGE_SIZE)\n\t\t\tflush_dcache_page(virt_to_page(ptr));\n\t}\n\n\t \n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\tspin_unlock(&priv->lock);\n\tusb_hcd_giveback_urb(hcd, urb, urb->status);\n\tspin_lock(&priv->lock);\n}\n\nstatic struct isp1760_qtd *qtd_alloc(gfp_t flags, struct urb *urb,\n\t\t\t\t\t\t\t\tu8 packet_type)\n{\n\tstruct isp1760_qtd *qtd;\n\n\tqtd = kmem_cache_zalloc(qtd_cachep, flags);\n\tif (!qtd)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&qtd->qtd_list);\n\tqtd->urb = urb;\n\tqtd->packet_type = packet_type;\n\tqtd->status = QTD_ENQUEUED;\n\tqtd->actual_length = 0;\n\n\treturn qtd;\n}\n\nstatic void qtd_free(struct isp1760_qtd *qtd)\n{\n\tWARN_ON(qtd->payload_addr);\n\tkmem_cache_free(qtd_cachep, qtd);\n}\n\nstatic void start_bus_transfer(struct usb_hcd *hcd, u32 ptd_offset, int slot,\n\t\t\t\tstruct isp1760_slotinfo *slots,\n\t\t\t\tstruct isp1760_qtd *qtd, struct isp1760_qh *qh,\n\t\t\t\tstruct ptd *ptd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint skip_map;\n\n\tWARN_ON((slot < 0) || (slot > mem->slot_num - 1));\n\tWARN_ON(qtd->length && !qtd->payload_addr);\n\tWARN_ON(slots[slot].qtd);\n\tWARN_ON(slots[slot].qh);\n\tWARN_ON(qtd->status != QTD_PAYLOAD_ALLOC);\n\n\tif (priv->is_isp1763)\n\t\tndelay(100);\n\n\t \n\tif (ptd_offset == ATL_PTD_OFFSET) {\n\t\tskip_map = isp1760_hcd_read(hcd, HC_ATL_PTD_SKIPMAP);\n\t\tisp1760_hcd_write(hcd, HC_ATL_PTD_SKIPMAP,\n\t\t\t\t  skip_map | (1 << slot));\n\t\tpriv->atl_done_map |= isp1760_hcd_read(hcd, HC_ATL_PTD_DONEMAP);\n\t\tpriv->atl_done_map &= ~(1 << slot);\n\t} else {\n\t\tskip_map = isp1760_hcd_read(hcd, HC_INT_PTD_SKIPMAP);\n\t\tisp1760_hcd_write(hcd, HC_INT_PTD_SKIPMAP,\n\t\t\t\t  skip_map | (1 << slot));\n\t\tpriv->int_done_map |= isp1760_hcd_read(hcd, HC_INT_PTD_DONEMAP);\n\t\tpriv->int_done_map &= ~(1 << slot);\n\t}\n\n\tskip_map &= ~(1 << slot);\n\tqh->slot = slot;\n\tqtd->status = QTD_XFER_STARTED;\n\tslots[slot].timestamp = jiffies;\n\tslots[slot].qtd = qtd;\n\tslots[slot].qh = qh;\n\tptd_write(hcd, ptd_offset, slot, ptd);\n\n\tif (ptd_offset == ATL_PTD_OFFSET)\n\t\tisp1760_hcd_write(hcd, HC_ATL_PTD_SKIPMAP, skip_map);\n\telse\n\t\tisp1760_hcd_write(hcd, HC_INT_PTD_SKIPMAP, skip_map);\n}\n\nstatic int is_short_bulk(struct isp1760_qtd *qtd)\n{\n\treturn (usb_pipebulk(qtd->urb->pipe) &&\n\t\t\t\t\t(qtd->actual_length < qtd->length));\n}\n\nstatic void collect_qtds(struct usb_hcd *hcd, struct isp1760_qh *qh,\n\t\t\t\t\t\tstruct list_head *urb_list)\n{\n\tstruct isp1760_qtd *qtd, *qtd_next;\n\tstruct urb_listitem *urb_listitem;\n\tint last_qtd;\n\n\tlist_for_each_entry_safe(qtd, qtd_next, &qh->qtd_list, qtd_list) {\n\t\tif (qtd->status < QTD_XFER_COMPLETE)\n\t\t\tbreak;\n\n\t\tlast_qtd = last_qtd_of_urb(qtd, qh);\n\n\t\tif ((!last_qtd) && (qtd->status == QTD_RETIRE))\n\t\t\tqtd_next->status = QTD_RETIRE;\n\n\t\tif (qtd->status == QTD_XFER_COMPLETE) {\n\t\t\tif (qtd->actual_length) {\n\t\t\t\tswitch (qtd->packet_type) {\n\t\t\t\tcase IN_PID:\n\t\t\t\t\tmem_read(hcd, qtd->payload_addr,\n\t\t\t\t\t\t qtd->data_buffer,\n\t\t\t\t\t\t qtd->actual_length);\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase OUT_PID:\n\t\t\t\t\tqtd->urb->actual_length +=\n\t\t\t\t\t\t\tqtd->actual_length;\n\t\t\t\t\tfallthrough;\n\t\t\t\tcase SETUP_PID:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_short_bulk(qtd)) {\n\t\t\t\tif (qtd->urb->transfer_flags & URB_SHORT_NOT_OK)\n\t\t\t\t\tqtd->urb->status = -EREMOTEIO;\n\t\t\t\tif (!last_qtd)\n\t\t\t\t\tqtd_next->status = QTD_RETIRE;\n\t\t\t}\n\t\t}\n\n\t\tif (qtd->payload_addr)\n\t\t\tfree_mem(hcd, qtd);\n\n\t\tif (last_qtd) {\n\t\t\tif ((qtd->status == QTD_RETIRE) &&\n\t\t\t\t\t(qtd->urb->status == -EINPROGRESS))\n\t\t\t\tqtd->urb->status = -EPIPE;\n\t\t\t \n\t\t\turb_listitem = kmem_cache_zalloc(urb_listitem_cachep,\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (unlikely(!urb_listitem))\n\t\t\t\tbreak;  \n\t\t\turb_listitem->urb = qtd->urb;\n\t\t\tlist_add_tail(&urb_listitem->urb_list, urb_list);\n\t\t}\n\n\t\tlist_del(&qtd->qtd_list);\n\t\tqtd_free(qtd);\n\t}\n}\n\n#define ENQUEUE_DEPTH\t2\nstatic void enqueue_qtds(struct usb_hcd *hcd, struct isp1760_qh *qh)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint slot_num = mem->slot_num;\n\tint ptd_offset;\n\tstruct isp1760_slotinfo *slots;\n\tint curr_slot, free_slot;\n\tint n;\n\tstruct ptd ptd;\n\tstruct isp1760_qtd *qtd;\n\n\tif (unlikely(list_empty(&qh->qtd_list))) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\tif (qh->tt_buffer_dirty)\n\t\treturn;\n\n\tif (usb_pipeint(list_entry(qh->qtd_list.next, struct isp1760_qtd,\n\t\t\t\t\t\t\tqtd_list)->urb->pipe)) {\n\t\tptd_offset = INT_PTD_OFFSET;\n\t\tslots = priv->int_slots;\n\t} else {\n\t\tptd_offset = ATL_PTD_OFFSET;\n\t\tslots = priv->atl_slots;\n\t}\n\n\tfree_slot = -1;\n\tfor (curr_slot = 0; curr_slot < slot_num; curr_slot++) {\n\t\tif ((free_slot == -1) && (slots[curr_slot].qtd == NULL))\n\t\t\tfree_slot = curr_slot;\n\t\tif (slots[curr_slot].qh == qh)\n\t\t\tbreak;\n\t}\n\n\tn = 0;\n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\n\t\tif (qtd->status == QTD_ENQUEUED) {\n\t\t\tWARN_ON(qtd->payload_addr);\n\t\t\talloc_mem(hcd, qtd);\n\t\t\tif ((qtd->length) && (!qtd->payload_addr))\n\t\t\t\tbreak;\n\n\t\t\tif (qtd->length && (qtd->packet_type == SETUP_PID ||\n\t\t\t\t\t    qtd->packet_type == OUT_PID)) {\n\t\t\t\tmem_write(hcd, qtd->payload_addr,\n\t\t\t\t\t  qtd->data_buffer, qtd->length);\n\t\t\t}\n\n\t\t\tqtd->status = QTD_PAYLOAD_ALLOC;\n\t\t}\n\n\t\tif (qtd->status == QTD_PAYLOAD_ALLOC) {\n \n\t\t\t \n\t\t\tif ((curr_slot > slot_num - 1) && (free_slot > -1)) {\n\t\t\t\tif (usb_pipeint(qtd->urb->pipe))\n\t\t\t\t\tcreate_ptd_int(qh, qtd, &ptd);\n\t\t\t\telse\n\t\t\t\t\tcreate_ptd_atl(qh, qtd, &ptd);\n\n\t\t\t\tstart_bus_transfer(hcd, ptd_offset, free_slot,\n\t\t\t\t\t\t\tslots, qtd, qh, &ptd);\n\t\t\t\tcurr_slot = free_slot;\n\t\t\t}\n\n\t\t\tn++;\n\t\t\tif (n >= ENQUEUE_DEPTH)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void schedule_ptds(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv;\n\tstruct isp1760_qh *qh, *qh_next;\n\tstruct list_head *ep_queue;\n\tLIST_HEAD(urb_list);\n\tstruct urb_listitem *urb_listitem, *urb_listitem_next;\n\tint i;\n\n\tif (!hcd) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tpriv = hcd_to_priv(hcd);\n\n\t \n\tfor (i = 0; i < QH_END; i++) {\n\t\tep_queue = &priv->qh_list[i];\n\t\tlist_for_each_entry_safe(qh, qh_next, ep_queue, qh_list) {\n\t\t\tcollect_qtds(hcd, qh, &urb_list);\n\t\t\tif (list_empty(&qh->qtd_list))\n\t\t\t\tlist_del(&qh->qh_list);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(urb_listitem, urb_listitem_next, &urb_list,\n\t\t\t\t\t\t\t\turb_list) {\n\t\tisp1760_urb_done(hcd, urb_listitem->urb);\n\t\tkmem_cache_free(urb_listitem_cachep, urb_listitem);\n\t}\n\n\t \n\tfor (i = 0; i < QH_END; i++) {\n\t\tep_queue = &priv->qh_list[i];\n\t\tlist_for_each_entry_safe(qh, qh_next, ep_queue, qh_list)\n\t\t\tenqueue_qtds(hcd, qh);\n\t}\n}\n\n#define PTD_STATE_QTD_DONE\t1\n#define PTD_STATE_QTD_RELOAD\t2\n#define PTD_STATE_URB_RETIRE\t3\n\nstatic int check_int_transfer(struct usb_hcd *hcd, struct ptd *ptd,\n\t\t\t\t\t\t\t\tstruct urb *urb)\n{\n\tu32 dw4;\n\tint i;\n\n\tdw4 = TO_U32(ptd->dw4);\n\tdw4 >>= 8;\n\n\t \n\n\tif (ptd->dw3 & DW3_HALT_BIT) {\n\n\t\turb->status = -EPROTO;  \n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tswitch (dw4 & 0x7) {\n\t\t\tcase INT_UNDERRUN:\n\t\t\t\tdev_dbg(hcd->self.controller, \"%s: underrun \"\n\t\t\t\t\t\t\"during uFrame %d\\n\",\n\t\t\t\t\t\t__func__, i);\n\t\t\t\turb->status = -ECOMM;  \n\t\t\t\tbreak;\n\t\t\tcase INT_EXACT:\n\t\t\t\tdev_dbg(hcd->self.controller, \"%s: transaction \"\n\t\t\t\t\t\t\"error during uFrame %d\\n\",\n\t\t\t\t\t\t__func__, i);\n\t\t\t\turb->status = -EPROTO;  \n\t\t\t\tbreak;\n\t\t\tcase INT_BABBLE:\n\t\t\t\tdev_dbg(hcd->self.controller, \"%s: babble \"\n\t\t\t\t\t\t\"error during uFrame %d\\n\",\n\t\t\t\t\t\t__func__, i);\n\t\t\t\turb->status = -EOVERFLOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdw4 >>= 3;\n\t\t}\n\n\t\treturn PTD_STATE_URB_RETIRE;\n\t}\n\n\treturn PTD_STATE_QTD_DONE;\n}\n\nstatic int check_atl_transfer(struct usb_hcd *hcd, struct ptd *ptd,\n\t\t\t\t\t\t\t\tstruct urb *urb)\n{\n\tWARN_ON(!ptd);\n\tif (ptd->dw3 & DW3_HALT_BIT) {\n\t\tif (ptd->dw3 & DW3_BABBLE_BIT)\n\t\t\turb->status = -EOVERFLOW;\n\t\telse if (FROM_DW3_CERR(ptd->dw3))\n\t\t\turb->status = -EPIPE;   \n\t\telse\n\t\t\turb->status = -EPROTO;  \n \n\t\treturn PTD_STATE_URB_RETIRE;\n\t}\n\n\tif ((ptd->dw3 & DW3_ERROR_BIT) && (ptd->dw3 & DW3_ACTIVE_BIT)) {\n\t\t \n\t\tdev_dbg(hcd->self.controller, \"PID error; reloading ptd\\n\");\n\t\treturn PTD_STATE_QTD_RELOAD;\n\t}\n\n\tif (!FROM_DW3_NAKCOUNT(ptd->dw3) && (ptd->dw3 & DW3_ACTIVE_BIT)) {\n\t\t \n\t\treturn PTD_STATE_QTD_RELOAD;\n\t}\n\n\treturn PTD_STATE_QTD_DONE;\n}\n\nstatic void handle_done_ptds(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tstruct ptd ptd;\n\tstruct isp1760_qh *qh;\n\tint slot;\n\tint state;\n\tstruct isp1760_slotinfo *slots;\n\tu32 ptd_offset;\n\tstruct isp1760_qtd *qtd;\n\tint modified;\n\tint skip_map;\n\n\tskip_map = isp1760_hcd_read(hcd, HC_INT_PTD_SKIPMAP);\n\tpriv->int_done_map &= ~skip_map;\n\tskip_map = isp1760_hcd_read(hcd, HC_ATL_PTD_SKIPMAP);\n\tpriv->atl_done_map &= ~skip_map;\n\n\tmodified = priv->int_done_map || priv->atl_done_map;\n\n\twhile (priv->int_done_map || priv->atl_done_map) {\n\t\tif (priv->int_done_map) {\n\t\t\t \n\t\t\tslot = __ffs(priv->int_done_map);\n\t\t\tpriv->int_done_map &= ~(1 << slot);\n\t\t\tslots = priv->int_slots;\n\t\t\t \n\t\t\tif (!slots[slot].qh) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptd_offset = INT_PTD_OFFSET;\n\t\t\tptd_read(hcd, INT_PTD_OFFSET, slot, &ptd);\n\t\t\tstate = check_int_transfer(hcd, &ptd,\n\t\t\t\t\t\t\tslots[slot].qtd->urb);\n\t\t} else {\n\t\t\t \n\t\t\tslot = __ffs(priv->atl_done_map);\n\t\t\tpriv->atl_done_map &= ~(1 << slot);\n\t\t\tslots = priv->atl_slots;\n\t\t\t \n\t\t\tif (!slots[slot].qh) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tptd_offset = ATL_PTD_OFFSET;\n\t\t\tptd_read(hcd, ATL_PTD_OFFSET, slot, &ptd);\n\t\t\tstate = check_atl_transfer(hcd, &ptd,\n\t\t\t\t\t\t\tslots[slot].qtd->urb);\n\t\t}\n\n\t\tqtd = slots[slot].qtd;\n\t\tslots[slot].qtd = NULL;\n\t\tqh = slots[slot].qh;\n\t\tslots[slot].qh = NULL;\n\t\tqh->slot = -1;\n\n\t\tWARN_ON(qtd->status != QTD_XFER_STARTED);\n\n\t\tswitch (state) {\n\t\tcase PTD_STATE_QTD_DONE:\n\t\t\tif ((usb_pipeint(qtd->urb->pipe)) &&\n\t\t\t\t       (qtd->urb->dev->speed != USB_SPEED_HIGH))\n\t\t\t\tqtd->actual_length =\n\t\t\t\t       FROM_DW3_SCS_NRBYTESTRANSFERRED(ptd.dw3);\n\t\t\telse\n\t\t\t\tqtd->actual_length =\n\t\t\t\t\tFROM_DW3_NRBYTESTRANSFERRED(ptd.dw3);\n\n\t\t\tqtd->status = QTD_XFER_COMPLETE;\n\t\t\tif (list_is_last(&qtd->qtd_list, &qh->qtd_list) ||\n\t\t\t    is_short_bulk(qtd))\n\t\t\t\tqtd = NULL;\n\t\t\telse\n\t\t\t\tqtd = list_entry(qtd->qtd_list.next,\n\t\t\t\t\t\t\ttypeof(*qtd), qtd_list);\n\n\t\t\tqh->toggle = FROM_DW3_DATA_TOGGLE(ptd.dw3);\n\t\t\tqh->ping = FROM_DW3_PING(ptd.dw3);\n\t\t\tbreak;\n\n\t\tcase PTD_STATE_QTD_RELOAD:  \n\t\t\tqtd->status = QTD_PAYLOAD_ALLOC;\n\t\t\tptd.dw0 |= DW0_VALID_BIT;\n\t\t\t \n\t\t\tptd.dw3 &= ~TO_DW3_NAKCOUNT(0xf);\n\t\t\tptd.dw3 |= TO_DW3_NAKCOUNT(FROM_DW2_RL(ptd.dw2));\n\t\t\tptd.dw3 &= ~TO_DW3_CERR(3);\n\t\t\tptd.dw3 |= TO_DW3_CERR(ERR_COUNTER);\n\t\t\tqh->toggle = FROM_DW3_DATA_TOGGLE(ptd.dw3);\n\t\t\tqh->ping = FROM_DW3_PING(ptd.dw3);\n\t\t\tbreak;\n\n\t\tcase PTD_STATE_URB_RETIRE:\n\t\t\tqtd->status = QTD_RETIRE;\n\t\t\tif ((qtd->urb->dev->speed != USB_SPEED_HIGH) &&\n\t\t\t\t\t(qtd->urb->status != -EPIPE) &&\n\t\t\t\t\t(qtd->urb->status != -EREMOTEIO)) {\n\t\t\t\tqh->tt_buffer_dirty = 1;\n\t\t\t\tif (usb_hub_clear_tt_buffer(qtd->urb))\n\t\t\t\t\t \n\t\t\t\t\tqh->tt_buffer_dirty = 0;\n\t\t\t}\n\t\t\tqtd = NULL;\n\t\t\tqh->toggle = 0;\n\t\t\tqh->ping = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (qtd && (qtd->status == QTD_PAYLOAD_ALLOC)) {\n\t\t\tif (slots == priv->int_slots) {\n\t\t\t\tif (state == PTD_STATE_QTD_RELOAD)\n\t\t\t\t\tdev_err(hcd->self.controller,\n\t\t\t\t\t\t\"%s: PTD_STATE_QTD_RELOAD on \"\n\t\t\t\t\t\t\"interrupt packet\\n\", __func__);\n\t\t\t\tif (state != PTD_STATE_QTD_RELOAD)\n\t\t\t\t\tcreate_ptd_int(qh, qtd, &ptd);\n\t\t\t} else {\n\t\t\t\tif (state != PTD_STATE_QTD_RELOAD)\n\t\t\t\t\tcreate_ptd_atl(qh, qtd, &ptd);\n\t\t\t}\n\n\t\t\tstart_bus_transfer(hcd, ptd_offset, slot, slots, qtd,\n\t\t\t\tqh, &ptd);\n\t\t}\n\t}\n\n\tif (modified)\n\t\tschedule_ptds(hcd);\n}\n\nstatic irqreturn_t isp1760_irq(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tirqreturn_t irqret = IRQ_NONE;\n\tu32 int_reg;\n\tu32 imask;\n\n\tspin_lock(&priv->lock);\n\n\tif (!(hcd->state & HC_STATE_RUNNING))\n\t\tgoto leave;\n\n\timask = isp1760_hcd_read(hcd, HC_INTERRUPT);\n\tif (unlikely(!imask))\n\t\tgoto leave;\n\n\tint_reg = priv->is_isp1763 ? ISP1763_HC_INTERRUPT :\n\t\tISP176x_HC_INTERRUPT;\n\tisp1760_reg_write(priv->regs, int_reg, imask);\n\n\tpriv->int_done_map |= isp1760_hcd_read(hcd, HC_INT_PTD_DONEMAP);\n\tpriv->atl_done_map |= isp1760_hcd_read(hcd, HC_ATL_PTD_DONEMAP);\n\n\thandle_done_ptds(hcd);\n\n\tirqret = IRQ_HANDLED;\n\nleave:\n\tspin_unlock(&priv->lock);\n\n\treturn irqret;\n}\n\n \n#define SLOT_TIMEOUT 300\n#define SLOT_CHECK_PERIOD 200\nstatic struct timer_list errata2_timer;\nstatic struct usb_hcd *errata2_timer_hcd;\n\nstatic void errata2_function(struct timer_list *unused)\n{\n\tstruct usb_hcd *hcd = errata2_timer_hcd;\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tint slot;\n\tstruct ptd ptd;\n\tunsigned long spinflags;\n\n\tspin_lock_irqsave(&priv->lock, spinflags);\n\n\tfor (slot = 0; slot < mem->slot_num; slot++)\n\t\tif (priv->atl_slots[slot].qh && time_after(jiffies,\n\t\t\t\t\tpriv->atl_slots[slot].timestamp +\n\t\t\t\t\tmsecs_to_jiffies(SLOT_TIMEOUT))) {\n\t\t\tptd_read(hcd, ATL_PTD_OFFSET, slot, &ptd);\n\t\t\tif (!FROM_DW0_VALID(ptd.dw0) &&\n\t\t\t\t\t!FROM_DW3_ACTIVE(ptd.dw3))\n\t\t\t\tpriv->atl_done_map |= 1 << slot;\n\t\t}\n\n\tif (priv->atl_done_map)\n\t\thandle_done_ptds(hcd);\n\n\tspin_unlock_irqrestore(&priv->lock, spinflags);\n\n\terrata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);\n\tadd_timer(&errata2_timer);\n}\n\nstatic int isp1763_run(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tint retval;\n\tu32 chipid_h;\n\tu32 chipid_l;\n\tu32 chip_rev;\n\tu32 ptd_atl_int;\n\tu32 ptd_iso;\n\n\thcd->uses_new_polling = 1;\n\thcd->state = HC_STATE_RUNNING;\n\n\tchipid_h = isp1760_hcd_read(hcd, HC_CHIP_ID_HIGH);\n\tchipid_l = isp1760_hcd_read(hcd, HC_CHIP_ID_LOW);\n\tchip_rev = isp1760_hcd_read(hcd, HC_CHIP_REV);\n\tdev_info(hcd->self.controller, \"USB ISP %02x%02x HW rev. %d started\\n\",\n\t\t chipid_h, chipid_l, chip_rev);\n\n\tisp1760_hcd_clear(hcd, ISO_BUF_FILL);\n\tisp1760_hcd_clear(hcd, INT_BUF_FILL);\n\tisp1760_hcd_clear(hcd, ATL_BUF_FILL);\n\n\tisp1760_hcd_set(hcd, HC_ATL_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_INT_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_ISO_PTD_SKIPMAP);\n\tndelay(100);\n\tisp1760_hcd_clear(hcd, HC_ATL_PTD_DONEMAP);\n\tisp1760_hcd_clear(hcd, HC_INT_PTD_DONEMAP);\n\tisp1760_hcd_clear(hcd, HC_ISO_PTD_DONEMAP);\n\n\tisp1760_hcd_set(hcd, HW_OTG_DISABLE);\n\tisp1760_reg_write(priv->regs, ISP1763_HC_OTG_CTRL_CLEAR, BIT(7));\n\tisp1760_reg_write(priv->regs, ISP1763_HC_OTG_CTRL_CLEAR, BIT(15));\n\tmdelay(10);\n\n\tisp1760_hcd_set(hcd, HC_INT_IRQ_ENABLE);\n\tisp1760_hcd_set(hcd, HC_ATL_IRQ_ENABLE);\n\n\tisp1760_hcd_set(hcd, HW_GLOBAL_INTR_EN);\n\n\tisp1760_hcd_clear(hcd, HC_ATL_IRQ_MASK_AND);\n\tisp1760_hcd_clear(hcd, HC_INT_IRQ_MASK_AND);\n\tisp1760_hcd_clear(hcd, HC_ISO_IRQ_MASK_AND);\n\n\tisp1760_hcd_set(hcd, HC_ATL_IRQ_MASK_OR);\n\tisp1760_hcd_set(hcd, HC_INT_IRQ_MASK_OR);\n\tisp1760_hcd_set(hcd, HC_ISO_IRQ_MASK_OR);\n\n\tptd_atl_int = 0x8000;\n\tptd_iso = 0x0001;\n\n\tisp1760_hcd_write(hcd, HC_ATL_PTD_LASTPTD, ptd_atl_int);\n\tisp1760_hcd_write(hcd, HC_INT_PTD_LASTPTD, ptd_atl_int);\n\tisp1760_hcd_write(hcd, HC_ISO_PTD_LASTPTD, ptd_iso);\n\n\tisp1760_hcd_set(hcd, ATL_BUF_FILL);\n\tisp1760_hcd_set(hcd, INT_BUF_FILL);\n\n\tisp1760_hcd_clear(hcd, CMD_LRESET);\n\tisp1760_hcd_clear(hcd, CMD_RESET);\n\n\tretval = isp1760_hcd_set_and_wait(hcd, CMD_RUN, 250 * 1000);\n\tif (retval)\n\t\treturn retval;\n\n\tdown_write(&ehci_cf_port_reset_rwsem);\n\tretval = isp1760_hcd_set_and_wait(hcd, FLAG_CF, 250 * 1000);\n\tup_write(&ehci_cf_port_reset_rwsem);\n\tif (retval)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic int isp1760_run(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tint retval;\n\tu32 chipid_h;\n\tu32 chipid_l;\n\tu32 chip_rev;\n\tu32 ptd_atl_int;\n\tu32 ptd_iso;\n\n\t \n\tif (priv->is_isp1763)\n\t\treturn isp1763_run(hcd);\n\n\thcd->uses_new_polling = 1;\n\n\thcd->state = HC_STATE_RUNNING;\n\n\t \n\tisp1760_hcd_clear(hcd, HC_ATL_IRQ_MASK_AND);\n\tisp1760_hcd_clear(hcd, HC_INT_IRQ_MASK_AND);\n\tisp1760_hcd_clear(hcd, HC_ISO_IRQ_MASK_AND);\n\n\tisp1760_hcd_set(hcd, HC_ATL_IRQ_MASK_OR);\n\tisp1760_hcd_set(hcd, HC_INT_IRQ_MASK_OR);\n\tisp1760_hcd_set(hcd, HC_ISO_IRQ_MASK_OR);\n\n\t \n\n\tisp1760_hcd_set(hcd, HW_GLOBAL_INTR_EN);\n\n\tisp1760_hcd_clear(hcd, CMD_LRESET);\n\tisp1760_hcd_clear(hcd, CMD_RESET);\n\n\tretval = isp1760_hcd_set_and_wait(hcd, CMD_RUN, 250 * 1000);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tdown_write(&ehci_cf_port_reset_rwsem);\n\n\tretval = isp1760_hcd_set_and_wait(hcd, FLAG_CF, 250 * 1000);\n\tup_write(&ehci_cf_port_reset_rwsem);\n\tif (retval)\n\t\treturn retval;\n\n\terrata2_timer_hcd = hcd;\n\ttimer_setup(&errata2_timer, errata2_function, 0);\n\terrata2_timer.expires = jiffies + msecs_to_jiffies(SLOT_CHECK_PERIOD);\n\tadd_timer(&errata2_timer);\n\n\tchipid_h = isp1760_hcd_read(hcd, HC_CHIP_ID_HIGH);\n\tchipid_l = isp1760_hcd_read(hcd, HC_CHIP_ID_LOW);\n\tchip_rev = isp1760_hcd_read(hcd, HC_CHIP_REV);\n\tdev_info(hcd->self.controller, \"USB ISP %02x%02x HW rev. %d started\\n\",\n\t\t chipid_h, chipid_l, chip_rev);\n\n\t \n\n\t \n\tptd_atl_int = 0x80000000;\n\tptd_iso = 0x00000001;\n\n\tisp1760_hcd_write(hcd, HC_ATL_PTD_LASTPTD, ptd_atl_int);\n\tisp1760_hcd_write(hcd, HC_INT_PTD_LASTPTD, ptd_atl_int);\n\tisp1760_hcd_write(hcd, HC_ISO_PTD_LASTPTD, ptd_iso);\n\n\tisp1760_hcd_set(hcd, HC_ATL_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_INT_PTD_SKIPMAP);\n\tisp1760_hcd_set(hcd, HC_ISO_PTD_SKIPMAP);\n\n\tisp1760_hcd_set(hcd, ATL_BUF_FILL);\n\tisp1760_hcd_set(hcd, INT_BUF_FILL);\n\n\t \n\treturn 0;\n}\n\nstatic int qtd_fill(struct isp1760_qtd *qtd, void *databuffer, size_t len)\n{\n\tqtd->data_buffer = databuffer;\n\n\tqtd->length = len;\n\n\treturn qtd->length;\n}\n\nstatic void qtd_list_free(struct list_head *qtd_list)\n{\n\tstruct isp1760_qtd *qtd, *qtd_next;\n\n\tlist_for_each_entry_safe(qtd, qtd_next, qtd_list, qtd_list) {\n\t\tlist_del(&qtd->qtd_list);\n\t\tqtd_free(qtd);\n\t}\n}\n\n \nstatic void packetize_urb(struct usb_hcd *hcd,\n\t\tstruct urb *urb, struct list_head *head, gfp_t flags)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tconst struct isp1760_memory_layout *mem = priv->memory_layout;\n\tstruct isp1760_qtd *qtd;\n\tvoid *buf;\n\tint len, maxpacketsize;\n\tu8 packet_type;\n\n\t \n\n\tif (!urb->transfer_buffer && urb->transfer_buffer_length) {\n\t\t \n\t\tdev_err(hcd->self.controller,\n\t\t\t\t\"buf is null, dma is %08lx len is %d\\n\",\n\t\t\t\t(long unsigned)urb->transfer_dma,\n\t\t\t\turb->transfer_buffer_length);\n\t\tWARN_ON(1);\n\t}\n\n\tif (usb_pipein(urb->pipe))\n\t\tpacket_type = IN_PID;\n\telse\n\t\tpacket_type = OUT_PID;\n\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\tqtd = qtd_alloc(flags, urb, SETUP_PID);\n\t\tif (!qtd)\n\t\t\tgoto cleanup;\n\t\tqtd_fill(qtd, urb->setup_packet, sizeof(struct usb_ctrlrequest));\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t \n\t\tif (urb->transfer_buffer_length == 0)\n\t\t\tpacket_type = IN_PID;\n\t}\n\n\tmaxpacketsize = usb_maxpacket(urb->dev, urb->pipe);\n\n\t \n\tbuf = urb->transfer_buffer;\n\tlen = urb->transfer_buffer_length;\n\n\tfor (;;) {\n\t\tint this_qtd_len;\n\n\t\tqtd = qtd_alloc(flags, urb, packet_type);\n\t\tif (!qtd)\n\t\t\tgoto cleanup;\n\n\t\tif (len > mem->blocks_size[ISP176x_BLOCK_NUM - 1])\n\t\t\tthis_qtd_len = mem->blocks_size[ISP176x_BLOCK_NUM - 1];\n\t\telse\n\t\t\tthis_qtd_len = len;\n\n\t\tthis_qtd_len = qtd_fill(qtd, buf, this_qtd_len);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\tlen -= this_qtd_len;\n\t\tbuf += this_qtd_len;\n\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (urb->transfer_buffer_length != 0) {\n\t\tint one_more = 0;\n\n\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\tone_more = 1;\n\t\t\tif (packet_type == IN_PID)\n\t\t\t\tpacket_type = OUT_PID;\n\t\t\telse\n\t\t\t\tpacket_type = IN_PID;\n\t\t} else if (usb_pipebulk(urb->pipe) && maxpacketsize\n\t\t\t\t&& (urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& !(urb->transfer_buffer_length %\n\t\t\t\t\t\t\tmaxpacketsize)) {\n\t\t\tone_more = 1;\n\t\t}\n\t\tif (one_more) {\n\t\t\tqtd = qtd_alloc(flags, urb, packet_type);\n\t\t\tif (!qtd)\n\t\t\t\tgoto cleanup;\n\n\t\t\t \n\t\t\tqtd_fill(qtd, NULL, 0);\n\t\t\tlist_add_tail(&qtd->qtd_list, head);\n\t\t}\n\t}\n\n\treturn;\n\ncleanup:\n\tqtd_list_free(head);\n}\n\nstatic int isp1760_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\tgfp_t mem_flags)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tstruct list_head *ep_queue;\n\tstruct isp1760_qh *qh, *qhit;\n\tunsigned long spinflags;\n\tLIST_HEAD(new_qtds);\n\tint retval;\n\tint qh_in_queue;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_queue = &priv->qh_list[QH_CONTROL];\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_queue = &priv->qh_list[QH_BULK];\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tif (urb->interval < 0)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tep_queue = &priv->qh_list[QH_INTERRUPT];\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tdev_err(hcd->self.controller, \"%s: isochronous USB packets \"\n\t\t\t\t\t\t\t\"not yet supported\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\treturn -EPIPE;\n\tdefault:\n\t\tdev_err(hcd->self.controller, \"%s: unknown pipe type\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\treturn -EPIPE;\n\t}\n\n\tif (usb_pipein(urb->pipe))\n\t\turb->actual_length = 0;\n\n\tpacketize_urb(hcd, urb, &new_qtds, mem_flags);\n\tif (list_empty(&new_qtds))\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&priv->lock, spinflags);\n\n\tif (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {\n\t\tretval = -ESHUTDOWN;\n\t\tqtd_list_free(&new_qtds);\n\t\tgoto out;\n\t}\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval) {\n\t\tqtd_list_free(&new_qtds);\n\t\tgoto out;\n\t}\n\n\tqh = urb->ep->hcpriv;\n\tif (qh) {\n\t\tqh_in_queue = 0;\n\t\tlist_for_each_entry(qhit, ep_queue, qh_list) {\n\t\t\tif (qhit == qh) {\n\t\t\t\tqh_in_queue = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!qh_in_queue)\n\t\t\tlist_add_tail(&qh->qh_list, ep_queue);\n\t} else {\n\t\tqh = qh_alloc(GFP_ATOMIC);\n\t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\tqtd_list_free(&new_qtds);\n\t\t\tgoto out;\n\t\t}\n\t\tlist_add_tail(&qh->qh_list, ep_queue);\n\t\turb->ep->hcpriv = qh;\n\t}\n\n\tlist_splice_tail(&new_qtds, &qh->qtd_list);\n\tschedule_ptds(hcd);\n\nout:\n\tspin_unlock_irqrestore(&priv->lock, spinflags);\n\treturn retval;\n}\n\nstatic void kill_transfer(struct usb_hcd *hcd, struct urb *urb,\n\t\tstruct isp1760_qh *qh)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tint skip_map;\n\n\tWARN_ON(qh->slot == -1);\n\n\t \n\tif (usb_pipecontrol(urb->pipe) || usb_pipebulk(urb->pipe)) {\n\t\tif (qh->slot != -1) {\n\t\t\tskip_map = isp1760_hcd_read(hcd, HC_ATL_PTD_SKIPMAP);\n\t\t\tskip_map |= (1 << qh->slot);\n\t\t\tisp1760_hcd_write(hcd, HC_ATL_PTD_SKIPMAP, skip_map);\n\t\t\tndelay(100);\n\t\t}\n\t\tpriv->atl_slots[qh->slot].qh = NULL;\n\t\tpriv->atl_slots[qh->slot].qtd = NULL;\n\t} else {\n\t\tif (qh->slot != -1) {\n\t\t\tskip_map = isp1760_hcd_read(hcd, HC_INT_PTD_SKIPMAP);\n\t\t\tskip_map |= (1 << qh->slot);\n\t\t\tisp1760_hcd_write(hcd, HC_INT_PTD_SKIPMAP, skip_map);\n\t\t}\n\t\tpriv->int_slots[qh->slot].qh = NULL;\n\t\tpriv->int_slots[qh->slot].qtd = NULL;\n\t}\n\n\tqh->slot = -1;\n}\n\n \nstatic void dequeue_urb_from_qtd(struct usb_hcd *hcd, struct isp1760_qh *qh,\n\t\t\t\t\t\tstruct isp1760_qtd *qtd)\n{\n\tstruct urb *urb;\n\tint urb_was_running;\n\n\turb = qtd->urb;\n\turb_was_running = 0;\n\tlist_for_each_entry_from(qtd, &qh->qtd_list, qtd_list) {\n\t\tif (qtd->urb != urb)\n\t\t\tbreak;\n\n\t\tif (qtd->status >= QTD_XFER_STARTED)\n\t\t\turb_was_running = 1;\n\t\tif (last_qtd_of_urb(qtd, qh) &&\n\t\t\t\t\t(qtd->status >= QTD_XFER_COMPLETE))\n\t\t\turb_was_running = 0;\n\n\t\tif (qtd->status == QTD_XFER_STARTED)\n\t\t\tkill_transfer(hcd, urb, qh);\n\t\tqtd->status = QTD_RETIRE;\n\t}\n\n\tif ((urb->dev->speed != USB_SPEED_HIGH) && urb_was_running) {\n\t\tqh->tt_buffer_dirty = 1;\n\t\tif (usb_hub_clear_tt_buffer(urb))\n\t\t\t \n\t\t\tqh->tt_buffer_dirty = 0;\n\t}\n}\n\nstatic int isp1760_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\n\t\tint status)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tunsigned long spinflags;\n\tstruct isp1760_qh *qh;\n\tstruct isp1760_qtd *qtd;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&priv->lock, spinflags);\n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval)\n\t\tgoto out;\n\n\tqh = urb->ep->hcpriv;\n\tif (!qh) {\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list)\n\t\tif (qtd->urb == urb) {\n\t\t\tdequeue_urb_from_qtd(hcd, qh, qtd);\n\t\t\tlist_move(&qtd->qtd_list, &qh->qtd_list);\n\t\t\tbreak;\n\t\t}\n\n\turb->status = status;\n\tschedule_ptds(hcd);\n\nout:\n\tspin_unlock_irqrestore(&priv->lock, spinflags);\n\treturn retval;\n}\n\nstatic void isp1760_endpoint_disable(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tunsigned long spinflags;\n\tstruct isp1760_qh *qh, *qh_iter;\n\tint i;\n\n\tspin_lock_irqsave(&priv->lock, spinflags);\n\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\tgoto out;\n\n\tWARN_ON(!list_empty(&qh->qtd_list));\n\n\tfor (i = 0; i < QH_END; i++)\n\t\tlist_for_each_entry(qh_iter, &priv->qh_list[i], qh_list)\n\t\t\tif (qh_iter == qh) {\n\t\t\t\tlist_del(&qh_iter->qh_list);\n\t\t\t\ti = QH_END;\n\t\t\t\tbreak;\n\t\t\t}\n\tqh_free(qh);\n\tep->hcpriv = NULL;\n\n\tschedule_ptds(hcd);\n\nout:\n\tspin_unlock_irqrestore(&priv->lock, spinflags);\n}\n\nstatic int isp1760_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 status = 0;\n\tint retval = 1;\n\tunsigned long flags;\n\n\t \n\tif (!HC_IS_RUNNING(hcd->state))\n\t\treturn 0;\n\n\t \n\tbuf[0] = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (isp1760_hcd_is_set(hcd, PORT_OWNER) &&\n\t    isp1760_hcd_is_set(hcd, PORT_CSC)) {\n\t\tisp1760_hcd_clear(hcd, PORT_CSC);\n\t\tgoto done;\n\t}\n\n\t \n\tif (isp1760_hcd_is_set(hcd, PORT_CSC) ||\n\t    (isp1760_hcd_is_set(hcd, PORT_RESUME) &&\n\t     time_after_eq(jiffies, priv->reset_done))) {\n\t\tbuf [0] |= 1 << (0 + 1);\n\t\tstatus = STS_PCD;\n\t}\n\t \ndone:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn status ? retval : 0;\n}\n\nstatic void isp1760_hub_descriptor(struct isp1760_hcd *priv,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint ports;\n\tu16 temp;\n\n\tports = isp1760_hcd_n_ports(priv->hcd);\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\t \n\tdesc->bPwrOn2PwrGood = 10;\n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ports;\n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\t \n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\n\tmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\n\n\t \n\ttemp = HUB_CHAR_INDV_PORT_OCPM;\n\tif (isp1760_hcd_ppc_is_set(priv->hcd))\n\t\t \n\t\ttemp |= HUB_CHAR_INDV_PORT_LPSM;\n\telse\n\t\t \n\t\ttemp |= HUB_CHAR_NO_LPSM;\n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n}\n\n#define\tPORT_WAKE_BITS\t(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)\n\nstatic void check_reset_complete(struct usb_hcd *hcd, int index)\n{\n\tif (!(isp1760_hcd_is_set(hcd, PORT_CONNECT)))\n\t\treturn;\n\n\t \n\tif (!isp1760_hcd_is_set(hcd, PORT_PE)) {\n\t\tdev_info(hcd->self.controller,\n\t\t\t \"port %d full speed --> companion\\n\", index + 1);\n\n\t\tisp1760_hcd_set(hcd, PORT_OWNER);\n\n\t\tisp1760_hcd_clear(hcd, PORT_CSC);\n\t} else {\n\t\tdev_info(hcd->self.controller, \"port %d high speed\\n\",\n\t\t\t index + 1);\n\t}\n\n\treturn;\n}\n\nstatic int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,\n\t\tu16 wValue, u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 status;\n\tunsigned long flags;\n\tint retval = 0;\n\tint ports;\n\n\tports = isp1760_hcd_n_ports(hcd);\n\n\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\n\t\t \n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tisp1760_hcd_clear(hcd, PORT_PE);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (isp1760_hcd_is_set(hcd, PORT_RESET))\n\t\t\t\tgoto error;\n\n\t\t\tif (isp1760_hcd_is_set(hcd, PORT_SUSPEND)) {\n\t\t\t\tif (!isp1760_hcd_is_set(hcd, PORT_PE))\n\t\t\t\t\tgoto error;\n\t\t\t\t \n\t\t\t\tisp1760_hcd_clear(hcd, PORT_CSC);\n\t\t\t\tisp1760_hcd_set(hcd, PORT_RESUME);\n\n\t\t\t\tpriv->reset_done = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (isp1760_hcd_ppc_is_set(hcd))\n\t\t\t\tisp1760_hcd_clear(hcd, PORT_POWER);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tisp1760_hcd_set(hcd, PORT_CSC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tisp1760_hcd_read(hcd, CMD_RUN);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tisp1760_hub_descriptor(priv, (struct usb_hub_descriptor *)\n\t\t\tbuf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t \n\t\tmemset(buf, 0, 4);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tstatus = 0;\n\n\t\t \n\t\tif (isp1760_hcd_is_set(hcd, PORT_CSC))\n\t\t\tstatus |= USB_PORT_STAT_C_CONNECTION << 16;\n\n\t\t \n\t\tif (isp1760_hcd_is_set(hcd, PORT_RESUME)) {\n\t\t\tdev_err(hcd->self.controller, \"Port resume should be skipped.\\n\");\n\n\t\t\t \n\t\t\tif (!priv->reset_done) {\n\t\t\t\t \n\t\t\t\tpriv->reset_done = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies(20);\n\t\t\t\t \n\t\t\t\tmod_timer(&hcd->rh_timer, priv->reset_done);\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (time_after_eq(jiffies,\n\t\t\t\t\tpriv->reset_done)) {\n\t\t\t\tstatus |= USB_PORT_STAT_C_SUSPEND << 16;\n\t\t\t\tpriv->reset_done = 0;\n\n\t\t\t\t \n\t\t\t\tisp1760_hcd_clear(hcd, PORT_CSC);\n\n\t\t\t\tretval = isp1760_hcd_clear_and_wait(hcd,\n\t\t\t\t\t\t\t  PORT_RESUME, 2000);\n\t\t\t\tif (retval != 0) {\n\t\t\t\t\tdev_err(hcd->self.controller,\n\t\t\t\t\t\t\"port %d resume error %d\\n\",\n\t\t\t\t\t\twIndex + 1, retval);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (isp1760_hcd_is_set(hcd, PORT_RESET) &&\n\t\t    time_after_eq(jiffies, priv->reset_done)) {\n\t\t\tstatus |= USB_PORT_STAT_C_RESET << 16;\n\t\t\tpriv->reset_done = 0;\n\n\t\t\t \n\t\t\t \n\t\t\tretval = isp1760_hcd_clear_and_wait(hcd, PORT_RESET,\n\t\t\t\t\t\t\t    750);\n\t\t\tif (retval != 0) {\n\t\t\t\tdev_err(hcd->self.controller, \"port %d reset error %d\\n\",\n\t\t\t\t\twIndex + 1, retval);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tcheck_reset_complete(hcd, wIndex);\n\t\t}\n\t\t \n\n\t\tif (isp1760_hcd_is_set(hcd, PORT_OWNER))\n\t\t\tdev_err(hcd->self.controller, \"PORT_OWNER is set\\n\");\n\n\t\tif (isp1760_hcd_is_set(hcd, PORT_CONNECT)) {\n\t\t\tstatus |= USB_PORT_STAT_CONNECTION;\n\t\t\t \n\t\t\tstatus |= USB_PORT_STAT_HIGH_SPEED;\n\t\t}\n\t\tif (isp1760_hcd_is_set(hcd, PORT_PE))\n\t\t\tstatus |= USB_PORT_STAT_ENABLE;\n\t\tif (isp1760_hcd_is_set(hcd, PORT_SUSPEND) &&\n\t\t    isp1760_hcd_is_set(hcd, PORT_RESUME))\n\t\t\tstatus |= USB_PORT_STAT_SUSPEND;\n\t\tif (isp1760_hcd_is_set(hcd, PORT_RESET))\n\t\t\tstatus |= USB_PORT_STAT_RESET;\n\t\tif (isp1760_hcd_is_set(hcd, PORT_POWER))\n\t\t\tstatus |= USB_PORT_STAT_POWER;\n\n\t\tput_unaligned(cpu_to_le32(status), (__le32 *) buf);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\twIndex &= 0xff;\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\n\t\tif (isp1760_hcd_is_set(hcd, PORT_OWNER))\n\t\t\tbreak;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tisp1760_hcd_set(hcd, PORT_PE);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (!isp1760_hcd_is_set(hcd, PORT_PE) ||\n\t\t\t    isp1760_hcd_is_set(hcd, PORT_RESET))\n\t\t\t\tgoto error;\n\n\t\t\tisp1760_hcd_set(hcd, PORT_SUSPEND);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (isp1760_hcd_ppc_is_set(hcd))\n\t\t\t\tisp1760_hcd_set(hcd, PORT_POWER);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (isp1760_hcd_is_set(hcd, PORT_RESUME))\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\tif ((isp1760_hcd_is_set(hcd, PORT_CONNECT) &&\n\t\t\t     !isp1760_hcd_is_set(hcd, PORT_PE)) &&\n\t\t\t    (isp1760_hcd_read(hcd, PORT_LSTATUS) == 1)) {\n\t\t\t\tisp1760_hcd_set(hcd, PORT_OWNER);\n\t\t\t} else {\n\t\t\t\tisp1760_hcd_set(hcd, PORT_RESET);\n\t\t\t\tisp1760_hcd_clear(hcd, PORT_PE);\n\n\t\t\t\t \n\t\t\t\tpriv->reset_done = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(50);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn retval;\n}\n\nstatic int isp1760_get_frame(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tu32 fr;\n\n\tfr = isp1760_hcd_read(hcd, HC_FRINDEX);\n\treturn (fr >> 3) % priv->periodic_size;\n}\n\nstatic void isp1760_stop(struct usb_hcd *hcd)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\n\tdel_timer(&errata2_timer);\n\n\tisp1760_hub_control(hcd, ClearPortFeature, USB_PORT_FEAT_POWER,\t1,\n\t\t\tNULL, 0);\n\tmsleep(20);\n\n\tspin_lock_irq(&priv->lock);\n\tehci_reset(hcd);\n\t \n\tisp1760_hcd_clear(hcd, HW_GLOBAL_INTR_EN);\n\tspin_unlock_irq(&priv->lock);\n\n\tisp1760_hcd_clear(hcd, FLAG_CF);\n}\n\nstatic void isp1760_shutdown(struct usb_hcd *hcd)\n{\n\tisp1760_stop(hcd);\n\n\tisp1760_hcd_clear(hcd, HW_GLOBAL_INTR_EN);\n\n\tisp1760_hcd_clear(hcd, CMD_RUN);\n}\n\nstatic void isp1760_clear_tt_buffer_complete(struct usb_hcd *hcd,\n\t\t\t\t\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct isp1760_hcd *priv = hcd_to_priv(hcd);\n\tstruct isp1760_qh *qh = ep->hcpriv;\n\tunsigned long spinflags;\n\n\tif (!qh)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->lock, spinflags);\n\tqh->tt_buffer_dirty = 0;\n\tschedule_ptds(hcd);\n\tspin_unlock_irqrestore(&priv->lock, spinflags);\n}\n\n\nstatic const struct hc_driver isp1760_hc_driver = {\n\t.description\t\t= \"isp1760-hcd\",\n\t.product_desc\t\t= \"NXP ISP1760 USB Host Controller\",\n\t.hcd_priv_size\t\t= sizeof(struct isp1760_hcd *),\n\t.irq\t\t\t= isp1760_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_USB2,\n\t.reset\t\t\t= isp1760_hc_setup,\n\t.start\t\t\t= isp1760_run,\n\t.stop\t\t\t= isp1760_stop,\n\t.shutdown\t\t= isp1760_shutdown,\n\t.urb_enqueue\t\t= isp1760_urb_enqueue,\n\t.urb_dequeue\t\t= isp1760_urb_dequeue,\n\t.endpoint_disable\t= isp1760_endpoint_disable,\n\t.get_frame_number\t= isp1760_get_frame,\n\t.hub_status_data\t= isp1760_hub_status_data,\n\t.hub_control\t\t= isp1760_hub_control,\n\t.clear_tt_buffer_complete\t= isp1760_clear_tt_buffer_complete,\n};\n\nint __init isp1760_init_kmem_once(void)\n{\n\turb_listitem_cachep = kmem_cache_create(\"isp1760_urb_listitem\",\n\t\t\tsizeof(struct urb_listitem), 0, SLAB_TEMPORARY |\n\t\t\tSLAB_MEM_SPREAD, NULL);\n\n\tif (!urb_listitem_cachep)\n\t\treturn -ENOMEM;\n\n\tqtd_cachep = kmem_cache_create(\"isp1760_qtd\",\n\t\t\tsizeof(struct isp1760_qtd), 0, SLAB_TEMPORARY |\n\t\t\tSLAB_MEM_SPREAD, NULL);\n\n\tif (!qtd_cachep)\n\t\tgoto destroy_urb_listitem;\n\n\tqh_cachep = kmem_cache_create(\"isp1760_qh\", sizeof(struct isp1760_qh),\n\t\t\t0, SLAB_TEMPORARY | SLAB_MEM_SPREAD, NULL);\n\n\tif (!qh_cachep)\n\t\tgoto destroy_qtd;\n\n\treturn 0;\n\ndestroy_qtd:\n\tkmem_cache_destroy(qtd_cachep);\n\ndestroy_urb_listitem:\n\tkmem_cache_destroy(urb_listitem_cachep);\n\n\treturn -ENOMEM;\n}\n\nvoid isp1760_deinit_kmem_cache(void)\n{\n\tkmem_cache_destroy(qtd_cachep);\n\tkmem_cache_destroy(qh_cachep);\n\tkmem_cache_destroy(urb_listitem_cachep);\n}\n\nint isp1760_hcd_register(struct isp1760_hcd *priv, struct resource *mem,\n\t\t\t int irq, unsigned long irqflags,\n\t\t\t struct device *dev)\n{\n\tconst struct isp1760_memory_layout *mem_layout = priv->memory_layout;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\n\thcd = usb_create_hcd(&isp1760_hc_driver, dev, dev_name(dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\t*(struct isp1760_hcd **)hcd->hcd_priv = priv;\n\n\tpriv->hcd = hcd;\n\n\tpriv->atl_slots = kcalloc(mem_layout->slot_num,\n\t\t\t\t  sizeof(struct isp1760_slotinfo), GFP_KERNEL);\n\tif (!priv->atl_slots) {\n\t\tret = -ENOMEM;\n\t\tgoto put_hcd;\n\t}\n\n\tpriv->int_slots = kcalloc(mem_layout->slot_num,\n\t\t\t\t  sizeof(struct isp1760_slotinfo), GFP_KERNEL);\n\tif (!priv->int_slots) {\n\t\tret = -ENOMEM;\n\t\tgoto free_atl_slots;\n\t}\n\n\tinit_memory(priv);\n\n\thcd->irq = irq;\n\thcd->rsrc_start = mem->start;\n\thcd->rsrc_len = resource_size(mem);\n\n\t \n\thcd->cant_recv_wakeups = 1;\n\n\tret = usb_add_hcd(hcd, irq, irqflags);\n\tif (ret)\n\t\tgoto free_int_slots;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\treturn 0;\n\nfree_int_slots:\n\tkfree(priv->int_slots);\nfree_atl_slots:\n\tkfree(priv->atl_slots);\nput_hcd:\n\tusb_put_hcd(hcd);\n\treturn ret;\n}\n\nvoid isp1760_hcd_unregister(struct isp1760_hcd *priv)\n{\n\tif (!priv->hcd)\n\t\treturn;\n\n\tusb_remove_hcd(priv->hcd);\n\tusb_put_hcd(priv->hcd);\n\tkfree(priv->atl_slots);\n\tkfree(priv->int_slots);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}