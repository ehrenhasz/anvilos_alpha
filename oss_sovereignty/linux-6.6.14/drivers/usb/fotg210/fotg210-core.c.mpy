{
  "module_name": "fotg210-core.c",
  "hash_id": "58d707eb0192d99a4dd3fdcc91deebc5bdc1ab4062ac95107a213f7d3e370b44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/fotg210/fotg210-core.c",
  "human_readable_source": "\n \n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/usb.h>\n#include <linux/usb/otg.h>\n\n#include \"fotg210.h\"\n\n \n#define FOTG210_RR\t\t\t0x80\n#define FOTG210_RR_ID\t\t\tBIT(21)  \n#define FOTG210_RR_CROLE\t\tBIT(20)  \n\n \n#define GEMINI_GLOBAL_MISC_CTRL\t\t0x30\n#define GEMINI_MISC_USB0_WAKEUP\t\tBIT(14)\n#define GEMINI_MISC_USB1_WAKEUP\t\tBIT(15)\n#define GEMINI_MISC_USB0_VBUS_ON\tBIT(22)\n#define GEMINI_MISC_USB1_VBUS_ON\tBIT(23)\n#define GEMINI_MISC_USB0_MINI_B\t\tBIT(29)\n#define GEMINI_MISC_USB1_MINI_B\t\tBIT(30)\n\nstatic int fotg210_gemini_init(struct fotg210 *fotg, struct resource *res,\n\t\t\t       enum usb_dr_mode mode)\n{\n\tstruct device *dev = fotg->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct regmap *map;\n\tbool wakeup;\n\tu32 mask, val;\n\tint ret;\n\n\tmap = syscon_regmap_lookup_by_phandle(np, \"syscon\");\n\tif (IS_ERR(map))\n\t\treturn dev_err_probe(dev, PTR_ERR(map), \"no syscon\\n\");\n\tfotg->map = map;\n\twakeup = of_property_read_bool(np, \"wakeup-source\");\n\n\t \n\tmask = 0;\n\tif (res->start == 0x69000000) {\n\t\tfotg->port = GEMINI_PORT_1;\n\t\tmask = GEMINI_MISC_USB1_VBUS_ON | GEMINI_MISC_USB1_MINI_B |\n\t\t\tGEMINI_MISC_USB1_WAKEUP;\n\t\tif (mode == USB_DR_MODE_HOST)\n\t\t\tval = GEMINI_MISC_USB1_VBUS_ON;\n\t\telse\n\t\t\tval = GEMINI_MISC_USB1_MINI_B;\n\t\tif (wakeup)\n\t\t\tval |= GEMINI_MISC_USB1_WAKEUP;\n\t} else {\n\t\tfotg->port = GEMINI_PORT_0;\n\t\tmask = GEMINI_MISC_USB0_VBUS_ON | GEMINI_MISC_USB0_MINI_B |\n\t\t\tGEMINI_MISC_USB0_WAKEUP;\n\t\tif (mode == USB_DR_MODE_HOST)\n\t\t\tval = GEMINI_MISC_USB0_VBUS_ON;\n\t\telse\n\t\t\tval = GEMINI_MISC_USB0_MINI_B;\n\t\tif (wakeup)\n\t\t\tval |= GEMINI_MISC_USB0_WAKEUP;\n\t}\n\n\tret = regmap_update_bits(map, GEMINI_GLOBAL_MISC_CTRL, mask, val);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to initialize Gemini PHY\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_info(dev, \"initialized Gemini PHY in %s mode\\n\",\n\t\t (mode == USB_DR_MODE_HOST) ? \"host\" : \"gadget\");\n\treturn 0;\n}\n\n \nvoid fotg210_vbus(struct fotg210 *fotg, bool enable)\n{\n\tu32 mask;\n\tu32 val;\n\tint ret;\n\n\tswitch (fotg->port) {\n\tcase GEMINI_PORT_0:\n\t\tmask = GEMINI_MISC_USB0_VBUS_ON;\n\t\tval = enable ? GEMINI_MISC_USB0_VBUS_ON : 0;\n\t\tbreak;\n\tcase GEMINI_PORT_1:\n\t\tmask = GEMINI_MISC_USB1_VBUS_ON;\n\t\tval = enable ? GEMINI_MISC_USB1_VBUS_ON : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tret = regmap_update_bits(fotg->map, GEMINI_GLOBAL_MISC_CTRL, mask, val);\n\tif (ret)\n\t\tdev_err(fotg->dev, \"failed to %s VBUS\\n\",\n\t\t\tenable ? \"enable\" : \"disable\");\n\tdev_info(fotg->dev, \"%s: %s VBUS\\n\", __func__, enable ? \"enable\" : \"disable\");\n}\n\nstatic int fotg210_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tenum usb_dr_mode mode;\n\tstruct fotg210 *fotg;\n\tu32 val;\n\tint ret;\n\n\tfotg = devm_kzalloc(dev, sizeof(*fotg), GFP_KERNEL);\n\tif (!fotg)\n\t\treturn -ENOMEM;\n\tfotg->dev = dev;\n\n\tfotg->base = devm_platform_get_and_ioremap_resource(pdev, 0, &fotg->res);\n\tif (IS_ERR(fotg->base))\n\t\treturn PTR_ERR(fotg->base);\n\n\tfotg->pclk = devm_clk_get_optional_enabled(dev, \"PCLK\");\n\tif (IS_ERR(fotg->pclk))\n\t\treturn PTR_ERR(fotg->pclk);\n\n\tmode = usb_get_dr_mode(dev);\n\n\tif (of_device_is_compatible(dev->of_node, \"cortina,gemini-usb\")) {\n\t\tret = fotg210_gemini_init(fotg, fotg->res, mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tval = readl(fotg->base + FOTG210_RR);\n\tif (mode == USB_DR_MODE_PERIPHERAL) {\n\t\tif (!(val & FOTG210_RR_CROLE))\n\t\t\tdev_err(dev, \"block not in device role\\n\");\n\t\tret = fotg210_udc_probe(pdev, fotg);\n\t} else {\n\t\tif (val & FOTG210_RR_CROLE)\n\t\t\tdev_err(dev, \"block not in host role\\n\");\n\t\tret = fotg210_hcd_probe(pdev, fotg);\n\t}\n\n\treturn ret;\n}\n\nstatic void fotg210_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tenum usb_dr_mode mode;\n\n\tmode = usb_get_dr_mode(dev);\n\n\tif (mode == USB_DR_MODE_PERIPHERAL)\n\t\tfotg210_udc_remove(pdev);\n\telse\n\t\tfotg210_hcd_remove(pdev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id fotg210_of_match[] = {\n\t{ .compatible = \"faraday,fotg200\" },\n\t{ .compatible = \"faraday,fotg210\" },\n\t \n\t{},\n};\nMODULE_DEVICE_TABLE(of, fotg210_of_match);\n#endif\n\nstatic struct platform_driver fotg210_driver = {\n\t.driver = {\n\t\t.name   = \"fotg210\",\n\t\t.of_match_table = of_match_ptr(fotg210_of_match),\n\t},\n\t.probe  = fotg210_probe,\n\t.remove_new = fotg210_remove,\n};\n\nstatic int __init fotg210_init(void)\n{\n\tif (IS_ENABLED(CONFIG_USB_FOTG210_HCD) && !usb_disabled())\n\t\tfotg210_hcd_init();\n\treturn platform_driver_register(&fotg210_driver);\n}\nmodule_init(fotg210_init);\n\nstatic void __exit fotg210_cleanup(void)\n{\n\tplatform_driver_unregister(&fotg210_driver);\n\tif (IS_ENABLED(CONFIG_USB_FOTG210_HCD))\n\t\tfotg210_hcd_cleanup();\n}\nmodule_exit(fotg210_cleanup);\n\nMODULE_AUTHOR(\"Yuan-Hsin Chen, Feng-Hsin Chiang\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"FOTG210 Dual Role Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}