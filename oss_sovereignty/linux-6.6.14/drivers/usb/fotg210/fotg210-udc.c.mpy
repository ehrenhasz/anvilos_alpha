{
  "module_name": "fotg210-udc.c",
  "hash_id": "7996187d333e9426051e9dfc9039c93d396ac3d3668ac6b3302fdb5e4df24d5a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/fotg210/fotg210-udc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/phy.h>\n\n#include \"fotg210.h\"\n#include \"fotg210-udc.h\"\n\n#define\tDRIVER_DESC\t\"FOTG210 USB Device Controller Driver\"\n#define\tDRIVER_VERSION\t\"30-April-2013\"\n\nstatic const char udc_name[] = \"fotg210_udc\";\nstatic const char * const fotg210_ep_name[] = {\n\t\"ep0\", \"ep1\", \"ep2\", \"ep3\", \"ep4\"};\n\nstatic void fotg210_ack_int(struct fotg210_udc *fotg210, u32 offset, u32 mask)\n{\n\tu32 value = ioread32(fotg210->reg + offset);\n\n\tvalue &= ~mask;\n\tiowrite32(value, fotg210->reg + offset);\n}\n\nstatic void fotg210_disable_fifo_int(struct fotg210_ep *ep)\n{\n\tu32 value = ioread32(ep->fotg210->reg + FOTG210_DMISGR1);\n\n\tif (ep->dir_in)\n\t\tvalue |= DMISGR1_MF_IN_INT(ep->epnum - 1);\n\telse\n\t\tvalue |= DMISGR1_MF_OUTSPK_INT(ep->epnum - 1);\n\tiowrite32(value, ep->fotg210->reg + FOTG210_DMISGR1);\n}\n\nstatic void fotg210_enable_fifo_int(struct fotg210_ep *ep)\n{\n\tu32 value = ioread32(ep->fotg210->reg + FOTG210_DMISGR1);\n\n\tif (ep->dir_in)\n\t\tvalue &= ~DMISGR1_MF_IN_INT(ep->epnum - 1);\n\telse\n\t\tvalue &= ~DMISGR1_MF_OUTSPK_INT(ep->epnum - 1);\n\tiowrite32(value, ep->fotg210->reg + FOTG210_DMISGR1);\n}\n\nstatic void fotg210_set_cxdone(struct fotg210_udc *fotg210)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_DCFESR);\n\n\tvalue |= DCFESR_CX_DONE;\n\tiowrite32(value, fotg210->reg + FOTG210_DCFESR);\n}\n\nstatic void fotg210_done(struct fotg210_ep *ep, struct fotg210_request *req,\n\t\t\tint status)\n{\n\tlist_del_init(&req->queue);\n\n\t \n\tif (ep->fotg210->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treq->req.status = -ESHUTDOWN;\n\telse\n\t\treq->req.status = status;\n\n\tspin_unlock(&ep->fotg210->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->fotg210->lock);\n\n\tif (ep->epnum) {\n\t\tif (list_empty(&ep->queue))\n\t\t\tfotg210_disable_fifo_int(ep);\n\t} else {\n\t\tfotg210_set_cxdone(ep->fotg210);\n\t}\n}\n\nstatic void fotg210_fifo_ep_mapping(struct fotg210_ep *ep, u32 epnum,\n\t\t\t\tu32 dir_in)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 val;\n\n\t \n\n\t \n\tval = ioread32(fotg210->reg + FOTG210_EPMAP);\n\tval &= ~EPMAP_FIFONOMSK(epnum, dir_in);\n\tval |= EPMAP_FIFONO(epnum, dir_in);\n\tiowrite32(val, fotg210->reg + FOTG210_EPMAP);\n\n\t \n\tval = ioread32(fotg210->reg + FOTG210_FIFOMAP);\n\tval &= ~FIFOMAP_EPNOMSK(epnum);\n\tval |= FIFOMAP_EPNO(epnum);\n\tiowrite32(val, fotg210->reg + FOTG210_FIFOMAP);\n\n\t \n\tval = ioread32(fotg210->reg + FOTG210_FIFOCF);\n\tval |= FIFOCF_FIFO_EN(epnum - 1);\n\tiowrite32(val, fotg210->reg + FOTG210_FIFOCF);\n}\n\nstatic void fotg210_set_fifo_dir(struct fotg210_ep *ep, u32 epnum, u32 dir_in)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 val;\n\n\tval = ioread32(fotg210->reg + FOTG210_FIFOMAP);\n\tval |= (dir_in ? FIFOMAP_DIRIN(epnum - 1) : FIFOMAP_DIROUT(epnum - 1));\n\tiowrite32(val, fotg210->reg + FOTG210_FIFOMAP);\n}\n\nstatic void fotg210_set_tfrtype(struct fotg210_ep *ep, u32 epnum, u32 type)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 val;\n\n\tval = ioread32(fotg210->reg + FOTG210_FIFOCF);\n\tval |= FIFOCF_TYPE(type, epnum - 1);\n\tiowrite32(val, fotg210->reg + FOTG210_FIFOCF);\n}\n\nstatic void fotg210_set_mps(struct fotg210_ep *ep, u32 epnum, u32 mps,\n\t\t\t\tu32 dir_in)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 val;\n\tu32 offset = dir_in ? FOTG210_INEPMPSR(epnum) :\n\t\t\t\tFOTG210_OUTEPMPSR(epnum);\n\n\tval = ioread32(fotg210->reg + offset);\n\tval |= INOUTEPMPSR_MPS(mps);\n\tiowrite32(val, fotg210->reg + offset);\n}\n\nstatic int fotg210_config_ep(struct fotg210_ep *ep,\n\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\n\tfotg210_set_fifo_dir(ep, ep->epnum, ep->dir_in);\n\tfotg210_set_tfrtype(ep, ep->epnum, ep->type);\n\tfotg210_set_mps(ep, ep->epnum, ep->ep.maxpacket, ep->dir_in);\n\tfotg210_fifo_ep_mapping(ep, ep->epnum, ep->dir_in);\n\n\tfotg210->ep[ep->epnum] = ep;\n\n\treturn 0;\n}\n\nstatic int fotg210_ep_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct fotg210_ep *ep;\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\n\tep->desc = desc;\n\tep->epnum = usb_endpoint_num(desc);\n\tep->type = usb_endpoint_type(desc);\n\tep->dir_in = usb_endpoint_dir_in(desc);\n\tep->ep.maxpacket = usb_endpoint_maxp(desc);\n\n\treturn fotg210_config_ep(ep, desc);\n}\n\nstatic void fotg210_reset_tseq(struct fotg210_udc *fotg210, u8 epnum)\n{\n\tstruct fotg210_ep *ep = fotg210->ep[epnum];\n\tu32 value;\n\tvoid __iomem *reg;\n\n\treg = (ep->dir_in) ?\n\t\tfotg210->reg + FOTG210_INEPMPSR(epnum) :\n\t\tfotg210->reg + FOTG210_OUTEPMPSR(epnum);\n\n\t \n\n\tvalue = ioread32(reg);\n\tvalue |= INOUTEPMPSR_RESET_TSEQ;\n\tiowrite32(value, reg);\n\n\tvalue = ioread32(reg);\n\tvalue &= ~INOUTEPMPSR_RESET_TSEQ;\n\tiowrite32(value, reg);\n}\n\nstatic int fotg210_ep_release(struct fotg210_ep *ep)\n{\n\tif (!ep->epnum)\n\t\treturn 0;\n\tep->epnum = 0;\n\tep->stall = 0;\n\tep->wedged = 0;\n\n\tfotg210_reset_tseq(ep->fotg210, ep->epnum);\n\n\treturn 0;\n}\n\nstatic int fotg210_ep_disable(struct usb_ep *_ep)\n{\n\tstruct fotg210_ep *ep;\n\tstruct fotg210_request *req;\n\tunsigned long flags;\n\n\tBUG_ON(!_ep);\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct fotg210_request, queue);\n\t\tspin_lock_irqsave(&ep->fotg210->lock, flags);\n\t\tfotg210_done(ep, req, -ECONNRESET);\n\t\tspin_unlock_irqrestore(&ep->fotg210->lock, flags);\n\t}\n\n\treturn fotg210_ep_release(ep);\n}\n\nstatic struct usb_request *fotg210_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\tgfp_t gfp_flags)\n{\n\tstruct fotg210_request *req;\n\n\treq = kzalloc(sizeof(struct fotg210_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void fotg210_ep_free_request(struct usb_ep *_ep,\n\t\t\t\t\tstruct usb_request *_req)\n{\n\tstruct fotg210_request *req;\n\n\treq = container_of(_req, struct fotg210_request, req);\n\tkfree(req);\n}\n\nstatic void fotg210_enable_dma(struct fotg210_ep *ep,\n\t\t\t      dma_addr_t d, u32 len)\n{\n\tu32 value;\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMACPSR1);\n\tvalue &= ~(DMACPSR1_DMA_LEN(0xFFFF) | DMACPSR1_DMA_TYPE(1));\n\tvalue |= DMACPSR1_DMA_LEN(len) | DMACPSR1_DMA_TYPE(ep->dir_in);\n\tiowrite32(value, fotg210->reg + FOTG210_DMACPSR1);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMATFNR);\n\tif (ep->epnum)\n\t\tvalue |= DMATFNR_ACC_FN(ep->epnum - 1);\n\telse\n\t\tvalue |= DMATFNR_ACC_CXF;\n\tiowrite32(value, fotg210->reg + FOTG210_DMATFNR);\n\n\t \n\tiowrite32(d, fotg210->reg + FOTG210_DMACPSR2);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMISGR2);\n\tvalue &= ~(DMISGR2_MDMA_CMPLT | DMISGR2_MDMA_ERROR);\n\tiowrite32(value, fotg210->reg + FOTG210_DMISGR2);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMACPSR1);\n\tvalue |= DMACPSR1_DMA_START;\n\tiowrite32(value, fotg210->reg + FOTG210_DMACPSR1);\n}\n\nstatic void fotg210_disable_dma(struct fotg210_ep *ep)\n{\n\tiowrite32(DMATFNR_DISDMA, ep->fotg210->reg + FOTG210_DMATFNR);\n}\n\nstatic void fotg210_wait_dma_done(struct fotg210_ep *ep)\n{\n\tu32 value;\n\n\tdo {\n\t\tvalue = ioread32(ep->fotg210->reg + FOTG210_DISGR2);\n\t\tif ((value & DISGR2_USBRST_INT) ||\n\t\t    (value & DISGR2_DMA_ERROR))\n\t\t\tgoto dma_reset;\n\t} while (!(value & DISGR2_DMA_CMPLT));\n\n\tfotg210_ack_int(ep->fotg210, FOTG210_DISGR2, DISGR2_DMA_CMPLT);\n\treturn;\n\ndma_reset:\n\tvalue = ioread32(ep->fotg210->reg + FOTG210_DMACPSR1);\n\tvalue |= DMACPSR1_DMA_ABORT;\n\tiowrite32(value, ep->fotg210->reg + FOTG210_DMACPSR1);\n\n\t \n\tif (ep->epnum) {\n\t\tvalue = ioread32(ep->fotg210->reg +\n\t\t\t\tFOTG210_FIBCR(ep->epnum - 1));\n\t\tvalue |= FIBCR_FFRST;\n\t\tiowrite32(value, ep->fotg210->reg +\n\t\t\t\tFOTG210_FIBCR(ep->epnum - 1));\n\t} else {\n\t\tvalue = ioread32(ep->fotg210->reg + FOTG210_DCFESR);\n\t\tvalue |= DCFESR_CX_CLR;\n\t\tiowrite32(value, ep->fotg210->reg + FOTG210_DCFESR);\n\t}\n}\n\nstatic void fotg210_start_dma(struct fotg210_ep *ep,\n\t\t\tstruct fotg210_request *req)\n{\n\tstruct device *dev = &ep->fotg210->gadget.dev;\n\tdma_addr_t d;\n\tu8 *buffer;\n\tu32 length;\n\n\tif (ep->epnum) {\n\t\tif (ep->dir_in) {\n\t\t\tbuffer = req->req.buf;\n\t\t\tlength = req->req.length;\n\t\t} else {\n\t\t\tbuffer = req->req.buf + req->req.actual;\n\t\t\tlength = ioread32(ep->fotg210->reg +\n\t\t\t\t\tFOTG210_FIBCR(ep->epnum - 1)) & FIBCR_BCFX;\n\t\t\tif (length > req->req.length - req->req.actual)\n\t\t\t\tlength = req->req.length - req->req.actual;\n\t\t}\n\t} else {\n\t\tbuffer = req->req.buf + req->req.actual;\n\t\tif (req->req.length - req->req.actual > ep->ep.maxpacket)\n\t\t\tlength = ep->ep.maxpacket;\n\t\telse\n\t\t\tlength = req->req.length - req->req.actual;\n\t}\n\n\td = dma_map_single(dev, buffer, length,\n\t\t\tep->dir_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(dev, d)) {\n\t\tpr_err(\"dma_mapping_error\\n\");\n\t\treturn;\n\t}\n\n\tfotg210_enable_dma(ep, d, length);\n\n\t \n\tfotg210_wait_dma_done(ep);\n\n\tfotg210_disable_dma(ep);\n\n\t \n\treq->req.actual += length;\n\n\tdma_unmap_single(dev, d, length, DMA_TO_DEVICE);\n}\n\nstatic void fotg210_ep0_queue(struct fotg210_ep *ep,\n\t\t\t\tstruct fotg210_request *req)\n{\n\tif (!req->req.length) {\n\t\tfotg210_done(ep, req, 0);\n\t\treturn;\n\t}\n\tif (ep->dir_in) {  \n\t\tfotg210_start_dma(ep, req);\n\t\tif (req->req.length == req->req.actual)\n\t\t\tfotg210_done(ep, req, 0);\n\t} else {  \n\t\tu32 value = ioread32(ep->fotg210->reg + FOTG210_DMISGR0);\n\n\t\tvalue &= ~DMISGR0_MCX_OUT_INT;\n\t\tiowrite32(value, ep->fotg210->reg + FOTG210_DMISGR0);\n\t}\n}\n\nstatic int fotg210_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t\tgfp_t gfp_flags)\n{\n\tstruct fotg210_ep *ep;\n\tstruct fotg210_request *req;\n\tunsigned long flags;\n\tint request = 0;\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\treq = container_of(_req, struct fotg210_request, req);\n\n\tif (ep->fotg210->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&ep->fotg210->lock, flags);\n\n\tif (list_empty(&ep->queue))\n\t\trequest = 1;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\n\tif (!ep->epnum)  \n\t\tfotg210_ep0_queue(ep, req);\n\telse if (request && !ep->stall)\n\t\tfotg210_enable_fifo_int(ep);\n\n\tspin_unlock_irqrestore(&ep->fotg210->lock, flags);\n\n\treturn 0;\n}\n\nstatic int fotg210_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct fotg210_ep *ep;\n\tstruct fotg210_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\treq = container_of(_req, struct fotg210_request, req);\n\n\tspin_lock_irqsave(&ep->fotg210->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\tfotg210_done(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&ep->fotg210->lock, flags);\n\n\treturn 0;\n}\n\nstatic void fotg210_set_epnstall(struct fotg210_ep *ep)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 value;\n\tvoid __iomem *reg;\n\n\t \n\tif (ep->dir_in) {\n\t\tdo {\n\t\t\tvalue = ioread32(fotg210->reg + FOTG210_DCFESR);\n\t\t} while (!(value & DCFESR_FIFO_EMPTY(ep->epnum - 1)));\n\t}\n\n\treg = (ep->dir_in) ?\n\t\tfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\n\t\tfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\n\tvalue = ioread32(reg);\n\tvalue |= INOUTEPMPSR_STL_EP;\n\tiowrite32(value, reg);\n}\n\nstatic void fotg210_clear_epnstall(struct fotg210_ep *ep)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 value;\n\tvoid __iomem *reg;\n\n\treg = (ep->dir_in) ?\n\t\tfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\n\t\tfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\n\tvalue = ioread32(reg);\n\tvalue &= ~INOUTEPMPSR_STL_EP;\n\tiowrite32(value, reg);\n}\n\nstatic int fotg210_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedge)\n{\n\tstruct fotg210_ep *ep;\n\tstruct fotg210_udc *fotg210;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\n\tfotg210 = ep->fotg210;\n\n\tspin_lock_irqsave(&ep->fotg210->lock, flags);\n\n\tif (value) {\n\t\tfotg210_set_epnstall(ep);\n\t\tep->stall = 1;\n\t\tif (wedge)\n\t\t\tep->wedged = 1;\n\t} else {\n\t\tfotg210_reset_tseq(fotg210, ep->epnum);\n\t\tfotg210_clear_epnstall(ep);\n\t\tep->stall = 0;\n\t\tep->wedged = 0;\n\t\tif (!list_empty(&ep->queue))\n\t\t\tfotg210_enable_fifo_int(ep);\n\t}\n\n\tspin_unlock_irqrestore(&ep->fotg210->lock, flags);\n\treturn 0;\n}\n\nstatic int fotg210_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn fotg210_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int fotg210_ep_set_wedge(struct usb_ep *_ep)\n{\n\treturn fotg210_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic void fotg210_ep_fifo_flush(struct usb_ep *_ep)\n{\n}\n\nstatic const struct usb_ep_ops fotg210_ep_ops = {\n\t.enable\t\t= fotg210_ep_enable,\n\t.disable\t= fotg210_ep_disable,\n\n\t.alloc_request\t= fotg210_ep_alloc_request,\n\t.free_request\t= fotg210_ep_free_request,\n\n\t.queue\t\t= fotg210_ep_queue,\n\t.dequeue\t= fotg210_ep_dequeue,\n\n\t.set_halt\t= fotg210_ep_set_halt,\n\t.fifo_flush\t= fotg210_ep_fifo_flush,\n\t.set_wedge\t= fotg210_ep_set_wedge,\n};\n\nstatic void fotg210_clear_tx0byte(struct fotg210_udc *fotg210)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_TX0BYTE);\n\n\tvalue &= ~(TX0BYTE_EP1 | TX0BYTE_EP2 | TX0BYTE_EP3\n\t\t   | TX0BYTE_EP4);\n\tiowrite32(value, fotg210->reg + FOTG210_TX0BYTE);\n}\n\nstatic void fotg210_clear_rx0byte(struct fotg210_udc *fotg210)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_RX0BYTE);\n\n\tvalue &= ~(RX0BYTE_EP1 | RX0BYTE_EP2 | RX0BYTE_EP3\n\t\t   | RX0BYTE_EP4);\n\tiowrite32(value, fotg210->reg + FOTG210_RX0BYTE);\n}\n\n \nstatic void fotg210_rdsetupp(struct fotg210_udc *fotg210,\n\t\t   u8 *buffer)\n{\n\tint i = 0;\n\tu8 *tmp = buffer;\n\tu32 data;\n\tu32 length = 8;\n\n\tiowrite32(DMATFNR_ACC_CXF, fotg210->reg + FOTG210_DMATFNR);\n\n\tfor (i = (length >> 2); i > 0; i--) {\n\t\tdata = ioread32(fotg210->reg + FOTG210_CXPORT);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\t*(tmp + 3) = (data >> 24) & 0xFF;\n\t\ttmp = tmp + 4;\n\t}\n\n\tswitch (length % 4) {\n\tcase 1:\n\t\tdata = ioread32(fotg210->reg + FOTG210_CXPORT);\n\t\t*tmp = data & 0xFF;\n\t\tbreak;\n\tcase 2:\n\t\tdata = ioread32(fotg210->reg + FOTG210_CXPORT);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\tbreak;\n\tcase 3:\n\t\tdata = ioread32(fotg210->reg + FOTG210_CXPORT);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tiowrite32(DMATFNR_DISDMA, fotg210->reg + FOTG210_DMATFNR);\n}\n\nstatic void fotg210_set_configuration(struct fotg210_udc *fotg210)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_DAR);\n\n\tvalue |= DAR_AFT_CONF;\n\tiowrite32(value, fotg210->reg + FOTG210_DAR);\n}\n\nstatic void fotg210_set_dev_addr(struct fotg210_udc *fotg210, u32 addr)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_DAR);\n\n\tvalue |= (addr & 0x7F);\n\tiowrite32(value, fotg210->reg + FOTG210_DAR);\n}\n\nstatic void fotg210_set_cxstall(struct fotg210_udc *fotg210)\n{\n\tu32 value = ioread32(fotg210->reg + FOTG210_DCFESR);\n\n\tvalue |= DCFESR_CX_STL;\n\tiowrite32(value, fotg210->reg + FOTG210_DCFESR);\n}\n\nstatic void fotg210_request_error(struct fotg210_udc *fotg210)\n{\n\tfotg210_set_cxstall(fotg210);\n\tpr_err(\"request error!!\\n\");\n}\n\nstatic void fotg210_set_address(struct fotg210_udc *fotg210,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tif (le16_to_cpu(ctrl->wValue) >= 0x0100) {\n\t\tfotg210_request_error(fotg210);\n\t} else {\n\t\tfotg210_set_dev_addr(fotg210, le16_to_cpu(ctrl->wValue));\n\t\tfotg210_set_cxdone(fotg210);\n\t}\n}\n\nstatic void fotg210_set_feature(struct fotg210_udc *fotg210,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tfotg210_set_cxdone(fotg210);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tfotg210_set_cxdone(fotg210);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tu8 epnum;\n\t\tepnum = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum)\n\t\t\tfotg210_set_epnstall(fotg210->ep[epnum]);\n\t\telse\n\t\t\tfotg210_set_cxstall(fotg210);\n\t\tfotg210_set_cxdone(fotg210);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfotg210_request_error(fotg210);\n\t\tbreak;\n\t}\n}\n\nstatic void fotg210_clear_feature(struct fotg210_udc *fotg210,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tstruct fotg210_ep *ep =\n\t\tfotg210->ep[ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK];\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tfotg210_set_cxdone(fotg210);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tfotg210_set_cxdone(fotg210);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK) {\n\t\t\tif (ep->wedged) {\n\t\t\t\tfotg210_set_cxdone(fotg210);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep->stall)\n\t\t\t\tfotg210_set_halt_and_wedge(&ep->ep, 0, 0);\n\t\t}\n\t\tfotg210_set_cxdone(fotg210);\n\t\tbreak;\n\tdefault:\n\t\tfotg210_request_error(fotg210);\n\t\tbreak;\n\t}\n}\n\nstatic int fotg210_is_epnstall(struct fotg210_ep *ep)\n{\n\tstruct fotg210_udc *fotg210 = ep->fotg210;\n\tu32 value;\n\tvoid __iomem *reg;\n\n\treg = (ep->dir_in) ?\n\t\tfotg210->reg + FOTG210_INEPMPSR(ep->epnum) :\n\t\tfotg210->reg + FOTG210_OUTEPMPSR(ep->epnum);\n\tvalue = ioread32(reg);\n\treturn value & INOUTEPMPSR_STL_EP ? 1 : 0;\n}\n\n \nstatic void fotg210_ep0_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tstruct fotg210_ep *ep;\n\tstruct fotg210_udc *fotg210;\n\n\tep = container_of(_ep, struct fotg210_ep, ep);\n\tfotg210 = ep->fotg210;\n\n\tif (req->status || req->actual != req->length) {\n\t\tdev_warn(&fotg210->gadget.dev, \"EP0 request failed: %d\\n\", req->status);\n\t}\n}\n\nstatic void fotg210_get_status(struct fotg210_udc *fotg210,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tu8 epnum;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tfotg210->ep0_data = cpu_to_le16(1 << USB_DEVICE_SELF_POWERED);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tfotg210->ep0_data = cpu_to_le16(0);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum)\n\t\t\tfotg210->ep0_data =\n\t\t\t\tcpu_to_le16(fotg210_is_epnstall(fotg210->ep[epnum])\n\t\t\t\t\t    << USB_ENDPOINT_HALT);\n\t\telse\n\t\t\tfotg210_request_error(fotg210);\n\t\tbreak;\n\n\tdefault:\n\t\tfotg210_request_error(fotg210);\n\t\treturn;\t\t \n\t}\n\n\tfotg210->ep0_req->buf = &fotg210->ep0_data;\n\tfotg210->ep0_req->length = 2;\n\n\tspin_unlock(&fotg210->lock);\n\tfotg210_ep_queue(fotg210->gadget.ep0, fotg210->ep0_req, GFP_ATOMIC);\n\tspin_lock(&fotg210->lock);\n}\n\nstatic int fotg210_setup_packet(struct fotg210_udc *fotg210,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tu8 *p = (u8 *)ctrl;\n\tu8 ret = 0;\n\n\tfotg210_rdsetupp(fotg210, p);\n\n\tfotg210->ep[0]->dir_in = ctrl->bRequestType & USB_DIR_IN;\n\n\tif (fotg210->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tu32 value = ioread32(fotg210->reg + FOTG210_DMCR);\n\t\tfotg210->gadget.speed = value & DMCR_HS_EN ?\n\t\t\t\tUSB_SPEED_HIGH : USB_SPEED_FULL;\n\t}\n\n\t \n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tfotg210_get_status(fotg210, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tfotg210_clear_feature(fotg210, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tfotg210_set_feature(fotg210, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tfotg210_set_address(fotg210, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tfotg210_set_configuration(fotg210);\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void fotg210_ep0out(struct fotg210_udc *fotg210)\n{\n\tstruct fotg210_ep *ep = fotg210->ep[0];\n\n\tif (!list_empty(&ep->queue) && !ep->dir_in) {\n\t\tstruct fotg210_request *req;\n\n\t\treq = list_first_entry(&ep->queue,\n\t\t\tstruct fotg210_request, queue);\n\n\t\tif (req->req.length)\n\t\t\tfotg210_start_dma(ep, req);\n\n\t\tif ((req->req.length - req->req.actual) < ep->ep.maxpacket)\n\t\t\tfotg210_done(ep, req, 0);\n\t} else {\n\t\tpr_err(\"%s : empty queue\\n\", __func__);\n\t}\n}\n\nstatic void fotg210_ep0in(struct fotg210_udc *fotg210)\n{\n\tstruct fotg210_ep *ep = fotg210->ep[0];\n\n\tif ((!list_empty(&ep->queue)) && (ep->dir_in)) {\n\t\tstruct fotg210_request *req;\n\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct fotg210_request, queue);\n\n\t\tif (req->req.length)\n\t\t\tfotg210_start_dma(ep, req);\n\n\t\tif (req->req.actual == req->req.length)\n\t\t\tfotg210_done(ep, req, 0);\n\t} else {\n\t\tfotg210_set_cxdone(fotg210);\n\t}\n}\n\nstatic void fotg210_in_fifo_handler(struct fotg210_ep *ep)\n{\n\tstruct fotg210_request *req = list_entry(ep->queue.next,\n\t\t\t\t\tstruct fotg210_request, queue);\n\n\tif (req->req.length)\n\t\tfotg210_start_dma(ep, req);\n\tfotg210_done(ep, req, 0);\n}\n\nstatic void fotg210_out_fifo_handler(struct fotg210_ep *ep)\n{\n\tstruct fotg210_request *req = list_entry(ep->queue.next,\n\t\t\t\t\t\t struct fotg210_request, queue);\n\tint disgr1 = ioread32(ep->fotg210->reg + FOTG210_DISGR1);\n\n\tfotg210_start_dma(ep, req);\n\n\t \n\n\tif (req->req.length == req->req.actual ||\n\t    (disgr1 & DISGR1_SPK_INT(ep->epnum - 1)))\n\t\tfotg210_done(ep, req, 0);\n}\n\nstatic irqreturn_t fotg210_irq(int irq, void *_fotg210)\n{\n\tstruct fotg210_udc *fotg210 = _fotg210;\n\tu32 int_grp = ioread32(fotg210->reg + FOTG210_DIGR);\n\tu32 int_msk = ioread32(fotg210->reg + FOTG210_DMIGR);\n\n\tint_grp &= ~int_msk;\n\n\tspin_lock(&fotg210->lock);\n\n\tif (int_grp & DIGR_INT_G2) {\n\t\tvoid __iomem *reg = fotg210->reg + FOTG210_DISGR2;\n\t\tu32 int_grp2 = ioread32(reg);\n\t\tu32 int_msk2 = ioread32(fotg210->reg + FOTG210_DMISGR2);\n\n\t\tint_grp2 &= ~int_msk2;\n\n\t\tif (int_grp2 & DISGR2_USBRST_INT) {\n\t\t\tusb_gadget_udc_reset(&fotg210->gadget,\n\t\t\t\t\t     fotg210->driver);\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_USBRST_INT);\n\t\t\tpr_info(\"fotg210 udc reset\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_SUSP_INT) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_SUSP_INT);\n\t\t\tpr_info(\"fotg210 udc suspend\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_RESM_INT) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_RESM_INT);\n\t\t\tpr_info(\"fotg210 udc resume\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_ISO_SEQ_ERR_INT) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_ISO_SEQ_ERR_INT);\n\t\t\tpr_info(\"fotg210 iso sequence error\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_ISO_SEQ_ABORT_INT) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_ISO_SEQ_ABORT_INT);\n\t\t\tpr_info(\"fotg210 iso sequence abort\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_TX0BYTE_INT) {\n\t\t\tfotg210_clear_tx0byte(fotg210);\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_TX0BYTE_INT);\n\t\t\tpr_info(\"fotg210 transferred 0 byte\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_RX0BYTE_INT) {\n\t\t\tfotg210_clear_rx0byte(fotg210);\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_RX0BYTE_INT);\n\t\t\tpr_info(\"fotg210 received 0 byte\\n\");\n\t\t}\n\t\tif (int_grp2 & DISGR2_DMA_ERROR) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR2, DISGR2_DMA_ERROR);\n\t\t}\n\t}\n\n\tif (int_grp & DIGR_INT_G0) {\n\t\tvoid __iomem *reg = fotg210->reg + FOTG210_DISGR0;\n\t\tu32 int_grp0 = ioread32(reg);\n\t\tu32 int_msk0 = ioread32(fotg210->reg + FOTG210_DMISGR0);\n\t\tstruct usb_ctrlrequest ctrl;\n\n\t\tint_grp0 &= ~int_msk0;\n\n\t\t \n\t\tif (int_grp0 & DISGR0_CX_COMABT_INT) {\n\t\t\tfotg210_ack_int(fotg210, FOTG210_DISGR0, DISGR0_CX_COMABT_INT);\n\t\t\tpr_info(\"fotg210 CX command abort\\n\");\n\t\t}\n\n\t\tif (int_grp0 & DISGR0_CX_SETUP_INT) {\n\t\t\tif (fotg210_setup_packet(fotg210, &ctrl)) {\n\t\t\t\tspin_unlock(&fotg210->lock);\n\t\t\t\tif (fotg210->driver->setup(&fotg210->gadget,\n\t\t\t\t\t\t\t   &ctrl) < 0)\n\t\t\t\t\tfotg210_set_cxstall(fotg210);\n\t\t\t\tspin_lock(&fotg210->lock);\n\t\t\t}\n\t\t}\n\t\tif (int_grp0 & DISGR0_CX_COMEND_INT)\n\t\t\tpr_info(\"fotg210 cmd end\\n\");\n\n\t\tif (int_grp0 & DISGR0_CX_IN_INT)\n\t\t\tfotg210_ep0in(fotg210);\n\n\t\tif (int_grp0 & DISGR0_CX_OUT_INT)\n\t\t\tfotg210_ep0out(fotg210);\n\n\t\tif (int_grp0 & DISGR0_CX_COMFAIL_INT) {\n\t\t\tfotg210_set_cxstall(fotg210);\n\t\t\tpr_info(\"fotg210 ep0 fail\\n\");\n\t\t}\n\t}\n\n\tif (int_grp & DIGR_INT_G1) {\n\t\tvoid __iomem *reg = fotg210->reg + FOTG210_DISGR1;\n\t\tu32 int_grp1 = ioread32(reg);\n\t\tu32 int_msk1 = ioread32(fotg210->reg + FOTG210_DMISGR1);\n\t\tint fifo;\n\n\t\tint_grp1 &= ~int_msk1;\n\n\t\tfor (fifo = 0; fifo < FOTG210_MAX_FIFO_NUM; fifo++) {\n\t\t\tif (int_grp1 & DISGR1_IN_INT(fifo))\n\t\t\t\tfotg210_in_fifo_handler(fotg210->ep[fifo + 1]);\n\n\t\t\tif ((int_grp1 & DISGR1_OUT_INT(fifo)) ||\n\t\t\t    (int_grp1 & DISGR1_SPK_INT(fifo)))\n\t\t\t\tfotg210_out_fifo_handler(fotg210->ep[fifo + 1]);\n\t\t}\n\t}\n\n\tspin_unlock(&fotg210->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fotg210_disable_unplug(struct fotg210_udc *fotg210)\n{\n\tu32 reg = ioread32(fotg210->reg + FOTG210_PHYTMSR);\n\n\treg &= ~PHYTMSR_UNPLUG;\n\tiowrite32(reg, fotg210->reg + FOTG210_PHYTMSR);\n}\n\nstatic int fotg210_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct fotg210_udc *fotg210 = gadget_to_fotg210(g);\n\tu32 value;\n\tint ret;\n\n\t \n\tfotg210->driver = driver;\n\tfotg210->gadget.dev.of_node = fotg210->dev->of_node;\n\tfotg210->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tdev_info(fotg210->dev, \"bound driver %s\\n\", driver->driver.name);\n\n\tif (!IS_ERR_OR_NULL(fotg210->phy)) {\n\t\tret = otg_set_peripheral(fotg210->phy->otg,\n\t\t\t\t\t &fotg210->gadget);\n\t\tif (ret)\n\t\t\tdev_err(fotg210->dev, \"can't bind to phy\\n\");\n\t}\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMCR);\n\tvalue |= DMCR_CHIP_EN;\n\tiowrite32(value, fotg210->reg + FOTG210_DMCR);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMCR);\n\tvalue |= DMCR_GLINT_EN;\n\tiowrite32(value, fotg210->reg + FOTG210_DMCR);\n\n\treturn 0;\n}\n\nstatic void fotg210_init(struct fotg210_udc *fotg210)\n{\n\tu32 value;\n\n\t \n\tiowrite32(GMIR_MHC_INT | GMIR_MOTG_INT | GMIR_INT_POLARITY,\n\t\t  fotg210->reg + FOTG210_GMIR);\n\n\t \n\tiowrite32(~(DMIGR_MINT_G0 | DMIGR_MINT_G1 | DMIGR_MINT_G2),\n\t\t  fotg210->reg + FOTG210_DMIGR);\n\n\t \n\tiowrite32(DMCR_SFRST, fotg210->reg + FOTG210_DMCR);\n\t \n\tusleep_range(100, 200);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMCR);\n\tvalue &= ~DMCR_GLINT_EN;\n\tiowrite32(value, fotg210->reg + FOTG210_DMCR);\n\n\t \n\tiowrite32(~(DISGR2_DMA_ERROR | DISGR2_RX0BYTE_INT | DISGR2_TX0BYTE_INT\n\t\t    | DISGR2_ISO_SEQ_ABORT_INT | DISGR2_ISO_SEQ_ERR_INT\n\t\t    | DISGR2_RESM_INT | DISGR2_SUSP_INT | DISGR2_USBRST_INT),\n\t\t  fotg210->reg + FOTG210_DMISGR2);\n\n\t \n\tiowrite32(~(u32)0, fotg210->reg + FOTG210_DMISGR1);\n\n\t \n\tvalue = ioread32(fotg210->reg + FOTG210_DMISGR0);\n\tvalue |= DMISGR0_MCX_COMEND;\n\tiowrite32(value, fotg210->reg + FOTG210_DMISGR0);\n}\n\nstatic int fotg210_udc_stop(struct usb_gadget *g)\n{\n\tstruct fotg210_udc *fotg210 = gadget_to_fotg210(g);\n\tunsigned long\tflags;\n\n\tif (!IS_ERR_OR_NULL(fotg210->phy))\n\t\treturn otg_set_peripheral(fotg210->phy->otg, NULL);\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\tfotg210_init(fotg210);\n\tfotg210->driver = NULL;\n\tfotg210->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int fotg210_vbus_session(struct usb_gadget *g, int is_active)\n{\n\tstruct fotg210_udc *fotg210 = gadget_to_fotg210(g);\n\n\t \n\tfotg210_vbus(fotg210->fotg, is_active);\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops fotg210_gadget_ops = {\n\t.udc_start\t\t= fotg210_udc_start,\n\t.udc_stop\t\t= fotg210_udc_stop,\n\t.vbus_session\t\t= fotg210_vbus_session,\n};\n\n \nstatic int fotg210_phy_event(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct usb_gadget *gadget = data;\n\n\tif (!gadget)\n\t\treturn NOTIFY_DONE;\n\n\tswitch (action) {\n\tcase USB_EVENT_VBUS:\n\t\tusb_gadget_vbus_connect(gadget);\n\t\treturn NOTIFY_OK;\n\tcase USB_EVENT_NONE:\n\t\tusb_gadget_vbus_disconnect(gadget);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block fotg210_phy_notifier = {\n\t.notifier_call = fotg210_phy_event,\n};\n\nint fotg210_udc_remove(struct platform_device *pdev)\n{\n\tstruct fotg210_udc *fotg210 = platform_get_drvdata(pdev);\n\tint i;\n\n\tusb_del_gadget_udc(&fotg210->gadget);\n\tif (!IS_ERR_OR_NULL(fotg210->phy)) {\n\t\tusb_unregister_notifier(fotg210->phy, &fotg210_phy_notifier);\n\t\tusb_put_phy(fotg210->phy);\n\t}\n\tiounmap(fotg210->reg);\n\tfree_irq(platform_get_irq(pdev, 0), fotg210);\n\n\tfotg210_ep_free_request(&fotg210->ep[0]->ep, fotg210->ep0_req);\n\tfor (i = 0; i < FOTG210_MAX_NUM_EP; i++)\n\t\tkfree(fotg210->ep[i]);\n\n\tkfree(fotg210);\n\n\treturn 0;\n}\n\nint fotg210_udc_probe(struct platform_device *pdev, struct fotg210 *fotg)\n{\n\tstruct fotg210_udc *fotg210 = NULL;\n\tstruct device *dev = &pdev->dev;\n\tint irq;\n\tint ret = 0;\n\tint i;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tfotg210 = kzalloc(sizeof(struct fotg210_udc), GFP_KERNEL);\n\tif (fotg210 == NULL)\n\t\treturn -ENOMEM;\n\n\tfotg210->dev = dev;\n\tfotg210->fotg = fotg;\n\n\tfotg210->phy = devm_usb_get_phy_by_phandle(dev, \"usb-phy\", 0);\n\tif (IS_ERR(fotg210->phy)) {\n\t\tret = PTR_ERR(fotg210->phy);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_free;\n\t\tdev_info(dev, \"no PHY found\\n\");\n\t\tfotg210->phy = NULL;\n\t} else {\n\t\tret = usb_phy_init(fotg210->phy);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t\tdev_info(dev, \"found and initialized PHY\\n\");\n\t}\n\n\tret = -ENOMEM;\n\n\tfor (i = 0; i < FOTG210_MAX_NUM_EP; i++) {\n\t\tfotg210->ep[i] = kzalloc(sizeof(struct fotg210_ep), GFP_KERNEL);\n\t\tif (!fotg210->ep[i])\n\t\t\tgoto err_alloc;\n\t}\n\n\tfotg210->reg = fotg->base;\n\n\tspin_lock_init(&fotg210->lock);\n\n\tplatform_set_drvdata(pdev, fotg210);\n\n\tfotg210->gadget.ops = &fotg210_gadget_ops;\n\n\tfotg210->gadget.max_speed = USB_SPEED_HIGH;\n\tfotg210->gadget.dev.parent = dev;\n\tfotg210->gadget.dev.dma_mask = dev->dma_mask;\n\tfotg210->gadget.name = udc_name;\n\n\tINIT_LIST_HEAD(&fotg210->gadget.ep_list);\n\n\tfor (i = 0; i < FOTG210_MAX_NUM_EP; i++) {\n\t\tstruct fotg210_ep *ep = fotg210->ep[i];\n\n\t\tif (i) {\n\t\t\tINIT_LIST_HEAD(&fotg210->ep[i]->ep.ep_list);\n\t\t\tlist_add_tail(&fotg210->ep[i]->ep.ep_list,\n\t\t\t\t      &fotg210->gadget.ep_list);\n\t\t}\n\t\tep->fotg210 = fotg210;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tep->ep.name = fotg210_ep_name[i];\n\t\tep->ep.ops = &fotg210_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\n\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\tusb_ep_set_maxpacket_limit(&fotg210->ep[0]->ep, 0x40);\n\tfotg210->gadget.ep0 = &fotg210->ep[0]->ep;\n\tINIT_LIST_HEAD(&fotg210->gadget.ep0->ep_list);\n\n\tfotg210->ep0_req = fotg210_ep_alloc_request(&fotg210->ep[0]->ep,\n\t\t\t\tGFP_KERNEL);\n\tif (fotg210->ep0_req == NULL)\n\t\tgoto err_map;\n\n\tfotg210->ep0_req->complete = fotg210_ep0_complete;\n\n\tfotg210_init(fotg210);\n\n\tfotg210_disable_unplug(fotg210);\n\n\tret = request_irq(irq, fotg210_irq, IRQF_SHARED,\n\t\t\t  udc_name, fotg210);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"request_irq error\\n\");\n\t\tgoto err_req;\n\t}\n\n\tif (!IS_ERR_OR_NULL(fotg210->phy))\n\t\tusb_register_notifier(fotg210->phy, &fotg210_phy_notifier);\n\n\tret = usb_add_gadget_udc(dev, &fotg210->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\n\tdev_info(dev, \"version %s\\n\", DRIVER_VERSION);\n\n\treturn 0;\n\nerr_add_udc:\n\tif (!IS_ERR_OR_NULL(fotg210->phy))\n\t\tusb_unregister_notifier(fotg210->phy, &fotg210_phy_notifier);\n\tfree_irq(irq, fotg210);\n\nerr_req:\n\tfotg210_ep_free_request(&fotg210->ep[0]->ep, fotg210->ep0_req);\n\nerr_map:\n\tiounmap(fotg210->reg);\n\nerr_alloc:\n\tfor (i = 0; i < FOTG210_MAX_NUM_EP; i++)\n\t\tkfree(fotg210->ep[i]);\n\nerr_free:\n\tkfree(fotg210);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}