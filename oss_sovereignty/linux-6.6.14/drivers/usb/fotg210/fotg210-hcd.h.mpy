{
  "module_name": "fotg210-hcd.h",
  "hash_id": "1ef75c5e217c59365f3a2beb3f24fcce512103c38014dfd2830a6e287167399e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/fotg210/fotg210-hcd.h",
  "human_readable_source": " \n#ifndef __LINUX_FOTG210_H\n#define __LINUX_FOTG210_H\n\n#include <linux/usb/ehci-dbgp.h>\n\n \n\n \n#define __hc32\t__le32\n#define __hc16\t__le16\n\n \nstruct fotg210_stats {\n\t \n\tunsigned long\t\tnormal;\n\tunsigned long\t\terror;\n\tunsigned long\t\tiaa;\n\tunsigned long\t\tlost_iaa;\n\n\t \n\tunsigned long\t\tcomplete;\n\tunsigned long\t\tunlink;\n};\n\n \n\n#define\tFOTG210_MAX_ROOT_PORTS\t1\t\t \n\n \nenum fotg210_rh_state {\n\tFOTG210_RH_HALTED,\n\tFOTG210_RH_SUSPENDED,\n\tFOTG210_RH_RUNNING,\n\tFOTG210_RH_STOPPING\n};\n\n \nenum fotg210_hrtimer_event {\n\tFOTG210_HRTIMER_POLL_ASS,\t \n\tFOTG210_HRTIMER_POLL_PSS,\t \n\tFOTG210_HRTIMER_POLL_DEAD,\t \n\tFOTG210_HRTIMER_UNLINK_INTR,\t \n\tFOTG210_HRTIMER_FREE_ITDS,\t \n\tFOTG210_HRTIMER_ASYNC_UNLINKS,\t \n\tFOTG210_HRTIMER_IAA_WATCHDOG,\t \n\tFOTG210_HRTIMER_DISABLE_PERIODIC,  \n\tFOTG210_HRTIMER_DISABLE_ASYNC,\t \n\tFOTG210_HRTIMER_IO_WATCHDOG,\t \n\tFOTG210_HRTIMER_NUM_EVENTS\t \n};\n#define FOTG210_HRTIMER_NO_EVENT\t99\n\nstruct fotg210_hcd {\t\t\t \n\t \n\tenum fotg210_hrtimer_event\tnext_hrtimer_event;\n\tunsigned\t\tenabled_hrtimer_events;\n\tktime_t\t\t\thr_timeouts[FOTG210_HRTIMER_NUM_EVENTS];\n\tstruct hrtimer\t\thrtimer;\n\n\tint\t\t\tPSS_poll_count;\n\tint\t\t\tASS_poll_count;\n\tint\t\t\tdied_poll_count;\n\n\t \n\tstruct fotg210_caps __iomem *caps;\n\tstruct fotg210_regs __iomem *regs;\n\tstruct ehci_dbg_port __iomem *debug;\n\n\t__u32\t\t\thcs_params;\t \n\tspinlock_t\t\tlock;\n\tenum fotg210_rh_state\trh_state;\n\n\t \n\tbool\t\t\tscanning:1;\n\tbool\t\t\tneed_rescan:1;\n\tbool\t\t\tintr_unlinking:1;\n\tbool\t\t\tasync_unlinking:1;\n\tbool\t\t\tshutdown:1;\n\tstruct fotg210_qh\t\t*qh_scan_next;\n\n\t \n\tstruct fotg210_qh\t\t*async;\n\tstruct fotg210_qh\t\t*dummy;\t\t \n\tstruct fotg210_qh\t\t*async_unlink;\n\tstruct fotg210_qh\t\t*async_unlink_last;\n\tstruct fotg210_qh\t\t*async_iaa;\n\tunsigned\t\tasync_unlink_cycle;\n\tunsigned\t\tasync_count;\t \n\n\t \n#define\tDEFAULT_I_TDPS\t\t1024\t\t \n\tunsigned\t\tperiodic_size;\n\t__hc32\t\t\t*periodic;\t \n\tdma_addr_t\t\tperiodic_dma;\n\tstruct list_head\tintr_qh_list;\n\tunsigned\t\ti_thresh;\t \n\n\tunion fotg210_shadow\t*pshadow;\t \n\tstruct fotg210_qh\t\t*intr_unlink;\n\tstruct fotg210_qh\t\t*intr_unlink_last;\n\tunsigned\t\tintr_unlink_cycle;\n\tunsigned\t\tnow_frame;\t \n\tunsigned\t\tnext_frame;\t \n\tunsigned\t\tintr_count;\t \n\tunsigned\t\tisoc_count;\t \n\tunsigned\t\tperiodic_count;\t \n\t \n\tunsigned\t\tuframe_periodic_max;\n\n\n\t \n\tstruct list_head\tcached_itd_list;\n\tstruct fotg210_itd\t*last_itd_to_free;\n\n\t \n\tunsigned long\t\treset_done[FOTG210_MAX_ROOT_PORTS];\n\n\t \n\tunsigned long\t\tbus_suspended;\n\n\t \n\tunsigned long\t\tcompanion_ports;\n\n\t \n\tunsigned long\t\towned_ports;\n\n\t \n\tunsigned long\t\tport_c_suspend;\n\n\t \n\tunsigned long\t\tsuspended_ports;\n\n\t \n\tunsigned long\t\tresuming_ports;\n\n\t \n\tstruct dma_pool\t\t*qh_pool;\t \n\tstruct dma_pool\t\t*qtd_pool;\t \n\tstruct dma_pool\t\t*itd_pool;\t \n\n\tunsigned\t\trandom_frame;\n\tunsigned long\t\tnext_statechange;\n\tktime_t\t\t\tlast_periodic_enable;\n\tu32\t\t\tcommand;\n\n\t \n\tunsigned\t\tneed_io_watchdog:1;\n\tunsigned\t\tfs_i_thresh:1;\t \n\n\tu8\t\t\tsbrn;\t\t \n\n\t \n#ifdef FOTG210_STATS\n\tstruct fotg210_stats\tstats;\n#\tdefine INCR(x) ((x)++)\n#else\n#\tdefine INCR(x) do {} while (0)\n#endif\n\n\tstruct fotg210\t\t*fotg;\t\t \n\t \n\tstruct clk\t\t*pclk;\n};\n\n \nstatic inline struct fotg210_hcd *hcd_to_fotg210(struct usb_hcd *hcd)\n{\n\treturn (struct fotg210_hcd *)(hcd->hcd_priv);\n}\nstatic inline struct usb_hcd *fotg210_to_hcd(struct fotg210_hcd *fotg210)\n{\n\treturn container_of((void *) fotg210, struct usb_hcd, hcd_priv);\n}\n\n \n\n \n\n \nstruct fotg210_caps {\n\t \n\tu32\t\thc_capbase;\n#define HC_LENGTH(fotg210, p)\t(0x00ff&((p) >>   \\\n\t\t\t\t(fotg210_big_endian_capbase(fotg210) ? 24 : 0)))\n#define HC_VERSION(fotg210, p)\t(0xffff&((p) >>   \\\n\t\t\t\t(fotg210_big_endian_capbase(fotg210) ? 0 : 16)))\n\tu32\t\thcs_params;      \n#define HCS_N_PORTS(p)\t\t(((p)>>0)&0xf)\t \n\n\tu32\t\thcc_params;\t \n#define HCC_CANPARK(p)\t\t((p)&(1 << 2))   \n#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))   \n\tu8\t\tportroute[8];\t  \n};\n\n\n \nstruct fotg210_regs {\n\n\t \n\tu32\t\tcommand;\n\n \n \n#define CMD_PARK\t(1<<11)\t\t \n#define CMD_PARK_CNT(c)\t(((c)>>8)&3)\t \n#define CMD_IAAD\t(1<<6)\t\t \n#define CMD_ASE\t\t(1<<5)\t\t \n#define CMD_PSE\t\t(1<<4)\t\t \n \n#define CMD_RESET\t(1<<1)\t\t \n#define CMD_RUN\t\t(1<<0)\t\t \n\n\t \n\tu32\t\tstatus;\n#define STS_ASS\t\t(1<<15)\t\t \n#define STS_PSS\t\t(1<<14)\t\t \n#define STS_RECL\t(1<<13)\t\t \n#define STS_HALT\t(1<<12)\t\t \n \n\t \n#define STS_IAA\t\t(1<<5)\t\t \n#define STS_FATAL\t(1<<4)\t\t \n#define STS_FLR\t\t(1<<3)\t\t \n#define STS_PCD\t\t(1<<2)\t\t \n#define STS_ERR\t\t(1<<1)\t\t \n#define STS_INT\t\t(1<<0)\t\t \n\n\t \n\tu32\t\tintr_enable;\n\n\t \n\tu32\t\tframe_index;\t \n\t \n\tu32\t\tsegment;\t \n\t \n\tu32\t\tframe_list;\t \n\t \n\tu32\t\tasync_next;\t \n\n\tu32\treserved1;\n\t \n\tu32\tport_status;\n \n#define PORT_USB11(x) (((x)&(3<<10)) == (1<<10))\t \n#define PORT_RESET\t(1<<8)\t\t \n#define PORT_SUSPEND\t(1<<7)\t\t \n#define PORT_RESUME\t(1<<6)\t\t \n#define PORT_PEC\t(1<<3)\t\t \n#define PORT_PE\t\t(1<<2)\t\t \n#define PORT_CSC\t(1<<1)\t\t \n#define PORT_CONNECT\t(1<<0)\t\t \n#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC)\n\tu32     reserved2[19];\n\n\t \n\tu32     otgcsr;\n#define OTGCSR_HOST_SPD_TYP     (3 << 22)\n#define OTGCSR_A_BUS_DROP\t(1 << 5)\n#define OTGCSR_A_BUS_REQ\t(1 << 4)\n\n\t \n\tu32     otgisr;\n#define OTGISR_OVC\t(1 << 10)\n\n\tu32     reserved3[15];\n\n\t \n\tu32     gmir;\n#define GMIR_INT_POLARITY\t(1 << 3)  \n#define GMIR_MHC_INT\t\t(1 << 2)\n#define GMIR_MOTG_INT\t\t(1 << 1)\n#define GMIR_MDEV_INT\t(1 << 0)\n};\n\n \n\n#define\tQTD_NEXT(fotg210, dma)\tcpu_to_hc32(fotg210, (u32)dma)\n\n \nstruct fotg210_qtd {\n\t \n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_alt_next;     \n\t__hc32\t\t\thw_token;\t \n#define\tQTD_TOGGLE\t(1 << 31)\t \n#define\tQTD_LENGTH(tok)\t(((tok)>>16) & 0x7fff)\n#define\tQTD_IOC\t\t(1 << 15)\t \n#define\tQTD_CERR(tok)\t(((tok)>>10) & 0x3)\n#define\tQTD_PID(tok)\t(((tok)>>8) & 0x3)\n#define\tQTD_STS_ACTIVE\t(1 << 7)\t \n#define\tQTD_STS_HALT\t(1 << 6)\t \n#define\tQTD_STS_DBE\t(1 << 5)\t \n#define\tQTD_STS_BABBLE\t(1 << 4)\t \n#define\tQTD_STS_XACT\t(1 << 3)\t \n#define\tQTD_STS_MMF\t(1 << 2)\t \n#define\tQTD_STS_STS\t(1 << 1)\t \n#define\tQTD_STS_PING\t(1 << 0)\t \n\n#define ACTIVE_BIT(fotg210)\tcpu_to_hc32(fotg210, QTD_STS_ACTIVE)\n#define HALT_BIT(fotg210)\t\tcpu_to_hc32(fotg210, QTD_STS_HALT)\n#define STATUS_BIT(fotg210)\tcpu_to_hc32(fotg210, QTD_STS_STS)\n\n\t__hc32\t\t\thw_buf[5];\t \n\t__hc32\t\t\thw_buf_hi[5];\t \n\n\t \n\tdma_addr_t\t\tqtd_dma;\t\t \n\tstruct list_head\tqtd_list;\t\t \n\tstruct urb\t\t*urb;\t\t\t \n\tsize_t\t\t\tlength;\t\t\t \n} __aligned(32);\n\n \n#define QTD_MASK(fotg210)\tcpu_to_hc32(fotg210, ~0x1f)\n\n#define IS_SHORT_READ(token) (QTD_LENGTH(token) != 0 && QTD_PID(token) == 1)\n\n \n\n \n#define Q_NEXT_TYPE(fotg210, dma)\t((dma) & cpu_to_hc32(fotg210, 3 << 1))\n\n \n \n#define Q_TYPE_ITD\t(0 << 1)\n#define Q_TYPE_QH\t(1 << 1)\n#define Q_TYPE_SITD\t(2 << 1)\n#define Q_TYPE_FSTN\t(3 << 1)\n\n \n#define QH_NEXT(fotg210, dma) \\\n\t(cpu_to_hc32(fotg210, (((u32)dma)&~0x01f)|Q_TYPE_QH))\n\n \n#define FOTG210_LIST_END(fotg210) \\\n\tcpu_to_hc32(fotg210, 1)  \n\n \nunion fotg210_shadow {\n\tstruct fotg210_qh\t*qh;\t\t \n\tstruct fotg210_itd\t*itd;\t\t \n\tstruct fotg210_fstn\t*fstn;\t\t \n\t__hc32\t\t\t*hw_next;\t \n\tvoid\t\t\t*ptr;\n};\n\n \n\n \n\n \nstruct fotg210_qh_hw {\n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_info1;\t \n#define\tQH_CONTROL_EP\t(1 << 27)\t \n#define\tQH_HEAD\t\t(1 << 15)\t \n#define\tQH_TOGGLE_CTL\t(1 << 14)\t \n#define\tQH_HIGH_SPEED\t(2 << 12)\t \n#define\tQH_LOW_SPEED\t(1 << 12)\n#define\tQH_FULL_SPEED\t(0 << 12)\n#define\tQH_INACTIVATE\t(1 << 7)\t \n\t__hc32\t\t\thw_info2;\t \n#define\tQH_SMASK\t0x000000ff\n#define\tQH_CMASK\t0x0000ff00\n#define\tQH_HUBADDR\t0x007f0000\n#define\tQH_HUBPORT\t0x3f800000\n#define\tQH_MULT\t\t0xc0000000\n\t__hc32\t\t\thw_current;\t \n\n\t \n\t__hc32\t\t\thw_qtd_next;\n\t__hc32\t\t\thw_alt_next;\n\t__hc32\t\t\thw_token;\n\t__hc32\t\t\thw_buf[5];\n\t__hc32\t\t\thw_buf_hi[5];\n} __aligned(32);\n\nstruct fotg210_qh {\n\tstruct fotg210_qh_hw\t*hw;\t\t \n\t \n\tdma_addr_t\t\tqh_dma;\t\t \n\tunion fotg210_shadow\tqh_next;\t \n\tstruct list_head\tqtd_list;\t \n\tstruct list_head\tintr_node;\t \n\tstruct fotg210_qtd\t*dummy;\n\tstruct fotg210_qh\t*unlink_next;\t \n\n\tunsigned\t\tunlink_cycle;\n\n\tu8\t\t\tneeds_rescan;\t \n\tu8\t\t\tqh_state;\n#define\tQH_STATE_LINKED\t\t1\t\t \n#define\tQH_STATE_UNLINK\t\t2\t\t \n#define\tQH_STATE_IDLE\t\t3\t\t \n#define\tQH_STATE_UNLINK_WAIT\t4\t\t \n#define\tQH_STATE_COMPLETING\t5\t\t \n\n\tu8\t\t\txacterrs;\t \n#define\tQH_XACTERR_MAX\t\t32\t\t \n\n\t \n\tu8\t\t\tusecs;\t\t \n\tu8\t\t\tgap_uf;\t\t \n\tu8\t\t\tc_usecs;\t \n\tu16\t\t\ttt_usecs;\t \n\tunsigned short\t\tperiod;\t\t \n\tunsigned short\t\tstart;\t\t \n#define NO_FRAME ((unsigned short)~0)\t\t\t \n\n\tstruct usb_device\t*dev;\t\t \n\tunsigned\t\tis_out:1;\t \n\tunsigned\t\tclearing_tt:1;\t \n};\n\n \n\n \nstruct fotg210_iso_packet {\n\t \n\tu64\t\t\tbufp;\t\t \n\t__hc32\t\t\ttransaction;\t \n\tu8\t\t\tcross;\t\t \n\t \n\tu32\t\t\tbuf1;\n};\n\n \nstruct fotg210_iso_sched {\n\tstruct list_head\ttd_list;\n\tunsigned\t\tspan;\n\tstruct fotg210_iso_packet\tpacket[];\n};\n\n \nstruct fotg210_iso_stream {\n\t \n\tstruct fotg210_qh_hw\t*hw;\n\n\tu8\t\t\tbEndpointAddress;\n\tu8\t\t\thighspeed;\n\tstruct list_head\ttd_list;\t \n\tstruct list_head\tfree_list;\t \n\tstruct usb_device\t*udev;\n\tstruct usb_host_endpoint *ep;\n\n\t \n\tint\t\t\tnext_uframe;\n\t__hc32\t\t\tsplits;\n\n\t \n\tu8\t\t\tusecs, c_usecs;\n\tu16\t\t\tinterval;\n\tu16\t\t\ttt_usecs;\n\tu16\t\t\tmaxp;\n\tu16\t\t\traw_mask;\n\tunsigned\t\tbandwidth;\n\n\t \n\t__hc32\t\t\tbuf0;\n\t__hc32\t\t\tbuf1;\n\t__hc32\t\t\tbuf2;\n\n\t \n\t__hc32\t\t\taddress;\n};\n\n \n\n \nstruct fotg210_itd {\n\t \n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_transaction[8];  \n#define FOTG210_ISOC_ACTIVE\t(1<<31)\t \n#define FOTG210_ISOC_BUF_ERR\t(1<<30)\t \n#define FOTG210_ISOC_BABBLE\t(1<<29)\t \n#define FOTG210_ISOC_XACTERR\t(1<<28)\t \n#define\tFOTG210_ITD_LENGTH(tok)\t(((tok)>>16) & 0x0fff)\n#define\tFOTG210_ITD_IOC\t\t(1 << 15)\t \n\n#define ITD_ACTIVE(fotg210)\tcpu_to_hc32(fotg210, FOTG210_ISOC_ACTIVE)\n\n\t__hc32\t\t\thw_bufp[7];\t \n\t__hc32\t\t\thw_bufp_hi[7];\t \n\n\t \n\tdma_addr_t\t\titd_dma;\t \n\tunion fotg210_shadow\titd_next;\t \n\n\tstruct urb\t\t*urb;\n\tstruct fotg210_iso_stream\t*stream;\t \n\tstruct list_head\titd_list;\t \n\n\t \n\tunsigned\t\tframe;\t\t \n\tunsigned\t\tpg;\n\tunsigned\t\tindex[8];\t \n} __aligned(32);\n\n \n\n \nstruct fotg210_fstn {\n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_prev;\t \n\n\t \n\tdma_addr_t\t\tfstn_dma;\n\tunion fotg210_shadow\tfstn_next;\t \n} __aligned(32);\n\n \n\n \n\n#define fotg210_prepare_ports_for_controller_suspend(fotg210, do_wakeup) \\\n\t\tfotg210_adjust_port_wakeup_flags(fotg210, true, do_wakeup)\n\n#define fotg210_prepare_ports_for_controller_resume(fotg210)\t\t\\\n\t\tfotg210_adjust_port_wakeup_flags(fotg210, false, false)\n\n \n\n \n\nstatic inline unsigned int\nfotg210_get_speed(struct fotg210_hcd *fotg210, unsigned int portsc)\n{\n\treturn (readl(&fotg210->regs->otgcsr)\n\t\t& OTGCSR_HOST_SPD_TYP) >> 22;\n}\n\n \nstatic inline unsigned int\nfotg210_port_speed(struct fotg210_hcd *fotg210, unsigned int portsc)\n{\n\tswitch (fotg210_get_speed(fotg210, portsc)) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn USB_PORT_STAT_LOW_SPEED;\n\tcase 2:\n\tdefault:\n\t\treturn USB_PORT_STAT_HIGH_SPEED;\n\t}\n}\n\n \n\n#define\tfotg210_has_fsl_portno_bug(e)\t\t(0)\n\n \n\n#define fotg210_big_endian_mmio(e)\t0\n#define fotg210_big_endian_capbase(e)\t0\n\nstatic inline unsigned int fotg210_readl(const struct fotg210_hcd *fotg210,\n\t\t__u32 __iomem *regs)\n{\n\treturn readl(regs);\n}\n\nstatic inline void fotg210_writel(const struct fotg210_hcd *fotg210,\n\t\tconst unsigned int val, __u32 __iomem *regs)\n{\n\twritel(val, regs);\n}\n\n \nstatic inline __hc32 cpu_to_hc32(const struct fotg210_hcd *fotg210, const u32 x)\n{\n\treturn cpu_to_le32(x);\n}\n\n \nstatic inline u32 hc32_to_cpu(const struct fotg210_hcd *fotg210, const __hc32 x)\n{\n\treturn le32_to_cpu(x);\n}\n\nstatic inline u32 hc32_to_cpup(const struct fotg210_hcd *fotg210,\n\t\t\t       const __hc32 *x)\n{\n\treturn le32_to_cpup(x);\n}\n\n \n\nstatic inline unsigned fotg210_read_frame_index(struct fotg210_hcd *fotg210)\n{\n\treturn fotg210_readl(fotg210, &fotg210->regs->frame_index);\n}\n\n \n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}