{
  "module_name": "fotg210-hcd.c",
  "hash_id": "fc88ee84b8dc27f9587ff1de3af46309361e1007f1e9f42e308097830dc7a50f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/fotg210/fotg210-hcd.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <linux/debugfs.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include <asm/byteorder.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n#include \"fotg210.h\"\n\nstatic const char hcd_name[] = \"fotg210_hcd\";\n\n#undef FOTG210_URB_TRACE\n#define FOTG210_STATS\n\n \n#define FOTG210_TUNE_CERR\t3  \n#define FOTG210_TUNE_RL_HS\t4  \n#define FOTG210_TUNE_RL_TT\t0\n#define FOTG210_TUNE_MULT_HS\t1  \n#define FOTG210_TUNE_MULT_TT\t1\n\n \n#define FOTG210_TUNE_FLS 1  \n\n \nstatic int log2_irq_thresh;  \nmodule_param(log2_irq_thresh, int, S_IRUGO);\nMODULE_PARM_DESC(log2_irq_thresh, \"log2 IRQ latency, 1-64 microframes\");\n\n \nstatic unsigned park;\nmodule_param(park, uint, S_IRUGO);\nMODULE_PARM_DESC(park, \"park setting; 1-3 back-to-back async packets\");\n\n \nstatic unsigned int hird;\nmodule_param(hird, int, S_IRUGO);\nMODULE_PARM_DESC(hird, \"host initiated resume duration, +1 for each 75us\");\n\n#define INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)\n\n#include \"fotg210-hcd.h\"\n\n#define fotg210_dbg(fotg210, fmt, args...) \\\n\tdev_dbg(fotg210_to_hcd(fotg210)->self.controller, fmt, ## args)\n#define fotg210_err(fotg210, fmt, args...) \\\n\tdev_err(fotg210_to_hcd(fotg210)->self.controller, fmt, ## args)\n#define fotg210_info(fotg210, fmt, args...) \\\n\tdev_info(fotg210_to_hcd(fotg210)->self.controller, fmt, ## args)\n#define fotg210_warn(fotg210, fmt, args...) \\\n\tdev_warn(fotg210_to_hcd(fotg210)->self.controller, fmt, ## args)\n\n \nstatic void dbg_hcs_params(struct fotg210_hcd *fotg210, char *label)\n{\n\tu32 params = fotg210_readl(fotg210, &fotg210->caps->hcs_params);\n\n\tfotg210_dbg(fotg210, \"%s hcs_params 0x%x ports=%d\\n\", label, params,\n\t\t\tHCS_N_PORTS(params));\n}\n\n \nstatic void dbg_hcc_params(struct fotg210_hcd *fotg210, char *label)\n{\n\tu32 params = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\n\n\tfotg210_dbg(fotg210, \"%s hcc_params %04x uframes %s%s\\n\", label,\n\t\t\tparams,\n\t\t\tHCC_PGM_FRAMELISTLEN(params) ? \"256/512/1024\" : \"1024\",\n\t\t\tHCC_CANPARK(params) ? \" park\" : \"\");\n}\n\nstatic void __maybe_unused\ndbg_qtd(const char *label, struct fotg210_hcd *fotg210, struct fotg210_qtd *qtd)\n{\n\tfotg210_dbg(fotg210, \"%s td %p n%08x %08x t%08x p0=%08x\\n\", label, qtd,\n\t\t\thc32_to_cpup(fotg210, &qtd->hw_next),\n\t\t\thc32_to_cpup(fotg210, &qtd->hw_alt_next),\n\t\t\thc32_to_cpup(fotg210, &qtd->hw_token),\n\t\t\thc32_to_cpup(fotg210, &qtd->hw_buf[0]));\n\tif (qtd->hw_buf[1])\n\t\tfotg210_dbg(fotg210, \"  p1=%08x p2=%08x p3=%08x p4=%08x\\n\",\n\t\t\t\thc32_to_cpup(fotg210, &qtd->hw_buf[1]),\n\t\t\t\thc32_to_cpup(fotg210, &qtd->hw_buf[2]),\n\t\t\t\thc32_to_cpup(fotg210, &qtd->hw_buf[3]),\n\t\t\t\thc32_to_cpup(fotg210, &qtd->hw_buf[4]));\n}\n\nstatic void __maybe_unused\ndbg_qh(const char *label, struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\tstruct fotg210_qh_hw *hw = qh->hw;\n\n\tfotg210_dbg(fotg210, \"%s qh %p n%08x info %x %x qtd %x\\n\", label, qh,\n\t\t\thw->hw_next, hw->hw_info1, hw->hw_info2,\n\t\t\thw->hw_current);\n\n\tdbg_qtd(\"overlay\", fotg210, (struct fotg210_qtd *) &hw->hw_qtd_next);\n}\n\nstatic void __maybe_unused\ndbg_itd(const char *label, struct fotg210_hcd *fotg210, struct fotg210_itd *itd)\n{\n\tfotg210_dbg(fotg210, \"%s[%d] itd %p, next %08x, urb %p\\n\", label,\n\t\t\titd->frame, itd, hc32_to_cpu(fotg210, itd->hw_next),\n\t\t\titd->urb);\n\n\tfotg210_dbg(fotg210,\n\t\t\t\"  trans: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[0]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[1]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[2]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[3]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[4]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[5]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[6]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_transaction[7]));\n\n\tfotg210_dbg(fotg210,\n\t\t\t\"  buf:   %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[0]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[1]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[2]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[3]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[4]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[5]),\n\t\t\thc32_to_cpu(fotg210, itd->hw_bufp[6]));\n\n\tfotg210_dbg(fotg210, \"  index: %d %d %d %d %d %d %d %d\\n\",\n\t\t\titd->index[0], itd->index[1], itd->index[2],\n\t\t\titd->index[3], itd->index[4], itd->index[5],\n\t\t\titd->index[6], itd->index[7]);\n}\n\nstatic int __maybe_unused\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\n{\n\treturn scnprintf(buf, len, \"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s\",\n\t\t\tlabel, label[0] ? \" \" : \"\", status,\n\t\t\t(status & STS_ASS) ? \" Async\" : \"\",\n\t\t\t(status & STS_PSS) ? \" Periodic\" : \"\",\n\t\t\t(status & STS_RECL) ? \" Recl\" : \"\",\n\t\t\t(status & STS_HALT) ? \" Halt\" : \"\",\n\t\t\t(status & STS_IAA) ? \" IAA\" : \"\",\n\t\t\t(status & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t\t(status & STS_FLR) ? \" FLR\" : \"\",\n\t\t\t(status & STS_PCD) ? \" PCD\" : \"\",\n\t\t\t(status & STS_ERR) ? \" ERR\" : \"\",\n\t\t\t(status & STS_INT) ? \" INT\" : \"\");\n}\n\nstatic int __maybe_unused\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\n{\n\treturn scnprintf(buf, len, \"%s%sintrenable %02x%s%s%s%s%s%s\",\n\t\t\tlabel, label[0] ? \" \" : \"\", enable,\n\t\t\t(enable & STS_IAA) ? \" IAA\" : \"\",\n\t\t\t(enable & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t\t(enable & STS_FLR) ? \" FLR\" : \"\",\n\t\t\t(enable & STS_PCD) ? \" PCD\" : \"\",\n\t\t\t(enable & STS_ERR) ? \" ERR\" : \"\",\n\t\t\t(enable & STS_INT) ? \" INT\" : \"\");\n}\n\nstatic const char *const fls_strings[] = { \"1024\", \"512\", \"256\", \"??\" };\n\nstatic int dbg_command_buf(char *buf, unsigned len, const char *label,\n\t\tu32 command)\n{\n\treturn scnprintf(buf, len,\n\t\t\t\"%s%scommand %07x %s=%d ithresh=%d%s%s%s period=%s%s %s\",\n\t\t\tlabel, label[0] ? \" \" : \"\", command,\n\t\t\t(command & CMD_PARK) ? \" park\" : \"(park)\",\n\t\t\tCMD_PARK_CNT(command),\n\t\t\t(command >> 16) & 0x3f,\n\t\t\t(command & CMD_IAAD) ? \" IAAD\" : \"\",\n\t\t\t(command & CMD_ASE) ? \" Async\" : \"\",\n\t\t\t(command & CMD_PSE) ? \" Periodic\" : \"\",\n\t\t\tfls_strings[(command >> 2) & 0x3],\n\t\t\t(command & CMD_RESET) ? \" Reset\" : \"\",\n\t\t\t(command & CMD_RUN) ? \"RUN\" : \"HALT\");\n}\n\nstatic char *dbg_port_buf(char *buf, unsigned len, const char *label, int port,\n\t\tu32 status)\n{\n\tchar *sig;\n\n\t \n\tswitch (status & (3 << 10)) {\n\tcase 0 << 10:\n\t\tsig = \"se0\";\n\t\tbreak;\n\tcase 1 << 10:\n\t\tsig = \"k\";\n\t\tbreak;  \n\tcase 2 << 10:\n\t\tsig = \"j\";\n\t\tbreak;\n\tdefault:\n\t\tsig = \"?\";\n\t\tbreak;\n\t}\n\n\tscnprintf(buf, len, \"%s%sport:%d status %06x %d sig=%s%s%s%s%s%s%s%s\",\n\t\t\tlabel, label[0] ? \" \" : \"\", port, status,\n\t\t\tstatus >> 25,  \n\t\t\tsig,\n\t\t\t(status & PORT_RESET) ? \" RESET\" : \"\",\n\t\t\t(status & PORT_SUSPEND) ? \" SUSPEND\" : \"\",\n\t\t\t(status & PORT_RESUME) ? \" RESUME\" : \"\",\n\t\t\t(status & PORT_PEC) ? \" PEC\" : \"\",\n\t\t\t(status & PORT_PE) ? \" PE\" : \"\",\n\t\t\t(status & PORT_CSC) ? \" CSC\" : \"\",\n\t\t\t(status & PORT_CONNECT) ? \" CONNECT\" : \"\");\n\n\treturn buf;\n}\n\n \n#define dbg_status(fotg210, label, status) {\t\t\t\\\n\tchar _buf[80];\t\t\t\t\t\t\\\n\tdbg_status_buf(_buf, sizeof(_buf), label, status);\t\\\n\tfotg210_dbg(fotg210, \"%s\\n\", _buf);\t\t\t\\\n}\n\n#define dbg_cmd(fotg210, label, command) {\t\t\t\\\n\tchar _buf[80];\t\t\t\t\t\t\\\n\tdbg_command_buf(_buf, sizeof(_buf), label, command);\t\\\n\tfotg210_dbg(fotg210, \"%s\\n\", _buf);\t\t\t\\\n}\n\n#define dbg_port(fotg210, label, port, status) {\t\t\t       \\\n\tchar _buf[80];\t\t\t\t\t\t\t       \\\n\tfotg210_dbg(fotg210, \"%s\\n\",\t\t\t\t\t       \\\n\t\t\tdbg_port_buf(_buf, sizeof(_buf), label, port, status));\\\n}\n\n \nstatic int debug_async_open(struct inode *, struct file *);\nstatic int debug_periodic_open(struct inode *, struct file *);\nstatic int debug_registers_open(struct inode *, struct file *);\nstatic int debug_async_open(struct inode *, struct file *);\n\nstatic ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);\nstatic int debug_close(struct inode *, struct file *);\n\nstatic const struct file_operations debug_async_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_async_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations debug_periodic_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_periodic_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations debug_registers_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_registers_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *fotg210_debug_root;\n\nstruct debug_buffer {\n\tssize_t (*fill_func)(struct debug_buffer *);\t \n\tstruct usb_bus *bus;\n\tstruct mutex mutex;\t \n\tsize_t count;\t\t \n\tchar *output_buf;\n\tsize_t alloc_size;\n};\n\nstatic inline char speed_char(u32 scratch)\n{\n\tswitch (scratch & (3 << 12)) {\n\tcase QH_FULL_SPEED:\n\t\treturn 'f';\n\n\tcase QH_LOW_SPEED:\n\t\treturn 'l';\n\n\tcase QH_HIGH_SPEED:\n\t\treturn 'h';\n\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic inline char token_mark(struct fotg210_hcd *fotg210, __hc32 token)\n{\n\t__u32 v = hc32_to_cpu(fotg210, token);\n\n\tif (v & QTD_STS_ACTIVE)\n\t\treturn '*';\n\tif (v & QTD_STS_HALT)\n\t\treturn '-';\n\tif (!IS_SHORT_READ(v))\n\t\treturn ' ';\n\t \n\treturn '/';\n}\n\nstatic void qh_lines(struct fotg210_hcd *fotg210, struct fotg210_qh *qh,\n\t\tchar **nextp, unsigned *sizep)\n{\n\tu32 scratch;\n\tu32 hw_curr;\n\tstruct fotg210_qtd *td;\n\tunsigned temp;\n\tunsigned size = *sizep;\n\tchar *next = *nextp;\n\tchar mark;\n\t__le32 list_end = FOTG210_LIST_END(fotg210);\n\tstruct fotg210_qh_hw *hw = qh->hw;\n\n\tif (hw->hw_qtd_next == list_end)  \n\t\tmark = '@';\n\telse\n\t\tmark = token_mark(fotg210, hw->hw_token);\n\tif (mark == '/') {  \n\t\tif ((hw->hw_alt_next & QTD_MASK(fotg210)) ==\n\t\t    fotg210->async->hw->hw_alt_next)\n\t\t\tmark = '#';  \n\t\telse if (hw->hw_alt_next == list_end)\n\t\t\tmark = '.';  \n\t\t \n\t}\n\tscratch = hc32_to_cpup(fotg210, &hw->hw_info1);\n\thw_curr = (mark == '*') ? hc32_to_cpup(fotg210, &hw->hw_current) : 0;\n\ttemp = scnprintf(next, size,\n\t\t\t\"qh/%p dev%d %cs ep%d %08x %08x(%08x%c %s nak%d)\",\n\t\t\tqh, scratch & 0x007f,\n\t\t\tspeed_char(scratch),\n\t\t\t(scratch >> 8) & 0x000f,\n\t\t\tscratch, hc32_to_cpup(fotg210, &hw->hw_info2),\n\t\t\thc32_to_cpup(fotg210, &hw->hw_token), mark,\n\t\t\t(cpu_to_hc32(fotg210, QTD_TOGGLE) & hw->hw_token)\n\t\t\t\t? \"data1\" : \"data0\",\n\t\t\t(hc32_to_cpup(fotg210, &hw->hw_alt_next) >> 1) & 0x0f);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tlist_for_each_entry(td, &qh->qtd_list, qtd_list) {\n\t\tscratch = hc32_to_cpup(fotg210, &td->hw_token);\n\t\tmark = ' ';\n\t\tif (hw_curr == td->qtd_dma)\n\t\t\tmark = '*';\n\t\telse if (hw->hw_qtd_next == cpu_to_hc32(fotg210, td->qtd_dma))\n\t\t\tmark = '+';\n\t\telse if (QTD_LENGTH(scratch)) {\n\t\t\tif (td->hw_alt_next == fotg210->async->hw->hw_alt_next)\n\t\t\t\tmark = '#';\n\t\t\telse if (td->hw_alt_next != list_end)\n\t\t\t\tmark = '/';\n\t\t}\n\t\ttemp = snprintf(next, size,\n\t\t\t\t\"\\n\\t%p%c%s len=%d %08x urb %p\",\n\t\t\t\ttd, mark, ({ char *tmp;\n\t\t\t\tswitch ((scratch>>8)&0x03) {\n\t\t\t\tcase 0:\n\t\t\t\t\ttmp = \"out\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\ttmp = \"in\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\ttmp = \"setup\";\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttmp = \"?\";\n\t\t\t\t\tbreak;\n\t\t\t\t } tmp; }),\n\t\t\t\t(scratch >> 16) & 0x7fff,\n\t\t\t\tscratch,\n\t\t\t\ttd->urb);\n\t\tif (size < temp)\n\t\t\ttemp = size;\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\n\ttemp = snprintf(next, size, \"\\n\");\n\tif (size < temp)\n\t\ttemp = size;\n\n\tsize -= temp;\n\tnext += temp;\n\n\t*sizep = size;\n\t*nextp = next;\n}\n\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd *hcd;\n\tstruct fotg210_hcd *fotg210;\n\tunsigned long flags;\n\tunsigned temp, size;\n\tchar *next;\n\tstruct fotg210_qh *qh;\n\n\thcd = bus_to_hcd(buf->bus);\n\tfotg210 = hcd_to_fotg210(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\t*next = 0;\n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tfor (qh = fotg210->async->qh_next.qh; size > 0 && qh;\n\t\t\tqh = qh->qh_next.qh)\n\t\tqh_lines(fotg210, qh, &next, &size);\n\tif (fotg210->async_unlink && size > 0) {\n\t\ttemp = scnprintf(next, size, \"\\nunlink =\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tfor (qh = fotg210->async_unlink; size > 0 && qh;\n\t\t\t\tqh = qh->unlink_next)\n\t\t\tqh_lines(fotg210, qh, &next, &size);\n\t}\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\n\treturn strlen(buf->output_buf);\n}\n\n \nstatic unsigned output_buf_tds_dir(char *buf, struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh_hw *hw, struct fotg210_qh *qh, unsigned size)\n{\n\tu32 scratch = hc32_to_cpup(fotg210, &hw->hw_info1);\n\tstruct fotg210_qtd *qtd;\n\tchar *type = \"\";\n\tunsigned temp = 0;\n\n\t \n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\n\t\ttemp++;\n\t\tswitch ((hc32_to_cpu(fotg210, qtd->hw_token) >> 8) & 0x03) {\n\t\tcase 0:\n\t\t\ttype = \"out\";\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\ttype = \"in\";\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn scnprintf(buf, size, \"(%c%d ep%d%s [%d/%d] q%d p%d)\",\n\t\t\tspeed_char(scratch), scratch & 0x007f,\n\t\t\t(scratch >> 8) & 0x000f, type, qh->usecs,\n\t\t\tqh->c_usecs, temp, (scratch >> 16) & 0x7ff);\n}\n\n#define DBG_SCHED_LIMIT 64\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd *hcd;\n\tstruct fotg210_hcd *fotg210;\n\tunsigned long flags;\n\tunion fotg210_shadow p, *seen;\n\tunsigned temp, size, seen_count;\n\tchar *next;\n\tunsigned i;\n\t__hc32 tag;\n\n\tseen = kmalloc_array(DBG_SCHED_LIMIT, sizeof(*seen), GFP_ATOMIC);\n\tif (!seen)\n\t\treturn 0;\n\n\tseen_count = 0;\n\n\thcd = bus_to_hcd(buf->bus);\n\tfotg210 = hcd_to_fotg210(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\ttemp = scnprintf(next, size, \"size = %d\\n\", fotg210->periodic_size);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tfor (i = 0; i < fotg210->periodic_size; i++) {\n\t\tp = fotg210->pshadow[i];\n\t\tif (likely(!p.ptr))\n\t\t\tcontinue;\n\n\t\ttag = Q_NEXT_TYPE(fotg210, fotg210->periodic[i]);\n\n\t\ttemp = scnprintf(next, size, \"%4d: \", i);\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tdo {\n\t\t\tstruct fotg210_qh_hw *hw;\n\n\t\t\tswitch (hc32_to_cpu(fotg210, tag)) {\n\t\t\tcase Q_TYPE_QH:\n\t\t\t\thw = p.qh->hw;\n\t\t\t\ttemp = scnprintf(next, size, \" qh%d-%04x/%p\",\n\t\t\t\t\t\tp.qh->period,\n\t\t\t\t\t\thc32_to_cpup(fotg210,\n\t\t\t\t\t\t\t&hw->hw_info2)\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t& (QH_CMASK | QH_SMASK),\n\t\t\t\t\t\tp.qh);\n\t\t\t\tsize -= temp;\n\t\t\t\tnext += temp;\n\t\t\t\t \n\t\t\t\tfor (temp = 0; temp < seen_count; temp++) {\n\t\t\t\t\tif (seen[temp].ptr != p.ptr)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (p.qh->qh_next.ptr) {\n\t\t\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\t\t\t\" ...\");\n\t\t\t\t\t\tsize -= temp;\n\t\t\t\t\t\tnext += temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (temp == seen_count) {\n\t\t\t\t\ttemp = output_buf_tds_dir(next,\n\t\t\t\t\t\t\tfotg210, hw,\n\t\t\t\t\t\t\tp.qh, size);\n\n\t\t\t\t\tif (seen_count < DBG_SCHED_LIMIT)\n\t\t\t\t\t\tseen[seen_count++].qh = p.qh;\n\t\t\t\t} else\n\t\t\t\t\ttemp = 0;\n\t\t\t\ttag = Q_NEXT_TYPE(fotg210, hw->hw_next);\n\t\t\t\tp = p.qh->qh_next;\n\t\t\t\tbreak;\n\t\t\tcase Q_TYPE_FSTN:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\t\" fstn-%8x/%p\",\n\t\t\t\t\t\tp.fstn->hw_prev, p.fstn);\n\t\t\t\ttag = Q_NEXT_TYPE(fotg210, p.fstn->hw_next);\n\t\t\t\tp = p.fstn->fstn_next;\n\t\t\t\tbreak;\n\t\t\tcase Q_TYPE_ITD:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\t\" itd/%p\", p.itd);\n\t\t\t\ttag = Q_NEXT_TYPE(fotg210, p.itd->hw_next);\n\t\t\t\tp = p.itd->itd_next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t} while (p.ptr);\n\n\t\ttemp = scnprintf(next, size, \"\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\tkfree(seen);\n\n\treturn buf->alloc_size - size;\n}\n#undef DBG_SCHED_LIMIT\n\nstatic const char *rh_state_string(struct fotg210_hcd *fotg210)\n{\n\tswitch (fotg210->rh_state) {\n\tcase FOTG210_RH_HALTED:\n\t\treturn \"halted\";\n\tcase FOTG210_RH_SUSPENDED:\n\t\treturn \"suspended\";\n\tcase FOTG210_RH_RUNNING:\n\t\treturn \"running\";\n\tcase FOTG210_RH_STOPPING:\n\t\treturn \"stopping\";\n\t}\n\treturn \"?\";\n}\n\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd *hcd;\n\tstruct fotg210_hcd *fotg210;\n\tunsigned long flags;\n\tunsigned temp, size, i;\n\tchar *next, scratch[80];\n\tstatic const char fmt[] = \"%*s\\n\";\n\tstatic const char label[] = \"\";\n\n\thcd = bus_to_hcd(buf->bus);\n\tfotg210 = hcd_to_fotg210(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tsize = scnprintf(next, size,\n\t\t\t\t\"bus %s, device %s\\n\"\n\t\t\t\t\"%s\\n\"\n\t\t\t\t\"SUSPENDED(no register access)\\n\",\n\t\t\t\thcd->self.controller->bus->name,\n\t\t\t\tdev_name(hcd->self.controller),\n\t\t\t\thcd->product_desc);\n\t\tgoto done;\n\t}\n\n\t \n\ti = HC_VERSION(fotg210, fotg210_readl(fotg210,\n\t\t\t&fotg210->caps->hc_capbase));\n\ttemp = scnprintf(next, size,\n\t\t\t\"bus %s, device %s\\n\"\n\t\t\t\"%s\\n\"\n\t\t\t\"EHCI %x.%02x, rh state %s\\n\",\n\t\t\thcd->self.controller->bus->name,\n\t\t\tdev_name(hcd->self.controller),\n\t\t\thcd->product_desc,\n\t\t\ti >> 8, i & 0x0ff, rh_state_string(fotg210));\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\ti = fotg210_readl(fotg210, &fotg210->caps->hcs_params);\n\ttemp = scnprintf(next, size, \"structural params 0x%08x\\n\", i);\n\tsize -= temp;\n\tnext += temp;\n\n\ti = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\n\ttemp = scnprintf(next, size, \"capability params 0x%08x\\n\", i);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\ttemp = dbg_status_buf(scratch, sizeof(scratch), label,\n\t\t\tfotg210_readl(fotg210, &fotg210->regs->status));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = dbg_command_buf(scratch, sizeof(scratch), label,\n\t\t\tfotg210_readl(fotg210, &fotg210->regs->command));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = dbg_intr_buf(scratch, sizeof(scratch), label,\n\t\t\tfotg210_readl(fotg210, &fotg210->regs->intr_enable));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = scnprintf(next, size, \"uframe %04x\\n\",\n\t\t\tfotg210_read_frame_index(fotg210));\n\tsize -= temp;\n\tnext += temp;\n\n\tif (fotg210->async_unlink) {\n\t\ttemp = scnprintf(next, size, \"async unlink qh %p\\n\",\n\t\t\t\tfotg210->async_unlink);\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\n#ifdef FOTG210_STATS\n\ttemp = scnprintf(next, size,\n\t\t\t\"irq normal %ld err %ld iaa %ld(lost %ld)\\n\",\n\t\t\tfotg210->stats.normal, fotg210->stats.error,\n\t\t\tfotg210->stats.iaa, fotg210->stats.lost_iaa);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = scnprintf(next, size, \"complete %ld unlink %ld\\n\",\n\t\t\tfotg210->stats.complete, fotg210->stats.unlink);\n\tsize -= temp;\n\tnext += temp;\n#endif\n\ndone:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\n\treturn buf->alloc_size - size;\n}\n\nstatic struct debug_buffer\n*alloc_buffer(struct usb_bus *bus, ssize_t (*fill_func)(struct debug_buffer *))\n{\n\tstruct debug_buffer *buf;\n\n\tbuf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);\n\n\tif (buf) {\n\t\tbuf->bus = bus;\n\t\tbuf->fill_func = fill_func;\n\t\tmutex_init(&buf->mutex);\n\t\tbuf->alloc_size = PAGE_SIZE;\n\t}\n\n\treturn buf;\n}\n\nstatic int fill_buffer(struct debug_buffer *buf)\n{\n\tint ret = 0;\n\n\tif (!buf->output_buf)\n\t\tbuf->output_buf = vmalloc(buf->alloc_size);\n\n\tif (!buf->output_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = buf->fill_func(buf);\n\n\tif (ret >= 0) {\n\t\tbuf->count = ret;\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\n\t\tsize_t len, loff_t *offset)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\tint ret = 0;\n\n\tmutex_lock(&buf->mutex);\n\tif (buf->count == 0) {\n\t\tret = fill_buffer(buf);\n\t\tif (ret != 0) {\n\t\t\tmutex_unlock(&buf->mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&buf->mutex);\n\n\tret = simple_read_from_buffer(user_buf, len, offset,\n\t\t\tbuf->output_buf, buf->count);\n\nout:\n\treturn ret;\n\n}\n\nstatic int debug_close(struct inode *inode, struct file *file)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\n\tif (buf) {\n\t\tvfree(buf->output_buf);\n\t\tkfree(buf);\n\t}\n\n\treturn 0;\n}\nstatic int debug_async_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\n{\n\tstruct debug_buffer *buf;\n\n\tbuf = alloc_buffer(inode->i_private, fill_periodic_buffer);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->alloc_size = (sizeof(void *) == 4 ? 6 : 8)*PAGE_SIZE;\n\tfile->private_data = buf;\n\treturn 0;\n}\n\nstatic int debug_registers_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private,\n\t\t\tfill_registers_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic inline void create_debug_files(struct fotg210_hcd *fotg210)\n{\n\tstruct usb_bus *bus = &fotg210_to_hcd(fotg210)->self;\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(bus->bus_name, fotg210_debug_root);\n\n\tdebugfs_create_file(\"async\", S_IRUGO, root, bus, &debug_async_fops);\n\tdebugfs_create_file(\"periodic\", S_IRUGO, root, bus,\n\t\t\t    &debug_periodic_fops);\n\tdebugfs_create_file(\"registers\", S_IRUGO, root, bus,\n\t\t\t    &debug_registers_fops);\n}\n\nstatic inline void remove_debug_files(struct fotg210_hcd *fotg210)\n{\n\tstruct usb_bus *bus = &fotg210_to_hcd(fotg210)->self;\n\n\tdebugfs_lookup_and_remove(bus->bus_name, fotg210_debug_root);\n}\n\n \nstatic int handshake(struct fotg210_hcd *fotg210, void __iomem *ptr,\n\t\tu32 mask, u32 done, int usec)\n{\n\tu32 result;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(ptr, result,\n\t\t\t\t\t((result & mask) == done ||\n\t\t\t\t\t result == U32_MAX), 1, usec);\n\tif (result == U32_MAX)\t\t \n\t\treturn -ENODEV;\n\n\treturn ret;\n}\n\n \nstatic int fotg210_halt(struct fotg210_hcd *fotg210)\n{\n\tu32 temp;\n\n\tspin_lock_irq(&fotg210->lock);\n\n\t \n\tfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\n\n\t \n\tfotg210->command &= ~CMD_RUN;\n\ttemp = fotg210_readl(fotg210, &fotg210->regs->command);\n\ttemp &= ~(CMD_RUN | CMD_IAAD);\n\tfotg210_writel(fotg210, temp, &fotg210->regs->command);\n\n\tspin_unlock_irq(&fotg210->lock);\n\tsynchronize_irq(fotg210_to_hcd(fotg210)->irq);\n\n\treturn handshake(fotg210, &fotg210->regs->status,\n\t\t\tSTS_HALT, STS_HALT, 16 * 125);\n}\n\n \nstatic int fotg210_reset(struct fotg210_hcd *fotg210)\n{\n\tint retval;\n\tu32 command = fotg210_readl(fotg210, &fotg210->regs->command);\n\n\t \n\tif (fotg210->debug && !dbgp_reset_prep(fotg210_to_hcd(fotg210)))\n\t\tfotg210->debug = NULL;\n\n\tcommand |= CMD_RESET;\n\tdbg_cmd(fotg210, \"reset\", command);\n\tfotg210_writel(fotg210, command, &fotg210->regs->command);\n\tfotg210->rh_state = FOTG210_RH_HALTED;\n\tfotg210->next_statechange = jiffies;\n\tretval = handshake(fotg210, &fotg210->regs->command,\n\t\t\tCMD_RESET, 0, 250 * 1000);\n\n\tif (retval)\n\t\treturn retval;\n\n\tif (fotg210->debug)\n\t\tdbgp_external_startup(fotg210_to_hcd(fotg210));\n\n\tfotg210->port_c_suspend = fotg210->suspended_ports =\n\t\t\tfotg210->resuming_ports = 0;\n\treturn retval;\n}\n\n \nstatic void fotg210_quiesce(struct fotg210_hcd *fotg210)\n{\n\tu32 temp;\n\n\tif (fotg210->rh_state != FOTG210_RH_RUNNING)\n\t\treturn;\n\n\t \n\ttemp = (fotg210->command << 10) & (STS_ASS | STS_PSS);\n\thandshake(fotg210, &fotg210->regs->status, STS_ASS | STS_PSS, temp,\n\t\t\t16 * 125);\n\n\t \n\tspin_lock_irq(&fotg210->lock);\n\tfotg210->command &= ~(CMD_ASE | CMD_PSE);\n\tfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\n\tspin_unlock_irq(&fotg210->lock);\n\n\t \n\thandshake(fotg210, &fotg210->regs->status, STS_ASS | STS_PSS, 0,\n\t\t\t16 * 125);\n}\n\nstatic void end_unlink_async(struct fotg210_hcd *fotg210);\nstatic void unlink_empty_async(struct fotg210_hcd *fotg210);\nstatic void fotg210_work(struct fotg210_hcd *fotg210);\nstatic void start_unlink_intr(struct fotg210_hcd *fotg210,\n\t\t\t      struct fotg210_qh *qh);\nstatic void end_unlink_intr(struct fotg210_hcd *fotg210, struct fotg210_qh *qh);\n\n \nstatic void fotg210_set_command_bit(struct fotg210_hcd *fotg210, u32 bit)\n{\n\tfotg210->command |= bit;\n\tfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\n\n\t \n\tfotg210_readl(fotg210, &fotg210->regs->command);\n}\n\n \nstatic void fotg210_clear_command_bit(struct fotg210_hcd *fotg210, u32 bit)\n{\n\tfotg210->command &= ~bit;\n\tfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\n\n\t \n\tfotg210_readl(fotg210, &fotg210->regs->command);\n}\n\n \n\n \nstatic unsigned event_delays_ns[] = {\n\t1 * NSEC_PER_MSEC,\t \n\t1 * NSEC_PER_MSEC,\t \n\t1 * NSEC_PER_MSEC,\t \n\t1125 * NSEC_PER_USEC,\t \n\t2 * NSEC_PER_MSEC,\t \n\t6 * NSEC_PER_MSEC,\t \n\t10 * NSEC_PER_MSEC,\t \n\t10 * NSEC_PER_MSEC,\t \n\t15 * NSEC_PER_MSEC,\t \n\t100 * NSEC_PER_MSEC,\t \n};\n\n \nstatic void fotg210_enable_event(struct fotg210_hcd *fotg210, unsigned event,\n\t\tbool resched)\n{\n\tktime_t *timeout = &fotg210->hr_timeouts[event];\n\n\tif (resched)\n\t\t*timeout = ktime_add(ktime_get(), event_delays_ns[event]);\n\tfotg210->enabled_hrtimer_events |= (1 << event);\n\n\t \n\tif (event < fotg210->next_hrtimer_event) {\n\t\tfotg210->next_hrtimer_event = event;\n\t\thrtimer_start_range_ns(&fotg210->hrtimer, *timeout,\n\t\t\t\tNSEC_PER_MSEC, HRTIMER_MODE_ABS);\n\t}\n}\n\n\n \nstatic void fotg210_poll_ASS(struct fotg210_hcd *fotg210)\n{\n\tunsigned actual, want;\n\n\t \n\tif (fotg210->rh_state != FOTG210_RH_RUNNING)\n\t\treturn;\n\n\twant = (fotg210->command & CMD_ASE) ? STS_ASS : 0;\n\tactual = fotg210_readl(fotg210, &fotg210->regs->status) & STS_ASS;\n\n\tif (want != actual) {\n\n\t\t \n\t\tif (fotg210->ASS_poll_count++ < 20) {\n\t\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_POLL_ASS,\n\t\t\t\t\ttrue);\n\t\t\treturn;\n\t\t}\n\t\tfotg210_dbg(fotg210, \"Waited too long for the async schedule status (%x/%x), giving up\\n\",\n\t\t\t\twant, actual);\n\t}\n\tfotg210->ASS_poll_count = 0;\n\n\t \n\tif (want == 0) {\t \n\t\tif (fotg210->async_count > 0)\n\t\t\tfotg210_set_command_bit(fotg210, CMD_ASE);\n\n\t} else {\t\t \n\t\tif (fotg210->async_count == 0) {\n\n\t\t\t \n\t\t\tfotg210_enable_event(fotg210,\n\t\t\t\t\tFOTG210_HRTIMER_DISABLE_ASYNC,\n\t\t\t\t\ttrue);\n\t\t}\n\t}\n}\n\n \nstatic void fotg210_disable_ASE(struct fotg210_hcd *fotg210)\n{\n\tfotg210_clear_command_bit(fotg210, CMD_ASE);\n}\n\n\n \nstatic void fotg210_poll_PSS(struct fotg210_hcd *fotg210)\n{\n\tunsigned actual, want;\n\n\t \n\tif (fotg210->rh_state != FOTG210_RH_RUNNING)\n\t\treturn;\n\n\twant = (fotg210->command & CMD_PSE) ? STS_PSS : 0;\n\tactual = fotg210_readl(fotg210, &fotg210->regs->status) & STS_PSS;\n\n\tif (want != actual) {\n\n\t\t \n\t\tif (fotg210->PSS_poll_count++ < 20) {\n\t\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_POLL_PSS,\n\t\t\t\t\ttrue);\n\t\t\treturn;\n\t\t}\n\t\tfotg210_dbg(fotg210, \"Waited too long for the periodic schedule status (%x/%x), giving up\\n\",\n\t\t\t\twant, actual);\n\t}\n\tfotg210->PSS_poll_count = 0;\n\n\t \n\tif (want == 0) {\t \n\t\tif (fotg210->periodic_count > 0)\n\t\t\tfotg210_set_command_bit(fotg210, CMD_PSE);\n\n\t} else {\t\t \n\t\tif (fotg210->periodic_count == 0) {\n\n\t\t\t \n\t\t\tfotg210_enable_event(fotg210,\n\t\t\t\t\tFOTG210_HRTIMER_DISABLE_PERIODIC,\n\t\t\t\t\ttrue);\n\t\t}\n\t}\n}\n\n \nstatic void fotg210_disable_PSE(struct fotg210_hcd *fotg210)\n{\n\tfotg210_clear_command_bit(fotg210, CMD_PSE);\n}\n\n\n \nstatic void fotg210_handle_controller_death(struct fotg210_hcd *fotg210)\n{\n\tif (!(fotg210_readl(fotg210, &fotg210->regs->status) & STS_HALT)) {\n\n\t\t \n\t\tif (fotg210->died_poll_count++ < 5) {\n\t\t\t \n\t\t\tfotg210_enable_event(fotg210,\n\t\t\t\t\tFOTG210_HRTIMER_POLL_DEAD, true);\n\t\t\treturn;\n\t\t}\n\t\tfotg210_warn(fotg210, \"Waited too long for the controller to stop, giving up\\n\");\n\t}\n\n\t \n\tfotg210->rh_state = FOTG210_RH_HALTED;\n\tfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\n\tfotg210_work(fotg210);\n\tend_unlink_async(fotg210);\n\n\t \n}\n\n\n \nstatic void fotg210_handle_intr_unlinks(struct fotg210_hcd *fotg210)\n{\n\tbool stopped = (fotg210->rh_state < FOTG210_RH_RUNNING);\n\n\t \n\tfotg210->intr_unlinking = true;\n\twhile (fotg210->intr_unlink) {\n\t\tstruct fotg210_qh *qh = fotg210->intr_unlink;\n\n\t\tif (!stopped && qh->unlink_cycle == fotg210->intr_unlink_cycle)\n\t\t\tbreak;\n\t\tfotg210->intr_unlink = qh->unlink_next;\n\t\tqh->unlink_next = NULL;\n\t\tend_unlink_intr(fotg210, qh);\n\t}\n\n\t \n\tif (fotg210->intr_unlink) {\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_UNLINK_INTR,\n\t\t\t\ttrue);\n\t\t++fotg210->intr_unlink_cycle;\n\t}\n\tfotg210->intr_unlinking = false;\n}\n\n\n \nstatic void start_free_itds(struct fotg210_hcd *fotg210)\n{\n\tif (!(fotg210->enabled_hrtimer_events &\n\t\t\tBIT(FOTG210_HRTIMER_FREE_ITDS))) {\n\t\tfotg210->last_itd_to_free = list_entry(\n\t\t\t\tfotg210->cached_itd_list.prev,\n\t\t\t\tstruct fotg210_itd, itd_list);\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_FREE_ITDS, true);\n\t}\n}\n\n \nstatic void end_free_itds(struct fotg210_hcd *fotg210)\n{\n\tstruct fotg210_itd *itd, *n;\n\n\tif (fotg210->rh_state < FOTG210_RH_RUNNING)\n\t\tfotg210->last_itd_to_free = NULL;\n\n\tlist_for_each_entry_safe(itd, n, &fotg210->cached_itd_list, itd_list) {\n\t\tlist_del(&itd->itd_list);\n\t\tdma_pool_free(fotg210->itd_pool, itd, itd->itd_dma);\n\t\tif (itd == fotg210->last_itd_to_free)\n\t\t\tbreak;\n\t}\n\n\tif (!list_empty(&fotg210->cached_itd_list))\n\t\tstart_free_itds(fotg210);\n}\n\n\n \nstatic void fotg210_iaa_watchdog(struct fotg210_hcd *fotg210)\n{\n\tif (fotg210->rh_state != FOTG210_RH_RUNNING)\n\t\treturn;\n\n\t \n\tif (fotg210->async_iaa) {\n\t\tu32 cmd, status;\n\n\t\t \n\t\tcmd = fotg210_readl(fotg210, &fotg210->regs->command);\n\n\t\t \n\t\tstatus = fotg210_readl(fotg210, &fotg210->regs->status);\n\t\tif ((status & STS_IAA) || !(cmd & CMD_IAAD)) {\n\t\t\tINCR(fotg210->stats.lost_iaa);\n\t\t\tfotg210_writel(fotg210, STS_IAA,\n\t\t\t\t\t&fotg210->regs->status);\n\t\t}\n\n\t\tfotg210_dbg(fotg210, \"IAA watchdog: status %x cmd %x\\n\",\n\t\t\t\tstatus, cmd);\n\t\tend_unlink_async(fotg210);\n\t}\n}\n\n\n \nstatic void turn_on_io_watchdog(struct fotg210_hcd *fotg210)\n{\n\t \n\tif (fotg210->rh_state != FOTG210_RH_RUNNING ||\n\t\t\t(fotg210->enabled_hrtimer_events &\n\t\t\tBIT(FOTG210_HRTIMER_IO_WATCHDOG)))\n\t\treturn;\n\n\t \n\tif (fotg210->isoc_count > 0 || (fotg210->need_io_watchdog &&\n\t\t\tfotg210->async_count + fotg210->intr_count > 0))\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_IO_WATCHDOG,\n\t\t\t\ttrue);\n}\n\n\n \nstatic void (*event_handlers[])(struct fotg210_hcd *) = {\n\tfotg210_poll_ASS,\t\t\t \n\tfotg210_poll_PSS,\t\t\t \n\tfotg210_handle_controller_death,\t \n\tfotg210_handle_intr_unlinks,\t \n\tend_free_itds,\t\t\t \n\tunlink_empty_async,\t\t \n\tfotg210_iaa_watchdog,\t\t \n\tfotg210_disable_PSE,\t\t \n\tfotg210_disable_ASE,\t\t \n\tfotg210_work,\t\t\t \n};\n\nstatic enum hrtimer_restart fotg210_hrtimer_func(struct hrtimer *t)\n{\n\tstruct fotg210_hcd *fotg210 =\n\t\t\tcontainer_of(t, struct fotg210_hcd, hrtimer);\n\tktime_t now;\n\tunsigned long events;\n\tunsigned long flags;\n\tunsigned e;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\tevents = fotg210->enabled_hrtimer_events;\n\tfotg210->enabled_hrtimer_events = 0;\n\tfotg210->next_hrtimer_event = FOTG210_HRTIMER_NO_EVENT;\n\n\t \n\tnow = ktime_get();\n\tfor_each_set_bit(e, &events, FOTG210_HRTIMER_NUM_EVENTS) {\n\t\tif (ktime_compare(now, fotg210->hr_timeouts[e]) >= 0)\n\t\t\tevent_handlers[e](fotg210);\n\t\telse\n\t\t\tfotg210_enable_event(fotg210, e, false);\n\t}\n\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn HRTIMER_NORESTART;\n}\n\n#define fotg210_bus_suspend NULL\n#define fotg210_bus_resume NULL\n\nstatic int check_reset_complete(struct fotg210_hcd *fotg210, int index,\n\t\tu32 __iomem *status_reg, int port_status)\n{\n\tif (!(port_status & PORT_CONNECT))\n\t\treturn port_status;\n\n\t \n\tif (!(port_status & PORT_PE))\n\t\t \n\t\tfotg210_dbg(fotg210, \"Failed to enable port %d on root hub TT\\n\",\n\t\t\t\tindex + 1);\n\telse\n\t\tfotg210_dbg(fotg210, \"port %d reset complete, port enabled\\n\",\n\t\t\t\tindex + 1);\n\n\treturn port_status;\n}\n\n\n \n\nstatic int fotg210_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tu32 temp, status;\n\tu32 mask;\n\tint retval = 1;\n\tunsigned long flags;\n\n\t \n\tbuf[0] = 0;\n\n\t \n\tstatus = fotg210->resuming_ports;\n\n\tmask = PORT_CSC | PORT_PEC;\n\t \n\n\t \n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\ttemp = fotg210_readl(fotg210, &fotg210->regs->port_status);\n\n\t \n\n\tif ((temp & mask) != 0 || test_bit(0, &fotg210->port_c_suspend) ||\n\t\t\t(fotg210->reset_done[0] &&\n\t\t\ttime_after_eq(jiffies, fotg210->reset_done[0]))) {\n\t\tbuf[0] |= 1 << 1;\n\t\tstatus = STS_PCD;\n\t}\n\t \n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn status ? retval : 0;\n}\n\nstatic void fotg210_hub_descriptor(struct fotg210_hcd *fotg210,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint ports = HCS_N_PORTS(fotg210->hcs_params);\n\tu16 temp;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bPwrOn2PwrGood = 10;\t \n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ports;\n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\t \n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\n\tmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\n\n\ttemp = HUB_CHAR_INDV_PORT_OCPM;\t \n\ttemp |= HUB_CHAR_NO_LPSM;\t \n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n}\n\nstatic int fotg210_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\tu16 wIndex, char *buf, u16 wLength)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tint ports = HCS_N_PORTS(fotg210->hcs_params);\n\tu32 __iomem *status_reg = &fotg210->regs->port_status;\n\tu32 temp, temp1, status;\n\tunsigned long flags;\n\tint retval = 0;\n\tunsigned selector;\n\n\t \n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = fotg210_readl(fotg210, status_reg);\n\t\ttemp &= ~PORT_RWC_BITS;\n\n\t\t \n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tfotg210_writel(fotg210, temp & ~PORT_PE, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tfotg210_writel(fotg210, temp | PORT_PEC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (temp & PORT_RESET)\n\t\t\t\tgoto error;\n\t\t\tif (!(temp & PORT_SUSPEND))\n\t\t\t\tbreak;\n\t\t\tif ((temp & PORT_PE) == 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tfotg210_writel(fotg210, temp | PORT_RESUME, status_reg);\n\t\t\tfotg210->reset_done[wIndex] = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tclear_bit(wIndex, &fotg210->port_c_suspend);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tfotg210_writel(fotg210, temp | PORT_CSC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tfotg210_writel(fotg210, temp | OTGISR_OVC,\n\t\t\t\t\t&fotg210->regs->otgisr);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tfotg210_readl(fotg210, &fotg210->regs->command);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tfotg210_hub_descriptor(fotg210, (struct usb_hub_descriptor *)\n\t\t\t\tbuf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t \n\t\tmemset(buf, 0, 4);\n\t\t \n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tstatus = 0;\n\t\ttemp = fotg210_readl(fotg210, status_reg);\n\n\t\t \n\t\tif (temp & PORT_CSC)\n\t\t\tstatus |= USB_PORT_STAT_C_CONNECTION << 16;\n\t\tif (temp & PORT_PEC)\n\t\t\tstatus |= USB_PORT_STAT_C_ENABLE << 16;\n\n\t\ttemp1 = fotg210_readl(fotg210, &fotg210->regs->otgisr);\n\t\tif (temp1 & OTGISR_OVC)\n\t\t\tstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\n\n\t\t \n\t\tif (temp & PORT_RESUME) {\n\n\t\t\t \n\t\t\tif (!fotg210->reset_done[wIndex]) {\n\t\t\t\t \n\t\t\t\tfotg210->reset_done[wIndex] = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies(20);\n\t\t\t\t \n\t\t\t\tmod_timer(&fotg210_to_hcd(fotg210)->rh_timer,\n\t\t\t\t\t\tfotg210->reset_done[wIndex]);\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (time_after_eq(jiffies,\n\t\t\t\t\tfotg210->reset_done[wIndex])) {\n\t\t\t\tclear_bit(wIndex, &fotg210->suspended_ports);\n\t\t\t\tset_bit(wIndex, &fotg210->port_c_suspend);\n\t\t\t\tfotg210->reset_done[wIndex] = 0;\n\n\t\t\t\t \n\t\t\t\ttemp = fotg210_readl(fotg210, status_reg);\n\t\t\t\tfotg210_writel(fotg210, temp &\n\t\t\t\t\t\t~(PORT_RWC_BITS | PORT_RESUME),\n\t\t\t\t\t\tstatus_reg);\n\t\t\t\tclear_bit(wIndex, &fotg210->resuming_ports);\n\t\t\t\tretval = handshake(fotg210, status_reg,\n\t\t\t\t\t\tPORT_RESUME, 0, 2000); \n\t\t\t\tif (retval != 0) {\n\t\t\t\t\tfotg210_err(fotg210,\n\t\t\t\t\t\t\t\"port %d resume error %d\\n\",\n\t\t\t\t\t\t\twIndex + 1, retval);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\ttemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((temp & PORT_RESET) && time_after_eq(jiffies,\n\t\t\t\tfotg210->reset_done[wIndex])) {\n\t\t\tstatus |= USB_PORT_STAT_C_RESET << 16;\n\t\t\tfotg210->reset_done[wIndex] = 0;\n\t\t\tclear_bit(wIndex, &fotg210->resuming_ports);\n\n\t\t\t \n\t\t\tfotg210_writel(fotg210,\n\t\t\t\t\ttemp & ~(PORT_RWC_BITS | PORT_RESET),\n\t\t\t\t\tstatus_reg);\n\t\t\t \n\t\t\tretval = handshake(fotg210, status_reg,\n\t\t\t\t\tPORT_RESET, 0, 1000);\n\t\t\tif (retval != 0) {\n\t\t\t\tfotg210_err(fotg210, \"port %d reset error %d\\n\",\n\t\t\t\t\t\twIndex + 1, retval);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = check_reset_complete(fotg210, wIndex, status_reg,\n\t\t\t\t\tfotg210_readl(fotg210, status_reg));\n\n\t\t\t \n\t\t\tfotg210->command |= CMD_RUN;\n\t\t\tfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\n\t\t}\n\n\t\tif (!(temp & (PORT_RESUME|PORT_RESET))) {\n\t\t\tfotg210->reset_done[wIndex] = 0;\n\t\t\tclear_bit(wIndex, &fotg210->resuming_ports);\n\t\t}\n\n\t\t \n\t\tif ((temp & PORT_CONNECT) &&\n\t\t\t\ttest_bit(wIndex, &fotg210->companion_ports)) {\n\t\t\ttemp &= ~PORT_RWC_BITS;\n\t\t\tfotg210_writel(fotg210, temp, status_reg);\n\t\t\tfotg210_dbg(fotg210, \"port %d --> companion\\n\",\n\t\t\t\t\twIndex + 1);\n\t\t\ttemp = fotg210_readl(fotg210, status_reg);\n\t\t}\n\n\t\t \n\n\t\tif (temp & PORT_CONNECT) {\n\t\t\tstatus |= USB_PORT_STAT_CONNECTION;\n\t\t\tstatus |= fotg210_port_speed(fotg210, temp);\n\t\t}\n\t\tif (temp & PORT_PE)\n\t\t\tstatus |= USB_PORT_STAT_ENABLE;\n\n\t\t \n\t\tif (temp & (PORT_SUSPEND|PORT_RESUME)) {\n\t\t\tstatus |= USB_PORT_STAT_SUSPEND;\n\t\t} else if (test_bit(wIndex, &fotg210->suspended_ports)) {\n\t\t\tclear_bit(wIndex, &fotg210->suspended_ports);\n\t\t\tclear_bit(wIndex, &fotg210->resuming_ports);\n\t\t\tfotg210->reset_done[wIndex] = 0;\n\t\t\tif (temp & PORT_PE)\n\t\t\t\tset_bit(wIndex, &fotg210->port_c_suspend);\n\t\t}\n\n\t\ttemp1 = fotg210_readl(fotg210, &fotg210->regs->otgisr);\n\t\tif (temp1 & OTGISR_OVC)\n\t\t\tstatus |= USB_PORT_STAT_OVERCURRENT;\n\t\tif (temp & PORT_RESET)\n\t\t\tstatus |= USB_PORT_STAT_RESET;\n\t\tif (test_bit(wIndex, &fotg210->port_c_suspend))\n\t\t\tstatus |= USB_PORT_STAT_C_SUSPEND << 16;\n\n\t\tif (status & ~0xffff)\t \n\t\t\tdbg_port(fotg210, \"GetStatus\", wIndex + 1, temp);\n\t\tput_unaligned_le32(status, buf);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tselector = wIndex >> 8;\n\t\twIndex &= 0xff;\n\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = fotg210_readl(fotg210, status_reg);\n\t\ttemp &= ~PORT_RWC_BITS;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif ((temp & PORT_PE) == 0\n\t\t\t\t\t|| (temp & PORT_RESET) != 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tfotg210_writel(fotg210, temp | PORT_SUSPEND,\n\t\t\t\t\tstatus_reg);\n\t\t\tset_bit(wIndex, &fotg210->suspended_ports);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (temp & PORT_RESUME)\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\tfotg210_dbg(fotg210, \"port %d reset\\n\", wIndex + 1);\n\t\t\ttemp |= PORT_RESET;\n\t\t\ttemp &= ~PORT_PE;\n\n\t\t\t \n\t\t\tfotg210->reset_done[wIndex] = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(50);\n\t\t\tfotg210_writel(fotg210, temp, status_reg);\n\t\t\tbreak;\n\n\t\t \n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\tif (!selector || selector > 5)\n\t\t\t\tgoto error;\n\t\t\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\t\t\tfotg210_quiesce(fotg210);\n\t\t\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\t\t\t \n\t\t\ttemp = fotg210_readl(fotg210, status_reg) &\n\t\t\t\t~PORT_RWC_BITS;\n\t\t\tif (temp & PORT_PE)\n\t\t\t\tfotg210_writel(fotg210, temp | PORT_SUSPEND,\n\t\t\t\t\t\tstatus_reg);\n\n\t\t\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\t\t\tfotg210_halt(fotg210);\n\t\t\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\t\t\ttemp = fotg210_readl(fotg210, status_reg);\n\t\t\ttemp |= selector << 16;\n\t\t\tfotg210_writel(fotg210, temp, status_reg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tfotg210_readl(fotg210, &fotg210->regs->command);\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn retval;\n}\n\nstatic void __maybe_unused fotg210_relinquish_port(struct usb_hcd *hcd,\n\t\tint portnum)\n{\n\treturn;\n}\n\nstatic int __maybe_unused fotg210_port_handed_over(struct usb_hcd *hcd,\n\t\tint portnum)\n{\n\treturn 0;\n}\n\n \n\n \nstatic inline void fotg210_qtd_init(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qtd *qtd, dma_addr_t dma)\n{\n\tmemset(qtd, 0, sizeof(*qtd));\n\tqtd->qtd_dma = dma;\n\tqtd->hw_token = cpu_to_hc32(fotg210, QTD_STS_HALT);\n\tqtd->hw_next = FOTG210_LIST_END(fotg210);\n\tqtd->hw_alt_next = FOTG210_LIST_END(fotg210);\n\tINIT_LIST_HEAD(&qtd->qtd_list);\n}\n\nstatic struct fotg210_qtd *fotg210_qtd_alloc(struct fotg210_hcd *fotg210,\n\t\tgfp_t flags)\n{\n\tstruct fotg210_qtd *qtd;\n\tdma_addr_t dma;\n\n\tqtd = dma_pool_alloc(fotg210->qtd_pool, flags, &dma);\n\tif (qtd != NULL)\n\t\tfotg210_qtd_init(fotg210, qtd, dma);\n\n\treturn qtd;\n}\n\nstatic inline void fotg210_qtd_free(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qtd *qtd)\n{\n\tdma_pool_free(fotg210->qtd_pool, qtd, qtd->qtd_dma);\n}\n\n\nstatic void qh_destroy(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\t \n\tif (!list_empty(&qh->qtd_list) || qh->qh_next.ptr) {\n\t\tfotg210_dbg(fotg210, \"unused qh not empty!\\n\");\n\t\tBUG();\n\t}\n\tif (qh->dummy)\n\t\tfotg210_qtd_free(fotg210, qh->dummy);\n\tdma_pool_free(fotg210->qh_pool, qh->hw, qh->qh_dma);\n\tkfree(qh);\n}\n\nstatic struct fotg210_qh *fotg210_qh_alloc(struct fotg210_hcd *fotg210,\n\t\tgfp_t flags)\n{\n\tstruct fotg210_qh *qh;\n\tdma_addr_t dma;\n\n\tqh = kzalloc(sizeof(*qh), GFP_ATOMIC);\n\tif (!qh)\n\t\tgoto done;\n\tqh->hw = (struct fotg210_qh_hw *)\n\t\tdma_pool_zalloc(fotg210->qh_pool, flags, &dma);\n\tif (!qh->hw)\n\t\tgoto fail;\n\tqh->qh_dma = dma;\n\tINIT_LIST_HEAD(&qh->qtd_list);\n\n\t \n\tqh->dummy = fotg210_qtd_alloc(fotg210, flags);\n\tif (qh->dummy == NULL) {\n\t\tfotg210_dbg(fotg210, \"no dummy td\\n\");\n\t\tgoto fail1;\n\t}\ndone:\n\treturn qh;\nfail1:\n\tdma_pool_free(fotg210->qh_pool, qh->hw, qh->qh_dma);\nfail:\n\tkfree(qh);\n\treturn NULL;\n}\n\n \n\nstatic void fotg210_mem_cleanup(struct fotg210_hcd *fotg210)\n{\n\tif (fotg210->async)\n\t\tqh_destroy(fotg210, fotg210->async);\n\tfotg210->async = NULL;\n\n\tif (fotg210->dummy)\n\t\tqh_destroy(fotg210, fotg210->dummy);\n\tfotg210->dummy = NULL;\n\n\t \n\tdma_pool_destroy(fotg210->qtd_pool);\n\tfotg210->qtd_pool = NULL;\n\n\tdma_pool_destroy(fotg210->qh_pool);\n\tfotg210->qh_pool = NULL;\n\n\tdma_pool_destroy(fotg210->itd_pool);\n\tfotg210->itd_pool = NULL;\n\n\tif (fotg210->periodic)\n\t\tdma_free_coherent(fotg210_to_hcd(fotg210)->self.controller,\n\t\t\t\tfotg210->periodic_size * sizeof(u32),\n\t\t\t\tfotg210->periodic, fotg210->periodic_dma);\n\tfotg210->periodic = NULL;\n\n\t \n\tkfree(fotg210->pshadow);\n\tfotg210->pshadow = NULL;\n}\n\n \nstatic int fotg210_mem_init(struct fotg210_hcd *fotg210, gfp_t flags)\n{\n\tint i;\n\n\t \n\tfotg210->qtd_pool = dma_pool_create(\"fotg210_qtd\",\n\t\t\tfotg210_to_hcd(fotg210)->self.controller,\n\t\t\tsizeof(struct fotg210_qtd),\n\t\t\t32  ,\n\t\t\t4096  );\n\tif (!fotg210->qtd_pool)\n\t\tgoto fail;\n\n\t \n\tfotg210->qh_pool = dma_pool_create(\"fotg210_qh\",\n\t\t\tfotg210_to_hcd(fotg210)->self.controller,\n\t\t\tsizeof(struct fotg210_qh_hw),\n\t\t\t32  ,\n\t\t\t4096  );\n\tif (!fotg210->qh_pool)\n\t\tgoto fail;\n\n\tfotg210->async = fotg210_qh_alloc(fotg210, flags);\n\tif (!fotg210->async)\n\t\tgoto fail;\n\n\t \n\tfotg210->itd_pool = dma_pool_create(\"fotg210_itd\",\n\t\t\tfotg210_to_hcd(fotg210)->self.controller,\n\t\t\tsizeof(struct fotg210_itd),\n\t\t\t64  ,\n\t\t\t4096  );\n\tif (!fotg210->itd_pool)\n\t\tgoto fail;\n\n\t \n\tfotg210->periodic =\n\t\tdma_alloc_coherent(fotg210_to_hcd(fotg210)->self.controller,\n\t\t\t\tfotg210->periodic_size * sizeof(__le32),\n\t\t\t\t&fotg210->periodic_dma, 0);\n\tif (fotg210->periodic == NULL)\n\t\tgoto fail;\n\n\tfor (i = 0; i < fotg210->periodic_size; i++)\n\t\tfotg210->periodic[i] = FOTG210_LIST_END(fotg210);\n\n\t \n\tfotg210->pshadow = kcalloc(fotg210->periodic_size, sizeof(void *),\n\t\t\tflags);\n\tif (fotg210->pshadow != NULL)\n\t\treturn 0;\n\nfail:\n\tfotg210_dbg(fotg210, \"couldn't init memory\\n\");\n\tfotg210_mem_cleanup(fotg210);\n\treturn -ENOMEM;\n}\n \n\n \nstatic int qtd_fill(struct fotg210_hcd *fotg210, struct fotg210_qtd *qtd,\n\t\tdma_addr_t buf, size_t len, int token, int maxpacket)\n{\n\tint i, count;\n\tu64 addr = buf;\n\n\t \n\tqtd->hw_buf[0] = cpu_to_hc32(fotg210, (u32)addr);\n\tqtd->hw_buf_hi[0] = cpu_to_hc32(fotg210, (u32)(addr >> 32));\n\tcount = 0x1000 - (buf & 0x0fff);\t \n\tif (likely(len < count))\t\t \n\t\tcount = len;\n\telse {\n\t\tbuf +=  0x1000;\n\t\tbuf &= ~0x0fff;\n\n\t\t \n\t\tfor (i = 1; count < len && i < 5; i++) {\n\t\t\taddr = buf;\n\t\t\tqtd->hw_buf[i] = cpu_to_hc32(fotg210, (u32)addr);\n\t\t\tqtd->hw_buf_hi[i] = cpu_to_hc32(fotg210,\n\t\t\t\t\t(u32)(addr >> 32));\n\t\t\tbuf += 0x1000;\n\t\t\tif ((count + 0x1000) < len)\n\t\t\t\tcount += 0x1000;\n\t\t\telse\n\t\t\t\tcount = len;\n\t\t}\n\n\t\t \n\t\tif (count != len)\n\t\t\tcount -= (count % maxpacket);\n\t}\n\tqtd->hw_token = cpu_to_hc32(fotg210, (count << 16) | token);\n\tqtd->length = count;\n\n\treturn count;\n}\n\nstatic inline void qh_update(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh, struct fotg210_qtd *qtd)\n{\n\tstruct fotg210_qh_hw *hw = qh->hw;\n\n\t \n\tBUG_ON(qh->qh_state != QH_STATE_IDLE);\n\n\thw->hw_qtd_next = QTD_NEXT(fotg210, qtd->qtd_dma);\n\thw->hw_alt_next = FOTG210_LIST_END(fotg210);\n\n\t \n\tif (!(hw->hw_info1 & cpu_to_hc32(fotg210, QH_TOGGLE_CTL))) {\n\t\tunsigned is_out, epnum;\n\n\t\tis_out = qh->is_out;\n\t\tepnum = (hc32_to_cpup(fotg210, &hw->hw_info1) >> 8) & 0x0f;\n\t\tif (unlikely(!usb_gettoggle(qh->dev, epnum, is_out))) {\n\t\t\thw->hw_token &= ~cpu_to_hc32(fotg210, QTD_TOGGLE);\n\t\t\tusb_settoggle(qh->dev, epnum, is_out, 1);\n\t\t}\n\t}\n\n\thw->hw_token &= cpu_to_hc32(fotg210, QTD_TOGGLE | QTD_STS_PING);\n}\n\n \nstatic void qh_refresh(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\tstruct fotg210_qtd *qtd;\n\n\tif (list_empty(&qh->qtd_list))\n\t\tqtd = qh->dummy;\n\telse {\n\t\tqtd = list_entry(qh->qtd_list.next,\n\t\t\t\tstruct fotg210_qtd, qtd_list);\n\t\t \n\t\tif (cpu_to_hc32(fotg210, qtd->qtd_dma) == qh->hw->hw_current) {\n\t\t\tqh->hw->hw_qtd_next = qtd->hw_next;\n\t\t\tqtd = NULL;\n\t\t}\n\t}\n\n\tif (qtd)\n\t\tqh_update(fotg210, qh, qtd);\n}\n\nstatic void qh_link_async(struct fotg210_hcd *fotg210, struct fotg210_qh *qh);\n\nstatic void fotg210_clear_tt_buffer_complete(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tstruct fotg210_qh *qh = ep->hcpriv;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tqh->clearing_tt = 0;\n\tif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\n\t\t\t&& fotg210->rh_state == FOTG210_RH_RUNNING)\n\t\tqh_link_async(fotg210, qh);\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n}\n\nstatic void fotg210_clear_tt_buffer(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh, struct urb *urb, u32 token)\n{\n\n\t \n\tif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\n\t\tstruct usb_device *tt = urb->dev->tt->hub;\n\n\t\tdev_dbg(&tt->dev,\n\t\t\t\t\"clear tt buffer port %d, a%d ep%d t%08x\\n\",\n\t\t\t\turb->dev->ttport, urb->dev->devnum,\n\t\t\t\tusb_pipeendpoint(urb->pipe), token);\n\n\t\tif (urb->dev->tt->hub !=\n\t\t\t\tfotg210_to_hcd(fotg210)->self.root_hub) {\n\t\t\tif (usb_hub_clear_tt_buffer(urb) == 0)\n\t\t\t\tqh->clearing_tt = 1;\n\t\t}\n\t}\n}\n\nstatic int qtd_copy_status(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tsize_t length, u32 token)\n{\n\tint status = -EINPROGRESS;\n\n\t \n\tif (likely(QTD_PID(token) != 2))\n\t\turb->actual_length += length - QTD_LENGTH(token);\n\n\t \n\tif (unlikely(urb->unlinked))\n\t\treturn status;\n\n\t \n\tif (unlikely(IS_SHORT_READ(token)))\n\t\tstatus = -EREMOTEIO;\n\n\t \n\tif (token & QTD_STS_HALT) {\n\t\tif (token & QTD_STS_BABBLE) {\n\t\t\t \n\t\t\tstatus = -EOVERFLOW;\n\t\t \n\t\t} else if (QTD_CERR(token)) {\n\t\t\tstatus = -EPIPE;\n\n\t\t \n\t\t} else if (token & QTD_STS_MMF) {\n\t\t\t \n\t\t\tstatus = -EPROTO;\n\t\t} else if (token & QTD_STS_DBE) {\n\t\t\tstatus = (QTD_PID(token) == 1)  \n\t\t\t\t? -ENOSR   \n\t\t\t\t: -ECOMM;  \n\t\t} else if (token & QTD_STS_XACT) {\n\t\t\t \n\t\t\tfotg210_dbg(fotg210, \"devpath %s ep%d%s 3strikes\\n\",\n\t\t\t\t\turb->dev->devpath,\n\t\t\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\");\n\t\t\tstatus = -EPROTO;\n\t\t} else {\t \n\t\t\tstatus = -EPROTO;\n\t\t}\n\n\t\tfotg210_dbg(fotg210,\n\t\t\t\t\"dev%d ep%d%s qtd token %08x --> status %d\\n\",\n\t\t\t\tusb_pipedevice(urb->pipe),\n\t\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\t\ttoken, status);\n\t}\n\n\treturn status;\n}\n\nstatic void fotg210_urb_done(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tint status)\n__releases(fotg210->lock)\n__acquires(fotg210->lock)\n{\n\tif (likely(urb->hcpriv != NULL)) {\n\t\tstruct fotg210_qh *qh = (struct fotg210_qh *) urb->hcpriv;\n\n\t\t \n\t\tif ((qh->hw->hw_info2 & cpu_to_hc32(fotg210, QH_SMASK)) != 0) {\n\n\t\t\t \n\t\t\tfotg210_to_hcd(fotg210)->self.bandwidth_int_reqs--;\n\t\t}\n\t}\n\n\tif (unlikely(urb->unlinked)) {\n\t\tINCR(fotg210->stats.unlink);\n\t} else {\n\t\t \n\t\tif (status == -EINPROGRESS || status == -EREMOTEIO)\n\t\t\tstatus = 0;\n\t\tINCR(fotg210->stats.complete);\n\t}\n\n#ifdef FOTG210_URB_TRACE\n\tfotg210_dbg(fotg210,\n\t\t\t\"%s %s urb %p ep%d%s status %d len %d/%d\\n\",\n\t\t\t__func__, urb->dev->devpath, urb,\n\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\tstatus,\n\t\t\turb->actual_length, urb->transfer_buffer_length);\n#endif\n\n\t \n\tusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\n\tspin_unlock(&fotg210->lock);\n\tusb_hcd_giveback_urb(fotg210_to_hcd(fotg210), urb, status);\n\tspin_lock(&fotg210->lock);\n}\n\nstatic int qh_schedule(struct fotg210_hcd *fotg210, struct fotg210_qh *qh);\n\n \nstatic unsigned qh_completions(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh)\n{\n\tstruct fotg210_qtd *last, *end = qh->dummy;\n\tstruct fotg210_qtd *qtd, *tmp;\n\tint last_status;\n\tint stopped;\n\tunsigned count = 0;\n\tu8 state;\n\tstruct fotg210_qh_hw *hw = qh->hw;\n\n\tif (unlikely(list_empty(&qh->qtd_list)))\n\t\treturn count;\n\n\t \n\tstate = qh->qh_state;\n\tqh->qh_state = QH_STATE_COMPLETING;\n\tstopped = (state == QH_STATE_IDLE);\n\nrescan:\n\tlast = NULL;\n\tlast_status = -EINPROGRESS;\n\tqh->needs_rescan = 0;\n\n\t \n\tlist_for_each_entry_safe(qtd, tmp, &qh->qtd_list, qtd_list) {\n\t\tstruct urb *urb;\n\t\tu32 token = 0;\n\n\t\turb = qtd->urb;\n\n\t\t \n\t\tif (last) {\n\t\t\tif (likely(last->urb != urb)) {\n\t\t\t\tfotg210_urb_done(fotg210, last->urb,\n\t\t\t\t\t\tlast_status);\n\t\t\t\tcount++;\n\t\t\t\tlast_status = -EINPROGRESS;\n\t\t\t}\n\t\t\tfotg210_qtd_free(fotg210, last);\n\t\t\tlast = NULL;\n\t\t}\n\n\t\t \n\t\tif (qtd == end)\n\t\t\tbreak;\n\n\t\t \n\t\trmb();\n\t\ttoken = hc32_to_cpu(fotg210, qtd->hw_token);\n\n\t\t \nretry_xacterr:\n\t\tif ((token & QTD_STS_ACTIVE) == 0) {\n\n\t\t\t \n\t\t\tif (token & QTD_STS_DBE)\n\t\t\t\tfotg210_dbg(fotg210,\n\t\t\t\t\t\"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\\n\",\n\t\t\t\t\turb, usb_endpoint_num(&urb->ep->desc),\n\t\t\t\t\tusb_endpoint_dir_in(&urb->ep->desc)\n\t\t\t\t\t\t? \"in\" : \"out\",\n\t\t\t\t\turb->transfer_buffer_length, qtd, qh);\n\n\t\t\t \n\t\t\tif ((token & QTD_STS_HALT) != 0) {\n\n\t\t\t\t \n\t\t\t\tif ((token & QTD_STS_XACT) &&\n\t\t\t\t\t\tQTD_CERR(token) == 0 &&\n\t\t\t\t\t\t++qh->xacterrs < QH_XACTERR_MAX &&\n\t\t\t\t\t\t!urb->unlinked) {\n\t\t\t\t\tfotg210_dbg(fotg210,\n\t\t\t\t\t\t\"detected XactErr len %zu/%zu retry %d\\n\",\n\t\t\t\t\t\tqtd->length - QTD_LENGTH(token),\n\t\t\t\t\t\tqtd->length,\n\t\t\t\t\t\tqh->xacterrs);\n\n\t\t\t\t\t \n\t\t\t\t\ttoken &= ~QTD_STS_HALT;\n\t\t\t\t\ttoken |= QTD_STS_ACTIVE |\n\t\t\t\t\t\t (FOTG210_TUNE_CERR << 10);\n\t\t\t\t\tqtd->hw_token = cpu_to_hc32(fotg210,\n\t\t\t\t\t\t\ttoken);\n\t\t\t\t\twmb();\n\t\t\t\t\thw->hw_token = cpu_to_hc32(fotg210,\n\t\t\t\t\t\t\ttoken);\n\t\t\t\t\tgoto retry_xacterr;\n\t\t\t\t}\n\t\t\t\tstopped = 1;\n\n\t\t\t \n\t\t\t} else if (IS_SHORT_READ(token) &&\n\t\t\t\t\t!(qtd->hw_alt_next &\n\t\t\t\t\tFOTG210_LIST_END(fotg210))) {\n\t\t\t\tstopped = 1;\n\t\t\t}\n\n\t\t \n\t\t} else if (likely(!stopped\n\t\t\t\t&& fotg210->rh_state >= FOTG210_RH_RUNNING)) {\n\t\t\tbreak;\n\n\t\t \n\t\t} else {\n\t\t\tstopped = 1;\n\n\t\t\t \n\t\t\tif (fotg210->rh_state < FOTG210_RH_RUNNING)\n\t\t\t\tlast_status = -ESHUTDOWN;\n\n\t\t\t \n\t\t\telse if (last_status == -EINPROGRESS && !urb->unlinked)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (state == QH_STATE_IDLE &&\n\t\t\t\t\tcpu_to_hc32(fotg210, qtd->qtd_dma)\n\t\t\t\t\t== hw->hw_current) {\n\t\t\t\ttoken = hc32_to_cpu(fotg210, hw->hw_token);\n\n\t\t\t\t \n\t\t\t\tfotg210_clear_tt_buffer(fotg210, qh, urb,\n\t\t\t\t\t\ttoken);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (last_status == -EINPROGRESS) {\n\t\t\tlast_status = qtd_copy_status(fotg210, urb,\n\t\t\t\t\tqtd->length, token);\n\t\t\tif (last_status == -EREMOTEIO &&\n\t\t\t\t\t(qtd->hw_alt_next &\n\t\t\t\t\tFOTG210_LIST_END(fotg210)))\n\t\t\t\tlast_status = -EINPROGRESS;\n\n\t\t\t \n\t\t\tif (unlikely(last_status != -EINPROGRESS &&\n\t\t\t\t\tlast_status != -EREMOTEIO)) {\n\t\t\t\t \n\t\t\t\tif (last_status != -EPIPE)\n\t\t\t\t\tfotg210_clear_tt_buffer(fotg210, qh,\n\t\t\t\t\t\t\turb, token);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\n\t\t\tlast = list_entry(qtd->qtd_list.prev,\n\t\t\t\t\tstruct fotg210_qtd, qtd_list);\n\t\t\tlast->hw_next = qtd->hw_next;\n\t\t}\n\n\t\t \n\t\tlist_del(&qtd->qtd_list);\n\t\tlast = qtd;\n\n\t\t \n\t\tqh->xacterrs = 0;\n\t}\n\n\t \n\tif (likely(last != NULL)) {\n\t\tfotg210_urb_done(fotg210, last->urb, last_status);\n\t\tcount++;\n\t\tfotg210_qtd_free(fotg210, last);\n\t}\n\n\t \n\tif (unlikely(qh->needs_rescan)) {\n\t\t \n\t\tif (state == QH_STATE_IDLE)\n\t\t\tgoto rescan;\n\n\t\t \n\t\tif (state != QH_STATE_LINKED)\n\t\t\tqh->needs_rescan = 0;\n\t}\n\n\t \n\tqh->qh_state = state;\n\n\t \n\tif (stopped != 0 || hw->hw_qtd_next == FOTG210_LIST_END(fotg210)) {\n\t\tswitch (state) {\n\t\tcase QH_STATE_IDLE:\n\t\t\tqh_refresh(fotg210, qh);\n\t\t\tbreak;\n\t\tcase QH_STATE_LINKED:\n\t\t\t \n\n\t\t\t \n\t\t\tqh->needs_rescan = 1;\n\t\t\tbreak;\n\t\t \n\t\t}\n\t}\n\n\treturn count;\n}\n\n \nstatic void qtd_list_free(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tstruct list_head *head)\n{\n\tstruct fotg210_qtd *qtd, *temp;\n\n\tlist_for_each_entry_safe(qtd, temp, head, qtd_list) {\n\t\tlist_del(&qtd->qtd_list);\n\t\tfotg210_qtd_free(fotg210, qtd);\n\t}\n}\n\n \nstatic struct list_head *qh_urb_transaction(struct fotg210_hcd *fotg210,\n\t\tstruct urb *urb, struct list_head *head, gfp_t flags)\n{\n\tstruct fotg210_qtd *qtd, *qtd_prev;\n\tdma_addr_t buf;\n\tint len, this_sg_len, maxpacket;\n\tint is_input;\n\tu32 token;\n\tint i;\n\tstruct scatterlist *sg;\n\n\t \n\tqtd = fotg210_qtd_alloc(fotg210, flags);\n\tif (unlikely(!qtd))\n\t\treturn NULL;\n\tlist_add_tail(&qtd->qtd_list, head);\n\tqtd->urb = urb;\n\n\ttoken = QTD_STS_ACTIVE;\n\ttoken |= (FOTG210_TUNE_CERR << 10);\n\t \n\n\tlen = urb->transfer_buffer_length;\n\tis_input = usb_pipein(urb->pipe);\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\t \n\t\tqtd_fill(fotg210, qtd, urb->setup_dma,\n\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\ttoken | (2   << 8), 8);\n\n\t\t \n\t\ttoken ^= QTD_TOGGLE;\n\t\tqtd_prev = qtd;\n\t\tqtd = fotg210_qtd_alloc(fotg210, flags);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t \n\t\tif (len == 0)\n\t\t\ttoken |= (1   << 8);\n\t}\n\n\t \n\ti = urb->num_mapped_sgs;\n\tif (len > 0 && i > 0) {\n\t\tsg = urb->sg;\n\t\tbuf = sg_dma_address(sg);\n\n\t\t \n\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t} else {\n\t\tsg = NULL;\n\t\tbuf = urb->transfer_dma;\n\t\tthis_sg_len = len;\n\t}\n\n\tif (is_input)\n\t\ttoken |= (1   << 8);\n\t \n\n\tmaxpacket = usb_maxpacket(urb->dev, urb->pipe);\n\n\t \n\tfor (;;) {\n\t\tint this_qtd_len;\n\n\t\tthis_qtd_len = qtd_fill(fotg210, qtd, buf, this_sg_len, token,\n\t\t\t\tmaxpacket);\n\t\tthis_sg_len -= this_qtd_len;\n\t\tlen -= this_qtd_len;\n\t\tbuf += this_qtd_len;\n\n\t\t \n\t\tif (is_input)\n\t\t\tqtd->hw_alt_next = fotg210->async->hw->hw_alt_next;\n\n\t\t \n\t\tif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\n\t\t\ttoken ^= QTD_TOGGLE;\n\n\t\tif (likely(this_sg_len <= 0)) {\n\t\t\tif (--i <= 0 || len <= 0)\n\t\t\t\tbreak;\n\t\t\tsg = sg_next(sg);\n\t\t\tbuf = sg_dma_address(sg);\n\t\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t\t}\n\n\t\tqtd_prev = qtd;\n\t\tqtd = fotg210_qtd_alloc(fotg210, flags);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\t}\n\n\t \n\tif (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0 ||\n\t\t\tusb_pipecontrol(urb->pipe)))\n\t\tqtd->hw_alt_next = FOTG210_LIST_END(fotg210);\n\n\t \n\tif (likely(urb->transfer_buffer_length != 0)) {\n\t\tint one_more = 0;\n\n\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\tone_more = 1;\n\t\t\ttoken ^= 0x0100;\t \n\t\t\ttoken |= QTD_TOGGLE;\t \n\t\t} else if (usb_pipeout(urb->pipe)\n\t\t\t\t&& (urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& !(urb->transfer_buffer_length % maxpacket)) {\n\t\t\tone_more = 1;\n\t\t}\n\t\tif (one_more) {\n\t\t\tqtd_prev = qtd;\n\t\t\tqtd = fotg210_qtd_alloc(fotg210, flags);\n\t\t\tif (unlikely(!qtd))\n\t\t\t\tgoto cleanup;\n\t\t\tqtd->urb = urb;\n\t\t\tqtd_prev->hw_next = QTD_NEXT(fotg210, qtd->qtd_dma);\n\t\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t\t \n\t\t\tqtd_fill(fotg210, qtd, 0, 0, token, 0);\n\t\t}\n\t}\n\n\t \n\tif (likely(!(urb->transfer_flags & URB_NO_INTERRUPT)))\n\t\tqtd->hw_token |= cpu_to_hc32(fotg210, QTD_IOC);\n\treturn head;\n\ncleanup:\n\tqtd_list_free(fotg210, urb, head);\n\treturn NULL;\n}\n\n \n\n\n \nstatic struct fotg210_qh *qh_make(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tgfp_t flags)\n{\n\tstruct fotg210_qh *qh = fotg210_qh_alloc(fotg210, flags);\n\tstruct usb_host_endpoint *ep;\n\tu32 info1 = 0, info2 = 0;\n\tint is_input, type;\n\tint maxp = 0;\n\tint mult;\n\tstruct usb_tt *tt = urb->dev->tt;\n\tstruct fotg210_qh_hw *hw;\n\n\tif (!qh)\n\t\treturn qh;\n\n\t \n\tinfo1 |= usb_pipeendpoint(urb->pipe) << 8;\n\tinfo1 |= usb_pipedevice(urb->pipe) << 0;\n\n\tis_input = usb_pipein(urb->pipe);\n\ttype = usb_pipetype(urb->pipe);\n\tep = usb_pipe_endpoint(urb->dev, urb->pipe);\n\tmaxp = usb_endpoint_maxp(&ep->desc);\n\tmult = usb_endpoint_maxp_mult(&ep->desc);\n\n\t \n\tif (maxp > 1024) {\n\t\tfotg210_dbg(fotg210, \"bogus qh maxpacket %d\\n\", maxp);\n\t\tgoto done;\n\t}\n\n\t \n\tif (type == PIPE_INTERRUPT) {\n\t\tqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\n\t\t\t\tis_input, 0, mult * maxp));\n\t\tqh->start = NO_FRAME;\n\n\t\tif (urb->dev->speed == USB_SPEED_HIGH) {\n\t\t\tqh->c_usecs = 0;\n\t\t\tqh->gap_uf = 0;\n\n\t\t\tqh->period = urb->interval >> 3;\n\t\t\tif (qh->period == 0 && urb->interval != 1) {\n\t\t\t\t \n\t\t\t\turb->interval = 1;\n\t\t\t} else if (qh->period > fotg210->periodic_size) {\n\t\t\t\tqh->period = fotg210->periodic_size;\n\t\t\t\turb->interval = qh->period << 3;\n\t\t\t}\n\t\t} else {\n\t\t\tint think_time;\n\n\t\t\t \n\t\t\tqh->gap_uf = 1 + usb_calc_bus_time(urb->dev->speed,\n\t\t\t\t\tis_input, 0, maxp) / (125 * 1000);\n\n\t\t\t \n\t\t\tif (is_input) {\t\t \n\t\t\t\tqh->c_usecs = qh->usecs + HS_USECS(0);\n\t\t\t\tqh->usecs = HS_USECS(1);\n\t\t\t} else {\t\t \n\t\t\t\tqh->usecs += HS_USECS(1);\n\t\t\t\tqh->c_usecs = HS_USECS(0);\n\t\t\t}\n\n\t\t\tthink_time = tt ? tt->think_time : 0;\n\t\t\tqh->tt_usecs = NS_TO_US(think_time +\n\t\t\t\t\tusb_calc_bus_time(urb->dev->speed,\n\t\t\t\t\tis_input, 0, maxp));\n\t\t\tqh->period = urb->interval;\n\t\t\tif (qh->period > fotg210->periodic_size) {\n\t\t\t\tqh->period = fotg210->periodic_size;\n\t\t\t\turb->interval = qh->period;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tqh->dev = urb->dev;\n\n\t \n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tinfo1 |= QH_LOW_SPEED;\n\t\tfallthrough;\n\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tif (type != PIPE_INTERRUPT)\n\t\t\tinfo1 |= (FOTG210_TUNE_RL_TT << 28);\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= QH_CONTROL_EP;\t\t \n\t\t\tinfo1 |= QH_TOGGLE_CTL;\t\t \n\t\t}\n\t\tinfo1 |= maxp << 16;\n\n\t\tinfo2 |= (FOTG210_TUNE_MULT_TT << 30);\n\n\t\t \n\t\tif (fotg210_has_fsl_portno_bug(fotg210))\n\t\t\tinfo2 |= (urb->dev->ttport-1) << 23;\n\t\telse\n\t\t\tinfo2 |= urb->dev->ttport << 23;\n\n\t\t \n\t\tif (tt && tt->hub != fotg210_to_hcd(fotg210)->self.root_hub)\n\t\t\tinfo2 |= tt->hub->devnum << 16;\n\n\t\t \n\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\t\t \n\t\tinfo1 |= QH_HIGH_SPEED;\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= (FOTG210_TUNE_RL_HS << 28);\n\t\t\tinfo1 |= 64 << 16;\t \n\t\t\tinfo1 |= QH_TOGGLE_CTL;\t \n\t\t\tinfo2 |= (FOTG210_TUNE_MULT_HS << 30);\n\t\t} else if (type == PIPE_BULK) {\n\t\t\tinfo1 |= (FOTG210_TUNE_RL_HS << 28);\n\t\t\t \n\t\t\tinfo1 |= maxp << 16;\n\t\t\tinfo2 |= (FOTG210_TUNE_MULT_HS << 30);\n\t\t} else {\t\t \n\t\t\tinfo1 |= maxp << 16;\n\t\t\tinfo2 |= mult << 30;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tfotg210_dbg(fotg210, \"bogus dev %p speed %d\\n\", urb->dev,\n\t\t\t\turb->dev->speed);\ndone:\n\t\tqh_destroy(fotg210, qh);\n\t\treturn NULL;\n\t}\n\n\t \n\n\t \n\tqh->qh_state = QH_STATE_IDLE;\n\thw = qh->hw;\n\thw->hw_info1 = cpu_to_hc32(fotg210, info1);\n\thw->hw_info2 = cpu_to_hc32(fotg210, info2);\n\tqh->is_out = !is_input;\n\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input, 1);\n\tqh_refresh(fotg210, qh);\n\treturn qh;\n}\n\nstatic void enable_async(struct fotg210_hcd *fotg210)\n{\n\tif (fotg210->async_count++)\n\t\treturn;\n\n\t \n\tfotg210->enabled_hrtimer_events &= ~BIT(FOTG210_HRTIMER_DISABLE_ASYNC);\n\n\t \n\tfotg210_poll_ASS(fotg210);\n\tturn_on_io_watchdog(fotg210);\n}\n\nstatic void disable_async(struct fotg210_hcd *fotg210)\n{\n\tif (--fotg210->async_count)\n\t\treturn;\n\n\t \n\tWARN_ON(fotg210->async->qh_next.qh || fotg210->async_unlink);\n\n\t \n\tfotg210_poll_ASS(fotg210);\n}\n\n \n\nstatic void qh_link_async(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\t__hc32 dma = QH_NEXT(fotg210, qh->qh_dma);\n\tstruct fotg210_qh *head;\n\n\t \n\tif (unlikely(qh->clearing_tt))\n\t\treturn;\n\n\tWARN_ON(qh->qh_state != QH_STATE_IDLE);\n\n\t \n\tqh_refresh(fotg210, qh);\n\n\t \n\thead = fotg210->async;\n\tqh->qh_next = head->qh_next;\n\tqh->hw->hw_next = head->hw->hw_next;\n\twmb();\n\n\thead->qh_next.qh = qh;\n\thead->hw->hw_next = dma;\n\n\tqh->xacterrs = 0;\n\tqh->qh_state = QH_STATE_LINKED;\n\t \n\n\tenable_async(fotg210);\n}\n\n \nstatic struct fotg210_qh *qh_append_tds(struct fotg210_hcd *fotg210,\n\t\tstruct urb *urb, struct list_head *qtd_list,\n\t\tint epnum, void **ptr)\n{\n\tstruct fotg210_qh *qh = NULL;\n\t__hc32 qh_addr_mask = cpu_to_hc32(fotg210, 0x7f);\n\n\tqh = (struct fotg210_qh *) *ptr;\n\tif (unlikely(qh == NULL)) {\n\t\t \n\t\tqh = qh_make(fotg210, urb, GFP_ATOMIC);\n\t\t*ptr = qh;\n\t}\n\tif (likely(qh != NULL)) {\n\t\tstruct fotg210_qtd *qtd;\n\n\t\tif (unlikely(list_empty(qtd_list)))\n\t\t\tqtd = NULL;\n\t\telse\n\t\t\tqtd = list_entry(qtd_list->next, struct fotg210_qtd,\n\t\t\t\t\tqtd_list);\n\n\t\t \n\t\tif (unlikely(epnum == 0)) {\n\t\t\t \n\t\t\tif (usb_pipedevice(urb->pipe) == 0)\n\t\t\t\tqh->hw->hw_info1 &= ~qh_addr_mask;\n\t\t}\n\n\t\t \n\t\tif (likely(qtd != NULL)) {\n\t\t\tstruct fotg210_qtd *dummy;\n\t\t\tdma_addr_t dma;\n\t\t\t__hc32 token;\n\n\t\t\t \n\t\t\ttoken = qtd->hw_token;\n\t\t\tqtd->hw_token = HALT_BIT(fotg210);\n\n\t\t\tdummy = qh->dummy;\n\n\t\t\tdma = dummy->qtd_dma;\n\t\t\t*dummy = *qtd;\n\t\t\tdummy->qtd_dma = dma;\n\n\t\t\tlist_del(&qtd->qtd_list);\n\t\t\tlist_add(&dummy->qtd_list, qtd_list);\n\t\t\tlist_splice_tail(qtd_list, &qh->qtd_list);\n\n\t\t\tfotg210_qtd_init(fotg210, qtd, qtd->qtd_dma);\n\t\t\tqh->dummy = qtd;\n\n\t\t\t \n\t\t\tdma = qtd->qtd_dma;\n\t\t\tqtd = list_entry(qh->qtd_list.prev,\n\t\t\t\t\tstruct fotg210_qtd, qtd_list);\n\t\t\tqtd->hw_next = QTD_NEXT(fotg210, dma);\n\n\t\t\t \n\t\t\twmb();\n\t\t\tdummy->hw_token = token;\n\n\t\t\turb->hcpriv = qh;\n\t\t}\n\t}\n\treturn qh;\n}\n\nstatic int submit_async(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tstruct list_head *qtd_list, gfp_t mem_flags)\n{\n\tint epnum;\n\tunsigned long flags;\n\tstruct fotg210_qh *qh = NULL;\n\tint rc;\n\n\tepnum = urb->ep->desc.bEndpointAddress;\n\n#ifdef FOTG210_URB_TRACE\n\t{\n\t\tstruct fotg210_qtd *qtd;\n\n\t\tqtd = list_entry(qtd_list->next, struct fotg210_qtd, qtd_list);\n\t\tfotg210_dbg(fotg210,\n\t\t\t\t\"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\\n\",\n\t\t\t\t__func__, urb->dev->devpath, urb,\n\t\t\t\tepnum & 0x0f, (epnum & USB_DIR_IN)\n\t\t\t\t\t? \"in\" : \"out\",\n\t\t\t\turb->transfer_buffer_length,\n\t\t\t\tqtd, urb->ep->hcpriv);\n\t}\n#endif\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\n\t\trc = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n\trc = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\n\tif (unlikely(rc))\n\t\tgoto done;\n\n\tqh = qh_append_tds(fotg210, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tif (unlikely(qh == NULL)) {\n\t\tusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\n\t\trc = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (likely(qh->qh_state == QH_STATE_IDLE))\n\t\tqh_link_async(fotg210, qh);\ndone:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\tif (unlikely(qh == NULL))\n\t\tqtd_list_free(fotg210, urb, qtd_list);\n\treturn rc;\n}\n\nstatic void single_unlink_async(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh)\n{\n\tstruct fotg210_qh *prev;\n\n\t \n\tqh->qh_state = QH_STATE_UNLINK;\n\tif (fotg210->async_unlink)\n\t\tfotg210->async_unlink_last->unlink_next = qh;\n\telse\n\t\tfotg210->async_unlink = qh;\n\tfotg210->async_unlink_last = qh;\n\n\t \n\tprev = fotg210->async;\n\twhile (prev->qh_next.qh != qh)\n\t\tprev = prev->qh_next.qh;\n\n\tprev->hw->hw_next = qh->hw->hw_next;\n\tprev->qh_next = qh->qh_next;\n\tif (fotg210->qh_scan_next == qh)\n\t\tfotg210->qh_scan_next = qh->qh_next.qh;\n}\n\nstatic void start_iaa_cycle(struct fotg210_hcd *fotg210, bool nested)\n{\n\t \n\tif (fotg210->async_iaa || fotg210->async_unlinking)\n\t\treturn;\n\n\t \n\tfotg210->async_iaa = fotg210->async_unlink;\n\tfotg210->async_unlink = NULL;\n\n\t \n\tif (unlikely(fotg210->rh_state < FOTG210_RH_RUNNING)) {\n\t\tif (!nested)\t\t \n\t\t\tend_unlink_async(fotg210);\n\n\t \n\t} else if (likely(fotg210->rh_state == FOTG210_RH_RUNNING)) {\n\t\t \n\t\twmb();\n\n\t\tfotg210_writel(fotg210, fotg210->command | CMD_IAAD,\n\t\t\t\t&fotg210->regs->command);\n\t\tfotg210_readl(fotg210, &fotg210->regs->command);\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_IAA_WATCHDOG,\n\t\t\t\ttrue);\n\t}\n}\n\n \n\nstatic void end_unlink_async(struct fotg210_hcd *fotg210)\n{\n\tstruct fotg210_qh *qh;\n\n\t \nrestart:\n\tfotg210->async_unlinking = true;\n\twhile (fotg210->async_iaa) {\n\t\tqh = fotg210->async_iaa;\n\t\tfotg210->async_iaa = qh->unlink_next;\n\t\tqh->unlink_next = NULL;\n\n\t\tqh->qh_state = QH_STATE_IDLE;\n\t\tqh->qh_next.qh = NULL;\n\n\t\tqh_completions(fotg210, qh);\n\t\tif (!list_empty(&qh->qtd_list) &&\n\t\t\t\tfotg210->rh_state == FOTG210_RH_RUNNING)\n\t\t\tqh_link_async(fotg210, qh);\n\t\tdisable_async(fotg210);\n\t}\n\tfotg210->async_unlinking = false;\n\n\t \n\tif (fotg210->async_unlink) {\n\t\tstart_iaa_cycle(fotg210, true);\n\t\tif (unlikely(fotg210->rh_state < FOTG210_RH_RUNNING))\n\t\t\tgoto restart;\n\t}\n}\n\nstatic void unlink_empty_async(struct fotg210_hcd *fotg210)\n{\n\tstruct fotg210_qh *qh, *next;\n\tbool stopped = (fotg210->rh_state < FOTG210_RH_RUNNING);\n\tbool check_unlinks_later = false;\n\n\t \n\tnext = fotg210->async->qh_next.qh;\n\twhile (next) {\n\t\tqh = next;\n\t\tnext = qh->qh_next.qh;\n\n\t\tif (list_empty(&qh->qtd_list) &&\n\t\t\t\tqh->qh_state == QH_STATE_LINKED) {\n\t\t\tif (!stopped && qh->unlink_cycle ==\n\t\t\t\t\tfotg210->async_unlink_cycle)\n\t\t\t\tcheck_unlinks_later = true;\n\t\t\telse\n\t\t\t\tsingle_unlink_async(fotg210, qh);\n\t\t}\n\t}\n\n\t \n\tif (fotg210->async_unlink)\n\t\tstart_iaa_cycle(fotg210, false);\n\n\t \n\tif (check_unlinks_later) {\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_ASYNC_UNLINKS,\n\t\t\t\ttrue);\n\t\t++fotg210->async_unlink_cycle;\n\t}\n}\n\n \n \n\nstatic void start_unlink_async(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh)\n{\n\t \n\tif (qh->qh_state != QH_STATE_LINKED) {\n\t\tif (qh->qh_state == QH_STATE_COMPLETING)\n\t\t\tqh->needs_rescan = 1;\n\t\treturn;\n\t}\n\n\tsingle_unlink_async(fotg210, qh);\n\tstart_iaa_cycle(fotg210, false);\n}\n\nstatic void scan_async(struct fotg210_hcd *fotg210)\n{\n\tstruct fotg210_qh *qh;\n\tbool check_unlinks_later = false;\n\n\tfotg210->qh_scan_next = fotg210->async->qh_next.qh;\n\twhile (fotg210->qh_scan_next) {\n\t\tqh = fotg210->qh_scan_next;\n\t\tfotg210->qh_scan_next = qh->qh_next.qh;\nrescan:\n\t\t \n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tint temp;\n\n\t\t\t \n\t\t\ttemp = qh_completions(fotg210, qh);\n\t\t\tif (qh->needs_rescan) {\n\t\t\t\tstart_unlink_async(fotg210, qh);\n\t\t\t} else if (list_empty(&qh->qtd_list)\n\t\t\t\t\t&& qh->qh_state == QH_STATE_LINKED) {\n\t\t\t\tqh->unlink_cycle = fotg210->async_unlink_cycle;\n\t\t\t\tcheck_unlinks_later = true;\n\t\t\t} else if (temp != 0)\n\t\t\t\tgoto rescan;\n\t\t}\n\t}\n\n\t \n\tif (check_unlinks_later && fotg210->rh_state == FOTG210_RH_RUNNING &&\n\t\t\t!(fotg210->enabled_hrtimer_events &\n\t\t\tBIT(FOTG210_HRTIMER_ASYNC_UNLINKS))) {\n\t\tfotg210_enable_event(fotg210,\n\t\t\t\tFOTG210_HRTIMER_ASYNC_UNLINKS, true);\n\t\t++fotg210->async_unlink_cycle;\n\t}\n}\n \nstatic int fotg210_get_frame(struct usb_hcd *hcd);\n\n \nstatic union fotg210_shadow *periodic_next_shadow(struct fotg210_hcd *fotg210,\n\t\tunion fotg210_shadow *periodic, __hc32 tag)\n{\n\tswitch (hc32_to_cpu(fotg210, tag)) {\n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->qh_next;\n\tcase Q_TYPE_FSTN:\n\t\treturn &periodic->fstn->fstn_next;\n\tdefault:\n\t\treturn &periodic->itd->itd_next;\n\t}\n}\n\nstatic __hc32 *shadow_next_periodic(struct fotg210_hcd *fotg210,\n\t\tunion fotg210_shadow *periodic, __hc32 tag)\n{\n\tswitch (hc32_to_cpu(fotg210, tag)) {\n\t \n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->hw->hw_next;\n\t \n\tdefault:\n\t\treturn periodic->hw_next;\n\t}\n}\n\n \nstatic void periodic_unlink(struct fotg210_hcd *fotg210, unsigned frame,\n\t\tvoid *ptr)\n{\n\tunion fotg210_shadow *prev_p = &fotg210->pshadow[frame];\n\t__hc32 *hw_p = &fotg210->periodic[frame];\n\tunion fotg210_shadow here = *prev_p;\n\n\t \n\twhile (here.ptr && here.ptr != ptr) {\n\t\tprev_p = periodic_next_shadow(fotg210, prev_p,\n\t\t\t\tQ_NEXT_TYPE(fotg210, *hw_p));\n\t\thw_p = shadow_next_periodic(fotg210, &here,\n\t\t\t\tQ_NEXT_TYPE(fotg210, *hw_p));\n\t\there = *prev_p;\n\t}\n\t \n\tif (!here.ptr)\n\t\treturn;\n\n\t \n\t*prev_p = *periodic_next_shadow(fotg210, &here,\n\t\t\tQ_NEXT_TYPE(fotg210, *hw_p));\n\n\t*hw_p = *shadow_next_periodic(fotg210, &here,\n\t\t\tQ_NEXT_TYPE(fotg210, *hw_p));\n}\n\n \nstatic unsigned short periodic_usecs(struct fotg210_hcd *fotg210,\n\t\tunsigned frame, unsigned uframe)\n{\n\t__hc32 *hw_p = &fotg210->periodic[frame];\n\tunion fotg210_shadow *q = &fotg210->pshadow[frame];\n\tunsigned usecs = 0;\n\tstruct fotg210_qh_hw *hw;\n\n\twhile (q->ptr) {\n\t\tswitch (hc32_to_cpu(fotg210, Q_NEXT_TYPE(fotg210, *hw_p))) {\n\t\tcase Q_TYPE_QH:\n\t\t\thw = q->qh->hw;\n\t\t\t \n\t\t\tif (hw->hw_info2 & cpu_to_hc32(fotg210, 1 << uframe))\n\t\t\t\tusecs += q->qh->usecs;\n\t\t\t \n\t\t\tif (hw->hw_info2 & cpu_to_hc32(fotg210,\n\t\t\t\t\t1 << (8 + uframe)))\n\t\t\t\tusecs += q->qh->c_usecs;\n\t\t\thw_p = &hw->hw_next;\n\t\t\tq = &q->qh->qh_next;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\t \n\t\t\tif (q->fstn->hw_prev != FOTG210_LIST_END(fotg210))\n\t\t\t\tfotg210_dbg(fotg210, \"ignoring FSTN cost ...\\n\");\n\n\t\t\thw_p = &q->fstn->hw_next;\n\t\t\tq = &q->fstn->fstn_next;\n\t\t\tbreak;\n\t\tcase Q_TYPE_ITD:\n\t\t\tif (q->itd->hw_transaction[uframe])\n\t\t\t\tusecs += q->itd->stream->usecs;\n\t\t\thw_p = &q->itd->hw_next;\n\t\t\tq = &q->itd->itd_next;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (usecs > fotg210->uframe_periodic_max)\n\t\tfotg210_err(fotg210, \"uframe %d sched overrun: %d usecs\\n\",\n\t\t\t\tframe * 8 + uframe, usecs);\n\treturn usecs;\n}\n\nstatic int same_tt(struct usb_device *dev1, struct usb_device *dev2)\n{\n\tif (!dev1->tt || !dev2->tt)\n\t\treturn 0;\n\tif (dev1->tt != dev2->tt)\n\t\treturn 0;\n\tif (dev1->tt->multi)\n\t\treturn dev1->ttport == dev2->ttport;\n\telse\n\t\treturn 1;\n}\n\n \nstatic int tt_no_collision(struct fotg210_hcd *fotg210, unsigned period,\n\t\tstruct usb_device *dev, unsigned frame, u32 uf_mask)\n{\n\tif (period == 0)\t \n\t\treturn 0;\n\n\t \n\tfor (; frame < fotg210->periodic_size; frame += period) {\n\t\tunion fotg210_shadow here;\n\t\t__hc32 type;\n\t\tstruct fotg210_qh_hw *hw;\n\n\t\there = fotg210->pshadow[frame];\n\t\ttype = Q_NEXT_TYPE(fotg210, fotg210->periodic[frame]);\n\t\twhile (here.ptr) {\n\t\t\tswitch (hc32_to_cpu(fotg210, type)) {\n\t\t\tcase Q_TYPE_ITD:\n\t\t\t\ttype = Q_NEXT_TYPE(fotg210, here.itd->hw_next);\n\t\t\t\there = here.itd->itd_next;\n\t\t\t\tcontinue;\n\t\t\tcase Q_TYPE_QH:\n\t\t\t\thw = here.qh->hw;\n\t\t\t\tif (same_tt(dev, here.qh->dev)) {\n\t\t\t\t\tu32 mask;\n\n\t\t\t\t\tmask = hc32_to_cpu(fotg210,\n\t\t\t\t\t\t\thw->hw_info2);\n\t\t\t\t\t \n\t\t\t\t\tmask |= mask >> 8;\n\t\t\t\t\tif (mask & uf_mask)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttype = Q_NEXT_TYPE(fotg210, hw->hw_next);\n\t\t\t\there = here.qh->qh_next;\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\tfotg210_dbg(fotg210,\n\t\t\t\t\t\t\"periodic frame %d bogus type %d\\n\",\n\t\t\t\t\t\tframe, type);\n\t\t\t}\n\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic void enable_periodic(struct fotg210_hcd *fotg210)\n{\n\tif (fotg210->periodic_count++)\n\t\treturn;\n\n\t \n\tfotg210->enabled_hrtimer_events &=\n\t\t~BIT(FOTG210_HRTIMER_DISABLE_PERIODIC);\n\n\t \n\tfotg210_poll_PSS(fotg210);\n\tturn_on_io_watchdog(fotg210);\n}\n\nstatic void disable_periodic(struct fotg210_hcd *fotg210)\n{\n\tif (--fotg210->periodic_count)\n\t\treturn;\n\n\t \n\tfotg210_poll_PSS(fotg210);\n}\n\n \nstatic void qh_link_periodic(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\tunsigned i;\n\tunsigned period = qh->period;\n\n\tdev_dbg(&qh->dev->dev,\n\t\t\t\"link qh%d-%04x/%p start %d [%d/%d us]\\n\", period,\n\t\t\thc32_to_cpup(fotg210, &qh->hw->hw_info2) &\n\t\t\t(QH_CMASK | QH_SMASK), qh, qh->start, qh->usecs,\n\t\t\tqh->c_usecs);\n\n\t \n\tif (period == 0)\n\t\tperiod = 1;\n\n\tfor (i = qh->start; i < fotg210->periodic_size; i += period) {\n\t\tunion fotg210_shadow *prev = &fotg210->pshadow[i];\n\t\t__hc32 *hw_p = &fotg210->periodic[i];\n\t\tunion fotg210_shadow here = *prev;\n\t\t__hc32 type = 0;\n\n\t\t \n\t\twhile (here.ptr) {\n\t\t\ttype = Q_NEXT_TYPE(fotg210, *hw_p);\n\t\t\tif (type == cpu_to_hc32(fotg210, Q_TYPE_QH))\n\t\t\t\tbreak;\n\t\t\tprev = periodic_next_shadow(fotg210, prev, type);\n\t\t\thw_p = shadow_next_periodic(fotg210, &here, type);\n\t\t\there = *prev;\n\t\t}\n\n\t\t \n\t\twhile (here.ptr && qh != here.qh) {\n\t\t\tif (qh->period > here.qh->period)\n\t\t\t\tbreak;\n\t\t\tprev = &here.qh->qh_next;\n\t\t\thw_p = &here.qh->hw->hw_next;\n\t\t\there = *prev;\n\t\t}\n\t\t \n\t\tif (qh != here.qh) {\n\t\t\tqh->qh_next = here;\n\t\t\tif (here.qh)\n\t\t\t\tqh->hw->hw_next = *hw_p;\n\t\t\twmb();\n\t\t\tprev->qh = qh;\n\t\t\t*hw_p = QH_NEXT(fotg210, qh->qh_dma);\n\t\t}\n\t}\n\tqh->qh_state = QH_STATE_LINKED;\n\tqh->xacterrs = 0;\n\n\t \n\tfotg210_to_hcd(fotg210)->self.bandwidth_allocated += qh->period\n\t\t? ((qh->usecs + qh->c_usecs) / qh->period)\n\t\t: (qh->usecs * 8);\n\n\tlist_add(&qh->intr_node, &fotg210->intr_qh_list);\n\n\t \n\t++fotg210->intr_count;\n\tenable_periodic(fotg210);\n}\n\nstatic void qh_unlink_periodic(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh)\n{\n\tunsigned i;\n\tunsigned period;\n\n\t \n\n\t \n\tperiod = qh->period;\n\tif (!period)\n\t\tperiod = 1;\n\n\tfor (i = qh->start; i < fotg210->periodic_size; i += period)\n\t\tperiodic_unlink(fotg210, i, qh);\n\n\t \n\tfotg210_to_hcd(fotg210)->self.bandwidth_allocated -= qh->period\n\t\t? ((qh->usecs + qh->c_usecs) / qh->period)\n\t\t: (qh->usecs * 8);\n\n\tdev_dbg(&qh->dev->dev,\n\t\t\t\"unlink qh%d-%04x/%p start %d [%d/%d us]\\n\",\n\t\t\tqh->period, hc32_to_cpup(fotg210, &qh->hw->hw_info2) &\n\t\t\t(QH_CMASK | QH_SMASK), qh, qh->start, qh->usecs,\n\t\t\tqh->c_usecs);\n\n\t \n\tqh->qh_state = QH_STATE_UNLINK;\n\tqh->qh_next.ptr = NULL;\n\n\tif (fotg210->qh_scan_next == qh)\n\t\tfotg210->qh_scan_next = list_entry(qh->intr_node.next,\n\t\t\t\tstruct fotg210_qh, intr_node);\n\tlist_del(&qh->intr_node);\n}\n\nstatic void start_unlink_intr(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_qh *qh)\n{\n\t \n\tif (qh->qh_state != QH_STATE_LINKED) {\n\t\tif (qh->qh_state == QH_STATE_COMPLETING)\n\t\t\tqh->needs_rescan = 1;\n\t\treturn;\n\t}\n\n\tqh_unlink_periodic(fotg210, qh);\n\n\t \n\twmb();\n\n\t \n\tqh->unlink_cycle = fotg210->intr_unlink_cycle;\n\n\t \n\tif (fotg210->intr_unlink)\n\t\tfotg210->intr_unlink_last->unlink_next = qh;\n\telse\n\t\tfotg210->intr_unlink = qh;\n\tfotg210->intr_unlink_last = qh;\n\n\tif (fotg210->intr_unlinking)\n\t\t;\t \n\telse if (fotg210->rh_state < FOTG210_RH_RUNNING)\n\t\tfotg210_handle_intr_unlinks(fotg210);\n\telse if (fotg210->intr_unlink == qh) {\n\t\tfotg210_enable_event(fotg210, FOTG210_HRTIMER_UNLINK_INTR,\n\t\t\t\ttrue);\n\t\t++fotg210->intr_unlink_cycle;\n\t}\n}\n\nstatic void end_unlink_intr(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\tstruct fotg210_qh_hw *hw = qh->hw;\n\tint rc;\n\n\tqh->qh_state = QH_STATE_IDLE;\n\thw->hw_next = FOTG210_LIST_END(fotg210);\n\n\tqh_completions(fotg210, qh);\n\n\t \n\tif (!list_empty(&qh->qtd_list) &&\n\t\t\tfotg210->rh_state == FOTG210_RH_RUNNING) {\n\t\trc = qh_schedule(fotg210, qh);\n\n\t\t \n\t\tif (rc != 0)\n\t\t\tfotg210_err(fotg210, \"can't reschedule qh %p, err %d\\n\",\n\t\t\t\t\tqh, rc);\n\t}\n\n\t \n\t--fotg210->intr_count;\n\tdisable_periodic(fotg210);\n}\n\nstatic int check_period(struct fotg210_hcd *fotg210, unsigned frame,\n\t\tunsigned uframe, unsigned period, unsigned usecs)\n{\n\tint claimed;\n\n\t \n\tif (uframe >= 8)\n\t\treturn 0;\n\n\t \n\tusecs = fotg210->uframe_periodic_max - usecs;\n\n\t \n\tif (unlikely(period == 0)) {\n\t\tdo {\n\t\t\tfor (uframe = 0; uframe < 7; uframe++) {\n\t\t\t\tclaimed = periodic_usecs(fotg210, frame,\n\t\t\t\t\t\tuframe);\n\t\t\t\tif (claimed > usecs)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while ((frame += 1) < fotg210->periodic_size);\n\n\t \n\t} else {\n\t\tdo {\n\t\t\tclaimed = periodic_usecs(fotg210, frame, uframe);\n\t\t\tif (claimed > usecs)\n\t\t\t\treturn 0;\n\t\t} while ((frame += period) < fotg210->periodic_size);\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int check_intr_schedule(struct fotg210_hcd *fotg210, unsigned frame,\n\t\tunsigned uframe, const struct fotg210_qh *qh, __hc32 *c_maskp)\n{\n\tint retval = -ENOSPC;\n\tu8 mask = 0;\n\n\tif (qh->c_usecs && uframe >= 6)\t\t \n\t\tgoto done;\n\n\tif (!check_period(fotg210, frame, uframe, qh->period, qh->usecs))\n\t\tgoto done;\n\tif (!qh->c_usecs) {\n\t\tretval = 0;\n\t\t*c_maskp = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tmask = 0x03 << (uframe + qh->gap_uf);\n\t*c_maskp = cpu_to_hc32(fotg210, mask << 8);\n\n\tmask |= 1 << uframe;\n\tif (tt_no_collision(fotg210, qh->period, qh->dev, frame, mask)) {\n\t\tif (!check_period(fotg210, frame, uframe + qh->gap_uf + 1,\n\t\t\t\tqh->period, qh->c_usecs))\n\t\t\tgoto done;\n\t\tif (!check_period(fotg210, frame, uframe + qh->gap_uf,\n\t\t\t\tqh->period, qh->c_usecs))\n\t\t\tgoto done;\n\t\tretval = 0;\n\t}\ndone:\n\treturn retval;\n}\n\n \nstatic int qh_schedule(struct fotg210_hcd *fotg210, struct fotg210_qh *qh)\n{\n\tint status;\n\tunsigned uframe;\n\t__hc32 c_mask;\n\tunsigned frame;\t \n\tstruct fotg210_qh_hw *hw = qh->hw;\n\n\tqh_refresh(fotg210, qh);\n\thw->hw_next = FOTG210_LIST_END(fotg210);\n\tframe = qh->start;\n\n\t \n\tif (frame < qh->period) {\n\t\tuframe = ffs(hc32_to_cpup(fotg210, &hw->hw_info2) & QH_SMASK);\n\t\tstatus = check_intr_schedule(fotg210, frame, --uframe,\n\t\t\t\tqh, &c_mask);\n\t} else {\n\t\tuframe = 0;\n\t\tc_mask = 0;\n\t\tstatus = -ENOSPC;\n\t}\n\n\t \n\tif (status) {\n\t\t \n\t\tif (qh->period) {\n\t\t\tint i;\n\n\t\t\tfor (i = qh->period; status && i > 0; --i) {\n\t\t\t\tframe = ++fotg210->random_frame % qh->period;\n\t\t\t\tfor (uframe = 0; uframe < 8; uframe++) {\n\t\t\t\t\tstatus = check_intr_schedule(fotg210,\n\t\t\t\t\t\t\tframe, uframe, qh,\n\t\t\t\t\t\t\t&c_mask);\n\t\t\t\t\tif (status == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t \n\t\t} else {\n\t\t\tframe = 0;\n\t\t\tstatus = check_intr_schedule(fotg210, 0, 0, qh,\n\t\t\t\t\t&c_mask);\n\t\t}\n\t\tif (status)\n\t\t\tgoto done;\n\t\tqh->start = frame;\n\n\t\t \n\t\thw->hw_info2 &= cpu_to_hc32(fotg210, ~(QH_CMASK | QH_SMASK));\n\t\thw->hw_info2 |= qh->period\n\t\t\t? cpu_to_hc32(fotg210, 1 << uframe)\n\t\t\t: cpu_to_hc32(fotg210, QH_SMASK);\n\t\thw->hw_info2 |= c_mask;\n\t} else\n\t\tfotg210_dbg(fotg210, \"reused qh %p schedule\\n\", qh);\n\n\t \n\tqh_link_periodic(fotg210, qh);\ndone:\n\treturn status;\n}\n\nstatic int intr_submit(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tstruct list_head *qtd_list, gfp_t mem_flags)\n{\n\tunsigned epnum;\n\tunsigned long flags;\n\tstruct fotg210_qh *qh;\n\tint status;\n\tstruct list_head empty;\n\n\t \n\tepnum = urb->ep->desc.bEndpointAddress;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done_not_linked;\n\t}\n\tstatus = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\n\tif (unlikely(status))\n\t\tgoto done_not_linked;\n\n\t \n\tINIT_LIST_HEAD(&empty);\n\tqh = qh_append_tds(fotg210, urb, &empty, epnum, &urb->ep->hcpriv);\n\tif (qh == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto done;\n\t}\n\tif (qh->qh_state == QH_STATE_IDLE) {\n\t\tstatus = qh_schedule(fotg210, qh);\n\t\tif (status)\n\t\t\tgoto done;\n\t}\n\n\t \n\tqh = qh_append_tds(fotg210, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tBUG_ON(qh == NULL);\n\n\t \n\tfotg210_to_hcd(fotg210)->self.bandwidth_int_reqs++;\n\ndone:\n\tif (unlikely(status))\n\t\tusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\ndone_not_linked:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\tif (status)\n\t\tqtd_list_free(fotg210, urb, qtd_list);\n\n\treturn status;\n}\n\nstatic void scan_intr(struct fotg210_hcd *fotg210)\n{\n\tstruct fotg210_qh *qh;\n\n\tlist_for_each_entry_safe(qh, fotg210->qh_scan_next,\n\t\t\t&fotg210->intr_qh_list, intr_node) {\nrescan:\n\t\t \n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tint temp;\n\n\t\t\t \n\t\t\ttemp = qh_completions(fotg210, qh);\n\t\t\tif (unlikely(qh->needs_rescan ||\n\t\t\t\t\t(list_empty(&qh->qtd_list) &&\n\t\t\t\t\tqh->qh_state == QH_STATE_LINKED)))\n\t\t\t\tstart_unlink_intr(fotg210, qh);\n\t\t\telse if (temp != 0)\n\t\t\t\tgoto rescan;\n\t\t}\n\t}\n}\n\n \n\nstatic struct fotg210_iso_stream *iso_stream_alloc(gfp_t mem_flags)\n{\n\tstruct fotg210_iso_stream *stream;\n\n\tstream = kzalloc(sizeof(*stream), mem_flags);\n\tif (likely(stream != NULL)) {\n\t\tINIT_LIST_HEAD(&stream->td_list);\n\t\tINIT_LIST_HEAD(&stream->free_list);\n\t\tstream->next_uframe = -1;\n\t}\n\treturn stream;\n}\n\nstatic void iso_stream_init(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_iso_stream *stream, struct usb_device *dev,\n\t\tint pipe, unsigned interval)\n{\n\tu32 buf1;\n\tunsigned epnum, maxp;\n\tint is_input;\n\tlong bandwidth;\n\tunsigned multi;\n\tstruct usb_host_endpoint *ep;\n\n\t \n\tepnum = usb_pipeendpoint(pipe);\n\tis_input = usb_pipein(pipe) ? USB_DIR_IN : 0;\n\tep = usb_pipe_endpoint(dev, pipe);\n\tmaxp = usb_endpoint_maxp(&ep->desc);\n\tif (is_input)\n\t\tbuf1 = (1 << 11);\n\telse\n\t\tbuf1 = 0;\n\n\tmulti = usb_endpoint_maxp_mult(&ep->desc);\n\tbuf1 |= maxp;\n\tmaxp *= multi;\n\n\tstream->buf0 = cpu_to_hc32(fotg210, (epnum << 8) | dev->devnum);\n\tstream->buf1 = cpu_to_hc32(fotg210, buf1);\n\tstream->buf2 = cpu_to_hc32(fotg210, multi);\n\n\t \n\tif (dev->speed == USB_SPEED_FULL) {\n\t\tinterval <<= 3;\n\t\tstream->usecs = NS_TO_US(usb_calc_bus_time(dev->speed,\n\t\t\t\tis_input, 1, maxp));\n\t\tstream->usecs /= 8;\n\t} else {\n\t\tstream->highspeed = 1;\n\t\tstream->usecs = HS_USECS_ISO(maxp);\n\t}\n\tbandwidth = stream->usecs * 8;\n\tbandwidth /= interval;\n\n\tstream->bandwidth = bandwidth;\n\tstream->udev = dev;\n\tstream->bEndpointAddress = is_input | epnum;\n\tstream->interval = interval;\n\tstream->maxp = maxp;\n}\n\nstatic struct fotg210_iso_stream *iso_stream_find(struct fotg210_hcd *fotg210,\n\t\tstruct urb *urb)\n{\n\tunsigned epnum;\n\tstruct fotg210_iso_stream *stream;\n\tstruct usb_host_endpoint *ep;\n\tunsigned long flags;\n\n\tepnum = usb_pipeendpoint(urb->pipe);\n\tif (usb_pipein(urb->pipe))\n\t\tep = urb->dev->ep_in[epnum];\n\telse\n\t\tep = urb->dev->ep_out[epnum];\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tstream = ep->hcpriv;\n\n\tif (unlikely(stream == NULL)) {\n\t\tstream = iso_stream_alloc(GFP_ATOMIC);\n\t\tif (likely(stream != NULL)) {\n\t\t\tep->hcpriv = stream;\n\t\t\tstream->ep = ep;\n\t\t\tiso_stream_init(fotg210, stream, urb->dev, urb->pipe,\n\t\t\t\t\turb->interval);\n\t\t}\n\n\t \n\t} else if (unlikely(stream->hw != NULL)) {\n\t\tfotg210_dbg(fotg210, \"dev %s ep%d%s, not iso??\\n\",\n\t\t\t\turb->dev->devpath, epnum,\n\t\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\");\n\t\tstream = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn stream;\n}\n\n \n\nstatic struct fotg210_iso_sched *iso_sched_alloc(unsigned packets,\n\t\tgfp_t mem_flags)\n{\n\tstruct fotg210_iso_sched *iso_sched;\n\n\tiso_sched = kzalloc(struct_size(iso_sched, packet, packets), mem_flags);\n\tif (likely(iso_sched != NULL))\n\t\tINIT_LIST_HEAD(&iso_sched->td_list);\n\n\treturn iso_sched;\n}\n\nstatic inline void itd_sched_init(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_iso_sched *iso_sched,\n\t\tstruct fotg210_iso_stream *stream, struct urb *urb)\n{\n\tunsigned i;\n\tdma_addr_t dma = urb->transfer_dma;\n\n\t \n\tiso_sched->span = urb->number_of_packets * stream->interval;\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tstruct fotg210_iso_packet *uframe = &iso_sched->packet[i];\n\t\tunsigned length;\n\t\tdma_addr_t buf;\n\t\tu32 trans;\n\n\t\tlength = urb->iso_frame_desc[i].length;\n\t\tbuf = dma + urb->iso_frame_desc[i].offset;\n\n\t\ttrans = FOTG210_ISOC_ACTIVE;\n\t\ttrans |= buf & 0x0fff;\n\t\tif (unlikely(((i + 1) == urb->number_of_packets))\n\t\t\t\t&& !(urb->transfer_flags & URB_NO_INTERRUPT))\n\t\t\ttrans |= FOTG210_ITD_IOC;\n\t\ttrans |= length << 16;\n\t\tuframe->transaction = cpu_to_hc32(fotg210, trans);\n\n\t\t \n\t\tuframe->bufp = (buf & ~(u64)0x0fff);\n\t\tbuf += length;\n\t\tif (unlikely((uframe->bufp != (buf & ~(u64)0x0fff))))\n\t\t\tuframe->cross = 1;\n\t}\n}\n\nstatic void iso_sched_free(struct fotg210_iso_stream *stream,\n\t\tstruct fotg210_iso_sched *iso_sched)\n{\n\tif (!iso_sched)\n\t\treturn;\n\t \n\tlist_splice(&iso_sched->td_list, &stream->free_list);\n\tkfree(iso_sched);\n}\n\nstatic int itd_urb_transaction(struct fotg210_iso_stream *stream,\n\t\tstruct fotg210_hcd *fotg210, struct urb *urb, gfp_t mem_flags)\n{\n\tstruct fotg210_itd *itd;\n\tdma_addr_t itd_dma;\n\tint i;\n\tunsigned num_itds;\n\tstruct fotg210_iso_sched *sched;\n\tunsigned long flags;\n\n\tsched = iso_sched_alloc(urb->number_of_packets, mem_flags);\n\tif (unlikely(sched == NULL))\n\t\treturn -ENOMEM;\n\n\titd_sched_init(fotg210, sched, stream, urb);\n\n\tif (urb->interval < 8)\n\t\tnum_itds = 1 + (sched->span + 7) / 8;\n\telse\n\t\tnum_itds = urb->number_of_packets;\n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tfor (i = 0; i < num_itds; i++) {\n\n\t\t \n\t\tif (likely(!list_empty(&stream->free_list))) {\n\t\t\titd = list_first_entry(&stream->free_list,\n\t\t\t\t\tstruct fotg210_itd, itd_list);\n\t\t\tif (itd->frame == fotg210->now_frame)\n\t\t\t\tgoto alloc_itd;\n\t\t\tlist_del(&itd->itd_list);\n\t\t\titd_dma = itd->itd_dma;\n\t\t} else {\nalloc_itd:\n\t\t\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\t\t\titd = dma_pool_alloc(fotg210->itd_pool, mem_flags,\n\t\t\t\t\t&itd_dma);\n\t\t\tspin_lock_irqsave(&fotg210->lock, flags);\n\t\t\tif (!itd) {\n\t\t\t\tiso_sched_free(stream, sched);\n\t\t\t\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tmemset(itd, 0, sizeof(*itd));\n\t\titd->itd_dma = itd_dma;\n\t\tlist_add(&itd->itd_list, &sched->td_list);\n\t}\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\n\t \n\turb->hcpriv = sched;\n\turb->error_count = 0;\n\treturn 0;\n}\n\nstatic inline int itd_slot_ok(struct fotg210_hcd *fotg210, u32 mod, u32 uframe,\n\t\tu8 usecs, u32 period)\n{\n\tuframe %= period;\n\tdo {\n\t\t \n\t\tif (periodic_usecs(fotg210, uframe >> 3, uframe & 0x7)\n\t\t\t\t> (fotg210->uframe_periodic_max - usecs))\n\t\t\treturn 0;\n\n\t\t \n\t\tuframe += period;\n\t} while (uframe < mod);\n\treturn 1;\n}\n\n \n\n#define SCHEDULE_SLOP 80  \n\nstatic int iso_stream_schedule(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tstruct fotg210_iso_stream *stream)\n{\n\tu32 now, next, start, period, span;\n\tint status;\n\tunsigned mod = fotg210->periodic_size << 3;\n\tstruct fotg210_iso_sched *sched = urb->hcpriv;\n\n\tperiod = urb->interval;\n\tspan = sched->span;\n\n\tif (span > mod - SCHEDULE_SLOP) {\n\t\tfotg210_dbg(fotg210, \"iso request %p too long\\n\", urb);\n\t\tstatus = -EFBIG;\n\t\tgoto fail;\n\t}\n\n\tnow = fotg210_read_frame_index(fotg210) & (mod - 1);\n\n\t \n\tif (likely(!list_empty(&stream->td_list))) {\n\t\tu32 excess;\n\n\t\t \n\t\tif (!stream->highspeed && fotg210->fs_i_thresh)\n\t\t\tnext = now + fotg210->i_thresh;\n\t\telse\n\t\t\tnext = now;\n\n\t\t \n\t\texcess = (stream->next_uframe - period - next) & (mod - 1);\n\t\tif (excess >= mod - 2 * SCHEDULE_SLOP)\n\t\t\tstart = next + excess - mod + period *\n\t\t\t\t\tDIV_ROUND_UP(mod - excess, period);\n\t\telse\n\t\t\tstart = next + excess + period;\n\t\tif (start - now >= mod) {\n\t\t\tfotg210_dbg(fotg210, \"request %p would overflow (%d+%d >= %d)\\n\",\n\t\t\t\t\turb, start - now - period, period,\n\t\t\t\t\tmod);\n\t\t\tstatus = -EFBIG;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\telse {\n\t\tint done = 0;\n\n\t\tstart = SCHEDULE_SLOP + (now & ~0x07);\n\n\t\t \n\n\t\t \n\t\tnext = start;\n\t\tstart += period;\n\t\tdo {\n\t\t\tstart--;\n\t\t\t \n\t\t\tif (itd_slot_ok(fotg210, mod, start,\n\t\t\t\t\tstream->usecs, period))\n\t\t\t\tdone = 1;\n\t\t} while (start > next && !done);\n\n\t\t \n\t\tif (!done) {\n\t\t\tfotg210_dbg(fotg210, \"iso resched full %p (now %d max %d)\\n\",\n\t\t\t\t\turb, now, now + mod);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\tif (unlikely(start - now + span - period >=\n\t\t\tmod - 2 * SCHEDULE_SLOP)) {\n\t\tfotg210_dbg(fotg210, \"request %p would overflow (%d+%d >= %d)\\n\",\n\t\t\t\turb, start - now, span - period,\n\t\t\t\tmod - 2 * SCHEDULE_SLOP);\n\t\tstatus = -EFBIG;\n\t\tgoto fail;\n\t}\n\n\tstream->next_uframe = start & (mod - 1);\n\n\t \n\turb->start_frame = stream->next_uframe;\n\tif (!stream->highspeed)\n\t\turb->start_frame >>= 3;\n\n\t \n\tif (fotg210->isoc_count == 0)\n\t\tfotg210->next_frame = now >> 3;\n\treturn 0;\n\nfail:\n\tiso_sched_free(stream, sched);\n\turb->hcpriv = NULL;\n\treturn status;\n}\n\nstatic inline void itd_init(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_iso_stream *stream, struct fotg210_itd *itd)\n{\n\tint i;\n\n\t \n\titd->hw_next = FOTG210_LIST_END(fotg210);\n\titd->hw_bufp[0] = stream->buf0;\n\titd->hw_bufp[1] = stream->buf1;\n\titd->hw_bufp[2] = stream->buf2;\n\n\tfor (i = 0; i < 8; i++)\n\t\titd->index[i] = -1;\n\n\t \n}\n\nstatic inline void itd_patch(struct fotg210_hcd *fotg210,\n\t\tstruct fotg210_itd *itd, struct fotg210_iso_sched *iso_sched,\n\t\tunsigned index, u16 uframe)\n{\n\tstruct fotg210_iso_packet *uf = &iso_sched->packet[index];\n\tunsigned pg = itd->pg;\n\n\tuframe &= 0x07;\n\titd->index[uframe] = index;\n\n\titd->hw_transaction[uframe] = uf->transaction;\n\titd->hw_transaction[uframe] |= cpu_to_hc32(fotg210, pg << 12);\n\titd->hw_bufp[pg] |= cpu_to_hc32(fotg210, uf->bufp & ~(u32)0);\n\titd->hw_bufp_hi[pg] |= cpu_to_hc32(fotg210, (u32)(uf->bufp >> 32));\n\n\t \n\tif (unlikely(uf->cross)) {\n\t\tu64 bufp = uf->bufp + 4096;\n\n\t\titd->pg = ++pg;\n\t\titd->hw_bufp[pg] |= cpu_to_hc32(fotg210, bufp & ~(u32)0);\n\t\titd->hw_bufp_hi[pg] |= cpu_to_hc32(fotg210, (u32)(bufp >> 32));\n\t}\n}\n\nstatic inline void itd_link(struct fotg210_hcd *fotg210, unsigned frame,\n\t\tstruct fotg210_itd *itd)\n{\n\tunion fotg210_shadow *prev = &fotg210->pshadow[frame];\n\t__hc32 *hw_p = &fotg210->periodic[frame];\n\tunion fotg210_shadow here = *prev;\n\t__hc32 type = 0;\n\n\t \n\twhile (here.ptr) {\n\t\ttype = Q_NEXT_TYPE(fotg210, *hw_p);\n\t\tif (type == cpu_to_hc32(fotg210, Q_TYPE_QH))\n\t\t\tbreak;\n\t\tprev = periodic_next_shadow(fotg210, prev, type);\n\t\thw_p = shadow_next_periodic(fotg210, &here, type);\n\t\there = *prev;\n\t}\n\n\titd->itd_next = here;\n\titd->hw_next = *hw_p;\n\tprev->itd = itd;\n\titd->frame = frame;\n\twmb();\n\t*hw_p = cpu_to_hc32(fotg210, itd->itd_dma | Q_TYPE_ITD);\n}\n\n \nstatic void itd_link_urb(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tunsigned mod, struct fotg210_iso_stream *stream)\n{\n\tint packet;\n\tunsigned next_uframe, uframe, frame;\n\tstruct fotg210_iso_sched *iso_sched = urb->hcpriv;\n\tstruct fotg210_itd *itd;\n\n\tnext_uframe = stream->next_uframe & (mod - 1);\n\n\tif (unlikely(list_empty(&stream->td_list))) {\n\t\tfotg210_to_hcd(fotg210)->self.bandwidth_allocated\n\t\t\t\t+= stream->bandwidth;\n\t\tfotg210_dbg(fotg210,\n\t\t\t\"schedule devp %s ep%d%s-iso period %d start %d.%d\\n\",\n\t\t\turb->dev->devpath, stream->bEndpointAddress & 0x0f,\n\t\t\t(stream->bEndpointAddress & USB_DIR_IN) ? \"in\" : \"out\",\n\t\t\turb->interval,\n\t\t\tnext_uframe >> 3, next_uframe & 0x7);\n\t}\n\n\t \n\tfor (packet = 0, itd = NULL; packet < urb->number_of_packets;) {\n\t\tif (itd == NULL) {\n\t\t\t \n\n\t\t\t \n\n\t\t\titd = list_entry(iso_sched->td_list.next,\n\t\t\t\t\tstruct fotg210_itd, itd_list);\n\t\t\tlist_move_tail(&itd->itd_list, &stream->td_list);\n\t\t\titd->stream = stream;\n\t\t\titd->urb = urb;\n\t\t\titd_init(fotg210, stream, itd);\n\t\t}\n\n\t\tuframe = next_uframe & 0x07;\n\t\tframe = next_uframe >> 3;\n\n\t\titd_patch(fotg210, itd, iso_sched, packet, uframe);\n\n\t\tnext_uframe += stream->interval;\n\t\tnext_uframe &= mod - 1;\n\t\tpacket++;\n\n\t\t \n\t\tif (((next_uframe >> 3) != frame)\n\t\t\t\t|| packet == urb->number_of_packets) {\n\t\t\titd_link(fotg210, frame & (fotg210->periodic_size - 1),\n\t\t\t\t\titd);\n\t\t\titd = NULL;\n\t\t}\n\t}\n\tstream->next_uframe = next_uframe;\n\n\t \n\tiso_sched_free(stream, iso_sched);\n\turb->hcpriv = NULL;\n\n\t++fotg210->isoc_count;\n\tenable_periodic(fotg210);\n}\n\n#define ISO_ERRS (FOTG210_ISOC_BUF_ERR | FOTG210_ISOC_BABBLE |\\\n\t\tFOTG210_ISOC_XACTERR)\n\n \nstatic bool itd_complete(struct fotg210_hcd *fotg210, struct fotg210_itd *itd)\n{\n\tstruct urb *urb = itd->urb;\n\tstruct usb_iso_packet_descriptor *desc;\n\tu32 t;\n\tunsigned uframe;\n\tint urb_index = -1;\n\tstruct fotg210_iso_stream *stream = itd->stream;\n\tstruct usb_device *dev;\n\tbool retval = false;\n\n\t \n\tfor (uframe = 0; uframe < 8; uframe++) {\n\t\tif (likely(itd->index[uframe] == -1))\n\t\t\tcontinue;\n\t\turb_index = itd->index[uframe];\n\t\tdesc = &urb->iso_frame_desc[urb_index];\n\n\t\tt = hc32_to_cpup(fotg210, &itd->hw_transaction[uframe]);\n\t\titd->hw_transaction[uframe] = 0;\n\n\t\t \n\t\tif (unlikely(t & ISO_ERRS)) {\n\t\t\turb->error_count++;\n\t\t\tif (t & FOTG210_ISOC_BUF_ERR)\n\t\t\t\tdesc->status = usb_pipein(urb->pipe)\n\t\t\t\t\t? -ENOSR   \n\t\t\t\t\t: -ECOMM;  \n\t\t\telse if (t & FOTG210_ISOC_BABBLE)\n\t\t\t\tdesc->status = -EOVERFLOW;\n\t\t\telse  \n\t\t\t\tdesc->status = -EPROTO;\n\n\t\t\t \n\t\t\tif (!(t & FOTG210_ISOC_BABBLE)) {\n\t\t\t\tdesc->actual_length = FOTG210_ITD_LENGTH(t);\n\t\t\t\turb->actual_length += desc->actual_length;\n\t\t\t}\n\t\t} else if (likely((t & FOTG210_ISOC_ACTIVE) == 0)) {\n\t\t\tdesc->status = 0;\n\t\t\tdesc->actual_length = FOTG210_ITD_LENGTH(t);\n\t\t\turb->actual_length += desc->actual_length;\n\t\t} else {\n\t\t\t \n\t\t\tdesc->status = -EXDEV;\n\t\t}\n\t}\n\n\t \n\tif (likely((urb_index + 1) != urb->number_of_packets))\n\t\tgoto done;\n\n\t \n\n\t \n\tdev = urb->dev;\n\tfotg210_urb_done(fotg210, urb, 0);\n\tretval = true;\n\turb = NULL;\n\n\t--fotg210->isoc_count;\n\tdisable_periodic(fotg210);\n\n\tif (unlikely(list_is_singular(&stream->td_list))) {\n\t\tfotg210_to_hcd(fotg210)->self.bandwidth_allocated\n\t\t\t\t-= stream->bandwidth;\n\t\tfotg210_dbg(fotg210,\n\t\t\t\"deschedule devp %s ep%d%s-iso\\n\",\n\t\t\tdev->devpath, stream->bEndpointAddress & 0x0f,\n\t\t\t(stream->bEndpointAddress & USB_DIR_IN) ? \"in\" : \"out\");\n\t}\n\ndone:\n\titd->urb = NULL;\n\n\t \n\tlist_move_tail(&itd->itd_list, &stream->free_list);\n\n\t \n\tif (list_empty(&stream->td_list)) {\n\t\tlist_splice_tail_init(&stream->free_list,\n\t\t\t\t&fotg210->cached_itd_list);\n\t\tstart_free_itds(fotg210);\n\t}\n\n\treturn retval;\n}\n\nstatic int itd_submit(struct fotg210_hcd *fotg210, struct urb *urb,\n\t\tgfp_t mem_flags)\n{\n\tint status = -EINVAL;\n\tunsigned long flags;\n\tstruct fotg210_iso_stream *stream;\n\n\t \n\tstream = iso_stream_find(fotg210, urb);\n\tif (unlikely(stream == NULL)) {\n\t\tfotg210_dbg(fotg210, \"can't get iso stream\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(urb->interval != stream->interval &&\n\t\t\tfotg210_port_speed(fotg210, 0) ==\n\t\t\tUSB_PORT_STAT_HIGH_SPEED)) {\n\t\tfotg210_dbg(fotg210, \"can't change iso interval %d --> %d\\n\",\n\t\t\t\tstream->interval, urb->interval);\n\t\tgoto done;\n\t}\n\n#ifdef FOTG210_URB_TRACE\n\tfotg210_dbg(fotg210,\n\t\t\t\"%s %s urb %p ep%d%s len %d, %d pkts %d uframes[%p]\\n\",\n\t\t\t__func__, urb->dev->devpath, urb,\n\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\turb->transfer_buffer_length,\n\t\t\turb->number_of_packets, urb->interval,\n\t\t\tstream);\n#endif\n\n\t \n\tstatus = itd_urb_transaction(stream, fotg210, urb, mem_flags);\n\tif (unlikely(status < 0)) {\n\t\tfotg210_dbg(fotg210, \"can't init itds\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(fotg210_to_hcd(fotg210)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done_not_linked;\n\t}\n\tstatus = usb_hcd_link_urb_to_ep(fotg210_to_hcd(fotg210), urb);\n\tif (unlikely(status))\n\t\tgoto done_not_linked;\n\tstatus = iso_stream_schedule(fotg210, urb, stream);\n\tif (likely(status == 0))\n\t\titd_link_urb(fotg210, urb, fotg210->periodic_size << 3, stream);\n\telse\n\t\tusb_hcd_unlink_urb_from_ep(fotg210_to_hcd(fotg210), urb);\ndone_not_linked:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\ndone:\n\treturn status;\n}\n\nstatic inline int scan_frame_queue(struct fotg210_hcd *fotg210, unsigned frame,\n\t\tunsigned now_frame, bool live)\n{\n\tunsigned uf;\n\tbool modified;\n\tunion fotg210_shadow q, *q_p;\n\t__hc32 type, *hw_p;\n\n\t \n\tq_p = &fotg210->pshadow[frame];\n\thw_p = &fotg210->periodic[frame];\n\tq.ptr = q_p->ptr;\n\ttype = Q_NEXT_TYPE(fotg210, *hw_p);\n\tmodified = false;\n\n\twhile (q.ptr) {\n\t\tswitch (hc32_to_cpu(fotg210, type)) {\n\t\tcase Q_TYPE_ITD:\n\t\t\t \n\t\t\tif (frame == now_frame && live) {\n\t\t\t\trmb();\n\t\t\t\tfor (uf = 0; uf < 8; uf++) {\n\t\t\t\t\tif (q.itd->hw_transaction[uf] &\n\t\t\t\t\t\t\tITD_ACTIVE(fotg210))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (uf < 8) {\n\t\t\t\t\tq_p = &q.itd->itd_next;\n\t\t\t\t\thw_p = &q.itd->hw_next;\n\t\t\t\t\ttype = Q_NEXT_TYPE(fotg210,\n\t\t\t\t\t\t\tq.itd->hw_next);\n\t\t\t\t\tq = *q_p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\t*q_p = q.itd->itd_next;\n\t\t\t*hw_p = q.itd->hw_next;\n\t\t\ttype = Q_NEXT_TYPE(fotg210, q.itd->hw_next);\n\t\t\twmb();\n\t\t\tmodified = itd_complete(fotg210, q.itd);\n\t\t\tq = *q_p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfotg210_dbg(fotg210, \"corrupt type %d frame %d shadow %p\\n\",\n\t\t\t\t\ttype, frame, q.ptr);\n\t\t\tfallthrough;\n\t\tcase Q_TYPE_QH:\n\t\tcase Q_TYPE_FSTN:\n\t\t\t \n\t\t\tq.ptr = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (unlikely(modified && fotg210->isoc_count > 0))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void scan_isoc(struct fotg210_hcd *fotg210)\n{\n\tunsigned uf, now_frame, frame, ret;\n\tunsigned fmask = fotg210->periodic_size - 1;\n\tbool live;\n\n\t \n\tif (fotg210->rh_state >= FOTG210_RH_RUNNING) {\n\t\tuf = fotg210_read_frame_index(fotg210);\n\t\tnow_frame = (uf >> 3) & fmask;\n\t\tlive = true;\n\t} else  {\n\t\tnow_frame = (fotg210->next_frame - 1) & fmask;\n\t\tlive = false;\n\t}\n\tfotg210->now_frame = now_frame;\n\n\tframe = fotg210->next_frame;\n\tfor (;;) {\n\t\tret = 1;\n\t\twhile (ret != 0)\n\t\t\tret = scan_frame_queue(fotg210, frame,\n\t\t\t\t\tnow_frame, live);\n\n\t\t \n\t\tif (frame == now_frame)\n\t\t\tbreak;\n\t\tframe = (frame + 1) & fmask;\n\t}\n\tfotg210->next_frame = now_frame;\n}\n\n \nstatic ssize_t uframe_periodic_max_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct fotg210_hcd *fotg210;\n\n\tfotg210 = hcd_to_fotg210(bus_to_hcd(dev_get_drvdata(dev)));\n\treturn sysfs_emit(buf, \"%d\\n\", fotg210->uframe_periodic_max);\n}\n\nstatic ssize_t uframe_periodic_max_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct fotg210_hcd *fotg210;\n\tunsigned uframe_periodic_max;\n\tunsigned frame, uframe;\n\tunsigned short allocated_max;\n\tunsigned long flags;\n\tssize_t ret;\n\n\tfotg210 = hcd_to_fotg210(bus_to_hcd(dev_get_drvdata(dev)));\n\n\tret = kstrtouint(buf, 0, &uframe_periodic_max);\n\tif (ret)\n\t\treturn ret;\n\n\tif (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {\n\t\tfotg210_info(fotg210, \"rejecting invalid request for uframe_periodic_max=%u\\n\",\n\t\t\t\tuframe_periodic_max);\n\t\treturn -EINVAL;\n\t}\n\n\tret = -EINVAL;\n\n\t \n\tspin_lock_irqsave(&fotg210->lock, flags);\n\n\t \n\tif (uframe_periodic_max < fotg210->uframe_periodic_max) {\n\t\tallocated_max = 0;\n\n\t\tfor (frame = 0; frame < fotg210->periodic_size; ++frame)\n\t\t\tfor (uframe = 0; uframe < 7; ++uframe)\n\t\t\t\tallocated_max = max(allocated_max,\n\t\t\t\t\t\tperiodic_usecs(fotg210, frame,\n\t\t\t\t\t\tuframe));\n\n\t\tif (allocated_max > uframe_periodic_max) {\n\t\t\tfotg210_info(fotg210,\n\t\t\t\t\t\"cannot decrease uframe_periodic_max because periodic bandwidth is already allocated (%u > %u)\\n\",\n\t\t\t\t\tallocated_max, uframe_periodic_max);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\n\tfotg210_info(fotg210,\n\t\t\t\"setting max periodic bandwidth to %u%% (== %u usec/uframe)\\n\",\n\t\t\t100 * uframe_periodic_max/125, uframe_periodic_max);\n\n\tif (uframe_periodic_max != 100)\n\t\tfotg210_warn(fotg210, \"max periodic bandwidth set is non-standard\\n\");\n\n\tfotg210->uframe_periodic_max = uframe_periodic_max;\n\tret = count;\n\nout_unlock:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RW(uframe_periodic_max);\n\nstatic inline int create_sysfs_files(struct fotg210_hcd *fotg210)\n{\n\tstruct device *controller = fotg210_to_hcd(fotg210)->self.controller;\n\n\treturn device_create_file(controller, &dev_attr_uframe_periodic_max);\n}\n\nstatic inline void remove_sysfs_files(struct fotg210_hcd *fotg210)\n{\n\tstruct device *controller = fotg210_to_hcd(fotg210)->self.controller;\n\n\tdevice_remove_file(controller, &dev_attr_uframe_periodic_max);\n}\n \nstatic void fotg210_turn_off_all_ports(struct fotg210_hcd *fotg210)\n{\n\tu32 __iomem *status_reg = &fotg210->regs->port_status;\n\n\tfotg210_writel(fotg210, PORT_RWC_BITS, status_reg);\n}\n\n \nstatic void fotg210_silence_controller(struct fotg210_hcd *fotg210)\n{\n\tfotg210_halt(fotg210);\n\n\tspin_lock_irq(&fotg210->lock);\n\tfotg210->rh_state = FOTG210_RH_HALTED;\n\tfotg210_turn_off_all_ports(fotg210);\n\tspin_unlock_irq(&fotg210->lock);\n}\n\n \nstatic void fotg210_shutdown(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\n\tspin_lock_irq(&fotg210->lock);\n\tfotg210->shutdown = true;\n\tfotg210->rh_state = FOTG210_RH_STOPPING;\n\tfotg210->enabled_hrtimer_events = 0;\n\tspin_unlock_irq(&fotg210->lock);\n\n\tfotg210_silence_controller(fotg210);\n\n\thrtimer_cancel(&fotg210->hrtimer);\n}\n\n \nstatic void fotg210_work(struct fotg210_hcd *fotg210)\n{\n\t \n\tif (fotg210->scanning) {\n\t\tfotg210->need_rescan = true;\n\t\treturn;\n\t}\n\tfotg210->scanning = true;\n\nrescan:\n\tfotg210->need_rescan = false;\n\tif (fotg210->async_count)\n\t\tscan_async(fotg210);\n\tif (fotg210->intr_count > 0)\n\t\tscan_intr(fotg210);\n\tif (fotg210->isoc_count > 0)\n\t\tscan_isoc(fotg210);\n\tif (fotg210->need_rescan)\n\t\tgoto rescan;\n\tfotg210->scanning = false;\n\n\t \n\tturn_on_io_watchdog(fotg210);\n}\n\n \nstatic void fotg210_stop(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\n\tfotg210_dbg(fotg210, \"stop\\n\");\n\n\t \n\n\tspin_lock_irq(&fotg210->lock);\n\tfotg210->enabled_hrtimer_events = 0;\n\tspin_unlock_irq(&fotg210->lock);\n\n\tfotg210_quiesce(fotg210);\n\tfotg210_silence_controller(fotg210);\n\tfotg210_reset(fotg210);\n\n\thrtimer_cancel(&fotg210->hrtimer);\n\tremove_sysfs_files(fotg210);\n\tremove_debug_files(fotg210);\n\n\t \n\tspin_lock_irq(&fotg210->lock);\n\tend_free_itds(fotg210);\n\tspin_unlock_irq(&fotg210->lock);\n\tfotg210_mem_cleanup(fotg210);\n\n#ifdef FOTG210_STATS\n\tfotg210_dbg(fotg210, \"irq normal %ld err %ld iaa %ld (lost %ld)\\n\",\n\t\t\tfotg210->stats.normal, fotg210->stats.error,\n\t\t\tfotg210->stats.iaa, fotg210->stats.lost_iaa);\n\tfotg210_dbg(fotg210, \"complete %ld unlink %ld\\n\",\n\t\t\tfotg210->stats.complete, fotg210->stats.unlink);\n#endif\n\n\tdbg_status(fotg210, \"fotg210_stop completed\",\n\t\t\tfotg210_readl(fotg210, &fotg210->regs->status));\n}\n\n \nstatic int hcd_fotg210_init(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tu32 temp;\n\tint retval;\n\tu32 hcc_params;\n\tstruct fotg210_qh_hw *hw;\n\n\tspin_lock_init(&fotg210->lock);\n\n\t \n\tfotg210->need_io_watchdog = 1;\n\n\thrtimer_init(&fotg210->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tfotg210->hrtimer.function = fotg210_hrtimer_func;\n\tfotg210->next_hrtimer_event = FOTG210_HRTIMER_NO_EVENT;\n\n\thcc_params = fotg210_readl(fotg210, &fotg210->caps->hcc_params);\n\n\t \n\tfotg210->uframe_periodic_max = 100;\n\n\t \n\tfotg210->periodic_size = DEFAULT_I_TDPS;\n\tINIT_LIST_HEAD(&fotg210->intr_qh_list);\n\tINIT_LIST_HEAD(&fotg210->cached_itd_list);\n\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t \n\t\tswitch (FOTG210_TUNE_FLS) {\n\t\tcase 0:\n\t\t\tfotg210->periodic_size = 1024;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfotg210->periodic_size = 512;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tfotg210->periodic_size = 256;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\tretval = fotg210_mem_init(fotg210, GFP_KERNEL);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\tfotg210->i_thresh = 2;\n\n\t \n\tfotg210->async->qh_next.qh = NULL;\n\thw = fotg210->async->hw;\n\thw->hw_next = QH_NEXT(fotg210, fotg210->async->qh_dma);\n\thw->hw_info1 = cpu_to_hc32(fotg210, QH_HEAD);\n\thw->hw_token = cpu_to_hc32(fotg210, QTD_STS_HALT);\n\thw->hw_qtd_next = FOTG210_LIST_END(fotg210);\n\tfotg210->async->qh_state = QH_STATE_LINKED;\n\thw->hw_alt_next = QTD_NEXT(fotg210, fotg210->async->dummy->qtd_dma);\n\n\t \n\tif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\n\t\tlog2_irq_thresh = 0;\n\ttemp = 1 << (16 + log2_irq_thresh);\n\tif (HCC_CANPARK(hcc_params)) {\n\t\t \n\t\tif (park) {\n\t\t\tpark = min_t(unsigned, park, 3);\n\t\t\ttemp |= CMD_PARK;\n\t\t\ttemp |= park << 8;\n\t\t}\n\t\tfotg210_dbg(fotg210, \"park %d\\n\", park);\n\t}\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t \n\t\ttemp &= ~(3 << 2);\n\t\ttemp |= (FOTG210_TUNE_FLS << 2);\n\t}\n\tfotg210->command = temp;\n\n\t \n\tif (!hcd->localmem_pool)\n\t\thcd->self.sg_tablesize = ~0;\n\treturn 0;\n}\n\n \nstatic int fotg210_run(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tu32 temp;\n\n\thcd->uses_new_polling = 1;\n\n\t \n\n\tfotg210_writel(fotg210, fotg210->periodic_dma,\n\t\t\t&fotg210->regs->frame_list);\n\tfotg210_writel(fotg210, (u32)fotg210->async->qh_dma,\n\t\t\t&fotg210->regs->async_next);\n\n\t \n\tfotg210_readl(fotg210, &fotg210->caps->hcc_params);\n\n\t \n\tfotg210->command &= ~(CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\n\tfotg210->command |= CMD_RUN;\n\tfotg210_writel(fotg210, fotg210->command, &fotg210->regs->command);\n\tdbg_cmd(fotg210, \"init\", fotg210->command);\n\n\t \n\tdown_write(&ehci_cf_port_reset_rwsem);\n\tfotg210->rh_state = FOTG210_RH_RUNNING;\n\t \n\tfotg210_readl(fotg210, &fotg210->regs->command);\n\tusleep_range(5000, 10000);\n\tup_write(&ehci_cf_port_reset_rwsem);\n\tfotg210->last_periodic_enable = ktime_get_real();\n\n\ttemp = HC_VERSION(fotg210,\n\t\t\tfotg210_readl(fotg210, &fotg210->caps->hc_capbase));\n\tfotg210_info(fotg210,\n\t\t\t\"USB %x.%x started, EHCI %x.%02x\\n\",\n\t\t\t((fotg210->sbrn & 0xf0) >> 4), (fotg210->sbrn & 0x0f),\n\t\t\ttemp >> 8, temp & 0xff);\n\n\tfotg210_writel(fotg210, INTR_MASK,\n\t\t\t&fotg210->regs->intr_enable);  \n\n\t \n\tcreate_debug_files(fotg210);\n\tcreate_sysfs_files(fotg210);\n\n\treturn 0;\n}\n\nstatic int fotg210_setup(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tint retval;\n\n\tfotg210->regs = (void __iomem *)fotg210->caps +\n\t\t\tHC_LENGTH(fotg210,\n\t\t\tfotg210_readl(fotg210, &fotg210->caps->hc_capbase));\n\tdbg_hcs_params(fotg210, \"reset\");\n\tdbg_hcc_params(fotg210, \"reset\");\n\n\t \n\tfotg210->hcs_params = fotg210_readl(fotg210,\n\t\t\t&fotg210->caps->hcs_params);\n\n\tfotg210->sbrn = HCD_USB2;\n\n\t \n\tretval = hcd_fotg210_init(hcd);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = fotg210_halt(fotg210);\n\tif (retval)\n\t\treturn retval;\n\n\tfotg210_reset(fotg210);\n\n\treturn 0;\n}\n\nstatic irqreturn_t fotg210_irq(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tu32 status, masked_status, pcd_status = 0, cmd;\n\tint bh;\n\n\tspin_lock(&fotg210->lock);\n\n\tstatus = fotg210_readl(fotg210, &fotg210->regs->status);\n\n\t \n\tif (status == ~(u32) 0) {\n\t\tfotg210_dbg(fotg210, \"device removed\\n\");\n\t\tgoto dead;\n\t}\n\n\t \n\tmasked_status = status & (INTR_MASK | STS_FLR);\n\n\t \n\tif (!masked_status ||\n\t\t\tunlikely(fotg210->rh_state == FOTG210_RH_HALTED)) {\n\t\tspin_unlock(&fotg210->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tfotg210_writel(fotg210, masked_status, &fotg210->regs->status);\n\tcmd = fotg210_readl(fotg210, &fotg210->regs->command);\n\tbh = 0;\n\n\t \n\tdbg_status(fotg210, \"irq\", status);\n\n\t \n\n\t \n\tif (likely((status & (STS_INT|STS_ERR)) != 0)) {\n\t\tif (likely((status & STS_ERR) == 0))\n\t\t\tINCR(fotg210->stats.normal);\n\t\telse\n\t\t\tINCR(fotg210->stats.error);\n\t\tbh = 1;\n\t}\n\n\t \n\tif (status & STS_IAA) {\n\n\t\t \n\t\tfotg210->enabled_hrtimer_events &=\n\t\t\t~BIT(FOTG210_HRTIMER_IAA_WATCHDOG);\n\n\t\t \n\t\tif (fotg210->next_hrtimer_event == FOTG210_HRTIMER_IAA_WATCHDOG)\n\t\t\t++fotg210->next_hrtimer_event;\n\n\t\t \n\t\tif (cmd & CMD_IAAD)\n\t\t\tfotg210_dbg(fotg210, \"IAA with IAAD still set?\\n\");\n\t\tif (fotg210->async_iaa) {\n\t\t\tINCR(fotg210->stats.iaa);\n\t\t\tend_unlink_async(fotg210);\n\t\t} else\n\t\t\tfotg210_dbg(fotg210, \"IAA with nothing unlinked?\\n\");\n\t}\n\n\t \n\tif (status & STS_PCD) {\n\t\tint pstatus;\n\t\tu32 __iomem *status_reg = &fotg210->regs->port_status;\n\n\t\t \n\t\tpcd_status = status;\n\n\t\t \n\t\tif (fotg210->rh_state == FOTG210_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\n\t\tpstatus = fotg210_readl(fotg210, status_reg);\n\n\t\tif (test_bit(0, &fotg210->suspended_ports) &&\n\t\t\t\t((pstatus & PORT_RESUME) ||\n\t\t\t\t!(pstatus & PORT_SUSPEND)) &&\n\t\t\t\t(pstatus & PORT_PE) &&\n\t\t\t\tfotg210->reset_done[0] == 0) {\n\n\t\t\t \n\t\t\tfotg210->reset_done[0] = jiffies + msecs_to_jiffies(25);\n\t\t\tset_bit(0, &fotg210->resuming_ports);\n\t\t\tfotg210_dbg(fotg210, \"port 1 remote wakeup\\n\");\n\t\t\tmod_timer(&hcd->rh_timer, fotg210->reset_done[0]);\n\t\t}\n\t}\n\n\t \n\tif (unlikely((status & STS_FATAL) != 0)) {\n\t\tfotg210_err(fotg210, \"fatal error\\n\");\n\t\tdbg_cmd(fotg210, \"fatal\", cmd);\n\t\tdbg_status(fotg210, \"fatal\", status);\ndead:\n\t\tusb_hc_died(hcd);\n\n\t\t \n\t\tfotg210->shutdown = true;\n\t\tfotg210->rh_state = FOTG210_RH_STOPPING;\n\t\tfotg210->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);\n\t\tfotg210_writel(fotg210, fotg210->command,\n\t\t\t\t&fotg210->regs->command);\n\t\tfotg210_writel(fotg210, 0, &fotg210->regs->intr_enable);\n\t\tfotg210_handle_controller_death(fotg210);\n\n\t\t \n\t\tbh = 0;\n\t}\n\n\tif (bh)\n\t\tfotg210_work(fotg210);\n\tspin_unlock(&fotg210->lock);\n\tif (pcd_status)\n\t\tusb_hcd_poll_rh_status(hcd);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int fotg210_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\tgfp_t mem_flags)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tstruct list_head qtd_list;\n\n\tINIT_LIST_HEAD(&qtd_list);\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\t \n\t\tif (urb->transfer_buffer_length > (16 * 1024))\n\t\t\treturn -EMSGSIZE;\n\t\tfallthrough;\n\t \n\tdefault:\n\t\tif (!qh_urb_transaction(fotg210, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn submit_async(fotg210, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_INTERRUPT:\n\t\tif (!qh_urb_transaction(fotg210, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn intr_submit(fotg210, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_ISOCHRONOUS:\n\t\treturn itd_submit(fotg210, urb, mem_flags);\n\t}\n}\n\n \n\nstatic int fotg210_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tstruct fotg210_qh *qh;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\t \n\t \n\tdefault:\n\t\tqh = (struct fotg210_qh *) urb->hcpriv;\n\t\tif (!qh)\n\t\t\tbreak;\n\t\tswitch (qh->qh_state) {\n\t\tcase QH_STATE_LINKED:\n\t\tcase QH_STATE_COMPLETING:\n\t\t\tstart_unlink_async(fotg210, qh);\n\t\t\tbreak;\n\t\tcase QH_STATE_UNLINK:\n\t\tcase QH_STATE_UNLINK_WAIT:\n\t\t\t \n\t\t\tbreak;\n\t\tcase QH_STATE_IDLE:\n\t\t\t \n\t\t\tqh_completions(fotg210, qh);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PIPE_INTERRUPT:\n\t\tqh = (struct fotg210_qh *) urb->hcpriv;\n\t\tif (!qh)\n\t\t\tbreak;\n\t\tswitch (qh->qh_state) {\n\t\tcase QH_STATE_LINKED:\n\t\tcase QH_STATE_COMPLETING:\n\t\t\tstart_unlink_intr(fotg210, qh);\n\t\t\tbreak;\n\t\tcase QH_STATE_IDLE:\n\t\t\tqh_completions(fotg210, qh);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfotg210_dbg(fotg210, \"bogus qh %p state %d\\n\",\n\t\t\t\t\tqh, qh->qh_state);\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\n\tcase PIPE_ISOCHRONOUS:\n\t\t \n\n\t\t \n\t\t \n\t\tbreak;\n\t}\ndone:\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\treturn rc;\n}\n\n \n\nstatic void fotg210_endpoint_disable(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tunsigned long flags;\n\tstruct fotg210_qh *qh, *tmp;\n\n\t \n\t \n\nrescan:\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\tgoto done;\n\n\t \n\tif (qh->hw == NULL) {\n\t\tstruct fotg210_iso_stream *stream = ep->hcpriv;\n\n\t\tif (!list_empty(&stream->td_list))\n\t\t\tgoto idle_timeout;\n\n\t\t \n\t\tkfree(stream);\n\t\tgoto done;\n\t}\n\n\tif (fotg210->rh_state < FOTG210_RH_RUNNING)\n\t\tqh->qh_state = QH_STATE_IDLE;\n\tswitch (qh->qh_state) {\n\tcase QH_STATE_LINKED:\n\tcase QH_STATE_COMPLETING:\n\t\tfor (tmp = fotg210->async->qh_next.qh;\n\t\t\t\ttmp && tmp != qh;\n\t\t\t\ttmp = tmp->qh_next.qh)\n\t\t\tcontinue;\n\t\t \n\t\tif (tmp)\n\t\t\tstart_unlink_async(fotg210, qh);\n\t\tfallthrough;\n\tcase QH_STATE_UNLINK:\t\t \n\tcase QH_STATE_UNLINK_WAIT:\nidle_timeout:\n\t\tspin_unlock_irqrestore(&fotg210->lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tgoto rescan;\n\tcase QH_STATE_IDLE:\t\t \n\t\tif (qh->clearing_tt)\n\t\t\tgoto idle_timeout;\n\t\tif (list_empty(&qh->qtd_list)) {\n\t\t\tqh_destroy(fotg210, qh);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tfotg210_err(fotg210, \"qh %p (#%02x) state %d%s\\n\",\n\t\t\t\tqh, ep->desc.bEndpointAddress, qh->qh_state,\n\t\t\t\tlist_empty(&qh->qtd_list) ? \"\" : \"(has tds)\");\n\t\tbreak;\n\t}\ndone:\n\tep->hcpriv = NULL;\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n}\n\nstatic void fotg210_endpoint_reset(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\tstruct fotg210_qh *qh;\n\tint eptype = usb_endpoint_type(&ep->desc);\n\tint epnum = usb_endpoint_num(&ep->desc);\n\tint is_out = usb_endpoint_dir_out(&ep->desc);\n\tunsigned long flags;\n\n\tif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\n\t\treturn;\n\n\tspin_lock_irqsave(&fotg210->lock, flags);\n\tqh = ep->hcpriv;\n\n\t \n\tif (qh) {\n\t\tusb_settoggle(qh->dev, epnum, is_out, 0);\n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tWARN_ONCE(1, \"clear_halt for a busy endpoint\\n\");\n\t\t} else if (qh->qh_state == QH_STATE_LINKED ||\n\t\t\t\tqh->qh_state == QH_STATE_COMPLETING) {\n\n\t\t\t \n\t\t\tif (eptype == USB_ENDPOINT_XFER_BULK)\n\t\t\t\tstart_unlink_async(fotg210, qh);\n\t\t\telse\n\t\t\t\tstart_unlink_intr(fotg210, qh);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&fotg210->lock, flags);\n}\n\nstatic int fotg210_get_frame(struct usb_hcd *hcd)\n{\n\tstruct fotg210_hcd *fotg210 = hcd_to_fotg210(hcd);\n\n\treturn (fotg210_read_frame_index(fotg210) >> 3) %\n\t\tfotg210->periodic_size;\n}\n\n \n\nstatic const struct hc_driver fotg210_fotg210_hc_driver = {\n\t.description\t\t= hcd_name,\n\t.product_desc\t\t= \"Faraday USB2.0 Host Controller\",\n\t.hcd_priv_size\t\t= sizeof(struct fotg210_hcd),\n\n\t \n\t.irq\t\t\t= fotg210_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_DMA | HCD_USB2,\n\n\t \n\t.reset\t\t\t= hcd_fotg210_init,\n\t.start\t\t\t= fotg210_run,\n\t.stop\t\t\t= fotg210_stop,\n\t.shutdown\t\t= fotg210_shutdown,\n\n\t \n\t.urb_enqueue\t\t= fotg210_urb_enqueue,\n\t.urb_dequeue\t\t= fotg210_urb_dequeue,\n\t.endpoint_disable\t= fotg210_endpoint_disable,\n\t.endpoint_reset\t\t= fotg210_endpoint_reset,\n\n\t \n\t.get_frame_number\t= fotg210_get_frame,\n\n\t \n\t.hub_status_data\t= fotg210_hub_status_data,\n\t.hub_control\t\t= fotg210_hub_control,\n\t.bus_suspend\t\t= fotg210_bus_suspend,\n\t.bus_resume\t\t= fotg210_bus_resume,\n\n\t.relinquish_port\t= fotg210_relinquish_port,\n\t.port_handed_over\t= fotg210_port_handed_over,\n\n\t.clear_tt_buffer_complete = fotg210_clear_tt_buffer_complete,\n};\n\nstatic void fotg210_init(struct fotg210_hcd *fotg210)\n{\n\tu32 value;\n\n\tiowrite32(GMIR_MDEV_INT | GMIR_MOTG_INT | GMIR_INT_POLARITY,\n\t\t\t&fotg210->regs->gmir);\n\n\tvalue = ioread32(&fotg210->regs->otgcsr);\n\tvalue &= ~OTGCSR_A_BUS_DROP;\n\tvalue |= OTGCSR_A_BUS_REQ;\n\tiowrite32(value, &fotg210->regs->otgcsr);\n}\n\n \nint fotg210_hcd_probe(struct platform_device *pdev, struct fotg210 *fotg)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_hcd *hcd;\n\tint irq;\n\tint retval;\n\tstruct fotg210_hcd *fotg210;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tpdev->dev.power.power_state = PMSG_ON;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = usb_create_hcd(&fotg210_fotg210_hc_driver, dev,\n\t\t\tdev_name(dev));\n\tif (!hcd) {\n\t\tretval = dev_err_probe(dev, -ENOMEM, \"failed to create hcd\\n\");\n\t\tgoto fail_create_hcd;\n\t}\n\n\thcd->has_tt = 1;\n\n\thcd->regs = fotg->base;\n\n\thcd->rsrc_start = fotg->res->start;\n\thcd->rsrc_len = resource_size(fotg->res);\n\n\tfotg210 = hcd_to_fotg210(hcd);\n\n\tfotg210->fotg = fotg;\n\tfotg210->caps = hcd->regs;\n\n\tretval = fotg210_setup(hcd);\n\tif (retval)\n\t\tgoto failed_put_hcd;\n\n\tfotg210_init(fotg210);\n\n\tretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (retval) {\n\t\tdev_err_probe(dev, retval, \"failed to add hcd\\n\");\n\t\tgoto failed_put_hcd;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\tplatform_set_drvdata(pdev, hcd);\n\n\treturn retval;\n\nfailed_put_hcd:\n\tusb_put_hcd(hcd);\nfail_create_hcd:\n\treturn dev_err_probe(dev, retval, \"init %s fail\\n\", dev_name(dev));\n}\n\n \nint fotg210_hcd_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n\n\treturn 0;\n}\n\nint __init fotg210_hcd_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tset_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\n\tif (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||\n\t\t\ttest_bit(USB_OHCI_LOADED, &usb_hcds_loaded))\n\t\tpr_warn(\"Warning! fotg210_hcd should always be loaded before uhci_hcd and ohci_hcd, not after\\n\");\n\n\tpr_debug(\"%s: block sizes: qh %zd qtd %zd itd %zd\\n\",\n\t\t\thcd_name, sizeof(struct fotg210_qh),\n\t\t\tsizeof(struct fotg210_qtd),\n\t\t\tsizeof(struct fotg210_itd));\n\n\tfotg210_debug_root = debugfs_create_dir(\"fotg210\", usb_debug_root);\n\n\treturn 0;\n}\n\nvoid __exit fotg210_hcd_cleanup(void)\n{\n\tdebugfs_remove(fotg210_debug_root);\n\tclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}