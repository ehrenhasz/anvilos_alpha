{
  "module_name": "cdc-acm.c",
  "hash_id": "33b66b6d0d6108b491b6f54a487f68026f78def80b035ca2597e0d4162e6c2b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/class/cdc-acm.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n#undef VERBOSE_DEBUG\n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/tty.h>\n#include <linux/serial.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/tty_ldisc.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/idr.h>\n#include <linux/list.h>\n\n#include \"cdc-acm.h\"\n\n\n#define DRIVER_AUTHOR \"Armin Fuerst, Pavel Machek, Johannes Erdfelt, Vojtech Pavlik, David Kubicek, Johan Hovold\"\n#define DRIVER_DESC \"USB Abstract Control Model driver for USB modems and ISDN adapters\"\n\nstatic struct usb_driver acm_driver;\nstatic struct tty_driver *acm_tty_driver;\n\nstatic DEFINE_IDR(acm_minors);\nstatic DEFINE_MUTEX(acm_minors_lock);\n\nstatic void acm_tty_set_termios(struct tty_struct *tty,\n\t\t\t\tconst struct ktermios *termios_old);\n\n \n\n \nstatic struct acm *acm_get_by_minor(unsigned int minor)\n{\n\tstruct acm *acm;\n\n\tmutex_lock(&acm_minors_lock);\n\tacm = idr_find(&acm_minors, minor);\n\tif (acm) {\n\t\tmutex_lock(&acm->mutex);\n\t\tif (acm->disconnected) {\n\t\t\tmutex_unlock(&acm->mutex);\n\t\t\tacm = NULL;\n\t\t} else {\n\t\t\ttty_port_get(&acm->port);\n\t\t\tmutex_unlock(&acm->mutex);\n\t\t}\n\t}\n\tmutex_unlock(&acm_minors_lock);\n\treturn acm;\n}\n\n \nstatic int acm_alloc_minor(struct acm *acm)\n{\n\tint minor;\n\n\tmutex_lock(&acm_minors_lock);\n\tminor = idr_alloc(&acm_minors, acm, 0, ACM_TTY_MINORS, GFP_KERNEL);\n\tmutex_unlock(&acm_minors_lock);\n\n\treturn minor;\n}\n\n \nstatic void acm_release_minor(struct acm *acm)\n{\n\tmutex_lock(&acm_minors_lock);\n\tidr_remove(&acm_minors, acm->minor);\n\tmutex_unlock(&acm_minors_lock);\n}\n\n \n\nstatic int acm_ctrl_msg(struct acm *acm, int request, int value,\n\t\t\t\t\t\t\tvoid *buf, int len)\n{\n\tint retval;\n\n\tretval = usb_autopm_get_interface(acm->control);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = usb_control_msg(acm->dev, usb_sndctrlpipe(acm->dev, 0),\n\t\trequest, USB_RT_ACM, value,\n\t\tacm->control->altsetting[0].desc.bInterfaceNumber,\n\t\tbuf, len, USB_CTRL_SET_TIMEOUT);\n\n\tdev_dbg(&acm->control->dev,\n\t\t\"%s - rq 0x%02x, val %#x, len %#x, result %d\\n\",\n\t\t__func__, request, value, len, retval);\n\n\tusb_autopm_put_interface(acm->control);\n\n\treturn retval < 0 ? retval : 0;\n}\n\n \nstatic inline int acm_set_control(struct acm *acm, int control)\n{\n\tif (acm->quirks & QUIRK_CONTROL_LINE_STATE)\n\t\treturn -EOPNOTSUPP;\n\n\treturn acm_ctrl_msg(acm, USB_CDC_REQ_SET_CONTROL_LINE_STATE,\n\t\t\tcontrol, NULL, 0);\n}\n\n#define acm_set_line(acm, line) \\\n\tacm_ctrl_msg(acm, USB_CDC_REQ_SET_LINE_CODING, 0, line, sizeof *(line))\n#define acm_send_break(acm, ms) \\\n\tacm_ctrl_msg(acm, USB_CDC_REQ_SEND_BREAK, ms, NULL, 0)\n\nstatic void acm_poison_urbs(struct acm *acm)\n{\n\tint i;\n\n\tusb_poison_urb(acm->ctrlurb);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_poison_urb(acm->wb[i].urb);\n\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\tusb_poison_urb(acm->read_urbs[i]);\n}\n\nstatic void acm_unpoison_urbs(struct acm *acm)\n{\n\tint i;\n\n\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\tusb_unpoison_urb(acm->read_urbs[i]);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_unpoison_urb(acm->wb[i].urb);\n\tusb_unpoison_urb(acm->ctrlurb);\n}\n\n\n \n\nstatic int acm_wb_alloc(struct acm *acm)\n{\n\tint i, wbn;\n\tstruct acm_wb *wb;\n\n\twbn = 0;\n\ti = 0;\n\tfor (;;) {\n\t\twb = &acm->wb[wbn];\n\t\tif (!wb->use) {\n\t\t\twb->use = true;\n\t\t\twb->len = 0;\n\t\t\treturn wbn;\n\t\t}\n\t\twbn = (wbn + 1) % ACM_NW;\n\t\tif (++i >= ACM_NW)\n\t\t\treturn -1;\n\t}\n}\n\nstatic int acm_wb_is_avail(struct acm *acm)\n{\n\tint i, n;\n\tunsigned long flags;\n\n\tn = ACM_NW;\n\tspin_lock_irqsave(&acm->write_lock, flags);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tif(acm->wb[i].use)\n\t\t\tn--;\n\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\treturn n;\n}\n\n \nstatic void acm_write_done(struct acm *acm, struct acm_wb *wb)\n{\n\twb->use = false;\n\tacm->transmitting--;\n\tusb_autopm_put_interface_async(acm->control);\n}\n\n \n\nstatic int acm_start_wb(struct acm *acm, struct acm_wb *wb)\n{\n\tint rc;\n\n\tacm->transmitting++;\n\n\twb->urb->transfer_buffer = wb->buf;\n\twb->urb->transfer_dma = wb->dmah;\n\twb->urb->transfer_buffer_length = wb->len;\n\twb->urb->dev = acm->dev;\n\n\trc = usb_submit_urb(wb->urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tif (rc != -EPERM)\n\t\t\tdev_err(&acm->data->dev,\n\t\t\t\t\"%s - usb_submit_urb(write bulk) failed: %d\\n\",\n\t\t\t\t__func__, rc);\n\t\tacm_write_done(acm, wb);\n\t}\n\treturn rc;\n}\n\n \nstatic ssize_t bmCapabilities_show\n(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct acm *acm = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"%d\", acm->ctrl_caps);\n}\nstatic DEVICE_ATTR_RO(bmCapabilities);\n\nstatic ssize_t wCountryCodes_show\n(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct acm *acm = usb_get_intfdata(intf);\n\n\tmemcpy(buf, acm->country_codes, acm->country_code_size);\n\treturn acm->country_code_size;\n}\n\nstatic DEVICE_ATTR_RO(wCountryCodes);\n\nstatic ssize_t iCountryCodeRelDate_show\n(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct acm *acm = usb_get_intfdata(intf);\n\n\treturn sprintf(buf, \"%d\", acm->country_rel_date);\n}\n\nstatic DEVICE_ATTR_RO(iCountryCodeRelDate);\n \n\nstatic void acm_process_notification(struct acm *acm, unsigned char *buf)\n{\n\tint newctrl;\n\tint difference;\n\tunsigned long flags;\n\tstruct usb_cdc_notification *dr = (struct usb_cdc_notification *)buf;\n\tunsigned char *data = buf + sizeof(struct usb_cdc_notification);\n\n\tswitch (dr->bNotificationType) {\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - network connection: %d\\n\", __func__, dr->wValue);\n\t\tbreak;\n\n\tcase USB_CDC_NOTIFY_SERIAL_STATE:\n\t\tif (le16_to_cpu(dr->wLength) != 2) {\n\t\t\tdev_dbg(&acm->control->dev,\n\t\t\t\t\"%s - malformed serial state\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tnewctrl = get_unaligned_le16(data);\n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - serial state: 0x%x\\n\", __func__, newctrl);\n\n\t\tif (!acm->clocal && (acm->ctrlin & ~newctrl & USB_CDC_SERIAL_STATE_DCD)) {\n\t\t\tdev_dbg(&acm->control->dev,\n\t\t\t\t\"%s - calling hangup\\n\", __func__);\n\t\t\ttty_port_tty_hangup(&acm->port, false);\n\t\t}\n\n\t\tdifference = acm->ctrlin ^ newctrl;\n\n\t\tif ((difference & USB_CDC_SERIAL_STATE_DCD) && acm->port.tty) {\n\t\t\tstruct tty_ldisc *ld = tty_ldisc_ref(acm->port.tty);\n\t\t\tif (ld) {\n\t\t\t\tif (ld->ops->dcd_change)\n\t\t\t\t\tld->ops->dcd_change(acm->port.tty, newctrl & USB_CDC_SERIAL_STATE_DCD);\n\t\t\t\ttty_ldisc_deref(ld);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&acm->read_lock, flags);\n\t\tacm->ctrlin = newctrl;\n\t\tacm->oldcount = acm->iocount;\n\n\t\tif (difference & USB_CDC_SERIAL_STATE_DSR)\n\t\t\tacm->iocount.dsr++;\n\t\tif (difference & USB_CDC_SERIAL_STATE_DCD)\n\t\t\tacm->iocount.dcd++;\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_BREAK) {\n\t\t\tacm->iocount.brk++;\n\t\t\ttty_insert_flip_char(&acm->port, 0, TTY_BREAK);\n\t\t}\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_RING_SIGNAL)\n\t\t\tacm->iocount.rng++;\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_FRAMING)\n\t\t\tacm->iocount.frame++;\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_PARITY)\n\t\t\tacm->iocount.parity++;\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_OVERRUN)\n\t\t\tacm->iocount.overrun++;\n\t\tspin_unlock_irqrestore(&acm->read_lock, flags);\n\n\t\tif (newctrl & USB_CDC_SERIAL_STATE_BREAK)\n\t\t\ttty_flip_buffer_push(&acm->port);\n\n\t\tif (difference)\n\t\t\twake_up_all(&acm->wioctl);\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - unknown notification %d received: index %d len %d\\n\",\n\t\t\t__func__,\n\t\t\tdr->bNotificationType, dr->wIndex, dr->wLength);\n\t}\n}\n\n \nstatic void acm_ctrl_irq(struct urb *urb)\n{\n\tstruct acm *acm = urb->context;\n\tstruct usb_cdc_notification *dr = urb->transfer_buffer;\n\tunsigned int current_size = urb->actual_length;\n\tunsigned int expected_size, copy_size, alloc_size;\n\tint retval;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_mark_last_busy(acm->dev);\n\n\tif (acm->nb_index)\n\t\tdr = (struct usb_cdc_notification *)acm->notification_buffer;\n\n\t \n\texpected_size = sizeof(struct usb_cdc_notification) +\n\t\t\t\t\tle16_to_cpu(dr->wLength);\n\n\tif (current_size < expected_size) {\n\t\t \n\t\tif (acm->nb_size < expected_size) {\n\t\t\tu8 *new_buffer;\n\t\t\talloc_size = roundup_pow_of_two(expected_size);\n\t\t\t \n\t\t\tnew_buffer = krealloc(acm->notification_buffer,\n\t\t\t\t\t      alloc_size, GFP_ATOMIC);\n\t\t\tif (!new_buffer) {\n\t\t\t\tacm->nb_index = 0;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tacm->notification_buffer = new_buffer;\n\t\t\tacm->nb_size = alloc_size;\n\t\t\tdr = (struct usb_cdc_notification *)acm->notification_buffer;\n\t\t}\n\n\t\tcopy_size = min(current_size,\n\t\t\t\texpected_size - acm->nb_index);\n\n\t\tmemcpy(&acm->notification_buffer[acm->nb_index],\n\t\t       urb->transfer_buffer, copy_size);\n\t\tacm->nb_index += copy_size;\n\t\tcurrent_size = acm->nb_index;\n\t}\n\n\tif (current_size >= expected_size) {\n\t\t \n\t\tacm_process_notification(acm, (unsigned char *)dr);\n\t\tacm->nb_index = 0;\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval && retval != -EPERM && retval != -ENODEV)\n\t\tdev_err(&acm->control->dev,\n\t\t\t\"%s - usb_submit_urb failed: %d\\n\", __func__, retval);\n\telse\n\t\tdev_vdbg(&acm->control->dev,\n\t\t\t\"control resubmission terminated %d\\n\", retval);\n}\n\nstatic int acm_submit_read_urb(struct acm *acm, int index, gfp_t mem_flags)\n{\n\tint res;\n\n\tif (!test_and_clear_bit(index, &acm->read_urbs_free))\n\t\treturn 0;\n\n\tres = usb_submit_urb(acm->read_urbs[index], mem_flags);\n\tif (res) {\n\t\tif (res != -EPERM && res != -ENODEV) {\n\t\t\tdev_err(&acm->data->dev,\n\t\t\t\t\"urb %d failed submission with %d\\n\",\n\t\t\t\tindex, res);\n\t\t} else {\n\t\t\tdev_vdbg(&acm->data->dev, \"intended failure %d\\n\", res);\n\t\t}\n\t\tset_bit(index, &acm->read_urbs_free);\n\t\treturn res;\n\t} else {\n\t\tdev_vdbg(&acm->data->dev, \"submitted urb %d\\n\", index);\n\t}\n\n\treturn 0;\n}\n\nstatic int acm_submit_read_urbs(struct acm *acm, gfp_t mem_flags)\n{\n\tint res;\n\tint i;\n\n\tfor (i = 0; i < acm->rx_buflimit; ++i) {\n\t\tres = acm_submit_read_urb(acm, i, mem_flags);\n\t\tif (res)\n\t\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic void acm_process_read_urb(struct acm *acm, struct urb *urb)\n{\n\tunsigned long flags;\n\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tspin_lock_irqsave(&acm->read_lock, flags);\n\ttty_insert_flip_string(&acm->port, urb->transfer_buffer,\n\t\t\turb->actual_length);\n\tspin_unlock_irqrestore(&acm->read_lock, flags);\n\n\ttty_flip_buffer_push(&acm->port);\n}\n\nstatic void acm_read_bulk_callback(struct urb *urb)\n{\n\tstruct acm_rb *rb = urb->context;\n\tstruct acm *acm = rb->instance;\n\tint status = urb->status;\n\tbool stopped = false;\n\tbool stalled = false;\n\tbool cooldown = false;\n\n\tdev_vdbg(&acm->data->dev, \"got urb %d, len %d, status %d\\n\",\n\t\trb->index, urb->actual_length, status);\n\n\tswitch (status) {\n\tcase 0:\n\t\tusb_mark_last_busy(acm->dev);\n\t\tacm_process_read_urb(acm, urb);\n\t\tbreak;\n\tcase -EPIPE:\n\t\tset_bit(EVENT_RX_STALL, &acm->flags);\n\t\tstalled = true;\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&acm->data->dev,\n\t\t\t\"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\tstopped = true;\n\t\tbreak;\n\tcase -EOVERFLOW:\n\tcase -EPROTO:\n\t\tdev_dbg(&acm->data->dev,\n\t\t\t\"%s - cooling babbling device\\n\", __func__);\n\t\tusb_mark_last_busy(acm->dev);\n\t\tset_bit(rb->index, &acm->urbs_in_error_delay);\n\t\tset_bit(ACM_ERROR_DELAY, &acm->flags);\n\t\tcooldown = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&acm->data->dev,\n\t\t\t\"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tbreak;\n\t}\n\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(rb->index, &acm->read_urbs_free);\n\t \n\tsmp_mb__after_atomic();\n\n\tif (stopped || stalled || cooldown) {\n\t\tif (stalled)\n\t\t\tschedule_delayed_work(&acm->dwork, 0);\n\t\telse if (cooldown)\n\t\t\tschedule_delayed_work(&acm->dwork, HZ / 2);\n\t\treturn;\n\t}\n\n\tif (test_bit(ACM_THROTTLED, &acm->flags))\n\t\treturn;\n\n\tacm_submit_read_urb(acm, rb->index, GFP_ATOMIC);\n}\n\n \nstatic void acm_write_bulk(struct urb *urb)\n{\n\tstruct acm_wb *wb = urb->context;\n\tstruct acm *acm = wb->instance;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tif (status || (urb->actual_length != urb->transfer_buffer_length))\n\t\tdev_vdbg(&acm->data->dev, \"wrote len %d/%d, status %d\\n\",\n\t\t\turb->actual_length,\n\t\t\turb->transfer_buffer_length,\n\t\t\tstatus);\n\n\tspin_lock_irqsave(&acm->write_lock, flags);\n\tacm_write_done(acm, wb);\n\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\tset_bit(EVENT_TTY_WAKEUP, &acm->flags);\n\tschedule_delayed_work(&acm->dwork, 0);\n}\n\nstatic void acm_softint(struct work_struct *work)\n{\n\tint i;\n\tstruct acm *acm = container_of(work, struct acm, dwork.work);\n\n\tif (test_bit(EVENT_RX_STALL, &acm->flags)) {\n\t\tsmp_mb();  \n\t\tif (!acm->susp_count) {\n\t\t\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\t\t\tusb_kill_urb(acm->read_urbs[i]);\n\t\t\tusb_clear_halt(acm->dev, acm->in);\n\t\t\tacm_submit_read_urbs(acm, GFP_KERNEL);\n\t\t\tclear_bit(EVENT_RX_STALL, &acm->flags);\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(ACM_ERROR_DELAY, &acm->flags)) {\n\t\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\t\tif (test_and_clear_bit(i, &acm->urbs_in_error_delay))\n\t\t\t\tacm_submit_read_urb(acm, i, GFP_KERNEL);\n\t}\n\n\tif (test_and_clear_bit(EVENT_TTY_WAKEUP, &acm->flags))\n\t\ttty_port_tty_wakeup(&acm->port);\n}\n\n \n\nstatic int acm_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct acm *acm;\n\tint retval;\n\n\tacm = acm_get_by_minor(tty->index);\n\tif (!acm)\n\t\treturn -ENODEV;\n\n\tretval = tty_standard_install(driver, tty);\n\tif (retval)\n\t\tgoto error_init_termios;\n\n\t \n\tif (acm->quirks & DISABLE_ECHO)\n\t\ttty->termios.c_lflag &= ~ECHO;\n\n\ttty->driver_data = acm;\n\n\treturn 0;\n\nerror_init_termios:\n\ttty_port_put(&acm->port);\n\treturn retval;\n}\n\nstatic int acm_tty_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\treturn tty_port_open(&acm->port, tty, filp);\n}\n\nstatic void acm_port_dtr_rts(struct tty_port *port, bool active)\n{\n\tstruct acm *acm = container_of(port, struct acm, port);\n\tint val;\n\tint res;\n\n\tif (active)\n\t\tval = USB_CDC_CTRL_DTR | USB_CDC_CTRL_RTS;\n\telse\n\t\tval = 0;\n\n\t \n\tacm->ctrlout = val;\n\n\tres = acm_set_control(acm, val);\n\tif (res && (acm->ctrl_caps & USB_CDC_CAP_LINE))\n\t\t \n\t\tdev_dbg(&acm->control->dev, \"failed to set dtr/rts\\n\");\n}\n\nstatic int acm_port_activate(struct tty_port *port, struct tty_struct *tty)\n{\n\tstruct acm *acm = container_of(port, struct acm, port);\n\tint retval = -ENODEV;\n\tint i;\n\n\tmutex_lock(&acm->mutex);\n\tif (acm->disconnected)\n\t\tgoto disconnected;\n\n\tretval = usb_autopm_get_interface(acm->control);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\tset_bit(TTY_NO_WRITE_SPLIT, &tty->flags);\n\tacm->control->needs_remote_wakeup = 1;\n\n\tacm->ctrlurb->dev = acm->dev;\n\tretval = usb_submit_urb(acm->ctrlurb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&acm->control->dev,\n\t\t\t\"%s - usb_submit_urb(ctrl irq) failed\\n\", __func__);\n\t\tgoto error_submit_urb;\n\t}\n\n\tacm_tty_set_termios(tty, NULL);\n\n\t \n\tclear_bit(ACM_THROTTLED, &acm->flags);\n\n\tretval = acm_submit_read_urbs(acm, GFP_KERNEL);\n\tif (retval)\n\t\tgoto error_submit_read_urbs;\n\n\tusb_autopm_put_interface(acm->control);\n\n\tmutex_unlock(&acm->mutex);\n\n\treturn 0;\n\nerror_submit_read_urbs:\n\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\tusb_kill_urb(acm->read_urbs[i]);\n\tusb_kill_urb(acm->ctrlurb);\nerror_submit_urb:\n\tusb_autopm_put_interface(acm->control);\nerror_get_interface:\ndisconnected:\n\tmutex_unlock(&acm->mutex);\n\n\treturn usb_translate_errors(retval);\n}\n\nstatic void acm_port_destruct(struct tty_port *port)\n{\n\tstruct acm *acm = container_of(port, struct acm, port);\n\n\tif (acm->minor != ACM_MINOR_INVALID)\n\t\tacm_release_minor(acm);\n\tusb_put_intf(acm->control);\n\tkfree(acm->country_codes);\n\tkfree(acm);\n}\n\nstatic void acm_port_shutdown(struct tty_port *port)\n{\n\tstruct acm *acm = container_of(port, struct acm, port);\n\tstruct urb *urb;\n\tstruct acm_wb *wb;\n\n\t \n\tacm_poison_urbs(acm);\n\tspin_lock_irq(&acm->write_lock);\n\tspin_unlock_irq(&acm->write_lock);\n\n\tusb_autopm_get_interface_no_resume(acm->control);\n\tacm->control->needs_remote_wakeup = 0;\n\tusb_autopm_put_interface(acm->control);\n\n\tfor (;;) {\n\t\turb = usb_get_from_anchor(&acm->delayed);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\twb = urb->context;\n\t\twb->use = false;\n\t\tusb_autopm_put_interface_async(acm->control);\n\t}\n\n\tacm_unpoison_urbs(acm);\n\n}\n\nstatic void acm_tty_cleanup(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\ttty_port_put(&acm->port);\n}\n\nstatic void acm_tty_hangup(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\ttty_port_hangup(&acm->port);\n}\n\nstatic void acm_tty_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\ttty_port_close(&acm->port, tty, filp);\n}\n\nstatic ssize_t acm_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t     size_t count)\n{\n\tstruct acm *acm = tty->driver_data;\n\tint stat;\n\tunsigned long flags;\n\tint wbn;\n\tstruct acm_wb *wb;\n\n\tif (!count)\n\t\treturn 0;\n\n\tdev_vdbg(&acm->data->dev, \"%zu bytes from tty layer\\n\", count);\n\n\tspin_lock_irqsave(&acm->write_lock, flags);\n\twbn = acm_wb_alloc(acm);\n\tif (wbn < 0) {\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\treturn 0;\n\t}\n\twb = &acm->wb[wbn];\n\n\tif (!acm->dev) {\n\t\twb->use = false;\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tcount = (count > acm->writesize) ? acm->writesize : count;\n\tdev_vdbg(&acm->data->dev, \"writing %zu bytes\\n\", count);\n\tmemcpy(wb->buf, buf, count);\n\twb->len = count;\n\n\tstat = usb_autopm_get_interface_async(acm->control);\n\tif (stat) {\n\t\twb->use = false;\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\treturn stat;\n\t}\n\n\tif (acm->susp_count) {\n\t\tusb_anchor_urb(wb->urb, &acm->delayed);\n\t\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\t\treturn count;\n\t}\n\n\tstat = acm_start_wb(acm, wb);\n\tspin_unlock_irqrestore(&acm->write_lock, flags);\n\n\tif (stat < 0)\n\t\treturn stat;\n\treturn count;\n}\n\nstatic unsigned int acm_tty_write_room(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\t \n\treturn acm_wb_is_avail(acm) ? acm->writesize : 0;\n}\n\nstatic void acm_tty_flush_buffer(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&acm->write_lock, flags);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tif (acm->wb[i].use)\n\t\t\tusb_unlink_urb(acm->wb[i].urb);\n\tspin_unlock_irqrestore(&acm->write_lock, flags);\n}\n\nstatic unsigned int acm_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\t \n\tif (acm->disconnected)\n\t\treturn 0;\n\t \n\treturn (ACM_NW - acm_wb_is_avail(acm)) * acm->writesize;\n}\n\nstatic void acm_tty_throttle(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\tset_bit(ACM_THROTTLED, &acm->flags);\n}\n\nstatic void acm_tty_unthrottle(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\tclear_bit(ACM_THROTTLED, &acm->flags);\n\n\t \n\tsmp_mb();\n\n\tacm_submit_read_urbs(acm, GFP_KERNEL);\n}\n\nstatic int acm_tty_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct acm *acm = tty->driver_data;\n\tint retval;\n\n\tif (!(acm->ctrl_caps & USB_CDC_CAP_BRK))\n\t\treturn -EOPNOTSUPP;\n\n\tretval = acm_send_break(acm, state ? 0xffff : 0);\n\tif (retval < 0)\n\t\tdev_dbg(&acm->control->dev,\n\t\t\t\"%s - send break failed\\n\", __func__);\n\treturn retval;\n}\n\nstatic int acm_tty_tiocmget(struct tty_struct *tty)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\treturn (acm->ctrlout & USB_CDC_CTRL_DTR ? TIOCM_DTR : 0) |\n\t       (acm->ctrlout & USB_CDC_CTRL_RTS ? TIOCM_RTS : 0) |\n\t       (acm->ctrlin  & USB_CDC_SERIAL_STATE_DSR ? TIOCM_DSR : 0) |\n\t       (acm->ctrlin  & USB_CDC_SERIAL_STATE_RING_SIGNAL ? TIOCM_RI : 0) |\n\t       (acm->ctrlin  & USB_CDC_SERIAL_STATE_DCD ? TIOCM_CD : 0) |\n\t       TIOCM_CTS;\n}\n\nstatic int acm_tty_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct acm *acm = tty->driver_data;\n\tunsigned int newctrl;\n\n\tnewctrl = acm->ctrlout;\n\tset = (set & TIOCM_DTR ? USB_CDC_CTRL_DTR : 0) |\n\t      (set & TIOCM_RTS ? USB_CDC_CTRL_RTS : 0);\n\tclear = (clear & TIOCM_DTR ? USB_CDC_CTRL_DTR : 0) |\n\t\t(clear & TIOCM_RTS ? USB_CDC_CTRL_RTS : 0);\n\n\tnewctrl = (newctrl & ~clear) | set;\n\n\tif (acm->ctrlout == newctrl)\n\t\treturn 0;\n\treturn acm_set_control(acm, acm->ctrlout = newctrl);\n}\n\nstatic int get_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\tss->line = acm->minor;\n\tss->close_delay\t= jiffies_to_msecs(acm->port.close_delay) / 10;\n\tss->closing_wait = acm->port.closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\t\t\tASYNC_CLOSING_WAIT_NONE :\n\t\t\t\tjiffies_to_msecs(acm->port.closing_wait) / 10;\n\treturn 0;\n}\n\nstatic int set_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct acm *acm = tty->driver_data;\n\tunsigned int closing_wait, close_delay;\n\tint retval = 0;\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\tclosing_wait = ss->closing_wait == ASYNC_CLOSING_WAIT_NONE ?\n\t\t\tASYNC_CLOSING_WAIT_NONE :\n\t\t\tmsecs_to_jiffies(ss->closing_wait * 10);\n\n\tmutex_lock(&acm->port.mutex);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((close_delay != acm->port.close_delay) ||\n\t\t    (closing_wait != acm->port.closing_wait))\n\t\t\tretval = -EPERM;\n\t} else {\n\t\tacm->port.close_delay  = close_delay;\n\t\tacm->port.closing_wait = closing_wait;\n\t}\n\n\tmutex_unlock(&acm->port.mutex);\n\treturn retval;\n}\n\nstatic int wait_serial_change(struct acm *acm, unsigned long arg)\n{\n\tint rv = 0;\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct async_icount old, new;\n\n\tdo {\n\t\tspin_lock_irq(&acm->read_lock);\n\t\told = acm->oldcount;\n\t\tnew = acm->iocount;\n\t\tacm->oldcount = new;\n\t\tspin_unlock_irq(&acm->read_lock);\n\n\t\tif ((arg & TIOCM_DSR) &&\n\t\t\told.dsr != new.dsr)\n\t\t\tbreak;\n\t\tif ((arg & TIOCM_CD)  &&\n\t\t\told.dcd != new.dcd)\n\t\t\tbreak;\n\t\tif ((arg & TIOCM_RI) &&\n\t\t\told.rng != new.rng)\n\t\t\tbreak;\n\n\t\tadd_wait_queue(&acm->wioctl, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t\tremove_wait_queue(&acm->wioctl, &wait);\n\t\tif (acm->disconnected) {\n\t\t\tif (arg & TIOCM_CD)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\trv = -ENODEV;\n\t\t} else {\n\t\t\tif (signal_pending(current))\n\t\t\t\trv = -ERESTARTSYS;\n\t\t}\n\t} while (!rv);\n\n\t\n\n\treturn rv;\n}\n\nstatic int acm_tty_get_icount(struct tty_struct *tty,\n\t\t\t\t\tstruct serial_icounter_struct *icount)\n{\n\tstruct acm *acm = tty->driver_data;\n\n\ticount->dsr = acm->iocount.dsr;\n\ticount->rng = acm->iocount.rng;\n\ticount->dcd = acm->iocount.dcd;\n\ticount->frame = acm->iocount.frame;\n\ticount->overrun = acm->iocount.overrun;\n\ticount->parity = acm->iocount.parity;\n\ticount->brk = acm->iocount.brk;\n\n\treturn 0;\n}\n\nstatic int acm_tty_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct acm *acm = tty->driver_data;\n\tint rv = -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\trv = usb_autopm_get_interface(acm->control);\n\t\tif (rv < 0) {\n\t\t\trv = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\trv = wait_serial_change(acm, arg);\n\t\tusb_autopm_put_interface(acm->control);\n\t\tbreak;\n\t}\n\n\treturn rv;\n}\n\nstatic void acm_tty_set_termios(struct tty_struct *tty,\n\t\t\t\tconst struct ktermios *termios_old)\n{\n\tstruct acm *acm = tty->driver_data;\n\tstruct ktermios *termios = &tty->termios;\n\tstruct usb_cdc_line_coding newline;\n\tint newctrl = acm->ctrlout;\n\n\tnewline.dwDTERate = cpu_to_le32(tty_get_baud_rate(tty));\n\tnewline.bCharFormat = termios->c_cflag & CSTOPB ? 2 : 0;\n\tnewline.bParityType = termios->c_cflag & PARENB ?\n\t\t\t\t(termios->c_cflag & PARODD ? 1 : 2) +\n\t\t\t\t(termios->c_cflag & CMSPAR ? 2 : 0) : 0;\n\tnewline.bDataBits = tty_get_char_size(termios->c_cflag);\n\n\t \n\tacm->clocal = ((termios->c_cflag & CLOCAL) != 0);\n\n\tif (C_BAUD(tty) == B0) {\n\t\tnewline.dwDTERate = acm->line.dwDTERate;\n\t\tnewctrl &= ~USB_CDC_CTRL_DTR;\n\t} else if (termios_old && (termios_old->c_cflag & CBAUD) == B0) {\n\t\tnewctrl |=  USB_CDC_CTRL_DTR;\n\t}\n\n\tif (newctrl != acm->ctrlout)\n\t\tacm_set_control(acm, acm->ctrlout = newctrl);\n\n\tif (memcmp(&acm->line, &newline, sizeof newline)) {\n\t\tmemcpy(&acm->line, &newline, sizeof newline);\n\t\tdev_dbg(&acm->control->dev, \"%s - set line: %d %d %d %d\\n\",\n\t\t\t__func__,\n\t\t\tle32_to_cpu(newline.dwDTERate),\n\t\t\tnewline.bCharFormat, newline.bParityType,\n\t\t\tnewline.bDataBits);\n\t\tacm_set_line(acm, &acm->line);\n\t}\n}\n\nstatic const struct tty_port_operations acm_port_ops = {\n\t.dtr_rts = acm_port_dtr_rts,\n\t.shutdown = acm_port_shutdown,\n\t.activate = acm_port_activate,\n\t.destruct = acm_port_destruct,\n};\n\n \n\n \nstatic void acm_write_buffers_free(struct acm *acm)\n{\n\tint i;\n\tstruct acm_wb *wb;\n\n\tfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++)\n\t\tusb_free_coherent(acm->dev, acm->writesize, wb->buf, wb->dmah);\n}\n\nstatic void acm_read_buffers_free(struct acm *acm)\n{\n\tint i;\n\n\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\tusb_free_coherent(acm->dev, acm->readsize,\n\t\t\t  acm->read_buffers[i].base, acm->read_buffers[i].dma);\n}\n\n \nstatic int acm_write_buffers_alloc(struct acm *acm)\n{\n\tint i;\n\tstruct acm_wb *wb;\n\n\tfor (wb = &acm->wb[0], i = 0; i < ACM_NW; i++, wb++) {\n\t\twb->buf = usb_alloc_coherent(acm->dev, acm->writesize, GFP_KERNEL,\n\t\t    &wb->dmah);\n\t\tif (!wb->buf) {\n\t\t\twhile (i != 0) {\n\t\t\t\t--i;\n\t\t\t\t--wb;\n\t\t\t\tusb_free_coherent(acm->dev, acm->writesize,\n\t\t\t\t    wb->buf, wb->dmah);\n\t\t\t}\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int acm_probe(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_cdc_union_desc *union_header = NULL;\n\tstruct usb_cdc_call_mgmt_descriptor *cmgmd = NULL;\n\tunsigned char *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tstruct usb_interface *control_interface;\n\tstruct usb_interface *data_interface;\n\tstruct usb_endpoint_descriptor *epctrl = NULL;\n\tstruct usb_endpoint_descriptor *epread = NULL;\n\tstruct usb_endpoint_descriptor *epwrite = NULL;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usb_cdc_parsed_header h;\n\tstruct acm *acm;\n\tint minor;\n\tint ctrlsize, readsize;\n\tu8 *buf;\n\tint call_intf_num = -1;\n\tint data_intf_num = -1;\n\tunsigned long quirks;\n\tint num_rx_buf;\n\tint i;\n\tint combined_interfaces = 0;\n\tstruct device *tty_dev;\n\tint rv = -ENOMEM;\n\tint res;\n\n\t \n\tquirks = (unsigned long)id->driver_info;\n\n\tif (quirks == IGNORE_DEVICE)\n\t\treturn -ENODEV;\n\n\tmemset(&h, 0x00, sizeof(struct usb_cdc_parsed_header));\n\n\tnum_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;\n\n\t \n\tif (quirks == NO_UNION_NORMAL) {\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, 1);\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, 0);\n\t\t \n\t\tif (!data_interface || !control_interface)\n\t\t\treturn -ENODEV;\n\t\tgoto skip_normal_probe;\n\t}\n\n\t \n\tif (!buffer) {\n\t\tdev_err(&intf->dev, \"Weird descriptor references\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!buflen) {\n\t\tif (intf->cur_altsetting->endpoint &&\n\t\t\t\tintf->cur_altsetting->endpoint->extralen &&\n\t\t\t\tintf->cur_altsetting->endpoint->extra) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Seeking extra descriptors on endpoint\\n\");\n\t\t\tbuflen = intf->cur_altsetting->endpoint->extralen;\n\t\t\tbuffer = intf->cur_altsetting->endpoint->extra;\n\t\t} else {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\"Zero length descriptor references\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tcdc_parse_cdc_header(&h, intf, buffer, buflen);\n\tunion_header = h.usb_cdc_union_desc;\n\tcmgmd = h.usb_cdc_call_mgmt_descriptor;\n\tif (cmgmd)\n\t\tcall_intf_num = cmgmd->bDataInterface;\n\n\tif (!union_header) {\n\t\tif (intf->cur_altsetting->desc.bNumEndpoints == 3) {\n\t\t\tdev_dbg(&intf->dev, \"No union descriptor, assuming single interface\\n\");\n\t\t\tcombined_interfaces = 1;\n\t\t\tcontrol_interface = data_interface = intf;\n\t\t\tgoto look_for_collapsed_interface;\n\t\t} else if (call_intf_num > 0) {\n\t\t\tdev_dbg(&intf->dev, \"No union descriptor, using call management descriptor\\n\");\n\t\t\tdata_intf_num = call_intf_num;\n\t\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\t\t\tcontrol_interface = intf;\n\t\t} else {\n\t\t\tdev_dbg(&intf->dev, \"No union descriptor, giving up\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tint class = -1;\n\n\t\tdata_intf_num = union_header->bSlaveInterface0;\n\t\tcontrol_interface = usb_ifnum_to_if(usb_dev, union_header->bMasterInterface0);\n\t\tdata_interface = usb_ifnum_to_if(usb_dev, data_intf_num);\n\n\t\tif (control_interface)\n\t\t\tclass = control_interface->cur_altsetting->desc.bInterfaceClass;\n\n\t\tif (class != USB_CLASS_COMM && class != USB_CLASS_CDC_DATA) {\n\t\t\tdev_dbg(&intf->dev, \"Broken union descriptor, assuming single interface\\n\");\n\t\t\tcombined_interfaces = 1;\n\t\t\tcontrol_interface = data_interface = intf;\n\t\t\tgoto look_for_collapsed_interface;\n\t\t}\n\t}\n\n\tif (!control_interface || !data_interface) {\n\t\tdev_dbg(&intf->dev, \"no interfaces\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (data_intf_num != call_intf_num)\n\t\tdev_dbg(&intf->dev, \"Separate call control interface. That is not fully supported.\\n\");\n\n\tif (control_interface == data_interface) {\n\t\t \n\t\tdev_warn(&intf->dev,\"Control and data interfaces are not separated!\\n\");\n\t\tcombined_interfaces = 1;\n\t\t \n\t\tquirks |= NO_CAP_LINE;\n\t\tif (data_interface->cur_altsetting->desc.bNumEndpoints != 3) {\n\t\t\tdev_err(&intf->dev, \"This needs exactly 3 endpoints\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\nlook_for_collapsed_interface:\n\t\tres = usb_find_common_endpoints(data_interface->cur_altsetting,\n\t\t\t\t&epread, &epwrite, &epctrl, NULL);\n\t\tif (res)\n\t\t\treturn res;\n\n\t\tgoto made_compressed_probe;\n\t}\n\nskip_normal_probe:\n\n\t \n\tif (data_interface->cur_altsetting->desc.bInterfaceClass != USB_CLASS_CDC_DATA) {\n\t\tif (control_interface->cur_altsetting->desc.bInterfaceClass == USB_CLASS_CDC_DATA) {\n\t\t\tdev_dbg(&intf->dev,\n\t\t\t\t\"Your device has switched interfaces.\\n\");\n\t\t\tswap(control_interface, data_interface);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (!combined_interfaces && intf != control_interface)\n\t\treturn -ENODEV;\n\n\tif (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||\n\t    control_interface->cur_altsetting->desc.bNumEndpoints == 0)\n\t\treturn -EINVAL;\n\n\tepctrl = &control_interface->cur_altsetting->endpoint[0].desc;\n\tepread = &data_interface->cur_altsetting->endpoint[0].desc;\n\tepwrite = &data_interface->cur_altsetting->endpoint[1].desc;\n\n\n\t \n\tif (!usb_endpoint_dir_in(epread)) {\n\t\t \n\t\tdev_dbg(&intf->dev,\n\t\t\t\"The data interface has switched endpoints\\n\");\n\t\tswap(epread, epwrite);\n\t}\nmade_compressed_probe:\n\tdev_dbg(&intf->dev, \"interfaces are valid\\n\");\n\n\tacm = kzalloc(sizeof(struct acm), GFP_KERNEL);\n\tif (!acm)\n\t\treturn -ENOMEM;\n\n\ttty_port_init(&acm->port);\n\tacm->port.ops = &acm_port_ops;\n\n\tctrlsize = usb_endpoint_maxp(epctrl);\n\treadsize = usb_endpoint_maxp(epread) *\n\t\t\t\t(quirks == SINGLE_RX_URB ? 1 : 2);\n\tacm->combined_interfaces = combined_interfaces;\n\tacm->writesize = usb_endpoint_maxp(epwrite) * 20;\n\tacm->control = control_interface;\n\tacm->data = data_interface;\n\n\tusb_get_intf(acm->control);  \n\n\tminor = acm_alloc_minor(acm);\n\tif (minor < 0) {\n\t\tacm->minor = ACM_MINOR_INVALID;\n\t\tgoto err_put_port;\n\t}\n\n\tacm->minor = minor;\n\tacm->dev = usb_dev;\n\tif (h.usb_cdc_acm_descriptor)\n\t\tacm->ctrl_caps = h.usb_cdc_acm_descriptor->bmCapabilities;\n\tif (quirks & NO_CAP_LINE)\n\t\tacm->ctrl_caps &= ~USB_CDC_CAP_LINE;\n\tacm->ctrlsize = ctrlsize;\n\tacm->readsize = readsize;\n\tacm->rx_buflimit = num_rx_buf;\n\tINIT_DELAYED_WORK(&acm->dwork, acm_softint);\n\tinit_waitqueue_head(&acm->wioctl);\n\tspin_lock_init(&acm->write_lock);\n\tspin_lock_init(&acm->read_lock);\n\tmutex_init(&acm->mutex);\n\tif (usb_endpoint_xfer_int(epread)) {\n\t\tacm->bInterval = epread->bInterval;\n\t\tacm->in = usb_rcvintpipe(usb_dev, epread->bEndpointAddress);\n\t} else {\n\t\tacm->in = usb_rcvbulkpipe(usb_dev, epread->bEndpointAddress);\n\t}\n\tif (usb_endpoint_xfer_int(epwrite))\n\t\tacm->out = usb_sndintpipe(usb_dev, epwrite->bEndpointAddress);\n\telse\n\t\tacm->out = usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress);\n\tinit_usb_anchor(&acm->delayed);\n\tacm->quirks = quirks;\n\n\tbuf = usb_alloc_coherent(usb_dev, ctrlsize, GFP_KERNEL, &acm->ctrl_dma);\n\tif (!buf)\n\t\tgoto err_put_port;\n\tacm->ctrl_buffer = buf;\n\n\tif (acm_write_buffers_alloc(acm) < 0)\n\t\tgoto err_free_ctrl_buffer;\n\n\tacm->ctrlurb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!acm->ctrlurb)\n\t\tgoto err_free_write_buffers;\n\n\tfor (i = 0; i < num_rx_buf; i++) {\n\t\tstruct acm_rb *rb = &(acm->read_buffers[i]);\n\t\tstruct urb *urb;\n\n\t\trb->base = usb_alloc_coherent(acm->dev, readsize, GFP_KERNEL,\n\t\t\t\t\t\t\t\t&rb->dma);\n\t\tif (!rb->base)\n\t\t\tgoto err_free_read_urbs;\n\t\trb->index = i;\n\t\trb->instance = acm;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto err_free_read_urbs;\n\n\t\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\turb->transfer_dma = rb->dma;\n\t\tif (usb_endpoint_xfer_int(epread))\n\t\t\tusb_fill_int_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t acm->readsize,\n\t\t\t\t\t acm_read_bulk_callback, rb,\n\t\t\t\t\t acm->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(urb, acm->dev, acm->in, rb->base,\n\t\t\t\t\t  acm->readsize,\n\t\t\t\t\t  acm_read_bulk_callback, rb);\n\n\t\tacm->read_urbs[i] = urb;\n\t\t__set_bit(i, &acm->read_urbs_free);\n\t}\n\tfor (i = 0; i < ACM_NW; i++) {\n\t\tstruct acm_wb *snd = &(acm->wb[i]);\n\n\t\tsnd->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!snd->urb)\n\t\t\tgoto err_free_write_urbs;\n\n\t\tif (usb_endpoint_xfer_int(epwrite))\n\t\t\tusb_fill_int_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd, epwrite->bInterval);\n\t\telse\n\t\t\tusb_fill_bulk_urb(snd->urb, usb_dev, acm->out,\n\t\t\t\tNULL, acm->writesize, acm_write_bulk, snd);\n\t\tsnd->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tif (quirks & SEND_ZERO_PACKET)\n\t\t\tsnd->urb->transfer_flags |= URB_ZERO_PACKET;\n\t\tsnd->instance = acm;\n\t}\n\n\tusb_set_intfdata(intf, acm);\n\n\ti = device_create_file(&intf->dev, &dev_attr_bmCapabilities);\n\tif (i < 0)\n\t\tgoto err_free_write_urbs;\n\n\tif (h.usb_cdc_country_functional_desc) {  \n\t\tstruct usb_cdc_country_functional_desc * cfd =\n\t\t\t\t\th.usb_cdc_country_functional_desc;\n\n\t\tacm->country_codes = kmalloc(cfd->bLength - 4, GFP_KERNEL);\n\t\tif (!acm->country_codes)\n\t\t\tgoto skip_countries;\n\t\tacm->country_code_size = cfd->bLength - 4;\n\t\tmemcpy(acm->country_codes, (u8 *)&cfd->wCountyCode0,\n\t\t\t\t\t\t\tcfd->bLength - 4);\n\t\tacm->country_rel_date = cfd->iCountryCodeRelDate;\n\n\t\ti = device_create_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\tif (i < 0) {\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\n\t\ti = device_create_file(&intf->dev,\n\t\t\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t\tif (i < 0) {\n\t\t\tdevice_remove_file(&intf->dev, &dev_attr_wCountryCodes);\n\t\t\tkfree(acm->country_codes);\n\t\t\tacm->country_codes = NULL;\n\t\t\tacm->country_code_size = 0;\n\t\t\tgoto skip_countries;\n\t\t}\n\t}\n\nskip_countries:\n\tusb_fill_int_urb(acm->ctrlurb, usb_dev,\n\t\t\t usb_rcvintpipe(usb_dev, epctrl->bEndpointAddress),\n\t\t\t acm->ctrl_buffer, ctrlsize, acm_ctrl_irq, acm,\n\t\t\t  \n\t\t\t epctrl->bInterval ? epctrl->bInterval : 16);\n\tacm->ctrlurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tacm->ctrlurb->transfer_dma = acm->ctrl_dma;\n\tacm->notification_buffer = NULL;\n\tacm->nb_index = 0;\n\tacm->nb_size = 0;\n\n\tacm->line.dwDTERate = cpu_to_le32(9600);\n\tacm->line.bDataBits = 8;\n\tacm_set_line(acm, &acm->line);\n\n\tif (!acm->combined_interfaces) {\n\t\trv = usb_driver_claim_interface(&acm_driver, data_interface, acm);\n\t\tif (rv)\n\t\t\tgoto err_remove_files;\n\t}\n\n\ttty_dev = tty_port_register_device(&acm->port, acm_tty_driver, minor,\n\t\t\t&control_interface->dev);\n\tif (IS_ERR(tty_dev)) {\n\t\trv = PTR_ERR(tty_dev);\n\t\tgoto err_release_data_interface;\n\t}\n\n\tif (quirks & CLEAR_HALT_CONDITIONS) {\n\t\tusb_clear_halt(usb_dev, acm->in);\n\t\tusb_clear_halt(usb_dev, acm->out);\n\t}\n\n\tdev_info(&intf->dev, \"ttyACM%d: USB ACM device\\n\", minor);\n\n\treturn 0;\n\nerr_release_data_interface:\n\tif (!acm->combined_interfaces) {\n\t\t \n\t\tusb_set_intfdata(data_interface, NULL);\n\t\tusb_driver_release_interface(&acm_driver, data_interface);\n\t}\nerr_remove_files:\n\tif (acm->country_codes) {\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_wCountryCodes);\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t}\n\tdevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\nerr_free_write_urbs:\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_free_urb(acm->wb[i].urb);\nerr_free_read_urbs:\n\tfor (i = 0; i < num_rx_buf; i++)\n\t\tusb_free_urb(acm->read_urbs[i]);\n\tacm_read_buffers_free(acm);\n\tusb_free_urb(acm->ctrlurb);\nerr_free_write_buffers:\n\tacm_write_buffers_free(acm);\nerr_free_ctrl_buffer:\n\tusb_free_coherent(usb_dev, ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\nerr_put_port:\n\ttty_port_put(&acm->port);\n\n\treturn rv;\n}\n\nstatic void acm_disconnect(struct usb_interface *intf)\n{\n\tstruct acm *acm = usb_get_intfdata(intf);\n\tstruct tty_struct *tty;\n\tint i;\n\n\t \n\tif (!acm)\n\t\treturn;\n\n\tacm->disconnected = true;\n\t \n\tacm_poison_urbs(acm);\n\tmutex_lock(&acm->mutex);\n\tif (acm->country_codes) {\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_wCountryCodes);\n\t\tdevice_remove_file(&acm->control->dev,\n\t\t\t\t&dev_attr_iCountryCodeRelDate);\n\t}\n\twake_up_all(&acm->wioctl);\n\tdevice_remove_file(&acm->control->dev, &dev_attr_bmCapabilities);\n\tusb_set_intfdata(acm->control, NULL);\n\tusb_set_intfdata(acm->data, NULL);\n\tmutex_unlock(&acm->mutex);\n\n\ttty = tty_port_tty_get(&acm->port);\n\tif (tty) {\n\t\ttty_vhangup(tty);\n\t\ttty_kref_put(tty);\n\t}\n\n\tcancel_delayed_work_sync(&acm->dwork);\n\n\ttty_unregister_device(acm_tty_driver, acm->minor);\n\n\tusb_free_urb(acm->ctrlurb);\n\tfor (i = 0; i < ACM_NW; i++)\n\t\tusb_free_urb(acm->wb[i].urb);\n\tfor (i = 0; i < acm->rx_buflimit; i++)\n\t\tusb_free_urb(acm->read_urbs[i]);\n\tacm_write_buffers_free(acm);\n\tusb_free_coherent(acm->dev, acm->ctrlsize, acm->ctrl_buffer, acm->ctrl_dma);\n\tacm_read_buffers_free(acm);\n\n\tkfree(acm->notification_buffer);\n\n\tif (!acm->combined_interfaces)\n\t\tusb_driver_release_interface(&acm_driver, intf == acm->control ?\n\t\t\t\t\tacm->data : acm->control);\n\n\ttty_port_put(&acm->port);\n}\n\n#ifdef CONFIG_PM\nstatic int acm_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct acm *acm = usb_get_intfdata(intf);\n\tint cnt;\n\n\tspin_lock_irq(&acm->write_lock);\n\tif (PMSG_IS_AUTO(message)) {\n\t\tif (acm->transmitting) {\n\t\t\tspin_unlock_irq(&acm->write_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tcnt = acm->susp_count++;\n\tspin_unlock_irq(&acm->write_lock);\n\n\tif (cnt)\n\t\treturn 0;\n\n\tacm_poison_urbs(acm);\n\tcancel_delayed_work_sync(&acm->dwork);\n\tacm->urbs_in_error_delay = 0;\n\n\treturn 0;\n}\n\nstatic int acm_resume(struct usb_interface *intf)\n{\n\tstruct acm *acm = usb_get_intfdata(intf);\n\tstruct urb *urb;\n\tint rv = 0;\n\n\tspin_lock_irq(&acm->write_lock);\n\n\tif (--acm->susp_count)\n\t\tgoto out;\n\n\tacm_unpoison_urbs(acm);\n\n\tif (tty_port_initialized(&acm->port)) {\n\t\trv = usb_submit_urb(acm->ctrlurb, GFP_ATOMIC);\n\n\t\tfor (;;) {\n\t\t\turb = usb_get_from_anchor(&acm->delayed);\n\t\t\tif (!urb)\n\t\t\t\tbreak;\n\n\t\t\tacm_start_wb(acm, urb->context);\n\t\t}\n\n\t\t \n\t\tif (rv < 0)\n\t\t\tgoto out;\n\n\t\trv = acm_submit_read_urbs(acm, GFP_ATOMIC);\n\t}\nout:\n\tspin_unlock_irq(&acm->write_lock);\n\n\treturn rv;\n}\n\nstatic int acm_reset_resume(struct usb_interface *intf)\n{\n\tstruct acm *acm = usb_get_intfdata(intf);\n\n\tif (tty_port_initialized(&acm->port))\n\t\ttty_port_tty_hangup(&acm->port, false);\n\n\treturn acm_resume(intf);\n}\n\n#endif  \n\nstatic int acm_pre_reset(struct usb_interface *intf)\n{\n\tstruct acm *acm = usb_get_intfdata(intf);\n\n\tclear_bit(EVENT_RX_STALL, &acm->flags);\n\tacm->nb_index = 0;  \n\n\treturn 0;\n}\n\n#define NOKIA_PCSUITE_ACM_INFO(x) \\\n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x0421, x, \\\n\t\tUSB_CLASS_COMM, USB_CDC_SUBCLASS_ACM, \\\n\t\tUSB_CDC_ACM_PROTO_VENDOR)\n\n#define SAMSUNG_PCSUITE_ACM_INFO(x) \\\n\t\tUSB_DEVICE_AND_INTERFACE_INFO(0x04e7, x, \\\n\t\tUSB_CLASS_COMM, USB_CDC_SUBCLASS_ACM, \\\n\t\tUSB_CDC_ACM_PROTO_VENDOR)\n\n \n\nstatic const struct usb_device_id acm_ids[] = {\n\t \n\t{ USB_DEVICE(0x0424, 0x274e),  \n\t  .driver_info = DISABLE_ECHO, },  \n\t{ USB_DEVICE(0x076d, 0x0006),  \n\t.driver_info = NO_UNION_NORMAL, }, \n\t{ USB_DEVICE(0x17ef, 0x7000),  \n\t.driver_info = NO_UNION_NORMAL, }, \n\t{ USB_DEVICE(0x0870, 0x0001),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x045b, 0x023c),\t \n\t.driver_info = DISABLE_ECHO,\t \n\t},\n\t{ USB_DEVICE(0x045b, 0x0248),\t \n\t.driver_info = DISABLE_ECHO,\t \n\t},\n\t{ USB_DEVICE(0x045b, 0x024D),\t \n\t.driver_info = DISABLE_ECHO,\t \n\t},\n\t{ USB_DEVICE(0x0e8d, 0x0003),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0e8d, 0x2000),  \n\t.driver_info = DISABLE_ECHO,  \n\t},\n\t{ USB_DEVICE(0x0e8d, 0x3329),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0482, 0x0203),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x079b, 0x000f),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0ace, 0x1602),  \n\t.driver_info = SINGLE_RX_URB,\n\t},\n\t{ USB_DEVICE(0x0ace, 0x1608),  \n\t.driver_info = SINGLE_RX_URB,  \n\t},\n\t{ USB_DEVICE(0x0ace, 0x1611),  \n\t.driver_info = SINGLE_RX_URB,  \n\t},\n\t{ USB_DEVICE(0x11ca, 0x0201),  \n\t.driver_info = SINGLE_RX_URB,\n\t},\n\t{ USB_DEVICE(0x1965, 0x0018),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x7000),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0803, 0x3095),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0572, 0x1321),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0572, 0x1324),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0572, 0x1328),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0572, 0x1349),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x20df, 0x0001),  \n\t.driver_info = QUIRK_CONTROL_LINE_STATE, },\n\t{ USB_DEVICE(0x2184, 0x001c) },\t \n\t{ USB_DEVICE(0x2184, 0x0036) },\t \n\t{ USB_DEVICE(0x22b8, 0x6425),  \n\t},\n\t \n\t{ USB_DEVICE(0x22b8, 0x2d91) },  \n\t{ USB_DEVICE(0x22b8, 0x2d92),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d93),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d95),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d96),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d97),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d99),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x22b8, 0x2d9a),    \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\n\t{ USB_DEVICE(0x0572, 0x1329),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0572, 0x1340),  \n\t.driver_info = NO_UNION_NORMAL,\n\t},\n\t{ USB_DEVICE(0x05f9, 0x4002),  \n\t.driver_info = NO_UNION_NORMAL,\n\t},\n\t{ USB_DEVICE(0x1bbb, 0x0003),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x1576, 0x03b1),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0xfff0, 0x0100),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x09d8, 0x0320),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0c26, 0x0020),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\t{ USB_DEVICE(0x0ca6, 0xa050),  \n\t.driver_info = NO_UNION_NORMAL,  \n\t},\n\n\t{ USB_DEVICE(0x2912, 0x0001),  \n\t.driver_info = CLEAR_HALT_CONDITIONS,\n\t},\n\n\t \n\t{ NOKIA_PCSUITE_ACM_INFO(0x042D), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04D8), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04C9), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0419), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x044D), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0001), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0475), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0508), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0418), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0425), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0486), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04DF), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x000e), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0445), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x042F), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x048E), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0420), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04E6), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04B2), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0134), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x046E), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x002f), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0088), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x00fc), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0042), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x00b0), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x00ab), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0481), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0007), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0071), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04F0), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0070), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0099), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0128), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x008f), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x00a0), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x007b), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0094), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x003a), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x00e9), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0108), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x01f5), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x02e3), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0178), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x010e), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x02d9), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x01d0), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0223), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0275), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x026c), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0154), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x04ce), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x01d4), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0302), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x0335), },  \n\t{ NOKIA_PCSUITE_ACM_INFO(0x03cd), },  \n\t{ SAMSUNG_PCSUITE_ACM_INFO(0x6651), },  \n\n\t \n\t{ USB_DEVICE(0x03eb, 0x0030), },  \n\n\t \n\n#if IS_ENABLED(CONFIG_INPUT_IMS_PCU)\n\t{ USB_DEVICE(0x04d8, 0x0082),\t \n\t.driver_info = IGNORE_DEVICE,\n\t},\n\t{ USB_DEVICE(0x04d8, 0x0083),\t \n\t.driver_info = IGNORE_DEVICE,\n\t},\n#endif\n\n#if IS_ENABLED(CONFIG_IR_TOY)\n\t{ USB_DEVICE(0x04d8, 0xfd08),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t{ USB_DEVICE(0x04d8, 0xf58b),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n#endif\n\n#if IS_ENABLED(CONFIG_USB_SERIAL_XR)\n\t{ USB_DEVICE(0x04e2, 0x1400), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1401), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1402), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1403), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1410), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1411), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1412), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1414), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1420), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1422), .driver_info = IGNORE_DEVICE },\n\t{ USB_DEVICE(0x04e2, 0x1424), .driver_info = IGNORE_DEVICE },\n#endif\n\n\t \n\t{ USB_DEVICE(0x04e8, 0x685d),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t \n\t{ USB_DEVICE(0x058b, 0x0041),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t \n\t{ USB_DEVICE(0x108c, 0x0159),  \n\t.driver_info = IGNORE_DEVICE,\n\t},\n\t{ USB_DEVICE(0x108c, 0x0168),  \n\t.driver_info = IGNORE_DEVICE,\n\t},\n\t{ USB_DEVICE(0x108c, 0x0169),  \n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t{ USB_DEVICE(0x1bc7, 0x0021),  \n\t.driver_info = SEND_ZERO_PACKET,\n\t},\n\t{ USB_DEVICE(0x1bc7, 0x0023),  \n\t.driver_info = SEND_ZERO_PACKET,\n\t},\n\n\t \n\t{ USB_DEVICE(0x27c6, 0x5395),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t \n\t{ USB_DEVICE(0x32a7, 0x0000),\n\t.driver_info = IGNORE_DEVICE,\n\t},\n\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_PROTO_NONE) },\n\n\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_V25TER) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_PCCA101) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_PCCA101_WAKE) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_GSM) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_3G) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,\n\t\tUSB_CDC_ACM_PROTO_AT_CDMA) },\n\n\t{ USB_DEVICE(0x1519, 0x0452),  \n\t.driver_info = SEND_ZERO_PACKET,\n\t},\n\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, acm_ids);\n\nstatic struct usb_driver acm_driver = {\n\t.name =\t\t\"cdc_acm\",\n\t.probe =\tacm_probe,\n\t.disconnect =\tacm_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\tacm_suspend,\n\t.resume =\tacm_resume,\n\t.reset_resume =\tacm_reset_resume,\n#endif\n\t.pre_reset =\tacm_pre_reset,\n\t.id_table =\tacm_ids,\n#ifdef CONFIG_PM\n\t.supports_autosuspend = 1,\n#endif\n\t.disable_hub_initiated_lpm = 1,\n};\n\n \n\nstatic const struct tty_operations acm_ops = {\n\t.install =\t\tacm_tty_install,\n\t.open =\t\t\tacm_tty_open,\n\t.close =\t\tacm_tty_close,\n\t.cleanup =\t\tacm_tty_cleanup,\n\t.hangup =\t\tacm_tty_hangup,\n\t.write =\t\tacm_tty_write,\n\t.write_room =\t\tacm_tty_write_room,\n\t.flush_buffer =\t\tacm_tty_flush_buffer,\n\t.ioctl =\t\tacm_tty_ioctl,\n\t.throttle =\t\tacm_tty_throttle,\n\t.unthrottle =\t\tacm_tty_unthrottle,\n\t.chars_in_buffer =\tacm_tty_chars_in_buffer,\n\t.break_ctl =\t\tacm_tty_break_ctl,\n\t.set_termios =\t\tacm_tty_set_termios,\n\t.tiocmget =\t\tacm_tty_tiocmget,\n\t.tiocmset =\t\tacm_tty_tiocmset,\n\t.get_serial =\t\tget_serial_info,\n\t.set_serial =\t\tset_serial_info,\n\t.get_icount =\t\tacm_tty_get_icount,\n};\n\n \n\nstatic int __init acm_init(void)\n{\n\tint retval;\n\tacm_tty_driver = tty_alloc_driver(ACM_TTY_MINORS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(acm_tty_driver))\n\t\treturn PTR_ERR(acm_tty_driver);\n\tacm_tty_driver->driver_name = \"acm\",\n\tacm_tty_driver->name = \"ttyACM\",\n\tacm_tty_driver->major = ACM_TTY_MAJOR,\n\tacm_tty_driver->minor_start = 0,\n\tacm_tty_driver->type = TTY_DRIVER_TYPE_SERIAL,\n\tacm_tty_driver->subtype = SERIAL_TYPE_NORMAL,\n\tacm_tty_driver->init_termios = tty_std_termios;\n\tacm_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD |\n\t\t\t\t\t\t\t\tHUPCL | CLOCAL;\n\ttty_set_operations(acm_tty_driver, &acm_ops);\n\n\tretval = tty_register_driver(acm_tty_driver);\n\tif (retval) {\n\t\ttty_driver_kref_put(acm_tty_driver);\n\t\treturn retval;\n\t}\n\n\tretval = usb_register(&acm_driver);\n\tif (retval) {\n\t\ttty_unregister_driver(acm_tty_driver);\n\t\ttty_driver_kref_put(acm_tty_driver);\n\t\treturn retval;\n\t}\n\n\tprintk(KERN_INFO KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\n\treturn 0;\n}\n\nstatic void __exit acm_exit(void)\n{\n\tusb_deregister(&acm_driver);\n\ttty_unregister_driver(acm_tty_driver);\n\ttty_driver_kref_put(acm_tty_driver);\n\tidr_destroy(&acm_minors);\n}\n\nmodule_init(acm_init);\nmodule_exit(acm_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_CHARDEV_MAJOR(ACM_TTY_MAJOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}