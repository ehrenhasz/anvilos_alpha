{
  "module_name": "cdc-wdm.c",
  "hash_id": "9a897d5fae1f288339986bcf012a2943903072256819e67f252349c849dd17d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/class/cdc-wdm.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/ioctl.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/bitops.h>\n#include <linux/poll.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/wwan.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/usb/cdc-wdm.h>\n\n#define DRIVER_AUTHOR \"Oliver Neukum\"\n#define DRIVER_DESC \"USB Abstract Control Model driver for USB WCM Device Management\"\n\nstatic const struct usb_device_id wdm_ids[] = {\n\t{\n\t\t.match_flags = USB_DEVICE_ID_MATCH_INT_CLASS |\n\t\t\t\t USB_DEVICE_ID_MATCH_INT_SUBCLASS,\n\t\t.bInterfaceClass = USB_CLASS_COMM,\n\t\t.bInterfaceSubClass = USB_CDC_SUBCLASS_DMM\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE (usb, wdm_ids);\n\n#define WDM_MINOR_BASE\t176\n\n\n#define WDM_IN_USE\t\t1\n#define WDM_DISCONNECTING\t2\n#define WDM_RESULT\t\t3\n#define WDM_READ\t\t4\n#define WDM_INT_STALL\t\t5\n#define WDM_POLL_RUNNING\t6\n#define WDM_RESPONDING\t\t7\n#define WDM_SUSPENDING\t\t8\n#define WDM_RESETTING\t\t9\n#define WDM_OVERFLOW\t\t10\n#define WDM_WWAN_IN_USE\t\t11\n\n#define WDM_MAX\t\t\t16\n\n \n#define WDM_FLUSH_TIMEOUT\t(30 * HZ)\n\n \n#define WDM_DEFAULT_BUFSIZE\t256\n\nstatic DEFINE_MUTEX(wdm_mutex);\nstatic DEFINE_SPINLOCK(wdm_device_list_lock);\nstatic LIST_HEAD(wdm_device_list);\n\n \n\nstruct wdm_device {\n\tu8\t\t\t*inbuf;  \n\tu8\t\t\t*outbuf;  \n\tu8\t\t\t*sbuf;  \n\tu8\t\t\t*ubuf;  \n\n\tstruct urb\t\t*command;\n\tstruct urb\t\t*response;\n\tstruct urb\t\t*validity;\n\tstruct usb_interface\t*intf;\n\tstruct usb_ctrlrequest\t*orq;\n\tstruct usb_ctrlrequest\t*irq;\n\tspinlock_t\t\tiuspin;\n\n\tunsigned long\t\tflags;\n\tu16\t\t\tbufsize;\n\tu16\t\t\twMaxCommand;\n\tu16\t\t\twMaxPacketSize;\n\t__le16\t\t\tinum;\n\tint\t\t\treslength;\n\tint\t\t\tlength;\n\tint\t\t\tread;\n\tint\t\t\tcount;\n\tdma_addr_t\t\tshandle;\n\tdma_addr_t\t\tihandle;\n\tstruct mutex\t\twlock;\n\tstruct mutex\t\trlock;\n\twait_queue_head_t\twait;\n\tstruct work_struct\trxwork;\n\tstruct work_struct\tservice_outs_intr;\n\tint\t\t\twerr;\n\tint\t\t\trerr;\n\tint                     resp_count;\n\n\tstruct list_head\tdevice_list;\n\tint\t\t\t(*manage_power)(struct usb_interface *, int);\n\n\tenum wwan_port_type\twwanp_type;\n\tstruct wwan_port\t*wwanp;\n};\n\nstatic struct usb_driver wdm_driver;\n\n \nstatic struct wdm_device *wdm_find_device(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf == intf)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\nstatic struct wdm_device *wdm_find_device_by_minor(int minor)\n{\n\tstruct wdm_device *desc;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_for_each_entry(desc, &wdm_device_list, device_list)\n\t\tif (desc->intf->minor == minor)\n\t\t\tgoto found;\n\tdesc = NULL;\nfound:\n\tspin_unlock(&wdm_device_list_lock);\n\n\treturn desc;\n}\n\n \nstatic void wdm_out_callback(struct urb *urb)\n{\n\tstruct wdm_device *desc;\n\tunsigned long flags;\n\n\tdesc = urb->context;\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tdesc->werr = urb->status;\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\tkfree(desc->outbuf);\n\tdesc->outbuf = NULL;\n\tclear_bit(WDM_IN_USE, &desc->flags);\n\twake_up_all(&desc->wait);\n}\n\nstatic void wdm_wwan_rx(struct wdm_device *desc, int length);\n\nstatic void wdm_in_callback(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct wdm_device *desc = urb->context;\n\tint status = urb->status;\n\tint length = urb->actual_length;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tclear_bit(WDM_RESPONDING, &desc->flags);\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ENOENT\\n\");\n\t\t\tgoto skip_error;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ECONNRESET\\n\");\n\t\t\tgoto skip_error;\n\t\tcase -ESHUTDOWN:\n\t\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -ESHUTDOWN\\n\");\n\t\t\tgoto skip_error;\n\t\tcase -EPIPE:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: -EPIPE\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Unexpected error %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (test_bit(WDM_WWAN_IN_USE, &desc->flags)) {\n\t\twdm_wwan_rx(desc, length);\n\t\tgoto out;\n\t}\n\n\t \n\tif (desc->rerr == 0 && status != -EPIPE)\n\t\tdesc->rerr = status;\n\n\tif (length + desc->length > desc->wMaxCommand) {\n\t\t \n\t\tset_bit(WDM_OVERFLOW, &desc->flags);\n\t} else {\n\t\t \n\t\tif (!test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tmemmove(desc->ubuf + desc->length, desc->inbuf, length);\n\t\t\tdesc->length += length;\n\t\t\tdesc->reslength = length;\n\t\t}\n\t}\nskip_error:\n\n\tif (desc->rerr) {\n\t\t \n\t\tschedule_work(&desc->service_outs_intr);\n\t} else {\n\t\tset_bit(WDM_READ, &desc->flags);\n\t\twake_up(&desc->wait);\n\t}\nout:\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n}\n\nstatic void wdm_int_callback(struct urb *urb)\n{\n\tunsigned long flags;\n\tint rv = 0;\n\tint responding;\n\tint status = urb->status;\n\tstruct wdm_device *desc;\n\tstruct usb_cdc_notification *dr;\n\n\tdesc = urb->context;\n\tdr = (struct usb_cdc_notification *)desc->sbuf;\n\n\tif (status) {\n\t\tswitch (status) {\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOENT:\n\t\tcase -ECONNRESET:\n\t\t\treturn;  \n\t\tcase -EPIPE:\n\t\t\tset_bit(WDM_INT_STALL, &desc->flags);\n\t\t\tdev_err(&desc->intf->dev, \"Stall on int endpoint\\n\");\n\t\t\tgoto sw;  \n\t\tdefault:\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"nonzero urb status received: %d\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (urb->actual_length < sizeof(struct usb_cdc_notification)) {\n\t\tdev_err(&desc->intf->dev, \"wdm_int_callback - %d bytes\\n\",\n\t\t\turb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tswitch (dr->bNotificationType) {\n\tcase USB_CDC_NOTIFY_RESPONSE_AVAILABLE:\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_RESPONSE_AVAILABLE received: index %d len %d\\n\",\n\t\t\tle16_to_cpu(dr->wIndex), le16_to_cpu(dr->wLength));\n\t\tbreak;\n\n\tcase USB_CDC_NOTIFY_NETWORK_CONNECTION:\n\n\t\tdev_dbg(&desc->intf->dev,\n\t\t\t\"NOTIFY_NETWORK_CONNECTION %s network\\n\",\n\t\t\tdr->wValue ? \"connected to\" : \"disconnected from\");\n\t\tgoto exit;\n\tcase USB_CDC_NOTIFY_SPEED_CHANGE:\n\t\tdev_dbg(&desc->intf->dev, \"SPEED_CHANGE received (len %u)\\n\",\n\t\t\turb->actual_length);\n\t\tgoto exit;\n\tdefault:\n\t\tclear_bit(WDM_POLL_RUNNING, &desc->flags);\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"unknown notification %d received: index %d len %d\\n\",\n\t\t\tdr->bNotificationType,\n\t\t\tle16_to_cpu(dr->wIndex),\n\t\t\tle16_to_cpu(dr->wLength));\n\t\tgoto exit;\n\t}\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tresponding = test_and_set_bit(WDM_RESPONDING, &desc->flags);\n\tif (!desc->resp_count++ && !responding\n\t\t&& !test_bit(WDM_DISCONNECTING, &desc->flags)\n\t\t&& !test_bit(WDM_SUSPENDING, &desc->flags)) {\n\t\trv = usb_submit_urb(desc->response, GFP_ATOMIC);\n\t\tdev_dbg(&desc->intf->dev, \"submit response URB %d\\n\", rv);\n\t}\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\tif (rv < 0) {\n\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\tif (rv == -EPERM)\n\t\t\treturn;\n\t\tif (rv == -ENOMEM) {\nsw:\n\t\t\trv = schedule_work(&desc->rxwork);\n\t\t\tif (rv)\n\t\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\t\"Cannot schedule work\\n\");\n\t\t}\n\t}\nexit:\n\trv = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rv)\n\t\tdev_err(&desc->intf->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, rv);\n\n}\n\nstatic void poison_urbs(struct wdm_device *desc)\n{\n\t \n\tusb_poison_urb(desc->command);\n\tusb_poison_urb(desc->validity);\n\tusb_poison_urb(desc->response);\n}\n\nstatic void unpoison_urbs(struct wdm_device *desc)\n{\n\t \n\tusb_unpoison_urb(desc->response);\n\tusb_unpoison_urb(desc->validity);\n\tusb_unpoison_urb(desc->command);\n}\n\nstatic void free_urbs(struct wdm_device *desc)\n{\n\tusb_free_urb(desc->validity);\n\tusb_free_urb(desc->response);\n\tusb_free_urb(desc->command);\n}\n\nstatic void cleanup(struct wdm_device *desc)\n{\n\tkfree(desc->sbuf);\n\tkfree(desc->inbuf);\n\tkfree(desc->orq);\n\tkfree(desc->irq);\n\tkfree(desc->ubuf);\n\tfree_urbs(desc);\n\tkfree(desc);\n}\n\nstatic ssize_t wdm_write\n(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tu8 *buf;\n\tint rv = -EMSGSIZE, r, we;\n\tstruct wdm_device *desc = file->private_data;\n\tstruct usb_ctrlrequest *req;\n\n\tif (count > desc->wMaxCommand)\n\t\tcount = desc->wMaxCommand;\n\n\tspin_lock_irq(&desc->iuspin);\n\twe = desc->werr;\n\tdesc->werr = 0;\n\tspin_unlock_irq(&desc->iuspin);\n\tif (we < 0)\n\t\treturn usb_translate_errors(we);\n\n\tbuf = memdup_user(buffer, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\tr = mutex_lock_interruptible(&desc->wlock);\n\trv = -ERESTARTSYS;\n\tif (r)\n\t\tgoto out_free_mem;\n\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\trv = -ENODEV;\n\t\tgoto out_free_mem_lock;\n\t}\n\n\tr = usb_autopm_get_interface(desc->intf);\n\tif (r < 0) {\n\t\trv = usb_translate_errors(r);\n\t\tgoto out_free_mem_lock;\n\t}\n\n\tif (!(file->f_flags & O_NONBLOCK))\n\t\tr = wait_event_interruptible(desc->wait, !test_bit(WDM_IN_USE,\n\t\t\t\t\t\t\t\t&desc->flags));\n\telse\n\t\tif (test_bit(WDM_IN_USE, &desc->flags))\n\t\t\tr = -EAGAIN;\n\n\tif (test_bit(WDM_RESETTING, &desc->flags))\n\t\tr = -EIO;\n\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tr = -ENODEV;\n\n\tif (r < 0) {\n\t\trv = r;\n\t\tgoto out_free_mem_pm;\n\t}\n\n\treq = desc->orq;\n\tusb_fill_control_urb(\n\t\tdesc->command,\n\t\tinterface_to_usbdev(desc->intf),\n\t\t \n\t\tusb_sndctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)req,\n\t\tbuf,\n\t\tcount,\n\t\twdm_out_callback,\n\t\tdesc\n\t);\n\n\treq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t     USB_RECIP_INTERFACE);\n\treq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\treq->wValue = 0;\n\treq->wIndex = desc->inum;  \n\treq->wLength = cpu_to_le16(count);\n\tset_bit(WDM_IN_USE, &desc->flags);\n\tdesc->outbuf = buf;\n\n\trv = usb_submit_urb(desc->command, GFP_KERNEL);\n\tif (rv < 0) {\n\t\tdesc->outbuf = NULL;\n\t\tclear_bit(WDM_IN_USE, &desc->flags);\n\t\twake_up_all(&desc->wait);  \n\t\tdev_err(&desc->intf->dev, \"Tx URB error: %d\\n\", rv);\n\t\trv = usb_translate_errors(rv);\n\t\tgoto out_free_mem_pm;\n\t} else {\n\t\tdev_dbg(&desc->intf->dev, \"Tx URB has been submitted index=%d\\n\",\n\t\t\tle16_to_cpu(req->wIndex));\n\t}\n\n\tusb_autopm_put_interface(desc->intf);\n\tmutex_unlock(&desc->wlock);\n\treturn count;\n\nout_free_mem_pm:\n\tusb_autopm_put_interface(desc->intf);\nout_free_mem_lock:\n\tmutex_unlock(&desc->wlock);\nout_free_mem:\n\tkfree(buf);\n\treturn rv;\n}\n\n \nstatic int service_outstanding_interrupt(struct wdm_device *desc)\n{\n\tint rv = 0;\n\n\t \n\tif (!desc->resp_count || !--desc->resp_count)\n\t\tgoto out;\n\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\trv = -ENODEV;\n\t\tgoto out;\n\t}\n\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\trv = -EIO;\n\t\tgoto out;\n\t}\n\n\tset_bit(WDM_RESPONDING, &desc->flags);\n\tspin_unlock_irq(&desc->iuspin);\n\trv = usb_submit_urb(desc->response, GFP_KERNEL);\n\tspin_lock_irq(&desc->iuspin);\n\tif (rv) {\n\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"usb_submit_urb failed with result %d\\n\", rv);\n\n\t\t \n\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\tdesc->resp_count = 0;\n\t}\nout:\n\treturn rv;\n}\n\nstatic ssize_t wdm_read\n(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tint rv, cntr;\n\tint i = 0;\n\tstruct wdm_device *desc = file->private_data;\n\n\n\trv = mutex_lock_interruptible(&desc->rlock);  \n\tif (rv < 0)\n\t\treturn -ERESTARTSYS;\n\n\tcntr = READ_ONCE(desc->length);\n\tif (cntr == 0) {\n\t\tdesc->read = 0;\nretry:\n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_OVERFLOW, &desc->flags)) {\n\t\t\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\t\t\trv = -ENOBUFS;\n\t\t\tgoto err;\n\t\t}\n\t\ti++;\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tif (!test_bit(WDM_READ, &desc->flags)) {\n\t\t\t\trv = -EAGAIN;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = wait_event_interruptible(desc->wait,\n\t\t\t\ttest_bit(WDM_READ, &desc->flags));\n\t\t}\n\n\t\t \n\t\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\trv = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t\tif (test_bit(WDM_RESETTING, &desc->flags)) {\n\t\t\trv = -EIO;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_mark_last_busy(interface_to_usbdev(desc->intf));\n\t\tif (rv < 0) {\n\t\t\trv = -ERESTARTSYS;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_lock_irq(&desc->iuspin);\n\n\t\tif (desc->rerr) {  \n\t\t\trv = usb_translate_errors(desc->rerr);\n\t\t\tdesc->rerr = 0;\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tif (!test_bit(WDM_READ, &desc->flags)) {  \n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!desc->reslength) {  \n\t\t\tdev_dbg(&desc->intf->dev, \"zero length - clearing WDM_READ\\n\");\n\t\t\tclear_bit(WDM_READ, &desc->flags);\n\t\t\trv = service_outstanding_interrupt(desc);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tif (rv < 0)\n\t\t\t\tgoto err;\n\t\t\tgoto retry;\n\t\t}\n\t\tcntr = desc->length;\n\t\tspin_unlock_irq(&desc->iuspin);\n\t}\n\n\tif (cntr > count)\n\t\tcntr = count;\n\trv = copy_to_user(buffer, desc->ubuf, cntr);\n\tif (rv > 0) {\n\t\trv = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irq(&desc->iuspin);\n\n\tfor (i = 0; i < desc->length - cntr; i++)\n\t\tdesc->ubuf[i] = desc->ubuf[i + cntr];\n\n\tdesc->length -= cntr;\n\t \n\tif (!desc->length) {\n\t\tclear_bit(WDM_READ, &desc->flags);\n\t\tservice_outstanding_interrupt(desc);\n\t}\n\tspin_unlock_irq(&desc->iuspin);\n\trv = cntr;\n\nerr:\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n\nstatic int wdm_wait_for_response(struct file *file, long timeout)\n{\n\tstruct wdm_device *desc = file->private_data;\n\tlong rv;  \n\n\t \n\trv = wait_event_interruptible_timeout(desc->wait,\n\t\t\t      !test_bit(WDM_IN_USE, &desc->flags) ||\n\t\t\t      test_bit(WDM_DISCONNECTING, &desc->flags),\n\t\t\t      timeout);\n\n\t \n\tif (test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\treturn -ENODEV;\n\tif (!rv)\n\t\treturn -EIO;\n\tif (rv < 0)\n\t\treturn -EINTR;\n\n\tspin_lock_irq(&desc->iuspin);\n\trv = desc->werr;\n\tdesc->werr = 0;\n\tspin_unlock_irq(&desc->iuspin);\n\n\treturn usb_translate_errors(rv);\n\n}\n\n \nstatic int wdm_fsync(struct file *file, loff_t start, loff_t end, int datasync)\n{\n\treturn wdm_wait_for_response(file, MAX_SCHEDULE_TIMEOUT);\n}\n\n \nstatic int wdm_flush(struct file *file, fl_owner_t id)\n{\n\treturn wdm_wait_for_response(file, WDM_FLUSH_TIMEOUT);\n}\n\nstatic __poll_t wdm_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct wdm_device *desc = file->private_data;\n\tunsigned long flags;\n\t__poll_t mask = 0;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tmask = EPOLLHUP | EPOLLERR;\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\tgoto desc_out;\n\t}\n\tif (test_bit(WDM_READ, &desc->flags))\n\t\tmask = EPOLLIN | EPOLLRDNORM;\n\tif (desc->rerr || desc->werr)\n\t\tmask |= EPOLLERR;\n\tif (!test_bit(WDM_IN_USE, &desc->flags))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\n\tpoll_wait(file, &desc->wait, wait);\n\ndesc_out:\n\treturn mask;\n}\n\nstatic int wdm_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tint rv = -ENODEV;\n\tstruct usb_interface *intf;\n\tstruct wdm_device *desc;\n\n\tmutex_lock(&wdm_mutex);\n\tdesc = wdm_find_device_by_minor(minor);\n\tif (!desc)\n\t\tgoto out;\n\n\tintf = desc->intf;\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\tgoto out;\n\tfile->private_data = desc;\n\n\tif (test_bit(WDM_WWAN_IN_USE, &desc->flags)) {\n\t\trv = -EBUSY;\n\t\tgoto out;\n\t}\n\n\trv = usb_autopm_get_interface(desc->intf);\n\tif (rv < 0) {\n\t\tdev_err(&desc->intf->dev, \"Error autopm - %d\\n\", rv);\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&desc->wlock);\n\tif (!desc->count++) {\n\t\tdesc->werr = 0;\n\t\tdesc->rerr = 0;\n\t\trv = usb_submit_urb(desc->validity, GFP_KERNEL);\n\t\tif (rv < 0) {\n\t\t\tdesc->count--;\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error submitting int urb - %d\\n\", rv);\n\t\t\trv = usb_translate_errors(rv);\n\t\t}\n\t} else {\n\t\trv = 0;\n\t}\n\tmutex_unlock(&desc->wlock);\n\tif (desc->count == 1)\n\t\tdesc->manage_power(intf, 1);\n\tusb_autopm_put_interface(desc->intf);\nout:\n\tmutex_unlock(&wdm_mutex);\n\treturn rv;\n}\n\nstatic int wdm_release(struct inode *inode, struct file *file)\n{\n\tstruct wdm_device *desc = file->private_data;\n\n\tmutex_lock(&wdm_mutex);\n\n\t \n\tmutex_lock(&desc->wlock);\n\tdesc->count--;\n\tmutex_unlock(&desc->wlock);\n\n\tif (!desc->count) {\n\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\t\tdev_dbg(&desc->intf->dev, \"wdm_release: cleanup\\n\");\n\t\t\tpoison_urbs(desc);\n\t\t\tspin_lock_irq(&desc->iuspin);\n\t\t\tdesc->resp_count = 0;\n\t\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\t\tspin_unlock_irq(&desc->iuspin);\n\t\t\tdesc->manage_power(desc->intf, 0);\n\t\t\tunpoison_urbs(desc);\n\t\t} else {\n\t\t\t \n\t\t\tpr_debug(KBUILD_MODNAME \" %s: device gone - cleaning up\\n\", __func__);\n\t\t\tcleanup(desc);\n\t\t}\n\t}\n\tmutex_unlock(&wdm_mutex);\n\treturn 0;\n}\n\nstatic long wdm_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct wdm_device *desc = file->private_data;\n\tint rv = 0;\n\n\tswitch (cmd) {\n\tcase IOCTL_WDM_MAX_COMMAND:\n\t\tif (copy_to_user((void __user *)arg, &desc->wMaxCommand, sizeof(desc->wMaxCommand)))\n\t\t\trv = -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\trv = -ENOTTY;\n\t}\n\treturn rv;\n}\n\nstatic const struct file_operations wdm_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\twdm_read,\n\t.write =\twdm_write,\n\t.fsync =\twdm_fsync,\n\t.open =\t\twdm_open,\n\t.flush =\twdm_flush,\n\t.release =\twdm_release,\n\t.poll =\t\twdm_poll,\n\t.unlocked_ioctl = wdm_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic struct usb_class_driver wdm_class = {\n\t.name =\t\t\"cdc-wdm%d\",\n\t.fops =\t\t&wdm_fops,\n\t.minor_base =\tWDM_MINOR_BASE,\n};\n\n \n#ifdef CONFIG_WWAN\nstatic int wdm_wwan_port_start(struct wwan_port *port)\n{\n\tstruct wdm_device *desc = wwan_port_get_drvdata(port);\n\n\t \n\tmutex_lock(&wdm_mutex);\n\tif (desc->count) {\n\t\tmutex_unlock(&wdm_mutex);\n\t\treturn -EBUSY;\n\t}\n\tset_bit(WDM_WWAN_IN_USE, &desc->flags);\n\tmutex_unlock(&wdm_mutex);\n\n\tdesc->manage_power(desc->intf, 1);\n\n\t \n\twwan_port_txon(port);\n\n\t \n\treturn usb_submit_urb(desc->validity, GFP_KERNEL);\n}\n\nstatic void wdm_wwan_port_stop(struct wwan_port *port)\n{\n\tstruct wdm_device *desc = wwan_port_get_drvdata(port);\n\n\t \n\tpoison_urbs(desc);\n\tdesc->manage_power(desc->intf, 0);\n\tclear_bit(WDM_READ, &desc->flags);\n\tclear_bit(WDM_WWAN_IN_USE, &desc->flags);\n\tunpoison_urbs(desc);\n}\n\nstatic void wdm_wwan_port_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct wdm_device *desc = skb_shinfo(skb)->destructor_arg;\n\n\tusb_autopm_put_interface(desc->intf);\n\twwan_port_txon(desc->wwanp);\n\tkfree_skb(skb);\n}\n\nstatic int wdm_wwan_port_tx(struct wwan_port *port, struct sk_buff *skb)\n{\n\tstruct wdm_device *desc = wwan_port_get_drvdata(port);\n\tstruct usb_interface *intf = desc->intf;\n\tstruct usb_ctrlrequest *req = desc->orq;\n\tint rv;\n\n\trv = usb_autopm_get_interface(intf);\n\tif (rv)\n\t\treturn rv;\n\n\tusb_fill_control_urb(\n\t\tdesc->command,\n\t\tinterface_to_usbdev(intf),\n\t\tusb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t(unsigned char *)req,\n\t\tskb->data,\n\t\tskb->len,\n\t\twdm_wwan_port_tx_complete,\n\t\tskb\n\t);\n\n\treq->bRequestType = (USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\n\treq->bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;\n\treq->wValue = 0;\n\treq->wIndex = desc->inum;\n\treq->wLength = cpu_to_le16(skb->len);\n\n\tskb_shinfo(skb)->destructor_arg = desc;\n\n\trv = usb_submit_urb(desc->command, GFP_KERNEL);\n\tif (rv)\n\t\tusb_autopm_put_interface(intf);\n\telse  \n\t\twwan_port_txoff(port);\n\n\treturn rv;\n}\n\nstatic const struct wwan_port_ops wdm_wwan_port_ops = {\n\t.start = wdm_wwan_port_start,\n\t.stop = wdm_wwan_port_stop,\n\t.tx = wdm_wwan_port_tx,\n};\n\nstatic void wdm_wwan_init(struct wdm_device *desc)\n{\n\tstruct usb_interface *intf = desc->intf;\n\tstruct wwan_port *port;\n\n\t \n\tif (desc->wwanp_type == WWAN_PORT_UNKNOWN) {\n\t\tdev_info(&intf->dev, \"Unknown control protocol\\n\");\n\t\treturn;\n\t}\n\n\tport = wwan_create_port(&intf->dev, desc->wwanp_type, &wdm_wwan_port_ops,\n\t\t\t\tNULL, desc);\n\tif (IS_ERR(port)) {\n\t\tdev_err(&intf->dev, \"%s: Unable to create WWAN port\\n\",\n\t\t\tdev_name(intf->usb_dev));\n\t\treturn;\n\t}\n\n\tdesc->wwanp = port;\n}\n\nstatic void wdm_wwan_deinit(struct wdm_device *desc)\n{\n\tif (!desc->wwanp)\n\t\treturn;\n\n\twwan_remove_port(desc->wwanp);\n\tdesc->wwanp = NULL;\n}\n\nstatic void wdm_wwan_rx(struct wdm_device *desc, int length)\n{\n\tstruct wwan_port *port = desc->wwanp;\n\tstruct sk_buff *skb;\n\n\t \n\tskb = alloc_skb(length, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, desc->inbuf, length);\n\twwan_port_rx(port, skb);\n\n\t \n\tschedule_work(&desc->service_outs_intr);\n}\n#else  \nstatic void wdm_wwan_init(struct wdm_device *desc) {}\nstatic void wdm_wwan_deinit(struct wdm_device *desc) {}\nstatic void wdm_wwan_rx(struct wdm_device *desc, int length) {}\n#endif  \n\n \nstatic void wdm_rxwork(struct work_struct *work)\n{\n\tstruct wdm_device *desc = container_of(work, struct wdm_device, rxwork);\n\tunsigned long flags;\n\tint rv = 0;\n\tint responding;\n\n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tif (test_bit(WDM_DISCONNECTING, &desc->flags)) {\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t} else {\n\t\tresponding = test_and_set_bit(WDM_RESPONDING, &desc->flags);\n\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\tif (!responding)\n\t\t\trv = usb_submit_urb(desc->response, GFP_KERNEL);\n\t\tif (rv < 0 && rv != -EPERM) {\n\t\t\tspin_lock_irqsave(&desc->iuspin, flags);\n\t\t\tclear_bit(WDM_RESPONDING, &desc->flags);\n\t\t\tif (!test_bit(WDM_DISCONNECTING, &desc->flags))\n\t\t\t\tschedule_work(&desc->rxwork);\n\t\t\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\t\t}\n\t}\n}\n\nstatic void service_interrupt_work(struct work_struct *work)\n{\n\tstruct wdm_device *desc;\n\n\tdesc = container_of(work, struct wdm_device, service_outs_intr);\n\n\tspin_lock_irq(&desc->iuspin);\n\tservice_outstanding_interrupt(desc);\n\tif (!desc->resp_count) {\n\t\tset_bit(WDM_READ, &desc->flags);\n\t\twake_up(&desc->wait);\n\t}\n\tspin_unlock_irq(&desc->iuspin);\n}\n\n \n\nstatic int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor *ep,\n\t\t      u16 bufsize, enum wwan_port_type type,\n\t\t      int (*manage_power)(struct usb_interface *, int))\n{\n\tint rv = -ENOMEM;\n\tstruct wdm_device *desc;\n\n\tdesc = kzalloc(sizeof(struct wdm_device), GFP_KERNEL);\n\tif (!desc)\n\t\tgoto out;\n\tINIT_LIST_HEAD(&desc->device_list);\n\tmutex_init(&desc->rlock);\n\tmutex_init(&desc->wlock);\n\tspin_lock_init(&desc->iuspin);\n\tinit_waitqueue_head(&desc->wait);\n\tdesc->wMaxCommand = bufsize;\n\t \n\tdesc->inum = cpu_to_le16((u16)intf->cur_altsetting->desc.bInterfaceNumber);\n\tdesc->intf = intf;\n\tdesc->wwanp_type = type;\n\tINIT_WORK(&desc->rxwork, wdm_rxwork);\n\tINIT_WORK(&desc->service_outs_intr, service_interrupt_work);\n\n\tif (!usb_endpoint_is_int_in(ep)) {\n\t\trv = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdesc->wMaxPacketSize = usb_endpoint_maxp(ep);\n\n\tdesc->orq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->orq)\n\t\tgoto err;\n\tdesc->irq = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!desc->irq)\n\t\tgoto err;\n\n\tdesc->validity = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->validity)\n\t\tgoto err;\n\n\tdesc->response = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->response)\n\t\tgoto err;\n\n\tdesc->command = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!desc->command)\n\t\tgoto err;\n\n\tdesc->ubuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->ubuf)\n\t\tgoto err;\n\n\tdesc->sbuf = kmalloc(desc->wMaxPacketSize, GFP_KERNEL);\n\tif (!desc->sbuf)\n\t\tgoto err;\n\n\tdesc->inbuf = kmalloc(desc->wMaxCommand, GFP_KERNEL);\n\tif (!desc->inbuf)\n\t\tgoto err;\n\n\tusb_fill_int_urb(\n\t\tdesc->validity,\n\t\tinterface_to_usbdev(intf),\n\t\tusb_rcvintpipe(interface_to_usbdev(intf), ep->bEndpointAddress),\n\t\tdesc->sbuf,\n\t\tdesc->wMaxPacketSize,\n\t\twdm_int_callback,\n\t\tdesc,\n\t\tep->bInterval\n\t);\n\n\tdesc->irq->bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);\n\tdesc->irq->bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;\n\tdesc->irq->wValue = 0;\n\tdesc->irq->wIndex = desc->inum;  \n\tdesc->irq->wLength = cpu_to_le16(desc->wMaxCommand);\n\n\tusb_fill_control_urb(\n\t\tdesc->response,\n\t\tinterface_to_usbdev(intf),\n\t\t \n\t\tusb_rcvctrlpipe(interface_to_usbdev(desc->intf), 0),\n\t\t(unsigned char *)desc->irq,\n\t\tdesc->inbuf,\n\t\tdesc->wMaxCommand,\n\t\twdm_in_callback,\n\t\tdesc\n\t);\n\n\tdesc->manage_power = manage_power;\n\n\tspin_lock(&wdm_device_list_lock);\n\tlist_add(&desc->device_list, &wdm_device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\trv = usb_register_dev(intf, &wdm_class);\n\tif (rv < 0)\n\t\tgoto err;\n\telse\n\t\tdev_info(&intf->dev, \"%s: USB WDM device\\n\", dev_name(intf->usb_dev));\n\n\twdm_wwan_init(desc);\n\nout:\n\treturn rv;\nerr:\n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\tcleanup(desc);\n\treturn rv;\n}\n\nstatic int wdm_manage_power(struct usb_interface *intf, int on)\n{\n\t \n\tint rv = usb_autopm_get_interface(intf);\n\n\tintf->needs_remote_wakeup = on;\n\tif (!rv)\n\t\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nstatic int wdm_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint rv = -EINVAL;\n\tstruct usb_host_interface *iface;\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct usb_cdc_parsed_header hdr;\n\tu8 *buffer = intf->altsetting->extra;\n\tint buflen = intf->altsetting->extralen;\n\tu16 maxcom = WDM_DEFAULT_BUFSIZE;\n\n\tif (!buffer)\n\t\tgoto err;\n\n\tcdc_parse_cdc_header(&hdr, intf, buffer, buflen);\n\n\tif (hdr.usb_cdc_dmm_desc)\n\t\tmaxcom = le16_to_cpu(hdr.usb_cdc_dmm_desc->wMaxCommand);\n\n\tiface = intf->cur_altsetting;\n\tif (iface->desc.bNumEndpoints != 1)\n\t\tgoto err;\n\tep = &iface->endpoint[0].desc;\n\n\trv = wdm_create(intf, ep, maxcom, WWAN_PORT_UNKNOWN, &wdm_manage_power);\n\nerr:\n\treturn rv;\n}\n\n \nstruct usb_driver *usb_cdc_wdm_register(struct usb_interface *intf,\n\t\t\t\t\tstruct usb_endpoint_descriptor *ep,\n\t\t\t\t\tint bufsize, enum wwan_port_type type,\n\t\t\t\t\tint (*manage_power)(struct usb_interface *, int))\n{\n\tint rv;\n\n\trv = wdm_create(intf, ep, bufsize, type, manage_power);\n\tif (rv < 0)\n\t\tgoto err;\n\n\treturn &wdm_driver;\nerr:\n\treturn ERR_PTR(rv);\n}\nEXPORT_SYMBOL(usb_cdc_wdm_register);\n\nstatic void wdm_disconnect(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc;\n\tunsigned long flags;\n\n\tusb_deregister_dev(intf, &wdm_class);\n\tdesc = wdm_find_device(intf);\n\tmutex_lock(&wdm_mutex);\n\n\twdm_wwan_deinit(desc);\n\n\t \n\tspin_lock_irqsave(&desc->iuspin, flags);\n\tset_bit(WDM_DISCONNECTING, &desc->flags);\n\tset_bit(WDM_READ, &desc->flags);\n\tspin_unlock_irqrestore(&desc->iuspin, flags);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tpoison_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\tcancel_work_sync(&desc->service_outs_intr);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\n\t \n\tspin_lock(&wdm_device_list_lock);\n\tlist_del(&desc->device_list);\n\tspin_unlock(&wdm_device_list_lock);\n\n\tif (!desc->count)\n\t\tcleanup(desc);\n\telse\n\t\tdev_dbg(&intf->dev, \"%d open files - postponing cleanup\\n\", desc->count);\n\tmutex_unlock(&wdm_mutex);\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv = 0;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_suspend\\n\", intf->minor);\n\n\t \n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_lock(&desc->rlock);\n\t\tmutex_lock(&desc->wlock);\n\t}\n\tspin_lock_irq(&desc->iuspin);\n\n\tif (PMSG_IS_AUTO(message) &&\n\t\t\t(test_bit(WDM_IN_USE, &desc->flags)\n\t\t\t|| test_bit(WDM_RESPONDING, &desc->flags))) {\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\trv = -EBUSY;\n\t} else {\n\n\t\tset_bit(WDM_SUSPENDING, &desc->flags);\n\t\tspin_unlock_irq(&desc->iuspin);\n\t\t \n\t\tpoison_urbs(desc);\n\t\tcancel_work_sync(&desc->rxwork);\n\t\tcancel_work_sync(&desc->service_outs_intr);\n\t\tunpoison_urbs(desc);\n\t}\n\tif (!PMSG_IS_AUTO(message)) {\n\t\tmutex_unlock(&desc->wlock);\n\t\tmutex_unlock(&desc->rlock);\n\t}\n\n\treturn rv;\n}\n#endif\n\nstatic int recover_from_urb_loss(struct wdm_device *desc)\n{\n\tint rv = 0;\n\n\tif (desc->count) {\n\t\trv = usb_submit_urb(desc->validity, GFP_NOIO);\n\t\tif (rv < 0)\n\t\t\tdev_err(&desc->intf->dev,\n\t\t\t\t\"Error resume submitting int urb - %d\\n\", rv);\n\t}\n\treturn rv;\n}\n\n#ifdef CONFIG_PM\nstatic int wdm_resume(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tdev_dbg(&desc->intf->dev, \"wdm%d_resume\\n\", intf->minor);\n\n\tclear_bit(WDM_SUSPENDING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\n\treturn rv;\n}\n#endif\n\nstatic int wdm_pre_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\n\t \n\tspin_lock_irq(&desc->iuspin);\n\tset_bit(WDM_RESETTING, &desc->flags);\t \n\tset_bit(WDM_READ, &desc->flags);\t \n\tclear_bit(WDM_IN_USE, &desc->flags);\t \n\tdesc->rerr = -EINTR;\n\tspin_unlock_irq(&desc->iuspin);\n\twake_up_all(&desc->wait);\n\tmutex_lock(&desc->rlock);\n\tmutex_lock(&desc->wlock);\n\tpoison_urbs(desc);\n\tcancel_work_sync(&desc->rxwork);\n\tcancel_work_sync(&desc->service_outs_intr);\n\treturn 0;\n}\n\nstatic int wdm_post_reset(struct usb_interface *intf)\n{\n\tstruct wdm_device *desc = wdm_find_device(intf);\n\tint rv;\n\n\tunpoison_urbs(desc);\n\tclear_bit(WDM_OVERFLOW, &desc->flags);\n\tclear_bit(WDM_RESETTING, &desc->flags);\n\trv = recover_from_urb_loss(desc);\n\tmutex_unlock(&desc->wlock);\n\tmutex_unlock(&desc->rlock);\n\treturn rv;\n}\n\nstatic struct usb_driver wdm_driver = {\n\t.name =\t\t\"cdc_wdm\",\n\t.probe =\twdm_probe,\n\t.disconnect =\twdm_disconnect,\n#ifdef CONFIG_PM\n\t.suspend =\twdm_suspend,\n\t.resume =\twdm_resume,\n\t.reset_resume =\twdm_resume,\n#endif\n\t.pre_reset =\twdm_pre_reset,\n\t.post_reset =\twdm_post_reset,\n\t.id_table =\twdm_ids,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(wdm_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}