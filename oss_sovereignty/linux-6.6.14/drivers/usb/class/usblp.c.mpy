{
  "module_name": "usblp.c",
  "hash_id": "19db7f3f46e4355fcd583a23dd0ac4dbfdeadbb1aa6853c16f42a599b9538bf1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/class/usblp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/lp.h>\n#include <linux/mutex.h>\n#undef DEBUG\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/ratelimit.h>\n\n \n#define DRIVER_AUTHOR \"Michael Gee, Pavel Machek, Vojtech Pavlik, Randy Dunlap, Pete Zaitcev, David Paschal\"\n#define DRIVER_DESC \"USB Printer Device Class driver\"\n\n#define USBLP_BUF_SIZE\t\t8192\n#define USBLP_BUF_SIZE_IN\t1024\n#define USBLP_DEVICE_ID_SIZE\t1024\n\n \n#define IOCNR_GET_DEVICE_ID\t\t1\n#define IOCNR_GET_PROTOCOLS\t\t2\n#define IOCNR_SET_PROTOCOL\t\t3\n#define IOCNR_HP_SET_CHANNEL\t\t4\n#define IOCNR_GET_BUS_ADDRESS\t\t5\n#define IOCNR_GET_VID_PID\t\t6\n#define IOCNR_SOFT_RESET\t\t7\n \n#define LPIOC_GET_DEVICE_ID(len) _IOC(_IOC_READ, 'P', IOCNR_GET_DEVICE_ID, len)\n \n#define LPIOC_GET_PROTOCOLS(len) _IOC(_IOC_READ, 'P', IOCNR_GET_PROTOCOLS, len)\n \n#define LPIOC_SET_PROTOCOL _IOC(_IOC_WRITE, 'P', IOCNR_SET_PROTOCOL, 0)\n \n#define LPIOC_HP_SET_CHANNEL _IOC(_IOC_WRITE, 'P', IOCNR_HP_SET_CHANNEL, 0)\n \n#define LPIOC_GET_BUS_ADDRESS(len) _IOC(_IOC_READ, 'P', IOCNR_GET_BUS_ADDRESS, len)\n \n#define LPIOC_GET_VID_PID(len) _IOC(_IOC_READ, 'P', IOCNR_GET_VID_PID, len)\n \n#define LPIOC_SOFT_RESET _IOC(_IOC_NONE, 'P', IOCNR_SOFT_RESET, 0);\n\n \n\n \n\n#define USBLP_REQ_GET_ID\t\t\t0x00\n#define USBLP_REQ_GET_STATUS\t\t\t0x01\n#define USBLP_REQ_RESET\t\t\t\t0x02\n#define USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST\t0x00\t \n\n#define USBLP_MINORS\t\t16\n#define USBLP_MINOR_BASE\t0\n\n#define USBLP_CTL_TIMEOUT\t5000\t\t\t \n\n#define USBLP_FIRST_PROTOCOL\t1\n#define USBLP_LAST_PROTOCOL\t3\n#define USBLP_MAX_PROTOCOLS\t(USBLP_LAST_PROTOCOL+1)\n\n \n#define STATUS_BUF_SIZE\t\t8\n\n \nstruct usblp {\n\tstruct usb_device\t*dev;\t\t\t \n\tstruct mutex\t\twmut;\n\tstruct mutex\t\tmut;\n\tspinlock_t\t\tlock;\t\t \n\tchar\t\t\t*readbuf;\t\t \n\tchar\t\t\t*statusbuf;\t\t \n\tstruct usb_anchor\turbs;\n\twait_queue_head_t\trwait, wwait;\n\tint\t\t\treadcount;\t\t \n\tint\t\t\tifnum;\t\t\t \n\tstruct usb_interface\t*intf;\t\t\t \n\t \n\tstruct {\n\t\tint\t\t\t\talt_setting;\n\t\tstruct usb_endpoint_descriptor\t*epwrite;\n\t\tstruct usb_endpoint_descriptor\t*epread;\n\t}\t\t\tprotocol[USBLP_MAX_PROTOCOLS];\n\tint\t\t\tcurrent_protocol;\n\tint\t\t\tminor;\t\t\t \n\tint\t\t\twcomplete, rcomplete;\n\tint\t\t\twstatus;\t \n\tint\t\t\trstatus;\t \n\tunsigned int\t\tquirks;\t\t\t \n\tunsigned int\t\tflags;\t\t\t \n\tunsigned char\t\tused;\t\t\t \n\tunsigned char\t\tpresent;\t\t \n\tunsigned char\t\tbidir;\t\t\t \n\tunsigned char\t\tno_paper;\t\t \n\tunsigned char\t\t*device_id_string;\t \n\t\t\t\t\t\t\t \n};\n\n#ifdef DEBUG\nstatic void usblp_dump(struct usblp *usblp)\n{\n\tstruct device *dev = &usblp->intf->dev;\n\tint p;\n\n\tdev_dbg(dev, \"usblp=0x%p\\n\", usblp);\n\tdev_dbg(dev, \"dev=0x%p\\n\", usblp->dev);\n\tdev_dbg(dev, \"present=%d\\n\", usblp->present);\n\tdev_dbg(dev, \"readbuf=0x%p\\n\", usblp->readbuf);\n\tdev_dbg(dev, \"readcount=%d\\n\", usblp->readcount);\n\tdev_dbg(dev, \"ifnum=%d\\n\", usblp->ifnum);\n\tfor (p = USBLP_FIRST_PROTOCOL; p <= USBLP_LAST_PROTOCOL; p++) {\n\t\tdev_dbg(dev, \"protocol[%d].alt_setting=%d\\n\", p,\n\t\t\tusblp->protocol[p].alt_setting);\n\t\tdev_dbg(dev, \"protocol[%d].epwrite=%p\\n\", p,\n\t\t\tusblp->protocol[p].epwrite);\n\t\tdev_dbg(dev, \"protocol[%d].epread=%p\\n\", p,\n\t\t\tusblp->protocol[p].epread);\n\t}\n\tdev_dbg(dev, \"current_protocol=%d\\n\", usblp->current_protocol);\n\tdev_dbg(dev, \"minor=%d\\n\", usblp->minor);\n\tdev_dbg(dev, \"wstatus=%d\\n\", usblp->wstatus);\n\tdev_dbg(dev, \"rstatus=%d\\n\", usblp->rstatus);\n\tdev_dbg(dev, \"quirks=%d\\n\", usblp->quirks);\n\tdev_dbg(dev, \"used=%d\\n\", usblp->used);\n\tdev_dbg(dev, \"bidir=%d\\n\", usblp->bidir);\n\tdev_dbg(dev, \"device_id_string=\\\"%s\\\"\\n\",\n\t\tusblp->device_id_string ?\n\t\t\tusblp->device_id_string + 2 :\n\t\t\t(unsigned char *)\"(null)\");\n}\n#endif\n\n \n\nstruct quirk_printer_struct {\n\t__u16 vendorId;\n\t__u16 productId;\n\tunsigned int quirks;\n};\n\n#define USBLP_QUIRK_BIDIR\t0x1\t \n#define USBLP_QUIRK_USB_INIT\t0x2\t \n#define USBLP_QUIRK_BAD_CLASS\t0x4\t \n\nstatic const struct quirk_printer_struct quirk_printers[] = {\n\t{ 0x03f0, 0x0004, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0104, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0204, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0304, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0404, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0504, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0604, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x0804, USBLP_QUIRK_BIDIR },  \n\t{ 0x03f0, 0x1104, USBLP_QUIRK_BIDIR },  \n\t{ 0x0409, 0xefbe, USBLP_QUIRK_BIDIR },  \n\t{ 0x0409, 0xbef4, USBLP_QUIRK_BIDIR },  \n\t{ 0x0409, 0xf0be, USBLP_QUIRK_BIDIR },  \n\t{ 0x0409, 0xf1be, USBLP_QUIRK_BIDIR },  \n\t{ 0x0482, 0x0010, USBLP_QUIRK_BIDIR },  \n\t{ 0x04f9, 0x000d, USBLP_QUIRK_BIDIR },  \n\t{ 0x04b8, 0x0202, USBLP_QUIRK_BAD_CLASS },  \n\t{ 0, 0 }\n};\n\nstatic int usblp_wwait(struct usblp *usblp, int nonblock);\nstatic int usblp_wtest(struct usblp *usblp, int nonblock);\nstatic int usblp_rwait_and_lock(struct usblp *usblp, int nonblock);\nstatic int usblp_rtest(struct usblp *usblp, int nonblock);\nstatic int usblp_submit_read(struct usblp *usblp);\nstatic int usblp_select_alts(struct usblp *usblp);\nstatic int usblp_set_protocol(struct usblp *usblp, int protocol);\nstatic int usblp_cache_device_id_string(struct usblp *usblp);\n\n \nstatic struct usb_driver usblp_driver;\nstatic DEFINE_MUTEX(usblp_mutex);\t \n\n \n\nstatic int usblp_ctrl_msg(struct usblp *usblp, int request, int type, int dir, int recip, int value, void *buf, int len)\n{\n\tint retval;\n\tint index = usblp->ifnum;\n\n\t \n\tif ((request == USBLP_REQ_GET_ID) && (type == USB_TYPE_CLASS))\n\t\tindex = (usblp->ifnum<<8)|usblp->protocol[usblp->current_protocol].alt_setting;\n\n\tretval = usb_control_msg(usblp->dev,\n\t\tdir ? usb_rcvctrlpipe(usblp->dev, 0) : usb_sndctrlpipe(usblp->dev, 0),\n\t\trequest, type | dir | recip, value, index, buf, len, USBLP_CTL_TIMEOUT);\n\tdev_dbg(&usblp->intf->dev,\n\t\t\"usblp_control_msg: rq: 0x%02x dir: %d recip: %d value: %d idx: %d len: %#x result: %d\\n\",\n\t\trequest, !!dir, recip, value, index, len, retval);\n\treturn retval < 0 ? retval : 0;\n}\n\n#define usblp_read_status(usblp, status)\\\n\tusblp_ctrl_msg(usblp, USBLP_REQ_GET_STATUS, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, 0, status, 1)\n#define usblp_get_id(usblp, config, id, maxlen)\\\n\tusblp_ctrl_msg(usblp, USBLP_REQ_GET_ID, USB_TYPE_CLASS, USB_DIR_IN, USB_RECIP_INTERFACE, config, id, maxlen)\n#define usblp_reset(usblp)\\\n\tusblp_ctrl_msg(usblp, USBLP_REQ_RESET, USB_TYPE_CLASS, USB_DIR_OUT, USB_RECIP_OTHER, 0, NULL, 0)\n\nstatic int usblp_hp_channel_change_request(struct usblp *usblp, int channel, u8 *new_channel)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kzalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usblp_ctrl_msg(usblp, USBLP_REQ_HP_CHANNEL_CHANGE_REQUEST,\n\t\t\tUSB_TYPE_VENDOR, USB_DIR_IN, USB_RECIP_INTERFACE,\n\t\t\tchannel, buf, 1);\n\tif (ret == 0)\n\t\t*new_channel = buf[0];\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\n \nstatic int proto_bias = -1;\n\n \n\nstatic void usblp_bulk_read(struct urb *urb)\n{\n\tstruct usblp *usblp = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tif (usblp->present && usblp->used) {\n\t\tif (status)\n\t\t\tprintk(KERN_WARNING \"usblp%d: \"\n\t\t\t    \"nonzero read bulk status received: %d\\n\",\n\t\t\t    usblp->minor, status);\n\t}\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tif (status < 0)\n\t\tusblp->rstatus = status;\n\telse\n\t\tusblp->rstatus = urb->actual_length;\n\tusblp->rcomplete = 1;\n\twake_up(&usblp->rwait);\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\n\tusb_free_urb(urb);\n}\n\nstatic void usblp_bulk_write(struct urb *urb)\n{\n\tstruct usblp *usblp = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tif (usblp->present && usblp->used) {\n\t\tif (status)\n\t\t\tprintk(KERN_WARNING \"usblp%d: \"\n\t\t\t    \"nonzero write bulk status received: %d\\n\",\n\t\t\t    usblp->minor, status);\n\t}\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tif (status < 0)\n\t\tusblp->wstatus = status;\n\telse\n\t\tusblp->wstatus = urb->actual_length;\n\tusblp->no_paper = 0;\n\tusblp->wcomplete = 1;\n\twake_up(&usblp->wwait);\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\n\tusb_free_urb(urb);\n}\n\n \n\nstatic const char *usblp_messages[] = { \"ok\", \"out of paper\", \"off-line\", \"on fire\" };\n\nstatic int usblp_check_status(struct usblp *usblp, int err)\n{\n\tunsigned char status, newerr = 0;\n\tint error;\n\n\tmutex_lock(&usblp->mut);\n\tif ((error = usblp_read_status(usblp, usblp->statusbuf)) < 0) {\n\t\tmutex_unlock(&usblp->mut);\n\t\tprintk_ratelimited(KERN_ERR\n\t\t\t\t\"usblp%d: error %d reading printer status\\n\",\n\t\t\t\tusblp->minor, error);\n\t\treturn 0;\n\t}\n\tstatus = *usblp->statusbuf;\n\tmutex_unlock(&usblp->mut);\n\n\tif (~status & LP_PERRORP)\n\t\tnewerr = 3;\n\tif (status & LP_POUTPA)\n\t\tnewerr = 1;\n\tif (~status & LP_PSELECD)\n\t\tnewerr = 2;\n\n\tif (newerr != err) {\n\t\tprintk(KERN_INFO \"usblp%d: %s\\n\",\n\t\t   usblp->minor, usblp_messages[newerr]);\n\t}\n\n\treturn newerr;\n}\n\nstatic int handle_bidir(struct usblp *usblp)\n{\n\tif (usblp->bidir && usblp->used) {\n\t\tif (usblp_submit_read(usblp) < 0)\n\t\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int usblp_open(struct inode *inode, struct file *file)\n{\n\tint minor = iminor(inode);\n\tstruct usblp *usblp;\n\tstruct usb_interface *intf;\n\tint retval;\n\n\tif (minor < 0)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&usblp_mutex);\n\n\tretval = -ENODEV;\n\tintf = usb_find_interface(&usblp_driver, minor);\n\tif (!intf)\n\t\tgoto out;\n\tusblp = usb_get_intfdata(intf);\n\tif (!usblp || !usblp->dev || !usblp->present)\n\t\tgoto out;\n\n\tretval = -EBUSY;\n\tif (usblp->used)\n\t\tgoto out;\n\n\t \n\n\tretval = usb_autopm_get_interface(intf);\n\tif (retval < 0)\n\t\tgoto out;\n\tusblp->used = 1;\n\tfile->private_data = usblp;\n\n\tusblp->wcomplete = 1;  \n\tusblp->wstatus = 0;\n\tusblp->rcomplete = 0;\n\n\tif (handle_bidir(usblp) < 0) {\n\t\tusb_autopm_put_interface(intf);\n\t\tusblp->used = 0;\n\t\tfile->private_data = NULL;\n\t\tretval = -EIO;\n\t}\nout:\n\tmutex_unlock(&usblp_mutex);\n\treturn retval;\n}\n\nstatic void usblp_cleanup(struct usblp *usblp)\n{\n\tprintk(KERN_INFO \"usblp%d: removed\\n\", usblp->minor);\n\n\tkfree(usblp->readbuf);\n\tkfree(usblp->device_id_string);\n\tkfree(usblp->statusbuf);\n\tusb_put_intf(usblp->intf);\n\tkfree(usblp);\n}\n\nstatic void usblp_unlink_urbs(struct usblp *usblp)\n{\n\tusb_kill_anchored_urbs(&usblp->urbs);\n}\n\nstatic int usblp_release(struct inode *inode, struct file *file)\n{\n\tstruct usblp *usblp = file->private_data;\n\n\tusblp->flags &= ~LP_ABORT;\n\n\tmutex_lock(&usblp_mutex);\n\tusblp->used = 0;\n\tif (usblp->present)\n\t\tusblp_unlink_urbs(usblp);\n\n\tusb_autopm_put_interface(usblp->intf);\n\n\tif (!usblp->present)\t\t \n\t\tusblp_cleanup(usblp);\t \n\n\tmutex_unlock(&usblp_mutex);\n\treturn 0;\n}\n\n \nstatic __poll_t usblp_poll(struct file *file, struct poll_table_struct *wait)\n{\n\tstruct usblp *usblp = file->private_data;\n\t__poll_t ret = 0;\n\tunsigned long flags;\n\n\t \n\tpoll_wait(file, &usblp->rwait, wait);\n\tpoll_wait(file, &usblp->wwait, wait);\n\n\tmutex_lock(&usblp->mut);\n\tif (!usblp->present)\n\t\tret |= EPOLLHUP;\n\tmutex_unlock(&usblp->mut);\n\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tif (usblp->bidir && usblp->rcomplete)\n\t\tret |= EPOLLIN  | EPOLLRDNORM;\n\tif (usblp->no_paper || usblp->wcomplete)\n\t\tret |= EPOLLOUT | EPOLLWRNORM;\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\treturn ret;\n}\n\nstatic long usblp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct usblp *usblp = file->private_data;\n\tint length, err, i;\n\tunsigned char newChannel;\n\tint status;\n\tint twoints[2];\n\tint retval = 0;\n\n\tmutex_lock(&usblp->mut);\n\tif (!usblp->present) {\n\t\tretval = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tdev_dbg(&usblp->intf->dev,\n\t\t\"usblp_ioctl: cmd=0x%x (%c nr=%d len=%d dir=%d)\\n\", cmd,\n\t\t_IOC_TYPE(cmd), _IOC_NR(cmd), _IOC_SIZE(cmd), _IOC_DIR(cmd));\n\n\tif (_IOC_TYPE(cmd) == 'P')\t \n\n\t\tswitch (_IOC_NR(cmd)) {\n\n\t\tcase IOCNR_GET_DEVICE_ID:  \n\t\t\tif (_IOC_DIR(cmd) != _IOC_READ) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlength = usblp_cache_device_id_string(usblp);\n\t\t\tif (length < 0) {\n\t\t\t\tretval = length;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (length > _IOC_SIZE(cmd))\n\t\t\t\tlength = _IOC_SIZE(cmd);  \n\n\t\t\tif (copy_to_user((void __user *) arg,\n\t\t\t\t\tusblp->device_id_string,\n\t\t\t\t\t(unsigned long) length)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOCNR_GET_PROTOCOLS:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_READ ||\n\t\t\t    _IOC_SIZE(cmd) < sizeof(twoints)) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\ttwoints[0] = usblp->current_protocol;\n\t\t\ttwoints[1] = 0;\n\t\t\tfor (i = USBLP_FIRST_PROTOCOL;\n\t\t\t     i <= USBLP_LAST_PROTOCOL; i++) {\n\t\t\t\tif (usblp->protocol[i].alt_setting >= 0)\n\t\t\t\t\ttwoints[1] |= (1<<i);\n\t\t\t}\n\n\t\t\tif (copy_to_user((void __user *)arg,\n\t\t\t\t\t(unsigned char *)twoints,\n\t\t\t\t\tsizeof(twoints))) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase IOCNR_SET_PROTOCOL:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_WRITE) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n#ifdef DEBUG\n\t\t\tif (arg == -10) {\n\t\t\t\tusblp_dump(usblp);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\n\t\t\tusblp_unlink_urbs(usblp);\n\t\t\tretval = usblp_set_protocol(usblp, arg);\n\t\t\tif (retval < 0) {\n\t\t\t\tusblp_set_protocol(usblp,\n\t\t\t\t\tusblp->current_protocol);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IOCNR_HP_SET_CHANNEL:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_WRITE ||\n\t\t\t    le16_to_cpu(usblp->dev->descriptor.idVendor) != 0x03F0 ||\n\t\t\t    usblp->quirks & USBLP_QUIRK_BIDIR) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\terr = usblp_hp_channel_change_request(usblp,\n\t\t\t\targ, &newChannel);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&usblp->dev->dev,\n\t\t\t\t\t\"usblp%d: error = %d setting \"\n\t\t\t\t\t\"HP channel\\n\",\n\t\t\t\t\tusblp->minor, err);\n\t\t\t\tretval = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tdev_dbg(&usblp->intf->dev,\n\t\t\t\t\"usblp%d requested/got HP channel %ld/%d\\n\",\n\t\t\t\tusblp->minor, arg, newChannel);\n\t\t\tbreak;\n\n\t\tcase IOCNR_GET_BUS_ADDRESS:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_READ ||\n\t\t\t    _IOC_SIZE(cmd) < sizeof(twoints)) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\ttwoints[0] = usblp->dev->bus->busnum;\n\t\t\ttwoints[1] = usblp->dev->devnum;\n\t\t\tif (copy_to_user((void __user *)arg,\n\t\t\t\t\t(unsigned char *)twoints,\n\t\t\t\t\tsizeof(twoints))) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tdev_dbg(&usblp->intf->dev,\n\t\t\t\t\"usblp%d is bus=%d, device=%d\\n\",\n\t\t\t\tusblp->minor, twoints[0], twoints[1]);\n\t\t\tbreak;\n\n\t\tcase IOCNR_GET_VID_PID:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_READ ||\n\t\t\t    _IOC_SIZE(cmd) < sizeof(twoints)) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\ttwoints[0] = le16_to_cpu(usblp->dev->descriptor.idVendor);\n\t\t\ttwoints[1] = le16_to_cpu(usblp->dev->descriptor.idProduct);\n\t\t\tif (copy_to_user((void __user *)arg,\n\t\t\t\t\t(unsigned char *)twoints,\n\t\t\t\t\tsizeof(twoints))) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tdev_dbg(&usblp->intf->dev,\n\t\t\t\t\"usblp%d is VID=0x%4.4X, PID=0x%4.4X\\n\",\n\t\t\t\tusblp->minor, twoints[0], twoints[1]);\n\t\t\tbreak;\n\n\t\tcase IOCNR_SOFT_RESET:\n\t\t\tif (_IOC_DIR(cmd) != _IOC_NONE) {\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tretval = usblp_reset(usblp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tretval = -ENOTTY;\n\t\t}\n\telse\t \n\t\tswitch (cmd) {\n\n\t\tcase LPGETSTATUS:\n\t\t\tretval = usblp_read_status(usblp, usblp->statusbuf);\n\t\t\tif (retval) {\n\t\t\t\tprintk_ratelimited(KERN_ERR \"usblp%d:\"\n\t\t\t\t\t    \"failed reading printer status (%d)\\n\",\n\t\t\t\t\t    usblp->minor, retval);\n\t\t\t\tretval = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tstatus = *usblp->statusbuf;\n\t\t\tif (copy_to_user((void __user *)arg, &status, sizeof(int)))\n\t\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\n\t\tcase LPABORT:\n\t\t\tif (arg)\n\t\t\t\tusblp->flags |= LP_ABORT;\n\t\t\telse\n\t\t\t\tusblp->flags &= ~LP_ABORT;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tretval = -ENOTTY;\n\t\t}\n\ndone:\n\tmutex_unlock(&usblp->mut);\n\treturn retval;\n}\n\nstatic struct urb *usblp_new_writeurb(struct usblp *usblp, int transfer_length)\n{\n\tstruct urb *urb;\n\tchar *writebuf;\n\n\twritebuf = kmalloc(transfer_length, GFP_KERNEL);\n\tif (writebuf == NULL)\n\t\treturn NULL;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (urb == NULL) {\n\t\tkfree(writebuf);\n\t\treturn NULL;\n\t}\n\n\tusb_fill_bulk_urb(urb, usblp->dev,\n\t\tusb_sndbulkpipe(usblp->dev,\n\t\t usblp->protocol[usblp->current_protocol].epwrite->bEndpointAddress),\n\t\twritebuf, transfer_length, usblp_bulk_write, usblp);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\treturn urb;\n}\n\nstatic ssize_t usblp_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct usblp *usblp = file->private_data;\n\tstruct urb *writeurb;\n\tint rv;\n\tint transfer_length;\n\tssize_t writecount = 0;\n\n\tif (mutex_lock_interruptible(&usblp->wmut)) {\n\t\trv = -EINTR;\n\t\tgoto raise_biglock;\n\t}\n\tif ((rv = usblp_wwait(usblp, !!(file->f_flags & O_NONBLOCK))) < 0)\n\t\tgoto raise_wait;\n\n\twhile (writecount < count) {\n\t\t \n\t\tif ((transfer_length = count - writecount) > USBLP_BUF_SIZE)\n\t\t\ttransfer_length = USBLP_BUF_SIZE;\n\n\t\trv = -ENOMEM;\n\t\twriteurb = usblp_new_writeurb(usblp, transfer_length);\n\t\tif (writeurb == NULL)\n\t\t\tgoto raise_urb;\n\t\tusb_anchor_urb(writeurb, &usblp->urbs);\n\n\t\tif (copy_from_user(writeurb->transfer_buffer,\n\t\t\t\t   buffer + writecount, transfer_length)) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto raise_badaddr;\n\t\t}\n\n\t\tspin_lock_irq(&usblp->lock);\n\t\tusblp->wcomplete = 0;\n\t\tspin_unlock_irq(&usblp->lock);\n\t\tif ((rv = usb_submit_urb(writeurb, GFP_KERNEL)) < 0) {\n\t\t\tusblp->wstatus = 0;\n\t\t\tspin_lock_irq(&usblp->lock);\n\t\t\tusblp->no_paper = 0;\n\t\t\tusblp->wcomplete = 1;\n\t\t\twake_up(&usblp->wwait);\n\t\t\tspin_unlock_irq(&usblp->lock);\n\t\t\tif (rv != -ENOMEM)\n\t\t\t\trv = -EIO;\n\t\t\tgoto raise_submit;\n\t\t}\n\n\t\t \n\t\trv = usblp_wwait(usblp, !!(file->f_flags&O_NONBLOCK));\n\t\tif (rv < 0) {\n\t\t\tif (rv == -EAGAIN) {\n\t\t\t\t \n\t\t\t\twritecount += transfer_length;\n\t\t\t}\n\t\t\tif (rv == -ENOSPC) {\n\t\t\t\tspin_lock_irq(&usblp->lock);\n\t\t\t\tusblp->no_paper = 1;\t \n\t\t\t\tspin_unlock_irq(&usblp->lock);\n\t\t\t\twritecount += transfer_length;\n\t\t\t}\n\t\t\t \n\t\t\tgoto collect_error;\n\t\t}\n\n\t\tif (usblp->wstatus < 0) {\n\t\t\trv = -EIO;\n\t\t\tgoto collect_error;\n\t\t}\n\t\t \n\t\twritecount += usblp->wstatus;\n\t}\n\n\tmutex_unlock(&usblp->wmut);\n\treturn writecount;\n\nraise_submit:\nraise_badaddr:\n\tusb_unanchor_urb(writeurb);\n\tusb_free_urb(writeurb);\nraise_urb:\nraise_wait:\ncollect_error:\t\t \n\tmutex_unlock(&usblp->wmut);\nraise_biglock:\n\treturn writecount ? writecount : rv;\n}\n\n \nstatic ssize_t usblp_read(struct file *file, char __user *buffer, size_t len, loff_t *ppos)\n{\n\tstruct usblp *usblp = file->private_data;\n\tssize_t count;\n\tssize_t avail;\n\tint rv;\n\n\tif (!usblp->bidir)\n\t\treturn -EINVAL;\n\n\trv = usblp_rwait_and_lock(usblp, !!(file->f_flags & O_NONBLOCK));\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (!usblp->present) {\n\t\tcount = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif ((avail = usblp->rstatus) < 0) {\n\t\tprintk(KERN_ERR \"usblp%d: error %d reading from printer\\n\",\n\t\t    usblp->minor, (int)avail);\n\t\tusblp_submit_read(usblp);\n\t\tcount = -EIO;\n\t\tgoto done;\n\t}\n\n\tcount = len < avail - usblp->readcount ? len : avail - usblp->readcount;\n\tif (count != 0 &&\n\t    copy_to_user(buffer, usblp->readbuf + usblp->readcount, count)) {\n\t\tcount = -EFAULT;\n\t\tgoto done;\n\t}\n\n\tif ((usblp->readcount += count) == avail) {\n\t\tif (usblp_submit_read(usblp) < 0) {\n\t\t\t \n\t\t\tif (count == 0)\n\t\t\t\tcount = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&usblp->mut);\n\treturn count;\n}\n\n \nstatic int usblp_wwait(struct usblp *usblp, int nonblock)\n{\n\tDECLARE_WAITQUEUE(waita, current);\n\tint rc;\n\tint err = 0;\n\n\tadd_wait_queue(&usblp->wwait, &waita);\n\tfor (;;) {\n\t\tif (mutex_lock_interruptible(&usblp->mut)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\trc = usblp_wtest(usblp, nonblock);\n\t\tmutex_unlock(&usblp->mut);\n\t\tif (rc <= 0)\n\t\t\tbreak;\n\n\t\tif (schedule_timeout(msecs_to_jiffies(1500)) == 0) {\n\t\t\tif (usblp->flags & LP_ABORT) {\n\t\t\t\terr = usblp_check_status(usblp, err);\n\t\t\t\tif (err == 1) {\t \n\t\t\t\t\trc = -ENOSPC;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmutex_lock(&usblp->mut);\n\t\t\t\tusblp_read_status(usblp, usblp->statusbuf);\n\t\t\t\tmutex_unlock(&usblp->mut);\n\t\t\t}\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&usblp->wwait, &waita);\n\treturn rc;\n}\n\nstatic int usblp_wtest(struct usblp *usblp, int nonblock)\n{\n\tunsigned long flags;\n\n\tif (!usblp->present)\n\t\treturn -ENODEV;\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tif (usblp->wcomplete) {\n\t\tspin_unlock_irqrestore(&usblp->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\tif (nonblock)\n\t\treturn -EAGAIN;\n\treturn 1;\n}\n\n \nstatic int usblp_rwait_and_lock(struct usblp *usblp, int nonblock)\n{\n\tDECLARE_WAITQUEUE(waita, current);\n\tint rc;\n\n\tadd_wait_queue(&usblp->rwait, &waita);\n\tfor (;;) {\n\t\tif (mutex_lock_interruptible(&usblp->mut)) {\n\t\t\trc = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif ((rc = usblp_rtest(usblp, nonblock)) < 0) {\n\t\t\tmutex_unlock(&usblp->mut);\n\t\t\tbreak;\n\t\t}\n\t\tif (rc == 0)\t \n\t\t\tbreak;\n\t\tmutex_unlock(&usblp->mut);\n\t\tschedule();\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&usblp->rwait, &waita);\n\treturn rc;\n}\n\nstatic int usblp_rtest(struct usblp *usblp, int nonblock)\n{\n\tunsigned long flags;\n\n\tif (!usblp->present)\n\t\treturn -ENODEV;\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tif (usblp->rcomplete) {\n\t\tspin_unlock_irqrestore(&usblp->lock, flags);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\tif (nonblock)\n\t\treturn -EAGAIN;\n\treturn 1;\n}\n\n \nstatic int usblp_submit_read(struct usblp *usblp)\n{\n\tstruct urb *urb;\n\tunsigned long flags;\n\tint rc;\n\n\trc = -ENOMEM;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (urb == NULL)\n\t\tgoto raise_urb;\n\n\tusb_fill_bulk_urb(urb, usblp->dev,\n\t\tusb_rcvbulkpipe(usblp->dev,\n\t\t  usblp->protocol[usblp->current_protocol].epread->bEndpointAddress),\n\t\tusblp->readbuf, USBLP_BUF_SIZE_IN,\n\t\tusblp_bulk_read, usblp);\n\tusb_anchor_urb(urb, &usblp->urbs);\n\n\tspin_lock_irqsave(&usblp->lock, flags);\n\tusblp->readcount = 0;  \n\tusblp->rcomplete = 0;\n\tspin_unlock_irqrestore(&usblp->lock, flags);\n\tif ((rc = usb_submit_urb(urb, GFP_KERNEL)) < 0) {\n\t\tdev_dbg(&usblp->intf->dev, \"error submitting urb (%d)\\n\", rc);\n\t\tspin_lock_irqsave(&usblp->lock, flags);\n\t\tusblp->rstatus = rc;\n\t\tusblp->rcomplete = 1;\n\t\tspin_unlock_irqrestore(&usblp->lock, flags);\n\t\tgoto raise_submit;\n\t}\n\n\treturn 0;\n\nraise_submit:\n\tusb_unanchor_urb(urb);\n\tusb_free_urb(urb);\nraise_urb:\n\treturn rc;\n}\n\n \nstatic unsigned int usblp_quirks(__u16 vendor, __u16 product)\n{\n\tint i;\n\n\tfor (i = 0; quirk_printers[i].vendorId; i++) {\n\t\tif (vendor == quirk_printers[i].vendorId &&\n\t\t    product == quirk_printers[i].productId)\n\t\t\treturn quirk_printers[i].quirks;\n\t}\n\treturn 0;\n}\n\nstatic const struct file_operations usblp_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tusblp_read,\n\t.write =\tusblp_write,\n\t.poll =\t\tusblp_poll,\n\t.unlocked_ioctl =\tusblp_ioctl,\n\t.compat_ioctl =\t\tusblp_ioctl,\n\t.open =\t\tusblp_open,\n\t.release =\tusblp_release,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic char *usblp_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\nstatic struct usb_class_driver usblp_class = {\n\t.name =\t\t\"lp%d\",\n\t.devnode =\tusblp_devnode,\n\t.fops =\t\t&usblp_fops,\n\t.minor_base =\tUSBLP_MINOR_BASE,\n};\n\nstatic ssize_t ieee1284_id_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usblp *usblp = usb_get_intfdata(intf);\n\n\tif (usblp->device_id_string[0] == 0 &&\n\t    usblp->device_id_string[1] == 0)\n\t\treturn 0;\n\n\treturn sprintf(buf, \"%s\", usblp->device_id_string+2);\n}\n\nstatic DEVICE_ATTR_RO(ieee1284_id);\n\nstatic struct attribute *usblp_attrs[] = {\n\t&dev_attr_ieee1284_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(usblp);\n\nstatic int usblp_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usblp *usblp;\n\tint protocol;\n\tint retval;\n\n\t \n\tusblp = kzalloc(sizeof(struct usblp), GFP_KERNEL);\n\tif (!usblp) {\n\t\tretval = -ENOMEM;\n\t\tgoto abort_ret;\n\t}\n\tusblp->dev = dev;\n\tmutex_init(&usblp->wmut);\n\tmutex_init(&usblp->mut);\n\tspin_lock_init(&usblp->lock);\n\tinit_waitqueue_head(&usblp->rwait);\n\tinit_waitqueue_head(&usblp->wwait);\n\tinit_usb_anchor(&usblp->urbs);\n\tusblp->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tusblp->intf = usb_get_intf(intf);\n\n\t \n\tif (!(usblp->device_id_string = kmalloc(USBLP_DEVICE_ID_SIZE, GFP_KERNEL))) {\n\t\tretval = -ENOMEM;\n\t\tgoto abort;\n\t}\n\n\t \n\tif (!(usblp->readbuf = kmalloc(USBLP_BUF_SIZE_IN, GFP_KERNEL))) {\n\t\tretval = -ENOMEM;\n\t\tgoto abort;\n\t}\n\n\t \n\tusblp->statusbuf = kmalloc(STATUS_BUF_SIZE, GFP_KERNEL);\n\tif (!usblp->statusbuf) {\n\t\tretval = -ENOMEM;\n\t\tgoto abort;\n\t}\n\n\t \n\tusblp->quirks = usblp_quirks(\n\t\tle16_to_cpu(dev->descriptor.idVendor),\n\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\t \n\tprotocol = usblp_select_alts(usblp);\n\tif (protocol < 0) {\n\t\tdev_dbg(&intf->dev,\n\t\t\t\"incompatible printer-class device 0x%4.4X/0x%4.4X\\n\",\n\t\t\tle16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\t\tretval = -ENODEV;\n\t\tgoto abort;\n\t}\n\n\t \n\tif (usblp_set_protocol(usblp, protocol) < 0) {\n\t\tretval = -ENODEV;\t \n\t\tgoto abort;\n\t}\n\n\t \n\tusblp_cache_device_id_string(usblp);\n\n#ifdef DEBUG\n\tusblp_check_status(usblp, 0);\n#endif\n\n\tusb_set_intfdata(intf, usblp);\n\n\tusblp->present = 1;\n\n\tretval = usb_register_dev(intf, &usblp_class);\n\tif (retval) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"usblp: Not able to get a minor (base %u, slice default): %d\\n\",\n\t\t\tUSBLP_MINOR_BASE, retval);\n\t\tgoto abort_intfdata;\n\t}\n\tusblp->minor = intf->minor;\n\tdev_info(&intf->dev,\n\t\t\"usblp%d: USB %sdirectional printer dev %d if %d alt %d proto %d vid 0x%4.4X pid 0x%4.4X\\n\",\n\t\tusblp->minor, usblp->bidir ? \"Bi\" : \"Uni\", dev->devnum,\n\t\tusblp->ifnum,\n\t\tusblp->protocol[usblp->current_protocol].alt_setting,\n\t\tusblp->current_protocol,\n\t\tle16_to_cpu(usblp->dev->descriptor.idVendor),\n\t\tle16_to_cpu(usblp->dev->descriptor.idProduct));\n\n\treturn 0;\n\nabort_intfdata:\n\tusb_set_intfdata(intf, NULL);\nabort:\n\tkfree(usblp->readbuf);\n\tkfree(usblp->statusbuf);\n\tkfree(usblp->device_id_string);\n\tusb_put_intf(usblp->intf);\n\tkfree(usblp);\nabort_ret:\n\treturn retval;\n}\n\n \nstatic int usblp_select_alts(struct usblp *usblp)\n{\n\tstruct usb_interface *if_alt;\n\tstruct usb_host_interface *ifd;\n\tstruct usb_endpoint_descriptor *epwrite, *epread;\n\tint p, i;\n\tint res;\n\n\tif_alt = usblp->intf;\n\n\tfor (p = 0; p < USBLP_MAX_PROTOCOLS; p++)\n\t\tusblp->protocol[p].alt_setting = -1;\n\n\t \n\tfor (i = 0; i < if_alt->num_altsetting; i++) {\n\t\tifd = &if_alt->altsetting[i];\n\n\t\tif (ifd->desc.bInterfaceClass != USB_CLASS_PRINTER ||\n\t\t    ifd->desc.bInterfaceSubClass != 1)\n\t\t\tif (!(usblp->quirks & USBLP_QUIRK_BAD_CLASS))\n\t\t\t\tcontinue;\n\n\t\tif (ifd->desc.bInterfaceProtocol < USBLP_FIRST_PROTOCOL ||\n\t\t    ifd->desc.bInterfaceProtocol > USBLP_LAST_PROTOCOL)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (ifd->desc.bInterfaceProtocol > 1) {\n\t\t\tres = usb_find_common_endpoints(ifd,\n\t\t\t\t\t&epread, &epwrite, NULL, NULL);\n\t\t} else {\n\t\t\tepread = NULL;\n\t\t\tres = usb_find_bulk_out_endpoint(ifd, &epwrite);\n\t\t}\n\n\t\t \n\t\tif (res)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (usblp->quirks & USBLP_QUIRK_BIDIR) {\n\t\t\tprintk(KERN_INFO \"usblp%d: Disabling reads from \"\n\t\t\t    \"problematic bidirectional printer\\n\",\n\t\t\t    usblp->minor);\n\t\t\tepread = NULL;\n\t\t}\n\n\t\tusblp->protocol[ifd->desc.bInterfaceProtocol].alt_setting =\n\t\t\t\tifd->desc.bAlternateSetting;\n\t\tusblp->protocol[ifd->desc.bInterfaceProtocol].epwrite = epwrite;\n\t\tusblp->protocol[ifd->desc.bInterfaceProtocol].epread = epread;\n\t}\n\n\t \n\tif (proto_bias >= USBLP_FIRST_PROTOCOL &&\n\t    proto_bias <= USBLP_LAST_PROTOCOL &&\n\t    usblp->protocol[proto_bias].alt_setting != -1)\n\t\treturn proto_bias;\n\n\t \n\tif (usblp->protocol[2].alt_setting != -1)\n\t\treturn 2;\n\tif (usblp->protocol[1].alt_setting != -1)\n\t\treturn 1;\n\tif (usblp->protocol[3].alt_setting != -1)\n\t\treturn 3;\n\n\t \n\treturn -1;\n}\n\nstatic int usblp_set_protocol(struct usblp *usblp, int protocol)\n{\n\tint r, alts;\n\n\tif (protocol < USBLP_FIRST_PROTOCOL || protocol > USBLP_LAST_PROTOCOL)\n\t\treturn -EINVAL;\n\n\t \n\tif (usblp->intf->num_altsetting > 1) {\n\t\talts = usblp->protocol[protocol].alt_setting;\n\t\tif (alts < 0)\n\t\t\treturn -EINVAL;\n\t\tr = usb_set_interface(usblp->dev, usblp->ifnum, alts);\n\t\tif (r < 0) {\n\t\t\tprintk(KERN_ERR \"usblp: can't set desired altsetting %d on interface %d\\n\",\n\t\t\t\talts, usblp->ifnum);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tusblp->bidir = (usblp->protocol[protocol].epread != NULL);\n\tusblp->current_protocol = protocol;\n\tdev_dbg(&usblp->intf->dev, \"usblp%d set protocol %d\\n\",\n\t\tusblp->minor, protocol);\n\treturn 0;\n}\n\n \nstatic int usblp_cache_device_id_string(struct usblp *usblp)\n{\n\tint err, length;\n\n\terr = usblp_get_id(usblp, 0, usblp->device_id_string, USBLP_DEVICE_ID_SIZE - 1);\n\tif (err < 0) {\n\t\tdev_dbg(&usblp->intf->dev,\n\t\t\t\"usblp%d: error = %d reading IEEE-1284 Device ID string\\n\",\n\t\t\tusblp->minor, err);\n\t\tusblp->device_id_string[0] = usblp->device_id_string[1] = '\\0';\n\t\treturn -EIO;\n\t}\n\n\t \n\tlength = be16_to_cpu(*((__be16 *)usblp->device_id_string));\n\tif (length < 2)\n\t\tlength = 2;\n\telse if (length >= USBLP_DEVICE_ID_SIZE)\n\t\tlength = USBLP_DEVICE_ID_SIZE - 1;\n\tusblp->device_id_string[length] = '\\0';\n\n\tdev_dbg(&usblp->intf->dev, \"usblp%d Device ID string [len=%d]=\\\"%s\\\"\\n\",\n\t\tusblp->minor, length, &usblp->device_id_string[2]);\n\n\treturn length;\n}\n\nstatic void usblp_disconnect(struct usb_interface *intf)\n{\n\tstruct usblp *usblp = usb_get_intfdata(intf);\n\n\tusb_deregister_dev(intf, &usblp_class);\n\n\tif (!usblp || !usblp->dev) {\n\t\tdev_err(&intf->dev, \"bogus disconnect\\n\");\n\t\tBUG();\n\t}\n\n\tmutex_lock(&usblp_mutex);\n\tmutex_lock(&usblp->mut);\n\tusblp->present = 0;\n\twake_up(&usblp->wwait);\n\twake_up(&usblp->rwait);\n\tusb_set_intfdata(intf, NULL);\n\n\tusblp_unlink_urbs(usblp);\n\tmutex_unlock(&usblp->mut);\n\tusb_poison_anchored_urbs(&usblp->urbs);\n\n\tif (!usblp->used)\n\t\tusblp_cleanup(usblp);\n\n\tmutex_unlock(&usblp_mutex);\n}\n\nstatic int usblp_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usblp *usblp = usb_get_intfdata(intf);\n\n\tusblp_unlink_urbs(usblp);\n#if 0  \n\t \n\twake_up(&usblp->wwait);\n\twake_up(&usblp->rwait);\n#endif\n\n\treturn 0;\n}\n\nstatic int usblp_resume(struct usb_interface *intf)\n{\n\tstruct usblp *usblp = usb_get_intfdata(intf);\n\tint r;\n\n\tr = handle_bidir(usblp);\n\n\treturn r;\n}\n\nstatic const struct usb_device_id usblp_ids[] = {\n\t{ USB_DEVICE_INFO(USB_CLASS_PRINTER, 1, 1) },\n\t{ USB_DEVICE_INFO(USB_CLASS_PRINTER, 1, 2) },\n\t{ USB_DEVICE_INFO(USB_CLASS_PRINTER, 1, 3) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_PRINTER, 1, 1) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_PRINTER, 1, 2) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_PRINTER, 1, 3) },\n\t{ USB_DEVICE(0x04b8, 0x0202) },\t \n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, usblp_ids);\n\nstatic struct usb_driver usblp_driver = {\n\t.name =\t\t\"usblp\",\n\t.probe =\tusblp_probe,\n\t.disconnect =\tusblp_disconnect,\n\t.suspend =\tusblp_suspend,\n\t.resume =\tusblp_resume,\n\t.id_table =\tusblp_ids,\n\t.dev_groups =\tusblp_groups,\n\t.supports_autosuspend =\t1,\n};\n\nmodule_usb_driver(usblp_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nmodule_param(proto_bias, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(proto_bias, \"Favourite protocol number\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}