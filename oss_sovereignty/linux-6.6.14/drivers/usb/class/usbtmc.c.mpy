{
  "module_name": "usbtmc.c",
  "hash_id": "2d9df47cde53c6491deff86af59c8d3fc16753e8bbae867acd2fe958a3152615",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/class/usbtmc.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/kref.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/mutex.h>\n#include <linux/usb.h>\n#include <linux/compat.h>\n#include <linux/usb/tmc.h>\n\n \n#define USBTMC_API_VERSION (3)\n\n#define USBTMC_HEADER_SIZE\t12\n#define USBTMC_MINOR_BASE\t176\n\n \n#define USBTMC_MIN_TIMEOUT\t100\n \n#define USBTMC_TIMEOUT\t\t5000\n\n \n#define MAX_URBS_IN_FLIGHT\t16\n \n#define USBTMC_BUFSIZE\t\t(4096)\n\n \n#define USBTMC_MAX_READS_TO_CLEAR_BULK_IN\t100\n\nstatic const struct usb_device_id usbtmc_devices[] = {\n\t{ USB_INTERFACE_INFO(USB_CLASS_APP_SPEC, 3, 0), },\n\t{ USB_INTERFACE_INFO(USB_CLASS_APP_SPEC, 3, 1), },\n\t{ 0, }  \n};\nMODULE_DEVICE_TABLE(usb, usbtmc_devices);\n\n \nstruct usbtmc_dev_capabilities {\n\t__u8 interface_capabilities;\n\t__u8 device_capabilities;\n\t__u8 usb488_interface_capabilities;\n\t__u8 usb488_device_capabilities;\n};\n\n \nstruct usbtmc_device_data {\n\tconst struct usb_device_id *id;\n\tstruct usb_device *usb_dev;\n\tstruct usb_interface *intf;\n\tstruct list_head file_list;\n\n\tunsigned int bulk_in;\n\tunsigned int bulk_out;\n\n\tu8 bTag;\n\tu8 bTag_last_write;\t \n\tu8 bTag_last_read;\t \n\n\t \n\tu16            wMaxPacketSize;\n\n\t \n\tu8             bNotify1;\n\tu8             bNotify2;\n\tu16            ifnum;\n\tu8             iin_bTag;\n\tu8            *iin_buffer;\n\tatomic_t       iin_data_valid;\n\tunsigned int   iin_ep;\n\tint            iin_ep_present;\n\tint            iin_interval;\n\tstruct urb    *iin_urb;\n\tu16            iin_wMaxPacketSize;\n\n\t \n\t__u8 usb488_caps;\n\n\tbool zombie;  \n\n\tstruct usbtmc_dev_capabilities\tcapabilities;\n\tstruct kref kref;\n\tstruct mutex io_mutex;\t \n\twait_queue_head_t waitq;\n\tstruct fasync_struct *fasync;\n\tspinlock_t dev_lock;  \n};\n#define to_usbtmc_data(d) container_of(d, struct usbtmc_device_data, kref)\n\n \nstruct usbtmc_file_data {\n\tstruct usbtmc_device_data *data;\n\tstruct list_head file_elem;\n\n\tu32            timeout;\n\tu8             srq_byte;\n\tatomic_t       srq_asserted;\n\tatomic_t       closing;\n\tu8             bmTransferAttributes;  \n\n\tu8             eom_val;\n\tu8             term_char;\n\tbool           term_char_enabled;\n\tbool           auto_abort;\n\n\tspinlock_t     err_lock;  \n\n\tstruct usb_anchor submitted;\n\n\t \n\tstruct semaphore limit_write_sem;\n\tu32 out_transfer_size;\n\tint out_status;\n\n\t \n\tu32 in_transfer_size;\n\tint in_status;\n\tint in_urbs_used;\n\tstruct usb_anchor in_anchor;\n\twait_queue_head_t wait_bulk_in;\n};\n\n \nstatic struct usb_driver usbtmc_driver;\nstatic void usbtmc_draw_down(struct usbtmc_file_data *file_data);\n\nstatic void usbtmc_delete(struct kref *kref)\n{\n\tstruct usbtmc_device_data *data = to_usbtmc_data(kref);\n\n\tusb_put_dev(data->usb_dev);\n\tkfree(data);\n}\n\nstatic int usbtmc_open(struct inode *inode, struct file *filp)\n{\n\tstruct usb_interface *intf;\n\tstruct usbtmc_device_data *data;\n\tstruct usbtmc_file_data *file_data;\n\n\tintf = usb_find_interface(&usbtmc_driver, iminor(inode));\n\tif (!intf) {\n\t\tpr_err(\"can not find device for minor %d\", iminor(inode));\n\t\treturn -ENODEV;\n\t}\n\n\tfile_data = kzalloc(sizeof(*file_data), GFP_KERNEL);\n\tif (!file_data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&file_data->err_lock);\n\tsema_init(&file_data->limit_write_sem, MAX_URBS_IN_FLIGHT);\n\tinit_usb_anchor(&file_data->submitted);\n\tinit_usb_anchor(&file_data->in_anchor);\n\tinit_waitqueue_head(&file_data->wait_bulk_in);\n\n\tdata = usb_get_intfdata(intf);\n\t \n\tkref_get(&data->kref);\n\n\tmutex_lock(&data->io_mutex);\n\tfile_data->data = data;\n\n\tatomic_set(&file_data->closing, 0);\n\n\tfile_data->timeout = USBTMC_TIMEOUT;\n\tfile_data->term_char = '\\n';\n\tfile_data->term_char_enabled = 0;\n\tfile_data->auto_abort = 0;\n\tfile_data->eom_val = 1;\n\n\tINIT_LIST_HEAD(&file_data->file_elem);\n\tspin_lock_irq(&data->dev_lock);\n\tlist_add_tail(&file_data->file_elem, &data->file_list);\n\tspin_unlock_irq(&data->dev_lock);\n\tmutex_unlock(&data->io_mutex);\n\n\t \n\tfilp->private_data = file_data;\n\n\treturn 0;\n}\n\n \nstatic int usbtmc_flush(struct file *file, fl_owner_t id)\n{\n\tstruct usbtmc_file_data *file_data;\n\tstruct usbtmc_device_data *data;\n\n\tfile_data = file->private_data;\n\tif (file_data == NULL)\n\t\treturn -ENODEV;\n\n\tatomic_set(&file_data->closing, 1);\n\tdata = file_data->data;\n\n\t \n\tmutex_lock(&data->io_mutex);\n\n\tusbtmc_draw_down(file_data);\n\n\tspin_lock_irq(&file_data->err_lock);\n\tfile_data->in_status = 0;\n\tfile_data->in_transfer_size = 0;\n\tfile_data->in_urbs_used = 0;\n\tfile_data->out_status = 0;\n\tfile_data->out_transfer_size = 0;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\twake_up_interruptible_all(&data->waitq);\n\tmutex_unlock(&data->io_mutex);\n\n\treturn 0;\n}\n\nstatic int usbtmc_release(struct inode *inode, struct file *file)\n{\n\tstruct usbtmc_file_data *file_data = file->private_data;\n\n\t \n\tmutex_lock(&file_data->data->io_mutex);\n\tspin_lock_irq(&file_data->data->dev_lock);\n\n\tlist_del(&file_data->file_elem);\n\n\tspin_unlock_irq(&file_data->data->dev_lock);\n\tmutex_unlock(&file_data->data->io_mutex);\n\n\tkref_put(&file_data->data->kref, usbtmc_delete);\n\tfile_data->data = NULL;\n\tkfree(file_data);\n\treturn 0;\n}\n\nstatic int usbtmc_ioctl_abort_bulk_in_tag(struct usbtmc_device_data *data,\n\t\t\t\t\t  u8 tag)\n{\n\tu8 *buffer;\n\tstruct device *dev;\n\tint rv;\n\tint n;\n\tint actual;\n\n\tdev = &data->intf->dev;\n\tbuffer = kmalloc(USBTMC_BUFSIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_INITIATE_ABORT_BULK_IN,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t     tag, data->bulk_in,\n\t\t\t     buffer, 2, USB_CTRL_GET_TIMEOUT);\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"INITIATE_ABORT_BULK_IN returned %x with tag %02x\\n\",\n\t\tbuffer[0], buffer[1]);\n\n\tif (buffer[0] == USBTMC_STATUS_FAILED) {\n\t\t \n\t\trv = 0;\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] == USBTMC_STATUS_TRANSFER_NOT_IN_PROGRESS) {\n\t\t \n\t\trv = -ENOMSG;\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"INITIATE_ABORT_BULK_IN returned %x\\n\",\n\t\t\tbuffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tn = 0;\n\nusbtmc_abort_bulk_in_status:\n\tdev_dbg(dev, \"Reading from bulk in EP\\n\");\n\n\t \n\tactual = 0;\n\trv = usb_bulk_msg(data->usb_dev,\n\t\t\t  usb_rcvbulkpipe(data->usb_dev,\n\t\t\t\t\t  data->bulk_in),\n\t\t\t  buffer, USBTMC_BUFSIZE,\n\t\t\t  &actual, 300);\n\n\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t     buffer, actual, true);\n\n\tn++;\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_bulk_msg returned %d\\n\", rv);\n\t\tif (rv != -ETIMEDOUT)\n\t\t\tgoto exit;\n\t}\n\n\tif (actual == USBTMC_BUFSIZE)\n\t\tgoto usbtmc_abort_bulk_in_status;\n\n\tif (n >= USBTMC_MAX_READS_TO_CLEAR_BULK_IN) {\n\t\tdev_err(dev, \"Couldn't clear device buffer within %d cycles\\n\",\n\t\t\tUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_CHECK_ABORT_BULK_IN_STATUS,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t     0, data->bulk_in, buffer, 0x08,\n\t\t\t     USB_CTRL_GET_TIMEOUT);\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"CHECK_ABORT_BULK_IN returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] == USBTMC_STATUS_SUCCESS) {\n\t\trv = 0;\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != USBTMC_STATUS_PENDING) {\n\t\tdev_err(dev, \"CHECK_ABORT_BULK_IN returned %x\\n\", buffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif ((buffer[1] & 1) > 0) {\n\t\t \n\t\tgoto usbtmc_abort_bulk_in_status;\n\t}\n\n\t \n\trv = -EAGAIN;\nexit:\n\tkfree(buffer);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_abort_bulk_in(struct usbtmc_device_data *data)\n{\n\treturn usbtmc_ioctl_abort_bulk_in_tag(data, data->bTag_last_read);\n}\n\nstatic int usbtmc_ioctl_abort_bulk_out_tag(struct usbtmc_device_data *data,\n\t\t\t\t\t   u8 tag)\n{\n\tstruct device *dev;\n\tu8 *buffer;\n\tint rv;\n\tint n;\n\n\tdev = &data->intf->dev;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_INITIATE_ABORT_BULK_OUT,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t     tag, data->bulk_out,\n\t\t\t     buffer, 2, USB_CTRL_GET_TIMEOUT);\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"INITIATE_ABORT_BULK_OUT returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"INITIATE_ABORT_BULK_OUT returned %x\\n\",\n\t\t\tbuffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tn = 0;\n\nusbtmc_abort_bulk_out_check_status:\n\t \n\tmsleep(50);\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_CHECK_ABORT_BULK_OUT_STATUS,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT,\n\t\t\t     0, data->bulk_out, buffer, 0x08,\n\t\t\t     USB_CTRL_GET_TIMEOUT);\n\tn++;\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"CHECK_ABORT_BULK_OUT returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] == USBTMC_STATUS_SUCCESS)\n\t\tgoto usbtmc_abort_bulk_out_clear_halt;\n\n\tif ((buffer[0] == USBTMC_STATUS_PENDING) &&\n\t    (n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN))\n\t\tgoto usbtmc_abort_bulk_out_check_status;\n\n\trv = -EPERM;\n\tgoto exit;\n\nusbtmc_abort_bulk_out_clear_halt:\n\trv = usb_clear_halt(data->usb_dev,\n\t\t\t    usb_sndbulkpipe(data->usb_dev, data->bulk_out));\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\trv = 0;\n\nexit:\n\tkfree(buffer);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_abort_bulk_out(struct usbtmc_device_data *data)\n{\n\treturn usbtmc_ioctl_abort_bulk_out_tag(data, data->bTag_last_write);\n}\n\nstatic int usbtmc_get_stb(struct usbtmc_file_data *file_data, __u8 *stb)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tstruct device *dev = &data->intf->dev;\n\tu8 *buffer;\n\tu8 tag;\n\tint rv;\n\n\tdev_dbg(dev, \"Enter ioctl_read_stb iin_ep_present: %d\\n\",\n\t\tdata->iin_ep_present);\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&data->iin_data_valid, 0);\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\tusb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\tUSBTMC488_REQUEST_READ_STATUS_BYTE,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\tdata->iin_bTag,\n\t\t\tdata->ifnum,\n\t\t\tbuffer, 0x03, USB_CTRL_GET_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, \"stb usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"control status returned %x\\n\", buffer[0]);\n\t\trv = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (data->iin_ep_present) {\n\t\trv = wait_event_interruptible_timeout(\n\t\t\tdata->waitq,\n\t\t\tatomic_read(&data->iin_data_valid) != 0,\n\t\t\tfile_data->timeout);\n\t\tif (rv < 0) {\n\t\t\tdev_dbg(dev, \"wait interrupted %d\\n\", rv);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (rv == 0) {\n\t\t\tdev_dbg(dev, \"wait timed out\\n\");\n\t\t\trv = -ETIMEDOUT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttag = data->bNotify1 & 0x7f;\n\t\tif (tag != data->iin_bTag) {\n\t\t\tdev_err(dev, \"expected bTag %x got %x\\n\",\n\t\t\t\tdata->iin_bTag, tag);\n\t\t}\n\n\t\t*stb = data->bNotify2;\n\t} else {\n\t\t*stb = buffer[2];\n\t}\n\n\tdev_dbg(dev, \"stb:0x%02x received %d\\n\", (unsigned int)*stb, rv);\n\n exit:\n\t \n\tdata->iin_bTag += 1;\n\tif (data->iin_bTag > 127)\n\t\t \n\t\tdata->iin_bTag = 2;\n\n\tkfree(buffer);\n\treturn rv;\n}\n\nstatic int usbtmc488_ioctl_read_stb(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tint srq_asserted = 0;\n\t__u8 stb;\n\tint rv;\n\n\trv = usbtmc_get_stb(file_data, &stb);\n\n\tif (rv > 0) {\n\t\tsrq_asserted = atomic_xchg(&file_data->srq_asserted,\n\t\t\t\t\tsrq_asserted);\n\t\tif (srq_asserted)\n\t\t\tstb |= 0x40;  \n\n\t\trv = put_user(stb, (__u8 __user *)arg);\n\t}\n\treturn rv;\n\n}\n\nstatic int usbtmc_ioctl_get_srq_stb(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tstruct device *dev = &data->intf->dev;\n\tint srq_asserted = 0;\n\t__u8 stb = 0;\n\tint rv;\n\n\tspin_lock_irq(&data->dev_lock);\n\tsrq_asserted  = atomic_xchg(&file_data->srq_asserted, srq_asserted);\n\n\tif (srq_asserted) {\n\t\tstb = file_data->srq_byte;\n\t\tspin_unlock_irq(&data->dev_lock);\n\t\trv = put_user(stb, (__u8 __user *)arg);\n\t} else {\n\t\tspin_unlock_irq(&data->dev_lock);\n\t\trv = -ENOMSG;\n\t}\n\n\tdev_dbg(dev, \"stb:0x%02x with srq received %d\\n\", (unsigned int)stb, rv);\n\n\treturn rv;\n}\n\nstatic int usbtmc488_ioctl_wait_srq(struct usbtmc_file_data *file_data,\n\t\t\t\t    __u32 __user *arg)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tstruct device *dev = &data->intf->dev;\n\tint rv;\n\tu32 timeout;\n\tunsigned long expire;\n\n\tif (!data->iin_ep_present) {\n\t\tdev_dbg(dev, \"no interrupt endpoint present\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (get_user(timeout, arg))\n\t\treturn -EFAULT;\n\n\texpire = msecs_to_jiffies(timeout);\n\n\tmutex_unlock(&data->io_mutex);\n\n\trv = wait_event_interruptible_timeout(\n\t\t\tdata->waitq,\n\t\t\tatomic_read(&file_data->srq_asserted) != 0 ||\n\t\t\tatomic_read(&file_data->closing),\n\t\t\texpire);\n\n\tmutex_lock(&data->io_mutex);\n\n\t \n\tif (atomic_read(&file_data->closing) || data->zombie)\n\t\trv = -ENODEV;\n\n\tif (rv < 0) {\n\t\t \n\t\tpr_debug(\"%s - wait interrupted %d\\n\", __func__, rv);\n\t\treturn rv;\n\t}\n\n\tif (rv == 0) {\n\t\tdev_dbg(dev, \"%s - wait timed out\\n\", __func__);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tdev_dbg(dev, \"%s - srq asserted\\n\", __func__);\n\treturn 0;\n}\n\nstatic int usbtmc488_ioctl_simple(struct usbtmc_device_data *data,\n\t\t\t\tvoid __user *arg, unsigned int cmd)\n{\n\tstruct device *dev = &data->intf->dev;\n\t__u8 val;\n\tu8 *buffer;\n\tu16 wValue;\n\tint rv;\n\n\tif (!(data->usb488_caps & USBTMC488_CAPABILITY_SIMPLE))\n\t\treturn -EINVAL;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tif (cmd == USBTMC488_REQUEST_REN_CONTROL) {\n\t\trv = copy_from_user(&val, arg, sizeof(val));\n\t\tif (rv) {\n\t\t\trv = -EFAULT;\n\t\t\tgoto exit;\n\t\t}\n\t\twValue = val ? 1 : 0;\n\t} else {\n\t\twValue = 0;\n\t}\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\tusb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\tcmd,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\twValue,\n\t\t\tdata->ifnum,\n\t\t\tbuffer, 0x01, USB_CTRL_GET_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, \"simple usb_control_msg failed %d\\n\", rv);\n\t\tgoto exit;\n\t} else if (rv != 1) {\n\t\tdev_warn(dev, \"simple usb_control_msg returned %d\\n\", rv);\n\t\trv = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"simple control status returned %x\\n\", buffer[0]);\n\t\trv = -EIO;\n\t\tgoto exit;\n\t}\n\trv = 0;\n\n exit:\n\tkfree(buffer);\n\treturn rv;\n}\n\n \nstatic int usbtmc488_ioctl_trigger(struct usbtmc_file_data *file_data)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tint retval;\n\tu8 *buffer;\n\tint actual;\n\n\tbuffer = kzalloc(USBTMC_HEADER_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = 128;\n\tbuffer[1] = data->bTag;\n\tbuffer[2] = ~data->bTag;\n\n\tretval = usb_bulk_msg(data->usb_dev,\n\t\t\t      usb_sndbulkpipe(data->usb_dev,\n\t\t\t\t\t      data->bulk_out),\n\t\t\t      buffer, USBTMC_HEADER_SIZE,\n\t\t\t      &actual, file_data->timeout);\n\n\t \n\tdata->bTag_last_write = data->bTag;\n\n\t \n\tdata->bTag++;\n\tif (!data->bTag)\n\t\tdata->bTag++;\n\n\tkfree(buffer);\n\tif (retval < 0) {\n\t\tdev_err(&data->intf->dev, \"%s returned %d\\n\",\n\t\t\t__func__, retval);\n\t\treturn retval;\n\t}\n\n\treturn 0;\n}\n\nstatic struct urb *usbtmc_create_urb(void)\n{\n\tconst size_t bufsize = USBTMC_BUFSIZE;\n\tu8 *dmabuf = NULL;\n\tstruct urb *urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!urb)\n\t\treturn NULL;\n\n\tdmabuf = kmalloc(bufsize, GFP_KERNEL);\n\tif (!dmabuf) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\turb->transfer_buffer = dmabuf;\n\turb->transfer_buffer_length = bufsize;\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\treturn urb;\n}\n\nstatic void usbtmc_read_bulk_cb(struct urb *urb)\n{\n\tstruct usbtmc_file_data *file_data = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\t \n\tif (status) {\n\t\tif (!( \n\t\t\tstatus == -ECONNRESET ||\n\t\t\tstatus == -EREMOTEIO ||  \n\t\t\tstatus == -ESHUTDOWN))\n\t\t\tdev_err(&file_data->data->intf->dev,\n\t\t\t\"%s - nonzero read bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\n\t\tspin_lock_irqsave(&file_data->err_lock, flags);\n\t\tif (!file_data->in_status)\n\t\t\tfile_data->in_status = status;\n\t\tspin_unlock_irqrestore(&file_data->err_lock, flags);\n\t}\n\n\tspin_lock_irqsave(&file_data->err_lock, flags);\n\tfile_data->in_transfer_size += urb->actual_length;\n\tdev_dbg(&file_data->data->intf->dev,\n\t\t\"%s - total size: %u current: %d status: %d\\n\",\n\t\t__func__, file_data->in_transfer_size,\n\t\turb->actual_length, status);\n\tspin_unlock_irqrestore(&file_data->err_lock, flags);\n\tusb_anchor_urb(urb, &file_data->in_anchor);\n\n\twake_up_interruptible(&file_data->wait_bulk_in);\n\twake_up_interruptible(&file_data->data->waitq);\n}\n\nstatic inline bool usbtmc_do_transfer(struct usbtmc_file_data *file_data)\n{\n\tbool data_or_error;\n\n\tspin_lock_irq(&file_data->err_lock);\n\tdata_or_error = !usb_anchor_empty(&file_data->in_anchor)\n\t\t\t|| file_data->in_status;\n\tspin_unlock_irq(&file_data->err_lock);\n\tdev_dbg(&file_data->data->intf->dev, \"%s: returns %d\\n\", __func__,\n\t\tdata_or_error);\n\treturn data_or_error;\n}\n\nstatic ssize_t usbtmc_generic_read(struct usbtmc_file_data *file_data,\n\t\t\t\t   void __user *user_buffer,\n\t\t\t\t   u32 transfer_size,\n\t\t\t\t   u32 *transferred,\n\t\t\t\t   u32 flags)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tstruct device *dev = &data->intf->dev;\n\tu32 done = 0;\n\tu32 remaining;\n\tconst u32 bufsize = USBTMC_BUFSIZE;\n\tint retval = 0;\n\tu32 max_transfer_size;\n\tunsigned long expire;\n\tint bufcount = 1;\n\tint again = 0;\n\n\t \n\n\t*transferred = done;\n\n\tmax_transfer_size = transfer_size;\n\n\tif (flags & USBTMC_FLAG_IGNORE_TRAILER) {\n\t\t \n\t\tremaining = transfer_size;\n\t\tif ((max_transfer_size % data->wMaxPacketSize) == 0)\n\t\t\tmax_transfer_size += (data->wMaxPacketSize - 1);\n\t} else {\n\t\t \n\t\tif (max_transfer_size > bufsize) {\n\t\t\tmax_transfer_size =\n\t\t\t\troundup(max_transfer_size + 1 - bufsize,\n\t\t\t\t\tbufsize);\n\t\t}\n\t\tremaining = max_transfer_size;\n\t}\n\n\tspin_lock_irq(&file_data->err_lock);\n\n\tif (file_data->in_status) {\n\t\t \n\t\tretval = file_data->in_status;\n\t\tspin_unlock_irq(&file_data->err_lock);\n\t\tgoto error;\n\t}\n\n\tif (flags & USBTMC_FLAG_ASYNC) {\n\t\tif (usb_anchor_empty(&file_data->in_anchor))\n\t\t\tagain = 1;\n\n\t\tif (file_data->in_urbs_used == 0) {\n\t\t\tfile_data->in_transfer_size = 0;\n\t\t\tfile_data->in_status = 0;\n\t\t}\n\t} else {\n\t\tfile_data->in_transfer_size = 0;\n\t\tfile_data->in_status = 0;\n\t}\n\n\tif (max_transfer_size == 0) {\n\t\tbufcount = 0;\n\t} else {\n\t\tbufcount = roundup(max_transfer_size, bufsize) / bufsize;\n\t\tif (bufcount > file_data->in_urbs_used)\n\t\t\tbufcount -= file_data->in_urbs_used;\n\t\telse\n\t\t\tbufcount = 0;\n\n\t\tif (bufcount + file_data->in_urbs_used > MAX_URBS_IN_FLIGHT) {\n\t\t\tbufcount = MAX_URBS_IN_FLIGHT -\n\t\t\t\t\tfile_data->in_urbs_used;\n\t\t}\n\t}\n\tspin_unlock_irq(&file_data->err_lock);\n\n\tdev_dbg(dev, \"%s: requested=%u flags=0x%X size=%u bufs=%d used=%d\\n\",\n\t\t__func__, transfer_size, flags,\n\t\tmax_transfer_size, bufcount, file_data->in_urbs_used);\n\n\twhile (bufcount > 0) {\n\t\tu8 *dmabuf = NULL;\n\t\tstruct urb *urb = usbtmc_create_urb();\n\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\tdmabuf = urb->transfer_buffer;\n\n\t\tusb_fill_bulk_urb(urb, data->usb_dev,\n\t\t\tusb_rcvbulkpipe(data->usb_dev, data->bulk_in),\n\t\t\tdmabuf, bufsize,\n\t\t\tusbtmc_read_bulk_cb, file_data);\n\n\t\tusb_anchor_urb(urb, &file_data->submitted);\n\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\t \n\t\tusb_free_urb(urb);\n\t\tif (unlikely(retval)) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tgoto error;\n\t\t}\n\t\tfile_data->in_urbs_used++;\n\t\tbufcount--;\n\t}\n\n\tif (again) {\n\t\tdev_dbg(dev, \"%s: ret=again\\n\", __func__);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (user_buffer == NULL)\n\t\treturn -EINVAL;\n\n\texpire = msecs_to_jiffies(file_data->timeout);\n\n\twhile (max_transfer_size > 0) {\n\t\tu32 this_part;\n\t\tstruct urb *urb = NULL;\n\n\t\tif (!(flags & USBTMC_FLAG_ASYNC)) {\n\t\t\tdev_dbg(dev, \"%s: before wait time %lu\\n\",\n\t\t\t\t__func__, expire);\n\t\t\tretval = wait_event_interruptible_timeout(\n\t\t\t\tfile_data->wait_bulk_in,\n\t\t\t\tusbtmc_do_transfer(file_data),\n\t\t\t\texpire);\n\n\t\t\tdev_dbg(dev, \"%s: wait returned %d\\n\",\n\t\t\t\t__func__, retval);\n\n\t\t\tif (retval <= 0) {\n\t\t\t\tif (retval == 0)\n\t\t\t\t\tretval = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\turb = usb_get_from_anchor(&file_data->in_anchor);\n\t\tif (!urb) {\n\t\t\tif (!(flags & USBTMC_FLAG_ASYNC)) {\n\t\t\t\t \n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\t*transferred = done;\n\t\t\tdev_dbg(dev, \"%s: (async) done=%u ret=0\\n\",\n\t\t\t\t__func__, done);\n\t\t\treturn 0;\n\t\t}\n\n\t\tfile_data->in_urbs_used--;\n\n\t\tif (max_transfer_size > urb->actual_length)\n\t\t\tmax_transfer_size -= urb->actual_length;\n\t\telse\n\t\t\tmax_transfer_size = 0;\n\n\t\tif (remaining > urb->actual_length)\n\t\t\tthis_part = urb->actual_length;\n\t\telse\n\t\t\tthis_part = remaining;\n\n\t\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\turb->transfer_buffer, urb->actual_length, true);\n\n\t\tif (copy_to_user(user_buffer + done,\n\t\t\t\t urb->transfer_buffer, this_part)) {\n\t\t\tusb_free_urb(urb);\n\t\t\tretval = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\n\t\tremaining -= this_part;\n\t\tdone += this_part;\n\n\t\tspin_lock_irq(&file_data->err_lock);\n\t\tif (urb->status) {\n\t\t\t \n\t\t\tretval = file_data->in_status;\n\t\t\tspin_unlock_irq(&file_data->err_lock);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto error;\n\t\t}\n\t\tspin_unlock_irq(&file_data->err_lock);\n\n\t\tif (urb->actual_length < bufsize) {\n\t\t\t \n\t\t\tusb_free_urb(urb);\n\t\t\tretval = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(flags & USBTMC_FLAG_ASYNC) &&\n\t\t    max_transfer_size > (bufsize * file_data->in_urbs_used)) {\n\t\t\t \n\t\t\tusb_anchor_urb(urb, &file_data->submitted);\n\t\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\t\tif (unlikely(retval)) {\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_free_urb(urb);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfile_data->in_urbs_used++;\n\t\t}\n\t\tusb_free_urb(urb);\n\t\tretval = 0;\n\t}\n\nerror:\n\t*transferred = done;\n\n\tdev_dbg(dev, \"%s: before kill\\n\", __func__);\n\t \n\tusb_kill_anchored_urbs(&file_data->submitted);\n\tdev_dbg(dev, \"%s: after kill\\n\", __func__);\n\tusb_scuttle_anchored_urbs(&file_data->in_anchor);\n\tfile_data->in_urbs_used = 0;\n\tfile_data->in_status = 0;  \n\tdev_dbg(dev, \"%s: done=%u ret=%d\\n\", __func__, done, retval);\n\n\treturn retval;\n}\n\nstatic ssize_t usbtmc_ioctl_generic_read(struct usbtmc_file_data *file_data,\n\t\t\t\t\t void __user *arg)\n{\n\tstruct usbtmc_message msg;\n\tssize_t retval = 0;\n\n\t \n\n\tif (copy_from_user(&msg, arg, sizeof(struct usbtmc_message)))\n\t\treturn -EFAULT;\n\n\tretval = usbtmc_generic_read(file_data, msg.message,\n\t\t\t\t     msg.transfer_size, &msg.transferred,\n\t\t\t\t     msg.flags);\n\n\tif (put_user(msg.transferred,\n\t\t     &((struct usbtmc_message __user *)arg)->transferred))\n\t\treturn -EFAULT;\n\n\treturn retval;\n}\n\nstatic void usbtmc_write_bulk_cb(struct urb *urb)\n{\n\tstruct usbtmc_file_data *file_data = urb->context;\n\tint wakeup = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&file_data->err_lock, flags);\n\tfile_data->out_transfer_size += urb->actual_length;\n\n\t \n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t\turb->status == -ECONNRESET ||\n\t\t\turb->status == -ESHUTDOWN))\n\t\t\tdev_err(&file_data->data->intf->dev,\n\t\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\n\t\tif (!file_data->out_status) {\n\t\t\tfile_data->out_status = urb->status;\n\t\t\twakeup = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&file_data->err_lock, flags);\n\n\tdev_dbg(&file_data->data->intf->dev,\n\t\t\"%s - write bulk total size: %u\\n\",\n\t\t__func__, file_data->out_transfer_size);\n\n\tup(&file_data->limit_write_sem);\n\tif (usb_anchor_empty(&file_data->submitted) || wakeup)\n\t\twake_up_interruptible(&file_data->data->waitq);\n}\n\nstatic ssize_t usbtmc_generic_write(struct usbtmc_file_data *file_data,\n\t\t\t\t    const void __user *user_buffer,\n\t\t\t\t    u32 transfer_size,\n\t\t\t\t    u32 *transferred,\n\t\t\t\t    u32 flags)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tstruct device *dev;\n\tu32 done = 0;\n\tu32 remaining;\n\tunsigned long expire;\n\tconst u32 bufsize = USBTMC_BUFSIZE;\n\tstruct urb *urb = NULL;\n\tint retval = 0;\n\tu32 timeout;\n\n\t*transferred = 0;\n\n\t \n\tdev = &data->intf->dev;\n\n\tdev_dbg(dev, \"%s: size=%u flags=0x%X sema=%u\\n\",\n\t\t__func__, transfer_size, flags,\n\t\tfile_data->limit_write_sem.count);\n\n\tif (flags & USBTMC_FLAG_APPEND) {\n\t\tspin_lock_irq(&file_data->err_lock);\n\t\tretval = file_data->out_status;\n\t\tspin_unlock_irq(&file_data->err_lock);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t} else {\n\t\tspin_lock_irq(&file_data->err_lock);\n\t\tfile_data->out_transfer_size = 0;\n\t\tfile_data->out_status = 0;\n\t\tspin_unlock_irq(&file_data->err_lock);\n\t}\n\n\tremaining = transfer_size;\n\tif (remaining > INT_MAX)\n\t\tremaining = INT_MAX;\n\n\ttimeout = file_data->timeout;\n\texpire = msecs_to_jiffies(timeout);\n\n\twhile (remaining > 0) {\n\t\tu32 this_part, aligned;\n\t\tu8 *buffer = NULL;\n\n\t\tif (flags & USBTMC_FLAG_ASYNC) {\n\t\t\tif (down_trylock(&file_data->limit_write_sem)) {\n\t\t\t\tretval = (done)?(0):(-EAGAIN);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tretval = down_timeout(&file_data->limit_write_sem,\n\t\t\t\t\t      expire);\n\t\t\tif (retval < 0) {\n\t\t\t\tretval = -ETIMEDOUT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&file_data->err_lock);\n\t\tretval = file_data->out_status;\n\t\tspin_unlock_irq(&file_data->err_lock);\n\t\tif (retval < 0) {\n\t\t\tup(&file_data->limit_write_sem);\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\turb = usbtmc_create_urb();\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tup(&file_data->limit_write_sem);\n\t\t\tgoto error;\n\t\t}\n\t\tbuffer = urb->transfer_buffer;\n\n\t\tif (remaining > bufsize)\n\t\t\tthis_part = bufsize;\n\t\telse\n\t\t\tthis_part = remaining;\n\n\t\tif (copy_from_user(buffer, user_buffer + done, this_part)) {\n\t\t\tretval = -EFAULT;\n\t\t\tup(&file_data->limit_write_sem);\n\t\t\tgoto error;\n\t\t}\n\n\t\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE,\n\t\t\t16, 1, buffer, this_part, true);\n\n\t\t \n\t\taligned = (this_part + 3) & ~3;\n\t\tdev_dbg(dev, \"write(size:%u align:%u done:%u)\\n\",\n\t\t\t(unsigned int)this_part,\n\t\t\t(unsigned int)aligned,\n\t\t\t(unsigned int)done);\n\n\t\tusb_fill_bulk_urb(urb, data->usb_dev,\n\t\t\tusb_sndbulkpipe(data->usb_dev, data->bulk_out),\n\t\t\turb->transfer_buffer, aligned,\n\t\t\tusbtmc_write_bulk_cb, file_data);\n\n\t\tusb_anchor_urb(urb, &file_data->submitted);\n\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (unlikely(retval)) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tup(&file_data->limit_write_sem);\n\t\t\tgoto error;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t\turb = NULL;  \n\n\t\tremaining -= this_part;\n\t\tdone += this_part;\n\t}\n\n\t \n\tif (!(flags & USBTMC_FLAG_ASYNC)) {\n\t\tif (!usb_wait_anchor_empty_timeout(&file_data->submitted,\n\t\t\t\t\t\t   timeout)) {\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tretval = 0;\n\tgoto exit;\n\nerror:\n\tusb_kill_anchored_urbs(&file_data->submitted);\nexit:\n\tusb_free_urb(urb);\n\n\tspin_lock_irq(&file_data->err_lock);\n\tif (!(flags & USBTMC_FLAG_ASYNC))\n\t\tdone = file_data->out_transfer_size;\n\tif (!retval && file_data->out_status)\n\t\tretval = file_data->out_status;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\t*transferred = done;\n\n\tdev_dbg(dev, \"%s: done=%u, retval=%d, urbstat=%d\\n\",\n\t\t__func__, done, retval, file_data->out_status);\n\n\treturn retval;\n}\n\nstatic ssize_t usbtmc_ioctl_generic_write(struct usbtmc_file_data *file_data,\n\t\t\t\t\t  void __user *arg)\n{\n\tstruct usbtmc_message msg;\n\tssize_t retval = 0;\n\n\t \n\n\tif (copy_from_user(&msg, arg, sizeof(struct usbtmc_message)))\n\t\treturn -EFAULT;\n\n\tretval = usbtmc_generic_write(file_data, msg.message,\n\t\t\t\t      msg.transfer_size, &msg.transferred,\n\t\t\t\t      msg.flags);\n\n\tif (put_user(msg.transferred,\n\t\t     &((struct usbtmc_message __user *)arg)->transferred))\n\t\treturn -EFAULT;\n\n\treturn retval;\n}\n\n \nstatic ssize_t usbtmc_ioctl_write_result(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tu32 transferred;\n\tint retval;\n\n\tspin_lock_irq(&file_data->err_lock);\n\ttransferred = file_data->out_transfer_size;\n\tretval = file_data->out_status;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\tif (put_user(transferred, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\treturn retval;\n}\n\n \nstatic int send_request_dev_dep_msg_in(struct usbtmc_file_data *file_data,\n\t\t\t\t       u32 transfer_size)\n{\n\tstruct usbtmc_device_data *data = file_data->data;\n\tint retval;\n\tu8 *buffer;\n\tint actual;\n\n\tbuffer = kmalloc(USBTMC_HEADER_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\t \n\tbuffer[0] = 2;\n\tbuffer[1] = data->bTag;\n\tbuffer[2] = ~data->bTag;\n\tbuffer[3] = 0;  \n\tbuffer[4] = transfer_size >> 0;\n\tbuffer[5] = transfer_size >> 8;\n\tbuffer[6] = transfer_size >> 16;\n\tbuffer[7] = transfer_size >> 24;\n\tbuffer[8] = file_data->term_char_enabled * 2;\n\t \n\tbuffer[9] = file_data->term_char;\n\tbuffer[10] = 0;  \n\tbuffer[11] = 0;  \n\n\t \n\tretval = usb_bulk_msg(data->usb_dev,\n\t\t\t      usb_sndbulkpipe(data->usb_dev,\n\t\t\t\t\t      data->bulk_out),\n\t\t\t      buffer, USBTMC_HEADER_SIZE,\n\t\t\t      &actual, file_data->timeout);\n\n\t \n\tdata->bTag_last_write = data->bTag;\n\n\t \n\tdata->bTag++;\n\tif (!data->bTag)\n\t\tdata->bTag++;\n\n\tkfree(buffer);\n\tif (retval < 0)\n\t\tdev_err(&data->intf->dev, \"%s returned %d\\n\",\n\t\t\t__func__, retval);\n\n\treturn retval;\n}\n\nstatic ssize_t usbtmc_read(struct file *filp, char __user *buf,\n\t\t\t   size_t count, loff_t *f_pos)\n{\n\tstruct usbtmc_file_data *file_data;\n\tstruct usbtmc_device_data *data;\n\tstruct device *dev;\n\tconst u32 bufsize = USBTMC_BUFSIZE;\n\tu32 n_characters;\n\tu8 *buffer;\n\tint actual;\n\tu32 done = 0;\n\tu32 remaining;\n\tint retval;\n\n\t \n\tfile_data = filp->private_data;\n\tdata = file_data->data;\n\tdev = &data->intf->dev;\n\n\tbuffer = kmalloc(bufsize, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&data->io_mutex);\n\tif (data->zombie) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tif (count > INT_MAX)\n\t\tcount = INT_MAX;\n\n\tdev_dbg(dev, \"%s(count:%zu)\\n\", __func__, count);\n\n\tretval = send_request_dev_dep_msg_in(file_data, count);\n\n\tif (retval < 0) {\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_out(data);\n\t\tgoto exit;\n\t}\n\n\t \n\tremaining = count;\n\tactual = 0;\n\n\t \n\tretval = usb_bulk_msg(data->usb_dev,\n\t\t\t      usb_rcvbulkpipe(data->usb_dev,\n\t\t\t\t\t      data->bulk_in),\n\t\t\t      buffer, bufsize, &actual,\n\t\t\t      file_data->timeout);\n\n\tdev_dbg(dev, \"%s: bulk_msg retval(%u), actual(%d)\\n\",\n\t\t__func__, retval, actual);\n\n\t \n\tdata->bTag_last_read = data->bTag;\n\n\tif (retval < 0) {\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_in(data);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (actual < USBTMC_HEADER_SIZE) {\n\t\tdev_err(dev, \"Device sent too small first packet: %u < %u\\n\",\n\t\t\tactual, USBTMC_HEADER_SIZE);\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_in(data);\n\t\tgoto exit;\n\t}\n\n\tif (buffer[0] != 2) {\n\t\tdev_err(dev, \"Device sent reply with wrong MsgID: %u != 2\\n\",\n\t\t\tbuffer[0]);\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_in(data);\n\t\tgoto exit;\n\t}\n\n\tif (buffer[1] != data->bTag_last_write) {\n\t\tdev_err(dev, \"Device sent reply with wrong bTag: %u != %u\\n\",\n\t\tbuffer[1], data->bTag_last_write);\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_in(data);\n\t\tgoto exit;\n\t}\n\n\t \n\tn_characters = buffer[4] +\n\t\t       (buffer[5] << 8) +\n\t\t       (buffer[6] << 16) +\n\t\t       (buffer[7] << 24);\n\n\tfile_data->bmTransferAttributes = buffer[8];\n\n\tdev_dbg(dev, \"Bulk-IN header: N_characters(%u), bTransAttr(%u)\\n\",\n\t\tn_characters, buffer[8]);\n\n\tif (n_characters > remaining) {\n\t\tdev_err(dev, \"Device wants to return more data than requested: %u > %zu\\n\",\n\t\t\tn_characters, count);\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_in(data);\n\t\tgoto exit;\n\t}\n\n\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE,\n\t\t\t     16, 1, buffer, actual, true);\n\n\tremaining = n_characters;\n\n\t \n\tactual -= USBTMC_HEADER_SIZE;\n\n\t \n\tif (actual > remaining)\n\t\tactual = remaining;\n\n\tremaining -= actual;\n\n\t \n\tif (copy_to_user(buf, &buffer[USBTMC_HEADER_SIZE], actual)) {\n\t\t \n\t\tretval = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif ((actual + USBTMC_HEADER_SIZE) == bufsize) {\n\t\tretval = usbtmc_generic_read(file_data, buf + actual,\n\t\t\t\t\t     remaining,\n\t\t\t\t\t     &done,\n\t\t\t\t\t     USBTMC_FLAG_IGNORE_TRAILER);\n\t\tif (retval < 0)\n\t\t\tgoto exit;\n\t}\n\tdone += actual;\n\n\t \n\t*f_pos = *f_pos + done;\n\tretval = done;\n\nexit:\n\tmutex_unlock(&data->io_mutex);\n\tkfree(buffer);\n\treturn retval;\n}\n\nstatic ssize_t usbtmc_write(struct file *filp, const char __user *buf,\n\t\t\t    size_t count, loff_t *f_pos)\n{\n\tstruct usbtmc_file_data *file_data;\n\tstruct usbtmc_device_data *data;\n\tstruct urb *urb = NULL;\n\tssize_t retval = 0;\n\tu8 *buffer;\n\tu32 remaining, done;\n\tu32 transfersize, aligned, buflen;\n\n\tfile_data = filp->private_data;\n\tdata = file_data->data;\n\n\tmutex_lock(&data->io_mutex);\n\n\tif (data->zombie) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdone = 0;\n\n\tspin_lock_irq(&file_data->err_lock);\n\tfile_data->out_transfer_size = 0;\n\tfile_data->out_status = 0;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\tif (!count)\n\t\tgoto exit;\n\n\tif (down_trylock(&file_data->limit_write_sem)) {\n\t\t \n\t\tretval = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\turb = usbtmc_create_urb();\n\tif (!urb) {\n\t\tretval = -ENOMEM;\n\t\tup(&file_data->limit_write_sem);\n\t\tgoto exit;\n\t}\n\n\tbuffer = urb->transfer_buffer;\n\tbuflen = urb->transfer_buffer_length;\n\n\tif (count > INT_MAX) {\n\t\ttransfersize = INT_MAX;\n\t\tbuffer[8] = 0;\n\t} else {\n\t\ttransfersize = count;\n\t\tbuffer[8] = file_data->eom_val;\n\t}\n\n\t \n\tbuffer[0] = 1;\n\tbuffer[1] = data->bTag;\n\tbuffer[2] = ~data->bTag;\n\tbuffer[3] = 0;  \n\tbuffer[4] = transfersize >> 0;\n\tbuffer[5] = transfersize >> 8;\n\tbuffer[6] = transfersize >> 16;\n\tbuffer[7] = transfersize >> 24;\n\t \n\tbuffer[9] = 0;  \n\tbuffer[10] = 0;  \n\tbuffer[11] = 0;  \n\n\tremaining = transfersize;\n\n\tif (transfersize + USBTMC_HEADER_SIZE > buflen) {\n\t\ttransfersize = buflen - USBTMC_HEADER_SIZE;\n\t\taligned = buflen;\n\t} else {\n\t\taligned = (transfersize + (USBTMC_HEADER_SIZE + 3)) & ~3;\n\t}\n\n\tif (copy_from_user(&buffer[USBTMC_HEADER_SIZE], buf, transfersize)) {\n\t\tretval = -EFAULT;\n\t\tup(&file_data->limit_write_sem);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(&data->intf->dev, \"%s(size:%u align:%u)\\n\", __func__,\n\t\t(unsigned int)transfersize, (unsigned int)aligned);\n\n\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE,\n\t\t\t     16, 1, buffer, aligned, true);\n\n\tusb_fill_bulk_urb(urb, data->usb_dev,\n\t\tusb_sndbulkpipe(data->usb_dev, data->bulk_out),\n\t\turb->transfer_buffer, aligned,\n\t\tusbtmc_write_bulk_cb, file_data);\n\n\tusb_anchor_urb(urb, &file_data->submitted);\n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (unlikely(retval)) {\n\t\tusb_unanchor_urb(urb);\n\t\tup(&file_data->limit_write_sem);\n\t\tgoto exit;\n\t}\n\n\tremaining -= transfersize;\n\n\tdata->bTag_last_write = data->bTag;\n\tdata->bTag++;\n\n\tif (!data->bTag)\n\t\tdata->bTag++;\n\n\t \n\tretval = usbtmc_generic_write(file_data, buf + transfersize, remaining,\n\t\t\t\t      &done, USBTMC_FLAG_APPEND);\n\t \n\tif (done > remaining)\n\t\tdone = remaining;\n\n\t \n\tdone += transfersize;\n\n\tif (retval < 0) {\n\t\tusb_kill_anchored_urbs(&file_data->submitted);\n\n\t\tdev_err(&data->intf->dev,\n\t\t\t\"Unable to send data, error %d\\n\", (int)retval);\n\t\tif (file_data->auto_abort)\n\t\t\tusbtmc_ioctl_abort_bulk_out(data);\n\t\tgoto exit;\n\t}\n\n\tretval = done;\nexit:\n\tusb_free_urb(urb);\n\tmutex_unlock(&data->io_mutex);\n\treturn retval;\n}\n\nstatic int usbtmc_ioctl_clear(struct usbtmc_device_data *data)\n{\n\tstruct device *dev;\n\tu8 *buffer;\n\tint rv;\n\tint n;\n\tint actual = 0;\n\n\tdev = &data->intf->dev;\n\n\tdev_dbg(dev, \"Sending INITIATE_CLEAR request\\n\");\n\n\tbuffer = kmalloc(USBTMC_BUFSIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_INITIATE_CLEAR,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t     0, 0, buffer, 1, USB_CTRL_GET_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"INITIATE_CLEAR returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"INITIATE_CLEAR returned %x\\n\", buffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tn = 0;\n\nusbtmc_clear_check_status:\n\n\tdev_dbg(dev, \"Sending CHECK_CLEAR_STATUS request\\n\");\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_CHECK_CLEAR_STATUS,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t     0, 0, buffer, 2, USB_CTRL_GET_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"CHECK_CLEAR_STATUS returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] == USBTMC_STATUS_SUCCESS)\n\t\tgoto usbtmc_clear_bulk_out_halt;\n\n\tif (buffer[0] != USBTMC_STATUS_PENDING) {\n\t\tdev_err(dev, \"CHECK_CLEAR_STATUS returned %x\\n\", buffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tif ((buffer[1] & 1) != 0) {\n\t\tdo {\n\t\t\tdev_dbg(dev, \"Reading from bulk in EP\\n\");\n\n\t\t\tactual = 0;\n\t\t\trv = usb_bulk_msg(data->usb_dev,\n\t\t\t\t\t  usb_rcvbulkpipe(data->usb_dev,\n\t\t\t\t\t\t\t  data->bulk_in),\n\t\t\t\t\t  buffer, USBTMC_BUFSIZE,\n\t\t\t\t\t  &actual, USB_CTRL_GET_TIMEOUT);\n\n\t\t\tprint_hex_dump_debug(\"usbtmc \", DUMP_PREFIX_NONE,\n\t\t\t\t\t     16, 1, buffer, actual, true);\n\n\t\t\tn++;\n\n\t\t\tif (rv < 0) {\n\t\t\t\tdev_err(dev, \"usb_control_msg returned %d\\n\",\n\t\t\t\t\trv);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} while ((actual == USBTMC_BUFSIZE) &&\n\t\t\t  (n < USBTMC_MAX_READS_TO_CLEAR_BULK_IN));\n\t} else {\n\t\t \n\t\tmsleep(50);\n\t\tn++;\n\t}\n\n\tif (n >= USBTMC_MAX_READS_TO_CLEAR_BULK_IN) {\n\t\tdev_err(dev, \"Couldn't clear device buffer within %d cycles\\n\",\n\t\t\tUSBTMC_MAX_READS_TO_CLEAR_BULK_IN);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\n\tgoto usbtmc_clear_check_status;\n\nusbtmc_clear_bulk_out_halt:\n\n\trv = usb_clear_halt(data->usb_dev,\n\t\t\t    usb_sndbulkpipe(data->usb_dev, data->bulk_out));\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_clear_halt returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\trv = 0;\n\nexit:\n\tkfree(buffer);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_clear_out_halt(struct usbtmc_device_data *data)\n{\n\tint rv;\n\n\trv = usb_clear_halt(data->usb_dev,\n\t\t\t    usb_sndbulkpipe(data->usb_dev, data->bulk_out));\n\n\tif (rv < 0)\n\t\tdev_err(&data->usb_dev->dev, \"%s returned %d\\n\", __func__, rv);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_clear_in_halt(struct usbtmc_device_data *data)\n{\n\tint rv;\n\n\trv = usb_clear_halt(data->usb_dev,\n\t\t\t    usb_rcvbulkpipe(data->usb_dev, data->bulk_in));\n\n\tif (rv < 0)\n\t\tdev_err(&data->usb_dev->dev, \"%s returned %d\\n\", __func__, rv);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_cancel_io(struct usbtmc_file_data *file_data)\n{\n\tspin_lock_irq(&file_data->err_lock);\n\tfile_data->in_status = -ECANCELED;\n\tfile_data->out_status = -ECANCELED;\n\tspin_unlock_irq(&file_data->err_lock);\n\tusb_kill_anchored_urbs(&file_data->submitted);\n\treturn 0;\n}\n\nstatic int usbtmc_ioctl_cleanup_io(struct usbtmc_file_data *file_data)\n{\n\tusb_kill_anchored_urbs(&file_data->submitted);\n\tusb_scuttle_anchored_urbs(&file_data->in_anchor);\n\tspin_lock_irq(&file_data->err_lock);\n\tfile_data->in_status = 0;\n\tfile_data->in_transfer_size = 0;\n\tfile_data->out_status = 0;\n\tfile_data->out_transfer_size = 0;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\tfile_data->in_urbs_used = 0;\n\treturn 0;\n}\n\nstatic int get_capabilities(struct usbtmc_device_data *data)\n{\n\tstruct device *dev = &data->usb_dev->dev;\n\tchar *buffer;\n\tint rv = 0;\n\n\tbuffer = kmalloc(0x18, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\trv = usb_control_msg(data->usb_dev, usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_GET_CAPABILITIES,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t     0, 0, buffer, 0x18, USB_CTRL_GET_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto err_out;\n\t}\n\n\tdev_dbg(dev, \"GET_CAPABILITIES returned %x\\n\", buffer[0]);\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"GET_CAPABILITIES returned %x\\n\", buffer[0]);\n\t\trv = -EPERM;\n\t\tgoto err_out;\n\t}\n\tdev_dbg(dev, \"Interface capabilities are %x\\n\", buffer[4]);\n\tdev_dbg(dev, \"Device capabilities are %x\\n\", buffer[5]);\n\tdev_dbg(dev, \"USB488 interface capabilities are %x\\n\", buffer[14]);\n\tdev_dbg(dev, \"USB488 device capabilities are %x\\n\", buffer[15]);\n\n\tdata->capabilities.interface_capabilities = buffer[4];\n\tdata->capabilities.device_capabilities = buffer[5];\n\tdata->capabilities.usb488_interface_capabilities = buffer[14];\n\tdata->capabilities.usb488_device_capabilities = buffer[15];\n\tdata->usb488_caps = (buffer[14] & 0x07) | ((buffer[15] & 0x0f) << 4);\n\trv = 0;\n\nerr_out:\n\tkfree(buffer);\n\treturn rv;\n}\n\n#define capability_attribute(name)\t\t\t\t\t\\\nstatic ssize_t name##_show(struct device *dev,\t\t\t\t\\\n\t\t\t   struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_interface *intf = to_usb_interface(dev);\t\t\\\n\tstruct usbtmc_device_data *data = usb_get_intfdata(intf);\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%d\\n\", data->capabilities.name);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\ncapability_attribute(interface_capabilities);\ncapability_attribute(device_capabilities);\ncapability_attribute(usb488_interface_capabilities);\ncapability_attribute(usb488_device_capabilities);\n\nstatic struct attribute *usbtmc_attrs[] = {\n\t&dev_attr_interface_capabilities.attr,\n\t&dev_attr_device_capabilities.attr,\n\t&dev_attr_usb488_interface_capabilities.attr,\n\t&dev_attr_usb488_device_capabilities.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(usbtmc);\n\nstatic int usbtmc_ioctl_indicator_pulse(struct usbtmc_device_data *data)\n{\n\tstruct device *dev;\n\tu8 *buffer;\n\tint rv;\n\n\tdev = &data->intf->dev;\n\n\tbuffer = kmalloc(2, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\trv = usb_control_msg(data->usb_dev,\n\t\t\t     usb_rcvctrlpipe(data->usb_dev, 0),\n\t\t\t     USBTMC_REQUEST_INDICATOR_PULSE,\n\t\t\t     USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t     0, 0, buffer, 0x01, USB_CTRL_GET_TIMEOUT);\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"usb_control_msg returned %d\\n\", rv);\n\t\tgoto exit;\n\t}\n\n\tdev_dbg(dev, \"INDICATOR_PULSE returned %x\\n\", buffer[0]);\n\n\tif (buffer[0] != USBTMC_STATUS_SUCCESS) {\n\t\tdev_err(dev, \"INDICATOR_PULSE returned %x\\n\", buffer[0]);\n\t\trv = -EPERM;\n\t\tgoto exit;\n\t}\n\trv = 0;\n\nexit:\n\tkfree(buffer);\n\treturn rv;\n}\n\nstatic int usbtmc_ioctl_request(struct usbtmc_device_data *data,\n\t\t\t\tvoid __user *arg)\n{\n\tstruct device *dev = &data->intf->dev;\n\tstruct usbtmc_ctrlrequest request;\n\tu8 *buffer = NULL;\n\tint rv;\n\tunsigned int is_in, pipe;\n\tunsigned long res;\n\n\tres = copy_from_user(&request, arg, sizeof(struct usbtmc_ctrlrequest));\n\tif (res)\n\t\treturn -EFAULT;\n\n\tif (request.req.wLength > USBTMC_BUFSIZE)\n\t\treturn -EMSGSIZE;\n\tif (request.req.wLength == 0)\t \n\t\trequest.req.bRequestType &= ~USB_DIR_IN;\n\n\tis_in = request.req.bRequestType & USB_DIR_IN;\n\n\tif (request.req.wLength) {\n\t\tbuffer = kmalloc(request.req.wLength, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\treturn -ENOMEM;\n\n\t\tif (!is_in) {\n\t\t\t \n\t\t\tres = copy_from_user(buffer, request.data,\n\t\t\t\t\t     request.req.wLength);\n\t\t\tif (res) {\n\t\t\t\trv = -EFAULT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_in)\n\t\tpipe = usb_rcvctrlpipe(data->usb_dev, 0);\n\telse\n\t\tpipe = usb_sndctrlpipe(data->usb_dev, 0);\n\trv = usb_control_msg(data->usb_dev,\n\t\t\tpipe,\n\t\t\trequest.req.bRequest,\n\t\t\trequest.req.bRequestType,\n\t\t\trequest.req.wValue,\n\t\t\trequest.req.wIndex,\n\t\t\tbuffer, request.req.wLength, USB_CTRL_GET_TIMEOUT);\n\n\tif (rv < 0) {\n\t\tdev_err(dev, \"%s failed %d\\n\", __func__, rv);\n\t\tgoto exit;\n\t}\n\n\tif (rv && is_in) {\n\t\t \n\t\tres = copy_to_user(request.data, buffer, rv);\n\t\tif (res)\n\t\t\trv = -EFAULT;\n\t}\n\n exit:\n\tkfree(buffer);\n\treturn rv;\n}\n\n \nstatic int usbtmc_ioctl_get_timeout(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tu32 timeout;\n\n\ttimeout = file_data->timeout;\n\n\treturn put_user(timeout, (__u32 __user *)arg);\n}\n\n \nstatic int usbtmc_ioctl_set_timeout(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tu32 timeout;\n\n\tif (get_user(timeout, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\t \n\tif (timeout < USBTMC_MIN_TIMEOUT)\n\t\treturn -EINVAL;\n\n\tfile_data->timeout = timeout;\n\n\treturn 0;\n}\n\n \nstatic int usbtmc_ioctl_eom_enable(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tu8 eom_enable;\n\n\tif (copy_from_user(&eom_enable, arg, sizeof(eom_enable)))\n\t\treturn -EFAULT;\n\n\tif (eom_enable > 1)\n\t\treturn -EINVAL;\n\n\tfile_data->eom_val = eom_enable;\n\n\treturn 0;\n}\n\n \nstatic int usbtmc_ioctl_config_termc(struct usbtmc_file_data *file_data,\n\t\t\t\tvoid __user *arg)\n{\n\tstruct usbtmc_termchar termc;\n\n\tif (copy_from_user(&termc, arg, sizeof(termc)))\n\t\treturn -EFAULT;\n\n\tif ((termc.term_char_enabled > 1) ||\n\t\t(termc.term_char_enabled &&\n\t\t!(file_data->data->capabilities.device_capabilities & 1)))\n\t\treturn -EINVAL;\n\n\tfile_data->term_char = termc.term_char;\n\tfile_data->term_char_enabled = termc.term_char_enabled;\n\n\treturn 0;\n}\n\nstatic long usbtmc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct usbtmc_file_data *file_data;\n\tstruct usbtmc_device_data *data;\n\tint retval = -EBADRQC;\n\t__u8 tmp_byte;\n\n\tfile_data = file->private_data;\n\tdata = file_data->data;\n\n\tmutex_lock(&data->io_mutex);\n\tif (data->zombie) {\n\t\tretval = -ENODEV;\n\t\tgoto skip_io_on_zombie;\n\t}\n\n\tswitch (cmd) {\n\tcase USBTMC_IOCTL_CLEAR_OUT_HALT:\n\t\tretval = usbtmc_ioctl_clear_out_halt(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CLEAR_IN_HALT:\n\t\tretval = usbtmc_ioctl_clear_in_halt(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_INDICATOR_PULSE:\n\t\tretval = usbtmc_ioctl_indicator_pulse(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CLEAR:\n\t\tretval = usbtmc_ioctl_clear(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_ABORT_BULK_OUT:\n\t\tretval = usbtmc_ioctl_abort_bulk_out(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_ABORT_BULK_IN:\n\t\tretval = usbtmc_ioctl_abort_bulk_in(data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CTRL_REQUEST:\n\t\tretval = usbtmc_ioctl_request(data, (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_GET_TIMEOUT:\n\t\tretval = usbtmc_ioctl_get_timeout(file_data,\n\t\t\t\t\t\t  (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_SET_TIMEOUT:\n\t\tretval = usbtmc_ioctl_set_timeout(file_data,\n\t\t\t\t\t\t  (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_EOM_ENABLE:\n\t\tretval = usbtmc_ioctl_eom_enable(file_data,\n\t\t\t\t\t\t (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CONFIG_TERMCHAR:\n\t\tretval = usbtmc_ioctl_config_termc(file_data,\n\t\t\t\t\t\t   (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_WRITE:\n\t\tretval = usbtmc_ioctl_generic_write(file_data,\n\t\t\t\t\t\t    (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_READ:\n\t\tretval = usbtmc_ioctl_generic_read(file_data,\n\t\t\t\t\t\t   (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_WRITE_RESULT:\n\t\tretval = usbtmc_ioctl_write_result(file_data,\n\t\t\t\t\t\t   (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_API_VERSION:\n\t\tretval = put_user(USBTMC_API_VERSION,\n\t\t\t\t  (__u32 __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_GET_CAPS:\n\t\tretval = put_user(data->usb488_caps,\n\t\t\t\t  (unsigned char __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_READ_STB:\n\t\tretval = usbtmc488_ioctl_read_stb(file_data,\n\t\t\t\t\t\t  (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_REN_CONTROL:\n\t\tretval = usbtmc488_ioctl_simple(data, (void __user *)arg,\n\t\t\t\t\t\tUSBTMC488_REQUEST_REN_CONTROL);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_GOTO_LOCAL:\n\t\tretval = usbtmc488_ioctl_simple(data, (void __user *)arg,\n\t\t\t\t\t\tUSBTMC488_REQUEST_GOTO_LOCAL);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_LOCAL_LOCKOUT:\n\t\tretval = usbtmc488_ioctl_simple(data, (void __user *)arg,\n\t\t\t\t\t\tUSBTMC488_REQUEST_LOCAL_LOCKOUT);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_TRIGGER:\n\t\tretval = usbtmc488_ioctl_trigger(file_data);\n\t\tbreak;\n\n\tcase USBTMC488_IOCTL_WAIT_SRQ:\n\t\tretval = usbtmc488_ioctl_wait_srq(file_data,\n\t\t\t\t\t\t  (__u32 __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_MSG_IN_ATTR:\n\t\tretval = put_user(file_data->bmTransferAttributes,\n\t\t\t\t  (__u8 __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_AUTO_ABORT:\n\t\tretval = get_user(tmp_byte, (unsigned char __user *)arg);\n\t\tif (retval == 0)\n\t\t\tfile_data->auto_abort = !!tmp_byte;\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_GET_STB:\n\t\tretval = usbtmc_get_stb(file_data, &tmp_byte);\n\t\tif (retval > 0)\n\t\t\tretval = put_user(tmp_byte, (__u8 __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_GET_SRQ_STB:\n\t\tretval = usbtmc_ioctl_get_srq_stb(file_data,\n\t\t\t\t\t\t  (void __user *)arg);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CANCEL_IO:\n\t\tretval = usbtmc_ioctl_cancel_io(file_data);\n\t\tbreak;\n\n\tcase USBTMC_IOCTL_CLEANUP_IO:\n\t\tretval = usbtmc_ioctl_cleanup_io(file_data);\n\t\tbreak;\n\t}\n\nskip_io_on_zombie:\n\tmutex_unlock(&data->io_mutex);\n\treturn retval;\n}\n\nstatic int usbtmc_fasync(int fd, struct file *file, int on)\n{\n\tstruct usbtmc_file_data *file_data = file->private_data;\n\n\treturn fasync_helper(fd, file, on, &file_data->data->fasync);\n}\n\nstatic __poll_t usbtmc_poll(struct file *file, poll_table *wait)\n{\n\tstruct usbtmc_file_data *file_data = file->private_data;\n\tstruct usbtmc_device_data *data = file_data->data;\n\t__poll_t mask;\n\n\tmutex_lock(&data->io_mutex);\n\n\tif (data->zombie) {\n\t\tmask = EPOLLHUP | EPOLLERR;\n\t\tgoto no_poll;\n\t}\n\n\tpoll_wait(file, &data->waitq, wait);\n\n\t \n\tmask = 0;\n\tif (atomic_read(&file_data->srq_asserted))\n\t\tmask |= EPOLLPRI;\n\n\t \n\tif (usb_anchor_empty(&file_data->submitted))\n\t\tmask |= (EPOLLOUT | EPOLLWRNORM);\n\tif (!usb_anchor_empty(&file_data->in_anchor))\n\t\tmask |= (EPOLLIN | EPOLLRDNORM);\n\n\tspin_lock_irq(&file_data->err_lock);\n\tif (file_data->in_status || file_data->out_status)\n\t\tmask |= EPOLLERR;\n\tspin_unlock_irq(&file_data->err_lock);\n\n\tdev_dbg(&data->intf->dev, \"poll mask = %x\\n\", mask);\n\nno_poll:\n\tmutex_unlock(&data->io_mutex);\n\treturn mask;\n}\n\nstatic const struct file_operations fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= usbtmc_read,\n\t.write\t\t= usbtmc_write,\n\t.open\t\t= usbtmc_open,\n\t.release\t= usbtmc_release,\n\t.flush\t\t= usbtmc_flush,\n\t.unlocked_ioctl\t= usbtmc_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.fasync         = usbtmc_fasync,\n\t.poll           = usbtmc_poll,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct usb_class_driver usbtmc_class = {\n\t.name =\t\t\"usbtmc%d\",\n\t.fops =\t\t&fops,\n\t.minor_base =\tUSBTMC_MINOR_BASE,\n};\n\nstatic void usbtmc_interrupt(struct urb *urb)\n{\n\tstruct usbtmc_device_data *data = urb->context;\n\tstruct device *dev = &data->intf->dev;\n\tint status = urb->status;\n\tint rv;\n\n\tdev_dbg(&data->intf->dev, \"int status: %d len %d\\n\",\n\t\tstatus, urb->actual_length);\n\n\tswitch (status) {\n\tcase 0:  \n\t\t \n\t\tif (data->iin_buffer[0] > 0x81) {\n\t\t\tdata->bNotify1 = data->iin_buffer[0];\n\t\t\tdata->bNotify2 = data->iin_buffer[1];\n\t\t\tatomic_set(&data->iin_data_valid, 1);\n\t\t\twake_up_interruptible(&data->waitq);\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\tif (data->iin_buffer[0] == 0x81) {\n\t\t\tunsigned long flags;\n\t\t\tstruct list_head *elem;\n\n\t\t\tif (data->fasync)\n\t\t\t\tkill_fasync(&data->fasync,\n\t\t\t\t\tSIGIO, POLL_PRI);\n\n\t\t\tspin_lock_irqsave(&data->dev_lock, flags);\n\t\t\tlist_for_each(elem, &data->file_list) {\n\t\t\t\tstruct usbtmc_file_data *file_data;\n\n\t\t\t\tfile_data = list_entry(elem,\n\t\t\t\t\t\t       struct usbtmc_file_data,\n\t\t\t\t\t\t       file_elem);\n\t\t\t\tfile_data->srq_byte = data->iin_buffer[1];\n\t\t\t\tatomic_set(&file_data->srq_asserted, 1);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&data->dev_lock, flags);\n\n\t\t\tdev_dbg(dev, \"srq received bTag %x stb %x\\n\",\n\t\t\t\t(unsigned int)data->iin_buffer[0],\n\t\t\t\t(unsigned int)data->iin_buffer[1]);\n\t\t\twake_up_interruptible_all(&data->waitq);\n\t\t\tgoto exit;\n\t\t}\n\t\tdev_warn(dev, \"invalid notification: %x\\n\",\n\t\t\t data->iin_buffer[0]);\n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tdev_err(dev, \"overflow with length %d, actual length is %d\\n\",\n\t\t\tdata->iin_wMaxPacketSize, urb->actual_length);\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdev_dbg(dev, \"urb terminated, status: %d\\n\", status);\n\t\treturn;\n\t}\nexit:\n\trv = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rv)\n\t\tdev_err(dev, \"usb_submit_urb failed: %d\\n\", rv);\n}\n\nstatic void usbtmc_free_int(struct usbtmc_device_data *data)\n{\n\tif (!data->iin_ep_present || !data->iin_urb)\n\t\treturn;\n\tusb_kill_urb(data->iin_urb);\n\tkfree(data->iin_buffer);\n\tdata->iin_buffer = NULL;\n\tusb_free_urb(data->iin_urb);\n\tdata->iin_urb = NULL;\n\tkref_put(&data->kref, usbtmc_delete);\n}\n\nstatic int usbtmc_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usbtmc_device_data *data;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *bulk_in, *bulk_out, *int_in;\n\tint retcode;\n\n\tdev_dbg(&intf->dev, \"%s called\\n\", __func__);\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->intf = intf;\n\tdata->id = id;\n\tdata->usb_dev = usb_get_dev(interface_to_usbdev(intf));\n\tusb_set_intfdata(intf, data);\n\tkref_init(&data->kref);\n\tmutex_init(&data->io_mutex);\n\tinit_waitqueue_head(&data->waitq);\n\tatomic_set(&data->iin_data_valid, 0);\n\tINIT_LIST_HEAD(&data->file_list);\n\tspin_lock_init(&data->dev_lock);\n\n\tdata->zombie = 0;\n\n\t \n\tdata->bTag\t= 1;\n\t \n\tdata->iin_bTag = 2;\n\n\t \n\tiface_desc = data->intf->cur_altsetting;\n\tdata->ifnum = iface_desc->desc.bInterfaceNumber;\n\n\t \n\tretcode = usb_find_common_endpoints(iface_desc,\n\t\t\t&bulk_in, &bulk_out, NULL, NULL);\n\tif (retcode) {\n\t\tdev_err(&intf->dev, \"bulk endpoints not found\\n\");\n\t\tgoto err_put;\n\t}\n\n\tretcode = -EINVAL;\n\tdata->bulk_in = bulk_in->bEndpointAddress;\n\tdata->wMaxPacketSize = usb_endpoint_maxp(bulk_in);\n\tif (!data->wMaxPacketSize)\n\t\tgoto err_put;\n\tdev_dbg(&intf->dev, \"Found bulk in endpoint at %u\\n\", data->bulk_in);\n\n\tdata->bulk_out = bulk_out->bEndpointAddress;\n\tdev_dbg(&intf->dev, \"Found Bulk out endpoint at %u\\n\", data->bulk_out);\n\n\t \n\tretcode = usb_find_int_in_endpoint(iface_desc, &int_in);\n\tif (!retcode) {\n\t\tdata->iin_ep_present = 1;\n\t\tdata->iin_ep = int_in->bEndpointAddress;\n\t\tdata->iin_wMaxPacketSize = usb_endpoint_maxp(int_in);\n\t\tdata->iin_interval = int_in->bInterval;\n\t\tdev_dbg(&intf->dev, \"Found Int in endpoint at %u\\n\",\n\t\t\t\tdata->iin_ep);\n\t}\n\n\tretcode = get_capabilities(data);\n\tif (retcode)\n\t\tdev_err(&intf->dev, \"can't read capabilities\\n\");\n\n\tif (data->iin_ep_present) {\n\t\t \n\t\tdata->iin_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!data->iin_urb) {\n\t\t\tretcode = -ENOMEM;\n\t\t\tgoto error_register;\n\t\t}\n\n\t\t \n\t\tkref_get(&data->kref);\n\n\t\t \n\t\tdata->iin_buffer = kmalloc(data->iin_wMaxPacketSize,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif (!data->iin_buffer) {\n\t\t\tretcode = -ENOMEM;\n\t\t\tgoto error_register;\n\t\t}\n\n\t\t \n\t\tusb_fill_int_urb(data->iin_urb, data->usb_dev,\n\t\t\t\tusb_rcvintpipe(data->usb_dev, data->iin_ep),\n\t\t\t\tdata->iin_buffer, data->iin_wMaxPacketSize,\n\t\t\t\tusbtmc_interrupt,\n\t\t\t\tdata, data->iin_interval);\n\n\t\tretcode = usb_submit_urb(data->iin_urb, GFP_KERNEL);\n\t\tif (retcode) {\n\t\t\tdev_err(&intf->dev, \"Failed to submit iin_urb\\n\");\n\t\t\tgoto error_register;\n\t\t}\n\t}\n\n\tretcode = usb_register_dev(intf, &usbtmc_class);\n\tif (retcode) {\n\t\tdev_err(&intf->dev, \"Not able to get a minor (base %u, slice default): %d\\n\",\n\t\t\tUSBTMC_MINOR_BASE,\n\t\t\tretcode);\n\t\tgoto error_register;\n\t}\n\tdev_dbg(&intf->dev, \"Using minor number %d\\n\", intf->minor);\n\n\treturn 0;\n\nerror_register:\n\tusbtmc_free_int(data);\nerr_put:\n\tkref_put(&data->kref, usbtmc_delete);\n\treturn retcode;\n}\n\nstatic void usbtmc_disconnect(struct usb_interface *intf)\n{\n\tstruct usbtmc_device_data *data  = usb_get_intfdata(intf);\n\tstruct list_head *elem;\n\n\tusb_deregister_dev(intf, &usbtmc_class);\n\tmutex_lock(&data->io_mutex);\n\tdata->zombie = 1;\n\twake_up_interruptible_all(&data->waitq);\n\tlist_for_each(elem, &data->file_list) {\n\t\tstruct usbtmc_file_data *file_data;\n\n\t\tfile_data = list_entry(elem,\n\t\t\t\t       struct usbtmc_file_data,\n\t\t\t\t       file_elem);\n\t\tusb_kill_anchored_urbs(&file_data->submitted);\n\t\tusb_scuttle_anchored_urbs(&file_data->in_anchor);\n\t}\n\tmutex_unlock(&data->io_mutex);\n\tusbtmc_free_int(data);\n\tkref_put(&data->kref, usbtmc_delete);\n}\n\nstatic void usbtmc_draw_down(struct usbtmc_file_data *file_data)\n{\n\tint time;\n\n\ttime = usb_wait_anchor_empty_timeout(&file_data->submitted, 1000);\n\tif (!time)\n\t\tusb_kill_anchored_urbs(&file_data->submitted);\n\tusb_scuttle_anchored_urbs(&file_data->in_anchor);\n}\n\nstatic int usbtmc_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usbtmc_device_data *data = usb_get_intfdata(intf);\n\tstruct list_head *elem;\n\n\tif (!data)\n\t\treturn 0;\n\n\tmutex_lock(&data->io_mutex);\n\tlist_for_each(elem, &data->file_list) {\n\t\tstruct usbtmc_file_data *file_data;\n\n\t\tfile_data = list_entry(elem,\n\t\t\t\t       struct usbtmc_file_data,\n\t\t\t\t       file_elem);\n\t\tusbtmc_draw_down(file_data);\n\t}\n\n\tif (data->iin_ep_present && data->iin_urb)\n\t\tusb_kill_urb(data->iin_urb);\n\n\tmutex_unlock(&data->io_mutex);\n\treturn 0;\n}\n\nstatic int usbtmc_resume(struct usb_interface *intf)\n{\n\tstruct usbtmc_device_data *data = usb_get_intfdata(intf);\n\tint retcode = 0;\n\n\tif (data->iin_ep_present && data->iin_urb)\n\t\tretcode = usb_submit_urb(data->iin_urb, GFP_KERNEL);\n\tif (retcode)\n\t\tdev_err(&intf->dev, \"Failed to submit iin_urb\\n\");\n\n\treturn retcode;\n}\n\nstatic int usbtmc_pre_reset(struct usb_interface *intf)\n{\n\tstruct usbtmc_device_data *data  = usb_get_intfdata(intf);\n\tstruct list_head *elem;\n\n\tif (!data)\n\t\treturn 0;\n\n\tmutex_lock(&data->io_mutex);\n\n\tlist_for_each(elem, &data->file_list) {\n\t\tstruct usbtmc_file_data *file_data;\n\n\t\tfile_data = list_entry(elem,\n\t\t\t\t       struct usbtmc_file_data,\n\t\t\t\t       file_elem);\n\t\tusbtmc_ioctl_cancel_io(file_data);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbtmc_post_reset(struct usb_interface *intf)\n{\n\tstruct usbtmc_device_data *data  = usb_get_intfdata(intf);\n\n\tmutex_unlock(&data->io_mutex);\n\n\treturn 0;\n}\n\nstatic struct usb_driver usbtmc_driver = {\n\t.name\t\t= \"usbtmc\",\n\t.id_table\t= usbtmc_devices,\n\t.probe\t\t= usbtmc_probe,\n\t.disconnect\t= usbtmc_disconnect,\n\t.suspend\t= usbtmc_suspend,\n\t.resume\t\t= usbtmc_resume,\n\t.pre_reset\t= usbtmc_pre_reset,\n\t.post_reset\t= usbtmc_post_reset,\n\t.dev_groups\t= usbtmc_groups,\n};\n\nmodule_usb_driver(usbtmc_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}