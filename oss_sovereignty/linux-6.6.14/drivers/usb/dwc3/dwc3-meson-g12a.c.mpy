{
  "module_name": "dwc3-meson-g12a.c",
  "hash_id": "5dfd992e464ee77cb5e14bf4000817837000bf2306af85dfa369504a66eb045f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-meson-g12a.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/reset.h>\n#include <linux/phy/phy.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/role.h>\n#include <linux/regulator/consumer.h>\n\n \n\n#define U2P_REG_SIZE\t\t\t\t\t\t0x20\n\n#define U2P_R0\t\t\t\t\t\t\t0x0\n\t#define U2P_R0_HOST_DEVICE\t\t\t\tBIT(0)\n\t#define U2P_R0_POWER_OK\t\t\t\t\tBIT(1)\n\t#define U2P_R0_HAST_MODE\t\t\t\tBIT(2)\n\t#define U2P_R0_POWER_ON_RESET\t\t\t\tBIT(3)\n\t#define U2P_R0_ID_PULLUP\t\t\t\tBIT(4)\n\t#define U2P_R0_DRV_VBUS\t\t\t\t\tBIT(5)\n\n#define U2P_R1\t\t\t\t\t\t\t0x4\n\t#define U2P_R1_PHY_READY\t\t\t\tBIT(0)\n\t#define U2P_R1_ID_DIG\t\t\t\t\tBIT(1)\n\t#define U2P_R1_OTG_SESSION_VALID\t\t\tBIT(2)\n\t#define U2P_R1_VBUS_VALID\t\t\t\tBIT(3)\n\n \n\n#define G12A_GLUE_OFFSET\t\t\t\t\t0x80\n\n#define USB_R0\t\t\t\t\t\t\t0x00\n\t#define USB_R0_P30_LANE0_TX2RX_LOOPBACK\t\t\tBIT(17)\n\t#define USB_R0_P30_LANE0_EXT_PCLK_REQ\t\t\tBIT(18)\n\t#define USB_R0_P30_PCS_RX_LOS_MASK_VAL_MASK\t\tGENMASK(28, 19)\n\t#define USB_R0_U2D_SS_SCALEDOWN_MODE_MASK\t\tGENMASK(30, 29)\n\t#define USB_R0_U2D_ACT\t\t\t\t\tBIT(31)\n\n#define USB_R1\t\t\t\t\t\t\t0x04\n\t#define USB_R1_U3H_BIGENDIAN_GS\t\t\t\tBIT(0)\n\t#define USB_R1_U3H_PME_ENABLE\t\t\t\tBIT(1)\n\t#define USB_R1_U3H_HUB_PORT_OVERCURRENT_MASK\t\tGENMASK(4, 2)\n\t#define USB_R1_U3H_HUB_PORT_PERM_ATTACH_MASK\t\tGENMASK(9, 7)\n\t#define USB_R1_U3H_HOST_U2_PORT_DISABLE_MASK\t\tGENMASK(13, 12)\n\t#define USB_R1_U3H_HOST_U3_PORT_DISABLE\t\t\tBIT(16)\n\t#define USB_R1_U3H_HOST_PORT_POWER_CONTROL_PRESENT\tBIT(17)\n\t#define USB_R1_U3H_HOST_MSI_ENABLE\t\t\tBIT(18)\n\t#define USB_R1_U3H_FLADJ_30MHZ_REG_MASK\t\t\tGENMASK(24, 19)\n\t#define USB_R1_P30_PCS_TX_SWING_FULL_MASK\t\tGENMASK(31, 25)\n\n#define USB_R2\t\t\t\t\t\t\t0x08\n\t#define USB_R2_P30_PCS_TX_DEEMPH_3P5DB_MASK\t\tGENMASK(25, 20)\n\t#define USB_R2_P30_PCS_TX_DEEMPH_6DB_MASK\t\tGENMASK(31, 26)\n\n#define USB_R3\t\t\t\t\t\t\t0x0c\n\t#define USB_R3_P30_SSC_ENABLE\t\t\t\tBIT(0)\n\t#define USB_R3_P30_SSC_RANGE_MASK\t\t\tGENMASK(3, 1)\n\t#define USB_R3_P30_SSC_REF_CLK_SEL_MASK\t\t\tGENMASK(12, 4)\n\t#define USB_R3_P30_REF_SSP_EN\t\t\t\tBIT(13)\n\n#define USB_R4\t\t\t\t\t\t\t0x10\n\t#define USB_R4_P21_PORT_RESET_0\t\t\t\tBIT(0)\n\t#define USB_R4_P21_SLEEP_M0\t\t\t\tBIT(1)\n\t#define USB_R4_MEM_PD_MASK\t\t\t\tGENMASK(3, 2)\n\t#define USB_R4_P21_ONLY\t\t\t\t\tBIT(4)\n\n#define USB_R5\t\t\t\t\t\t\t0x14\n\t#define USB_R5_ID_DIG_SYNC\t\t\t\tBIT(0)\n\t#define USB_R5_ID_DIG_REG\t\t\t\tBIT(1)\n\t#define USB_R5_ID_DIG_CFG_MASK\t\t\t\tGENMASK(3, 2)\n\t#define USB_R5_ID_DIG_EN_0\t\t\t\tBIT(4)\n\t#define USB_R5_ID_DIG_EN_1\t\t\t\tBIT(5)\n\t#define USB_R5_ID_DIG_CURR\t\t\t\tBIT(6)\n\t#define USB_R5_ID_DIG_IRQ\t\t\t\tBIT(7)\n\t#define USB_R5_ID_DIG_TH_MASK\t\t\t\tGENMASK(15, 8)\n\t#define USB_R5_ID_DIG_CNT_MASK\t\t\t\tGENMASK(23, 16)\n\n#define PHY_COUNT\t\t\t\t\t\t3\n#define USB2_OTG_PHY\t\t\t\t\t\t1\n\nstatic struct clk_bulk_data meson_gxl_clocks[] = {\n\t{ .id = \"usb_ctrl\" },\n\t{ .id = \"ddr\" },\n};\n\nstatic struct clk_bulk_data meson_g12a_clocks[] = {\n\t{ .id = NULL },\n};\n\nstatic struct clk_bulk_data meson_a1_clocks[] = {\n\t{ .id = \"usb_ctrl\" },\n\t{ .id = \"usb_bus\" },\n\t{ .id = \"xtal_usb_ctrl\" },\n};\n\nstatic const char * const meson_gxm_phy_names[] = {\n\t\"usb2-phy0\", \"usb2-phy1\", \"usb2-phy2\",\n};\n\nstatic const char * const meson_g12a_phy_names[] = {\n\t\"usb2-phy0\", \"usb2-phy1\", \"usb3-phy0\",\n};\n\n \nstatic const char * const meson_a1_phy_names[] = {\n\t\"usb2-phy0\", \"usb2-phy1\"\n};\n\nstruct dwc3_meson_g12a;\n\nstruct dwc3_meson_g12a_drvdata {\n\tbool otg_phy_host_port_disable;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tconst char * const *phy_names;\n\tint num_phys;\n\tint (*setup_regmaps)(struct dwc3_meson_g12a *priv, void __iomem *base);\n\tint (*usb2_init_phy)(struct dwc3_meson_g12a *priv, int i,\n\t\t\t     enum phy_mode mode);\n\tint (*set_phy_mode)(struct dwc3_meson_g12a *priv, int i,\n\t\t\t    enum phy_mode mode);\n\tint (*usb_init)(struct dwc3_meson_g12a *priv);\n\tint (*usb_post_init)(struct dwc3_meson_g12a *priv);\n};\n\nstatic int dwc3_meson_gxl_setup_regmaps(struct dwc3_meson_g12a *priv,\n\t\t\t\t\tvoid __iomem *base);\nstatic int dwc3_meson_g12a_setup_regmaps(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t void __iomem *base);\n\nstatic int dwc3_meson_g12a_usb2_init_phy(struct dwc3_meson_g12a *priv, int i,\n\t\t\t\t\t enum phy_mode mode);\nstatic int dwc3_meson_gxl_usb2_init_phy(struct dwc3_meson_g12a *priv, int i,\n\t\t\t\t\tenum phy_mode mode);\n\nstatic int dwc3_meson_g12a_set_phy_mode(struct dwc3_meson_g12a *priv,\n\t\t\t\t\tint i, enum phy_mode mode);\nstatic int dwc3_meson_gxl_set_phy_mode(struct dwc3_meson_g12a *priv,\n\t\t\t\t       int i, enum phy_mode mode);\n\nstatic int dwc3_meson_g12a_usb_init(struct dwc3_meson_g12a *priv);\nstatic int dwc3_meson_gxl_usb_init(struct dwc3_meson_g12a *priv);\n\nstatic int dwc3_meson_gxl_usb_post_init(struct dwc3_meson_g12a *priv);\n\n \n\nstatic const struct dwc3_meson_g12a_drvdata gxl_drvdata = {\n\t.otg_phy_host_port_disable = true,\n\t.clks = meson_gxl_clocks,\n\t.num_clks = ARRAY_SIZE(meson_g12a_clocks),\n\t.phy_names = meson_a1_phy_names,\n\t.num_phys = ARRAY_SIZE(meson_a1_phy_names),\n\t.setup_regmaps = dwc3_meson_gxl_setup_regmaps,\n\t.usb2_init_phy = dwc3_meson_gxl_usb2_init_phy,\n\t.set_phy_mode = dwc3_meson_gxl_set_phy_mode,\n\t.usb_init = dwc3_meson_gxl_usb_init,\n\t.usb_post_init = dwc3_meson_gxl_usb_post_init,\n};\n\nstatic const struct dwc3_meson_g12a_drvdata gxm_drvdata = {\n\t.otg_phy_host_port_disable = true,\n\t.clks = meson_gxl_clocks,\n\t.num_clks = ARRAY_SIZE(meson_g12a_clocks),\n\t.phy_names = meson_gxm_phy_names,\n\t.num_phys = ARRAY_SIZE(meson_gxm_phy_names),\n\t.setup_regmaps = dwc3_meson_gxl_setup_regmaps,\n\t.usb2_init_phy = dwc3_meson_gxl_usb2_init_phy,\n\t.set_phy_mode = dwc3_meson_gxl_set_phy_mode,\n\t.usb_init = dwc3_meson_gxl_usb_init,\n\t.usb_post_init = dwc3_meson_gxl_usb_post_init,\n};\n\nstatic const struct dwc3_meson_g12a_drvdata axg_drvdata = {\n\t.clks = meson_gxl_clocks,\n\t.num_clks = ARRAY_SIZE(meson_gxl_clocks),\n\t.phy_names = meson_a1_phy_names,\n\t.num_phys = ARRAY_SIZE(meson_a1_phy_names),\n\t.setup_regmaps = dwc3_meson_gxl_setup_regmaps,\n\t.usb2_init_phy = dwc3_meson_gxl_usb2_init_phy,\n\t.set_phy_mode = dwc3_meson_gxl_set_phy_mode,\n\t.usb_init = dwc3_meson_g12a_usb_init,\n\t.usb_post_init = dwc3_meson_gxl_usb_post_init,\n};\n\nstatic const struct dwc3_meson_g12a_drvdata g12a_drvdata = {\n\t.clks = meson_g12a_clocks,\n\t.num_clks = ARRAY_SIZE(meson_g12a_clocks),\n\t.phy_names = meson_g12a_phy_names,\n\t.num_phys = ARRAY_SIZE(meson_g12a_phy_names),\n\t.setup_regmaps = dwc3_meson_g12a_setup_regmaps,\n\t.usb2_init_phy = dwc3_meson_g12a_usb2_init_phy,\n\t.set_phy_mode = dwc3_meson_g12a_set_phy_mode,\n\t.usb_init = dwc3_meson_g12a_usb_init,\n};\n\nstatic const struct dwc3_meson_g12a_drvdata a1_drvdata = {\n\t.clks = meson_a1_clocks,\n\t.num_clks = ARRAY_SIZE(meson_a1_clocks),\n\t.phy_names = meson_a1_phy_names,\n\t.num_phys = ARRAY_SIZE(meson_a1_phy_names),\n\t.setup_regmaps = dwc3_meson_g12a_setup_regmaps,\n\t.usb2_init_phy = dwc3_meson_g12a_usb2_init_phy,\n\t.set_phy_mode = dwc3_meson_g12a_set_phy_mode,\n\t.usb_init = dwc3_meson_g12a_usb_init,\n};\n\nstruct dwc3_meson_g12a {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*u2p_regmap[PHY_COUNT];\n\tstruct regmap\t\t*usb_glue_regmap;\n\tstruct reset_control\t*reset;\n\tstruct phy\t\t*phys[PHY_COUNT];\n\tenum usb_dr_mode\totg_mode;\n\tenum phy_mode\t\totg_phy_mode;\n\tunsigned int\t\tusb2_ports;\n\tunsigned int\t\tusb3_ports;\n\tstruct regulator\t*vbus;\n\tstruct usb_role_switch_desc switch_desc;\n\tstruct usb_role_switch\t*role_switch;\n\tconst struct dwc3_meson_g12a_drvdata *drvdata;\n};\n\nstatic int dwc3_meson_gxl_set_phy_mode(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t int i, enum phy_mode mode)\n{\n\treturn phy_set_mode(priv->phys[i], mode);\n}\n\nstatic int dwc3_meson_gxl_usb2_init_phy(struct dwc3_meson_g12a *priv, int i,\n\t\t\t\t\tenum phy_mode mode)\n{\n\t \n\treturn priv->drvdata->set_phy_mode(priv, i,\n\t\t\t\t(i == USB2_OTG_PHY) ? PHY_MODE_USB_DEVICE\n\t\t\t\t\t\t    : PHY_MODE_USB_HOST);\n}\n\nstatic int dwc3_meson_g12a_set_phy_mode(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t int i, enum phy_mode mode)\n{\n\tif (mode == PHY_MODE_USB_HOST)\n\t\tregmap_update_bits(priv->u2p_regmap[i], U2P_R0,\n\t\t\t\tU2P_R0_HOST_DEVICE,\n\t\t\t\tU2P_R0_HOST_DEVICE);\n\telse\n\t\tregmap_update_bits(priv->u2p_regmap[i], U2P_R0,\n\t\t\t\tU2P_R0_HOST_DEVICE, 0);\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_g12a_usb2_init_phy(struct dwc3_meson_g12a *priv, int i,\n\t\t\t\t\t enum phy_mode mode)\n{\n\tint ret;\n\n\tregmap_update_bits(priv->u2p_regmap[i], U2P_R0,\n\t\t\tU2P_R0_POWER_ON_RESET,\n\t\t\tU2P_R0_POWER_ON_RESET);\n\n\tif (i == USB2_OTG_PHY) {\n\t\tregmap_update_bits(priv->u2p_regmap[i], U2P_R0,\n\t\t\t\t   U2P_R0_ID_PULLUP | U2P_R0_DRV_VBUS,\n\t\t\t\t   U2P_R0_ID_PULLUP | U2P_R0_DRV_VBUS);\n\n\t\tret = priv->drvdata->set_phy_mode(priv, i, mode);\n\t} else\n\t\tret = priv->drvdata->set_phy_mode(priv, i,\n\t\t\t\t\t\t  PHY_MODE_USB_HOST);\n\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->u2p_regmap[i], U2P_R0,\n\t\t\tU2P_R0_POWER_ON_RESET, 0);\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_g12a_usb2_init(struct dwc3_meson_g12a *priv,\n\t\t\t\t     enum phy_mode mode)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < priv->drvdata->num_phys; ++i) {\n\t\tif (!priv->phys[i])\n\t\t\tcontinue;\n\n\t\tif (!strstr(priv->drvdata->phy_names[i], \"usb2\"))\n\t\t\tcontinue;\n\n\t\tret = priv->drvdata->usb2_init_phy(priv, i, mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc3_meson_g12a_usb3_init(struct dwc3_meson_g12a *priv)\n{\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R3,\n\t\t\tUSB_R3_P30_SSC_RANGE_MASK |\n\t\t\tUSB_R3_P30_REF_SSP_EN,\n\t\t\tUSB_R3_P30_SSC_ENABLE |\n\t\t\tFIELD_PREP(USB_R3_P30_SSC_RANGE_MASK, 2) |\n\t\t\tUSB_R3_P30_REF_SSP_EN);\n\tudelay(2);\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R2,\n\t\t\tUSB_R2_P30_PCS_TX_DEEMPH_3P5DB_MASK,\n\t\t\tFIELD_PREP(USB_R2_P30_PCS_TX_DEEMPH_3P5DB_MASK, 0x15));\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R2,\n\t\t\tUSB_R2_P30_PCS_TX_DEEMPH_6DB_MASK,\n\t\t\tFIELD_PREP(USB_R2_P30_PCS_TX_DEEMPH_6DB_MASK, 0x20));\n\n\tudelay(2);\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R1,\n\t\t\tUSB_R1_U3H_HOST_PORT_POWER_CONTROL_PRESENT,\n\t\t\tUSB_R1_U3H_HOST_PORT_POWER_CONTROL_PRESENT);\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R1,\n\t\t\tUSB_R1_P30_PCS_TX_SWING_FULL_MASK,\n\t\t\tFIELD_PREP(USB_R1_P30_PCS_TX_SWING_FULL_MASK, 127));\n}\n\nstatic void dwc3_meson_g12a_usb_otg_apply_mode(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t       enum phy_mode mode)\n{\n\tif (mode == PHY_MODE_USB_DEVICE) {\n\t\tif (priv->otg_mode != USB_DR_MODE_OTG &&\n\t\t    priv->drvdata->otg_phy_host_port_disable)\n\t\t\t \n\t\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R1,\n\t\t\t\tUSB_R1_U3H_HOST_U2_PORT_DISABLE_MASK,\n\t\t\t\tFIELD_PREP(USB_R1_U3H_HOST_U2_PORT_DISABLE_MASK,\n\t\t\t\t\t   BIT(USB2_OTG_PHY)));\n\n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R0,\n\t\t\t\tUSB_R0_U2D_ACT, USB_R0_U2D_ACT);\n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R0,\n\t\t\t\tUSB_R0_U2D_SS_SCALEDOWN_MODE_MASK, 0);\n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R4,\n\t\t\t\tUSB_R4_P21_SLEEP_M0, USB_R4_P21_SLEEP_M0);\n\t} else {\n\t\tif (priv->otg_mode != USB_DR_MODE_OTG &&\n\t\t    priv->drvdata->otg_phy_host_port_disable) {\n\t\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R1,\n\t\t\t\tUSB_R1_U3H_HOST_U2_PORT_DISABLE_MASK, 0);\n\t\t\tmsleep(500);\n\t\t}\n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R0,\n\t\t\t\tUSB_R0_U2D_ACT, 0);\n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R4,\n\t\t\t\tUSB_R4_P21_SLEEP_M0, 0);\n\t}\n}\n\nstatic int dwc3_meson_g12a_usb_init_glue(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t enum phy_mode mode)\n{\n\tint ret;\n\n\tret = dwc3_meson_g12a_usb2_init(priv, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R1,\n\t\t\tUSB_R1_U3H_FLADJ_30MHZ_REG_MASK,\n\t\t\tFIELD_PREP(USB_R1_U3H_FLADJ_30MHZ_REG_MASK, 0x20));\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R5,\n\t\t\tUSB_R5_ID_DIG_EN_0,\n\t\t\tUSB_R5_ID_DIG_EN_0);\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R5,\n\t\t\tUSB_R5_ID_DIG_EN_1,\n\t\t\tUSB_R5_ID_DIG_EN_1);\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R5,\n\t\t\tUSB_R5_ID_DIG_TH_MASK,\n\t\t\tFIELD_PREP(USB_R5_ID_DIG_TH_MASK, 0xff));\n\n\t \n\tif (priv->usb3_ports)\n\t\tdwc3_meson_g12a_usb3_init(priv);\n\n\tdwc3_meson_g12a_usb_otg_apply_mode(priv, mode);\n\n\treturn 0;\n}\n\nstatic const struct regmap_config phy_meson_g12a_usb_glue_regmap_conf = {\n\t.name = \"usb-glue\",\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = USB_R5,\n};\n\nstatic int dwc3_meson_g12a_get_phys(struct dwc3_meson_g12a *priv)\n{\n\tconst char *phy_name;\n\tint i;\n\n\tfor (i = 0 ; i < priv->drvdata->num_phys ; ++i) {\n\t\tphy_name = priv->drvdata->phy_names[i];\n\t\tpriv->phys[i] = devm_phy_optional_get(priv->dev, phy_name);\n\t\tif (!priv->phys[i])\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(priv->phys[i]))\n\t\t\treturn PTR_ERR(priv->phys[i]);\n\n\t\tif (strstr(phy_name, \"usb3\"))\n\t\t\tpriv->usb3_ports++;\n\t\telse\n\t\t\tpriv->usb2_ports++;\n\t}\n\n\tdev_info(priv->dev, \"USB2 ports: %d\\n\", priv->usb2_ports);\n\tdev_info(priv->dev, \"USB3 ports: %d\\n\", priv->usb3_ports);\n\n\treturn 0;\n}\n\nstatic enum phy_mode dwc3_meson_g12a_get_id(struct dwc3_meson_g12a *priv)\n{\n\tu32 reg;\n\n\tregmap_read(priv->usb_glue_regmap, USB_R5, &reg);\n\n\tif (reg & (USB_R5_ID_DIG_SYNC | USB_R5_ID_DIG_REG))\n\t\treturn PHY_MODE_USB_DEVICE;\n\n\treturn PHY_MODE_USB_HOST;\n}\n\nstatic int dwc3_meson_g12a_otg_mode_set(struct dwc3_meson_g12a *priv,\n\t\t\t\t\tenum phy_mode mode)\n{\n\tint ret;\n\n\tif (!priv->phys[USB2_OTG_PHY])\n\t\treturn -EINVAL;\n\n\tif (mode == PHY_MODE_USB_HOST)\n\t\tdev_info(priv->dev, \"switching to Host Mode\\n\");\n\telse\n\t\tdev_info(priv->dev, \"switching to Device Mode\\n\");\n\n\tif (priv->vbus) {\n\t\tif (mode == PHY_MODE_USB_DEVICE)\n\t\t\tret = regulator_disable(priv->vbus);\n\t\telse\n\t\t\tret = regulator_enable(priv->vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpriv->otg_phy_mode = mode;\n\n\tret = priv->drvdata->set_phy_mode(priv, USB2_OTG_PHY, mode);\n\tif (ret)\n\t\treturn ret;\n\n\tdwc3_meson_g12a_usb_otg_apply_mode(priv, mode);\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_g12a_role_set(struct usb_role_switch *sw,\n\t\t\t\t    enum usb_role role)\n{\n\tstruct dwc3_meson_g12a *priv = usb_role_switch_get_drvdata(sw);\n\tenum phy_mode mode;\n\n\tif (role == USB_ROLE_NONE)\n\t\treturn 0;\n\n\tmode = (role == USB_ROLE_HOST) ? PHY_MODE_USB_HOST\n\t\t\t\t       : PHY_MODE_USB_DEVICE;\n\n\tif (mode == priv->otg_phy_mode)\n\t\treturn 0;\n\n\tif (priv->drvdata->otg_phy_host_port_disable)\n\t\tdev_warn_once(priv->dev, \"Broken manual OTG switch\\n\");\n\n\treturn dwc3_meson_g12a_otg_mode_set(priv, mode);\n}\n\nstatic enum usb_role dwc3_meson_g12a_role_get(struct usb_role_switch *sw)\n{\n\tstruct dwc3_meson_g12a *priv = usb_role_switch_get_drvdata(sw);\n\n\treturn priv->otg_phy_mode == PHY_MODE_USB_HOST ?\n\t\tUSB_ROLE_HOST : USB_ROLE_DEVICE;\n}\n\nstatic irqreturn_t dwc3_meson_g12a_irq_thread(int irq, void *data)\n{\n\tstruct dwc3_meson_g12a *priv = data;\n\tenum phy_mode otg_id;\n\n\totg_id = dwc3_meson_g12a_get_id(priv);\n\tif (otg_id != priv->otg_phy_mode) {\n\t\tif (dwc3_meson_g12a_otg_mode_set(priv, otg_id))\n\t\t\tdev_warn(priv->dev, \"Failed to switch OTG mode\\n\");\n\t}\n\n\tregmap_update_bits(priv->usb_glue_regmap, USB_R5,\n\t\t\t   USB_R5_ID_DIG_IRQ, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct device *dwc3_meson_g12_find_child(struct device *dev,\n\t\t\t\t\t\tconst char *compatible)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\n\tnp = of_get_compatible_child(dev->of_node, compatible);\n\tif (!np)\n\t\treturn NULL;\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn NULL;\n\n\treturn &pdev->dev;\n}\n\nstatic int dwc3_meson_g12a_otg_init(struct platform_device *pdev,\n\t\t\t\t    struct dwc3_meson_g12a *priv)\n{\n\tenum phy_mode otg_id;\n\tint ret, irq;\n\tstruct device *dev = &pdev->dev;\n\n\tif (priv->otg_mode == USB_DR_MODE_OTG) {\n\t\t \n\t\tregmap_update_bits(priv->usb_glue_regmap, USB_R5,\n\t\t\t\t   USB_R5_ID_DIG_IRQ, 0);\n\n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\t\tdwc3_meson_g12a_irq_thread,\n\t\t\t\t\t\tIRQF_ONESHOT, pdev->name, priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (priv->otg_mode == USB_DR_MODE_OTG) {\n\t\totg_id = dwc3_meson_g12a_get_id(priv);\n\t\tif (otg_id != priv->otg_phy_mode) {\n\t\t\tif (dwc3_meson_g12a_otg_mode_set(priv, otg_id))\n\t\t\t\tdev_warn(dev, \"Failed to switch OTG mode\\n\");\n\t\t}\n\t}\n\n\t \n\tpriv->switch_desc.usb2_port = dwc3_meson_g12_find_child(dev,\n\t\t\t\t\t\t\t\t\"snps,dwc3\");\n\tpriv->switch_desc.udc = dwc3_meson_g12_find_child(dev, \"snps,dwc2\");\n\tpriv->switch_desc.allow_userspace_control = true;\n\tpriv->switch_desc.set = dwc3_meson_g12a_role_set;\n\tpriv->switch_desc.get = dwc3_meson_g12a_role_get;\n\tpriv->switch_desc.driver_data = priv;\n\n\tpriv->role_switch = usb_role_switch_register(dev, &priv->switch_desc);\n\tif (IS_ERR(priv->role_switch))\n\t\tdev_warn(dev, \"Unable to register Role Switch\\n\");\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_gxl_setup_regmaps(struct dwc3_meson_g12a *priv,\n\t\t\t\t\tvoid __iomem *base)\n{\n\t \n\tpriv->usb_glue_regmap = devm_regmap_init_mmio(priv->dev, base,\n\t\t\t\t\t&phy_meson_g12a_usb_glue_regmap_conf);\n\treturn PTR_ERR_OR_ZERO(priv->usb_glue_regmap);\n}\n\nstatic int dwc3_meson_g12a_setup_regmaps(struct dwc3_meson_g12a *priv,\n\t\t\t\t\t void __iomem *base)\n{\n\tint i;\n\n\tpriv->usb_glue_regmap = devm_regmap_init_mmio(priv->dev,\n\t\t\t\t\tbase + G12A_GLUE_OFFSET,\n\t\t\t\t\t&phy_meson_g12a_usb_glue_regmap_conf);\n\tif (IS_ERR(priv->usb_glue_regmap))\n\t\treturn PTR_ERR(priv->usb_glue_regmap);\n\n\t \n\tfor (i = 0; i < priv->drvdata->num_phys; i++) {\n\t\tstruct regmap_config u2p_regmap_config = {\n\t\t\t.reg_bits = 8,\n\t\t\t.val_bits = 32,\n\t\t\t.reg_stride = 4,\n\t\t\t.max_register = U2P_R1,\n\t\t};\n\n\t\tif (!strstr(priv->drvdata->phy_names[i], \"usb2\"))\n\t\t\tcontinue;\n\n\t\tu2p_regmap_config.name = devm_kasprintf(priv->dev, GFP_KERNEL,\n\t\t\t\t\t\t\t\"u2p-%d\", i);\n\t\tif (!u2p_regmap_config.name)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv->u2p_regmap[i] = devm_regmap_init_mmio(priv->dev,\n\t\t\t\t\t\tbase + (i * U2P_REG_SIZE),\n\t\t\t\t\t\t&u2p_regmap_config);\n\t\tif (IS_ERR(priv->u2p_regmap[i]))\n\t\t\treturn PTR_ERR(priv->u2p_regmap[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_g12a_usb_init(struct dwc3_meson_g12a *priv)\n{\n\treturn dwc3_meson_g12a_usb_init_glue(priv, priv->otg_phy_mode);\n}\n\nstatic int dwc3_meson_gxl_usb_init(struct dwc3_meson_g12a *priv)\n{\n\treturn dwc3_meson_g12a_usb_init_glue(priv, PHY_MODE_USB_DEVICE);\n}\n\nstatic int dwc3_meson_gxl_usb_post_init(struct dwc3_meson_g12a *priv)\n{\n\tint ret;\n\n\tret = priv->drvdata->set_phy_mode(priv, USB2_OTG_PHY,\n\t\t\t\t\t  priv->otg_phy_mode);\n\tif (ret)\n\t\treturn ret;\n\n\tdwc3_meson_g12a_usb_otg_apply_mode(priv, priv->otg_phy_mode);\n\n\treturn 0;\n}\n\nstatic int dwc3_meson_g12a_probe(struct platform_device *pdev)\n{\n\tstruct dwc3_meson_g12a\t*priv;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct device_node\t*np = dev->of_node;\n\tvoid __iomem *base;\n\tint ret, i;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tpriv->drvdata = of_device_get_match_data(&pdev->dev);\n\tpriv->dev = dev;\n\n\tpriv->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(priv->vbus)) {\n\t\tif (PTR_ERR(priv->vbus) == -EPROBE_DEFER)\n\t\t\treturn PTR_ERR(priv->vbus);\n\t\tpriv->vbus = NULL;\n\t}\n\n\tret = devm_clk_bulk_get(dev,\n\t\t\t\tpriv->drvdata->num_clks,\n\t\t\t\tpriv->drvdata->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(priv->drvdata->num_clks,\n\t\t\t\t      priv->drvdata->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->reset = devm_reset_control_get_shared(dev, NULL);\n\tif (IS_ERR(priv->reset)) {\n\t\tret = PTR_ERR(priv->reset);\n\t\tdev_err(dev, \"failed to get device reset, err=%d\\n\", ret);\n\t\tgoto err_disable_clks;\n\t}\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\tgoto err_disable_clks;\n\n\tret = dwc3_meson_g12a_get_phys(priv);\n\tif (ret)\n\t\tgoto err_rearm;\n\n\tret = priv->drvdata->setup_regmaps(priv, base);\n\tif (ret)\n\t\tgoto err_rearm;\n\n\tif (priv->vbus) {\n\t\tret = regulator_enable(priv->vbus);\n\t\tif (ret)\n\t\t\tgoto err_rearm;\n\t}\n\n\t \n\tpriv->otg_mode = usb_get_dr_mode(dev);\n\n\tif (priv->otg_mode == USB_DR_MODE_PERIPHERAL)\n\t\tpriv->otg_phy_mode = PHY_MODE_USB_DEVICE;\n\telse\n\t\tpriv->otg_phy_mode = PHY_MODE_USB_HOST;\n\n\tret = priv->drvdata->usb_init(priv);\n\tif (ret)\n\t\tgoto err_disable_regulator;\n\n\t \n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tret = phy_init(priv->phys[i]);\n\t\tif (ret)\n\t\t\tgoto err_disable_regulator;\n\t}\n\n\t \n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tret = phy_power_on(priv->phys[i]);\n\t\tif (ret)\n\t\t\tgoto err_phys_exit;\n\t}\n\n\tif (priv->drvdata->usb_post_init) {\n\t\tret = priv->drvdata->usb_post_init(priv);\n\t\tif (ret)\n\t\t\tgoto err_phys_power;\n\t}\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret)\n\t\tgoto err_phys_power;\n\n\tret = dwc3_meson_g12a_otg_init(pdev, priv);\n\tif (ret)\n\t\tgoto err_plat_depopulate;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\treturn 0;\n\nerr_plat_depopulate:\n\tof_platform_depopulate(dev);\n\nerr_phys_power:\n\tfor (i = 0 ; i < PHY_COUNT ; ++i)\n\t\tphy_power_off(priv->phys[i]);\n\nerr_phys_exit:\n\tfor (i = 0 ; i < PHY_COUNT ; ++i)\n\t\tphy_exit(priv->phys[i]);\n\nerr_disable_regulator:\n\tif (priv->vbus)\n\t\tregulator_disable(priv->vbus);\n\nerr_rearm:\n\treset_control_rearm(priv->reset);\n\nerr_disable_clks:\n\tclk_bulk_disable_unprepare(priv->drvdata->num_clks,\n\t\t\t\t   priv->drvdata->clks);\n\n\treturn ret;\n}\n\nstatic void dwc3_meson_g12a_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_meson_g12a *priv = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint i;\n\n\tusb_role_switch_unregister(priv->role_switch);\n\n\tof_platform_depopulate(dev);\n\n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tphy_power_off(priv->phys[i]);\n\t\tphy_exit(priv->phys[i]);\n\t}\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_suspended(dev);\n\n\treset_control_rearm(priv->reset);\n\n\tclk_bulk_disable_unprepare(priv->drvdata->num_clks,\n\t\t\t\t   priv->drvdata->clks);\n}\n\nstatic int __maybe_unused dwc3_meson_g12a_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_meson_g12a\t*priv = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(priv->drvdata->num_clks,\n\t\t\t\t   priv->drvdata->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_meson_g12a_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_meson_g12a\t*priv = dev_get_drvdata(dev);\n\n\treturn clk_bulk_prepare_enable(priv->drvdata->num_clks,\n\t\t\t\t       priv->drvdata->clks);\n}\n\nstatic int __maybe_unused dwc3_meson_g12a_suspend(struct device *dev)\n{\n\tstruct dwc3_meson_g12a *priv = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tif (priv->vbus && priv->otg_phy_mode == PHY_MODE_USB_HOST) {\n\t\tret = regulator_disable(priv->vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tphy_power_off(priv->phys[i]);\n\t\tphy_exit(priv->phys[i]);\n\t}\n\n\treset_control_rearm(priv->reset);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_meson_g12a_resume(struct device *dev)\n{\n\tstruct dwc3_meson_g12a *priv = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tret = reset_control_reset(priv->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = priv->drvdata->usb_init(priv);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tret = phy_init(priv->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0 ; i < PHY_COUNT ; ++i) {\n\t\tret = phy_power_on(priv->phys[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->vbus && priv->otg_phy_mode == PHY_MODE_USB_HOST) {\n\t\tret = regulator_enable(priv->vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (priv->drvdata->usb_post_init) {\n\t\tret = priv->drvdata->usb_post_init(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dwc3_meson_g12a_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_meson_g12a_suspend, dwc3_meson_g12a_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_meson_g12a_runtime_suspend,\n\t\t\t   dwc3_meson_g12a_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id dwc3_meson_g12a_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson-gxl-usb-ctrl\",\n\t\t.data = &gxl_drvdata,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-gxm-usb-ctrl\",\n\t\t.data = &gxm_drvdata,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-axg-usb-ctrl\",\n\t\t.data = &axg_drvdata,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-g12a-usb-ctrl\",\n\t\t.data = &g12a_drvdata,\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson-a1-usb-ctrl\",\n\t\t.data = &a1_drvdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dwc3_meson_g12a_match);\n\nstatic struct platform_driver dwc3_meson_g12a_driver = {\n\t.probe\t\t= dwc3_meson_g12a_probe,\n\t.remove_new\t= dwc3_meson_g12a_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-meson-g12a\",\n\t\t.of_match_table = dwc3_meson_g12a_match,\n\t\t.pm\t= &dwc3_meson_g12a_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dwc3_meson_g12a_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Amlogic Meson G12A USB Glue Layer\");\nMODULE_AUTHOR(\"Neil Armstrong <narmstrong@baylibre.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}