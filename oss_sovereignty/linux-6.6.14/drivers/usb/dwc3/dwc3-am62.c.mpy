{
  "module_name": "dwc3-am62.c",
  "hash_id": "e7abe79f7bd125cf924accc50b48e94be195929a709cfe068780c5206bb7b7e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-am62.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/regmap.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"core.h\"\n\n \n#define USBSS_PID\t\t\t0x0\n#define USBSS_OVERCURRENT_CTRL\t\t0x4\n#define USBSS_PHY_CONFIG\t\t0x8\n#define USBSS_PHY_TEST\t\t\t0xc\n#define USBSS_CORE_STAT\t\t\t0x14\n#define USBSS_HOST_VBUS_CTRL\t\t0x18\n#define USBSS_MODE_CONTROL\t\t0x1c\n#define USBSS_WAKEUP_CONFIG\t\t0x30\n#define USBSS_WAKEUP_STAT\t\t0x34\n#define USBSS_OVERRIDE_CONFIG\t\t0x38\n#define USBSS_IRQ_MISC_STATUS_RAW\t0x430\n#define USBSS_IRQ_MISC_STATUS\t\t0x434\n#define USBSS_IRQ_MISC_ENABLE_SET\t0x438\n#define USBSS_IRQ_MISC_ENABLE_CLR\t0x43c\n#define USBSS_IRQ_MISC_EOI\t\t0x440\n#define USBSS_INTR_TEST\t\t\t0x490\n#define USBSS_VBUS_FILTER\t\t0x614\n#define USBSS_VBUS_STAT\t\t\t0x618\n#define USBSS_DEBUG_CFG\t\t\t0x708\n#define USBSS_DEBUG_DATA\t\t0x70c\n#define USBSS_HOST_HUB_CTRL\t\t0x714\n\n \n#define USBSS_PHY_VBUS_SEL_MASK\t\tGENMASK(2, 1)\n#define USBSS_PHY_VBUS_SEL_SHIFT\t1\n#define USBSS_PHY_LANE_REVERSE\t\tBIT(0)\n\n \n#define USBSS_CORE_OPERATIONAL_MODE_MASK\tGENMASK(13, 12)\n#define USBSS_CORE_OPERATIONAL_MODE_SHIFT\t12\n\n \n#define USBSS_MODE_VALID\tBIT(0)\n\n \n#define USBSS_WAKEUP_CFG_OVERCURRENT_EN\tBIT(3)\n#define USBSS_WAKEUP_CFG_LINESTATE_EN\tBIT(2)\n#define USBSS_WAKEUP_CFG_SESSVALID_EN\tBIT(1)\n#define USBSS_WAKEUP_CFG_VBUSVALID_EN\tBIT(0)\n\n#define USBSS_WAKEUP_CFG_ALL\t(USBSS_WAKEUP_CFG_VBUSVALID_EN | \\\n\t\t\t\t USBSS_WAKEUP_CFG_SESSVALID_EN | \\\n\t\t\t\t USBSS_WAKEUP_CFG_LINESTATE_EN | \\\n\t\t\t\t USBSS_WAKEUP_CFG_OVERCURRENT_EN)\n\n#define USBSS_WAKEUP_CFG_NONE\t0\n\n \n#define USBSS_WAKEUP_STAT_OVERCURRENT\tBIT(4)\n#define USBSS_WAKEUP_STAT_LINESTATE\tBIT(3)\n#define USBSS_WAKEUP_STAT_SESSVALID\tBIT(2)\n#define USBSS_WAKEUP_STAT_VBUSVALID\tBIT(1)\n#define USBSS_WAKEUP_STAT_CLR\t\tBIT(0)\n\n \n#define USBSS_IRQ_MISC_RAW_VBUSVALID\tBIT(22)\n#define USBSS_IRQ_MISC_RAW_SESSVALID\tBIT(20)\n\n \n#define USBSS_IRQ_MISC_VBUSVALID\tBIT(22)\n#define USBSS_IRQ_MISC_SESSVALID\tBIT(20)\n\n \n#define USBSS_IRQ_MISC_ENABLE_SET_VBUSVALID\tBIT(22)\n#define USBSS_IRQ_MISC_ENABLE_SET_SESSVALID\tBIT(20)\n\n \n#define USBSS_IRQ_MISC_ENABLE_CLR_VBUSVALID\tBIT(22)\n#define USBSS_IRQ_MISC_ENABLE_CLR_SESSVALID\tBIT(20)\n\n \n#define USBSS_IRQ_MISC_EOI_VECTOR\tBIT(0)\n\n \n#define USBSS_VBUS_STAT_SESSVALID\tBIT(2)\n#define USBSS_VBUS_STAT_VBUSVALID\tBIT(0)\n\n \n#define PHY_PLL_REFCLK_MASK\tGENMASK(3, 0)\n\n#define DWC3_AM62_AUTOSUSPEND_DELAY\t100\n\nstruct dwc3_am62 {\n\tstruct device *dev;\n\tvoid __iomem *usbss;\n\tstruct clk *usb2_refclk;\n\tint rate_code;\n\tstruct regmap *syscon;\n\tunsigned int offset;\n\tunsigned int vbus_divider;\n\tu32 wakeup_stat;\n};\n\nstatic const int dwc3_ti_rate_table[] = {\t \n\t9600,\n\t10000,\n\t12000,\n\t19200,\n\t20000,\n\t24000,\n\t25000,\n\t26000,\n\t38400,\n\t40000,\n\t58000,\n\t50000,\n\t52000,\n};\n\nstatic inline u32 dwc3_ti_readl(struct dwc3_am62 *am62, u32 offset)\n{\n\treturn readl((am62->usbss) + offset);\n}\n\nstatic inline void dwc3_ti_writel(struct dwc3_am62 *am62, u32 offset, u32 value)\n{\n\twritel(value, (am62->usbss) + offset);\n}\n\nstatic int phy_syscon_pll_refclk(struct dwc3_am62 *am62)\n{\n\tstruct device *dev = am62->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct regmap *syscon;\n\tint ret;\n\n\tsyscon = syscon_regmap_lookup_by_phandle(node, \"ti,syscon-phy-pll-refclk\");\n\tif (IS_ERR(syscon)) {\n\t\tdev_err(dev, \"unable to get ti,syscon-phy-pll-refclk regmap\\n\");\n\t\treturn PTR_ERR(syscon);\n\t}\n\n\tam62->syscon = syscon;\n\n\tret = of_parse_phandle_with_fixed_args(node, \"ti,syscon-phy-pll-refclk\", 1,\n\t\t\t\t\t       0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tam62->offset = args.args[0];\n\n\tret = regmap_update_bits(am62->syscon, am62->offset, PHY_PLL_REFCLK_MASK, am62->rate_code);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set phy pll reference clock rate\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_ti_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct dwc3_am62 *am62;\n\tint i, ret;\n\tunsigned long rate;\n\tu32 reg;\n\n\tam62 = devm_kzalloc(dev, sizeof(*am62), GFP_KERNEL);\n\tif (!am62)\n\t\treturn -ENOMEM;\n\n\tam62->dev = dev;\n\tplatform_set_drvdata(pdev, am62);\n\n\tam62->usbss = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(am62->usbss)) {\n\t\tdev_err(dev, \"can't map IOMEM resource\\n\");\n\t\treturn PTR_ERR(am62->usbss);\n\t}\n\n\tam62->usb2_refclk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(am62->usb2_refclk)) {\n\t\tdev_err(dev, \"can't get usb2_refclk\\n\");\n\t\treturn PTR_ERR(am62->usb2_refclk);\n\t}\n\n\t \n\trate = clk_get_rate(am62->usb2_refclk);\n\trate /= 1000;\t\n\tfor (i = 0; i < ARRAY_SIZE(dwc3_ti_rate_table); i++) {\n\t\tif (dwc3_ti_rate_table[i] == rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(dwc3_ti_rate_table)) {\n\t\tdev_err(dev, \"unsupported usb2_refclk rate: %lu KHz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tam62->rate_code = i;\n\n\t \n\tret = phy_syscon_pll_refclk(am62);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tam62->vbus_divider = device_property_read_bool(dev, \"ti,vbus-divider\");\n\treg = dwc3_ti_readl(am62, USBSS_PHY_CONFIG);\n\tif (am62->vbus_divider)\n\t\treg |= 1 << USBSS_PHY_VBUS_SEL_SHIFT;\n\n\tdwc3_ti_writel(am62, USBSS_PHY_CONFIG, reg);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\t \n\tpm_suspend_ignore_children(dev, false);\n\tclk_prepare_enable(am62->usb2_refclk);\n\tpm_runtime_get_noresume(dev);\n\n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create dwc3 core: %d\\n\", ret);\n\t\tgoto err_pm_disable;\n\t}\n\n\t \n\treg = dwc3_ti_readl(am62, USBSS_MODE_CONTROL);\n\treg |= USBSS_MODE_VALID;\n\tdwc3_ti_writel(am62, USBSS_MODE_CONTROL, reg);\n\n\t \n\tdevice_set_wakeup_capable(dev, true);\n\tret = device_wakeup_enable(dev);\n\tif (ret)\n\t\tdev_err(dev, \"couldn't enable device as a wakeup source: %d\\n\", ret);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, DWC3_AM62_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn 0;\n\nerr_pm_disable:\n\tclk_disable_unprepare(am62->usb2_refclk);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\treturn ret;\n}\n\nstatic int dwc3_ti_remove_core(struct device *dev, void *c)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tplatform_device_unregister(pdev);\n\treturn 0;\n}\n\nstatic void dwc3_ti_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct dwc3_am62 *am62 = platform_get_drvdata(pdev);\n\tu32 reg;\n\n\tdevice_for_each_child(dev, NULL, dwc3_ti_remove_core);\n\n\t \n\treg = dwc3_ti_readl(am62, USBSS_MODE_CONTROL);\n\treg &= ~USBSS_MODE_VALID;\n\tdwc3_ti_writel(am62, USBSS_MODE_CONTROL, reg);\n\n\tpm_runtime_put_sync(dev);\n\tclk_disable_unprepare(am62->usb2_refclk);\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n}\n\n#ifdef CONFIG_PM\nstatic int dwc3_ti_suspend_common(struct device *dev)\n{\n\tstruct dwc3_am62 *am62 = dev_get_drvdata(dev);\n\tu32 reg, current_prtcap_dir;\n\n\tif (device_may_wakeup(dev)) {\n\t\treg = dwc3_ti_readl(am62, USBSS_CORE_STAT);\n\t\tcurrent_prtcap_dir = (reg & USBSS_CORE_OPERATIONAL_MODE_MASK)\n\t\t\t\t     >> USBSS_CORE_OPERATIONAL_MODE_SHIFT;\n\t\t \n\t\treg = dwc3_ti_readl(am62, USBSS_WAKEUP_CONFIG);\n\t\tif (current_prtcap_dir == DWC3_GCTL_PRTCAP_HOST) {\n\t\t\treg = USBSS_WAKEUP_CFG_LINESTATE_EN | USBSS_WAKEUP_CFG_OVERCURRENT_EN;\n\t\t} else {\n\t\t\treg = USBSS_WAKEUP_CFG_VBUSVALID_EN | USBSS_WAKEUP_CFG_SESSVALID_EN;\n\t\t\t \n\t\t}\n\t\tdwc3_ti_writel(am62, USBSS_WAKEUP_CONFIG, reg);\n\t\t \n\t\tdwc3_ti_writel(am62, USBSS_WAKEUP_STAT, USBSS_WAKEUP_STAT_CLR);\n\t}\n\n\tclk_disable_unprepare(am62->usb2_refclk);\n\n\treturn 0;\n}\n\nstatic int dwc3_ti_resume_common(struct device *dev)\n{\n\tstruct dwc3_am62 *am62 = dev_get_drvdata(dev);\n\tu32 reg;\n\n\tclk_prepare_enable(am62->usb2_refclk);\n\n\tif (device_may_wakeup(dev)) {\n\t\t \n\t\tdwc3_ti_writel(am62, USBSS_WAKEUP_CONFIG, USBSS_WAKEUP_CFG_NONE);\n\t}\n\n\treg = dwc3_ti_readl(am62, USBSS_WAKEUP_STAT);\n\tam62->wakeup_stat = reg;\n\n\treturn 0;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(dwc3_ti_pm_ops, dwc3_ti_suspend_common,\n\t\t\t    dwc3_ti_resume_common, NULL);\n\n#define DEV_PM_OPS\t(&dwc3_ti_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic const struct of_device_id dwc3_ti_of_match[] = {\n\t{ .compatible = \"ti,am62-usb\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dwc3_ti_of_match);\n\nstatic struct platform_driver dwc3_ti_driver = {\n\t.probe\t\t= dwc3_ti_probe,\n\t.remove_new\t= dwc3_ti_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-am62\",\n\t\t.pm\t= DEV_PM_OPS,\n\t\t.of_match_table = dwc3_ti_of_match,\n\t},\n};\n\nmodule_platform_driver(dwc3_ti_driver);\n\nMODULE_ALIAS(\"platform:dwc3-am62\");\nMODULE_AUTHOR(\"Aswath Govindraju <a-govindraju@ti.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"DesignWare USB3 TI Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}