{
  "module_name": "core.c",
  "hash_id": "0237f1e280ba6139a046868b29cf67b99c463a875487a038ce252e55b3998a3b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/version.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/acpi.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/reset.h>\n#include <linux/bitfield.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/of.h>\n#include <linux/usb/otg.h>\n\n#include \"core.h\"\n#include \"gadget.h\"\n#include \"io.h\"\n\n#include \"debug.h\"\n\n#define DWC3_DEFAULT_AUTOSUSPEND_DELAY\t5000  \n\n \nstatic int dwc3_get_dr_mode(struct dwc3 *dwc)\n{\n\tenum usb_dr_mode mode;\n\tstruct device *dev = dwc->dev;\n\tunsigned int hw_mode;\n\n\tif (dwc->dr_mode == USB_DR_MODE_UNKNOWN)\n\t\tdwc->dr_mode = USB_DR_MODE_OTG;\n\n\tmode = dwc->dr_mode;\n\thw_mode = DWC3_GHWPARAMS0_MODE(dwc->hwparams.hwparams0);\n\n\tswitch (hw_mode) {\n\tcase DWC3_GHWPARAMS0_MODE_GADGET:\n\t\tif (IS_ENABLED(CONFIG_USB_DWC3_HOST)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Controller does not support host mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode = USB_DR_MODE_PERIPHERAL;\n\t\tbreak;\n\tcase DWC3_GHWPARAMS0_MODE_HOST:\n\t\tif (IS_ENABLED(CONFIG_USB_DWC3_GADGET)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Controller does not support device mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode = USB_DR_MODE_HOST;\n\t\tbreak;\n\tdefault:\n\t\tif (IS_ENABLED(CONFIG_USB_DWC3_HOST))\n\t\t\tmode = USB_DR_MODE_HOST;\n\t\telse if (IS_ENABLED(CONFIG_USB_DWC3_GADGET))\n\t\t\tmode = USB_DR_MODE_PERIPHERAL;\n\n\t\t \n\t\tif (mode == USB_DR_MODE_OTG && !dwc->edev &&\n\t\t    (!IS_ENABLED(CONFIG_USB_ROLE_SWITCH) ||\n\t\t     !device_property_read_bool(dwc->dev, \"usb-role-switch\")) &&\n\t\t    !DWC3_VER_IS_PRIOR(DWC3, 330A))\n\t\t\tmode = USB_DR_MODE_PERIPHERAL;\n\t}\n\n\tif (mode != dwc->dr_mode) {\n\t\tdev_warn(dev,\n\t\t\t \"Configuration mismatch. dr_mode forced to %s\\n\",\n\t\t\t mode == USB_DR_MODE_HOST ? \"host\" : \"gadget\");\n\n\t\tdwc->dr_mode = mode;\n\t}\n\n\treturn 0;\n}\n\nvoid dwc3_set_prtcap(struct dwc3 *dwc, u32 mode)\n{\n\tu32 reg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\treg &= ~(DWC3_GCTL_PRTCAPDIR(DWC3_GCTL_PRTCAP_OTG));\n\treg |= DWC3_GCTL_PRTCAPDIR(mode);\n\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n\n\tdwc->current_dr_role = mode;\n}\n\nstatic void __dwc3_set_mode(struct work_struct *work)\n{\n\tstruct dwc3 *dwc = work_to_dwc(work);\n\tunsigned long flags;\n\tint ret;\n\tu32 reg;\n\tu32 desired_dr_role;\n\n\tmutex_lock(&dwc->mutex);\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdesired_dr_role = dwc->desired_dr_role;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tpm_runtime_get_sync(dwc->dev);\n\n\tif (dwc->current_dr_role == DWC3_GCTL_PRTCAP_OTG)\n\t\tdwc3_otg_update(dwc, 0);\n\n\tif (!desired_dr_role)\n\t\tgoto out;\n\n\tif (desired_dr_role == dwc->current_dr_role)\n\t\tgoto out;\n\n\tif (desired_dr_role == DWC3_GCTL_PRTCAP_OTG && dwc->edev)\n\t\tgoto out;\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tdwc3_host_exit(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tdwc3_gadget_exit(dwc);\n\t\tdwc3_event_buffers_cleanup(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\tdwc3_otg_exit(dwc);\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc->desired_otg_role = DWC3_OTG_ROLE_IDLE;\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\tdwc3_otg_update(dwc, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (dwc->current_dr_role && ((DWC3_IP_IS(DWC3) ||\n\t\t\tDWC3_VER_IS_PRIOR(DWC31, 190A)) &&\n\t\t\tdesired_dr_role != DWC3_GCTL_PRTCAP_OTG)) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\t\treg |= DWC3_GCTL_CORESOFTRESET;\n\t\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n\n\t\t \n\t\tmsleep(100);\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\t\treg &= ~DWC3_GCTL_CORESOFTRESET;\n\t\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\n\tdwc3_set_prtcap(dwc, desired_dr_role);\n\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tswitch (desired_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tret = dwc3_host_init(dwc);\n\t\tif (ret) {\n\t\t\tdev_err(dwc->dev, \"failed to initialize host\\n\");\n\t\t} else {\n\t\t\tif (dwc->usb2_phy)\n\t\t\t\totg_set_vbus(dwc->usb2_phy->otg, true);\n\t\t\tphy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_HOST);\n\t\t\tphy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_HOST);\n\t\t\tif (dwc->dis_split_quirk) {\n\t\t\t\treg = dwc3_readl(dwc->regs, DWC3_GUCTL3);\n\t\t\t\treg |= DWC3_GUCTL3_SPLITDISABLE;\n\t\t\t\tdwc3_writel(dwc->regs, DWC3_GUCTL3, reg);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tdwc3_core_soft_reset(dwc);\n\n\t\tdwc3_event_buffers_setup(dwc);\n\n\t\tif (dwc->usb2_phy)\n\t\t\totg_set_vbus(dwc->usb2_phy->otg, false);\n\t\tphy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_DEVICE);\n\t\tphy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_DEVICE);\n\n\t\tret = dwc3_gadget_init(dwc);\n\t\tif (ret)\n\t\t\tdev_err(dwc->dev, \"failed to initialize peripheral\\n\");\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\tdwc3_otg_init(dwc);\n\t\tdwc3_otg_update(dwc, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tpm_runtime_mark_last_busy(dwc->dev);\n\tpm_runtime_put_autosuspend(dwc->dev);\n\tmutex_unlock(&dwc->mutex);\n}\n\nvoid dwc3_set_mode(struct dwc3 *dwc, u32 mode)\n{\n\tunsigned long flags;\n\n\tif (dwc->dr_mode != USB_DR_MODE_OTG)\n\t\treturn;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->desired_dr_role = mode;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tqueue_work(system_freezable_wq, &dwc->drd_work);\n}\n\nu32 dwc3_core_fifo_space(struct dwc3_ep *dep, u8 type)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tu32\t\t\treg;\n\n\tdwc3_writel(dwc->regs, DWC3_GDBGFIFOSPACE,\n\t\t\tDWC3_GDBGFIFOSPACE_NUM(dep->number) |\n\t\t\tDWC3_GDBGFIFOSPACE_TYPE(type));\n\n\treg = dwc3_readl(dwc->regs, DWC3_GDBGFIFOSPACE);\n\n\treturn DWC3_GDBGFIFOSPACE_SPACE_AVAILABLE(reg);\n}\n\n \nint dwc3_core_soft_reset(struct dwc3 *dwc)\n{\n\tu32\t\treg;\n\tint\t\tretries = 1000;\n\n\t \n\tif (dwc->current_dr_role == DWC3_GCTL_PRTCAP_HOST)\n\t\treturn 0;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\treg |= DWC3_DCTL_CSFTRST;\n\treg &= ~DWC3_DCTL_RUN_STOP;\n\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\n\t \n\tif (DWC3_VER_IS_WITHIN(DWC31, 190A, ANY) || DWC3_IP_IS(DWC32))\n\t\tretries = 10;\n\n\tdo {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\tif (!(reg & DWC3_DCTL_CSFTRST))\n\t\t\tgoto done;\n\n\t\tif (DWC3_VER_IS_WITHIN(DWC31, 190A, ANY) || DWC3_IP_IS(DWC32))\n\t\t\tmsleep(20);\n\t\telse\n\t\t\tudelay(1);\n\t} while (--retries);\n\n\tdev_warn(dwc->dev, \"DWC3 controller soft reset failed.\\n\");\n\treturn -ETIMEDOUT;\n\ndone:\n\t \n\tif (DWC3_VER_IS_WITHIN(DWC31, ANY, 180A))\n\t\tmsleep(50);\n\n\treturn 0;\n}\n\n \nstatic void dwc3_frame_length_adjustment(struct dwc3 *dwc)\n{\n\tu32 reg;\n\tu32 dft;\n\n\tif (DWC3_VER_IS_PRIOR(DWC3, 250A))\n\t\treturn;\n\n\tif (dwc->fladj == 0)\n\t\treturn;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GFLADJ);\n\tdft = reg & DWC3_GFLADJ_30MHZ_MASK;\n\tif (dft != dwc->fladj) {\n\t\treg &= ~DWC3_GFLADJ_30MHZ_MASK;\n\t\treg |= DWC3_GFLADJ_30MHZ_SDBND_SEL | dwc->fladj;\n\t\tdwc3_writel(dwc->regs, DWC3_GFLADJ, reg);\n\t}\n}\n\n \nstatic void dwc3_ref_clk_period(struct dwc3 *dwc)\n{\n\tunsigned long period;\n\tunsigned long fladj;\n\tunsigned long decr;\n\tunsigned long rate;\n\tu32 reg;\n\n\tif (dwc->ref_clk) {\n\t\trate = clk_get_rate(dwc->ref_clk);\n\t\tif (!rate)\n\t\t\treturn;\n\t\tperiod = NSEC_PER_SEC / rate;\n\t} else if (dwc->ref_clk_per) {\n\t\tperiod = dwc->ref_clk_per;\n\t\trate = NSEC_PER_SEC / period;\n\t} else {\n\t\treturn;\n\t}\n\n\treg = dwc3_readl(dwc->regs, DWC3_GUCTL);\n\treg &= ~DWC3_GUCTL_REFCLKPER_MASK;\n\treg |=  FIELD_PREP(DWC3_GUCTL_REFCLKPER_MASK, period);\n\tdwc3_writel(dwc->regs, DWC3_GUCTL, reg);\n\n\tif (DWC3_VER_IS_PRIOR(DWC3, 250A))\n\t\treturn;\n\n\t \n\tfladj = div64_u64(125000ULL * NSEC_PER_SEC, (u64)rate * period);\n\tfladj -= 125000;\n\n\t \n\tdecr = 480000000 / rate;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GFLADJ);\n\treg &= ~DWC3_GFLADJ_REFCLK_FLADJ_MASK\n\t    &  ~DWC3_GFLADJ_240MHZDECR\n\t    &  ~DWC3_GFLADJ_240MHZDECR_PLS1;\n\treg |= FIELD_PREP(DWC3_GFLADJ_REFCLK_FLADJ_MASK, fladj)\n\t    |  FIELD_PREP(DWC3_GFLADJ_240MHZDECR, decr >> 1)\n\t    |  FIELD_PREP(DWC3_GFLADJ_240MHZDECR_PLS1, decr & 1);\n\n\tif (dwc->gfladj_refclk_lpm_sel)\n\t\treg |=  DWC3_GFLADJ_REFCLK_LPM_SEL;\n\n\tdwc3_writel(dwc->regs, DWC3_GFLADJ, reg);\n}\n\n \nstatic void dwc3_free_one_event_buffer(struct dwc3 *dwc,\n\t\tstruct dwc3_event_buffer *evt)\n{\n\tdma_free_coherent(dwc->sysdev, evt->length, evt->buf, evt->dma);\n}\n\n \nstatic struct dwc3_event_buffer *dwc3_alloc_one_event_buffer(struct dwc3 *dwc,\n\t\tunsigned int length)\n{\n\tstruct dwc3_event_buffer\t*evt;\n\n\tevt = devm_kzalloc(dwc->dev, sizeof(*evt), GFP_KERNEL);\n\tif (!evt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tevt->dwc\t= dwc;\n\tevt->length\t= length;\n\tevt->cache\t= devm_kzalloc(dwc->dev, length, GFP_KERNEL);\n\tif (!evt->cache)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tevt->buf\t= dma_alloc_coherent(dwc->sysdev, length,\n\t\t\t&evt->dma, GFP_KERNEL);\n\tif (!evt->buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn evt;\n}\n\n \nstatic void dwc3_free_event_buffers(struct dwc3 *dwc)\n{\n\tstruct dwc3_event_buffer\t*evt;\n\n\tevt = dwc->ev_buf;\n\tif (evt)\n\t\tdwc3_free_one_event_buffer(dwc, evt);\n}\n\n \nstatic int dwc3_alloc_event_buffers(struct dwc3 *dwc, unsigned int length)\n{\n\tstruct dwc3_event_buffer *evt;\n\n\tevt = dwc3_alloc_one_event_buffer(dwc, length);\n\tif (IS_ERR(evt)) {\n\t\tdev_err(dwc->dev, \"can't allocate event buffer\\n\");\n\t\treturn PTR_ERR(evt);\n\t}\n\tdwc->ev_buf = evt;\n\n\treturn 0;\n}\n\n \nint dwc3_event_buffers_setup(struct dwc3 *dwc)\n{\n\tstruct dwc3_event_buffer\t*evt;\n\n\tevt = dwc->ev_buf;\n\tevt->lpos = 0;\n\tdwc3_writel(dwc->regs, DWC3_GEVNTADRLO(0),\n\t\t\tlower_32_bits(evt->dma));\n\tdwc3_writel(dwc->regs, DWC3_GEVNTADRHI(0),\n\t\t\tupper_32_bits(evt->dma));\n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0),\n\t\t\tDWC3_GEVNTSIZ_SIZE(evt->length));\n\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), 0);\n\n\treturn 0;\n}\n\nvoid dwc3_event_buffers_cleanup(struct dwc3 *dwc)\n{\n\tstruct dwc3_event_buffer\t*evt;\n\n\tevt = dwc->ev_buf;\n\n\tevt->lpos = 0;\n\n\tdwc3_writel(dwc->regs, DWC3_GEVNTADRLO(0), 0);\n\tdwc3_writel(dwc->regs, DWC3_GEVNTADRHI(0), 0);\n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), DWC3_GEVNTSIZ_INTMASK\n\t\t\t| DWC3_GEVNTSIZ_SIZE(0));\n\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), 0);\n}\n\nstatic void dwc3_core_num_eps(struct dwc3 *dwc)\n{\n\tstruct dwc3_hwparams\t*parms = &dwc->hwparams;\n\n\tdwc->num_eps = DWC3_NUM_EPS(parms);\n}\n\nstatic void dwc3_cache_hwparams(struct dwc3 *dwc)\n{\n\tstruct dwc3_hwparams\t*parms = &dwc->hwparams;\n\n\tparms->hwparams0 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS0);\n\tparms->hwparams1 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS1);\n\tparms->hwparams2 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS2);\n\tparms->hwparams3 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS3);\n\tparms->hwparams4 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS4);\n\tparms->hwparams5 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS5);\n\tparms->hwparams6 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS6);\n\tparms->hwparams7 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS7);\n\tparms->hwparams8 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS8);\n\n\tif (DWC3_IP_IS(DWC32))\n\t\tparms->hwparams9 = dwc3_readl(dwc->regs, DWC3_GHWPARAMS9);\n}\n\nstatic int dwc3_core_ulpi_init(struct dwc3 *dwc)\n{\n\tint intf;\n\tint ret = 0;\n\n\tintf = DWC3_GHWPARAMS3_HSPHY_IFC(dwc->hwparams.hwparams3);\n\n\tif (intf == DWC3_GHWPARAMS3_HSPHY_IFC_ULPI ||\n\t    (intf == DWC3_GHWPARAMS3_HSPHY_IFC_UTMI_ULPI &&\n\t     dwc->hsphy_interface &&\n\t     !strncmp(dwc->hsphy_interface, \"ulpi\", 4)))\n\t\tret = dwc3_ulpi_init(dwc);\n\n\treturn ret;\n}\n\n \nstatic int dwc3_phy_setup(struct dwc3 *dwc)\n{\n\tunsigned int hw_mode;\n\tu32 reg;\n\n\thw_mode = DWC3_GHWPARAMS0_MODE(dwc->hwparams.hwparams0);\n\n\treg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));\n\n\t \n\treg &= ~DWC3_GUSB3PIPECTL_UX_EXIT_PX;\n\n\t \n\tif (!DWC3_VER_IS_WITHIN(DWC3, ANY, 194A))\n\t\treg |= DWC3_GUSB3PIPECTL_SUSPHY;\n\n\t \n\tif (hw_mode == DWC3_GHWPARAMS0_MODE_DRD)\n\t\treg &= ~DWC3_GUSB3PIPECTL_SUSPHY;\n\n\tif (dwc->u2ss_inp3_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_U2SSINP3OK;\n\n\tif (dwc->dis_rxdet_inp3_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_DISRXDETINP3;\n\n\tif (dwc->req_p1p2p3_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_REQP1P2P3;\n\n\tif (dwc->del_p1p2p3_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_DEP1P2P3_EN;\n\n\tif (dwc->del_phy_power_chg_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_DEPOCHANGE;\n\n\tif (dwc->lfps_filter_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_LFPSFILT;\n\n\tif (dwc->rx_detect_poll_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_RX_DETOPOLL;\n\n\tif (dwc->tx_de_emphasis_quirk)\n\t\treg |= DWC3_GUSB3PIPECTL_TX_DEEPH(dwc->tx_de_emphasis);\n\n\tif (dwc->dis_u3_susphy_quirk)\n\t\treg &= ~DWC3_GUSB3PIPECTL_SUSPHY;\n\n\tif (dwc->dis_del_phy_power_chg_quirk)\n\t\treg &= ~DWC3_GUSB3PIPECTL_DEPOCHANGE;\n\n\tdwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);\n\n\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\n\t \n\tswitch (DWC3_GHWPARAMS3_HSPHY_IFC(dwc->hwparams.hwparams3)) {\n\tcase DWC3_GHWPARAMS3_HSPHY_IFC_UTMI_ULPI:\n\t\tif (dwc->hsphy_interface &&\n\t\t\t\t!strncmp(dwc->hsphy_interface, \"utmi\", 4)) {\n\t\t\treg &= ~DWC3_GUSB2PHYCFG_ULPI_UTMI;\n\t\t\tbreak;\n\t\t} else if (dwc->hsphy_interface &&\n\t\t\t\t!strncmp(dwc->hsphy_interface, \"ulpi\", 4)) {\n\t\t\treg |= DWC3_GUSB2PHYCFG_ULPI_UTMI;\n\t\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t\t} else {\n\t\t\t \n\t\t\tif (!(reg & DWC3_GUSB2PHYCFG_ULPI_UTMI))\n\t\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase DWC3_GHWPARAMS3_HSPHY_IFC_ULPI:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (dwc->hsphy_mode) {\n\tcase USBPHY_INTERFACE_MODE_UTMI:\n\t\treg &= ~(DWC3_GUSB2PHYCFG_PHYIF_MASK |\n\t\t       DWC3_GUSB2PHYCFG_USBTRDTIM_MASK);\n\t\treg |= DWC3_GUSB2PHYCFG_PHYIF(UTMI_PHYIF_8_BIT) |\n\t\t       DWC3_GUSB2PHYCFG_USBTRDTIM(USBTRDTIM_UTMI_8_BIT);\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_UTMIW:\n\t\treg &= ~(DWC3_GUSB2PHYCFG_PHYIF_MASK |\n\t\t       DWC3_GUSB2PHYCFG_USBTRDTIM_MASK);\n\t\treg |= DWC3_GUSB2PHYCFG_PHYIF(UTMI_PHYIF_16_BIT) |\n\t\t       DWC3_GUSB2PHYCFG_USBTRDTIM(USBTRDTIM_UTMI_16_BIT);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!DWC3_VER_IS_WITHIN(DWC3, ANY, 194A))\n\t\treg |= DWC3_GUSB2PHYCFG_SUSPHY;\n\n\t \n\tif (hw_mode == DWC3_GHWPARAMS0_MODE_DRD)\n\t\treg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\n\n\tif (dwc->dis_u2_susphy_quirk)\n\t\treg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\n\n\tif (dwc->dis_enblslpm_quirk)\n\t\treg &= ~DWC3_GUSB2PHYCFG_ENBLSLPM;\n\telse\n\t\treg |= DWC3_GUSB2PHYCFG_ENBLSLPM;\n\n\tif (dwc->dis_u2_freeclk_exists_quirk || dwc->gfladj_refclk_lpm_sel)\n\t\treg &= ~DWC3_GUSB2PHYCFG_U2_FREECLK_EXISTS;\n\n\t \n\tif (dwc->ulpi_ext_vbus_drv)\n\t\treg |= DWC3_GUSB2PHYCFG_ULPIEXTVBUSDRV;\n\n\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\n\treturn 0;\n}\n\nstatic int dwc3_phy_init(struct dwc3 *dwc)\n{\n\tint ret;\n\n\tusb_phy_init(dwc->usb2_phy);\n\tusb_phy_init(dwc->usb3_phy);\n\n\tret = phy_init(dwc->usb2_generic_phy);\n\tif (ret < 0)\n\t\tgoto err_shutdown_usb3_phy;\n\n\tret = phy_init(dwc->usb3_generic_phy);\n\tif (ret < 0)\n\t\tgoto err_exit_usb2_phy;\n\n\treturn 0;\n\nerr_exit_usb2_phy:\n\tphy_exit(dwc->usb2_generic_phy);\nerr_shutdown_usb3_phy:\n\tusb_phy_shutdown(dwc->usb3_phy);\n\tusb_phy_shutdown(dwc->usb2_phy);\n\n\treturn ret;\n}\n\nstatic void dwc3_phy_exit(struct dwc3 *dwc)\n{\n\tphy_exit(dwc->usb3_generic_phy);\n\tphy_exit(dwc->usb2_generic_phy);\n\n\tusb_phy_shutdown(dwc->usb3_phy);\n\tusb_phy_shutdown(dwc->usb2_phy);\n}\n\nstatic int dwc3_phy_power_on(struct dwc3 *dwc)\n{\n\tint ret;\n\n\tusb_phy_set_suspend(dwc->usb2_phy, 0);\n\tusb_phy_set_suspend(dwc->usb3_phy, 0);\n\n\tret = phy_power_on(dwc->usb2_generic_phy);\n\tif (ret < 0)\n\t\tgoto err_suspend_usb3_phy;\n\n\tret = phy_power_on(dwc->usb3_generic_phy);\n\tif (ret < 0)\n\t\tgoto err_power_off_usb2_phy;\n\n\treturn 0;\n\nerr_power_off_usb2_phy:\n\tphy_power_off(dwc->usb2_generic_phy);\nerr_suspend_usb3_phy:\n\tusb_phy_set_suspend(dwc->usb3_phy, 1);\n\tusb_phy_set_suspend(dwc->usb2_phy, 1);\n\n\treturn ret;\n}\n\nstatic void dwc3_phy_power_off(struct dwc3 *dwc)\n{\n\tphy_power_off(dwc->usb3_generic_phy);\n\tphy_power_off(dwc->usb2_generic_phy);\n\n\tusb_phy_set_suspend(dwc->usb3_phy, 1);\n\tusb_phy_set_suspend(dwc->usb2_phy, 1);\n}\n\nstatic int dwc3_clk_enable(struct dwc3 *dwc)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(dwc->bus_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(dwc->ref_clk);\n\tif (ret)\n\t\tgoto disable_bus_clk;\n\n\tret = clk_prepare_enable(dwc->susp_clk);\n\tif (ret)\n\t\tgoto disable_ref_clk;\n\n\treturn 0;\n\ndisable_ref_clk:\n\tclk_disable_unprepare(dwc->ref_clk);\ndisable_bus_clk:\n\tclk_disable_unprepare(dwc->bus_clk);\n\treturn ret;\n}\n\nstatic void dwc3_clk_disable(struct dwc3 *dwc)\n{\n\tclk_disable_unprepare(dwc->susp_clk);\n\tclk_disable_unprepare(dwc->ref_clk);\n\tclk_disable_unprepare(dwc->bus_clk);\n}\n\nstatic void dwc3_core_exit(struct dwc3 *dwc)\n{\n\tdwc3_event_buffers_cleanup(dwc);\n\tdwc3_phy_power_off(dwc);\n\tdwc3_phy_exit(dwc);\n\tdwc3_clk_disable(dwc);\n\treset_control_assert(dwc->reset);\n}\n\nstatic bool dwc3_core_is_valid(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GSNPSID);\n\tdwc->ip = DWC3_GSNPS_ID(reg);\n\n\t \n\tif (DWC3_IP_IS(DWC3)) {\n\t\tdwc->revision = reg;\n\t} else if (DWC3_IP_IS(DWC31) || DWC3_IP_IS(DWC32)) {\n\t\tdwc->revision = dwc3_readl(dwc->regs, DWC3_VER_NUMBER);\n\t\tdwc->version_type = dwc3_readl(dwc->regs, DWC3_VER_TYPE);\n\t} else {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void dwc3_core_setup_global_control(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\treg &= ~DWC3_GCTL_SCALEDOWN_MASK;\n\n\tswitch (DWC3_GHWPARAMS1_EN_PWROPT(dwc->hwparams.hwparams1)) {\n\tcase DWC3_GHWPARAMS1_EN_PWROPT_CLK:\n\t\t \n\t\tif ((dwc->dr_mode == USB_DR_MODE_HOST ||\n\t\t\t\tdwc->dr_mode == USB_DR_MODE_OTG) &&\n\t\t\t\tDWC3_VER_IS_WITHIN(DWC3, 210A, 250A))\n\t\t\treg |= DWC3_GCTL_DSBLCLKGTNG | DWC3_GCTL_SOFITPSYNC;\n\t\telse\n\t\t\treg &= ~DWC3_GCTL_DSBLCLKGTNG;\n\t\tbreak;\n\tcase DWC3_GHWPARAMS1_EN_PWROPT_HIB:\n\t\t \n\t\treg |= DWC3_GCTL_GBLHIBERNATIONEN;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tif (dwc->hwparams.hwparams6 & DWC3_GHWPARAMS6_EN_FPGA) {\n\t\tdev_info(dwc->dev, \"Running with FPGA optimizations\\n\");\n\t\tdwc->is_fpga = true;\n\t}\n\n\tWARN_ONCE(dwc->disable_scramble_quirk && !dwc->is_fpga,\n\t\t\t\"disable_scramble cannot be used on non-FPGA builds\\n\");\n\n\tif (dwc->disable_scramble_quirk && dwc->is_fpga)\n\t\treg |= DWC3_GCTL_DISSCRAMBLE;\n\telse\n\t\treg &= ~DWC3_GCTL_DISSCRAMBLE;\n\n\tif (dwc->u2exit_lfps_quirk)\n\t\treg |= DWC3_GCTL_U2EXIT_LFPS;\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 190A))\n\t\treg |= DWC3_GCTL_U2RSTECN;\n\n\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n}\n\nstatic int dwc3_core_get_phy(struct dwc3 *dwc);\nstatic int dwc3_core_ulpi_init(struct dwc3 *dwc);\n\n \nstatic void dwc3_set_incr_burst_type(struct dwc3 *dwc)\n{\n\tstruct device *dev = dwc->dev;\n\t \n\tbool incrx_mode;\n\t \n\tu32 incrx_size;\n\tu32 *vals;\n\tu32 cfg;\n\tint ntype;\n\tint ret;\n\tint i;\n\n\tcfg = dwc3_readl(dwc->regs, DWC3_GSBUSCFG0);\n\n\t \n\tntype = device_property_count_u32(dev, \"snps,incr-burst-type-adjustment\");\n\tif (ntype <= 0)\n\t\treturn;\n\n\tvals = kcalloc(ntype, sizeof(u32), GFP_KERNEL);\n\tif (!vals)\n\t\treturn;\n\n\t \n\tret = device_property_read_u32_array(dev,\n\t\t\t\"snps,incr-burst-type-adjustment\", vals, ntype);\n\tif (ret) {\n\t\tkfree(vals);\n\t\tdev_err(dev, \"Error to get property\\n\");\n\t\treturn;\n\t}\n\n\tincrx_size = *vals;\n\n\tif (ntype > 1) {\n\t\t \n\t\tincrx_mode = INCRX_UNDEF_LENGTH_BURST_MODE;\n\t\tfor (i = 1; i < ntype; i++) {\n\t\t\tif (vals[i] > incrx_size)\n\t\t\t\tincrx_size = vals[i];\n\t\t}\n\t} else {\n\t\t \n\t\tincrx_mode = INCRX_BURST_MODE;\n\t}\n\n\tkfree(vals);\n\n\t \n\tcfg &= ~DWC3_GSBUSCFG0_INCRBRST_MASK;\n\tif (incrx_mode)\n\t\tcfg |= DWC3_GSBUSCFG0_INCRBRSTENA;\n\tswitch (incrx_size) {\n\tcase 256:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR256BRSTENA;\n\t\tbreak;\n\tcase 128:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR128BRSTENA;\n\t\tbreak;\n\tcase 64:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR64BRSTENA;\n\t\tbreak;\n\tcase 32:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR32BRSTENA;\n\t\tbreak;\n\tcase 16:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR16BRSTENA;\n\t\tbreak;\n\tcase 8:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR8BRSTENA;\n\t\tbreak;\n\tcase 4:\n\t\tcfg |= DWC3_GSBUSCFG0_INCR4BRSTENA;\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid property\\n\");\n\t\tbreak;\n\t}\n\n\tdwc3_writel(dwc->regs, DWC3_GSBUSCFG0, cfg);\n}\n\nstatic void dwc3_set_power_down_clk_scale(struct dwc3 *dwc)\n{\n\tu32 scale;\n\tu32 reg;\n\n\tif (!dwc->susp_clk)\n\t\treturn;\n\n\t \n\tscale = DIV_ROUND_UP(clk_get_rate(dwc->susp_clk), 16000);\n\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\tif ((reg & DWC3_GCTL_PWRDNSCALE_MASK) < DWC3_GCTL_PWRDNSCALE(scale) ||\n\t    (reg & DWC3_GCTL_PWRDNSCALE_MASK) > DWC3_GCTL_PWRDNSCALE(scale*3)) {\n\t\treg &= ~(DWC3_GCTL_PWRDNSCALE_MASK);\n\t\treg |= DWC3_GCTL_PWRDNSCALE(scale);\n\t\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n\t}\n}\n\nstatic void dwc3_config_threshold(struct dwc3 *dwc)\n{\n\tu32 reg;\n\tu8 rx_thr_num;\n\tu8 rx_maxburst;\n\tu8 tx_thr_num;\n\tu8 tx_maxburst;\n\n\t \n\tif (!DWC3_IP_IS(DWC3) && dwc->dr_mode == USB_DR_MODE_HOST) {\n\t\trx_thr_num = dwc->rx_thr_num_pkt_prd;\n\t\trx_maxburst = dwc->rx_max_burst_prd;\n\t\ttx_thr_num = dwc->tx_thr_num_pkt_prd;\n\t\ttx_maxburst = dwc->tx_max_burst_prd;\n\n\t\tif (rx_thr_num && rx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);\n\t\t\treg |= DWC31_RXTHRNUMPKTSEL_PRD;\n\n\t\t\treg &= ~DWC31_RXTHRNUMPKT_PRD(~0);\n\t\t\treg |= DWC31_RXTHRNUMPKT_PRD(rx_thr_num);\n\n\t\t\treg &= ~DWC31_MAXRXBURSTSIZE_PRD(~0);\n\t\t\treg |= DWC31_MAXRXBURSTSIZE_PRD(rx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);\n\t\t}\n\n\t\tif (tx_thr_num && tx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GTXTHRCFG);\n\t\t\treg |= DWC31_TXTHRNUMPKTSEL_PRD;\n\n\t\t\treg &= ~DWC31_TXTHRNUMPKT_PRD(~0);\n\t\t\treg |= DWC31_TXTHRNUMPKT_PRD(tx_thr_num);\n\n\t\t\treg &= ~DWC31_MAXTXBURSTSIZE_PRD(~0);\n\t\t\treg |= DWC31_MAXTXBURSTSIZE_PRD(tx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GTXTHRCFG, reg);\n\t\t}\n\t}\n\n\trx_thr_num = dwc->rx_thr_num_pkt;\n\trx_maxburst = dwc->rx_max_burst;\n\ttx_thr_num = dwc->tx_thr_num_pkt;\n\ttx_maxburst = dwc->tx_max_burst;\n\n\tif (DWC3_IP_IS(DWC3)) {\n\t\tif (rx_thr_num && rx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);\n\t\t\treg |= DWC3_GRXTHRCFG_PKTCNTSEL;\n\n\t\t\treg &= ~DWC3_GRXTHRCFG_RXPKTCNT(~0);\n\t\t\treg |= DWC3_GRXTHRCFG_RXPKTCNT(rx_thr_num);\n\n\t\t\treg &= ~DWC3_GRXTHRCFG_MAXRXBURSTSIZE(~0);\n\t\t\treg |= DWC3_GRXTHRCFG_MAXRXBURSTSIZE(rx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);\n\t\t}\n\n\t\tif (tx_thr_num && tx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GTXTHRCFG);\n\t\t\treg |= DWC3_GTXTHRCFG_PKTCNTSEL;\n\n\t\t\treg &= ~DWC3_GTXTHRCFG_TXPKTCNT(~0);\n\t\t\treg |= DWC3_GTXTHRCFG_TXPKTCNT(tx_thr_num);\n\n\t\t\treg &= ~DWC3_GTXTHRCFG_MAXTXBURSTSIZE(~0);\n\t\t\treg |= DWC3_GTXTHRCFG_MAXTXBURSTSIZE(tx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GTXTHRCFG, reg);\n\t\t}\n\t} else {\n\t\tif (rx_thr_num && rx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);\n\t\t\treg |= DWC31_GRXTHRCFG_PKTCNTSEL;\n\n\t\t\treg &= ~DWC31_GRXTHRCFG_RXPKTCNT(~0);\n\t\t\treg |= DWC31_GRXTHRCFG_RXPKTCNT(rx_thr_num);\n\n\t\t\treg &= ~DWC31_GRXTHRCFG_MAXRXBURSTSIZE(~0);\n\t\t\treg |= DWC31_GRXTHRCFG_MAXRXBURSTSIZE(rx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);\n\t\t}\n\n\t\tif (tx_thr_num && tx_maxburst) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GTXTHRCFG);\n\t\t\treg |= DWC31_GTXTHRCFG_PKTCNTSEL;\n\n\t\t\treg &= ~DWC31_GTXTHRCFG_TXPKTCNT(~0);\n\t\t\treg |= DWC31_GTXTHRCFG_TXPKTCNT(tx_thr_num);\n\n\t\t\treg &= ~DWC31_GTXTHRCFG_MAXTXBURSTSIZE(~0);\n\t\t\treg |= DWC31_GTXTHRCFG_MAXTXBURSTSIZE(tx_maxburst);\n\n\t\t\tdwc3_writel(dwc->regs, DWC3_GTXTHRCFG, reg);\n\t\t}\n\t}\n}\n\n \nstatic int dwc3_core_init(struct dwc3 *dwc)\n{\n\tunsigned int\t\thw_mode;\n\tu32\t\t\treg;\n\tint\t\t\tret;\n\n\thw_mode = DWC3_GHWPARAMS0_MODE(dwc->hwparams.hwparams0);\n\n\t \n\tdwc3_writel(dwc->regs, DWC3_GUID, LINUX_VERSION_CODE);\n\n\tret = dwc3_phy_setup(dwc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!dwc->ulpi_ready) {\n\t\tret = dwc3_core_ulpi_init(dwc);\n\t\tif (ret) {\n\t\t\tif (ret == -ETIMEDOUT) {\n\t\t\t\tdwc3_core_soft_reset(dwc);\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tdwc->ulpi_ready = true;\n\t}\n\n\tif (!dwc->phys_ready) {\n\t\tret = dwc3_core_get_phy(dwc);\n\t\tif (ret)\n\t\t\tgoto err_exit_ulpi;\n\t\tdwc->phys_ready = true;\n\t}\n\n\tret = dwc3_phy_init(dwc);\n\tif (ret)\n\t\tgoto err_exit_ulpi;\n\n\tret = dwc3_core_soft_reset(dwc);\n\tif (ret)\n\t\tgoto err_exit_phy;\n\n\tif (hw_mode == DWC3_GHWPARAMS0_MODE_DRD &&\n\t    !DWC3_VER_IS_WITHIN(DWC3, ANY, 194A)) {\n\t\tif (!dwc->dis_u3_susphy_quirk) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));\n\t\t\treg |= DWC3_GUSB3PIPECTL_SUSPHY;\n\t\t\tdwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), reg);\n\t\t}\n\n\t\tif (!dwc->dis_u2_susphy_quirk) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\t\treg |= DWC3_GUSB2PHYCFG_SUSPHY;\n\t\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t\t}\n\t}\n\n\tdwc3_core_setup_global_control(dwc);\n\tdwc3_core_num_eps(dwc);\n\n\t \n\tdwc3_set_power_down_clk_scale(dwc);\n\n\t \n\tdwc3_frame_length_adjustment(dwc);\n\n\t \n\tdwc3_ref_clk_period(dwc);\n\n\tdwc3_set_incr_burst_type(dwc);\n\n\tret = dwc3_phy_power_on(dwc);\n\tif (ret)\n\t\tgoto err_exit_phy;\n\n\tret = dwc3_event_buffers_setup(dwc);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to setup event buffers\\n\");\n\t\tgoto err_power_off_phy;\n\t}\n\n\t \n\tif (DWC3_VER_IS_WITHIN(DWC3, 310A, ANY)) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUCTL2);\n\t\treg |= DWC3_GUCTL2_RST_ACTBITLATER;\n\t\tdwc3_writel(dwc->regs, DWC3_GUCTL2, reg);\n\t}\n\n\t \n\tif (dwc->resume_hs_terminations) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUCTL1);\n\t\treg |= DWC3_GUCTL1_RESUME_OPMODE_HS_HOST;\n\t\tdwc3_writel(dwc->regs, DWC3_GUCTL1, reg);\n\t}\n\n\tif (!DWC3_VER_IS_PRIOR(DWC3, 250A)) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUCTL1);\n\n\t\t \n\t\tif (!DWC3_VER_IS_PRIOR(DWC3, 290A))\n\t\t\treg |= DWC3_GUCTL1_DEV_L1_EXIT_BY_HW;\n\n\t\t \n\t\tif (!DWC3_VER_IS_PRIOR(DWC3, 300A))\n\t\t\treg |= DWC3_GUCTL1_DEV_DECOUPLE_L1L2_EVT;\n\n\t\tif (dwc->dis_tx_ipgap_linecheck_quirk)\n\t\t\treg |= DWC3_GUCTL1_TX_IPGAP_LINECHECK_DIS;\n\n\t\tif (dwc->parkmode_disable_ss_quirk)\n\t\t\treg |= DWC3_GUCTL1_PARKMODE_DISABLE_SS;\n\n\t\tif (dwc->parkmode_disable_hs_quirk)\n\t\t\treg |= DWC3_GUCTL1_PARKMODE_DISABLE_HS;\n\n\t\tif (DWC3_VER_IS_WITHIN(DWC3, 290A, ANY) &&\n\t\t    (dwc->maximum_speed == USB_SPEED_HIGH ||\n\t\t     dwc->maximum_speed == USB_SPEED_FULL))\n\t\t\treg |= DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK;\n\n\t\tdwc3_writel(dwc->regs, DWC3_GUCTL1, reg);\n\t}\n\n\tdwc3_config_threshold(dwc);\n\n\treturn 0;\n\nerr_power_off_phy:\n\tdwc3_phy_power_off(dwc);\nerr_exit_phy:\n\tdwc3_phy_exit(dwc);\nerr_exit_ulpi:\n\tdwc3_ulpi_exit(dwc);\n\n\treturn ret;\n}\n\nstatic int dwc3_core_get_phy(struct dwc3 *dwc)\n{\n\tstruct device\t\t*dev = dwc->dev;\n\tstruct device_node\t*node = dev->of_node;\n\tint ret;\n\n\tif (node) {\n\t\tdwc->usb2_phy = devm_usb_get_phy_by_phandle(dev, \"usb-phy\", 0);\n\t\tdwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, \"usb-phy\", 1);\n\t} else {\n\t\tdwc->usb2_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\n\t\tdwc->usb3_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB3);\n\t}\n\n\tif (IS_ERR(dwc->usb2_phy)) {\n\t\tret = PTR_ERR(dwc->usb2_phy);\n\t\tif (ret == -ENXIO || ret == -ENODEV)\n\t\t\tdwc->usb2_phy = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"no usb2 phy configured\\n\");\n\t}\n\n\tif (IS_ERR(dwc->usb3_phy)) {\n\t\tret = PTR_ERR(dwc->usb3_phy);\n\t\tif (ret == -ENXIO || ret == -ENODEV)\n\t\t\tdwc->usb3_phy = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"no usb3 phy configured\\n\");\n\t}\n\n\tdwc->usb2_generic_phy = devm_phy_get(dev, \"usb2-phy\");\n\tif (IS_ERR(dwc->usb2_generic_phy)) {\n\t\tret = PTR_ERR(dwc->usb2_generic_phy);\n\t\tif (ret == -ENOSYS || ret == -ENODEV)\n\t\t\tdwc->usb2_generic_phy = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"no usb2 phy configured\\n\");\n\t}\n\n\tdwc->usb3_generic_phy = devm_phy_get(dev, \"usb3-phy\");\n\tif (IS_ERR(dwc->usb3_generic_phy)) {\n\t\tret = PTR_ERR(dwc->usb3_generic_phy);\n\t\tif (ret == -ENOSYS || ret == -ENODEV)\n\t\t\tdwc->usb3_generic_phy = NULL;\n\t\telse\n\t\t\treturn dev_err_probe(dev, ret, \"no usb3 phy configured\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_core_init_mode(struct dwc3 *dwc)\n{\n\tstruct device *dev = dwc->dev;\n\tint ret;\n\n\tswitch (dwc->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_DEVICE);\n\n\t\tif (dwc->usb2_phy)\n\t\t\totg_set_vbus(dwc->usb2_phy->otg, false);\n\t\tphy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_DEVICE);\n\t\tphy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_DEVICE);\n\n\t\tret = dwc3_gadget_init(dwc);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to initialize gadget\\n\");\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_HOST);\n\n\t\tif (dwc->usb2_phy)\n\t\t\totg_set_vbus(dwc->usb2_phy->otg, true);\n\t\tphy_set_mode(dwc->usb2_generic_phy, PHY_MODE_USB_HOST);\n\t\tphy_set_mode(dwc->usb3_generic_phy, PHY_MODE_USB_HOST);\n\n\t\tret = dwc3_host_init(dwc);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to initialize host\\n\");\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tINIT_WORK(&dwc->drd_work, __dwc3_set_mode);\n\t\tret = dwc3_drd_init(dwc);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"failed to initialize dual-role\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Unsupported mode of operation %d\\n\", dwc->dr_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc3_core_exit_mode(struct dwc3 *dwc)\n{\n\tswitch (dwc->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tdwc3_gadget_exit(dwc);\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tdwc3_host_exit(dwc);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tdwc3_drd_exit(dwc);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\t \n\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_DEVICE);\n}\n\nstatic void dwc3_get_properties(struct dwc3 *dwc)\n{\n\tstruct device\t\t*dev = dwc->dev;\n\tu8\t\t\tlpm_nyet_threshold;\n\tu8\t\t\ttx_de_emphasis;\n\tu8\t\t\third_threshold;\n\tu8\t\t\trx_thr_num_pkt = 0;\n\tu8\t\t\trx_max_burst = 0;\n\tu8\t\t\ttx_thr_num_pkt = 0;\n\tu8\t\t\ttx_max_burst = 0;\n\tu8\t\t\trx_thr_num_pkt_prd = 0;\n\tu8\t\t\trx_max_burst_prd = 0;\n\tu8\t\t\ttx_thr_num_pkt_prd = 0;\n\tu8\t\t\ttx_max_burst_prd = 0;\n\tu8\t\t\ttx_fifo_resize_max_num;\n\tconst char\t\t*usb_psy_name;\n\tint\t\t\tret;\n\n\t \n\tlpm_nyet_threshold = 0xf;\n\n\t \n\ttx_de_emphasis = 1;\n\n\t \n\third_threshold = 12;\n\n\t \n\ttx_fifo_resize_max_num = 6;\n\n\tdwc->maximum_speed = usb_get_maximum_speed(dev);\n\tdwc->max_ssp_rate = usb_get_maximum_ssp_rate(dev);\n\tdwc->dr_mode = usb_get_dr_mode(dev);\n\tdwc->hsphy_mode = of_usb_get_phy_mode(dev->of_node);\n\n\tdwc->sysdev_is_parent = device_property_read_bool(dev,\n\t\t\t\t\"linux,sysdev_is_parent\");\n\tif (dwc->sysdev_is_parent)\n\t\tdwc->sysdev = dwc->dev->parent;\n\telse\n\t\tdwc->sysdev = dwc->dev;\n\n\tret = device_property_read_string(dev, \"usb-psy-name\", &usb_psy_name);\n\tif (ret >= 0) {\n\t\tdwc->usb_psy = power_supply_get_by_name(usb_psy_name);\n\t\tif (!dwc->usb_psy)\n\t\t\tdev_err(dev, \"couldn't get usb power supply\\n\");\n\t}\n\n\tdwc->has_lpm_erratum = device_property_read_bool(dev,\n\t\t\t\t\"snps,has-lpm-erratum\");\n\tdevice_property_read_u8(dev, \"snps,lpm-nyet-threshold\",\n\t\t\t\t&lpm_nyet_threshold);\n\tdwc->is_utmi_l1_suspend = device_property_read_bool(dev,\n\t\t\t\t\"snps,is-utmi-l1-suspend\");\n\tdevice_property_read_u8(dev, \"snps,hird-threshold\",\n\t\t\t\t&hird_threshold);\n\tdwc->dis_start_transfer_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-start-transfer-quirk\");\n\tdwc->usb3_lpm_capable = device_property_read_bool(dev,\n\t\t\t\t\"snps,usb3_lpm_capable\");\n\tdwc->usb2_lpm_disable = device_property_read_bool(dev,\n\t\t\t\t\"snps,usb2-lpm-disable\");\n\tdwc->usb2_gadget_lpm_disable = device_property_read_bool(dev,\n\t\t\t\t\"snps,usb2-gadget-lpm-disable\");\n\tdevice_property_read_u8(dev, \"snps,rx-thr-num-pkt\",\n\t\t\t\t&rx_thr_num_pkt);\n\tdevice_property_read_u8(dev, \"snps,rx-max-burst\",\n\t\t\t\t&rx_max_burst);\n\tdevice_property_read_u8(dev, \"snps,tx-thr-num-pkt\",\n\t\t\t\t&tx_thr_num_pkt);\n\tdevice_property_read_u8(dev, \"snps,tx-max-burst\",\n\t\t\t\t&tx_max_burst);\n\tdevice_property_read_u8(dev, \"snps,rx-thr-num-pkt-prd\",\n\t\t\t\t&rx_thr_num_pkt_prd);\n\tdevice_property_read_u8(dev, \"snps,rx-max-burst-prd\",\n\t\t\t\t&rx_max_burst_prd);\n\tdevice_property_read_u8(dev, \"snps,tx-thr-num-pkt-prd\",\n\t\t\t\t&tx_thr_num_pkt_prd);\n\tdevice_property_read_u8(dev, \"snps,tx-max-burst-prd\",\n\t\t\t\t&tx_max_burst_prd);\n\tdwc->do_fifo_resize = device_property_read_bool(dev,\n\t\t\t\t\t\t\t\"tx-fifo-resize\");\n\tif (dwc->do_fifo_resize)\n\t\tdevice_property_read_u8(dev, \"tx-fifo-max-num\",\n\t\t\t\t\t&tx_fifo_resize_max_num);\n\n\tdwc->disable_scramble_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,disable_scramble_quirk\");\n\tdwc->u2exit_lfps_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,u2exit_lfps_quirk\");\n\tdwc->u2ss_inp3_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,u2ss_inp3_quirk\");\n\tdwc->req_p1p2p3_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,req_p1p2p3_quirk\");\n\tdwc->del_p1p2p3_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,del_p1p2p3_quirk\");\n\tdwc->del_phy_power_chg_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,del_phy_power_chg_quirk\");\n\tdwc->lfps_filter_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,lfps_filter_quirk\");\n\tdwc->rx_detect_poll_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,rx_detect_poll_quirk\");\n\tdwc->dis_u3_susphy_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis_u3_susphy_quirk\");\n\tdwc->dis_u2_susphy_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis_u2_susphy_quirk\");\n\tdwc->dis_enblslpm_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis_enblslpm_quirk\");\n\tdwc->dis_u1_entry_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-u1-entry-quirk\");\n\tdwc->dis_u2_entry_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-u2-entry-quirk\");\n\tdwc->dis_rxdet_inp3_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis_rxdet_inp3_quirk\");\n\tdwc->dis_u2_freeclk_exists_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-u2-freeclk-exists-quirk\");\n\tdwc->dis_del_phy_power_chg_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-del-phy-power-chg-quirk\");\n\tdwc->dis_tx_ipgap_linecheck_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-tx-ipgap-linecheck-quirk\");\n\tdwc->resume_hs_terminations = device_property_read_bool(dev,\n\t\t\t\t\"snps,resume-hs-terminations\");\n\tdwc->ulpi_ext_vbus_drv = device_property_read_bool(dev,\n\t\t\t\t\"snps,ulpi-ext-vbus-drv\");\n\tdwc->parkmode_disable_ss_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,parkmode-disable-ss-quirk\");\n\tdwc->parkmode_disable_hs_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,parkmode-disable-hs-quirk\");\n\tdwc->gfladj_refclk_lpm_sel = device_property_read_bool(dev,\n\t\t\t\t\"snps,gfladj-refclk-lpm-sel-quirk\");\n\n\tdwc->tx_de_emphasis_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,tx_de_emphasis_quirk\");\n\tdevice_property_read_u8(dev, \"snps,tx_de_emphasis\",\n\t\t\t\t&tx_de_emphasis);\n\tdevice_property_read_string(dev, \"snps,hsphy_interface\",\n\t\t\t\t    &dwc->hsphy_interface);\n\tdevice_property_read_u32(dev, \"snps,quirk-frame-length-adjustment\",\n\t\t\t\t &dwc->fladj);\n\tdevice_property_read_u32(dev, \"snps,ref-clock-period-ns\",\n\t\t\t\t &dwc->ref_clk_per);\n\n\tdwc->dis_metastability_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis_metastability_quirk\");\n\n\tdwc->dis_split_quirk = device_property_read_bool(dev,\n\t\t\t\t\"snps,dis-split-quirk\");\n\n\tdwc->lpm_nyet_threshold = lpm_nyet_threshold;\n\tdwc->tx_de_emphasis = tx_de_emphasis;\n\n\tdwc->hird_threshold = hird_threshold;\n\n\tdwc->rx_thr_num_pkt = rx_thr_num_pkt;\n\tdwc->rx_max_burst = rx_max_burst;\n\n\tdwc->tx_thr_num_pkt = tx_thr_num_pkt;\n\tdwc->tx_max_burst = tx_max_burst;\n\n\tdwc->rx_thr_num_pkt_prd = rx_thr_num_pkt_prd;\n\tdwc->rx_max_burst_prd = rx_max_burst_prd;\n\n\tdwc->tx_thr_num_pkt_prd = tx_thr_num_pkt_prd;\n\tdwc->tx_max_burst_prd = tx_max_burst_prd;\n\n\tdwc->imod_interval = 0;\n\n\tdwc->tx_fifo_resize_max_num = tx_fifo_resize_max_num;\n}\n\n \nbool dwc3_has_imod(struct dwc3 *dwc)\n{\n\treturn DWC3_VER_IS_WITHIN(DWC3, 300A, ANY) ||\n\t\tDWC3_VER_IS_WITHIN(DWC31, 120A, ANY) ||\n\t\tDWC3_IP_IS(DWC32);\n}\n\nstatic void dwc3_check_params(struct dwc3 *dwc)\n{\n\tstruct device *dev = dwc->dev;\n\tunsigned int hwparam_gen =\n\t\tDWC3_GHWPARAMS3_SSPHY_IFC(dwc->hwparams.hwparams3);\n\n\t \n\tif (dwc->imod_interval && !dwc3_has_imod(dwc)) {\n\t\tdev_warn(dwc->dev, \"Interrupt moderation not supported\\n\");\n\t\tdwc->imod_interval = 0;\n\t}\n\n\t \n\tif (!dwc->imod_interval &&\n\t    DWC3_VER_IS(DWC3, 300A))\n\t\tdwc->imod_interval = 1;\n\n\t \n\tswitch (dwc->maximum_speed) {\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tif (hwparam_gen == DWC3_GHWPARAMS3_SSPHY_IFC_DIS)\n\t\t\tdev_warn(dev, \"UDC doesn't support Gen 1\\n\");\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif ((DWC3_IP_IS(DWC32) &&\n\t\t     hwparam_gen == DWC3_GHWPARAMS3_SSPHY_IFC_DIS) ||\n\t\t    (!DWC3_IP_IS(DWC32) &&\n\t\t     hwparam_gen != DWC3_GHWPARAMS3_SSPHY_IFC_GEN2))\n\t\t\tdev_warn(dev, \"UDC doesn't support SSP\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid maximum_speed parameter %d\\n\",\n\t\t\tdwc->maximum_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\tswitch (hwparam_gen) {\n\t\tcase DWC3_GHWPARAMS3_SSPHY_IFC_GEN2:\n\t\t\tdwc->maximum_speed = USB_SPEED_SUPER_PLUS;\n\t\t\tbreak;\n\t\tcase DWC3_GHWPARAMS3_SSPHY_IFC_GEN1:\n\t\t\tif (DWC3_IP_IS(DWC32))\n\t\t\t\tdwc->maximum_speed = USB_SPEED_SUPER_PLUS;\n\t\t\telse\n\t\t\t\tdwc->maximum_speed = USB_SPEED_SUPER;\n\t\t\tbreak;\n\t\tcase DWC3_GHWPARAMS3_SSPHY_IFC_DIS:\n\t\t\tdwc->maximum_speed = USB_SPEED_HIGH;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdwc->maximum_speed = USB_SPEED_SUPER;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (dwc->maximum_speed == USB_SPEED_SUPER_PLUS) {\n\t\tswitch (dwc->max_ssp_rate) {\n\t\tcase USB_SSP_GEN_2x1:\n\t\t\tif (hwparam_gen == DWC3_GHWPARAMS3_SSPHY_IFC_GEN1)\n\t\t\t\tdev_warn(dev, \"UDC only supports Gen 1\\n\");\n\t\t\tbreak;\n\t\tcase USB_SSP_GEN_1x2:\n\t\tcase USB_SSP_GEN_2x2:\n\t\t\tif (DWC3_IP_IS(DWC31))\n\t\t\t\tdev_warn(dev, \"UDC only supports single lane\\n\");\n\t\t\tbreak;\n\t\tcase USB_SSP_GEN_UNKNOWN:\n\t\tdefault:\n\t\t\tswitch (hwparam_gen) {\n\t\t\tcase DWC3_GHWPARAMS3_SSPHY_IFC_GEN2:\n\t\t\t\tif (DWC3_IP_IS(DWC32))\n\t\t\t\t\tdwc->max_ssp_rate = USB_SSP_GEN_2x2;\n\t\t\t\telse\n\t\t\t\t\tdwc->max_ssp_rate = USB_SSP_GEN_2x1;\n\t\t\t\tbreak;\n\t\t\tcase DWC3_GHWPARAMS3_SSPHY_IFC_GEN1:\n\t\t\t\tif (DWC3_IP_IS(DWC32))\n\t\t\t\t\tdwc->max_ssp_rate = USB_SSP_GEN_1x2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic struct extcon_dev *dwc3_get_extcon(struct dwc3 *dwc)\n{\n\tstruct device *dev = dwc->dev;\n\tstruct device_node *np_phy;\n\tstruct extcon_dev *edev = NULL;\n\tconst char *name;\n\n\tif (device_property_read_bool(dev, \"extcon\"))\n\t\treturn extcon_get_edev_by_phandle(dev, 0);\n\n\t \n\tif (device_property_read_string(dev, \"linux,extcon-name\", &name) == 0)\n\t\treturn extcon_get_extcon_dev(name);\n\n\t \n\tif (IS_ENABLED(CONFIG_USB_ROLE_SWITCH) &&\n\t    device_property_read_bool(dev, \"usb-role-switch\"))\n\t\treturn NULL;\n\n\t \n\tnp_phy = of_parse_phandle(dev->of_node, \"phys\", 0);\n\tif (of_graph_is_present(np_phy)) {\n\t\tstruct device_node *np_conn;\n\n\t\tnp_conn = of_graph_get_remote_node(np_phy, -1, -1);\n\t\tif (np_conn)\n\t\t\tedev = extcon_find_edev_by_node(np_conn);\n\t\tof_node_put(np_conn);\n\t}\n\tof_node_put(np_phy);\n\n\treturn edev;\n}\n\nstatic int dwc3_get_clocks(struct dwc3 *dwc)\n{\n\tstruct device *dev = dwc->dev;\n\n\tif (!dev->of_node)\n\t\treturn 0;\n\n\t \n\tdwc->bus_clk = devm_clk_get_optional(dev, \"bus_early\");\n\tif (IS_ERR(dwc->bus_clk)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(dwc->bus_clk),\n\t\t\t\t\"could not get bus clock\\n\");\n\t}\n\n\tif (dwc->bus_clk == NULL) {\n\t\tdwc->bus_clk = devm_clk_get_optional(dev, \"bus_clk\");\n\t\tif (IS_ERR(dwc->bus_clk)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(dwc->bus_clk),\n\t\t\t\t\t\"could not get bus clock\\n\");\n\t\t}\n\t}\n\n\tdwc->ref_clk = devm_clk_get_optional(dev, \"ref\");\n\tif (IS_ERR(dwc->ref_clk)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(dwc->ref_clk),\n\t\t\t\t\"could not get ref clock\\n\");\n\t}\n\n\tif (dwc->ref_clk == NULL) {\n\t\tdwc->ref_clk = devm_clk_get_optional(dev, \"ref_clk\");\n\t\tif (IS_ERR(dwc->ref_clk)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(dwc->ref_clk),\n\t\t\t\t\t\"could not get ref clock\\n\");\n\t\t}\n\t}\n\n\tdwc->susp_clk = devm_clk_get_optional(dev, \"suspend\");\n\tif (IS_ERR(dwc->susp_clk)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(dwc->susp_clk),\n\t\t\t\t\"could not get suspend clock\\n\");\n\t}\n\n\tif (dwc->susp_clk == NULL) {\n\t\tdwc->susp_clk = devm_clk_get_optional(dev, \"suspend_clk\");\n\t\tif (IS_ERR(dwc->susp_clk)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(dwc->susp_clk),\n\t\t\t\t\t\"could not get suspend clock\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct resource\t\t*res, dwc_res;\n\tvoid __iomem\t\t*regs;\n\tstruct dwc3\t\t*dwc;\n\tint\t\t\tret;\n\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\n\tdwc->dev = dev;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(dev, \"missing memory resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdwc->xhci_resources[0].start = res->start;\n\tdwc->xhci_resources[0].end = dwc->xhci_resources[0].start +\n\t\t\t\t\tDWC3_XHCI_REGS_END;\n\tdwc->xhci_resources[0].flags = res->flags;\n\tdwc->xhci_resources[0].name = res->name;\n\n\t \n\tdwc_res = *res;\n\tdwc_res.start += DWC3_GLOBALS_REGS_START;\n\n\tif (dev->of_node) {\n\t\tstruct device_node *parent = of_get_parent(dev->of_node);\n\n\t\tif (of_device_is_compatible(parent, \"realtek,rtd-dwc3\")) {\n\t\t\tdwc_res.start -= DWC3_GLOBALS_REGS_START;\n\t\t\tdwc_res.start += DWC3_RTK_RTD_GLOBALS_REGS_START;\n\t\t}\n\n\t\tof_node_put(parent);\n\t}\n\n\tregs = devm_ioremap_resource(dev, &dwc_res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tdwc->regs\t= regs;\n\tdwc->regs_size\t= resource_size(&dwc_res);\n\n\tdwc3_get_properties(dwc);\n\n\tdwc->reset = devm_reset_control_array_get_optional_shared(dev);\n\tif (IS_ERR(dwc->reset)) {\n\t\tret = PTR_ERR(dwc->reset);\n\t\tgoto err_put_psy;\n\t}\n\n\tret = dwc3_get_clocks(dwc);\n\tif (ret)\n\t\tgoto err_put_psy;\n\n\tret = reset_control_deassert(dwc->reset);\n\tif (ret)\n\t\tgoto err_put_psy;\n\n\tret = dwc3_clk_enable(dwc);\n\tif (ret)\n\t\tgoto err_assert_reset;\n\n\tif (!dwc3_core_is_valid(dwc)) {\n\t\tdev_err(dwc->dev, \"this is not a DesignWare USB3 DRD Core\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_disable_clks;\n\t}\n\n\tplatform_set_drvdata(pdev, dwc);\n\tdwc3_cache_hwparams(dwc);\n\n\tif (!dwc->sysdev_is_parent &&\n\t    DWC3_GHWPARAMS0_AWIDTH(dwc->hwparams.hwparams0) == 64) {\n\t\tret = dma_set_mask_and_coherent(dwc->sysdev, DMA_BIT_MASK(64));\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\tspin_lock_init(&dwc->lock);\n\tmutex_init(&dwc->mutex);\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, DWC3_DEFAULT_AUTOSUSPEND_DELAY);\n\tpm_runtime_enable(dev);\n\n\tpm_runtime_forbid(dev);\n\n\tret = dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to allocate event buffers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_allow_rpm;\n\t}\n\n\tdwc->edev = dwc3_get_extcon(dwc);\n\tif (IS_ERR(dwc->edev)) {\n\t\tret = dev_err_probe(dwc->dev, PTR_ERR(dwc->edev), \"failed to get extcon\\n\");\n\t\tgoto err_free_event_buffers;\n\t}\n\n\tret = dwc3_get_dr_mode(dwc);\n\tif (ret)\n\t\tgoto err_free_event_buffers;\n\n\tret = dwc3_core_init(dwc);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to initialize core\\n\");\n\t\tgoto err_free_event_buffers;\n\t}\n\n\tdwc3_check_params(dwc);\n\tdwc3_debugfs_init(dwc);\n\n\tret = dwc3_core_init_mode(dwc);\n\tif (ret)\n\t\tgoto err_exit_debugfs;\n\n\tpm_runtime_put(dev);\n\n\tdma_set_max_seg_size(dev, UINT_MAX);\n\n\treturn 0;\n\nerr_exit_debugfs:\n\tdwc3_debugfs_exit(dwc);\n\tdwc3_event_buffers_cleanup(dwc);\n\tdwc3_phy_power_off(dwc);\n\tdwc3_phy_exit(dwc);\n\tdwc3_ulpi_exit(dwc);\nerr_free_event_buffers:\n\tdwc3_free_event_buffers(dwc);\nerr_allow_rpm:\n\tpm_runtime_allow(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_set_suspended(dev);\n\tpm_runtime_put_noidle(dev);\nerr_disable_clks:\n\tdwc3_clk_disable(dwc);\nerr_assert_reset:\n\treset_control_assert(dwc->reset);\nerr_put_psy:\n\tif (dwc->usb_psy)\n\t\tpower_supply_put(dwc->usb_psy);\n\n\treturn ret;\n}\n\nstatic void dwc3_remove(struct platform_device *pdev)\n{\n\tstruct dwc3\t*dwc = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tdwc3_core_exit_mode(dwc);\n\tdwc3_debugfs_exit(dwc);\n\n\tdwc3_core_exit(dwc);\n\tdwc3_ulpi_exit(dwc);\n\n\tpm_runtime_allow(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\t \n\tplatform_set_drvdata(pdev, NULL);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tdwc3_free_event_buffers(dwc);\n\n\tif (dwc->usb_psy)\n\t\tpower_supply_put(dwc->usb_psy);\n}\n\n#ifdef CONFIG_PM\nstatic int dwc3_core_init_for_resume(struct dwc3 *dwc)\n{\n\tint ret;\n\n\tret = reset_control_deassert(dwc->reset);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dwc3_clk_enable(dwc);\n\tif (ret)\n\t\tgoto assert_reset;\n\n\tret = dwc3_core_init(dwc);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\treturn 0;\n\ndisable_clks:\n\tdwc3_clk_disable(dwc);\nassert_reset:\n\treset_control_assert(dwc->reset);\n\n\treturn ret;\n}\n\nstatic int dwc3_suspend_common(struct dwc3 *dwc, pm_message_t msg)\n{\n\tunsigned long\tflags;\n\tu32 reg;\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tif (pm_runtime_suspended(dwc->dev))\n\t\t\tbreak;\n\t\tdwc3_gadget_suspend(dwc);\n\t\tsynchronize_irq(dwc->irq_gadget);\n\t\tdwc3_core_exit(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tif (!PMSG_IS_AUTO(msg) && !device_may_wakeup(dwc->dev)) {\n\t\t\tdwc3_core_exit(dwc);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (dwc->dis_u2_susphy_quirk ||\n\t\t    dwc->dis_enblslpm_quirk) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\t\treg |=  DWC3_GUSB2PHYCFG_ENBLSLPM |\n\t\t\t\tDWC3_GUSB2PHYCFG_SUSPHY;\n\t\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\n\t\t\t \n\t\t\tusleep_range(5000, 6000);\n\t\t}\n\n\t\tphy_pm_runtime_put_sync(dwc->usb2_generic_phy);\n\t\tphy_pm_runtime_put_sync(dwc->usb3_generic_phy);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\t \n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tbreak;\n\n\t\tif (dwc->current_otg_role == DWC3_OTG_ROLE_DEVICE) {\n\t\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\t\tdwc3_gadget_suspend(dwc);\n\t\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\t\tsynchronize_irq(dwc->irq_gadget);\n\t\t}\n\n\t\tdwc3_otg_exit(dwc);\n\t\tdwc3_core_exit(dwc);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_resume_common(struct dwc3 *dwc, pm_message_t msg)\n{\n\tunsigned long\tflags;\n\tint\t\tret;\n\tu32\t\treg;\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tret = dwc3_core_init_for_resume(dwc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_DEVICE);\n\t\tdwc3_gadget_resume(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tif (!PMSG_IS_AUTO(msg) && !device_may_wakeup(dwc->dev)) {\n\t\t\tret = dwc3_core_init_for_resume(dwc);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_HOST);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\tif (dwc->dis_u2_susphy_quirk)\n\t\t\treg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\n\n\t\tif (dwc->dis_enblslpm_quirk)\n\t\t\treg &= ~DWC3_GUSB2PHYCFG_ENBLSLPM;\n\n\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\n\t\tphy_pm_runtime_get_sync(dwc->usb2_generic_phy);\n\t\tphy_pm_runtime_get_sync(dwc->usb3_generic_phy);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\t \n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tbreak;\n\n\t\tret = dwc3_core_init_for_resume(dwc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdwc3_set_prtcap(dwc, dwc->current_dr_role);\n\n\t\tdwc3_otg_init(dwc);\n\t\tif (dwc->current_otg_role == DWC3_OTG_ROLE_HOST) {\n\t\t\tdwc3_otg_host_init(dwc);\n\t\t} else if (dwc->current_otg_role == DWC3_OTG_ROLE_DEVICE) {\n\t\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\t\tdwc3_gadget_resume(dwc);\n\t\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_runtime_checks(struct dwc3 *dwc)\n{\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tif (dwc->connected)\n\t\t\treturn -EBUSY;\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3     *dwc = dev_get_drvdata(dev);\n\tint\t\tret;\n\n\tif (dwc3_runtime_checks(dwc))\n\t\treturn -EBUSY;\n\n\tret = dwc3_suspend_common(dwc, PMSG_AUTO_SUSPEND);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int dwc3_runtime_resume(struct device *dev)\n{\n\tstruct dwc3     *dwc = dev_get_drvdata(dev);\n\tint\t\tret;\n\n\tret = dwc3_resume_common(dwc, PMSG_AUTO_RESUME);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tdwc3_gadget_process_pending_events(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\n\treturn 0;\n}\n\nstatic int dwc3_runtime_idle(struct device *dev)\n{\n\tstruct dwc3     *dwc = dev_get_drvdata(dev);\n\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tif (dwc3_runtime_checks(dwc))\n\t\t\treturn -EBUSY;\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_autosuspend(dev);\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwc3_suspend(struct device *dev)\n{\n\tstruct dwc3\t*dwc = dev_get_drvdata(dev);\n\tint\t\tret;\n\n\tret = dwc3_suspend_common(dwc, PMSG_SUSPEND);\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int dwc3_resume(struct device *dev)\n{\n\tstruct dwc3\t*dwc = dev_get_drvdata(dev);\n\tint\t\tret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tret = dwc3_resume_common(dwc, PMSG_RESUME);\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void dwc3_complete(struct device *dev)\n{\n\tstruct dwc3\t*dwc = dev_get_drvdata(dev);\n\tu32\t\treg;\n\n\tif (dwc->current_dr_role == DWC3_GCTL_PRTCAP_HOST &&\n\t\t\tdwc->dis_split_quirk) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUCTL3);\n\t\treg |= DWC3_GUCTL3_SPLITDISABLE;\n\t\tdwc3_writel(dwc->regs, DWC3_GUCTL3, reg);\n\t}\n}\n#else\n#define dwc3_complete NULL\n#endif  \n\nstatic const struct dev_pm_ops dwc3_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_suspend, dwc3_resume)\n\t.complete = dwc3_complete,\n\tSET_RUNTIME_PM_OPS(dwc3_runtime_suspend, dwc3_runtime_resume,\n\t\t\tdwc3_runtime_idle)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_dwc3_match[] = {\n\t{\n\t\t.compatible = \"snps,dwc3\"\n\t},\n\t{\n\t\t.compatible = \"synopsys,dwc3\"\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_dwc3_match);\n#endif\n\n#ifdef CONFIG_ACPI\n\n#define ACPI_ID_INTEL_BSW\t\"808622B7\"\n\nstatic const struct acpi_device_id dwc3_acpi_match[] = {\n\t{ ACPI_ID_INTEL_BSW, 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, dwc3_acpi_match);\n#endif\n\nstatic struct platform_driver dwc3_driver = {\n\t.probe\t\t= dwc3_probe,\n\t.remove_new\t= dwc3_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3\",\n\t\t.of_match_table\t= of_match_ptr(of_dwc3_match),\n\t\t.acpi_match_table = ACPI_PTR(dwc3_acpi_match),\n\t\t.pm\t= &dwc3_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dwc3_driver);\n\nMODULE_ALIAS(\"platform:dwc3\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 DRD Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}