{
  "module_name": "ulpi.c",
  "hash_id": "a1bec65a74d75c9db93fefe3a432882443a199c74b6e62e462cefd6bd9120ce4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/ulpi.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/time64.h>\n#include <linux/ulpi/regs.h>\n\n#include \"core.h\"\n#include \"io.h\"\n\n#define DWC3_ULPI_ADDR(a) \\\n\t\t((a >= ULPI_EXT_VENDOR_SPECIFIC) ? \\\n\t\tDWC3_GUSB2PHYACC_ADDR(ULPI_ACCESS_EXTENDED) | \\\n\t\tDWC3_GUSB2PHYACC_EXTEND_ADDR(a) : DWC3_GUSB2PHYACC_ADDR(a))\n\n#define DWC3_ULPI_BASE_DELAY\tDIV_ROUND_UP(NSEC_PER_SEC, 60000000L)\n\nstatic int dwc3_ulpi_busyloop(struct dwc3 *dwc, u8 addr, bool read)\n{\n\tunsigned long ns = 5L * DWC3_ULPI_BASE_DELAY;\n\tunsigned int count = 10000;\n\tu32 reg;\n\n\tif (addr >= ULPI_EXT_VENDOR_SPECIFIC)\n\t\tns += DWC3_ULPI_BASE_DELAY;\n\n\tif (read)\n\t\tns += DWC3_ULPI_BASE_DELAY;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\tif (reg & DWC3_GUSB2PHYCFG_SUSPHY)\n\t\tusleep_range(1000, 1200);\n\n\twhile (count--) {\n\t\tndelay(ns);\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYACC(0));\n\t\tif (reg & DWC3_GUSB2PHYACC_DONE)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int dwc3_ulpi_read(struct device *dev, u8 addr)\n{\n\tstruct dwc3 *dwc = dev_get_drvdata(dev);\n\tu32 reg;\n\tint ret;\n\n\treg = DWC3_GUSB2PHYACC_NEWREGREQ | DWC3_ULPI_ADDR(addr);\n\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYACC(0), reg);\n\n\tret = dwc3_ulpi_busyloop(dwc, addr, true);\n\tif (ret)\n\t\treturn ret;\n\n\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYACC(0));\n\n\treturn DWC3_GUSB2PHYACC_DATA(reg);\n}\n\nstatic int dwc3_ulpi_write(struct device *dev, u8 addr, u8 val)\n{\n\tstruct dwc3 *dwc = dev_get_drvdata(dev);\n\tu32 reg;\n\n\treg = DWC3_GUSB2PHYACC_NEWREGREQ | DWC3_ULPI_ADDR(addr);\n\treg |= DWC3_GUSB2PHYACC_WRITE | val;\n\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYACC(0), reg);\n\n\treturn dwc3_ulpi_busyloop(dwc, addr, false);\n}\n\nstatic const struct ulpi_ops dwc3_ulpi_ops = {\n\t.read = dwc3_ulpi_read,\n\t.write = dwc3_ulpi_write,\n};\n\nint dwc3_ulpi_init(struct dwc3 *dwc)\n{\n\t \n\tdwc->ulpi = ulpi_register_interface(dwc->dev, &dwc3_ulpi_ops);\n\tif (IS_ERR(dwc->ulpi)) {\n\t\tdev_err(dwc->dev, \"failed to register ULPI interface\");\n\t\treturn PTR_ERR(dwc->ulpi);\n\t}\n\n\treturn 0;\n}\n\nvoid dwc3_ulpi_exit(struct dwc3 *dwc)\n{\n\tif (dwc->ulpi) {\n\t\tulpi_unregister_interface(dwc->ulpi);\n\t\tdwc->ulpi = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}