{
  "module_name": "dwc3-imx8mp.c",
  "hash_id": "c83aafdf01636bbfb5644dde543826079ffdd838fb75226d761033fa7bca8fb6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-imx8mp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"core.h\"\n\n \n#define USB_WAKEUP_CTRL\t\t\t0x00\n\n \n#define USB_WAKEUP_EN\t\t\tBIT(31)\n \n#define USB_WAKEUP_SS_CONN\t\tBIT(5)\n \n#define USB_WAKEUP_VBUS_SRC_SESS_VAL\tBIT(4)\n \n#define USB_WAKEUP_U3_EN\t\tBIT(3)\n \n#define USB_WAKEUP_ID_EN\t\tBIT(2)\n \n#define\tUSB_WAKEUP_VBUS_EN\t\tBIT(1)\n \n#define USB_WAKEUP_DPDM_EN\t\tBIT(0)\n\n#define USB_WAKEUP_EN_MASK\t\tGENMASK(5, 0)\n\n \n#define USB_CTRL0\t\t0x00\n#define USB_CTRL1\t\t0x04\n\n#define USB_CTRL0_PORTPWR_EN\tBIT(12)  \n#define USB_CTRL0_USB3_FIXED\tBIT(22)  \n#define USB_CTRL0_USB2_FIXED\tBIT(23)  \n\n#define USB_CTRL1_OC_POLARITY\tBIT(16)  \n#define USB_CTRL1_PWR_POLARITY\tBIT(17)  \n\nstruct dwc3_imx8mp {\n\tstruct device\t\t\t*dev;\n\tstruct platform_device\t\t*dwc3;\n\tvoid __iomem\t\t\t*hsio_blk_base;\n\tvoid __iomem\t\t\t*glue_base;\n\tstruct clk\t\t\t*hsio_clk;\n\tstruct clk\t\t\t*suspend_clk;\n\tint\t\t\t\tirq;\n\tbool\t\t\t\tpm_suspended;\n\tbool\t\t\t\twakeup_pending;\n};\n\nstatic void imx8mp_configure_glue(struct dwc3_imx8mp *dwc3_imx)\n{\n\tstruct device *dev = dwc3_imx->dev;\n\tu32 value;\n\n\tif (!dwc3_imx->glue_base)\n\t\treturn;\n\n\tvalue = readl(dwc3_imx->glue_base + USB_CTRL0);\n\n\tif (device_property_read_bool(dev, \"fsl,permanently-attached\"))\n\t\tvalue |= (USB_CTRL0_USB2_FIXED | USB_CTRL0_USB3_FIXED);\n\telse\n\t\tvalue &= ~(USB_CTRL0_USB2_FIXED | USB_CTRL0_USB3_FIXED);\n\n\tif (device_property_read_bool(dev, \"fsl,disable-port-power-control\"))\n\t\tvalue &= ~(USB_CTRL0_PORTPWR_EN);\n\telse\n\t\tvalue |= USB_CTRL0_PORTPWR_EN;\n\n\twritel(value, dwc3_imx->glue_base + USB_CTRL0);\n\n\tvalue = readl(dwc3_imx->glue_base + USB_CTRL1);\n\tif (device_property_read_bool(dev, \"fsl,over-current-active-low\"))\n\t\tvalue |= USB_CTRL1_OC_POLARITY;\n\telse\n\t\tvalue &= ~USB_CTRL1_OC_POLARITY;\n\n\tif (device_property_read_bool(dev, \"fsl,power-active-low\"))\n\t\tvalue |= USB_CTRL1_PWR_POLARITY;\n\telse\n\t\tvalue &= ~USB_CTRL1_PWR_POLARITY;\n\n\twritel(value, dwc3_imx->glue_base + USB_CTRL1);\n}\n\nstatic void dwc3_imx8mp_wakeup_enable(struct dwc3_imx8mp *dwc3_imx)\n{\n\tstruct dwc3\t*dwc3 = platform_get_drvdata(dwc3_imx->dwc3);\n\tu32\t\tval;\n\n\tif (!dwc3)\n\t\treturn;\n\n\tval = readl(dwc3_imx->hsio_blk_base + USB_WAKEUP_CTRL);\n\n\tif ((dwc3->current_dr_role == DWC3_GCTL_PRTCAP_HOST) && dwc3->xhci)\n\t\tval |= USB_WAKEUP_EN | USB_WAKEUP_SS_CONN |\n\t\t       USB_WAKEUP_U3_EN | USB_WAKEUP_DPDM_EN;\n\telse if (dwc3->current_dr_role == DWC3_GCTL_PRTCAP_DEVICE)\n\t\tval |= USB_WAKEUP_EN | USB_WAKEUP_VBUS_EN |\n\t\t       USB_WAKEUP_VBUS_SRC_SESS_VAL;\n\n\twritel(val, dwc3_imx->hsio_blk_base + USB_WAKEUP_CTRL);\n}\n\nstatic void dwc3_imx8mp_wakeup_disable(struct dwc3_imx8mp *dwc3_imx)\n{\n\tu32 val;\n\n\tval = readl(dwc3_imx->hsio_blk_base + USB_WAKEUP_CTRL);\n\tval &= ~(USB_WAKEUP_EN | USB_WAKEUP_EN_MASK);\n\twritel(val, dwc3_imx->hsio_blk_base + USB_WAKEUP_CTRL);\n}\n\nstatic irqreturn_t dwc3_imx8mp_interrupt(int irq, void *_dwc3_imx)\n{\n\tstruct dwc3_imx8mp\t*dwc3_imx = _dwc3_imx;\n\tstruct dwc3\t\t*dwc = platform_get_drvdata(dwc3_imx->dwc3);\n\n\tif (!dwc3_imx->pm_suspended)\n\t\treturn IRQ_HANDLED;\n\n\tdisable_irq_nosync(dwc3_imx->irq);\n\tdwc3_imx->wakeup_pending = true;\n\n\tif ((dwc->current_dr_role == DWC3_GCTL_PRTCAP_HOST) && dwc->xhci)\n\t\tpm_runtime_resume(&dwc->xhci->dev);\n\telse if (dwc->current_dr_role == DWC3_GCTL_PRTCAP_DEVICE)\n\t\tpm_runtime_get(dwc->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dwc3_imx8mp_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct device_node\t*dwc3_np, *node = dev->of_node;\n\tstruct dwc3_imx8mp\t*dwc3_imx;\n\tstruct resource\t\t*res;\n\tint\t\t\terr, irq;\n\n\tif (!node) {\n\t\tdev_err(dev, \"device node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdwc3_imx = devm_kzalloc(dev, sizeof(*dwc3_imx), GFP_KERNEL);\n\tif (!dwc3_imx)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, dwc3_imx);\n\n\tdwc3_imx->dev = dev;\n\n\tdwc3_imx->hsio_blk_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dwc3_imx->hsio_blk_base))\n\t\treturn PTR_ERR(dwc3_imx->hsio_blk_base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_warn(dev, \"Base address for glue layer missing. Continuing without, some features are missing though.\");\n\t} else {\n\t\tdwc3_imx->glue_base = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(dwc3_imx->glue_base))\n\t\t\treturn PTR_ERR(dwc3_imx->glue_base);\n\t}\n\n\tdwc3_imx->hsio_clk = devm_clk_get(dev, \"hsio\");\n\tif (IS_ERR(dwc3_imx->hsio_clk)) {\n\t\terr = PTR_ERR(dwc3_imx->hsio_clk);\n\t\tdev_err(dev, \"Failed to get hsio clk, err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(dwc3_imx->hsio_clk);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable hsio clk, err=%d\\n\", err);\n\t\treturn err;\n\t}\n\n\tdwc3_imx->suspend_clk = devm_clk_get(dev, \"suspend\");\n\tif (IS_ERR(dwc3_imx->suspend_clk)) {\n\t\terr = PTR_ERR(dwc3_imx->suspend_clk);\n\t\tdev_err(dev, \"Failed to get suspend clk, err=%d\\n\", err);\n\t\tgoto disable_hsio_clk;\n\t}\n\n\terr = clk_prepare_enable(dwc3_imx->suspend_clk);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable suspend clk, err=%d\\n\", err);\n\t\tgoto disable_hsio_clk;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto disable_clks;\n\t}\n\tdwc3_imx->irq = irq;\n\n\timx8mp_configure_glue(dwc3_imx);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\terr = pm_runtime_get_sync(dev);\n\tif (err < 0)\n\t\tgoto disable_rpm;\n\n\tdwc3_np = of_get_compatible_child(node, \"snps,dwc3\");\n\tif (!dwc3_np) {\n\t\terr = -ENODEV;\n\t\tdev_err(dev, \"failed to find dwc3 core child\\n\");\n\t\tgoto disable_rpm;\n\t}\n\n\terr = of_platform_populate(node, NULL, NULL, dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to create dwc3 core\\n\");\n\t\tgoto err_node_put;\n\t}\n\n\tdwc3_imx->dwc3 = of_find_device_by_node(dwc3_np);\n\tif (!dwc3_imx->dwc3) {\n\t\tdev_err(dev, \"failed to get dwc3 platform device\\n\");\n\t\terr = -ENODEV;\n\t\tgoto depopulate;\n\t}\n\tof_node_put(dwc3_np);\n\n\terr = devm_request_threaded_irq(dev, irq, NULL, dwc3_imx8mp_interrupt,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), dwc3_imx);\n\tif (err) {\n\t\tdev_err(dev, \"failed to request IRQ #%d --> %d\\n\", irq, err);\n\t\tgoto depopulate;\n\t}\n\n\tdevice_set_wakeup_capable(dev, true);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\ndepopulate:\n\tof_platform_depopulate(dev);\nerr_node_put:\n\tof_node_put(dwc3_np);\ndisable_rpm:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\ndisable_clks:\n\tclk_disable_unprepare(dwc3_imx->suspend_clk);\ndisable_hsio_clk:\n\tclk_disable_unprepare(dwc3_imx->hsio_clk);\n\n\treturn err;\n}\n\nstatic void dwc3_imx8mp_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_imx8mp *dwc3_imx = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\tof_platform_depopulate(dev);\n\n\tclk_disable_unprepare(dwc3_imx->suspend_clk);\n\tclk_disable_unprepare(dwc3_imx->hsio_clk);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n}\n\nstatic int __maybe_unused dwc3_imx8mp_suspend(struct dwc3_imx8mp *dwc3_imx,\n\t\t\t\t\t      pm_message_t msg)\n{\n\tif (dwc3_imx->pm_suspended)\n\t\treturn 0;\n\n\t \n\tif (PMSG_IS_AUTO(msg) || device_may_wakeup(dwc3_imx->dev))\n\t\tdwc3_imx8mp_wakeup_enable(dwc3_imx);\n\n\tdwc3_imx->pm_suspended = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_imx8mp_resume(struct dwc3_imx8mp *dwc3_imx,\n\t\t\t\t\t     pm_message_t msg)\n{\n\tstruct dwc3\t*dwc = platform_get_drvdata(dwc3_imx->dwc3);\n\tint ret = 0;\n\n\tif (!dwc3_imx->pm_suspended)\n\t\treturn 0;\n\n\t \n\tdwc3_imx8mp_wakeup_disable(dwc3_imx);\n\tdwc3_imx->pm_suspended = false;\n\n\t \n\timx8mp_configure_glue(dwc3_imx);\n\n\tif (dwc3_imx->wakeup_pending) {\n\t\tdwc3_imx->wakeup_pending = false;\n\t\tif (dwc->current_dr_role == DWC3_GCTL_PRTCAP_DEVICE) {\n\t\t\tpm_runtime_mark_last_busy(dwc->dev);\n\t\t\tpm_runtime_put_autosuspend(dwc->dev);\n\t\t} else {\n\t\t\t \n\t\t\tusleep_range(9000, 10000);\n\t\t}\n\t\tenable_irq(dwc3_imx->irq);\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_imx8mp_pm_suspend(struct device *dev)\n{\n\tstruct dwc3_imx8mp *dwc3_imx = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = dwc3_imx8mp_suspend(dwc3_imx, PMSG_SUSPEND);\n\n\tif (device_may_wakeup(dwc3_imx->dev))\n\t\tenable_irq_wake(dwc3_imx->irq);\n\telse\n\t\tclk_disable_unprepare(dwc3_imx->suspend_clk);\n\n\tclk_disable_unprepare(dwc3_imx->hsio_clk);\n\tdev_dbg(dev, \"dwc3 imx8mp pm suspend.\\n\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_imx8mp_pm_resume(struct device *dev)\n{\n\tstruct dwc3_imx8mp *dwc3_imx = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (device_may_wakeup(dwc3_imx->dev)) {\n\t\tdisable_irq_wake(dwc3_imx->irq);\n\t} else {\n\t\tret = clk_prepare_enable(dwc3_imx->suspend_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(dwc3_imx->hsio_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = dwc3_imx8mp_resume(dwc3_imx, PMSG_RESUME);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tdev_dbg(dev, \"dwc3 imx8mp pm resume.\\n\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc3_imx8mp_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_imx8mp *dwc3_imx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"dwc3 imx8mp runtime suspend.\\n\");\n\n\treturn dwc3_imx8mp_suspend(dwc3_imx, PMSG_AUTO_SUSPEND);\n}\n\nstatic int __maybe_unused dwc3_imx8mp_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_imx8mp *dwc3_imx = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"dwc3 imx8mp runtime resume.\\n\");\n\n\treturn dwc3_imx8mp_resume(dwc3_imx, PMSG_AUTO_RESUME);\n}\n\nstatic const struct dev_pm_ops dwc3_imx8mp_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_imx8mp_pm_suspend, dwc3_imx8mp_pm_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_imx8mp_runtime_suspend,\n\t\t\t   dwc3_imx8mp_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id dwc3_imx8mp_of_match[] = {\n\t{ .compatible = \"fsl,imx8mp-dwc3\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dwc3_imx8mp_of_match);\n\nstatic struct platform_driver dwc3_imx8mp_driver = {\n\t.probe\t\t= dwc3_imx8mp_probe,\n\t.remove_new\t= dwc3_imx8mp_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"imx8mp-dwc3\",\n\t\t.pm\t= &dwc3_imx8mp_dev_pm_ops,\n\t\t.of_match_table\t= dwc3_imx8mp_of_match,\n\t},\n};\n\nmodule_platform_driver(dwc3_imx8mp_driver);\n\nMODULE_ALIAS(\"platform:imx8mp-dwc3\");\nMODULE_AUTHOR(\"jun.li@nxp.com\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 imx8mp Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}