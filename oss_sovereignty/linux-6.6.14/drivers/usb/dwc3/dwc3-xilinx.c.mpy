{
  "module_name": "dwc3-xilinx.c",
  "hash_id": "af71d92f26904800755556256cc5ca76f9c9f05c5af4a3776b68431dde6178f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-xilinx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/gpio/consumer.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/io.h>\n\n#include <linux/phy/phy.h>\n\n \n#define XLNX_USB_PHY_RST_EN\t\t\t0x001C\n#define XLNX_PHY_RST_MASK\t\t\t0x1\n\n \n#define XLNX_USB_TRAFFIC_ROUTE_CONFIG\t\t0x005C\n#define XLNX_USB_TRAFFIC_ROUTE_FPD\t\t0x1\n\n \n#define VERSAL_USB_RESET_ID\t\t\t0xC104036\n\n#define XLNX_USB_FPD_PIPE_CLK\t\t\t0x7c\n#define PIPE_CLK_DESELECT\t\t\t1\n#define PIPE_CLK_SELECT\t\t\t\t0\n#define XLNX_USB_FPD_POWER_PRSNT\t\t0x80\n#define FPD_POWER_PRSNT_OPTION\t\t\tBIT(0)\n\nstruct dwc3_xlnx {\n\tint\t\t\t\tnum_clocks;\n\tstruct clk_bulk_data\t\t*clks;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\tint\t\t\t\t(*pltfm_init)(struct dwc3_xlnx *data);\n\tstruct phy\t\t\t*usb3_phy;\n};\n\nstatic void dwc3_xlnx_mask_phy_rst(struct dwc3_xlnx *priv_data, bool mask)\n{\n\tu32 reg;\n\n\t \n\treg = readl(priv_data->regs + XLNX_USB_PHY_RST_EN);\n\n\tif (mask)\n\t\treg &= ~XLNX_PHY_RST_MASK;\n\telse\n\t\treg |= XLNX_PHY_RST_MASK;\n\n\twritel(reg, priv_data->regs + XLNX_USB_PHY_RST_EN);\n}\n\nstatic int dwc3_xlnx_init_versal(struct dwc3_xlnx *priv_data)\n{\n\tstruct device\t\t*dev = priv_data->dev;\n\tint\t\t\tret;\n\n\tdwc3_xlnx_mask_phy_rst(priv_data, false);\n\n\t \n\tret = zynqmp_pm_reset_assert(VERSAL_USB_RESET_ID,\n\t\t\t\t     PM_RESET_ACTION_ASSERT);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"failed to assert Reset\\n\");\n\t\treturn ret;\n\t}\n\n\tret = zynqmp_pm_reset_assert(VERSAL_USB_RESET_ID,\n\t\t\t\t     PM_RESET_ACTION_RELEASE);\n\tif (ret < 0) {\n\t\tdev_err_probe(dev, ret, \"failed to De-assert Reset\\n\");\n\t\treturn ret;\n\t}\n\n\tdwc3_xlnx_mask_phy_rst(priv_data, true);\n\n\treturn 0;\n}\n\nstatic int dwc3_xlnx_init_zynqmp(struct dwc3_xlnx *priv_data)\n{\n\tstruct device\t\t*dev = priv_data->dev;\n\tstruct reset_control\t*crst, *hibrst, *apbrst;\n\tstruct gpio_desc\t*reset_gpio;\n\tint\t\t\tret = 0;\n\tu32\t\t\treg;\n\n\tpriv_data->usb3_phy = devm_phy_optional_get(dev, \"usb3-phy\");\n\tif (IS_ERR(priv_data->usb3_phy)) {\n\t\tret = PTR_ERR(priv_data->usb3_phy);\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"failed to get USB3 PHY\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (!priv_data->usb3_phy)\n\t\tgoto skip_usb3_phy;\n\n\tcrst = devm_reset_control_get_exclusive(dev, \"usb_crst\");\n\tif (IS_ERR(crst)) {\n\t\tret = PTR_ERR(crst);\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"failed to get core reset signal\\n\");\n\t\tgoto err;\n\t}\n\n\thibrst = devm_reset_control_get_exclusive(dev, \"usb_hibrst\");\n\tif (IS_ERR(hibrst)) {\n\t\tret = PTR_ERR(hibrst);\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"failed to get hibernation reset signal\\n\");\n\t\tgoto err;\n\t}\n\n\tapbrst = devm_reset_control_get_exclusive(dev, \"usb_apbrst\");\n\tif (IS_ERR(apbrst)) {\n\t\tret = PTR_ERR(apbrst);\n\t\tdev_err_probe(dev, ret,\n\t\t\t      \"failed to get APB reset signal\\n\");\n\t\tgoto err;\n\t}\n\n\tret = reset_control_assert(crst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to assert core reset\\n\");\n\t\tgoto err;\n\t}\n\n\tret = reset_control_assert(hibrst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to assert hibernation reset\\n\");\n\t\tgoto err;\n\t}\n\n\tret = reset_control_assert(apbrst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to assert APB reset\\n\");\n\t\tgoto err;\n\t}\n\n\tret = phy_init(priv_data->usb3_phy);\n\tif (ret < 0) {\n\t\tphy_exit(priv_data->usb3_phy);\n\t\tgoto err;\n\t}\n\n\tret = reset_control_deassert(apbrst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to release APB reset\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\twritel(FPD_POWER_PRSNT_OPTION, priv_data->regs + XLNX_USB_FPD_POWER_PRSNT);\n\n\t \n\twritel(PIPE_CLK_SELECT, priv_data->regs + XLNX_USB_FPD_PIPE_CLK);\n\n\tret = reset_control_deassert(crst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to release core reset\\n\");\n\t\tgoto err;\n\t}\n\n\tret = reset_control_deassert(hibrst);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to release hibernation reset\\n\");\n\t\tgoto err;\n\t}\n\n\tret = phy_power_on(priv_data->usb3_phy);\n\tif (ret < 0) {\n\t\tphy_exit(priv_data->usb3_phy);\n\t\tgoto err;\n\t}\n\nskip_usb3_phy:\n\t \n\treset_gpio = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(reset_gpio)) {\n\t\treturn dev_err_probe(dev, PTR_ERR(reset_gpio),\n\t\t\t\t     \"Failed to request reset GPIO\\n\");\n\t}\n\n\tif (reset_gpio) {\n\t\t \n\t\tgpiod_set_value_cansleep(reset_gpio, 1);\n\t\tusleep_range(5000, 10000);\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\tusleep_range(5000, 10000);\n\t}\n\n\t \n\tif (of_dma_is_coherent(dev->of_node) || device_iommu_mapped(dev)) {\n\t\treg = readl(priv_data->regs + XLNX_USB_TRAFFIC_ROUTE_CONFIG);\n\t\treg |= XLNX_USB_TRAFFIC_ROUTE_FPD;\n\t\twritel(reg, priv_data->regs + XLNX_USB_TRAFFIC_ROUTE_CONFIG);\n\t}\n\nerr:\n\treturn ret;\n}\n\nstatic const struct of_device_id dwc3_xlnx_of_match[] = {\n\t{\n\t\t.compatible = \"xlnx,zynqmp-dwc3\",\n\t\t.data = &dwc3_xlnx_init_zynqmp,\n\t},\n\t{\n\t\t.compatible = \"xlnx,versal-dwc3\",\n\t\t.data = &dwc3_xlnx_init_versal,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, dwc3_xlnx_of_match);\n\nstatic int dwc3_xlnx_probe(struct platform_device *pdev)\n{\n\tstruct dwc3_xlnx\t\t*priv_data;\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tstruct device_node\t\t*np = dev->of_node;\n\tconst struct of_device_id\t*match;\n\tvoid __iomem\t\t\t*regs;\n\tint\t\t\t\tret;\n\n\tpriv_data = devm_kzalloc(dev, sizeof(*priv_data), GFP_KERNEL);\n\tif (!priv_data)\n\t\treturn -ENOMEM;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs)) {\n\t\tret = PTR_ERR(regs);\n\t\tdev_err_probe(dev, ret, \"failed to map registers\\n\");\n\t\treturn ret;\n\t}\n\n\tmatch = of_match_node(dwc3_xlnx_of_match, pdev->dev.of_node);\n\n\tpriv_data->pltfm_init = match->data;\n\tpriv_data->regs = regs;\n\tpriv_data->dev = dev;\n\n\tplatform_set_drvdata(pdev, priv_data);\n\n\tret = devm_clk_bulk_get_all(priv_data->dev, &priv_data->clks);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpriv_data->num_clocks = ret;\n\n\tret = clk_bulk_prepare_enable(priv_data->num_clocks, priv_data->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = priv_data->pltfm_init(priv_data);\n\tif (ret)\n\t\tgoto err_clk_put;\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret)\n\t\tgoto err_clk_put;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_suspend_ignore_children(dev, false);\n\tpm_runtime_get_sync(dev);\n\n\treturn 0;\n\nerr_clk_put:\n\tclk_bulk_disable_unprepare(priv_data->num_clocks, priv_data->clks);\n\n\treturn ret;\n}\n\nstatic void dwc3_xlnx_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_xlnx\t*priv_data = platform_get_drvdata(pdev);\n\tstruct device\t\t*dev = &pdev->dev;\n\n\tof_platform_depopulate(dev);\n\n\tclk_bulk_disable_unprepare(priv_data->num_clocks, priv_data->clks);\n\tpriv_data->num_clocks = 0;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_suspended(dev);\n}\n\nstatic int __maybe_unused dwc3_xlnx_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_xlnx *priv_data = dev_get_drvdata(dev);\n\n\tclk_bulk_disable(priv_data->num_clocks, priv_data->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_xlnx_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_xlnx *priv_data = dev_get_drvdata(dev);\n\n\treturn clk_bulk_enable(priv_data->num_clocks, priv_data->clks);\n}\n\nstatic int __maybe_unused dwc3_xlnx_runtime_idle(struct device *dev)\n{\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_xlnx_suspend(struct device *dev)\n{\n\tstruct dwc3_xlnx *priv_data = dev_get_drvdata(dev);\n\n\tphy_exit(priv_data->usb3_phy);\n\n\t \n\tclk_bulk_disable(priv_data->num_clocks, priv_data->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_xlnx_resume(struct device *dev)\n{\n\tstruct dwc3_xlnx *priv_data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_bulk_enable(priv_data->num_clocks, priv_data->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_init(priv_data->usb3_phy);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = phy_power_on(priv_data->usb3_phy);\n\tif (ret < 0) {\n\t\tphy_exit(priv_data->usb3_phy);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dwc3_xlnx_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_xlnx_suspend, dwc3_xlnx_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_xlnx_runtime_suspend,\n\t\t\t   dwc3_xlnx_runtime_resume, dwc3_xlnx_runtime_idle)\n};\n\nstatic struct platform_driver dwc3_xlnx_driver = {\n\t.probe\t\t= dwc3_xlnx_probe,\n\t.remove_new\t= dwc3_xlnx_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"dwc3-xilinx\",\n\t\t.of_match_table\t= dwc3_xlnx_of_match,\n\t\t.pm\t\t= &dwc3_xlnx_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dwc3_xlnx_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Xilinx DWC3 controller specific glue driver\");\nMODULE_AUTHOR(\"Manish Narani <manish.narani@xilinx.com>\");\nMODULE_AUTHOR(\"Anurag Kumar Vulisha <anurag.kumar.vulisha@xilinx.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}