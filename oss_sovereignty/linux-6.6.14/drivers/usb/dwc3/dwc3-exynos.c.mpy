{
  "module_name": "dwc3-exynos.c",
  "hash_id": "f88da52963cd995bd2ee1b67422e86471af5369bcab6f97568dfced75c7bff10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/regulator/consumer.h>\n\n#define DWC3_EXYNOS_MAX_CLOCKS\t4\n\nstruct dwc3_exynos_driverdata {\n\tconst char\t\t*clk_names[DWC3_EXYNOS_MAX_CLOCKS];\n\tint\t\t\tnum_clks;\n\tint\t\t\tsuspend_clk_idx;\n};\n\nstruct dwc3_exynos {\n\tstruct device\t\t*dev;\n\n\tconst char\t\t**clk_names;\n\tstruct clk\t\t*clks[DWC3_EXYNOS_MAX_CLOCKS];\n\tint\t\t\tnum_clks;\n\tint\t\t\tsuspend_clk_idx;\n\n\tstruct regulator\t*vdd33;\n\tstruct regulator\t*vdd10;\n};\n\nstatic int dwc3_exynos_probe(struct platform_device *pdev)\n{\n\tstruct dwc3_exynos\t*exynos;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct device_node\t*node = dev->of_node;\n\tconst struct dwc3_exynos_driverdata *driver_data;\n\tint\t\t\ti, ret;\n\n\texynos = devm_kzalloc(dev, sizeof(*exynos), GFP_KERNEL);\n\tif (!exynos)\n\t\treturn -ENOMEM;\n\n\tdriver_data = of_device_get_match_data(dev);\n\texynos->dev = dev;\n\texynos->num_clks = driver_data->num_clks;\n\texynos->clk_names = (const char **)driver_data->clk_names;\n\texynos->suspend_clk_idx = driver_data->suspend_clk_idx;\n\n\tplatform_set_drvdata(pdev, exynos);\n\n\tfor (i = 0; i < exynos->num_clks; i++) {\n\t\texynos->clks[i] = devm_clk_get(dev, exynos->clk_names[i]);\n\t\tif (IS_ERR(exynos->clks[i])) {\n\t\t\tdev_err(dev, \"failed to get clock: %s\\n\",\n\t\t\t\texynos->clk_names[i]);\n\t\t\treturn PTR_ERR(exynos->clks[i]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < exynos->num_clks; i++) {\n\t\tret = clk_prepare_enable(exynos->clks[i]);\n\t\tif (ret) {\n\t\t\twhile (i-- > 0)\n\t\t\t\tclk_disable_unprepare(exynos->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (exynos->suspend_clk_idx >= 0)\n\t\tclk_prepare_enable(exynos->clks[exynos->suspend_clk_idx]);\n\n\texynos->vdd33 = devm_regulator_get(dev, \"vdd33\");\n\tif (IS_ERR(exynos->vdd33)) {\n\t\tret = PTR_ERR(exynos->vdd33);\n\t\tgoto vdd33_err;\n\t}\n\tret = regulator_enable(exynos->vdd33);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable VDD33 supply\\n\");\n\t\tgoto vdd33_err;\n\t}\n\n\texynos->vdd10 = devm_regulator_get(dev, \"vdd10\");\n\tif (IS_ERR(exynos->vdd10)) {\n\t\tret = PTR_ERR(exynos->vdd10);\n\t\tgoto vdd10_err;\n\t}\n\tret = regulator_enable(exynos->vdd10);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable VDD10 supply\\n\");\n\t\tgoto vdd10_err;\n\t}\n\n\tif (node) {\n\t\tret = of_platform_populate(node, NULL, NULL, dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to add dwc3 core\\n\");\n\t\t\tgoto populate_err;\n\t\t}\n\t} else {\n\t\tdev_err(dev, \"no device node, failed to add dwc3 core\\n\");\n\t\tret = -ENODEV;\n\t\tgoto populate_err;\n\t}\n\n\treturn 0;\n\npopulate_err:\n\tregulator_disable(exynos->vdd10);\nvdd10_err:\n\tregulator_disable(exynos->vdd33);\nvdd33_err:\n\tfor (i = exynos->num_clks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(exynos->clks[i]);\n\n\tif (exynos->suspend_clk_idx >= 0)\n\t\tclk_disable_unprepare(exynos->clks[exynos->suspend_clk_idx]);\n\n\treturn ret;\n}\n\nstatic void dwc3_exynos_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_exynos\t*exynos = platform_get_drvdata(pdev);\n\tint i;\n\n\tof_platform_depopulate(&pdev->dev);\n\n\tfor (i = exynos->num_clks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(exynos->clks[i]);\n\n\tif (exynos->suspend_clk_idx >= 0)\n\t\tclk_disable_unprepare(exynos->clks[exynos->suspend_clk_idx]);\n\n\tregulator_disable(exynos->vdd33);\n\tregulator_disable(exynos->vdd10);\n}\n\nstatic const struct dwc3_exynos_driverdata exynos5250_drvdata = {\n\t.clk_names = { \"usbdrd30\" },\n\t.num_clks = 1,\n\t.suspend_clk_idx = -1,\n};\n\nstatic const struct dwc3_exynos_driverdata exynos5433_drvdata = {\n\t.clk_names = { \"aclk\", \"susp_clk\", \"pipe_pclk\", \"phyclk\" },\n\t.num_clks = 4,\n\t.suspend_clk_idx = 1,\n};\n\nstatic const struct dwc3_exynos_driverdata exynos7_drvdata = {\n\t.clk_names = { \"usbdrd30\", \"usbdrd30_susp_clk\", \"usbdrd30_axius_clk\" },\n\t.num_clks = 3,\n\t.suspend_clk_idx = 1,\n};\n\nstatic const struct dwc3_exynos_driverdata exynos850_drvdata = {\n\t.clk_names = { \"bus_early\", \"ref\" },\n\t.num_clks = 2,\n\t.suspend_clk_idx = -1,\n};\n\nstatic const struct of_device_id exynos_dwc3_match[] = {\n\t{\n\t\t.compatible = \"samsung,exynos5250-dwusb3\",\n\t\t.data = &exynos5250_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos5433-dwusb3\",\n\t\t.data = &exynos5433_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos7-dwusb3\",\n\t\t.data = &exynos7_drvdata,\n\t}, {\n\t\t.compatible = \"samsung,exynos850-dwusb3\",\n\t\t.data = &exynos850_drvdata,\n\t}, {\n\t}\n};\nMODULE_DEVICE_TABLE(of, exynos_dwc3_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwc3_exynos_suspend(struct device *dev)\n{\n\tstruct dwc3_exynos *exynos = dev_get_drvdata(dev);\n\tint i;\n\n\tfor (i = exynos->num_clks - 1; i >= 0; i--)\n\t\tclk_disable_unprepare(exynos->clks[i]);\n\n\tregulator_disable(exynos->vdd33);\n\tregulator_disable(exynos->vdd10);\n\n\treturn 0;\n}\n\nstatic int dwc3_exynos_resume(struct device *dev)\n{\n\tstruct dwc3_exynos *exynos = dev_get_drvdata(dev);\n\tint i, ret;\n\n\tret = regulator_enable(exynos->vdd33);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable VDD33 supply\\n\");\n\t\treturn ret;\n\t}\n\tret = regulator_enable(exynos->vdd10);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable VDD10 supply\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < exynos->num_clks; i++) {\n\t\tret = clk_prepare_enable(exynos->clks[i]);\n\t\tif (ret) {\n\t\t\twhile (i-- > 0)\n\t\t\t\tclk_disable_unprepare(exynos->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dwc3_exynos_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_exynos_suspend, dwc3_exynos_resume)\n};\n\n#define DEV_PM_OPS\t(&dwc3_exynos_dev_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic struct platform_driver dwc3_exynos_driver = {\n\t.probe\t\t= dwc3_exynos_probe,\n\t.remove_new\t= dwc3_exynos_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"exynos-dwc3\",\n\t\t.of_match_table = exynos_dwc3_match,\n\t\t.pm\t= DEV_PM_OPS,\n\t},\n};\n\nmodule_platform_driver(dwc3_exynos_driver);\n\nMODULE_AUTHOR(\"Anton Tikhomirov <av.tikhomirov@samsung.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 Exynos Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}