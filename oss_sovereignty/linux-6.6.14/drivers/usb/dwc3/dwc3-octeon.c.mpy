{
  "module_name": "dwc3-octeon.c",
  "hash_id": "de3e7a92aa685293a17158fdf3a5d838f2e75f6d88ed63f78530d40128a2db45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-octeon.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n\n \n#define USBDRD_UCTL_CTL\t\t\t\t0x00\n \n# define USBDRD_UCTL_CTL_CLEAR_BIST\t\tBIT_ULL(63)\n \n# define USBDRD_UCTL_CTL_START_BIST\t\tBIT_ULL(62)\n \n# define USBDRD_UCTL_CTL_REF_CLK_SEL\t\tGENMASK_ULL(61, 60)\n \n# define USBDRD_UCTL_CTL_SSC_EN\t\t\tBIT_ULL(59)\n \n# define USBDRD_UCTL_CTL_SSC_RANGE\t\tGENMASK_ULL(58, 56)\n \n# define USBDRD_UCTL_CTL_SSC_REF_CLK_SEL\tGENMASK_ULL(55, 47)\n \n# define USBDRD_UCTL_CTL_MPLL_MULTIPLIER\tGENMASK_ULL(46, 40)\n \n# define USBDRD_UCTL_CTL_REF_SSP_EN\t\tBIT_ULL(39)\n \n# define USBDRD_UCTL_CTL_REF_CLK_DIV2\t\tBIT_ULL(38)\n \n# define USBDRD_UCTL_CTL_REF_CLK_FSEL\t\tGENMASK_ULL(37, 32)\n \n# define USBDRD_UCTL_CTL_H_CLK_EN\t\tBIT_ULL(30)\n \n# define USBDRD_UCTL_CTL_H_CLK_BYP_SEL\t\tBIT_ULL(29)\n \n# define USBDRD_UCTL_CTL_H_CLKDIV_RST\t\tBIT_ULL(28)\n \n# define USBDRD_UCTL_CTL_H_CLKDIV_SEL\t\tGENMASK_ULL(26, 24)\n \n# define USBDRD_UCTL_CTL_USB3_PORT_PERM_ATTACH\tBIT_ULL(21)\n \n# define USBDRD_UCTL_CTL_USB2_PORT_PERM_ATTACH\tBIT_ULL(20)\n \n# define USBDRD_UCTL_CTL_USB3_PORT_DISABLE\tBIT_ULL(18)\n \n# define USBDRD_UCTL_CTL_USB2_PORT_DISABLE\tBIT_ULL(16)\n \n# define USBDRD_UCTL_CTL_SS_POWER_EN\t\tBIT_ULL(14)\n \n# define USBDRD_UCTL_CTL_HS_POWER_EN\t\tBIT_ULL(12)\n \n# define USBDRD_UCTL_CTL_CSCLK_EN\t\tBIT_ULL(4)\n \n# define USBDRD_UCTL_CTL_DRD_MODE\t\tBIT_ULL(3)\n \n# define USBDRD_UCTL_CTL_UPHY_RST\t\tBIT_ULL(2)\n \n# define USBDRD_UCTL_CTL_UAHC_RST\t\tBIT_ULL(1)\n \n# define USBDRD_UCTL_CTL_UCTL_RST\t\tBIT_ULL(0)\n\n#define USBDRD_UCTL_BIST_STATUS\t\t\t0x08\n#define USBDRD_UCTL_SPARE0\t\t\t0x10\n#define USBDRD_UCTL_INTSTAT\t\t\t0x30\n#define USBDRD_UCTL_PORT_CFG_HS(port)\t\t(0x40 + (0x20 * port))\n#define USBDRD_UCTL_PORT_CFG_SS(port)\t\t(0x48 + (0x20 * port))\n#define USBDRD_UCTL_PORT_CR_DBG_CFG(port)\t(0x50 + (0x20 * port))\n#define USBDRD_UCTL_PORT_CR_DBG_STATUS(port)\t(0x58 + (0x20 * port))\n\n \n#define USBDRD_UCTL_HOST_CFG\t\t\t0xe0\n \n# define USBDRD_UCTL_HOST_CFG_HOST_CURRENT_BELT\tGENMASK_ULL(59, 48)\n \n# define USBDRD_UCTL_HOST_CFG_FLA\t\tGENMASK_ULL(37, 32)\n \n# define USBDRD_UCTL_HOST_CFG_BME\t\tBIT_ULL(28)\n \n# define USBDRD_UCTL_HOST_OCI_EN\t\tBIT_ULL(27)\n \n# define USBDRD_UCTL_HOST_OCI_ACTIVE_HIGH_EN\tBIT_ULL(26)\n \n# define USBDRD_UCTL_HOST_PPC_EN\t\tBIT_ULL(25)\n \n# define USBDRD_UCTL_HOST_PPC_ACTIVE_HIGH_EN\tBIT_ULL(24)\n\n \n#define USBDRD_UCTL_SHIM_CFG\t\t\t0xe8\n \n# define USBDRD_UCTL_SHIM_CFG_XS_NCB_OOB_WRN\tBIT_ULL(63)\n \n# define USBDRD_UCTL_SHIM_CFG_XS_NCB_OOB_OSRC\tGENMASK_ULL(59, 48)\n \n# define USBDRD_UCTL_SHIM_CFG_XM_BAD_DMA_WRN\tBIT_ULL(47)\n \n# define USBDRD_UCTL_SHIM_CFG_XM_BAD_DMA_TYPE\tGENMASK_ULL(43, 40)\n \n# define USBDRD_UCTL_SHIM_CFG_DMA_READ_CMD\tBIT_ULL(12)\n \n# define USBDRD_UCTL_SHIM_CFG_DMA_ENDIAN_MODE\tGENMASK_ULL(9, 8)\n \n# define USBDRD_UCTL_SHIM_CFG_CSR_ENDIAN_MODE\tGENMASK_ULL(1, 0)\n\n#define USBDRD_UCTL_ECC\t\t\t\t0xf0\n#define USBDRD_UCTL_SPARE1\t\t\t0xf8\n\nstruct dwc3_octeon {\n\tstruct device *dev;\n\tvoid __iomem *base;\n};\n\n#define DWC3_GPIO_POWER_NONE\t(-1)\n\n#ifdef CONFIG_CAVIUM_OCTEON_SOC\n#include <asm/octeon/octeon.h>\nstatic inline uint64_t dwc3_octeon_readq(void __iomem *addr)\n{\n\treturn cvmx_readq_csr(addr);\n}\n\nstatic inline void dwc3_octeon_writeq(void __iomem *base, uint64_t val)\n{\n\tcvmx_writeq_csr(base, val);\n}\n\nstatic void dwc3_octeon_config_gpio(int index, int gpio)\n{\n\tunion cvmx_gpio_bit_cfgx gpio_bit;\n\n\tif ((OCTEON_IS_MODEL(OCTEON_CN73XX) ||\n\t    OCTEON_IS_MODEL(OCTEON_CNF75XX))\n\t    && gpio <= 31) {\n\t\tgpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_BIT_CFGX(gpio));\n\t\tgpio_bit.s.tx_oe = 1;\n\t\tgpio_bit.s.output_sel = (index == 0 ? 0x14 : 0x15);\n\t\tcvmx_write_csr(CVMX_GPIO_BIT_CFGX(gpio), gpio_bit.u64);\n\t} else if (gpio <= 15) {\n\t\tgpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_BIT_CFGX(gpio));\n\t\tgpio_bit.s.tx_oe = 1;\n\t\tgpio_bit.s.output_sel = (index == 0 ? 0x14 : 0x19);\n\t\tcvmx_write_csr(CVMX_GPIO_BIT_CFGX(gpio), gpio_bit.u64);\n\t} else {\n\t\tgpio_bit.u64 = cvmx_read_csr(CVMX_GPIO_XBIT_CFGX(gpio));\n\t\tgpio_bit.s.tx_oe = 1;\n\t\tgpio_bit.s.output_sel = (index == 0 ? 0x14 : 0x19);\n\t\tcvmx_write_csr(CVMX_GPIO_XBIT_CFGX(gpio), gpio_bit.u64);\n\t}\n}\n#else\nstatic inline uint64_t dwc3_octeon_readq(void __iomem *addr)\n{\n\treturn 0;\n}\n\nstatic inline void dwc3_octeon_writeq(void __iomem *base, uint64_t val) { }\n\nstatic inline void dwc3_octeon_config_gpio(int index, int gpio) { }\n\nstatic uint64_t octeon_get_io_clock_rate(void)\n{\n\treturn 150000000;\n}\n#endif\n\nstatic int dwc3_octeon_get_divider(void)\n{\n\tstatic const uint8_t clk_div[] = { 1, 2, 4, 6, 8, 16, 24, 32 };\n\tint div = 0;\n\n\twhile (div < ARRAY_SIZE(clk_div)) {\n\t\tuint64_t rate = octeon_get_io_clock_rate() / clk_div[div];\n\t\tif (rate <= 300000000 && rate >= 150000000)\n\t\t\treturn div;\n\t\tdiv++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dwc3_octeon_setup(struct dwc3_octeon *octeon,\n\t\t\t     int ref_clk_sel, int ref_clk_fsel, int mpll_mul,\n\t\t\t     int power_gpio, int power_active_low)\n{\n\tu64 val;\n\tint div;\n\tstruct device *dev = octeon->dev;\n\tvoid __iomem *uctl_ctl_reg = octeon->base + USBDRD_UCTL_CTL;\n\tvoid __iomem *uctl_host_cfg_reg = octeon->base + USBDRD_UCTL_HOST_CFG;\n\n\t \n\n\t \n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval |= USBDRD_UCTL_CTL_UPHY_RST |\n\t       USBDRD_UCTL_CTL_UAHC_RST |\n\t       USBDRD_UCTL_CTL_UCTL_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval |= USBDRD_UCTL_CTL_H_CLKDIV_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tdiv = dwc3_octeon_get_divider();\n\tif (div < 0) {\n\t\tdev_err(dev, \"clock divider invalid\\n\");\n\t\treturn div;\n\t}\n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_H_CLKDIV_SEL;\n\tval |= FIELD_PREP(USBDRD_UCTL_CTL_H_CLKDIV_SEL, div);\n\tval |= USBDRD_UCTL_CTL_H_CLK_EN;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tif ((div != FIELD_GET(USBDRD_UCTL_CTL_H_CLKDIV_SEL, val)) ||\n\t    (!(FIELD_GET(USBDRD_UCTL_CTL_H_CLK_EN, val)))) {\n\t\tdev_err(dev, \"clock init failure (UCTL_CTL=%016llx)\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval &= ~USBDRD_UCTL_CTL_H_CLKDIV_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_REF_CLK_DIV2;\n\tval &= ~USBDRD_UCTL_CTL_REF_CLK_SEL;\n\tval |= FIELD_PREP(USBDRD_UCTL_CTL_REF_CLK_SEL, ref_clk_sel);\n\n\tval &= ~USBDRD_UCTL_CTL_REF_CLK_FSEL;\n\tval |= FIELD_PREP(USBDRD_UCTL_CTL_REF_CLK_FSEL, ref_clk_fsel);\n\n\tval &= ~USBDRD_UCTL_CTL_MPLL_MULTIPLIER;\n\tval |= FIELD_PREP(USBDRD_UCTL_CTL_MPLL_MULTIPLIER, mpll_mul);\n\n\t \n\tval |= USBDRD_UCTL_CTL_SSC_EN;\n\n\t \n\tval |= USBDRD_UCTL_CTL_REF_SSP_EN;\n\n\t \n\n\t \n\tval |= USBDRD_UCTL_CTL_HS_POWER_EN;\n\tval |= USBDRD_UCTL_CTL_SS_POWER_EN;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tudelay(10);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_UCTL_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tudelay(10);\n\n\t \n\tval = dwc3_octeon_readq(uctl_host_cfg_reg);\n\tval |= USBDRD_UCTL_HOST_PPC_EN;\n\tif (power_gpio == DWC3_GPIO_POWER_NONE) {\n\t\tval &= ~USBDRD_UCTL_HOST_PPC_EN;\n\t} else {\n\t\tval |= USBDRD_UCTL_HOST_PPC_EN;\n\t\tdwc3_octeon_config_gpio(((__force uintptr_t)octeon->base >> 24) & 1,\n\t\t\t\t\tpower_gpio);\n\t\tdev_dbg(dev, \"power control is using gpio%d\\n\", power_gpio);\n\t}\n\tif (power_active_low)\n\t\tval &= ~USBDRD_UCTL_HOST_PPC_ACTIVE_HIGH_EN;\n\telse\n\t\tval |= USBDRD_UCTL_HOST_PPC_ACTIVE_HIGH_EN;\n\tdwc3_octeon_writeq(uctl_host_cfg_reg, val);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_UAHC_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tudelay(10);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval |= USBDRD_UCTL_CTL_CSCLK_EN;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\t \n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_DRD_MODE;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n\n\treturn 0;\n}\n\nstatic void dwc3_octeon_set_endian_mode(struct dwc3_octeon *octeon)\n{\n\tu64 val;\n\tvoid __iomem *uctl_shim_cfg_reg = octeon->base + USBDRD_UCTL_SHIM_CFG;\n\n\tval = dwc3_octeon_readq(uctl_shim_cfg_reg);\n\tval &= ~USBDRD_UCTL_SHIM_CFG_DMA_ENDIAN_MODE;\n\tval &= ~USBDRD_UCTL_SHIM_CFG_CSR_ENDIAN_MODE;\n#ifdef __BIG_ENDIAN\n\tval |= FIELD_PREP(USBDRD_UCTL_SHIM_CFG_DMA_ENDIAN_MODE, 1);\n\tval |= FIELD_PREP(USBDRD_UCTL_SHIM_CFG_CSR_ENDIAN_MODE, 1);\n#endif\n\tdwc3_octeon_writeq(uctl_shim_cfg_reg, val);\n}\n\nstatic void dwc3_octeon_phy_reset(struct dwc3_octeon *octeon)\n{\n\tu64 val;\n\tvoid __iomem *uctl_ctl_reg = octeon->base + USBDRD_UCTL_CTL;\n\n\tval = dwc3_octeon_readq(uctl_ctl_reg);\n\tval &= ~USBDRD_UCTL_CTL_UPHY_RST;\n\tdwc3_octeon_writeq(uctl_ctl_reg, val);\n}\n\nstatic int dwc3_octeon_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct dwc3_octeon *octeon;\n\tconst char *hs_clock_type, *ss_clock_type;\n\tint ref_clk_sel, ref_clk_fsel, mpll_mul;\n\tint power_active_low, power_gpio;\n\tint err, len;\n\tu32 clock_rate;\n\n\tif (of_property_read_u32(node, \"refclk-frequency\", &clock_rate)) {\n\t\tdev_err(dev, \"No UCTL \\\"refclk-frequency\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (of_property_read_string(node, \"refclk-type-ss\", &ss_clock_type)) {\n\t\tdev_err(dev, \"No UCTL \\\"refclk-type-ss\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (of_property_read_string(node, \"refclk-type-hs\", &hs_clock_type)) {\n\t\tdev_err(dev, \"No UCTL \\\"refclk-type-hs\\\"\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tref_clk_sel = 2;\n\tif (strcmp(\"dlmc_ref_clk0\", ss_clock_type) == 0) {\n\t\tif (strcmp(hs_clock_type, \"dlmc_ref_clk0\") == 0)\n\t\t\tref_clk_sel = 0;\n\t\telse if (strcmp(hs_clock_type, \"pll_ref_clk\"))\n\t\t\tdev_warn(dev, \"Invalid HS clock type %s, using pll_ref_clk instead\\n\",\n\t\t\t\t hs_clock_type);\n\t} else if (strcmp(ss_clock_type, \"dlmc_ref_clk1\") == 0) {\n\t\tif (strcmp(hs_clock_type, \"dlmc_ref_clk1\") == 0) {\n\t\t\tref_clk_sel = 1;\n\t\t} else {\n\t\t\tref_clk_sel = 3;\n\t\t\tif (strcmp(hs_clock_type, \"pll_ref_clk\"))\n\t\t\t\tdev_warn(dev, \"Invalid HS clock type %s, using pll_ref_clk instead\\n\",\n\t\t\t\t\t hs_clock_type);\n\t\t}\n\t} else {\n\t\tdev_warn(dev, \"Invalid SS clock type %s, using dlmc_ref_clk0 instead\\n\",\n\t\t\t ss_clock_type);\n\t}\n\n\tref_clk_fsel = 0x07;\n\tswitch (clock_rate) {\n\tdefault:\n\t\tdev_warn(dev, \"Invalid ref_clk %u, using 100000000 instead\\n\",\n\t\t\t clock_rate);\n\t\tfallthrough;\n\tcase 100000000:\n\t\tmpll_mul = 0x19;\n\t\tif (ref_clk_sel < 2)\n\t\t\tref_clk_fsel = 0x27;\n\t\tbreak;\n\tcase 50000000:\n\t\tmpll_mul = 0x32;\n\t\tbreak;\n\tcase 125000000:\n\t\tmpll_mul = 0x28;\n\t\tbreak;\n\t}\n\n\tpower_gpio = DWC3_GPIO_POWER_NONE;\n\tpower_active_low = 0;\n\tif (of_find_property(node, \"power\", &len)) {\n\t\tu32 gpio_pwr[3];\n\n\t\tswitch (len) {\n\t\tcase 8:\n\t\t\tof_property_read_u32_array(node, \"power\", gpio_pwr, 2);\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tof_property_read_u32_array(node, \"power\", gpio_pwr, 3);\n\t\t\tpower_active_low = gpio_pwr[2] & 0x01;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid power configuration\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpower_gpio = gpio_pwr[1];\n\t}\n\n\tocteon = devm_kzalloc(dev, sizeof(*octeon), GFP_KERNEL);\n\tif (!octeon)\n\t\treturn -ENOMEM;\n\n\tocteon->dev = dev;\n\tocteon->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(octeon->base))\n\t\treturn PTR_ERR(octeon->base);\n\n\terr = dwc3_octeon_setup(octeon, ref_clk_sel, ref_clk_fsel, mpll_mul,\n\t\t\t\tpower_gpio, power_active_low);\n\tif (err)\n\t\treturn err;\n\n\tdwc3_octeon_set_endian_mode(octeon);\n\tdwc3_octeon_phy_reset(octeon);\n\n\tplatform_set_drvdata(pdev, octeon);\n\n\treturn of_platform_populate(node, NULL, NULL, dev);\n}\n\nstatic void dwc3_octeon_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_octeon *octeon = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(octeon->dev);\n}\n\nstatic const struct of_device_id dwc3_octeon_of_match[] = {\n\t{ .compatible = \"cavium,octeon-7130-usb-uctl\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, dwc3_octeon_of_match);\n\nstatic struct platform_driver dwc3_octeon_driver = {\n\t.probe\t\t= dwc3_octeon_probe,\n\t.remove_new\t= dwc3_octeon_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-octeon\",\n\t\t.of_match_table = dwc3_octeon_of_match,\n\t},\n};\nmodule_platform_driver(dwc3_octeon_driver);\n\nMODULE_ALIAS(\"platform:dwc3-octeon\");\nMODULE_AUTHOR(\"Ladislav Michl <ladis@linux-mips.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"DesignWare USB3 OCTEON III Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}