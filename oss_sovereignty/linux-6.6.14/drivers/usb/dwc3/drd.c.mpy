{
  "module_name": "drd.c",
  "hash_id": "e2c8f3f454826d20f12a94c3c184485be7cb561087d96dc46b0595c9a747faeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/drd.c",
  "human_readable_source": "\n \n\n#include <linux/extcon.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n#include \"gadget.h\"\n\nstatic void dwc3_otg_disable_events(struct dwc3 *dwc, u32 disable_mask)\n{\n\tu32 reg = dwc3_readl(dwc->regs, DWC3_OEVTEN);\n\n\treg &= ~(disable_mask);\n\tdwc3_writel(dwc->regs, DWC3_OEVTEN, reg);\n}\n\nstatic void dwc3_otg_enable_events(struct dwc3 *dwc, u32 enable_mask)\n{\n\tu32 reg = dwc3_readl(dwc->regs, DWC3_OEVTEN);\n\n\treg |= (enable_mask);\n\tdwc3_writel(dwc->regs, DWC3_OEVTEN, reg);\n}\n\nstatic void dwc3_otg_clear_events(struct dwc3 *dwc)\n{\n\tu32 reg = dwc3_readl(dwc->regs, DWC3_OEVT);\n\n\tdwc3_writel(dwc->regs, DWC3_OEVTEN, reg);\n}\n\n#define DWC3_OTG_ALL_EVENTS\t(DWC3_OEVTEN_XHCIRUNSTPSETEN | \\\n\t\tDWC3_OEVTEN_DEVRUNSTPSETEN | DWC3_OEVTEN_HIBENTRYEN | \\\n\t\tDWC3_OEVTEN_CONIDSTSCHNGEN | DWC3_OEVTEN_HRRCONFNOTIFEN | \\\n\t\tDWC3_OEVTEN_HRRINITNOTIFEN | DWC3_OEVTEN_ADEVIDLEEN | \\\n\t\tDWC3_OEVTEN_ADEVBHOSTENDEN | DWC3_OEVTEN_ADEVHOSTEN | \\\n\t\tDWC3_OEVTEN_ADEVHNPCHNGEN | DWC3_OEVTEN_ADEVSRPDETEN | \\\n\t\tDWC3_OEVTEN_ADEVSESSENDDETEN | DWC3_OEVTEN_BDEVBHOSTENDEN | \\\n\t\tDWC3_OEVTEN_BDEVHNPCHNGEN | DWC3_OEVTEN_BDEVSESSVLDDETEN | \\\n\t\tDWC3_OEVTEN_BDEVVBUSCHNGEN)\n\nstatic irqreturn_t dwc3_otg_thread_irq(int irq, void *_dwc)\n{\n\tstruct dwc3 *dwc = _dwc;\n\n\tspin_lock(&dwc->lock);\n\tif (dwc->otg_restart_host) {\n\t\tdwc3_otg_host_init(dwc);\n\t\tdwc->otg_restart_host = false;\n\t}\n\n\tspin_unlock(&dwc->lock);\n\n\tdwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_OTG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t dwc3_otg_irq(int irq, void *_dwc)\n{\n\tu32 reg;\n\tstruct dwc3 *dwc = _dwc;\n\tirqreturn_t ret = IRQ_NONE;\n\n\treg = dwc3_readl(dwc->regs, DWC3_OEVT);\n\tif (reg) {\n\t\t \n\t\tif (!(reg & DWC3_OTG_ALL_EVENTS)) {\n\t\t\tdwc3_writel(dwc->regs, DWC3_OEVT, reg);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\n\t\tif (dwc->current_otg_role == DWC3_OTG_ROLE_HOST &&\n\t\t    !(reg & DWC3_OEVT_DEVICEMODE))\n\t\t\tdwc->otg_restart_host = true;\n\t\tdwc3_writel(dwc->regs, DWC3_OEVT, reg);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\nstatic void dwc3_otgregs_init(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCFG);\n\treg |= DWC3_OCFG_SFTRSTMASK;\n\tdwc3_writel(dwc->regs, DWC3_OCFG, reg);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_GCTL);\n\treg &= ~DWC3_GCTL_GBLHIBERNATIONEN;\n\tdwc3_writel(dwc->regs, DWC3_GCTL, reg);\n\n\t \n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCFG);\n\treg &= ~(DWC3_OCFG_SRPCAP | DWC3_OCFG_HNPCAP);\n\tdwc3_writel(dwc->regs, DWC3_OCFG, reg);\n\t \n\tdwc3_otg_clear_events(dwc);\n\t \n\tdwc3_otg_disable_events(dwc, DWC3_OTG_ALL_EVENTS);\n\t \n\tdwc3_otg_enable_events(dwc, DWC3_OTG_ALL_EVENTS);\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg |= DWC3_OCTL_PERIMODE;\n\treg &= ~(DWC3_OCTL_DEVSETHNPEN | DWC3_OCTL_HSTSETHNPEN |\n\t\t DWC3_OCTL_HNPREQ);\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n}\n\nstatic int dwc3_otg_get_irq(struct dwc3 *dwc)\n{\n\tstruct platform_device *dwc3_pdev = to_platform_device(dwc->dev);\n\tint irq;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"otg\");\n\tif (irq > 0)\n\t\tgoto out;\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"dwc_usb3\");\n\tif (irq > 0)\n\t\tgoto out;\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq(dwc3_pdev, 0);\n\tif (irq > 0)\n\t\tgoto out;\n\n\tif (!irq)\n\t\tirq = -EINVAL;\n\nout:\n\treturn irq;\n}\n\nvoid dwc3_otg_init(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\t \n\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_OTG);\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\treg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\n\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\n\t \n\tdwc3_otgregs_init(dwc);\n}\n\nvoid dwc3_otg_exit(struct dwc3 *dwc)\n{\n\t \n\tdwc3_otg_disable_events(dwc, DWC3_OTG_ALL_EVENTS);\n\t \n\tdwc3_otg_clear_events(dwc);\n}\n\n \nvoid dwc3_otg_host_init(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\t \n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg &= ~(DWC3_OCTL_PERIMODE | DWC3_OCTL_TERMSELIDPULSE |\n\t\t\tDWC3_OCTL_DEVSETHNPEN | DWC3_OCTL_HSTSETHNPEN);\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCFG);\n\treg &= ~DWC3_OCFG_DISPWRCUTTOFF;\n\tdwc3_writel(dwc->regs, DWC3_OCFG, reg);\n\n\t \n\n\t \n\n\t \n\tif (!dwc->dis_u2_susphy_quirk) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\treg |= DWC3_GUSB2PHYCFG_SUSPHY;\n\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t}\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg |= DWC3_OCTL_PRTPWRCTL;\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n}\n\n \nstatic void dwc3_otg_host_exit(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\n\t \n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg &= ~(DWC3_OCTL_HSTSETHNPEN | DWC3_OCTL_PRTPWRCTL);\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n}\n\n \nstatic void dwc3_otg_device_init(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCFG);\n\t \n\treg |= DWC3_OCFG_SFTRSTMASK;\n\tdwc3_writel(dwc->regs, DWC3_OCFG, reg);\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg |= DWC3_OCTL_PERIMODE;\n\treg &= ~(DWC3_OCTL_TERMSELIDPULSE | DWC3_OCTL_HNPREQ |\n\t\t\tDWC3_OCTL_DEVSETHNPEN | DWC3_OCTL_HSTSETHNPEN);\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n\t \n\tdwc3_otg_enable_events(dwc, DWC3_OEVTEN_BDEVSESSVLDDETEN);\n\t \n\tif (!dwc->dis_u2_susphy_quirk) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\treg |= DWC3_GUSB2PHYCFG_SUSPHY;\n\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t}\n\t \n}\n\n \nstatic void dwc3_otg_device_exit(struct dwc3 *dwc)\n{\n\tu32 reg;\n\n\t \n\n\t \n\tdwc3_otg_disable_events(dwc, DWC3_OEVTEN_BDEVHNPCHNGEN |\n\t\t\t\tDWC3_OEVTEN_BDEVVBUSCHNGEN |\n\t\t\t\tDWC3_OEVTEN_BDEVBHOSTENDEN);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_OCTL);\n\treg &= ~(DWC3_OCTL_DEVSETHNPEN | DWC3_OCTL_HNPREQ);\n\treg |= DWC3_OCTL_PERIMODE;\n\tdwc3_writel(dwc->regs, DWC3_OCTL, reg);\n}\n\nvoid dwc3_otg_update(struct dwc3 *dwc, bool ignore_idstatus)\n{\n\tint ret;\n\tu32 reg;\n\tint id;\n\tunsigned long flags;\n\n\tif (dwc->dr_mode != USB_DR_MODE_OTG)\n\t\treturn;\n\n\t \n\tif (dwc->current_dr_role != DWC3_GCTL_PRTCAP_OTG)\n\t\treturn;\n\n\tif (!ignore_idstatus) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_OSTS);\n\t\tid = !!(reg & DWC3_OSTS_CONIDSTS);\n\n\t\tdwc->desired_otg_role = id ? DWC3_OTG_ROLE_DEVICE :\n\t\t\t\t\tDWC3_OTG_ROLE_HOST;\n\t}\n\n\tif (dwc->desired_otg_role == dwc->current_otg_role)\n\t\treturn;\n\n\tswitch (dwc->current_otg_role) {\n\tcase DWC3_OTG_ROLE_HOST:\n\t\tdwc3_host_exit(dwc);\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc3_otg_host_exit(dwc);\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\tbreak;\n\tcase DWC3_OTG_ROLE_DEVICE:\n\t\tdwc3_gadget_exit(dwc);\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc3_event_buffers_cleanup(dwc);\n\t\tdwc3_otg_device_exit(dwc);\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\n\tdwc->current_otg_role = dwc->desired_otg_role;\n\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tswitch (dwc->desired_otg_role) {\n\tcase DWC3_OTG_ROLE_HOST:\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc3_otgregs_init(dwc);\n\t\tdwc3_otg_host_init(dwc);\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\tret = dwc3_host_init(dwc);\n\t\tif (ret) {\n\t\t\tdev_err(dwc->dev, \"failed to initialize host\\n\");\n\t\t} else {\n\t\t\tif (dwc->usb2_phy)\n\t\t\t\totg_set_vbus(dwc->usb2_phy->otg, true);\n\t\t\tif (dwc->usb2_generic_phy)\n\t\t\t\tphy_set_mode(dwc->usb2_generic_phy,\n\t\t\t\t\t     PHY_MODE_USB_HOST);\n\t\t}\n\t\tbreak;\n\tcase DWC3_OTG_ROLE_DEVICE:\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc3_otgregs_init(dwc);\n\t\tdwc3_otg_device_init(dwc);\n\t\tdwc3_event_buffers_setup(dwc);\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\t\tif (dwc->usb2_phy)\n\t\t\totg_set_vbus(dwc->usb2_phy->otg, false);\n\t\tif (dwc->usb2_generic_phy)\n\t\t\tphy_set_mode(dwc->usb2_generic_phy,\n\t\t\t\t     PHY_MODE_USB_DEVICE);\n\t\tret = dwc3_gadget_init(dwc);\n\t\tif (ret)\n\t\t\tdev_err(dwc->dev, \"failed to initialize peripheral\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void dwc3_drd_update(struct dwc3 *dwc)\n{\n\tint id;\n\n\tif (dwc->edev) {\n\t\tid = extcon_get_state(dwc->edev, EXTCON_USB_HOST);\n\t\tif (id < 0)\n\t\t\tid = 0;\n\t\tdwc3_set_mode(dwc, id ?\n\t\t\t      DWC3_GCTL_PRTCAP_HOST :\n\t\t\t      DWC3_GCTL_PRTCAP_DEVICE);\n\t}\n}\n\nstatic int dwc3_drd_notifier(struct notifier_block *nb,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct dwc3 *dwc = container_of(nb, struct dwc3, edev_nb);\n\n\tdwc3_set_mode(dwc, event ?\n\t\t      DWC3_GCTL_PRTCAP_HOST :\n\t\t      DWC3_GCTL_PRTCAP_DEVICE);\n\n\treturn NOTIFY_DONE;\n}\n\n#if IS_ENABLED(CONFIG_USB_ROLE_SWITCH)\n#define ROLE_SWITCH 1\nstatic int dwc3_usb_role_switch_set(struct usb_role_switch *sw,\n\t\t\t\t    enum usb_role role)\n{\n\tstruct dwc3 *dwc = usb_role_switch_get_drvdata(sw);\n\tu32 mode;\n\n\tswitch (role) {\n\tcase USB_ROLE_HOST:\n\t\tmode = DWC3_GCTL_PRTCAP_HOST;\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tmode = DWC3_GCTL_PRTCAP_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tif (dwc->role_switch_default_mode == USB_DR_MODE_HOST)\n\t\t\tmode = DWC3_GCTL_PRTCAP_HOST;\n\t\telse\n\t\t\tmode = DWC3_GCTL_PRTCAP_DEVICE;\n\t\tbreak;\n\t}\n\n\tdwc3_set_mode(dwc, mode);\n\treturn 0;\n}\n\nstatic enum usb_role dwc3_usb_role_switch_get(struct usb_role_switch *sw)\n{\n\tstruct dwc3 *dwc = usb_role_switch_get_drvdata(sw);\n\tunsigned long flags;\n\tenum usb_role role;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\trole = USB_ROLE_HOST;\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\trole = USB_ROLE_DEVICE;\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\trole = dwc->current_otg_role;\n\t\tbreak;\n\tdefault:\n\t\tif (dwc->role_switch_default_mode == USB_DR_MODE_HOST)\n\t\t\trole = USB_ROLE_HOST;\n\t\telse\n\t\t\trole = USB_ROLE_DEVICE;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\treturn role;\n}\n\nstatic int dwc3_setup_role_switch(struct dwc3 *dwc)\n{\n\tstruct usb_role_switch_desc dwc3_role_switch = {NULL};\n\tu32 mode;\n\n\tdwc->role_switch_default_mode = usb_get_role_switch_default_mode(dwc->dev);\n\tif (dwc->role_switch_default_mode == USB_DR_MODE_HOST) {\n\t\tmode = DWC3_GCTL_PRTCAP_HOST;\n\t} else {\n\t\tdwc->role_switch_default_mode = USB_DR_MODE_PERIPHERAL;\n\t\tmode = DWC3_GCTL_PRTCAP_DEVICE;\n\t}\n\tdwc3_set_mode(dwc, mode);\n\n\tdwc3_role_switch.fwnode = dev_fwnode(dwc->dev);\n\tdwc3_role_switch.set = dwc3_usb_role_switch_set;\n\tdwc3_role_switch.get = dwc3_usb_role_switch_get;\n\tdwc3_role_switch.driver_data = dwc;\n\tdwc->role_sw = usb_role_switch_register(dwc->dev, &dwc3_role_switch);\n\tif (IS_ERR(dwc->role_sw))\n\t\treturn PTR_ERR(dwc->role_sw);\n\n\tif (dwc->dev->of_node) {\n\t\t \n\t\tint ret = devm_of_platform_populate(dwc->dev);\n\n\t\tif (ret) {\n\t\t\tusb_role_switch_unregister(dwc->role_sw);\n\t\t\tdwc->role_sw = NULL;\n\t\t\tdev_err(dwc->dev, \"DWC3 platform devices creation failed: %i\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#else\n#define ROLE_SWITCH 0\n#define dwc3_setup_role_switch(x) 0\n#endif\n\nint dwc3_drd_init(struct dwc3 *dwc)\n{\n\tint ret, irq;\n\n\tif (ROLE_SWITCH &&\n\t    device_property_read_bool(dwc->dev, \"usb-role-switch\"))\n\t\treturn dwc3_setup_role_switch(dwc);\n\n\tif (dwc->edev) {\n\t\tdwc->edev_nb.notifier_call = dwc3_drd_notifier;\n\t\tret = extcon_register_notifier(dwc->edev, EXTCON_USB_HOST,\n\t\t\t\t\t       &dwc->edev_nb);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dwc->dev, \"couldn't register cable notifier\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tdwc3_drd_update(dwc);\n\t} else {\n\t\tdwc3_set_prtcap(dwc, DWC3_GCTL_PRTCAP_OTG);\n\n\t\t \n\t\tirq = dwc3_otg_get_irq(dwc);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tdwc->otg_irq = irq;\n\n\t\t \n\t\tdwc3_otg_disable_events(dwc, DWC3_OTG_ALL_EVENTS);\n\t\t \n\t\tdwc3_otg_clear_events(dwc);\n\n\t\tret = request_threaded_irq(dwc->otg_irq, dwc3_otg_irq,\n\t\t\t\t\t   dwc3_otg_thread_irq,\n\t\t\t\t\t   IRQF_SHARED, \"dwc3-otg\", dwc);\n\t\tif (ret) {\n\t\t\tdev_err(dwc->dev, \"failed to request irq #%d --> %d\\n\",\n\t\t\t\tdwc->otg_irq, ret);\n\t\t\tret = -ENODEV;\n\t\t\treturn ret;\n\t\t}\n\n\t\tdwc3_otg_init(dwc);\n\t\tdwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_OTG);\n\t}\n\n\treturn 0;\n}\n\nvoid dwc3_drd_exit(struct dwc3 *dwc)\n{\n\tunsigned long flags;\n\n\tif (dwc->role_sw)\n\t\tusb_role_switch_unregister(dwc->role_sw);\n\n\tif (dwc->edev)\n\t\textcon_unregister_notifier(dwc->edev, EXTCON_USB_HOST,\n\t\t\t\t\t   &dwc->edev_nb);\n\n\tcancel_work_sync(&dwc->drd_work);\n\n\t \n\tswitch (dwc->current_dr_role) {\n\tcase DWC3_GCTL_PRTCAP_HOST:\n\t\tdwc3_host_exit(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_DEVICE:\n\t\tdwc3_gadget_exit(dwc);\n\t\tdwc3_event_buffers_cleanup(dwc);\n\t\tbreak;\n\tcase DWC3_GCTL_PRTCAP_OTG:\n\t\tdwc3_otg_exit(dwc);\n\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\tdwc->desired_otg_role = DWC3_OTG_ROLE_IDLE;\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\tdwc3_otg_update(dwc, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dwc->otg_irq)\n\t\tfree_irq(dwc->otg_irq, dwc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}