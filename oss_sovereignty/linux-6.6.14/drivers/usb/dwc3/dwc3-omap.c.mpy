{
  "module_name": "dwc3-omap.c",
  "hash_id": "9409e2a125db3426459fb5558556c3527cb75bd3317e5ebf7b8f236c923537bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-omap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/extcon.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/usb/otg.h>\n\n \n\n#define USBOTGSS_REVISION\t\t\t0x0000\n#define USBOTGSS_SYSCONFIG\t\t\t0x0010\n#define USBOTGSS_IRQ_EOI\t\t\t0x0020\n#define USBOTGSS_EOI_OFFSET\t\t\t0x0008\n#define USBOTGSS_IRQSTATUS_RAW_0\t\t0x0024\n#define USBOTGSS_IRQSTATUS_0\t\t\t0x0028\n#define USBOTGSS_IRQENABLE_SET_0\t\t0x002c\n#define USBOTGSS_IRQENABLE_CLR_0\t\t0x0030\n#define USBOTGSS_IRQ0_OFFSET\t\t\t0x0004\n#define USBOTGSS_IRQSTATUS_RAW_1\t\t0x0030\n#define USBOTGSS_IRQSTATUS_1\t\t\t0x0034\n#define USBOTGSS_IRQENABLE_SET_1\t\t0x0038\n#define USBOTGSS_IRQENABLE_CLR_1\t\t0x003c\n#define USBOTGSS_IRQSTATUS_RAW_2\t\t0x0040\n#define USBOTGSS_IRQSTATUS_2\t\t\t0x0044\n#define USBOTGSS_IRQENABLE_SET_2\t\t0x0048\n#define USBOTGSS_IRQENABLE_CLR_2\t\t0x004c\n#define USBOTGSS_IRQSTATUS_RAW_3\t\t0x0050\n#define USBOTGSS_IRQSTATUS_3\t\t\t0x0054\n#define USBOTGSS_IRQENABLE_SET_3\t\t0x0058\n#define USBOTGSS_IRQENABLE_CLR_3\t\t0x005c\n#define USBOTGSS_IRQSTATUS_EOI_MISC\t\t0x0030\n#define USBOTGSS_IRQSTATUS_RAW_MISC\t\t0x0034\n#define USBOTGSS_IRQSTATUS_MISC\t\t\t0x0038\n#define USBOTGSS_IRQENABLE_SET_MISC\t\t0x003c\n#define USBOTGSS_IRQENABLE_CLR_MISC\t\t0x0040\n#define USBOTGSS_IRQMISC_OFFSET\t\t\t0x03fc\n#define USBOTGSS_UTMI_OTG_STATUS\t\t0x0080\n#define USBOTGSS_UTMI_OTG_CTRL\t\t\t0x0084\n#define USBOTGSS_UTMI_OTG_OFFSET\t\t0x0480\n#define USBOTGSS_TXFIFO_DEPTH\t\t\t0x0508\n#define USBOTGSS_RXFIFO_DEPTH\t\t\t0x050c\n#define USBOTGSS_MMRAM_OFFSET\t\t\t0x0100\n#define USBOTGSS_FLADJ\t\t\t\t0x0104\n#define USBOTGSS_DEBUG_CFG\t\t\t0x0108\n#define USBOTGSS_DEBUG_DATA\t\t\t0x010c\n#define USBOTGSS_DEV_EBC_EN\t\t\t0x0110\n#define USBOTGSS_DEBUG_OFFSET\t\t\t0x0600\n\n \n#define USBOTGSS_SYSCONFIG_DMADISABLE\t\tBIT(16)\n\n \n#define USBOTGSS_IRQ_EOI_LINE_NUMBER\t\tBIT(0)\n\n \n#define USBOTGSS_IRQO_COREIRQ_ST\t\tBIT(0)\n\n \n#define USBOTGSS_IRQMISC_DMADISABLECLR\t\tBIT(17)\n#define USBOTGSS_IRQMISC_OEVT\t\t\tBIT(16)\n#define USBOTGSS_IRQMISC_DRVVBUS_RISE\t\tBIT(13)\n#define USBOTGSS_IRQMISC_CHRGVBUS_RISE\t\tBIT(12)\n#define USBOTGSS_IRQMISC_DISCHRGVBUS_RISE\tBIT(11)\n#define USBOTGSS_IRQMISC_IDPULLUP_RISE\t\tBIT(8)\n#define USBOTGSS_IRQMISC_DRVVBUS_FALL\t\tBIT(5)\n#define USBOTGSS_IRQMISC_CHRGVBUS_FALL\t\tBIT(4)\n#define USBOTGSS_IRQMISC_DISCHRGVBUS_FALL\t\tBIT(3)\n#define USBOTGSS_IRQMISC_IDPULLUP_FALL\t\tBIT(0)\n\n \n#define USBOTGSS_UTMI_OTG_STATUS_DRVVBUS\tBIT(5)\n#define USBOTGSS_UTMI_OTG_STATUS_CHRGVBUS\tBIT(4)\n#define USBOTGSS_UTMI_OTG_STATUS_DISCHRGVBUS\tBIT(3)\n#define USBOTGSS_UTMI_OTG_STATUS_IDPULLUP\tBIT(0)\n\n \n#define USBOTGSS_UTMI_OTG_CTRL_SW_MODE\t\tBIT(31)\n#define USBOTGSS_UTMI_OTG_CTRL_POWERPRESENT\tBIT(9)\n#define USBOTGSS_UTMI_OTG_CTRL_TXBITSTUFFENABLE BIT(8)\n#define USBOTGSS_UTMI_OTG_CTRL_IDDIG\t\tBIT(4)\n#define USBOTGSS_UTMI_OTG_CTRL_SESSEND\t\tBIT(3)\n#define USBOTGSS_UTMI_OTG_CTRL_SESSVALID\tBIT(2)\n#define USBOTGSS_UTMI_OTG_CTRL_VBUSVALID\tBIT(1)\n\nenum dwc3_omap_utmi_mode {\n\tDWC3_OMAP_UTMI_MODE_UNKNOWN = 0,\n\tDWC3_OMAP_UTMI_MODE_HW,\n\tDWC3_OMAP_UTMI_MODE_SW,\n};\n\nstruct dwc3_omap {\n\tstruct device\t\t*dev;\n\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*base;\n\n\tu32\t\t\tutmi_otg_ctrl;\n\tu32\t\t\tutmi_otg_offset;\n\tu32\t\t\tirqmisc_offset;\n\tu32\t\t\tirq_eoi_offset;\n\tu32\t\t\tdebug_offset;\n\tu32\t\t\tirq0_offset;\n\n\tstruct extcon_dev\t*edev;\n\tstruct notifier_block\tvbus_nb;\n\tstruct notifier_block\tid_nb;\n\n\tstruct regulator\t*vbus_reg;\n};\n\nenum omap_dwc3_vbus_id_status {\n\tOMAP_DWC3_ID_FLOAT,\n\tOMAP_DWC3_ID_GROUND,\n\tOMAP_DWC3_VBUS_OFF,\n\tOMAP_DWC3_VBUS_VALID,\n};\n\nstatic inline u32 dwc3_omap_readl(void __iomem *base, u32 offset)\n{\n\treturn readl(base + offset);\n}\n\nstatic inline void dwc3_omap_writel(void __iomem *base, u32 offset, u32 value)\n{\n\twritel(value, base + offset);\n}\n\nstatic u32 dwc3_omap_read_utmi_ctrl(struct dwc3_omap *omap)\n{\n\treturn dwc3_omap_readl(omap->base, USBOTGSS_UTMI_OTG_CTRL +\n\t\t\t\t\t\t\tomap->utmi_otg_offset);\n}\n\nstatic void dwc3_omap_write_utmi_ctrl(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_UTMI_OTG_CTRL +\n\t\t\t\t\tomap->utmi_otg_offset, value);\n\n}\n\nstatic u32 dwc3_omap_read_irq0_status(struct dwc3_omap *omap)\n{\n\treturn dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_RAW_0 -\n\t\t\t\t\t\tomap->irq0_offset);\n}\n\nstatic void dwc3_omap_write_irq0_status(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_0 -\n\t\t\t\t\t\tomap->irq0_offset, value);\n\n}\n\nstatic u32 dwc3_omap_read_irqmisc_status(struct dwc3_omap *omap)\n{\n\treturn dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_RAW_MISC +\n\t\t\t\t\t\tomap->irqmisc_offset);\n}\n\nstatic void dwc3_omap_write_irqmisc_status(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_MISC +\n\t\t\t\t\tomap->irqmisc_offset, value);\n\n}\n\nstatic void dwc3_omap_write_irqmisc_set(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_MISC +\n\t\t\t\t\t\tomap->irqmisc_offset, value);\n\n}\n\nstatic void dwc3_omap_write_irq0_set(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_0 -\n\t\t\t\t\t\tomap->irq0_offset, value);\n}\n\nstatic void dwc3_omap_write_irqmisc_clr(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_CLR_MISC +\n\t\t\t\t\t\tomap->irqmisc_offset, value);\n}\n\nstatic void dwc3_omap_write_irq0_clr(struct dwc3_omap *omap, u32 value)\n{\n\tdwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_CLR_0 -\n\t\t\t\t\t\tomap->irq0_offset, value);\n}\n\nstatic void dwc3_omap_set_mailbox(struct dwc3_omap *omap,\n\tenum omap_dwc3_vbus_id_status status)\n{\n\tint\tret;\n\tu32\tval;\n\n\tswitch (status) {\n\tcase OMAP_DWC3_ID_GROUND:\n\t\tif (omap->vbus_reg) {\n\t\t\tret = regulator_enable(omap->vbus_reg);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(omap->dev, \"regulator enable failed\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tval = dwc3_omap_read_utmi_ctrl(omap);\n\t\tval &= ~USBOTGSS_UTMI_OTG_CTRL_IDDIG;\n\t\tdwc3_omap_write_utmi_ctrl(omap, val);\n\t\tbreak;\n\n\tcase OMAP_DWC3_VBUS_VALID:\n\t\tval = dwc3_omap_read_utmi_ctrl(omap);\n\t\tval &= ~USBOTGSS_UTMI_OTG_CTRL_SESSEND;\n\t\tval |= USBOTGSS_UTMI_OTG_CTRL_VBUSVALID\n\t\t\t\t| USBOTGSS_UTMI_OTG_CTRL_SESSVALID;\n\t\tdwc3_omap_write_utmi_ctrl(omap, val);\n\t\tbreak;\n\n\tcase OMAP_DWC3_ID_FLOAT:\n\t\tif (omap->vbus_reg && regulator_is_enabled(omap->vbus_reg))\n\t\t\tregulator_disable(omap->vbus_reg);\n\t\tval = dwc3_omap_read_utmi_ctrl(omap);\n\t\tval |= USBOTGSS_UTMI_OTG_CTRL_IDDIG;\n\t\tdwc3_omap_write_utmi_ctrl(omap, val);\n\t\tbreak;\n\n\tcase OMAP_DWC3_VBUS_OFF:\n\t\tval = dwc3_omap_read_utmi_ctrl(omap);\n\t\tval &= ~(USBOTGSS_UTMI_OTG_CTRL_SESSVALID\n\t\t\t\t| USBOTGSS_UTMI_OTG_CTRL_VBUSVALID);\n\t\tval |= USBOTGSS_UTMI_OTG_CTRL_SESSEND;\n\t\tdwc3_omap_write_utmi_ctrl(omap, val);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_WARN(omap->dev, \"invalid state\\n\");\n\t}\n}\n\nstatic void dwc3_omap_enable_irqs(struct dwc3_omap *omap);\nstatic void dwc3_omap_disable_irqs(struct dwc3_omap *omap);\n\nstatic irqreturn_t dwc3_omap_interrupt(int irq, void *_omap)\n{\n\tstruct dwc3_omap\t*omap = _omap;\n\n\tif (dwc3_omap_read_irqmisc_status(omap) ||\n\t    dwc3_omap_read_irq0_status(omap)) {\n\t\t \n\t\tdwc3_omap_disable_irqs(omap);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t dwc3_omap_interrupt_thread(int irq, void *_omap)\n{\n\tstruct dwc3_omap\t*omap = _omap;\n\tu32\t\t\treg;\n\n\t \n\treg = dwc3_omap_read_irqmisc_status(omap);\n\tdwc3_omap_write_irqmisc_status(omap, reg);\n\n\treg = dwc3_omap_read_irq0_status(omap);\n\tdwc3_omap_write_irq0_status(omap, reg);\n\n\t \n\tdwc3_omap_enable_irqs(omap);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dwc3_omap_enable_irqs(struct dwc3_omap *omap)\n{\n\tu32\t\t\treg;\n\n\t \n\treg = USBOTGSS_IRQO_COREIRQ_ST;\n\tdwc3_omap_write_irq0_set(omap, reg);\n\n\treg = (USBOTGSS_IRQMISC_OEVT |\n\t\t\tUSBOTGSS_IRQMISC_DRVVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_CHRGVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_DISCHRGVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_IDPULLUP_RISE |\n\t\t\tUSBOTGSS_IRQMISC_DRVVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_CHRGVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_DISCHRGVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_IDPULLUP_FALL);\n\n\tdwc3_omap_write_irqmisc_set(omap, reg);\n}\n\nstatic void dwc3_omap_disable_irqs(struct dwc3_omap *omap)\n{\n\tu32\t\t\treg;\n\n\t \n\treg = USBOTGSS_IRQO_COREIRQ_ST;\n\tdwc3_omap_write_irq0_clr(omap, reg);\n\n\treg = (USBOTGSS_IRQMISC_OEVT |\n\t\t\tUSBOTGSS_IRQMISC_DRVVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_CHRGVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_DISCHRGVBUS_RISE |\n\t\t\tUSBOTGSS_IRQMISC_IDPULLUP_RISE |\n\t\t\tUSBOTGSS_IRQMISC_DRVVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_CHRGVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_DISCHRGVBUS_FALL |\n\t\t\tUSBOTGSS_IRQMISC_IDPULLUP_FALL);\n\n\tdwc3_omap_write_irqmisc_clr(omap, reg);\n}\n\nstatic int dwc3_omap_id_notifier(struct notifier_block *nb,\n\tunsigned long event, void *ptr)\n{\n\tstruct dwc3_omap *omap = container_of(nb, struct dwc3_omap, id_nb);\n\n\tif (event)\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_GROUND);\n\telse\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_FLOAT);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int dwc3_omap_vbus_notifier(struct notifier_block *nb,\n\tunsigned long event, void *ptr)\n{\n\tstruct dwc3_omap *omap = container_of(nb, struct dwc3_omap, vbus_nb);\n\n\tif (event)\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_VALID);\n\telse\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_OFF);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void dwc3_omap_map_offset(struct dwc3_omap *omap)\n{\n\tstruct device_node\t*node = omap->dev->of_node;\n\n\t \n\tif (of_device_is_compatible(node, \"ti,am437x-dwc3\")) {\n\t\tomap->irq_eoi_offset = USBOTGSS_EOI_OFFSET;\n\t\tomap->irq0_offset = USBOTGSS_IRQ0_OFFSET;\n\t\tomap->irqmisc_offset = USBOTGSS_IRQMISC_OFFSET;\n\t\tomap->utmi_otg_offset = USBOTGSS_UTMI_OTG_OFFSET;\n\t\tomap->debug_offset = USBOTGSS_DEBUG_OFFSET;\n\t}\n}\n\nstatic void dwc3_omap_set_utmi_mode(struct dwc3_omap *omap)\n{\n\tu32\t\t\treg;\n\tstruct device_node\t*node = omap->dev->of_node;\n\tu32\t\t\tutmi_mode = 0;\n\n\treg = dwc3_omap_read_utmi_ctrl(omap);\n\n\tof_property_read_u32(node, \"utmi-mode\", &utmi_mode);\n\n\tswitch (utmi_mode) {\n\tcase DWC3_OMAP_UTMI_MODE_SW:\n\t\treg |= USBOTGSS_UTMI_OTG_CTRL_SW_MODE;\n\t\tbreak;\n\tcase DWC3_OMAP_UTMI_MODE_HW:\n\t\treg &= ~USBOTGSS_UTMI_OTG_CTRL_SW_MODE;\n\t\tbreak;\n\tdefault:\n\t\tdev_WARN(omap->dev, \"UNKNOWN utmi mode %d\\n\", utmi_mode);\n\t}\n\n\tdwc3_omap_write_utmi_ctrl(omap, reg);\n}\n\nstatic int dwc3_omap_extcon_register(struct dwc3_omap *omap)\n{\n\tint\t\t\tret;\n\tstruct device_node\t*node = omap->dev->of_node;\n\tstruct extcon_dev\t*edev;\n\n\tif (of_property_read_bool(node, \"extcon\")) {\n\t\tedev = extcon_get_edev_by_phandle(omap->dev, 0);\n\t\tif (IS_ERR(edev)) {\n\t\t\tdev_vdbg(omap->dev, \"couldn't get extcon device\\n\");\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\n\t\tomap->vbus_nb.notifier_call = dwc3_omap_vbus_notifier;\n\t\tret = devm_extcon_register_notifier(omap->dev, edev,\n\t\t\t\t\t\tEXTCON_USB, &omap->vbus_nb);\n\t\tif (ret < 0)\n\t\t\tdev_vdbg(omap->dev, \"failed to register notifier for USB\\n\");\n\n\t\tomap->id_nb.notifier_call = dwc3_omap_id_notifier;\n\t\tret = devm_extcon_register_notifier(omap->dev, edev,\n\t\t\t\t\t\tEXTCON_USB_HOST, &omap->id_nb);\n\t\tif (ret < 0)\n\t\t\tdev_vdbg(omap->dev, \"failed to register notifier for USB-HOST\\n\");\n\n\t\tif (extcon_get_state(edev, EXTCON_USB) == true)\n\t\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_VALID);\n\t\telse\n\t\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_OFF);\n\n\t\tif (extcon_get_state(edev, EXTCON_USB_HOST) == true)\n\t\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_GROUND);\n\t\telse\n\t\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_FLOAT);\n\n\t\tomap->edev = edev;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_omap_probe(struct platform_device *pdev)\n{\n\tstruct device_node\t*node = pdev->dev.of_node;\n\n\tstruct dwc3_omap\t*omap;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct regulator\t*vbus_reg = NULL;\n\n\tint\t\t\tret;\n\tint\t\t\tirq;\n\n\tvoid __iomem\t\t*base;\n\n\tif (!node) {\n\t\tdev_err(dev, \"device node not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tomap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);\n\tif (!omap)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, omap);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tif (of_property_read_bool(node, \"vbus-supply\")) {\n\t\tvbus_reg = devm_regulator_get(dev, \"vbus\");\n\t\tif (IS_ERR(vbus_reg)) {\n\t\t\tdev_err(dev, \"vbus init failed\\n\");\n\t\t\treturn PTR_ERR(vbus_reg);\n\t\t}\n\t}\n\n\tomap->dev\t= dev;\n\tomap->irq\t= irq;\n\tomap->base\t= base;\n\tomap->vbus_reg\t= vbus_reg;\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"get_sync failed with err %d\\n\", ret);\n\t\tgoto err1;\n\t}\n\n\tdwc3_omap_map_offset(omap);\n\tdwc3_omap_set_utmi_mode(omap);\n\n\tret = dwc3_omap_extcon_register(omap);\n\tif (ret < 0)\n\t\tgoto err1;\n\n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to create dwc3 core\\n\");\n\t\tgoto err1;\n\t}\n\n\tret = devm_request_threaded_irq(dev, omap->irq, dwc3_omap_interrupt,\n\t\t\t\t\tdwc3_omap_interrupt_thread, IRQF_SHARED,\n\t\t\t\t\t\"dwc3-omap\", omap);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ #%d --> %d\\n\",\n\t\t\tomap->irq, ret);\n\t\tgoto err1;\n\t}\n\tdwc3_omap_enable_irqs(omap);\n\treturn 0;\n\nerr1:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void dwc3_omap_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_omap\t*omap = platform_get_drvdata(pdev);\n\n\tdwc3_omap_disable_irqs(omap);\n\tdisable_irq(omap->irq);\n\tof_platform_depopulate(omap->dev);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic const struct of_device_id of_dwc3_match[] = {\n\t{\n\t\t.compatible =\t\"ti,dwc3\"\n\t},\n\t{\n\t\t.compatible =\t\"ti,am437x-dwc3\"\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_dwc3_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwc3_omap_suspend(struct device *dev)\n{\n\tstruct dwc3_omap\t*omap = dev_get_drvdata(dev);\n\n\tomap->utmi_otg_ctrl = dwc3_omap_read_utmi_ctrl(omap);\n\tdwc3_omap_disable_irqs(omap);\n\n\treturn 0;\n}\n\nstatic int dwc3_omap_resume(struct device *dev)\n{\n\tstruct dwc3_omap\t*omap = dev_get_drvdata(dev);\n\n\tdwc3_omap_write_utmi_ctrl(omap, omap->utmi_otg_ctrl);\n\tdwc3_omap_enable_irqs(omap);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void dwc3_omap_complete(struct device *dev)\n{\n\tstruct dwc3_omap\t*omap = dev_get_drvdata(dev);\n\n\tif (extcon_get_state(omap->edev, EXTCON_USB))\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_VALID);\n\telse\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_OFF);\n\n\tif (extcon_get_state(omap->edev, EXTCON_USB_HOST))\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_GROUND);\n\telse\n\t\tdwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_FLOAT);\n}\n\nstatic const struct dev_pm_ops dwc3_omap_dev_pm_ops = {\n\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_omap_suspend, dwc3_omap_resume)\n\t.complete = dwc3_omap_complete,\n};\n\n#define DEV_PM_OPS\t(&dwc3_omap_dev_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif  \n\nstatic struct platform_driver dwc3_omap_driver = {\n\t.probe\t\t= dwc3_omap_probe,\n\t.remove_new\t= dwc3_omap_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"omap-dwc3\",\n\t\t.of_match_table\t= of_dwc3_match,\n\t\t.pm\t= DEV_PM_OPS,\n\t},\n};\n\nmodule_platform_driver(dwc3_omap_driver);\n\nMODULE_ALIAS(\"platform:omap-dwc3\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 OMAP Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}