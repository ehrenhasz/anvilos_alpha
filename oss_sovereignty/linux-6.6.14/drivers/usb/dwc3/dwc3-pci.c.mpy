{
  "module_name": "dwc3-pci.c",
  "hash_id": "51f9df2afbac202056d79f7d4ef2125d8a218c098eafa4363bfef6813f16c6a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/workqueue.h>\n#include <linux/pm_runtime.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/acpi.h>\n#include <linux/delay.h>\n\n#define PCI_DEVICE_ID_INTEL_BYT\t\t\t0x0f37\n#define PCI_DEVICE_ID_INTEL_MRFLD\t\t0x119e\n#define PCI_DEVICE_ID_INTEL_BSW\t\t\t0x22b7\n#define PCI_DEVICE_ID_INTEL_SPTLP\t\t0x9d30\n#define PCI_DEVICE_ID_INTEL_SPTH\t\t0xa130\n#define PCI_DEVICE_ID_INTEL_BXT\t\t\t0x0aaa\n#define PCI_DEVICE_ID_INTEL_BXT_M\t\t0x1aaa\n#define PCI_DEVICE_ID_INTEL_APL\t\t\t0x5aaa\n#define PCI_DEVICE_ID_INTEL_KBP\t\t\t0xa2b0\n#define PCI_DEVICE_ID_INTEL_CMLLP\t\t0x02ee\n#define PCI_DEVICE_ID_INTEL_CMLH\t\t0x06ee\n#define PCI_DEVICE_ID_INTEL_GLK\t\t\t0x31aa\n#define PCI_DEVICE_ID_INTEL_CNPLP\t\t0x9dee\n#define PCI_DEVICE_ID_INTEL_CNPH\t\t0xa36e\n#define PCI_DEVICE_ID_INTEL_CNPV\t\t0xa3b0\n#define PCI_DEVICE_ID_INTEL_ICLLP\t\t0x34ee\n#define PCI_DEVICE_ID_INTEL_EHL\t\t\t0x4b7e\n#define PCI_DEVICE_ID_INTEL_TGPLP\t\t0xa0ee\n#define PCI_DEVICE_ID_INTEL_TGPH\t\t0x43ee\n#define PCI_DEVICE_ID_INTEL_JSP\t\t\t0x4dee\n#define PCI_DEVICE_ID_INTEL_ADL\t\t\t0x460e\n#define PCI_DEVICE_ID_INTEL_ADL_PCH\t\t0x51ee\n#define PCI_DEVICE_ID_INTEL_ADLN\t\t0x465e\n#define PCI_DEVICE_ID_INTEL_ADLN_PCH\t\t0x54ee\n#define PCI_DEVICE_ID_INTEL_ADLS\t\t0x7ae1\n#define PCI_DEVICE_ID_INTEL_RPL\t\t\t0xa70e\n#define PCI_DEVICE_ID_INTEL_RPLS\t\t0x7a61\n#define PCI_DEVICE_ID_INTEL_MTLM\t\t0x7eb1\n#define PCI_DEVICE_ID_INTEL_MTLP\t\t0x7ec1\n#define PCI_DEVICE_ID_INTEL_MTLS\t\t0x7f6f\n#define PCI_DEVICE_ID_INTEL_MTL\t\t\t0x7e7e\n#define PCI_DEVICE_ID_INTEL_TGL\t\t\t0x9a15\n#define PCI_DEVICE_ID_AMD_MR\t\t\t0x163a\n\n#define PCI_INTEL_BXT_DSM_GUID\t\t\"732b85d5-b7a7-4a1b-9ba0-4bbd00ffd511\"\n#define PCI_INTEL_BXT_FUNC_PMU_PWR\t4\n#define PCI_INTEL_BXT_STATE_D0\t\t0\n#define PCI_INTEL_BXT_STATE_D3\t\t3\n\n#define GP_RWBAR\t\t\t1\n#define GP_RWREG1\t\t\t0xa0\n#define GP_RWREG1_ULPI_REFCLK_DISABLE\t(1 << 17)\n\n \nstruct dwc3_pci {\n\tstruct platform_device *dwc3;\n\tstruct pci_dev *pci;\n\n\tguid_t guid;\n\n\tunsigned int has_dsm_for_pm:1;\n\tstruct work_struct wakeup_work;\n};\n\nstatic const struct acpi_gpio_params reset_gpios = { 0, 0, false };\nstatic const struct acpi_gpio_params cs_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_dwc3_byt_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1 },\n\t{ \"cs-gpios\", &cs_gpios, 1 },\n\t{ },\n};\n\nstatic struct gpiod_lookup_table platform_bytcr_gpios = {\n\t.dev_id\t\t= \"0000:00:16.0\",\n\t.table\t\t= {\n\t\tGPIO_LOOKUP(\"INT33FC:00\", 54, \"cs\", GPIO_ACTIVE_HIGH),\n\t\tGPIO_LOOKUP(\"INT33FC:02\", 14, \"reset\", GPIO_ACTIVE_HIGH),\n\t\t{}\n\t},\n};\n\nstatic int dwc3_byt_enable_ulpi_refclock(struct pci_dev *pci)\n{\n\tvoid __iomem\t*reg;\n\tu32\t\tvalue;\n\n\treg = pcim_iomap(pci, GP_RWBAR, 0);\n\tif (!reg)\n\t\treturn -ENOMEM;\n\n\tvalue = readl(reg + GP_RWREG1);\n\tif (!(value & GP_RWREG1_ULPI_REFCLK_DISABLE))\n\t\tgoto unmap;  \n\n\tvalue &= ~GP_RWREG1_ULPI_REFCLK_DISABLE;\n\twritel(value, reg + GP_RWREG1);\n\t \n\tmsleep(100);\nunmap:\n\tpcim_iounmap(pci, reg);\n\treturn 0;\n}\n\nstatic const struct property_entry dwc3_pci_intel_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"peripheral\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct property_entry dwc3_pci_intel_phy_charger_detect_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"peripheral\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u2_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,phy_charger_detect\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct property_entry dwc3_pci_intel_byt_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"peripheral\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u2_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct property_entry dwc3_pci_mrfld_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"otg\"),\n\tPROPERTY_ENTRY_STRING(\"linux,extcon-name\", \"mrfld_bcove_pwrsrc\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u3_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u2_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,usb2-gadget-lpm-disable\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct property_entry dwc3_pci_amd_properties[] = {\n\tPROPERTY_ENTRY_BOOL(\"snps,has-lpm-erratum\"),\n\tPROPERTY_ENTRY_U8(\"snps,lpm-nyet-threshold\", 0xf),\n\tPROPERTY_ENTRY_BOOL(\"snps,u2exit_lfps_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,u2ss_inp3_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,req_p1p2p3_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,del_p1p2p3_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,del_phy_power_chg_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,lfps_filter_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,rx_detect_poll_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,tx_de_emphasis_quirk\"),\n\tPROPERTY_ENTRY_U8(\"snps,tx_de_emphasis\", 1),\n\t \n\tPROPERTY_ENTRY_BOOL(\"snps,disable_scramble_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u3_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"snps,dis_u2_susphy_quirk\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct property_entry dwc3_pci_mr_properties[] = {\n\tPROPERTY_ENTRY_STRING(\"dr_mode\", \"otg\"),\n\tPROPERTY_ENTRY_BOOL(\"usb-role-switch\"),\n\tPROPERTY_ENTRY_STRING(\"role-switch-default-mode\", \"host\"),\n\tPROPERTY_ENTRY_BOOL(\"linux,sysdev_is_parent\"),\n\t{}\n};\n\nstatic const struct software_node dwc3_pci_intel_swnode = {\n\t.properties = dwc3_pci_intel_properties,\n};\n\nstatic const struct software_node dwc3_pci_intel_phy_charger_detect_swnode = {\n\t.properties = dwc3_pci_intel_phy_charger_detect_properties,\n};\n\nstatic const struct software_node dwc3_pci_intel_byt_swnode = {\n\t.properties = dwc3_pci_intel_byt_properties,\n};\n\nstatic const struct software_node dwc3_pci_intel_mrfld_swnode = {\n\t.properties = dwc3_pci_mrfld_properties,\n};\n\nstatic const struct software_node dwc3_pci_amd_swnode = {\n\t.properties = dwc3_pci_amd_properties,\n};\n\nstatic const struct software_node dwc3_pci_amd_mr_swnode = {\n\t.properties = dwc3_pci_mr_properties,\n};\n\nstatic int dwc3_pci_quirks(struct dwc3_pci *dwc,\n\t\t\t   const struct software_node *swnode)\n{\n\tstruct pci_dev\t\t\t*pdev = dwc->pci;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\n\t\tif (pdev->device == PCI_DEVICE_ID_INTEL_BXT ||\n\t\t    pdev->device == PCI_DEVICE_ID_INTEL_BXT_M ||\n\t\t    pdev->device == PCI_DEVICE_ID_INTEL_EHL) {\n\t\t\tguid_parse(PCI_INTEL_BXT_DSM_GUID, &dwc->guid);\n\t\t\tdwc->has_dsm_for_pm = true;\n\t\t}\n\n\t\tif (pdev->device == PCI_DEVICE_ID_INTEL_BYT) {\n\t\t\tstruct gpio_desc *gpio;\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tret = dwc3_byt_enable_ulpi_refclock(pdev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tret = devm_acpi_dev_add_driver_gpios(&pdev->dev,\n\t\t\t\t\tacpi_dwc3_byt_gpios);\n\t\t\tif (ret)\n\t\t\t\tdev_dbg(&pdev->dev, \"failed to add mapping table\\n\");\n\n\t\t\t \n\t\t\tif (acpi_dev_present(\"INT33FC\", NULL, -1))\n\t\t\t\tgpiod_add_lookup_table(&platform_bytcr_gpios);\n\n\t\t\t \n\t\t\tgpio = gpiod_get_optional(&pdev->dev, \"cs\", GPIOD_OUT_LOW);\n\t\t\tif (IS_ERR(gpio))\n\t\t\t\treturn PTR_ERR(gpio);\n\n\t\t\tgpiod_set_value_cansleep(gpio, 1);\n\t\t\tgpiod_put(gpio);\n\n\t\t\tgpio = gpiod_get_optional(&pdev->dev, \"reset\", GPIOD_OUT_LOW);\n\t\t\tif (IS_ERR(gpio))\n\t\t\t\treturn PTR_ERR(gpio);\n\n\t\t\tif (gpio) {\n\t\t\t\tgpiod_set_value_cansleep(gpio, 1);\n\t\t\t\tgpiod_put(gpio);\n\t\t\t\tusleep_range(10000, 11000);\n\t\t\t}\n\n\t\t\t \n\t\t\tdwc->dwc3->id = PLATFORM_DEVID_NONE;\n\t\t\tplatform_bytcr_gpios.dev_id = \"dwc3.ulpi\";\n\n\t\t\t \n\t\t\tif (acpi_dev_present(\"INT33FD\", \"1\", 2) &&\n\t\t\t    acpi_quirk_skip_acpi_ac_and_battery()) {\n\t\t\t\tdev_info(&pdev->dev, \"Using TUSB1211 phy for charger detection\\n\");\n\t\t\t\tswnode = &dwc3_pci_intel_phy_charger_detect_swnode;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn device_add_software_node(&dwc->dwc3->dev, swnode);\n}\n\n#ifdef CONFIG_PM\nstatic void dwc3_pci_resume_work(struct work_struct *work)\n{\n\tstruct dwc3_pci *dwc = container_of(work, struct dwc3_pci, wakeup_work);\n\tstruct platform_device *dwc3 = dwc->dwc3;\n\tint ret;\n\n\tret = pm_runtime_get_sync(&dwc3->dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_sync_autosuspend(&dwc3->dev);\n\t\treturn;\n\t}\n\n\tpm_runtime_mark_last_busy(&dwc3->dev);\n\tpm_runtime_put_sync_autosuspend(&dwc3->dev);\n}\n#endif\n\nstatic int dwc3_pci_probe(struct pci_dev *pci, const struct pci_device_id *id)\n{\n\tstruct dwc3_pci\t\t*dwc;\n\tstruct resource\t\tres[2];\n\tint\t\t\tret;\n\tstruct device\t\t*dev = &pci->dev;\n\n\tret = pcim_enable_device(pci);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable pci device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pci);\n\n\tdwc = devm_kzalloc(dev, sizeof(*dwc), GFP_KERNEL);\n\tif (!dwc)\n\t\treturn -ENOMEM;\n\n\tdwc->dwc3 = platform_device_alloc(\"dwc3\", PLATFORM_DEVID_AUTO);\n\tif (!dwc->dwc3)\n\t\treturn -ENOMEM;\n\n\tmemset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));\n\n\tres[0].start\t= pci_resource_start(pci, 0);\n\tres[0].end\t= pci_resource_end(pci, 0);\n\tres[0].name\t= \"dwc_usb3\";\n\tres[0].flags\t= IORESOURCE_MEM;\n\n\tres[1].start\t= pci->irq;\n\tres[1].name\t= \"dwc_usb3\";\n\tres[1].flags\t= IORESOURCE_IRQ;\n\n\tret = platform_device_add_resources(dwc->dwc3, res, ARRAY_SIZE(res));\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdwc->pci = pci;\n\tdwc->dwc3->dev.parent = dev;\n\tACPI_COMPANION_SET(&dwc->dwc3->dev, ACPI_COMPANION(dev));\n\n\tret = dwc3_pci_quirks(dwc, (void *)id->driver_data);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(dwc->dwc3);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register dwc3 device\\n\");\n\t\tgoto err;\n\t}\n\n\tdevice_init_wakeup(dev, true);\n\tpci_set_drvdata(pci, dwc);\n\tpm_runtime_put(dev);\n#ifdef CONFIG_PM\n\tINIT_WORK(&dwc->wakeup_work, dwc3_pci_resume_work);\n#endif\n\n\treturn 0;\nerr:\n\tdevice_remove_software_node(&dwc->dwc3->dev);\n\tplatform_device_put(dwc->dwc3);\n\treturn ret;\n}\n\nstatic void dwc3_pci_remove(struct pci_dev *pci)\n{\n\tstruct dwc3_pci\t\t*dwc = pci_get_drvdata(pci);\n\tstruct pci_dev\t\t*pdev = dwc->pci;\n\n\tif (pdev->device == PCI_DEVICE_ID_INTEL_BYT)\n\t\tgpiod_remove_lookup_table(&platform_bytcr_gpios);\n#ifdef CONFIG_PM\n\tcancel_work_sync(&dwc->wakeup_work);\n#endif\n\tdevice_init_wakeup(&pci->dev, false);\n\tpm_runtime_get(&pci->dev);\n\tdevice_remove_software_node(&dwc->dwc3->dev);\n\tplatform_device_unregister(dwc->dwc3);\n}\n\nstatic const struct pci_device_id dwc3_pci_id_table[] = {\n\t{ PCI_DEVICE_DATA(INTEL, BSW, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, BYT, &dwc3_pci_intel_byt_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, MRFLD, &dwc3_pci_intel_mrfld_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, CMLLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, CMLH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, SPTLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, SPTH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, BXT, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, BXT_M, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, APL, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, KBP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, GLK, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, CNPLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, CNPH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, CNPV, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ICLLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, EHL, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, TGPLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, TGPH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, JSP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ADL, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ADL_PCH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLN, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLN_PCH, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, ADLS, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, RPL, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, RPLS, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, MTLM, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, MTLP, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, MTL, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, MTLS, &dwc3_pci_intel_swnode) },\n\t{ PCI_DEVICE_DATA(INTEL, TGL, &dwc3_pci_intel_swnode) },\n\n\t{ PCI_DEVICE_DATA(AMD, NL_USB, &dwc3_pci_amd_swnode) },\n\t{ PCI_DEVICE_DATA(AMD, MR, &dwc3_pci_amd_mr_swnode) },\n\n\t{  }\t \n};\nMODULE_DEVICE_TABLE(pci, dwc3_pci_id_table);\n\n#if defined(CONFIG_PM) || defined(CONFIG_PM_SLEEP)\nstatic int dwc3_pci_dsm(struct dwc3_pci *dwc, int param)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object tmp;\n\tunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);\n\n\tif (!dwc->has_dsm_for_pm)\n\t\treturn 0;\n\n\ttmp.type = ACPI_TYPE_INTEGER;\n\ttmp.integer.value = param;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(&dwc->pci->dev), &dwc->guid,\n\t\t\t1, PCI_INTEL_BXT_FUNC_PMU_PWR, &argv4);\n\tif (!obj) {\n\t\tdev_err(&dwc->pci->dev, \"failed to evaluate _DSM\\n\");\n\t\treturn -EIO;\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int dwc3_pci_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_pci\t\t*dwc = dev_get_drvdata(dev);\n\n\tif (device_can_wakeup(dev))\n\t\treturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D3);\n\n\treturn -EBUSY;\n}\n\nstatic int dwc3_pci_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_pci\t\t*dwc = dev_get_drvdata(dev);\n\tint\t\t\tret;\n\n\tret = dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D0);\n\tif (ret)\n\t\treturn ret;\n\n\tqueue_work(pm_wq, &dwc->wakeup_work);\n\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwc3_pci_suspend(struct device *dev)\n{\n\tstruct dwc3_pci\t\t*dwc = dev_get_drvdata(dev);\n\n\treturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D3);\n}\n\nstatic int dwc3_pci_resume(struct device *dev)\n{\n\tstruct dwc3_pci\t\t*dwc = dev_get_drvdata(dev);\n\n\treturn dwc3_pci_dsm(dwc, PCI_INTEL_BXT_STATE_D0);\n}\n#endif  \n\nstatic const struct dev_pm_ops dwc3_pci_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_pci_suspend, dwc3_pci_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_pci_runtime_suspend, dwc3_pci_runtime_resume,\n\t\tNULL)\n};\n\nstatic struct pci_driver dwc3_pci_driver = {\n\t.name\t\t= \"dwc3-pci\",\n\t.id_table\t= dwc3_pci_id_table,\n\t.probe\t\t= dwc3_pci_probe,\n\t.remove\t\t= dwc3_pci_remove,\n\t.driver\t\t= {\n\t\t.pm\t= &dwc3_pci_dev_pm_ops,\n\t}\n};\n\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 PCI Glue Layer\");\n\nmodule_pci_driver(dwc3_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}