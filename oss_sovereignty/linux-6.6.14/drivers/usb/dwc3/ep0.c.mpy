{
  "module_name": "ep0.c",
  "hash_id": "8ac3a64859d114e385bee6ccce13cc5455e3689603d733f51c2be7c1c12dc0b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/ep0.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/dma-mapping.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/composite.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"gadget.h\"\n#include \"io.h\"\n\nstatic void __dwc3_ep0_do_control_status(struct dwc3 *dwc, struct dwc3_ep *dep);\nstatic void __dwc3_ep0_do_control_data(struct dwc3 *dwc,\n\t\tstruct dwc3_ep *dep, struct dwc3_request *req);\nstatic int dwc3_ep0_delegate_req(struct dwc3 *dwc,\n\t\t\t\t struct usb_ctrlrequest *ctrl);\n\nstatic void dwc3_ep0_prepare_one_trb(struct dwc3_ep *dep,\n\t\tdma_addr_t buf_dma, u32 len, u32 type, bool chain)\n{\n\tstruct dwc3_trb\t\t\t*trb;\n\tstruct dwc3\t\t\t*dwc;\n\n\tdwc = dep->dwc;\n\ttrb = &dwc->ep0_trb[dep->trb_enqueue];\n\n\tif (chain)\n\t\tdep->trb_enqueue++;\n\n\ttrb->bpl = lower_32_bits(buf_dma);\n\ttrb->bph = upper_32_bits(buf_dma);\n\ttrb->size = len;\n\ttrb->ctrl = type;\n\n\ttrb->ctrl |= (DWC3_TRB_CTRL_HWO\n\t\t\t| DWC3_TRB_CTRL_ISP_IMI);\n\n\tif (chain)\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_CHN;\n\telse\n\t\ttrb->ctrl |= (DWC3_TRB_CTRL_IOC\n\t\t\t\t| DWC3_TRB_CTRL_LST);\n\n\ttrace_dwc3_prepare_trb(dep, trb);\n}\n\nstatic int dwc3_ep0_start_trans(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3\t\t\t*dwc;\n\tint\t\t\t\tret;\n\n\tif (dep->flags & DWC3_EP_TRANSFER_STARTED)\n\t\treturn 0;\n\n\tdwc = dep->dwc;\n\n\tmemset(&params, 0, sizeof(params));\n\tparams.param0 = upper_32_bits(dwc->ep0_trb_addr);\n\tparams.param1 = lower_32_bits(dwc->ep0_trb_addr);\n\n\tret = dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_STARTTRANSFER, &params);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdwc->ep0_next_event = DWC3_EP0_COMPLETE;\n\n\treturn 0;\n}\n\nstatic int __dwc3_gadget_ep0_queue(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\treq->request.actual\t= 0;\n\treq->request.status\t= -EINPROGRESS;\n\treq->epnum\t\t= dep->number;\n\n\tlist_add_tail(&req->list, &dep->pending_list);\n\n\t \n\tif (dep->flags & DWC3_EP_PENDING_REQUEST) {\n\t\tunsigned int direction;\n\n\t\tdirection = !!(dep->flags & DWC3_EP0_DIR_IN);\n\n\t\tif (dwc->ep0state != EP0_DATA_PHASE) {\n\t\t\tdev_WARN(dwc->dev, \"Unexpected pending request\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\t__dwc3_ep0_do_control_data(dwc, dwc->eps[direction], req);\n\n\t\tdep->flags &= ~(DWC3_EP_PENDING_REQUEST |\n\t\t\t\tDWC3_EP0_DIR_IN);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (dwc->delayed_status) {\n\t\tunsigned int direction;\n\n\t\tdirection = !dwc->ep0_expect_in;\n\t\tdwc->delayed_status = false;\n\t\tusb_gadget_set_state(dwc->gadget, USB_STATE_CONFIGURED);\n\n\t\tif (dwc->ep0state == EP0_STATUS_PHASE)\n\t\t\t__dwc3_ep0_do_control_status(dwc, dwc->eps[direction]);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (dwc->three_stage_setup) {\n\t\tunsigned int direction;\n\n\t\tdirection = dwc->ep0_expect_in;\n\t\tdwc->ep0state = EP0_DATA_PHASE;\n\n\t\t__dwc3_ep0_do_control_data(dwc, dwc->eps[direction], req);\n\n\t\tdep->flags &= ~DWC3_EP0_DIR_IN;\n\t}\n\n\treturn 0;\n}\n\nint dwc3_gadget_ep0_queue(struct usb_ep *ep, struct usb_request *request,\n\t\tgfp_t gfp_flags)\n{\n\tstruct dwc3_request\t\t*req = to_dwc3_request(request);\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tunsigned long\t\t\tflags;\n\n\tint\t\t\t\tret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tif (!dep->endpoint.desc || !dwc->pullups_connected || !dwc->connected) {\n\t\tdev_err(dwc->dev, \"%s: can't queue to disabled endpoint\\n\",\n\t\t\t\tdep->name);\n\t\tret = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!list_empty(&dep->pending_list)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = __dwc3_gadget_ep0_queue(dep, req);\n\nout:\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nvoid dwc3_ep0_stall_and_restart(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep\t\t*dep;\n\n\t \n\tdep = dwc->eps[1];\n\tdep->flags = DWC3_EP_ENABLED;\n\n\t \n\tdep = dwc->eps[0];\n\t__dwc3_gadget_ep_set_halt(dep, 1, false);\n\tdep->flags = DWC3_EP_ENABLED;\n\tdwc->delayed_status = false;\n\n\tif (!list_empty(&dep->pending_list)) {\n\t\tstruct dwc3_request\t*req;\n\n\t\treq = next_request(&dep->pending_list);\n\t\tif (!dwc->connected)\n\t\t\tdwc3_gadget_giveback(dep, req, -ESHUTDOWN);\n\t\telse\n\t\t\tdwc3_gadget_giveback(dep, req, -ECONNRESET);\n\t}\n\n\tdwc->eps[0]->trb_enqueue = 0;\n\tdwc->eps[1]->trb_enqueue = 0;\n\tdwc->ep0state = EP0_SETUP_PHASE;\n\tdwc3_ep0_out_start(dwc);\n}\n\nint __dwc3_gadget_ep0_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tdwc3_ep0_stall_and_restart(dwc);\n\n\treturn 0;\n}\n\nint dwc3_gadget_ep0_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = __dwc3_gadget_ep0_set_halt(ep, value);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nvoid dwc3_ep0_out_start(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep\t\t\t*dep;\n\tint\t\t\t\tret;\n\tint                             i;\n\n\tcomplete(&dwc->ep0_in_setup);\n\n\tdep = dwc->eps[0];\n\tdwc3_ep0_prepare_one_trb(dep, dwc->ep0_trb_addr, 8,\n\t\t\tDWC3_TRBCTL_CONTROL_SETUP, false);\n\tret = dwc3_ep0_start_trans(dep);\n\tWARN_ON(ret < 0);\n\tfor (i = 2; i < DWC3_ENDPOINTS_NUM; i++) {\n\t\tstruct dwc3_ep *dwc3_ep;\n\n\t\tdwc3_ep = dwc->eps[i];\n\t\tif (!dwc3_ep)\n\t\t\tcontinue;\n\n\t\tif (!(dwc3_ep->flags & DWC3_EP_DELAY_STOP))\n\t\t\tcontinue;\n\n\t\tdwc3_ep->flags &= ~DWC3_EP_DELAY_STOP;\n\t\tif (dwc->connected)\n\t\t\tdwc3_stop_active_transfer(dwc3_ep, true, true);\n\t\telse\n\t\t\tdwc3_remove_requests(dwc, dwc3_ep, -ESHUTDOWN);\n\t}\n}\n\nstatic struct dwc3_ep *dwc3_wIndex_to_dep(struct dwc3 *dwc, __le16 wIndex_le)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tu32\t\t\twindex = le16_to_cpu(wIndex_le);\n\tu32\t\t\tepnum;\n\n\tepnum = (windex & USB_ENDPOINT_NUMBER_MASK) << 1;\n\tif ((windex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\n\t\tepnum |= 1;\n\n\tdep = dwc->eps[epnum];\n\tif (dep == NULL)\n\t\treturn NULL;\n\n\tif (dep->flags & DWC3_EP_ENABLED)\n\t\treturn dep;\n\n\treturn NULL;\n}\n\nstatic void dwc3_ep0_status_cmpl(struct usb_ep *ep, struct usb_request *req)\n{\n}\n \nstatic int dwc3_ep0_handle_status(struct dwc3 *dwc,\n\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tu32\t\t\trecip;\n\tu32\t\t\tvalue;\n\tu32\t\t\treg;\n\tu16\t\t\tusb_status = 0;\n\t__le16\t\t\t*response_pkt;\n\n\t \n\tvalue = le16_to_cpu(ctrl->wValue);\n\tif (value != 0)\n\t\treturn -EINVAL;\n\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\t \n\t\tusb_status |= dwc->gadget->is_selfpowered;\n\n\t\tif ((dwc->speed == DWC3_DSTS_SUPERSPEED) ||\n\t\t    (dwc->speed == DWC3_DSTS_SUPERSPEED_PLUS)) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\t\tif (reg & DWC3_DCTL_INITU1ENA)\n\t\t\t\tusb_status |= 1 << USB_DEV_STAT_U1_ENABLED;\n\t\t\tif (reg & DWC3_DCTL_INITU2ENA)\n\t\t\t\tusb_status |= 1 << USB_DEV_STAT_U2_ENABLED;\n\t\t} else {\n\t\t\tusb_status |= dwc->gadget->wakeup_armed <<\n\t\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP;\n\t\t}\n\n\t\tbreak;\n\n\tcase USB_RECIP_INTERFACE:\n\t\t \n\t\treturn dwc3_ep0_delegate_req(dwc, ctrl);\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tdep = dwc3_wIndex_to_dep(dwc, ctrl->wIndex);\n\t\tif (!dep)\n\t\t\treturn -EINVAL;\n\n\t\tif (dep->flags & DWC3_EP_STALL)\n\t\t\tusb_status = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tresponse_pkt = (__le16 *) dwc->setup_buf;\n\t*response_pkt = cpu_to_le16(usb_status);\n\n\tdep = dwc->eps[0];\n\tdwc->ep0_usb_req.dep = dep;\n\tdwc->ep0_usb_req.request.length = sizeof(*response_pkt);\n\tdwc->ep0_usb_req.request.buf = dwc->setup_buf;\n\tdwc->ep0_usb_req.request.complete = dwc3_ep0_status_cmpl;\n\n\treturn __dwc3_gadget_ep0_queue(dep, &dwc->ep0_usb_req);\n}\n\nstatic int dwc3_ep0_handle_u1(struct dwc3 *dwc, enum usb_device_state state,\n\t\tint set)\n{\n\tu32 reg;\n\n\tif (state != USB_STATE_CONFIGURED)\n\t\treturn -EINVAL;\n\tif ((dwc->speed != DWC3_DSTS_SUPERSPEED) &&\n\t\t\t(dwc->speed != DWC3_DSTS_SUPERSPEED_PLUS))\n\t\treturn -EINVAL;\n\tif (set && dwc->dis_u1_entry_quirk)\n\t\treturn -EINVAL;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\tif (set)\n\t\treg |= DWC3_DCTL_INITU1ENA;\n\telse\n\t\treg &= ~DWC3_DCTL_INITU1ENA;\n\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_handle_u2(struct dwc3 *dwc, enum usb_device_state state,\n\t\tint set)\n{\n\tu32 reg;\n\n\n\tif (state != USB_STATE_CONFIGURED)\n\t\treturn -EINVAL;\n\tif ((dwc->speed != DWC3_DSTS_SUPERSPEED) &&\n\t\t\t(dwc->speed != DWC3_DSTS_SUPERSPEED_PLUS))\n\t\treturn -EINVAL;\n\tif (set && dwc->dis_u2_entry_quirk)\n\t\treturn -EINVAL;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\tif (set)\n\t\treg |= DWC3_DCTL_INITU2ENA;\n\telse\n\t\treg &= ~DWC3_DCTL_INITU2ENA;\n\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_handle_test(struct dwc3 *dwc, enum usb_device_state state,\n\t\tu32 wIndex, int set)\n{\n\tif ((wIndex & 0xff) != 0)\n\t\treturn -EINVAL;\n\tif (!set)\n\t\treturn -EINVAL;\n\n\tswitch (wIndex >> 8) {\n\tcase USB_TEST_J:\n\tcase USB_TEST_K:\n\tcase USB_TEST_SE0_NAK:\n\tcase USB_TEST_PACKET:\n\tcase USB_TEST_FORCE_ENABLE:\n\t\tdwc->test_mode_nr = wIndex >> 8;\n\t\tdwc->test_mode = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_handle_device(struct dwc3 *dwc,\n\t\tstruct usb_ctrlrequest *ctrl, int set)\n{\n\tenum usb_device_state\tstate;\n\tu32\t\t\twValue;\n\tu32\t\t\twIndex;\n\tint\t\t\tret = 0;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\twIndex = le16_to_cpu(ctrl->wIndex);\n\tstate = dwc->gadget->state;\n\n\tswitch (wValue) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tif (dwc->wakeup_configured)\n\t\t\tdwc->gadget->wakeup_armed = set;\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tbreak;\n\t \n\tcase USB_DEVICE_U1_ENABLE:\n\t\tret = dwc3_ep0_handle_u1(dwc, state, set);\n\t\tbreak;\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tret = dwc3_ep0_handle_u2(dwc, state, set);\n\t\tbreak;\n\tcase USB_DEVICE_LTM_ENABLE:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase USB_DEVICE_TEST_MODE:\n\t\tret = dwc3_ep0_handle_test(dwc, state, wIndex, set);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_ep0_handle_intf(struct dwc3 *dwc,\n\t\tstruct usb_ctrlrequest *ctrl, int set)\n{\n\tu32\t\t\twValue;\n\tint\t\t\tret = 0;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\n\tswitch (wValue) {\n\tcase USB_INTRF_FUNC_SUSPEND:\n\t\tret = dwc3_ep0_delegate_req(dwc, ctrl);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_ep0_handle_endpoint(struct dwc3 *dwc,\n\t\tstruct usb_ctrlrequest *ctrl, int set)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tu32\t\t\twValue;\n\tint\t\t\tret;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\n\tswitch (wValue) {\n\tcase USB_ENDPOINT_HALT:\n\t\tdep = dwc3_wIndex_to_dep(dwc, ctrl->wIndex);\n\t\tif (!dep)\n\t\t\treturn -EINVAL;\n\n\t\tif (set == 0 && (dep->flags & DWC3_EP_WEDGE))\n\t\t\tbreak;\n\n\t\tret = __dwc3_gadget_ep_set_halt(dep, set, true);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (!set && (dep->flags & DWC3_EP_END_TRANSFER_PENDING))\n\t\t\treturn USB_GADGET_DELAYED_STATUS;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_handle_feature(struct dwc3 *dwc,\n\t\tstruct usb_ctrlrequest *ctrl, int set)\n{\n\tu32\t\t\trecip;\n\tint\t\t\tret;\n\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tret = dwc3_ep0_handle_device(dwc, ctrl, set);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tret = dwc3_ep0_handle_intf(dwc, ctrl, set);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tret = dwc3_ep0_handle_endpoint(dwc, ctrl, set);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_ep0_set_address(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = dwc->gadget->state;\n\tu32 addr;\n\tu32 reg;\n\n\taddr = le16_to_cpu(ctrl->wValue);\n\tif (addr > 127) {\n\t\tdev_err(dwc->dev, \"invalid device address %d\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB_STATE_CONFIGURED) {\n\t\tdev_err(dwc->dev, \"can't SetAddress() from Configured State\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg &= ~(DWC3_DCFG_DEVADDR_MASK);\n\treg |= DWC3_DCFG_DEVADDR(addr);\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n\n\tif (addr)\n\t\tusb_gadget_set_state(dwc->gadget, USB_STATE_ADDRESS);\n\telse\n\t\tusb_gadget_set_state(dwc->gadget, USB_STATE_DEFAULT);\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_delegate_req(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tint ret = -EINVAL;\n\n\tif (dwc->async_callbacks) {\n\t\tspin_unlock(&dwc->lock);\n\t\tret = dwc->gadget_driver->setup(dwc->gadget, ctrl);\n\t\tspin_lock(&dwc->lock);\n\t}\n\treturn ret;\n}\n\nstatic int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = dwc->gadget->state;\n\tu32 cfg;\n\tint ret;\n\tu32 reg;\n\n\tcfg = le16_to_cpu(ctrl->wValue);\n\n\tswitch (state) {\n\tcase USB_STATE_DEFAULT:\n\t\treturn -EINVAL;\n\n\tcase USB_STATE_ADDRESS:\n\t\tdwc3_gadget_clear_tx_fifos(dwc);\n\n\t\tret = dwc3_ep0_delegate_req(dwc, ctrl);\n\t\t \n\t\tif (cfg && (!ret || (ret == USB_GADGET_DELAYED_STATUS))) {\n\n\t\t\t \n\t\t\tif (ret == 0)\n\t\t\t\tusb_gadget_set_state(dwc->gadget,\n\t\t\t\t\t\tUSB_STATE_CONFIGURED);\n\n\t\t\t \n\t\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\t\tif (!dwc->dis_u1_entry_quirk)\n\t\t\t\treg |= DWC3_DCTL_ACCEPTU1ENA;\n\t\t\tif (!dwc->dis_u2_entry_quirk)\n\t\t\t\treg |= DWC3_DCTL_ACCEPTU2ENA;\n\t\t\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\t\t}\n\t\tbreak;\n\n\tcase USB_STATE_CONFIGURED:\n\t\tret = dwc3_ep0_delegate_req(dwc, ctrl);\n\t\tif (!cfg && !ret)\n\t\t\tusb_gadget_set_state(dwc->gadget,\n\t\t\t\t\tUSB_STATE_ADDRESS);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic void dwc3_ep0_set_sel_cmpl(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dwc3_ep\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t*dwc = dep->dwc;\n\n\tu32\t\tparam = 0;\n\tu32\t\treg;\n\n\tstruct timing {\n\t\tu8\tu1sel;\n\t\tu8\tu1pel;\n\t\t__le16\tu2sel;\n\t\t__le16\tu2pel;\n\t} __packed timing;\n\n\tint\t\tret;\n\n\tmemcpy(&timing, req->buf, sizeof(timing));\n\n\tdwc->u1sel = timing.u1sel;\n\tdwc->u1pel = timing.u1pel;\n\tdwc->u2sel = le16_to_cpu(timing.u2sel);\n\tdwc->u2pel = le16_to_cpu(timing.u2pel);\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\tif (reg & DWC3_DCTL_INITU2ENA)\n\t\tparam = dwc->u2pel;\n\tif (reg & DWC3_DCTL_INITU1ENA)\n\t\tparam = dwc->u1pel;\n\n\t \n\tif (param > 125)\n\t\tparam = 0;\n\n\t \n\tret = dwc3_send_gadget_generic_command(dwc,\n\t\t\tDWC3_DGCMD_SET_PERIODIC_PAR, param);\n\tWARN_ON(ret < 0);\n}\n\nstatic int dwc3_ep0_set_sel(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tstruct dwc3_ep\t*dep;\n\tenum usb_device_state state = dwc->gadget->state;\n\tu16\t\twLength;\n\n\tif (state == USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\twLength = le16_to_cpu(ctrl->wLength);\n\n\tif (wLength != 6) {\n\t\tdev_err(dwc->dev, \"Set SEL should be 6 bytes, got %d\\n\",\n\t\t\t\twLength);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdep = dwc->eps[0];\n\tdwc->ep0_usb_req.dep = dep;\n\tdwc->ep0_usb_req.request.length = dep->endpoint.maxpacket;\n\tdwc->ep0_usb_req.request.buf = dwc->setup_buf;\n\tdwc->ep0_usb_req.request.complete = dwc3_ep0_set_sel_cmpl;\n\n\treturn __dwc3_gadget_ep0_queue(dep, &dwc->ep0_usb_req);\n}\n\nstatic int dwc3_ep0_set_isoch_delay(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tu16\t\twLength;\n\tu16\t\twValue;\n\tu16\t\twIndex;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\twLength = le16_to_cpu(ctrl->wLength);\n\twIndex = le16_to_cpu(ctrl->wIndex);\n\n\tif (wIndex || wLength)\n\t\treturn -EINVAL;\n\n\tdwc->gadget->isoch_delay = wValue;\n\n\treturn 0;\n}\n\nstatic int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)\n{\n\tint ret;\n\n\tswitch (ctrl->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\tret = dwc3_ep0_handle_status(dwc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tret = dwc3_ep0_handle_feature(dwc, ctrl, 0);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tret = dwc3_ep0_handle_feature(dwc, ctrl, 1);\n\t\tbreak;\n\tcase USB_REQ_SET_ADDRESS:\n\t\tret = dwc3_ep0_set_address(dwc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tret = dwc3_ep0_set_config(dwc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_SEL:\n\t\tret = dwc3_ep0_set_sel(dwc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\tret = dwc3_ep0_set_isoch_delay(dwc, ctrl);\n\t\tbreak;\n\tdefault:\n\t\tret = dwc3_ep0_delegate_req(dwc, ctrl);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void dwc3_ep0_inspect_setup(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct usb_ctrlrequest *ctrl = (void *) dwc->ep0_trb;\n\tint ret = -EINVAL;\n\tu32 len;\n\n\tif (!dwc->gadget_driver || !dwc->softconnect || !dwc->connected)\n\t\tgoto out;\n\n\ttrace_dwc3_ctrl_req(ctrl);\n\n\tlen = le16_to_cpu(ctrl->wLength);\n\tif (!len) {\n\t\tdwc->three_stage_setup = false;\n\t\tdwc->ep0_expect_in = false;\n\t\tdwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;\n\t} else {\n\t\tdwc->three_stage_setup = true;\n\t\tdwc->ep0_expect_in = !!(ctrl->bRequestType & USB_DIR_IN);\n\t\tdwc->ep0_next_event = DWC3_EP0_NRDY_DATA;\n\t}\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tret = dwc3_ep0_std_request(dwc, ctrl);\n\telse\n\t\tret = dwc3_ep0_delegate_req(dwc, ctrl);\n\n\tif (ret == USB_GADGET_DELAYED_STATUS)\n\t\tdwc->delayed_status = true;\n\nout:\n\tif (ret < 0)\n\t\tdwc3_ep0_stall_and_restart(dwc);\n}\n\nstatic void dwc3_ep0_complete_data(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_request\t*r;\n\tstruct usb_request\t*ur;\n\tstruct dwc3_trb\t\t*trb;\n\tstruct dwc3_ep\t\t*ep0;\n\tu32\t\t\ttransferred = 0;\n\tu32\t\t\tstatus;\n\tu32\t\t\tlength;\n\tu8\t\t\tepnum;\n\n\tepnum = event->endpoint_number;\n\tep0 = dwc->eps[0];\n\n\tdwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;\n\ttrb = dwc->ep0_trb;\n\ttrace_dwc3_complete_trb(ep0, trb);\n\n\tr = next_request(&ep0->pending_list);\n\tif (!r)\n\t\treturn;\n\n\tstatus = DWC3_TRB_SIZE_TRBSTS(trb->size);\n\tif (status == DWC3_TRBSTS_SETUP_PENDING) {\n\t\tdwc->setup_packet_pending = true;\n\t\tif (r)\n\t\t\tdwc3_gadget_giveback(ep0, r, -ECONNRESET);\n\n\t\treturn;\n\t}\n\n\tur = &r->request;\n\n\tlength = trb->size & DWC3_TRB_SIZE_MASK;\n\ttransferred = ur->length - length;\n\tur->actual += transferred;\n\n\tif ((IS_ALIGNED(ur->length, ep0->endpoint.maxpacket) &&\n\t     ur->length && ur->zero) || dwc->ep0_bounced) {\n\t\ttrb++;\n\t\ttrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\n\t\ttrace_dwc3_complete_trb(ep0, trb);\n\n\t\tif (r->direction)\n\t\t\tdwc->eps[1]->trb_enqueue = 0;\n\t\telse\n\t\t\tdwc->eps[0]->trb_enqueue = 0;\n\n\t\tdwc->ep0_bounced = false;\n\t}\n\n\tif ((epnum & 1) && ur->actual < ur->length)\n\t\tdwc3_ep0_stall_and_restart(dwc);\n\telse\n\t\tdwc3_gadget_giveback(ep0, r, 0);\n}\n\nstatic void dwc3_ep0_complete_status(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_request\t*r;\n\tstruct dwc3_ep\t\t*dep;\n\tstruct dwc3_trb\t\t*trb;\n\tu32\t\t\tstatus;\n\n\tdep = dwc->eps[0];\n\ttrb = dwc->ep0_trb;\n\n\ttrace_dwc3_complete_trb(dep, trb);\n\n\tif (!list_empty(&dep->pending_list)) {\n\t\tr = next_request(&dep->pending_list);\n\n\t\tdwc3_gadget_giveback(dep, r, 0);\n\t}\n\n\tif (dwc->test_mode) {\n\t\tint ret;\n\n\t\tret = dwc3_gadget_set_test_mode(dwc, dwc->test_mode_nr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dwc->dev, \"invalid test #%d\\n\",\n\t\t\t\t\tdwc->test_mode_nr);\n\t\t\tdwc3_ep0_stall_and_restart(dwc);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstatus = DWC3_TRB_SIZE_TRBSTS(trb->size);\n\tif (status == DWC3_TRBSTS_SETUP_PENDING)\n\t\tdwc->setup_packet_pending = true;\n\n\tdwc->ep0state = EP0_SETUP_PHASE;\n\tdwc3_ep0_out_start(dwc);\n}\n\nstatic void dwc3_ep0_xfer_complete(struct dwc3 *dwc,\n\t\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_ep\t\t*dep = dwc->eps[event->endpoint_number];\n\n\tdep->flags &= ~DWC3_EP_TRANSFER_STARTED;\n\tdep->resource_index = 0;\n\tdwc->setup_packet_pending = false;\n\n\tswitch (dwc->ep0state) {\n\tcase EP0_SETUP_PHASE:\n\t\tdwc3_ep0_inspect_setup(dwc, event);\n\t\tbreak;\n\n\tcase EP0_DATA_PHASE:\n\t\tdwc3_ep0_complete_data(dwc, event);\n\t\tbreak;\n\n\tcase EP0_STATUS_PHASE:\n\t\tdwc3_ep0_complete_status(dwc, event);\n\t\tbreak;\n\tdefault:\n\t\tWARN(true, \"UNKNOWN ep0state %d\\n\", dwc->ep0state);\n\t}\n}\n\nstatic void __dwc3_ep0_do_control_data(struct dwc3 *dwc,\n\t\tstruct dwc3_ep *dep, struct dwc3_request *req)\n{\n\tunsigned int\t\ttrb_length = 0;\n\tint\t\t\tret;\n\n\treq->direction = !!dep->number;\n\n\tif (req->request.length == 0) {\n\t\tif (!req->direction)\n\t\t\ttrb_length = dep->endpoint.maxpacket;\n\n\t\tdwc3_ep0_prepare_one_trb(dep, dwc->bounce_addr, trb_length,\n\t\t\t\tDWC3_TRBCTL_CONTROL_DATA, false);\n\t\tret = dwc3_ep0_start_trans(dep);\n\t} else if (!IS_ALIGNED(req->request.length, dep->endpoint.maxpacket)\n\t\t\t&& (dep->number == 0)) {\n\t\tu32\tmaxpacket;\n\t\tu32\trem;\n\n\t\tret = usb_gadget_map_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, dep->number);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tmaxpacket = dep->endpoint.maxpacket;\n\t\trem = req->request.length % maxpacket;\n\t\tdwc->ep0_bounced = true;\n\n\t\t \n\t\tdwc3_ep0_prepare_one_trb(dep, req->request.dma,\n\t\t\t\t\t req->request.length,\n\t\t\t\t\t DWC3_TRBCTL_CONTROL_DATA,\n\t\t\t\t\t true);\n\n\t\treq->trb = &dwc->ep0_trb[dep->trb_enqueue - 1];\n\n\t\t \n\t\tdwc3_ep0_prepare_one_trb(dep, dwc->bounce_addr,\n\t\t\t\t\t maxpacket - rem,\n\t\t\t\t\t DWC3_TRBCTL_CONTROL_DATA,\n\t\t\t\t\t false);\n\t\tret = dwc3_ep0_start_trans(dep);\n\t} else if (IS_ALIGNED(req->request.length, dep->endpoint.maxpacket) &&\n\t\t   req->request.length && req->request.zero) {\n\n\t\tret = usb_gadget_map_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, dep->number);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\t \n\t\tdwc3_ep0_prepare_one_trb(dep, req->request.dma,\n\t\t\t\t\t req->request.length,\n\t\t\t\t\t DWC3_TRBCTL_CONTROL_DATA,\n\t\t\t\t\t true);\n\n\t\treq->trb = &dwc->ep0_trb[dep->trb_enqueue - 1];\n\n\t\tif (!req->direction)\n\t\t\ttrb_length = dep->endpoint.maxpacket;\n\n\t\t \n\t\tdwc3_ep0_prepare_one_trb(dep, dwc->bounce_addr,\n\t\t\t\t\t trb_length, DWC3_TRBCTL_CONTROL_DATA,\n\t\t\t\t\t false);\n\t\tret = dwc3_ep0_start_trans(dep);\n\t} else {\n\t\tret = usb_gadget_map_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, dep->number);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tdwc3_ep0_prepare_one_trb(dep, req->request.dma,\n\t\t\t\treq->request.length, DWC3_TRBCTL_CONTROL_DATA,\n\t\t\t\tfalse);\n\n\t\treq->trb = &dwc->ep0_trb[dep->trb_enqueue];\n\n\t\tret = dwc3_ep0_start_trans(dep);\n\t}\n\n\tWARN_ON(ret < 0);\n}\n\nstatic int dwc3_ep0_start_control_status(struct dwc3_ep *dep)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tu32\t\t\ttype;\n\n\ttype = dwc->three_stage_setup ? DWC3_TRBCTL_CONTROL_STATUS3\n\t\t: DWC3_TRBCTL_CONTROL_STATUS2;\n\n\tdwc3_ep0_prepare_one_trb(dep, dwc->ep0_trb_addr, 0, type, false);\n\treturn dwc3_ep0_start_trans(dep);\n}\n\nstatic void __dwc3_ep0_do_control_status(struct dwc3 *dwc, struct dwc3_ep *dep)\n{\n\tWARN_ON(dwc3_ep0_start_control_status(dep));\n}\n\nstatic void dwc3_ep0_do_control_status(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_ep\t\t*dep = dwc->eps[event->endpoint_number];\n\n\t__dwc3_ep0_do_control_status(dwc, dep);\n}\n\nvoid dwc3_ep0_send_delayed_status(struct dwc3 *dwc)\n{\n\tunsigned int direction = !dwc->ep0_expect_in;\n\n\tdwc->delayed_status = false;\n\tdwc->clear_stall_protocol = 0;\n\n\tif (dwc->ep0state != EP0_STATUS_PHASE)\n\t\treturn;\n\n\t__dwc3_ep0_do_control_status(dwc, dwc->eps[direction]);\n}\n\nvoid dwc3_ep0_end_control_data(struct dwc3 *dwc, struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tu32\t\t\tcmd;\n\tint\t\t\tret;\n\n\t \n\tif (!dep->resource_index && dep->number)\n\t\treturn;\n\n\tcmd = DWC3_DEPCMD_ENDTRANSFER;\n\tcmd |= DWC3_DEPCMD_CMDIOC;\n\tcmd |= DWC3_DEPCMD_PARAM(dep->resource_index);\n\tmemset(&params, 0, sizeof(params));\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tWARN_ON_ONCE(ret);\n\tdep->resource_index = 0;\n}\n\nstatic void dwc3_ep0_xfernotready(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tswitch (event->status) {\n\tcase DEPEVT_STATUS_CONTROL_DATA:\n\t\tif (!dwc->softconnect || !dwc->connected)\n\t\t\treturn;\n\t\t \n\t\tif (dwc->ep0_expect_in != event->endpoint_number) {\n\t\t\tstruct dwc3_ep\t*dep = dwc->eps[dwc->ep0_expect_in];\n\n\t\t\tdev_err(dwc->dev, \"unexpected direction for Data Phase\\n\");\n\t\t\tdwc3_ep0_end_control_data(dwc, dep);\n\t\t\tdwc3_ep0_stall_and_restart(dwc);\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\n\tcase DEPEVT_STATUS_CONTROL_STATUS:\n\t\tif (dwc->ep0_next_event != DWC3_EP0_NRDY_STATUS)\n\t\t\treturn;\n\n\t\tif (dwc->setup_packet_pending) {\n\t\t\tdwc3_ep0_stall_and_restart(dwc);\n\t\t\treturn;\n\t\t}\n\n\t\tdwc->ep0state = EP0_STATUS_PHASE;\n\n\t\tif (dwc->delayed_status) {\n\t\t\tstruct dwc3_ep *dep = dwc->eps[0];\n\n\t\t\tWARN_ON_ONCE(event->endpoint_number != 1);\n\t\t\t \n\t\t\tif (!list_empty(&dep->pending_list)) {\n\t\t\t\tdwc->delayed_status = false;\n\t\t\t\tusb_gadget_set_state(dwc->gadget,\n\t\t\t\t\t\t     USB_STATE_CONFIGURED);\n\t\t\t\tdwc3_ep0_do_control_status(dwc, event);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tdwc3_ep0_do_control_status(dwc, event);\n\t}\n}\n\nvoid dwc3_ep0_interrupt(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_ep\t*dep = dwc->eps[event->endpoint_number];\n\tu8\t\tcmd;\n\n\tswitch (event->endpoint_event) {\n\tcase DWC3_DEPEVT_XFERCOMPLETE:\n\t\tdwc3_ep0_xfer_complete(dwc, event);\n\t\tbreak;\n\n\tcase DWC3_DEPEVT_XFERNOTREADY:\n\t\tdwc3_ep0_xfernotready(dwc, event);\n\t\tbreak;\n\n\tcase DWC3_DEPEVT_XFERINPROGRESS:\n\tcase DWC3_DEPEVT_RXTXFIFOEVT:\n\tcase DWC3_DEPEVT_STREAMEVT:\n\t\tbreak;\n\tcase DWC3_DEPEVT_EPCMDCMPLT:\n\t\tcmd = DEPEVT_PARAMETER_CMD(event->parameters);\n\n\t\tif (cmd == DWC3_DEPCMD_ENDTRANSFER) {\n\t\t\tdep->flags &= ~DWC3_EP_END_TRANSFER_PENDING;\n\t\t\tdep->flags &= ~DWC3_EP_TRANSFER_STARTED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwc->dev, \"unknown endpoint event %d\\n\", event->endpoint_event);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}