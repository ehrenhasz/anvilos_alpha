{
  "module_name": "host.c",
  "hash_id": "08d3be99ab8d79dfbb2675471f70c7d362aeb797774956a6e8bb1bb040e33f33",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/host.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include \"core.h\"\n\nstatic void dwc3_host_fill_xhci_irq_res(struct dwc3 *dwc,\n\t\t\t\t\tint irq, char *name)\n{\n\tstruct platform_device *pdev = to_platform_device(dwc->dev);\n\tstruct device_node *np = dev_of_node(&pdev->dev);\n\n\tdwc->xhci_resources[1].start = irq;\n\tdwc->xhci_resources[1].end = irq;\n\tdwc->xhci_resources[1].flags = IORESOURCE_IRQ | irq_get_trigger_type(irq);\n\tif (!name && np)\n\t\tdwc->xhci_resources[1].name = of_node_full_name(pdev->dev.of_node);\n\telse\n\t\tdwc->xhci_resources[1].name = name;\n}\n\nstatic int dwc3_host_get_irq(struct dwc3 *dwc)\n{\n\tstruct platform_device\t*dwc3_pdev = to_platform_device(dwc->dev);\n\tint irq;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"host\");\n\tif (irq > 0) {\n\t\tdwc3_host_fill_xhci_irq_res(dwc, irq, \"host\");\n\t\tgoto out;\n\t}\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"dwc_usb3\");\n\tif (irq > 0) {\n\t\tdwc3_host_fill_xhci_irq_res(dwc, irq, \"dwc_usb3\");\n\t\tgoto out;\n\t}\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq(dwc3_pdev, 0);\n\tif (irq > 0)\n\t\tdwc3_host_fill_xhci_irq_res(dwc, irq, NULL);\n\nout:\n\treturn irq;\n}\n\nint dwc3_host_init(struct dwc3 *dwc)\n{\n\tstruct property_entry\tprops[4];\n\tstruct platform_device\t*xhci;\n\tint\t\t\tret, irq;\n\tint\t\t\tprop_idx = 0;\n\n\tirq = dwc3_host_get_irq(dwc);\n\tif (irq < 0)\n\t\treturn irq;\n\n\txhci = platform_device_alloc(\"xhci-hcd\", PLATFORM_DEVID_AUTO);\n\tif (!xhci) {\n\t\tdev_err(dwc->dev, \"couldn't allocate xHCI device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\txhci->dev.parent\t= dwc->dev;\n\n\tdwc->xhci = xhci;\n\n\tret = platform_device_add_resources(xhci, dwc->xhci_resources,\n\t\t\t\t\t\tDWC3_XHCI_RESOURCES_NUM);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"couldn't add resources to xHCI device\\n\");\n\t\tgoto err;\n\t}\n\n\tmemset(props, 0, sizeof(struct property_entry) * ARRAY_SIZE(props));\n\n\tif (dwc->usb3_lpm_capable)\n\t\tprops[prop_idx++] = PROPERTY_ENTRY_BOOL(\"usb3-lpm-capable\");\n\n\tif (dwc->usb2_lpm_disable)\n\t\tprops[prop_idx++] = PROPERTY_ENTRY_BOOL(\"usb2-lpm-disable\");\n\n\t \n\tif (DWC3_VER_IS_WITHIN(DWC3, ANY, 300A))\n\t\tprops[prop_idx++] = PROPERTY_ENTRY_BOOL(\"quirk-broken-port-ped\");\n\n\tif (prop_idx) {\n\t\tret = device_create_managed_software_node(&xhci->dev, props, NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dwc->dev, \"failed to add properties to xHCI\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = platform_device_add(xhci);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to register xHCI device\\n\");\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tplatform_device_put(xhci);\n\treturn ret;\n}\n\nvoid dwc3_host_exit(struct dwc3 *dwc)\n{\n\tplatform_device_unregister(dwc->xhci);\n\tdwc->xhci = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}