{
  "module_name": "gadget.c",
  "hash_id": "2b8256bc360396e3bdd9d9665402544b92995bbd2ec25a1ddba047e0abac0f6e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/gadget.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/dma-mapping.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n#include \"gadget.h\"\n#include \"io.h\"\n\n#define DWC3_ALIGN_FRAME(d, n)\t(((d)->frame_number + ((d)->interval * (n))) \\\n\t\t\t\t\t& ~((d)->interval - 1))\n\n \nint dwc3_gadget_set_test_mode(struct dwc3 *dwc, int mode)\n{\n\tu32\t\treg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\treg &= ~DWC3_DCTL_TSTCTRL_MASK;\n\n\tswitch (mode) {\n\tcase USB_TEST_J:\n\tcase USB_TEST_K:\n\tcase USB_TEST_SE0_NAK:\n\tcase USB_TEST_PACKET:\n\tcase USB_TEST_FORCE_ENABLE:\n\t\treg |= mode << 1;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\n\treturn 0;\n}\n\n \nint dwc3_gadget_get_link_state(struct dwc3 *dwc)\n{\n\tu32\t\treg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\n\treturn DWC3_DSTS_USBLNKST(reg);\n}\n\n \nint dwc3_gadget_set_link_state(struct dwc3 *dwc, enum dwc3_link_state state)\n{\n\tint\t\tretries = 10000;\n\tu32\t\treg;\n\n\t \n\tif (!DWC3_VER_IS_PRIOR(DWC3, 194A)) {\n\t\twhile (--retries) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\t\t\tif (reg & DWC3_DSTS_DCNRD)\n\t\t\t\tudelay(5);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (retries <= 0)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\treg &= ~DWC3_DCTL_ULSTCHNGREQ_MASK;\n\n\t \n\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\n\t \n\treg |= DWC3_DCTL_ULSTCHNGREQ(state);\n\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\n\t \n\tif (!DWC3_VER_IS_PRIOR(DWC3, 194A))\n\t\treturn 0;\n\n\t \n\tretries = 10000;\n\twhile (--retries) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\n\t\tif (DWC3_DSTS_USBLNKST(reg) == state)\n\t\t\treturn 0;\n\n\t\tudelay(5);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void dwc3_ep0_reset_state(struct dwc3 *dwc)\n{\n\tunsigned int\tdir;\n\n\tif (dwc->ep0state != EP0_SETUP_PHASE) {\n\t\tdir = !!dwc->ep0_expect_in;\n\t\tif (dwc->ep0state == EP0_DATA_PHASE)\n\t\t\tdwc3_ep0_end_control_data(dwc, dwc->eps[dir]);\n\t\telse\n\t\t\tdwc3_ep0_end_control_data(dwc, dwc->eps[!dir]);\n\n\t\tdwc->eps[0]->trb_enqueue = 0;\n\t\tdwc->eps[1]->trb_enqueue = 0;\n\n\t\tdwc3_ep0_stall_and_restart(dwc);\n\t}\n}\n\n \nstatic void dwc3_ep_inc_trb(u8 *index)\n{\n\t(*index)++;\n\tif (*index == (DWC3_TRB_NUM - 1))\n\t\t*index = 0;\n}\n\n \nstatic void dwc3_ep_inc_enq(struct dwc3_ep *dep)\n{\n\tdwc3_ep_inc_trb(&dep->trb_enqueue);\n}\n\n \nstatic void dwc3_ep_inc_deq(struct dwc3_ep *dep)\n{\n\tdwc3_ep_inc_trb(&dep->trb_dequeue);\n}\n\nstatic void dwc3_gadget_del_and_unmap_request(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, int status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tlist_del(&req->list);\n\treq->remaining = 0;\n\treq->needs_extra_trb = false;\n\treq->num_trbs = 0;\n\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\n\tif (req->trb)\n\t\tusb_gadget_unmap_request_by_dev(dwc->sysdev,\n\t\t\t\t&req->request, req->direction);\n\n\treq->trb = NULL;\n\ttrace_dwc3_gadget_giveback(req);\n\n\tif (dep->number > 1)\n\t\tpm_runtime_put(dwc->dev);\n}\n\n \nvoid dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,\n\t\tint status)\n{\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tdwc3_gadget_del_and_unmap_request(dep, req, status);\n\treq->status = DWC3_REQUEST_STATUS_COMPLETED;\n\n\tspin_unlock(&dwc->lock);\n\tusb_gadget_giveback_request(&dep->endpoint, &req->request);\n\tspin_lock(&dwc->lock);\n}\n\n \nint dwc3_send_gadget_generic_command(struct dwc3 *dwc, unsigned int cmd,\n\t\tu32 param)\n{\n\tu32\t\ttimeout = 500;\n\tint\t\tstatus = 0;\n\tint\t\tret = 0;\n\tu32\t\treg;\n\n\tdwc3_writel(dwc->regs, DWC3_DGCMDPAR, param);\n\tdwc3_writel(dwc->regs, DWC3_DGCMD, cmd | DWC3_DGCMD_CMDACT);\n\n\tdo {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DGCMD);\n\t\tif (!(reg & DWC3_DGCMD_CMDACT)) {\n\t\t\tstatus = DWC3_DGCMD_STATUS(reg);\n\t\t\tif (status)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t} while (--timeout);\n\n\tif (!timeout) {\n\t\tret = -ETIMEDOUT;\n\t\tstatus = -ETIMEDOUT;\n\t}\n\n\ttrace_dwc3_gadget_generic_cmd(cmd, param, status);\n\n\treturn ret;\n}\n\nstatic int __dwc3_gadget_wakeup(struct dwc3 *dwc, bool async);\n\n \nint dwc3_send_gadget_ep_cmd(struct dwc3_ep *dep, unsigned int cmd,\n\t\tstruct dwc3_gadget_ep_cmd_params *params)\n{\n\tconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tu32\t\t\ttimeout = 5000;\n\tu32\t\t\tsaved_config = 0;\n\tu32\t\t\treg;\n\n\tint\t\t\tcmd_status = 0;\n\tint\t\t\tret = -EINVAL;\n\n\t \n\tif (dwc->gadget->speed <= USB_SPEED_HIGH ||\n\t    DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_ENDTRANSFER) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\tif (unlikely(reg & DWC3_GUSB2PHYCFG_SUSPHY)) {\n\t\t\tsaved_config |= DWC3_GUSB2PHYCFG_SUSPHY;\n\t\t\treg &= ~DWC3_GUSB2PHYCFG_SUSPHY;\n\t\t}\n\n\t\tif (reg & DWC3_GUSB2PHYCFG_ENBLSLPM) {\n\t\t\tsaved_config |= DWC3_GUSB2PHYCFG_ENBLSLPM;\n\t\t\treg &= ~DWC3_GUSB2PHYCFG_ENBLSLPM;\n\t\t}\n\n\t\tif (saved_config)\n\t\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t}\n\n\tif (DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_STARTTRANSFER) {\n\t\tint link_state;\n\n\t\t \n\t\tlink_state = dwc3_gadget_get_link_state(dwc);\n\t\tswitch (link_state) {\n\t\tcase DWC3_LINK_STATE_U2:\n\t\t\tif (dwc->gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\n\t\t\tfallthrough;\n\t\tcase DWC3_LINK_STATE_U3:\n\t\t\tret = __dwc3_gadget_wakeup(dwc, false);\n\t\t\tdev_WARN_ONCE(dwc->dev, ret, \"wakeup failed --> %d\\n\",\n\t\t\t\t\tret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (DWC3_DEPCMD_CMD(cmd) != DWC3_DEPCMD_UPDATETRANSFER) {\n\t\tdwc3_writel(dep->regs, DWC3_DEPCMDPAR0, params->param0);\n\t\tdwc3_writel(dep->regs, DWC3_DEPCMDPAR1, params->param1);\n\t\tdwc3_writel(dep->regs, DWC3_DEPCMDPAR2, params->param2);\n\t}\n\n\t \n\tif (DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_UPDATETRANSFER &&\n\t\t\t!usb_endpoint_xfer_isoc(desc))\n\t\tcmd &= ~(DWC3_DEPCMD_CMDIOC | DWC3_DEPCMD_CMDACT);\n\telse\n\t\tcmd |= DWC3_DEPCMD_CMDACT;\n\n\tdwc3_writel(dep->regs, DWC3_DEPCMD, cmd);\n\n\tif (!(cmd & DWC3_DEPCMD_CMDACT) ||\n\t\t(DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_ENDTRANSFER &&\n\t\t!(cmd & DWC3_DEPCMD_CMDIOC))) {\n\t\tret = 0;\n\t\tgoto skip_status;\n\t}\n\n\tdo {\n\t\treg = dwc3_readl(dep->regs, DWC3_DEPCMD);\n\t\tif (!(reg & DWC3_DEPCMD_CMDACT)) {\n\t\t\tcmd_status = DWC3_DEPCMD_STATUS(reg);\n\n\t\t\tswitch (cmd_status) {\n\t\t\tcase 0:\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\tcase DEPEVT_TRANSFER_NO_RESOURCE:\n\t\t\t\tdev_WARN(dwc->dev, \"No resource for %s\\n\",\n\t\t\t\t\t dep->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tcase DEPEVT_TRANSFER_BUS_EXPIRY:\n\t\t\t\t \n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_WARN(dwc->dev, \"UNKNOWN cmd status\\n\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} while (--timeout);\n\n\tif (timeout == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tcmd_status = -ETIMEDOUT;\n\t}\n\nskip_status:\n\ttrace_dwc3_gadget_ep_cmd(dep, cmd, params, cmd_status);\n\n\tif (DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_STARTTRANSFER) {\n\t\tif (ret == 0)\n\t\t\tdep->flags |= DWC3_EP_TRANSFER_STARTED;\n\n\t\tif (ret != -ETIMEDOUT)\n\t\t\tdwc3_gadget_ep_get_transfer_index(dep);\n\t}\n\n\tif (saved_config) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));\n\t\treg |= saved_config;\n\t\tdwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), reg);\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_send_clear_stall_ep_cmd(struct dwc3_ep *dep)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tu32 cmd = DWC3_DEPCMD_CLEARSTALL;\n\n\t \n\tif (dep->direction &&\n\t    !DWC3_VER_IS_PRIOR(DWC3, 260A) &&\n\t    (dwc->gadget->speed >= USB_SPEED_SUPER))\n\t\tcmd |= DWC3_DEPCMD_CLEARPENDIN;\n\n\tmemset(&params, 0, sizeof(params));\n\n\treturn dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n}\n\nstatic dma_addr_t dwc3_trb_dma_offset(struct dwc3_ep *dep,\n\t\tstruct dwc3_trb *trb)\n{\n\tu32\t\toffset = (char *) trb - (char *) dep->trb_pool;\n\n\treturn dep->trb_pool_dma + offset;\n}\n\nstatic int dwc3_alloc_trb_pool(struct dwc3_ep *dep)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tif (dep->trb_pool)\n\t\treturn 0;\n\n\tdep->trb_pool = dma_alloc_coherent(dwc->sysdev,\n\t\t\tsizeof(struct dwc3_trb) * DWC3_TRB_NUM,\n\t\t\t&dep->trb_pool_dma, GFP_KERNEL);\n\tif (!dep->trb_pool) {\n\t\tdev_err(dep->dwc->dev, \"failed to allocate trb pool for %s\\n\",\n\t\t\t\tdep->name);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc3_free_trb_pool(struct dwc3_ep *dep)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tdma_free_coherent(dwc->sysdev, sizeof(struct dwc3_trb) * DWC3_TRB_NUM,\n\t\t\tdep->trb_pool, dep->trb_pool_dma);\n\n\tdep->trb_pool = NULL;\n\tdep->trb_pool_dma = 0;\n}\n\nstatic int dwc3_gadget_set_xfer_resource(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\n\tmemset(&params, 0x00, sizeof(params));\n\n\tparams.param0 = DWC3_DEPXFERCFG_NUM_XFER_RES(1);\n\n\treturn dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETTRANSFRESOURCE,\n\t\t\t&params);\n}\n\n \nstatic int dwc3_gadget_start_config(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3\t\t*dwc;\n\tu32\t\t\tcmd;\n\tint\t\t\ti;\n\tint\t\t\tret;\n\n\tif (dep->number)\n\t\treturn 0;\n\n\tmemset(&params, 0x00, sizeof(params));\n\tcmd = DWC3_DEPCMD_DEPSTARTCFG;\n\tdwc = dep->dwc;\n\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < DWC3_ENDPOINTS_NUM; i++) {\n\t\tstruct dwc3_ep *dep = dwc->eps[i];\n\n\t\tif (!dep)\n\t\t\tcontinue;\n\n\t\tret = dwc3_gadget_set_xfer_resource(dep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_set_ep_config(struct dwc3_ep *dep, unsigned int action)\n{\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n\tconst struct usb_endpoint_descriptor *desc;\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3 *dwc = dep->dwc;\n\n\tcomp_desc = dep->endpoint.comp_desc;\n\tdesc = dep->endpoint.desc;\n\n\tmemset(&params, 0x00, sizeof(params));\n\n\tparams.param0 = DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))\n\t\t| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc));\n\n\t \n\tif (dwc->gadget->speed >= USB_SPEED_SUPER) {\n\t\tu32 burst = dep->endpoint.maxburst;\n\n\t\tparams.param0 |= DWC3_DEPCFG_BURST_SIZE(burst - 1);\n\t}\n\n\tparams.param0 |= action;\n\tif (action == DWC3_DEPCFG_ACTION_RESTORE)\n\t\tparams.param2 |= dep->saved_state;\n\n\tif (usb_endpoint_xfer_control(desc))\n\t\tparams.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN;\n\n\tif (dep->number <= 1 || usb_endpoint_xfer_isoc(desc))\n\t\tparams.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;\n\n\tif (usb_ss_max_streams(comp_desc) && usb_endpoint_xfer_bulk(desc)) {\n\t\tparams.param1 |= DWC3_DEPCFG_STREAM_CAPABLE\n\t\t\t| DWC3_DEPCFG_XFER_COMPLETE_EN\n\t\t\t| DWC3_DEPCFG_STREAM_EVENT_EN;\n\t\tdep->stream_capable = true;\n\t}\n\n\tif (!usb_endpoint_xfer_control(desc))\n\t\tparams.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;\n\n\t \n\tparams.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);\n\n\t \n\tif (dep->direction)\n\t\tparams.param0 |= DWC3_DEPCFG_FIFO_NUMBER(dep->number >> 1);\n\n\tif (desc->bInterval) {\n\t\tu8 bInterval_m1;\n\n\t\t \n\t\tbInterval_m1 = min_t(u8, desc->bInterval - 1, 13);\n\n\t\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT &&\n\t\t    dwc->gadget->speed == USB_SPEED_FULL)\n\t\t\tdep->interval = desc->bInterval;\n\t\telse\n\t\t\tdep->interval = 1 << (desc->bInterval - 1);\n\n\t\tparams.param1 |= DWC3_DEPCFG_BINTERVAL_M1(bInterval_m1);\n\t}\n\n\treturn dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETEPCONFIG, &params);\n}\n\n \nstatic int dwc3_gadget_calc_tx_fifo_size(struct dwc3 *dwc, int mult)\n{\n\tint max_packet = 1024;\n\tint fifo_size;\n\tint mdwidth;\n\n\tmdwidth = dwc3_mdwidth(dwc);\n\n\t \n\tmdwidth >>= 3;\n\n\tif (DWC3_VER_IS_PRIOR(DWC3, 290A))\n\t\tfifo_size = mult * (max_packet / mdwidth) + 1;\n\telse\n\t\tfifo_size = mult * ((max_packet + mdwidth) / mdwidth) + 1;\n\treturn fifo_size;\n}\n\n \nvoid dwc3_gadget_clear_tx_fifos(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep *dep;\n\tint fifo_depth;\n\tint size;\n\tint num;\n\n\tif (!dwc->do_fifo_resize)\n\t\treturn;\n\n\t \n\tdep = dwc->eps[1];\n\tsize = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(0));\n\tif (DWC3_IP_IS(DWC3))\n\t\tfifo_depth = DWC3_GTXFIFOSIZ_TXFDEP(size);\n\telse\n\t\tfifo_depth = DWC31_GTXFIFOSIZ_TXFDEP(size);\n\n\tdwc->last_fifo_depth = fifo_depth;\n\t \n\tfor (num = 3; num < min_t(int, dwc->num_eps, DWC3_ENDPOINTS_NUM);\n\t     num += 2) {\n\t\tdep = dwc->eps[num];\n\t\t \n\t\tsize = DWC3_IP_IS(DWC3) ? 0 :\n\t\t\tdwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(num >> 1)) &\n\t\t\t\t   DWC31_GTXFIFOSIZ_TXFRAMNUM;\n\n\t\tdwc3_writel(dwc->regs, DWC3_GTXFIFOSIZ(num >> 1), size);\n\t\tdep->flags &= ~DWC3_EP_TXFIFO_RESIZED;\n\t}\n\tdwc->num_ep_resized = 0;\n}\n\n \nstatic int dwc3_gadget_resize_tx_fifos(struct dwc3_ep *dep)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\tint fifo_0_start;\n\tint ram1_depth;\n\tint fifo_size;\n\tint min_depth;\n\tint num_in_ep;\n\tint remaining;\n\tint num_fifos = 1;\n\tint fifo;\n\tint tmp;\n\n\tif (!dwc->do_fifo_resize)\n\t\treturn 0;\n\n\t \n\tif (!usb_endpoint_dir_in(dep->endpoint.desc) || dep->number <= 1)\n\t\treturn 0;\n\n\t \n\tif (dep->flags & DWC3_EP_TXFIFO_RESIZED)\n\t\treturn 0;\n\n\tram1_depth = DWC3_RAM1_DEPTH(dwc->hwparams.hwparams7);\n\n\tif ((dep->endpoint.maxburst > 1 &&\n\t     usb_endpoint_xfer_bulk(dep->endpoint.desc)) ||\n\t    usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\tnum_fifos = 3;\n\n\tif (dep->endpoint.maxburst > 6 &&\n\t    (usb_endpoint_xfer_bulk(dep->endpoint.desc) ||\n\t     usb_endpoint_xfer_isoc(dep->endpoint.desc)) && DWC3_IP_IS(DWC31))\n\t\tnum_fifos = dwc->tx_fifo_resize_max_num;\n\n\t \n\tfifo = dwc3_gadget_calc_tx_fifo_size(dwc, 1);\n\n\t \n\tnum_in_ep = dwc->max_cfg_eps;\n\tnum_in_ep -= dwc->num_ep_resized;\n\n\t \n\tmin_depth = num_in_ep * (fifo + 1);\n\tremaining = ram1_depth - min_depth - dwc->last_fifo_depth;\n\tremaining = max_t(int, 0, remaining);\n\t \n\tfifo_size = (num_fifos - 1) * fifo;\n\tif (remaining < fifo_size)\n\t\tfifo_size = remaining;\n\n\tfifo_size += fifo;\n\t \n\tfifo_size++;\n\n\t \n\ttmp = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(0));\n\tfifo_0_start = DWC3_GTXFIFOSIZ_TXFSTADDR(tmp);\n\n\tfifo_size |= (fifo_0_start + (dwc->last_fifo_depth << 16));\n\tif (DWC3_IP_IS(DWC3))\n\t\tdwc->last_fifo_depth += DWC3_GTXFIFOSIZ_TXFDEP(fifo_size);\n\telse\n\t\tdwc->last_fifo_depth += DWC31_GTXFIFOSIZ_TXFDEP(fifo_size);\n\n\t \n\tif (dwc->last_fifo_depth >= ram1_depth) {\n\t\tdev_err(dwc->dev, \"Fifosize(%d) > RAM size(%d) %s depth:%d\\n\",\n\t\t\tdwc->last_fifo_depth, ram1_depth,\n\t\t\tdep->endpoint.name, fifo_size);\n\t\tif (DWC3_IP_IS(DWC3))\n\t\t\tfifo_size = DWC3_GTXFIFOSIZ_TXFDEP(fifo_size);\n\t\telse\n\t\t\tfifo_size = DWC31_GTXFIFOSIZ_TXFDEP(fifo_size);\n\n\t\tdwc->last_fifo_depth -= fifo_size;\n\t\treturn -ENOMEM;\n\t}\n\n\tdwc3_writel(dwc->regs, DWC3_GTXFIFOSIZ(dep->number >> 1), fifo_size);\n\tdep->flags |= DWC3_EP_TXFIFO_RESIZED;\n\tdwc->num_ep_resized++;\n\n\treturn 0;\n}\n\n \nstatic int __dwc3_gadget_ep_enable(struct dwc3_ep *dep, unsigned int action)\n{\n\tconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tu32\t\t\treg;\n\tint\t\t\tret;\n\n\tif (!(dep->flags & DWC3_EP_ENABLED)) {\n\t\tret = dwc3_gadget_resize_tx_fifos(dep);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = dwc3_gadget_start_config(dep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = dwc3_gadget_set_ep_config(dep, action);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(dep->flags & DWC3_EP_ENABLED)) {\n\t\tstruct dwc3_trb\t*trb_st_hw;\n\t\tstruct dwc3_trb\t*trb_link;\n\n\t\tdep->type = usb_endpoint_type(desc);\n\t\tdep->flags |= DWC3_EP_ENABLED;\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_DALEPENA);\n\t\treg |= DWC3_DALEPENA_EP(dep->number);\n\t\tdwc3_writel(dwc->regs, DWC3_DALEPENA, reg);\n\n\t\tdep->trb_dequeue = 0;\n\t\tdep->trb_enqueue = 0;\n\n\t\tif (usb_endpoint_xfer_control(desc))\n\t\t\tgoto out;\n\n\t\t \n\t\tmemset(dep->trb_pool, 0,\n\t\t       sizeof(struct dwc3_trb) * DWC3_TRB_NUM);\n\n\t\t \n\t\ttrb_st_hw = &dep->trb_pool[0];\n\n\t\ttrb_link = &dep->trb_pool[DWC3_TRB_NUM - 1];\n\t\ttrb_link->bpl = lower_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\n\t\ttrb_link->bph = upper_32_bits(dwc3_trb_dma_offset(dep, trb_st_hw));\n\t\ttrb_link->ctrl |= DWC3_TRBCTL_LINK_TRB;\n\t\ttrb_link->ctrl |= DWC3_TRB_CTRL_HWO;\n\t}\n\n\t \n\tif (usb_endpoint_xfer_bulk(desc) ||\n\t\t\tusb_endpoint_xfer_int(desc)) {\n\t\tstruct dwc3_gadget_ep_cmd_params params;\n\t\tstruct dwc3_trb\t*trb;\n\t\tdma_addr_t trb_dma;\n\t\tu32 cmd;\n\n\t\tmemset(&params, 0, sizeof(params));\n\t\ttrb = &dep->trb_pool[0];\n\t\ttrb_dma = dwc3_trb_dma_offset(dep, trb);\n\n\t\tparams.param0 = upper_32_bits(trb_dma);\n\t\tparams.param1 = lower_32_bits(trb_dma);\n\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\n\t\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (dep->stream_capable) {\n\t\t\t \n\t\t\tdwc3_stop_active_transfer(dep, true, true);\n\n\t\t\t \n\t\t\tif (!dep->direction ||\n\t\t\t    !(dwc->hwparams.hwparams9 &\n\t\t\t      DWC3_GHWPARAMS9_DEV_TXF_FLUSH_BYPASS))\n\t\t\t\tdep->flags |= DWC3_EP_FORCE_RESTART_STREAM;\n\t\t}\n\t}\n\nout:\n\ttrace_dwc3_gadget_ep_enable(dep);\n\n\treturn 0;\n}\n\nvoid dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep, int status)\n{\n\tstruct dwc3_request\t\t*req;\n\n\tdwc3_stop_active_transfer(dep, true, false);\n\n\t \n\tif (dep->flags & DWC3_EP_DELAY_STOP)\n\t\treturn;\n\n\t \n\twhile (!list_empty(&dep->started_list)) {\n\t\treq = next_request(&dep->started_list);\n\n\t\tdwc3_gadget_giveback(dep, req, status);\n\t}\n\n\twhile (!list_empty(&dep->pending_list)) {\n\t\treq = next_request(&dep->pending_list);\n\n\t\tdwc3_gadget_giveback(dep, req, status);\n\t}\n\n\twhile (!list_empty(&dep->cancelled_list)) {\n\t\treq = next_request(&dep->cancelled_list);\n\n\t\tdwc3_gadget_giveback(dep, req, status);\n\t}\n}\n\n \nstatic int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tu32\t\t\treg;\n\tu32\t\t\tmask;\n\n\ttrace_dwc3_gadget_ep_disable(dep);\n\n\t \n\tif (dep->flags & DWC3_EP_STALL)\n\t\t__dwc3_gadget_ep_set_halt(dep, 0, false);\n\n\treg = dwc3_readl(dwc->regs, DWC3_DALEPENA);\n\treg &= ~DWC3_DALEPENA_EP(dep->number);\n\tdwc3_writel(dwc->regs, DWC3_DALEPENA, reg);\n\n\tdwc3_remove_requests(dwc, dep, -ESHUTDOWN);\n\n\tdep->stream_capable = false;\n\tdep->type = 0;\n\tmask = DWC3_EP_TXFIFO_RESIZED;\n\t \n\tif (dep->flags & DWC3_EP_DELAY_STOP)\n\t\tmask |= (DWC3_EP_DELAY_STOP | DWC3_EP_TRANSFER_STARTED);\n\tdep->flags &= mask;\n\n\t \n\tif (dep->number > 1) {\n\t\tdep->endpoint.comp_desc = NULL;\n\t\tdep->endpoint.desc = NULL;\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic int dwc3_gadget_ep0_enable(struct usb_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\nstatic int dwc3_gadget_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\n \n\nstatic int dwc3_gadget_ep_enable(struct usb_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct dwc3_ep\t\t\t*dep;\n\tstruct dwc3\t\t\t*dwc;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tret;\n\n\tif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"dwc3: invalid parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->wMaxPacketSize) {\n\t\tpr_debug(\"dwc3: missing wMaxPacketSize\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdep = to_dwc3_ep(ep);\n\tdwc = dep->dwc;\n\n\tif (dev_WARN_ONCE(dwc->dev, dep->flags & DWC3_EP_ENABLED,\n\t\t\t\t\t\"%s is already enabled\\n\",\n\t\t\t\t\tdep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = __dwc3_gadget_ep_enable(dep, DWC3_DEPCFG_ACTION_INIT);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_ep_disable(struct usb_ep *ep)\n{\n\tstruct dwc3_ep\t\t\t*dep;\n\tstruct dwc3\t\t\t*dwc;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tret;\n\n\tif (!ep) {\n\t\tpr_debug(\"dwc3: invalid parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdep = to_dwc3_ep(ep);\n\tdwc = dep->dwc;\n\n\tif (dev_WARN_ONCE(dwc->dev, !(dep->flags & DWC3_EP_ENABLED),\n\t\t\t\t\t\"%s is already disabled\\n\",\n\t\t\t\t\tdep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = __dwc3_gadget_ep_disable(dep);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct usb_request *dwc3_gadget_ep_alloc_request(struct usb_ep *ep,\n\t\tgfp_t gfp_flags)\n{\n\tstruct dwc3_request\t\t*req;\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->direction\t= dep->direction;\n\treq->epnum\t= dep->number;\n\treq->dep\t= dep;\n\treq->status\t= DWC3_REQUEST_STATUS_UNKNOWN;\n\n\ttrace_dwc3_alloc_request(req);\n\n\treturn &req->request;\n}\n\nstatic void dwc3_gadget_ep_free_request(struct usb_ep *ep,\n\t\tstruct usb_request *request)\n{\n\tstruct dwc3_request\t\t*req = to_dwc3_request(request);\n\n\ttrace_dwc3_free_request(req);\n\tkfree(req);\n}\n\n \nstatic struct dwc3_trb *dwc3_ep_prev_trb(struct dwc3_ep *dep, u8 index)\n{\n\tu8 tmp = index;\n\n\tif (!tmp)\n\t\ttmp = DWC3_TRB_NUM - 1;\n\n\treturn &dep->trb_pool[tmp - 1];\n}\n\nstatic u32 dwc3_calc_trbs_left(struct dwc3_ep *dep)\n{\n\tu8\t\t\ttrbs_left;\n\n\t \n\tif (dep->trb_enqueue == dep->trb_dequeue) {\n\t\t \n\t\tif (!list_empty(&dep->started_list))\n\t\t\treturn 0;\n\n\t\treturn DWC3_TRB_NUM - 1;\n\t}\n\n\ttrbs_left = dep->trb_dequeue - dep->trb_enqueue;\n\ttrbs_left &= (DWC3_TRB_NUM - 1);\n\n\tif (dep->trb_dequeue < dep->trb_enqueue)\n\t\ttrbs_left--;\n\n\treturn trbs_left;\n}\n\n \nstatic void dwc3_prepare_one_trb(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, unsigned int trb_length,\n\t\tunsigned int chain, unsigned int node, bool use_bounce_buffer,\n\t\tbool must_interrupt)\n{\n\tstruct dwc3_trb\t\t*trb;\n\tdma_addr_t\t\tdma;\n\tunsigned int\t\tstream_id = req->request.stream_id;\n\tunsigned int\t\tshort_not_ok = req->request.short_not_ok;\n\tunsigned int\t\tno_interrupt = req->request.no_interrupt;\n\tunsigned int\t\tis_last = req->request.is_last;\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tstruct usb_gadget\t*gadget = dwc->gadget;\n\tenum usb_device_speed\tspeed = gadget->speed;\n\n\tif (use_bounce_buffer)\n\t\tdma = dep->dwc->bounce_addr;\n\telse if (req->request.num_sgs > 0)\n\t\tdma = sg_dma_address(req->start_sg);\n\telse\n\t\tdma = req->request.dma;\n\n\ttrb = &dep->trb_pool[dep->trb_enqueue];\n\n\tif (!req->trb) {\n\t\tdwc3_gadget_move_started_request(req);\n\t\treq->trb = trb;\n\t\treq->trb_dma = dwc3_trb_dma_offset(dep, trb);\n\t}\n\n\treq->num_trbs++;\n\n\ttrb->size = DWC3_TRB_SIZE_LENGTH(trb_length);\n\ttrb->bpl = lower_32_bits(dma);\n\ttrb->bph = upper_32_bits(dma);\n\n\tswitch (usb_endpoint_type(dep->endpoint.desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\ttrb->ctrl = DWC3_TRBCTL_CONTROL_SETUP;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (!node) {\n\t\t\ttrb->ctrl = DWC3_TRBCTL_ISOCHRONOUS_FIRST;\n\n\t\t\t \n\t\t\tif (speed == USB_SPEED_HIGH) {\n\t\t\t\tstruct usb_ep *ep = &dep->endpoint;\n\t\t\t\tunsigned int mult = 2;\n\t\t\t\tunsigned int maxp = usb_endpoint_maxp(ep->desc);\n\n\t\t\t\tif (req->request.length <= (2 * maxp))\n\t\t\t\t\tmult--;\n\n\t\t\t\tif (req->request.length <= maxp)\n\t\t\t\t\tmult--;\n\n\t\t\t\ttrb->size |= DWC3_TRB_SIZE_PCM1(mult);\n\t\t\t}\n\t\t} else {\n\t\t\ttrb->ctrl = DWC3_TRBCTL_ISOCHRONOUS;\n\t\t}\n\n\t\tif (!no_interrupt && !chain)\n\t\t\ttrb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttrb->ctrl = DWC3_TRBCTL_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_WARN(dwc->dev, \"Unknown endpoint type %d\\n\",\n\t\t\t\tusb_endpoint_type(dep->endpoint.desc));\n\t}\n\n\t \n\tif (usb_endpoint_dir_out(dep->endpoint.desc)) {\n\t\tif (!dep->stream_capable)\n\t\t\ttrb->ctrl |= DWC3_TRB_CTRL_CSP;\n\n\t\tif (short_not_ok)\n\t\t\ttrb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;\n\t}\n\n\t \n\tif (dep->stream_capable && DWC3_MST_CAPABLE(&dwc->hwparams))\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_CSP;\n\n\tif ((!no_interrupt && !chain) || must_interrupt)\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_IOC;\n\n\tif (chain)\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_CHN;\n\telse if (dep->stream_capable && is_last &&\n\t\t !DWC3_MST_CAPABLE(&dwc->hwparams))\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_LST;\n\n\tif (usb_endpoint_xfer_bulk(dep->endpoint.desc) && dep->stream_capable)\n\t\ttrb->ctrl |= DWC3_TRB_CTRL_SID_SOFN(stream_id);\n\n\t \n\twmb();\n\ttrb->ctrl |= DWC3_TRB_CTRL_HWO;\n\n\tdwc3_ep_inc_enq(dep);\n\n\ttrace_dwc3_prepare_trb(dep, trb);\n}\n\nstatic bool dwc3_needs_extra_trb(struct dwc3_ep *dep, struct dwc3_request *req)\n{\n\tunsigned int maxp = usb_endpoint_maxp(dep->endpoint.desc);\n\tunsigned int rem = req->request.length % maxp;\n\n\tif ((req->request.length && req->request.zero && !rem &&\n\t\t\t!usb_endpoint_xfer_isoc(dep->endpoint.desc)) ||\n\t\t\t(!req->direction && rem))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int dwc3_prepare_last_sg(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, unsigned int entry_length,\n\t\tunsigned int node)\n{\n\tunsigned int maxp = usb_endpoint_maxp(dep->endpoint.desc);\n\tunsigned int rem = req->request.length % maxp;\n\tunsigned int num_trbs = 1;\n\n\tif (dwc3_needs_extra_trb(dep, req))\n\t\tnum_trbs++;\n\n\tif (dwc3_calc_trbs_left(dep) < num_trbs)\n\t\treturn 0;\n\n\treq->needs_extra_trb = num_trbs > 1;\n\n\t \n\tif (req->direction || req->request.length)\n\t\tdwc3_prepare_one_trb(dep, req, entry_length,\n\t\t\t\treq->needs_extra_trb, node, false, false);\n\n\t \n\tif ((!req->direction && !req->request.length) || req->needs_extra_trb)\n\t\tdwc3_prepare_one_trb(dep, req,\n\t\t\t\treq->direction ? 0 : maxp - rem,\n\t\t\t\tfalse, 1, true, false);\n\n\treturn num_trbs;\n}\n\nstatic int dwc3_prepare_trbs_sg(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req)\n{\n\tstruct scatterlist *sg = req->start_sg;\n\tstruct scatterlist *s;\n\tint\t\ti;\n\tunsigned int length = req->request.length;\n\tunsigned int remaining = req->request.num_mapped_sgs\n\t\t- req->num_queued_sgs;\n\tunsigned int num_trbs = req->num_trbs;\n\tbool needs_extra_trb = dwc3_needs_extra_trb(dep, req);\n\n\t \n\tfor_each_sg(req->request.sg, s, req->num_queued_sgs, i)\n\t\tlength -= sg_dma_len(s);\n\n\tfor_each_sg(sg, s, remaining, i) {\n\t\tunsigned int num_trbs_left = dwc3_calc_trbs_left(dep);\n\t\tunsigned int trb_length;\n\t\tbool must_interrupt = false;\n\t\tbool last_sg = false;\n\n\t\ttrb_length = min_t(unsigned int, length, sg_dma_len(s));\n\n\t\tlength -= trb_length;\n\n\t\t \n\t\tif ((i == remaining - 1) || !length)\n\t\t\tlast_sg = true;\n\n\t\tif (!num_trbs_left)\n\t\t\tbreak;\n\n\t\tif (last_sg) {\n\t\t\tif (!dwc3_prepare_last_sg(dep, req, trb_length, i))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (num_trbs_left == 1 || (needs_extra_trb &&\n\t\t\t\t\tnum_trbs_left <= 2 &&\n\t\t\t\t\tsg_dma_len(sg_next(s)) >= length)) {\n\t\t\t\tstruct dwc3_request *r;\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry(r, &dep->started_list, list) {\n\t\t\t\t\tif (r != req && !r->request.no_interrupt)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (r == req)\n\t\t\t\t\t\tmust_interrupt = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdwc3_prepare_one_trb(dep, req, trb_length, 1, i, false,\n\t\t\t\t\tmust_interrupt);\n\t\t}\n\n\t\t \n\t\tif (!last_sg)\n\t\t\treq->start_sg = sg_next(s);\n\n\t\treq->num_queued_sgs++;\n\t\treq->num_pending_sgs--;\n\n\t\t \n\t\tif (length == 0) {\n\t\t\treq->num_pending_sgs = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (must_interrupt)\n\t\t\tbreak;\n\t}\n\n\treturn req->num_trbs - num_trbs;\n}\n\nstatic int dwc3_prepare_trbs_linear(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req)\n{\n\treturn dwc3_prepare_last_sg(dep, req, req->request.length, 0);\n}\n\n \nstatic int dwc3_prepare_trbs(struct dwc3_ep *dep)\n{\n\tstruct dwc3_request\t*req, *n;\n\tint\t\t\tret = 0;\n\n\tBUILD_BUG_ON_NOT_POWER_OF_2(DWC3_TRB_NUM);\n\n\t \n\tlist_for_each_entry(req, &dep->started_list, list) {\n\t\tif (req->num_pending_sgs > 0) {\n\t\t\tret = dwc3_prepare_trbs_sg(dep, req);\n\t\t\tif (!ret || req->num_pending_sgs)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (!dwc3_calc_trbs_left(dep))\n\t\t\treturn ret;\n\n\t\t \n\t\tif (dep->stream_capable && req->request.is_last &&\n\t\t    !DWC3_MST_CAPABLE(&dep->dwc->hwparams))\n\t\t\treturn ret;\n\t}\n\n\tlist_for_each_entry_safe(req, n, &dep->pending_list, list) {\n\t\tstruct dwc3\t*dwc = dep->dwc;\n\n\t\tret = usb_gadget_map_request_by_dev(dwc->sysdev, &req->request,\n\t\t\t\t\t\t    dep->direction);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treq->sg\t\t\t= req->request.sg;\n\t\treq->start_sg\t\t= req->sg;\n\t\treq->num_queued_sgs\t= 0;\n\t\treq->num_pending_sgs\t= req->request.num_mapped_sgs;\n\n\t\tif (req->num_pending_sgs > 0) {\n\t\t\tret = dwc3_prepare_trbs_sg(dep, req);\n\t\t\tif (req->num_pending_sgs)\n\t\t\t\treturn ret;\n\t\t} else {\n\t\t\tret = dwc3_prepare_trbs_linear(dep, req);\n\t\t}\n\n\t\tif (!ret || !dwc3_calc_trbs_left(dep))\n\t\t\treturn ret;\n\n\t\t \n\t\tif (dep->stream_capable && req->request.is_last &&\n\t\t    !DWC3_MST_CAPABLE(&dwc->hwparams))\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic void dwc3_gadget_ep_cleanup_cancelled_requests(struct dwc3_ep *dep);\n\nstatic int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep)\n{\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tstruct dwc3_request\t\t*req;\n\tint\t\t\t\tstarting;\n\tint\t\t\t\tret;\n\tu32\t\t\t\tcmd;\n\n\t \n\tret = dwc3_prepare_trbs(dep);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tstarting = !(dep->flags & DWC3_EP_TRANSFER_STARTED);\n\n\t \n\tif (!ret && !starting)\n\t\treturn ret;\n\n\treq = next_request(&dep->started_list);\n\tif (!req) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn 0;\n\t}\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (starting) {\n\t\tparams.param0 = upper_32_bits(req->trb_dma);\n\t\tparams.param1 = lower_32_bits(req->trb_dma);\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\n\t\tif (dep->stream_capable)\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(req->request.stream_id);\n\n\t\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\tcmd |= DWC3_DEPCMD_PARAM(dep->frame_number);\n\t} else {\n\t\tcmd = DWC3_DEPCMD_UPDATETRANSFER |\n\t\t\tDWC3_DEPCMD_PARAM(dep->resource_index);\n\t}\n\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\tif (ret < 0) {\n\t\tstruct dwc3_request *tmp;\n\n\t\tif (ret == -EAGAIN)\n\t\t\treturn ret;\n\n\t\tdwc3_stop_active_transfer(dep, true, true);\n\n\t\tlist_for_each_entry_safe(req, tmp, &dep->started_list, list)\n\t\t\tdwc3_gadget_move_cancelled_request(req, DWC3_REQUEST_STATUS_DEQUEUED);\n\n\t\t \n\t\tif (!(dep->flags & DWC3_EP_END_TRANSFER_PENDING))\n\t\t\tdwc3_gadget_ep_cleanup_cancelled_requests(dep);\n\n\t\treturn ret;\n\t}\n\n\tif (dep->stream_capable && req->request.is_last &&\n\t    !DWC3_MST_CAPABLE(&dep->dwc->hwparams))\n\t\tdep->flags |= DWC3_EP_WAIT_TRANSFER_COMPLETE;\n\n\treturn 0;\n}\n\nstatic int __dwc3_gadget_get_frame(struct dwc3 *dwc)\n{\n\tu32\t\t\treg;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\treturn DWC3_DSTS_SOFFN(reg);\n}\n\n \nstatic int __dwc3_stop_active_transfer(struct dwc3_ep *dep, bool force, bool interrupt)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\tstruct dwc3_gadget_ep_cmd_params params;\n\tu32 cmd;\n\tint ret;\n\n\tcmd = DWC3_DEPCMD_ENDTRANSFER;\n\tcmd |= force ? DWC3_DEPCMD_HIPRI_FORCERM : 0;\n\tcmd |= interrupt ? DWC3_DEPCMD_CMDIOC : 0;\n\tcmd |= DWC3_DEPCMD_PARAM(dep->resource_index);\n\tmemset(&params, 0, sizeof(params));\n\tret = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\t \n\tif (ret == -ETIMEDOUT && dep->dwc->ep0state != EP0_SETUP_PHASE) {\n\t\tdep->flags |= DWC3_EP_DELAY_STOP;\n\t\treturn 0;\n\t}\n\tWARN_ON_ONCE(ret);\n\tdep->resource_index = 0;\n\n\tif (!interrupt) {\n\t\tif (!DWC3_IP_IS(DWC3) || DWC3_VER_IS_PRIOR(DWC3, 310A))\n\t\t\tmdelay(1);\n\t\tdep->flags &= ~DWC3_EP_TRANSFER_STARTED;\n\t} else if (!ret) {\n\t\tdep->flags |= DWC3_EP_END_TRANSFER_PENDING;\n\t}\n\n\tdep->flags &= ~DWC3_EP_DELAY_STOP;\n\treturn ret;\n}\n\n \nstatic int dwc3_gadget_start_isoc_quirk(struct dwc3_ep *dep)\n{\n\tint cmd_status = 0;\n\tbool test0;\n\tbool test1;\n\n\twhile (dep->combo_num < 2) {\n\t\tstruct dwc3_gadget_ep_cmd_params params;\n\t\tu32 test_frame_number;\n\t\tu32 cmd;\n\n\t\t \n\t\ttest_frame_number = dep->frame_number & DWC3_FRNUMBER_MASK;\n\t\ttest_frame_number |= dep->combo_num << 14;\n\t\ttest_frame_number += max_t(u32, 4, dep->interval);\n\n\t\tparams.param0 = upper_32_bits(dep->dwc->bounce_addr);\n\t\tparams.param1 = lower_32_bits(dep->dwc->bounce_addr);\n\n\t\tcmd = DWC3_DEPCMD_STARTTRANSFER;\n\t\tcmd |= DWC3_DEPCMD_PARAM(test_frame_number);\n\t\tcmd_status = dwc3_send_gadget_ep_cmd(dep, cmd, &params);\n\n\t\t \n\t\tif (cmd_status && cmd_status != -EAGAIN) {\n\t\t\tdep->start_cmd_status = 0;\n\t\t\tdep->combo_num = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (dep->combo_num == 0)\n\t\t\tdep->start_cmd_status = cmd_status;\n\n\t\tdep->combo_num++;\n\n\t\t \n\t\tif (cmd_status == 0) {\n\t\t\tdwc3_stop_active_transfer(dep, true, true);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\ttest0 = (dep->start_cmd_status == 0);\n\ttest1 = (cmd_status == 0);\n\n\tif (!test0 && test1)\n\t\tdep->combo_num = 1;\n\telse if (!test0 && !test1)\n\t\tdep->combo_num = 2;\n\telse if (test0 && !test1)\n\t\tdep->combo_num = 3;\n\telse if (test0 && test1)\n\t\tdep->combo_num = 0;\n\n\tdep->frame_number &= DWC3_FRNUMBER_MASK;\n\tdep->frame_number |= dep->combo_num << 14;\n\tdep->frame_number += max_t(u32, 4, dep->interval);\n\n\t \n\tdep->start_cmd_status = 0;\n\tdep->combo_num = 0;\n\n\treturn __dwc3_gadget_kick_transfer(dep);\n}\n\nstatic int __dwc3_gadget_start_isoc(struct dwc3_ep *dep)\n{\n\tconst struct usb_endpoint_descriptor *desc = dep->endpoint.desc;\n\tstruct dwc3 *dwc = dep->dwc;\n\tint ret;\n\tint i;\n\n\tif (list_empty(&dep->pending_list) &&\n\t    list_empty(&dep->started_list)) {\n\t\tdep->flags |= DWC3_EP_PENDING_REQUEST;\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!dwc->dis_start_transfer_quirk &&\n\t    (DWC3_VER_IS_PRIOR(DWC31, 170A) ||\n\t     DWC3_VER_TYPE_IS_WITHIN(DWC31, 170A, EA01, EA06))) {\n\t\tif (dwc->gadget->speed <= USB_SPEED_HIGH && dep->direction)\n\t\t\treturn dwc3_gadget_start_isoc_quirk(dep);\n\t}\n\n\tif (desc->bInterval <= 14 &&\n\t    dwc->gadget->speed >= USB_SPEED_HIGH) {\n\t\tu32 frame = __dwc3_gadget_get_frame(dwc);\n\t\tbool rollover = frame <\n\t\t\t\t(dep->frame_number & DWC3_FRNUMBER_MASK);\n\n\t\t \n\n\t\tdep->frame_number = (dep->frame_number & ~DWC3_FRNUMBER_MASK) |\n\t\t\t\t     frame;\n\t\tif (rollover)\n\t\t\tdep->frame_number += BIT(14);\n\t}\n\n\tfor (i = 0; i < DWC3_ISOC_MAX_RETRIES; i++) {\n\t\tint future_interval = i + 1;\n\n\t\t \n\t\tif (desc->bInterval < 3)\n\t\t\tfuture_interval += 3 - desc->bInterval;\n\n\t\tdep->frame_number = DWC3_ALIGN_FRAME(dep, future_interval);\n\n\t\tret = __dwc3_gadget_kick_transfer(dep);\n\t\tif (ret != -EAGAIN)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (ret == -EAGAIN)\n\t\tret = __dwc3_stop_active_transfer(dep, false, true);\n\n\treturn ret;\n}\n\nstatic int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tif (!dep->endpoint.desc || !dwc->pullups_connected || !dwc->connected) {\n\t\tdev_dbg(dwc->dev, \"%s: can't queue to disabled endpoint\\n\",\n\t\t\t\tdep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (WARN(req->dep != dep, \"request %pK belongs to '%s'\\n\",\n\t\t\t\t&req->request, req->dep->name))\n\t\treturn -EINVAL;\n\n\tif (WARN(req->status < DWC3_REQUEST_STATUS_COMPLETED,\n\t\t\t\t\"%s: request %pK already in flight\\n\",\n\t\t\t\tdep->name, &req->request))\n\t\treturn -EINVAL;\n\n\tpm_runtime_get(dwc->dev);\n\n\treq->request.actual\t= 0;\n\treq->request.status\t= -EINPROGRESS;\n\n\ttrace_dwc3_ep_queue(req);\n\n\tlist_add_tail(&req->list, &dep->pending_list);\n\treq->status = DWC3_REQUEST_STATUS_QUEUED;\n\n\tif (dep->flags & DWC3_EP_WAIT_TRANSFER_COMPLETE)\n\t\treturn 0;\n\n\t \n\tif ((dep->flags & DWC3_EP_END_TRANSFER_PENDING) ||\n\t    (dep->flags & DWC3_EP_WEDGE) ||\n\t    (dep->flags & DWC3_EP_DELAY_STOP) ||\n\t    (dep->flags & DWC3_EP_STALL)) {\n\t\tdep->flags |= DWC3_EP_DELAY_START;\n\t\treturn 0;\n\t}\n\n\t \n\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\n\t\tif (!(dep->flags & DWC3_EP_TRANSFER_STARTED)) {\n\t\t\tif ((dep->flags & DWC3_EP_PENDING_REQUEST))\n\t\t\t\treturn __dwc3_gadget_start_isoc(dep);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t__dwc3_gadget_kick_transfer(dep);\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,\n\tgfp_t gfp_flags)\n{\n\tstruct dwc3_request\t\t*req = to_dwc3_request(request);\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tunsigned long\t\t\tflags;\n\n\tint\t\t\t\tret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = __dwc3_gadget_ep_queue(dep, req);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void dwc3_gadget_ep_skip_trbs(struct dwc3_ep *dep, struct dwc3_request *req)\n{\n\tint i;\n\n\t \n\tif (!req->trb)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < req->num_trbs; i++) {\n\t\tstruct dwc3_trb *trb;\n\n\t\ttrb = &dep->trb_pool[dep->trb_dequeue];\n\t\ttrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\n\t\tdwc3_ep_inc_deq(dep);\n\t}\n\n\treq->num_trbs = 0;\n}\n\nstatic void dwc3_gadget_ep_cleanup_cancelled_requests(struct dwc3_ep *dep)\n{\n\tstruct dwc3_request\t\t*req;\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\twhile (!list_empty(&dep->cancelled_list)) {\n\t\treq = next_request(&dep->cancelled_list);\n\t\tdwc3_gadget_ep_skip_trbs(dep, req);\n\t\tswitch (req->status) {\n\t\tcase DWC3_REQUEST_STATUS_DISCONNECTED:\n\t\t\tdwc3_gadget_giveback(dep, req, -ESHUTDOWN);\n\t\t\tbreak;\n\t\tcase DWC3_REQUEST_STATUS_DEQUEUED:\n\t\t\tdwc3_gadget_giveback(dep, req, -ECONNRESET);\n\t\t\tbreak;\n\t\tcase DWC3_REQUEST_STATUS_STALLED:\n\t\t\tdwc3_gadget_giveback(dep, req, -EPIPE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dwc->dev, \"request cancelled with wrong reason:%d\\n\", req->status);\n\t\t\tdwc3_gadget_giveback(dep, req, -ECONNRESET);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!dep->endpoint.desc)\n\t\t\tbreak;\n\t}\n}\n\nstatic int dwc3_gadget_ep_dequeue(struct usb_ep *ep,\n\t\tstruct usb_request *request)\n{\n\tstruct dwc3_request\t\t*req = to_dwc3_request(request);\n\tstruct dwc3_request\t\t*r = NULL;\n\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tret = 0;\n\n\ttrace_dwc3_ep_dequeue(req);\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\n\tlist_for_each_entry(r, &dep->cancelled_list, list) {\n\t\tif (r == req)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(r, &dep->pending_list, list) {\n\t\tif (r == req) {\n\t\t\t \n\t\t\tif (dep->number > 1)\n\t\t\t\tdwc3_gadget_giveback(dep, req, -ECONNRESET);\n\t\t\telse\n\t\t\t\tdwc3_ep0_reset_state(dwc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry(r, &dep->started_list, list) {\n\t\tif (r == req) {\n\t\t\tstruct dwc3_request *t;\n\n\t\t\t \n\t\t\tdwc3_stop_active_transfer(dep, true, true);\n\n\t\t\t \n\t\t\tlist_for_each_entry_safe(r, t, &dep->started_list, list)\n\t\t\t\tdwc3_gadget_move_cancelled_request(r,\n\t\t\t\t\t\tDWC3_REQUEST_STATUS_DEQUEUED);\n\n\t\t\tdep->flags &= ~DWC3_EP_WAIT_TRANSFER_COMPLETE;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_err(dwc->dev, \"request %pK was not queued to %s\\n\",\n\t\trequest, ep->name);\n\tret = -EINVAL;\nout:\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nint __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value, int protocol)\n{\n\tstruct dwc3_gadget_ep_cmd_params\tparams;\n\tstruct dwc3\t\t\t\t*dwc = dep->dwc;\n\tstruct dwc3_request\t\t\t*req;\n\tstruct dwc3_request\t\t\t*tmp;\n\tint\t\t\t\t\tret;\n\n\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {\n\t\tdev_err(dwc->dev, \"%s is of Isochronous type\\n\", dep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&params, 0x00, sizeof(params));\n\n\tif (value) {\n\t\tstruct dwc3_trb *trb;\n\n\t\tunsigned int transfer_in_flight;\n\t\tunsigned int started;\n\n\t\tif (dep->number > 1)\n\t\t\ttrb = dwc3_ep_prev_trb(dep, dep->trb_enqueue);\n\t\telse\n\t\t\ttrb = &dwc->ep0_trb[dep->trb_enqueue];\n\n\t\ttransfer_in_flight = trb->ctrl & DWC3_TRB_CTRL_HWO;\n\t\tstarted = !list_empty(&dep->started_list);\n\n\t\tif (!protocol && ((dep->direction && transfer_in_flight) ||\n\t\t\t\t(!dep->direction && started))) {\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tret = dwc3_send_gadget_ep_cmd(dep, DWC3_DEPCMD_SETSTALL,\n\t\t\t\t&params);\n\t\tif (ret)\n\t\t\tdev_err(dwc->dev, \"failed to set STALL on %s\\n\",\n\t\t\t\t\tdep->name);\n\t\telse\n\t\t\tdep->flags |= DWC3_EP_STALL;\n\t} else {\n\t\t \n\t\tif (dep->number <= 1) {\n\t\t\tdep->flags &= ~(DWC3_EP_STALL | DWC3_EP_WEDGE);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdwc3_stop_active_transfer(dep, true, true);\n\n\t\tlist_for_each_entry_safe(req, tmp, &dep->started_list, list)\n\t\t\tdwc3_gadget_move_cancelled_request(req, DWC3_REQUEST_STATUS_STALLED);\n\n\t\tif (dep->flags & DWC3_EP_END_TRANSFER_PENDING ||\n\t\t    (dep->flags & DWC3_EP_DELAY_STOP)) {\n\t\t\tdep->flags |= DWC3_EP_PENDING_CLEAR_STALL;\n\t\t\tif (protocol)\n\t\t\t\tdwc->clear_stall_protocol = dep->number;\n\n\t\t\treturn 0;\n\t\t}\n\n\t\tdwc3_gadget_ep_cleanup_cancelled_requests(dep);\n\n\t\tret = dwc3_send_clear_stall_ep_cmd(dep);\n\t\tif (ret) {\n\t\t\tdev_err(dwc->dev, \"failed to clear STALL on %s\\n\",\n\t\t\t\t\tdep->name);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdep->flags &= ~(DWC3_EP_STALL | DWC3_EP_WEDGE);\n\n\t\tif ((dep->flags & DWC3_EP_DELAY_START) &&\n\t\t    !usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t\t__dwc3_gadget_kick_transfer(dep);\n\n\t\tdep->flags &= ~DWC3_EP_DELAY_START;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\n\tunsigned long\t\t\tflags;\n\n\tint\t\t\t\tret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = __dwc3_gadget_ep_set_halt(dep, value, false);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct dwc3_ep\t\t\t*dep = to_dwc3_ep(ep);\n\tstruct dwc3\t\t\t*dwc = dep->dwc;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdep->flags |= DWC3_EP_WEDGE;\n\n\tif (dep->number == 0 || dep->number == 1)\n\t\tret = __dwc3_gadget_ep0_set_halt(ep, 1);\n\telse\n\t\tret = __dwc3_gadget_ep_set_halt(dep, 1, false);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\n \n\nstatic struct usb_endpoint_descriptor dwc3_gadget_ep0_desc = {\n\t.bLength\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes\t= USB_ENDPOINT_XFER_CONTROL,\n};\n\nstatic const struct usb_ep_ops dwc3_gadget_ep0_ops = {\n\t.enable\t\t= dwc3_gadget_ep0_enable,\n\t.disable\t= dwc3_gadget_ep0_disable,\n\t.alloc_request\t= dwc3_gadget_ep_alloc_request,\n\t.free_request\t= dwc3_gadget_ep_free_request,\n\t.queue\t\t= dwc3_gadget_ep0_queue,\n\t.dequeue\t= dwc3_gadget_ep_dequeue,\n\t.set_halt\t= dwc3_gadget_ep0_set_halt,\n\t.set_wedge\t= dwc3_gadget_ep_set_wedge,\n};\n\nstatic const struct usb_ep_ops dwc3_gadget_ep_ops = {\n\t.enable\t\t= dwc3_gadget_ep_enable,\n\t.disable\t= dwc3_gadget_ep_disable,\n\t.alloc_request\t= dwc3_gadget_ep_alloc_request,\n\t.free_request\t= dwc3_gadget_ep_free_request,\n\t.queue\t\t= dwc3_gadget_ep_queue,\n\t.dequeue\t= dwc3_gadget_ep_dequeue,\n\t.set_halt\t= dwc3_gadget_ep_set_halt,\n\t.set_wedge\t= dwc3_gadget_ep_set_wedge,\n};\n\n \n\nstatic void dwc3_gadget_enable_linksts_evts(struct dwc3 *dwc, bool set)\n{\n\tu32 reg;\n\n\tif (DWC3_VER_IS_PRIOR(DWC3, 250A))\n\t\treturn;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DEVTEN);\n\tif (set)\n\t\treg |= DWC3_DEVTEN_ULSTCNGEN;\n\telse\n\t\treg &= ~DWC3_DEVTEN_ULSTCNGEN;\n\n\tdwc3_writel(dwc->regs, DWC3_DEVTEN, reg);\n}\n\nstatic int dwc3_gadget_get_frame(struct usb_gadget *g)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\n\treturn __dwc3_gadget_get_frame(dwc);\n}\n\nstatic int __dwc3_gadget_wakeup(struct dwc3 *dwc, bool async)\n{\n\tint\t\t\tretries;\n\n\tint\t\t\tret;\n\tu32\t\t\treg;\n\n\tu8\t\t\tlink_state;\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\n\tlink_state = DWC3_DSTS_USBLNKST(reg);\n\n\tswitch (link_state) {\n\tcase DWC3_LINK_STATE_RESET:\n\tcase DWC3_LINK_STATE_RX_DET:\t \n\tcase DWC3_LINK_STATE_U3:\t \n\tcase DWC3_LINK_STATE_U2:\t \n\tcase DWC3_LINK_STATE_U1:\n\tcase DWC3_LINK_STATE_RESUME:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (async)\n\t\tdwc3_gadget_enable_linksts_evts(dwc, true);\n\n\tret = dwc3_gadget_set_link_state(dwc, DWC3_LINK_STATE_RECOV);\n\tif (ret < 0) {\n\t\tdev_err(dwc->dev, \"failed to put link in Recovery\\n\");\n\t\tdwc3_gadget_enable_linksts_evts(dwc, false);\n\t\treturn ret;\n\t}\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 194A)) {\n\t\t \n\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\treg &= ~DWC3_DCTL_ULSTCHNGREQ_MASK;\n\t\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\t}\n\n\t \n\tif (async)\n\t\treturn 0;\n\n\t \n\tretries = 20000;\n\n\twhile (retries--) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\n\t\t \n\t\tif (DWC3_DSTS_USBLNKST(reg) == DWC3_LINK_STATE_U0)\n\t\t\tbreak;\n\t}\n\n\tif (DWC3_DSTS_USBLNKST(reg) != DWC3_LINK_STATE_U0) {\n\t\tdev_err(dwc->dev, \"failed to send remote wakeup\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_wakeup(struct usb_gadget *g)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\tint\t\t\tret;\n\n\tif (!dwc->wakeup_configured) {\n\t\tdev_err(dwc->dev, \"remote wakeup not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tif (!dwc->gadget->wakeup_armed) {\n\t\tdev_err(dwc->dev, \"not armed for remote wakeup\\n\");\n\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tret = __dwc3_gadget_wakeup(dwc, true);\n\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void dwc3_resume_gadget(struct dwc3 *dwc);\n\nstatic int dwc3_gadget_func_wakeup(struct usb_gadget *g, int intf_id)\n{\n\tstruct  dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\tint\t\t\tret;\n\tint\t\t\tlink_state;\n\n\tif (!dwc->wakeup_configured) {\n\t\tdev_err(dwc->dev, \"remote wakeup not configured\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\t \n\tlink_state = dwc3_gadget_get_link_state(dwc);\n\tif (link_state == DWC3_LINK_STATE_U3) {\n\t\tret = __dwc3_gadget_wakeup(dwc, false);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tdwc3_resume_gadget(dwc);\n\t\tdwc->suspended = false;\n\t\tdwc->link_state = DWC3_LINK_STATE_U0;\n\t}\n\n\tret = dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_DEV_NOTIFICATION,\n\t\t\t\t\t       DWC3_DGCMDPAR_DN_FUNC_WAKE |\n\t\t\t\t\t       DWC3_DGCMDPAR_INTF_SEL(intf_id));\n\tif (ret)\n\t\tdev_err(dwc->dev, \"function remote wakeup failed, ret:%d\\n\", ret);\n\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_set_remote_wakeup(struct usb_gadget *g, int set)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->wakeup_configured = !!set;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_set_selfpowered(struct usb_gadget *g,\n\t\tint is_selfpowered)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tg->is_selfpowered = !!is_selfpowered;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn 0;\n}\n\nstatic void dwc3_stop_active_transfers(struct dwc3 *dwc)\n{\n\tu32 epnum;\n\n\tfor (epnum = 2; epnum < dwc->num_eps; epnum++) {\n\t\tstruct dwc3_ep *dep;\n\n\t\tdep = dwc->eps[epnum];\n\t\tif (!dep)\n\t\t\tcontinue;\n\n\t\tdwc3_remove_requests(dwc, dep, -ESHUTDOWN);\n\t}\n}\n\nstatic void __dwc3_gadget_set_ssp_rate(struct dwc3 *dwc)\n{\n\tenum usb_ssp_rate\tssp_rate = dwc->gadget_ssp_rate;\n\tu32\t\t\treg;\n\n\tif (ssp_rate == USB_SSP_GEN_UNKNOWN)\n\t\tssp_rate = dwc->max_ssp_rate;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg &= ~DWC3_DCFG_SPEED_MASK;\n\treg &= ~DWC3_DCFG_NUMLANES(~0);\n\n\tif (ssp_rate == USB_SSP_GEN_1x2)\n\t\treg |= DWC3_DCFG_SUPERSPEED;\n\telse if (dwc->max_ssp_rate != USB_SSP_GEN_1x2)\n\t\treg |= DWC3_DCFG_SUPERSPEED_PLUS;\n\n\tif (ssp_rate != USB_SSP_GEN_2x1 &&\n\t    dwc->max_ssp_rate != USB_SSP_GEN_2x1)\n\t\treg |= DWC3_DCFG_NUMLANES(1);\n\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n}\n\nstatic void __dwc3_gadget_set_speed(struct dwc3 *dwc)\n{\n\tenum usb_device_speed\tspeed;\n\tu32\t\t\treg;\n\n\tspeed = dwc->gadget_max_speed;\n\tif (speed == USB_SPEED_UNKNOWN || speed > dwc->maximum_speed)\n\t\tspeed = dwc->maximum_speed;\n\n\tif (speed == USB_SPEED_SUPER_PLUS &&\n\t    DWC3_IP_IS(DWC32)) {\n\t\t__dwc3_gadget_set_ssp_rate(dwc);\n\t\treturn;\n\t}\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg &= ~(DWC3_DCFG_SPEED_MASK);\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 220A) &&\n\t    !dwc->dis_metastability_quirk) {\n\t\treg |= DWC3_DCFG_SUPERSPEED;\n\t} else {\n\t\tswitch (speed) {\n\t\tcase USB_SPEED_FULL:\n\t\t\treg |= DWC3_DCFG_FULLSPEED;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\treg |= DWC3_DCFG_HIGHSPEED;\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER:\n\t\t\treg |= DWC3_DCFG_SUPERSPEED;\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\t\tif (DWC3_IP_IS(DWC3))\n\t\t\t\treg |= DWC3_DCFG_SUPERSPEED;\n\t\t\telse\n\t\t\t\treg |= DWC3_DCFG_SUPERSPEED_PLUS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dwc->dev, \"invalid speed (%d)\\n\", speed);\n\n\t\t\tif (DWC3_IP_IS(DWC3))\n\t\t\t\treg |= DWC3_DCFG_SUPERSPEED;\n\t\t\telse\n\t\t\t\treg |= DWC3_DCFG_SUPERSPEED_PLUS;\n\t\t}\n\t}\n\n\tif (DWC3_IP_IS(DWC32) &&\n\t    speed > USB_SPEED_UNKNOWN &&\n\t    speed < USB_SPEED_SUPER_PLUS)\n\t\treg &= ~DWC3_DCFG_NUMLANES(~0);\n\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n}\n\nstatic int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)\n{\n\tu32\t\t\treg;\n\tu32\t\t\ttimeout = 2000;\n\n\tif (pm_runtime_suspended(dwc->dev))\n\t\treturn 0;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\tif (is_on) {\n\t\tif (DWC3_VER_IS_WITHIN(DWC3, ANY, 187A)) {\n\t\t\treg &= ~DWC3_DCTL_TRGTULST_MASK;\n\t\t\treg |= DWC3_DCTL_TRGTULST_RX_DET;\n\t\t}\n\n\t\tif (!DWC3_VER_IS_PRIOR(DWC3, 194A))\n\t\t\treg &= ~DWC3_DCTL_KEEP_CONNECT;\n\t\treg |= DWC3_DCTL_RUN_STOP;\n\n\t\t__dwc3_gadget_set_speed(dwc);\n\t\tdwc->pullups_connected = true;\n\t} else {\n\t\treg &= ~DWC3_DCTL_RUN_STOP;\n\n\t\tdwc->pullups_connected = false;\n\t}\n\n\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\n\tdo {\n\t\tusleep_range(1000, 2000);\n\t\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\t\treg &= DWC3_DSTS_DEVCTRLHLT;\n\t} while (--timeout && !(!is_on ^ !reg));\n\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic void dwc3_gadget_disable_irq(struct dwc3 *dwc);\nstatic void __dwc3_gadget_stop(struct dwc3 *dwc);\nstatic int __dwc3_gadget_start(struct dwc3 *dwc);\n\nstatic int dwc3_gadget_soft_disconnect(struct dwc3 *dwc)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->connected = false;\n\n\t \n\tif (dwc->delayed_status)\n\t\tdwc3_ep0_send_delayed_status(dwc);\n\n\t \n\tdwc3_stop_active_transfers(dwc);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\t \n\tif (dwc->ep0state != EP0_SETUP_PHASE) {\n\t\treinit_completion(&dwc->ep0_in_setup);\n\n\t\tret = wait_for_completion_timeout(&dwc->ep0_in_setup,\n\t\t\t\tmsecs_to_jiffies(DWC3_PULL_UP_TIMEOUT));\n\t\tif (ret == 0) {\n\t\t\tdev_warn(dwc->dev, \"wait for SETUP phase timed out\\n\");\n\t\t\tspin_lock_irqsave(&dwc->lock, flags);\n\t\t\tdwc3_ep0_reset_state(dwc);\n\t\t\tspin_unlock_irqrestore(&dwc->lock, flags);\n\t\t}\n\t}\n\n\t \n\tret = dwc3_gadget_run_stop(dwc, false);\n\n\t \n\tspin_lock_irqsave(&dwc->lock, flags);\n\t__dwc3_gadget_stop(dwc);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_soft_connect(struct dwc3 *dwc)\n{\n\tint ret;\n\n\t \n\tret = dwc3_core_soft_reset(dwc);\n\tif (ret)\n\t\treturn ret;\n\n\tdwc3_event_buffers_setup(dwc);\n\t__dwc3_gadget_start(dwc);\n\treturn dwc3_gadget_run_stop(dwc, true);\n}\n\nstatic int dwc3_gadget_pullup(struct usb_gadget *g, int is_on)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tint\t\t\tret;\n\n\tis_on = !!is_on;\n\n\tdwc->softconnect = is_on;\n\n\t \n\tif (!is_on) {\n\t\tpm_runtime_barrier(dwc->dev);\n\t\tif (pm_runtime_suspended(dwc->dev))\n\t\t\treturn 0;\n\t}\n\n\t \n\tret = pm_runtime_get_sync(dwc->dev);\n\tif (!ret || ret < 0) {\n\t\tpm_runtime_put(dwc->dev);\n\t\tif (ret < 0)\n\t\t\tpm_runtime_set_suspended(dwc->dev);\n\t\treturn ret;\n\t}\n\n\tif (dwc->pullups_connected == is_on) {\n\t\tpm_runtime_put(dwc->dev);\n\t\treturn 0;\n\t}\n\n\tsynchronize_irq(dwc->irq_gadget);\n\n\tif (!is_on)\n\t\tret = dwc3_gadget_soft_disconnect(dwc);\n\telse\n\t\tret = dwc3_gadget_soft_connect(dwc);\n\n\tpm_runtime_put(dwc->dev);\n\n\treturn ret;\n}\n\nstatic void dwc3_gadget_enable_irq(struct dwc3 *dwc)\n{\n\tu32\t\t\treg;\n\n\t \n\treg = (DWC3_DEVTEN_EVNTOVERFLOWEN |\n\t\t\tDWC3_DEVTEN_CMDCMPLTEN |\n\t\t\tDWC3_DEVTEN_ERRTICERREN |\n\t\t\tDWC3_DEVTEN_WKUPEVTEN |\n\t\t\tDWC3_DEVTEN_CONNECTDONEEN |\n\t\t\tDWC3_DEVTEN_USBRSTEN |\n\t\t\tDWC3_DEVTEN_DISCONNEVTEN);\n\n\tif (DWC3_VER_IS_PRIOR(DWC3, 250A))\n\t\treg |= DWC3_DEVTEN_ULSTCNGEN;\n\n\t \n\tif (!DWC3_VER_IS_PRIOR(DWC3, 230A))\n\t\treg |= DWC3_DEVTEN_U3L2L1SUSPEN;\n\n\tdwc3_writel(dwc->regs, DWC3_DEVTEN, reg);\n}\n\nstatic void dwc3_gadget_disable_irq(struct dwc3 *dwc)\n{\n\t \n\tdwc3_writel(dwc->regs, DWC3_DEVTEN, 0x00);\n}\n\nstatic irqreturn_t dwc3_interrupt(int irq, void *_dwc);\nstatic irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc);\n\n \nstatic void dwc3_gadget_setup_nump(struct dwc3 *dwc)\n{\n\tu32 ram2_depth;\n\tu32 mdwidth;\n\tu32 nump;\n\tu32 reg;\n\n\tram2_depth = DWC3_GHWPARAMS7_RAM2_DEPTH(dwc->hwparams.hwparams7);\n\tmdwidth = dwc3_mdwidth(dwc);\n\n\tnump = ((ram2_depth * mdwidth / 8) - 24 - 16) / 1024;\n\tnump = min_t(u32, nump, 16);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg &= ~DWC3_DCFG_NUMP_MASK;\n\treg |= nump << DWC3_DCFG_NUMP_SHIFT;\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n}\n\nstatic int __dwc3_gadget_start(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tint\t\t\tret = 0;\n\tu32\t\t\treg;\n\n\t \n\tif (dwc->imod_interval) {\n\t\tdwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), dwc->imod_interval);\n\t\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), DWC3_GEVNTCOUNT_EHB);\n\t} else if (dwc3_has_imod(dwc)) {\n\t\tdwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), 0);\n\t}\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);\n\tif (DWC3_IP_IS(DWC3))\n\t\treg &= ~DWC3_GRXTHRCFG_PKTCNTSEL;\n\telse\n\t\treg &= ~DWC31_GRXTHRCFG_PKTCNTSEL;\n\n\tdwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);\n\n\tdwc3_gadget_setup_nump(dwc);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg |= DWC3_DCFG_IGNSTRMPP;\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n\n\t \n\tif (DWC3_MST_CAPABLE(&dwc->hwparams)) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCFG1);\n\t\treg &= ~DWC3_DCFG1_DIS_MST_ENH;\n\t\tdwc3_writel(dwc->regs, DWC3_DCFG1, reg);\n\t}\n\n\t \n\tdwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\n\n\tdep = dwc->eps[0];\n\tdep->flags = 0;\n\tret = __dwc3_gadget_ep_enable(dep, DWC3_DEPCFG_ACTION_INIT);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to enable %s\\n\", dep->name);\n\t\tgoto err0;\n\t}\n\n\tdep = dwc->eps[1];\n\tdep->flags = 0;\n\tret = __dwc3_gadget_ep_enable(dep, DWC3_DEPCFG_ACTION_INIT);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to enable %s\\n\", dep->name);\n\t\tgoto err1;\n\t}\n\n\t \n\tdwc->ep0state = EP0_SETUP_PHASE;\n\tdwc->ep0_bounced = false;\n\tdwc->link_state = DWC3_LINK_STATE_SS_DIS;\n\tdwc->delayed_status = false;\n\tdwc3_ep0_out_start(dwc);\n\n\tdwc3_gadget_enable_irq(dwc);\n\n\treturn 0;\n\nerr1:\n\t__dwc3_gadget_ep_disable(dwc->eps[0]);\n\nerr0:\n\treturn ret;\n}\n\nstatic int dwc3_gadget_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\tint\t\t\tret;\n\tint\t\t\tirq;\n\n\tirq = dwc->irq_gadget;\n\tret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,\n\t\t\tIRQF_SHARED, \"dwc3\", dwc->ev_buf);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to request irq #%d --> %d\\n\",\n\t\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->gadget_driver\t= driver;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn 0;\n}\n\nstatic void __dwc3_gadget_stop(struct dwc3 *dwc)\n{\n\tdwc3_gadget_disable_irq(dwc);\n\t__dwc3_gadget_ep_disable(dwc->eps[0]);\n\t__dwc3_gadget_ep_disable(dwc->eps[1]);\n}\n\nstatic int dwc3_gadget_stop(struct usb_gadget *g)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->gadget_driver\t= NULL;\n\tdwc->max_cfg_eps = 0;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\tfree_irq(dwc->irq_gadget, dwc->ev_buf);\n\n\treturn 0;\n}\n\nstatic void dwc3_gadget_config_params(struct usb_gadget *g,\n\t\t\t\t      struct usb_dcd_config_params *params)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\n\tparams->besl_baseline = USB_DEFAULT_BESL_UNSPECIFIED;\n\tparams->besl_deep = USB_DEFAULT_BESL_UNSPECIFIED;\n\n\t \n\tif (!dwc->dis_enblslpm_quirk) {\n\t\t \n\t\tparams->besl_baseline = 1;\n\t\tif (dwc->is_utmi_l1_suspend)\n\t\t\tparams->besl_deep =\n\t\t\t\tclamp_t(u8, dwc->hird_threshold, 2, 15);\n\t}\n\n\t \n\tif (dwc->dis_u1_entry_quirk)\n\t\tparams->bU1devExitLat = 0;\n\telse\n\t\tparams->bU1devExitLat = DWC3_DEFAULT_U1_DEV_EXIT_LAT;\n\n\t \n\tif (dwc->dis_u2_entry_quirk)\n\t\tparams->bU2DevExitLat = 0;\n\telse\n\t\tparams->bU2DevExitLat =\n\t\t\t\tcpu_to_le16(DWC3_DEFAULT_U2_DEV_EXIT_LAT);\n}\n\nstatic void dwc3_gadget_set_speed(struct usb_gadget *g,\n\t\t\t\t  enum usb_device_speed speed)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->gadget_max_speed = speed;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n}\n\nstatic void dwc3_gadget_set_ssp_rate(struct usb_gadget *g,\n\t\t\t\t     enum usb_ssp_rate rate)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->gadget_max_speed = USB_SPEED_SUPER_PLUS;\n\tdwc->gadget_ssp_rate = rate;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n}\n\nstatic int dwc3_gadget_vbus_draw(struct usb_gadget *g, unsigned int mA)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunion power_supply_propval\tval = {0};\n\tint\t\t\t\tret;\n\n\tif (dwc->usb2_phy)\n\t\treturn usb_phy_set_power(dwc->usb2_phy, mA);\n\n\tif (!dwc->usb_psy)\n\t\treturn -EOPNOTSUPP;\n\n\tval.intval = 1000 * mA;\n\tret = power_supply_set_property(dwc->usb_psy, POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT, &val);\n\n\treturn ret;\n}\n\n \nstatic int dwc3_gadget_check_config(struct usb_gadget *g)\n{\n\tstruct dwc3 *dwc = gadget_to_dwc(g);\n\tstruct usb_ep *ep;\n\tint fifo_size = 0;\n\tint ram1_depth;\n\tint ep_num = 0;\n\n\tif (!dwc->do_fifo_resize)\n\t\treturn 0;\n\n\tlist_for_each_entry(ep, &g->ep_list, ep_list) {\n\t\t \n\t\tif (ep->claimed && (ep->address & USB_DIR_IN))\n\t\t\tep_num++;\n\t}\n\n\tif (ep_num <= dwc->max_cfg_eps)\n\t\treturn 0;\n\n\t \n\tdwc->max_cfg_eps = ep_num;\n\n\tfifo_size = dwc3_gadget_calc_tx_fifo_size(dwc, dwc->max_cfg_eps);\n\t \n\tfifo_size += dwc->max_cfg_eps;\n\n\t \n\tram1_depth = DWC3_RAM1_DEPTH(dwc->hwparams.hwparams7);\n\tif (fifo_size > ram1_depth)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void dwc3_gadget_async_callbacks(struct usb_gadget *g, bool enable)\n{\n\tstruct dwc3\t\t*dwc = gadget_to_dwc(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc->async_callbacks = enable;\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n}\n\nstatic const struct usb_gadget_ops dwc3_gadget_ops = {\n\t.get_frame\t\t= dwc3_gadget_get_frame,\n\t.wakeup\t\t\t= dwc3_gadget_wakeup,\n\t.func_wakeup\t\t= dwc3_gadget_func_wakeup,\n\t.set_remote_wakeup\t= dwc3_gadget_set_remote_wakeup,\n\t.set_selfpowered\t= dwc3_gadget_set_selfpowered,\n\t.pullup\t\t\t= dwc3_gadget_pullup,\n\t.udc_start\t\t= dwc3_gadget_start,\n\t.udc_stop\t\t= dwc3_gadget_stop,\n\t.udc_set_speed\t\t= dwc3_gadget_set_speed,\n\t.udc_set_ssp_rate\t= dwc3_gadget_set_ssp_rate,\n\t.get_config_params\t= dwc3_gadget_config_params,\n\t.vbus_draw\t\t= dwc3_gadget_vbus_draw,\n\t.check_config\t\t= dwc3_gadget_check_config,\n\t.udc_async_callbacks\t= dwc3_gadget_async_callbacks,\n};\n\n \n\nstatic int dwc3_gadget_init_control_endpoint(struct dwc3_ep *dep)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\n\tusb_ep_set_maxpacket_limit(&dep->endpoint, 512);\n\tdep->endpoint.maxburst = 1;\n\tdep->endpoint.ops = &dwc3_gadget_ep0_ops;\n\tif (!dep->direction)\n\t\tdwc->gadget->ep0 = &dep->endpoint;\n\n\tdep->endpoint.caps.type_control = true;\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_init_in_endpoint(struct dwc3_ep *dep)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\tu32 mdwidth;\n\tint size;\n\tint maxpacket;\n\n\tmdwidth = dwc3_mdwidth(dwc);\n\n\t \n\tmdwidth /= 8;\n\n\tsize = dwc3_readl(dwc->regs, DWC3_GTXFIFOSIZ(dep->number >> 1));\n\tif (DWC3_IP_IS(DWC3))\n\t\tsize = DWC3_GTXFIFOSIZ_TXFDEP(size);\n\telse\n\t\tsize = DWC31_GTXFIFOSIZ_TXFDEP(size);\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 290A))\n\t\tmaxpacket = mdwidth * (size - 1);\n\telse\n\t\tmaxpacket = mdwidth * ((size - 1) - 1) - mdwidth;\n\n\t \n\tsize = min_t(int, maxpacket, 1024);\n\tusb_ep_set_maxpacket_limit(&dep->endpoint, size);\n\n\tdep->endpoint.max_streams = 16;\n\tdep->endpoint.ops = &dwc3_gadget_ep_ops;\n\tlist_add_tail(&dep->endpoint.ep_list,\n\t\t\t&dwc->gadget->ep_list);\n\tdep->endpoint.caps.type_iso = true;\n\tdep->endpoint.caps.type_bulk = true;\n\tdep->endpoint.caps.type_int = true;\n\n\treturn dwc3_alloc_trb_pool(dep);\n}\n\nstatic int dwc3_gadget_init_out_endpoint(struct dwc3_ep *dep)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\tu32 mdwidth;\n\tint size;\n\n\tmdwidth = dwc3_mdwidth(dwc);\n\n\t \n\tmdwidth /= 8;\n\n\t \n\tsize = dwc3_readl(dwc->regs, DWC3_GRXFIFOSIZ(0));\n\tif (DWC3_IP_IS(DWC3))\n\t\tsize = DWC3_GRXFIFOSIZ_RXFDEP(size);\n\telse\n\t\tsize = DWC31_GRXFIFOSIZ_RXFDEP(size);\n\n\t \n\tsize *= mdwidth;\n\n\t \n\tsize -= (3 * 8) + 16;\n\tif (size < 0)\n\t\tsize = 0;\n\telse\n\t\tsize /= 3;\n\n\tusb_ep_set_maxpacket_limit(&dep->endpoint, size);\n\tdep->endpoint.max_streams = 16;\n\tdep->endpoint.ops = &dwc3_gadget_ep_ops;\n\tlist_add_tail(&dep->endpoint.ep_list,\n\t\t\t&dwc->gadget->ep_list);\n\tdep->endpoint.caps.type_iso = true;\n\tdep->endpoint.caps.type_bulk = true;\n\tdep->endpoint.caps.type_int = true;\n\n\treturn dwc3_alloc_trb_pool(dep);\n}\n\nstatic int dwc3_gadget_init_endpoint(struct dwc3 *dwc, u8 epnum)\n{\n\tstruct dwc3_ep\t\t\t*dep;\n\tbool\t\t\t\tdirection = epnum & 1;\n\tint\t\t\t\tret;\n\tu8\t\t\t\tnum = epnum >> 1;\n\n\tdep = kzalloc(sizeof(*dep), GFP_KERNEL);\n\tif (!dep)\n\t\treturn -ENOMEM;\n\n\tdep->dwc = dwc;\n\tdep->number = epnum;\n\tdep->direction = direction;\n\tdep->regs = dwc->regs + DWC3_DEP_BASE(epnum);\n\tdwc->eps[epnum] = dep;\n\tdep->combo_num = 0;\n\tdep->start_cmd_status = 0;\n\n\tsnprintf(dep->name, sizeof(dep->name), \"ep%u%s\", num,\n\t\t\tdirection ? \"in\" : \"out\");\n\n\tdep->endpoint.name = dep->name;\n\n\tif (!(dep->number > 1)) {\n\t\tdep->endpoint.desc = &dwc3_gadget_ep0_desc;\n\t\tdep->endpoint.comp_desc = NULL;\n\t}\n\n\tif (num == 0)\n\t\tret = dwc3_gadget_init_control_endpoint(dep);\n\telse if (direction)\n\t\tret = dwc3_gadget_init_in_endpoint(dep);\n\telse\n\t\tret = dwc3_gadget_init_out_endpoint(dep);\n\n\tif (ret)\n\t\treturn ret;\n\n\tdep->endpoint.caps.dir_in = direction;\n\tdep->endpoint.caps.dir_out = !direction;\n\n\tINIT_LIST_HEAD(&dep->pending_list);\n\tINIT_LIST_HEAD(&dep->started_list);\n\tINIT_LIST_HEAD(&dep->cancelled_list);\n\n\tdwc3_debugfs_create_endpoint_dir(dep);\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_init_endpoints(struct dwc3 *dwc, u8 total)\n{\n\tu8\t\t\t\tepnum;\n\n\tINIT_LIST_HEAD(&dwc->gadget->ep_list);\n\n\tfor (epnum = 0; epnum < total; epnum++) {\n\t\tint\t\t\tret;\n\n\t\tret = dwc3_gadget_init_endpoint(dwc, epnum);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc3_gadget_free_endpoints(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep\t\t\t*dep;\n\tu8\t\t\t\tepnum;\n\n\tfor (epnum = 0; epnum < DWC3_ENDPOINTS_NUM; epnum++) {\n\t\tdep = dwc->eps[epnum];\n\t\tif (!dep)\n\t\t\tcontinue;\n\t\t \n\t\tif (epnum != 0 && epnum != 1) {\n\t\t\tdwc3_free_trb_pool(dep);\n\t\t\tlist_del(&dep->endpoint.ep_list);\n\t\t}\n\n\t\tdwc3_debugfs_remove_endpoint_dir(dep);\n\t\tkfree(dep);\n\t}\n}\n\n \n\nstatic int dwc3_gadget_ep_reclaim_completed_trb(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, struct dwc3_trb *trb,\n\t\tconst struct dwc3_event_depevt *event, int status, int chain)\n{\n\tunsigned int\t\tcount;\n\n\tdwc3_ep_inc_deq(dep);\n\n\ttrace_dwc3_complete_trb(dep, trb);\n\treq->num_trbs--;\n\n\t \n\tif (chain && (trb->ctrl & DWC3_TRB_CTRL_HWO))\n\t\ttrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\n\n\t \n\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc) &&\n\t    (trb->ctrl & DWC3_TRBCTL_ISOCHRONOUS_FIRST)) {\n\t\tunsigned int frame_number;\n\n\t\tframe_number = DWC3_TRB_CTRL_GET_SID_SOFN(trb->ctrl);\n\t\tframe_number &= ~(dep->interval - 1);\n\t\treq->request.frame_number = frame_number;\n\t}\n\n\t \n\tif (trb->bpl == lower_32_bits(dep->dwc->bounce_addr) &&\n\t    trb->bph == upper_32_bits(dep->dwc->bounce_addr)) {\n\t\ttrb->ctrl &= ~DWC3_TRB_CTRL_HWO;\n\t\treturn 1;\n\t}\n\n\tcount = trb->size & DWC3_TRB_SIZE_MASK;\n\treq->remaining += count;\n\n\tif ((trb->ctrl & DWC3_TRB_CTRL_HWO) && status != -ESHUTDOWN)\n\t\treturn 1;\n\n\tif (event->status & DEPEVT_STATUS_SHORT && !chain)\n\t\treturn 1;\n\n\tif ((trb->ctrl & DWC3_TRB_CTRL_ISP_IMI) &&\n\t    DWC3_TRB_SIZE_TRBSTS(trb->size) == DWC3_TRBSTS_MISSED_ISOC)\n\t\treturn 1;\n\n\tif ((trb->ctrl & DWC3_TRB_CTRL_IOC) ||\n\t    (trb->ctrl & DWC3_TRB_CTRL_LST))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int dwc3_gadget_ep_reclaim_trb_sg(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, const struct dwc3_event_depevt *event,\n\t\tint status)\n{\n\tstruct dwc3_trb *trb = &dep->trb_pool[dep->trb_dequeue];\n\tstruct scatterlist *sg = req->sg;\n\tstruct scatterlist *s;\n\tunsigned int num_queued = req->num_queued_sgs;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor_each_sg(sg, s, num_queued, i) {\n\t\ttrb = &dep->trb_pool[dep->trb_dequeue];\n\n\t\treq->sg = sg_next(s);\n\t\treq->num_queued_sgs--;\n\n\t\tret = dwc3_gadget_ep_reclaim_completed_trb(dep, req,\n\t\t\t\ttrb, event, status, true);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int dwc3_gadget_ep_reclaim_trb_linear(struct dwc3_ep *dep,\n\t\tstruct dwc3_request *req, const struct dwc3_event_depevt *event,\n\t\tint status)\n{\n\tstruct dwc3_trb *trb = &dep->trb_pool[dep->trb_dequeue];\n\n\treturn dwc3_gadget_ep_reclaim_completed_trb(dep, req, trb,\n\t\t\tevent, status, false);\n}\n\nstatic bool dwc3_gadget_ep_request_completed(struct dwc3_request *req)\n{\n\treturn req->num_pending_sgs == 0 && req->num_queued_sgs == 0;\n}\n\nstatic int dwc3_gadget_ep_cleanup_completed_request(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event,\n\t\tstruct dwc3_request *req, int status)\n{\n\tint request_status;\n\tint ret;\n\n\tif (req->request.num_mapped_sgs)\n\t\tret = dwc3_gadget_ep_reclaim_trb_sg(dep, req, event,\n\t\t\t\tstatus);\n\telse\n\t\tret = dwc3_gadget_ep_reclaim_trb_linear(dep, req, event,\n\t\t\t\tstatus);\n\n\treq->request.actual = req->request.length - req->remaining;\n\n\tif (!dwc3_gadget_ep_request_completed(req))\n\t\tgoto out;\n\n\tif (req->needs_extra_trb) {\n\t\tret = dwc3_gadget_ep_reclaim_trb_linear(dep, req, event,\n\t\t\t\tstatus);\n\t\treq->needs_extra_trb = false;\n\t}\n\n\t \n\tif (req->request.no_interrupt) {\n\t\tstruct dwc3_trb *trb;\n\n\t\ttrb = dwc3_ep_prev_trb(dep, dep->trb_dequeue);\n\t\tswitch (DWC3_TRB_SIZE_TRBSTS(trb->size)) {\n\t\tcase DWC3_TRBSTS_MISSED_ISOC:\n\t\t\t \n\t\t\trequest_status = -EXDEV;\n\t\t\tbreak;\n\t\tcase DWC3_TRB_STS_XFER_IN_PROG:\n\t\t\t \n\t\tcase DWC3_TRBSTS_SETUP_PENDING:\n\t\t\t \n\t\tcase DWC3_TRBSTS_OK:\n\t\tdefault:\n\t\t\trequest_status = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trequest_status = status;\n\t}\n\n\tdwc3_gadget_giveback(dep, req, request_status);\n\nout:\n\treturn ret;\n}\n\nstatic void dwc3_gadget_ep_cleanup_completed_requests(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event, int status)\n{\n\tstruct dwc3_request\t*req;\n\n\twhile (!list_empty(&dep->started_list)) {\n\t\tint ret;\n\n\t\treq = next_request(&dep->started_list);\n\t\tret = dwc3_gadget_ep_cleanup_completed_request(dep, event,\n\t\t\t\treq, status);\n\t\tif (ret)\n\t\t\tbreak;\n\t\t \n\t\tif (!dep->endpoint.desc)\n\t\t\tbreak;\n\t}\n}\n\nstatic bool dwc3_gadget_ep_should_continue(struct dwc3_ep *dep)\n{\n\tstruct dwc3_request\t*req;\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\n\tif (!dep->endpoint.desc || !dwc->pullups_connected ||\n\t    !dwc->connected)\n\t\treturn false;\n\n\tif (!list_empty(&dep->pending_list))\n\t\treturn true;\n\n\t \n\treq = next_request(&dep->started_list);\n\tif (!req)\n\t\treturn false;\n\n\treturn !dwc3_gadget_ep_request_completed(req);\n}\n\nstatic void dwc3_gadget_endpoint_frame_from_event(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tdep->frame_number = event->parameters;\n}\n\nstatic bool dwc3_gadget_endpoint_trbs_complete(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event, int status)\n{\n\tstruct dwc3\t\t*dwc = dep->dwc;\n\tbool\t\t\tno_started_trb = true;\n\n\tdwc3_gadget_ep_cleanup_completed_requests(dep, event, status);\n\n\tif (dep->flags & DWC3_EP_END_TRANSFER_PENDING)\n\t\tgoto out;\n\n\tif (!dep->endpoint.desc)\n\t\treturn no_started_trb;\n\n\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc) &&\n\t\tlist_empty(&dep->started_list) &&\n\t\t(list_empty(&dep->pending_list) || status == -EXDEV))\n\t\tdwc3_stop_active_transfer(dep, true, true);\n\telse if (dwc3_gadget_ep_should_continue(dep))\n\t\tif (__dwc3_gadget_kick_transfer(dep) == 0)\n\t\t\tno_started_trb = false;\n\nout:\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 183A)) {\n\t\tu32\t\treg;\n\t\tint\t\ti;\n\n\t\tfor (i = 0; i < DWC3_ENDPOINTS_NUM; i++) {\n\t\t\tdep = dwc->eps[i];\n\n\t\t\tif (!(dep->flags & DWC3_EP_ENABLED))\n\t\t\t\tcontinue;\n\n\t\t\tif (!list_empty(&dep->started_list))\n\t\t\t\treturn no_started_trb;\n\t\t}\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\treg |= dwc->u1u2;\n\t\tdwc3_writel(dwc->regs, DWC3_DCTL, reg);\n\n\t\tdwc->u1u2 = 0;\n\t}\n\n\treturn no_started_trb;\n}\n\nstatic void dwc3_gadget_endpoint_transfer_in_progress(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tint status = 0;\n\n\tif (!dep->endpoint.desc)\n\t\treturn;\n\n\tif (usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\tdwc3_gadget_endpoint_frame_from_event(dep, event);\n\n\tif (event->status & DEPEVT_STATUS_BUSERR)\n\t\tstatus = -ECONNRESET;\n\n\tif (event->status & DEPEVT_STATUS_MISSED_ISOC)\n\t\tstatus = -EXDEV;\n\n\tdwc3_gadget_endpoint_trbs_complete(dep, event, status);\n}\n\nstatic void dwc3_gadget_endpoint_transfer_complete(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tint status = 0;\n\n\tdep->flags &= ~DWC3_EP_TRANSFER_STARTED;\n\n\tif (event->status & DEPEVT_STATUS_BUSERR)\n\t\tstatus = -ECONNRESET;\n\n\tif (dwc3_gadget_endpoint_trbs_complete(dep, event, status))\n\t\tdep->flags &= ~DWC3_EP_WAIT_TRANSFER_COMPLETE;\n}\n\nstatic void dwc3_gadget_endpoint_transfer_not_ready(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tdwc3_gadget_endpoint_frame_from_event(dep, event);\n\n\t \n\tif (dep->flags & DWC3_EP_END_TRANSFER_PENDING)\n\t\treturn;\n\n\t(void) __dwc3_gadget_start_isoc(dep);\n}\n\nstatic void dwc3_gadget_endpoint_command_complete(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tu8 cmd = DEPEVT_PARAMETER_CMD(event->parameters);\n\n\tif (cmd != DWC3_DEPCMD_ENDTRANSFER)\n\t\treturn;\n\n\t \n\tif (dep->stream_capable)\n\t\tdep->flags |= DWC3_EP_IGNORE_NEXT_NOSTREAM;\n\n\tdep->flags &= ~DWC3_EP_END_TRANSFER_PENDING;\n\tdep->flags &= ~DWC3_EP_TRANSFER_STARTED;\n\tdwc3_gadget_ep_cleanup_cancelled_requests(dep);\n\n\tif (dep->flags & DWC3_EP_PENDING_CLEAR_STALL) {\n\t\tstruct dwc3 *dwc = dep->dwc;\n\n\t\tdep->flags &= ~DWC3_EP_PENDING_CLEAR_STALL;\n\t\tif (dwc3_send_clear_stall_ep_cmd(dep)) {\n\t\t\tstruct usb_ep *ep0 = &dwc->eps[0]->endpoint;\n\n\t\t\tdev_err(dwc->dev, \"failed to clear STALL on %s\\n\", dep->name);\n\t\t\tif (dwc->delayed_status)\n\t\t\t\t__dwc3_gadget_ep0_set_halt(ep0, 1);\n\t\t\treturn;\n\t\t}\n\n\t\tdep->flags &= ~(DWC3_EP_STALL | DWC3_EP_WEDGE);\n\t\tif (dwc->clear_stall_protocol == dep->number)\n\t\t\tdwc3_ep0_send_delayed_status(dwc);\n\t}\n\n\tif ((dep->flags & DWC3_EP_DELAY_START) &&\n\t    !usb_endpoint_xfer_isoc(dep->endpoint.desc))\n\t\t__dwc3_gadget_kick_transfer(dep);\n\n\tdep->flags &= ~DWC3_EP_DELAY_START;\n}\n\nstatic void dwc3_gadget_endpoint_stream_event(struct dwc3_ep *dep,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\n\tif (event->status == DEPEVT_STREAMEVT_FOUND) {\n\t\tdep->flags |= DWC3_EP_FIRST_STREAM_PRIMED;\n\t\tgoto out;\n\t}\n\n\t \n\tswitch (event->parameters) {\n\tcase DEPEVT_STREAM_PRIME:\n\t\t \n\t\tif (dep->flags & DWC3_EP_FORCE_RESTART_STREAM) {\n\t\t\tif (dep->flags & DWC3_EP_FIRST_STREAM_PRIMED)\n\t\t\t\tdep->flags &= ~DWC3_EP_FORCE_RESTART_STREAM;\n\t\t\telse\n\t\t\t\tdep->flags |= DWC3_EP_FIRST_STREAM_PRIMED;\n\t\t}\n\n\t\tbreak;\n\tcase DEPEVT_STREAM_NOSTREAM:\n\t\tif ((dep->flags & DWC3_EP_IGNORE_NEXT_NOSTREAM) ||\n\t\t    !(dep->flags & DWC3_EP_FORCE_RESTART_STREAM) ||\n\t\t    (!DWC3_MST_CAPABLE(&dwc->hwparams) &&\n\t\t     !(dep->flags & DWC3_EP_WAIT_TRANSFER_COMPLETE)))\n\t\t\tbreak;\n\n\t\t \n\t\tif (DWC3_VER_IS_WITHIN(DWC32, 100A, ANY)) {\n\t\t\tunsigned int cmd = DWC3_DGCMD_SET_ENDPOINT_PRIME;\n\n\t\t\tdwc3_send_gadget_generic_command(dwc, cmd, dep->number);\n\t\t} else {\n\t\t\tdep->flags |= DWC3_EP_DELAY_START;\n\t\t\tdwc3_stop_active_transfer(dep, true, true);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tdep->flags &= ~DWC3_EP_IGNORE_NEXT_NOSTREAM;\n}\n\nstatic void dwc3_endpoint_interrupt(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_depevt *event)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tu8\t\t\tepnum = event->endpoint_number;\n\n\tdep = dwc->eps[epnum];\n\n\tif (!(dep->flags & DWC3_EP_ENABLED)) {\n\t\tif ((epnum > 1) && !(dep->flags & DWC3_EP_TRANSFER_STARTED))\n\t\t\treturn;\n\n\t\t \n\t\tif ((event->endpoint_event != DWC3_DEPEVT_EPCMDCMPLT) &&\n\t\t\t!(epnum <= 1 && event->endpoint_event == DWC3_DEPEVT_XFERCOMPLETE))\n\t\t\treturn;\n\t}\n\n\tif (epnum == 0 || epnum == 1) {\n\t\tdwc3_ep0_interrupt(dwc, event);\n\t\treturn;\n\t}\n\n\tswitch (event->endpoint_event) {\n\tcase DWC3_DEPEVT_XFERINPROGRESS:\n\t\tdwc3_gadget_endpoint_transfer_in_progress(dep, event);\n\t\tbreak;\n\tcase DWC3_DEPEVT_XFERNOTREADY:\n\t\tdwc3_gadget_endpoint_transfer_not_ready(dep, event);\n\t\tbreak;\n\tcase DWC3_DEPEVT_EPCMDCMPLT:\n\t\tdwc3_gadget_endpoint_command_complete(dep, event);\n\t\tbreak;\n\tcase DWC3_DEPEVT_XFERCOMPLETE:\n\t\tdwc3_gadget_endpoint_transfer_complete(dep, event);\n\t\tbreak;\n\tcase DWC3_DEPEVT_STREAMEVT:\n\t\tdwc3_gadget_endpoint_stream_event(dep, event);\n\t\tbreak;\n\tcase DWC3_DEPEVT_RXTXFIFOEVT:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dwc->dev, \"unknown endpoint event %d\\n\", event->endpoint_event);\n\t\tbreak;\n\t}\n}\n\nstatic void dwc3_disconnect_gadget(struct dwc3 *dwc)\n{\n\tif (dwc->async_callbacks && dwc->gadget_driver->disconnect) {\n\t\tspin_unlock(&dwc->lock);\n\t\tdwc->gadget_driver->disconnect(dwc->gadget);\n\t\tspin_lock(&dwc->lock);\n\t}\n}\n\nstatic void dwc3_suspend_gadget(struct dwc3 *dwc)\n{\n\tif (dwc->async_callbacks && dwc->gadget_driver->suspend) {\n\t\tspin_unlock(&dwc->lock);\n\t\tdwc->gadget_driver->suspend(dwc->gadget);\n\t\tspin_lock(&dwc->lock);\n\t}\n}\n\nstatic void dwc3_resume_gadget(struct dwc3 *dwc)\n{\n\tif (dwc->async_callbacks && dwc->gadget_driver->resume) {\n\t\tspin_unlock(&dwc->lock);\n\t\tdwc->gadget_driver->resume(dwc->gadget);\n\t\tspin_lock(&dwc->lock);\n\t}\n}\n\nstatic void dwc3_reset_gadget(struct dwc3 *dwc)\n{\n\tif (!dwc->gadget_driver)\n\t\treturn;\n\n\tif (dwc->async_callbacks && dwc->gadget->speed != USB_SPEED_UNKNOWN) {\n\t\tspin_unlock(&dwc->lock);\n\t\tusb_gadget_udc_reset(dwc->gadget, dwc->gadget_driver);\n\t\tspin_lock(&dwc->lock);\n\t}\n}\n\nvoid dwc3_stop_active_transfer(struct dwc3_ep *dep, bool force,\n\tbool interrupt)\n{\n\tstruct dwc3 *dwc = dep->dwc;\n\n\t \n\tif (dep->number <= 1 && dwc->ep0state != EP0_DATA_PHASE)\n\t\treturn;\n\n\tif (interrupt && (dep->flags & DWC3_EP_DELAY_STOP))\n\t\treturn;\n\n\tif (!(dep->flags & DWC3_EP_TRANSFER_STARTED) ||\n\t    (dep->flags & DWC3_EP_END_TRANSFER_PENDING))\n\t\treturn;\n\n\t \n\tif (dwc->ep0state != EP0_SETUP_PHASE && !dwc->delayed_status) {\n\t\tdep->flags |= DWC3_EP_DELAY_STOP;\n\t\treturn;\n\t}\n\n\t \n\n\t__dwc3_stop_active_transfer(dep, force, interrupt);\n}\n\nstatic void dwc3_clear_stall_all_ep(struct dwc3 *dwc)\n{\n\tu32 epnum;\n\n\tfor (epnum = 1; epnum < DWC3_ENDPOINTS_NUM; epnum++) {\n\t\tstruct dwc3_ep *dep;\n\t\tint ret;\n\n\t\tdep = dwc->eps[epnum];\n\t\tif (!dep)\n\t\t\tcontinue;\n\n\t\tif (!(dep->flags & DWC3_EP_STALL))\n\t\t\tcontinue;\n\n\t\tdep->flags &= ~DWC3_EP_STALL;\n\n\t\tret = dwc3_send_clear_stall_ep_cmd(dep);\n\t\tWARN_ON_ONCE(ret);\n\t}\n}\n\nstatic void dwc3_gadget_disconnect_interrupt(struct dwc3 *dwc)\n{\n\tint\t\t\treg;\n\n\tdwc->suspended = false;\n\n\tdwc3_gadget_set_link_state(dwc, DWC3_LINK_STATE_RX_DET);\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\treg &= ~DWC3_DCTL_INITU1ENA;\n\treg &= ~DWC3_DCTL_INITU2ENA;\n\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\n\tdwc->connected = false;\n\n\tdwc3_disconnect_gadget(dwc);\n\n\tdwc->gadget->speed = USB_SPEED_UNKNOWN;\n\tdwc->setup_packet_pending = false;\n\tdwc->gadget->wakeup_armed = false;\n\tdwc3_gadget_enable_linksts_evts(dwc, false);\n\tusb_gadget_set_state(dwc->gadget, USB_STATE_NOTATTACHED);\n\n\tdwc3_ep0_reset_state(dwc);\n\n\t \n\tpm_request_idle(dwc->dev);\n}\n\nstatic void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)\n{\n\tu32\t\t\treg;\n\n\tdwc->suspended = false;\n\n\t \n\tdwc->connected = false;\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 188A)) {\n\t\tif (dwc->setup_packet_pending)\n\t\t\tdwc3_gadget_disconnect_interrupt(dwc);\n\t}\n\n\tdwc3_reset_gadget(dwc);\n\n\t \n\tdwc3_ep0_reset_state(dwc);\n\n\t \n\tdwc3_stop_active_transfers(dwc);\n\tdwc->connected = true;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\treg &= ~DWC3_DCTL_TSTCTRL_MASK;\n\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\tdwc->test_mode = false;\n\tdwc->gadget->wakeup_armed = false;\n\tdwc3_gadget_enable_linksts_evts(dwc, false);\n\tdwc3_clear_stall_all_ep(dwc);\n\n\t \n\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\treg &= ~(DWC3_DCFG_DEVADDR_MASK);\n\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n}\n\nstatic void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)\n{\n\tstruct dwc3_ep\t\t*dep;\n\tint\t\t\tret;\n\tu32\t\t\treg;\n\tu8\t\t\tlanes = 1;\n\tu8\t\t\tspeed;\n\n\tif (!dwc->softconnect)\n\t\treturn;\n\n\treg = dwc3_readl(dwc->regs, DWC3_DSTS);\n\tspeed = reg & DWC3_DSTS_CONNECTSPD;\n\tdwc->speed = speed;\n\n\tif (DWC3_IP_IS(DWC32))\n\t\tlanes = DWC3_DSTS_CONNLANES(reg) + 1;\n\n\tdwc->gadget->ssp_rate = USB_SSP_GEN_UNKNOWN;\n\n\t \n\n\tswitch (speed) {\n\tcase DWC3_DSTS_SUPERSPEED_PLUS:\n\t\tdwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tdwc->gadget->ep0->maxpacket = 512;\n\t\tdwc->gadget->speed = USB_SPEED_SUPER_PLUS;\n\n\t\tif (lanes > 1)\n\t\t\tdwc->gadget->ssp_rate = USB_SSP_GEN_2x2;\n\t\telse\n\t\t\tdwc->gadget->ssp_rate = USB_SSP_GEN_2x1;\n\t\tbreak;\n\tcase DWC3_DSTS_SUPERSPEED:\n\t\t \n\t\tif (DWC3_VER_IS_PRIOR(DWC3, 190A))\n\t\t\tdwc3_gadget_reset_interrupt(dwc);\n\n\t\tdwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tdwc->gadget->ep0->maxpacket = 512;\n\t\tdwc->gadget->speed = USB_SPEED_SUPER;\n\n\t\tif (lanes > 1) {\n\t\t\tdwc->gadget->speed = USB_SPEED_SUPER_PLUS;\n\t\t\tdwc->gadget->ssp_rate = USB_SSP_GEN_1x2;\n\t\t}\n\t\tbreak;\n\tcase DWC3_DSTS_HIGHSPEED:\n\t\tdwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tdwc->gadget->ep0->maxpacket = 64;\n\t\tdwc->gadget->speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase DWC3_DSTS_FULLSPEED:\n\t\tdwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tdwc->gadget->ep0->maxpacket = 64;\n\t\tdwc->gadget->speed = USB_SPEED_FULL;\n\t\tbreak;\n\t}\n\n\tdwc->eps[1]->endpoint.maxpacket = dwc->gadget->ep0->maxpacket;\n\n\t \n\n\tif (!DWC3_VER_IS_WITHIN(DWC3, ANY, 194A) &&\n\t    !dwc->usb2_gadget_lpm_disable &&\n\t    (speed != DWC3_DSTS_SUPERSPEED) &&\n\t    (speed != DWC3_DSTS_SUPERSPEED_PLUS)) {\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\t\treg |= DWC3_DCFG_LPM_CAP;\n\t\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\treg &= ~(DWC3_DCTL_HIRD_THRES_MASK | DWC3_DCTL_L1_HIBER_EN);\n\n\t\treg |= DWC3_DCTL_HIRD_THRES(dwc->hird_threshold |\n\t\t\t\t\t    (dwc->is_utmi_l1_suspend << 4));\n\n\t\t \n\t\tWARN_ONCE(DWC3_VER_IS_PRIOR(DWC3, 240A) && dwc->has_lpm_erratum,\n\t\t\t\t\"LPM Erratum not available on dwc3 revisions < 2.40a\\n\");\n\n\t\tif (dwc->has_lpm_erratum && !DWC3_VER_IS_PRIOR(DWC3, 240A))\n\t\t\treg |= DWC3_DCTL_NYET_THRES(dwc->lpm_nyet_threshold);\n\n\t\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\t} else {\n\t\tif (dwc->usb2_gadget_lpm_disable) {\n\t\t\treg = dwc3_readl(dwc->regs, DWC3_DCFG);\n\t\t\treg &= ~DWC3_DCFG_LPM_CAP;\n\t\t\tdwc3_writel(dwc->regs, DWC3_DCFG, reg);\n\t\t}\n\n\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\treg &= ~DWC3_DCTL_HIRD_THRES_MASK;\n\t\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\t}\n\n\tdep = dwc->eps[0];\n\tret = __dwc3_gadget_ep_enable(dep, DWC3_DEPCFG_ACTION_MODIFY);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to enable %s\\n\", dep->name);\n\t\treturn;\n\t}\n\n\tdep = dwc->eps[1];\n\tret = __dwc3_gadget_ep_enable(dep, DWC3_DEPCFG_ACTION_MODIFY);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to enable %s\\n\", dep->name);\n\t\treturn;\n\t}\n\n\t \n}\n\nstatic void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc, unsigned int evtinfo)\n{\n\tdwc->suspended = false;\n\n\t \n\n\tif (dwc->async_callbacks && dwc->gadget_driver->resume) {\n\t\tspin_unlock(&dwc->lock);\n\t\tdwc->gadget_driver->resume(dwc->gadget);\n\t\tspin_lock(&dwc->lock);\n\t}\n\n\tdwc->link_state = evtinfo & DWC3_LINK_STATE_MASK;\n}\n\nstatic void dwc3_gadget_linksts_change_interrupt(struct dwc3 *dwc,\n\t\tunsigned int evtinfo)\n{\n\tenum dwc3_link_state\tnext = evtinfo & DWC3_LINK_STATE_MASK;\n\tunsigned int\t\tpwropt;\n\n\t \n\tpwropt = DWC3_GHWPARAMS1_EN_PWROPT(dwc->hwparams.hwparams1);\n\tif (DWC3_VER_IS_PRIOR(DWC3, 250A) &&\n\t\t\t(pwropt != DWC3_GHWPARAMS1_EN_PWROPT_HIB)) {\n\t\tif ((dwc->link_state == DWC3_LINK_STATE_U3) &&\n\t\t\t\t(next == DWC3_LINK_STATE_RESUME)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 183A)) {\n\t\tif (next == DWC3_LINK_STATE_U0) {\n\t\t\tu32\tu1u2;\n\t\t\tu32\treg;\n\n\t\t\tswitch (dwc->link_state) {\n\t\t\tcase DWC3_LINK_STATE_U1:\n\t\t\tcase DWC3_LINK_STATE_U2:\n\t\t\t\treg = dwc3_readl(dwc->regs, DWC3_DCTL);\n\t\t\t\tu1u2 = reg & (DWC3_DCTL_INITU2ENA\n\t\t\t\t\t\t| DWC3_DCTL_ACCEPTU2ENA\n\t\t\t\t\t\t| DWC3_DCTL_INITU1ENA\n\t\t\t\t\t\t| DWC3_DCTL_ACCEPTU1ENA);\n\n\t\t\t\tif (!dwc->u1u2)\n\t\t\t\t\tdwc->u1u2 = reg & u1u2;\n\n\t\t\t\treg &= ~u1u2;\n\n\t\t\t\tdwc3_gadget_dctl_write_safe(dwc, reg);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (next) {\n\tcase DWC3_LINK_STATE_U0:\n\t\tif (dwc->gadget->wakeup_armed) {\n\t\t\tdwc3_gadget_enable_linksts_evts(dwc, false);\n\t\t\tdwc3_resume_gadget(dwc);\n\t\t\tdwc->suspended = false;\n\t\t}\n\t\tbreak;\n\tcase DWC3_LINK_STATE_U1:\n\t\tif (dwc->speed == USB_SPEED_SUPER)\n\t\t\tdwc3_suspend_gadget(dwc);\n\t\tbreak;\n\tcase DWC3_LINK_STATE_U2:\n\tcase DWC3_LINK_STATE_U3:\n\t\tdwc3_suspend_gadget(dwc);\n\t\tbreak;\n\tcase DWC3_LINK_STATE_RESUME:\n\t\tdwc3_resume_gadget(dwc);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tdwc->link_state = next;\n}\n\nstatic void dwc3_gadget_suspend_interrupt(struct dwc3 *dwc,\n\t\t\t\t\t  unsigned int evtinfo)\n{\n\tenum dwc3_link_state next = evtinfo & DWC3_LINK_STATE_MASK;\n\n\tif (!dwc->suspended && next == DWC3_LINK_STATE_U3) {\n\t\tdwc->suspended = true;\n\t\tdwc3_suspend_gadget(dwc);\n\t}\n\n\tdwc->link_state = next;\n}\n\nstatic void dwc3_gadget_interrupt(struct dwc3 *dwc,\n\t\tconst struct dwc3_event_devt *event)\n{\n\tswitch (event->type) {\n\tcase DWC3_DEVICE_EVENT_DISCONNECT:\n\t\tdwc3_gadget_disconnect_interrupt(dwc);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_RESET:\n\t\tdwc3_gadget_reset_interrupt(dwc);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_CONNECT_DONE:\n\t\tdwc3_gadget_conndone_interrupt(dwc);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_WAKEUP:\n\t\tdwc3_gadget_wakeup_interrupt(dwc, event->event_info);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_HIBER_REQ:\n\t\tdev_WARN_ONCE(dwc->dev, true, \"unexpected hibernation event\\n\");\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:\n\t\tdwc3_gadget_linksts_change_interrupt(dwc, event->event_info);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_SUSPEND:\n\t\t \n\t\tif (!DWC3_VER_IS_PRIOR(DWC3, 230A))\n\t\t\tdwc3_gadget_suspend_interrupt(dwc, event->event_info);\n\t\tbreak;\n\tcase DWC3_DEVICE_EVENT_SOF:\n\tcase DWC3_DEVICE_EVENT_ERRATIC_ERROR:\n\tcase DWC3_DEVICE_EVENT_CMD_CMPL:\n\tcase DWC3_DEVICE_EVENT_OVERFLOW:\n\t\tbreak;\n\tdefault:\n\t\tdev_WARN(dwc->dev, \"UNKNOWN IRQ %d\\n\", event->type);\n\t}\n}\n\nstatic void dwc3_process_event_entry(struct dwc3 *dwc,\n\t\tconst union dwc3_event *event)\n{\n\ttrace_dwc3_event(event->raw, dwc);\n\n\tif (!event->type.is_devspec)\n\t\tdwc3_endpoint_interrupt(dwc, &event->depevt);\n\telse if (event->type.type == DWC3_EVENT_TYPE_DEV)\n\t\tdwc3_gadget_interrupt(dwc, &event->devt);\n\telse\n\t\tdev_err(dwc->dev, \"UNKNOWN IRQ type %d\\n\", event->raw);\n}\n\nstatic irqreturn_t dwc3_process_event_buf(struct dwc3_event_buffer *evt)\n{\n\tstruct dwc3 *dwc = evt->dwc;\n\tirqreturn_t ret = IRQ_NONE;\n\tint left;\n\n\tleft = evt->count;\n\n\tif (!(evt->flags & DWC3_EVENT_PENDING))\n\t\treturn IRQ_NONE;\n\n\twhile (left > 0) {\n\t\tunion dwc3_event event;\n\n\t\tevent.raw = *(u32 *) (evt->cache + evt->lpos);\n\n\t\tdwc3_process_event_entry(dwc, &event);\n\n\t\t \n\t\tevt->lpos = (evt->lpos + 4) % evt->length;\n\t\tleft -= 4;\n\t}\n\n\tevt->count = 0;\n\tret = IRQ_HANDLED;\n\n\t \n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0),\n\t\t    DWC3_GEVNTSIZ_SIZE(evt->length));\n\n\tif (dwc->imod_interval) {\n\t\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), DWC3_GEVNTCOUNT_EHB);\n\t\tdwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), dwc->imod_interval);\n\t}\n\n\t \n\tevt->flags &= ~DWC3_EVENT_PENDING;\n\n\treturn ret;\n}\n\nstatic irqreturn_t dwc3_thread_interrupt(int irq, void *_evt)\n{\n\tstruct dwc3_event_buffer *evt = _evt;\n\tstruct dwc3 *dwc = evt->dwc;\n\tunsigned long flags;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tlocal_bh_disable();\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tret = dwc3_process_event_buf(evt);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\tlocal_bh_enable();\n\n\treturn ret;\n}\n\nstatic irqreturn_t dwc3_check_event_buf(struct dwc3_event_buffer *evt)\n{\n\tstruct dwc3 *dwc = evt->dwc;\n\tu32 amount;\n\tu32 count;\n\n\tif (pm_runtime_suspended(dwc->dev)) {\n\t\tdwc->pending_events = true;\n\t\t \n\t\tpm_runtime_get(dwc->dev);\n\t\tdisable_irq_nosync(dwc->irq_gadget);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (evt->flags & DWC3_EVENT_PENDING)\n\t\treturn IRQ_HANDLED;\n\n\tcount = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(0));\n\tcount &= DWC3_GEVNTCOUNT_MASK;\n\tif (!count)\n\t\treturn IRQ_NONE;\n\n\tevt->count = count;\n\tevt->flags |= DWC3_EVENT_PENDING;\n\n\t \n\tdwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0),\n\t\t    DWC3_GEVNTSIZ_INTMASK | DWC3_GEVNTSIZ_SIZE(evt->length));\n\n\tamount = min(count, evt->length - evt->lpos);\n\tmemcpy(evt->cache + evt->lpos, evt->buf + evt->lpos, amount);\n\n\tif (amount < count)\n\t\tmemcpy(evt->cache, evt->buf, count - amount);\n\n\tdwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), count);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t dwc3_interrupt(int irq, void *_evt)\n{\n\tstruct dwc3_event_buffer\t*evt = _evt;\n\n\treturn dwc3_check_event_buf(evt);\n}\n\nstatic int dwc3_gadget_get_irq(struct dwc3 *dwc)\n{\n\tstruct platform_device *dwc3_pdev = to_platform_device(dwc->dev);\n\tint irq;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"peripheral\");\n\tif (irq > 0)\n\t\tgoto out;\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq_byname_optional(dwc3_pdev, \"dwc_usb3\");\n\tif (irq > 0)\n\t\tgoto out;\n\n\tif (irq == -EPROBE_DEFER)\n\t\tgoto out;\n\n\tirq = platform_get_irq(dwc3_pdev, 0);\n\nout:\n\treturn irq;\n}\n\nstatic void dwc_gadget_release(struct device *dev)\n{\n\tstruct usb_gadget *gadget = container_of(dev, struct usb_gadget, dev);\n\n\tkfree(gadget);\n}\n\n \nint dwc3_gadget_init(struct dwc3 *dwc)\n{\n\tint ret;\n\tint irq;\n\tstruct device *dev;\n\n\tirq = dwc3_gadget_get_irq(dwc);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err0;\n\t}\n\n\tdwc->irq_gadget = irq;\n\n\tdwc->ep0_trb = dma_alloc_coherent(dwc->sysdev,\n\t\t\t\t\t  sizeof(*dwc->ep0_trb) * 2,\n\t\t\t\t\t  &dwc->ep0_trb_addr, GFP_KERNEL);\n\tif (!dwc->ep0_trb) {\n\t\tdev_err(dwc->dev, \"failed to allocate ep0 trb\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tdwc->setup_buf = kzalloc(DWC3_EP0_SETUP_SIZE, GFP_KERNEL);\n\tif (!dwc->setup_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tdwc->bounce = dma_alloc_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE,\n\t\t\t&dwc->bounce_addr, GFP_KERNEL);\n\tif (!dwc->bounce) {\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tinit_completion(&dwc->ep0_in_setup);\n\tdwc->gadget = kzalloc(sizeof(struct usb_gadget), GFP_KERNEL);\n\tif (!dwc->gadget) {\n\t\tret = -ENOMEM;\n\t\tgoto err3;\n\t}\n\n\n\tusb_initialize_gadget(dwc->dev, dwc->gadget, dwc_gadget_release);\n\tdev\t\t\t\t= &dwc->gadget->dev;\n\tdev->platform_data\t\t= dwc;\n\tdwc->gadget->ops\t\t= &dwc3_gadget_ops;\n\tdwc->gadget->speed\t\t= USB_SPEED_UNKNOWN;\n\tdwc->gadget->ssp_rate\t\t= USB_SSP_GEN_UNKNOWN;\n\tdwc->gadget->sg_supported\t= true;\n\tdwc->gadget->name\t\t= \"dwc3-gadget\";\n\tdwc->gadget->lpm_capable\t= !dwc->usb2_gadget_lpm_disable;\n\tdwc->gadget->wakeup_capable\t= true;\n\n\t \n\tif (DWC3_VER_IS_PRIOR(DWC3, 220A) &&\n\t    !dwc->dis_metastability_quirk)\n\t\tdev_info(dwc->dev, \"changing max_speed on rev %08x\\n\",\n\t\t\t\tdwc->revision);\n\n\tdwc->gadget->max_speed\t\t= dwc->maximum_speed;\n\tdwc->gadget->max_ssp_rate\t= dwc->max_ssp_rate;\n\n\t \n\n\tret = dwc3_gadget_init_endpoints(dwc, dwc->num_eps);\n\tif (ret)\n\t\tgoto err4;\n\n\tret = usb_add_gadget(dwc->gadget);\n\tif (ret) {\n\t\tdev_err(dwc->dev, \"failed to add gadget\\n\");\n\t\tgoto err5;\n\t}\n\n\tif (DWC3_IP_IS(DWC32) && dwc->maximum_speed == USB_SPEED_SUPER_PLUS)\n\t\tdwc3_gadget_set_ssp_rate(dwc->gadget, dwc->max_ssp_rate);\n\telse\n\t\tdwc3_gadget_set_speed(dwc->gadget, dwc->maximum_speed);\n\n\treturn 0;\n\nerr5:\n\tdwc3_gadget_free_endpoints(dwc);\nerr4:\n\tusb_put_gadget(dwc->gadget);\n\tdwc->gadget = NULL;\nerr3:\n\tdma_free_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE, dwc->bounce,\n\t\t\tdwc->bounce_addr);\n\nerr2:\n\tkfree(dwc->setup_buf);\n\nerr1:\n\tdma_free_coherent(dwc->sysdev, sizeof(*dwc->ep0_trb) * 2,\n\t\t\tdwc->ep0_trb, dwc->ep0_trb_addr);\n\nerr0:\n\treturn ret;\n}\n\n \n\nvoid dwc3_gadget_exit(struct dwc3 *dwc)\n{\n\tif (!dwc->gadget)\n\t\treturn;\n\n\tusb_del_gadget(dwc->gadget);\n\tdwc3_gadget_free_endpoints(dwc);\n\tusb_put_gadget(dwc->gadget);\n\tdma_free_coherent(dwc->sysdev, DWC3_BOUNCE_SIZE, dwc->bounce,\n\t\t\t  dwc->bounce_addr);\n\tkfree(dwc->setup_buf);\n\tdma_free_coherent(dwc->sysdev, sizeof(*dwc->ep0_trb) * 2,\n\t\t\t  dwc->ep0_trb, dwc->ep0_trb_addr);\n}\n\nint dwc3_gadget_suspend(struct dwc3 *dwc)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (!dwc->gadget_driver)\n\t\treturn 0;\n\n\tret = dwc3_gadget_soft_disconnect(dwc);\n\tif (ret)\n\t\tgoto err;\n\n\tspin_lock_irqsave(&dwc->lock, flags);\n\tdwc3_disconnect_gadget(dwc);\n\tspin_unlock_irqrestore(&dwc->lock, flags);\n\n\treturn 0;\n\nerr:\n\t \n\tif (dwc->softconnect)\n\t\tdwc3_gadget_soft_connect(dwc);\n\n\treturn ret;\n}\n\nint dwc3_gadget_resume(struct dwc3 *dwc)\n{\n\tif (!dwc->gadget_driver || !dwc->softconnect)\n\t\treturn 0;\n\n\treturn dwc3_gadget_soft_connect(dwc);\n}\n\nvoid dwc3_gadget_process_pending_events(struct dwc3 *dwc)\n{\n\tif (dwc->pending_events) {\n\t\tdwc3_interrupt(dwc->irq_gadget, dwc->ev_buf);\n\t\tdwc3_thread_interrupt(dwc->irq_gadget, dwc->ev_buf);\n\t\tpm_runtime_put(dwc->dev);\n\t\tdwc->pending_events = false;\n\t\tenable_irq(dwc->irq_gadget);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}