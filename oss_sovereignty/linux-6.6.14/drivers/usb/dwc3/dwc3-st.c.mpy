{
  "module_name": "dwc3-st.c",
  "hash_id": "2999e2b81e5485c98166ba3d780b27d3fc21322d71affd54d4dbed34f2cac6be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-st.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/usb/of.h>\n\n#include \"core.h\"\n#include \"io.h\"\n\n \n#define CLKRST_CTRL\t\t0x00\n#define AUX_CLK_EN\t\tBIT(0)\n#define SW_PIPEW_RESET_N\tBIT(4)\n#define EXT_CFG_RESET_N\t\tBIT(8)\n \n#define XHCI_REVISION\t\tBIT(12)\n\n#define USB2_VBUS_MNGMNT_SEL1\t0x2C\n \n#define USB2_VBUS_REG30\t\t0x0\n#define USB2_VBUS_UTMIOTG\t0x1\n#define USB2_VBUS_PIPEW\t\t0x2\n#define USB2_VBUS_ZERO\t\t0x3\n\n#define SEL_OVERRIDE_VBUSVALID(n)\t(n << 0)\n#define SEL_OVERRIDE_POWERPRESENT(n)\t(n << 4)\n#define SEL_OVERRIDE_BVALID(n)\t\t(n << 8)\n\n \n#define USB3_CONTROL_MASK\t\t0xf77\n\n#define USB3_DEVICE_NOT_HOST\t\tBIT(0)\n#define USB3_FORCE_VBUSVALID\t\tBIT(1)\n#define USB3_DELAY_VBUSVALID\t\tBIT(2)\n#define USB3_SEL_FORCE_OPMODE\t\tBIT(4)\n#define USB3_FORCE_OPMODE(n)\t\t(n << 5)\n#define USB3_SEL_FORCE_DPPULLDOWN2\tBIT(8)\n#define USB3_FORCE_DPPULLDOWN2\t\tBIT(9)\n#define USB3_SEL_FORCE_DMPULLDOWN2\tBIT(10)\n#define USB3_FORCE_DMPULLDOWN2\t\tBIT(11)\n\n \n\nstruct st_dwc3 {\n\tstruct device *dev;\n\tvoid __iomem *glue_base;\n\tstruct regmap *regmap;\n\tint syscfg_reg_off;\n\tenum usb_dr_mode dr_mode;\n\tstruct reset_control *rstc_pwrdn;\n\tstruct reset_control *rstc_rst;\n};\n\nstatic inline u32 st_dwc3_readl(void __iomem *base, u32 offset)\n{\n\treturn readl_relaxed(base + offset);\n}\n\nstatic inline void st_dwc3_writel(void __iomem *base, u32 offset, u32 value)\n{\n\twritel_relaxed(value, base + offset);\n}\n\n \nstatic int st_dwc3_drd_init(struct st_dwc3 *dwc3_data)\n{\n\tu32 val;\n\tint err;\n\n\terr = regmap_read(dwc3_data->regmap, dwc3_data->syscfg_reg_off, &val);\n\tif (err)\n\t\treturn err;\n\n\tval &= USB3_CONTROL_MASK;\n\n\tswitch (dwc3_data->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\n\t\tval &= ~(USB3_DELAY_VBUSVALID\n\t\t\t| USB3_SEL_FORCE_OPMODE | USB3_FORCE_OPMODE(0x3)\n\t\t\t| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2\n\t\t\t| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);\n\n\t\t \n\n\t\tval |= USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID;\n\t\tbreak;\n\n\tcase USB_DR_MODE_HOST:\n\n\t\tval &= ~(USB3_DEVICE_NOT_HOST | USB3_FORCE_VBUSVALID\n\t\t\t| USB3_SEL_FORCE_OPMODE\t| USB3_FORCE_OPMODE(0x3)\n\t\t\t| USB3_SEL_FORCE_DPPULLDOWN2 | USB3_FORCE_DPPULLDOWN2\n\t\t\t| USB3_SEL_FORCE_DMPULLDOWN2 | USB3_FORCE_DMPULLDOWN2);\n\n\t\t \n\n\t\tval |= USB3_DELAY_VBUSVALID;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dwc3_data->dev, \"Unsupported mode of operation %d\\n\",\n\t\t\tdwc3_data->dr_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(dwc3_data->regmap, dwc3_data->syscfg_reg_off, val);\n}\n\n \nstatic void st_dwc3_init(struct st_dwc3 *dwc3_data)\n{\n\tu32 reg = st_dwc3_readl(dwc3_data->glue_base, CLKRST_CTRL);\n\n\treg |= AUX_CLK_EN | EXT_CFG_RESET_N | XHCI_REVISION;\n\treg &= ~SW_PIPEW_RESET_N;\n\tst_dwc3_writel(dwc3_data->glue_base, CLKRST_CTRL, reg);\n\n\t \n\treg = st_dwc3_readl(dwc3_data->glue_base, USB2_VBUS_MNGMNT_SEL1);\n\n\treg |= SEL_OVERRIDE_VBUSVALID(USB2_VBUS_UTMIOTG) |\n\t\tSEL_OVERRIDE_POWERPRESENT(USB2_VBUS_UTMIOTG) |\n\t\tSEL_OVERRIDE_BVALID(USB2_VBUS_UTMIOTG);\n\n\tst_dwc3_writel(dwc3_data->glue_base, USB2_VBUS_MNGMNT_SEL1, reg);\n\n\treg = st_dwc3_readl(dwc3_data->glue_base, CLKRST_CTRL);\n\treg |= SW_PIPEW_RESET_N;\n\tst_dwc3_writel(dwc3_data->glue_base, CLKRST_CTRL, reg);\n}\n\nstatic int st_dwc3_probe(struct platform_device *pdev)\n{\n\tstruct st_dwc3 *dwc3_data;\n\tstruct resource *res;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node, *child;\n\tstruct platform_device *child_pdev;\n\tstruct regmap *regmap;\n\tint ret;\n\n\tdwc3_data = devm_kzalloc(dev, sizeof(*dwc3_data), GFP_KERNEL);\n\tif (!dwc3_data)\n\t\treturn -ENOMEM;\n\n\tdwc3_data->glue_base =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"reg-glue\");\n\tif (IS_ERR(dwc3_data->glue_base))\n\t\treturn PTR_ERR(dwc3_data->glue_base);\n\n\tregmap = syscon_regmap_lookup_by_phandle(node, \"st,syscfg\");\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tdwc3_data->dev = dev;\n\tdwc3_data->regmap = regmap;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"syscfg-reg\");\n\tif (!res) {\n\t\tret = -ENXIO;\n\t\tgoto undo_platform_dev_alloc;\n\t}\n\n\tdwc3_data->syscfg_reg_off = res->start;\n\n\tdev_vdbg(&pdev->dev, \"glue-logic addr 0x%pK, syscfg-reg offset 0x%x\\n\",\n\t\t dwc3_data->glue_base, dwc3_data->syscfg_reg_off);\n\n\tdwc3_data->rstc_pwrdn =\n\t\tdevm_reset_control_get_exclusive(dev, \"powerdown\");\n\tif (IS_ERR(dwc3_data->rstc_pwrdn)) {\n\t\tdev_err(&pdev->dev, \"could not get power controller\\n\");\n\t\tret = PTR_ERR(dwc3_data->rstc_pwrdn);\n\t\tgoto undo_platform_dev_alloc;\n\t}\n\n\t \n\treset_control_deassert(dwc3_data->rstc_pwrdn);\n\n\tdwc3_data->rstc_rst =\n\t\tdevm_reset_control_get_shared(dev, \"softreset\");\n\tif (IS_ERR(dwc3_data->rstc_rst)) {\n\t\tdev_err(&pdev->dev, \"could not get reset controller\\n\");\n\t\tret = PTR_ERR(dwc3_data->rstc_rst);\n\t\tgoto undo_powerdown;\n\t}\n\n\t \n\treset_control_deassert(dwc3_data->rstc_rst);\n\n\tchild = of_get_compatible_child(node, \"snps,dwc3\");\n\tif (!child) {\n\t\tdev_err(&pdev->dev, \"failed to find dwc3 core node\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_node_put;\n\t}\n\n\t \n\tret = of_platform_populate(node, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add dwc3 core\\n\");\n\t\tgoto err_node_put;\n\t}\n\n\tchild_pdev = of_find_device_by_node(child);\n\tif (!child_pdev) {\n\t\tdev_err(dev, \"failed to find dwc3 core device\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_node_put;\n\t}\n\n\tdwc3_data->dr_mode = usb_get_dr_mode(&child_pdev->dev);\n\tof_node_put(child);\n\tplatform_device_put(child_pdev);\n\n\t \n\tret = st_dwc3_drd_init(dwc3_data);\n\tif (ret) {\n\t\tdev_err(dev, \"drd initialisation failed\\n\");\n\t\tgoto undo_softreset;\n\t}\n\n\t \n\tst_dwc3_init(dwc3_data);\n\n\tplatform_set_drvdata(pdev, dwc3_data);\n\treturn 0;\n\nerr_node_put:\n\tof_node_put(child);\nundo_softreset:\n\treset_control_assert(dwc3_data->rstc_rst);\nundo_powerdown:\n\treset_control_assert(dwc3_data->rstc_pwrdn);\nundo_platform_dev_alloc:\n\tplatform_device_put(pdev);\n\treturn ret;\n}\n\nstatic void st_dwc3_remove(struct platform_device *pdev)\n{\n\tstruct st_dwc3 *dwc3_data = platform_get_drvdata(pdev);\n\n\tof_platform_depopulate(&pdev->dev);\n\n\treset_control_assert(dwc3_data->rstc_pwrdn);\n\treset_control_assert(dwc3_data->rstc_rst);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int st_dwc3_suspend(struct device *dev)\n{\n\tstruct st_dwc3 *dwc3_data = dev_get_drvdata(dev);\n\n\treset_control_assert(dwc3_data->rstc_pwrdn);\n\treset_control_assert(dwc3_data->rstc_rst);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int st_dwc3_resume(struct device *dev)\n{\n\tstruct st_dwc3 *dwc3_data = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\treset_control_deassert(dwc3_data->rstc_pwrdn);\n\treset_control_deassert(dwc3_data->rstc_rst);\n\n\tret = st_dwc3_drd_init(dwc3_data);\n\tif (ret) {\n\t\tdev_err(dev, \"drd initialisation failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tst_dwc3_init(dwc3_data);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(st_dwc3_dev_pm_ops, st_dwc3_suspend, st_dwc3_resume);\n\nstatic const struct of_device_id st_dwc3_match[] = {\n\t{ .compatible = \"st,stih407-dwc3\" },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(of, st_dwc3_match);\n\nstatic struct platform_driver st_dwc3_driver = {\n\t.probe = st_dwc3_probe,\n\t.remove_new = st_dwc3_remove,\n\t.driver = {\n\t\t.name = \"usb-st-dwc3\",\n\t\t.of_match_table = st_dwc3_match,\n\t\t.pm = &st_dwc3_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(st_dwc3_driver);\n\nMODULE_AUTHOR(\"Giuseppe Cavallaro <peppe.cavallaro@st.com>\");\nMODULE_DESCRIPTION(\"DesignWare USB3 STi Glue Layer\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}