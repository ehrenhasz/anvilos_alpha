{
  "module_name": "dwc3-of-simple.c",
  "hash_id": "37ba6646ecd5d70c52564593352b16a65fbe4389431e5ccd9e822048f7709ad4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc3/dwc3-of-simple.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\nstruct dwc3_of_simple {\n\tstruct device\t\t*dev;\n\tstruct clk_bulk_data\t*clks;\n\tint\t\t\tnum_clocks;\n\tstruct reset_control\t*resets;\n\tbool\t\t\tneed_reset;\n};\n\nstatic int dwc3_of_simple_probe(struct platform_device *pdev)\n{\n\tstruct dwc3_of_simple\t*simple;\n\tstruct device\t\t*dev = &pdev->dev;\n\tstruct device_node\t*np = dev->of_node;\n\n\tint\t\t\tret;\n\n\tsimple = devm_kzalloc(dev, sizeof(*simple), GFP_KERNEL);\n\tif (!simple)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, simple);\n\tsimple->dev = dev;\n\n\t \n\tif (of_device_is_compatible(np, \"rockchip,rk3399-dwc3\"))\n\t\tsimple->need_reset = true;\n\n\tsimple->resets = of_reset_control_array_get(np, false, true,\n\t\t\t\t\t\t    true);\n\tif (IS_ERR(simple->resets)) {\n\t\tret = PTR_ERR(simple->resets);\n\t\tdev_err(dev, \"failed to get device resets, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(simple->resets);\n\tif (ret)\n\t\tgoto err_resetc_put;\n\n\tret = clk_bulk_get_all(simple->dev, &simple->clks);\n\tif (ret < 0)\n\t\tgoto err_resetc_assert;\n\n\tsimple->num_clocks = ret;\n\tret = clk_bulk_prepare_enable(simple->num_clocks, simple->clks);\n\tif (ret)\n\t\tgoto err_resetc_assert;\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret)\n\t\tgoto err_clk_put;\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\treturn 0;\n\nerr_clk_put:\n\tclk_bulk_disable_unprepare(simple->num_clocks, simple->clks);\n\tclk_bulk_put_all(simple->num_clocks, simple->clks);\n\nerr_resetc_assert:\n\treset_control_assert(simple->resets);\n\nerr_resetc_put:\n\treset_control_put(simple->resets);\n\treturn ret;\n}\n\nstatic void __dwc3_of_simple_teardown(struct dwc3_of_simple *simple)\n{\n\tof_platform_depopulate(simple->dev);\n\n\tclk_bulk_disable_unprepare(simple->num_clocks, simple->clks);\n\tclk_bulk_put_all(simple->num_clocks, simple->clks);\n\tsimple->num_clocks = 0;\n\n\treset_control_assert(simple->resets);\n\n\treset_control_put(simple->resets);\n\n\tpm_runtime_disable(simple->dev);\n\tpm_runtime_put_noidle(simple->dev);\n\tpm_runtime_set_suspended(simple->dev);\n}\n\nstatic void dwc3_of_simple_remove(struct platform_device *pdev)\n{\n\tstruct dwc3_of_simple\t*simple = platform_get_drvdata(pdev);\n\n\t__dwc3_of_simple_teardown(simple);\n}\n\nstatic void dwc3_of_simple_shutdown(struct platform_device *pdev)\n{\n\tstruct dwc3_of_simple\t*simple = platform_get_drvdata(pdev);\n\n\t__dwc3_of_simple_teardown(simple);\n}\n\nstatic int __maybe_unused dwc3_of_simple_runtime_suspend(struct device *dev)\n{\n\tstruct dwc3_of_simple\t*simple = dev_get_drvdata(dev);\n\n\tclk_bulk_disable(simple->num_clocks, simple->clks);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_of_simple_runtime_resume(struct device *dev)\n{\n\tstruct dwc3_of_simple\t*simple = dev_get_drvdata(dev);\n\n\treturn clk_bulk_enable(simple->num_clocks, simple->clks);\n}\n\nstatic int __maybe_unused dwc3_of_simple_suspend(struct device *dev)\n{\n\tstruct dwc3_of_simple *simple = dev_get_drvdata(dev);\n\n\tif (simple->need_reset)\n\t\treset_control_assert(simple->resets);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused dwc3_of_simple_resume(struct device *dev)\n{\n\tstruct dwc3_of_simple *simple = dev_get_drvdata(dev);\n\n\tif (simple->need_reset)\n\t\treset_control_deassert(simple->resets);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops dwc3_of_simple_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc3_of_simple_suspend, dwc3_of_simple_resume)\n\tSET_RUNTIME_PM_OPS(dwc3_of_simple_runtime_suspend,\n\t\t\tdwc3_of_simple_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id of_dwc3_simple_match[] = {\n\t{ .compatible = \"rockchip,rk3399-dwc3\" },\n\t{ .compatible = \"sprd,sc9860-dwc3\" },\n\t{ .compatible = \"allwinner,sun50i-h6-dwc3\" },\n\t{ .compatible = \"hisilicon,hi3670-dwc3\" },\n\t{ .compatible = \"intel,keembay-dwc3\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, of_dwc3_simple_match);\n\nstatic struct platform_driver dwc3_of_simple_driver = {\n\t.probe\t\t= dwc3_of_simple_probe,\n\t.remove_new\t= dwc3_of_simple_remove,\n\t.shutdown\t= dwc3_of_simple_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"dwc3-of-simple\",\n\t\t.of_match_table = of_dwc3_simple_match,\n\t\t.pm\t= &dwc3_of_simple_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dwc3_of_simple_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DesignWare USB3 OF Simple Glue Layer\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}