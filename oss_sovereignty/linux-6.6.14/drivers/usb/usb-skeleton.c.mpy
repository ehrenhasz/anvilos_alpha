{
  "module_name": "usb-skeleton.c",
  "hash_id": "e43e97dade0362c8c070f287347c98d860f3f2148f37e9f14820829162249145",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usb-skeleton.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n\n\n \n#define USB_SKEL_VENDOR_ID\t0xfff0\n#define USB_SKEL_PRODUCT_ID\t0xfff0\n\n \nstatic const struct usb_device_id skel_table[] = {\n\t{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, skel_table);\n\n\n \n#define USB_SKEL_MINOR_BASE\t192\n\n \n#define MAX_TRANSFER\t\t(PAGE_SIZE - 512)\n \n#define WRITES_IN_FLIGHT\t8\n \n\n \nstruct usb_skel {\n\tstruct usb_device\t*udev;\t\t\t \n\tstruct usb_interface\t*interface;\t\t \n\tstruct semaphore\tlimit_sem;\t\t \n\tstruct usb_anchor\tsubmitted;\t\t \n\tstruct urb\t\t*bulk_in_urb;\t\t \n\tunsigned char           *bulk_in_buffer;\t \n\tsize_t\t\t\tbulk_in_size;\t\t \n\tsize_t\t\t\tbulk_in_filled;\t\t \n\tsize_t\t\t\tbulk_in_copied;\t\t \n\t__u8\t\t\tbulk_in_endpointAddr;\t \n\t__u8\t\t\tbulk_out_endpointAddr;\t \n\tint\t\t\terrors;\t\t\t \n\tbool\t\t\tongoing_read;\t\t \n\tspinlock_t\t\terr_lock;\t\t \n\tstruct kref\t\tkref;\n\tstruct mutex\t\tio_mutex;\t\t \n\tunsigned long\t\tdisconnected:1;\n\twait_queue_head_t\tbulk_in_wait;\t\t \n};\n#define to_skel_dev(d) container_of(d, struct usb_skel, kref)\n\nstatic struct usb_driver skel_driver;\nstatic void skel_draw_down(struct usb_skel *dev);\n\nstatic void skel_delete(struct kref *kref)\n{\n\tstruct usb_skel *dev = to_skel_dev(kref);\n\n\tusb_free_urb(dev->bulk_in_urb);\n\tusb_put_intf(dev->interface);\n\tusb_put_dev(dev->udev);\n\tkfree(dev->bulk_in_buffer);\n\tkfree(dev);\n}\n\nstatic int skel_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_skel *dev;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&skel_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"%s - error, can't find device for minor %d\\n\",\n\t\t\t__func__, subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tretval = usb_autopm_get_interface(interface);\n\tif (retval)\n\t\tgoto exit;\n\n\t \n\tkref_get(&dev->kref);\n\n\t \n\tfile->private_data = dev;\n\nexit:\n\treturn retval;\n}\n\nstatic int skel_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_skel *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tusb_autopm_put_interface(dev->interface);\n\n\t \n\tkref_put(&dev->kref, skel_delete);\n\treturn 0;\n}\n\nstatic int skel_flush(struct file *file, fl_owner_t id)\n{\n\tstruct usb_skel *dev;\n\tint res;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&dev->io_mutex);\n\tskel_draw_down(dev);\n\n\t \n\tspin_lock_irq(&dev->err_lock);\n\tres = dev->errors ? (dev->errors == -EPIPE ? -EPIPE : -EIO) : 0;\n\tdev->errors = 0;\n\tspin_unlock_irq(&dev->err_lock);\n\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn res;\n}\n\nstatic void skel_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_skel *dev;\n\tunsigned long flags;\n\n\tdev = urb->context;\n\n\tspin_lock_irqsave(&dev->err_lock, flags);\n\t \n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t    urb->status == -ECONNRESET ||\n\t\t    urb->status == -ESHUTDOWN))\n\t\t\tdev_err(&dev->interface->dev,\n\t\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\n\t\tdev->errors = urb->status;\n\t} else {\n\t\tdev->bulk_in_filled = urb->actual_length;\n\t}\n\tdev->ongoing_read = 0;\n\tspin_unlock_irqrestore(&dev->err_lock, flags);\n\n\twake_up_interruptible(&dev->bulk_in_wait);\n}\n\nstatic int skel_do_read_io(struct usb_skel *dev, size_t count)\n{\n\tint rv;\n\n\t \n\tusb_fill_bulk_urb(dev->bulk_in_urb,\n\t\t\tdev->udev,\n\t\t\tusb_rcvbulkpipe(dev->udev,\n\t\t\t\tdev->bulk_in_endpointAddr),\n\t\t\tdev->bulk_in_buffer,\n\t\t\tmin(dev->bulk_in_size, count),\n\t\t\tskel_read_bulk_callback,\n\t\t\tdev);\n\t \n\tspin_lock_irq(&dev->err_lock);\n\tdev->ongoing_read = 1;\n\tspin_unlock_irq(&dev->err_lock);\n\n\t \n\tdev->bulk_in_filled = 0;\n\tdev->bulk_in_copied = 0;\n\n\t \n\trv = usb_submit_urb(dev->bulk_in_urb, GFP_KERNEL);\n\tif (rv < 0) {\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t__func__, rv);\n\t\trv = (rv == -ENOMEM) ? rv : -EIO;\n\t\tspin_lock_irq(&dev->err_lock);\n\t\tdev->ongoing_read = 0;\n\t\tspin_unlock_irq(&dev->err_lock);\n\t}\n\n\treturn rv;\n}\n\nstatic ssize_t skel_read(struct file *file, char *buffer, size_t count,\n\t\t\t loff_t *ppos)\n{\n\tstruct usb_skel *dev;\n\tint rv;\n\tbool ongoing_io;\n\n\tdev = file->private_data;\n\n\tif (!count)\n\t\treturn 0;\n\n\t \n\trv = mutex_lock_interruptible(&dev->io_mutex);\n\tif (rv < 0)\n\t\treturn rv;\n\n\tif (dev->disconnected) {\t\t \n\t\trv = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \nretry:\n\tspin_lock_irq(&dev->err_lock);\n\tongoing_io = dev->ongoing_read;\n\tspin_unlock_irq(&dev->err_lock);\n\n\tif (ongoing_io) {\n\t\t \n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\trv = -EAGAIN;\n\t\t\tgoto exit;\n\t\t}\n\t\t \n\t\trv = wait_event_interruptible(dev->bulk_in_wait, (!dev->ongoing_read));\n\t\tif (rv < 0)\n\t\t\tgoto exit;\n\t}\n\n\t \n\trv = dev->errors;\n\tif (rv < 0) {\n\t\t \n\t\tdev->errors = 0;\n\t\t \n\t\trv = (rv == -EPIPE) ? rv : -EIO;\n\t\t \n\t\tgoto exit;\n\t}\n\n\t \n\n\tif (dev->bulk_in_filled) {\n\t\t \n\t\tsize_t available = dev->bulk_in_filled - dev->bulk_in_copied;\n\t\tsize_t chunk = min(available, count);\n\n\t\tif (!available) {\n\t\t\t \n\t\t\trv = skel_do_read_io(dev, count);\n\t\t\tif (rv < 0)\n\t\t\t\tgoto exit;\n\t\t\telse\n\t\t\t\tgoto retry;\n\t\t}\n\t\t \n\n\t\tif (copy_to_user(buffer,\n\t\t\t\t dev->bulk_in_buffer + dev->bulk_in_copied,\n\t\t\t\t chunk))\n\t\t\trv = -EFAULT;\n\t\telse\n\t\t\trv = chunk;\n\n\t\tdev->bulk_in_copied += chunk;\n\n\t\t \n\t\tif (available < count)\n\t\t\tskel_do_read_io(dev, count - chunk);\n\t} else {\n\t\t \n\t\trv = skel_do_read_io(dev, count);\n\t\tif (rv < 0)\n\t\t\tgoto exit;\n\t\telse\n\t\t\tgoto retry;\n\t}\nexit:\n\tmutex_unlock(&dev->io_mutex);\n\treturn rv;\n}\n\nstatic void skel_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_skel *dev;\n\tunsigned long flags;\n\n\tdev = urb->context;\n\n\t \n\tif (urb->status) {\n\t\tif (!(urb->status == -ENOENT ||\n\t\t    urb->status == -ECONNRESET ||\n\t\t    urb->status == -ESHUTDOWN))\n\t\t\tdev_err(&dev->interface->dev,\n\t\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\n\t\tspin_lock_irqsave(&dev->err_lock, flags);\n\t\tdev->errors = urb->status;\n\t\tspin_unlock_irqrestore(&dev->err_lock, flags);\n\t}\n\n\t \n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tup(&dev->limit_sem);\n}\n\nstatic ssize_t skel_write(struct file *file, const char *user_buffer,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct usb_skel *dev;\n\tint retval = 0;\n\tstruct urb *urb = NULL;\n\tchar *buf = NULL;\n\tsize_t writesize = min_t(size_t, count, MAX_TRANSFER);\n\n\tdev = file->private_data;\n\n\t \n\tif (count == 0)\n\t\tgoto exit;\n\n\t \n\tif (!(file->f_flags & O_NONBLOCK)) {\n\t\tif (down_interruptible(&dev->limit_sem)) {\n\t\t\tretval = -ERESTARTSYS;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tif (down_trylock(&dev->limit_sem)) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tspin_lock_irq(&dev->err_lock);\n\tretval = dev->errors;\n\tif (retval < 0) {\n\t\t \n\t\tdev->errors = 0;\n\t\t \n\t\tretval = (retval == -EPIPE) ? retval : -EIO;\n\t}\n\tspin_unlock_irq(&dev->err_lock);\n\tif (retval < 0)\n\t\tgoto error;\n\n\t \n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tbuf = usb_alloc_coherent(dev->udev, writesize, GFP_KERNEL,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(buf, user_buffer, writesize)) {\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\n\t \n\tmutex_lock(&dev->io_mutex);\n\tif (dev->disconnected) {\t\t \n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),\n\t\t\t  buf, writesize, skel_write_bulk_callback, dev);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->submitted);\n\n\t \n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tmutex_unlock(&dev->io_mutex);\n\tif (retval) {\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto error_unanchor;\n\t}\n\n\t \n\tusb_free_urb(urb);\n\n\n\treturn writesize;\n\nerror_unanchor:\n\tusb_unanchor_urb(urb);\nerror:\n\tif (urb) {\n\t\tusb_free_coherent(dev->udev, writesize, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n\tup(&dev->limit_sem);\n\nexit:\n\treturn retval;\n}\n\nstatic const struct file_operations skel_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tskel_read,\n\t.write =\tskel_write,\n\t.open =\t\tskel_open,\n\t.release =\tskel_release,\n\t.flush =\tskel_flush,\n\t.llseek =\tnoop_llseek,\n};\n\n \nstatic struct usb_class_driver skel_class = {\n\t.name =\t\t\"skel%d\",\n\t.fops =\t\t&skel_fops,\n\t.minor_base =\tUSB_SKEL_MINOR_BASE,\n};\n\nstatic int skel_probe(struct usb_interface *interface,\n\t\t      const struct usb_device_id *id)\n{\n\tstruct usb_skel *dev;\n\tstruct usb_endpoint_descriptor *bulk_in, *bulk_out;\n\tint retval;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&dev->kref);\n\tsema_init(&dev->limit_sem, WRITES_IN_FLIGHT);\n\tmutex_init(&dev->io_mutex);\n\tspin_lock_init(&dev->err_lock);\n\tinit_usb_anchor(&dev->submitted);\n\tinit_waitqueue_head(&dev->bulk_in_wait);\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = usb_get_intf(interface);\n\n\t \n\t \n\tretval = usb_find_common_endpoints(interface->cur_altsetting,\n\t\t\t&bulk_in, &bulk_out, NULL, NULL);\n\tif (retval) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Could not find both bulk-in and bulk-out endpoints\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->bulk_in_size = usb_endpoint_maxp(bulk_in);\n\tdev->bulk_in_endpointAddr = bulk_in->bEndpointAddress;\n\tdev->bulk_in_buffer = kmalloc(dev->bulk_in_size, GFP_KERNEL);\n\tif (!dev->bulk_in_buffer) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\tdev->bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->bulk_in_urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdev->bulk_out_endpointAddr = bulk_out->bEndpointAddress;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\t \n\tretval = usb_register_dev(interface, &skel_class);\n\tif (retval) {\n\t\t \n\t\tdev_err(&interface->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\t \n\tdev_info(&interface->dev,\n\t\t \"USB Skeleton device now attached to USBSkel-%d\",\n\t\t interface->minor);\n\treturn 0;\n\nerror:\n\t \n\tkref_put(&dev->kref, skel_delete);\n\n\treturn retval;\n}\n\nstatic void skel_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_skel *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\n\t \n\tusb_deregister_dev(interface, &skel_class);\n\n\t \n\tmutex_lock(&dev->io_mutex);\n\tdev->disconnected = 1;\n\tmutex_unlock(&dev->io_mutex);\n\n\tusb_kill_urb(dev->bulk_in_urb);\n\tusb_kill_anchored_urbs(&dev->submitted);\n\n\t \n\tkref_put(&dev->kref, skel_delete);\n\n\tdev_info(&interface->dev, \"USB Skeleton #%d now disconnected\", minor);\n}\n\nstatic void skel_draw_down(struct usb_skel *dev)\n{\n\tint time;\n\n\ttime = usb_wait_anchor_empty_timeout(&dev->submitted, 1000);\n\tif (!time)\n\t\tusb_kill_anchored_urbs(&dev->submitted);\n\tusb_kill_urb(dev->bulk_in_urb);\n}\n\nstatic int skel_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_skel *dev = usb_get_intfdata(intf);\n\n\tif (!dev)\n\t\treturn 0;\n\tskel_draw_down(dev);\n\treturn 0;\n}\n\nstatic int skel_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int skel_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_skel *dev = usb_get_intfdata(intf);\n\n\tmutex_lock(&dev->io_mutex);\n\tskel_draw_down(dev);\n\n\treturn 0;\n}\n\nstatic int skel_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_skel *dev = usb_get_intfdata(intf);\n\n\t \n\tdev->errors = -EPIPE;\n\tmutex_unlock(&dev->io_mutex);\n\n\treturn 0;\n}\n\nstatic struct usb_driver skel_driver = {\n\t.name =\t\t\"skeleton\",\n\t.probe =\tskel_probe,\n\t.disconnect =\tskel_disconnect,\n\t.suspend =\tskel_suspend,\n\t.resume =\tskel_resume,\n\t.pre_reset =\tskel_pre_reset,\n\t.post_reset =\tskel_post_reset,\n\t.id_table =\tskel_table,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(skel_driver);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}