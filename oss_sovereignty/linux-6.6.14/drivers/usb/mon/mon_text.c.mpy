{
  "module_name": "mon_text.c",
  "hash_id": "2fdbfe80a0905c2d3b3f02a1c0eb1d91109796efb524068980bcb095d10b43ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mon/mon_text.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n#include <linux/time.h>\n#include <linux/ktime.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/debugfs.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n\n#include \"usb_mon.h\"\n\n \n#define DATA_MAX  32\n\n \n#define SETUP_MAX  8\n\n \n#define EVENT_MAX  (4*PAGE_SIZE / sizeof(struct mon_event_text))\n\n \n#define ISODESC_MAX   5\n\n#define PRINTF_DFL  250    \n\nstruct mon_iso_desc {\n\tint status;\n\tunsigned int offset;\n\tunsigned int length;\t \n};\n\nstruct mon_event_text {\n\tstruct list_head e_link;\n\tint type;\t\t \n\tunsigned long id;\t \n\tunsigned int tstamp;\n\tint busnum;\n\tchar devnum;\n\tchar epnum;\n\tchar is_in;\n\tchar xfertype;\n\tint length;\t\t \n\tint status;\n\tint interval;\n\tint start_frame;\n\tint error_count;\n\tchar setup_flag;\n\tchar data_flag;\n\tint numdesc;\t\t \n\tstruct mon_iso_desc isodesc[ISODESC_MAX];\n\tunsigned char setup[SETUP_MAX];\n\tunsigned char data[DATA_MAX];\n};\n\n#define SLAB_NAME_SZ  30\nstruct mon_reader_text {\n\tstruct kmem_cache *e_slab;\n\tint nevents;\n\tstruct list_head e_list;\n\tstruct mon_reader r;\t \n\n\twait_queue_head_t wait;\n\tint printf_size;\n\tsize_t printf_offset;\n\tsize_t printf_togo;\n\tchar *printf_buf;\n\tstruct mutex printf_lock;\n\n\tchar slab_name[SLAB_NAME_SZ];\n};\n\nstatic struct dentry *mon_dir;\t\t \n\nstatic void mon_text_ctor(void *);\n\nstruct mon_text_ptr {\n\tint cnt, limit;\n\tchar *pbuf;\n};\n\nstatic struct mon_event_text *\n    mon_text_read_wait(struct mon_reader_text *rp, struct file *file);\nstatic void mon_text_read_head_t(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_head_u(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_statset(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_intstat(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_isostat(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_isodesc(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep);\nstatic void mon_text_read_data(struct mon_reader_text *rp,\n    struct mon_text_ptr *p, const struct mon_event_text *ep);\n\n \n\nstatic inline char mon_text_get_setup(struct mon_event_text *ep,\n    struct urb *urb, char ev_type, struct mon_bus *mbus)\n{\n\n\tif (ep->xfertype != USB_ENDPOINT_XFER_CONTROL || ev_type != 'S')\n\t\treturn '-';\n\n\tif (urb->setup_packet == NULL)\n\t\treturn 'Z';\t \n\n\tmemcpy(ep->setup, urb->setup_packet, SETUP_MAX);\n\treturn 0;\n}\n\nstatic inline char mon_text_get_data(struct mon_event_text *ep, struct urb *urb,\n    int len, char ev_type, struct mon_bus *mbus)\n{\n\tvoid *src;\n\n\tif (len <= 0)\n\t\treturn 'L';\n\tif (len >= DATA_MAX)\n\t\tlen = DATA_MAX;\n\n\tif (ep->is_in) {\n\t\tif (ev_type != 'C')\n\t\t\treturn '<';\n\t} else {\n\t\tif (ev_type != 'S')\n\t\t\treturn '>';\n\t}\n\n\tif (urb->num_sgs == 0) {\n\t\tsrc = urb->transfer_buffer;\n\t\tif (src == NULL)\n\t\t\treturn 'Z';\t \n\t} else {\n\t\tstruct scatterlist *sg = urb->sg;\n\n\t\tif (PageHighMem(sg_page(sg)))\n\t\t\treturn 'D';\n\n\t\t \n\t\tlen = min_t(int, sg->length, len);\n\t\tsrc = sg_virt(sg);\n\t}\n\n\tmemcpy(ep->data, src, len);\n\treturn 0;\n}\n\nstatic inline unsigned int mon_get_timestamp(void)\n{\n\tstruct timespec64 now;\n\tunsigned int stamp;\n\n\tktime_get_ts64(&now);\n\tstamp = now.tv_sec & 0xFFF;   \n\tstamp = stamp * USEC_PER_SEC + now.tv_nsec / NSEC_PER_USEC;\n\treturn stamp;\n}\n\nstatic void mon_text_event(struct mon_reader_text *rp, struct urb *urb,\n    char ev_type, int status)\n{\n\tstruct mon_event_text *ep;\n\tunsigned int stamp;\n\tstruct usb_iso_packet_descriptor *fp;\n\tstruct mon_iso_desc *dp;\n\tint i, ndesc;\n\n\tstamp = mon_get_timestamp();\n\n\tif (rp->nevents >= EVENT_MAX ||\n\t    (ep = kmem_cache_alloc(rp->e_slab, GFP_ATOMIC)) == NULL) {\n\t\trp->r.m_bus->cnt_text_lost++;\n\t\treturn;\n\t}\n\n\tep->type = ev_type;\n\tep->id = (unsigned long) urb;\n\tep->busnum = urb->dev->bus->busnum;\n\tep->devnum = urb->dev->devnum;\n\tep->epnum = usb_endpoint_num(&urb->ep->desc);\n\tep->xfertype = usb_endpoint_type(&urb->ep->desc);\n\tep->is_in = usb_urb_dir_in(urb);\n\tep->tstamp = stamp;\n\tep->length = (ev_type == 'S') ?\n\t    urb->transfer_buffer_length : urb->actual_length;\n\t \n\tep->status = status;\n\n\tif (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\tep->interval = urb->interval;\n\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\tep->interval = urb->interval;\n\t\tep->start_frame = urb->start_frame;\n\t\tep->error_count = urb->error_count;\n\t}\n\tep->numdesc = urb->number_of_packets;\n\tif (ep->xfertype == USB_ENDPOINT_XFER_ISOC &&\n\t\t\turb->number_of_packets > 0) {\n\t\tif ((ndesc = urb->number_of_packets) > ISODESC_MAX)\n\t\t\tndesc = ISODESC_MAX;\n\t\tfp = urb->iso_frame_desc;\n\t\tdp = ep->isodesc;\n\t\tfor (i = 0; i < ndesc; i++) {\n\t\t\tdp->status = fp->status;\n\t\t\tdp->offset = fp->offset;\n\t\t\tdp->length = (ev_type == 'S') ?\n\t\t\t    fp->length : fp->actual_length;\n\t\t\tfp++;\n\t\t\tdp++;\n\t\t}\n\t\t \n\t\tif (ev_type == 'C')\n\t\t\tep->length = urb->transfer_buffer_length;\n\t}\n\n\tep->setup_flag = mon_text_get_setup(ep, urb, ev_type, rp->r.m_bus);\n\tep->data_flag = mon_text_get_data(ep, urb, ep->length, ev_type,\n\t\t\trp->r.m_bus);\n\n\trp->nevents++;\n\tlist_add_tail(&ep->e_link, &rp->e_list);\n\twake_up(&rp->wait);\n}\n\nstatic void mon_text_submit(void *data, struct urb *urb)\n{\n\tstruct mon_reader_text *rp = data;\n\tmon_text_event(rp, urb, 'S', -EINPROGRESS);\n}\n\nstatic void mon_text_complete(void *data, struct urb *urb, int status)\n{\n\tstruct mon_reader_text *rp = data;\n\tmon_text_event(rp, urb, 'C', status);\n}\n\nstatic void mon_text_error(void *data, struct urb *urb, int error)\n{\n\tstruct mon_reader_text *rp = data;\n\tstruct mon_event_text *ep;\n\n\tif (rp->nevents >= EVENT_MAX ||\n\t    (ep = kmem_cache_alloc(rp->e_slab, GFP_ATOMIC)) == NULL) {\n\t\trp->r.m_bus->cnt_text_lost++;\n\t\treturn;\n\t}\n\n\tep->type = 'E';\n\tep->id = (unsigned long) urb;\n\tep->busnum = urb->dev->bus->busnum;\n\tep->devnum = urb->dev->devnum;\n\tep->epnum = usb_endpoint_num(&urb->ep->desc);\n\tep->xfertype = usb_endpoint_type(&urb->ep->desc);\n\tep->is_in = usb_urb_dir_in(urb);\n\tep->tstamp = mon_get_timestamp();\n\tep->length = 0;\n\tep->status = error;\n\n\tep->setup_flag = '-';\n\tep->data_flag = 'E';\n\n\trp->nevents++;\n\tlist_add_tail(&ep->e_link, &rp->e_list);\n\twake_up(&rp->wait);\n}\n\n \nstatic struct mon_event_text *mon_text_fetch(struct mon_reader_text *rp,\n    struct mon_bus *mbus)\n{\n\tstruct list_head *p;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tif (list_empty(&rp->e_list)) {\n\t\tspin_unlock_irqrestore(&mbus->lock, flags);\n\t\treturn NULL;\n\t}\n\tp = rp->e_list.next;\n\tlist_del(p);\n\t--rp->nevents;\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n\treturn list_entry(p, struct mon_event_text, e_link);\n}\n\n \nstatic int mon_text_open(struct inode *inode, struct file *file)\n{\n\tstruct mon_bus *mbus;\n\tstruct mon_reader_text *rp;\n\tint rc;\n\n\tmutex_lock(&mon_lock);\n\tmbus = inode->i_private;\n\n\trp = kzalloc(sizeof(struct mon_reader_text), GFP_KERNEL);\n\tif (rp == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\tINIT_LIST_HEAD(&rp->e_list);\n\tinit_waitqueue_head(&rp->wait);\n\tmutex_init(&rp->printf_lock);\n\n\trp->printf_size = PRINTF_DFL;\n\trp->printf_buf = kmalloc(rp->printf_size, GFP_KERNEL);\n\tif (rp->printf_buf == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto err_alloc_pr;\n\t}\n\n\trp->r.m_bus = mbus;\n\trp->r.r_data = rp;\n\trp->r.rnf_submit = mon_text_submit;\n\trp->r.rnf_error = mon_text_error;\n\trp->r.rnf_complete = mon_text_complete;\n\n\tsnprintf(rp->slab_name, SLAB_NAME_SZ, \"mon_text_%p\", rp);\n\trp->e_slab = kmem_cache_create(rp->slab_name,\n\t    sizeof(struct mon_event_text), sizeof(long), 0,\n\t    mon_text_ctor);\n\tif (rp->e_slab == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto err_slab;\n\t}\n\n\tmon_reader_add(mbus, &rp->r);\n\n\tfile->private_data = rp;\n\tmutex_unlock(&mon_lock);\n\treturn 0;\n\n\n\nerr_slab:\n\tkfree(rp->printf_buf);\nerr_alloc_pr:\n\tkfree(rp);\nerr_alloc:\n\tmutex_unlock(&mon_lock);\n\treturn rc;\n}\n\nstatic ssize_t mon_text_copy_to_user(struct mon_reader_text *rp,\n    char __user * const buf, const size_t nbytes)\n{\n\tconst size_t togo = min(nbytes, rp->printf_togo);\n\n\tif (copy_to_user(buf, &rp->printf_buf[rp->printf_offset], togo))\n\t\treturn -EFAULT;\n\trp->printf_togo -= togo;\n\trp->printf_offset += togo;\n\treturn togo;\n}\n\n \nstatic ssize_t mon_text_read_t(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_t(rp, &ptr, ep);\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\tptr.cnt += scnprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    \" %d\", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}\n\n \nstatic ssize_t mon_text_read_u(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_u(rp, &ptr, ep);\n\t\tif (ep->type == 'E') {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t\t} else {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t}\n\t\tptr.cnt += scnprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    \" %d\", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}\n\nstatic struct mon_event_text *mon_text_read_wait(struct mon_reader_text *rp,\n    struct file *file)\n{\n\tstruct mon_bus *mbus = rp->r.m_bus;\n\tDECLARE_WAITQUEUE(waita, current);\n\tstruct mon_event_text *ep;\n\n\tadd_wait_queue(&rp->wait, &waita);\n\tset_current_state(TASK_INTERRUPTIBLE);\n\twhile ((ep = mon_text_fetch(rp, mbus)) == NULL) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&rp->wait, &waita);\n\t\t\treturn ERR_PTR(-EWOULDBLOCK);\n\t\t}\n\t\t \n\t\tschedule();\n\t\tif (signal_pending(current)) {\n\t\t\tremove_wait_queue(&rp->wait, &waita);\n\t\t\treturn ERR_PTR(-EINTR);\n\t\t}\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tremove_wait_queue(&rp->wait, &waita);\n\treturn ep;\n}\n\nstatic void mon_text_read_head_t(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tchar udir, utype;\n\n\tudir = (ep->is_in ? 'i' : 'o');\n\tswitch (ep->xfertype) {\n\tcase USB_ENDPOINT_XFER_ISOC:\tutype = 'Z'; break;\n\tcase USB_ENDPOINT_XFER_INT:\tutype = 'I'; break;\n\tcase USB_ENDPOINT_XFER_CONTROL:\tutype = 'C'; break;\n\tdefault:    utype = 'B';\n\t}\n\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t    \"%lx %u %c %c%c:%03u:%02u\",\n\t    ep->id, ep->tstamp, ep->type,\n\t    utype, udir, ep->devnum, ep->epnum);\n}\n\nstatic void mon_text_read_head_u(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tchar udir, utype;\n\n\tudir = (ep->is_in ? 'i' : 'o');\n\tswitch (ep->xfertype) {\n\tcase USB_ENDPOINT_XFER_ISOC:\tutype = 'Z'; break;\n\tcase USB_ENDPOINT_XFER_INT:\tutype = 'I'; break;\n\tcase USB_ENDPOINT_XFER_CONTROL:\tutype = 'C'; break;\n\tdefault:    utype = 'B';\n\t}\n\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t    \"%lx %u %c %c%c:%d:%03u:%u\",\n\t    ep->id, ep->tstamp, ep->type,\n\t    utype, udir, ep->busnum, ep->devnum, ep->epnum);\n}\n\nstatic void mon_text_read_statset(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\n\tif (ep->setup_flag == 0) {    \n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" s %02x %02x %04x %04x %04x\",\n\t\t    ep->setup[0],\n\t\t    ep->setup[1],\n\t\t    (ep->setup[3] << 8) | ep->setup[2],\n\t\t    (ep->setup[5] << 8) | ep->setup[4],\n\t\t    (ep->setup[7] << 8) | ep->setup[6]);\n\t} else if (ep->setup_flag != '-') {  \n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" %c __ __ ____ ____ ____\", ep->setup_flag);\n\t} else {                      \n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" %d\", ep->status);\n\t}\n}\n\nstatic void mon_text_read_intstat(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t    \" %d:%d\", ep->status, ep->interval);\n}\n\nstatic void mon_text_read_isostat(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tif (ep->type == 'S') {\n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" %d:%d:%d\", ep->status, ep->interval, ep->start_frame);\n\t} else {\n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" %d:%d:%d:%d\",\n\t\t    ep->status, ep->interval, ep->start_frame, ep->error_count);\n\t}\n}\n\nstatic void mon_text_read_isodesc(struct mon_reader_text *rp,\n\tstruct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tint ndesc;\t \n\tint i;\n\tconst struct mon_iso_desc *dp;\n\n\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t    \" %d\", ep->numdesc);\n\tndesc = ep->numdesc;\n\tif (ndesc > ISODESC_MAX)\n\t\tndesc = ISODESC_MAX;\n\tif (ndesc < 0)\n\t\tndesc = 0;\n\tdp = ep->isodesc;\n\tfor (i = 0; i < ndesc; i++) {\n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t    \" %d:%u:%u\", dp->status, dp->offset, dp->length);\n\t\tdp++;\n\t}\n}\n\nstatic void mon_text_read_data(struct mon_reader_text *rp,\n    struct mon_text_ptr *p, const struct mon_event_text *ep)\n{\n\tint data_len, i;\n\n\tif ((data_len = ep->length) > 0) {\n\t\tif (ep->data_flag == 0) {\n\t\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t\t    \" =\");\n\t\t\tif (data_len >= DATA_MAX)\n\t\t\t\tdata_len = DATA_MAX;\n\t\t\tfor (i = 0; i < data_len; i++) {\n\t\t\t\tif (i % 4 == 0) {\n\t\t\t\t\tp->cnt += scnprintf(p->pbuf + p->cnt,\n\t\t\t\t\t    p->limit - p->cnt,\n\t\t\t\t\t    \" \");\n\t\t\t\t}\n\t\t\t\tp->cnt += scnprintf(p->pbuf + p->cnt,\n\t\t\t\t    p->limit - p->cnt,\n\t\t\t\t    \"%02x\", ep->data[i]);\n\t\t\t}\n\t\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t\t    \"\\n\");\n\t\t} else {\n\t\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt,\n\t\t\t    \" %c\\n\", ep->data_flag);\n\t\t}\n\t} else {\n\t\tp->cnt += scnprintf(p->pbuf + p->cnt, p->limit - p->cnt, \"\\n\");\n\t}\n}\n\nstatic int mon_text_release(struct inode *inode, struct file *file)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_bus *mbus;\n\t \n\tstruct list_head *p;\n\tstruct mon_event_text *ep;\n\n\tmutex_lock(&mon_lock);\n\tmbus = inode->i_private;\n\n\tif (mbus->nreaders <= 0) {\n\t\tprintk(KERN_ERR TAG \": consistency error on close\\n\");\n\t\tmutex_unlock(&mon_lock);\n\t\treturn 0;\n\t}\n\tmon_reader_del(mbus, &rp->r);\n\n\t \n\t \n\twhile (!list_empty(&rp->e_list)) {\n\t\tp = rp->e_list.next;\n\t\tep = list_entry(p, struct mon_event_text, e_link);\n\t\tlist_del(p);\n\t\t--rp->nevents;\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\t \n\n\tkmem_cache_destroy(rp->e_slab);\n\tkfree(rp->printf_buf);\n\tkfree(rp);\n\n\tmutex_unlock(&mon_lock);\n\treturn 0;\n}\n\nstatic const struct file_operations mon_fops_text_t = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tmon_text_open,\n\t.llseek =\tno_llseek,\n\t.read =\t\tmon_text_read_t,\n\t.release =\tmon_text_release,\n};\n\nstatic const struct file_operations mon_fops_text_u = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tmon_text_open,\n\t.llseek =\tno_llseek,\n\t.read =\t\tmon_text_read_u,\n\t.release =\tmon_text_release,\n};\n\nint mon_text_add(struct mon_bus *mbus, const struct usb_bus *ubus)\n{\n\tenum { NAMESZ = 10 };\n\tchar name[NAMESZ];\n\tint busnum = ubus? ubus->busnum: 0;\n\tint rc;\n\n\tif (mon_dir == NULL)\n\t\treturn 0;\n\n\tif (ubus != NULL) {\n\t\trc = snprintf(name, NAMESZ, \"%dt\", busnum);\n\t\tif (rc <= 0 || rc >= NAMESZ)\n\t\t\tgoto err_print_t;\n\t\tmbus->dent_t = debugfs_create_file(name, 0600, mon_dir, mbus,\n\t\t\t\t\t\t\t     &mon_fops_text_t);\n\t}\n\n\trc = snprintf(name, NAMESZ, \"%du\", busnum);\n\tif (rc <= 0 || rc >= NAMESZ)\n\t\tgoto err_print_u;\n\tmbus->dent_u = debugfs_create_file(name, 0600, mon_dir, mbus,\n\t\t\t\t\t   &mon_fops_text_u);\n\n\trc = snprintf(name, NAMESZ, \"%ds\", busnum);\n\tif (rc <= 0 || rc >= NAMESZ)\n\t\tgoto err_print_s;\n\tmbus->dent_s = debugfs_create_file(name, 0600, mon_dir, mbus,\n\t\t\t\t\t   &mon_fops_stat);\n\n\treturn 1;\n\nerr_print_s:\n\tdebugfs_remove(mbus->dent_u);\n\tmbus->dent_u = NULL;\nerr_print_u:\n\tif (ubus != NULL) {\n\t\tdebugfs_remove(mbus->dent_t);\n\t\tmbus->dent_t = NULL;\n\t}\nerr_print_t:\n\treturn 0;\n}\n\nvoid mon_text_del(struct mon_bus *mbus)\n{\n\tdebugfs_remove(mbus->dent_u);\n\tdebugfs_remove(mbus->dent_t);\n\tdebugfs_remove(mbus->dent_s);\n}\n\n \nstatic void mon_text_ctor(void *mem)\n{\n\t \n\tmemset(mem, 0xe5, sizeof(struct mon_event_text));\n}\n\nint __init mon_text_init(void)\n{\n\tmon_dir = debugfs_create_dir(\"usbmon\", usb_debug_root);\n\treturn 0;\n}\n\nvoid mon_text_exit(void)\n{\n\tdebugfs_remove(mon_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}