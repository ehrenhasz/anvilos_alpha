{
  "module_name": "mon_main.c",
  "hash_id": "1f0f5c48a60f7e78388fc4ebbf5066c22c9096f2ccac913c0f53311339664746",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mon/mon_main.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/slab.h>\n#include <linux/notifier.h>\n#include <linux/mutex.h>\n\n#include \"usb_mon.h\"\n\n\nstatic void mon_stop(struct mon_bus *mbus);\nstatic void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus);\nstatic void mon_bus_drop(struct kref *r);\nstatic void mon_bus_init(struct usb_bus *ubus);\n\nDEFINE_MUTEX(mon_lock);\n\nstruct mon_bus mon_bus0;\t\t \nstatic LIST_HEAD(mon_buses);\t\t \n\n \nvoid mon_reader_add(struct mon_bus *mbus, struct mon_reader *r)\n{\n\tunsigned long flags;\n\tstruct list_head *p;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tif (mbus->nreaders == 0) {\n\t\tif (mbus == &mon_bus0) {\n\t\t\tlist_for_each (p, &mon_buses) {\n\t\t\t\tstruct mon_bus *m1;\n\t\t\t\tm1 = list_entry(p, struct mon_bus, bus_link);\n\t\t\t\tm1->u_bus->monitored = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tmbus->u_bus->monitored = 1;\n\t\t}\n\t}\n\tmbus->nreaders++;\n\tlist_add_tail(&r->r_link, &mbus->r_list);\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n\n\tkref_get(&mbus->ref);\n}\n\n \nvoid mon_reader_del(struct mon_bus *mbus, struct mon_reader *r)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tlist_del(&r->r_link);\n\t--mbus->nreaders;\n\tif (mbus->nreaders == 0)\n\t\tmon_stop(mbus);\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n\n\tkref_put(&mbus->ref, mon_bus_drop);\n}\n\n \nstatic void mon_bus_submit(struct mon_bus *mbus, struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct list_head *pos;\n\tstruct mon_reader *r;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tmbus->cnt_events++;\n\tlist_for_each (pos, &mbus->r_list) {\n\t\tr = list_entry(pos, struct mon_reader, r_link);\n\t\tr->rnf_submit(r->r_data, urb);\n\t}\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n}\n\nstatic void mon_submit(struct usb_bus *ubus, struct urb *urb)\n{\n\tstruct mon_bus *mbus;\n\n\tmbus = ubus->mon_bus;\n\tif (mbus != NULL)\n\t\tmon_bus_submit(mbus, urb);\n\tmon_bus_submit(&mon_bus0, urb);\n}\n\n \nstatic void mon_bus_submit_error(struct mon_bus *mbus, struct urb *urb, int error)\n{\n\tunsigned long flags;\n\tstruct list_head *pos;\n\tstruct mon_reader *r;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tmbus->cnt_events++;\n\tlist_for_each (pos, &mbus->r_list) {\n\t\tr = list_entry(pos, struct mon_reader, r_link);\n\t\tr->rnf_error(r->r_data, urb, error);\n\t}\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n}\n\nstatic void mon_submit_error(struct usb_bus *ubus, struct urb *urb, int error)\n{\n\tstruct mon_bus *mbus;\n\n\tmbus = ubus->mon_bus;\n\tif (mbus != NULL)\n\t\tmon_bus_submit_error(mbus, urb, error);\n\tmon_bus_submit_error(&mon_bus0, urb, error);\n}\n\n \nstatic void mon_bus_complete(struct mon_bus *mbus, struct urb *urb, int status)\n{\n\tunsigned long flags;\n\tstruct list_head *pos;\n\tstruct mon_reader *r;\n\n\tspin_lock_irqsave(&mbus->lock, flags);\n\tmbus->cnt_events++;\n\tlist_for_each (pos, &mbus->r_list) {\n\t\tr = list_entry(pos, struct mon_reader, r_link);\n\t\tr->rnf_complete(r->r_data, urb, status);\n\t}\n\tspin_unlock_irqrestore(&mbus->lock, flags);\n}\n\nstatic void mon_complete(struct usb_bus *ubus, struct urb *urb, int status)\n{\n\tstruct mon_bus *mbus;\n\n\tmbus = ubus->mon_bus;\n\tif (mbus != NULL)\n\t\tmon_bus_complete(mbus, urb, status);\n\tmon_bus_complete(&mon_bus0, urb, status);\n}\n\n \n\n \nstatic void mon_stop(struct mon_bus *mbus)\n{\n\tstruct usb_bus *ubus;\n\tstruct list_head *p;\n\n\tif (mbus == &mon_bus0) {\n\t\tlist_for_each (p, &mon_buses) {\n\t\t\tmbus = list_entry(p, struct mon_bus, bus_link);\n\t\t\t \n\t\t\tif (mbus->nreaders == 0 && (ubus = mbus->u_bus) != NULL)\n\t\t\t\tubus->monitored = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (mon_bus0.nreaders == 0 && (ubus = mbus->u_bus) != NULL) {\n\t\t\tubus->monitored = 0;\n\t\t\tmb();\n\t\t}\n\t}\n}\n\n \nstatic void mon_bus_add(struct usb_bus *ubus)\n{\n\tmon_bus_init(ubus);\n\tmutex_lock(&mon_lock);\n\tif (mon_bus0.nreaders != 0)\n\t\tubus->monitored = 1;\n\tmutex_unlock(&mon_lock);\n}\n\n \nstatic void mon_bus_remove(struct usb_bus *ubus)\n{\n\tstruct mon_bus *mbus = ubus->mon_bus;\n\n\tmutex_lock(&mon_lock);\n\tlist_del(&mbus->bus_link);\n\tif (mbus->text_inited)\n\t\tmon_text_del(mbus);\n\tif (mbus->bin_inited)\n\t\tmon_bin_del(mbus);\n\n\tmon_dissolve(mbus, ubus);\n\tkref_put(&mbus->ref, mon_bus_drop);\n\tmutex_unlock(&mon_lock);\n}\n\nstatic int mon_notify(struct notifier_block *self, unsigned long action,\n\t\t      void *dev)\n{\n\tswitch (action) {\n\tcase USB_BUS_ADD:\n\t\tmon_bus_add(dev);\n\t\tbreak;\n\tcase USB_BUS_REMOVE:\n\t\tmon_bus_remove(dev);\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block mon_nb = {\n\t.notifier_call = \tmon_notify,\n};\n\n \nstatic const struct usb_mon_operations mon_ops_0 = {\n\t.urb_submit =\tmon_submit,\n\t.urb_submit_error = mon_submit_error,\n\t.urb_complete =\tmon_complete,\n};\n\n \nstatic void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus)\n{\n\n\tif (ubus->monitored) {\n\t\tubus->monitored = 0;\n\t\tmb();\n\t}\n\n\tubus->mon_bus = NULL;\n\tmbus->u_bus = NULL;\n\tmb();\n\n\t \n}\n\n \nstatic void mon_bus_drop(struct kref *r)\n{\n\tstruct mon_bus *mbus = container_of(r, struct mon_bus, ref);\n\tkfree(mbus);\n}\n\n \nstatic void mon_bus_init(struct usb_bus *ubus)\n{\n\tstruct mon_bus *mbus;\n\n\tmbus = kzalloc(sizeof(struct mon_bus), GFP_KERNEL);\n\tif (mbus == NULL)\n\t\tgoto err_alloc;\n\tkref_init(&mbus->ref);\n\tspin_lock_init(&mbus->lock);\n\tINIT_LIST_HEAD(&mbus->r_list);\n\n\t \n\tmbus->u_bus = ubus;\n\tubus->mon_bus = mbus;\n\n\tmbus->text_inited = mon_text_add(mbus, ubus);\n\tmbus->bin_inited = mon_bin_add(mbus, ubus);\n\n\tmutex_lock(&mon_lock);\n\tlist_add_tail(&mbus->bus_link, &mon_buses);\n\tmutex_unlock(&mon_lock);\n\treturn;\n\nerr_alloc:\n\treturn;\n}\n\nstatic void mon_bus0_init(void)\n{\n\tstruct mon_bus *mbus = &mon_bus0;\n\n\tkref_init(&mbus->ref);\n\tspin_lock_init(&mbus->lock);\n\tINIT_LIST_HEAD(&mbus->r_list);\n\n\tmbus->text_inited = mon_text_add(mbus, NULL);\n\tmbus->bin_inited = mon_bin_add(mbus, NULL);\n}\n\n \nstruct mon_bus *mon_bus_lookup(unsigned int num)\n{\n\tstruct list_head *p;\n\tstruct mon_bus *mbus;\n\n\tif (num == 0) {\n\t\treturn &mon_bus0;\n\t}\n\tlist_for_each (p, &mon_buses) {\n\t\tmbus = list_entry(p, struct mon_bus, bus_link);\n\t\tif (mbus->u_bus->busnum == num) {\n\t\t\treturn mbus;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int __init mon_init(void)\n{\n\tstruct usb_bus *ubus;\n\tint rc, id;\n\n\tif ((rc = mon_text_init()) != 0)\n\t\tgoto err_text;\n\tif ((rc = mon_bin_init()) != 0)\n\t\tgoto err_bin;\n\n\tmon_bus0_init();\n\n\tif (usb_mon_register(&mon_ops_0) != 0) {\n\t\tprintk(KERN_NOTICE TAG \": unable to register with the core\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_reg;\n\t}\n\t\n\n\tmutex_lock(&usb_bus_idr_lock);\n\tidr_for_each_entry(&usb_bus_idr, ubus, id)\n\t\tmon_bus_init(ubus);\n\tusb_register_notify(&mon_nb);\n\tmutex_unlock(&usb_bus_idr_lock);\n\treturn 0;\n\nerr_reg:\n\tmon_bin_exit();\nerr_bin:\n\tmon_text_exit();\nerr_text:\n\treturn rc;\n}\n\nstatic void __exit mon_exit(void)\n{\n\tstruct mon_bus *mbus;\n\tstruct list_head *p;\n\n\tusb_unregister_notify(&mon_nb);\n\tusb_mon_deregister();\n\n\tmutex_lock(&mon_lock);\n\n\twhile (!list_empty(&mon_buses)) {\n\t\tp = mon_buses.next;\n\t\tmbus = list_entry(p, struct mon_bus, bus_link);\n\t\tlist_del(p);\n\n\t\tif (mbus->text_inited)\n\t\t\tmon_text_del(mbus);\n\t\tif (mbus->bin_inited)\n\t\t\tmon_bin_del(mbus);\n\n\t\t \n\t\tif (mbus->nreaders) {\n\t\t\tprintk(KERN_ERR TAG\n\t\t\t    \": Outstanding opens (%d) on usb%d, leaking...\\n\",\n\t\t\t    mbus->nreaders, mbus->u_bus->busnum);\n\t\t\tkref_get(&mbus->ref);  \n\t\t}\n\n\t\tmon_dissolve(mbus, mbus->u_bus);\n\t\tkref_put(&mbus->ref, mon_bus_drop);\n\t}\n\n\tmbus = &mon_bus0;\n\tif (mbus->text_inited)\n\t\tmon_text_del(mbus);\n\tif (mbus->bin_inited)\n\t\tmon_bin_del(mbus);\n\n\tmutex_unlock(&mon_lock);\n\n\tmon_text_exit();\n\tmon_bin_exit();\n}\n\nmodule_init(mon_init);\nmodule_exit(mon_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}