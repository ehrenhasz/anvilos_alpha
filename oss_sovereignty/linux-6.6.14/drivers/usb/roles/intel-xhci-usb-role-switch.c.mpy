{
  "module_name": "intel-xhci-usb-role-switch.c",
  "hash_id": "6bbc5bb79b486329c45fb84c39d197b2de41a27e19b023a72a4b3b68abc736e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/roles/intel-xhci-usb-role-switch.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/usb/role.h>\n\n \n#define DUAL_ROLE_CFG0\t\t\t0x68\n#define SW_VBUS_VALID\t\t\tBIT(24)\n#define SW_IDPIN_EN\t\t\tBIT(21)\n#define SW_IDPIN\t\t\tBIT(20)\n#define SW_SWITCH_EN\t\t\tBIT(16)\n\n#define DRD_CONFIG_DYNAMIC\t\t0\n#define DRD_CONFIG_STATIC_HOST\t\t1\n#define DRD_CONFIG_STATIC_DEVICE\t2\n#define DRD_CONFIG_MASK\t\t\t3\n\n#define DUAL_ROLE_CFG1\t\t\t0x6c\n#define HOST_MODE\t\t\tBIT(29)\n\n#define DUAL_ROLE_CFG1_POLL_TIMEOUT\t1000\n\n#define DRV_NAME\t\t\t\"intel_xhci_usb_sw\"\n\nstruct intel_xhci_usb_data {\n\tstruct device *dev;\n\tstruct usb_role_switch *role_sw;\n\tvoid __iomem *base;\n\tbool enable_sw_switch;\n};\n\nstatic const struct software_node intel_xhci_usb_node = {\n\t\"intel-xhci-usb-sw\",\n};\n\nstatic int intel_xhci_usb_set_role(struct usb_role_switch *sw,\n\t\t\t\t   enum usb_role role)\n{\n\tstruct intel_xhci_usb_data *data = usb_role_switch_get_drvdata(sw);\n\tunsigned long timeout;\n\tacpi_status status;\n\tu32 glk, val;\n\tu32 drd_config = DRD_CONFIG_DYNAMIC;\n\n\t \n\tstatus = acpi_acquire_global_lock(ACPI_WAIT_FOREVER, &glk);\n\tif (ACPI_FAILURE(status) && status != AE_NOT_CONFIGURED) {\n\t\tdev_err(data->dev, \"Error could not acquire lock\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpm_runtime_get_sync(data->dev);\n\n\t \n\tval = readl(data->base + DUAL_ROLE_CFG0);\n\tswitch (role) {\n\tcase USB_ROLE_NONE:\n\t\tval |= SW_IDPIN;\n\t\tval &= ~SW_VBUS_VALID;\n\t\tdrd_config = DRD_CONFIG_DYNAMIC;\n\t\tbreak;\n\tcase USB_ROLE_HOST:\n\t\tval &= ~SW_IDPIN;\n\t\tval &= ~SW_VBUS_VALID;\n\t\tdrd_config = DRD_CONFIG_STATIC_HOST;\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tval |= SW_IDPIN;\n\t\tval |= SW_VBUS_VALID;\n\t\tdrd_config = DRD_CONFIG_STATIC_DEVICE;\n\t\tbreak;\n\t}\n\tval |= SW_IDPIN_EN;\n\tif (data->enable_sw_switch) {\n\t\tval &= ~DRD_CONFIG_MASK;\n\t\tval |= SW_SWITCH_EN | drd_config;\n\t}\n\twritel(val, data->base + DUAL_ROLE_CFG0);\n\n\tacpi_release_global_lock(glk);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(DUAL_ROLE_CFG1_POLL_TIMEOUT);\n\n\t \n\tdo {\n\t\tval = readl(data->base + DUAL_ROLE_CFG1);\n\t\tif (!!(val & HOST_MODE) == (role == USB_ROLE_HOST)) {\n\t\t\tpm_runtime_put(data->dev);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tusleep_range(5000, 10000);\n\t} while (time_before(jiffies, timeout));\n\n\tpm_runtime_put(data->dev);\n\n\tdev_warn(data->dev, \"Timeout waiting for role-switch\\n\");\n\treturn -ETIMEDOUT;\n}\n\nstatic enum usb_role intel_xhci_usb_get_role(struct usb_role_switch *sw)\n{\n\tstruct intel_xhci_usb_data *data = usb_role_switch_get_drvdata(sw);\n\tenum usb_role role;\n\tu32 val;\n\n\tpm_runtime_get_sync(data->dev);\n\tval = readl(data->base + DUAL_ROLE_CFG0);\n\tpm_runtime_put(data->dev);\n\n\tif (!(val & SW_IDPIN))\n\t\trole = USB_ROLE_HOST;\n\telse if (val & SW_VBUS_VALID)\n\t\trole = USB_ROLE_DEVICE;\n\telse\n\t\trole = USB_ROLE_NONE;\n\n\treturn role;\n}\n\nstatic int intel_xhci_usb_probe(struct platform_device *pdev)\n{\n\tstruct usb_role_switch_desc sw_desc = { };\n\tstruct device *dev = &pdev->dev;\n\tstruct intel_xhci_usb_data *data;\n\tstruct resource *res;\n\tint ret;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\tdata->base = devm_ioremap(dev, res->start, resource_size(res));\n\tif (!data->base)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tret = software_node_register(&intel_xhci_usb_node);\n\tif (ret)\n\t\treturn ret;\n\n\tsw_desc.set = intel_xhci_usb_set_role,\n\tsw_desc.get = intel_xhci_usb_get_role,\n\tsw_desc.allow_userspace_control = true,\n\tsw_desc.fwnode = software_node_fwnode(&intel_xhci_usb_node);\n\tsw_desc.driver_data = data;\n\n\tdata->dev = dev;\n\tdata->enable_sw_switch = !device_property_read_bool(dev,\n\t\t\t\t\t\t\"sw_switch_disable\");\n\n\tdata->role_sw = usb_role_switch_register(dev, &sw_desc);\n\tif (IS_ERR(data->role_sw)) {\n\t\tfwnode_handle_put(sw_desc.fwnode);\n\t\treturn PTR_ERR(data->role_sw);\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic void intel_xhci_usb_remove(struct platform_device *pdev)\n{\n\tstruct intel_xhci_usb_data *data = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tusb_role_switch_unregister(data->role_sw);\n\tfwnode_handle_put(software_node_fwnode(&intel_xhci_usb_node));\n}\n\nstatic const struct platform_device_id intel_xhci_usb_table[] = {\n\t{ .name = DRV_NAME },\n\t{}\n};\nMODULE_DEVICE_TABLE(platform, intel_xhci_usb_table);\n\nstatic struct platform_driver intel_xhci_usb_driver = {\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t},\n\t.id_table = intel_xhci_usb_table,\n\t.probe = intel_xhci_usb_probe,\n\t.remove_new = intel_xhci_usb_remove,\n};\n\nmodule_platform_driver(intel_xhci_usb_driver);\n\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_DESCRIPTION(\"Intel XHCI USB role switch driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}