{
  "module_name": "class.c",
  "hash_id": "e7b44b0e9ccf42d8f7c41a057afc66029ed977c89545231bed9aba803de0b9fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/roles/class.c",
  "human_readable_source": "\n \n\n#include <linux/usb/role.h>\n#include <linux/property.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\nstatic const struct class role_class = {\n\t.name = \"usb_role\",\n};\n\nstruct usb_role_switch {\n\tstruct device dev;\n\tstruct mutex lock;  \n\tenum usb_role role;\n\n\t \n\tstruct device *usb2_port;\n\tstruct device *usb3_port;\n\tstruct device *udc;\n\tusb_role_switch_set_t set;\n\tusb_role_switch_get_t get;\n\tbool allow_userspace_control;\n};\n\n#define to_role_switch(d)\tcontainer_of(d, struct usb_role_switch, dev)\n\n \nint usb_role_switch_set_role(struct usb_role_switch *sw, enum usb_role role)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(sw))\n\t\treturn 0;\n\n\tmutex_lock(&sw->lock);\n\n\tret = sw->set(sw, role);\n\tif (!ret) {\n\t\tsw->role = role;\n\t\tkobject_uevent(&sw->dev.kobj, KOBJ_CHANGE);\n\t}\n\n\tmutex_unlock(&sw->lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_set_role);\n\n \nenum usb_role usb_role_switch_get_role(struct usb_role_switch *sw)\n{\n\tenum usb_role role;\n\n\tif (IS_ERR_OR_NULL(sw))\n\t\treturn USB_ROLE_NONE;\n\n\tmutex_lock(&sw->lock);\n\n\tif (sw->get)\n\t\trole = sw->get(sw);\n\telse\n\t\trole = sw->role;\n\n\tmutex_unlock(&sw->lock);\n\n\treturn role;\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_get_role);\n\nstatic void *usb_role_switch_match(const struct fwnode_handle *fwnode, const char *id,\n\t\t\t\t   void *data)\n{\n\tstruct device *dev;\n\n\tif (id && !fwnode_property_present(fwnode, id))\n\t\treturn NULL;\n\n\tdev = class_find_device_by_fwnode(&role_class, fwnode);\n\n\treturn dev ? to_role_switch(dev) : ERR_PTR(-EPROBE_DEFER);\n}\n\nstatic struct usb_role_switch *\nusb_role_switch_is_parent(struct fwnode_handle *fwnode)\n{\n\tstruct fwnode_handle *parent = fwnode_get_parent(fwnode);\n\tstruct device *dev;\n\n\tif (!fwnode_property_present(parent, \"usb-role-switch\")) {\n\t\tfwnode_handle_put(parent);\n\t\treturn NULL;\n\t}\n\n\tdev = class_find_device_by_fwnode(&role_class, parent);\n\tfwnode_handle_put(parent);\n\treturn dev ? to_role_switch(dev) : ERR_PTR(-EPROBE_DEFER);\n}\n\n \nstruct usb_role_switch *usb_role_switch_get(struct device *dev)\n{\n\tstruct usb_role_switch *sw;\n\n\tsw = usb_role_switch_is_parent(dev_fwnode(dev));\n\tif (!sw)\n\t\tsw = device_connection_find_match(dev, \"usb-role-switch\", NULL,\n\t\t\t\t\t\t  usb_role_switch_match);\n\n\tif (!IS_ERR_OR_NULL(sw))\n\t\tWARN_ON(!try_module_get(sw->dev.parent->driver->owner));\n\n\treturn sw;\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_get);\n\n \nstruct usb_role_switch *fwnode_usb_role_switch_get(struct fwnode_handle *fwnode)\n{\n\tstruct usb_role_switch *sw;\n\n\tsw = usb_role_switch_is_parent(fwnode);\n\tif (!sw)\n\t\tsw = fwnode_connection_find_match(fwnode, \"usb-role-switch\",\n\t\t\t\t\t\t  NULL, usb_role_switch_match);\n\tif (!IS_ERR_OR_NULL(sw))\n\t\tWARN_ON(!try_module_get(sw->dev.parent->driver->owner));\n\n\treturn sw;\n}\nEXPORT_SYMBOL_GPL(fwnode_usb_role_switch_get);\n\n \nvoid usb_role_switch_put(struct usb_role_switch *sw)\n{\n\tif (!IS_ERR_OR_NULL(sw)) {\n\t\tmodule_put(sw->dev.parent->driver->owner);\n\t\tput_device(&sw->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_put);\n\n \nstruct usb_role_switch *\nusb_role_switch_find_by_fwnode(const struct fwnode_handle *fwnode)\n{\n\tstruct device *dev;\n\n\tif (!fwnode)\n\t\treturn NULL;\n\n\tdev = class_find_device_by_fwnode(&role_class, fwnode);\n\tif (dev)\n\t\tWARN_ON(!try_module_get(dev->parent->driver->owner));\n\n\treturn dev ? to_role_switch(dev) : NULL;\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_find_by_fwnode);\n\nstatic umode_t\nusb_role_switch_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_role_switch *sw = to_role_switch(dev);\n\n\tif (sw->allow_userspace_control)\n\t\treturn attr->mode;\n\n\treturn 0;\n}\n\nstatic const char * const usb_roles[] = {\n\t[USB_ROLE_NONE]\t\t= \"none\",\n\t[USB_ROLE_HOST]\t\t= \"host\",\n\t[USB_ROLE_DEVICE]\t= \"device\",\n};\n\nconst char *usb_role_string(enum usb_role role)\n{\n\tif (role < 0 || role >= ARRAY_SIZE(usb_roles))\n\t\treturn \"unknown\";\n\n\treturn usb_roles[role];\n}\nEXPORT_SYMBOL_GPL(usb_role_string);\n\nstatic ssize_t\nrole_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_role_switch *sw = to_role_switch(dev);\n\tenum usb_role role = usb_role_switch_get_role(sw);\n\n\treturn sprintf(buf, \"%s\\n\", usb_roles[role]);\n}\n\nstatic ssize_t role_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t size)\n{\n\tstruct usb_role_switch *sw = to_role_switch(dev);\n\tint ret;\n\n\tret = sysfs_match_string(usb_roles, buf);\n\tif (ret < 0) {\n\t\tbool res;\n\n\t\t \n\t\tret = kstrtobool(buf, &res);\n\t\tif (ret || res)\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = usb_role_switch_set_role(sw, ret);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(role);\n\nstatic struct attribute *usb_role_switch_attrs[] = {\n\t&dev_attr_role.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group usb_role_switch_group = {\n\t.is_visible = usb_role_switch_is_visible,\n\t.attrs = usb_role_switch_attrs,\n};\n\nstatic const struct attribute_group *usb_role_switch_groups[] = {\n\t&usb_role_switch_group,\n\tNULL,\n};\n\nstatic int usb_role_switch_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint ret;\n\n\tret = add_uevent_var(env, \"USB_ROLE_SWITCH=%s\", dev_name(dev));\n\tif (ret)\n\t\tdev_err(dev, \"failed to add uevent USB_ROLE_SWITCH\\n\");\n\n\treturn ret;\n}\n\nstatic void usb_role_switch_release(struct device *dev)\n{\n\tstruct usb_role_switch *sw = to_role_switch(dev);\n\n\tkfree(sw);\n}\n\nstatic const struct device_type usb_role_dev_type = {\n\t.name = \"usb_role_switch\",\n\t.groups = usb_role_switch_groups,\n\t.uevent = usb_role_switch_uevent,\n\t.release = usb_role_switch_release,\n};\n\n \nstruct usb_role_switch *\nusb_role_switch_register(struct device *parent,\n\t\t\t const struct usb_role_switch_desc *desc)\n{\n\tstruct usb_role_switch *sw;\n\tint ret;\n\n\tif (!desc || !desc->set)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsw = kzalloc(sizeof(*sw), GFP_KERNEL);\n\tif (!sw)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&sw->lock);\n\n\tsw->allow_userspace_control = desc->allow_userspace_control;\n\tsw->usb2_port = desc->usb2_port;\n\tsw->usb3_port = desc->usb3_port;\n\tsw->udc = desc->udc;\n\tsw->set = desc->set;\n\tsw->get = desc->get;\n\n\tsw->dev.parent = parent;\n\tsw->dev.fwnode = desc->fwnode;\n\tsw->dev.class = &role_class;\n\tsw->dev.type = &usb_role_dev_type;\n\tdev_set_drvdata(&sw->dev, desc->driver_data);\n\tdev_set_name(&sw->dev, \"%s-role-switch\",\n\t\t     desc->name ? desc->name : dev_name(parent));\n\n\tret = device_register(&sw->dev);\n\tif (ret) {\n\t\tput_device(&sw->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\n\treturn sw;\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_register);\n\n \nvoid usb_role_switch_unregister(struct usb_role_switch *sw)\n{\n\tif (!IS_ERR_OR_NULL(sw))\n\t\tdevice_unregister(&sw->dev);\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_unregister);\n\n \nvoid usb_role_switch_set_drvdata(struct usb_role_switch *sw, void *data)\n{\n\tdev_set_drvdata(&sw->dev, data);\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_set_drvdata);\n\n \nvoid *usb_role_switch_get_drvdata(struct usb_role_switch *sw)\n{\n\treturn dev_get_drvdata(&sw->dev);\n}\nEXPORT_SYMBOL_GPL(usb_role_switch_get_drvdata);\n\nstatic int __init usb_roles_init(void)\n{\n\treturn class_register(&role_class);\n}\nsubsys_initcall(usb_roles_init);\n\nstatic void __exit usb_roles_exit(void)\n{\n\tclass_unregister(&role_class);\n}\nmodule_exit(usb_roles_exit);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"USB Role Class\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}