{
  "module_name": "ehci-dbgp.c",
  "hash_id": "c04ac799f4848095e1cdbf6e0670f9f58852cc65c9abdcefe234d48363363ab5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/early/ehci-dbgp.c",
  "human_readable_source": "\n \n\n#include <linux/console.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/pci_regs.h>\n#include <linux/pci_ids.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/ehci_def.h>\n#include <linux/delay.h>\n#include <linux/serial_core.h>\n#include <linux/kgdb.h>\n#include <linux/kthread.h>\n#include <asm/io.h>\n#include <asm/pci-direct.h>\n#include <asm/fixmap.h>\n\n \n\nstatic int dbgp_phys_port = 1;\n\nstatic struct ehci_caps __iomem *ehci_caps;\nstatic struct ehci_regs __iomem *ehci_regs;\nstatic struct ehci_dbg_port __iomem *ehci_debug;\nstatic int dbgp_not_safe;  \nstatic unsigned int dbgp_endpoint_out;\nstatic unsigned int dbgp_endpoint_in;\n\nstruct ehci_dev {\n\tu32 bus;\n\tu32 slot;\n\tu32 func;\n};\n\nstatic struct ehci_dev ehci_dev;\n\n#define USB_DEBUG_DEVNUM 127\n\n#ifdef DBGP_DEBUG\n#define dbgp_printk printk\nstatic void dbgp_ehci_status(char *str)\n{\n\tif (!ehci_debug)\n\t\treturn;\n\tdbgp_printk(\"dbgp: %s\\n\", str);\n\tdbgp_printk(\"  Debug control: %08x\", readl(&ehci_debug->control));\n\tdbgp_printk(\"  ehci cmd     : %08x\", readl(&ehci_regs->command));\n\tdbgp_printk(\"  ehci conf flg: %08x\\n\",\n\t\t    readl(&ehci_regs->configured_flag));\n\tdbgp_printk(\"  ehci status  : %08x\", readl(&ehci_regs->status));\n\tdbgp_printk(\"  ehci portsc  : %08x\\n\",\n\t\t    readl(&ehci_regs->port_status[dbgp_phys_port - 1]));\n}\n#else\nstatic inline void dbgp_ehci_status(char *str) { }\nstatic inline void dbgp_printk(const char *fmt, ...) { }\n#endif\n\nstatic inline u32 dbgp_len_update(u32 x, u32 len)\n{\n\treturn (x & ~0x0f) | (len & 0x0f);\n}\n\n#ifdef CONFIG_KGDB\nstatic struct kgdb_io kgdbdbgp_io_ops;\n#define dbgp_kgdb_mode (dbg_io_ops == &kgdbdbgp_io_ops)\n#else\n#define dbgp_kgdb_mode (0)\n#endif\n\n \n#define EARLY_HC_LENGTH(p)\t(0x00ff & (p))  \n\n \n\n \n#define USB_PID_OUT\t\t0xe1\n#define USB_PID_IN\t\t0x69\n#define USB_PID_SOF\t\t0xa5\n#define USB_PID_SETUP\t\t0x2d\n \n#define USB_PID_ACK\t\t0xd2\n#define USB_PID_NAK\t\t0x5a\n#define USB_PID_STALL\t\t0x1e\n#define USB_PID_NYET\t\t0x96\n \n#define USB_PID_DATA0\t\t0xc3\n#define USB_PID_DATA1\t\t0x4b\n#define USB_PID_DATA2\t\t0x87\n#define USB_PID_MDATA\t\t0x0f\n \n#define USB_PID_PREAMBLE\t0x3c\n#define USB_PID_ERR\t\t0x3c\n#define USB_PID_SPLIT\t\t0x78\n#define USB_PID_PING\t\t0xb4\n#define USB_PID_UNDEF_0\t\t0xf0\n\n#define USB_PID_DATA_TOGGLE\t0x88\n#define DBGP_CLAIM (DBGP_OWNER | DBGP_ENABLED | DBGP_INUSE)\n\n#define PCI_CAP_ID_EHCI_DEBUG\t0xa\n\n#define HUB_ROOT_RESET_TIME\t50\t \n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t500\n\n#define DBGP_MAX_PACKET\t\t8\n#define DBGP_TIMEOUT\t\t(250 * 1000)\n#define DBGP_LOOPS\t\t1000\n\nstatic inline u32 dbgp_pid_write_update(u32 x, u32 tok)\n{\n\tstatic int data0 = USB_PID_DATA1;\n\tdata0 ^= USB_PID_DATA_TOGGLE;\n\treturn (x & 0xffff0000) | (data0 << 8) | (tok & 0xff);\n}\n\nstatic inline u32 dbgp_pid_read_update(u32 x, u32 tok)\n{\n\treturn (x & 0xffff0000) | (USB_PID_DATA0 << 8) | (tok & 0xff);\n}\n\nstatic int dbgp_wait_until_complete(void)\n{\n\tu32 ctrl;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(&ehci_debug->control, ctrl,\n\t\t\t\t(ctrl & DBGP_DONE), 1, DBGP_TIMEOUT);\n\tif (ret)\n\t\treturn -DBGP_TIMEOUT;\n\n\t \n\twritel(ctrl | DBGP_DONE, &ehci_debug->control);\n\treturn (ctrl & DBGP_ERROR) ? -DBGP_ERRCODE(ctrl) : DBGP_LEN(ctrl);\n}\n\nstatic inline void dbgp_mdelay(int ms)\n{\n\tint i;\n\n\twhile (ms--) {\n\t\tfor (i = 0; i < 1000; i++)\n\t\t\toutb(0x1, 0x80);\n\t}\n}\n\nstatic void dbgp_breath(void)\n{\n\t \n}\n\nstatic int dbgp_wait_until_done(unsigned ctrl, int loop)\n{\n\tu32 pids, lpid;\n\tint ret;\n\nretry:\n\twritel(ctrl | DBGP_GO, &ehci_debug->control);\n\tret = dbgp_wait_until_complete();\n\tpids = readl(&ehci_debug->pids);\n\tlpid = DBGP_PID_GET(pids);\n\n\tif (ret < 0) {\n\t\t \n\t\tif (ret == -DBGP_TIMEOUT && !dbgp_not_safe)\n\t\t\tdbgp_not_safe = 1;\n\t\tif (ret == -DBGP_ERR_BAD && --loop > 0)\n\t\t\tgoto retry;\n\t\treturn ret;\n\t}\n\n\t \n\tif ((lpid == USB_PID_NAK) || (lpid == USB_PID_NYET))\n\t\tdbgp_breath();\n\n\t \n\tif (lpid == USB_PID_NAK) {\n\t\tif (--loop > 0)\n\t\t\tgoto retry;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void dbgp_set_data(const void *buf, int size)\n{\n\tconst unsigned char *bytes = buf;\n\tu32 lo, hi;\n\tint i;\n\n\tlo = hi = 0;\n\tfor (i = 0; i < 4 && i < size; i++)\n\t\tlo |= bytes[i] << (8*i);\n\tfor (; i < 8 && i < size; i++)\n\t\thi |= bytes[i] << (8*(i - 4));\n\twritel(lo, &ehci_debug->data03);\n\twritel(hi, &ehci_debug->data47);\n}\n\nstatic inline void dbgp_get_data(void *buf, int size)\n{\n\tunsigned char *bytes = buf;\n\tu32 lo, hi;\n\tint i;\n\n\tlo = readl(&ehci_debug->data03);\n\thi = readl(&ehci_debug->data47);\n\tfor (i = 0; i < 4 && i < size; i++)\n\t\tbytes[i] = (lo >> (8*i)) & 0xff;\n\tfor (; i < 8 && i < size; i++)\n\t\tbytes[i] = (hi >> (8*(i - 4))) & 0xff;\n}\n\nstatic int dbgp_bulk_write(unsigned devnum, unsigned endpoint,\n\t\t\t const char *bytes, int size)\n{\n\tint ret;\n\tu32 addr;\n\tu32 pids, ctrl;\n\n\tif (size > DBGP_MAX_PACKET)\n\t\treturn -1;\n\n\taddr = DBGP_EPADDR(devnum, endpoint);\n\n\tpids = readl(&ehci_debug->pids);\n\tpids = dbgp_pid_write_update(pids, USB_PID_OUT);\n\n\tctrl = readl(&ehci_debug->control);\n\tctrl = dbgp_len_update(ctrl, size);\n\tctrl |= DBGP_OUT;\n\tctrl |= DBGP_GO;\n\n\tdbgp_set_data(bytes, size);\n\twritel(addr, &ehci_debug->address);\n\twritel(pids, &ehci_debug->pids);\n\tret = dbgp_wait_until_done(ctrl, DBGP_LOOPS);\n\n\treturn ret;\n}\n\nstatic int dbgp_bulk_read(unsigned devnum, unsigned endpoint, void *data,\n\t\t\t  int size, int loops)\n{\n\tu32 pids, addr, ctrl;\n\tint ret;\n\n\tif (size > DBGP_MAX_PACKET)\n\t\treturn -1;\n\n\taddr = DBGP_EPADDR(devnum, endpoint);\n\n\tpids = readl(&ehci_debug->pids);\n\tpids = dbgp_pid_read_update(pids, USB_PID_IN);\n\n\tctrl = readl(&ehci_debug->control);\n\tctrl = dbgp_len_update(ctrl, size);\n\tctrl &= ~DBGP_OUT;\n\tctrl |= DBGP_GO;\n\n\twritel(addr, &ehci_debug->address);\n\twritel(pids, &ehci_debug->pids);\n\tret = dbgp_wait_until_done(ctrl, loops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (size > ret)\n\t\tsize = ret;\n\tdbgp_get_data(data, size);\n\treturn ret;\n}\n\nstatic int dbgp_control_msg(unsigned devnum, int requesttype,\n\tint request, int value, int index, void *data, int size)\n{\n\tu32 pids, addr, ctrl;\n\tstruct usb_ctrlrequest req;\n\tint read;\n\tint ret;\n\n\tread = (requesttype & USB_DIR_IN) != 0;\n\tif (size > (read ? DBGP_MAX_PACKET : 0))\n\t\treturn -1;\n\n\t \n\treq.bRequestType = requesttype;\n\treq.bRequest = request;\n\treq.wValue = cpu_to_le16(value);\n\treq.wIndex = cpu_to_le16(index);\n\treq.wLength = cpu_to_le16(size);\n\n\tpids = DBGP_PID_SET(USB_PID_DATA0, USB_PID_SETUP);\n\taddr = DBGP_EPADDR(devnum, 0);\n\n\tctrl = readl(&ehci_debug->control);\n\tctrl = dbgp_len_update(ctrl, sizeof(req));\n\tctrl |= DBGP_OUT;\n\tctrl |= DBGP_GO;\n\n\t \n\tdbgp_set_data(&req, sizeof(req));\n\twritel(addr, &ehci_debug->address);\n\twritel(pids, &ehci_debug->pids);\n\tret = dbgp_wait_until_done(ctrl, DBGP_LOOPS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\treturn dbgp_bulk_read(devnum, 0, data, size, DBGP_LOOPS);\n}\n\n \nstatic u32 __init find_cap(u32 num, u32 slot, u32 func, int cap)\n{\n\tu8 pos;\n\tint bytes;\n\n\tif (!(read_pci_config_16(num, slot, func, PCI_STATUS) &\n\t\tPCI_STATUS_CAP_LIST))\n\t\treturn 0;\n\n\tpos = read_pci_config_byte(num, slot, func, PCI_CAPABILITY_LIST);\n\tfor (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {\n\t\tu8 id;\n\n\t\tpos &= ~3;\n\t\tid = read_pci_config_byte(num, slot, func, pos+PCI_CAP_LIST_ID);\n\t\tif (id == 0xff)\n\t\t\tbreak;\n\t\tif (id == cap)\n\t\t\treturn pos;\n\n\t\tpos = read_pci_config_byte(num, slot, func,\n\t\t\t\t\t\t pos+PCI_CAP_LIST_NEXT);\n\t}\n\treturn 0;\n}\n\nstatic u32 __init __find_dbgp(u32 bus, u32 slot, u32 func)\n{\n\tu32 class;\n\n\tclass = read_pci_config(bus, slot, func, PCI_CLASS_REVISION);\n\tif ((class >> 8) != PCI_CLASS_SERIAL_USB_EHCI)\n\t\treturn 0;\n\n\treturn find_cap(bus, slot, func, PCI_CAP_ID_EHCI_DEBUG);\n}\n\nstatic u32 __init find_dbgp(int ehci_num, u32 *rbus, u32 *rslot, u32 *rfunc)\n{\n\tu32 bus, slot, func;\n\n\tfor (bus = 0; bus < 256; bus++) {\n\t\tfor (slot = 0; slot < 32; slot++) {\n\t\t\tfor (func = 0; func < 8; func++) {\n\t\t\t\tunsigned cap;\n\n\t\t\t\tcap = __find_dbgp(bus, slot, func);\n\n\t\t\t\tif (!cap)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ehci_num-- != 0)\n\t\t\t\t\tcontinue;\n\t\t\t\t*rbus = bus;\n\t\t\t\t*rslot = slot;\n\t\t\t\t*rfunc = func;\n\t\t\t\treturn cap;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int dbgp_ehci_startup(void)\n{\n\tu32 ctrl, cmd, status;\n\tint loop;\n\n\t \n\tctrl = readl(&ehci_debug->control);\n\tctrl |= DBGP_OWNER;\n\tctrl &= ~(DBGP_ENABLED | DBGP_INUSE);\n\twritel(ctrl, &ehci_debug->control);\n\tudelay(1);\n\n\tdbgp_ehci_status(\"EHCI startup\");\n\t \n\tcmd = readl(&ehci_regs->command);\n\tcmd &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE | CMD_ASE | CMD_RESET);\n\tcmd |= CMD_RUN;\n\twritel(cmd, &ehci_regs->command);\n\n\t \n\twritel(FLAG_CF, &ehci_regs->configured_flag);\n\n\t \n\tloop = 1000;\n\tdo {\n\t\tstatus = readl(&ehci_regs->status);\n\t\tif (!(status & STS_HALT))\n\t\t\tbreak;\n\t\tudelay(1);\n\t} while (--loop > 0);\n\n\tif (!loop) {\n\t\tdbgp_printk(\"ehci can not be started\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdbgp_printk(\"ehci started\\n\");\n\treturn 0;\n}\n\nstatic int dbgp_ehci_controller_reset(void)\n{\n\tint loop = 250 * 1000;\n\tu32 cmd;\n\n\t \n\tcmd = readl(&ehci_regs->command);\n\tcmd |= CMD_RESET;\n\twritel(cmd, &ehci_regs->command);\n\tdo {\n\t\tcmd = readl(&ehci_regs->command);\n\t} while ((cmd & CMD_RESET) && (--loop > 0));\n\n\tif (!loop) {\n\t\tdbgp_printk(\"can not reset ehci\\n\");\n\t\treturn -1;\n\t}\n\tdbgp_ehci_status(\"ehci reset done\");\n\treturn 0;\n}\nstatic int ehci_wait_for_port(int port);\n \nstatic int _dbgp_external_startup(void)\n{\n\tint devnum;\n\tstruct usb_debug_descriptor dbgp_desc;\n\tint ret;\n\tu32 ctrl, portsc, cmd;\n\tint dbg_port = dbgp_phys_port;\n\tint tries = 3;\n\tint reset_port_tries = 1;\n\tint try_hard_once = 1;\n\ntry_port_reset_again:\n\tret = dbgp_ehci_startup();\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ehci_wait_for_port(dbg_port);\n\tif (ret < 0) {\n\t\tportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\n\t\tif (!(portsc & PORT_CONNECT) && try_hard_once) {\n\t\t\t \n\t\t\ttry_hard_once = 0;\n\t\t\tcmd = readl(&ehci_regs->command);\n\t\t\tcmd &= ~CMD_RUN;\n\t\t\twritel(cmd, &ehci_regs->command);\n\t\t\tportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\n\t\t\tportsc |= PORT_TEST_PKT;\n\t\t\twritel(portsc, &ehci_regs->port_status[dbg_port - 1]);\n\t\t\tdbgp_ehci_status(\"Trying to force debug port online\");\n\t\t\tmdelay(50);\n\t\t\tdbgp_ehci_controller_reset();\n\t\t\tgoto try_port_reset_again;\n\t\t} else if (reset_port_tries--) {\n\t\t\tgoto try_port_reset_again;\n\t\t}\n\t\tdbgp_printk(\"No device found in debug port\\n\");\n\t\treturn -EIO;\n\t}\n\tdbgp_ehci_status(\"wait for port done\");\n\n\t \n\tctrl = readl(&ehci_debug->control);\n\tctrl |= DBGP_CLAIM;\n\twritel(ctrl, &ehci_debug->control);\n\tctrl = readl(&ehci_debug->control);\n\tif ((ctrl & DBGP_CLAIM) != DBGP_CLAIM) {\n\t\tdbgp_printk(\"No device in debug port\\n\");\n\t\twritel(ctrl & ~DBGP_CLAIM, &ehci_debug->control);\n\t\treturn -ENODEV;\n\t}\n\tdbgp_ehci_status(\"debug ported enabled\");\n\n\t \n\tportsc = readl(&ehci_regs->port_status[dbg_port - 1]);\n\tportsc &= ~PORT_PE;\n\twritel(portsc, &ehci_regs->port_status[dbg_port - 1]);\n\n\tdbgp_mdelay(100);\n\ntry_again:\n\t \n\tfor (devnum = 0; devnum <= 127; devnum++) {\n\t\tret = dbgp_control_msg(devnum,\n\t\t\tUSB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\tUSB_REQ_GET_DESCRIPTOR, (USB_DT_DEBUG << 8), 0,\n\t\t\t&dbgp_desc, sizeof(dbgp_desc));\n\t\tif (ret > 0)\n\t\t\tbreak;\n\t}\n\tif (devnum > 127) {\n\t\tdbgp_printk(\"Could not find attached debug device\\n\");\n\t\tgoto err;\n\t}\n\tdbgp_endpoint_out = dbgp_desc.bDebugOutEndpoint;\n\tdbgp_endpoint_in = dbgp_desc.bDebugInEndpoint;\n\n\t \n\tif (devnum != USB_DEBUG_DEVNUM) {\n\t\tret = dbgp_control_msg(devnum,\n\t\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\tUSB_REQ_SET_ADDRESS, USB_DEBUG_DEVNUM, 0, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tdbgp_printk(\"Could not move attached device to %d\\n\",\n\t\t\t\tUSB_DEBUG_DEVNUM);\n\t\t\tgoto err;\n\t\t}\n\t\tdbgp_printk(\"debug device renamed to 127\\n\");\n\t}\n\n\t \n\tret = dbgp_control_msg(USB_DEBUG_DEVNUM,\n\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\tUSB_REQ_SET_FEATURE, USB_DEVICE_DEBUG_MODE, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tdbgp_printk(\" Could not enable the debug device\\n\");\n\t\tgoto err;\n\t}\n\tdbgp_printk(\"debug interface enabled\\n\");\n\t \n\tret = dbgp_bulk_write(USB_DEBUG_DEVNUM, dbgp_endpoint_out, \" \", 1);\n\tif (ret < 0) {\n\t\tdbgp_printk(\"dbgp_bulk_write failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\tdbgp_printk(\"small write done\\n\");\n\tdbgp_not_safe = 0;\n\n\treturn 0;\nerr:\n\tif (tries--)\n\t\tgoto try_again;\n\treturn -ENODEV;\n}\n\nstatic int ehci_reset_port(int port)\n{\n\tu32 portsc;\n\tu32 delay_time, delay;\n\tint loop;\n\n\tdbgp_ehci_status(\"reset port\");\n\t \n\tportsc = readl(&ehci_regs->port_status[port - 1]);\n\tportsc &= ~PORT_PE;\n\tportsc |= PORT_RESET;\n\twritel(portsc, &ehci_regs->port_status[port - 1]);\n\n\tdelay = HUB_ROOT_RESET_TIME;\n\tfor (delay_time = 0; delay_time < HUB_RESET_TIMEOUT;\n\t     delay_time += delay) {\n\t\tdbgp_mdelay(delay);\n\t\tportsc = readl(&ehci_regs->port_status[port - 1]);\n\t\tif (!(portsc & PORT_RESET))\n\t\t\tbreak;\n\t}\n\tif (portsc & PORT_RESET) {\n\t\t \n\t\tloop = 100 * 1000;\n\t\twritel(portsc & ~(PORT_RWC_BITS | PORT_RESET),\n\t\t\t&ehci_regs->port_status[port - 1]);\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tportsc = readl(&ehci_regs->port_status[port-1]);\n\t\t} while ((portsc & PORT_RESET) && (--loop > 0));\n\t}\n\n\t \n\tif (!(portsc & PORT_CONNECT))\n\t\treturn -ENOTCONN;\n\n\t \n\tif ((portsc & PORT_CSC))\n\t\treturn -EINVAL;\n\n\t \n\tif (!(portsc & PORT_RESET) && (portsc & PORT_PE))\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic int ehci_wait_for_port(int port)\n{\n\tu32 status;\n\tint ret, reps;\n\n\tfor (reps = 0; reps < 300; reps++) {\n\t\tstatus = readl(&ehci_regs->status);\n\t\tif (status & STS_PCD)\n\t\t\tbreak;\n\t\tdbgp_mdelay(1);\n\t}\n\tret = ehci_reset_port(port);\n\tif (ret == 0)\n\t\treturn 0;\n\treturn -ENOTCONN;\n}\n\ntypedef void (*set_debug_port_t)(int port);\n\nstatic void __init default_set_debug_port(int port)\n{\n}\n\nstatic set_debug_port_t __initdata set_debug_port = default_set_debug_port;\n\nstatic void __init nvidia_set_debug_port(int port)\n{\n\tu32 dword;\n\tdword = read_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\n\t\t\t\t 0x74);\n\tdword &= ~(0x0f<<12);\n\tdword |= ((port & 0x0f)<<12);\n\twrite_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func, 0x74,\n\t\t\t\t dword);\n\tdbgp_printk(\"set debug port to %d\\n\", port);\n}\n\nstatic void __init detect_set_debug_port(void)\n{\n\tu32 vendorid;\n\n\tvendorid = read_pci_config(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\n\t\t 0x00);\n\n\tif ((vendorid & 0xffff) == 0x10de) {\n\t\tdbgp_printk(\"using nvidia set_debug_port\\n\");\n\t\tset_debug_port = nvidia_set_debug_port;\n\t}\n}\n\n \n#define EHCI_USBLEGSUP_BIOS\t(1 << 16)\t \n#define EHCI_USBLEGCTLSTS\t4\t\t \nstatic void __init early_ehci_bios_handoff(void)\n{\n\tu32 hcc_params = readl(&ehci_caps->hcc_params);\n\tint offset = (hcc_params >> 8) & 0xff;\n\tu32 cap;\n\tint msec;\n\n\tif (!offset)\n\t\treturn;\n\n\tcap = read_pci_config(ehci_dev.bus, ehci_dev.slot,\n\t\t\t      ehci_dev.func, offset);\n\tdbgp_printk(\"dbgp: ehci BIOS state %08x\\n\", cap);\n\n\tif ((cap & 0xff) == 1 && (cap & EHCI_USBLEGSUP_BIOS)) {\n\t\tdbgp_printk(\"dbgp: BIOS handoff\\n\");\n\t\twrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot,\n\t\t\t\t      ehci_dev.func, offset + 3, 1);\n\t}\n\n\t \n\tmsec = 1000;\n\twhile ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {\n\t\tmdelay(10);\n\t\tmsec -= 10;\n\t\tcap = read_pci_config(ehci_dev.bus, ehci_dev.slot,\n\t\t\t\t      ehci_dev.func, offset);\n\t}\n\n\tif (cap & EHCI_USBLEGSUP_BIOS) {\n\t\t \n\t\tdbgp_printk(\"dbgp: BIOS handoff failed: %08x\\n\", cap);\n\t\twrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot,\n\t\t\t\t      ehci_dev.func, offset + 2, 0);\n\t}\n\n\t \n\twrite_pci_config_byte(ehci_dev.bus, ehci_dev.slot, ehci_dev.func,\n\t\t\t      offset + EHCI_USBLEGCTLSTS, 0);\n}\n\nstatic int __init ehci_setup(void)\n{\n\tu32 ctrl, portsc, hcs_params;\n\tu32 debug_port, new_debug_port = 0, n_ports;\n\tint ret, i;\n\tint port_map_tried;\n\tint playtimes = 3;\n\n\tearly_ehci_bios_handoff();\n\ntry_next_time:\n\tport_map_tried = 0;\n\ntry_next_port:\n\n\thcs_params = readl(&ehci_caps->hcs_params);\n\tdebug_port = HCS_DEBUG_PORT(hcs_params);\n\tdbgp_phys_port = debug_port;\n\tn_ports    = HCS_N_PORTS(hcs_params);\n\n\tdbgp_printk(\"debug_port: %d\\n\", debug_port);\n\tdbgp_printk(\"n_ports:    %d\\n\", n_ports);\n\tdbgp_ehci_status(\"\");\n\n\tfor (i = 1; i <= n_ports; i++) {\n\t\tportsc = readl(&ehci_regs->port_status[i-1]);\n\t\tdbgp_printk(\"portstatus%d: %08x\\n\", i, portsc);\n\t}\n\n\tif (port_map_tried && (new_debug_port != debug_port)) {\n\t\tif (--playtimes) {\n\t\t\tset_debug_port(new_debug_port);\n\t\t\tgoto try_next_time;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t \n\tif (!(readl(&ehci_regs->configured_flag) & FLAG_CF)) {\n\t\tif (dbgp_ehci_controller_reset() != 0)\n\t\t\treturn -1;\n\t} else {\n\t\tdbgp_ehci_status(\"ehci skip - already configured\");\n\t}\n\n\tret = _dbgp_external_startup();\n\tif (ret == -EIO)\n\t\tgoto next_debug_port;\n\n\tif (ret < 0) {\n\t\t \n\t\tctrl = readl(&ehci_debug->control);\n\t\tctrl &= ~(DBGP_CLAIM | DBGP_OUT);\n\t\twritel(ctrl, &ehci_debug->control);\n\t\treturn -1;\n\t}\n\treturn 0;\n\nnext_debug_port:\n\tport_map_tried |= (1<<(debug_port - 1));\n\tnew_debug_port = ((debug_port-1+1)%n_ports) + 1;\n\tif (port_map_tried != ((1<<n_ports) - 1)) {\n\t\tset_debug_port(new_debug_port);\n\t\tgoto try_next_port;\n\t}\n\tif (--playtimes) {\n\t\tset_debug_port(new_debug_port);\n\t\tgoto try_next_time;\n\t}\n\n\treturn -1;\n}\n\nint __init early_dbgp_init(char *s)\n{\n\tu32 debug_port, bar, offset;\n\tu32 bus, slot, func, cap;\n\tvoid __iomem *ehci_bar;\n\tu32 dbgp_num;\n\tu32 bar_val;\n\tchar *e;\n\tint ret;\n\tu8 byte;\n\n\tif (!early_pci_allowed())\n\t\treturn -1;\n\n\tdbgp_num = 0;\n\tif (*s)\n\t\tdbgp_num = simple_strtoul(s, &e, 10);\n\tdbgp_printk(\"dbgp_num: %d\\n\", dbgp_num);\n\n\tcap = find_dbgp(dbgp_num, &bus, &slot, &func);\n\tif (!cap)\n\t\treturn -1;\n\n\tdbgp_printk(\"Found EHCI debug port on %02x:%02x.%1x\\n\", bus, slot,\n\t\t\t func);\n\n\tdebug_port = read_pci_config(bus, slot, func, cap);\n\tbar = (debug_port >> 29) & 0x7;\n\tbar = (bar * 4) + 0xc;\n\toffset = (debug_port >> 16) & 0xfff;\n\tdbgp_printk(\"bar: %02x offset: %03x\\n\", bar, offset);\n\tif (bar != PCI_BASE_ADDRESS_0) {\n\t\tdbgp_printk(\"only debug ports on bar 1 handled.\\n\");\n\n\t\treturn -1;\n\t}\n\n\tbar_val = read_pci_config(bus, slot, func, PCI_BASE_ADDRESS_0);\n\tdbgp_printk(\"bar_val: %02x offset: %03x\\n\", bar_val, offset);\n\tif (bar_val & ~PCI_BASE_ADDRESS_MEM_MASK) {\n\t\tdbgp_printk(\"only simple 32bit mmio bars supported\\n\");\n\n\t\treturn -1;\n\t}\n\n\t \n\tbyte = read_pci_config_byte(bus, slot, func, 0x04);\n\tif (!(byte & 0x2)) {\n\t\tbyte  |= 0x02;\n\t\twrite_pci_config_byte(bus, slot, func, 0x04, byte);\n\t\tdbgp_printk(\"mmio for ehci enabled\\n\");\n\t}\n\n\t \n\tset_fixmap_nocache(FIX_DBGP_BASE, bar_val & PAGE_MASK);\n\tehci_bar = (void __iomem *)__fix_to_virt(FIX_DBGP_BASE);\n\tehci_bar += bar_val & ~PAGE_MASK;\n\tdbgp_printk(\"ehci_bar: %p\\n\", ehci_bar);\n\n\tehci_caps  = ehci_bar;\n\tehci_regs  = ehci_bar + EARLY_HC_LENGTH(readl(&ehci_caps->hc_capbase));\n\tehci_debug = ehci_bar + offset;\n\tehci_dev.bus = bus;\n\tehci_dev.slot = slot;\n\tehci_dev.func = func;\n\n\tdetect_set_debug_port();\n\n\tret = ehci_setup();\n\tif (ret < 0) {\n\t\tdbgp_printk(\"ehci_setup failed\\n\");\n\t\tehci_debug = NULL;\n\n\t\treturn -1;\n\t}\n\tdbgp_ehci_status(\"early_init_complete\");\n\n\treturn 0;\n}\n\nstatic void early_dbgp_write(struct console *con, const char *str, u32 n)\n{\n\tint chunk;\n\tchar buf[DBGP_MAX_PACKET];\n\tint use_cr = 0;\n\tu32 cmd, ctrl;\n\tint reset_run = 0;\n\n\tif (!ehci_debug || dbgp_not_safe)\n\t\treturn;\n\n\tcmd = readl(&ehci_regs->command);\n\tif (unlikely(!(cmd & CMD_RUN))) {\n\t\t \n\t\tctrl = readl(&ehci_debug->control);\n\t\tif (!(ctrl & DBGP_ENABLED)) {\n\t\t\tdbgp_not_safe = 1;\n\t\t\t_dbgp_external_startup();\n\t\t} else {\n\t\t\tcmd |= CMD_RUN;\n\t\t\twritel(cmd, &ehci_regs->command);\n\t\t\treset_run = 1;\n\t\t}\n\t}\n\twhile (n > 0) {\n\t\tfor (chunk = 0; chunk < DBGP_MAX_PACKET && n > 0;\n\t\t     str++, chunk++, n--) {\n\t\t\tif (!use_cr && *str == '\\n') {\n\t\t\t\tuse_cr = 1;\n\t\t\t\tbuf[chunk] = '\\r';\n\t\t\t\tstr--;\n\t\t\t\tn++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (use_cr)\n\t\t\t\tuse_cr = 0;\n\t\t\tbuf[chunk] = *str;\n\t\t}\n\t\tif (chunk > 0) {\n\t\t\tdbgp_bulk_write(USB_DEBUG_DEVNUM,\n\t\t\t\t\tdbgp_endpoint_out, buf, chunk);\n\t\t}\n\t}\n\tif (unlikely(reset_run)) {\n\t\tcmd = readl(&ehci_regs->command);\n\t\tcmd &= ~CMD_RUN;\n\t\twritel(cmd, &ehci_regs->command);\n\t}\n}\n\nstruct console early_dbgp_console = {\n\t.name =\t\t\"earlydbg\",\n\t.write =\tearly_dbgp_write,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n};\n\n#if IS_ENABLED(CONFIG_USB)\nint dbgp_reset_prep(struct usb_hcd *hcd)\n{\n\tint ret = xen_dbgp_reset_prep(hcd);\n\tu32 ctrl;\n\n\tif (ret)\n\t\treturn ret;\n\n\tdbgp_not_safe = 1;\n\tif (!ehci_debug)\n\t\treturn 0;\n\n\tif ((early_dbgp_console.index != -1 &&\n\t     !(early_dbgp_console.flags & CON_BOOT)) ||\n\t    dbgp_kgdb_mode)\n\t\treturn 1;\n\t \n\tctrl = readl(&ehci_debug->control);\n\tif (ctrl & DBGP_ENABLED) {\n\t\tctrl &= ~(DBGP_CLAIM);\n\t\twritel(ctrl, &ehci_debug->control);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dbgp_reset_prep);\n\nint dbgp_external_startup(struct usb_hcd *hcd)\n{\n\treturn xen_dbgp_external_startup(hcd) ?: _dbgp_external_startup();\n}\nEXPORT_SYMBOL_GPL(dbgp_external_startup);\n#endif  \n\n#ifdef CONFIG_KGDB\n\nstatic char kgdbdbgp_buf[DBGP_MAX_PACKET];\nstatic int kgdbdbgp_buf_sz;\nstatic int kgdbdbgp_buf_idx;\nstatic int kgdbdbgp_loop_cnt = DBGP_LOOPS;\n\nstatic int kgdbdbgp_read_char(void)\n{\n\tint ret;\n\n\tif (kgdbdbgp_buf_idx < kgdbdbgp_buf_sz) {\n\t\tchar ch = kgdbdbgp_buf[kgdbdbgp_buf_idx++];\n\t\treturn ch;\n\t}\n\n\tret = dbgp_bulk_read(USB_DEBUG_DEVNUM, dbgp_endpoint_in,\n\t\t\t     &kgdbdbgp_buf, DBGP_MAX_PACKET,\n\t\t\t     kgdbdbgp_loop_cnt);\n\tif (ret <= 0)\n\t\treturn NO_POLL_CHAR;\n\tkgdbdbgp_buf_sz = ret;\n\tkgdbdbgp_buf_idx = 1;\n\treturn kgdbdbgp_buf[0];\n}\n\nstatic void kgdbdbgp_write_char(u8 chr)\n{\n\tearly_dbgp_write(NULL, &chr, 1);\n}\n\nstatic struct kgdb_io kgdbdbgp_io_ops = {\n\t.name = \"kgdbdbgp\",\n\t.read_char = kgdbdbgp_read_char,\n\t.write_char = kgdbdbgp_write_char,\n};\n\nstatic int kgdbdbgp_wait_time;\n\nstatic int __init kgdbdbgp_parse_config(char *str)\n{\n\tchar *ptr;\n\n\tif (!ehci_debug) {\n\t\tif (early_dbgp_init(str))\n\t\t\treturn -1;\n\t}\n\tptr = strchr(str, ',');\n\tif (ptr) {\n\t\tptr++;\n\t\tkgdbdbgp_wait_time = simple_strtoul(ptr, &ptr, 10);\n\t}\n\tkgdb_register_io_module(&kgdbdbgp_io_ops);\n\tif (early_dbgp_console.index != -1)\n\t\tkgdbdbgp_io_ops.cons = &early_dbgp_console;\n\n\treturn 0;\n}\nearly_param(\"kgdbdbgp\", kgdbdbgp_parse_config);\n\nstatic int kgdbdbgp_reader_thread(void *ptr)\n{\n\tint ret;\n\n\twhile (readl(&ehci_debug->control) & DBGP_ENABLED) {\n\t\tkgdbdbgp_loop_cnt = 1;\n\t\tret = kgdbdbgp_read_char();\n\t\tkgdbdbgp_loop_cnt = DBGP_LOOPS;\n\t\tif (ret != NO_POLL_CHAR) {\n\t\t\tif (ret == 0x3 || ret == '$') {\n\t\t\t\tif (ret == '$')\n\t\t\t\t\tkgdbdbgp_buf_idx--;\n\t\t\t\tkgdb_breakpoint();\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tschedule_timeout_interruptible(kgdbdbgp_wait_time * HZ);\n\t}\n\treturn 0;\n}\n\nstatic int __init kgdbdbgp_start_thread(void)\n{\n\tif (dbgp_kgdb_mode && kgdbdbgp_wait_time)\n\t\tkthread_run(kgdbdbgp_reader_thread, NULL, \"%s\", \"dbgp\");\n\n\treturn 0;\n}\ndevice_initcall(kgdbdbgp_start_thread);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}