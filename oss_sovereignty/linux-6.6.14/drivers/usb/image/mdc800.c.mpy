{
  "module_name": "mdc800.c",
  "hash_id": "1a42bdd6938a95724cfb7cd77f158186f23b6b07f2d5018759453c585ee347f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/image/mdc800.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/sched/signal.h>\n#include <linux/signal.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/mutex.h>\n\n#include <linux/usb.h>\n#include <linux/fs.h>\n\n \n#define DRIVER_VERSION \"v0.7.5 (30/10/2000)\"\n#define DRIVER_AUTHOR \"Henning Zabel <henning@uni-paderborn.de>\"\n#define DRIVER_DESC \"USB Driver for Mustek MDC800 Digital Camera\"\n\n \n#define MDC800_VENDOR_ID \t0x055f\n#define MDC800_PRODUCT_ID\t0xa800\n\n \n#define TO_DOWNLOAD_GET_READY\t\t1500\n#define TO_DOWNLOAD_GET_BUSY\t\t1500\n#define TO_WRITE_GET_READY\t\t1000\n#define TO_DEFAULT_COMMAND\t\t5000\n#define TO_READ_FROM_IRQ \t\tTO_DEFAULT_COMMAND\n#define TO_GET_READY\t\t\tTO_DEFAULT_COMMAND\n\n \n#define MDC800_DEVICE_MINOR_BASE 32\n\n\n \n\n\ntypedef enum {\n\tNOT_CONNECTED, READY, WORKING, DOWNLOAD\n} mdc800_state;\n\n\n \nstruct mdc800_data\n{\n\tstruct usb_device *\tdev;\t\t\t \n\tmdc800_state \t\tstate;\n\n\tunsigned int\t\tendpoint [4];\n\n\tstruct urb *\t\tirq_urb;\n\twait_queue_head_t\tirq_wait;\n\tint\t\t\tirq_woken;\n\tchar*\t\t\tirq_urb_buffer;\n\n\tint\t\t\tcamera_busy;           \n\tint \t\t\tcamera_request_ready;  \n\tchar \t\t\tcamera_response [8];   \n\n\tstruct urb *   \t\twrite_urb;\n\tchar*\t\t\twrite_urb_buffer;\n\twait_queue_head_t\twrite_wait;\n\tint\t\t\twritten;\n\n\n\tstruct urb *   \t\tdownload_urb;\n\tchar*\t\t\tdownload_urb_buffer;\n\twait_queue_head_t\tdownload_wait;\n\tint\t\t\tdownloaded;\n\tint\t\t\tdownload_left;\t\t \n\n\n\t \n\tchar\t\t\tout [64];\t \n\tint \t\t\tout_ptr;\t \n\tint\t\t\tout_count;\t \n\n\tint\t\t\topen;\t\t \n\tstruct mutex\t\tio_lock;\t \n\n\tchar \t\t\tin [8];\t\t \n\tint  \t\t\tin_count;\n\n\tint\t\t\tpic_index;\t \n\tint\t\t\tpic_len;\n\tint\t\t\tminor;\n};\n\n\n \nstatic struct usb_endpoint_descriptor mdc800_ed [4] =\n{\n\t{ \n\t\t.bLength = \t\t0,\n\t\t.bDescriptorType =\t0,\n\t\t.bEndpointAddress =\t0x01,\n\t\t.bmAttributes = \t0x02,\n\t\t.wMaxPacketSize =\tcpu_to_le16(8),\n\t\t.bInterval = \t\t0,\n\t\t.bRefresh = \t\t0,\n\t\t.bSynchAddress = \t0,\n\t},\n\t{\n\t\t.bLength = \t\t0,\n\t\t.bDescriptorType = \t0,\n\t\t.bEndpointAddress = \t0x82,\n\t\t.bmAttributes = \t0x03,\n\t\t.wMaxPacketSize = \tcpu_to_le16(8),\n\t\t.bInterval = \t\t0,\n\t\t.bRefresh = \t\t0,\n\t\t.bSynchAddress = \t0,\n\t},\n\t{\n\t\t.bLength = \t\t0,\n\t\t.bDescriptorType = \t0,\n\t\t.bEndpointAddress = \t0x03,\n\t\t.bmAttributes = \t0x02,\n\t\t.wMaxPacketSize = \tcpu_to_le16(64),\n\t\t.bInterval = \t\t0,\n\t\t.bRefresh = \t\t0,\n\t\t.bSynchAddress = \t0,\n\t},\n\t{\n\t\t.bLength = \t\t0,\n\t\t.bDescriptorType = \t0,\n\t\t.bEndpointAddress = \t0x84,\n\t\t.bmAttributes = \t0x02,\n\t\t.wMaxPacketSize = \tcpu_to_le16(64),\n\t\t.bInterval = \t\t0,\n\t\t.bRefresh = \t\t0,\n\t\t.bSynchAddress = \t0,\n\t},\n};\n\n \nstatic struct mdc800_data* mdc800;\n\n\n \n\nstatic int mdc800_endpoint_equals (struct usb_endpoint_descriptor *a,struct usb_endpoint_descriptor *b)\n{\n\treturn (\n\t\t   ( a->bEndpointAddress == b->bEndpointAddress )\n\t\t&& ( a->bmAttributes     == b->bmAttributes     )\n\t\t&& ( a->wMaxPacketSize   == b->wMaxPacketSize   )\n\t);\n}\n\n\n \nstatic int mdc800_isBusy (char* ch)\n{\n\tint i=0;\n\twhile (i<8)\n\t{\n\t\tif (ch [i] != (char)0x99)\n\t\t\treturn 0;\n\t\ti++;\n\t}\n\treturn 1;\n}\n\n\n \nstatic int mdc800_isReady (char *ch)\n{\n\tint i=0;\n\twhile (i<8)\n\t{\n\t\tif (ch [i] != (char)0xbb)\n\t\t\treturn 0;\n\t\ti++;\n\t}\n\treturn 1;\n}\n\n\n\n \nstatic void mdc800_usb_irq (struct urb *urb)\n{\n\tint data_received=0, wake_up;\n\tunsigned char* b=urb->transfer_buffer;\n\tstruct mdc800_data* mdc800=urb->context;\n\tstruct device *dev = &mdc800->dev->dev;\n\tint status = urb->status;\n\n\tif (status >= 0) {\n\t\tif (mdc800_isBusy (b))\n\t\t{\n\t\t\tif (!mdc800->camera_busy)\n\t\t\t{\n\t\t\t\tmdc800->camera_busy=1;\n\t\t\t\tdev_dbg(dev, \"gets busy\\n\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (mdc800->camera_busy && mdc800_isReady (b))\n\t\t\t{\n\t\t\t\tmdc800->camera_busy=0;\n\t\t\t\tdev_dbg(dev, \"gets ready\\n\");\n\t\t\t}\n\t\t}\n\t\tif (!(mdc800_isBusy (b) || mdc800_isReady (b)))\n\t\t{\n\t\t\t \n\t\t\tdev_dbg(dev, \"%i %i %i %i %i %i %i %i \\n\",b[0],b[1],b[2],b[3],b[4],b[5],b[6],b[7]);\n\n\t\t\tmemcpy (mdc800->camera_response,b,8);\n\t\t\tdata_received=1;\n\t\t}\n\t}\n\twake_up= ( mdc800->camera_request_ready > 0 )\n\t\t&&\n\t\t(\n\t\t\t((mdc800->camera_request_ready == 1) && (!mdc800->camera_busy))\n\t\t||\n\t\t\t((mdc800->camera_request_ready == 2) && data_received)\n\t\t||\n\t\t\t((mdc800->camera_request_ready == 3) && (mdc800->camera_busy))\n\t\t||\n\t\t\t(status < 0)\n\t\t);\n\n\tif (wake_up)\n\t{\n\t\tmdc800->camera_request_ready=0;\n\t\tmdc800->irq_woken=1;\n\t\twake_up (&mdc800->irq_wait);\n\t}\n}\n\n\n \nstatic int mdc800_usb_waitForIRQ (int mode, int msec)\n{\n\tmdc800->camera_request_ready=1+mode;\n\n\twait_event_timeout(mdc800->irq_wait, mdc800->irq_woken,\n\t\t\t   msecs_to_jiffies(msec));\n\tmdc800->irq_woken = 0;\n\n\tif (mdc800->camera_request_ready>0)\n\t{\n\t\tmdc800->camera_request_ready=0;\n\t\tdev_err(&mdc800->dev->dev, \"timeout waiting for camera.\\n\");\n\t\treturn -1;\n\t}\n\t\n\tif (mdc800->state == NOT_CONNECTED)\n\t{\n\t\tprintk(KERN_WARNING \"mdc800: Camera gets disconnected \"\n\t\t       \"during waiting for irq.\\n\");\n\t\tmdc800->camera_request_ready=0;\n\t\treturn -2;\n\t}\n\t\n\treturn 0;\n}\n\n\n \nstatic void mdc800_usb_write_notify (struct urb *urb)\n{\n\tstruct mdc800_data* mdc800=urb->context;\n\tint status = urb->status;\n\n\tif (status != 0)\n\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\"writing command fails (status=%i)\\n\", status);\n\telse\n\t\tmdc800->state=READY;\n\tmdc800->written = 1;\n\twake_up (&mdc800->write_wait);\n}\n\n\n \nstatic void mdc800_usb_download_notify (struct urb *urb)\n{\n\tstruct mdc800_data* mdc800=urb->context;\n\tint status = urb->status;\n\n\tif (status == 0) {\n\t\t \n\t\tmemcpy (mdc800->out,  urb->transfer_buffer, 64);\n\t\tmdc800->out_count=64;\n\t\tmdc800->out_ptr=0;\n\t\tmdc800->download_left-=64;\n\t\tif (mdc800->download_left == 0)\n\t\t{\n\t\t\tmdc800->state=READY;\n\t\t}\n\t} else {\n\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\"request bytes fails (status:%i)\\n\", status);\n\t}\n\tmdc800->downloaded = 1;\n\twake_up (&mdc800->download_wait);\n}\n\n\n \n\nstatic struct usb_driver mdc800_usb_driver;\nstatic const struct file_operations mdc800_device_ops;\nstatic struct usb_class_driver mdc800_class = {\n\t.name =\t\t\"mdc800%d\",\n\t.fops =\t\t&mdc800_device_ops,\n\t.minor_base =\tMDC800_DEVICE_MINOR_BASE,\n};\n\n\n \nstatic int mdc800_usb_probe (struct usb_interface *intf,\n\t\t\t       const struct usb_device_id *id)\n{\n\tint i,j;\n\tstruct usb_host_interface *intf_desc;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\tint irq_interval=0;\n\tint retval;\n\n\tdev_dbg(&intf->dev, \"(%s) called.\\n\", __func__);\n\n\n\tif (mdc800->dev != NULL)\n\t{\n\t\tdev_warn(&intf->dev, \"only one Mustek MDC800 is supported.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev->descriptor.bNumConfigurations != 1)\n\t{\n\t\tdev_err(&intf->dev,\n\t\t\t\"probe fails -> wrong Number of Configuration\\n\");\n\t\treturn -ENODEV;\n\t}\n\tintf_desc = intf->cur_altsetting;\n\n\tif (\n\t\t\t( intf_desc->desc.bInterfaceClass != 0xff )\n\t\t||\t( intf_desc->desc.bInterfaceSubClass != 0 )\n\t\t|| ( intf_desc->desc.bInterfaceProtocol != 0 )\n\t\t|| ( intf_desc->desc.bNumEndpoints != 4)\n\t)\n\t{\n\t\tdev_err(&intf->dev, \"probe fails -> wrong Interface\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tfor (i=0; i<4; i++)\n\t{\n\t\tmdc800->endpoint[i]=-1;\n\t\tfor (j=0; j<4; j++)\n\t\t{\n\t\t\tif (mdc800_endpoint_equals (&intf_desc->endpoint [j].desc,&mdc800_ed [i]))\n\t\t\t{\n\t\t\t\tmdc800->endpoint[i]=intf_desc->endpoint [j].desc.bEndpointAddress ;\n\t\t\t\tif (i==1)\n\t\t\t\t{\n\t\t\t\t\tirq_interval=intf_desc->endpoint [j].desc.bInterval;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (mdc800->endpoint[i] == -1)\n\t\t{\n\t\t\tdev_err(&intf->dev, \"probe fails -> Wrong Endpoints.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\n\tdev_info(&intf->dev, \"Found Mustek MDC800 on USB.\\n\");\n\n\tmutex_lock(&mdc800->io_lock);\n\n\tretval = usb_register_dev(intf, &mdc800_class);\n\tif (retval) {\n\t\tdev_err(&intf->dev, \"Not able to get a minor for this device.\\n\");\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tmdc800->dev=dev;\n\tmdc800->open=0;\n\n\t \n\tusb_fill_int_urb (\n\t\tmdc800->irq_urb,\n\t\tmdc800->dev,\n\t\tusb_rcvintpipe (mdc800->dev,mdc800->endpoint [1]),\n\t\tmdc800->irq_urb_buffer,\n\t\t8,\n\t\tmdc800_usb_irq,\n\t\tmdc800,\n\t\tirq_interval\n\t);\n\n\tusb_fill_bulk_urb (\n\t\tmdc800->write_urb,\n\t\tmdc800->dev,\n\t\tusb_sndbulkpipe (mdc800->dev, mdc800->endpoint[0]),\n\t\tmdc800->write_urb_buffer,\n\t\t8,\n\t\tmdc800_usb_write_notify,\n\t\tmdc800\n\t);\n\n\tusb_fill_bulk_urb (\n\t\tmdc800->download_urb,\n\t\tmdc800->dev,\n\t\tusb_rcvbulkpipe (mdc800->dev, mdc800->endpoint [3]),\n\t\tmdc800->download_urb_buffer,\n\t\t64,\n\t\tmdc800_usb_download_notify,\n\t\tmdc800\n\t);\n\n\tmdc800->state=READY;\n\n\tmutex_unlock(&mdc800->io_lock);\n\t\n\tusb_set_intfdata(intf, mdc800);\n\treturn 0;\n}\n\n\n \nstatic void mdc800_usb_disconnect (struct usb_interface *intf)\n{\n\tstruct mdc800_data* mdc800 = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"(%s) called\\n\", __func__);\n\n\tif (mdc800) {\n\t\tif (mdc800->state == NOT_CONNECTED)\n\t\t\treturn;\n\n\t\tusb_deregister_dev(intf, &mdc800_class);\n\n\t\t \n\t\tmutex_lock(&mdc800->io_lock);\n\t\tmdc800->state=NOT_CONNECTED;\n\n\t\tusb_kill_urb(mdc800->irq_urb);\n\t\tusb_kill_urb(mdc800->write_urb);\n\t\tusb_kill_urb(mdc800->download_urb);\n\t\tmutex_unlock(&mdc800->io_lock);\n\n\t\tmdc800->dev = NULL;\n\t\tusb_set_intfdata(intf, NULL);\n\t}\n\tdev_info(&intf->dev, \"Mustek MDC800 disconnected from USB.\\n\");\n}\n\n\n \n\n \nstatic int mdc800_getAnswerSize (char command)\n{\n\tswitch ((unsigned char) command)\n\t{\n\t\tcase 0x2a:\n\t\tcase 0x49:\n\t\tcase 0x51:\n\t\tcase 0x0d:\n\t\tcase 0x20:\n\t\tcase 0x07:\n\t\tcase 0x01:\n\t\tcase 0x25:\n\t\tcase 0x00:\n\t\t\treturn 8;\n\n\t\tcase 0x05:\n\t\tcase 0x3e:\n\t\t\treturn mdc800->pic_len;\n\n\t\tcase 0x09:\n\t\t\treturn 4096;\n\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n\n \nstatic int mdc800_device_open (struct inode* inode, struct file *file)\n{\n\tint retval=0;\n\tint errn=0;\n\n\tmutex_lock(&mdc800->io_lock);\n\t\n\tif (mdc800->state == NOT_CONNECTED)\n\t{\n\t\terrn=-EBUSY;\n\t\tgoto error_out;\n\t}\n\tif (mdc800->open)\n\t{\n\t\terrn=-EBUSY;\n\t\tgoto error_out;\n\t}\n\n\tmdc800->in_count=0;\n\tmdc800->out_count=0;\n\tmdc800->out_ptr=0;\n\tmdc800->pic_index=0;\n\tmdc800->pic_len=-1;\n\tmdc800->download_left=0;\n\n\tmdc800->camera_busy=0;\n\tmdc800->camera_request_ready=0;\n\n\tretval=0;\n\tmdc800->irq_urb->dev = mdc800->dev;\n\tretval = usb_submit_urb (mdc800->irq_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\"request USB irq fails (submit_retval=%i).\\n\", retval);\n\t\terrn = -EIO;\n\t\tgoto error_out;\n\t}\n\n\tmdc800->open=1;\n\tdev_dbg(&mdc800->dev->dev, \"Mustek MDC800 device opened.\\n\");\n\nerror_out:\n\tmutex_unlock(&mdc800->io_lock);\n\treturn errn;\n}\n\n\n \nstatic int mdc800_device_release (struct inode* inode, struct file *file)\n{\n\tint retval=0;\n\n\tmutex_lock(&mdc800->io_lock);\n\tif (mdc800->open && (mdc800->state != NOT_CONNECTED))\n\t{\n\t\tusb_kill_urb(mdc800->irq_urb);\n\t\tusb_kill_urb(mdc800->write_urb);\n\t\tusb_kill_urb(mdc800->download_urb);\n\t\tmdc800->open=0;\n\t}\n\telse\n\t{\n\t\tretval=-EIO;\n\t}\n\n\tmutex_unlock(&mdc800->io_lock);\n\treturn retval;\n}\n\n\n \nstatic ssize_t mdc800_device_read (struct file *file, char __user *buf, size_t len, loff_t *pos)\n{\n\tsize_t left=len, sts=len;  \n\tchar __user *ptr = buf;\n\tint retval;\n\n\tmutex_lock(&mdc800->io_lock);\n\tif (mdc800->state == NOT_CONNECTED)\n\t{\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -EBUSY;\n\t}\n\tif (mdc800->state == WORKING)\n\t{\n\t\tprintk(KERN_WARNING \"mdc800: Illegal State \\\"working\\\"\"\n\t\t       \"reached during read ?!\\n\");\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -EBUSY;\n\t}\n\tif (!mdc800->open)\n\t{\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -EBUSY;\n\t}\n\n\twhile (left)\n\t{\n\t\tif (signal_pending (current)) \n\t\t{\n\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\n\t\tsts=left > (mdc800->out_count-mdc800->out_ptr)?mdc800->out_count-mdc800->out_ptr:left;\n\n\t\tif (sts <= 0)\n\t\t{\n\t\t\t \n\t\t\tif (mdc800->state == DOWNLOAD)\n\t\t\t{\n\t\t\t\tmdc800->out_count=0;\n\t\t\t\tmdc800->out_ptr=0;\n\n\t\t\t\t \n\t\t\t\tmdc800->download_urb->dev = mdc800->dev;\n\t\t\t\tretval = usb_submit_urb (mdc800->download_urb, GFP_KERNEL);\n\t\t\t\tif (retval) {\n\t\t\t\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\t\t\t\"Can't submit download urb \"\n\t\t\t\t\t\t\"(retval=%i)\\n\", retval);\n\t\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\t\treturn len-left;\n\t\t\t\t}\n\t\t\t\twait_event_timeout(mdc800->download_wait,\n\t\t\t\t     mdc800->downloaded,\n\t\t\t\t     msecs_to_jiffies(TO_DOWNLOAD_GET_READY));\n\t\t\t\tmdc800->downloaded = 0;\n\t\t\t\tif (mdc800->download_urb->status != 0)\n\t\t\t\t{\n\t\t\t\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\t\t\t\"request download-bytes fails \"\n\t\t\t\t\t\t\"(status=%i)\\n\",\n\t\t\t\t\t\tmdc800->download_urb->status);\n\t\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\t\treturn len-left;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t \n\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t \n\t\t\tif (copy_to_user(ptr, &mdc800->out [mdc800->out_ptr],\n\t\t\t\t\t\tsts)) {\n\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t\tptr+=sts;\n\t\t\tleft-=sts;\n\t\t\tmdc800->out_ptr+=sts;\n\t\t}\n\t}\n\n\tmutex_unlock(&mdc800->io_lock);\n\treturn len-left;\n}\n\n\n \nstatic ssize_t mdc800_device_write (struct file *file, const char __user *buf, size_t len, loff_t *pos)\n{\n\tsize_t i=0;\n\tint retval;\n\n\tmutex_lock(&mdc800->io_lock);\n\tif (mdc800->state != READY)\n\t{\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -EBUSY;\n\t}\n\tif (!mdc800->open )\n\t{\n\t\tmutex_unlock(&mdc800->io_lock);\n\t\treturn -EBUSY;\n\t}\n\n\twhile (i<len)\n\t{\n\t\tunsigned char c;\n\t\tif (signal_pending (current)) \n\t\t{\n\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\t\n\t\tif(get_user(c, buf+i))\n\t\t{\n\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\tif (c == 0x55)\n\t\t{\n\t\t\tmdc800->in_count=0;\n\t\t\tmdc800->out_count=0;\n\t\t\tmdc800->out_ptr=0;\n\t\t\tmdc800->download_left=0;\n\t\t}\n\n\t\t \n\t\tif (mdc800->in_count < 8)\n\t\t{\n\t\t\tmdc800->in[mdc800->in_count] = c;\n\t\t\tmdc800->in_count++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tif (mdc800->in_count == 8)\n\t\t{\n\t\t\tint answersize;\n\n\t\t\tif (mdc800_usb_waitForIRQ (0,TO_GET_READY))\n\t\t\t{\n\t\t\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\t\t\"Camera didn't get ready.\\n\");\n\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tanswersize=mdc800_getAnswerSize (mdc800->in[1]);\n\n\t\t\tmdc800->state=WORKING;\n\t\t\tmemcpy (mdc800->write_urb->transfer_buffer, mdc800->in,8);\n\t\t\tmdc800->write_urb->dev = mdc800->dev;\n\t\t\tretval = usb_submit_urb (mdc800->write_urb, GFP_KERNEL);\n\t\t\tif (retval) {\n\t\t\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\t\t\"submitting write urb fails \"\n\t\t\t\t\t\"(retval=%i)\\n\", retval);\n\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\twait_event_timeout(mdc800->write_wait, mdc800->written,\n\t\t\t\t\tmsecs_to_jiffies(TO_WRITE_GET_READY));\n\t\t\tmdc800->written = 0;\n\t\t\tif (mdc800->state == WORKING)\n\t\t\t{\n\t\t\t\tusb_kill_urb(mdc800->write_urb);\n\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tswitch ((unsigned char) mdc800->in[1])\n\t\t\t{\n\t\t\t\tcase 0x05:  \n\t\t\t\tcase 0x3e:  \n\t\t\t\t\tif (mdc800->pic_len < 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdev_err(&mdc800->dev->dev,\n\t\t\t\t\t\t\t\"call 0x07 before \"\n\t\t\t\t\t\t\t\"0x05,0x3e\\n\");\n\t\t\t\t\t\tmdc800->state=READY;\n\t\t\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t}\n\t\t\t\t\tmdc800->pic_len=-1;\n\t\t\t\t\tfallthrough;\n\n\t\t\t\tcase 0x09:  \n\t\t\t\t\tmdc800->download_left=answersize+64;\n\t\t\t\t\tmdc800->state=DOWNLOAD;\n\t\t\t\t\tmdc800_usb_waitForIRQ (0,TO_DOWNLOAD_GET_BUSY);\n\t\t\t\t\tbreak;\n\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (answersize)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (mdc800_usb_waitForIRQ (1,TO_READ_FROM_IRQ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdev_err(&mdc800->dev->dev, \"requesting answer from irq fails\\n\");\n\t\t\t\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy (mdc800->out, mdc800->camera_response,8);\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tmemcpy (&mdc800->out[8], mdc800->camera_response,8);\n\n\t\t\t\t\t\tmdc800->out_ptr=0;\n\t\t\t\t\t\tmdc800->out_count=16;\n\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (mdc800->in [1] == (char) 0x07)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmdc800->pic_len=(int) 65536*(unsigned char) mdc800->camera_response[0]+256*(unsigned char) mdc800->camera_response[1]+(unsigned char) mdc800->camera_response[2];\n\n\t\t\t\t\t\t\tdev_dbg(&mdc800->dev->dev, \"cached imagesize = %i\\n\", mdc800->pic_len);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (mdc800_usb_waitForIRQ (0,TO_DEFAULT_COMMAND))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdev_err(&mdc800->dev->dev, \"Command Timeout.\\n\");\n\t\t\t\t\t\t\tmutex_unlock(&mdc800->io_lock);\n\t\t\t\t\t\t\treturn -EIO;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tmdc800->state=READY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tmutex_unlock(&mdc800->io_lock);\n\treturn i;\n}\n\n\n \n\n \nstatic const struct file_operations mdc800_device_ops =\n{\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tmdc800_device_read,\n\t.write =\tmdc800_device_write,\n\t.open =\t\tmdc800_device_open,\n\t.release =\tmdc800_device_release,\n\t.llseek =\tnoop_llseek,\n};\n\n\n\nstatic const struct usb_device_id mdc800_table[] = {\n\t{ USB_DEVICE(MDC800_VENDOR_ID, MDC800_PRODUCT_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, mdc800_table);\n \nstatic struct usb_driver mdc800_usb_driver =\n{\n\t.name =\t\t\"mdc800\",\n\t.probe =\tmdc800_usb_probe,\n\t.disconnect =\tmdc800_usb_disconnect,\n\t.id_table =\tmdc800_table\n};\n\n\n\n \n\nstatic int __init usb_mdc800_init (void)\n{\n\tint retval = -ENODEV;\n\t \n\tmdc800=kzalloc (sizeof (struct mdc800_data), GFP_KERNEL);\n\tif (!mdc800)\n\t\tgoto cleanup_on_fail;\n\n\tmdc800->dev = NULL;\n\tmdc800->state=NOT_CONNECTED;\n\tmutex_init (&mdc800->io_lock);\n\n\tinit_waitqueue_head (&mdc800->irq_wait);\n\tinit_waitqueue_head (&mdc800->write_wait);\n\tinit_waitqueue_head (&mdc800->download_wait);\n\n\tmdc800->irq_woken = 0;\n\tmdc800->downloaded = 0;\n\tmdc800->written = 0;\n\n\tmdc800->irq_urb_buffer=kmalloc (8, GFP_KERNEL);\n\tif (!mdc800->irq_urb_buffer)\n\t\tgoto cleanup_on_fail;\n\tmdc800->write_urb_buffer=kmalloc (8, GFP_KERNEL);\n\tif (!mdc800->write_urb_buffer)\n\t\tgoto cleanup_on_fail;\n\tmdc800->download_urb_buffer=kmalloc (64, GFP_KERNEL);\n\tif (!mdc800->download_urb_buffer)\n\t\tgoto cleanup_on_fail;\n\n\tmdc800->irq_urb=usb_alloc_urb (0, GFP_KERNEL);\n\tif (!mdc800->irq_urb)\n\t\tgoto cleanup_on_fail;\n\tmdc800->download_urb=usb_alloc_urb (0, GFP_KERNEL);\n\tif (!mdc800->download_urb)\n\t\tgoto cleanup_on_fail;\n\tmdc800->write_urb=usb_alloc_urb (0, GFP_KERNEL);\n\tif (!mdc800->write_urb)\n\t\tgoto cleanup_on_fail;\n\n\t \n\tretval = usb_register(&mdc800_usb_driver);\n\tif (retval)\n\t\tgoto cleanup_on_fail;\n\n\tprintk(KERN_INFO KBUILD_MODNAME \": \" DRIVER_VERSION \":\"\n\t       DRIVER_DESC \"\\n\");\n\n\treturn 0;\n\n\t \n\ncleanup_on_fail:\n\n\tif (mdc800 != NULL)\n\t{\n\t\tprintk(KERN_ERR \"mdc800: can't alloc memory!\\n\");\n\n\t\tkfree(mdc800->download_urb_buffer);\n\t\tkfree(mdc800->write_urb_buffer);\n\t\tkfree(mdc800->irq_urb_buffer);\n\n\t\tusb_free_urb(mdc800->write_urb);\n\t\tusb_free_urb(mdc800->download_urb);\n\t\tusb_free_urb(mdc800->irq_urb);\n\n\t\tkfree (mdc800);\n\t}\n\tmdc800 = NULL;\n\treturn retval;\n}\n\n\nstatic void __exit usb_mdc800_cleanup (void)\n{\n\tusb_deregister (&mdc800_usb_driver);\n\n\tusb_free_urb (mdc800->irq_urb);\n\tusb_free_urb (mdc800->download_urb);\n\tusb_free_urb (mdc800->write_urb);\n\n\tkfree (mdc800->irq_urb_buffer);\n\tkfree (mdc800->write_urb_buffer);\n\tkfree (mdc800->download_urb_buffer);\n\n\tkfree (mdc800);\n\tmdc800 = NULL;\n}\n\nmodule_init (usb_mdc800_init);\nmodule_exit (usb_mdc800_cleanup);\n\nMODULE_AUTHOR( DRIVER_AUTHOR );\nMODULE_DESCRIPTION( DRIVER_DESC );\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}