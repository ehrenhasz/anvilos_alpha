{
  "module_name": "microtek.c",
  "hash_id": "0c945aa5a168742af9b03a1e06d6b31459cd9e89b02d1c0aaf743ed25e4414ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/image/microtek.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <linux/blkdev.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"microtek.h\"\n\n#define DRIVER_AUTHOR \"John Fremlin <vii@penguinpowered.com>, Oliver Neukum <Oliver.Neukum@lrz.uni-muenchen.de>\"\n#define DRIVER_DESC \"Microtek Scanmaker X6 USB scanner driver\"\n\n \n\n\n\n \n\nstatic int mts_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id);\nstatic void mts_usb_disconnect(struct usb_interface *intf);\n\nstatic const struct usb_device_id mts_usb_ids[];\n\nstatic struct usb_driver mts_usb_driver = {\n\t.name =\t\t\"microtekX6\",\n\t.probe =\tmts_usb_probe,\n\t.disconnect =\tmts_usb_disconnect,\n\t.id_table =\tmts_usb_ids,\n};\n\n\n \n\n#define MTS_VERSION\t\"0.4.3\"\n#define MTS_NAME\t\"microtek usb (rev \" MTS_VERSION \"): \"\n\n#define MTS_WARNING(x...) \\\n\tprintk( KERN_WARNING MTS_NAME x )\n#define MTS_ERROR(x...) \\\n\tprintk( KERN_ERR MTS_NAME x )\n#define MTS_INT_ERROR(x...) \\\n\tMTS_ERROR(x)\n#define MTS_MESSAGE(x...) \\\n\tprintk( KERN_INFO MTS_NAME x )\n\n#if defined MTS_DO_DEBUG\n\n#define MTS_DEBUG(x...) \\\n\tprintk( KERN_DEBUG MTS_NAME x )\n\n#define MTS_DEBUG_GOT_HERE() \\\n\tMTS_DEBUG(\"got to %s:%d (%s)\\n\", __FILE__, (int)__LINE__, __func__ )\n#define MTS_DEBUG_INT() \\\n\tdo { MTS_DEBUG_GOT_HERE(); \\\n\t     MTS_DEBUG(\"transfer = 0x%x context = 0x%x\\n\",(int)transfer,(int)context ); \\\n\t     MTS_DEBUG(\"status = 0x%x data-length = 0x%x sent = 0x%x\\n\",transfer->status,(int)context->data_length, (int)transfer->actual_length ); \\\n             mts_debug_dump(context->instance);\\\n\t   } while(0)\n#else\n\n#define MTS_NUL_STATEMENT do { } while(0)\n\n#define MTS_DEBUG(x...)\tMTS_NUL_STATEMENT\n#define MTS_DEBUG_GOT_HERE() MTS_NUL_STATEMENT\n#define MTS_DEBUG_INT() MTS_NUL_STATEMENT\n\n#endif\n\n\n\n#define MTS_INT_INIT()\\\n\tstruct mts_transfer_context* context = (struct mts_transfer_context*)transfer->context; \\\n\tMTS_DEBUG_INT();\\\n\n#ifdef MTS_DO_DEBUG\n\nstatic inline void mts_debug_dump(struct mts_desc* desc) {\n\tMTS_DEBUG(\"desc at 0x%x: toggle = %02x%02x\\n\",\n\t\t  (int)desc,\n\t\t  (int)desc->usb_dev->toggle[1],(int)desc->usb_dev->toggle[0]\n\t\t);\n\tMTS_DEBUG(\"ep_out=%x ep_response=%x ep_image=%x\\n\",\n\t\t  usb_sndbulkpipe(desc->usb_dev,desc->ep_out),\n\t\t  usb_rcvbulkpipe(desc->usb_dev,desc->ep_response),\n\t\t  usb_rcvbulkpipe(desc->usb_dev,desc->ep_image)\n\t\t);\n}\n\n\nstatic inline void mts_show_command(struct scsi_cmnd *srb)\n{\n\tchar *what = NULL;\n\n\tswitch (srb->cmnd[0]) {\n\tcase TEST_UNIT_READY: what = \"TEST_UNIT_READY\"; break;\n\tcase REZERO_UNIT: what = \"REZERO_UNIT\"; break;\n\tcase REQUEST_SENSE: what = \"REQUEST_SENSE\"; break;\n\tcase FORMAT_UNIT: what = \"FORMAT_UNIT\"; break;\n\tcase READ_BLOCK_LIMITS: what = \"READ_BLOCK_LIMITS\"; break;\n\tcase REASSIGN_BLOCKS: what = \"REASSIGN_BLOCKS\"; break;\n\tcase READ_6: what = \"READ_6\"; break;\n\tcase WRITE_6: what = \"WRITE_6\"; break;\n\tcase SEEK_6: what = \"SEEK_6\"; break;\n\tcase READ_REVERSE: what = \"READ_REVERSE\"; break;\n\tcase WRITE_FILEMARKS: what = \"WRITE_FILEMARKS\"; break;\n\tcase SPACE: what = \"SPACE\"; break;\n\tcase INQUIRY: what = \"INQUIRY\"; break;\n\tcase RECOVER_BUFFERED_DATA: what = \"RECOVER_BUFFERED_DATA\"; break;\n\tcase MODE_SELECT: what = \"MODE_SELECT\"; break;\n\tcase RESERVE: what = \"RESERVE\"; break;\n\tcase RELEASE: what = \"RELEASE\"; break;\n\tcase COPY: what = \"COPY\"; break;\n\tcase ERASE: what = \"ERASE\"; break;\n\tcase MODE_SENSE: what = \"MODE_SENSE\"; break;\n\tcase START_STOP: what = \"START_STOP\"; break;\n\tcase RECEIVE_DIAGNOSTIC: what = \"RECEIVE_DIAGNOSTIC\"; break;\n\tcase SEND_DIAGNOSTIC: what = \"SEND_DIAGNOSTIC\"; break;\n\tcase ALLOW_MEDIUM_REMOVAL: what = \"ALLOW_MEDIUM_REMOVAL\"; break;\n\tcase SET_WINDOW: what = \"SET_WINDOW\"; break;\n\tcase READ_CAPACITY: what = \"READ_CAPACITY\"; break;\n\tcase READ_10: what = \"READ_10\"; break;\n\tcase WRITE_10: what = \"WRITE_10\"; break;\n\tcase SEEK_10: what = \"SEEK_10\"; break;\n\tcase WRITE_VERIFY: what = \"WRITE_VERIFY\"; break;\n\tcase VERIFY: what = \"VERIFY\"; break;\n\tcase SEARCH_HIGH: what = \"SEARCH_HIGH\"; break;\n\tcase SEARCH_EQUAL: what = \"SEARCH_EQUAL\"; break;\n\tcase SEARCH_LOW: what = \"SEARCH_LOW\"; break;\n\tcase SET_LIMITS: what = \"SET_LIMITS\"; break;\n\tcase READ_POSITION: what = \"READ_POSITION\"; break;\n\tcase SYNCHRONIZE_CACHE: what = \"SYNCHRONIZE_CACHE\"; break;\n\tcase LOCK_UNLOCK_CACHE: what = \"LOCK_UNLOCK_CACHE\"; break;\n\tcase READ_DEFECT_DATA: what = \"READ_DEFECT_DATA\"; break;\n\tcase MEDIUM_SCAN: what = \"MEDIUM_SCAN\"; break;\n\tcase COMPARE: what = \"COMPARE\"; break;\n\tcase COPY_VERIFY: what = \"COPY_VERIFY\"; break;\n\tcase WRITE_BUFFER: what = \"WRITE_BUFFER\"; break;\n\tcase READ_BUFFER: what = \"READ_BUFFER\"; break;\n\tcase UPDATE_BLOCK: what = \"UPDATE_BLOCK\"; break;\n\tcase READ_LONG: what = \"READ_LONG\"; break;\n\tcase WRITE_LONG: what = \"WRITE_LONG\"; break;\n\tcase CHANGE_DEFINITION: what = \"CHANGE_DEFINITION\"; break;\n\tcase WRITE_SAME: what = \"WRITE_SAME\"; break;\n\tcase READ_TOC: what = \"READ_TOC\"; break;\n\tcase LOG_SELECT: what = \"LOG_SELECT\"; break;\n\tcase LOG_SENSE: what = \"LOG_SENSE\"; break;\n\tcase MODE_SELECT_10: what = \"MODE_SELECT_10\"; break;\n\tcase MODE_SENSE_10: what = \"MODE_SENSE_10\"; break;\n\tcase MOVE_MEDIUM: what = \"MOVE_MEDIUM\"; break;\n\tcase READ_12: what = \"READ_12\"; break;\n\tcase WRITE_12: what = \"WRITE_12\"; break;\n\tcase WRITE_VERIFY_12: what = \"WRITE_VERIFY_12\"; break;\n\tcase SEARCH_HIGH_12: what = \"SEARCH_HIGH_12\"; break;\n\tcase SEARCH_EQUAL_12: what = \"SEARCH_EQUAL_12\"; break;\n\tcase SEARCH_LOW_12: what = \"SEARCH_LOW_12\"; break;\n\tcase READ_ELEMENT_STATUS: what = \"READ_ELEMENT_STATUS\"; break;\n\tcase SEND_VOLUME_TAG: what = \"SEND_VOLUME_TAG\"; break;\n\tcase WRITE_LONG_2: what = \"WRITE_LONG_2\"; break;\n\tdefault:\n\t\tMTS_DEBUG(\"can't decode command\\n\");\n\t\tgoto out;\n\t\tbreak;\n\t}\n\tMTS_DEBUG( \"Command %s (%d bytes)\\n\", what, srb->cmd_len);\n\n out:\n\tMTS_DEBUG( \"  %10ph\\n\", srb->cmnd);\n}\n\n#else\n\nstatic inline void mts_show_command(struct scsi_cmnd * dummy)\n{\n}\n\nstatic inline void mts_debug_dump(struct mts_desc* dummy)\n{\n}\n\n#endif\n\nstatic inline void mts_urb_abort(struct mts_desc* desc) {\n\tMTS_DEBUG_GOT_HERE();\n\tmts_debug_dump(desc);\n\n\tusb_kill_urb( desc->urb );\n}\n\nstatic int mts_slave_alloc (struct scsi_device *s)\n{\n\ts->inquiry_len = 0x24;\n\treturn 0;\n}\n\nstatic int mts_slave_configure (struct scsi_device *s)\n{\n\tblk_queue_dma_alignment(s->request_queue, (512 - 1));\n\treturn 0;\n}\n\nstatic int mts_scsi_abort(struct scsi_cmnd *srb)\n{\n\tstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\n\n\tMTS_DEBUG_GOT_HERE();\n\n\tmts_urb_abort(desc);\n\n\treturn FAILED;\n}\n\nstatic int mts_scsi_host_reset(struct scsi_cmnd *srb)\n{\n\tstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\n\tint result;\n\n\tMTS_DEBUG_GOT_HERE();\n\tmts_debug_dump(desc);\n\n\tresult = usb_lock_device_for_reset(desc->usb_dev, desc->usb_intf);\n\tif (result == 0) {\n\t\tresult = usb_reset_device(desc->usb_dev);\n\t\tusb_unlock_device(desc->usb_dev);\n\t}\n\treturn result ? FAILED : SUCCESS;\n}\n\nstatic int\nmts_scsi_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *srb);\n\nstatic void mts_transfer_cleanup( struct urb *transfer );\nstatic void mts_do_sg(struct urb * transfer);\n\nstatic inline\nvoid mts_int_submit_urb (struct urb* transfer,\n\t\t\tint pipe,\n\t\t\tvoid* data,\n\t\t\tunsigned length,\n\t\t\tusb_complete_t callback )\n \n\n \n{\n\tint res;\n\n\tMTS_INT_INIT();\n\n\tusb_fill_bulk_urb(transfer,\n\t\t      context->instance->usb_dev,\n\t\t      pipe,\n\t\t      data,\n\t\t      length,\n\t\t      callback,\n\t\t      context\n\t\t);\n\n\tres = usb_submit_urb( transfer, GFP_ATOMIC );\n\tif ( unlikely(res) ) {\n\t\tMTS_INT_ERROR( \"could not submit URB! Error was %d\\n\",(int)res );\n\t\tset_host_byte(context->srb, DID_ERROR);\n\t\tmts_transfer_cleanup(transfer);\n\t}\n}\n\n\nstatic void mts_transfer_cleanup( struct urb *transfer )\n \n{\n\tMTS_INT_INIT();\n\n\tif ( likely(context->final_callback != NULL) )\n\t\tcontext->final_callback(context->srb);\n}\n\nstatic void mts_transfer_done( struct urb *transfer )\n{\n\tMTS_INT_INIT();\n\n\tcontext->srb->result &= MTS_SCSI_ERR_MASK;\n\tcontext->srb->result |= (unsigned)(*context->scsi_status)<<1;\n\n\tmts_transfer_cleanup(transfer);\n}\n\n\nstatic void mts_get_status( struct urb *transfer )\n \n{\n\tMTS_INT_INIT();\n\n\tmts_int_submit_urb(transfer,\n\t\t\t   usb_rcvbulkpipe(context->instance->usb_dev,\n\t\t\t\t\t   context->instance->ep_response),\n\t\t\t   context->scsi_status,\n\t\t\t   1,\n\t\t\t   mts_transfer_done );\n}\n\nstatic void mts_data_done( struct urb* transfer )\n \n{\n\tint status = transfer->status;\n\tMTS_INT_INIT();\n\n\tif ( context->data_length != transfer->actual_length ) {\n\t\tscsi_set_resid(context->srb, context->data_length -\n\t\t\t       transfer->actual_length);\n\t} else if ( unlikely(status) ) {\n\t\tset_host_byte(context->srb, (status == -ENOENT ? DID_ABORT : DID_ERROR));\n\t}\n\n\tmts_get_status(transfer);\n}\n\n\nstatic void mts_command_done( struct urb *transfer )\n \n{\n\tint status = transfer->status;\n\tMTS_INT_INIT();\n\n\tif ( unlikely(status) ) {\n\t        if (status == -ENOENT) {\n\t\t         \n\t\t\tMTS_DEBUG_GOT_HERE();\n\t\t\tset_host_byte(context->srb, DID_ABORT);\n                } else {\n\t\t         \n\t\t\tMTS_DEBUG_GOT_HERE();\n\n\t\t        set_host_byte(context->srb, DID_ERROR);\n                }\n\t\tmts_transfer_cleanup(transfer);\n\n\t\treturn;\n\t}\n\n\tif (context->srb->cmnd[0] == REQUEST_SENSE) {\n\t\tmts_int_submit_urb(transfer,\n\t\t\t\t   context->data_pipe,\n\t\t\t\t   context->srb->sense_buffer,\n\t\t\t\t   context->data_length,\n\t\t\t\t   mts_data_done);\n\t} else { if ( context->data ) {\n\t\t\tmts_int_submit_urb(transfer,\n\t\t\t\t\t   context->data_pipe,\n\t\t\t\t\t   context->data,\n\t\t\t\t\t   context->data_length,\n\t\t\t\t\t   scsi_sg_count(context->srb) > 1 ?\n\t\t\t\t\t           mts_do_sg : mts_data_done);\n\t\t} else {\n\t\t\tmts_get_status(transfer);\n\t\t}\n\t}\n}\n\nstatic void mts_do_sg (struct urb* transfer)\n{\n\tint status = transfer->status;\n\tMTS_INT_INIT();\n\n\tMTS_DEBUG(\"Processing fragment %d of %d\\n\", context->fragment,\n\t                                          scsi_sg_count(context->srb));\n\n\tif (unlikely(status)) {\n                set_host_byte(context->srb, (status == -ENOENT ? DID_ABORT : DID_ERROR));\n\t\tmts_transfer_cleanup(transfer);\n        }\n\n\tcontext->curr_sg = sg_next(context->curr_sg);\n\tmts_int_submit_urb(transfer,\n\t\t\t   context->data_pipe,\n\t\t\t   sg_virt(context->curr_sg),\n\t\t\t   context->curr_sg->length,\n\t\t\t   sg_is_last(context->curr_sg) ?\n\t\t\t   mts_data_done : mts_do_sg);\n}\n\nstatic const u8 mts_read_image_sig[] = { 0x28, 00, 00, 00 };\nstatic const u8 mts_read_image_sig_len = 4;\nstatic const unsigned char mts_direction[256/8] = {\n\t0x28, 0x81, 0x14, 0x14, 0x20, 0x01, 0x90, 0x77,\n\t0x0C, 0x20, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\n\n#define MTS_DIRECTION_IS_IN(x) ((mts_direction[x>>3] >> (x & 7)) & 1)\n\nstatic void\nmts_build_transfer_context(struct scsi_cmnd *srb, struct mts_desc* desc)\n{\n\tint pipe;\n\n\tMTS_DEBUG_GOT_HERE();\n\n\tdesc->context.instance = desc;\n\tdesc->context.srb = srb;\n\n\tif (!scsi_bufflen(srb)) {\n\t\tdesc->context.data = NULL;\n\t\tdesc->context.data_length = 0;\n\t\treturn;\n\t} else {\n\t\tdesc->context.curr_sg = scsi_sglist(srb);\n\t\tdesc->context.data = sg_virt(desc->context.curr_sg);\n\t\tdesc->context.data_length = desc->context.curr_sg->length;\n\t}\n\n\n\t \n\n\t \n\n\tif ( !memcmp( srb->cmnd, mts_read_image_sig, mts_read_image_sig_len )\n) { \t\tpipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_image);\n\t\tMTS_DEBUG( \"transferring from desc->ep_image == %d\\n\",\n\t\t\t   (int)desc->ep_image );\n\t} else if ( MTS_DIRECTION_IS_IN(srb->cmnd[0]) ) {\n\t\t\tpipe = usb_rcvbulkpipe(desc->usb_dev,desc->ep_response);\n\t\t\tMTS_DEBUG( \"transferring from desc->ep_response == %d\\n\",\n\t\t\t\t   (int)desc->ep_response);\n\t} else {\n\t\tMTS_DEBUG(\"transferring to desc->ep_out == %d\\n\",\n\t\t\t  (int)desc->ep_out);\n\t\tpipe = usb_sndbulkpipe(desc->usb_dev,desc->ep_out);\n\t}\n\tdesc->context.data_pipe = pipe;\n}\n\nstatic int mts_scsi_queuecommand_lck(struct scsi_cmnd *srb)\n{\n\tmts_scsi_cmnd_callback callback = scsi_done;\n\tstruct mts_desc* desc = (struct mts_desc*)(srb->device->host->hostdata[0]);\n\tint res;\n\n\tMTS_DEBUG_GOT_HERE();\n\tmts_show_command(srb);\n\tmts_debug_dump(desc);\n\n\tif ( srb->device->lun || srb->device->id || srb->device->channel ) {\n\n\t\tMTS_DEBUG(\"Command to LUN=%d ID=%d CHANNEL=%d from SCSI layer\\n\",(int)srb->device->lun,(int)srb->device->id, (int)srb->device->channel );\n\n\t\tMTS_DEBUG(\"this device doesn't exist\\n\");\n\n\t\tset_host_byte(srb, DID_BAD_TARGET);\n\n\t\tif(likely(callback != NULL))\n\t\t\tcallback(srb);\n\n\t\tgoto out;\n\t}\n\n\t\n\tusb_fill_bulk_urb(desc->urb,\n\t\t      desc->usb_dev,\n\t\t      usb_sndbulkpipe(desc->usb_dev,desc->ep_out),\n\t\t      srb->cmnd,\n\t\t      srb->cmd_len,\n\t\t      mts_command_done,\n\t\t      &desc->context\n\t\t      );\n\n\n\tmts_build_transfer_context( srb, desc );\n\tdesc->context.final_callback = callback;\n\t\n\t \n\tres=usb_submit_urb(desc->urb, GFP_ATOMIC);\n\n\tif(unlikely(res)){\n\t\tMTS_ERROR(\"error %d submitting URB\\n\",(int)res);\n\t\tset_host_byte(srb, DID_ERROR);\n\n\t\tif(likely(callback != NULL))\n\t\t\tcallback(srb);\n\n\t}\nout:\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(mts_scsi_queuecommand)\n\nstatic const struct scsi_host_template mts_scsi_host_template = {\n\t.module\t\t\t= THIS_MODULE,\n\t.name\t\t\t= \"microtekX6\",\n\t.proc_name\t\t= \"microtekX6\",\n\t.queuecommand\t\t= mts_scsi_queuecommand,\n\t.eh_abort_handler\t= mts_scsi_abort,\n\t.eh_host_reset_handler\t= mts_scsi_host_reset,\n\t.sg_tablesize =\t\tSG_ALL,\n\t.can_queue =\t\t1,\n\t.this_id =\t\t-1,\n\t.emulated =\t\t1,\n\t.slave_alloc =\t\tmts_slave_alloc,\n\t.slave_configure =\tmts_slave_configure,\n\t.max_sectors=\t\t256,  \n};\n\n \n\nstatic const struct usb_device_id mts_usb_ids[] =\n{\n\t{ USB_DEVICE(0x4ce, 0x0300) },\n\t{ USB_DEVICE(0x5da, 0x0094) },\n\t{ USB_DEVICE(0x5da, 0x0099) },\n\t{ USB_DEVICE(0x5da, 0x009a) },\n\t{ USB_DEVICE(0x5da, 0x00a0) },\n\t{ USB_DEVICE(0x5da, 0x00a3) },\n\t{ USB_DEVICE(0x5da, 0x80a3) },\n\t{ USB_DEVICE(0x5da, 0x80ac) },\n\t{ USB_DEVICE(0x5da, 0x00b6) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, mts_usb_ids);\n\n\nstatic int mts_usb_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tint i;\n\tint ep_out = -1;\n\tint ep_in_set[3];  \n\tint *ep_in_current = ep_in_set;\n\tint err_retval = -ENOMEM;\n\n\tstruct mts_desc * new_desc;\n\tstruct usb_device *dev = interface_to_usbdev (intf);\n\n\t \n\tstruct usb_host_interface *altsetting;\n\n\tMTS_DEBUG_GOT_HERE();\n\tMTS_DEBUG( \"usb-device descriptor at %x\\n\", (int)dev );\n\n\tMTS_DEBUG( \"product id = 0x%x, vendor id = 0x%x\\n\",\n\t\t   le16_to_cpu(dev->descriptor.idProduct),\n\t\t   le16_to_cpu(dev->descriptor.idVendor) );\n\n\tMTS_DEBUG_GOT_HERE();\n\n\t \n\taltsetting = intf->cur_altsetting;\n\n\n\t \n\n\tif ( altsetting->desc.bNumEndpoints != MTS_EP_TOTAL ) {\n\t\tMTS_WARNING( \"expecting %d got %d endpoints! Bailing out.\\n\",\n\t\t\t     (int)MTS_EP_TOTAL, (int)altsetting->desc.bNumEndpoints );\n\t\treturn -ENODEV;\n\t}\n\n\tfor( i = 0; i < altsetting->desc.bNumEndpoints; i++ ) {\n\t\tif ((altsetting->endpoint[i].desc.bmAttributes &\n\t\t     USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK) {\n\n\t\t\tMTS_WARNING( \"can only deal with bulk endpoints; endpoint %d is not bulk.\\n\",\n\t\t\t     (int)altsetting->endpoint[i].desc.bEndpointAddress );\n\t\t} else {\n\t\t\tif (altsetting->endpoint[i].desc.bEndpointAddress &\n\t\t\t    USB_DIR_IN)\n\t\t\t\t*ep_in_current++\n\t\t\t\t\t= altsetting->endpoint[i].desc.bEndpointAddress &\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\t\telse {\n\t\t\t\tif ( ep_out != -1 ) {\n\t\t\t\t\tMTS_WARNING( \"can only deal with one output endpoints. Bailing out.\" );\n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\n\t\t\t\tep_out = altsetting->endpoint[i].desc.bEndpointAddress &\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (ep_in_current != &ep_in_set[2]) {\n\t\tMTS_WARNING(\"couldn't find two input bulk endpoints. Bailing out.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ( ep_out == -1 ) {\n\t\tMTS_WARNING( \"couldn't find an output bulk endpoint. Bailing out.\\n\" );\n\t\treturn -ENODEV;\n\t}\n\n\n\tnew_desc = kzalloc(sizeof(struct mts_desc), GFP_KERNEL);\n\tif (!new_desc)\n\t\tgoto out;\n\n\tnew_desc->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!new_desc->urb)\n\t\tgoto out_kfree;\n\n\tnew_desc->context.scsi_status = kmalloc(1, GFP_KERNEL);\n\tif (!new_desc->context.scsi_status)\n\t\tgoto out_free_urb;\n\n\tnew_desc->usb_dev = dev;\n\tnew_desc->usb_intf = intf;\n\n\t \n\tnew_desc->ep_out = ep_out;\n\tnew_desc->ep_response = ep_in_set[0];\n\tnew_desc->ep_image = ep_in_set[1];\n\n\tif ( new_desc->ep_out != MTS_EP_OUT )\n\t\tMTS_WARNING( \"will this work? Command EP is not usually %d\\n\",\n\t\t\t     (int)new_desc->ep_out );\n\n\tif ( new_desc->ep_response != MTS_EP_RESPONSE )\n\t\tMTS_WARNING( \"will this work? Response EP is not usually %d\\n\",\n\t\t\t     (int)new_desc->ep_response );\n\n\tif ( new_desc->ep_image != MTS_EP_IMAGE )\n\t\tMTS_WARNING( \"will this work? Image data EP is not usually %d\\n\",\n\t\t\t     (int)new_desc->ep_image );\n\n\tnew_desc->host = scsi_host_alloc(&mts_scsi_host_template,\n\t\t\tsizeof(new_desc));\n\tif (!new_desc->host)\n\t\tgoto out_kfree2;\n\n\tnew_desc->host->hostdata[0] = (unsigned long)new_desc;\n\tif (scsi_add_host(new_desc->host, &dev->dev)) {\n\t\terr_retval = -EIO;\n\t\tgoto out_host_put;\n\t}\n\tscsi_scan_host(new_desc->host);\n\n\tusb_set_intfdata(intf, new_desc);\n\treturn 0;\n\n out_host_put:\n\tscsi_host_put(new_desc->host);\n out_kfree2:\n\tkfree(new_desc->context.scsi_status);\n out_free_urb:\n\tusb_free_urb(new_desc->urb);\n out_kfree:\n\tkfree(new_desc);\n out:\n\treturn err_retval;\n}\n\nstatic void mts_usb_disconnect (struct usb_interface *intf)\n{\n\tstruct mts_desc *desc = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tusb_kill_urb(desc->urb);\n\tscsi_remove_host(desc->host);\n\n\tscsi_host_put(desc->host);\n\tusb_free_urb(desc->urb);\n\tkfree(desc->context.scsi_status);\n\tkfree(desc);\n}\n\nmodule_usb_driver(mts_usb_driver);\n\nMODULE_AUTHOR( DRIVER_AUTHOR );\nMODULE_DESCRIPTION( DRIVER_DESC );\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}