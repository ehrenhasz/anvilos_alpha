{
  "module_name": "composite.c",
  "hash_id": "6bb9236b4464c5989a1488730e671be0db2b1d4ee158771b45c7a4720f6c5578",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/composite.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kallsyms.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/utsname.h>\n#include <linux/bitfield.h>\n#include <linux/uuid.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/webusb.h>\n#include <asm/unaligned.h>\n\n#include \"u_os_desc.h\"\n\n \nstruct usb_os_string {\n\t__u8\tbLength;\n\t__u8\tbDescriptorType;\n\t__u8\tqwSignature[OS_STRING_QW_SIGN_LEN];\n\t__u8\tbMS_VendorCode;\n\t__u8\tbPad;\n} __packed;\n\n \n\nstatic struct usb_gadget_strings **get_containers_gs(\n\t\tstruct usb_gadget_string_container *uc)\n{\n\treturn (struct usb_gadget_strings **)uc->stash;\n}\n\n \nstatic struct usb_descriptor_header **\nfunction_descriptors(struct usb_function *f,\n\t\t     enum usb_device_speed speed)\n{\n\tstruct usb_descriptor_header **descriptors;\n\n\t \n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tdescriptors = f->ssp_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tdescriptors = f->ss_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tdescriptors = f->hs_descriptors;\n\t\tif (descriptors)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tdescriptors = f->fs_descriptors;\n\t}\n\n\t \n\n\treturn descriptors;\n}\n\n \nstatic struct usb_descriptor_header**\nnext_desc(struct usb_descriptor_header **t, u8 desc_type)\n{\n\tfor (; *t; t++) {\n\t\tif ((*t)->bDescriptorType == desc_type)\n\t\t\treturn t;\n\t}\n\treturn NULL;\n}\n\n \n#define for_each_desc(start, iter_desc, desc_type) \\\n\tfor (iter_desc = next_desc(start, desc_type); \\\n\t     iter_desc; iter_desc = next_desc(iter_desc + 1, desc_type))\n\n \nint config_ep_by_speed_and_alt(struct usb_gadget *g,\n\t\t\t\tstruct usb_function *f,\n\t\t\t\tstruct usb_ep *_ep,\n\t\t\t\tu8 alt)\n{\n\tstruct usb_endpoint_descriptor *chosen_desc = NULL;\n\tstruct usb_interface_descriptor *int_desc = NULL;\n\tstruct usb_descriptor_header **speed_desc = NULL;\n\n\tstruct usb_ss_ep_comp_descriptor *comp_desc = NULL;\n\tint want_comp_desc = 0;\n\n\tstruct usb_descriptor_header **d_spd;  \n\tstruct usb_composite_dev *cdev;\n\tbool incomplete_desc = false;\n\n\tif (!g || !f || !_ep)\n\t\treturn -EIO;\n\n\t \n\tswitch (g->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (f->ssp_descriptors) {\n\t\t\tspeed_desc = f->ssp_descriptors;\n\t\t\twant_comp_desc = 1;\n\t\t\tbreak;\n\t\t}\n\t\tincomplete_desc = true;\n\t\tfallthrough;\n\tcase USB_SPEED_SUPER:\n\t\tif (f->ss_descriptors) {\n\t\t\tspeed_desc = f->ss_descriptors;\n\t\t\twant_comp_desc = 1;\n\t\t\tbreak;\n\t\t}\n\t\tincomplete_desc = true;\n\t\tfallthrough;\n\tcase USB_SPEED_HIGH:\n\t\tif (f->hs_descriptors) {\n\t\t\tspeed_desc = f->hs_descriptors;\n\t\t\tbreak;\n\t\t}\n\t\tincomplete_desc = true;\n\t\tfallthrough;\n\tdefault:\n\t\tspeed_desc = f->fs_descriptors;\n\t}\n\n\tcdev = get_gadget_data(g);\n\tif (incomplete_desc)\n\t\tWARNING(cdev,\n\t\t\t\"%s doesn't hold the descriptors for current speed\\n\",\n\t\t\tf->name);\n\n\t \n\tfor_each_desc(speed_desc, d_spd, USB_DT_INTERFACE) {\n\t\tint_desc = (struct usb_interface_descriptor *)*d_spd;\n\n\t\tif (int_desc->bAlternateSetting == alt) {\n\t\t\tspeed_desc = d_spd;\n\t\t\tgoto intf_found;\n\t\t}\n\t}\n\treturn -EIO;\n\nintf_found:\n\t \n\tfor_each_desc(speed_desc, d_spd, USB_DT_ENDPOINT) {\n\t\tchosen_desc = (struct usb_endpoint_descriptor *)*d_spd;\n\t\tif (chosen_desc->bEndpointAddress == _ep->address)\n\t\t\tgoto ep_found;\n\t}\n\treturn -EIO;\n\nep_found:\n\t \n\t_ep->maxpacket = usb_endpoint_maxp(chosen_desc);\n\t_ep->desc = chosen_desc;\n\t_ep->comp_desc = NULL;\n\t_ep->maxburst = 0;\n\t_ep->mult = 1;\n\n\tif (g->speed == USB_SPEED_HIGH && (usb_endpoint_xfer_isoc(_ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(_ep->desc)))\n\t\t_ep->mult = usb_endpoint_maxp_mult(_ep->desc);\n\n\tif (!want_comp_desc)\n\t\treturn 0;\n\n\t \n\tcomp_desc = (struct usb_ss_ep_comp_descriptor *)*(++d_spd);\n\tif (!comp_desc ||\n\t    (comp_desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP))\n\t\treturn -EIO;\n\t_ep->comp_desc = comp_desc;\n\tif (g->speed >= USB_SPEED_SUPER) {\n\t\tswitch (usb_endpoint_type(_ep->desc)) {\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t \n\t\t\t_ep->mult = (comp_desc->bmAttributes & 0x3) + 1;\n\t\t\tfallthrough;\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t_ep->maxburst = comp_desc->bMaxBurst + 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (comp_desc->bMaxBurst != 0)\n\t\t\t\tERROR(cdev, \"ep0 bMaxBurst must be 0\\n\");\n\t\t\t_ep->maxburst = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed_and_alt);\n\n \nint config_ep_by_speed(struct usb_gadget *g,\n\t\t\tstruct usb_function *f,\n\t\t\tstruct usb_ep *_ep)\n{\n\treturn config_ep_by_speed_and_alt(g, f, _ep, 0);\n}\nEXPORT_SYMBOL_GPL(config_ep_by_speed);\n\n \nint usb_add_function(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tint\tvalue = -EINVAL;\n\n\tDBG(config->cdev, \"adding '%s'/%p to config '%s'/%p\\n\",\n\t\t\tfunction->name, function,\n\t\t\tconfig->label, config);\n\n\tif (!function->set_alt || !function->disable)\n\t\tgoto done;\n\n\tfunction->config = config;\n\tlist_add_tail(&function->list, &config->functions);\n\n\tif (function->bind_deactivated) {\n\t\tvalue = usb_function_deactivate(function);\n\t\tif (value)\n\t\t\tgoto done;\n\t}\n\n\t \n\tif (function->bind) {\n\t\tvalue = function->bind(config, function);\n\t\tif (value < 0) {\n\t\t\tlist_del(&function->list);\n\t\t\tfunction->config = NULL;\n\t\t}\n\t} else\n\t\tvalue = 0;\n\n\t \n\tif (!config->fullspeed && function->fs_descriptors)\n\t\tconfig->fullspeed = true;\n\tif (!config->highspeed && function->hs_descriptors)\n\t\tconfig->highspeed = true;\n\tif (!config->superspeed && function->ss_descriptors)\n\t\tconfig->superspeed = true;\n\tif (!config->superspeed_plus && function->ssp_descriptors)\n\t\tconfig->superspeed_plus = true;\n\ndone:\n\tif (value)\n\t\tDBG(config->cdev, \"adding '%s'/%p --> %d\\n\",\n\t\t\t\tfunction->name, function, value);\n\treturn value;\n}\nEXPORT_SYMBOL_GPL(usb_add_function);\n\nvoid usb_remove_function(struct usb_configuration *c, struct usb_function *f)\n{\n\tif (f->disable)\n\t\tf->disable(f);\n\n\tbitmap_zero(f->endpoints, 32);\n\tlist_del(&f->list);\n\tif (f->unbind)\n\t\tf->unbind(c, f);\n\n\tif (f->bind_deactivated)\n\t\tusb_function_activate(f);\n}\nEXPORT_SYMBOL_GPL(usb_remove_function);\n\n \nint usb_function_deactivate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->deactivations == 0) {\n\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\tstatus = usb_gadget_deactivate(cdev->gadget);\n\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t}\n\tif (status == 0)\n\t\tcdev->deactivations++;\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_deactivate);\n\n \nint usb_function_activate(struct usb_function *function)\n{\n\tstruct usb_composite_dev\t*cdev = function->config->cdev;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\tstatus = 0;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (WARN_ON(cdev->deactivations == 0))\n\t\tstatus = -EINVAL;\n\telse {\n\t\tcdev->deactivations--;\n\t\tif (cdev->deactivations == 0) {\n\t\t\tspin_unlock_irqrestore(&cdev->lock, flags);\n\t\t\tstatus = usb_gadget_activate(cdev->gadget);\n\t\t\tspin_lock_irqsave(&cdev->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_function_activate);\n\n \nint usb_interface_id(struct usb_configuration *config,\n\t\tstruct usb_function *function)\n{\n\tunsigned id = config->next_interface_id;\n\n\tif (id < MAX_CONFIG_INTERFACES) {\n\t\tconfig->interface[id] = function;\n\t\tconfig->next_interface_id = id + 1;\n\t\treturn id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_interface_id);\n\n \nint usb_func_wakeup(struct usb_function *func)\n{\n\tstruct usb_gadget\t*gadget = func->config->cdev->gadget;\n\tint\t\t\tid;\n\n\tif (!gadget->ops->func_wakeup)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!func->func_wakeup_armed) {\n\t\tERROR(func->config->cdev, \"not armed for func remote wakeup\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (id = 0; id < MAX_CONFIG_INTERFACES; id++)\n\t\tif (func->config->interface[id] == func)\n\t\t\tbreak;\n\n\tif (id == MAX_CONFIG_INTERFACES) {\n\t\tERROR(func->config->cdev, \"Invalid function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn gadget->ops->func_wakeup(gadget, id);\n}\nEXPORT_SYMBOL_GPL(usb_func_wakeup);\n\nstatic u8 encode_bMaxPower(enum usb_device_speed speed,\n\t\tstruct usb_configuration *c)\n{\n\tunsigned val;\n\n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tval = c->MaxPower;\n\telse\n\t\tval = CONFIG_USB_GADGET_VBUS_DRAW;\n\tif (!val)\n\t\treturn 0;\n\tif (speed < USB_SPEED_SUPER)\n\t\treturn min(val, 500U) / 2;\n\telse\n\t\t \n\t\treturn min(val, 900U) / 8;\n}\n\nvoid check_remote_wakeup_config(struct usb_gadget *g,\n\t\t\t\tstruct usb_configuration *c)\n{\n\tif (USB_CONFIG_ATT_WAKEUP & c->bmAttributes) {\n\t\t \n\t\tif (!g->wakeup_capable && g->ops->set_remote_wakeup) {\n\t\t\tWARN(c->cdev, \"Clearing wakeup bit for config c.%d\\n\",\n\t\t\t     c->bConfigurationValue);\n\t\t\tc->bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;\n\t\t}\n\t}\n}\n\nstatic int config_buf(struct usb_configuration *config,\n\t\tenum usb_device_speed speed, void *buf, u8 type)\n{\n\tstruct usb_config_descriptor\t*c = buf;\n\tvoid\t\t\t\t*next = buf + USB_DT_CONFIG_SIZE;\n\tint\t\t\t\tlen;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tstatus;\n\n\tlen = USB_COMP_EP0_BUFSIZ - USB_DT_CONFIG_SIZE;\n\t \n\tc = buf;\n\tc->bLength = USB_DT_CONFIG_SIZE;\n\tc->bDescriptorType = type;\n\t \n\tc->bNumInterfaces = config->next_interface_id;\n\tc->bConfigurationValue = config->bConfigurationValue;\n\tc->iConfiguration = config->iConfiguration;\n\tc->bmAttributes = USB_CONFIG_ATT_ONE | config->bmAttributes;\n\tc->bMaxPower = encode_bMaxPower(speed, config);\n\n\t \n\tif (config->descriptors) {\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t\tconfig->descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\t \n\tlist_for_each_entry(f, &config->functions, list) {\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tdescriptors = function_descriptors(f, speed);\n\t\tif (!descriptors)\n\t\t\tcontinue;\n\t\tstatus = usb_descriptor_fillbuf(next, len,\n\t\t\t(const struct usb_descriptor_header **) descriptors);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tlen -= status;\n\t\tnext += status;\n\t}\n\n\tlen = next - buf;\n\tc->wTotalLength = cpu_to_le16(len);\n\treturn len;\n}\n\nstatic int config_desc(struct usb_composite_dev *cdev, unsigned w_value)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tstruct list_head\t\t*pos;\n\tu8\t\t\t\ttype = w_value >> 8;\n\tenum usb_device_speed\t\tspeed = USB_SPEED_UNKNOWN;\n\n\tif (gadget->speed >= USB_SPEED_SUPER)\n\t\tspeed = gadget->speed;\n\telse if (gadget_is_dualspeed(gadget)) {\n\t\tint\ths = 0;\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (type == USB_DT_OTHER_SPEED_CONFIG)\n\t\t\ths = !hs;\n\t\tif (hs)\n\t\t\tspeed = USB_SPEED_HIGH;\n\n\t}\n\n\t \n\tw_value &= 0xff;\n\n\tpos = &cdev->configs;\n\tc = cdev->os_desc_config;\n\tif (c)\n\t\tgoto check_config;\n\n\twhile ((pos = pos->next) !=  &cdev->configs) {\n\t\tc = list_entry(pos, typeof(*c), list);\n\n\t\t \n\t\tif (c == cdev->os_desc_config)\n\t\t\tcontinue;\n\ncheck_config:\n\t\t \n\t\tswitch (speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER:\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (w_value == 0)\n\t\t\treturn config_buf(c, speed, cdev->req->buf, type);\n\t\tw_value--;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int count_configs(struct usb_composite_dev *cdev, unsigned type)\n{\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct usb_configuration\t*c;\n\tunsigned\t\t\tcount = 0;\n\tint\t\t\t\ths = 0;\n\tint\t\t\t\tss = 0;\n\tint\t\t\t\tssp = 0;\n\n\tif (gadget_is_dualspeed(gadget)) {\n\t\tif (gadget->speed == USB_SPEED_HIGH)\n\t\t\ths = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER)\n\t\t\tss = 1;\n\t\tif (gadget->speed == USB_SPEED_SUPER_PLUS)\n\t\t\tssp = 1;\n\t\tif (type == USB_DT_DEVICE_QUALIFIER)\n\t\t\ths = !hs;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t \n\t\tif (ssp) {\n\t\t\tif (!c->superspeed_plus)\n\t\t\t\tcontinue;\n\t\t} else if (ss) {\n\t\t\tif (!c->superspeed)\n\t\t\t\tcontinue;\n\t\t} else if (hs) {\n\t\t\tif (!c->highspeed)\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\tif (!c->fullspeed)\n\t\t\t\tcontinue;\n\t\t}\n\t\tcount++;\n\t}\n\treturn count;\n}\n\n \nstatic int bos_desc(struct usb_composite_dev *cdev)\n{\n\tstruct usb_ext_cap_descriptor\t*usb_ext;\n\tstruct usb_dcd_config_params\tdcd_config_params;\n\tstruct usb_bos_descriptor\t*bos = cdev->req->buf;\n\tunsigned int\t\t\tbesl = 0;\n\n\tbos->bLength = USB_DT_BOS_SIZE;\n\tbos->bDescriptorType = USB_DT_BOS;\n\n\tbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE);\n\tbos->bNumDeviceCaps = 0;\n\n\t \n\tif (cdev->gadget->ops->get_config_params) {\n\t\tcdev->gadget->ops->get_config_params(cdev->gadget,\n\t\t\t\t\t\t     &dcd_config_params);\n\t} else {\n\t\tdcd_config_params.besl_baseline =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.besl_deep =\n\t\t\tUSB_DEFAULT_BESL_UNSPECIFIED;\n\t\tdcd_config_params.bU1devExitLat =\n\t\t\tUSB_DEFAULT_U1_DEV_EXIT_LAT;\n\t\tdcd_config_params.bU2DevExitLat =\n\t\t\tcpu_to_le16(USB_DEFAULT_U2_DEV_EXIT_LAT);\n\t}\n\n\tif (dcd_config_params.besl_baseline != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl = USB_BESL_BASELINE_VALID |\n\t\t\tUSB_SET_BESL_BASELINE(dcd_config_params.besl_baseline);\n\n\tif (dcd_config_params.besl_deep != USB_DEFAULT_BESL_UNSPECIFIED)\n\t\tbesl |= USB_BESL_DEEP_VALID |\n\t\t\tUSB_SET_BESL_DEEP(dcd_config_params.besl_deep);\n\n\t \n\tif (cdev->gadget->lpm_capable) {\n\t\tusb_ext = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_EXT_CAP_SIZE);\n\t\tusb_ext->bLength = USB_DT_USB_EXT_CAP_SIZE;\n\t\tusb_ext->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tusb_ext->bDevCapabilityType = USB_CAP_TYPE_EXT;\n\t\tusb_ext->bmAttributes = cpu_to_le32(USB_LPM_SUPPORT |\n\t\t\t\t\t\t\tUSB_BESL_SUPPORT | besl);\n\t}\n\n\t \n\tif (gadget_is_superspeed(cdev->gadget)) {\n\t\tstruct usb_ss_cap_descriptor *ss_cap;\n\n\t\tss_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SS_CAP_SIZE);\n\t\tss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\n\t\tss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\n\t\tss_cap->bmAttributes = 0;  \n\t\tss_cap->wSpeedSupported = cpu_to_le16(USB_LOW_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_FULL_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_HIGH_SPEED_OPERATION |\n\t\t\t\t\t\t      USB_5GBPS_OPERATION);\n\t\tss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\n\t\tss_cap->bU1devExitLat = dcd_config_params.bU1devExitLat;\n\t\tss_cap->bU2DevExitLat = dcd_config_params.bU2DevExitLat;\n\t}\n\n\t \n\tif (gadget_is_superspeed_plus(cdev->gadget)) {\n\t\tstruct usb_ssp_cap_descriptor *ssp_cap;\n\t\tu8 ssac = 1;\n\t\tu8 ssic;\n\t\tint i;\n\n\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x2)\n\t\t\tssac = 3;\n\n\t\t \n\t\tssic = (ssac + 1) / 2 - 1;\n\n\t\tssp_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\tbos->bNumDeviceCaps++;\n\n\t\tle16_add_cpu(&bos->wTotalLength, USB_DT_USB_SSP_CAP_SIZE(ssac));\n\t\tssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(ssac);\n\t\tssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\tssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;\n\t\tssp_cap->bReserved = 0;\n\t\tssp_cap->wReserved = 0;\n\n\t\tssp_cap->bmAttributes =\n\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_ATTRIBS, ssac) |\n\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_IDS, ssic));\n\n\t\tssp_cap->wFunctionalitySupport =\n\t\t\tcpu_to_le16(FIELD_PREP(USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID, 0) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_RX_LANE_COUNT, 1) |\n\t\t\t\t    FIELD_PREP(USB_SSP_MIN_TX_LANE_COUNT, 1));\n\n\t\t \n\t\tfor (i = 0; i < ssac + 1; i++) {\n\t\t\tu8 ssid;\n\t\t\tu8 mantissa;\n\t\t\tu8 type;\n\n\t\t\tssid = i >> 1;\n\n\t\t\tif (cdev->gadget->max_ssp_rate == USB_SSP_GEN_2x1 ||\n\t\t\t    cdev->gadget->max_ssp_rate == USB_SSP_GEN_UNKNOWN)\n\t\t\t\tmantissa = 10;\n\t\t\telse\n\t\t\t\tmantissa = 5 << ssid;\n\n\t\t\tif (i % 2)\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_TX;\n\t\t\telse\n\t\t\t\ttype = USB_SSP_SUBLINK_SPEED_ST_SYM_RX;\n\n\t\t\tssp_cap->bmSublinkSpeedAttr[i] =\n\t\t\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_SSID, ssid) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSE,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LSE_GBPS) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST, type) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LP,\n\t\t\t\t\t\t       USB_SSP_SUBLINK_SPEED_LP_SSP) |\n\t\t\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_LSM, mantissa));\n\t\t}\n\t}\n\n\t \n\tif (cdev->use_webusb) {\n\t\tstruct usb_plat_dev_cap_descriptor *webusb_cap;\n\t\tstruct usb_webusb_cap_data *webusb_cap_data;\n\t\tguid_t webusb_uuid = WEBUSB_UUID;\n\n\t\twebusb_cap = cdev->req->buf + le16_to_cpu(bos->wTotalLength);\n\t\twebusb_cap_data = (struct usb_webusb_cap_data *) webusb_cap->CapabilityData;\n\t\tbos->bNumDeviceCaps++;\n\t\tle16_add_cpu(&bos->wTotalLength,\n\t\t\tUSB_DT_USB_PLAT_DEV_CAP_SIZE(USB_WEBUSB_CAP_DATA_SIZE));\n\n\t\twebusb_cap->bLength = USB_DT_USB_PLAT_DEV_CAP_SIZE(USB_WEBUSB_CAP_DATA_SIZE);\n\t\twebusb_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\t\twebusb_cap->bDevCapabilityType = USB_PLAT_DEV_CAP_TYPE;\n\t\twebusb_cap->bReserved = 0;\n\t\texport_guid(webusb_cap->UUID, &webusb_uuid);\n\n\t\tif (cdev->bcd_webusb_version != 0)\n\t\t\twebusb_cap_data->bcdVersion = cpu_to_le16(cdev->bcd_webusb_version);\n\t\telse\n\t\t\twebusb_cap_data->bcdVersion = WEBUSB_VERSION_1_00;\n\n\t\twebusb_cap_data->bVendorCode = cdev->b_webusb_vendor_code;\n\n\t\tif (strnlen(cdev->landing_page, sizeof(cdev->landing_page)) > 0)\n\t\t\twebusb_cap_data->iLandingPage = WEBUSB_LANDING_PAGE_PRESENT;\n\t\telse\n\t\t\twebusb_cap_data->iLandingPage = WEBUSB_LANDING_PAGE_NOT_PRESENT;\n\t}\n\n\treturn le16_to_cpu(bos->wTotalLength);\n}\n\nstatic void device_qual(struct usb_composite_dev *cdev)\n{\n\tstruct usb_qualifier_descriptor\t*qual = cdev->req->buf;\n\n\tqual->bLength = sizeof(*qual);\n\tqual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;\n\t \n\tqual->bcdUSB = cdev->desc.bcdUSB;\n\tqual->bDeviceClass = cdev->desc.bDeviceClass;\n\tqual->bDeviceSubClass = cdev->desc.bDeviceSubClass;\n\tqual->bDeviceProtocol = cdev->desc.bDeviceProtocol;\n\t \n\tqual->bMaxPacketSize0 = cdev->gadget->ep0->maxpacket;\n\tqual->bNumConfigurations = count_configs(cdev, USB_DT_DEVICE_QUALIFIER);\n\tqual->bRESERVED = 0;\n}\n\n \n\nstatic void reset_config(struct usb_composite_dev *cdev)\n{\n\tstruct usb_function\t\t*f;\n\n\tDBG(cdev, \"reset config\\n\");\n\n\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\tif (f->disable)\n\t\t\tf->disable(f);\n\n\t\t \n\t\tf->func_wakeup_armed = false;\n\n\t\tbitmap_zero(f->endpoints, 32);\n\t}\n\tcdev->config = NULL;\n\tcdev->delayed_status = 0;\n}\n\nstatic int set_config(struct usb_composite_dev *cdev,\n\t\tconst struct usb_ctrlrequest *ctrl, unsigned number)\n{\n\tstruct usb_gadget\t*gadget = cdev->gadget;\n\tstruct usb_configuration *c = NULL, *iter;\n\tint\t\t\tresult = -EINVAL;\n\tunsigned\t\tpower = gadget_is_otg(gadget) ? 8 : 100;\n\tint\t\t\ttmp;\n\n\tif (number) {\n\t\tlist_for_each_entry(iter, &cdev->configs, list) {\n\t\t\tif (iter->bConfigurationValue != number)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (cdev->config)\n\t\t\t\treset_config(cdev);\n\t\t\tc = iter;\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (result < 0)\n\t\t\tgoto done;\n\t} else {  \n\t\tif (cdev->config)\n\t\t\treset_config(cdev);\n\t\tresult = 0;\n\t}\n\n\tDBG(cdev, \"%s config #%d: %s\\n\",\n\t    usb_speed_string(gadget->speed),\n\t    number, c ? c->label : \"unconfigured\");\n\n\tif (!c)\n\t\tgoto done;\n\n\tusb_gadget_set_state(gadget, USB_STATE_CONFIGURED);\n\tcdev->config = c;\n\n\t \n\tfor (tmp = 0; tmp < MAX_CONFIG_INTERFACES; tmp++) {\n\t\tstruct usb_function\t*f = c->interface[tmp];\n\t\tstruct usb_descriptor_header **descriptors;\n\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t \n\t\tdescriptors = function_descriptors(f, gadget->speed);\n\n\t\tfor (; *descriptors; ++descriptors) {\n\t\t\tstruct usb_endpoint_descriptor *ep;\n\t\t\tint addr;\n\n\t\t\tif ((*descriptors)->bDescriptorType != USB_DT_ENDPOINT)\n\t\t\t\tcontinue;\n\n\t\t\tep = (struct usb_endpoint_descriptor *)*descriptors;\n\t\t\taddr = ((ep->bEndpointAddress & 0x80) >> 3)\n\t\t\t     |  (ep->bEndpointAddress & 0x0f);\n\t\t\tset_bit(addr, f->endpoints);\n\t\t}\n\n\t\tresult = f->set_alt(f, tmp, 0);\n\t\tif (result < 0) {\n\t\t\tDBG(cdev, \"interface %d (%s/%p) alt 0 --> %d\\n\",\n\t\t\t\t\ttmp, f->name, f, result);\n\n\t\t\treset_config(cdev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (result == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, tmp, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t}\n\n\t \n\tif (c->MaxPower || (c->bmAttributes & USB_CONFIG_ATT_SELFPOWER))\n\t\tpower = c->MaxPower;\n\telse\n\t\tpower = CONFIG_USB_GADGET_VBUS_DRAW;\n\n\tif (gadget->speed < USB_SPEED_SUPER)\n\t\tpower = min(power, 500U);\n\telse\n\t\tpower = min(power, 900U);\n\n\tif (USB_CONFIG_ATT_WAKEUP & c->bmAttributes)\n\t\tusb_gadget_set_remote_wakeup(gadget, 1);\n\telse\n\t\tusb_gadget_set_remote_wakeup(gadget, 0);\ndone:\n\tif (power <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\telse\n\t\tusb_gadget_clear_selfpowered(gadget);\n\n\tusb_gadget_vbus_draw(gadget, power);\n\tif (result >= 0 && cdev->delayed_status)\n\t\tresult = USB_GADGET_DELAYED_STATUS;\n\treturn result;\n}\n\nint usb_add_config_only(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config)\n{\n\tstruct usb_configuration *c;\n\n\tif (!config->bConfigurationValue)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->bConfigurationValue == config->bConfigurationValue)\n\t\t\treturn -EBUSY;\n\t}\n\n\tconfig->cdev = cdev;\n\tlist_add_tail(&config->list, &cdev->configs);\n\n\tINIT_LIST_HEAD(&config->functions);\n\tconfig->next_interface_id = 0;\n\tmemset(config->interface, 0, sizeof(config->interface));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_add_config_only);\n\n \nint usb_add_config(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *config,\n\t\tint (*bind)(struct usb_configuration *))\n{\n\tint\t\t\t\tstatus = -EINVAL;\n\n\tif (!bind)\n\t\tgoto done;\n\n\tDBG(cdev, \"adding config #%u '%s'/%p\\n\",\n\t\t\tconfig->bConfigurationValue,\n\t\t\tconfig->label, config);\n\n\tstatus = usb_add_config_only(cdev, config);\n\tif (status)\n\t\tgoto done;\n\n\tstatus = bind(config);\n\n\tif (status == 0)\n\t\tstatus = usb_gadget_check_config(cdev->gadget);\n\n\tif (status < 0) {\n\t\twhile (!list_empty(&config->functions)) {\n\t\t\tstruct usb_function\t\t*f;\n\n\t\t\tf = list_first_entry(&config->functions,\n\t\t\t\t\tstruct usb_function, list);\n\t\t\tlist_del(&f->list);\n\t\t\tif (f->unbind) {\n\t\t\t\tDBG(cdev, \"unbind function '%s'/%p\\n\",\n\t\t\t\t\tf->name, f);\n\t\t\t\tf->unbind(config, f);\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t\tlist_del(&config->list);\n\t\tconfig->cdev = NULL;\n\t} else {\n\t\tunsigned\ti;\n\n\t\tDBG(cdev, \"cfg %d/%p speeds:%s%s%s%s\\n\",\n\t\t\tconfig->bConfigurationValue, config,\n\t\t\tconfig->superspeed_plus ? \" superplus\" : \"\",\n\t\t\tconfig->superspeed ? \" super\" : \"\",\n\t\t\tconfig->highspeed ? \" high\" : \"\",\n\t\t\tconfig->fullspeed\n\t\t\t\t? (gadget_is_dualspeed(cdev->gadget)\n\t\t\t\t\t? \" full\"\n\t\t\t\t\t: \" full/low\")\n\t\t\t\t: \"\");\n\n\t\tfor (i = 0; i < MAX_CONFIG_INTERFACES; i++) {\n\t\t\tstruct usb_function\t*f = config->interface[i];\n\n\t\t\tif (!f)\n\t\t\t\tcontinue;\n\t\t\tDBG(cdev, \"  interface %d = %s/%p\\n\",\n\t\t\t\ti, f->name, f);\n\t\t}\n\t}\n\n\t \n\tusb_ep_autoconfig_reset(cdev->gadget);\n\ndone:\n\tif (status)\n\t\tDBG(cdev, \"added config '%s'/%u --> %d\\n\", config->label,\n\t\t\t\tconfig->bConfigurationValue, status);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_add_config);\n\nstatic void remove_config(struct usb_composite_dev *cdev,\n\t\t\t      struct usb_configuration *config)\n{\n\twhile (!list_empty(&config->functions)) {\n\t\tstruct usb_function\t\t*f;\n\n\t\tf = list_first_entry(&config->functions,\n\t\t\t\tstruct usb_function, list);\n\n\t\tusb_remove_function(config, f);\n\t}\n\tlist_del(&config->list);\n\tif (config->unbind) {\n\t\tDBG(cdev, \"unbind config '%s'/%p\\n\", config->label, config);\n\t\tconfig->unbind(config);\n\t\t\t \n\t}\n}\n\n \nvoid usb_remove_config(struct usb_composite_dev *cdev,\n\t\t      struct usb_configuration *config)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->config == config)\n\t\treset_config(cdev);\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n\n\tremove_config(cdev, config);\n}\n\n \n\n \n\nstatic void collect_langs(struct usb_gadget_strings **sp, __le16 *buf)\n{\n\tconst struct usb_gadget_strings\t*s;\n\t__le16\t\t\t\tlanguage;\n\t__le16\t\t\t\t*tmp;\n\n\twhile (*sp) {\n\t\ts = *sp;\n\t\tlanguage = cpu_to_le16(s->language);\n\t\tfor (tmp = buf; *tmp && tmp < &buf[USB_MAX_STRING_LEN]; tmp++) {\n\t\t\tif (*tmp == language)\n\t\t\t\tgoto repeat;\n\t\t}\n\t\t*tmp++ = language;\nrepeat:\n\t\tsp++;\n\t}\n}\n\nstatic int lookup_string(\n\tstruct usb_gadget_strings\t**sp,\n\tvoid\t\t\t\t*buf,\n\tu16\t\t\t\tlanguage,\n\tint\t\t\t\tid\n)\n{\n\tstruct usb_gadget_strings\t*s;\n\tint\t\t\t\tvalue;\n\n\twhile (*sp) {\n\t\ts = *sp++;\n\t\tif (s->language != language)\n\t\t\tcontinue;\n\t\tvalue = usb_gadget_get_string(s, id, buf);\n\t\tif (value > 0)\n\t\t\treturn value;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int get_string(struct usb_composite_dev *cdev,\n\t\tvoid *buf, u16 language, int id)\n{\n\tstruct usb_composite_driver\t*composite = cdev->driver;\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_configuration\t*c;\n\tstruct usb_function\t\t*f;\n\tint\t\t\t\tlen;\n\n\t \n\n\t \n\tif (id == 0) {\n\t\tstruct usb_string_descriptor\t*s = buf;\n\t\tstruct usb_gadget_strings\t**sp;\n\n\t\tmemset(s, 0, 256);\n\t\ts->bDescriptorType = USB_DT_STRING;\n\n\t\tsp = composite->strings;\n\t\tif (sp)\n\t\t\tcollect_langs(sp, s->wData);\n\n\t\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\t\tsp = c->strings;\n\t\t\tif (sp)\n\t\t\t\tcollect_langs(sp, s->wData);\n\n\t\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\t\tsp = f->strings;\n\t\t\t\tif (sp)\n\t\t\t\t\tcollect_langs(sp, s->wData);\n\t\t\t}\n\t\t}\n\t\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\t\tstruct usb_gadget_strings **sp;\n\n\t\t\tsp = get_containers_gs(uc);\n\t\t\tcollect_langs(sp, s->wData);\n\t\t}\n\n\t\tfor (len = 0; len <= USB_MAX_STRING_LEN && s->wData[len]; len++)\n\t\t\tcontinue;\n\t\tif (!len)\n\t\t\treturn -EINVAL;\n\n\t\ts->bLength = 2 * (len + 1);\n\t\treturn s->bLength;\n\t}\n\n\tif (cdev->use_os_string && language == 0 && id == OS_STRING_IDX) {\n\t\tstruct usb_os_string *b = buf;\n\t\tb->bLength = sizeof(*b);\n\t\tb->bDescriptorType = USB_DT_STRING;\n\t\tcompiletime_assert(\n\t\t\tsizeof(b->qwSignature) == sizeof(cdev->qw_sign),\n\t\t\t\"qwSignature size must be equal to qw_sign\");\n\t\tmemcpy(&b->qwSignature, cdev->qw_sign, sizeof(b->qwSignature));\n\t\tb->bMS_VendorCode = cdev->b_vendor_code;\n\t\tb->bPad = 0;\n\t\treturn sizeof(*b);\n\t}\n\n\tlist_for_each_entry(uc, &cdev->gstrings, list) {\n\t\tstruct usb_gadget_strings **sp;\n\n\t\tsp = get_containers_gs(uc);\n\t\tlen = lookup_string(sp, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\n\t \n\tif (composite->strings) {\n\t\tlen = lookup_string(composite->strings, buf, language, id);\n\t\tif (len > 0)\n\t\t\treturn len;\n\t}\n\tlist_for_each_entry(c, &cdev->configs, list) {\n\t\tif (c->strings) {\n\t\t\tlen = lookup_string(c->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t\tlist_for_each_entry(f, &c->functions, list) {\n\t\t\tif (!f->strings)\n\t\t\t\tcontinue;\n\t\t\tlen = lookup_string(f->strings, buf, language, id);\n\t\t\tif (len > 0)\n\t\t\t\treturn len;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nint usb_string_id(struct usb_composite_dev *cdev)\n{\n\tif (cdev->next_string_id < 254) {\n\t\t \n\t\t \n\t\tcdev->next_string_id++;\n\t\treturn cdev->next_string_id;\n\t}\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL_GPL(usb_string_id);\n\n \nint usb_string_ids_tab(struct usb_composite_dev *cdev, struct usb_string *str)\n{\n\tint next = cdev->next_string_id;\n\n\tfor (; str->s; ++str) {\n\t\tif (unlikely(next >= 254))\n\t\t\treturn -ENODEV;\n\t\tstr->id = ++next;\n\t}\n\n\tcdev->next_string_id = next;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_tab);\n\nstatic struct usb_gadget_string_container *copy_gadget_strings(\n\t\tstruct usb_gadget_strings **sp, unsigned n_gstrings,\n\t\tunsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **gs_array;\n\tstruct usb_gadget_strings *gs;\n\tstruct usb_string *s;\n\tunsigned mem;\n\tunsigned n_gs;\n\tunsigned n_s;\n\tvoid *stash;\n\n\tmem = sizeof(*uc);\n\tmem += sizeof(void *) * (n_gstrings + 1);\n\tmem += sizeof(struct usb_gadget_strings) * n_gstrings;\n\tmem += sizeof(struct usb_string) * (n_strings + 1) * (n_gstrings);\n\tuc = kmalloc(mem, GFP_KERNEL);\n\tif (!uc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tgs_array = get_containers_gs(uc);\n\tstash = uc->stash;\n\tstash += sizeof(void *) * (n_gstrings + 1);\n\tfor (n_gs = 0; n_gs < n_gstrings; n_gs++) {\n\t\tstruct usb_string *org_s;\n\n\t\tgs_array[n_gs] = stash;\n\t\tgs = gs_array[n_gs];\n\t\tstash += sizeof(struct usb_gadget_strings);\n\t\tgs->language = sp[n_gs]->language;\n\t\tgs->strings = stash;\n\t\torg_s = sp[n_gs]->strings;\n\n\t\tfor (n_s = 0; n_s < n_strings; n_s++) {\n\t\t\ts = stash;\n\t\t\tstash += sizeof(struct usb_string);\n\t\t\tif (org_s->s)\n\t\t\t\ts->s = org_s->s;\n\t\t\telse\n\t\t\t\ts->s = \"\";\n\t\t\torg_s++;\n\t\t}\n\t\ts = stash;\n\t\ts->s = NULL;\n\t\tstash += sizeof(struct usb_string);\n\n\t}\n\tgs_array[n_gs] = NULL;\n\treturn uc;\n}\n\n \nstruct usb_string *usb_gstrings_attach(struct usb_composite_dev *cdev,\n\t\tstruct usb_gadget_strings **sp, unsigned n_strings)\n{\n\tstruct usb_gadget_string_container *uc;\n\tstruct usb_gadget_strings **n_gs;\n\tunsigned n_gstrings = 0;\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; sp[i]; i++)\n\t\tn_gstrings++;\n\n\tif (!n_gstrings)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tuc = copy_gadget_strings(sp, n_gstrings, n_strings);\n\tif (IS_ERR(uc))\n\t\treturn ERR_CAST(uc);\n\n\tn_gs = get_containers_gs(uc);\n\tret = usb_string_ids_tab(cdev, n_gs[0]->strings);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 1; i < n_gstrings; i++) {\n\t\tstruct usb_string *m_s;\n\t\tstruct usb_string *s;\n\t\tunsigned n;\n\n\t\tm_s = n_gs[0]->strings;\n\t\ts = n_gs[i]->strings;\n\t\tfor (n = 0; n < n_strings; n++) {\n\t\t\ts->id = m_s->id;\n\t\t\ts++;\n\t\t\tm_s++;\n\t\t}\n\t}\n\tlist_add_tail(&uc->list, &cdev->gstrings);\n\treturn n_gs[0]->strings;\nerr:\n\tkfree(uc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(usb_gstrings_attach);\n\n \nint usb_string_ids_n(struct usb_composite_dev *c, unsigned n)\n{\n\tunsigned next = c->next_string_id;\n\tif (unlikely(n > 254 || (unsigned)next + n > 254))\n\t\treturn -ENODEV;\n\tc->next_string_id += n;\n\treturn next + 1;\n}\nEXPORT_SYMBOL_GPL(usb_string_ids_n);\n\n \n\nstatic void composite_setup_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_composite_dev *cdev;\n\n\tif (req->status || req->actual != req->length)\n\t\tDBG((struct usb_composite_dev *) ep->driver_data,\n\t\t\t\t\"setup complete --> %d, %d/%d\\n\",\n\t\t\t\treq->status, req->actual, req->length);\n\n\t \n\tif (!req->context)\n\t\treturn;\n\n\tcdev = req->context;\n\n\tif (cdev->req == req)\n\t\tcdev->setup_pending = false;\n\telse if (cdev->os_desc_req == req)\n\t\tcdev->os_desc_pending = false;\n\telse\n\t\tWARN(1, \"unknown request %p\\n\", req);\n}\n\nstatic int composite_ep0_queue(struct usb_composite_dev *cdev,\n\t\tstruct usb_request *req, gfp_t gfp_flags)\n{\n\tint ret;\n\n\tret = usb_ep_queue(cdev->gadget->ep0, req, gfp_flags);\n\tif (ret == 0) {\n\t\tif (cdev->req == req)\n\t\t\tcdev->setup_pending = true;\n\t\telse if (cdev->os_desc_req == req)\n\t\t\tcdev->os_desc_pending = true;\n\t\telse\n\t\t\tWARN(1, \"unknown request %p\\n\", req);\n\t}\n\n\treturn ret;\n}\n\nstatic int count_ext_compat(struct usb_configuration *c)\n{\n\tint i, res;\n\n\tres = 0;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id)\n\t\t\t\t++res;\n\t\t}\n\t}\n\tBUG_ON(res > 255);\n\treturn res;\n}\n\nstatic int fill_ext_compat(struct usb_configuration *c, u8 *buf)\n{\n\tint i, count;\n\n\tcount = 16;\n\tbuf += 16;\n\tfor (i = 0; i < c->next_interface_id; ++i) {\n\t\tstruct usb_function *f;\n\t\tint j;\n\n\t\tf = c->interface[i];\n\t\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\t\tstruct usb_os_desc *d;\n\n\t\t\tif (i != f->os_desc_table[j].if_id)\n\t\t\t\tcontinue;\n\t\t\td = f->os_desc_table[j].os_desc;\n\t\t\tif (d && d->ext_compat_id) {\n\t\t\t\t*buf++ = i;\n\t\t\t\t*buf++ = 0x01;\n\t\t\t\tmemcpy(buf, d->ext_compat_id, 16);\n\t\t\t\tbuf += 22;\n\t\t\t} else {\n\t\t\t\t++buf;\n\t\t\t\t*buf = 0x01;\n\t\t\t\tbuf += 23;\n\t\t\t}\n\t\t\tcount += 24;\n\t\t\tif (count + 24 >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\treturn count;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic int count_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tint j;\n\n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tstruct usb_os_desc *d;\n\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d && d->ext_compat_id)\n\t\t\treturn d->ext_prop_count;\n\t}\n\treturn 0;\n}\n\nstatic int len_ext_prop(struct usb_configuration *c, int interface)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tint j, res;\n\n\tres = 10;  \n\tf = c->interface[interface];\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\treturn min(res + d->ext_prop_len, 4096);\n\t}\n\treturn res;\n}\n\nstatic int fill_ext_prop(struct usb_configuration *c, int interface, u8 *buf)\n{\n\tstruct usb_function *f;\n\tstruct usb_os_desc *d;\n\tstruct usb_os_desc_ext_prop *ext_prop;\n\tint j, count, n, ret;\n\n\tf = c->interface[interface];\n\tcount = 10;  \n\tbuf += 10;\n\tfor (j = 0; j < f->os_desc_n; ++j) {\n\t\tif (interface != f->os_desc_table[j].if_id)\n\t\t\tcontinue;\n\t\td = f->os_desc_table[j].os_desc;\n\t\tif (d)\n\t\t\tlist_for_each_entry(ext_prop, &d->ext_prop, entry) {\n\t\t\t\tn = ext_prop->data_len +\n\t\t\t\t\text_prop->name_len + 14;\n\t\t\t\tif (count + n >= USB_COMP_EP0_OS_DESC_BUFSIZ)\n\t\t\t\t\treturn count;\n\t\t\t\tusb_ext_prop_put_size(buf, n);\n\t\t\t\tusb_ext_prop_put_type(buf, ext_prop->type);\n\t\t\t\tret = usb_ext_prop_put_name(buf, ext_prop->name,\n\t\t\t\t\t\t\t    ext_prop->name_len);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\treturn ret;\n\t\t\t\tswitch (ext_prop->type) {\n\t\t\t\tcase USB_EXT_PROP_UNICODE:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\t\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\t\t\t\tusb_ext_prop_put_unicode(buf, ret,\n\t\t\t\t\t\t\t ext_prop->data,\n\t\t\t\t\t\t\t ext_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_BINARY:\n\t\t\t\t\tusb_ext_prop_put_binary(buf, ret,\n\t\t\t\t\t\t\text_prop->data,\n\t\t\t\t\t\t\text_prop->data_len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_EXT_PROP_LE32:\n\t\t\t\t\t \n\t\t\t\tcase USB_EXT_PROP_BE32:\n\t\t\t\t\t \n\t\t\t\tdefault:\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t\tbuf += n;\n\t\t\t\tcount += n;\n\t\t\t}\n\t}\n\n\treturn count;\n}\n\n \nint\ncomposite_setup(struct usb_gadget *gadget, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_request\t\t*req = cdev->req;\n\tint\t\t\t\tvalue = -EOPNOTSUPP;\n\tint\t\t\t\tstatus = 0;\n\tu16\t\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu8\t\t\t\tintf = w_index & 0xFF;\n\tu16\t\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\tstruct usb_function\t\t*f = NULL;\n\tstruct usb_function\t\t*iter;\n\tu8\t\t\t\tendp;\n\n\tif (w_length > USB_COMP_EP0_BUFSIZ) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t \n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(USB_COMP_EP0_BUFSIZ);\n\t\t\tw_length = USB_COMP_EP0_BUFSIZ;\n\t\t} else {\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\treq->zero = 0;\n\treq->context = cdev;\n\treq->complete = composite_setup_complete;\n\treq->length = 0;\n\tgadget->ep0->driver_data = cdev;\n\n\t \n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\tgoto unknown;\n\n\tswitch (ctrl->bRequest) {\n\n\t \n\tcase USB_REQ_GET_DESCRIPTOR:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tswitch (w_value >> 8) {\n\n\t\tcase USB_DT_DEVICE:\n\t\t\tcdev->desc.bNumConfigurations =\n\t\t\t\tcount_configs(cdev, USB_DT_DEVICE);\n\t\t\tcdev->desc.bMaxPacketSize0 =\n\t\t\t\tcdev->gadget->ep0->maxpacket;\n\t\t\tif (gadget_is_superspeed(gadget)) {\n\t\t\t\tif (gadget->speed >= USB_SPEED_SUPER) {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0320);\n\t\t\t\t\tcdev->desc.bMaxPacketSize0 = 9;\n\t\t\t\t} else {\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0210);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (gadget->lpm_capable || cdev->use_webusb)\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0201);\n\t\t\t\telse\n\t\t\t\t\tcdev->desc.bcdUSB = cpu_to_le16(0x0200);\n\t\t\t}\n\n\t\t\tvalue = min(w_length, (u16) sizeof cdev->desc);\n\t\t\tmemcpy(req->buf, &cdev->desc, value);\n\t\t\tbreak;\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tdevice_qual(cdev);\n\t\t\tvalue = min_t(int, w_length,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\t\tbreak;\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\tif (!gadget_is_dualspeed(gadget) ||\n\t\t\t    gadget->speed >= USB_SPEED_SUPER)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase USB_DT_CONFIG:\n\t\t\tvalue = config_desc(cdev, w_value);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_STRING:\n\t\t\tvalue = get_string(cdev, req->buf,\n\t\t\t\t\tw_index, w_value & 0xff);\n\t\t\tif (value >= 0)\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\tbreak;\n\t\tcase USB_DT_BOS:\n\t\t\tif (gadget_is_superspeed(gadget) ||\n\t\t\t    gadget->lpm_capable || cdev->use_webusb) {\n\t\t\t\tvalue = bos_desc(cdev);\n\t\t\t\tvalue = min(w_length, (u16) value);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_DT_OTG:\n\t\t\tif (gadget_is_otg(gadget)) {\n\t\t\t\tstruct usb_configuration *config;\n\t\t\t\tint otg_desc_len = 0;\n\n\t\t\t\tif (cdev->config)\n\t\t\t\t\tconfig = cdev->config;\n\t\t\t\telse\n\t\t\t\t\tconfig = list_first_entry(\n\t\t\t\t\t\t\t&cdev->configs,\n\t\t\t\t\t\tstruct usb_configuration, list);\n\t\t\t\tif (!config)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tif (gadget->otg_caps &&\n\t\t\t\t\t(gadget->otg_caps->otg_rev >= 0x0200))\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg20_descriptor);\n\t\t\t\telse\n\t\t\t\t\totg_desc_len += sizeof(\n\t\t\t\t\t\tstruct usb_otg_descriptor);\n\n\t\t\t\tvalue = min_t(int, w_length, otg_desc_len);\n\t\t\t\tmemcpy(req->buf, config->descriptors[0], value);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != 0)\n\t\t\tgoto unknown;\n\t\tif (gadget_is_otg(gadget)) {\n\t\t\tif (gadget->a_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP available\\n\");\n\t\t\telse if (gadget->a_alt_hnp_support)\n\t\t\t\tDBG(cdev, \"HNP on another port\\n\");\n\t\t\telse\n\t\t\t\tVDBG(cdev, \"HNP inactive\\n\");\n\t\t}\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = set_config(cdev, ctrl, w_value);\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_CONFIGURATION:\n\t\tif (ctrl->bRequestType != USB_DIR_IN)\n\t\t\tgoto unknown;\n\t\tif (cdev->config)\n\t\t\t*(u8 *)req->buf = cdev->config->bConfigurationValue;\n\t\telse\n\t\t\t*(u8 *)req->buf = 0;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\n\t \n\tcase USB_REQ_SET_INTERFACE:\n\t\tif (ctrl->bRequestType != USB_RECIP_INTERFACE)\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\t \n\t\tif (w_value && !f->get_alt)\n\t\t\tbreak;\n\n\t\tspin_lock(&cdev->lock);\n\t\tvalue = f->set_alt(f, w_index, w_value);\n\t\tif (value == USB_GADGET_DELAYED_STATUS) {\n\t\t\tDBG(cdev,\n\t\t\t \"%s: interface %d (%s) requested delayed status\\n\",\n\t\t\t\t\t__func__, intf, f->name);\n\t\t\tcdev->delayed_status++;\n\t\t\tDBG(cdev, \"delayed_status count %d\\n\",\n\t\t\t\t\tcdev->delayed_status);\n\t\t}\n\t\tspin_unlock(&cdev->lock);\n\t\tbreak;\n\tcase USB_REQ_GET_INTERFACE:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\t\t \n\t\tvalue = f->get_alt ? f->get_alt(f, w_index) : 0;\n\t\tif (value < 0)\n\t\t\tbreak;\n\t\t*((u8 *)req->buf) = value;\n\t\tvalue = min(w_length, (u16) 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (gadget_is_otg(gadget) && gadget->hnp_polling_support &&\n\t\t\t\t\t\t(w_index == OTG_STS_SELECTOR)) {\n\t\t\tif (ctrl->bRequestType != (USB_DIR_IN |\n\t\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\t\tgoto unknown;\n\t\t\t*((u8 *)req->buf) = gadget->host_request_flag;\n\t\t\tvalue = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tvalue = 2;\t \n\t\tput_unaligned_le16(0, req->buf);\n\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\tbreak;\n\t\tf = cdev->config->interface[intf];\n\t\tif (!f)\n\t\t\tbreak;\n\n\t\tif (f->get_status) {\n\t\t\tstatus = f->get_status(f);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tif (f->config->bmAttributes & USB_CONFIG_ATT_WAKEUP) {\n\t\t\t\tstatus |= USB_INTRF_STAT_FUNC_RW_CAP;\n\t\t\t\tif (f->func_wakeup_armed)\n\t\t\t\t\tstatus |= USB_INTRF_STAT_FUNC_RW;\n\t\t\t}\n\t\t}\n\n\t\tput_unaligned_le16(status & 0x0000ffff, req->buf);\n\t\tbreak;\n\t \n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (!gadget_is_superspeed(gadget))\n\t\t\tgoto unknown;\n\t\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_INTERFACE))\n\t\t\tgoto unknown;\n\t\tswitch (w_value) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tif (!f)\n\t\t\t\tbreak;\n\t\t\tvalue = 0;\n\t\t\tif (f->func_suspend) {\n\t\t\t\tvalue = f->func_suspend(f, w_index >> 8);\n\t\t\t \n\t\t\t} else if (ctrl->bRequest == USB_REQ_SET_FEATURE) {\n\t\t\t\tif (!(f->config->bmAttributes &\n\t\t\t\t      USB_CONFIG_ATT_WAKEUP) &&\n\t\t\t\t     (w_index & USB_INTRF_FUNC_SUSPEND_RW))\n\t\t\t\t\tbreak;\n\n\t\t\t\tf->func_wakeup_armed = !!(w_index &\n\t\t\t\t\t\t\t  USB_INTRF_FUNC_SUSPEND_RW);\n\n\t\t\t\tif (w_index & USB_INTRF_FUNC_SUSPEND_LP) {\n\t\t\t\t\tif (f->suspend && !f->func_suspended) {\n\t\t\t\t\t\tf->suspend(f);\n\t\t\t\t\t\tf->func_suspended = true;\n\t\t\t\t\t}\n\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tif (f->resume && f->func_suspended) {\n\t\t\t\t\t\tf->resume(f);\n\t\t\t\t\t\tf->func_suspended = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t \n\t\t\t} else if (ctrl->bRequest == USB_REQ_CLEAR_FEATURE) {\n\t\t\t\tf->func_wakeup_armed = false;\n\n\t\t\t\tif (f->resume && f->func_suspended) {\n\t\t\t\t\tf->resume(f);\n\t\t\t\t\tf->func_suspended = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value < 0) {\n\t\t\t\tERROR(cdev,\n\t\t\t\t      \"func_suspend() returned error %d\\n\",\n\t\t\t\t      value);\n\t\t\t\tvalue = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\nunknown:\n\t\t \n\t\tif (cdev->use_os_string && cdev->os_desc_config &&\n\t\t    (ctrl->bRequestType & USB_TYPE_VENDOR) &&\n\t\t    ctrl->bRequest == cdev->b_vendor_code) {\n\t\t\tstruct usb_configuration\t*os_desc_cfg;\n\t\t\tu8\t\t\t\t*buf;\n\t\t\tint\t\t\t\tinterface;\n\t\t\tint\t\t\t\tcount = 0;\n\n\t\t\treq = cdev->os_desc_req;\n\t\t\treq->context = cdev;\n\t\t\treq->complete = composite_setup_complete;\n\t\t\tbuf = req->buf;\n\t\t\tos_desc_cfg = cdev->os_desc_config;\n\t\t\tw_length = min_t(u16, w_length, USB_COMP_EP0_OS_DESC_BUFSIZ);\n\t\t\tmemset(buf, 0, w_length);\n\t\t\tbuf[5] = 0x01;\n\t\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (w_index != 0x4 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\t \n\t\t\t\tcount = count_ext_compat(os_desc_cfg);\n\t\t\t\tbuf[8] = count;\n\t\t\t\tcount *= 24;  \n\t\t\t\tcount += 16;  \n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x10) {\n\t\t\t\t\tvalue = fill_ext_compat(os_desc_cfg, buf);\n\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (w_index != 0x5 || (w_value >> 8))\n\t\t\t\t\tbreak;\n\t\t\t\tinterface = w_value & 0xFF;\n\t\t\t\tif (interface >= MAX_CONFIG_INTERFACES ||\n\t\t\t\t    !os_desc_cfg->interface[interface])\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[6] = w_index;\n\t\t\t\tcount = count_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le16(count, buf + 8);\n\t\t\t\tcount = len_ext_prop(os_desc_cfg,\n\t\t\t\t\tinterface);\n\t\t\t\tput_unaligned_le32(count, buf);\n\t\t\t\tvalue = w_length;\n\t\t\t\tif (w_length > 0x0A) {\n\t\t\t\t\tvalue = fill_ext_prop(os_desc_cfg,\n\t\t\t\t\t\t\t      interface, buf);\n\t\t\t\t\tif (value >= 0)\n\t\t\t\t\t\tvalue = min_t(u16, w_length, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\t \n\t\tif (cdev->use_webusb &&\n\t\t    ctrl->bRequestType == (USB_DIR_IN | USB_TYPE_VENDOR) &&\n\t\t    w_index == WEBUSB_GET_URL &&\n\t\t    w_value == WEBUSB_LANDING_PAGE_PRESENT &&\n\t\t    ctrl->bRequest == cdev->b_webusb_vendor_code) {\n\t\t\tunsigned int\tlanding_page_length;\n\t\t\tunsigned int\tlanding_page_offset;\n\t\t\tstruct webusb_url_descriptor *url_descriptor =\n\t\t\t\t\t(struct webusb_url_descriptor *)cdev->req->buf;\n\n\t\t\turl_descriptor->bDescriptorType = WEBUSB_URL_DESCRIPTOR_TYPE;\n\n\t\t\tif (strncasecmp(cdev->landing_page, \"https://\",  8) == 0) {\n\t\t\t\tlanding_page_offset = 8;\n\t\t\t\turl_descriptor->bScheme = WEBUSB_URL_SCHEME_HTTPS;\n\t\t\t} else if (strncasecmp(cdev->landing_page, \"http://\", 7) == 0) {\n\t\t\t\tlanding_page_offset = 7;\n\t\t\t\turl_descriptor->bScheme = WEBUSB_URL_SCHEME_HTTP;\n\t\t\t} else {\n\t\t\t\tlanding_page_offset = 0;\n\t\t\t\turl_descriptor->bScheme = WEBUSB_URL_SCHEME_NONE;\n\t\t\t}\n\n\t\t\tlanding_page_length = strnlen(cdev->landing_page,\n\t\t\t\tsizeof(url_descriptor->URL)\n\t\t\t\t- WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH + landing_page_offset);\n\n\t\t\tif (w_length < WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH + landing_page_length)\n\t\t\t\tlanding_page_length = w_length\n\t\t\t\t- WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH + landing_page_offset;\n\n\t\t\tmemcpy(url_descriptor->URL,\n\t\t\t\tcdev->landing_page + landing_page_offset,\n\t\t\t\tlanding_page_length - landing_page_offset);\n\t\t\turl_descriptor->bLength = landing_page_length\n\t\t\t\t- landing_page_offset + WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH;\n\n\t\t\tvalue = url_descriptor->bLength;\n\n\t\t\tgoto check_value;\n\t\t}\n\n\t\tVDBG(cdev,\n\t\t\t\"non-core control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t\t \n\t\tif (cdev->config) {\n\t\t\tlist_for_each_entry(f, &cdev->config->functions, list)\n\t\t\t\tif (f->req_match &&\n\t\t\t\t    f->req_match(f, ctrl, false))\n\t\t\t\t\tgoto try_fun_setup;\n\t\t} else {\n\t\t\tstruct usb_configuration *c;\n\t\t\tlist_for_each_entry(c, &cdev->configs, list)\n\t\t\t\tlist_for_each_entry(f, &c->functions, list)\n\t\t\t\t\tif (f->req_match &&\n\t\t\t\t\t    f->req_match(f, ctrl, true))\n\t\t\t\t\t\tgoto try_fun_setup;\n\t\t}\n\t\tf = NULL;\n\n\t\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tif (!cdev->config || intf >= MAX_CONFIG_INTERFACES)\n\t\t\t\tbreak;\n\t\t\tf = cdev->config->interface[intf];\n\t\t\tbreak;\n\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tif (!cdev->config)\n\t\t\t\tbreak;\n\t\t\tendp = ((w_index & 0x80) >> 3) | (w_index & 0x0f);\n\t\t\tlist_for_each_entry(iter, &cdev->config->functions, list) {\n\t\t\t\tif (test_bit(endp, iter->endpoints)) {\n\t\t\t\t\tf = iter;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\ntry_fun_setup:\n\t\tif (f && f->setup)\n\t\t\tvalue = f->setup(f, ctrl);\n\t\telse {\n\t\t\tstruct usb_configuration\t*c;\n\n\t\t\tc = cdev->config;\n\t\t\tif (!c)\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tif (c->setup) {\n\t\t\t\tvalue = c->setup(c, ctrl);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!list_is_singular(&c->functions))\n\t\t\t\tgoto done;\n\t\t\tf = list_first_entry(&c->functions, struct usb_function,\n\t\t\t\t\t     list);\n\t\t\tif (f->setup)\n\t\t\t\tvalue = f->setup(f, ctrl);\n\t\t}\n\n\t\tgoto done;\n\t}\n\ncheck_value:\n\t \n\tif (value >= 0 && value != USB_GADGET_DELAYED_STATUS) {\n\t\treq->length = value;\n\t\treq->context = cdev;\n\t\treq->zero = value < w_length;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(gadget->ep0, req);\n\t\t}\n\t} else if (value == USB_GADGET_DELAYED_STATUS && w_length != 0) {\n\t\tWARN(cdev,\n\t\t\t\"%s: Delayed status not supported for w_length != 0\",\n\t\t\t__func__);\n\t}\n\ndone:\n\t \n\treturn value;\n}\n\nstatic void __composite_disconnect(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tunsigned long\t\t\tflags;\n\n\t \n\tspin_lock_irqsave(&cdev->lock, flags);\n\tcdev->suspended = 0;\n\tif (cdev->config)\n\t\treset_config(cdev);\n\tif (cdev->driver->disconnect)\n\t\tcdev->driver->disconnect(cdev);\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\n\nvoid composite_disconnect(struct usb_gadget *gadget)\n{\n\tusb_gadget_vbus_draw(gadget, 0);\n\t__composite_disconnect(gadget);\n}\n\nvoid composite_reset(struct usb_gadget *gadget)\n{\n\t \n\tusb_gadget_vbus_draw(gadget, 100);\n\t__composite_disconnect(gadget);\n}\n\n \n\nstatic ssize_t suspended_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_composite_dev *cdev = get_gadget_data(gadget);\n\n\treturn sprintf(buf, \"%d\\n\", cdev->suspended);\n}\nstatic DEVICE_ATTR_RO(suspended);\n\nstatic void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\t \n\tWARN_ON(cdev->config);\n\n\twhile (!list_empty(&cdev->configs)) {\n\t\tstruct usb_configuration\t*c;\n\t\tc = list_first_entry(&cdev->configs,\n\t\t\t\tstruct usb_configuration, list);\n\t\tremove_config(cdev, c);\n\t}\n\tif (cdev->driver->unbind && unbind_driver)\n\t\tcdev->driver->unbind(cdev);\n\n\tcomposite_dev_cleanup(cdev);\n\n\tif (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev->def_manufacturer)\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = \"\";\n\n\tkfree(cdev->def_manufacturer);\n\tkfree(cdev);\n\tset_gadget_data(gadget, NULL);\n}\n\nstatic void composite_unbind(struct usb_gadget *gadget)\n{\n\t__composite_unbind(gadget, true);\n}\n\nstatic void update_unchanged_dev_desc(struct usb_device_descriptor *new,\n\t\tconst struct usb_device_descriptor *old)\n{\n\t__le16 idVendor;\n\t__le16 idProduct;\n\t__le16 bcdDevice;\n\tu8 iSerialNumber;\n\tu8 iManufacturer;\n\tu8 iProduct;\n\n\t \n\tidVendor = new->idVendor;\n\tidProduct = new->idProduct;\n\tbcdDevice = new->bcdDevice;\n\tiSerialNumber = new->iSerialNumber;\n\tiManufacturer = new->iManufacturer;\n\tiProduct = new->iProduct;\n\n\t*new = *old;\n\tif (idVendor)\n\t\tnew->idVendor = idVendor;\n\tif (idProduct)\n\t\tnew->idProduct = idProduct;\n\tif (bcdDevice)\n\t\tnew->bcdDevice = bcdDevice;\n\telse\n\t\tnew->bcdDevice = cpu_to_le16(get_default_bcdDevice());\n\tif (iSerialNumber)\n\t\tnew->iSerialNumber = iSerialNumber;\n\tif (iManufacturer)\n\t\tnew->iManufacturer = iManufacturer;\n\tif (iProduct)\n\t\tnew->iProduct = iProduct;\n}\n\nint composite_dev_prepare(struct usb_composite_driver *composite,\n\t\tstruct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tint ret = -ENOMEM;\n\n\t \n\tcdev->req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\n\tif (!cdev->req)\n\t\treturn -ENOMEM;\n\n\tcdev->req->buf = kzalloc(USB_COMP_EP0_BUFSIZ, GFP_KERNEL);\n\tif (!cdev->req->buf)\n\t\tgoto fail;\n\n\tret = device_create_file(&gadget->dev, &dev_attr_suspended);\n\tif (ret)\n\t\tgoto fail_dev;\n\n\tcdev->req->complete = composite_setup_complete;\n\tcdev->req->context = cdev;\n\tgadget->ep0->driver_data = cdev;\n\n\tcdev->driver = composite;\n\n\t \n\tif (CONFIG_USB_GADGET_VBUS_DRAW <= USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\tusb_gadget_set_selfpowered(gadget);\n\n\t \n\tusb_ep_autoconfig_reset(gadget);\n\treturn 0;\nfail_dev:\n\tkfree(cdev->req->buf);\nfail:\n\tusb_ep_free_request(gadget->ep0, cdev->req);\n\tcdev->req = NULL;\n\treturn ret;\n}\n\nint composite_os_desc_req_prepare(struct usb_composite_dev *cdev,\n\t\t\t\t  struct usb_ep *ep0)\n{\n\tint ret = 0;\n\n\tcdev->os_desc_req = usb_ep_alloc_request(ep0, GFP_KERNEL);\n\tif (!cdev->os_desc_req) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tcdev->os_desc_req->buf = kmalloc(USB_COMP_EP0_OS_DESC_BUFSIZ,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!cdev->os_desc_req->buf) {\n\t\tret = -ENOMEM;\n\t\tusb_ep_free_request(ep0, cdev->os_desc_req);\n\t\tgoto end;\n\t}\n\tcdev->os_desc_req->context = cdev;\n\tcdev->os_desc_req->complete = composite_setup_complete;\nend:\n\treturn ret;\n}\n\nvoid composite_dev_cleanup(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_string_container *uc, *tmp;\n\tstruct usb_ep\t\t\t   *ep, *tmp_ep;\n\n\tlist_for_each_entry_safe(uc, tmp, &cdev->gstrings, list) {\n\t\tlist_del(&uc->list);\n\t\tkfree(uc);\n\t}\n\tif (cdev->os_desc_req) {\n\t\tif (cdev->os_desc_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->os_desc_req);\n\n\t\tkfree(cdev->os_desc_req->buf);\n\t\tcdev->os_desc_req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->os_desc_req);\n\t\tcdev->os_desc_req = NULL;\n\t}\n\tif (cdev->req) {\n\t\tif (cdev->setup_pending)\n\t\t\tusb_ep_dequeue(cdev->gadget->ep0, cdev->req);\n\n\t\tkfree(cdev->req->buf);\n\t\tcdev->req->buf = NULL;\n\t\tusb_ep_free_request(cdev->gadget->ep0, cdev->req);\n\t\tcdev->req = NULL;\n\t}\n\tcdev->next_string_id = 0;\n\tdevice_remove_file(&cdev->gadget->dev, &dev_attr_suspended);\n\n\t \n\tlist_for_each_entry_safe(ep, tmp_ep,\n\t\t\t\t &cdev->gadget->ep_list, ep_list) {\n\t\tif (ep->ops->dispose)\n\t\t\tep->ops->dispose(ep);\n\t}\n}\n\nstatic int composite_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *gdriver)\n{\n\tstruct usb_composite_dev\t*cdev;\n\tstruct usb_composite_driver\t*composite = to_cdriver(gdriver);\n\tint\t\t\t\tstatus = -ENOMEM;\n\n\tcdev = kzalloc(sizeof *cdev, GFP_KERNEL);\n\tif (!cdev)\n\t\treturn status;\n\n\tspin_lock_init(&cdev->lock);\n\tcdev->gadget = gadget;\n\tset_gadget_data(gadget, cdev);\n\tINIT_LIST_HEAD(&cdev->configs);\n\tINIT_LIST_HEAD(&cdev->gstrings);\n\n\tstatus = composite_dev_prepare(composite, cdev);\n\tif (status)\n\t\tgoto fail;\n\n\t \n\tstatus = composite->bind(cdev);\n\tif (status < 0)\n\t\tgoto fail;\n\n\tif (cdev->use_os_string) {\n\t\tstatus = composite_os_desc_req_prepare(cdev, gadget->ep0);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tupdate_unchanged_dev_desc(&cdev->desc, composite->dev);\n\n\t \n\tif (composite->needs_serial && !cdev->desc.iSerialNumber)\n\t\tWARNING(cdev, \"userspace failed to provide iSerialNumber\\n\");\n\n\tINFO(cdev, \"%s ready\\n\", composite->name);\n\treturn 0;\n\nfail:\n\t__composite_unbind(gadget, false);\n\treturn status;\n}\n\n \n\nvoid composite_suspend(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\n\t \n\tDBG(cdev, \"suspend\\n\");\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\tif (f->suspend)\n\t\t\t\tf->suspend(f);\n\t\t}\n\t}\n\tif (cdev->driver->suspend)\n\t\tcdev->driver->suspend(cdev);\n\n\tcdev->suspended = 1;\n\n\tusb_gadget_set_selfpowered(gadget);\n\tusb_gadget_vbus_draw(gadget, 2);\n}\n\nvoid composite_resume(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev = get_gadget_data(gadget);\n\tstruct usb_function\t\t*f;\n\tunsigned\t\t\tmaxpower;\n\n\t \n\tDBG(cdev, \"resume\\n\");\n\tif (cdev->driver->resume)\n\t\tcdev->driver->resume(cdev);\n\tif (cdev->config) {\n\t\tlist_for_each_entry(f, &cdev->config->functions, list) {\n\t\t\t \n\t\t\tif (f->resume && !f->func_suspended)\n\t\t\t\tf->resume(f);\n\t\t}\n\n\t\tmaxpower = cdev->config->MaxPower ?\n\t\t\tcdev->config->MaxPower : CONFIG_USB_GADGET_VBUS_DRAW;\n\t\tif (gadget->speed < USB_SPEED_SUPER)\n\t\t\tmaxpower = min(maxpower, 500U);\n\t\telse\n\t\t\tmaxpower = min(maxpower, 900U);\n\n\t\tif (maxpower > USB_SELF_POWER_VBUS_MAX_DRAW)\n\t\t\tusb_gadget_clear_selfpowered(gadget);\n\n\t\tusb_gadget_vbus_draw(gadget, maxpower);\n\t} else {\n\t\tmaxpower = CONFIG_USB_GADGET_VBUS_DRAW;\n\t\tmaxpower = min(maxpower, 100U);\n\t\tusb_gadget_vbus_draw(gadget, maxpower);\n\t}\n\n\tcdev->suspended = 0;\n}\n\n \n\nstatic const struct usb_gadget_driver composite_driver_template = {\n\t.bind\t\t= composite_bind,\n\t.unbind\t\t= composite_unbind,\n\n\t.setup\t\t= composite_setup,\n\t.reset\t\t= composite_reset,\n\t.disconnect\t= composite_disconnect,\n\n\t.suspend\t= composite_suspend,\n\t.resume\t\t= composite_resume,\n\n\t.driver\t= {\n\t\t.owner\t\t= THIS_MODULE,\n\t},\n};\n\n \nint usb_composite_probe(struct usb_composite_driver *driver)\n{\n\tstruct usb_gadget_driver *gadget_driver;\n\n\tif (!driver || !driver->dev || !driver->bind)\n\t\treturn -EINVAL;\n\n\tif (!driver->name)\n\t\tdriver->name = \"composite\";\n\n\tdriver->gadget_driver = composite_driver_template;\n\tgadget_driver = &driver->gadget_driver;\n\n\tgadget_driver->function =  (char *) driver->name;\n\tgadget_driver->driver.name = driver->name;\n\tgadget_driver->max_speed = driver->max_speed;\n\n\treturn usb_gadget_register_driver(gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_probe);\n\n \nvoid usb_composite_unregister(struct usb_composite_driver *driver)\n{\n\tusb_gadget_unregister_driver(&driver->gadget_driver);\n}\nEXPORT_SYMBOL_GPL(usb_composite_unregister);\n\n \nvoid usb_composite_setup_continue(struct usb_composite_dev *cdev)\n{\n\tint\t\t\tvalue;\n\tstruct usb_request\t*req = cdev->req;\n\tunsigned long\t\tflags;\n\n\tDBG(cdev, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&cdev->lock, flags);\n\n\tif (cdev->delayed_status == 0) {\n\t\tWARN(cdev, \"%s: Unexpected call\\n\", __func__);\n\n\t} else if (--cdev->delayed_status == 0) {\n\t\tDBG(cdev, \"%s: Completing delayed status\\n\", __func__);\n\t\treq->length = 0;\n\t\treq->context = cdev;\n\t\tvalue = composite_ep0_queue(cdev, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tDBG(cdev, \"ep_queue --> %d\\n\", value);\n\t\t\treq->status = 0;\n\t\t\tcomposite_setup_complete(cdev->gadget->ep0, req);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&cdev->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_composite_setup_continue);\n\nstatic char *composite_default_mfr(struct usb_gadget *gadget)\n{\n\treturn kasprintf(GFP_KERNEL, \"%s %s with %s\", init_utsname()->sysname,\n\t\t\t init_utsname()->release, gadget->name);\n}\n\nvoid usb_composite_overwrite_options(struct usb_composite_dev *cdev,\n\t\tstruct usb_composite_overwrite *covr)\n{\n\tstruct usb_device_descriptor\t*desc = &cdev->desc;\n\tstruct usb_gadget_strings\t*gstr = cdev->driver->strings[0];\n\tstruct usb_string\t\t*dev_str = gstr->strings;\n\n\tif (covr->idVendor)\n\t\tdesc->idVendor = cpu_to_le16(covr->idVendor);\n\n\tif (covr->idProduct)\n\t\tdesc->idProduct = cpu_to_le16(covr->idProduct);\n\n\tif (covr->bcdDevice)\n\t\tdesc->bcdDevice = cpu_to_le16(covr->bcdDevice);\n\n\tif (covr->serial_number) {\n\t\tdesc->iSerialNumber = dev_str[USB_GADGET_SERIAL_IDX].id;\n\t\tdev_str[USB_GADGET_SERIAL_IDX].s = covr->serial_number;\n\t}\n\tif (covr->manufacturer) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = covr->manufacturer;\n\n\t} else if (!strlen(dev_str[USB_GADGET_MANUFACTURER_IDX].s)) {\n\t\tdesc->iManufacturer = dev_str[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tcdev->def_manufacturer = composite_default_mfr(cdev->gadget);\n\t\tdev_str[USB_GADGET_MANUFACTURER_IDX].s = cdev->def_manufacturer;\n\t}\n\n\tif (covr->product) {\n\t\tdesc->iProduct = dev_str[USB_GADGET_PRODUCT_IDX].id;\n\t\tdev_str[USB_GADGET_PRODUCT_IDX].s = covr->product;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_composite_overwrite_options);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}