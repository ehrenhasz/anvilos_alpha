{
  "module_name": "Kconfig",
  "hash_id": "253f6002278a664589c9c1244bc8381b395b8318fa6bce2368d5ed0b64f5a1f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/Kconfig",
  "human_readable_source": "# SPDX-License-Identifier: GPL-2.0\n#\n# USB Gadget support on a system involves\n#    (a) a peripheral controller, and\n#    (b) the gadget driver using it.\n#\n# NOTE:  Gadget support ** DOES NOT ** depend on host-side CONFIG_USB !!\n#\n#  - Host systems (like PCs) need CONFIG_USB (with \"A\" jacks).\n#  - Peripherals (like PDAs) need CONFIG_USB_GADGET (with \"B\" jacks).\n#  - Some systems have both kinds of controllers.\n#\n# With help from a special transceiver and a \"Mini-AB\" jack, systems with\n# both kinds of controller can also support \"USB On-the-Go\" (CONFIG_USB_OTG).\n#\n\nmenuconfig USB_GADGET\n\ttristate \"USB Gadget Support\"\n\tselect USB_COMMON\n\tselect NLS\n\thelp\n\t   USB is a host/device protocol, organized with one host (such as a\n\t   PC) controlling up to 127 peripheral devices.\n\t   The USB hardware is asymmetric, which makes it easier to set up:\n\t   you can't connect a \"to-the-host\" connector to a peripheral.\n\n\t   Linux can run in the host, or in the peripheral.  In both cases\n\t   you need a low level bus controller driver, and some software\n\t   talking to it.  Peripheral controllers are often discrete silicon,\n\t   or are integrated with the CPU in a microcontroller.  The more\n\t   familiar host side controllers have names like \"EHCI\", \"OHCI\",\n\t   or \"UHCI\", and are usually integrated into southbridges on PC\n\t   motherboards.\n\n\t   Enable this configuration option if you want to run Linux inside\n\t   a USB peripheral device.  Configure one hardware driver for your\n\t   peripheral/device side bus controller, and a \"gadget driver\" for\n\t   your peripheral protocol.  (If you use modular gadget drivers,\n\t   you may configure more than one.)\n\n\t   If in doubt, say \"N\" and don't enable these drivers; most people\n\t   don't have this kind of hardware (except maybe inside Linux PDAs).\n\n\t   For more information, see <http://www.linux-usb.org/gadget> and\n\t   the kernel documentation for this API.\n\nif USB_GADGET\n\nconfig USB_GADGET_DEBUG\n\tbool \"Debugging messages (DEVELOPMENT)\"\n\tdepends on DEBUG_KERNEL\n\thelp\n\t   Many controller and gadget drivers will print some debugging\n\t   messages if you use this option to ask for those messages.\n\n\t   Avoid enabling these messages, even if you're actively\n\t   debugging such a driver.  Many drivers will emit so many\n\t   messages that the driver timings are affected, which will\n\t   either create new failure modes or remove the one you're\n\t   trying to track down.  Never enable these messages for a\n\t   production build.\n\nconfig USB_GADGET_VERBOSE\n\tbool \"Verbose debugging Messages (DEVELOPMENT)\"\n\tdepends on USB_GADGET_DEBUG\n\thelp\n\t   Many controller and gadget drivers will print verbose debugging\n\t   messages if you use this option to ask for those messages.\n\n\t   Avoid enabling these messages, even if you're actively\n\t   debugging such a driver.  Many drivers will emit so many\n\t   messages that the driver timings are affected, which will\n\t   either create new failure modes or remove the one you're\n\t   trying to track down.  Never enable these messages for a\n\t   production build.\n\nconfig USB_GADGET_DEBUG_FILES\n\tbool \"Debugging information files (DEVELOPMENT)\"\n\tdepends on PROC_FS\n\thelp\n\t   Some of the drivers in the \"gadget\" framework can expose\n\t   debugging information in files such as /proc/driver/udc\n\t   (for a peripheral controller).  The information in these\n\t   files may help when you're troubleshooting or bringing up a\n\t   driver on a new board.   Enable these files by choosing \"Y\"\n\t   here.  If in doubt, or to conserve kernel memory, say \"N\".\n\nconfig USB_GADGET_DEBUG_FS\n\tbool \"Debugging information files in debugfs (DEVELOPMENT)\"\n\tdepends on DEBUG_FS\n\thelp\n\t   Some of the drivers in the \"gadget\" framework can expose\n\t   debugging information in files under /sys/kernel/debug/.\n\t   The information in these files may help when you're\n\t   troubleshooting or bringing up a driver on a new board.\n\t   Enable these files by choosing \"Y\" here.  If in doubt, or\n\t   to conserve kernel memory, say \"N\".\n\nconfig USB_GADGET_VBUS_DRAW\n\tint \"Maximum VBUS Power usage (2-500 mA)\"\n\trange 2 500\n\tdefault 2\n\thelp\n\t   Some devices need to draw power from USB when they are\n\t   configured, perhaps to operate circuitry or to recharge\n\t   batteries.  This is in addition to any local power supply,\n\t   such as an AC adapter or batteries.\n\n\t   Enter the maximum power your device draws through USB, in\n\t   milliAmperes.  The permitted range of values is 2 - 500 mA;\n\t   0 mA would be legal, but can make some hosts misbehave.\n\n\t   This value will be used except for system-specific gadget\n\t   drivers that have more specific information.\n\nconfig USB_GADGET_STORAGE_NUM_BUFFERS\n\tint \"Number of storage pipeline buffers\"\n\trange 2 256\n\tdefault 2\n\thelp\n\t   Usually 2 buffers are enough to establish a good buffering\n\t   pipeline. The number may be increased in order to compensate\n\t   for a bursty VFS behaviour. For instance there may be CPU wake up\n\t   latencies that makes the VFS to appear bursty in a system with\n\t   an CPU on-demand governor. Especially if DMA is doing IO to\n\t   offload the CPU. In this case the CPU will go into power\n\t   save often and spin up occasionally to move data within VFS.\n\t   If selecting USB_GADGET_DEBUG_FILES this value may be set by\n\t   a module parameter as well.\n\t   If unsure, say 2.\n\nconfig U_SERIAL_CONSOLE\n\tbool \"Serial gadget console support\"\n\tdepends on USB_U_SERIAL\n\thelp\n\t   It supports the serial gadget can be used as a console.\n\nsource \"drivers/usb/gadget/udc/Kconfig\"\n\n#\n# USB Gadget Drivers\n#\n\n# composite based drivers\nconfig USB_LIBCOMPOSITE\n\ttristate\n\tselect CONFIGFS_FS\n\tdepends on USB_GADGET\n\nconfig USB_F_ACM\n\ttristate\n\nconfig USB_F_SS_LB\n\ttristate\n\nconfig USB_U_SERIAL\n\ttristate\n\nconfig USB_U_ETHER\n\ttristate\n\nconfig USB_U_AUDIO\n\ttristate\n\nconfig USB_F_SERIAL\n\ttristate\n\nconfig USB_F_OBEX\n\ttristate\n\nconfig USB_F_NCM\n\ttristate\n\nconfig USB_F_ECM\n\ttristate\n\nconfig USB_F_PHONET\n\ttristate\n\nconfig USB_F_EEM\n\ttristate\n\nconfig USB_F_SUBSET\n\ttristate\n\nconfig USB_F_RNDIS\n\ttristate\n\nconfig USB_F_MASS_STORAGE\n\ttristate\n\nconfig USB_F_FS\n\ttristate\n\nconfig USB_F_UAC1\n\ttristate\n\nconfig USB_F_UAC1_LEGACY\n\ttristate\n\nconfig USB_F_UAC2\n\ttristate\n\nconfig USB_F_UVC\n\ttristate\n\tselect UVC_COMMON\n\nconfig USB_F_MIDI\n\ttristate\n\nconfig USB_F_MIDI2\n\ttristate\n\nconfig USB_F_HID\n\ttristate\n\nconfig USB_F_PRINTER\n\ttristate\n\nconfig USB_F_TCM\n\ttristate\n\n# this first set of drivers all depend on bulk-capable hardware.\n\nconfig USB_CONFIGFS\n\ttristate \"USB Gadget functions configurable through configfs\"\n\tselect USB_LIBCOMPOSITE\n\thelp\n\t  A Linux USB \"gadget\" can be set up through configfs.\n\t  If this is the case, the USB functions (which from the host's\n\t  perspective are seen as interfaces) and configurations are\n\t  specified simply by creating appropriate directories in configfs.\n\t  Associating functions with configurations is done by creating\n\t  appropriate symbolic links.\n\t  For more information see Documentation/usb/gadget_configfs.rst.\n\nconfig USB_CONFIGFS_SERIAL\n\tbool \"Generic serial bulk in/out\"\n\tdepends on USB_CONFIGFS\n\tdepends on TTY\n\tselect USB_U_SERIAL\n\tselect USB_F_SERIAL\n\thelp\n\t  The function talks to the Linux-USB generic serial driver.\n\nconfig USB_CONFIGFS_ACM\n\tbool \"Abstract Control Model (CDC ACM)\"\n\tdepends on USB_CONFIGFS\n\tdepends on TTY\n\tselect USB_U_SERIAL\n\tselect USB_F_ACM\n\thelp\n\t  ACM serial link.  This function can be used to interoperate with\n\t  MS-Windows hosts or with the Linux-USB \"cdc-acm\" driver.\n\nconfig USB_CONFIGFS_OBEX\n\tbool \"Object Exchange Model (CDC OBEX)\"\n\tdepends on USB_CONFIGFS\n\tdepends on TTY\n\tselect USB_U_SERIAL\n\tselect USB_F_OBEX\n\thelp\n\t  You will need a user space OBEX server talking to /dev/ttyGS*,\n\t  since the kernel itself doesn't implement the OBEX protocol.\n\nconfig USB_CONFIGFS_NCM\n\tbool \"Network Control Model (CDC NCM)\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tselect USB_U_ETHER\n\tselect USB_F_NCM\n\tselect CRC32\n\thelp\n\t  NCM is an advanced protocol for Ethernet encapsulation, allows\n\t  grouping of several ethernet frames into one USB transfer and\n\t  different alignment possibilities.\n\nconfig USB_CONFIGFS_ECM\n\tbool \"Ethernet Control Model (CDC ECM)\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tselect USB_U_ETHER\n\tselect USB_F_ECM\n\thelp\n\t  The \"Communication Device Class\" (CDC) Ethernet Control Model.\n\t  That protocol is often avoided with pure Ethernet adapters, in\n\t  favor of simpler vendor-specific hardware, but is widely\n\t  supported by firmware for smart network devices.\n\nconfig USB_CONFIGFS_ECM_SUBSET\n\tbool \"Ethernet Control Model (CDC ECM) subset\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tselect USB_U_ETHER\n\tselect USB_F_SUBSET\n\thelp\n\t  On hardware that can't implement the full protocol,\n\t  a simple CDC subset is used, placing fewer demands on USB.\n\nconfig USB_CONFIGFS_RNDIS\n\tbool \"RNDIS\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tselect USB_U_ETHER\n\tselect USB_F_RNDIS\n\thelp\n\t   Microsoft Windows XP bundles the \"Remote NDIS\" (RNDIS) protocol,\n\t   and Microsoft provides redistributable binary RNDIS drivers for\n\t   older versions of Windows.\n\n\t   To make MS-Windows work with this, use Documentation/usb/linux.inf\n\t   as the \"driver info file\".  For versions of MS-Windows older than\n\t   XP, you'll need to download drivers from Microsoft's website; a URL\n\t   is given in comments found in that info file.\n\nconfig USB_CONFIGFS_EEM\n\tbool \"Ethernet Emulation Model (EEM)\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tselect USB_U_ETHER\n\tselect USB_F_EEM\n\tselect CRC32\n\thelp\n\t  CDC EEM is a newer USB standard that is somewhat simpler than CDC ECM\n\t  and therefore can be supported by more hardware.  Technically ECM and\n\t  EEM are designed for different applications.  The ECM model extends\n\t  the network interface to the target (e.g. a USB cable modem), and the\n\t  EEM model is for mobile devices to communicate with hosts using\n\t  ethernet over USB.  For Linux gadgets, however, the interface with\n\t  the host is the same (a usbX device), so the differences are minimal.\n\nconfig USB_CONFIGFS_PHONET\n\tbool \"Phonet protocol\"\n\tdepends on USB_CONFIGFS\n\tdepends on NET\n\tdepends on PHONET\n\tselect USB_U_ETHER\n\tselect USB_F_PHONET\n\thelp\n\t  The Phonet protocol implementation for USB device.\n\nconfig USB_CONFIGFS_MASS_STORAGE\n\tbool \"Mass storage\"\n\tdepends on USB_CONFIGFS\n\tdepends on BLOCK\n\tselect USB_F_MASS_STORAGE\n\thelp\n\t  The Mass Storage Gadget acts as a USB Mass Storage disk drive.\n\t  As its storage repository it can use a regular file or a block\n\t  device (in much the same way as the \"loop\" device driver),\n\t  specified as a module parameter or sysfs option.\n\nconfig USB_CONFIGFS_F_LB_SS\n\tbool \"Loopback and sourcesink function (for testing)\"\n\tdepends on USB_CONFIGFS\n\tselect USB_F_SS_LB\n\thelp\n\t  Loopback function loops back a configurable number of transfers.\n\t  Sourcesink function either sinks and sources bulk data.\n\t  It also implements control requests, for \"chapter 9\" conformance.\n\t  Make this be the first driver you try using on top of any new\n\t  USB peripheral controller driver.  Then you can use host-side\n\t  test software, like the \"usbtest\" driver, to put your hardware\n\t  and its driver through a basic set of functional tests.\n\nconfig USB_CONFIGFS_F_FS\n\tbool \"Function filesystem (FunctionFS)\"\n\tdepends on USB_CONFIGFS\n\tselect USB_F_FS\n\thelp\n\t  The Function Filesystem (FunctionFS) lets one create USB\n\t  composite functions in user space in the same way GadgetFS\n\t  lets one create USB gadgets in user space.  This allows creation\n\t  of composite gadgets such that some of the functions are\n\t  implemented in kernel space (for instance Ethernet, serial or\n\t  mass storage) and other are implemented in user space.\n\nconfig USB_CONFIGFS_F_UAC1\n\tbool \"Audio Class 1.0\"\n\tdepends on USB_CONFIGFS\n\tdepends on SND\n\tselect USB_LIBCOMPOSITE\n\tselect SND_PCM\n\tselect USB_U_AUDIO\n\tselect USB_F_UAC1\n\thelp\n\t  This Audio function implements 1 AudioControl interface,\n\t  1 AudioStreaming Interface each for USB-OUT and USB-IN.\n\t  This driver doesn't expect any real Audio codec to be present\n\t  on the device - the audio streams are simply sinked to and\n\t  sourced from a virtual ALSA sound card created. The user-space\n\t  application may choose to do whatever it wants with the data\n\t  received from the USB Host and choose to provide whatever it\n\t  wants as audio data to the USB Host.\n\nconfig USB_CONFIGFS_F_UAC1_LEGACY\n\tbool \"Audio Class 1.0 (legacy implementation)\"\n\tdepends on USB_CONFIGFS\n\tdepends on SND\n\tselect USB_LIBCOMPOSITE\n\tselect SND_PCM\n\tselect USB_F_UAC1_LEGACY\n\thelp\n\t  This Audio function implements 1 AudioControl interface,\n\t  1 AudioStreaming Interface each for USB-OUT and USB-IN.\n\t  This is a legacy driver and requires a real Audio codec\n\t  to be present on the device.\n\nconfig USB_CONFIGFS_F_UAC2\n\tbool \"Audio Class 2.0\"\n\tdepends on USB_CONFIGFS\n\tdepends on SND\n\tselect USB_LIBCOMPOSITE\n\tselect SND_PCM\n\tselect USB_U_AUDIO\n\tselect USB_F_UAC2\n\thelp\n\t  This Audio function is compatible with USB Audio Class\n\t  specification 2.0. It implements 1 AudioControl interface,\n\t  1 AudioStreaming Interface each for USB-OUT and USB-IN.\n\t  This driver doesn't expect any real Audio codec to be present\n\t  on the device - the audio streams are simply sinked to and\n\t  sourced from a virtual ALSA sound card created. The user-space\n\t  application may choose to do whatever it wants with the data\n\t  received from the USB Host and choose to provide whatever it\n\t  wants as audio data to the USB Host.\n\nconfig USB_CONFIGFS_F_MIDI\n\tbool \"MIDI function\"\n\tdepends on USB_CONFIGFS\n\tdepends on SND\n\tselect USB_LIBCOMPOSITE\n\tselect SND_RAWMIDI\n\tselect USB_F_MIDI\n\thelp\n\t  The MIDI Function acts as a USB Audio device, with one MIDI\n\t  input and one MIDI output. These MIDI jacks appear as\n\t  a sound \"card\" in the ALSA sound system. Other MIDI\n\t  connections can then be made on the gadget system, using\n\t  ALSA's aconnect utility etc.\n\nconfig USB_CONFIGFS_F_MIDI2\n\tbool \"MIDI 2.0 function\"\n\tdepends on USB_CONFIGFS\n\tdepends on SND\n\tselect USB_LIBCOMPOSITE\n\tselect SND_UMP\n\tselect SND_UMP_LEGACY_RAWMIDI\n\tselect USB_F_MIDI2\n\thelp\n\t  The MIDI 2.0 function driver provides the generic emulated\n\t  USB MIDI 2.0 interface, looped back to ALSA UMP rawmidi\n\t  device on the gadget host. It supports UMP 1.1 spec and\n\t  responds UMP Stream messages for UMP Endpoint and Function\n\t  Block information / configuration.\n\nconfig USB_CONFIGFS_F_HID\n\tbool \"HID function\"\n\tdepends on USB_CONFIGFS\n\tselect USB_F_HID\n\thelp\n\t  The HID function driver provides generic emulation of USB\n\t  Human Interface Devices (HID).\n\n\t  For more information, see Documentation/usb/gadget_hid.rst.\n\nconfig USB_CONFIGFS_F_UVC\n\tbool \"USB Webcam function\"\n\tdepends on USB_CONFIGFS\n\tdepends on VIDEO_DEV\n\tdepends on VIDEO_DEV\n\tselect VIDEOBUF2_DMA_SG\n\tselect VIDEOBUF2_VMALLOC\n\tselect USB_F_UVC\n\thelp\n\t  The Webcam function acts as a composite USB Audio and Video Class\n\t  device. It provides a userspace API to process UVC control requests\n\t  and stream video data to the host.\n\nconfig USB_CONFIGFS_F_PRINTER\n\tbool \"Printer function\"\n\tselect USB_F_PRINTER\n\tdepends on USB_CONFIGFS\n\thelp\n\t  The Printer function channels data between the USB host and a\n\t  userspace program driving the print engine. The user space\n\t  program reads and writes the device file /dev/g_printer<X> to\n\t  receive or send printer data. It can use ioctl calls to\n\t  the device file to get or set printer status.\n\n\t  For more information, see Documentation/usb/gadget_printer.rst\n\t  which includes sample code for accessing the device file.\n\nconfig USB_CONFIGFS_F_TCM\n\tbool \"USB Gadget Target Fabric\"\n\tdepends on TARGET_CORE\n\tdepends on USB_CONFIGFS\n\tselect USB_LIBCOMPOSITE\n\tselect USB_F_TCM\n\thelp\n\t  This fabric is a USB gadget component. Two USB protocols are\n\t  supported that is BBB or BOT (Bulk Only Transport) and UAS\n\t  (USB Attached SCSI). BOT is advertised on alternative\n\t  interface 0 (primary) and UAS is on alternative interface 1.\n\t  Both protocols can work on USB2.0 and USB3.0.\n\t  UAS utilizes the USB 3.0 feature called streams support.\n\nsource \"drivers/usb/gadget/legacy/Kconfig\"\n\nendif # USB_GADGET\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}