{
  "module_name": "config.c",
  "hash_id": "0220c5d3836a86bfd56b19584396272202ec08938f775a120de6a2d440763fae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/config.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/device.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/otg.h>\n\n \nint\nusb_descriptor_fillbuf(void *buf, unsigned buflen,\n\t\tconst struct usb_descriptor_header **src)\n{\n\tu8\t*dest = buf;\n\n\tif (!src)\n\t\treturn -EINVAL;\n\n\t \n\tfor (; NULL != *src; src++) {\n\t\tunsigned\t\tlen = (*src)->bLength;\n\n\t\tif (len > buflen)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(dest, *src, len);\n\t\tbuflen -= len;\n\t\tdest += len;\n\t}\n\treturn dest - (u8 *)buf;\n}\nEXPORT_SYMBOL_GPL(usb_descriptor_fillbuf);\n\n \nint usb_gadget_config_buf(\n\tconst struct usb_config_descriptor\t*config,\n\tvoid\t\t\t\t\t*buf,\n\tunsigned\t\t\t\tlength,\n\tconst struct usb_descriptor_header\t**desc\n)\n{\n\tstruct usb_config_descriptor\t\t*cp = buf;\n\tint\t\t\t\t\tlen;\n\n\t \n\tif (length < USB_DT_CONFIG_SIZE || !desc)\n\t\treturn -EINVAL;\n\t*cp = *config;\n\n\t \n\tlen = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,\n\t\t\tlength - USB_DT_CONFIG_SIZE, desc);\n\tif (len < 0)\n\t\treturn len;\n\tlen += USB_DT_CONFIG_SIZE;\n\tif (len > 0xffff)\n\t\treturn -EINVAL;\n\n\t \n\tcp->bLength = USB_DT_CONFIG_SIZE;\n\tcp->bDescriptorType = USB_DT_CONFIG;\n\tcp->wTotalLength = cpu_to_le16(len);\n\tcp->bmAttributes |= USB_CONFIG_ATT_ONE;\n\treturn len;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_config_buf);\n\n \nstruct usb_descriptor_header **\nusb_copy_descriptors(struct usb_descriptor_header **src)\n{\n\tstruct usb_descriptor_header **tmp;\n\tunsigned bytes;\n\tunsigned n_desc;\n\tvoid *mem;\n\tstruct usb_descriptor_header **ret;\n\n\t \n\tfor (bytes = 0, n_desc = 0, tmp = src; *tmp; tmp++, n_desc++)\n\t\tbytes += (*tmp)->bLength;\n\tbytes += (n_desc + 1) * sizeof(*tmp);\n\n\tmem = kmalloc(bytes, GFP_KERNEL);\n\tif (!mem)\n\t\treturn NULL;\n\n\t \n\ttmp = mem;\n\tret = mem;\n\tmem += (n_desc + 1) * sizeof(*tmp);\n\twhile (*src) {\n\t\tmemcpy(mem, *src, (*src)->bLength);\n\t\t*tmp = mem;\n\t\ttmp++;\n\t\tmem += (*src)->bLength;\n\t\tsrc++;\n\t}\n\t*tmp = NULL;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_copy_descriptors);\n\nint usb_assign_descriptors(struct usb_function *f,\n\t\tstruct usb_descriptor_header **fs,\n\t\tstruct usb_descriptor_header **hs,\n\t\tstruct usb_descriptor_header **ss,\n\t\tstruct usb_descriptor_header **ssp)\n{\n\t \n\tif (!ssp)\n\t\tssp = ss;\n\n\tif (fs) {\n\t\tf->fs_descriptors = usb_copy_descriptors(fs);\n\t\tif (!f->fs_descriptors)\n\t\t\tgoto err;\n\t}\n\tif (hs) {\n\t\tf->hs_descriptors = usb_copy_descriptors(hs);\n\t\tif (!f->hs_descriptors)\n\t\t\tgoto err;\n\t}\n\tif (ss) {\n\t\tf->ss_descriptors = usb_copy_descriptors(ss);\n\t\tif (!f->ss_descriptors)\n\t\t\tgoto err;\n\t}\n\tif (ssp) {\n\t\tf->ssp_descriptors = usb_copy_descriptors(ssp);\n\t\tif (!f->ssp_descriptors)\n\t\t\tgoto err;\n\t}\n\treturn 0;\nerr:\n\tusb_free_all_descriptors(f);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_assign_descriptors);\n\nvoid usb_free_all_descriptors(struct usb_function *f)\n{\n\tusb_free_descriptors(f->fs_descriptors);\n\tf->fs_descriptors = NULL;\n\tusb_free_descriptors(f->hs_descriptors);\n\tf->hs_descriptors = NULL;\n\tusb_free_descriptors(f->ss_descriptors);\n\tf->ss_descriptors = NULL;\n\tusb_free_descriptors(f->ssp_descriptors);\n\tf->ssp_descriptors = NULL;\n}\nEXPORT_SYMBOL_GPL(usb_free_all_descriptors);\n\nstruct usb_descriptor_header *usb_otg_descriptor_alloc(\n\t\t\t\tstruct usb_gadget *gadget)\n{\n\tstruct usb_descriptor_header *otg_desc;\n\tunsigned length = 0;\n\n\tif (gadget->otg_caps && (gadget->otg_caps->otg_rev >= 0x0200))\n\t\tlength = sizeof(struct usb_otg20_descriptor);\n\telse\n\t\tlength = sizeof(struct usb_otg_descriptor);\n\n\totg_desc = kzalloc(length, GFP_KERNEL);\n\treturn otg_desc;\n}\nEXPORT_SYMBOL_GPL(usb_otg_descriptor_alloc);\n\nint usb_otg_descriptor_init(struct usb_gadget *gadget,\n\t\tstruct usb_descriptor_header *otg_desc)\n{\n\tstruct usb_otg_descriptor *otg1x_desc;\n\tstruct usb_otg20_descriptor *otg20_desc;\n\tstruct usb_otg_caps *otg_caps = gadget->otg_caps;\n\tu8 otg_attributes = 0;\n\n\tif (!otg_desc)\n\t\treturn -EINVAL;\n\n\tif (otg_caps && otg_caps->otg_rev) {\n\t\tif (otg_caps->hnp_support)\n\t\t\totg_attributes |= USB_OTG_HNP;\n\t\tif (otg_caps->srp_support)\n\t\t\totg_attributes |= USB_OTG_SRP;\n\t\tif (otg_caps->adp_support && (otg_caps->otg_rev >= 0x0200))\n\t\t\totg_attributes |= USB_OTG_ADP;\n\t} else {\n\t\totg_attributes = USB_OTG_SRP | USB_OTG_HNP;\n\t}\n\n\tif (otg_caps && (otg_caps->otg_rev >= 0x0200)) {\n\t\totg20_desc = (struct usb_otg20_descriptor *)otg_desc;\n\t\totg20_desc->bLength = sizeof(struct usb_otg20_descriptor);\n\t\totg20_desc->bDescriptorType = USB_DT_OTG;\n\t\totg20_desc->bmAttributes = otg_attributes;\n\t\totg20_desc->bcdOTG = cpu_to_le16(otg_caps->otg_rev);\n\t} else {\n\t\totg1x_desc = (struct usb_otg_descriptor *)otg_desc;\n\t\totg1x_desc->bLength = sizeof(struct usb_otg_descriptor);\n\t\totg1x_desc->bDescriptorType = USB_DT_OTG;\n\t\totg1x_desc->bmAttributes = otg_attributes;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_otg_descriptor_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}