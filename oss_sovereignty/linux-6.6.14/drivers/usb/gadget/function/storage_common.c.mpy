{
  "module_name": "storage_common.c",
  "hash_id": "878b14871c092df49bb6d49868512769bf7e0b05d67c20d8eb1f514dca0b1c92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/storage_common.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kstrtox.h>\n#include <linux/usb/composite.h>\n\n#include \"storage_common.h\"\n\n \n\nstruct usb_interface_descriptor fsg_intf_desc = {\n\t.bLength =\t\tsizeof fsg_intf_desc,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bNumEndpoints =\t2,\t\t \n\t.bInterfaceClass =\tUSB_CLASS_MASS_STORAGE,\n\t.bInterfaceSubClass =\tUSB_SC_SCSI,\t \n\t.bInterfaceProtocol =\tUSB_PR_BULK,\t \n\t.iInterface =\t\tFSG_STRING_INTERFACE,\n};\nEXPORT_SYMBOL_GPL(fsg_intf_desc);\n\n \n\nstruct usb_endpoint_descriptor fsg_fs_bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t \n};\nEXPORT_SYMBOL_GPL(fsg_fs_bulk_in_desc);\n\nstruct usb_endpoint_descriptor fsg_fs_bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t \n};\nEXPORT_SYMBOL_GPL(fsg_fs_bulk_out_desc);\n\nstruct usb_descriptor_header *fsg_fs_function[] = {\n\t(struct usb_descriptor_header *) &fsg_intf_desc,\n\t(struct usb_descriptor_header *) &fsg_fs_bulk_in_desc,\n\t(struct usb_descriptor_header *) &fsg_fs_bulk_out_desc,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(fsg_fs_function);\n\n\n \nstruct usb_endpoint_descriptor fsg_hs_bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\nEXPORT_SYMBOL_GPL(fsg_hs_bulk_in_desc);\n\nstruct usb_endpoint_descriptor fsg_hs_bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n\t.bInterval =\t\t1,\t \n};\nEXPORT_SYMBOL_GPL(fsg_hs_bulk_out_desc);\n\n\nstruct usb_descriptor_header *fsg_hs_function[] = {\n\t(struct usb_descriptor_header *) &fsg_intf_desc,\n\t(struct usb_descriptor_header *) &fsg_hs_bulk_in_desc,\n\t(struct usb_descriptor_header *) &fsg_hs_bulk_out_desc,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(fsg_hs_function);\n\nstruct usb_endpoint_descriptor fsg_ss_bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\nEXPORT_SYMBOL_GPL(fsg_ss_bulk_in_desc);\n\nstruct usb_ss_ep_comp_descriptor fsg_ss_bulk_in_comp_desc = {\n\t.bLength =\t\tsizeof(fsg_ss_bulk_in_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n};\nEXPORT_SYMBOL_GPL(fsg_ss_bulk_in_comp_desc);\n\nstruct usb_endpoint_descriptor fsg_ss_bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\nEXPORT_SYMBOL_GPL(fsg_ss_bulk_out_desc);\n\nstruct usb_ss_ep_comp_descriptor fsg_ss_bulk_out_comp_desc = {\n\t.bLength =\t\tsizeof(fsg_ss_bulk_in_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n};\nEXPORT_SYMBOL_GPL(fsg_ss_bulk_out_comp_desc);\n\nstruct usb_descriptor_header *fsg_ss_function[] = {\n\t(struct usb_descriptor_header *) &fsg_intf_desc,\n\t(struct usb_descriptor_header *) &fsg_ss_bulk_in_desc,\n\t(struct usb_descriptor_header *) &fsg_ss_bulk_in_comp_desc,\n\t(struct usb_descriptor_header *) &fsg_ss_bulk_out_desc,\n\t(struct usb_descriptor_header *) &fsg_ss_bulk_out_comp_desc,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(fsg_ss_function);\n\n\n  \n\n \n\nvoid fsg_lun_close(struct fsg_lun *curlun)\n{\n\tif (curlun->filp) {\n\t\tLDBG(curlun, \"close backing file\\n\");\n\t\tfput(curlun->filp);\n\t\tcurlun->filp = NULL;\n\t}\n}\nEXPORT_SYMBOL_GPL(fsg_lun_close);\n\nint fsg_lun_open(struct fsg_lun *curlun, const char *filename)\n{\n\tint\t\t\t\tro;\n\tstruct file\t\t\t*filp = NULL;\n\tint\t\t\t\trc = -EINVAL;\n\tstruct inode\t\t\t*inode = NULL;\n\tloff_t\t\t\t\tsize;\n\tloff_t\t\t\t\tnum_sectors;\n\tloff_t\t\t\t\tmin_sectors;\n\tunsigned int\t\t\tblkbits;\n\tunsigned int\t\t\tblksize;\n\n\t \n\tro = curlun->initially_ro;\n\tif (!ro) {\n\t\tfilp = filp_open(filename, O_RDWR | O_LARGEFILE, 0);\n\t\tif (PTR_ERR(filp) == -EROFS || PTR_ERR(filp) == -EACCES)\n\t\t\tro = 1;\n\t}\n\tif (ro)\n\t\tfilp = filp_open(filename, O_RDONLY | O_LARGEFILE, 0);\n\tif (IS_ERR(filp)) {\n\t\tLINFO(curlun, \"unable to open backing file: %s\\n\", filename);\n\t\treturn PTR_ERR(filp);\n\t}\n\n\tif (!(filp->f_mode & FMODE_WRITE))\n\t\tro = 1;\n\n\tinode = filp->f_mapping->host;\n\tif ((!S_ISREG(inode->i_mode) && !S_ISBLK(inode->i_mode))) {\n\t\tLINFO(curlun, \"invalid file type: %s\\n\", filename);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(filp->f_mode & FMODE_CAN_READ)) {\n\t\tLINFO(curlun, \"file not readable: %s\\n\", filename);\n\t\tgoto out;\n\t}\n\tif (!(filp->f_mode & FMODE_CAN_WRITE))\n\t\tro = 1;\n\n\tsize = i_size_read(inode);\n\tif (size < 0) {\n\t\tLINFO(curlun, \"unable to find file size: %s\\n\", filename);\n\t\trc = (int) size;\n\t\tgoto out;\n\t}\n\n\tif (curlun->cdrom) {\n\t\tblksize = 2048;\n\t\tblkbits = 11;\n\t} else if (S_ISBLK(inode->i_mode)) {\n\t\tblksize = bdev_logical_block_size(I_BDEV(inode));\n\t\tblkbits = blksize_bits(blksize);\n\t} else {\n\t\tblksize = 512;\n\t\tblkbits = 9;\n\t}\n\n\tnum_sectors = size >> blkbits;  \n\tmin_sectors = 1;\n\tif (curlun->cdrom) {\n\t\tmin_sectors = 300;\t \n\t\tif (num_sectors >= 256*60*75) {\n\t\t\tnum_sectors = 256*60*75 - 1;\n\t\t\tLINFO(curlun, \"file too big: %s\\n\", filename);\n\t\t\tLINFO(curlun, \"using only first %d blocks\\n\",\n\t\t\t\t\t(int) num_sectors);\n\t\t}\n\t}\n\tif (num_sectors < min_sectors) {\n\t\tLINFO(curlun, \"file too small: %s\\n\", filename);\n\t\trc = -ETOOSMALL;\n\t\tgoto out;\n\t}\n\n\tif (fsg_lun_is_open(curlun))\n\t\tfsg_lun_close(curlun);\n\n\tcurlun->blksize = blksize;\n\tcurlun->blkbits = blkbits;\n\tcurlun->ro = ro;\n\tcurlun->filp = filp;\n\tcurlun->file_length = size;\n\tcurlun->num_sectors = num_sectors;\n\tLDBG(curlun, \"open backing file: %s\\n\", filename);\n\treturn 0;\n\nout:\n\tfput(filp);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsg_lun_open);\n\n\n \n\n \nint fsg_lun_fsync_sub(struct fsg_lun *curlun)\n{\n\tstruct file\t*filp = curlun->filp;\n\n\tif (curlun->ro || !filp)\n\t\treturn 0;\n\treturn vfs_fsync(filp, 1);\n}\nEXPORT_SYMBOL_GPL(fsg_lun_fsync_sub);\n\nvoid store_cdrom_address(u8 *dest, int msf, u32 addr)\n{\n\tif (msf) {\n\t\t \n\t\taddr += 2*75;\t\t \n\t\tdest[3] = addr % 75;\t \n\t\taddr /= 75;\n\t\tdest[2] = addr % 60;\t \n\t\taddr /= 60;\n\t\tdest[1] = addr;\t\t \n\t\tdest[0] = 0;\t\t \n\t} else {\n\t\t \n\t\tput_unaligned_be32(addr, dest);\n\t}\n}\nEXPORT_SYMBOL_GPL(store_cdrom_address);\n\n \n\n\nssize_t fsg_show_ro(struct fsg_lun *curlun, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", fsg_lun_is_open(curlun)\n\t\t\t\t  ? curlun->ro\n\t\t\t\t  : curlun->initially_ro);\n}\nEXPORT_SYMBOL_GPL(fsg_show_ro);\n\nssize_t fsg_show_nofua(struct fsg_lun *curlun, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", curlun->nofua);\n}\nEXPORT_SYMBOL_GPL(fsg_show_nofua);\n\nssize_t fsg_show_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,\n\t\t      char *buf)\n{\n\tchar\t\t*p;\n\tssize_t\t\trc;\n\n\tdown_read(filesem);\n\tif (fsg_lun_is_open(curlun)) {\t \n\t\tp = file_path(curlun->filp, buf, PAGE_SIZE - 1);\n\t\tif (IS_ERR(p))\n\t\t\trc = PTR_ERR(p);\n\t\telse {\n\t\t\trc = strlen(p);\n\t\t\tmemmove(buf, p, rc);\n\t\t\tbuf[rc] = '\\n';\t\t \n\t\t\tbuf[++rc] = 0;\n\t\t}\n\t} else {\t\t\t\t \n\t\t*buf = 0;\n\t\trc = 0;\n\t}\n\tup_read(filesem);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsg_show_file);\n\nssize_t fsg_show_cdrom(struct fsg_lun *curlun, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", curlun->cdrom);\n}\nEXPORT_SYMBOL_GPL(fsg_show_cdrom);\n\nssize_t fsg_show_removable(struct fsg_lun *curlun, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", curlun->removable);\n}\nEXPORT_SYMBOL_GPL(fsg_show_removable);\n\nssize_t fsg_show_inquiry_string(struct fsg_lun *curlun, char *buf)\n{\n\treturn sprintf(buf, \"%s\\n\", curlun->inquiry_string);\n}\nEXPORT_SYMBOL_GPL(fsg_show_inquiry_string);\n\n \nstatic ssize_t _fsg_store_ro(struct fsg_lun *curlun, bool ro)\n{\n\tif (fsg_lun_is_open(curlun)) {\n\t\tLDBG(curlun, \"read-only status change prevented\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcurlun->ro = ro;\n\tcurlun->initially_ro = ro;\n\tLDBG(curlun, \"read-only status set to %d\\n\", curlun->ro);\n\n\treturn 0;\n}\n\nssize_t fsg_store_ro(struct fsg_lun *curlun, struct rw_semaphore *filesem,\n\t\t     const char *buf, size_t count)\n{\n\tssize_t\t\trc;\n\tbool\t\tro;\n\n\trc = kstrtobool(buf, &ro);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tdown_read(filesem);\n\trc = _fsg_store_ro(curlun, ro);\n\tif (!rc)\n\t\trc = count;\n\tup_read(filesem);\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsg_store_ro);\n\nssize_t fsg_store_nofua(struct fsg_lun *curlun, const char *buf, size_t count)\n{\n\tbool\t\tnofua;\n\tint\t\tret;\n\n\tret = kstrtobool(buf, &nofua);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!nofua && curlun->nofua)\n\t\tfsg_lun_fsync_sub(curlun);\n\n\tcurlun->nofua = nofua;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(fsg_store_nofua);\n\nssize_t fsg_store_file(struct fsg_lun *curlun, struct rw_semaphore *filesem,\n\t\t       const char *buf, size_t count)\n{\n\tint\t\trc = 0;\n\n\tif (curlun->prevent_medium_removal && fsg_lun_is_open(curlun)) {\n\t\tLDBG(curlun, \"eject attempt prevented\\n\");\n\t\treturn -EBUSY;\t\t\t\t \n\t}\n\n\t \n\tif (count > 0 && buf[count-1] == '\\n')\n\t\t((char *) buf)[count-1] = 0;\t\t \n\n\t \n\tdown_write(filesem);\n\tif (count > 0 && buf[0]) {\n\t\t \n\t\trc = fsg_lun_open(curlun, buf);\n\t\tif (rc == 0)\n\t\t\tcurlun->unit_attention_data =\n\t\t\t\t\tSS_NOT_READY_TO_READY_TRANSITION;\n\t} else if (fsg_lun_is_open(curlun)) {\n\t\tfsg_lun_close(curlun);\n\t\tcurlun->unit_attention_data = SS_MEDIUM_NOT_PRESENT;\n\t}\n\tup_write(filesem);\n\treturn (rc < 0 ? rc : count);\n}\nEXPORT_SYMBOL_GPL(fsg_store_file);\n\nssize_t fsg_store_cdrom(struct fsg_lun *curlun, struct rw_semaphore *filesem,\n\t\t\tconst char *buf, size_t count)\n{\n\tbool\t\tcdrom;\n\tint\t\tret;\n\n\tret = kstrtobool(buf, &cdrom);\n\tif (ret)\n\t\treturn ret;\n\n\tdown_read(filesem);\n\tret = cdrom ? _fsg_store_ro(curlun, true) : 0;\n\n\tif (!ret) {\n\t\tcurlun->cdrom = cdrom;\n\t\tret = count;\n\t}\n\tup_read(filesem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(fsg_store_cdrom);\n\nssize_t fsg_store_removable(struct fsg_lun *curlun, const char *buf,\n\t\t\t    size_t count)\n{\n\tbool\t\tremovable;\n\tint\t\tret;\n\n\tret = kstrtobool(buf, &removable);\n\tif (ret)\n\t\treturn ret;\n\n\tcurlun->removable = removable;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(fsg_store_removable);\n\nssize_t fsg_store_inquiry_string(struct fsg_lun *curlun, const char *buf,\n\t\t\t\t size_t count)\n{\n\tconst size_t len = min(count, sizeof(curlun->inquiry_string));\n\n\tif (len == 0 || buf[0] == '\\n') {\n\t\tcurlun->inquiry_string[0] = 0;\n\t} else {\n\t\tsnprintf(curlun->inquiry_string,\n\t\t\t sizeof(curlun->inquiry_string), \"%-28s\", buf);\n\t\tif (curlun->inquiry_string[len-1] == '\\n')\n\t\t\tcurlun->inquiry_string[len-1] = ' ';\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(fsg_store_inquiry_string);\n\nssize_t fsg_store_forced_eject(struct fsg_lun *curlun, struct rw_semaphore *filesem,\n\t\t\t       const char *buf, size_t count)\n{\n\tint ret;\n\n\t \n\tcurlun->prevent_medium_removal = 0;\n\tret = fsg_store_file(curlun, filesem, \"\", 0);\n\treturn ret < 0 ? ret : count;\n}\nEXPORT_SYMBOL_GPL(fsg_store_forced_eject);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}