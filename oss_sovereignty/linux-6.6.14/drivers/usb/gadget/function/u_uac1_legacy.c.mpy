{
  "module_name": "u_uac1_legacy.c",
  "hash_id": "a44f0d502b19f8932cdd06890858e6fb6a9889b750da00a9b5e70f24c5ad8981",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/u_uac1_legacy.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/syscalls.h>\n\n#include \"u_uac1_legacy.h\"\n\n \n\n \n\n \nstatic int snd_interval_refine_set(struct snd_interval *i, unsigned int val)\n{\n\tstruct snd_interval t;\n\tt.empty = 0;\n\tt.min = t.max = val;\n\tt.openmin = t.openmax = 0;\n\tt.integer = 1;\n\treturn snd_interval_refine(i, &t);\n}\n\nstatic int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,\n\t\t\t\t snd_pcm_hw_param_t var, unsigned int val,\n\t\t\t\t int dir)\n{\n\tint changed;\n\tif (hw_is_mask(var)) {\n\t\tstruct snd_mask *m = hw_param_mask(params, var);\n\t\tif (val == 0 && dir < 0) {\n\t\t\tchanged = -EINVAL;\n\t\t\tsnd_mask_none(m);\n\t\t} else {\n\t\t\tif (dir > 0)\n\t\t\t\tval++;\n\t\t\telse if (dir < 0)\n\t\t\t\tval--;\n\t\t\tchanged = snd_mask_refine_set(\n\t\t\t\t\thw_param_mask(params, var), val);\n\t\t}\n\t} else if (hw_is_interval(var)) {\n\t\tstruct snd_interval *i = hw_param_interval(params, var);\n\t\tif (val == 0 && dir < 0) {\n\t\t\tchanged = -EINVAL;\n\t\t\tsnd_interval_none(i);\n\t\t} else if (dir == 0)\n\t\t\tchanged = snd_interval_refine_set(i, val);\n\t\telse {\n\t\t\tstruct snd_interval t;\n\t\t\tt.openmin = 1;\n\t\t\tt.openmax = 1;\n\t\t\tt.empty = 0;\n\t\t\tt.integer = 0;\n\t\t\tif (dir < 0) {\n\t\t\t\tt.min = val - 1;\n\t\t\t\tt.max = val;\n\t\t\t} else {\n\t\t\t\tt.min = val;\n\t\t\t\tt.max = val+1;\n\t\t\t}\n\t\t\tchanged = snd_interval_refine(i, &t);\n\t\t}\n\t} else\n\t\treturn -EINVAL;\n\tif (changed) {\n\t\tparams->cmask |= 1 << var;\n\t\tparams->rmask |= 1 << var;\n\t}\n\treturn changed;\n}\n \n\n \nstatic int playback_default_hw_params(struct gaudio_snd_dev *snd)\n{\n\tstruct snd_pcm_substream *substream = snd->substream;\n\tstruct snd_pcm_hw_params *params;\n\tsnd_pcm_sframes_t result;\n\n        \n\tsnd->access = SNDRV_PCM_ACCESS_RW_INTERLEAVED;\n\tsnd->format = SNDRV_PCM_FORMAT_S16_LE;\n\tsnd->channels = 2;\n\tsnd->rate = 48000;\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\t_snd_pcm_hw_params_any(params);\n\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_ACCESS,\n\t\t\tsnd->access, 0);\n\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_FORMAT,\n\t\t\tsnd->format, 0);\n\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_CHANNELS,\n\t\t\tsnd->channels, 0);\n\t_snd_pcm_hw_param_set(params, SNDRV_PCM_HW_PARAM_RATE,\n\t\t\tsnd->rate, 0);\n\n\tsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_DROP, NULL);\n\tsnd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_HW_PARAMS, params);\n\n\tresult = snd_pcm_kernel_ioctl(substream, SNDRV_PCM_IOCTL_PREPARE, NULL);\n\tif (result < 0) {\n\t\tERROR(snd->card,\n\t\t\t\"Preparing sound card failed: %d\\n\", (int)result);\n\t\tkfree(params);\n\t\treturn result;\n\t}\n\n\t \n\tsnd->access = params_access(params);\n\tsnd->format = params_format(params);\n\tsnd->channels = params_channels(params);\n\tsnd->rate = params_rate(params);\n\n\tkfree(params);\n\n\tINFO(snd->card,\n\t\t\"Hardware params: access %x, format %x, channels %d, rate %d\\n\",\n\t\tsnd->access, snd->format, snd->channels, snd->rate);\n\n\treturn 0;\n}\n\n \nsize_t u_audio_playback(struct gaudio *card, void *buf, size_t count)\n{\n\tstruct gaudio_snd_dev\t*snd = &card->playback;\n\tstruct snd_pcm_substream *substream = snd->substream;\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tssize_t result;\n\tsnd_pcm_sframes_t frames;\n\ntry_again:\n\tif (runtime->state == SNDRV_PCM_STATE_XRUN ||\n\t\truntime->state == SNDRV_PCM_STATE_SUSPENDED) {\n\t\tresult = snd_pcm_kernel_ioctl(substream,\n\t\t\t\tSNDRV_PCM_IOCTL_PREPARE, NULL);\n\t\tif (result < 0) {\n\t\t\tERROR(card, \"Preparing sound card failed: %d\\n\",\n\t\t\t\t\t(int)result);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tframes = bytes_to_frames(runtime, count);\n\tresult = snd_pcm_kernel_write(snd->substream, buf, frames);\n\tif (result != frames) {\n\t\tERROR(card, \"Playback error: %d\\n\", (int)result);\n\t\tgoto try_again;\n\t}\n\n\treturn 0;\n}\n\nint u_audio_get_playback_channels(struct gaudio *card)\n{\n\treturn card->playback.channels;\n}\n\nint u_audio_get_playback_rate(struct gaudio *card)\n{\n\treturn card->playback.rate;\n}\n\n \nstatic int gaudio_open_snd_dev(struct gaudio *card)\n{\n\tstruct snd_pcm_file *pcm_file;\n\tstruct gaudio_snd_dev *snd;\n\tstruct f_uac1_legacy_opts *opts;\n\tchar *fn_play, *fn_cap, *fn_cntl;\n\n\topts = container_of(card->func.fi, struct f_uac1_legacy_opts,\n\t\t\t    func_inst);\n\tfn_play = opts->fn_play;\n\tfn_cap = opts->fn_cap;\n\tfn_cntl = opts->fn_cntl;\n\n\t \n\tsnd = &card->control;\n\tsnd->filp = filp_open(fn_cntl, O_RDWR, 0);\n\tif (IS_ERR(snd->filp)) {\n\t\tint ret = PTR_ERR(snd->filp);\n\t\tERROR(card, \"unable to open sound control device file: %s\\n\",\n\t\t\t\tfn_cntl);\n\t\tsnd->filp = NULL;\n\t\treturn ret;\n\t}\n\tsnd->card = card;\n\n\t \n\tsnd = &card->playback;\n\tsnd->filp = filp_open(fn_play, O_WRONLY, 0);\n\tif (IS_ERR(snd->filp)) {\n\t\tint ret = PTR_ERR(snd->filp);\n\n\t\tERROR(card, \"No such PCM playback device: %s\\n\", fn_play);\n\t\tsnd->filp = NULL;\n\t\treturn ret;\n\t}\n\tpcm_file = snd->filp->private_data;\n\tsnd->substream = pcm_file->substream;\n\tsnd->card = card;\n\tplayback_default_hw_params(snd);\n\n\t \n\tsnd = &card->capture;\n\tsnd->filp = filp_open(fn_cap, O_RDONLY, 0);\n\tif (IS_ERR(snd->filp)) {\n\t\tERROR(card, \"No such PCM capture device: %s\\n\", fn_cap);\n\t\tsnd->substream = NULL;\n\t\tsnd->card = NULL;\n\t\tsnd->filp = NULL;\n\t} else {\n\t\tpcm_file = snd->filp->private_data;\n\t\tsnd->substream = pcm_file->substream;\n\t\tsnd->card = card;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int gaudio_close_snd_dev(struct gaudio *gau)\n{\n\tstruct gaudio_snd_dev\t*snd;\n\n\t \n\tsnd = &gau->control;\n\tif (snd->filp)\n\t\tfilp_close(snd->filp, NULL);\n\n\t \n\tsnd = &gau->playback;\n\tif (snd->filp)\n\t\tfilp_close(snd->filp, NULL);\n\n\t \n\tsnd = &gau->capture;\n\tif (snd->filp)\n\t\tfilp_close(snd->filp, NULL);\n\n\treturn 0;\n}\n\n \nint gaudio_setup(struct gaudio *card)\n{\n\tint\tret;\n\n\tret = gaudio_open_snd_dev(card);\n\tif (ret)\n\t\tERROR(card, \"we need at least one control device\\n\");\n\n\treturn ret;\n\n}\n\n \nvoid gaudio_cleanup(struct gaudio *the_card)\n{\n\tif (the_card)\n\t\tgaudio_close_snd_dev(the_card);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}