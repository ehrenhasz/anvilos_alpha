{
  "module_name": "uvc_v4l2.c",
  "hash_id": "581115ffc66ddfffdf8dc16837862fd74e61e39a885d61b2496f7996e40c5493",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc_v4l2.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/usb/g_uvc.h>\n#include <linux/usb/uvc.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n\n#include <media/v4l2-dev.h>\n#include <media/v4l2-event.h>\n#include <media/v4l2-ioctl.h>\n\n#include \"f_uvc.h\"\n#include \"uvc.h\"\n#include \"uvc_queue.h\"\n#include \"uvc_video.h\"\n#include \"uvc_v4l2.h\"\n#include \"uvc_configfs.h\"\n\nstatic const struct uvc_format_desc *to_uvc_format(struct uvcg_format *uformat)\n{\n\tchar guid[16] = UVC_GUID_FORMAT_MJPEG;\n\tconst struct uvc_format_desc *format;\n\tstruct uvcg_uncompressed *unc;\n\n\tif (uformat->type == UVCG_UNCOMPRESSED) {\n\t\tunc = to_uvcg_uncompressed(&uformat->group.cg_item);\n\t\tif (!unc)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\tmemcpy(guid, unc->desc.guidFormat, sizeof(guid));\n\t}\n\n\tformat = uvc_format_by_guid(guid);\n\tif (!format)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn format;\n}\n\nstatic int uvc_v4l2_get_bytesperline(struct uvcg_format *uformat,\n\t\t\t      struct uvcg_frame *uframe)\n{\n\tstruct uvcg_uncompressed *u;\n\n\tif (uformat->type == UVCG_UNCOMPRESSED) {\n\t\tu = to_uvcg_uncompressed(&uformat->group.cg_item);\n\t\tif (!u)\n\t\t\treturn 0;\n\n\t\treturn u->desc.bBitsPerPixel * uframe->frame.w_width / 8;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvc_get_frame_size(struct uvcg_format *uformat,\n\t\t       struct uvcg_frame *uframe)\n{\n\tunsigned int bpl = uvc_v4l2_get_bytesperline(uformat, uframe);\n\n\treturn bpl ? bpl * uframe->frame.w_height :\n\t\tuframe->frame.dw_max_video_frame_buffer_size;\n}\n\nstatic struct uvcg_format *find_format_by_index(struct uvc_device *uvc, int index)\n{\n\tstruct uvcg_format_ptr *format;\n\tstruct uvcg_format *uformat = NULL;\n\tint i = 1;\n\n\tlist_for_each_entry(format, &uvc->header->formats, entry) {\n\t\tif (index == i) {\n\t\t\tuformat = format->fmt;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn uformat;\n}\n\nstatic struct uvcg_frame *find_frame_by_index(struct uvc_device *uvc,\n\t\t\t\t       struct uvcg_format *uformat,\n\t\t\t\t       int index)\n{\n\tstruct uvcg_format_ptr *format;\n\tstruct uvcg_frame_ptr *frame;\n\tstruct uvcg_frame *uframe = NULL;\n\n\tlist_for_each_entry(format, &uvc->header->formats, entry) {\n\t\tif (format->fmt->type != uformat->type)\n\t\t\tcontinue;\n\t\tlist_for_each_entry(frame, &format->fmt->frames, entry) {\n\t\t\tif (index == frame->frm->frame.b_frame_index) {\n\t\t\t\tuframe = frame->frm;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn uframe;\n}\n\nstatic struct uvcg_format *find_format_by_pix(struct uvc_device *uvc,\n\t\t\t\t\t      u32 pixelformat)\n{\n\tstruct uvcg_format_ptr *format;\n\tstruct uvcg_format *uformat = NULL;\n\n\tlist_for_each_entry(format, &uvc->header->formats, entry) {\n\t\tconst struct uvc_format_desc *fmtdesc = to_uvc_format(format->fmt);\n\n\t\tif (fmtdesc->fcc == pixelformat) {\n\t\t\tuformat = format->fmt;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn uformat;\n}\n\nstatic struct uvcg_frame *find_closest_frame_by_size(struct uvc_device *uvc,\n\t\t\t\t\t   struct uvcg_format *uformat,\n\t\t\t\t\t   u16 rw, u16 rh)\n{\n\tstruct uvc_video *video = &uvc->video;\n\tstruct uvcg_format_ptr *format;\n\tstruct uvcg_frame_ptr *frame;\n\tstruct uvcg_frame *uframe = NULL;\n\tunsigned int d, maxd;\n\n\t \n\tmaxd = (unsigned int)-1;\n\n\tlist_for_each_entry(format, &uvc->header->formats, entry) {\n\t\tif (format->fmt->type != uformat->type)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(frame, &format->fmt->frames, entry) {\n\t\t\tu16 w, h;\n\n\t\t\tw = frame->frm->frame.w_width;\n\t\t\th = frame->frm->frame.w_height;\n\n\t\t\td = min(w, rw) * min(h, rh);\n\t\t\td = w*h + rw*rh - 2*d;\n\t\t\tif (d < maxd) {\n\t\t\t\tmaxd = d;\n\t\t\t\tuframe = frame->frm;\n\t\t\t}\n\n\t\t\tif (maxd == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!uframe)\n\t\tuvcg_dbg(&video->uvc->func, \"Unsupported size %ux%u\\n\", rw, rh);\n\n\treturn uframe;\n}\n\n \n\nstatic int\nuvc_send_response(struct uvc_device *uvc, struct uvc_request_data *data)\n{\n\tstruct usb_composite_dev *cdev = uvc->func.config->cdev;\n\tstruct usb_request *req = uvc->control_req;\n\n\tif (data->length < 0)\n\t\treturn usb_ep_set_halt(cdev->gadget->ep0);\n\n\treq->length = min_t(unsigned int, uvc->event_length, data->length);\n\treq->zero = data->length < uvc->event_length;\n\n\tmemcpy(req->buf, data->data, req->length);\n\n\treturn usb_ep_queue(cdev->gadget->ep0, req, GFP_KERNEL);\n}\n\n \n\nstatic int\nuvc_v4l2_querycap(struct file *file, void *fh, struct v4l2_capability *cap)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct usb_composite_dev *cdev = uvc->func.config->cdev;\n\n\tstrscpy(cap->driver, \"g_uvc\", sizeof(cap->driver));\n\tstrscpy(cap->card, cdev->gadget->name, sizeof(cap->card));\n\tstrscpy(cap->bus_info, dev_name(&cdev->gadget->dev),\n\t\tsizeof(cap->bus_info));\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_get_format(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\n\tfmt->fmt.pix.pixelformat = video->fcc;\n\tfmt->fmt.pix.width = video->width;\n\tfmt->fmt.pix.height = video->height;\n\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\tfmt->fmt.pix.bytesperline = video->bpp * video->width / 8;\n\tfmt->fmt.pix.sizeimage = video->imagesize;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->fmt.pix.priv = 0;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_try_format(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\tstruct uvcg_format *uformat;\n\tstruct uvcg_frame *uframe;\n\tu8 *fcc;\n\n\tif (fmt->type != video->queue.queue.type)\n\t\treturn -EINVAL;\n\n\tfcc = (u8 *)&fmt->fmt.pix.pixelformat;\n\tuvcg_dbg(&uvc->func, \"Trying format 0x%08x (%c%c%c%c): %ux%u\\n\",\n\t\tfmt->fmt.pix.pixelformat,\n\t\tfcc[0], fcc[1], fcc[2], fcc[3],\n\t\tfmt->fmt.pix.width, fmt->fmt.pix.height);\n\n\tuformat = find_format_by_pix(uvc, fmt->fmt.pix.pixelformat);\n\tif (!uformat)\n\t\treturn -EINVAL;\n\n\tuframe = find_closest_frame_by_size(uvc, uformat,\n\t\t\t\tfmt->fmt.pix.width, fmt->fmt.pix.height);\n\tif (!uframe)\n\t\treturn -EINVAL;\n\n\tfmt->fmt.pix.width = uframe->frame.w_width;\n\tfmt->fmt.pix.height = uframe->frame.w_height;\n\tfmt->fmt.pix.field = V4L2_FIELD_NONE;\n\tfmt->fmt.pix.bytesperline = uvc_v4l2_get_bytesperline(uformat, uframe);\n\tfmt->fmt.pix.sizeimage = uvc_get_frame_size(uformat, uframe);\n\tfmt->fmt.pix.pixelformat = to_uvc_format(uformat)->fcc;\n\tfmt->fmt.pix.colorspace = V4L2_COLORSPACE_SRGB;\n\tfmt->fmt.pix.priv = 0;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_set_format(struct file *file, void *fh, struct v4l2_format *fmt)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\tint ret;\n\n\tret = uvc_v4l2_try_format(file, fh, fmt);\n\tif (ret)\n\t\treturn ret;\n\n\tvideo->fcc = fmt->fmt.pix.pixelformat;\n\tvideo->bpp = fmt->fmt.pix.bytesperline * 8 / video->width;\n\tvideo->width = fmt->fmt.pix.width;\n\tvideo->height = fmt->fmt.pix.height;\n\tvideo->imagesize = fmt->fmt.pix.sizeimage;\n\n\treturn ret;\n}\n\nstatic int\nuvc_v4l2_enum_frameintervals(struct file *file, void *fh,\n\t\tstruct v4l2_frmivalenum *fival)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvcg_format *uformat = NULL;\n\tstruct uvcg_frame *uframe = NULL;\n\tstruct uvcg_frame_ptr *frame;\n\n\tuformat = find_format_by_pix(uvc, fival->pixel_format);\n\tif (!uformat)\n\t\treturn -EINVAL;\n\n\tlist_for_each_entry(frame, &uformat->frames, entry) {\n\t\tif (frame->frm->frame.w_width == fival->width &&\n\t\t    frame->frm->frame.w_height == fival->height) {\n\t\t\tuframe = frame->frm;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!uframe)\n\t\treturn -EINVAL;\n\n\tif (fival->index >= uframe->frame.b_frame_interval_type)\n\t\treturn -EINVAL;\n\n\tfival->discrete.numerator =\n\t\tuframe->dw_frame_interval[fival->index];\n\n\t \n\tfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\n\tfival->discrete.denominator = 10000000;\n\tv4l2_simplify_fraction(&fival->discrete.numerator,\n\t\t&fival->discrete.denominator, 8, 333);\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_enum_framesizes(struct file *file, void *fh,\n\t\tstruct v4l2_frmsizeenum *fsize)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvcg_format *uformat = NULL;\n\tstruct uvcg_frame *uframe = NULL;\n\n\tuformat = find_format_by_pix(uvc, fsize->pixel_format);\n\tif (!uformat)\n\t\treturn -EINVAL;\n\n\tif (fsize->index >= uformat->num_frames)\n\t\treturn -EINVAL;\n\n\tuframe = find_frame_by_index(uvc, uformat, fsize->index + 1);\n\tif (!uframe)\n\t\treturn -EINVAL;\n\n\tfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\n\tfsize->discrete.width = uframe->frame.w_width;\n\tfsize->discrete.height = uframe->frame.w_height;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tconst struct uvc_format_desc *fmtdesc;\n\tstruct uvcg_format *uformat;\n\n\tif (f->index >= uvc->header->num_fmt)\n\t\treturn -EINVAL;\n\n\tuformat = find_format_by_index(uvc, f->index + 1);\n\tif (!uformat)\n\t\treturn -EINVAL;\n\n\tfmtdesc = to_uvc_format(uformat);\n\tf->pixelformat = fmtdesc->fcc;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *b)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\n\tif (b->type != video->queue.queue.type)\n\t\treturn -EINVAL;\n\n\treturn uvcg_alloc_buffers(&video->queue, b);\n}\n\nstatic int\nuvc_v4l2_querybuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\n\treturn uvcg_query_buffer(&video->queue, b);\n}\n\nstatic int\nuvc_v4l2_qbuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\tint ret;\n\n\tret = uvcg_queue_buffer(&video->queue, b);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (uvc->state == UVC_STATE_STREAMING)\n\t\tqueue_work(video->async_wq, &video->pump);\n\n\treturn ret;\n}\n\nstatic int\nuvc_v4l2_dqbuf(struct file *file, void *fh, struct v4l2_buffer *b)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\n\treturn uvcg_dequeue_buffer(&video->queue, b, file->f_flags & O_NONBLOCK);\n}\n\nstatic int\nuvc_v4l2_streamon(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\tint ret;\n\n\tif (type != video->queue.queue.type)\n\t\treturn -EINVAL;\n\n\t \n\tret = uvcg_video_enable(video, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tuvc_function_setup_continue(uvc);\n\tuvc->state = UVC_STATE_STREAMING;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_video *video = &uvc->video;\n\n\tif (type != video->queue.queue.type)\n\t\treturn -EINVAL;\n\n\treturn uvcg_video_enable(video, 0);\n}\n\nstatic int\nuvc_v4l2_subscribe_event(struct v4l2_fh *fh,\n\t\t\t const struct v4l2_event_subscription *sub)\n{\n\tstruct uvc_device *uvc = video_get_drvdata(fh->vdev);\n\tstruct uvc_file_handle *handle = to_uvc_file_handle(fh);\n\tint ret;\n\n\tif (sub->type < UVC_EVENT_FIRST || sub->type > UVC_EVENT_LAST)\n\t\treturn -EINVAL;\n\n\tif (sub->type == UVC_EVENT_SETUP && uvc->func_connected)\n\t\treturn -EBUSY;\n\n\tret = v4l2_event_subscribe(fh, sub, 2, NULL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sub->type == UVC_EVENT_SETUP) {\n\t\tuvc->func_connected = true;\n\t\thandle->is_uvc_app_handle = true;\n\t\tuvc_function_connect(uvc);\n\t}\n\n\treturn 0;\n}\n\nstatic void uvc_v4l2_disable(struct uvc_device *uvc)\n{\n\tuvc_function_disconnect(uvc);\n\tuvcg_video_enable(&uvc->video, 0);\n\tuvcg_free_buffers(&uvc->video.queue);\n\tuvc->func_connected = false;\n\twake_up_interruptible(&uvc->func_connected_queue);\n}\n\nstatic int\nuvc_v4l2_unsubscribe_event(struct v4l2_fh *fh,\n\t\t\t   const struct v4l2_event_subscription *sub)\n{\n\tstruct uvc_device *uvc = video_get_drvdata(fh->vdev);\n\tstruct uvc_file_handle *handle = to_uvc_file_handle(fh);\n\tint ret;\n\n\tret = v4l2_event_unsubscribe(fh, sub);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (sub->type == UVC_EVENT_SETUP && handle->is_uvc_app_handle) {\n\t\tuvc_v4l2_disable(uvc);\n\t\thandle->is_uvc_app_handle = false;\n\t}\n\n\treturn 0;\n}\n\nstatic long\nuvc_v4l2_ioctl_default(struct file *file, void *fh, bool valid_prio,\n\t\t       unsigned int cmd, void *arg)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\n\tswitch (cmd) {\n\tcase UVCIOC_SEND_RESPONSE:\n\t\treturn uvc_send_response(uvc, arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nconst struct v4l2_ioctl_ops uvc_v4l2_ioctl_ops = {\n\t.vidioc_querycap = uvc_v4l2_querycap,\n\t.vidioc_try_fmt_vid_out = uvc_v4l2_try_format,\n\t.vidioc_g_fmt_vid_out = uvc_v4l2_get_format,\n\t.vidioc_s_fmt_vid_out = uvc_v4l2_set_format,\n\t.vidioc_enum_frameintervals = uvc_v4l2_enum_frameintervals,\n\t.vidioc_enum_framesizes = uvc_v4l2_enum_framesizes,\n\t.vidioc_enum_fmt_vid_out = uvc_v4l2_enum_format,\n\t.vidioc_reqbufs = uvc_v4l2_reqbufs,\n\t.vidioc_querybuf = uvc_v4l2_querybuf,\n\t.vidioc_qbuf = uvc_v4l2_qbuf,\n\t.vidioc_dqbuf = uvc_v4l2_dqbuf,\n\t.vidioc_streamon = uvc_v4l2_streamon,\n\t.vidioc_streamoff = uvc_v4l2_streamoff,\n\t.vidioc_subscribe_event = uvc_v4l2_subscribe_event,\n\t.vidioc_unsubscribe_event = uvc_v4l2_unsubscribe_event,\n\t.vidioc_default = uvc_v4l2_ioctl_default,\n};\n\n \n\nstatic int\nuvc_v4l2_open(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_file_handle *handle;\n\n\thandle = kzalloc(sizeof(*handle), GFP_KERNEL);\n\tif (handle == NULL)\n\t\treturn -ENOMEM;\n\n\tv4l2_fh_init(&handle->vfh, vdev);\n\tv4l2_fh_add(&handle->vfh);\n\n\thandle->device = &uvc->video;\n\tfile->private_data = &handle->vfh;\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_release(struct file *file)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\tstruct uvc_file_handle *handle = to_uvc_file_handle(file->private_data);\n\tstruct uvc_video *video = handle->device;\n\n\tmutex_lock(&video->mutex);\n\tif (handle->is_uvc_app_handle)\n\t\tuvc_v4l2_disable(uvc);\n\tmutex_unlock(&video->mutex);\n\n\tfile->private_data = NULL;\n\tv4l2_fh_del(&handle->vfh);\n\tv4l2_fh_exit(&handle->vfh);\n\tkfree(handle);\n\n\treturn 0;\n}\n\nstatic int\nuvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\n\treturn uvcg_queue_mmap(&uvc->video.queue, vma);\n}\n\nstatic __poll_t\nuvc_v4l2_poll(struct file *file, poll_table *wait)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\n\treturn uvcg_queue_poll(&uvc->video.queue, file, wait);\n}\n\n#ifndef CONFIG_MMU\nstatic unsigned long uvcg_v4l2_get_unmapped_area(struct file *file,\n\t\tunsigned long addr, unsigned long len, unsigned long pgoff,\n\t\tunsigned long flags)\n{\n\tstruct video_device *vdev = video_devdata(file);\n\tstruct uvc_device *uvc = video_get_drvdata(vdev);\n\n\treturn uvcg_queue_get_unmapped_area(&uvc->video.queue, pgoff);\n}\n#endif\n\nconst struct v4l2_file_operations uvc_v4l2_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= uvc_v4l2_open,\n\t.release\t= uvc_v4l2_release,\n\t.unlocked_ioctl\t= video_ioctl2,\n\t.mmap\t\t= uvc_v4l2_mmap,\n\t.poll\t\t= uvc_v4l2_poll,\n#ifndef CONFIG_MMU\n\t.get_unmapped_area = uvcg_v4l2_get_unmapped_area,\n#endif\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}