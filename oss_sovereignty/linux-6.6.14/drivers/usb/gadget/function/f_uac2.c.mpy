{
  "module_name": "f_uac2.c",
  "hash_id": "9a79d12a05a25bcbd3dcb66200cfc95345fe8297dc9651d044c1eea403e8b1ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_uac2.c",
  "human_readable_source": "\n \n\n#include <linux/usb/audio.h>\n#include <linux/usb/audio-v2.h>\n#include <linux/module.h>\n\n#include \"u_audio.h\"\n\n#include \"u_uac2.h\"\n\n \n#define UAC2_CHANNEL_MASK 0x07FFFFFF\n\n \n#define USB_OUT_CLK_ID\t(out_clk_src_desc.bClockID)\n#define USB_IN_CLK_ID\t(in_clk_src_desc.bClockID)\n#define USB_OUT_FU_ID\t(out_feature_unit_desc->bUnitID)\n#define USB_IN_FU_ID\t(in_feature_unit_desc->bUnitID)\n\n#define CONTROL_ABSENT\t0\n#define CONTROL_RDONLY\t1\n#define CONTROL_RDWR\t3\n\n#define CLK_FREQ_CTRL\t0\n#define CLK_VLD_CTRL\t2\n#define FU_MUTE_CTRL\t0\n#define FU_VOL_CTRL\t2\n\n#define COPY_CTRL\t0\n#define CONN_CTRL\t2\n#define OVRLD_CTRL\t4\n#define CLSTR_CTRL\t6\n#define UNFLW_CTRL\t8\n#define OVFLW_CTRL\t10\n\n#define EPIN_EN(_opts) ((_opts)->p_chmask != 0)\n#define EPOUT_EN(_opts) ((_opts)->c_chmask != 0)\n#define FUIN_EN(_opts) (EPIN_EN(_opts) \\\n\t\t\t\t&& ((_opts)->p_mute_present \\\n\t\t\t\t|| (_opts)->p_volume_present))\n#define FUOUT_EN(_opts) (EPOUT_EN(_opts) \\\n\t\t\t\t&& ((_opts)->c_mute_present \\\n\t\t\t\t|| (_opts)->c_volume_present))\n#define EPOUT_FBACK_IN_EN(_opts) ((_opts)->c_sync == USB_ENDPOINT_SYNC_ASYNC)\n\nstruct f_uac2 {\n\tstruct g_audio g_audio;\n\tu8 ac_intf, as_in_intf, as_out_intf;\n\tu8 ac_alt, as_in_alt, as_out_alt;\t \n\n\tstruct usb_ctrlrequest setup_cr;\t \n\n\t \n\tstruct usb_ep\t*int_ep;\n\tatomic_t\tint_count;\n\t \n\tint clock_id;\n};\n\nstatic inline struct f_uac2 *func_to_uac2(struct usb_function *f)\n{\n\treturn container_of(f, struct f_uac2, g_audio.func);\n}\n\nstatic inline\nstruct f_uac2_opts *g_audio_to_uac2_opts(struct g_audio *agdev)\n{\n\treturn container_of(agdev->func.fi, struct f_uac2_opts, func_inst);\n}\n\nstatic int afunc_notify(struct g_audio *agdev, int unit_id, int cs);\n\n \n\nenum {\n\tSTR_ASSOC,\n\tSTR_IF_CTRL,\n\tSTR_CLKSRC_IN,\n\tSTR_CLKSRC_OUT,\n\tSTR_USB_IT,\n\tSTR_IO_IT,\n\tSTR_USB_OT,\n\tSTR_IO_OT,\n\tSTR_FU_IN,\n\tSTR_FU_OUT,\n\tSTR_AS_OUT_ALT0,\n\tSTR_AS_OUT_ALT1,\n\tSTR_AS_IN_ALT0,\n\tSTR_AS_IN_ALT1,\n};\n\nstatic struct usb_string strings_fn[] = {\n\t \n\t[STR_IF_CTRL].s = \"Topology Control\",\n\t[STR_CLKSRC_IN].s = \"Input Clock\",\n\t[STR_CLKSRC_OUT].s = \"Output Clock\",\n\t[STR_USB_IT].s = \"USBH Out\",\n\t[STR_IO_IT].s = \"USBD Out\",\n\t[STR_USB_OT].s = \"USBH In\",\n\t[STR_IO_OT].s = \"USBD In\",\n\t[STR_FU_IN].s = \"Capture Volume\",\n\t[STR_FU_OUT].s = \"Playback Volume\",\n\t[STR_AS_OUT_ALT0].s = \"Playback Inactive\",\n\t[STR_AS_OUT_ALT1].s = \"Playback Active\",\n\t[STR_AS_IN_ALT0].s = \"Capture Inactive\",\n\t[STR_AS_IN_ALT1].s = \"Capture Active\",\n\t{ },\n};\n\nstatic const char *const speed_names[] = {\n\t[USB_SPEED_UNKNOWN] = \"UNKNOWN\",\n\t[USB_SPEED_LOW] = \"LS\",\n\t[USB_SPEED_FULL] = \"FS\",\n\t[USB_SPEED_HIGH] = \"HS\",\n\t[USB_SPEED_WIRELESS] = \"W\",\n\t[USB_SPEED_SUPER] = \"SS\",\n\t[USB_SPEED_SUPER_PLUS] = \"SS+\",\n};\n\nstatic struct usb_gadget_strings str_fn = {\n\t.language = 0x0409,\t \n\t.strings = strings_fn,\n};\n\nstatic struct usb_gadget_strings *fn_strings[] = {\n\t&str_fn,\n\tNULL,\n};\n\nstatic struct usb_interface_assoc_descriptor iad_desc = {\n\t.bLength = sizeof iad_desc,\n\t.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,\n\n\t.bFirstInterface = 0,\n\t.bInterfaceCount = 3,\n\t.bFunctionClass = USB_CLASS_AUDIO,\n\t.bFunctionSubClass = UAC2_FUNCTION_SUBCLASS_UNDEFINED,\n\t.bFunctionProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct usb_interface_descriptor std_ac_if_desc = {\n\t.bLength = sizeof std_ac_if_desc,\n\t.bDescriptorType = USB_DT_INTERFACE,\n\n\t.bAlternateSetting = 0,\n\t \n\t.bInterfaceClass = USB_CLASS_AUDIO,\n\t.bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL,\n\t.bInterfaceProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct uac_clock_source_descriptor in_clk_src_desc = {\n\t.bLength = sizeof in_clk_src_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC2_CLOCK_SOURCE,\n\t \n\t.bmAttributes = UAC_CLOCK_SOURCE_TYPE_INT_FIXED,\n\t.bmControls = (CONTROL_RDWR << CLK_FREQ_CTRL),\n\t.bAssocTerminal = 0,\n};\n\n \nstatic struct uac_clock_source_descriptor out_clk_src_desc = {\n\t.bLength = sizeof out_clk_src_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC2_CLOCK_SOURCE,\n\t \n\t.bmAttributes = UAC_CLOCK_SOURCE_TYPE_INT_FIXED,\n\t.bmControls = (CONTROL_RDWR << CLK_FREQ_CTRL),\n\t.bAssocTerminal = 0,\n};\n\n \nstatic struct uac2_input_terminal_descriptor usb_out_it_desc = {\n\t.bLength = sizeof usb_out_it_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_INPUT_TERMINAL,\n\t \n\t.wTerminalType = cpu_to_le16(UAC_TERMINAL_STREAMING),\n\t.bAssocTerminal = 0,\n\t \n\t.iChannelNames = 0,\n\t.bmControls = cpu_to_le16(CONTROL_RDWR << COPY_CTRL),\n};\n\n \nstatic struct uac2_input_terminal_descriptor io_in_it_desc = {\n\t.bLength = sizeof io_in_it_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_INPUT_TERMINAL,\n\t \n\t.wTerminalType = cpu_to_le16(UAC_INPUT_TERMINAL_MICROPHONE),\n\t.bAssocTerminal = 0,\n\t \n\t.iChannelNames = 0,\n\t.bmControls = cpu_to_le16(CONTROL_RDWR << COPY_CTRL),\n};\n\n \nstatic struct uac2_output_terminal_descriptor usb_in_ot_desc = {\n\t.bLength = sizeof usb_in_ot_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_OUTPUT_TERMINAL,\n\t \n\t.wTerminalType = cpu_to_le16(UAC_TERMINAL_STREAMING),\n\t.bAssocTerminal = 0,\n\t \n\t \n\t.bmControls = cpu_to_le16(CONTROL_RDWR << COPY_CTRL),\n};\n\n \nstatic struct uac2_output_terminal_descriptor io_out_ot_desc = {\n\t.bLength = sizeof io_out_ot_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_OUTPUT_TERMINAL,\n\t \n\t.wTerminalType = cpu_to_le16(UAC_OUTPUT_TERMINAL_SPEAKER),\n\t.bAssocTerminal = 0,\n\t \n\t \n\t.bmControls = cpu_to_le16(CONTROL_RDWR << COPY_CTRL),\n};\n\nstatic struct uac2_feature_unit_descriptor *in_feature_unit_desc;\nstatic struct uac2_feature_unit_descriptor *out_feature_unit_desc;\n\nstatic struct uac2_ac_header_descriptor ac_hdr_desc = {\n\t.bLength = sizeof ac_hdr_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_MS_HEADER,\n\t.bcdADC = cpu_to_le16(0x200),\n\t.bCategory = UAC2_FUNCTION_IO_BOX,\n\t \n\t.bmControls = 0,\n};\n\n \nstatic struct usb_endpoint_descriptor fs_ep_int_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize = cpu_to_le16(6),\n\t.bInterval = 1,\n};\n\nstatic struct usb_endpoint_descriptor hs_ep_int_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bmAttributes = USB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize = cpu_to_le16(6),\n\t.bInterval = 4,\n};\n\nstatic struct usb_endpoint_descriptor ss_ep_int_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize = cpu_to_le16(6),\n\t.bInterval = 4,\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ep_int_desc_comp = {\n\t.bLength = sizeof(ss_ep_int_desc_comp),\n\t.bDescriptorType = USB_DT_SS_ENDPOINT_COMP,\n\t.wBytesPerInterval = cpu_to_le16(6),\n};\n\n \nstatic struct usb_interface_descriptor std_as_out_if0_desc = {\n\t.bLength = sizeof std_as_out_if0_desc,\n\t.bDescriptorType = USB_DT_INTERFACE,\n\n\t.bAlternateSetting = 0,\n\t.bNumEndpoints = 0,\n\t.bInterfaceClass = USB_CLASS_AUDIO,\n\t.bInterfaceSubClass = USB_SUBCLASS_AUDIOSTREAMING,\n\t.bInterfaceProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct usb_interface_descriptor std_as_out_if1_desc = {\n\t.bLength = sizeof std_as_out_if1_desc,\n\t.bDescriptorType = USB_DT_INTERFACE,\n\n\t.bAlternateSetting = 1,\n\t.bNumEndpoints = 1,\n\t.bInterfaceClass = USB_CLASS_AUDIO,\n\t.bInterfaceSubClass = USB_SUBCLASS_AUDIOSTREAMING,\n\t.bInterfaceProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct uac2_as_header_descriptor as_out_hdr_desc = {\n\t.bLength = sizeof as_out_hdr_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_AS_GENERAL,\n\t \n\t.bmControls = 0,\n\t.bFormatType = UAC_FORMAT_TYPE_I,\n\t.bmFormats = cpu_to_le32(UAC_FORMAT_TYPE_I_PCM),\n\t.iChannelNames = 0,\n};\n\n \nstatic struct uac2_format_type_i_descriptor as_out_fmt1_desc = {\n\t.bLength = sizeof as_out_fmt1_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype = UAC_FORMAT_TYPE,\n\t.bFormatType = UAC_FORMAT_TYPE_I,\n};\n\n \nstatic struct usb_endpoint_descriptor fs_epout_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_OUT,\n\t \n\t \n\t.bInterval = 1,\n};\n\nstatic struct usb_endpoint_descriptor hs_epout_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t \n\t \n\t \n};\n\nstatic struct usb_endpoint_descriptor ss_epout_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_OUT,\n\t \n\t \n\t \n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_epout_desc_comp = {\n\t.bLength\t\t= sizeof(ss_epout_desc_comp),\n\t.bDescriptorType\t= USB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst\t\t= 0,\n\t.bmAttributes\t\t= 0,\n\t \n};\n\n \nstatic struct uac2_iso_endpoint_descriptor as_iso_out_desc = {\n\t.bLength = sizeof as_iso_out_desc,\n\t.bDescriptorType = USB_DT_CS_ENDPOINT,\n\n\t.bDescriptorSubtype = UAC_EP_GENERAL,\n\t.bmAttributes = 0,\n\t.bmControls = 0,\n\t.bLockDelayUnits = 0,\n\t.wLockDelay = 0,\n};\n\n \nstatic struct usb_endpoint_descriptor fs_epin_fback_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_USAGE_FEEDBACK,\n\t.wMaxPacketSize = cpu_to_le16(3),\n\t.bInterval = 1,\n};\n\nstatic struct usb_endpoint_descriptor hs_epin_fback_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_USAGE_FEEDBACK,\n\t.wMaxPacketSize = cpu_to_le16(4),\n\t.bInterval = 4,\n};\n\nstatic struct usb_endpoint_descriptor ss_epin_fback_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_USAGE_FEEDBACK,\n\t.wMaxPacketSize = cpu_to_le16(4),\n\t.bInterval = 4,\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_epin_fback_desc_comp = {\n\t.bLength\t\t= sizeof(ss_epin_fback_desc_comp),\n\t.bDescriptorType\t= USB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst\t\t= 0,\n\t.bmAttributes\t\t= 0,\n\t.wBytesPerInterval\t= cpu_to_le16(4),\n};\n\n\n \nstatic struct usb_interface_descriptor std_as_in_if0_desc = {\n\t.bLength = sizeof std_as_in_if0_desc,\n\t.bDescriptorType = USB_DT_INTERFACE,\n\n\t.bAlternateSetting = 0,\n\t.bNumEndpoints = 0,\n\t.bInterfaceClass = USB_CLASS_AUDIO,\n\t.bInterfaceSubClass = USB_SUBCLASS_AUDIOSTREAMING,\n\t.bInterfaceProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct usb_interface_descriptor std_as_in_if1_desc = {\n\t.bLength = sizeof std_as_in_if1_desc,\n\t.bDescriptorType = USB_DT_INTERFACE,\n\n\t.bAlternateSetting = 1,\n\t.bNumEndpoints = 1,\n\t.bInterfaceClass = USB_CLASS_AUDIO,\n\t.bInterfaceSubClass = USB_SUBCLASS_AUDIOSTREAMING,\n\t.bInterfaceProtocol = UAC_VERSION_2,\n};\n\n \nstatic struct uac2_as_header_descriptor as_in_hdr_desc = {\n\t.bLength = sizeof as_in_hdr_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\n\t.bDescriptorSubtype = UAC_AS_GENERAL,\n\t \n\t.bmControls = 0,\n\t.bFormatType = UAC_FORMAT_TYPE_I,\n\t.bmFormats = cpu_to_le32(UAC_FORMAT_TYPE_I_PCM),\n\t.iChannelNames = 0,\n};\n\n \nstatic struct uac2_format_type_i_descriptor as_in_fmt1_desc = {\n\t.bLength = sizeof as_in_fmt1_desc,\n\t.bDescriptorType = USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype = UAC_FORMAT_TYPE,\n\t.bFormatType = UAC_FORMAT_TYPE_I,\n};\n\n \nstatic struct usb_endpoint_descriptor fs_epin_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,\n\t \n\t.bInterval = 1,\n};\n\nstatic struct usb_endpoint_descriptor hs_epin_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,\n\t \n\t \n};\n\nstatic struct usb_endpoint_descriptor ss_epin_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,\n\t \n\t \n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_epin_desc_comp = {\n\t.bLength\t\t= sizeof(ss_epin_desc_comp),\n\t.bDescriptorType\t= USB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst\t\t= 0,\n\t.bmAttributes\t\t= 0,\n\t \n};\n\n \nstatic struct uac2_iso_endpoint_descriptor as_iso_in_desc = {\n\t.bLength = sizeof as_iso_in_desc,\n\t.bDescriptorType = USB_DT_CS_ENDPOINT,\n\n\t.bDescriptorSubtype = UAC_EP_GENERAL,\n\t.bmAttributes = 0,\n\t.bmControls = 0,\n\t.bLockDelayUnits = 0,\n\t.wLockDelay = 0,\n};\n\nstatic struct usb_descriptor_header *fs_audio_desc[] = {\n\t(struct usb_descriptor_header *)&iad_desc,\n\t(struct usb_descriptor_header *)&std_ac_if_desc,\n\n\t(struct usb_descriptor_header *)&ac_hdr_desc,\n\t(struct usb_descriptor_header *)&in_clk_src_desc,\n\t(struct usb_descriptor_header *)&out_clk_src_desc,\n\t(struct usb_descriptor_header *)&usb_out_it_desc,\n\t(struct usb_descriptor_header *)&out_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_in_it_desc,\n\t(struct usb_descriptor_header *)&usb_in_ot_desc,\n\t(struct usb_descriptor_header *)&in_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_out_ot_desc,\n\n\t(struct usb_descriptor_header *)&fs_ep_int_desc,\n\n\t(struct usb_descriptor_header *)&std_as_out_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_out_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_out_hdr_desc,\n\t(struct usb_descriptor_header *)&as_out_fmt1_desc,\n\t(struct usb_descriptor_header *)&fs_epout_desc,\n\t(struct usb_descriptor_header *)&as_iso_out_desc,\n\t(struct usb_descriptor_header *)&fs_epin_fback_desc,\n\n\t(struct usb_descriptor_header *)&std_as_in_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_in_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_in_hdr_desc,\n\t(struct usb_descriptor_header *)&as_in_fmt1_desc,\n\t(struct usb_descriptor_header *)&fs_epin_desc,\n\t(struct usb_descriptor_header *)&as_iso_in_desc,\n\tNULL,\n};\n\nstatic struct usb_descriptor_header *hs_audio_desc[] = {\n\t(struct usb_descriptor_header *)&iad_desc,\n\t(struct usb_descriptor_header *)&std_ac_if_desc,\n\n\t(struct usb_descriptor_header *)&ac_hdr_desc,\n\t(struct usb_descriptor_header *)&in_clk_src_desc,\n\t(struct usb_descriptor_header *)&out_clk_src_desc,\n\t(struct usb_descriptor_header *)&usb_out_it_desc,\n\t(struct usb_descriptor_header *)&out_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_in_it_desc,\n\t(struct usb_descriptor_header *)&usb_in_ot_desc,\n\t(struct usb_descriptor_header *)&in_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_out_ot_desc,\n\n\t(struct usb_descriptor_header *)&hs_ep_int_desc,\n\n\t(struct usb_descriptor_header *)&std_as_out_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_out_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_out_hdr_desc,\n\t(struct usb_descriptor_header *)&as_out_fmt1_desc,\n\t(struct usb_descriptor_header *)&hs_epout_desc,\n\t(struct usb_descriptor_header *)&as_iso_out_desc,\n\t(struct usb_descriptor_header *)&hs_epin_fback_desc,\n\n\t(struct usb_descriptor_header *)&std_as_in_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_in_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_in_hdr_desc,\n\t(struct usb_descriptor_header *)&as_in_fmt1_desc,\n\t(struct usb_descriptor_header *)&hs_epin_desc,\n\t(struct usb_descriptor_header *)&as_iso_in_desc,\n\tNULL,\n};\n\nstatic struct usb_descriptor_header *ss_audio_desc[] = {\n\t(struct usb_descriptor_header *)&iad_desc,\n\t(struct usb_descriptor_header *)&std_ac_if_desc,\n\n\t(struct usb_descriptor_header *)&ac_hdr_desc,\n\t(struct usb_descriptor_header *)&in_clk_src_desc,\n\t(struct usb_descriptor_header *)&out_clk_src_desc,\n\t(struct usb_descriptor_header *)&usb_out_it_desc,\n  (struct usb_descriptor_header *)&out_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_in_it_desc,\n\t(struct usb_descriptor_header *)&usb_in_ot_desc,\n\t(struct usb_descriptor_header *)&in_feature_unit_desc,\n\t(struct usb_descriptor_header *)&io_out_ot_desc,\n\n\t(struct usb_descriptor_header *)&ss_ep_int_desc,\n\t(struct usb_descriptor_header *)&ss_ep_int_desc_comp,\n\n\t(struct usb_descriptor_header *)&std_as_out_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_out_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_out_hdr_desc,\n\t(struct usb_descriptor_header *)&as_out_fmt1_desc,\n\t(struct usb_descriptor_header *)&ss_epout_desc,\n\t(struct usb_descriptor_header *)&ss_epout_desc_comp,\n\t(struct usb_descriptor_header *)&as_iso_out_desc,\n\t(struct usb_descriptor_header *)&ss_epin_fback_desc,\n\t(struct usb_descriptor_header *)&ss_epin_fback_desc_comp,\n\n\t(struct usb_descriptor_header *)&std_as_in_if0_desc,\n\t(struct usb_descriptor_header *)&std_as_in_if1_desc,\n\n\t(struct usb_descriptor_header *)&as_in_hdr_desc,\n\t(struct usb_descriptor_header *)&as_in_fmt1_desc,\n\t(struct usb_descriptor_header *)&ss_epin_desc,\n\t(struct usb_descriptor_header *)&ss_epin_desc_comp,\n\t(struct usb_descriptor_header *)&as_iso_in_desc,\n\tNULL,\n};\n\nstruct cntrl_cur_lay2 {\n\t__le16\twCUR;\n};\n\nstruct cntrl_range_lay2 {\n\t__le16\twNumSubRanges;\n\t__le16\twMIN;\n\t__le16\twMAX;\n\t__le16\twRES;\n} __packed;\n\nstruct cntrl_cur_lay3 {\n\t__le32\tdCUR;\n};\n\nstruct cntrl_subrange_lay3 {\n\t__le32\tdMIN;\n\t__le32\tdMAX;\n\t__le32\tdRES;\n} __packed;\n\n#define ranges_lay3_size(c) (sizeof(c.wNumSubRanges)\t\\\n\t\t+ le16_to_cpu(c.wNumSubRanges)\t\t\\\n\t\t* sizeof(struct cntrl_subrange_lay3))\n\n#define DECLARE_UAC2_CNTRL_RANGES_LAY3(k, n)\t\t\\\n\tstruct cntrl_ranges_lay3_##k {\t\t\t\\\n\t__le16\twNumSubRanges;\t\t\t\t\\\n\tstruct cntrl_subrange_lay3 r[n];\t\t\\\n} __packed\n\nDECLARE_UAC2_CNTRL_RANGES_LAY3(srates, UAC_MAX_RATES);\n\nstatic int get_max_srate(const int *srates)\n{\n\tint i, max_srate = 0;\n\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (srates[i] == 0)\n\t\t\tbreak;\n\t\tif (srates[i] > max_srate)\n\t\t\tmax_srate = srates[i];\n\t}\n\treturn max_srate;\n}\n\nstatic int get_max_bw_for_bint(const struct f_uac2_opts *uac2_opts,\n\tu8 bint, unsigned int factor, bool is_playback)\n{\n\tint chmask, srate, ssize;\n\tu16 max_size_bw;\n\n\tif (is_playback) {\n\t\tchmask = uac2_opts->p_chmask;\n\t\tsrate = get_max_srate(uac2_opts->p_srates);\n\t\tssize = uac2_opts->p_ssize;\n\t} else {\n\t\tchmask = uac2_opts->c_chmask;\n\t\tsrate = get_max_srate(uac2_opts->c_srates);\n\t\tssize = uac2_opts->c_ssize;\n\t}\n\n\tif (is_playback || (uac2_opts->c_sync == USB_ENDPOINT_SYNC_ASYNC)) {\n\t\t\n\t\t\n\t\tsrate = srate * (1000 + uac2_opts->fb_max) / 1000;\n\t\t\n\t\tmax_size_bw = num_channels(chmask) * ssize *\n\t\t\t(DIV_ROUND_UP(srate, factor / (1 << (bint - 1))));\n\t} else {\n\t\t\n\t\tmax_size_bw = num_channels(chmask) * ssize *\n\t\t\t(DIV_ROUND_UP(srate, factor / (1 << (bint - 1))) + 1);\n\t}\n\treturn max_size_bw;\n}\n\nstatic int set_ep_max_packet_size_bint(struct device *dev, const struct f_uac2_opts *uac2_opts,\n\tstruct usb_endpoint_descriptor *ep_desc,\n\tenum usb_device_speed speed, bool is_playback)\n{\n\tu16 max_size_bw, max_size_ep;\n\tu8 bint, opts_bint;\n\tchar *dir;\n\n\tswitch (speed) {\n\tcase USB_SPEED_FULL:\n\t\tmax_size_ep = 1023;\n\t\t\n\t\tbint = ep_desc->bInterval;\n\t\tmax_size_bw = get_max_bw_for_bint(uac2_opts, bint, 1000, is_playback);\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tmax_size_ep = 1024;\n\t\tif (is_playback)\n\t\t\topts_bint = uac2_opts->p_hs_bint;\n\t\telse\n\t\t\topts_bint = uac2_opts->c_hs_bint;\n\n\t\tif (opts_bint > 0) {\n\t\t\t \n\t\t\tbint = opts_bint;\n\t\t\tmax_size_bw = get_max_bw_for_bint(uac2_opts, bint, 8000, is_playback);\n\t\t} else {\n\t\t\t \n\t\t\tfor (bint = 4; bint > 0; --bint) {\n\t\t\t\tmax_size_bw = get_max_bw_for_bint(\n\t\t\t\t\tuac2_opts, bint, 8000, is_playback);\n\t\t\t\tif (max_size_bw <= max_size_ep)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_playback)\n\t\tdir = \"Playback\";\n\telse\n\t\tdir = \"Capture\";\n\n\tif (max_size_bw <= max_size_ep)\n\t\tdev_dbg(dev,\n\t\t\t\"%s %s: Would use wMaxPacketSize %d and bInterval %d\\n\",\n\t\t\tspeed_names[speed], dir, max_size_bw, bint);\n\telse {\n\t\tdev_warn(dev,\n\t\t\t\"%s %s: Req. wMaxPacketSize %d at bInterval %d > max ISOC %d, may drop data!\\n\",\n\t\t\tspeed_names[speed], dir, max_size_bw, bint, max_size_ep);\n\t\tmax_size_bw = max_size_ep;\n\t}\n\n\tep_desc->wMaxPacketSize = cpu_to_le16(max_size_bw);\n\tep_desc->bInterval = bint;\n\n\treturn 0;\n}\n\nstatic struct uac2_feature_unit_descriptor *build_fu_desc(int chmask)\n{\n\tstruct uac2_feature_unit_descriptor *fu_desc;\n\tint channels = num_channels(chmask);\n\tint fu_desc_size = UAC2_DT_FEATURE_UNIT_SIZE(channels);\n\n\tfu_desc = kzalloc(fu_desc_size, GFP_KERNEL);\n\tif (!fu_desc)\n\t\treturn NULL;\n\n\tfu_desc->bLength = fu_desc_size;\n\tfu_desc->bDescriptorType = USB_DT_CS_INTERFACE;\n\n\tfu_desc->bDescriptorSubtype = UAC_FEATURE_UNIT;\n\n\t \n\n\treturn fu_desc;\n}\n\n \n#define USBDHDR(p) (struct usb_descriptor_header *)(p)\n\nstatic void setup_headers(struct f_uac2_opts *opts,\n\t\t\t  struct usb_descriptor_header **headers,\n\t\t\t  enum usb_device_speed speed)\n{\n\tstruct usb_ss_ep_comp_descriptor *epout_desc_comp = NULL;\n\tstruct usb_ss_ep_comp_descriptor *epin_desc_comp = NULL;\n\tstruct usb_ss_ep_comp_descriptor *epin_fback_desc_comp = NULL;\n\tstruct usb_ss_ep_comp_descriptor *ep_int_desc_comp = NULL;\n\tstruct usb_endpoint_descriptor *epout_desc;\n\tstruct usb_endpoint_descriptor *epin_desc;\n\tstruct usb_endpoint_descriptor *epin_fback_desc;\n\tstruct usb_endpoint_descriptor *ep_int_desc;\n\tint i;\n\n\tswitch (speed) {\n\tcase USB_SPEED_FULL:\n\t\tepout_desc = &fs_epout_desc;\n\t\tepin_desc = &fs_epin_desc;\n\t\tepin_fback_desc = &fs_epin_fback_desc;\n\t\tep_int_desc = &fs_ep_int_desc;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tepout_desc = &hs_epout_desc;\n\t\tepin_desc = &hs_epin_desc;\n\t\tepin_fback_desc = &hs_epin_fback_desc;\n\t\tep_int_desc = &hs_ep_int_desc;\n\t\tbreak;\n\tdefault:\n\t\tepout_desc = &ss_epout_desc;\n\t\tepin_desc = &ss_epin_desc;\n\t\tepout_desc_comp = &ss_epout_desc_comp;\n\t\tepin_desc_comp = &ss_epin_desc_comp;\n\t\tepin_fback_desc = &ss_epin_fback_desc;\n\t\tepin_fback_desc_comp = &ss_epin_fback_desc_comp;\n\t\tep_int_desc = &ss_ep_int_desc;\n\t\tep_int_desc_comp = &ss_ep_int_desc_comp;\n\t}\n\n\ti = 0;\n\theaders[i++] = USBDHDR(&iad_desc);\n\theaders[i++] = USBDHDR(&std_ac_if_desc);\n\theaders[i++] = USBDHDR(&ac_hdr_desc);\n\tif (EPIN_EN(opts))\n\t\theaders[i++] = USBDHDR(&in_clk_src_desc);\n\tif (EPOUT_EN(opts)) {\n\t\theaders[i++] = USBDHDR(&out_clk_src_desc);\n\t\theaders[i++] = USBDHDR(&usb_out_it_desc);\n\n\t\tif (FUOUT_EN(opts))\n\t\t\theaders[i++] = USBDHDR(out_feature_unit_desc);\n\t}\n\n\tif (EPIN_EN(opts)) {\n\t\theaders[i++] = USBDHDR(&io_in_it_desc);\n\n\t\tif (FUIN_EN(opts))\n\t\t\theaders[i++] = USBDHDR(in_feature_unit_desc);\n\n\t\theaders[i++] = USBDHDR(&usb_in_ot_desc);\n\t}\n\n\tif (EPOUT_EN(opts))\n\t\theaders[i++] = USBDHDR(&io_out_ot_desc);\n\n\tif (FUOUT_EN(opts) || FUIN_EN(opts)) {\n\t\theaders[i++] = USBDHDR(ep_int_desc);\n\t\tif (ep_int_desc_comp)\n\t\t\theaders[i++] = USBDHDR(ep_int_desc_comp);\n\t}\n\n\tif (EPOUT_EN(opts)) {\n\t\theaders[i++] = USBDHDR(&std_as_out_if0_desc);\n\t\theaders[i++] = USBDHDR(&std_as_out_if1_desc);\n\t\theaders[i++] = USBDHDR(&as_out_hdr_desc);\n\t\theaders[i++] = USBDHDR(&as_out_fmt1_desc);\n\t\theaders[i++] = USBDHDR(epout_desc);\n\t\tif (epout_desc_comp)\n\t\t\theaders[i++] = USBDHDR(epout_desc_comp);\n\n\t\theaders[i++] = USBDHDR(&as_iso_out_desc);\n\n\t\tif (EPOUT_FBACK_IN_EN(opts)) {\n\t\t\theaders[i++] = USBDHDR(epin_fback_desc);\n\t\t\tif (epin_fback_desc_comp)\n\t\t\t\theaders[i++] = USBDHDR(epin_fback_desc_comp);\n\t\t}\n\t}\n\n\tif (EPIN_EN(opts)) {\n\t\theaders[i++] = USBDHDR(&std_as_in_if0_desc);\n\t\theaders[i++] = USBDHDR(&std_as_in_if1_desc);\n\t\theaders[i++] = USBDHDR(&as_in_hdr_desc);\n\t\theaders[i++] = USBDHDR(&as_in_fmt1_desc);\n\t\theaders[i++] = USBDHDR(epin_desc);\n\t\tif (epin_desc_comp)\n\t\t\theaders[i++] = USBDHDR(epin_desc_comp);\n\n\t\theaders[i++] = USBDHDR(&as_iso_in_desc);\n\t}\n\theaders[i] = NULL;\n}\n\nstatic void setup_descriptor(struct f_uac2_opts *opts)\n{\n\t \n\tint i = 1;  \n\n\tif (EPOUT_EN(opts))\n\t\tusb_out_it_desc.bTerminalID = i++;\n\tif (EPIN_EN(opts))\n\t\tio_in_it_desc.bTerminalID = i++;\n\tif (EPOUT_EN(opts))\n\t\tio_out_ot_desc.bTerminalID = i++;\n\tif (EPIN_EN(opts))\n\t\tusb_in_ot_desc.bTerminalID = i++;\n\tif (FUOUT_EN(opts))\n\t\tout_feature_unit_desc->bUnitID = i++;\n\tif (FUIN_EN(opts))\n\t\tin_feature_unit_desc->bUnitID = i++;\n\tif (EPOUT_EN(opts))\n\t\tout_clk_src_desc.bClockID = i++;\n\tif (EPIN_EN(opts))\n\t\tin_clk_src_desc.bClockID = i++;\n\n\tusb_out_it_desc.bCSourceID = out_clk_src_desc.bClockID;\n\n\tif (FUIN_EN(opts)) {\n\t\tusb_in_ot_desc.bSourceID = in_feature_unit_desc->bUnitID;\n\t\tin_feature_unit_desc->bSourceID = io_in_it_desc.bTerminalID;\n\t} else {\n\t\tusb_in_ot_desc.bSourceID = io_in_it_desc.bTerminalID;\n\t}\n\n\tusb_in_ot_desc.bCSourceID = in_clk_src_desc.bClockID;\n\tio_in_it_desc.bCSourceID = in_clk_src_desc.bClockID;\n\tio_out_ot_desc.bCSourceID = out_clk_src_desc.bClockID;\n\n\tif (FUOUT_EN(opts)) {\n\t\tio_out_ot_desc.bSourceID = out_feature_unit_desc->bUnitID;\n\t\tout_feature_unit_desc->bSourceID = usb_out_it_desc.bTerminalID;\n\t} else {\n\t\tio_out_ot_desc.bSourceID = usb_out_it_desc.bTerminalID;\n\t}\n\n\tas_out_hdr_desc.bTerminalLink = usb_out_it_desc.bTerminalID;\n\tas_in_hdr_desc.bTerminalLink = usb_in_ot_desc.bTerminalID;\n\n\tiad_desc.bInterfaceCount = 1;\n\tac_hdr_desc.wTotalLength = cpu_to_le16(sizeof(ac_hdr_desc));\n\n\tif (EPIN_EN(opts)) {\n\t\tu16 len = le16_to_cpu(ac_hdr_desc.wTotalLength);\n\n\t\tlen += sizeof(in_clk_src_desc);\n\t\tlen += sizeof(usb_in_ot_desc);\n\n\t\tif (FUIN_EN(opts))\n\t\t\tlen += in_feature_unit_desc->bLength;\n\n\t\tlen += sizeof(io_in_it_desc);\n\t\tac_hdr_desc.wTotalLength = cpu_to_le16(len);\n\t\tiad_desc.bInterfaceCount++;\n\t}\n\tif (EPOUT_EN(opts)) {\n\t\tu16 len = le16_to_cpu(ac_hdr_desc.wTotalLength);\n\n\t\tlen += sizeof(out_clk_src_desc);\n\t\tlen += sizeof(usb_out_it_desc);\n\n\t\tif (FUOUT_EN(opts))\n\t\t\tlen += out_feature_unit_desc->bLength;\n\n\t\tlen += sizeof(io_out_ot_desc);\n\t\tac_hdr_desc.wTotalLength = cpu_to_le16(len);\n\t\tiad_desc.bInterfaceCount++;\n\t}\n\n\tsetup_headers(opts, fs_audio_desc, USB_SPEED_FULL);\n\tsetup_headers(opts, hs_audio_desc, USB_SPEED_HIGH);\n\tsetup_headers(opts, ss_audio_desc, USB_SPEED_SUPER);\n}\n\nstatic int afunc_validate_opts(struct g_audio *agdev, struct device *dev)\n{\n\tstruct f_uac2_opts *opts = g_audio_to_uac2_opts(agdev);\n\tconst char *msg = NULL;\n\n\tif (!opts->p_chmask && !opts->c_chmask)\n\t\tmsg = \"no playback and capture channels\";\n\telse if (opts->p_chmask & ~UAC2_CHANNEL_MASK)\n\t\tmsg = \"unsupported playback channels mask\";\n\telse if (opts->c_chmask & ~UAC2_CHANNEL_MASK)\n\t\tmsg = \"unsupported capture channels mask\";\n\telse if ((opts->p_ssize < 1) || (opts->p_ssize > 4))\n\t\tmsg = \"incorrect playback sample size\";\n\telse if ((opts->c_ssize < 1) || (opts->c_ssize > 4))\n\t\tmsg = \"incorrect capture sample size\";\n\telse if (!opts->p_srates[0])\n\t\tmsg = \"incorrect playback sampling rate\";\n\telse if (!opts->c_srates[0])\n\t\tmsg = \"incorrect capture sampling rate\";\n\n\telse if (opts->p_volume_max <= opts->p_volume_min)\n\t\tmsg = \"incorrect playback volume max/min\";\n\telse if (opts->c_volume_max <= opts->c_volume_min)\n\t\tmsg = \"incorrect capture volume max/min\";\n\telse if (opts->p_volume_res <= 0)\n\t\tmsg = \"negative/zero playback volume resolution\";\n\telse if (opts->c_volume_res <= 0)\n\t\tmsg = \"negative/zero capture volume resolution\";\n\n\telse if ((opts->p_volume_max - opts->p_volume_min) % opts->p_volume_res)\n\t\tmsg = \"incorrect playback volume resolution\";\n\telse if ((opts->c_volume_max - opts->c_volume_min) % opts->c_volume_res)\n\t\tmsg = \"incorrect capture volume resolution\";\n\n\telse if ((opts->p_hs_bint < 0) || (opts->p_hs_bint > 4))\n\t\tmsg = \"incorrect playback HS/SS bInterval (1-4: fixed, 0: auto)\";\n\telse if ((opts->c_hs_bint < 0) || (opts->c_hs_bint > 4))\n\t\tmsg = \"incorrect capture HS/SS bInterval (1-4: fixed, 0: auto)\";\n\n\tif (msg) {\n\t\tdev_err(dev, \"Error: %s\\n\", msg);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nafunc_bind(struct usb_configuration *cfg, struct usb_function *fn)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct usb_composite_dev *cdev = cfg->cdev;\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tstruct f_uac2_opts *uac2_opts = g_audio_to_uac2_opts(agdev);\n\tstruct usb_string *us;\n\tint ret;\n\n\tret = afunc_validate_opts(agdev, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tstrings_fn[STR_ASSOC].s = uac2_opts->function_name;\n\n\tus = usb_gstrings_attach(cdev, fn_strings, ARRAY_SIZE(strings_fn));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\n\tif (FUOUT_EN(uac2_opts)) {\n\t\tout_feature_unit_desc = build_fu_desc(uac2_opts->c_chmask);\n\t\tif (!out_feature_unit_desc)\n\t\t\treturn -ENOMEM;\n\t}\n\tif (FUIN_EN(uac2_opts)) {\n\t\tin_feature_unit_desc = build_fu_desc(uac2_opts->p_chmask);\n\t\tif (!in_feature_unit_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_fu;\n\t\t}\n\t}\n\n\tiad_desc.iFunction = us[STR_ASSOC].id;\n\tstd_ac_if_desc.iInterface = us[STR_IF_CTRL].id;\n\tin_clk_src_desc.iClockSource = us[STR_CLKSRC_IN].id;\n\tout_clk_src_desc.iClockSource = us[STR_CLKSRC_OUT].id;\n\tusb_out_it_desc.iTerminal = us[STR_USB_IT].id;\n\tio_in_it_desc.iTerminal = us[STR_IO_IT].id;\n\tusb_in_ot_desc.iTerminal = us[STR_USB_OT].id;\n\tio_out_ot_desc.iTerminal = us[STR_IO_OT].id;\n\tstd_as_out_if0_desc.iInterface = us[STR_AS_OUT_ALT0].id;\n\tstd_as_out_if1_desc.iInterface = us[STR_AS_OUT_ALT1].id;\n\tstd_as_in_if0_desc.iInterface = us[STR_AS_IN_ALT0].id;\n\tstd_as_in_if1_desc.iInterface = us[STR_AS_IN_ALT1].id;\n\n\tif (FUOUT_EN(uac2_opts)) {\n\t\tu8 *i_feature = (u8 *)out_feature_unit_desc +\n\t\t\t\tout_feature_unit_desc->bLength - 1;\n\t\t*i_feature = us[STR_FU_OUT].id;\n\t}\n\tif (FUIN_EN(uac2_opts)) {\n\t\tu8 *i_feature = (u8 *)in_feature_unit_desc +\n\t\t\t\tin_feature_unit_desc->bLength - 1;\n\t\t*i_feature = us[STR_FU_IN].id;\n\t}\n\n\n\t \n\tusb_out_it_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\n\tusb_out_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\n\tio_in_it_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\n\tio_in_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\n\tas_out_hdr_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\n\tas_out_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\n\tas_in_hdr_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\n\tas_in_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\n\tas_out_fmt1_desc.bSubslotSize = uac2_opts->c_ssize;\n\tas_out_fmt1_desc.bBitResolution = uac2_opts->c_ssize * 8;\n\tas_in_fmt1_desc.bSubslotSize = uac2_opts->p_ssize;\n\tas_in_fmt1_desc.bBitResolution = uac2_opts->p_ssize * 8;\n\tif (FUOUT_EN(uac2_opts)) {\n\t\t__le32 *bma = (__le32 *)&out_feature_unit_desc->bmaControls[0];\n\t\tu32 control = 0;\n\n\t\tif (uac2_opts->c_mute_present)\n\t\t\tcontrol |= CONTROL_RDWR << FU_MUTE_CTRL;\n\t\tif (uac2_opts->c_volume_present)\n\t\t\tcontrol |= CONTROL_RDWR << FU_VOL_CTRL;\n\t\t*bma = cpu_to_le32(control);\n\t}\n\tif (FUIN_EN(uac2_opts)) {\n\t\t__le32 *bma = (__le32 *)&in_feature_unit_desc->bmaControls[0];\n\t\tu32 control = 0;\n\n\t\tif (uac2_opts->p_mute_present)\n\t\t\tcontrol |= CONTROL_RDWR << FU_MUTE_CTRL;\n\t\tif (uac2_opts->p_volume_present)\n\t\t\tcontrol |= CONTROL_RDWR << FU_VOL_CTRL;\n\t\t*bma = cpu_to_le32(control);\n\t}\n\n\tret = usb_interface_id(cfg, fn);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\tgoto err_free_fu;\n\t}\n\tiad_desc.bFirstInterface = ret;\n\n\tstd_ac_if_desc.bInterfaceNumber = ret;\n\tuac2->ac_intf = ret;\n\tuac2->ac_alt = 0;\n\n\tif (EPOUT_EN(uac2_opts)) {\n\t\tret = usb_interface_id(cfg, fn);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\tgoto err_free_fu;\n\t\t}\n\t\tstd_as_out_if0_desc.bInterfaceNumber = ret;\n\t\tstd_as_out_if1_desc.bInterfaceNumber = ret;\n\t\tstd_as_out_if1_desc.bNumEndpoints = 1;\n\t\tuac2->as_out_intf = ret;\n\t\tuac2->as_out_alt = 0;\n\n\t\tif (EPOUT_FBACK_IN_EN(uac2_opts)) {\n\t\t\tfs_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC;\n\t\t\ths_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC;\n\t\t\tss_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC;\n\t\t\tstd_as_out_if1_desc.bNumEndpoints++;\n\t\t} else {\n\t\t\tfs_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE;\n\t\t\ths_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE;\n\t\t\tss_epout_desc.bmAttributes =\n\t\t\t  USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE;\n\t\t}\n\t}\n\n\tif (EPIN_EN(uac2_opts)) {\n\t\tret = usb_interface_id(cfg, fn);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\tgoto err_free_fu;\n\t\t}\n\t\tstd_as_in_if0_desc.bInterfaceNumber = ret;\n\t\tstd_as_in_if1_desc.bInterfaceNumber = ret;\n\t\tuac2->as_in_intf = ret;\n\t\tuac2->as_in_alt = 0;\n\t}\n\n\tif (FUOUT_EN(uac2_opts) || FUIN_EN(uac2_opts)) {\n\t\tuac2->int_ep = usb_ep_autoconfig(gadget, &fs_ep_int_desc);\n\t\tif (!uac2->int_ep) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_fu;\n\t\t}\n\n\t\tstd_ac_if_desc.bNumEndpoints = 1;\n\t}\n\n\ths_epin_desc.bInterval = uac2_opts->p_hs_bint;\n\tss_epin_desc.bInterval = uac2_opts->p_hs_bint;\n\ths_epout_desc.bInterval = uac2_opts->c_hs_bint;\n\tss_epout_desc.bInterval = uac2_opts->c_hs_bint;\n\n\t \n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &fs_epin_desc,\n\t\t\t\t\tUSB_SPEED_FULL, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &fs_epout_desc,\n\t\t\t\t\tUSB_SPEED_FULL, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &hs_epin_desc,\n\t\t\t\t\tUSB_SPEED_HIGH, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &hs_epout_desc,\n\t\t\t\t\tUSB_SPEED_HIGH, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &ss_epin_desc,\n\t\t\t\t\tUSB_SPEED_SUPER, true);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tret = set_ep_max_packet_size_bint(dev, uac2_opts, &ss_epout_desc,\n\t\t\t\t\tUSB_SPEED_SUPER, false);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn ret;\n\t}\n\n\tif (EPOUT_EN(uac2_opts)) {\n\t\tagdev->out_ep = usb_ep_autoconfig(gadget, &fs_epout_desc);\n\t\tif (!agdev->out_ep) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_fu;\n\t\t}\n\t\tif (EPOUT_FBACK_IN_EN(uac2_opts)) {\n\t\t\tagdev->in_ep_fback = usb_ep_autoconfig(gadget,\n\t\t\t\t\t\t       &fs_epin_fback_desc);\n\t\t\tif (!agdev->in_ep_fback) {\n\t\t\t\tdev_err(dev, \"%s:%d Error!\\n\",\n\t\t\t\t\t__func__, __LINE__);\n\t\t\t\tret = -ENODEV;\n\t\t\t\tgoto err_free_fu;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (EPIN_EN(uac2_opts)) {\n\t\tagdev->in_ep = usb_ep_autoconfig(gadget, &fs_epin_desc);\n\t\tif (!agdev->in_ep) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_free_fu;\n\t\t}\n\t}\n\n\tagdev->in_ep_maxpsize = max_t(u16,\n\t\t\t\tle16_to_cpu(fs_epin_desc.wMaxPacketSize),\n\t\t\t\tle16_to_cpu(hs_epin_desc.wMaxPacketSize));\n\tagdev->out_ep_maxpsize = max_t(u16,\n\t\t\t\tle16_to_cpu(fs_epout_desc.wMaxPacketSize),\n\t\t\t\tle16_to_cpu(hs_epout_desc.wMaxPacketSize));\n\n\tagdev->in_ep_maxpsize = max_t(u16, agdev->in_ep_maxpsize,\n\t\t\t\tle16_to_cpu(ss_epin_desc.wMaxPacketSize));\n\tagdev->out_ep_maxpsize = max_t(u16, agdev->out_ep_maxpsize,\n\t\t\t\tle16_to_cpu(ss_epout_desc.wMaxPacketSize));\n\n\tss_epin_desc_comp.wBytesPerInterval = ss_epin_desc.wMaxPacketSize;\n\tss_epout_desc_comp.wBytesPerInterval = ss_epout_desc.wMaxPacketSize;\n\n\t\n\ths_ep_int_desc.bEndpointAddress = fs_ep_int_desc.bEndpointAddress;\n\ths_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;\n\ths_epin_fback_desc.bEndpointAddress = fs_epin_fback_desc.bEndpointAddress;\n\ths_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;\n\tss_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;\n\tss_epin_fback_desc.bEndpointAddress = fs_epin_fback_desc.bEndpointAddress;\n\tss_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;\n\tss_ep_int_desc.bEndpointAddress = fs_ep_int_desc.bEndpointAddress;\n\n\tsetup_descriptor(uac2_opts);\n\n\tret = usb_assign_descriptors(fn, fs_audio_desc, hs_audio_desc, ss_audio_desc,\n\t\t\t\t     ss_audio_desc);\n\tif (ret)\n\t\tgoto err_free_fu;\n\n\tagdev->gadget = gadget;\n\n\tagdev->params.p_chmask = uac2_opts->p_chmask;\n\tmemcpy(agdev->params.p_srates, uac2_opts->p_srates,\n\t\t\tsizeof(agdev->params.p_srates));\n\tagdev->params.p_ssize = uac2_opts->p_ssize;\n\tif (FUIN_EN(uac2_opts)) {\n\t\tagdev->params.p_fu.id = USB_IN_FU_ID;\n\t\tagdev->params.p_fu.mute_present = uac2_opts->p_mute_present;\n\t\tagdev->params.p_fu.volume_present = uac2_opts->p_volume_present;\n\t\tagdev->params.p_fu.volume_min = uac2_opts->p_volume_min;\n\t\tagdev->params.p_fu.volume_max = uac2_opts->p_volume_max;\n\t\tagdev->params.p_fu.volume_res = uac2_opts->p_volume_res;\n\t}\n\tagdev->params.c_chmask = uac2_opts->c_chmask;\n\tmemcpy(agdev->params.c_srates, uac2_opts->c_srates,\n\t\t\tsizeof(agdev->params.c_srates));\n\tagdev->params.c_ssize = uac2_opts->c_ssize;\n\tif (FUOUT_EN(uac2_opts)) {\n\t\tagdev->params.c_fu.id = USB_OUT_FU_ID;\n\t\tagdev->params.c_fu.mute_present = uac2_opts->c_mute_present;\n\t\tagdev->params.c_fu.volume_present = uac2_opts->c_volume_present;\n\t\tagdev->params.c_fu.volume_min = uac2_opts->c_volume_min;\n\t\tagdev->params.c_fu.volume_max = uac2_opts->c_volume_max;\n\t\tagdev->params.c_fu.volume_res = uac2_opts->c_volume_res;\n\t}\n\tagdev->params.req_number = uac2_opts->req_number;\n\tagdev->params.fb_max = uac2_opts->fb_max;\n\n\tif (FUOUT_EN(uac2_opts) || FUIN_EN(uac2_opts))\n    agdev->notify = afunc_notify;\n\n\tret = g_audio_setup(agdev, \"UAC2 PCM\", \"UAC2_Gadget\");\n\tif (ret)\n\t\tgoto err_free_descs;\n\n\treturn 0;\n\nerr_free_descs:\n\tusb_free_all_descriptors(fn);\n\tagdev->gadget = NULL;\nerr_free_fu:\n\tkfree(out_feature_unit_desc);\n\tout_feature_unit_desc = NULL;\n\tkfree(in_feature_unit_desc);\n\tin_feature_unit_desc = NULL;\n\treturn ret;\n}\n\nstatic void\nafunc_notify_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tstruct g_audio *agdev = req->context;\n\tstruct f_uac2 *uac2 = func_to_uac2(&agdev->func);\n\n\tatomic_dec(&uac2->int_count);\n\tkfree(req->buf);\n\tusb_ep_free_request(_ep, req);\n}\n\nstatic int\nafunc_notify(struct g_audio *agdev, int unit_id, int cs)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(&agdev->func);\n\tstruct usb_request *req;\n\tstruct uac2_interrupt_data_msg *msg;\n\tu16 w_index, w_value;\n\tint ret;\n\n\tif (!uac2->int_ep->enabled)\n\t\treturn 0;\n\n\tif (atomic_inc_return(&uac2->int_count) > UAC2_DEF_INT_REQ_NUM) {\n\t\tatomic_dec(&uac2->int_count);\n\t\treturn 0;\n\t}\n\n\treq = usb_ep_alloc_request(uac2->int_ep, GFP_ATOMIC);\n\tif (req == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dec_int_count;\n\t}\n\n\tmsg = kzalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (msg == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_request;\n\t}\n\n\tw_index = unit_id << 8 | uac2->ac_intf;\n\tw_value = cs << 8;\n\n\tmsg->bInfo = 0;  \n\tmsg->bAttribute = UAC2_CS_CUR;\n\tmsg->wIndex = cpu_to_le16(w_index);\n\tmsg->wValue = cpu_to_le16(w_value);\n\n\treq->length = sizeof(*msg);\n\treq->buf = msg;\n\treq->context = agdev;\n\treq->complete = afunc_notify_complete;\n\n\tret = usb_ep_queue(uac2->int_ep, req, GFP_ATOMIC);\n\n\tif (ret)\n\t\tgoto err_free_msg;\n\n\treturn 0;\n\nerr_free_msg:\n\tkfree(msg);\nerr_free_request:\n\tusb_ep_free_request(uac2->int_ep, req);\nerr_dec_int_count:\n\tatomic_dec(&uac2->int_count);\n\n\treturn ret;\n}\n\nstatic int\nafunc_set_alt(struct usb_function *fn, unsigned intf, unsigned alt)\n{\n\tstruct usb_composite_dev *cdev = fn->config->cdev;\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tint ret = 0;\n\n\t \n\tif (alt > 1) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intf == uac2->ac_intf) {\n\t\t \n\t\tif (alt) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (uac2->int_ep) {\n\t\t\tusb_ep_disable(uac2->int_ep);\n\t\t\tconfig_ep_by_speed(gadget, &agdev->func, uac2->int_ep);\n\t\t\tusb_ep_enable(uac2->int_ep);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (intf == uac2->as_out_intf) {\n\t\tuac2->as_out_alt = alt;\n\n\t\tif (alt)\n\t\t\tret = u_audio_start_capture(&uac2->g_audio);\n\t\telse\n\t\t\tu_audio_stop_capture(&uac2->g_audio);\n\t} else if (intf == uac2->as_in_intf) {\n\t\tuac2->as_in_alt = alt;\n\n\t\tif (alt)\n\t\t\tret = u_audio_start_playback(&uac2->g_audio);\n\t\telse\n\t\t\tu_audio_stop_playback(&uac2->g_audio);\n\t} else {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int\nafunc_get_alt(struct usb_function *fn, unsigned intf)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\n\tif (intf == uac2->ac_intf)\n\t\treturn uac2->ac_alt;\n\telse if (intf == uac2->as_out_intf)\n\t\treturn uac2->as_out_alt;\n\telse if (intf == uac2->as_in_intf)\n\t\treturn uac2->as_in_alt;\n\telse\n\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\"%s:%d Invalid Interface %d!\\n\",\n\t\t\t__func__, __LINE__, intf);\n\n\treturn -EINVAL;\n}\n\nstatic void\nafunc_disable(struct usb_function *fn)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\n\tuac2->as_in_alt = 0;\n\tuac2->as_out_alt = 0;\n\tu_audio_stop_capture(&uac2->g_audio);\n\tu_audio_stop_playback(&uac2->g_audio);\n\tif (uac2->int_ep)\n\t\tusb_ep_disable(uac2->int_ep);\n}\n\nstatic void\nafunc_suspend(struct usb_function *fn)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\n\tu_audio_suspend(&uac2->g_audio);\n}\n\nstatic int\nin_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct f_uac2_opts *opts = g_audio_to_uac2_opts(agdev);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\tu32 p_srate, c_srate;\n\n\tu_audio_get_playback_srate(agdev, &p_srate);\n\tu_audio_get_capture_srate(agdev, &c_srate);\n\n\tif ((entity_id == USB_IN_CLK_ID) || (entity_id == USB_OUT_CLK_ID)) {\n\t\tif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\n\t\t\tstruct cntrl_cur_lay3 c;\n\n\t\t\tmemset(&c, 0, sizeof(struct cntrl_cur_lay3));\n\n\t\t\tif (entity_id == USB_IN_CLK_ID)\n\t\t\t\tc.dCUR = cpu_to_le32(p_srate);\n\t\t\telse if (entity_id == USB_OUT_CLK_ID)\n\t\t\t\tc.dCUR = cpu_to_le32(c_srate);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(c));\n\t\t\tmemcpy(req->buf, &c, value);\n\t\t} else if (control_selector == UAC2_CS_CONTROL_CLOCK_VALID) {\n\t\t\t*(u8 *)req->buf = 1;\n\t\t\tvalue = min_t(unsigned int, w_length, 1);\n\t\t} else {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else if ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_MUTE) {\n\t\t\tunsigned int mute;\n\n\t\t\tu_audio_get_mute(agdev, is_playback, &mute);\n\n\t\t\t*(u8 *)req->buf = mute;\n\t\t\tvalue = min_t(unsigned int, w_length, 1);\n\t\t} else if (control_selector == UAC_FU_VOLUME) {\n\t\t\tstruct cntrl_cur_lay2 c;\n\t\t\ts16 volume;\n\n\t\t\tmemset(&c, 0, sizeof(struct cntrl_cur_lay2));\n\n\t\t\tu_audio_get_volume(agdev, is_playback, &volume);\n\t\t\tc.wCUR = cpu_to_le16(volume);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(c));\n\t\t\tmemcpy(req->buf, &c, value);\n\t\t} else {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic int\nin_rq_range(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct f_uac2_opts *opts = g_audio_to_uac2_opts(agdev);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\n\tif ((entity_id == USB_IN_CLK_ID) || (entity_id == USB_OUT_CLK_ID)) {\n\t\tif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\n\t\t\tstruct cntrl_ranges_lay3_srates rs;\n\t\t\tint i;\n\t\t\tint wNumSubRanges = 0;\n\t\t\tint srate;\n\t\t\tint *srates;\n\n\t\t\tif (entity_id == USB_IN_CLK_ID)\n\t\t\t\tsrates = opts->p_srates;\n\t\t\telse if (entity_id == USB_OUT_CLK_ID)\n\t\t\t\tsrates = opts->c_srates;\n\t\t\telse\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\t\t\tsrate = srates[i];\n\t\t\t\tif (srate == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\trs.r[wNumSubRanges].dMIN = cpu_to_le32(srate);\n\t\t\t\trs.r[wNumSubRanges].dMAX = cpu_to_le32(srate);\n\t\t\t\trs.r[wNumSubRanges].dRES = 0;\n\t\t\t\twNumSubRanges++;\n\t\t\t\tdev_dbg(&agdev->gadget->dev,\n\t\t\t\t\t\"%s(): clk %d: rate ID %d: %d\\n\",\n\t\t\t\t\t__func__, entity_id, wNumSubRanges, srate);\n\t\t\t}\n\t\t\trs.wNumSubRanges = cpu_to_le16(wNumSubRanges);\n\t\t\tvalue = min_t(unsigned int, w_length, ranges_lay3_size(rs));\n\t\t\tdev_dbg(&agdev->gadget->dev, \"%s(): sending %d rates, size %d\\n\",\n\t\t\t\t__func__, rs.wNumSubRanges, value);\n\t\t\tmemcpy(req->buf, &rs, value);\n\t\t} else {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else if ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_VOLUME) {\n\t\t\tstruct cntrl_range_lay2 r;\n\t\t\ts16 max_db, min_db, res_db;\n\n\t\t\tif (is_playback) {\n\t\t\t\tmax_db = opts->p_volume_max;\n\t\t\t\tmin_db = opts->p_volume_min;\n\t\t\t\tres_db = opts->p_volume_res;\n\t\t\t} else {\n\t\t\t\tmax_db = opts->c_volume_max;\n\t\t\t\tmin_db = opts->c_volume_min;\n\t\t\t\tres_db = opts->c_volume_res;\n\t\t\t}\n\n\t\t\tr.wMAX = cpu_to_le16(max_db);\n\t\t\tr.wMIN = cpu_to_le16(min_db);\n\t\t\tr.wRES = cpu_to_le16(res_db);\n\t\t\tr.wNumSubRanges = cpu_to_le16(1);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(r));\n\t\t\tmemcpy(req->buf, &r, value);\n\t\t} else {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic int\nac_rq_in(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tif (cr->bRequest == UAC2_CS_CUR)\n\t\treturn in_rq_cur(fn, cr);\n\telse if (cr->bRequest == UAC2_CS_RANGE)\n\t\treturn in_rq_range(fn, cr);\n\telse\n\t\treturn -EOPNOTSUPP;\n}\n\nstatic void uac2_cs_control_sam_freq(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_function *fn = ep->driver_data;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tu32 val;\n\n\tif (req->actual != 4)\n\t\treturn;\n\n\tval = le32_to_cpu(*((__le32 *)req->buf));\n\tdev_dbg(&agdev->gadget->dev, \"%s val: %d.\\n\", __func__, val);\n\tif (uac2->clock_id == USB_IN_CLK_ID) {\n\t\tu_audio_set_playback_srate(agdev, val);\n\t} else if (uac2->clock_id == USB_OUT_CLK_ID) {\n\t\tu_audio_set_capture_srate(agdev, val);\n\t}\n}\n\nstatic void\nout_rq_cur_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct g_audio *agdev = req->context;\n\tstruct usb_composite_dev *cdev = agdev->func.config->cdev;\n\tstruct f_uac2_opts *opts = g_audio_to_uac2_opts(agdev);\n\tstruct f_uac2 *uac2 = func_to_uac2(&agdev->func);\n\tstruct usb_ctrlrequest *cr = &uac2->setup_cr;\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\n\tif (req->status != 0) {\n\t\tdev_dbg(&cdev->gadget->dev, \"completion err %d\\n\", req->status);\n\t\treturn;\n\t}\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_MUTE) {\n\t\t\tu8 mute = *(u8 *)req->buf;\n\n\t\t\tu_audio_set_mute(agdev, is_playback, mute);\n\n\t\t\treturn;\n\t\t} else if (control_selector == UAC_FU_VOLUME) {\n\t\t\tstruct cntrl_cur_lay2 *c = req->buf;\n\t\t\ts16 volume;\n\n\t\t\tvolume = le16_to_cpu(c->wCUR);\n\t\t\tu_audio_set_volume(agdev, is_playback, volume);\n\n\t\t\treturn;\n\t\t} else {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t\tusb_ep_set_halt(ep);\n\t\t}\n\t}\n}\n\nstatic int\nout_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_composite_dev *cdev = fn->config->cdev;\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct f_uac2_opts *opts = g_audio_to_uac2_opts(agdev);\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tu8 clock_id = w_index >> 8;\n\n\tif ((entity_id == USB_IN_CLK_ID) || (entity_id == USB_OUT_CLK_ID)) {\n\t\tif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\n\t\t\tdev_dbg(&agdev->gadget->dev,\n\t\t\t\t\"control_selector UAC2_CS_CONTROL_SAM_FREQ, clock: %d\\n\", clock_id);\n\t\t\tcdev->gadget->ep0->driver_data = fn;\n\t\t\tuac2->clock_id = clock_id;\n\t\t\treq->complete = uac2_cs_control_sam_freq;\n\t\t\treturn w_length;\n\t\t}\n\t} else if ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tmemcpy(&uac2->setup_cr, cr, sizeof(*cr));\n\t\treq->context = agdev;\n\t\treq->complete = out_rq_cur_complete;\n\n\t\treturn w_length;\n\t} else {\n\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nsetup_rq_inf(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct f_uac2 *uac2 = func_to_uac2(fn);\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu8 intf = w_index & 0xff;\n\n\tif (intf != uac2->ac_intf) {\n\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (cr->bRequestType & USB_DIR_IN)\n\t\treturn ac_rq_in(fn, cr);\n\telse if (cr->bRequest == UAC2_CS_CUR)\n\t\treturn out_rq_cur(fn, cr);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int\nafunc_setup(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_composite_dev *cdev = fn->config->cdev;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct usb_request *req = cdev->req;\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tint value = -EOPNOTSUPP;\n\n\t \n\tif ((cr->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\n\t\treturn -EOPNOTSUPP;\n\n\tif ((cr->bRequestType & USB_RECIP_MASK) == USB_RECIP_INTERFACE)\n\t\tvalue = setup_rq_inf(fn, cr);\n\telse\n\t\tdev_err(&agdev->gadget->dev, \"%s:%d Error!\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\tif (value >= 0) {\n\t\treq->length = value;\n\t\treq->zero = value < w_length;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tdev_err(&agdev->gadget->dev,\n\t\t\t\t\"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\treq->status = 0;\n\t\t}\n\t}\n\n\treturn value;\n}\n\nstatic inline struct f_uac2_opts *to_f_uac2_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_uac2_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void f_uac2_attr_release(struct config_item *item)\n{\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations f_uac2_item_ops = {\n\t.release\t= f_uac2_attr_release,\n};\n\n#define uac2_kstrtou8 kstrtou8\n#define uac2_kstrtou32 kstrtou32\n#define uac2_kstrtos16 kstrtos16\n#define uac2_kstrtobool(s, base, res) kstrtobool((s), (res))\n\nstatic const char *u8_fmt = \"%u\\n\";\nstatic const char *u32_fmt = \"%u\\n\";\nstatic const char *s16_fmt = \"%hd\\n\";\nstatic const char *bool_fmt = \"%u\\n\";\n\n#define UAC2_ATTRIBUTE(type, name)\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, type##_fmt, opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\ttype num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = uac2_kstrto##type(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac2_opts_, name)\n\n#define UAC2_ATTRIBUTE_SYNC(name)\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\tchar *str;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tswitch (opts->name) {\t\t\t\t\t\t\\\n\tcase USB_ENDPOINT_SYNC_ASYNC:\t\t\t\t\t\\\n\t\tstr = \"async\";\t\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase USB_ENDPOINT_SYNC_ADAPTIVE:\t\t\t\t\\\n\t\tstr = \"adaptive\";\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tdefault:\t\t\t\t\t\t\t\\\n\t\tstr = \"unknown\";\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tresult = sprintf(page, \"%s\\n\", str);\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!strncmp(page, \"async\", 5))\t\t\t\t\t\\\n\t\topts->name = USB_ENDPOINT_SYNC_ASYNC;\t\t\t\\\n\telse if (!strncmp(page, \"adaptive\", 8))\t\t\t\t\\\n\t\topts->name = USB_ENDPOINT_SYNC_ADAPTIVE;\t\t\\\n\telse {\t\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac2_opts_, name)\n\n#define UAC2_RATE_ATTRIBUTE(name)\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint result = 0;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tpage[0] = '\\0';\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\t\t\t\t\\\n\t\tif (opts->name##s[i] == 0)\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tresult += sprintf(page + strlen(page), \"%u,\",\t\t\\\n\t\t\t\topts->name##s[i]);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (strlen(page) > 0)\t\t\t\t\t\t\\\n\t\tpage[strlen(page) - 1] = '\\n';\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tchar *split_page = NULL;\t\t\t\t\t\\\n\tint ret = -EINVAL;\t\t\t\t\t\t\\\n\tchar *token;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ti = 0;\t\t\t\t\t\t\t\t\\\n\tmemset(opts->name##s, 0x00, sizeof(opts->name##s));\t\t\\\n\tsplit_page = kstrdup(page, GFP_KERNEL);\t\t\t\t\\\n\twhile ((token = strsep(&split_page, \",\")) != NULL) {\t\t\\\n\t\tret = kstrtou32(token, 0, &num);\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\\\n\t\t\tgoto end;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\topts->name##s[i++] = num;\t\t\t\t\\\n\t\tret = len;\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tkfree(split_page);\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac2_opts_, name)\n\n#define UAC2_ATTRIBUTE_STRING(name)\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = snprintf(page, sizeof(opts->name), \"%s\", opts->name);\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac2_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac2_opts *opts = to_f_uac2_opts(item);\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = snprintf(opts->name, min(sizeof(opts->name), len),\t\\\n\t\t\t\"%s\", page);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac2_opts_, name)\n\nUAC2_ATTRIBUTE(u32, p_chmask);\nUAC2_RATE_ATTRIBUTE(p_srate);\nUAC2_ATTRIBUTE(u32, p_ssize);\nUAC2_ATTRIBUTE(u8, p_hs_bint);\nUAC2_ATTRIBUTE(u32, c_chmask);\nUAC2_RATE_ATTRIBUTE(c_srate);\nUAC2_ATTRIBUTE_SYNC(c_sync);\nUAC2_ATTRIBUTE(u32, c_ssize);\nUAC2_ATTRIBUTE(u8, c_hs_bint);\nUAC2_ATTRIBUTE(u32, req_number);\n\nUAC2_ATTRIBUTE(bool, p_mute_present);\nUAC2_ATTRIBUTE(bool, p_volume_present);\nUAC2_ATTRIBUTE(s16, p_volume_min);\nUAC2_ATTRIBUTE(s16, p_volume_max);\nUAC2_ATTRIBUTE(s16, p_volume_res);\n\nUAC2_ATTRIBUTE(bool, c_mute_present);\nUAC2_ATTRIBUTE(bool, c_volume_present);\nUAC2_ATTRIBUTE(s16, c_volume_min);\nUAC2_ATTRIBUTE(s16, c_volume_max);\nUAC2_ATTRIBUTE(s16, c_volume_res);\nUAC2_ATTRIBUTE(u32, fb_max);\nUAC2_ATTRIBUTE_STRING(function_name);\n\nstatic struct configfs_attribute *f_uac2_attrs[] = {\n\t&f_uac2_opts_attr_p_chmask,\n\t&f_uac2_opts_attr_p_srate,\n\t&f_uac2_opts_attr_p_ssize,\n\t&f_uac2_opts_attr_p_hs_bint,\n\t&f_uac2_opts_attr_c_chmask,\n\t&f_uac2_opts_attr_c_srate,\n\t&f_uac2_opts_attr_c_ssize,\n\t&f_uac2_opts_attr_c_hs_bint,\n\t&f_uac2_opts_attr_c_sync,\n\t&f_uac2_opts_attr_req_number,\n\t&f_uac2_opts_attr_fb_max,\n\n\t&f_uac2_opts_attr_p_mute_present,\n\t&f_uac2_opts_attr_p_volume_present,\n\t&f_uac2_opts_attr_p_volume_min,\n\t&f_uac2_opts_attr_p_volume_max,\n\t&f_uac2_opts_attr_p_volume_res,\n\n\t&f_uac2_opts_attr_c_mute_present,\n\t&f_uac2_opts_attr_c_volume_present,\n\t&f_uac2_opts_attr_c_volume_min,\n\t&f_uac2_opts_attr_c_volume_max,\n\t&f_uac2_opts_attr_c_volume_res,\n\n\t&f_uac2_opts_attr_function_name,\n\n\tNULL,\n};\n\nstatic const struct config_item_type f_uac2_func_type = {\n\t.ct_item_ops\t= &f_uac2_item_ops,\n\t.ct_attrs\t= f_uac2_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void afunc_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_uac2_opts *opts;\n\n\topts = container_of(f, struct f_uac2_opts, func_inst);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *afunc_alloc_inst(void)\n{\n\tstruct f_uac2_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = afunc_free_inst;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &f_uac2_func_type);\n\n\topts->p_chmask = UAC2_DEF_PCHMASK;\n\topts->p_srates[0] = UAC2_DEF_PSRATE;\n\topts->p_ssize = UAC2_DEF_PSSIZE;\n\topts->p_hs_bint = UAC2_DEF_PHSBINT;\n\topts->c_chmask = UAC2_DEF_CCHMASK;\n\topts->c_srates[0] = UAC2_DEF_CSRATE;\n\topts->c_ssize = UAC2_DEF_CSSIZE;\n\topts->c_hs_bint = UAC2_DEF_CHSBINT;\n\topts->c_sync = UAC2_DEF_CSYNC;\n\n\topts->p_mute_present = UAC2_DEF_MUTE_PRESENT;\n\topts->p_volume_present = UAC2_DEF_VOLUME_PRESENT;\n\topts->p_volume_min = UAC2_DEF_MIN_DB;\n\topts->p_volume_max = UAC2_DEF_MAX_DB;\n\topts->p_volume_res = UAC2_DEF_RES_DB;\n\n\topts->c_mute_present = UAC2_DEF_MUTE_PRESENT;\n\topts->c_volume_present = UAC2_DEF_VOLUME_PRESENT;\n\topts->c_volume_min = UAC2_DEF_MIN_DB;\n\topts->c_volume_max = UAC2_DEF_MAX_DB;\n\topts->c_volume_res = UAC2_DEF_RES_DB;\n\n\topts->req_number = UAC2_DEF_REQ_NUM;\n\topts->fb_max = FBACK_FAST_MAX;\n\n\tsnprintf(opts->function_name, sizeof(opts->function_name), \"Source/Sink\");\n\n\treturn &opts->func_inst;\n}\n\nstatic void afunc_free(struct usb_function *f)\n{\n\tstruct g_audio *agdev;\n\tstruct f_uac2_opts *opts;\n\n\tagdev = func_to_g_audio(f);\n\topts = container_of(f->fi, struct f_uac2_opts, func_inst);\n\tkfree(agdev);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void afunc_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct g_audio *agdev = func_to_g_audio(f);\n\n\tg_audio_cleanup(agdev);\n\tusb_free_all_descriptors(f);\n\n\tagdev->gadget = NULL;\n\n\tkfree(out_feature_unit_desc);\n\tout_feature_unit_desc = NULL;\n\tkfree(in_feature_unit_desc);\n\tin_feature_unit_desc = NULL;\n}\n\nstatic struct usb_function *afunc_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_uac2\t*uac2;\n\tstruct f_uac2_opts *opts;\n\n\tuac2 = kzalloc(sizeof(*uac2), GFP_KERNEL);\n\tif (uac2 == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_uac2_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tuac2->g_audio.func.name = \"uac2_func\";\n\tuac2->g_audio.func.bind = afunc_bind;\n\tuac2->g_audio.func.unbind = afunc_unbind;\n\tuac2->g_audio.func.set_alt = afunc_set_alt;\n\tuac2->g_audio.func.get_alt = afunc_get_alt;\n\tuac2->g_audio.func.disable = afunc_disable;\n\tuac2->g_audio.func.suspend = afunc_suspend;\n\tuac2->g_audio.func.setup = afunc_setup;\n\tuac2->g_audio.func.free_func = afunc_free;\n\n\treturn &uac2->g_audio.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(uac2, afunc_alloc_inst, afunc_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yadwinder Singh\");\nMODULE_AUTHOR(\"Jaswinder Singh\");\nMODULE_AUTHOR(\"Ruslan Bilovol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}