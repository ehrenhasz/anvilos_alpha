{
  "module_name": "f_ncm.c",
  "hash_id": "88ee488f6e86d6528be1f37c55c1953d3e375c295d05ff95e333a9ed97318cc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_ncm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n\n#include <linux/usb/cdc.h>\n\n#include \"u_ether.h\"\n#include \"u_ether_configfs.h\"\n#include \"u_ncm.h\"\n#include \"configfs.h\"\n\n \n\n \n\n#define NCM_NDP_HDR_CRC\t\t0x01000000\n\nenum ncm_notify_state {\n\tNCM_NOTIFY_NONE,\t\t \n\tNCM_NOTIFY_CONNECT,\t\t \n\tNCM_NOTIFY_SPEED,\t\t \n};\n\nstruct f_ncm {\n\tstruct gether\t\t\tport;\n\tu8\t\t\t\tctrl_id, data_id;\n\n\tchar\t\t\t\tethaddr[14];\n\n\tstruct usb_ep\t\t\t*notify;\n\tstruct usb_request\t\t*notify_req;\n\tu8\t\t\t\tnotify_state;\n\tatomic_t\t\t\tnotify_count;\n\tbool\t\t\t\tis_open;\n\n\tconst struct ndp_parser_opts\t*parser_opts;\n\tbool\t\t\t\tis_crc;\n\tu32\t\t\t\tndp_sign;\n\n\t \n\tspinlock_t\t\t\tlock;\n\n\tstruct net_device\t\t*netdev;\n\n\t \n\tstruct sk_buff\t\t\t*skb_tx_data;\n\tstruct sk_buff\t\t\t*skb_tx_ndp;\n\tu16\t\t\t\tndp_dgram_count;\n\tstruct hrtimer\t\t\ttask_timer;\n};\n\nstatic inline struct f_ncm *func_to_ncm(struct usb_function *f)\n{\n\treturn container_of(f, struct f_ncm, port.func);\n}\n\n \n\n \n#define NTB_DEFAULT_IN_SIZE\t16384\n#define NTB_OUT_SIZE\t\t16384\n\n \n#define TX_MAX_NUM_DPE\t\t32\n\n \n#define TX_TIMEOUT_NSECS\t300000\n\n#define FORMATS_SUPPORTED\t(USB_CDC_NCM_NTB16_SUPPORTED |\t\\\n\t\t\t\t USB_CDC_NCM_NTB32_SUPPORTED)\n\nstatic struct usb_cdc_ncm_ntb_parameters ntb_parameters = {\n\t.wLength = cpu_to_le16(sizeof(ntb_parameters)),\n\t.bmNtbFormatsSupported = cpu_to_le16(FORMATS_SUPPORTED),\n\t.dwNtbInMaxSize = cpu_to_le32(NTB_DEFAULT_IN_SIZE),\n\t.wNdpInDivisor = cpu_to_le16(4),\n\t.wNdpInPayloadRemainder = cpu_to_le16(0),\n\t.wNdpInAlignment = cpu_to_le16(4),\n\n\t.dwNtbOutMaxSize = cpu_to_le32(NTB_OUT_SIZE),\n\t.wNdpOutDivisor = cpu_to_le16(4),\n\t.wNdpOutPayloadRemainder = cpu_to_le16(0),\n\t.wNdpOutAlignment = cpu_to_le16(4),\n};\n\n \n\n#define NCM_STATUS_INTERVAL_MS\t\t32\n#define NCM_STATUS_BYTECOUNT\t\t16\t \n\nstatic struct usb_interface_assoc_descriptor ncm_iad_desc = {\n\t.bLength =\t\tsizeof ncm_iad_desc,\n\t.bDescriptorType =\tUSB_DT_INTERFACE_ASSOCIATION,\n\n\t \n\t.bInterfaceCount =\t2,\t \n\t.bFunctionClass =\tUSB_CLASS_COMM,\n\t.bFunctionSubClass =\tUSB_CDC_SUBCLASS_NCM,\n\t.bFunctionProtocol =\tUSB_CDC_PROTO_NONE,\n\t \n};\n\n \n\nstatic struct usb_interface_descriptor ncm_control_intf = {\n\t.bLength =\t\tsizeof ncm_control_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_NCM,\n\t.bInterfaceProtocol =\tUSB_CDC_PROTO_NONE,\n\t \n};\n\nstatic struct usb_cdc_header_desc ncm_header_desc = {\n\t.bLength =\t\tsizeof ncm_header_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic struct usb_cdc_union_desc ncm_union_desc = {\n\t.bLength =\t\tsizeof(ncm_union_desc),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_UNION_TYPE,\n\t \n\t \n};\n\nstatic struct usb_cdc_ether_desc ecm_desc = {\n\t.bLength =\t\tsizeof ecm_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_ETHERNET_TYPE,\n\n\t \n\t \n\t.bmEthernetStatistics =\tcpu_to_le32(0),  \n\t.wMaxSegmentSize =\tcpu_to_le16(ETH_FRAME_LEN),\n\t.wNumberMCFilters =\tcpu_to_le16(0),\n\t.bNumberPowerFilters =\t0,\n};\n\n#define NCAPS\t(USB_CDC_NCM_NCAP_ETH_FILTER | USB_CDC_NCM_NCAP_CRC_MODE)\n\nstatic struct usb_cdc_ncm_desc ncm_desc = {\n\t.bLength =\t\tsizeof ncm_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_NCM_TYPE,\n\n\t.bcdNcmVersion =\tcpu_to_le16(0x0100),\n\t \n\t.bmNetworkCapabilities = NCAPS,\n};\n\n \n\nstatic struct usb_interface_descriptor ncm_data_nop_intf = {\n\t.bLength =\t\tsizeof ncm_data_nop_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bInterfaceNumber =\t1,\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\tUSB_CDC_NCM_PROTO_NTB,\n\t \n};\n\n \n\nstatic struct usb_interface_descriptor ncm_data_intf = {\n\t.bLength =\t\tsizeof ncm_data_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bInterfaceNumber =\t1,\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\tUSB_CDC_NCM_PROTO_NTB,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_ncm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(NCM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tNCM_STATUS_INTERVAL_MS,\n};\n\nstatic struct usb_endpoint_descriptor fs_ncm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_ncm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *ncm_fs_function[] = {\n\t(struct usb_descriptor_header *) &ncm_iad_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_control_intf,\n\t(struct usb_descriptor_header *) &ncm_header_desc,\n\t(struct usb_descriptor_header *) &ncm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\t(struct usb_descriptor_header *) &ncm_desc,\n\t(struct usb_descriptor_header *) &fs_ncm_notify_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ncm_data_intf,\n\t(struct usb_descriptor_header *) &fs_ncm_in_desc,\n\t(struct usb_descriptor_header *) &fs_ncm_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_ncm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(NCM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(NCM_STATUS_INTERVAL_MS),\n};\nstatic struct usb_endpoint_descriptor hs_ncm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_ncm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *ncm_hs_function[] = {\n\t(struct usb_descriptor_header *) &ncm_iad_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_control_intf,\n\t(struct usb_descriptor_header *) &ncm_header_desc,\n\t(struct usb_descriptor_header *) &ncm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\t(struct usb_descriptor_header *) &ncm_desc,\n\t(struct usb_descriptor_header *) &hs_ncm_notify_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ncm_data_intf,\n\t(struct usb_descriptor_header *) &hs_ncm_in_desc,\n\t(struct usb_descriptor_header *) &hs_ncm_out_desc,\n\tNULL,\n};\n\n\n \n\nstatic struct usb_endpoint_descriptor ss_ncm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(NCM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(NCM_STATUS_INTERVAL_MS)\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ncm_notify_comp_desc = {\n\t.bLength =\t\tsizeof(ss_ncm_notify_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n\t.wBytesPerInterval =\tcpu_to_le16(NCM_STATUS_BYTECOUNT),\n};\n\nstatic struct usb_endpoint_descriptor ss_ncm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor ss_ncm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ncm_bulk_comp_desc = {\n\t.bLength =\t\tsizeof(ss_ncm_bulk_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t.bMaxBurst =\t\t15,\n\t \n};\n\nstatic struct usb_descriptor_header *ncm_ss_function[] = {\n\t(struct usb_descriptor_header *) &ncm_iad_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_control_intf,\n\t(struct usb_descriptor_header *) &ncm_header_desc,\n\t(struct usb_descriptor_header *) &ncm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\t(struct usb_descriptor_header *) &ncm_desc,\n\t(struct usb_descriptor_header *) &ss_ncm_notify_desc,\n\t(struct usb_descriptor_header *) &ss_ncm_notify_comp_desc,\n\t \n\t(struct usb_descriptor_header *) &ncm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ncm_data_intf,\n\t(struct usb_descriptor_header *) &ss_ncm_in_desc,\n\t(struct usb_descriptor_header *) &ss_ncm_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &ss_ncm_out_desc,\n\t(struct usb_descriptor_header *) &ss_ncm_bulk_comp_desc,\n\tNULL,\n};\n\n \n\n#define STRING_CTRL_IDX\t0\n#define STRING_MAC_IDX\t1\n#define STRING_DATA_IDX\t2\n#define STRING_IAD_IDX\t3\n\nstatic struct usb_string ncm_string_defs[] = {\n\t[STRING_CTRL_IDX].s = \"CDC Network Control Model (NCM)\",\n\t[STRING_MAC_IDX].s = \"\",\n\t[STRING_DATA_IDX].s = \"CDC Network Data\",\n\t[STRING_IAD_IDX].s = \"CDC NCM\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings ncm_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\tncm_string_defs,\n};\n\nstatic struct usb_gadget_strings *ncm_strings[] = {\n\t&ncm_string_table,\n\tNULL,\n};\n\n \n\nstruct ndp_parser_opts {\n\tu32\t\tnth_sign;\n\tu32\t\tndp_sign;\n\tunsigned\tnth_size;\n\tunsigned\tndp_size;\n\tunsigned\tdpe_size;\n\tunsigned\tndplen_align;\n\t \n\tunsigned\tdgram_item_len;  \n\tunsigned\tblock_length;\n\tunsigned\tndp_index;\n\tunsigned\treserved1;\n\tunsigned\treserved2;\n\tunsigned\tnext_ndp_index;\n};\n\nstatic const struct ndp_parser_opts ndp16_opts = {\n\t.nth_sign = USB_CDC_NCM_NTH16_SIGN,\n\t.ndp_sign = USB_CDC_NCM_NDP16_NOCRC_SIGN,\n\t.nth_size = sizeof(struct usb_cdc_ncm_nth16),\n\t.ndp_size = sizeof(struct usb_cdc_ncm_ndp16),\n\t.dpe_size = sizeof(struct usb_cdc_ncm_dpe16),\n\t.ndplen_align = 4,\n\t.dgram_item_len = 1,\n\t.block_length = 1,\n\t.ndp_index = 1,\n\t.reserved1 = 0,\n\t.reserved2 = 0,\n\t.next_ndp_index = 1,\n};\n\nstatic const struct ndp_parser_opts ndp32_opts = {\n\t.nth_sign = USB_CDC_NCM_NTH32_SIGN,\n\t.ndp_sign = USB_CDC_NCM_NDP32_NOCRC_SIGN,\n\t.nth_size = sizeof(struct usb_cdc_ncm_nth32),\n\t.ndp_size = sizeof(struct usb_cdc_ncm_ndp32),\n\t.dpe_size = sizeof(struct usb_cdc_ncm_dpe32),\n\t.ndplen_align = 8,\n\t.dgram_item_len = 2,\n\t.block_length = 2,\n\t.ndp_index = 2,\n\t.reserved1 = 1,\n\t.reserved2 = 2,\n\t.next_ndp_index = 2,\n};\n\nstatic inline void put_ncm(__le16 **p, unsigned size, unsigned val)\n{\n\tswitch (size) {\n\tcase 1:\n\t\tput_unaligned_le16((u16)val, *p);\n\t\tbreak;\n\tcase 2:\n\t\tput_unaligned_le32((u32)val, *p);\n\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t*p += size;\n}\n\nstatic inline unsigned get_ncm(__le16 **p, unsigned size)\n{\n\tunsigned tmp;\n\n\tswitch (size) {\n\tcase 1:\n\t\ttmp = get_unaligned_le16(*p);\n\t\tbreak;\n\tcase 2:\n\t\ttmp = get_unaligned_le32(*p);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\t*p += size;\n\treturn tmp;\n}\n\n \n\nstatic inline void ncm_reset_values(struct f_ncm *ncm)\n{\n\tncm->parser_opts = &ndp16_opts;\n\tncm->is_crc = false;\n\tncm->ndp_sign = ncm->parser_opts->ndp_sign;\n\tncm->port.cdc_filter = DEFAULT_FILTER;\n\n\t \n\tncm->port.header_len = 0;\n\n\tncm->port.fixed_out_len = le32_to_cpu(ntb_parameters.dwNtbOutMaxSize);\n\tncm->port.fixed_in_len = NTB_DEFAULT_IN_SIZE;\n}\n\n \nstatic void ncm_do_notify(struct f_ncm *ncm)\n{\n\tstruct usb_request\t\t*req = ncm->notify_req;\n\tstruct usb_cdc_notification\t*event;\n\tstruct usb_composite_dev\t*cdev = ncm->port.func.config->cdev;\n\t__le32\t\t\t\t*data;\n\tint\t\t\t\tstatus;\n\n\t \n\tif (atomic_read(&ncm->notify_count))\n\t\treturn;\n\n\tevent = req->buf;\n\tswitch (ncm->notify_state) {\n\tcase NCM_NOTIFY_NONE:\n\t\treturn;\n\n\tcase NCM_NOTIFY_CONNECT:\n\t\tevent->bNotificationType = USB_CDC_NOTIFY_NETWORK_CONNECTION;\n\t\tif (ncm->is_open)\n\t\t\tevent->wValue = cpu_to_le16(1);\n\t\telse\n\t\t\tevent->wValue = cpu_to_le16(0);\n\t\tevent->wLength = 0;\n\t\treq->length = sizeof *event;\n\n\t\tDBG(cdev, \"notify connect %s\\n\",\n\t\t\t\tncm->is_open ? \"true\" : \"false\");\n\t\tncm->notify_state = NCM_NOTIFY_NONE;\n\t\tbreak;\n\n\tcase NCM_NOTIFY_SPEED:\n\t\tevent->bNotificationType = USB_CDC_NOTIFY_SPEED_CHANGE;\n\t\tevent->wValue = cpu_to_le16(0);\n\t\tevent->wLength = cpu_to_le16(8);\n\t\treq->length = NCM_STATUS_BYTECOUNT;\n\n\t\t \n\t\tdata = req->buf + sizeof *event;\n\t\tdata[0] = cpu_to_le32(gether_bitrate(cdev->gadget));\n\t\tdata[1] = data[0];\n\n\t\tDBG(cdev, \"notify speed %u\\n\", gether_bitrate(cdev->gadget));\n\t\tncm->notify_state = NCM_NOTIFY_CONNECT;\n\t\tbreak;\n\t}\n\tevent->bmRequestType = 0xA1;\n\tevent->wIndex = cpu_to_le16(ncm->ctrl_id);\n\n\tatomic_inc(&ncm->notify_count);\n\n\t \n\tspin_unlock(&ncm->lock);\n\tstatus = usb_ep_queue(ncm->notify, req, GFP_ATOMIC);\n\tspin_lock(&ncm->lock);\n\tif (status < 0) {\n\t\tatomic_dec(&ncm->notify_count);\n\t\tDBG(cdev, \"notify --> %d\\n\", status);\n\t}\n}\n\n \nstatic void ncm_notify(struct f_ncm *ncm)\n{\n\t \n\tncm->notify_state = NCM_NOTIFY_SPEED;\n\tncm_do_notify(ncm);\n}\n\nstatic void ncm_notify_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_ncm\t\t\t*ncm = req->context;\n\tstruct usb_composite_dev\t*cdev = ncm->port.func.config->cdev;\n\tstruct usb_cdc_notification\t*event = req->buf;\n\n\tspin_lock(&ncm->lock);\n\tswitch (req->status) {\n\tcase 0:\n\t\tVDBG(cdev, \"Notification %02x sent\\n\",\n\t\t     event->bNotificationType);\n\t\tatomic_dec(&ncm->notify_count);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tatomic_set(&ncm->notify_count, 0);\n\t\tncm->notify_state = NCM_NOTIFY_NONE;\n\t\tbreak;\n\tdefault:\n\t\tDBG(cdev, \"event %02x --> %d\\n\",\n\t\t\tevent->bNotificationType, req->status);\n\t\tatomic_dec(&ncm->notify_count);\n\t\tbreak;\n\t}\n\tncm_do_notify(ncm);\n\tspin_unlock(&ncm->lock);\n}\n\nstatic void ncm_ep0out_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\t \n\tunsigned\t\tin_size;\n\tstruct usb_function\t*f = req->context;\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\treq->context = NULL;\n\tif (req->status || req->actual != req->length) {\n\t\tDBG(cdev, \"Bad control-OUT transfer\\n\");\n\t\tgoto invalid;\n\t}\n\n\tin_size = get_unaligned_le32(req->buf);\n\tif (in_size < USB_CDC_NCM_NTB_MIN_IN_SIZE ||\n\t    in_size > le32_to_cpu(ntb_parameters.dwNtbInMaxSize)) {\n\t\tDBG(cdev, \"Got wrong INPUT SIZE (%d) from host\\n\", in_size);\n\t\tgoto invalid;\n\t}\n\n\tncm->port.fixed_in_len = in_size;\n\tVDBG(cdev, \"Set NTB INPUT SIZE %d\\n\", in_size);\n\treturn;\n\ninvalid:\n\tusb_ep_set_halt(ep);\n\treturn;\n}\n\nstatic int ncm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_SET_ETHERNET_PACKET_FILTER:\n\t\t \n\t\tif (w_length != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tDBG(cdev, \"packet filter %02x\\n\", w_value);\n\t\t \n\t\tncm->port.cdc_filter = w_value;\n\t\tvalue = 0;\n\t\tbreak;\n\t \n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_GET_NTB_PARAMETERS:\n\n\t\tif (w_length == 0 || w_value != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tvalue = w_length > sizeof ntb_parameters ?\n\t\t\tsizeof ntb_parameters : w_length;\n\t\tmemcpy(req->buf, &ntb_parameters, value);\n\t\tVDBG(cdev, \"Host asked NTB parameters\\n\");\n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_GET_NTB_INPUT_SIZE:\n\n\t\tif (w_length < 4 || w_value != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tput_unaligned_le32(ncm->port.fixed_in_len, req->buf);\n\t\tvalue = 4;\n\t\tVDBG(cdev, \"Host asked INPUT SIZE, sending %d\\n\",\n\t\t     ncm->port.fixed_in_len);\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_SET_NTB_INPUT_SIZE:\n\t{\n\t\tif (w_length != 4 || w_value != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\treq->complete = ncm_ep0out_complete;\n\t\treq->length = w_length;\n\t\treq->context = f;\n\n\t\tvalue = req->length;\n\t\tbreak;\n\t}\n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_GET_NTB_FORMAT:\n\t{\n\t\tuint16_t format;\n\n\t\tif (w_length < 2 || w_value != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tformat = (ncm->parser_opts == &ndp16_opts) ? 0x0000 : 0x0001;\n\t\tput_unaligned_le16(format, req->buf);\n\t\tvalue = 2;\n\t\tVDBG(cdev, \"Host asked NTB FORMAT, sending %d\\n\", format);\n\t\tbreak;\n\t}\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_SET_NTB_FORMAT:\n\t{\n\t\tif (w_length != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tswitch (w_value) {\n\t\tcase 0x0000:\n\t\t\tncm->parser_opts = &ndp16_opts;\n\t\t\tDBG(cdev, \"NCM16 selected\\n\");\n\t\t\tbreak;\n\t\tcase 0x0001:\n\t\t\tncm->parser_opts = &ndp32_opts;\n\t\t\tDBG(cdev, \"NCM32 selected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\t\tvalue = 0;\n\t\tbreak;\n\t}\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_GET_CRC_MODE:\n\t{\n\t\tuint16_t is_crc;\n\n\t\tif (w_length < 2 || w_value != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tis_crc = ncm->is_crc ? 0x0001 : 0x0000;\n\t\tput_unaligned_le16(is_crc, req->buf);\n\t\tvalue = 2;\n\t\tVDBG(cdev, \"Host asked CRC MODE, sending %d\\n\", is_crc);\n\t\tbreak;\n\t}\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t| USB_CDC_SET_CRC_MODE:\n\t{\n\t\tif (w_length != 0 || w_index != ncm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tswitch (w_value) {\n\t\tcase 0x0000:\n\t\t\tncm->is_crc = false;\n\t\t\tDBG(cdev, \"non-CRC mode selected\\n\");\n\t\t\tbreak;\n\t\tcase 0x0001:\n\t\t\tncm->is_crc = true;\n\t\t\tDBG(cdev, \"CRC mode selected\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto invalid;\n\t\t}\n\t\tvalue = 0;\n\t\tbreak;\n\t}\n\n\t \n\t \n\t \n\t \n\t \n\n\tdefault:\ninvalid:\n\t\tDBG(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\tncm->ndp_sign = ncm->parser_opts->ndp_sign |\n\t\t(ncm->is_crc ? NCM_NDP_HDR_CRC : 0);\n\n\t \n\tif (value >= 0) {\n\t\tDBG(cdev, \"ncm req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"ncm req %02x.%02x response err %d\\n\",\n\t\t\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\t\t\tvalue);\n\t}\n\n\t \n\treturn value;\n}\n\n\nstatic int ncm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\tif (intf == ncm->ctrl_id) {\n\t\tif (alt != 0)\n\t\t\tgoto fail;\n\n\t\tDBG(cdev, \"reset ncm control %d\\n\", intf);\n\t\tusb_ep_disable(ncm->notify);\n\n\t\tif (!(ncm->notify->desc)) {\n\t\t\tDBG(cdev, \"init ncm ctrl %d\\n\", intf);\n\t\t\tif (config_ep_by_speed(cdev->gadget, f, ncm->notify))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tusb_ep_enable(ncm->notify);\n\n\t \n\t} else if (intf == ncm->data_id) {\n\t\tif (alt > 1)\n\t\t\tgoto fail;\n\n\t\tif (ncm->port.in_ep->enabled) {\n\t\t\tDBG(cdev, \"reset ncm\\n\");\n\t\t\tncm->netdev = NULL;\n\t\t\tgether_disconnect(&ncm->port);\n\t\t\tncm_reset_values(ncm);\n\t\t}\n\n\t\t \n\t\tif (alt == 1) {\n\t\t\tstruct net_device\t*net;\n\n\t\t\tif (!ncm->port.in_ep->desc ||\n\t\t\t    !ncm->port.out_ep->desc) {\n\t\t\t\tDBG(cdev, \"init ncm\\n\");\n\t\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t\t       ncm->port.in_ep) ||\n\t\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t\t       ncm->port.out_ep)) {\n\t\t\t\t\tncm->port.in_ep->desc = NULL;\n\t\t\t\t\tncm->port.out_ep->desc = NULL;\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tncm->port.is_zlp_ok =\n\t\t\t\tgadget_is_zlp_supported(cdev->gadget);\n\t\t\tncm->port.cdc_filter = DEFAULT_FILTER;\n\t\t\tDBG(cdev, \"activate ncm\\n\");\n\t\t\tnet = gether_connect(&ncm->port);\n\t\t\tif (IS_ERR(net))\n\t\t\t\treturn PTR_ERR(net);\n\t\t\tncm->netdev = net;\n\t\t}\n\n\t\tspin_lock(&ncm->lock);\n\t\tncm_notify(ncm);\n\t\tspin_unlock(&ncm->lock);\n\t} else\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\n\n \nstatic int ncm_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\n\tif (intf == ncm->ctrl_id)\n\t\treturn 0;\n\treturn ncm->port.in_ep->enabled ? 1 : 0;\n}\n\nstatic struct sk_buff *package_for_tx(struct f_ncm *ncm)\n{\n\t__le16\t\t*ntb_iter;\n\tstruct sk_buff\t*skb2 = NULL;\n\tunsigned\tndp_pad;\n\tunsigned\tndp_index;\n\tunsigned\tnew_len;\n\n\tconst struct ndp_parser_opts *opts = ncm->parser_opts;\n\tconst int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);\n\tconst int dgram_idx_len = 2 * 2 * opts->dgram_item_len;\n\n\t \n\thrtimer_try_to_cancel(&ncm->task_timer);\n\n\tndp_pad = ALIGN(ncm->skb_tx_data->len, ndp_align) -\n\t\t\tncm->skb_tx_data->len;\n\tndp_index = ncm->skb_tx_data->len + ndp_pad;\n\tnew_len = ndp_index + dgram_idx_len + ncm->skb_tx_ndp->len;\n\n\t \n\tntb_iter = (void *) ncm->skb_tx_data->data;\n\t \n\tntb_iter += 2 + 1 + 1;\n\tput_ncm(&ntb_iter, opts->block_length, new_len);\n\tput_ncm(&ntb_iter, opts->ndp_index, ndp_index);\n\n\t \n\tnew_len = opts->ndp_size +\n\t\t\t(ncm->ndp_dgram_count * dgram_idx_len);\n\tncm->ndp_dgram_count = 0;\n\t \n\tntb_iter = (void *) ncm->skb_tx_ndp->data;\n\tntb_iter += 2;\n\tput_unaligned_le16(new_len, ntb_iter);\n\n\t \n\tswap(skb2, ncm->skb_tx_data);\n\tif (ncm->skb_tx_data) {\n\t\tdev_consume_skb_any(ncm->skb_tx_data);\n\t\tncm->skb_tx_data = NULL;\n\t}\n\n\t \n\tskb_put_zero(skb2, ndp_pad);\n\n\t \n\tskb_put_data(skb2, ncm->skb_tx_ndp->data, ncm->skb_tx_ndp->len);\n\tdev_consume_skb_any(ncm->skb_tx_ndp);\n\tncm->skb_tx_ndp = NULL;\n\n\t \n\tskb_put_zero(skb2, dgram_idx_len);\n\n\treturn skb2;\n}\n\nstatic struct sk_buff *ncm_wrap_ntb(struct gether *port,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct f_ncm\t*ncm = func_to_ncm(&port->func);\n\tstruct sk_buff\t*skb2 = NULL;\n\n\tif (skb) {\n\t\tint\t\tncb_len = 0;\n\t\t__le16\t\t*ntb_data;\n\t\t__le16\t\t*ntb_ndp;\n\t\tint\t\tdgram_pad;\n\n\t\tunsigned\tmax_size = ncm->port.fixed_in_len;\n\t\tconst struct ndp_parser_opts *opts = ncm->parser_opts;\n\t\tconst int ndp_align = le16_to_cpu(ntb_parameters.wNdpInAlignment);\n\t\tconst int div = le16_to_cpu(ntb_parameters.wNdpInDivisor);\n\t\tconst int rem = le16_to_cpu(ntb_parameters.wNdpInPayloadRemainder);\n\t\tconst int dgram_idx_len = 2 * 2 * opts->dgram_item_len;\n\n\t\t \n\t\tif (ncm->is_crc) {\n\t\t\tuint32_t\tcrc;\n\t\t\t__le16\t\t*crc_pos;\n\n\t\t\tcrc = ~crc32_le(~0,\n\t\t\t\t\tskb->data,\n\t\t\t\t\tskb->len);\n\t\t\tcrc_pos = skb_put(skb, sizeof(uint32_t));\n\t\t\tput_unaligned_le32(crc, crc_pos);\n\t\t}\n\n\t\t \n\t\tif (ncm->skb_tx_data\n\t\t    && (ncm->ndp_dgram_count >= TX_MAX_NUM_DPE\n\t\t    || (ncm->skb_tx_data->len +\n\t\t    div + rem + skb->len +\n\t\t    ncm->skb_tx_ndp->len + ndp_align + (2 * dgram_idx_len))\n\t\t    > max_size)) {\n\t\t\tskb2 = package_for_tx(ncm);\n\t\t\tif (!skb2)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (!ncm->skb_tx_data) {\n\t\t\tncb_len = opts->nth_size;\n\t\t\tdgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;\n\t\t\tncb_len += dgram_pad;\n\n\t\t\t \n\t\t\tncm->skb_tx_data = alloc_skb(max_size, GFP_ATOMIC);\n\t\t\tif (!ncm->skb_tx_data)\n\t\t\t\tgoto err;\n\n\t\t\tncm->skb_tx_data->dev = ncm->netdev;\n\t\t\tntb_data = skb_put_zero(ncm->skb_tx_data, ncb_len);\n\t\t\t \n\t\t\tput_unaligned_le32(opts->nth_sign, ntb_data);\n\t\t\tntb_data += 2;\n\t\t\t \n\t\t\tput_unaligned_le16(opts->nth_size, ntb_data++);\n\n\t\t\t \n\t\t\tncm->skb_tx_ndp = alloc_skb((int)(opts->ndp_size\n\t\t\t\t\t\t    + opts->dpe_size\n\t\t\t\t\t\t    * TX_MAX_NUM_DPE),\n\t\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (!ncm->skb_tx_ndp)\n\t\t\t\tgoto err;\n\n\t\t\tncm->skb_tx_ndp->dev = ncm->netdev;\n\t\t\tntb_ndp = skb_put(ncm->skb_tx_ndp, opts->ndp_size);\n\t\t\tmemset(ntb_ndp, 0, ncb_len);\n\t\t\t \n\t\t\tput_unaligned_le32(ncm->ndp_sign, ntb_ndp);\n\t\t\tntb_ndp += 2;\n\n\t\t\t \n\t\t\tncm->ndp_dgram_count = 1;\n\n\t\t\t \n\n\t\t\t \n\t\t\thrtimer_start(&ncm->task_timer, TX_TIMEOUT_NSECS,\n\t\t\t\t      HRTIMER_MODE_REL_SOFT);\n\t\t}\n\n\t\t \n\t\tntb_ndp = skb_put_zero(ncm->skb_tx_ndp, dgram_idx_len);\n\n\t\tncb_len = ncm->skb_tx_data->len;\n\t\tdgram_pad = ALIGN(ncb_len, div) + rem - ncb_len;\n\t\tncb_len += dgram_pad;\n\n\t\t \n\t\tput_ncm(&ntb_ndp, opts->dgram_item_len, ncb_len);\n\t\t \n\t\tput_ncm(&ntb_ndp, opts->dgram_item_len, skb->len);\n\t\tncm->ndp_dgram_count++;\n\n\t\t \n\t\tskb_put_zero(ncm->skb_tx_data, dgram_pad);\n\t\tskb_put_data(ncm->skb_tx_data, skb->data, skb->len);\n\t\tdev_consume_skb_any(skb);\n\t\tskb = NULL;\n\n\t} else if (ncm->skb_tx_data) {\n\t\t \n\t\tskb2 = package_for_tx(ncm);\n\t\tif (!skb2)\n\t\t\tgoto err;\n\t}\n\n\treturn skb2;\n\nerr:\n\tncm->netdev->stats.tx_dropped++;\n\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\tif (ncm->skb_tx_data)\n\t\tdev_kfree_skb_any(ncm->skb_tx_data);\n\tif (ncm->skb_tx_ndp)\n\t\tdev_kfree_skb_any(ncm->skb_tx_ndp);\n\n\treturn NULL;\n}\n\n \nstatic enum hrtimer_restart ncm_tx_timeout(struct hrtimer *data)\n{\n\tstruct f_ncm *ncm = container_of(data, struct f_ncm, task_timer);\n\tstruct net_device *netdev = READ_ONCE(ncm->netdev);\n\n\tif (netdev) {\n\t\t \n\t\tnetdev->netdev_ops->ndo_start_xmit(NULL, netdev);\n\t}\n\treturn HRTIMER_NORESTART;\n}\n\nstatic int ncm_unwrap_ntb(struct gether *port,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  struct sk_buff_head *list)\n{\n\tstruct f_ncm\t*ncm = func_to_ncm(&port->func);\n\tunsigned char\t*ntb_ptr = skb->data;\n\t__le16\t\t*tmp;\n\tunsigned\tindex, index2;\n\tint\t\tndp_index;\n\tunsigned\tdg_len, dg_len2;\n\tunsigned\tndp_len;\n\tunsigned\tblock_len;\n\tstruct sk_buff\t*skb2;\n\tint\t\tret = -EINVAL;\n\tunsigned\tntb_max = le32_to_cpu(ntb_parameters.dwNtbOutMaxSize);\n\tunsigned\tframe_max = le16_to_cpu(ecm_desc.wMaxSegmentSize);\n\tconst struct ndp_parser_opts *opts = ncm->parser_opts;\n\tunsigned\tcrc_len = ncm->is_crc ? sizeof(uint32_t) : 0;\n\tint\t\tdgram_counter;\n\tint\t\tto_process = skb->len;\n\nparse_ntb:\n\ttmp = (__le16 *)ntb_ptr;\n\n\t \n\tif (get_unaligned_le32(tmp) != opts->nth_sign) {\n\t\tINFO(port->func.config->cdev, \"Wrong NTH SIGN, skblen %d\\n\",\n\t\t\tskb->len);\n\t\tprint_hex_dump(KERN_INFO, \"HEAD:\", DUMP_PREFIX_ADDRESS, 32, 1,\n\t\t\t       skb->data, 32, false);\n\n\t\tgoto err;\n\t}\n\ttmp += 2;\n\t \n\tif (get_unaligned_le16(tmp++) != opts->nth_size) {\n\t\tINFO(port->func.config->cdev, \"Wrong NTB headersize\\n\");\n\t\tgoto err;\n\t}\n\ttmp++;  \n\n\tblock_len = get_ncm(&tmp, opts->block_length);\n\t \n\tif (block_len > ntb_max) {\n\t\tINFO(port->func.config->cdev, \"OUT size exceeded\\n\");\n\t\tgoto err;\n\t}\n\n\tndp_index = get_ncm(&tmp, opts->ndp_index);\n\n\t \n\tdo {\n\t\t \n\t\tif (((ndp_index % 4) != 0) ||\n\t\t\t\t(ndp_index < opts->nth_size) ||\n\t\t\t\t(ndp_index > (block_len -\n\t\t\t\t\t      opts->ndp_size))) {\n\t\t\tINFO(port->func.config->cdev, \"Bad index: %#X\\n\",\n\t\t\t     ndp_index);\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\ttmp = (__le16 *)(ntb_ptr + ndp_index);\n\t\tif (get_unaligned_le32(tmp) != ncm->ndp_sign) {\n\t\t\tINFO(port->func.config->cdev, \"Wrong NDP SIGN\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\ttmp += 2;\n\n\t\tndp_len = get_unaligned_le16(tmp++);\n\t\t \n\t\tif ((ndp_len < opts->ndp_size\n\t\t\t\t+ 2 * 2 * (opts->dgram_item_len * 2)) ||\n\t\t\t\t(ndp_len % opts->ndplen_align != 0)) {\n\t\t\tINFO(port->func.config->cdev, \"Bad NDP length: %#X\\n\",\n\t\t\t     ndp_len);\n\t\t\tgoto err;\n\t\t}\n\t\ttmp += opts->reserved1;\n\t\t \n\t\tndp_index = get_ncm(&tmp, opts->next_ndp_index);\n\t\ttmp += opts->reserved2;\n\n\t\tndp_len -= opts->ndp_size;\n\t\tindex2 = get_ncm(&tmp, opts->dgram_item_len);\n\t\tdg_len2 = get_ncm(&tmp, opts->dgram_item_len);\n\t\tdgram_counter = 0;\n\n\t\tdo {\n\t\t\tindex = index2;\n\t\t\t \n\t\t\tif ((index < opts->nth_size) ||\n\t\t\t\t\t(index > block_len - opts->dpe_size)) {\n\t\t\t\tINFO(port->func.config->cdev,\n\t\t\t\t     \"Bad index: %#X\\n\", index);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tdg_len = dg_len2;\n\t\t\t \n\t\t\tif ((dg_len < 14 + crc_len) ||\n\t\t\t\t\t(dg_len > frame_max)) {\n\t\t\t\tINFO(port->func.config->cdev,\n\t\t\t\t     \"Bad dgram length: %#X\\n\", dg_len);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (ncm->is_crc) {\n\t\t\t\tuint32_t crc, crc2;\n\n\t\t\t\tcrc = get_unaligned_le32(ntb_ptr +\n\t\t\t\t\t\t\t index + dg_len -\n\t\t\t\t\t\t\t crc_len);\n\t\t\t\tcrc2 = ~crc32_le(~0,\n\t\t\t\t\t\t ntb_ptr + index,\n\t\t\t\t\t\t dg_len - crc_len);\n\t\t\t\tif (crc != crc2) {\n\t\t\t\t\tINFO(port->func.config->cdev,\n\t\t\t\t\t     \"Bad CRC\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tindex2 = get_ncm(&tmp, opts->dgram_item_len);\n\t\t\tdg_len2 = get_ncm(&tmp, opts->dgram_item_len);\n\n\t\t\t \n\t\t\tif (index2 > block_len - opts->dpe_size) {\n\t\t\t\tINFO(port->func.config->cdev,\n\t\t\t\t     \"Bad index: %#X\\n\", index2);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\t \n\t\t\tskb2 = netdev_alloc_skb_ip_align(ncm->netdev,\n\t\t\t\t\t\t\t dg_len - crc_len);\n\t\t\tif (skb2 == NULL)\n\t\t\t\tgoto err;\n\t\t\tskb_put_data(skb2, ntb_ptr + index,\n\t\t\t\t     dg_len - crc_len);\n\n\t\t\tskb_queue_tail(list, skb2);\n\n\t\t\tndp_len -= 2 * (opts->dgram_item_len * 2);\n\n\t\t\tdgram_counter++;\n\t\t\tif (index2 == 0 || dg_len2 == 0)\n\t\t\t\tbreak;\n\t\t} while (ndp_len > 2 * (opts->dgram_item_len * 2));\n\t} while (ndp_index);\n\n\tVDBG(port->func.config->cdev,\n\t     \"Parsed NTB with %d frames\\n\", dgram_counter);\n\n\tto_process -= block_len;\n\tif (to_process != 0) {\n\t\tntb_ptr = (unsigned char *)(ntb_ptr + block_len);\n\t\tgoto parse_ntb;\n\t}\n\n\tdev_consume_skb_any(skb);\n\n\treturn 0;\nerr:\n\tskb_queue_purge(list);\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\nstatic void ncm_disable(struct usb_function *f)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tDBG(cdev, \"ncm deactivated\\n\");\n\n\tif (ncm->port.in_ep->enabled) {\n\t\tncm->netdev = NULL;\n\t\tgether_disconnect(&ncm->port);\n\t}\n\n\tif (ncm->notify->enabled) {\n\t\tusb_ep_disable(ncm->notify);\n\t\tncm->notify->desc = NULL;\n\t}\n}\n\n \n\n \n\nstatic void ncm_open(struct gether *geth)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(&geth->func);\n\n\tDBG(ncm->port.func.config->cdev, \"%s\\n\", __func__);\n\n\tspin_lock(&ncm->lock);\n\tncm->is_open = true;\n\tncm_notify(ncm);\n\tspin_unlock(&ncm->lock);\n}\n\nstatic void ncm_close(struct gether *geth)\n{\n\tstruct f_ncm\t\t*ncm = func_to_ncm(&geth->func);\n\n\tDBG(ncm->port.func.config->cdev, \"%s\\n\", __func__);\n\n\tspin_lock(&ncm->lock);\n\tncm->is_open = false;\n\tncm_notify(ncm);\n\tspin_unlock(&ncm->lock);\n}\n\n \n\n \n\nstatic int ncm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_ncm\t\t*ncm = func_to_ncm(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus = 0;\n\tstruct usb_ep\t\t*ep;\n\tstruct f_ncm_opts\t*ncm_opts;\n\n\tif (!can_support_ecm(cdev->gadget))\n\t\treturn -EINVAL;\n\n\tncm_opts = container_of(f->fi, struct f_ncm_opts, func_inst);\n\n\tif (cdev->use_os_string) {\n\t\tf->os_desc_table = kzalloc(sizeof(*f->os_desc_table),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!f->os_desc_table)\n\t\t\treturn -ENOMEM;\n\t\tf->os_desc_n = 1;\n\t\tf->os_desc_table[0].os_desc = &ncm_opts->ncm_os_desc;\n\t}\n\n\tmutex_lock(&ncm_opts->lock);\n\tgether_set_gadget(ncm_opts->net, cdev->gadget);\n\tif (!ncm_opts->bound)\n\t\tstatus = gether_register_netdev(ncm_opts->net);\n\tmutex_unlock(&ncm_opts->lock);\n\n\tif (status)\n\t\tgoto fail;\n\n\tncm_opts->bound = true;\n\n\tus = usb_gstrings_attach(cdev, ncm_strings,\n\t\t\t\t ARRAY_SIZE(ncm_string_defs));\n\tif (IS_ERR(us)) {\n\t\tstatus = PTR_ERR(us);\n\t\tgoto fail;\n\t}\n\tncm_control_intf.iInterface = us[STRING_CTRL_IDX].id;\n\tncm_data_nop_intf.iInterface = us[STRING_DATA_IDX].id;\n\tncm_data_intf.iInterface = us[STRING_DATA_IDX].id;\n\tecm_desc.iMACAddress = us[STRING_MAC_IDX].id;\n\tncm_iad_desc.iFunction = us[STRING_IAD_IDX].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tncm->ctrl_id = status;\n\tncm_iad_desc.bFirstInterface = status;\n\n\tncm_control_intf.bInterfaceNumber = status;\n\tncm_union_desc.bMasterInterface0 = status;\n\n\tif (cdev->use_os_string)\n\t\tf->os_desc_table[0].if_id =\n\t\t\tncm_iad_desc.bFirstInterface;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tncm->data_id = status;\n\n\tncm_data_nop_intf.bInterfaceNumber = status;\n\tncm_data_intf.bInterfaceNumber = status;\n\tncm_union_desc.bSlaveInterface0 = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tncm->port.in_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tncm->port.out_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ncm_notify_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tncm->notify = ep;\n\n\tstatus = -ENOMEM;\n\n\t \n\tncm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\n\tif (!ncm->notify_req)\n\t\tgoto fail;\n\tncm->notify_req->buf = kmalloc(NCM_STATUS_BYTECOUNT, GFP_KERNEL);\n\tif (!ncm->notify_req->buf)\n\t\tgoto fail;\n\tncm->notify_req->context = ncm;\n\tncm->notify_req->complete = ncm_notify_complete;\n\n\t \n\ths_ncm_in_desc.bEndpointAddress = fs_ncm_in_desc.bEndpointAddress;\n\ths_ncm_out_desc.bEndpointAddress = fs_ncm_out_desc.bEndpointAddress;\n\ths_ncm_notify_desc.bEndpointAddress =\n\t\tfs_ncm_notify_desc.bEndpointAddress;\n\n\tss_ncm_in_desc.bEndpointAddress = fs_ncm_in_desc.bEndpointAddress;\n\tss_ncm_out_desc.bEndpointAddress = fs_ncm_out_desc.bEndpointAddress;\n\tss_ncm_notify_desc.bEndpointAddress =\n\t\tfs_ncm_notify_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, ncm_fs_function, ncm_hs_function,\n\t\t\tncm_ss_function, ncm_ss_function);\n\tif (status)\n\t\tgoto fail;\n\n\t \n\n\tncm->port.open = ncm_open;\n\tncm->port.close = ncm_close;\n\n\thrtimer_init(&ncm->task_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL_SOFT);\n\tncm->task_timer.function = ncm_tx_timeout;\n\n\tDBG(cdev, \"CDC Network: IN/%s OUT/%s NOTIFY/%s\\n\",\n\t\t\tncm->port.in_ep->name, ncm->port.out_ep->name,\n\t\t\tncm->notify->name);\n\treturn 0;\n\nfail:\n\tkfree(f->os_desc_table);\n\tf->os_desc_n = 0;\n\n\tif (ncm->notify_req) {\n\t\tkfree(ncm->notify_req->buf);\n\t\tusb_ep_free_request(ncm->notify, ncm->notify_req);\n\t}\n\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_ncm_opts *to_f_ncm_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_ncm_opts,\n\t\t\t    func_inst.group);\n}\n\n \nUSB_ETHERNET_CONFIGFS_ITEM(ncm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(ncm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(ncm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(ncm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(ncm);\n\nstatic struct configfs_attribute *ncm_attrs[] = {\n\t&ncm_opts_attr_dev_addr,\n\t&ncm_opts_attr_host_addr,\n\t&ncm_opts_attr_qmult,\n\t&ncm_opts_attr_ifname,\n\tNULL,\n};\n\nstatic const struct config_item_type ncm_func_type = {\n\t.ct_item_ops\t= &ncm_item_ops,\n\t.ct_attrs\t= ncm_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void ncm_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_ncm_opts *opts;\n\n\topts = container_of(f, struct f_ncm_opts, func_inst);\n\tif (opts->bound)\n\t\tgether_cleanup(netdev_priv(opts->net));\n\telse\n\t\tfree_netdev(opts->net);\n\tkfree(opts->ncm_interf_group);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *ncm_alloc_inst(void)\n{\n\tstruct f_ncm_opts *opts;\n\tstruct usb_os_desc *descs[1];\n\tchar *names[1];\n\tstruct config_group *ncm_interf_group;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\topts->ncm_os_desc.ext_compat_id = opts->ncm_ext_compat_id;\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = ncm_free_inst;\n\topts->net = gether_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\tINIT_LIST_HEAD(&opts->ncm_os_desc.ext_prop);\n\n\tdescs[0] = &opts->ncm_os_desc;\n\tnames[0] = \"ncm\";\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &ncm_func_type);\n\tncm_interf_group =\n\t\tusb_os_desc_prepare_interf_dir(&opts->func_inst.group, 1, descs,\n\t\t\t\t\t       names, THIS_MODULE);\n\tif (IS_ERR(ncm_interf_group)) {\n\t\tncm_free_inst(&opts->func_inst);\n\t\treturn ERR_CAST(ncm_interf_group);\n\t}\n\topts->ncm_interf_group = ncm_interf_group;\n\n\treturn &opts->func_inst;\n}\n\nstatic void ncm_free(struct usb_function *f)\n{\n\tstruct f_ncm *ncm;\n\tstruct f_ncm_opts *opts;\n\n\tncm = func_to_ncm(f);\n\topts = container_of(f->fi, struct f_ncm_opts, func_inst);\n\tkfree(ncm);\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void ncm_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_ncm *ncm = func_to_ncm(f);\n\n\tDBG(c->cdev, \"ncm unbind\\n\");\n\n\thrtimer_cancel(&ncm->task_timer);\n\n\tkfree(f->os_desc_table);\n\tf->os_desc_n = 0;\n\n\tncm_string_defs[0].id = 0;\n\tusb_free_all_descriptors(f);\n\n\tif (atomic_read(&ncm->notify_count)) {\n\t\tusb_ep_dequeue(ncm->notify, ncm->notify_req);\n\t\tatomic_set(&ncm->notify_count, 0);\n\t}\n\n\tkfree(ncm->notify_req->buf);\n\tusb_ep_free_request(ncm->notify, ncm->notify_req);\n}\n\nstatic struct usb_function *ncm_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_ncm\t\t*ncm;\n\tstruct f_ncm_opts\t*opts;\n\tint status;\n\n\t \n\tncm = kzalloc(sizeof(*ncm), GFP_KERNEL);\n\tif (!ncm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_ncm_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\n\t \n\tstatus = gether_get_host_addr_cdc(opts->net, ncm->ethaddr,\n\t\t\t\t      sizeof(ncm->ethaddr));\n\tif (status < 12) {  \n\t\tkfree(ncm);\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tncm_string_defs[STRING_MAC_IDX].s = ncm->ethaddr;\n\n\tspin_lock_init(&ncm->lock);\n\tncm_reset_values(ncm);\n\tncm->port.ioport = netdev_priv(opts->net);\n\tmutex_unlock(&opts->lock);\n\tncm->port.is_fixed = true;\n\tncm->port.supports_multi_frame = true;\n\n\tncm->port.func.name = \"cdc_network\";\n\t \n\tncm->port.func.bind = ncm_bind;\n\tncm->port.func.unbind = ncm_unbind;\n\tncm->port.func.set_alt = ncm_set_alt;\n\tncm->port.func.get_alt = ncm_get_alt;\n\tncm->port.func.setup = ncm_setup;\n\tncm->port.func.disable = ncm_disable;\n\tncm->port.func.free_func = ncm_free;\n\n\tncm->port.wrap = ncm_wrap_ntb;\n\tncm->port.unwrap = ncm_unwrap_ntb;\n\n\treturn &ncm->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(ncm, ncm_alloc_inst, ncm_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yauheni Kaliuta\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}