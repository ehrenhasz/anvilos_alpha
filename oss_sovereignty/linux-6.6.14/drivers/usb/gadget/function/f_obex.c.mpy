{
  "module_name": "f_obex.c",
  "hash_id": "43bbb4f47955c583b217b015ff58b861df462fc59ef0e26c6856fec65f732fd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_obex.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n\n#include \"u_serial.h\"\n\n\n \n\nstruct f_obex {\n\tstruct gserial\t\t\tport;\n\tu8\t\t\t\tctrl_id;\n\tu8\t\t\t\tdata_id;\n\tu8\t\t\t\tcur_alt;\n\tu8\t\t\t\tport_num;\n};\n\nstatic inline struct f_obex *func_to_obex(struct usb_function *f)\n{\n\treturn container_of(f, struct f_obex, port.func);\n}\n\nstatic inline struct f_obex *port_to_obex(struct gserial *p)\n{\n\treturn container_of(p, struct f_obex, port);\n}\n\n \n\n#define OBEX_CTRL_IDX\t0\n#define OBEX_DATA_IDX\t1\n\nstatic struct usb_string obex_string_defs[] = {\n\t[OBEX_CTRL_IDX].s\t= \"CDC Object Exchange (OBEX)\",\n\t[OBEX_DATA_IDX].s\t= \"CDC OBEX Data\",\n\t{  },\t \n};\n\nstatic struct usb_gadget_strings obex_string_table = {\n\t.language\t\t= 0x0409,\t \n\t.strings\t\t= obex_string_defs,\n};\n\nstatic struct usb_gadget_strings *obex_strings[] = {\n\t&obex_string_table,\n\tNULL,\n};\n\n \n\nstatic struct usb_interface_descriptor obex_control_intf = {\n\t.bLength\t\t= sizeof(obex_control_intf),\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= 0,\n\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 0,\n\t.bInterfaceClass\t= USB_CLASS_COMM,\n\t.bInterfaceSubClass\t= USB_CDC_SUBCLASS_OBEX,\n};\n\nstatic struct usb_interface_descriptor obex_data_nop_intf = {\n\t.bLength\t\t= sizeof(obex_data_nop_intf),\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= 1,\n\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 0,\n\t.bInterfaceClass\t= USB_CLASS_CDC_DATA,\n};\n\nstatic struct usb_interface_descriptor obex_data_intf = {\n\t.bLength\t\t= sizeof(obex_data_intf),\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= 2,\n\n\t.bAlternateSetting\t= 1,\n\t.bNumEndpoints\t\t= 2,\n\t.bInterfaceClass\t= USB_CLASS_CDC_DATA,\n};\n\nstatic struct usb_cdc_header_desc obex_cdc_header_desc = {\n\t.bLength\t\t= sizeof(obex_cdc_header_desc),\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubType\t= USB_CDC_HEADER_TYPE,\n\t.bcdCDC\t\t\t= cpu_to_le16(0x0120),\n};\n\nstatic struct usb_cdc_union_desc obex_cdc_union_desc = {\n\t.bLength\t\t= sizeof(obex_cdc_union_desc),\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubType\t= USB_CDC_UNION_TYPE,\n\t.bMasterInterface0\t= 1,\n\t.bSlaveInterface0\t= 2,\n};\n\nstatic struct usb_cdc_obex_desc obex_desc = {\n\t.bLength\t\t= sizeof(obex_desc),\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubType\t= USB_CDC_OBEX_TYPE,\n\t.bcdVersion\t\t= cpu_to_le16(0x0100),\n};\n\n \n\nstatic struct usb_endpoint_descriptor obex_hs_ep_out_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize\t\t= cpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor obex_hs_ep_in_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize\t\t= cpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *hs_function[] = {\n\t(struct usb_descriptor_header *) &obex_control_intf,\n\t(struct usb_descriptor_header *) &obex_cdc_header_desc,\n\t(struct usb_descriptor_header *) &obex_desc,\n\t(struct usb_descriptor_header *) &obex_cdc_union_desc,\n\n\t(struct usb_descriptor_header *) &obex_data_nop_intf,\n\t(struct usb_descriptor_header *) &obex_data_intf,\n\t(struct usb_descriptor_header *) &obex_hs_ep_in_desc,\n\t(struct usb_descriptor_header *) &obex_hs_ep_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor obex_fs_ep_in_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor obex_fs_ep_out_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *fs_function[] = {\n\t(struct usb_descriptor_header *) &obex_control_intf,\n\t(struct usb_descriptor_header *) &obex_cdc_header_desc,\n\t(struct usb_descriptor_header *) &obex_desc,\n\t(struct usb_descriptor_header *) &obex_cdc_union_desc,\n\n\t(struct usb_descriptor_header *) &obex_data_nop_intf,\n\t(struct usb_descriptor_header *) &obex_data_intf,\n\t(struct usb_descriptor_header *) &obex_fs_ep_in_desc,\n\t(struct usb_descriptor_header *) &obex_fs_ep_out_desc,\n\tNULL,\n};\n\n \n\nstatic int obex_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_obex\t\t*obex = func_to_obex(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tif (intf == obex->ctrl_id) {\n\t\tif (alt != 0)\n\t\t\tgoto fail;\n\t\t \n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"reset obex ttyGS%d control\\n\", obex->port_num);\n\n\t} else if (intf == obex->data_id) {\n\t\tif (alt > 1)\n\t\t\tgoto fail;\n\n\t\tif (obex->port.in->enabled) {\n\t\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\t\"reset obex ttyGS%d\\n\", obex->port_num);\n\t\t\tgserial_disconnect(&obex->port);\n\t\t}\n\n\t\tif (!obex->port.in->desc || !obex->port.out->desc) {\n\t\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\t\"init obex ttyGS%d\\n\", obex->port_num);\n\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       obex->port.in) ||\n\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       obex->port.out)) {\n\t\t\t\tobex->port.out->desc = NULL;\n\t\t\t\tobex->port.in->desc = NULL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\tif (alt == 1) {\n\t\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\t\"activate obex ttyGS%d\\n\", obex->port_num);\n\t\t\tgserial_connect(&obex->port, obex->port_num);\n\t\t}\n\n\t} else\n\t\tgoto fail;\n\n\tobex->cur_alt = alt;\n\n\treturn 0;\n\nfail:\n\treturn -EINVAL;\n}\n\nstatic int obex_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_obex\t\t*obex = func_to_obex(f);\n\n\treturn obex->cur_alt;\n}\n\nstatic void obex_disable(struct usb_function *f)\n{\n\tstruct f_obex\t*obex = func_to_obex(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tdev_dbg(&cdev->gadget->dev, \"obex ttyGS%d disable\\n\", obex->port_num);\n\tgserial_disconnect(&obex->port);\n}\n\n \n\nstatic void obex_connect(struct gserial *g)\n{\n\tstruct f_obex\t\t*obex = port_to_obex(g);\n\tstruct usb_composite_dev *cdev = g->func.config->cdev;\n\tint\t\t\tstatus;\n\n\tstatus = usb_function_activate(&g->func);\n\tif (status)\n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"obex ttyGS%d function activate --> %d\\n\",\n\t\t\tobex->port_num, status);\n}\n\nstatic void obex_disconnect(struct gserial *g)\n{\n\tstruct f_obex\t\t*obex = port_to_obex(g);\n\tstruct usb_composite_dev *cdev = g->func.config->cdev;\n\tint\t\t\tstatus;\n\n\tstatus = usb_function_deactivate(&g->func);\n\tif (status)\n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"obex ttyGS%d function deactivate --> %d\\n\",\n\t\t\tobex->port_num, status);\n}\n\n \n\n \nstatic inline bool can_support_obex(struct usb_configuration *c)\n{\n\t \n\tif (!gadget_is_altset_supported(c->cdev->gadget))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\nstatic int obex_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_obex\t\t*obex = func_to_obex(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\tif (!can_support_obex(c))\n\t\treturn -EINVAL;\n\n\tus = usb_gstrings_attach(cdev, obex_strings,\n\t\t\t\t ARRAY_SIZE(obex_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\tobex_control_intf.iInterface = us[OBEX_CTRL_IDX].id;\n\tobex_data_nop_intf.iInterface = us[OBEX_DATA_IDX].id;\n\tobex_data_intf.iInterface = us[OBEX_DATA_IDX].id;\n\n\t \n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tobex->ctrl_id = status;\n\n\tobex_control_intf.bInterfaceNumber = status;\n\tobex_cdc_union_desc.bMasterInterface0 = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tobex->data_id = status;\n\n\tobex_data_nop_intf.bInterfaceNumber = status;\n\tobex_data_intf.bInterfaceNumber = status;\n\tobex_cdc_union_desc.bSlaveInterface0 = status;\n\n\t \n\n\tstatus = -ENODEV;\n\tep = usb_ep_autoconfig(cdev->gadget, &obex_fs_ep_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tobex->port.in = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &obex_fs_ep_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tobex->port.out = ep;\n\n\t \n\n\tobex_hs_ep_in_desc.bEndpointAddress =\n\t\tobex_fs_ep_in_desc.bEndpointAddress;\n\tobex_hs_ep_out_desc.bEndpointAddress =\n\t\tobex_fs_ep_out_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, fs_function, hs_function, NULL,\n\t\t\t\t\tNULL);\n\tif (status)\n\t\tgoto fail;\n\n\tdev_dbg(&cdev->gadget->dev, \"obex ttyGS%d: IN/%s OUT/%s\\n\",\n\t\tobex->port_num,\n\t\tobex->port.in->name, obex->port.out->name);\n\n\treturn 0;\n\nfail:\n\tERROR(cdev, \"%s/%p: can't bind, err %d\\n\", f->name, f, status);\n\n\treturn status;\n}\n\nstatic inline struct f_serial_opts *to_f_serial_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_serial_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void obex_attr_release(struct config_item *item)\n{\n\tstruct f_serial_opts *opts = to_f_serial_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations obex_item_ops = {\n\t.release\t= obex_attr_release,\n};\n\nstatic ssize_t f_obex_port_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_f_serial_opts(item)->port_num);\n}\n\nCONFIGFS_ATTR_RO(f_obex_, port_num);\n\nstatic struct configfs_attribute *acm_attrs[] = {\n\t&f_obex_attr_port_num,\n\tNULL,\n};\n\nstatic const struct config_item_type obex_func_type = {\n\t.ct_item_ops\t= &obex_item_ops,\n\t.ct_attrs\t= acm_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void obex_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_serial_opts *opts;\n\n\topts = container_of(f, struct f_serial_opts, func_inst);\n\tgserial_free_line(opts->port_num);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *obex_alloc_inst(void)\n{\n\tstruct f_serial_opts *opts;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.free_func_inst = obex_free_inst;\n\tret = gserial_alloc_line_no_console(&opts->port_num);\n\tif (ret) {\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &obex_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void obex_free(struct usb_function *f)\n{\n\tstruct f_obex *obex;\n\n\tobex = func_to_obex(f);\n\tkfree(obex);\n}\n\nstatic void obex_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *obex_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_obex\t*obex;\n\tstruct f_serial_opts *opts;\n\n\t \n\tobex = kzalloc(sizeof(*obex), GFP_KERNEL);\n\tif (!obex)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_serial_opts, func_inst);\n\n\tobex->port_num = opts->port_num;\n\n\tobex->port.connect = obex_connect;\n\tobex->port.disconnect = obex_disconnect;\n\n\tobex->port.func.name = \"obex\";\n\t \n\tobex->port.func.bind = obex_bind;\n\tobex->port.func.unbind = obex_unbind;\n\tobex->port.func.set_alt = obex_set_alt;\n\tobex->port.func.get_alt = obex_get_alt;\n\tobex->port.func.disable = obex_disable;\n\tobex->port.func.free_func = obex_free;\n\tobex->port.func.bind_deactivated = true;\n\n\treturn &obex->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(obex, obex_alloc_inst, obex_alloc);\nMODULE_AUTHOR(\"Felipe Balbi\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}