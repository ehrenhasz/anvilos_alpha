{
  "module_name": "f_phonet.c",
  "hash_id": "6422cde74aaea237b5e134c6f6f912362d7046540ef2ea3e61d3b0e1cebc5575",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_phonet.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_phonet.h>\n#include <linux/if_arp.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/composite.h>\n\n#include \"u_phonet.h\"\n#include \"u_ether.h\"\n\n#define PN_MEDIA_USB\t0x1B\n#define MAXPACKET\t512\n#if (PAGE_SIZE % MAXPACKET)\n#error MAXPACKET must divide PAGE_SIZE!\n#endif\n\n \n\nstruct phonet_port {\n\tstruct f_phonet\t\t\t*usb;\n\tspinlock_t\t\t\tlock;\n};\n\nstruct f_phonet {\n\tstruct usb_function\t\tfunction;\n\tstruct {\n\t\tstruct sk_buff\t\t*skb;\n\t\tspinlock_t\t\tlock;\n\t} rx;\n\tstruct net_device\t\t*dev;\n\tstruct usb_ep\t\t\t*in_ep, *out_ep;\n\n\tstruct usb_request\t\t*in_req;\n\tstruct usb_request\t\t*out_reqv[];\n};\n\nstatic int phonet_rxq_size = 17;\n\nstatic inline struct f_phonet *func_to_pn(struct usb_function *f)\n{\n\treturn container_of(f, struct f_phonet, function);\n}\n\n \n\n#define USB_CDC_SUBCLASS_PHONET\t0xfe\n#define USB_CDC_PHONET_TYPE\t0xab\n\nstatic struct usb_interface_descriptor\npn_control_intf_desc = {\n\t.bLength =\t\tsizeof pn_control_intf_desc,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_PHONET,\n};\n\nstatic const struct usb_cdc_header_desc\npn_header_desc = {\n\t.bLength =\t\tsizeof pn_header_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic const struct usb_cdc_header_desc\npn_phonet_desc = {\n\t.bLength =\t\tsizeof pn_phonet_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_PHONET_TYPE,\n\t.bcdCDC =\t\tcpu_to_le16(0x1505),  \n};\n\nstatic struct usb_cdc_union_desc\npn_union_desc = {\n\t.bLength =\t\tsizeof pn_union_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_UNION_TYPE,\n\n\t \n\t \n};\n\nstatic struct usb_interface_descriptor\npn_data_nop_intf_desc = {\n\t.bLength =\t\tsizeof pn_data_nop_intf_desc,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n};\n\nstatic struct usb_interface_descriptor\npn_data_intf_desc = {\n\t.bLength =\t\tsizeof pn_data_intf_desc,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n};\n\nstatic struct usb_endpoint_descriptor\npn_fs_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor\npn_hs_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(MAXPACKET),\n};\n\nstatic struct usb_endpoint_descriptor\npn_fs_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor\npn_hs_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *fs_pn_function[] = {\n\t(struct usb_descriptor_header *) &pn_control_intf_desc,\n\t(struct usb_descriptor_header *) &pn_header_desc,\n\t(struct usb_descriptor_header *) &pn_phonet_desc,\n\t(struct usb_descriptor_header *) &pn_union_desc,\n\t(struct usb_descriptor_header *) &pn_data_nop_intf_desc,\n\t(struct usb_descriptor_header *) &pn_data_intf_desc,\n\t(struct usb_descriptor_header *) &pn_fs_sink_desc,\n\t(struct usb_descriptor_header *) &pn_fs_source_desc,\n\tNULL,\n};\n\nstatic struct usb_descriptor_header *hs_pn_function[] = {\n\t(struct usb_descriptor_header *) &pn_control_intf_desc,\n\t(struct usb_descriptor_header *) &pn_header_desc,\n\t(struct usb_descriptor_header *) &pn_phonet_desc,\n\t(struct usb_descriptor_header *) &pn_union_desc,\n\t(struct usb_descriptor_header *) &pn_data_nop_intf_desc,\n\t(struct usb_descriptor_header *) &pn_data_intf_desc,\n\t(struct usb_descriptor_header *) &pn_hs_sink_desc,\n\t(struct usb_descriptor_header *) &pn_hs_source_desc,\n\tNULL,\n};\n\n \n\nstatic int pn_net_open(struct net_device *dev)\n{\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nstatic int pn_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic void pn_tx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_phonet *fp = ep->driver_data;\n\tstruct net_device *dev = fp->dev;\n\tstruct sk_buff *skb = req->context;\n\n\tswitch (req->status) {\n\tcase 0:\n\t\tdev->stats.tx_packets++;\n\t\tdev->stats.tx_bytes += skb->len;\n\t\tbreak;\n\n\tcase -ESHUTDOWN:  \n\tcase -ECONNRESET:  \n\t\tdev->stats.tx_aborted_errors++;\n\t\tfallthrough;\n\tdefault:\n\t\tdev->stats.tx_errors++;\n\t}\n\n\tdev_kfree_skb_any(skb);\n\tnetif_wake_queue(dev);\n}\n\nstatic netdev_tx_t pn_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct phonet_port *port = netdev_priv(dev);\n\tstruct f_phonet *fp;\n\tstruct usb_request *req;\n\tunsigned long flags;\n\n\tif (skb->protocol != htons(ETH_P_PHONET))\n\t\tgoto out;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tfp = port->usb;\n\tif (unlikely(!fp))  \n\t\tgoto out_unlock;\n\n\treq = fp->in_req;\n\treq->buf = skb->data;\n\treq->length = skb->len;\n\treq->complete = pn_tx_complete;\n\treq->zero = 1;\n\treq->context = skb;\n\n\tif (unlikely(usb_ep_queue(fp->in_ep, req, GFP_ATOMIC)))\n\t\tgoto out_unlock;\n\n\tnetif_stop_queue(dev);\n\tskb = NULL;\n\nout_unlock:\n\tspin_unlock_irqrestore(&port->lock, flags);\nout:\n\tif (unlikely(skb)) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.tx_dropped++;\n\t}\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops pn_netdev_ops = {\n\t.ndo_open\t= pn_net_open,\n\t.ndo_stop\t= pn_net_close,\n\t.ndo_start_xmit\t= pn_net_xmit,\n};\n\nstatic void pn_net_setup(struct net_device *dev)\n{\n\tconst u8 addr = PN_MEDIA_USB;\n\n\tdev->features\t\t= 0;\n\tdev->type\t\t= ARPHRD_PHONET;\n\tdev->flags\t\t= IFF_POINTOPOINT | IFF_NOARP;\n\tdev->mtu\t\t= PHONET_DEV_MTU;\n\tdev->min_mtu\t\t= PHONET_MIN_MTU;\n\tdev->max_mtu\t\t= PHONET_MAX_MTU;\n\tdev->hard_header_len\t= 1;\n\tdev->addr_len\t\t= 1;\n\tdev_addr_set(dev, &addr);\n\n\tdev->tx_queue_len\t= 1;\n\n\tdev->netdev_ops\t\t= &pn_netdev_ops;\n\tdev->needs_free_netdev\t= true;\n\tdev->header_ops\t\t= &phonet_header_ops;\n}\n\n \n\n \nstatic int\npn_rx_submit(struct f_phonet *fp, struct usb_request *req, gfp_t gfp_flags)\n{\n\tstruct page *page;\n\tint err;\n\n\tpage = __dev_alloc_page(gfp_flags | __GFP_NOMEMALLOC);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\treq->buf = page_address(page);\n\treq->length = PAGE_SIZE;\n\treq->context = page;\n\n\terr = usb_ep_queue(fp->out_ep, req, gfp_flags);\n\tif (unlikely(err))\n\t\tput_page(page);\n\treturn err;\n}\n\nstatic void pn_rx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_phonet *fp = ep->driver_data;\n\tstruct net_device *dev = fp->dev;\n\tstruct page *page = req->context;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\tspin_lock_irqsave(&fp->rx.lock, flags);\n\t\tskb = fp->rx.skb;\n\t\tif (!skb)\n\t\t\tskb = fp->rx.skb = netdev_alloc_skb(dev, 12);\n\t\tif (req->actual < req->length)  \n\t\t\tfp->rx.skb = NULL;\n\t\tspin_unlock_irqrestore(&fp->rx.lock, flags);\n\n\t\tif (unlikely(!skb))\n\t\t\tbreak;\n\n\t\tif (skb->len == 0) {  \n\t\t\tskb->protocol = htons(ETH_P_PHONET);\n\t\t\tskb_reset_mac_header(skb);\n\t\t\t \n\t\t\tskb_put_data(skb, page_address(page), 1);\n\t\t}\n\n\t\tskb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page,\n\t\t\t\tskb->len <= 1, req->actual, PAGE_SIZE);\n\t\tpage = NULL;\n\n\t\tif (req->actual < req->length) {  \n\t\t\tskb->dev = dev;\n\t\t\tdev->stats.rx_packets++;\n\t\t\tdev->stats.rx_bytes += skb->len;\n\n\t\t\tnetif_rx(skb);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase -ESHUTDOWN:  \n\tcase -ECONNABORTED:  \n\tcase -ECONNRESET:  \n\t\treq = NULL;\n\t\tbreak;\n\n\t \n\tcase -EOVERFLOW:  \n\t\tdev->stats.rx_over_errors++;\n\t\tfallthrough;\n\tdefault:\n\t\tdev->stats.rx_errors++;\n\t\tbreak;\n\t}\n\n\tif (page)\n\t\tput_page(page);\n\tif (req)\n\t\tpn_rx_submit(fp, req, GFP_ATOMIC);\n}\n\n \n\nstatic void __pn_reset(struct usb_function *f)\n{\n\tstruct f_phonet *fp = func_to_pn(f);\n\tstruct net_device *dev = fp->dev;\n\tstruct phonet_port *port = netdev_priv(dev);\n\n\tnetif_carrier_off(dev);\n\tport->usb = NULL;\n\n\tusb_ep_disable(fp->out_ep);\n\tusb_ep_disable(fp->in_ep);\n\tif (fp->rx.skb) {\n\t\tdev_kfree_skb_irq(fp->rx.skb);\n\t\tfp->rx.skb = NULL;\n\t}\n}\n\nstatic int pn_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_phonet *fp = func_to_pn(f);\n\tstruct usb_gadget *gadget = fp->function.config->cdev->gadget;\n\n\tif (intf == pn_control_intf_desc.bInterfaceNumber)\n\t\t \n\t\treturn (alt > 0) ? -EINVAL : 0;\n\n\tif (intf == pn_data_intf_desc.bInterfaceNumber) {\n\t\tstruct net_device *dev = fp->dev;\n\t\tstruct phonet_port *port = netdev_priv(dev);\n\n\t\t \n\t\tif (alt > 1)\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock(&port->lock);\n\n\t\tif (fp->in_ep->enabled)\n\t\t\t__pn_reset(f);\n\n\t\tif (alt == 1) {\n\t\t\tint i;\n\n\t\t\tif (config_ep_by_speed(gadget, f, fp->in_ep) ||\n\t\t\t    config_ep_by_speed(gadget, f, fp->out_ep)) {\n\t\t\t\tfp->in_ep->desc = NULL;\n\t\t\t\tfp->out_ep->desc = NULL;\n\t\t\t\tspin_unlock(&port->lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tusb_ep_enable(fp->out_ep);\n\t\t\tusb_ep_enable(fp->in_ep);\n\n\t\t\tport->usb = fp;\n\t\t\tfp->out_ep->driver_data = fp;\n\t\t\tfp->in_ep->driver_data = fp;\n\n\t\t\tnetif_carrier_on(dev);\n\t\t\tfor (i = 0; i < phonet_rxq_size; i++)\n\t\t\t\tpn_rx_submit(fp, fp->out_reqv[i], GFP_ATOMIC);\n\t\t}\n\t\tspin_unlock(&port->lock);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int pn_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_phonet *fp = func_to_pn(f);\n\n\tif (intf == pn_control_intf_desc.bInterfaceNumber)\n\t\treturn 0;\n\n\tif (intf == pn_data_intf_desc.bInterfaceNumber) {\n\t\tstruct phonet_port *port = netdev_priv(fp->dev);\n\t\tu8 alt;\n\n\t\tspin_lock(&port->lock);\n\t\talt = port->usb != NULL;\n\t\tspin_unlock(&port->lock);\n\t\treturn alt;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void pn_disconnect(struct usb_function *f)\n{\n\tstruct f_phonet *fp = func_to_pn(f);\n\tstruct phonet_port *port = netdev_priv(fp->dev);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\t__pn_reset(f);\n\tspin_unlock_irqrestore(&port->lock, flags);\n}\n\n \n\nstatic int pn_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct f_phonet *fp = func_to_pn(f);\n\tstruct usb_ep *ep;\n\tint status, i;\n\n\tstruct f_phonet_opts *phonet_opts;\n\n\tphonet_opts = container_of(f->fi, struct f_phonet_opts, func_inst);\n\n\t \n\tif (!phonet_opts->bound) {\n\t\tgphonet_set_gadget(phonet_opts->net, gadget);\n\t\tstatus = gphonet_register_netdev(phonet_opts->net);\n\t\tif (status)\n\t\t\treturn status;\n\t\tphonet_opts->bound = true;\n\t}\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto err;\n\tpn_control_intf_desc.bInterfaceNumber = status;\n\tpn_union_desc.bMasterInterface0 = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto err;\n\tpn_data_nop_intf_desc.bInterfaceNumber = status;\n\tpn_data_intf_desc.bInterfaceNumber = status;\n\tpn_union_desc.bSlaveInterface0 = status;\n\n\t \n\tstatus = -ENODEV;\n\tep = usb_ep_autoconfig(gadget, &pn_fs_sink_desc);\n\tif (!ep)\n\t\tgoto err;\n\tfp->out_ep = ep;\n\n\tep = usb_ep_autoconfig(gadget, &pn_fs_source_desc);\n\tif (!ep)\n\t\tgoto err;\n\tfp->in_ep = ep;\n\n\tpn_hs_sink_desc.bEndpointAddress = pn_fs_sink_desc.bEndpointAddress;\n\tpn_hs_source_desc.bEndpointAddress = pn_fs_source_desc.bEndpointAddress;\n\n\t \n\tstatus = usb_assign_descriptors(f, fs_pn_function, hs_pn_function,\n\t\t\tNULL, NULL);\n\tif (status)\n\t\tgoto err;\n\n\t \n\tstatus = -ENOMEM;\n\tfor (i = 0; i < phonet_rxq_size; i++) {\n\t\tstruct usb_request *req;\n\n\t\treq = usb_ep_alloc_request(fp->out_ep, GFP_KERNEL);\n\t\tif (!req)\n\t\t\tgoto err_req;\n\n\t\treq->complete = pn_rx_complete;\n\t\tfp->out_reqv[i] = req;\n\t}\n\n\t \n\tfp->in_req = usb_ep_alloc_request(fp->in_ep, GFP_KERNEL);\n\tif (!fp->in_req)\n\t\tgoto err_req;\n\n\tINFO(cdev, \"USB CDC Phonet function\\n\");\n\tINFO(cdev, \"using %s, OUT %s, IN %s\\n\", cdev->gadget->name,\n\t\tfp->out_ep->name, fp->in_ep->name);\n\treturn 0;\n\nerr_req:\n\tfor (i = 0; i < phonet_rxq_size && fp->out_reqv[i]; i++)\n\t\tusb_ep_free_request(fp->out_ep, fp->out_reqv[i]);\n\tusb_free_all_descriptors(f);\nerr:\n\tERROR(cdev, \"USB CDC Phonet: cannot autoconfigure\\n\");\n\treturn status;\n}\n\nstatic inline struct f_phonet_opts *to_f_phonet_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_phonet_opts,\n\t\t\tfunc_inst.group);\n}\n\nstatic void phonet_attr_release(struct config_item *item)\n{\n\tstruct f_phonet_opts *opts = to_f_phonet_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations phonet_item_ops = {\n\t.release\t\t= phonet_attr_release,\n};\n\nstatic ssize_t f_phonet_ifname_show(struct config_item *item, char *page)\n{\n\treturn gether_get_ifname(to_f_phonet_opts(item)->net, page, PAGE_SIZE);\n}\n\nCONFIGFS_ATTR_RO(f_phonet_, ifname);\n\nstatic struct configfs_attribute *phonet_attrs[] = {\n\t&f_phonet_attr_ifname,\n\tNULL,\n};\n\nstatic const struct config_item_type phonet_func_type = {\n\t.ct_item_ops\t= &phonet_item_ops,\n\t.ct_attrs\t= phonet_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void phonet_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_phonet_opts *opts;\n\n\topts = container_of(f, struct f_phonet_opts, func_inst);\n\tif (opts->bound)\n\t\tgphonet_cleanup(opts->net);\n\telse\n\t\tfree_netdev(opts->net);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *phonet_alloc_inst(void)\n{\n\tstruct f_phonet_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.free_func_inst = phonet_free_inst;\n\topts->net = gphonet_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t&phonet_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void phonet_free(struct usb_function *f)\n{\n\tstruct f_phonet *phonet;\n\n\tphonet = func_to_pn(f);\n\tkfree(phonet);\n}\n\nstatic void pn_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_phonet *fp = func_to_pn(f);\n\tint i;\n\n\t \n\tif (fp->in_req)\n\t\tusb_ep_free_request(fp->in_ep, fp->in_req);\n\tfor (i = 0; i < phonet_rxq_size; i++)\n\t\tif (fp->out_reqv[i])\n\t\t\tusb_ep_free_request(fp->out_ep, fp->out_reqv[i]);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *phonet_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_phonet *fp;\n\tstruct f_phonet_opts *opts;\n\n\tfp = kzalloc(struct_size(fp, out_reqv, phonet_rxq_size), GFP_KERNEL);\n\tif (!fp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_phonet_opts, func_inst);\n\n\tfp->dev = opts->net;\n\tfp->function.name = \"phonet\";\n\tfp->function.bind = pn_bind;\n\tfp->function.unbind = pn_unbind;\n\tfp->function.set_alt = pn_set_alt;\n\tfp->function.get_alt = pn_get_alt;\n\tfp->function.disable = pn_disconnect;\n\tfp->function.free_func = phonet_free;\n\tspin_lock_init(&fp->rx.lock);\n\n\treturn &fp->function;\n}\n\nstruct net_device *gphonet_setup_default(void)\n{\n\tstruct net_device *dev;\n\tstruct phonet_port *port;\n\n\t \n\tdev = alloc_netdev(sizeof(*port), \"upnlink%d\", NET_NAME_UNKNOWN,\n\t\t\t   pn_net_setup);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tport = netdev_priv(dev);\n\tspin_lock_init(&port->lock);\n\tnetif_carrier_off(dev);\n\n\treturn dev;\n}\n\nvoid gphonet_set_gadget(struct net_device *net, struct usb_gadget *g)\n{\n\tSET_NETDEV_DEV(net, &g->dev);\n}\n\nint gphonet_register_netdev(struct net_device *net)\n{\n\tint status;\n\n\tstatus = register_netdev(net);\n\tif (status)\n\t\tfree_netdev(net);\n\n\treturn status;\n}\n\nvoid gphonet_cleanup(struct net_device *dev)\n{\n\tunregister_netdev(dev);\n}\n\nDECLARE_USB_FUNCTION_INIT(phonet, phonet_alloc_inst, phonet_alloc);\nMODULE_AUTHOR(\"R\u00e9mi Denis-Courmont\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}