{
  "module_name": "f_midi.c",
  "hash_id": "99179eb0f7d82bb415713a4dca71cd89df76fb4def9e9e9b008cae373f20f3e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_midi.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kfifo.h>\n#include <linux/spinlock.h>\n\n#include <sound/core.h>\n#include <sound/initval.h>\n#include <sound/rawmidi.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi.h>\n\n#include \"u_f.h\"\n#include \"u_midi.h\"\n\nMODULE_AUTHOR(\"Ben Williamson\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic const char f_midi_shortname[] = \"f_midi\";\nstatic const char f_midi_longname[] = \"MIDI Gadget\";\n\n \n#define MAX_PORTS 16\n\n \nenum {\n\tSTATE_INITIAL = 0,\t \n\tSTATE_1PARAM,\n\tSTATE_2PARAM_1,\n\tSTATE_2PARAM_2,\n\tSTATE_SYSEX_0,\n\tSTATE_SYSEX_1,\n\tSTATE_SYSEX_2,\n\tSTATE_REAL_TIME,\n\tSTATE_FINISHED,\t\t \n};\n\n \nstruct gmidi_in_port {\n\tstruct snd_rawmidi_substream *substream;\n\tint active;\n\tuint8_t cable;\n\tuint8_t state;\n\tuint8_t data[2];\n};\n\nstruct f_midi {\n\tstruct usb_function\tfunc;\n\tstruct usb_gadget\t*gadget;\n\tstruct usb_ep\t\t*in_ep, *out_ep;\n\tstruct snd_card\t\t*card;\n\tstruct snd_rawmidi\t*rmidi;\n\tu8\t\t\tms_id;\n\n\tstruct snd_rawmidi_substream *out_substream[MAX_PORTS];\n\n\tunsigned long\t\tout_triggered;\n\tstruct work_struct\twork;\n\tunsigned int in_ports;\n\tunsigned int out_ports;\n\tint index;\n\tchar *id;\n\tunsigned int buflen, qlen;\n\t \n\tDECLARE_KFIFO_PTR(in_req_fifo, struct usb_request *);\n\tspinlock_t transmit_lock;\n\tunsigned int in_last_port;\n\tunsigned char free_ref;\n\n\tstruct gmidi_in_port\tin_ports_array[ ];\n};\n\nstatic inline struct f_midi *func_to_midi(struct usb_function *f)\n{\n\treturn container_of(f, struct f_midi, func);\n}\n\nstatic void f_midi_transmit(struct f_midi *midi);\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi);\nstatic void f_midi_free_inst(struct usb_function_instance *f);\n\nDECLARE_UAC_AC_HEADER_DESCRIPTOR(1);\nDECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(1);\nDECLARE_USB_MS_ENDPOINT_DESCRIPTOR(16);\n\n \nstatic struct usb_interface_descriptor ac_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t \n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n\t \n};\n\n \nstatic struct uac1_ac_header_descriptor_1 ac_header_desc = {\n\t.bLength =\t\tUAC_DT_AC_HEADER_SIZE(1),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdADC =\t\tcpu_to_le16(0x0100),\n\t.wTotalLength =\t\tcpu_to_le16(UAC_DT_AC_HEADER_SIZE(1)),\n\t.bInCollection =\t1,\n\t \n};\n\n \nstatic struct usb_interface_descriptor ms_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_MIDISTREAMING,\n\t \n};\n\n \nstatic struct usb_ms_header_descriptor ms_header_desc = {\n\t.bLength =\t\tUSB_DT_MS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdMSC =\t\tcpu_to_le16(0x0100),\n\t \n};\n\n \nstatic struct usb_endpoint_descriptor bulk_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_out_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_out_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t \n\t \n};\n\n \nstatic struct usb_ms_endpoint_descriptor_16 ms_out_desc = {\n\t \n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t \n\t \n};\n\n \nstatic struct usb_endpoint_descriptor bulk_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bulk_in_ss_comp_desc = {\n\t.bLength                = sizeof(bulk_in_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n\t \n\t \n};\n\n \nstatic struct usb_ms_endpoint_descriptor_16 ms_in_desc = {\n\t \n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t \n\t \n};\n\n \n\n#define STRING_FUNC_IDX\t\t\t0\n\nstatic struct usb_string midi_string_defs[] = {\n\t[STRING_FUNC_IDX].s = \"MIDI function\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings midi_stringtab = {\n\t.language\t= 0x0409,\t \n\t.strings\t= midi_string_defs,\n};\n\nstatic struct usb_gadget_strings *midi_strings[] = {\n\t&midi_stringtab,\n\tNULL,\n};\n\nstatic inline struct usb_request *midi_alloc_ep_req(struct usb_ep *ep,\n\t\t\t\t\t\t    unsigned length)\n{\n\treturn alloc_ep_req(ep, length);\n}\n\nstatic const uint8_t f_midi_cin_length[] = {\n\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n};\n\n \nstatic void f_midi_read_data(struct usb_ep *ep, int cable,\n\t\t\t     uint8_t *data, int length)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct snd_rawmidi_substream *substream = midi->out_substream[cable];\n\n\tif (!substream)\n\t\t \n\t\treturn;\n\n\tif (!test_bit(cable, &midi->out_triggered))\n\t\treturn;\n\n\tsnd_rawmidi_receive(substream, data, length);\n}\n\nstatic void f_midi_handle_out_data(struct usb_ep *ep, struct usb_request *req)\n{\n\tunsigned int i;\n\tu8 *buf = req->buf;\n\n\tfor (i = 0; i + 3 < req->actual; i += 4)\n\t\tif (buf[i] != 0) {\n\t\t\tint cable = buf[i] >> 4;\n\t\t\tint length = f_midi_cin_length[buf[i] & 0x0f];\n\t\t\tf_midi_read_data(ep, cable, &buf[i + 1], length);\n\t\t}\n}\n\nstatic void\nf_midi_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_midi *midi = ep->driver_data;\n\tstruct usb_composite_dev *cdev = midi->func.config->cdev;\n\tint status = req->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t  \n\t\tif (ep == midi->out_ep) {\n\t\t\t \n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t} else if (ep == midi->in_ep) {\n\t\t\t \n\t\t\treq->length = 0;\n\t\t\tf_midi_transmit(midi);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase -ECONNABORTED:\t \n\tcase -ECONNRESET:\t \n\tcase -ESHUTDOWN:\t \n\t\tVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\n\t\t\t\treq->actual, req->length);\n\t\tif (ep == midi->out_ep) {\n\t\t\tf_midi_handle_out_data(ep, req);\n\t\t\t \n\t\t\tfree_ep_req(ep, req);\n\t\t}\n\t\treturn;\n\n\tcase -EOVERFLOW:\t \n\tdefault:\n\t\tDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tbreak;\n\tcase -EREMOTEIO:\t \n\t\tbreak;\n\t}\n\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (status) {\n\t\tERROR(cdev, \"kill %s:  resubmit %d bytes --> %d\\n\",\n\t\t\t\tep->name, req->length, status);\n\t\tusb_ep_set_halt(ep);\n\t\t \n\t}\n}\n\nstatic void f_midi_drop_out_substreams(struct f_midi *midi)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < midi->in_ports; i++) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (port->active && substream)\n\t\t\tsnd_rawmidi_drop_output(substream);\n\t}\n}\n\nstatic int f_midi_start_ep(struct f_midi *midi,\n\t\t\t   struct usb_function *f,\n\t\t\t   struct usb_ep *ep)\n{\n\tint err;\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tusb_ep_disable(ep);\n\n\terr = config_ep_by_speed(midi->gadget, f, ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't configure %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\terr = usb_ep_enable(ep);\n\tif (err) {\n\t\tERROR(cdev, \"can't start %s: %d\\n\", ep->name, err);\n\t\treturn err;\n\t}\n\n\tep->driver_data = midi;\n\n\treturn 0;\n}\n\nstatic int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t \n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t \n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t \n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void f_midi_disable(struct usb_function *f)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request *req = NULL;\n\n\tDBG(cdev, \"disable\\n\");\n\n\t \n\tusb_ep_disable(midi->in_ep);\n\tusb_ep_disable(midi->out_ep);\n\n\t \n\twhile (kfifo_get(&midi->in_req_fifo, &req))\n\t\tfree_ep_req(midi->in_ep, req);\n\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic int f_midi_snd_free(struct snd_device *device)\n{\n\treturn 0;\n}\n\n \nstatic void f_midi_transmit_byte(struct usb_request *req,\n\t\t\t\t struct gmidi_in_port *port, uint8_t b)\n{\n\tuint8_t p[4] = { port->cable << 4, 0, 0, 0 };\n\tuint8_t next_state = STATE_INITIAL;\n\n\tswitch (b) {\n\tcase 0xf8 ... 0xff:\n\t\t \n\t\tp[0] |= 0x0f;\n\t\tp[1] = b;\n\t\tnext_state = port->state;\n\t\tport->state = STATE_REAL_TIME;\n\t\tbreak;\n\n\tcase 0xf7:\n\t\t \n\t\tswitch (port->state) {\n\t\tcase STATE_SYSEX_0:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tp[0] |= 0x06;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x07;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tnext_state = port->state;\n\t\t\tport->state = STATE_INITIAL;\n\t\t}\n\t\tbreak;\n\n\tcase 0xf0 ... 0xf6:\n\t\t \n\t\tport->data[0] = port->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->data[1] = 0;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf6;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x80 ... 0xef:\n\t\t \n\t\tport->data[0] = b;\n\t\tport->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tnext_state = STATE_1PARAM;\n\t\telse\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\tbreak;\n\n\tcase 0x00 ... 0x7f:\n\t\t \n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x02;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = b;\n\t\t\t \n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x03;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\t \n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x04;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\tnext_state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (next_state == STATE_FINISHED ||\n\t    port->state == STATE_SYSEX_2 ||\n\t    port->state == STATE_1PARAM ||\n\t    port->state == STATE_2PARAM_2 ||\n\t    port->state == STATE_REAL_TIME) {\n\n\t\tunsigned int length = req->length;\n\t\tu8 *buf = (u8 *)req->buf + length;\n\n\t\tmemcpy(buf, p, sizeof(p));\n\t\treq->length = length + sizeof(p);\n\n\t\tif (next_state == STATE_FINISHED) {\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tport->data[0] = port->data[1] = 0;\n\t\t}\n\t}\n\n\tport->state = next_state;\n}\n\nstatic int f_midi_do_transmit(struct f_midi *midi, struct usb_ep *ep)\n{\n\tstruct usb_request *req = NULL;\n\tunsigned int len, i;\n\tbool active = false;\n\tint err;\n\n\t \n\tlen = kfifo_peek(&midi->in_req_fifo, &req);\n\tif (len != 1) {\n\t\tERROR(midi, \"%s: Couldn't get usb request\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tif (req->length > 0)\n\t\treturn 0;\n\n\tfor (i = midi->in_last_port; i < midi->in_ports; ++i) {\n\t\tstruct gmidi_in_port *port = midi->in_ports_array + i;\n\t\tstruct snd_rawmidi_substream *substream = port->substream;\n\n\t\tif (!port->active || !substream)\n\t\t\tcontinue;\n\n\t\twhile (req->length + 3 < midi->buflen) {\n\t\t\tuint8_t b;\n\n\t\t\tif (snd_rawmidi_transmit(substream, &b, 1) != 1) {\n\t\t\t\tport->active = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf_midi_transmit_byte(req, port, b);\n\t\t}\n\n\t\tactive = !!port->active;\n\t\tif (active)\n\t\t\tbreak;\n\t}\n\tmidi->in_last_port = active ? i : 0;\n\n\tif (req->length <= 0)\n\t\tgoto done;\n\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tERROR(midi, \"%s failed to queue req: %d\\n\",\n\t\t      midi->in_ep->name, err);\n\t\treq->length = 0;  \n\t} else {\n\t\t \n\t\tkfifo_skip(&midi->in_req_fifo);\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\ndone:\n\treturn active;\n}\n\nstatic void f_midi_transmit(struct f_midi *midi)\n{\n\tstruct usb_ep *ep = midi->in_ep;\n\tint ret;\n\tunsigned long flags;\n\n\t \n\tif (!ep || !ep->enabled)\n\t\tgoto drop_out;\n\n\tspin_lock_irqsave(&midi->transmit_lock, flags);\n\n\tdo {\n\t\tret = f_midi_do_transmit(midi, ep);\n\t\tif (ret < 0) {\n\t\t\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\t\t\tgoto drop_out;\n\t\t}\n\t} while (ret);\n\n\tspin_unlock_irqrestore(&midi->transmit_lock, flags);\n\n\treturn;\n\ndrop_out:\n\tf_midi_drop_out_substreams(midi);\n}\n\nstatic void f_midi_in_work(struct work_struct *work)\n{\n\tstruct f_midi *midi;\n\n\tmidi = container_of(work, struct f_midi, work);\n\tf_midi_transmit(midi);\n}\n\nstatic int f_midi_in_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\tstruct gmidi_in_port *port;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tport = midi->in_ports_array + substream->number;\n\tport->substream = substream;\n\tport->state = STATE_INITIAL;\n\treturn 0;\n}\n\nstatic int f_midi_in_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_in_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= midi->in_ports)\n\t\treturn;\n\n\tVDBG(midi, \"%s() %d\\n\", __func__, up);\n\tmidi->in_ports_array[substream->number].active = up;\n\tif (up)\n\t\tqueue_work(system_highpri_wq, &midi->work);\n}\n\nstatic int f_midi_out_open(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tif (substream->number >= MAX_PORTS)\n\t\treturn -EINVAL;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\tmidi->out_substream[substream->number] = substream;\n\treturn 0;\n}\n\nstatic int f_midi_out_close(struct snd_rawmidi_substream *substream)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\treturn 0;\n}\n\nstatic void f_midi_out_trigger(struct snd_rawmidi_substream *substream, int up)\n{\n\tstruct f_midi *midi = substream->rmidi->private_data;\n\n\tVDBG(midi, \"%s()\\n\", __func__);\n\n\tif (up)\n\t\tset_bit(substream->number, &midi->out_triggered);\n\telse\n\t\tclear_bit(substream->number, &midi->out_triggered);\n}\n\nstatic const struct snd_rawmidi_ops gmidi_in_ops = {\n\t.open = f_midi_in_open,\n\t.close = f_midi_in_close,\n\t.trigger = f_midi_in_trigger,\n};\n\nstatic const struct snd_rawmidi_ops gmidi_out_ops = {\n\t.open = f_midi_out_open,\n\t.close = f_midi_out_close,\n\t.trigger = f_midi_out_trigger\n};\n\nstatic inline void f_midi_unregister_card(struct f_midi *midi)\n{\n\tif (midi->card) {\n\t\tsnd_card_free(midi->card);\n\t\tmidi->card = NULL;\n\t}\n}\n\n \nstatic int f_midi_register_card(struct f_midi *midi)\n{\n\tstruct snd_card *card;\n\tstruct snd_rawmidi *rmidi;\n\tint err;\n\tstatic struct snd_device_ops ops = {\n\t\t.dev_free = f_midi_snd_free,\n\t};\n\n\terr = snd_card_new(&midi->gadget->dev, midi->index, midi->id,\n\t\t\t   THIS_MODULE, 0, &card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_new() failed\\n\");\n\t\tgoto fail;\n\t}\n\tmidi->card = card;\n\n\terr = snd_device_new(card, SNDRV_DEV_LOWLEVEL, midi, &ops);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_device_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\tstrcpy(card->driver, f_midi_longname);\n\tstrcpy(card->longname, f_midi_longname);\n\tstrcpy(card->shortname, f_midi_shortname);\n\n\t \n\tsnd_component_add(card, \"MIDI\");\n\terr = snd_rawmidi_new(card, card->longname, 0,\n\t\t\t      midi->out_ports, midi->in_ports, &rmidi);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_rawmidi_new() failed: error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\tmidi->rmidi = rmidi;\n\tmidi->in_last_port = 0;\n\tstrcpy(rmidi->name, card->shortname);\n\trmidi->info_flags = SNDRV_RAWMIDI_INFO_OUTPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_INPUT |\n\t\t\t    SNDRV_RAWMIDI_INFO_DUPLEX;\n\trmidi->private_data = midi;\n\trmidi->private_free = f_midi_rmidi_free;\n\tmidi->free_ref++;\n\n\t \n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &gmidi_in_ops);\n\tsnd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &gmidi_out_ops);\n\n\t \n\terr = snd_card_register(card);\n\tif (err < 0) {\n\t\tERROR(midi, \"snd_card_register() failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tVDBG(midi, \"%s() finished ok\\n\", __func__);\n\treturn 0;\n\nfail:\n\tf_midi_unregister_card(midi);\n\treturn err;\n}\n\n \n\nstatic int f_midi_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_descriptor_header **midi_function;\n\tstruct usb_midi_in_jack_descriptor jack_in_ext_desc[MAX_PORTS];\n\tstruct usb_midi_in_jack_descriptor jack_in_emb_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_ext_desc[MAX_PORTS];\n\tstruct usb_midi_out_jack_descriptor_1 jack_out_emb_desc[MAX_PORTS];\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct usb_string *us;\n\tint status, n, jack = 1, i = 0, endpoint_descriptor_index = 0;\n\n\tmidi->gadget = cdev->gadget;\n\tINIT_WORK(&midi->work, f_midi_in_work);\n\tstatus = f_midi_register_card(midi);\n\tif (status < 0)\n\t\tgoto fail_register;\n\n\t \n\tus = usb_gstrings_attach(c->cdev, midi_strings,\n\t\t\t\t ARRAY_SIZE(midi_string_defs));\n\tif (IS_ERR(us)) {\n\t\tstatus = PTR_ERR(us);\n\t\tgoto fail;\n\t}\n\tac_interface_desc.iInterface = us[STRING_FUNC_IDX].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tac_interface_desc.bInterfaceNumber = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tms_interface_desc.bInterfaceNumber = status;\n\tac_header_desc.baInterfaceNr[0] = status;\n\tmidi->ms_id = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tmidi->in_ep = usb_ep_autoconfig(cdev->gadget, &bulk_in_desc);\n\tif (!midi->in_ep)\n\t\tgoto fail;\n\n\tmidi->out_ep = usb_ep_autoconfig(cdev->gadget, &bulk_out_desc);\n\tif (!midi->out_ep)\n\t\tgoto fail;\n\n\t \n\tmidi_function = kcalloc((MAX_PORTS * 4) + 11, sizeof(*midi_function),\n\t\t\t\tGFP_KERNEL);\n\tif (!midi_function) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\n\t \n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_interface_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ac_header_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_interface_desc;\n\n\t \n\tn = USB_DT_MS_HEADER_SIZE\n\t\t+ (midi->in_ports + midi->out_ports) *\n\t\t\t(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\n\tms_header_desc.wTotalLength = cpu_to_le16(n);\n\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_header_desc;\n\n\t \n\tfor (n = 0; n < midi->in_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_ext = &jack_in_ext_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_emb = &jack_out_emb_desc[n];\n\n\t\tin_ext->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_ext->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_ext->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_ext->bJackType\t\t= USB_MS_EXTERNAL;\n\t\tin_ext->bJackID\t\t\t= jack++;\n\t\tin_ext->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_ext;\n\n\t\tout_emb->bLength\t\t= USB_DT_MIDI_OUT_SIZE(1);\n\t\tout_emb->bDescriptorType\t= USB_DT_CS_INTERFACE;\n\t\tout_emb->bDescriptorSubtype\t= USB_MS_MIDI_OUT_JACK;\n\t\tout_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tout_emb->bJackID\t\t= jack++;\n\t\tout_emb->bNrInputPins\t\t= 1;\n\t\tout_emb->pins[0].baSourcePin\t= 1;\n\t\tout_emb->pins[0].baSourceID\t= in_ext->bJackID;\n\t\tout_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_emb;\n\n\t\t \n\t\tms_in_desc.baAssocJackID[n] = out_emb->bJackID;\n\t}\n\n\t \n\tfor (n = 0; n < midi->out_ports; n++) {\n\t\tstruct usb_midi_in_jack_descriptor *in_emb = &jack_in_emb_desc[n];\n\t\tstruct usb_midi_out_jack_descriptor_1 *out_ext = &jack_out_ext_desc[n];\n\n\t\tin_emb->bLength\t\t\t= USB_DT_MIDI_IN_SIZE;\n\t\tin_emb->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\t\tin_emb->bDescriptorSubtype\t= USB_MS_MIDI_IN_JACK;\n\t\tin_emb->bJackType\t\t= USB_MS_EMBEDDED;\n\t\tin_emb->bJackID\t\t\t= jack++;\n\t\tin_emb->iJack\t\t\t= 0;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) in_emb;\n\n\t\tout_ext->bLength =\t\tUSB_DT_MIDI_OUT_SIZE(1);\n\t\tout_ext->bDescriptorType =\tUSB_DT_CS_INTERFACE;\n\t\tout_ext->bDescriptorSubtype =\tUSB_MS_MIDI_OUT_JACK;\n\t\tout_ext->bJackType =\t\tUSB_MS_EXTERNAL;\n\t\tout_ext->bJackID =\t\tjack++;\n\t\tout_ext->bNrInputPins =\t\t1;\n\t\tout_ext->iJack =\t\t0;\n\t\tout_ext->pins[0].baSourceID =\tin_emb->bJackID;\n\t\tout_ext->pins[0].baSourcePin =\t1;\n\t\tmidi_function[i++] = (struct usb_descriptor_header *) out_ext;\n\n\t\t \n\t\tms_out_desc.baAssocJackID[n] = in_emb->bJackID;\n\t}\n\n\t \n\tms_out_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->in_ports);\n\tms_out_desc.bNumEmbMIDIJack = midi->in_ports;\n\n\tms_in_desc.bLength = USB_DT_MS_ENDPOINT_SIZE(midi->out_ports);\n\tms_in_desc.bNumEmbMIDIJack = midi->out_ports;\n\n\t \n\tendpoint_descriptor_index = i;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &bulk_in_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *) &ms_in_desc;\n\tmidi_function[i++] = NULL;\n\n\t \n\t \n\tf->fs_descriptors = usb_copy_descriptors(midi_function);\n\tif (!f->fs_descriptors)\n\t\tgoto fail_f_midi;\n\n\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(512);\n\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(512);\n\tf->hs_descriptors = usb_copy_descriptors(midi_function);\n\tif (!f->hs_descriptors)\n\t\tgoto fail_f_midi;\n\n\tbulk_in_desc.wMaxPacketSize = cpu_to_le16(1024);\n\tbulk_out_desc.wMaxPacketSize = cpu_to_le16(1024);\n\ti = endpoint_descriptor_index;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &bulk_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &bulk_out_ss_comp_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &ms_out_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &bulk_in_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &bulk_in_ss_comp_desc;\n\tmidi_function[i++] = (struct usb_descriptor_header *)\n\t\t\t     &ms_in_desc;\n\tf->ss_descriptors = usb_copy_descriptors(midi_function);\n\tif (!f->ss_descriptors)\n\t\tgoto fail_f_midi;\n\n\tkfree(midi_function);\n\n\treturn 0;\n\nfail_f_midi:\n\tkfree(midi_function);\n\tusb_free_all_descriptors(f);\nfail:\n\tf_midi_unregister_card(midi);\nfail_register:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_midi_opts *to_f_midi_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void midi_attr_release(struct config_item *item)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations midi_item_ops = {\n\t.release\t= midi_attr_release,\n};\n\n#define F_MIDI_OPT(name, test_limit, limit)\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt > 1) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_limit && num > limit) {\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi_opts_, name);\n\n#define F_MIDI_OPT_SIGNED(name, test_limit, limit)\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_show(struct config_item *item, char *page) \\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%d\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\ts32 num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt > 1) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtos32(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (test_limit && num > limit) {\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi_opts_, name);\n\nF_MIDI_OPT_SIGNED(index, true, SNDRV_CARDS);\nF_MIDI_OPT(buflen, false, 0);\nF_MIDI_OPT(qlen, false, 0);\nF_MIDI_OPT(in_ports, true, MAX_PORTS);\nF_MIDI_OPT(out_ports, true, MAX_PORTS);\n\nstatic ssize_t f_midi_opts_id_show(struct config_item *item, char *page)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->id) {\n\t\tresult = strlcpy(page, opts->id, PAGE_SIZE);\n\t} else {\n\t\tpage[0] = 0;\n\t\tresult = 0;\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_midi_opts_id_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_midi_opts *opts = to_f_midi_opts(item);\n\tint ret;\n\tchar *c;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt > 1) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, len, GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\tif (opts->id_allocated)\n\t\tkfree(opts->id);\n\topts->id = c;\n\topts->id_allocated = true;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_midi_opts_, id);\n\nstatic struct configfs_attribute *midi_attrs[] = {\n\t&f_midi_opts_attr_index,\n\t&f_midi_opts_attr_buflen,\n\t&f_midi_opts_attr_qlen,\n\t&f_midi_opts_attr_in_ports,\n\t&f_midi_opts_attr_out_ports,\n\t&f_midi_opts_attr_id,\n\tNULL,\n};\n\nstatic const struct config_item_type midi_func_type = {\n\t.ct_item_ops\t= &midi_item_ops,\n\t.ct_attrs\t= midi_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_midi_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_midi_opts *opts;\n\tbool free = false;\n\n\topts = container_of(f, struct f_midi_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\tif (!--opts->refcnt) {\n\t\tfree = true;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tif (free) {\n\t\tif (opts->id_allocated)\n\t\t\tkfree(opts->id);\n\t\tkfree(opts);\n\t}\n}\n\nstatic struct usb_function_instance *f_midi_alloc_inst(void)\n{\n\tstruct f_midi_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi_free_inst;\n\topts->index = SNDRV_DEFAULT_IDX1;\n\topts->id = SNDRV_DEFAULT_STR1;\n\topts->buflen = 512;\n\topts->qlen = 32;\n\topts->in_ports = 1;\n\topts->out_ports = 1;\n\topts->refcnt = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &midi_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void f_midi_free(struct usb_function *f)\n{\n\tstruct f_midi *midi;\n\tstruct f_midi_opts *opts;\n\tbool free = false;\n\n\tmidi = func_to_midi(f);\n\topts = container_of(f->fi, struct f_midi_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\tif (!--midi->free_ref) {\n\t\tkfree(midi->id);\n\t\tkfifo_free(&midi->in_req_fifo);\n\t\tkfree(midi);\n\t\tfree = true;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tif (free)\n\t\tf_midi_free_inst(&opts->func_inst);\n}\n\nstatic void f_midi_rmidi_free(struct snd_rawmidi *rmidi)\n{\n\tf_midi_free(rmidi->private_data);\n}\n\nstatic void f_midi_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct f_midi *midi = func_to_midi(f);\n\tstruct snd_card *card;\n\n\tDBG(cdev, \"unbind\\n\");\n\n\t \n\tf_midi_disable(f);\n\n\tcard = midi->card;\n\tmidi->card = NULL;\n\tif (card)\n\t\tsnd_card_free_when_closed(card);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *f_midi_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_midi *midi = NULL;\n\tstruct f_midi_opts *opts;\n\tint status, i;\n\n\topts = container_of(fi, struct f_midi_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\t \n\tif (opts->in_ports > MAX_PORTS || opts->out_ports > MAX_PORTS) {\n\t\tstatus = -EINVAL;\n\t\tgoto setup_fail;\n\t}\n\n\t \n\tmidi = kzalloc(struct_size(midi, in_ports_array, opts->in_ports),\n\t\t       GFP_KERNEL);\n\tif (!midi) {\n\t\tstatus = -ENOMEM;\n\t\tgoto setup_fail;\n\t}\n\n\tfor (i = 0; i < opts->in_ports; i++)\n\t\tmidi->in_ports_array[i].cable = i;\n\n\t \n\tmidi->id = kstrdup(opts->id, GFP_KERNEL);\n\tif (opts->id && !midi->id) {\n\t\tstatus = -ENOMEM;\n\t\tgoto midi_free;\n\t}\n\tmidi->in_ports = opts->in_ports;\n\tmidi->out_ports = opts->out_ports;\n\tmidi->index = opts->index;\n\tmidi->buflen = opts->buflen;\n\tmidi->qlen = opts->qlen;\n\tmidi->in_last_port = 0;\n\tmidi->free_ref = 1;\n\n\tstatus = kfifo_alloc(&midi->in_req_fifo, midi->qlen, GFP_KERNEL);\n\tif (status)\n\t\tgoto midi_free;\n\n\tspin_lock_init(&midi->transmit_lock);\n\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tmidi->func.name\t\t= \"gmidi function\";\n\tmidi->func.bind\t\t= f_midi_bind;\n\tmidi->func.unbind\t= f_midi_unbind;\n\tmidi->func.set_alt\t= f_midi_set_alt;\n\tmidi->func.disable\t= f_midi_disable;\n\tmidi->func.free_func\t= f_midi_free;\n\n\treturn &midi->func;\n\nmidi_free:\n\tif (midi)\n\t\tkfree(midi->id);\n\tkfree(midi);\nsetup_fail:\n\tmutex_unlock(&opts->lock);\n\n\treturn ERR_PTR(status);\n}\n\nDECLARE_USB_FUNCTION_INIT(midi, f_midi_alloc_inst, f_midi_alloc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}