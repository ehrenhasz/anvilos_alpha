{
  "module_name": "f_eem.c",
  "hash_id": "36a20622afee22e08babd6434cf7cf68d3311f6a07f0fc1d0714c3a8d87bc21e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_eem.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n\n#include \"u_ether.h\"\n#include \"u_ether_configfs.h\"\n#include \"u_eem.h\"\n\n#define EEM_HLEN 2\n\n \n\nstruct f_eem {\n\tstruct gether\t\t\tport;\n\tu8\t\t\t\tctrl_id;\n};\n\nstruct in_context {\n\tstruct sk_buff\t*skb;\n\tstruct usb_ep\t*ep;\n};\n\nstatic inline struct f_eem *func_to_eem(struct usb_function *f)\n{\n\treturn container_of(f, struct f_eem, port.func);\n}\n\n \n\n \n\nstatic struct usb_interface_descriptor eem_intf = {\n\t.bLength =\t\tsizeof eem_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_EEM,\n\t.bInterfaceProtocol =\tUSB_CDC_PROTO_EEM,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor eem_fs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor eem_fs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *eem_fs_function[] = {\n\t \n\t(struct usb_descriptor_header *) &eem_intf,\n\t(struct usb_descriptor_header *) &eem_fs_in_desc,\n\t(struct usb_descriptor_header *) &eem_fs_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor eem_hs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor eem_hs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *eem_hs_function[] = {\n\t \n\t(struct usb_descriptor_header *) &eem_intf,\n\t(struct usb_descriptor_header *) &eem_hs_in_desc,\n\t(struct usb_descriptor_header *) &eem_hs_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor eem_ss_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor eem_ss_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor eem_ss_bulk_comp_desc = {\n\t.bLength =\t\tsizeof eem_ss_bulk_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n};\n\nstatic struct usb_descriptor_header *eem_ss_function[] = {\n\t \n\t(struct usb_descriptor_header *) &eem_intf,\n\t(struct usb_descriptor_header *) &eem_ss_in_desc,\n\t(struct usb_descriptor_header *) &eem_ss_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &eem_ss_out_desc,\n\t(struct usb_descriptor_header *) &eem_ss_bulk_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string eem_string_defs[] = {\n\t[0].s = \"CDC Ethernet Emulation Model (EEM)\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings eem_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\teem_string_defs,\n};\n\nstatic struct usb_gadget_strings *eem_strings[] = {\n\t&eem_string_table,\n\tNULL,\n};\n\n \n\nstatic int eem_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\tDBG(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\tctrl->bRequestType, ctrl->bRequest,\n\t\tw_value, w_index, w_length);\n\n\t \n\treturn -EOPNOTSUPP;\n}\n\n\nstatic int eem_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_eem\t\t*eem = func_to_eem(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct net_device\t*net;\n\n\t \n\tif (alt != 0)\n\t\tgoto fail;\n\n\tif (intf == eem->ctrl_id) {\n\t\tDBG(cdev, \"reset eem\\n\");\n\t\tgether_disconnect(&eem->port);\n\n\t\tif (!eem->port.in_ep->desc || !eem->port.out_ep->desc) {\n\t\t\tDBG(cdev, \"init eem\\n\");\n\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       eem->port.in_ep) ||\n\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       eem->port.out_ep)) {\n\t\t\t\teem->port.in_ep->desc = NULL;\n\t\t\t\teem->port.out_ep->desc = NULL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\teem->port.is_zlp_ok = 1;\n\t\teem->port.cdc_filter = DEFAULT_FILTER;\n\t\tDBG(cdev, \"activate eem\\n\");\n\t\tnet = gether_connect(&eem->port);\n\t\tif (IS_ERR(net))\n\t\t\treturn PTR_ERR(net);\n\t} else\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\n\nstatic void eem_disable(struct usb_function *f)\n{\n\tstruct f_eem\t\t*eem = func_to_eem(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tDBG(cdev, \"eem deactivated\\n\");\n\n\tif (eem->port.in_ep->enabled)\n\t\tgether_disconnect(&eem->port);\n}\n\n \n\n \n\nstatic int eem_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_eem\t\t*eem = func_to_eem(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\tstruct f_eem_opts\t*eem_opts;\n\n\teem_opts = container_of(f->fi, struct f_eem_opts, func_inst);\n\t \n\tif (!eem_opts->bound) {\n\t\tmutex_lock(&eem_opts->lock);\n\t\tgether_set_gadget(eem_opts->net, cdev->gadget);\n\t\tstatus = gether_register_netdev(eem_opts->net);\n\t\tmutex_unlock(&eem_opts->lock);\n\t\tif (status)\n\t\t\treturn status;\n\t\teem_opts->bound = true;\n\t}\n\n\tus = usb_gstrings_attach(cdev, eem_strings,\n\t\t\t\t ARRAY_SIZE(eem_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\teem_intf.iInterface = us[0].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\teem->ctrl_id = status;\n\teem_intf.bInterfaceNumber = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &eem_fs_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\teem->port.in_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &eem_fs_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\teem->port.out_ep = ep;\n\n\t \n\teem_hs_in_desc.bEndpointAddress = eem_fs_in_desc.bEndpointAddress;\n\teem_hs_out_desc.bEndpointAddress = eem_fs_out_desc.bEndpointAddress;\n\n\teem_ss_in_desc.bEndpointAddress = eem_fs_in_desc.bEndpointAddress;\n\teem_ss_out_desc.bEndpointAddress = eem_fs_out_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, eem_fs_function, eem_hs_function,\n\t\t\teem_ss_function, eem_ss_function);\n\tif (status)\n\t\tgoto fail;\n\n\tDBG(cdev, \"CDC Ethernet (EEM): IN/%s OUT/%s\\n\",\n\t\t\teem->port.in_ep->name, eem->port.out_ep->name);\n\treturn 0;\n\nfail:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic void eem_cmd_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct in_context *ctx = req->context;\n\n\tdev_kfree_skb_any(ctx->skb);\n\tkfree(req->buf);\n\tusb_ep_free_request(ctx->ep, req);\n\tkfree(ctx);\n}\n\n \nstatic struct sk_buff *eem_wrap(struct gether *port, struct sk_buff *skb)\n{\n\tstruct sk_buff\t*skb2 = NULL;\n\tstruct usb_ep\t*in = port->in_ep;\n\tint\t\theadroom, tailroom, padlen = 0;\n\tu16\t\tlen;\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tlen = skb->len;\n\theadroom = skb_headroom(skb);\n\ttailroom = skb_tailroom(skb);\n\n\t \n\tif (((len + EEM_HLEN + ETH_FCS_LEN) % in->maxpacket) == 0)\n\t\tpadlen += 2;\n\n\tif ((tailroom >= (ETH_FCS_LEN + padlen)) &&\n\t\t\t(headroom >= EEM_HLEN) && !skb_cloned(skb))\n\t\tgoto done;\n\n\tskb2 = skb_copy_expand(skb, EEM_HLEN, ETH_FCS_LEN + padlen, GFP_ATOMIC);\n\tdev_kfree_skb_any(skb);\n\tskb = skb2;\n\tif (!skb)\n\t\treturn skb;\n\ndone:\n\t \n\tput_unaligned_be32(0xdeadbeef, skb_put(skb, 4));\n\n\t \n\tlen = skb->len;\n\tput_unaligned_le16(len & 0x3FFF, skb_push(skb, 2));\n\n\t \n\tif (padlen)\n\t\tput_unaligned_le16(0, skb_put(skb, 2));\n\n\treturn skb;\n}\n\n \nstatic int eem_unwrap(struct gether *port,\n\t\t\tstruct sk_buff *skb,\n\t\t\tstruct sk_buff_head *list)\n{\n\tstruct usb_composite_dev\t*cdev = port->func.config->cdev;\n\tint\t\t\t\tstatus = 0;\n\n\tdo {\n\t\tstruct sk_buff\t*skb2;\n\t\tu16\t\theader;\n\t\tu16\t\tlen = 0;\n\n\t\tif (skb->len < EEM_HLEN) {\n\t\t\tstatus = -EINVAL;\n\t\t\tDBG(cdev, \"invalid EEM header\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\theader = get_unaligned_le16(skb->data);\n\t\tskb_pull(skb, EEM_HLEN);\n\n\t\t \n\t\tif (header & BIT(15)) {\n\t\t\tstruct usb_request\t*req;\n\t\t\tstruct in_context\t*ctx;\n\t\t\tstruct usb_ep\t\t*ep;\n\t\t\tu16\t\t\tbmEEMCmd;\n\n\t\t\t \n\t\t\tif (header & BIT(14))\n\t\t\t\tcontinue;\n\n\t\t\tbmEEMCmd = (header >> 11) & 0x7;\n\t\t\tswitch (bmEEMCmd) {\n\t\t\tcase 0:  \n\t\t\t\tlen = header & 0x7FF;\n\t\t\t\tif (skb->len < len) {\n\t\t\t\t\tstatus = -EOVERFLOW;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (unlikely(!skb2)) {\n\t\t\t\t\tDBG(cdev, \"EEM echo response error\\n\");\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tskb_trim(skb2, len);\n\t\t\t\tput_unaligned_le16(BIT(15) | BIT(11) | len,\n\t\t\t\t\t\t\tskb_push(skb2, 2));\n\n\t\t\t\tep = port->in_ep;\n\t\t\t\treq = usb_ep_alloc_request(ep, GFP_ATOMIC);\n\t\t\t\tif (!req) {\n\t\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\treq->buf = kmalloc(skb2->len, GFP_KERNEL);\n\t\t\t\tif (!req->buf) {\n\t\t\t\t\tusb_ep_free_request(ep, req);\n\t\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\n\t\t\t\tctx = kmalloc(sizeof(*ctx), GFP_KERNEL);\n\t\t\t\tif (!ctx) {\n\t\t\t\t\tkfree(req->buf);\n\t\t\t\t\tusb_ep_free_request(ep, req);\n\t\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tctx->skb = skb2;\n\t\t\t\tctx->ep = ep;\n\n\t\t\t\tskb_copy_bits(skb2, 0, req->buf, skb2->len);\n\t\t\t\treq->length = skb2->len;\n\t\t\t\treq->complete = eem_cmd_complete;\n\t\t\t\treq->zero = 1;\n\t\t\t\treq->context = ctx;\n\t\t\t\tif (usb_ep_queue(port->in_ep, req, GFP_ATOMIC))\n\t\t\t\t\tDBG(cdev, \"echo response queue fail\\n\");\n\t\t\t\tbreak;\n\n\t\t\tcase 1:   \n\t\t\tcase 2:   \n\t\t\tcase 3:   \n\t\t\tcase 4:   \n\t\t\tcase 5:   \n\t\t\tdefault:  \n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tu32\t\tcrc, crc2;\n\t\t\tstruct sk_buff\t*skb3;\n\n\t\t\t \n\t\t\tif (header == 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tlen = header & 0x3FFF;\n\t\t\tif ((skb->len < len)\n\t\t\t\t\t|| (len < (ETH_HLEN + ETH_FCS_LEN))) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (header & BIT(14)) {\n\t\t\t\tcrc = get_unaligned_le32(skb->data + len\n\t\t\t\t\t\t\t- ETH_FCS_LEN);\n\t\t\t\tcrc2 = ~crc32_le(~0,\n\t\t\t\t\t\tskb->data, len - ETH_FCS_LEN);\n\t\t\t} else {\n\t\t\t\tcrc = get_unaligned_be32(skb->data + len\n\t\t\t\t\t\t\t- ETH_FCS_LEN);\n\t\t\t\tcrc2 = 0xdeadbeef;\n\t\t\t}\n\t\t\tif (crc != crc2) {\n\t\t\t\tDBG(cdev, \"invalid EEM CRC\\n\");\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\tskb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (unlikely(!skb2)) {\n\t\t\t\tDBG(cdev, \"unable to unframe EEM packet\\n\");\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tskb_trim(skb2, len - ETH_FCS_LEN);\n\n\t\t\tskb3 = skb_copy_expand(skb2,\n\t\t\t\t\t\tNET_IP_ALIGN,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (unlikely(!skb3)) {\n\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tdev_kfree_skb_any(skb2);\n\t\t\tskb_queue_tail(list, skb3);\n\t\t}\nnext:\n\t\tskb_pull(skb, len);\n\t} while (skb->len);\n\nerror:\n\tdev_kfree_skb_any(skb);\n\treturn status;\n}\n\nstatic inline struct f_eem_opts *to_f_eem_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_eem_opts,\n\t\t\t    func_inst.group);\n}\n\n \nUSB_ETHERNET_CONFIGFS_ITEM(eem);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(eem);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(eem);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(eem);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(eem);\n\nstatic struct configfs_attribute *eem_attrs[] = {\n\t&eem_opts_attr_dev_addr,\n\t&eem_opts_attr_host_addr,\n\t&eem_opts_attr_qmult,\n\t&eem_opts_attr_ifname,\n\tNULL,\n};\n\nstatic const struct config_item_type eem_func_type = {\n\t.ct_item_ops\t= &eem_item_ops,\n\t.ct_attrs\t= eem_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void eem_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_eem_opts *opts;\n\n\topts = container_of(f, struct f_eem_opts, func_inst);\n\tif (opts->bound)\n\t\tgether_cleanup(netdev_priv(opts->net));\n\telse\n\t\tfree_netdev(opts->net);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *eem_alloc_inst(void)\n{\n\tstruct f_eem_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = eem_free_inst;\n\topts->net = gether_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &eem_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void eem_free(struct usb_function *f)\n{\n\tstruct f_eem *eem;\n\tstruct f_eem_opts *opts;\n\n\teem = func_to_eem(f);\n\topts = container_of(f->fi, struct f_eem_opts, func_inst);\n\tkfree(eem);\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void eem_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tDBG(c->cdev, \"eem unbind\\n\");\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *eem_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_eem\t*eem;\n\tstruct f_eem_opts *opts;\n\n\t \n\teem = kzalloc(sizeof(*eem), GFP_KERNEL);\n\tif (!eem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_eem_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\n\teem->port.ioport = netdev_priv(opts->net);\n\tmutex_unlock(&opts->lock);\n\teem->port.cdc_filter = DEFAULT_FILTER;\n\n\teem->port.func.name = \"cdc_eem\";\n\t \n\teem->port.func.bind = eem_bind;\n\teem->port.func.unbind = eem_unbind;\n\teem->port.func.set_alt = eem_set_alt;\n\teem->port.func.setup = eem_setup;\n\teem->port.func.disable = eem_disable;\n\teem->port.func.free_func = eem_free;\n\teem->port.wrap = eem_wrap;\n\teem->port.unwrap = eem_unwrap;\n\teem->port.header_len = EEM_HLEN;\n\n\treturn &eem->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(eem, eem_alloc_inst, eem_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}