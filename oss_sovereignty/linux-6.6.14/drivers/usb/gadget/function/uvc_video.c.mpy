{
  "module_name": "uvc_video.c",
  "hash_id": "01d505274672d71b4fc384d2d73a7b934257cbe749da046c8f4856b37555e8a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc_video.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/video.h>\n#include <asm/unaligned.h>\n\n#include <media/v4l2-dev.h>\n\n#include \"uvc.h\"\n#include \"uvc_queue.h\"\n#include \"uvc_video.h\"\n\n \n\nstatic int\nuvc_video_encode_header(struct uvc_video *video, struct uvc_buffer *buf,\n\t\tu8 *data, int len)\n{\n\tstruct uvc_device *uvc = container_of(video, struct uvc_device, video);\n\tstruct usb_composite_dev *cdev = uvc->func.config->cdev;\n\tstruct timespec64 ts = ns_to_timespec64(buf->buf.vb2_buf.timestamp);\n\tint pos = 2;\n\n\tdata[1] = UVC_STREAM_EOH | video->fid;\n\n\tif (video->queue.buf_used == 0 && ts.tv_sec) {\n\t\t \n\t\tu32 pts = ((u64)ts.tv_sec * USEC_PER_SEC + ts.tv_nsec / NSEC_PER_USEC) * 48;\n\n\t\tdata[1] |= UVC_STREAM_PTS;\n\t\tput_unaligned_le32(pts, &data[pos]);\n\t\tpos += 4;\n\t}\n\n\tif (cdev->gadget->ops->get_frame) {\n\t\tu32 sof, stc;\n\n\t\tsof = usb_gadget_frame_number(cdev->gadget);\n\t\tktime_get_ts64(&ts);\n\t\tstc = ((u64)ts.tv_sec * USEC_PER_SEC + ts.tv_nsec / NSEC_PER_USEC) * 48;\n\n\t\tdata[1] |= UVC_STREAM_SCR;\n\t\tput_unaligned_le32(stc, &data[pos]);\n\t\tput_unaligned_le16(sof, &data[pos+4]);\n\t\tpos += 6;\n\t}\n\n\tdata[0] = pos;\n\n\tif (buf->bytesused - video->queue.buf_used <= len - pos)\n\t\tdata[1] |= UVC_STREAM_EOF;\n\n\treturn pos;\n}\n\nstatic int\nuvc_video_encode_data(struct uvc_video *video, struct uvc_buffer *buf,\n\t\tu8 *data, int len)\n{\n\tstruct uvc_video_queue *queue = &video->queue;\n\tunsigned int nbytes;\n\tvoid *mem;\n\n\t \n\tmem = buf->mem + queue->buf_used;\n\tnbytes = min((unsigned int)len, buf->bytesused - queue->buf_used);\n\n\tmemcpy(data, mem, nbytes);\n\tqueue->buf_used += nbytes;\n\n\treturn nbytes;\n}\n\nstatic void\nuvc_video_encode_bulk(struct usb_request *req, struct uvc_video *video,\n\t\tstruct uvc_buffer *buf)\n{\n\tvoid *mem = req->buf;\n\tstruct uvc_request *ureq = req->context;\n\tint len = video->req_size;\n\tint ret;\n\n\t \n\tif (video->payload_size == 0) {\n\t\tret = uvc_video_encode_header(video, buf, mem, len);\n\t\tvideo->payload_size += ret;\n\t\tmem += ret;\n\t\tlen -= ret;\n\t}\n\n\t \n\tlen = min((int)(video->max_payload_size - video->payload_size), len);\n\tret = uvc_video_encode_data(video, buf, mem, len);\n\n\tvideo->payload_size += ret;\n\tlen -= ret;\n\n\treq->length = video->req_size - len;\n\treq->zero = video->payload_size == video->max_payload_size;\n\n\tif (buf->bytesused == video->queue.buf_used) {\n\t\tvideo->queue.buf_used = 0;\n\t\tbuf->state = UVC_BUF_STATE_DONE;\n\t\tlist_del(&buf->queue);\n\t\tvideo->fid ^= UVC_STREAM_FID;\n\t\tureq->last_buf = buf;\n\n\t\tvideo->payload_size = 0;\n\t}\n\n\tif (video->payload_size == video->max_payload_size ||\n\t    video->queue.flags & UVC_QUEUE_DROP_INCOMPLETE ||\n\t    buf->bytesused == video->queue.buf_used)\n\t\tvideo->payload_size = 0;\n}\n\nstatic void\nuvc_video_encode_isoc_sg(struct usb_request *req, struct uvc_video *video,\n\t\tstruct uvc_buffer *buf)\n{\n\tunsigned int pending = buf->bytesused - video->queue.buf_used;\n\tstruct uvc_request *ureq = req->context;\n\tstruct scatterlist *sg, *iter;\n\tunsigned int len = video->req_size;\n\tunsigned int sg_left, part = 0;\n\tunsigned int i;\n\tint header_len;\n\n\tsg = ureq->sgt.sgl;\n\tsg_init_table(sg, ureq->sgt.nents);\n\n\t \n\theader_len = uvc_video_encode_header(video, buf, ureq->header,\n\t\t\t\t      video->req_size);\n\tsg_set_buf(sg, ureq->header, header_len);\n\tlen -= header_len;\n\n\tif (pending <= len)\n\t\tlen = pending;\n\n\treq->length = (len == pending) ?\n\t\tlen + header_len : video->req_size;\n\n\t \n\tsg = sg_next(sg);\n\n\tfor_each_sg(sg, iter, ureq->sgt.nents - 1, i) {\n\t\tif (!len || !buf->sg || !buf->sg->length)\n\t\t\tbreak;\n\n\t\tsg_left = buf->sg->length - buf->offset;\n\t\tpart = min_t(unsigned int, len, sg_left);\n\n\t\tsg_set_page(iter, sg_page(buf->sg), part, buf->offset);\n\n\t\tif (part == sg_left) {\n\t\t\tbuf->offset = 0;\n\t\t\tbuf->sg = sg_next(buf->sg);\n\t\t} else {\n\t\t\tbuf->offset += part;\n\t\t}\n\t\tlen -= part;\n\t}\n\n\t \n\treq->buf = NULL;\n\treq->sg\t= ureq->sgt.sgl;\n\treq->num_sgs = i + 1;\n\n\treq->length -= len;\n\tvideo->queue.buf_used += req->length - header_len;\n\n\tif (buf->bytesused == video->queue.buf_used || !buf->sg ||\n\t\t\tvideo->queue.flags & UVC_QUEUE_DROP_INCOMPLETE) {\n\t\tvideo->queue.buf_used = 0;\n\t\tbuf->state = UVC_BUF_STATE_DONE;\n\t\tbuf->offset = 0;\n\t\tlist_del(&buf->queue);\n\t\tvideo->fid ^= UVC_STREAM_FID;\n\t\tureq->last_buf = buf;\n\t}\n}\n\nstatic void\nuvc_video_encode_isoc(struct usb_request *req, struct uvc_video *video,\n\t\tstruct uvc_buffer *buf)\n{\n\tvoid *mem = req->buf;\n\tstruct uvc_request *ureq = req->context;\n\tint len = video->req_size;\n\tint ret;\n\n\t \n\tret = uvc_video_encode_header(video, buf, mem, len);\n\tmem += ret;\n\tlen -= ret;\n\n\t \n\tret = uvc_video_encode_data(video, buf, mem, len);\n\tlen -= ret;\n\n\treq->length = video->req_size - len;\n\n\tif (buf->bytesused == video->queue.buf_used ||\n\t\t\tvideo->queue.flags & UVC_QUEUE_DROP_INCOMPLETE) {\n\t\tvideo->queue.buf_used = 0;\n\t\tbuf->state = UVC_BUF_STATE_DONE;\n\t\tlist_del(&buf->queue);\n\t\tvideo->fid ^= UVC_STREAM_FID;\n\t\tureq->last_buf = buf;\n\t}\n}\n\n \n\nstatic int uvcg_video_ep_queue(struct uvc_video *video, struct usb_request *req)\n{\n\tint ret;\n\n\tret = usb_ep_queue(video->ep, req, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tuvcg_err(&video->uvc->func, \"Failed to queue request (%d).\\n\",\n\t\t\t ret);\n\n\t\t \n\t\tif (video->ep->desc) {\n\t\t\t \n\t\t\tif (usb_endpoint_xfer_bulk(video->ep->desc))\n\t\t\t\tusb_ep_set_halt(video->ep);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void\nuvc_video_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct uvc_request *ureq = req->context;\n\tstruct uvc_video *video = ureq->video;\n\tstruct uvc_video_queue *queue = &video->queue;\n\tstruct uvc_device *uvc = video->uvc;\n\tunsigned long flags;\n\n\tswitch (req->status) {\n\tcase 0:\n\t\tbreak;\n\n\tcase -EXDEV:\n\t\tuvcg_dbg(&video->uvc->func, \"VS request missed xfer.\\n\");\n\t\tqueue->flags |= UVC_QUEUE_DROP_INCOMPLETE;\n\t\tbreak;\n\n\tcase -ESHUTDOWN:\t \n\t\tuvcg_dbg(&video->uvc->func, \"VS request cancelled.\\n\");\n\t\tuvcg_queue_cancel(queue, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tuvcg_warn(&video->uvc->func,\n\t\t\t  \"VS request completed with status %d.\\n\",\n\t\t\t  req->status);\n\t\tuvcg_queue_cancel(queue, 0);\n\t}\n\n\tif (ureq->last_buf) {\n\t\tuvcg_complete_buffer(&video->queue, ureq->last_buf);\n\t\tureq->last_buf = NULL;\n\t}\n\n\tspin_lock_irqsave(&video->req_lock, flags);\n\tlist_add_tail(&req->list, &video->req_free);\n\tspin_unlock_irqrestore(&video->req_lock, flags);\n\n\tif (uvc->state == UVC_STATE_STREAMING)\n\t\tqueue_work(video->async_wq, &video->pump);\n}\n\nstatic int\nuvc_video_free_requests(struct uvc_video *video)\n{\n\tunsigned int i;\n\n\tif (video->ureq) {\n\t\tfor (i = 0; i < video->uvc_num_requests; ++i) {\n\t\t\tsg_free_table(&video->ureq[i].sgt);\n\n\t\t\tif (video->ureq[i].req) {\n\t\t\t\tusb_ep_free_request(video->ep, video->ureq[i].req);\n\t\t\t\tvideo->ureq[i].req = NULL;\n\t\t\t}\n\n\t\t\tif (video->ureq[i].req_buffer) {\n\t\t\t\tkfree(video->ureq[i].req_buffer);\n\t\t\t\tvideo->ureq[i].req_buffer = NULL;\n\t\t\t}\n\t\t}\n\n\t\tkfree(video->ureq);\n\t\tvideo->ureq = NULL;\n\t}\n\n\tINIT_LIST_HEAD(&video->req_free);\n\tvideo->req_size = 0;\n\treturn 0;\n}\n\nstatic int\nuvc_video_alloc_requests(struct uvc_video *video)\n{\n\tunsigned int req_size;\n\tunsigned int i;\n\tint ret = -ENOMEM;\n\n\tBUG_ON(video->req_size);\n\n\treq_size = video->ep->maxpacket\n\t\t * max_t(unsigned int, video->ep->maxburst, 1)\n\t\t * (video->ep->mult);\n\n\tvideo->ureq = kcalloc(video->uvc_num_requests, sizeof(struct uvc_request), GFP_KERNEL);\n\tif (video->ureq == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < video->uvc_num_requests; ++i) {\n\t\tvideo->ureq[i].req_buffer = kmalloc(req_size, GFP_KERNEL);\n\t\tif (video->ureq[i].req_buffer == NULL)\n\t\t\tgoto error;\n\n\t\tvideo->ureq[i].req = usb_ep_alloc_request(video->ep, GFP_KERNEL);\n\t\tif (video->ureq[i].req == NULL)\n\t\t\tgoto error;\n\n\t\tvideo->ureq[i].req->buf = video->ureq[i].req_buffer;\n\t\tvideo->ureq[i].req->length = 0;\n\t\tvideo->ureq[i].req->complete = uvc_video_complete;\n\t\tvideo->ureq[i].req->context = &video->ureq[i];\n\t\tvideo->ureq[i].video = video;\n\t\tvideo->ureq[i].last_buf = NULL;\n\n\t\tlist_add_tail(&video->ureq[i].req->list, &video->req_free);\n\t\t \n\t\tsg_alloc_table(&video->ureq[i].sgt,\n\t\t\t       DIV_ROUND_UP(req_size - UVCG_REQUEST_HEADER_LEN,\n\t\t\t\t\t    PAGE_SIZE) + 2, GFP_KERNEL);\n\t}\n\n\tvideo->req_size = req_size;\n\n\treturn 0;\n\nerror:\n\tuvc_video_free_requests(video);\n\treturn ret;\n}\n\n \n\n \nstatic void uvcg_video_pump(struct work_struct *work)\n{\n\tstruct uvc_video *video = container_of(work, struct uvc_video, pump);\n\tstruct uvc_video_queue *queue = &video->queue;\n\t \n\tbool is_bulk = video->max_payload_size;\n\tstruct usb_request *req = NULL;\n\tstruct uvc_buffer *buf;\n\tunsigned long flags;\n\tbool buf_done;\n\tint ret;\n\n\twhile (video->ep->enabled) {\n\t\t \n\t\tspin_lock_irqsave(&video->req_lock, flags);\n\t\tif (list_empty(&video->req_free)) {\n\t\t\tspin_unlock_irqrestore(&video->req_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\treq = list_first_entry(&video->req_free, struct usb_request,\n\t\t\t\t\tlist);\n\t\tlist_del(&req->list);\n\t\tspin_unlock_irqrestore(&video->req_lock, flags);\n\n\t\t \n\t\tspin_lock_irqsave(&queue->irqlock, flags);\n\t\tbuf = uvcg_queue_head(queue);\n\n\t\tif (buf != NULL) {\n\t\t\tvideo->encode(req, video, buf);\n\t\t\tbuf_done = buf->state == UVC_BUF_STATE_DONE;\n\t\t} else if (!(queue->flags & UVC_QUEUE_DISCONNECTED) && !is_bulk) {\n\t\t\t \n\t\t\treq->length = 0;\n\t\t\tbuf_done = false;\n\t\t} else {\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&queue->irqlock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (list_empty(&video->req_free) || buf_done ||\n\t\t    !(video->req_int_count %\n\t\t       DIV_ROUND_UP(video->uvc_num_requests, 4))) {\n\t\t\tvideo->req_int_count = 0;\n\t\t\treq->no_interrupt = 0;\n\t\t} else {\n\t\t\treq->no_interrupt = 1;\n\t\t}\n\n\t\t \n\t\tret = uvcg_video_ep_queue(video, req);\n\t\tspin_unlock_irqrestore(&queue->irqlock, flags);\n\n\t\tif (ret < 0) {\n\t\t\tuvcg_queue_cancel(queue, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treq = NULL;\n\t\tvideo->req_int_count++;\n\t}\n\n\tif (!req)\n\t\treturn;\n\n\tspin_lock_irqsave(&video->req_lock, flags);\n\tlist_add_tail(&req->list, &video->req_free);\n\tspin_unlock_irqrestore(&video->req_lock, flags);\n\treturn;\n}\n\n \nint uvcg_video_enable(struct uvc_video *video, int enable)\n{\n\tunsigned int i;\n\tint ret;\n\n\tif (video->ep == NULL) {\n\t\tuvcg_info(&video->uvc->func,\n\t\t\t  \"Video enable failed, device is uninitialized.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!enable) {\n\t\tcancel_work_sync(&video->pump);\n\t\tuvcg_queue_cancel(&video->queue, 0);\n\n\t\tfor (i = 0; i < video->uvc_num_requests; ++i)\n\t\t\tif (video->ureq && video->ureq[i].req)\n\t\t\t\tusb_ep_dequeue(video->ep, video->ureq[i].req);\n\n\t\tuvc_video_free_requests(video);\n\t\tuvcg_queue_enable(&video->queue, 0);\n\t\treturn 0;\n\t}\n\n\tif ((ret = uvcg_queue_enable(&video->queue, 1)) < 0)\n\t\treturn ret;\n\n\tif ((ret = uvc_video_alloc_requests(video)) < 0)\n\t\treturn ret;\n\n\tif (video->max_payload_size) {\n\t\tvideo->encode = uvc_video_encode_bulk;\n\t\tvideo->payload_size = 0;\n\t} else\n\t\tvideo->encode = video->queue.use_sg ?\n\t\t\tuvc_video_encode_isoc_sg : uvc_video_encode_isoc;\n\n\tvideo->req_int_count = 0;\n\n\tqueue_work(video->async_wq, &video->pump);\n\n\treturn ret;\n}\n\n \nint uvcg_video_init(struct uvc_video *video, struct uvc_device *uvc)\n{\n\tINIT_LIST_HEAD(&video->req_free);\n\tspin_lock_init(&video->req_lock);\n\tINIT_WORK(&video->pump, uvcg_video_pump);\n\n\t \n\tvideo->async_wq = alloc_workqueue(\"uvcgadget\", WQ_UNBOUND | WQ_HIGHPRI, 0);\n\tif (!video->async_wq)\n\t\treturn -EINVAL;\n\n\tvideo->uvc = uvc;\n\tvideo->fcc = V4L2_PIX_FMT_YUYV;\n\tvideo->bpp = 16;\n\tvideo->width = 320;\n\tvideo->height = 240;\n\tvideo->imagesize = 320 * 240 * 2;\n\n\t \n\tuvcg_queue_init(&video->queue, uvc->v4l2_dev.dev->parent,\n\t\t\tV4L2_BUF_TYPE_VIDEO_OUTPUT, &video->mutex);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}