{
  "module_name": "uvc_queue.c",
  "hash_id": "94dacefd6e3b2decd21908146eecea6d92744c55edc6043cb4b8db7e5419d6b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc_queue.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/videodev2.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n\n#include <media/v4l2-common.h>\n#include <media/videobuf2-dma-sg.h>\n#include <media/videobuf2-vmalloc.h>\n\n#include \"uvc.h\"\n\n \n\n \n\nstatic int uvc_queue_setup(struct vb2_queue *vq,\n\t\t\t   unsigned int *nbuffers, unsigned int *nplanes,\n\t\t\t   unsigned int sizes[], struct device *alloc_devs[])\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vq);\n\tstruct uvc_video *video = container_of(queue, struct uvc_video, queue);\n\tunsigned int req_size;\n\tunsigned int nreq;\n\n\tif (*nbuffers > UVC_MAX_VIDEO_BUFFERS)\n\t\t*nbuffers = UVC_MAX_VIDEO_BUFFERS;\n\n\t*nplanes = 1;\n\n\tsizes[0] = video->imagesize;\n\n\treq_size = video->ep->maxpacket\n\t\t * max_t(unsigned int, video->ep->maxburst, 1)\n\t\t * (video->ep->mult);\n\n\t \n\tnreq = DIV_ROUND_UP(DIV_ROUND_UP(sizes[0], 2), req_size);\n\tnreq = clamp(nreq, 4U, 64U);\n\tvideo->uvc_num_requests = nreq;\n\n\treturn 0;\n}\n\nstatic int uvc_buffer_prepare(struct vb2_buffer *vb)\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct uvc_buffer *buf = container_of(vbuf, struct uvc_buffer, buf);\n\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT &&\n\t    vb2_get_plane_payload(vb, 0) > vb2_plane_size(vb, 0)) {\n\t\tuvc_trace(UVC_TRACE_CAPTURE, \"[E] Bytes used out of bounds.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(queue->flags & UVC_QUEUE_DISCONNECTED))\n\t\treturn -ENODEV;\n\n\tbuf->state = UVC_BUF_STATE_QUEUED;\n\tif (queue->use_sg) {\n\t\tbuf->sgt = vb2_dma_sg_plane_desc(vb, 0);\n\t\tbuf->sg = buf->sgt->sgl;\n\t} else {\n\t\tbuf->mem = vb2_plane_vaddr(vb, 0);\n\t}\n\tbuf->length = vb2_plane_size(vb, 0);\n\tif (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\n\t\tbuf->bytesused = 0;\n\telse\n\t\tbuf->bytesused = vb2_get_plane_payload(vb, 0);\n\n\treturn 0;\n}\n\nstatic void uvc_buffer_queue(struct vb2_buffer *vb)\n{\n\tstruct uvc_video_queue *queue = vb2_get_drv_priv(vb->vb2_queue);\n\tstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\n\tstruct uvc_buffer *buf = container_of(vbuf, struct uvc_buffer, buf);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\n\tif (likely(!(queue->flags & UVC_QUEUE_DISCONNECTED))) {\n\t\tlist_add_tail(&buf->queue, &queue->irqqueue);\n\t} else {\n\t\t \n\t\tbuf->state = UVC_BUF_STATE_ERROR;\n\t\tvb2_buffer_done(vb, VB2_BUF_STATE_ERROR);\n\t}\n\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n}\n\nstatic const struct vb2_ops uvc_queue_qops = {\n\t.queue_setup = uvc_queue_setup,\n\t.buf_prepare = uvc_buffer_prepare,\n\t.buf_queue = uvc_buffer_queue,\n\t.wait_prepare = vb2_ops_wait_prepare,\n\t.wait_finish = vb2_ops_wait_finish,\n};\n\nint uvcg_queue_init(struct uvc_video_queue *queue, struct device *dev, enum v4l2_buf_type type,\n\t\t    struct mutex *lock)\n{\n\tstruct uvc_video *video = container_of(queue, struct uvc_video, queue);\n\tstruct usb_composite_dev *cdev = video->uvc->func.config->cdev;\n\tint ret;\n\n\tqueue->queue.type = type;\n\tqueue->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;\n\tqueue->queue.drv_priv = queue;\n\tqueue->queue.buf_struct_size = sizeof(struct uvc_buffer);\n\tqueue->queue.ops = &uvc_queue_qops;\n\tqueue->queue.lock = lock;\n\tif (cdev->gadget->sg_supported) {\n\t\tqueue->queue.mem_ops = &vb2_dma_sg_memops;\n\t\tqueue->use_sg = 1;\n\t} else {\n\t\tqueue->queue.mem_ops = &vb2_vmalloc_memops;\n\t}\n\n\tqueue->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY\n\t\t\t\t     | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;\n\tqueue->queue.dev = dev;\n\n\tret = vb2_queue_init(&queue->queue);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_init(&queue->irqlock);\n\tINIT_LIST_HEAD(&queue->irqqueue);\n\tqueue->flags = 0;\n\n\treturn 0;\n}\n\n \nvoid uvcg_free_buffers(struct uvc_video_queue *queue)\n{\n\tvb2_queue_release(&queue->queue);\n}\n\n \nint uvcg_alloc_buffers(struct uvc_video_queue *queue,\n\t\t\t      struct v4l2_requestbuffers *rb)\n{\n\tint ret;\n\n\tret = vb2_reqbufs(&queue->queue, rb);\n\n\treturn ret ? ret : rb->count;\n}\n\nint uvcg_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\n{\n\treturn vb2_querybuf(&queue->queue, buf);\n}\n\nint uvcg_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf)\n{\n\treturn vb2_qbuf(&queue->queue, NULL, buf);\n}\n\n \nint uvcg_dequeue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf,\n\t\t\tint nonblocking)\n{\n\treturn vb2_dqbuf(&queue->queue, buf, nonblocking);\n}\n\n \n__poll_t uvcg_queue_poll(struct uvc_video_queue *queue, struct file *file,\n\t\t\t     poll_table *wait)\n{\n\treturn vb2_poll(&queue->queue, file, wait);\n}\n\nint uvcg_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma)\n{\n\treturn vb2_mmap(&queue->queue, vma);\n}\n\n#ifndef CONFIG_MMU\n \nunsigned long uvcg_queue_get_unmapped_area(struct uvc_video_queue *queue,\n\t\t\t\t\t   unsigned long pgoff)\n{\n\treturn vb2_get_unmapped_area(&queue->queue, 0, 0, pgoff, 0);\n}\n#endif\n\n \nvoid uvcg_queue_cancel(struct uvc_video_queue *queue, int disconnect)\n{\n\tstruct uvc_buffer *buf;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&queue->irqlock, flags);\n\twhile (!list_empty(&queue->irqqueue)) {\n\t\tbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\n\t\t\t\t       queue);\n\t\tlist_del(&buf->queue);\n\t\tbuf->state = UVC_BUF_STATE_ERROR;\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t}\n\tqueue->buf_used = 0;\n\n\t \n\tif (disconnect)\n\t\tqueue->flags |= UVC_QUEUE_DISCONNECTED;\n\tspin_unlock_irqrestore(&queue->irqlock, flags);\n}\n\n \nint uvcg_queue_enable(struct uvc_video_queue *queue, int enable)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = vb2_streamon(&queue->queue, queue->queue.type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tqueue->sequence = 0;\n\t\tqueue->buf_used = 0;\n\t\tqueue->flags &= ~UVC_QUEUE_DROP_INCOMPLETE;\n\t} else {\n\t\tret = vb2_streamoff(&queue->queue, queue->queue.type);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tspin_lock_irqsave(&queue->irqlock, flags);\n\t\tINIT_LIST_HEAD(&queue->irqqueue);\n\n\t\t \n\t\tqueue->flags &= ~UVC_QUEUE_DISCONNECTED;\n\t\tspin_unlock_irqrestore(&queue->irqlock, flags);\n\t}\n\n\treturn ret;\n}\n\n \nvoid uvcg_complete_buffer(struct uvc_video_queue *queue,\n\t\t\t\t\t  struct uvc_buffer *buf)\n{\n\tif (queue->flags & UVC_QUEUE_DROP_INCOMPLETE) {\n\t\tqueue->flags &= ~UVC_QUEUE_DROP_INCOMPLETE;\n\t\tbuf->state = UVC_BUF_STATE_ERROR;\n\t\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, 0);\n\t\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_ERROR);\n\t\treturn;\n\t}\n\n\tbuf->buf.field = V4L2_FIELD_NONE;\n\tbuf->buf.sequence = queue->sequence++;\n\tbuf->buf.vb2_buf.timestamp = ktime_get_ns();\n\n\tvb2_set_plane_payload(&buf->buf.vb2_buf, 0, buf->bytesused);\n\tvb2_buffer_done(&buf->buf.vb2_buf, VB2_BUF_STATE_DONE);\n}\n\nstruct uvc_buffer *uvcg_queue_head(struct uvc_video_queue *queue)\n{\n\tstruct uvc_buffer *buf = NULL;\n\n\tif (!list_empty(&queue->irqqueue))\n\t\tbuf = list_first_entry(&queue->irqqueue, struct uvc_buffer,\n\t\t\t\t       queue);\n\n\treturn buf;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}