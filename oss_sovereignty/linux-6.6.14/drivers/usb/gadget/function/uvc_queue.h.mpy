{
  "module_name": "uvc_queue.h",
  "hash_id": "7ca4553b2b8fc7dd60d62f5353457c281afd7ec32989ff683462e88a8634f68c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc_queue.h",
  "human_readable_source": " \n#ifndef _UVC_QUEUE_H_\n#define _UVC_QUEUE_H_\n\n#include <linux/list.h>\n#include <linux/poll.h>\n#include <linux/spinlock.h>\n\n#include <media/videobuf2-v4l2.h>\n\nstruct file;\nstruct mutex;\n\n \n#define UVC_MAX_FRAME_SIZE\t(16*1024*1024)\n \n#define UVC_MAX_VIDEO_BUFFERS\t32\n\n \n\nenum uvc_buffer_state {\n\tUVC_BUF_STATE_IDLE\t= 0,\n\tUVC_BUF_STATE_QUEUED\t= 1,\n\tUVC_BUF_STATE_ACTIVE\t= 2,\n\tUVC_BUF_STATE_DONE\t= 3,\n\tUVC_BUF_STATE_ERROR\t= 4,\n};\n\nstruct uvc_buffer {\n\tstruct vb2_v4l2_buffer buf;\n\tstruct list_head queue;\n\n\tenum uvc_buffer_state state;\n\tvoid *mem;\n\tstruct sg_table *sgt;\n\tstruct scatterlist *sg;\n\tunsigned int offset;\n\tunsigned int length;\n\tunsigned int bytesused;\n};\n\n#define UVC_QUEUE_DISCONNECTED\t\t(1 << 0)\n#define UVC_QUEUE_DROP_INCOMPLETE\t(1 << 1)\n\nstruct uvc_video_queue {\n\tstruct vb2_queue queue;\n\n\tunsigned int flags;\n\t__u32 sequence;\n\n\tunsigned int buf_used;\n\n\tbool use_sg;\n\n\tspinlock_t irqlock;\t \n\tstruct list_head irqqueue;\n};\n\nstatic inline int uvc_queue_streaming(struct uvc_video_queue *queue)\n{\n\treturn vb2_is_streaming(&queue->queue);\n}\n\nint uvcg_queue_init(struct uvc_video_queue *queue, struct device *dev, enum v4l2_buf_type type,\n\t\t    struct mutex *lock);\n\nvoid uvcg_free_buffers(struct uvc_video_queue *queue);\n\nint uvcg_alloc_buffers(struct uvc_video_queue *queue,\n\t\t       struct v4l2_requestbuffers *rb);\n\nint uvcg_query_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf);\n\nint uvcg_queue_buffer(struct uvc_video_queue *queue, struct v4l2_buffer *buf);\n\nint uvcg_dequeue_buffer(struct uvc_video_queue *queue,\n\t\t\tstruct v4l2_buffer *buf, int nonblocking);\n\n__poll_t uvcg_queue_poll(struct uvc_video_queue *queue,\n\t\t\t     struct file *file, poll_table *wait);\n\nint uvcg_queue_mmap(struct uvc_video_queue *queue, struct vm_area_struct *vma);\n\n#ifndef CONFIG_MMU\nunsigned long uvcg_queue_get_unmapped_area(struct uvc_video_queue *queue,\n\t\t\t\t\t   unsigned long pgoff);\n#endif  \n\nvoid uvcg_queue_cancel(struct uvc_video_queue *queue, int disconnect);\n\nint uvcg_queue_enable(struct uvc_video_queue *queue, int enable);\n\nvoid uvcg_complete_buffer(struct uvc_video_queue *queue,\n\t\t\t\t\t  struct uvc_buffer *buf);\n\nstruct uvc_buffer *uvcg_queue_head(struct uvc_video_queue *queue);\n\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}