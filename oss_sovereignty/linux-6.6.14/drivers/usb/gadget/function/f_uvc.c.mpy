{
  "module_name": "f_uvc.c",
  "hash_id": "7389e81b52f33735ae5a88f9164fb9e2b182965fd22c05807493880efd95ceae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_uvc.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/g_uvc.h>\n#include <linux/usb/video.h>\n#include <linux/vmalloc.h>\n#include <linux/wait.h>\n\n#include <media/v4l2-dev.h>\n#include <media/v4l2-event.h>\n\n#include \"uvc.h\"\n#include \"uvc_configfs.h\"\n#include \"uvc_v4l2.h\"\n#include \"uvc_video.h\"\n\nunsigned int uvc_gadget_trace_param;\nmodule_param_named(trace, uvc_gadget_trace_param, uint, 0644);\nMODULE_PARM_DESC(trace, \"Trace level bitmask\");\n\n \n\n \n\nstatic struct usb_string uvc_en_us_strings[] = {\n\t \n\t[UVC_STRING_STREAMING_IDX].s = \"Video Streaming\",\n\t{  }\n};\n\nstatic struct usb_gadget_strings uvc_stringtab = {\n\t.language = 0x0409,\t \n\t.strings = uvc_en_us_strings,\n};\n\nstatic struct usb_gadget_strings *uvc_function_strings[] = {\n\t&uvc_stringtab,\n\tNULL,\n};\n\n#define UVC_INTF_VIDEO_CONTROL\t\t\t0\n#define UVC_INTF_VIDEO_STREAMING\t\t1\n\n#define UVC_STATUS_MAX_PACKET_SIZE\t\t16\t \n\nstatic struct usb_interface_assoc_descriptor uvc_iad = {\n\t.bLength\t\t= sizeof(uvc_iad),\n\t.bDescriptorType\t= USB_DT_INTERFACE_ASSOCIATION,\n\t.bFirstInterface\t= 0,\n\t.bInterfaceCount\t= 2,\n\t.bFunctionClass\t\t= USB_CLASS_VIDEO,\n\t.bFunctionSubClass\t= UVC_SC_VIDEO_INTERFACE_COLLECTION,\n\t.bFunctionProtocol\t= 0x00,\n\t.iFunction\t\t= 0,\n};\n\nstatic struct usb_interface_descriptor uvc_control_intf = {\n\t.bLength\t\t= USB_DT_INTERFACE_SIZE,\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= UVC_INTF_VIDEO_CONTROL,\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 0,\n\t.bInterfaceClass\t= USB_CLASS_VIDEO,\n\t.bInterfaceSubClass\t= UVC_SC_VIDEOCONTROL,\n\t.bInterfaceProtocol\t= 0x00,\n\t.iInterface\t\t= 0,\n};\n\nstatic struct usb_endpoint_descriptor uvc_interrupt_ep = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize\t\t= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),\n\t.bInterval\t\t= 8,\n};\n\nstatic struct usb_ss_ep_comp_descriptor uvc_ss_interrupt_comp = {\n\t.bLength\t\t= sizeof(uvc_ss_interrupt_comp),\n\t.bDescriptorType\t= USB_DT_SS_ENDPOINT_COMP,\n\t \n\t.bMaxBurst\t\t= 0,\n\t.bmAttributes\t\t= 0,\n\t.wBytesPerInterval\t= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),\n};\n\nstatic struct uvc_control_endpoint_descriptor uvc_interrupt_cs_ep = {\n\t.bLength\t\t= UVC_DT_CONTROL_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_CS_ENDPOINT,\n\t.bDescriptorSubType\t= UVC_EP_INTERRUPT,\n\t.wMaxTransferSize\t= cpu_to_le16(UVC_STATUS_MAX_PACKET_SIZE),\n};\n\nstatic struct usb_interface_descriptor uvc_streaming_intf_alt0 = {\n\t.bLength\t\t= USB_DT_INTERFACE_SIZE,\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= UVC_INTF_VIDEO_STREAMING,\n\t.bAlternateSetting\t= 0,\n\t.bNumEndpoints\t\t= 0,\n\t.bInterfaceClass\t= USB_CLASS_VIDEO,\n\t.bInterfaceSubClass\t= UVC_SC_VIDEOSTREAMING,\n\t.bInterfaceProtocol\t= 0x00,\n\t.iInterface\t\t= 0,\n};\n\nstatic struct usb_interface_descriptor uvc_streaming_intf_alt1 = {\n\t.bLength\t\t= USB_DT_INTERFACE_SIZE,\n\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t.bInterfaceNumber\t= UVC_INTF_VIDEO_STREAMING,\n\t.bAlternateSetting\t= 1,\n\t.bNumEndpoints\t\t= 1,\n\t.bInterfaceClass\t= USB_CLASS_VIDEO,\n\t.bInterfaceSubClass\t= UVC_SC_VIDEOSTREAMING,\n\t.bInterfaceProtocol\t= 0x00,\n\t.iInterface\t\t= 0,\n};\n\nstatic struct usb_endpoint_descriptor uvc_fs_streaming_ep = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_SYNC_ASYNC\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t \n};\n\nstatic struct usb_endpoint_descriptor uvc_hs_streaming_ep = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_SYNC_ASYNC\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t \n};\n\nstatic struct usb_endpoint_descriptor uvc_ss_streaming_ep = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\n\t.bEndpointAddress\t= USB_DIR_IN,\n\t.bmAttributes\t\t= USB_ENDPOINT_SYNC_ASYNC\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t \n};\n\nstatic struct usb_ss_ep_comp_descriptor uvc_ss_streaming_comp = {\n\t.bLength\t\t= sizeof(uvc_ss_streaming_comp),\n\t.bDescriptorType\t= USB_DT_SS_ENDPOINT_COMP,\n\t \n};\n\nstatic const struct usb_descriptor_header * const uvc_fs_streaming[] = {\n\t(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,\n\t(struct usb_descriptor_header *) &uvc_fs_streaming_ep,\n\tNULL,\n};\n\nstatic const struct usb_descriptor_header * const uvc_hs_streaming[] = {\n\t(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,\n\t(struct usb_descriptor_header *) &uvc_hs_streaming_ep,\n\tNULL,\n};\n\nstatic const struct usb_descriptor_header * const uvc_ss_streaming[] = {\n\t(struct usb_descriptor_header *) &uvc_streaming_intf_alt1,\n\t(struct usb_descriptor_header *) &uvc_ss_streaming_ep,\n\t(struct usb_descriptor_header *) &uvc_ss_streaming_comp,\n\tNULL,\n};\n\n \n\nstatic void\nuvc_function_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct uvc_device *uvc = req->context;\n\tstruct v4l2_event v4l2_event;\n\tstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\n\n\tif (uvc->event_setup_out) {\n\t\tuvc->event_setup_out = 0;\n\n\t\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\t\tv4l2_event.type = UVC_EVENT_DATA;\n\t\tuvc_event->data.length = min_t(unsigned int, req->actual,\n\t\t\tsizeof(uvc_event->data.data));\n\t\tmemcpy(&uvc_event->data.data, req->buf, uvc_event->data.length);\n\t\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\t}\n}\n\nstatic int\nuvc_function_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct v4l2_event v4l2_event;\n\tstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\n\tunsigned int interface = le16_to_cpu(ctrl->wIndex) & 0xff;\n\tstruct usb_ctrlrequest *mctrl;\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS) {\n\t\tuvcg_info(f, \"invalid request type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le16_to_cpu(ctrl->wLength) > UVC_MAX_REQUEST_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tuvc->event_setup_out = !(ctrl->bRequestType & USB_DIR_IN);\n\tuvc->event_length = le16_to_cpu(ctrl->wLength);\n\n\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\tv4l2_event.type = UVC_EVENT_SETUP;\n\tmemcpy(&uvc_event->req, ctrl, sizeof(uvc_event->req));\n\n\t \n\tmctrl = &uvc_event->req;\n\tmctrl->wIndex &= ~cpu_to_le16(0xff);\n\tif (interface == uvc->streaming_intf)\n\t\tmctrl->wIndex = cpu_to_le16(UVC_STRING_STREAMING_IDX);\n\n\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\n\treturn 0;\n}\n\nvoid uvc_function_setup_continue(struct uvc_device *uvc)\n{\n\tstruct usb_composite_dev *cdev = uvc->func.config->cdev;\n\n\tusb_composite_setup_continue(cdev);\n}\n\nstatic int\nuvc_function_get_alt(struct usb_function *f, unsigned interface)\n{\n\tstruct uvc_device *uvc = to_uvc(f);\n\n\tuvcg_info(f, \"%s(%u)\\n\", __func__, interface);\n\n\tif (interface == uvc->control_intf)\n\t\treturn 0;\n\telse if (interface != uvc->streaming_intf)\n\t\treturn -EINVAL;\n\telse\n\t\treturn uvc->video.ep->enabled ? 1 : 0;\n}\n\nstatic int\nuvc_function_set_alt(struct usb_function *f, unsigned interface, unsigned alt)\n{\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct v4l2_event v4l2_event;\n\tstruct uvc_event *uvc_event = (void *)&v4l2_event.u.data;\n\tint ret;\n\n\tuvcg_info(f, \"%s(%u, %u)\\n\", __func__, interface, alt);\n\n\tif (interface == uvc->control_intf) {\n\t\tif (alt)\n\t\t\treturn -EINVAL;\n\n\t\tif (uvc->enable_interrupt_ep) {\n\t\t\tuvcg_info(f, \"reset UVC interrupt endpoint\\n\");\n\t\t\tusb_ep_disable(uvc->interrupt_ep);\n\n\t\t\tif (!uvc->interrupt_ep->desc)\n\t\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t\t       uvc->interrupt_ep))\n\t\t\t\t\treturn -EINVAL;\n\n\t\t\tusb_ep_enable(uvc->interrupt_ep);\n\t\t}\n\n\t\tif (uvc->state == UVC_STATE_DISCONNECTED) {\n\t\t\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\t\t\tv4l2_event.type = UVC_EVENT_CONNECT;\n\t\t\tuvc_event->speed = cdev->gadget->speed;\n\t\t\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\n\t\t\tuvc->state = UVC_STATE_CONNECTED;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (interface != uvc->streaming_intf)\n\t\treturn -EINVAL;\n\n\t \n\n\tswitch (alt) {\n\tcase 0:\n\t\tif (uvc->state != UVC_STATE_STREAMING)\n\t\t\treturn 0;\n\n\t\tif (uvc->video.ep)\n\t\t\tusb_ep_disable(uvc->video.ep);\n\n\t\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\t\tv4l2_event.type = UVC_EVENT_STREAMOFF;\n\t\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\n\t\tuvc->state = UVC_STATE_CONNECTED;\n\t\treturn 0;\n\n\tcase 1:\n\t\tif (uvc->state != UVC_STATE_CONNECTED)\n\t\t\treturn 0;\n\n\t\tif (!uvc->video.ep)\n\t\t\treturn -EINVAL;\n\n\t\tuvcg_info(f, \"reset UVC\\n\");\n\t\tusb_ep_disable(uvc->video.ep);\n\n\t\tret = config_ep_by_speed(f->config->cdev->gadget,\n\t\t\t\t&(uvc->func), uvc->video.ep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tusb_ep_enable(uvc->video.ep);\n\n\t\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\t\tv4l2_event.type = UVC_EVENT_STREAMON;\n\t\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\t\treturn USB_GADGET_DELAYED_STATUS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void\nuvc_function_disable(struct usb_function *f)\n{\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct v4l2_event v4l2_event;\n\n\tuvcg_info(f, \"%s()\\n\", __func__);\n\n\tmemset(&v4l2_event, 0, sizeof(v4l2_event));\n\tv4l2_event.type = UVC_EVENT_DISCONNECT;\n\tv4l2_event_queue(&uvc->vdev, &v4l2_event);\n\n\tuvc->state = UVC_STATE_DISCONNECTED;\n\n\tusb_ep_disable(uvc->video.ep);\n\tif (uvc->enable_interrupt_ep)\n\t\tusb_ep_disable(uvc->interrupt_ep);\n}\n\n \n\nvoid\nuvc_function_connect(struct uvc_device *uvc)\n{\n\tint ret;\n\n\tif ((ret = usb_function_activate(&uvc->func)) < 0)\n\t\tuvcg_info(&uvc->func, \"UVC connect failed with %d\\n\", ret);\n}\n\nvoid\nuvc_function_disconnect(struct uvc_device *uvc)\n{\n\tint ret;\n\n\tif ((ret = usb_function_deactivate(&uvc->func)) < 0)\n\t\tuvcg_info(&uvc->func, \"UVC disconnect failed with %d\\n\", ret);\n}\n\n \n\nstatic ssize_t function_name_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct uvc_device *uvc = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", uvc->func.fi->group.cg_item.ci_name);\n}\n\nstatic DEVICE_ATTR_RO(function_name);\n\nstatic int\nuvc_register_video(struct uvc_device *uvc)\n{\n\tstruct usb_composite_dev *cdev = uvc->func.config->cdev;\n\tint ret;\n\n\t \n\tmemset(&uvc->vdev, 0, sizeof(uvc->vdev));\n\tuvc->vdev.v4l2_dev = &uvc->v4l2_dev;\n\tuvc->vdev.v4l2_dev->dev = &cdev->gadget->dev;\n\tuvc->vdev.fops = &uvc_v4l2_fops;\n\tuvc->vdev.ioctl_ops = &uvc_v4l2_ioctl_ops;\n\tuvc->vdev.release = video_device_release_empty;\n\tuvc->vdev.vfl_dir = VFL_DIR_TX;\n\tuvc->vdev.lock = &uvc->video.mutex;\n\tuvc->vdev.device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;\n\tstrscpy(uvc->vdev.name, cdev->gadget->name, sizeof(uvc->vdev.name));\n\n\tvideo_set_drvdata(&uvc->vdev, uvc);\n\n\tret = video_register_device(&uvc->vdev, VFL_TYPE_VIDEO, -1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_create_file(&uvc->vdev.dev, &dev_attr_function_name);\n\tif (ret < 0) {\n\t\tvideo_unregister_device(&uvc->vdev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define UVC_COPY_DESCRIPTOR(mem, dst, desc) \\\n\tdo { \\\n\t\tmemcpy(mem, desc, (desc)->bLength); \\\n\t\t*(dst)++ = mem; \\\n\t\tmem += (desc)->bLength; \\\n\t} while (0);\n\n#define UVC_COPY_DESCRIPTORS(mem, dst, src) \\\n\tdo { \\\n\t\tconst struct usb_descriptor_header * const *__src; \\\n\t\tfor (__src = src; *__src; ++__src) { \\\n\t\t\tmemcpy(mem, *__src, (*__src)->bLength); \\\n\t\t\t*dst++ = mem; \\\n\t\t\tmem += (*__src)->bLength; \\\n\t\t} \\\n\t} while (0)\n\n#define UVC_COPY_XU_DESCRIPTOR(mem, dst, desc)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\t\\\n\t\t*(dst)++ = mem;\t\t\t\t\t\t\t\\\n\t\tmemcpy(mem, desc, 22);  \t\t\\\n\t\tmem += 22;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(mem, (desc)->baSourceID, (desc)->bNrInPins);\t\t\\\n\t\tmem += (desc)->bNrInPins;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(mem, &(desc)->bControlSize, 1);\t\t\t\t\\\n\t\tmem++;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(mem, (desc)->bmControls, (desc)->bControlSize);\t\t\\\n\t\tmem += (desc)->bControlSize;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\\\n\t\tmemcpy(mem, &(desc)->iExtension, 1);\t\t\t\t\\\n\t\tmem++;\t\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic struct usb_descriptor_header **\nuvc_copy_descriptors(struct uvc_device *uvc, enum usb_device_speed speed)\n{\n\tstruct uvc_input_header_descriptor *uvc_streaming_header;\n\tstruct uvc_header_descriptor *uvc_control_header;\n\tconst struct uvc_descriptor_header * const *uvc_control_desc;\n\tconst struct uvc_descriptor_header * const *uvc_streaming_cls;\n\tconst struct usb_descriptor_header * const *uvc_streaming_std;\n\tconst struct usb_descriptor_header * const *src;\n\tstruct usb_descriptor_header **dst;\n\tstruct usb_descriptor_header **hdr;\n\tstruct uvcg_extension *xu;\n\tunsigned int control_size;\n\tunsigned int streaming_size;\n\tunsigned int n_desc;\n\tunsigned int bytes;\n\tvoid *mem;\n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER:\n\t\tuvc_control_desc = uvc->desc.ss_control;\n\t\tuvc_streaming_cls = uvc->desc.ss_streaming;\n\t\tuvc_streaming_std = uvc_ss_streaming;\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\n\t\tuvc_control_desc = uvc->desc.fs_control;\n\t\tuvc_streaming_cls = uvc->desc.hs_streaming;\n\t\tuvc_streaming_std = uvc_hs_streaming;\n\t\tbreak;\n\n\tcase USB_SPEED_FULL:\n\tdefault:\n\t\tuvc_control_desc = uvc->desc.fs_control;\n\t\tuvc_streaming_cls = uvc->desc.fs_streaming;\n\t\tuvc_streaming_std = uvc_fs_streaming;\n\t\tbreak;\n\t}\n\n\tif (!uvc_control_desc || !uvc_streaming_cls)\n\t\treturn ERR_PTR(-ENODEV);\n\n\t \n\n\t \n\tcontrol_size = 0;\n\tstreaming_size = 0;\n\tbytes = uvc_iad.bLength + uvc_control_intf.bLength\n\t      + uvc_streaming_intf_alt0.bLength;\n\n\tn_desc = 3;\n\tif (uvc->enable_interrupt_ep) {\n\t\tbytes += uvc_interrupt_ep.bLength + uvc_interrupt_cs_ep.bLength;\n\t\tn_desc += 2;\n\n\t\tif (speed == USB_SPEED_SUPER) {\n\t\t\tbytes += uvc_ss_interrupt_comp.bLength;\n\t\t\tn_desc += 1;\n\t\t}\n\t}\n\n\tfor (src = (const struct usb_descriptor_header **)uvc_control_desc;\n\t     *src; ++src) {\n\t\tcontrol_size += (*src)->bLength;\n\t\tbytes += (*src)->bLength;\n\t\tn_desc++;\n\t}\n\n\tlist_for_each_entry(xu, uvc->desc.extension_units, list) {\n\t\tcontrol_size += xu->desc.bLength;\n\t\tbytes += xu->desc.bLength;\n\t\tn_desc++;\n\t}\n\n\tfor (src = (const struct usb_descriptor_header **)uvc_streaming_cls;\n\t     *src; ++src) {\n\t\tstreaming_size += (*src)->bLength;\n\t\tbytes += (*src)->bLength;\n\t\tn_desc++;\n\t}\n\tfor (src = uvc_streaming_std; *src; ++src) {\n\t\tbytes += (*src)->bLength;\n\t\tn_desc++;\n\t}\n\n\tmem = kmalloc((n_desc + 1) * sizeof(*src) + bytes, GFP_KERNEL);\n\tif (mem == NULL)\n\t\treturn NULL;\n\n\thdr = mem;\n\tdst = mem;\n\tmem += (n_desc + 1) * sizeof(*src);\n\n\t \n\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_iad);\n\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_control_intf);\n\n\tuvc_control_header = mem;\n\tUVC_COPY_DESCRIPTORS(mem, dst,\n\t\t(const struct usb_descriptor_header **)uvc_control_desc);\n\n\tlist_for_each_entry(xu, uvc->desc.extension_units, list)\n\t\tUVC_COPY_XU_DESCRIPTOR(mem, dst, &xu->desc);\n\n\tuvc_control_header->wTotalLength = cpu_to_le16(control_size);\n\tuvc_control_header->bInCollection = 1;\n\tuvc_control_header->baInterfaceNr[0] = uvc->streaming_intf;\n\n\tif (uvc->enable_interrupt_ep) {\n\t\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_interrupt_ep);\n\t\tif (speed == USB_SPEED_SUPER)\n\t\t\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_ss_interrupt_comp);\n\n\t\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_interrupt_cs_ep);\n\t}\n\n\tUVC_COPY_DESCRIPTOR(mem, dst, &uvc_streaming_intf_alt0);\n\n\tuvc_streaming_header = mem;\n\tUVC_COPY_DESCRIPTORS(mem, dst,\n\t\t(const struct usb_descriptor_header**)uvc_streaming_cls);\n\tuvc_streaming_header->wTotalLength = cpu_to_le16(streaming_size);\n\tuvc_streaming_header->bEndpointAddress = uvc->video.ep->address;\n\n\tUVC_COPY_DESCRIPTORS(mem, dst, uvc_streaming_std);\n\n\t*dst = NULL;\n\treturn hdr;\n}\n\nstatic int\nuvc_function_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct uvcg_extension *xu;\n\tstruct usb_string *us;\n\tunsigned int max_packet_mult;\n\tunsigned int max_packet_size;\n\tstruct usb_ep *ep;\n\tstruct f_uvc_opts *opts;\n\tint ret = -EINVAL;\n\n\tuvcg_info(f, \"%s()\\n\", __func__);\n\n\topts = fi_to_f_uvc_opts(f->fi);\n\t \n\topts->streaming_interval = clamp(opts->streaming_interval, 1U, 16U);\n\topts->streaming_maxpacket = clamp(opts->streaming_maxpacket, 1U, 3072U);\n\topts->streaming_maxburst = min(opts->streaming_maxburst, 15U);\n\n\t \n\tif (opts->streaming_maxburst &&\n\t    (opts->streaming_maxpacket % 1024) != 0) {\n\t\topts->streaming_maxpacket = roundup(opts->streaming_maxpacket, 1024);\n\t\tuvcg_info(f, \"overriding streaming_maxpacket to %d\\n\",\n\t\t\t  opts->streaming_maxpacket);\n\t}\n\n\t \n\tif (opts->streaming_maxpacket <= 1024) {\n\t\tmax_packet_mult = 1;\n\t\tmax_packet_size = opts->streaming_maxpacket;\n\t} else if (opts->streaming_maxpacket <= 2048) {\n\t\tmax_packet_mult = 2;\n\t\tmax_packet_size = opts->streaming_maxpacket / 2;\n\t} else {\n\t\tmax_packet_mult = 3;\n\t\tmax_packet_size = opts->streaming_maxpacket / 3;\n\t}\n\n\tuvc_fs_streaming_ep.wMaxPacketSize =\n\t\tcpu_to_le16(min(opts->streaming_maxpacket, 1023U));\n\tuvc_fs_streaming_ep.bInterval = opts->streaming_interval;\n\n\tuvc_hs_streaming_ep.wMaxPacketSize =\n\t\tcpu_to_le16(max_packet_size | ((max_packet_mult - 1) << 11));\n\n\t \n\tif (max_packet_mult > 1)\n\t\tuvc_hs_streaming_ep.bInterval = 1;\n\telse\n\t\tuvc_hs_streaming_ep.bInterval = opts->streaming_interval;\n\n\tuvc_ss_streaming_ep.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\tuvc_ss_streaming_ep.bInterval = opts->streaming_interval;\n\tuvc_ss_streaming_comp.bmAttributes = max_packet_mult - 1;\n\tuvc_ss_streaming_comp.bMaxBurst = opts->streaming_maxburst;\n\tuvc_ss_streaming_comp.wBytesPerInterval =\n\t\tcpu_to_le16(max_packet_size * max_packet_mult *\n\t\t\t    (opts->streaming_maxburst + 1));\n\n\t \n\tif (opts->enable_interrupt_ep) {\n\t\tep = usb_ep_autoconfig(cdev->gadget, &uvc_interrupt_ep);\n\t\tif (!ep) {\n\t\t\tuvcg_info(f, \"Unable to allocate interrupt EP\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tuvc->interrupt_ep = ep;\n\t\tuvc_control_intf.bNumEndpoints = 1;\n\t}\n\tuvc->enable_interrupt_ep = opts->enable_interrupt_ep;\n\n\t \n\tif (gadget_is_superspeed(c->cdev->gadget))\n\t\tep = usb_ep_autoconfig_ss(cdev->gadget, &uvc_ss_streaming_ep,\n\t\t\t\t\t  &uvc_ss_streaming_comp);\n\telse if (gadget_is_dualspeed(cdev->gadget))\n\t\tep = usb_ep_autoconfig(cdev->gadget, &uvc_hs_streaming_ep);\n\telse\n\t\tep = usb_ep_autoconfig(cdev->gadget, &uvc_fs_streaming_ep);\n\n\tif (!ep) {\n\t\tuvcg_info(f, \"Unable to allocate streaming EP\\n\");\n\t\tgoto error;\n\t}\n\tuvc->video.ep = ep;\n\n\tuvc_fs_streaming_ep.bEndpointAddress = uvc->video.ep->address;\n\tuvc_hs_streaming_ep.bEndpointAddress = uvc->video.ep->address;\n\tuvc_ss_streaming_ep.bEndpointAddress = uvc->video.ep->address;\n\n\t \n\tlist_for_each_entry(xu, &opts->extension_units, list)\n\t\tif (xu->string_descriptor_index)\n\t\t\txu->desc.iExtension = cdev->usb_strings[xu->string_descriptor_index].id;\n\n\t \n\tuvc_en_us_strings[UVC_STRING_CONTROL_IDX].s = opts->function_name;\n\tus = usb_gstrings_attach(cdev, uvc_function_strings,\n\t\t\t\t ARRAY_SIZE(uvc_en_us_strings));\n\tif (IS_ERR(us)) {\n\t\tret = PTR_ERR(us);\n\t\tgoto error;\n\t}\n\n\tuvc_iad.iFunction = opts->iad_index ? cdev->usb_strings[opts->iad_index].id :\n\t\t\t    us[UVC_STRING_CONTROL_IDX].id;\n\tuvc_streaming_intf_alt0.iInterface = opts->vs0_index ?\n\t\t\t\t\t     cdev->usb_strings[opts->vs0_index].id :\n\t\t\t\t\t     us[UVC_STRING_STREAMING_IDX].id;\n\tuvc_streaming_intf_alt1.iInterface = opts->vs1_index ?\n\t\t\t\t\t     cdev->usb_strings[opts->vs1_index].id :\n\t\t\t\t\t     us[UVC_STRING_STREAMING_IDX].id;\n\n\t \n\tif ((ret = usb_interface_id(c, f)) < 0)\n\t\tgoto error;\n\tuvc_iad.bFirstInterface = ret;\n\tuvc_control_intf.bInterfaceNumber = ret;\n\tuvc->control_intf = ret;\n\topts->control_interface = ret;\n\n\tif ((ret = usb_interface_id(c, f)) < 0)\n\t\tgoto error;\n\tuvc_streaming_intf_alt0.bInterfaceNumber = ret;\n\tuvc_streaming_intf_alt1.bInterfaceNumber = ret;\n\tuvc->streaming_intf = ret;\n\topts->streaming_interface = ret;\n\n\t \n\tf->fs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_FULL);\n\tif (IS_ERR(f->fs_descriptors)) {\n\t\tret = PTR_ERR(f->fs_descriptors);\n\t\tf->fs_descriptors = NULL;\n\t\tgoto error;\n\t}\n\n\tf->hs_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_HIGH);\n\tif (IS_ERR(f->hs_descriptors)) {\n\t\tret = PTR_ERR(f->hs_descriptors);\n\t\tf->hs_descriptors = NULL;\n\t\tgoto error;\n\t}\n\n\tf->ss_descriptors = uvc_copy_descriptors(uvc, USB_SPEED_SUPER);\n\tif (IS_ERR(f->ss_descriptors)) {\n\t\tret = PTR_ERR(f->ss_descriptors);\n\t\tf->ss_descriptors = NULL;\n\t\tgoto error;\n\t}\n\n\t \n\tuvc->control_req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\n\tuvc->control_buf = kmalloc(UVC_MAX_REQUEST_SIZE, GFP_KERNEL);\n\tif (uvc->control_req == NULL || uvc->control_buf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tuvc->control_req->buf = uvc->control_buf;\n\tuvc->control_req->complete = uvc_function_ep0_complete;\n\tuvc->control_req->context = uvc;\n\n\tif (v4l2_device_register(&cdev->gadget->dev, &uvc->v4l2_dev)) {\n\t\tuvcg_err(f, \"failed to register V4L2 device\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tret = uvcg_video_init(&uvc->video, uvc);\n\tif (ret < 0)\n\t\tgoto v4l2_error;\n\n\t \n\tret = uvc_register_video(uvc);\n\tif (ret < 0) {\n\t\tuvcg_err(f, \"failed to register video device\\n\");\n\t\tgoto v4l2_error;\n\t}\n\n\treturn 0;\n\nv4l2_error:\n\tv4l2_device_unregister(&uvc->v4l2_dev);\nerror:\n\tif (uvc->control_req)\n\t\tusb_ep_free_request(cdev->gadget->ep0, uvc->control_req);\n\tkfree(uvc->control_buf);\n\n\tusb_free_all_descriptors(f);\n\treturn ret;\n}\n\n \n\nstatic void uvc_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_uvc_opts *opts = fi_to_f_uvc_opts(f);\n\n\tmutex_destroy(&opts->lock);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *uvc_alloc_inst(void)\n{\n\tstruct f_uvc_opts *opts;\n\tstruct uvc_camera_terminal_descriptor *cd;\n\tstruct uvc_processing_unit_descriptor *pd;\n\tstruct uvc_output_terminal_descriptor *od;\n\tstruct uvc_descriptor_header **ctl_cls;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\topts->func_inst.free_func_inst = uvc_free_inst;\n\tmutex_init(&opts->lock);\n\n\tcd = &opts->uvc_camera_terminal;\n\tcd->bLength\t\t\t= UVC_DT_CAMERA_TERMINAL_SIZE(3);\n\tcd->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\tcd->bDescriptorSubType\t\t= UVC_VC_INPUT_TERMINAL;\n\tcd->bTerminalID\t\t\t= 1;\n\tcd->wTerminalType\t\t= cpu_to_le16(0x0201);\n\tcd->bAssocTerminal\t\t= 0;\n\tcd->iTerminal\t\t\t= 0;\n\tcd->wObjectiveFocalLengthMin\t= cpu_to_le16(0);\n\tcd->wObjectiveFocalLengthMax\t= cpu_to_le16(0);\n\tcd->wOcularFocalLength\t\t= cpu_to_le16(0);\n\tcd->bControlSize\t\t= 3;\n\tcd->bmControls[0]\t\t= 2;\n\tcd->bmControls[1]\t\t= 0;\n\tcd->bmControls[2]\t\t= 0;\n\n\tpd = &opts->uvc_processing;\n\tpd->bLength\t\t\t= UVC_DT_PROCESSING_UNIT_SIZE(2);\n\tpd->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\tpd->bDescriptorSubType\t\t= UVC_VC_PROCESSING_UNIT;\n\tpd->bUnitID\t\t\t= 2;\n\tpd->bSourceID\t\t\t= 1;\n\tpd->wMaxMultiplier\t\t= cpu_to_le16(16*1024);\n\tpd->bControlSize\t\t= 2;\n\tpd->bmControls[0]\t\t= 1;\n\tpd->bmControls[1]\t\t= 0;\n\tpd->iProcessing\t\t\t= 0;\n\tpd->bmVideoStandards\t\t= 0;\n\n\tod = &opts->uvc_output_terminal;\n\tod->bLength\t\t\t= UVC_DT_OUTPUT_TERMINAL_SIZE;\n\tod->bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\tod->bDescriptorSubType\t\t= UVC_VC_OUTPUT_TERMINAL;\n\tod->bTerminalID\t\t\t= 3;\n\tod->wTerminalType\t\t= cpu_to_le16(0x0101);\n\tod->bAssocTerminal\t\t= 0;\n\tod->bSourceID\t\t\t= 2;\n\tod->iTerminal\t\t\t= 0;\n\n\t \n\topts->last_unit_id\t\t= 3;\n\n\t \n\tctl_cls = opts->uvc_fs_control_cls;\n\tctl_cls[0] = NULL;\t \n\tctl_cls[1] = (struct uvc_descriptor_header *)cd;\n\tctl_cls[2] = (struct uvc_descriptor_header *)pd;\n\tctl_cls[3] = (struct uvc_descriptor_header *)od;\n\tctl_cls[4] = NULL;\t \n\topts->fs_control =\n\t\t(const struct uvc_descriptor_header * const *)ctl_cls;\n\n\t \n\tctl_cls = opts->uvc_ss_control_cls;\n\tctl_cls[0] = NULL;\t \n\tctl_cls[1] = (struct uvc_descriptor_header *)cd;\n\tctl_cls[2] = (struct uvc_descriptor_header *)pd;\n\tctl_cls[3] = (struct uvc_descriptor_header *)od;\n\tctl_cls[4] = NULL;\t \n\topts->ss_control =\n\t\t(const struct uvc_descriptor_header * const *)ctl_cls;\n\n\tINIT_LIST_HEAD(&opts->extension_units);\n\n\topts->streaming_interval = 1;\n\topts->streaming_maxpacket = 1024;\n\tsnprintf(opts->function_name, sizeof(opts->function_name), \"UVC Camera\");\n\n\tret = uvcg_attach_configfs(opts);\n\tif (ret < 0) {\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &opts->func_inst;\n}\n\nstatic void uvc_free(struct usb_function *f)\n{\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct f_uvc_opts *opts = container_of(f->fi, struct f_uvc_opts,\n\t\t\t\t\t       func_inst);\n\tif (!opts->header)\n\t\tconfig_item_put(&uvc->header->item);\n\t--opts->refcnt;\n\tkfree(uvc);\n}\n\nstatic void uvc_function_unbind(struct usb_configuration *c,\n\t\t\t\tstruct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct uvc_device *uvc = to_uvc(f);\n\tstruct uvc_video *video = &uvc->video;\n\tlong wait_ret = 1;\n\n\tuvcg_info(f, \"%s()\\n\", __func__);\n\n\tif (video->async_wq)\n\t\tdestroy_workqueue(video->async_wq);\n\n\t \n\tif (uvc->func_connected) {\n\t\tuvcg_dbg(f, \"waiting for clean disconnect\\n\");\n\t\twait_ret = wait_event_interruptible_timeout(uvc->func_connected_queue,\n\t\t\t\tuvc->func_connected == false, msecs_to_jiffies(500));\n\t\tuvcg_dbg(f, \"done waiting with ret: %ld\\n\", wait_ret);\n\t}\n\n\tdevice_remove_file(&uvc->vdev.dev, &dev_attr_function_name);\n\tvideo_unregister_device(&uvc->vdev);\n\tv4l2_device_unregister(&uvc->v4l2_dev);\n\n\tif (uvc->func_connected) {\n\t\t \n\t\tuvcg_warn(f, \"%s no clean disconnect, wait for release\\n\", __func__);\n\t\twait_ret = wait_event_interruptible_timeout(uvc->func_connected_queue,\n\t\t\t\tuvc->func_connected == false, msecs_to_jiffies(1000));\n\t\tuvcg_dbg(f, \"done waiting for release with ret: %ld\\n\", wait_ret);\n\t}\n\n\tusb_ep_free_request(cdev->gadget->ep0, uvc->control_req);\n\tkfree(uvc->control_buf);\n\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *uvc_alloc(struct usb_function_instance *fi)\n{\n\tstruct uvc_device *uvc;\n\tstruct f_uvc_opts *opts;\n\tstruct uvc_descriptor_header **strm_cls;\n\tstruct config_item *streaming, *header, *h;\n\n\tuvc = kzalloc(sizeof(*uvc), GFP_KERNEL);\n\tif (uvc == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&uvc->video.mutex);\n\tuvc->state = UVC_STATE_DISCONNECTED;\n\tinit_waitqueue_head(&uvc->func_connected_queue);\n\topts = fi_to_f_uvc_opts(fi);\n\n\tmutex_lock(&opts->lock);\n\tif (opts->uvc_fs_streaming_cls) {\n\t\tstrm_cls = opts->uvc_fs_streaming_cls;\n\t\topts->fs_streaming =\n\t\t\t(const struct uvc_descriptor_header * const *)strm_cls;\n\t}\n\tif (opts->uvc_hs_streaming_cls) {\n\t\tstrm_cls = opts->uvc_hs_streaming_cls;\n\t\topts->hs_streaming =\n\t\t\t(const struct uvc_descriptor_header * const *)strm_cls;\n\t}\n\tif (opts->uvc_ss_streaming_cls) {\n\t\tstrm_cls = opts->uvc_ss_streaming_cls;\n\t\topts->ss_streaming =\n\t\t\t(const struct uvc_descriptor_header * const *)strm_cls;\n\t}\n\n\tuvc->desc.fs_control = opts->fs_control;\n\tuvc->desc.ss_control = opts->ss_control;\n\tuvc->desc.fs_streaming = opts->fs_streaming;\n\tuvc->desc.hs_streaming = opts->hs_streaming;\n\tuvc->desc.ss_streaming = opts->ss_streaming;\n\n\tif (opts->header) {\n\t\tuvc->header = opts->header;\n\t} else {\n\t\tstreaming = config_group_find_item(&opts->func_inst.group, \"streaming\");\n\t\tif (!streaming)\n\t\t\tgoto err_config;\n\n\t\theader = config_group_find_item(to_config_group(streaming), \"header\");\n\t\tconfig_item_put(streaming);\n\t\tif (!header)\n\t\t\tgoto err_config;\n\n\t\th = config_group_find_item(to_config_group(header), \"h\");\n\t\tconfig_item_put(header);\n\t\tif (!h)\n\t\t\tgoto err_config;\n\n\t\tuvc->header = to_uvcg_streaming_header(h);\n\t\tif (!uvc->header->linked) {\n\t\t\tmutex_unlock(&opts->lock);\n\t\t\tkfree(uvc);\n\t\t\treturn ERR_PTR(-EBUSY);\n\t\t}\n\t}\n\n\tuvc->desc.extension_units = &opts->extension_units;\n\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\t \n\tuvc->func.name = \"uvc\";\n\tuvc->func.bind = uvc_function_bind;\n\tuvc->func.unbind = uvc_function_unbind;\n\tuvc->func.get_alt = uvc_function_get_alt;\n\tuvc->func.set_alt = uvc_function_set_alt;\n\tuvc->func.disable = uvc_function_disable;\n\tuvc->func.setup = uvc_function_setup;\n\tuvc->func.free_func = uvc_free;\n\tuvc->func.bind_deactivated = true;\n\n\treturn &uvc->func;\n\nerr_config:\n\tmutex_unlock(&opts->lock);\n\tkfree(uvc);\n\treturn ERR_PTR(-ENOENT);\n}\n\nDECLARE_USB_FUNCTION_INIT(uvc, uvc_alloc_inst, uvc_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Laurent Pinchart\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}