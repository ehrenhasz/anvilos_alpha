{
  "module_name": "uvc.h",
  "hash_id": "88b632c24a1ad495af5477c33f673ce2ebd6a075fcb0ada1bdb92303c2734bb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc.h",
  "human_readable_source": " \n \n\n#ifndef _UVC_GADGET_H_\n#define _UVC_GADGET_H_\n\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n#include <linux/usb/composite.h>\n#include <linux/videodev2.h>\n#include <linux/wait.h>\n\n#include <media/v4l2-device.h>\n#include <media/v4l2-dev.h>\n#include <media/v4l2-fh.h>\n\n#include \"uvc_queue.h\"\n\nstruct usb_ep;\nstruct usb_request;\nstruct uvc_descriptor_header;\nstruct uvc_device;\n\n \n\n#define UVC_TRACE_PROBE\t\t\t\t(1 << 0)\n#define UVC_TRACE_DESCR\t\t\t\t(1 << 1)\n#define UVC_TRACE_CONTROL\t\t\t(1 << 2)\n#define UVC_TRACE_FORMAT\t\t\t(1 << 3)\n#define UVC_TRACE_CAPTURE\t\t\t(1 << 4)\n#define UVC_TRACE_CALLS\t\t\t\t(1 << 5)\n#define UVC_TRACE_IOCTL\t\t\t\t(1 << 6)\n#define UVC_TRACE_FRAME\t\t\t\t(1 << 7)\n#define UVC_TRACE_SUSPEND\t\t\t(1 << 8)\n#define UVC_TRACE_STATUS\t\t\t(1 << 9)\n\n#define UVC_WARN_MINMAX\t\t\t\t0\n#define UVC_WARN_PROBE_DEF\t\t\t1\n\nextern unsigned int uvc_gadget_trace_param;\n\n#define uvc_trace(flag, msg...) \\\n\tdo { \\\n\t\tif (uvc_gadget_trace_param & flag) \\\n\t\t\tprintk(KERN_DEBUG \"uvcvideo: \" msg); \\\n\t} while (0)\n\n#define uvcg_dbg(f, fmt, args...) \\\n\tdev_dbg(&(f)->config->cdev->gadget->dev, \"%s: \" fmt, (f)->name, ##args)\n#define uvcg_info(f, fmt, args...) \\\n\tdev_info(&(f)->config->cdev->gadget->dev, \"%s: \" fmt, (f)->name, ##args)\n#define uvcg_warn(f, fmt, args...) \\\n\tdev_warn(&(f)->config->cdev->gadget->dev, \"%s: \" fmt, (f)->name, ##args)\n#define uvcg_err(f, fmt, args...) \\\n\tdev_err(&(f)->config->cdev->gadget->dev, \"%s: \" fmt, (f)->name, ##args)\n\n \n\n#define UVC_MAX_REQUEST_SIZE\t\t\t64\n#define UVC_MAX_EVENTS\t\t\t\t4\n\n#define UVCG_REQUEST_HEADER_LEN\t\t\t12\n\n \nstruct uvc_request {\n\tstruct usb_request *req;\n\tu8 *req_buffer;\n\tstruct uvc_video *video;\n\tstruct sg_table sgt;\n\tu8 header[UVCG_REQUEST_HEADER_LEN];\n\tstruct uvc_buffer *last_buf;\n};\n\nstruct uvc_video {\n\tstruct uvc_device *uvc;\n\tstruct usb_ep *ep;\n\n\tstruct work_struct pump;\n\tstruct workqueue_struct *async_wq;\n\n\t \n\tu8 bpp;\n\tu32 fcc;\n\tunsigned int width;\n\tunsigned int height;\n\tunsigned int imagesize;\n\tstruct mutex mutex;\t \n\n\tunsigned int uvc_num_requests;\n\n\t \n\tunsigned int req_size;\n\tstruct uvc_request *ureq;\n\tstruct list_head req_free;\n\tspinlock_t req_lock;\n\n\tunsigned int req_int_count;\n\n\tvoid (*encode) (struct usb_request *req, struct uvc_video *video,\n\t\t\tstruct uvc_buffer *buf);\n\n\t \n\t__u32 payload_size;\n\t__u32 max_payload_size;\n\n\tstruct uvc_video_queue queue;\n\tunsigned int fid;\n};\n\nenum uvc_state {\n\tUVC_STATE_DISCONNECTED,\n\tUVC_STATE_CONNECTED,\n\tUVC_STATE_STREAMING,\n};\n\nstruct uvc_device {\n\tstruct video_device vdev;\n\tstruct v4l2_device v4l2_dev;\n\tenum uvc_state state;\n\tstruct usb_function func;\n\tstruct uvc_video video;\n\tbool func_connected;\n\twait_queue_head_t func_connected_queue;\n\n\tstruct uvcg_streaming_header *header;\n\n\t \n\tstruct {\n\t\tconst struct uvc_descriptor_header * const *fs_control;\n\t\tconst struct uvc_descriptor_header * const *ss_control;\n\t\tconst struct uvc_descriptor_header * const *fs_streaming;\n\t\tconst struct uvc_descriptor_header * const *hs_streaming;\n\t\tconst struct uvc_descriptor_header * const *ss_streaming;\n\t\tstruct list_head *extension_units;\n\t} desc;\n\n\tunsigned int control_intf;\n\tstruct usb_ep *interrupt_ep;\n\tstruct usb_request *control_req;\n\tvoid *control_buf;\n\tbool enable_interrupt_ep;\n\n\tunsigned int streaming_intf;\n\n\t \n\tunsigned int event_length;\n\tunsigned int event_setup_out : 1;\n};\n\nstatic inline struct uvc_device *to_uvc(struct usb_function *f)\n{\n\treturn container_of(f, struct uvc_device, func);\n}\n\nstruct uvc_file_handle {\n\tstruct v4l2_fh vfh;\n\tstruct uvc_video *device;\n\tbool is_uvc_app_handle;\n};\n\n#define to_uvc_file_handle(handle) \\\n\tcontainer_of(handle, struct uvc_file_handle, vfh)\n\n \n\nextern void uvc_function_setup_continue(struct uvc_device *uvc);\nextern void uvc_function_connect(struct uvc_device *uvc);\nextern void uvc_function_disconnect(struct uvc_device *uvc);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}