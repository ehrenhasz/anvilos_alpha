{
  "module_name": "f_rndis.c",
  "hash_id": "6f60c77f48c6c235ed49d5eb3920313bf35ad27999f33d1c660f41085f13c926",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_rndis.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n\n#include <linux/atomic.h>\n\n#include \"u_ether.h\"\n#include \"u_ether_configfs.h\"\n#include \"u_rndis.h\"\n#include \"rndis.h\"\n#include \"configfs.h\"\n\n \n\nstruct f_rndis {\n\tstruct gether\t\t\tport;\n\tu8\t\t\t\tctrl_id, data_id;\n\tu8\t\t\t\tethaddr[ETH_ALEN];\n\tu32\t\t\t\tvendorID;\n\tconst char\t\t\t*manufacturer;\n\tstruct rndis_params\t\t*params;\n\n\tstruct usb_ep\t\t\t*notify;\n\tstruct usb_request\t\t*notify_req;\n\tatomic_t\t\t\tnotify_count;\n};\n\nstatic inline struct f_rndis *func_to_rndis(struct usb_function *f)\n{\n\treturn container_of(f, struct f_rndis, port.func);\n}\n\n \n\n \n\n#define RNDIS_STATUS_INTERVAL_MS\t32\n#define STATUS_BYTECOUNT\t\t8\t \n\n\n \n\nstatic struct usb_interface_descriptor rndis_control_intf = {\n\t.bLength =\t\tsizeof rndis_control_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t \n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =   USB_CDC_SUBCLASS_ACM,\n\t.bInterfaceProtocol =   USB_CDC_ACM_PROTO_VENDOR,\n\t \n};\n\nstatic struct usb_cdc_header_desc header_desc = {\n\t.bLength =\t\tsizeof header_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic struct usb_cdc_call_mgmt_descriptor call_mgmt_descriptor = {\n\t.bLength =\t\tsizeof call_mgmt_descriptor,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_CALL_MANAGEMENT_TYPE,\n\n\t.bmCapabilities =\t0x00,\n\t.bDataInterface =\t0x01,\n};\n\nstatic struct usb_cdc_acm_descriptor rndis_acm_descriptor = {\n\t.bLength =\t\tsizeof rndis_acm_descriptor,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_ACM_TYPE,\n\n\t.bmCapabilities =\t0x00,\n};\n\nstatic struct usb_cdc_union_desc rndis_union_desc = {\n\t.bLength =\t\tsizeof(rndis_union_desc),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_UNION_TYPE,\n\t \n\t \n};\n\n \n\nstatic struct usb_interface_descriptor rndis_data_intf = {\n\t.bLength =\t\tsizeof rndis_data_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\n\nstatic struct usb_interface_assoc_descriptor\nrndis_iad_descriptor = {\n\t.bLength =\t\tsizeof rndis_iad_descriptor,\n\t.bDescriptorType =\tUSB_DT_INTERFACE_ASSOCIATION,\n\n\t.bFirstInterface =\t0,  \n\t.bInterfaceCount = \t2,\t\n\t.bFunctionClass =\tUSB_CLASS_COMM,\n\t.bFunctionSubClass =\tUSB_CDC_SUBCLASS_ETHERNET,\n\t.bFunctionProtocol =\tUSB_CDC_PROTO_NONE,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(STATUS_BYTECOUNT),\n\t.bInterval =\t\tRNDIS_STATUS_INTERVAL_MS,\n};\n\nstatic struct usb_endpoint_descriptor fs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *eth_fs_function[] = {\n\t(struct usb_descriptor_header *) &rndis_iad_descriptor,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_control_intf,\n\t(struct usb_descriptor_header *) &header_desc,\n\t(struct usb_descriptor_header *) &call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &rndis_acm_descriptor,\n\t(struct usb_descriptor_header *) &rndis_union_desc,\n\t(struct usb_descriptor_header *) &fs_notify_desc,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_data_intf,\n\t(struct usb_descriptor_header *) &fs_in_desc,\n\t(struct usb_descriptor_header *) &fs_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(RNDIS_STATUS_INTERVAL_MS)\n};\n\nstatic struct usb_endpoint_descriptor hs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *eth_hs_function[] = {\n\t(struct usb_descriptor_header *) &rndis_iad_descriptor,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_control_intf,\n\t(struct usb_descriptor_header *) &header_desc,\n\t(struct usb_descriptor_header *) &call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &rndis_acm_descriptor,\n\t(struct usb_descriptor_header *) &rndis_union_desc,\n\t(struct usb_descriptor_header *) &hs_notify_desc,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_data_intf,\n\t(struct usb_descriptor_header *) &hs_in_desc,\n\t(struct usb_descriptor_header *) &hs_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(RNDIS_STATUS_INTERVAL_MS)\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_intr_comp_desc = {\n\t.bLength =\t\tsizeof ss_intr_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n\t.wBytesPerInterval =\tcpu_to_le16(STATUS_BYTECOUNT),\n};\n\nstatic struct usb_endpoint_descriptor ss_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor ss_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_bulk_comp_desc = {\n\t.bLength =\t\tsizeof ss_bulk_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n};\n\nstatic struct usb_descriptor_header *eth_ss_function[] = {\n\t(struct usb_descriptor_header *) &rndis_iad_descriptor,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_control_intf,\n\t(struct usb_descriptor_header *) &header_desc,\n\t(struct usb_descriptor_header *) &call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &rndis_acm_descriptor,\n\t(struct usb_descriptor_header *) &rndis_union_desc,\n\t(struct usb_descriptor_header *) &ss_notify_desc,\n\t(struct usb_descriptor_header *) &ss_intr_comp_desc,\n\n\t \n\t(struct usb_descriptor_header *) &rndis_data_intf,\n\t(struct usb_descriptor_header *) &ss_in_desc,\n\t(struct usb_descriptor_header *) &ss_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &ss_out_desc,\n\t(struct usb_descriptor_header *) &ss_bulk_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string rndis_string_defs[] = {\n\t[0].s = \"RNDIS Communications Control\",\n\t[1].s = \"RNDIS Ethernet Data\",\n\t[2].s = \"RNDIS\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings rndis_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\trndis_string_defs,\n};\n\nstatic struct usb_gadget_strings *rndis_strings[] = {\n\t&rndis_string_table,\n\tNULL,\n};\n\n \n\nstatic struct sk_buff *rndis_add_header(struct gether *port,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct sk_buff *skb2;\n\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb2 = skb_realloc_headroom(skb, sizeof(struct rndis_packet_msg_type));\n\trndis_add_hdr(skb2);\n\n\tdev_kfree_skb(skb);\n\treturn skb2;\n}\n\nstatic void rndis_response_available(void *_rndis)\n{\n\tstruct f_rndis\t\t\t*rndis = _rndis;\n\tstruct usb_request\t\t*req = rndis->notify_req;\n\tstruct usb_composite_dev\t*cdev = rndis->port.func.config->cdev;\n\t__le32\t\t\t\t*data = req->buf;\n\tint\t\t\t\tstatus;\n\n\tif (atomic_inc_return(&rndis->notify_count) != 1)\n\t\treturn;\n\n\t \n\tdata[0] = cpu_to_le32(1);\n\tdata[1] = cpu_to_le32(0);\n\n\tstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\n\tif (status) {\n\t\tatomic_dec(&rndis->notify_count);\n\t\tDBG(cdev, \"notify/0 --> %d\\n\", status);\n\t}\n}\n\nstatic void rndis_response_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_rndis\t\t\t*rndis = req->context;\n\tstruct usb_composite_dev\t*cdev = rndis->port.func.config->cdev;\n\tint\t\t\t\tstatus = req->status;\n\n\t \n\tswitch (status) {\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tatomic_set(&rndis->notify_count, 0);\n\t\tbreak;\n\tdefault:\n\t\tDBG(cdev, \"RNDIS %s response error %d, %d/%d\\n\",\n\t\t\tep->name, status,\n\t\t\treq->actual, req->length);\n\t\tfallthrough;\n\tcase 0:\n\t\tif (ep != rndis->notify)\n\t\t\tbreak;\n\n\t\t \n\t\tif (atomic_dec_and_test(&rndis->notify_count))\n\t\t\tbreak;\n\t\tstatus = usb_ep_queue(rndis->notify, req, GFP_ATOMIC);\n\t\tif (status) {\n\t\t\tatomic_dec(&rndis->notify_count);\n\t\t\tDBG(cdev, \"notify/1 --> %d\\n\", status);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void rndis_command_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_rndis\t\t\t*rndis = req->context;\n\tint\t\t\t\tstatus;\n\n\t \n \n\tstatus = rndis_msg_parser(rndis->params, (u8 *) req->buf);\n\tif (status < 0)\n\t\tpr_err(\"RNDIS command error %d, %d/%d\\n\",\n\t\t\tstatus, req->actual, req->length);\n \n}\n\nstatic int\nrndis_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\n\t \n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_SEND_ENCAPSULATED_COMMAND:\n\t\tif (w_value || w_index != rndis->ctrl_id)\n\t\t\tgoto invalid;\n\t\t \n\t\tvalue = w_length;\n\t\treq->complete = rndis_command_complete;\n\t\treq->context = rndis;\n\t\t \n\t\tbreak;\n\n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_GET_ENCAPSULATED_RESPONSE:\n\t\tif (w_value || w_index != rndis->ctrl_id)\n\t\t\tgoto invalid;\n\t\telse {\n\t\t\tu8 *buf;\n\t\t\tu32 n;\n\n\t\t\t \n\t\t\tbuf = rndis_get_next_response(rndis->params, &n);\n\t\t\tif (buf) {\n\t\t\t\tmemcpy(req->buf, buf, n);\n\t\t\t\treq->complete = rndis_response_complete;\n\t\t\t\treq->context = rndis;\n\t\t\t\trndis_free_response(rndis->params, buf);\n\t\t\t\tvalue = n;\n\t\t\t}\n\t\t\t \n\t\t}\n\t\tbreak;\n\n\tdefault:\ninvalid:\n\t\tVDBG(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tDBG(cdev, \"rndis req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = (value < w_length);\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"rndis response on err %d\\n\", value);\n\t}\n\n\t \n\treturn value;\n}\n\n\nstatic int rndis_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\n\tif (intf == rndis->ctrl_id) {\n\t\tVDBG(cdev, \"reset rndis control %d\\n\", intf);\n\t\tusb_ep_disable(rndis->notify);\n\n\t\tif (!rndis->notify->desc) {\n\t\t\tVDBG(cdev, \"init rndis ctrl %d\\n\", intf);\n\t\t\tif (config_ep_by_speed(cdev->gadget, f, rndis->notify))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tusb_ep_enable(rndis->notify);\n\n\t} else if (intf == rndis->data_id) {\n\t\tstruct net_device\t*net;\n\n\t\tif (rndis->port.in_ep->enabled) {\n\t\t\tDBG(cdev, \"reset rndis\\n\");\n\t\t\tgether_disconnect(&rndis->port);\n\t\t}\n\n\t\tif (!rndis->port.in_ep->desc || !rndis->port.out_ep->desc) {\n\t\t\tDBG(cdev, \"init rndis\\n\");\n\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       rndis->port.in_ep) ||\n\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       rndis->port.out_ep)) {\n\t\t\t\trndis->port.in_ep->desc = NULL;\n\t\t\t\trndis->port.out_ep->desc = NULL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\trndis->port.is_zlp_ok = false;\n\n\t\t \n\t\trndis->port.cdc_filter = 0;\n\n\t\tDBG(cdev, \"RNDIS RX/TX early activation ... \\n\");\n\t\tnet = gether_connect(&rndis->port);\n\t\tif (IS_ERR(net))\n\t\t\treturn PTR_ERR(net);\n\n\t\trndis_set_param_dev(rndis->params, net,\n\t\t\t\t&rndis->port.cdc_filter);\n\t} else\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\n\nstatic void rndis_disable(struct usb_function *f)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tif (!rndis->notify->enabled)\n\t\treturn;\n\n\tDBG(cdev, \"rndis deactivated\\n\");\n\n\trndis_uninit(rndis->params);\n\tgether_disconnect(&rndis->port);\n\n\tusb_ep_disable(rndis->notify);\n\trndis->notify->desc = NULL;\n}\n\n \n\n \n\nstatic void rndis_open(struct gether *geth)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(&geth->func);\n\tstruct usb_composite_dev *cdev = geth->func.config->cdev;\n\n\tDBG(cdev, \"%s\\n\", __func__);\n\n\trndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3,\n\t\t\t\tgether_bitrate(cdev->gadget) / 100);\n\trndis_signal_connect(rndis->params);\n}\n\nstatic void rndis_close(struct gether *geth)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(&geth->func);\n\n\tDBG(geth->func.config->cdev, \"%s\\n\", __func__);\n\n\trndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3, 0);\n\trndis_signal_disconnect(rndis->params);\n}\n\n \n\n \nstatic inline bool can_support_rndis(struct usb_configuration *c)\n{\n\t \n\treturn true;\n}\n\n \n\nstatic int\nrndis_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_rndis\t\t*rndis = func_to_rndis(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\tstruct f_rndis_opts *rndis_opts;\n\n\tif (!can_support_rndis(c))\n\t\treturn -EINVAL;\n\n\trndis_opts = container_of(f->fi, struct f_rndis_opts, func_inst);\n\n\tif (cdev->use_os_string) {\n\t\tf->os_desc_table = kzalloc(sizeof(*f->os_desc_table),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!f->os_desc_table)\n\t\t\treturn -ENOMEM;\n\t\tf->os_desc_n = 1;\n\t\tf->os_desc_table[0].os_desc = &rndis_opts->rndis_os_desc;\n\t}\n\n\trndis_iad_descriptor.bFunctionClass = rndis_opts->class;\n\trndis_iad_descriptor.bFunctionSubClass = rndis_opts->subclass;\n\trndis_iad_descriptor.bFunctionProtocol = rndis_opts->protocol;\n\n\t \n\tif (!rndis_opts->bound) {\n\t\tgether_set_gadget(rndis_opts->net, cdev->gadget);\n\t\tstatus = gether_register_netdev(rndis_opts->net);\n\t\tif (status)\n\t\t\tgoto fail;\n\t\trndis_opts->bound = true;\n\t}\n\n\tus = usb_gstrings_attach(cdev, rndis_strings,\n\t\t\t\t ARRAY_SIZE(rndis_string_defs));\n\tif (IS_ERR(us)) {\n\t\tstatus = PTR_ERR(us);\n\t\tgoto fail;\n\t}\n\trndis_control_intf.iInterface = us[0].id;\n\trndis_data_intf.iInterface = us[1].id;\n\trndis_iad_descriptor.iFunction = us[2].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\trndis->ctrl_id = status;\n\trndis_iad_descriptor.bFirstInterface = status;\n\n\trndis_control_intf.bInterfaceNumber = status;\n\trndis_union_desc.bMasterInterface0 = status;\n\n\tif (cdev->use_os_string)\n\t\tf->os_desc_table[0].if_id =\n\t\t\trndis_iad_descriptor.bFirstInterface;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\trndis->data_id = status;\n\n\trndis_data_intf.bInterfaceNumber = status;\n\trndis_union_desc.bSlaveInterface0 = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\trndis->port.in_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &fs_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\trndis->port.out_ep = ep;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_notify_desc);\n\tif (!ep)\n\t\tgoto fail;\n\trndis->notify = ep;\n\n\tstatus = -ENOMEM;\n\n\t \n\trndis->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\n\tif (!rndis->notify_req)\n\t\tgoto fail;\n\trndis->notify_req->buf = kmalloc(STATUS_BYTECOUNT, GFP_KERNEL);\n\tif (!rndis->notify_req->buf)\n\t\tgoto fail;\n\trndis->notify_req->length = STATUS_BYTECOUNT;\n\trndis->notify_req->context = rndis;\n\trndis->notify_req->complete = rndis_response_complete;\n\n\t \n\ths_in_desc.bEndpointAddress = fs_in_desc.bEndpointAddress;\n\ths_out_desc.bEndpointAddress = fs_out_desc.bEndpointAddress;\n\ths_notify_desc.bEndpointAddress = fs_notify_desc.bEndpointAddress;\n\n\tss_in_desc.bEndpointAddress = fs_in_desc.bEndpointAddress;\n\tss_out_desc.bEndpointAddress = fs_out_desc.bEndpointAddress;\n\tss_notify_desc.bEndpointAddress = fs_notify_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, eth_fs_function, eth_hs_function,\n\t\t\teth_ss_function, eth_ss_function);\n\tif (status)\n\t\tgoto fail;\n\n\trndis->port.open = rndis_open;\n\trndis->port.close = rndis_close;\n\n\trndis_set_param_medium(rndis->params, RNDIS_MEDIUM_802_3, 0);\n\trndis_set_host_mac(rndis->params, rndis->ethaddr);\n\n\tif (rndis->manufacturer && rndis->vendorID &&\n\t\t\trndis_set_param_vendor(rndis->params, rndis->vendorID,\n\t\t\t\t\t       rndis->manufacturer)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_free_descs;\n\t}\n\n\t \n\n\tDBG(cdev, \"RNDIS: IN/%s OUT/%s NOTIFY/%s\\n\",\n\t\t\trndis->port.in_ep->name, rndis->port.out_ep->name,\n\t\t\trndis->notify->name);\n\treturn 0;\n\nfail_free_descs:\n\tusb_free_all_descriptors(f);\nfail:\n\tkfree(f->os_desc_table);\n\tf->os_desc_n = 0;\n\n\tif (rndis->notify_req) {\n\t\tkfree(rndis->notify_req->buf);\n\t\tusb_ep_free_request(rndis->notify, rndis->notify_req);\n\t}\n\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nvoid rndis_borrow_net(struct usb_function_instance *f, struct net_device *net)\n{\n\tstruct f_rndis_opts *opts;\n\n\topts = container_of(f, struct f_rndis_opts, func_inst);\n\tif (opts->bound)\n\t\tgether_cleanup(netdev_priv(opts->net));\n\telse\n\t\tfree_netdev(opts->net);\n\topts->borrowed_net = opts->bound = true;\n\topts->net = net;\n}\nEXPORT_SYMBOL_GPL(rndis_borrow_net);\n\nstatic inline struct f_rndis_opts *to_f_rndis_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_rndis_opts,\n\t\t\t    func_inst.group);\n}\n\n \nUSB_ETHERNET_CONFIGFS_ITEM(rndis);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(rndis);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(rndis);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(rndis);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(rndis);\n\n \nUSB_ETHER_CONFIGFS_ITEM_ATTR_U8_RW(rndis, class);\n\n \nUSB_ETHER_CONFIGFS_ITEM_ATTR_U8_RW(rndis, subclass);\n\n \nUSB_ETHER_CONFIGFS_ITEM_ATTR_U8_RW(rndis, protocol);\n\nstatic struct configfs_attribute *rndis_attrs[] = {\n\t&rndis_opts_attr_dev_addr,\n\t&rndis_opts_attr_host_addr,\n\t&rndis_opts_attr_qmult,\n\t&rndis_opts_attr_ifname,\n\t&rndis_opts_attr_class,\n\t&rndis_opts_attr_subclass,\n\t&rndis_opts_attr_protocol,\n\tNULL,\n};\n\nstatic const struct config_item_type rndis_func_type = {\n\t.ct_item_ops\t= &rndis_item_ops,\n\t.ct_attrs\t= rndis_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void rndis_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_rndis_opts *opts;\n\n\topts = container_of(f, struct f_rndis_opts, func_inst);\n\tif (!opts->borrowed_net) {\n\t\tif (opts->bound)\n\t\t\tgether_cleanup(netdev_priv(opts->net));\n\t\telse\n\t\t\tfree_netdev(opts->net);\n\t}\n\n\tkfree(opts->rndis_interf_group);\t \n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *rndis_alloc_inst(void)\n{\n\tstruct f_rndis_opts *opts;\n\tstruct usb_os_desc *descs[1];\n\tchar *names[1];\n\tstruct config_group *rndis_interf_group;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\topts->rndis_os_desc.ext_compat_id = opts->rndis_ext_compat_id;\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = rndis_free_inst;\n\topts->net = gether_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\tINIT_LIST_HEAD(&opts->rndis_os_desc.ext_prop);\n\n\topts->class = rndis_iad_descriptor.bFunctionClass;\n\topts->subclass = rndis_iad_descriptor.bFunctionSubClass;\n\topts->protocol = rndis_iad_descriptor.bFunctionProtocol;\n\n\tdescs[0] = &opts->rndis_os_desc;\n\tnames[0] = \"rndis\";\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &rndis_func_type);\n\trndis_interf_group =\n\t\tusb_os_desc_prepare_interf_dir(&opts->func_inst.group, 1, descs,\n\t\t\t\t\t       names, THIS_MODULE);\n\tif (IS_ERR(rndis_interf_group)) {\n\t\trndis_free_inst(&opts->func_inst);\n\t\treturn ERR_CAST(rndis_interf_group);\n\t}\n\topts->rndis_interf_group = rndis_interf_group;\n\n\treturn &opts->func_inst;\n}\n\nstatic void rndis_free(struct usb_function *f)\n{\n\tstruct f_rndis *rndis;\n\tstruct f_rndis_opts *opts;\n\n\trndis = func_to_rndis(f);\n\trndis_deregister(rndis->params);\n\topts = container_of(f->fi, struct f_rndis_opts, func_inst);\n\tkfree(rndis);\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void rndis_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_rndis\t\t*rndis = func_to_rndis(f);\n\n\tkfree(f->os_desc_table);\n\tf->os_desc_n = 0;\n\tusb_free_all_descriptors(f);\n\n\tkfree(rndis->notify_req->buf);\n\tusb_ep_free_request(rndis->notify, rndis->notify_req);\n}\n\nstatic struct usb_function *rndis_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_rndis\t*rndis;\n\tstruct f_rndis_opts *opts;\n\tstruct rndis_params *params;\n\n\t \n\trndis = kzalloc(sizeof(*rndis), GFP_KERNEL);\n\tif (!rndis)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_rndis_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\n\tgether_get_host_addr_u8(opts->net, rndis->ethaddr);\n\trndis->vendorID = opts->vendor_id;\n\trndis->manufacturer = opts->manufacturer;\n\n\trndis->port.ioport = netdev_priv(opts->net);\n\tmutex_unlock(&opts->lock);\n\t \n\trndis->port.cdc_filter = 0;\n\n\t \n\trndis->port.header_len = sizeof(struct rndis_packet_msg_type);\n\trndis->port.wrap = rndis_add_header;\n\trndis->port.unwrap = rndis_rm_hdr;\n\n\trndis->port.func.name = \"rndis\";\n\t \n\trndis->port.func.bind = rndis_bind;\n\trndis->port.func.unbind = rndis_unbind;\n\trndis->port.func.set_alt = rndis_set_alt;\n\trndis->port.func.setup = rndis_setup;\n\trndis->port.func.disable = rndis_disable;\n\trndis->port.func.free_func = rndis_free;\n\n\tparams = rndis_register(rndis_response_available, rndis);\n\tif (IS_ERR(params)) {\n\t\tkfree(rndis);\n\t\treturn ERR_CAST(params);\n\t}\n\trndis->params = params;\n\n\treturn &rndis->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(rndis, rndis_alloc_inst, rndis_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}