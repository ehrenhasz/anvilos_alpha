{
  "module_name": "f_subset.c",
  "hash_id": "b23f7134ecedae2c6c4bf31017e7f223cc9ddbcac7cb0766551d38b5b5063df5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_subset.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n\n#include \"u_ether.h\"\n#include \"u_ether_configfs.h\"\n#include \"u_gether.h\"\n\n \n\nstruct f_gether {\n\tstruct gether\t\t\tport;\n\n\tchar\t\t\t\tethaddr[14];\n};\n\nstatic inline struct f_gether *func_to_geth(struct usb_function *f)\n{\n\treturn container_of(f, struct f_gether, port.func);\n}\n\n \n\n \n\n \n\nstatic struct usb_interface_descriptor subset_data_intf = {\n\t.bLength =\t\tsizeof subset_data_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =      USB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_MDLM,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\nstatic struct usb_cdc_header_desc mdlm_header_desc = {\n\t.bLength =\t\tsizeof mdlm_header_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic struct usb_cdc_mdlm_desc mdlm_desc = {\n\t.bLength =\t\tsizeof mdlm_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_MDLM_TYPE,\n\n\t.bcdVersion =\t\tcpu_to_le16(0x0100),\n\t.bGUID = {\n\t\t0x5d, 0x34, 0xcf, 0x66, 0x11, 0x18, 0x11, 0xd6,\n\t\t0xa2, 0x1a, 0x00, 0x01, 0x02, 0xca, 0x9a, 0x7f,\n\t},\n};\n\n \nstatic u8 mdlm_detail_desc[] = {\n\t6,\n\tUSB_DT_CS_INTERFACE,\n\tUSB_CDC_MDLM_DETAIL_TYPE,\n\n\t0,\t \n\t0,\t \n\t0,\t \n};\n\nstatic struct usb_cdc_ether_desc ether_desc = {\n\t.bLength =\t\tsizeof ether_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_ETHERNET_TYPE,\n\n\t \n\t \n\t.bmEthernetStatistics =\tcpu_to_le32(0),  \n\t.wMaxSegmentSize =\tcpu_to_le16(ETH_FRAME_LEN),\n\t.wNumberMCFilters =\tcpu_to_le16(0),\n\t.bNumberPowerFilters =\t0,\n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_subset_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_subset_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *fs_eth_function[] = {\n\t(struct usb_descriptor_header *) &subset_data_intf,\n\t(struct usb_descriptor_header *) &mdlm_header_desc,\n\t(struct usb_descriptor_header *) &mdlm_desc,\n\t(struct usb_descriptor_header *) &mdlm_detail_desc,\n\t(struct usb_descriptor_header *) &ether_desc,\n\t(struct usb_descriptor_header *) &fs_subset_in_desc,\n\t(struct usb_descriptor_header *) &fs_subset_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_subset_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_subset_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *hs_eth_function[] = {\n\t(struct usb_descriptor_header *) &subset_data_intf,\n\t(struct usb_descriptor_header *) &mdlm_header_desc,\n\t(struct usb_descriptor_header *) &mdlm_desc,\n\t(struct usb_descriptor_header *) &mdlm_detail_desc,\n\t(struct usb_descriptor_header *) &ether_desc,\n\t(struct usb_descriptor_header *) &hs_subset_in_desc,\n\t(struct usb_descriptor_header *) &hs_subset_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_subset_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor ss_subset_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_subset_bulk_comp_desc = {\n\t.bLength =\t\tsizeof ss_subset_bulk_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n};\n\nstatic struct usb_descriptor_header *ss_eth_function[] = {\n\t(struct usb_descriptor_header *) &subset_data_intf,\n\t(struct usb_descriptor_header *) &mdlm_header_desc,\n\t(struct usb_descriptor_header *) &mdlm_desc,\n\t(struct usb_descriptor_header *) &mdlm_detail_desc,\n\t(struct usb_descriptor_header *) &ether_desc,\n\t(struct usb_descriptor_header *) &ss_subset_in_desc,\n\t(struct usb_descriptor_header *) &ss_subset_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &ss_subset_out_desc,\n\t(struct usb_descriptor_header *) &ss_subset_bulk_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string geth_string_defs[] = {\n\t[0].s = \"CDC Ethernet Subset/SAFE\",\n\t[1].s = \"\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings geth_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\tgeth_string_defs,\n};\n\nstatic struct usb_gadget_strings *geth_strings[] = {\n\t&geth_string_table,\n\tNULL,\n};\n\n \n\nstatic int geth_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_gether\t\t*geth = func_to_geth(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct net_device\t*net;\n\n\t \n\n\tif (geth->port.in_ep->enabled) {\n\t\tDBG(cdev, \"reset cdc subset\\n\");\n\t\tgether_disconnect(&geth->port);\n\t}\n\n\tDBG(cdev, \"init + activate cdc subset\\n\");\n\tif (config_ep_by_speed(cdev->gadget, f, geth->port.in_ep) ||\n\t    config_ep_by_speed(cdev->gadget, f, geth->port.out_ep)) {\n\t\tgeth->port.in_ep->desc = NULL;\n\t\tgeth->port.out_ep->desc = NULL;\n\t\treturn -EINVAL;\n\t}\n\n\tnet = gether_connect(&geth->port);\n\treturn PTR_ERR_OR_ZERO(net);\n}\n\nstatic void geth_disable(struct usb_function *f)\n{\n\tstruct f_gether\t*geth = func_to_geth(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tDBG(cdev, \"net deactivated\\n\");\n\tgether_disconnect(&geth->port);\n}\n\n \n\n \n\nstatic int\ngeth_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_gether\t\t*geth = func_to_geth(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\tstruct f_gether_opts\t*gether_opts;\n\n\tgether_opts = container_of(f->fi, struct f_gether_opts, func_inst);\n\n\t \n\tif (!gether_opts->bound) {\n\t\tmutex_lock(&gether_opts->lock);\n\t\tgether_set_gadget(gether_opts->net, cdev->gadget);\n\t\tstatus = gether_register_netdev(gether_opts->net);\n\t\tmutex_unlock(&gether_opts->lock);\n\t\tif (status)\n\t\t\treturn status;\n\t\tgether_opts->bound = true;\n\t}\n\n\tus = usb_gstrings_attach(cdev, geth_strings,\n\t\t\t\t ARRAY_SIZE(geth_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\n\tsubset_data_intf.iInterface = us[0].id;\n\tether_desc.iMACAddress = us[1].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tsubset_data_intf.bInterfaceNumber = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_subset_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tgeth->port.in_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &fs_subset_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tgeth->port.out_ep = ep;\n\n\t \n\ths_subset_in_desc.bEndpointAddress = fs_subset_in_desc.bEndpointAddress;\n\ths_subset_out_desc.bEndpointAddress =\n\t\tfs_subset_out_desc.bEndpointAddress;\n\n\tss_subset_in_desc.bEndpointAddress = fs_subset_in_desc.bEndpointAddress;\n\tss_subset_out_desc.bEndpointAddress =\n\t\tfs_subset_out_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, fs_eth_function, hs_eth_function,\n\t\t\tss_eth_function, ss_eth_function);\n\tif (status)\n\t\tgoto fail;\n\n\t \n\n\tDBG(cdev, \"CDC Subset: IN/%s OUT/%s\\n\",\n\t\t\tgeth->port.in_ep->name, geth->port.out_ep->name);\n\treturn 0;\n\nfail:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_gether_opts *to_f_gether_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_gether_opts,\n\t\t\t    func_inst.group);\n}\n\n \nUSB_ETHERNET_CONFIGFS_ITEM(gether);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(gether);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(gether);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(gether);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(gether);\n\nstatic struct configfs_attribute *gether_attrs[] = {\n\t&gether_opts_attr_dev_addr,\n\t&gether_opts_attr_host_addr,\n\t&gether_opts_attr_qmult,\n\t&gether_opts_attr_ifname,\n\tNULL,\n};\n\nstatic const struct config_item_type gether_func_type = {\n\t.ct_item_ops\t= &gether_item_ops,\n\t.ct_attrs\t= gether_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void geth_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_gether_opts *opts;\n\n\topts = container_of(f, struct f_gether_opts, func_inst);\n\tif (opts->bound)\n\t\tgether_cleanup(netdev_priv(opts->net));\n\telse\n\t\tfree_netdev(opts->net);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *geth_alloc_inst(void)\n{\n\tstruct f_gether_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = geth_free_inst;\n\topts->net = gether_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &gether_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void geth_free(struct usb_function *f)\n{\n\tstruct f_gether *eth;\n\n\teth = func_to_geth(f);\n\tkfree(eth);\n}\n\nstatic void geth_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tgeth_string_defs[0].id = 0;\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *geth_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_gether\t*geth;\n\tstruct f_gether_opts *opts;\n\tint status;\n\n\t \n\tgeth = kzalloc(sizeof(*geth), GFP_KERNEL);\n\tif (!geth)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_gether_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\t \n\tstatus = gether_get_host_addr_cdc(opts->net, geth->ethaddr,\n\t\t\t\t\t  sizeof(geth->ethaddr));\n\tif (status < 12) {\n\t\tkfree(geth);\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tgeth_string_defs[1].s = geth->ethaddr;\n\n\tgeth->port.ioport = netdev_priv(opts->net);\n\tmutex_unlock(&opts->lock);\n\tgeth->port.cdc_filter = DEFAULT_FILTER;\n\n\tgeth->port.func.name = \"cdc_subset\";\n\tgeth->port.func.bind = geth_bind;\n\tgeth->port.func.unbind = geth_unbind;\n\tgeth->port.func.set_alt = geth_set_alt;\n\tgeth->port.func.disable = geth_disable;\n\tgeth->port.func.free_func = geth_free;\n\n\treturn &geth->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(geth, geth_alloc_inst, geth_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}