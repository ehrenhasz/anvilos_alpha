{
  "module_name": "f_uac1.c",
  "hash_id": "4dfdc973d80df5206b5977a39f1786573f0306a391f1e200c83ed6f3f554916d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_uac1.c",
  "human_readable_source": "\n \n\n#include <linux/usb/audio.h>\n#include <linux/module.h>\n\n#include \"u_audio.h\"\n#include \"u_uac1.h\"\n\n \n#define UAC1_CHANNEL_MASK 0x0FFF\n\n#define USB_OUT_FU_ID\t(out_feature_unit_desc->bUnitID)\n#define USB_IN_FU_ID\t(in_feature_unit_desc->bUnitID)\n\n#define EPIN_EN(_opts) ((_opts)->p_chmask != 0)\n#define EPOUT_EN(_opts) ((_opts)->c_chmask != 0)\n#define FUIN_EN(_opts) ((_opts)->p_mute_present \\\n\t\t\t|| (_opts)->p_volume_present)\n#define FUOUT_EN(_opts) ((_opts)->c_mute_present \\\n\t\t\t|| (_opts)->c_volume_present)\n\nstruct f_uac1 {\n\tstruct g_audio g_audio;\n\tu8 ac_intf, as_in_intf, as_out_intf;\n\tu8 ac_alt, as_in_alt, as_out_alt;\t \n\n\tstruct usb_ctrlrequest setup_cr;\t \n\n\t \n\tstruct usb_ep\t*int_ep;\n\tatomic_t\tint_count;\n\tint ctl_id;\t\t \n\tint c_srate;\t \n\tint p_srate;\t \n};\n\nstatic inline struct f_uac1 *func_to_uac1(struct usb_function *f)\n{\n\treturn container_of(f, struct f_uac1, g_audio.func);\n}\n\nstatic inline struct f_uac1_opts *g_audio_to_uac1_opts(struct g_audio *audio)\n{\n\treturn container_of(audio->func.fi, struct f_uac1_opts, func_inst);\n}\n\n \n\n \n\n \nstatic struct usb_interface_descriptor ac_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n};\n\n \nstatic struct uac1_ac_header_descriptor *ac_header_desc;\n\nstatic struct uac_input_terminal_descriptor usb_out_it_desc = {\n\t.bLength =\t\tUAC_DT_INPUT_TERMINAL_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_INPUT_TERMINAL,\n\t \n\t.wTerminalType =\tcpu_to_le16(UAC_TERMINAL_STREAMING),\n\t.bAssocTerminal =\t0,\n\t.wChannelConfig =\tcpu_to_le16(0x3),\n};\n\nstatic struct uac1_output_terminal_descriptor io_out_ot_desc = {\n\t.bLength\t\t= UAC_DT_OUTPUT_TERMINAL_SIZE,\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype\t= UAC_OUTPUT_TERMINAL,\n\t \n\t.wTerminalType\t\t= cpu_to_le16(UAC_OUTPUT_TERMINAL_SPEAKER),\n\t.bAssocTerminal\t\t= 0,\n\t \n};\n\nstatic struct uac_input_terminal_descriptor io_in_it_desc = {\n\t.bLength\t\t= UAC_DT_INPUT_TERMINAL_SIZE,\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype\t= UAC_INPUT_TERMINAL,\n\t \n\t.wTerminalType\t\t= cpu_to_le16(UAC_INPUT_TERMINAL_MICROPHONE),\n\t.bAssocTerminal\t\t= 0,\n\t.wChannelConfig\t\t= cpu_to_le16(0x3),\n};\n\nstatic struct uac1_output_terminal_descriptor usb_in_ot_desc = {\n\t.bLength =\t\tUAC_DT_OUTPUT_TERMINAL_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_OUTPUT_TERMINAL,\n\t \n\t.wTerminalType =\tcpu_to_le16(UAC_TERMINAL_STREAMING),\n\t.bAssocTerminal =\t0,\n\t \n};\n\nstatic struct uac_feature_unit_descriptor *in_feature_unit_desc;\nstatic struct uac_feature_unit_descriptor *out_feature_unit_desc;\n\n \nstatic struct usb_endpoint_descriptor ac_int_ep_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes = USB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize = cpu_to_le16(2),\n\t.bInterval = 4,\n};\n\n \nstatic struct usb_interface_descriptor as_out_interface_alt_0_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\nstatic struct usb_interface_descriptor as_out_interface_alt_1_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\nstatic struct usb_interface_descriptor as_in_interface_alt_0_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\nstatic struct usb_interface_descriptor as_in_interface_alt_1_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\n \nstatic struct uac1_as_header_descriptor as_out_header_desc = {\n\t.bLength =\t\tUAC_DT_AS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_AS_GENERAL,\n\t \n\t.bDelay =\t\t1,\n\t.wFormatTag =\t\tcpu_to_le16(UAC_FORMAT_TYPE_I_PCM),\n};\n\nstatic struct uac1_as_header_descriptor as_in_header_desc = {\n\t.bLength =\t\tUAC_DT_AS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_AS_GENERAL,\n\t \n\t.bDelay =\t\t1,\n\t.wFormatTag =\t\tcpu_to_le16(UAC_FORMAT_TYPE_I_PCM),\n};\n\nDECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(UAC_MAX_RATES);\n#define uac_format_type_i_discrete_descriptor\t\t\t\\\n\tuac_format_type_i_discrete_descriptor_##UAC_MAX_RATES\n\nstatic struct uac_format_type_i_discrete_descriptor as_out_type_i_desc = {\n\t.bLength =\t\t0,  \n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_FORMAT_TYPE,\n\t.bFormatType =\t\tUAC_FORMAT_TYPE_I,\n\t.bSubframeSize =\t2,\n\t.bBitResolution =\t16,\n\t.bSamFreqType =\t\t0,  \n};\n\n \nstatic struct usb_endpoint_descriptor as_out_ep_desc  = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_SYNC_ADAPTIVE\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize\t=\tcpu_to_le16(UAC1_OUT_EP_MAX_PACKET_SIZE),\n\t.bInterval =\t\t4,\n};\n\n \nstatic struct uac_iso_endpoint_descriptor as_iso_out_desc = {\n\t.bLength =\t\tUAC_ISO_ENDPOINT_DESC_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUAC_EP_GENERAL,\n\t.bmAttributes =\t\t1,\n\t.bLockDelayUnits =\t1,\n\t.wLockDelay =\t\tcpu_to_le16(1),\n};\n\nstatic struct uac_format_type_i_discrete_descriptor as_in_type_i_desc = {\n\t.bLength =\t\t0,  \n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_FORMAT_TYPE,\n\t.bFormatType =\t\tUAC_FORMAT_TYPE_I,\n\t.bSubframeSize =\t2,\n\t.bBitResolution =\t16,\n\t.bSamFreqType =\t\t0,  \n};\n\n \nstatic struct usb_endpoint_descriptor as_in_ep_desc  = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_SYNC_ASYNC\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize\t=\tcpu_to_le16(UAC1_OUT_EP_MAX_PACKET_SIZE),\n\t.bInterval =\t\t4,\n};\n\n \nstatic struct uac_iso_endpoint_descriptor as_iso_in_desc = {\n\t.bLength =\t\tUAC_ISO_ENDPOINT_DESC_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUAC_EP_GENERAL,\n\t.bmAttributes =\t\t1,\n\t.bLockDelayUnits =\t0,\n\t.wLockDelay =\t\t0,\n};\n\nstatic struct usb_descriptor_header *f_audio_desc[] = {\n\t(struct usb_descriptor_header *)&ac_interface_desc,\n\t(struct usb_descriptor_header *)&ac_header_desc,\n\n\t(struct usb_descriptor_header *)&usb_out_it_desc,\n\t(struct usb_descriptor_header *)&io_out_ot_desc,\n\t(struct usb_descriptor_header *)&out_feature_unit_desc,\n\n\t(struct usb_descriptor_header *)&io_in_it_desc,\n\t(struct usb_descriptor_header *)&usb_in_ot_desc,\n\t(struct usb_descriptor_header *)&in_feature_unit_desc,\n\n\t(struct usb_descriptor_header *)&ac_int_ep_desc,\n\n\t(struct usb_descriptor_header *)&as_out_interface_alt_0_desc,\n\t(struct usb_descriptor_header *)&as_out_interface_alt_1_desc,\n\t(struct usb_descriptor_header *)&as_out_header_desc,\n\n\t(struct usb_descriptor_header *)&as_out_type_i_desc,\n\n\t(struct usb_descriptor_header *)&as_out_ep_desc,\n\t(struct usb_descriptor_header *)&as_iso_out_desc,\n\n\t(struct usb_descriptor_header *)&as_in_interface_alt_0_desc,\n\t(struct usb_descriptor_header *)&as_in_interface_alt_1_desc,\n\t(struct usb_descriptor_header *)&as_in_header_desc,\n\n\t(struct usb_descriptor_header *)&as_in_type_i_desc,\n\n\t(struct usb_descriptor_header *)&as_in_ep_desc,\n\t(struct usb_descriptor_header *)&as_iso_in_desc,\n\tNULL,\n};\n\nenum {\n\tSTR_AC_IF,\n\tSTR_USB_OUT_IT,\n\tSTR_USB_OUT_IT_CH_NAMES,\n\tSTR_IO_OUT_OT,\n\tSTR_IO_IN_IT,\n\tSTR_IO_IN_IT_CH_NAMES,\n\tSTR_USB_IN_OT,\n\tSTR_FU_IN,\n\tSTR_FU_OUT,\n\tSTR_AS_OUT_IF_ALT0,\n\tSTR_AS_OUT_IF_ALT1,\n\tSTR_AS_IN_IF_ALT0,\n\tSTR_AS_IN_IF_ALT1,\n};\n\nstatic struct usb_string strings_uac1[] = {\n\t \n\t[STR_USB_OUT_IT].s = \"Playback Input terminal\",\n\t[STR_USB_OUT_IT_CH_NAMES].s = \"Playback Channels\",\n\t[STR_IO_OUT_OT].s = \"Playback Output terminal\",\n\t[STR_IO_IN_IT].s = \"Capture Input terminal\",\n\t[STR_IO_IN_IT_CH_NAMES].s = \"Capture Channels\",\n\t[STR_USB_IN_OT].s = \"Capture Output terminal\",\n\t[STR_FU_IN].s = \"Capture Volume\",\n\t[STR_FU_OUT].s = \"Playback Volume\",\n\t[STR_AS_OUT_IF_ALT0].s = \"Playback Inactive\",\n\t[STR_AS_OUT_IF_ALT1].s = \"Playback Active\",\n\t[STR_AS_IN_IF_ALT0].s = \"Capture Inactive\",\n\t[STR_AS_IN_IF_ALT1].s = \"Capture Active\",\n\t{ },\n};\n\nstatic struct usb_gadget_strings str_uac1 = {\n\t.language = 0x0409,\t \n\t.strings = strings_uac1,\n};\n\nstatic struct usb_gadget_strings *uac1_strings[] = {\n\t&str_uac1,\n\tNULL,\n};\n\n \n\nstatic void uac_cs_attr_sample_rate(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_function *fn = ep->driver_data;\n\tstruct usb_composite_dev *cdev = fn->config->cdev;\n\tstruct g_audio *agdev = func_to_g_audio(fn);\n\tstruct f_uac1 *uac1 = func_to_uac1(fn);\n\tu8 *buf = (u8 *)req->buf;\n\tu32 val = 0;\n\n\tif (req->actual != 3) {\n\t\tWARN(cdev, \"Invalid data size for UAC_EP_CS_ATTR_SAMPLE_RATE.\\n\");\n\t\treturn;\n\t}\n\n\tval = buf[0] | (buf[1] << 8) | (buf[2] << 16);\n\tif (uac1->ctl_id == (USB_DIR_IN | 2)) {\n\t\tuac1->p_srate = val;\n\t\tu_audio_set_playback_srate(agdev, uac1->p_srate);\n\t} else if (uac1->ctl_id == (USB_DIR_OUT | 1)) {\n\t\tuac1->c_srate = val;\n\t\tu_audio_set_capture_srate(agdev, uac1->c_srate);\n\t}\n}\n\nstatic void audio_notify_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tstruct g_audio *audio = req->context;\n\tstruct f_uac1 *uac1 = func_to_uac1(&audio->func);\n\n\tatomic_dec(&uac1->int_count);\n\tkfree(req->buf);\n\tusb_ep_free_request(_ep, req);\n}\n\nstatic int audio_notify(struct g_audio *audio, int unit_id, int cs)\n{\n\tstruct f_uac1 *uac1 = func_to_uac1(&audio->func);\n\tstruct usb_request *req;\n\tstruct uac1_status_word *msg;\n\tint ret;\n\n\tif (!uac1->int_ep->enabled)\n\t\treturn 0;\n\n\tif (atomic_inc_return(&uac1->int_count) > UAC1_DEF_INT_REQ_NUM) {\n\t\tatomic_dec(&uac1->int_count);\n\t\treturn 0;\n\t}\n\n\treq = usb_ep_alloc_request(uac1->int_ep, GFP_ATOMIC);\n\tif (req == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_dec_int_count;\n\t}\n\n\tmsg = kmalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (msg == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_request;\n\t}\n\n\tmsg->bStatusType = UAC1_STATUS_TYPE_IRQ_PENDING\n\t\t\t\t| UAC1_STATUS_TYPE_ORIG_AUDIO_CONTROL_IF;\n\tmsg->bOriginator = unit_id;\n\n\treq->length = sizeof(*msg);\n\treq->buf = msg;\n\treq->context = audio;\n\treq->complete = audio_notify_complete;\n\n\tret = usb_ep_queue(uac1->int_ep, req, GFP_ATOMIC);\n\n\tif (ret)\n\t\tgoto err_free_msg;\n\n\treturn 0;\n\nerr_free_msg:\n\tkfree(msg);\nerr_free_request:\n\tusb_ep_free_request(uac1->int_ep, req);\nerr_dec_int_count:\n\tatomic_dec(&uac1->int_count);\n\n\treturn ret;\n}\n\nstatic int\nin_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *audio = func_to_g_audio(fn);\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_MUTE) {\n\t\t\tunsigned int mute;\n\n\t\t\tu_audio_get_mute(audio, is_playback, &mute);\n\n\t\t\t*(u8 *)req->buf = mute;\n\t\t\tvalue = min_t(unsigned int, w_length, 1);\n\t\t} else if (control_selector == UAC_FU_VOLUME) {\n\t\t\t__le16 c;\n\t\t\ts16 volume;\n\n\t\t\tu_audio_get_volume(audio, is_playback, &volume);\n\n\t\t\tc = cpu_to_le16(volume);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(c));\n\t\t\tmemcpy(req->buf, &c, value);\n\t\t} else {\n\t\t\tdev_err(&audio->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic int\nin_rq_min(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *audio = func_to_g_audio(fn);\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_VOLUME) {\n\t\t\t__le16 r;\n\t\t\ts16 min_db;\n\n\t\t\tif (is_playback)\n\t\t\t\tmin_db = opts->p_volume_min;\n\t\t\telse\n\t\t\t\tmin_db = opts->c_volume_min;\n\n\t\t\tr = cpu_to_le16(min_db);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(r));\n\t\t\tmemcpy(req->buf, &r, value);\n\t\t} else {\n\t\t\tdev_err(&audio->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic int\nin_rq_max(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *audio = func_to_g_audio(fn);\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_VOLUME) {\n\t\t\t__le16 r;\n\t\t\ts16 max_db;\n\n\t\t\tif (is_playback)\n\t\t\t\tmax_db = opts->p_volume_max;\n\t\t\telse\n\t\t\t\tmax_db = opts->c_volume_max;\n\n\t\t\tr = cpu_to_le16(max_db);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(r));\n\t\t\tmemcpy(req->buf, &r, value);\n\t\t} else {\n\t\t\tdev_err(&audio->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic int\nin_rq_res(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *audio = func_to_g_audio(fn);\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\tint value = -EOPNOTSUPP;\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_VOLUME) {\n\t\t\t__le16 r;\n\t\t\ts16 res_db;\n\n\t\t\tif (is_playback)\n\t\t\t\tres_db = opts->p_volume_res;\n\t\t\telse\n\t\t\t\tres_db = opts->c_volume_res;\n\n\t\t\tr = cpu_to_le16(res_db);\n\n\t\t\tvalue = min_t(unsigned int, w_length, sizeof(r));\n\t\t\tmemcpy(req->buf, &r, value);\n\t\t} else {\n\t\t\tdev_err(&audio->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t}\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\n\treturn value;\n}\n\nstatic void\nout_rq_cur_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct g_audio *audio = req->context;\n\tstruct usb_composite_dev *cdev = audio->func.config->cdev;\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tstruct f_uac1 *uac1 = func_to_uac1(&audio->func);\n\tstruct usb_ctrlrequest *cr = &uac1->setup_cr;\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\n\tif (req->status != 0) {\n\t\tdev_dbg(&cdev->gadget->dev, \"completion err %d\\n\", req->status);\n\t\treturn;\n\t}\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tunsigned int is_playback = 0;\n\n\t\tif (FUIN_EN(opts) && (entity_id == USB_IN_FU_ID))\n\t\t\tis_playback = 1;\n\n\t\tif (control_selector == UAC_FU_MUTE) {\n\t\t\tu8 mute = *(u8 *)req->buf;\n\n\t\t\tu_audio_set_mute(audio, is_playback, mute);\n\n\t\t\treturn;\n\t\t} else if (control_selector == UAC_FU_VOLUME) {\n\t\t\t__le16 *c = req->buf;\n\t\t\ts16 volume;\n\n\t\t\tvolume = le16_to_cpu(*c);\n\t\t\tu_audio_set_volume(audio, is_playback, volume);\n\n\t\t\treturn;\n\t\t} else {\n\t\t\tdev_err(&audio->gadget->dev,\n\t\t\t\t\"%s:%d control_selector=%d TODO!\\n\",\n\t\t\t\t__func__, __LINE__, control_selector);\n\t\t\tusb_ep_set_halt(ep);\n\t\t}\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t\tusb_ep_set_halt(ep);\n\n\t}\n}\n\nstatic int\nout_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\n{\n\tstruct usb_request *req = fn->config->cdev->req;\n\tstruct g_audio *audio = func_to_g_audio(fn);\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\tstruct f_uac1 *uac1 = func_to_uac1(&audio->func);\n\tu16 w_length = le16_to_cpu(cr->wLength);\n\tu16 w_index = le16_to_cpu(cr->wIndex);\n\tu16 w_value = le16_to_cpu(cr->wValue);\n\tu8 entity_id = (w_index >> 8) & 0xff;\n\tu8 control_selector = w_value >> 8;\n\n\tif ((FUIN_EN(opts) && (entity_id == USB_IN_FU_ID)) ||\n\t\t\t(FUOUT_EN(opts) && (entity_id == USB_OUT_FU_ID))) {\n\t\tmemcpy(&uac1->setup_cr, cr, sizeof(*cr));\n\t\treq->context = audio;\n\t\treq->complete = out_rq_cur_complete;\n\n\t\treturn w_length;\n\t} else {\n\t\tdev_err(&audio->gadget->dev,\n\t\t\t\"%s:%d entity_id=%d control_selector=%d TODO!\\n\",\n\t\t\t__func__, __LINE__, entity_id, control_selector);\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ac_rq_in(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tint value = -EOPNOTSUPP;\n\tu8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\n\tu16 len = le16_to_cpu(ctrl->wLength);\n\tu16 w_value = le16_to_cpu(ctrl->wValue);\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, ep);\n\n\tswitch (ctrl->bRequest) {\n\tcase UAC_GET_CUR:\n\t\treturn in_rq_cur(f, ctrl);\n\tcase UAC_GET_MIN:\n\t\treturn in_rq_min(f, ctrl);\n\tcase UAC_GET_MAX:\n\t\treturn in_rq_max(f, ctrl);\n\tcase UAC_GET_RES:\n\t\treturn in_rq_res(f, ctrl);\n\tcase UAC_GET_MEM:\n\t\tbreak;\n\tcase UAC_GET_STAT:\n\t\tvalue = len;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic int audio_set_endpoint_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = f->config->cdev->req;\n\tstruct f_uac1\t\t*uac1 = func_to_uac1(f);\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tep = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tlen = le16_to_cpu(ctrl->wLength);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu8\t\t\tcs = w_value >> 8;\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, ep);\n\n\tswitch (ctrl->bRequest) {\n\tcase UAC_SET_CUR: {\n\t\tif (cs == UAC_EP_CS_ATTR_SAMPLE_RATE) {\n\t\t\tcdev->gadget->ep0->driver_data = f;\n\t\t\tuac1->ctl_id = ep;\n\t\t\treq->complete = uac_cs_attr_sample_rate;\n\t\t}\n\t\tvalue = len;\n\t\tbreak;\n\t}\n\n\tcase UAC_SET_MIN:\n\t\tbreak;\n\n\tcase UAC_SET_MAX:\n\t\tbreak;\n\n\tcase UAC_SET_RES:\n\t\tbreak;\n\n\tcase UAC_SET_MEM:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic int audio_get_endpoint_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request *req = f->config->cdev->req;\n\tstruct f_uac1 *uac1 = func_to_uac1(f);\n\tu8 *buf = (u8 *)req->buf;\n\tint value = -EOPNOTSUPP;\n\tu8 ep = le16_to_cpu(ctrl->wIndex);\n\tu16 len = le16_to_cpu(ctrl->wLength);\n\tu16 w_value = le16_to_cpu(ctrl->wValue);\n\tu8 cs = w_value >> 8;\n\tu32 val = 0;\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, ep);\n\n\tswitch (ctrl->bRequest) {\n\tcase UAC_GET_CUR: {\n\t\tif (cs == UAC_EP_CS_ATTR_SAMPLE_RATE) {\n\t\t\tif (ep == (USB_DIR_IN | 2))\n\t\t\t\tval = uac1->p_srate;\n\t\t\telse if (ep == (USB_DIR_OUT | 1))\n\t\t\t\tval = uac1->c_srate;\n\t\t\tbuf[2] = (val >> 16) & 0xff;\n\t\t\tbuf[1] = (val >> 8) & 0xff;\n\t\t\tbuf[0] = val & 0xff;\n\t\t}\n\t\tvalue = len;\n\t\tbreak;\n\t}\n\tcase UAC_GET_MIN:\n\tcase UAC_GET_MAX:\n\tcase UAC_GET_RES:\n\t\tvalue = len;\n\t\tbreak;\n\tcase UAC_GET_MEM:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic int\nf_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch (ctrl->bRequestType) {\n\tcase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\n\t\tvalue = audio_set_endpoint_req(f, ctrl);\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\n\t\tvalue = audio_get_endpoint_req(f, ctrl);\n\t\tbreak;\n\tcase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\n\t\tif (ctrl->bRequest == UAC_SET_CUR)\n\t\t\tvalue = out_rq_cur(f, ctrl);\n\t\tbreak;\n\tcase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\n\t\tvalue = ac_rq_in(f, ctrl);\n\t\tbreak;\n\tdefault:\n\t\tERROR(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tDBG(cdev, \"audio req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"audio response on err %d\\n\", value);\n\t}\n\n\t \n\treturn value;\n}\n\nstatic int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tstruct g_audio *audio = func_to_g_audio(f);\n\tstruct f_uac1 *uac1 = func_to_uac1(f);\n\tint ret = 0;\n\n\t \n\tif (alt > 1) {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intf == uac1->ac_intf) {\n\t\t \n\t\tif (alt) {\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (uac1->int_ep) {\n\t\t\tusb_ep_disable(uac1->int_ep);\n\t\t\tconfig_ep_by_speed(gadget, &audio->func, uac1->int_ep);\n\t\t\tusb_ep_enable(uac1->int_ep);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (intf == uac1->as_out_intf) {\n\t\tuac1->as_out_alt = alt;\n\n\t\tif (alt)\n\t\t\tret = u_audio_start_capture(&uac1->g_audio);\n\t\telse\n\t\t\tu_audio_stop_capture(&uac1->g_audio);\n\t} else if (intf == uac1->as_in_intf) {\n\t\tuac1->as_in_alt = alt;\n\n\t\tif (alt)\n\t\t\tret = u_audio_start_playback(&uac1->g_audio);\n\t\telse\n\t\t\tu_audio_stop_playback(&uac1->g_audio);\n\t} else {\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int f_audio_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tstruct f_uac1 *uac1 = func_to_uac1(f);\n\n\tif (intf == uac1->ac_intf)\n\t\treturn uac1->ac_alt;\n\telse if (intf == uac1->as_out_intf)\n\t\treturn uac1->as_out_alt;\n\telse if (intf == uac1->as_in_intf)\n\t\treturn uac1->as_in_alt;\n\telse\n\t\tdev_err(dev, \"%s:%d Invalid Interface %d!\\n\",\n\t\t\t__func__, __LINE__, intf);\n\n\treturn -EINVAL;\n}\n\n\nstatic void f_audio_disable(struct usb_function *f)\n{\n\tstruct f_uac1 *uac1 = func_to_uac1(f);\n\n\tuac1->as_out_alt = 0;\n\tuac1->as_in_alt = 0;\n\n\tu_audio_stop_playback(&uac1->g_audio);\n\tu_audio_stop_capture(&uac1->g_audio);\n\tif (uac1->int_ep)\n\t\tusb_ep_disable(uac1->int_ep);\n}\n\nstatic void\nf_audio_suspend(struct usb_function *f)\n{\n\tstruct f_uac1 *uac1 = func_to_uac1(f);\n\n\tu_audio_suspend(&uac1->g_audio);\n}\n\n \nstatic struct uac_feature_unit_descriptor *build_fu_desc(int chmask)\n{\n\tstruct uac_feature_unit_descriptor *fu_desc;\n\tint channels = num_channels(chmask);\n\tint fu_desc_size = UAC_DT_FEATURE_UNIT_SIZE(channels);\n\n\tfu_desc = kzalloc(fu_desc_size, GFP_KERNEL);\n\tif (!fu_desc)\n\t\treturn NULL;\n\n\tfu_desc->bLength = fu_desc_size;\n\tfu_desc->bDescriptorType = USB_DT_CS_INTERFACE;\n\n\tfu_desc->bDescriptorSubtype = UAC_FEATURE_UNIT;\n\tfu_desc->bControlSize  = 2;\n\n\t \n\n\treturn fu_desc;\n}\n\n \nstatic struct\nuac1_ac_header_descriptor *build_ac_header_desc(struct f_uac1_opts *opts)\n{\n\tstruct uac1_ac_header_descriptor *ac_desc;\n\tint ac_header_desc_size;\n\tint num_ifaces = 0;\n\n\tif (EPOUT_EN(opts))\n\t\tnum_ifaces++;\n\tif (EPIN_EN(opts))\n\t\tnum_ifaces++;\n\n\tac_header_desc_size = UAC_DT_AC_HEADER_SIZE(num_ifaces);\n\n\tac_desc = kzalloc(ac_header_desc_size, GFP_KERNEL);\n\tif (!ac_desc)\n\t\treturn NULL;\n\n\tac_desc->bLength = ac_header_desc_size;\n\tac_desc->bDescriptorType = USB_DT_CS_INTERFACE;\n\tac_desc->bDescriptorSubtype = UAC_HEADER;\n\tac_desc->bcdADC = cpu_to_le16(0x0100);\n\tac_desc->bInCollection = num_ifaces;\n\n\t \n\n\treturn ac_desc;\n}\n\n \n#define USBDHDR(p) (struct usb_descriptor_header *)(p)\n\nstatic void setup_descriptor(struct f_uac1_opts *opts)\n{\n\t \n\tint i = 1;  \n\n\tif (EPOUT_EN(opts))\n\t\tusb_out_it_desc.bTerminalID = i++;\n\tif (EPIN_EN(opts))\n\t\tio_in_it_desc.bTerminalID = i++;\n\tif (EPOUT_EN(opts))\n\t\tio_out_ot_desc.bTerminalID = i++;\n\tif (EPIN_EN(opts))\n\t\tusb_in_ot_desc.bTerminalID = i++;\n\tif (FUOUT_EN(opts))\n\t\tout_feature_unit_desc->bUnitID = i++;\n\tif (FUIN_EN(opts))\n\t\tin_feature_unit_desc->bUnitID = i++;\n\n\tif (FUIN_EN(opts)) {\n\t\tusb_in_ot_desc.bSourceID = in_feature_unit_desc->bUnitID;\n\t\tin_feature_unit_desc->bSourceID = io_in_it_desc.bTerminalID;\n\t} else {\n\t\tusb_in_ot_desc.bSourceID = io_in_it_desc.bTerminalID;\n\t}\n\tif (FUOUT_EN(opts)) {\n\t\tio_out_ot_desc.bSourceID = out_feature_unit_desc->bUnitID;\n\t\tout_feature_unit_desc->bSourceID = usb_out_it_desc.bTerminalID;\n\t} else {\n\t\tio_out_ot_desc.bSourceID = usb_out_it_desc.bTerminalID;\n\t}\n\n\tas_out_header_desc.bTerminalLink = usb_out_it_desc.bTerminalID;\n\tas_in_header_desc.bTerminalLink = usb_in_ot_desc.bTerminalID;\n\n\tac_header_desc->wTotalLength = cpu_to_le16(ac_header_desc->bLength);\n\n\tif (EPIN_EN(opts)) {\n\t\tu16 len = le16_to_cpu(ac_header_desc->wTotalLength);\n\n\t\tlen += sizeof(usb_in_ot_desc);\n\t\tlen += sizeof(io_in_it_desc);\n\t\tif (FUIN_EN(opts))\n\t\t\tlen += in_feature_unit_desc->bLength;\n\t\tac_header_desc->wTotalLength = cpu_to_le16(len);\n\t}\n\tif (EPOUT_EN(opts)) {\n\t\tu16 len = le16_to_cpu(ac_header_desc->wTotalLength);\n\n\t\tlen += sizeof(usb_out_it_desc);\n\t\tlen += sizeof(io_out_ot_desc);\n\t\tif (FUOUT_EN(opts))\n\t\t\tlen += out_feature_unit_desc->bLength;\n\t\tac_header_desc->wTotalLength = cpu_to_le16(len);\n\t}\n\n\ti = 0;\n\tf_audio_desc[i++] = USBDHDR(&ac_interface_desc);\n\tf_audio_desc[i++] = USBDHDR(ac_header_desc);\n\n\tif (EPOUT_EN(opts)) {\n\t\tf_audio_desc[i++] = USBDHDR(&usb_out_it_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&io_out_ot_desc);\n\t\tif (FUOUT_EN(opts))\n\t\t\tf_audio_desc[i++] = USBDHDR(out_feature_unit_desc);\n\t}\n\n\tif (EPIN_EN(opts)) {\n\t\tf_audio_desc[i++] = USBDHDR(&io_in_it_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&usb_in_ot_desc);\n\t\tif (FUIN_EN(opts))\n\t\t\tf_audio_desc[i++] = USBDHDR(in_feature_unit_desc);\n\t}\n\n\tif (FUOUT_EN(opts) || FUIN_EN(opts))\n\t\tf_audio_desc[i++] = USBDHDR(&ac_int_ep_desc);\n\n\tif (EPOUT_EN(opts)) {\n\t\tf_audio_desc[i++] = USBDHDR(&as_out_interface_alt_0_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_out_interface_alt_1_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_out_header_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_out_type_i_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_out_ep_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_iso_out_desc);\n\t}\n\tif (EPIN_EN(opts)) {\n\t\tf_audio_desc[i++] = USBDHDR(&as_in_interface_alt_0_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_in_interface_alt_1_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_in_header_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_in_type_i_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_in_ep_desc);\n\t\tf_audio_desc[i++] = USBDHDR(&as_iso_in_desc);\n\t}\n\tf_audio_desc[i] = NULL;\n}\n\nstatic int f_audio_validate_opts(struct g_audio *audio, struct device *dev)\n{\n\tstruct f_uac1_opts *opts = g_audio_to_uac1_opts(audio);\n\n\tif (!opts->p_chmask && !opts->c_chmask) {\n\t\tdev_err(dev, \"Error: no playback and capture channels\\n\");\n\t\treturn -EINVAL;\n\t} else if (opts->p_chmask & ~UAC1_CHANNEL_MASK) {\n\t\tdev_err(dev, \"Error: unsupported playback channels mask\\n\");\n\t\treturn -EINVAL;\n\t} else if (opts->c_chmask & ~UAC1_CHANNEL_MASK) {\n\t\tdev_err(dev, \"Error: unsupported capture channels mask\\n\");\n\t\treturn -EINVAL;\n\t} else if ((opts->p_ssize < 1) || (opts->p_ssize > 4)) {\n\t\tdev_err(dev, \"Error: incorrect playback sample size\\n\");\n\t\treturn -EINVAL;\n\t} else if ((opts->c_ssize < 1) || (opts->c_ssize > 4)) {\n\t\tdev_err(dev, \"Error: incorrect capture sample size\\n\");\n\t\treturn -EINVAL;\n\t} else if (!opts->p_srates[0]) {\n\t\tdev_err(dev, \"Error: incorrect playback sampling rate\\n\");\n\t\treturn -EINVAL;\n\t} else if (!opts->c_srates[0]) {\n\t\tdev_err(dev, \"Error: incorrect capture sampling rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (opts->p_volume_max <= opts->p_volume_min) {\n\t\tdev_err(dev, \"Error: incorrect playback volume max/min\\n\");\n\t\treturn -EINVAL;\n\t} else if (opts->c_volume_max <= opts->c_volume_min) {\n\t\tdev_err(dev, \"Error: incorrect capture volume max/min\\n\");\n\t\treturn -EINVAL;\n\t} else if (opts->p_volume_res <= 0) {\n\t\tdev_err(dev, \"Error: negative/zero playback volume resolution\\n\");\n\t\treturn -EINVAL;\n\t} else if (opts->c_volume_res <= 0) {\n\t\tdev_err(dev, \"Error: negative/zero capture volume resolution\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((opts->p_volume_max - opts->p_volume_min) % opts->p_volume_res) {\n\t\tdev_err(dev, \"Error: incorrect playback volume resolution\\n\");\n\t\treturn -EINVAL;\n\t} else if ((opts->c_volume_max - opts->c_volume_min) % opts->c_volume_res) {\n\t\tdev_err(dev, \"Error: incorrect capture volume resolution\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int f_audio_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev\t*cdev = c->cdev;\n\tstruct usb_gadget\t\t*gadget = cdev->gadget;\n\tstruct device\t\t\t*dev = &gadget->dev;\n\tstruct f_uac1\t\t\t*uac1 = func_to_uac1(f);\n\tstruct g_audio\t\t\t*audio = func_to_g_audio(f);\n\tstruct f_uac1_opts\t\t*audio_opts;\n\tstruct usb_ep\t\t\t*ep = NULL;\n\tstruct usb_string\t\t*us;\n\tint\t\t\t\tba_iface_id;\n\tint\t\t\t\tstatus;\n\tint\t\t\t\tidx, i;\n\n\tstatus = f_audio_validate_opts(audio, dev);\n\tif (status)\n\t\treturn status;\n\n\taudio_opts = container_of(f->fi, struct f_uac1_opts, func_inst);\n\n\tstrings_uac1[STR_AC_IF].s = audio_opts->function_name;\n\n\tus = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\n\tac_header_desc = build_ac_header_desc(audio_opts);\n\tif (!ac_header_desc)\n\t\treturn -ENOMEM;\n\n\tif (FUOUT_EN(audio_opts)) {\n\t\tout_feature_unit_desc = build_fu_desc(audio_opts->c_chmask);\n\t\tif (!out_feature_unit_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (FUIN_EN(audio_opts)) {\n\t\tin_feature_unit_desc = build_fu_desc(audio_opts->p_chmask);\n\t\tif (!in_feature_unit_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto err_free_fu;\n\t\t}\n\t}\n\n\tac_interface_desc.iInterface = us[STR_AC_IF].id;\n\tusb_out_it_desc.iTerminal = us[STR_USB_OUT_IT].id;\n\tusb_out_it_desc.iChannelNames = us[STR_USB_OUT_IT_CH_NAMES].id;\n\tio_out_ot_desc.iTerminal = us[STR_IO_OUT_OT].id;\n\tas_out_interface_alt_0_desc.iInterface = us[STR_AS_OUT_IF_ALT0].id;\n\tas_out_interface_alt_1_desc.iInterface = us[STR_AS_OUT_IF_ALT1].id;\n\tio_in_it_desc.iTerminal = us[STR_IO_IN_IT].id;\n\tio_in_it_desc.iChannelNames = us[STR_IO_IN_IT_CH_NAMES].id;\n\tusb_in_ot_desc.iTerminal = us[STR_USB_IN_OT].id;\n\tas_in_interface_alt_0_desc.iInterface = us[STR_AS_IN_IF_ALT0].id;\n\tas_in_interface_alt_1_desc.iInterface = us[STR_AS_IN_IF_ALT1].id;\n\n\tif (FUOUT_EN(audio_opts)) {\n\t\tu8 *i_feature;\n\n\t\ti_feature = (u8 *)out_feature_unit_desc +\n\t\t\t\t\tout_feature_unit_desc->bLength - 1;\n\t\t*i_feature = us[STR_FU_OUT].id;\n\t}\n\tif (FUIN_EN(audio_opts)) {\n\t\tu8 *i_feature;\n\n\t\ti_feature = (u8 *)in_feature_unit_desc +\n\t\t\t\t\tin_feature_unit_desc->bLength - 1;\n\t\t*i_feature = us[STR_FU_IN].id;\n\t}\n\n\t \n\tusb_out_it_desc.bNrChannels = num_channels(audio_opts->c_chmask);\n\tusb_out_it_desc.wChannelConfig = cpu_to_le16(audio_opts->c_chmask);\n\tas_out_type_i_desc.bNrChannels = num_channels(audio_opts->c_chmask);\n\tas_out_type_i_desc.bSubframeSize = audio_opts->c_ssize;\n\tas_out_type_i_desc.bBitResolution = audio_opts->c_ssize * 8;\n\tio_in_it_desc.bNrChannels = num_channels(audio_opts->p_chmask);\n\tio_in_it_desc.wChannelConfig = cpu_to_le16(audio_opts->p_chmask);\n\tas_in_type_i_desc.bNrChannels = num_channels(audio_opts->p_chmask);\n\tas_in_type_i_desc.bSubframeSize = audio_opts->p_ssize;\n\tas_in_type_i_desc.bBitResolution = audio_opts->p_ssize * 8;\n\n\tif (FUOUT_EN(audio_opts)) {\n\t\t__le16 *bma = (__le16 *)&out_feature_unit_desc->bmaControls[0];\n\t\tu32 control = 0;\n\n\t\tif (audio_opts->c_mute_present)\n\t\t\tcontrol |= UAC_FU_MUTE;\n\t\tif (audio_opts->c_volume_present)\n\t\t\tcontrol |= UAC_FU_VOLUME;\n\t\t*bma = cpu_to_le16(control);\n\t}\n\tif (FUIN_EN(audio_opts)) {\n\t\t__le16 *bma = (__le16 *)&in_feature_unit_desc->bmaControls[0];\n\t\tu32 control = 0;\n\n\t\tif (audio_opts->p_mute_present)\n\t\t\tcontrol |= UAC_FU_MUTE;\n\t\tif (audio_opts->p_volume_present)\n\t\t\tcontrol |= UAC_FU_VOLUME;\n\t\t*bma = cpu_to_le16(control);\n\t}\n\n\t \n\tfor (i = 0, idx = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (audio_opts->c_srates[i] == 0)\n\t\t\tbreak;\n\t\tmemcpy(as_out_type_i_desc.tSamFreq[idx++],\n\t\t\t\t&audio_opts->c_srates[i], 3);\n\t}\n\tas_out_type_i_desc.bLength = UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(idx);\n\tas_out_type_i_desc.bSamFreqType = idx;\n\n\tfor (i = 0, idx = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (audio_opts->p_srates[i] == 0)\n\t\t\tbreak;\n\t\tmemcpy(as_in_type_i_desc.tSamFreq[idx++],\n\t\t\t\t&audio_opts->p_srates[i], 3);\n\t}\n\tas_in_type_i_desc.bLength = UAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(idx);\n\tas_in_type_i_desc.bSamFreqType = idx;\n\tuac1->p_srate = audio_opts->p_srates[0];\n\tuac1->c_srate = audio_opts->c_srates[0];\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto err_free_fu;\n\tac_interface_desc.bInterfaceNumber = status;\n\tuac1->ac_intf = status;\n\tuac1->ac_alt = 0;\n\n\tba_iface_id = 0;\n\n\tif (EPOUT_EN(audio_opts)) {\n\t\tstatus = usb_interface_id(c, f);\n\t\tif (status < 0)\n\t\t\tgoto err_free_fu;\n\t\tas_out_interface_alt_0_desc.bInterfaceNumber = status;\n\t\tas_out_interface_alt_1_desc.bInterfaceNumber = status;\n\t\tac_header_desc->baInterfaceNr[ba_iface_id++] = status;\n\t\tuac1->as_out_intf = status;\n\t\tuac1->as_out_alt = 0;\n\t}\n\n\tif (EPIN_EN(audio_opts)) {\n\t\tstatus = usb_interface_id(c, f);\n\t\tif (status < 0)\n\t\t\tgoto err_free_fu;\n\t\tas_in_interface_alt_0_desc.bInterfaceNumber = status;\n\t\tas_in_interface_alt_1_desc.bInterfaceNumber = status;\n\t\tac_header_desc->baInterfaceNr[ba_iface_id++] = status;\n\t\tuac1->as_in_intf = status;\n\t\tuac1->as_in_alt = 0;\n\t}\n\n\taudio->gadget = gadget;\n\n\tstatus = -ENODEV;\n\n\tac_interface_desc.bNumEndpoints = 0;\n\n\t \n\tif (FUOUT_EN(audio_opts) || FUIN_EN(audio_opts)) {\n\t\tep = usb_ep_autoconfig(cdev->gadget, &ac_int_ep_desc);\n\t\tif (!ep)\n\t\t\tgoto err_free_fu;\n\t\tuac1->int_ep = ep;\n\t\tuac1->int_ep->desc = &ac_int_ep_desc;\n\n\t\tac_interface_desc.bNumEndpoints = 1;\n\t}\n\n\t \n\tif (EPOUT_EN(audio_opts)) {\n\t\tep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);\n\t\tif (!ep)\n\t\t\tgoto err_free_fu;\n\t\taudio->out_ep = ep;\n\t\taudio->out_ep->desc = &as_out_ep_desc;\n\t}\n\n\tif (EPIN_EN(audio_opts)) {\n\t\tep = usb_ep_autoconfig(cdev->gadget, &as_in_ep_desc);\n\t\tif (!ep)\n\t\t\tgoto err_free_fu;\n\t\taudio->in_ep = ep;\n\t\taudio->in_ep->desc = &as_in_ep_desc;\n\t}\n\n\tsetup_descriptor(audio_opts);\n\n\t \n\tstatus = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL,\n\t\t\t\t\tNULL);\n\tif (status)\n\t\tgoto err_free_fu;\n\n\taudio->out_ep_maxpsize = le16_to_cpu(as_out_ep_desc.wMaxPacketSize);\n\taudio->in_ep_maxpsize = le16_to_cpu(as_in_ep_desc.wMaxPacketSize);\n\taudio->params.c_chmask = audio_opts->c_chmask;\n\tmemcpy(audio->params.c_srates, audio_opts->c_srates,\n\t\t\tsizeof(audio->params.c_srates));\n\taudio->params.c_ssize = audio_opts->c_ssize;\n\tif (FUIN_EN(audio_opts)) {\n\t\taudio->params.p_fu.id = USB_IN_FU_ID;\n\t\taudio->params.p_fu.mute_present = audio_opts->p_mute_present;\n\t\taudio->params.p_fu.volume_present =\n\t\t\t\taudio_opts->p_volume_present;\n\t\taudio->params.p_fu.volume_min = audio_opts->p_volume_min;\n\t\taudio->params.p_fu.volume_max = audio_opts->p_volume_max;\n\t\taudio->params.p_fu.volume_res = audio_opts->p_volume_res;\n\t}\n\taudio->params.p_chmask = audio_opts->p_chmask;\n\tmemcpy(audio->params.p_srates, audio_opts->p_srates,\n\t\t\tsizeof(audio->params.p_srates));\n\taudio->params.p_ssize = audio_opts->p_ssize;\n\tif (FUOUT_EN(audio_opts)) {\n\t\taudio->params.c_fu.id = USB_OUT_FU_ID;\n\t\taudio->params.c_fu.mute_present = audio_opts->c_mute_present;\n\t\taudio->params.c_fu.volume_present =\n\t\t\t\taudio_opts->c_volume_present;\n\t\taudio->params.c_fu.volume_min = audio_opts->c_volume_min;\n\t\taudio->params.c_fu.volume_max = audio_opts->c_volume_max;\n\t\taudio->params.c_fu.volume_res = audio_opts->c_volume_res;\n\t}\n\taudio->params.req_number = audio_opts->req_number;\n\taudio->params.fb_max = FBACK_FAST_MAX;\n\tif (FUOUT_EN(audio_opts) || FUIN_EN(audio_opts))\n\t\taudio->notify = audio_notify;\n\n\tstatus = g_audio_setup(audio, \"UAC1_PCM\", \"UAC1_Gadget\");\n\tif (status)\n\t\tgoto err_card_register;\n\n\treturn 0;\n\nerr_card_register:\n\tusb_free_all_descriptors(f);\nerr_free_fu:\n\tkfree(out_feature_unit_desc);\n\tout_feature_unit_desc = NULL;\n\tkfree(in_feature_unit_desc);\n\tin_feature_unit_desc = NULL;\nfail:\n\tkfree(ac_header_desc);\n\tac_header_desc = NULL;\n\treturn status;\n}\n\n \n\nstatic inline struct f_uac1_opts *to_f_uac1_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_uac1_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void f_uac1_attr_release(struct config_item *item)\n{\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations f_uac1_item_ops = {\n\t.release\t= f_uac1_attr_release,\n};\n\n#define uac1_kstrtou32\t\t\tkstrtou32\n#define uac1_kstrtos16\t\t\tkstrtos16\n#define uac1_kstrtobool(s, base, res)\tkstrtobool((s), (res))\n\nstatic const char *u32_fmt = \"%u\\n\";\nstatic const char *s16_fmt = \"%hd\\n\";\nstatic const char *bool_fmt = \"%u\\n\";\n\n#define UAC1_ATTRIBUTE(type, name)\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_show(\t\t\t\t\\\n\t\t\t\t\t  struct config_item *item,\t\\\n\t\t\t\t\t  char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, type##_fmt, opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_store(\t\t\t\t\\\n\t\t\t\t\t  struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\ttype num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = uac1_kstrto##type(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac1_opts_, name)\n\n#define UAC1_RATE_ATTRIBUTE(name)\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint result = 0;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tpage[0] = '\\0';\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\t\t\t\t\\\n\t\tif (opts->name##s[i] == 0)\t\t\t\t\\\n\t\t\tbreak;\t\t\t\t\t\t\\\n\t\tresult += sprintf(page + strlen(page), \"%u,\",\t\t\\\n\t\t\t\topts->name##s[i]);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (strlen(page) > 0)\t\t\t\t\t\t\\\n\t\tpage[strlen(page) - 1] = '\\n';\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tchar *split_page = NULL;\t\t\t\t\t\\\n\tint ret = -EINVAL;\t\t\t\t\t\t\\\n\tchar *token;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\tint i;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ti = 0;\t\t\t\t\t\t\t\t\\\n\tmemset(opts->name##s, 0x00, sizeof(opts->name##s));\t\t\\\n\tsplit_page = kstrdup(page, GFP_KERNEL);\t\t\t\t\\\n\twhile ((token = strsep(&split_page, \",\")) != NULL) {\t\t\\\n\t\tret = kstrtou32(token, 0, &num);\t\t\t\\\n\t\tif (ret)\t\t\t\t\t\t\\\n\t\t\tgoto end;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\topts->name##s[i++] = num;\t\t\t\t\\\n\t\tret = len;\t\t\t\t\t\t\\\n\t};\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tkfree(split_page);\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac1_opts_, name)\n\n#define UAC1_ATTRIBUTE_STRING(name)\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = snprintf(page, sizeof(opts->name), \"%s\", opts->name);\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = snprintf(opts->name, min(sizeof(opts->name), len),\t\\\n\t\t\t\"%s\", page);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac1_opts_, name)\n\nUAC1_ATTRIBUTE(u32, c_chmask);\nUAC1_RATE_ATTRIBUTE(c_srate);\nUAC1_ATTRIBUTE(u32, c_ssize);\nUAC1_ATTRIBUTE(u32, p_chmask);\nUAC1_RATE_ATTRIBUTE(p_srate);\nUAC1_ATTRIBUTE(u32, p_ssize);\nUAC1_ATTRIBUTE(u32, req_number);\n\nUAC1_ATTRIBUTE(bool, p_mute_present);\nUAC1_ATTRIBUTE(bool, p_volume_present);\nUAC1_ATTRIBUTE(s16, p_volume_min);\nUAC1_ATTRIBUTE(s16, p_volume_max);\nUAC1_ATTRIBUTE(s16, p_volume_res);\n\nUAC1_ATTRIBUTE(bool, c_mute_present);\nUAC1_ATTRIBUTE(bool, c_volume_present);\nUAC1_ATTRIBUTE(s16, c_volume_min);\nUAC1_ATTRIBUTE(s16, c_volume_max);\nUAC1_ATTRIBUTE(s16, c_volume_res);\nUAC1_ATTRIBUTE_STRING(function_name);\n\nstatic struct configfs_attribute *f_uac1_attrs[] = {\n\t&f_uac1_opts_attr_c_chmask,\n\t&f_uac1_opts_attr_c_srate,\n\t&f_uac1_opts_attr_c_ssize,\n\t&f_uac1_opts_attr_p_chmask,\n\t&f_uac1_opts_attr_p_srate,\n\t&f_uac1_opts_attr_p_ssize,\n\t&f_uac1_opts_attr_req_number,\n\n\t&f_uac1_opts_attr_p_mute_present,\n\t&f_uac1_opts_attr_p_volume_present,\n\t&f_uac1_opts_attr_p_volume_min,\n\t&f_uac1_opts_attr_p_volume_max,\n\t&f_uac1_opts_attr_p_volume_res,\n\n\t&f_uac1_opts_attr_c_mute_present,\n\t&f_uac1_opts_attr_c_volume_present,\n\t&f_uac1_opts_attr_c_volume_min,\n\t&f_uac1_opts_attr_c_volume_max,\n\t&f_uac1_opts_attr_c_volume_res,\n\n\t&f_uac1_opts_attr_function_name,\n\n\tNULL,\n};\n\nstatic const struct config_item_type f_uac1_func_type = {\n\t.ct_item_ops\t= &f_uac1_item_ops,\n\t.ct_attrs\t= f_uac1_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_audio_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_uac1_opts *opts;\n\n\topts = container_of(f, struct f_uac1_opts, func_inst);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *f_audio_alloc_inst(void)\n{\n\tstruct f_uac1_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_audio_free_inst;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &f_uac1_func_type);\n\n\topts->c_chmask = UAC1_DEF_CCHMASK;\n\topts->c_srates[0] = UAC1_DEF_CSRATE;\n\topts->c_ssize = UAC1_DEF_CSSIZE;\n\topts->p_chmask = UAC1_DEF_PCHMASK;\n\topts->p_srates[0] = UAC1_DEF_PSRATE;\n\topts->p_ssize = UAC1_DEF_PSSIZE;\n\n\topts->p_mute_present = UAC1_DEF_MUTE_PRESENT;\n\topts->p_volume_present = UAC1_DEF_VOLUME_PRESENT;\n\topts->p_volume_min = UAC1_DEF_MIN_DB;\n\topts->p_volume_max = UAC1_DEF_MAX_DB;\n\topts->p_volume_res = UAC1_DEF_RES_DB;\n\n\topts->c_mute_present = UAC1_DEF_MUTE_PRESENT;\n\topts->c_volume_present = UAC1_DEF_VOLUME_PRESENT;\n\topts->c_volume_min = UAC1_DEF_MIN_DB;\n\topts->c_volume_max = UAC1_DEF_MAX_DB;\n\topts->c_volume_res = UAC1_DEF_RES_DB;\n\n\topts->req_number = UAC1_DEF_REQ_NUM;\n\n\tsnprintf(opts->function_name, sizeof(opts->function_name), \"AC Interface\");\n\n\treturn &opts->func_inst;\n}\n\nstatic void f_audio_free(struct usb_function *f)\n{\n\tstruct g_audio *audio;\n\tstruct f_uac1_opts *opts;\n\n\taudio = func_to_g_audio(f);\n\topts = container_of(f->fi, struct f_uac1_opts, func_inst);\n\tkfree(audio);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void f_audio_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct g_audio *audio = func_to_g_audio(f);\n\n\tg_audio_cleanup(audio);\n\tusb_free_all_descriptors(f);\n\n\tkfree(out_feature_unit_desc);\n\tout_feature_unit_desc = NULL;\n\tkfree(in_feature_unit_desc);\n\tin_feature_unit_desc = NULL;\n\n\tkfree(ac_header_desc);\n\tac_header_desc = NULL;\n\n\taudio->gadget = NULL;\n}\n\nstatic struct usb_function *f_audio_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_uac1 *uac1;\n\tstruct f_uac1_opts *opts;\n\n\t \n\tuac1 = kzalloc(sizeof(*uac1), GFP_KERNEL);\n\tif (!uac1)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_uac1_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tuac1->g_audio.func.name = \"uac1_func\";\n\tuac1->g_audio.func.bind = f_audio_bind;\n\tuac1->g_audio.func.unbind = f_audio_unbind;\n\tuac1->g_audio.func.set_alt = f_audio_set_alt;\n\tuac1->g_audio.func.get_alt = f_audio_get_alt;\n\tuac1->g_audio.func.setup = f_audio_setup;\n\tuac1->g_audio.func.disable = f_audio_disable;\n\tuac1->g_audio.func.suspend = f_audio_suspend;\n\tuac1->g_audio.func.free_func = f_audio_free;\n\n\treturn &uac1->g_audio.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(uac1, f_audio_alloc_inst, f_audio_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Ruslan Bilovol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}