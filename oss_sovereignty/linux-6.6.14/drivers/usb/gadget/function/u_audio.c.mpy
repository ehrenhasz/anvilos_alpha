{
  "module_name": "u_audio.c",
  "hash_id": "4f6dfc1d30d21c0685ea1f26cc7df2f29ea18c26b0bf3e615f225a4538e2daed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/u_audio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <sound/core.h>\n#include <sound/pcm.h>\n#include <sound/pcm_params.h>\n#include <sound/control.h>\n#include <sound/tlv.h>\n#include <linux/usb/audio.h>\n\n#include \"u_audio.h\"\n\n#define BUFF_SIZE_MAX\t(PAGE_SIZE * 16)\n#define PRD_SIZE_MAX\tPAGE_SIZE\n#define MIN_PERIODS\t4\n\nenum {\n\tUAC_FBACK_CTRL,\n\tUAC_P_PITCH_CTRL,\n\tUAC_MUTE_CTRL,\n\tUAC_VOLUME_CTRL,\n\tUAC_RATE_CTRL,\n};\n\n \nstruct uac_rtd_params {\n\tstruct snd_uac_chip *uac;  \n\tbool ep_enabled;  \n\n\tstruct snd_pcm_substream *ss;\n\n\t \n\tssize_t hw_ptr;\n\n\tvoid *rbuf;\n\n\tunsigned int pitch;\t \n\tunsigned int max_psize;\t \n\n\tstruct usb_request **reqs;\n\n\tstruct usb_request *req_fback;  \n\tbool fb_ep_enabled;  \n\n   \n  int fu_id;  \n  struct snd_kcontrol *snd_kctl_volume;\n  struct snd_kcontrol *snd_kctl_mute;\n  s16 volume_min, volume_max, volume_res;\n  s16 volume;\n  int mute;\n\n\tstruct snd_kcontrol *snd_kctl_rate;  \n\tint srate;  \n\tint active;  \n\n  spinlock_t lock;  \n\n};\n\nstruct snd_uac_chip {\n\tstruct g_audio *audio_dev;\n\n\tstruct uac_rtd_params p_prm;\n\tstruct uac_rtd_params c_prm;\n\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\n\t \n\tunsigned long long p_residue_mil;\n\tunsigned int p_interval;\n\tunsigned int p_framesize;\n};\n\nstatic const struct snd_pcm_hardware uac_pcm_hardware = {\n\t.info = SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_BLOCK_TRANSFER\n\t\t | SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_MMAP_VALID\n\t\t | SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,\n\t.rates = SNDRV_PCM_RATE_CONTINUOUS,\n\t.periods_max = BUFF_SIZE_MAX / PRD_SIZE_MAX,\n\t.buffer_bytes_max = BUFF_SIZE_MAX,\n\t.period_bytes_max = PRD_SIZE_MAX,\n\t.periods_min = MIN_PERIODS,\n};\n\nstatic void u_audio_set_fback_frequency(enum usb_device_speed speed,\n\t\t\t\t\tstruct usb_ep *out_ep,\n\t\t\t\t\tunsigned long long freq,\n\t\t\t\t\tunsigned int pitch,\n\t\t\t\t\tvoid *buf)\n{\n\tu32 ff = 0;\n\tconst struct usb_endpoint_descriptor *ep_desc;\n\n\t \n\n\tif (speed == USB_SPEED_FULL) {\n\t\t \n\t\tfreq <<= 5;\n\t} else {\n\t\t \n\t\tep_desc = out_ep->desc;\n\t\tfreq <<= 4 + (ep_desc->bInterval - 1);\n\t}\n\n\tff = DIV_ROUND_CLOSEST_ULL((freq * pitch), 1953125);\n\n\t*(__le32 *)buf = cpu_to_le32(ff);\n}\n\nstatic void u_audio_iso_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tunsigned int pending;\n\tunsigned int hw_ptr;\n\tint status = req->status;\n\tstruct snd_pcm_substream *substream;\n\tstruct snd_pcm_runtime *runtime;\n\tstruct uac_rtd_params *prm = req->context;\n\tstruct snd_uac_chip *uac = prm->uac;\n\tunsigned int frames, p_pktsize;\n\tunsigned long long pitched_rate_mil, p_pktsize_residue_mil,\n\t\t\tresidue_frames_mil, div_result;\n\n\t \n\tif (!prm->ep_enabled) {\n\t\tusb_ep_free_request(ep, req);\n\t\treturn;\n\t}\n\n\tif (req->status == -ESHUTDOWN)\n\t\treturn;\n\n\t \n\tif (status)\n\t\tpr_debug(\"%s: iso_complete status(%d) %d/%d\\n\",\n\t\t\t__func__, status, req->actual, req->length);\n\n\tsubstream = prm->ss;\n\n\t \n\tif (!substream)\n\t\tgoto exit;\n\n\tsnd_pcm_stream_lock(substream);\n\n\truntime = substream->runtime;\n\tif (!runtime || !snd_pcm_running(substream)) {\n\t\tsnd_pcm_stream_unlock(substream);\n\t\tgoto exit;\n\t}\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t \n\t\tunsigned long long p_interval_mil = uac->p_interval * 1000000ULL;\n\n\t\tpitched_rate_mil = (unsigned long long) prm->srate * prm->pitch;\n\t\tdiv_result = pitched_rate_mil;\n\t\tdo_div(div_result, uac->p_interval);\n\t\tdo_div(div_result, 1000000);\n\t\tframes = (unsigned int) div_result;\n\n\t\tpr_debug(\"p_srate %d, pitch %d, interval_mil %llu, frames %d\\n\",\n\t\t\t\tprm->srate, prm->pitch, p_interval_mil, frames);\n\n\t\tp_pktsize = min_t(unsigned int,\n\t\t\t\t\tuac->p_framesize * frames,\n\t\t\t\t\tep->maxpacket);\n\n\t\tif (p_pktsize < ep->maxpacket) {\n\t\t\tresidue_frames_mil = pitched_rate_mil - frames * p_interval_mil;\n\t\t\tp_pktsize_residue_mil = uac->p_framesize * residue_frames_mil;\n\t\t} else\n\t\t\tp_pktsize_residue_mil = 0;\n\n\t\treq->length = p_pktsize;\n\t\tuac->p_residue_mil += p_pktsize_residue_mil;\n\n\t\t \n\t\tdiv_result = uac->p_residue_mil;\n\t\tdo_div(div_result, uac->p_interval);\n\t\tdo_div(div_result, 1000000);\n\t\tif ((unsigned int) div_result >= uac->p_framesize) {\n\t\t\treq->length += uac->p_framesize;\n\t\t\tuac->p_residue_mil -= uac->p_framesize * p_interval_mil;\n\t\t\tpr_debug(\"increased req length to %d\\n\", req->length);\n\t\t}\n\t\tpr_debug(\"remains uac->p_residue_mil %llu\\n\", uac->p_residue_mil);\n\n\t\treq->actual = req->length;\n\t}\n\n\thw_ptr = prm->hw_ptr;\n\n\t \n\tpending = runtime->dma_bytes - hw_ptr;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\tif (unlikely(pending < req->actual)) {\n\t\t\tmemcpy(req->buf, runtime->dma_area + hw_ptr, pending);\n\t\t\tmemcpy(req->buf + pending, runtime->dma_area,\n\t\t\t       req->actual - pending);\n\t\t} else {\n\t\t\tmemcpy(req->buf, runtime->dma_area + hw_ptr,\n\t\t\t       req->actual);\n\t\t}\n\t} else {\n\t\tif (unlikely(pending < req->actual)) {\n\t\t\tmemcpy(runtime->dma_area + hw_ptr, req->buf, pending);\n\t\t\tmemcpy(runtime->dma_area, req->buf + pending,\n\t\t\t       req->actual - pending);\n\t\t} else {\n\t\t\tmemcpy(runtime->dma_area + hw_ptr, req->buf,\n\t\t\t       req->actual);\n\t\t}\n\t}\n\n\t \n\tprm->hw_ptr = (hw_ptr + req->actual) % runtime->dma_bytes;\n\thw_ptr = prm->hw_ptr;\n\tsnd_pcm_stream_unlock(substream);\n\n\tif ((hw_ptr % snd_pcm_lib_period_bytes(substream)) < req->actual)\n\t\tsnd_pcm_period_elapsed(substream);\n\nexit:\n\tif (usb_ep_queue(ep, req, GFP_ATOMIC))\n\t\tdev_err(uac->card->dev, \"%d Error!\\n\", __LINE__);\n}\n\nstatic void u_audio_iso_fback_complete(struct usb_ep *ep,\n\t\t\t\t       struct usb_request *req)\n{\n\tstruct uac_rtd_params *prm = req->context;\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tint status = req->status;\n\n\t \n\tif (!prm->fb_ep_enabled) {\n\t\tkfree(req->buf);\n\t\tusb_ep_free_request(ep, req);\n\t\treturn;\n\t}\n\n\tif (req->status == -ESHUTDOWN)\n\t\treturn;\n\n\t \n\tif (status)\n\t\tpr_debug(\"%s: iso_complete status(%d) %d/%d\\n\",\n\t\t\t__func__, status, req->actual, req->length);\n\n\tu_audio_set_fback_frequency(audio_dev->gadget->speed, audio_dev->out_ep,\n\t\t\t\t    prm->srate, prm->pitch,\n\t\t\t\t    req->buf);\n\n\tif (usb_ep_queue(ep, req, GFP_ATOMIC))\n\t\tdev_err(uac->card->dev, \"%d Error!\\n\", __LINE__);\n}\n\nstatic int uac_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\n{\n\tstruct snd_uac_chip *uac = snd_pcm_substream_chip(substream);\n\tstruct uac_rtd_params *prm;\n\tstruct g_audio *audio_dev;\n\tstruct uac_params *params;\n\tint err = 0;\n\n\taudio_dev = uac->audio_dev;\n\tparams = &audio_dev->params;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\t \n\tprm->hw_ptr = 0;\n\n\tswitch (cmd) {\n\tcase SNDRV_PCM_TRIGGER_START:\n\tcase SNDRV_PCM_TRIGGER_RESUME:\n\t\tprm->ss = substream;\n\t\tbreak;\n\tcase SNDRV_PCM_TRIGGER_STOP:\n\tcase SNDRV_PCM_TRIGGER_SUSPEND:\n\t\tprm->ss = NULL;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\t \n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && !prm->ss)\n\t\tmemset(prm->rbuf, 0, prm->max_psize * params->req_number);\n\n\treturn err;\n}\n\nstatic snd_pcm_uframes_t uac_pcm_pointer(struct snd_pcm_substream *substream)\n{\n\tstruct snd_uac_chip *uac = snd_pcm_substream_chip(substream);\n\tstruct uac_rtd_params *prm;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\treturn bytes_to_frames(substream->runtime, prm->hw_ptr);\n}\n\nstatic u64 uac_ssize_to_fmt(int ssize)\n{\n\tu64 ret;\n\n\tswitch (ssize) {\n\tcase 3:\n\t\tret = SNDRV_PCM_FMTBIT_S24_3LE;\n\t\tbreak;\n\tcase 4:\n\t\tret = SNDRV_PCM_FMTBIT_S32_LE;\n\t\tbreak;\n\tdefault:\n\t\tret = SNDRV_PCM_FMTBIT_S16_LE;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int uac_pcm_open(struct snd_pcm_substream *substream)\n{\n\tstruct snd_uac_chip *uac = snd_pcm_substream_chip(substream);\n\tstruct snd_pcm_runtime *runtime = substream->runtime;\n\tstruct g_audio *audio_dev;\n\tstruct uac_params *params;\n\tstruct uac_rtd_params *prm;\n\tint p_ssize, c_ssize;\n\tint p_chmask, c_chmask;\n\n\taudio_dev = uac->audio_dev;\n\tparams = &audio_dev->params;\n\tp_ssize = params->p_ssize;\n\tc_ssize = params->c_ssize;\n\tp_chmask = params->p_chmask;\n\tc_chmask = params->c_chmask;\n\tuac->p_residue_mil = 0;\n\n\truntime->hw = uac_pcm_hardware;\n\n\tif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\truntime->hw.formats = uac_ssize_to_fmt(p_ssize);\n\t\truntime->hw.channels_min = num_channels(p_chmask);\n\t\tprm = &uac->p_prm;\n\t} else {\n\t\truntime->hw.formats = uac_ssize_to_fmt(c_ssize);\n\t\truntime->hw.channels_min = num_channels(c_chmask);\n\t\tprm = &uac->c_prm;\n\t}\n\n\truntime->hw.period_bytes_min = 2 * prm->max_psize\n\t\t\t\t\t/ runtime->hw.periods_min;\n\truntime->hw.rate_min = prm->srate;\n\truntime->hw.rate_max = runtime->hw.rate_min;\n\truntime->hw.channels_max = runtime->hw.channels_min;\n\n\tsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\n\n\treturn 0;\n}\n\n \nstatic int uac_pcm_null(struct snd_pcm_substream *substream)\n{\n\treturn 0;\n}\n\nstatic const struct snd_pcm_ops uac_pcm_ops = {\n\t.open = uac_pcm_open,\n\t.close = uac_pcm_null,\n\t.trigger = uac_pcm_trigger,\n\t.pointer = uac_pcm_pointer,\n\t.prepare = uac_pcm_null,\n};\n\nstatic inline void free_ep(struct uac_rtd_params *prm, struct usb_ep *ep)\n{\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev;\n\tstruct uac_params *params;\n\tint i;\n\n\tif (!prm->ep_enabled)\n\t\treturn;\n\n\taudio_dev = uac->audio_dev;\n\tparams = &audio_dev->params;\n\n\tfor (i = 0; i < params->req_number; i++) {\n\t\tif (prm->reqs[i]) {\n\t\t\tif (usb_ep_dequeue(ep, prm->reqs[i]))\n\t\t\t\tusb_ep_free_request(ep, prm->reqs[i]);\n\t\t\t \n\n\t\t\tprm->reqs[i] = NULL;\n\t\t}\n\t}\n\n\tprm->ep_enabled = false;\n\n\tif (usb_ep_disable(ep))\n\t\tdev_err(uac->card->dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n}\n\nstatic inline void free_ep_fback(struct uac_rtd_params *prm, struct usb_ep *ep)\n{\n\tstruct snd_uac_chip *uac = prm->uac;\n\n\tif (!prm->fb_ep_enabled)\n\t\treturn;\n\n\tif (prm->req_fback) {\n\t\tif (usb_ep_dequeue(ep, prm->req_fback)) {\n\t\t\tkfree(prm->req_fback->buf);\n\t\t\tusb_ep_free_request(ep, prm->req_fback);\n\t\t}\n\t\tprm->req_fback = NULL;\n\t}\n\n\tprm->fb_ep_enabled = false;\n\n\tif (usb_ep_disable(ep))\n\t\tdev_err(uac->card->dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n}\n\nstatic void set_active(struct uac_rtd_params *prm, bool active)\n{\n\t \n\tstruct snd_kcontrol *kctl = prm->snd_kctl_rate;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tif (prm->active != active) {\n\t\tprm->active = active;\n\t\tsnd_ctl_notify(prm->uac->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&kctl->id);\n\t}\n\tspin_unlock_irqrestore(&prm->lock, flags);\n}\n\nint u_audio_set_capture_srate(struct g_audio *audio_dev, int srate)\n{\n\tstruct uac_params *params = &audio_dev->params;\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tint i;\n\tunsigned long flags;\n\n\tdev_dbg(&audio_dev->gadget->dev, \"%s: srate %d\\n\", __func__, srate);\n\tprm = &uac->c_prm;\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (params->c_srates[i] == srate) {\n\t\t\tspin_lock_irqsave(&prm->lock, flags);\n\t\t\tprm->srate = srate;\n\t\t\tspin_unlock_irqrestore(&prm->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tif (params->c_srates[i] == 0)\n\t\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(u_audio_set_capture_srate);\n\nint u_audio_get_capture_srate(struct g_audio *audio_dev, u32 *val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\n\tprm = &uac->c_prm;\n\tspin_lock_irqsave(&prm->lock, flags);\n\t*val = prm->srate;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_get_capture_srate);\n\nint u_audio_set_playback_srate(struct g_audio *audio_dev, int srate)\n{\n\tstruct uac_params *params = &audio_dev->params;\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tint i;\n\tunsigned long flags;\n\n\tdev_dbg(&audio_dev->gadget->dev, \"%s: srate %d\\n\", __func__, srate);\n\tprm = &uac->p_prm;\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (params->p_srates[i] == srate) {\n\t\t\tspin_lock_irqsave(&prm->lock, flags);\n\t\t\tprm->srate = srate;\n\t\t\tspin_unlock_irqrestore(&prm->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tif (params->p_srates[i] == 0)\n\t\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(u_audio_set_playback_srate);\n\nint u_audio_get_playback_srate(struct g_audio *audio_dev, u32 *val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\n\tprm = &uac->p_prm;\n\tspin_lock_irqsave(&prm->lock, flags);\n\t*val = prm->srate;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_get_playback_srate);\n\nint u_audio_start_capture(struct g_audio *audio_dev)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct usb_gadget *gadget = audio_dev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tstruct usb_request *req, *req_fback;\n\tstruct usb_ep *ep, *ep_fback;\n\tstruct uac_rtd_params *prm;\n\tstruct uac_params *params = &audio_dev->params;\n\tint req_len, i;\n\n\tprm = &uac->c_prm;\n\tdev_dbg(dev, \"start capture with rate %d\\n\", prm->srate);\n\tep = audio_dev->out_ep;\n\tconfig_ep_by_speed(gadget, &audio_dev->func, ep);\n\treq_len = ep->maxpacket;\n\n\tprm->ep_enabled = true;\n\tusb_ep_enable(ep);\n\n\tfor (i = 0; i < params->req_number; i++) {\n\t\tif (!prm->reqs[i]) {\n\t\t\treq = usb_ep_alloc_request(ep, GFP_ATOMIC);\n\t\t\tif (req == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprm->reqs[i] = req;\n\n\t\t\treq->zero = 0;\n\t\t\treq->context = prm;\n\t\t\treq->length = req_len;\n\t\t\treq->complete = u_audio_iso_complete;\n\t\t\treq->buf = prm->rbuf + i * ep->maxpacket;\n\t\t}\n\n\t\tif (usb_ep_queue(ep, prm->reqs[i], GFP_ATOMIC))\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t}\n\n\tset_active(&uac->c_prm, true);\n\n\tep_fback = audio_dev->in_ep_fback;\n\tif (!ep_fback)\n\t\treturn 0;\n\n\t \n\tconfig_ep_by_speed(gadget, &audio_dev->func, ep_fback);\n\tprm->fb_ep_enabled = true;\n\tusb_ep_enable(ep_fback);\n\treq_len = ep_fback->maxpacket;\n\n\treq_fback = usb_ep_alloc_request(ep_fback, GFP_ATOMIC);\n\tif (req_fback == NULL)\n\t\treturn -ENOMEM;\n\n\tprm->req_fback = req_fback;\n\treq_fback->zero = 0;\n\treq_fback->context = prm;\n\treq_fback->length = req_len;\n\treq_fback->complete = u_audio_iso_fback_complete;\n\n\treq_fback->buf = kzalloc(req_len, GFP_ATOMIC);\n\tif (!req_fback->buf)\n\t\treturn -ENOMEM;\n\n\t \n\tprm->pitch = 1000000;\n\tu_audio_set_fback_frequency(audio_dev->gadget->speed, ep,\n\t\t\t\t    prm->srate, prm->pitch,\n\t\t\t\t    req_fback->buf);\n\n\tif (usb_ep_queue(ep_fback, req_fback, GFP_ATOMIC))\n\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_start_capture);\n\nvoid u_audio_stop_capture(struct g_audio *audio_dev)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\n\tset_active(&uac->c_prm, false);\n\tif (audio_dev->in_ep_fback)\n\t\tfree_ep_fback(&uac->c_prm, audio_dev->in_ep_fback);\n\tfree_ep(&uac->c_prm, audio_dev->out_ep);\n}\nEXPORT_SYMBOL_GPL(u_audio_stop_capture);\n\nint u_audio_start_playback(struct g_audio *audio_dev)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct usb_gadget *gadget = audio_dev->gadget;\n\tstruct device *dev = &gadget->dev;\n\tstruct usb_request *req;\n\tstruct usb_ep *ep;\n\tstruct uac_rtd_params *prm;\n\tstruct uac_params *params = &audio_dev->params;\n\tunsigned int factor;\n\tconst struct usb_endpoint_descriptor *ep_desc;\n\tint req_len, i;\n\tunsigned int p_pktsize;\n\n\tprm = &uac->p_prm;\n\tdev_dbg(dev, \"start playback with rate %d\\n\", prm->srate);\n\tep = audio_dev->in_ep;\n\tconfig_ep_by_speed(gadget, &audio_dev->func, ep);\n\n\tep_desc = ep->desc;\n\t \n\tprm->pitch = 1000000;\n\n\t \n\tif (gadget->speed == USB_SPEED_FULL)\n\t\tfactor = 1000;\n\telse\n\t\tfactor = 8000;\n\n\t \n\tuac->p_framesize = params->p_ssize *\n\t\t\t    num_channels(params->p_chmask);\n\tuac->p_interval = factor / (1 << (ep_desc->bInterval - 1));\n\tp_pktsize = min_t(unsigned int,\n\t\t\t\tuac->p_framesize *\n\t\t\t\t\t(prm->srate / uac->p_interval),\n\t\t\t\tep->maxpacket);\n\n\treq_len = p_pktsize;\n\tuac->p_residue_mil = 0;\n\n\tprm->ep_enabled = true;\n\tusb_ep_enable(ep);\n\n\tfor (i = 0; i < params->req_number; i++) {\n\t\tif (!prm->reqs[i]) {\n\t\t\treq = usb_ep_alloc_request(ep, GFP_ATOMIC);\n\t\t\tif (req == NULL)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprm->reqs[i] = req;\n\n\t\t\treq->zero = 0;\n\t\t\treq->context = prm;\n\t\t\treq->length = req_len;\n\t\t\treq->complete = u_audio_iso_complete;\n\t\t\treq->buf = prm->rbuf + i * ep->maxpacket;\n\t\t}\n\n\t\tif (usb_ep_queue(ep, prm->reqs[i], GFP_ATOMIC))\n\t\t\tdev_err(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t}\n\n\tset_active(&uac->p_prm, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_start_playback);\n\nvoid u_audio_stop_playback(struct g_audio *audio_dev)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\n\tset_active(&uac->p_prm, false);\n\tfree_ep(&uac->p_prm, audio_dev->in_ep);\n}\nEXPORT_SYMBOL_GPL(u_audio_stop_playback);\n\nvoid u_audio_suspend(struct g_audio *audio_dev)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\n\tset_active(&uac->p_prm, false);\n\tset_active(&uac->c_prm, false);\n}\nEXPORT_SYMBOL_GPL(u_audio_suspend);\n\nint u_audio_get_volume(struct g_audio *audio_dev, int playback, s16 *val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\n\tif (playback)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\t*val = prm->volume;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_get_volume);\n\nint u_audio_set_volume(struct g_audio *audio_dev, int playback, s16 val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\tint change = 0;\n\n\tif (playback)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tval = clamp(val, prm->volume_min, prm->volume_max);\n\tif (prm->volume != val) {\n\t\tprm->volume = val;\n\t\tchange = 1;\n\t}\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\tif (change)\n\t\tsnd_ctl_notify(uac->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t\t&prm->snd_kctl_volume->id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_set_volume);\n\nint u_audio_get_mute(struct g_audio *audio_dev, int playback, int *val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\n\tif (playback)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\t*val = prm->mute;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_get_mute);\n\nint u_audio_set_mute(struct g_audio *audio_dev, int playback, int val)\n{\n\tstruct snd_uac_chip *uac = audio_dev->uac;\n\tstruct uac_rtd_params *prm;\n\tunsigned long flags;\n\tint change = 0;\n\tint mute;\n\n\tif (playback)\n\t\tprm = &uac->p_prm;\n\telse\n\t\tprm = &uac->c_prm;\n\n\tmute = val ? 1 : 0;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tif (prm->mute != mute) {\n\t\tprm->mute = mute;\n\t\tchange = 1;\n\t}\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\tif (change)\n\t\tsnd_ctl_notify(uac->card, SNDRV_CTL_EVENT_MASK_VALUE,\n\t\t\t       &prm->snd_kctl_mute->id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(u_audio_set_mute);\n\n\nstatic int u_audio_pitch_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tstruct uac_params *params = &audio_dev->params;\n\tunsigned int pitch_min, pitch_max;\n\n\tpitch_min = (1000 - FBACK_SLOW_MAX) * 1000;\n\tpitch_max = (1000 + params->fb_max) * 1000;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = pitch_min;\n\tuinfo->value.integer.max = pitch_max;\n\tuinfo->value.integer.step = 1;\n\treturn 0;\n}\n\nstatic int u_audio_pitch_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = prm->pitch;\n\n\treturn 0;\n}\n\nstatic int u_audio_pitch_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tstruct uac_params *params = &audio_dev->params;\n\tunsigned int val;\n\tunsigned int pitch_min, pitch_max;\n\tint change = 0;\n\n\tpitch_min = (1000 - FBACK_SLOW_MAX) * 1000;\n\tpitch_max = (1000 + params->fb_max) * 1000;\n\n\tval = ucontrol->value.integer.value[0];\n\n\tif (val < pitch_min)\n\t\tval = pitch_min;\n\tif (val > pitch_max)\n\t\tval = pitch_max;\n\n\tif (prm->pitch != val) {\n\t\tprm->pitch = val;\n\t\tchange = 1;\n\t}\n\n\treturn change;\n}\n\nstatic int u_audio_mute_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max = 1;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int u_audio_mute_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tucontrol->value.integer.value[0] = !prm->mute;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\treturn 0;\n}\n\nstatic int u_audio_mute_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tunsigned int val;\n\tunsigned long flags;\n\tint change = 0;\n\n\tval = !ucontrol->value.integer.value[0];\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tif (val != prm->mute) {\n\t\tprm->mute = val;\n\t\tchange = 1;\n\t}\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\tif (change && audio_dev->notify)\n\t\taudio_dev->notify(audio_dev, prm->fu_id, UAC_FU_MUTE);\n\n\treturn change;\n}\n\n \nstatic int u_audio_volume_tlv(struct snd_kcontrol *kcontrol, int op_flag,\n\t\t\t unsigned int size, unsigned int __user *_tlv)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tDECLARE_TLV_DB_MINMAX(scale, 0, 0);\n\n\tif (size < sizeof(scale))\n\t\treturn -ENOMEM;\n\n\t \n\tscale[2] = (prm->volume_min * 100) / 256;\n\tscale[3] = (prm->volume_max * 100) / 256;\n\tif (copy_to_user(_tlv, scale, sizeof(scale)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int u_audio_volume_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_info *uinfo)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = 0;\n\tuinfo->value.integer.max =\n\t\t(prm->volume_max - prm->volume_min + prm->volume_res - 1)\n\t\t/ prm->volume_res;\n\tuinfo->value.integer.step = 1;\n\n\treturn 0;\n}\n\nstatic int u_audio_volume_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t   struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tucontrol->value.integer.value[0] =\n\t\t\t(prm->volume - prm->volume_min) / prm->volume_res;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\treturn 0;\n}\n\nstatic int u_audio_volume_put(struct snd_kcontrol *kcontrol,\n\t\t\t\t  struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tunsigned int val;\n\ts16 volume;\n\tunsigned long flags;\n\tint change = 0;\n\n\tval = ucontrol->value.integer.value[0];\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tvolume = (val * prm->volume_res) + prm->volume_min;\n\tvolume = clamp(volume, prm->volume_min, prm->volume_max);\n\tif (volume != prm->volume) {\n\t\tprm->volume = volume;\n\t\tchange = 1;\n\t}\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\n\tif (change && audio_dev->notify)\n\t\taudio_dev->notify(audio_dev, prm->fu_id, UAC_FU_VOLUME);\n\n\treturn change;\n}\n\nstatic int get_max_srate(const int *srates)\n{\n\tint i, max_srate = 0;\n\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (srates[i] == 0)\n\t\t\tbreak;\n\t\tif (srates[i] > max_srate)\n\t\t\tmax_srate = srates[i];\n\t}\n\treturn max_srate;\n}\n\nstatic int get_min_srate(const int *srates)\n{\n\tint i, min_srate = INT_MAX;\n\n\tfor (i = 0; i < UAC_MAX_RATES; i++) {\n\t\tif (srates[i] == 0)\n\t\t\tbreak;\n\t\tif (srates[i] < min_srate)\n\t\t\tmin_srate = srates[i];\n\t}\n\treturn min_srate;\n}\n\nstatic int u_audio_rate_info(struct snd_kcontrol *kcontrol,\n\t\t\t\tstruct snd_ctl_elem_info *uinfo)\n{\n\tconst int *srates;\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tstruct snd_uac_chip *uac = prm->uac;\n\tstruct g_audio *audio_dev = uac->audio_dev;\n\tstruct uac_params *params = &audio_dev->params;\n\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\n\tif (prm == &uac->c_prm)\n\t\tsrates = params->c_srates;\n\telse\n\t\tsrates = params->p_srates;\n\tuinfo->value.integer.min = get_min_srate(srates);\n\tuinfo->value.integer.max = get_max_srate(srates);\n\treturn 0;\n}\n\nstatic int u_audio_rate_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t\t\t struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct uac_rtd_params *prm = snd_kcontrol_chip(kcontrol);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&prm->lock, flags);\n\tif (prm->active)\n\t\tucontrol->value.integer.value[0] = prm->srate;\n\telse\n\t\t \n\t\tucontrol->value.integer.value[0] = 0;\n\tspin_unlock_irqrestore(&prm->lock, flags);\n\treturn 0;\n}\n\nstatic struct snd_kcontrol_new u_audio_controls[]  = {\n  [UAC_FBACK_CTRL] {\n    .iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n    .name =         \"Capture Pitch 1000000\",\n    .info =         u_audio_pitch_info,\n    .get =          u_audio_pitch_get,\n    .put =          u_audio_pitch_put,\n  },\n\t[UAC_P_PITCH_CTRL] {\n\t\t.iface =        SNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =         \"Playback Pitch 1000000\",\n\t\t.info =         u_audio_pitch_info,\n\t\t.get =          u_audio_pitch_get,\n\t\t.put =          u_audio_pitch_put,\n\t},\n  [UAC_MUTE_CTRL] {\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"\",  \n\t\t.info =\t\tu_audio_mute_info,\n\t\t.get =\t\tu_audio_mute_get,\n\t\t.put =\t\tu_audio_mute_put,\n\t},\n\t[UAC_VOLUME_CTRL] {\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_MIXER,\n\t\t.name =\t\t\"\",  \n\t\t.info =\t\tu_audio_volume_info,\n\t\t.get =\t\tu_audio_volume_get,\n\t\t.put =\t\tu_audio_volume_put,\n\t},\n\t[UAC_RATE_CTRL] {\n\t\t.iface =\tSNDRV_CTL_ELEM_IFACE_PCM,\n\t\t.name =\t\t\"\",  \n\t\t.access =\tSNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t\t.info =\t\tu_audio_rate_info,\n\t\t.get =\t\tu_audio_rate_get,\n\t},\n};\n\nint g_audio_setup(struct g_audio *g_audio, const char *pcm_name,\n\t\t\t\t\tconst char *card_name)\n{\n\tstruct snd_uac_chip *uac;\n\tstruct snd_card *card;\n\tstruct snd_pcm *pcm;\n\tstruct snd_kcontrol *kctl;\n\tstruct uac_params *params;\n\tint p_chmask, c_chmask;\n\tint i, err;\n\n\tif (!g_audio)\n\t\treturn -EINVAL;\n\n\tuac = kzalloc(sizeof(*uac), GFP_KERNEL);\n\tif (!uac)\n\t\treturn -ENOMEM;\n\tg_audio->uac = uac;\n\tuac->audio_dev = g_audio;\n\n\tparams = &g_audio->params;\n\tp_chmask = params->p_chmask;\n\tc_chmask = params->c_chmask;\n\n\tif (c_chmask) {\n\t\tstruct uac_rtd_params *prm = &uac->c_prm;\n\n\t\tspin_lock_init(&prm->lock);\n\t\tuac->c_prm.uac = uac;\n\t\tprm->max_psize = g_audio->out_ep_maxpsize;\n\t\tprm->srate = params->c_srates[0];\n\n\t\tprm->reqs = kcalloc(params->req_number,\n\t\t\t\t    sizeof(struct usb_request *),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!prm->reqs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tprm->rbuf = kcalloc(params->req_number, prm->max_psize,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!prm->rbuf) {\n\t\t\tprm->max_psize = 0;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (p_chmask) {\n\t\tstruct uac_rtd_params *prm = &uac->p_prm;\n\n\t\tspin_lock_init(&prm->lock);\n\t\tuac->p_prm.uac = uac;\n\t\tprm->max_psize = g_audio->in_ep_maxpsize;\n\t\tprm->srate = params->p_srates[0];\n\n\t\tprm->reqs = kcalloc(params->req_number,\n\t\t\t\t    sizeof(struct usb_request *),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!prm->reqs) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tprm->rbuf = kcalloc(params->req_number, prm->max_psize,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!prm->rbuf) {\n\t\t\tprm->max_psize = 0;\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\t \n\terr = snd_card_new(&g_audio->gadget->dev,\n\t\t\t-1, NULL, THIS_MODULE, 0, &card);\n\tif (err < 0)\n\t\tgoto fail;\n\n\tuac->card = card;\n\n\t \n\terr = snd_pcm_new(uac->card, pcm_name, 0,\n\t\t\t       p_chmask ? 1 : 0, c_chmask ? 1 : 0, &pcm);\n\tif (err < 0)\n\t\tgoto snd_fail;\n\n\tstrscpy(pcm->name, pcm_name, sizeof(pcm->name));\n\tpcm->private_data = uac;\n\tuac->pcm = pcm;\n\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &uac_pcm_ops);\n\tsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &uac_pcm_ops);\n\n\t \n\tif ((c_chmask && g_audio->in_ep_fback)\n\t\t\t|| (p_chmask && params->p_fu.id)\n\t\t\t|| (c_chmask && params->c_fu.id))\n\t\tstrscpy(card->mixername, card_name, sizeof(card->driver));\n\n\tif (c_chmask && g_audio->in_ep_fback) {\n\t\tkctl = snd_ctl_new1(&u_audio_controls[UAC_FBACK_CTRL],\n\t\t\t\t    &uac->c_prm);\n\t\tif (!kctl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto snd_fail;\n\t\t}\n\n\t\tkctl->id.device = pcm->device;\n\t\tkctl->id.subdevice = 0;\n\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto snd_fail;\n\t}\n\n\tif (p_chmask) {\n\t\tkctl = snd_ctl_new1(&u_audio_controls[UAC_P_PITCH_CTRL],\n\t\t\t\t    &uac->p_prm);\n\t\tif (!kctl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto snd_fail;\n\t\t}\n\n\t\tkctl->id.device = pcm->device;\n\t\tkctl->id.subdevice = 0;\n\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto snd_fail;\n\t}\n\n\tfor (i = 0; i <= SNDRV_PCM_STREAM_LAST; i++) {\n\t\tstruct uac_rtd_params *prm;\n\t\tstruct uac_fu_params *fu;\n\t\tchar ctrl_name[24];\n\t\tchar *direction;\n\n\t\tif (!pcm->streams[i].substream_count)\n\t\t\tcontinue;\n\n\t\tif (i == SNDRV_PCM_STREAM_PLAYBACK) {\n\t\t\tprm = &uac->p_prm;\n\t\t\tfu = &params->p_fu;\n\t\t\tdirection = \"Playback\";\n\t\t} else {\n\t\t\tprm = &uac->c_prm;\n\t\t\tfu = &params->c_fu;\n\t\t\tdirection = \"Capture\";\n\t\t}\n\n\t\tprm->fu_id = fu->id;\n\n\t\tif (fu->mute_present) {\n\t\t\tsnprintf(ctrl_name, sizeof(ctrl_name),\n\t\t\t\t\t\"PCM %s Switch\", direction);\n\n\t\t\tu_audio_controls[UAC_MUTE_CTRL].name = ctrl_name;\n\n\t\t\tkctl = snd_ctl_new1(&u_audio_controls[UAC_MUTE_CTRL],\n\t\t\t\t\t    prm);\n\t\t\tif (!kctl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto snd_fail;\n\t\t\t}\n\n\t\t\tkctl->id.device = pcm->device;\n\t\t\tkctl->id.subdevice = 0;\n\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\tgoto snd_fail;\n\t\t\tprm->snd_kctl_mute = kctl;\n\t\t\tprm->mute = 0;\n\t\t}\n\n\t\tif (fu->volume_present) {\n\t\t\tsnprintf(ctrl_name, sizeof(ctrl_name),\n\t\t\t\t\t\"PCM %s Volume\", direction);\n\n\t\t\tu_audio_controls[UAC_VOLUME_CTRL].name = ctrl_name;\n\n\t\t\tkctl = snd_ctl_new1(&u_audio_controls[UAC_VOLUME_CTRL],\n\t\t\t\t\t    prm);\n\t\t\tif (!kctl) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto snd_fail;\n\t\t\t}\n\n\t\t\tkctl->id.device = pcm->device;\n\t\t\tkctl->id.subdevice = 0;\n\n\n\t\t\tkctl->tlv.c = u_audio_volume_tlv;\n\t\t\tkctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ |\n\t\t\t\t\tSNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;\n\n\t\t\terr = snd_ctl_add(card, kctl);\n\t\t\tif (err < 0)\n\t\t\t\tgoto snd_fail;\n\t\t\tprm->snd_kctl_volume = kctl;\n\t\t\tprm->volume = fu->volume_max;\n\t\t\tprm->volume_max = fu->volume_max;\n\t\t\tprm->volume_min = fu->volume_min;\n\t\t\tprm->volume_res = fu->volume_res;\n\t\t}\n\n\t\t \n\t\tsnprintf(ctrl_name, sizeof(ctrl_name),\n\t\t\t\t\"%s Rate\", direction);\n\t\tu_audio_controls[UAC_RATE_CTRL].name = ctrl_name;\n\n\t\tkctl = snd_ctl_new1(&u_audio_controls[UAC_RATE_CTRL], prm);\n\t\tif (!kctl) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto snd_fail;\n\t\t}\n\n\t\tkctl->id.device = pcm->device;\n\t\tkctl->id.subdevice = 0;\n\n\t\terr = snd_ctl_add(card, kctl);\n\t\tif (err < 0)\n\t\t\tgoto snd_fail;\n\t\tprm->snd_kctl_rate = kctl;\n\t}\n\n\tstrscpy(card->driver, card_name, sizeof(card->driver));\n\tstrscpy(card->shortname, card_name, sizeof(card->shortname));\n\tsprintf(card->longname, \"%s %i\", card_name, card->dev->id);\n\n\tsnd_pcm_set_managed_buffer_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\n\t\t\t\t       NULL, 0, BUFF_SIZE_MAX);\n\n\terr = snd_card_register(card);\n\n\tif (!err)\n\t\treturn 0;\n\nsnd_fail:\n\tsnd_card_free(card);\nfail:\n\tkfree(uac->p_prm.reqs);\n\tkfree(uac->c_prm.reqs);\n\tkfree(uac->p_prm.rbuf);\n\tkfree(uac->c_prm.rbuf);\n\tkfree(uac);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(g_audio_setup);\n\nvoid g_audio_cleanup(struct g_audio *g_audio)\n{\n\tstruct snd_uac_chip *uac;\n\tstruct snd_card *card;\n\n\tif (!g_audio || !g_audio->uac)\n\t\treturn;\n\n\tuac = g_audio->uac;\n\tcard = uac->card;\n\tif (card)\n\t\tsnd_card_free_when_closed(card);\n\n\tkfree(uac->p_prm.reqs);\n\tkfree(uac->c_prm.reqs);\n\tkfree(uac->p_prm.rbuf);\n\tkfree(uac->c_prm.rbuf);\n\tkfree(uac);\n}\nEXPORT_SYMBOL_GPL(g_audio_cleanup);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB gadget \\\"ALSA sound card\\\" utilities\");\nMODULE_AUTHOR(\"Ruslan Bilovol\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}