{
  "module_name": "f_midi2.c",
  "hash_id": "06ac622c0afdfd1ec96e3e6ba9644598c685d4e4db275d10a75e394c1d2a18a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_midi2.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <sound/core.h>\n#include <sound/control.h>\n#include <sound/ump.h>\n#include <sound/ump_msg.h>\n#include <sound/ump_convert.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/audio.h>\n#include <linux/usb/midi-v2.h>\n\n#include \"u_f.h\"\n#include \"u_midi2.h\"\n\nstruct f_midi2;\nstruct f_midi2_ep;\nstruct f_midi2_usb_ep;\n\n \nstruct f_midi2_req_ctx {\n\tstruct f_midi2_usb_ep *usb_ep;\t \n\tunsigned int index;\t\t \n\tstruct usb_request *req;\t \n};\n\n \nstruct f_midi2_usb_ep {\n\tstruct f_midi2 *card;\t\t \n\tstruct f_midi2_ep *ep;\t\t \n\tstruct usb_ep *usb_ep;\t\t \n\tvoid (*complete)(struct usb_ep *usb_ep, struct usb_request *req);\n\tunsigned long free_reqs;\t \n\tunsigned int num_reqs;\t\t \n\tstruct f_midi2_req_ctx *reqs;\t \n};\n\n \nstruct f_midi2_block {\n\tstruct f_midi2_block_info info;\t \n\tstruct snd_ump_block *fb;\t \n\tunsigned int gtb_id;\t\t \n\tunsigned int string_id;\t\t \n};\n\n \nstruct f_midi2_midi1_port {\n\tunsigned int pending;  \n\tu8 buf[32];\t \n\tu8 state;\t \n\tu8 data[2];\t \n};\n\n \nenum {\n\tSTATE_INITIAL = 0,\t \n\tSTATE_1PARAM,\n\tSTATE_2PARAM_1,\n\tSTATE_2PARAM_2,\n\tSTATE_SYSEX_0,\n\tSTATE_SYSEX_1,\n\tSTATE_SYSEX_2,\n\tSTATE_REAL_TIME,\n\tSTATE_FINISHED,\t\t \n};\n\n \nstruct f_midi2_ep {\n\tstruct snd_ump_endpoint *ump;\t \n\tstruct f_midi2 *card;\t\t \n\n\tstruct f_midi2_ep_info info;\t \n\tunsigned int num_blks;\t\t \n\tstruct f_midi2_block blks[SNDRV_UMP_MAX_BLOCKS];\t \n\n\tstruct f_midi2_usb_ep ep_in;\t \n\tstruct f_midi2_usb_ep ep_out;\t \n\n\tu8 in_group_to_cable[SNDRV_UMP_MAX_GROUPS];  \n};\n\n \nenum {\n\tSTR_IFACE = 0,\n\tSTR_GTB1 = 1,\n};\n\n \n#define gtb_to_str_id(id)\t(STR_GTB1 + (id) - 1)\n\n \nstruct midi1_cable_mapping {\n\tstruct f_midi2_ep *ep;\n\tunsigned char block;\n\tunsigned char group;\n};\n\n \nenum {\n\tMIDI_OP_MODE_UNSET,\t \n\tMIDI_OP_MODE_MIDI1,\t \n\tMIDI_OP_MODE_MIDI2,\t \n};\n\n \nstruct f_midi2 {\n\tstruct usb_function func;\n\tstruct usb_gadget *gadget;\n\tstruct snd_card *card;\n\n\t \n\tstruct f_midi2_usb_ep midi1_ep_in;\n\tstruct f_midi2_usb_ep midi1_ep_out;\n\n\t \n\tunsigned int num_midi1_in;\n\tunsigned int num_midi1_out;\n\n\t \n\tstruct f_midi2_midi1_port midi1_port[MAX_CABLES];\n\t \n\tstruct ump_cvt_to_ump midi1_ump_cvt;\n\t \n\tstruct midi1_cable_mapping in_cable_mapping[MAX_CABLES];\n\tstruct midi1_cable_mapping out_cable_mapping[MAX_CABLES];\n\n\tint midi_if;\t\t\t \n\tint operation_mode;\t\t \n\n\tspinlock_t queue_lock;\n\n\tstruct f_midi2_card_info info;\t \n\n\tunsigned int num_eps;\n\tstruct f_midi2_ep midi2_eps[MAX_UMP_EPS];\n\n\tunsigned int total_blocks;\t \n\tstruct usb_string *string_defs;\n\tstruct usb_string *strings;\n};\n\n#define func_to_midi2(f)\tcontainer_of(f, struct f_midi2, func)\n\n \nstatic const char *ump_ep_name(const struct f_midi2_ep *ep)\n{\n\treturn ep->info.ep_name ? ep->info.ep_name : \"MIDI 2.0 Gadget\";\n}\n\n \nstatic const char *ump_product_id(const struct f_midi2_ep *ep)\n{\n\treturn ep->info.product_id ? ep->info.product_id : \"Unique Product ID\";\n}\n\n \nstatic const char *ump_fb_name(const struct f_midi2_block_info *info)\n{\n\treturn info->name ? info->name : \"MIDI 2.0 Gadget I/O\";\n}\n\n \n \nstatic struct usb_ms20_gr_trm_block_header_descriptor gtb_header_desc = {\n\t.bLength =\t\tsizeof(gtb_header_desc),\n\t.bDescriptorType =\tUSB_DT_CS_GR_TRM_BLOCK,\n\t.bDescriptorSubtype =\tUSB_MS_GR_TRM_BLOCK_HEADER,\n\t.wTotalLength =\t\t__cpu_to_le16(0x12), \n};\n\n \nstatic struct usb_ms20_gr_trm_block_descriptor gtb_desc = {\n\t.bLength =\t\tsizeof(gtb_desc),\n\t.bDescriptorType =\tUSB_DT_CS_GR_TRM_BLOCK,\n\t.bDescriptorSubtype =\tUSB_MS_GR_TRM_BLOCK,\n\t.bGrpTrmBlkID =\t\t0x01,\n\t.bGrpTrmBlkType =\tUSB_MS_GR_TRM_BLOCK_TYPE_BIDIRECTIONAL,\n\t.nGroupTrm =\t\t0x00,\n\t.nNumGroupTrm =\t\t1,\n\t.iBlockItem =\t\t0,\n\t.bMIDIProtocol =\tUSB_MS_MIDI_PROTO_1_0_64,\n\t.wMaxInputBandwidth =\t0,\n\t.wMaxOutputBandwidth =\t0,\n};\n\nDECLARE_USB_MIDI_OUT_JACK_DESCRIPTOR(1);\nDECLARE_USB_MS_ENDPOINT_DESCRIPTOR(16);\nDECLARE_UAC_AC_HEADER_DESCRIPTOR(1);\nDECLARE_USB_MS20_ENDPOINT_DESCRIPTOR(32);\n\n#define EP_MAX_PACKET_INT\t8\n\n \nstatic struct usb_interface_descriptor midi2_audio_if_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bInterfaceNumber =\t0, \n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n\t.bInterfaceProtocol =\t0,\n\t.iInterface =\t\t0,\n};\n\nstatic struct uac1_ac_header_descriptor_1 midi2_audio_class_desc = {\n\t.bLength =\t\t0x09,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\t0x01,\n\t.bcdADC =\t\t__cpu_to_le16(0x0100),\n\t.wTotalLength =\t\t__cpu_to_le16(0x0009),\n\t.bInCollection =\t0x01,\n\t.baInterfaceNr =\t{ 0x01 }, \n};\n\n \nstatic struct usb_interface_descriptor midi2_midi1_if_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bInterfaceNumber =\t0, \n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t2, \n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_MIDISTREAMING,\n\t.bInterfaceProtocol =\t0,\n\t.iInterface =\t\t0, \n};\n\nstatic struct usb_ms_header_descriptor midi2_midi1_class_desc = {\n\t.bLength =\t\t0x07,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdMSC =\t\t__cpu_to_le16(0x0100),\n\t.wTotalLength =\t\t__cpu_to_le16(0x41), \n};\n\n \nstatic struct usb_endpoint_descriptor midi2_midi1_ep_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT | 0, \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor midi2_midi1_ep_out_ss_comp_desc = {\n\t.bLength                = sizeof(midi2_midi1_ep_out_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_ms_endpoint_descriptor_16 midi2_midi1_ep_out_class_desc = {\n\t.bLength =\t\t0x05, \n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t.bNumEmbMIDIJack =\t1,\n\t.baAssocJackID =\t{ 0x01 },\n};\n\n \nstatic struct usb_endpoint_descriptor midi2_midi1_ep_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN | 0, \n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_ss_ep_comp_descriptor midi2_midi1_ep_in_ss_comp_desc = {\n\t.bLength                = sizeof(midi2_midi1_ep_in_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_ms_endpoint_descriptor_16 midi2_midi1_ep_in_class_desc = {\n\t.bLength =\t\t0x05, \n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUSB_MS_GENERAL,\n\t.bNumEmbMIDIJack =\t1,\n\t.baAssocJackID =\t{ 0x03 },\n};\n\n \nstatic struct usb_interface_descriptor midi2_midi2_if_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bInterfaceNumber =\t0, \n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t2, \n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_MIDISTREAMING,\n\t.bInterfaceProtocol =\t0,\n\t.iInterface =\t\t0, \n};\n\nstatic struct usb_ms_header_descriptor midi2_midi2_class_desc = {\n\t.bLength =\t\t0x07,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUSB_MS_HEADER,\n\t.bcdMSC =\t\t__cpu_to_le16(0x0200),\n\t.wTotalLength =\t\t__cpu_to_le16(0x07),\n};\n\n \nstatic struct usb_endpoint_descriptor midi2_midi2_ep_out_desc[MAX_UMP_EPS];\n\nstatic struct usb_ss_ep_comp_descriptor midi2_midi2_ep_out_ss_comp_desc = {\n\t.bLength                = sizeof(midi2_midi1_ep_out_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_ms20_endpoint_descriptor_32 midi2_midi2_ep_out_class_desc[MAX_UMP_EPS];\n\n \nstatic struct usb_endpoint_descriptor midi2_midi2_ep_in_desc[MAX_UMP_EPS];\n\nstatic struct usb_ss_ep_comp_descriptor midi2_midi2_ep_in_ss_comp_desc = {\n\t.bLength                = sizeof(midi2_midi2_ep_in_ss_comp_desc),\n\t.bDescriptorType        = USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_ms20_endpoint_descriptor_32 midi2_midi2_ep_in_class_desc[MAX_UMP_EPS];\n\n \nstatic void *midi2_audio_descs[] = {\n\t&midi2_audio_if_desc,\n\t&midi2_audio_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi1_descs[] = {\n\t&midi2_midi1_if_desc,\n\t&midi2_midi1_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi1_ep_out_descs[] = {\n\t&midi2_midi1_ep_out_desc,\n\t&midi2_midi1_ep_out_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi1_ep_in_descs[] = {\n\t&midi2_midi1_ep_in_desc,\n\t&midi2_midi1_ep_in_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi1_ep_out_ss_descs[] = {\n\t&midi2_midi1_ep_out_desc,\n\t&midi2_midi1_ep_out_ss_comp_desc,\n\t&midi2_midi1_ep_out_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi1_ep_in_ss_descs[] = {\n\t&midi2_midi1_ep_in_desc,\n\t&midi2_midi1_ep_in_ss_comp_desc,\n\t&midi2_midi1_ep_in_class_desc,\n\tNULL\n};\n\nstatic void *midi2_midi2_descs[] = {\n\t&midi2_midi2_if_desc,\n\t&midi2_midi2_class_desc,\n\tNULL\n};\n\n \n\n \nstatic struct usb_request *get_empty_request(struct f_midi2_usb_ep *usb_ep)\n{\n\tstruct usb_request *req = NULL;\n\tunsigned long flags;\n\tint index;\n\n\tspin_lock_irqsave(&usb_ep->card->queue_lock, flags);\n\tif (!usb_ep->free_reqs)\n\t\tgoto unlock;\n\tindex = find_first_bit(&usb_ep->free_reqs, usb_ep->num_reqs);\n\tif (index >= usb_ep->num_reqs)\n\t\tgoto unlock;\n\treq = usb_ep->reqs[index].req;\n\tif (!req)\n\t\tgoto unlock;\n\tclear_bit(index, &usb_ep->free_reqs);\n\treq->length = 0;\n unlock:\n\tspin_unlock_irqrestore(&usb_ep->card->queue_lock, flags);\n\treturn req;\n}\n\n \nstatic void put_empty_request(struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->usb_ep->card->queue_lock, flags);\n\tset_bit(ctx->index, &ctx->usb_ep->free_reqs);\n\tspin_unlock_irqrestore(&ctx->usb_ep->card->queue_lock, flags);\n}\n\n \n\n \nstatic int queue_request_ep_raw(struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tint err;\n\n\treq->complete = ctx->usb_ep->complete;\n\terr = usb_ep_queue(ctx->usb_ep->usb_ep, req, GFP_ATOMIC);\n\tif (err) {\n\t\tput_empty_request(req);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\n \nstatic int queue_request_ep_in(struct usb_request *req)\n{\n\t \n\tcpu_to_le32_array((u32 *)req->buf, req->length >> 2);\n\treturn queue_request_ep_raw(req);\n}\n\n \nstatic int reply_ep_in(struct f_midi2_ep *ep, const void *buf, int len)\n{\n\tstruct f_midi2_usb_ep *usb_ep = &ep->ep_in;\n\tstruct usb_request *req;\n\n\treq = get_empty_request(usb_ep);\n\tif (!req)\n\t\treturn -ENOSPC;\n\n\treq->length = len;\n\tmemcpy(req->buf, buf, len);\n\treturn queue_request_ep_in(req);\n}\n\n \nstatic void reply_ump_stream_ep_info(struct f_midi2_ep *ep)\n{\n\tstruct snd_ump_stream_msg_ep_info rep = {\n\t\t.type = UMP_MSG_TYPE_STREAM,\n\t\t.status = UMP_STREAM_MSG_STATUS_EP_INFO,\n\t\t.ump_version_major = 0x01,\n\t\t.ump_version_minor = 0x01,\n\t\t.num_function_blocks = ep->num_blks,\n\t\t.static_function_block = !!ep->card->info.static_block,\n\t\t.protocol = (UMP_STREAM_MSG_EP_INFO_CAP_MIDI1 |\n\t\t\t     UMP_STREAM_MSG_EP_INFO_CAP_MIDI2) >> 8,\n\t};\n\n\treply_ep_in(ep, &rep, sizeof(rep));\n}\n\n \nstatic void reply_ump_stream_ep_device(struct f_midi2_ep *ep)\n{\n\tstruct snd_ump_stream_msg_devince_info rep = {\n\t\t.type = UMP_MSG_TYPE_STREAM,\n\t\t.status = UMP_STREAM_MSG_STATUS_DEVICE_INFO,\n\t\t.manufacture_id = ep->info.manufacturer,\n\t\t.family_lsb = ep->info.family & 0xff,\n\t\t.family_msb = (ep->info.family >> 8) & 0xff,\n\t\t.model_lsb = ep->info.model & 0xff,\n\t\t.model_msb = (ep->info.model >> 8) & 0xff,\n\t\t.sw_revision = ep->info.sw_revision,\n\t};\n\n\treply_ep_in(ep, &rep, sizeof(rep));\n}\n\n#define UMP_STREAM_PKT_BYTES\t16\t \n#define UMP_STREAM_EP_STR_OFF\t2\t \n#define UMP_STREAM_FB_STR_OFF\t3\t \n\n \nstatic void reply_ump_stream_string(struct f_midi2_ep *ep, const u8 *name,\n\t\t\t\t    unsigned int type, unsigned int extra,\n\t\t\t\t    unsigned int start_ofs)\n{\n\tstruct f_midi2_usb_ep *usb_ep = &ep->ep_in;\n\tstruct f_midi2 *midi2 = ep->card;\n\tstruct usb_request *req;\n\tunsigned int pos;\n\tu32 *buf;\n\n\tif (!*name)\n\t\treturn;\n\treq = get_empty_request(usb_ep);\n\tif (!req)\n\t\treturn;\n\n\tbuf = (u32 *)req->buf;\n\tpos = start_ofs;\n\tfor (;;) {\n\t\tif (pos == start_ofs) {\n\t\t\tmemset(buf, 0, UMP_STREAM_PKT_BYTES);\n\t\t\tbuf[0] = ump_stream_compose(type, 0) | extra;\n\t\t}\n\t\tbuf[pos / 4] |= *name++ << ((3 - (pos % 4)) * 8);\n\t\tif (!*name) {\n\t\t\tif (req->length)\n\t\t\t\tbuf[0] |= UMP_STREAM_MSG_FORMAT_END << 26;\n\t\t\treq->length += UMP_STREAM_PKT_BYTES;\n\t\t\tbreak;\n\t\t}\n\t\tif (++pos == UMP_STREAM_PKT_BYTES) {\n\t\t\tif (!req->length)\n\t\t\t\tbuf[0] |= UMP_STREAM_MSG_FORMAT_START << 26;\n\t\t\telse\n\t\t\t\tbuf[0] |= UMP_STREAM_MSG_FORMAT_CONTINUE << 26;\n\t\t\treq->length += UMP_STREAM_PKT_BYTES;\n\t\t\tif (midi2->info.req_buf_size - req->length < UMP_STREAM_PKT_BYTES)\n\t\t\t\tbreak;\n\t\t\tbuf += 4;\n\t\t\tpos = start_ofs;\n\t\t}\n\t}\n\n\tif (req->length)\n\t\tqueue_request_ep_in(req);\n\telse\n\t\tput_empty_request(req);\n}\n\n \nstatic void reply_ump_stream_ep_name(struct f_midi2_ep *ep)\n{\n\treply_ump_stream_string(ep, ump_ep_name(ep),\n\t\t\t\tUMP_STREAM_MSG_STATUS_EP_NAME, 0,\n\t\t\t\tUMP_STREAM_EP_STR_OFF);\n}\n\n \nstatic void reply_ump_stream_ep_pid(struct f_midi2_ep *ep)\n{\n\treply_ump_stream_string(ep, ump_product_id(ep),\n\t\t\t\tUMP_STREAM_MSG_STATUS_PRODUCT_ID, 0,\n\t\t\t\tUMP_STREAM_EP_STR_OFF);\n}\n\n \nstatic void reply_ump_stream_ep_config(struct f_midi2_ep *ep)\n{\n\tstruct snd_ump_stream_msg_stream_cfg rep = {\n\t\t.type = UMP_MSG_TYPE_STREAM,\n\t\t.status = UMP_STREAM_MSG_STATUS_STREAM_CFG,\n\t};\n\n\tif ((ep->info.protocol & SNDRV_UMP_EP_INFO_PROTO_MIDI_MASK) ==\n\t    SNDRV_UMP_EP_INFO_PROTO_MIDI2)\n\t\trep.protocol = UMP_STREAM_MSG_EP_INFO_CAP_MIDI2 >> 8;\n\telse\n\t\trep.protocol = UMP_STREAM_MSG_EP_INFO_CAP_MIDI1 >> 8;\n\n\treply_ep_in(ep, &rep, sizeof(rep));\n}\n\n \nstatic void reply_ump_stream_fb_info(struct f_midi2_ep *ep, int blk)\n{\n\tstruct f_midi2_block_info *b = &ep->blks[blk].info;\n\tstruct snd_ump_stream_msg_fb_info rep = {\n\t\t.type = UMP_MSG_TYPE_STREAM,\n\t\t.status = UMP_STREAM_MSG_STATUS_FB_INFO,\n\t\t.active = !!b->active,\n\t\t.function_block_id = blk,\n\t\t.ui_hint = b->ui_hint,\n\t\t.midi_10 = b->is_midi1,\n\t\t.direction = b->direction,\n\t\t.first_group = b->first_group,\n\t\t.num_groups = b->num_groups,\n\t\t.midi_ci_version = b->midi_ci_version,\n\t\t.sysex8_streams = b->sysex8_streams,\n\t};\n\n\treply_ep_in(ep, &rep, sizeof(rep));\n}\n\n \nstatic void reply_ump_stream_fb_name(struct f_midi2_ep *ep, unsigned int blk)\n{\n\treply_ump_stream_string(ep, ump_fb_name(&ep->blks[blk].info),\n\t\t\t\tUMP_STREAM_MSG_STATUS_FB_NAME, blk << 8,\n\t\t\t\tUMP_STREAM_FB_STR_OFF);\n}\n\n \nstatic void process_ump_stream_msg(struct f_midi2_ep *ep, const u32 *data)\n{\n\tstruct f_midi2 *midi2 = ep->card;\n\tunsigned int format, status, blk;\n\n\tformat = ump_stream_message_format(*data);\n\tstatus = ump_stream_message_status(*data);\n\tswitch (status) {\n\tcase UMP_STREAM_MSG_STATUS_EP_DISCOVERY:\n\t\tif (format)\n\t\t\treturn; \n\t\tif (data[1] & UMP_STREAM_MSG_REQUEST_EP_INFO)\n\t\t\treply_ump_stream_ep_info(ep);\n\t\tif (data[1] & UMP_STREAM_MSG_REQUEST_DEVICE_INFO)\n\t\t\treply_ump_stream_ep_device(ep);\n\t\tif (data[1] & UMP_STREAM_MSG_REQUEST_EP_NAME)\n\t\t\treply_ump_stream_ep_name(ep);\n\t\tif (data[1] & UMP_STREAM_MSG_REQUEST_PRODUCT_ID)\n\t\t\treply_ump_stream_ep_pid(ep);\n\t\tif (data[1] & UMP_STREAM_MSG_REQUEST_STREAM_CFG)\n\t\t\treply_ump_stream_ep_config(ep);\n\t\treturn;\n\tcase UMP_STREAM_MSG_STATUS_STREAM_CFG_REQUEST:\n\t\tif (*data & UMP_STREAM_MSG_EP_INFO_CAP_MIDI2) {\n\t\t\tep->info.protocol = SNDRV_UMP_EP_INFO_PROTO_MIDI2;\n\t\t\tDBG(midi2, \"Switching Protocol to MIDI2\\n\");\n\t\t} else {\n\t\t\tep->info.protocol = SNDRV_UMP_EP_INFO_PROTO_MIDI1;\n\t\t\tDBG(midi2, \"Switching Protocol to MIDI1\\n\");\n\t\t}\n\t\tsnd_ump_switch_protocol(ep->ump, ep->info.protocol);\n\t\treply_ump_stream_ep_config(ep);\n\t\treturn;\n\tcase UMP_STREAM_MSG_STATUS_FB_DISCOVERY:\n\t\tif (format)\n\t\t\treturn; \n\t\tblk = (*data >> 8) & 0xff;\n\t\tif (blk >= ep->num_blks)\n\t\t\treturn;\n\t\tif (*data & UMP_STREAM_MSG_REQUEST_FB_INFO)\n\t\t\treply_ump_stream_fb_info(ep, blk);\n\t\tif (*data & UMP_STREAM_MSG_REQUEST_FB_NAME)\n\t\t\treply_ump_stream_fb_name(ep, blk);\n\t\treturn;\n\t}\n}\n\n \nstatic void process_ump(struct f_midi2_ep *ep, const struct usb_request *req)\n{\n\tconst u32 *data = (u32 *)req->buf;\n\tint len = req->actual >> 2;\n\tconst u32 *in_buf = ep->ump->input_buf;\n\n\tfor (; len > 0; len--, data++) {\n\t\tif (snd_ump_receive_ump_val(ep->ump, *data) <= 0)\n\t\t\tcontinue;\n\t\tif (ump_message_type(*in_buf) == UMP_MSG_TYPE_STREAM)\n\t\t\tprocess_ump_stream_msg(ep, in_buf);\n\t}\n}\n\n \n\n \nstatic void f_midi2_ep_out_complete(struct usb_ep *usb_ep,\n\t\t\t\t    struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tstruct f_midi2_ep *ep = ctx->usb_ep->ep;\n\tstruct f_midi2 *midi2 = ep->card;\n\tint status = req->status;\n\n\tif (status) {\n\t\tDBG(midi2, \"%s complete error %d: %d/%d\\n\",\n\t\t    usb_ep->name, status, req->actual, req->length);\n\t\tgoto error;\n\t}\n\n\t \n\tle32_to_cpu_array((u32 *)req->buf, req->actual >> 2);\n\n\tif (midi2->info.process_ump)\n\t\tprocess_ump(ep, req);\n\n\tsnd_ump_receive(ep->ump, req->buf, req->actual & ~3);\n\n\tif (midi2->operation_mode != MIDI_OP_MODE_MIDI2)\n\t\tgoto error;\n\n\tif (queue_request_ep_raw(req))\n\t\tgoto error;\n\treturn;\n\n error:\n\tput_empty_request(req);\n}\n\n \nstatic void process_ump_transmit(struct f_midi2_ep *ep)\n{\n\tstruct f_midi2_usb_ep *usb_ep = &ep->ep_in;\n\tstruct f_midi2 *midi2 = ep->card;\n\tstruct usb_request *req;\n\tint len;\n\n\tif (!usb_ep->usb_ep->enabled)\n\t\treturn;\n\n\tfor (;;) {\n\t\treq = get_empty_request(usb_ep);\n\t\tif (!req)\n\t\t\tbreak;\n\t\tlen = snd_ump_transmit(ep->ump, (u32 *)req->buf,\n\t\t\t\t       midi2->info.req_buf_size);\n\t\tif (len <= 0) {\n\t\t\tput_empty_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\treq->length = len;\n\t\tif (queue_request_ep_in(req) < 0)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void f_midi2_ep_in_complete(struct usb_ep *usb_ep,\n\t\t\t\t   struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tstruct f_midi2_ep *ep = ctx->usb_ep->ep;\n\tstruct f_midi2 *midi2 = ep->card;\n\tint status = req->status;\n\n\tput_empty_request(req);\n\n\tif (status) {\n\t\tDBG(midi2, \"%s complete error %d: %d/%d\\n\",\n\t\t    usb_ep->name, status, req->actual, req->length);\n\t\treturn;\n\t}\n\n\tprocess_ump_transmit(ep);\n}\n\n \n\n \nstatic bool process_midi1_byte(struct f_midi2 *midi2, u8 cable, u8 b,\n\t\t\t       struct usb_request **req_p)\n{\n\tstruct f_midi2_midi1_port *port = &midi2->midi1_port[cable];\n\tu8 p[4] = { cable << 4, 0, 0, 0 };\n\tint next_state = STATE_INITIAL;\n\tstruct usb_request *req = *req_p;\n\n\tswitch (b) {\n\tcase 0xf8 ... 0xff:\n\t\t \n\t\tp[0] |= 0x0f;\n\t\tp[1] = b;\n\t\tnext_state = port->state;\n\t\tport->state = STATE_REAL_TIME;\n\t\tbreak;\n\n\tcase 0xf7:\n\t\t \n\t\tswitch (port->state) {\n\t\tcase STATE_SYSEX_0:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tp[0] |= 0x06;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x07;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = 0xf7;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tnext_state = port->state;\n\t\t\tport->state = STATE_INITIAL;\n\t\t}\n\t\tbreak;\n\n\tcase 0xf0 ... 0xf6:\n\t\t \n\t\tport->data[0] = port->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tswitch (b) {\n\t\tcase 0xf0:\n\t\t\tport->data[0] = b;\n\t\t\tport->data[1] = 0;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase 0xf1:\n\t\tcase 0xf3:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase 0xf2:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase 0xf4:\n\t\tcase 0xf5:\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tbreak;\n\t\tcase 0xf6:\n\t\t\tp[0] |= 0x05;\n\t\t\tp[1] = 0xf6;\n\t\t\tnext_state = STATE_FINISHED;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 0x80 ... 0xef:\n\t\t \n\t\tport->data[0] = b;\n\t\tport->data[1] = 0;\n\t\tport->state = STATE_INITIAL;\n\t\tif (b >= 0xc0 && b <= 0xdf)\n\t\t\tnext_state = STATE_1PARAM;\n\t\telse\n\t\t\tnext_state = STATE_2PARAM_1;\n\t\tbreak;\n\n\tcase 0x00 ... 0x7f:\n\t\t \n\t\tswitch (port->state) {\n\t\tcase STATE_1PARAM:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x02;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = b;\n\t\t\t \n\t\t\tnext_state = STATE_1PARAM;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_2PARAM_2;\n\t\t\tbreak;\n\t\tcase STATE_2PARAM_2:\n\t\t\tif (port->data[0] < 0xf0)\n\t\t\t\tp[0] |= port->data[0] >> 4;\n\t\t\telse\n\t\t\t\tp[0] |= 0x03;\n\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\t \n\t\t\tnext_state = STATE_2PARAM_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_0:\n\t\t\tport->data[0] = b;\n\t\t\tnext_state = STATE_SYSEX_1;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_1:\n\t\t\tport->data[1] = b;\n\t\t\tnext_state = STATE_SYSEX_2;\n\t\t\tbreak;\n\t\tcase STATE_SYSEX_2:\n\t\t\tp[0] |= 0x04;\n\t\t\tp[1] = port->data[0];\n\t\t\tp[2] = port->data[1];\n\t\t\tp[3] = b;\n\t\t\tnext_state = STATE_SYSEX_0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tif (next_state == STATE_FINISHED ||\n\t    port->state == STATE_SYSEX_2 ||\n\t    port->state == STATE_1PARAM ||\n\t    port->state == STATE_2PARAM_2 ||\n\t    port->state == STATE_REAL_TIME) {\n\t\tmemcpy(req->buf + req->length, p, sizeof(p));\n\t\treq->length += sizeof(p);\n\n\t\tif (next_state == STATE_FINISHED) {\n\t\t\tnext_state = STATE_INITIAL;\n\t\t\tport->data[0] = port->data[1] = 0;\n\t\t}\n\n\t\tif (midi2->info.req_buf_size - req->length <= 4) {\n\t\t\tqueue_request_ep_raw(req);\n\t\t\t*req_p = NULL;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tport->state = next_state;\n\treturn false;\n}\n\n \nstatic bool process_midi1_pending_buf(struct f_midi2 *midi2,\n\t\t\t\t      struct usb_request **req_p)\n{\n\tunsigned int cable, c;\n\n\tfor (cable = 0; cable < midi2->num_midi1_in; cable++) {\n\t\tstruct f_midi2_midi1_port *port = &midi2->midi1_port[cable];\n\n\t\tif (!port->pending)\n\t\t\tcontinue;\n\t\tfor (c = 0; c < port->pending; c++) {\n\t\t\tif (process_midi1_byte(midi2, cable, port->buf[c],\n\t\t\t\t\t       req_p)) {\n\t\t\t\tport->pending -= c;\n\t\t\t\tif (port->pending)\n\t\t\t\t\tmemmove(port->buf, port->buf + c,\n\t\t\t\t\t\tport->pending);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tport->pending = 0;\n\t}\n\n\treturn false;\n}\n\n \nstatic void fill_midi1_pending_buf(struct f_midi2 *midi2, u8 cable, u8 *buf,\n\t\t\t\t   unsigned int size)\n{\n\tstruct f_midi2_midi1_port *port = &midi2->midi1_port[cable];\n\n\tif (port->pending + size > sizeof(port->buf))\n\t\treturn;\n\tmemcpy(port->buf + port->pending, buf, size);\n\tport->pending += size;\n}\n\n \nstatic void process_midi1_transmit(struct f_midi2 *midi2)\n{\n\tstruct f_midi2_usb_ep *usb_ep = &midi2->midi1_ep_in;\n\tstruct f_midi2_ep *ep = &midi2->midi2_eps[0];\n\tstruct usb_request *req = NULL;\n\t \n\tunsigned char outbuf[12];\n\tunsigned char group, cable;\n\tint len, size;\n\tu32 ump;\n\n\tif (!usb_ep->usb_ep || !usb_ep->usb_ep->enabled)\n\t\treturn;\n\n\tfor (;;) {\n\t\tif (!req) {\n\t\t\treq = get_empty_request(usb_ep);\n\t\t\tif (!req)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (process_midi1_pending_buf(midi2, &req))\n\t\t\tcontinue;\n\n\t\tlen = snd_ump_transmit(ep->ump, &ump, 4);\n\t\tif (len <= 0)\n\t\t\tbreak;\n\t\tif (snd_ump_receive_ump_val(ep->ump, ump) <= 0)\n\t\t\tcontinue;\n\t\tsize = snd_ump_convert_from_ump(ep->ump->input_buf, outbuf,\n\t\t\t\t\t\t&group);\n\t\tif (size <= 0)\n\t\t\tcontinue;\n\t\tcable = ep->in_group_to_cable[group];\n\t\tif (!cable)\n\t\t\tcontinue;\n\t\tcable--;  \n\t\tfill_midi1_pending_buf(midi2, cable, outbuf, size);\n\t}\n\n\tif (req) {\n\t\tif (req->length)\n\t\t\tqueue_request_ep_raw(req);\n\t\telse\n\t\t\tput_empty_request(req);\n\t}\n}\n\n \nstatic void f_midi2_midi1_ep_in_complete(struct usb_ep *usb_ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tstruct f_midi2 *midi2 = ctx->usb_ep->card;\n\tint status = req->status;\n\n\tput_empty_request(req);\n\n\tif (status) {\n\t\tDBG(midi2, \"%s complete error %d: %d/%d\\n\",\n\t\t    usb_ep->name, status, req->actual, req->length);\n\t\treturn;\n\t}\n\n\tprocess_midi1_transmit(midi2);\n}\n\n \nstatic void f_midi2_midi1_ep_out_complete(struct usb_ep *usb_ep,\n\t\t\t\t\t  struct usb_request *req)\n{\n\tstruct f_midi2_req_ctx *ctx = req->context;\n\tstruct f_midi2 *midi2 = ctx->usb_ep->card;\n\tstruct f_midi2_ep *ep;\n\tstruct ump_cvt_to_ump *cvt = &midi2->midi1_ump_cvt;\n\tstatic const u8 midi1_packet_bytes[16] = {\n\t\t0, 0, 2, 3, 3, 1, 2, 3, 3, 3, 3, 3, 2, 2, 3, 1\n\t};\n\tunsigned int group, cable, bytes, c, len;\n\tint status = req->status;\n\tconst u8 *buf = req->buf;\n\n\tif (status) {\n\t\tDBG(midi2, \"%s complete error %d: %d/%d\\n\",\n\t\t    usb_ep->name, status, req->actual, req->length);\n\t\tgoto error;\n\t}\n\n\tlen = req->actual >> 2;\n\tfor (; len; len--, buf += 4) {\n\t\tcable = *buf >> 4;\n\t\tep = midi2->out_cable_mapping[cable].ep;\n\t\tif (!ep)\n\t\t\tcontinue;\n\t\tgroup = midi2->out_cable_mapping[cable].group;\n\t\tbytes = midi1_packet_bytes[*buf & 0x0f];\n\t\tfor (c = 0; c < bytes; c++) {\n\t\t\tsnd_ump_convert_to_ump(cvt, group, ep->info.protocol,\n\t\t\t\t\t       buf[c + 1]);\n\t\t\tif (cvt->ump_bytes) {\n\t\t\t\tsnd_ump_receive(ep->ump, cvt->ump,\n\t\t\t\t\t\tcvt->ump_bytes);\n\t\t\t\tcvt->ump_bytes = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (midi2->operation_mode != MIDI_OP_MODE_MIDI1)\n\t\tgoto error;\n\n\tif (queue_request_ep_raw(req))\n\t\tgoto error;\n\treturn;\n\n error:\n\tput_empty_request(req);\n}\n\n \n\n \nstatic int f_midi2_start_ep(struct f_midi2_usb_ep *usb_ep,\n\t\t\t    struct usb_function *fn)\n{\n\tint err;\n\n\tif (!usb_ep->usb_ep)\n\t\treturn 0;\n\n\tusb_ep_disable(usb_ep->usb_ep);\n\terr = config_ep_by_speed(usb_ep->card->gadget, fn, usb_ep->usb_ep);\n\tif (err)\n\t\treturn err;\n\treturn usb_ep_enable(usb_ep->usb_ep);\n}\n\n \nstatic void f_midi2_drop_reqs(struct f_midi2_usb_ep *usb_ep)\n{\n\tint i;\n\n\tif (!usb_ep->usb_ep || !usb_ep->num_reqs)\n\t\treturn;\n\n\tfor (i = 0; i < usb_ep->num_reqs; i++) {\n\t\tif (!test_bit(i, &usb_ep->free_reqs) && usb_ep->reqs[i].req) {\n\t\t\tusb_ep_dequeue(usb_ep->usb_ep, usb_ep->reqs[i].req);\n\t\t\tset_bit(i, &usb_ep->free_reqs);\n\t\t}\n\t}\n}\n\n \nstatic int f_midi2_alloc_ep_reqs(struct f_midi2_usb_ep *usb_ep)\n{\n\tstruct f_midi2 *midi2 = usb_ep->card;\n\tint i;\n\n\tif (!usb_ep->usb_ep)\n\t\treturn 0;\n\tif (!usb_ep->reqs)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < midi2->info.num_reqs; i++) {\n\t\tif (usb_ep->reqs[i].req)\n\t\t\tcontinue;\n\t\tusb_ep->reqs[i].req = alloc_ep_req(usb_ep->usb_ep,\n\t\t\t\t\t\t   midi2->info.req_buf_size);\n\t\tif (!usb_ep->reqs[i].req)\n\t\t\treturn -ENOMEM;\n\t\tusb_ep->reqs[i].req->context = &usb_ep->reqs[i];\n\t}\n\treturn 0;\n}\n\n \nstatic void f_midi2_free_ep_reqs(struct f_midi2_usb_ep *usb_ep)\n{\n\tstruct f_midi2 *midi2 = usb_ep->card;\n\tint i;\n\n\tfor (i = 0; i < midi2->info.num_reqs; i++) {\n\t\tif (!usb_ep->reqs[i].req)\n\t\t\tcontinue;\n\t\tfree_ep_req(usb_ep->usb_ep, usb_ep->reqs[i].req);\n\t\tusb_ep->reqs[i].req = NULL;\n\t}\n}\n\n \nstatic int f_midi2_init_ep(struct f_midi2 *midi2, struct f_midi2_ep *ep,\n\t\t\t   struct f_midi2_usb_ep *usb_ep,\n\t\t\t   void *desc,\n\t\t\t   void (*complete)(struct usb_ep *usb_ep,\n\t\t\t\t\t    struct usb_request *req))\n{\n\tint i;\n\n\tusb_ep->card = midi2;\n\tusb_ep->ep = ep;\n\tusb_ep->usb_ep = usb_ep_autoconfig(midi2->gadget, desc);\n\tif (!usb_ep->usb_ep)\n\t\treturn -ENODEV;\n\tusb_ep->complete = complete;\n\n\tusb_ep->reqs = kcalloc(midi2->info.num_reqs, sizeof(*usb_ep->reqs),\n\t\t\t       GFP_KERNEL);\n\tif (!usb_ep->reqs)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < midi2->info.num_reqs; i++) {\n\t\tusb_ep->reqs[i].index = i;\n\t\tusb_ep->reqs[i].usb_ep = usb_ep;\n\t\tset_bit(i, &usb_ep->free_reqs);\n\t\tusb_ep->num_reqs++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void f_midi2_free_ep(struct f_midi2_usb_ep *usb_ep)\n{\n\tf_midi2_drop_reqs(usb_ep);\n\n\tf_midi2_free_ep_reqs(usb_ep);\n\n\tkfree(usb_ep->reqs);\n\tusb_ep->num_reqs = 0;\n\tusb_ep->free_reqs = 0;\n\tusb_ep->reqs = NULL;\n}\n\n \nstatic void f_midi2_queue_out_reqs(struct f_midi2_usb_ep *usb_ep)\n{\n\tint i, err;\n\n\tif (!usb_ep->usb_ep)\n\t\treturn;\n\n\tfor (i = 0; i < usb_ep->num_reqs; i++) {\n\t\tif (!test_bit(i, &usb_ep->free_reqs) || !usb_ep->reqs[i].req)\n\t\t\tcontinue;\n\t\tusb_ep->reqs[i].req->complete = usb_ep->complete;\n\t\terr = usb_ep_queue(usb_ep->usb_ep, usb_ep->reqs[i].req,\n\t\t\t\t   GFP_ATOMIC);\n\t\tif (!err)\n\t\t\tclear_bit(i, &usb_ep->free_reqs);\n\t}\n}\n\n \n\n \nstatic void f_midi2_stop_eps(struct f_midi2_usb_ep *ep_in,\n\t\t\t     struct f_midi2_usb_ep *ep_out)\n{\n\tf_midi2_drop_reqs(ep_in);\n\tf_midi2_drop_reqs(ep_out);\n\tf_midi2_free_ep_reqs(ep_in);\n\tf_midi2_free_ep_reqs(ep_out);\n}\n\n \nstatic int f_midi2_start_eps(struct f_midi2_usb_ep *ep_in,\n\t\t\t     struct f_midi2_usb_ep *ep_out,\n\t\t\t     struct usb_function *fn)\n{\n\tint err;\n\n\terr = f_midi2_start_ep(ep_in, fn);\n\tif (err)\n\t\treturn err;\n\terr = f_midi2_start_ep(ep_out, fn);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi2_alloc_ep_reqs(ep_in);\n\tif (err)\n\t\treturn err;\n\terr = f_midi2_alloc_ep_reqs(ep_out);\n\tif (err)\n\t\treturn err;\n\n\tf_midi2_queue_out_reqs(ep_out);\n\treturn 0;\n}\n\n \nstatic int f_midi2_set_alt(struct usb_function *fn, unsigned int intf,\n\t\t\t   unsigned int alt)\n{\n\tstruct f_midi2 *midi2 = func_to_midi2(fn);\n\tstruct f_midi2_ep *ep;\n\tint i, op_mode, err;\n\n\tif (intf != midi2->midi_if || alt > 1)\n\t\treturn 0;\n\n\tif (alt == 0)\n\t\top_mode = MIDI_OP_MODE_MIDI1;\n\telse if (alt == 1)\n\t\top_mode = MIDI_OP_MODE_MIDI2;\n\telse\n\t\top_mode = MIDI_OP_MODE_UNSET;\n\n\tif (midi2->operation_mode == op_mode)\n\t\treturn 0;\n\n\tmidi2->operation_mode = op_mode;\n\n\tif (op_mode != MIDI_OP_MODE_MIDI1)\n\t\tf_midi2_stop_eps(&midi2->midi1_ep_in, &midi2->midi1_ep_out);\n\n\tif (op_mode != MIDI_OP_MODE_MIDI2) {\n\t\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\t\tep = &midi2->midi2_eps[i];\n\t\t\tf_midi2_stop_eps(&ep->ep_in, &ep->ep_out);\n\t\t}\n\t}\n\n\tif (op_mode == MIDI_OP_MODE_MIDI1)\n\t\treturn f_midi2_start_eps(&midi2->midi1_ep_in,\n\t\t\t\t\t &midi2->midi1_ep_out, fn);\n\n\tif (op_mode == MIDI_OP_MODE_MIDI2) {\n\t\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\t\tep = &midi2->midi2_eps[i];\n\n\t\t\terr = f_midi2_start_eps(&ep->ep_in, &ep->ep_out, fn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int f_midi2_get_alt(struct usb_function *fn, unsigned int intf)\n{\n\tstruct f_midi2 *midi2 = func_to_midi2(fn);\n\n\tif (intf == midi2->midi_if &&\n\t    midi2->operation_mode == MIDI_OP_MODE_MIDI2)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic unsigned int ump_to_usb_dir(unsigned int ump_dir)\n{\n\tswitch (ump_dir) {\n\tcase SNDRV_UMP_DIR_INPUT:\n\t\treturn USB_MS_GR_TRM_BLOCK_TYPE_INPUT_ONLY;\n\tcase SNDRV_UMP_DIR_OUTPUT:\n\t\treturn USB_MS_GR_TRM_BLOCK_TYPE_OUTPUT_ONLY;\n\tdefault:\n\t\treturn USB_MS_GR_TRM_BLOCK_TYPE_BIDIRECTIONAL;\n\t}\n}\n\n \nstatic void assign_block_descriptors(struct f_midi2 *midi2,\n\t\t\t\t     struct usb_request *req,\n\t\t\t\t     int max_len)\n{\n\tstruct usb_ms20_gr_trm_block_header_descriptor header;\n\tstruct usb_ms20_gr_trm_block_descriptor *desc;\n\tstruct f_midi2_block_info *b;\n\tstruct f_midi2_ep *ep;\n\tint i, blk, len;\n\tchar *data;\n\n\tlen = sizeof(gtb_header_desc) + sizeof(gtb_desc) * midi2->total_blocks;\n\tif (WARN_ON(len > midi2->info.req_buf_size))\n\t\treturn;\n\n\theader = gtb_header_desc;\n\theader.wTotalLength = cpu_to_le16(len);\n\tif (max_len < len) {\n\t\tlen = min_t(int, len, sizeof(header));\n\t\tmemcpy(req->buf, &header, len);\n\t\treq->length = len;\n\t\treq->zero = len < max_len;\n\t\treturn;\n\t}\n\n\tmemcpy(req->buf, &header, sizeof(header));\n\tdata = req->buf + sizeof(header);\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tep = &midi2->midi2_eps[i];\n\t\tfor (blk = 0; blk < ep->num_blks; blk++) {\n\t\t\tb = &ep->blks[blk].info;\n\t\t\tdesc = (struct usb_ms20_gr_trm_block_descriptor *)data;\n\n\t\t\t*desc = gtb_desc;\n\t\t\tdesc->bGrpTrmBlkID = ep->blks[blk].gtb_id;\n\t\t\tdesc->bGrpTrmBlkType = ump_to_usb_dir(b->direction);\n\t\t\tdesc->nGroupTrm = b->first_group;\n\t\t\tdesc->nNumGroupTrm = b->num_groups;\n\t\t\tdesc->iBlockItem = ep->blks[blk].string_id;\n\n\t\t\tif (ep->info.protocol & SNDRV_UMP_EP_INFO_PROTO_MIDI2)\n\t\t\t\tdesc->bMIDIProtocol = USB_MS_MIDI_PROTO_2_0;\n\t\t\telse\n\t\t\t\tdesc->bMIDIProtocol = USB_MS_MIDI_PROTO_1_0_128;\n\n\t\t\tif (b->is_midi1 == 2) {\n\t\t\t\tdesc->wMaxInputBandwidth = cpu_to_le16(1);\n\t\t\t\tdesc->wMaxOutputBandwidth = cpu_to_le16(1);\n\t\t\t}\n\n\t\t\tdata += sizeof(*desc);\n\t\t}\n\t}\n\n\treq->length = len;\n\treq->zero = len < max_len;\n}\n\n \nstatic int f_midi2_setup(struct usb_function *fn,\n\t\t\t const struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_midi2 *midi2 = func_to_midi2(fn);\n\tstruct usb_composite_dev *cdev = fn->config->cdev;\n\tstruct usb_request *req = cdev->req;\n\tu16 value, length;\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD ||\n\t    ctrl->bRequest != USB_REQ_GET_DESCRIPTOR)\n\t\treturn -EOPNOTSUPP;\n\n\tvalue = le16_to_cpu(ctrl->wValue);\n\tlength = le16_to_cpu(ctrl->wLength);\n\n\tif ((value >> 8) != USB_DT_CS_GR_TRM_BLOCK)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif ((value & 0xff) != 1)\n\t\treturn -EOPNOTSUPP;\n\n\tassign_block_descriptors(midi2, req, length);\n\treturn usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n}\n\n \nstatic void f_midi2_disable(struct usb_function *fn)\n{\n\tstruct f_midi2 *midi2 = func_to_midi2(fn);\n\n\tmidi2->operation_mode = MIDI_OP_MODE_UNSET;\n}\n\n \nstatic int f_midi2_ump_open(struct snd_ump_endpoint *ump, int dir)\n{\n\treturn 0;\n}\n\nstatic void f_midi2_ump_close(struct snd_ump_endpoint *ump, int dir)\n{\n}\n\nstatic void f_midi2_ump_trigger(struct snd_ump_endpoint *ump, int dir, int up)\n{\n\tstruct f_midi2_ep *ep = ump->private_data;\n\tstruct f_midi2 *midi2 = ep->card;\n\n\tif (up && dir == SNDRV_RAWMIDI_STREAM_OUTPUT) {\n\t\tswitch (midi2->operation_mode) {\n\t\tcase MIDI_OP_MODE_MIDI1:\n\t\t\tprocess_midi1_transmit(midi2);\n\t\t\tbreak;\n\t\tcase MIDI_OP_MODE_MIDI2:\n\t\t\tprocess_ump_transmit(ep);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void f_midi2_ump_drain(struct snd_ump_endpoint *ump, int dir)\n{\n}\n\nstatic const struct snd_ump_ops f_midi2_ump_ops = {\n\t.open = f_midi2_ump_open,\n\t.close = f_midi2_ump_close,\n\t.trigger = f_midi2_ump_trigger,\n\t.drain = f_midi2_ump_drain,\n};\n\n \nstatic int f_midi2_operation_mode_info(struct snd_kcontrol *kcontrol,\n\t\t\t\t       struct snd_ctl_elem_info *uinfo)\n{\n\tuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\n\tuinfo->count = 1;\n\tuinfo->value.integer.min = MIDI_OP_MODE_UNSET;\n\tuinfo->value.integer.max = MIDI_OP_MODE_MIDI2;\n\treturn 0;\n}\n\nstatic int f_midi2_operation_mode_get(struct snd_kcontrol *kcontrol,\n\t\t\t\t      struct snd_ctl_elem_value *ucontrol)\n{\n\tstruct f_midi2 *midi2 = snd_kcontrol_chip(kcontrol);\n\n\tucontrol->value.integer.value[0] = midi2->operation_mode;\n\treturn 0;\n}\n\nstatic const struct snd_kcontrol_new operation_mode_ctl = {\n\t.iface = SNDRV_CTL_ELEM_IFACE_RAWMIDI,\n\t.name = \"Operation Mode\",\n\t.access = SNDRV_CTL_ELEM_ACCESS_READ | SNDRV_CTL_ELEM_ACCESS_VOLATILE,\n\t.info = f_midi2_operation_mode_info,\n\t.get = f_midi2_operation_mode_get,\n};\n\n \nstatic void f_midi2_free_card(struct f_midi2 *midi2)\n{\n\tif (midi2->card) {\n\t\tsnd_card_free_when_closed(midi2->card);\n\t\tmidi2->card = NULL;\n\t}\n}\n\n \nstatic int reverse_dir(int dir)\n{\n\tif (!dir || dir == SNDRV_UMP_DIR_BIDIRECTION)\n\t\treturn dir;\n\treturn (dir == SNDRV_UMP_DIR_OUTPUT) ?\n\t\tSNDRV_UMP_DIR_INPUT : SNDRV_UMP_DIR_OUTPUT;\n}\n\nstatic int f_midi2_create_card(struct f_midi2 *midi2)\n{\n\tstruct snd_card *card;\n\tstruct snd_ump_endpoint *ump;\n\tstruct f_midi2_ep *ep;\n\tint i, id, blk, err;\n\t__be32 sw;\n\n\terr = snd_card_new(&midi2->gadget->dev, -1, NULL, THIS_MODULE, 0,\n\t\t\t   &card);\n\tif (err < 0)\n\t\treturn err;\n\tmidi2->card = card;\n\n\tstrcpy(card->driver, \"f_midi2\");\n\tstrcpy(card->shortname, \"MIDI 2.0 Gadget\");\n\tstrcpy(card->longname, \"MIDI 2.0 Gadget\");\n\n\tid = 0;\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tep = &midi2->midi2_eps[i];\n\t\terr = snd_ump_endpoint_new(card, \"MIDI 2.0 Gadget\", id,\n\t\t\t\t\t   1, 1, &ump);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tid++;\n\n\t\tep->ump = ump;\n\t\tump->no_process_stream = true;\n\t\tump->private_data = ep;\n\t\tump->ops = &f_midi2_ump_ops;\n\t\tif (midi2->info.static_block)\n\t\t\tump->info.flags |= SNDRV_UMP_EP_INFO_STATIC_BLOCKS;\n\t\tump->info.protocol_caps = (ep->info.protocol_caps & 3) << 8;\n\t\tump->info.protocol = (ep->info.protocol & 3) << 8;\n\t\tump->info.version = 0x0101;\n\t\tump->info.family_id = ep->info.family;\n\t\tump->info.model_id = ep->info.model;\n\t\tump->info.manufacturer_id = ep->info.manufacturer & 0xffffff;\n\t\tsw = cpu_to_be32(ep->info.sw_revision);\n\t\tmemcpy(ump->info.sw_revision, &sw, 4);\n\n\t\tstrscpy(ump->info.name, ump_ep_name(ep),\n\t\t\tsizeof(ump->info.name));\n\t\tstrscpy(ump->info.product_id, ump_product_id(ep),\n\t\t\tsizeof(ump->info.product_id));\n\t\tstrscpy(ump->core.name, ump->info.name, sizeof(ump->core.name));\n\n\t\tfor (blk = 0; blk < ep->num_blks; blk++) {\n\t\t\tconst struct f_midi2_block_info *b = &ep->blks[blk].info;\n\t\t\tstruct snd_ump_block *fb;\n\n\t\t\terr = snd_ump_block_new(ump, blk,\n\t\t\t\t\t\treverse_dir(b->direction),\n\t\t\t\t\t\tb->first_group, b->num_groups,\n\t\t\t\t\t\t&ep->blks[blk].fb);\n\t\t\tif (err < 0)\n\t\t\t\tgoto error;\n\t\t\tfb = ep->blks[blk].fb;\n\t\t\tfb->info.active = !!b->active;\n\t\t\tfb->info.midi_ci_version = b->midi_ci_version;\n\t\t\tfb->info.ui_hint = reverse_dir(b->ui_hint);\n\t\t\tfb->info.sysex8_streams = b->sysex8_streams;\n\t\t\tfb->info.flags |= b->is_midi1;\n\t\t\tstrscpy(fb->info.name, ump_fb_name(b),\n\t\t\t\tsizeof(fb->info.name));\n\t\t}\n\t}\n\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\terr = snd_ump_attach_legacy_rawmidi(midi2->midi2_eps[i].ump,\n\t\t\t\t\t\t    \"Legacy MIDI\", id);\n\t\tif (err < 0)\n\t\t\tgoto error;\n\t\tid++;\n\t}\n\n\terr = snd_ctl_add(card, snd_ctl_new1(&operation_mode_ctl, midi2));\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = snd_card_register(card);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\n error:\n\tf_midi2_free_card(midi2);\n\treturn err;\n}\n\n \nstruct f_midi2_usb_config {\n\tstruct usb_descriptor_header **list;\n\tunsigned int size;\n\tunsigned int alloc;\n\n\t \n\tunsigned char jack_in, jack_out, jack_id;\n\tstruct usb_midi_in_jack_descriptor jack_ins[MAX_CABLES];\n\tstruct usb_midi_out_jack_descriptor_1 jack_outs[MAX_CABLES];\n};\n\nstatic int append_config(struct f_midi2_usb_config *config, void *d)\n{\n\tunsigned int size;\n\tvoid *buf;\n\n\tif (config->size + 2 >= config->alloc) {\n\t\tsize = config->size + 16;\n\t\tbuf = krealloc(config->list, size * sizeof(void *), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t\tconfig->list = buf;\n\t\tconfig->alloc = size;\n\t}\n\n\tconfig->list[config->size] = d;\n\tconfig->size++;\n\tconfig->list[config->size] = NULL;\n\treturn 0;\n}\n\nstatic int append_configs(struct f_midi2_usb_config *config, void **d)\n{\n\tint err;\n\n\tfor (; *d; d++) {\n\t\terr = append_config(config, *d);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int append_midi1_in_jack(struct f_midi2 *midi2,\n\t\t\t\tstruct f_midi2_usb_config *config,\n\t\t\t\tstruct midi1_cable_mapping *map,\n\t\t\t\tunsigned int type)\n{\n\tstruct usb_midi_in_jack_descriptor *jack =\n\t\t&config->jack_ins[config->jack_in++];\n\tint id = ++config->jack_id;\n\tint err;\n\n\tjack->bLength = 0x06;\n\tjack->bDescriptorType = USB_DT_CS_INTERFACE;\n\tjack->bDescriptorSubtype = USB_MS_MIDI_IN_JACK;\n\tjack->bJackType = type;\n\tjack->bJackID = id;\n\t \n\tif (map->ep)\n\t\tjack->iJack = map->ep->blks[map->block].string_id;\n\n\terr = append_config(config, jack);\n\tif (err < 0)\n\t\treturn err;\n\treturn id;\n}\n\nstatic int append_midi1_out_jack(struct f_midi2 *midi2,\n\t\t\t\t struct f_midi2_usb_config *config,\n\t\t\t\t struct midi1_cable_mapping *map,\n\t\t\t\t unsigned int type, unsigned int source)\n{\n\tstruct usb_midi_out_jack_descriptor_1 *jack =\n\t\t&config->jack_outs[config->jack_out++];\n\tint id = ++config->jack_id;\n\tint err;\n\n\tjack->bLength = 0x09;\n\tjack->bDescriptorType = USB_DT_CS_INTERFACE;\n\tjack->bDescriptorSubtype = USB_MS_MIDI_OUT_JACK;\n\tjack->bJackType = type;\n\tjack->bJackID = id;\n\tjack->bNrInputPins = 1;\n\tjack->pins[0].baSourceID = source;\n\tjack->pins[0].baSourcePin = 0x01;\n\t \n\tif (map->ep)\n\t\tjack->iJack = map->ep->blks[map->block].string_id;\n\n\terr = append_config(config, jack);\n\tif (err < 0)\n\t\treturn err;\n\treturn id;\n}\n\nstatic int f_midi2_create_usb_configs(struct f_midi2 *midi2,\n\t\t\t\t      struct f_midi2_usb_config *config,\n\t\t\t\t      int speed)\n{\n\tvoid **midi1_in_eps, **midi1_out_eps;\n\tint i, jack, total;\n\tint err;\n\n\tswitch (speed) {\n\tdefault:\n\tcase USB_SPEED_HIGH:\n\t\tmidi2_midi1_ep_out_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tmidi2_midi1_ep_in_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tfor (i = 0; i < midi2->num_eps; i++)\n\t\t\tmidi2_midi2_ep_out_desc[i].wMaxPacketSize =\n\t\t\t\tcpu_to_le16(512);\n\t\tfallthrough;\n\tcase USB_SPEED_FULL:\n\t\tmidi1_in_eps = midi2_midi1_ep_in_descs;\n\t\tmidi1_out_eps = midi2_midi1_ep_out_descs;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tmidi2_midi1_ep_out_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\tmidi2_midi1_ep_in_desc.wMaxPacketSize = cpu_to_le16(1024);\n\t\tfor (i = 0; i < midi2->num_eps; i++)\n\t\t\tmidi2_midi2_ep_out_desc[i].wMaxPacketSize =\n\t\t\t\tcpu_to_le16(1024);\n\t\tmidi1_in_eps = midi2_midi1_ep_in_ss_descs;\n\t\tmidi1_out_eps = midi2_midi1_ep_out_ss_descs;\n\t\tbreak;\n\t}\n\n\terr = append_configs(config, midi2_audio_descs);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (midi2->num_midi1_in && midi2->num_midi1_out)\n\t\tmidi2_midi1_if_desc.bNumEndpoints = 2;\n\telse\n\t\tmidi2_midi1_if_desc.bNumEndpoints = 1;\n\n\terr = append_configs(config, midi2_midi1_descs);\n\tif (err < 0)\n\t\treturn err;\n\n\ttotal = USB_DT_MS_HEADER_SIZE;\n\tif (midi2->num_midi1_out) {\n\t\tmidi2_midi1_ep_out_class_desc.bLength =\n\t\t\tUSB_DT_MS_ENDPOINT_SIZE(midi2->num_midi1_out);\n\t\ttotal += midi2_midi1_ep_out_class_desc.bLength;\n\t\tmidi2_midi1_ep_out_class_desc.bNumEmbMIDIJack =\n\t\t\tmidi2->num_midi1_out;\n\t\ttotal += midi2->num_midi1_out *\n\t\t\t(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\n\t\tfor (i = 0; i < midi2->num_midi1_out; i++) {\n\t\t\tjack = append_midi1_in_jack(midi2, config,\n\t\t\t\t\t\t    &midi2->in_cable_mapping[i],\n\t\t\t\t\t\t    USB_MS_EMBEDDED);\n\t\t\tif (jack < 0)\n\t\t\t\treturn jack;\n\t\t\tmidi2_midi1_ep_out_class_desc.baAssocJackID[i] = jack;\n\t\t\tjack = append_midi1_out_jack(midi2, config,\n\t\t\t\t\t\t     &midi2->in_cable_mapping[i],\n\t\t\t\t\t\t     USB_MS_EXTERNAL, jack);\n\t\t\tif (jack < 0)\n\t\t\t\treturn jack;\n\t\t}\n\t}\n\n\tif (midi2->num_midi1_in) {\n\t\tmidi2_midi1_ep_in_class_desc.bLength =\n\t\t\tUSB_DT_MS_ENDPOINT_SIZE(midi2->num_midi1_in);\n\t\ttotal += midi2_midi1_ep_in_class_desc.bLength;\n\t\tmidi2_midi1_ep_in_class_desc.bNumEmbMIDIJack =\n\t\t\tmidi2->num_midi1_in;\n\t\ttotal += midi2->num_midi1_in *\n\t\t\t(USB_DT_MIDI_IN_SIZE + USB_DT_MIDI_OUT_SIZE(1));\n\t\tfor (i = 0; i < midi2->num_midi1_in; i++) {\n\t\t\tjack = append_midi1_in_jack(midi2, config,\n\t\t\t\t\t\t    &midi2->out_cable_mapping[i],\n\t\t\t\t\t\t    USB_MS_EXTERNAL);\n\t\t\tif (jack < 0)\n\t\t\t\treturn jack;\n\t\t\tjack = append_midi1_out_jack(midi2, config,\n\t\t\t\t\t\t     &midi2->out_cable_mapping[i],\n\t\t\t\t\t\t     USB_MS_EMBEDDED, jack);\n\t\t\tif (jack < 0)\n\t\t\t\treturn jack;\n\t\t\tmidi2_midi1_ep_in_class_desc.baAssocJackID[i] = jack;\n\t\t}\n\t}\n\n\tmidi2_midi1_class_desc.wTotalLength = cpu_to_le16(total);\n\n\tif (midi2->num_midi1_out) {\n\t\terr = append_configs(config, midi1_out_eps);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tif (midi2->num_midi1_in) {\n\t\terr = append_configs(config, midi1_in_eps);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = append_configs(config, midi2_midi2_descs);\n\tif (err < 0)\n\t\treturn err;\n\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\terr = append_config(config, &midi2_midi2_ep_out_desc[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (speed == USB_SPEED_SUPER || speed == USB_SPEED_SUPER_PLUS) {\n\t\t\terr = append_config(config, &midi2_midi2_ep_out_ss_comp_desc);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = append_config(config, &midi2_midi2_ep_out_class_desc[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = append_config(config, &midi2_midi2_ep_in_desc[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tif (speed == USB_SPEED_SUPER || speed == USB_SPEED_SUPER_PLUS) {\n\t\t\terr = append_config(config, &midi2_midi2_ep_in_ss_comp_desc);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\terr = append_config(config, &midi2_midi2_ep_in_class_desc[i]);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void f_midi2_free_usb_configs(struct f_midi2_usb_config *config)\n{\n\tkfree(config->list);\n\tmemset(config, 0, sizeof(*config));\n}\n\n \nstatic DEFINE_MUTEX(f_midi2_desc_mutex);\n\n \nstatic void fill_midi2_class_desc(struct f_midi2_ep *ep,\n\t\t\t\t  struct usb_ms20_endpoint_descriptor_32 *cdesc)\n{\n\tint blk;\n\n\tcdesc->bLength = USB_DT_MS20_ENDPOINT_SIZE(ep->num_blks);\n\tcdesc->bDescriptorType = USB_DT_CS_ENDPOINT;\n\tcdesc->bDescriptorSubtype = USB_MS_GENERAL_2_0;\n\tcdesc->bNumGrpTrmBlock = ep->num_blks;\n\tfor (blk = 0; blk < ep->num_blks; blk++)\n\t\tcdesc->baAssoGrpTrmBlkID[blk] = ep->blks[blk].gtb_id;\n}\n\n \nstatic int f_midi2_init_midi2_ep_in(struct f_midi2 *midi2, int index)\n{\n\tstruct f_midi2_ep *ep = &midi2->midi2_eps[index];\n\tstruct usb_endpoint_descriptor *desc = &midi2_midi2_ep_in_desc[index];\n\n\tdesc->bLength = USB_DT_ENDPOINT_SIZE;\n\tdesc->bDescriptorType = USB_DT_ENDPOINT;\n\tdesc->bEndpointAddress = USB_DIR_IN;\n\tdesc->bmAttributes = USB_ENDPOINT_XFER_INT;\n\tdesc->wMaxPacketSize = cpu_to_le16(EP_MAX_PACKET_INT);\n\tdesc->bInterval = 1;\n\n\tfill_midi2_class_desc(ep, &midi2_midi2_ep_in_class_desc[index]);\n\n\treturn f_midi2_init_ep(midi2, ep, &ep->ep_in, desc,\n\t\t\t       f_midi2_ep_in_complete);\n}\n\n \nstatic int f_midi2_init_midi2_ep_out(struct f_midi2 *midi2, int index)\n{\n\tstruct f_midi2_ep *ep = &midi2->midi2_eps[index];\n\tstruct usb_endpoint_descriptor *desc = &midi2_midi2_ep_out_desc[index];\n\n\tdesc->bLength = USB_DT_ENDPOINT_SIZE;\n\tdesc->bDescriptorType = USB_DT_ENDPOINT;\n\tdesc->bEndpointAddress = USB_DIR_OUT;\n\tdesc->bmAttributes = USB_ENDPOINT_XFER_BULK;\n\n\tfill_midi2_class_desc(ep, &midi2_midi2_ep_out_class_desc[index]);\n\n\treturn f_midi2_init_ep(midi2, ep, &ep->ep_out, desc,\n\t\t\t       f_midi2_ep_out_complete);\n}\n\n \nstatic int f_midi2_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_midi2 *midi2 = func_to_midi2(f);\n\tstruct f_midi2_ep *ep;\n\tstruct f_midi2_usb_config config = {};\n\tstruct usb_gadget_strings string_fn = {\n\t\t.language = 0x0409,\t \n\t\t.strings = midi2->string_defs,\n\t};\n\tstruct usb_gadget_strings *strings[] = {\n\t\t&string_fn,\n\t\tNULL,\n\t};\n\tint i, blk, status;\n\n\tmidi2->gadget = cdev->gadget;\n\tmidi2->operation_mode = MIDI_OP_MODE_UNSET;\n\n\tstatus = f_midi2_create_card(midi2);\n\tif (status < 0)\n\t\tgoto fail_register;\n\n\t \n\tmidi2->strings = usb_gstrings_attach(c->cdev, strings,\n\t\t\t\t\t     midi2->total_blocks + 1);\n\tif (IS_ERR(midi2->strings)) {\n\t\tstatus = PTR_ERR(midi2->strings);\n\t\tgoto fail_string;\n\t}\n\n\tmutex_lock(&f_midi2_desc_mutex);\n\tmidi2_midi1_if_desc.iInterface = midi2->strings[STR_IFACE].id;\n\tmidi2_midi2_if_desc.iInterface = midi2->strings[STR_IFACE].id;\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tep = &midi2->midi2_eps[i];\n\t\tfor (blk = 0; blk < ep->num_blks; blk++)\n\t\t\tep->blks[blk].string_id =\n\t\t\t\tmidi2->strings[gtb_to_str_id(ep->blks[blk].gtb_id)].id;\n\t}\n\n\tmidi2_midi2_if_desc.bNumEndpoints = midi2->num_eps * 2;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tmidi2_audio_if_desc.bInterfaceNumber = status;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tmidi2->midi_if = status;\n\tmidi2_midi1_if_desc.bInterfaceNumber = status;\n\tmidi2_midi2_if_desc.bInterfaceNumber = status;\n\tmidi2_audio_class_desc.baInterfaceNr[0] = status;\n\n\t \n\tif (midi2->midi2_eps[0].blks[0].info.direction != SNDRV_UMP_DIR_OUTPUT) {\n\t\tstatus = f_midi2_init_ep(midi2, NULL, &midi2->midi1_ep_in,\n\t\t\t\t\t &midi2_midi1_ep_in_desc,\n\t\t\t\t\t f_midi2_midi1_ep_in_complete);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tif (midi2->midi2_eps[0].blks[0].info.direction != SNDRV_UMP_DIR_INPUT) {\n\t\tstatus = f_midi2_init_ep(midi2, NULL, &midi2->midi1_ep_out,\n\t\t\t\t\t &midi2_midi1_ep_out_desc,\n\t\t\t\t\t f_midi2_midi1_ep_out_complete);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tstatus = f_midi2_init_midi2_ep_in(midi2, i);\n\t\tif (status)\n\t\t\tgoto fail;\n\t\tstatus = f_midi2_init_midi2_ep_out(midi2, i);\n\t\tif (status)\n\t\t\tgoto fail;\n\t}\n\n\tstatus = f_midi2_create_usb_configs(midi2, &config, USB_SPEED_FULL);\n\tif (status < 0)\n\t\tgoto fail;\n\tf->fs_descriptors = usb_copy_descriptors(config.list);\n\tif (!f->fs_descriptors) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tf_midi2_free_usb_configs(&config);\n\n\tstatus = f_midi2_create_usb_configs(midi2, &config, USB_SPEED_HIGH);\n\tif (status < 0)\n\t\tgoto fail;\n\tf->hs_descriptors = usb_copy_descriptors(config.list);\n\tif (!f->hs_descriptors) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tf_midi2_free_usb_configs(&config);\n\n\tstatus = f_midi2_create_usb_configs(midi2, &config, USB_SPEED_SUPER);\n\tif (status < 0)\n\t\tgoto fail;\n\tf->ss_descriptors = usb_copy_descriptors(config.list);\n\tif (!f->ss_descriptors) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tf_midi2_free_usb_configs(&config);\n\n\tmutex_unlock(&f_midi2_desc_mutex);\n\treturn 0;\n\nfail:\n\tf_midi2_free_usb_configs(&config);\n\tmutex_unlock(&f_midi2_desc_mutex);\n\tusb_free_all_descriptors(f);\nfail_string:\n\tf_midi2_free_card(midi2);\nfail_register:\n\tERROR(midi2, \"%s: can't bind, err %d\\n\", f->name, status);\n\treturn status;\n}\n\n \nstatic void f_midi2_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_midi2 *midi2 = func_to_midi2(f);\n\tint i;\n\n\tf_midi2_free_card(midi2);\n\n\tf_midi2_free_ep(&midi2->midi1_ep_in);\n\tf_midi2_free_ep(&midi2->midi1_ep_out);\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tf_midi2_free_ep(&midi2->midi2_eps[i].ep_in);\n\t\tf_midi2_free_ep(&midi2->midi2_eps[i].ep_out);\n\t}\n\n\tusb_free_all_descriptors(f);\n}\n\n \n\n \nstatic inline struct f_midi2_opts *to_f_midi2_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi2_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic inline struct f_midi2_ep_opts *\nto_f_midi2_ep_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi2_ep_opts,\n\t\t\t    group);\n}\n\nstatic inline struct f_midi2_block_opts *\nto_f_midi2_block_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_midi2_block_opts,\n\t\t\t    group);\n}\n\n \nstatic void make_name_string(char *s)\n{\n\tchar *p;\n\n\tp = strchr(s, '\\n');\n\tif (p)\n\t\t*p = 0;\n\n\tp = s + strlen(s);\n\tfor (; p > s && isspace(*p); p--)\n\t\t*p = 0;\n}\n\n \nstatic ssize_t f_midi2_opts_uint_show(struct f_midi2_opts *opts,\n\t\t\t\t      u32 val, const char *format, char *page)\n{\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, format, val);\n\tmutex_unlock(&opts->lock);\n\treturn result;\n}\n\nstatic ssize_t f_midi2_opts_uint_store(struct f_midi2_opts *opts,\n\t\t\t\t       u32 *valp, u32 minval, u32 maxval,\n\t\t\t\t       const char *page, size_t len)\n{\n\tint ret;\n\tu32 val;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &val);\n\tif (ret)\n\t\tgoto end;\n\tif (val < minval || val > maxval) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\t*valp = val;\n\tret = len;\n\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\n \nstatic ssize_t f_midi2_opts_bool_store(struct f_midi2_opts *opts,\n\t\t\t\t       bool *valp, const char *page, size_t len)\n{\n\tint ret;\n\tbool val;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtobool(page, &val);\n\tif (ret)\n\t\tgoto end;\n\t*valp = val;\n\tret = len;\n\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\n \nstatic ssize_t f_midi2_opts_str_show(struct f_midi2_opts *opts,\n\t\t\t\t     const char *str, char *page)\n{\n\tint result = 0;\n\n\tmutex_lock(&opts->lock);\n\tif (str)\n\t\tresult = scnprintf(page, PAGE_SIZE, \"%s\\n\", str);\n\tmutex_unlock(&opts->lock);\n\treturn result;\n}\n\nstatic ssize_t f_midi2_opts_str_store(struct f_midi2_opts *opts,\n\t\t\t\t      const char **strp, size_t maxlen,\n\t\t\t\t      const char *page, size_t len)\n{\n\tchar *c;\n\tint ret;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tc = kstrndup(page, min(len, maxlen), GFP_KERNEL);\n\tif (!c) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tkfree(*strp);\n\tmake_name_string(c);\n\t*strp = c;\n\tret = len;\n\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\n \n\n \n#define F_MIDI2_BLOCK_OPT(name, format, minval, maxval)\t\t\t\\\nstatic ssize_t f_midi2_block_opts_##name##_show(struct config_item *item,\\\n\t\t\t\t\t  char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\t\\\n\treturn f_midi2_opts_uint_show(opts->ep->opts, opts->info.name,\t\\\n\t\t\t\t      format \"\\n\", page);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_block_opts_##name##_store(struct config_item *item,\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\t\\\n\treturn f_midi2_opts_uint_store(opts->ep->opts, &opts->info.name,\\\n\t\t\t\t       minval, maxval, page, len);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi2_block_opts_, name)\n\n \n#define F_MIDI2_BLOCK_BOOL_OPT(name)\t\t\t\t\t\\\nstatic ssize_t f_midi2_block_opts_##name##_show(struct config_item *item,\\\n\t\t\t\t\t  char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\t\\\n\treturn f_midi2_opts_uint_show(opts->ep->opts, opts->info.name,\t\\\n\t\t\t\t      \"%u\\n\", page);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_block_opts_##name##_store(struct config_item *item,\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\t\\\n\treturn f_midi2_opts_bool_store(opts->ep->opts, &opts->info.name,\\\n\t\t\t\t       page, len);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi2_block_opts_, name)\n\nF_MIDI2_BLOCK_OPT(direction, \"0x%x\", 1, 3);\nF_MIDI2_BLOCK_OPT(first_group, \"0x%x\", 0, 15);\nF_MIDI2_BLOCK_OPT(num_groups, \"0x%x\", 1, 16);\nF_MIDI2_BLOCK_OPT(midi1_first_group, \"0x%x\", 0, 15);\nF_MIDI2_BLOCK_OPT(midi1_num_groups, \"0x%x\", 0, 16);\nF_MIDI2_BLOCK_OPT(ui_hint, \"0x%x\", 0, 3);\nF_MIDI2_BLOCK_OPT(midi_ci_version, \"%u\", 0, 1);\nF_MIDI2_BLOCK_OPT(sysex8_streams, \"%u\", 0, 255);\nF_MIDI2_BLOCK_OPT(is_midi1, \"%u\", 0, 2);\nF_MIDI2_BLOCK_BOOL_OPT(active);\n\nstatic ssize_t f_midi2_block_opts_name_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\n\n\treturn f_midi2_opts_str_show(opts->ep->opts, opts->info.name, page);\n}\n\nstatic ssize_t f_midi2_block_opts_name_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t len)\n{\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\n\n\treturn f_midi2_opts_str_store(opts->ep->opts, &opts->info.name, 128,\n\t\t\t\t      page, len);\n}\n\nCONFIGFS_ATTR(f_midi2_block_opts_, name);\n\nstatic struct configfs_attribute *f_midi2_block_attrs[] = {\n\t&f_midi2_block_opts_attr_direction,\n\t&f_midi2_block_opts_attr_first_group,\n\t&f_midi2_block_opts_attr_num_groups,\n\t&f_midi2_block_opts_attr_midi1_first_group,\n\t&f_midi2_block_opts_attr_midi1_num_groups,\n\t&f_midi2_block_opts_attr_ui_hint,\n\t&f_midi2_block_opts_attr_midi_ci_version,\n\t&f_midi2_block_opts_attr_sysex8_streams,\n\t&f_midi2_block_opts_attr_is_midi1,\n\t&f_midi2_block_opts_attr_active,\n\t&f_midi2_block_opts_attr_name,\n\tNULL,\n};\n\nstatic void f_midi2_block_opts_release(struct config_item *item)\n{\n\tstruct f_midi2_block_opts *opts = to_f_midi2_block_opts(item);\n\n\tkfree(opts->info.name);\n\tkfree(opts);\n}\n\nstatic struct configfs_item_operations f_midi2_block_item_ops = {\n\t.release\t= f_midi2_block_opts_release,\n};\n\nstatic const struct config_item_type f_midi2_block_type = {\n\t.ct_item_ops\t= &f_midi2_block_item_ops,\n\t.ct_attrs\t= f_midi2_block_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic int f_midi2_block_opts_create(struct f_midi2_ep_opts *ep_opts,\n\t\t\t\t     unsigned int blk,\n\t\t\t\t     struct f_midi2_block_opts **block_p)\n{\n\tstruct f_midi2_block_opts *block_opts;\n\tint ret = 0;\n\n\tmutex_lock(&ep_opts->opts->lock);\n\tif (ep_opts->opts->refcnt || ep_opts->blks[blk]) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tblock_opts = kzalloc(sizeof(*block_opts), GFP_KERNEL);\n\tif (!block_opts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tblock_opts->ep = ep_opts;\n\tblock_opts->id = blk;\n\n\t \n\tblock_opts->info.direction = SNDRV_UMP_DIR_BIDIRECTION;\n\tblock_opts->info.first_group = 0;\n\tblock_opts->info.num_groups = 1;\n\tblock_opts->info.ui_hint = SNDRV_UMP_BLOCK_UI_HINT_BOTH;\n\tblock_opts->info.active = 1;\n\n\tep_opts->blks[blk] = block_opts;\n\t*block_p = block_opts;\n\n out:\n\tmutex_unlock(&ep_opts->opts->lock);\n\treturn ret;\n}\n\n \nstatic struct config_group *\nf_midi2_opts_block_make(struct config_group *group, const char *name)\n{\n\tstruct f_midi2_ep_opts *ep_opts;\n\tstruct f_midi2_block_opts *block_opts;\n\tunsigned int blk;\n\tint ret;\n\n\tif (strncmp(name, \"block.\", 6))\n\t\treturn ERR_PTR(-EINVAL);\n\tret = kstrtouint(name + 6, 10, &blk);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tep_opts = to_f_midi2_ep_opts(&group->cg_item);\n\n\tif (blk >= SNDRV_UMP_MAX_BLOCKS)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (ep_opts->blks[blk])\n\t\treturn ERR_PTR(-EBUSY);\n\tret = f_midi2_block_opts_create(ep_opts, blk, &block_opts);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tconfig_group_init_type_name(&block_opts->group, name,\n\t\t\t\t    &f_midi2_block_type);\n\treturn &block_opts->group;\n}\n\n \nstatic void\nf_midi2_opts_block_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct f_midi2_block_opts *block_opts = to_f_midi2_block_opts(item);\n\n\tmutex_lock(&block_opts->ep->opts->lock);\n\tblock_opts->ep->blks[block_opts->id] = NULL;\n\tmutex_unlock(&block_opts->ep->opts->lock);\n\tconfig_item_put(item);\n}\n\n \n\n \n#define F_MIDI2_EP_OPT(name, format, minval, maxval)\t\t\t\\\nstatic ssize_t f_midi2_ep_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t     char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_ep_opts *opts = to_f_midi2_ep_opts(item);\t\\\n\treturn f_midi2_opts_uint_show(opts->opts, opts->info.name,\t\\\n\t\t\t\t      format \"\\n\", page);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_ep_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t   const char *page, size_t len)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_ep_opts *opts = to_f_midi2_ep_opts(item);\t\\\n\treturn f_midi2_opts_uint_store(opts->opts, &opts->info.name,\t\\\n\t\t\t\t       minval, maxval, page, len);\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi2_ep_opts_, name)\n\n \n#define F_MIDI2_EP_STR_OPT(name, maxlen)\t\t\t\t\\\nstatic ssize_t f_midi2_ep_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t     char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_ep_opts *opts = to_f_midi2_ep_opts(item);\t\\\n\treturn f_midi2_opts_str_show(opts->opts, opts->info.name, page);\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_ep_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_ep_opts *opts = to_f_midi2_ep_opts(item);\t\\\n\treturn f_midi2_opts_str_store(opts->opts, &opts->info.name, maxlen,\\\n\t\t\t\t      page, len);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi2_ep_opts_, name)\n\nF_MIDI2_EP_OPT(protocol, \"0x%x\", 1, 2);\nF_MIDI2_EP_OPT(protocol_caps, \"0x%x\", 1, 3);\nF_MIDI2_EP_OPT(manufacturer, \"0x%x\", 0, 0xffffff);\nF_MIDI2_EP_OPT(family, \"0x%x\", 0, 0xffff);\nF_MIDI2_EP_OPT(model, \"0x%x\", 0, 0xffff);\nF_MIDI2_EP_OPT(sw_revision, \"0x%x\", 0, 0xffffffff);\nF_MIDI2_EP_STR_OPT(ep_name, 128);\nF_MIDI2_EP_STR_OPT(product_id, 128);\n\nstatic struct configfs_attribute *f_midi2_ep_attrs[] = {\n\t&f_midi2_ep_opts_attr_protocol,\n\t&f_midi2_ep_opts_attr_protocol_caps,\n\t&f_midi2_ep_opts_attr_ep_name,\n\t&f_midi2_ep_opts_attr_product_id,\n\t&f_midi2_ep_opts_attr_manufacturer,\n\t&f_midi2_ep_opts_attr_family,\n\t&f_midi2_ep_opts_attr_model,\n\t&f_midi2_ep_opts_attr_sw_revision,\n\tNULL,\n};\n\nstatic void f_midi2_ep_opts_release(struct config_item *item)\n{\n\tstruct f_midi2_ep_opts *opts = to_f_midi2_ep_opts(item);\n\n\tkfree(opts->info.ep_name);\n\tkfree(opts->info.product_id);\n\tkfree(opts);\n}\n\nstatic struct configfs_item_operations f_midi2_ep_item_ops = {\n\t.release\t= f_midi2_ep_opts_release,\n};\n\nstatic struct configfs_group_operations f_midi2_ep_group_ops = {\n\t.make_group\t= f_midi2_opts_block_make,\n\t.drop_item\t= f_midi2_opts_block_drop,\n};\n\nstatic const struct config_item_type f_midi2_ep_type = {\n\t.ct_item_ops\t= &f_midi2_ep_item_ops,\n\t.ct_group_ops\t= &f_midi2_ep_group_ops,\n\t.ct_attrs\t= f_midi2_ep_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \nstatic int f_midi2_ep_opts_create(struct f_midi2_opts *opts,\n\t\t\t\t  unsigned int index,\n\t\t\t\t  struct f_midi2_ep_opts **ep_p)\n{\n\tstruct f_midi2_ep_opts *ep_opts;\n\n\tep_opts = kzalloc(sizeof(*ep_opts), GFP_KERNEL);\n\tif (!ep_opts)\n\t\treturn -ENOMEM;\n\n\tep_opts->opts = opts;\n\tep_opts->index = index;\n\n\t \n\tep_opts->info.protocol = 2;\n\tep_opts->info.protocol_caps = 3;\n\n\topts->eps[index] = ep_opts;\n\t*ep_p = ep_opts;\n\treturn 0;\n}\n\n \nstatic struct config_group *\nf_midi2_opts_ep_make(struct config_group *group, const char *name)\n{\n\tstruct f_midi2_opts *opts;\n\tstruct f_midi2_ep_opts *ep_opts;\n\tunsigned int index;\n\tint ret;\n\n\tif (strncmp(name, \"ep.\", 3))\n\t\treturn ERR_PTR(-EINVAL);\n\tret = kstrtouint(name + 3, 10, &index);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\topts = to_f_midi2_opts(&group->cg_item);\n\tif (index >= MAX_UMP_EPS)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (opts->eps[index])\n\t\treturn ERR_PTR(-EBUSY);\n\tret = f_midi2_ep_opts_create(opts, index, &ep_opts);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tconfig_group_init_type_name(&ep_opts->group, name, &f_midi2_ep_type);\n\treturn &ep_opts->group;\n}\n\n \nstatic void\nf_midi2_opts_ep_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct f_midi2_ep_opts *ep_opts = to_f_midi2_ep_opts(item);\n\n\tmutex_lock(&ep_opts->opts->lock);\n\tep_opts->opts->eps[ep_opts->index] = NULL;\n\tmutex_unlock(&ep_opts->opts->lock);\n\tconfig_item_put(item);\n}\n\n \n\n \n#define F_MIDI2_BOOL_OPT(name)\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t  char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_opts *opts = to_f_midi2_opts(item);\t\t\\\n\treturn f_midi2_opts_uint_show(opts, opts->info.name,\t\t\\\n\t\t\t\t      \"%u\\n\", page);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_midi2_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_midi2_opts *opts = to_f_midi2_opts(item);\t\t\\\n\treturn f_midi2_opts_bool_store(opts, &opts->info.name,\t\t\\\n\t\t\t\t       page, len);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_midi2_opts_, name)\n\nF_MIDI2_BOOL_OPT(process_ump);\nF_MIDI2_BOOL_OPT(static_block);\n\nstatic ssize_t f_midi2_opts_iface_name_show(struct config_item *item,\n\t\t\t\t\t    char *page)\n{\n\tstruct f_midi2_opts *opts = to_f_midi2_opts(item);\n\n\treturn f_midi2_opts_str_show(opts, opts->info.iface_name, page);\n}\n\nstatic ssize_t f_midi2_opts_iface_name_store(struct config_item *item,\n\t\t\t\t\t     const char *page, size_t len)\n{\n\tstruct f_midi2_opts *opts = to_f_midi2_opts(item);\n\n\treturn f_midi2_opts_str_store(opts, &opts->info.iface_name, 128,\n\t\t\t\t      page, len);\n}\n\nCONFIGFS_ATTR(f_midi2_opts_, iface_name);\n\nstatic struct configfs_attribute *f_midi2_attrs[] = {\n\t&f_midi2_opts_attr_process_ump,\n\t&f_midi2_opts_attr_static_block,\n\t&f_midi2_opts_attr_iface_name,\n\tNULL\n};\n\nstatic void f_midi2_opts_release(struct config_item *item)\n{\n\tstruct f_midi2_opts *opts = to_f_midi2_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations f_midi2_item_ops = {\n\t.release\t= f_midi2_opts_release,\n};\n\nstatic struct configfs_group_operations f_midi2_group_ops = {\n\t.make_group\t= f_midi2_opts_ep_make,\n\t.drop_item\t= f_midi2_opts_ep_drop,\n};\n\nstatic const struct config_item_type f_midi2_func_type = {\n\t.ct_item_ops\t= &f_midi2_item_ops,\n\t.ct_group_ops\t= &f_midi2_group_ops,\n\t.ct_attrs\t= f_midi2_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_midi2_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_midi2_opts *opts;\n\n\topts = container_of(f, struct f_midi2_opts, func_inst);\n\n\tkfree(opts->info.iface_name);\n\tkfree(opts);\n}\n\n \nstatic struct usb_function_instance *f_midi2_alloc_inst(void)\n{\n\tstruct f_midi2_opts *opts;\n\tstruct f_midi2_ep_opts *ep_opts;\n\tstruct f_midi2_block_opts *block_opts;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_midi2_free_inst;\n\topts->info.process_ump = true;\n\topts->info.static_block = true;\n\topts->info.num_reqs = 32;\n\topts->info.req_buf_size = 512;\n\n\t \n\tret = f_midi2_ep_opts_create(opts, 0, &ep_opts);\n\tif (ret) {\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tret = f_midi2_block_opts_create(ep_opts, 0, &block_opts);\n\tif (ret) {\n\t\tkfree(ep_opts);\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tblock_opts->info.midi1_num_groups = 1;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &f_midi2_func_type);\n\n\tconfig_group_init_type_name(&ep_opts->group, \"ep.0\",\n\t\t\t\t    &f_midi2_ep_type);\n\tconfigfs_add_default_group(&ep_opts->group, &opts->func_inst.group);\n\n\tconfig_group_init_type_name(&block_opts->group, \"block.0\",\n\t\t\t\t    &f_midi2_block_type);\n\tconfigfs_add_default_group(&block_opts->group, &ep_opts->group);\n\n\treturn &opts->func_inst;\n}\n\nstatic void do_f_midi2_free(struct f_midi2 *midi2, struct f_midi2_opts *opts)\n{\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\tkfree(midi2->string_defs);\n\tkfree(midi2);\n}\n\nstatic void f_midi2_free(struct usb_function *f)\n{\n\tdo_f_midi2_free(func_to_midi2(f),\n\t\t\tcontainer_of(f->fi, struct f_midi2_opts, func_inst));\n}\n\n \nstatic int verify_parameters(struct f_midi2_opts *opts)\n{\n\tint i, j, num_eps, num_blks;\n\tstruct f_midi2_ep_info *ep;\n\tstruct f_midi2_block_info *bp;\n\n\tfor (num_eps = 0; num_eps < MAX_UMP_EPS && opts->eps[num_eps];\n\t     num_eps++)\n\t\t;\n\tif (!num_eps) {\n\t\tpr_err(\"f_midi2: No EP is defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tnum_blks = 0;\n\tfor (i = 0; i < num_eps; i++) {\n\t\tep = &opts->eps[i]->info;\n\t\tif (!(ep->protocol_caps & ep->protocol)) {\n\t\t\tpr_err(\"f_midi2: Invalid protocol 0x%x (caps 0x%x) for EP %d\\n\",\n\t\t\t       ep->protocol, ep->protocol_caps, i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (j = 0; j < SNDRV_UMP_MAX_BLOCKS && opts->eps[i]->blks[j];\n\t\t     j++, num_blks++) {\n\t\t\tbp = &opts->eps[i]->blks[j]->info;\n\t\t\tif (bp->first_group + bp->num_groups > SNDRV_UMP_MAX_GROUPS) {\n\t\t\t\tpr_err(\"f_midi2: Invalid group definitions for block %d:%d\\n\",\n\t\t\t\t       i, j);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tif (bp->midi1_num_groups) {\n\t\t\t\tif (bp->midi1_first_group < bp->first_group ||\n\t\t\t\t    bp->midi1_first_group + bp->midi1_num_groups >\n\t\t\t\t    bp->first_group + bp->num_groups) {\n\t\t\t\t\tpr_err(\"f_midi2: Invalid MIDI1 group definitions for block %d:%d\\n\",\n\t\t\t\t\t       i, j);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (!num_blks) {\n\t\tpr_err(\"f_midi2: No block is defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn num_eps;\n}\n\n \nstatic void fill_midi1_cable_mapping(struct f_midi2 *midi2,\n\t\t\t\t     struct f_midi2_ep *ep,\n\t\t\t\t     int blk)\n{\n\tconst struct f_midi2_block_info *binfo = &ep->blks[blk].info;\n\tstruct midi1_cable_mapping *map;\n\tint i, group;\n\n\tif (!binfo->midi1_num_groups)\n\t\treturn;\n\tif (binfo->direction != SNDRV_UMP_DIR_OUTPUT) {\n\t\tgroup = binfo->midi1_first_group;\n\t\tmap = midi2->in_cable_mapping + midi2->num_midi1_in;\n\t\tfor (i = 0; i < binfo->midi1_num_groups; i++, group++, map++) {\n\t\t\tif (midi2->num_midi1_in >= MAX_CABLES)\n\t\t\t\tbreak;\n\t\t\tmap->ep = ep;\n\t\t\tmap->block = blk;\n\t\t\tmap->group = group;\n\t\t\tmidi2->num_midi1_in++;\n\t\t\t \n\t\t\tep->in_group_to_cable[group] = midi2->num_midi1_in;\n\t\t}\n\t}\n\n\tif (binfo->direction != SNDRV_UMP_DIR_INPUT) {\n\t\tgroup = binfo->midi1_first_group;\n\t\tmap = midi2->out_cable_mapping + midi2->num_midi1_out;\n\t\tfor (i = 0; i < binfo->midi1_num_groups; i++, group++, map++) {\n\t\t\tif (midi2->num_midi1_out >= MAX_CABLES)\n\t\t\t\tbreak;\n\t\t\tmap->ep = ep;\n\t\t\tmap->block = blk;\n\t\t\tmap->group = group;\n\t\t\tmidi2->num_midi1_out++;\n\t\t}\n\t}\n}\n\n \nstatic struct usb_function *f_midi2_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_midi2 *midi2;\n\tstruct f_midi2_opts *opts;\n\tstruct f_midi2_ep *ep;\n\tstruct f_midi2_block *bp;\n\tint i, num_eps, blk;\n\n\tmidi2 = kzalloc(sizeof(*midi2), GFP_KERNEL);\n\tif (!midi2)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_midi2_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\tnum_eps = verify_parameters(opts);\n\tif (num_eps < 0) {\n\t\tmutex_unlock(&opts->lock);\n\t\tkfree(midi2);\n\t\treturn ERR_PTR(num_eps);\n\t}\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\n\tspin_lock_init(&midi2->queue_lock);\n\n\tmidi2->func.name = \"midi2_func\";\n\tmidi2->func.bind = f_midi2_bind;\n\tmidi2->func.unbind = f_midi2_unbind;\n\tmidi2->func.get_alt = f_midi2_get_alt;\n\tmidi2->func.set_alt = f_midi2_set_alt;\n\tmidi2->func.setup = f_midi2_setup;\n\tmidi2->func.disable = f_midi2_disable;\n\tmidi2->func.free_func = f_midi2_free;\n\n\tmidi2->info = opts->info;\n\tmidi2->num_eps = num_eps;\n\n\tfor (i = 0; i < num_eps; i++) {\n\t\tep = &midi2->midi2_eps[i];\n\t\tep->info = opts->eps[i]->info;\n\t\tep->card = midi2;\n\t\tfor (blk = 0; blk < SNDRV_UMP_MAX_BLOCKS &&\n\t\t\t     opts->eps[i]->blks[blk]; blk++) {\n\t\t\tbp = &ep->blks[blk];\n\t\t\tep->num_blks++;\n\t\t\tbp->info = opts->eps[i]->blks[blk]->info;\n\t\t\tbp->gtb_id = ++midi2->total_blocks;\n\t\t}\n\t}\n\n\tmidi2->string_defs = kcalloc(midi2->total_blocks + 1,\n\t\t\t\t     sizeof(*midi2->string_defs), GFP_KERNEL);\n\tif (!midi2->string_defs) {\n\t\tdo_f_midi2_free(midi2, opts);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tif (opts->info.iface_name && *opts->info.iface_name)\n\t\tmidi2->string_defs[STR_IFACE].s = opts->info.iface_name;\n\telse\n\t\tmidi2->string_defs[STR_IFACE].s = ump_ep_name(&midi2->midi2_eps[0]);\n\n\tfor (i = 0; i < midi2->num_eps; i++) {\n\t\tep = &midi2->midi2_eps[i];\n\t\tfor (blk = 0; blk < ep->num_blks; blk++) {\n\t\t\tbp = &ep->blks[blk];\n\t\t\tmidi2->string_defs[gtb_to_str_id(bp->gtb_id)].s =\n\t\t\t\tump_fb_name(&bp->info);\n\n\t\t\tfill_midi1_cable_mapping(midi2, ep, blk);\n\t\t}\n\t}\n\n\tif (!midi2->num_midi1_in && !midi2->num_midi1_out) {\n\t\tpr_err(\"f_midi2: MIDI1 definition is missing\\n\");\n\t\tdo_f_midi2_free(midi2, opts);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn &midi2->func;\n}\n\nDECLARE_USB_FUNCTION_INIT(midi2, f_midi2_alloc_inst, f_midi2_alloc);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}