{
  "module_name": "f_tcm.c",
  "hash_id": "9b09cd460233edc37820b68dc0b053fcb6ec56c9dac0143400503811bccbf9d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_tcm.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/storage.h>\n#include <scsi/scsi_tcq.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <asm/unaligned.h>\n\n#include \"tcm.h\"\n#include \"u_tcm.h\"\n#include \"configfs.h\"\n\n#define TPG_INSTANCES\t\t1\n\nstruct tpg_instance {\n\tstruct usb_function_instance\t*func_inst;\n\tstruct usbg_tpg\t\t\t*tpg;\n};\n\nstatic struct tpg_instance tpg_instances[TPG_INSTANCES];\n\nstatic DEFINE_MUTEX(tpg_instances_lock);\n\nstatic inline struct f_uas *to_f_uas(struct usb_function *f)\n{\n\treturn container_of(f, struct f_uas, function);\n}\n\n \n\nstatic int bot_enqueue_cmd_cbw(struct f_uas *fu)\n{\n\tint ret;\n\n\tif (fu->flags & USBG_BOT_CMD_PEND)\n\t\treturn 0;\n\n\tret = usb_ep_queue(fu->ep_out, fu->cmd.req, GFP_ATOMIC);\n\tif (!ret)\n\t\tfu->flags |= USBG_BOT_CMD_PEND;\n\treturn ret;\n}\n\nstatic void bot_status_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbg_cmd *cmd = req->context;\n\tstruct f_uas *fu = cmd->fu;\n\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\tif (req->status < 0) {\n\t\tpr_err(\"ERR %s(%d)\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\t \n\tbot_enqueue_cmd_cbw(fu);\n}\n\nstatic void bot_enqueue_sense_code(struct f_uas *fu, struct usbg_cmd *cmd)\n{\n\tstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\n\tint ret;\n\tunsigned int csw_stat;\n\n\tcsw_stat = cmd->csw_code;\n\tcsw->Tag = cmd->bot_tag;\n\tcsw->Status = csw_stat;\n\tfu->bot_status.req->context = cmd;\n\tret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_ATOMIC);\n\tif (ret)\n\t\tpr_err(\"%s(%d) ERR: %d\\n\", __func__, __LINE__, ret);\n}\n\nstatic void bot_err_compl(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbg_cmd *cmd = req->context;\n\tstruct f_uas *fu = cmd->fu;\n\n\tif (req->status < 0)\n\t\tpr_err(\"ERR %s(%d)\\n\", __func__, __LINE__);\n\n\tif (cmd->data_len) {\n\t\tif (cmd->data_len > ep->maxpacket) {\n\t\t\treq->length = ep->maxpacket;\n\t\t\tcmd->data_len -= ep->maxpacket;\n\t\t} else {\n\t\t\treq->length = cmd->data_len;\n\t\t\tcmd->data_len = 0;\n\t\t}\n\n\t\tusb_ep_queue(ep, req, GFP_ATOMIC);\n\t\treturn;\n\t}\n\tbot_enqueue_sense_code(fu, cmd);\n}\n\nstatic void bot_send_bad_status(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\n\tstruct usb_request *req;\n\tstruct usb_ep *ep;\n\n\tcsw->Residue = cpu_to_le32(cmd->data_len);\n\n\tif (cmd->data_len) {\n\t\tif (cmd->is_read) {\n\t\t\tep = fu->ep_in;\n\t\t\treq = fu->bot_req_in;\n\t\t} else {\n\t\t\tep = fu->ep_out;\n\t\t\treq = fu->bot_req_out;\n\t\t}\n\n\t\tif (cmd->data_len > fu->ep_in->maxpacket) {\n\t\t\treq->length = ep->maxpacket;\n\t\t\tcmd->data_len -= ep->maxpacket;\n\t\t} else {\n\t\t\treq->length = cmd->data_len;\n\t\t\tcmd->data_len = 0;\n\t\t}\n\t\treq->complete = bot_err_compl;\n\t\treq->context = cmd;\n\t\treq->buf = fu->cmd.buf;\n\t\tusb_ep_queue(ep, req, GFP_KERNEL);\n\t} else {\n\t\tbot_enqueue_sense_code(fu, cmd);\n\t}\n}\n\nstatic int bot_send_status(struct usbg_cmd *cmd, bool moved_data)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct bulk_cs_wrap *csw = &fu->bot_status.csw;\n\tint ret;\n\n\tif (cmd->se_cmd.scsi_status == SAM_STAT_GOOD) {\n\t\tif (!moved_data && cmd->data_len) {\n\t\t\t \n\t\t\tcmd->csw_code = US_BULK_STAT_OK;\n\t\t\tbot_send_bad_status(cmd);\n\t\t\treturn 0;\n\t\t}\n\n\t\tcsw->Tag = cmd->bot_tag;\n\t\tcsw->Residue = cpu_to_le32(0);\n\t\tcsw->Status = US_BULK_STAT_OK;\n\t\tfu->bot_status.req->context = cmd;\n\n\t\tret = usb_ep_queue(fu->ep_in, fu->bot_status.req, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d) ERR: %d\\n\", __func__, __LINE__, ret);\n\t} else {\n\t\tcmd->csw_code = US_BULK_STAT_FAIL;\n\t\tbot_send_bad_status(cmd);\n\t}\n\treturn 0;\n}\n\n \nstatic int bot_send_status_response(struct usbg_cmd *cmd)\n{\n\tbool moved_data = false;\n\n\tif (!cmd->is_read)\n\t\tmoved_data = true;\n\treturn bot_send_status(cmd, moved_data);\n}\n\n \nstatic void bot_read_compl(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbg_cmd *cmd = req->context;\n\n\tif (req->status < 0)\n\t\tpr_err(\"ERR %s(%d)\\n\", __func__, __LINE__);\n\n\tbot_send_status(cmd, true);\n}\n\nstatic int bot_send_read_response(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct usb_gadget *gadget = fuas_to_gadget(fu);\n\tint ret;\n\n\tif (!cmd->data_len) {\n\t\tcmd->csw_code = US_BULK_STAT_PHASE;\n\t\tbot_send_bad_status(cmd);\n\t\treturn 0;\n\t}\n\n\tif (!gadget->sg_supported) {\n\t\tcmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\n\t\tif (!cmd->data_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_copy_to_buffer(se_cmd->t_data_sg,\n\t\t\t\tse_cmd->t_data_nents,\n\t\t\t\tcmd->data_buf,\n\t\t\t\tse_cmd->data_length);\n\n\t\tfu->bot_req_in->buf = cmd->data_buf;\n\t} else {\n\t\tfu->bot_req_in->buf = NULL;\n\t\tfu->bot_req_in->num_sgs = se_cmd->t_data_nents;\n\t\tfu->bot_req_in->sg = se_cmd->t_data_sg;\n\t}\n\n\tfu->bot_req_in->complete = bot_read_compl;\n\tfu->bot_req_in->length = se_cmd->data_length;\n\tfu->bot_req_in->context = cmd;\n\tret = usb_ep_queue(fu->ep_in, fu->bot_req_in, GFP_ATOMIC);\n\tif (ret)\n\t\tpr_err(\"%s(%d)\\n\", __func__, __LINE__);\n\treturn 0;\n}\n\nstatic void usbg_data_write_cmpl(struct usb_ep *, struct usb_request *);\nstatic int usbg_prepare_w_request(struct usbg_cmd *, struct usb_request *);\n\nstatic int bot_send_write_request(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct usb_gadget *gadget = fuas_to_gadget(fu);\n\tint ret;\n\n\tinit_completion(&cmd->write_complete);\n\tcmd->fu = fu;\n\n\tif (!cmd->data_len) {\n\t\tcmd->csw_code = US_BULK_STAT_PHASE;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!gadget->sg_supported) {\n\t\tcmd->data_buf = kmalloc(se_cmd->data_length, GFP_KERNEL);\n\t\tif (!cmd->data_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tfu->bot_req_out->buf = cmd->data_buf;\n\t} else {\n\t\tfu->bot_req_out->buf = NULL;\n\t\tfu->bot_req_out->num_sgs = se_cmd->t_data_nents;\n\t\tfu->bot_req_out->sg = se_cmd->t_data_sg;\n\t}\n\n\tfu->bot_req_out->complete = usbg_data_write_cmpl;\n\tfu->bot_req_out->length = se_cmd->data_length;\n\tfu->bot_req_out->context = cmd;\n\n\tret = usbg_prepare_w_request(cmd, fu->bot_req_out);\n\tif (ret)\n\t\tgoto cleanup;\n\tret = usb_ep_queue(fu->ep_out, fu->bot_req_out, GFP_KERNEL);\n\tif (ret)\n\t\tpr_err(\"%s(%d)\\n\", __func__, __LINE__);\n\n\twait_for_completion(&cmd->write_complete);\n\ttarget_execute_cmd(se_cmd);\ncleanup:\n\treturn ret;\n}\n\nstatic int bot_submit_command(struct f_uas *, void *, unsigned int);\n\nstatic void bot_cmd_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_uas *fu = req->context;\n\tint ret;\n\n\tfu->flags &= ~USBG_BOT_CMD_PEND;\n\n\tif (req->status < 0)\n\t\treturn;\n\n\tret = bot_submit_command(fu, req->buf, req->actual);\n\tif (ret)\n\t\tpr_err(\"%s(%d): %d\\n\", __func__, __LINE__, ret);\n}\n\nstatic int bot_prepare_reqs(struct f_uas *fu)\n{\n\tint ret;\n\n\tfu->bot_req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\n\tif (!fu->bot_req_in)\n\t\tgoto err;\n\n\tfu->bot_req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\n\tif (!fu->bot_req_out)\n\t\tgoto err_out;\n\n\tfu->cmd.req = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\n\tif (!fu->cmd.req)\n\t\tgoto err_cmd;\n\n\tfu->bot_status.req = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\n\tif (!fu->bot_status.req)\n\t\tgoto err_sts;\n\n\tfu->bot_status.req->buf = &fu->bot_status.csw;\n\tfu->bot_status.req->length = US_BULK_CS_WRAP_LEN;\n\tfu->bot_status.req->complete = bot_status_complete;\n\tfu->bot_status.csw.Signature = cpu_to_le32(US_BULK_CS_SIGN);\n\n\tfu->cmd.buf = kmalloc(fu->ep_out->maxpacket, GFP_KERNEL);\n\tif (!fu->cmd.buf)\n\t\tgoto err_buf;\n\n\tfu->cmd.req->complete = bot_cmd_complete;\n\tfu->cmd.req->buf = fu->cmd.buf;\n\tfu->cmd.req->length = fu->ep_out->maxpacket;\n\tfu->cmd.req->context = fu;\n\n\tret = bot_enqueue_cmd_cbw(fu);\n\tif (ret)\n\t\tgoto err_queue;\n\treturn 0;\nerr_queue:\n\tkfree(fu->cmd.buf);\n\tfu->cmd.buf = NULL;\nerr_buf:\n\tusb_ep_free_request(fu->ep_in, fu->bot_status.req);\nerr_sts:\n\tusb_ep_free_request(fu->ep_out, fu->cmd.req);\n\tfu->cmd.req = NULL;\nerr_cmd:\n\tusb_ep_free_request(fu->ep_out, fu->bot_req_out);\n\tfu->bot_req_out = NULL;\nerr_out:\n\tusb_ep_free_request(fu->ep_in, fu->bot_req_in);\n\tfu->bot_req_in = NULL;\nerr:\n\tpr_err(\"BOT: endpoint setup failed\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void bot_cleanup_old_alt(struct f_uas *fu)\n{\n\tif (!(fu->flags & USBG_ENABLED))\n\t\treturn;\n\n\tusb_ep_disable(fu->ep_in);\n\tusb_ep_disable(fu->ep_out);\n\n\tif (!fu->bot_req_in)\n\t\treturn;\n\n\tusb_ep_free_request(fu->ep_in, fu->bot_req_in);\n\tusb_ep_free_request(fu->ep_out, fu->bot_req_out);\n\tusb_ep_free_request(fu->ep_out, fu->cmd.req);\n\tusb_ep_free_request(fu->ep_in, fu->bot_status.req);\n\n\tkfree(fu->cmd.buf);\n\n\tfu->bot_req_in = NULL;\n\tfu->bot_req_out = NULL;\n\tfu->cmd.req = NULL;\n\tfu->bot_status.req = NULL;\n\tfu->cmd.buf = NULL;\n}\n\nstatic void bot_set_alt(struct f_uas *fu)\n{\n\tstruct usb_function *f = &fu->function;\n\tstruct usb_gadget *gadget = f->config->cdev->gadget;\n\tint ret;\n\n\tfu->flags = USBG_IS_BOT;\n\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_in, USB_G_ALT_INT_BBB);\n\tret = usb_ep_enable(fu->ep_in);\n\tif (ret)\n\t\tgoto err_b_in;\n\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_out, USB_G_ALT_INT_BBB);\n\tret = usb_ep_enable(fu->ep_out);\n\tif (ret)\n\t\tgoto err_b_out;\n\n\tret = bot_prepare_reqs(fu);\n\tif (ret)\n\t\tgoto err_wq;\n\tfu->flags |= USBG_ENABLED;\n\tpr_info(\"Using the BOT protocol\\n\");\n\treturn;\nerr_wq:\n\tusb_ep_disable(fu->ep_out);\nerr_b_out:\n\tusb_ep_disable(fu->ep_in);\nerr_b_in:\n\tfu->flags = USBG_IS_BOT;\n}\n\nstatic int usbg_bot_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_uas *fu = to_f_uas(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tu16 w_value = le16_to_cpu(ctrl->wValue);\n\tu16 w_length = le16_to_cpu(ctrl->wLength);\n\tint luns;\n\tu8 *ret_lun;\n\n\tswitch (ctrl->bRequest) {\n\tcase US_BULK_GET_MAX_LUN:\n\t\tif (ctrl->bRequestType != (USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t\t\tUSB_RECIP_INTERFACE))\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (w_length < 1)\n\t\t\treturn -EINVAL;\n\t\tif (w_value != 0)\n\t\t\treturn -EINVAL;\n\t\tluns = atomic_read(&fu->tpg->tpg_port_count);\n\t\tif (!luns) {\n\t\t\tpr_err(\"No LUNs configured?\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tluns--;\n\t\tif (luns > 0xf) {\n\t\t\tpr_info_once(\"Limiting the number of luns to 16\\n\");\n\t\t\tluns = 0xf;\n\t\t}\n\t\tret_lun = cdev->req->buf;\n\t\t*ret_lun = luns;\n\t\tcdev->req->length = 1;\n\t\treturn usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);\n\n\tcase US_BULK_RESET_REQUEST:\n\t\t \n\t\tbot_enqueue_cmd_cbw(fu);\n\t\treturn 0;\n\t}\n\treturn -ENOTSUPP;\n}\n\n \n\nstatic void uasp_cleanup_one_stream(struct f_uas *fu, struct uas_stream *stream)\n{\n\t \n\tif (!stream->req_in)\n\t\treturn;\n\n\tusb_ep_free_request(fu->ep_in, stream->req_in);\n\tusb_ep_free_request(fu->ep_out, stream->req_out);\n\tusb_ep_free_request(fu->ep_status, stream->req_status);\n\n\tstream->req_in = NULL;\n\tstream->req_out = NULL;\n\tstream->req_status = NULL;\n}\n\nstatic void uasp_free_cmdreq(struct f_uas *fu)\n{\n\tusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\n\tkfree(fu->cmd.buf);\n\tfu->cmd.req = NULL;\n\tfu->cmd.buf = NULL;\n}\n\nstatic void uasp_cleanup_old_alt(struct f_uas *fu)\n{\n\tint i;\n\n\tif (!(fu->flags & USBG_ENABLED))\n\t\treturn;\n\n\tusb_ep_disable(fu->ep_in);\n\tusb_ep_disable(fu->ep_out);\n\tusb_ep_disable(fu->ep_status);\n\tusb_ep_disable(fu->ep_cmd);\n\n\tfor (i = 0; i < UASP_SS_EP_COMP_NUM_STREAMS; i++)\n\t\tuasp_cleanup_one_stream(fu, &fu->stream[i]);\n\tuasp_free_cmdreq(fu);\n}\n\nstatic void uasp_status_data_cmpl(struct usb_ep *ep, struct usb_request *req);\n\nstatic int uasp_prepare_r_request(struct usbg_cmd *cmd)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct f_uas *fu = cmd->fu;\n\tstruct usb_gadget *gadget = fuas_to_gadget(fu);\n\tstruct uas_stream *stream = cmd->stream;\n\n\tif (!gadget->sg_supported) {\n\t\tcmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\n\t\tif (!cmd->data_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tsg_copy_to_buffer(se_cmd->t_data_sg,\n\t\t\t\tse_cmd->t_data_nents,\n\t\t\t\tcmd->data_buf,\n\t\t\t\tse_cmd->data_length);\n\n\t\tstream->req_in->buf = cmd->data_buf;\n\t} else {\n\t\tstream->req_in->buf = NULL;\n\t\tstream->req_in->num_sgs = se_cmd->t_data_nents;\n\t\tstream->req_in->sg = se_cmd->t_data_sg;\n\t}\n\n\tstream->req_in->is_last = 1;\n\tstream->req_in->complete = uasp_status_data_cmpl;\n\tstream->req_in->length = se_cmd->data_length;\n\tstream->req_in->context = cmd;\n\n\tcmd->state = UASP_SEND_STATUS;\n\treturn 0;\n}\n\nstatic void uasp_prepare_status(struct usbg_cmd *cmd)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct sense_iu *iu = &cmd->sense_iu;\n\tstruct uas_stream *stream = cmd->stream;\n\n\tcmd->state = UASP_QUEUE_COMMAND;\n\tiu->iu_id = IU_ID_STATUS;\n\tiu->tag = cpu_to_be16(cmd->tag);\n\n\t \n\tiu->len = cpu_to_be16(se_cmd->scsi_sense_length);\n\tiu->status = se_cmd->scsi_status;\n\tstream->req_status->is_last = 1;\n\tstream->req_status->context = cmd;\n\tstream->req_status->length = se_cmd->scsi_sense_length + 16;\n\tstream->req_status->buf = iu;\n\tstream->req_status->complete = uasp_status_data_cmpl;\n}\n\nstatic void uasp_status_data_cmpl(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbg_cmd *cmd = req->context;\n\tstruct uas_stream *stream = cmd->stream;\n\tstruct f_uas *fu = cmd->fu;\n\tint ret;\n\n\tif (req->status < 0)\n\t\tgoto cleanup;\n\n\tswitch (cmd->state) {\n\tcase UASP_SEND_DATA:\n\t\tret = uasp_prepare_r_request(cmd);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t\tret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d) => %d\\n\", __func__, __LINE__, ret);\n\t\tbreak;\n\n\tcase UASP_RECEIVE_DATA:\n\t\tret = usbg_prepare_w_request(cmd, stream->req_out);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t\tret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d) => %d\\n\", __func__, __LINE__, ret);\n\t\tbreak;\n\n\tcase UASP_SEND_STATUS:\n\t\tuasp_prepare_status(cmd);\n\t\tret = usb_ep_queue(fu->ep_status, stream->req_status,\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d) => %d\\n\", __func__, __LINE__, ret);\n\t\tbreak;\n\n\tcase UASP_QUEUE_COMMAND:\n\t\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n\t\tusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t}\n\treturn;\n\ncleanup:\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n}\n\nstatic int uasp_send_status_response(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct uas_stream *stream = cmd->stream;\n\tstruct sense_iu *iu = &cmd->sense_iu;\n\n\tiu->tag = cpu_to_be16(cmd->tag);\n\tstream->req_status->complete = uasp_status_data_cmpl;\n\tstream->req_status->context = cmd;\n\tcmd->fu = fu;\n\tuasp_prepare_status(cmd);\n\treturn usb_ep_queue(fu->ep_status, stream->req_status, GFP_ATOMIC);\n}\n\nstatic int uasp_send_read_response(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct uas_stream *stream = cmd->stream;\n\tstruct sense_iu *iu = &cmd->sense_iu;\n\tint ret;\n\n\tcmd->fu = fu;\n\n\tiu->tag = cpu_to_be16(cmd->tag);\n\tif (fu->flags & USBG_USE_STREAMS) {\n\n\t\tret = uasp_prepare_r_request(cmd);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = usb_ep_queue(fu->ep_in, stream->req_in, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s(%d) => %d\\n\", __func__, __LINE__, ret);\n\t\t\tkfree(cmd->data_buf);\n\t\t\tcmd->data_buf = NULL;\n\t\t}\n\n\t} else {\n\n\t\tiu->iu_id = IU_ID_READ_READY;\n\t\tiu->tag = cpu_to_be16(cmd->tag);\n\n\t\tstream->req_status->complete = uasp_status_data_cmpl;\n\t\tstream->req_status->context = cmd;\n\n\t\tcmd->state = UASP_SEND_DATA;\n\t\tstream->req_status->buf = iu;\n\t\tstream->req_status->length = sizeof(struct iu);\n\n\t\tret = usb_ep_queue(fu->ep_status, stream->req_status,\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d) => %d\\n\", __func__, __LINE__, ret);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int uasp_send_write_request(struct usbg_cmd *cmd)\n{\n\tstruct f_uas *fu = cmd->fu;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct uas_stream *stream = cmd->stream;\n\tstruct sense_iu *iu = &cmd->sense_iu;\n\tint ret;\n\n\tinit_completion(&cmd->write_complete);\n\tcmd->fu = fu;\n\n\tiu->tag = cpu_to_be16(cmd->tag);\n\n\tif (fu->flags & USBG_USE_STREAMS) {\n\n\t\tret = usbg_prepare_w_request(cmd, stream->req_out);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t\tret = usb_ep_queue(fu->ep_out, stream->req_out, GFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d)\\n\", __func__, __LINE__);\n\n\t} else {\n\n\t\tiu->iu_id = IU_ID_WRITE_READY;\n\t\tiu->tag = cpu_to_be16(cmd->tag);\n\n\t\tstream->req_status->complete = uasp_status_data_cmpl;\n\t\tstream->req_status->context = cmd;\n\n\t\tcmd->state = UASP_RECEIVE_DATA;\n\t\tstream->req_status->buf = iu;\n\t\tstream->req_status->length = sizeof(struct iu);\n\n\t\tret = usb_ep_queue(fu->ep_status, stream->req_status,\n\t\t\t\tGFP_ATOMIC);\n\t\tif (ret)\n\t\t\tpr_err(\"%s(%d)\\n\", __func__, __LINE__);\n\t}\n\n\twait_for_completion(&cmd->write_complete);\n\ttarget_execute_cmd(se_cmd);\ncleanup:\n\treturn ret;\n}\n\nstatic int usbg_submit_command(struct f_uas *, void *, unsigned int);\n\nstatic void uasp_cmd_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_uas *fu = req->context;\n\tint ret;\n\n\tif (req->status < 0)\n\t\treturn;\n\n\tret = usbg_submit_command(fu, req->buf, req->actual);\n\t \n\tif (!ret)\n\t\treturn;\n\tusb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\n}\n\nstatic int uasp_alloc_stream_res(struct f_uas *fu, struct uas_stream *stream)\n{\n\tstream->req_in = usb_ep_alloc_request(fu->ep_in, GFP_KERNEL);\n\tif (!stream->req_in)\n\t\tgoto out;\n\n\tstream->req_out = usb_ep_alloc_request(fu->ep_out, GFP_KERNEL);\n\tif (!stream->req_out)\n\t\tgoto err_out;\n\n\tstream->req_status = usb_ep_alloc_request(fu->ep_status, GFP_KERNEL);\n\tif (!stream->req_status)\n\t\tgoto err_sts;\n\n\treturn 0;\n\nerr_sts:\n\tusb_ep_free_request(fu->ep_out, stream->req_out);\n\tstream->req_out = NULL;\nerr_out:\n\tusb_ep_free_request(fu->ep_in, stream->req_in);\n\tstream->req_in = NULL;\nout:\n\treturn -ENOMEM;\n}\n\nstatic int uasp_alloc_cmd(struct f_uas *fu)\n{\n\tfu->cmd.req = usb_ep_alloc_request(fu->ep_cmd, GFP_KERNEL);\n\tif (!fu->cmd.req)\n\t\tgoto err;\n\n\tfu->cmd.buf = kmalloc(fu->ep_cmd->maxpacket, GFP_KERNEL);\n\tif (!fu->cmd.buf)\n\t\tgoto err_buf;\n\n\tfu->cmd.req->complete = uasp_cmd_complete;\n\tfu->cmd.req->buf = fu->cmd.buf;\n\tfu->cmd.req->length = fu->ep_cmd->maxpacket;\n\tfu->cmd.req->context = fu;\n\treturn 0;\n\nerr_buf:\n\tusb_ep_free_request(fu->ep_cmd, fu->cmd.req);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void uasp_setup_stream_res(struct f_uas *fu, int max_streams)\n{\n\tint i;\n\n\tfor (i = 0; i < max_streams; i++) {\n\t\tstruct uas_stream *s = &fu->stream[i];\n\n\t\ts->req_in->stream_id = i + 1;\n\t\ts->req_out->stream_id = i + 1;\n\t\ts->req_status->stream_id = i + 1;\n\t}\n}\n\nstatic int uasp_prepare_reqs(struct f_uas *fu)\n{\n\tint ret;\n\tint i;\n\tint max_streams;\n\n\tif (fu->flags & USBG_USE_STREAMS)\n\t\tmax_streams = UASP_SS_EP_COMP_NUM_STREAMS;\n\telse\n\t\tmax_streams = 1;\n\n\tfor (i = 0; i < max_streams; i++) {\n\t\tret = uasp_alloc_stream_res(fu, &fu->stream[i]);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\t}\n\n\tret = uasp_alloc_cmd(fu);\n\tif (ret)\n\t\tgoto err_free_stream;\n\tuasp_setup_stream_res(fu, max_streams);\n\n\tret = usb_ep_queue(fu->ep_cmd, fu->cmd.req, GFP_ATOMIC);\n\tif (ret)\n\t\tgoto err_free_stream;\n\n\treturn 0;\n\nerr_free_stream:\n\tuasp_free_cmdreq(fu);\n\nerr_cleanup:\n\tif (i) {\n\t\tdo {\n\t\t\tuasp_cleanup_one_stream(fu, &fu->stream[i - 1]);\n\t\t\ti--;\n\t\t} while (i);\n\t}\n\tpr_err(\"UASP: endpoint setup failed\\n\");\n\treturn ret;\n}\n\nstatic void uasp_set_alt(struct f_uas *fu)\n{\n\tstruct usb_function *f = &fu->function;\n\tstruct usb_gadget *gadget = f->config->cdev->gadget;\n\tint ret;\n\n\tfu->flags = USBG_IS_UAS;\n\n\tif (gadget->speed >= USB_SPEED_SUPER)\n\t\tfu->flags |= USBG_USE_STREAMS;\n\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_in, USB_G_ALT_INT_UAS);\n\tret = usb_ep_enable(fu->ep_in);\n\tif (ret)\n\t\tgoto err_b_in;\n\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_out, USB_G_ALT_INT_UAS);\n\tret = usb_ep_enable(fu->ep_out);\n\tif (ret)\n\t\tgoto err_b_out;\n\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_cmd, USB_G_ALT_INT_UAS);\n\tret = usb_ep_enable(fu->ep_cmd);\n\tif (ret)\n\t\tgoto err_cmd;\n\tconfig_ep_by_speed_and_alt(gadget, f, fu->ep_status, USB_G_ALT_INT_UAS);\n\tret = usb_ep_enable(fu->ep_status);\n\tif (ret)\n\t\tgoto err_status;\n\n\tret = uasp_prepare_reqs(fu);\n\tif (ret)\n\t\tgoto err_wq;\n\tfu->flags |= USBG_ENABLED;\n\n\tpr_info(\"Using the UAS protocol\\n\");\n\treturn;\nerr_wq:\n\tusb_ep_disable(fu->ep_status);\nerr_status:\n\tusb_ep_disable(fu->ep_cmd);\nerr_cmd:\n\tusb_ep_disable(fu->ep_out);\nerr_b_out:\n\tusb_ep_disable(fu->ep_in);\nerr_b_in:\n\tfu->flags = 0;\n}\n\nstatic int get_cmd_dir(const unsigned char *cdb)\n{\n\tint ret;\n\n\tswitch (cdb[0]) {\n\tcase READ_6:\n\tcase READ_10:\n\tcase READ_12:\n\tcase READ_16:\n\tcase INQUIRY:\n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\tcase SERVICE_ACTION_IN_16:\n\tcase MAINTENANCE_IN:\n\tcase PERSISTENT_RESERVE_IN:\n\tcase SECURITY_PROTOCOL_IN:\n\tcase ACCESS_CONTROL_IN:\n\tcase REPORT_LUNS:\n\tcase READ_BLOCK_LIMITS:\n\tcase READ_POSITION:\n\tcase READ_CAPACITY:\n\tcase READ_TOC:\n\tcase READ_FORMAT_CAPACITIES:\n\tcase REQUEST_SENSE:\n\t\tret = DMA_FROM_DEVICE;\n\t\tbreak;\n\n\tcase WRITE_6:\n\tcase WRITE_10:\n\tcase WRITE_12:\n\tcase WRITE_16:\n\tcase MODE_SELECT:\n\tcase MODE_SELECT_10:\n\tcase WRITE_VERIFY:\n\tcase WRITE_VERIFY_12:\n\tcase PERSISTENT_RESERVE_OUT:\n\tcase MAINTENANCE_OUT:\n\tcase SECURITY_PROTOCOL_OUT:\n\tcase ACCESS_CONTROL_OUT:\n\t\tret = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase ALLOW_MEDIUM_REMOVAL:\n\tcase TEST_UNIT_READY:\n\tcase SYNCHRONIZE_CACHE:\n\tcase START_STOP:\n\tcase ERASE:\n\tcase REZERO_UNIT:\n\tcase SEEK_10:\n\tcase SPACE:\n\tcase VERIFY:\n\tcase WRITE_FILEMARKS:\n\t\tret = DMA_NONE;\n\t\tbreak;\n\tdefault:\n#define CMD_DIR_MSG \"target: Unknown data direction for SCSI Opcode 0x%02x\\n\"\n\t\tpr_warn(CMD_DIR_MSG, cdb[0]);\n#undef CMD_DIR_MSG\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic void usbg_data_write_cmpl(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbg_cmd *cmd = req->context;\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\n\tif (req->status < 0) {\n\t\tpr_err(\"%s() state %d transfer failed\\n\", __func__, cmd->state);\n\t\tgoto cleanup;\n\t}\n\n\tif (req->num_sgs == 0) {\n\t\tsg_copy_from_buffer(se_cmd->t_data_sg,\n\t\t\t\tse_cmd->t_data_nents,\n\t\t\t\tcmd->data_buf,\n\t\t\t\tse_cmd->data_length);\n\t}\n\n\tcomplete(&cmd->write_complete);\n\treturn;\n\ncleanup:\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n}\n\nstatic int usbg_prepare_w_request(struct usbg_cmd *cmd, struct usb_request *req)\n{\n\tstruct se_cmd *se_cmd = &cmd->se_cmd;\n\tstruct f_uas *fu = cmd->fu;\n\tstruct usb_gadget *gadget = fuas_to_gadget(fu);\n\n\tif (!gadget->sg_supported) {\n\t\tcmd->data_buf = kmalloc(se_cmd->data_length, GFP_ATOMIC);\n\t\tif (!cmd->data_buf)\n\t\t\treturn -ENOMEM;\n\n\t\treq->buf = cmd->data_buf;\n\t} else {\n\t\treq->buf = NULL;\n\t\treq->num_sgs = se_cmd->t_data_nents;\n\t\treq->sg = se_cmd->t_data_sg;\n\t}\n\n\treq->is_last = 1;\n\treq->complete = usbg_data_write_cmpl;\n\treq->length = se_cmd->data_length;\n\treq->context = cmd;\n\treturn 0;\n}\n\nstatic int usbg_send_status_response(struct se_cmd *se_cmd)\n{\n\tstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\n\t\t\tse_cmd);\n\tstruct f_uas *fu = cmd->fu;\n\n\tif (fu->flags & USBG_IS_BOT)\n\t\treturn bot_send_status_response(cmd);\n\telse\n\t\treturn uasp_send_status_response(cmd);\n}\n\nstatic int usbg_send_write_request(struct se_cmd *se_cmd)\n{\n\tstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\n\t\t\tse_cmd);\n\tstruct f_uas *fu = cmd->fu;\n\n\tif (fu->flags & USBG_IS_BOT)\n\t\treturn bot_send_write_request(cmd);\n\telse\n\t\treturn uasp_send_write_request(cmd);\n}\n\nstatic int usbg_send_read_response(struct se_cmd *se_cmd)\n{\n\tstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\n\t\t\tse_cmd);\n\tstruct f_uas *fu = cmd->fu;\n\n\tif (fu->flags & USBG_IS_BOT)\n\t\treturn bot_send_read_response(cmd);\n\telse\n\t\treturn uasp_send_read_response(cmd);\n}\n\nstatic void usbg_cmd_work(struct work_struct *work)\n{\n\tstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\n\tstruct se_cmd *se_cmd;\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tstruct usbg_tpg *tpg;\n\tint dir, flags = (TARGET_SCF_UNKNOWN_SIZE | TARGET_SCF_ACK_KREF);\n\n\tse_cmd = &cmd->se_cmd;\n\ttpg = cmd->fu->tpg;\n\ttv_nexus = tpg->tpg_nexus;\n\tdir = get_cmd_dir(cmd->cmd_buf);\n\tif (dir < 0) {\n\t\t__target_init_cmd(se_cmd,\n\t\t\t\t  tv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\n\t\t\t\t  tv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\n\t\t\t\t  cmd->prio_attr, cmd->sense_iu.sense,\n\t\t\t\t  cmd->unpacked_lun, NULL);\n\t\tgoto out;\n\t}\n\n\ttarget_submit_cmd(se_cmd, tv_nexus->tvn_se_sess, cmd->cmd_buf,\n\t\t\t  cmd->sense_iu.sense, cmd->unpacked_lun, 0,\n\t\t\t  cmd->prio_attr, dir, flags);\n\treturn;\n\nout:\n\ttransport_send_check_condition_and_sense(se_cmd,\n\t\t\tTCM_UNSUPPORTED_SCSI_OPCODE, 1);\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n}\n\nstatic struct usbg_cmd *usbg_get_cmd(struct f_uas *fu,\n\t\tstruct tcm_usbg_nexus *tv_nexus, u32 scsi_tag)\n{\n\tstruct se_session *se_sess = tv_nexus->tvn_se_sess;\n\tstruct usbg_cmd *cmd;\n\tint tag, cpu;\n\n\ttag = sbitmap_queue_get(&se_sess->sess_tag_pool, &cpu);\n\tif (tag < 0)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = &((struct usbg_cmd *)se_sess->sess_cmd_map)[tag];\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->se_cmd.map_tag = tag;\n\tcmd->se_cmd.map_cpu = cpu;\n\tcmd->se_cmd.tag = cmd->tag = scsi_tag;\n\tcmd->fu = fu;\n\n\treturn cmd;\n}\n\nstatic void usbg_release_cmd(struct se_cmd *);\n\nstatic int usbg_submit_command(struct f_uas *fu,\n\t\tvoid *cmdbuf, unsigned int len)\n{\n\tstruct command_iu *cmd_iu = cmdbuf;\n\tstruct usbg_cmd *cmd;\n\tstruct usbg_tpg *tpg = fu->tpg;\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tu32 cmd_len;\n\tu16 scsi_tag;\n\n\tif (cmd_iu->iu_id != IU_ID_COMMAND) {\n\t\tpr_err(\"Unsupported type %d\\n\", cmd_iu->iu_id);\n\t\treturn -EINVAL;\n\t}\n\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tpr_err(\"Missing nexus, ignoring command\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_len = (cmd_iu->len & ~0x3) + 16;\n\tif (cmd_len > USBG_MAX_CMD)\n\t\treturn -EINVAL;\n\n\tscsi_tag = be16_to_cpup(&cmd_iu->tag);\n\tcmd = usbg_get_cmd(fu, tv_nexus, scsi_tag);\n\tif (IS_ERR(cmd)) {\n\t\tpr_err(\"usbg_get_cmd failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(cmd->cmd_buf, cmd_iu->cdb, cmd_len);\n\n\tif (fu->flags & USBG_USE_STREAMS) {\n\t\tif (cmd->tag > UASP_SS_EP_COMP_NUM_STREAMS)\n\t\t\tgoto err;\n\t\tif (!cmd->tag)\n\t\t\tcmd->stream = &fu->stream[0];\n\t\telse\n\t\t\tcmd->stream = &fu->stream[cmd->tag - 1];\n\t} else {\n\t\tcmd->stream = &fu->stream[0];\n\t}\n\n\tswitch (cmd_iu->prio_attr & 0x7) {\n\tcase UAS_HEAD_TAG:\n\t\tcmd->prio_attr = TCM_HEAD_TAG;\n\t\tbreak;\n\tcase UAS_ORDERED_TAG:\n\t\tcmd->prio_attr = TCM_ORDERED_TAG;\n\t\tbreak;\n\tcase UAS_ACA:\n\t\tcmd->prio_attr = TCM_ACA_TAG;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug_once(\"Unsupported prio_attr: %02x.\\n\",\n\t\t\t\tcmd_iu->prio_attr);\n\t\tfallthrough;\n\tcase UAS_SIMPLE_TAG:\n\t\tcmd->prio_attr = TCM_SIMPLE_TAG;\n\t\tbreak;\n\t}\n\n\tcmd->unpacked_lun = scsilun_to_int(&cmd_iu->lun);\n\n\tINIT_WORK(&cmd->work, usbg_cmd_work);\n\tqueue_work(tpg->workqueue, &cmd->work);\n\n\treturn 0;\nerr:\n\tusbg_release_cmd(&cmd->se_cmd);\n\treturn -EINVAL;\n}\n\nstatic void bot_cmd_work(struct work_struct *work)\n{\n\tstruct usbg_cmd *cmd = container_of(work, struct usbg_cmd, work);\n\tstruct se_cmd *se_cmd;\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tstruct usbg_tpg *tpg;\n\tint dir;\n\n\tse_cmd = &cmd->se_cmd;\n\ttpg = cmd->fu->tpg;\n\ttv_nexus = tpg->tpg_nexus;\n\tdir = get_cmd_dir(cmd->cmd_buf);\n\tif (dir < 0) {\n\t\t__target_init_cmd(se_cmd,\n\t\t\t\t  tv_nexus->tvn_se_sess->se_tpg->se_tpg_tfo,\n\t\t\t\t  tv_nexus->tvn_se_sess, cmd->data_len, DMA_NONE,\n\t\t\t\t  cmd->prio_attr, cmd->sense_iu.sense,\n\t\t\t\t  cmd->unpacked_lun, NULL);\n\t\tgoto out;\n\t}\n\n\ttarget_submit_cmd(se_cmd, tv_nexus->tvn_se_sess,\n\t\t\t  cmd->cmd_buf, cmd->sense_iu.sense, cmd->unpacked_lun,\n\t\t\t  cmd->data_len, cmd->prio_attr, dir, 0);\n\treturn;\n\nout:\n\ttransport_send_check_condition_and_sense(se_cmd,\n\t\t\t\tTCM_UNSUPPORTED_SCSI_OPCODE, 1);\n\ttransport_generic_free_cmd(&cmd->se_cmd, 0);\n}\n\nstatic int bot_submit_command(struct f_uas *fu,\n\t\tvoid *cmdbuf, unsigned int len)\n{\n\tstruct bulk_cb_wrap *cbw = cmdbuf;\n\tstruct usbg_cmd *cmd;\n\tstruct usbg_tpg *tpg = fu->tpg;\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tu32 cmd_len;\n\n\tif (cbw->Signature != cpu_to_le32(US_BULK_CB_SIGN)) {\n\t\tpr_err(\"Wrong signature on CBW\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (len != 31) {\n\t\tpr_err(\"Wrong length for CBW\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_len = cbw->Length;\n\tif (cmd_len < 1 || cmd_len > 16)\n\t\treturn -EINVAL;\n\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tpr_err(\"Missing nexus, ignoring command\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcmd = usbg_get_cmd(fu, tv_nexus, cbw->Tag);\n\tif (IS_ERR(cmd)) {\n\t\tpr_err(\"usbg_get_cmd failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmemcpy(cmd->cmd_buf, cbw->CDB, cmd_len);\n\n\tcmd->bot_tag = cbw->Tag;\n\tcmd->prio_attr = TCM_SIMPLE_TAG;\n\tcmd->unpacked_lun = cbw->Lun;\n\tcmd->is_read = cbw->Flags & US_BULK_FLAG_IN ? 1 : 0;\n\tcmd->data_len = le32_to_cpu(cbw->DataTransferLength);\n\tcmd->se_cmd.tag = le32_to_cpu(cmd->bot_tag);\n\n\tINIT_WORK(&cmd->work, bot_cmd_work);\n\tqueue_work(tpg->workqueue, &cmd->work);\n\n\treturn 0;\n}\n\n \n\nstatic int usbg_check_true(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic char *usbg_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct usbg_tpg, se_tpg);\n\tstruct usbg_tport *tport = tpg->tport;\n\n\treturn &tport->tport_name[0];\n}\n\nstatic u16 usbg_get_tag(struct se_portal_group *se_tpg)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct usbg_tpg, se_tpg);\n\treturn tpg->tport_tpgt;\n}\n\nstatic void usbg_release_cmd(struct se_cmd *se_cmd)\n{\n\tstruct usbg_cmd *cmd = container_of(se_cmd, struct usbg_cmd,\n\t\t\tse_cmd);\n\tstruct se_session *se_sess = se_cmd->se_sess;\n\n\tkfree(cmd->data_buf);\n\ttarget_free_tag(se_sess, se_cmd);\n}\n\nstatic void usbg_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n}\n\nstatic void usbg_aborted_task(struct se_cmd *se_cmd)\n{\n}\n\nstatic const char *usbg_check_wwn(const char *name)\n{\n\tconst char *n;\n\tunsigned int len;\n\n\tn = strstr(name, \"naa.\");\n\tif (!n)\n\t\treturn NULL;\n\tn += 4;\n\tlen = strlen(n);\n\tif (len == 0 || len > USBG_NAMELEN - 1)\n\t\treturn NULL;\n\treturn n;\n}\n\nstatic int usbg_init_nodeacl(struct se_node_acl *se_nacl, const char *name)\n{\n\tif (!usbg_check_wwn(name))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic struct se_portal_group *usbg_make_tpg(struct se_wwn *wwn,\n\t\t\t\t\t     const char *name)\n{\n\tstruct usbg_tport *tport = container_of(wwn, struct usbg_tport,\n\t\t\ttport_wwn);\n\tstruct usbg_tpg *tpg;\n\tunsigned long tpgt;\n\tint ret;\n\tstruct f_tcm_opts *opts;\n\tunsigned i;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtoul(name + 5, 0, &tpgt) || tpgt > UINT_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tret = -ENODEV;\n\tmutex_lock(&tpg_instances_lock);\n\tfor (i = 0; i < TPG_INSTANCES; ++i)\n\t\tif (tpg_instances[i].func_inst && !tpg_instances[i].tpg)\n\t\t\tbreak;\n\tif (i == TPG_INSTANCES)\n\t\tgoto unlock_inst;\n\n\topts = container_of(tpg_instances[i].func_inst, struct f_tcm_opts,\n\t\tfunc_inst);\n\tmutex_lock(&opts->dep_lock);\n\tif (!opts->ready)\n\t\tgoto unlock_dep;\n\n\tif (opts->has_dep) {\n\t\tif (!try_module_get(opts->dependent))\n\t\t\tgoto unlock_dep;\n\t} else {\n\t\tret = configfs_depend_item_unlocked(\n\t\t\twwn->wwn_group.cg_subsys,\n\t\t\t&opts->func_inst.group.cg_item);\n\t\tif (ret)\n\t\t\tgoto unlock_dep;\n\t}\n\n\ttpg = kzalloc(sizeof(struct usbg_tpg), GFP_KERNEL);\n\tret = -ENOMEM;\n\tif (!tpg)\n\t\tgoto unref_dep;\n\tmutex_init(&tpg->tpg_mutex);\n\tatomic_set(&tpg->tpg_port_count, 0);\n\ttpg->workqueue = alloc_workqueue(\"tcm_usb_gadget\", 0, 1);\n\tif (!tpg->workqueue)\n\t\tgoto free_tpg;\n\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\t \n\tret = core_tpg_register(wwn, &tpg->se_tpg, SCSI_PROTOCOL_SAS);\n\tif (ret < 0)\n\t\tgoto free_workqueue;\n\n\ttpg_instances[i].tpg = tpg;\n\ttpg->fi = tpg_instances[i].func_inst;\n\tmutex_unlock(&opts->dep_lock);\n\tmutex_unlock(&tpg_instances_lock);\n\treturn &tpg->se_tpg;\n\nfree_workqueue:\n\tdestroy_workqueue(tpg->workqueue);\nfree_tpg:\n\tkfree(tpg);\nunref_dep:\n\tif (opts->has_dep)\n\t\tmodule_put(opts->dependent);\n\telse\n\t\tconfigfs_undepend_item_unlocked(&opts->func_inst.group.cg_item);\nunlock_dep:\n\tmutex_unlock(&opts->dep_lock);\nunlock_inst:\n\tmutex_unlock(&tpg_instances_lock);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int tcm_usbg_drop_nexus(struct usbg_tpg *);\n\nstatic void usbg_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct usbg_tpg, se_tpg);\n\tunsigned i;\n\tstruct f_tcm_opts *opts;\n\n\ttcm_usbg_drop_nexus(tpg);\n\tcore_tpg_deregister(se_tpg);\n\tdestroy_workqueue(tpg->workqueue);\n\n\tmutex_lock(&tpg_instances_lock);\n\tfor (i = 0; i < TPG_INSTANCES; ++i)\n\t\tif (tpg_instances[i].tpg == tpg)\n\t\t\tbreak;\n\tif (i < TPG_INSTANCES) {\n\t\ttpg_instances[i].tpg = NULL;\n\t\topts = container_of(tpg_instances[i].func_inst,\n\t\t\tstruct f_tcm_opts, func_inst);\n\t\tmutex_lock(&opts->dep_lock);\n\t\tif (opts->has_dep)\n\t\t\tmodule_put(opts->dependent);\n\t\telse\n\t\t\tconfigfs_undepend_item_unlocked(\n\t\t\t\t&opts->func_inst.group.cg_item);\n\t\tmutex_unlock(&opts->dep_lock);\n\t}\n\tmutex_unlock(&tpg_instances_lock);\n\n\tkfree(tpg);\n}\n\nstatic struct se_wwn *usbg_make_tport(\n\tstruct target_fabric_configfs *tf,\n\tstruct config_group *group,\n\tconst char *name)\n{\n\tstruct usbg_tport *tport;\n\tconst char *wnn_name;\n\tu64 wwpn = 0;\n\n\twnn_name = usbg_check_wwn(name);\n\tif (!wnn_name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttport = kzalloc(sizeof(struct usbg_tport), GFP_KERNEL);\n\tif (!(tport))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttport->tport_wwpn = wwpn;\n\tsnprintf(tport->tport_name, sizeof(tport->tport_name), \"%s\", wnn_name);\n\treturn &tport->tport_wwn;\n}\n\nstatic void usbg_drop_tport(struct se_wwn *wwn)\n{\n\tstruct usbg_tport *tport = container_of(wwn,\n\t\t\t\tstruct usbg_tport, tport_wwn);\n\tkfree(tport);\n}\n\n \nstatic ssize_t usbg_wwn_version_show(struct config_item *item,  char *page)\n{\n\treturn sprintf(page, \"usb-gadget fabric module\\n\");\n}\n\nCONFIGFS_ATTR_RO(usbg_wwn_, version);\n\nstatic struct configfs_attribute *usbg_wwn_attrs[] = {\n\t&usbg_wwn_attr_version,\n\tNULL,\n};\n\nstatic int usbg_attach(struct usbg_tpg *);\nstatic void usbg_detach(struct usbg_tpg *);\n\nstatic int usbg_enable_tpg(struct se_portal_group *se_tpg, bool enable)\n{\n\tstruct usbg_tpg  *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\n\tint ret = 0;\n\n\tif (enable)\n\t\tret = usbg_attach(tpg);\n\telse\n\t\tusbg_detach(tpg);\n\tif (ret)\n\t\treturn ret;\n\n\ttpg->gadget_connect = enable;\n\n\treturn 0;\n}\n\nstatic ssize_t tcm_usbg_tpg_nexus_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tssize_t ret;\n\n\tmutex_lock(&tpg->tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tret = snprintf(page, PAGE_SIZE, \"%s\\n\",\n\t\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\nout:\n\tmutex_unlock(&tpg->tpg_mutex);\n\treturn ret;\n}\n\nstatic int usbg_alloc_sess_cb(struct se_portal_group *se_tpg,\n\t\t\t      struct se_session *se_sess, void *p)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct usbg_tpg, se_tpg);\n\n\ttpg->tpg_nexus = p;\n\treturn 0;\n}\n\nstatic int tcm_usbg_make_nexus(struct usbg_tpg *tpg, char *name)\n{\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tint ret = 0;\n\n\tmutex_lock(&tpg->tpg_mutex);\n\tif (tpg->tpg_nexus) {\n\t\tret = -EEXIST;\n\t\tpr_debug(\"tpg->tpg_nexus already exists\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\ttv_nexus = kzalloc(sizeof(*tv_nexus), GFP_KERNEL);\n\tif (!tv_nexus) {\n\t\tret = -ENOMEM;\n\t\tgoto out_unlock;\n\t}\n\n\ttv_nexus->tvn_se_sess = target_setup_session(&tpg->se_tpg,\n\t\t\t\t\t\t     USB_G_DEFAULT_SESSION_TAGS,\n\t\t\t\t\t\t     sizeof(struct usbg_cmd),\n\t\t\t\t\t\t     TARGET_PROT_NORMAL, name,\n\t\t\t\t\t\t     tv_nexus, usbg_alloc_sess_cb);\n\tif (IS_ERR(tv_nexus->tvn_se_sess)) {\n#define MAKE_NEXUS_MSG \"core_tpg_check_initiator_node_acl() failed for %s\\n\"\n\t\tpr_debug(MAKE_NEXUS_MSG, name);\n#undef MAKE_NEXUS_MSG\n\t\tret = PTR_ERR(tv_nexus->tvn_se_sess);\n\t\tkfree(tv_nexus);\n\t}\n\nout_unlock:\n\tmutex_unlock(&tpg->tpg_mutex);\n\treturn ret;\n}\n\nstatic int tcm_usbg_drop_nexus(struct usbg_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct tcm_usbg_nexus *tv_nexus;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&tpg->tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus)\n\t\tgoto out;\n\n\tse_sess = tv_nexus->tvn_se_sess;\n\tif (!se_sess)\n\t\tgoto out;\n\n\tif (atomic_read(&tpg->tpg_port_count)) {\n\t\tret = -EPERM;\n#define MSG \"Unable to remove Host I_T Nexus with active TPG port count: %d\\n\"\n\t\tpr_err(MSG, atomic_read(&tpg->tpg_port_count));\n#undef MSG\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"Removing I_T Nexus to Initiator Port: %s\\n\",\n\t\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\n\t \n\ttarget_remove_session(se_sess);\n\ttpg->tpg_nexus = NULL;\n\n\tkfree(tv_nexus);\n\tret = 0;\nout:\n\tmutex_unlock(&tpg->tpg_mutex);\n\treturn ret;\n}\n\nstatic ssize_t tcm_usbg_tpg_nexus_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\n\tunsigned char i_port[USBG_NAMELEN], *ptr;\n\tint ret;\n\n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = tcm_usbg_drop_nexus(tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\tif (strlen(page) >= USBG_NAMELEN) {\n\n#define NEXUS_STORE_MSG \"Emulated NAA Sas Address: %s, exceeds max: %d\\n\"\n\t\tpr_err(NEXUS_STORE_MSG, page, USBG_NAMELEN);\n#undef NEXUS_STORE_MSG\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(i_port, USBG_NAMELEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (!ptr) {\n\t\tpr_err(\"Missing 'naa.' prefix\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (i_port[strlen(i_port) - 1] == '\\n')\n\t\ti_port[strlen(i_port) - 1] = '\\0';\n\n\tret = tcm_usbg_make_nexus(tpg, &i_port[0]);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nCONFIGFS_ATTR(tcm_usbg_tpg_, nexus);\n\nstatic struct configfs_attribute *usbg_base_attrs[] = {\n\t&tcm_usbg_tpg_attr_nexus,\n\tNULL,\n};\n\nstatic int usbg_port_link(struct se_portal_group *se_tpg, struct se_lun *lun)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\n\n\tatomic_inc(&tpg->tpg_port_count);\n\tsmp_mb__after_atomic();\n\treturn 0;\n}\n\nstatic void usbg_port_unlink(struct se_portal_group *se_tpg,\n\t\tstruct se_lun *se_lun)\n{\n\tstruct usbg_tpg *tpg = container_of(se_tpg, struct usbg_tpg, se_tpg);\n\n\tatomic_dec(&tpg->tpg_port_count);\n\tsmp_mb__after_atomic();\n}\n\nstatic int usbg_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn target_put_sess_cmd(se_cmd);\n}\n\nstatic const struct target_core_fabric_ops usbg_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"usb_gadget\",\n\t.tpg_get_wwn\t\t\t= usbg_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= usbg_get_tag,\n\t.tpg_check_demo_mode\t\t= usbg_check_true,\n\t.release_cmd\t\t\t= usbg_release_cmd,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.write_pending\t\t\t= usbg_send_write_request,\n\t.queue_data_in\t\t\t= usbg_send_read_response,\n\t.queue_status\t\t\t= usbg_send_status_response,\n\t.queue_tm_rsp\t\t\t= usbg_queue_tm_rsp,\n\t.aborted_task\t\t\t= usbg_aborted_task,\n\t.check_stop_free\t\t= usbg_check_stop_free,\n\n\t.fabric_make_wwn\t\t= usbg_make_tport,\n\t.fabric_drop_wwn\t\t= usbg_drop_tport,\n\t.fabric_make_tpg\t\t= usbg_make_tpg,\n\t.fabric_enable_tpg\t\t= usbg_enable_tpg,\n\t.fabric_drop_tpg\t\t= usbg_drop_tpg,\n\t.fabric_post_link\t\t= usbg_port_link,\n\t.fabric_pre_unlink\t\t= usbg_port_unlink,\n\t.fabric_init_nodeacl\t\t= usbg_init_nodeacl,\n\n\t.tfc_wwn_attrs\t\t\t= usbg_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= usbg_base_attrs,\n};\n\n \n\nstatic struct usb_interface_descriptor bot_intf_desc = {\n\t.bLength =              sizeof(bot_intf_desc),\n\t.bDescriptorType =      USB_DT_INTERFACE,\n\t.bNumEndpoints =        2,\n\t.bAlternateSetting =\tUSB_G_ALT_INT_BBB,\n\t.bInterfaceClass =      USB_CLASS_MASS_STORAGE,\n\t.bInterfaceSubClass =   USB_SC_SCSI,\n\t.bInterfaceProtocol =   USB_PR_BULK,\n};\n\nstatic struct usb_interface_descriptor uasp_intf_desc = {\n\t.bLength =\t\tsizeof(uasp_intf_desc),\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bNumEndpoints =\t4,\n\t.bAlternateSetting =\tUSB_G_ALT_INT_UAS,\n\t.bInterfaceClass =\tUSB_CLASS_MASS_STORAGE,\n\t.bInterfaceSubClass =\tUSB_SC_SCSI,\n\t.bInterfaceProtocol =\tUSB_PR_UAS,\n};\n\nstatic struct usb_endpoint_descriptor uasp_bi_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor uasp_fs_bi_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_pipe_usage_descriptor uasp_bi_pipe_desc = {\n\t.bLength =\t\tsizeof(uasp_bi_pipe_desc),\n\t.bDescriptorType =\tUSB_DT_PIPE_USAGE,\n\t.bPipeID =\t\tDATA_IN_PIPE_ID,\n};\n\nstatic struct usb_endpoint_descriptor uasp_ss_bi_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor uasp_bi_ep_comp_desc = {\n\t.bLength =\t\tsizeof(uasp_bi_ep_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\tUASP_SS_EP_COMP_LOG_STREAMS,\n\t.wBytesPerInterval =\t0,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bot_bi_ep_comp_desc = {\n\t.bLength =\t\tsizeof(bot_bi_ep_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst =\t\t0,\n};\n\nstatic struct usb_endpoint_descriptor uasp_bo_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor uasp_fs_bo_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_pipe_usage_descriptor uasp_bo_pipe_desc = {\n\t.bLength =\t\tsizeof(uasp_bo_pipe_desc),\n\t.bDescriptorType =\tUSB_DT_PIPE_USAGE,\n\t.bPipeID =\t\tDATA_OUT_PIPE_ID,\n};\n\nstatic struct usb_endpoint_descriptor uasp_ss_bo_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(0x400),\n};\n\nstatic struct usb_ss_ep_comp_descriptor uasp_bo_ep_comp_desc = {\n\t.bLength =\t\tsizeof(uasp_bo_ep_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bmAttributes =\t\tUASP_SS_EP_COMP_LOG_STREAMS,\n};\n\nstatic struct usb_ss_ep_comp_descriptor bot_bo_ep_comp_desc = {\n\t.bLength =\t\tsizeof(bot_bo_ep_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_endpoint_descriptor uasp_status_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor uasp_fs_status_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_pipe_usage_descriptor uasp_status_pipe_desc = {\n\t.bLength =\t\tsizeof(uasp_status_pipe_desc),\n\t.bDescriptorType =\tUSB_DT_PIPE_USAGE,\n\t.bPipeID =\t\tSTATUS_PIPE_ID,\n};\n\nstatic struct usb_endpoint_descriptor uasp_ss_status_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor uasp_status_in_ep_comp_desc = {\n\t.bLength =\t\tsizeof(uasp_status_in_ep_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bmAttributes =\t\tUASP_SS_EP_COMP_LOG_STREAMS,\n};\n\nstatic struct usb_endpoint_descriptor uasp_cmd_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor uasp_fs_cmd_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_pipe_usage_descriptor uasp_cmd_pipe_desc = {\n\t.bLength =\t\tsizeof(uasp_cmd_pipe_desc),\n\t.bDescriptorType =\tUSB_DT_PIPE_USAGE,\n\t.bPipeID =\t\tCMD_PIPE_ID,\n};\n\nstatic struct usb_endpoint_descriptor uasp_ss_cmd_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor uasp_cmd_comp_desc = {\n\t.bLength =\t\tsizeof(uasp_cmd_comp_desc),\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_descriptor_header *uasp_fs_function_desc[] = {\n\t(struct usb_descriptor_header *) &bot_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_bi_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_bo_desc,\n\n\t(struct usb_descriptor_header *) &uasp_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_bi_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_bo_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_status_desc,\n\t(struct usb_descriptor_header *) &uasp_status_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_fs_cmd_desc,\n\t(struct usb_descriptor_header *) &uasp_cmd_pipe_desc,\n\tNULL,\n};\n\nstatic struct usb_descriptor_header *uasp_hs_function_desc[] = {\n\t(struct usb_descriptor_header *) &bot_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_desc,\n\n\t(struct usb_descriptor_header *) &uasp_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_status_desc,\n\t(struct usb_descriptor_header *) &uasp_status_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_cmd_desc,\n\t(struct usb_descriptor_header *) &uasp_cmd_pipe_desc,\n\tNULL,\n};\n\nstatic struct usb_descriptor_header *uasp_ss_function_desc[] = {\n\t(struct usb_descriptor_header *) &bot_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_bi_desc,\n\t(struct usb_descriptor_header *) &bot_bi_ep_comp_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_bo_desc,\n\t(struct usb_descriptor_header *) &bot_bo_ep_comp_desc,\n\n\t(struct usb_descriptor_header *) &uasp_intf_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_bi_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_ep_comp_desc,\n\t(struct usb_descriptor_header *) &uasp_bi_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_bo_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_ep_comp_desc,\n\t(struct usb_descriptor_header *) &uasp_bo_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_status_desc,\n\t(struct usb_descriptor_header *) &uasp_status_in_ep_comp_desc,\n\t(struct usb_descriptor_header *) &uasp_status_pipe_desc,\n\t(struct usb_descriptor_header *) &uasp_ss_cmd_desc,\n\t(struct usb_descriptor_header *) &uasp_cmd_comp_desc,\n\t(struct usb_descriptor_header *) &uasp_cmd_pipe_desc,\n\tNULL,\n};\n\nstatic struct usb_string\ttcm_us_strings[] = {\n\t[USB_G_STR_INT_UAS].s\t\t= \"USB Attached SCSI\",\n\t[USB_G_STR_INT_BBB].s\t\t= \"Bulk Only Transport\",\n\t{ },\n};\n\nstatic struct usb_gadget_strings tcm_stringtab = {\n\t.language = 0x0409,\n\t.strings = tcm_us_strings,\n};\n\nstatic struct usb_gadget_strings *tcm_strings[] = {\n\t&tcm_stringtab,\n\tNULL,\n};\n\nstatic int tcm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_uas\t\t*fu = to_f_uas(f);\n\tstruct usb_string\t*us;\n\tstruct usb_gadget\t*gadget = c->cdev->gadget;\n\tstruct usb_ep\t\t*ep;\n\tstruct f_tcm_opts\t*opts;\n\tint\t\t\tiface;\n\tint\t\t\tret;\n\n\topts = container_of(f->fi, struct f_tcm_opts, func_inst);\n\n\tmutex_lock(&opts->dep_lock);\n\tif (!opts->can_attach) {\n\t\tmutex_unlock(&opts->dep_lock);\n\t\treturn -ENODEV;\n\t}\n\tmutex_unlock(&opts->dep_lock);\n\tus = usb_gstrings_attach(c->cdev, tcm_strings,\n\t\tARRAY_SIZE(tcm_us_strings));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\tbot_intf_desc.iInterface = us[USB_G_STR_INT_BBB].id;\n\tuasp_intf_desc.iInterface = us[USB_G_STR_INT_UAS].id;\n\n\tiface = usb_interface_id(c, f);\n\tif (iface < 0)\n\t\treturn iface;\n\n\tbot_intf_desc.bInterfaceNumber = iface;\n\tuasp_intf_desc.bInterfaceNumber = iface;\n\tfu->iface = iface;\n\tep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bi_desc,\n\t\t\t&uasp_bi_ep_comp_desc);\n\tif (!ep)\n\t\tgoto ep_fail;\n\n\tfu->ep_in = ep;\n\n\tep = usb_ep_autoconfig_ss(gadget, &uasp_ss_bo_desc,\n\t\t\t&uasp_bo_ep_comp_desc);\n\tif (!ep)\n\t\tgoto ep_fail;\n\tfu->ep_out = ep;\n\n\tep = usb_ep_autoconfig_ss(gadget, &uasp_ss_status_desc,\n\t\t\t&uasp_status_in_ep_comp_desc);\n\tif (!ep)\n\t\tgoto ep_fail;\n\tfu->ep_status = ep;\n\n\tep = usb_ep_autoconfig_ss(gadget, &uasp_ss_cmd_desc,\n\t\t\t&uasp_cmd_comp_desc);\n\tif (!ep)\n\t\tgoto ep_fail;\n\tfu->ep_cmd = ep;\n\n\t \n\tuasp_bi_desc.bEndpointAddress =\tuasp_ss_bi_desc.bEndpointAddress;\n\tuasp_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\n\tuasp_status_desc.bEndpointAddress =\n\t\tuasp_ss_status_desc.bEndpointAddress;\n\tuasp_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\n\n\tuasp_fs_bi_desc.bEndpointAddress = uasp_ss_bi_desc.bEndpointAddress;\n\tuasp_fs_bo_desc.bEndpointAddress = uasp_ss_bo_desc.bEndpointAddress;\n\tuasp_fs_status_desc.bEndpointAddress =\n\t\tuasp_ss_status_desc.bEndpointAddress;\n\tuasp_fs_cmd_desc.bEndpointAddress = uasp_ss_cmd_desc.bEndpointAddress;\n\n\tret = usb_assign_descriptors(f, uasp_fs_function_desc,\n\t\t\tuasp_hs_function_desc, uasp_ss_function_desc,\n\t\t\tuasp_ss_function_desc);\n\tif (ret)\n\t\tgoto ep_fail;\n\n\treturn 0;\nep_fail:\n\tpr_err(\"Can't claim all required eps\\n\");\n\n\treturn -ENOTSUPP;\n}\n\nstruct guas_setup_wq {\n\tstruct work_struct work;\n\tstruct f_uas *fu;\n\tunsigned int alt;\n};\n\nstatic void tcm_delayed_set_alt(struct work_struct *wq)\n{\n\tstruct guas_setup_wq *work = container_of(wq, struct guas_setup_wq,\n\t\t\twork);\n\tstruct f_uas *fu = work->fu;\n\tint alt = work->alt;\n\n\tkfree(work);\n\n\tif (fu->flags & USBG_IS_BOT)\n\t\tbot_cleanup_old_alt(fu);\n\tif (fu->flags & USBG_IS_UAS)\n\t\tuasp_cleanup_old_alt(fu);\n\n\tif (alt == USB_G_ALT_INT_BBB)\n\t\tbot_set_alt(fu);\n\telse if (alt == USB_G_ALT_INT_UAS)\n\t\tuasp_set_alt(fu);\n\tusb_composite_setup_continue(fu->function.config->cdev);\n}\n\nstatic int tcm_get_alt(struct usb_function *f, unsigned intf)\n{\n\tif (intf == bot_intf_desc.bInterfaceNumber)\n\t\treturn USB_G_ALT_INT_BBB;\n\tif (intf == uasp_intf_desc.bInterfaceNumber)\n\t\treturn USB_G_ALT_INT_UAS;\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int tcm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_uas *fu = to_f_uas(f);\n\n\tif ((alt == USB_G_ALT_INT_BBB) || (alt == USB_G_ALT_INT_UAS)) {\n\t\tstruct guas_setup_wq *work;\n\n\t\twork = kmalloc(sizeof(*work), GFP_ATOMIC);\n\t\tif (!work)\n\t\t\treturn -ENOMEM;\n\t\tINIT_WORK(&work->work, tcm_delayed_set_alt);\n\t\twork->fu = fu;\n\t\twork->alt = alt;\n\t\tschedule_work(&work->work);\n\t\treturn USB_GADGET_DELAYED_STATUS;\n\t}\n\treturn -EOPNOTSUPP;\n}\n\nstatic void tcm_disable(struct usb_function *f)\n{\n\tstruct f_uas *fu = to_f_uas(f);\n\n\tif (fu->flags & USBG_IS_UAS)\n\t\tuasp_cleanup_old_alt(fu);\n\telse if (fu->flags & USBG_IS_BOT)\n\t\tbot_cleanup_old_alt(fu);\n\tfu->flags = 0;\n}\n\nstatic int tcm_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_uas *fu = to_f_uas(f);\n\n\tif (!(fu->flags & USBG_IS_BOT))\n\t\treturn -EOPNOTSUPP;\n\n\treturn usbg_bot_setup(f, ctrl);\n}\n\nstatic inline struct f_tcm_opts *to_f_tcm_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_tcm_opts,\n\t\tfunc_inst.group);\n}\n\nstatic void tcm_attr_release(struct config_item *item)\n{\n\tstruct f_tcm_opts *opts = to_f_tcm_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations tcm_item_ops = {\n\t.release\t\t= tcm_attr_release,\n};\n\nstatic const struct config_item_type tcm_func_type = {\n\t.ct_item_ops\t= &tcm_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void tcm_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_tcm_opts *opts;\n\tunsigned i;\n\n\topts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tmutex_lock(&tpg_instances_lock);\n\tfor (i = 0; i < TPG_INSTANCES; ++i)\n\t\tif (tpg_instances[i].func_inst == f)\n\t\t\tbreak;\n\tif (i < TPG_INSTANCES)\n\t\ttpg_instances[i].func_inst = NULL;\n\tmutex_unlock(&tpg_instances_lock);\n\n\tkfree(opts);\n}\n\nstatic int tcm_register_callback(struct usb_function_instance *f)\n{\n\tstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tmutex_lock(&opts->dep_lock);\n\topts->can_attach = true;\n\tmutex_unlock(&opts->dep_lock);\n\n\treturn 0;\n}\n\nstatic void tcm_unregister_callback(struct usb_function_instance *f)\n{\n\tstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tmutex_lock(&opts->dep_lock);\n\tunregister_gadget_item(opts->\n\t\tfunc_inst.group.cg_item.ci_parent->ci_parent);\n\topts->can_attach = false;\n\tmutex_unlock(&opts->dep_lock);\n}\n\nstatic int usbg_attach(struct usbg_tpg *tpg)\n{\n\tstruct usb_function_instance *f = tpg->fi;\n\tstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tif (opts->tcm_register_callback)\n\t\treturn opts->tcm_register_callback(f);\n\n\treturn 0;\n}\n\nstatic void usbg_detach(struct usbg_tpg *tpg)\n{\n\tstruct usb_function_instance *f = tpg->fi;\n\tstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tif (opts->tcm_unregister_callback)\n\t\topts->tcm_unregister_callback(f);\n}\n\nstatic int tcm_set_name(struct usb_function_instance *f, const char *name)\n{\n\tstruct f_tcm_opts *opts = container_of(f, struct f_tcm_opts, func_inst);\n\n\tpr_debug(\"tcm: Activating %s\\n\", name);\n\n\tmutex_lock(&opts->dep_lock);\n\topts->ready = true;\n\tmutex_unlock(&opts->dep_lock);\n\n\treturn 0;\n}\n\nstatic struct usb_function_instance *tcm_alloc_inst(void)\n{\n\tstruct f_tcm_opts *opts;\n\tint i;\n\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&tpg_instances_lock);\n\tfor (i = 0; i < TPG_INSTANCES; ++i)\n\t\tif (!tpg_instances[i].func_inst)\n\t\t\tbreak;\n\n\tif (i == TPG_INSTANCES) {\n\t\tmutex_unlock(&tpg_instances_lock);\n\t\tkfree(opts);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\ttpg_instances[i].func_inst = &opts->func_inst;\n\tmutex_unlock(&tpg_instances_lock);\n\n\tmutex_init(&opts->dep_lock);\n\topts->func_inst.set_inst_name = tcm_set_name;\n\topts->func_inst.free_func_inst = tcm_free_inst;\n\topts->tcm_register_callback = tcm_register_callback;\n\topts->tcm_unregister_callback = tcm_unregister_callback;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t&tcm_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void tcm_free(struct usb_function *f)\n{\n\tstruct f_uas *tcm = to_f_uas(f);\n\n\tkfree(tcm);\n}\n\nstatic void tcm_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *tcm_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_uas *fu;\n\tunsigned i;\n\n\tmutex_lock(&tpg_instances_lock);\n\tfor (i = 0; i < TPG_INSTANCES; ++i)\n\t\tif (tpg_instances[i].func_inst == fi)\n\t\t\tbreak;\n\tif (i == TPG_INSTANCES) {\n\t\tmutex_unlock(&tpg_instances_lock);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tfu = kzalloc(sizeof(*fu), GFP_KERNEL);\n\tif (!fu) {\n\t\tmutex_unlock(&tpg_instances_lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfu->function.name = \"Target Function\";\n\tfu->function.bind = tcm_bind;\n\tfu->function.unbind = tcm_unbind;\n\tfu->function.set_alt = tcm_set_alt;\n\tfu->function.get_alt = tcm_get_alt;\n\tfu->function.setup = tcm_setup;\n\tfu->function.disable = tcm_disable;\n\tfu->function.free_func = tcm_free;\n\tfu->tpg = tpg_instances[i].tpg;\n\tmutex_unlock(&tpg_instances_lock);\n\n\treturn &fu->function;\n}\n\nDECLARE_USB_FUNCTION(tcm, tcm_alloc_inst, tcm_alloc);\n\nstatic int __init tcm_init(void)\n{\n\tint ret;\n\n\tret = usb_function_register(&tcmusb_func);\n\tif (ret)\n\t\treturn ret;\n\n\tret = target_register_template(&usbg_ops);\n\tif (ret)\n\t\tusb_function_unregister(&tcmusb_func);\n\n\treturn ret;\n}\nmodule_init(tcm_init);\n\nstatic void __exit tcm_exit(void)\n{\n\ttarget_unregister_template(&usbg_ops);\n\tusb_function_unregister(&tcmusb_func);\n}\nmodule_exit(tcm_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Sebastian Andrzej Siewior\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}