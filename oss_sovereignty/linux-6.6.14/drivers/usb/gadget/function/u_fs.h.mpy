{
  "module_name": "u_fs.h",
  "hash_id": "8617b6deff511972889149289ad3fb4c6a0eb8cb859798bfea54c460f1a581a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/u_fs.h",
  "human_readable_source": " \n \n\n#ifndef U_FFS_H\n#define U_FFS_H\n\n#include <linux/usb/composite.h>\n#include <linux/list.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/refcount.h>\n\n#ifdef VERBOSE_DEBUG\n#ifndef pr_vdebug\n#  define pr_vdebug pr_debug\n#endif  \n#  define ffs_dump_mem(prefix, ptr, len) \\\n\tprint_hex_dump_bytes(pr_fmt(prefix \": \"), DUMP_PREFIX_NONE, ptr, len)\n#else\n#ifndef pr_vdebug\n#  define pr_vdebug(...)                 do { } while (0)\n#endif  \n#  define ffs_dump_mem(prefix, ptr, len) do { } while (0)\n#endif  \n\nstruct f_fs_opts;\n\nstruct ffs_dev {\n\tstruct ffs_data *ffs_data;\n\tstruct f_fs_opts *opts;\n\tstruct list_head entry;\n\n\tchar name[41];\n\n\tbool mounted;\n\tbool desc_ready;\n\tbool single;\n\n\tint (*ffs_ready_callback)(struct ffs_data *ffs);\n\tvoid (*ffs_closed_callback)(struct ffs_data *ffs);\n\tvoid *(*ffs_acquire_dev_callback)(struct ffs_dev *dev);\n\tvoid (*ffs_release_dev_callback)(struct ffs_dev *dev);\n};\n\nextern struct mutex ffs_lock;\n\nstatic inline void ffs_dev_lock(void)\n{\n\tmutex_lock(&ffs_lock);\n}\n\nstatic inline void ffs_dev_unlock(void)\n{\n\tmutex_unlock(&ffs_lock);\n}\n\nint ffs_name_dev(struct ffs_dev *dev, const char *name);\nint ffs_single_dev(struct ffs_dev *dev);\n\nstruct ffs_epfile;\nstruct ffs_function;\n\nenum ffs_state {\n\t \n\tFFS_READ_DESCRIPTORS,\n\tFFS_READ_STRINGS,\n\n\t \n\tFFS_ACTIVE,\n\n\t \n\tFFS_DEACTIVATED,\n\n\t \n\tFFS_CLOSING\n};\n\nenum ffs_setup_state {\n\t \n\tFFS_NO_SETUP,\n\t \n\tFFS_SETUP_PENDING,\n\t \n\tFFS_SETUP_CANCELLED\n};\n\nstruct ffs_data {\n\tstruct usb_gadget\t\t*gadget;\n\n\t \n\tstruct mutex\t\t\tmutex;\n\n\t \n\tspinlock_t\t\t\teps_lock;\n\n\t \n\tstruct usb_request\t\t*ep0req;\t\t \n\tstruct completion\t\tep0req_completion;\t \n\n\t \n\trefcount_t\t\t\tref;\n\t \n\tatomic_t\t\t\topened;\n\n\t \n\tenum ffs_state\t\t\tstate;\n\n\t \n\tenum ffs_setup_state\t\tsetup_state;\n\n\t \n\tstruct {\n\t\tu8\t\t\t\ttypes[4];\n\t\tunsigned short\t\t\tcount;\n\t\t \n\t\tunsigned short\t\t\tcan_stall;\n\t\tstruct usb_ctrlrequest\t\tsetup;\n\n\t\twait_queue_head_t\t\twaitq;\n\t} ev;  \n\n\t \n\tunsigned long\t\t\tflags;\n#define FFS_FL_CALL_CLOSED_CALLBACK 0\n#define FFS_FL_BOUND                1\n\n\t \n\twait_queue_head_t\t\twait;\n\n\t \n\tstruct ffs_function\t\t*func;\n\n\t \n\tconst char\t\t\t*dev_name;\n\t \n\tvoid\t\t\t\t*private_data;\n\n\t \n\t \n\tconst void\t\t\t*raw_descs_data;\n\tconst void\t\t\t*raw_descs;\n\tunsigned\t\t\traw_descs_length;\n\tunsigned\t\t\tfs_descs_count;\n\tunsigned\t\t\ths_descs_count;\n\tunsigned\t\t\tss_descs_count;\n\tunsigned\t\t\tms_os_descs_count;\n\tunsigned\t\t\tms_os_descs_ext_prop_count;\n\tunsigned\t\t\tms_os_descs_ext_prop_name_len;\n\tunsigned\t\t\tms_os_descs_ext_prop_data_len;\n\tvoid\t\t\t\t*ms_os_descs_ext_prop_avail;\n\tvoid\t\t\t\t*ms_os_descs_ext_prop_name_avail;\n\tvoid\t\t\t\t*ms_os_descs_ext_prop_data_avail;\n\n\tunsigned\t\t\tuser_flags;\n\n#define FFS_MAX_EPS_COUNT 31\n\tu8\t\t\t\teps_addrmap[FFS_MAX_EPS_COUNT];\n\n\tunsigned short\t\t\tstrings_count;\n\tunsigned short\t\t\tinterfaces_count;\n\tunsigned short\t\t\teps_count;\n\tunsigned short\t\t\t_pad1;\n\n\t \n\t \n\tconst void\t\t\t*raw_strings;\n\tstruct usb_gadget_strings\t**stringtabs;\n\n\t \n\tstruct super_block\t\t*sb;\n\n\t \n\tstruct ffs_file_perms {\n\t\tumode_t\t\t\t\tmode;\n\t\tkuid_t\t\t\t\tuid;\n\t\tkgid_t\t\t\t\tgid;\n\t}\t\t\t\tfile_perms;\n\n\tstruct eventfd_ctx *ffs_eventfd;\n\tstruct workqueue_struct *io_completion_wq;\n\tbool no_disconnect;\n\tstruct work_struct reset_work;\n\n\t \n\tstruct ffs_epfile\t\t*epfiles;\n};\n\n\nstruct f_fs_opts {\n\tstruct usb_function_instance\tfunc_inst;\n\tstruct ffs_dev\t\t\t*dev;\n\tunsigned\t\t\trefcnt;\n\tbool\t\t\t\tno_configfs;\n};\n\nstatic inline struct f_fs_opts *to_f_fs_opts(struct usb_function_instance *fi)\n{\n\treturn container_of(fi, struct f_fs_opts, func_inst);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}