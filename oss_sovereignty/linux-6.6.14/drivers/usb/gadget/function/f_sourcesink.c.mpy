{
  "module_name": "f_sourcesink.c",
  "hash_id": "950f6720a9379ce096463299b1c979d0f9ae0e13dff445ede4097c2570b6f8e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_sourcesink.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/usb/composite.h>\n#include <linux/err.h>\n\n#include \"g_zero.h\"\n#include \"u_f.h\"\n\n \nstruct f_sourcesink {\n\tstruct usb_function\tfunction;\n\n\tstruct usb_ep\t\t*in_ep;\n\tstruct usb_ep\t\t*out_ep;\n\tstruct usb_ep\t\t*iso_in_ep;\n\tstruct usb_ep\t\t*iso_out_ep;\n\tint\t\t\tcur_alt;\n\n\tunsigned pattern;\n\tunsigned isoc_interval;\n\tunsigned isoc_maxpacket;\n\tunsigned isoc_mult;\n\tunsigned isoc_maxburst;\n\tunsigned buflen;\n\tunsigned bulk_qlen;\n\tunsigned iso_qlen;\n};\n\nstatic inline struct f_sourcesink *func_to_ss(struct usb_function *f)\n{\n\treturn container_of(f, struct f_sourcesink, function);\n}\n\n \n\nstatic struct usb_interface_descriptor source_sink_intf_alt0 = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_VENDOR_SPEC,\n\t \n};\n\nstatic struct usb_interface_descriptor source_sink_intf_alt1 = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t4,\n\t.bInterfaceClass =\tUSB_CLASS_VENDOR_SPEC,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_iso_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1023),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_endpoint_descriptor fs_iso_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1023),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_descriptor_header *fs_source_sink_descs[] = {\n\t(struct usb_descriptor_header *) &source_sink_intf_alt0,\n\t(struct usb_descriptor_header *) &fs_sink_desc,\n\t(struct usb_descriptor_header *) &fs_source_desc,\n\t(struct usb_descriptor_header *) &source_sink_intf_alt1,\n#define FS_ALT_IFC_1_OFFSET\t3\n\t(struct usb_descriptor_header *) &fs_sink_desc,\n\t(struct usb_descriptor_header *) &fs_source_desc,\n\t(struct usb_descriptor_header *) &fs_iso_sink_desc,\n\t(struct usb_descriptor_header *) &fs_iso_source_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_iso_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_endpoint_descriptor hs_iso_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_descriptor_header *hs_source_sink_descs[] = {\n\t(struct usb_descriptor_header *) &source_sink_intf_alt0,\n\t(struct usb_descriptor_header *) &hs_source_desc,\n\t(struct usb_descriptor_header *) &hs_sink_desc,\n\t(struct usb_descriptor_header *) &source_sink_intf_alt1,\n#define HS_ALT_IFC_1_OFFSET\t3\n\t(struct usb_descriptor_header *) &hs_source_desc,\n\t(struct usb_descriptor_header *) &hs_sink_desc,\n\t(struct usb_descriptor_header *) &hs_iso_source_desc,\n\t(struct usb_descriptor_header *) &hs_iso_sink_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_source_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\t0,\n};\n\nstatic struct usb_endpoint_descriptor ss_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_sink_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\t0,\n};\n\nstatic struct usb_endpoint_descriptor ss_iso_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_iso_source_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor ss_iso_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n\t.bInterval =\t\t4,\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_iso_sink_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_descriptor_header *ss_source_sink_descs[] = {\n\t(struct usb_descriptor_header *) &source_sink_intf_alt0,\n\t(struct usb_descriptor_header *) &ss_source_desc,\n\t(struct usb_descriptor_header *) &ss_source_comp_desc,\n\t(struct usb_descriptor_header *) &ss_sink_desc,\n\t(struct usb_descriptor_header *) &ss_sink_comp_desc,\n\t(struct usb_descriptor_header *) &source_sink_intf_alt1,\n#define SS_ALT_IFC_1_OFFSET\t5\n\t(struct usb_descriptor_header *) &ss_source_desc,\n\t(struct usb_descriptor_header *) &ss_source_comp_desc,\n\t(struct usb_descriptor_header *) &ss_sink_desc,\n\t(struct usb_descriptor_header *) &ss_sink_comp_desc,\n\t(struct usb_descriptor_header *) &ss_iso_source_desc,\n\t(struct usb_descriptor_header *) &ss_iso_source_comp_desc,\n\t(struct usb_descriptor_header *) &ss_iso_sink_desc,\n\t(struct usb_descriptor_header *) &ss_iso_sink_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string strings_sourcesink[] = {\n\t[0].s = \"source and sink data\",\n\t{  }\t\t\t \n};\n\nstatic struct usb_gadget_strings stringtab_sourcesink = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_sourcesink,\n};\n\nstatic struct usb_gadget_strings *sourcesink_strings[] = {\n\t&stringtab_sourcesink,\n\tNULL,\n};\n\n \n\nstatic inline struct usb_request *ss_alloc_ep_req(struct usb_ep *ep, int len)\n{\n\treturn alloc_ep_req(ep, len);\n}\n\nstatic void disable_ep(struct usb_composite_dev *cdev, struct usb_ep *ep)\n{\n\tint\t\t\tvalue;\n\n\tvalue = usb_ep_disable(ep);\n\tif (value < 0)\n\t\tDBG(cdev, \"disable %s --> %d\\n\", ep->name, value);\n}\n\nvoid disable_endpoints(struct usb_composite_dev *cdev,\n\t\tstruct usb_ep *in, struct usb_ep *out,\n\t\tstruct usb_ep *iso_in, struct usb_ep *iso_out)\n{\n\tdisable_ep(cdev, in);\n\tdisable_ep(cdev, out);\n\tif (iso_in)\n\t\tdisable_ep(cdev, iso_in);\n\tif (iso_out)\n\t\tdisable_ep(cdev, iso_out);\n}\n\nstatic int\nsourcesink_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_sourcesink\t*ss = func_to_ss(f);\n\tint\tid;\n\tint ret;\n\n\t \n\tid = usb_interface_id(c, f);\n\tif (id < 0)\n\t\treturn id;\n\tsource_sink_intf_alt0.bInterfaceNumber = id;\n\tsource_sink_intf_alt1.bInterfaceNumber = id;\n\n\t \n\tss->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_source_desc);\n\tif (!ss->in_ep) {\nautoconf_fail:\n\t\tERROR(cdev, \"%s: can't autoconfigure on %s\\n\",\n\t\t\tf->name, cdev->gadget->name);\n\t\treturn -ENODEV;\n\t}\n\n\tss->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_sink_desc);\n\tif (!ss->out_ep)\n\t\tgoto autoconf_fail;\n\n\t \n\tif (ss->isoc_interval < 1)\n\t\tss->isoc_interval = 1;\n\tif (ss->isoc_interval > 16)\n\t\tss->isoc_interval = 16;\n\tif (ss->isoc_mult > 2)\n\t\tss->isoc_mult = 2;\n\tif (ss->isoc_maxburst > 15)\n\t\tss->isoc_maxburst = 15;\n\n\t \n\tfs_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?\n\t\t\t\t\t\t1023 : ss->isoc_maxpacket;\n\tfs_iso_source_desc.bInterval = ss->isoc_interval;\n\tfs_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket > 1023 ?\n\t\t\t\t\t\t1023 : ss->isoc_maxpacket;\n\tfs_iso_sink_desc.bInterval = ss->isoc_interval;\n\n\t \n\tss->iso_in_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_source_desc);\n\tif (!ss->iso_in_ep)\n\t\tgoto no_iso;\n\n\tss->iso_out_ep = usb_ep_autoconfig(cdev->gadget, &fs_iso_sink_desc);\n\tif (!ss->iso_out_ep) {\n\t\tusb_ep_autoconfig_release(ss->iso_in_ep);\n\t\tss->iso_in_ep = NULL;\nno_iso:\n\t\t \n\t\tfs_source_sink_descs[FS_ALT_IFC_1_OFFSET] = NULL;\n\t\ths_source_sink_descs[HS_ALT_IFC_1_OFFSET] = NULL;\n\t\tss_source_sink_descs[SS_ALT_IFC_1_OFFSET] = NULL;\n\t}\n\n\tif (ss->isoc_maxpacket > 1024)\n\t\tss->isoc_maxpacket = 1024;\n\n\t \n\ths_source_desc.bEndpointAddress = fs_source_desc.bEndpointAddress;\n\ths_sink_desc.bEndpointAddress = fs_sink_desc.bEndpointAddress;\n\n\t \n\ths_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;\n\ths_iso_source_desc.wMaxPacketSize |= ss->isoc_mult << 11;\n\ths_iso_source_desc.bInterval = ss->isoc_interval;\n\ths_iso_source_desc.bEndpointAddress =\n\t\tfs_iso_source_desc.bEndpointAddress;\n\n\ths_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;\n\ths_iso_sink_desc.wMaxPacketSize |= ss->isoc_mult << 11;\n\ths_iso_sink_desc.bInterval = ss->isoc_interval;\n\ths_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;\n\n\t \n\tss_source_desc.bEndpointAddress =\n\t\tfs_source_desc.bEndpointAddress;\n\tss_sink_desc.bEndpointAddress =\n\t\tfs_sink_desc.bEndpointAddress;\n\n\t \n\tss_iso_source_desc.wMaxPacketSize = ss->isoc_maxpacket;\n\tss_iso_source_desc.bInterval = ss->isoc_interval;\n\tss_iso_source_comp_desc.bmAttributes = ss->isoc_mult;\n\tss_iso_source_comp_desc.bMaxBurst = ss->isoc_maxburst;\n\tss_iso_source_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *\n\t\t(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);\n\tss_iso_source_desc.bEndpointAddress =\n\t\tfs_iso_source_desc.bEndpointAddress;\n\n\tss_iso_sink_desc.wMaxPacketSize = ss->isoc_maxpacket;\n\tss_iso_sink_desc.bInterval = ss->isoc_interval;\n\tss_iso_sink_comp_desc.bmAttributes = ss->isoc_mult;\n\tss_iso_sink_comp_desc.bMaxBurst = ss->isoc_maxburst;\n\tss_iso_sink_comp_desc.wBytesPerInterval = ss->isoc_maxpacket *\n\t\t(ss->isoc_mult + 1) * (ss->isoc_maxburst + 1);\n\tss_iso_sink_desc.bEndpointAddress = fs_iso_sink_desc.bEndpointAddress;\n\n\tret = usb_assign_descriptors(f, fs_source_sink_descs,\n\t\t\ths_source_sink_descs, ss_source_sink_descs,\n\t\t\tss_source_sink_descs);\n\tif (ret)\n\t\treturn ret;\n\n\tDBG(cdev, \"%s: IN/%s, OUT/%s, ISO-IN/%s, ISO-OUT/%s\\n\",\n\t\t\tf->name, ss->in_ep->name, ss->out_ep->name,\n\t\t\tss->iso_in_ep ? ss->iso_in_ep->name : \"<none>\",\n\t\t\tss->iso_out_ep ? ss->iso_out_ep->name : \"<none>\");\n\treturn 0;\n}\n\nstatic void\nsourcesink_free_func(struct usb_function *f)\n{\n\tstruct f_ss_opts *opts;\n\n\topts = container_of(f->fi, struct f_ss_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n\n\tusb_free_all_descriptors(f);\n\tkfree(func_to_ss(f));\n}\n\n \nstatic int check_read_data(struct f_sourcesink *ss, struct usb_request *req)\n{\n\tunsigned\t\ti;\n\tu8\t\t\t*buf = req->buf;\n\tstruct usb_composite_dev *cdev = ss->function.config->cdev;\n\tint max_packet_size = le16_to_cpu(ss->out_ep->desc->wMaxPacketSize);\n\n\tif (ss->pattern == 2)\n\t\treturn 0;\n\n\tfor (i = 0; i < req->actual; i++, buf++) {\n\t\tswitch (ss->pattern) {\n\n\t\t \n\t\tcase 0:\n\t\t\tif (*buf == 0)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\n\t\t \n\t\tcase 1:\n\t\t\tif (*buf == (u8)((i % max_packet_size) % 63))\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tERROR(cdev, \"bad OUT byte, buf[%d] = %d\\n\", i, *buf);\n\t\tusb_ep_set_halt(ss->out_ep);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void reinit_write_data(struct usb_ep *ep, struct usb_request *req)\n{\n\tunsigned\ti;\n\tu8\t\t*buf = req->buf;\n\tint max_packet_size = le16_to_cpu(ep->desc->wMaxPacketSize);\n\tstruct f_sourcesink *ss = ep->driver_data;\n\n\tswitch (ss->pattern) {\n\tcase 0:\n\t\tmemset(req->buf, 0, req->length);\n\t\tbreak;\n\tcase 1:\n\t\tfor  (i = 0; i < req->length; i++)\n\t\t\t*buf++ = (u8) ((i % max_packet_size) % 63);\n\t\tbreak;\n\tcase 2:\n\t\tbreak;\n\t}\n}\n\nstatic void source_sink_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usb_composite_dev\t*cdev;\n\tstruct f_sourcesink\t\t*ss = ep->driver_data;\n\tint\t\t\t\tstatus = req->status;\n\n\t \n\tif (!ss)\n\t\treturn;\n\n\tcdev = ss->function.config->cdev;\n\n\tswitch (status) {\n\n\tcase 0:\t\t\t\t \n\t\tif (ep == ss->out_ep) {\n\t\t\tcheck_read_data(ss, req);\n\t\t\tif (ss->pattern != 2)\n\t\t\t\tmemset(req->buf, 0x55, req->length);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase -ECONNABORTED:\t\t \n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tVDBG(cdev, \"%s gone (%d), %d/%d\\n\", ep->name, status,\n\t\t\t\treq->actual, req->length);\n\t\tif (ep == ss->out_ep)\n\t\t\tcheck_read_data(ss, req);\n\t\tfree_ep_req(ep, req);\n\t\treturn;\n\n\tcase -EOVERFLOW:\t\t \n\tdefault:\n#if 1\n\t\tDBG(cdev, \"%s complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tbreak;\n#endif\n\tcase -EREMOTEIO:\t\t \n\t\tbreak;\n\t}\n\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (status) {\n\t\tERROR(cdev, \"kill %s:  resubmit %d bytes --> %d\\n\",\n\t\t\t\tep->name, req->length, status);\n\t\tusb_ep_set_halt(ep);\n\t\t \n\t}\n}\n\nstatic int source_sink_start_ep(struct f_sourcesink *ss, bool is_in,\n\t\tbool is_iso, int speed)\n{\n\tstruct usb_ep\t\t*ep;\n\tstruct usb_request\t*req;\n\tint\t\t\ti, size, qlen, status = 0;\n\n\tif (is_iso) {\n\t\tswitch (speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\t\tsize = ss->isoc_maxpacket *\n\t\t\t\t\t(ss->isoc_mult + 1) *\n\t\t\t\t\t(ss->isoc_maxburst + 1);\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tsize = ss->isoc_maxpacket * (ss->isoc_mult + 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = ss->isoc_maxpacket > 1023 ?\n\t\t\t\t\t1023 : ss->isoc_maxpacket;\n\t\t\tbreak;\n\t\t}\n\t\tep = is_in ? ss->iso_in_ep : ss->iso_out_ep;\n\t\tqlen = ss->iso_qlen;\n\t} else {\n\t\tep = is_in ? ss->in_ep : ss->out_ep;\n\t\tqlen = ss->bulk_qlen;\n\t\tsize = ss->buflen;\n\t}\n\n\tfor (i = 0; i < qlen; i++) {\n\t\treq = ss_alloc_ep_req(ep, size);\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = source_sink_complete;\n\t\tif (is_in)\n\t\t\treinit_write_data(ep, req);\n\t\telse if (ss->pattern != 2)\n\t\t\tmemset(req->buf, 0x55, req->length);\n\n\t\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\t\tif (status) {\n\t\t\tstruct usb_composite_dev\t*cdev;\n\n\t\t\tcdev = ss->function.config->cdev;\n\t\t\tERROR(cdev, \"start %s%s %s --> %d\\n\",\n\t\t\t      is_iso ? \"ISO-\" : \"\", is_in ? \"IN\" : \"OUT\",\n\t\t\t      ep->name, status);\n\t\t\tfree_ep_req(ep, req);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void disable_source_sink(struct f_sourcesink *ss)\n{\n\tstruct usb_composite_dev\t*cdev;\n\n\tcdev = ss->function.config->cdev;\n\tdisable_endpoints(cdev, ss->in_ep, ss->out_ep, ss->iso_in_ep,\n\t\t\tss->iso_out_ep);\n\tVDBG(cdev, \"%s disabled\\n\", ss->function.name);\n}\n\nstatic int\nenable_source_sink(struct usb_composite_dev *cdev, struct f_sourcesink *ss,\n\t\tint alt)\n{\n\tint\t\t\t\t\tresult = 0;\n\tint\t\t\t\t\tspeed = cdev->gadget->speed;\n\tstruct usb_ep\t\t\t\t*ep;\n\n\t \n\tep = ss->in_ep;\n\tresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\n\tif (result)\n\t\treturn result;\n\tresult = usb_ep_enable(ep);\n\tif (result < 0)\n\t\treturn result;\n\tep->driver_data = ss;\n\n\tresult = source_sink_start_ep(ss, true, false, speed);\n\tif (result < 0) {\nfail:\n\t\tep = ss->in_ep;\n\t\tusb_ep_disable(ep);\n\t\treturn result;\n\t}\n\n\t \n\tep = ss->out_ep;\n\tresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\n\tif (result)\n\t\tgoto fail;\n\tresult = usb_ep_enable(ep);\n\tif (result < 0)\n\t\tgoto fail;\n\tep->driver_data = ss;\n\n\tresult = source_sink_start_ep(ss, false, false, speed);\n\tif (result < 0) {\nfail2:\n\t\tep = ss->out_ep;\n\t\tusb_ep_disable(ep);\n\t\tgoto fail;\n\t}\n\n\tif (alt == 0)\n\t\tgoto out;\n\n\t \n\tep = ss->iso_in_ep;\n\tif (ep) {\n\t\tresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\n\t\tif (result)\n\t\t\tgoto fail2;\n\t\tresult = usb_ep_enable(ep);\n\t\tif (result < 0)\n\t\t\tgoto fail2;\n\t\tep->driver_data = ss;\n\n\t\tresult = source_sink_start_ep(ss, true, true, speed);\n\t\tif (result < 0) {\nfail3:\n\t\t\tep = ss->iso_in_ep;\n\t\t\tif (ep)\n\t\t\t\tusb_ep_disable(ep);\n\t\t\tgoto fail2;\n\t\t}\n\t}\n\n\t \n\tep = ss->iso_out_ep;\n\tif (ep) {\n\t\tresult = config_ep_by_speed(cdev->gadget, &(ss->function), ep);\n\t\tif (result)\n\t\t\tgoto fail3;\n\t\tresult = usb_ep_enable(ep);\n\t\tif (result < 0)\n\t\t\tgoto fail3;\n\t\tep->driver_data = ss;\n\n\t\tresult = source_sink_start_ep(ss, false, true, speed);\n\t\tif (result < 0) {\n\t\t\tusb_ep_disable(ep);\n\t\t\tgoto fail3;\n\t\t}\n\t}\nout:\n\tss->cur_alt = alt;\n\n\tDBG(cdev, \"%s enabled, alt intf %d\\n\", ss->function.name, alt);\n\treturn result;\n}\n\nstatic int sourcesink_set_alt(struct usb_function *f,\n\t\tunsigned intf, unsigned alt)\n{\n\tstruct f_sourcesink\t\t*ss = func_to_ss(f);\n\tstruct usb_composite_dev\t*cdev = f->config->cdev;\n\n\tdisable_source_sink(ss);\n\treturn enable_source_sink(cdev, ss, alt);\n}\n\nstatic int sourcesink_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_sourcesink\t\t*ss = func_to_ss(f);\n\n\treturn ss->cur_alt;\n}\n\nstatic void sourcesink_disable(struct usb_function *f)\n{\n\tstruct f_sourcesink\t*ss = func_to_ss(f);\n\n\tdisable_source_sink(ss);\n}\n\n \n\nstatic int sourcesink_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_configuration        *c = f->config;\n\tstruct usb_request\t*req = c->cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\treq->length = USB_COMP_EP0_BUFSIZ;\n\n\t \n\tswitch (ctrl->bRequest) {\n\n\t \n\tcase 0x5b:\t \n\t\tif (ctrl->bRequestType != (USB_DIR_OUT|USB_TYPE_VENDOR))\n\t\t\tgoto unknown;\n\t\tif (w_value || w_index)\n\t\t\tbreak;\n\t\t \n\t\tif (w_length > req->length)\n\t\t\tbreak;\n\t\tvalue = w_length;\n\t\tbreak;\n\tcase 0x5c:\t \n\t\tif (ctrl->bRequestType != (USB_DIR_IN|USB_TYPE_VENDOR))\n\t\t\tgoto unknown;\n\t\tif (w_value || w_index)\n\t\t\tbreak;\n\t\t \n\t\tif (w_length > req->length)\n\t\t\tbreak;\n\t\tvalue = w_length;\n\t\tbreak;\n\n\tdefault:\nunknown:\n\t\tVDBG(c->cdev,\n\t\t\t\"unknown control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tVDBG(c->cdev, \"source/sink req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(c->cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(c->cdev, \"source/sink response, err %d\\n\",\n\t\t\t\t\tvalue);\n\t}\n\n\t \n\treturn value;\n}\n\nstatic struct usb_function *source_sink_alloc_func(\n\t\tstruct usb_function_instance *fi)\n{\n\tstruct f_sourcesink     *ss;\n\tstruct f_ss_opts\t*ss_opts;\n\n\tss = kzalloc(sizeof(*ss), GFP_KERNEL);\n\tif (!ss)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tss_opts =  container_of(fi, struct f_ss_opts, func_inst);\n\n\tmutex_lock(&ss_opts->lock);\n\tss_opts->refcnt++;\n\tmutex_unlock(&ss_opts->lock);\n\n\tss->pattern = ss_opts->pattern;\n\tss->isoc_interval = ss_opts->isoc_interval;\n\tss->isoc_maxpacket = ss_opts->isoc_maxpacket;\n\tss->isoc_mult = ss_opts->isoc_mult;\n\tss->isoc_maxburst = ss_opts->isoc_maxburst;\n\tss->buflen = ss_opts->bulk_buflen;\n\tss->bulk_qlen = ss_opts->bulk_qlen;\n\tss->iso_qlen = ss_opts->iso_qlen;\n\n\tss->function.name = \"source/sink\";\n\tss->function.bind = sourcesink_bind;\n\tss->function.set_alt = sourcesink_set_alt;\n\tss->function.get_alt = sourcesink_get_alt;\n\tss->function.disable = sourcesink_disable;\n\tss->function.setup = sourcesink_setup;\n\tss->function.strings = sourcesink_strings;\n\n\tss->function.free_func = sourcesink_free_func;\n\n\treturn &ss->function;\n}\n\nstatic inline struct f_ss_opts *to_f_ss_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_ss_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void ss_attr_release(struct config_item *item)\n{\n\tstruct f_ss_opts *ss_opts = to_f_ss_opts(item);\n\n\tusb_put_function_instance(&ss_opts->func_inst);\n}\n\nstatic struct configfs_item_operations ss_item_ops = {\n\t.release\t\t= ss_attr_release,\n};\n\nstatic ssize_t f_ss_opts_pattern_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->pattern);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_pattern_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu8 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tif (num != 0 && num != 1 && num != 2) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\topts->pattern = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, pattern);\n\nstatic ssize_t f_ss_opts_isoc_interval_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->isoc_interval);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_isoc_interval_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu8 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tif (num > 16) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\topts->isoc_interval = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, isoc_interval);\n\nstatic ssize_t f_ss_opts_isoc_maxpacket_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->isoc_maxpacket);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_isoc_maxpacket_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu16 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou16(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tif (num > 1024) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\topts->isoc_maxpacket = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, isoc_maxpacket);\n\nstatic ssize_t f_ss_opts_isoc_mult_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->isoc_mult);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_isoc_mult_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu8 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tif (num > 2) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\topts->isoc_mult = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, isoc_mult);\n\nstatic ssize_t f_ss_opts_isoc_maxburst_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->isoc_maxburst);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_isoc_maxburst_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu8 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tif (num > 15) {\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\topts->isoc_maxburst = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, isoc_maxburst);\n\nstatic ssize_t f_ss_opts_bulk_buflen_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->bulk_buflen);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_bulk_buflen_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu32 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->bulk_buflen = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, bulk_buflen);\n\nstatic ssize_t f_ss_opts_bulk_qlen_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->bulk_qlen);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_bulk_qlen_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu32 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->bulk_qlen = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, bulk_qlen);\n\nstatic ssize_t f_ss_opts_iso_qlen_show(struct config_item *item, char *page)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", opts->iso_qlen);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_ss_opts_iso_qlen_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct f_ss_opts *opts = to_f_ss_opts(item);\n\tint ret;\n\tu32 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->iso_qlen = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_ss_opts_, iso_qlen);\n\nstatic struct configfs_attribute *ss_attrs[] = {\n\t&f_ss_opts_attr_pattern,\n\t&f_ss_opts_attr_isoc_interval,\n\t&f_ss_opts_attr_isoc_maxpacket,\n\t&f_ss_opts_attr_isoc_mult,\n\t&f_ss_opts_attr_isoc_maxburst,\n\t&f_ss_opts_attr_bulk_buflen,\n\t&f_ss_opts_attr_bulk_qlen,\n\t&f_ss_opts_attr_iso_qlen,\n\tNULL,\n};\n\nstatic const struct config_item_type ss_func_type = {\n\t.ct_item_ops    = &ss_item_ops,\n\t.ct_attrs\t= ss_attrs,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic void source_sink_free_instance(struct usb_function_instance *fi)\n{\n\tstruct f_ss_opts *ss_opts;\n\n\tss_opts = container_of(fi, struct f_ss_opts, func_inst);\n\tkfree(ss_opts);\n}\n\nstatic struct usb_function_instance *source_sink_alloc_inst(void)\n{\n\tstruct f_ss_opts *ss_opts;\n\n\tss_opts = kzalloc(sizeof(*ss_opts), GFP_KERNEL);\n\tif (!ss_opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&ss_opts->lock);\n\tss_opts->func_inst.free_func_inst = source_sink_free_instance;\n\tss_opts->isoc_interval = GZERO_ISOC_INTERVAL;\n\tss_opts->isoc_maxpacket = GZERO_ISOC_MAXPACKET;\n\tss_opts->bulk_buflen = GZERO_BULK_BUFLEN;\n\tss_opts->bulk_qlen = GZERO_SS_BULK_QLEN;\n\tss_opts->iso_qlen = GZERO_SS_ISO_QLEN;\n\n\tconfig_group_init_type_name(&ss_opts->func_inst.group, \"\",\n\t\t\t\t    &ss_func_type);\n\n\treturn &ss_opts->func_inst;\n}\nDECLARE_USB_FUNCTION(SourceSink, source_sink_alloc_inst,\n\t\tsource_sink_alloc_func);\n\nstatic int __init sslb_modinit(void)\n{\n\tint ret;\n\n\tret = usb_function_register(&SourceSinkusb_func);\n\tif (ret)\n\t\treturn ret;\n\tret = lb_modinit();\n\tif (ret)\n\t\tusb_function_unregister(&SourceSinkusb_func);\n\treturn ret;\n}\nstatic void __exit sslb_modexit(void)\n{\n\tusb_function_unregister(&SourceSinkusb_func);\n\tlb_modexit();\n}\nmodule_init(sslb_modinit);\nmodule_exit(sslb_modexit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}