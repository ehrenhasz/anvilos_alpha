{
  "module_name": "f_ecm.c",
  "hash_id": "44430884ec845344961dbfcd45e3796b61c93b2bc23003ea42c4180dc0bdb8d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_ecm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/etherdevice.h>\n\n#include \"u_ether.h\"\n#include \"u_ether_configfs.h\"\n#include \"u_ecm.h\"\n\n\n \n\n\nenum ecm_notify_state {\n\tECM_NOTIFY_NONE,\t\t \n\tECM_NOTIFY_CONNECT,\t\t \n\tECM_NOTIFY_SPEED,\t\t \n};\n\nstruct f_ecm {\n\tstruct gether\t\t\tport;\n\tu8\t\t\t\tctrl_id, data_id;\n\n\tchar\t\t\t\tethaddr[14];\n\n\tstruct usb_ep\t\t\t*notify;\n\tstruct usb_request\t\t*notify_req;\n\tu8\t\t\t\tnotify_state;\n\tatomic_t\t\t\tnotify_count;\n\tbool\t\t\t\tis_open;\n\n\t \n};\n\nstatic inline struct f_ecm *func_to_ecm(struct usb_function *f)\n{\n\treturn container_of(f, struct f_ecm, port.func);\n}\n\n \n\n \n\n#define ECM_STATUS_INTERVAL_MS\t\t32\n#define ECM_STATUS_BYTECOUNT\t\t16\t \n\n\n \n\nstatic struct usb_interface_assoc_descriptor\necm_iad_descriptor = {\n\t.bLength =\t\tsizeof ecm_iad_descriptor,\n\t.bDescriptorType =\tUSB_DT_INTERFACE_ASSOCIATION,\n\n\t \n\t.bInterfaceCount =\t2,\t \n\t.bFunctionClass =\tUSB_CLASS_COMM,\n\t.bFunctionSubClass =\tUSB_CDC_SUBCLASS_ETHERNET,\n\t.bFunctionProtocol =\tUSB_CDC_PROTO_NONE,\n\t \n};\n\n\nstatic struct usb_interface_descriptor ecm_control_intf = {\n\t.bLength =\t\tsizeof ecm_control_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t \n\t \n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_ETHERNET,\n\t.bInterfaceProtocol =\tUSB_CDC_PROTO_NONE,\n\t \n};\n\nstatic struct usb_cdc_header_desc ecm_header_desc = {\n\t.bLength =\t\tsizeof ecm_header_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic struct usb_cdc_union_desc ecm_union_desc = {\n\t.bLength =\t\tsizeof(ecm_union_desc),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_UNION_TYPE,\n\t \n\t \n};\n\nstatic struct usb_cdc_ether_desc ecm_desc = {\n\t.bLength =\t\tsizeof ecm_desc,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_ETHERNET_TYPE,\n\n\t \n\t \n\t.bmEthernetStatistics =\tcpu_to_le32(0),  \n\t.wMaxSegmentSize =\tcpu_to_le16(ETH_FRAME_LEN),\n\t.wNumberMCFilters =\tcpu_to_le16(0),\n\t.bNumberPowerFilters =\t0,\n};\n\n \n\nstatic struct usb_interface_descriptor ecm_data_nop_intf = {\n\t.bLength =\t\tsizeof ecm_data_nop_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bInterfaceNumber =\t1,\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\n \n\nstatic struct usb_interface_descriptor ecm_data_intf = {\n\t.bLength =\t\tsizeof ecm_data_intf,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bInterfaceNumber =\t1,\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_ecm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(ECM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tECM_STATUS_INTERVAL_MS,\n};\n\nstatic struct usb_endpoint_descriptor fs_ecm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_ecm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *ecm_fs_function[] = {\n\t \n\t(struct usb_descriptor_header *) &ecm_iad_descriptor,\n\t(struct usb_descriptor_header *) &ecm_control_intf,\n\t(struct usb_descriptor_header *) &ecm_header_desc,\n\t(struct usb_descriptor_header *) &ecm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\n\t \n\t(struct usb_descriptor_header *) &fs_ecm_notify_desc,\n\n\t \n\t(struct usb_descriptor_header *) &ecm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ecm_data_intf,\n\t(struct usb_descriptor_header *) &fs_ecm_in_desc,\n\t(struct usb_descriptor_header *) &fs_ecm_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_ecm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(ECM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(ECM_STATUS_INTERVAL_MS),\n};\n\nstatic struct usb_endpoint_descriptor hs_ecm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_ecm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *ecm_hs_function[] = {\n\t \n\t(struct usb_descriptor_header *) &ecm_iad_descriptor,\n\t(struct usb_descriptor_header *) &ecm_control_intf,\n\t(struct usb_descriptor_header *) &ecm_header_desc,\n\t(struct usb_descriptor_header *) &ecm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\n\t \n\t(struct usb_descriptor_header *) &hs_ecm_notify_desc,\n\n\t \n\t(struct usb_descriptor_header *) &ecm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ecm_data_intf,\n\t(struct usb_descriptor_header *) &hs_ecm_in_desc,\n\t(struct usb_descriptor_header *) &hs_ecm_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_ecm_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(ECM_STATUS_BYTECOUNT),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(ECM_STATUS_INTERVAL_MS),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ecm_intr_comp_desc = {\n\t.bLength =\t\tsizeof ss_ecm_intr_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n\t.wBytesPerInterval =\tcpu_to_le16(ECM_STATUS_BYTECOUNT),\n};\n\nstatic struct usb_endpoint_descriptor ss_ecm_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor ss_ecm_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ecm_bulk_comp_desc = {\n\t.bLength =\t\tsizeof ss_ecm_bulk_comp_desc,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\n\t \n\t \n\t \n};\n\nstatic struct usb_descriptor_header *ecm_ss_function[] = {\n\t \n\t(struct usb_descriptor_header *) &ecm_iad_descriptor,\n\t(struct usb_descriptor_header *) &ecm_control_intf,\n\t(struct usb_descriptor_header *) &ecm_header_desc,\n\t(struct usb_descriptor_header *) &ecm_union_desc,\n\t(struct usb_descriptor_header *) &ecm_desc,\n\n\t \n\t(struct usb_descriptor_header *) &ss_ecm_notify_desc,\n\t(struct usb_descriptor_header *) &ss_ecm_intr_comp_desc,\n\n\t \n\t(struct usb_descriptor_header *) &ecm_data_nop_intf,\n\t(struct usb_descriptor_header *) &ecm_data_intf,\n\t(struct usb_descriptor_header *) &ss_ecm_in_desc,\n\t(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &ss_ecm_out_desc,\n\t(struct usb_descriptor_header *) &ss_ecm_bulk_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string ecm_string_defs[] = {\n\t[0].s = \"CDC Ethernet Control Model (ECM)\",\n\t[1].s = \"\",\n\t[2].s = \"CDC Ethernet Data\",\n\t[3].s = \"CDC ECM\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings ecm_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\tecm_string_defs,\n};\n\nstatic struct usb_gadget_strings *ecm_strings[] = {\n\t&ecm_string_table,\n\tNULL,\n};\n\n \n\nstatic void ecm_do_notify(struct f_ecm *ecm)\n{\n\tstruct usb_request\t\t*req = ecm->notify_req;\n\tstruct usb_cdc_notification\t*event;\n\tstruct usb_composite_dev\t*cdev = ecm->port.func.config->cdev;\n\t__le32\t\t\t\t*data;\n\tint\t\t\t\tstatus;\n\n\t \n\tif (atomic_read(&ecm->notify_count))\n\t\treturn;\n\n\tevent = req->buf;\n\tswitch (ecm->notify_state) {\n\tcase ECM_NOTIFY_NONE:\n\t\treturn;\n\n\tcase ECM_NOTIFY_CONNECT:\n\t\tevent->bNotificationType = USB_CDC_NOTIFY_NETWORK_CONNECTION;\n\t\tif (ecm->is_open)\n\t\t\tevent->wValue = cpu_to_le16(1);\n\t\telse\n\t\t\tevent->wValue = cpu_to_le16(0);\n\t\tevent->wLength = 0;\n\t\treq->length = sizeof *event;\n\n\t\tDBG(cdev, \"notify connect %s\\n\",\n\t\t\t\tecm->is_open ? \"true\" : \"false\");\n\t\tecm->notify_state = ECM_NOTIFY_SPEED;\n\t\tbreak;\n\n\tcase ECM_NOTIFY_SPEED:\n\t\tevent->bNotificationType = USB_CDC_NOTIFY_SPEED_CHANGE;\n\t\tevent->wValue = cpu_to_le16(0);\n\t\tevent->wLength = cpu_to_le16(8);\n\t\treq->length = ECM_STATUS_BYTECOUNT;\n\n\t\t \n\t\tdata = req->buf + sizeof *event;\n\t\tdata[0] = cpu_to_le32(gether_bitrate(cdev->gadget));\n\t\tdata[1] = data[0];\n\n\t\tDBG(cdev, \"notify speed %d\\n\", gether_bitrate(cdev->gadget));\n\t\tecm->notify_state = ECM_NOTIFY_NONE;\n\t\tbreak;\n\t}\n\tevent->bmRequestType = 0xA1;\n\tevent->wIndex = cpu_to_le16(ecm->ctrl_id);\n\n\tatomic_inc(&ecm->notify_count);\n\tstatus = usb_ep_queue(ecm->notify, req, GFP_ATOMIC);\n\tif (status < 0) {\n\t\tatomic_dec(&ecm->notify_count);\n\t\tDBG(cdev, \"notify --> %d\\n\", status);\n\t}\n}\n\nstatic void ecm_notify(struct f_ecm *ecm)\n{\n\t \n\tecm->notify_state = ECM_NOTIFY_CONNECT;\n\tecm_do_notify(ecm);\n}\n\nstatic void ecm_notify_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_ecm\t\t\t*ecm = req->context;\n\tstruct usb_composite_dev\t*cdev = ecm->port.func.config->cdev;\n\tstruct usb_cdc_notification\t*event = req->buf;\n\n\tswitch (req->status) {\n\tcase 0:\n\t\t \n\t\tatomic_dec(&ecm->notify_count);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tatomic_set(&ecm->notify_count, 0);\n\t\tecm->notify_state = ECM_NOTIFY_NONE;\n\t\tbreak;\n\tdefault:\n\t\tDBG(cdev, \"event %02x --> %d\\n\",\n\t\t\tevent->bNotificationType, req->status);\n\t\tatomic_dec(&ecm->notify_count);\n\t\tbreak;\n\t}\n\tecm_do_notify(ecm);\n}\n\nstatic int ecm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_SET_ETHERNET_PACKET_FILTER:\n\t\t \n\t\tif (w_length != 0 || w_index != ecm->ctrl_id)\n\t\t\tgoto invalid;\n\t\tDBG(cdev, \"packet filter %02x\\n\", w_value);\n\t\t \n\t\tecm->port.cdc_filter = w_value;\n\t\tvalue = 0;\n\t\tbreak;\n\n\t \n\n\tdefault:\ninvalid:\n\t\tDBG(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tDBG(cdev, \"ecm req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"ecm req %02x.%02x response err %d\\n\",\n\t\t\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\t\t\tvalue);\n\t}\n\n\t \n\treturn value;\n}\n\n\nstatic int ecm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\tif (intf == ecm->ctrl_id) {\n\t\tif (alt != 0)\n\t\t\tgoto fail;\n\n\t\tVDBG(cdev, \"reset ecm control %d\\n\", intf);\n\t\tusb_ep_disable(ecm->notify);\n\t\tif (!(ecm->notify->desc)) {\n\t\t\tVDBG(cdev, \"init ecm ctrl %d\\n\", intf);\n\t\t\tif (config_ep_by_speed(cdev->gadget, f, ecm->notify))\n\t\t\t\tgoto fail;\n\t\t}\n\t\tusb_ep_enable(ecm->notify);\n\n\t \n\t} else if (intf == ecm->data_id) {\n\t\tif (alt > 1)\n\t\t\tgoto fail;\n\n\t\tif (ecm->port.in_ep->enabled) {\n\t\t\tDBG(cdev, \"reset ecm\\n\");\n\t\t\tgether_disconnect(&ecm->port);\n\t\t}\n\n\t\tif (!ecm->port.in_ep->desc ||\n\t\t    !ecm->port.out_ep->desc) {\n\t\t\tDBG(cdev, \"init ecm\\n\");\n\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       ecm->port.in_ep) ||\n\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       ecm->port.out_ep)) {\n\t\t\t\tecm->port.in_ep->desc = NULL;\n\t\t\t\tecm->port.out_ep->desc = NULL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (alt == 1) {\n\t\t\tstruct net_device\t*net;\n\n\t\t\t \n\t\t\tecm->port.is_zlp_ok =\n\t\t\t\tgadget_is_zlp_supported(cdev->gadget);\n\t\t\tecm->port.cdc_filter = DEFAULT_FILTER;\n\t\t\tDBG(cdev, \"activate ecm\\n\");\n\t\t\tnet = gether_connect(&ecm->port);\n\t\t\tif (IS_ERR(net))\n\t\t\t\treturn PTR_ERR(net);\n\t\t}\n\n\t\t \n\t\tecm_notify(ecm);\n\t} else\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\n\n \nstatic int ecm_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\n\tif (intf == ecm->ctrl_id)\n\t\treturn 0;\n\treturn ecm->port.in_ep->enabled ? 1 : 0;\n}\n\nstatic void ecm_disable(struct usb_function *f)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tDBG(cdev, \"ecm deactivated\\n\");\n\n\tif (ecm->port.in_ep->enabled) {\n\t\tgether_disconnect(&ecm->port);\n\t} else {\n\t\tecm->port.in_ep->desc = NULL;\n\t\tecm->port.out_ep->desc = NULL;\n\t}\n\n\tusb_ep_disable(ecm->notify);\n\tecm->notify->desc = NULL;\n}\n\n \n\n \n\nstatic void ecm_open(struct gether *geth)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(&geth->func);\n\n\tDBG(ecm->port.func.config->cdev, \"%s\\n\", __func__);\n\n\tecm->is_open = true;\n\tecm_notify(ecm);\n}\n\nstatic void ecm_close(struct gether *geth)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(&geth->func);\n\n\tDBG(ecm->port.func.config->cdev, \"%s\\n\", __func__);\n\n\tecm->is_open = false;\n\tecm_notify(ecm);\n}\n\n \n\n \n\nstatic int\necm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus = 0;\n\tstruct usb_ep\t\t*ep;\n\n\tstruct f_ecm_opts\t*ecm_opts;\n\n\tif (!can_support_ecm(cdev->gadget))\n\t\treturn -EINVAL;\n\n\tecm_opts = container_of(f->fi, struct f_ecm_opts, func_inst);\n\n\tmutex_lock(&ecm_opts->lock);\n\n\tgether_set_gadget(ecm_opts->net, cdev->gadget);\n\n\tif (!ecm_opts->bound) {\n\t\tstatus = gether_register_netdev(ecm_opts->net);\n\t\tecm_opts->bound = true;\n\t}\n\n\tmutex_unlock(&ecm_opts->lock);\n\tif (status)\n\t\treturn status;\n\n\tecm_string_defs[1].s = ecm->ethaddr;\n\n\tus = usb_gstrings_attach(cdev, ecm_strings,\n\t\t\t\t ARRAY_SIZE(ecm_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\tecm_control_intf.iInterface = us[0].id;\n\tecm_data_intf.iInterface = us[2].id;\n\tecm_desc.iMACAddress = us[1].id;\n\tecm_iad_descriptor.iFunction = us[3].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tecm->ctrl_id = status;\n\tecm_iad_descriptor.bFirstInterface = status;\n\n\tecm_control_intf.bInterfaceNumber = status;\n\tecm_union_desc.bMasterInterface0 = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tecm->data_id = status;\n\n\tecm_data_nop_intf.bInterfaceNumber = status;\n\tecm_data_intf.bInterfaceNumber = status;\n\tecm_union_desc.bSlaveInterface0 = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tecm->port.in_ep = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tecm->port.out_ep = ep;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &fs_ecm_notify_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tecm->notify = ep;\n\n\tstatus = -ENOMEM;\n\n\t \n\tecm->notify_req = usb_ep_alloc_request(ep, GFP_KERNEL);\n\tif (!ecm->notify_req)\n\t\tgoto fail;\n\tecm->notify_req->buf = kmalloc(ECM_STATUS_BYTECOUNT, GFP_KERNEL);\n\tif (!ecm->notify_req->buf)\n\t\tgoto fail;\n\tecm->notify_req->context = ecm;\n\tecm->notify_req->complete = ecm_notify_complete;\n\n\t \n\ths_ecm_in_desc.bEndpointAddress = fs_ecm_in_desc.bEndpointAddress;\n\ths_ecm_out_desc.bEndpointAddress = fs_ecm_out_desc.bEndpointAddress;\n\ths_ecm_notify_desc.bEndpointAddress =\n\t\tfs_ecm_notify_desc.bEndpointAddress;\n\n\tss_ecm_in_desc.bEndpointAddress = fs_ecm_in_desc.bEndpointAddress;\n\tss_ecm_out_desc.bEndpointAddress = fs_ecm_out_desc.bEndpointAddress;\n\tss_ecm_notify_desc.bEndpointAddress =\n\t\tfs_ecm_notify_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, ecm_fs_function, ecm_hs_function,\n\t\t\tecm_ss_function, ecm_ss_function);\n\tif (status)\n\t\tgoto fail;\n\n\t \n\n\tecm->port.open = ecm_open;\n\tecm->port.close = ecm_close;\n\n\tDBG(cdev, \"CDC Ethernet: IN/%s OUT/%s NOTIFY/%s\\n\",\n\t\t\tecm->port.in_ep->name, ecm->port.out_ep->name,\n\t\t\tecm->notify->name);\n\treturn 0;\n\nfail:\n\tif (ecm->notify_req) {\n\t\tkfree(ecm->notify_req->buf);\n\t\tusb_ep_free_request(ecm->notify, ecm->notify_req);\n\t}\n\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_ecm_opts *to_f_ecm_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_ecm_opts,\n\t\t\t    func_inst.group);\n}\n\n \nUSB_ETHERNET_CONFIGFS_ITEM(ecm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_DEV_ADDR(ecm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_HOST_ADDR(ecm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_QMULT(ecm);\n\n \nUSB_ETHERNET_CONFIGFS_ITEM_ATTR_IFNAME(ecm);\n\nstatic struct configfs_attribute *ecm_attrs[] = {\n\t&ecm_opts_attr_dev_addr,\n\t&ecm_opts_attr_host_addr,\n\t&ecm_opts_attr_qmult,\n\t&ecm_opts_attr_ifname,\n\tNULL,\n};\n\nstatic const struct config_item_type ecm_func_type = {\n\t.ct_item_ops\t= &ecm_item_ops,\n\t.ct_attrs\t= ecm_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void ecm_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_ecm_opts *opts;\n\n\topts = container_of(f, struct f_ecm_opts, func_inst);\n\tif (opts->bound)\n\t\tgether_cleanup(netdev_priv(opts->net));\n\telse\n\t\tfree_netdev(opts->net);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *ecm_alloc_inst(void)\n{\n\tstruct f_ecm_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = ecm_free_inst;\n\topts->net = gether_setup_default();\n\tif (IS_ERR(opts->net)) {\n\t\tstruct net_device *net = opts->net;\n\t\tkfree(opts);\n\t\treturn ERR_CAST(net);\n\t}\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &ecm_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void ecm_suspend(struct usb_function *f)\n{\n\tstruct f_ecm *ecm = func_to_ecm(f);\n\tstruct usb_composite_dev *cdev = ecm->port.func.config->cdev;\n\n\tDBG(cdev, \"ECM Suspend\\n\");\n\n\tgether_suspend(&ecm->port);\n}\n\nstatic void ecm_resume(struct usb_function *f)\n{\n\tstruct f_ecm *ecm = func_to_ecm(f);\n\tstruct usb_composite_dev *cdev = ecm->port.func.config->cdev;\n\n\tDBG(cdev, \"ECM Resume\\n\");\n\n\tgether_resume(&ecm->port);\n}\n\nstatic void ecm_free(struct usb_function *f)\n{\n\tstruct f_ecm *ecm;\n\tstruct f_ecm_opts *opts;\n\n\tecm = func_to_ecm(f);\n\topts = container_of(f->fi, struct f_ecm_opts, func_inst);\n\tkfree(ecm);\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void ecm_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_ecm\t\t*ecm = func_to_ecm(f);\n\n\tDBG(c->cdev, \"ecm unbind\\n\");\n\n\tusb_free_all_descriptors(f);\n\n\tif (atomic_read(&ecm->notify_count)) {\n\t\tusb_ep_dequeue(ecm->notify, ecm->notify_req);\n\t\tatomic_set(&ecm->notify_count, 0);\n\t}\n\n\tkfree(ecm->notify_req->buf);\n\tusb_ep_free_request(ecm->notify, ecm->notify_req);\n}\n\nstatic struct usb_function *ecm_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_ecm\t*ecm;\n\tstruct f_ecm_opts *opts;\n\tint status;\n\n\t \n\tecm = kzalloc(sizeof(*ecm), GFP_KERNEL);\n\tif (!ecm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_ecm_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\n\t \n\tstatus = gether_get_host_addr_cdc(opts->net, ecm->ethaddr,\n\t\t\t\t\t  sizeof(ecm->ethaddr));\n\tif (status < 12) {\n\t\tkfree(ecm);\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tecm->port.ioport = netdev_priv(opts->net);\n\tmutex_unlock(&opts->lock);\n\tecm->port.cdc_filter = DEFAULT_FILTER;\n\n\tecm->port.func.name = \"cdc_ethernet\";\n\t \n\tecm->port.func.bind = ecm_bind;\n\tecm->port.func.unbind = ecm_unbind;\n\tecm->port.func.set_alt = ecm_set_alt;\n\tecm->port.func.get_alt = ecm_get_alt;\n\tecm->port.func.setup = ecm_setup;\n\tecm->port.func.disable = ecm_disable;\n\tecm->port.func.free_func = ecm_free;\n\tecm->port.func.suspend = ecm_suspend;\n\tecm->port.func.resume = ecm_resume;\n\n\treturn &ecm->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(ecm, ecm_alloc_inst, ecm_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}