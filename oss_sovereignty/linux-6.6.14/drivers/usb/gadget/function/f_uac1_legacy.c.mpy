{
  "module_name": "f_uac1_legacy.c",
  "hash_id": "22d89f2d1e86c5ce23884dfa41160bac689bbb3336d820ac30c139591c3fa93b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_uac1_legacy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/atomic.h>\n\n#include \"u_uac1_legacy.h\"\n\nstatic int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value);\nstatic int generic_get_cmd(struct usb_audio_control *con, u8 cmd);\n\n \n\n \n#define F_AUDIO_AC_INTERFACE\t0\n#define F_AUDIO_AS_INTERFACE\t1\n#define F_AUDIO_NUM_INTERFACES\t1\n\n \nstatic struct usb_interface_descriptor ac_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOCONTROL,\n};\n\n \nDECLARE_UAC_AC_HEADER_DESCRIPTOR(1);\n\n#define UAC_DT_AC_HEADER_LENGTH\tUAC_DT_AC_HEADER_SIZE(F_AUDIO_NUM_INTERFACES)\n \n#define UAC_DT_TOTAL_LENGTH (UAC_DT_AC_HEADER_LENGTH + UAC_DT_INPUT_TERMINAL_SIZE \\\n\t+ UAC_DT_OUTPUT_TERMINAL_SIZE + UAC_DT_FEATURE_UNIT_SIZE(0))\n \nstatic struct uac1_ac_header_descriptor_1 ac_header_desc = {\n\t.bLength =\t\tUAC_DT_AC_HEADER_LENGTH,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_HEADER,\n\t.bcdADC =\t\tcpu_to_le16(0x0100),\n\t.wTotalLength =\t\tcpu_to_le16(UAC_DT_TOTAL_LENGTH),\n\t.bInCollection =\tF_AUDIO_NUM_INTERFACES,\n\t.baInterfaceNr = {\n\t \n\t\t[0] =\t\t1,\n\t}\n};\n\n#define INPUT_TERMINAL_ID\t1\nstatic struct uac_input_terminal_descriptor input_terminal_desc = {\n\t.bLength =\t\tUAC_DT_INPUT_TERMINAL_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_INPUT_TERMINAL,\n\t.bTerminalID =\t\tINPUT_TERMINAL_ID,\n\t.wTerminalType =\tUAC_TERMINAL_STREAMING,\n\t.bAssocTerminal =\t0,\n\t.wChannelConfig =\t0x3,\n};\n\nDECLARE_UAC_FEATURE_UNIT_DESCRIPTOR(0);\n\n#define FEATURE_UNIT_ID\t\t2\nstatic struct uac_feature_unit_descriptor_0 feature_unit_desc = {\n\t.bLength\t\t= UAC_DT_FEATURE_UNIT_SIZE(0),\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype\t= UAC_FEATURE_UNIT,\n\t.bUnitID\t\t= FEATURE_UNIT_ID,\n\t.bSourceID\t\t= INPUT_TERMINAL_ID,\n\t.bControlSize\t\t= 2,\n\t.bmaControls[0]\t\t= (UAC_FU_MUTE | UAC_FU_VOLUME),\n};\n\nstatic struct usb_audio_control mute_control = {\n\t.list = LIST_HEAD_INIT(mute_control.list),\n\t.name = \"Mute Control\",\n\t.type = UAC_FU_MUTE,\n\t \n\t.set = generic_set_cmd,\n\t.get = generic_get_cmd,\n};\n\nstatic struct usb_audio_control volume_control = {\n\t.list = LIST_HEAD_INIT(volume_control.list),\n\t.name = \"Volume Control\",\n\t.type = UAC_FU_VOLUME,\n\t \n\t.set = generic_set_cmd,\n\t.get = generic_get_cmd,\n};\n\nstatic struct usb_audio_control_selector feature_unit = {\n\t.list = LIST_HEAD_INIT(feature_unit.list),\n\t.id = FEATURE_UNIT_ID,\n\t.name = \"Mute & Volume Control\",\n\t.type = UAC_FEATURE_UNIT,\n\t.desc = (struct usb_descriptor_header *)&feature_unit_desc,\n};\n\n#define OUTPUT_TERMINAL_ID\t3\nstatic struct uac1_output_terminal_descriptor output_terminal_desc = {\n\t.bLength\t\t= UAC_DT_OUTPUT_TERMINAL_SIZE,\n\t.bDescriptorType\t= USB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype\t= UAC_OUTPUT_TERMINAL,\n\t.bTerminalID\t\t= OUTPUT_TERMINAL_ID,\n\t.wTerminalType\t\t= UAC_OUTPUT_TERMINAL_SPEAKER,\n\t.bAssocTerminal\t\t= FEATURE_UNIT_ID,\n\t.bSourceID\t\t= FEATURE_UNIT_ID,\n};\n\n \nstatic struct usb_interface_descriptor as_interface_alt_0_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t0,\n\t.bNumEndpoints =\t0,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\nstatic struct usb_interface_descriptor as_interface_alt_1_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bAlternateSetting =\t1,\n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_AUDIO,\n\t.bInterfaceSubClass =\tUSB_SUBCLASS_AUDIOSTREAMING,\n};\n\n \nstatic struct uac1_as_header_descriptor as_header_desc = {\n\t.bLength =\t\tUAC_DT_AS_HEADER_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_AS_GENERAL,\n\t.bTerminalLink =\tINPUT_TERMINAL_ID,\n\t.bDelay =\t\t1,\n\t.wFormatTag =\t\tUAC_FORMAT_TYPE_I_PCM,\n};\n\nDECLARE_UAC_FORMAT_TYPE_I_DISCRETE_DESC(1);\n\nstatic struct uac_format_type_i_discrete_descriptor_1 as_type_i_desc = {\n\t.bLength =\t\tUAC_FORMAT_TYPE_I_DISCRETE_DESC_SIZE(1),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubtype =\tUAC_FORMAT_TYPE,\n\t.bFormatType =\t\tUAC_FORMAT_TYPE_I,\n\t.bSubframeSize =\t2,\n\t.bBitResolution =\t16,\n\t.bSamFreqType =\t\t1,\n};\n\n \nstatic struct usb_endpoint_descriptor as_out_ep_desc  = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_AUDIO_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_SYNC_ADAPTIVE\n\t\t\t\t| USB_ENDPOINT_XFER_ISOC,\n\t.wMaxPacketSize\t=\tcpu_to_le16(UAC1_OUT_EP_MAX_PACKET_SIZE),\n\t.bInterval =\t\t4,\n};\n\n \nstatic struct uac_iso_endpoint_descriptor as_iso_out_desc = {\n\t.bLength =\t\tUAC_ISO_ENDPOINT_DESC_SIZE,\n\t.bDescriptorType =\tUSB_DT_CS_ENDPOINT,\n\t.bDescriptorSubtype =\tUAC_EP_GENERAL,\n\t.bmAttributes = \t1,\n\t.bLockDelayUnits =\t1,\n\t.wLockDelay =\t\tcpu_to_le16(1),\n};\n\nstatic struct usb_descriptor_header *f_audio_desc[] = {\n\t(struct usb_descriptor_header *)&ac_interface_desc,\n\t(struct usb_descriptor_header *)&ac_header_desc,\n\n\t(struct usb_descriptor_header *)&input_terminal_desc,\n\t(struct usb_descriptor_header *)&output_terminal_desc,\n\t(struct usb_descriptor_header *)&feature_unit_desc,\n\n\t(struct usb_descriptor_header *)&as_interface_alt_0_desc,\n\t(struct usb_descriptor_header *)&as_interface_alt_1_desc,\n\t(struct usb_descriptor_header *)&as_header_desc,\n\n\t(struct usb_descriptor_header *)&as_type_i_desc,\n\n\t(struct usb_descriptor_header *)&as_out_ep_desc,\n\t(struct usb_descriptor_header *)&as_iso_out_desc,\n\tNULL,\n};\n\nenum {\n\tSTR_AC_IF,\n\tSTR_INPUT_TERMINAL,\n\tSTR_INPUT_TERMINAL_CH_NAMES,\n\tSTR_FEAT_DESC_0,\n\tSTR_OUTPUT_TERMINAL,\n\tSTR_AS_IF_ALT0,\n\tSTR_AS_IF_ALT1,\n};\n\nstatic struct usb_string strings_uac1[] = {\n\t[STR_AC_IF].s = \"AC Interface\",\n\t[STR_INPUT_TERMINAL].s = \"Input terminal\",\n\t[STR_INPUT_TERMINAL_CH_NAMES].s = \"Channels\",\n\t[STR_FEAT_DESC_0].s = \"Volume control & mute\",\n\t[STR_OUTPUT_TERMINAL].s = \"Output terminal\",\n\t[STR_AS_IF_ALT0].s = \"AS Interface\",\n\t[STR_AS_IF_ALT1].s = \"AS Interface\",\n\t{ },\n};\n\nstatic struct usb_gadget_strings str_uac1 = {\n\t.language = 0x0409,\t \n\t.strings = strings_uac1,\n};\n\nstatic struct usb_gadget_strings *uac1_strings[] = {\n\t&str_uac1,\n\tNULL,\n};\n\n \n\n \nstruct f_audio_buf {\n\tu8 *buf;\n\tint actual;\n\tstruct list_head list;\n};\n\nstatic struct f_audio_buf *f_audio_buffer_alloc(int buf_size)\n{\n\tstruct f_audio_buf *copy_buf;\n\n\tcopy_buf = kzalloc(sizeof *copy_buf, GFP_ATOMIC);\n\tif (!copy_buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcopy_buf->buf = kzalloc(buf_size, GFP_ATOMIC);\n\tif (!copy_buf->buf) {\n\t\tkfree(copy_buf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn copy_buf;\n}\n\nstatic void f_audio_buffer_free(struct f_audio_buf *audio_buf)\n{\n\tkfree(audio_buf->buf);\n\tkfree(audio_buf);\n}\n \n\nstruct f_audio {\n\tstruct gaudio\t\t\tcard;\n\n\tu8 ac_intf, ac_alt;\n\tu8 as_intf, as_alt;\n\n\t \n\tstruct usb_ep\t\t\t*out_ep;\n\n\tspinlock_t\t\t\tlock;\n\tstruct f_audio_buf *copy_buf;\n\tstruct work_struct playback_work;\n\tstruct list_head play_queue;\n\n\t \n\tstruct list_head cs;\n\tu8 set_cmd;\n\tstruct usb_audio_control *set_con;\n};\n\nstatic inline struct f_audio *func_to_audio(struct usb_function *f)\n{\n\treturn container_of(f, struct f_audio, card.func);\n}\n\n \n\nstatic void f_audio_playback_work(struct work_struct *data)\n{\n\tstruct f_audio *audio = container_of(data, struct f_audio,\n\t\t\t\t\tplayback_work);\n\tstruct f_audio_buf *play_buf;\n\n\tspin_lock_irq(&audio->lock);\n\tif (list_empty(&audio->play_queue)) {\n\t\tspin_unlock_irq(&audio->lock);\n\t\treturn;\n\t}\n\tplay_buf = list_first_entry(&audio->play_queue,\n\t\t\tstruct f_audio_buf, list);\n\tlist_del(&play_buf->list);\n\tspin_unlock_irq(&audio->lock);\n\n\tu_audio_playback(&audio->card, play_buf->buf, play_buf->actual);\n\tf_audio_buffer_free(play_buf);\n}\n\nstatic int f_audio_out_ep_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_audio *audio = req->context;\n\tstruct usb_composite_dev *cdev = audio->card.func.config->cdev;\n\tstruct f_audio_buf *copy_buf = audio->copy_buf;\n\tstruct f_uac1_legacy_opts *opts;\n\tint audio_buf_size;\n\tint err;\n\n\topts = container_of(audio->card.func.fi, struct f_uac1_legacy_opts,\n\t\t\t    func_inst);\n\taudio_buf_size = opts->audio_buf_size;\n\n\tif (!copy_buf)\n\t\treturn -EINVAL;\n\n\t \n\tif (audio_buf_size - copy_buf->actual < req->actual) {\n\t\tspin_lock_irq(&audio->lock);\n\t\tlist_add_tail(&copy_buf->list, &audio->play_queue);\n\t\tspin_unlock_irq(&audio->lock);\n\t\tschedule_work(&audio->playback_work);\n\t\tcopy_buf = f_audio_buffer_alloc(audio_buf_size);\n\t\tif (IS_ERR(copy_buf))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(copy_buf->buf + copy_buf->actual, req->buf, req->actual);\n\tcopy_buf->actual += req->actual;\n\taudio->copy_buf = copy_buf;\n\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err)\n\t\tERROR(cdev, \"%s queue req: %d\\n\", ep->name, err);\n\n\treturn 0;\n\n}\n\nstatic void f_audio_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_audio *audio = req->context;\n\tint status = req->status;\n\tu32 data = 0;\n\tstruct usb_ep *out_ep = audio->out_ep;\n\n\tswitch (status) {\n\n\tcase 0:\t\t\t\t \n\t\tif (ep == out_ep)\n\t\t\tf_audio_out_ep_complete(ep, req);\n\t\telse if (audio->set_con) {\n\t\t\tmemcpy(&data, req->buf, req->length);\n\t\t\taudio->set_con->set(audio->set_con, audio->set_cmd,\n\t\t\t\t\tle16_to_cpu(data));\n\t\t\taudio->set_con = NULL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int audio_set_intf_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_audio\t\t*audio = func_to_audio(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tu8\t\t\tid = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\n\tu16\t\t\tlen = le16_to_cpu(ctrl->wLength);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu8\t\t\tcon_sel = (w_value >> 8) & 0xFF;\n\tu8\t\t\tcmd = (ctrl->bRequest & 0x0F);\n\tstruct usb_audio_control_selector *cs;\n\tstruct usb_audio_control *con;\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, entity %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, id);\n\n\tlist_for_each_entry(cs, &audio->cs, list) {\n\t\tif (cs->id == id) {\n\t\t\tlist_for_each_entry(con, &cs->control, list) {\n\t\t\t\tif (con->type == con_sel) {\n\t\t\t\t\taudio->set_con = con;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\taudio->set_cmd = cmd;\n\treq->context = audio;\n\treq->complete = f_audio_complete;\n\n\treturn len;\n}\n\nstatic int audio_get_intf_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_audio\t\t*audio = func_to_audio(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu8\t\t\tid = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\n\tu16\t\t\tlen = le16_to_cpu(ctrl->wLength);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu8\t\t\tcon_sel = (w_value >> 8) & 0xFF;\n\tu8\t\t\tcmd = (ctrl->bRequest & 0x0F);\n\tstruct usb_audio_control_selector *cs;\n\tstruct usb_audio_control *con;\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, entity %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, id);\n\n\tlist_for_each_entry(cs, &audio->cs, list) {\n\t\tif (cs->id == id) {\n\t\t\tlist_for_each_entry(con, &cs->control, list) {\n\t\t\t\tif (con->type == con_sel && con->get) {\n\t\t\t\t\tvalue = con->get(con, cmd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treq->context = audio;\n\treq->complete = f_audio_complete;\n\tlen = min_t(size_t, sizeof(value), len);\n\tmemcpy(req->buf, &value, len);\n\n\treturn len;\n}\n\nstatic int audio_set_endpoint_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tep = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tlen = le16_to_cpu(ctrl->wLength);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, ep);\n\n\tswitch (ctrl->bRequest) {\n\tcase UAC_SET_CUR:\n\t\tvalue = len;\n\t\tbreak;\n\n\tcase UAC_SET_MIN:\n\t\tbreak;\n\n\tcase UAC_SET_MAX:\n\t\tbreak;\n\n\tcase UAC_SET_RES:\n\t\tbreak;\n\n\tcase UAC_SET_MEM:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic int audio_get_endpoint_req(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tint value = -EOPNOTSUPP;\n\tu8 ep = ((le16_to_cpu(ctrl->wIndex) >> 8) & 0xFF);\n\tu16 len = le16_to_cpu(ctrl->wLength);\n\tu16 w_value = le16_to_cpu(ctrl->wValue);\n\n\tDBG(cdev, \"bRequest 0x%x, w_value 0x%04x, len %d, endpoint %d\\n\",\n\t\t\tctrl->bRequest, w_value, len, ep);\n\n\tswitch (ctrl->bRequest) {\n\tcase UAC_GET_CUR:\n\tcase UAC_GET_MIN:\n\tcase UAC_GET_MAX:\n\tcase UAC_GET_RES:\n\t\tvalue = len;\n\t\tbreak;\n\tcase UAC_GET_MEM:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn value;\n}\n\nstatic int\nf_audio_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch (ctrl->bRequestType) {\n\tcase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\n\t\tvalue = audio_set_intf_req(f, ctrl);\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE:\n\t\tvalue = audio_get_intf_req(f, ctrl);\n\t\tbreak;\n\n\tcase USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\n\t\tvalue = audio_set_endpoint_req(f, ctrl);\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_ENDPOINT:\n\t\tvalue = audio_get_endpoint_req(f, ctrl);\n\t\tbreak;\n\n\tdefault:\n\t\tERROR(cdev, \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tDBG(cdev, \"audio req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"audio response on err %d\\n\", value);\n\t}\n\n\t \n\treturn value;\n}\n\nstatic int f_audio_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_audio\t\t*audio = func_to_audio(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_ep *out_ep = audio->out_ep;\n\tstruct usb_request *req;\n\tstruct f_uac1_legacy_opts *opts;\n\tint req_buf_size, req_count, audio_buf_size;\n\tint i = 0, err = 0;\n\n\tDBG(cdev, \"intf %d, alt %d\\n\", intf, alt);\n\n\topts = container_of(f->fi, struct f_uac1_legacy_opts, func_inst);\n\treq_buf_size = opts->req_buf_size;\n\treq_count = opts->req_count;\n\taudio_buf_size = opts->audio_buf_size;\n\n\t \n\tif (alt > 1) {\n\t\tERROR(cdev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (intf == audio->ac_intf) {\n\t\t \n\t\tif (alt) {\n\t\t\tERROR(cdev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t} else if (intf == audio->as_intf) {\n\t\tif (alt == 1) {\n\t\t\terr = config_ep_by_speed(cdev->gadget, f, out_ep);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\tusb_ep_enable(out_ep);\n\t\t\taudio->copy_buf = f_audio_buffer_alloc(audio_buf_size);\n\t\t\tif (IS_ERR(audio->copy_buf))\n\t\t\t\treturn -ENOMEM;\n\n\t\t\t \n\t\t\tfor (i = 0; i < req_count && err == 0; i++) {\n\t\t\t\treq = usb_ep_alloc_request(out_ep, GFP_ATOMIC);\n\t\t\t\tif (req) {\n\t\t\t\t\treq->buf = kzalloc(req_buf_size,\n\t\t\t\t\t\t\tGFP_ATOMIC);\n\t\t\t\t\tif (req->buf) {\n\t\t\t\t\t\treq->length = req_buf_size;\n\t\t\t\t\t\treq->context = audio;\n\t\t\t\t\t\treq->complete =\n\t\t\t\t\t\t\tf_audio_complete;\n\t\t\t\t\t\terr = usb_ep_queue(out_ep,\n\t\t\t\t\t\t\treq, GFP_ATOMIC);\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\tERROR(cdev,\n\t\t\t\t\t\t\t\"%s queue req: %d\\n\",\n\t\t\t\t\t\t\tout_ep->name, err);\n\t\t\t\t\t} else\n\t\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t} else\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t}\n\n\t\t} else {\n\t\t\tstruct f_audio_buf *copy_buf = audio->copy_buf;\n\t\t\tif (copy_buf) {\n\t\t\t\tlist_add_tail(&copy_buf->list,\n\t\t\t\t\t\t&audio->play_queue);\n\t\t\t\tschedule_work(&audio->playback_work);\n\t\t\t}\n\t\t}\n\t\taudio->as_alt = alt;\n\t}\n\n\treturn err;\n}\n\nstatic int f_audio_get_alt(struct usb_function *f, unsigned intf)\n{\n\tstruct f_audio\t\t*audio = func_to_audio(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tif (intf == audio->ac_intf)\n\t\treturn audio->ac_alt;\n\telse if (intf == audio->as_intf)\n\t\treturn audio->as_alt;\n\telse\n\t\tERROR(cdev, \"%s:%d Invalid Interface %d!\\n\",\n\t\t      __func__, __LINE__, intf);\n\n\treturn -EINVAL;\n}\n\nstatic void f_audio_disable(struct usb_function *f)\n{\n\treturn;\n}\n\n \n\nstatic void f_audio_build_desc(struct f_audio *audio)\n{\n\tstruct gaudio *card = &audio->card;\n\tu8 *sam_freq;\n\tint rate;\n\n\t \n\tinput_terminal_desc.bNrChannels = u_audio_get_playback_channels(card);\n\tas_type_i_desc.bNrChannels = u_audio_get_playback_channels(card);\n\n\t \n\trate = u_audio_get_playback_rate(card);\n\tsam_freq = as_type_i_desc.tSamFreq[0];\n\tmemcpy(sam_freq, &rate, 3);\n\n\t \n\n\treturn;\n}\n\n \nstatic int\nf_audio_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_audio\t\t*audio = func_to_audio(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep = NULL;\n\tstruct f_uac1_legacy_opts\t*audio_opts;\n\n\taudio_opts = container_of(f->fi, struct f_uac1_legacy_opts, func_inst);\n\taudio->card.gadget = c->cdev->gadget;\n\t \n\tif (!audio_opts->bound) {\n\t\tstatus = gaudio_setup(&audio->card);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\taudio_opts->bound = true;\n\t}\n\tus = usb_gstrings_attach(cdev, uac1_strings, ARRAY_SIZE(strings_uac1));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\tac_interface_desc.iInterface = us[STR_AC_IF].id;\n\tinput_terminal_desc.iTerminal = us[STR_INPUT_TERMINAL].id;\n\tinput_terminal_desc.iChannelNames = us[STR_INPUT_TERMINAL_CH_NAMES].id;\n\tfeature_unit_desc.iFeature = us[STR_FEAT_DESC_0].id;\n\toutput_terminal_desc.iTerminal = us[STR_OUTPUT_TERMINAL].id;\n\tas_interface_alt_0_desc.iInterface = us[STR_AS_IF_ALT0].id;\n\tas_interface_alt_1_desc.iInterface = us[STR_AS_IF_ALT1].id;\n\n\n\tf_audio_build_desc(audio);\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tac_interface_desc.bInterfaceNumber = status;\n\taudio->ac_intf = status;\n\taudio->ac_alt = 0;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tas_interface_alt_0_desc.bInterfaceNumber = status;\n\tas_interface_alt_1_desc.bInterfaceNumber = status;\n\taudio->as_intf = status;\n\taudio->as_alt = 0;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &as_out_ep_desc);\n\tif (!ep)\n\t\tgoto fail;\n\taudio->out_ep = ep;\n\taudio->out_ep->desc = &as_out_ep_desc;\n\n\t \n\tstatus = usb_assign_descriptors(f, f_audio_desc, f_audio_desc, NULL,\n\t\t\t\t\tNULL);\n\tif (status)\n\t\tgoto fail;\n\treturn 0;\n\nfail:\n\tgaudio_cleanup(&audio->card);\n\treturn status;\n}\n\n \n\nstatic int generic_set_cmd(struct usb_audio_control *con, u8 cmd, int value)\n{\n\tcon->data[cmd] = value;\n\n\treturn 0;\n}\n\nstatic int generic_get_cmd(struct usb_audio_control *con, u8 cmd)\n{\n\treturn con->data[cmd];\n}\n\n \nstatic int control_selector_init(struct f_audio *audio)\n{\n\tINIT_LIST_HEAD(&audio->cs);\n\tlist_add(&feature_unit.list, &audio->cs);\n\n\tINIT_LIST_HEAD(&feature_unit.control);\n\tlist_add(&mute_control.list, &feature_unit.control);\n\tlist_add(&volume_control.list, &feature_unit.control);\n\n\tvolume_control.data[UAC__CUR] = 0xffc0;\n\tvolume_control.data[UAC__MIN] = 0xe3a0;\n\tvolume_control.data[UAC__MAX] = 0xfff0;\n\tvolume_control.data[UAC__RES] = 0x0030;\n\n\treturn 0;\n}\n\nstatic inline\nstruct f_uac1_legacy_opts *to_f_uac1_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_uac1_legacy_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void f_uac1_attr_release(struct config_item *item)\n{\n\tstruct f_uac1_legacy_opts *opts = to_f_uac1_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations f_uac1_item_ops = {\n\t.release\t= f_uac1_attr_release,\n};\n\n#define UAC1_INT_ATTRIBUTE(name)\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_legacy_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_store(struct config_item *item,\t\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_legacy_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu32 num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou32(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts->name = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac1_opts_, name)\n\nUAC1_INT_ATTRIBUTE(req_buf_size);\nUAC1_INT_ATTRIBUTE(req_count);\nUAC1_INT_ATTRIBUTE(audio_buf_size);\n\n#define UAC1_STR_ATTRIBUTE(name)\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_show(struct config_item *item,\t\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_legacy_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%s\\n\", opts->name);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uac1_opts_##name##_store(struct config_item *item,\t\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uac1_legacy_opts *opts = to_f_uac1_opts(item);\t\t\\\n\tint ret = -EBUSY;\t\t\t\t\t\t\\\n\tchar *tmp;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt)\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttmp = kstrndup(page, len, GFP_KERNEL);\t\t\t\t\\\n\tif (tmp) {\t\t\t\t\t\t\t\\\n\t\tret = -ENOMEM;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (opts->name##_alloc)\t\t\t\t\t\t\\\n\t\tkfree(opts->name);\t\t\t\t\t\\\n\topts->name##_alloc = true;\t\t\t\t\t\\\n\topts->name = tmp;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nCONFIGFS_ATTR(f_uac1_opts_, name)\n\nUAC1_STR_ATTRIBUTE(fn_play);\nUAC1_STR_ATTRIBUTE(fn_cap);\nUAC1_STR_ATTRIBUTE(fn_cntl);\n\nstatic struct configfs_attribute *f_uac1_attrs[] = {\n\t&f_uac1_opts_attr_req_buf_size,\n\t&f_uac1_opts_attr_req_count,\n\t&f_uac1_opts_attr_audio_buf_size,\n\t&f_uac1_opts_attr_fn_play,\n\t&f_uac1_opts_attr_fn_cap,\n\t&f_uac1_opts_attr_fn_cntl,\n\tNULL,\n};\n\nstatic const struct config_item_type f_uac1_func_type = {\n\t.ct_item_ops\t= &f_uac1_item_ops,\n\t.ct_attrs\t= f_uac1_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void f_audio_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_uac1_legacy_opts *opts;\n\n\topts = container_of(f, struct f_uac1_legacy_opts, func_inst);\n\tif (opts->fn_play_alloc)\n\t\tkfree(opts->fn_play);\n\tif (opts->fn_cap_alloc)\n\t\tkfree(opts->fn_cap);\n\tif (opts->fn_cntl_alloc)\n\t\tkfree(opts->fn_cntl);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *f_audio_alloc_inst(void)\n{\n\tstruct f_uac1_legacy_opts *opts;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = f_audio_free_inst;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &f_uac1_func_type);\n\n\topts->req_buf_size = UAC1_OUT_EP_MAX_PACKET_SIZE;\n\topts->req_count = UAC1_REQ_COUNT;\n\topts->audio_buf_size = UAC1_AUDIO_BUF_SIZE;\n\topts->fn_play = FILE_PCM_PLAYBACK;\n\topts->fn_cap = FILE_PCM_CAPTURE;\n\topts->fn_cntl = FILE_CONTROL;\n\treturn &opts->func_inst;\n}\n\nstatic void f_audio_free(struct usb_function *f)\n{\n\tstruct f_audio *audio = func_to_audio(f);\n\tstruct f_uac1_legacy_opts *opts;\n\n\tgaudio_cleanup(&audio->card);\n\topts = container_of(f->fi, struct f_uac1_legacy_opts, func_inst);\n\tkfree(audio);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void f_audio_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *f_audio_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_audio *audio;\n\tstruct f_uac1_legacy_opts *opts;\n\n\t \n\taudio = kzalloc(sizeof(*audio), GFP_KERNEL);\n\tif (!audio)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\taudio->card.func.name = \"g_audio\";\n\n\topts = container_of(fi, struct f_uac1_legacy_opts, func_inst);\n\tmutex_lock(&opts->lock);\n\t++opts->refcnt;\n\tmutex_unlock(&opts->lock);\n\tINIT_LIST_HEAD(&audio->play_queue);\n\tspin_lock_init(&audio->lock);\n\n\taudio->card.func.bind = f_audio_bind;\n\taudio->card.func.unbind = f_audio_unbind;\n\taudio->card.func.set_alt = f_audio_set_alt;\n\taudio->card.func.get_alt = f_audio_get_alt;\n\taudio->card.func.setup = f_audio_setup;\n\taudio->card.func.disable = f_audio_disable;\n\taudio->card.func.free_func = f_audio_free;\n\n\tcontrol_selector_init(audio);\n\n\tINIT_WORK(&audio->playback_work, f_audio_playback_work);\n\n\treturn &audio->card.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(uac1_legacy, f_audio_alloc_inst, f_audio_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bryan Wu\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}