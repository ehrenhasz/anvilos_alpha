{
  "module_name": "u_ether.c",
  "hash_id": "1d814af7b084e2f9243d9f175d81e0c5305f5b28b11d152b4f66eaf96466e4c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/u_ether.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/gfp.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/string_helpers.h>\n#include <linux/usb/composite.h>\n\n#include \"u_ether.h\"\n\n\n \n\n#define UETH__VERSION\t\"29-May-2008\"\n\n \n#define GETHER_MAX_MTU_SIZE 15412\n#define GETHER_MAX_ETH_FRAME_LEN (GETHER_MAX_MTU_SIZE + ETH_HLEN)\n\nstruct eth_dev {\n\t \n\tspinlock_t\t\tlock;\n\tstruct gether\t\t*port_usb;\n\n\tstruct net_device\t*net;\n\tstruct usb_gadget\t*gadget;\n\n\tspinlock_t\t\treq_lock;\t \n\tstruct list_head\ttx_reqs, rx_reqs;\n\tatomic_t\t\ttx_qlen;\n\n\tstruct sk_buff_head\trx_frames;\n\n\tunsigned\t\tqmult;\n\n\tunsigned\t\theader_len;\n\tstruct sk_buff\t\t*(*wrap)(struct gether *, struct sk_buff *skb);\n\tint\t\t\t(*unwrap)(struct gether *,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tstruct sk_buff_head *list);\n\n\tstruct work_struct\twork;\n\n\tunsigned long\t\ttodo;\n#define\tWORK_RX_MEMORY\t\t0\n\n\tbool\t\t\tzlp;\n\tbool\t\t\tno_skb_reserve;\n\tbool\t\t\tifname_set;\n\tu8\t\t\thost_mac[ETH_ALEN];\n\tu8\t\t\tdev_mac[ETH_ALEN];\n};\n\n \n\n#define RX_EXTRA\t20\t \n\n#define DEFAULT_QLEN\t2\t \n\n \nstatic inline int qlen(struct usb_gadget *gadget, unsigned qmult)\n{\n\tif (gadget->speed == USB_SPEED_HIGH || gadget->speed >= USB_SPEED_SUPER)\n\t\treturn qmult * DEFAULT_QLEN;\n\telse\n\t\treturn DEFAULT_QLEN;\n}\n\n \n\n \n\nstatic void eth_get_drvinfo(struct net_device *net, struct ethtool_drvinfo *p)\n{\n\tstruct eth_dev *dev = netdev_priv(net);\n\n\tstrscpy(p->driver, \"g_ether\", sizeof(p->driver));\n\tstrscpy(p->version, UETH__VERSION, sizeof(p->version));\n\tstrscpy(p->fw_version, dev->gadget->name, sizeof(p->fw_version));\n\tstrscpy(p->bus_info, dev_name(&dev->gadget->dev), sizeof(p->bus_info));\n}\n\n \n\nstatic const struct ethtool_ops ops = {\n\t.get_drvinfo = eth_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n};\n\nstatic void defer_kevent(struct eth_dev *dev, int flag)\n{\n\tif (test_and_set_bit(flag, &dev->todo))\n\t\treturn;\n\tif (!schedule_work(&dev->work))\n\t\tERROR(dev, \"kevent %d may have been dropped\\n\", flag);\n\telse\n\t\tDBG(dev, \"kevent %d scheduled\\n\", flag);\n}\n\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req);\n\nstatic int\nrx_submit(struct eth_dev *dev, struct usb_request *req, gfp_t gfp_flags)\n{\n\tstruct usb_gadget *g = dev->gadget;\n\tstruct sk_buff\t*skb;\n\tint\t\tretval = -ENOMEM;\n\tsize_t\t\tsize = 0;\n\tstruct usb_ep\t*out;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->port_usb)\n\t\tout = dev->port_usb->out_ep;\n\telse\n\t\tout = NULL;\n\n\tif (!out)\n\t{\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENOTCONN;\n\t}\n\n\t \n\tsize += sizeof(struct ethhdr) + dev->net->mtu + RX_EXTRA;\n\tsize += dev->port_usb->header_len;\n\n\tif (g->quirk_ep_out_aligned_size) {\n\t\tsize += out->maxpacket - 1;\n\t\tsize -= size % out->maxpacket;\n\t}\n\n\tif (dev->port_usb->is_fixed)\n\t\tsize = max_t(size_t, size, dev->port_usb->fixed_out_len);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tskb = __netdev_alloc_skb(dev->net, size + NET_IP_ALIGN, gfp_flags);\n\tif (skb == NULL) {\n\t\tDBG(dev, \"no rx skb\\n\");\n\t\tgoto enomem;\n\t}\n\n\t \n\tif (likely(!dev->no_skb_reserve))\n\t\tskb_reserve(skb, NET_IP_ALIGN);\n\n\treq->buf = skb->data;\n\treq->length = size;\n\treq->complete = rx_complete;\n\treq->context = skb;\n\n\tretval = usb_ep_queue(out, req, gfp_flags);\n\tif (retval == -ENOMEM)\nenomem:\n\t\tdefer_kevent(dev, WORK_RX_MEMORY);\n\tif (retval) {\n\t\tDBG(dev, \"rx submit --> %d\\n\", retval);\n\t\tif (skb)\n\t\t\tdev_kfree_skb_any(skb);\n\t\tspin_lock_irqsave(&dev->req_lock, flags);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\tspin_unlock_irqrestore(&dev->req_lock, flags);\n\t}\n\treturn retval;\n}\n\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct sk_buff\t*skb = req->context, *skb2;\n\tstruct eth_dev\t*dev = ep->driver_data;\n\tint\t\tstatus = req->status;\n\n\tswitch (status) {\n\n\t \n\tcase 0:\n\t\tskb_put(skb, req->actual);\n\n\t\tif (dev->unwrap) {\n\t\t\tunsigned long\tflags;\n\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif (dev->port_usb) {\n\t\t\t\tstatus = dev->unwrap(dev->port_usb,\n\t\t\t\t\t\t\tskb,\n\t\t\t\t\t\t\t&dev->rx_frames);\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tstatus = -ENOTCONN;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t} else {\n\t\t\tskb_queue_tail(&dev->rx_frames, skb);\n\t\t}\n\t\tskb = NULL;\n\n\t\tskb2 = skb_dequeue(&dev->rx_frames);\n\t\twhile (skb2) {\n\t\t\tif (status < 0\n\t\t\t\t\t|| ETH_HLEN > skb2->len\n\t\t\t\t\t|| skb2->len > GETHER_MAX_ETH_FRAME_LEN) {\n\t\t\t\tdev->net->stats.rx_errors++;\n\t\t\t\tdev->net->stats.rx_length_errors++;\n\t\t\t\tDBG(dev, \"rx length %d\\n\", skb2->len);\n\t\t\t\tdev_kfree_skb_any(skb2);\n\t\t\t\tgoto next_frame;\n\t\t\t}\n\t\t\tskb2->protocol = eth_type_trans(skb2, dev->net);\n\t\t\tdev->net->stats.rx_packets++;\n\t\t\tdev->net->stats.rx_bytes += skb2->len;\n\n\t\t\t \n\t\t\tstatus = netif_rx(skb2);\nnext_frame:\n\t\t\tskb2 = skb_dequeue(&dev->rx_frames);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tVDBG(dev, \"rx shutdown, code %d\\n\", status);\n\t\tgoto quiesce;\n\n\t \n\tcase -ECONNABORTED:\t\t \n\t\tDBG(dev, \"rx %s reset\\n\", ep->name);\n\t\tdefer_kevent(dev, WORK_RX_MEMORY);\nquiesce:\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto clean;\n\n\t \n\tcase -EOVERFLOW:\n\t\tdev->net->stats.rx_over_errors++;\n\t\tfallthrough;\n\n\tdefault:\n\t\tdev->net->stats.rx_errors++;\n\t\tDBG(dev, \"rx status %d\\n\", status);\n\t\tbreak;\n\t}\n\n\tif (skb)\n\t\tdev_kfree_skb_any(skb);\n\tif (!netif_running(dev->net)) {\nclean:\n\t\tspin_lock(&dev->req_lock);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\tspin_unlock(&dev->req_lock);\n\t\treq = NULL;\n\t}\n\tif (req)\n\t\trx_submit(dev, req, GFP_ATOMIC);\n}\n\nstatic int prealloc(struct list_head *list, struct usb_ep *ep, unsigned n)\n{\n\tunsigned\t\ti;\n\tstruct usb_request\t*req;\n\n\tif (!n)\n\t\treturn -ENOMEM;\n\n\t \n\ti = n;\n\tlist_for_each_entry(req, list, list) {\n\t\tif (i-- == 0)\n\t\t\tgoto extra;\n\t}\n\twhile (i--) {\n\t\treq = usb_ep_alloc_request(ep, GFP_ATOMIC);\n\t\tif (!req)\n\t\t\treturn list_empty(list) ? -ENOMEM : 0;\n\t\tlist_add(&req->list, list);\n\t}\n\treturn 0;\n\nextra:\n\t \n\tfor (;;) {\n\t\tstruct list_head\t*next;\n\n\t\tnext = req->list.next;\n\t\tlist_del(&req->list);\n\t\tusb_ep_free_request(ep, req);\n\n\t\tif (next == list)\n\t\t\tbreak;\n\n\t\treq = container_of(next, struct usb_request, list);\n\t}\n\treturn 0;\n}\n\nstatic int alloc_requests(struct eth_dev *dev, struct gether *link, unsigned n)\n{\n\tint\tstatus;\n\n\tspin_lock(&dev->req_lock);\n\tstatus = prealloc(&dev->tx_reqs, link->in_ep, n);\n\tif (status < 0)\n\t\tgoto fail;\n\tstatus = prealloc(&dev->rx_reqs, link->out_ep, n);\n\tif (status < 0)\n\t\tgoto fail;\n\tgoto done;\nfail:\n\tDBG(dev, \"can't alloc requests\\n\");\ndone:\n\tspin_unlock(&dev->req_lock);\n\treturn status;\n}\n\nstatic void rx_fill(struct eth_dev *dev, gfp_t gfp_flags)\n{\n\tstruct usb_request\t*req;\n\tunsigned long\t\tflags;\n\n\t \n\tspin_lock_irqsave(&dev->req_lock, flags);\n\twhile (!list_empty(&dev->rx_reqs)) {\n\t\treq = list_first_entry(&dev->rx_reqs, struct usb_request, list);\n\t\tlist_del_init(&req->list);\n\t\tspin_unlock_irqrestore(&dev->req_lock, flags);\n\n\t\tif (rx_submit(dev, req, gfp_flags) < 0) {\n\t\t\tdefer_kevent(dev, WORK_RX_MEMORY);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_lock_irqsave(&dev->req_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&dev->req_lock, flags);\n}\n\nstatic void eth_work(struct work_struct *work)\n{\n\tstruct eth_dev\t*dev = container_of(work, struct eth_dev, work);\n\n\tif (test_and_clear_bit(WORK_RX_MEMORY, &dev->todo)) {\n\t\tif (netif_running(dev->net))\n\t\t\trx_fill(dev, GFP_KERNEL);\n\t}\n\n\tif (dev->todo)\n\t\tDBG(dev, \"work done, flags = 0x%lx\\n\", dev->todo);\n}\n\nstatic void tx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct sk_buff\t*skb = req->context;\n\tstruct eth_dev\t*dev = ep->driver_data;\n\n\tswitch (req->status) {\n\tdefault:\n\t\tdev->net->stats.tx_errors++;\n\t\tVDBG(dev, \"tx err %d\\n\", req->status);\n\t\tfallthrough;\n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\tcase 0:\n\t\tdev->net->stats.tx_bytes += skb->len;\n\t\tdev_consume_skb_any(skb);\n\t}\n\tdev->net->stats.tx_packets++;\n\n\tspin_lock(&dev->req_lock);\n\tlist_add(&req->list, &dev->tx_reqs);\n\tspin_unlock(&dev->req_lock);\n\n\tatomic_dec(&dev->tx_qlen);\n\tif (netif_carrier_ok(dev->net))\n\t\tnetif_wake_queue(dev->net);\n}\n\nstatic inline int is_promisc(u16 cdc_filter)\n{\n\treturn cdc_filter & USB_CDC_PACKET_TYPE_PROMISCUOUS;\n}\n\nstatic int ether_wakeup_host(struct gether *port)\n{\n\tint\t\t\tret;\n\tstruct usb_function\t*func = &port->func;\n\tstruct usb_gadget\t*gadget = func->config->cdev->gadget;\n\n\tif (func->func_suspended)\n\t\tret = usb_func_wakeup(func);\n\telse\n\t\tret = usb_gadget_wakeup(gadget);\n\n\treturn ret;\n}\n\nstatic netdev_tx_t eth_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *net)\n{\n\tstruct eth_dev\t\t*dev = netdev_priv(net);\n\tint\t\t\tlength = 0;\n\tint\t\t\tretval;\n\tstruct usb_request\t*req = NULL;\n\tunsigned long\t\tflags;\n\tstruct usb_ep\t\t*in;\n\tu16\t\t\tcdc_filter;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->port_usb) {\n\t\tin = dev->port_usb->in_ep;\n\t\tcdc_filter = dev->port_usb->cdc_filter;\n\t} else {\n\t\tin = NULL;\n\t\tcdc_filter = 0;\n\t}\n\n\tif (dev->port_usb && dev->port_usb->is_suspend) {\n\t\tDBG(dev, \"Port suspended. Triggering wakeup\\n\");\n\t\tnetif_stop_queue(net);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tether_wakeup_host(dev->port_usb);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (!in) {\n\t\tif (skb)\n\t\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t \n\tif (skb && !is_promisc(cdc_filter)) {\n\t\tu8\t\t*dest = skb->data;\n\n\t\tif (is_multicast_ether_addr(dest)) {\n\t\t\tu16\ttype;\n\n\t\t\t \n\t\t\tif (is_broadcast_ether_addr(dest))\n\t\t\t\ttype = USB_CDC_PACKET_TYPE_BROADCAST;\n\t\t\telse\n\t\t\t\ttype = USB_CDC_PACKET_TYPE_ALL_MULTICAST;\n\t\t\tif (!(cdc_filter & type)) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t}\n\t\t \n\t}\n\n\tspin_lock_irqsave(&dev->req_lock, flags);\n\t \n\tif (list_empty(&dev->tx_reqs)) {\n\t\tspin_unlock_irqrestore(&dev->req_lock, flags);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\treq = list_first_entry(&dev->tx_reqs, struct usb_request, list);\n\tlist_del(&req->list);\n\n\t \n\tif (list_empty(&dev->tx_reqs))\n\t\tnetif_stop_queue(net);\n\tspin_unlock_irqrestore(&dev->req_lock, flags);\n\n\t \n\tif (dev->wrap) {\n\t\tunsigned long\tflags;\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tif (dev->port_usb)\n\t\t\tskb = dev->wrap(dev->port_usb, skb);\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tif (!skb) {\n\t\t\t \n\t\t\tif (dev->port_usb &&\n\t\t\t\t\tdev->port_usb->supports_multi_frame)\n\t\t\t\tgoto multiframe;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tlength = skb->len;\n\treq->buf = skb->data;\n\treq->context = skb;\n\treq->complete = tx_complete;\n\n\t \n\tif (dev->port_usb &&\n\t    dev->port_usb->is_fixed &&\n\t    length == dev->port_usb->fixed_in_len &&\n\t    (length % in->maxpacket) == 0)\n\t\treq->zero = 0;\n\telse\n\t\treq->zero = 1;\n\n\t \n\tif (req->zero && !dev->zlp && (length % in->maxpacket) == 0)\n\t\tlength++;\n\n\treq->length = length;\n\n\tretval = usb_ep_queue(in, req, GFP_ATOMIC);\n\tswitch (retval) {\n\tdefault:\n\t\tDBG(dev, \"tx queue err %d\\n\", retval);\n\t\tbreak;\n\tcase 0:\n\t\tnetif_trans_update(net);\n\t\tatomic_inc(&dev->tx_qlen);\n\t}\n\n\tif (retval) {\n\t\tdev_kfree_skb_any(skb);\ndrop:\n\t\tdev->net->stats.tx_dropped++;\nmultiframe:\n\t\tspin_lock_irqsave(&dev->req_lock, flags);\n\t\tif (list_empty(&dev->tx_reqs))\n\t\t\tnetif_start_queue(net);\n\t\tlist_add(&req->list, &dev->tx_reqs);\n\t\tspin_unlock_irqrestore(&dev->req_lock, flags);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n \n\nstatic void eth_start(struct eth_dev *dev, gfp_t gfp_flags)\n{\n\tDBG(dev, \"%s\\n\", __func__);\n\n\t \n\trx_fill(dev, gfp_flags);\n\n\t \n\tatomic_set(&dev->tx_qlen, 0);\n\tnetif_wake_queue(dev->net);\n}\n\nstatic int eth_open(struct net_device *net)\n{\n\tstruct eth_dev\t*dev = netdev_priv(net);\n\tstruct gether\t*link;\n\n\tDBG(dev, \"%s\\n\", __func__);\n\tif (netif_carrier_ok(dev->net))\n\t\teth_start(dev, GFP_KERNEL);\n\n\tspin_lock_irq(&dev->lock);\n\tlink = dev->port_usb;\n\tif (link && link->open)\n\t\tlink->open(link);\n\tspin_unlock_irq(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int eth_stop(struct net_device *net)\n{\n\tstruct eth_dev\t*dev = netdev_priv(net);\n\tunsigned long\tflags;\n\n\tVDBG(dev, \"%s\\n\", __func__);\n\tnetif_stop_queue(net);\n\n\tDBG(dev, \"stop stats: rx/tx %ld/%ld, errs %ld/%ld\\n\",\n\t\tdev->net->stats.rx_packets, dev->net->stats.tx_packets,\n\t\tdev->net->stats.rx_errors, dev->net->stats.tx_errors\n\t\t);\n\n\t \n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->port_usb) {\n\t\tstruct gether\t*link = dev->port_usb;\n\t\tconst struct usb_endpoint_descriptor *in;\n\t\tconst struct usb_endpoint_descriptor *out;\n\n\t\tif (link->close)\n\t\t\tlink->close(link);\n\n\t\t \n\t\tin = link->in_ep->desc;\n\t\tout = link->out_ep->desc;\n\t\tusb_ep_disable(link->in_ep);\n\t\tusb_ep_disable(link->out_ep);\n\t\tif (netif_carrier_ok(net)) {\n\t\t\tDBG(dev, \"host still using in/out endpoints\\n\");\n\t\t\tlink->in_ep->desc = in;\n\t\t\tlink->out_ep->desc = out;\n\t\t\tusb_ep_enable(link->in_ep);\n\t\t\tusb_ep_enable(link->out_ep);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic int get_ether_addr(const char *str, u8 *dev_addr)\n{\n\tif (str) {\n\t\tunsigned\ti;\n\n\t\tfor (i = 0; i < 6; i++) {\n\t\t\tunsigned char num;\n\n\t\t\tif ((*str == '.') || (*str == ':'))\n\t\t\t\tstr++;\n\t\t\tnum = hex_to_bin(*str++) << 4;\n\t\t\tnum |= hex_to_bin(*str++);\n\t\t\tdev_addr [i] = num;\n\t\t}\n\t\tif (is_valid_ether_addr(dev_addr))\n\t\t\treturn 0;\n\t}\n\teth_random_addr(dev_addr);\n\treturn 1;\n}\n\nstatic int get_ether_addr_str(u8 dev_addr[ETH_ALEN], char *str, int len)\n{\n\tif (len < 18)\n\t\treturn -EINVAL;\n\n\tsnprintf(str, len, \"%pM\", dev_addr);\n\treturn 18;\n}\n\nstatic const struct net_device_ops eth_netdev_ops = {\n\t.ndo_open\t\t= eth_open,\n\t.ndo_stop\t\t= eth_stop,\n\t.ndo_start_xmit\t\t= eth_start_xmit,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic struct device_type gadget_type = {\n\t.name\t= \"gadget\",\n};\n\n \nstruct eth_dev *gether_setup_name(struct usb_gadget *g,\n\t\tconst char *dev_addr, const char *host_addr,\n\t\tu8 ethaddr[ETH_ALEN], unsigned qmult, const char *netname)\n{\n\tstruct eth_dev\t\t*dev;\n\tstruct net_device\t*net;\n\tint\t\t\tstatus;\n\tu8\t\t\taddr[ETH_ALEN];\n\n\tnet = alloc_etherdev(sizeof *dev);\n\tif (!net)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = netdev_priv(net);\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&dev->req_lock);\n\tINIT_WORK(&dev->work, eth_work);\n\tINIT_LIST_HEAD(&dev->tx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_reqs);\n\n\tskb_queue_head_init(&dev->rx_frames);\n\n\t \n\tdev->net = net;\n\tdev->qmult = qmult;\n\tsnprintf(net->name, sizeof(net->name), \"%s%%d\", netname);\n\n\tif (get_ether_addr(dev_addr, addr)) {\n\t\tnet->addr_assign_type = NET_ADDR_RANDOM;\n\t\tdev_warn(&g->dev,\n\t\t\t\"using random %s ethernet address\\n\", \"self\");\n\t} else {\n\t\tnet->addr_assign_type = NET_ADDR_SET;\n\t}\n\teth_hw_addr_set(net, addr);\n\tif (get_ether_addr(host_addr, dev->host_mac))\n\t\tdev_warn(&g->dev,\n\t\t\t\"using random %s ethernet address\\n\", \"host\");\n\n\tif (ethaddr)\n\t\tmemcpy(ethaddr, dev->host_mac, ETH_ALEN);\n\n\tnet->netdev_ops = &eth_netdev_ops;\n\n\tnet->ethtool_ops = &ops;\n\n\t \n\tnet->min_mtu = ETH_HLEN;\n\tnet->max_mtu = GETHER_MAX_MTU_SIZE;\n\n\tdev->gadget = g;\n\tSET_NETDEV_DEV(net, &g->dev);\n\tSET_NETDEV_DEVTYPE(net, &gadget_type);\n\n\tstatus = register_netdev(net);\n\tif (status < 0) {\n\t\tdev_dbg(&g->dev, \"register_netdev failed, %d\\n\", status);\n\t\tfree_netdev(net);\n\t\tdev = ERR_PTR(status);\n\t} else {\n\t\tINFO(dev, \"MAC %pM\\n\", net->dev_addr);\n\t\tINFO(dev, \"HOST MAC %pM\\n\", dev->host_mac);\n\n\t\t \n\t\tnetif_carrier_off(net);\n\t}\n\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(gether_setup_name);\n\nstruct net_device *gether_setup_name_default(const char *netname)\n{\n\tstruct net_device\t*net;\n\tstruct eth_dev\t\t*dev;\n\n\tnet = alloc_etherdev(sizeof(*dev));\n\tif (!net)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = netdev_priv(net);\n\tspin_lock_init(&dev->lock);\n\tspin_lock_init(&dev->req_lock);\n\tINIT_WORK(&dev->work, eth_work);\n\tINIT_LIST_HEAD(&dev->tx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_reqs);\n\n\tskb_queue_head_init(&dev->rx_frames);\n\n\t \n\tdev->net = net;\n\tdev->qmult = QMULT_DEFAULT;\n\tsnprintf(net->name, sizeof(net->name), \"%s%%d\", netname);\n\n\teth_random_addr(dev->dev_mac);\n\n\t \n\tnet->addr_assign_type = NET_ADDR_RANDOM;\n\n\teth_random_addr(dev->host_mac);\n\n\tnet->netdev_ops = &eth_netdev_ops;\n\n\tnet->ethtool_ops = &ops;\n\tSET_NETDEV_DEVTYPE(net, &gadget_type);\n\n\t \n\tnet->min_mtu = ETH_HLEN;\n\tnet->max_mtu = GETHER_MAX_MTU_SIZE;\n\n\treturn net;\n}\nEXPORT_SYMBOL_GPL(gether_setup_name_default);\n\nint gether_register_netdev(struct net_device *net)\n{\n\tstruct eth_dev *dev;\n\tstruct usb_gadget *g;\n\tint status;\n\n\tif (!net->dev.parent)\n\t\treturn -EINVAL;\n\tdev = netdev_priv(net);\n\tg = dev->gadget;\n\n\teth_hw_addr_set(net, dev->dev_mac);\n\n\tstatus = register_netdev(net);\n\tif (status < 0) {\n\t\tdev_dbg(&g->dev, \"register_netdev failed, %d\\n\", status);\n\t\treturn status;\n\t} else {\n\t\tINFO(dev, \"HOST MAC %pM\\n\", dev->host_mac);\n\t\tINFO(dev, \"MAC %pM\\n\", dev->dev_mac);\n\n\t\t \n\t\tnetif_carrier_off(net);\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(gether_register_netdev);\n\nvoid gether_set_gadget(struct net_device *net, struct usb_gadget *g)\n{\n\tstruct eth_dev *dev;\n\n\tdev = netdev_priv(net);\n\tdev->gadget = g;\n\tSET_NETDEV_DEV(net, &g->dev);\n}\nEXPORT_SYMBOL_GPL(gether_set_gadget);\n\nint gether_set_dev_addr(struct net_device *net, const char *dev_addr)\n{\n\tstruct eth_dev *dev;\n\tu8 new_addr[ETH_ALEN];\n\n\tdev = netdev_priv(net);\n\tif (get_ether_addr(dev_addr, new_addr))\n\t\treturn -EINVAL;\n\tmemcpy(dev->dev_mac, new_addr, ETH_ALEN);\n\tnet->addr_assign_type = NET_ADDR_SET;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gether_set_dev_addr);\n\nint gether_get_dev_addr(struct net_device *net, char *dev_addr, int len)\n{\n\tstruct eth_dev *dev;\n\tint ret;\n\n\tdev = netdev_priv(net);\n\tret = get_ether_addr_str(dev->dev_mac, dev_addr, len);\n\tif (ret + 1 < len) {\n\t\tdev_addr[ret++] = '\\n';\n\t\tdev_addr[ret] = '\\0';\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gether_get_dev_addr);\n\nint gether_set_host_addr(struct net_device *net, const char *host_addr)\n{\n\tstruct eth_dev *dev;\n\tu8 new_addr[ETH_ALEN];\n\n\tdev = netdev_priv(net);\n\tif (get_ether_addr(host_addr, new_addr))\n\t\treturn -EINVAL;\n\tmemcpy(dev->host_mac, new_addr, ETH_ALEN);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gether_set_host_addr);\n\nint gether_get_host_addr(struct net_device *net, char *host_addr, int len)\n{\n\tstruct eth_dev *dev;\n\tint ret;\n\n\tdev = netdev_priv(net);\n\tret = get_ether_addr_str(dev->host_mac, host_addr, len);\n\tif (ret + 1 < len) {\n\t\thost_addr[ret++] = '\\n';\n\t\thost_addr[ret] = '\\0';\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gether_get_host_addr);\n\nint gether_get_host_addr_cdc(struct net_device *net, char *host_addr, int len)\n{\n\tstruct eth_dev *dev;\n\n\tif (len < 13)\n\t\treturn -EINVAL;\n\n\tdev = netdev_priv(net);\n\tsnprintf(host_addr, len, \"%pm\", dev->host_mac);\n\n\tstring_upper(host_addr, host_addr);\n\n\treturn strlen(host_addr);\n}\nEXPORT_SYMBOL_GPL(gether_get_host_addr_cdc);\n\nvoid gether_get_host_addr_u8(struct net_device *net, u8 host_mac[ETH_ALEN])\n{\n\tstruct eth_dev *dev;\n\n\tdev = netdev_priv(net);\n\tmemcpy(host_mac, dev->host_mac, ETH_ALEN);\n}\nEXPORT_SYMBOL_GPL(gether_get_host_addr_u8);\n\nvoid gether_set_qmult(struct net_device *net, unsigned qmult)\n{\n\tstruct eth_dev *dev;\n\n\tdev = netdev_priv(net);\n\tdev->qmult = qmult;\n}\nEXPORT_SYMBOL_GPL(gether_set_qmult);\n\nunsigned gether_get_qmult(struct net_device *net)\n{\n\tstruct eth_dev *dev;\n\n\tdev = netdev_priv(net);\n\treturn dev->qmult;\n}\nEXPORT_SYMBOL_GPL(gether_get_qmult);\n\nint gether_get_ifname(struct net_device *net, char *name, int len)\n{\n\tstruct eth_dev *dev = netdev_priv(net);\n\tint ret;\n\n\trtnl_lock();\n\tret = scnprintf(name, len, \"%s\\n\",\n\t\t\tdev->ifname_set ? net->name : netdev_name(net));\n\trtnl_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gether_get_ifname);\n\nint gether_set_ifname(struct net_device *net, const char *name, int len)\n{\n\tstruct eth_dev *dev = netdev_priv(net);\n\tchar tmp[IFNAMSIZ];\n\tconst char *p;\n\n\tif (name[len - 1] == '\\n')\n\t\tlen--;\n\n\tif (len >= sizeof(tmp))\n\t\treturn -E2BIG;\n\n\tstrscpy(tmp, name, len + 1);\n\tif (!dev_valid_name(tmp))\n\t\treturn -EINVAL;\n\n\t \n\tp = strchr(name, '%');\n\tif (!p || p[1] != 'd' || strchr(p + 2, '%'))\n\t\treturn -EINVAL;\n\n\tstrncpy(net->name, tmp, sizeof(net->name));\n\tdev->ifname_set = true;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(gether_set_ifname);\n\nvoid gether_suspend(struct gether *link)\n{\n\tstruct eth_dev *dev = link->ioport;\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (atomic_read(&dev->tx_qlen)) {\n\t\t \n\t\tether_wakeup_host(dev->port_usb);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlink->is_suspend = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\nEXPORT_SYMBOL_GPL(gether_suspend);\n\nvoid gether_resume(struct gether *link)\n{\n\tstruct eth_dev *dev = link->ioport;\n\tunsigned long flags;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (netif_queue_stopped(dev->net))\n\t\tnetif_start_queue(dev->net);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlink->is_suspend = false;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\nEXPORT_SYMBOL_GPL(gether_resume);\n\n \nvoid gether_cleanup(struct eth_dev *dev)\n{\n\tif (!dev)\n\t\treturn;\n\n\tunregister_netdev(dev->net);\n\tflush_work(&dev->work);\n\tfree_netdev(dev->net);\n}\nEXPORT_SYMBOL_GPL(gether_cleanup);\n\n \nstruct net_device *gether_connect(struct gether *link)\n{\n\tstruct eth_dev\t\t*dev = link->ioport;\n\tint\t\t\tresult = 0;\n\n\tif (!dev)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlink->in_ep->driver_data = dev;\n\tresult = usb_ep_enable(link->in_ep);\n\tif (result != 0) {\n\t\tDBG(dev, \"enable %s --> %d\\n\",\n\t\t\tlink->in_ep->name, result);\n\t\tgoto fail0;\n\t}\n\n\tlink->out_ep->driver_data = dev;\n\tresult = usb_ep_enable(link->out_ep);\n\tif (result != 0) {\n\t\tDBG(dev, \"enable %s --> %d\\n\",\n\t\t\tlink->out_ep->name, result);\n\t\tgoto fail1;\n\t}\n\n\tif (result == 0)\n\t\tresult = alloc_requests(dev, link, qlen(dev->gadget,\n\t\t\t\t\tdev->qmult));\n\n\tif (result == 0) {\n\t\tdev->zlp = link->is_zlp_ok;\n\t\tdev->no_skb_reserve = gadget_avoids_skb_reserve(dev->gadget);\n\t\tDBG(dev, \"qlen %d\\n\", qlen(dev->gadget, dev->qmult));\n\n\t\tdev->header_len = link->header_len;\n\t\tdev->unwrap = link->unwrap;\n\t\tdev->wrap = link->wrap;\n\n\t\tspin_lock(&dev->lock);\n\t\tdev->port_usb = link;\n\t\tif (netif_running(dev->net)) {\n\t\t\tif (link->open)\n\t\t\t\tlink->open(link);\n\t\t} else {\n\t\t\tif (link->close)\n\t\t\t\tlink->close(link);\n\t\t}\n\t\tspin_unlock(&dev->lock);\n\n\t\tnetif_carrier_on(dev->net);\n\t\tif (netif_running(dev->net))\n\t\t\teth_start(dev, GFP_ATOMIC);\n\n\t \n\t} else {\n\t\t(void) usb_ep_disable(link->out_ep);\nfail1:\n\t\t(void) usb_ep_disable(link->in_ep);\n\t}\nfail0:\n\t \n\tif (result < 0)\n\t\treturn ERR_PTR(result);\n\treturn dev->net;\n}\nEXPORT_SYMBOL_GPL(gether_connect);\n\n \nvoid gether_disconnect(struct gether *link)\n{\n\tstruct eth_dev\t\t*dev = link->ioport;\n\tstruct usb_request\t*req;\n\n\tWARN_ON(!dev);\n\tif (!dev)\n\t\treturn;\n\n\tDBG(dev, \"%s\\n\", __func__);\n\n\tnetif_stop_queue(dev->net);\n\tnetif_carrier_off(dev->net);\n\n\t \n\tusb_ep_disable(link->in_ep);\n\tspin_lock(&dev->req_lock);\n\twhile (!list_empty(&dev->tx_reqs)) {\n\t\treq = list_first_entry(&dev->tx_reqs, struct usb_request, list);\n\t\tlist_del(&req->list);\n\n\t\tspin_unlock(&dev->req_lock);\n\t\tusb_ep_free_request(link->in_ep, req);\n\t\tspin_lock(&dev->req_lock);\n\t}\n\tspin_unlock(&dev->req_lock);\n\tlink->in_ep->desc = NULL;\n\n\tusb_ep_disable(link->out_ep);\n\tspin_lock(&dev->req_lock);\n\twhile (!list_empty(&dev->rx_reqs)) {\n\t\treq = list_first_entry(&dev->rx_reqs, struct usb_request, list);\n\t\tlist_del(&req->list);\n\n\t\tspin_unlock(&dev->req_lock);\n\t\tusb_ep_free_request(link->out_ep, req);\n\t\tspin_lock(&dev->req_lock);\n\t}\n\tspin_unlock(&dev->req_lock);\n\tlink->out_ep->desc = NULL;\n\n\t \n\tdev->header_len = 0;\n\tdev->unwrap = NULL;\n\tdev->wrap = NULL;\n\n\tspin_lock(&dev->lock);\n\tdev->port_usb = NULL;\n\tlink->is_suspend = false;\n\tspin_unlock(&dev->lock);\n}\nEXPORT_SYMBOL_GPL(gether_disconnect);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}