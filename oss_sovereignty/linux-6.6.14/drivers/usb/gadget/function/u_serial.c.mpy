{
  "module_name": "u_serial.c",
  "hash_id": "cfa9377fceea74d6d814262e8d9ca8b97bde52e0173df360b0720cc8f7e0bbfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/u_serial.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/console.h>\n#include <linux/kstrtox.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/kfifo.h>\n\n#include \"u_serial.h\"\n\n\n \n\n \n#define QUEUE_SIZE\t\t16\n#define WRITE_BUF_SIZE\t\t8192\t\t \n#define GS_CONSOLE_BUF_SIZE\t8192\n\n \nstatic DEFINE_SPINLOCK(serial_port_lock);\n\n \nstruct gs_console {\n\tstruct console\t\tconsole;\n\tstruct work_struct\twork;\n\tspinlock_t\t\tlock;\n\tstruct usb_request\t*req;\n\tstruct kfifo\t\tbuf;\n\tsize_t\t\t\tmissed;\n};\n\n \nstruct gs_port {\n\tstruct tty_port\t\tport;\n\tspinlock_t\t\tport_lock;\t \n\n\tstruct gserial\t\t*port_usb;\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\tstruct gs_console\t*console;\n#endif\n\n\tu8\t\t\tport_num;\n\n\tstruct list_head\tread_pool;\n\tint read_started;\n\tint read_allocated;\n\tstruct list_head\tread_queue;\n\tunsigned\t\tn_read;\n\tstruct delayed_work\tpush;\n\n\tstruct list_head\twrite_pool;\n\tint write_started;\n\tint write_allocated;\n\tstruct kfifo\t\tport_write_buf;\n\twait_queue_head_t\tdrain_wait;\t \n\tbool                    write_busy;\n\twait_queue_head_t\tclose_wait;\n\tbool\t\t\tsuspended;\t \n\tbool\t\t\tstart_delayed;\t \n\n\t \n\tstruct usb_cdc_line_coding port_line_coding;\t \n};\n\nstatic struct portmaster {\n\tstruct mutex\tlock;\t\t\t \n\tstruct gs_port\t*port;\n} ports[MAX_U_SERIAL_PORTS];\n\n#define GS_CLOSE_TIMEOUT\t\t15\t\t \n\n\n\n#ifdef VERBOSE_DEBUG\n#ifndef pr_vdebug\n#define pr_vdebug(fmt, arg...) \\\n\tpr_debug(fmt, ##arg)\n#endif  \n#else\n#ifndef pr_vdebug\n#define pr_vdebug(fmt, arg...) \\\n\t({ if (0) pr_debug(fmt, ##arg); })\n#endif  \n#endif\n\n \n\n \n\n \nstruct usb_request *\ngs_alloc_req(struct usb_ep *ep, unsigned len, gfp_t kmalloc_flags)\n{\n\tstruct usb_request *req;\n\n\treq = usb_ep_alloc_request(ep, kmalloc_flags);\n\n\tif (req != NULL) {\n\t\treq->length = len;\n\t\treq->buf = kmalloc(len, kmalloc_flags);\n\t\tif (req->buf == NULL) {\n\t\t\tusb_ep_free_request(ep, req);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn req;\n}\nEXPORT_SYMBOL_GPL(gs_alloc_req);\n\n \nvoid gs_free_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tkfree(req->buf);\n\tusb_ep_free_request(ep, req);\n}\nEXPORT_SYMBOL_GPL(gs_free_req);\n\n \nstatic unsigned\ngs_send_packet(struct gs_port *port, char *packet, unsigned size)\n{\n\tunsigned len;\n\n\tlen = kfifo_len(&port->port_write_buf);\n\tif (len < size)\n\t\tsize = len;\n\tif (size != 0)\n\t\tsize = kfifo_out(&port->port_write_buf, packet, size);\n\treturn size;\n}\n\n \nstatic int gs_start_tx(struct gs_port *port)\n \n{\n\tstruct list_head\t*pool = &port->write_pool;\n\tstruct usb_ep\t\t*in;\n\tint\t\t\tstatus = 0;\n\tbool\t\t\tdo_tty_wake = false;\n\n\tif (!port->port_usb)\n\t\treturn status;\n\n\tin = port->port_usb->in;\n\n\twhile (!port->write_busy && !list_empty(pool)) {\n\t\tstruct usb_request\t*req;\n\t\tint\t\t\tlen;\n\n\t\tif (port->write_started >= QUEUE_SIZE)\n\t\t\tbreak;\n\n\t\treq = list_entry(pool->next, struct usb_request, list);\n\t\tlen = gs_send_packet(port, req->buf, in->maxpacket);\n\t\tif (len == 0) {\n\t\t\twake_up_interruptible(&port->drain_wait);\n\t\t\tbreak;\n\t\t}\n\t\tdo_tty_wake = true;\n\n\t\treq->length = len;\n\t\tlist_del(&req->list);\n\t\treq->zero = kfifo_is_empty(&port->port_write_buf);\n\n\t\tpr_vdebug(\"ttyGS%d: tx len=%d, %3ph ...\\n\", port->port_num, len, req->buf);\n\n\t\t \n\t\tport->write_busy = true;\n\t\tspin_unlock(&port->port_lock);\n\t\tstatus = usb_ep_queue(in, req, GFP_ATOMIC);\n\t\tspin_lock(&port->port_lock);\n\t\tport->write_busy = false;\n\n\t\tif (status) {\n\t\t\tpr_debug(\"%s: %s %s err %d\\n\",\n\t\t\t\t\t__func__, \"queue\", in->name, status);\n\t\t\tlist_add(&req->list, pool);\n\t\t\tbreak;\n\t\t}\n\n\t\tport->write_started++;\n\n\t\t \n\t\tif (!port->port_usb)\n\t\t\tbreak;\n\t}\n\n\tif (do_tty_wake && port->port.tty)\n\t\ttty_wakeup(port->port.tty);\n\treturn status;\n}\n\n \nstatic unsigned gs_start_rx(struct gs_port *port)\n \n{\n\tstruct list_head\t*pool = &port->read_pool;\n\tstruct usb_ep\t\t*out = port->port_usb->out;\n\n\twhile (!list_empty(pool)) {\n\t\tstruct usb_request\t*req;\n\t\tint\t\t\tstatus;\n\t\tstruct tty_struct\t*tty;\n\n\t\t \n\t\ttty = port->port.tty;\n\t\tif (!tty)\n\t\t\tbreak;\n\n\t\tif (port->read_started >= QUEUE_SIZE)\n\t\t\tbreak;\n\n\t\treq = list_entry(pool->next, struct usb_request, list);\n\t\tlist_del(&req->list);\n\t\treq->length = out->maxpacket;\n\n\t\t \n\t\tspin_unlock(&port->port_lock);\n\t\tstatus = usb_ep_queue(out, req, GFP_ATOMIC);\n\t\tspin_lock(&port->port_lock);\n\n\t\tif (status) {\n\t\t\tpr_debug(\"%s: %s %s err %d\\n\",\n\t\t\t\t\t__func__, \"queue\", out->name, status);\n\t\t\tlist_add(&req->list, pool);\n\t\t\tbreak;\n\t\t}\n\t\tport->read_started++;\n\n\t\t \n\t\tif (!port->port_usb)\n\t\t\tbreak;\n\t}\n\treturn port->read_started;\n}\n\n \nstatic void gs_rx_push(struct work_struct *work)\n{\n\tstruct delayed_work\t*w = to_delayed_work(work);\n\tstruct gs_port\t\t*port = container_of(w, struct gs_port, push);\n\tstruct tty_struct\t*tty;\n\tstruct list_head\t*queue = &port->read_queue;\n\tbool\t\t\tdisconnect = false;\n\tbool\t\t\tdo_push = false;\n\n\t \n\tspin_lock_irq(&port->port_lock);\n\ttty = port->port.tty;\n\twhile (!list_empty(queue)) {\n\t\tstruct usb_request\t*req;\n\n\t\treq = list_first_entry(queue, struct usb_request, list);\n\n\t\t \n\t\tif (tty && tty_throttled(tty))\n\t\t\tbreak;\n\n\t\tswitch (req->status) {\n\t\tcase -ESHUTDOWN:\n\t\t\tdisconnect = true;\n\t\t\tpr_vdebug(\"ttyGS%d: shutdown\\n\", port->port_num);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tpr_warn(\"ttyGS%d: unexpected RX status %d\\n\",\n\t\t\t\tport->port_num, req->status);\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (req->actual && tty) {\n\t\t\tchar\t\t*packet = req->buf;\n\t\t\tunsigned\tsize = req->actual;\n\t\t\tunsigned\tn;\n\t\t\tint\t\tcount;\n\n\t\t\t \n\t\t\tn = port->n_read;\n\t\t\tif (n) {\n\t\t\t\tpacket += n;\n\t\t\t\tsize -= n;\n\t\t\t}\n\n\t\t\tcount = tty_insert_flip_string(&port->port, packet,\n\t\t\t\t\tsize);\n\t\t\tif (count)\n\t\t\t\tdo_push = true;\n\t\t\tif (count != size) {\n\t\t\t\t \n\t\t\t\tport->n_read += count;\n\t\t\t\tpr_vdebug(\"ttyGS%d: rx block %d/%d\\n\",\n\t\t\t\t\t  port->port_num, count, req->actual);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport->n_read = 0;\n\t\t}\n\n\t\tlist_move(&req->list, &port->read_pool);\n\t\tport->read_started--;\n\t}\n\n\t \n\tif (do_push)\n\t\ttty_flip_buffer_push(&port->port);\n\n\n\t \n\tif (!list_empty(queue) && !tty_throttled(tty))\n\t\tschedule_delayed_work(&port->push, 1);\n\n\t \n\tif (!disconnect && port->port_usb)\n\t\tgs_start_rx(port);\n\n\tspin_unlock_irq(&port->port_lock);\n}\n\nstatic void gs_read_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct gs_port\t*port = ep->driver_data;\n\n\t \n\tspin_lock(&port->port_lock);\n\tlist_add_tail(&req->list, &port->read_queue);\n\tschedule_delayed_work(&port->push, 0);\n\tspin_unlock(&port->port_lock);\n}\n\nstatic void gs_write_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct gs_port\t*port = ep->driver_data;\n\n\tspin_lock(&port->port_lock);\n\tlist_add(&req->list, &port->write_pool);\n\tport->write_started--;\n\n\tswitch (req->status) {\n\tdefault:\n\t\t \n\t\tpr_warn(\"%s: unexpected %s status %d\\n\",\n\t\t\t__func__, ep->name, req->status);\n\t\tfallthrough;\n\tcase 0:\n\t\t \n\t\tgs_start_tx(port);\n\t\tbreak;\n\n\tcase -ESHUTDOWN:\n\t\t \n\t\tpr_vdebug(\"%s: %s shutdown\\n\", __func__, ep->name);\n\t\tbreak;\n\t}\n\n\tspin_unlock(&port->port_lock);\n}\n\nstatic void gs_free_requests(struct usb_ep *ep, struct list_head *head,\n\t\t\t\t\t\t\t int *allocated)\n{\n\tstruct usb_request\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = list_entry(head->next, struct usb_request, list);\n\t\tlist_del(&req->list);\n\t\tgs_free_req(ep, req);\n\t\tif (allocated)\n\t\t\t(*allocated)--;\n\t}\n}\n\nstatic int gs_alloc_requests(struct usb_ep *ep, struct list_head *head,\n\t\tvoid (*fn)(struct usb_ep *, struct usb_request *),\n\t\tint *allocated)\n{\n\tint\t\t\ti;\n\tstruct usb_request\t*req;\n\tint n = allocated ? QUEUE_SIZE - *allocated : QUEUE_SIZE;\n\n\t \n\tfor (i = 0; i < n; i++) {\n\t\treq = gs_alloc_req(ep, ep->maxpacket, GFP_ATOMIC);\n\t\tif (!req)\n\t\t\treturn list_empty(head) ? -ENOMEM : 0;\n\t\treq->complete = fn;\n\t\tlist_add_tail(&req->list, head);\n\t\tif (allocated)\n\t\t\t(*allocated)++;\n\t}\n\treturn 0;\n}\n\n \nstatic int gs_start_io(struct gs_port *port)\n{\n\tstruct list_head\t*head = &port->read_pool;\n\tstruct usb_ep\t\t*ep;\n\tint\t\t\tstatus;\n\tunsigned\t\tstarted;\n\n\tif (!port->port_usb || !port->port.tty)\n\t\treturn -EIO;\n\n\t \n\tep = port->port_usb->out;\n\tstatus = gs_alloc_requests(ep, head, gs_read_complete,\n\t\t&port->read_allocated);\n\tif (status)\n\t\treturn status;\n\n\tstatus = gs_alloc_requests(port->port_usb->in, &port->write_pool,\n\t\t\tgs_write_complete, &port->write_allocated);\n\tif (status) {\n\t\tgs_free_requests(ep, head, &port->read_allocated);\n\t\treturn status;\n\t}\n\n\t \n\tport->n_read = 0;\n\tstarted = gs_start_rx(port);\n\n\tif (started) {\n\t\tgs_start_tx(port);\n\t\t \n\t\ttty_wakeup(port->port.tty);\n\t} else {\n\t\tgs_free_requests(ep, head, &port->read_allocated);\n\t\tgs_free_requests(port->port_usb->in, &port->write_pool,\n\t\t\t&port->write_allocated);\n\t\tstatus = -EIO;\n\t}\n\n\treturn status;\n}\n\n \n\n \n\n \nstatic int gs_open(struct tty_struct *tty, struct file *file)\n{\n\tint\t\tport_num = tty->index;\n\tstruct gs_port\t*port;\n\tint\t\tstatus = 0;\n\n\tmutex_lock(&ports[port_num].lock);\n\tport = ports[port_num].port;\n\tif (!port) {\n\t\tstatus = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&port->port_lock);\n\n\t \n\tif (!kfifo_initialized(&port->port_write_buf)) {\n\n\t\tspin_unlock_irq(&port->port_lock);\n\n\t\t \n\n\t\tstatus = kfifo_alloc(&port->port_write_buf,\n\t\t\t\t     WRITE_BUF_SIZE, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tpr_debug(\"gs_open: ttyGS%d (%p,%p) no buffer\\n\",\n\t\t\t\t port_num, tty, file);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irq(&port->port_lock);\n\t}\n\n\t \n\tif (port->port.count++)\n\t\tgoto exit_unlock_port;\n\n\ttty->driver_data = port;\n\tport->port.tty = tty;\n\n\t \n\tif (port->port_usb) {\n\t\t \n\t\tif (!port->suspended) {\n\t\t\tstruct gserial\t*gser = port->port_usb;\n\n\t\t\tpr_debug(\"gs_open: start ttyGS%d\\n\", port->port_num);\n\t\t\tgs_start_io(port);\n\n\t\t\tif (gser->connect)\n\t\t\t\tgser->connect(gser);\n\t\t} else {\n\t\t\tpr_debug(\"delay start of ttyGS%d\\n\", port->port_num);\n\t\t\tport->start_delayed = true;\n\t\t}\n\t}\n\n\tpr_debug(\"gs_open: ttyGS%d (%p,%p)\\n\", port->port_num, tty, file);\n\nexit_unlock_port:\n\tspin_unlock_irq(&port->port_lock);\nout:\n\tmutex_unlock(&ports[port_num].lock);\n\treturn status;\n}\n\nstatic int gs_close_flush_done(struct gs_port *p)\n{\n\tint cond;\n\n\t \n\tspin_lock_irq(&p->port_lock);\n\tcond = p->port_usb == NULL || !kfifo_len(&p->port_write_buf) ||\n\t\tp->port.count > 1;\n\tspin_unlock_irq(&p->port_lock);\n\n\treturn cond;\n}\n\nstatic void gs_close(struct tty_struct *tty, struct file *file)\n{\n\tstruct gs_port *port = tty->driver_data;\n\tstruct gserial\t*gser;\n\n\tspin_lock_irq(&port->port_lock);\n\n\tif (port->port.count != 1) {\nraced_with_open:\n\t\tif (port->port.count == 0)\n\t\t\tWARN_ON(1);\n\t\telse\n\t\t\t--port->port.count;\n\t\tgoto exit;\n\t}\n\n\tpr_debug(\"gs_close: ttyGS%d (%p,%p) ...\\n\", port->port_num, tty, file);\n\n\tgser = port->port_usb;\n\tif (gser && !port->suspended && gser->disconnect)\n\t\tgser->disconnect(gser);\n\n\t \n\tif (kfifo_len(&port->port_write_buf) > 0 && gser) {\n\t\tspin_unlock_irq(&port->port_lock);\n\t\twait_event_interruptible_timeout(port->drain_wait,\n\t\t\t\t\tgs_close_flush_done(port),\n\t\t\t\t\tGS_CLOSE_TIMEOUT * HZ);\n\t\tspin_lock_irq(&port->port_lock);\n\n\t\tif (port->port.count != 1)\n\t\t\tgoto raced_with_open;\n\n\t\tgser = port->port_usb;\n\t}\n\n\t \n\tif (gser == NULL)\n\t\tkfifo_free(&port->port_write_buf);\n\telse\n\t\tkfifo_reset(&port->port_write_buf);\n\n\tport->start_delayed = false;\n\tport->port.count = 0;\n\tport->port.tty = NULL;\n\n\tpr_debug(\"gs_close: ttyGS%d (%p,%p) done!\\n\",\n\t\t\tport->port_num, tty, file);\n\n\twake_up(&port->close_wait);\nexit:\n\tspin_unlock_irq(&port->port_lock);\n}\n\nstatic ssize_t gs_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tunsigned long\tflags;\n\n\tpr_vdebug(\"gs_write: ttyGS%d (%p) writing %zu bytes\\n\",\n\t\t\tport->port_num, tty, count);\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (count)\n\t\tcount = kfifo_in(&port->port_write_buf, buf, count);\n\t \n\tif (port->port_usb)\n\t\tgs_start_tx(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn count;\n}\n\nstatic int gs_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tunsigned long\tflags;\n\tint\t\tstatus;\n\n\tpr_vdebug(\"gs_put_char: (%d,%p) char=0x%x, called from %ps\\n\",\n\t\tport->port_num, tty, ch, __builtin_return_address(0));\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tstatus = kfifo_put(&port->port_write_buf, ch);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn status;\n}\n\nstatic void gs_flush_chars(struct tty_struct *tty)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tunsigned long\tflags;\n\n\tpr_vdebug(\"gs_flush_chars: (%d,%p)\\n\", port->port_num, tty);\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (port->port_usb)\n\t\tgs_start_tx(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic unsigned int gs_write_room(struct tty_struct *tty)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tunsigned long\tflags;\n\tunsigned int room = 0;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (port->port_usb)\n\t\troom = kfifo_avail(&port->port_write_buf);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\tpr_vdebug(\"gs_write_room: (%d,%p) room=%u\\n\",\n\t\tport->port_num, tty, room);\n\n\treturn room;\n}\n\nstatic unsigned int gs_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tunsigned long\tflags;\n\tunsigned int\tchars;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tchars = kfifo_len(&port->port_write_buf);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\tpr_vdebug(\"gs_chars_in_buffer: (%d,%p) chars=%u\\n\",\n\t\tport->port_num, tty, chars);\n\n\treturn chars;\n}\n\n \nstatic void gs_unthrottle(struct tty_struct *tty)\n{\n\tstruct gs_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (port->port_usb) {\n\t\t \n\t\tpr_vdebug(\"ttyGS%d: unthrottle\\n\", port->port_num);\n\t\tschedule_delayed_work(&port->push, 0);\n\t}\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic int gs_break_ctl(struct tty_struct *tty, int duration)\n{\n\tstruct gs_port\t*port = tty->driver_data;\n\tint\t\tstatus = 0;\n\tstruct gserial\t*gser;\n\n\tpr_vdebug(\"gs_break_ctl: ttyGS%d, send break (%d) \\n\",\n\t\t\tport->port_num, duration);\n\n\tspin_lock_irq(&port->port_lock);\n\tgser = port->port_usb;\n\tif (gser && gser->send_break)\n\t\tstatus = gser->send_break(gser, duration);\n\tspin_unlock_irq(&port->port_lock);\n\n\treturn status;\n}\n\nstatic const struct tty_operations gs_tty_ops = {\n\t.open =\t\t\tgs_open,\n\t.close =\t\tgs_close,\n\t.write =\t\tgs_write,\n\t.put_char =\t\tgs_put_char,\n\t.flush_chars =\t\tgs_flush_chars,\n\t.write_room =\t\tgs_write_room,\n\t.chars_in_buffer =\tgs_chars_in_buffer,\n\t.unthrottle =\t\tgs_unthrottle,\n\t.break_ctl =\t\tgs_break_ctl,\n};\n\n \n\nstatic struct tty_driver *gs_tty_driver;\n\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\nstatic void gs_console_complete_out(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct gs_console *cons = req->context;\n\n\tswitch (req->status) {\n\tdefault:\n\t\tpr_warn(\"%s: unexpected %s status %d\\n\",\n\t\t\t__func__, ep->name, req->status);\n\t\tfallthrough;\n\tcase 0:\n\t\t \n\t\tspin_lock(&cons->lock);\n\t\treq->length = 0;\n\t\tschedule_work(&cons->work);\n\t\tspin_unlock(&cons->lock);\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tpr_vdebug(\"%s: %s shutdown\\n\", __func__, ep->name);\n\t\tbreak;\n\t}\n}\n\nstatic void __gs_console_push(struct gs_console *cons)\n{\n\tstruct usb_request *req = cons->req;\n\tstruct usb_ep *ep;\n\tsize_t size;\n\n\tif (!req)\n\t\treturn;\t \n\n\tif (req->length)\n\t\treturn;\t \n\n\tep = cons->console.data;\n\tsize = kfifo_out(&cons->buf, req->buf, ep->maxpacket);\n\tif (!size)\n\t\treturn;\n\n\tif (cons->missed && ep->maxpacket >= 64) {\n\t\tchar buf[64];\n\t\tsize_t len;\n\n\t\tlen = sprintf(buf, \"\\n[missed %zu bytes]\\n\", cons->missed);\n\t\tkfifo_in(&cons->buf, buf, len);\n\t\tcons->missed = 0;\n\t}\n\n\treq->length = size;\n\n\tspin_unlock_irq(&cons->lock);\n\tif (usb_ep_queue(ep, req, GFP_ATOMIC))\n\t\treq->length = 0;\n\tspin_lock_irq(&cons->lock);\n}\n\nstatic void gs_console_work(struct work_struct *work)\n{\n\tstruct gs_console *cons = container_of(work, struct gs_console, work);\n\n\tspin_lock_irq(&cons->lock);\n\n\t__gs_console_push(cons);\n\n\tspin_unlock_irq(&cons->lock);\n}\n\nstatic void gs_console_write(struct console *co,\n\t\t\t     const char *buf, unsigned count)\n{\n\tstruct gs_console *cons = container_of(co, struct gs_console, console);\n\tunsigned long flags;\n\tsize_t n;\n\n\tspin_lock_irqsave(&cons->lock, flags);\n\n\tn = kfifo_in(&cons->buf, buf, count);\n\tif (n < count)\n\t\tcons->missed += count - n;\n\n\tif (cons->req && !cons->req->length)\n\t\tschedule_work(&cons->work);\n\n\tspin_unlock_irqrestore(&cons->lock, flags);\n}\n\nstatic struct tty_driver *gs_console_device(struct console *co, int *index)\n{\n\t*index = co->index;\n\treturn gs_tty_driver;\n}\n\nstatic int gs_console_connect(struct gs_port *port)\n{\n\tstruct gs_console *cons = port->console;\n\tstruct usb_request *req;\n\tstruct usb_ep *ep;\n\n\tif (!cons)\n\t\treturn 0;\n\n\tep = port->port_usb->in;\n\treq = gs_alloc_req(ep, ep->maxpacket, GFP_ATOMIC);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->complete = gs_console_complete_out;\n\treq->context = cons;\n\treq->length = 0;\n\n\tspin_lock(&cons->lock);\n\tcons->req = req;\n\tcons->console.data = ep;\n\tspin_unlock(&cons->lock);\n\n\tpr_debug(\"ttyGS%d: console connected!\\n\", port->port_num);\n\n\tschedule_work(&cons->work);\n\n\treturn 0;\n}\n\nstatic void gs_console_disconnect(struct gs_port *port)\n{\n\tstruct gs_console *cons = port->console;\n\tstruct usb_request *req;\n\tstruct usb_ep *ep;\n\n\tif (!cons)\n\t\treturn;\n\n\tspin_lock(&cons->lock);\n\n\treq = cons->req;\n\tep = cons->console.data;\n\tcons->req = NULL;\n\n\tspin_unlock(&cons->lock);\n\n\tif (!req)\n\t\treturn;\n\n\tusb_ep_dequeue(ep, req);\n\tgs_free_req(ep, req);\n}\n\nstatic int gs_console_init(struct gs_port *port)\n{\n\tstruct gs_console *cons;\n\tint err;\n\n\tif (port->console)\n\t\treturn 0;\n\n\tcons = kzalloc(sizeof(*port->console), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\tstrcpy(cons->console.name, \"ttyGS\");\n\tcons->console.write = gs_console_write;\n\tcons->console.device = gs_console_device;\n\tcons->console.flags = CON_PRINTBUFFER;\n\tcons->console.index = port->port_num;\n\n\tINIT_WORK(&cons->work, gs_console_work);\n\tspin_lock_init(&cons->lock);\n\n\terr = kfifo_alloc(&cons->buf, GS_CONSOLE_BUF_SIZE, GFP_KERNEL);\n\tif (err) {\n\t\tpr_err(\"ttyGS%d: allocate console buffer failed\\n\", port->port_num);\n\t\tkfree(cons);\n\t\treturn err;\n\t}\n\n\tport->console = cons;\n\tregister_console(&cons->console);\n\n\tspin_lock_irq(&port->port_lock);\n\tif (port->port_usb)\n\t\tgs_console_connect(port);\n\tspin_unlock_irq(&port->port_lock);\n\n\treturn 0;\n}\n\nstatic void gs_console_exit(struct gs_port *port)\n{\n\tstruct gs_console *cons = port->console;\n\n\tif (!cons)\n\t\treturn;\n\n\tunregister_console(&cons->console);\n\n\tspin_lock_irq(&port->port_lock);\n\tif (cons->req)\n\t\tgs_console_disconnect(port);\n\tspin_unlock_irq(&port->port_lock);\n\n\tcancel_work_sync(&cons->work);\n\tkfifo_free(&cons->buf);\n\tkfree(cons);\n\tport->console = NULL;\n}\n\nssize_t gserial_set_console(unsigned char port_num, const char *page, size_t count)\n{\n\tstruct gs_port *port;\n\tbool enable;\n\tint ret;\n\n\tret = kstrtobool(page, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&ports[port_num].lock);\n\tport = ports[port_num].port;\n\n\tif (WARN_ON(port == NULL)) {\n\t\tret = -ENXIO;\n\t\tgoto out;\n\t}\n\n\tif (enable)\n\t\tret = gs_console_init(port);\n\telse\n\t\tgs_console_exit(port);\nout:\n\tmutex_unlock(&ports[port_num].lock);\n\n\treturn ret < 0 ? ret : count;\n}\nEXPORT_SYMBOL_GPL(gserial_set_console);\n\nssize_t gserial_get_console(unsigned char port_num, char *page)\n{\n\tstruct gs_port *port;\n\tssize_t ret;\n\n\tmutex_lock(&ports[port_num].lock);\n\tport = ports[port_num].port;\n\n\tif (WARN_ON(port == NULL))\n\t\tret = -ENXIO;\n\telse\n\t\tret = sprintf(page, \"%u\\n\", !!port->console);\n\n\tmutex_unlock(&ports[port_num].lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gserial_get_console);\n\n#else\n\nstatic int gs_console_connect(struct gs_port *port)\n{\n\treturn 0;\n}\n\nstatic void gs_console_disconnect(struct gs_port *port)\n{\n}\n\nstatic int gs_console_init(struct gs_port *port)\n{\n\treturn -ENOSYS;\n}\n\nstatic void gs_console_exit(struct gs_port *port)\n{\n}\n\n#endif\n\nstatic int\ngs_port_alloc(unsigned port_num, struct usb_cdc_line_coding *coding)\n{\n\tstruct gs_port\t*port;\n\tint\t\tret = 0;\n\n\tmutex_lock(&ports[port_num].lock);\n\tif (ports[port_num].port) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tport = kzalloc(sizeof(struct gs_port), GFP_KERNEL);\n\tif (port == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\ttty_port_init(&port->port);\n\tspin_lock_init(&port->port_lock);\n\tinit_waitqueue_head(&port->drain_wait);\n\tinit_waitqueue_head(&port->close_wait);\n\n\tINIT_DELAYED_WORK(&port->push, gs_rx_push);\n\n\tINIT_LIST_HEAD(&port->read_pool);\n\tINIT_LIST_HEAD(&port->read_queue);\n\tINIT_LIST_HEAD(&port->write_pool);\n\n\tport->port_num = port_num;\n\tport->port_line_coding = *coding;\n\n\tports[port_num].port = port;\nout:\n\tmutex_unlock(&ports[port_num].lock);\n\treturn ret;\n}\n\nstatic int gs_closed(struct gs_port *port)\n{\n\tint cond;\n\n\tspin_lock_irq(&port->port_lock);\n\tcond = port->port.count == 0;\n\tspin_unlock_irq(&port->port_lock);\n\n\treturn cond;\n}\n\nstatic void gserial_free_port(struct gs_port *port)\n{\n\tcancel_delayed_work_sync(&port->push);\n\t \n\twait_event(port->close_wait, gs_closed(port));\n\tWARN_ON(port->port_usb != NULL);\n\ttty_port_destroy(&port->port);\n\tkfree(port);\n}\n\nvoid gserial_free_line(unsigned char port_num)\n{\n\tstruct gs_port\t*port;\n\n\tmutex_lock(&ports[port_num].lock);\n\tif (!ports[port_num].port) {\n\t\tmutex_unlock(&ports[port_num].lock);\n\t\treturn;\n\t}\n\tport = ports[port_num].port;\n\tgs_console_exit(port);\n\tports[port_num].port = NULL;\n\tmutex_unlock(&ports[port_num].lock);\n\n\tgserial_free_port(port);\n\ttty_unregister_device(gs_tty_driver, port_num);\n}\nEXPORT_SYMBOL_GPL(gserial_free_line);\n\nint gserial_alloc_line_no_console(unsigned char *line_num)\n{\n\tstruct usb_cdc_line_coding\tcoding;\n\tstruct gs_port\t\t\t*port;\n\tstruct device\t\t\t*tty_dev;\n\tint\t\t\t\tret;\n\tint\t\t\t\tport_num;\n\n\tcoding.dwDTERate = cpu_to_le32(9600);\n\tcoding.bCharFormat = 8;\n\tcoding.bParityType = USB_CDC_NO_PARITY;\n\tcoding.bDataBits = USB_CDC_1_STOP_BITS;\n\n\tfor (port_num = 0; port_num < MAX_U_SERIAL_PORTS; port_num++) {\n\t\tret = gs_port_alloc(port_num, &coding);\n\t\tif (ret == -EBUSY)\n\t\t\tcontinue;\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tport = ports[port_num].port;\n\ttty_dev = tty_port_register_device(&port->port,\n\t\t\tgs_tty_driver, port_num, NULL);\n\tif (IS_ERR(tty_dev)) {\n\t\tpr_err(\"%s: failed to register tty for port %d, err %ld\\n\",\n\t\t\t\t__func__, port_num, PTR_ERR(tty_dev));\n\n\t\tret = PTR_ERR(tty_dev);\n\t\tmutex_lock(&ports[port_num].lock);\n\t\tports[port_num].port = NULL;\n\t\tmutex_unlock(&ports[port_num].lock);\n\t\tgserial_free_port(port);\n\t\tgoto err;\n\t}\n\t*line_num = port_num;\nerr:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gserial_alloc_line_no_console);\n\nint gserial_alloc_line(unsigned char *line_num)\n{\n\tint ret = gserial_alloc_line_no_console(line_num);\n\n\tif (!ret && !*line_num)\n\t\tgs_console_init(ports[*line_num].port);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(gserial_alloc_line);\n\n \nint gserial_connect(struct gserial *gser, u8 port_num)\n{\n\tstruct gs_port\t*port;\n\tunsigned long\tflags;\n\tint\t\tstatus;\n\n\tif (port_num >= MAX_U_SERIAL_PORTS)\n\t\treturn -ENXIO;\n\n\tport = ports[port_num].port;\n\tif (!port) {\n\t\tpr_err(\"serial line %d not allocated.\\n\", port_num);\n\t\treturn -EINVAL;\n\t}\n\tif (port->port_usb) {\n\t\tpr_err(\"serial line %d is in use.\\n\", port_num);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tstatus = usb_ep_enable(gser->in);\n\tif (status < 0)\n\t\treturn status;\n\tgser->in->driver_data = port;\n\n\tstatus = usb_ep_enable(gser->out);\n\tif (status < 0)\n\t\tgoto fail_out;\n\tgser->out->driver_data = port;\n\n\t \n\tspin_lock_irqsave(&port->port_lock, flags);\n\tgser->ioport = port;\n\tport->port_usb = gser;\n\n\t \n\tgser->port_line_coding = port->port_line_coding;\n\n\t \n\n\t \n\tif (port->port.count) {\n\t\tpr_debug(\"gserial_connect: start ttyGS%d\\n\", port->port_num);\n\t\tgs_start_io(port);\n\t\tif (gser->connect)\n\t\t\tgser->connect(gser);\n\t} else {\n\t\tif (gser->disconnect)\n\t\t\tgser->disconnect(gser);\n\t}\n\n\tstatus = gs_console_connect(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn status;\n\nfail_out:\n\tusb_ep_disable(gser->in);\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(gserial_connect);\n \nvoid gserial_disconnect(struct gserial *gser)\n{\n\tstruct gs_port\t*port = gser->ioport;\n\tunsigned long\tflags;\n\n\tif (!port)\n\t\treturn;\n\n\tspin_lock_irqsave(&serial_port_lock, flags);\n\n\t \n\tspin_lock(&port->port_lock);\n\n\tgs_console_disconnect(port);\n\n\t \n\tport->port_line_coding = gser->port_line_coding;\n\n\tport->port_usb = NULL;\n\tgser->ioport = NULL;\n\tif (port->port.count > 0) {\n\t\twake_up_interruptible(&port->drain_wait);\n\t\tif (port->port.tty)\n\t\t\ttty_hangup(port->port.tty);\n\t}\n\tport->suspended = false;\n\tspin_unlock(&port->port_lock);\n\tspin_unlock_irqrestore(&serial_port_lock, flags);\n\n\t \n\tusb_ep_disable(gser->out);\n\tusb_ep_disable(gser->in);\n\n\t \n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (port->port.count == 0)\n\t\tkfifo_free(&port->port_write_buf);\n\tgs_free_requests(gser->out, &port->read_pool, NULL);\n\tgs_free_requests(gser->out, &port->read_queue, NULL);\n\tgs_free_requests(gser->in, &port->write_pool, NULL);\n\n\tport->read_allocated = port->read_started =\n\t\tport->write_allocated = port->write_started = 0;\n\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\nEXPORT_SYMBOL_GPL(gserial_disconnect);\n\nvoid gserial_suspend(struct gserial *gser)\n{\n\tstruct gs_port\t*port;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&serial_port_lock, flags);\n\tport = gser->ioport;\n\n\tif (!port) {\n\t\tspin_unlock_irqrestore(&serial_port_lock, flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&port->port_lock);\n\tspin_unlock(&serial_port_lock);\n\tport->suspended = true;\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\nEXPORT_SYMBOL_GPL(gserial_suspend);\n\nvoid gserial_resume(struct gserial *gser)\n{\n\tstruct gs_port *port;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&serial_port_lock, flags);\n\tport = gser->ioport;\n\n\tif (!port) {\n\t\tspin_unlock_irqrestore(&serial_port_lock, flags);\n\t\treturn;\n\t}\n\n\tspin_lock(&port->port_lock);\n\tspin_unlock(&serial_port_lock);\n\tport->suspended = false;\n\tif (!port->start_delayed) {\n\t\tspin_unlock_irqrestore(&port->port_lock, flags);\n\t\treturn;\n\t}\n\n\tpr_debug(\"delayed start ttyGS%d\\n\", port->port_num);\n\tgs_start_io(port);\n\tif (gser->connect)\n\t\tgser->connect(gser);\n\tport->start_delayed = false;\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\nEXPORT_SYMBOL_GPL(gserial_resume);\n\nstatic int __init userial_init(void)\n{\n\tstruct tty_driver *driver;\n\tunsigned\t\t\ti;\n\tint\t\t\t\tstatus;\n\n\tdriver = tty_alloc_driver(MAX_U_SERIAL_PORTS, TTY_DRIVER_REAL_RAW |\n\t\t\tTTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(driver))\n\t\treturn PTR_ERR(driver);\n\n\tdriver->driver_name = \"g_serial\";\n\tdriver->name = \"ttyGS\";\n\t \n\n\tdriver->type = TTY_DRIVER_TYPE_SERIAL;\n\tdriver->subtype = SERIAL_TYPE_NORMAL;\n\tdriver->init_termios = tty_std_termios;\n\n\t \n\tdriver->init_termios.c_cflag =\n\t\t\tB9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tdriver->init_termios.c_ispeed = 9600;\n\tdriver->init_termios.c_ospeed = 9600;\n\n\ttty_set_operations(driver, &gs_tty_ops);\n\tfor (i = 0; i < MAX_U_SERIAL_PORTS; i++)\n\t\tmutex_init(&ports[i].lock);\n\n\t \n\tstatus = tty_register_driver(driver);\n\tif (status) {\n\t\tpr_err(\"%s: cannot register, err %d\\n\",\n\t\t\t\t__func__, status);\n\t\tgoto fail;\n\t}\n\n\tgs_tty_driver = driver;\n\n\tpr_debug(\"%s: registered %d ttyGS* device%s\\n\", __func__,\n\t\t\tMAX_U_SERIAL_PORTS,\n\t\t\t(MAX_U_SERIAL_PORTS == 1) ? \"\" : \"s\");\n\n\treturn status;\nfail:\n\ttty_driver_kref_put(driver);\n\treturn status;\n}\nmodule_init(userial_init);\n\nstatic void __exit userial_cleanup(void)\n{\n\ttty_unregister_driver(gs_tty_driver);\n\ttty_driver_kref_put(gs_tty_driver);\n\tgs_tty_driver = NULL;\n}\nmodule_exit(userial_cleanup);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}