{
  "module_name": "f_printer.c",
  "hash_id": "051ad0adab342a030cdaeb42d5b7ea7bf57464a2b73add311bd182094baa1afa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_printer.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/idr.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/cdev.h>\n#include <linux/kref.h>\n\n#include <asm/byteorder.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/g_printer.h>\n\n#include \"u_printer.h\"\n\n#define PRINTER_MINORS\t\t4\n#define GET_DEVICE_ID\t\t0\n#define GET_PORT_STATUS\t\t1\n#define SOFT_RESET\t\t2\n\n#define DEFAULT_Q_LEN\t\t10  \n\nstatic int major, minors;\nstatic const struct class usb_gadget_class = {\n\t.name = \"usb_printer_gadget\",\n};\n\nstatic DEFINE_IDA(printer_ida);\nstatic DEFINE_MUTEX(printer_ida_lock);  \n\n \n\nstruct printer_dev {\n\tspinlock_t\t\tlock;\t\t \n\t \n\tstruct mutex\t\tlock_printer_io;\n\tstruct usb_gadget\t*gadget;\n\ts8\t\t\tinterface;\n\tstruct usb_ep\t\t*in_ep, *out_ep;\n\tstruct kref             kref;\n\tstruct list_head\trx_reqs;\t \n\tstruct list_head\trx_reqs_active;\t \n\tstruct list_head\trx_buffers;\t \n\t \n\twait_queue_head_t\trx_wait;\n\tstruct list_head\ttx_reqs;\t \n\tstruct list_head\ttx_reqs_active;  \n\t \n\twait_queue_head_t\ttx_wait;\n\t \n\twait_queue_head_t\ttx_flush_wait;\n\tstruct usb_request\t*current_rx_req;\n\tsize_t\t\t\tcurrent_rx_bytes;\n\tu8\t\t\t*current_rx_buf;\n\tu8\t\t\tprinter_status;\n\tu8\t\t\treset_printer;\n\tint\t\t\tminor;\n\tstruct cdev\t\tprinter_cdev;\n\tu8\t\t\tprinter_cdev_open;\n\twait_queue_head_t\twait;\n\tunsigned\t\tq_len;\n\tchar\t\t\t**pnp_string;\t \n\tstruct usb_function\tfunction;\n};\n\nstatic inline struct printer_dev *func_to_printer(struct usb_function *f)\n{\n\treturn container_of(f, struct printer_dev, function);\n}\n\n \n\n \n\n \n#define USB_DESC_BUFSIZE\t\t256\n#define USB_BUFSIZE\t\t\t8192\n\nstatic struct usb_interface_descriptor intf_desc = {\n\t.bLength =\t\tsizeof(intf_desc),\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_PRINTER,\n\t.bInterfaceSubClass =\t1,\t \n\t.bInterfaceProtocol =\t2,\t \n\t.iInterface =\t\t0\n};\n\nstatic struct usb_endpoint_descriptor fs_ep_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK\n};\n\nstatic struct usb_endpoint_descriptor fs_ep_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK\n};\n\nstatic struct usb_descriptor_header *fs_printer_function[] = {\n\t(struct usb_descriptor_header *) &intf_desc,\n\t(struct usb_descriptor_header *) &fs_ep_in_desc,\n\t(struct usb_descriptor_header *) &fs_ep_out_desc,\n\tNULL\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_ep_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512)\n};\n\nstatic struct usb_endpoint_descriptor hs_ep_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512)\n};\n\nstatic struct usb_descriptor_header *hs_printer_function[] = {\n\t(struct usb_descriptor_header *) &intf_desc,\n\t(struct usb_descriptor_header *) &hs_ep_in_desc,\n\t(struct usb_descriptor_header *) &hs_ep_out_desc,\n\tNULL\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_ep_in_desc = {\n\t.bLength =              USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =      USB_DT_ENDPOINT,\n\t.bmAttributes =         USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =       cpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ep_in_comp_desc = {\n\t.bLength =              sizeof(ss_ep_in_comp_desc),\n\t.bDescriptorType =      USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_endpoint_descriptor ss_ep_out_desc = {\n\t.bLength =              USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =      USB_DT_ENDPOINT,\n\t.bmAttributes =         USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =       cpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_ep_out_comp_desc = {\n\t.bLength =              sizeof(ss_ep_out_comp_desc),\n\t.bDescriptorType =      USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_descriptor_header *ss_printer_function[] = {\n\t(struct usb_descriptor_header *) &intf_desc,\n\t(struct usb_descriptor_header *) &ss_ep_in_desc,\n\t(struct usb_descriptor_header *) &ss_ep_in_comp_desc,\n\t(struct usb_descriptor_header *) &ss_ep_out_desc,\n\t(struct usb_descriptor_header *) &ss_ep_out_comp_desc,\n\tNULL\n};\n\n \nstatic inline struct usb_endpoint_descriptor *ep_desc(struct usb_gadget *gadget,\n\t\t\t\t\tstruct usb_endpoint_descriptor *fs,\n\t\t\t\t\tstruct usb_endpoint_descriptor *hs,\n\t\t\t\t\tstruct usb_endpoint_descriptor *ss)\n{\n\tswitch (gadget->speed) {\n\tcase USB_SPEED_SUPER:\n\t\treturn ss;\n\tcase USB_SPEED_HIGH:\n\t\treturn hs;\n\tdefault:\n\t\treturn fs;\n\t}\n}\n\n \n\nstatic void printer_dev_free(struct kref *kref)\n{\n\tstruct printer_dev *dev = container_of(kref, struct printer_dev, kref);\n\n\tkfree(dev);\n}\n\nstatic struct usb_request *\nprinter_req_alloc(struct usb_ep *ep, unsigned len, gfp_t gfp_flags)\n{\n\tstruct usb_request\t*req;\n\n\treq = usb_ep_alloc_request(ep, gfp_flags);\n\n\tif (req != NULL) {\n\t\treq->length = len;\n\t\treq->buf = kmalloc(len, gfp_flags);\n\t\tif (req->buf == NULL) {\n\t\t\tusb_ep_free_request(ep, req);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn req;\n}\n\nstatic void\nprinter_req_free(struct usb_ep *ep, struct usb_request *req)\n{\n\tif (ep != NULL && req != NULL) {\n\t\tkfree(req->buf);\n\t\tusb_ep_free_request(ep, req);\n\t}\n}\n\n \n\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct printer_dev\t*dev = ep->driver_data;\n\tint\t\t\tstatus = req->status;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tlist_del_init(&req->list);\t \n\n\tswitch (status) {\n\n\t \n\tcase 0:\n\t\tif (req->actual > 0) {\n\t\t\tlist_add_tail(&req->list, &dev->rx_buffers);\n\t\t\tDBG(dev, \"G_Printer : rx length %d\\n\", req->actual);\n\t\t} else {\n\t\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tVDBG(dev, \"rx shutdown, code %d\\n\", status);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\tbreak;\n\n\t \n\tcase -ECONNABORTED:\t\t \n\t\tDBG(dev, \"rx %s reset\\n\", ep->name);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\tbreak;\n\n\t \n\tcase -EOVERFLOW:\n\t\tfallthrough;\n\n\tdefault:\n\t\tDBG(dev, \"rx status %d\\n\", status);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\tbreak;\n\t}\n\n\twake_up_interruptible(&dev->rx_wait);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\nstatic void tx_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct printer_dev\t*dev = ep->driver_data;\n\n\tswitch (req->status) {\n\tdefault:\n\t\tVDBG(dev, \"tx err %d\\n\", req->status);\n\t\tfallthrough;\n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tspin_lock(&dev->lock);\n\t \n\tlist_del_init(&req->list);\n\tlist_add(&req->list, &dev->tx_reqs);\n\twake_up_interruptible(&dev->tx_wait);\n\tif (likely(list_empty(&dev->tx_reqs_active)))\n\t\twake_up_interruptible(&dev->tx_flush_wait);\n\n\tspin_unlock(&dev->lock);\n}\n\n \n\nstatic int\nprinter_open(struct inode *inode, struct file *fd)\n{\n\tstruct printer_dev\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\tret = -EBUSY;\n\n\tdev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!dev->printer_cdev_open) {\n\t\tdev->printer_cdev_open = 1;\n\t\tfd->private_data = dev;\n\t\tret = 0;\n\t\t \n\t\tdev->printer_status |= PRINTER_SELECTED;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tkref_get(&dev->kref);\n\n\treturn ret;\n}\n\nstatic int\nprinter_close(struct inode *inode, struct file *fd)\n{\n\tstruct printer_dev\t*dev = fd->private_data;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->printer_cdev_open = 0;\n\tfd->private_data = NULL;\n\t \n\tdev->printer_status &= ~PRINTER_SELECTED;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tkref_put(&dev->kref, printer_dev_free);\n\n\treturn 0;\n}\n\n \nstatic void\nsetup_rx_reqs(struct printer_dev *dev)\n{\n\tstruct usb_request              *req;\n\n\twhile (likely(!list_empty(&dev->rx_reqs))) {\n\t\tint error;\n\n\t\treq = container_of(dev->rx_reqs.next,\n\t\t\t\tstruct usb_request, list);\n\t\tlist_del_init(&req->list);\n\n\t\t \n\t\treq->length = USB_BUFSIZE;\n\t\treq->complete = rx_complete;\n\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\terror = usb_ep_queue(dev->out_ep, req, GFP_ATOMIC);\n\t\tspin_lock(&dev->lock);\n\t\tif (error) {\n\t\t\tDBG(dev, \"rx submit --> %d\\n\", error);\n\t\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\telse if (list_empty(&req->list))\n\t\t\tlist_add(&req->list, &dev->rx_reqs_active);\n\t}\n}\n\nstatic ssize_t\nprinter_read(struct file *fd, char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct printer_dev\t\t*dev = fd->private_data;\n\tunsigned long\t\t\tflags;\n\tsize_t\t\t\t\tsize;\n\tsize_t\t\t\t\tbytes_copied;\n\tstruct usb_request\t\t*req;\n\t \n\tstruct usb_request\t\t*current_rx_req;\n\t \n\tsize_t\t\t\t\tcurrent_rx_bytes;\n\t \n\tu8\t\t\t\t*current_rx_buf;\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tDBG(dev, \"printer_read trying to read %d bytes\\n\", (int)len);\n\n\tmutex_lock(&dev->lock_printer_io);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tmutex_unlock(&dev->lock_printer_io);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->reset_printer = 0;\n\n\tsetup_rx_reqs(dev);\n\n\tbytes_copied = 0;\n\tcurrent_rx_req = dev->current_rx_req;\n\tcurrent_rx_bytes = dev->current_rx_bytes;\n\tcurrent_rx_buf = dev->current_rx_buf;\n\tdev->current_rx_req = NULL;\n\tdev->current_rx_bytes = 0;\n\tdev->current_rx_buf = NULL;\n\n\t \n\tif ((current_rx_bytes == 0) &&\n\t\t\t(likely(list_empty(&dev->rx_buffers)))) {\n\t\t \n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t \n\t\tif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t \n\t\twait_event_interruptible(dev->rx_wait,\n\t\t\t\t(likely(!list_empty(&dev->rx_buffers))));\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t}\n\n\t \n\twhile ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))\n\t\t\t&& len) {\n\t\tif (current_rx_bytes == 0) {\n\t\t\treq = container_of(dev->rx_buffers.next,\n\t\t\t\t\tstruct usb_request, list);\n\t\t\tlist_del_init(&req->list);\n\n\t\t\tif (req->actual && req->buf) {\n\t\t\t\tcurrent_rx_req = req;\n\t\t\t\tcurrent_rx_bytes = req->actual;\n\t\t\t\tcurrent_rx_buf = req->buf;\n\t\t\t} else {\n\t\t\t\tlist_add(&req->list, &dev->rx_reqs);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tif (len > current_rx_bytes)\n\t\t\tsize = current_rx_bytes;\n\t\telse\n\t\t\tsize = len;\n\n\t\tsize -= copy_to_user(buf, current_rx_buf, size);\n\t\tbytes_copied += size;\n\t\tlen -= size;\n\t\tbuf += size;\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\n\t\t \n\t\tif (dev->reset_printer) {\n\t\t\tlist_add(&current_rx_req->list, &dev->rx_reqs);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t \n\t\tif (size < current_rx_bytes) {\n\t\t\tcurrent_rx_bytes -= size;\n\t\t\tcurrent_rx_buf += size;\n\t\t} else {\n\t\t\tlist_add(&current_rx_req->list, &dev->rx_reqs);\n\t\t\tcurrent_rx_bytes = 0;\n\t\t\tcurrent_rx_buf = NULL;\n\t\t\tcurrent_rx_req = NULL;\n\t\t}\n\t}\n\n\tdev->current_rx_req = current_rx_req;\n\tdev->current_rx_bytes = current_rx_bytes;\n\tdev->current_rx_buf = current_rx_buf;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->lock_printer_io);\n\n\tDBG(dev, \"printer_read returned %d bytes\\n\", (int)bytes_copied);\n\n\tif (bytes_copied)\n\t\treturn bytes_copied;\n\telse\n\t\treturn -EAGAIN;\n}\n\nstatic ssize_t\nprinter_write(struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\n{\n\tstruct printer_dev\t*dev = fd->private_data;\n\tunsigned long\t\tflags;\n\tsize_t\t\t\tsize;\t \n\tsize_t\t\t\tbytes_copied = 0;\n\tstruct usb_request\t*req;\n\tint\t\t\tvalue;\n\n\tDBG(dev, \"printer_write trying to send %d bytes\\n\", (int)len);\n\n\tif (len == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&dev->lock_printer_io);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tmutex_unlock(&dev->lock_printer_io);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev->reset_printer = 0;\n\n\t \n\tif (likely(list_empty(&dev->tx_reqs))) {\n\t\t \n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t \n\t\tif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\t \n\t\twait_event_interruptible(dev->tx_wait,\n\t\t\t\t(likely(!list_empty(&dev->tx_reqs))));\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t}\n\n\twhile (likely(!list_empty(&dev->tx_reqs)) && len) {\n\n\t\tif (len > USB_BUFSIZE)\n\t\t\tsize = USB_BUFSIZE;\n\t\telse\n\t\t\tsize = len;\n\n\t\treq = container_of(dev->tx_reqs.next, struct usb_request,\n\t\t\t\tlist);\n\t\tlist_del_init(&req->list);\n\n\t\treq->complete = tx_complete;\n\t\treq->length = size;\n\n\t\t \n\t\tif (len > size)\n\t\t\t \n\t\t\treq->zero = 0;\n\t\telse\n\t\t\t \n\t\t\treq->zero = ((len % dev->in_ep->maxpacket) == 0);\n\n\t\t \n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\tif (copy_from_user(req->buf, buf, size)) {\n\t\t\tlist_add(&req->list, &dev->tx_reqs);\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn bytes_copied;\n\t\t}\n\n\t\tbytes_copied += size;\n\t\tlen -= size;\n\t\tbuf += size;\n\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\n\t\t \n\t\tif (dev->reset_printer) {\n\t\t\tlist_add(&req->list, &dev->tx_reqs);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tlist_add(&req->list, &dev->tx_reqs_active);\n\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\tvalue = usb_ep_queue(dev->in_ep, req, GFP_ATOMIC);\n\t\tspin_lock(&dev->lock);\n\t\tif (value) {\n\t\t\tlist_move(&req->list, &dev->tx_reqs);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tmutex_unlock(&dev->lock_printer_io);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->lock_printer_io);\n\n\tDBG(dev, \"printer_write sent %d bytes\\n\", (int)bytes_copied);\n\n\tif (bytes_copied)\n\t\treturn bytes_copied;\n\telse\n\t\treturn -EAGAIN;\n}\n\nstatic int\nprinter_fsync(struct file *fd, loff_t start, loff_t end, int datasync)\n{\n\tstruct printer_dev\t*dev = fd->private_data;\n\tstruct inode *inode = file_inode(fd);\n\tunsigned long\t\tflags;\n\tint\t\t\ttx_list_empty;\n\n\tinode_lock(inode);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tinode_unlock(inode);\n\t\treturn -ENODEV;\n\t}\n\n\ttx_list_empty = (likely(list_empty(&dev->tx_reqs)));\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (!tx_list_empty) {\n\t\t \n\t\twait_event_interruptible(dev->tx_flush_wait,\n\t\t\t\t(likely(list_empty(&dev->tx_reqs_active))));\n\t}\n\tinode_unlock(inode);\n\n\treturn 0;\n}\n\nstatic __poll_t\nprinter_poll(struct file *fd, poll_table *wait)\n{\n\tstruct printer_dev\t*dev = fd->private_data;\n\tunsigned long\t\tflags;\n\t__poll_t\t\tstatus = 0;\n\n\tmutex_lock(&dev->lock_printer_io);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tmutex_unlock(&dev->lock_printer_io);\n\t\treturn EPOLLERR | EPOLLHUP;\n\t}\n\n\tsetup_rx_reqs(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->lock_printer_io);\n\n\tpoll_wait(fd, &dev->rx_wait, wait);\n\tpoll_wait(fd, &dev->tx_wait, wait);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (likely(!list_empty(&dev->tx_reqs)))\n\t\tstatus |= EPOLLOUT | EPOLLWRNORM;\n\n\tif (likely(dev->current_rx_bytes) ||\n\t\t\tlikely(!list_empty(&dev->rx_buffers)))\n\t\tstatus |= EPOLLIN | EPOLLRDNORM;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn status;\n}\n\nstatic long\nprinter_ioctl(struct file *fd, unsigned int code, unsigned long arg)\n{\n\tstruct printer_dev\t*dev = fd->private_data;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus = 0;\n\n\tDBG(dev, \"printer_ioctl: cmd=0x%4.4x, arg=%lu\\n\", code, arg);\n\n\t \n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->interface < 0) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (code) {\n\tcase GADGET_GET_PRINTER_STATUS:\n\t\tstatus = (int)dev->printer_status;\n\t\tbreak;\n\tcase GADGET_SET_PRINTER_STATUS:\n\t\tdev->printer_status = (u8)arg;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tDBG(dev, \"printer_ioctl: ERROR cmd=0x%4.4xis not supported\\n\",\n\t\t\t\tcode);\n\t\tstatus = -ENOTTY;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn status;\n}\n\n \nstatic const struct file_operations printer_io_operations = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tprinter_open,\n\t.read =\t\tprinter_read,\n\t.write =\tprinter_write,\n\t.fsync =\tprinter_fsync,\n\t.poll =\t\tprinter_poll,\n\t.unlocked_ioctl = printer_ioctl,\n\t.release =\tprinter_close,\n\t.llseek =\tnoop_llseek,\n};\n\n \n\nstatic int\nset_printer_interface(struct printer_dev *dev)\n{\n\tint\t\t\tresult = 0;\n\n\tdev->in_ep->desc = ep_desc(dev->gadget, &fs_ep_in_desc, &hs_ep_in_desc,\n\t\t\t\t&ss_ep_in_desc);\n\tdev->in_ep->driver_data = dev;\n\n\tdev->out_ep->desc = ep_desc(dev->gadget, &fs_ep_out_desc,\n\t\t\t\t    &hs_ep_out_desc, &ss_ep_out_desc);\n\tdev->out_ep->driver_data = dev;\n\n\tresult = usb_ep_enable(dev->in_ep);\n\tif (result != 0) {\n\t\tDBG(dev, \"enable %s --> %d\\n\", dev->in_ep->name, result);\n\t\tgoto done;\n\t}\n\n\tresult = usb_ep_enable(dev->out_ep);\n\tif (result != 0) {\n\t\tDBG(dev, \"enable %s --> %d\\n\", dev->out_ep->name, result);\n\t\tgoto done;\n\t}\n\ndone:\n\t \n\tif (result != 0) {\n\t\t(void) usb_ep_disable(dev->in_ep);\n\t\t(void) usb_ep_disable(dev->out_ep);\n\t\tdev->in_ep->desc = NULL;\n\t\tdev->out_ep->desc = NULL;\n\t}\n\n\t \n\treturn result;\n}\n\nstatic void printer_reset_interface(struct printer_dev *dev)\n{\n\tunsigned long\tflags;\n\n\tif (dev->interface < 0)\n\t\treturn;\n\n\tif (dev->in_ep->desc)\n\t\tusb_ep_disable(dev->in_ep);\n\n\tif (dev->out_ep->desc)\n\t\tusb_ep_disable(dev->out_ep);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->in_ep->desc = NULL;\n\tdev->out_ep->desc = NULL;\n\tdev->interface = -1;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n}\n\n \nstatic int set_interface(struct printer_dev *dev, unsigned number)\n{\n\tint\t\t\tresult = 0;\n\n\t \n\tprinter_reset_interface(dev);\n\n\tresult = set_printer_interface(dev);\n\tif (result)\n\t\tprinter_reset_interface(dev);\n\telse\n\t\tdev->interface = number;\n\n\tif (!result)\n\t\tINFO(dev, \"Using interface %x\\n\", number);\n\n\treturn result;\n}\n\nstatic void printer_soft_reset(struct printer_dev *dev)\n{\n\tstruct usb_request\t*req;\n\n\tif (usb_ep_disable(dev->in_ep))\n\t\tDBG(dev, \"Failed to disable USB in_ep\\n\");\n\tif (usb_ep_disable(dev->out_ep))\n\t\tDBG(dev, \"Failed to disable USB out_ep\\n\");\n\n\tif (dev->current_rx_req != NULL) {\n\t\tlist_add(&dev->current_rx_req->list, &dev->rx_reqs);\n\t\tdev->current_rx_req = NULL;\n\t}\n\tdev->current_rx_bytes = 0;\n\tdev->current_rx_buf = NULL;\n\tdev->reset_printer = 1;\n\n\twhile (likely(!(list_empty(&dev->rx_buffers)))) {\n\t\treq = container_of(dev->rx_buffers.next, struct usb_request,\n\t\t\t\tlist);\n\t\tlist_del_init(&req->list);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t}\n\n\twhile (likely(!(list_empty(&dev->rx_reqs_active)))) {\n\t\treq = container_of(dev->rx_buffers.next, struct usb_request,\n\t\t\t\tlist);\n\t\tlist_del_init(&req->list);\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t}\n\n\twhile (likely(!(list_empty(&dev->tx_reqs_active)))) {\n\t\treq = container_of(dev->tx_reqs_active.next,\n\t\t\t\tstruct usb_request, list);\n\t\tlist_del_init(&req->list);\n\t\tlist_add(&req->list, &dev->tx_reqs);\n\t}\n\n\tif (usb_ep_enable(dev->in_ep))\n\t\tDBG(dev, \"Failed to enable USB in_ep\\n\");\n\tif (usb_ep_enable(dev->out_ep))\n\t\tDBG(dev, \"Failed to enable USB out_ep\\n\");\n\n\twake_up_interruptible(&dev->rx_wait);\n\twake_up_interruptible(&dev->tx_wait);\n\twake_up_interruptible(&dev->tx_flush_wait);\n}\n\n \n\nstatic bool gprinter_req_match(struct usb_function *f,\n\t\t\t       const struct usb_ctrlrequest *ctrl,\n\t\t\t       bool config0)\n{\n\tstruct printer_dev\t*dev = func_to_printer(f);\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\tif (config0)\n\t\treturn false;\n\n\tif ((ctrl->bRequestType & USB_RECIP_MASK) != USB_RECIP_INTERFACE ||\n\t    (ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\n\t\treturn false;\n\n\tswitch (ctrl->bRequest) {\n\tcase GET_DEVICE_ID:\n\t\tw_index >>= 8;\n\t\tif (USB_DIR_IN & ctrl->bRequestType)\n\t\t\tbreak;\n\t\treturn false;\n\tcase GET_PORT_STATUS:\n\t\tif (!w_value && w_length == 1 &&\n\t\t    (USB_DIR_IN & ctrl->bRequestType))\n\t\t\tbreak;\n\t\treturn false;\n\tcase SOFT_RESET:\n\t\tif (!w_value && !w_length &&\n\t\t   !(USB_DIR_IN & ctrl->bRequestType))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\treturn false;\n\t}\n\treturn w_index == dev->interface;\n}\n\n \nstatic int printer_func_setup(struct usb_function *f,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tu8\t\t\t*buf = req->buf;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\twIndex = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\twValue = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\twLength = le16_to_cpu(ctrl->wLength);\n\n\tDBG(dev, \"ctrl req%02x.%02x v%04x i%04x l%d\\n\",\n\t\tctrl->bRequestType, ctrl->bRequest, wValue, wIndex, wLength);\n\n\tswitch (ctrl->bRequestType&USB_TYPE_MASK) {\n\tcase USB_TYPE_CLASS:\n\t\tswitch (ctrl->bRequest) {\n\t\tcase GET_DEVICE_ID:  \n\t\t\t \n\t\t\tif ((wIndex>>8) != dev->interface)\n\t\t\t\tbreak;\n\n\t\t\tif (!*dev->pnp_string) {\n\t\t\t\tvalue = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue = strlen(*dev->pnp_string);\n\t\t\tbuf[0] = (value >> 8) & 0xFF;\n\t\t\tbuf[1] = value & 0xFF;\n\t\t\tmemcpy(buf + 2, *dev->pnp_string, value);\n\t\t\tDBG(dev, \"1284 PNP String: %x %s\\n\", value,\n\t\t\t    *dev->pnp_string);\n\t\t\tbreak;\n\n\t\tcase GET_PORT_STATUS:  \n\t\t\t \n\t\t\tif (wIndex != dev->interface)\n\t\t\t\tbreak;\n\n\t\t\tbuf[0] = dev->printer_status;\n\t\t\tvalue = min_t(u16, wLength, 1);\n\t\t\tbreak;\n\n\t\tcase SOFT_RESET:  \n\t\t\t \n\t\t\tif (wIndex != dev->interface)\n\t\t\t\tbreak;\n\n\t\t\tprinter_soft_reset(dev);\n\n\t\t\tvalue = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto unknown;\n\t\t}\n\t\tbreak;\n\n\tdefault:\nunknown:\n\t\tVDBG(dev,\n\t\t\t\"unknown ctrl req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tctrl->bRequestType, ctrl->bRequest,\n\t\t\twValue, wIndex, wLength);\n\t\tbreak;\n\t}\n\t \n\tif (value >= 0) {\n\t\treq->length = value;\n\t\treq->zero = value < wLength;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0) {\n\t\t\tERROR(dev, \"%s:%d Error!\\n\", __func__, __LINE__);\n\t\t\treq->status = 0;\n\t\t}\n\t}\n\treturn value;\n}\n\nstatic int printer_func_bind(struct usb_configuration *c,\n\t\tstruct usb_function *f)\n{\n\tstruct usb_gadget *gadget = c->cdev->gadget;\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct device *pdev;\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct usb_ep *in_ep;\n\tstruct usb_ep *out_ep = NULL;\n\tstruct usb_request *req;\n\tdev_t devt;\n\tint id;\n\tint ret;\n\tu32 i;\n\n\tid = usb_interface_id(c, f);\n\tif (id < 0)\n\t\treturn id;\n\tintf_desc.bInterfaceNumber = id;\n\n\t \n\tdev->gadget = gadget;\n\n\t \n\tin_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_in_desc);\n\tif (!in_ep) {\nautoconf_fail:\n\t\tdev_err(&cdev->gadget->dev, \"can't autoconfigure on %s\\n\",\n\t\t\tcdev->gadget->name);\n\t\treturn -ENODEV;\n\t}\n\n\tout_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_out_desc);\n\tif (!out_ep)\n\t\tgoto autoconf_fail;\n\n\t \n\ths_ep_in_desc.bEndpointAddress = fs_ep_in_desc.bEndpointAddress;\n\ths_ep_out_desc.bEndpointAddress = fs_ep_out_desc.bEndpointAddress;\n\tss_ep_in_desc.bEndpointAddress = fs_ep_in_desc.bEndpointAddress;\n\tss_ep_out_desc.bEndpointAddress = fs_ep_out_desc.bEndpointAddress;\n\n\tret = usb_assign_descriptors(f, fs_printer_function,\n\t\t\ths_printer_function, ss_printer_function,\n\t\t\tss_printer_function);\n\tif (ret)\n\t\treturn ret;\n\n\tdev->in_ep = in_ep;\n\tdev->out_ep = out_ep;\n\n\tret = -ENOMEM;\n\tfor (i = 0; i < dev->q_len; i++) {\n\t\treq = printer_req_alloc(dev->in_ep, USB_BUFSIZE, GFP_KERNEL);\n\t\tif (!req)\n\t\t\tgoto fail_tx_reqs;\n\t\tlist_add(&req->list, &dev->tx_reqs);\n\t}\n\n\tfor (i = 0; i < dev->q_len; i++) {\n\t\treq = printer_req_alloc(dev->out_ep, USB_BUFSIZE, GFP_KERNEL);\n\t\tif (!req)\n\t\t\tgoto fail_rx_reqs;\n\t\tlist_add(&req->list, &dev->rx_reqs);\n\t}\n\n\t \n\tdevt = MKDEV(major, dev->minor);\n\tpdev = device_create(&usb_gadget_class, NULL, devt,\n\t\t\t\t  NULL, \"g_printer%d\", dev->minor);\n\tif (IS_ERR(pdev)) {\n\t\tERROR(dev, \"Failed to create device: g_printer\\n\");\n\t\tret = PTR_ERR(pdev);\n\t\tgoto fail_rx_reqs;\n\t}\n\n\t \n\tcdev_init(&dev->printer_cdev, &printer_io_operations);\n\tdev->printer_cdev.owner = THIS_MODULE;\n\tret = cdev_add(&dev->printer_cdev, devt, 1);\n\tif (ret) {\n\t\tERROR(dev, \"Failed to open char device\\n\");\n\t\tgoto fail_cdev_add;\n\t}\n\n\treturn 0;\n\nfail_cdev_add:\n\tdevice_destroy(&usb_gadget_class, devt);\n\nfail_rx_reqs:\n\twhile (!list_empty(&dev->rx_reqs)) {\n\t\treq = container_of(dev->rx_reqs.next, struct usb_request, list);\n\t\tlist_del(&req->list);\n\t\tprinter_req_free(dev->out_ep, req);\n\t}\n\nfail_tx_reqs:\n\twhile (!list_empty(&dev->tx_reqs)) {\n\t\treq = container_of(dev->tx_reqs.next, struct usb_request, list);\n\t\tlist_del(&req->list);\n\t\tprinter_req_free(dev->in_ep, req);\n\t}\n\n\tusb_free_all_descriptors(f);\n\treturn ret;\n\n}\n\nstatic int printer_func_set_alt(struct usb_function *f,\n\t\tunsigned intf, unsigned alt)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tint ret = -ENOTSUPP;\n\n\tif (!alt)\n\t\tret = set_interface(dev, intf);\n\n\treturn ret;\n}\n\nstatic void printer_func_disable(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\n\tprinter_reset_interface(dev);\n}\n\nstatic inline struct f_printer_opts\n*to_f_printer_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_printer_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void printer_attr_release(struct config_item *item)\n{\n\tstruct f_printer_opts *opts = to_f_printer_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations printer_item_ops = {\n\t.release\t= printer_attr_release,\n};\n\nstatic ssize_t f_printer_opts_pnp_string_show(struct config_item *item,\n\t\t\t\t\t      char *page)\n{\n\tstruct f_printer_opts *opts = to_f_printer_opts(item);\n\tint result = 0;\n\n\tmutex_lock(&opts->lock);\n\tif (!opts->pnp_string)\n\t\tgoto unlock;\n\n\tresult = strscpy(page, opts->pnp_string, PAGE_SIZE);\n\tif (result < 1) {\n\t\tresult = PAGE_SIZE;\n\t} else if (page[result - 1] != '\\n' && result + 1 < PAGE_SIZE) {\n\t\tpage[result++] = '\\n';\n\t\tpage[result] = '\\0';\n\t}\n\nunlock:\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_printer_opts_pnp_string_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t len)\n{\n\tstruct f_printer_opts *opts = to_f_printer_opts(item);\n\tchar *new_pnp;\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\n\tnew_pnp = kstrndup(page, len, GFP_KERNEL);\n\tif (!new_pnp) {\n\t\tresult = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tif (opts->pnp_string_allocated)\n\t\tkfree(opts->pnp_string);\n\n\topts->pnp_string_allocated = true;\n\topts->pnp_string = new_pnp;\n\tresult = len;\nunlock:\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nCONFIGFS_ATTR(f_printer_opts_, pnp_string);\n\nstatic ssize_t f_printer_opts_q_len_show(struct config_item *item,\n\t\t\t\t\t char *page)\n{\n\tstruct f_printer_opts *opts = to_f_printer_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%d\\n\", opts->q_len);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_printer_opts_q_len_store(struct config_item *item,\n\t\t\t\t\t  const char *page, size_t len)\n{\n\tstruct f_printer_opts *opts = to_f_printer_opts(item);\n\tint ret;\n\tu16 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou16(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->q_len = (unsigned)num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_printer_opts_, q_len);\n\nstatic struct configfs_attribute *printer_attrs[] = {\n\t&f_printer_opts_attr_pnp_string,\n\t&f_printer_opts_attr_q_len,\n\tNULL,\n};\n\nstatic const struct config_item_type printer_func_type = {\n\t.ct_item_ops\t= &printer_item_ops,\n\t.ct_attrs\t= printer_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic inline int gprinter_get_minor(void)\n{\n\tint ret;\n\n\tret = ida_simple_get(&printer_ida, 0, 0, GFP_KERNEL);\n\tif (ret >= PRINTER_MINORS) {\n\t\tida_simple_remove(&printer_ida, ret);\n\t\tret = -ENODEV;\n\t}\n\n\treturn ret;\n}\n\nstatic inline void gprinter_put_minor(int minor)\n{\n\tida_simple_remove(&printer_ida, minor);\n}\n\nstatic int gprinter_setup(int);\nstatic void gprinter_cleanup(void);\n\nstatic void gprinter_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f, struct f_printer_opts, func_inst);\n\n\tmutex_lock(&printer_ida_lock);\n\n\tgprinter_put_minor(opts->minor);\n\tif (ida_is_empty(&printer_ida))\n\t\tgprinter_cleanup();\n\n\tmutex_unlock(&printer_ida_lock);\n\n\tif (opts->pnp_string_allocated)\n\t\tkfree(opts->pnp_string);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *gprinter_alloc_inst(void)\n{\n\tstruct f_printer_opts *opts;\n\tstruct usb_function_instance *ret;\n\tint status = 0;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = gprinter_free_inst;\n\tret = &opts->func_inst;\n\n\t \n\topts->q_len = DEFAULT_Q_LEN;\n\n\tmutex_lock(&printer_ida_lock);\n\n\tif (ida_is_empty(&printer_ida)) {\n\t\tstatus = gprinter_setup(PRINTER_MINORS);\n\t\tif (status) {\n\t\t\tret = ERR_PTR(status);\n\t\t\tkfree(opts);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\topts->minor = gprinter_get_minor();\n\tif (opts->minor < 0) {\n\t\tret = ERR_PTR(opts->minor);\n\t\tkfree(opts);\n\t\tif (ida_is_empty(&printer_ida))\n\t\t\tgprinter_cleanup();\n\t\tgoto unlock;\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &printer_func_type);\n\nunlock:\n\tmutex_unlock(&printer_ida_lock);\n\treturn ret;\n}\n\nstatic void gprinter_free(struct usb_function *f)\n{\n\tstruct printer_dev *dev = func_to_printer(f);\n\tstruct f_printer_opts *opts;\n\n\topts = container_of(f->fi, struct f_printer_opts, func_inst);\n\n\tkref_put(&dev->kref, printer_dev_free);\n\tmutex_lock(&opts->lock);\n\t--opts->refcnt;\n\tmutex_unlock(&opts->lock);\n}\n\nstatic void printer_func_unbind(struct usb_configuration *c,\n\t\tstruct usb_function *f)\n{\n\tstruct printer_dev\t*dev;\n\tstruct usb_request\t*req;\n\n\tdev = func_to_printer(f);\n\n\tdevice_destroy(&usb_gadget_class, MKDEV(major, dev->minor));\n\n\t \n\tcdev_del(&dev->printer_cdev);\n\n\t \n\tWARN_ON(!list_empty(&dev->tx_reqs_active));\n\tWARN_ON(!list_empty(&dev->rx_reqs_active));\n\n\t \n\twhile (!list_empty(&dev->tx_reqs)) {\n\t\treq = container_of(dev->tx_reqs.next, struct usb_request,\n\t\t\t\tlist);\n\t\tlist_del(&req->list);\n\t\tprinter_req_free(dev->in_ep, req);\n\t}\n\n\tif (dev->current_rx_req != NULL)\n\t\tprinter_req_free(dev->out_ep, dev->current_rx_req);\n\n\twhile (!list_empty(&dev->rx_reqs)) {\n\t\treq = container_of(dev->rx_reqs.next,\n\t\t\t\tstruct usb_request, list);\n\t\tlist_del(&req->list);\n\t\tprinter_req_free(dev->out_ep, req);\n\t}\n\n\twhile (!list_empty(&dev->rx_buffers)) {\n\t\treq = container_of(dev->rx_buffers.next,\n\t\t\t\tstruct usb_request, list);\n\t\tlist_del(&req->list);\n\t\tprinter_req_free(dev->out_ep, req);\n\t}\n\tusb_free_all_descriptors(f);\n}\n\nstatic struct usb_function *gprinter_alloc(struct usb_function_instance *fi)\n{\n\tstruct printer_dev\t*dev;\n\tstruct f_printer_opts\t*opts;\n\n\topts = container_of(fi, struct f_printer_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\tif (opts->minor >= minors) {\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tmutex_unlock(&opts->lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tkref_init(&dev->kref);\n\t++opts->refcnt;\n\tdev->minor = opts->minor;\n\tdev->pnp_string = &opts->pnp_string;\n\tdev->q_len = opts->q_len;\n\tmutex_unlock(&opts->lock);\n\n\tdev->function.name = \"printer\";\n\tdev->function.bind = printer_func_bind;\n\tdev->function.setup = printer_func_setup;\n\tdev->function.unbind = printer_func_unbind;\n\tdev->function.set_alt = printer_func_set_alt;\n\tdev->function.disable = printer_func_disable;\n\tdev->function.req_match = gprinter_req_match;\n\tdev->function.free_func = gprinter_free;\n\n\tINIT_LIST_HEAD(&dev->tx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_reqs);\n\tINIT_LIST_HEAD(&dev->rx_buffers);\n\tINIT_LIST_HEAD(&dev->tx_reqs_active);\n\tINIT_LIST_HEAD(&dev->rx_reqs_active);\n\n\tspin_lock_init(&dev->lock);\n\tmutex_init(&dev->lock_printer_io);\n\tinit_waitqueue_head(&dev->rx_wait);\n\tinit_waitqueue_head(&dev->tx_wait);\n\tinit_waitqueue_head(&dev->tx_flush_wait);\n\n\tdev->interface = -1;\n\tdev->printer_cdev_open = 0;\n\tdev->printer_status = PRINTER_NOT_ERROR;\n\tdev->current_rx_req = NULL;\n\tdev->current_rx_bytes = 0;\n\tdev->current_rx_buf = NULL;\n\n\treturn &dev->function;\n}\n\nDECLARE_USB_FUNCTION_INIT(printer, gprinter_alloc_inst, gprinter_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Craig Nadler\");\n\nstatic int gprinter_setup(int count)\n{\n\tint status;\n\tdev_t devt;\n\n\tstatus = class_register(&usb_gadget_class);\n\tif (status)\n\t\treturn status;\n\n\tstatus = alloc_chrdev_region(&devt, 0, count, \"USB printer gadget\");\n\tif (status) {\n\t\tpr_err(\"alloc_chrdev_region %d\\n\", status);\n\t\tclass_unregister(&usb_gadget_class);\n\t\treturn status;\n\t}\n\n\tmajor = MAJOR(devt);\n\tminors = count;\n\n\treturn status;\n}\n\nstatic void gprinter_cleanup(void)\n{\n\tif (major) {\n\t\tunregister_chrdev_region(MKDEV(major, 0), minors);\n\t\tmajor = minors = 0;\n\t}\n\tclass_unregister(&usb_gadget_class);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}