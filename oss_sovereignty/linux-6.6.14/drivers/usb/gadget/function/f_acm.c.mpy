{
  "module_name": "f_acm.c",
  "hash_id": "28b72a2a6b8c9588ebc90d09a2af4a52f0c1d88f38e578fa94c00fbd5c2eb974",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_acm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/err.h>\n\n#include \"u_serial.h\"\n\n\n \n\nstruct f_acm {\n\tstruct gserial\t\t\tport;\n\tu8\t\t\t\tctrl_id, data_id;\n\tu8\t\t\t\tport_num;\n\n\tu8\t\t\t\tpending;\n\n\t \n\tspinlock_t\t\t\tlock;\n\n\tstruct usb_ep\t\t\t*notify;\n\tstruct usb_request\t\t*notify_req;\n\n\tstruct usb_cdc_line_coding\tport_line_coding;\t \n\n\t \n\tu16\t\t\t\tport_handshake_bits;\n\t \n\tu16\t\t\t\tserial_state;\n};\n\nstatic inline struct f_acm *func_to_acm(struct usb_function *f)\n{\n\treturn container_of(f, struct f_acm, port.func);\n}\n\nstatic inline struct f_acm *port_to_acm(struct gserial *p)\n{\n\treturn container_of(p, struct f_acm, port);\n}\n\n \n\n \n\n#define GS_NOTIFY_INTERVAL_MS\t\t32\n#define GS_NOTIFY_MAXPACKET\t\t10\t \n\n \n\nstatic struct usb_interface_assoc_descriptor\nacm_iad_descriptor = {\n\t.bLength =\t\tsizeof acm_iad_descriptor,\n\t.bDescriptorType =\tUSB_DT_INTERFACE_ASSOCIATION,\n\n\t \n\t.bInterfaceCount = \t2,\t \n\t.bFunctionClass =\tUSB_CLASS_COMM,\n\t.bFunctionSubClass =\tUSB_CDC_SUBCLASS_ACM,\n\t.bFunctionProtocol =\tUSB_CDC_ACM_PROTO_AT_V25TER,\n\t \n};\n\n\nstatic struct usb_interface_descriptor acm_control_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t.bNumEndpoints =\t1,\n\t.bInterfaceClass =\tUSB_CLASS_COMM,\n\t.bInterfaceSubClass =\tUSB_CDC_SUBCLASS_ACM,\n\t.bInterfaceProtocol =\tUSB_CDC_ACM_PROTO_AT_V25TER,\n\t \n};\n\nstatic struct usb_interface_descriptor acm_data_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_CDC_DATA,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\nstatic struct usb_cdc_header_desc acm_header_desc = {\n\t.bLength =\t\tsizeof(acm_header_desc),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_HEADER_TYPE,\n\t.bcdCDC =\t\tcpu_to_le16(0x0110),\n};\n\nstatic struct usb_cdc_call_mgmt_descriptor\nacm_call_mgmt_descriptor = {\n\t.bLength =\t\tsizeof(acm_call_mgmt_descriptor),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_CALL_MANAGEMENT_TYPE,\n\t.bmCapabilities =\t0,\n\t \n};\n\nstatic struct usb_cdc_acm_descriptor acm_descriptor = {\n\t.bLength =\t\tsizeof(acm_descriptor),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_ACM_TYPE,\n\t.bmCapabilities =\tUSB_CDC_CAP_LINE,\n};\n\nstatic struct usb_cdc_union_desc acm_union_desc = {\n\t.bLength =\t\tsizeof(acm_union_desc),\n\t.bDescriptorType =\tUSB_DT_CS_INTERFACE,\n\t.bDescriptorSubType =\tUSB_CDC_UNION_TYPE,\n\t \n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor acm_fs_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(GS_NOTIFY_MAXPACKET),\n\t.bInterval =\t\tGS_NOTIFY_INTERVAL_MS,\n};\n\nstatic struct usb_endpoint_descriptor acm_fs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor acm_fs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *acm_fs_function[] = {\n\t(struct usb_descriptor_header *) &acm_iad_descriptor,\n\t(struct usb_descriptor_header *) &acm_control_interface_desc,\n\t(struct usb_descriptor_header *) &acm_header_desc,\n\t(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &acm_descriptor,\n\t(struct usb_descriptor_header *) &acm_union_desc,\n\t(struct usb_descriptor_header *) &acm_fs_notify_desc,\n\t(struct usb_descriptor_header *) &acm_data_interface_desc,\n\t(struct usb_descriptor_header *) &acm_fs_in_desc,\n\t(struct usb_descriptor_header *) &acm_fs_out_desc,\n\tNULL,\n};\n\n \nstatic struct usb_endpoint_descriptor acm_hs_notify_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_INT,\n\t.wMaxPacketSize =\tcpu_to_le16(GS_NOTIFY_MAXPACKET),\n\t.bInterval =\t\tUSB_MS_TO_HS_INTERVAL(GS_NOTIFY_INTERVAL_MS),\n};\n\nstatic struct usb_endpoint_descriptor acm_hs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor acm_hs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *acm_hs_function[] = {\n\t(struct usb_descriptor_header *) &acm_iad_descriptor,\n\t(struct usb_descriptor_header *) &acm_control_interface_desc,\n\t(struct usb_descriptor_header *) &acm_header_desc,\n\t(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &acm_descriptor,\n\t(struct usb_descriptor_header *) &acm_union_desc,\n\t(struct usb_descriptor_header *) &acm_hs_notify_desc,\n\t(struct usb_descriptor_header *) &acm_data_interface_desc,\n\t(struct usb_descriptor_header *) &acm_hs_in_desc,\n\t(struct usb_descriptor_header *) &acm_hs_out_desc,\n\tNULL,\n};\n\nstatic struct usb_endpoint_descriptor acm_ss_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor acm_ss_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor acm_ss_bulk_comp_desc = {\n\t.bLength =              sizeof acm_ss_bulk_comp_desc,\n\t.bDescriptorType =      USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_descriptor_header *acm_ss_function[] = {\n\t(struct usb_descriptor_header *) &acm_iad_descriptor,\n\t(struct usb_descriptor_header *) &acm_control_interface_desc,\n\t(struct usb_descriptor_header *) &acm_header_desc,\n\t(struct usb_descriptor_header *) &acm_call_mgmt_descriptor,\n\t(struct usb_descriptor_header *) &acm_descriptor,\n\t(struct usb_descriptor_header *) &acm_union_desc,\n\t(struct usb_descriptor_header *) &acm_hs_notify_desc,\n\t(struct usb_descriptor_header *) &acm_ss_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &acm_data_interface_desc,\n\t(struct usb_descriptor_header *) &acm_ss_in_desc,\n\t(struct usb_descriptor_header *) &acm_ss_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &acm_ss_out_desc,\n\t(struct usb_descriptor_header *) &acm_ss_bulk_comp_desc,\n\tNULL,\n};\n\n \n\n#define ACM_CTRL_IDX\t0\n#define ACM_DATA_IDX\t1\n#define ACM_IAD_IDX\t2\n\n \nstatic struct usb_string acm_string_defs[] = {\n\t[ACM_CTRL_IDX].s = \"CDC Abstract Control Model (ACM)\",\n\t[ACM_DATA_IDX].s = \"CDC ACM Data\",\n\t[ACM_IAD_IDX ].s = \"CDC Serial\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings acm_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\tacm_string_defs,\n};\n\nstatic struct usb_gadget_strings *acm_strings[] = {\n\t&acm_string_table,\n\tNULL,\n};\n\n \n\n \n\nstatic void acm_complete_set_line_coding(struct usb_ep *ep,\n\t\tstruct usb_request *req)\n{\n\tstruct f_acm\t*acm = ep->driver_data;\n\tstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\n\n\tif (req->status != 0) {\n\t\tdev_dbg(&cdev->gadget->dev, \"acm ttyGS%d completion, err %d\\n\",\n\t\t\tacm->port_num, req->status);\n\t\treturn;\n\t}\n\n\t \n\tif (req->actual != sizeof(acm->port_line_coding)) {\n\t\tdev_dbg(&cdev->gadget->dev, \"acm ttyGS%d short resp, len %d\\n\",\n\t\t\tacm->port_num, req->actual);\n\t\tusb_ep_set_halt(ep);\n\t} else {\n\t\tstruct usb_cdc_line_coding\t*value = req->buf;\n\n\t\t \n\t\tacm->port_line_coding = *value;\n\t}\n}\n\nstatic int acm_send_break(struct gserial *port, int duration);\n\nstatic int acm_setup(struct usb_function *f, const struct usb_ctrlrequest *ctrl)\n{\n\tstruct f_acm\t\t*acm = func_to_acm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\tstruct usb_request\t*req = cdev->req;\n\tint\t\t\tvalue = -EOPNOTSUPP;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\t \n\tswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\n\n\t \n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_REQ_SET_LINE_CODING:\n\t\tif (w_length != sizeof(struct usb_cdc_line_coding)\n\t\t\t\t|| w_index != acm->ctrl_id)\n\t\t\tgoto invalid;\n\n\t\tvalue = w_length;\n\t\tcdev->gadget->ep0->driver_data = acm;\n\t\treq->complete = acm_complete_set_line_coding;\n\t\tbreak;\n\n\t \n\tcase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_REQ_GET_LINE_CODING:\n\t\tif (w_index != acm->ctrl_id)\n\t\t\tgoto invalid;\n\n\t\tvalue = min_t(unsigned, w_length,\n\t\t\t\tsizeof(struct usb_cdc_line_coding));\n\t\tmemcpy(req->buf, &acm->port_line_coding, value);\n\t\tbreak;\n\n\t \n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_REQ_SET_CONTROL_LINE_STATE:\n\t\tif (w_index != acm->ctrl_id)\n\t\t\tgoto invalid;\n\n\t\tvalue = 0;\n\n\t\t \n\t\tacm->port_handshake_bits = w_value;\n\t\tbreak;\n\n\tcase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_CDC_REQ_SEND_BREAK:\n\t\tif (w_index != acm->ctrl_id)\n\t\t\tgoto invalid;\n\n\t\tacm_send_break(&acm->port, w_value);\n\t\tbreak;\n\n\tdefault:\ninvalid:\n\t\tdev_vdbg(&cdev->gadget->dev,\n\t\t\t \"invalid control req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\t ctrl->bRequestType, ctrl->bRequest,\n\t\t\t w_value, w_index, w_length);\n\t}\n\n\t \n\tif (value >= 0) {\n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"acm ttyGS%d req%02x.%02x v%04x i%04x l%d\\n\",\n\t\t\tacm->port_num, ctrl->bRequestType, ctrl->bRequest,\n\t\t\tw_value, w_index, w_length);\n\t\treq->zero = 0;\n\t\treq->length = value;\n\t\tvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\n\t\tif (value < 0)\n\t\t\tERROR(cdev, \"acm response on ttyGS%d, err %d\\n\",\n\t\t\t\t\tacm->port_num, value);\n\t}\n\n\t \n\treturn value;\n}\n\nstatic int acm_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_acm\t\t*acm = func_to_acm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\n\tif (intf == acm->ctrl_id) {\n\t\tif (acm->notify->enabled) {\n\t\t\tdev_vdbg(&cdev->gadget->dev,\n\t\t\t\t\t\"reset acm control interface %d\\n\", intf);\n\t\t\tusb_ep_disable(acm->notify);\n\t\t}\n\n\t\tif (!acm->notify->desc)\n\t\t\tif (config_ep_by_speed(cdev->gadget, f, acm->notify))\n\t\t\t\treturn -EINVAL;\n\n\t\tusb_ep_enable(acm->notify);\n\n\t} else if (intf == acm->data_id) {\n\t\tif (acm->notify->enabled) {\n\t\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\t\"reset acm ttyGS%d\\n\", acm->port_num);\n\t\t\tgserial_disconnect(&acm->port);\n\t\t}\n\t\tif (!acm->port.in->desc || !acm->port.out->desc) {\n\t\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\t\"activate acm ttyGS%d\\n\", acm->port_num);\n\t\t\tif (config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       acm->port.in) ||\n\t\t\t    config_ep_by_speed(cdev->gadget, f,\n\t\t\t\t\t       acm->port.out)) {\n\t\t\t\tacm->port.in->desc = NULL;\n\t\t\t\tacm->port.out->desc = NULL;\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tgserial_connect(&acm->port, acm->port_num);\n\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic void acm_disable(struct usb_function *f)\n{\n\tstruct f_acm\t*acm = func_to_acm(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tdev_dbg(&cdev->gadget->dev, \"acm ttyGS%d deactivated\\n\", acm->port_num);\n\tgserial_disconnect(&acm->port);\n\tusb_ep_disable(acm->notify);\n}\n\n \n\n \nstatic int acm_cdc_notify(struct f_acm *acm, u8 type, u16 value,\n\t\tvoid *data, unsigned length)\n{\n\tstruct usb_ep\t\t\t*ep = acm->notify;\n\tstruct usb_request\t\t*req;\n\tstruct usb_cdc_notification\t*notify;\n\tconst unsigned\t\t\tlen = sizeof(*notify) + length;\n\tvoid\t\t\t\t*buf;\n\tint\t\t\t\tstatus;\n\n\treq = acm->notify_req;\n\tacm->notify_req = NULL;\n\tacm->pending = false;\n\n\treq->length = len;\n\tnotify = req->buf;\n\tbuf = notify + 1;\n\n\tnotify->bmRequestType = USB_DIR_IN | USB_TYPE_CLASS\n\t\t\t| USB_RECIP_INTERFACE;\n\tnotify->bNotificationType = type;\n\tnotify->wValue = cpu_to_le16(value);\n\tnotify->wIndex = cpu_to_le16(acm->ctrl_id);\n\tnotify->wLength = cpu_to_le16(length);\n\tmemcpy(buf, data, length);\n\n\t \n\tspin_unlock(&acm->lock);\n\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tspin_lock(&acm->lock);\n\n\tif (status < 0) {\n\t\tERROR(acm->port.func.config->cdev,\n\t\t\t\t\"acm ttyGS%d can't notify serial state, %d\\n\",\n\t\t\t\tacm->port_num, status);\n\t\tacm->notify_req = req;\n\t}\n\n\treturn status;\n}\n\nstatic int acm_notify_serial_state(struct f_acm *acm)\n{\n\tstruct usb_composite_dev *cdev = acm->port.func.config->cdev;\n\tint\t\t\tstatus;\n\t__le16\t\t\tserial_state;\n\n\tspin_lock(&acm->lock);\n\tif (acm->notify_req) {\n\t\tdev_dbg(&cdev->gadget->dev, \"acm ttyGS%d serial state %04x\\n\",\n\t\t\tacm->port_num, acm->serial_state);\n\t\tserial_state = cpu_to_le16(acm->serial_state);\n\t\tstatus = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,\n\t\t\t\t0, &serial_state, sizeof(acm->serial_state));\n\t} else {\n\t\tacm->pending = true;\n\t\tstatus = 0;\n\t}\n\tspin_unlock(&acm->lock);\n\treturn status;\n}\n\nstatic void acm_cdc_notify_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_acm\t\t*acm = req->context;\n\tu8\t\t\tdoit = false;\n\n\t \n\tspin_lock(&acm->lock);\n\tif (req->status != -ESHUTDOWN)\n\t\tdoit = acm->pending;\n\tacm->notify_req = req;\n\tspin_unlock(&acm->lock);\n\n\tif (doit)\n\t\tacm_notify_serial_state(acm);\n}\n\n \n\nstatic void acm_connect(struct gserial *port)\n{\n\tstruct f_acm\t\t*acm = port_to_acm(port);\n\n\tacm->serial_state |= USB_CDC_SERIAL_STATE_DSR | USB_CDC_SERIAL_STATE_DCD;\n\tacm_notify_serial_state(acm);\n}\n\nstatic void acm_disconnect(struct gserial *port)\n{\n\tstruct f_acm\t\t*acm = port_to_acm(port);\n\n\tacm->serial_state &= ~(USB_CDC_SERIAL_STATE_DSR | USB_CDC_SERIAL_STATE_DCD);\n\tacm_notify_serial_state(acm);\n}\n\nstatic int acm_send_break(struct gserial *port, int duration)\n{\n\tstruct f_acm\t\t*acm = port_to_acm(port);\n\tu16\t\t\tstate;\n\n\tstate = acm->serial_state;\n\tstate &= ~USB_CDC_SERIAL_STATE_BREAK;\n\tif (duration)\n\t\tstate |= USB_CDC_SERIAL_STATE_BREAK;\n\n\tacm->serial_state = state;\n\treturn acm_notify_serial_state(acm);\n}\n\n \n\n \nstatic int\nacm_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_acm\t\t*acm = func_to_acm(f);\n\tstruct usb_string\t*us;\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\t \n\n\t \n\tus = usb_gstrings_attach(cdev, acm_strings,\n\t\t\tARRAY_SIZE(acm_string_defs));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\tacm_control_interface_desc.iInterface = us[ACM_CTRL_IDX].id;\n\tacm_data_interface_desc.iInterface = us[ACM_DATA_IDX].id;\n\tacm_iad_descriptor.iFunction = us[ACM_IAD_IDX].id;\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tacm->ctrl_id = status;\n\tacm_iad_descriptor.bFirstInterface = status;\n\n\tacm_control_interface_desc.bInterfaceNumber = status;\n\tacm_union_desc .bMasterInterface0 = status;\n\n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tacm->data_id = status;\n\n\tacm_data_interface_desc.bInterfaceNumber = status;\n\tacm_union_desc.bSlaveInterface0 = status;\n\tacm_call_mgmt_descriptor.bDataInterface = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &acm_fs_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tacm->port.in = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &acm_fs_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tacm->port.out = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &acm_fs_notify_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tacm->notify = ep;\n\n\t \n\tacm->notify_req = gs_alloc_req(ep,\n\t\t\tsizeof(struct usb_cdc_notification) + 2,\n\t\t\tGFP_KERNEL);\n\tif (!acm->notify_req)\n\t\tgoto fail;\n\n\tacm->notify_req->complete = acm_cdc_notify_complete;\n\tacm->notify_req->context = acm;\n\n\t \n\tacm_hs_in_desc.bEndpointAddress = acm_fs_in_desc.bEndpointAddress;\n\tacm_hs_out_desc.bEndpointAddress = acm_fs_out_desc.bEndpointAddress;\n\tacm_hs_notify_desc.bEndpointAddress =\n\t\tacm_fs_notify_desc.bEndpointAddress;\n\n\tacm_ss_in_desc.bEndpointAddress = acm_fs_in_desc.bEndpointAddress;\n\tacm_ss_out_desc.bEndpointAddress = acm_fs_out_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, acm_fs_function, acm_hs_function,\n\t\t\tacm_ss_function, acm_ss_function);\n\tif (status)\n\t\tgoto fail;\n\n\tdev_dbg(&cdev->gadget->dev,\n\t\t\"acm ttyGS%d: IN/%s OUT/%s NOTIFY/%s\\n\",\n\t\tacm->port_num,\n\t\tacm->port.in->name, acm->port.out->name,\n\t\tacm->notify->name);\n\treturn 0;\n\nfail:\n\tif (acm->notify_req)\n\t\tgs_free_req(acm->notify, acm->notify_req);\n\n\tERROR(cdev, \"%s/%p: can't bind, err %d\\n\", f->name, f, status);\n\n\treturn status;\n}\n\nstatic void acm_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_acm\t\t*acm = func_to_acm(f);\n\n\tacm_string_defs[0].id = 0;\n\tusb_free_all_descriptors(f);\n\tif (acm->notify_req)\n\t\tgs_free_req(acm->notify, acm->notify_req);\n}\n\nstatic void acm_free_func(struct usb_function *f)\n{\n\tstruct f_acm\t\t*acm = func_to_acm(f);\n\n\tkfree(acm);\n}\n\nstatic void acm_resume(struct usb_function *f)\n{\n\tstruct f_acm *acm = func_to_acm(f);\n\n\tgserial_resume(&acm->port);\n}\n\nstatic void acm_suspend(struct usb_function *f)\n{\n\tstruct f_acm *acm = func_to_acm(f);\n\n\tgserial_suspend(&acm->port);\n}\n\nstatic struct usb_function *acm_alloc_func(struct usb_function_instance *fi)\n{\n\tstruct f_serial_opts *opts;\n\tstruct f_acm *acm;\n\n\tacm = kzalloc(sizeof(*acm), GFP_KERNEL);\n\tif (!acm)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&acm->lock);\n\n\tacm->port.connect = acm_connect;\n\tacm->port.disconnect = acm_disconnect;\n\tacm->port.send_break = acm_send_break;\n\n\tacm->port.func.name = \"acm\";\n\tacm->port.func.strings = acm_strings;\n\t \n\tacm->port.func.bind = acm_bind;\n\tacm->port.func.set_alt = acm_set_alt;\n\tacm->port.func.setup = acm_setup;\n\tacm->port.func.disable = acm_disable;\n\n\topts = container_of(fi, struct f_serial_opts, func_inst);\n\tacm->port_num = opts->port_num;\n\tacm->port.func.unbind = acm_unbind;\n\tacm->port.func.free_func = acm_free_func;\n\tacm->port.func.resume = acm_resume;\n\tacm->port.func.suspend = acm_suspend;\n\n\treturn &acm->port.func;\n}\n\nstatic inline struct f_serial_opts *to_f_serial_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_serial_opts,\n\t\t\tfunc_inst.group);\n}\n\nstatic void acm_attr_release(struct config_item *item)\n{\n\tstruct f_serial_opts *opts = to_f_serial_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations acm_item_ops = {\n\t.release                = acm_attr_release,\n};\n\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\nstatic ssize_t f_acm_console_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn gserial_set_console(to_f_serial_opts(item)->port_num,\n\t\t\t\t   page, count);\n}\n\nstatic ssize_t f_acm_console_show(struct config_item *item, char *page)\n{\n\treturn gserial_get_console(to_f_serial_opts(item)->port_num, page);\n}\n\nCONFIGFS_ATTR(f_acm_, console);\n\n#endif  \n\nstatic ssize_t f_acm_port_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_f_serial_opts(item)->port_num);\n}\n\nCONFIGFS_ATTR_RO(f_acm_, port_num);\n\nstatic struct configfs_attribute *acm_attrs[] = {\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\t&f_acm_attr_console,\n#endif\n\t&f_acm_attr_port_num,\n\tNULL,\n};\n\nstatic const struct config_item_type acm_func_type = {\n\t.ct_item_ops    = &acm_item_ops,\n\t.ct_attrs\t= acm_attrs,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic void acm_free_instance(struct usb_function_instance *fi)\n{\n\tstruct f_serial_opts *opts;\n\n\topts = container_of(fi, struct f_serial_opts, func_inst);\n\tgserial_free_line(opts->port_num);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *acm_alloc_instance(void)\n{\n\tstruct f_serial_opts *opts;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\topts->func_inst.free_func_inst = acm_free_instance;\n\tret = gserial_alloc_line(&opts->port_num);\n\tif (ret) {\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t&acm_func_type);\n\treturn &opts->func_inst;\n}\nDECLARE_USB_FUNCTION_INIT(acm, acm_alloc_instance, acm_alloc_func);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}