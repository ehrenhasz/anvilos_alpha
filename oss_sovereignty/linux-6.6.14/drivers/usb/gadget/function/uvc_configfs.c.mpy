{
  "module_name": "uvc_configfs.c",
  "hash_id": "d77f3b45f29ee2fc04389a5620b7b5e0efa03e72f1c5ed2083a21edd819bbd47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/uvc_configfs.c",
  "human_readable_source": "\n \n\n#include \"uvc_configfs.h\"\n\n#include <linux/sort.h>\n#include <linux/usb/video.h>\n\n \n\n#define UVC_ATTR(prefix, cname, aname) \\\nstatic struct configfs_attribute prefix##attr_##cname = { \\\n\t.ca_name\t= __stringify(aname),\t\t\t\t\\\n\t.ca_mode\t= S_IRUGO | S_IWUGO,\t\t\t\t\\\n\t.ca_owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t.show\t\t= prefix##cname##_show,\t\t\t\t\\\n\t.store\t\t= prefix##cname##_store,\t\t\t\\\n}\n\n#define UVC_ATTR_RO(prefix, cname, aname) \\\nstatic struct configfs_attribute prefix##attr_##cname = { \\\n\t.ca_name\t= __stringify(aname),\t\t\t\t\\\n\t.ca_mode\t= S_IRUGO,\t\t\t\t\t\\\n\t.ca_owner\t= THIS_MODULE,\t\t\t\t\t\\\n\t.show\t\t= prefix##cname##_show,\t\t\t\t\\\n}\n\n#define le8_to_cpu(x)\t(x)\n#define cpu_to_le8(x)\t(x)\n\nstatic int uvcg_config_compare_u32(const void *l, const void *r)\n{\n\tu32 li = *(const u32 *)l;\n\tu32 ri = *(const u32 *)r;\n\n\treturn li < ri ? -1 : li == ri ? 0 : 1;\n}\n\nstatic inline int __uvcg_count_item_entries(char *buf, void *priv, unsigned int size)\n{\n\t++*((int *)priv);\n\treturn 0;\n}\n\nstatic inline int __uvcg_fill_item_entries(char *buf, void *priv, unsigned int size)\n{\n\tunsigned int num;\n\tu8 **values;\n\tint ret;\n\n\tret = kstrtouint(buf, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tif (num != (num & GENMASK((size * 8) - 1, 0)))\n\t\treturn -ERANGE;\n\n\tvalues = priv;\n\tmemcpy(*values, &num, size);\n\t*values += size;\n\n\treturn 0;\n}\n\nstatic int __uvcg_iter_item_entries(const char *page, size_t len,\n\t\t\t\t    int (*fun)(char *, void *, unsigned int),\n\t\t\t\t    void *priv, unsigned int size)\n{\n\t \n\tunsigned int bufsize = 1 + size * 8 + 1 + 1;\n\tconst char *pg = page;\n\tint i, ret = 0;\n\tchar *buf;\n\n\tif (!fun)\n\t\treturn -EINVAL;\n\n\tbuf = kzalloc(bufsize, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (pg - page < len) {\n\t\ti = 0;\n\t\twhile (i < sizeof(buf) && (pg - page < len) &&\n\t\t       *pg != '\\0' && *pg != '\\n')\n\t\t\tbuf[i++] = *pg++;\n\t\tif (i == sizeof(buf)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_free_buf;\n\t\t}\n\t\twhile ((pg - page < len) && (*pg == '\\0' || *pg == '\\n'))\n\t\t\t++pg;\n\t\tbuf[i] = '\\0';\n\t\tret = fun(buf, priv, size);\n\t\tif (ret)\n\t\t\tgoto out_free_buf;\n\t}\n\nout_free_buf:\n\tkfree(buf);\n\treturn ret;\n}\n\nstruct uvcg_config_group_type {\n\tstruct config_item_type type;\n\tconst char *name;\n\tconst struct uvcg_config_group_type **children;\n\tint (*create_children)(struct config_group *group);\n};\n\nstatic void uvcg_config_item_release(struct config_item *item)\n{\n\tstruct config_group *group = to_config_group(item);\n\n\tkfree(group);\n}\n\nstatic struct configfs_item_operations uvcg_config_item_ops = {\n\t.release\t= uvcg_config_item_release,\n};\n\nstatic int uvcg_config_create_group(struct config_group *parent,\n\t\t\t\t    const struct uvcg_config_group_type *type);\n\nstatic int uvcg_config_create_children(struct config_group *group,\n\t\t\t\tconst struct uvcg_config_group_type *type)\n{\n\tconst struct uvcg_config_group_type **child;\n\tint ret;\n\n\tif (type->create_children)\n\t\treturn type->create_children(group);\n\n\tfor (child = type->children; child && *child; ++child) {\n\t\tret = uvcg_config_create_group(group, *child);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvcg_config_create_group(struct config_group *parent,\n\t\t\t\t    const struct uvcg_config_group_type *type)\n{\n\tstruct config_group *group;\n\n\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\tif (!group)\n\t\treturn -ENOMEM;\n\n\tconfig_group_init_type_name(group, type->name, &type->type);\n\tconfigfs_add_default_group(group, parent);\n\n\treturn uvcg_config_create_children(group, type);\n}\n\nstatic void uvcg_config_remove_children(struct config_group *group)\n{\n\tstruct config_group *child, *n;\n\n\tlist_for_each_entry_safe(child, n, &group->default_groups, group_entry) {\n\t\tlist_del(&child->group_entry);\n\t\tuvcg_config_remove_children(child);\n\t\tconfig_item_put(&child->cg_item);\n\t}\n}\n\n \n\n#define UVCG_CTRL_HDR_ATTR(cname, aname, bits, limit)\t\t\t\\\nstatic ssize_t uvcg_control_header_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_control_header *ch = to_uvcg_control_header(item);\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &ch->item.ci_group->cg_subsys->su_mutex;\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = ch->item.ci_parent->ci_parent->ci_parent;\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(ch->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nuvcg_control_header_##cname##_store(struct config_item *item,\t\t\\\n\t\t\t   const char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_control_header *ch = to_uvcg_control_header(item);\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &ch->item.ci_group->cg_subsys->su_mutex;\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu##bits num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = ch->item.ci_parent->ci_parent->ci_parent;\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (ch->linked || opts->refcnt) {\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou##bits(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (num > limit) {\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tch->desc.aname = cpu_to_le##bits(num);\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(uvcg_control_header_, cname, aname)\n\nUVCG_CTRL_HDR_ATTR(bcd_uvc, bcdUVC, 16, 0xffff);\n\nUVCG_CTRL_HDR_ATTR(dw_clock_frequency, dwClockFrequency, 32, 0x7fffffff);\n\n#undef UVCG_CTRL_HDR_ATTR\n\nstatic struct configfs_attribute *uvcg_control_header_attrs[] = {\n\t&uvcg_control_header_attr_bcd_uvc,\n\t&uvcg_control_header_attr_dw_clock_frequency,\n\tNULL,\n};\n\nstatic const struct config_item_type uvcg_control_header_type = {\n\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t.ct_attrs\t= uvcg_control_header_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item *uvcg_control_header_make(struct config_group *group,\n\t\t\t\t\t\t    const char *name)\n{\n\tstruct uvcg_control_header *h;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\th->desc.bLength\t\t\t= UVC_DT_HEADER_SIZE(1);\n\th->desc.bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\th->desc.bDescriptorSubType\t= UVC_VC_HEADER;\n\th->desc.bcdUVC\t\t\t= cpu_to_le16(0x0110);\n\th->desc.dwClockFrequency\t= cpu_to_le32(48000000);\n\n\tconfig_item_init_type_name(&h->item, name, &uvcg_control_header_type);\n\n\treturn &h->item;\n}\n\nstatic struct configfs_group_operations uvcg_control_header_grp_ops = {\n\t.make_item\t\t= uvcg_control_header_make,\n};\n\nstatic const struct uvcg_config_group_type uvcg_control_header_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_control_header_grp_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"header\",\n};\n\n \n\n#define UVCG_DEFAULT_PROCESSING_ATTR(cname, aname, bits)\t\t\\\nstatic ssize_t uvcg_default_processing_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tstruct uvc_processing_unit_descriptor *pd;\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\tpd = &opts->uvc_processing;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(pd->aname));\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_default_processing_, cname, aname)\n\nUVCG_DEFAULT_PROCESSING_ATTR(b_unit_id, bUnitID, 8);\nUVCG_DEFAULT_PROCESSING_ATTR(b_source_id, bSourceID, 8);\nUVCG_DEFAULT_PROCESSING_ATTR(w_max_multiplier, wMaxMultiplier, 16);\nUVCG_DEFAULT_PROCESSING_ATTR(i_processing, iProcessing, 8);\n\n#undef UVCG_DEFAULT_PROCESSING_ATTR\n\nstatic ssize_t uvcg_default_processing_bm_controls_store(\n\tstruct config_item *item, const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_processing_unit_descriptor *pd;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tu8 *bm_controls, *tmp;\n\tunsigned int i;\n\tint ret, n = 0;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tpd = &opts->uvc_processing;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_count_item_entries, &n,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (n > pd->bControlSize) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\ttmp = bm_controls = kcalloc(n, sizeof(u8), GFP_KERNEL);\n\tif (!bm_controls) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_fill_item_entries, &tmp,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto free_mem;\n\n\tfor (i = 0; i < n; i++)\n\t\tpd->bmControls[i] = bm_controls[i];\n\n\tret = len;\n\nfree_mem:\n\tkfree(bm_controls);\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nstatic ssize_t uvcg_default_processing_bm_controls_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_processing_unit_descriptor *pd;\n\tint result, i;\n\tchar *pg = page;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tpd = &opts->uvc_processing;\n\n\tmutex_lock(&opts->lock);\n\tfor (result = 0, i = 0; i < pd->bControlSize; ++i) {\n\t\tresult += sprintf(pg, \"%u\\n\", pd->bmControls[i]);\n\t\tpg = page + result;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn result;\n}\n\nUVC_ATTR(uvcg_default_processing_, bm_controls, bmControls);\n\nstatic struct configfs_attribute *uvcg_default_processing_attrs[] = {\n\t&uvcg_default_processing_attr_b_unit_id,\n\t&uvcg_default_processing_attr_b_source_id,\n\t&uvcg_default_processing_attr_w_max_multiplier,\n\t&uvcg_default_processing_attr_bm_controls,\n\t&uvcg_default_processing_attr_i_processing,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvcg_default_processing_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_attrs\t= uvcg_default_processing_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"default\",\n};\n\n \n\nstatic const struct uvcg_config_group_type uvcg_processing_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"processing\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_default_processing_type,\n\t\tNULL,\n\t},\n};\n\n \n\n#define UVCG_DEFAULT_CAMERA_ATTR(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_default_camera_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tstruct uvc_camera_terminal_descriptor *cd;\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent->\t\\\n\t\t\tci_parent;\t\t\t\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\tcd = &opts->uvc_camera_terminal;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(cd->aname));\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_default_camera_, cname, aname)\n\nUVCG_DEFAULT_CAMERA_ATTR(b_terminal_id, bTerminalID, 8);\nUVCG_DEFAULT_CAMERA_ATTR(w_terminal_type, wTerminalType, 16);\nUVCG_DEFAULT_CAMERA_ATTR(b_assoc_terminal, bAssocTerminal, 8);\nUVCG_DEFAULT_CAMERA_ATTR(i_terminal, iTerminal, 8);\nUVCG_DEFAULT_CAMERA_ATTR(w_objective_focal_length_min, wObjectiveFocalLengthMin,\n\t\t\t 16);\nUVCG_DEFAULT_CAMERA_ATTR(w_objective_focal_length_max, wObjectiveFocalLengthMax,\n\t\t\t 16);\nUVCG_DEFAULT_CAMERA_ATTR(w_ocular_focal_length, wOcularFocalLength,\n\t\t\t 16);\n\n#undef UVCG_DEFAULT_CAMERA_ATTR\n\nstatic ssize_t uvcg_default_camera_bm_controls_store(\n\tstruct config_item *item, const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_camera_terminal_descriptor *cd;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tu8 *bm_controls, *tmp;\n\tunsigned int i;\n\tint ret, n = 0;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent->\n\t\t\tci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tcd = &opts->uvc_camera_terminal;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_count_item_entries, &n,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (n > cd->bControlSize) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\ttmp = bm_controls = kcalloc(n, sizeof(u8), GFP_KERNEL);\n\tif (!bm_controls) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_fill_item_entries, &tmp,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto free_mem;\n\n\tfor (i = 0; i < n; i++)\n\t\tcd->bmControls[i] = bm_controls[i];\n\n\tret = len;\n\nfree_mem:\n\tkfree(bm_controls);\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nstatic ssize_t uvcg_default_camera_bm_controls_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_camera_terminal_descriptor *cd;\n\tint result, i;\n\tchar *pg = page;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent->\n\t\t\tci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tcd = &opts->uvc_camera_terminal;\n\n\tmutex_lock(&opts->lock);\n\tfor (result = 0, i = 0; i < cd->bControlSize; ++i) {\n\t\tresult += sprintf(pg, \"%u\\n\", cd->bmControls[i]);\n\t\tpg = page + result;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\treturn result;\n}\n\nUVC_ATTR(uvcg_default_camera_, bm_controls, bmControls);\n\nstatic struct configfs_attribute *uvcg_default_camera_attrs[] = {\n\t&uvcg_default_camera_attr_b_terminal_id,\n\t&uvcg_default_camera_attr_w_terminal_type,\n\t&uvcg_default_camera_attr_b_assoc_terminal,\n\t&uvcg_default_camera_attr_i_terminal,\n\t&uvcg_default_camera_attr_w_objective_focal_length_min,\n\t&uvcg_default_camera_attr_w_objective_focal_length_max,\n\t&uvcg_default_camera_attr_w_ocular_focal_length,\n\t&uvcg_default_camera_attr_bm_controls,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvcg_default_camera_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_attrs\t= uvcg_default_camera_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"default\",\n};\n\n \n\nstatic const struct uvcg_config_group_type uvcg_camera_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"camera\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_default_camera_type,\n\t\tNULL,\n\t},\n};\n\n \n\n#define UVCG_DEFAULT_OUTPUT_ATTR(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_default_output_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tstruct uvc_output_terminal_descriptor *cd;\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = group->cg_item.ci_parent->ci_parent->\t\t\\\n\t\t\tci_parent->ci_parent;\t\t\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\tcd = &opts->uvc_output_terminal;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(cd->aname));\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_default_output_, cname, aname)\n\nUVCG_DEFAULT_OUTPUT_ATTR(b_terminal_id, bTerminalID, 8);\nUVCG_DEFAULT_OUTPUT_ATTR(w_terminal_type, wTerminalType, 16);\nUVCG_DEFAULT_OUTPUT_ATTR(b_assoc_terminal, bAssocTerminal, 8);\nUVCG_DEFAULT_OUTPUT_ATTR(i_terminal, iTerminal, 8);\n\n#undef UVCG_DEFAULT_OUTPUT_ATTR\n\nstatic ssize_t uvcg_default_output_b_source_id_show(struct config_item *item,\n\t\t\t\t\t\t    char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_output_terminal_descriptor *cd;\n\tint result;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = group->cg_item.ci_parent->ci_parent->\n\t\t\tci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tcd = &opts->uvc_output_terminal;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", le8_to_cpu(cd->bSourceID));\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn result;\n}\n\nstatic ssize_t uvcg_default_output_b_source_id_store(struct config_item *item,\n\t\t\t\t\t\t     const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvc_output_terminal_descriptor *cd;\n\tint result;\n\tu8 num;\n\n\tresult = kstrtou8(page, 0, &num);\n\tif (result)\n\t\treturn result;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = group->cg_item.ci_parent->ci_parent->\n\t\t\tci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tcd = &opts->uvc_output_terminal;\n\n\tmutex_lock(&opts->lock);\n\tcd->bSourceID = num;\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn len;\n}\nUVC_ATTR(uvcg_default_output_, b_source_id, bSourceID);\n\nstatic struct configfs_attribute *uvcg_default_output_attrs[] = {\n\t&uvcg_default_output_attr_b_terminal_id,\n\t&uvcg_default_output_attr_w_terminal_type,\n\t&uvcg_default_output_attr_b_assoc_terminal,\n\t&uvcg_default_output_attr_b_source_id,\n\t&uvcg_default_output_attr_i_terminal,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvcg_default_output_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_attrs\t= uvcg_default_output_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"default\",\n};\n\n \n\nstatic const struct uvcg_config_group_type uvcg_output_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"output\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_default_output_type,\n\t\tNULL,\n\t},\n};\n\n \n\nstatic const struct uvcg_config_group_type uvcg_terminal_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"terminal\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_camera_grp_type,\n\t\t&uvcg_output_grp_type,\n\t\tNULL,\n\t},\n};\n\n \n\n#define UVCG_EXTENSION_ATTR(cname, aname, ro...)\t\t\t\\\nstatic ssize_t uvcg_extension_##cname##_show(struct config_item *item,\t\\\n\t\t\t\t\t     char *page)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item->ci_parent);\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = item->ci_parent->ci_parent->ci_parent;\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tret = sprintf(page, \"%u\\n\", xu->desc.aname);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR##ro(uvcg_extension_, cname, aname)\n\nUVCG_EXTENSION_ATTR(b_length, bLength, _RO);\nUVCG_EXTENSION_ATTR(b_unit_id, bUnitID, _RO);\nUVCG_EXTENSION_ATTR(i_extension, iExtension, _RO);\n\nstatic ssize_t uvcg_extension_b_num_controls_store(struct config_item *item,\n\t\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tint ret;\n\tu8 num;\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\txu->desc.bNumControls = num;\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn len;\n}\nUVCG_EXTENSION_ATTR(b_num_controls, bNumControls);\n\n \nstatic ssize_t uvcg_extension_b_nr_in_pins_store(struct config_item *item,\n\t\t\t\t\t\t const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tvoid *tmp_buf;\n\tint ret;\n\tu8 num;\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tif (num == xu->desc.bNrInPins) {\n\t\tret = len;\n\t\tgoto unlock;\n\t}\n\n\ttmp_buf = krealloc_array(xu->desc.baSourceID, num, sizeof(u8),\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\txu->desc.baSourceID = tmp_buf;\n\txu->desc.bNrInPins = num;\n\txu->desc.bLength = UVC_DT_EXTENSION_UNIT_SIZE(xu->desc.bNrInPins,\n\t\t\t\t\t\t      xu->desc.bControlSize);\n\n\tret = len;\n\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\nUVCG_EXTENSION_ATTR(b_nr_in_pins, bNrInPins);\n\n \nstatic ssize_t uvcg_extension_b_control_size_store(struct config_item *item,\n\t\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tvoid *tmp_buf;\n\tint ret;\n\tu8 num;\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tif (num == xu->desc.bControlSize) {\n\t\tret = len;\n\t\tgoto unlock;\n\t}\n\n\ttmp_buf = krealloc_array(xu->desc.bmControls, num, sizeof(u8),\n\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\txu->desc.bmControls = tmp_buf;\n\txu->desc.bControlSize = num;\n\txu->desc.bLength = UVC_DT_EXTENSION_UNIT_SIZE(xu->desc.bNrInPins,\n\t\t\t\t\t\t      xu->desc.bControlSize);\n\n\tret = len;\n\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nUVCG_EXTENSION_ATTR(b_control_size, bControlSize);\n\nstatic ssize_t uvcg_extension_guid_extension_code_show(struct config_item *item,\n\t\t\t\t\t\t       char *page)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tmemcpy(page, xu->desc.guidExtensionCode, sizeof(xu->desc.guidExtensionCode));\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn sizeof(xu->desc.guidExtensionCode);\n}\n\nstatic ssize_t uvcg_extension_guid_extension_code_store(struct config_item *item,\n\t\t\t\t\t\t\tconst char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tint ret;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tmemcpy(xu->desc.guidExtensionCode, page,\n\t       min(sizeof(xu->desc.guidExtensionCode), len));\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\tret = sizeof(xu->desc.guidExtensionCode);\n\n\treturn ret;\n}\n\nUVC_ATTR(uvcg_extension_, guid_extension_code, guidExtensionCode);\n\nstatic ssize_t uvcg_extension_ba_source_id_show(struct config_item *item,\n\t\t\t\t\t\tchar *page)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tchar *pg = page;\n\tint ret, i;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tfor (ret = 0, i = 0; i < xu->desc.bNrInPins; ++i) {\n\t\tret += sprintf(pg, \"%u\\n\", xu->desc.baSourceID[i]);\n\t\tpg = page + ret;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t uvcg_extension_ba_source_id_store(struct config_item *item,\n\t\t\t\t\t\t const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tu8 *source_ids, *iter;\n\tint ret, n = 0;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_count_item_entries, &n,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto unlock;\n\n\titer = source_ids = kcalloc(n, sizeof(u8), GFP_KERNEL);\n\tif (!source_ids) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_fill_item_entries, &iter,\n\t\t\t\t       sizeof(u8));\n\tif (ret) {\n\t\tkfree(source_ids);\n\t\tgoto unlock;\n\t}\n\n\tkfree(xu->desc.baSourceID);\n\txu->desc.baSourceID = source_ids;\n\txu->desc.bNrInPins = n;\n\txu->desc.bLength = UVC_DT_EXTENSION_UNIT_SIZE(xu->desc.bNrInPins,\n\t\t\t\t\t\t      xu->desc.bControlSize);\n\n\tret = len;\n\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\nUVC_ATTR(uvcg_extension_, ba_source_id, baSourceID);\n\nstatic ssize_t uvcg_extension_bm_controls_show(struct config_item *item,\n\t\t\t\t\t       char *page)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tchar *pg = page;\n\tint ret, i;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tfor (ret = 0, i = 0; i < xu->desc.bControlSize; ++i) {\n\t\tret += sprintf(pg, \"0x%02x\\n\", xu->desc.bmControls[i]);\n\t\tpg = page + ret;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t uvcg_extension_bm_controls_store(struct config_item *item,\n\t\t\t\t\t\tconst char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item->ci_parent);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tu8 *bm_controls, *iter;\n\tint ret, n = 0;\n\n\tmutex_lock(su_mutex);\n\n\topts_item = item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_count_item_entries, &n,\n\t\t\t\t       sizeof(u8));\n\tif (ret)\n\t\tgoto unlock;\n\n\titer = bm_controls = kcalloc(n, sizeof(u8), GFP_KERNEL);\n\tif (!bm_controls) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_fill_item_entries, &iter,\n\t\t\t\t       sizeof(u8));\n\tif (ret) {\n\t\tkfree(bm_controls);\n\t\tgoto unlock;\n\t}\n\n\tkfree(xu->desc.bmControls);\n\txu->desc.bmControls = bm_controls;\n\txu->desc.bControlSize = n;\n\txu->desc.bLength = UVC_DT_EXTENSION_UNIT_SIZE(xu->desc.bNrInPins,\n\t\t\t\t\t\t      xu->desc.bControlSize);\n\n\tret = len;\n\nunlock:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nUVC_ATTR(uvcg_extension_, bm_controls, bmControls);\n\nstatic struct configfs_attribute *uvcg_extension_attrs[] = {\n\t&uvcg_extension_attr_b_length,\n\t&uvcg_extension_attr_b_unit_id,\n\t&uvcg_extension_attr_b_num_controls,\n\t&uvcg_extension_attr_b_nr_in_pins,\n\t&uvcg_extension_attr_b_control_size,\n\t&uvcg_extension_attr_guid_extension_code,\n\t&uvcg_extension_attr_ba_source_id,\n\t&uvcg_extension_attr_bm_controls,\n\t&uvcg_extension_attr_i_extension,\n\tNULL,\n};\n\nstatic void uvcg_extension_release(struct config_item *item)\n{\n\tstruct uvcg_extension *xu = container_of(item, struct uvcg_extension, item);\n\n\tkfree(xu);\n}\n\nstatic int uvcg_extension_allow_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(src);\n\tstruct config_item *gadget_item;\n\tstruct gadget_string *string;\n\tstruct config_item *strings;\n\tint ret = 0;\n\n\tmutex_lock(su_mutex);  \n\n\t \n\tgadget_item = src->ci_parent->ci_parent->ci_parent->ci_parent->ci_parent;\n\tstrings = config_group_find_item(to_config_group(gadget_item), \"strings\");\n\tif (!strings || tgt->ci_parent->ci_parent != strings) {\n\t\tret = -EINVAL;\n\t\tgoto put_strings;\n\t}\n\n\tstring = to_gadget_string(tgt);\n\txu->string_descriptor_index = string->usb_string.id;\n\nput_strings:\n\tconfig_item_put(strings);\n\tmutex_unlock(su_mutex);\n\n\treturn ret;\n}\n\nstatic void uvcg_extension_drop_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvcg_extension *xu = to_uvcg_extension(src);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = src->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\txu->string_descriptor_index = 0;\n\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n}\n\nstatic struct configfs_item_operations uvcg_extension_item_ops = {\n\t.release\t= uvcg_extension_release,\n\t.allow_link\t= uvcg_extension_allow_link,\n\t.drop_link\t= uvcg_extension_drop_link,\n};\n\nstatic const struct config_item_type uvcg_extension_type = {\n\t.ct_item_ops\t= &uvcg_extension_item_ops,\n\t.ct_attrs\t= uvcg_extension_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void uvcg_extension_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct uvcg_extension *xu = container_of(item, struct uvcg_extension, item);\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\n\topts_item = group->cg_item.ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tconfig_item_put(item);\n\tlist_del(&xu->list);\n\tkfree(xu->desc.baSourceID);\n\tkfree(xu->desc.bmControls);\n\n\tmutex_unlock(&opts->lock);\n}\n\nstatic struct config_item *uvcg_extension_make(struct config_group *group, const char *name)\n{\n\tstruct config_item *opts_item;\n\tstruct uvcg_extension *xu;\n\tstruct f_uvc_opts *opts;\n\n\topts_item = group->cg_item.ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\txu = kzalloc(sizeof(*xu), GFP_KERNEL);\n\tif (!xu)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\txu->desc.bLength = UVC_DT_EXTENSION_UNIT_SIZE(0, 0);\n\txu->desc.bDescriptorType = USB_DT_CS_INTERFACE;\n\txu->desc.bDescriptorSubType = UVC_VC_EXTENSION_UNIT;\n\txu->desc.bNumControls = 0;\n\txu->desc.bNrInPins = 0;\n\txu->desc.baSourceID = NULL;\n\txu->desc.bControlSize = 0;\n\txu->desc.bmControls = NULL;\n\n\tmutex_lock(&opts->lock);\n\n\txu->desc.bUnitID = ++opts->last_unit_id;\n\n\tconfig_item_init_type_name(&xu->item, name, &uvcg_extension_type);\n\tlist_add_tail(&xu->list, &opts->extension_units);\n\n\tmutex_unlock(&opts->lock);\n\n\treturn &xu->item;\n}\n\nstatic struct configfs_group_operations uvcg_extensions_grp_ops = {\n\t.make_item\t= uvcg_extension_make,\n\t.drop_item\t= uvcg_extension_drop,\n};\n\nstatic const struct uvcg_config_group_type uvcg_extensions_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_extensions_grp_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"extensions\",\n};\n\n \n\nstruct uvcg_control_class_group {\n\tstruct config_group group;\n\tconst char *name;\n};\n\nstatic inline struct uvc_descriptor_header\n**uvcg_get_ctl_class_arr(struct config_item *i, struct f_uvc_opts *o)\n{\n\tstruct uvcg_control_class_group *group =\n\t\tcontainer_of(i, struct uvcg_control_class_group,\n\t\t\t     group.cg_item);\n\n\tif (!strcmp(group->name, \"fs\"))\n\t\treturn o->uvc_fs_control_cls;\n\n\tif (!strcmp(group->name, \"ss\"))\n\t\treturn o->uvc_ss_control_cls;\n\n\treturn NULL;\n}\n\nstatic int uvcg_control_class_allow_link(struct config_item *src,\n\t\t\t\t\t struct config_item *target)\n{\n\tstruct config_item *control, *header;\n\tstruct f_uvc_opts *opts;\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvc_descriptor_header **class_array;\n\tstruct uvcg_control_header *target_hdr;\n\tint ret = -EINVAL;\n\n\tmutex_lock(su_mutex);  \n\n\tcontrol = src->ci_parent->ci_parent;\n\theader = config_group_find_item(to_config_group(control), \"header\");\n\tif (!header || target->ci_parent != header)\n\t\tgoto out;\n\n\topts = to_f_uvc_opts(control->ci_parent);\n\n\tmutex_lock(&opts->lock);\n\n\tclass_array = uvcg_get_ctl_class_arr(src, opts);\n\tif (!class_array)\n\t\tgoto unlock;\n\tif (opts->refcnt || class_array[0]) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\ttarget_hdr = to_uvcg_control_header(target);\n\t++target_hdr->linked;\n\tclass_array[0] = (struct uvc_descriptor_header *)&target_hdr->desc;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&opts->lock);\nout:\n\tconfig_item_put(header);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nstatic void uvcg_control_class_drop_link(struct config_item *src,\n\t\t\t\t\tstruct config_item *target)\n{\n\tstruct config_item *control, *header;\n\tstruct f_uvc_opts *opts;\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvc_descriptor_header **class_array;\n\tstruct uvcg_control_header *target_hdr;\n\n\tmutex_lock(su_mutex);  \n\n\tcontrol = src->ci_parent->ci_parent;\n\theader = config_group_find_item(to_config_group(control), \"header\");\n\tif (!header || target->ci_parent != header)\n\t\tgoto out;\n\n\topts = to_f_uvc_opts(control->ci_parent);\n\n\tmutex_lock(&opts->lock);\n\n\tclass_array = uvcg_get_ctl_class_arr(src, opts);\n\tif (!class_array || opts->refcnt)\n\t\tgoto unlock;\n\n\ttarget_hdr = to_uvcg_control_header(target);\n\t--target_hdr->linked;\n\tclass_array[0] = NULL;\n\nunlock:\n\tmutex_unlock(&opts->lock);\nout:\n\tconfig_item_put(header);\n\tmutex_unlock(su_mutex);\n}\n\nstatic struct configfs_item_operations uvcg_control_class_item_ops = {\n\t.release\t= uvcg_config_item_release,\n\t.allow_link\t= uvcg_control_class_allow_link,\n\t.drop_link\t= uvcg_control_class_drop_link,\n};\n\nstatic const struct config_item_type uvcg_control_class_type = {\n\t.ct_item_ops\t= &uvcg_control_class_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstatic int uvcg_control_class_create_children(struct config_group *parent)\n{\n\tstatic const char * const names[] = { \"fs\", \"ss\" };\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(names); ++i) {\n\t\tstruct uvcg_control_class_group *group;\n\n\t\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\t\tif (!group)\n\t\t\treturn -ENOMEM;\n\n\t\tgroup->name = names[i];\n\n\t\tconfig_group_init_type_name(&group->group, group->name,\n\t\t\t\t\t    &uvcg_control_class_type);\n\t\tconfigfs_add_default_group(&group->group, parent);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct uvcg_config_group_type uvcg_control_class_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"class\",\n\t.create_children = uvcg_control_class_create_children,\n};\n\n \n\nstatic ssize_t uvcg_default_control_b_interface_number_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tint result = 0;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = item->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tresult += sprintf(page, \"%u\\n\", opts->control_interface);\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn result;\n}\n\nUVC_ATTR_RO(uvcg_default_control_, b_interface_number, bInterfaceNumber);\n\nstatic ssize_t uvcg_default_control_enable_interrupt_ep_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tint result = 0;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = item->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tresult += sprintf(page, \"%u\\n\", opts->enable_interrupt_ep);\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn result;\n}\n\nstatic ssize_t uvcg_default_control_enable_interrupt_ep_store(\n\tstruct config_item *item, const char *page, size_t len)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tssize_t ret;\n\tu8 num;\n\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = item->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\topts->enable_interrupt_ep = num;\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn len;\n}\nUVC_ATTR(uvcg_default_control_, enable_interrupt_ep, enable_interrupt_ep);\n\nstatic struct configfs_attribute *uvcg_default_control_attrs[] = {\n\t&uvcg_default_control_attr_b_interface_number,\n\t&uvcg_default_control_attr_enable_interrupt_ep,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvcg_control_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_attrs\t= uvcg_default_control_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"control\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_control_header_grp_type,\n\t\t&uvcg_processing_grp_type,\n\t\t&uvcg_terminal_grp_type,\n\t\t&uvcg_control_class_grp_type,\n\t\t&uvcg_extensions_grp_type,\n\t\tNULL,\n\t},\n};\n\n \n\nstatic const char * const uvcg_format_names[] = {\n\t\"uncompressed\",\n\t\"mjpeg\",\n};\n\nstatic struct uvcg_color_matching *\nuvcg_format_get_default_color_match(struct config_item *streaming)\n{\n\tstruct config_item *color_matching_item, *cm_default;\n\tstruct uvcg_color_matching *color_match;\n\n\tcolor_matching_item = config_group_find_item(to_config_group(streaming),\n\t\t\t\t\t\t     \"color_matching\");\n\tif (!color_matching_item)\n\t\treturn NULL;\n\n\tcm_default = config_group_find_item(to_config_group(color_matching_item),\n\t\t\t\t\t    \"default\");\n\tconfig_item_put(color_matching_item);\n\tif (!cm_default)\n\t\treturn NULL;\n\n\tcolor_match = to_uvcg_color_matching(to_config_group(cm_default));\n\tconfig_item_put(cm_default);\n\n\treturn color_match;\n}\n\nstatic int uvcg_format_allow_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvcg_color_matching *color_matching_desc;\n\tstruct config_item *streaming, *color_matching;\n\tstruct uvcg_format *fmt;\n\tint ret = 0;\n\n\tmutex_lock(su_mutex);\n\n\tstreaming = src->ci_parent->ci_parent;\n\tcolor_matching = config_group_find_item(to_config_group(streaming), \"color_matching\");\n\tif (!color_matching || color_matching != tgt->ci_parent) {\n\t\tret = -EINVAL;\n\t\tgoto out_put_cm;\n\t}\n\n\tfmt = to_uvcg_format(src);\n\n\t \n\tcolor_matching_desc = uvcg_format_get_default_color_match(streaming);\n\tif (fmt->color_matching != color_matching_desc) {\n\t\tret = -EBUSY;\n\t\tgoto out_put_cm;\n\t}\n\n\tcolor_matching_desc->refcnt--;\n\n\tcolor_matching_desc = to_uvcg_color_matching(to_config_group(tgt));\n\tfmt->color_matching = color_matching_desc;\n\tcolor_matching_desc->refcnt++;\n\nout_put_cm:\n\tconfig_item_put(color_matching);\n\tmutex_unlock(su_mutex);\n\n\treturn ret;\n}\n\nstatic void uvcg_format_drop_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvcg_color_matching *color_matching_desc;\n\tstruct config_item *streaming;\n\tstruct uvcg_format *fmt;\n\n\tmutex_lock(su_mutex);\n\n\tcolor_matching_desc = to_uvcg_color_matching(to_config_group(tgt));\n\tcolor_matching_desc->refcnt--;\n\n\tstreaming = src->ci_parent->ci_parent;\n\tcolor_matching_desc = uvcg_format_get_default_color_match(streaming);\n\n\tfmt = to_uvcg_format(src);\n\tfmt->color_matching = color_matching_desc;\n\tcolor_matching_desc->refcnt++;\n\n\tmutex_unlock(su_mutex);\n}\n\nstatic struct configfs_item_operations uvcg_format_item_operations = {\n\t.release\t= uvcg_config_item_release,\n\t.allow_link\t= uvcg_format_allow_link,\n\t.drop_link\t= uvcg_format_drop_link,\n};\n\nstatic ssize_t uvcg_format_bma_controls_show(struct uvcg_format *f, char *page)\n{\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &f->group.cg_subsys->su_mutex;\n\tint result, i;\n\tchar *pg = page;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = f->group.cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(pg, \"0x\");\n\tpg += result;\n\tfor (i = 0; i < UVCG_STREAMING_CONTROL_SIZE; ++i) {\n\t\tresult += sprintf(pg, \"%x\\n\", f->bmaControls[i]);\n\t\tpg = page + result;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\treturn result;\n}\n\nstatic ssize_t uvcg_format_bma_controls_store(struct uvcg_format *ch,\n\t\t\t\t\t      const char *page, size_t len)\n{\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &ch->group.cg_subsys->su_mutex;\n\tint ret = -EINVAL;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = ch->group.cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tif (ch->linked || opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tif (len < 4 || *page != '0' ||\n\t    (*(page + 1) != 'x' && *(page + 1) != 'X'))\n\t\tgoto end;\n\tret = hex2bin(ch->bmaControls, page + 2, 1);\n\tif (ret < 0)\n\t\tgoto end;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\n \n\nstatic void uvcg_format_set_indices(struct config_group *fmt);\n\nstatic int uvcg_streaming_header_allow_link(struct config_item *src,\n\t\t\t\t\t    struct config_item *target)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tstruct uvcg_streaming_header *src_hdr;\n\tstruct uvcg_format *target_fmt = NULL;\n\tstruct uvcg_format_ptr *format_ptr;\n\tint i, ret = -EINVAL;\n\n\tsrc_hdr = to_uvcg_streaming_header(src);\n\tmutex_lock(su_mutex);  \n\n\topts_item = src->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\n\tif (src_hdr->linked) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (src->ci_parent->ci_parent != target->ci_parent->ci_parent)\n\t\tgoto out;\n\n\tfor (i = 0; i < ARRAY_SIZE(uvcg_format_names); ++i) {\n\t\tif (!strcmp(target->ci_parent->ci_name, uvcg_format_names[i]))\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(uvcg_format_names))\n\t\tgoto out;\n\n\ttarget_fmt = container_of(to_config_group(target), struct uvcg_format,\n\t\t\t\t  group);\n\n\tuvcg_format_set_indices(to_config_group(target));\n\n\tformat_ptr = kzalloc(sizeof(*format_ptr), GFP_KERNEL);\n\tif (!format_ptr) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = 0;\n\tformat_ptr->fmt = target_fmt;\n\tlist_add_tail(&format_ptr->entry, &src_hdr->formats);\n\t++src_hdr->num_fmt;\n\t++target_fmt->linked;\n\nout:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nstatic void uvcg_streaming_header_drop_link(struct config_item *src,\n\t\t\t\t\t   struct config_item *target)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tstruct uvcg_streaming_header *src_hdr;\n\tstruct uvcg_format *target_fmt = NULL;\n\tstruct uvcg_format_ptr *format_ptr, *tmp;\n\n\tsrc_hdr = to_uvcg_streaming_header(src);\n\tmutex_lock(su_mutex);  \n\n\topts_item = src->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\ttarget_fmt = container_of(to_config_group(target), struct uvcg_format,\n\t\t\t\t  group);\n\n\tlist_for_each_entry_safe(format_ptr, tmp, &src_hdr->formats, entry)\n\t\tif (format_ptr->fmt == target_fmt) {\n\t\t\tlist_del(&format_ptr->entry);\n\t\t\tkfree(format_ptr);\n\t\t\t--src_hdr->num_fmt;\n\t\t\tbreak;\n\t\t}\n\n\t--target_fmt->linked;\n\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n}\n\nstatic struct configfs_item_operations uvcg_streaming_header_item_ops = {\n\t.release\t= uvcg_config_item_release,\n\t.allow_link\t= uvcg_streaming_header_allow_link,\n\t.drop_link\t= uvcg_streaming_header_drop_link,\n};\n\n#define UVCG_STREAMING_HEADER_ATTR(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_streaming_header_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_streaming_header *sh = to_uvcg_streaming_header(item); \\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &sh->item.ci_group->cg_subsys->su_mutex;\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = sh->item.ci_parent->ci_parent->ci_parent;\t\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(sh->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_streaming_header_, cname, aname)\n\nUVCG_STREAMING_HEADER_ATTR(bm_info, bmInfo, 8);\nUVCG_STREAMING_HEADER_ATTR(b_terminal_link, bTerminalLink, 8);\nUVCG_STREAMING_HEADER_ATTR(b_still_capture_method, bStillCaptureMethod, 8);\nUVCG_STREAMING_HEADER_ATTR(b_trigger_support, bTriggerSupport, 8);\nUVCG_STREAMING_HEADER_ATTR(b_trigger_usage, bTriggerUsage, 8);\n\n#undef UVCG_STREAMING_HEADER_ATTR\n\nstatic struct configfs_attribute *uvcg_streaming_header_attrs[] = {\n\t&uvcg_streaming_header_attr_bm_info,\n\t&uvcg_streaming_header_attr_b_terminal_link,\n\t&uvcg_streaming_header_attr_b_still_capture_method,\n\t&uvcg_streaming_header_attr_b_trigger_support,\n\t&uvcg_streaming_header_attr_b_trigger_usage,\n\tNULL,\n};\n\nstatic const struct config_item_type uvcg_streaming_header_type = {\n\t.ct_item_ops\t= &uvcg_streaming_header_item_ops,\n\t.ct_attrs\t= uvcg_streaming_header_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item\n*uvcg_streaming_header_make(struct config_group *group, const char *name)\n{\n\tstruct uvcg_streaming_header *h;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_LIST_HEAD(&h->formats);\n\th->desc.bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\th->desc.bDescriptorSubType\t= UVC_VS_INPUT_HEADER;\n\th->desc.bTerminalLink\t\t= 3;\n\th->desc.bControlSize\t\t= UVCG_STREAMING_CONTROL_SIZE;\n\n\tconfig_item_init_type_name(&h->item, name, &uvcg_streaming_header_type);\n\n\treturn &h->item;\n}\n\nstatic struct configfs_group_operations uvcg_streaming_header_grp_ops = {\n\t.make_item\t\t= uvcg_streaming_header_make,\n};\n\nstatic const struct uvcg_config_group_type uvcg_streaming_header_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_streaming_header_grp_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"header\",\n};\n\n \n\n#define UVCG_FRAME_ATTR(cname, aname, bits) \\\nstatic ssize_t uvcg_frame_##cname##_show(struct config_item *item, char *page)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_frame *f = to_uvcg_frame(item);\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &f->item.ci_group->cg_subsys->su_mutex;\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = f->item.ci_parent->ci_parent->ci_parent->ci_parent;\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", f->frame.cname);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t  uvcg_frame_##cname##_store(struct config_item *item,\t\\\n\t\t\t\t\t   const char *page, size_t len)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_frame *f = to_uvcg_frame(item);\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct uvcg_format *fmt;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &f->item.ci_group->cg_subsys->su_mutex;\\\n\ttypeof(f->frame.cname) num;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou##bits(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = f->item.ci_parent->ci_parent->ci_parent->ci_parent;\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\tfmt = to_uvcg_format(f->item.ci_parent);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (fmt->linked || opts->refcnt) {\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tf->frame.cname = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(uvcg_frame_, cname, aname);\n\nstatic ssize_t uvcg_frame_b_frame_index_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tstruct uvcg_frame *f = to_uvcg_frame(item);\n\tstruct uvcg_format *fmt;\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct config_item *fmt_item;\n\tstruct mutex *su_mutex = &f->item.ci_group->cg_subsys->su_mutex;\n\tint result;\n\n\tmutex_lock(su_mutex);  \n\n\tfmt_item = f->item.ci_parent;\n\tfmt = to_uvcg_format(fmt_item);\n\n\tif (!fmt->linked) {\n\t\tresult = -EBUSY;\n\t\tgoto out;\n\t}\n\n\topts_item = fmt_item->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%u\\n\", f->frame.b_frame_index);\n\tmutex_unlock(&opts->lock);\n\nout:\n\tmutex_unlock(su_mutex);\n\treturn result;\n}\n\nUVC_ATTR_RO(uvcg_frame_, b_frame_index, bFrameIndex);\n\nUVCG_FRAME_ATTR(bm_capabilities, bmCapabilities, 8);\nUVCG_FRAME_ATTR(w_width, wWidth, 16);\nUVCG_FRAME_ATTR(w_height, wHeight, 16);\nUVCG_FRAME_ATTR(dw_min_bit_rate, dwMinBitRate, 32);\nUVCG_FRAME_ATTR(dw_max_bit_rate, dwMaxBitRate, 32);\nUVCG_FRAME_ATTR(dw_max_video_frame_buffer_size, dwMaxVideoFrameBufferSize, 32);\nUVCG_FRAME_ATTR(dw_default_frame_interval, dwDefaultFrameInterval, 32);\n\n#undef UVCG_FRAME_ATTR\n\nstatic ssize_t uvcg_frame_dw_frame_interval_show(struct config_item *item,\n\t\t\t\t\t\t char *page)\n{\n\tstruct uvcg_frame *frm = to_uvcg_frame(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &frm->item.ci_group->cg_subsys->su_mutex;\n\tint result, i;\n\tchar *pg = page;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = frm->item.ci_parent->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tfor (result = 0, i = 0; i < frm->frame.b_frame_interval_type; ++i) {\n\t\tresult += sprintf(pg, \"%u\\n\", frm->dw_frame_interval[i]);\n\t\tpg = page + result;\n\t}\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\treturn result;\n}\n\nstatic ssize_t uvcg_frame_dw_frame_interval_store(struct config_item *item,\n\t\t\t\t\t\t  const char *page, size_t len)\n{\n\tstruct uvcg_frame *ch = to_uvcg_frame(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct uvcg_format *fmt;\n\tstruct mutex *su_mutex = &ch->item.ci_group->cg_subsys->su_mutex;\n\tint ret = 0, n = 0;\n\tu32 *frm_intrv, *tmp;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = ch->item.ci_parent->ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\tfmt = to_uvcg_format(ch->item.ci_parent);\n\n\tmutex_lock(&opts->lock);\n\tif (fmt->linked || opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_count_item_entries, &n, sizeof(u32));\n\tif (ret)\n\t\tgoto end;\n\n\ttmp = frm_intrv = kcalloc(n, sizeof(u32), GFP_KERNEL);\n\tif (!frm_intrv) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\n\tret = __uvcg_iter_item_entries(page, len, __uvcg_fill_item_entries, &tmp, sizeof(u32));\n\tif (ret) {\n\t\tkfree(frm_intrv);\n\t\tgoto end;\n\t}\n\n\tkfree(ch->dw_frame_interval);\n\tch->dw_frame_interval = frm_intrv;\n\tch->frame.b_frame_interval_type = n;\n\tsort(ch->dw_frame_interval, n, sizeof(*ch->dw_frame_interval),\n\t     uvcg_config_compare_u32, NULL);\n\tret = len;\n\nend:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nUVC_ATTR(uvcg_frame_, dw_frame_interval, dwFrameInterval);\n\nstatic struct configfs_attribute *uvcg_frame_attrs[] = {\n\t&uvcg_frame_attr_b_frame_index,\n\t&uvcg_frame_attr_bm_capabilities,\n\t&uvcg_frame_attr_w_width,\n\t&uvcg_frame_attr_w_height,\n\t&uvcg_frame_attr_dw_min_bit_rate,\n\t&uvcg_frame_attr_dw_max_bit_rate,\n\t&uvcg_frame_attr_dw_max_video_frame_buffer_size,\n\t&uvcg_frame_attr_dw_default_frame_interval,\n\t&uvcg_frame_attr_dw_frame_interval,\n\tNULL,\n};\n\nstatic const struct config_item_type uvcg_frame_type = {\n\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t.ct_attrs\t= uvcg_frame_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item *uvcg_frame_make(struct config_group *group,\n\t\t\t\t\t   const char *name)\n{\n\tstruct uvcg_frame *h;\n\tstruct uvcg_format *fmt;\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct uvcg_frame_ptr *frame_ptr;\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\th->frame.b_descriptor_type\t\t= USB_DT_CS_INTERFACE;\n\th->frame.b_frame_index\t\t\t= 1;\n\th->frame.w_width\t\t\t= 640;\n\th->frame.w_height\t\t\t= 360;\n\th->frame.dw_min_bit_rate\t\t= 18432000;\n\th->frame.dw_max_bit_rate\t\t= 55296000;\n\th->frame.dw_max_video_frame_buffer_size\t= 460800;\n\th->frame.dw_default_frame_interval\t= 666666;\n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tfmt = to_uvcg_format(&group->cg_item);\n\tif (fmt->type == UVCG_UNCOMPRESSED) {\n\t\th->frame.b_descriptor_subtype = UVC_VS_FRAME_UNCOMPRESSED;\n\t\th->fmt_type = UVCG_UNCOMPRESSED;\n\t} else if (fmt->type == UVCG_MJPEG) {\n\t\th->frame.b_descriptor_subtype = UVC_VS_FRAME_MJPEG;\n\t\th->fmt_type = UVCG_MJPEG;\n\t} else {\n\t\tmutex_unlock(&opts->lock);\n\t\tkfree(h);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tframe_ptr = kzalloc(sizeof(*frame_ptr), GFP_KERNEL);\n\tif (!frame_ptr) {\n\t\tmutex_unlock(&opts->lock);\n\t\tkfree(h);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tframe_ptr->frm = h;\n\tlist_add_tail(&frame_ptr->entry, &fmt->frames);\n\t++fmt->num_frames;\n\tmutex_unlock(&opts->lock);\n\n\tconfig_item_init_type_name(&h->item, name, &uvcg_frame_type);\n\n\treturn &h->item;\n}\n\nstatic void uvcg_frame_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct uvcg_format *fmt;\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct uvcg_frame *target_frm = NULL;\n\tstruct uvcg_frame_ptr *frame_ptr, *tmp;\n\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\ttarget_frm = container_of(item, struct uvcg_frame, item);\n\tfmt = to_uvcg_format(&group->cg_item);\n\n\tlist_for_each_entry_safe(frame_ptr, tmp, &fmt->frames, entry)\n\t\tif (frame_ptr->frm == target_frm) {\n\t\t\tlist_del(&frame_ptr->entry);\n\t\t\tkfree(frame_ptr);\n\t\t\t--fmt->num_frames;\n\t\t\tbreak;\n\t\t}\n\tmutex_unlock(&opts->lock);\n\n\tconfig_item_put(item);\n}\n\nstatic void uvcg_format_set_indices(struct config_group *fmt)\n{\n\tstruct config_item *ci;\n\tunsigned int i = 1;\n\n\tlist_for_each_entry(ci, &fmt->cg_children, ci_entry) {\n\t\tstruct uvcg_frame *frm;\n\n\t\tif (ci->ci_type != &uvcg_frame_type)\n\t\t\tcontinue;\n\n\t\tfrm = to_uvcg_frame(ci);\n\t\tfrm->frame.b_frame_index = i++;\n\t}\n}\n\n \n\nstatic struct configfs_group_operations uvcg_uncompressed_group_ops = {\n\t.make_item\t\t= uvcg_frame_make,\n\t.drop_item\t\t= uvcg_frame_drop,\n};\n\nstatic ssize_t uvcg_uncompressed_guid_format_show(struct config_item *item,\n\t\t\t\t\t\t\tchar *page)\n{\n\tstruct uvcg_uncompressed *ch = to_uvcg_uncompressed(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tmemcpy(page, ch->desc.guidFormat, sizeof(ch->desc.guidFormat));\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn sizeof(ch->desc.guidFormat);\n}\n\nstatic ssize_t uvcg_uncompressed_guid_format_store(struct config_item *item,\n\t\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct uvcg_uncompressed *ch = to_uvcg_uncompressed(item);\n\tstruct f_uvc_opts *opts;\n\tstruct config_item *opts_item;\n\tstruct mutex *su_mutex = &ch->fmt.group.cg_subsys->su_mutex;\n\tint ret;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = ch->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tif (ch->fmt.linked || opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tmemcpy(ch->desc.guidFormat, page,\n\t       min(sizeof(ch->desc.guidFormat), len));\n\tret = sizeof(ch->desc.guidFormat);\n\nend:\n\tmutex_unlock(&opts->lock);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nUVC_ATTR(uvcg_uncompressed_, guid_format, guidFormat);\n\n#define UVCG_UNCOMPRESSED_ATTR_RO(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_uncompressed_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_uncompressed *u = to_uvcg_uncompressed(item);\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(u->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_uncompressed_, cname, aname);\n\n#define UVCG_UNCOMPRESSED_ATTR(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_uncompressed_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_uncompressed *u = to_uvcg_uncompressed(item);\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(u->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nuvcg_uncompressed_##cname##_store(struct config_item *item,\t\t\\\n\t\t\t\t    const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_uncompressed *u = to_uvcg_uncompressed(item);\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu8 num;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (u->fmt.linked || opts->refcnt) {\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou8(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tif (!num) {\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tu->desc.aname = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(uvcg_uncompressed_, cname, aname);\n\nUVCG_UNCOMPRESSED_ATTR_RO(b_format_index, bFormatIndex, 8);\nUVCG_UNCOMPRESSED_ATTR(b_bits_per_pixel, bBitsPerPixel, 8);\nUVCG_UNCOMPRESSED_ATTR(b_default_frame_index, bDefaultFrameIndex, 8);\nUVCG_UNCOMPRESSED_ATTR_RO(b_aspect_ratio_x, bAspectRatioX, 8);\nUVCG_UNCOMPRESSED_ATTR_RO(b_aspect_ratio_y, bAspectRatioY, 8);\nUVCG_UNCOMPRESSED_ATTR_RO(bm_interlace_flags, bmInterlaceFlags, 8);\n\n#undef UVCG_UNCOMPRESSED_ATTR\n#undef UVCG_UNCOMPRESSED_ATTR_RO\n\nstatic inline ssize_t\nuvcg_uncompressed_bma_controls_show(struct config_item *item, char *page)\n{\n\tstruct uvcg_uncompressed *unc = to_uvcg_uncompressed(item);\n\treturn uvcg_format_bma_controls_show(&unc->fmt, page);\n}\n\nstatic inline ssize_t\nuvcg_uncompressed_bma_controls_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t len)\n{\n\tstruct uvcg_uncompressed *unc = to_uvcg_uncompressed(item);\n\treturn uvcg_format_bma_controls_store(&unc->fmt, page, len);\n}\n\nUVC_ATTR(uvcg_uncompressed_, bma_controls, bmaControls);\n\nstatic struct configfs_attribute *uvcg_uncompressed_attrs[] = {\n\t&uvcg_uncompressed_attr_b_format_index,\n\t&uvcg_uncompressed_attr_guid_format,\n\t&uvcg_uncompressed_attr_b_bits_per_pixel,\n\t&uvcg_uncompressed_attr_b_default_frame_index,\n\t&uvcg_uncompressed_attr_b_aspect_ratio_x,\n\t&uvcg_uncompressed_attr_b_aspect_ratio_y,\n\t&uvcg_uncompressed_attr_bm_interlace_flags,\n\t&uvcg_uncompressed_attr_bma_controls,\n\tNULL,\n};\n\nstatic const struct config_item_type uvcg_uncompressed_type = {\n\t.ct_item_ops\t= &uvcg_format_item_operations,\n\t.ct_group_ops\t= &uvcg_uncompressed_group_ops,\n\t.ct_attrs\t= uvcg_uncompressed_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *uvcg_uncompressed_make(struct config_group *group,\n\t\t\t\t\t\t   const char *name)\n{\n\tstatic char guid[] = {\n\t\t'Y',  'U',  'Y',  '2', 0x00, 0x00, 0x10, 0x00,\n\t\t 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71\n\t};\n\tstruct uvcg_color_matching *color_match;\n\tstruct config_item *streaming;\n\tstruct uvcg_uncompressed *h;\n\n\tstreaming = group->cg_item.ci_parent;\n\tcolor_match = uvcg_format_get_default_color_match(streaming);\n\tif (!color_match)\n\t\treturn ERR_PTR(-EINVAL);\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\th->desc.bLength\t\t\t= UVC_DT_FORMAT_UNCOMPRESSED_SIZE;\n\th->desc.bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\th->desc.bDescriptorSubType\t= UVC_VS_FORMAT_UNCOMPRESSED;\n\tmemcpy(h->desc.guidFormat, guid, sizeof(guid));\n\th->desc.bBitsPerPixel\t\t= 16;\n\th->desc.bDefaultFrameIndex\t= 1;\n\th->desc.bAspectRatioX\t\t= 0;\n\th->desc.bAspectRatioY\t\t= 0;\n\th->desc.bmInterlaceFlags\t= 0;\n\th->desc.bCopyProtect\t\t= 0;\n\n\tINIT_LIST_HEAD(&h->fmt.frames);\n\th->fmt.type = UVCG_UNCOMPRESSED;\n\th->fmt.color_matching = color_match;\n\tcolor_match->refcnt++;\n\tconfig_group_init_type_name(&h->fmt.group, name,\n\t\t\t\t    &uvcg_uncompressed_type);\n\n\treturn &h->fmt.group;\n}\n\nstatic struct configfs_group_operations uvcg_uncompressed_grp_ops = {\n\t.make_group\t\t= uvcg_uncompressed_make,\n};\n\nstatic const struct uvcg_config_group_type uvcg_uncompressed_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_uncompressed_grp_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"uncompressed\",\n};\n\n \n\nstatic struct configfs_group_operations uvcg_mjpeg_group_ops = {\n\t.make_item\t\t= uvcg_frame_make,\n\t.drop_item\t\t= uvcg_frame_drop,\n};\n\n#define UVCG_MJPEG_ATTR_RO(cname, aname, bits)\t\t\t\t\\\nstatic ssize_t uvcg_mjpeg_##cname##_show(struct config_item *item, char *page)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_mjpeg *u = to_uvcg_mjpeg(item);\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(u->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR_RO(uvcg_mjpeg_, cname, aname)\n\n#define UVCG_MJPEG_ATTR(cname, aname, bits)\t\t\t\t\\\nstatic ssize_t uvcg_mjpeg_##cname##_show(struct config_item *item, char *page)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_mjpeg *u = to_uvcg_mjpeg(item);\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", le##bits##_to_cpu(u->desc.aname));\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nuvcg_mjpeg_##cname##_store(struct config_item *item,\t\t\t\\\n\t\t\t   const char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct uvcg_mjpeg *u = to_uvcg_mjpeg(item);\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &u->fmt.group.cg_subsys->su_mutex;\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu8 num;\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = u->fmt.group.cg_item.ci_parent->ci_parent->ci_parent;\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (u->fmt.linked || opts->refcnt) {\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou8(page, 0, &num);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t \t\t\t\t\\\n\tif (!num) {\t\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tu->desc.aname = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(uvcg_mjpeg_, cname, aname)\n\nUVCG_MJPEG_ATTR_RO(b_format_index, bFormatIndex, 8);\nUVCG_MJPEG_ATTR(b_default_frame_index, bDefaultFrameIndex, 8);\nUVCG_MJPEG_ATTR_RO(bm_flags, bmFlags, 8);\nUVCG_MJPEG_ATTR_RO(b_aspect_ratio_x, bAspectRatioX, 8);\nUVCG_MJPEG_ATTR_RO(b_aspect_ratio_y, bAspectRatioY, 8);\nUVCG_MJPEG_ATTR_RO(bm_interlace_flags, bmInterlaceFlags, 8);\n\n#undef UVCG_MJPEG_ATTR\n#undef UVCG_MJPEG_ATTR_RO\n\nstatic inline ssize_t\nuvcg_mjpeg_bma_controls_show(struct config_item *item, char *page)\n{\n\tstruct uvcg_mjpeg *u = to_uvcg_mjpeg(item);\n\treturn uvcg_format_bma_controls_show(&u->fmt, page);\n}\n\nstatic inline ssize_t\nuvcg_mjpeg_bma_controls_store(struct config_item *item,\n\t\t\t\t     const char *page, size_t len)\n{\n\tstruct uvcg_mjpeg *u = to_uvcg_mjpeg(item);\n\treturn uvcg_format_bma_controls_store(&u->fmt, page, len);\n}\n\nUVC_ATTR(uvcg_mjpeg_, bma_controls, bmaControls);\n\nstatic struct configfs_attribute *uvcg_mjpeg_attrs[] = {\n\t&uvcg_mjpeg_attr_b_format_index,\n\t&uvcg_mjpeg_attr_b_default_frame_index,\n\t&uvcg_mjpeg_attr_bm_flags,\n\t&uvcg_mjpeg_attr_b_aspect_ratio_x,\n\t&uvcg_mjpeg_attr_b_aspect_ratio_y,\n\t&uvcg_mjpeg_attr_bm_interlace_flags,\n\t&uvcg_mjpeg_attr_bma_controls,\n\tNULL,\n};\n\nstatic const struct config_item_type uvcg_mjpeg_type = {\n\t.ct_item_ops\t= &uvcg_format_item_operations,\n\t.ct_group_ops\t= &uvcg_mjpeg_group_ops,\n\t.ct_attrs\t= uvcg_mjpeg_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *uvcg_mjpeg_make(struct config_group *group,\n\t\t\t\t\t\t   const char *name)\n{\n\tstruct uvcg_color_matching *color_match;\n\tstruct config_item *streaming;\n\tstruct uvcg_mjpeg *h;\n\n\tstreaming = group->cg_item.ci_parent;\n\tcolor_match = uvcg_format_get_default_color_match(streaming);\n\tif (!color_match)\n\t\treturn ERR_PTR(-EINVAL);\n\n\th = kzalloc(sizeof(*h), GFP_KERNEL);\n\tif (!h)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\th->desc.bLength\t\t\t= UVC_DT_FORMAT_MJPEG_SIZE;\n\th->desc.bDescriptorType\t\t= USB_DT_CS_INTERFACE;\n\th->desc.bDescriptorSubType\t= UVC_VS_FORMAT_MJPEG;\n\th->desc.bDefaultFrameIndex\t= 1;\n\th->desc.bAspectRatioX\t\t= 0;\n\th->desc.bAspectRatioY\t\t= 0;\n\th->desc.bmInterlaceFlags\t= 0;\n\th->desc.bCopyProtect\t\t= 0;\n\n\tINIT_LIST_HEAD(&h->fmt.frames);\n\th->fmt.type = UVCG_MJPEG;\n\th->fmt.color_matching = color_match;\n\tcolor_match->refcnt++;\n\tconfig_group_init_type_name(&h->fmt.group, name,\n\t\t\t\t    &uvcg_mjpeg_type);\n\n\treturn &h->fmt.group;\n}\n\nstatic struct configfs_group_operations uvcg_mjpeg_grp_ops = {\n\t.make_group\t\t= uvcg_mjpeg_make,\n};\n\nstatic const struct uvcg_config_group_type uvcg_mjpeg_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_mjpeg_grp_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"mjpeg\",\n};\n\n \n\n#define UVCG_COLOR_MATCHING_ATTR(cname, aname, bits)\t\t\t\\\nstatic ssize_t uvcg_color_matching_##cname##_show(\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct uvcg_color_matching *color_match =\t\t\t\\\n\t\tto_uvcg_color_matching(group);\t\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\",\t\t\t\t\t\\\n\t\t\t le##bits##_to_cpu(color_match->desc.aname));\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t uvcg_color_matching_##cname##_store(\t\t\t\\\n\tstruct config_item *item, const char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct config_group *group = to_config_group(item);\t\t\\\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\t\t\\\n\tstruct uvcg_color_matching *color_match =\t\t\t\\\n\t\tto_uvcg_color_matching(group);\t\t\t\t\\\n\tstruct f_uvc_opts *opts;\t\t\t\t\t\\\n\tstruct config_item *opts_item;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tu##bits num;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtou##bits(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(su_mutex);  \t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (color_match->refcnt) {\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto unlock_su;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\topts_item = group->cg_item.ci_parent->ci_parent->ci_parent;\t\\\n\topts = to_f_uvc_opts(opts_item);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tcolor_match->desc.aname = num;\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\nunlock_su:\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(su_mutex);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(uvcg_color_matching_, cname, aname)\n\nUVCG_COLOR_MATCHING_ATTR(b_color_primaries, bColorPrimaries, 8);\nUVCG_COLOR_MATCHING_ATTR(b_transfer_characteristics, bTransferCharacteristics, 8);\nUVCG_COLOR_MATCHING_ATTR(b_matrix_coefficients, bMatrixCoefficients, 8);\n\n#undef UVCG_COLOR_MATCHING_ATTR\n\nstatic struct configfs_attribute *uvcg_color_matching_attrs[] = {\n\t&uvcg_color_matching_attr_b_color_primaries,\n\t&uvcg_color_matching_attr_b_transfer_characteristics,\n\t&uvcg_color_matching_attr_b_matrix_coefficients,\n\tNULL,\n};\n\nstatic void uvcg_color_matching_release(struct config_item *item)\n{\n\tstruct uvcg_color_matching *color_match =\n\t\tto_uvcg_color_matching(to_config_group(item));\n\n\tkfree(color_match);\n}\n\nstatic struct configfs_item_operations uvcg_color_matching_item_ops = {\n\t.release\t= uvcg_color_matching_release,\n};\n\nstatic const struct config_item_type uvcg_color_matching_type = {\n\t.ct_item_ops\t= &uvcg_color_matching_item_ops,\n\t.ct_attrs\t= uvcg_color_matching_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstatic struct config_group *uvcg_color_matching_make(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct uvcg_color_matching *color_match;\n\n\tcolor_match = kzalloc(sizeof(*color_match), GFP_KERNEL);\n\tif (!color_match)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcolor_match->desc.bLength = UVC_DT_COLOR_MATCHING_SIZE;\n\tcolor_match->desc.bDescriptorType = USB_DT_CS_INTERFACE;\n\tcolor_match->desc.bDescriptorSubType = UVC_VS_COLORFORMAT;\n\n\tconfig_group_init_type_name(&color_match->group, name,\n\t\t\t\t    &uvcg_color_matching_type);\n\n\treturn &color_match->group;\n}\n\nstatic struct configfs_group_operations uvcg_color_matching_grp_group_ops = {\n\t.make_group\t= uvcg_color_matching_make,\n};\n\nstatic int uvcg_color_matching_create_children(struct config_group *parent)\n{\n\tstruct uvcg_color_matching *color_match;\n\n\tcolor_match = kzalloc(sizeof(*color_match), GFP_KERNEL);\n\tif (!color_match)\n\t\treturn -ENOMEM;\n\n\tcolor_match->desc.bLength = UVC_DT_COLOR_MATCHING_SIZE;\n\tcolor_match->desc.bDescriptorType = USB_DT_CS_INTERFACE;\n\tcolor_match->desc.bDescriptorSubType = UVC_VS_COLORFORMAT;\n\tcolor_match->desc.bColorPrimaries = UVC_COLOR_PRIMARIES_BT_709_SRGB;\n\tcolor_match->desc.bTransferCharacteristics = UVC_TRANSFER_CHARACTERISTICS_BT_709;\n\tcolor_match->desc.bMatrixCoefficients = UVC_MATRIX_COEFFICIENTS_SMPTE_170M;\n\n\tconfig_group_init_type_name(&color_match->group, \"default\",\n\t\t\t\t    &uvcg_color_matching_type);\n\tconfigfs_add_default_group(&color_match->group, parent);\n\n\treturn 0;\n}\n\nstatic const struct uvcg_config_group_type uvcg_color_matching_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_group_ops\t= &uvcg_color_matching_grp_group_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"color_matching\",\n\t.create_children = uvcg_color_matching_create_children,\n};\n\n \n\nstruct uvcg_streaming_class_group {\n\tstruct config_group group;\n\tconst char *name;\n};\n\nstatic inline struct uvc_descriptor_header\n***__uvcg_get_stream_class_arr(struct config_item *i, struct f_uvc_opts *o)\n{\n\tstruct uvcg_streaming_class_group *group =\n\t\tcontainer_of(i, struct uvcg_streaming_class_group,\n\t\t\t     group.cg_item);\n\n\tif (!strcmp(group->name, \"fs\"))\n\t\treturn &o->uvc_fs_streaming_cls;\n\n\tif (!strcmp(group->name, \"hs\"))\n\t\treturn &o->uvc_hs_streaming_cls;\n\n\tif (!strcmp(group->name, \"ss\"))\n\t\treturn &o->uvc_ss_streaming_cls;\n\n\treturn NULL;\n}\n\nenum uvcg_strm_type {\n\tUVCG_HEADER = 0,\n\tUVCG_FORMAT,\n\tUVCG_FRAME,\n\tUVCG_COLOR_MATCHING,\n};\n\n \nstatic int __uvcg_iter_strm_cls(struct uvcg_streaming_header *h,\n\tvoid *priv2, void *priv3,\n\tint (*fun)(void *, void *, void *, int, enum uvcg_strm_type type))\n{\n\tstruct uvcg_format_ptr *f;\n\tstruct config_group *grp;\n\tstruct config_item *item;\n\tstruct uvcg_frame *frm;\n\tint ret, i, j;\n\n\tif (!fun)\n\t\treturn -EINVAL;\n\n\ti = j = 0;\n\tret = fun(h, priv2, priv3, 0, UVCG_HEADER);\n\tif (ret)\n\t\treturn ret;\n\tlist_for_each_entry(f, &h->formats, entry) {\n\t\tret = fun(f->fmt, priv2, priv3, i++, UVCG_FORMAT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tgrp = &f->fmt->group;\n\t\tlist_for_each_entry(item, &grp->cg_children, ci_entry) {\n\t\t\tfrm = to_uvcg_frame(item);\n\t\t\tret = fun(frm, priv2, priv3, j++, UVCG_FRAME);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = fun(f->fmt->color_matching, priv2, priv3, 0,\n\t\t\t  UVCG_COLOR_MATCHING);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,\n\t\t\t   enum uvcg_strm_type type)\n{\n\tsize_t *size = priv2;\n\tsize_t *count = priv3;\n\n\tswitch (type) {\n\tcase UVCG_HEADER: {\n\t\tstruct uvcg_streaming_header *h = priv1;\n\n\t\t*size += sizeof(h->desc);\n\t\t \n\t\t*size += h->num_fmt * UVCG_STREAMING_CONTROL_SIZE;\n\t}\n\tbreak;\n\tcase UVCG_FORMAT: {\n\t\tstruct uvcg_format *fmt = priv1;\n\n\t\tif (fmt->type == UVCG_UNCOMPRESSED) {\n\t\t\tstruct uvcg_uncompressed *u =\n\t\t\t\tcontainer_of(fmt, struct uvcg_uncompressed,\n\t\t\t\t\t     fmt);\n\n\t\t\t*size += sizeof(u->desc);\n\t\t} else if (fmt->type == UVCG_MJPEG) {\n\t\t\tstruct uvcg_mjpeg *m =\n\t\t\t\tcontainer_of(fmt, struct uvcg_mjpeg, fmt);\n\n\t\t\t*size += sizeof(m->desc);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tbreak;\n\tcase UVCG_FRAME: {\n\t\tstruct uvcg_frame *frm = priv1;\n\t\tint sz = sizeof(frm->dw_frame_interval);\n\n\t\t*size += sizeof(frm->frame);\n\t\t*size += frm->frame.b_frame_interval_type * sz;\n\t}\n\tbreak;\n\tcase UVCG_COLOR_MATCHING: {\n\t\tstruct uvcg_color_matching *color_match = priv1;\n\n\t\t*size += sizeof(color_match->desc);\n\t}\n\tbreak;\n\t}\n\n\t++*count;\n\n\treturn 0;\n}\n\n \nstatic int __uvcg_fill_strm(void *priv1, void *priv2, void *priv3, int n,\n\t\t\t    enum uvcg_strm_type type)\n{\n\tvoid **dest = priv2;\n\tstruct uvc_descriptor_header ***array = priv3;\n\tsize_t sz;\n\n\t**array = *dest;\n\t++*array;\n\n\tswitch (type) {\n\tcase UVCG_HEADER: {\n\t\tstruct uvc_input_header_descriptor *ihdr = *dest;\n\t\tstruct uvcg_streaming_header *h = priv1;\n\t\tstruct uvcg_format_ptr *f;\n\n\t\tmemcpy(*dest, &h->desc, sizeof(h->desc));\n\t\t*dest += sizeof(h->desc);\n\t\tsz = UVCG_STREAMING_CONTROL_SIZE;\n\t\tlist_for_each_entry(f, &h->formats, entry) {\n\t\t\tmemcpy(*dest, f->fmt->bmaControls, sz);\n\t\t\t*dest += sz;\n\t\t}\n\t\tihdr->bLength = sizeof(h->desc) + h->num_fmt * sz;\n\t\tihdr->bNumFormats = h->num_fmt;\n\t}\n\tbreak;\n\tcase UVCG_FORMAT: {\n\t\tstruct uvcg_format *fmt = priv1;\n\n\t\tif (fmt->type == UVCG_UNCOMPRESSED) {\n\t\t\tstruct uvcg_uncompressed *u =\n\t\t\t\tcontainer_of(fmt, struct uvcg_uncompressed,\n\t\t\t\t\t     fmt);\n\n\t\t\tu->desc.bFormatIndex = n + 1;\n\t\t\tu->desc.bNumFrameDescriptors = fmt->num_frames;\n\t\t\tmemcpy(*dest, &u->desc, sizeof(u->desc));\n\t\t\t*dest += sizeof(u->desc);\n\t\t} else if (fmt->type == UVCG_MJPEG) {\n\t\t\tstruct uvcg_mjpeg *m =\n\t\t\t\tcontainer_of(fmt, struct uvcg_mjpeg, fmt);\n\n\t\t\tm->desc.bFormatIndex = n + 1;\n\t\t\tm->desc.bNumFrameDescriptors = fmt->num_frames;\n\t\t\tmemcpy(*dest, &m->desc, sizeof(m->desc));\n\t\t\t*dest += sizeof(m->desc);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tbreak;\n\tcase UVCG_FRAME: {\n\t\tstruct uvcg_frame *frm = priv1;\n\t\tstruct uvc_descriptor_header *h = *dest;\n\n\t\tsz = sizeof(frm->frame);\n\t\tmemcpy(*dest, &frm->frame, sz);\n\t\t*dest += sz;\n\t\tsz = frm->frame.b_frame_interval_type *\n\t\t\tsizeof(*frm->dw_frame_interval);\n\t\tmemcpy(*dest, frm->dw_frame_interval, sz);\n\t\t*dest += sz;\n\t\tif (frm->fmt_type == UVCG_UNCOMPRESSED)\n\t\t\th->bLength = UVC_DT_FRAME_UNCOMPRESSED_SIZE(\n\t\t\t\tfrm->frame.b_frame_interval_type);\n\t\telse if (frm->fmt_type == UVCG_MJPEG)\n\t\t\th->bLength = UVC_DT_FRAME_MJPEG_SIZE(\n\t\t\t\tfrm->frame.b_frame_interval_type);\n\t}\n\tbreak;\n\tcase UVCG_COLOR_MATCHING: {\n\t\tstruct uvcg_color_matching *color_match = priv1;\n\n\t\tmemcpy(*dest, &color_match->desc, sizeof(color_match->desc));\n\t\t*dest += sizeof(color_match->desc);\n\t}\n\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int uvcg_streaming_class_allow_link(struct config_item *src,\n\t\t\t\t\t   struct config_item *target)\n{\n\tstruct config_item *streaming, *header;\n\tstruct f_uvc_opts *opts;\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvc_descriptor_header ***class_array, **cl_arr;\n\tstruct uvcg_streaming_header *target_hdr;\n\tvoid *data, *data_save;\n\tsize_t size = 0, count = 0;\n\tint ret = -EINVAL;\n\n\tmutex_lock(su_mutex);  \n\n\tstreaming = src->ci_parent->ci_parent;\n\theader = config_group_find_item(to_config_group(streaming), \"header\");\n\tif (!header || target->ci_parent != header)\n\t\tgoto out;\n\n\topts = to_f_uvc_opts(streaming->ci_parent);\n\n\tmutex_lock(&opts->lock);\n\n\tclass_array = __uvcg_get_stream_class_arr(src, opts);\n\tif (!class_array || *class_array || opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\ttarget_hdr = to_uvcg_streaming_header(target);\n\tret = __uvcg_iter_strm_cls(target_hdr, &size, &count, __uvcg_cnt_strm);\n\tif (ret)\n\t\tgoto unlock;\n\n\tcount += 1;  \n\t*class_array = kcalloc(count, sizeof(void *), GFP_KERNEL);\n\tif (!*class_array) {\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tdata = data_save = kzalloc(size, GFP_KERNEL);\n\tif (!data) {\n\t\tkfree(*class_array);\n\t\t*class_array = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\tcl_arr = *class_array;\n\tret = __uvcg_iter_strm_cls(target_hdr, &data, &cl_arr,\n\t\t\t\t   __uvcg_fill_strm);\n\tif (ret) {\n\t\tkfree(*class_array);\n\t\t*class_array = NULL;\n\t\t \n\t\tkfree(data_save);\n\t\tgoto unlock;\n\t}\n\n\t++target_hdr->linked;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&opts->lock);\nout:\n\tconfig_item_put(header);\n\tmutex_unlock(su_mutex);\n\treturn ret;\n}\n\nstatic void uvcg_streaming_class_drop_link(struct config_item *src,\n\t\t\t\t\t  struct config_item *target)\n{\n\tstruct config_item *streaming, *header;\n\tstruct f_uvc_opts *opts;\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct uvc_descriptor_header ***class_array;\n\tstruct uvcg_streaming_header *target_hdr;\n\n\tmutex_lock(su_mutex);  \n\n\tstreaming = src->ci_parent->ci_parent;\n\theader = config_group_find_item(to_config_group(streaming), \"header\");\n\tif (!header || target->ci_parent != header)\n\t\tgoto out;\n\n\topts = to_f_uvc_opts(streaming->ci_parent);\n\n\tmutex_lock(&opts->lock);\n\n\tclass_array = __uvcg_get_stream_class_arr(src, opts);\n\tif (!class_array || !*class_array)\n\t\tgoto unlock;\n\n\tif (opts->refcnt)\n\t\tgoto unlock;\n\n\ttarget_hdr = to_uvcg_streaming_header(target);\n\t--target_hdr->linked;\n\tkfree(**class_array);\n\tkfree(*class_array);\n\t*class_array = NULL;\n\nunlock:\n\tmutex_unlock(&opts->lock);\nout:\n\tconfig_item_put(header);\n\tmutex_unlock(su_mutex);\n}\n\nstatic struct configfs_item_operations uvcg_streaming_class_item_ops = {\n\t.release\t= uvcg_config_item_release,\n\t.allow_link\t= uvcg_streaming_class_allow_link,\n\t.drop_link\t= uvcg_streaming_class_drop_link,\n};\n\nstatic const struct config_item_type uvcg_streaming_class_type = {\n\t.ct_item_ops\t= &uvcg_streaming_class_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n \n\nstatic int uvcg_streaming_class_create_children(struct config_group *parent)\n{\n\tstatic const char * const names[] = { \"fs\", \"hs\", \"ss\" };\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(names); ++i) {\n\t\tstruct uvcg_streaming_class_group *group;\n\n\t\tgroup = kzalloc(sizeof(*group), GFP_KERNEL);\n\t\tif (!group)\n\t\t\treturn -ENOMEM;\n\n\t\tgroup->name = names[i];\n\n\t\tconfig_group_init_type_name(&group->group, group->name,\n\t\t\t\t\t    &uvcg_streaming_class_type);\n\t\tconfigfs_add_default_group(&group->group, parent);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct uvcg_config_group_type uvcg_streaming_class_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"class\",\n\t.create_children = uvcg_streaming_class_create_children,\n};\n\n \n\nstatic ssize_t uvcg_default_streaming_b_interface_number_show(\n\tstruct config_item *item, char *page)\n{\n\tstruct config_group *group = to_config_group(item);\n\tstruct mutex *su_mutex = &group->cg_subsys->su_mutex;\n\tstruct config_item *opts_item;\n\tstruct f_uvc_opts *opts;\n\tint result = 0;\n\n\tmutex_lock(su_mutex);  \n\n\topts_item = item->ci_parent;\n\topts = to_f_uvc_opts(opts_item);\n\n\tmutex_lock(&opts->lock);\n\tresult += sprintf(page, \"%u\\n\", opts->streaming_interface);\n\tmutex_unlock(&opts->lock);\n\n\tmutex_unlock(su_mutex);\n\n\treturn result;\n}\n\nUVC_ATTR_RO(uvcg_default_streaming_, b_interface_number, bInterfaceNumber);\n\nstatic struct configfs_attribute *uvcg_default_streaming_attrs[] = {\n\t&uvcg_default_streaming_attr_b_interface_number,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvcg_streaming_grp_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvcg_config_item_ops,\n\t\t.ct_attrs\t= uvcg_default_streaming_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"streaming\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_streaming_header_grp_type,\n\t\t&uvcg_uncompressed_grp_type,\n\t\t&uvcg_mjpeg_grp_type,\n\t\t&uvcg_color_matching_grp_type,\n\t\t&uvcg_streaming_class_grp_type,\n\t\tNULL,\n\t},\n};\n\n \n\nstatic void uvc_func_item_release(struct config_item *item)\n{\n\tstruct f_uvc_opts *opts = to_f_uvc_opts(item);\n\n\tuvcg_config_remove_children(to_config_group(item));\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic int uvc_func_allow_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct mutex *su_mutex = &src->ci_group->cg_subsys->su_mutex;\n\tstruct gadget_string *string;\n\tstruct config_item *strings;\n\tstruct f_uvc_opts *opts;\n\tint ret = 0;\n\n\tmutex_lock(su_mutex);  \n\n\t \n\tstrings = config_group_find_item(to_config_group(src->ci_parent->ci_parent),\n\t\t\t\t\t \"strings\");\n\tif (!strings || tgt->ci_parent->ci_parent != strings) {\n\t\tret = -EINVAL;\n\t\tgoto put_strings;\n\t}\n\n\tstring = to_gadget_string(tgt);\n\n\topts = to_f_uvc_opts(src);\n\tmutex_lock(&opts->lock);\n\n\tif (!strcmp(tgt->ci_name, \"iad_desc\"))\n\t\topts->iad_index = string->usb_string.id;\n\telse if (!strcmp(tgt->ci_name, \"vs0_desc\"))\n\t\topts->vs0_index = string->usb_string.id;\n\telse if (!strcmp(tgt->ci_name, \"vs1_desc\"))\n\t\topts->vs1_index = string->usb_string.id;\n\telse\n\t\tret = -EINVAL;\n\n\tmutex_unlock(&opts->lock);\n\nput_strings:\n\tconfig_item_put(strings);\n\tmutex_unlock(su_mutex);\n\n\treturn ret;\n}\n\nstatic void uvc_func_drop_link(struct config_item *src, struct config_item *tgt)\n{\n\tstruct f_uvc_opts *opts;\n\n\topts = to_f_uvc_opts(src);\n\tmutex_lock(&opts->lock);\n\n\tif (!strcmp(tgt->ci_name, \"iad_desc\"))\n\t\topts->iad_index = 0;\n\telse if (!strcmp(tgt->ci_name, \"vs0_desc\"))\n\t\topts->vs0_index = 0;\n\telse if (!strcmp(tgt->ci_name, \"vs1_desc\"))\n\t\topts->vs1_index = 0;\n\n\tmutex_unlock(&opts->lock);\n}\n\nstatic struct configfs_item_operations uvc_func_item_ops = {\n\t.release\t= uvc_func_item_release,\n\t.allow_link\t= uvc_func_allow_link,\n\t.drop_link\t= uvc_func_drop_link,\n};\n\n#define UVCG_OPTS_ATTR(cname, aname, limit)\t\t\t\t\\\nstatic ssize_t f_uvc_opts_##cname##_show(\t\t\t\t\\\n\tstruct config_item *item, char *page)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uvc_opts *opts = to_f_uvc_opts(item);\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = sprintf(page, \"%u\\n\", opts->cname);\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nf_uvc_opts_##cname##_store(struct config_item *item,\t\t\t\\\n\t\t\t   const char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uvc_opts *opts = to_f_uvc_opts(item);\t\t\t\\\n\tunsigned int num;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtouint(page, 0, &num);\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (num > limit) {\t\t\t\t\t\t\\\n\t\tret = -EINVAL;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\topts->cname = num;\t\t\t\t\t\t\\\n\tret = len;\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(f_uvc_opts_, cname, cname)\n\nUVCG_OPTS_ATTR(streaming_interval, streaming_interval, 16);\nUVCG_OPTS_ATTR(streaming_maxpacket, streaming_maxpacket, 3072);\nUVCG_OPTS_ATTR(streaming_maxburst, streaming_maxburst, 15);\n\n#undef UVCG_OPTS_ATTR\n\n#define UVCG_OPTS_STRING_ATTR(cname, aname)\t\t\t\t\\\nstatic ssize_t f_uvc_opts_string_##cname##_show(struct config_item *item,\\\n\t\t\t\t\t char *page)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uvc_opts *opts = to_f_uvc_opts(item);\t\t\t\\\n\tint result;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tresult = snprintf(page, sizeof(opts->aname), \"%s\", opts->aname);\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn result;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t f_uvc_opts_string_##cname##_store(struct config_item *item,\\\n\t\t\t\t\t  const char *page, size_t len)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct f_uvc_opts *opts = to_f_uvc_opts(item);\t\t\t\\\n\tint size = min(sizeof(opts->aname), len + 1);\t\t\t\\\n\tint ret = 0;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&opts->lock);\t\t\t\t\t\\\n\tif (opts->refcnt) {\t\t\t\t\t\t\\\n\t\tret = -EBUSY;\t\t\t\t\t\t\\\n\t\tgoto end;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = strscpy(opts->aname, page, size);\t\t\t\t\\\n\tif (ret == -E2BIG)\t\t\t\t\t\t\\\n\t\tret = size - 1;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nend:\t\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&opts->lock);\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\nUVC_ATTR(f_uvc_opts_string_, cname, aname)\n\nUVCG_OPTS_STRING_ATTR(function_name, function_name);\n\n#undef UVCG_OPTS_STRING_ATTR\n\nstatic struct configfs_attribute *uvc_attrs[] = {\n\t&f_uvc_opts_attr_streaming_interval,\n\t&f_uvc_opts_attr_streaming_maxpacket,\n\t&f_uvc_opts_attr_streaming_maxburst,\n\t&f_uvc_opts_string_attr_function_name,\n\tNULL,\n};\n\nstatic const struct uvcg_config_group_type uvc_func_type = {\n\t.type = {\n\t\t.ct_item_ops\t= &uvc_func_item_ops,\n\t\t.ct_attrs\t= uvc_attrs,\n\t\t.ct_owner\t= THIS_MODULE,\n\t},\n\t.name = \"\",\n\t.children = (const struct uvcg_config_group_type*[]) {\n\t\t&uvcg_control_grp_type,\n\t\t&uvcg_streaming_grp_type,\n\t\tNULL,\n\t},\n};\n\nint uvcg_attach_configfs(struct f_uvc_opts *opts)\n{\n\tint ret;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, uvc_func_type.name,\n\t\t\t\t    &uvc_func_type.type);\n\n\tret = uvcg_config_create_children(&opts->func_inst.group,\n\t\t\t\t\t  &uvc_func_type);\n\tif (ret < 0)\n\t\tconfig_group_put(&opts->func_inst.group);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}