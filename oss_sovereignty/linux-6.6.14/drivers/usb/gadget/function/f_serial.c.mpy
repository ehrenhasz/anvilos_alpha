{
  "module_name": "f_serial.c",
  "hash_id": "99c34a7a4470e8d0e6708451352deb54c1f807dd794a7b97f0d460fd2983114c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_serial.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n\n#include \"u_serial.h\"\n\n\n \n\nstruct f_gser {\n\tstruct gserial\t\t\tport;\n\tu8\t\t\t\tdata_id;\n\tu8\t\t\t\tport_num;\n};\n\nstatic inline struct f_gser *func_to_gser(struct usb_function *f)\n{\n\treturn container_of(f, struct f_gser, port.func);\n}\n\n \n\n \n\nstatic struct usb_interface_descriptor gser_interface_desc = {\n\t.bLength =\t\tUSB_DT_INTERFACE_SIZE,\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\t \n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_VENDOR_SPEC,\n\t.bInterfaceSubClass =\t0,\n\t.bInterfaceProtocol =\t0,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor gser_fs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor gser_fs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *gser_fs_function[] = {\n\t(struct usb_descriptor_header *) &gser_interface_desc,\n\t(struct usb_descriptor_header *) &gser_fs_in_desc,\n\t(struct usb_descriptor_header *) &gser_fs_out_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor gser_hs_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor gser_hs_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *gser_hs_function[] = {\n\t(struct usb_descriptor_header *) &gser_interface_desc,\n\t(struct usb_descriptor_header *) &gser_hs_in_desc,\n\t(struct usb_descriptor_header *) &gser_hs_out_desc,\n\tNULL,\n};\n\nstatic struct usb_endpoint_descriptor gser_ss_in_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_endpoint_descriptor gser_ss_out_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor gser_ss_bulk_comp_desc = {\n\t.bLength =              sizeof gser_ss_bulk_comp_desc,\n\t.bDescriptorType =      USB_DT_SS_ENDPOINT_COMP,\n};\n\nstatic struct usb_descriptor_header *gser_ss_function[] = {\n\t(struct usb_descriptor_header *) &gser_interface_desc,\n\t(struct usb_descriptor_header *) &gser_ss_in_desc,\n\t(struct usb_descriptor_header *) &gser_ss_bulk_comp_desc,\n\t(struct usb_descriptor_header *) &gser_ss_out_desc,\n\t(struct usb_descriptor_header *) &gser_ss_bulk_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string gser_string_defs[] = {\n\t[0].s = \"Generic Serial\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings gser_string_table = {\n\t.language =\t\t0x0409,\t \n\t.strings =\t\tgser_string_defs,\n};\n\nstatic struct usb_gadget_strings *gser_strings[] = {\n\t&gser_string_table,\n\tNULL,\n};\n\n \n\nstatic int gser_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_gser\t\t*gser = func_to_gser(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\n\tif (gser->port.in->enabled) {\n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"reset generic ttyGS%d\\n\", gser->port_num);\n\t\tgserial_disconnect(&gser->port);\n\t}\n\tif (!gser->port.in->desc || !gser->port.out->desc) {\n\t\tdev_dbg(&cdev->gadget->dev,\n\t\t\t\"activate generic ttyGS%d\\n\", gser->port_num);\n\t\tif (config_ep_by_speed(cdev->gadget, f, gser->port.in) ||\n\t\t    config_ep_by_speed(cdev->gadget, f, gser->port.out)) {\n\t\t\tgser->port.in->desc = NULL;\n\t\t\tgser->port.out->desc = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tgserial_connect(&gser->port, gser->port_num);\n\treturn 0;\n}\n\nstatic void gser_disable(struct usb_function *f)\n{\n\tstruct f_gser\t*gser = func_to_gser(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\tdev_dbg(&cdev->gadget->dev,\n\t\t\"generic ttyGS%d deactivated\\n\", gser->port_num);\n\tgserial_disconnect(&gser->port);\n}\n\n \n\n \n\nstatic int gser_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_gser\t\t*gser = func_to_gser(f);\n\tint\t\t\tstatus;\n\tstruct usb_ep\t\t*ep;\n\n\t \n\n\t \n\tif (gser_string_defs[0].id == 0) {\n\t\tstatus = usb_string_id(c->cdev);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t\tgser_string_defs[0].id = status;\n\t}\n\n\t \n\tstatus = usb_interface_id(c, f);\n\tif (status < 0)\n\t\tgoto fail;\n\tgser->data_id = status;\n\tgser_interface_desc.bInterfaceNumber = status;\n\n\tstatus = -ENODEV;\n\n\t \n\tep = usb_ep_autoconfig(cdev->gadget, &gser_fs_in_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tgser->port.in = ep;\n\n\tep = usb_ep_autoconfig(cdev->gadget, &gser_fs_out_desc);\n\tif (!ep)\n\t\tgoto fail;\n\tgser->port.out = ep;\n\n\t \n\tgser_hs_in_desc.bEndpointAddress = gser_fs_in_desc.bEndpointAddress;\n\tgser_hs_out_desc.bEndpointAddress = gser_fs_out_desc.bEndpointAddress;\n\n\tgser_ss_in_desc.bEndpointAddress = gser_fs_in_desc.bEndpointAddress;\n\tgser_ss_out_desc.bEndpointAddress = gser_fs_out_desc.bEndpointAddress;\n\n\tstatus = usb_assign_descriptors(f, gser_fs_function, gser_hs_function,\n\t\t\tgser_ss_function, gser_ss_function);\n\tif (status)\n\t\tgoto fail;\n\tdev_dbg(&cdev->gadget->dev, \"generic ttyGS%d: IN/%s OUT/%s\\n\",\n\t\tgser->port_num,\n\t\tgser->port.in->name, gser->port.out->name);\n\treturn 0;\n\nfail:\n\tERROR(cdev, \"%s: can't bind, err %d\\n\", f->name, status);\n\n\treturn status;\n}\n\nstatic inline struct f_serial_opts *to_f_serial_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_serial_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void serial_attr_release(struct config_item *item)\n{\n\tstruct f_serial_opts *opts = to_f_serial_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations serial_item_ops = {\n\t.release\t= serial_attr_release,\n};\n\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\nstatic ssize_t f_serial_console_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\treturn gserial_set_console(to_f_serial_opts(item)->port_num,\n\t\t\t\t   page, count);\n}\n\nstatic ssize_t f_serial_console_show(struct config_item *item, char *page)\n{\n\treturn gserial_get_console(to_f_serial_opts(item)->port_num, page);\n}\n\nCONFIGFS_ATTR(f_serial_, console);\n\n#endif  \n\nstatic ssize_t f_serial_port_num_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", to_f_serial_opts(item)->port_num);\n}\n\nCONFIGFS_ATTR_RO(f_serial_, port_num);\n\nstatic struct configfs_attribute *acm_attrs[] = {\n#ifdef CONFIG_U_SERIAL_CONSOLE\n\t&f_serial_attr_console,\n#endif\n\t&f_serial_attr_port_num,\n\tNULL,\n};\n\nstatic const struct config_item_type serial_func_type = {\n\t.ct_item_ops\t= &serial_item_ops,\n\t.ct_attrs\t= acm_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void gser_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_serial_opts *opts;\n\n\topts = container_of(f, struct f_serial_opts, func_inst);\n\tgserial_free_line(opts->port_num);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *gser_alloc_inst(void)\n{\n\tstruct f_serial_opts *opts;\n\tint ret;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.free_func_inst = gser_free_inst;\n\tret = gserial_alloc_line(&opts->port_num);\n\tif (ret) {\n\t\tkfree(opts);\n\t\treturn ERR_PTR(ret);\n\t}\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &serial_func_type);\n\n\treturn &opts->func_inst;\n}\n\nstatic void gser_free(struct usb_function *f)\n{\n\tstruct f_gser *serial;\n\n\tserial = func_to_gser(f);\n\tkfree(serial);\n}\n\nstatic void gser_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct f_gser\t*gser = func_to_gser(f);\n\n\t \n\tgserial_disconnect(&gser->port);\n\tusb_free_all_descriptors(f);\n}\n\nstatic void gser_resume(struct usb_function *f)\n{\n\tstruct f_gser *gser = func_to_gser(f);\n\n\tgserial_resume(&gser->port);\n}\n\nstatic void gser_suspend(struct usb_function *f)\n{\n\tstruct f_gser *gser = func_to_gser(f);\n\n\tgserial_suspend(&gser->port);\n}\n\nstatic struct usb_function *gser_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_gser\t*gser;\n\tstruct f_serial_opts *opts;\n\n\t \n\tgser = kzalloc(sizeof(*gser), GFP_KERNEL);\n\tif (!gser)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts = container_of(fi, struct f_serial_opts, func_inst);\n\n\tgser->port_num = opts->port_num;\n\n\tgser->port.func.name = \"gser\";\n\tgser->port.func.strings = gser_strings;\n\tgser->port.func.bind = gser_bind;\n\tgser->port.func.unbind = gser_unbind;\n\tgser->port.func.set_alt = gser_set_alt;\n\tgser->port.func.disable = gser_disable;\n\tgser->port.func.free_func = gser_free;\n\tgser->port.func.resume = gser_resume;\n\tgser->port.func.suspend = gser_suspend;\n\n\treturn &gser->port.func;\n}\n\nDECLARE_USB_FUNCTION_INIT(gser, gser_alloc_inst, gser_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Al Borchers\");\nMODULE_AUTHOR(\"David Brownell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}