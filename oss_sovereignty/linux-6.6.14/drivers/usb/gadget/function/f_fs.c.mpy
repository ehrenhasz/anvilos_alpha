{
  "module_name": "f_fs.c",
  "hash_id": "a63abe4e06bbcf2f32703605a140890e742f9f1ec1df03ff14f06fd0d2ded84a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_fs.c",
  "human_readable_source": "\n \n\n\n \n \n\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/fs_parser.h>\n#include <linux/hid.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/scatterlist.h>\n#include <linux/sched/signal.h>\n#include <linux/uio.h>\n#include <linux/vmalloc.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/ccid.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/functionfs.h>\n\n#include <linux/aio.h>\n#include <linux/kthread.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n\n#include \"u_fs.h\"\n#include \"u_f.h\"\n#include \"u_os_desc.h\"\n#include \"configfs.h\"\n\n#define FUNCTIONFS_MAGIC\t0xa647361  \n\n \nstatic void ffs_data_get(struct ffs_data *ffs);\nstatic void ffs_data_put(struct ffs_data *ffs);\n \nstatic struct ffs_data *__must_check ffs_data_new(const char *dev_name)\n\t__attribute__((malloc));\n\n \nstatic void ffs_data_opened(struct ffs_data *ffs);\nstatic void ffs_data_closed(struct ffs_data *ffs);\n\n \nstatic int __must_check\n__ffs_data_got_descs(struct ffs_data *ffs, char *data, size_t len);\nstatic int __must_check\n__ffs_data_got_strings(struct ffs_data *ffs, char *data, size_t len);\n\n\n \n\nstruct ffs_ep;\n\nstruct ffs_function {\n\tstruct usb_configuration\t*conf;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct ffs_data\t\t\t*ffs;\n\n\tstruct ffs_ep\t\t\t*eps;\n\tu8\t\t\t\teps_revmap[16];\n\tshort\t\t\t\t*interfaces_nums;\n\n\tstruct usb_function\t\tfunction;\n};\n\n\nstatic struct ffs_function *ffs_func_from_usb(struct usb_function *f)\n{\n\treturn container_of(f, struct ffs_function, function);\n}\n\n\nstatic inline enum ffs_setup_state\nffs_setup_state_clear_cancelled(struct ffs_data *ffs)\n{\n\treturn (enum ffs_setup_state)\n\t\tcmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);\n}\n\n\nstatic void ffs_func_eps_disable(struct ffs_function *func);\nstatic int __must_check ffs_func_eps_enable(struct ffs_function *func);\n\nstatic int ffs_func_bind(struct usb_configuration *,\n\t\t\t struct usb_function *);\nstatic int ffs_func_set_alt(struct usb_function *, unsigned, unsigned);\nstatic void ffs_func_disable(struct usb_function *);\nstatic int ffs_func_setup(struct usb_function *,\n\t\t\t  const struct usb_ctrlrequest *);\nstatic bool ffs_func_req_match(struct usb_function *,\n\t\t\t       const struct usb_ctrlrequest *,\n\t\t\t       bool config0);\nstatic void ffs_func_suspend(struct usb_function *);\nstatic void ffs_func_resume(struct usb_function *);\n\n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num);\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf);\n\n\n \n\nstruct ffs_ep {\n\tstruct usb_ep\t\t\t*ep;\t \n\tstruct usb_request\t\t*req;\t \n\n\t \n\tstruct usb_endpoint_descriptor\t*descs[3];\n\n\tu8\t\t\t\tnum;\n};\n\nstruct ffs_epfile {\n\t \n\tstruct mutex\t\t\tmutex;\n\n\tstruct ffs_data\t\t\t*ffs;\n\tstruct ffs_ep\t\t\t*ep;\t \n\n\tstruct dentry\t\t\t*dentry;\n\n\t \n\tstruct ffs_buffer\t\t*read_buffer;\n#define READ_BUFFER_DROP ((struct ffs_buffer *)ERR_PTR(-ESHUTDOWN))\n\n\tchar\t\t\t\tname[5];\n\n\tunsigned char\t\t\tin;\t \n\tunsigned char\t\t\tisoc;\t \n\n\tunsigned char\t\t\t_pad;\n};\n\nstruct ffs_buffer {\n\tsize_t length;\n\tchar *data;\n\tchar storage[];\n};\n\n \n\nstruct ffs_io_data {\n\tbool aio;\n\tbool read;\n\n\tstruct kiocb *kiocb;\n\tstruct iov_iter data;\n\tconst void *to_free;\n\tchar *buf;\n\n\tstruct mm_struct *mm;\n\tstruct work_struct work;\n\n\tstruct usb_ep *ep;\n\tstruct usb_request *req;\n\tstruct sg_table sgt;\n\tbool use_sg;\n\n\tstruct ffs_data *ffs;\n\n\tint status;\n\tstruct completion done;\n};\n\nstruct ffs_desc_helper {\n\tstruct ffs_data *ffs;\n\tunsigned interfaces_count;\n\tunsigned eps_count;\n};\n\nstatic int  __must_check ffs_epfiles_create(struct ffs_data *ffs);\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count);\n\nstatic struct dentry *\nffs_sb_create_file(struct super_block *sb, const char *name, void *data,\n\t\t   const struct file_operations *fops);\n\n \n\nDEFINE_MUTEX(ffs_lock);\nEXPORT_SYMBOL_GPL(ffs_lock);\n\nstatic struct ffs_dev *_ffs_find_dev(const char *name);\nstatic struct ffs_dev *_ffs_alloc_dev(void);\nstatic void _ffs_free_dev(struct ffs_dev *dev);\nstatic int ffs_acquire_dev(const char *dev_name, struct ffs_data *ffs_data);\nstatic void ffs_release_dev(struct ffs_dev *ffs_dev);\nstatic int ffs_ready(struct ffs_data *ffs);\nstatic void ffs_closed(struct ffs_data *ffs);\n\n \n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n\t__attribute__((warn_unused_result, nonnull));\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n\t__attribute__((warn_unused_result, nonnull));\n\n\n \n\nstatic void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ffs_data *ffs = req->context;\n\n\tcomplete(&ffs->ep0req_completion);\n}\n\nstatic int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)\n\t__releases(&ffs->ev.waitq.lock)\n{\n\tstruct usb_request *req = ffs->ep0req;\n\tint ret;\n\n\tif (!req) {\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq->zero     = len < le16_to_cpu(ffs->ev.setup.wLength);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\treq->buf      = data;\n\treq->length   = len;\n\n\t \n\tif (req->buf == NULL)\n\t\treq->buf = (void *)0xDEADBABE;\n\n\treinit_completion(&ffs->ep0req_completion);\n\n\tret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wait_for_completion_interruptible(&ffs->ep0req_completion);\n\tif (ret) {\n\t\tusb_ep_dequeue(ffs->gadget->ep0, req);\n\t\treturn -EINTR;\n\t}\n\n\tffs->setup_state = FFS_NO_SETUP;\n\treturn req->status ? req->status : req->actual;\n}\n\nstatic int __ffs_ep0_stall(struct ffs_data *ffs)\n{\n\tif (ffs->ev.can_stall) {\n\t\tpr_vdebug(\"ep0 stall\\n\");\n\t\tusb_ep_set_halt(ffs->gadget->ep0);\n\t\tffs->setup_state = FFS_NO_SETUP;\n\t\treturn -EL2HLT;\n\t} else {\n\t\tpr_debug(\"bogus ep0 stall!\\n\");\n\t\treturn -ESRCH;\n\t}\n}\n\nstatic ssize_t ffs_ep0_write(struct file *file, const char __user *buf,\n\t\t\t     size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tssize_t ret;\n\tchar *data;\n\n\t \n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t \n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\t \n\t\tif (len < 16) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ffs->state == FFS_READ_DESCRIPTORS) {\n\t\t\tpr_info(\"read descriptors\\n\");\n\t\t\tret = __ffs_data_got_descs(ffs, data, len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tffs->state = FFS_READ_STRINGS;\n\t\t\tret = len;\n\t\t} else {\n\t\t\tpr_info(\"read strings\\n\");\n\t\t\tret = __ffs_data_got_strings(ffs, data, len);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tret = ffs_epfiles_create(ffs);\n\t\t\tif (ret) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tffs->state = FFS_ACTIVE;\n\t\t\tmutex_unlock(&ffs->mutex);\n\n\t\t\tret = ffs_ready(ffs);\n\t\t\tif (ret < 0) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tdata = NULL;\n\t\t \n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\t\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tret = -EIDRM;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_NO_SETUP:\n\t\t\tret = -ESRCH;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t \n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\ndone_spin:\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t} else {\n\t\t\t \n\t\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\t}\n\t\tkfree(data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\treturn ret;\n}\n\n \nstatic ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf,\n\t\t\t\t     size_t n)\n\t__releases(&ffs->ev.waitq.lock)\n{\n\t \n\tstruct usb_functionfs_event events[ARRAY_SIZE(ffs->ev.types)];\n\tconst size_t size = n * sizeof *events;\n\tunsigned i = 0;\n\n\tmemset(events, 0, size);\n\n\tdo {\n\t\tevents[i].type = ffs->ev.types[i];\n\t\tif (events[i].type == FUNCTIONFS_SETUP) {\n\t\t\tevents[i].u.setup = ffs->ev.setup;\n\t\t\tffs->setup_state = FFS_SETUP_PENDING;\n\t\t}\n\t} while (++i < n);\n\n\tffs->ev.count -= n;\n\tif (ffs->ev.count)\n\t\tmemmove(ffs->ev.types, ffs->ev.types + n,\n\t\t\tffs->ev.count * sizeof *ffs->ev.types);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\tmutex_unlock(&ffs->mutex);\n\n\treturn copy_to_user(buf, events, size) ? -EFAULT : size;\n}\n\nstatic ssize_t ffs_ep0_read(struct file *file, char __user *buf,\n\t\t\t    size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tchar *data = NULL;\n\tsize_t n;\n\tint ret;\n\n\t \n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t \n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ffs->state != FFS_ACTIVE) {\n\t\tret = -EBADFD;\n\t\tgoto done_mutex;\n\t}\n\n\t \n\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\tcase FFS_SETUP_CANCELLED:\n\t\tret = -EIDRM;\n\t\tbreak;\n\n\tcase FFS_NO_SETUP:\n\t\tn = len / sizeof(struct usb_functionfs_event);\n\t\tif (!n) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,\n\t\t\t\t\t\t\tffs->ev.count)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treturn __ffs_ep0_read_events(ffs, buf,\n\t\t\t\t\t     min(n, (size_t)ffs->ev.count));\n\n\tcase FFS_SETUP_PENDING:\n\t\tif (ffs->ev.setup.bRequestType & USB_DIR_IN) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tgoto done_mutex;\n\t\t}\n\n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tif (len) {\n\t\t\tdata = kmalloc(len, GFP_KERNEL);\n\t\t\tif (!data) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done_mutex;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t \n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\tif ((ret > 0) && (copy_to_user(buf, data, len)))\n\t\t\tret = -EFAULT;\n\t\tgoto done_mutex;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\ndone_mutex:\n\tmutex_unlock(&ffs->mutex);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ffs_ep0_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = inode->i_private;\n\n\tif (ffs->state == FFS_CLOSING)\n\t\treturn -EBUSY;\n\n\tfile->private_data = ffs;\n\tffs_data_opened(ffs);\n\n\treturn stream_open(inode, file);\n}\n\nstatic int ffs_ep0_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\n\tffs_data_closed(ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tstruct usb_gadget *gadget = ffs->gadget;\n\tlong ret;\n\n\tif (code == FUNCTIONFS_INTERFACE_REVMAP) {\n\t\tstruct ffs_function *func = ffs->func;\n\t\tret = func ? ffs_func_revmap_intf(func, value) : -ENODEV;\n\t} else if (gadget && gadget->ops->ioctl) {\n\t\tret = gadget->ops->ioctl(gadget, code, value);\n\t} else {\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic __poll_t ffs_ep0_poll(struct file *file, poll_table *wait)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\t__poll_t mask = EPOLLWRNORM;\n\tint ret;\n\n\tpoll_wait(file, &ffs->ev.waitq, wait);\n\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (ret < 0)\n\t\treturn mask;\n\n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\tmask |= EPOLLOUT;\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tswitch (ffs->setup_state) {\n\t\tcase FFS_NO_SETUP:\n\t\t\tif (ffs->ev.count)\n\t\t\t\tmask |= EPOLLIN;\n\t\t\tbreak;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tmask |= (EPOLLIN | EPOLLOUT);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase FFS_CLOSING:\n\t\tbreak;\n\tcase FFS_DEACTIVATED:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\n\treturn mask;\n}\n\nstatic const struct file_operations ffs_ep0_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_ep0_open,\n\t.write =\tffs_ep0_write,\n\t.read =\t\tffs_ep0_read,\n\t.release =\tffs_ep0_release,\n\t.unlocked_ioctl =\tffs_ep0_ioctl,\n\t.poll =\t\tffs_ep0_poll,\n};\n\n\n \n\nstatic void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tstruct ffs_io_data *io_data = req->context;\n\n\tif (req->status)\n\t\tio_data->status = req->status;\n\telse\n\t\tio_data->status = req->actual;\n\n\tcomplete(&io_data->done);\n}\n\nstatic ssize_t ffs_copy_to_iter(void *data, int data_len, struct iov_iter *iter)\n{\n\tssize_t ret = copy_to_iter(data, data_len, iter);\n\tif (ret == data_len)\n\t\treturn ret;\n\n\tif (iov_iter_count(iter))\n\t\treturn -EFAULT;\n\n\t \n\tpr_err(\"functionfs read size %d > requested size %zd, dropping excess data. \"\n\t       \"Align read buffer size to max packet size to avoid the problem.\\n\",\n\t       data_len, ret);\n\n\treturn ret;\n}\n\n \nstatic void *ffs_build_sg_list(struct sg_table *sgt, size_t sz)\n{\n\tstruct page **pages;\n\tvoid *vaddr, *ptr;\n\tunsigned int n_pages;\n\tint i;\n\n\tvaddr = vmalloc(sz);\n\tif (!vaddr)\n\t\treturn NULL;\n\n\tn_pages = PAGE_ALIGN(sz) >> PAGE_SHIFT;\n\tpages = kvmalloc_array(n_pages, sizeof(struct page *), GFP_KERNEL);\n\tif (!pages) {\n\t\tvfree(vaddr);\n\n\t\treturn NULL;\n\t}\n\tfor (i = 0, ptr = vaddr; i < n_pages; ++i, ptr += PAGE_SIZE)\n\t\tpages[i] = vmalloc_to_page(ptr);\n\n\tif (sg_alloc_table_from_pages(sgt, pages, n_pages, 0, sz, GFP_KERNEL)) {\n\t\tkvfree(pages);\n\t\tvfree(vaddr);\n\n\t\treturn NULL;\n\t}\n\tkvfree(pages);\n\n\treturn vaddr;\n}\n\nstatic inline void *ffs_alloc_buffer(struct ffs_io_data *io_data,\n\tsize_t data_len)\n{\n\tif (io_data->use_sg)\n\t\treturn ffs_build_sg_list(&io_data->sgt, data_len);\n\n\treturn kmalloc(data_len, GFP_KERNEL);\n}\n\nstatic inline void ffs_free_buffer(struct ffs_io_data *io_data)\n{\n\tif (!io_data->buf)\n\t\treturn;\n\n\tif (io_data->use_sg) {\n\t\tsg_free_table(&io_data->sgt);\n\t\tvfree(io_data->buf);\n\t} else {\n\t\tkfree(io_data->buf);\n\t}\n}\n\nstatic void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->status;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tkthread_use_mm(io_data->mm);\n\t\tret = ffs_copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tkthread_unuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tffs_free_buffer(io_data);\n\tkfree(io_data);\n}\n\nstatic void ffs_epfile_async_io_complete(struct usb_ep *_ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct ffs_io_data *io_data = req->context;\n\tstruct ffs_data *ffs = io_data->ffs;\n\n\tio_data->status = req->status ? req->status : req->actual;\n\tusb_ep_free_request(_ep, req);\n\n\tINIT_WORK(&io_data->work, ffs_user_copy_worker);\n\tqueue_work(ffs->io_completion_wq, &io_data->work);\n}\n\nstatic void __ffs_epfile_read_buffer_free(struct ffs_epfile *epfile)\n{\n\t \n\tstruct ffs_buffer *buf = xchg(&epfile->read_buffer, READ_BUFFER_DROP);\n\tif (buf && buf != READ_BUFFER_DROP)\n\t\tkfree(buf);\n}\n\n \nstatic ssize_t __ffs_epfile_read_buffered(struct ffs_epfile *epfile,\n\t\t\t\t\t  struct iov_iter *iter)\n{\n\t \n\tstruct ffs_buffer *buf = xchg(&epfile->read_buffer, NULL);\n\tssize_t ret;\n\tif (!buf || buf == READ_BUFFER_DROP)\n\t\treturn 0;\n\n\tret = copy_to_iter(buf->data, buf->length, iter);\n\tif (buf->length == ret) {\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tif (iov_iter_count(iter)) {\n\t\tret = -EFAULT;\n\t} else {\n\t\tbuf->length -= ret;\n\t\tbuf->data += ret;\n\t}\n\n\tif (cmpxchg(&epfile->read_buffer, NULL, buf))\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\n \nstatic ssize_t __ffs_epfile_read_data(struct ffs_epfile *epfile,\n\t\t\t\t      void *data, int data_len,\n\t\t\t\t      struct iov_iter *iter)\n{\n\tstruct ffs_buffer *buf;\n\n\tssize_t ret = copy_to_iter(data, data_len, iter);\n\tif (data_len == ret)\n\t\treturn ret;\n\n\tif (iov_iter_count(iter))\n\t\treturn -EFAULT;\n\n\t \n\tpr_warn(\"functionfs read size %d > requested size %zd, splitting request into multiple reads.\",\n\t\tdata_len, ret);\n\n\tdata_len -= ret;\n\tbuf = kmalloc(struct_size(buf, storage, data_len), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf->length = data_len;\n\tbuf->data = buf->storage;\n\tmemcpy(buf->storage, data + ret, flex_array_size(buf, storage, data_len));\n\n\t \n\tif (cmpxchg(&epfile->read_buffer, NULL, buf))\n\t\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tstruct usb_request *req;\n\tstruct ffs_ep *ep;\n\tchar *data = NULL;\n\tssize_t ret, data_len = -EINVAL;\n\tint halt;\n\n\t \n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\t \n\tep = epfile->ep;\n\tif (!ep) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(\n\t\t\t\tepfile->ffs->wait, (ep = epfile->ep));\n\t\tif (ret)\n\t\t\treturn -EINTR;\n\t}\n\n\t \n\thalt = (!io_data->read == !epfile->in);\n\tif (halt && epfile->isoc)\n\t\treturn -EINVAL;\n\n\t \n\tret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);\n\tif (ret)\n\t\tgoto error;\n\n\t \n\tif (!halt) {\n\t\tstruct usb_gadget *gadget;\n\n\t\t \n\t\tif (!io_data->aio && io_data->read) {\n\t\t\tret = __ffs_epfile_read_buffered(epfile, &io_data->data);\n\t\t\tif (ret)\n\t\t\t\tgoto error_mutex;\n\t\t}\n\n\t\t \n\t\tgadget = epfile->ffs->gadget;\n\n\t\tspin_lock_irq(&epfile->ffs->eps_lock);\n\t\t \n\t\tif (epfile->ep != ep) {\n\t\t\tret = -ESHUTDOWN;\n\t\t\tgoto error_lock;\n\t\t}\n\t\tdata_len = iov_iter_count(&io_data->data);\n\t\t \n\t\tif (io_data->read)\n\t\t\tdata_len = usb_ep_align_maybe(gadget, ep->ep, data_len);\n\n\t\tio_data->use_sg = gadget->sg_supported && data_len > PAGE_SIZE;\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tdata = ffs_alloc_buffer(io_data, data_len);\n\t\tif (!data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_mutex;\n\t\t}\n\t\tif (!io_data->read &&\n\t\t    !copy_from_iter_full(data, data_len, &io_data->data)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error_mutex;\n\t\t}\n\t}\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\tif (epfile->ep != ep) {\n\t\t \n\t\tret = -ESHUTDOWN;\n\t} else if (halt) {\n\t\tret = usb_ep_set_halt(ep->ep);\n\t\tif (!ret)\n\t\t\tret = -EBADMSG;\n\t} else if (data_len == -EINVAL) {\n\t\t \n\t\tWARN(1, \"%s: data_len == -EINVAL\\n\", __func__);\n\t\tret = -EINVAL;\n\t} else if (!io_data->aio) {\n\t\tbool interrupted = false;\n\n\t\treq = ep->req;\n\t\tif (io_data->use_sg) {\n\t\t\treq->buf = NULL;\n\t\t\treq->sg\t= io_data->sgt.sgl;\n\t\t\treq->num_sgs = io_data->sgt.nents;\n\t\t} else {\n\t\t\treq->buf = data;\n\t\t\treq->num_sgs = 0;\n\t\t}\n\t\treq->length = data_len;\n\n\t\tio_data->buf = data;\n\n\t\tinit_completion(&io_data->done);\n\t\treq->context  = io_data;\n\t\treq->complete = ffs_epfile_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto error_lock;\n\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tif (wait_for_completion_interruptible(&io_data->done)) {\n\t\t\tspin_lock_irq(&epfile->ffs->eps_lock);\n\t\t\tif (epfile->ep != ep) {\n\t\t\t\tret = -ESHUTDOWN;\n\t\t\t\tgoto error_lock;\n\t\t\t}\n\t\t\t \n\t\t\tusb_ep_dequeue(ep->ep, req);\n\t\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\t\twait_for_completion(&io_data->done);\n\t\t\tinterrupted = io_data->status < 0;\n\t\t}\n\n\t\tif (interrupted)\n\t\t\tret = -EINTR;\n\t\telse if (io_data->read && io_data->status > 0)\n\t\t\tret = __ffs_epfile_read_data(epfile, data, io_data->status,\n\t\t\t\t\t\t     &io_data->data);\n\t\telse\n\t\t\tret = io_data->status;\n\t\tgoto error_mutex;\n\t} else if (!(req = usb_ep_alloc_request(ep->ep, GFP_ATOMIC))) {\n\t\tret = -ENOMEM;\n\t} else {\n\t\tif (io_data->use_sg) {\n\t\t\treq->buf = NULL;\n\t\t\treq->sg\t= io_data->sgt.sgl;\n\t\t\treq->num_sgs = io_data->sgt.nents;\n\t\t} else {\n\t\t\treq->buf = data;\n\t\t\treq->num_sgs = 0;\n\t\t}\n\t\treq->length = data_len;\n\n\t\tio_data->buf = data;\n\t\tio_data->ep = ep->ep;\n\t\tio_data->req = req;\n\t\tio_data->ffs = epfile->ffs;\n\n\t\treq->context  = io_data;\n\t\treq->complete = ffs_epfile_async_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tio_data->req = NULL;\n\t\t\tusb_ep_free_request(ep->ep, req);\n\t\t\tgoto error_lock;\n\t\t}\n\n\t\tret = -EIOCBQUEUED;\n\t\t \n\t\tdata = NULL;\n\t}\n\nerror_lock:\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\nerror_mutex:\n\tmutex_unlock(&epfile->mutex);\nerror:\n\tif (ret != -EIOCBQUEUED)  \n\t\tffs_free_buffer(io_data);\n\treturn ret;\n}\n\nstatic int\nffs_epfile_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\tfile->private_data = epfile;\n\tffs_data_opened(epfile->ffs);\n\n\treturn stream_open(inode, file);\n}\n\nstatic int ffs_aio_cancel(struct kiocb *kiocb)\n{\n\tstruct ffs_io_data *io_data = kiocb->private;\n\tstruct ffs_epfile *epfile = kiocb->ki_filp->private_data;\n\tunsigned long flags;\n\tint value;\n\n\tspin_lock_irqsave(&epfile->ffs->eps_lock, flags);\n\n\tif (io_data && io_data->ep && io_data->req)\n\t\tvalue = usb_ep_dequeue(io_data->ep, io_data->req);\n\telse\n\t\tvalue = -EINVAL;\n\n\tspin_unlock_irqrestore(&epfile->ffs->eps_lock, flags);\n\n\treturn value;\n}\n\nstatic ssize_t ffs_epfile_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kzalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tp->aio = false;\n\t}\n\n\tp->read = false;\n\tp->kiocb = kiocb;\n\tp->data = *from;\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\tif (p->aio)\n\t\tkfree(p);\n\telse\n\t\t*from = p->data;\n\treturn res;\n}\n\nstatic ssize_t ffs_epfile_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kzalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tmemset(p, 0, sizeof(*p));\n\t\tp->aio = false;\n\t}\n\n\tp->read = true;\n\tp->kiocb = kiocb;\n\tif (p->aio) {\n\t\tp->to_free = dup_iter(&p->data, to, GFP_KERNEL);\n\t\tif (!iter_is_ubuf(&p->data) && !p->to_free) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tp->data = *to;\n\t\tp->to_free = NULL;\n\t}\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\n\tif (p->aio) {\n\t\tkfree(p->to_free);\n\t\tkfree(p);\n\t} else {\n\t\t*to = p->data;\n\t}\n\treturn res;\n}\n\nstatic int\nffs_epfile_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\t__ffs_epfile_read_buffer_free(epfile);\n\tffs_data_closed(epfile->ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_epfile_ioctl(struct file *file, unsigned code,\n\t\t\t     unsigned long value)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tstruct ffs_ep *ep;\n\tint ret;\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\t \n\tep = epfile->ep;\n\tif (!ep) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(\n\t\t\t\tepfile->ffs->wait, (ep = epfile->ep));\n\t\tif (ret)\n\t\t\treturn -EINTR;\n\t}\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\t \n\tif (epfile->ep != ep) {\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tswitch (code) {\n\tcase FUNCTIONFS_FIFO_STATUS:\n\t\tret = usb_ep_fifo_status(epfile->ep->ep);\n\t\tbreak;\n\tcase FUNCTIONFS_FIFO_FLUSH:\n\t\tusb_ep_fifo_flush(epfile->ep->ep);\n\t\tret = 0;\n\t\tbreak;\n\tcase FUNCTIONFS_CLEAR_HALT:\n\t\tret = usb_ep_clear_halt(epfile->ep->ep);\n\t\tbreak;\n\tcase FUNCTIONFS_ENDPOINT_REVMAP:\n\t\tret = epfile->ep->num;\n\t\tbreak;\n\tcase FUNCTIONFS_ENDPOINT_DESC:\n\t{\n\t\tint desc_idx;\n\t\tstruct usb_endpoint_descriptor desc1, *desc;\n\n\t\tswitch (epfile->ffs->gadget->speed) {\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\t\tdesc_idx = 2;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tdesc_idx = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdesc_idx = 0;\n\t\t}\n\n\t\tdesc = epfile->ep->descs[desc_idx];\n\t\tmemcpy(&desc1, desc, desc->bLength);\n\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\tret = copy_to_user((void __user *)value, &desc1, desc1.bLength);\n\t\tif (ret)\n\t\t\tret = -EFAULT;\n\t\treturn ret;\n\t}\n\tdefault:\n\t\tret = -ENOTTY;\n\t}\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ffs_epfile_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_epfile_open,\n\t.write_iter =\tffs_epfile_write_iter,\n\t.read_iter =\tffs_epfile_read_iter,\n\t.release =\tffs_epfile_release,\n\t.unlocked_ioctl =\tffs_epfile_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\n\n \n\n \n\nstatic struct inode *__must_check\nffs_sb_make_inode(struct super_block *sb, void *data,\n\t\t  const struct file_operations *fops,\n\t\t  const struct inode_operations *iops,\n\t\t  struct ffs_file_perms *perms)\n{\n\tstruct inode *inode;\n\n\tinode = new_inode(sb);\n\n\tif (inode) {\n\t\tstruct timespec64 ts = inode_set_ctime_current(inode);\n\n\t\tinode->i_ino\t = get_next_ino();\n\t\tinode->i_mode    = perms->mode;\n\t\tinode->i_uid     = perms->uid;\n\t\tinode->i_gid     = perms->gid;\n\t\tinode->i_atime   = ts;\n\t\tinode->i_mtime   = ts;\n\t\tinode->i_private = data;\n\t\tif (fops)\n\t\t\tinode->i_fop = fops;\n\t\tif (iops)\n\t\t\tinode->i_op  = iops;\n\t}\n\n\treturn inode;\n}\n\n \nstatic struct dentry *ffs_sb_create_file(struct super_block *sb,\n\t\t\t\t\tconst char *name, void *data,\n\t\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct ffs_data\t*ffs = sb->s_fs_info;\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\n\tdentry = d_alloc_name(sb->s_root, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tinode = ffs_sb_make_inode(sb, data, fops, NULL, &ffs->file_perms);\n\tif (!inode) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\td_add(dentry, inode);\n\treturn dentry;\n}\n\n \nstatic const struct super_operations ffs_sb_operations = {\n\t.statfs =\tsimple_statfs,\n\t.drop_inode =\tgeneric_delete_inode,\n};\n\nstruct ffs_sb_fill_data {\n\tstruct ffs_file_perms perms;\n\tumode_t root_mode;\n\tconst char *dev_name;\n\tbool no_disconnect;\n\tstruct ffs_data *ffs_data;\n};\n\nstatic int ffs_sb_fill(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct ffs_sb_fill_data *data = fc->fs_private;\n\tstruct inode\t*inode;\n\tstruct ffs_data\t*ffs = data->ffs_data;\n\n\tffs->sb              = sb;\n\tdata->ffs_data       = NULL;\n\tsb->s_fs_info        = ffs;\n\tsb->s_blocksize      = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic          = FUNCTIONFS_MAGIC;\n\tsb->s_op             = &ffs_sb_operations;\n\tsb->s_time_gran      = 1;\n\n\t \n\tdata->perms.mode = data->root_mode;\n\tinode = ffs_sb_make_inode(sb, NULL,\n\t\t\t\t  &simple_dir_operations,\n\t\t\t\t  &simple_dir_inode_operations,\n\t\t\t\t  &data->perms);\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!ffs_sb_create_file(sb, \"ep0\", ffs, &ffs_ep0_operations))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nenum {\n\tOpt_no_disconnect,\n\tOpt_rmode,\n\tOpt_fmode,\n\tOpt_mode,\n\tOpt_uid,\n\tOpt_gid,\n};\n\nstatic const struct fs_parameter_spec ffs_fs_fs_parameters[] = {\n\tfsparam_bool\t(\"no_disconnect\",\tOpt_no_disconnect),\n\tfsparam_u32\t(\"rmode\",\t\tOpt_rmode),\n\tfsparam_u32\t(\"fmode\",\t\tOpt_fmode),\n\tfsparam_u32\t(\"mode\",\t\tOpt_mode),\n\tfsparam_u32\t(\"uid\",\t\t\tOpt_uid),\n\tfsparam_u32\t(\"gid\",\t\t\tOpt_gid),\n\t{}\n};\n\nstatic int ffs_fs_parse_param(struct fs_context *fc, struct fs_parameter *param)\n{\n\tstruct ffs_sb_fill_data *data = fc->fs_private;\n\tstruct fs_parse_result result;\n\tint opt;\n\n\topt = fs_parse(fc, ffs_fs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_no_disconnect:\n\t\tdata->no_disconnect = result.boolean;\n\t\tbreak;\n\tcase Opt_rmode:\n\t\tdata->root_mode  = (result.uint_32 & 0555) | S_IFDIR;\n\t\tbreak;\n\tcase Opt_fmode:\n\t\tdata->perms.mode = (result.uint_32 & 0666) | S_IFREG;\n\t\tbreak;\n\tcase Opt_mode:\n\t\tdata->root_mode  = (result.uint_32 & 0555) | S_IFDIR;\n\t\tdata->perms.mode = (result.uint_32 & 0666) | S_IFREG;\n\t\tbreak;\n\n\tcase Opt_uid:\n\t\tdata->perms.uid = make_kuid(current_user_ns(), result.uint_32);\n\t\tif (!uid_valid(data->perms.uid))\n\t\t\tgoto unmapped_value;\n\t\tbreak;\n\tcase Opt_gid:\n\t\tdata->perms.gid = make_kgid(current_user_ns(), result.uint_32);\n\t\tif (!gid_valid(data->perms.gid))\n\t\t\tgoto unmapped_value;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOPARAM;\n\t}\n\n\treturn 0;\n\nunmapped_value:\n\treturn invalf(fc, \"%s: unmapped value: %u\", param->key, result.uint_32);\n}\n\n \nstatic int ffs_fs_get_tree(struct fs_context *fc)\n{\n\tstruct ffs_sb_fill_data *ctx = fc->fs_private;\n\tstruct ffs_data\t*ffs;\n\tint ret;\n\n\tif (!fc->source)\n\t\treturn invalf(fc, \"No source specified\");\n\n\tffs = ffs_data_new(fc->source);\n\tif (!ffs)\n\t\treturn -ENOMEM;\n\tffs->file_perms = ctx->perms;\n\tffs->no_disconnect = ctx->no_disconnect;\n\n\tffs->dev_name = kstrdup(fc->source, GFP_KERNEL);\n\tif (!ffs->dev_name) {\n\t\tffs_data_put(ffs);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ffs_acquire_dev(ffs->dev_name, ffs);\n\tif (ret) {\n\t\tffs_data_put(ffs);\n\t\treturn ret;\n\t}\n\n\tctx->ffs_data = ffs;\n\treturn get_tree_nodev(fc, ffs_sb_fill);\n}\n\nstatic void ffs_fs_free_fc(struct fs_context *fc)\n{\n\tstruct ffs_sb_fill_data *ctx = fc->fs_private;\n\n\tif (ctx) {\n\t\tif (ctx->ffs_data) {\n\t\t\tffs_data_put(ctx->ffs_data);\n\t\t}\n\n\t\tkfree(ctx);\n\t}\n}\n\nstatic const struct fs_context_operations ffs_fs_context_ops = {\n\t.free\t\t= ffs_fs_free_fc,\n\t.parse_param\t= ffs_fs_parse_param,\n\t.get_tree\t= ffs_fs_get_tree,\n};\n\nstatic int ffs_fs_init_fs_context(struct fs_context *fc)\n{\n\tstruct ffs_sb_fill_data *ctx;\n\n\tctx = kzalloc(sizeof(struct ffs_sb_fill_data), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->perms.mode = S_IFREG | 0600;\n\tctx->perms.uid = GLOBAL_ROOT_UID;\n\tctx->perms.gid = GLOBAL_ROOT_GID;\n\tctx->root_mode = S_IFDIR | 0500;\n\tctx->no_disconnect = false;\n\n\tfc->fs_private = ctx;\n\tfc->ops = &ffs_fs_context_ops;\n\treturn 0;\n}\n\nstatic void\nffs_fs_kill_sb(struct super_block *sb)\n{\n\tkill_litter_super(sb);\n\tif (sb->s_fs_info)\n\t\tffs_data_closed(sb->s_fs_info);\n}\n\nstatic struct file_system_type ffs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"functionfs\",\n\t.init_fs_context = ffs_fs_init_fs_context,\n\t.parameters\t= ffs_fs_fs_parameters,\n\t.kill_sb\t= ffs_fs_kill_sb,\n};\nMODULE_ALIAS_FS(\"functionfs\");\n\n\n \n\nstatic int functionfs_init(void)\n{\n\tint ret;\n\n\tret = register_filesystem(&ffs_fs_type);\n\tif (!ret)\n\t\tpr_info(\"file system registered\\n\");\n\telse\n\t\tpr_err(\"failed registering file system (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void functionfs_cleanup(void)\n{\n\tpr_info(\"unloading\\n\");\n\tunregister_filesystem(&ffs_fs_type);\n}\n\n\n \n\nstatic void ffs_data_clear(struct ffs_data *ffs);\nstatic void ffs_data_reset(struct ffs_data *ffs);\n\nstatic void ffs_data_get(struct ffs_data *ffs)\n{\n\trefcount_inc(&ffs->ref);\n}\n\nstatic void ffs_data_opened(struct ffs_data *ffs)\n{\n\trefcount_inc(&ffs->ref);\n\tif (atomic_add_return(1, &ffs->opened) == 1 &&\n\t\t\tffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n}\n\nstatic void ffs_data_put(struct ffs_data *ffs)\n{\n\tif (refcount_dec_and_test(&ffs->ref)) {\n\t\tpr_info(\"%s(): freeing\\n\", __func__);\n\t\tffs_data_clear(ffs);\n\t\tffs_release_dev(ffs->private_data);\n\t\tBUG_ON(waitqueue_active(&ffs->ev.waitq) ||\n\t\t       swait_active(&ffs->ep0req_completion.wait) ||\n\t\t       waitqueue_active(&ffs->wait));\n\t\tdestroy_workqueue(ffs->io_completion_wq);\n\t\tkfree(ffs->dev_name);\n\t\tkfree(ffs);\n\t}\n}\n\nstatic void ffs_data_closed(struct ffs_data *ffs)\n{\n\tstruct ffs_epfile *epfiles;\n\tunsigned long flags;\n\n\tif (atomic_dec_and_test(&ffs->opened)) {\n\t\tif (ffs->no_disconnect) {\n\t\t\tffs->state = FFS_DEACTIVATED;\n\t\t\tspin_lock_irqsave(&ffs->eps_lock, flags);\n\t\t\tepfiles = ffs->epfiles;\n\t\t\tffs->epfiles = NULL;\n\t\t\tspin_unlock_irqrestore(&ffs->eps_lock,\n\t\t\t\t\t\t\tflags);\n\n\t\t\tif (epfiles)\n\t\t\t\tffs_epfiles_destroy(epfiles,\n\t\t\t\t\t\t ffs->eps_count);\n\n\t\t\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\t\t\t__ffs_ep0_stall(ffs);\n\t\t} else {\n\t\t\tffs->state = FFS_CLOSING;\n\t\t\tffs_data_reset(ffs);\n\t\t}\n\t}\n\tif (atomic_read(&ffs->opened) < 0) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n\n\tffs_data_put(ffs);\n}\n\nstatic struct ffs_data *ffs_data_new(const char *dev_name)\n{\n\tstruct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);\n\tif (!ffs)\n\t\treturn NULL;\n\n\tffs->io_completion_wq = alloc_ordered_workqueue(\"%s\", 0, dev_name);\n\tif (!ffs->io_completion_wq) {\n\t\tkfree(ffs);\n\t\treturn NULL;\n\t}\n\n\trefcount_set(&ffs->ref, 1);\n\tatomic_set(&ffs->opened, 0);\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tmutex_init(&ffs->mutex);\n\tspin_lock_init(&ffs->eps_lock);\n\tinit_waitqueue_head(&ffs->ev.waitq);\n\tinit_waitqueue_head(&ffs->wait);\n\tinit_completion(&ffs->ep0req_completion);\n\n\t \n\tffs->ev.can_stall = 1;\n\n\treturn ffs;\n}\n\nstatic void ffs_data_clear(struct ffs_data *ffs)\n{\n\tstruct ffs_epfile *epfiles;\n\tunsigned long flags;\n\n\tffs_closed(ffs);\n\n\tBUG_ON(ffs->gadget);\n\n\tspin_lock_irqsave(&ffs->eps_lock, flags);\n\tepfiles = ffs->epfiles;\n\tffs->epfiles = NULL;\n\tspin_unlock_irqrestore(&ffs->eps_lock, flags);\n\n\t \n\tif (epfiles) {\n\t\tffs_epfiles_destroy(epfiles, ffs->eps_count);\n\t\tffs->epfiles = NULL;\n\t}\n\n\tif (ffs->ffs_eventfd) {\n\t\teventfd_ctx_put(ffs->ffs_eventfd);\n\t\tffs->ffs_eventfd = NULL;\n\t}\n\n\tkfree(ffs->raw_descs_data);\n\tkfree(ffs->raw_strings);\n\tkfree(ffs->stringtabs);\n}\n\nstatic void ffs_data_reset(struct ffs_data *ffs)\n{\n\tffs_data_clear(ffs);\n\n\tffs->raw_descs_data = NULL;\n\tffs->raw_descs = NULL;\n\tffs->raw_strings = NULL;\n\tffs->stringtabs = NULL;\n\n\tffs->raw_descs_length = 0;\n\tffs->fs_descs_count = 0;\n\tffs->hs_descs_count = 0;\n\tffs->ss_descs_count = 0;\n\n\tffs->strings_count = 0;\n\tffs->interfaces_count = 0;\n\tffs->eps_count = 0;\n\n\tffs->ev.count = 0;\n\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tffs->setup_state = FFS_NO_SETUP;\n\tffs->flags = 0;\n\n\tffs->ms_os_descs_ext_prop_count = 0;\n\tffs->ms_os_descs_ext_prop_name_len = 0;\n\tffs->ms_os_descs_ext_prop_data_len = 0;\n}\n\n\nstatic int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_strings **lang;\n\tint first_id;\n\n\tif (WARN_ON(ffs->state != FFS_ACTIVE\n\t\t || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))\n\t\treturn -EBADFD;\n\n\tfirst_id = usb_string_ids_n(cdev, ffs->strings_count);\n\tif (first_id < 0)\n\t\treturn first_id;\n\n\tffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\n\tif (!ffs->ep0req)\n\t\treturn -ENOMEM;\n\tffs->ep0req->complete = ffs_ep0_complete;\n\tffs->ep0req->context = ffs;\n\n\tlang = ffs->stringtabs;\n\tif (lang) {\n\t\tfor (; *lang; ++lang) {\n\t\t\tstruct usb_string *str = (*lang)->strings;\n\t\t\tint id = first_id;\n\t\t\tfor (; str->s; ++id, ++str)\n\t\t\t\tstr->id = id;\n\t\t}\n\t}\n\n\tffs->gadget = cdev->gadget;\n\tffs_data_get(ffs);\n\treturn 0;\n}\n\nstatic void functionfs_unbind(struct ffs_data *ffs)\n{\n\tif (!WARN_ON(!ffs->gadget)) {\n\t\t \n\t\tusb_ep_dequeue(ffs->gadget->ep0, ffs->ep0req);\n\t\tmutex_lock(&ffs->mutex);\n\t\tusb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);\n\t\tffs->ep0req = NULL;\n\t\tffs->gadget = NULL;\n\t\tclear_bit(FFS_FL_BOUND, &ffs->flags);\n\t\tmutex_unlock(&ffs->mutex);\n\t\tffs_data_put(ffs);\n\t}\n}\n\nstatic int ffs_epfiles_create(struct ffs_data *ffs)\n{\n\tstruct ffs_epfile *epfile, *epfiles;\n\tunsigned i, count;\n\n\tcount = ffs->eps_count;\n\tepfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);\n\tif (!epfiles)\n\t\treturn -ENOMEM;\n\n\tepfile = epfiles;\n\tfor (i = 1; i <= count; ++i, ++epfile) {\n\t\tepfile->ffs = ffs;\n\t\tmutex_init(&epfile->mutex);\n\t\tif (ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tsprintf(epfile->name, \"ep%02x\", ffs->eps_addrmap[i]);\n\t\telse\n\t\t\tsprintf(epfile->name, \"ep%u\", i);\n\t\tepfile->dentry = ffs_sb_create_file(ffs->sb, epfile->name,\n\t\t\t\t\t\t epfile,\n\t\t\t\t\t\t &ffs_epfile_operations);\n\t\tif (!epfile->dentry) {\n\t\t\tffs_epfiles_destroy(epfiles, i - 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tffs->epfiles = epfiles;\n\treturn 0;\n}\n\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\n{\n\tstruct ffs_epfile *epfile = epfiles;\n\n\tfor (; count; --count, ++epfile) {\n\t\tBUG_ON(mutex_is_locked(&epfile->mutex));\n\t\tif (epfile->dentry) {\n\t\t\td_delete(epfile->dentry);\n\t\t\tdput(epfile->dentry);\n\t\t\tepfile->dentry = NULL;\n\t\t}\n\t}\n\n\tkfree(epfiles);\n}\n\nstatic void ffs_func_eps_disable(struct ffs_function *func)\n{\n\tstruct ffs_ep *ep;\n\tstruct ffs_epfile *epfile;\n\tunsigned short count;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tcount = func->ffs->eps_count;\n\tepfile = func->ffs->epfiles;\n\tep = func->eps;\n\twhile (count--) {\n\t\t \n\t\tif (ep->ep)\n\t\t\tusb_ep_disable(ep->ep);\n\t\t++ep;\n\n\t\tif (epfile) {\n\t\t\tepfile->ep = NULL;\n\t\t\t__ffs_epfile_read_buffer_free(epfile);\n\t\t\t++epfile;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n}\n\nstatic int ffs_func_eps_enable(struct ffs_function *func)\n{\n\tstruct ffs_data *ffs;\n\tstruct ffs_ep *ep;\n\tstruct ffs_epfile *epfile;\n\tunsigned short count;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tffs = func->ffs;\n\tep = func->eps;\n\tepfile = ffs->epfiles;\n\tcount = ffs->eps_count;\n\twhile(count--) {\n\t\tep->ep->driver_data = ep;\n\n\t\tret = config_ep_by_speed(func->gadget, &func->function, ep->ep);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: config_ep_by_speed(%s) returned %d\\n\",\n\t\t\t\t\t__func__, ep->ep->name, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = usb_ep_enable(ep->ep);\n\t\tif (!ret) {\n\t\t\tepfile->ep = ep;\n\t\t\tepfile->in = usb_endpoint_dir_in(ep->ep->desc);\n\t\t\tepfile->isoc = usb_endpoint_xfer_isoc(ep->ep->desc);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\t++ep;\n\t\t++epfile;\n\t}\n\n\twake_up_interruptible(&ffs->wait);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\n\treturn ret;\n}\n\n\n \n\n \n\nenum ffs_entity_type {\n\tFFS_DESCRIPTOR, FFS_INTERFACE, FFS_STRING, FFS_ENDPOINT\n};\n\nenum ffs_os_desc_type {\n\tFFS_OS_DESC, FFS_OS_DESC_EXT_COMPAT, FFS_OS_DESC_EXT_PROP\n};\n\ntypedef int (*ffs_entity_callback)(enum ffs_entity_type entity,\n\t\t\t\t   u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv);\n\ntypedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type entity,\n\t\t\t\t    struct usb_os_desc_header *h, void *data,\n\t\t\t\t    unsigned len, void *priv);\n\nstatic int __must_check ffs_do_single_desc(char *data, unsigned len,\n\t\t\t\t\t   ffs_entity_callback entity,\n\t\t\t\t\t   void *priv, int *current_class)\n{\n\tstruct usb_descriptor_header *_ds = (void *)data;\n\tu8 length;\n\tint ret;\n\n\t \n\tif (len < 2) {\n\t\tpr_vdebug(\"descriptor too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlength = _ds->bLength;\n\tif (len < length) {\n\t\tpr_vdebug(\"descriptor longer then available data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#define __entity_check_INTERFACE(val)  1\n#define __entity_check_STRING(val)     (val)\n#define __entity_check_ENDPOINT(val)   ((val) & USB_ENDPOINT_NUMBER_MASK)\n#define __entity(type, val) do {\t\t\t\t\t\\\n\t\tpr_vdebug(\"entity \" #type \"(%02x)\\n\", (val));\t\t\\\n\t\tif (!__entity_check_ ##type(val)) {\t\t\t\\\n\t\t\tpr_vdebug(\"invalid entity's value\\n\");\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tret = entity(FFS_ ##type, &val, _ds, priv);\t\t\\\n\t\tif (ret < 0) {\t\t\t\t\t\t\\\n\t\t\tpr_debug(\"entity \" #type \"(%02x); ret = %d\\n\",\t\\\n\t\t\t\t (val), ret);\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\t \n\tswitch (_ds->bDescriptorType) {\n\tcase USB_DT_DEVICE:\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_STRING:\n\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t \n\t\tpr_vdebug(\"descriptor reserved for gadget: %d\\n\",\n\t\t      _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tcase USB_DT_INTERFACE: {\n\t\tstruct usb_interface_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\n\t\t__entity(INTERFACE, ds->bInterfaceNumber);\n\t\tif (ds->iInterface)\n\t\t\t__entity(STRING, ds->iInterface);\n\t\t*current_class = ds->bInterfaceClass;\n\t}\n\t\tbreak;\n\n\tcase USB_DT_ENDPOINT: {\n\t\tstruct usb_endpoint_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"endpoint descriptor\\n\");\n\t\tif (length != USB_DT_ENDPOINT_SIZE &&\n\t\t    length != USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\t\tgoto inv_length;\n\t\t__entity(ENDPOINT, ds->bEndpointAddress);\n\t}\n\t\tbreak;\n\n\tcase USB_TYPE_CLASS | 0x01:\n\t\tif (*current_class == USB_INTERFACE_CLASS_HID) {\n\t\t\tpr_vdebug(\"hid descriptor\\n\");\n\t\t\tif (length != sizeof(struct hid_descriptor))\n\t\t\t\tgoto inv_length;\n\t\t\tbreak;\n\t\t} else if (*current_class == USB_INTERFACE_CLASS_CCID) {\n\t\t\tpr_vdebug(\"ccid descriptor\\n\");\n\t\t\tif (length != sizeof(struct ccid_descriptor))\n\t\t\t\tgoto inv_length;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_vdebug(\"unknown descriptor: %d for class %d\\n\",\n\t\t\t      _ds->bDescriptorType, *current_class);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tcase USB_DT_OTG:\n\t\tif (length != sizeof(struct usb_otg_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_INTERFACE_ASSOCIATION: {\n\t\tstruct usb_interface_assoc_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface association descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\t\tif (ds->iFunction)\n\t\t\t__entity(STRING, ds->iFunction);\n\t}\n\t\tbreak;\n\n\tcase USB_DT_SS_ENDPOINT_COMP:\n\t\tpr_vdebug(\"EP SS companion descriptor\\n\");\n\t\tif (length != sizeof(struct usb_ss_ep_comp_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\tcase USB_DT_INTERFACE_POWER:\n\tcase USB_DT_DEBUG:\n\tcase USB_DT_SECURITY:\n\tcase USB_DT_CS_RADIO_CONTROL:\n\t\t \n\t\tpr_vdebug(\"unimplemented descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\t \n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\ninv_length:\n\t\tpr_vdebug(\"invalid length: %d (descriptor %d)\\n\",\n\t\t\t  _ds->bLength, _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\t}\n\n#undef __entity\n#undef __entity_check_DESCRIPTOR\n#undef __entity_check_INTERFACE\n#undef __entity_check_STRING\n#undef __entity_check_ENDPOINT\n\n\treturn length;\n}\n\nstatic int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,\n\t\t\t\t     ffs_entity_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\tint current_class = -1;\n\n\tfor (;;) {\n\t\tint ret;\n\n\t\tif (num == count)\n\t\t\tdata = NULL;\n\n\t\t \n\t\tret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"entity DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!data)\n\t\t\treturn _len - len;\n\n\t\tret = ffs_do_single_desc(data, len, entity, priv,\n\t\t\t&current_class);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t\t++num;\n\t}\n}\n\nstatic int __ffs_data_do_entity(enum ffs_entity_type type,\n\t\t\t\tu8 *valuep, struct usb_descriptor_header *desc,\n\t\t\t\tvoid *priv)\n{\n\tstruct ffs_desc_helper *helper = priv;\n\tstruct usb_endpoint_descriptor *d;\n\n\tswitch (type) {\n\tcase FFS_DESCRIPTOR:\n\t\tbreak;\n\n\tcase FFS_INTERFACE:\n\t\t \n\t\tif (*valuep >= helper->interfaces_count)\n\t\t\thelper->interfaces_count = *valuep + 1;\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t \n\t\tif (*valuep > helper->ffs->strings_count)\n\t\t\thelper->ffs->strings_count = *valuep;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\td = (void *)desc;\n\t\thelper->eps_count++;\n\t\tif (helper->eps_count >= FFS_MAX_EPS_COUNT)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (!helper->ffs->eps_count && !helper->ffs->interfaces_count)\n\t\t\thelper->ffs->eps_addrmap[helper->eps_count] =\n\t\t\t\td->bEndpointAddress;\n\t\telse if (helper->ffs->eps_addrmap[helper->eps_count] !=\n\t\t\t\td->bEndpointAddress)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ffs_do_os_desc_header(enum ffs_os_desc_type *next_type,\n\t\t\t\t   struct usb_os_desc_header *desc)\n{\n\tu16 bcd_version = le16_to_cpu(desc->bcdVersion);\n\tu16 w_index = le16_to_cpu(desc->wIndex);\n\n\tif (bcd_version == 0x1) {\n\t\tpr_warn(\"bcdVersion must be 0x0100, stored in Little Endian order. \"\n\t\t\t\"Userspace driver should be fixed, accepting 0x0001 for compatibility.\\n\");\n\t} else if (bcd_version != 0x100) {\n\t\tpr_vdebug(\"unsupported os descriptors version: 0x%x\\n\",\n\t\t\t  bcd_version);\n\t\treturn -EINVAL;\n\t}\n\tswitch (w_index) {\n\tcase 0x4:\n\t\t*next_type = FFS_OS_DESC_EXT_COMPAT;\n\t\tbreak;\n\tcase 0x5:\n\t\t*next_type = FFS_OS_DESC_EXT_PROP;\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unsupported os descriptor type: %d\", w_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn sizeof(*desc);\n}\n\n \nstatic int __must_check ffs_do_single_os_desc(char *data, unsigned len,\n\t\t\t\t\t      enum ffs_os_desc_type type,\n\t\t\t\t\t      u16 feature_count,\n\t\t\t\t\t      ffs_os_desc_callback entity,\n\t\t\t\t\t      void *priv,\n\t\t\t\t\t      struct usb_os_desc_header *h)\n{\n\tint ret;\n\tconst unsigned _len = len;\n\n\t \n\twhile (feature_count--) {\n\t\tret = entity(type, h, data, len, priv);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"bad OS descriptor, type: %d\\n\", type);\n\t\t\treturn ret;\n\t\t}\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\treturn _len - len;\n}\n\n \nstatic int __must_check ffs_do_os_descs(unsigned count,\n\t\t\t\t\tchar *data, unsigned len,\n\t\t\t\t\tffs_os_desc_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\n\tfor (num = 0; num < count; ++num) {\n\t\tint ret;\n\t\tenum ffs_os_desc_type type;\n\t\tu16 feature_count;\n\t\tstruct usb_os_desc_header *desc = (void *)data;\n\n\t\tif (len < sizeof(*desc))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tif (le32_to_cpu(desc->dwLength) > len)\n\t\t\treturn -EINVAL;\n\n\t\tret = __ffs_do_os_desc_header(&type, desc);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"entity OS_DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tfeature_count = le16_to_cpu(desc->wCount);\n\t\tif (type == FFS_OS_DESC_EXT_COMPAT &&\n\t\t    (feature_count > 255 || desc->Reserved))\n\t\t\t\treturn -EINVAL;\n\t\tlen -= ret;\n\t\tdata += ret;\n\n\t\t \n\t\tret = ffs_do_single_os_desc(data, len, type,\n\t\t\t\t\t    feature_count, entity, priv, desc);\n\t\tif (ret < 0) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t}\n\treturn _len - len;\n}\n\n \nstatic int __ffs_data_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t struct usb_os_desc_header *h, void *data,\n\t\t\t\t unsigned len, void *priv)\n{\n\tstruct ffs_data *ffs = priv;\n\tu8 length;\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *d = data;\n\t\tint i;\n\n\t\tif (len < sizeof(*d) ||\n\t\t    d->bFirstInterfaceNumber >= ffs->interfaces_count)\n\t\t\treturn -EINVAL;\n\t\tif (d->Reserved1 != 1) {\n\t\t\t \n\t\t\tpr_debug(\"usb_ext_compat_desc::Reserved1 forced to 1\\n\");\n\t\t\td->Reserved1 = 1;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(d->Reserved2); ++i)\n\t\t\tif (d->Reserved2[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tlength = sizeof(struct usb_ext_compat_desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *d = data;\n\t\tu32 type, pdl;\n\t\tu16 pnl;\n\n\t\tif (len < sizeof(*d) || h->interface >= ffs->interfaces_count)\n\t\t\treturn -EINVAL;\n\t\tlength = le32_to_cpu(d->dwSize);\n\t\tif (len < length)\n\t\t\treturn -EINVAL;\n\t\ttype = le32_to_cpu(d->dwPropertyDataType);\n\t\tif (type < USB_EXT_PROP_UNICODE ||\n\t\t    type > USB_EXT_PROP_UNICODE_MULTI) {\n\t\t\tpr_vdebug(\"unsupported os descriptor property type: %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpnl = le16_to_cpu(d->wPropertyNameLength);\n\t\tif (length < 14 + pnl) {\n\t\t\tpr_vdebug(\"invalid os descriptor length: %d pnl:%d (descriptor %d)\\n\",\n\t\t\t\t  length, pnl, type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpdl = le32_to_cpu(*(__le32 *)((u8 *)data + 10 + pnl));\n\t\tif (length != 14 + pnl + pdl) {\n\t\t\tpr_vdebug(\"invalid os descriptor length: %d pnl:%d pdl:%d (descriptor %d)\\n\",\n\t\t\t\t  length, pnl, pdl, type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t++ffs->ms_os_descs_ext_prop_count;\n\t\t \n\t\tffs->ms_os_descs_ext_prop_name_len += pnl * 2;\n\t\tffs->ms_os_descs_ext_prop_data_len += pdl;\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\treturn length;\n}\n\nstatic int __ffs_data_got_descs(struct ffs_data *ffs,\n\t\t\t\tchar *const _data, size_t len)\n{\n\tchar *data = _data, *raw_descs;\n\tunsigned os_descs_count = 0, counts[3], flags;\n\tint ret = -EINVAL, i;\n\tstruct ffs_desc_helper helper;\n\n\tif (get_unaligned_le32(data + 4) != len)\n\t\tgoto error;\n\n\tswitch (get_unaligned_le32(data)) {\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC:\n\t\tflags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;\n\t\tdata += 8;\n\t\tlen  -= 8;\n\t\tbreak;\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC_V2:\n\t\tflags = get_unaligned_le32(data + 8);\n\t\tffs->user_flags = flags;\n\t\tif (flags & ~(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t      FUNCTIONFS_HAS_HS_DESC |\n\t\t\t      FUNCTIONFS_HAS_SS_DESC |\n\t\t\t      FUNCTIONFS_HAS_MS_OS_DESC |\n\t\t\t      FUNCTIONFS_VIRTUAL_ADDR |\n\t\t\t      FUNCTIONFS_EVENTFD |\n\t\t\t      FUNCTIONFS_ALL_CTRL_RECIP |\n\t\t\t      FUNCTIONFS_CONFIG0_SETUP)) {\n\t\t\tret = -ENOSYS;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 12;\n\t\tlen  -= 12;\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tif (flags & FUNCTIONFS_EVENTFD) {\n\t\tif (len < 4)\n\t\t\tgoto error;\n\t\tffs->ffs_eventfd =\n\t\t\teventfd_ctx_fdget((int)get_unaligned_le32(data));\n\t\tif (IS_ERR(ffs->ffs_eventfd)) {\n\t\t\tret = PTR_ERR(ffs->ffs_eventfd);\n\t\t\tffs->ffs_eventfd = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 4;\n\t\tlen  -= 4;\n\t}\n\n\t \n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!(flags & (1 << i))) {\n\t\t\tcounts[i] = 0;\n\t\t} else if (len < 4) {\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tcounts[i] = get_unaligned_le32(data);\n\t\t\tdata += 4;\n\t\t\tlen  -= 4;\n\t\t}\n\t}\n\tif (flags & (1 << i)) {\n\t\tif (len < 4) {\n\t\t\tgoto error;\n\t\t}\n\t\tos_descs_count = get_unaligned_le32(data);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t}\n\n\t \n\traw_descs = data;\n\thelper.ffs = ffs;\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!counts[i])\n\t\t\tcontinue;\n\t\thelper.interfaces_count = 0;\n\t\thelper.eps_count = 0;\n\t\tret = ffs_do_descs(counts[i], data, len,\n\t\t\t\t   __ffs_data_do_entity, &helper);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (!ffs->eps_count && !ffs->interfaces_count) {\n\t\t\tffs->eps_count = helper.eps_count;\n\t\t\tffs->interfaces_count = helper.interfaces_count;\n\t\t} else {\n\t\t\tif (ffs->eps_count != helper.eps_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (ffs->interfaces_count != helper.interfaces_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tdata += ret;\n\t\tlen  -= ret;\n\t}\n\tif (os_descs_count) {\n\t\tret = ffs_do_os_descs(os_descs_count, data, len,\n\t\t\t\t      __ffs_data_do_os_desc, ffs);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (raw_descs == data || len) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tffs->raw_descs_data\t= _data;\n\tffs->raw_descs\t\t= raw_descs;\n\tffs->raw_descs_length\t= data - raw_descs;\n\tffs->fs_descs_count\t= counts[0];\n\tffs->hs_descs_count\t= counts[1];\n\tffs->ss_descs_count\t= counts[2];\n\tffs->ms_os_descs_count\t= os_descs_count;\n\n\treturn 0;\n\nerror:\n\tkfree(_data);\n\treturn ret;\n}\n\nstatic int __ffs_data_got_strings(struct ffs_data *ffs,\n\t\t\t\t  char *const _data, size_t len)\n{\n\tu32 str_count, needed_count, lang_count;\n\tstruct usb_gadget_strings **stringtabs, *t;\n\tconst char *data = _data;\n\tstruct usb_string *s;\n\n\tif (len < 16 ||\n\t    get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||\n\t    get_unaligned_le32(data + 4) != len)\n\t\tgoto error;\n\tstr_count  = get_unaligned_le32(data + 8);\n\tlang_count = get_unaligned_le32(data + 12);\n\n\t \n\tif (!str_count != !lang_count)\n\t\tgoto error;\n\n\t \n\tneeded_count = ffs->strings_count;\n\tif (str_count < needed_count)\n\t\tgoto error;\n\n\t \n\tif (!needed_count) {\n\t\tkfree(_data);\n\t\treturn 0;\n\t}\n\n\t \n\t{\n\t\tunsigned i = 0;\n\t\tvla_group(d);\n\t\tvla_item(d, struct usb_gadget_strings *, stringtabs,\n\t\t\tsize_add(lang_count, 1));\n\t\tvla_item(d, struct usb_gadget_strings, stringtab, lang_count);\n\t\tvla_item(d, struct usb_string, strings,\n\t\t\tsize_mul(lang_count, (needed_count + 1)));\n\n\t\tchar *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);\n\n\t\tif (!vlabuf) {\n\t\t\tkfree(_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ti = lang_count;\n\t\tdo {\n\t\t\t*stringtabs++ = t++;\n\t\t} while (--i);\n\t\t*stringtabs = NULL;\n\n\t\t \n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ts = vla_ptr(vlabuf, d, strings);\n\t}\n\n\t \n\tdata += 16;\n\tlen -= 16;\n\n\tdo {  \n\t\tunsigned needed = needed_count;\n\t\tu32 str_per_lang = str_count;\n\n\t\tif (len < 3)\n\t\t\tgoto error_free;\n\t\tt->language = get_unaligned_le16(data);\n\t\tt->strings  = s;\n\t\t++t;\n\n\t\tdata += 2;\n\t\tlen -= 2;\n\n\t\t \n\t\tdo {  \n\t\t\tsize_t length = strnlen(data, len);\n\n\t\t\tif (length == len)\n\t\t\t\tgoto error_free;\n\n\t\t\t \n\t\t\tif (needed) {\n\t\t\t\t \n\t\t\t\ts->s = data;\n\t\t\t\t--needed;\n\t\t\t\t++s;\n\t\t\t}\n\n\t\t\tdata += length + 1;\n\t\t\tlen -= length + 1;\n\t\t} while (--str_per_lang);\n\n\t\ts->id = 0;    \n\t\ts->s = NULL;\n\t\t++s;\n\n\t} while (--lang_count);\n\n\t \n\tif (len)\n\t\tgoto error_free;\n\n\t \n\tffs->stringtabs = stringtabs;\n\tffs->raw_strings = _data;\n\n\treturn 0;\n\nerror_free:\n\tkfree(stringtabs);\nerror:\n\tkfree(_data);\n\treturn -EINVAL;\n}\n\n\n \n\nstatic void __ffs_event_add(struct ffs_data *ffs,\n\t\t\t    enum usb_functionfs_event_type type)\n{\n\tenum usb_functionfs_event_type rem_type1, rem_type2 = type;\n\tint neg = 0;\n\n\t \n\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\tffs->setup_state = FFS_SETUP_CANCELLED;\n\n\t \n\tswitch (type) {\n\tcase FUNCTIONFS_RESUME:\n\t\trem_type2 = FUNCTIONFS_SUSPEND;\n\t\tfallthrough;\n\tcase FUNCTIONFS_SUSPEND:\n\tcase FUNCTIONFS_SETUP:\n\t\trem_type1 = type;\n\t\t \n\t\tbreak;\n\n\tcase FUNCTIONFS_BIND:\n\tcase FUNCTIONFS_UNBIND:\n\tcase FUNCTIONFS_DISABLE:\n\tcase FUNCTIONFS_ENABLE:\n\t\t \n\t\trem_type1 = FUNCTIONFS_SUSPEND;\n\t\trem_type2 = FUNCTIONFS_RESUME;\n\t\tneg = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"%d: unknown event, this should not happen\\n\", type);\n\t\treturn;\n\t}\n\n\t{\n\t\tu8 *ev  = ffs->ev.types, *out = ev;\n\t\tunsigned n = ffs->ev.count;\n\t\tfor (; n; --n, ++ev)\n\t\t\tif ((*ev == rem_type1 || *ev == rem_type2) == neg)\n\t\t\t\t*out++ = *ev;\n\t\t\telse\n\t\t\t\tpr_vdebug(\"purging event %d\\n\", *ev);\n\t\tffs->ev.count = out - ffs->ev.types;\n\t}\n\n\tpr_vdebug(\"adding event %d\\n\", type);\n\tffs->ev.types[ffs->ev.count++] = type;\n\twake_up_locked(&ffs->ev.waitq);\n\tif (ffs->ffs_eventfd)\n\t\teventfd_signal(ffs->ffs_eventfd, 1);\n}\n\nstatic void ffs_event_add(struct ffs_data *ffs,\n\t\t\t  enum usb_functionfs_event_type type)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\t__ffs_event_add(ffs, type);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n}\n\n \n\nstatic int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)\n{\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)\n\t\tif (ffs->eps_addrmap[i] == endpoint_address)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\nstatic int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t    struct usb_descriptor_header *desc,\n\t\t\t\t    void *priv)\n{\n\tstruct usb_endpoint_descriptor *ds = (void *)desc;\n\tstruct ffs_function *func = priv;\n\tstruct ffs_ep *ffs_ep;\n\tunsigned ep_desc_id;\n\tint idx;\n\tstatic const char *speed_names[] = { \"full\", \"high\", \"super\" };\n\n\tif (type != FFS_DESCRIPTOR)\n\t\treturn 0;\n\n\t \n\tif (func->function.ss_descriptors) {\n\t\tep_desc_id = 2;\n\t\tfunc->function.ss_descriptors[(long)valuep] = desc;\n\t} else if (func->function.hs_descriptors) {\n\t\tep_desc_id = 1;\n\t\tfunc->function.hs_descriptors[(long)valuep] = desc;\n\t} else {\n\t\tep_desc_id = 0;\n\t\tfunc->function.fs_descriptors[(long)valuep]    = desc;\n\t}\n\n\tif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn 0;\n\n\tidx = ffs_ep_addr2idx(func->ffs, ds->bEndpointAddress) - 1;\n\tif (idx < 0)\n\t\treturn idx;\n\n\tffs_ep = func->eps + idx;\n\n\tif (ffs_ep->descs[ep_desc_id]) {\n\t\tpr_err(\"two %sspeed descriptors for EP %d\\n\",\n\t\t\t  speed_names[ep_desc_id],\n\t\t\t  ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t\treturn -EINVAL;\n\t}\n\tffs_ep->descs[ep_desc_id] = ds;\n\n\tffs_dump_mem(\": Original  ep desc\", ds, ds->bLength);\n\tif (ffs_ep->ep) {\n\t\tds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;\n\t\tif (!ds->wMaxPacketSize)\n\t\t\tds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;\n\t} else {\n\t\tstruct usb_request *req;\n\t\tstruct usb_ep *ep;\n\t\tu8 bEndpointAddress;\n\t\tu16 wMaxPacketSize;\n\n\t\t \n\t\tbEndpointAddress = ds->bEndpointAddress;\n\t\t \n\t\twMaxPacketSize = ds->wMaxPacketSize;\n\t\tpr_vdebug(\"autoconfig\\n\");\n\t\tep = usb_ep_autoconfig(func->gadget, ds);\n\t\tif (!ep)\n\t\t\treturn -ENOTSUPP;\n\t\tep->driver_data = func->eps + idx;\n\n\t\treq = usb_ep_alloc_request(ep, GFP_KERNEL);\n\t\tif (!req)\n\t\t\treturn -ENOMEM;\n\n\t\tffs_ep->ep  = ep;\n\t\tffs_ep->req = req;\n\t\tfunc->eps_revmap[ds->bEndpointAddress &\n\t\t\t\t USB_ENDPOINT_NUMBER_MASK] = idx + 1;\n\t\t \n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tds->bEndpointAddress = bEndpointAddress;\n\t\t \n\t\tds->wMaxPacketSize = wMaxPacketSize;\n\t}\n\tffs_dump_mem(\": Rewritten ep desc\", ds, ds->bLength);\n\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tunsigned idx;\n\tu8 newValue;\n\n\tswitch (type) {\n\tdefault:\n\tcase FFS_DESCRIPTOR:\n\t\t \n\t\treturn 0;\n\n\tcase FFS_INTERFACE:\n\t\tidx = *valuep;\n\t\tif (func->interfaces_nums[idx] < 0) {\n\t\t\tint id = usb_interface_id(func->conf, &func->function);\n\t\t\tif (id < 0)\n\t\t\t\treturn id;\n\t\t\tfunc->interfaces_nums[idx] = id;\n\t\t}\n\t\tnewValue = func->interfaces_nums[idx];\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t \n\t\tnewValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\t \n\t\tif (desc->bDescriptorType == USB_DT_ENDPOINT)\n\t\t\treturn 0;\n\n\t\tidx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;\n\t\tif (!func->eps[idx].ep)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct usb_endpoint_descriptor **descs;\n\t\t\tdescs = func->eps[idx].descs;\n\t\t\tnewValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;\n\t\t}\n\t\tbreak;\n\t}\n\n\tpr_vdebug(\"%02x -> %02x\\n\", *valuep, newValue);\n\t*valuep = newValue;\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t      struct usb_os_desc_header *h, void *data,\n\t\t\t\t      unsigned len, void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tu8 length = 0;\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\n\t\tt = &func->function.os_desc_table[desc->bFirstInterfaceNumber];\n\t\tt->if_id = func->interfaces_nums[desc->bFirstInterfaceNumber];\n\t\tmemcpy(t->os_desc->ext_compat_id, &desc->CompatibleID,\n\t\t       ARRAY_SIZE(desc->CompatibleID) +\n\t\t       ARRAY_SIZE(desc->SubCompatibleID));\n\t\tlength = sizeof(*desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\t\tstruct usb_os_desc_ext_prop *ext_prop;\n\t\tchar *ext_prop_name;\n\t\tchar *ext_prop_data;\n\n\t\tt = &func->function.os_desc_table[h->interface];\n\t\tt->if_id = func->interfaces_nums[h->interface];\n\n\t\text_prop = func->ffs->ms_os_descs_ext_prop_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_avail += sizeof(*ext_prop);\n\n\t\text_prop->type = le32_to_cpu(desc->dwPropertyDataType);\n\t\text_prop->name_len = le16_to_cpu(desc->wPropertyNameLength);\n\t\text_prop->data_len = le32_to_cpu(*(__le32 *)\n\t\t\tusb_ext_prop_data_len_ptr(data, ext_prop->name_len));\n\t\tlength = ext_prop->name_len + ext_prop->data_len + 14;\n\n\t\text_prop_name = func->ffs->ms_os_descs_ext_prop_name_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_name_avail +=\n\t\t\text_prop->name_len;\n\n\t\text_prop_data = func->ffs->ms_os_descs_ext_prop_data_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_data_avail +=\n\t\t\text_prop->data_len;\n\t\tmemcpy(ext_prop_data,\n\t\t       usb_ext_prop_data_ptr(data, ext_prop->name_len),\n\t\t       ext_prop->data_len);\n\t\t \n\t\tswitch (ext_prop->type) {\n\t\tcase USB_EXT_PROP_UNICODE:\n\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\tcase USB_EXT_PROP_UNICODE_MULTI:\n\t\t\text_prop->data_len *= 2;\n\t\t\tbreak;\n\t\t}\n\t\text_prop->data = ext_prop_data;\n\n\t\tmemcpy(ext_prop_name, usb_ext_prop_name_ptr(data),\n\t\t       ext_prop->name_len);\n\t\t \n\t\text_prop->name_len *= 2;\n\t\text_prop->name = ext_prop_name;\n\n\t\tt->os_desc->ext_prop_len +=\n\t\t\text_prop->name_len + ext_prop->data_len + 14;\n\t\t++t->os_desc->ext_prop_count;\n\t\tlist_add_tail(&ext_prop->entry, &t->os_desc->ext_prop);\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t}\n\n\treturn length;\n}\n\nstatic inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,\n\t\t\t\t\t\tstruct usb_configuration *c)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct f_fs_opts *ffs_opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tstruct ffs_data *ffs_data;\n\tint ret;\n\n\t \n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_lock();\n\tret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;\n\tffs_data = ffs_opts->dev->ffs_data;\n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_unlock();\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfunc->ffs = ffs_data;\n\tfunc->conf = c;\n\tfunc->gadget = c->cdev->gadget;\n\n\t \n\tif (!ffs_opts->refcnt) {\n\t\tret = functionfs_bind(func->ffs, c->cdev);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tffs_opts->refcnt++;\n\tfunc->function.strings = func->ffs->stringtabs;\n\n\treturn ffs_opts;\n}\n\nstatic int _ffs_func_bind(struct usb_configuration *c,\n\t\t\t  struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\n\tconst int full = !!func->ffs->fs_descs_count;\n\tconst int high = !!func->ffs->hs_descs_count;\n\tconst int super = !!func->ffs->ss_descs_count;\n\n\tint fs_len, hs_len, ss_len, ret, i;\n\tstruct ffs_ep *eps_ptr;\n\n\t \n\tvla_group(d);\n\tvla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,\n\t\tfull ? ffs->fs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,\n\t\thigh ? ffs->hs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,\n\t\tsuper ? ffs->ss_descs_count + 1 : 0);\n\tvla_item_with_sz(d, short, inums, ffs->interfaces_count);\n\tvla_item_with_sz(d, struct usb_os_desc_table, os_desc_table,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, char[16], ext_compat,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc, os_desc,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc_ext_prop, ext_prop,\n\t\t\t ffs->ms_os_descs_ext_prop_count);\n\tvla_item_with_sz(d, char, ext_prop_name,\n\t\t\t ffs->ms_os_descs_ext_prop_name_len);\n\tvla_item_with_sz(d, char, ext_prop_data,\n\t\t\t ffs->ms_os_descs_ext_prop_data_len);\n\tvla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);\n\tchar *vlabuf;\n\n\t \n\tif (!(full | high | super))\n\t\treturn -ENOTSUPP;\n\n\t \n\tvlabuf = kzalloc(vla_group_size(d), GFP_KERNEL);\n\tif (!vlabuf)\n\t\treturn -ENOMEM;\n\n\tffs->ms_os_descs_ext_prop_avail = vla_ptr(vlabuf, d, ext_prop);\n\tffs->ms_os_descs_ext_prop_name_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_name);\n\tffs->ms_os_descs_ext_prop_data_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_data);\n\n\t \n\tmemcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs,\n\t       ffs->raw_descs_length);\n\n\tmemset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);\n\teps_ptr = vla_ptr(vlabuf, d, eps);\n\tfor (i = 0; i < ffs->eps_count; i++)\n\t\teps_ptr[i].num = -1;\n\n\t \n\tfunc->eps             = vla_ptr(vlabuf, d, eps);\n\tfunc->interfaces_nums = vla_ptr(vlabuf, d, inums);\n\n\t \n\tif (full) {\n\t\tfunc->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);\n\t\tfs_len = ffs_do_descs(ffs->fs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs),\n\t\t\t\t      d_raw_descs__sz,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (fs_len < 0) {\n\t\t\tret = fs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tfs_len = 0;\n\t}\n\n\tif (high) {\n\t\tfunc->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);\n\t\ths_len = ffs_do_descs(ffs->hs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs) + fs_len,\n\t\t\t\t      d_raw_descs__sz - fs_len,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (hs_len < 0) {\n\t\t\tret = hs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\ths_len = 0;\n\t}\n\n\tif (super) {\n\t\tfunc->function.ss_descriptors = func->function.ssp_descriptors =\n\t\t\tvla_ptr(vlabuf, d, ss_descs);\n\t\tss_len = ffs_do_descs(ffs->ss_descs_count,\n\t\t\t\tvla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,\n\t\t\t\td_raw_descs__sz - fs_len - hs_len,\n\t\t\t\t__ffs_func_bind_do_descs, func);\n\t\tif (ss_len < 0) {\n\t\t\tret = ss_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tss_len = 0;\n\t}\n\n\t \n\tret = ffs_do_descs(ffs->fs_descs_count +\n\t\t\t   (high ? ffs->hs_descs_count : 0) +\n\t\t\t   (super ? ffs->ss_descs_count : 0),\n\t\t\t   vla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,\n\t\t\t   __ffs_func_bind_do_nums, func);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tfunc->function.os_desc_table = vla_ptr(vlabuf, d, os_desc_table);\n\tif (c->cdev->use_os_string) {\n\t\tfor (i = 0; i < ffs->interfaces_count; ++i) {\n\t\t\tstruct usb_os_desc *desc;\n\n\t\t\tdesc = func->function.os_desc_table[i].os_desc =\n\t\t\t\tvla_ptr(vlabuf, d, os_desc) +\n\t\t\t\ti * sizeof(struct usb_os_desc);\n\t\t\tdesc->ext_compat_id =\n\t\t\t\tvla_ptr(vlabuf, d, ext_compat) + i * 16;\n\t\t\tINIT_LIST_HEAD(&desc->ext_prop);\n\t\t}\n\t\tret = ffs_do_os_descs(ffs->ms_os_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs) +\n\t\t\t\t      fs_len + hs_len + ss_len,\n\t\t\t\t      d_raw_descs__sz - fs_len - hs_len -\n\t\t\t\t      ss_len,\n\t\t\t\t      __ffs_func_bind_do_os_desc, func);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\tfunc->function.os_desc_n =\n\t\tc->cdev->use_os_string ? ffs->interfaces_count : 0;\n\n\t \n\tffs_event_add(ffs, FUNCTIONFS_BIND);\n\treturn 0;\n\nerror:\n\t \n\treturn ret;\n}\n\nstatic int ffs_func_bind(struct usb_configuration *c,\n\t\t\t struct usb_function *f)\n{\n\tstruct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tint ret;\n\n\tif (IS_ERR(ffs_opts))\n\t\treturn PTR_ERR(ffs_opts);\n\n\tret = _ffs_func_bind(c, f);\n\tif (ret && !--ffs_opts->refcnt)\n\t\tfunctionfs_unbind(func->ffs);\n\n\treturn ret;\n}\n\n\n \n\nstatic void ffs_reset_work(struct work_struct *work)\n{\n\tstruct ffs_data *ffs = container_of(work,\n\t\tstruct ffs_data, reset_work);\n\tffs_data_reset(ffs);\n}\n\nstatic int ffs_func_set_alt(struct usb_function *f,\n\t\t\t    unsigned interface, unsigned alt)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tint ret = 0, intf;\n\n\tif (alt != (unsigned)-1) {\n\t\tintf = ffs_func_revmap_intf(func, interface);\n\t\tif (intf < 0)\n\t\t\treturn intf;\n\t}\n\n\tif (ffs->func)\n\t\tffs_func_eps_disable(ffs->func);\n\n\tif (ffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tINIT_WORK(&ffs->reset_work, ffs_reset_work);\n\t\tschedule_work(&ffs->reset_work);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tif (alt == (unsigned)-1) {\n\t\tffs->func = NULL;\n\t\tffs_event_add(ffs, FUNCTIONFS_DISABLE);\n\t\treturn 0;\n\t}\n\n\tffs->func = func;\n\tret = ffs_func_eps_enable(func);\n\tif (ret >= 0)\n\t\tffs_event_add(ffs, FUNCTIONFS_ENABLE);\n\treturn ret;\n}\n\nstatic void ffs_func_disable(struct usb_function *f)\n{\n\tffs_func_set_alt(f, 0, (unsigned)-1);\n}\n\nstatic int ffs_func_setup(struct usb_function *f,\n\t\t\t  const struct usb_ctrlrequest *creq)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tunsigned long flags;\n\tint ret;\n\n\tpr_vdebug(\"creq->bRequestType = %02x\\n\", creq->bRequestType);\n\tpr_vdebug(\"creq->bRequest     = %02x\\n\", creq->bRequest);\n\tpr_vdebug(\"creq->wValue       = %04x\\n\", le16_to_cpu(creq->wValue));\n\tpr_vdebug(\"creq->wIndex       = %04x\\n\", le16_to_cpu(creq->wIndex));\n\tpr_vdebug(\"creq->wLength      = %04x\\n\", le16_to_cpu(creq->wLength));\n\n\t \n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tswitch (creq->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_INTERFACE:\n\t\tret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tret = func->ffs->eps_addrmap[ret];\n\t\tbreak;\n\n\tdefault:\n\t\tif (func->ffs->user_flags & FUNCTIONFS_ALL_CTRL_RECIP)\n\t\t\tret = le16_to_cpu(creq->wIndex);\n\t\telse\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\tffs->ev.setup = *creq;\n\tffs->ev.setup.wIndex = cpu_to_le16(ret);\n\t__ffs_event_add(ffs, FUNCTIONFS_SETUP);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n\n\treturn creq->wLength == 0 ? USB_GADGET_DELAYED_STATUS : 0;\n}\n\nstatic bool ffs_func_req_match(struct usb_function *f,\n\t\t\t       const struct usb_ctrlrequest *creq,\n\t\t\t       bool config0)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\n\tif (config0 && !(func->ffs->user_flags & FUNCTIONFS_CONFIG0_SETUP))\n\t\treturn false;\n\n\tswitch (creq->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_INTERFACE:\n\t\treturn (ffs_func_revmap_intf(func,\n\t\t\t\t\t     le16_to_cpu(creq->wIndex)) >= 0);\n\tcase USB_RECIP_ENDPOINT:\n\t\treturn (ffs_func_revmap_ep(func,\n\t\t\t\t\t   le16_to_cpu(creq->wIndex)) >= 0);\n\tdefault:\n\t\treturn (bool) (func->ffs->user_flags &\n\t\t\t       FUNCTIONFS_ALL_CTRL_RECIP);\n\t}\n}\n\nstatic void ffs_func_suspend(struct usb_function *f)\n{\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);\n}\n\nstatic void ffs_func_resume(struct usb_function *f)\n{\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);\n}\n\n\n \n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num)\n{\n\tnum = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];\n\treturn num ? num : -EDOM;\n}\n\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\n{\n\tshort *nums = func->interfaces_nums;\n\tunsigned count = func->ffs->interfaces_count;\n\n\tfor (; count; --count, ++nums) {\n\t\tif (*nums >= 0 && *nums == intf)\n\t\t\treturn nums - func->interfaces_nums;\n\t}\n\n\treturn -EDOM;\n}\n\n\n \n\nstatic LIST_HEAD(ffs_devices);\n\nstatic struct ffs_dev *_ffs_do_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(dev, &ffs_devices, entry) {\n\t\tif (strcmp(dev->name, name) == 0)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct ffs_dev *_ffs_get_single_dev(void)\n{\n\tstruct ffs_dev *dev;\n\n\tif (list_is_singular(&ffs_devices)) {\n\t\tdev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\n\t\tif (dev->single)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic struct ffs_dev *_ffs_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tdev = _ffs_get_single_dev();\n\tif (dev)\n\t\treturn dev;\n\n\treturn _ffs_do_find_dev(name);\n}\n\n \n\nstatic inline struct f_fs_opts *to_ffs_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_fs_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void ffs_attr_release(struct config_item *item)\n{\n\tstruct f_fs_opts *opts = to_ffs_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations ffs_item_ops = {\n\t.release\t= ffs_attr_release,\n};\n\nstatic const struct config_item_type ffs_func_type = {\n\t.ct_item_ops\t= &ffs_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n\n \n\nstatic void ffs_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_fs_opts *opts;\n\n\topts = to_f_fs_opts(f);\n\tffs_release_dev(opts->dev);\n\tffs_dev_lock();\n\t_ffs_free_dev(opts->dev);\n\tffs_dev_unlock();\n\tkfree(opts);\n}\n\nstatic int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)\n{\n\tif (strlen(name) >= sizeof_field(struct ffs_dev, name))\n\t\treturn -ENAMETOOLONG;\n\treturn ffs_name_dev(to_f_fs_opts(fi)->dev, name);\n}\n\nstatic struct usb_function_instance *ffs_alloc_inst(void)\n{\n\tstruct f_fs_opts *opts;\n\tstruct ffs_dev *dev;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.set_inst_name = ffs_set_inst_name;\n\topts->func_inst.free_func_inst = ffs_free_inst;\n\tffs_dev_lock();\n\tdev = _ffs_alloc_dev();\n\tffs_dev_unlock();\n\tif (IS_ERR(dev)) {\n\t\tkfree(opts);\n\t\treturn ERR_CAST(dev);\n\t}\n\topts->dev = dev;\n\tdev->opts = opts;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &ffs_func_type);\n\treturn &opts->func_inst;\n}\n\nstatic void ffs_free(struct usb_function *f)\n{\n\tkfree(ffs_func_from_usb(f));\n}\n\nstatic void ffs_func_unbind(struct usb_configuration *c,\n\t\t\t    struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tstruct f_fs_opts *opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tstruct ffs_ep *ep = func->eps;\n\tunsigned count = ffs->eps_count;\n\tunsigned long flags;\n\n\tif (ffs->func == func) {\n\t\tffs_func_eps_disable(func);\n\t\tffs->func = NULL;\n\t}\n\n\t \n\tdrain_workqueue(ffs->io_completion_wq);\n\n\tffs_event_add(ffs, FUNCTIONFS_UNBIND);\n\tif (!--opts->refcnt)\n\t\tfunctionfs_unbind(ffs);\n\n\t \n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\twhile (count--) {\n\t\tif (ep->ep && ep->req)\n\t\t\tusb_ep_free_request(ep->ep, ep->req);\n\t\tep->req = NULL;\n\t\t++ep;\n\t}\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\tkfree(func->eps);\n\tfunc->eps = NULL;\n\t \n\tfunc->function.fs_descriptors = NULL;\n\tfunc->function.hs_descriptors = NULL;\n\tfunc->function.ss_descriptors = NULL;\n\tfunc->function.ssp_descriptors = NULL;\n\tfunc->interfaces_nums = NULL;\n\n}\n\nstatic struct usb_function *ffs_alloc(struct usb_function_instance *fi)\n{\n\tstruct ffs_function *func;\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (!func)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfunc->function.name    = \"Function FS Gadget\";\n\n\tfunc->function.bind    = ffs_func_bind;\n\tfunc->function.unbind  = ffs_func_unbind;\n\tfunc->function.set_alt = ffs_func_set_alt;\n\tfunc->function.disable = ffs_func_disable;\n\tfunc->function.setup   = ffs_func_setup;\n\tfunc->function.req_match = ffs_func_req_match;\n\tfunc->function.suspend = ffs_func_suspend;\n\tfunc->function.resume  = ffs_func_resume;\n\tfunc->function.free_func = ffs_free;\n\n\treturn &func->function;\n}\n\n \nstatic struct ffs_dev *_ffs_alloc_dev(void)\n{\n\tstruct ffs_dev *dev;\n\tint ret;\n\n\tif (_ffs_get_single_dev())\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (list_empty(&ffs_devices)) {\n\t\tret = functionfs_init();\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tlist_add(&dev->entry, &ffs_devices);\n\n\treturn dev;\n}\n\nint ffs_name_dev(struct ffs_dev *dev, const char *name)\n{\n\tstruct ffs_dev *existing;\n\tint ret = 0;\n\n\tffs_dev_lock();\n\n\texisting = _ffs_do_find_dev(name);\n\tif (!existing)\n\t\tstrscpy(dev->name, name, ARRAY_SIZE(dev->name));\n\telse if (existing != dev)\n\t\tret = -EBUSY;\n\n\tffs_dev_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_name_dev);\n\nint ffs_single_dev(struct ffs_dev *dev)\n{\n\tint ret;\n\n\tret = 0;\n\tffs_dev_lock();\n\n\tif (!list_is_singular(&ffs_devices))\n\t\tret = -EBUSY;\n\telse\n\t\tdev->single = true;\n\n\tffs_dev_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_single_dev);\n\n \nstatic void _ffs_free_dev(struct ffs_dev *dev)\n{\n\tlist_del(&dev->entry);\n\n\tkfree(dev);\n\tif (list_empty(&ffs_devices))\n\t\tfunctionfs_cleanup();\n}\n\nstatic int ffs_acquire_dev(const char *dev_name, struct ffs_data *ffs_data)\n{\n\tint ret = 0;\n\tstruct ffs_dev *ffs_dev;\n\n\tffs_dev_lock();\n\n\tffs_dev = _ffs_find_dev(dev_name);\n\tif (!ffs_dev) {\n\t\tret = -ENOENT;\n\t} else if (ffs_dev->mounted) {\n\t\tret = -EBUSY;\n\t} else if (ffs_dev->ffs_acquire_dev_callback &&\n\t\t   ffs_dev->ffs_acquire_dev_callback(ffs_dev)) {\n\t\tret = -ENOENT;\n\t} else {\n\t\tffs_dev->mounted = true;\n\t\tffs_dev->ffs_data = ffs_data;\n\t\tffs_data->private_data = ffs_dev;\n\t}\n\n\tffs_dev_unlock();\n\treturn ret;\n}\n\nstatic void ffs_release_dev(struct ffs_dev *ffs_dev)\n{\n\tffs_dev_lock();\n\n\tif (ffs_dev && ffs_dev->mounted) {\n\t\tffs_dev->mounted = false;\n\t\tif (ffs_dev->ffs_data) {\n\t\t\tffs_dev->ffs_data->private_data = NULL;\n\t\t\tffs_dev->ffs_data = NULL;\n\t\t}\n\n\t\tif (ffs_dev->ffs_release_dev_callback)\n\t\t\tffs_dev->ffs_release_dev_callback(ffs_dev);\n\t}\n\n\tffs_dev_unlock();\n}\n\nstatic int ffs_ready(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tint ret = 0;\n\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (WARN_ON(ffs_obj->desc_ready)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tffs_obj->desc_ready = true;\n\n\tif (ffs_obj->ffs_ready_callback) {\n\t\tret = ffs_obj->ffs_ready_callback(ffs);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tset_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);\ndone:\n\tffs_dev_unlock();\n\treturn ret;\n}\n\nstatic void ffs_closed(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tstruct f_fs_opts *opts;\n\tstruct config_item *ci;\n\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj)\n\t\tgoto done;\n\n\tffs_obj->desc_ready = false;\n\n\tif (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags) &&\n\t    ffs_obj->ffs_closed_callback)\n\t\tffs_obj->ffs_closed_callback(ffs);\n\n\tif (ffs_obj->opts)\n\t\topts = ffs_obj->opts;\n\telse\n\t\tgoto done;\n\n\tif (opts->no_configfs || !opts->func_inst.group.cg_item.ci_parent\n\t    || !kref_read(&opts->func_inst.group.cg_item.ci_kref))\n\t\tgoto done;\n\n\tci = opts->func_inst.group.cg_item.ci_parent->ci_parent;\n\tffs_dev_unlock();\n\n\tif (test_bit(FFS_FL_BOUND, &ffs->flags))\n\t\tunregister_gadget_item(ci);\n\treturn;\ndone:\n\tffs_dev_unlock();\n}\n\n \n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n{\n\treturn nonblock\n\t\t? mutex_trylock(mutex) ? 0 : -EAGAIN\n\t\t: mutex_lock_interruptible(mutex);\n}\n\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n{\n\tchar *data;\n\n\tif (!len)\n\t\treturn NULL;\n\n\tdata = memdup_user(buf, len);\n\tif (IS_ERR(data))\n\t\treturn data;\n\n\tpr_vdebug(\"Buffer from user space:\\n\");\n\tffs_dump_mem(\"\", data, len);\n\n\treturn data;\n}\n\nDECLARE_USB_FUNCTION_INIT(ffs, ffs_alloc_inst, ffs_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Nazarewicz\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}