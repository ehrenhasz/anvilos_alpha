{
  "module_name": "f_mass_storage.c",
  "hash_id": "9c0a1398b14865365a4f53f6af20fc3046028aae5f15fbc3f69059d118ce8a43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_mass_storage.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n\n \n \n\n#include <linux/blkdev.h>\n#include <linux/completion.h>\n#include <linux/dcache.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/kstrtox.h>\n#include <linux/kthread.h>\n#include <linux/sched/signal.h>\n#include <linux/limits.h>\n#include <linux/pagemap.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/freezer.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/composite.h>\n\n#include <linux/nospec.h>\n\n#include \"configfs.h\"\n\n\n \n\n#define FSG_DRIVER_DESC\t\t\"Mass Storage Function\"\n#define FSG_DRIVER_VERSION\t\"2009/09/11\"\n\nstatic const char fsg_string_interface[] = \"Mass Storage\";\n\n#include \"storage_common.h\"\n#include \"f_mass_storage.h\"\n\n \nstatic struct usb_string\t\tfsg_strings[] = {\n\t{FSG_STRING_INTERFACE,\t\tfsg_string_interface},\n\t{}\n};\n\nstatic struct usb_gadget_strings\tfsg_stringtab = {\n\t.language\t= 0x0409,\t\t \n\t.strings\t= fsg_strings,\n};\n\nstatic struct usb_gadget_strings *fsg_strings_array[] = {\n\t&fsg_stringtab,\n\tNULL,\n};\n\n \n\nstruct fsg_dev;\nstruct fsg_common;\n\n \nstruct fsg_common {\n\tstruct usb_gadget\t*gadget;\n\tstruct usb_composite_dev *cdev;\n\tstruct fsg_dev\t\t*fsg;\n\twait_queue_head_t\tio_wait;\n\twait_queue_head_t\tfsg_wait;\n\n\t \n\tstruct rw_semaphore\tfilesem;\n\n\t \n\tspinlock_t\t\tlock;\n\n\tstruct usb_ep\t\t*ep0;\t\t \n\tstruct usb_request\t*ep0req;\t \n\tunsigned int\t\tep0_req_tag;\n\n\tstruct fsg_buffhd\t*next_buffhd_to_fill;\n\tstruct fsg_buffhd\t*next_buffhd_to_drain;\n\tstruct fsg_buffhd\t*buffhds;\n\tunsigned int\t\tfsg_num_buffers;\n\n\tint\t\t\tcmnd_size;\n\tu8\t\t\tcmnd[MAX_COMMAND_SIZE];\n\n\tunsigned int\t\tlun;\n\tstruct fsg_lun\t\t*luns[FSG_MAX_LUNS];\n\tstruct fsg_lun\t\t*curlun;\n\n\tunsigned int\t\tbulk_out_maxpacket;\n\tenum fsg_state\t\tstate;\t\t \n\tunsigned int\t\texception_req_tag;\n\tvoid\t\t\t*exception_arg;\n\n\tenum data_direction\tdata_dir;\n\tu32\t\t\tdata_size;\n\tu32\t\t\tdata_size_from_cmnd;\n\tu32\t\t\ttag;\n\tu32\t\t\tresidue;\n\tu32\t\t\tusb_amount_left;\n\n\tunsigned int\t\tcan_stall:1;\n\tunsigned int\t\tfree_storage_on_release:1;\n\tunsigned int\t\tphase_error:1;\n\tunsigned int\t\tshort_packet_received:1;\n\tunsigned int\t\tbad_lun_okay:1;\n\tunsigned int\t\trunning:1;\n\tunsigned int\t\tsysfs:1;\n\n\tstruct completion\tthread_notifier;\n\tstruct task_struct\t*thread_task;\n\n\t \n\tvoid\t\t\t*private_data;\n\n\tchar inquiry_string[INQUIRY_STRING_LEN];\n};\n\nstruct fsg_dev {\n\tstruct usb_function\tfunction;\n\tstruct usb_gadget\t*gadget;\t \n\tstruct fsg_common\t*common;\n\n\tu16\t\t\tinterface_number;\n\n\tunsigned int\t\tbulk_in_enabled:1;\n\tunsigned int\t\tbulk_out_enabled:1;\n\n\tunsigned long\t\tatomic_bitflags;\n#define IGNORE_BULK_OUT\t\t0\n\n\tstruct usb_ep\t\t*bulk_in;\n\tstruct usb_ep\t\t*bulk_out;\n};\n\nstatic inline int __fsg_is_set(struct fsg_common *common,\n\t\t\t       const char *func, unsigned line)\n{\n\tif (common->fsg)\n\t\treturn 1;\n\tERROR(common, \"common->fsg is NULL in %s at %u\\n\", func, line);\n\tWARN_ON(1);\n\treturn 0;\n}\n\n#define fsg_is_set(common) likely(__fsg_is_set(common, __func__, __LINE__))\n\nstatic inline struct fsg_dev *fsg_from_func(struct usb_function *f)\n{\n\treturn container_of(f, struct fsg_dev, function);\n}\n\nstatic int exception_in_progress(struct fsg_common *common)\n{\n\treturn common->state > FSG_STATE_NORMAL;\n}\n\n \nstatic void set_bulk_out_req_length(struct fsg_common *common,\n\t\t\t\t    struct fsg_buffhd *bh, unsigned int length)\n{\n\tunsigned int\trem;\n\n\tbh->bulk_out_intended_length = length;\n\trem = length % common->bulk_out_maxpacket;\n\tif (rem > 0)\n\t\tlength += common->bulk_out_maxpacket - rem;\n\tbh->outreq->length = length;\n}\n\n\n \n\nstatic int fsg_set_halt(struct fsg_dev *fsg, struct usb_ep *ep)\n{\n\tconst char\t*name;\n\n\tif (ep == fsg->bulk_in)\n\t\tname = \"bulk-in\";\n\telse if (ep == fsg->bulk_out)\n\t\tname = \"bulk-out\";\n\telse\n\t\tname = ep->name;\n\tDBG(fsg, \"%s set halt\\n\", name);\n\treturn usb_ep_set_halt(ep);\n}\n\n\n \n\n \n\nstatic void __raise_exception(struct fsg_common *common, enum fsg_state new_state,\n\t\t\t      void *arg)\n{\n\tunsigned long\t\tflags;\n\n\t \n\tspin_lock_irqsave(&common->lock, flags);\n\tif (common->state <= new_state) {\n\t\tcommon->exception_req_tag = common->ep0_req_tag;\n\t\tcommon->state = new_state;\n\t\tcommon->exception_arg = arg;\n\t\tif (common->thread_task)\n\t\t\tsend_sig_info(SIGUSR1, SEND_SIG_PRIV,\n\t\t\t\t      common->thread_task);\n\t}\n\tspin_unlock_irqrestore(&common->lock, flags);\n}\n\nstatic void raise_exception(struct fsg_common *common, enum fsg_state new_state)\n{\n\t__raise_exception(common, new_state, NULL);\n}\n\n \n\nstatic int ep0_queue(struct fsg_common *common)\n{\n\tint\trc;\n\n\trc = usb_ep_queue(common->ep0, common->ep0req, GFP_ATOMIC);\n\tcommon->ep0->driver_data = common;\n\tif (rc != 0 && rc != -ESHUTDOWN) {\n\t\t \n\t\tWARNING(common, \"error in submission: %s --> %d\\n\",\n\t\t\tcommon->ep0->name, rc);\n\t}\n\treturn rc;\n}\n\n\n \n\n \n\nstatic void bulk_in_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct fsg_common\t*common = ep->driver_data;\n\tstruct fsg_buffhd\t*bh = req->context;\n\n\tif (req->status || req->actual != req->length)\n\t\tDBG(common, \"%s --> %d, %u/%u\\n\", __func__,\n\t\t    req->status, req->actual, req->length);\n\tif (req->status == -ECONNRESET)\t\t \n\t\tusb_ep_fifo_flush(ep);\n\n\t \n\tsmp_store_release(&bh->state, BUF_STATE_EMPTY);\n\twake_up(&common->io_wait);\n}\n\nstatic void bulk_out_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct fsg_common\t*common = ep->driver_data;\n\tstruct fsg_buffhd\t*bh = req->context;\n\n\tdump_msg(common, \"bulk-out\", req->buf, req->actual);\n\tif (req->status || req->actual != bh->bulk_out_intended_length)\n\t\tDBG(common, \"%s --> %d, %u/%u\\n\", __func__,\n\t\t    req->status, req->actual, bh->bulk_out_intended_length);\n\tif (req->status == -ECONNRESET)\t\t \n\t\tusb_ep_fifo_flush(ep);\n\n\t \n\tsmp_store_release(&bh->state, BUF_STATE_FULL);\n\twake_up(&common->io_wait);\n}\n\nstatic int _fsg_common_get_max_lun(struct fsg_common *common)\n{\n\tint i = ARRAY_SIZE(common->luns) - 1;\n\n\twhile (i >= 0 && !common->luns[i])\n\t\t--i;\n\n\treturn i;\n}\n\nstatic int fsg_setup(struct usb_function *f,\n\t\t     const struct usb_ctrlrequest *ctrl)\n{\n\tstruct fsg_dev\t\t*fsg = fsg_from_func(f);\n\tstruct usb_request\t*req = fsg->common->ep0req;\n\tu16\t\t\tw_index = le16_to_cpu(ctrl->wIndex);\n\tu16\t\t\tw_value = le16_to_cpu(ctrl->wValue);\n\tu16\t\t\tw_length = le16_to_cpu(ctrl->wLength);\n\n\tif (!fsg_is_set(fsg->common))\n\t\treturn -EOPNOTSUPP;\n\n\t++fsg->common->ep0_req_tag;\t \n\treq->context = NULL;\n\treq->length = 0;\n\tdump_msg(fsg, \"ep0-setup\", (u8 *) ctrl, sizeof(*ctrl));\n\n\tswitch (ctrl->bRequest) {\n\n\tcase US_BULK_RESET_REQUEST:\n\t\tif (ctrl->bRequestType !=\n\t\t    (USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\t\t\tbreak;\n\t\tif (w_index != fsg->interface_number || w_value != 0 ||\n\t\t\t\tw_length != 0)\n\t\t\treturn -EDOM;\n\n\t\t \n\t\tDBG(fsg, \"bulk reset request\\n\");\n\t\traise_exception(fsg->common, FSG_STATE_PROTOCOL_RESET);\n\t\treturn USB_GADGET_DELAYED_STATUS;\n\n\tcase US_BULK_GET_MAX_LUN:\n\t\tif (ctrl->bRequestType !=\n\t\t    (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE))\n\t\t\tbreak;\n\t\tif (w_index != fsg->interface_number || w_value != 0 ||\n\t\t\t\tw_length != 1)\n\t\t\treturn -EDOM;\n\t\tVDBG(fsg, \"get max LUN\\n\");\n\t\t*(u8 *)req->buf = _fsg_common_get_max_lun(fsg->common);\n\n\t\t \n\t\treq->length = min((u16)1, w_length);\n\t\treturn ep0_queue(fsg->common);\n\t}\n\n\tVDBG(fsg,\n\t     \"unknown class-specific control req %02x.%02x v%04x i%04x l%u\\n\",\n\t     ctrl->bRequestType, ctrl->bRequest,\n\t     le16_to_cpu(ctrl->wValue), w_index, w_length);\n\treturn -EOPNOTSUPP;\n}\n\n\n \n\n \n\n \nstatic int start_transfer(struct fsg_dev *fsg, struct usb_ep *ep,\n\t\t\t   struct usb_request *req)\n{\n\tint\trc;\n\n\tif (ep == fsg->bulk_in)\n\t\tdump_msg(fsg, \"bulk-in\", req->buf, req->length);\n\n\trc = usb_ep_queue(ep, req, GFP_KERNEL);\n\tif (rc) {\n\n\t\t \n\t\treq->status = rc;\n\n\t\t \n\t\tif (rc != -ESHUTDOWN &&\n\t\t\t\t!(rc == -EOPNOTSUPP && req->length == 0))\n\t\t\tWARNING(fsg, \"error in submission: %s --> %d\\n\",\n\t\t\t\t\tep->name, rc);\n\t}\n\treturn rc;\n}\n\nstatic bool start_in_transfer(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tif (!fsg_is_set(common))\n\t\treturn false;\n\tbh->state = BUF_STATE_SENDING;\n\tif (start_transfer(common->fsg, common->fsg->bulk_in, bh->inreq))\n\t\tbh->state = BUF_STATE_EMPTY;\n\treturn true;\n}\n\nstatic bool start_out_transfer(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tif (!fsg_is_set(common))\n\t\treturn false;\n\tbh->state = BUF_STATE_RECEIVING;\n\tif (start_transfer(common->fsg, common->fsg->bulk_out, bh->outreq))\n\t\tbh->state = BUF_STATE_FULL;\n\treturn true;\n}\n\nstatic int sleep_thread(struct fsg_common *common, bool can_freeze,\n\t\tstruct fsg_buffhd *bh)\n{\n\tint\trc;\n\n\t \n\tif (can_freeze)\n\t\t \n\t\trc = wait_event_freezable(common->io_wait,\n\t\t\t\tbh && smp_load_acquire(&bh->state) >=\n\t\t\t\t\tBUF_STATE_EMPTY);\n\telse\n\t\trc = wait_event_interruptible(common->io_wait,\n\t\t\t\tbh && smp_load_acquire(&bh->state) >=\n\t\t\t\t\tBUF_STATE_EMPTY);\n\treturn rc ? -EINTR : 0;\n}\n\n\n \n\nstatic int do_read(struct fsg_common *common)\n{\n\tstruct fsg_lun\t\t*curlun = common->curlun;\n\tu64\t\t\tlba;\n\tstruct fsg_buffhd\t*bh;\n\tint\t\t\trc;\n\tu32\t\t\tamount_left;\n\tloff_t\t\t\tfile_offset, file_offset_tmp;\n\tunsigned int\t\tamount;\n\tssize_t\t\t\tnread;\n\n\t \n\tif (common->cmnd[0] == READ_6)\n\t\tlba = get_unaligned_be24(&common->cmnd[1]);\n\telse {\n\t\tif (common->cmnd[0] == READ_16)\n\t\t\tlba = get_unaligned_be64(&common->cmnd[2]);\n\t\telse\t\t \n\t\t\tlba = get_unaligned_be32(&common->cmnd[2]);\n\n\t\t \n\t\tif ((common->cmnd[1] & ~0x18) != 0) {\n\t\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (lba >= curlun->num_sectors) {\n\t\tcurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\treturn -EINVAL;\n\t}\n\tfile_offset = ((loff_t) lba) << curlun->blkbits;\n\n\t \n\tamount_left = common->data_size_from_cmnd;\n\tif (unlikely(amount_left == 0))\n\t\treturn -EIO;\t\t \n\n\tfor (;;) {\n\t\t \n\t\tamount = min(amount_left, FSG_BUFLEN);\n\t\tamount = min((loff_t)amount,\n\t\t\t     curlun->file_length - file_offset);\n\n\t\t \n\t\tbh = common->next_buffhd_to_fill;\n\t\trc = sleep_thread(common, false, bh);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tif (amount == 0) {\n\t\t\tcurlun->sense_data =\n\t\t\t\t\tSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbh->inreq->length = 0;\n\t\t\tbh->state = BUF_STATE_FULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfile_offset_tmp = file_offset;\n\t\tnread = kernel_read(curlun->filp, bh->buf, amount,\n\t\t\t\t&file_offset_tmp);\n\t\tVLDBG(curlun, \"file read %u @ %llu -> %d\\n\", amount,\n\t\t      (unsigned long long)file_offset, (int)nread);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tif (nread < 0) {\n\t\t\tLDBG(curlun, \"error in file read: %d\\n\", (int)nread);\n\t\t\tnread = 0;\n\t\t} else if (nread < amount) {\n\t\t\tLDBG(curlun, \"partial file read: %d/%u\\n\",\n\t\t\t     (int)nread, amount);\n\t\t\tnread = round_down(nread, curlun->blksize);\n\t\t}\n\t\tfile_offset  += nread;\n\t\tamount_left  -= nread;\n\t\tcommon->residue -= nread;\n\n\t\t \n\t\tbh->inreq->length = nread;\n\t\tbh->state = BUF_STATE_FULL;\n\n\t\t \n\t\tif (nread < amount) {\n\t\t\tcurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (amount_left == 0)\n\t\t\tbreak;\t\t \n\n\t\t \n\t\tbh->inreq->zero = 0;\n\t\tif (!start_in_transfer(common, bh))\n\t\t\t \n\t\t\treturn -EIO;\n\t\tcommon->next_buffhd_to_fill = bh->next;\n\t}\n\n\treturn -EIO;\t\t \n}\n\n\n \n\nstatic int do_write(struct fsg_common *common)\n{\n\tstruct fsg_lun\t\t*curlun = common->curlun;\n\tu64\t\t\tlba;\n\tstruct fsg_buffhd\t*bh;\n\tint\t\t\tget_some_more;\n\tu32\t\t\tamount_left_to_req, amount_left_to_write;\n\tloff_t\t\t\tusb_offset, file_offset, file_offset_tmp;\n\tunsigned int\t\tamount;\n\tssize_t\t\t\tnwritten;\n\tint\t\t\trc;\n\n\tif (curlun->ro) {\n\t\tcurlun->sense_data = SS_WRITE_PROTECTED;\n\t\treturn -EINVAL;\n\t}\n\tspin_lock(&curlun->filp->f_lock);\n\tcurlun->filp->f_flags &= ~O_SYNC;\t \n\tspin_unlock(&curlun->filp->f_lock);\n\n\t \n\tif (common->cmnd[0] == WRITE_6)\n\t\tlba = get_unaligned_be24(&common->cmnd[1]);\n\telse {\n\t\tif (common->cmnd[0] == WRITE_16)\n\t\t\tlba = get_unaligned_be64(&common->cmnd[2]);\n\t\telse\t\t \n\t\t\tlba = get_unaligned_be32(&common->cmnd[2]);\n\n\t\t \n\t\tif (common->cmnd[1] & ~0x18) {\n\t\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!curlun->nofua && (common->cmnd[1] & 0x08)) {  \n\t\t\tspin_lock(&curlun->filp->f_lock);\n\t\t\tcurlun->filp->f_flags |= O_SYNC;\n\t\t\tspin_unlock(&curlun->filp->f_lock);\n\t\t}\n\t}\n\tif (lba >= curlun->num_sectors) {\n\t\tcurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tget_some_more = 1;\n\tfile_offset = usb_offset = ((loff_t) lba) << curlun->blkbits;\n\tamount_left_to_req = common->data_size_from_cmnd;\n\tamount_left_to_write = common->data_size_from_cmnd;\n\n\twhile (amount_left_to_write > 0) {\n\n\t\t \n\t\tbh = common->next_buffhd_to_fill;\n\t\tif (bh->state == BUF_STATE_EMPTY && get_some_more) {\n\n\t\t\t \n\t\t\tamount = min(amount_left_to_req, FSG_BUFLEN);\n\n\t\t\t \n\t\t\tif (usb_offset >= curlun->file_length) {\n\t\t\t\tget_some_more = 0;\n\t\t\t\tcurlun->sense_data =\n\t\t\t\t\tSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\t\t\tcurlun->sense_data_info =\n\t\t\t\t\tusb_offset >> curlun->blkbits;\n\t\t\t\tcurlun->info_valid = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tusb_offset += amount;\n\t\t\tcommon->usb_amount_left -= amount;\n\t\t\tamount_left_to_req -= amount;\n\t\t\tif (amount_left_to_req == 0)\n\t\t\t\tget_some_more = 0;\n\n\t\t\t \n\t\t\tset_bulk_out_req_length(common, bh, amount);\n\t\t\tif (!start_out_transfer(common, bh))\n\t\t\t\t \n\t\t\t\treturn -EIO;\n\t\t\tcommon->next_buffhd_to_fill = bh->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tbh = common->next_buffhd_to_drain;\n\t\tif (bh->state == BUF_STATE_EMPTY && !get_some_more)\n\t\t\tbreak;\t\t\t \n\n\t\t \n\t\trc = sleep_thread(common, false, bh);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tcommon->next_buffhd_to_drain = bh->next;\n\t\tbh->state = BUF_STATE_EMPTY;\n\n\t\t \n\t\tif (bh->outreq->status != 0) {\n\t\t\tcurlun->sense_data = SS_COMMUNICATION_FAILURE;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tamount = bh->outreq->actual;\n\t\tif (curlun->file_length - file_offset < amount) {\n\t\t\tLERROR(curlun, \"write %u @ %llu beyond end %llu\\n\",\n\t\t\t\t       amount, (unsigned long long)file_offset,\n\t\t\t\t       (unsigned long long)curlun->file_length);\n\t\t\tamount = curlun->file_length - file_offset;\n\t\t}\n\n\t\t \n\t\tamount = min(amount, bh->bulk_out_intended_length);\n\n\t\t \n\t\tamount = round_down(amount, curlun->blksize);\n\t\tif (amount == 0)\n\t\t\tgoto empty_write;\n\n\t\t \n\t\tfile_offset_tmp = file_offset;\n\t\tnwritten = kernel_write(curlun->filp, bh->buf, amount,\n\t\t\t\t&file_offset_tmp);\n\t\tVLDBG(curlun, \"file write %u @ %llu -> %d\\n\", amount,\n\t\t\t\t(unsigned long long)file_offset, (int)nwritten);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\t\t \n\n\t\tif (nwritten < 0) {\n\t\t\tLDBG(curlun, \"error in file write: %d\\n\",\n\t\t\t\t\t(int) nwritten);\n\t\t\tnwritten = 0;\n\t\t} else if (nwritten < amount) {\n\t\t\tLDBG(curlun, \"partial file write: %d/%u\\n\",\n\t\t\t\t\t(int) nwritten, amount);\n\t\t\tnwritten = round_down(nwritten, curlun->blksize);\n\t\t}\n\t\tfile_offset += nwritten;\n\t\tamount_left_to_write -= nwritten;\n\t\tcommon->residue -= nwritten;\n\n\t\t \n\t\tif (nwritten < amount) {\n\t\t\tcurlun->sense_data = SS_WRITE_ERROR;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbreak;\n\t\t}\n\n empty_write:\n\t\t \n\t\tif (bh->outreq->actual < bh->bulk_out_intended_length) {\n\t\t\tcommon->short_packet_received = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -EIO;\t\t \n}\n\n\n \n\nstatic int do_synchronize_cache(struct fsg_common *common)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\trc;\n\n\t \n\trc = fsg_lun_fsync_sub(curlun);\n\tif (rc)\n\t\tcurlun->sense_data = SS_WRITE_ERROR;\n\treturn 0;\n}\n\n\n \n\nstatic void invalidate_sub(struct fsg_lun *curlun)\n{\n\tstruct file\t*filp = curlun->filp;\n\tstruct inode\t*inode = file_inode(filp);\n\tunsigned long __maybe_unused\trc;\n\n\trc = invalidate_mapping_pages(inode->i_mapping, 0, -1);\n\tVLDBG(curlun, \"invalidate_mapping_pages -> %ld\\n\", rc);\n}\n\nstatic int do_verify(struct fsg_common *common)\n{\n\tstruct fsg_lun\t\t*curlun = common->curlun;\n\tu32\t\t\tlba;\n\tu32\t\t\tverification_length;\n\tstruct fsg_buffhd\t*bh = common->next_buffhd_to_fill;\n\tloff_t\t\t\tfile_offset, file_offset_tmp;\n\tu32\t\t\tamount_left;\n\tunsigned int\t\tamount;\n\tssize_t\t\t\tnread;\n\n\t \n\tlba = get_unaligned_be32(&common->cmnd[2]);\n\tif (lba >= curlun->num_sectors) {\n\t\tcurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (common->cmnd[1] & ~0x10) {\n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\tverification_length = get_unaligned_be16(&common->cmnd[7]);\n\tif (unlikely(verification_length == 0))\n\t\treturn -EIO;\t\t \n\n\t \n\tamount_left = verification_length << curlun->blkbits;\n\tfile_offset = ((loff_t) lba) << curlun->blkbits;\n\n\t \n\tfsg_lun_fsync_sub(curlun);\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\n\tinvalidate_sub(curlun);\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\n\t \n\twhile (amount_left > 0) {\n\t\t \n\t\tamount = min(amount_left, FSG_BUFLEN);\n\t\tamount = min((loff_t)amount,\n\t\t\t     curlun->file_length - file_offset);\n\t\tif (amount == 0) {\n\t\t\tcurlun->sense_data =\n\t\t\t\t\tSS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfile_offset_tmp = file_offset;\n\t\tnread = kernel_read(curlun->filp, bh->buf, amount,\n\t\t\t\t&file_offset_tmp);\n\t\tVLDBG(curlun, \"file read %u @ %llu -> %d\\n\", amount,\n\t\t\t\t(unsigned long long) file_offset,\n\t\t\t\t(int) nread);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\n\t\tif (nread < 0) {\n\t\t\tLDBG(curlun, \"error in file verify: %d\\n\", (int)nread);\n\t\t\tnread = 0;\n\t\t} else if (nread < amount) {\n\t\t\tLDBG(curlun, \"partial file verify: %d/%u\\n\",\n\t\t\t     (int)nread, amount);\n\t\t\tnread = round_down(nread, curlun->blksize);\n\t\t}\n\t\tif (nread == 0) {\n\t\t\tcurlun->sense_data = SS_UNRECOVERED_READ_ERROR;\n\t\t\tcurlun->sense_data_info =\n\t\t\t\tfile_offset >> curlun->blkbits;\n\t\t\tcurlun->info_valid = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfile_offset += nread;\n\t\tamount_left -= nread;\n\t}\n\treturn 0;\n}\n\n\n \n\nstatic int do_inquiry(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun *curlun = common->curlun;\n\tu8\t*buf = (u8 *) bh->buf;\n\n\tif (!curlun) {\t\t \n\t\tcommon->bad_lun_okay = 1;\n\t\tmemset(buf, 0, 36);\n\t\tbuf[0] = TYPE_NO_LUN;\t \n\t\tbuf[4] = 31;\t\t \n\t\treturn 36;\n\t}\n\n\tbuf[0] = curlun->cdrom ? TYPE_ROM : TYPE_DISK;\n\tbuf[1] = curlun->removable ? 0x80 : 0;\n\tbuf[2] = 2;\t\t \n\tbuf[3] = 2;\t\t \n\tbuf[4] = 31;\t\t \n\tbuf[5] = 0;\t\t \n\tbuf[6] = 0;\n\tbuf[7] = 0;\n\tif (curlun->inquiry_string[0])\n\t\tmemcpy(buf + 8, curlun->inquiry_string,\n\t\t       sizeof(curlun->inquiry_string));\n\telse\n\t\tmemcpy(buf + 8, common->inquiry_string,\n\t\t       sizeof(common->inquiry_string));\n\treturn 36;\n}\n\nstatic int do_request_sense(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tu8\t\t*buf = (u8 *) bh->buf;\n\tu32\t\tsd, sdinfo;\n\tint\t\tvalid;\n\n\t \n#if 0\n\tif (curlun && curlun->unit_attention_data != SS_NO_SENSE) {\n\t\tcurlun->sense_data = curlun->unit_attention_data;\n\t\tcurlun->unit_attention_data = SS_NO_SENSE;\n\t}\n#endif\n\n\tif (!curlun) {\t\t \n\t\tcommon->bad_lun_okay = 1;\n\t\tsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\n\t\tsdinfo = 0;\n\t\tvalid = 0;\n\t} else {\n\t\tsd = curlun->sense_data;\n\t\tsdinfo = curlun->sense_data_info;\n\t\tvalid = curlun->info_valid << 7;\n\t\tcurlun->sense_data = SS_NO_SENSE;\n\t\tcurlun->sense_data_info = 0;\n\t\tcurlun->info_valid = 0;\n\t}\n\n\tmemset(buf, 0, 18);\n\tbuf[0] = valid | 0x70;\t\t\t \n\tbuf[2] = SK(sd);\n\tput_unaligned_be32(sdinfo, &buf[3]);\t \n\tbuf[7] = 18 - 8;\t\t\t \n\tbuf[12] = ASC(sd);\n\tbuf[13] = ASCQ(sd);\n\treturn 18;\n}\n\nstatic int do_read_capacity(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tu32\t\tlba = get_unaligned_be32(&common->cmnd[2]);\n\tint\t\tpmi = common->cmnd[8];\n\tu8\t\t*buf = (u8 *)bh->buf;\n\tu32\t\tmax_lba;\n\n\t \n\tif (pmi > 1 || (pmi == 0 && lba != 0)) {\n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\tif (curlun->num_sectors < 0x100000000ULL)\n\t\tmax_lba = curlun->num_sectors - 1;\n\telse\n\t\tmax_lba = 0xffffffff;\n\tput_unaligned_be32(max_lba, &buf[0]);\t\t \n\tput_unaligned_be32(curlun->blksize, &buf[4]);\t \n\treturn 8;\n}\n\nstatic int do_read_capacity_16(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun  *curlun = common->curlun;\n\tu64\t\tlba = get_unaligned_be64(&common->cmnd[2]);\n\tint\t\tpmi = common->cmnd[14];\n\tu8\t\t*buf = (u8 *)bh->buf;\n\n\t \n\tif (pmi > 1 || (pmi == 0 && lba != 0)) {\n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\tput_unaligned_be64(curlun->num_sectors - 1, &buf[0]);\n\t\t\t\t\t\t\t \n\tput_unaligned_be32(curlun->blksize, &buf[8]);\t \n\n\t \n\tmemset(&buf[12], 0, 32 - 12);\n\treturn 32;\n}\n\nstatic int do_read_header(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\tmsf = common->cmnd[1] & 0x02;\n\tu32\t\tlba = get_unaligned_be32(&common->cmnd[2]);\n\tu8\t\t*buf = (u8 *)bh->buf;\n\n\tif (common->cmnd[1] & ~0x02) {\t\t \n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\tif (lba >= curlun->num_sectors) {\n\t\tcurlun->sense_data = SS_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE;\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(buf, 0, 8);\n\tbuf[0] = 0x01;\t\t \n\tstore_cdrom_address(&buf[4], msf, lba);\n\treturn 8;\n}\n\nstatic int do_read_toc(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\tmsf = common->cmnd[1] & 0x02;\n\tint\t\tstart_track = common->cmnd[6];\n\tu8\t\t*buf = (u8 *)bh->buf;\n\tu8\t\tformat;\n\tint\t\ti, len;\n\n\tformat = common->cmnd[2] & 0xf;\n\n\tif ((common->cmnd[1] & ~0x02) != 0 ||\t \n\t\t\t(start_track > 1 && format != 0x1)) {\n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (format == 0)\n\t\tformat = (common->cmnd[9] >> 6) & 0x3;\n\n\tswitch (format) {\n\tcase 0:\t \n\tcase 1:\t \n\t\tlen = 4 + 2*8;\t\t \n\t\tmemset(buf, 0, len);\n\t\tbuf[1] = len - 2;\t \n\t\tbuf[2] = 1;\t\t \n\t\tbuf[3] = 1;\t\t \n\t\tbuf[5] = 0x16;\t\t \n\t\tbuf[6] = 0x01;\t\t \n\t\tstore_cdrom_address(&buf[8], msf, 0);\n\n\t\tbuf[13] = 0x16;\t\t \n\t\tbuf[14] = 0xAA;\t\t \n\t\tstore_cdrom_address(&buf[16], msf, curlun->num_sectors);\n\t\treturn len;\n\n\tcase 2:\n\t\t \n\t\tlen = 4 + 3*11;\t\t \n\t\tmemset(buf, 0, len);\t \n\t\tbuf[1] = len - 2;\t \n\t\tbuf[2] = 1;\t\t \n\t\tbuf[3] = 1;\t\t \n\n\t\tbuf += 4;\n\t\t \n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tbuf[0] = 1;\t \n\t\t\tbuf[1] = 0x16;\t \n\t\t\t \n\t\t\tbuf[3] = 0xA0 + i;  \n\t\t\t \n\t\t\tbuf[8] = 1;\t \n\t\t\tbuf += 11;\t \n\t\t}\n\t\tbuf -= 11;\t\t \n\n\t\t \n\t\tstore_cdrom_address(&buf[7], msf, curlun->num_sectors);\n\t\treturn len;\n\n\tdefault:\n\t\t \n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int do_mode_sense(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\tmscmnd = common->cmnd[0];\n\tu8\t\t*buf = (u8 *) bh->buf;\n\tu8\t\t*buf0 = buf;\n\tint\t\tpc, page_code;\n\tint\t\tchangeable_values, all_pages;\n\tint\t\tvalid_page = 0;\n\tint\t\tlen, limit;\n\n\tif ((common->cmnd[1] & ~0x08) != 0) {\t \n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\tpc = common->cmnd[2] >> 6;\n\tpage_code = common->cmnd[2] & 0x3f;\n\tif (pc == 3) {\n\t\tcurlun->sense_data = SS_SAVING_PARAMETERS_NOT_SUPPORTED;\n\t\treturn -EINVAL;\n\t}\n\tchangeable_values = (pc == 1);\n\tall_pages = (page_code == 0x3f);\n\n\t \n\tmemset(buf, 0, 8);\n\tif (mscmnd == MODE_SENSE) {\n\t\tbuf[2] = (curlun->ro ? 0x80 : 0x00);\t\t \n\t\tbuf += 4;\n\t\tlimit = 255;\n\t} else {\t\t\t \n\t\tbuf[3] = (curlun->ro ? 0x80 : 0x00);\t\t \n\t\tbuf += 8;\n\t\tlimit = 65535;\t\t \n\t}\n\n\t \n\n\t \n\tif (page_code == 0x08 || all_pages) {\n\t\tvalid_page = 1;\n\t\tbuf[0] = 0x08;\t\t \n\t\tbuf[1] = 10;\t\t \n\t\tmemset(buf+2, 0, 10);\t \n\n\t\tif (!changeable_values) {\n\t\t\tbuf[2] = 0x04;\t \n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\tput_unaligned_be16(0xffff, &buf[4]);\n\t\t\t\t\t \n\t\t\t\t\t \n\t\t\tput_unaligned_be16(0xffff, &buf[8]);\n\t\t\t\t\t \n\t\t\tput_unaligned_be16(0xffff, &buf[10]);\n\t\t\t\t\t \n\t\t}\n\t\tbuf += 12;\n\t}\n\n\t \n\tlen = buf - buf0;\n\tif (!valid_page || len > limit) {\n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (mscmnd == MODE_SENSE)\n\t\tbuf0[0] = len - 1;\n\telse\n\t\tput_unaligned_be16(len - 2, buf0);\n\treturn len;\n}\n\nstatic int do_start_stop(struct fsg_common *common)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\tloej, start;\n\n\tif (!curlun) {\n\t\treturn -EINVAL;\n\t} else if (!curlun->removable) {\n\t\tcurlun->sense_data = SS_INVALID_COMMAND;\n\t\treturn -EINVAL;\n\t} else if ((common->cmnd[1] & ~0x01) != 0 ||  \n\t\t   (common->cmnd[4] & ~0x03) != 0) {  \n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\tloej  = common->cmnd[4] & 0x02;\n\tstart = common->cmnd[4] & 0x01;\n\n\t \n\tif (start) {\n\t\tif (!fsg_lun_is_open(curlun)) {\n\t\t\tcurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (curlun->prevent_medium_removal) {\n\t\tLDBG(curlun, \"unload attempt prevented\\n\");\n\t\tcurlun->sense_data = SS_MEDIUM_REMOVAL_PREVENTED;\n\t\treturn -EINVAL;\n\t}\n\n\tif (!loej)\n\t\treturn 0;\n\n\tup_read(&common->filesem);\n\tdown_write(&common->filesem);\n\tfsg_lun_close(curlun);\n\tup_write(&common->filesem);\n\tdown_read(&common->filesem);\n\n\treturn 0;\n}\n\nstatic int do_prevent_allow(struct fsg_common *common)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tint\t\tprevent;\n\n\tif (!common->curlun) {\n\t\treturn -EINVAL;\n\t} else if (!common->curlun->removable) {\n\t\tcommon->curlun->sense_data = SS_INVALID_COMMAND;\n\t\treturn -EINVAL;\n\t}\n\n\tprevent = common->cmnd[4] & 0x01;\n\tif ((common->cmnd[4] & ~0x01) != 0) {\t \n\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\treturn -EINVAL;\n\t}\n\n\tif (curlun->prevent_medium_removal && !prevent)\n\t\tfsg_lun_fsync_sub(curlun);\n\tcurlun->prevent_medium_removal = prevent;\n\treturn 0;\n}\n\nstatic int do_read_format_capacities(struct fsg_common *common,\n\t\t\tstruct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\tu8\t\t*buf = (u8 *) bh->buf;\n\n\tbuf[0] = buf[1] = buf[2] = 0;\n\tbuf[3] = 8;\t \n\tbuf += 4;\n\n\tput_unaligned_be32(curlun->num_sectors, &buf[0]);\n\t\t\t\t\t\t \n\tput_unaligned_be32(curlun->blksize, &buf[4]); \n\tbuf[4] = 0x02;\t\t\t\t \n\treturn 12;\n}\n\nstatic int do_mode_select(struct fsg_common *common, struct fsg_buffhd *bh)\n{\n\tstruct fsg_lun\t*curlun = common->curlun;\n\n\t \n\tif (curlun)\n\t\tcurlun->sense_data = SS_INVALID_COMMAND;\n\treturn -EINVAL;\n}\n\n\n \n\nstatic int halt_bulk_in_endpoint(struct fsg_dev *fsg)\n{\n\tint\trc;\n\n\trc = fsg_set_halt(fsg, fsg->bulk_in);\n\tif (rc == -EAGAIN)\n\t\tVDBG(fsg, \"delayed bulk-in endpoint halt\\n\");\n\twhile (rc != 0) {\n\t\tif (rc != -EAGAIN) {\n\t\t\tWARNING(fsg, \"usb_ep_set_halt -> %d\\n\", rc);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msleep_interruptible(100) != 0)\n\t\t\treturn -EINTR;\n\t\trc = usb_ep_set_halt(fsg->bulk_in);\n\t}\n\treturn rc;\n}\n\nstatic int wedge_bulk_in_endpoint(struct fsg_dev *fsg)\n{\n\tint\trc;\n\n\tDBG(fsg, \"bulk-in set wedge\\n\");\n\trc = usb_ep_set_wedge(fsg->bulk_in);\n\tif (rc == -EAGAIN)\n\t\tVDBG(fsg, \"delayed bulk-in endpoint wedge\\n\");\n\twhile (rc != 0) {\n\t\tif (rc != -EAGAIN) {\n\t\t\tWARNING(fsg, \"usb_ep_set_wedge -> %d\\n\", rc);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (msleep_interruptible(100) != 0)\n\t\t\treturn -EINTR;\n\t\trc = usb_ep_set_wedge(fsg->bulk_in);\n\t}\n\treturn rc;\n}\n\nstatic int throw_away_data(struct fsg_common *common)\n{\n\tstruct fsg_buffhd\t*bh, *bh2;\n\tu32\t\t\tamount;\n\tint\t\t\trc;\n\n\tfor (bh = common->next_buffhd_to_drain;\n\t     bh->state != BUF_STATE_EMPTY || common->usb_amount_left > 0;\n\t     bh = common->next_buffhd_to_drain) {\n\n\t\t \n\t\tbh2 = common->next_buffhd_to_fill;\n\t\tif (bh2->state == BUF_STATE_EMPTY &&\n\t\t\t\tcommon->usb_amount_left > 0) {\n\t\t\tamount = min(common->usb_amount_left, FSG_BUFLEN);\n\n\t\t\t \n\t\t\tset_bulk_out_req_length(common, bh2, amount);\n\t\t\tif (!start_out_transfer(common, bh2))\n\t\t\t\t \n\t\t\t\treturn -EIO;\n\t\t\tcommon->next_buffhd_to_fill = bh2->next;\n\t\t\tcommon->usb_amount_left -= amount;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\trc = sleep_thread(common, false, bh);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\tbh->state = BUF_STATE_EMPTY;\n\t\tcommon->next_buffhd_to_drain = bh->next;\n\n\t\t \n\t\tif (bh->outreq->actual < bh->bulk_out_intended_length ||\n\t\t\t\tbh->outreq->status != 0) {\n\t\t\traise_exception(common, FSG_STATE_ABORT_BULK_OUT);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int finish_reply(struct fsg_common *common)\n{\n\tstruct fsg_buffhd\t*bh = common->next_buffhd_to_fill;\n\tint\t\t\trc = 0;\n\n\tswitch (common->data_dir) {\n\tcase DATA_DIR_NONE:\n\t\tbreak;\t\t\t \n\n\t \n\tcase DATA_DIR_UNKNOWN:\n\t\tif (!common->can_stall) {\n\t\t\t \n\t\t} else if (fsg_is_set(common)) {\n\t\t\tfsg_set_halt(common->fsg, common->fsg->bulk_out);\n\t\t\trc = halt_bulk_in_endpoint(common->fsg);\n\t\t} else {\n\t\t\t \n\t\t\trc = -EIO;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase DATA_DIR_TO_HOST:\n\t\tif (common->data_size == 0) {\n\t\t\t \n\n\t\t \n\t\t} else if (!fsg_is_set(common)) {\n\t\t\trc = -EIO;\n\n\t\t \n\t\t} else if (common->residue == 0) {\n\t\t\tbh->inreq->zero = 0;\n\t\t\tif (!start_in_transfer(common, bh))\n\t\t\t\treturn -EIO;\n\t\t\tcommon->next_buffhd_to_fill = bh->next;\n\n\t\t \n\t\t} else {\n\t\t\tbh->inreq->zero = 1;\n\t\t\tif (!start_in_transfer(common, bh))\n\t\t\t\trc = -EIO;\n\t\t\tcommon->next_buffhd_to_fill = bh->next;\n\t\t\tif (common->can_stall)\n\t\t\t\trc = halt_bulk_in_endpoint(common->fsg);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase DATA_DIR_FROM_HOST:\n\t\tif (common->residue == 0) {\n\t\t\t \n\n\t\t \n\t\t} else if (common->short_packet_received) {\n\t\t\traise_exception(common, FSG_STATE_ABORT_BULK_OUT);\n\t\t\trc = -EINTR;\n\n\t\t \n#if 0\n\t\t} else if (common->can_stall) {\n\t\t\tif (fsg_is_set(common))\n\t\t\t\tfsg_set_halt(common->fsg,\n\t\t\t\t\t     common->fsg->bulk_out);\n\t\t\traise_exception(common, FSG_STATE_ABORT_BULK_OUT);\n\t\t\trc = -EINTR;\n#endif\n\n\t\t \n\t\t} else {\n\t\t\trc = throw_away_data(common);\n\t\t}\n\t\tbreak;\n\t}\n\treturn rc;\n}\n\nstatic void send_status(struct fsg_common *common)\n{\n\tstruct fsg_lun\t\t*curlun = common->curlun;\n\tstruct fsg_buffhd\t*bh;\n\tstruct bulk_cs_wrap\t*csw;\n\tint\t\t\trc;\n\tu8\t\t\tstatus = US_BULK_STAT_OK;\n\tu32\t\t\tsd, sdinfo = 0;\n\n\t \n\tbh = common->next_buffhd_to_fill;\n\trc = sleep_thread(common, false, bh);\n\tif (rc)\n\t\treturn;\n\n\tif (curlun) {\n\t\tsd = curlun->sense_data;\n\t\tsdinfo = curlun->sense_data_info;\n\t} else if (common->bad_lun_okay)\n\t\tsd = SS_NO_SENSE;\n\telse\n\t\tsd = SS_LOGICAL_UNIT_NOT_SUPPORTED;\n\n\tif (common->phase_error) {\n\t\tDBG(common, \"sending phase-error status\\n\");\n\t\tstatus = US_BULK_STAT_PHASE;\n\t\tsd = SS_INVALID_COMMAND;\n\t} else if (sd != SS_NO_SENSE) {\n\t\tDBG(common, \"sending command-failure status\\n\");\n\t\tstatus = US_BULK_STAT_FAIL;\n\t\tVDBG(common, \"  sense data: SK x%02x, ASC x%02x, ASCQ x%02x;\"\n\t\t\t\t\"  info x%x\\n\",\n\t\t\t\tSK(sd), ASC(sd), ASCQ(sd), sdinfo);\n\t}\n\n\t \n\tcsw = (void *)bh->buf;\n\n\tcsw->Signature = cpu_to_le32(US_BULK_CS_SIGN);\n\tcsw->Tag = common->tag;\n\tcsw->Residue = cpu_to_le32(common->residue);\n\tcsw->Status = status;\n\n\tbh->inreq->length = US_BULK_CS_WRAP_LEN;\n\tbh->inreq->zero = 0;\n\tif (!start_in_transfer(common, bh))\n\t\t \n\t\treturn;\n\n\tcommon->next_buffhd_to_fill = bh->next;\n\treturn;\n}\n\n\n \n\n \nstatic int check_command(struct fsg_common *common, int cmnd_size,\n\t\t\t enum data_direction data_dir, unsigned int mask,\n\t\t\t int needs_medium, const char *name)\n{\n\tint\t\t\ti;\n\tunsigned int\t\tlun = common->cmnd[1] >> 5;\n\tstatic const char\tdirletter[4] = {'u', 'o', 'i', 'n'};\n\tchar\t\t\thdlen[20];\n\tstruct fsg_lun\t\t*curlun;\n\n\thdlen[0] = 0;\n\tif (common->data_dir != DATA_DIR_UNKNOWN)\n\t\tsprintf(hdlen, \", H%c=%u\", dirletter[(int) common->data_dir],\n\t\t\tcommon->data_size);\n\tVDBG(common, \"SCSI command: %s;  Dc=%d, D%c=%u;  Hc=%d%s\\n\",\n\t     name, cmnd_size, dirletter[(int) data_dir],\n\t     common->data_size_from_cmnd, common->cmnd_size, hdlen);\n\n\t \n\tif (common->data_size_from_cmnd == 0)\n\t\tdata_dir = DATA_DIR_NONE;\n\tif (common->data_size < common->data_size_from_cmnd) {\n\t\t \n\t\tcommon->data_size_from_cmnd = common->data_size;\n\t\tcommon->phase_error = 1;\n\t}\n\tcommon->residue = common->data_size;\n\tcommon->usb_amount_left = common->data_size;\n\n\t \n\tif (common->data_dir != data_dir && common->data_size_from_cmnd > 0) {\n\t\tcommon->phase_error = 1;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cmnd_size != common->cmnd_size) {\n\n\t\t \n\t\tif (cmnd_size <= common->cmnd_size) {\n\t\t\tDBG(common, \"%s is buggy! Expected length %d \"\n\t\t\t    \"but we got %d\\n\", name,\n\t\t\t    cmnd_size, common->cmnd_size);\n\t\t\tcmnd_size = common->cmnd_size;\n\t\t} else {\n\t\t\tcommon->phase_error = 1;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (common->lun != lun)\n\t\tDBG(common, \"using LUN %u from CBW, not LUN %u from CDB\\n\",\n\t\t    common->lun, lun);\n\n\t \n\tcurlun = common->curlun;\n\tif (curlun) {\n\t\tif (common->cmnd[0] != REQUEST_SENSE) {\n\t\t\tcurlun->sense_data = SS_NO_SENSE;\n\t\t\tcurlun->sense_data_info = 0;\n\t\t\tcurlun->info_valid = 0;\n\t\t}\n\t} else {\n\t\tcommon->bad_lun_okay = 0;\n\n\t\t \n\t\tif (common->cmnd[0] != INQUIRY &&\n\t\t    common->cmnd[0] != REQUEST_SENSE) {\n\t\t\tDBG(common, \"unsupported LUN %u\\n\", common->lun);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (curlun && curlun->unit_attention_data != SS_NO_SENSE &&\n\t    common->cmnd[0] != INQUIRY &&\n\t    common->cmnd[0] != REQUEST_SENSE) {\n\t\tcurlun->sense_data = curlun->unit_attention_data;\n\t\tcurlun->unit_attention_data = SS_NO_SENSE;\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcommon->cmnd[1] &= 0x1f;\t\t\t \n\tfor (i = 1; i < cmnd_size; ++i) {\n\t\tif (common->cmnd[i] && !(mask & (1 << i))) {\n\t\t\tif (curlun)\n\t\t\t\tcurlun->sense_data = SS_INVALID_FIELD_IN_CDB;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tif (curlun && !fsg_lun_is_open(curlun) && needs_medium) {\n\t\tcurlun->sense_data = SS_MEDIUM_NOT_PRESENT;\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int check_command_size_in_blocks(struct fsg_common *common,\n\t\tint cmnd_size, enum data_direction data_dir,\n\t\tunsigned int mask, int needs_medium, const char *name)\n{\n\tif (common->curlun)\n\t\tcommon->data_size_from_cmnd <<= common->curlun->blkbits;\n\treturn check_command(common, cmnd_size, data_dir,\n\t\t\tmask, needs_medium, name);\n}\n\nstatic int do_scsi_command(struct fsg_common *common)\n{\n\tstruct fsg_buffhd\t*bh;\n\tint\t\t\trc;\n\tint\t\t\treply = -EINVAL;\n\tint\t\t\ti;\n\tstatic char\t\tunknown[16];\n\n\tdump_cdb(common);\n\n\t \n\tbh = common->next_buffhd_to_fill;\n\tcommon->next_buffhd_to_drain = bh;\n\trc = sleep_thread(common, false, bh);\n\tif (rc)\n\t\treturn rc;\n\n\tcommon->phase_error = 0;\n\tcommon->short_packet_received = 0;\n\n\tdown_read(&common->filesem);\t \n\tswitch (common->cmnd[0]) {\n\n\tcase INQUIRY:\n\t\tcommon->data_size_from_cmnd = common->cmnd[4];\n\t\treply = check_command(common, 6, DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<4), 0,\n\t\t\t\t      \"INQUIRY\");\n\t\tif (reply == 0)\n\t\t\treply = do_inquiry(common, bh);\n\t\tbreak;\n\n\tcase MODE_SELECT:\n\t\tcommon->data_size_from_cmnd = common->cmnd[4];\n\t\treply = check_command(common, 6, DATA_DIR_FROM_HOST,\n\t\t\t\t      (1<<1) | (1<<4), 0,\n\t\t\t\t      \"MODE SELECT(6)\");\n\t\tif (reply == 0)\n\t\t\treply = do_mode_select(common, bh);\n\t\tbreak;\n\n\tcase MODE_SELECT_10:\n\t\tcommon->data_size_from_cmnd =\n\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command(common, 10, DATA_DIR_FROM_HOST,\n\t\t\t\t      (1<<1) | (3<<7), 0,\n\t\t\t\t      \"MODE SELECT(10)\");\n\t\tif (reply == 0)\n\t\t\treply = do_mode_select(common, bh);\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tcommon->data_size_from_cmnd = common->cmnd[4];\n\t\treply = check_command(common, 6, DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<1) | (1<<2) | (1<<4), 0,\n\t\t\t\t      \"MODE SENSE(6)\");\n\t\tif (reply == 0)\n\t\t\treply = do_mode_sense(common, bh);\n\t\tbreak;\n\n\tcase MODE_SENSE_10:\n\t\tcommon->data_size_from_cmnd =\n\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command(common, 10, DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<1) | (1<<2) | (3<<7), 0,\n\t\t\t\t      \"MODE SENSE(10)\");\n\t\tif (reply == 0)\n\t\t\treply = do_mode_sense(common, bh);\n\t\tbreak;\n\n\tcase ALLOW_MEDIUM_REMOVAL:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\treply = check_command(common, 6, DATA_DIR_NONE,\n\t\t\t\t      (1<<4), 0,\n\t\t\t\t      \"PREVENT-ALLOW MEDIUM REMOVAL\");\n\t\tif (reply == 0)\n\t\t\treply = do_prevent_allow(common);\n\t\tbreak;\n\n\tcase READ_6:\n\t\ti = common->cmnd[4];\n\t\tcommon->data_size_from_cmnd = (i == 0) ? 256 : i;\n\t\treply = check_command_size_in_blocks(common, 6,\n\t\t\t\t      DATA_DIR_TO_HOST,\n\t\t\t\t      (7<<1) | (1<<4), 1,\n\t\t\t\t      \"READ(6)\");\n\t\tif (reply == 0)\n\t\t\treply = do_read(common);\n\t\tbreak;\n\n\tcase READ_10:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command_size_in_blocks(common, 10,\n\t\t\t\t      DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<1) | (0xf<<2) | (3<<7), 1,\n\t\t\t\t      \"READ(10)\");\n\t\tif (reply == 0)\n\t\t\treply = do_read(common);\n\t\tbreak;\n\n\tcase READ_12:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be32(&common->cmnd[6]);\n\t\treply = check_command_size_in_blocks(common, 12,\n\t\t\t\t      DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<1) | (0xf<<2) | (0xf<<6), 1,\n\t\t\t\t      \"READ(12)\");\n\t\tif (reply == 0)\n\t\t\treply = do_read(common);\n\t\tbreak;\n\n\tcase READ_16:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be32(&common->cmnd[10]);\n\t\treply = check_command_size_in_blocks(common, 16,\n\t\t\t\t      DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<1) | (0xff<<2) | (0xf<<10), 1,\n\t\t\t\t      \"READ(16)\");\n\t\tif (reply == 0)\n\t\t\treply = do_read(common);\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t\tcommon->data_size_from_cmnd = 8;\n\t\treply = check_command(common, 10, DATA_DIR_TO_HOST,\n\t\t\t\t      (0xf<<2) | (1<<8), 1,\n\t\t\t\t      \"READ CAPACITY\");\n\t\tif (reply == 0)\n\t\t\treply = do_read_capacity(common, bh);\n\t\tbreak;\n\n\tcase READ_HEADER:\n\t\tif (!common->curlun || !common->curlun->cdrom)\n\t\t\tgoto unknown_cmnd;\n\t\tcommon->data_size_from_cmnd =\n\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command(common, 10, DATA_DIR_TO_HOST,\n\t\t\t\t      (3<<7) | (0x1f<<1), 1,\n\t\t\t\t      \"READ HEADER\");\n\t\tif (reply == 0)\n\t\t\treply = do_read_header(common, bh);\n\t\tbreak;\n\n\tcase READ_TOC:\n\t\tif (!common->curlun || !common->curlun->cdrom)\n\t\t\tgoto unknown_cmnd;\n\t\tcommon->data_size_from_cmnd =\n\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command(common, 10, DATA_DIR_TO_HOST,\n\t\t\t\t      (0xf<<6) | (3<<1), 1,\n\t\t\t\t      \"READ TOC\");\n\t\tif (reply == 0)\n\t\t\treply = do_read_toc(common, bh);\n\t\tbreak;\n\n\tcase READ_FORMAT_CAPACITIES:\n\t\tcommon->data_size_from_cmnd =\n\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command(common, 10, DATA_DIR_TO_HOST,\n\t\t\t\t      (3<<7), 1,\n\t\t\t\t      \"READ FORMAT CAPACITIES\");\n\t\tif (reply == 0)\n\t\t\treply = do_read_format_capacities(common, bh);\n\t\tbreak;\n\n\tcase REQUEST_SENSE:\n\t\tcommon->data_size_from_cmnd = common->cmnd[4];\n\t\treply = check_command(common, 6, DATA_DIR_TO_HOST,\n\t\t\t\t      (1<<4), 0,\n\t\t\t\t      \"REQUEST SENSE\");\n\t\tif (reply == 0)\n\t\t\treply = do_request_sense(common, bh);\n\t\tbreak;\n\n\tcase SERVICE_ACTION_IN_16:\n\t\tswitch (common->cmnd[1] & 0x1f) {\n\n\t\tcase SAI_READ_CAPACITY_16:\n\t\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be32(&common->cmnd[10]);\n\t\t\treply = check_command(common, 16, DATA_DIR_TO_HOST,\n\t\t\t\t\t      (1<<1) | (0xff<<2) | (0xf<<10) |\n\t\t\t\t\t      (1<<14), 1,\n\t\t\t\t\t      \"READ CAPACITY(16)\");\n\t\t\tif (reply == 0)\n\t\t\t\treply = do_read_capacity_16(common, bh);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto unknown_cmnd;\n\t\t}\n\t\tbreak;\n\n\tcase START_STOP:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\treply = check_command(common, 6, DATA_DIR_NONE,\n\t\t\t\t      (1<<1) | (1<<4), 0,\n\t\t\t\t      \"START-STOP UNIT\");\n\t\tif (reply == 0)\n\t\t\treply = do_start_stop(common);\n\t\tbreak;\n\n\tcase SYNCHRONIZE_CACHE:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\treply = check_command(common, 10, DATA_DIR_NONE,\n\t\t\t\t      (0xf<<2) | (3<<7), 1,\n\t\t\t\t      \"SYNCHRONIZE CACHE\");\n\t\tif (reply == 0)\n\t\t\treply = do_synchronize_cache(common);\n\t\tbreak;\n\n\tcase TEST_UNIT_READY:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\treply = check_command(common, 6, DATA_DIR_NONE,\n\t\t\t\t0, 1,\n\t\t\t\t\"TEST UNIT READY\");\n\t\tbreak;\n\n\t \n\tcase VERIFY:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\treply = check_command(common, 10, DATA_DIR_NONE,\n\t\t\t\t      (1<<1) | (0xf<<2) | (3<<7), 1,\n\t\t\t\t      \"VERIFY\");\n\t\tif (reply == 0)\n\t\t\treply = do_verify(common);\n\t\tbreak;\n\n\tcase WRITE_6:\n\t\ti = common->cmnd[4];\n\t\tcommon->data_size_from_cmnd = (i == 0) ? 256 : i;\n\t\treply = check_command_size_in_blocks(common, 6,\n\t\t\t\t      DATA_DIR_FROM_HOST,\n\t\t\t\t      (7<<1) | (1<<4), 1,\n\t\t\t\t      \"WRITE(6)\");\n\t\tif (reply == 0)\n\t\t\treply = do_write(common);\n\t\tbreak;\n\n\tcase WRITE_10:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be16(&common->cmnd[7]);\n\t\treply = check_command_size_in_blocks(common, 10,\n\t\t\t\t      DATA_DIR_FROM_HOST,\n\t\t\t\t      (1<<1) | (0xf<<2) | (3<<7), 1,\n\t\t\t\t      \"WRITE(10)\");\n\t\tif (reply == 0)\n\t\t\treply = do_write(common);\n\t\tbreak;\n\n\tcase WRITE_12:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be32(&common->cmnd[6]);\n\t\treply = check_command_size_in_blocks(common, 12,\n\t\t\t\t      DATA_DIR_FROM_HOST,\n\t\t\t\t      (1<<1) | (0xf<<2) | (0xf<<6), 1,\n\t\t\t\t      \"WRITE(12)\");\n\t\tif (reply == 0)\n\t\t\treply = do_write(common);\n\t\tbreak;\n\n\tcase WRITE_16:\n\t\tcommon->data_size_from_cmnd =\n\t\t\t\tget_unaligned_be32(&common->cmnd[10]);\n\t\treply = check_command_size_in_blocks(common, 16,\n\t\t\t\t      DATA_DIR_FROM_HOST,\n\t\t\t\t      (1<<1) | (0xff<<2) | (0xf<<10), 1,\n\t\t\t\t      \"WRITE(16)\");\n\t\tif (reply == 0)\n\t\t\treply = do_write(common);\n\t\tbreak;\n\n\t \n\tcase FORMAT_UNIT:\n\tcase RELEASE:\n\tcase RESERVE:\n\tcase SEND_DIAGNOSTIC:\n\n\tdefault:\nunknown_cmnd:\n\t\tcommon->data_size_from_cmnd = 0;\n\t\tsprintf(unknown, \"Unknown x%02x\", common->cmnd[0]);\n\t\treply = check_command(common, common->cmnd_size,\n\t\t\t\t      DATA_DIR_UNKNOWN, ~0, 0, unknown);\n\t\tif (reply == 0) {\n\t\t\tcommon->curlun->sense_data = SS_INVALID_COMMAND;\n\t\t\treply = -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tup_read(&common->filesem);\n\n\tif (reply == -EINTR || signal_pending(current))\n\t\treturn -EINTR;\n\n\t \n\tif (reply == -EINVAL)\n\t\treply = 0;\t\t \n\tif (reply >= 0 && common->data_dir == DATA_DIR_TO_HOST) {\n\t\treply = min((u32)reply, common->data_size_from_cmnd);\n\t\tbh->inreq->length = reply;\n\t\tbh->state = BUF_STATE_FULL;\n\t\tcommon->residue -= reply;\n\t}\t\t\t\t \n\n\treturn 0;\n}\n\n\n \n\nstatic int received_cbw(struct fsg_dev *fsg, struct fsg_buffhd *bh)\n{\n\tstruct usb_request\t*req = bh->outreq;\n\tstruct bulk_cb_wrap\t*cbw = req->buf;\n\tstruct fsg_common\t*common = fsg->common;\n\n\t \n\tif (req->status || test_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags))\n\t\treturn -EINVAL;\n\n\t \n\tif (req->actual != US_BULK_CB_WRAP_LEN ||\n\t\t\tcbw->Signature != cpu_to_le32(\n\t\t\t\tUS_BULK_CB_SIGN)) {\n\t\tDBG(fsg, \"invalid CBW: len %u sig 0x%x\\n\",\n\t\t\t\treq->actual,\n\t\t\t\tle32_to_cpu(cbw->Signature));\n\n\t\t \n\t\twedge_bulk_in_endpoint(fsg);\n\t\tset_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cbw->Lun >= ARRAY_SIZE(common->luns) ||\n\t    cbw->Flags & ~US_BULK_FLAG_IN || cbw->Length <= 0 ||\n\t    cbw->Length > MAX_COMMAND_SIZE) {\n\t\tDBG(fsg, \"non-meaningful CBW: lun = %u, flags = 0x%x, \"\n\t\t\t\t\"cmdlen %u\\n\",\n\t\t\t\tcbw->Lun, cbw->Flags, cbw->Length);\n\n\t\t \n\t\tif (common->can_stall) {\n\t\t\tfsg_set_halt(fsg, fsg->bulk_out);\n\t\t\thalt_bulk_in_endpoint(fsg);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcommon->cmnd_size = cbw->Length;\n\tmemcpy(common->cmnd, cbw->CDB, common->cmnd_size);\n\tif (cbw->Flags & US_BULK_FLAG_IN)\n\t\tcommon->data_dir = DATA_DIR_TO_HOST;\n\telse\n\t\tcommon->data_dir = DATA_DIR_FROM_HOST;\n\tcommon->data_size = le32_to_cpu(cbw->DataTransferLength);\n\tif (common->data_size == 0)\n\t\tcommon->data_dir = DATA_DIR_NONE;\n\tcommon->lun = cbw->Lun;\n\tif (common->lun < ARRAY_SIZE(common->luns))\n\t\tcommon->curlun = common->luns[common->lun];\n\telse\n\t\tcommon->curlun = NULL;\n\tcommon->tag = cbw->Tag;\n\treturn 0;\n}\n\nstatic int get_next_command(struct fsg_common *common)\n{\n\tstruct fsg_buffhd\t*bh;\n\tint\t\t\trc = 0;\n\n\t \n\tbh = common->next_buffhd_to_fill;\n\trc = sleep_thread(common, true, bh);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tset_bulk_out_req_length(common, bh, US_BULK_CB_WRAP_LEN);\n\tif (!start_out_transfer(common, bh))\n\t\t \n\t\treturn -EIO;\n\n\t \n\n\t \n\trc = sleep_thread(common, true, bh);\n\tif (rc)\n\t\treturn rc;\n\n\trc = fsg_is_set(common) ? received_cbw(common->fsg, bh) : -EIO;\n\tbh->state = BUF_STATE_EMPTY;\n\n\treturn rc;\n}\n\n\n \n\nstatic int alloc_request(struct fsg_common *common, struct usb_ep *ep,\n\t\tstruct usb_request **preq)\n{\n\t*preq = usb_ep_alloc_request(ep, GFP_ATOMIC);\n\tif (*preq)\n\t\treturn 0;\n\tERROR(common, \"can't allocate request for %s\\n\", ep->name);\n\treturn -ENOMEM;\n}\n\n \nstatic int do_set_interface(struct fsg_common *common, struct fsg_dev *new_fsg)\n{\n\tstruct fsg_dev *fsg;\n\tint i, rc = 0;\n\n\tif (common->running)\n\t\tDBG(common, \"reset interface\\n\");\n\nreset:\n\t \n\tif (common->fsg) {\n\t\tfsg = common->fsg;\n\n\t\tfor (i = 0; i < common->fsg_num_buffers; ++i) {\n\t\t\tstruct fsg_buffhd *bh = &common->buffhds[i];\n\n\t\t\tif (bh->inreq) {\n\t\t\t\tusb_ep_free_request(fsg->bulk_in, bh->inreq);\n\t\t\t\tbh->inreq = NULL;\n\t\t\t}\n\t\t\tif (bh->outreq) {\n\t\t\t\tusb_ep_free_request(fsg->bulk_out, bh->outreq);\n\t\t\t\tbh->outreq = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (fsg->bulk_in_enabled) {\n\t\t\tusb_ep_disable(fsg->bulk_in);\n\t\t\tfsg->bulk_in_enabled = 0;\n\t\t}\n\t\tif (fsg->bulk_out_enabled) {\n\t\t\tusb_ep_disable(fsg->bulk_out);\n\t\t\tfsg->bulk_out_enabled = 0;\n\t\t}\n\n\t\tcommon->fsg = NULL;\n\t\twake_up(&common->fsg_wait);\n\t}\n\n\tcommon->running = 0;\n\tif (!new_fsg || rc)\n\t\treturn rc;\n\n\tcommon->fsg = new_fsg;\n\tfsg = common->fsg;\n\n\t \n\trc = config_ep_by_speed(common->gadget, &(fsg->function), fsg->bulk_in);\n\tif (rc)\n\t\tgoto reset;\n\trc = usb_ep_enable(fsg->bulk_in);\n\tif (rc)\n\t\tgoto reset;\n\tfsg->bulk_in->driver_data = common;\n\tfsg->bulk_in_enabled = 1;\n\n\trc = config_ep_by_speed(common->gadget, &(fsg->function),\n\t\t\t\tfsg->bulk_out);\n\tif (rc)\n\t\tgoto reset;\n\trc = usb_ep_enable(fsg->bulk_out);\n\tif (rc)\n\t\tgoto reset;\n\tfsg->bulk_out->driver_data = common;\n\tfsg->bulk_out_enabled = 1;\n\tcommon->bulk_out_maxpacket = usb_endpoint_maxp(fsg->bulk_out->desc);\n\tclear_bit(IGNORE_BULK_OUT, &fsg->atomic_bitflags);\n\n\t \n\tfor (i = 0; i < common->fsg_num_buffers; ++i) {\n\t\tstruct fsg_buffhd\t*bh = &common->buffhds[i];\n\n\t\trc = alloc_request(common, fsg->bulk_in, &bh->inreq);\n\t\tif (rc)\n\t\t\tgoto reset;\n\t\trc = alloc_request(common, fsg->bulk_out, &bh->outreq);\n\t\tif (rc)\n\t\t\tgoto reset;\n\t\tbh->inreq->buf = bh->outreq->buf = bh->buf;\n\t\tbh->inreq->context = bh->outreq->context = bh;\n\t\tbh->inreq->complete = bulk_in_complete;\n\t\tbh->outreq->complete = bulk_out_complete;\n\t}\n\n\tcommon->running = 1;\n\tfor (i = 0; i < ARRAY_SIZE(common->luns); ++i)\n\t\tif (common->luns[i])\n\t\t\tcommon->luns[i]->unit_attention_data =\n\t\t\t\tSS_RESET_OCCURRED;\n\treturn rc;\n}\n\n\n \n\nstatic int fsg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct fsg_dev *fsg = fsg_from_func(f);\n\n\t__raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE, fsg);\n\treturn USB_GADGET_DELAYED_STATUS;\n}\n\nstatic void fsg_disable(struct usb_function *f)\n{\n\tstruct fsg_dev *fsg = fsg_from_func(f);\n\n\t \n\tif (fsg->bulk_in_enabled) {\n\t\tusb_ep_disable(fsg->bulk_in);\n\t\tfsg->bulk_in_enabled = 0;\n\t}\n\tif (fsg->bulk_out_enabled) {\n\t\tusb_ep_disable(fsg->bulk_out);\n\t\tfsg->bulk_out_enabled = 0;\n\t}\n\n\t__raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE, NULL);\n}\n\n\n \n\nstatic void handle_exception(struct fsg_common *common)\n{\n\tint\t\t\ti;\n\tstruct fsg_buffhd\t*bh;\n\tenum fsg_state\t\told_state;\n\tstruct fsg_lun\t\t*curlun;\n\tunsigned int\t\texception_req_tag;\n\tstruct fsg_dev\t\t*new_fsg;\n\n\t \n\tfor (;;) {\n\t\tint sig = kernel_dequeue_signal();\n\t\tif (!sig)\n\t\t\tbreak;\n\t\tif (sig != SIGUSR1) {\n\t\t\tspin_lock_irq(&common->lock);\n\t\t\tif (common->state < FSG_STATE_EXIT)\n\t\t\t\tDBG(common, \"Main thread exiting on signal\\n\");\n\t\t\tcommon->state = FSG_STATE_EXIT;\n\t\t\tspin_unlock_irq(&common->lock);\n\t\t}\n\t}\n\n\t \n\tif (likely(common->fsg)) {\n\t\tfor (i = 0; i < common->fsg_num_buffers; ++i) {\n\t\t\tbh = &common->buffhds[i];\n\t\t\tif (bh->state == BUF_STATE_SENDING)\n\t\t\t\tusb_ep_dequeue(common->fsg->bulk_in, bh->inreq);\n\t\t\tif (bh->state == BUF_STATE_RECEIVING)\n\t\t\t\tusb_ep_dequeue(common->fsg->bulk_out,\n\t\t\t\t\t       bh->outreq);\n\n\t\t\t \n\t\t\tif (sleep_thread(common, false, bh))\n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (common->fsg->bulk_in_enabled)\n\t\t\tusb_ep_fifo_flush(common->fsg->bulk_in);\n\t\tif (common->fsg->bulk_out_enabled)\n\t\t\tusb_ep_fifo_flush(common->fsg->bulk_out);\n\t}\n\n\t \n\tspin_lock_irq(&common->lock);\n\n\tfor (i = 0; i < common->fsg_num_buffers; ++i) {\n\t\tbh = &common->buffhds[i];\n\t\tbh->state = BUF_STATE_EMPTY;\n\t}\n\tcommon->next_buffhd_to_fill = &common->buffhds[0];\n\tcommon->next_buffhd_to_drain = &common->buffhds[0];\n\texception_req_tag = common->exception_req_tag;\n\tnew_fsg = common->exception_arg;\n\told_state = common->state;\n\tcommon->state = FSG_STATE_NORMAL;\n\n\tif (old_state != FSG_STATE_ABORT_BULK_OUT) {\n\t\tfor (i = 0; i < ARRAY_SIZE(common->luns); ++i) {\n\t\t\tcurlun = common->luns[i];\n\t\t\tif (!curlun)\n\t\t\t\tcontinue;\n\t\t\tcurlun->prevent_medium_removal = 0;\n\t\t\tcurlun->sense_data = SS_NO_SENSE;\n\t\t\tcurlun->unit_attention_data = SS_NO_SENSE;\n\t\t\tcurlun->sense_data_info = 0;\n\t\t\tcurlun->info_valid = 0;\n\t\t}\n\t}\n\tspin_unlock_irq(&common->lock);\n\n\t \n\tswitch (old_state) {\n\tcase FSG_STATE_NORMAL:\n\t\tbreak;\n\n\tcase FSG_STATE_ABORT_BULK_OUT:\n\t\tsend_status(common);\n\t\tbreak;\n\n\tcase FSG_STATE_PROTOCOL_RESET:\n\t\t \n\t\tif (!fsg_is_set(common))\n\t\t\tbreak;\n\t\tif (test_and_clear_bit(IGNORE_BULK_OUT,\n\t\t\t\t       &common->fsg->atomic_bitflags))\n\t\t\tusb_ep_clear_halt(common->fsg->bulk_in);\n\n\t\tif (common->ep0_req_tag == exception_req_tag)\n\t\t\tep0_queue(common);\t \n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tbreak;\n\n\tcase FSG_STATE_CONFIG_CHANGE:\n\t\tdo_set_interface(common, new_fsg);\n\t\tif (new_fsg)\n\t\t\tusb_composite_setup_continue(common->cdev);\n\t\tbreak;\n\n\tcase FSG_STATE_EXIT:\n\t\tdo_set_interface(common, NULL);\t\t \n\t\tspin_lock_irq(&common->lock);\n\t\tcommon->state = FSG_STATE_TERMINATED;\t \n\t\tspin_unlock_irq(&common->lock);\n\t\tbreak;\n\n\tcase FSG_STATE_TERMINATED:\n\t\tbreak;\n\t}\n}\n\n\n \n\nstatic int fsg_main_thread(void *common_)\n{\n\tstruct fsg_common\t*common = common_;\n\tint\t\t\ti;\n\n\t \n\tallow_signal(SIGINT);\n\tallow_signal(SIGTERM);\n\tallow_signal(SIGKILL);\n\tallow_signal(SIGUSR1);\n\n\t \n\tset_freezable();\n\n\t \n\twhile (common->state != FSG_STATE_TERMINATED) {\n\t\tif (exception_in_progress(common) || signal_pending(current)) {\n\t\t\thandle_exception(common);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!common->running) {\n\t\t\tsleep_thread(common, true, NULL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (get_next_command(common) || exception_in_progress(common))\n\t\t\tcontinue;\n\t\tif (do_scsi_command(common) || exception_in_progress(common))\n\t\t\tcontinue;\n\t\tif (finish_reply(common) || exception_in_progress(common))\n\t\t\tcontinue;\n\t\tsend_status(common);\n\t}\n\n\tspin_lock_irq(&common->lock);\n\tcommon->thread_task = NULL;\n\tspin_unlock_irq(&common->lock);\n\n\t \n\n\tdown_write(&common->filesem);\n\tfor (i = 0; i < ARRAY_SIZE(common->luns); i++) {\n\t\tstruct fsg_lun *curlun = common->luns[i];\n\n\t\tif (curlun && fsg_lun_is_open(curlun))\n\t\t\tfsg_lun_close(curlun);\n\t}\n\tup_write(&common->filesem);\n\n\t \n\tkthread_complete_and_exit(&common->thread_notifier, 0);\n}\n\n\n \n\nstatic ssize_t ro_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\n\treturn fsg_show_ro(curlun, buf);\n}\n\nstatic ssize_t nofua_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\n\treturn fsg_show_nofua(curlun, buf);\n}\n\nstatic ssize_t file_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\tstruct rw_semaphore\t*filesem = dev_get_drvdata(dev);\n\n\treturn fsg_show_file(curlun, filesem, buf);\n}\n\nstatic ssize_t ro_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t count)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\tstruct rw_semaphore\t*filesem = dev_get_drvdata(dev);\n\n\treturn fsg_store_ro(curlun, filesem, buf, count);\n}\n\nstatic ssize_t nofua_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\n\treturn fsg_store_nofua(curlun, buf, count);\n}\n\nstatic ssize_t file_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\tstruct rw_semaphore\t*filesem = dev_get_drvdata(dev);\n\n\treturn fsg_store_file(curlun, filesem, buf, count);\n}\n\nstatic ssize_t forced_eject_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct fsg_lun\t\t*curlun = fsg_lun_from_dev(dev);\n\tstruct rw_semaphore\t*filesem = dev_get_drvdata(dev);\n\n\treturn fsg_store_forced_eject(curlun, filesem, buf, count);\n}\n\nstatic DEVICE_ATTR_RW(nofua);\nstatic DEVICE_ATTR_WO(forced_eject);\n\n \nstatic DEVICE_ATTR_RW(ro);\nstatic DEVICE_ATTR_RW(file);\n\n \n\nstatic void fsg_lun_release(struct device *dev)\n{\n\t \n}\n\nstatic struct fsg_common *fsg_common_setup(struct fsg_common *common)\n{\n\tif (!common) {\n\t\tcommon = kzalloc(sizeof(*common), GFP_KERNEL);\n\t\tif (!common)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tcommon->free_storage_on_release = 1;\n\t} else {\n\t\tcommon->free_storage_on_release = 0;\n\t}\n\tinit_rwsem(&common->filesem);\n\tspin_lock_init(&common->lock);\n\tinit_completion(&common->thread_notifier);\n\tinit_waitqueue_head(&common->io_wait);\n\tinit_waitqueue_head(&common->fsg_wait);\n\tcommon->state = FSG_STATE_TERMINATED;\n\tmemset(common->luns, 0, sizeof(common->luns));\n\n\treturn common;\n}\n\nvoid fsg_common_set_sysfs(struct fsg_common *common, bool sysfs)\n{\n\tcommon->sysfs = sysfs;\n}\nEXPORT_SYMBOL_GPL(fsg_common_set_sysfs);\n\nstatic void _fsg_common_free_buffers(struct fsg_buffhd *buffhds, unsigned n)\n{\n\tif (buffhds) {\n\t\tstruct fsg_buffhd *bh = buffhds;\n\t\twhile (n--) {\n\t\t\tkfree(bh->buf);\n\t\t\t++bh;\n\t\t}\n\t\tkfree(buffhds);\n\t}\n}\n\nint fsg_common_set_num_buffers(struct fsg_common *common, unsigned int n)\n{\n\tstruct fsg_buffhd *bh, *buffhds;\n\tint i;\n\n\tbuffhds = kcalloc(n, sizeof(*buffhds), GFP_KERNEL);\n\tif (!buffhds)\n\t\treturn -ENOMEM;\n\n\t \n\tbh = buffhds;\n\ti = n;\n\tgoto buffhds_first_it;\n\tdo {\n\t\tbh->next = bh + 1;\n\t\t++bh;\nbuffhds_first_it:\n\t\tbh->buf = kmalloc(FSG_BUFLEN, GFP_KERNEL);\n\t\tif (unlikely(!bh->buf))\n\t\t\tgoto error_release;\n\t} while (--i);\n\tbh->next = buffhds;\n\n\t_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\n\tcommon->fsg_num_buffers = n;\n\tcommon->buffhds = buffhds;\n\n\treturn 0;\n\nerror_release:\n\t \n\t_fsg_common_free_buffers(buffhds, n);\n\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(fsg_common_set_num_buffers);\n\nvoid fsg_common_remove_lun(struct fsg_lun *lun)\n{\n\tif (device_is_registered(&lun->dev))\n\t\tdevice_unregister(&lun->dev);\n\tfsg_lun_close(lun);\n\tkfree(lun);\n}\nEXPORT_SYMBOL_GPL(fsg_common_remove_lun);\n\nstatic void _fsg_common_remove_luns(struct fsg_common *common, int n)\n{\n\tint i;\n\n\tfor (i = 0; i < n; ++i)\n\t\tif (common->luns[i]) {\n\t\t\tfsg_common_remove_lun(common->luns[i]);\n\t\t\tcommon->luns[i] = NULL;\n\t\t}\n}\n\nvoid fsg_common_remove_luns(struct fsg_common *common)\n{\n\t_fsg_common_remove_luns(common, ARRAY_SIZE(common->luns));\n}\nEXPORT_SYMBOL_GPL(fsg_common_remove_luns);\n\nvoid fsg_common_free_buffers(struct fsg_common *common)\n{\n\t_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\n\tcommon->buffhds = NULL;\n}\nEXPORT_SYMBOL_GPL(fsg_common_free_buffers);\n\nint fsg_common_set_cdev(struct fsg_common *common,\n\t\t\t struct usb_composite_dev *cdev, bool can_stall)\n{\n\tstruct usb_string *us;\n\n\tcommon->gadget = cdev->gadget;\n\tcommon->ep0 = cdev->gadget->ep0;\n\tcommon->ep0req = cdev->req;\n\tcommon->cdev = cdev;\n\n\tus = usb_gstrings_attach(cdev, fsg_strings_array,\n\t\t\t\t ARRAY_SIZE(fsg_strings));\n\tif (IS_ERR(us))\n\t\treturn PTR_ERR(us);\n\n\tfsg_intf_desc.iInterface = us[FSG_STRING_INTERFACE].id;\n\n\t \n\tcommon->can_stall = can_stall &&\n\t\t\tgadget_is_stall_supported(common->gadget);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(fsg_common_set_cdev);\n\nstatic struct attribute *fsg_lun_dev_attrs[] = {\n\t&dev_attr_ro.attr,\n\t&dev_attr_file.attr,\n\t&dev_attr_nofua.attr,\n\t&dev_attr_forced_eject.attr,\n\tNULL\n};\n\nstatic umode_t fsg_lun_dev_is_visible(struct kobject *kobj,\n\t\t\t\t      struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct fsg_lun *lun = fsg_lun_from_dev(dev);\n\n\tif (attr == &dev_attr_ro.attr)\n\t\treturn lun->cdrom ? S_IRUGO : (S_IWUSR | S_IRUGO);\n\tif (attr == &dev_attr_file.attr)\n\t\treturn lun->removable ? (S_IWUSR | S_IRUGO) : S_IRUGO;\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group fsg_lun_dev_group = {\n\t.attrs = fsg_lun_dev_attrs,\n\t.is_visible = fsg_lun_dev_is_visible,\n};\n\nstatic const struct attribute_group *fsg_lun_dev_groups[] = {\n\t&fsg_lun_dev_group,\n\tNULL\n};\n\nint fsg_common_create_lun(struct fsg_common *common, struct fsg_lun_config *cfg,\n\t\t\t  unsigned int id, const char *name,\n\t\t\t  const char **name_pfx)\n{\n\tstruct fsg_lun *lun;\n\tchar *pathbuf = NULL, *p = \"(no medium)\";\n\tint rc = -ENOMEM;\n\n\tif (id >= ARRAY_SIZE(common->luns))\n\t\treturn -ENODEV;\n\n\tif (common->luns[id])\n\t\treturn -EBUSY;\n\n\tif (!cfg->filename && !cfg->removable) {\n\t\tpr_err(\"no file given for LUN%d\\n\", id);\n\t\treturn -EINVAL;\n\t}\n\n\tlun = kzalloc(sizeof(*lun), GFP_KERNEL);\n\tif (!lun)\n\t\treturn -ENOMEM;\n\n\tlun->name_pfx = name_pfx;\n\n\tlun->cdrom = !!cfg->cdrom;\n\tlun->ro = cfg->cdrom || cfg->ro;\n\tlun->initially_ro = lun->ro;\n\tlun->removable = !!cfg->removable;\n\n\tif (!common->sysfs) {\n\t\t \n\t\tlun->name = name;\n\t} else {\n\t\tlun->dev.release = fsg_lun_release;\n\t\tlun->dev.parent = &common->gadget->dev;\n\t\tlun->dev.groups = fsg_lun_dev_groups;\n\t\tdev_set_drvdata(&lun->dev, &common->filesem);\n\t\tdev_set_name(&lun->dev, \"%s\", name);\n\t\tlun->name = dev_name(&lun->dev);\n\n\t\trc = device_register(&lun->dev);\n\t\tif (rc) {\n\t\t\tpr_info(\"failed to register LUN%d: %d\\n\", id, rc);\n\t\t\tput_device(&lun->dev);\n\t\t\tgoto error_sysfs;\n\t\t}\n\t}\n\n\tcommon->luns[id] = lun;\n\n\tif (cfg->filename) {\n\t\trc = fsg_lun_open(lun, cfg->filename);\n\t\tif (rc)\n\t\t\tgoto error_lun;\n\n\t\tp = \"(error)\";\n\t\tpathbuf = kmalloc(PATH_MAX, GFP_KERNEL);\n\t\tif (pathbuf) {\n\t\t\tp = file_path(lun->filp, pathbuf, PATH_MAX);\n\t\t\tif (IS_ERR(p))\n\t\t\t\tp = \"(error)\";\n\t\t}\n\t}\n\tpr_info(\"LUN: %s%s%sfile: %s\\n\",\n\t      lun->removable ? \"removable \" : \"\",\n\t      lun->ro ? \"read only \" : \"\",\n\t      lun->cdrom ? \"CD-ROM \" : \"\",\n\t      p);\n\tkfree(pathbuf);\n\n\treturn 0;\n\nerror_lun:\n\tif (device_is_registered(&lun->dev))\n\t\tdevice_unregister(&lun->dev);\n\tcommon->luns[id] = NULL;\nerror_sysfs:\n\tkfree(lun);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsg_common_create_lun);\n\nint fsg_common_create_luns(struct fsg_common *common, struct fsg_config *cfg)\n{\n\tchar buf[8];  \n\tint i, rc;\n\n\tfsg_common_remove_luns(common);\n\n\tfor (i = 0; i < cfg->nluns; ++i) {\n\t\tsnprintf(buf, sizeof(buf), \"lun%d\", i);\n\t\trc = fsg_common_create_lun(common, &cfg->luns[i], i, buf, NULL);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\tpr_info(\"Number of LUNs=%d\\n\", cfg->nluns);\n\n\treturn 0;\n\nfail:\n\t_fsg_common_remove_luns(common, i);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(fsg_common_create_luns);\n\nvoid fsg_common_set_inquiry_string(struct fsg_common *common, const char *vn,\n\t\t\t\t   const char *pn)\n{\n\tint i;\n\n\t \n\ti = get_default_bcdDevice();\n\tsnprintf(common->inquiry_string, sizeof(common->inquiry_string),\n\t\t \"%-8s%-16s%04x\", vn ?: \"Linux\",\n\t\t  \n\t\t pn ?: ((*common->luns)->cdrom\n\t\t     ? \"File-CD Gadget\"\n\t\t     : \"File-Stor Gadget\"),\n\t\t i);\n}\nEXPORT_SYMBOL_GPL(fsg_common_set_inquiry_string);\n\nstatic void fsg_common_release(struct fsg_common *common)\n{\n\tint i;\n\n\t \n\tif (common->state != FSG_STATE_TERMINATED) {\n\t\traise_exception(common, FSG_STATE_EXIT);\n\t\twait_for_completion(&common->thread_notifier);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(common->luns); ++i) {\n\t\tstruct fsg_lun *lun = common->luns[i];\n\t\tif (!lun)\n\t\t\tcontinue;\n\t\tfsg_lun_close(lun);\n\t\tif (device_is_registered(&lun->dev))\n\t\t\tdevice_unregister(&lun->dev);\n\t\tkfree(lun);\n\t}\n\n\t_fsg_common_free_buffers(common->buffhds, common->fsg_num_buffers);\n\tif (common->free_storage_on_release)\n\t\tkfree(common);\n}\n\n\n \n\nstatic int fsg_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct fsg_dev\t\t*fsg = fsg_from_func(f);\n\tstruct fsg_common\t*common = fsg->common;\n\tstruct usb_gadget\t*gadget = c->cdev->gadget;\n\tint\t\t\ti;\n\tstruct usb_ep\t\t*ep;\n\tunsigned\t\tmax_burst;\n\tint\t\t\tret;\n\tstruct fsg_opts\t\t*opts;\n\n\t \n\tret = _fsg_common_get_max_lun(common);\n\tif (ret < 0) {\n\t\tpr_err(\"There should be at least one LUN.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\topts = fsg_opts_from_func_inst(f->fi);\n\tif (!opts->no_configfs) {\n\t\tret = fsg_common_set_cdev(fsg->common, c->cdev,\n\t\t\t\t\t  fsg->common->can_stall);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfsg_common_set_inquiry_string(fsg->common, NULL, NULL);\n\t}\n\n\tif (!common->thread_task) {\n\t\tcommon->state = FSG_STATE_NORMAL;\n\t\tcommon->thread_task =\n\t\t\tkthread_create(fsg_main_thread, common, \"file-storage\");\n\t\tif (IS_ERR(common->thread_task)) {\n\t\t\tret = PTR_ERR(common->thread_task);\n\t\t\tcommon->thread_task = NULL;\n\t\t\tcommon->state = FSG_STATE_TERMINATED;\n\t\t\treturn ret;\n\t\t}\n\t\tDBG(common, \"I/O thread pid: %d\\n\",\n\t\t    task_pid_nr(common->thread_task));\n\t\twake_up_process(common->thread_task);\n\t}\n\n\tfsg->gadget = gadget;\n\n\t \n\ti = usb_interface_id(c, f);\n\tif (i < 0)\n\t\tgoto fail;\n\tfsg_intf_desc.bInterfaceNumber = i;\n\tfsg->interface_number = i;\n\n\t \n\tep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_in_desc);\n\tif (!ep)\n\t\tgoto autoconf_fail;\n\tfsg->bulk_in = ep;\n\n\tep = usb_ep_autoconfig(gadget, &fsg_fs_bulk_out_desc);\n\tif (!ep)\n\t\tgoto autoconf_fail;\n\tfsg->bulk_out = ep;\n\n\t \n\tfsg_hs_bulk_in_desc.bEndpointAddress =\n\t\tfsg_fs_bulk_in_desc.bEndpointAddress;\n\tfsg_hs_bulk_out_desc.bEndpointAddress =\n\t\tfsg_fs_bulk_out_desc.bEndpointAddress;\n\n\t \n\tmax_burst = min_t(unsigned, FSG_BUFLEN / 1024, 15);\n\n\tfsg_ss_bulk_in_desc.bEndpointAddress =\n\t\tfsg_fs_bulk_in_desc.bEndpointAddress;\n\tfsg_ss_bulk_in_comp_desc.bMaxBurst = max_burst;\n\n\tfsg_ss_bulk_out_desc.bEndpointAddress =\n\t\tfsg_fs_bulk_out_desc.bEndpointAddress;\n\tfsg_ss_bulk_out_comp_desc.bMaxBurst = max_burst;\n\n\tret = usb_assign_descriptors(f, fsg_fs_function, fsg_hs_function,\n\t\t\tfsg_ss_function, fsg_ss_function);\n\tif (ret)\n\t\tgoto autoconf_fail;\n\n\treturn 0;\n\nautoconf_fail:\n\tERROR(fsg, \"unable to autoconfigure all endpoints\\n\");\n\ti = -ENOTSUPP;\nfail:\n\t \n\tif (fsg->common->state != FSG_STATE_TERMINATED) {\n\t\traise_exception(fsg->common, FSG_STATE_EXIT);\n\t\twait_for_completion(&fsg->common->thread_notifier);\n\t}\n\treturn i;\n}\n\n \n\nstatic void fsg_unbind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct fsg_dev\t\t*fsg = fsg_from_func(f);\n\tstruct fsg_common\t*common = fsg->common;\n\n\tDBG(fsg, \"unbind\\n\");\n\tif (fsg->common->fsg == fsg) {\n\t\t__raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE, NULL);\n\t\t \n\t\twait_event(common->fsg_wait, common->fsg != fsg);\n\t}\n\n\tusb_free_all_descriptors(&fsg->function);\n}\n\nstatic inline struct fsg_lun_opts *to_fsg_lun_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct fsg_lun_opts, group);\n}\n\nstatic inline struct fsg_opts *to_fsg_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct fsg_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void fsg_lun_attr_release(struct config_item *item)\n{\n\tstruct fsg_lun_opts *lun_opts;\n\n\tlun_opts = to_fsg_lun_opts(item);\n\tkfree(lun_opts);\n}\n\nstatic struct configfs_item_operations fsg_lun_item_ops = {\n\t.release\t\t= fsg_lun_attr_release,\n};\n\nstatic ssize_t fsg_lun_opts_file_show(struct config_item *item, char *page)\n{\n\tstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\n\tstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\n\n\treturn fsg_show_file(opts->lun, &fsg_opts->common->filesem, page);\n}\n\nstatic ssize_t fsg_lun_opts_file_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\n\tstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\n\n\treturn fsg_store_file(opts->lun, &fsg_opts->common->filesem, page, len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, file);\n\nstatic ssize_t fsg_lun_opts_ro_show(struct config_item *item, char *page)\n{\n\treturn fsg_show_ro(to_fsg_lun_opts(item)->lun, page);\n}\n\nstatic ssize_t fsg_lun_opts_ro_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\n\tstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\n\n\treturn fsg_store_ro(opts->lun, &fsg_opts->common->filesem, page, len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, ro);\n\nstatic ssize_t fsg_lun_opts_removable_show(struct config_item *item,\n\t\t\t\t\t   char *page)\n{\n\treturn fsg_show_removable(to_fsg_lun_opts(item)->lun, page);\n}\n\nstatic ssize_t fsg_lun_opts_removable_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\treturn fsg_store_removable(to_fsg_lun_opts(item)->lun, page, len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, removable);\n\nstatic ssize_t fsg_lun_opts_cdrom_show(struct config_item *item, char *page)\n{\n\treturn fsg_show_cdrom(to_fsg_lun_opts(item)->lun, page);\n}\n\nstatic ssize_t fsg_lun_opts_cdrom_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\tstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\n\tstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\n\n\treturn fsg_store_cdrom(opts->lun, &fsg_opts->common->filesem, page,\n\t\t\t       len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, cdrom);\n\nstatic ssize_t fsg_lun_opts_nofua_show(struct config_item *item, char *page)\n{\n\treturn fsg_show_nofua(to_fsg_lun_opts(item)->lun, page);\n}\n\nstatic ssize_t fsg_lun_opts_nofua_store(struct config_item *item,\n\t\t\t\t       const char *page, size_t len)\n{\n\treturn fsg_store_nofua(to_fsg_lun_opts(item)->lun, page, len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, nofua);\n\nstatic ssize_t fsg_lun_opts_inquiry_string_show(struct config_item *item,\n\t\t\t\t\t\tchar *page)\n{\n\treturn fsg_show_inquiry_string(to_fsg_lun_opts(item)->lun, page);\n}\n\nstatic ssize_t fsg_lun_opts_inquiry_string_store(struct config_item *item,\n\t\t\t\t\t\t const char *page, size_t len)\n{\n\treturn fsg_store_inquiry_string(to_fsg_lun_opts(item)->lun, page, len);\n}\n\nCONFIGFS_ATTR(fsg_lun_opts_, inquiry_string);\n\nstatic ssize_t fsg_lun_opts_forced_eject_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t len)\n{\n\tstruct fsg_lun_opts *opts = to_fsg_lun_opts(item);\n\tstruct fsg_opts *fsg_opts = to_fsg_opts(opts->group.cg_item.ci_parent);\n\n\treturn fsg_store_forced_eject(opts->lun, &fsg_opts->common->filesem,\n\t\t\t\t      page, len);\n}\n\nCONFIGFS_ATTR_WO(fsg_lun_opts_, forced_eject);\n\nstatic struct configfs_attribute *fsg_lun_attrs[] = {\n\t&fsg_lun_opts_attr_file,\n\t&fsg_lun_opts_attr_ro,\n\t&fsg_lun_opts_attr_removable,\n\t&fsg_lun_opts_attr_cdrom,\n\t&fsg_lun_opts_attr_nofua,\n\t&fsg_lun_opts_attr_inquiry_string,\n\t&fsg_lun_opts_attr_forced_eject,\n\tNULL,\n};\n\nstatic const struct config_item_type fsg_lun_type = {\n\t.ct_item_ops\t= &fsg_lun_item_ops,\n\t.ct_attrs\t= fsg_lun_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *fsg_lun_make(struct config_group *group,\n\t\t\t\t\t const char *name)\n{\n\tstruct fsg_lun_opts *opts;\n\tstruct fsg_opts *fsg_opts;\n\tstruct fsg_lun_config config;\n\tchar *num_str;\n\tu8 num;\n\tint ret;\n\n\tnum_str = strchr(name, '.');\n\tif (!num_str) {\n\t\tpr_err(\"Unable to locate . in LUN.NUMBER\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tnum_str++;\n\n\tret = kstrtou8(num_str, 0, &num);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfsg_opts = to_fsg_opts(&group->cg_item);\n\tif (num >= FSG_MAX_LUNS)\n\t\treturn ERR_PTR(-ERANGE);\n\tnum = array_index_nospec(num, FSG_MAX_LUNS);\n\n\tmutex_lock(&fsg_opts->lock);\n\tif (fsg_opts->refcnt || fsg_opts->common->luns[num]) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.removable = true;\n\n\tret = fsg_common_create_lun(fsg_opts->common, &config, num, name,\n\t\t\t\t    (const char **)&group->cg_item.ci_name);\n\tif (ret) {\n\t\tkfree(opts);\n\t\tgoto out;\n\t}\n\topts->lun = fsg_opts->common->luns[num];\n\topts->lun_id = num;\n\tmutex_unlock(&fsg_opts->lock);\n\n\tconfig_group_init_type_name(&opts->group, name, &fsg_lun_type);\n\n\treturn &opts->group;\nout:\n\tmutex_unlock(&fsg_opts->lock);\n\treturn ERR_PTR(ret);\n}\n\nstatic void fsg_lun_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct fsg_lun_opts *lun_opts;\n\tstruct fsg_opts *fsg_opts;\n\n\tlun_opts = to_fsg_lun_opts(item);\n\tfsg_opts = to_fsg_opts(&group->cg_item);\n\n\tmutex_lock(&fsg_opts->lock);\n\tif (fsg_opts->refcnt) {\n\t\tstruct config_item *gadget;\n\n\t\tgadget = group->cg_item.ci_parent->ci_parent;\n\t\tunregister_gadget_item(gadget);\n\t}\n\n\tfsg_common_remove_lun(lun_opts->lun);\n\tfsg_opts->common->luns[lun_opts->lun_id] = NULL;\n\tlun_opts->lun_id = 0;\n\tmutex_unlock(&fsg_opts->lock);\n\n\tconfig_item_put(item);\n}\n\nstatic void fsg_attr_release(struct config_item *item)\n{\n\tstruct fsg_opts *opts = to_fsg_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations fsg_item_ops = {\n\t.release\t\t= fsg_attr_release,\n};\n\nstatic ssize_t fsg_opts_stall_show(struct config_item *item, char *page)\n{\n\tstruct fsg_opts *opts = to_fsg_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%d\", opts->common->can_stall);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t fsg_opts_stall_store(struct config_item *item, const char *page,\n\t\t\t\t    size_t len)\n{\n\tstruct fsg_opts *opts = to_fsg_opts(item);\n\tint ret;\n\tbool stall;\n\n\tmutex_lock(&opts->lock);\n\n\tif (opts->refcnt) {\n\t\tmutex_unlock(&opts->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tret = kstrtobool(page, &stall);\n\tif (!ret) {\n\t\topts->common->can_stall = stall;\n\t\tret = len;\n\t}\n\n\tmutex_unlock(&opts->lock);\n\n\treturn ret;\n}\n\nCONFIGFS_ATTR(fsg_opts_, stall);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\nstatic ssize_t fsg_opts_num_buffers_show(struct config_item *item, char *page)\n{\n\tstruct fsg_opts *opts = to_fsg_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%d\", opts->common->fsg_num_buffers);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t fsg_opts_num_buffers_store(struct config_item *item,\n\t\t\t\t\t  const char *page, size_t len)\n{\n\tstruct fsg_opts *opts = to_fsg_opts(item);\n\tint ret;\n\tu8 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\tret = kstrtou8(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\tret = fsg_common_set_num_buffers(opts->common, num);\n\tif (ret)\n\t\tgoto end;\n\tret = len;\n\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(fsg_opts_, num_buffers);\n#endif\n\nstatic struct configfs_attribute *fsg_attrs[] = {\n\t&fsg_opts_attr_stall,\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\t&fsg_opts_attr_num_buffers,\n#endif\n\tNULL,\n};\n\nstatic struct configfs_group_operations fsg_group_ops = {\n\t.make_group\t= fsg_lun_make,\n\t.drop_item\t= fsg_lun_drop,\n};\n\nstatic const struct config_item_type fsg_func_type = {\n\t.ct_item_ops\t= &fsg_item_ops,\n\t.ct_group_ops\t= &fsg_group_ops,\n\t.ct_attrs\t= fsg_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void fsg_free_inst(struct usb_function_instance *fi)\n{\n\tstruct fsg_opts *opts;\n\n\topts = fsg_opts_from_func_inst(fi);\n\tfsg_common_release(opts->common);\n\tkfree(opts);\n}\n\nstatic struct usb_function_instance *fsg_alloc_inst(void)\n{\n\tstruct fsg_opts *opts;\n\tstruct fsg_lun_config config;\n\tint rc;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&opts->lock);\n\topts->func_inst.free_func_inst = fsg_free_inst;\n\topts->common = fsg_common_setup(opts->common);\n\tif (IS_ERR(opts->common)) {\n\t\trc = PTR_ERR(opts->common);\n\t\tgoto release_opts;\n\t}\n\n\trc = fsg_common_set_num_buffers(opts->common,\n\t\t\t\t\tCONFIG_USB_GADGET_STORAGE_NUM_BUFFERS);\n\tif (rc)\n\t\tgoto release_common;\n\n\tpr_info(FSG_DRIVER_DESC \", version: \" FSG_DRIVER_VERSION \"\\n\");\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.removable = true;\n\trc = fsg_common_create_lun(opts->common, &config, 0, \"lun.0\",\n\t\t\t(const char **)&opts->func_inst.group.cg_item.ci_name);\n\tif (rc)\n\t\tgoto release_buffers;\n\n\topts->lun0.lun = opts->common->luns[0];\n\topts->lun0.lun_id = 0;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\", &fsg_func_type);\n\n\tconfig_group_init_type_name(&opts->lun0.group, \"lun.0\", &fsg_lun_type);\n\tconfigfs_add_default_group(&opts->lun0.group, &opts->func_inst.group);\n\n\treturn &opts->func_inst;\n\nrelease_buffers:\n\tfsg_common_free_buffers(opts->common);\nrelease_common:\n\tkfree(opts->common);\nrelease_opts:\n\tkfree(opts);\n\treturn ERR_PTR(rc);\n}\n\nstatic void fsg_free(struct usb_function *f)\n{\n\tstruct fsg_dev *fsg;\n\tstruct fsg_opts *opts;\n\n\tfsg = container_of(f, struct fsg_dev, function);\n\topts = container_of(f->fi, struct fsg_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n\n\tkfree(fsg);\n}\n\nstatic struct usb_function *fsg_alloc(struct usb_function_instance *fi)\n{\n\tstruct fsg_opts *opts = fsg_opts_from_func_inst(fi);\n\tstruct fsg_common *common = opts->common;\n\tstruct fsg_dev *fsg;\n\n\tfsg = kzalloc(sizeof(*fsg), GFP_KERNEL);\n\tif (unlikely(!fsg))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_lock(&opts->lock);\n\topts->refcnt++;\n\tmutex_unlock(&opts->lock);\n\n\tfsg->function.name\t= FSG_DRIVER_DESC;\n\tfsg->function.bind\t= fsg_bind;\n\tfsg->function.unbind\t= fsg_unbind;\n\tfsg->function.setup\t= fsg_setup;\n\tfsg->function.set_alt\t= fsg_set_alt;\n\tfsg->function.disable\t= fsg_disable;\n\tfsg->function.free_func\t= fsg_free;\n\n\tfsg->common               = common;\n\n\treturn &fsg->function;\n}\n\nDECLARE_USB_FUNCTION_INIT(mass_storage, fsg_alloc_inst, fsg_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Nazarewicz\");\n\n \n\n\nvoid fsg_config_from_params(struct fsg_config *cfg,\n\t\t       const struct fsg_module_parameters *params,\n\t\t       unsigned int fsg_num_buffers)\n{\n\tstruct fsg_lun_config *lun;\n\tunsigned i;\n\n\t \n\tcfg->nluns =\n\t\tmin(params->luns ?: (params->file_count ?: 1u),\n\t\t    (unsigned)FSG_MAX_LUNS);\n\tfor (i = 0, lun = cfg->luns; i < cfg->nluns; ++i, ++lun) {\n\t\tlun->ro = !!params->ro[i];\n\t\tlun->cdrom = !!params->cdrom[i];\n\t\tlun->removable = !!params->removable[i];\n\t\tlun->filename =\n\t\t\tparams->file_count > i && params->file[i][0]\n\t\t\t? params->file[i]\n\t\t\t: NULL;\n\t}\n\n\t \n\tcfg->vendor_name = NULL;\n\tcfg->product_name = NULL;\n\n\tcfg->ops = NULL;\n\tcfg->private_data = NULL;\n\n\t \n\tcfg->can_stall = params->stall;\n\tcfg->fsg_num_buffers = fsg_num_buffers;\n}\nEXPORT_SYMBOL_GPL(fsg_config_from_params);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}