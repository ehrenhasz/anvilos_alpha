{
  "module_name": "f_loopback.c",
  "hash_id": "b97c72c3426db8873d104a88478df36cc92c9d13da5a23738fd9a2d55834c325",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/function/f_loopback.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/usb/composite.h>\n\n#include \"g_zero.h\"\n#include \"u_f.h\"\n\n \nstruct f_loopback {\n\tstruct usb_function\tfunction;\n\n\tstruct usb_ep\t\t*in_ep;\n\tstruct usb_ep\t\t*out_ep;\n\n\tunsigned                qlen;\n\tunsigned                buflen;\n};\n\nstatic inline struct f_loopback *func_to_loop(struct usb_function *f)\n{\n\treturn container_of(f, struct f_loopback, function);\n}\n\n \n\nstatic struct usb_interface_descriptor loopback_intf = {\n\t.bLength =\t\tsizeof(loopback_intf),\n\t.bDescriptorType =\tUSB_DT_INTERFACE,\n\n\t.bNumEndpoints =\t2,\n\t.bInterfaceClass =\tUSB_CLASS_VENDOR_SPEC,\n\t \n};\n\n \n\nstatic struct usb_endpoint_descriptor fs_loop_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_IN,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_endpoint_descriptor fs_loop_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\tUSB_DIR_OUT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n};\n\nstatic struct usb_descriptor_header *fs_loopback_descs[] = {\n\t(struct usb_descriptor_header *) &loopback_intf,\n\t(struct usb_descriptor_header *) &fs_loop_sink_desc,\n\t(struct usb_descriptor_header *) &fs_loop_source_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor hs_loop_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_endpoint_descriptor hs_loop_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(512),\n};\n\nstatic struct usb_descriptor_header *hs_loopback_descs[] = {\n\t(struct usb_descriptor_header *) &loopback_intf,\n\t(struct usb_descriptor_header *) &hs_loop_source_desc,\n\t(struct usb_descriptor_header *) &hs_loop_sink_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_endpoint_descriptor ss_loop_source_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_loop_source_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\t0,\n};\n\nstatic struct usb_endpoint_descriptor ss_loop_sink_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize =\tcpu_to_le16(1024),\n};\n\nstatic struct usb_ss_ep_comp_descriptor ss_loop_sink_comp_desc = {\n\t.bLength =\t\tUSB_DT_SS_EP_COMP_SIZE,\n\t.bDescriptorType =\tUSB_DT_SS_ENDPOINT_COMP,\n\t.bMaxBurst =\t\t0,\n\t.bmAttributes =\t\t0,\n\t.wBytesPerInterval =\t0,\n};\n\nstatic struct usb_descriptor_header *ss_loopback_descs[] = {\n\t(struct usb_descriptor_header *) &loopback_intf,\n\t(struct usb_descriptor_header *) &ss_loop_source_desc,\n\t(struct usb_descriptor_header *) &ss_loop_source_comp_desc,\n\t(struct usb_descriptor_header *) &ss_loop_sink_desc,\n\t(struct usb_descriptor_header *) &ss_loop_sink_comp_desc,\n\tNULL,\n};\n\n \n\nstatic struct usb_string strings_loopback[] = {\n\t[0].s = \"loop input to output\",\n\t{  }\t\t\t \n};\n\nstatic struct usb_gadget_strings stringtab_loop = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_loopback,\n};\n\nstatic struct usb_gadget_strings *loopback_strings[] = {\n\t&stringtab_loop,\n\tNULL,\n};\n\n \n\nstatic int loopback_bind(struct usb_configuration *c, struct usb_function *f)\n{\n\tstruct usb_composite_dev *cdev = c->cdev;\n\tstruct f_loopback\t*loop = func_to_loop(f);\n\tint\t\t\tid;\n\tint ret;\n\n\t \n\tid = usb_interface_id(c, f);\n\tif (id < 0)\n\t\treturn id;\n\tloopback_intf.bInterfaceNumber = id;\n\n\tid = usb_string_id(cdev);\n\tif (id < 0)\n\t\treturn id;\n\tstrings_loopback[0].id = id;\n\tloopback_intf.iInterface = id;\n\n\t \n\n\tloop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);\n\tif (!loop->in_ep) {\nautoconf_fail:\n\t\tERROR(cdev, \"%s: can't autoconfigure on %s\\n\",\n\t\t\tf->name, cdev->gadget->name);\n\t\treturn -ENODEV;\n\t}\n\n\tloop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);\n\tif (!loop->out_ep)\n\t\tgoto autoconf_fail;\n\n\t \n\ths_loop_source_desc.bEndpointAddress =\n\t\tfs_loop_source_desc.bEndpointAddress;\n\ths_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;\n\n\t \n\tss_loop_source_desc.bEndpointAddress =\n\t\tfs_loop_source_desc.bEndpointAddress;\n\tss_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;\n\n\tret = usb_assign_descriptors(f, fs_loopback_descs, hs_loopback_descs,\n\t\t\tss_loopback_descs, ss_loopback_descs);\n\tif (ret)\n\t\treturn ret;\n\n\tDBG(cdev, \"%s: IN/%s, OUT/%s\\n\",\n\t\t\tf->name, loop->in_ep->name, loop->out_ep->name);\n\treturn 0;\n}\n\nstatic void lb_free_func(struct usb_function *f)\n{\n\tstruct f_lb_opts *opts;\n\n\topts = container_of(f->fi, struct f_lb_opts, func_inst);\n\n\tmutex_lock(&opts->lock);\n\topts->refcnt--;\n\tmutex_unlock(&opts->lock);\n\n\tusb_free_all_descriptors(f);\n\tkfree(func_to_loop(f));\n}\n\nstatic void loopback_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct f_loopback\t*loop = ep->driver_data;\n\tstruct usb_composite_dev *cdev = loop->function.config->cdev;\n\tint\t\t\tstatus = req->status;\n\n\tswitch (status) {\n\tcase 0:\t\t\t\t \n\t\tif (ep == loop->out_ep) {\n\t\t\t \n\t\t\tstruct usb_request *in_req = req->context;\n\n\t\t\tin_req->zero = (req->actual < req->length);\n\t\t\tin_req->length = req->actual;\n\t\t\tep = loop->in_ep;\n\t\t\treq = in_req;\n\t\t} else {\n\t\t\t \n\t\t\treq = req->context;\n\t\t\tep = loop->out_ep;\n\t\t}\n\n\t\t \n\t\tstatus = usb_ep_queue(ep, req, GFP_ATOMIC);\n\t\tif (status == 0) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tERROR(cdev, \"Unable to loop back buffer to %s: %d\\n\",\n\t\t\t      ep->name, status);\n\t\t\tgoto free_req;\n\t\t}\n\n\t\t \n\tdefault:\n\t\tERROR(cdev, \"%s loop complete --> %d, %d/%d\\n\", ep->name,\n\t\t\t\tstatus, req->actual, req->length);\n\t\tfallthrough;\n\n\t \n\tcase -ECONNABORTED:\t\t \n\tcase -ECONNRESET:\t\t \n\tcase -ESHUTDOWN:\t\t \nfree_req:\n\t\tusb_ep_free_request(ep == loop->in_ep ?\n\t\t\t\t    loop->out_ep : loop->in_ep,\n\t\t\t\t    req->context);\n\t\tfree_ep_req(ep, req);\n\t\treturn;\n\t}\n}\n\nstatic void disable_loopback(struct f_loopback *loop)\n{\n\tstruct usb_composite_dev\t*cdev;\n\n\tcdev = loop->function.config->cdev;\n\tdisable_endpoints(cdev, loop->in_ep, loop->out_ep, NULL, NULL);\n\tVDBG(cdev, \"%s disabled\\n\", loop->function.name);\n}\n\nstatic inline struct usb_request *lb_alloc_ep_req(struct usb_ep *ep, int len)\n{\n\treturn alloc_ep_req(ep, len);\n}\n\nstatic int alloc_requests(struct usb_composite_dev *cdev,\n\t\t\t  struct f_loopback *loop)\n{\n\tstruct usb_request *in_req, *out_req;\n\tint i;\n\tint result = 0;\n\n\t \n\tfor (i = 0; i < loop->qlen && result == 0; i++) {\n\t\tresult = -ENOMEM;\n\n\t\tin_req = usb_ep_alloc_request(loop->in_ep, GFP_ATOMIC);\n\t\tif (!in_req)\n\t\t\tgoto fail;\n\n\t\tout_req = lb_alloc_ep_req(loop->out_ep, loop->buflen);\n\t\tif (!out_req)\n\t\t\tgoto fail_in;\n\n\t\tin_req->complete = loopback_complete;\n\t\tout_req->complete = loopback_complete;\n\n\t\tin_req->buf = out_req->buf;\n\t\t \n\t\tin_req->context = out_req;\n\t\tout_req->context = in_req;\n\n\t\tresult = usb_ep_queue(loop->out_ep, out_req, GFP_ATOMIC);\n\t\tif (result) {\n\t\t\tERROR(cdev, \"%s queue req --> %d\\n\",\n\t\t\t\t\tloop->out_ep->name, result);\n\t\t\tgoto fail_out;\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_out:\n\tfree_ep_req(loop->out_ep, out_req);\nfail_in:\n\tusb_ep_free_request(loop->in_ep, in_req);\nfail:\n\treturn result;\n}\n\nstatic int enable_endpoint(struct usb_composite_dev *cdev,\n\t\t\t   struct f_loopback *loop, struct usb_ep *ep)\n{\n\tint\t\t\t\t\tresult;\n\n\tresult = config_ep_by_speed(cdev->gadget, &(loop->function), ep);\n\tif (result)\n\t\tgoto out;\n\n\tresult = usb_ep_enable(ep);\n\tif (result < 0)\n\t\tgoto out;\n\tep->driver_data = loop;\n\tresult = 0;\n\nout:\n\treturn result;\n}\n\nstatic int\nenable_loopback(struct usb_composite_dev *cdev, struct f_loopback *loop)\n{\n\tint\t\t\t\t\tresult = 0;\n\n\tresult = enable_endpoint(cdev, loop, loop->in_ep);\n\tif (result)\n\t\tgoto out;\n\n\tresult = enable_endpoint(cdev, loop, loop->out_ep);\n\tif (result)\n\t\tgoto disable_in;\n\n\tresult = alloc_requests(cdev, loop);\n\tif (result)\n\t\tgoto disable_out;\n\n\tDBG(cdev, \"%s enabled\\n\", loop->function.name);\n\treturn 0;\n\ndisable_out:\n\tusb_ep_disable(loop->out_ep);\ndisable_in:\n\tusb_ep_disable(loop->in_ep);\nout:\n\treturn result;\n}\n\nstatic int loopback_set_alt(struct usb_function *f,\n\t\tunsigned intf, unsigned alt)\n{\n\tstruct f_loopback\t*loop = func_to_loop(f);\n\tstruct usb_composite_dev *cdev = f->config->cdev;\n\n\t \n\tdisable_loopback(loop);\n\treturn enable_loopback(cdev, loop);\n}\n\nstatic void loopback_disable(struct usb_function *f)\n{\n\tstruct f_loopback\t*loop = func_to_loop(f);\n\n\tdisable_loopback(loop);\n}\n\nstatic struct usb_function *loopback_alloc(struct usb_function_instance *fi)\n{\n\tstruct f_loopback\t*loop;\n\tstruct f_lb_opts\t*lb_opts;\n\n\tloop = kzalloc(sizeof *loop, GFP_KERNEL);\n\tif (!loop)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlb_opts = container_of(fi, struct f_lb_opts, func_inst);\n\n\tmutex_lock(&lb_opts->lock);\n\tlb_opts->refcnt++;\n\tmutex_unlock(&lb_opts->lock);\n\n\tloop->buflen = lb_opts->bulk_buflen;\n\tloop->qlen = lb_opts->qlen;\n\tif (!loop->qlen)\n\t\tloop->qlen = 32;\n\n\tloop->function.name = \"loopback\";\n\tloop->function.bind = loopback_bind;\n\tloop->function.set_alt = loopback_set_alt;\n\tloop->function.disable = loopback_disable;\n\tloop->function.strings = loopback_strings;\n\n\tloop->function.free_func = lb_free_func;\n\n\treturn &loop->function;\n}\n\nstatic inline struct f_lb_opts *to_f_lb_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_lb_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void lb_attr_release(struct config_item *item)\n{\n\tstruct f_lb_opts *lb_opts = to_f_lb_opts(item);\n\n\tusb_put_function_instance(&lb_opts->func_inst);\n}\n\nstatic struct configfs_item_operations lb_item_ops = {\n\t.release\t\t= lb_attr_release,\n};\n\nstatic ssize_t f_lb_opts_qlen_show(struct config_item *item, char *page)\n{\n\tstruct f_lb_opts *opts = to_f_lb_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%d\\n\", opts->qlen);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_lb_opts_qlen_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_lb_opts *opts = to_f_lb_opts(item);\n\tint ret;\n\tu32 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->qlen = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_lb_opts_, qlen);\n\nstatic ssize_t f_lb_opts_bulk_buflen_show(struct config_item *item, char *page)\n{\n\tstruct f_lb_opts *opts = to_f_lb_opts(item);\n\tint result;\n\n\tmutex_lock(&opts->lock);\n\tresult = sprintf(page, \"%d\\n\", opts->bulk_buflen);\n\tmutex_unlock(&opts->lock);\n\n\treturn result;\n}\n\nstatic ssize_t f_lb_opts_bulk_buflen_store(struct config_item *item,\n\t\t\t\t    const char *page, size_t len)\n{\n\tstruct f_lb_opts *opts = to_f_lb_opts(item);\n\tint ret;\n\tu32 num;\n\n\tmutex_lock(&opts->lock);\n\tif (opts->refcnt) {\n\t\tret = -EBUSY;\n\t\tgoto end;\n\t}\n\n\tret = kstrtou32(page, 0, &num);\n\tif (ret)\n\t\tgoto end;\n\n\topts->bulk_buflen = num;\n\tret = len;\nend:\n\tmutex_unlock(&opts->lock);\n\treturn ret;\n}\n\nCONFIGFS_ATTR(f_lb_opts_, bulk_buflen);\n\nstatic struct configfs_attribute *lb_attrs[] = {\n\t&f_lb_opts_attr_qlen,\n\t&f_lb_opts_attr_bulk_buflen,\n\tNULL,\n};\n\nstatic const struct config_item_type lb_func_type = {\n\t.ct_item_ops    = &lb_item_ops,\n\t.ct_attrs\t= lb_attrs,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic void lb_free_instance(struct usb_function_instance *fi)\n{\n\tstruct f_lb_opts *lb_opts;\n\n\tlb_opts = container_of(fi, struct f_lb_opts, func_inst);\n\tkfree(lb_opts);\n}\n\nstatic struct usb_function_instance *loopback_alloc_instance(void)\n{\n\tstruct f_lb_opts *lb_opts;\n\n\tlb_opts = kzalloc(sizeof(*lb_opts), GFP_KERNEL);\n\tif (!lb_opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmutex_init(&lb_opts->lock);\n\tlb_opts->func_inst.free_func_inst = lb_free_instance;\n\tlb_opts->bulk_buflen = GZERO_BULK_BUFLEN;\n\tlb_opts->qlen = GZERO_QLEN;\n\n\tconfig_group_init_type_name(&lb_opts->func_inst.group, \"\",\n\t\t\t\t    &lb_func_type);\n\n\treturn  &lb_opts->func_inst;\n}\nDECLARE_USB_FUNCTION(Loopback, loopback_alloc_instance, loopback_alloc);\n\nint __init lb_modinit(void)\n{\n\treturn usb_function_register(&Loopbackusb_func);\n}\n\nvoid __exit lb_modexit(void)\n{\n\tusb_function_unregister(&Loopbackusb_func);\n}\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}