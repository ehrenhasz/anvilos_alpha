{
  "module_name": "functions.c",
  "hash_id": "0f0dded8cf04d9b86d3471950e64cc03977ff8a58886f9b087fbecb62380d5a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/functions.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/err.h>\n\n#include <linux/usb/composite.h>\n\nstatic LIST_HEAD(func_list);\nstatic DEFINE_MUTEX(func_lock);\n\nstatic struct usb_function_instance *try_get_usb_function_instance(const char *name)\n{\n\tstruct usb_function_driver *fd;\n\tstruct usb_function_instance *fi;\n\n\tfi = ERR_PTR(-ENOENT);\n\tmutex_lock(&func_lock);\n\tlist_for_each_entry(fd, &func_list, list) {\n\n\t\tif (strcmp(name, fd->name))\n\t\t\tcontinue;\n\n\t\tif (!try_module_get(fd->mod)) {\n\t\t\tfi = ERR_PTR(-EBUSY);\n\t\t\tbreak;\n\t\t}\n\t\tfi = fd->alloc_inst();\n\t\tif (IS_ERR(fi))\n\t\t\tmodule_put(fd->mod);\n\t\telse\n\t\t\tfi->fd = fd;\n\t\tbreak;\n\t}\n\tmutex_unlock(&func_lock);\n\treturn fi;\n}\n\nstruct usb_function_instance *usb_get_function_instance(const char *name)\n{\n\tstruct usb_function_instance *fi;\n\tint ret;\n\n\tfi = try_get_usb_function_instance(name);\n\tif (!IS_ERR(fi))\n\t\treturn fi;\n\tret = PTR_ERR(fi);\n\tif (ret != -ENOENT)\n\t\treturn fi;\n\tret = request_module(\"usbfunc:%s\", name);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\treturn try_get_usb_function_instance(name);\n}\nEXPORT_SYMBOL_GPL(usb_get_function_instance);\n\nstruct usb_function *usb_get_function(struct usb_function_instance *fi)\n{\n\tstruct usb_function *f;\n\n\tf = fi->fd->alloc_func(fi);\n\tif (IS_ERR(f))\n\t\treturn f;\n\tf->fi = fi;\n\treturn f;\n}\nEXPORT_SYMBOL_GPL(usb_get_function);\n\nvoid usb_put_function_instance(struct usb_function_instance *fi)\n{\n\tstruct module *mod;\n\n\tif (!fi)\n\t\treturn;\n\n\tmod = fi->fd->mod;\n\tfi->free_func_inst(fi);\n\tmodule_put(mod);\n}\nEXPORT_SYMBOL_GPL(usb_put_function_instance);\n\nvoid usb_put_function(struct usb_function *f)\n{\n\tif (!f)\n\t\treturn;\n\n\tf->free_func(f);\n}\nEXPORT_SYMBOL_GPL(usb_put_function);\n\nint usb_function_register(struct usb_function_driver *newf)\n{\n\tstruct usb_function_driver *fd;\n\tint ret;\n\n\tret = -EEXIST;\n\n\tmutex_lock(&func_lock);\n\tlist_for_each_entry(fd, &func_list, list) {\n\t\tif (!strcmp(fd->name, newf->name))\n\t\t\tgoto out;\n\t}\n\tret = 0;\n\tlist_add_tail(&newf->list, &func_list);\nout:\n\tmutex_unlock(&func_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_function_register);\n\nvoid usb_function_unregister(struct usb_function_driver *fd)\n{\n\tmutex_lock(&func_lock);\n\tlist_del(&fd->list);\n\tmutex_unlock(&func_lock);\n}\nEXPORT_SYMBOL_GPL(usb_function_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}