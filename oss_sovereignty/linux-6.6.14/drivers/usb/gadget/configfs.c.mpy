{
  "module_name": "configfs.c",
  "hash_id": "2567be13397bcf0624f188d2e3f03257d65f457a134b6f75415cc1726540a032",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/configfs.c",
  "human_readable_source": "\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/kstrtox.h>\n#include <linux/nls.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget_configfs.h>\n#include <linux/usb/webusb.h>\n#include \"configfs.h\"\n#include \"u_f.h\"\n#include \"u_os_desc.h\"\n\nint check_user_usb_string(const char *name,\n\t\tstruct usb_gadget_strings *stringtab_dev)\n{\n\tu16 num;\n\tint ret;\n\n\tret = kstrtou16(name, 0, &num);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!usb_validate_langid(num))\n\t\treturn -EINVAL;\n\n\tstringtab_dev->language = num;\n\treturn 0;\n}\n\n#define MAX_NAME_LEN\t40\n#define MAX_USB_STRING_LANGS 2\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\nstruct gadget_info {\n\tstruct config_group group;\n\tstruct config_group functions_group;\n\tstruct config_group configs_group;\n\tstruct config_group strings_group;\n\tstruct config_group os_desc_group;\n\tstruct config_group webusb_group;\n\n\tstruct mutex lock;\n\tstruct usb_gadget_strings *gstrings[MAX_USB_STRING_LANGS + 1];\n\tstruct list_head string_list;\n\tstruct list_head available_func;\n\n\tstruct usb_composite_driver composite;\n\tstruct usb_composite_dev cdev;\n\tbool use_os_desc;\n\tchar b_vendor_code;\n\tchar qw_sign[OS_STRING_QW_SIGN_LEN];\n\tbool use_webusb;\n\tu16 bcd_webusb_version;\n\tu8 b_webusb_vendor_code;\n\tchar landing_page[WEBUSB_URL_RAW_MAX_LENGTH];\n\n\tspinlock_t spinlock;\n\tbool unbind;\n};\n\nstatic inline struct gadget_info *to_gadget_info(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct gadget_info, group);\n}\n\nstruct config_usb_cfg {\n\tstruct config_group group;\n\tstruct config_group strings_group;\n\tstruct list_head string_list;\n\tstruct usb_configuration c;\n\tstruct list_head func_list;\n\tstruct usb_gadget_strings *gstrings[MAX_USB_STRING_LANGS + 1];\n};\n\nstatic inline struct config_usb_cfg *to_config_usb_cfg(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct config_usb_cfg,\n\t\t\tgroup);\n}\n\nstatic inline struct gadget_info *cfg_to_gadget_info(struct config_usb_cfg *cfg)\n{\n\treturn container_of(cfg->c.cdev, struct gadget_info, cdev);\n}\n\nstruct gadget_language {\n\tstruct usb_gadget_strings stringtab_dev;\n\tstruct usb_string strings[USB_GADGET_FIRST_AVAIL_IDX];\n\tchar *manufacturer;\n\tchar *product;\n\tchar *serialnumber;\n\n\tstruct config_group group;\n\tstruct list_head list;\n\tstruct list_head gadget_strings;\n\tunsigned int nstrings;\n};\n\nstruct gadget_config_name {\n\tstruct usb_gadget_strings stringtab_dev;\n\tstruct usb_string strings;\n\tchar *configuration;\n\n\tstruct config_group group;\n\tstruct list_head list;\n};\n\n#define USB_MAX_STRING_WITH_NULL_LEN\t(USB_MAX_STRING_LEN+1)\n\nstatic int usb_string_copy(const char *s, char **s_copy)\n{\n\tint ret;\n\tchar *str;\n\tchar *copy = *s_copy;\n\tret = strlen(s);\n\tif (ret > USB_MAX_STRING_LEN)\n\t\treturn -EOVERFLOW;\n\n\tif (copy) {\n\t\tstr = copy;\n\t} else {\n\t\tstr = kmalloc(USB_MAX_STRING_WITH_NULL_LEN, GFP_KERNEL);\n\t\tif (!str)\n\t\t\treturn -ENOMEM;\n\t}\n\tstrcpy(str, s);\n\tif (str[ret - 1] == '\\n')\n\t\tstr[ret - 1] = '\\0';\n\t*s_copy = str;\n\treturn 0;\n}\n\n#define GI_DEVICE_DESC_SIMPLE_R_u8(__name)\t\\\nstatic ssize_t gadget_dev_desc_##__name##_show(struct config_item *item, \\\n\t\t\tchar *page)\t\\\n{\t\\\n\treturn sprintf(page, \"0x%02x\\n\", \\\n\t\tto_gadget_info(item)->cdev.desc.__name); \\\n}\n\n#define GI_DEVICE_DESC_SIMPLE_R_u16(__name)\t\\\nstatic ssize_t gadget_dev_desc_##__name##_show(struct config_item *item, \\\n\t\t\tchar *page)\t\\\n{\t\\\n\treturn sprintf(page, \"0x%04x\\n\", \\\n\t\tle16_to_cpup(&to_gadget_info(item)->cdev.desc.__name)); \\\n}\n\n\n#define GI_DEVICE_DESC_SIMPLE_W_u8(_name)\t\t\\\nstatic ssize_t gadget_dev_desc_##_name##_store(struct config_item *item, \\\n\t\tconst char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tu8 val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\\\n\tret = kstrtou8(page, 0, &val);\t\t\t\\\n\tif (ret)\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\\\n\tto_gadget_info(item)->cdev.desc._name = val;\t\\\n\treturn len;\t\t\t\t\t\\\n}\n\n#define GI_DEVICE_DESC_SIMPLE_W_u16(_name)\t\\\nstatic ssize_t gadget_dev_desc_##_name##_store(struct config_item *item, \\\n\t\tconst char *page, size_t len)\t\t\\\n{\t\t\t\t\t\t\t\\\n\tu16 val;\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\\\n\tret = kstrtou16(page, 0, &val);\t\t\t\\\n\tif (ret)\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\\\n\tto_gadget_info(item)->cdev.desc._name = cpu_to_le16p(&val);\t\\\n\treturn len;\t\t\t\t\t\\\n}\n\n#define GI_DEVICE_DESC_SIMPLE_RW(_name, _type)\t\\\n\tGI_DEVICE_DESC_SIMPLE_R_##_type(_name)\t\\\n\tGI_DEVICE_DESC_SIMPLE_W_##_type(_name)\n\nGI_DEVICE_DESC_SIMPLE_R_u16(bcdUSB);\nGI_DEVICE_DESC_SIMPLE_RW(bDeviceClass, u8);\nGI_DEVICE_DESC_SIMPLE_RW(bDeviceSubClass, u8);\nGI_DEVICE_DESC_SIMPLE_RW(bDeviceProtocol, u8);\nGI_DEVICE_DESC_SIMPLE_RW(bMaxPacketSize0, u8);\nGI_DEVICE_DESC_SIMPLE_RW(idVendor, u16);\nGI_DEVICE_DESC_SIMPLE_RW(idProduct, u16);\nGI_DEVICE_DESC_SIMPLE_R_u16(bcdDevice);\n\nstatic ssize_t is_valid_bcd(u16 bcd_val)\n{\n\tif ((bcd_val & 0xf) > 9)\n\t\treturn -EINVAL;\n\tif (((bcd_val >> 4) & 0xf) > 9)\n\t\treturn -EINVAL;\n\tif (((bcd_val >> 8) & 0xf) > 9)\n\t\treturn -EINVAL;\n\tif (((bcd_val >> 12) & 0xf) > 9)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic ssize_t gadget_dev_desc_bcdDevice_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tu16 bcdDevice;\n\tint ret;\n\n\tret = kstrtou16(page, 0, &bcdDevice);\n\tif (ret)\n\t\treturn ret;\n\tret = is_valid_bcd(bcdDevice);\n\tif (ret)\n\t\treturn ret;\n\n\tto_gadget_info(item)->cdev.desc.bcdDevice = cpu_to_le16(bcdDevice);\n\treturn len;\n}\n\nstatic ssize_t gadget_dev_desc_bcdUSB_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tu16 bcdUSB;\n\tint ret;\n\n\tret = kstrtou16(page, 0, &bcdUSB);\n\tif (ret)\n\t\treturn ret;\n\tret = is_valid_bcd(bcdUSB);\n\tif (ret)\n\t\treturn ret;\n\n\tto_gadget_info(item)->cdev.desc.bcdUSB = cpu_to_le16(bcdUSB);\n\treturn len;\n}\n\nstatic ssize_t gadget_dev_desc_UDC_show(struct config_item *item, char *page)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\tchar *udc_name;\n\tint ret;\n\n\tmutex_lock(&gi->lock);\n\tudc_name = gi->composite.gadget_driver.udc_name;\n\tret = sprintf(page, \"%s\\n\", udc_name ?: \"\");\n\tmutex_unlock(&gi->lock);\n\n\treturn ret;\n}\n\nstatic int unregister_gadget(struct gadget_info *gi)\n{\n\tint ret;\n\n\tif (!gi->composite.gadget_driver.udc_name)\n\t\treturn -ENODEV;\n\n\tret = usb_gadget_unregister_driver(&gi->composite.gadget_driver);\n\tif (ret)\n\t\treturn ret;\n\tkfree(gi->composite.gadget_driver.udc_name);\n\tgi->composite.gadget_driver.udc_name = NULL;\n\treturn 0;\n}\n\nstatic ssize_t gadget_dev_desc_UDC_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\tchar *name;\n\tint ret;\n\n\tif (strlen(page) < len)\n\t\treturn -EOVERFLOW;\n\n\tname = kstrdup(page, GFP_KERNEL);\n\tif (!name)\n\t\treturn -ENOMEM;\n\tif (name[len - 1] == '\\n')\n\t\tname[len - 1] = '\\0';\n\n\tmutex_lock(&gi->lock);\n\n\tif (!strlen(name)) {\n\t\tret = unregister_gadget(gi);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tkfree(name);\n\t} else {\n\t\tif (gi->composite.gadget_driver.udc_name) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\t\tgi->composite.gadget_driver.udc_name = name;\n\t\tret = usb_gadget_register_driver(&gi->composite.gadget_driver);\n\t\tif (ret) {\n\t\t\tgi->composite.gadget_driver.udc_name = NULL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tmutex_unlock(&gi->lock);\n\treturn len;\nerr:\n\tkfree(name);\n\tmutex_unlock(&gi->lock);\n\treturn ret;\n}\n\nstatic ssize_t gadget_dev_desc_max_speed_show(struct config_item *item,\n\t\t\t\t\t      char *page)\n{\n\tenum usb_device_speed speed = to_gadget_info(item)->composite.max_speed;\n\n\treturn sprintf(page, \"%s\\n\", usb_speed_string(speed));\n}\n\nstatic ssize_t gadget_dev_desc_max_speed_store(struct config_item *item,\n\t\t\t\t\t       const char *page, size_t len)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\n\tmutex_lock(&gi->lock);\n\n\t \n\tif (gi->composite.gadget_driver.udc_name)\n\t\tgoto err;\n\n\tif (strncmp(page, \"super-speed-plus\", 16) == 0)\n\t\tgi->composite.max_speed = USB_SPEED_SUPER_PLUS;\n\telse if (strncmp(page, \"super-speed\", 11) == 0)\n\t\tgi->composite.max_speed = USB_SPEED_SUPER;\n\telse if (strncmp(page, \"high-speed\", 10) == 0)\n\t\tgi->composite.max_speed = USB_SPEED_HIGH;\n\telse if (strncmp(page, \"full-speed\", 10) == 0)\n\t\tgi->composite.max_speed = USB_SPEED_FULL;\n\telse if (strncmp(page, \"low-speed\", 9) == 0)\n\t\tgi->composite.max_speed = USB_SPEED_LOW;\n\telse\n\t\tgoto err;\n\n\tgi->composite.gadget_driver.max_speed = gi->composite.max_speed;\n\n\tmutex_unlock(&gi->lock);\n\treturn len;\nerr:\n\tmutex_unlock(&gi->lock);\n\treturn -EINVAL;\n}\n\nCONFIGFS_ATTR(gadget_dev_desc_, bDeviceClass);\nCONFIGFS_ATTR(gadget_dev_desc_, bDeviceSubClass);\nCONFIGFS_ATTR(gadget_dev_desc_, bDeviceProtocol);\nCONFIGFS_ATTR(gadget_dev_desc_, bMaxPacketSize0);\nCONFIGFS_ATTR(gadget_dev_desc_, idVendor);\nCONFIGFS_ATTR(gadget_dev_desc_, idProduct);\nCONFIGFS_ATTR(gadget_dev_desc_, bcdDevice);\nCONFIGFS_ATTR(gadget_dev_desc_, bcdUSB);\nCONFIGFS_ATTR(gadget_dev_desc_, UDC);\nCONFIGFS_ATTR(gadget_dev_desc_, max_speed);\n\nstatic struct configfs_attribute *gadget_root_attrs[] = {\n\t&gadget_dev_desc_attr_bDeviceClass,\n\t&gadget_dev_desc_attr_bDeviceSubClass,\n\t&gadget_dev_desc_attr_bDeviceProtocol,\n\t&gadget_dev_desc_attr_bMaxPacketSize0,\n\t&gadget_dev_desc_attr_idVendor,\n\t&gadget_dev_desc_attr_idProduct,\n\t&gadget_dev_desc_attr_bcdDevice,\n\t&gadget_dev_desc_attr_bcdUSB,\n\t&gadget_dev_desc_attr_UDC,\n\t&gadget_dev_desc_attr_max_speed,\n\tNULL,\n};\n\nstatic inline struct gadget_language *to_gadget_language(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct gadget_language,\n\t\t\t group);\n}\n\nstatic inline struct gadget_config_name *to_gadget_config_name(\n\t\tstruct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct gadget_config_name,\n\t\t\t group);\n}\n\nstatic inline struct usb_function_instance *to_usb_function_instance(\n\t\tstruct config_item *item)\n{\n\treturn container_of(to_config_group(item),\n\t\t\t struct usb_function_instance, group);\n}\n\nstatic void gadget_info_attr_release(struct config_item *item)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\n\tWARN_ON(!list_empty(&gi->cdev.configs));\n\tWARN_ON(!list_empty(&gi->string_list));\n\tWARN_ON(!list_empty(&gi->available_func));\n\tkfree(gi->composite.gadget_driver.function);\n\tkfree(gi->composite.gadget_driver.driver.name);\n\tkfree(gi);\n}\n\nstatic struct configfs_item_operations gadget_root_item_ops = {\n\t.release                = gadget_info_attr_release,\n};\n\nstatic void gadget_config_attr_release(struct config_item *item)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\n\tWARN_ON(!list_empty(&cfg->c.functions));\n\tlist_del(&cfg->c.list);\n\tkfree(cfg->c.label);\n\tkfree(cfg);\n}\n\nstatic int config_usb_cfg_link(\n\tstruct config_item *usb_cfg_ci,\n\tstruct config_item *usb_func_ci)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\n\tstruct gadget_info *gi = cfg_to_gadget_info(cfg);\n\n\tstruct usb_function_instance *fi =\n\t\t\tto_usb_function_instance(usb_func_ci);\n\tstruct usb_function_instance *a_fi = NULL, *iter;\n\tstruct usb_function *f;\n\tint ret;\n\n\tmutex_lock(&gi->lock);\n\t \n\n\tif (gi->composite.gadget_driver.udc_name) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(iter, &gi->available_func, cfs_list) {\n\t\tif (iter != fi)\n\t\t\tcontinue;\n\t\ta_fi = iter;\n\t\tbreak;\n\t}\n\tif (!a_fi) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(f, &cfg->func_list, list) {\n\t\tif (f->fi == fi) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tf = usb_get_function(fi);\n\tif (IS_ERR(f)) {\n\t\tret = PTR_ERR(f);\n\t\tgoto out;\n\t}\n\n\t \n\tlist_add_tail(&f->list, &cfg->func_list);\n\tret = 0;\nout:\n\tmutex_unlock(&gi->lock);\n\treturn ret;\n}\n\nstatic void config_usb_cfg_unlink(\n\tstruct config_item *usb_cfg_ci,\n\tstruct config_item *usb_func_ci)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(usb_cfg_ci);\n\tstruct gadget_info *gi = cfg_to_gadget_info(cfg);\n\n\tstruct usb_function_instance *fi =\n\t\t\tto_usb_function_instance(usb_func_ci);\n\tstruct usb_function *f;\n\n\t \n\tmutex_lock(&gi->lock);\n\tif (gi->composite.gadget_driver.udc_name)\n\t\tunregister_gadget(gi);\n\tWARN_ON(gi->composite.gadget_driver.udc_name);\n\n\tlist_for_each_entry(f, &cfg->func_list, list) {\n\t\tif (f->fi == fi) {\n\t\t\tlist_del(&f->list);\n\t\t\tusb_put_function(f);\n\t\t\tmutex_unlock(&gi->lock);\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&gi->lock);\n\tWARN(1, \"Unable to locate function to unbind\\n\");\n}\n\nstatic struct configfs_item_operations gadget_config_item_ops = {\n\t.release                = gadget_config_attr_release,\n\t.allow_link             = config_usb_cfg_link,\n\t.drop_link              = config_usb_cfg_unlink,\n};\n\n\nstatic ssize_t gadget_config_desc_MaxPower_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\n\treturn sprintf(page, \"%u\\n\", cfg->c.MaxPower);\n}\n\nstatic ssize_t gadget_config_desc_MaxPower_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\tu16 val;\n\tint ret;\n\tret = kstrtou16(page, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (DIV_ROUND_UP(val, 8) > 0xff)\n\t\treturn -ERANGE;\n\tcfg->c.MaxPower = val;\n\treturn len;\n}\n\nstatic ssize_t gadget_config_desc_bmAttributes_show(struct config_item *item,\n\t\tchar *page)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\n\treturn sprintf(page, \"0x%02x\\n\", cfg->c.bmAttributes);\n}\n\nstatic ssize_t gadget_config_desc_bmAttributes_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct config_usb_cfg *cfg = to_config_usb_cfg(item);\n\tu8 val;\n\tint ret;\n\tret = kstrtou8(page, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (!(val & USB_CONFIG_ATT_ONE))\n\t\treturn -EINVAL;\n\tif (val & ~(USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER |\n\t\t\t\tUSB_CONFIG_ATT_WAKEUP))\n\t\treturn -EINVAL;\n\tcfg->c.bmAttributes = val;\n\treturn len;\n}\n\nCONFIGFS_ATTR(gadget_config_desc_, MaxPower);\nCONFIGFS_ATTR(gadget_config_desc_, bmAttributes);\n\nstatic struct configfs_attribute *gadget_config_attrs[] = {\n\t&gadget_config_desc_attr_MaxPower,\n\t&gadget_config_desc_attr_bmAttributes,\n\tNULL,\n};\n\nstatic const struct config_item_type gadget_config_type = {\n\t.ct_item_ops\t= &gadget_config_item_ops,\n\t.ct_attrs\t= gadget_config_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic const struct config_item_type gadget_root_type = {\n\t.ct_item_ops\t= &gadget_root_item_ops,\n\t.ct_attrs\t= gadget_root_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic void composite_init_dev(struct usb_composite_dev *cdev)\n{\n\tspin_lock_init(&cdev->lock);\n\tINIT_LIST_HEAD(&cdev->configs);\n\tINIT_LIST_HEAD(&cdev->gstrings);\n}\n\nstatic struct config_group *function_make(\n\t\tstruct config_group *group,\n\t\tconst char *name)\n{\n\tstruct gadget_info *gi;\n\tstruct usb_function_instance *fi;\n\tchar buf[MAX_NAME_LEN];\n\tchar *func_name;\n\tchar *instance_name;\n\tint ret;\n\n\tret = snprintf(buf, MAX_NAME_LEN, \"%s\", name);\n\tif (ret >= MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tfunc_name = buf;\n\tinstance_name = strchr(func_name, '.');\n\tif (!instance_name) {\n\t\tpr_err(\"Unable to locate . in FUNC.INSTANCE\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\t*instance_name = '\\0';\n\tinstance_name++;\n\n\tfi = usb_get_function_instance(func_name);\n\tif (IS_ERR(fi))\n\t\treturn ERR_CAST(fi);\n\n\tret = config_item_set_name(&fi->group.cg_item, \"%s\", name);\n\tif (ret) {\n\t\tusb_put_function_instance(fi);\n\t\treturn ERR_PTR(ret);\n\t}\n\tif (fi->set_inst_name) {\n\t\tret = fi->set_inst_name(fi, instance_name);\n\t\tif (ret) {\n\t\t\tusb_put_function_instance(fi);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tgi = container_of(group, struct gadget_info, functions_group);\n\n\tmutex_lock(&gi->lock);\n\tlist_add_tail(&fi->cfs_list, &gi->available_func);\n\tmutex_unlock(&gi->lock);\n\treturn &fi->group;\n}\n\nstatic void function_drop(\n\t\tstruct config_group *group,\n\t\tstruct config_item *item)\n{\n\tstruct usb_function_instance *fi = to_usb_function_instance(item);\n\tstruct gadget_info *gi;\n\n\tgi = container_of(group, struct gadget_info, functions_group);\n\n\tmutex_lock(&gi->lock);\n\tlist_del(&fi->cfs_list);\n\tmutex_unlock(&gi->lock);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations functions_ops = {\n\t.make_group     = &function_make,\n\t.drop_item      = &function_drop,\n};\n\nstatic const struct config_item_type functions_type = {\n\t.ct_group_ops   = &functions_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nGS_STRINGS_RW(gadget_config_name, configuration);\n\nstatic struct configfs_attribute *gadget_config_name_langid_attrs[] = {\n\t&gadget_config_name_attr_configuration,\n\tNULL,\n};\n\nstatic void gadget_config_name_attr_release(struct config_item *item)\n{\n\tstruct gadget_config_name *cn = to_gadget_config_name(item);\n\n\tkfree(cn->configuration);\n\n\tlist_del(&cn->list);\n\tkfree(cn);\n}\n\nUSB_CONFIG_STRING_RW_OPS(gadget_config_name);\nUSB_CONFIG_STRINGS_LANG(gadget_config_name, config_usb_cfg);\n\nstatic struct config_group *config_desc_make(\n\t\tstruct config_group *group,\n\t\tconst char *name)\n{\n\tstruct gadget_info *gi;\n\tstruct config_usb_cfg *cfg;\n\tchar buf[MAX_NAME_LEN];\n\tchar *num_str;\n\tu8 num;\n\tint ret;\n\n\tgi = container_of(group, struct gadget_info, configs_group);\n\tret = snprintf(buf, MAX_NAME_LEN, \"%s\", name);\n\tif (ret >= MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnum_str = strchr(buf, '.');\n\tif (!num_str) {\n\t\tpr_err(\"Unable to locate . in name.bConfigurationValue\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t*num_str = '\\0';\n\tnum_str++;\n\n\tif (!strlen(buf))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = kstrtou8(num_str, 0, &num);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tcfg = kzalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcfg->c.label = kstrdup(buf, GFP_KERNEL);\n\tif (!cfg->c.label) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tcfg->c.bConfigurationValue = num;\n\tcfg->c.MaxPower = CONFIG_USB_GADGET_VBUS_DRAW;\n\tcfg->c.bmAttributes = USB_CONFIG_ATT_ONE;\n\tINIT_LIST_HEAD(&cfg->string_list);\n\tINIT_LIST_HEAD(&cfg->func_list);\n\n\tconfig_group_init_type_name(&cfg->group, name,\n\t\t\t\t&gadget_config_type);\n\n\tconfig_group_init_type_name(&cfg->strings_group, \"strings\",\n\t\t\t&gadget_config_name_strings_type);\n\tconfigfs_add_default_group(&cfg->strings_group, &cfg->group);\n\n\tret = usb_add_config_only(&gi->cdev, &cfg->c);\n\tif (ret)\n\t\tgoto err;\n\n\treturn &cfg->group;\nerr:\n\tkfree(cfg->c.label);\n\tkfree(cfg);\n\treturn ERR_PTR(ret);\n}\n\nstatic void config_desc_drop(\n\t\tstruct config_group *group,\n\t\tstruct config_item *item)\n{\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations config_desc_ops = {\n\t.make_group     = &config_desc_make,\n\t.drop_item      = &config_desc_drop,\n};\n\nstatic const struct config_item_type config_desc_type = {\n\t.ct_group_ops   = &config_desc_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nGS_STRINGS_RW(gadget_language, manufacturer);\nGS_STRINGS_RW(gadget_language, product);\nGS_STRINGS_RW(gadget_language, serialnumber);\n\nstatic struct configfs_attribute *gadget_language_langid_attrs[] = {\n\t&gadget_language_attr_manufacturer,\n\t&gadget_language_attr_product,\n\t&gadget_language_attr_serialnumber,\n\tNULL,\n};\n\nstatic void gadget_language_attr_release(struct config_item *item)\n{\n\tstruct gadget_language *gs = to_gadget_language(item);\n\n\tkfree(gs->manufacturer);\n\tkfree(gs->product);\n\tkfree(gs->serialnumber);\n\n\tlist_del(&gs->list);\n\tkfree(gs);\n}\n\nstatic struct configfs_item_operations gadget_language_langid_item_ops = {\n\t.release                = gadget_language_attr_release,\n};\n\nstatic ssize_t gadget_string_id_show(struct config_item *item, char *page)\n{\n\tstruct gadget_string *string = to_gadget_string(item);\n\tint ret;\n\n\tret = sprintf(page, \"%u\\n\", string->usb_string.id);\n\treturn ret;\n}\nCONFIGFS_ATTR_RO(gadget_string_, id);\n\nstatic ssize_t gadget_string_s_show(struct config_item *item, char *page)\n{\n\tstruct gadget_string *string = to_gadget_string(item);\n\tint ret;\n\n\tret = snprintf(page, sizeof(string->string), \"%s\\n\", string->string);\n\treturn ret;\n}\n\nstatic ssize_t gadget_string_s_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t len)\n{\n\tstruct gadget_string *string = to_gadget_string(item);\n\tint size = min(sizeof(string->string), len + 1);\n\n\tif (len > USB_MAX_STRING_LEN)\n\t\treturn -EINVAL;\n\n\treturn strscpy(string->string, page, size);\n}\nCONFIGFS_ATTR(gadget_string_, s);\n\nstatic struct configfs_attribute *gadget_string_attrs[] = {\n\t&gadget_string_attr_id,\n\t&gadget_string_attr_s,\n\tNULL,\n};\n\nstatic void gadget_string_release(struct config_item *item)\n{\n\tstruct gadget_string *string = to_gadget_string(item);\n\n\tkfree(string);\n}\n\nstatic struct configfs_item_operations gadget_string_item_ops = {\n\t.release\t= gadget_string_release,\n};\n\nstatic const struct config_item_type gadget_string_type = {\n\t.ct_item_ops\t= &gadget_string_item_ops,\n\t.ct_attrs\t= gadget_string_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item *gadget_language_string_make(struct config_group *group,\n\t\t\t\t\t\t       const char *name)\n{\n\tstruct gadget_language *language;\n\tstruct gadget_string *string;\n\n\tlanguage = to_gadget_language(&group->cg_item);\n\n\tstring = kzalloc(sizeof(*string), GFP_KERNEL);\n\tif (!string)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstring->usb_string.id = language->nstrings++;\n\tstring->usb_string.s = string->string;\n\tlist_add_tail(&string->list, &language->gadget_strings);\n\n\tconfig_item_init_type_name(&string->item, name, &gadget_string_type);\n\n\treturn &string->item;\n}\n\nstatic void gadget_language_string_drop(struct config_group *group,\n\t\t\t\t\tstruct config_item *item)\n{\n\tstruct gadget_language *language;\n\tstruct gadget_string *string;\n\tunsigned int i = USB_GADGET_FIRST_AVAIL_IDX;\n\n\tlanguage = to_gadget_language(&group->cg_item);\n\tstring = to_gadget_string(item);\n\n\tlist_del(&string->list);\n\tlanguage->nstrings--;\n\n\t \n\tlist_for_each_entry(string, &language->gadget_strings, list)\n\t\tstring->usb_string.id = i++;\n}\n\nstatic struct configfs_group_operations gadget_language_langid_group_ops = {\n\t.make_item\t\t= gadget_language_string_make,\n\t.drop_item\t\t= gadget_language_string_drop,\n};\n\nstatic struct config_item_type gadget_language_type = {\n\t.ct_item_ops\t= &gadget_language_langid_item_ops,\n\t.ct_group_ops\t= &gadget_language_langid_group_ops,\n\t.ct_attrs\t= gadget_language_langid_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *gadget_language_make(struct config_group *group,\n\t\t\t\t\t\t const char *name)\n{\n\tstruct gadget_info *gi;\n\tstruct gadget_language *gs;\n\tstruct gadget_language *new;\n\tint langs = 0;\n\tint ret;\n\n\tnew = kzalloc(sizeof(*new), GFP_KERNEL);\n\tif (!new)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = check_user_usb_string(name, &new->stringtab_dev);\n\tif (ret)\n\t\tgoto err;\n\tconfig_group_init_type_name(&new->group, name,\n\t\t\t\t    &gadget_language_type);\n\n\tgi = container_of(group, struct gadget_info, strings_group);\n\tret = -EEXIST;\n\tlist_for_each_entry(gs, &gi->string_list, list) {\n\t\tif (gs->stringtab_dev.language == new->stringtab_dev.language)\n\t\t\tgoto err;\n\t\tlangs++;\n\t}\n\tret = -EOVERFLOW;\n\tif (langs >= MAX_USB_STRING_LANGS)\n\t\tgoto err;\n\n\tlist_add_tail(&new->list, &gi->string_list);\n\tINIT_LIST_HEAD(&new->gadget_strings);\n\n\t \n\tnew->nstrings = 3;\n\treturn &new->group;\nerr:\n\tkfree(new);\n\treturn ERR_PTR(ret);\n}\n\nstatic void gadget_language_drop(struct config_group *group,\n\t\t\t\t struct config_item *item)\n{\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations gadget_language_group_ops = {\n\t.make_group     = &gadget_language_make,\n\t.drop_item      = &gadget_language_drop,\n};\n\nstatic struct config_item_type gadget_language_strings_type = {\n\t.ct_group_ops   = &gadget_language_group_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic inline struct gadget_info *webusb_item_to_gadget_info(\n\t\tstruct config_item *item)\n{\n\treturn container_of(to_config_group(item),\n\t\t\tstruct gadget_info, webusb_group);\n}\n\nstatic ssize_t webusb_use_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"%d\\n\",\n\t\t\twebusb_item_to_gadget_info(item)->use_webusb);\n}\n\nstatic ssize_t webusb_use_store(struct config_item *item, const char *page,\n\t\t\t\t size_t len)\n{\n\tstruct gadget_info *gi = webusb_item_to_gadget_info(item);\n\tint ret;\n\tbool use;\n\n\tret = kstrtobool(page, &use);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gi->lock);\n\tgi->use_webusb = use;\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nstatic ssize_t webusb_bcdVersion_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"0x%04x\\n\",\n\t\t\t\t\twebusb_item_to_gadget_info(item)->bcd_webusb_version);\n}\n\nstatic ssize_t webusb_bcdVersion_store(struct config_item *item,\n\t\tconst char *page, size_t len)\n{\n\tstruct gadget_info *gi = webusb_item_to_gadget_info(item);\n\tu16 bcdVersion;\n\tint ret;\n\n\tret = kstrtou16(page, 0, &bcdVersion);\n\tif (ret)\n\t\treturn ret;\n\n\tret = is_valid_bcd(bcdVersion);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gi->lock);\n\tgi->bcd_webusb_version = bcdVersion;\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nstatic ssize_t webusb_bVendorCode_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"0x%02x\\n\",\n\t\t\twebusb_item_to_gadget_info(item)->b_webusb_vendor_code);\n}\n\nstatic ssize_t webusb_bVendorCode_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct gadget_info *gi = webusb_item_to_gadget_info(item);\n\tint ret;\n\tu8 b_vendor_code;\n\n\tret = kstrtou8(page, 0, &b_vendor_code);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gi->lock);\n\tgi->b_webusb_vendor_code = b_vendor_code;\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nstatic ssize_t webusb_landingPage_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"%s\\n\", webusb_item_to_gadget_info(item)->landing_page);\n}\n\nstatic ssize_t webusb_landingPage_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t len)\n{\n\tstruct gadget_info *gi = webusb_item_to_gadget_info(item);\n\tunsigned int bytes_to_strip = 0;\n\tint l = len;\n\n\tif (page[l - 1] == '\\n') {\n\t\t--l;\n\t\t++bytes_to_strip;\n\t}\n\n\tif (l > sizeof(gi->landing_page)) {\n\t\tpr_err(\"webusb: landingPage URL too long\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t\n\tif (strncasecmp(page, \"https://\",  8) == 0)\n\t\tbytes_to_strip = 8;\n\telse if (strncasecmp(page, \"http://\", 7) == 0)\n\t\tbytes_to_strip = 7;\n\telse\n\t\tbytes_to_strip = 0;\n\n\tif (l > U8_MAX - WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH + bytes_to_strip) {\n\t\tpr_err(\"webusb: landingPage URL %d bytes too long for given URL scheme\\n\",\n\t\t\tl - U8_MAX + WEBUSB_URL_DESCRIPTOR_HEADER_LENGTH - bytes_to_strip);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&gi->lock);\n\t\n\tmemcpy_and_pad(gi->landing_page, sizeof(gi->landing_page), page, l, 0);\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nCONFIGFS_ATTR(webusb_, use);\nCONFIGFS_ATTR(webusb_, bVendorCode);\nCONFIGFS_ATTR(webusb_, bcdVersion);\nCONFIGFS_ATTR(webusb_, landingPage);\n\nstatic struct configfs_attribute *webusb_attrs[] = {\n\t&webusb_attr_use,\n\t&webusb_attr_bcdVersion,\n\t&webusb_attr_bVendorCode,\n\t&webusb_attr_landingPage,\n\tNULL,\n};\n\nstatic struct config_item_type webusb_type = {\n\t.ct_attrs\t= webusb_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic inline struct gadget_info *os_desc_item_to_gadget_info(\n\t\tstruct config_item *item)\n{\n\treturn container_of(to_config_group(item),\n\t\t\tstruct gadget_info, os_desc_group);\n}\n\nstatic ssize_t os_desc_use_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\",\n\t\t\tos_desc_item_to_gadget_info(item)->use_os_desc);\n}\n\nstatic ssize_t os_desc_use_store(struct config_item *item, const char *page,\n\t\t\t\t size_t len)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\n\tint ret;\n\tbool use;\n\n\tret = kstrtobool(page, &use);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gi->lock);\n\tgi->use_os_desc = use;\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nstatic ssize_t os_desc_b_vendor_code_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"0x%02x\\n\",\n\t\t\tos_desc_item_to_gadget_info(item)->b_vendor_code);\n}\n\nstatic ssize_t os_desc_b_vendor_code_store(struct config_item *item,\n\t\t\t\t\t   const char *page, size_t len)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\n\tint ret;\n\tu8 b_vendor_code;\n\n\tret = kstrtou8(page, 0, &b_vendor_code);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&gi->lock);\n\tgi->b_vendor_code = b_vendor_code;\n\tmutex_unlock(&gi->lock);\n\n\treturn len;\n}\n\nstatic ssize_t os_desc_qw_sign_show(struct config_item *item, char *page)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\n\tint res;\n\n\tres = utf16s_to_utf8s((wchar_t *) gi->qw_sign, OS_STRING_QW_SIGN_LEN,\n\t\t\t      UTF16_LITTLE_ENDIAN, page, PAGE_SIZE - 1);\n\tpage[res++] = '\\n';\n\n\treturn res;\n}\n\nstatic ssize_t os_desc_qw_sign_store(struct config_item *item, const char *page,\n\t\t\t\t     size_t len)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(item);\n\tint res, l;\n\n\tl = min((int)len, OS_STRING_QW_SIGN_LEN >> 1);\n\tif (page[l - 1] == '\\n')\n\t\t--l;\n\n\tmutex_lock(&gi->lock);\n\tres = utf8s_to_utf16s(page, l,\n\t\t\t      UTF16_LITTLE_ENDIAN, (wchar_t *) gi->qw_sign,\n\t\t\t      OS_STRING_QW_SIGN_LEN);\n\tif (res > 0)\n\t\tres = len;\n\tmutex_unlock(&gi->lock);\n\n\treturn res;\n}\n\nCONFIGFS_ATTR(os_desc_, use);\nCONFIGFS_ATTR(os_desc_, b_vendor_code);\nCONFIGFS_ATTR(os_desc_, qw_sign);\n\nstatic struct configfs_attribute *os_desc_attrs[] = {\n\t&os_desc_attr_use,\n\t&os_desc_attr_b_vendor_code,\n\t&os_desc_attr_qw_sign,\n\tNULL,\n};\n\nstatic int os_desc_link(struct config_item *os_desc_ci,\n\t\t\tstruct config_item *usb_cfg_ci)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(os_desc_ci);\n\tstruct usb_composite_dev *cdev = &gi->cdev;\n\tstruct config_usb_cfg *c_target = to_config_usb_cfg(usb_cfg_ci);\n\tstruct usb_configuration *c = NULL, *iter;\n\tint ret;\n\n\tmutex_lock(&gi->lock);\n\tlist_for_each_entry(iter, &cdev->configs, list) {\n\t\tif (iter != &c_target->c)\n\t\t\tcontinue;\n\t\tc = iter;\n\t\tbreak;\n\t}\n\tif (!c) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (cdev->os_desc_config) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tcdev->os_desc_config = &c_target->c;\n\tret = 0;\n\nout:\n\tmutex_unlock(&gi->lock);\n\treturn ret;\n}\n\nstatic void os_desc_unlink(struct config_item *os_desc_ci,\n\t\t\t  struct config_item *usb_cfg_ci)\n{\n\tstruct gadget_info *gi = os_desc_item_to_gadget_info(os_desc_ci);\n\tstruct usb_composite_dev *cdev = &gi->cdev;\n\n\tmutex_lock(&gi->lock);\n\tif (gi->composite.gadget_driver.udc_name)\n\t\tunregister_gadget(gi);\n\tcdev->os_desc_config = NULL;\n\tWARN_ON(gi->composite.gadget_driver.udc_name);\n\tmutex_unlock(&gi->lock);\n}\n\nstatic struct configfs_item_operations os_desc_ops = {\n\t.allow_link\t\t= os_desc_link,\n\t.drop_link\t\t= os_desc_unlink,\n};\n\nstatic struct config_item_type os_desc_type = {\n\t.ct_item_ops\t= &os_desc_ops,\n\t.ct_attrs\t= os_desc_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic inline struct usb_os_desc_ext_prop\n*to_usb_os_desc_ext_prop(struct config_item *item)\n{\n\treturn container_of(item, struct usb_os_desc_ext_prop, item);\n}\n\nstatic ssize_t ext_prop_type_show(struct config_item *item, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", to_usb_os_desc_ext_prop(item)->type);\n}\n\nstatic ssize_t ext_prop_type_store(struct config_item *item,\n\t\t\t\t   const char *page, size_t len)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\n\tstruct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);\n\tu8 type;\n\tint ret;\n\n\tret = kstrtou8(page, 0, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (type < USB_EXT_PROP_UNICODE || type > USB_EXT_PROP_UNICODE_MULTI)\n\t\treturn -EINVAL;\n\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\n\tif ((ext_prop->type == USB_EXT_PROP_BINARY ||\n\t    ext_prop->type == USB_EXT_PROP_LE32 ||\n\t    ext_prop->type == USB_EXT_PROP_BE32) &&\n\t    (type == USB_EXT_PROP_UNICODE ||\n\t    type == USB_EXT_PROP_UNICODE_ENV ||\n\t    type == USB_EXT_PROP_UNICODE_LINK))\n\t\text_prop->data_len <<= 1;\n\telse if ((ext_prop->type == USB_EXT_PROP_UNICODE ||\n\t\t   ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||\n\t\t   ext_prop->type == USB_EXT_PROP_UNICODE_LINK) &&\n\t\t   (type == USB_EXT_PROP_BINARY ||\n\t\t   type == USB_EXT_PROP_LE32 ||\n\t\t   type == USB_EXT_PROP_BE32))\n\t\text_prop->data_len >>= 1;\n\text_prop->type = type;\n\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\treturn len;\n}\n\nstatic ssize_t ext_prop_data_show(struct config_item *item, char *page)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\n\tint len = ext_prop->data_len;\n\n\tif (ext_prop->type == USB_EXT_PROP_UNICODE ||\n\t    ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||\n\t    ext_prop->type == USB_EXT_PROP_UNICODE_LINK)\n\t\tlen >>= 1;\n\tmemcpy(page, ext_prop->data, len);\n\n\treturn len;\n}\n\nstatic ssize_t ext_prop_data_store(struct config_item *item,\n\t\t\t\t   const char *page, size_t len)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\n\tstruct usb_os_desc *desc = to_usb_os_desc(ext_prop->item.ci_parent);\n\tchar *new_data;\n\tsize_t ret_len = len;\n\n\tif (page[len - 1] == '\\n' || page[len - 1] == '\\0')\n\t\t--len;\n\tnew_data = kmemdup(page, len, GFP_KERNEL);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\tkfree(ext_prop->data);\n\text_prop->data = new_data;\n\tdesc->ext_prop_len -= ext_prop->data_len;\n\text_prop->data_len = len;\n\tdesc->ext_prop_len += ext_prop->data_len;\n\tif (ext_prop->type == USB_EXT_PROP_UNICODE ||\n\t    ext_prop->type == USB_EXT_PROP_UNICODE_ENV ||\n\t    ext_prop->type == USB_EXT_PROP_UNICODE_LINK) {\n\t\tdesc->ext_prop_len -= ext_prop->data_len;\n\t\text_prop->data_len <<= 1;\n\t\text_prop->data_len += 2;\n\t\tdesc->ext_prop_len += ext_prop->data_len;\n\t}\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\treturn ret_len;\n}\n\nCONFIGFS_ATTR(ext_prop_, type);\nCONFIGFS_ATTR(ext_prop_, data);\n\nstatic struct configfs_attribute *ext_prop_attrs[] = {\n\t&ext_prop_attr_type,\n\t&ext_prop_attr_data,\n\tNULL,\n};\n\nstatic void usb_os_desc_ext_prop_release(struct config_item *item)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\n\n\tkfree(ext_prop);  \n}\n\nstatic struct configfs_item_operations ext_prop_ops = {\n\t.release\t\t= usb_os_desc_ext_prop_release,\n};\n\nstatic struct config_item *ext_prop_make(\n\t\tstruct config_group *group,\n\t\tconst char *name)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop;\n\tstruct config_item_type *ext_prop_type;\n\tstruct usb_os_desc *desc;\n\tchar *vlabuf;\n\n\tvla_group(data_chunk);\n\tvla_item(data_chunk, struct usb_os_desc_ext_prop, ext_prop, 1);\n\tvla_item(data_chunk, struct config_item_type, ext_prop_type, 1);\n\n\tvlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);\n\tif (!vlabuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\text_prop = vla_ptr(vlabuf, data_chunk, ext_prop);\n\text_prop_type = vla_ptr(vlabuf, data_chunk, ext_prop_type);\n\n\tdesc = container_of(group, struct usb_os_desc, group);\n\text_prop_type->ct_item_ops = &ext_prop_ops;\n\text_prop_type->ct_attrs = ext_prop_attrs;\n\text_prop_type->ct_owner = desc->owner;\n\n\tconfig_item_init_type_name(&ext_prop->item, name, ext_prop_type);\n\n\text_prop->name = kstrdup(name, GFP_KERNEL);\n\tif (!ext_prop->name) {\n\t\tkfree(vlabuf);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdesc->ext_prop_len += 14;\n\text_prop->name_len = 2 * strlen(ext_prop->name) + 2;\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\tdesc->ext_prop_len += ext_prop->name_len;\n\tlist_add_tail(&ext_prop->entry, &desc->ext_prop);\n\t++desc->ext_prop_count;\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\n\treturn &ext_prop->item;\n}\n\nstatic void ext_prop_drop(struct config_group *group, struct config_item *item)\n{\n\tstruct usb_os_desc_ext_prop *ext_prop = to_usb_os_desc_ext_prop(item);\n\tstruct usb_os_desc *desc = to_usb_os_desc(&group->cg_item);\n\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\tlist_del(&ext_prop->entry);\n\t--desc->ext_prop_count;\n\tkfree(ext_prop->name);\n\tdesc->ext_prop_len -= (ext_prop->name_len + ext_prop->data_len + 14);\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations interf_grp_ops = {\n\t.make_item\t= &ext_prop_make,\n\t.drop_item\t= &ext_prop_drop,\n};\n\nstatic ssize_t interf_grp_compatible_id_show(struct config_item *item,\n\t\t\t\t\t     char *page)\n{\n\tmemcpy(page, to_usb_os_desc(item)->ext_compat_id, 8);\n\treturn 8;\n}\n\nstatic ssize_t interf_grp_compatible_id_store(struct config_item *item,\n\t\t\t\t\t      const char *page, size_t len)\n{\n\tstruct usb_os_desc *desc = to_usb_os_desc(item);\n\tint l;\n\n\tl = min_t(int, 8, len);\n\tif (page[l - 1] == '\\n')\n\t\t--l;\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\tmemcpy(desc->ext_compat_id, page, l);\n\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\n\treturn len;\n}\n\nstatic ssize_t interf_grp_sub_compatible_id_show(struct config_item *item,\n\t\t\t\t\t\t char *page)\n{\n\tmemcpy(page, to_usb_os_desc(item)->ext_compat_id + 8, 8);\n\treturn 8;\n}\n\nstatic ssize_t interf_grp_sub_compatible_id_store(struct config_item *item,\n\t\t\t\t\t\t  const char *page, size_t len)\n{\n\tstruct usb_os_desc *desc = to_usb_os_desc(item);\n\tint l;\n\n\tl = min_t(int, 8, len);\n\tif (page[l - 1] == '\\n')\n\t\t--l;\n\tif (desc->opts_mutex)\n\t\tmutex_lock(desc->opts_mutex);\n\tmemcpy(desc->ext_compat_id + 8, page, l);\n\n\tif (desc->opts_mutex)\n\t\tmutex_unlock(desc->opts_mutex);\n\n\treturn len;\n}\n\nCONFIGFS_ATTR(interf_grp_, compatible_id);\nCONFIGFS_ATTR(interf_grp_, sub_compatible_id);\n\nstatic struct configfs_attribute *interf_grp_attrs[] = {\n\t&interf_grp_attr_compatible_id,\n\t&interf_grp_attr_sub_compatible_id,\n\tNULL\n};\n\nstruct config_group *usb_os_desc_prepare_interf_dir(\n\t\tstruct config_group *parent,\n\t\tint n_interf,\n\t\tstruct usb_os_desc **desc,\n\t\tchar **names,\n\t\tstruct module *owner)\n{\n\tstruct config_group *os_desc_group;\n\tstruct config_item_type *os_desc_type, *interface_type;\n\n\tvla_group(data_chunk);\n\tvla_item(data_chunk, struct config_group, os_desc_group, 1);\n\tvla_item(data_chunk, struct config_item_type, os_desc_type, 1);\n\tvla_item(data_chunk, struct config_item_type, interface_type, 1);\n\n\tchar *vlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);\n\tif (!vlabuf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tos_desc_group = vla_ptr(vlabuf, data_chunk, os_desc_group);\n\tos_desc_type = vla_ptr(vlabuf, data_chunk, os_desc_type);\n\tinterface_type = vla_ptr(vlabuf, data_chunk, interface_type);\n\n\tos_desc_type->ct_owner = owner;\n\tconfig_group_init_type_name(os_desc_group, \"os_desc\", os_desc_type);\n\tconfigfs_add_default_group(os_desc_group, parent);\n\n\tinterface_type->ct_group_ops = &interf_grp_ops;\n\tinterface_type->ct_attrs = interf_grp_attrs;\n\tinterface_type->ct_owner = owner;\n\n\twhile (n_interf--) {\n\t\tstruct usb_os_desc *d;\n\n\t\td = desc[n_interf];\n\t\td->owner = owner;\n\t\tconfig_group_init_type_name(&d->group, \"\", interface_type);\n\t\tconfig_item_set_name(&d->group.cg_item, \"interface.%s\",\n\t\t\t\t     names[n_interf]);\n\t\tconfigfs_add_default_group(&d->group, os_desc_group);\n\t}\n\n\treturn os_desc_group;\n}\nEXPORT_SYMBOL(usb_os_desc_prepare_interf_dir);\n\nstatic int configfs_do_nothing(struct usb_composite_dev *cdev)\n{\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nint composite_dev_prepare(struct usb_composite_driver *composite,\n\t\tstruct usb_composite_dev *dev);\n\nint composite_os_desc_req_prepare(struct usb_composite_dev *cdev,\n\t\t\t\t  struct usb_ep *ep0);\n\nstatic void purge_configs_funcs(struct gadget_info *gi)\n{\n\tstruct usb_configuration\t*c;\n\n\tlist_for_each_entry(c, &gi->cdev.configs, list) {\n\t\tstruct usb_function *f, *tmp;\n\t\tstruct config_usb_cfg *cfg;\n\n\t\tcfg = container_of(c, struct config_usb_cfg, c);\n\n\t\tlist_for_each_entry_safe_reverse(f, tmp, &c->functions, list) {\n\n\t\t\tlist_move(&f->list, &cfg->func_list);\n\t\t\tif (f->unbind) {\n\t\t\t\tdev_dbg(&gi->cdev.gadget->dev,\n\t\t\t\t\t\"unbind function '%s'/%p\\n\",\n\t\t\t\t\tf->name, f);\n\t\t\t\tf->unbind(c, f);\n\t\t\t}\n\t\t}\n\t\tc->next_interface_id = 0;\n\t\tmemset(c->interface, 0, sizeof(c->interface));\n\t\tc->superspeed_plus = 0;\n\t\tc->superspeed = 0;\n\t\tc->highspeed = 0;\n\t\tc->fullspeed = 0;\n\t}\n}\n\nstatic struct usb_string *\nconfigfs_attach_gadget_strings(struct gadget_info *gi)\n{\n\tstruct usb_gadget_strings **gadget_strings;\n\tstruct gadget_language *language;\n\tstruct gadget_string *string;\n\tunsigned int nlangs = 0;\n\tstruct list_head *iter;\n\tstruct usb_string *us;\n\tunsigned int i = 0;\n\tint nstrings = -1;\n\tunsigned int j;\n\n\tlist_for_each(iter, &gi->string_list)\n\t\tnlangs++;\n\n\t \n\tif (!nlangs)\n\t\treturn NULL;\n\n\tgadget_strings = kcalloc(nlangs + 1,  \n\t\t\t\t sizeof(struct usb_gadget_strings *), GFP_KERNEL);\n\tif (!gadget_strings)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlist_for_each_entry(language, &gi->string_list, list) {\n\t\tstruct usb_string *stringtab;\n\n\t\tif (nstrings == -1) {\n\t\t\tnstrings = language->nstrings;\n\t\t} else if (nstrings != language->nstrings) {\n\t\t\tpr_err(\"languages must contain the same number of strings\\n\");\n\t\t\tus = ERR_PTR(-EINVAL);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tstringtab = kcalloc(language->nstrings + 1, sizeof(struct usb_string),\n\t\t\t\t    GFP_KERNEL);\n\t\tif (!stringtab) {\n\t\t\tus = ERR_PTR(-ENOMEM);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tstringtab[USB_GADGET_MANUFACTURER_IDX].id = USB_GADGET_MANUFACTURER_IDX;\n\t\tstringtab[USB_GADGET_MANUFACTURER_IDX].s = language->manufacturer;\n\t\tstringtab[USB_GADGET_PRODUCT_IDX].id = USB_GADGET_PRODUCT_IDX;\n\t\tstringtab[USB_GADGET_PRODUCT_IDX].s = language->product;\n\t\tstringtab[USB_GADGET_SERIAL_IDX].id = USB_GADGET_SERIAL_IDX;\n\t\tstringtab[USB_GADGET_SERIAL_IDX].s = language->serialnumber;\n\n\t\tj = USB_GADGET_FIRST_AVAIL_IDX;\n\t\tlist_for_each_entry(string, &language->gadget_strings, list) {\n\t\t\tmemcpy(&stringtab[j], &string->usb_string, sizeof(struct usb_string));\n\t\t\tj++;\n\t\t}\n\n\t\tlanguage->stringtab_dev.strings = stringtab;\n\t\tgadget_strings[i] = &language->stringtab_dev;\n\t\ti++;\n\t}\n\n\tus = usb_gstrings_attach(&gi->cdev, gadget_strings, nstrings);\n\ncleanup:\n\tlist_for_each_entry(language, &gi->string_list, list) {\n\t\tkfree(language->stringtab_dev.strings);\n\t\tlanguage->stringtab_dev.strings = NULL;\n\t}\n\n\tkfree(gadget_strings);\n\n\treturn us;\n}\n\nstatic int configfs_composite_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *gdriver)\n{\n\tstruct usb_composite_driver     *composite = to_cdriver(gdriver);\n\tstruct gadget_info\t\t*gi = container_of(composite,\n\t\t\t\t\t\tstruct gadget_info, composite);\n\tstruct usb_composite_dev\t*cdev = &gi->cdev;\n\tstruct usb_configuration\t*c;\n\tstruct usb_string\t\t*s;\n\tunsigned\t\t\ti;\n\tint\t\t\t\tret;\n\n\t \n\tgi->unbind = 0;\n\tcdev->gadget = gadget;\n\tset_gadget_data(gadget, cdev);\n\tret = composite_dev_prepare(composite, cdev);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = -EINVAL;\n\n\tif (list_empty(&gi->cdev.configs)) {\n\t\tpr_err(\"Need at least one configuration in %s.\\n\",\n\t\t\t\tgi->composite.name);\n\t\tgoto err_comp_cleanup;\n\t}\n\n\n\tlist_for_each_entry(c, &gi->cdev.configs, list) {\n\t\tstruct config_usb_cfg *cfg;\n\n\t\tcfg = container_of(c, struct config_usb_cfg, c);\n\t\tif (list_empty(&cfg->func_list)) {\n\t\t\tpr_err(\"Config %s/%d of %s needs at least one function.\\n\",\n\t\t\t      c->label, c->bConfigurationValue,\n\t\t\t      gi->composite.name);\n\t\t\tgoto err_comp_cleanup;\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&gi->string_list)) {\n\t\ts = configfs_attach_gadget_strings(gi);\n\t\tif (IS_ERR(s)) {\n\t\t\tret = PTR_ERR(s);\n\t\t\tgoto err_comp_cleanup;\n\t\t}\n\n\t\tgi->cdev.desc.iManufacturer = s[USB_GADGET_MANUFACTURER_IDX].id;\n\t\tgi->cdev.desc.iProduct = s[USB_GADGET_PRODUCT_IDX].id;\n\t\tgi->cdev.desc.iSerialNumber = s[USB_GADGET_SERIAL_IDX].id;\n\n\t\tgi->cdev.usb_strings = s;\n\t}\n\n\tif (gi->use_webusb) {\n\t\tcdev->use_webusb = true;\n\t\tcdev->bcd_webusb_version = gi->bcd_webusb_version;\n\t\tcdev->b_webusb_vendor_code = gi->b_webusb_vendor_code;\n\t\tmemcpy(cdev->landing_page, gi->landing_page, WEBUSB_URL_RAW_MAX_LENGTH);\n\t}\n\n\tif (gi->use_os_desc) {\n\t\tcdev->use_os_string = true;\n\t\tcdev->b_vendor_code = gi->b_vendor_code;\n\t\tmemcpy(cdev->qw_sign, gi->qw_sign, OS_STRING_QW_SIGN_LEN);\n\t}\n\n\tif (gadget_is_otg(gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(gadget);\n\t\tif (!usb_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_comp_cleanup;\n\t\t}\n\t\tusb_otg_descriptor_init(gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\t \n\tlist_for_each_entry(c, &gi->cdev.configs, list) {\n\t\tstruct config_usb_cfg *cfg;\n\t\tstruct usb_function *f;\n\t\tstruct usb_function *tmp;\n\t\tstruct gadget_config_name *cn;\n\n\t\tif (gadget_is_otg(gadget))\n\t\t\tc->descriptors = otg_desc;\n\n\t\t \n\t\tcheck_remote_wakeup_config(gadget, c);\n\n\t\tcfg = container_of(c, struct config_usb_cfg, c);\n\t\tif (!list_empty(&cfg->string_list)) {\n\t\t\ti = 0;\n\t\t\tlist_for_each_entry(cn, &cfg->string_list, list) {\n\t\t\t\tcfg->gstrings[i] = &cn->stringtab_dev;\n\t\t\t\tcn->stringtab_dev.strings = &cn->strings;\n\t\t\t\tcn->strings.s = cn->configuration;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tcfg->gstrings[i] = NULL;\n\t\t\ts = usb_gstrings_attach(&gi->cdev, cfg->gstrings, 1);\n\t\t\tif (IS_ERR(s)) {\n\t\t\t\tret = PTR_ERR(s);\n\t\t\t\tgoto err_comp_cleanup;\n\t\t\t}\n\t\t\tc->iConfiguration = s[0].id;\n\t\t}\n\n\t\tlist_for_each_entry_safe(f, tmp, &cfg->func_list, list) {\n\t\t\tlist_del(&f->list);\n\t\t\tret = usb_add_function(c, f);\n\t\t\tif (ret) {\n\t\t\t\tlist_add(&f->list, &cfg->func_list);\n\t\t\t\tgoto err_purge_funcs;\n\t\t\t}\n\t\t}\n\t\tret = usb_gadget_check_config(cdev->gadget);\n\t\tif (ret)\n\t\t\tgoto err_purge_funcs;\n\n\t\tusb_ep_autoconfig_reset(cdev->gadget);\n\t}\n\tif (cdev->use_os_string) {\n\t\tret = composite_os_desc_req_prepare(cdev, gadget->ep0);\n\t\tif (ret)\n\t\t\tgoto err_purge_funcs;\n\t}\n\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\treturn 0;\n\nerr_purge_funcs:\n\tpurge_configs_funcs(gi);\nerr_comp_cleanup:\n\tcomposite_dev_cleanup(cdev);\n\treturn ret;\n}\n\nstatic void configfs_composite_unbind(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev\t*cdev;\n\tstruct gadget_info\t\t*gi;\n\tunsigned long flags;\n\n\t \n\n\tcdev = get_gadget_data(gadget);\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tgi->unbind = 1;\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\tpurge_configs_funcs(gi);\n\tcomposite_dev_cleanup(cdev);\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev->gadget = NULL;\n\tcdev->deactivations = 0;\n\tgadget->deactivated = false;\n\tset_gadget_data(gadget, NULL);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n}\n\nstatic int configfs_composite_setup(struct usb_gadget *gadget,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_composite_dev *cdev;\n\tstruct gadget_info *gi;\n\tunsigned long flags;\n\tint ret;\n\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev)\n\t\treturn 0;\n\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev || gi->unbind) {\n\t\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\t\treturn 0;\n\t}\n\n\tret = composite_setup(gadget, ctrl);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\treturn ret;\n}\n\nstatic void configfs_composite_disconnect(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev *cdev;\n\tstruct gadget_info *gi;\n\tunsigned long flags;\n\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev)\n\t\treturn;\n\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev || gi->unbind) {\n\t\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\t\treturn;\n\t}\n\n\tcomposite_disconnect(gadget);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n}\n\nstatic void configfs_composite_reset(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev *cdev;\n\tstruct gadget_info *gi;\n\tunsigned long flags;\n\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev)\n\t\treturn;\n\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev || gi->unbind) {\n\t\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\t\treturn;\n\t}\n\n\tcomposite_reset(gadget);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n}\n\nstatic void configfs_composite_suspend(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev *cdev;\n\tstruct gadget_info *gi;\n\tunsigned long flags;\n\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev)\n\t\treturn;\n\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev || gi->unbind) {\n\t\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\t\treturn;\n\t}\n\n\tcomposite_suspend(gadget);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n}\n\nstatic void configfs_composite_resume(struct usb_gadget *gadget)\n{\n\tstruct usb_composite_dev *cdev;\n\tstruct gadget_info *gi;\n\tunsigned long flags;\n\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev)\n\t\treturn;\n\n\tgi = container_of(cdev, struct gadget_info, cdev);\n\tspin_lock_irqsave(&gi->spinlock, flags);\n\tcdev = get_gadget_data(gadget);\n\tif (!cdev || gi->unbind) {\n\t\tspin_unlock_irqrestore(&gi->spinlock, flags);\n\t\treturn;\n\t}\n\n\tcomposite_resume(gadget);\n\tspin_unlock_irqrestore(&gi->spinlock, flags);\n}\n\nstatic const struct usb_gadget_driver configfs_driver_template = {\n\t.bind           = configfs_composite_bind,\n\t.unbind         = configfs_composite_unbind,\n\n\t.setup          = configfs_composite_setup,\n\t.reset          = configfs_composite_reset,\n\t.disconnect     = configfs_composite_disconnect,\n\n\t.suspend\t= configfs_composite_suspend,\n\t.resume\t\t= configfs_composite_resume,\n\n\t.max_speed\t= USB_SPEED_SUPER_PLUS,\n\t.driver = {\n\t\t.owner          = THIS_MODULE,\n\t},\n\t.match_existing_only = 1,\n};\n\nstatic struct config_group *gadgets_make(\n\t\tstruct config_group *group,\n\t\tconst char *name)\n{\n\tstruct gadget_info *gi;\n\n\tgi = kzalloc(sizeof(*gi), GFP_KERNEL);\n\tif (!gi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconfig_group_init_type_name(&gi->group, name, &gadget_root_type);\n\n\tconfig_group_init_type_name(&gi->functions_group, \"functions\",\n\t\t\t&functions_type);\n\tconfigfs_add_default_group(&gi->functions_group, &gi->group);\n\n\tconfig_group_init_type_name(&gi->configs_group, \"configs\",\n\t\t\t&config_desc_type);\n\tconfigfs_add_default_group(&gi->configs_group, &gi->group);\n\n\tconfig_group_init_type_name(&gi->strings_group, \"strings\",\n\t\t\t&gadget_language_strings_type);\n\tconfigfs_add_default_group(&gi->strings_group, &gi->group);\n\n\tconfig_group_init_type_name(&gi->os_desc_group, \"os_desc\",\n\t\t\t&os_desc_type);\n\tconfigfs_add_default_group(&gi->os_desc_group, &gi->group);\n\n\tconfig_group_init_type_name(&gi->webusb_group, \"webusb\",\n\t\t\t&webusb_type);\n\tconfigfs_add_default_group(&gi->webusb_group, &gi->group);\n\n\tgi->composite.bind = configfs_do_nothing;\n\tgi->composite.unbind = configfs_do_nothing;\n\tgi->composite.suspend = NULL;\n\tgi->composite.resume = NULL;\n\tgi->composite.max_speed = USB_SPEED_SUPER_PLUS;\n\n\tspin_lock_init(&gi->spinlock);\n\tmutex_init(&gi->lock);\n\tINIT_LIST_HEAD(&gi->string_list);\n\tINIT_LIST_HEAD(&gi->available_func);\n\n\tcomposite_init_dev(&gi->cdev);\n\tgi->cdev.desc.bLength = USB_DT_DEVICE_SIZE;\n\tgi->cdev.desc.bDescriptorType = USB_DT_DEVICE;\n\tgi->cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());\n\n\tgi->composite.gadget_driver = configfs_driver_template;\n\n\tgi->composite.gadget_driver.driver.name = kasprintf(GFP_KERNEL,\n\t\t\t\t\t\t\t    \"configfs-gadget.%s\", name);\n\tif (!gi->composite.gadget_driver.driver.name)\n\t\tgoto err;\n\n\tgi->composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);\n\tgi->composite.name = gi->composite.gadget_driver.function;\n\n\tif (!gi->composite.gadget_driver.function)\n\t\tgoto out_free_driver_name;\n\n\treturn &gi->group;\n\nout_free_driver_name:\n\tkfree(gi->composite.gadget_driver.driver.name);\nerr:\n\tkfree(gi);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void gadgets_drop(struct config_group *group, struct config_item *item)\n{\n\tconfig_item_put(item);\n}\n\nstatic struct configfs_group_operations gadgets_ops = {\n\t.make_group     = &gadgets_make,\n\t.drop_item      = &gadgets_drop,\n};\n\nstatic const struct config_item_type gadgets_type = {\n\t.ct_group_ops   = &gadgets_ops,\n\t.ct_owner       = THIS_MODULE,\n};\n\nstatic struct configfs_subsystem gadget_subsys = {\n\t.su_group = {\n\t\t.cg_item = {\n\t\t\t.ci_namebuf = \"usb_gadget\",\n\t\t\t.ci_type = &gadgets_type,\n\t\t},\n\t},\n\t.su_mutex = __MUTEX_INITIALIZER(gadget_subsys.su_mutex),\n};\n\nvoid unregister_gadget_item(struct config_item *item)\n{\n\tstruct gadget_info *gi = to_gadget_info(item);\n\n\tmutex_lock(&gi->lock);\n\tunregister_gadget(gi);\n\tmutex_unlock(&gi->lock);\n}\nEXPORT_SYMBOL_GPL(unregister_gadget_item);\n\nstatic int __init gadget_cfs_init(void)\n{\n\tint ret;\n\n\tconfig_group_init(&gadget_subsys.su_group);\n\n\tret = configfs_register_subsystem(&gadget_subsys);\n\treturn ret;\n}\nmodule_init(gadget_cfs_init);\n\nstatic void __exit gadget_cfs_exit(void)\n{\n\tconfigfs_unregister_subsystem(&gadget_subsys);\n}\nmodule_exit(gadget_cfs_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}