{
  "module_name": "max3420_udc.c",
  "hash_id": "561637f024f2a5547c11eae1642c6bd0053893d6f17341b2198b1aa690a2a127",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/max3420_udc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/bitfield.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/prefetch.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/spi/spi.h>\n#include <linux/gpio/consumer.h>\n\n#define MAX3420_MAX_EPS\t\t4\n#define MAX3420_EP_MAX_PACKET\t\t64   \n#define MAX3420_EPNAME_SIZE\t\t16   \n\n#define MAX3420_ACKSTAT\t\tBIT(0)\n\n#define MAX3420_SPI_DIR_RD\t0\t \n#define MAX3420_SPI_DIR_WR\t1\t \n\n \n#define MAX3420_SPI_DIR_SHIFT\t1\n#define MAX3420_SPI_REG_SHIFT\t3\n\n#define MAX3420_REG_EP0FIFO\t0\n#define MAX3420_REG_EP1FIFO\t1\n#define MAX3420_REG_EP2FIFO\t2\n#define MAX3420_REG_EP3FIFO\t3\n#define MAX3420_REG_SUDFIFO\t4\n#define MAX3420_REG_EP0BC\t5\n#define MAX3420_REG_EP1BC\t6\n#define MAX3420_REG_EP2BC\t7\n#define MAX3420_REG_EP3BC\t8\n\n#define MAX3420_REG_EPSTALLS\t9\n\t#define ACKSTAT\t\tBIT(6)\n\t#define STLSTAT\t\tBIT(5)\n\t#define STLEP3IN\tBIT(4)\n\t#define STLEP2IN\tBIT(3)\n\t#define STLEP1OUT\tBIT(2)\n\t#define STLEP0OUT\tBIT(1)\n\t#define STLEP0IN\tBIT(0)\n\n#define MAX3420_REG_CLRTOGS\t10\n\t#define EP3DISAB\tBIT(7)\n\t#define EP2DISAB\tBIT(6)\n\t#define EP1DISAB\tBIT(5)\n\t#define CTGEP3IN\tBIT(4)\n\t#define CTGEP2IN\tBIT(3)\n\t#define CTGEP1OUT\tBIT(2)\n\n#define MAX3420_REG_EPIRQ\t11\n#define MAX3420_REG_EPIEN\t12\n\t#define SUDAVIRQ\tBIT(5)\n\t#define IN3BAVIRQ\tBIT(4)\n\t#define IN2BAVIRQ\tBIT(3)\n\t#define OUT1DAVIRQ\tBIT(2)\n\t#define OUT0DAVIRQ\tBIT(1)\n\t#define IN0BAVIRQ\tBIT(0)\n\n#define MAX3420_REG_USBIRQ\t13\n#define MAX3420_REG_USBIEN\t14\n\t#define OSCOKIRQ\tBIT(0)\n\t#define RWUDNIRQ\tBIT(1)\n\t#define BUSACTIRQ\tBIT(2)\n\t#define URESIRQ\t\tBIT(3)\n\t#define SUSPIRQ\t\tBIT(4)\n\t#define NOVBUSIRQ\tBIT(5)\n\t#define VBUSIRQ\t\tBIT(6)\n\t#define URESDNIRQ\tBIT(7)\n\n#define MAX3420_REG_USBCTL\t15\n\t#define HOSCSTEN\tBIT(7)\n\t#define VBGATE\t\tBIT(6)\n\t#define CHIPRES\t\tBIT(5)\n\t#define PWRDOWN\t\tBIT(4)\n\t#define CONNECT\t\tBIT(3)\n\t#define SIGRWU\t\tBIT(2)\n\n#define MAX3420_REG_CPUCTL\t16\n\t#define IE\t\tBIT(0)\n\n#define MAX3420_REG_PINCTL\t17\n\t#define EP3INAK\t\tBIT(7)\n\t#define EP2INAK\t\tBIT(6)\n\t#define EP0INAK\t\tBIT(5)\n\t#define FDUPSPI\t\tBIT(4)\n\t#define INTLEVEL\tBIT(3)\n\t#define POSINT\t\tBIT(2)\n\t#define GPXB\t\tBIT(1)\n\t#define GPXA\t\tBIT(0)\n\n#define MAX3420_REG_REVISION\t18\n\n#define MAX3420_REG_FNADDR\t19\n\t#define FNADDR_MASK\t0x7f\n\n#define MAX3420_REG_IOPINS\t20\n#define MAX3420_REG_IOPINS2\t21\n#define MAX3420_REG_GPINIRQ\t22\n#define MAX3420_REG_GPINIEN\t23\n#define MAX3420_REG_GPINPOL\t24\n#define MAX3420_REG_HIRQ\t25\n#define MAX3420_REG_HIEN\t26\n#define MAX3420_REG_MODE\t27\n#define MAX3420_REG_PERADDR\t28\n#define MAX3420_REG_HCTL\t29\n#define MAX3420_REG_HXFR\t30\n#define MAX3420_REG_HRSL\t31\n\n#define ENABLE_IRQ\tBIT(0)\n#define IOPIN_UPDATE\tBIT(1)\n#define REMOTE_WAKEUP\tBIT(2)\n#define CONNECT_HOST\tGENMASK(4, 3)\n#define\tHCONNECT\t(1 << 3)\n#define\tHDISCONNECT\t(3 << 3)\n#define UDC_START\tGENMASK(6, 5)\n#define\tSTART\t\t(1 << 5)\n#define\tSTOP\t\t(3 << 5)\n#define ENABLE_EP\tGENMASK(8, 7)\n#define\tENABLE\t\t(1 << 7)\n#define\tDISABLE\t\t(3 << 7)\n#define STALL_EP\tGENMASK(10, 9)\n#define\tSTALL\t\t(1 << 9)\n#define\tUNSTALL\t\t(3 << 9)\n\n#define MAX3420_CMD(c)\t\tFIELD_PREP(GENMASK(7, 3), c)\n#define MAX3420_SPI_CMD_RD(c)\t(MAX3420_CMD(c) | (0 << 1))\n#define MAX3420_SPI_CMD_WR(c)\t(MAX3420_CMD(c) | (1 << 1))\n\nstruct max3420_req {\n\tstruct usb_request usb_req;\n\tstruct list_head queue;\n\tstruct max3420_ep *ep;\n};\n\nstruct max3420_ep {\n\tstruct usb_ep ep_usb;\n\tstruct max3420_udc *udc;\n\tstruct list_head queue;\n\tchar name[MAX3420_EPNAME_SIZE];\n\tunsigned int maxpacket;\n\tspinlock_t lock;\n\tint halted;\n\tu32 todo;\n\tint id;\n};\n\nstruct max3420_udc {\n\tstruct usb_gadget gadget;\n\tstruct max3420_ep ep[MAX3420_MAX_EPS];\n\tstruct usb_gadget_driver *driver;\n\tstruct task_struct *thread_task;\n\tint remote_wkp, is_selfpowered;\n\tbool vbus_active, softconnect;\n\tstruct usb_ctrlrequest setup;\n\tstruct mutex spi_bus_mutex;\n\tstruct max3420_req ep0req;\n\tstruct spi_device *spi;\n\tstruct device *dev;\n\tspinlock_t lock;\n\tbool suspended;\n\tu8 ep0buf[64];\n\tu32 todo;\n};\n\n#define to_max3420_req(r)\tcontainer_of((r), struct max3420_req, usb_req)\n#define to_max3420_ep(e)\tcontainer_of((e), struct max3420_ep, ep_usb)\n#define to_udc(g)\t\tcontainer_of((g), struct max3420_udc, gadget)\n\n#define DRIVER_DESC     \"MAX3420 USB Device-Mode Driver\"\nstatic const char driver_name[] = \"max3420-udc\";\n\n \nstatic const struct usb_endpoint_descriptor ep0_desc = {\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize\t\t= cpu_to_le16(MAX3420_EP_MAX_PACKET),\n};\n\nstatic void spi_ack_ctrl(struct max3420_udc *udc)\n{\n\tstruct spi_device *spi = udc->spi;\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\tu8 txdata[1];\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\ttxdata[0] = MAX3420_ACKSTAT;\n\ttransfer.tx_buf = txdata;\n\ttransfer.len = 1;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic u8 spi_rd8_ack(struct max3420_udc *udc, u8 reg, int actstat)\n{\n\tstruct spi_device *spi = udc->spi;\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\tu8 txdata[2], rxdata[2];\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\ttxdata[0] = MAX3420_SPI_CMD_RD(reg) | (actstat ? MAX3420_ACKSTAT : 0);\n\ttransfer.tx_buf = txdata;\n\ttransfer.rx_buf = rxdata;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n\n\treturn rxdata[1];\n}\n\nstatic u8 spi_rd8(struct max3420_udc *udc, u8 reg)\n{\n\treturn spi_rd8_ack(udc, reg, 0);\n}\n\nstatic void spi_wr8_ack(struct max3420_udc *udc, u8 reg, u8 val, int actstat)\n{\n\tstruct spi_device *spi = udc->spi;\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\tu8 txdata[2];\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\ttxdata[0] = MAX3420_SPI_CMD_WR(reg) | (actstat ? MAX3420_ACKSTAT : 0);\n\ttxdata[1] = val;\n\n\ttransfer.tx_buf = txdata;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void spi_wr8(struct max3420_udc *udc, u8 reg, u8 val)\n{\n\tspi_wr8_ack(udc, reg, val, 0);\n}\n\nstatic void spi_rd_buf(struct max3420_udc *udc, u8 reg, void *buf, u8 len)\n{\n\tstruct spi_device *spi = udc->spi;\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\tu8 local_buf[MAX3420_EP_MAX_PACKET + 1] = {};\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tlocal_buf[0] = MAX3420_SPI_CMD_RD(reg);\n\ttransfer.tx_buf = &local_buf[0];\n\ttransfer.rx_buf = &local_buf[0];\n\ttransfer.len = len + 1;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n\n\tmemcpy(buf, &local_buf[1], len);\n}\n\nstatic void spi_wr_buf(struct max3420_udc *udc, u8 reg, void *buf, u8 len)\n{\n\tstruct spi_device *spi = udc->spi;\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\tu8 local_buf[MAX3420_EP_MAX_PACKET + 1] = {};\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tlocal_buf[0] = MAX3420_SPI_CMD_WR(reg);\n\tmemcpy(&local_buf[1], buf, len);\n\n\ttransfer.tx_buf = local_buf;\n\ttransfer.len = len + 1;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic int spi_max3420_enable(struct max3420_ep *ep)\n{\n\tstruct max3420_udc *udc = ep->udc;\n\tunsigned long flags;\n\tu8 epdis, epien;\n\tint todo;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\ttodo = ep->todo & ENABLE_EP;\n\tep->todo &= ~ENABLE_EP;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!todo || ep->id == 0)\n\t\treturn false;\n\n\tepien = spi_rd8(udc, MAX3420_REG_EPIEN);\n\tepdis = spi_rd8(udc, MAX3420_REG_CLRTOGS);\n\n\tif (todo == ENABLE) {\n\t\tepdis &= ~BIT(ep->id + 4);\n\t\tepien |= BIT(ep->id + 1);\n\t} else {\n\t\tepdis |= BIT(ep->id + 4);\n\t\tepien &= ~BIT(ep->id + 1);\n\t}\n\n\tspi_wr8(udc, MAX3420_REG_CLRTOGS, epdis);\n\tspi_wr8(udc, MAX3420_REG_EPIEN, epien);\n\n\treturn true;\n}\n\nstatic int spi_max3420_stall(struct max3420_ep *ep)\n{\n\tstruct max3420_udc *udc = ep->udc;\n\tunsigned long flags;\n\tu8 epstalls;\n\tint todo;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\ttodo = ep->todo & STALL_EP;\n\tep->todo &= ~STALL_EP;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!todo || ep->id == 0)\n\t\treturn false;\n\n\tepstalls = spi_rd8(udc, MAX3420_REG_EPSTALLS);\n\tif (todo == STALL) {\n\t\tep->halted = 1;\n\t\tepstalls |= BIT(ep->id + 1);\n\t} else {\n\t\tu8 clrtogs;\n\n\t\tep->halted = 0;\n\t\tepstalls &= ~BIT(ep->id + 1);\n\t\tclrtogs = spi_rd8(udc, MAX3420_REG_CLRTOGS);\n\t\tclrtogs |= BIT(ep->id + 1);\n\t\tspi_wr8(udc, MAX3420_REG_CLRTOGS, clrtogs);\n\t}\n\tspi_wr8(udc, MAX3420_REG_EPSTALLS, epstalls | ACKSTAT);\n\n\treturn true;\n}\n\nstatic int spi_max3420_rwkup(struct max3420_udc *udc)\n{\n\tunsigned long flags;\n\tint wake_remote;\n\tu8 usbctl;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\twake_remote = udc->todo & REMOTE_WAKEUP;\n\tudc->todo &= ~REMOTE_WAKEUP;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (!wake_remote || !udc->suspended)\n\t\treturn false;\n\n\t \n\tusbctl = spi_rd8(udc, MAX3420_REG_USBCTL);\n\tusbctl |= SIGRWU;\n\tspi_wr8(udc, MAX3420_REG_USBCTL, usbctl);\n\n\tmsleep_interruptible(5);\n\n\t \n\tusbctl = spi_rd8(udc, MAX3420_REG_USBCTL);\n\tusbctl &= ~SIGRWU;\n\tspi_wr8(udc, MAX3420_REG_USBCTL, usbctl);\n\n\tudc->suspended = false;\n\n\treturn true;\n}\n\nstatic void max3420_nuke(struct max3420_ep *ep, int status);\nstatic void __max3420_stop(struct max3420_udc *udc)\n{\n\tu8 val;\n\tint i;\n\n\t \n\tfor (i = 1; i < MAX3420_MAX_EPS; i++)\n\t\tmax3420_nuke(&udc->ep[i], -ECONNRESET);\n\n\t \n\tspi_wr8(udc, MAX3420_REG_CPUCTL, 0);\n\n\tval = spi_rd8(udc, MAX3420_REG_USBCTL);\n\tval |= PWRDOWN;\n\tif (udc->is_selfpowered)\n\t\tval &= ~HOSCSTEN;\n\telse\n\t\tval |= HOSCSTEN;\n\tspi_wr8(udc, MAX3420_REG_USBCTL, val);\n}\n\nstatic void __max3420_start(struct max3420_udc *udc)\n{\n\tu8 val;\n\n\t \n\tmsleep_interruptible(250);\n\n\t \n\tspi_wr8(udc, MAX3420_REG_PINCTL, FDUPSPI);\n\n\t \n\tspi_wr8(udc, MAX3420_REG_USBCTL, CHIPRES);\n\tmsleep_interruptible(5);\n\tspi_wr8(udc, MAX3420_REG_USBCTL, 0);\n\n\t \n\twhile (1) {\n\t\tval = spi_rd8(udc, MAX3420_REG_USBIRQ);\n\t\tif (val & OSCOKIRQ)\n\t\t\tbreak;\n\t\tcond_resched();\n\t}\n\n\t \n\tval = spi_rd8(udc, MAX3420_REG_USBCTL);\n\tval |= VBGATE | CONNECT;\n\tspi_wr8(udc, MAX3420_REG_USBCTL, val);\n\n\tval = URESDNIRQ | URESIRQ;\n\tif (udc->is_selfpowered)\n\t\tval |= NOVBUSIRQ;\n\tspi_wr8(udc, MAX3420_REG_USBIEN, val);\n\n\t \n\tval = IN0BAVIRQ | OUT0DAVIRQ | SUDAVIRQ;\n\tspi_wr8(udc, MAX3420_REG_EPIEN, val);\n\n\t \n\tspi_wr8(udc, MAX3420_REG_CPUCTL, IE);\n}\n\nstatic int max3420_start(struct max3420_udc *udc)\n{\n\tunsigned long flags;\n\tint todo;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\ttodo = udc->todo & UDC_START;\n\tudc->todo &= ~UDC_START;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (!todo)\n\t\treturn false;\n\n\tif (udc->vbus_active && udc->softconnect)\n\t\t__max3420_start(udc);\n\telse\n\t\t__max3420_stop(udc);\n\n\treturn true;\n}\n\nstatic irqreturn_t max3420_vbus_handler(int irq, void *dev_id)\n{\n\tstruct max3420_udc *udc = dev_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tudc->vbus_active = !udc->vbus_active;\n\tudc->todo |= UDC_START;\n\tusb_udc_vbus_handler(&udc->gadget, udc->vbus_active);\n\tusb_gadget_set_state(&udc->gadget, udc->vbus_active\n\t\t\t     ? USB_STATE_POWERED : USB_STATE_NOTATTACHED);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->thread_task)\n\t\twake_up_process(udc->thread_task);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t max3420_irq_handler(int irq, void *dev_id)\n{\n\tstruct max3420_udc *udc = dev_id;\n\tstruct spi_device *spi = udc->spi;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif ((udc->todo & ENABLE_IRQ) == 0) {\n\t\tdisable_irq_nosync(spi->irq);\n\t\tudc->todo |= ENABLE_IRQ;\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->thread_task)\n\t\twake_up_process(udc->thread_task);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void max3420_getstatus(struct max3420_udc *udc)\n{\n\tstruct max3420_ep *ep;\n\tu16 status = 0;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t \n\t\tstatus = udc->gadget.is_selfpowered << USB_DEVICE_SELF_POWERED;\n\t\tstatus |= (udc->remote_wkp << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tif (udc->driver->setup(&udc->gadget, &udc->setup) < 0)\n\t\t\tgoto stall;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = &udc->ep[udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK];\n\t\tif (udc->setup.wIndex & USB_DIR_IN) {\n\t\t\tif (!ep->ep_usb.caps.dir_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (!ep->ep_usb.caps.dir_out)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (ep->halted)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\tstatus = cpu_to_le16(status);\n\tspi_wr_buf(udc, MAX3420_REG_EP0FIFO, &status, 2);\n\tspi_wr8_ack(udc, MAX3420_REG_EP0BC, 2, 1);\n\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\tspi_wr8(udc, MAX3420_REG_EPSTALLS, STLEP0IN | STLEP0OUT | STLSTAT);\n}\n\nstatic void max3420_set_clear_feature(struct max3420_udc *udc)\n{\n\tstruct max3420_ep *ep;\n\tint set = udc->setup.bRequest == USB_REQ_SET_FEATURE;\n\tunsigned long flags;\n\tint id;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tif (udc->setup.wValue != USB_DEVICE_REMOTE_WAKEUP)\n\t\t\tbreak;\n\n\t\tif (udc->setup.bRequest == USB_REQ_SET_FEATURE)\n\t\t\tudc->remote_wkp = 1;\n\t\telse\n\t\t\tudc->remote_wkp = 0;\n\n\t\treturn spi_ack_ctrl(udc);\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (udc->setup.wValue != USB_ENDPOINT_HALT)\n\t\t\tbreak;\n\n\t\tid = udc->setup.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tep = &udc->ep[id];\n\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tep->todo &= ~STALL_EP;\n\t\tif (set)\n\t\t\tep->todo |= STALL;\n\t\telse\n\t\t\tep->todo |= UNSTALL;\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t\tspi_max3420_stall(ep);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\tspi_wr8(udc, MAX3420_REG_EPSTALLS, STLEP0IN | STLEP0OUT | STLSTAT);\n}\n\nstatic void max3420_handle_setup(struct max3420_udc *udc)\n{\n\tstruct usb_ctrlrequest setup;\n\n\tspi_rd_buf(udc, MAX3420_REG_SUDFIFO, (void *)&setup, 8);\n\n\tudc->setup = setup;\n\tudc->setup.wValue = cpu_to_le16(setup.wValue);\n\tudc->setup.wIndex = cpu_to_le16(setup.wIndex);\n\tudc->setup.wLength = cpu_to_le16(setup.wLength);\n\n\tswitch (udc->setup.bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t \n\t\tif ((udc->setup.bRequestType &\n\t\t\t\t(USB_DIR_IN | USB_TYPE_MASK)) !=\n\t\t\t\t(USB_DIR_IN | USB_TYPE_STANDARD)) {\n\t\t\tbreak;\n\t\t}\n\t\treturn max3420_getstatus(udc);\n\tcase USB_REQ_SET_ADDRESS:\n\t\t \n\t\tif (udc->setup.bRequestType != (USB_DIR_OUT |\n\t\t\t\tUSB_TYPE_STANDARD | USB_RECIP_DEVICE)) {\n\t\t\tbreak;\n\t\t}\n\t\tspi_rd8_ack(udc, MAX3420_REG_FNADDR, 1);\n\t\tdev_dbg(udc->dev, \"Assigned Address=%d\\n\", udc->setup.wValue);\n\t\treturn;\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t \n\t\tif ((udc->setup.bRequestType & USB_TYPE_MASK)\n\t\t\t\t!= USB_TYPE_STANDARD)\n\t\t\tbreak;\n\t\treturn max3420_set_clear_feature(udc);\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (udc->driver->setup(&udc->gadget, &setup) < 0) {\n\t\t \n\t\tspi_wr8(udc, MAX3420_REG_EPSTALLS,\n\t\t\tSTLEP0IN | STLEP0OUT | STLSTAT);\n\t}\n}\n\nstatic void max3420_req_done(struct max3420_req *req, int status)\n{\n\tstruct max3420_ep *ep = req->ep;\n\tstruct max3420_udc *udc = ep->udc;\n\n\tif (req->usb_req.status == -EINPROGRESS)\n\t\treq->usb_req.status = status;\n\telse\n\t\tstatus = req->usb_req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tdev_err(udc->dev, \"%s done %p, status %d\\n\",\n\t\t\tep->ep_usb.name, req, status);\n\n\tif (req->usb_req.complete)\n\t\treq->usb_req.complete(&ep->ep_usb, &req->usb_req);\n}\n\nstatic int max3420_do_data(struct max3420_udc *udc, int ep_id, int in)\n{\n\tstruct max3420_ep *ep = &udc->ep[ep_id];\n\tstruct max3420_req *req;\n\tint done, length, psz;\n\tvoid *buf;\n\n\tif (list_empty(&ep->queue))\n\t\treturn false;\n\n\treq = list_first_entry(&ep->queue, struct max3420_req, queue);\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\n\tpsz = ep->ep_usb.maxpacket;\n\tlength = req->usb_req.length - req->usb_req.actual;\n\tlength = min(length, psz);\n\n\tif (length == 0) {\n\t\tdone = 1;\n\t\tgoto xfer_done;\n\t}\n\n\tdone = 0;\n\tif (in) {\n\t\tprefetch(buf);\n\t\tspi_wr_buf(udc, MAX3420_REG_EP0FIFO + ep_id, buf, length);\n\t\tspi_wr8(udc, MAX3420_REG_EP0BC + ep_id, length);\n\t\tif (length < psz)\n\t\t\tdone = 1;\n\t} else {\n\t\tpsz = spi_rd8(udc, MAX3420_REG_EP0BC + ep_id);\n\t\tlength = min(length, psz);\n\t\tprefetchw(buf);\n\t\tspi_rd_buf(udc, MAX3420_REG_EP0FIFO + ep_id, buf, length);\n\t\tif (length < ep->ep_usb.maxpacket)\n\t\t\tdone = 1;\n\t}\n\n\treq->usb_req.actual += length;\n\n\tif (req->usb_req.actual == req->usb_req.length)\n\t\tdone = 1;\n\nxfer_done:\n\tif (done) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tlist_del_init(&req->queue);\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t\tif (ep_id == 0)\n\t\t\tspi_ack_ctrl(udc);\n\n\t\tmax3420_req_done(req, 0);\n\t}\n\n\treturn true;\n}\n\nstatic int max3420_handle_irqs(struct max3420_udc *udc)\n{\n\tu8 epien, epirq, usbirq, usbien, reg[4];\n\tbool ret = false;\n\n\tspi_rd_buf(udc, MAX3420_REG_EPIRQ, reg, 4);\n\tepirq = reg[0];\n\tepien = reg[1];\n\tusbirq = reg[2];\n\tusbien = reg[3];\n\n\tusbirq &= usbien;\n\tepirq &= epien;\n\n\tif (epirq & SUDAVIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_EPIRQ, SUDAVIRQ);\n\t\tmax3420_handle_setup(udc);\n\t\treturn true;\n\t}\n\n\tif (usbirq & VBUSIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, VBUSIRQ);\n\t\tdev_dbg(udc->dev, \"Cable plugged in\\n\");\n\t\treturn true;\n\t}\n\n\tif (usbirq & NOVBUSIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, NOVBUSIRQ);\n\t\tdev_dbg(udc->dev, \"Cable pulled out\\n\");\n\t\treturn true;\n\t}\n\n\tif (usbirq & URESIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, URESIRQ);\n\t\tdev_dbg(udc->dev, \"USB Reset - Start\\n\");\n\t\treturn true;\n\t}\n\n\tif (usbirq & URESDNIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, URESDNIRQ);\n\t\tdev_dbg(udc->dev, \"USB Reset - END\\n\");\n\t\tspi_wr8(udc, MAX3420_REG_USBIEN, URESDNIRQ | URESIRQ);\n\t\tspi_wr8(udc, MAX3420_REG_EPIEN, SUDAVIRQ | IN0BAVIRQ\n\t\t\t| OUT0DAVIRQ);\n\t\treturn true;\n\t}\n\n\tif (usbirq & SUSPIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, SUSPIRQ);\n\t\tdev_dbg(udc->dev, \"USB Suspend - Enter\\n\");\n\t\tudc->suspended = true;\n\t\treturn true;\n\t}\n\n\tif (usbirq & BUSACTIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, BUSACTIRQ);\n\t\tdev_dbg(udc->dev, \"USB Suspend - Exit\\n\");\n\t\tudc->suspended = false;\n\t\treturn true;\n\t}\n\n\tif (usbirq & RWUDNIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, RWUDNIRQ);\n\t\tdev_dbg(udc->dev, \"Asked Host to wakeup\\n\");\n\t\treturn true;\n\t}\n\n\tif (usbirq & OSCOKIRQ) {\n\t\tspi_wr8(udc, MAX3420_REG_USBIRQ, OSCOKIRQ);\n\t\tdev_dbg(udc->dev, \"Osc stabilized, start work\\n\");\n\t\treturn true;\n\t}\n\n\tif (epirq & OUT0DAVIRQ && max3420_do_data(udc, 0, 0)) {\n\t\tspi_wr8_ack(udc, MAX3420_REG_EPIRQ, OUT0DAVIRQ, 1);\n\t\tret = true;\n\t}\n\n\tif (epirq & IN0BAVIRQ && max3420_do_data(udc, 0, 1))\n\t\tret = true;\n\n\tif (epirq & OUT1DAVIRQ && max3420_do_data(udc, 1, 0)) {\n\t\tspi_wr8_ack(udc, MAX3420_REG_EPIRQ, OUT1DAVIRQ, 1);\n\t\tret = true;\n\t}\n\n\tif (epirq & IN2BAVIRQ && max3420_do_data(udc, 2, 1))\n\t\tret = true;\n\n\tif (epirq & IN3BAVIRQ && max3420_do_data(udc, 3, 1))\n\t\tret = true;\n\n\treturn ret;\n}\n\nstatic int max3420_thread(void *dev_id)\n{\n\tstruct max3420_udc *udc = dev_id;\n\tstruct spi_device *spi = udc->spi;\n\tint i, loop_again = 1;\n\tunsigned long flags;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (!loop_again) {\n\t\t\tktime_t kt = ns_to_ktime(1000 * 1000 * 250);  \n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\n\t\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\t\tif (udc->todo & ENABLE_IRQ) {\n\t\t\t\tenable_irq(spi->irq);\n\t\t\t\tudc->todo &= ~ENABLE_IRQ;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\t\t\tschedule_hrtimeout(&kt, HRTIMER_MODE_REL);\n\t\t}\n\t\tloop_again = 0;\n\n\t\tmutex_lock(&udc->spi_bus_mutex);\n\n\t\t \n\t\tif (!udc->vbus_active || !udc->softconnect)\n\t\t\tgoto loop;\n\n\t\tif (max3420_start(udc)) {\n\t\t\tloop_again = 1;\n\t\t\tgoto loop;\n\t\t}\n\n\t\tif (max3420_handle_irqs(udc)) {\n\t\t\tloop_again = 1;\n\t\t\tgoto loop;\n\t\t}\n\n\t\tif (spi_max3420_rwkup(udc)) {\n\t\t\tloop_again = 1;\n\t\t\tgoto loop;\n\t\t}\n\n\t\tmax3420_do_data(udc, 0, 1);  \n\n\t\tfor (i = 1; i < MAX3420_MAX_EPS; i++) {\n\t\t\tstruct max3420_ep *ep = &udc->ep[i];\n\n\t\t\tif (spi_max3420_enable(ep))\n\t\t\t\tloop_again = 1;\n\t\t\tif (spi_max3420_stall(ep))\n\t\t\t\tloop_again = 1;\n\t\t}\nloop:\n\t\tmutex_unlock(&udc->spi_bus_mutex);\n\t}\n\n\tset_current_state(TASK_RUNNING);\n\tdev_info(udc->dev, \"SPI thread exiting\\n\");\n\treturn 0;\n}\n\nstatic int max3420_ep_set_halt(struct usb_ep *_ep, int stall)\n{\n\tstruct max3420_ep *ep = to_max3420_ep(_ep);\n\tstruct max3420_udc *udc = ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tep->todo &= ~STALL_EP;\n\tif (stall)\n\t\tep->todo |= STALL;\n\telse\n\t\tep->todo |= UNSTALL;\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twake_up_process(udc->thread_task);\n\n\tdev_dbg(udc->dev, \"%sStall %s\\n\", stall ? \"\" : \"Un\", ep->name);\n\treturn 0;\n}\n\nstatic int __max3420_ep_enable(struct max3420_ep *ep,\n\t\t\t       const struct usb_endpoint_descriptor *desc)\n{\n\tunsigned int maxp = usb_endpoint_maxp(desc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tep->ep_usb.desc = desc;\n\tep->ep_usb.maxpacket = maxp;\n\n\tep->todo &= ~ENABLE_EP;\n\tep->todo |= ENABLE;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\treturn 0;\n}\n\nstatic int max3420_ep_enable(struct usb_ep *_ep,\n\t\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct max3420_ep *ep = to_max3420_ep(_ep);\n\tstruct max3420_udc *udc = ep->udc;\n\n\t__max3420_ep_enable(ep, desc);\n\n\twake_up_process(udc->thread_task);\n\n\treturn 0;\n}\n\nstatic void max3420_nuke(struct max3420_ep *ep, int status)\n{\n\tstruct max3420_req *req, *r;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tlist_for_each_entry_safe(req, r, &ep->queue, queue) {\n\t\tlist_del_init(&req->queue);\n\n\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\tmax3420_req_done(req, status);\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\nstatic void __max3420_ep_disable(struct max3420_ep *ep)\n{\n\tstruct max3420_udc *udc = ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tep->ep_usb.desc = NULL;\n\n\tep->todo &= ~ENABLE_EP;\n\tep->todo |= DISABLE;\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tdev_dbg(udc->dev, \"Disabled %s\\n\", ep->name);\n}\n\nstatic int max3420_ep_disable(struct usb_ep *_ep)\n{\n\tstruct max3420_ep *ep = to_max3420_ep(_ep);\n\tstruct max3420_udc *udc = ep->udc;\n\n\tmax3420_nuke(ep, -ESHUTDOWN);\n\n\t__max3420_ep_disable(ep);\n\n\twake_up_process(udc->thread_task);\n\n\treturn 0;\n}\n\nstatic struct usb_request *max3420_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct max3420_ep *ep = to_max3420_ep(_ep);\n\tstruct max3420_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->ep = ep;\n\n\treturn &req->usb_req;\n}\n\nstatic void max3420_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tkfree(to_max3420_req(_req));\n}\n\nstatic int max3420_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t    gfp_t ignored)\n{\n\tstruct max3420_req *req = to_max3420_req(_req);\n\tstruct max3420_ep *ep  = to_max3420_ep(_ep);\n\tstruct max3420_udc *udc = ep->udc;\n\tunsigned long flags;\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_add_tail(&req->queue, &ep->queue);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twake_up_process(udc->thread_task);\n\treturn 0;\n}\n\nstatic int max3420_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct max3420_req *t = NULL;\n\tstruct max3420_req *req = to_max3420_req(_req);\n\tstruct max3420_req *iter;\n\tstruct max3420_ep *ep = to_max3420_ep(_ep);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (iter != req)\n\t\t\tcontinue;\n\t\tlist_del_init(&req->queue);\n\t\tt = iter;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (t)\n\t\tmax3420_req_done(req, -ECONNRESET);\n\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops max3420_ep_ops = {\n\t.enable\t\t= max3420_ep_enable,\n\t.disable\t= max3420_ep_disable,\n\t.alloc_request\t= max3420_alloc_request,\n\t.free_request\t= max3420_free_request,\n\t.queue\t\t= max3420_ep_queue,\n\t.dequeue\t= max3420_ep_dequeue,\n\t.set_halt\t= max3420_ep_set_halt,\n};\n\nstatic int max3420_wakeup(struct usb_gadget *gadget)\n{\n\tstruct max3420_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (udc->remote_wkp) {\n\t\tudc->todo |= REMOTE_WAKEUP;\n\t\tret = 0;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->thread_task)\n\t\twake_up_process(udc->thread_task);\n\treturn ret;\n}\n\nstatic int max3420_udc_start(struct usb_gadget *gadget,\n\t\t\t     struct usb_gadget_driver *driver)\n{\n\tstruct max3420_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tudc->driver = driver;\n\tudc->gadget.speed = USB_SPEED_FULL;\n\n\tudc->gadget.is_selfpowered = udc->is_selfpowered;\n\tudc->remote_wkp = 0;\n\tudc->softconnect = true;\n\tudc->todo |= UDC_START;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->thread_task)\n\t\twake_up_process(udc->thread_task);\n\n\treturn 0;\n}\n\nstatic int max3420_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct max3420_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->is_selfpowered = udc->gadget.is_selfpowered;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->driver = NULL;\n\tudc->softconnect = false;\n\tudc->todo |= UDC_START;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->thread_task)\n\t\twake_up_process(udc->thread_task);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops max3420_udc_ops = {\n\t.udc_start\t= max3420_udc_start,\n\t.udc_stop\t= max3420_udc_stop,\n\t.wakeup\t\t= max3420_wakeup,\n};\n\nstatic void max3420_eps_init(struct max3420_udc *udc)\n{\n\tint idx;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tfor (idx = 0; idx < MAX3420_MAX_EPS; idx++) {\n\t\tstruct max3420_ep *ep = &udc->ep[idx];\n\n\t\tspin_lock_init(&ep->lock);\n\t\tINIT_LIST_HEAD(&ep->queue);\n\n\t\tep->udc = udc;\n\t\tep->id = idx;\n\t\tep->halted = 0;\n\t\tep->maxpacket = 0;\n\t\tep->ep_usb.name = ep->name;\n\t\tep->ep_usb.ops = &max3420_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb, MAX3420_EP_MAX_PACKET);\n\n\t\tif (idx == 0) {  \n\t\t\tep->ep_usb.desc = &ep0_desc;\n\t\t\tep->ep_usb.maxpacket = usb_endpoint_maxp(&ep0_desc);\n\t\t\tep->ep_usb.caps.type_control = true;\n\t\t\tep->ep_usb.caps.dir_in = true;\n\t\t\tep->ep_usb.caps.dir_out = true;\n\t\t\tsnprintf(ep->name, MAX3420_EPNAME_SIZE, \"ep0\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idx == 1) {  \n\t\t\tep->ep_usb.caps.dir_in = false;\n\t\t\tep->ep_usb.caps.dir_out = true;\n\t\t\tsnprintf(ep->name, MAX3420_EPNAME_SIZE, \"ep1-bulk-out\");\n\t\t} else {  \n\t\t\tep->ep_usb.caps.dir_in = true;\n\t\t\tep->ep_usb.caps.dir_out = false;\n\t\t\tsnprintf(ep->name, MAX3420_EPNAME_SIZE,\n\t\t\t\t \"ep%d-bulk-in\", idx);\n\t\t}\n\t\tep->ep_usb.caps.type_iso = false;\n\t\tep->ep_usb.caps.type_int = false;\n\t\tep->ep_usb.caps.type_bulk = true;\n\n\t\tlist_add_tail(&ep->ep_usb.ep_list,\n\t\t\t      &udc->gadget.ep_list);\n\t}\n}\n\nstatic int max3420_probe(struct spi_device *spi)\n{\n\tstruct max3420_udc *udc;\n\tint err, irq;\n\tu8 reg[8];\n\n\tif (spi->master->flags & SPI_MASTER_HALF_DUPLEX) {\n\t\tdev_err(&spi->dev, \"UDC needs full duplex to work\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspi->mode = SPI_MODE_3;\n\tspi->bits_per_word = 8;\n\n\terr = spi_setup(spi);\n\tif (err) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI bus\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tudc = devm_kzalloc(&spi->dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tudc->spi = spi;\n\n\tudc->remote_wkp = 0;\n\n\t \n\tudc->gadget.ops = &max3420_udc_ops;\n\tudc->gadget.max_speed = USB_SPEED_FULL;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.ep0 = &udc->ep[0].ep_usb;\n\tudc->gadget.name = driver_name;\n\n\tspin_lock_init(&udc->lock);\n\tmutex_init(&udc->spi_bus_mutex);\n\n\tudc->ep0req.ep = &udc->ep[0];\n\tudc->ep0req.usb_req.buf = udc->ep0buf;\n\tINIT_LIST_HEAD(&udc->ep0req.queue);\n\n\t \n\tmax3420_eps_init(udc);\n\n\t \n\tspi_rd_buf(udc, MAX3420_REG_EPIRQ, reg, 8);\n\tspi_wr8(udc, MAX3420_REG_PINCTL, FDUPSPI);\n\n\terr = usb_add_gadget_udc(&spi->dev, &udc->gadget);\n\tif (err)\n\t\treturn err;\n\n\tudc->dev = &udc->gadget.dev;\n\n\tspi_set_drvdata(spi, udc);\n\n\tirq = of_irq_get_byname(spi->dev.of_node, \"udc\");\n\terr = devm_request_irq(&spi->dev, irq, max3420_irq_handler, 0,\n\t\t\t       \"max3420\", udc);\n\tif (err < 0)\n\t\tgoto del_gadget;\n\n\tudc->thread_task = kthread_create(max3420_thread, udc,\n\t\t\t\t\t  \"max3420-thread\");\n\tif (IS_ERR(udc->thread_task)) {\n\t\terr = PTR_ERR(udc->thread_task);\n\t\tgoto del_gadget;\n\t}\n\n\tirq = of_irq_get_byname(spi->dev.of_node, \"vbus\");\n\tif (irq <= 0) {  \n\t\tudc->is_selfpowered = 1;\n\t\tudc->vbus_active = true;\n\t\tudc->todo |= UDC_START;\n\t\tusb_udc_vbus_handler(&udc->gadget, udc->vbus_active);\n\t\tusb_gadget_set_state(&udc->gadget, USB_STATE_POWERED);\n\t\tmax3420_start(udc);\n\t} else {\n\t\tudc->is_selfpowered = 0;\n\t\t \n\t\tspi_rd_buf(udc, MAX3420_REG_EPIRQ, reg, 8);\n\t\tif (reg[7] != 0xff)\n\t\t\tudc->vbus_active = true;\n\n\t\terr = devm_request_irq(&spi->dev, irq,\n\t\t\t\t       max3420_vbus_handler, 0, \"vbus\", udc);\n\t\tif (err < 0)\n\t\t\tgoto del_gadget;\n\t}\n\n\treturn 0;\n\ndel_gadget:\n\tusb_del_gadget_udc(&udc->gadget);\n\treturn err;\n}\n\nstatic void max3420_remove(struct spi_device *spi)\n{\n\tstruct max3420_udc *udc = spi_get_drvdata(spi);\n\tunsigned long flags;\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tkthread_stop(udc->thread_task);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic const struct of_device_id max3420_udc_of_match[] = {\n\t{ .compatible = \"maxim,max3420-udc\"},\n\t{ .compatible = \"maxim,max3421-udc\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max3420_udc_of_match);\n\nstatic struct spi_driver max3420_driver = {\n\t.driver = {\n\t\t.name = \"max3420-udc\",\n\t\t.of_match_table = max3420_udc_of_match,\n\t},\n\t.probe = max3420_probe,\n\t.remove = max3420_remove,\n};\n\nmodule_spi_driver(max3420_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Jassi Brar <jaswinder.singh@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}