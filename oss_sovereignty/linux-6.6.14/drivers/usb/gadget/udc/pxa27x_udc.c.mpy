{
  "module_name": "pxa27x_udc.c",
  "hash_id": "d3a275b55b4a88b4a4473be87d678970dfcef97ee894eb5235c89cf640265797",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/pxa27x_udc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/gpio.h>\n#include <linux/gpio/consumer.h>\n#include <linux/slab.h>\n#include <linux/prefetch.h>\n#include <linux/byteorder/generic.h>\n#include <linux/platform_data/pxa2xx_udc.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/phy.h>\n\n#include \"pxa27x_udc.h\"\n\n \n\n#define\tDRIVER_VERSION\t\"2008-04-18\"\n#define\tDRIVER_DESC\t\"PXA 27x USB Device Controller driver\"\n\nstatic const char driver_name[] = \"pxa27x_udc\";\nstatic struct pxa_udc *the_controller;\n\nstatic void handle_ep(struct pxa_ep *ep);\n\n \n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n\nstatic int state_dbg_show(struct seq_file *s, void *p)\n{\n\tstruct pxa_udc *udc = s->private;\n\tu32 tmp;\n\n\tif (!udc->driver)\n\t\treturn -ENODEV;\n\n\t \n\tseq_printf(s, DRIVER_DESC \"\\n\"\n\t\t   \"%s version: %s\\n\"\n\t\t   \"Gadget driver: %s\\n\",\n\t\t   driver_name, DRIVER_VERSION,\n\t\t   udc->driver ? udc->driver->driver.name : \"(none)\");\n\n\ttmp = udc_readl(udc, UDCCR);\n\tseq_printf(s,\n\t\t   \"udccr=0x%0x(%s%s%s%s%s%s%s%s%s%s), con=%d,inter=%d,altinter=%d\\n\",\n\t\t   tmp,\n\t\t   (tmp & UDCCR_OEN) ? \" oen\":\"\",\n\t\t   (tmp & UDCCR_AALTHNP) ? \" aalthnp\":\"\",\n\t\t   (tmp & UDCCR_AHNP) ? \" rem\" : \"\",\n\t\t   (tmp & UDCCR_BHNP) ? \" rstir\" : \"\",\n\t\t   (tmp & UDCCR_DWRE) ? \" dwre\" : \"\",\n\t\t   (tmp & UDCCR_SMAC) ? \" smac\" : \"\",\n\t\t   (tmp & UDCCR_EMCE) ? \" emce\" : \"\",\n\t\t   (tmp & UDCCR_UDR) ? \" udr\" : \"\",\n\t\t   (tmp & UDCCR_UDA) ? \" uda\" : \"\",\n\t\t   (tmp & UDCCR_UDE) ? \" ude\" : \"\",\n\t\t   (tmp & UDCCR_ACN) >> UDCCR_ACN_S,\n\t\t   (tmp & UDCCR_AIN) >> UDCCR_AIN_S,\n\t\t   (tmp & UDCCR_AAISN) >> UDCCR_AAISN_S);\n\t \n\tseq_printf(s, \"udcicr0=0x%08x udcicr1=0x%08x\\n\",\n\t\t   udc_readl(udc, UDCICR0), udc_readl(udc, UDCICR1));\n\tseq_printf(s, \"udcisr0=0x%08x udcisr1=0x%08x\\n\",\n\t\t   udc_readl(udc, UDCISR0), udc_readl(udc, UDCISR1));\n\tseq_printf(s, \"udcfnr=%d\\n\", udc_readl(udc, UDCFNR));\n\tseq_printf(s, \"irqs: reset=%lu, suspend=%lu, resume=%lu, reconfig=%lu\\n\",\n\t\t   udc->stats.irqs_reset, udc->stats.irqs_suspend,\n\t\t   udc->stats.irqs_resume, udc->stats.irqs_reconfig);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(state_dbg);\n\nstatic int queues_dbg_show(struct seq_file *s, void *p)\n{\n\tstruct pxa_udc *udc = s->private;\n\tstruct pxa_ep *ep;\n\tstruct pxa27x_request *req;\n\tint i, maxpkt;\n\n\tif (!udc->driver)\n\t\treturn -ENODEV;\n\n\t \n\tfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\n\t\tep = &udc->pxa_ep[i];\n\t\tmaxpkt = ep->fifo_size;\n\t\tseq_printf(s,  \"%-12s max_pkt=%d %s\\n\",\n\t\t\t   EPNAME(ep), maxpkt, \"pio\");\n\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tseq_puts(s, \"\\t(nothing queued)\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tseq_printf(s,  \"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t   &req->req, req->req.actual,\n\t\t\t\t   req->req.length, req->req.buf);\n\t\t}\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(queues_dbg);\n\nstatic int eps_dbg_show(struct seq_file *s, void *p)\n{\n\tstruct pxa_udc *udc = s->private;\n\tstruct pxa_ep *ep;\n\tint i;\n\tu32 tmp;\n\n\tif (!udc->driver)\n\t\treturn -ENODEV;\n\n\tep = &udc->pxa_ep[0];\n\ttmp = udc_ep_readl(ep, UDCCSR);\n\tseq_printf(s, \"udccsr0=0x%03x(%s%s%s%s%s%s%s)\\n\",\n\t\t   tmp,\n\t\t   (tmp & UDCCSR0_SA) ? \" sa\" : \"\",\n\t\t   (tmp & UDCCSR0_RNE) ? \" rne\" : \"\",\n\t\t   (tmp & UDCCSR0_FST) ? \" fst\" : \"\",\n\t\t   (tmp & UDCCSR0_SST) ? \" sst\" : \"\",\n\t\t   (tmp & UDCCSR0_DME) ? \" dme\" : \"\",\n\t\t   (tmp & UDCCSR0_IPR) ? \" ipr\" : \"\",\n\t\t   (tmp & UDCCSR0_OPC) ? \" opc\" : \"\");\n\tfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\n\t\tep = &udc->pxa_ep[i];\n\t\ttmp = i? udc_ep_readl(ep, UDCCR) : udc_readl(udc, UDCCR);\n\t\tseq_printf(s, \"%-12s: IN %lu(%lu reqs), OUT %lu(%lu reqs), irqs=%lu, udccr=0x%08x, udccsr=0x%03x, udcbcr=%d\\n\",\n\t\t\t   EPNAME(ep),\n\t\t\t   ep->stats.in_bytes, ep->stats.in_ops,\n\t\t\t   ep->stats.out_bytes, ep->stats.out_ops,\n\t\t\t   ep->stats.irqs,\n\t\t\t   tmp, udc_ep_readl(ep, UDCCSR),\n\t\t\t   udc_ep_readl(ep, UDCBCR));\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(eps_dbg);\n\nstatic void pxa_init_debugfs(struct pxa_udc *udc)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(udc->gadget.name, usb_debug_root);\n\tdebugfs_create_file(\"udcstate\", 0400, root, udc, &state_dbg_fops);\n\tdebugfs_create_file(\"queues\", 0400, root, udc, &queues_dbg_fops);\n\tdebugfs_create_file(\"epstate\", 0400, root, udc, &eps_dbg_fops);\n}\n\nstatic void pxa_cleanup_debugfs(struct pxa_udc *udc)\n{\n\tdebugfs_lookup_and_remove(udc->gadget.name, usb_debug_root);\n}\n\n#else\nstatic inline void pxa_init_debugfs(struct pxa_udc *udc)\n{\n}\n\nstatic inline void pxa_cleanup_debugfs(struct pxa_udc *udc)\n{\n}\n#endif\n\n \nstatic int is_match_usb_pxa(struct udc_usb_ep *udc_usb_ep, struct pxa_ep *ep,\n\t\tint config, int interface, int altsetting)\n{\n\tif (usb_endpoint_num(&udc_usb_ep->desc) != ep->addr)\n\t\treturn 0;\n\tif (usb_endpoint_dir_in(&udc_usb_ep->desc) != ep->dir_in)\n\t\treturn 0;\n\tif (usb_endpoint_type(&udc_usb_ep->desc) != ep->type)\n\t\treturn 0;\n\tif ((ep->config != config) || (ep->interface != interface)\n\t\t\t|| (ep->alternate != altsetting))\n\t\treturn 0;\n\treturn 1;\n}\n\n \nstatic struct pxa_ep *find_pxa_ep(struct pxa_udc *udc,\n\t\tstruct udc_usb_ep *udc_usb_ep)\n{\n\tint i;\n\tstruct pxa_ep *ep;\n\tint cfg = udc->config;\n\tint iface = udc->last_interface;\n\tint alt = udc->last_alternate;\n\n\tif (udc_usb_ep == &udc->udc_usb_ep[0])\n\t\treturn &udc->pxa_ep[0];\n\n\tfor (i = 1; i < NR_PXA_ENDPOINTS; i++) {\n\t\tep = &udc->pxa_ep[i];\n\t\tif (is_match_usb_pxa(udc_usb_ep, ep, cfg, iface, alt))\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n \nstatic void update_pxa_ep_matches(struct pxa_udc *udc)\n{\n\tint i;\n\tstruct udc_usb_ep *udc_usb_ep;\n\n\tfor (i = 1; i < NR_USB_ENDPOINTS; i++) {\n\t\tudc_usb_ep = &udc->udc_usb_ep[i];\n\t\tif (udc_usb_ep->pxa_ep)\n\t\t\tudc_usb_ep->pxa_ep = find_pxa_ep(udc, udc_usb_ep);\n\t}\n}\n\n \nstatic void pio_irq_enable(struct pxa_ep *ep)\n{\n\tstruct pxa_udc *udc = ep->dev;\n\tint index = EPIDX(ep);\n\tu32 udcicr0 = udc_readl(udc, UDCICR0);\n\tu32 udcicr1 = udc_readl(udc, UDCICR1);\n\n\tif (index < 16)\n\t\tudc_writel(udc, UDCICR0, udcicr0 | (3 << (index * 2)));\n\telse\n\t\tudc_writel(udc, UDCICR1, udcicr1 | (3 << ((index - 16) * 2)));\n}\n\n \nstatic void pio_irq_disable(struct pxa_ep *ep)\n{\n\tstruct pxa_udc *udc = ep->dev;\n\tint index = EPIDX(ep);\n\tu32 udcicr0 = udc_readl(udc, UDCICR0);\n\tu32 udcicr1 = udc_readl(udc, UDCICR1);\n\n\tif (index < 16)\n\t\tudc_writel(udc, UDCICR0, udcicr0 & ~(3 << (index * 2)));\n\telse\n\t\tudc_writel(udc, UDCICR1, udcicr1 & ~(3 << ((index - 16) * 2)));\n}\n\n \nstatic inline void udc_set_mask_UDCCR(struct pxa_udc *udc, int mask)\n{\n\tu32 udccr = udc_readl(udc, UDCCR);\n\tudc_writel(udc, UDCCR,\n\t\t\t(udccr & UDCCR_MASK_BITS) | (mask & UDCCR_MASK_BITS));\n}\n\n \nstatic inline void udc_clear_mask_UDCCR(struct pxa_udc *udc, int mask)\n{\n\tu32 udccr = udc_readl(udc, UDCCR);\n\tudc_writel(udc, UDCCR,\n\t\t\t(udccr & UDCCR_MASK_BITS) & ~(mask & UDCCR_MASK_BITS));\n}\n\n \nstatic inline void ep_write_UDCCSR(struct pxa_ep *ep, int mask)\n{\n\tif (is_ep0(ep))\n\t\tmask |= UDCCSR0_ACM;\n\tudc_ep_writel(ep, UDCCSR, mask);\n}\n\n \nstatic int ep_count_bytes_remain(struct pxa_ep *ep)\n{\n\tif (ep->dir_in)\n\t\treturn -EOPNOTSUPP;\n\treturn udc_ep_readl(ep, UDCBCR) & 0x3ff;\n}\n\n \nstatic int ep_is_empty(struct pxa_ep *ep)\n{\n\tint ret;\n\n\tif (!is_ep0(ep) && ep->dir_in)\n\t\treturn -EOPNOTSUPP;\n\tif (is_ep0(ep))\n\t\tret = !(udc_ep_readl(ep, UDCCSR) & UDCCSR0_RNE);\n\telse\n\t\tret = !(udc_ep_readl(ep, UDCCSR) & UDCCSR_BNE);\n\treturn ret;\n}\n\n \nstatic int ep_is_full(struct pxa_ep *ep)\n{\n\tif (is_ep0(ep))\n\t\treturn (udc_ep_readl(ep, UDCCSR) & UDCCSR0_IPR);\n\tif (!ep->dir_in)\n\t\treturn -EOPNOTSUPP;\n\treturn (!(udc_ep_readl(ep, UDCCSR) & UDCCSR_BNF));\n}\n\n \nstatic int epout_has_pkt(struct pxa_ep *ep)\n{\n\tif (!is_ep0(ep) && ep->dir_in)\n\t\treturn -EOPNOTSUPP;\n\tif (is_ep0(ep))\n\t\treturn (udc_ep_readl(ep, UDCCSR) & UDCCSR0_OPC);\n\treturn (udc_ep_readl(ep, UDCCSR) & UDCCSR_PC);\n}\n\n \nstatic void set_ep0state(struct pxa_udc *udc, int state)\n{\n\tstruct pxa_ep *ep = &udc->pxa_ep[0];\n\tchar *old_stname = EP0_STNAME(udc);\n\n\tudc->ep0state = state;\n\tep_dbg(ep, \"state=%s->%s, udccsr0=0x%03x, udcbcr=%d\\n\", old_stname,\n\t\tEP0_STNAME(udc), udc_ep_readl(ep, UDCCSR),\n\t\tudc_ep_readl(ep, UDCBCR));\n}\n\n \nstatic void ep0_idle(struct pxa_udc *dev)\n{\n\tset_ep0state(dev, WAIT_FOR_SETUP);\n}\n\n \nstatic void inc_ep_stats_reqs(struct pxa_ep *ep, int is_in)\n{\n\tif (is_in)\n\t\tep->stats.in_ops++;\n\telse\n\t\tep->stats.out_ops++;\n}\n\n \nstatic void inc_ep_stats_bytes(struct pxa_ep *ep, int count, int is_in)\n{\n\tif (is_in)\n\t\tep->stats.in_bytes += count;\n\telse\n\t\tep->stats.out_bytes += count;\n}\n\n \nstatic void pxa_ep_setup(struct pxa_ep *ep)\n{\n\tu32 new_udccr;\n\n\tnew_udccr = ((ep->config << UDCCONR_CN_S) & UDCCONR_CN)\n\t\t| ((ep->interface << UDCCONR_IN_S) & UDCCONR_IN)\n\t\t| ((ep->alternate << UDCCONR_AISN_S) & UDCCONR_AISN)\n\t\t| ((EPADDR(ep) << UDCCONR_EN_S) & UDCCONR_EN)\n\t\t| ((EPXFERTYPE(ep) << UDCCONR_ET_S) & UDCCONR_ET)\n\t\t| ((ep->dir_in) ? UDCCONR_ED : 0)\n\t\t| ((ep->fifo_size << UDCCONR_MPS_S) & UDCCONR_MPS)\n\t\t| UDCCONR_EE;\n\n\tudc_ep_writel(ep, UDCCR, new_udccr);\n}\n\n \nstatic void pxa_eps_setup(struct pxa_udc *dev)\n{\n\tunsigned int i;\n\n\tdev_dbg(dev->dev, \"%s: dev=%p\\n\", __func__, dev);\n\n\tfor (i = 1; i < NR_PXA_ENDPOINTS; i++)\n\t\tpxa_ep_setup(&dev->pxa_ep[i]);\n}\n\n \nstatic struct usb_request *\npxa_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct pxa27x_request *req;\n\n\treq = kzalloc(sizeof *req, gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\treq->in_use = 0;\n\treq->udc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\n\treturn &req->req;\n}\n\n \nstatic void pxa_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct pxa27x_request *req;\n\n\treq = container_of(_req, struct pxa27x_request, req);\n\tWARN_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\n \nstatic void ep_add_request(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tif (unlikely(!req))\n\t\treturn;\n\tep_vdbg(ep, \"req:%p, lg=%d, udccsr=0x%03x\\n\", req,\n\t\treq->req.length, udc_ep_readl(ep, UDCCSR));\n\n\treq->in_use = 1;\n\tlist_add_tail(&req->queue, &ep->queue);\n\tpio_irq_enable(ep);\n}\n\n \nstatic void ep_del_request(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tif (unlikely(!req))\n\t\treturn;\n\tep_vdbg(ep, \"req:%p, lg=%d, udccsr=0x%03x\\n\", req,\n\t\treq->req.length, udc_ep_readl(ep, UDCCSR));\n\n\tlist_del_init(&req->queue);\n\treq->in_use = 0;\n\tif (!is_ep0(ep) && list_empty(&ep->queue))\n\t\tpio_irq_disable(ep);\n}\n\n \nstatic void req_done(struct pxa_ep *ep, struct pxa27x_request *req, int status,\n\tunsigned long *pflags)\n{\n\tunsigned long\tflags;\n\n\tep_del_request(ep, req);\n\tif (likely(req->req.status == -EINPROGRESS))\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tep_dbg(ep, \"complete req %p stat %d len %u/%u\\n\",\n\t\t\t&req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\tif (pflags)\n\t\tspin_unlock_irqrestore(&ep->lock, *pflags);\n\tlocal_irq_save(flags);\n\tusb_gadget_giveback_request(&req->udc_usb_ep->usb_ep, &req->req);\n\tlocal_irq_restore(flags);\n\tif (pflags)\n\t\tspin_lock_irqsave(&ep->lock, *pflags);\n}\n\n \nstatic void ep_end_out_req(struct pxa_ep *ep, struct pxa27x_request *req,\n\tunsigned long *pflags)\n{\n\tinc_ep_stats_reqs(ep, !USB_DIR_IN);\n\treq_done(ep, req, 0, pflags);\n}\n\n \nstatic void ep0_end_out_req(struct pxa_ep *ep, struct pxa27x_request *req,\n\tunsigned long *pflags)\n{\n\tset_ep0state(ep->dev, OUT_STATUS_STAGE);\n\tep_end_out_req(ep, req, pflags);\n\tep0_idle(ep->dev);\n}\n\n \nstatic void ep_end_in_req(struct pxa_ep *ep, struct pxa27x_request *req,\n\tunsigned long *pflags)\n{\n\tinc_ep_stats_reqs(ep, USB_DIR_IN);\n\treq_done(ep, req, 0, pflags);\n}\n\n \nstatic void ep0_end_in_req(struct pxa_ep *ep, struct pxa27x_request *req,\n\tunsigned long *pflags)\n{\n\tset_ep0state(ep->dev, IN_STATUS_STAGE);\n\tep_end_in_req(ep, req, pflags);\n}\n\n \nstatic void nuke(struct pxa_ep *ep, int status)\n{\n\tstruct pxa27x_request\t*req;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct pxa27x_request, queue);\n\t\treq_done(ep, req, status, &flags);\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic int read_packet(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tu32 *buf;\n\tint bytes_ep, bufferspace, count, i;\n\n\tbytes_ep = ep_count_bytes_remain(ep);\n\tbufferspace = req->req.length - req->req.actual;\n\n\tbuf = (u32 *)(req->req.buf + req->req.actual);\n\tprefetchw(buf);\n\n\tif (likely(!ep_is_empty(ep)))\n\t\tcount = min(bytes_ep, bufferspace);\n\telse  \n\t\tcount = 0;\n\n\tfor (i = count; i > 0; i -= 4)\n\t\t*buf++ = udc_ep_readl(ep, UDCDR);\n\treq->req.actual += count;\n\n\tep_write_UDCCSR(ep, UDCCSR_PC);\n\n\treturn count;\n}\n\n \nstatic int write_packet(struct pxa_ep *ep, struct pxa27x_request *req,\n\t\t\tunsigned int max)\n{\n\tint length, count, remain, i;\n\tu32 *buf;\n\tu8 *buf_8;\n\n\tbuf = (u32 *)(req->req.buf + req->req.actual);\n\tprefetch(buf);\n\n\tlength = min(req->req.length - req->req.actual, max);\n\treq->req.actual += length;\n\n\tremain = length & 0x3;\n\tcount = length & ~(0x3);\n\tfor (i = count; i > 0 ; i -= 4)\n\t\tudc_ep_writel(ep, UDCDR, *buf++);\n\n\tbuf_8 = (u8 *)buf;\n\tfor (i = remain; i > 0; i--)\n\t\tudc_ep_writeb(ep, UDCDR, *buf_8++);\n\n\tep_vdbg(ep, \"length=%d+%d, udccsr=0x%03x\\n\", count, remain,\n\t\tudc_ep_readl(ep, UDCCSR));\n\n\treturn length;\n}\n\n \nstatic int read_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tint count, is_short, completed = 0;\n\n\twhile (epout_has_pkt(ep)) {\n\t\tcount = read_packet(ep, req);\n\t\tinc_ep_stats_bytes(ep, count, !USB_DIR_IN);\n\n\t\tis_short = (count < ep->fifo_size);\n\t\tep_dbg(ep, \"read udccsr:%03x, count:%d bytes%s req %p %d/%d\\n\",\n\t\t\tudc_ep_readl(ep, UDCCSR), count, is_short ? \"/S\" : \"\",\n\t\t\t&req->req, req->req.actual, req->req.length);\n\n\t\t \n\t\tif (is_short || req->req.actual == req->req.length) {\n\t\t\tcompleted = 1;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t}\n\treturn completed;\n}\n\n \nstatic int write_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tunsigned max;\n\tint count, is_short, is_last = 0, completed = 0, totcount = 0;\n\tu32 udccsr;\n\n\tmax = ep->fifo_size;\n\tdo {\n\t\tudccsr = udc_ep_readl(ep, UDCCSR);\n\t\tif (udccsr & UDCCSR_PC) {\n\t\t\tep_vdbg(ep, \"Clearing Transmit Complete, udccsr=%x\\n\",\n\t\t\t\tudccsr);\n\t\t\tep_write_UDCCSR(ep, UDCCSR_PC);\n\t\t}\n\t\tif (udccsr & UDCCSR_TRN) {\n\t\t\tep_vdbg(ep, \"Clearing Underrun on, udccsr=%x\\n\",\n\t\t\t\tudccsr);\n\t\t\tep_write_UDCCSR(ep, UDCCSR_TRN);\n\t\t}\n\n\t\tcount = write_packet(ep, req, max);\n\t\tinc_ep_stats_bytes(ep, count, USB_DIR_IN);\n\t\ttotcount += count;\n\n\t\t \n\t\tif (unlikely(count < max)) {\n\t\t\tis_last = 1;\n\t\t\tis_short = 1;\n\t\t} else {\n\t\t\tif (likely(req->req.length > req->req.actual)\n\t\t\t\t\t|| req->req.zero)\n\t\t\t\tis_last = 0;\n\t\t\telse\n\t\t\t\tis_last = 1;\n\t\t\t \n\t\t\tis_short = unlikely(max < ep->fifo_size);\n\t\t}\n\n\t\tif (is_short)\n\t\t\tep_write_UDCCSR(ep, UDCCSR_SP);\n\n\t\t \n\t\tif (is_last) {\n\t\t\tcompleted = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!ep_is_full(ep));\n\n\tep_dbg(ep, \"wrote count:%d bytes%s%s, left:%d req=%p\\n\",\n\t\t\ttotcount, is_last ? \"/L\" : \"\", is_short ? \"/S\" : \"\",\n\t\t\treq->req.length - req->req.actual, &req->req);\n\n\treturn completed;\n}\n\n \nstatic int read_ep0_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tint count, is_short, completed = 0;\n\n\twhile (epout_has_pkt(ep)) {\n\t\tcount = read_packet(ep, req);\n\t\tep_write_UDCCSR(ep, UDCCSR0_OPC);\n\t\tinc_ep_stats_bytes(ep, count, !USB_DIR_IN);\n\n\t\tis_short = (count < ep->fifo_size);\n\t\tep_dbg(ep, \"read udccsr:%03x, count:%d bytes%s req %p %d/%d\\n\",\n\t\t\tudc_ep_readl(ep, UDCCSR), count, is_short ? \"/S\" : \"\",\n\t\t\t&req->req, req->req.actual, req->req.length);\n\n\t\tif (is_short || req->req.actual >= req->req.length) {\n\t\t\tcompleted = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn completed;\n}\n\n \nstatic int write_ep0_fifo(struct pxa_ep *ep, struct pxa27x_request *req)\n{\n\tunsigned\tcount;\n\tint\t\tis_last, is_short;\n\n\tcount = write_packet(ep, req, EP0_FIFO_SIZE);\n\tinc_ep_stats_bytes(ep, count, USB_DIR_IN);\n\n\tis_short = (count < EP0_FIFO_SIZE);\n\tis_last = ((count == 0) || (count < EP0_FIFO_SIZE));\n\n\t \n\tif (unlikely(is_short))\n\t\tep_write_UDCCSR(ep, UDCCSR0_IPR);\n\n\tep_dbg(ep, \"in %d bytes%s%s, %d left, req=%p, udccsr0=0x%03x\\n\",\n\t\tcount, is_short ? \"/S\" : \"\", is_last ? \"/L\" : \"\",\n\t\treq->req.length - req->req.actual,\n\t\t&req->req, udc_ep_readl(ep, UDCCSR));\n\n\treturn is_last;\n}\n\n \nstatic int pxa_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\tstruct pxa_ep\t\t*ep;\n\tstruct pxa27x_request\t*req;\n\tstruct pxa_udc\t\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\trc = 0;\n\tint\t\t\tis_first_req;\n\tunsigned\t\tlength;\n\tint\t\t\trecursion_detected;\n\n\treq = container_of(_req, struct pxa27x_request, req);\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\n\tif (unlikely(!_req || !_req->complete || !_req->buf))\n\t\treturn -EINVAL;\n\n\tif (unlikely(!_ep))\n\t\treturn -EINVAL;\n\n\tep = udc_usb_ep->pxa_ep;\n\tif (unlikely(!ep))\n\t\treturn -EINVAL;\n\n\tdev = ep->dev;\n\tif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {\n\t\tep_dbg(ep, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (unlikely(EPXFERTYPE_is_ISO(ep)\n\t\t\t&& req->req.length > ep->fifo_size))\n\t\treturn -EMSGSIZE;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\trecursion_detected = ep->in_handle_ep;\n\n\tis_first_req = list_empty(&ep->queue);\n\tep_dbg(ep, \"queue req %p(first=%s), len %d buf %p\\n\",\n\t\t\t_req, is_first_req ? \"yes\" : \"no\",\n\t\t\t_req->length, _req->buf);\n\n\tif (!ep->enabled) {\n\t\t_req->status = -ESHUTDOWN;\n\t\trc = -ESHUTDOWN;\n\t\tgoto out_locked;\n\t}\n\n\tif (req->in_use) {\n\t\tep_err(ep, \"refusing to queue req %p (already queued)\\n\", req);\n\t\tgoto out_locked;\n\t}\n\n\tlength = _req->length;\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tep_add_request(ep, req);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (is_ep0(ep)) {\n\t\tswitch (dev->ep0state) {\n\t\tcase WAIT_ACK_SET_CONF_INTERF:\n\t\t\tif (length == 0) {\n\t\t\t\tep_end_in_req(ep, req, NULL);\n\t\t\t} else {\n\t\t\t\tep_err(ep, \"got a request of %d bytes while\"\n\t\t\t\t\t\"in state WAIT_ACK_SET_CONF_INTERF\\n\",\n\t\t\t\t\tlength);\n\t\t\t\tep_del_request(ep, req);\n\t\t\t\trc = -EL2HLT;\n\t\t\t}\n\t\t\tep0_idle(ep->dev);\n\t\t\tbreak;\n\t\tcase IN_DATA_STAGE:\n\t\t\tif (!ep_is_full(ep))\n\t\t\t\tif (write_ep0_fifo(ep, req))\n\t\t\t\t\tep0_end_in_req(ep, req, NULL);\n\t\t\tbreak;\n\t\tcase OUT_DATA_STAGE:\n\t\t\tif ((length == 0) || !epout_has_pkt(ep))\n\t\t\t\tif (read_ep0_fifo(ep, req))\n\t\t\t\t\tep0_end_out_req(ep, req, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tep_err(ep, \"odd state %s to send me a request\\n\",\n\t\t\t\tEP0_STNAME(ep->dev));\n\t\t\tep_del_request(ep, req);\n\t\t\trc = -EL2HLT;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (!recursion_detected)\n\t\t\thandle_ep(ep);\n\t}\n\nout:\n\treturn rc;\nout_locked:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tgoto out;\n}\n\n \nstatic int pxa_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\tstruct pxa27x_request\t*req = NULL, *iter;\n\tunsigned long\t\tflags;\n\tint\t\t\trc = -EINVAL;\n\n\tif (!_ep)\n\t\treturn rc;\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tep = udc_usb_ep->pxa_ep;\n\tif (!ep || is_ep0(ep))\n\t\treturn rc;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\tif (!rc)\n\t\treq_done(ep, req, -ECONNRESET, NULL);\n\treturn rc;\n}\n\n \nstatic int pxa_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\tunsigned long flags;\n\tint rc;\n\n\n\tif (!_ep)\n\t\treturn -EINVAL;\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tep = udc_usb_ep->pxa_ep;\n\tif (!ep || is_ep0(ep))\n\t\treturn -EINVAL;\n\n\tif (value == 0) {\n\t\t \n\t\tep_dbg(ep, \"only host can clear halt\\n\");\n\t\treturn -EROFS;\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\trc = -EAGAIN;\n\tif (ep->dir_in\t&& (ep_is_full(ep) || !list_empty(&ep->queue)))\n\t\tgoto out;\n\n\t \n\trc = 0;\n\tep_write_UDCCSR(ep, UDCCSR_FST | UDCCSR_FEF);\n\tif (is_ep0(ep))\n\t\tset_ep0state(ep->dev, STALL);\n\nout:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\treturn rc;\n}\n\n \nstatic int pxa_ep_fifo_status(struct usb_ep *_ep)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\n\tif (!_ep)\n\t\treturn -ENODEV;\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tep = udc_usb_ep->pxa_ep;\n\tif (!ep || is_ep0(ep))\n\t\treturn -ENODEV;\n\n\tif (ep->dir_in)\n\t\treturn -EOPNOTSUPP;\n\tif (ep->dev->gadget.speed == USB_SPEED_UNKNOWN || ep_is_empty(ep))\n\t\treturn 0;\n\telse\n\t\treturn ep_count_bytes_remain(ep) + 1;\n}\n\n \nstatic void pxa_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\tunsigned long\t\tflags;\n\n\tif (!_ep)\n\t\treturn;\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tep = udc_usb_ep->pxa_ep;\n\tif (!ep || is_ep0(ep))\n\t\treturn;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tif (unlikely(!list_empty(&ep->queue)))\n\t\tep_dbg(ep, \"called while queue list not empty\\n\");\n\tep_dbg(ep, \"called\\n\");\n\n\t \n\tif (!ep->dir_in) {\n\t\twhile (!ep_is_empty(ep))\n\t\t\tudc_ep_readl(ep, UDCDR);\n\t} else {\n\t\t \n\t\tep_write_UDCCSR(ep,\n\t\t\t\tUDCCSR_PC | UDCCSR_FEF | UDCCSR_TRN\n\t\t\t\t| (EPXFERTYPE_is_ISO(ep) ? 0 : UDCCSR_SST));\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic int pxa_ep_enable(struct usb_ep *_ep,\n\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\tstruct pxa_udc\t\t*udc;\n\n\tif (!_ep || !desc)\n\t\treturn -EINVAL;\n\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tif (udc_usb_ep->pxa_ep) {\n\t\tep = udc_usb_ep->pxa_ep;\n\t\tep_warn(ep, \"usb_ep %s already enabled, doing nothing\\n\",\n\t\t\t_ep->name);\n\t} else {\n\t\tep = find_pxa_ep(udc_usb_ep->dev, udc_usb_ep);\n\t}\n\n\tif (!ep || is_ep0(ep)) {\n\t\tdev_err(udc_usb_ep->dev->dev,\n\t\t\t\"unable to match pxa_ep for ep %s\\n\",\n\t\t\t_ep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\t\t|| (ep->type != usb_endpoint_type(desc))) {\n\t\tep_err(ep, \"type mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ep->fifo_size < usb_endpoint_maxp(desc)) {\n\t\tep_err(ep, \"bad maxpacket\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tudc_usb_ep->pxa_ep = ep;\n\tudc = ep->dev;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tep_err(ep, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tep->enabled = 1;\n\n\t \n\tpxa_ep_fifo_flush(_ep);\n\n\tep_dbg(ep, \"enabled\\n\");\n\treturn 0;\n}\n\n \nstatic int pxa_ep_disable(struct usb_ep *_ep)\n{\n\tstruct pxa_ep\t\t*ep;\n\tstruct udc_usb_ep\t*udc_usb_ep;\n\n\tif (!_ep)\n\t\treturn -EINVAL;\n\n\tudc_usb_ep = container_of(_ep, struct udc_usb_ep, usb_ep);\n\tep = udc_usb_ep->pxa_ep;\n\tif (!ep || is_ep0(ep) || !list_empty(&ep->queue))\n\t\treturn -EINVAL;\n\n\tep->enabled = 0;\n\tnuke(ep, -ESHUTDOWN);\n\n\tpxa_ep_fifo_flush(_ep);\n\tudc_usb_ep->pxa_ep = NULL;\n\n\tep_dbg(ep, \"disabled\\n\");\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops pxa_ep_ops = {\n\t.enable\t\t= pxa_ep_enable,\n\t.disable\t= pxa_ep_disable,\n\n\t.alloc_request\t= pxa_ep_alloc_request,\n\t.free_request\t= pxa_ep_free_request,\n\n\t.queue\t\t= pxa_ep_queue,\n\t.dequeue\t= pxa_ep_dequeue,\n\n\t.set_halt\t= pxa_ep_set_halt,\n\t.fifo_status\t= pxa_ep_fifo_status,\n\t.fifo_flush\t= pxa_ep_fifo_flush,\n};\n\n \nstatic void dplus_pullup(struct pxa_udc *udc, int on)\n{\n\tif (udc->gpiod) {\n\t\tgpiod_set_value(udc->gpiod, on);\n\t} else if (udc->udc_command) {\n\t\tif (on)\n\t\t\tudc->udc_command(PXA2XX_UDC_CMD_CONNECT);\n\t\telse\n\t\t\tudc->udc_command(PXA2XX_UDC_CMD_DISCONNECT);\n\t}\n\tudc->pullup_on = on;\n}\n\n \nstatic int pxa_udc_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct pxa_udc *udc = to_gadget_udc(_gadget);\n\n\treturn (udc_readl(udc, UDCFNR) & 0x7ff);\n}\n\n \nstatic int pxa_udc_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct pxa_udc *udc = to_gadget_udc(_gadget);\n\n\t \n\tif ((udc_readl(udc, UDCCR) & UDCCR_DWRE) == 0)\n\t\treturn -EHOSTUNREACH;\n\tudc_set_mask_UDCCR(udc, UDCCR_UDR);\n\treturn 0;\n}\n\nstatic void udc_enable(struct pxa_udc *udc);\nstatic void udc_disable(struct pxa_udc *udc);\n\n \nstatic int should_enable_udc(struct pxa_udc *udc)\n{\n\tint put_on;\n\n\tput_on = ((udc->pullup_on) && (udc->driver));\n\tput_on &= ((udc->vbus_sensed) || (IS_ERR_OR_NULL(udc->transceiver)));\n\treturn put_on;\n}\n\n \nstatic int should_disable_udc(struct pxa_udc *udc)\n{\n\tint put_off;\n\n\tput_off = ((!udc->pullup_on) || (!udc->driver));\n\tput_off |= ((!udc->vbus_sensed) && (!IS_ERR_OR_NULL(udc->transceiver)));\n\treturn put_off;\n}\n\n \nstatic int pxa_udc_pullup(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct pxa_udc *udc = to_gadget_udc(_gadget);\n\n\tif (!udc->gpiod && !udc->udc_command)\n\t\treturn -EOPNOTSUPP;\n\n\tdplus_pullup(udc, is_active);\n\n\tif (should_enable_udc(udc))\n\t\tudc_enable(udc);\n\tif (should_disable_udc(udc))\n\t\tudc_disable(udc);\n\treturn 0;\n}\n\n \nstatic int pxa_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct pxa_udc *udc = to_gadget_udc(_gadget);\n\n\tudc->vbus_sensed = is_active;\n\tif (should_enable_udc(udc))\n\t\tudc_enable(udc);\n\tif (should_disable_udc(udc))\n\t\tudc_disable(udc);\n\n\treturn 0;\n}\n\n \nstatic int pxa_udc_vbus_draw(struct usb_gadget *_gadget, unsigned mA)\n{\n\tstruct pxa_udc *udc;\n\n\tudc = to_gadget_udc(_gadget);\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\treturn usb_phy_set_power(udc->transceiver, mA);\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int pxa_udc_phy_event(struct notifier_block *nb, unsigned long action,\n\t\t\t     void *data)\n{\n\tstruct usb_gadget *gadget = data;\n\n\tswitch (action) {\n\tcase USB_EVENT_VBUS:\n\t\tusb_gadget_vbus_connect(gadget);\n\t\treturn NOTIFY_OK;\n\tcase USB_EVENT_NONE:\n\t\tusb_gadget_vbus_disconnect(gadget);\n\t\treturn NOTIFY_OK;\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n}\n\nstatic struct notifier_block pxa27x_udc_phy = {\n\t.notifier_call = pxa_udc_phy_event,\n};\n\nstatic int pxa27x_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int pxa27x_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops pxa_udc_ops = {\n\t.get_frame\t= pxa_udc_get_frame,\n\t.wakeup\t\t= pxa_udc_wakeup,\n\t.pullup\t\t= pxa_udc_pullup,\n\t.vbus_session\t= pxa_udc_vbus_session,\n\t.vbus_draw\t= pxa_udc_vbus_draw,\n\t.udc_start\t= pxa27x_udc_start,\n\t.udc_stop\t= pxa27x_udc_stop,\n};\n\n \nstatic void udc_disable(struct pxa_udc *udc)\n{\n\tif (!udc->enabled)\n\t\treturn;\n\n\tudc_writel(udc, UDCICR0, 0);\n\tudc_writel(udc, UDCICR1, 0);\n\n\tudc_clear_mask_UDCCR(udc, UDCCR_UDE);\n\n\tep0_idle(udc);\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tclk_disable(udc->clk);\n\n\tudc->enabled = 0;\n}\n\n \nstatic void udc_init_data(struct pxa_udc *dev)\n{\n\tint i;\n\tstruct pxa_ep *ep;\n\n\t \n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n\tdev->udc_usb_ep[0].pxa_ep = &dev->pxa_ep[0];\n\tdev->gadget.quirk_altset_not_supp = 1;\n\tep0_idle(dev);\n\n\t \n\tfor (i = 0; i < NR_PXA_ENDPOINTS; i++) {\n\t\tep = &dev->pxa_ep[i];\n\n\t\tep->enabled = is_ep0(ep);\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tspin_lock_init(&ep->lock);\n\t}\n\n\t \n\tfor (i = 1; i < NR_USB_ENDPOINTS; i++) {\n\t\tlist_add_tail(&dev->udc_usb_ep[i].usb_ep.ep_list,\n\t\t\t\t&dev->gadget.ep_list);\n\t\tusb_ep_set_maxpacket_limit(&dev->udc_usb_ep[i].usb_ep,\n\t\t\t\t\t   dev->udc_usb_ep[i].usb_ep.maxpacket);\n\t}\n}\n\n \nstatic void udc_enable(struct pxa_udc *udc)\n{\n\tif (udc->enabled)\n\t\treturn;\n\n\tclk_enable(udc->clk);\n\tudc_writel(udc, UDCICR0, 0);\n\tudc_writel(udc, UDCICR1, 0);\n\tudc_clear_mask_UDCCR(udc, UDCCR_UDE);\n\n\tep0_idle(udc);\n\tudc->gadget.speed = USB_SPEED_FULL;\n\tmemset(&udc->stats, 0, sizeof(udc->stats));\n\n\tpxa_eps_setup(udc);\n\tudc_set_mask_UDCCR(udc, UDCCR_UDE);\n\tep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_ACM);\n\tudelay(2);\n\tif (udc_readl(udc, UDCCR) & UDCCR_EMCE)\n\t\tdev_err(udc->dev, \"Configuration errors, udc disabled\\n\");\n\n\t \n\tmsleep(100);\n\n\t \n\tudc_writel(udc, UDCICR1,\n\t\t\tUDCICR1_IECC | UDCICR1_IERU\n\t\t\t| UDCICR1_IESU | UDCICR1_IERS);\n\n\t \n\tpio_irq_enable(&udc->pxa_ep[0]);\n\n\tudc->enabled = 1;\n}\n\n \nstatic int pxa27x_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct pxa_udc *udc = to_pxa(g);\n\tint retval;\n\n\t \n\tudc->driver = driver;\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver)) {\n\t\tretval = otg_set_peripheral(udc->transceiver->otg,\n\t\t\t\t\t\t&udc->gadget);\n\t\tif (retval) {\n\t\t\tdev_err(udc->dev, \"can't bind to transceiver\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (should_enable_udc(udc))\n\t\tudc_enable(udc);\n\treturn 0;\n\nfail:\n\tudc->driver = NULL;\n\treturn retval;\n}\n\n \nstatic void stop_activity(struct pxa_udc *udc)\n{\n\tint i;\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tfor (i = 0; i < NR_USB_ENDPOINTS; i++)\n\t\tpxa_ep_disable(&udc->udc_usb_ep[i].usb_ep);\n}\n\n \nstatic int pxa27x_udc_stop(struct usb_gadget *g)\n{\n\tstruct pxa_udc *udc = to_pxa(g);\n\n\tstop_activity(udc);\n\tudc_disable(udc);\n\n\tudc->driver = NULL;\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\treturn otg_set_peripheral(udc->transceiver->otg, NULL);\n\treturn 0;\n}\n\n \nstatic void handle_ep0_ctrl_req(struct pxa_udc *udc,\n\t\t\t\tstruct pxa27x_request *req)\n{\n\tstruct pxa_ep *ep = &udc->pxa_ep[0];\n\tunion {\n\t\tstruct usb_ctrlrequest\tr;\n\t\tu32\t\t\tword[2];\n\t} u;\n\tint i;\n\tint have_extrabytes = 0;\n\tunsigned long flags;\n\n\tnuke(ep, -EPROTO);\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t \n\tif (epout_has_pkt(ep) && (ep_count_bytes_remain(ep) == 0))\n\t\tep_write_UDCCSR(ep, UDCCSR0_OPC);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tif (unlikely(ep_is_empty(ep)))\n\t\t\tgoto stall;\n\t\tu.word[i] = udc_ep_readl(ep, UDCDR);\n\t}\n\n\thave_extrabytes = !ep_is_empty(ep);\n\twhile (!ep_is_empty(ep)) {\n\t\ti = udc_ep_readl(ep, UDCDR);\n\t\tep_err(ep, \"wrong to have extra bytes for setup : 0x%08x\\n\", i);\n\t}\n\n\tep_dbg(ep, \"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\tu.r.bRequestType, u.r.bRequest,\n\t\tle16_to_cpu(u.r.wValue), le16_to_cpu(u.r.wIndex),\n\t\tle16_to_cpu(u.r.wLength));\n\tif (unlikely(have_extrabytes))\n\t\tgoto stall;\n\n\tif (u.r.bRequestType & USB_DIR_IN)\n\t\tset_ep0state(udc, IN_DATA_STAGE);\n\telse\n\t\tset_ep0state(udc, OUT_DATA_STAGE);\n\n\t \n\tep_write_UDCCSR(ep, UDCCSR0_SA | UDCCSR0_OPC);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\ti = udc->driver->setup(&udc->gadget, &u.r);\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (i < 0)\n\t\tgoto stall;\nout:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\treturn;\nstall:\n\tep_dbg(ep, \"protocol STALL, udccsr0=%03x err %d\\n\",\n\t\tudc_ep_readl(ep, UDCCSR), i);\n\tep_write_UDCCSR(ep, UDCCSR0_FST | UDCCSR0_FTF);\n\tset_ep0state(udc, STALL);\n\tgoto out;\n}\n\n \nstatic void handle_ep0(struct pxa_udc *udc, int fifo_irq, int opc_irq)\n{\n\tu32\t\t\tudccsr0;\n\tstruct pxa_ep\t\t*ep = &udc->pxa_ep[0];\n\tstruct pxa27x_request\t*req = NULL;\n\tint\t\t\tcompleted = 0;\n\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next, struct pxa27x_request, queue);\n\n\tudccsr0 = udc_ep_readl(ep, UDCCSR);\n\tep_dbg(ep, \"state=%s, req=%p, udccsr0=0x%03x, udcbcr=%d, irq_msk=%x\\n\",\n\t\tEP0_STNAME(udc), req, udccsr0, udc_ep_readl(ep, UDCBCR),\n\t\t(fifo_irq << 1 | opc_irq));\n\n\tif (udccsr0 & UDCCSR0_SST) {\n\t\tep_dbg(ep, \"clearing stall status\\n\");\n\t\tnuke(ep, -EPIPE);\n\t\tep_write_UDCCSR(ep, UDCCSR0_SST);\n\t\tep0_idle(udc);\n\t}\n\n\tif (udccsr0 & UDCCSR0_SA) {\n\t\tnuke(ep, 0);\n\t\tset_ep0state(udc, SETUP_STAGE);\n\t}\n\n\tswitch (udc->ep0state) {\n\tcase WAIT_FOR_SETUP:\n\t\t \n\t\tbreak;\n\tcase SETUP_STAGE:\n\t\tudccsr0 &= UDCCSR0_CTRL_REQ_MASK;\n\t\tif (likely(udccsr0 == UDCCSR0_CTRL_REQ_MASK))\n\t\t\thandle_ep0_ctrl_req(udc, req);\n\t\tbreak;\n\tcase IN_DATA_STAGE:\t\t\t \n\t\tif (epout_has_pkt(ep))\n\t\t\tep_write_UDCCSR(ep, UDCCSR0_OPC);\n\t\tif (req && !ep_is_full(ep))\n\t\t\tcompleted = write_ep0_fifo(ep, req);\n\t\tif (completed)\n\t\t\tep0_end_in_req(ep, req, NULL);\n\t\tbreak;\n\tcase OUT_DATA_STAGE:\t\t\t \n\t\tif (epout_has_pkt(ep) && req)\n\t\t\tcompleted = read_ep0_fifo(ep, req);\n\t\tif (completed)\n\t\t\tep0_end_out_req(ep, req, NULL);\n\t\tbreak;\n\tcase STALL:\n\t\tep_write_UDCCSR(ep, UDCCSR0_FST);\n\t\tbreak;\n\tcase IN_STATUS_STAGE:\n\t\t \n\t\tif (opc_irq)\n\t\t\tep0_idle(udc);\n\t\tbreak;\n\tcase OUT_STATUS_STAGE:\n\tcase WAIT_ACK_SET_CONF_INTERF:\n\t\tep_warn(ep, \"should never get in %s state here!!!\\n\",\n\t\t\t\tEP0_STNAME(ep->dev));\n\t\tep0_idle(udc);\n\t\tbreak;\n\t}\n}\n\n \nstatic void handle_ep(struct pxa_ep *ep)\n{\n\tstruct pxa27x_request\t*req;\n\tint completed;\n\tu32 udccsr;\n\tint is_in = ep->dir_in;\n\tint loop = 0;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep->in_handle_ep)\n\t\tgoto recursion_detected;\n\tep->in_handle_ep = 1;\n\n\tdo {\n\t\tcompleted = 0;\n\t\tudccsr = udc_ep_readl(ep, UDCCSR);\n\n\t\tif (likely(!list_empty(&ep->queue)))\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct pxa27x_request, queue);\n\t\telse\n\t\t\treq = NULL;\n\n\t\tep_dbg(ep, \"req:%p, udccsr 0x%03x loop=%d\\n\",\n\t\t\t\treq, udccsr, loop++);\n\n\t\tif (unlikely(udccsr & (UDCCSR_SST | UDCCSR_TRN)))\n\t\t\tudc_ep_writel(ep, UDCCSR,\n\t\t\t\t\tudccsr & (UDCCSR_SST | UDCCSR_TRN));\n\t\tif (!req)\n\t\t\tbreak;\n\n\t\tif (unlikely(is_in)) {\n\t\t\tif (likely(!ep_is_full(ep)))\n\t\t\t\tcompleted = write_fifo(ep, req);\n\t\t} else {\n\t\t\tif (likely(epout_has_pkt(ep)))\n\t\t\t\tcompleted = read_fifo(ep, req);\n\t\t}\n\n\t\tif (completed) {\n\t\t\tif (is_in)\n\t\t\t\tep_end_in_req(ep, req, &flags);\n\t\t\telse\n\t\t\t\tep_end_out_req(ep, req, &flags);\n\t\t}\n\t} while (completed);\n\n\tep->in_handle_ep = 0;\nrecursion_detected:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n}\n\n \nstatic void pxa27x_change_configuration(struct pxa_udc *udc, int config)\n{\n\tstruct usb_ctrlrequest req ;\n\n\tdev_dbg(udc->dev, \"config=%d\\n\", config);\n\n\tudc->config = config;\n\tudc->last_interface = 0;\n\tudc->last_alternate = 0;\n\n\treq.bRequestType = 0;\n\treq.bRequest = USB_REQ_SET_CONFIGURATION;\n\treq.wValue = config;\n\treq.wIndex = 0;\n\treq.wLength = 0;\n\n\tset_ep0state(udc, WAIT_ACK_SET_CONF_INTERF);\n\tudc->driver->setup(&udc->gadget, &req);\n\tep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_AREN);\n}\n\n \nstatic void pxa27x_change_interface(struct pxa_udc *udc, int iface, int alt)\n{\n\tstruct usb_ctrlrequest  req;\n\n\tdev_dbg(udc->dev, \"interface=%d, alternate setting=%d\\n\", iface, alt);\n\n\tudc->last_interface = iface;\n\tudc->last_alternate = alt;\n\n\treq.bRequestType = USB_RECIP_INTERFACE;\n\treq.bRequest = USB_REQ_SET_INTERFACE;\n\treq.wValue = alt;\n\treq.wIndex = iface;\n\treq.wLength = 0;\n\n\tset_ep0state(udc, WAIT_ACK_SET_CONF_INTERF);\n\tudc->driver->setup(&udc->gadget, &req);\n\tep_write_UDCCSR(&udc->pxa_ep[0], UDCCSR0_AREN);\n}\n\n \nstatic void irq_handle_data(int irq, struct pxa_udc *udc)\n{\n\tint i;\n\tstruct pxa_ep *ep;\n\tu32 udcisr0 = udc_readl(udc, UDCISR0) & UDCCISR0_EP_MASK;\n\tu32 udcisr1 = udc_readl(udc, UDCISR1) & UDCCISR1_EP_MASK;\n\n\tif (udcisr0 & UDCISR_INT_MASK) {\n\t\tudc->pxa_ep[0].stats.irqs++;\n\t\tudc_writel(udc, UDCISR0, UDCISR_INT(0, UDCISR_INT_MASK));\n\t\thandle_ep0(udc, !!(udcisr0 & UDCICR_FIFOERR),\n\t\t\t\t!!(udcisr0 & UDCICR_PKTCOMPL));\n\t}\n\n\tudcisr0 >>= 2;\n\tfor (i = 1; udcisr0 != 0 && i < 16; udcisr0 >>= 2, i++) {\n\t\tif (!(udcisr0 & UDCISR_INT_MASK))\n\t\t\tcontinue;\n\n\t\tudc_writel(udc, UDCISR0, UDCISR_INT(i, UDCISR_INT_MASK));\n\n\t\tWARN_ON(i >= ARRAY_SIZE(udc->pxa_ep));\n\t\tif (i < ARRAY_SIZE(udc->pxa_ep)) {\n\t\t\tep = &udc->pxa_ep[i];\n\t\t\tep->stats.irqs++;\n\t\t\thandle_ep(ep);\n\t\t}\n\t}\n\n\tfor (i = 16; udcisr1 != 0 && i < 24; udcisr1 >>= 2, i++) {\n\t\tudc_writel(udc, UDCISR1, UDCISR_INT(i - 16, UDCISR_INT_MASK));\n\t\tif (!(udcisr1 & UDCISR_INT_MASK))\n\t\t\tcontinue;\n\n\t\tWARN_ON(i >= ARRAY_SIZE(udc->pxa_ep));\n\t\tif (i < ARRAY_SIZE(udc->pxa_ep)) {\n\t\t\tep = &udc->pxa_ep[i];\n\t\t\tep->stats.irqs++;\n\t\t\thandle_ep(ep);\n\t\t}\n\t}\n\n}\n\n \nstatic void irq_udc_suspend(struct pxa_udc *udc)\n{\n\tudc_writel(udc, UDCISR1, UDCISR1_IRSU);\n\tudc->stats.irqs_suspend++;\n\n\tif (udc->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t&& udc->driver && udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n\tep0_idle(udc);\n}\n\n \nstatic void irq_udc_resume(struct pxa_udc *udc)\n{\n\tudc_writel(udc, UDCISR1, UDCISR1_IRRU);\n\tudc->stats.irqs_resume++;\n\n\tif (udc->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t&& udc->driver && udc->driver->resume)\n\t\tudc->driver->resume(&udc->gadget);\n}\n\n \nstatic void irq_udc_reconfig(struct pxa_udc *udc)\n{\n\tunsigned config, interface, alternate, config_change;\n\tu32 udccr = udc_readl(udc, UDCCR);\n\n\tudc_writel(udc, UDCISR1, UDCISR1_IRCC);\n\tudc->stats.irqs_reconfig++;\n\n\tconfig = (udccr & UDCCR_ACN) >> UDCCR_ACN_S;\n\tconfig_change = (config != udc->config);\n\tpxa27x_change_configuration(udc, config);\n\n\tinterface = (udccr & UDCCR_AIN) >> UDCCR_AIN_S;\n\talternate = (udccr & UDCCR_AAISN) >> UDCCR_AAISN_S;\n\tpxa27x_change_interface(udc, interface, alternate);\n\n\tif (config_change)\n\t\tupdate_pxa_ep_matches(udc);\n\tudc_set_mask_UDCCR(udc, UDCCR_SMAC);\n}\n\n \nstatic void irq_udc_reset(struct pxa_udc *udc)\n{\n\tu32 udccr = udc_readl(udc, UDCCR);\n\tstruct pxa_ep *ep = &udc->pxa_ep[0];\n\n\tdev_info(udc->dev, \"USB reset\\n\");\n\tudc_writel(udc, UDCISR1, UDCISR1_IRRS);\n\tudc->stats.irqs_reset++;\n\n\tif ((udccr & UDCCR_UDA) == 0) {\n\t\tdev_dbg(udc->dev, \"USB reset start\\n\");\n\t\tstop_activity(udc);\n\t}\n\tudc->gadget.speed = USB_SPEED_FULL;\n\tmemset(&udc->stats, 0, sizeof udc->stats);\n\n\tnuke(ep, -EPROTO);\n\tep_write_UDCCSR(ep, UDCCSR0_FTF | UDCCSR0_OPC);\n\tep0_idle(udc);\n}\n\n \nstatic irqreturn_t pxa_udc_irq(int irq, void *_dev)\n{\n\tstruct pxa_udc *udc = _dev;\n\tu32 udcisr0 = udc_readl(udc, UDCISR0);\n\tu32 udcisr1 = udc_readl(udc, UDCISR1);\n\tu32 udccr = udc_readl(udc, UDCCR);\n\tu32 udcisr1_spec;\n\n\tdev_vdbg(udc->dev, \"Interrupt, UDCISR0:0x%08x, UDCISR1:0x%08x, \"\n\t\t \"UDCCR:0x%08x\\n\", udcisr0, udcisr1, udccr);\n\n\tudcisr1_spec = udcisr1 & 0xf8000000;\n\tif (unlikely(udcisr1_spec & UDCISR1_IRSU))\n\t\tirq_udc_suspend(udc);\n\tif (unlikely(udcisr1_spec & UDCISR1_IRRU))\n\t\tirq_udc_resume(udc);\n\tif (unlikely(udcisr1_spec & UDCISR1_IRCC))\n\t\tirq_udc_reconfig(udc);\n\tif (unlikely(udcisr1_spec & UDCISR1_IRRS))\n\t\tirq_udc_reset(udc);\n\n\tif ((udcisr0 & UDCCISR0_EP_MASK) | (udcisr1 & UDCCISR1_EP_MASK))\n\t\tirq_handle_data(irq, udc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct pxa_udc memory = {\n\t.gadget = {\n\t\t.ops\t\t= &pxa_udc_ops,\n\t\t.ep0\t\t= &memory.udc_usb_ep[0].usb_ep,\n\t\t.name\t\t= driver_name,\n\t\t.dev = {\n\t\t\t.init_name\t= \"gadget\",\n\t\t},\n\t},\n\n\t.udc_usb_ep = {\n\t\tUSB_EP_CTRL,\n\t\tUSB_EP_OUT_BULK(1),\n\t\tUSB_EP_IN_BULK(2),\n\t\tUSB_EP_IN_ISO(3),\n\t\tUSB_EP_OUT_ISO(4),\n\t\tUSB_EP_IN_INT(5),\n\t},\n\n\t.pxa_ep = {\n\t\tPXA_EP_CTRL,\n\t\t \n\t\tPXA_EP_OUT_BULK(1, 1, 3, 0, 0),\n\t\tPXA_EP_IN_BULK(2,  2, 3, 0, 0),\n\t\t \n\t\tPXA_EP_OUT_BULK(3, 1, 1, 0, 0),\n\t\tPXA_EP_IN_BULK(4,  2, 1, 0, 0),\n\t\tPXA_EP_IN_ISO(5,   3, 1, 0, 0),\n\t\tPXA_EP_OUT_ISO(6,  4, 1, 0, 0),\n\t\tPXA_EP_IN_INT(7,   5, 1, 0, 0),\n\t\t \n\t\tPXA_EP_OUT_BULK(8, 1, 2, 0, 0),\n\t\tPXA_EP_IN_BULK(9,  2, 2, 0, 0),\n\t\tPXA_EP_IN_INT(10,  5, 2, 0, 0),\n\t\t \n\t\tPXA_EP_OUT_BULK(11, 1, 2, 1, 0),\n\t\tPXA_EP_IN_BULK(12,  2, 2, 1, 0),\n\t\t \n\t\tPXA_EP_OUT_BULK(13, 1, 1, 1, 1),\n\t\tPXA_EP_IN_BULK(14,  2, 1, 1, 1),\n\t}\n};\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id udc_pxa_dt_ids[] = {\n\t{ .compatible = \"marvell,pxa270-udc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, udc_pxa_dt_ids);\n#endif\n\n \nstatic int pxa_udc_probe(struct platform_device *pdev)\n{\n\tstruct pxa_udc *udc = &memory;\n\tint retval = 0, gpio;\n\tstruct pxa2xx_udc_mach_info *mach = dev_get_platdata(&pdev->dev);\n\tunsigned long gpio_flags;\n\n\tif (mach) {\n\t\tgpio_flags = mach->gpio_pullup_inverted ? GPIOF_ACTIVE_LOW : 0;\n\t\tgpio = mach->gpio_pullup;\n\t\tif (gpio_is_valid(gpio)) {\n\t\t\tretval = devm_gpio_request_one(&pdev->dev, gpio,\n\t\t\t\t\t\t       gpio_flags,\n\t\t\t\t\t\t       \"USB D+ pullup\");\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t\tudc->gpiod = gpio_to_desc(mach->gpio_pullup);\n\t\t}\n\t\tudc->udc_command = mach->udc_command;\n\t} else {\n\t\tudc->gpiod = devm_gpiod_get(&pdev->dev, NULL, GPIOD_ASIS);\n\t}\n\n\tudc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->regs))\n\t\treturn PTR_ERR(udc->regs);\n\tudc->irq = platform_get_irq(pdev, 0);\n\tif (udc->irq < 0)\n\t\treturn udc->irq;\n\n\tudc->dev = &pdev->dev;\n\tif (of_have_populated_dt()) {\n\t\tudc->transceiver =\n\t\t\tdevm_usb_get_phy_by_phandle(udc->dev, \"phys\", 0);\n\t\tif (IS_ERR(udc->transceiver))\n\t\t\treturn PTR_ERR(udc->transceiver);\n\t} else {\n\t\tudc->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\n\t}\n\n\tif (IS_ERR(udc->gpiod)) {\n\t\tdev_err(&pdev->dev, \"Couldn't find or request D+ gpio : %ld\\n\",\n\t\t\tPTR_ERR(udc->gpiod));\n\t\treturn PTR_ERR(udc->gpiod);\n\t}\n\tif (udc->gpiod)\n\t\tgpiod_direction_output(udc->gpiod, 0);\n\n\tudc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(udc->clk))\n\t\treturn PTR_ERR(udc->clk);\n\n\tretval = clk_prepare(udc->clk);\n\tif (retval)\n\t\treturn retval;\n\n\tudc->vbus_sensed = 0;\n\n\tthe_controller = udc;\n\tplatform_set_drvdata(pdev, udc);\n\tudc_init_data(udc);\n\n\t \n\tretval = devm_request_irq(&pdev->dev, udc->irq, pxa_udc_irq,\n\t\t\t\t  IRQF_SHARED, driver_name, udc);\n\tif (retval != 0) {\n\t\tdev_err(udc->dev, \"%s: can't get irq %i, err %d\\n\",\n\t\t\tdriver_name, udc->irq, retval);\n\t\tgoto err;\n\t}\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\tusb_register_notifier(udc->transceiver, &pxa27x_udc_phy);\n\tretval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (retval)\n\t\tgoto err_add_gadget;\n\n\tpxa_init_debugfs(udc);\n\tif (should_enable_udc(udc))\n\t\tudc_enable(udc);\n\treturn 0;\n\nerr_add_gadget:\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\tusb_unregister_notifier(udc->transceiver, &pxa27x_udc_phy);\nerr:\n\tclk_unprepare(udc->clk);\n\treturn retval;\n}\n\n \nstatic void pxa_udc_remove(struct platform_device *_dev)\n{\n\tstruct pxa_udc *udc = platform_get_drvdata(_dev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tpxa_cleanup_debugfs(udc);\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver)) {\n\t\tusb_unregister_notifier(udc->transceiver, &pxa27x_udc_phy);\n\t\tusb_put_phy(udc->transceiver);\n\t}\n\n\tudc->transceiver = NULL;\n\tthe_controller = NULL;\n\tclk_unprepare(udc->clk);\n}\n\nstatic void pxa_udc_shutdown(struct platform_device *_dev)\n{\n\tstruct pxa_udc *udc = platform_get_drvdata(_dev);\n\n\tif (udc_readl(udc, UDCCR) & UDCCR_UDE)\n\t\tudc_disable(udc);\n}\n\n#ifdef CONFIG_PM\n \nstatic int pxa_udc_suspend(struct platform_device *_dev, pm_message_t state)\n{\n\tstruct pxa_udc *udc = platform_get_drvdata(_dev);\n\tstruct pxa_ep *ep;\n\n\tep = &udc->pxa_ep[0];\n\tudc->udccsr0 = udc_ep_readl(ep, UDCCSR);\n\n\tudc_disable(udc);\n\tudc->pullup_resume = udc->pullup_on;\n\tdplus_pullup(udc, 0);\n\n\tif (udc->driver)\n\t\tudc->driver->disconnect(&udc->gadget);\n\n\treturn 0;\n}\n\n \nstatic int pxa_udc_resume(struct platform_device *_dev)\n{\n\tstruct pxa_udc *udc = platform_get_drvdata(_dev);\n\tstruct pxa_ep *ep;\n\n\tep = &udc->pxa_ep[0];\n\tudc_ep_writel(ep, UDCCSR, udc->udccsr0 & (UDCCSR0_FST | UDCCSR0_DME));\n\n\tdplus_pullup(udc, udc->pullup_resume);\n\tif (should_enable_udc(udc))\n\t\tudc_enable(udc);\n\t \n\tpxa27x_clear_otgph();\n\n\treturn 0;\n}\n#endif\n\n \nMODULE_ALIAS(\"platform:pxa27x-udc\");\n\nstatic struct platform_driver udc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"pxa27x-udc\",\n\t\t.of_match_table = of_match_ptr(udc_pxa_dt_ids),\n\t},\n\t.probe\t\t= pxa_udc_probe,\n\t.remove_new\t= pxa_udc_remove,\n\t.shutdown\t= pxa_udc_shutdown,\n#ifdef CONFIG_PM\n\t.suspend\t= pxa_udc_suspend,\n\t.resume\t\t= pxa_udc_resume\n#endif\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Robert Jarzmik\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}