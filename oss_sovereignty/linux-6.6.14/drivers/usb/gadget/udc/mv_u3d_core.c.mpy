{
  "module_name": "mv_u3d_core.c",
  "hash_id": "2482819594676bf85343405329ce2644aeea5efc57fafdf6a4812cf4286fda54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/mv_u3d_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/notifier.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/pm.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/mv_usb.h>\n#include <linux/clk.h>\n\n#include \"mv_u3d.h\"\n\n#define DRIVER_DESC\t\t\"Marvell PXA USB3.0 Device Controller driver\"\n\nstatic const char driver_name[] = \"mv_u3d\";\n\nstatic void mv_u3d_nuke(struct mv_u3d_ep *ep, int status);\nstatic void mv_u3d_stop_activity(struct mv_u3d *u3d,\n\t\t\tstruct usb_gadget_driver *driver);\n\n \nstatic const struct usb_endpoint_descriptor mv_u3d_ep0_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\t0,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize =\tMV_U3D_EP0_MAX_PKT_SIZE,\n};\n\nstatic void mv_u3d_ep0_reset(struct mv_u3d *u3d)\n{\n\tstruct mv_u3d_ep *ep;\n\tu32 epxcr;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tep = &u3d->eps[i];\n\t\tep->u3d = u3d;\n\n\t\t \n\t\tep->ep_context = &u3d->ep_context[1];\n\t}\n\n\t \n\t \n\tepxcr = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\n\tepxcr |= MV_U3D_EPXCR_EP_INIT;\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr0);\n\tudelay(5);\n\tepxcr &= ~MV_U3D_EPXCR_EP_INIT;\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr0);\n\n\tepxcr = ((MV_U3D_EP0_MAX_PKT_SIZE\n\t\t<< MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\n\t\t| (1 << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\n\t\t| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t| MV_U3D_EPXCR_EP_TYPE_CONTROL);\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxoutcr1);\n\n\t \n\tepxcr = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\n\tepxcr |= MV_U3D_EPXCR_EP_INIT;\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr0);\n\tudelay(5);\n\tepxcr &= ~MV_U3D_EPXCR_EP_INIT;\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr0);\n\n\tepxcr = ((MV_U3D_EP0_MAX_PKT_SIZE\n\t\t<< MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\n\t\t| (1 << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\n\t\t| (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t| MV_U3D_EPXCR_EP_TYPE_CONTROL);\n\tiowrite32(epxcr, &u3d->vuc_regs->epcr[0].epxincr1);\n}\n\nstatic void mv_u3d_ep0_stall(struct mv_u3d *u3d)\n{\n\tu32 tmp;\n\tdev_dbg(u3d->dev, \"%s\\n\", __func__);\n\n\t \n\ttmp = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\n\ttmp |= MV_U3D_EPXCR_EP_HALT;\n\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\n\n\ttmp = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\n\ttmp |= MV_U3D_EPXCR_EP_HALT;\n\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\n\n\t \n\tu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\n\tu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\n}\n\nstatic int mv_u3d_process_ep_req(struct mv_u3d *u3d, int index,\n\tstruct mv_u3d_req *curr_req)\n{\n\tstruct mv_u3d_trb\t*curr_trb;\n\tint actual, remaining_length = 0;\n\tint direction, ep_num;\n\tint retval = 0;\n\tu32 tmp, status, length;\n\n\tdirection = index % 2;\n\tep_num = index / 2;\n\n\tactual = curr_req->req.length;\n\n\twhile (!list_empty(&curr_req->trb_list)) {\n\t\tcurr_trb = list_entry(curr_req->trb_list.next,\n\t\t\t\t\tstruct mv_u3d_trb, trb_list);\n\t\tif (!curr_trb->trb_hw->ctrl.own) {\n\t\t\tdev_err(u3d->dev, \"%s, TRB own error!\\n\",\n\t\t\t\tu3d->eps[index].name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tcurr_trb->trb_hw->ctrl.own = 0;\n\t\tif (direction == MV_U3D_EP_DIR_OUT)\n\t\t\ttmp = ioread32(&u3d->vuc_regs->rxst[ep_num].statuslo);\n\t\telse\n\t\t\ttmp = ioread32(&u3d->vuc_regs->txst[ep_num].statuslo);\n\n\t\tstatus = tmp >> MV_U3D_XFERSTATUS_COMPLETE_SHIFT;\n\t\tlength = tmp & MV_U3D_XFERSTATUS_TRB_LENGTH_MASK;\n\n\t\tif (status == MV_U3D_COMPLETE_SUCCESS ||\n\t\t\t(status == MV_U3D_COMPLETE_SHORT_PACKET &&\n\t\t\tdirection == MV_U3D_EP_DIR_OUT)) {\n\t\t\tremaining_length += length;\n\t\t\tactual -= remaining_length;\n\t\t} else {\n\t\t\tdev_err(u3d->dev,\n\t\t\t\t\"complete_tr error: ep=%d %s: error = 0x%x\\n\",\n\t\t\t\tindex >> 1, direction ? \"SEND\" : \"RECV\",\n\t\t\t\tstatus);\n\t\t\tretval = -EPROTO;\n\t\t}\n\n\t\tlist_del_init(&curr_trb->trb_list);\n\t}\n\tif (retval)\n\t\treturn retval;\n\n\tcurr_req->req.actual = actual;\n\treturn 0;\n}\n\n \nstatic\nvoid mv_u3d_done(struct mv_u3d_ep *ep, struct mv_u3d_req *req, int status)\n\t__releases(&ep->udc->lock)\n\t__acquires(&ep->udc->lock)\n{\n\tstruct mv_u3d *u3d = (struct mv_u3d *)ep->u3d;\n\n\tdev_dbg(u3d->dev, \"mv_u3d_done: remove req->queue\\n\");\n\t \n\tlist_del_init(&req->queue);\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\t \n\tif (!req->chain)\n\t\tdma_pool_free(u3d->trb_pool,\n\t\t\treq->trb_head->trb_hw, req->trb_head->trb_dma);\n\telse {\n\t\tdma_unmap_single(ep->u3d->gadget.dev.parent,\n\t\t\t(dma_addr_t)req->trb_head->trb_dma,\n\t\t\treq->trb_count * sizeof(struct mv_u3d_trb_hw),\n\t\t\tDMA_BIDIRECTIONAL);\n\t\tkfree(req->trb_head->trb_hw);\n\t}\n\tkfree(req->trb_head);\n\n\tusb_gadget_unmap_request(&u3d->gadget, &req->req, mv_u3d_ep_dir(ep));\n\n\tif (status && (status != -ESHUTDOWN)) {\n\t\tdev_dbg(u3d->dev, \"complete %s req %p stat %d len %u/%u\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\t}\n\n\tspin_unlock(&ep->u3d->lock);\n\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\n\tspin_lock(&ep->u3d->lock);\n}\n\nstatic int mv_u3d_queue_trb(struct mv_u3d_ep *ep, struct mv_u3d_req *req)\n{\n\tu32 tmp, direction;\n\tstruct mv_u3d *u3d;\n\tstruct mv_u3d_ep_context *ep_context;\n\tint retval = 0;\n\n\tu3d = ep->u3d;\n\tdirection = mv_u3d_ep_dir(ep);\n\n\t \n\tif (ep->ep_num == 0)\n\t\tep_context = &(u3d->ep_context[1]);\n\telse\n\t\tep_context = &(u3d->ep_context[ep->ep_num * 2 + direction]);\n\n\t \n\tif (!list_empty(&ep->queue)) {\n\t\tdev_err(u3d->dev, \"add trb to non-empty queue!\\n\");\n\t\tretval = -ENOMEM;\n\t\tWARN_ON(1);\n\t} else {\n\t\tep_context->rsvd0 = cpu_to_le32(1);\n\t\tep_context->rsvd1 = 0;\n\n\t\t \n\t\tep_context->trb_addr_lo =\n\t\t\tcpu_to_le32(req->trb_head->trb_dma | DCS_ENABLE);\n\t\tep_context->trb_addr_hi = 0;\n\n\t\t \n\t\twmb();\n\n\t\t \n\t\tif (ep->ep_num == 0)\n\t\t\ttmp = 0x1;\n\t\telse\n\t\t\ttmp = ep->ep_num * 2\n\t\t\t\t+ ((direction == MV_U3D_EP_DIR_OUT) ? 0 : 1);\n\n\t\tiowrite32(tmp, &u3d->op_regs->doorbell);\n\t}\n\treturn retval;\n}\n\nstatic struct mv_u3d_trb *mv_u3d_build_trb_one(struct mv_u3d_req *req,\n\t\t\t\tunsigned *length, dma_addr_t *dma)\n{\n\tu32 temp;\n\tunsigned int direction;\n\tstruct mv_u3d_trb *trb;\n\tstruct mv_u3d_trb_hw *trb_hw;\n\tstruct mv_u3d *u3d;\n\n\t \n\t*length = req->req.length - req->req.actual;\n\tBUG_ON(*length > (unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER);\n\n\tu3d = req->ep->u3d;\n\n\ttrb = kzalloc(sizeof(*trb), GFP_ATOMIC);\n\tif (!trb)\n\t\treturn NULL;\n\n\t \n\ttrb_hw = dma_pool_alloc(u3d->trb_pool, GFP_ATOMIC, dma);\n\tif (!trb_hw) {\n\t\tkfree(trb);\n\t\tdev_err(u3d->dev,\n\t\t\t\"%s, dma_pool_alloc fail\\n\", __func__);\n\t\treturn NULL;\n\t}\n\ttrb->trb_dma = *dma;\n\ttrb->trb_hw = trb_hw;\n\n\t \n\ttemp = (u32)(req->req.dma + req->req.actual);\n\n\ttrb_hw->buf_addr_lo = cpu_to_le32(temp);\n\ttrb_hw->buf_addr_hi = 0;\n\ttrb_hw->trb_len = cpu_to_le32(*length);\n\ttrb_hw->ctrl.own = 1;\n\n\tif (req->ep->ep_num == 0)\n\t\ttrb_hw->ctrl.type = TYPE_DATA;\n\telse\n\t\ttrb_hw->ctrl.type = TYPE_NORMAL;\n\n\treq->req.actual += *length;\n\n\tdirection = mv_u3d_ep_dir(req->ep);\n\tif (direction == MV_U3D_EP_DIR_IN)\n\t\ttrb_hw->ctrl.dir = 1;\n\telse\n\t\ttrb_hw->ctrl.dir = 0;\n\n\t \n\tif (!req->req.no_interrupt)\n\t\ttrb_hw->ctrl.ioc = 1;\n\n\ttrb_hw->ctrl.chain = 0;\n\n\twmb();\n\treturn trb;\n}\n\nstatic int mv_u3d_build_trb_chain(struct mv_u3d_req *req, unsigned *length,\n\t\tstruct mv_u3d_trb *trb, int *is_last)\n{\n\tu32 temp;\n\tunsigned int direction;\n\tstruct mv_u3d *u3d;\n\n\t \n\t*length = min(req->req.length - req->req.actual,\n\t\t\t(unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER);\n\n\tu3d = req->ep->u3d;\n\n\ttrb->trb_dma = 0;\n\n\t \n\ttemp = (u32)(req->req.dma + req->req.actual);\n\n\ttrb->trb_hw->buf_addr_lo = cpu_to_le32(temp);\n\ttrb->trb_hw->buf_addr_hi = 0;\n\ttrb->trb_hw->trb_len = cpu_to_le32(*length);\n\ttrb->trb_hw->ctrl.own = 1;\n\n\tif (req->ep->ep_num == 0)\n\t\ttrb->trb_hw->ctrl.type = TYPE_DATA;\n\telse\n\t\ttrb->trb_hw->ctrl.type = TYPE_NORMAL;\n\n\treq->req.actual += *length;\n\n\tdirection = mv_u3d_ep_dir(req->ep);\n\tif (direction == MV_U3D_EP_DIR_IN)\n\t\ttrb->trb_hw->ctrl.dir = 1;\n\telse\n\t\ttrb->trb_hw->ctrl.dir = 0;\n\n\t \n\tif (req->req.zero) {\n\t\tif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\n\t\t\t*is_last = 1;\n\t\telse\n\t\t\t*is_last = 0;\n\t} else if (req->req.length == req->req.actual)\n\t\t*is_last = 1;\n\telse\n\t\t*is_last = 0;\n\n\t \n\tif (*is_last && !req->req.no_interrupt)\n\t\ttrb->trb_hw->ctrl.ioc = 1;\n\n\tif (*is_last)\n\t\ttrb->trb_hw->ctrl.chain = 0;\n\telse {\n\t\ttrb->trb_hw->ctrl.chain = 1;\n\t\tdev_dbg(u3d->dev, \"chain trb\\n\");\n\t}\n\n\twmb();\n\n\treturn 0;\n}\n\n \nstatic int mv_u3d_req_to_trb(struct mv_u3d_req *req)\n{\n\tunsigned count;\n\tint is_last;\n\tstruct mv_u3d_trb *trb;\n\tstruct mv_u3d_trb_hw *trb_hw;\n\tstruct mv_u3d *u3d;\n\tdma_addr_t dma;\n\tunsigned length;\n\tunsigned trb_num;\n\n\tu3d = req->ep->u3d;\n\n\tINIT_LIST_HEAD(&req->trb_list);\n\n\tlength = req->req.length - req->req.actual;\n\t \n\tif (length <= (unsigned)MV_U3D_EP_MAX_LENGTH_TRANSFER) {\n\t\ttrb = mv_u3d_build_trb_one(req, &count, &dma);\n\t\tlist_add_tail(&trb->trb_list, &req->trb_list);\n\t\treq->trb_head = trb;\n\t\treq->trb_count = 1;\n\t\treq->chain = 0;\n\t} else {\n\t\ttrb_num = length / MV_U3D_EP_MAX_LENGTH_TRANSFER;\n\t\tif (length % MV_U3D_EP_MAX_LENGTH_TRANSFER)\n\t\t\ttrb_num++;\n\n\t\ttrb = kcalloc(trb_num, sizeof(*trb), GFP_ATOMIC);\n\t\tif (!trb)\n\t\t\treturn -ENOMEM;\n\n\t\ttrb_hw = kcalloc(trb_num, sizeof(*trb_hw), GFP_ATOMIC);\n\t\tif (!trb_hw) {\n\t\t\tkfree(trb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdo {\n\t\t\ttrb->trb_hw = trb_hw;\n\t\t\tif (mv_u3d_build_trb_chain(req, &count,\n\t\t\t\t\t\ttrb, &is_last)) {\n\t\t\t\tdev_err(u3d->dev,\n\t\t\t\t\t\"%s, mv_u3d_build_trb_chain fail\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tlist_add_tail(&trb->trb_list, &req->trb_list);\n\t\t\treq->trb_count++;\n\t\t\ttrb++;\n\t\t\ttrb_hw++;\n\t\t} while (!is_last);\n\n\t\treq->trb_head = list_entry(req->trb_list.next,\n\t\t\t\t\tstruct mv_u3d_trb, trb_list);\n\t\treq->trb_head->trb_dma = dma_map_single(u3d->gadget.dev.parent,\n\t\t\t\t\treq->trb_head->trb_hw,\n\t\t\t\t\ttrb_num * sizeof(*trb_hw),\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(u3d->gadget.dev.parent,\n\t\t\t\t\treq->trb_head->trb_dma)) {\n\t\t\tkfree(req->trb_head->trb_hw);\n\t\t\tkfree(req->trb_head);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->chain = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmv_u3d_start_queue(struct mv_u3d_ep *ep)\n{\n\tstruct mv_u3d *u3d = ep->u3d;\n\tstruct mv_u3d_req *req;\n\tint ret;\n\n\tif (!list_empty(&ep->req_list) && !ep->processing)\n\t\treq = list_entry(ep->req_list.next, struct mv_u3d_req, list);\n\telse\n\t\treturn 0;\n\n\tep->processing = 1;\n\n\t \n\tret = usb_gadget_map_request(&u3d->gadget, &req->req,\n\t\t\t\t\tmv_u3d_ep_dir(ep));\n\tif (ret)\n\t\tgoto break_processing;\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->trb_count = 0;\n\n\t \n\tret = mv_u3d_req_to_trb(req);\n\tif (ret) {\n\t\tdev_err(u3d->dev, \"%s, mv_u3d_req_to_trb fail\\n\", __func__);\n\t\tgoto break_processing;\n\t}\n\n\t \n\tret = mv_u3d_queue_trb(ep, req);\n\tif (ret)\n\t\tgoto break_processing;\n\n\t \n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treturn 0;\n\nbreak_processing:\n\tep->processing = 0;\n\treturn ret;\n}\n\nstatic int mv_u3d_ep_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct mv_u3d *u3d;\n\tstruct mv_u3d_ep *ep;\n\tu16 max = 0;\n\tunsigned maxburst = 0;\n\tu32 epxcr, direction;\n\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tep = container_of(_ep, struct mv_u3d_ep, ep);\n\tu3d = ep->u3d;\n\n\tif (!u3d->driver || u3d->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tdirection = mv_u3d_ep_dir(ep);\n\tmax = le16_to_cpu(desc->wMaxPacketSize);\n\n\tif (!_ep->maxburst)\n\t\t_ep->maxburst = 1;\n\tmaxburst = _ep->maxburst;\n\n\t \n\tswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (maxburst > 16) {\n\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t\"max burst should not be greater \"\n\t\t\t\t\"than 16 on bulk ep\\n\");\n\t\t\tmaxburst = 1;\n\t\t\t_ep->maxburst = maxburst;\n\t\t}\n\t\tdev_dbg(u3d->dev,\n\t\t\t\"maxburst: %d on bulk %s\\n\", maxburst, ep->name);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\tmaxburst = 1;\n\t\t_ep->maxburst = maxburst;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (maxburst != 1) {\n\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t\"max burst should be 1 on int ep \"\n\t\t\t\t\"if transfer size is not 1024\\n\");\n\t\t\tmaxburst = 1;\n\t\t\t_ep->maxburst = maxburst;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (maxburst != 1) {\n\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t\"max burst should be 1 on isoc ep \"\n\t\t\t\t\"if transfer size is not 1024\\n\");\n\t\t\tmaxburst = 1;\n\t\t\t_ep->maxburst = maxburst;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto en_done;\n\t}\n\n\tep->ep.maxpacket = max;\n\tep->ep.desc = desc;\n\tep->enabled = 1;\n\n\t \n\tif (direction == MV_U3D_EP_DIR_OUT) {\n\t\tepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\t\tepxcr |= MV_U3D_EPXCR_EP_INIT;\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\t\tudelay(5);\n\t\tepxcr &= ~MV_U3D_EPXCR_EP_INIT;\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\n\t\tepxcr = ((max << MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\n\t\t      | ((maxburst - 1) << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\n\t\t      | (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t      | (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\n\t} else {\n\t\tepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\t\tepxcr |= MV_U3D_EPXCR_EP_INIT;\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\t\tudelay(5);\n\t\tepxcr &= ~MV_U3D_EPXCR_EP_INIT;\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\n\t\tepxcr = ((max << MV_U3D_EPXCR_MAX_PACKET_SIZE_SHIFT)\n\t\t      | ((maxburst - 1) << MV_U3D_EPXCR_MAX_BURST_SIZE_SHIFT)\n\t\t      | (1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t      | (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK));\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\n\t}\n\n\treturn 0;\nen_done:\n\treturn -EINVAL;\n}\n\nstatic int  mv_u3d_ep_disable(struct usb_ep *_ep)\n{\n\tstruct mv_u3d *u3d;\n\tstruct mv_u3d_ep *ep;\n\tu32 epxcr, direction;\n\tunsigned long flags;\n\n\tif (!_ep)\n\t\treturn -EINVAL;\n\n\tep = container_of(_ep, struct mv_u3d_ep, ep);\n\tif (!ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tu3d = ep->u3d;\n\n\tdirection = mv_u3d_ep_dir(ep);\n\n\t \n\tspin_lock_irqsave(&u3d->lock, flags);\n\tmv_u3d_nuke(ep, -ESHUTDOWN);\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\n\t \n\tif (direction == MV_U3D_EP_DIR_OUT) {\n\t\tepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\n\t\tepxcr &= ~((1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t      | USB_ENDPOINT_XFERTYPE_MASK);\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr1);\n\t} else {\n\t\tepxcr = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\n\t\tepxcr &= ~((1 << MV_U3D_EPXCR_EP_ENABLE_SHIFT)\n\t\t      | USB_ENDPOINT_XFERTYPE_MASK);\n\t\tiowrite32(epxcr, &u3d->vuc_regs->epcr[ep->ep_num].epxincr1);\n\t}\n\n\tep->enabled = 0;\n\n\tep->ep.desc = NULL;\n\treturn 0;\n}\n\nstatic struct usb_request *\nmv_u3d_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct mv_u3d_req *req;\n\n\treq = kzalloc(sizeof *req, gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void mv_u3d_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct mv_u3d_req *req = container_of(_req, struct mv_u3d_req, req);\n\n\tkfree(req);\n}\n\nstatic void mv_u3d_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct mv_u3d *u3d;\n\tu32 direction;\n\tstruct mv_u3d_ep *ep = container_of(_ep, struct mv_u3d_ep, ep);\n\tunsigned int loops;\n\tu32 tmp;\n\n\t \n\tif (!ep->enabled)\n\t\treturn;\n\n\tu3d = ep->u3d;\n\tdirection = mv_u3d_ep_dir(ep);\n\n\t \n\tif (!ep->ep_num) {\n\t\tif (direction == MV_U3D_EP_DIR_OUT) {\n\t\t\ttmp = ioread32(&u3d->vuc_regs->epcr[0].epxoutcr0);\n\t\t\ttmp |= MV_U3D_EPXCR_EP_FLUSH;\n\t\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\n\t\t\tudelay(10);\n\t\t\ttmp &= ~MV_U3D_EPXCR_EP_FLUSH;\n\t\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxoutcr0);\n\t\t} else {\n\t\t\ttmp = ioread32(&u3d->vuc_regs->epcr[0].epxincr0);\n\t\t\ttmp |= MV_U3D_EPXCR_EP_FLUSH;\n\t\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\n\t\t\tudelay(10);\n\t\t\ttmp &= ~MV_U3D_EPXCR_EP_FLUSH;\n\t\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[0].epxincr0);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (direction == MV_U3D_EP_DIR_OUT) {\n\t\ttmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\t\ttmp |= MV_U3D_EPXCR_EP_FLUSH;\n\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\n\t\t \n\t\tloops = LOOPS(MV_U3D_FLUSH_TIMEOUT);\n\t\twhile (ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0) &\n\t\t\tMV_U3D_EPXCR_EP_FLUSH) {\n\t\t\t \n\t\t\tif (loops == 0) {\n\t\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t    \"EP FLUSH TIMEOUT for ep%d%s\\n\", ep->ep_num,\n\t\t\t\t    direction ? \"in\" : \"out\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tloops--;\n\t\t\tudelay(LOOPS_USEC);\n\t\t}\n\t} else {\t \n\t\ttmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\t\ttmp |= MV_U3D_EPXCR_EP_FLUSH;\n\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\n\t\t \n\t\tloops = LOOPS(MV_U3D_FLUSH_TIMEOUT);\n\t\twhile (ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0) &\n\t\t\tMV_U3D_EPXCR_EP_FLUSH) {\n\t\t\t \n\t\t\tif (loops == 0) {\n\t\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t    \"EP FLUSH TIMEOUT for ep%d%s\\n\", ep->ep_num,\n\t\t\t\t    direction ? \"in\" : \"out\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tloops--;\n\t\t\tudelay(LOOPS_USEC);\n\t\t}\n\t}\n}\n\n \nstatic int\nmv_u3d_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct mv_u3d_ep *ep;\n\tstruct mv_u3d_req *req;\n\tstruct mv_u3d *u3d;\n\tunsigned long flags;\n\tint is_first_req = 0;\n\n\tif (unlikely(!_ep || !_req))\n\t\treturn -EINVAL;\n\n\tep = container_of(_ep, struct mv_u3d_ep, ep);\n\tu3d = ep->u3d;\n\n\treq = container_of(_req, struct mv_u3d_req, req);\n\n\tif (!ep->ep_num\n\t\t&& u3d->ep0_state == MV_U3D_STATUS_STAGE\n\t\t&& !_req->length) {\n\t\tdev_dbg(u3d->dev, \"ep0 status stage\\n\");\n\t\tu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(u3d->dev, \"%s: %s, req: 0x%p\\n\",\n\t\t\t__func__, _ep->name, req);\n\n\t \n\tif (!req->req.complete || !req->req.buf\n\t\t\t|| !list_empty(&req->queue)) {\n\t\tdev_err(u3d->dev,\n\t\t\t\"%s, bad params, _req: 0x%p,\"\n\t\t\t\"req->req.complete: 0x%p, req->req.buf: 0x%p,\"\n\t\t\t\"list_empty: 0x%x\\n\",\n\t\t\t__func__, _req,\n\t\t\treq->req.complete, req->req.buf,\n\t\t\tlist_empty(&req->queue));\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(!ep->ep.desc)) {\n\t\tdev_err(u3d->dev, \"%s, bad ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tif (req->req.length > ep->ep.maxpacket)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tif (!u3d->driver || u3d->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_err(u3d->dev,\n\t\t\t\"bad params of driver/speed\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\treq->ep = ep;\n\n\t \n\tspin_lock_irqsave(&ep->req_lock, flags);\n\tis_first_req = list_empty(&ep->req_list);\n\tlist_add_tail(&req->list, &ep->req_list);\n\tspin_unlock_irqrestore(&ep->req_lock, flags);\n\tif (!is_first_req) {\n\t\tdev_dbg(u3d->dev, \"list is not empty\\n\");\n\t\treturn 0;\n\t}\n\n\tdev_dbg(u3d->dev, \"call mv_u3d_start_queue from usb_ep_queue\\n\");\n\tspin_lock_irqsave(&u3d->lock, flags);\n\tmv_u3d_start_queue(ep);\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\treturn 0;\n}\n\n \nstatic int mv_u3d_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct mv_u3d_ep *ep;\n\tstruct mv_u3d_req *req = NULL, *iter;\n\tstruct mv_u3d *u3d;\n\tstruct mv_u3d_ep_context *ep_context;\n\tstruct mv_u3d_req *next_req;\n\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tep = container_of(_ep, struct mv_u3d_ep, ep);\n\tu3d = ep->u3d;\n\n\tspin_lock_irqsave(&ep->u3d->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\t_req->status = -ECONNRESET;\n\t\tmv_u3d_ep_fifo_flush(_ep);\n\n\t\t \n\t\tif (req->queue.next != &ep->queue) {\n\t\t\tdev_dbg(u3d->dev,\n\t\t\t\t\"it is the last request in this ep queue\\n\");\n\t\t\tep_context = ep->ep_context;\n\t\t\tnext_req = list_entry(req->queue.next,\n\t\t\t\t\tstruct mv_u3d_req, queue);\n\n\t\t\t \n\t\t\tiowrite32((unsigned long) next_req->trb_head,\n\t\t\t\t\t&ep_context->trb_addr_lo);\n\t\t} else {\n\t\t\tstruct mv_u3d_ep_context *ep_context;\n\t\t\tep_context = ep->ep_context;\n\t\t\tep_context->trb_addr_lo = 0;\n\t\t\tep_context->trb_addr_hi = 0;\n\t\t}\n\n\t} else\n\t\tWARN_ON(1);\n\n\tmv_u3d_done(ep, req, -ECONNRESET);\n\n\t \n\tif (!list_empty(&ep->req_list)) {\n\t\tstruct mv_u3d_req *curr_req;\n\t\tcurr_req = list_entry(ep->req_list.next,\n\t\t\t\t\tstruct mv_u3d_req, list);\n\t\tif (curr_req == req) {\n\t\t\tlist_del_init(&req->list);\n\t\t\tep->processing = 0;\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&ep->u3d->lock, flags);\n\treturn ret;\n}\n\nstatic void\nmv_u3d_ep_set_stall(struct mv_u3d *u3d, u8 ep_num, u8 direction, int stall)\n{\n\tu32 tmp;\n\tstruct mv_u3d_ep *ep = u3d->eps;\n\n\tdev_dbg(u3d->dev, \"%s\\n\", __func__);\n\tif (direction == MV_U3D_EP_DIR_OUT) {\n\t\ttmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\t\tif (stall)\n\t\t\ttmp |= MV_U3D_EPXCR_EP_HALT;\n\t\telse\n\t\t\ttmp &= ~MV_U3D_EPXCR_EP_HALT;\n\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxoutcr0);\n\t} else {\n\t\ttmp = ioread32(&u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\t\tif (stall)\n\t\t\ttmp |= MV_U3D_EPXCR_EP_HALT;\n\t\telse\n\t\t\ttmp &= ~MV_U3D_EPXCR_EP_HALT;\n\t\tiowrite32(tmp, &u3d->vuc_regs->epcr[ep->ep_num].epxincr0);\n\t}\n}\n\nstatic int mv_u3d_ep_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\n{\n\tstruct mv_u3d_ep *ep;\n\tunsigned long flags;\n\tint status = 0;\n\tstruct mv_u3d *u3d;\n\n\tep = container_of(_ep, struct mv_u3d_ep, ep);\n\tu3d = ep->u3d;\n\tif (!ep->ep.desc) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tstatus = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (halt && (mv_u3d_ep_dir(ep) == MV_U3D_EP_DIR_IN)\n\t\t\t&& !list_empty(&ep->queue)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ep->u3d->lock, flags);\n\tmv_u3d_ep_set_stall(u3d, ep->ep_num, mv_u3d_ep_dir(ep), halt);\n\tif (halt && wedge)\n\t\tep->wedge = 1;\n\telse if (!halt)\n\t\tep->wedge = 0;\n\tspin_unlock_irqrestore(&ep->u3d->lock, flags);\n\n\tif (ep->ep_num == 0)\n\t\tu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\nout:\n\treturn status;\n}\n\nstatic int mv_u3d_ep_set_halt(struct usb_ep *_ep, int halt)\n{\n\treturn mv_u3d_ep_set_halt_wedge(_ep, halt, 0);\n}\n\nstatic int mv_u3d_ep_set_wedge(struct usb_ep *_ep)\n{\n\treturn mv_u3d_ep_set_halt_wedge(_ep, 1, 1);\n}\n\nstatic const struct usb_ep_ops mv_u3d_ep_ops = {\n\t.enable\t\t= mv_u3d_ep_enable,\n\t.disable\t= mv_u3d_ep_disable,\n\n\t.alloc_request\t= mv_u3d_alloc_request,\n\t.free_request\t= mv_u3d_free_request,\n\n\t.queue\t\t= mv_u3d_ep_queue,\n\t.dequeue\t= mv_u3d_ep_dequeue,\n\n\t.set_wedge\t= mv_u3d_ep_set_wedge,\n\t.set_halt\t= mv_u3d_ep_set_halt,\n\t.fifo_flush\t= mv_u3d_ep_fifo_flush,\n};\n\nstatic void mv_u3d_controller_stop(struct mv_u3d *u3d)\n{\n\tu32 tmp;\n\n\tif (!u3d->clock_gating && u3d->vbus_valid_detect)\n\t\tiowrite32(MV_U3D_INTR_ENABLE_VBUS_VALID,\n\t\t\t\t&u3d->vuc_regs->intrenable);\n\telse\n\t\tiowrite32(0, &u3d->vuc_regs->intrenable);\n\tiowrite32(~0x0, &u3d->vuc_regs->endcomplete);\n\tiowrite32(~0x0, &u3d->vuc_regs->trbunderrun);\n\tiowrite32(~0x0, &u3d->vuc_regs->trbcomplete);\n\tiowrite32(~0x0, &u3d->vuc_regs->linkchange);\n\tiowrite32(0x1, &u3d->vuc_regs->setuplock);\n\n\t \n\ttmp = ioread32(&u3d->op_regs->usbcmd);\n\ttmp &= ~MV_U3D_CMD_RUN_STOP;\n\tiowrite32(tmp, &u3d->op_regs->usbcmd);\n\tdev_dbg(u3d->dev, \"after u3d_stop, USBCMD 0x%x\\n\",\n\t\tioread32(&u3d->op_regs->usbcmd));\n}\n\nstatic void mv_u3d_controller_start(struct mv_u3d *u3d)\n{\n\tu32 usbintr;\n\tu32 temp;\n\n\t \n\ttemp = ioread32(&u3d->vuc_regs->ltssm);\n\ttemp |= MV_U3D_LTSSM_PHY_INIT_DONE;\n\tiowrite32(temp, &u3d->vuc_regs->ltssm);\n\n\t \n\tusbintr = MV_U3D_INTR_ENABLE_LINK_CHG | MV_U3D_INTR_ENABLE_TXDESC_ERR |\n\t\tMV_U3D_INTR_ENABLE_RXDESC_ERR | MV_U3D_INTR_ENABLE_TX_COMPLETE |\n\t\tMV_U3D_INTR_ENABLE_RX_COMPLETE | MV_U3D_INTR_ENABLE_SETUP |\n\t\t(u3d->vbus_valid_detect ? MV_U3D_INTR_ENABLE_VBUS_VALID : 0);\n\tiowrite32(usbintr, &u3d->vuc_regs->intrenable);\n\n\t \n\tiowrite32(0x1, &u3d->vuc_regs->ctrlepenable);\n\n\t \n\tiowrite32(MV_U3D_CMD_RUN_STOP, &u3d->op_regs->usbcmd);\n\tdev_dbg(u3d->dev, \"after u3d_start, USBCMD 0x%x\\n\",\n\t\tioread32(&u3d->op_regs->usbcmd));\n}\n\nstatic int mv_u3d_controller_reset(struct mv_u3d *u3d)\n{\n\tunsigned int loops;\n\tu32 tmp;\n\n\t \n\ttmp = ioread32(&u3d->op_regs->usbcmd);\n\ttmp &= ~MV_U3D_CMD_RUN_STOP;\n\tiowrite32(tmp, &u3d->op_regs->usbcmd);\n\n\t \n\tiowrite32(MV_U3D_CMD_CTRL_RESET, &u3d->op_regs->usbcmd);\n\n\t \n\tloops = LOOPS(MV_U3D_RESET_TIMEOUT);\n\twhile (ioread32(&u3d->op_regs->usbcmd) & MV_U3D_CMD_CTRL_RESET) {\n\t\tif (loops == 0) {\n\t\t\tdev_err(u3d->dev,\n\t\t\t\t\"Wait for RESET completed TIMEOUT\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tloops--;\n\t\tudelay(LOOPS_USEC);\n\t}\n\n\t \n\tiowrite32(u3d->ep_context_dma, &u3d->op_regs->dcbaapl);\n\tiowrite32(0, &u3d->op_regs->dcbaaph);\n\n\treturn 0;\n}\n\nstatic int mv_u3d_enable(struct mv_u3d *u3d)\n{\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\n\tint retval;\n\n\tif (u3d->active)\n\t\treturn 0;\n\n\tif (!u3d->clock_gating) {\n\t\tu3d->active = 1;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(u3d->dev, \"enable u3d\\n\");\n\tclk_enable(u3d->clk);\n\tif (pdata->phy_init) {\n\t\tretval = pdata->phy_init(u3d->phy_regs);\n\t\tif (retval) {\n\t\t\tdev_err(u3d->dev,\n\t\t\t\t\"init phy error %d\\n\", retval);\n\t\t\tclk_disable(u3d->clk);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tu3d->active = 1;\n\n\treturn 0;\n}\n\nstatic void mv_u3d_disable(struct mv_u3d *u3d)\n{\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\n\tif (u3d->clock_gating && u3d->active) {\n\t\tdev_dbg(u3d->dev, \"disable u3d\\n\");\n\t\tif (pdata->phy_deinit)\n\t\t\tpdata->phy_deinit(u3d->phy_regs);\n\t\tclk_disable(u3d->clk);\n\t\tu3d->active = 0;\n\t}\n}\n\nstatic int mv_u3d_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct mv_u3d *u3d;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tu3d = container_of(gadget, struct mv_u3d, gadget);\n\n\tspin_lock_irqsave(&u3d->lock, flags);\n\n\tu3d->vbus_active = (is_active != 0);\n\tdev_dbg(u3d->dev, \"%s: softconnect %d, vbus_active %d\\n\",\n\t\t__func__, u3d->softconnect, u3d->vbus_active);\n\t \n\tif (u3d->driver && u3d->softconnect && u3d->vbus_active) {\n\t\tretval = mv_u3d_enable(u3d);\n\t\tif (retval == 0) {\n\t\t\t \n\t\t\tmv_u3d_controller_reset(u3d);\n\t\t\tmv_u3d_ep0_reset(u3d);\n\t\t\tmv_u3d_controller_start(u3d);\n\t\t}\n\t} else if (u3d->driver && u3d->softconnect) {\n\t\tif (!u3d->active)\n\t\t\tgoto out;\n\n\t\t \n\t\tmv_u3d_stop_activity(u3d, u3d->driver);\n\t\tmv_u3d_controller_stop(u3d);\n\t\tmv_u3d_disable(u3d);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\treturn retval;\n}\n\n \nstatic int mv_u3d_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{\n\tstruct mv_u3d *u3d = container_of(gadget, struct mv_u3d, gadget);\n\n\tu3d->power = mA;\n\n\treturn 0;\n}\n\nstatic int mv_u3d_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct mv_u3d *u3d = container_of(gadget, struct mv_u3d, gadget);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&u3d->lock, flags);\n\n\tdev_dbg(u3d->dev, \"%s: softconnect %d, vbus_active %d\\n\",\n\t\t__func__, u3d->softconnect, u3d->vbus_active);\n\tu3d->softconnect = (is_on != 0);\n\tif (u3d->driver && u3d->softconnect && u3d->vbus_active) {\n\t\tretval = mv_u3d_enable(u3d);\n\t\tif (retval == 0) {\n\t\t\t \n\t\t\tmv_u3d_controller_reset(u3d);\n\t\t\tmv_u3d_ep0_reset(u3d);\n\t\t\tmv_u3d_controller_start(u3d);\n\t\t}\n\t} else if (u3d->driver && u3d->vbus_active) {\n\t\t \n\t\tmv_u3d_stop_activity(u3d, u3d->driver);\n\t\tmv_u3d_controller_stop(u3d);\n\t\tmv_u3d_disable(u3d);\n\t}\n\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\n\treturn retval;\n}\n\nstatic int mv_u3d_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct mv_u3d *u3d = container_of(g, struct mv_u3d, gadget);\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\n\tunsigned long flags;\n\n\tif (u3d->driver)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&u3d->lock, flags);\n\n\tif (!u3d->clock_gating) {\n\t\tclk_enable(u3d->clk);\n\t\tif (pdata->phy_init)\n\t\t\tpdata->phy_init(u3d->phy_regs);\n\t}\n\n\t \n\tu3d->driver = driver;\n\n\tu3d->ep0_dir = USB_DIR_OUT;\n\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\n\tu3d->vbus_valid_detect = 1;\n\n\treturn 0;\n}\n\nstatic int mv_u3d_stop(struct usb_gadget *g)\n{\n\tstruct mv_u3d *u3d = container_of(g, struct mv_u3d, gadget);\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(u3d->dev);\n\tunsigned long flags;\n\n\tu3d->vbus_valid_detect = 0;\n\tspin_lock_irqsave(&u3d->lock, flags);\n\n\t \n\tclk_enable(u3d->clk);\n\tif (pdata->phy_init)\n\t\tpdata->phy_init(u3d->phy_regs);\n\n\tmv_u3d_controller_stop(u3d);\n\t \n\tu3d->gadget.speed = USB_SPEED_UNKNOWN;\n\tmv_u3d_stop_activity(u3d, NULL);\n\tmv_u3d_disable(u3d);\n\n\tif (pdata->phy_deinit)\n\t\tpdata->phy_deinit(u3d->phy_regs);\n\tclk_disable(u3d->clk);\n\n\tspin_unlock_irqrestore(&u3d->lock, flags);\n\n\tu3d->driver = NULL;\n\n\treturn 0;\n}\n\n \nstatic const struct usb_gadget_ops mv_u3d_ops = {\n\t \n\t.vbus_session\t= mv_u3d_vbus_session,\n\n\t \n\t.vbus_draw\t= mv_u3d_vbus_draw,\n\n\t.pullup\t\t= mv_u3d_pullup,\n\t.udc_start\t= mv_u3d_start,\n\t.udc_stop\t= mv_u3d_stop,\n};\n\nstatic int mv_u3d_eps_init(struct mv_u3d *u3d)\n{\n\tstruct mv_u3d_ep\t*ep;\n\tchar name[14];\n\tint i;\n\n\t \n\tep = &u3d->eps[1];\n\tep->u3d = u3d;\n\tstrncpy(ep->name, \"ep0\", sizeof(ep->name));\n\tep->ep.name = ep->name;\n\tep->ep.ops = &mv_u3d_ep_ops;\n\tep->wedge = 0;\n\tusb_ep_set_maxpacket_limit(&ep->ep, MV_U3D_EP0_MAX_PKT_SIZE);\n\tep->ep.caps.type_control = true;\n\tep->ep.caps.dir_in = true;\n\tep->ep.caps.dir_out = true;\n\tep->ep_num = 0;\n\tep->ep.desc = &mv_u3d_ep0_desc;\n\tINIT_LIST_HEAD(&ep->queue);\n\tINIT_LIST_HEAD(&ep->req_list);\n\tep->ep_type = USB_ENDPOINT_XFER_CONTROL;\n\n\t \n\tep->ep_context = &u3d->ep_context[1];\n\n\t \n\tfor (i = 2; i < u3d->max_eps * 2; i++) {\n\t\tep = &u3d->eps[i];\n\t\tif (i & 1) {\n\t\t\tsnprintf(name, sizeof(name), \"ep%din\", i >> 1);\n\t\t\tep->direction = MV_U3D_EP_DIR_IN;\n\t\t\tep->ep.caps.dir_in = true;\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"ep%dout\", i >> 1);\n\t\t\tep->direction = MV_U3D_EP_DIR_OUT;\n\t\t\tep->ep.caps.dir_out = true;\n\t\t}\n\t\tep->u3d = u3d;\n\t\tstrncpy(ep->name, name, sizeof(ep->name));\n\t\tep->ep.name = ep->name;\n\n\t\tep->ep.caps.type_iso = true;\n\t\tep->ep.caps.type_bulk = true;\n\t\tep->ep.caps.type_int = true;\n\n\t\tep->ep.ops = &mv_u3d_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\n\t\tep->ep_num = i / 2;\n\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tlist_add_tail(&ep->ep.ep_list, &u3d->gadget.ep_list);\n\n\t\tINIT_LIST_HEAD(&ep->req_list);\n\t\tspin_lock_init(&ep->req_lock);\n\t\tep->ep_context = &u3d->ep_context[i];\n\t}\n\n\treturn 0;\n}\n\n \nstatic void mv_u3d_nuke(struct mv_u3d_ep *ep, int status)\n{\n\t \n\tmv_u3d_ep_fifo_flush(&ep->ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct mv_u3d_req *req = NULL;\n\t\treq = list_entry(ep->queue.next, struct mv_u3d_req, queue);\n\t\tmv_u3d_done(ep, req, status);\n\t}\n}\n\n \nstatic\nvoid mv_u3d_stop_activity(struct mv_u3d *u3d, struct usb_gadget_driver *driver)\n{\n\tstruct mv_u3d_ep\t*ep;\n\n\tmv_u3d_nuke(&u3d->eps[1], -ESHUTDOWN);\n\n\tlist_for_each_entry(ep, &u3d->gadget.ep_list, ep.ep_list) {\n\t\tmv_u3d_nuke(ep, -ESHUTDOWN);\n\t}\n\n\t \n\tif (driver) {\n\t\tspin_unlock(&u3d->lock);\n\t\tdriver->disconnect(&u3d->gadget);\n\t\tspin_lock(&u3d->lock);\n\t}\n}\n\nstatic void mv_u3d_irq_process_error(struct mv_u3d *u3d)\n{\n\t \n\tu3d->errors++;\n\tdev_err(u3d->dev, \"%s\\n\", __func__);\n}\n\nstatic void mv_u3d_irq_process_link_change(struct mv_u3d *u3d)\n{\n\tu32 linkchange;\n\n\tlinkchange = ioread32(&u3d->vuc_regs->linkchange);\n\tiowrite32(linkchange, &u3d->vuc_regs->linkchange);\n\n\tdev_dbg(u3d->dev, \"linkchange: 0x%x\\n\", linkchange);\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_LINK_UP) {\n\t\tdev_dbg(u3d->dev, \"link up: ltssm state: 0x%x\\n\",\n\t\t\tioread32(&u3d->vuc_regs->ltssmstate));\n\n\t\tu3d->usb_state = USB_STATE_DEFAULT;\n\t\tu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\n\t\tu3d->ep0_state = MV_U3D_WAIT_FOR_SETUP;\n\n\t\t \n\t\tu3d->gadget.speed = USB_SPEED_SUPER;\n\t}\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_SUSPEND) {\n\t\tdev_dbg(u3d->dev, \"link suspend\\n\");\n\t\tu3d->resume_state = u3d->usb_state;\n\t\tu3d->usb_state = USB_STATE_SUSPENDED;\n\t}\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_RESUME) {\n\t\tdev_dbg(u3d->dev, \"link resume\\n\");\n\t\tu3d->usb_state = u3d->resume_state;\n\t\tu3d->resume_state = 0;\n\t}\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_WRESET) {\n\t\tdev_dbg(u3d->dev, \"warm reset\\n\");\n\t\tu3d->usb_state = USB_STATE_POWERED;\n\t}\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_HRESET) {\n\t\tdev_dbg(u3d->dev, \"hot reset\\n\");\n\t\tu3d->usb_state = USB_STATE_DEFAULT;\n\t}\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_INACT)\n\t\tdev_dbg(u3d->dev, \"inactive\\n\");\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_DISABLE_AFTER_U0)\n\t\tdev_dbg(u3d->dev, \"ss.disabled\\n\");\n\n\tif (linkchange & MV_U3D_LINK_CHANGE_VBUS_INVALID) {\n\t\tdev_dbg(u3d->dev, \"vbus invalid\\n\");\n\t\tu3d->usb_state = USB_STATE_ATTACHED;\n\t\tu3d->vbus_valid_detect = 1;\n\t\t \n\t\tif (!u3d->vbus) {\n\t\t\tspin_unlock(&u3d->lock);\n\t\t\tmv_u3d_vbus_session(&u3d->gadget, 0);\n\t\t\tspin_lock(&u3d->lock);\n\t\t}\n\t}\n}\n\nstatic void mv_u3d_ch9setaddress(struct mv_u3d *u3d,\n\t\t\t\tstruct usb_ctrlrequest *setup)\n{\n\tu32 tmp;\n\n\tif (u3d->usb_state != USB_STATE_DEFAULT) {\n\t\tdev_err(u3d->dev,\n\t\t\t\"%s, cannot setaddr in this state (%d)\\n\",\n\t\t\t__func__, u3d->usb_state);\n\t\tgoto err;\n\t}\n\n\tu3d->dev_addr = (u8)setup->wValue;\n\n\tdev_dbg(u3d->dev, \"%s: 0x%x\\n\", __func__, u3d->dev_addr);\n\n\tif (u3d->dev_addr > 127) {\n\t\tdev_err(u3d->dev,\n\t\t\t\"%s, u3d address is wrong (out of range)\\n\", __func__);\n\t\tu3d->dev_addr = 0;\n\t\tgoto err;\n\t}\n\n\t \n\tu3d->usb_state = USB_STATE_ADDRESS;\n\n\t \n\ttmp = ioread32(&u3d->vuc_regs->devaddrtiebrkr);\n\ttmp &= ~0x7F;\n\ttmp |= (u32)u3d->dev_addr;\n\tiowrite32(tmp, &u3d->vuc_regs->devaddrtiebrkr);\n\n\treturn;\nerr:\n\tmv_u3d_ep0_stall(u3d);\n}\n\nstatic int mv_u3d_is_set_configuration(struct usb_ctrlrequest *setup)\n{\n\tif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tif (setup->bRequest == USB_REQ_SET_CONFIGURATION)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void mv_u3d_handle_setup_packet(struct mv_u3d *u3d, u8 ep_num,\n\tstruct usb_ctrlrequest *setup)\n\t__releases(&u3c->lock)\n\t__acquires(&u3c->lock)\n{\n\tbool delegate = false;\n\n\tmv_u3d_nuke(&u3d->eps[ep_num * 2 + MV_U3D_EP_DIR_IN], -ESHUTDOWN);\n\n\tdev_dbg(u3d->dev, \"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t\tsetup->bRequestType, setup->bRequest,\n\t\t\tsetup->wValue, setup->wIndex, setup->wLength);\n\n\t \n\tif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (setup->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tdelegate = true;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tmv_u3d_ch9setaddress(u3d, setup);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tdelegate = true;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tdelegate = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdelegate = true;\n\t\t}\n\t} else\n\t\tdelegate = true;\n\n\t \n\tif (delegate) {\n\t\t \n\t\tif (setup->wLength) {\n\t\t\t \n\t\t\tu3d->ep0_dir = (setup->bRequestType & USB_DIR_IN)\n\t\t\t\t\t? MV_U3D_EP_DIR_IN : MV_U3D_EP_DIR_OUT;\n\t\t\tspin_unlock(&u3d->lock);\n\t\t\tif (u3d->driver->setup(&u3d->gadget,\n\t\t\t\t&u3d->local_setup_buff) < 0) {\n\t\t\t\tdev_err(u3d->dev, \"setup error!\\n\");\n\t\t\t\tmv_u3d_ep0_stall(u3d);\n\t\t\t}\n\t\t\tspin_lock(&u3d->lock);\n\t\t} else {\n\t\t\t \n\t\t\tu3d->ep0_dir = MV_U3D_EP_DIR_IN;\n\t\t\tu3d->ep0_state = MV_U3D_STATUS_STAGE;\n\t\t\tspin_unlock(&u3d->lock);\n\t\t\tif (u3d->driver->setup(&u3d->gadget,\n\t\t\t\t&u3d->local_setup_buff) < 0)\n\t\t\t\tmv_u3d_ep0_stall(u3d);\n\t\t\tspin_lock(&u3d->lock);\n\t\t}\n\n\t\tif (mv_u3d_is_set_configuration(setup)) {\n\t\t\tdev_dbg(u3d->dev, \"u3d configured\\n\");\n\t\t\tu3d->usb_state = USB_STATE_CONFIGURED;\n\t\t}\n\t}\n}\n\nstatic void mv_u3d_get_setup_data(struct mv_u3d *u3d, u8 ep_num, u8 *buffer_ptr)\n{\n\tstruct mv_u3d_ep_context *epcontext;\n\n\tepcontext = &u3d->ep_context[ep_num * 2 + MV_U3D_EP_DIR_IN];\n\n\t \n\tmemcpy(buffer_ptr, (u8 *) &epcontext->setup_buffer, 8);\n}\n\nstatic void mv_u3d_irq_process_setup(struct mv_u3d *u3d)\n{\n\tu32 tmp, i;\n\t \n\ttmp = ioread32(&u3d->vuc_regs->setuplock);\n\tif (tmp) {\n\t\tfor (i = 0; i < u3d->max_eps; i++) {\n\t\t\tif (tmp & (1 << i)) {\n\t\t\t\tmv_u3d_get_setup_data(u3d, i,\n\t\t\t\t\t(u8 *)(&u3d->local_setup_buff));\n\t\t\t\tmv_u3d_handle_setup_packet(u3d, i,\n\t\t\t\t\t&u3d->local_setup_buff);\n\t\t\t}\n\t\t}\n\t}\n\n\tiowrite32(tmp, &u3d->vuc_regs->setuplock);\n}\n\nstatic void mv_u3d_irq_process_tr_complete(struct mv_u3d *u3d)\n{\n\tu32 tmp, bit_pos;\n\tint i, ep_num = 0, direction = 0;\n\tstruct mv_u3d_ep\t*curr_ep;\n\tstruct mv_u3d_req *curr_req, *temp_req;\n\tint status;\n\n\ttmp = ioread32(&u3d->vuc_regs->endcomplete);\n\n\tdev_dbg(u3d->dev, \"tr_complete: ep: 0x%x\\n\", tmp);\n\tif (!tmp)\n\t\treturn;\n\tiowrite32(tmp, &u3d->vuc_regs->endcomplete);\n\n\tfor (i = 0; i < u3d->max_eps * 2; i++) {\n\t\tep_num = i >> 1;\n\t\tdirection = i % 2;\n\n\t\tbit_pos = 1 << (ep_num + 16 * direction);\n\n\t\tif (!(bit_pos & tmp))\n\t\t\tcontinue;\n\n\t\tif (i == 0)\n\t\t\tcurr_ep = &u3d->eps[1];\n\t\telse\n\t\t\tcurr_ep = &u3d->eps[i];\n\n\t\t \n\t\tdev_dbg(u3d->dev, \"tr comp: check req_list\\n\");\n\t\tspin_lock(&curr_ep->req_lock);\n\t\tif (!list_empty(&curr_ep->req_list)) {\n\t\t\tstruct mv_u3d_req *req;\n\t\t\treq = list_entry(curr_ep->req_list.next,\n\t\t\t\t\t\tstruct mv_u3d_req, list);\n\t\t\tlist_del_init(&req->list);\n\t\t\tcurr_ep->processing = 0;\n\t\t}\n\t\tspin_unlock(&curr_ep->req_lock);\n\n\t\t \n\t\tlist_for_each_entry_safe(curr_req, temp_req,\n\t\t\t&curr_ep->queue, queue) {\n\t\t\tstatus = mv_u3d_process_ep_req(u3d, i, curr_req);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcurr_req->req.status = status;\n\n\t\t\t \n\t\t\tif (ep_num == 0) {\n\t\t\t\tmv_u3d_done(curr_ep, curr_req, 0);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tmv_u3d_done(curr_ep, curr_req, status);\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(u3d->dev, \"call mv_u3d_start_queue from ep complete\\n\");\n\t\tmv_u3d_start_queue(curr_ep);\n\t}\n}\n\nstatic irqreturn_t mv_u3d_irq(int irq, void *dev)\n{\n\tstruct mv_u3d *u3d = (struct mv_u3d *)dev;\n\tu32 status, intr;\n\tu32 bridgesetting;\n\tu32 trbunderrun;\n\n\tspin_lock(&u3d->lock);\n\n\tstatus = ioread32(&u3d->vuc_regs->intrcause);\n\tintr = ioread32(&u3d->vuc_regs->intrenable);\n\tstatus &= intr;\n\n\tif (status == 0) {\n\t\tspin_unlock(&u3d->lock);\n\t\tdev_err(u3d->dev, \"irq error!\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (status & MV_U3D_USBINT_VBUS_VALID) {\n\t\tbridgesetting = ioread32(&u3d->vuc_regs->bridgesetting);\n\t\tif (bridgesetting & MV_U3D_BRIDGE_SETTING_VBUS_VALID) {\n\t\t\t \n\t\t\tbridgesetting = MV_U3D_BRIDGE_SETTING_VBUS_VALID;\n\t\t\tiowrite32(bridgesetting, &u3d->vuc_regs->bridgesetting);\n\t\t\tdev_dbg(u3d->dev, \"vbus valid\\n\");\n\n\t\t\tu3d->usb_state = USB_STATE_POWERED;\n\t\t\tu3d->vbus_valid_detect = 0;\n\t\t\t \n\t\t\tif (!u3d->vbus) {\n\t\t\t\tspin_unlock(&u3d->lock);\n\t\t\t\tmv_u3d_vbus_session(&u3d->gadget, 1);\n\t\t\t\tspin_lock(&u3d->lock);\n\t\t\t}\n\t\t} else\n\t\t\tdev_err(u3d->dev, \"vbus bit is not set\\n\");\n\t}\n\n\t \n\tif (status & MV_U3D_USBINT_UNDER_RUN) {\n\t\ttrbunderrun = ioread32(&u3d->vuc_regs->trbunderrun);\n\t\tdev_err(u3d->dev, \"under run, ep%d\\n\", trbunderrun);\n\t\tiowrite32(trbunderrun, &u3d->vuc_regs->trbunderrun);\n\t\tmv_u3d_irq_process_error(u3d);\n\t}\n\n\tif (status & (MV_U3D_USBINT_RXDESC_ERR | MV_U3D_USBINT_TXDESC_ERR)) {\n\t\t \n\t\tiowrite32(status & (MV_U3D_USBINT_RXDESC_ERR\n\t\t\t| MV_U3D_USBINT_TXDESC_ERR),\n\t\t\t&u3d->vuc_regs->intrcause);\n\t\tdev_err(u3d->dev, \"desc err 0x%x\\n\", status);\n\t\tmv_u3d_irq_process_error(u3d);\n\t}\n\n\tif (status & MV_U3D_USBINT_LINK_CHG)\n\t\tmv_u3d_irq_process_link_change(u3d);\n\n\tif (status & MV_U3D_USBINT_TX_COMPLETE)\n\t\tmv_u3d_irq_process_tr_complete(u3d);\n\n\tif (status & MV_U3D_USBINT_RX_COMPLETE)\n\t\tmv_u3d_irq_process_tr_complete(u3d);\n\n\tif (status & MV_U3D_USBINT_SETUP)\n\t\tmv_u3d_irq_process_setup(u3d);\n\n\tspin_unlock(&u3d->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void mv_u3d_remove(struct platform_device *dev)\n{\n\tstruct mv_u3d *u3d = platform_get_drvdata(dev);\n\n\tBUG_ON(u3d == NULL);\n\n\tusb_del_gadget_udc(&u3d->gadget);\n\n\t \n\tdma_pool_destroy(u3d->trb_pool);\n\n\tif (u3d->ep_context)\n\t\tdma_free_coherent(&dev->dev, u3d->ep_context_size,\n\t\t\tu3d->ep_context, u3d->ep_context_dma);\n\n\tkfree(u3d->eps);\n\n\tif (u3d->irq)\n\t\tfree_irq(u3d->irq, u3d);\n\n\tif (u3d->cap_regs)\n\t\tiounmap(u3d->cap_regs);\n\tu3d->cap_regs = NULL;\n\n\tkfree(u3d->status_req);\n\n\tclk_put(u3d->clk);\n\n\tkfree(u3d);\n}\n\nstatic int mv_u3d_probe(struct platform_device *dev)\n{\n\tstruct mv_u3d *u3d;\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(&dev->dev);\n\tint retval = 0;\n\tstruct resource *r;\n\tsize_t size;\n\n\tif (!dev_get_platdata(&dev->dev)) {\n\t\tdev_err(&dev->dev, \"missing platform_data\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_pdata;\n\t}\n\n\tu3d = kzalloc(sizeof(*u3d), GFP_KERNEL);\n\tif (!u3d) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_private;\n\t}\n\n\tspin_lock_init(&u3d->lock);\n\n\tplatform_set_drvdata(dev, u3d);\n\n\tu3d->dev = &dev->dev;\n\tu3d->vbus = pdata->vbus;\n\n\tu3d->clk = clk_get(&dev->dev, NULL);\n\tif (IS_ERR(u3d->clk)) {\n\t\tretval = PTR_ERR(u3d->clk);\n\t\tgoto err_get_clk;\n\t}\n\n\tr = platform_get_resource_byname(dev, IORESOURCE_MEM, \"capregs\");\n\tif (!r) {\n\t\tdev_err(&dev->dev, \"no I/O memory resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_get_cap_regs;\n\t}\n\n\tu3d->cap_regs = (struct mv_u3d_cap_regs __iomem *)\n\t\tioremap(r->start, resource_size(r));\n\tif (!u3d->cap_regs) {\n\t\tdev_err(&dev->dev, \"failed to map I/O memory\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err_map_cap_regs;\n\t} else {\n\t\tdev_dbg(&dev->dev, \"cap_regs address: 0x%lx/0x%lx\\n\",\n\t\t\t(unsigned long) r->start,\n\t\t\t(unsigned long) u3d->cap_regs);\n\t}\n\n\t \n\tretval = clk_enable(u3d->clk);\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"clk_enable error %d\\n\", retval);\n\t\tgoto err_u3d_enable;\n\t}\n\n\tif (pdata->phy_init) {\n\t\tretval = pdata->phy_init(u3d->phy_regs);\n\t\tif (retval) {\n\t\t\tdev_err(&dev->dev, \"init phy error %d\\n\", retval);\n\t\t\tclk_disable(u3d->clk);\n\t\t\tgoto err_phy_init;\n\t\t}\n\t}\n\n\tu3d->op_regs = (struct mv_u3d_op_regs __iomem *)(u3d->cap_regs\n\t\t+ MV_U3D_USB3_OP_REGS_OFFSET);\n\n\tu3d->vuc_regs = (struct mv_u3d_vuc_regs __iomem *)(u3d->cap_regs\n\t\t+ ioread32(&u3d->cap_regs->vuoff));\n\n\tu3d->max_eps = 16;\n\n\t \n\tmv_u3d_controller_stop(u3d);\n\tiowrite32(0xFFFFFFFF, &u3d->vuc_regs->intrcause);\n\n\tif (pdata->phy_deinit)\n\t\tpdata->phy_deinit(u3d->phy_regs);\n\tclk_disable(u3d->clk);\n\n\tsize = u3d->max_eps * sizeof(struct mv_u3d_ep_context) * 2;\n\tsize = (size + MV_U3D_EP_CONTEXT_ALIGNMENT - 1)\n\t\t& ~(MV_U3D_EP_CONTEXT_ALIGNMENT - 1);\n\tu3d->ep_context = dma_alloc_coherent(&dev->dev, size,\n\t\t\t\t\t&u3d->ep_context_dma, GFP_KERNEL);\n\tif (!u3d->ep_context) {\n\t\tdev_err(&dev->dev, \"allocate ep context memory failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_ep_context;\n\t}\n\tu3d->ep_context_size = size;\n\n\t \n\tu3d->trb_pool = dma_pool_create(\"u3d_trb\",\n\t\t\t&dev->dev,\n\t\t\tsizeof(struct mv_u3d_trb_hw),\n\t\t\tMV_U3D_TRB_ALIGNMENT,\n\t\t\tMV_U3D_DMA_BOUNDARY);\n\n\tif (!u3d->trb_pool) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_trb_pool;\n\t}\n\n\tsize = u3d->max_eps * sizeof(struct mv_u3d_ep) * 2;\n\tu3d->eps = kzalloc(size, GFP_KERNEL);\n\tif (!u3d->eps) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_eps;\n\t}\n\n\t \n\tu3d->status_req = kzalloc(sizeof(struct mv_u3d_req) + 8, GFP_KERNEL);\n\tif (!u3d->status_req) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_status_req;\n\t}\n\tINIT_LIST_HEAD(&u3d->status_req->queue);\n\n\t \n\tu3d->status_req->req.buf = (char *)u3d->status_req\n\t\t\t\t\t+ sizeof(struct mv_u3d_req);\n\tu3d->status_req->req.dma = virt_to_phys(u3d->status_req->req.buf);\n\n\tu3d->resume_state = USB_STATE_NOTATTACHED;\n\tu3d->usb_state = USB_STATE_ATTACHED;\n\tu3d->ep0_dir = MV_U3D_EP_DIR_OUT;\n\tu3d->remote_wakeup = 0;\n\n\tr = platform_get_resource(dev, IORESOURCE_IRQ, 0);\n\tif (!r) {\n\t\tdev_err(&dev->dev, \"no IRQ resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_get_irq;\n\t}\n\tu3d->irq = r->start;\n\n\t \n\tu3d->gadget.ops = &mv_u3d_ops;\t \n\tu3d->gadget.ep0 = &u3d->eps[1].ep;\t \n\tINIT_LIST_HEAD(&u3d->gadget.ep_list);\t \n\tu3d->gadget.speed = USB_SPEED_UNKNOWN;\t \n\n\t \n\tu3d->gadget.name = driver_name;\t\t \n\n\tmv_u3d_eps_init(u3d);\n\n\tif (request_irq(u3d->irq, mv_u3d_irq,\n\t\tIRQF_SHARED, driver_name, u3d)) {\n\t\tu3d->irq = 0;\n\t\tdev_err(&dev->dev, \"Request irq %d for u3d failed\\n\",\n\t\t\tu3d->irq);\n\t\tretval = -ENODEV;\n\t\tgoto err_request_irq;\n\t}\n\n\t \n\tif (u3d->vbus) {\n\t\tu3d->clock_gating = 1;\n\t\tdev_err(&dev->dev, \"external vbus detection\\n\");\n\t}\n\n\tif (!u3d->clock_gating)\n\t\tu3d->vbus_active = 1;\n\n\t \n\tu3d->vbus_valid_detect = 1;\n\n\tretval = usb_add_gadget_udc(&dev->dev, &u3d->gadget);\n\tif (retval)\n\t\tgoto err_unregister;\n\n\tdev_dbg(&dev->dev, \"successful probe usb3 device %s clock gating.\\n\",\n\t\tu3d->clock_gating ? \"with\" : \"without\");\n\n\treturn 0;\n\nerr_unregister:\n\tfree_irq(u3d->irq, u3d);\nerr_get_irq:\nerr_request_irq:\n\tkfree(u3d->status_req);\nerr_alloc_status_req:\n\tkfree(u3d->eps);\nerr_alloc_eps:\n\tdma_pool_destroy(u3d->trb_pool);\nerr_alloc_trb_pool:\n\tdma_free_coherent(&dev->dev, u3d->ep_context_size,\n\t\tu3d->ep_context, u3d->ep_context_dma);\nerr_alloc_ep_context:\nerr_phy_init:\nerr_u3d_enable:\n\tiounmap(u3d->cap_regs);\nerr_map_cap_regs:\nerr_get_cap_regs:\n\tclk_put(u3d->clk);\nerr_get_clk:\n\tkfree(u3d);\nerr_alloc_private:\nerr_pdata:\n\treturn retval;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mv_u3d_suspend(struct device *dev)\n{\n\tstruct mv_u3d *u3d = dev_get_drvdata(dev);\n\n\t \n\tif (!u3d->clock_gating) {\n\t\tmv_u3d_controller_stop(u3d);\n\n\t\tspin_lock_irq(&u3d->lock);\n\t\t \n\t\tmv_u3d_stop_activity(u3d, u3d->driver);\n\t\tspin_unlock_irq(&u3d->lock);\n\n\t\tmv_u3d_disable(u3d);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv_u3d_resume(struct device *dev)\n{\n\tstruct mv_u3d *u3d = dev_get_drvdata(dev);\n\tint retval;\n\n\tif (!u3d->clock_gating) {\n\t\tretval = mv_u3d_enable(u3d);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (u3d->driver && u3d->softconnect) {\n\t\t\tmv_u3d_controller_reset(u3d);\n\t\t\tmv_u3d_ep0_reset(u3d);\n\t\t\tmv_u3d_controller_start(u3d);\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mv_u3d_pm_ops, mv_u3d_suspend, mv_u3d_resume);\n\nstatic void mv_u3d_shutdown(struct platform_device *dev)\n{\n\tstruct mv_u3d *u3d = platform_get_drvdata(dev);\n\tu32 tmp;\n\n\ttmp = ioread32(&u3d->op_regs->usbcmd);\n\ttmp &= ~MV_U3D_CMD_RUN_STOP;\n\tiowrite32(tmp, &u3d->op_regs->usbcmd);\n}\n\nstatic struct platform_driver mv_u3d_driver = {\n\t.probe\t\t= mv_u3d_probe,\n\t.remove_new\t= mv_u3d_remove,\n\t.shutdown\t= mv_u3d_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"mv-u3d\",\n\t\t.pm\t= &mv_u3d_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mv_u3d_driver);\nMODULE_ALIAS(\"platform:mv-u3d\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Yu Xu <yuxu@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}