{
  "module_name": "amd5536udc_pci.c",
  "hash_id": "dd38b63110a0c3388a999188c6098df10ddc926d62b64190ca5c6f276a50c395",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/amd5536udc_pci.c",
  "human_readable_source": "\n \n\n \n\n \n#define UDC_MOD_DESCRIPTION\t\t\"AMD 5536 UDC - USB Device Controller\"\n\n \n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/prefetch.h>\n#include <linux/pci.h>\n\n \n#include \"amd5536udc.h\"\n\n \nstatic struct udc *udc;\n\n \nstatic const char name[] = \"amd5536udc-pci\";\n\n \nstatic void udc_pci_remove(struct pci_dev *pdev)\n{\n\tstruct udc\t\t*dev;\n\n\tdev = pci_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\t \n\tif (WARN_ON(dev->driver))\n\t\treturn;\n\n\t \n\tfree_dma_pools(dev);\n\n\t \n\twritel(AMD_BIT(UDC_DEVCFG_SOFTRESET), &dev->regs->cfg);\n\tfree_irq(pdev->irq, dev);\n\tiounmap(dev->virt_addr);\n\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t   pci_resource_len(pdev, 0));\n\tpci_disable_device(pdev);\n\n\tudc_remove(dev);\n}\n\n \nstatic int udc_pci_probe(\n\tstruct pci_dev *pdev,\n\tconst struct pci_device_id *id\n)\n{\n\tstruct udc\t\t*dev;\n\tunsigned long\t\tresource;\n\tunsigned long\t\tlen;\n\tint\t\t\tretval = 0;\n\n\t \n\tif (udc) {\n\t\tdev_dbg(&pdev->dev, \"already probed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdev = kzalloc(sizeof(struct udc), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tif (pci_enable_device(pdev) < 0) {\n\t\tretval = -ENODEV;\n\t\tgoto err_pcidev;\n\t}\n\n\t \n\tresource = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\n\tif (!request_mem_region(resource, len, name)) {\n\t\tdev_dbg(&pdev->dev, \"pci device used already\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err_memreg;\n\t}\n\n\tdev->virt_addr = ioremap(resource, len);\n\tif (!dev->virt_addr) {\n\t\tdev_dbg(&pdev->dev, \"start address cannot be mapped\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto err_ioremap;\n\t}\n\n\tif (!pdev->irq) {\n\t\tdev_err(&pdev->dev, \"irq not set\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_irq;\n\t}\n\n\tspin_lock_init(&dev->lock);\n\t \n\tdev->csr = dev->virt_addr + UDC_CSR_ADDR;\n\t \n\tdev->regs = dev->virt_addr + UDC_DEVCFG_ADDR;\n\t \n\tdev->ep_regs = dev->virt_addr + UDC_EPREGS_ADDR;\n\t \n\tdev->rxfifo = (u32 __iomem *)(dev->virt_addr + UDC_RXFIFO_ADDR);\n\tdev->txfifo = (u32 __iomem *)(dev->virt_addr + UDC_TXFIFO_ADDR);\n\n\tif (request_irq(pdev->irq, udc_irq, IRQF_SHARED, name, dev) != 0) {\n\t\tdev_dbg(&pdev->dev, \"request_irq(%d) fail\\n\", pdev->irq);\n\t\tretval = -EBUSY;\n\t\tgoto err_irq;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tdev->chiprev = pdev->revision;\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\tdev->phys_addr = resource;\n\tdev->irq = pdev->irq;\n\tdev->pdev = pdev;\n\tdev->dev = &pdev->dev;\n\n\t \n\tif (use_dma) {\n\t\tretval = init_dma_pools(dev);\n\t\tif (retval != 0)\n\t\t\tgoto err_dma;\n\t}\n\n\t \n\tif (udc_probe(dev)) {\n\t\tretval = -ENODEV;\n\t\tgoto err_probe;\n\t}\n\n\tudc = dev;\n\n\treturn 0;\n\nerr_probe:\n\tif (use_dma)\n\t\tfree_dma_pools(dev);\nerr_dma:\n\tfree_irq(pdev->irq, dev);\nerr_irq:\n\tiounmap(dev->virt_addr);\nerr_ioremap:\n\trelease_mem_region(resource, len);\nerr_memreg:\n\tpci_disable_device(pdev);\nerr_pcidev:\n\tkfree(dev);\n\treturn retval;\n}\n\n \nstatic const struct pci_device_id pci_id[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_AMD, 0x2096),\n\t\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask =\t0xffffffff,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(pci, pci_id);\n\n \nstatic struct pci_driver udc_pci_driver = {\n\t.name =\t\tname,\n\t.id_table =\tpci_id,\n\t.probe =\tudc_pci_probe,\n\t.remove =\tudc_pci_remove,\n};\nmodule_pci_driver(udc_pci_driver);\n\nMODULE_DESCRIPTION(UDC_MOD_DESCRIPTION);\nMODULE_AUTHOR(\"Thomas Dahlmann\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}