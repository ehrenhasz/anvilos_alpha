{
  "module_name": "net2280.c",
  "hash_id": "4b013fd9a64846d26f298d1e283353a9550f4cfd3eae6720d4ccf51a02912748",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/net2280.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/prefetch.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include <asm/byteorder.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n#define\tDRIVER_DESC\t\t\"PLX NET228x/USB338x USB Peripheral Controller\"\n#define\tDRIVER_VERSION\t\t\"2005 Sept 27/v3.0\"\n\n#define\tEP_DONTUSE\t\t13\t \n\n#define USE_RDK_LEDS\t\t \n\n\nstatic const char driver_name[] = \"net2280\";\nstatic const char driver_desc[] = DRIVER_DESC;\n\nstatic const u32 ep_bit[9] = { 0, 17, 2, 19, 4, 1, 18, 3, 20 };\nstatic const char ep0name[] = \"ep0\";\n\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} ep_info_dft[] = {  \n\tEP_INFO(ep0name,\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-a\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-b\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-c\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-d\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-e\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-f\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-g\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep-h\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n}, ep_info_adv[] = {  \n\tEP_INFO(ep0name,\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep1in\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep2out\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep3in\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep4out\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep1out\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep2in\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep3out\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep4in\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_IN)),\n};\n\n#undef EP_INFO\n\n \nstatic ushort fifo_mode;\n\n \nmodule_param(fifo_mode, ushort, 0644);\n\n \nstatic bool enable_suspend;\n\n \nmodule_param(enable_suspend, bool, 0444);\n\n#define\tDIR_STRING(bAddress) (((bAddress) & USB_DIR_IN) ? \"in\" : \"out\")\n\nstatic char *type_string(u8 bmAttributes)\n{\n\tswitch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_BULK:\treturn \"bulk\";\n\tcase USB_ENDPOINT_XFER_ISOC:\treturn \"iso\";\n\tcase USB_ENDPOINT_XFER_INT:\treturn \"intr\";\n\t}\n\treturn \"control\";\n}\n\n#include \"net2280.h\"\n\n#define valid_bit\tcpu_to_le32(BIT(VALID_BIT))\n#define dma_done_ie\tcpu_to_le32(BIT(DMA_DONE_INTERRUPT_ENABLE))\n\nstatic void ep_clear_seqnum(struct net2280_ep *ep);\nstatic void stop_activity(struct net2280 *dev,\n\t\t\t\t\tstruct usb_gadget_driver *driver);\nstatic void ep0_start(struct net2280 *dev);\n\n \nstatic inline void enable_pciirqenb(struct net2280_ep *ep)\n{\n\tu32 tmp = readl(&ep->dev->regs->pciirqenb0);\n\n\tif (ep->dev->quirks & PLX_LEGACY)\n\t\ttmp |= BIT(ep->num);\n\telse\n\t\ttmp |= BIT(ep_bit[ep->num]);\n\twritel(tmp, &ep->dev->regs->pciirqenb0);\n\n\treturn;\n}\n\nstatic int\nnet2280_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\n{\n\tstruct net2280\t\t*dev;\n\tstruct net2280_ep\t*ep;\n\tu32\t\t\tmax;\n\tu32 tmp = 0;\n\tu32 type;\n\tunsigned long\t\tflags;\n\tstatic const u32 ep_key[9] = { 1, 0, 1, 0, 1, 1, 0, 1, 0 };\n\tint ret = 0;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || !desc || ep->desc || _ep->name == ep0name ||\n\t\t\tdesc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_err(\"%s: failed at line=%d\\n\", __func__, __LINE__);\n\t\treturn -EINVAL;\n\t}\n\tdev = ep->dev;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto print_err;\n\t}\n\n\t \n\tif ((desc->bEndpointAddress & 0x0f) == EP_DONTUSE) {\n\t\tret = -EDOM;\n\t\tgoto print_err;\n\t}\n\n\tif (dev->quirks & PLX_PCIE) {\n\t\tif ((desc->bEndpointAddress & 0x0f) >= 0x0c) {\n\t\t\tret = -EDOM;\n\t\t\tgoto print_err;\n\t\t}\n\t\tep->is_in = !!usb_endpoint_dir_in(desc);\n\t\tif (dev->enhanced_mode && ep->is_in && ep_key[ep->num]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto print_err;\n\t\t}\n\t}\n\n\t \n\tmax = usb_endpoint_maxp(desc);\n\tif (ep->num > 4 && max > 64 && (dev->quirks & PLX_LEGACY)) {\n\t\tret = -ERANGE;\n\t\tgoto print_err;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\t_ep->maxpacket = max;\n\tep->desc = desc;\n\n\t \n\tep->stopped = 0;\n\tep->wedged = 0;\n\tep->out_overflow = 0;\n\n\t \n\tset_max_speed(ep, max);\n\n\t \n\twritel(BIT(FIFO_FLUSH), &ep->regs->ep_stat);\n\n\tif ((dev->quirks & PLX_PCIE) && dev->enhanced_mode) {\n\t\ttmp = readl(&ep->cfg->ep_cfg);\n\t\t \n\t\tif ((tmp & 0xf) != usb_endpoint_num(desc)) {\n\t\t\tret = -EINVAL;\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tgoto print_err;\n\t\t}\n\t\tif (ep->is_in)\n\t\t\ttmp &= ~USB3380_EP_CFG_MASK_IN;\n\t\telse\n\t\t\ttmp &= ~USB3380_EP_CFG_MASK_OUT;\n\t}\n\ttype = (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\n\tif (type == USB_ENDPOINT_XFER_INT) {\n\t\t \n\t\tif (dev->chiprev == 0100 &&\n\t\t\t\tdev->gadget.speed == USB_SPEED_HIGH &&\n\t\t\t\t!(desc->bEndpointAddress & USB_DIR_IN))\n\t\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS_MODE),\n\t\t\t\t&ep->regs->ep_rsp);\n\t} else if (type == USB_ENDPOINT_XFER_BULK) {\n\t\t \n\t\tif ((dev->gadget.speed == USB_SPEED_SUPER && max != 1024) ||\n\t\t    (dev->gadget.speed == USB_SPEED_HIGH && max != 512) ||\n\t\t    (dev->gadget.speed == USB_SPEED_FULL && max > 64)) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tret = -ERANGE;\n\t\t\tgoto print_err;\n\t\t}\n\t}\n\tep->is_iso = (type == USB_ENDPOINT_XFER_ISOC);\n\t \n\tif (dev->quirks & PLX_LEGACY) {\n\t\ttmp |= type << ENDPOINT_TYPE;\n\t\ttmp |= desc->bEndpointAddress;\n\t\t \n\t\ttmp |= (4 << ENDPOINT_BYTE_COUNT);\n\t\ttmp |= BIT(ENDPOINT_ENABLE);\n\t\tep->is_in = (tmp & USB_DIR_IN) != 0;\n\t} else {\n\t\t \n\t\tif (dev->enhanced_mode && ep->is_in) {\n\t\t\ttmp |= type << IN_ENDPOINT_TYPE;\n\t\t\ttmp |= BIT(IN_ENDPOINT_ENABLE);\n\t\t} else {\n\t\t\ttmp |= type << OUT_ENDPOINT_TYPE;\n\t\t\ttmp |= BIT(OUT_ENDPOINT_ENABLE);\n\t\t\ttmp |= (ep->is_in << ENDPOINT_DIRECTION);\n\t\t}\n\n\t\ttmp |= (4 << ENDPOINT_BYTE_COUNT);\n\t\tif (!dev->enhanced_mode)\n\t\t\ttmp |= usb_endpoint_num(desc);\n\t\ttmp |= (ep->ep.maxburst << MAX_BURST_SIZE);\n\t}\n\n\t \n\twmb();\n\n\t \n\tif (!ep->is_in)\n\t\twritel(BIT(SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\n\telse if (!(dev->quirks & PLX_2280)) {\n\t\t \n\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS) |\n\t\t\tBIT(CLEAR_NAK_OUT_PACKETS_MODE), &ep->regs->ep_rsp);\n\t}\n\n\tif (dev->quirks & PLX_PCIE)\n\t\tep_clear_seqnum(ep);\n\twritel(tmp, &ep->cfg->ep_cfg);\n\n\t \n\tif (!ep->dma) {\t\t\t\t \n\t\tenable_pciirqenb(ep);\n\n\t\ttmp = BIT(DATA_PACKET_RECEIVED_INTERRUPT_ENABLE) |\n\t\t\tBIT(DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE);\n\t\tif (dev->quirks & PLX_2280)\n\t\t\ttmp |= readl(&ep->regs->ep_irqenb);\n\t\twritel(tmp, &ep->regs->ep_irqenb);\n\t} else {\t\t\t\t \n\t\ttmp = BIT((8 + ep->num));\t \n\t\ttmp |= readl(&dev->regs->pciirqenb1);\n\t\twritel(tmp, &dev->regs->pciirqenb1);\n\n\t\t \n\t\tif ((desc->bEndpointAddress & USB_DIR_IN) == 0) {\n\t\t\ttmp = BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT_ENABLE);\n\t\t\twritel(tmp, &ep->regs->ep_irqenb);\n\n\t\t\tenable_pciirqenb(ep);\n\t\t}\n\t}\n\n\ttmp = desc->bEndpointAddress;\n\tep_dbg(dev, \"enabled %s (ep%d%s-%s) %s max %04x\\n\",\n\t\t_ep->name, tmp & 0x0f, DIR_STRING(tmp),\n\t\ttype_string(desc->bmAttributes),\n\t\tep->dma ? \"dma\" : \"pio\", max);\n\n\t \n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n\nprint_err:\n\tdev_err(&ep->dev->pdev->dev, \"%s: error=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int handshake(u32 __iomem *ptr, u32 mask, u32 done, int usec)\n{\n\tu32\tresult;\n\tint\tret;\n\n\tret = readl_poll_timeout_atomic(ptr, result,\n\t\t\t\t\t((result & mask) == done ||\n\t\t\t\t\t result == U32_MAX),\n\t\t\t\t\t1, usec);\n\tif (result == U32_MAX)\t\t \n\t\treturn -ENODEV;\n\n\treturn ret;\n}\n\nstatic const struct usb_ep_ops net2280_ep_ops;\n\nstatic void ep_reset_228x(struct net2280_regs __iomem *regs,\n\t\t\t  struct net2280_ep *ep)\n{\n\tu32\t\ttmp;\n\n\tep->desc = NULL;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tusb_ep_set_maxpacket_limit(&ep->ep, ~0);\n\tep->ep.ops = &net2280_ep_ops;\n\n\t \n\tif (ep->dma) {\n\t\twritel(0, &ep->dma->dmactl);\n\t\twritel(BIT(DMA_SCATTER_GATHER_DONE_INTERRUPT) |\n\t\t\tBIT(DMA_TRANSACTION_DONE_INTERRUPT) |\n\t\t\tBIT(DMA_ABORT),\n\t\t\t&ep->dma->dmastat);\n\n\t\ttmp = readl(&regs->pciirqenb0);\n\t\ttmp &= ~BIT(ep->num);\n\t\twritel(tmp, &regs->pciirqenb0);\n\t} else {\n\t\ttmp = readl(&regs->pciirqenb1);\n\t\ttmp &= ~BIT((8 + ep->num));\t \n\t\twritel(tmp, &regs->pciirqenb1);\n\t}\n\twritel(0, &ep->regs->ep_irqenb);\n\n\t \n\tif (!ep->is_in || (ep->dev->quirks & PLX_2280)) {\n\t\ttmp = BIT(SET_NAK_OUT_PACKETS_MODE) |\n\t\tBIT(SET_NAK_OUT_PACKETS) |\n\t\tBIT(CLEAR_EP_HIDE_STATUS_PHASE) |\n\t\tBIT(CLEAR_INTERRUPT_MODE);\n\t} else {\n\t\t \n\t\ttmp = BIT(CLEAR_NAK_OUT_PACKETS_MODE) |\n\t\tBIT(CLEAR_NAK_OUT_PACKETS) |\n\t\tBIT(CLEAR_EP_HIDE_STATUS_PHASE) |\n\t\tBIT(CLEAR_INTERRUPT_MODE);\n\t}\n\n\tif (ep->num != 0) {\n\t\ttmp |= BIT(CLEAR_ENDPOINT_TOGGLE) |\n\t\t\tBIT(CLEAR_ENDPOINT_HALT);\n\t}\n\twritel(tmp, &ep->regs->ep_rsp);\n\n\t \n\tif (ep->dev->quirks & PLX_2280)\n\t\ttmp = BIT(FIFO_OVERFLOW) |\n\t\t\tBIT(FIFO_UNDERFLOW);\n\telse\n\t\ttmp = 0;\n\n\twritel(tmp | BIT(TIMEOUT) |\n\t\tBIT(USB_STALL_SENT) |\n\t\tBIT(USB_IN_NAK_SENT) |\n\t\tBIT(USB_IN_ACK_RCVD) |\n\t\tBIT(USB_OUT_PING_NAK_SENT) |\n\t\tBIT(USB_OUT_ACK_SENT) |\n\t\tBIT(FIFO_FLUSH) |\n\t\tBIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\n\t\tBIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\n\t\tBIT(DATA_PACKET_RECEIVED_INTERRUPT) |\n\t\tBIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\n\t\tBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t\tBIT(DATA_IN_TOKEN_INTERRUPT),\n\t\t&ep->regs->ep_stat);\n\n\t \n}\n\nstatic void ep_reset_338x(struct net2280_regs __iomem *regs,\n\t\t\t\t\tstruct net2280_ep *ep)\n{\n\tu32 tmp, dmastat;\n\n\tep->desc = NULL;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tusb_ep_set_maxpacket_limit(&ep->ep, ~0);\n\tep->ep.ops = &net2280_ep_ops;\n\n\t \n\tif (ep->dma) {\n\t\twritel(0, &ep->dma->dmactl);\n\t\twritel(BIT(DMA_ABORT_DONE_INTERRUPT) |\n\t\t       BIT(DMA_PAUSE_DONE_INTERRUPT) |\n\t\t       BIT(DMA_SCATTER_GATHER_DONE_INTERRUPT) |\n\t\t       BIT(DMA_TRANSACTION_DONE_INTERRUPT),\n\t\t        \n\t\t       &ep->dma->dmastat);\n\n\t\tdmastat = readl(&ep->dma->dmastat);\n\t\tif (dmastat == 0x5002) {\n\t\t\tep_warn(ep->dev, \"The dmastat return = %x!!\\n\",\n\t\t\t       dmastat);\n\t\t\twritel(0x5a, &ep->dma->dmastat);\n\t\t}\n\n\t\ttmp = readl(&regs->pciirqenb0);\n\t\ttmp &= ~BIT(ep_bit[ep->num]);\n\t\twritel(tmp, &regs->pciirqenb0);\n\t} else {\n\t\tif (ep->num < 5) {\n\t\t\ttmp = readl(&regs->pciirqenb1);\n\t\t\ttmp &= ~BIT((8 + ep->num));\t \n\t\t\twritel(tmp, &regs->pciirqenb1);\n\t\t}\n\t}\n\twritel(0, &ep->regs->ep_irqenb);\n\n\twritel(BIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\n\t       BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\n\t       BIT(FIFO_OVERFLOW) |\n\t       BIT(DATA_PACKET_RECEIVED_INTERRUPT) |\n\t       BIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\n\t       BIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t       BIT(DATA_IN_TOKEN_INTERRUPT), &ep->regs->ep_stat);\n\n\ttmp = readl(&ep->cfg->ep_cfg);\n\tif (ep->is_in)\n\t\ttmp &= ~USB3380_EP_CFG_MASK_IN;\n\telse\n\t\ttmp &= ~USB3380_EP_CFG_MASK_OUT;\n\twritel(tmp, &ep->cfg->ep_cfg);\n}\n\nstatic void nuke(struct net2280_ep *);\n\nstatic int net2280_disable(struct usb_ep *_ep)\n{\n\tstruct net2280_ep\t*ep;\n\tunsigned long\t\tflags;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || _ep->name == ep0name) {\n\t\tpr_err(\"%s: Invalid ep=%p\\n\", __func__, _ep);\n\t\treturn -EINVAL;\n\t}\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tnuke(ep);\n\n\tif (ep->dev->quirks & PLX_PCIE)\n\t\tep_reset_338x(ep->dev->regs, ep);\n\telse\n\t\tep_reset_228x(ep->dev->regs, ep);\n\n\tep_vdbg(ep->dev, \"disabled %s %s\\n\",\n\t\t\tep->dma ? \"dma\" : \"pio\", _ep->name);\n\n\t \n\t(void)readl(&ep->cfg->ep_cfg);\n\n\tif (!ep->dma && ep->num >= 1 && ep->num <= 4)\n\t\tep->dma = &ep->dev->dma[ep->num - 1];\n\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic struct usb_request\n*net2280_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct net2280_ep\t*ep;\n\tstruct net2280_request\t*req;\n\n\tif (!_ep) {\n\t\tpr_err(\"%s: Invalid ep\\n\", __func__);\n\t\treturn NULL;\n\t}\n\tep = container_of(_ep, struct net2280_ep, ep);\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\t \n\tif (ep->dma) {\n\t\tstruct net2280_dma\t*td;\n\n\t\ttd = dma_pool_alloc(ep->dev->requests, gfp_flags,\n\t\t\t\t&req->td_dma);\n\t\tif (!td) {\n\t\t\tkfree(req);\n\t\t\treturn NULL;\n\t\t}\n\t\ttd->dmacount = 0;\t \n\t\ttd->dmadesc = td->dmaaddr;\n\t\treq->td = td;\n\t}\n\treturn &req->req;\n}\n\nstatic void net2280_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct net2280_ep\t*ep;\n\tstruct net2280_request\t*req;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || !_req) {\n\t\tdev_err(&ep->dev->pdev->dev, \"%s: Invalid ep=%p or req=%p\\n\",\n\t\t\t\t\t\t\t__func__, _ep, _req);\n\t\treturn;\n\t}\n\n\treq = container_of(_req, struct net2280_request, req);\n\tWARN_ON(!list_empty(&req->queue));\n\tif (req->td)\n\t\tdma_pool_free(ep->dev->requests, req->td, req->td_dma);\n\tkfree(req);\n}\n\n \n\n \nstatic void write_fifo(struct net2280_ep *ep, struct usb_request *req)\n{\n\tstruct net2280_ep_regs\t__iomem *regs = ep->regs;\n\tu8\t\t\t*buf;\n\tu32\t\t\ttmp;\n\tunsigned\t\tcount, total;\n\n\t \n\n\tif (req) {\n\t\tbuf = req->buf + req->actual;\n\t\tprefetch(buf);\n\t\ttotal = req->length - req->actual;\n\t} else {\n\t\ttotal = 0;\n\t\tbuf = NULL;\n\t}\n\n\t \n\tcount = ep->ep.maxpacket;\n\tif (count > total)\t \n\t\tcount = total;\n\n\tep_vdbg(ep->dev, \"write %s fifo (IN) %d bytes%s req %p\\n\",\n\t\t\tep->ep.name, count,\n\t\t\t(count != ep->ep.maxpacket) ? \" (short)\" : \"\",\n\t\t\treq);\n\twhile (count >= 4) {\n\t\t \n\t\ttmp = get_unaligned((u32 *)buf);\n\t\tcpu_to_le32s(&tmp);\n\t\twritel(tmp, &regs->ep_data);\n\t\tbuf += 4;\n\t\tcount -= 4;\n\t}\n\n\t \n\tif (count || total < ep->ep.maxpacket) {\n\t\ttmp = count ? get_unaligned((u32 *)buf) : count;\n\t\tcpu_to_le32s(&tmp);\n\t\tset_fifo_bytecount(ep, count & 0x03);\n\t\twritel(tmp, &regs->ep_data);\n\t}\n\n\t \n}\n\n \nstatic void out_flush(struct net2280_ep *ep)\n{\n\tu32\t__iomem *statp;\n\tu32\ttmp;\n\n\tstatp = &ep->regs->ep_stat;\n\n\ttmp = readl(statp);\n\tif (tmp & BIT(NAK_OUT_PACKETS)) {\n\t\tep_dbg(ep->dev, \"%s %s %08x !NAK\\n\",\n\t\t\tep->ep.name, __func__, tmp);\n\t\twritel(BIT(SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\n\t}\n\n\twritel(BIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t\tBIT(DATA_PACKET_RECEIVED_INTERRUPT),\n\t\tstatp);\n\twritel(BIT(FIFO_FLUSH), statp);\n\t \n\tmb();\n\ttmp = readl(statp);\n\tif (tmp & BIT(DATA_OUT_PING_TOKEN_INTERRUPT) &&\n\t\t\t \n\t\t\tep->dev->gadget.speed == USB_SPEED_FULL) {\n\t\tunsigned\tusec;\n\n\t\tusec = 50;\t\t \n\t\thandshake(statp, BIT(USB_OUT_PING_NAK_SENT),\n\t\t\t\tBIT(USB_OUT_PING_NAK_SENT), usec);\n\t\t \n\t}\n}\n\n \nstatic int read_fifo(struct net2280_ep *ep, struct net2280_request *req)\n{\n\tstruct net2280_ep_regs\t__iomem *regs = ep->regs;\n\tu8\t\t\t*buf = req->req.buf + req->req.actual;\n\tunsigned\t\tcount, tmp, is_short;\n\tunsigned\t\tcleanup = 0, prevent = 0;\n\n\t \n\tif (ep->dev->chiprev == 0x0100 &&\n\t\t\tep->dev->gadget.speed == USB_SPEED_FULL) {\n\t\tudelay(1);\n\t\ttmp = readl(&ep->regs->ep_stat);\n\t\tif ((tmp & BIT(NAK_OUT_PACKETS)))\n\t\t\tcleanup = 1;\n\t\telse if ((tmp & BIT(FIFO_FULL))) {\n\t\t\tstart_out_naking(ep);\n\t\t\tprevent = 1;\n\t\t}\n\t\t \n\t}\n\n\t \n\tprefetchw(buf);\n\tcount = readl(&regs->ep_avail);\n\tif (unlikely(count == 0)) {\n\t\tudelay(1);\n\t\ttmp = readl(&ep->regs->ep_stat);\n\t\tcount = readl(&regs->ep_avail);\n\t\t \n\t\tif (count == 0 && (tmp & BIT(NAK_OUT_PACKETS)) == 0)\n\t\t\treturn 0;\n\t}\n\n\ttmp = req->req.length - req->req.actual;\n\tif (count > tmp) {\n\t\t \n\t\tif ((tmp % ep->ep.maxpacket) != 0) {\n\t\t\tep_err(ep->dev,\n\t\t\t\t\"%s out fifo %d bytes, expected %d\\n\",\n\t\t\t\tep->ep.name, count, tmp);\n\t\t\treq->req.status = -EOVERFLOW;\n\t\t\tcleanup = 1;\n\t\t\t \n\t\t}  \n\t\tcount = tmp;\n\t}\n\treq->req.actual += count;\n\n\tis_short = (count == 0) || ((count % ep->ep.maxpacket) != 0);\n\n\tep_vdbg(ep->dev, \"read %s fifo (OUT) %d bytes%s%s%s req %p %d/%d\\n\",\n\t\t\tep->ep.name, count, is_short ? \" (short)\" : \"\",\n\t\t\tcleanup ? \" flush\" : \"\", prevent ? \" nak\" : \"\",\n\t\t\treq, req->req.actual, req->req.length);\n\n\twhile (count >= 4) {\n\t\ttmp = readl(&regs->ep_data);\n\t\tcpu_to_le32s(&tmp);\n\t\tput_unaligned(tmp, (u32 *)buf);\n\t\tbuf += 4;\n\t\tcount -= 4;\n\t}\n\tif (count) {\n\t\ttmp = readl(&regs->ep_data);\n\t\t \n\t\tdo {\n\t\t\t*buf++ = (u8) tmp;\n\t\t\ttmp >>= 8;\n\t\t} while (--count);\n\t}\n\tif (cleanup)\n\t\tout_flush(ep);\n\tif (prevent) {\n\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\n\t\t(void) readl(&ep->regs->ep_rsp);\n\t}\n\n\treturn is_short || req->req.actual == req->req.length;\n}\n\n \nstatic void fill_dma_desc(struct net2280_ep *ep,\n\t\t\t\t\tstruct net2280_request *req, int valid)\n{\n\tstruct net2280_dma\t*td = req->td;\n\tu32\t\t\tdmacount = req->req.length;\n\n\t \n\tif (ep->is_in)\n\t\tdmacount |= BIT(DMA_DIRECTION);\n\tif ((!ep->is_in && (dmacount % ep->ep.maxpacket) != 0) ||\n\t\t\t\t\t!(ep->dev->quirks & PLX_2280))\n\t\tdmacount |= BIT(END_OF_CHAIN);\n\n\treq->valid = valid;\n\tif (valid)\n\t\tdmacount |= BIT(VALID_BIT);\n\tdmacount |= BIT(DMA_DONE_INTERRUPT_ENABLE);\n\n\t \n\ttd->dmaaddr = cpu_to_le32 (req->req.dma);\n\n\t \n\twmb();\n\ttd->dmacount = cpu_to_le32(dmacount);\n}\n\nstatic const u32 dmactl_default =\n\t\tBIT(DMA_SCATTER_GATHER_DONE_INTERRUPT) |\n\t\tBIT(DMA_CLEAR_COUNT_ENABLE) |\n\t\t \n\t\t(POLL_100_USEC << DESCRIPTOR_POLLING_RATE) |\n\t\tBIT(DMA_VALID_BIT_POLLING_ENABLE) |\n\t\tBIT(DMA_VALID_BIT_ENABLE) |\n\t\tBIT(DMA_SCATTER_GATHER_ENABLE) |\n\t\t \n\t\tBIT(DMA_ENABLE);\n\nstatic inline void spin_stop_dma(struct net2280_dma_regs __iomem *dma)\n{\n\thandshake(&dma->dmactl, BIT(DMA_ENABLE), 0, 50);\n}\n\nstatic inline void stop_dma(struct net2280_dma_regs __iomem *dma)\n{\n\twritel(readl(&dma->dmactl) & ~BIT(DMA_ENABLE), &dma->dmactl);\n\tspin_stop_dma(dma);\n}\n\nstatic void start_queue(struct net2280_ep *ep, u32 dmactl, u32 td_dma)\n{\n\tstruct net2280_dma_regs\t__iomem *dma = ep->dma;\n\tunsigned int tmp = BIT(VALID_BIT) | (ep->is_in << DMA_DIRECTION);\n\n\tif (!(ep->dev->quirks & PLX_2280))\n\t\ttmp |= BIT(END_OF_CHAIN);\n\n\twritel(tmp, &dma->dmacount);\n\twritel(readl(&dma->dmastat), &dma->dmastat);\n\n\twritel(td_dma, &dma->dmadesc);\n\tif (ep->dev->quirks & PLX_PCIE)\n\t\tdmactl |= BIT(DMA_REQUEST_OUTSTANDING);\n\twritel(dmactl, &dma->dmactl);\n\n\t \n\t(void) readl(&ep->dev->pci->pcimstctl);\n\n\twritel(BIT(DMA_START), &dma->dmastat);\n}\n\nstatic void start_dma(struct net2280_ep *ep, struct net2280_request *req)\n{\n\tu32\t\t\ttmp;\n\tstruct net2280_dma_regs\t__iomem *dma = ep->dma;\n\n\t \n\n\t \n\tWARN_ON(readl(&dma->dmactl) & BIT(DMA_ENABLE));\n\twritel(0, &ep->dma->dmactl);\n\n\t \n\tif (!ep->is_in && (readl(&ep->regs->ep_stat) &\n\t\t\t\tBIT(NAK_OUT_PACKETS))) {\n\t\twritel(BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT),\n\t\t\t&ep->regs->ep_stat);\n\n\t\ttmp = readl(&ep->regs->ep_avail);\n\t\tif (tmp) {\n\t\t\twritel(readl(&dma->dmastat), &dma->dmastat);\n\n\t\t\t \n\t\t\twritel(req->req.dma, &dma->dmaaddr);\n\t\t\ttmp = min(tmp, req->req.length);\n\n\t\t\t \n\t\t\treq->td->dmacount = cpu_to_le32(req->req.length - tmp);\n\t\t\twritel(BIT(DMA_DONE_INTERRUPT_ENABLE) | tmp,\n\t\t\t\t\t&dma->dmacount);\n\t\t\treq->td->dmadesc = 0;\n\t\t\treq->valid = 1;\n\n\t\t\twritel(BIT(DMA_ENABLE), &dma->dmactl);\n\t\t\twritel(BIT(DMA_START), &dma->dmastat);\n\t\t\treturn;\n\t\t}\n\t\tstop_out_naking(ep);\n\t}\n\n\ttmp = dmactl_default;\n\n\t \n\tif (ep->is_in) {\n\t\tif (likely((req->req.length % ep->ep.maxpacket) ||\n\t\t\t\t\t\t\treq->req.zero)){\n\t\t\ttmp |= BIT(DMA_FIFO_VALIDATE);\n\t\t\tep->in_fifo_validate = 1;\n\t\t} else\n\t\t\tep->in_fifo_validate = 0;\n\t}\n\n\t \n\treq->td->dmadesc = cpu_to_le32 (ep->td_dma);\n\tfill_dma_desc(ep, req, 1);\n\n\treq->td->dmacount |= cpu_to_le32(BIT(END_OF_CHAIN));\n\n\tstart_queue(ep, tmp, req->td_dma);\n}\n\nstatic inline void\nqueue_dma(struct net2280_ep *ep, struct net2280_request *req, int valid)\n{\n\t \n\tswap(ep->dummy, req->td);\n\tswap(ep->td_dma, req->td_dma);\n\n\treq->td->dmadesc = cpu_to_le32 (ep->td_dma);\n\n\tfill_dma_desc(ep, req, valid);\n}\n\nstatic void\ndone(struct net2280_ep *ep, struct net2280_request *req, int status)\n{\n\tstruct net2280\t\t*dev;\n\tunsigned\t\tstopped = ep->stopped;\n\n\tlist_del_init(&req->queue);\n\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tdev = ep->dev;\n\tif (ep->dma)\n\t\tusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\n\n\tif (status && status != -ESHUTDOWN)\n\t\tep_vdbg(dev, \"complete %s req %p stat %d len %u/%u\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\t \n\tep->stopped = 1;\n\tspin_unlock(&dev->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&dev->lock);\n\tep->stopped = stopped;\n}\n\n \n\nstatic int\nnet2280_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct net2280_request\t*req;\n\tstruct net2280_ep\t*ep;\n\tstruct net2280\t\t*dev;\n\tunsigned long\t\tflags;\n\tint ret = 0;\n\n\t \n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0)) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep->desc\\n\", __func__, _ep);\n\t\treturn -EINVAL;\n\t}\n\treq = container_of(_req, struct net2280_request, req);\n\tif (!_req || !_req->complete || !_req->buf ||\n\t\t\t\t!list_empty(&req->queue)) {\n\t\tret = -EINVAL;\n\t\tgoto print_err;\n\t}\n\tif (_req->length > (~0 & DMA_BYTE_COUNT_MASK)) {\n\t\tret = -EDOM;\n\t\tgoto print_err;\n\t}\n\tdev = ep->dev;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto print_err;\n\t}\n\n\t \n\tif (ep->dma && _req->length == 0) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto print_err;\n\t}\n\n\t \n\tif (ep->dma) {\n\t\tret = usb_gadget_map_request(&dev->gadget, _req,\n\t\t\t\tep->is_in);\n\t\tif (ret)\n\t\t\tgoto print_err;\n\t}\n\n\tep_vdbg(dev, \"%s queue req %p, len %d buf %p\\n\",\n\t\t\t_ep->name, _req, _req->length, _req->buf);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\t \n\tif  (list_empty(&ep->queue) && !ep->stopped &&\n\t\t!((dev->quirks & PLX_PCIE) && ep->dma &&\n\t\t  (readl(&ep->regs->ep_rsp) & BIT(CLEAR_ENDPOINT_HALT)))) {\n\n\t\t \n\t\tif (ep->dma)\n\t\t\tstart_dma(ep, req);\n\t\telse {\n\t\t\t \n\t\t\tif (ep->num == 0 && _req->length == 0) {\n\t\t\t\tallow_status(ep);\n\t\t\t\tdone(ep, req, 0);\n\t\t\t\tep_vdbg(dev, \"%s status ack\\n\", ep->ep.name);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (ep->is_in)\n\t\t\t\twrite_fifo(ep, _req);\n\t\t\telse {\n\t\t\t\tu32\ts;\n\n\t\t\t\t \n\t\t\t\ts = readl(&ep->regs->ep_stat);\n\t\t\t\tif ((s & BIT(FIFO_EMPTY)) == 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (read_fifo(ep, req) &&\n\t\t\t\t\t\t\tep->num == 0) {\n\t\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t\t\tallow_status(ep);\n\t\t\t\t\t\t \n\t\t\t\t\t\treq = NULL;\n\t\t\t\t\t} else if (read_fifo(ep, req) &&\n\t\t\t\t\t\t\tep->num != 0) {\n\t\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t\t\treq = NULL;\n\t\t\t\t\t} else\n\t\t\t\t\t\ts = readl(&ep->regs->ep_stat);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (req && (s & BIT(NAK_OUT_PACKETS)))\n\t\t\t\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS),\n\t\t\t\t\t\t\t&ep->regs->ep_rsp);\n\t\t\t}\n\t\t}\n\n\t} else if (ep->dma) {\n\t\tint\tvalid = 1;\n\n\t\tif (ep->is_in) {\n\t\t\tint\texpect;\n\n\t\t\t \n\t\t\texpect = likely(req->req.zero ||\n\t\t\t\t(req->req.length % ep->ep.maxpacket));\n\t\t\tif (expect != ep->in_fifo_validate)\n\t\t\t\tvalid = 0;\n\t\t}\n\t\tqueue_dma(ep, req, valid);\n\n\t}  \n\n\tep->responded = 1;\n\tif (req)\n\t\tlist_add_tail(&req->queue, &ep->queue);\ndone:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\treturn ret;\n\nprint_err:\n\tdev_err(&ep->dev->pdev->dev, \"%s: error=%d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic inline void\ndma_done(struct net2280_ep *ep,\tstruct net2280_request *req, u32 dmacount,\n\t\tint status)\n{\n\treq->req.actual = req->req.length - (DMA_BYTE_COUNT_MASK & dmacount);\n\tdone(ep, req, status);\n}\n\nstatic int scan_dma_completions(struct net2280_ep *ep)\n{\n\tint num_completed = 0;\n\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct net2280_request\t*req;\n\t\tu32 req_dma_count;\n\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct net2280_request, queue);\n\t\tif (!req->valid)\n\t\t\tbreak;\n\t\trmb();\n\t\treq_dma_count = le32_to_cpup(&req->td->dmacount);\n\t\tif ((req_dma_count & BIT(VALID_BIT)) != 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unlikely(req->td->dmadesc == 0)) {\n\t\t\t \n\t\t\tu32 const ep_dmacount = readl(&ep->dma->dmacount);\n\n\t\t\tif (ep_dmacount & DMA_BYTE_COUNT_MASK)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tdma_done(ep, req, req_dma_count, 0);\n\t\t\tnum_completed++;\n\t\t\tbreak;\n\t\t} else if (!ep->is_in &&\n\t\t\t   (req->req.length % ep->ep.maxpacket) &&\n\t\t\t   !(ep->dev->quirks & PLX_PCIE)) {\n\n\t\t\tu32 const ep_stat = readl(&ep->regs->ep_stat);\n\t\t\t \n\t\t\tif ((ep_stat & BIT(NAK_OUT_PACKETS)) == 0) {\n\t\t\t\tep_warn(ep->dev, \"%s lost packet sync!\\n\",\n\t\t\t\t\t\tep->ep.name);\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t} else {\n\t\t\t\tu32 const ep_avail = readl(&ep->regs->ep_avail);\n\t\t\t\tif (ep_avail) {\n\t\t\t\t\t \n\t\t\t\t\tep->out_overflow = 1;\n\t\t\t\t\tep_dbg(ep->dev,\n\t\t\t\t\t\t\"%s dma, discard %d len %d\\n\",\n\t\t\t\t\t\tep->ep.name, ep_avail,\n\t\t\t\t\t\treq->req.length);\n\t\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdma_done(ep, req, req_dma_count, 0);\n\t\tnum_completed++;\n\t}\n\n\treturn num_completed;\n}\n\nstatic void restart_dma(struct net2280_ep *ep)\n{\n\tstruct net2280_request\t*req;\n\n\tif (ep->stopped)\n\t\treturn;\n\treq = list_entry(ep->queue.next, struct net2280_request, queue);\n\n\tstart_dma(ep, req);\n}\n\nstatic void abort_dma(struct net2280_ep *ep)\n{\n\t \n\tif (likely(!list_empty(&ep->queue))) {\n\t\t \n\t\twritel(BIT(DMA_ABORT), &ep->dma->dmastat);\n\t\tspin_stop_dma(ep->dma);\n\t} else\n\t\tstop_dma(ep->dma);\n\tscan_dma_completions(ep);\n}\n\n \nstatic void nuke(struct net2280_ep *ep)\n{\n\tstruct net2280_request\t*req;\n\n\t \n\tep->stopped = 1;\n\tif (ep->dma)\n\t\tabort_dma(ep);\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct net2280_request,\n\t\t\t\tqueue);\n\t\tdone(ep, req, -ESHUTDOWN);\n\t}\n}\n\n \nstatic int net2280_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct net2280_ep\t*ep;\n\tstruct net2280_request\t*req = NULL;\n\tstruct net2280_request\t*iter;\n\tunsigned long\t\tflags;\n\tu32\t\t\tdmactl;\n\tint\t\t\tstopped;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0) || !_req) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep->desc or req=%p\\n\",\n\t\t\t\t\t\t__func__, _ep, _req);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tstopped = ep->stopped;\n\n\t \n\tdmactl = 0;\n\tep->stopped = 1;\n\tif (ep->dma) {\n\t\tdmactl = readl(&ep->dma->dmactl);\n\t\t \n\t\tstop_dma(ep->dma);\n\t\tscan_dma_completions(ep);\n\t}\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tep->stopped = stopped;\n\t\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\t\tep_dbg(ep->dev, \"%s: Request mismatch\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\tif (ep->dma) {\n\t\t\tep_dbg(ep->dev, \"unlink (%s) dma\\n\", _ep->name);\n\t\t\t_req->status = -ECONNRESET;\n\t\t\tabort_dma(ep);\n\t\t\tif (likely(ep->queue.next == &req->queue)) {\n\t\t\t\t \n\t\t\t\treq->td->dmacount = 0;\t \n\t\t\t\tdma_done(ep, req,\n\t\t\t\t\treadl(&ep->dma->dmacount),\n\t\t\t\t\t-ECONNRESET);\n\t\t\t}\n\t\t} else {\n\t\t\tep_dbg(ep->dev, \"unlink (%s) pio\\n\", _ep->name);\n\t\t\tdone(ep, req, -ECONNRESET);\n\t\t}\n\t\treq = NULL;\n\t}\n\n\tif (req)\n\t\tdone(ep, req, -ECONNRESET);\n\tep->stopped = stopped;\n\n\tif (ep->dma) {\n\t\t \n\t\tif (list_empty(&ep->queue))\n\t\t\tstop_dma(ep->dma);\n\t\telse if (!ep->stopped) {\n\t\t\t \n\t\t\tif (req)\n\t\t\t\twritel(dmactl, &ep->dma->dmactl);\n\t\t\telse\n\t\t\t\tstart_dma(ep, list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2280_request, queue));\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int net2280_fifo_status(struct usb_ep *_ep);\n\nstatic int\nnet2280_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\n{\n\tstruct net2280_ep\t*ep;\n\tunsigned long\t\tflags;\n\tint\t\t\tretval = 0;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0)) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep->desc\\n\", __func__, _ep);\n\t\treturn -EINVAL;\n\t}\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tretval = -ESHUTDOWN;\n\t\tgoto print_err;\n\t}\n\tif (ep->desc   && (ep->desc->bmAttributes & 0x03)\n\t\t\t\t\t\t== USB_ENDPOINT_XFER_ISOC) {\n\t\tretval = -EINVAL;\n\t\tgoto print_err;\n\t}\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tif (!list_empty(&ep->queue)) {\n\t\tretval = -EAGAIN;\n\t\tgoto print_unlock;\n\t} else if (ep->is_in && value && net2280_fifo_status(_ep) != 0) {\n\t\tretval = -EAGAIN;\n\t\tgoto print_unlock;\n\t} else {\n\t\tep_vdbg(ep->dev, \"%s %s %s\\n\", _ep->name,\n\t\t\t\tvalue ? \"set\" : \"clear\",\n\t\t\t\twedged ? \"wedge\" : \"halt\");\n\t\t \n\t\tif (value) {\n\t\t\tif (ep->num == 0)\n\t\t\t\tep->dev->protocol_stall = 1;\n\t\t\telse\n\t\t\t\tset_halt(ep);\n\t\t\tif (wedged)\n\t\t\t\tep->wedged = 1;\n\t\t} else {\n\t\t\tclear_halt(ep);\n\t\t\tif (ep->dev->quirks & PLX_PCIE &&\n\t\t\t\t!list_empty(&ep->queue) && ep->td_dma)\n\t\t\t\t\trestart_dma(ep);\n\t\t\tep->wedged = 0;\n\t\t}\n\t\t(void) readl(&ep->regs->ep_rsp);\n\t}\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\n\treturn retval;\n\nprint_unlock:\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\nprint_err:\n\tdev_err(&ep->dev->pdev->dev, \"%s: error=%d\\n\", __func__, retval);\n\treturn retval;\n}\n\nstatic int net2280_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn net2280_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int net2280_set_wedge(struct usb_ep *_ep)\n{\n\tif (!_ep || _ep->name == ep0name) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep0\\n\", __func__, _ep);\n\t\treturn -EINVAL;\n\t}\n\treturn net2280_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic int net2280_fifo_status(struct usb_ep *_ep)\n{\n\tstruct net2280_ep\t*ep;\n\tu32\t\t\tavail;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0)) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep->desc\\n\", __func__, _ep);\n\t\treturn -ENODEV;\n\t}\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_err(&ep->dev->pdev->dev,\n\t\t\t\"%s: Invalid driver=%p or speed=%d\\n\",\n\t\t\t__func__, ep->dev->driver, ep->dev->gadget.speed);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tavail = readl(&ep->regs->ep_avail) & (BIT(12) - 1);\n\tif (avail > ep->fifo_size) {\n\t\tdev_err(&ep->dev->pdev->dev, \"%s: Fifo overflow\\n\", __func__);\n\t\treturn -EOVERFLOW;\n\t}\n\tif (ep->is_in)\n\t\tavail = ep->fifo_size - avail;\n\treturn avail;\n}\n\nstatic void net2280_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct net2280_ep\t*ep;\n\n\tep = container_of(_ep, struct net2280_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0)) {\n\t\tpr_err(\"%s: Invalid ep=%p or ep->desc\\n\", __func__, _ep);\n\t\treturn;\n\t}\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_err(&ep->dev->pdev->dev,\n\t\t\t\"%s: Invalid driver=%p or speed=%d\\n\",\n\t\t\t__func__, ep->dev->driver, ep->dev->gadget.speed);\n\t\treturn;\n\t}\n\n\twritel(BIT(FIFO_FLUSH), &ep->regs->ep_stat);\n\t(void) readl(&ep->regs->ep_rsp);\n}\n\nstatic const struct usb_ep_ops net2280_ep_ops = {\n\t.enable\t\t= net2280_enable,\n\t.disable\t= net2280_disable,\n\n\t.alloc_request\t= net2280_alloc_request,\n\t.free_request\t= net2280_free_request,\n\n\t.queue\t\t= net2280_queue,\n\t.dequeue\t= net2280_dequeue,\n\n\t.set_halt\t= net2280_set_halt,\n\t.set_wedge\t= net2280_set_wedge,\n\t.fifo_status\t= net2280_fifo_status,\n\t.fifo_flush\t= net2280_fifo_flush,\n};\n\n \n\nstatic int net2280_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct net2280\t\t*dev;\n\tunsigned long\t\tflags;\n\tu16\t\t\tretval;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct net2280, gadget);\n\tspin_lock_irqsave(&dev->lock, flags);\n\tretval = get_idx_reg(dev->regs, REG_FRAME) & 0x03ff;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn retval;\n}\n\nstatic int net2280_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct net2280\t\t*dev;\n\tu32\t\t\ttmp;\n\tunsigned long\t\tflags;\n\n\tif (!_gadget)\n\t\treturn 0;\n\tdev = container_of(_gadget, struct net2280, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttmp = readl(&dev->usb->usbctl);\n\tif (tmp & BIT(DEVICE_REMOTE_WAKEUP_ENABLE))\n\t\twritel(BIT(GENERATE_RESUME), &dev->usb->usbstat);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\treturn 0;\n}\n\nstatic int net2280_set_selfpowered(struct usb_gadget *_gadget, int value)\n{\n\tstruct net2280\t\t*dev;\n\tu32\t\t\ttmp;\n\tunsigned long\t\tflags;\n\n\tif (!_gadget)\n\t\treturn 0;\n\tdev = container_of(_gadget, struct net2280, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttmp = readl(&dev->usb->usbctl);\n\tif (value) {\n\t\ttmp |= BIT(SELF_POWERED_STATUS);\n\t\t_gadget->is_selfpowered = 1;\n\t} else {\n\t\ttmp &= ~BIT(SELF_POWERED_STATUS);\n\t\t_gadget->is_selfpowered = 0;\n\t}\n\twritel(tmp, &dev->usb->usbctl);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int net2280_pullup(struct usb_gadget *_gadget, int is_on)\n{\n\tstruct net2280  *dev;\n\tu32             tmp;\n\tunsigned long   flags;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct net2280, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttmp = readl(&dev->usb->usbctl);\n\tdev->softconnect = (is_on != 0);\n\tif (is_on) {\n\t\tep0_start(dev);\n\t\twritel(tmp | BIT(USB_DETECT_ENABLE), &dev->usb->usbctl);\n\t} else {\n\t\twritel(tmp & ~BIT(USB_DETECT_ENABLE), &dev->usb->usbctl);\n\t\tstop_activity(dev, NULL);\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_ep *net2280_match_ep(struct usb_gadget *_gadget,\n\t\tstruct usb_endpoint_descriptor *desc,\n\t\tstruct usb_ss_ep_comp_descriptor *ep_comp)\n{\n\tchar name[8];\n\tstruct usb_ep *ep;\n\n\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT) {\n\t\t \n\t\tep = gadget_find_ep_by_name(_gadget, \"ep-e\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep-f\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t}\n\n\t \n\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT &&\n\t    usb_endpoint_dir_in(desc)) {\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep2in\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep4in\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t} else if (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT &&\n\t\t   !usb_endpoint_dir_in(desc)) {\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep1out\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep3out\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t} else if (usb_endpoint_type(desc) != USB_ENDPOINT_XFER_BULK &&\n\t\t   usb_endpoint_dir_in(desc)) {\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep1in\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep3in\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t} else if (usb_endpoint_type(desc) != USB_ENDPOINT_XFER_BULK &&\n\t\t   !usb_endpoint_dir_in(desc)) {\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep2out\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tep = gadget_find_ep_by_name(_gadget, \"ep4out\");\n\t\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), \"ep%d%s\", usb_endpoint_num(desc),\n\t\t\tusb_endpoint_dir_in(desc) ? \"in\" : \"out\");\n\tep = gadget_find_ep_by_name(_gadget, name);\n\tif (ep && usb_gadget_ep_match_desc(_gadget, ep, desc, ep_comp))\n\t\treturn ep;\n\n\treturn NULL;\n}\n\nstatic int net2280_start(struct usb_gadget *_gadget,\n\t\tstruct usb_gadget_driver *driver);\nstatic int net2280_stop(struct usb_gadget *_gadget);\nstatic void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable);\n\nstatic const struct usb_gadget_ops net2280_ops = {\n\t.get_frame\t= net2280_get_frame,\n\t.wakeup\t\t= net2280_wakeup,\n\t.set_selfpowered = net2280_set_selfpowered,\n\t.pullup\t\t= net2280_pullup,\n\t.udc_start\t= net2280_start,\n\t.udc_stop\t= net2280_stop,\n\t.udc_async_callbacks = net2280_async_callbacks,\n\t.match_ep\t= net2280_match_ep,\n};\n\n \n\n#ifdef\tCONFIG_USB_GADGET_DEBUG_FILES\n\n \n\n \nstatic ssize_t function_show(struct device *_dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct net2280\t*dev = dev_get_drvdata(_dev);\n\n\tif (!dev->driver || !dev->driver->function ||\n\t\t\tstrlen(dev->driver->function) > PAGE_SIZE)\n\t\treturn 0;\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", dev->driver->function);\n}\nstatic DEVICE_ATTR_RO(function);\n\nstatic ssize_t registers_show(struct device *_dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct net2280\t\t*dev;\n\tchar\t\t\t*next;\n\tunsigned\t\tsize, t;\n\tunsigned long\t\tflags;\n\tint\t\t\ti;\n\tu32\t\t\tt1, t2;\n\tconst char\t\t*s;\n\n\tdev = dev_get_drvdata(_dev);\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (dev->driver)\n\t\ts = dev->driver->driver.name;\n\telse\n\t\ts = \"(none)\";\n\n\t \n\tt = scnprintf(next, size, \"%s version \" DRIVER_VERSION\n\t\t\t\", chiprev %04x\\n\\n\"\n\t\t\t\"devinit %03x fifoctl %08x gadget '%s'\\n\"\n\t\t\t\"pci irqenb0 %02x irqenb1 %08x \"\n\t\t\t\"irqstat0 %04x irqstat1 %08x\\n\",\n\t\t\tdriver_name, dev->chiprev,\n\t\t\treadl(&dev->regs->devinit),\n\t\t\treadl(&dev->regs->fifoctl),\n\t\t\ts,\n\t\t\treadl(&dev->regs->pciirqenb0),\n\t\t\treadl(&dev->regs->pciirqenb1),\n\t\t\treadl(&dev->regs->irqstat0),\n\t\t\treadl(&dev->regs->irqstat1));\n\tsize -= t;\n\tnext += t;\n\n\t \n\tt1 = readl(&dev->usb->usbctl);\n\tt2 = readl(&dev->usb->usbstat);\n\tif (t1 & BIT(VBUS_PIN)) {\n\t\tif (t2 & BIT(HIGH_SPEED))\n\t\t\ts = \"high speed\";\n\t\telse if (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\t\ts = \"powered\";\n\t\telse\n\t\t\ts = \"full speed\";\n\t\t \n\t} else\n\t\t\ts = \"not attached\";\n\tt = scnprintf(next, size,\n\t\t\t\"stdrsp %08x usbctl %08x usbstat %08x \"\n\t\t\t\t\"addr 0x%02x (%s)\\n\",\n\t\t\treadl(&dev->usb->stdrsp), t1, t2,\n\t\t\treadl(&dev->usb->ouraddr), s);\n\tsize -= t;\n\tnext += t;\n\n\t \n\n\t \n\n\t \n\tfor (i = 0; i < dev->n_ep; i++) {\n\t\tstruct net2280_ep\t*ep;\n\n\t\tep = &dev->ep[i];\n\t\tif (i && !ep->desc)\n\t\t\tcontinue;\n\n\t\tt1 = readl(&ep->cfg->ep_cfg);\n\t\tt2 = readl(&ep->regs->ep_rsp) & 0xff;\n\t\tt = scnprintf(next, size,\n\t\t\t\t\"\\n%s\\tcfg %05x rsp (%02x) %s%s%s%s%s%s%s%s\"\n\t\t\t\t\t\"irqenb %02x\\n\",\n\t\t\t\tep->ep.name, t1, t2,\n\t\t\t\t(t2 & BIT(CLEAR_NAK_OUT_PACKETS))\n\t\t\t\t\t? \"NAK \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_EP_HIDE_STATUS_PHASE))\n\t\t\t\t\t? \"hide \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_EP_FORCE_CRC_ERROR))\n\t\t\t\t\t? \"CRC \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_INTERRUPT_MODE))\n\t\t\t\t\t? \"interrupt \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE))\n\t\t\t\t\t? \"status \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_NAK_OUT_PACKETS_MODE))\n\t\t\t\t\t? \"NAKmode \" : \"\",\n\t\t\t\t(t2 & BIT(CLEAR_ENDPOINT_TOGGLE))\n\t\t\t\t\t? \"DATA1 \" : \"DATA0 \",\n\t\t\t\t(t2 & BIT(CLEAR_ENDPOINT_HALT))\n\t\t\t\t\t? \"HALT \" : \"\",\n\t\t\t\treadl(&ep->regs->ep_irqenb));\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tt = scnprintf(next, size,\n\t\t\t\t\"\\tstat %08x avail %04x \"\n\t\t\t\t\"(ep%d%s-%s)%s\\n\",\n\t\t\t\treadl(&ep->regs->ep_stat),\n\t\t\t\treadl(&ep->regs->ep_avail),\n\t\t\t\tt1 & 0x0f, DIR_STRING(t1),\n\t\t\t\ttype_string(t1 >> 8),\n\t\t\t\tep->stopped ? \"*\" : \"\");\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tif (!ep->dma)\n\t\t\tcontinue;\n\n\t\tt = scnprintf(next, size,\n\t\t\t\t\"  dma\\tctl %08x stat %08x count %08x\\n\"\n\t\t\t\t\"\\taddr %08x desc %08x\\n\",\n\t\t\t\treadl(&ep->dma->dmactl),\n\t\t\t\treadl(&ep->dma->dmastat),\n\t\t\t\treadl(&ep->dma->dmacount),\n\t\t\t\treadl(&ep->dma->dmaaddr),\n\t\t\t\treadl(&ep->dma->dmadesc));\n\t\tsize -= t;\n\t\tnext += t;\n\n\t}\n\n\t \n\n\t \n\tt = scnprintf(next, size, \"\\nirqs:  \");\n\tsize -= t;\n\tnext += t;\n\tfor (i = 0; i < dev->n_ep; i++) {\n\t\tstruct net2280_ep\t*ep;\n\n\t\tep = &dev->ep[i];\n\t\tif (i && !ep->irqs)\n\t\t\tcontinue;\n\t\tt = scnprintf(next, size, \" %s/%lu\", ep->ep.name, ep->irqs);\n\t\tsize -= t;\n\t\tnext += t;\n\n\t}\n\tt = scnprintf(next, size, \"\\n\");\n\tsize -= t;\n\tnext += t;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn PAGE_SIZE - size;\n}\nstatic DEVICE_ATTR_RO(registers);\n\nstatic ssize_t queues_show(struct device *_dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct net2280\t\t*dev;\n\tchar\t\t\t*next;\n\tunsigned\t\tsize;\n\tunsigned long\t\tflags;\n\tint\t\t\ti;\n\n\tdev = dev_get_drvdata(_dev);\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tfor (i = 0; i < dev->n_ep; i++) {\n\t\tstruct net2280_ep\t\t*ep = &dev->ep[i];\n\t\tstruct net2280_request\t\t*req;\n\t\tint\t\t\t\tt;\n\n\t\tif (i != 0) {\n\t\t\tconst struct usb_endpoint_descriptor\t*d;\n\n\t\t\td = ep->desc;\n\t\t\tif (!d)\n\t\t\t\tcontinue;\n\t\t\tt = d->bEndpointAddress;\n\t\t\tt = scnprintf(next, size,\n\t\t\t\t\"\\n%s (ep%d%s-%s) max %04x %s fifo %d\\n\",\n\t\t\t\tep->ep.name, t & USB_ENDPOINT_NUMBER_MASK,\n\t\t\t\t(t & USB_DIR_IN) ? \"in\" : \"out\",\n\t\t\t\ttype_string(d->bmAttributes),\n\t\t\t\tusb_endpoint_maxp(d),\n\t\t\t\tep->dma ? \"dma\" : \"pio\", ep->fifo_size\n\t\t\t\t);\n\t\t} else  \n\t\t\tt = scnprintf(next, size, \"ep0 max 64 pio %s\\n\",\n\t\t\t\t\tep->is_in ? \"in\" : \"out\");\n\t\tif (t <= 0 || t > size)\n\t\t\tgoto done;\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tt = scnprintf(next, size, \"\\t(nothing queued)\\n\");\n\t\t\tif (t <= 0 || t > size)\n\t\t\t\tgoto done;\n\t\t\tsize -= t;\n\t\t\tnext += t;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tif (ep->dma && req->td_dma == readl(&ep->dma->dmadesc))\n\t\t\t\tt = scnprintf(next, size,\n\t\t\t\t\t\"\\treq %p len %d/%d \"\n\t\t\t\t\t\"buf %p (dmacount %08x)\\n\",\n\t\t\t\t\t&req->req, req->req.actual,\n\t\t\t\t\treq->req.length, req->req.buf,\n\t\t\t\t\treadl(&ep->dma->dmacount));\n\t\t\telse\n\t\t\t\tt = scnprintf(next, size,\n\t\t\t\t\t\"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t\t&req->req, req->req.actual,\n\t\t\t\t\treq->req.length, req->req.buf);\n\t\t\tif (t <= 0 || t > size)\n\t\t\t\tgoto done;\n\t\t\tsize -= t;\n\t\t\tnext += t;\n\n\t\t\tif (ep->dma) {\n\t\t\t\tstruct net2280_dma\t*td;\n\n\t\t\t\ttd = req->td;\n\t\t\t\tt = scnprintf(next, size, \"\\t    td %08x \"\n\t\t\t\t\t\" count %08x buf %08x desc %08x\\n\",\n\t\t\t\t\t(u32) req->td_dma,\n\t\t\t\t\tle32_to_cpu(td->dmacount),\n\t\t\t\t\tle32_to_cpu(td->dmaaddr),\n\t\t\t\t\tle32_to_cpu(td->dmadesc));\n\t\t\t\tif (t <= 0 || t > size)\n\t\t\t\t\tgoto done;\n\t\t\t\tsize -= t;\n\t\t\t\tnext += t;\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn PAGE_SIZE - size;\n}\nstatic DEVICE_ATTR_RO(queues);\n\n\n#else\n\n#define device_create_file(a, b)\t(0)\n#define device_remove_file(a, b)\tdo { } while (0)\n\n#endif\n\n \n\n \n\nstatic void set_fifo_mode(struct net2280 *dev, int mode)\n{\n\t \n\twritel((0xffff << PCI_BASE2_RANGE) | mode, &dev->regs->fifoctl);\n\n\t \n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[1].ep.ep_list, &dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\n\tswitch (mode) {\n\tcase 0:\n\t\tlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\n\t\tlist_add_tail(&dev->ep[4].ep.ep_list, &dev->gadget.ep_list);\n\t\tdev->ep[1].fifo_size = dev->ep[2].fifo_size = 1024;\n\t\tbreak;\n\tcase 1:\n\t\tdev->ep[1].fifo_size = dev->ep[2].fifo_size = 2048;\n\t\tbreak;\n\tcase 2:\n\t\tlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\n\t\tdev->ep[1].fifo_size = 2048;\n\t\tdev->ep[2].fifo_size = 1024;\n\t\tbreak;\n\t}\n\t \n\tlist_add_tail(&dev->ep[5].ep.ep_list, &dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[6].ep.ep_list, &dev->gadget.ep_list);\n}\n\nstatic void defect7374_disable_data_eps(struct net2280 *dev)\n{\n\t \n\tstruct net2280_ep *ep;\n\tint i;\n\tunsigned char ep_sel;\n\tu32 tmp_reg;\n\n\tfor (i = 1; i < 5; i++) {\n\t\tep = &dev->ep[i];\n\t\twritel(i, &ep->cfg->ep_cfg);\n\t}\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\twritel(0, &dev->dep[i].dep_cfg);\n\n\tfor (ep_sel = 0; ep_sel <= 21; ep_sel++) {\n\t\t \n\t\ttmp_reg = readl(&dev->plregs->pl_ep_ctrl);\n\t\twritel(((tmp_reg & ~0x1f) | ep_sel), &dev->plregs->pl_ep_ctrl);\n\n\t\tif (ep_sel < 2 || (ep_sel > 9 && ep_sel < 14) ||\n\t\t\t\t\tep_sel == 18 || ep_sel == 20)\n\t\t\tcontinue;\n\n\t\t \n\t\ttmp_reg = readl(&dev->plregs->pl_ep_cfg_4);\n\t\ttmp_reg &= ~BIT(NON_CTRL_IN_TOLERATE_BAD_DIR);\n\t\twritel(tmp_reg, &dev->plregs->pl_ep_cfg_4);\n\t\ttmp_reg = readl(&dev->plregs->pl_ep_ctrl);\n\t\ttmp_reg |= BIT(EP_INITIALIZED);\n\t\twritel(tmp_reg, &dev->plregs->pl_ep_ctrl);\n\t}\n}\n\nstatic void defect7374_enable_data_eps_zero(struct net2280 *dev)\n{\n\tu32 tmp = 0, tmp_reg;\n\tu32 scratch;\n\tint i;\n\tunsigned char ep_sel;\n\n\tscratch = get_idx_reg(dev->regs, SCRATCH);\n\n\tWARN_ON((scratch & (0xf << DEFECT7374_FSM_FIELD))\n\t\t== DEFECT7374_FSM_SS_CONTROL_READ);\n\n\tscratch &= ~(0xf << DEFECT7374_FSM_FIELD);\n\n\tep_warn(dev, \"Operate Defect 7374 workaround soft this time\");\n\tep_warn(dev, \"It will operate on cold-reboot and SS connect\");\n\n\t \n\ttmp = ((0 << ENDPOINT_NUMBER) | BIT(ENDPOINT_DIRECTION) |\n\t\t\t(2 << OUT_ENDPOINT_TYPE) | (2 << IN_ENDPOINT_TYPE) |\n\t\t\t((dev->enhanced_mode) ?\n\t\t\t BIT(OUT_ENDPOINT_ENABLE) | BIT(IN_ENDPOINT_ENABLE) :\n\t\t\t BIT(ENDPOINT_ENABLE)));\n\n\tfor (i = 1; i < 5; i++)\n\t\twritel(tmp, &dev->ep[i].cfg->ep_cfg);\n\n\t \n\ttmp = ((0 << ENDPOINT_NUMBER) | BIT(ENDPOINT_ENABLE));\n\twritel(tmp, &dev->dep[1].dep_cfg);\n\twritel(tmp, &dev->dep[3].dep_cfg);\n\twritel(tmp, &dev->dep[4].dep_cfg);\n\twritel(tmp, &dev->dep[5].dep_cfg);\n\n\t \n\tfor (ep_sel = 0; ep_sel <= 21; ep_sel++) {\n\t\t \n\t\ttmp_reg = readl(&dev->plregs->pl_ep_ctrl);\n\t\twritel(((tmp_reg & ~0x1f) | ep_sel),\n\t\t\t\t&dev->plregs->pl_ep_ctrl);\n\n\t\tif (ep_sel == 1) {\n\t\t\ttmp =\n\t\t\t\t(readl(&dev->plregs->pl_ep_ctrl) |\n\t\t\t\t BIT(CLEAR_ACK_ERROR_CODE) | 0);\n\t\t\twritel(tmp, &dev->plregs->pl_ep_ctrl);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ep_sel == 0 || (ep_sel > 9 && ep_sel < 14) ||\n\t\t\t\tep_sel == 18  || ep_sel == 20)\n\t\t\tcontinue;\n\n\t\ttmp = (readl(&dev->plregs->pl_ep_cfg_4) |\n\t\t\t\tBIT(NON_CTRL_IN_TOLERATE_BAD_DIR) | 0);\n\t\twritel(tmp, &dev->plregs->pl_ep_cfg_4);\n\n\t\ttmp = readl(&dev->plregs->pl_ep_ctrl) &\n\t\t\t~BIT(EP_INITIALIZED);\n\t\twritel(tmp, &dev->plregs->pl_ep_ctrl);\n\n\t}\n\n\t \n\tscratch |= DEFECT7374_FSM_WAITING_FOR_CONTROL_READ;\n\tset_idx_reg(dev->regs, SCRATCH, scratch);\n\n}\n\n \n\nstatic void usb_reset_228x(struct net2280 *dev)\n{\n\tu32\ttmp;\n\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\t(void) readl(&dev->usb->usbctl);\n\n\tnet2280_led_init(dev);\n\n\t \n\twritel(0, &dev->usb->stdrsp);\n\twritel(0, &dev->regs->pciirqenb0);\n\twritel(0, &dev->regs->pciirqenb1);\n\n\t \n\tfor (tmp = 0; tmp < 4; tmp++) {\n\t\tstruct net2280_ep       *ep = &dev->ep[tmp + 1];\n\t\tif (ep->dma)\n\t\t\tabort_dma(ep);\n\t}\n\n\twritel(~0, &dev->regs->irqstat0),\n\twritel(~(u32)BIT(SUSPEND_REQUEST_INTERRUPT), &dev->regs->irqstat1),\n\n\t \n\ttmp = readl(&dev->regs->devinit) |\n\t\tBIT(PCI_ENABLE) |\n\t\tBIT(FIFO_SOFT_RESET) |\n\t\tBIT(USB_SOFT_RESET) |\n\t\tBIT(M8051_RESET);\n\twritel(tmp, &dev->regs->devinit);\n\n\t \n\tset_fifo_mode(dev, (fifo_mode <= 2) ? fifo_mode : 0);\n}\n\nstatic void usb_reset_338x(struct net2280 *dev)\n{\n\tu32 tmp;\n\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\t(void)readl(&dev->usb->usbctl);\n\n\tnet2280_led_init(dev);\n\n\tif (dev->bug7734_patched) {\n\t\t \n\t\twritel(0, &dev->usb->stdrsp);\n\t\twritel(0, &dev->regs->pciirqenb0);\n\t\twritel(0, &dev->regs->pciirqenb1);\n\t}\n\n\t \n\tfor (tmp = 0; tmp < 4; tmp++) {\n\t\tstruct net2280_ep *ep = &dev->ep[tmp + 1];\n\t\tstruct net2280_dma_regs __iomem *dma;\n\n\t\tif (ep->dma) {\n\t\t\tabort_dma(ep);\n\t\t} else {\n\t\t\tdma = &dev->dma[tmp];\n\t\t\twritel(BIT(DMA_ABORT), &dma->dmastat);\n\t\t\twritel(0, &dma->dmactl);\n\t\t}\n\t}\n\n\twritel(~0, &dev->regs->irqstat0), writel(~0, &dev->regs->irqstat1);\n\n\tif (dev->bug7734_patched) {\n\t\t \n\t\ttmp = readl(&dev->regs->devinit) |\n\t\t    BIT(PCI_ENABLE) |\n\t\t    BIT(FIFO_SOFT_RESET) |\n\t\t    BIT(USB_SOFT_RESET) |\n\t\t    BIT(M8051_RESET);\n\n\t\twritel(tmp, &dev->regs->devinit);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\n\tfor (tmp = 1; tmp < dev->n_ep; tmp++)\n\t\tlist_add_tail(&dev->ep[tmp].ep.ep_list, &dev->gadget.ep_list);\n\n}\n\nstatic void usb_reset(struct net2280 *dev)\n{\n\tif (dev->quirks & PLX_LEGACY)\n\t\treturn usb_reset_228x(dev);\n\treturn usb_reset_338x(dev);\n}\n\nstatic void usb_reinit_228x(struct net2280 *dev)\n{\n\tu32\ttmp;\n\n\t \n\tfor (tmp = 0; tmp < 7; tmp++) {\n\t\tstruct net2280_ep\t*ep = &dev->ep[tmp];\n\n\t\tep->ep.name = ep_info_dft[tmp].name;\n\t\tep->ep.caps = ep_info_dft[tmp].caps;\n\t\tep->dev = dev;\n\t\tep->num = tmp;\n\n\t\tif (tmp > 0 && tmp <= 4) {\n\t\t\tep->fifo_size = 1024;\n\t\t\tep->dma = &dev->dma[tmp - 1];\n\t\t} else\n\t\t\tep->fifo_size = 64;\n\t\tep->regs = &dev->epregs[tmp];\n\t\tep->cfg = &dev->epregs[tmp];\n\t\tep_reset_228x(dev->regs, ep);\n\t}\n\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 64);\n\tusb_ep_set_maxpacket_limit(&dev->ep[5].ep, 64);\n\tusb_ep_set_maxpacket_limit(&dev->ep[6].ep, 64);\n\n\tdev->gadget.ep0 = &dev->ep[0].ep;\n\tdev->ep[0].stopped = 0;\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n\n\t \n\tfor (tmp = 0; tmp < 5; tmp++)\n\t\twritel(EP_DONTUSE, &dev->dep[tmp].dep_cfg);\n}\n\nstatic void usb_reinit_338x(struct net2280 *dev)\n{\n\tint i;\n\tu32 tmp, val;\n\tstatic const u32 ne[9] = { 0, 1, 2, 3, 4, 1, 2, 3, 4 };\n\tstatic const u32 ep_reg_addr[9] = { 0x00, 0xC0, 0x00, 0xC0, 0x00,\n\t\t\t\t\t\t0x00, 0xC0, 0x00, 0xC0 };\n\n\t \n\tfor (i = 0; i < dev->n_ep; i++) {\n\t\tstruct net2280_ep *ep = &dev->ep[i];\n\n\t\tep->ep.name = dev->enhanced_mode ? ep_info_adv[i].name :\n\t\t\t\t\t\t   ep_info_dft[i].name;\n\t\tep->ep.caps = dev->enhanced_mode ? ep_info_adv[i].caps :\n\t\t\t\t\t\t   ep_info_dft[i].caps;\n\t\tep->dev = dev;\n\t\tep->num = i;\n\n\t\tif (i > 0 && i <= 4)\n\t\t\tep->dma = &dev->dma[i - 1];\n\n\t\tif (dev->enhanced_mode) {\n\t\t\tep->cfg = &dev->epregs[ne[i]];\n\t\t\t \n\t\t\t if (i > 0 && i < 5)\n\t\t\t\twritel(ne[i], &ep->cfg->ep_cfg);\n\t\t\tep->regs = (struct net2280_ep_regs __iomem *)\n\t\t\t\t(((void __iomem *)&dev->epregs[ne[i]]) +\n\t\t\t\tep_reg_addr[i]);\n\t\t} else {\n\t\t\tep->cfg = &dev->epregs[i];\n\t\t\tep->regs = &dev->epregs[i];\n\t\t}\n\n\t\tep->fifo_size = (i != 0) ? 2048 : 512;\n\n\t\tep_reset_338x(dev->regs, ep);\n\t}\n\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 512);\n\n\tdev->gadget.ep0 = &dev->ep[0].ep;\n\tdev->ep[0].stopped = 0;\n\n\t \n\tif (dev->bug7734_patched) {\n\t\ttmp = readl(&dev->usb_ext->usbctl2) &\n\t\t    ~(BIT(U1_ENABLE) | BIT(U2_ENABLE) | BIT(LTM_ENABLE));\n\t\twritel(tmp, &dev->usb_ext->usbctl2);\n\t}\n\n\t \n\tval = readl(&dev->llregs->ll_lfps_5);\n\tval &= ~(0xf << TIMER_LFPS_6US);\n\tval |= 0x5 << TIMER_LFPS_6US;\n\twritel(val, &dev->llregs->ll_lfps_5);\n\n\tval = readl(&dev->llregs->ll_lfps_6);\n\tval &= ~(0xffff << TIMER_LFPS_80US);\n\tval |= 0x0100 << TIMER_LFPS_80US;\n\twritel(val, &dev->llregs->ll_lfps_6);\n\n\t \n\tval = readl(&dev->llregs->ll_tsn_counters_2);\n\tval &= ~(0x1f << HOT_TX_NORESET_TS2);\n\tval |= 0x10 << HOT_TX_NORESET_TS2;\n\twritel(val, &dev->llregs->ll_tsn_counters_2);\n\n\tval = readl(&dev->llregs->ll_tsn_counters_3);\n\tval &= ~(0x1f << HOT_RX_RESET_TS2);\n\tval |= 0x3 << HOT_RX_RESET_TS2;\n\twritel(val, &dev->llregs->ll_tsn_counters_3);\n\n\t \n\tval = readl(&dev->llregs->ll_lfps_timers_2);\n\twritel((val & 0xffff0000) | LFPS_TIMERS_2_WORKAROUND_VALUE,\n\t       &dev->llregs->ll_lfps_timers_2);\n\n\t \n\tval = readl(&dev->llregs->ll_tsn_chicken_bit);\n\tval |= BIT(RECOVERY_IDLE_TO_RECOVER_FMW);\n\twritel(val, &dev->llregs->ll_tsn_chicken_bit);\n\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n\n\t \n\twritel(0x0D, &dev->dep[0].dep_cfg);\n\twritel(0x0D, &dev->dep[1].dep_cfg);\n\twritel(0x0E, &dev->dep[2].dep_cfg);\n\twritel(0x0E, &dev->dep[3].dep_cfg);\n\twritel(0x0F, &dev->dep[4].dep_cfg);\n\twritel(0x0C, &dev->dep[5].dep_cfg);\n}\n\nstatic void usb_reinit(struct net2280 *dev)\n{\n\tif (dev->quirks & PLX_LEGACY)\n\t\treturn usb_reinit_228x(dev);\n\treturn usb_reinit_338x(dev);\n}\n\nstatic void ep0_start_228x(struct net2280 *dev)\n{\n\twritel(BIT(CLEAR_EP_HIDE_STATUS_PHASE) |\n\t\tBIT(CLEAR_NAK_OUT_PACKETS) |\n\t\tBIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE),\n\t\t&dev->epregs[0].ep_rsp);\n\n\t \n\twritel(BIT(SET_TEST_MODE) |\n\t\tBIT(SET_ADDRESS) |\n\t\tBIT(DEVICE_SET_CLEAR_DEVICE_REMOTE_WAKEUP) |\n\t\tBIT(GET_DEVICE_STATUS) |\n\t\tBIT(GET_INTERFACE_STATUS),\n\t\t&dev->usb->stdrsp);\n\twritel(BIT(USB_ROOT_PORT_WAKEUP_ENABLE) |\n\t\tBIT(SELF_POWERED_USB_DEVICE) |\n\t\tBIT(REMOTE_WAKEUP_SUPPORT) |\n\t\t(dev->softconnect << USB_DETECT_ENABLE) |\n\t\tBIT(SELF_POWERED_STATUS),\n\t\t&dev->usb->usbctl);\n\n\t \n\twritel(BIT(SETUP_PACKET_INTERRUPT_ENABLE) |\n\t\tBIT(ENDPOINT_0_INTERRUPT_ENABLE),\n\t\t&dev->regs->pciirqenb0);\n\twritel(BIT(PCI_INTERRUPT_ENABLE) |\n\t\tBIT(PCI_MASTER_ABORT_RECEIVED_INTERRUPT_ENABLE) |\n\t\tBIT(PCI_TARGET_ABORT_RECEIVED_INTERRUPT_ENABLE) |\n\t\tBIT(PCI_RETRY_ABORT_INTERRUPT_ENABLE) |\n\t\tBIT(VBUS_INTERRUPT_ENABLE) |\n\t\tBIT(ROOT_PORT_RESET_INTERRUPT_ENABLE) |\n\t\tBIT(SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE),\n\t\t&dev->regs->pciirqenb1);\n\n\t \n\t(void) readl(&dev->usb->usbctl);\n}\n\nstatic void ep0_start_338x(struct net2280 *dev)\n{\n\n\tif (dev->bug7734_patched)\n\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS_MODE) |\n\t\t       BIT(SET_EP_HIDE_STATUS_PHASE),\n\t\t       &dev->epregs[0].ep_rsp);\n\n\t \n\twritel(BIT(SET_ISOCHRONOUS_DELAY) |\n\t       BIT(SET_SEL) |\n\t       BIT(SET_TEST_MODE) |\n\t       BIT(SET_ADDRESS) |\n\t       BIT(GET_INTERFACE_STATUS) |\n\t       BIT(GET_DEVICE_STATUS),\n\t\t&dev->usb->stdrsp);\n\tdev->wakeup_enable = 1;\n\twritel(BIT(USB_ROOT_PORT_WAKEUP_ENABLE) |\n\t       (dev->softconnect << USB_DETECT_ENABLE) |\n\t       BIT(DEVICE_REMOTE_WAKEUP_ENABLE),\n\t       &dev->usb->usbctl);\n\n\t \n\twritel(BIT(SETUP_PACKET_INTERRUPT_ENABLE) |\n\t       BIT(ENDPOINT_0_INTERRUPT_ENABLE),\n\t       &dev->regs->pciirqenb0);\n\twritel(BIT(PCI_INTERRUPT_ENABLE) |\n\t       BIT(ROOT_PORT_RESET_INTERRUPT_ENABLE) |\n\t       BIT(SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE) |\n\t       BIT(VBUS_INTERRUPT_ENABLE),\n\t       &dev->regs->pciirqenb1);\n\n\t \n\t(void)readl(&dev->usb->usbctl);\n}\n\nstatic void ep0_start(struct net2280 *dev)\n{\n\tif (dev->quirks & PLX_LEGACY)\n\t\treturn ep0_start_228x(dev);\n\treturn ep0_start_338x(dev);\n}\n\n \nstatic int net2280_start(struct usb_gadget *_gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct net2280\t\t*dev;\n\tint\t\t\tretval;\n\tunsigned\t\ti;\n\n\t \n\tif (!driver || driver->max_speed < USB_SPEED_HIGH ||\n\t\t\t!driver->setup)\n\t\treturn -EINVAL;\n\n\tdev = container_of(_gadget, struct net2280, gadget);\n\n\tfor (i = 0; i < dev->n_ep; i++)\n\t\tdev->ep[i].irqs = 0;\n\n\t \n\tdev->driver = driver;\n\n\tretval = device_create_file(&dev->pdev->dev, &dev_attr_function);\n\tif (retval)\n\t\tgoto err_unbind;\n\tretval = device_create_file(&dev->pdev->dev, &dev_attr_queues);\n\tif (retval)\n\t\tgoto err_func;\n\n\t \n\tnet2280_led_active(dev, 1);\n\n\tif ((dev->quirks & PLX_PCIE) && !dev->bug7734_patched)\n\t\tdefect7374_enable_data_eps_zero(dev);\n\n\tep0_start(dev);\n\n\t \n\treturn 0;\n\nerr_func:\n\tdevice_remove_file(&dev->pdev->dev, &dev_attr_function);\nerr_unbind:\n\tdev->driver = NULL;\n\treturn retval;\n}\n\nstatic void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)\n{\n\tint\t\t\ti;\n\n\t \n\tif (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\n\t \n\tusb_reset(dev);\n\tfor (i = 0; i < dev->n_ep; i++)\n\t\tnuke(&dev->ep[i]);\n\n\t \n\tif (dev->async_callbacks && driver) {\n\t\tspin_unlock(&dev->lock);\n\t\tdriver->disconnect(&dev->gadget);\n\t\tspin_lock(&dev->lock);\n\t}\n\n\tusb_reinit(dev);\n}\n\nstatic int net2280_stop(struct usb_gadget *_gadget)\n{\n\tstruct net2280\t*dev;\n\tunsigned long\tflags;\n\n\tdev = container_of(_gadget, struct net2280, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tstop_activity(dev, NULL);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tnet2280_led_active(dev, 0);\n\n\tdevice_remove_file(&dev->pdev->dev, &dev_attr_function);\n\tdevice_remove_file(&dev->pdev->dev, &dev_attr_queues);\n\n\tdev->driver = NULL;\n\n\treturn 0;\n}\n\nstatic void net2280_async_callbacks(struct usb_gadget *_gadget, bool enable)\n{\n\tstruct net2280\t*dev = container_of(_gadget, struct net2280, gadget);\n\n\tspin_lock_irq(&dev->lock);\n\tdev->async_callbacks = enable;\n\tspin_unlock_irq(&dev->lock);\n}\n\n \n\n \nstatic void handle_ep_small(struct net2280_ep *ep)\n{\n\tstruct net2280_request\t*req;\n\tu32\t\t\tt;\n\t \n\tint\t\t\tmode = 1;\n\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct net2280_request, queue);\n\telse\n\t\treq = NULL;\n\n\t \n\tt = readl(&ep->regs->ep_stat);\n\tep->irqs++;\n\n\tep_vdbg(ep->dev, \"%s ack ep_stat %08x, req %p\\n\",\n\t\t\tep->ep.name, t, req ? &req->req : NULL);\n\n\tif (!ep->is_in || (ep->dev->quirks & PLX_2280))\n\t\twritel(t & ~BIT(NAK_OUT_PACKETS), &ep->regs->ep_stat);\n\telse\n\t\t \n\t\twritel(t, &ep->regs->ep_stat);\n\n\t \n\tif (unlikely(ep->num == 0)) {\n\t\tif (ep->is_in) {\n\t\t\t \n\t\t\tif (t & BIT(DATA_OUT_PING_TOKEN_INTERRUPT)) {\n\t\t\t\tif (ep->dev->protocol_stall) {\n\t\t\t\t\tep->stopped = 1;\n\t\t\t\t\tset_halt(ep);\n\t\t\t\t}\n\t\t\t\tif (!req)\n\t\t\t\t\tallow_status(ep);\n\t\t\t\tmode = 2;\n\t\t\t \n\t\t\t} else if (t & BIT(DATA_IN_TOKEN_INTERRUPT)) {\n\t\t\t\tif (ep->dev->protocol_stall) {\n\t\t\t\t\tep->stopped = 1;\n\t\t\t\t\tset_halt(ep);\n\t\t\t\t\tmode = 2;\n\t\t\t\t} else if (ep->responded &&\n\t\t\t\t\t\t!req && !ep->stopped)\n\t\t\t\t\twrite_fifo(ep, NULL);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (t & BIT(DATA_IN_TOKEN_INTERRUPT)) {\n\t\t\t\tif (ep->dev->protocol_stall) {\n\t\t\t\t\tep->stopped = 1;\n\t\t\t\t\tset_halt(ep);\n\t\t\t\t}\n\t\t\t\tmode = 2;\n\t\t\t \n\t\t\t} else if (((t & BIT(DATA_OUT_PING_TOKEN_INTERRUPT)) &&\n\t\t\t\t\treq &&\n\t\t\t\t\treq->req.actual == req->req.length) ||\n\t\t\t\t\t(ep->responded && !req)) {\n\t\t\t\tep->dev->protocol_stall = 1;\n\t\t\t\tset_halt(ep);\n\t\t\t\tep->stopped = 1;\n\t\t\t\tif (req)\n\t\t\t\t\tdone(ep, req, -EOVERFLOW);\n\t\t\t\treq = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(!req))\n\t\treturn;\n\n\t \n\tif (likely(ep->dma)) {\n\t\tif (t & BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT)) {\n\t\t\tstruct net2280_request *stuck_req = NULL;\n\t\t\tint\tstopped = ep->stopped;\n\t\t\tint\tnum_completed;\n\t\t\tint\tstuck = 0;\n\t\t\tu32\tcount;\n\n\t\t\t \n\t\t\tep->stopped = 1;\n\t\t\tfor (count = 0; ; t = readl(&ep->regs->ep_stat)) {\n\n\t\t\t\t \n\t\t\t\tnum_completed = scan_dma_completions(ep);\n\t\t\t\tif (unlikely(list_empty(&ep->queue) ||\n\t\t\t\t\t\tep->out_overflow)) {\n\t\t\t\t\treq = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2280_request, queue);\n\n\t\t\t\t \n\t\t\t\tif (likely(t & BIT(FIFO_EMPTY))) {\n\t\t\t\t\tcount = readl(&ep->dma->dmacount);\n\t\t\t\t\tcount &= DMA_BYTE_COUNT_MASK;\n\t\t\t\t\tif (readl(&ep->dma->dmadesc)\n\t\t\t\t\t\t\t!= req->td_dma)\n\t\t\t\t\t\treq = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (num_completed == 0) {\n\t\t\t\t\tif (stuck_req == req &&\n\t\t\t\t\t    readl(&ep->dma->dmadesc) !=\n\t\t\t\t\t\t  req->td_dma && stuck++ > 5) {\n\t\t\t\t\t\tcount = readl(\n\t\t\t\t\t\t\t&ep->dma->dmacount);\n\t\t\t\t\t\tcount &= DMA_BYTE_COUNT_MASK;\n\t\t\t\t\t\treq = NULL;\n\t\t\t\t\t\tep_dbg(ep->dev, \"%s escape stuck %d, count %u\\n\",\n\t\t\t\t\t\t\tep->ep.name, stuck,\n\t\t\t\t\t\t\tcount);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (stuck_req != req) {\n\t\t\t\t\t\tstuck_req = req;\n\t\t\t\t\t\tstuck = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tstuck_req = NULL;\n\t\t\t\t\tstuck = 0;\n\t\t\t\t}\n\n\t\t\t\tudelay(1);\n\t\t\t}\n\n\t\t\t \n\t\t\twritel(BIT(DMA_ABORT), &ep->dma->dmastat);\n\t\t\tspin_stop_dma(ep->dma);\n\n\t\t\tif (likely(req)) {\n\t\t\t\treq->td->dmacount = 0;\n\t\t\t\tt = readl(&ep->regs->ep_avail);\n\t\t\t\tdma_done(ep, req, count,\n\t\t\t\t\t(ep->out_overflow || t)\n\t\t\t\t\t\t? -EOVERFLOW : 0);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (unlikely(ep->out_overflow ||\n\t\t\t\t\t(ep->dev->chiprev == 0x0100 &&\n\t\t\t\t\tep->dev->gadget.speed\n\t\t\t\t\t== USB_SPEED_FULL))) {\n\t\t\t\tout_flush(ep);\n\t\t\t\tep->out_overflow = 0;\n\t\t\t}\n\n\t\t\t \n\t\t\tep->stopped = stopped;\n\t\t\tif (!list_empty(&ep->queue))\n\t\t\t\trestart_dma(ep);\n\t\t} else\n\t\t\tep_dbg(ep->dev, \"%s dma ep_stat %08x ??\\n\",\n\t\t\t\t\tep->ep.name, t);\n\t\treturn;\n\n\t \n\t} else if (t & BIT(DATA_PACKET_RECEIVED_INTERRUPT)) {\n\t\tif (read_fifo(ep, req) && ep->num != 0)\n\t\t\tmode = 2;\n\n\t \n\t} else if (t & BIT(DATA_PACKET_TRANSMITTED_INTERRUPT)) {\n\t\tunsigned\tlen;\n\n\t\tlen = req->req.length - req->req.actual;\n\t\tif (len > ep->ep.maxpacket)\n\t\t\tlen = ep->ep.maxpacket;\n\t\treq->req.actual += len;\n\n\t\t \n\t\t \n\t\tif ((req->req.actual == req->req.length) &&\n\t\t\t(!req->req.zero || len != ep->ep.maxpacket) && ep->num)\n\t\t\t\tmode = 2;\n\n\t \n\t} else if (mode == 1)\n\t\treturn;\n\n\t \n\tif (mode == 2) {\n\t\t \n\t\tdone(ep, req, 0);\n\n\t\t \n\t\tif (ep->num == 0) {\n\t\t\t \n\t\t\tif (!ep->stopped)\n\t\t\t\tallow_status(ep);\n\t\t\treq = NULL;\n\t\t} else {\n\t\t\tif (!list_empty(&ep->queue) && !ep->stopped)\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2280_request, queue);\n\t\t\telse\n\t\t\t\treq = NULL;\n\t\t\tif (req && !ep->is_in)\n\t\t\t\tstop_out_naking(ep);\n\t\t}\n\t}\n\n\t \n\tif (req && !ep->stopped) {\n\n\t\t \n\t\tif (t & BIT(DATA_PACKET_TRANSMITTED_INTERRUPT))\n\t\t\twrite_fifo(ep, &req->req);\n\t}\n}\n\nstatic struct net2280_ep *get_ep_by_addr(struct net2280 *dev, u16 wIndex)\n{\n\tstruct net2280_ep\t*ep;\n\n\tif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\n\t\treturn &dev->ep[0];\n\tlist_for_each_entry(ep, &dev->gadget.ep_list, ep.ep_list) {\n\t\tu8\tbEndpointAddress;\n\n\t\tif (!ep->desc)\n\t\t\tcontinue;\n\t\tbEndpointAddress = ep->desc->bEndpointAddress;\n\t\tif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\n\t\t\tcontinue;\n\t\tif ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\nstatic void defect7374_workaround(struct net2280 *dev, struct usb_ctrlrequest r)\n{\n\tu32 scratch, fsmvalue;\n\tu32 ack_wait_timeout, state;\n\n\t \n\tscratch = get_idx_reg(dev->regs, SCRATCH);\n\tfsmvalue = scratch & (0xf << DEFECT7374_FSM_FIELD);\n\tscratch &= ~(0xf << DEFECT7374_FSM_FIELD);\n\n\tif (!((fsmvalue == DEFECT7374_FSM_WAITING_FOR_CONTROL_READ) &&\n\t\t\t\t(r.bRequestType & USB_DIR_IN)))\n\t\treturn;\n\n\t \n\tif (!(readl(&dev->usb->usbstat) & BIT(SUPER_SPEED_MODE))) {\n\t\t \n\t\tscratch |= DEFECT7374_FSM_NON_SS_CONTROL_READ;\n\t\tdev->bug7734_patched = 1;\n\t\tgoto restore_data_eps;\n\t}\n\n\t \n\tfor (ack_wait_timeout = 0;\n\t\t\tack_wait_timeout < DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS;\n\t\t\tack_wait_timeout++) {\n\n\t\tstate =\treadl(&dev->plregs->pl_ep_status_1)\n\t\t\t& (0xff << STATE);\n\t\tif ((state >= (ACK_GOOD_NORMAL << STATE)) &&\n\t\t\t(state <= (ACK_GOOD_MORE_ACKS_TO_COME << STATE))) {\n\t\t\tscratch |= DEFECT7374_FSM_SS_CONTROL_READ;\n\t\t\tdev->bug7734_patched = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tudelay(DEFECT_7374_PROCESSOR_WAIT_TIME);\n\t}\n\n\n\tif (ack_wait_timeout >= DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS) {\n\t\tep_err(dev, \"FAIL: Defect 7374 workaround waited but failed \"\n\t\t\"to detect SS host's data phase ACK.\");\n\t\tep_err(dev, \"PL_EP_STATUS_1(23:16):.Expected from 0x11 to 0x16\"\n\t\t\"got 0x%2.2x.\\n\", state >> STATE);\n\t} else {\n\t\tep_warn(dev, \"INFO: Defect 7374 workaround waited about\\n\"\n\t\t\"%duSec for Control Read Data Phase ACK\\n\",\n\t\t\tDEFECT_7374_PROCESSOR_WAIT_TIME * ack_wait_timeout);\n\t}\n\nrestore_data_eps:\n\t \n\tdefect7374_disable_data_eps(dev);\n\n\tset_idx_reg(dev->regs, SCRATCH, scratch);\n\n\treturn;\n}\n\nstatic void ep_clear_seqnum(struct net2280_ep *ep)\n{\n\tstruct net2280 *dev = ep->dev;\n\tu32 val;\n\tstatic const u32 ep_pl[9] = { 0, 3, 4, 7, 8, 2, 5, 6, 9 };\n\n\tval = readl(&dev->plregs->pl_ep_ctrl) & ~0x1f;\n\tval |= ep_pl[ep->num];\n\twritel(val, &dev->plregs->pl_ep_ctrl);\n\tval |= BIT(SEQUENCE_NUMBER_RESET);\n\twritel(val, &dev->plregs->pl_ep_ctrl);\n\n\treturn;\n}\n\nstatic void handle_stat0_irqs_superspeed(struct net2280 *dev,\n\t\tstruct net2280_ep *ep, struct usb_ctrlrequest r)\n{\n\tstruct net2280_ep *e;\n\tu16 status;\n\tint tmp = 0;\n\n#define\tw_value\t\tle16_to_cpu(r.wValue)\n#define\tw_index\t\tle16_to_cpu(r.wIndex)\n#define\tw_length\tle16_to_cpu(r.wLength)\n\n\tswitch (r.bRequest) {\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tdev->addressed_state = !w_value;\n\t\tgoto usb3_delegate;\n\n\tcase USB_REQ_GET_STATUS:\n\t\tswitch (r.bRequestType) {\n\t\tcase (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\n\t\t\tstatus = dev->wakeup_enable ? 0x02 : 0x00;\n\t\t\tif (dev->gadget.is_selfpowered)\n\t\t\t\tstatus |= BIT(0);\n\t\t\tstatus |= (dev->u1_enable << 2 | dev->u2_enable << 3 |\n\t\t\t\t\t\t\tdev->ltm_enable << 4);\n\t\t\twritel(0, &dev->epregs[0].ep_irqenb);\n\t\t\tset_fifo_bytecount(ep, sizeof(status));\n\t\t\twritel((__force u32) status, &dev->epregs[0].ep_data);\n\t\t\tallow_status_338x(ep);\n\t\t\tbreak;\n\n\t\tcase (USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\n\t\t\te = get_ep_by_addr(dev, w_index);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall3;\n\t\t\tstatus = readl(&e->regs->ep_rsp) &\n\t\t\t\t\t\tBIT(CLEAR_ENDPOINT_HALT);\n\t\t\twritel(0, &dev->epregs[0].ep_irqenb);\n\t\t\tset_fifo_bytecount(ep, sizeof(status));\n\t\t\twritel((__force u32) status, &dev->epregs[0].ep_data);\n\t\t\tallow_status_338x(ep);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto usb3_delegate;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tswitch (r.bRequestType) {\n\t\tcase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\n\t\t\tif (!dev->addressed_state) {\n\t\t\t\tswitch (w_value) {\n\t\t\t\tcase USB_DEVICE_U1_ENABLE:\n\t\t\t\t\tdev->u1_enable = 0;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) &\n\t\t\t\t\t\t~BIT(U1_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\n\t\t\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\t\t\tdev->u2_enable = 0;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) &\n\t\t\t\t\t\t~BIT(U2_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\n\t\t\t\tcase USB_DEVICE_LTM_ENABLE:\n\t\t\t\t\tdev->ltm_enable = 0;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) &\n\t\t\t\t\t\t~BIT(LTM_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (w_value == USB_DEVICE_REMOTE_WAKEUP) {\n\t\t\t\tdev->wakeup_enable = 0;\n\t\t\t\twritel(readl(&dev->usb->usbctl) &\n\t\t\t\t\t~BIT(DEVICE_REMOTE_WAKEUP_ENABLE),\n\t\t\t\t\t&dev->usb->usbctl);\n\t\t\t\tallow_status_338x(ep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto usb3_delegate;\n\n\t\tcase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\n\t\t\te = get_ep_by_addr(dev,\tw_index);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall3;\n\t\t\tif (w_value != USB_ENDPOINT_HALT)\n\t\t\t\tgoto do_stall3;\n\t\t\tep_vdbg(dev, \"%s clear halt\\n\", e->ep.name);\n\t\t\t \n\t\t\tep_clear_seqnum(e);\n\t\t\tclear_halt(e);\n\t\t\tif (!list_empty(&e->queue) && e->td_dma)\n\t\t\t\trestart_dma(e);\n\t\t\tallow_status(ep);\n\t\t\tep->stopped = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto usb3_delegate;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tswitch (r.bRequestType) {\n\t\tcase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE):\n\t\t\tif (!dev->addressed_state) {\n\t\t\t\tswitch (w_value) {\n\t\t\t\tcase USB_DEVICE_U1_ENABLE:\n\t\t\t\t\tdev->u1_enable = 1;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) |\n\t\t\t\t\t\tBIT(U1_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\n\t\t\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\t\t\tdev->u2_enable = 1;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) |\n\t\t\t\t\t\tBIT(U2_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\n\t\t\t\tcase USB_DEVICE_LTM_ENABLE:\n\t\t\t\t\tdev->ltm_enable = 1;\n\t\t\t\t\twritel(readl(&dev->usb_ext->usbctl2) |\n\t\t\t\t\t\tBIT(LTM_ENABLE),\n\t\t\t\t\t\t&dev->usb_ext->usbctl2);\n\t\t\t\t\tallow_status_338x(ep);\n\t\t\t\t\tgoto next_endpoints3;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (w_value == USB_DEVICE_REMOTE_WAKEUP) {\n\t\t\t\tdev->wakeup_enable = 1;\n\t\t\t\twritel(readl(&dev->usb->usbctl) |\n\t\t\t\t\tBIT(DEVICE_REMOTE_WAKEUP_ENABLE),\n\t\t\t\t\t&dev->usb->usbctl);\n\t\t\t\tallow_status_338x(ep);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgoto usb3_delegate;\n\n\t\tcase (USB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\n\t\t\te = get_ep_by_addr(dev,\tw_index);\n\t\t\tif (!e || (w_value != USB_ENDPOINT_HALT))\n\t\t\t\tgoto do_stall3;\n\t\t\tep->stopped = 1;\n\t\t\tif (ep->num == 0)\n\t\t\t\tep->dev->protocol_stall = 1;\n\t\t\telse {\n\t\t\t\tif (ep->dma)\n\t\t\t\t\tabort_dma(ep);\n\t\t\t\tset_halt(ep);\n\t\t\t}\n\t\t\tallow_status_338x(ep);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto usb3_delegate;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\nusb3_delegate:\n\t\tep_vdbg(dev, \"setup %02x.%02x v%04x i%04x l%04x ep_cfg %08x\\n\",\n\t\t\t\tr.bRequestType, r.bRequest,\n\t\t\t\tw_value, w_index, w_length,\n\t\t\t\treadl(&ep->cfg->ep_cfg));\n\n\t\tep->responded = 0;\n\t\tif (dev->async_callbacks) {\n\t\t\tspin_unlock(&dev->lock);\n\t\t\ttmp = dev->driver->setup(&dev->gadget, &r);\n\t\t\tspin_lock(&dev->lock);\n\t\t}\n\t}\ndo_stall3:\n\tif (tmp < 0) {\n\t\tep_vdbg(dev, \"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\tr.bRequestType, r.bRequest, tmp);\n\t\tdev->protocol_stall = 1;\n\t\t \n\t\tset_halt(ep);\n\t}\n\nnext_endpoints3:\n\n#undef\tw_value\n#undef\tw_index\n#undef\tw_length\n\n\treturn;\n}\n\nstatic void usb338x_handle_ep_intr(struct net2280 *dev, u32 stat0)\n{\n\tu32 index;\n\tu32 bit;\n\n\tfor (index = 0; index < ARRAY_SIZE(ep_bit); index++) {\n\t\tbit = BIT(ep_bit[index]);\n\n\t\tif (!stat0)\n\t\t\tbreak;\n\n\t\tif (!(stat0 & bit))\n\t\t\tcontinue;\n\n\t\tstat0 &= ~bit;\n\n\t\thandle_ep_small(&dev->ep[index]);\n\t}\n}\n\nstatic void handle_stat0_irqs(struct net2280 *dev, u32 stat)\n{\n\tstruct net2280_ep\t*ep;\n\tu32\t\t\tnum, scratch;\n\n\t \n\tstat &= ~BIT(INTA_ASSERTED);\n\tif (!stat)\n\t\treturn;\n\t \n\n\t \n\tif (unlikely(stat & BIT(SETUP_PACKET_INTERRUPT))) {\n\t\tunion {\n\t\t\tu32\t\t\traw[2];\n\t\t\tstruct usb_ctrlrequest\tr;\n\t\t} u;\n\t\tint\t\t\t\ttmp;\n\t\tstruct net2280_request\t\t*req;\n\n\t\tif (dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\t\tu32 val = readl(&dev->usb->usbstat);\n\t\t\tif (val & BIT(SUPER_SPEED)) {\n\t\t\t\tdev->gadget.speed = USB_SPEED_SUPER;\n\t\t\t\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\n\t\t\t\t\t\tEP0_SS_MAX_PACKET_SIZE);\n\t\t\t} else if (val & BIT(HIGH_SPEED)) {\n\t\t\t\tdev->gadget.speed = USB_SPEED_HIGH;\n\t\t\t\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\n\t\t\t\t\t\tEP0_HS_MAX_PACKET_SIZE);\n\t\t\t} else {\n\t\t\t\tdev->gadget.speed = USB_SPEED_FULL;\n\t\t\t\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep,\n\t\t\t\t\t\tEP0_HS_MAX_PACKET_SIZE);\n\t\t\t}\n\t\t\tnet2280_led_speed(dev, dev->gadget.speed);\n\t\t\tep_dbg(dev, \"%s\\n\",\n\t\t\t\t\tusb_speed_string(dev->gadget.speed));\n\t\t}\n\n\t\tep = &dev->ep[0];\n\t\tep->irqs++;\n\n\t\t \n\t\tstat &= ~BIT(ENDPOINT_0_INTERRUPT);\n\t\twhile (!list_empty(&ep->queue)) {\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2280_request, queue);\n\t\t\tdone(ep, req, (req->req.actual == req->req.length)\n\t\t\t\t\t\t? 0 : -EPROTO);\n\t\t}\n\t\tep->stopped = 0;\n\t\tdev->protocol_stall = 0;\n\t\tif (!(dev->quirks & PLX_PCIE)) {\n\t\t\tif (ep->dev->quirks & PLX_2280)\n\t\t\t\ttmp = BIT(FIFO_OVERFLOW) |\n\t\t\t\t    BIT(FIFO_UNDERFLOW);\n\t\t\telse\n\t\t\t\ttmp = 0;\n\n\t\t\twritel(tmp | BIT(TIMEOUT) |\n\t\t\t\t   BIT(USB_STALL_SENT) |\n\t\t\t\t   BIT(USB_IN_NAK_SENT) |\n\t\t\t\t   BIT(USB_IN_ACK_RCVD) |\n\t\t\t\t   BIT(USB_OUT_PING_NAK_SENT) |\n\t\t\t\t   BIT(USB_OUT_ACK_SENT) |\n\t\t\t\t   BIT(SHORT_PACKET_OUT_DONE_INTERRUPT) |\n\t\t\t\t   BIT(SHORT_PACKET_TRANSFERRED_INTERRUPT) |\n\t\t\t\t   BIT(DATA_PACKET_RECEIVED_INTERRUPT) |\n\t\t\t\t   BIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\n\t\t\t\t   BIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t\t\t\t   BIT(DATA_IN_TOKEN_INTERRUPT),\n\t\t\t\t   &ep->regs->ep_stat);\n\t\t}\n\t\tu.raw[0] = readl(&dev->usb->setup0123);\n\t\tu.raw[1] = readl(&dev->usb->setup4567);\n\n\t\tcpu_to_le32s(&u.raw[0]);\n\t\tcpu_to_le32s(&u.raw[1]);\n\n\t\tif ((dev->quirks & PLX_PCIE) && !dev->bug7734_patched)\n\t\t\tdefect7374_workaround(dev, u.r);\n\n\t\ttmp = 0;\n\n#define\tw_value\t\tle16_to_cpu(u.r.wValue)\n#define\tw_index\t\tle16_to_cpu(u.r.wIndex)\n#define\tw_length\tle16_to_cpu(u.r.wLength)\n\n\t\t \n\t\twritel(BIT(SETUP_PACKET_INTERRUPT), &dev->regs->irqstat0);\n\t\tstat ^= BIT(SETUP_PACKET_INTERRUPT);\n\n\t\t \n\t\tep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;\n\t\tif (ep->is_in) {\n\t\t\tscratch = BIT(DATA_PACKET_TRANSMITTED_INTERRUPT) |\n\t\t\t\tBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t\t\t\tBIT(DATA_IN_TOKEN_INTERRUPT);\n\t\t\tstop_out_naking(ep);\n\t\t} else\n\t\t\tscratch = BIT(DATA_PACKET_RECEIVED_INTERRUPT) |\n\t\t\t\tBIT(DATA_OUT_PING_TOKEN_INTERRUPT) |\n\t\t\t\tBIT(DATA_IN_TOKEN_INTERRUPT);\n\t\twritel(scratch, &dev->epregs[0].ep_irqenb);\n\n\t\t \n\t\tep->responded = 1;\n\n\t\tif (dev->gadget.speed == USB_SPEED_SUPER) {\n\t\t\thandle_stat0_irqs_superspeed(dev, ep, u.r);\n\t\t\tgoto next_endpoints;\n\t\t}\n\n\t\tswitch (u.r.bRequest) {\n\t\tcase USB_REQ_GET_STATUS: {\n\t\t\tstruct net2280_ep\t*e;\n\t\t\t__le32\t\t\tstatus;\n\n\t\t\t \n\t\t\tif (u.r.bRequestType != (USB_DIR_IN|USB_RECIP_ENDPOINT))\n\t\t\t\tgoto delegate;\n\t\t\te = get_ep_by_addr(dev, w_index);\n\t\t\tif (!e || w_length > 2)\n\t\t\t\tgoto do_stall;\n\n\t\t\tif (readl(&e->regs->ep_rsp) & BIT(SET_ENDPOINT_HALT))\n\t\t\t\tstatus = cpu_to_le32(1);\n\t\t\telse\n\t\t\t\tstatus = cpu_to_le32(0);\n\n\t\t\t \n\t\t\twritel(0, &dev->epregs[0].ep_irqenb);\n\t\t\tset_fifo_bytecount(ep, w_length);\n\t\t\twritel((__force u32)status, &dev->epregs[0].ep_data);\n\t\t\tallow_status(ep);\n\t\t\tep_vdbg(dev, \"%s stat %02x\\n\", ep->ep.name, status);\n\t\t\tgoto next_endpoints;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE: {\n\t\t\tstruct net2280_ep\t*e;\n\n\t\t\t \n\t\t\tif (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (w_value != USB_ENDPOINT_HALT || w_length != 0)\n\t\t\t\tgoto do_stall;\n\t\t\te = get_ep_by_addr(dev, w_index);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall;\n\t\t\tif (e->wedged) {\n\t\t\t\tep_vdbg(dev, \"%s wedged, halt not cleared\\n\",\n\t\t\t\t\t\tep->ep.name);\n\t\t\t} else {\n\t\t\t\tep_vdbg(dev, \"%s clear halt\\n\", e->ep.name);\n\t\t\t\tclear_halt(e);\n\t\t\t\tif ((ep->dev->quirks & PLX_PCIE) &&\n\t\t\t\t\t!list_empty(&e->queue) && e->td_dma)\n\t\t\t\t\t\trestart_dma(e);\n\t\t\t}\n\t\t\tallow_status(ep);\n\t\t\tgoto next_endpoints;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE: {\n\t\t\tstruct net2280_ep\t*e;\n\n\t\t\t \n\t\t\tif (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (w_value != USB_ENDPOINT_HALT || w_length != 0)\n\t\t\t\tgoto do_stall;\n\t\t\te = get_ep_by_addr(dev, w_index);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall;\n\t\t\tif (e->ep.name == ep0name)\n\t\t\t\tgoto do_stall;\n\t\t\tset_halt(e);\n\t\t\tif ((dev->quirks & PLX_PCIE) && e->dma)\n\t\t\t\tabort_dma(e);\n\t\t\tallow_status(ep);\n\t\t\tep_vdbg(dev, \"%s set halt\\n\", ep->ep.name);\n\t\t\tgoto next_endpoints;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\ndelegate:\n\t\t\tep_vdbg(dev, \"setup %02x.%02x v%04x i%04x l%04x \"\n\t\t\t\t\"ep_cfg %08x\\n\",\n\t\t\t\tu.r.bRequestType, u.r.bRequest,\n\t\t\t\tw_value, w_index, w_length,\n\t\t\t\treadl(&ep->cfg->ep_cfg));\n\t\t\tep->responded = 0;\n\t\t\tif (dev->async_callbacks) {\n\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\ttmp = dev->driver->setup(&dev->gadget, &u.r);\n\t\t\t\tspin_lock(&dev->lock);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (tmp < 0) {\ndo_stall:\n\t\t\tep_vdbg(dev, \"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\t\tu.r.bRequestType, u.r.bRequest, tmp);\n\t\t\tdev->protocol_stall = 1;\n\t\t}\n\n\t\t \n\t}\n\n#undef\tw_value\n#undef\tw_index\n#undef\tw_length\n\nnext_endpoints:\n\tif ((dev->quirks & PLX_PCIE) && dev->enhanced_mode) {\n\t\tu32 mask = (BIT(ENDPOINT_0_INTERRUPT) |\n\t\t\tUSB3380_IRQSTAT0_EP_INTR_MASK_IN |\n\t\t\tUSB3380_IRQSTAT0_EP_INTR_MASK_OUT);\n\n\t\tif (stat & mask) {\n\t\t\tusb338x_handle_ep_intr(dev, stat & mask);\n\t\t\tstat &= ~mask;\n\t\t}\n\t} else {\n\t\t \n\t\tscratch = stat & 0x7f;\n\t\tstat &= ~0x7f;\n\t\tfor (num = 0; scratch; num++) {\n\t\t\tu32\t\tt;\n\n\t\t\t \n\t\t\tt = BIT(num);\n\t\t\tif ((scratch & t) == 0)\n\t\t\t\tcontinue;\n\t\t\tscratch ^= t;\n\n\t\t\tep = &dev->ep[num];\n\t\t\thandle_ep_small(ep);\n\t\t}\n\t}\n\n\tif (stat)\n\t\tep_dbg(dev, \"unhandled irqstat0 %08x\\n\", stat);\n}\n\n#define DMA_INTERRUPTS (BIT(DMA_D_INTERRUPT) | \\\n\t\tBIT(DMA_C_INTERRUPT) | \\\n\t\tBIT(DMA_B_INTERRUPT) | \\\n\t\tBIT(DMA_A_INTERRUPT))\n#define\tPCI_ERROR_INTERRUPTS ( \\\n\t\tBIT(PCI_MASTER_ABORT_RECEIVED_INTERRUPT) | \\\n\t\tBIT(PCI_TARGET_ABORT_RECEIVED_INTERRUPT) | \\\n\t\tBIT(PCI_RETRY_ABORT_INTERRUPT))\n\nstatic void handle_stat1_irqs(struct net2280 *dev, u32 stat)\n__releases(dev->lock)\n__acquires(dev->lock)\n{\n\tstruct net2280_ep\t*ep;\n\tu32\t\t\ttmp, num, mask, scratch;\n\n\t \n\ttmp = BIT(VBUS_INTERRUPT) | BIT(ROOT_PORT_RESET_INTERRUPT);\n\tmask = BIT(SUPER_SPEED) | BIT(HIGH_SPEED) | BIT(FULL_SPEED);\n\n\t \n\tif (stat & tmp) {\n\t\tbool\treset = false;\n\t\tbool\tdisconnect = false;\n\n\t\t \n\t\twritel(tmp, &dev->regs->irqstat1);\n\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN) {\n\t\t\tif ((stat & BIT(VBUS_INTERRUPT)) &&\n\t\t\t\t\t(readl(&dev->usb->usbctl) &\n\t\t\t\t\t\tBIT(VBUS_PIN)) == 0) {\n\t\t\t\tdisconnect = true;\n\t\t\t\tep_dbg(dev, \"disconnect %s\\n\",\n\t\t\t\t\t\tdev->driver->driver.name);\n\t\t\t} else if ((stat & BIT(ROOT_PORT_RESET_INTERRUPT)) &&\n\t\t\t\t\t(readl(&dev->usb->usbstat) & mask)\n\t\t\t\t\t\t== 0) {\n\t\t\t\treset = true;\n\t\t\t\tep_dbg(dev, \"reset %s\\n\",\n\t\t\t\t\t\tdev->driver->driver.name);\n\t\t\t}\n\n\t\t\tif (disconnect || reset) {\n\t\t\t\tstop_activity(dev, dev->driver);\n\t\t\t\tep0_start(dev);\n\t\t\t\tif (dev->async_callbacks) {\n\t\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\t\tif (reset)\n\t\t\t\t\t\tusb_gadget_udc_reset(&dev->gadget, dev->driver);\n\t\t\t\t\telse\n\t\t\t\t\t\t(dev->driver->disconnect)(&dev->gadget);\n\t\t\t\t\tspin_lock(&dev->lock);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstat &= ~tmp;\n\n\t\t \n\t\tif (!stat)\n\t\t\treturn;\n\t}\n\n\t \n\ttmp = BIT(SUSPEND_REQUEST_CHANGE_INTERRUPT);\n\tif (stat & tmp) {\n\t\twritel(tmp, &dev->regs->irqstat1);\n\t\tspin_unlock(&dev->lock);\n\t\tif (stat & BIT(SUSPEND_REQUEST_INTERRUPT)) {\n\t\t\tif (dev->async_callbacks && dev->driver->suspend)\n\t\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\tif (!enable_suspend)\n\t\t\t\tstat &= ~BIT(SUSPEND_REQUEST_INTERRUPT);\n\t\t} else {\n\t\t\tif (dev->async_callbacks && dev->driver->resume)\n\t\t\t\tdev->driver->resume(&dev->gadget);\n\t\t\t \n\t\t}\n\t\tspin_lock(&dev->lock);\n\t\tstat &= ~tmp;\n\t}\n\n\t \n\tif (stat)\n\t\twritel(stat, &dev->regs->irqstat1);\n\n\t \n\tif (dev->quirks & PLX_2280)\n\t\tstat &= ~(BIT(CONTROL_STATUS_INTERRUPT) |\n\t\t\t  BIT(SUSPEND_REQUEST_INTERRUPT) |\n\t\t\t  BIT(RESUME_INTERRUPT) |\n\t\t\t  BIT(SOF_INTERRUPT));\n\telse\n\t\tstat &= ~(BIT(CONTROL_STATUS_INTERRUPT) |\n\t\t\t  BIT(RESUME_INTERRUPT) |\n\t\t\t  BIT(SOF_DOWN_INTERRUPT) |\n\t\t\t  BIT(SOF_INTERRUPT));\n\n\tif (!stat)\n\t\treturn;\n\t \n\n\t \n\tscratch = stat & DMA_INTERRUPTS;\n\tstat &= ~DMA_INTERRUPTS;\n\tscratch >>= 9;\n\tfor (num = 0; scratch; num++) {\n\t\tstruct net2280_dma_regs\t__iomem *dma;\n\n\t\ttmp = BIT(num);\n\t\tif ((tmp & scratch) == 0)\n\t\t\tcontinue;\n\t\tscratch ^= tmp;\n\n\t\tep = &dev->ep[num + 1];\n\t\tdma = ep->dma;\n\n\t\tif (!dma)\n\t\t\tcontinue;\n\n\t\t \n\t\ttmp = readl(&dma->dmastat);\n\t\twritel(tmp, &dma->dmastat);\n\n\t\t \n\t\tif (dev->quirks & PLX_PCIE) {\n\t\t\tu32 r_dmacount = readl(&dma->dmacount);\n\t\t\tif (!ep->is_in &&  (r_dmacount & 0x00FFFFFF) &&\n\t\t\t    (tmp & BIT(DMA_TRANSACTION_DONE_INTERRUPT)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(tmp & BIT(DMA_TRANSACTION_DONE_INTERRUPT))) {\n\t\t\tep_dbg(ep->dev, \"%s no xact done? %08x\\n\",\n\t\t\t\tep->ep.name, tmp);\n\t\t\tcontinue;\n\t\t}\n\t\tstop_dma(ep->dma);\n\n\t\t \n\t\tscan_dma_completions(ep);\n\n\t\t \n\t\tif (!list_empty(&ep->queue)) {\n\t\t\ttmp = readl(&dma->dmactl);\n\t\t\trestart_dma(ep);\n\t\t}\n\t\tep->irqs++;\n\t}\n\n\t \n\tif (stat & PCI_ERROR_INTERRUPTS) {\n\t\tep_err(dev, \"pci dma error; stat %08x\\n\", stat);\n\t\tstat &= ~PCI_ERROR_INTERRUPTS;\n\t\t \n\t\tstop_activity(dev, dev->driver);\n\t\tep0_start(dev);\n\t\tstat = 0;\n\t}\n\n\tif (stat)\n\t\tep_dbg(dev, \"unhandled irqstat1 %08x\\n\", stat);\n}\n\nstatic irqreturn_t net2280_irq(int irq, void *_dev)\n{\n\tstruct net2280\t\t*dev = _dev;\n\n\t \n\tif ((dev->quirks & PLX_LEGACY) &&\n\t\t(!(readl(&dev->regs->irqstat0) & BIT(INTA_ASSERTED))))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&dev->lock);\n\n\t \n\thandle_stat1_irqs(dev, readl(&dev->regs->irqstat1));\n\n\t \n\thandle_stat0_irqs(dev, readl(&dev->regs->irqstat0));\n\n\tif (dev->quirks & PLX_PCIE) {\n\t\t \n\t\tu32 pciirqenb1 = readl(&dev->regs->pciirqenb1);\n\t\twritel(pciirqenb1 & 0x7FFFFFFF, &dev->regs->pciirqenb1);\n\t\twritel(pciirqenb1, &dev->regs->pciirqenb1);\n\t}\n\n\tspin_unlock(&dev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void gadget_release(struct device *_dev)\n{\n\tstruct net2280\t*dev = container_of(_dev, struct net2280, gadget.dev);\n\n\tkfree(dev);\n}\n\n \n\nstatic void net2280_remove(struct pci_dev *pdev)\n{\n\tstruct net2280\t\t*dev = pci_get_drvdata(pdev);\n\n\tif (dev->added)\n\t\tusb_del_gadget(&dev->gadget);\n\n\tBUG_ON(dev->driver);\n\n\t \n\tif (dev->requests) {\n\t\tint\t\ti;\n\t\tfor (i = 1; i < 5; i++) {\n\t\t\tif (!dev->ep[i].dummy)\n\t\t\t\tcontinue;\n\t\t\tdma_pool_free(dev->requests, dev->ep[i].dummy,\n\t\t\t\t\tdev->ep[i].td_dma);\n\t\t}\n\t\tdma_pool_destroy(dev->requests);\n\t}\n\tif (dev->got_irq)\n\t\tfree_irq(pdev->irq, dev);\n\tif (dev->quirks & PLX_PCIE)\n\t\tpci_disable_msi(pdev);\n\tif (dev->regs) {\n\t\tnet2280_led_shutdown(dev);\n\t\tiounmap(dev->regs);\n\t}\n\tif (dev->region)\n\t\trelease_mem_region(pci_resource_start(pdev, 0),\n\t\t\t\tpci_resource_len(pdev, 0));\n\tif (dev->enabled)\n\t\tpci_disable_device(pdev);\n\tdevice_remove_file(&pdev->dev, &dev_attr_registers);\n\n\tep_info(dev, \"unbind\\n\");\n\tusb_put_gadget(&dev->gadget);\n}\n\n \n\nstatic int net2280_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct net2280\t\t*dev;\n\tunsigned long\t\tresource, len;\n\tvoid\t\t\t__iomem *base = NULL;\n\tint\t\t\tretval, i;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\tusb_initialize_gadget(&pdev->dev, &dev->gadget, gadget_release);\n\tspin_lock_init(&dev->lock);\n\tdev->quirks = id->driver_data;\n\tdev->pdev = pdev;\n\tdev->gadget.ops = &net2280_ops;\n\tdev->gadget.max_speed = (dev->quirks & PLX_SUPERSPEED) ?\n\t\t\t\tUSB_SPEED_SUPER : USB_SPEED_HIGH;\n\n\t \n\tdev->gadget.name = driver_name;\n\n\t \n\tif (pci_enable_device(pdev) < 0) {\n\t\tretval = -ENODEV;\n\t\tgoto done;\n\t}\n\tdev->enabled = 1;\n\n\t \n\tresource = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\tif (!request_mem_region(resource, len, driver_name)) {\n\t\tep_dbg(dev, \"controller already in use\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto done;\n\t}\n\tdev->region = 1;\n\n\t \n\n\tbase = ioremap(resource, len);\n\tif (base == NULL) {\n\t\tep_dbg(dev, \"can't map memory\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto done;\n\t}\n\tdev->regs = (struct net2280_regs __iomem *) base;\n\tdev->usb = (struct net2280_usb_regs __iomem *) (base + 0x0080);\n\tdev->pci = (struct net2280_pci_regs __iomem *) (base + 0x0100);\n\tdev->dma = (struct net2280_dma_regs __iomem *) (base + 0x0180);\n\tdev->dep = (struct net2280_dep_regs __iomem *) (base + 0x0200);\n\tdev->epregs = (struct net2280_ep_regs __iomem *) (base + 0x0300);\n\n\tif (dev->quirks & PLX_PCIE) {\n\t\tu32 fsmvalue;\n\t\tu32 usbstat;\n\t\tdev->usb_ext = (struct usb338x_usb_ext_regs __iomem *)\n\t\t\t\t\t\t\t(base + 0x00b4);\n\t\tdev->llregs = (struct usb338x_ll_regs __iomem *)\n\t\t\t\t\t\t\t(base + 0x0700);\n\t\tdev->plregs = (struct usb338x_pl_regs __iomem *)\n\t\t\t\t\t\t\t(base + 0x0800);\n\t\tusbstat = readl(&dev->usb->usbstat);\n\t\tdev->enhanced_mode = !!(usbstat & BIT(11));\n\t\tdev->n_ep = (dev->enhanced_mode) ? 9 : 5;\n\t\t \n\t\tfsmvalue = get_idx_reg(dev->regs, SCRATCH) &\n\t\t\t\t\t(0xf << DEFECT7374_FSM_FIELD);\n\t\t \n\t\tif (fsmvalue == DEFECT7374_FSM_SS_CONTROL_READ) {\n\t\t\tdev->bug7734_patched = 1;\n\t\t\twritel(0, &dev->usb->usbctl);\n\t\t} else\n\t\t\tdev->bug7734_patched = 0;\n\t} else {\n\t\tdev->enhanced_mode = 0;\n\t\tdev->n_ep = 7;\n\t\t \n\t\twritel(0, &dev->usb->usbctl);\n\t}\n\n\tusb_reset(dev);\n\tusb_reinit(dev);\n\n\t \n\tif (!pdev->irq) {\n\t\tep_err(dev, \"No IRQ.  Check PCI setup!\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tif (dev->quirks & PLX_PCIE)\n\t\tif (pci_enable_msi(pdev))\n\t\t\tep_err(dev, \"Failed to enable MSI mode\\n\");\n\n\tif (request_irq(pdev->irq, net2280_irq, IRQF_SHARED,\n\t\t\t\t\t\t\tdriver_name, dev)) {\n\t\tep_err(dev, \"request interrupt %d failed\\n\", pdev->irq);\n\t\tretval = -EBUSY;\n\t\tgoto done;\n\t}\n\tdev->got_irq = 1;\n\n\t \n\t \n\tdev->requests = dma_pool_create(\"requests\", &pdev->dev,\n\t\tsizeof(struct net2280_dma),\n\t\t0  ,\n\t\t0  );\n\tif (!dev->requests) {\n\t\tep_dbg(dev, \"can't get request pool\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto done;\n\t}\n\tfor (i = 1; i < 5; i++) {\n\t\tstruct net2280_dma\t*td;\n\n\t\ttd = dma_pool_alloc(dev->requests, GFP_KERNEL,\n\t\t\t\t&dev->ep[i].td_dma);\n\t\tif (!td) {\n\t\t\tep_dbg(dev, \"can't get dummy %d\\n\", i);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto done;\n\t\t}\n\t\ttd->dmacount = 0;\t \n\t\ttd->dmadesc = td->dmaaddr;\n\t\tdev->ep[i].dummy = td;\n\t}\n\n\t \n\tif (dev->quirks & PLX_LEGACY)\n\t\twritel(BIT(DMA_MEMORY_WRITE_AND_INVALIDATE_ENABLE) |\n\t\t\t \n\t\t\tBIT(DMA_READ_MULTIPLE_ENABLE) |\n\t\t\tBIT(DMA_READ_LINE_ENABLE),\n\t\t\t&dev->pci->pcimstctl);\n\t \n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\t \n\tdev->chiprev = get_idx_reg(dev->regs, REG_CHIPREV) & 0xffff;\n\n\t \n\tep_info(dev, \"%s\\n\", driver_desc);\n\tep_info(dev, \"irq %d, pci mem %p, chip rev %04x\\n\",\n\t\t\tpdev->irq, base, dev->chiprev);\n\tep_info(dev, \"version: \" DRIVER_VERSION \"; %s\\n\",\n\t\tdev->enhanced_mode ? \"enhanced mode\" : \"legacy mode\");\n\tretval = device_create_file(&pdev->dev, &dev_attr_registers);\n\tif (retval)\n\t\tgoto done;\n\n\tretval = usb_add_gadget(&dev->gadget);\n\tif (retval)\n\t\tgoto done;\n\tdev->added = 1;\n\treturn 0;\n\ndone:\n\tif (dev) {\n\t\tnet2280_remove(pdev);\n\t\tkfree(dev);\n\t}\n\treturn retval;\n}\n\n \n\nstatic void net2280_shutdown(struct pci_dev *pdev)\n{\n\tstruct net2280\t\t*dev = pci_get_drvdata(pdev);\n\n\t \n\twritel(0, &dev->regs->pciirqenb0);\n\twritel(0, &dev->regs->pciirqenb1);\n\n\t \n\twritel(0, &dev->usb->usbctl);\n\n}\n\n\n \n\nstatic const struct pci_device_id pci_ids[] = { {\n\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t.class_mask =\t~0,\n\t.vendor =\tPCI_VENDOR_ID_PLX_LEGACY,\n\t.device =\t0x2280,\n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\t.driver_data =\tPLX_LEGACY | PLX_2280,\n\t}, {\n\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t.class_mask =\t~0,\n\t.vendor =\tPCI_VENDOR_ID_PLX_LEGACY,\n\t.device =\t0x2282,\n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\t.driver_data =\tPLX_LEGACY,\n\t},\n\t{\n\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t.class_mask =\t~0,\n\t.vendor =\tPCI_VENDOR_ID_PLX,\n\t.device =\t0x2380,\n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\t.driver_data =\tPLX_PCIE,\n\t },\n\t{\n\t.class =\t((PCI_CLASS_SERIAL_USB << 8) | 0xfe),\n\t.class_mask =\t~0,\n\t.vendor =\tPCI_VENDOR_ID_PLX,\n\t.device =\t0x3380,\n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\t.driver_data =\tPLX_PCIE | PLX_SUPERSPEED,\n\t },\n\t{\n\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t.class_mask =\t~0,\n\t.vendor =\tPCI_VENDOR_ID_PLX,\n\t.device =\t0x3382,\n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\t.driver_data =\tPLX_PCIE | PLX_SUPERSPEED,\n\t },\n{   }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\n \nstatic struct pci_driver net2280_pci_driver = {\n\t.name =\t\tdriver_name,\n\t.id_table =\tpci_ids,\n\n\t.probe =\tnet2280_probe,\n\t.remove =\tnet2280_remove,\n\t.shutdown =\tnet2280_shutdown,\n\n\t \n};\n\nmodule_pci_driver(net2280_pci_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}