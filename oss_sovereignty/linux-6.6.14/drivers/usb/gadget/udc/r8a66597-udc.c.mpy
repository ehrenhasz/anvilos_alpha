{
  "module_name": "r8a66597-udc.c",
  "hash_id": "31bbdbff1e61ed431c9ae0ebb42f39e60657148d757f57e6a4247e2c0e5f0a45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/r8a66597-udc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include \"r8a66597-udc.h\"\n\n#define DRIVER_VERSION\t\"2011-09-26\"\n\nstatic const char udc_name[] = \"r8a66597_udc\";\nstatic const char *r8a66597_ep_name[] = {\n\t\"ep0\", \"ep1\", \"ep2\", \"ep3\", \"ep4\", \"ep5\", \"ep6\", \"ep7\",\n\t\"ep8\", \"ep9\",\n};\n\nstatic void init_controller(struct r8a66597 *r8a66597);\nstatic void disable_controller(struct r8a66597 *r8a66597);\nstatic void irq_ep0_write(struct r8a66597_ep *ep, struct r8a66597_request *req);\nstatic void irq_packet_write(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req);\nstatic int r8a66597_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags);\n\nstatic void transfer_complete(struct r8a66597_ep *ep,\n\t\tstruct r8a66597_request *req, int status);\n\n \nstatic inline u16 get_usb_speed(struct r8a66597 *r8a66597)\n{\n\treturn r8a66597_read(r8a66597, DVSTCTR0) & RHST;\n}\n\nstatic void enable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\n\t\tunsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, INTENB0);\n\tr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE,\n\t\t\tINTENB0);\n\tr8a66597_bset(r8a66597, (1 << pipenum), reg);\n\tr8a66597_write(r8a66597, tmp, INTENB0);\n}\n\nstatic void disable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\n\t\tunsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, INTENB0);\n\tr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE,\n\t\t\tINTENB0);\n\tr8a66597_bclr(r8a66597, (1 << pipenum), reg);\n\tr8a66597_write(r8a66597, tmp, INTENB0);\n}\n\nstatic void r8a66597_usb_connect(struct r8a66597 *r8a66597)\n{\n\tr8a66597_bset(r8a66597, CTRE, INTENB0);\n\tr8a66597_bset(r8a66597, BEMPE | BRDYE, INTENB0);\n\n\tr8a66597_bset(r8a66597, DPRPU, SYSCFG0);\n}\n\nstatic void r8a66597_usb_disconnect(struct r8a66597 *r8a66597)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tr8a66597_bclr(r8a66597, CTRE, INTENB0);\n\tr8a66597_bclr(r8a66597, BEMPE | BRDYE, INTENB0);\n\tr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\n\n\tr8a66597->gadget.speed = USB_SPEED_UNKNOWN;\n\tspin_unlock(&r8a66597->lock);\n\tr8a66597->driver->disconnect(&r8a66597->gadget);\n\tspin_lock(&r8a66597->lock);\n\n\tdisable_controller(r8a66597);\n\tinit_controller(r8a66597);\n\tr8a66597_bset(r8a66597, VBSE, INTENB0);\n\tINIT_LIST_HEAD(&r8a66597->ep[0].queue);\n}\n\nstatic inline u16 control_reg_get_pid(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tu16 pid = 0;\n\tunsigned long offset;\n\n\tif (pipenum == 0) {\n\t\tpid = r8a66597_read(r8a66597, DCPCTR) & PID;\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tpid = r8a66597_read(r8a66597, offset) & PID;\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"unexpect pipe num (%d)\\n\",\n\t\t\tpipenum);\n\t}\n\n\treturn pid;\n}\n\nstatic inline void control_reg_set_pid(struct r8a66597 *r8a66597, u16 pipenum,\n\t\tu16 pid)\n{\n\tunsigned long offset;\n\n\tif (pipenum == 0) {\n\t\tr8a66597_mdfy(r8a66597, pid, PID, DCPCTR);\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tr8a66597_mdfy(r8a66597, pid, PID, offset);\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"unexpect pipe num (%d)\\n\",\n\t\t\tpipenum);\n\t}\n}\n\nstatic inline void pipe_start(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tcontrol_reg_set_pid(r8a66597, pipenum, PID_BUF);\n}\n\nstatic inline void pipe_stop(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tcontrol_reg_set_pid(r8a66597, pipenum, PID_NAK);\n}\n\nstatic inline void pipe_stall(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tcontrol_reg_set_pid(r8a66597, pipenum, PID_STALL);\n}\n\nstatic inline u16 control_reg_get(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tu16 ret = 0;\n\tunsigned long offset;\n\n\tif (pipenum == 0) {\n\t\tret = r8a66597_read(r8a66597, DCPCTR);\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tret = r8a66597_read(r8a66597, offset);\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"unexpect pipe num (%d)\\n\",\n\t\t\tpipenum);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void control_reg_sqclr(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tunsigned long offset;\n\n\tpipe_stop(r8a66597, pipenum);\n\n\tif (pipenum == 0) {\n\t\tr8a66597_bset(r8a66597, SQCLR, DCPCTR);\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tr8a66597_bset(r8a66597, SQCLR, offset);\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"unexpect pipe num (%d)\\n\",\n\t\t\tpipenum);\n\t}\n}\n\nstatic void control_reg_sqset(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tunsigned long offset;\n\n\tpipe_stop(r8a66597, pipenum);\n\n\tif (pipenum == 0) {\n\t\tr8a66597_bset(r8a66597, SQSET, DCPCTR);\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tr8a66597_bset(r8a66597, SQSET, offset);\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"unexpect pipe num(%d)\\n\", pipenum);\n\t}\n}\n\nstatic u16 control_reg_sqmon(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tunsigned long offset;\n\n\tif (pipenum == 0) {\n\t\treturn r8a66597_read(r8a66597, DCPCTR) & SQMON;\n\t} else if (pipenum < R8A66597_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\treturn r8a66597_read(r8a66597, offset) & SQMON;\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"unexpect pipe num(%d)\\n\", pipenum);\n\t}\n\n\treturn 0;\n}\n\nstatic u16 save_usb_toggle(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\treturn control_reg_sqmon(r8a66597, pipenum);\n}\n\nstatic void restore_usb_toggle(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t       u16 toggle)\n{\n\tif (toggle)\n\t\tcontrol_reg_sqset(r8a66597, pipenum);\n\telse\n\t\tcontrol_reg_sqclr(r8a66597, pipenum);\n}\n\nstatic inline int get_buffer_size(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tu16 tmp;\n\tint size;\n\n\tif (pipenum == 0) {\n\t\ttmp = r8a66597_read(r8a66597, DCPCFG);\n\t\tif ((tmp & R8A66597_CNTMD) != 0)\n\t\t\tsize = 256;\n\t\telse {\n\t\t\ttmp = r8a66597_read(r8a66597, DCPMAXP);\n\t\t\tsize = tmp & MAXP;\n\t\t}\n\t} else {\n\t\tr8a66597_write(r8a66597, pipenum, PIPESEL);\n\t\ttmp = r8a66597_read(r8a66597, PIPECFG);\n\t\tif ((tmp & R8A66597_CNTMD) != 0) {\n\t\t\ttmp = r8a66597_read(r8a66597, PIPEBUF);\n\t\t\tsize = ((tmp >> 10) + 1) * 64;\n\t\t} else {\n\t\t\ttmp = r8a66597_read(r8a66597, PIPEMAXP);\n\t\t\tsize = tmp & MXPS;\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic inline unsigned short mbw_value(struct r8a66597 *r8a66597)\n{\n\tif (r8a66597->pdata->on_chip)\n\t\treturn MBW_32;\n\telse\n\t\treturn MBW_16;\n}\n\nstatic void r8a66597_change_curpipe(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t\t    u16 isel, u16 fifosel)\n{\n\tu16 tmp, mask, loop;\n\tint i = 0;\n\n\tif (!pipenum) {\n\t\tmask = ISEL | CURPIPE;\n\t\tloop = isel;\n\t} else {\n\t\tmask = CURPIPE;\n\t\tloop = pipenum;\n\t}\n\tr8a66597_mdfy(r8a66597, loop, mask, fifosel);\n\n\tdo {\n\t\ttmp = r8a66597_read(r8a66597, fifosel);\n\t\tif (i++ > 1000000) {\n\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\"r8a66597: register%x, loop %x \"\n\t\t\t\t\"is timeout\\n\", fifosel, loop);\n\t\t\tbreak;\n\t\t}\n\t\tndelay(1);\n\t} while ((tmp & mask) != loop);\n}\n\nstatic void pipe_change(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tstruct r8a66597_ep *ep = r8a66597->pipenum2ep[pipenum];\n\n\tif (ep->use_dma)\n\t\tr8a66597_bclr(r8a66597, DREQE, ep->fifosel);\n\n\tr8a66597_mdfy(r8a66597, pipenum, CURPIPE, ep->fifosel);\n\n\tndelay(450);\n\n\tif (r8a66597_is_sudmac(r8a66597) && ep->use_dma)\n\t\tr8a66597_bclr(r8a66597, mbw_value(r8a66597), ep->fifosel);\n\telse\n\t\tr8a66597_bset(r8a66597, mbw_value(r8a66597), ep->fifosel);\n\n\tif (ep->use_dma)\n\t\tr8a66597_bset(r8a66597, DREQE, ep->fifosel);\n}\n\nstatic int pipe_buffer_setting(struct r8a66597 *r8a66597,\n\t\tstruct r8a66597_pipe_info *info)\n{\n\tu16 bufnum = 0, buf_bsize = 0;\n\tu16 pipecfg = 0;\n\n\tif (info->pipe == 0)\n\t\treturn -EINVAL;\n\n\tr8a66597_write(r8a66597, info->pipe, PIPESEL);\n\n\tif (info->dir_in)\n\t\tpipecfg |= R8A66597_DIR;\n\tpipecfg |= info->type;\n\tpipecfg |= info->epnum;\n\tswitch (info->type) {\n\tcase R8A66597_INT:\n\t\tbufnum = 4 + (info->pipe - R8A66597_BASE_PIPENUM_INT);\n\t\tbuf_bsize = 0;\n\t\tbreak;\n\tcase R8A66597_BULK:\n\t\t \n\t\tif (info->pipe >= R8A66597_BASE_PIPENUM_BULK)\n\t\t\tbufnum = info->pipe - R8A66597_BASE_PIPENUM_BULK;\n\t\telse\n\t\t\tbufnum = info->pipe - R8A66597_BASE_PIPENUM_ISOC;\n\n\t\tbufnum = R8A66597_BASE_BUFNUM + (bufnum * 16);\n\t\tbuf_bsize = 7;\n\t\tpipecfg |= R8A66597_DBLB;\n\t\tif (!info->dir_in)\n\t\t\tpipecfg |= R8A66597_SHTNAK;\n\t\tbreak;\n\tcase R8A66597_ISO:\n\t\tbufnum = R8A66597_BASE_BUFNUM +\n\t\t\t (info->pipe - R8A66597_BASE_PIPENUM_ISOC) * 16;\n\t\tbuf_bsize = 7;\n\t\tbreak;\n\t}\n\n\tif (buf_bsize && ((bufnum + 16) >= R8A66597_MAX_BUFNUM)) {\n\t\tpr_err(\"r8a66597 pipe memory is insufficient\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tr8a66597_write(r8a66597, pipecfg, PIPECFG);\n\tr8a66597_write(r8a66597, (buf_bsize << 10) | (bufnum), PIPEBUF);\n\tr8a66597_write(r8a66597, info->maxpacket, PIPEMAXP);\n\tif (info->interval)\n\t\tinfo->interval--;\n\tr8a66597_write(r8a66597, info->interval, PIPEPERI);\n\n\treturn 0;\n}\n\nstatic void pipe_buffer_release(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_pipe_info *info)\n{\n\tif (info->pipe == 0)\n\t\treturn;\n\n\tif (is_bulk_pipe(info->pipe)) {\n\t\tr8a66597->bulk--;\n\t} else if (is_interrupt_pipe(info->pipe)) {\n\t\tr8a66597->interrupt--;\n\t} else if (is_isoc_pipe(info->pipe)) {\n\t\tr8a66597->isochronous--;\n\t\tif (info->type == R8A66597_BULK)\n\t\t\tr8a66597->bulk--;\n\t} else {\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"ep_release: unexpect pipenum (%d)\\n\", info->pipe);\n\t}\n}\n\nstatic void pipe_initialize(struct r8a66597_ep *ep)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\n\tr8a66597_mdfy(r8a66597, 0, CURPIPE, ep->fifosel);\n\n\tr8a66597_write(r8a66597, ACLRM, ep->pipectr);\n\tr8a66597_write(r8a66597, 0, ep->pipectr);\n\tr8a66597_write(r8a66597, SQCLR, ep->pipectr);\n\tif (ep->use_dma) {\n\t\tr8a66597_mdfy(r8a66597, ep->pipenum, CURPIPE, ep->fifosel);\n\n\t\tndelay(450);\n\n\t\tr8a66597_bset(r8a66597, mbw_value(r8a66597), ep->fifosel);\n\t}\n}\n\nstatic void r8a66597_ep_setting(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_ep *ep,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc,\n\t\t\t\tu16 pipenum, int dma)\n{\n\tep->use_dma = 0;\n\tep->fifoaddr = CFIFO;\n\tep->fifosel = CFIFOSEL;\n\tep->fifoctr = CFIFOCTR;\n\n\tep->pipectr = get_pipectr_addr(pipenum);\n\tif (is_bulk_pipe(pipenum) || is_isoc_pipe(pipenum)) {\n\t\tep->pipetre = get_pipetre_addr(pipenum);\n\t\tep->pipetrn = get_pipetrn_addr(pipenum);\n\t} else {\n\t\tep->pipetre = 0;\n\t\tep->pipetrn = 0;\n\t}\n\tep->pipenum = pipenum;\n\tep->ep.maxpacket = usb_endpoint_maxp(desc);\n\tr8a66597->pipenum2ep[pipenum] = ep;\n\tr8a66597->epaddr2ep[usb_endpoint_num(desc)]\n\t\t= ep;\n\tINIT_LIST_HEAD(&ep->queue);\n}\n\nstatic void r8a66597_ep_release(struct r8a66597_ep *ep)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tu16 pipenum = ep->pipenum;\n\n\tif (pipenum == 0)\n\t\treturn;\n\n\tif (ep->use_dma)\n\t\tr8a66597->num_dma--;\n\tep->pipenum = 0;\n\tep->busy = 0;\n\tep->use_dma = 0;\n}\n\nstatic int alloc_pipe_config(struct r8a66597_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tstruct r8a66597_pipe_info info;\n\tint dma = 0;\n\tunsigned char *counter;\n\tint ret;\n\n\tep->ep.desc = desc;\n\n\tif (ep->pipenum)\t \n\t\treturn 0;\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (r8a66597->bulk >= R8A66597_MAX_NUM_BULK) {\n\t\t\tif (r8a66597->isochronous >= R8A66597_MAX_NUM_ISOC) {\n\t\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\t\"bulk pipe is insufficient\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t} else {\n\t\t\t\tinfo.pipe = R8A66597_BASE_PIPENUM_ISOC\n\t\t\t\t\t\t+ r8a66597->isochronous;\n\t\t\t\tcounter = &r8a66597->isochronous;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.pipe = R8A66597_BASE_PIPENUM_BULK + r8a66597->bulk;\n\t\t\tcounter = &r8a66597->bulk;\n\t\t}\n\t\tinfo.type = R8A66597_BULK;\n\t\tdma = 1;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (r8a66597->interrupt >= R8A66597_MAX_NUM_INT) {\n\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\"interrupt pipe is insufficient\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tinfo.pipe = R8A66597_BASE_PIPENUM_INT + r8a66597->interrupt;\n\t\tinfo.type = R8A66597_INT;\n\t\tcounter = &r8a66597->interrupt;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (r8a66597->isochronous >= R8A66597_MAX_NUM_ISOC) {\n\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\"isochronous pipe is insufficient\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tinfo.pipe = R8A66597_BASE_PIPENUM_ISOC + r8a66597->isochronous;\n\t\tinfo.type = R8A66597_ISO;\n\t\tcounter = &r8a66597->isochronous;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"unexpect xfer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tep->type = info.type;\n\n\tinfo.epnum = usb_endpoint_num(desc);\n\tinfo.maxpacket = usb_endpoint_maxp(desc);\n\tinfo.interval = desc->bInterval;\n\tif (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\n\t\tinfo.dir_in = 1;\n\telse\n\t\tinfo.dir_in = 0;\n\n\tret = pipe_buffer_setting(r8a66597, &info);\n\tif (ret < 0) {\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"pipe_buffer_setting fail\\n\");\n\t\treturn ret;\n\t}\n\n\t(*counter)++;\n\tif ((counter == &r8a66597->isochronous) && info.type == R8A66597_BULK)\n\t\tr8a66597->bulk++;\n\n\tr8a66597_ep_setting(r8a66597, ep, desc, info.pipe, dma);\n\tpipe_initialize(ep);\n\n\treturn 0;\n}\n\nstatic int free_pipe_config(struct r8a66597_ep *ep)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tstruct r8a66597_pipe_info info;\n\n\tinfo.pipe = ep->pipenum;\n\tinfo.type = ep->type;\n\tpipe_buffer_release(r8a66597, &info);\n\tr8a66597_ep_release(ep);\n\n\treturn 0;\n}\n\n \nstatic void pipe_irq_enable(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tenable_irq_ready(r8a66597, pipenum);\n\tenable_irq_nrdy(r8a66597, pipenum);\n}\n\nstatic void pipe_irq_disable(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tdisable_irq_ready(r8a66597, pipenum);\n\tdisable_irq_nrdy(r8a66597, pipenum);\n}\n\n \nstatic void control_end(struct r8a66597 *r8a66597, unsigned ccpl)\n{\n\tr8a66597->ep[0].internal_ccpl = ccpl;\n\tpipe_start(r8a66597, 0);\n\tr8a66597_bset(r8a66597, CCPL, DCPCTR);\n}\n\nstatic void start_ep0_write(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\n\tpipe_change(r8a66597, ep->pipenum);\n\tr8a66597_mdfy(r8a66597, ISEL, (ISEL | CURPIPE), CFIFOSEL);\n\tr8a66597_write(r8a66597, BCLR, ep->fifoctr);\n\tif (req->req.length == 0) {\n\t\tr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\n\t\tpipe_start(r8a66597, 0);\n\t\ttransfer_complete(ep, req, 0);\n\t} else {\n\t\tr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\n\t\tirq_ep0_write(ep, req);\n\t}\n}\n\nstatic void disable_fifosel(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t    u16 fifosel)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, fifosel) & CURPIPE;\n\tif (tmp == pipenum)\n\t\tr8a66597_change_curpipe(r8a66597, 0, 0, fifosel);\n}\n\nstatic void change_bfre_mode(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t     int enable)\n{\n\tstruct r8a66597_ep *ep = r8a66597->pipenum2ep[pipenum];\n\tu16 tmp, toggle;\n\n\t \n\tr8a66597_write(r8a66597, pipenum, PIPESEL);\n\ttmp = r8a66597_read(r8a66597, PIPECFG) & R8A66597_BFRE;\n\tif ((enable && tmp) || (!enable && !tmp))\n\t\treturn;\n\n\t \n\tpipe_stop(r8a66597, pipenum);\n\tdisable_fifosel(r8a66597, pipenum, CFIFOSEL);\n\tdisable_fifosel(r8a66597, pipenum, D0FIFOSEL);\n\tdisable_fifosel(r8a66597, pipenum, D1FIFOSEL);\n\n\ttoggle = save_usb_toggle(r8a66597, pipenum);\n\n\tr8a66597_write(r8a66597, pipenum, PIPESEL);\n\tif (enable)\n\t\tr8a66597_bset(r8a66597, R8A66597_BFRE, PIPECFG);\n\telse\n\t\tr8a66597_bclr(r8a66597, R8A66597_BFRE, PIPECFG);\n\n\t \n\tr8a66597_bset(r8a66597, ACLRM, ep->pipectr);\n\tr8a66597_bclr(r8a66597, ACLRM, ep->pipectr);\n\n\trestore_usb_toggle(r8a66597, pipenum, toggle);\n}\n\nstatic int sudmac_alloc_channel(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tstruct r8a66597_dma *dma;\n\n\tif (!r8a66597_is_sudmac(r8a66597))\n\t\treturn -ENODEV;\n\n\t \n\tif (!is_bulk_pipe(ep->pipenum))\n\t\treturn -EIO;\n\n\tif (r8a66597->dma.used)\n\t\treturn -EBUSY;\n\n\t \n\tdma = &r8a66597->dma;\n\tdma->used = 1;\n\tif (ep->ep.desc->bEndpointAddress & USB_DIR_IN) {\n\t\tdma->dir = 1;\n\t} else {\n\t\tdma->dir = 0;\n\t\tchange_bfre_mode(r8a66597, ep->pipenum, 1);\n\t}\n\n\t \n\tep->use_dma = 1;\n\tep->dma = dma;\n\tep->fifoaddr = D0FIFO;\n\tep->fifosel = D0FIFOSEL;\n\tep->fifoctr = D0FIFOCTR;\n\n\t \n\treturn usb_gadget_map_request(&r8a66597->gadget, &req->req, dma->dir);\n}\n\nstatic void sudmac_free_channel(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tif (!r8a66597_is_sudmac(r8a66597))\n\t\treturn;\n\n\tusb_gadget_unmap_request(&r8a66597->gadget, &req->req, ep->dma->dir);\n\n\tr8a66597_bclr(r8a66597, DREQE, ep->fifosel);\n\tr8a66597_change_curpipe(r8a66597, 0, 0, ep->fifosel);\n\n\tep->dma->used = 0;\n\tep->use_dma = 0;\n\tep->fifoaddr = CFIFO;\n\tep->fifosel = CFIFOSEL;\n\tep->fifoctr = CFIFOCTR;\n}\n\nstatic void sudmac_start(struct r8a66597 *r8a66597, struct r8a66597_ep *ep,\n\t\t\t struct r8a66597_request *req)\n{\n\tBUG_ON(req->req.length == 0);\n\n\tr8a66597_sudmac_write(r8a66597, LBA_WAIT, CH0CFG);\n\tr8a66597_sudmac_write(r8a66597, req->req.dma, CH0BA);\n\tr8a66597_sudmac_write(r8a66597, req->req.length, CH0BBC);\n\tr8a66597_sudmac_write(r8a66597, CH0ENDE, DINTCTRL);\n\n\tr8a66597_sudmac_write(r8a66597, DEN, CH0DEN);\n}\n\nstatic void start_packet_write(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tu16 tmp;\n\n\tpipe_change(r8a66597, ep->pipenum);\n\tdisable_irq_empty(r8a66597, ep->pipenum);\n\tpipe_start(r8a66597, ep->pipenum);\n\n\tif (req->req.length == 0) {\n\t\ttransfer_complete(ep, req, 0);\n\t} else {\n\t\tr8a66597_write(r8a66597, ~(1 << ep->pipenum), BRDYSTS);\n\t\tif (sudmac_alloc_channel(r8a66597, ep, req) < 0) {\n\t\t\t \n\t\t\tpipe_change(r8a66597, ep->pipenum);\n\t\t\tdisable_irq_empty(r8a66597, ep->pipenum);\n\t\t\tpipe_start(r8a66597, ep->pipenum);\n\t\t\ttmp = r8a66597_read(r8a66597, ep->fifoctr);\n\t\t\tif (unlikely((tmp & FRDY) == 0))\n\t\t\t\tpipe_irq_enable(r8a66597, ep->pipenum);\n\t\t\telse\n\t\t\t\tirq_packet_write(ep, req);\n\t\t} else {\n\t\t\t \n\t\t\tpipe_change(r8a66597, ep->pipenum);\n\t\t\tdisable_irq_nrdy(r8a66597, ep->pipenum);\n\t\t\tpipe_start(r8a66597, ep->pipenum);\n\t\t\tenable_irq_nrdy(r8a66597, ep->pipenum);\n\t\t\tsudmac_start(r8a66597, ep, req);\n\t\t}\n\t}\n}\n\nstatic void start_packet_read(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tu16 pipenum = ep->pipenum;\n\n\tif (ep->pipenum == 0) {\n\t\tr8a66597_mdfy(r8a66597, 0, (ISEL | CURPIPE), CFIFOSEL);\n\t\tr8a66597_write(r8a66597, BCLR, ep->fifoctr);\n\t\tpipe_start(r8a66597, pipenum);\n\t\tpipe_irq_enable(r8a66597, pipenum);\n\t} else {\n\t\tpipe_stop(r8a66597, pipenum);\n\t\tif (ep->pipetre) {\n\t\t\tenable_irq_nrdy(r8a66597, pipenum);\n\t\t\tr8a66597_write(r8a66597, TRCLR, ep->pipetre);\n\t\t\tr8a66597_write(r8a66597,\n\t\t\t\tDIV_ROUND_UP(req->req.length, ep->ep.maxpacket),\n\t\t\t\tep->pipetrn);\n\t\t\tr8a66597_bset(r8a66597, TRENB, ep->pipetre);\n\t\t}\n\n\t\tif (sudmac_alloc_channel(r8a66597, ep, req) < 0) {\n\t\t\t \n\t\t\tchange_bfre_mode(r8a66597, ep->pipenum, 0);\n\t\t\tpipe_start(r8a66597, pipenum);\t \n\t\t\tpipe_irq_enable(r8a66597, pipenum);\n\t\t} else {\n\t\t\tpipe_change(r8a66597, pipenum);\n\t\t\tsudmac_start(r8a66597, ep, req);\n\t\t\tpipe_start(r8a66597, pipenum);\t \n\t\t}\n\t}\n}\n\nstatic void start_packet(struct r8a66597_ep *ep, struct r8a66597_request *req)\n{\n\tif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\n\t\tstart_packet_write(ep, req);\n\telse\n\t\tstart_packet_read(ep, req);\n}\n\nstatic void start_ep0(struct r8a66597_ep *ep, struct r8a66597_request *req)\n{\n\tu16 ctsq;\n\n\tctsq = r8a66597_read(ep->r8a66597, INTSTS0) & CTSQ;\n\n\tswitch (ctsq) {\n\tcase CS_RDDS:\n\t\tstart_ep0_write(ep, req);\n\t\tbreak;\n\tcase CS_WRDS:\n\t\tstart_packet_read(ep, req);\n\t\tbreak;\n\n\tcase CS_WRND:\n\t\tcontrol_end(ep->r8a66597, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(r8a66597_to_dev(ep->r8a66597),\n\t\t\t\"start_ep0: unexpect ctsq(%x)\\n\", ctsq);\n\t\tbreak;\n\t}\n}\n\nstatic void init_controller(struct r8a66597 *r8a66597)\n{\n\tu16 vif = r8a66597->pdata->vif ? LDRV : 0;\n\tu16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;\n\tu16 endian = r8a66597->pdata->endian ? BIGEND : 0;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tif (r8a66597->pdata->buswait)\n\t\t\tr8a66597_write(r8a66597, r8a66597->pdata->buswait,\n\t\t\t\t\tSYSCFG1);\n\t\telse\n\t\t\tr8a66597_write(r8a66597, 0x0f, SYSCFG1);\n\t\tr8a66597_bset(r8a66597, HSE, SYSCFG0);\n\n\t\tr8a66597_bclr(r8a66597, USBE, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\n\t\tr8a66597_bset(r8a66597, USBE, SYSCFG0);\n\n\t\tr8a66597_bset(r8a66597, SCKE, SYSCFG0);\n\n\t\tr8a66597_bset(r8a66597, irq_sense, INTENB1);\n\t\tr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,\n\t\t\t\tDMA0CFG);\n\t} else {\n\t\tr8a66597_bset(r8a66597, vif | endian, PINCFG);\n\t\tr8a66597_bset(r8a66597, HSE, SYSCFG0);\t\t \n\t\tr8a66597_mdfy(r8a66597, get_xtal_from_pdata(r8a66597->pdata),\n\t\t\t\tXTAL, SYSCFG0);\n\n\t\tr8a66597_bclr(r8a66597, USBE, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\n\t\tr8a66597_bset(r8a66597, USBE, SYSCFG0);\n\n\t\tr8a66597_bset(r8a66597, XCKE, SYSCFG0);\n\n\t\tmdelay(3);\n\n\t\tr8a66597_bset(r8a66597, PLLC, SYSCFG0);\n\n\t\tmdelay(1);\n\n\t\tr8a66597_bset(r8a66597, SCKE, SYSCFG0);\n\n\t\tr8a66597_bset(r8a66597, irq_sense, INTENB1);\n\t\tr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR,\n\t\t\t       DMA0CFG);\n\t}\n}\n\nstatic void disable_controller(struct r8a66597 *r8a66597)\n{\n\tif (r8a66597->pdata->on_chip) {\n\t\tr8a66597_bset(r8a66597, SCKE, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, UTST, TESTMODE);\n\n\t\t \n\t\tr8a66597_write(r8a66597, 0, INTENB0);\n\t\tr8a66597_write(r8a66597, 0, INTENB1);\n\t\tr8a66597_write(r8a66597, 0, BRDYENB);\n\t\tr8a66597_write(r8a66597, 0, BEMPENB);\n\t\tr8a66597_write(r8a66597, 0, NRDYENB);\n\n\t\t \n\t\tr8a66597_write(r8a66597, 0, BRDYSTS);\n\t\tr8a66597_write(r8a66597, 0, NRDYSTS);\n\t\tr8a66597_write(r8a66597, 0, BEMPSTS);\n\n\t\tr8a66597_bclr(r8a66597, USBE, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\n\n\t} else {\n\t\tr8a66597_bclr(r8a66597, UTST, TESTMODE);\n\t\tr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\n\t\tudelay(1);\n\t\tr8a66597_bclr(r8a66597, PLLC, SYSCFG0);\n\t\tudelay(1);\n\t\tudelay(1);\n\t\tr8a66597_bclr(r8a66597, XCKE, SYSCFG0);\n\t}\n}\n\nstatic void r8a66597_start_xclock(struct r8a66597 *r8a66597)\n{\n\tu16 tmp;\n\n\tif (!r8a66597->pdata->on_chip) {\n\t\ttmp = r8a66597_read(r8a66597, SYSCFG0);\n\t\tif (!(tmp & XCKE))\n\t\t\tr8a66597_bset(r8a66597, XCKE, SYSCFG0);\n\t}\n}\n\nstatic struct r8a66597_request *get_request_from_ep(struct r8a66597_ep *ep)\n{\n\treturn list_entry(ep->queue.next, struct r8a66597_request, queue);\n}\n\n \nstatic void transfer_complete(struct r8a66597_ep *ep,\n\t\tstruct r8a66597_request *req, int status)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tint restart = 0;\n\n\tif (unlikely(ep->pipenum == 0)) {\n\t\tif (ep->internal_ccpl) {\n\t\t\tep->internal_ccpl = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_del_init(&req->queue);\n\tif (ep->r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treq->req.status = -ESHUTDOWN;\n\telse\n\t\treq->req.status = status;\n\n\tif (!list_empty(&ep->queue))\n\t\trestart = 1;\n\n\tif (ep->use_dma)\n\t\tsudmac_free_channel(ep->r8a66597, ep, req);\n\n\tspin_unlock(&ep->r8a66597->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->r8a66597->lock);\n\n\tif (restart) {\n\t\treq = get_request_from_ep(ep);\n\t\tif (ep->ep.desc)\n\t\t\tstart_packet(ep, req);\n\t}\n}\n\nstatic void irq_ep0_write(struct r8a66597_ep *ep, struct r8a66597_request *req)\n{\n\tint i;\n\tu16 tmp;\n\tunsigned bufsize;\n\tsize_t size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\n\tpipe_change(r8a66597, pipenum);\n\tr8a66597_bset(r8a66597, ISEL, ep->fifosel);\n\n\ti = 0;\n\tdo {\n\t\ttmp = r8a66597_read(r8a66597, ep->fifoctr);\n\t\tif (i++ > 100000) {\n\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\"pipe0 is busy. maybe cpu i/o bus \"\n\t\t\t\t\"conflict. please power off this controller.\");\n\t\t\treturn;\n\t\t}\n\t\tndelay(1);\n\t} while ((tmp & FRDY) == 0);\n\n\t \n\tbufsize = get_buffer_size(r8a66597, pipenum);\n\tbuf = req->req.buf + req->req.actual;\n\tsize = min(bufsize, req->req.length - req->req.actual);\n\n\t \n\tif (req->req.buf) {\n\t\tif (size > 0)\n\t\t\tr8a66597_write_fifo(r8a66597, ep, buf, size);\n\t\tif ((size == 0) || ((size % ep->ep.maxpacket) != 0))\n\t\t\tr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\n\t}\n\n\t \n\treq->req.actual += size;\n\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tdisable_irq_ready(r8a66597, pipenum);\n\t\tdisable_irq_empty(r8a66597, pipenum);\n\t} else {\n\t\tdisable_irq_ready(r8a66597, pipenum);\n\t\tenable_irq_empty(r8a66597, pipenum);\n\t}\n\tpipe_start(r8a66597, pipenum);\n}\n\nstatic void irq_packet_write(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tu16 tmp;\n\tunsigned bufsize;\n\tsize_t size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\n\tpipe_change(r8a66597, pipenum);\n\ttmp = r8a66597_read(r8a66597, ep->fifoctr);\n\tif (unlikely((tmp & FRDY) == 0)) {\n\t\tpipe_stop(r8a66597, pipenum);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"write fifo not ready. pipnum=%d\\n\", pipenum);\n\t\treturn;\n\t}\n\n\t \n\tbufsize = get_buffer_size(r8a66597, pipenum);\n\tbuf = req->req.buf + req->req.actual;\n\tsize = min(bufsize, req->req.length - req->req.actual);\n\n\t \n\tif (req->req.buf) {\n\t\tr8a66597_write_fifo(r8a66597, ep, buf, size);\n\t\tif ((size == 0)\n\t\t\t\t|| ((size % ep->ep.maxpacket) != 0)\n\t\t\t\t|| ((bufsize != ep->ep.maxpacket)\n\t\t\t\t\t&& (bufsize > size)))\n\t\t\tr8a66597_bset(r8a66597, BVAL, ep->fifoctr);\n\t}\n\n\t \n\treq->req.actual += size;\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tdisable_irq_ready(r8a66597, pipenum);\n\t\tenable_irq_empty(r8a66597, pipenum);\n\t} else {\n\t\tdisable_irq_empty(r8a66597, pipenum);\n\t\tpipe_irq_enable(r8a66597, pipenum);\n\t}\n}\n\nstatic void irq_packet_read(struct r8a66597_ep *ep,\n\t\t\t\tstruct r8a66597_request *req)\n{\n\tu16 tmp;\n\tint rcv_len, bufsize, req_len;\n\tint size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct r8a66597 *r8a66597 = ep->r8a66597;\n\tint finish = 0;\n\n\tpipe_change(r8a66597, pipenum);\n\ttmp = r8a66597_read(r8a66597, ep->fifoctr);\n\tif (unlikely((tmp & FRDY) == 0)) {\n\t\treq->req.status = -EPIPE;\n\t\tpipe_stop(r8a66597, pipenum);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"read fifo not ready\");\n\t\treturn;\n\t}\n\n\t \n\trcv_len = tmp & DTLN;\n\tbufsize = get_buffer_size(r8a66597, pipenum);\n\n\tbuf = req->req.buf + req->req.actual;\n\treq_len = req->req.length - req->req.actual;\n\tif (rcv_len < bufsize)\n\t\tsize = min(rcv_len, req_len);\n\telse\n\t\tsize = min(bufsize, req_len);\n\n\t \n\treq->req.actual += size;\n\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tpipe_stop(r8a66597, pipenum);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tfinish = 1;\n\t}\n\n\t \n\tif (req->req.buf) {\n\t\tif (size == 0)\n\t\t\tr8a66597_write(r8a66597, BCLR, ep->fifoctr);\n\t\telse\n\t\t\tr8a66597_read_fifo(r8a66597, ep->fifoaddr, buf, size);\n\n\t}\n\n\tif ((ep->pipenum != 0) && finish)\n\t\ttransfer_complete(ep, req, 0);\n}\n\nstatic void irq_pipe_ready(struct r8a66597 *r8a66597, u16 status, u16 enb)\n{\n\tu16 check;\n\tu16 pipenum;\n\tstruct r8a66597_ep *ep;\n\tstruct r8a66597_request *req;\n\n\tif ((status & BRDY0) && (enb & BRDY0)) {\n\t\tr8a66597_write(r8a66597, ~BRDY0, BRDYSTS);\n\t\tr8a66597_mdfy(r8a66597, 0, CURPIPE, CFIFOSEL);\n\n\t\tep = &r8a66597->ep[0];\n\t\treq = get_request_from_ep(ep);\n\t\tirq_packet_read(ep, req);\n\t} else {\n\t\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\t\tcheck = 1 << pipenum;\n\t\t\tif ((status & check) && (enb & check)) {\n\t\t\t\tr8a66597_write(r8a66597, ~check, BRDYSTS);\n\t\t\t\tep = r8a66597->pipenum2ep[pipenum];\n\t\t\t\treq = get_request_from_ep(ep);\n\t\t\t\tif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t\tirq_packet_write(ep, req);\n\t\t\t\telse\n\t\t\t\t\tirq_packet_read(ep, req);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void irq_pipe_empty(struct r8a66597 *r8a66597, u16 status, u16 enb)\n{\n\tu16 tmp;\n\tu16 check;\n\tu16 pipenum;\n\tstruct r8a66597_ep *ep;\n\tstruct r8a66597_request *req;\n\n\tif ((status & BEMP0) && (enb & BEMP0)) {\n\t\tr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\n\n\t\tep = &r8a66597->ep[0];\n\t\treq = get_request_from_ep(ep);\n\t\tirq_ep0_write(ep, req);\n\t} else {\n\t\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\t\tcheck = 1 << pipenum;\n\t\t\tif ((status & check) && (enb & check)) {\n\t\t\t\tr8a66597_write(r8a66597, ~check, BEMPSTS);\n\t\t\t\ttmp = control_reg_get(r8a66597, pipenum);\n\t\t\t\tif ((tmp & INBUFM) == 0) {\n\t\t\t\t\tdisable_irq_empty(r8a66597, pipenum);\n\t\t\t\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\t\t\t\tpipe_stop(r8a66597, pipenum);\n\t\t\t\t\tep = r8a66597->pipenum2ep[pipenum];\n\t\t\t\t\treq = get_request_from_ep(ep);\n\t\t\t\t\tif (!list_empty(&ep->queue))\n\t\t\t\t\t\ttransfer_complete(ep, req, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void get_status(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tstruct r8a66597_ep *ep;\n\tu16 pid;\n\tu16 status = 0;\n\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = r8a66597->device_status;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tpid = control_reg_get_pid(r8a66597, ep->pipenum);\n\t\tif (pid == PID_STALL)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\telse\n\t\t\tstatus = 0;\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(r8a66597, 0);\n\t\treturn;\t\t \n\t}\n\n\tr8a66597->ep0_data = cpu_to_le16(status);\n\tr8a66597->ep0_req->buf = &r8a66597->ep0_data;\n\tr8a66597->ep0_req->length = 2;\n\t \n\tspin_unlock(&r8a66597->lock);\n\tr8a66597_queue(r8a66597->gadget.ep0, r8a66597->ep0_req, GFP_ATOMIC);\n\tspin_lock(&r8a66597->lock);\n}\n\nstatic void clear_feature(struct r8a66597 *r8a66597,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tcontrol_end(r8a66597, 1);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tcontrol_end(r8a66597, 1);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tstruct r8a66597_ep *ep;\n\t\tstruct r8a66597_request *req;\n\t\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\t\tep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tif (!ep->wedge) {\n\t\t\tpipe_stop(r8a66597, ep->pipenum);\n\t\t\tcontrol_reg_sqclr(r8a66597, ep->pipenum);\n\t\t\tspin_unlock(&r8a66597->lock);\n\t\t\tusb_ep_clear_halt(&ep->ep);\n\t\t\tspin_lock(&r8a66597->lock);\n\t\t}\n\n\t\tcontrol_end(r8a66597, 1);\n\n\t\treq = get_request_from_ep(ep);\n\t\tif (ep->busy) {\n\t\t\tep->busy = 0;\n\t\t\tif (list_empty(&ep->queue))\n\t\t\t\tbreak;\n\t\t\tstart_packet(ep, req);\n\t\t} else if (!list_empty(&ep->queue))\n\t\t\tpipe_start(r8a66597, ep->pipenum);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(r8a66597, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void set_feature(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\n{\n\tu16 tmp;\n\tint timeout = 3000;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (le16_to_cpu(ctrl->wValue)) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\tcontrol_end(r8a66597, 1);\n\t\t\t \n\t\t\tdo {\n\t\t\t\ttmp = r8a66597_read(r8a66597, INTSTS0) & CTSQ;\n\t\t\t\tudelay(1);\n\t\t\t} while (tmp != CS_IDST && timeout-- > 0);\n\n\t\t\tif (tmp == CS_IDST)\n\t\t\t\tr8a66597_bset(r8a66597,\n\t\t\t\t\t      le16_to_cpu(ctrl->wIndex >> 8),\n\t\t\t\t\t      TESTMODE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpipe_stall(r8a66597, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tcontrol_end(r8a66597, 1);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tstruct r8a66597_ep *ep;\n\t\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\t\tep = r8a66597->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tpipe_stall(r8a66597, ep->pipenum);\n\n\t\tcontrol_end(r8a66597, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(r8a66597, 0);\n\t\tbreak;\n\t}\n}\n\n \nstatic int setup_packet(struct r8a66597 *r8a66597, struct usb_ctrlrequest *ctrl)\n{\n\tu16 *p = (u16 *)ctrl;\n\tunsigned long offset = USBREQ;\n\tint i, ret = 0;\n\n\t \n\tr8a66597_write(r8a66597, ~VALID, INTSTS0);\n\n\tfor (i = 0; i < 4; i++)\n\t\tp[i] = r8a66597_read(r8a66597, offset + i*2);\n\n\t \n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tget_status(r8a66597, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tclear_feature(r8a66597, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tset_feature(r8a66597, ctrl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tret = 1;\n\treturn ret;\n}\n\nstatic void r8a66597_update_usb_speed(struct r8a66597 *r8a66597)\n{\n\tu16 speed = get_usb_speed(r8a66597);\n\n\tswitch (speed) {\n\tcase HSMODE:\n\t\tr8a66597->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase FSMODE:\n\t\tr8a66597->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\tdefault:\n\t\tr8a66597->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tdev_err(r8a66597_to_dev(r8a66597), \"USB speed unknown\\n\");\n\t}\n}\n\nstatic void irq_device_state(struct r8a66597 *r8a66597)\n{\n\tu16 dvsq;\n\n\tdvsq = r8a66597_read(r8a66597, INTSTS0) & DVSQ;\n\tr8a66597_write(r8a66597, ~DVST, INTSTS0);\n\n\tif (dvsq == DS_DFLT) {\n\t\t \n\t\tspin_unlock(&r8a66597->lock);\n\t\tusb_gadget_udc_reset(&r8a66597->gadget, r8a66597->driver);\n\t\tspin_lock(&r8a66597->lock);\n\t\tr8a66597_update_usb_speed(r8a66597);\n\t}\n\tif (r8a66597->old_dvsq == DS_CNFG && dvsq != DS_CNFG)\n\t\tr8a66597_update_usb_speed(r8a66597);\n\tif ((dvsq == DS_CNFG || dvsq == DS_ADDS)\n\t\t\t&& r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tr8a66597_update_usb_speed(r8a66597);\n\n\tr8a66597->old_dvsq = dvsq;\n}\n\nstatic void irq_control_stage(struct r8a66597 *r8a66597)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tstruct usb_ctrlrequest ctrl;\n\tu16 ctsq;\n\n\tctsq = r8a66597_read(r8a66597, INTSTS0) & CTSQ;\n\tr8a66597_write(r8a66597, ~CTRT, INTSTS0);\n\n\tswitch (ctsq) {\n\tcase CS_IDST: {\n\t\tstruct r8a66597_ep *ep;\n\t\tstruct r8a66597_request *req;\n\t\tep = &r8a66597->ep[0];\n\t\treq = get_request_from_ep(ep);\n\t\ttransfer_complete(ep, req, 0);\n\t\t}\n\t\tbreak;\n\n\tcase CS_RDDS:\n\tcase CS_WRDS:\n\tcase CS_WRND:\n\t\tif (setup_packet(r8a66597, &ctrl)) {\n\t\t\tspin_unlock(&r8a66597->lock);\n\t\t\tif (r8a66597->driver->setup(&r8a66597->gadget, &ctrl)\n\t\t\t\t< 0)\n\t\t\t\tpipe_stall(r8a66597, 0);\n\t\t\tspin_lock(&r8a66597->lock);\n\t\t}\n\t\tbreak;\n\tcase CS_RDSS:\n\tcase CS_WRSS:\n\t\tcontrol_end(r8a66597, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\"ctrl_stage: unexpect ctsq(%x)\\n\", ctsq);\n\t\tbreak;\n\t}\n}\n\nstatic void sudmac_finish(struct r8a66597 *r8a66597, struct r8a66597_ep *ep)\n{\n\tu16 pipenum;\n\tstruct r8a66597_request *req;\n\tu32 len;\n\tint i = 0;\n\n\tpipenum = ep->pipenum;\n\tpipe_change(r8a66597, pipenum);\n\n\twhile (!(r8a66597_read(r8a66597, ep->fifoctr) & FRDY)) {\n\t\tudelay(1);\n\t\tif (unlikely(i++ >= 10000)) {\t \n\t\t\tdev_err(r8a66597_to_dev(r8a66597),\n\t\t\t\t\"%s: FRDY was not set (%d)\\n\",\n\t\t\t\t__func__, pipenum);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tr8a66597_bset(r8a66597, BCLR, ep->fifoctr);\n\treq = get_request_from_ep(ep);\n\n\t \n\tlen = r8a66597_sudmac_read(r8a66597, CH0CBC);\n\treq->req.actual += len;\n\n\t \n\tr8a66597_sudmac_write(r8a66597, CH0STCLR, DSTSCLR);\n\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (len % ep->ep.maxpacket)) {\n\t\tif (ep->dma->dir) {\n\t\t\tdisable_irq_ready(r8a66597, pipenum);\n\t\t\tenable_irq_empty(r8a66597, pipenum);\n\t\t} else {\n\t\t\t \n\t\t\tr8a66597_write(r8a66597, ~(1 << pipenum), BRDYSTS);\n\t\t\ttransfer_complete(ep, req, 0);\n\t\t}\n\t}\n}\n\nstatic void r8a66597_sudmac_irq(struct r8a66597 *r8a66597)\n{\n\tu32 irqsts;\n\tstruct r8a66597_ep *ep;\n\tu16 pipenum;\n\n\tirqsts = r8a66597_sudmac_read(r8a66597, DINTSTS);\n\tif (irqsts & CH0ENDS) {\n\t\tr8a66597_sudmac_write(r8a66597, CH0ENDC, DINTSTSCLR);\n\t\tpipenum = (r8a66597_read(r8a66597, D0FIFOSEL) & CURPIPE);\n\t\tep = r8a66597->pipenum2ep[pipenum];\n\t\tsudmac_finish(r8a66597, ep);\n\t}\n}\n\nstatic irqreturn_t r8a66597_irq(int irq, void *_r8a66597)\n{\n\tstruct r8a66597 *r8a66597 = _r8a66597;\n\tu16 intsts0;\n\tu16 intenb0;\n\tu16 savepipe;\n\tu16 mask0;\n\n\tspin_lock(&r8a66597->lock);\n\n\tif (r8a66597_is_sudmac(r8a66597))\n\t\tr8a66597_sudmac_irq(r8a66597);\n\n\tintsts0 = r8a66597_read(r8a66597, INTSTS0);\n\tintenb0 = r8a66597_read(r8a66597, INTENB0);\n\n\tsavepipe = r8a66597_read(r8a66597, CFIFOSEL);\n\n\tmask0 = intsts0 & intenb0;\n\tif (mask0) {\n\t\tu16 brdysts = r8a66597_read(r8a66597, BRDYSTS);\n\t\tu16 bempsts = r8a66597_read(r8a66597, BEMPSTS);\n\t\tu16 brdyenb = r8a66597_read(r8a66597, BRDYENB);\n\t\tu16 bempenb = r8a66597_read(r8a66597, BEMPENB);\n\n\t\tif (mask0 & VBINT) {\n\t\t\tr8a66597_write(r8a66597,  0xffff & ~VBINT,\n\t\t\t\t\tINTSTS0);\n\t\t\tr8a66597_start_xclock(r8a66597);\n\n\t\t\t \n\t\t\tr8a66597->old_vbus = r8a66597_read(r8a66597, INTSTS0)\n\t\t\t\t\t& VBSTS;\n\t\t\tr8a66597->scount = R8A66597_MAX_SAMPLING;\n\n\t\t\tmod_timer(&r8a66597->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t}\n\t\tif (intsts0 & DVSQ)\n\t\t\tirq_device_state(r8a66597);\n\n\t\tif ((intsts0 & BRDY) && (intenb0 & BRDYE)\n\t\t\t\t&& (brdysts & brdyenb))\n\t\t\tirq_pipe_ready(r8a66597, brdysts, brdyenb);\n\t\tif ((intsts0 & BEMP) && (intenb0 & BEMPE)\n\t\t\t\t&& (bempsts & bempenb))\n\t\t\tirq_pipe_empty(r8a66597, bempsts, bempenb);\n\n\t\tif (intsts0 & CTRT)\n\t\t\tirq_control_stage(r8a66597);\n\t}\n\n\tr8a66597_write(r8a66597, savepipe, CFIFOSEL);\n\n\tspin_unlock(&r8a66597->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void r8a66597_timer(struct timer_list *t)\n{\n\tstruct r8a66597 *r8a66597 = from_timer(r8a66597, t, timer);\n\tunsigned long flags;\n\tu16 tmp;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\ttmp = r8a66597_read(r8a66597, SYSCFG0);\n\tif (r8a66597->scount > 0) {\n\t\ttmp = r8a66597_read(r8a66597, INTSTS0) & VBSTS;\n\t\tif (tmp == r8a66597->old_vbus) {\n\t\t\tr8a66597->scount--;\n\t\t\tif (r8a66597->scount == 0) {\n\t\t\t\tif (tmp == VBSTS)\n\t\t\t\t\tr8a66597_usb_connect(r8a66597);\n\t\t\t\telse\n\t\t\t\t\tr8a66597_usb_disconnect(r8a66597);\n\t\t\t} else {\n\t\t\t\tmod_timer(&r8a66597->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t\t}\n\t\t} else {\n\t\t\tr8a66597->scount = R8A66597_MAX_SAMPLING;\n\t\t\tr8a66597->old_vbus = tmp;\n\t\t\tmod_timer(&r8a66597->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n}\n\n \nstatic int r8a66597_enable(struct usb_ep *_ep,\n\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\tstruct r8a66597_ep *ep;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\treturn alloc_pipe_config(ep, desc);\n}\n\nstatic int r8a66597_disable(struct usb_ep *_ep)\n{\n\tstruct r8a66597_ep *ep;\n\tstruct r8a66597_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\tBUG_ON(!ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = get_request_from_ep(ep);\n\t\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\t\ttransfer_complete(ep, req, -ECONNRESET);\n\t\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n\t}\n\n\tpipe_irq_disable(ep->r8a66597, ep->pipenum);\n\treturn free_pipe_config(ep);\n}\n\nstatic struct usb_request *r8a66597_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\tgfp_t gfp_flags)\n{\n\tstruct r8a66597_request *req;\n\n\treq = kzalloc(sizeof(struct r8a66597_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void r8a66597_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct r8a66597_request *req;\n\n\treq = container_of(_req, struct r8a66597_request, req);\n\tkfree(req);\n}\n\nstatic int r8a66597_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct r8a66597_ep *ep;\n\tstruct r8a66597_request *req;\n\tunsigned long flags;\n\tint request = 0;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\treq = container_of(_req, struct r8a66597_request, req);\n\n\tif (ep->r8a66597->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\n\tif (list_empty(&ep->queue))\n\t\trequest = 1;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\n\tif (ep->ep.desc == NULL)\t \n\t\tstart_ep0(ep, req);\n\telse {\n\t\tif (request && !ep->busy)\n\t\t\tstart_packet(ep, req);\n\t}\n\n\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n\n\treturn 0;\n}\n\nstatic int r8a66597_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct r8a66597_ep *ep;\n\tstruct r8a66597_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\treq = container_of(_req, struct r8a66597_request, req);\n\n\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\ttransfer_complete(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n\n\treturn 0;\n}\n\nstatic int r8a66597_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct r8a66597_ep *ep = container_of(_ep, struct r8a66597_ep, ep);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t} else if (value) {\n\t\tep->busy = 1;\n\t\tpipe_stall(ep->r8a66597, ep->pipenum);\n\t} else {\n\t\tep->busy = 0;\n\t\tep->wedge = 0;\n\t\tpipe_stop(ep->r8a66597, ep->pipenum);\n\t}\n\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n\treturn ret;\n}\n\nstatic int r8a66597_set_wedge(struct usb_ep *_ep)\n{\n\tstruct r8a66597_ep *ep;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\n\tif (!ep || !ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\tep->wedge = 1;\n\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n\n\treturn usb_ep_set_halt(_ep);\n}\n\nstatic void r8a66597_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct r8a66597_ep *ep;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct r8a66597_ep, ep);\n\tspin_lock_irqsave(&ep->r8a66597->lock, flags);\n\tif (list_empty(&ep->queue) && !ep->busy) {\n\t\tpipe_stop(ep->r8a66597, ep->pipenum);\n\t\tr8a66597_bclr(ep->r8a66597, BCLR, ep->fifoctr);\n\t\tr8a66597_write(ep->r8a66597, ACLRM, ep->pipectr);\n\t\tr8a66597_write(ep->r8a66597, 0, ep->pipectr);\n\t}\n\tspin_unlock_irqrestore(&ep->r8a66597->lock, flags);\n}\n\nstatic const struct usb_ep_ops r8a66597_ep_ops = {\n\t.enable\t\t= r8a66597_enable,\n\t.disable\t= r8a66597_disable,\n\n\t.alloc_request\t= r8a66597_alloc_request,\n\t.free_request\t= r8a66597_free_request,\n\n\t.queue\t\t= r8a66597_queue,\n\t.dequeue\t= r8a66597_dequeue,\n\n\t.set_halt\t= r8a66597_set_halt,\n\t.set_wedge\t= r8a66597_set_wedge,\n\t.fifo_flush\t= r8a66597_fifo_flush,\n};\n\n \nstatic int r8a66597_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\n\n\tif (!driver\n\t\t\t|| driver->max_speed < USB_SPEED_HIGH\n\t\t\t|| !driver->setup)\n\t\treturn -EINVAL;\n\tif (!r8a66597)\n\t\treturn -ENODEV;\n\n\t \n\tr8a66597->driver = driver;\n\n\tinit_controller(r8a66597);\n\tr8a66597_bset(r8a66597, VBSE, INTENB0);\n\tif (r8a66597_read(r8a66597, INTSTS0) & VBSTS) {\n\t\tr8a66597_start_xclock(r8a66597);\n\t\t \n\t\tr8a66597->old_vbus = r8a66597_read(r8a66597,\n\t\t\t\t\t INTSTS0) & VBSTS;\n\t\tr8a66597->scount = R8A66597_MAX_SAMPLING;\n\t\tmod_timer(&r8a66597->timer, jiffies + msecs_to_jiffies(50));\n\t}\n\n\treturn 0;\n}\n\nstatic int r8a66597_stop(struct usb_gadget *gadget)\n{\n\tstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tr8a66597_bclr(r8a66597, VBSE, INTENB0);\n\tdisable_controller(r8a66597);\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\n\tr8a66597->driver = NULL;\n\treturn 0;\n}\n\n \nstatic int r8a66597_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct r8a66597 *r8a66597 = gadget_to_r8a66597(_gadget);\n\treturn r8a66597_read(r8a66597, FRMNUM) & 0x03FF;\n}\n\nstatic int r8a66597_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tif (is_on)\n\t\tr8a66597_bset(r8a66597, DPRPU, SYSCFG0);\n\telse\n\t\tr8a66597_bclr(r8a66597, DPRPU, SYSCFG0);\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\n\treturn 0;\n}\n\nstatic int r8a66597_set_selfpowered(struct usb_gadget *gadget, int is_self)\n{\n\tstruct r8a66597 *r8a66597 = gadget_to_r8a66597(gadget);\n\n\tgadget->is_selfpowered = (is_self != 0);\n\tif (is_self)\n\t\tr8a66597->device_status |= 1 << USB_DEVICE_SELF_POWERED;\n\telse\n\t\tr8a66597->device_status &= ~(1 << USB_DEVICE_SELF_POWERED);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops r8a66597_gadget_ops = {\n\t.get_frame\t\t= r8a66597_get_frame,\n\t.udc_start\t\t= r8a66597_start,\n\t.udc_stop\t\t= r8a66597_stop,\n\t.pullup\t\t\t= r8a66597_pullup,\n\t.set_selfpowered\t= r8a66597_set_selfpowered,\n};\n\nstatic void r8a66597_remove(struct platform_device *pdev)\n{\n\tstruct r8a66597\t\t*r8a66597 = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&r8a66597->gadget);\n\tdel_timer_sync(&r8a66597->timer);\n\tr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tclk_disable_unprepare(r8a66597->clk);\n\t}\n}\n\nstatic void nop_completion(struct usb_ep *ep, struct usb_request *r)\n{\n}\n\nstatic int r8a66597_sudmac_ioremap(struct r8a66597 *r8a66597,\n\t\t\t\t\t  struct platform_device *pdev)\n{\n\tr8a66597->sudmac_reg =\n\t\tdevm_platform_ioremap_resource_byname(pdev, \"sudmac\");\n\treturn PTR_ERR_OR_ZERO(r8a66597->sudmac_reg);\n}\n\nstatic int r8a66597_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tchar clk_name[8];\n\tstruct resource *ires;\n\tint irq;\n\tvoid __iomem *reg = NULL;\n\tstruct r8a66597 *r8a66597 = NULL;\n\tint ret = 0;\n\tint i;\n\tunsigned long irq_trigger;\n\n\treg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(reg))\n\t\treturn PTR_ERR(reg);\n\n\tires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!ires)\n\t\treturn -EINVAL;\n\tirq = ires->start;\n\tirq_trigger = ires->flags & IRQF_TRIGGER_MASK;\n\n\tif (irq < 0) {\n\t\tdev_err(dev, \"platform_get_irq error.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tr8a66597 = devm_kzalloc(dev, sizeof(struct r8a66597), GFP_KERNEL);\n\tif (r8a66597 == NULL)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&r8a66597->lock);\n\tplatform_set_drvdata(pdev, r8a66597);\n\tr8a66597->pdata = dev_get_platdata(dev);\n\tr8a66597->irq_sense_low = irq_trigger == IRQF_TRIGGER_LOW;\n\n\tr8a66597->gadget.ops = &r8a66597_gadget_ops;\n\tr8a66597->gadget.max_speed = USB_SPEED_HIGH;\n\tr8a66597->gadget.name = udc_name;\n\n\ttimer_setup(&r8a66597->timer, r8a66597_timer, 0);\n\tr8a66597->reg = reg;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"usb%d\", pdev->id);\n\t\tr8a66597->clk = devm_clk_get(dev, clk_name);\n\t\tif (IS_ERR(r8a66597->clk)) {\n\t\t\tdev_err(dev, \"cannot get clock \\\"%s\\\"\\n\", clk_name);\n\t\t\treturn PTR_ERR(r8a66597->clk);\n\t\t}\n\t\tclk_prepare_enable(r8a66597->clk);\n\t}\n\n\tif (r8a66597->pdata->sudmac) {\n\t\tret = r8a66597_sudmac_ioremap(r8a66597, pdev);\n\t\tif (ret < 0)\n\t\t\tgoto clean_up2;\n\t}\n\n\tdisable_controller(r8a66597);  \n\n\tret = devm_request_irq(dev, irq, r8a66597_irq, IRQF_SHARED,\n\t\t\t       udc_name, r8a66597);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_irq error (%d)\\n\", ret);\n\t\tgoto clean_up2;\n\t}\n\n\tINIT_LIST_HEAD(&r8a66597->gadget.ep_list);\n\tr8a66597->gadget.ep0 = &r8a66597->ep[0].ep;\n\tINIT_LIST_HEAD(&r8a66597->gadget.ep0->ep_list);\n\tfor (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {\n\t\tstruct r8a66597_ep *ep = &r8a66597->ep[i];\n\n\t\tif (i != 0) {\n\t\t\tINIT_LIST_HEAD(&r8a66597->ep[i].ep.ep_list);\n\t\t\tlist_add_tail(&r8a66597->ep[i].ep.ep_list,\n\t\t\t\t\t&r8a66597->gadget.ep_list);\n\t\t}\n\t\tep->r8a66597 = r8a66597;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tep->ep.name = r8a66597_ep_name[i];\n\t\tep->ep.ops = &r8a66597_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, 512);\n\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\tusb_ep_set_maxpacket_limit(&r8a66597->ep[0].ep, 64);\n\tr8a66597->ep[0].pipenum = 0;\n\tr8a66597->ep[0].fifoaddr = CFIFO;\n\tr8a66597->ep[0].fifosel = CFIFOSEL;\n\tr8a66597->ep[0].fifoctr = CFIFOCTR;\n\tr8a66597->ep[0].pipectr = get_pipectr_addr(0);\n\tr8a66597->pipenum2ep[0] = &r8a66597->ep[0];\n\tr8a66597->epaddr2ep[0] = &r8a66597->ep[0];\n\n\tr8a66597->ep0_req = r8a66597_alloc_request(&r8a66597->ep[0].ep,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (r8a66597->ep0_req == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto clean_up2;\n\t}\n\tr8a66597->ep0_req->complete = nop_completion;\n\n\tret = usb_add_gadget_udc(dev, &r8a66597->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\n\tdev_info(dev, \"version %s\\n\", DRIVER_VERSION);\n\treturn 0;\n\nerr_add_udc:\n\tr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\nclean_up2:\n\tif (r8a66597->pdata->on_chip)\n\t\tclk_disable_unprepare(r8a66597->clk);\n\n\tif (r8a66597->ep0_req)\n\t\tr8a66597_free_request(&r8a66597->ep[0].ep, r8a66597->ep0_req);\n\n\treturn ret;\n}\n\n \nstatic struct platform_driver r8a66597_driver = {\n\t.remove_new =\tr8a66597_remove,\n\t.driver\t\t= {\n\t\t.name =\tudc_name,\n\t},\n};\n\nmodule_platform_driver_probe(r8a66597_driver, r8a66597_probe);\n\nMODULE_DESCRIPTION(\"R8A66597 USB gadget driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_ALIAS(\"platform:r8a66597_udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}