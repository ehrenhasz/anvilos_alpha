{
  "module_name": "goku_udc.c",
  "hash_id": "aae14027226cc5ab9965c3b98d6cf2d720d54e340914ef2541e8d5d2a58c5889",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/goku_udc.c",
  "human_readable_source": "\n \n\n \n\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/prefetch.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n\n#include \"goku_udc.h\"\n\n#define\tDRIVER_DESC\t\t\"TC86C001 USB Device Controller\"\n#define\tDRIVER_VERSION\t\t\"30-Oct 2003\"\n\nstatic const char driver_name [] = \"goku_udc\";\nstatic const char driver_desc [] = DRIVER_DESC;\n\nMODULE_AUTHOR(\"source@mvista.com\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n\n \nstatic unsigned use_dma = 1;\n\n#if 0\n\n \nmodule_param(use_dma, uint, S_IRUGO);\n#endif\n\n \n\nstatic void nuke(struct goku_ep *, int status);\n\nstatic inline void\ncommand(struct goku_udc_regs __iomem *regs, int command, unsigned epnum)\n{\n\twritel(COMMAND_EP(epnum) | command, &regs->Command);\n\tudelay(300);\n}\n\nstatic int\ngoku_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\n{\n\tstruct goku_udc\t*dev;\n\tstruct goku_ep\t*ep;\n\tu32\t\tmode;\n\tu16\t\tmax;\n\tunsigned long\tflags;\n\n\tep = container_of(_ep, struct goku_ep, ep);\n\tif (!_ep || !desc\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (ep == &dev->ep[0])\n\t\treturn -EINVAL;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\tif (ep->num != usb_endpoint_num(desc))\n\t\treturn -EINVAL;\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif ((readl(ep->reg_status) & EPxSTATUS_EP_MASK)\n\t\t\t!= EPxSTATUS_EP_INVALID)\n\t\treturn -EBUSY;\n\n\t \n\tmode = 0;\n\tmax = get_unaligned_le16(&desc->wMaxPacketSize);\n\tswitch (max) {\n\tcase 64:\n\t\tmode++;\n\t\tfallthrough;\n\tcase 32:\n\t\tmode++;\n\t\tfallthrough;\n\tcase 16:\n\t\tmode++;\n\t\tfallthrough;\n\tcase 8:\n\t\tmode <<= 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tmode |= 2 << 1;\t\t \n\n\t \n\tep->is_in = usb_endpoint_dir_in(desc);\n\tif (ep->is_in) {\n\t\tmode |= 1;\n\t\tep->dma = (use_dma != 0) && (ep->num == UDC_MSTRD_ENDPOINT);\n\t} else {\n\t\tep->dma = (use_dma == 2) && (ep->num == UDC_MSTWR_ENDPOINT);\n\t\tif (ep->dma)\n\t\t\tDBG(dev, \"%s out-dma hides short packets\\n\",\n\t\t\t\tep->ep.name);\n\t}\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\n\t \n\tif (ep->num < 3) {\n\t\tstruct goku_udc_regs __iomem\t*regs = ep->dev->regs;\n\t\tu32\t\t\t\ttmp;\n\n\t\t \n\t\ttmp = ((ep->dma || !ep->is_in)\n\t\t\t\t? 0x10\t \n\t\t\t\t: 0x11\t \n\t\t\t) << ep->num;\n\t\ttmp |= readl(&regs->EPxSingle);\n\t\twritel(tmp, &regs->EPxSingle);\n\n\t\ttmp = (ep->dma ? 0x10  : 0x11 ) << ep->num;\n\t\ttmp |= readl(&regs->EPxBCS);\n\t\twritel(tmp, &regs->EPxBCS);\n\t}\n\twritel(mode, ep->reg_mode);\n\tcommand(ep->dev->regs, COMMAND_RESET, ep->num);\n\tep->ep.maxpacket = max;\n\tep->stopped = 0;\n\tep->ep.desc = desc;\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\n\tDBG(dev, \"enable %s %s %s maxpacket %u\\n\", ep->ep.name,\n\t\tep->is_in ? \"IN\" : \"OUT\",\n\t\tep->dma ? \"dma\" : \"pio\",\n\t\tmax);\n\n\treturn 0;\n}\n\nstatic void ep_reset(struct goku_udc_regs __iomem *regs, struct goku_ep *ep)\n{\n\tstruct goku_udc\t\t*dev = ep->dev;\n\n\tif (regs) {\n\t\tcommand(regs, COMMAND_INVALID, ep->num);\n\t\tif (ep->num) {\n\t\t\tif (ep->num == UDC_MSTWR_ENDPOINT)\n\t\t\t\tdev->int_enable &= ~(INT_MSTWREND\n\t\t\t\t\t\t\t|INT_MSTWRTMOUT);\n\t\t\telse if (ep->num == UDC_MSTRD_ENDPOINT)\n\t\t\t\tdev->int_enable &= ~INT_MSTRDEND;\n\t\t\tdev->int_enable &= ~INT_EPxDATASET (ep->num);\n\t\t} else\n\t\t\tdev->int_enable &= ~INT_EP0;\n\t\twritel(dev->int_enable, &regs->int_enable);\n\t\treadl(&regs->int_enable);\n\t\tif (ep->num < 3) {\n\t\t\tstruct goku_udc_regs __iomem\t*r = ep->dev->regs;\n\t\t\tu32\t\t\t\ttmp;\n\n\t\t\ttmp = readl(&r->EPxSingle);\n\t\t\ttmp &= ~(0x11 << ep->num);\n\t\t\twritel(tmp, &r->EPxSingle);\n\n\t\t\ttmp = readl(&r->EPxBCS);\n\t\t\ttmp &= ~(0x11 << ep->num);\n\t\t\twritel(tmp, &r->EPxBCS);\n\t\t}\n\t\t \n\t\tif (ep->dma) {\n\t\t\tu32\tmaster;\n\n\t\t\tmaster = readl(&regs->dma_master) & MST_RW_BITS;\n\t\t\tif (ep->num == UDC_MSTWR_ENDPOINT) {\n\t\t\t\tmaster &= ~MST_W_BITS;\n\t\t\t\tmaster |= MST_WR_RESET;\n\t\t\t} else {\n\t\t\t\tmaster &= ~MST_R_BITS;\n\t\t\t\tmaster |= MST_RD_RESET;\n\t\t\t}\n\t\t\twritel(master, &regs->dma_master);\n\t\t}\n\t}\n\n\tusb_ep_set_maxpacket_limit(&ep->ep, MAX_FIFO_SIZE);\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\tep->irqs = 0;\n\tep->dma = 0;\n}\n\nstatic int goku_ep_disable(struct usb_ep *_ep)\n{\n\tstruct goku_ep\t*ep;\n\tstruct goku_udc\t*dev;\n\tunsigned long\tflags;\n\n\tep = container_of(_ep, struct goku_ep, ep);\n\tif (!_ep || !ep->ep.desc)\n\t\treturn -ENODEV;\n\tdev = ep->dev;\n\tif (dev->ep0state == EP0_SUSPEND)\n\t\treturn -EBUSY;\n\n\tVDBG(dev, \"disable %s\\n\", _ep->name);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tnuke(ep, -ESHUTDOWN);\n\tep_reset(dev->regs, ep);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic struct usb_request *\ngoku_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct goku_request\t*req;\n\n\tif (!_ep)\n\t\treturn NULL;\n\treq = kzalloc(sizeof *req, gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->req;\n}\n\nstatic void\ngoku_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct goku_request\t*req;\n\n\tif (!_ep || !_req)\n\t\treturn;\n\n\treq = container_of(_req, struct goku_request, req);\n\tWARN_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\n \n\nstatic void\ndone(struct goku_ep *ep, struct goku_request *req, int status)\n{\n\tstruct goku_udc\t\t*dev;\n\tunsigned\t\tstopped = ep->stopped;\n\n\tlist_del_init(&req->queue);\n\n\tif (likely(req->req.status == -EINPROGRESS))\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tdev = ep->dev;\n\n\tif (ep->dma)\n\t\tusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\n\n#ifndef USB_TRACE\n\tif (status && status != -ESHUTDOWN)\n#endif\n\t\tVDBG(dev, \"complete %s req %p stat %d len %u/%u\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\t \n\tep->stopped = 1;\n\tspin_unlock(&dev->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&dev->lock);\n\tep->stopped = stopped;\n}\n\n \n\nstatic inline int\nwrite_packet(u32 __iomem *fifo, u8 *buf, struct goku_request *req, unsigned max)\n{\n\tunsigned\tlength, count;\n\n\tlength = min(req->req.length - req->req.actual, max);\n\treq->req.actual += length;\n\n\tcount = length;\n\twhile (likely(count--))\n\t\twritel(*buf++, fifo);\n\treturn length;\n}\n\n\nstatic int write_fifo(struct goku_ep *ep, struct goku_request *req)\n{\n\tstruct goku_udc\t*dev = ep->dev;\n\tu32\t\ttmp;\n\tu8\t\t*buf;\n\tunsigned\tcount;\n\tint\t\tis_last;\n\n\ttmp = readl(&dev->regs->DataSet);\n\tbuf = req->req.buf + req->req.actual;\n\tprefetch(buf);\n\n\tdev = ep->dev;\n\tif (unlikely(ep->num == 0 && dev->ep0state != EP0_IN))\n\t\treturn -EL2HLT;\n\n\t \n\tif (unlikely((tmp & DATASET_A(ep->num)) != 0))\n\t\treturn 0;\n\n\t \n\tif (ep->num != 0)\n\t\twritel(~INT_EPxDATASET(ep->num), &dev->regs->int_status);\n\n\tcount = write_packet(ep->reg_fifo, buf, req, ep->ep.maxpacket);\n\n\t \n\tif (unlikely(count != ep->ep.maxpacket)) {\n\t\twritel(~(1<<ep->num), &dev->regs->EOP);\n\t\tif (ep->num == 0) {\n\t\t\tdev->ep[0].stopped = 1;\n\t\t\tdev->ep0state = EP0_STATUS;\n\t\t}\n\t\tis_last = 1;\n\t} else {\n\t\tif (likely(req->req.length != req->req.actual)\n\t\t\t\t|| req->req.zero)\n\t\t\tis_last = 0;\n\t\telse\n\t\t\tis_last = 1;\n\t}\n#if 0\t\t \n\n\tVDBG(dev, \"wrote %s %u bytes%s IN %u left %p\\n\",\n\t\tep->ep.name, count, is_last ? \"/last\" : \"\",\n\t\treq->req.length - req->req.actual, req);\n#endif\n\n\t \n\tif (is_last) {\n\t\tdone(ep, req, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int read_fifo(struct goku_ep *ep, struct goku_request *req)\n{\n\tstruct goku_udc_regs __iomem\t*regs;\n\tu32\t\t\t\tsize, set;\n\tu8\t\t\t\t*buf;\n\tunsigned\t\t\tbufferspace, is_short, dbuff;\n\n\tregs = ep->dev->regs;\ntop:\n\tbuf = req->req.buf + req->req.actual;\n\tprefetchw(buf);\n\n\tif (unlikely(ep->num == 0 && ep->dev->ep0state != EP0_OUT))\n\t\treturn -EL2HLT;\n\n\tdbuff = (ep->num == 1 || ep->num == 2);\n\tdo {\n\t\t \n\t\tif (ep->num != 0)\n\t\t\twritel(~INT_EPxDATASET(ep->num), &regs->int_status);\n\n\t\tset = readl(&regs->DataSet) & DATASET_AB(ep->num);\n\t\tsize = readl(&regs->EPxSizeLA[ep->num]);\n\t\tbufferspace = req->req.length - req->req.actual;\n\n\t\t \n\t\tif (likely(ep->num != 0 || bufferspace != 0)) {\n\t\t\tif (unlikely(set == 0))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (!(size & PACKET_ACTIVE))\n\t\t\t\tsize = readl(&regs->EPxSizeLB[ep->num]);\n\t\t\tif (!(size & PACKET_ACTIVE))\t \n\t\t\t\tbreak;\n\t\t\tsize &= DATASIZE;\t \n\n\t\t \n\t\t} else\n\t\t\tsize = 0;\n\n\t\t \n\t\treq->req.actual += size;\n\t\tis_short = (size < ep->ep.maxpacket);\n#ifdef USB_TRACE\n\t\tVDBG(ep->dev, \"read %s %u bytes%s OUT req %p %u/%u\\n\",\n\t\t\tep->ep.name, size, is_short ? \"/S\" : \"\",\n\t\t\treq, req->req.actual, req->req.length);\n#endif\n\t\twhile (likely(size-- != 0)) {\n\t\t\tu8\tbyte = (u8) readl(ep->reg_fifo);\n\n\t\t\tif (unlikely(bufferspace == 0)) {\n\t\t\t\t \n\t\t\t\tif (req->req.status != -EOVERFLOW)\n\t\t\t\t\tDBG(ep->dev, \"%s overflow %u\\n\",\n\t\t\t\t\t\tep->ep.name, size);\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t} else {\n\t\t\t\t*buf++ = byte;\n\t\t\t\tbufferspace--;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (unlikely(is_short || req->req.actual == req->req.length)) {\n\t\t\tif (unlikely(ep->num == 0)) {\n\t\t\t\t \n\t\t\t\tif (ep->dev->req_config)\n\t\t\t\t\twritel(ep->dev->configured\n\t\t\t\t\t\t\t? USBSTATE_CONFIGURED\n\t\t\t\t\t\t\t: 0,\n\t\t\t\t\t\t&regs->UsbState);\n\t\t\t\t \n\t\t\t\twritel(~(1<<0), &regs->EOP);\n\t\t\t\tep->stopped = 1;\n\t\t\t\tep->dev->ep0state = EP0_STATUS;\n\t\t\t}\n\t\t\tdone(ep, req, 0);\n\n\t\t\t \n\t\t\tif (dbuff && !list_empty(&ep->queue)) {\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\t\tstruct goku_request, queue);\n\t\t\t\tgoto top;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t} while (dbuff);\n\treturn 0;\n}\n\nstatic inline void\npio_irq_enable(struct goku_udc *dev,\n\t\tstruct goku_udc_regs __iomem *regs, int epnum)\n{\n\tdev->int_enable |= INT_EPxDATASET (epnum);\n\twritel(dev->int_enable, &regs->int_enable);\n\t \n}\n\nstatic inline void\npio_irq_disable(struct goku_udc *dev,\n\t\tstruct goku_udc_regs __iomem *regs, int epnum)\n{\n\tdev->int_enable &= ~INT_EPxDATASET (epnum);\n\twritel(dev->int_enable, &regs->int_enable);\n\t \n}\n\nstatic inline void\npio_advance(struct goku_ep *ep)\n{\n\tstruct goku_request\t*req;\n\n\tif (unlikely(list_empty (&ep->queue)))\n\t\treturn;\n\treq = list_entry(ep->queue.next, struct goku_request, queue);\n\t(ep->is_in ? write_fifo : read_fifo)(ep, req);\n}\n\n\n \n\n \nstatic int start_dma(struct goku_ep *ep, struct goku_request *req)\n{\n\tstruct goku_udc_regs __iomem\t*regs = ep->dev->regs;\n\tu32\t\t\t\tmaster;\n\tu32\t\t\t\tstart = req->req.dma;\n\tu32\t\t\t\tend = start + req->req.length - 1;\n\n\tmaster = readl(&regs->dma_master) & MST_RW_BITS;\n\n\t \n\tif (likely(ep->is_in)) {\n\t\tif (unlikely(master & MST_RD_ENA)) {\n\t\t\tDBG (ep->dev, \"start, IN active dma %03x!!\\n\",\n\t\t\t\tmaster);\n \n\t\t}\n\t\twritel(end, &regs->in_dma_end);\n\t\twritel(start, &regs->in_dma_start);\n\n\t\tmaster &= ~MST_R_BITS;\n\t\tif (unlikely(req->req.length == 0))\n\t\t\tmaster |= MST_RD_ENA | MST_RD_EOPB;\n\t\telse if ((req->req.length % ep->ep.maxpacket) != 0\n\t\t\t\t\t|| req->req.zero)\n\t\t\tmaster |= MST_RD_ENA | MST_EOPB_ENA;\n\t\telse\n\t\t\tmaster |= MST_RD_ENA | MST_EOPB_DIS;\n\n\t\tep->dev->int_enable |= INT_MSTRDEND;\n\n\t \n\t} else {\n\t\tif (unlikely(master & MST_WR_ENA)) {\n\t\t\tDBG (ep->dev, \"start, OUT active dma %03x!!\\n\",\n\t\t\t\tmaster);\n \n\t\t}\n\t\twritel(end, &regs->out_dma_end);\n\t\twritel(start, &regs->out_dma_start);\n\n\t\tmaster &= ~MST_W_BITS;\n\t\tmaster |= MST_WR_ENA | MST_TIMEOUT_DIS;\n\n\t\tep->dev->int_enable |= INT_MSTWREND|INT_MSTWRTMOUT;\n\t}\n\n\twritel(master, &regs->dma_master);\n\twritel(ep->dev->int_enable, &regs->int_enable);\n\treturn 0;\n}\n\nstatic void dma_advance(struct goku_udc *dev, struct goku_ep *ep)\n{\n\tstruct goku_request\t\t*req;\n\tstruct goku_udc_regs __iomem\t*regs = ep->dev->regs;\n\tu32\t\t\t\tmaster;\n\n\tmaster = readl(&regs->dma_master);\n\n\tif (unlikely(list_empty(&ep->queue))) {\nstop:\n\t\tif (ep->is_in)\n\t\t\tdev->int_enable &= ~INT_MSTRDEND;\n\t\telse\n\t\t\tdev->int_enable &= ~(INT_MSTWREND|INT_MSTWRTMOUT);\n\t\twritel(dev->int_enable, &regs->int_enable);\n\t\treturn;\n\t}\n\treq = list_entry(ep->queue.next, struct goku_request, queue);\n\n\t \n\tif (likely(ep->is_in)) {\n\t\tif (unlikely(master & MST_RD_ENA))\n\t\t\treturn;\n\t\treq->req.actual = readl(&regs->in_dma_current);\n\t} else {\n\t\tif (unlikely(master & MST_WR_ENA))\n\t\t\treturn;\n\n\t\t \n\t\treq->req.actual = readl(&regs->out_dma_current);\n\t}\n\treq->req.actual -= req->req.dma;\n\treq->req.actual++;\n\n#ifdef USB_TRACE\n\tVDBG(dev, \"done %s %s dma, %u/%u bytes, req %p\\n\",\n\t\tep->ep.name, ep->is_in ? \"IN\" : \"OUT\",\n\t\treq->req.actual, req->req.length, req);\n#endif\n\tdone(ep, req, 0);\n\tif (list_empty(&ep->queue))\n\t\tgoto stop;\n\treq = list_entry(ep->queue.next, struct goku_request, queue);\n\t(void) start_dma(ep, req);\n}\n\nstatic void abort_dma(struct goku_ep *ep, int status)\n{\n\tstruct goku_udc_regs __iomem\t*regs = ep->dev->regs;\n\tstruct goku_request\t\t*req;\n\tu32\t\t\t\tcurr, master;\n\n\t \n\tcommand(regs, COMMAND_FIFO_DISABLE, ep->num);\n\treq = list_entry(ep->queue.next, struct goku_request, queue);\n\tmaster = readl(&regs->dma_master) & MST_RW_BITS;\n\n\t \n\tif (ep->is_in) {\n\t\tif (unlikely((readl(&regs->dma_master) & MST_RD_ENA) == 0))\n\t\t\tgoto finished;\n\t\tcurr = readl(&regs->in_dma_current);\n\n\t\twritel(curr, &regs->in_dma_end);\n\t\twritel(curr, &regs->in_dma_start);\n\n\t\tmaster &= ~MST_R_BITS;\n\t\tmaster |= MST_RD_RESET;\n\t\twritel(master, &regs->dma_master);\n\n\t\tif (readl(&regs->dma_master) & MST_RD_ENA)\n\t\t\tDBG(ep->dev, \"IN dma active after reset!\\n\");\n\n\t} else {\n\t\tif (unlikely((readl(&regs->dma_master) & MST_WR_ENA) == 0))\n\t\t\tgoto finished;\n\t\tcurr = readl(&regs->out_dma_current);\n\n\t\twritel(curr, &regs->out_dma_end);\n\t\twritel(curr, &regs->out_dma_start);\n\n\t\tmaster &= ~MST_W_BITS;\n\t\tmaster |= MST_WR_RESET;\n\t\twritel(master, &regs->dma_master);\n\n\t\tif (readl(&regs->dma_master) & MST_WR_ENA)\n\t\t\tDBG(ep->dev, \"OUT dma active after reset!\\n\");\n\t}\n\treq->req.actual = (curr - req->req.dma) + 1;\n\treq->req.status = status;\n\n\tVDBG(ep->dev, \"%s %s %s %d/%d\\n\", __func__, ep->ep.name,\n\t\tep->is_in ? \"IN\" : \"OUT\",\n\t\treq->req.actual, req->req.length);\n\n\tcommand(regs, COMMAND_FIFO_ENABLE, ep->num);\n\n\treturn;\n\nfinished:\n\t \n\tcommand(regs, COMMAND_FIFO_ENABLE, ep->num);\n\treq->req.actual = req->req.length;\n\treq->req.status = 0;\n}\n\n \n\nstatic int\ngoku_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct goku_request\t*req;\n\tstruct goku_ep\t\t*ep;\n\tstruct goku_udc\t\t*dev;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus;\n\n\t \n\treq = container_of(_req, struct goku_request, req);\n\tif (unlikely(!_req || !_req->complete\n\t\t\t|| !_req->buf || !list_empty(&req->queue)))\n\t\treturn -EINVAL;\n\tep = container_of(_ep, struct goku_ep, ep);\n\tif (unlikely(!_ep || (!ep->ep.desc && ep->num != 0)))\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (dev->ep0state == EP0_SUSPEND)\n\t\treturn -EBUSY;\n\n\t \n\tif (ep->dma) {\n\t\tstatus = usb_gadget_map_request(&dev->gadget, &req->req,\n\t\t\t\tep->is_in);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n#ifdef USB_TRACE\n\tVDBG(dev, \"%s queue req %p, len %u buf %p\\n\",\n\t\t\t_ep->name, _req, _req->length, _req->buf);\n#endif\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\t \n\tif (unlikely(ep->num == 0 && ep->is_in))\n\t\t_req->zero = 1;\n\n\t \n\tstatus = 0;\n\tif (list_empty(&ep->queue) && likely(!ep->stopped)) {\n\t\t \n\t\tif (ep->dma)\n\t\t\tstatus = start_dma(ep, req);\n\t\telse\n\t\t\tstatus = (ep->is_in ? write_fifo : read_fifo)(ep, req);\n\n\t\tif (unlikely(status != 0)) {\n\t\t\tif (status > 0)\n\t\t\t\tstatus = 0;\n\t\t\treq = NULL;\n\t\t}\n\n\t}  \n\n\tif (likely(req != NULL))\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tif (likely(!list_empty(&ep->queue))\n\t\t\t&& likely(ep->num != 0)\n\t\t\t&& !ep->dma\n\t\t\t&& !(dev->int_enable & INT_EPxDATASET (ep->num)))\n\t\tpio_irq_enable(dev, dev->regs, ep->num);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t \n\treturn status;\n}\n\n \nstatic void nuke(struct goku_ep *ep, int status)\n{\n\tstruct goku_request\t*req;\n\n\tep->stopped = 1;\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\tif (ep->dma)\n\t\tabort_dma(ep, status);\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct goku_request, queue);\n\t\tdone(ep, req, status);\n\t}\n}\n\n \nstatic int goku_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct goku_request\t*req = NULL, *iter;\n\tstruct goku_ep\t\t*ep;\n\tstruct goku_udc\t\t*dev;\n\tunsigned long\t\tflags;\n\n\tep = container_of(_ep, struct goku_ep, ep);\n\tif (!_ep || !_req || (!ep->ep.desc && ep->num != 0))\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (!dev->driver)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (dev->ep0state == EP0_SUSPEND)\n\t\treturn -EBUSY;\n\n\tVDBG(dev, \"%s %s %s %s %p\\n\", __func__, _ep->name,\n\t\tep->is_in ? \"IN\" : \"OUT\",\n\t\tep->dma ? \"dma\" : \"pio\",\n\t\t_req);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore (&dev->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ep->dma && ep->queue.next == &req->queue && !ep->stopped) {\n\t\tabort_dma(ep, -ECONNRESET);\n\t\tdone(ep, req, -ECONNRESET);\n\t\tdma_advance(dev, ep);\n\t} else if (!list_empty(&req->queue))\n\t\tdone(ep, req, -ECONNRESET);\n\telse\n\t\treq = NULL;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn req ? 0 : -EOPNOTSUPP;\n}\n\n \n\nstatic void goku_clear_halt(struct goku_ep *ep)\n{\n\t \n\tVDBG(ep->dev, \"%s clear halt\\n\", ep->ep.name);\n\tcommand(ep->dev->regs, COMMAND_SETDATA0, ep->num);\n\tcommand(ep->dev->regs, COMMAND_STALL_CLEAR, ep->num);\n\tif (ep->stopped) {\n\t\tep->stopped = 0;\n\t\tif (ep->dma) {\n\t\t\tstruct goku_request\t*req;\n\n\t\t\tif (list_empty(&ep->queue))\n\t\t\t\treturn;\n\t\t\treq = list_entry(ep->queue.next, struct goku_request,\n\t\t\t\t\t\tqueue);\n\t\t\t(void) start_dma(ep, req);\n\t\t} else\n\t\t\tpio_advance(ep);\n\t}\n}\n\nstatic int goku_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct goku_ep\t*ep;\n\tunsigned long\tflags;\n\tint\t\tretval = 0;\n\n\tif (!_ep)\n\t\treturn -ENODEV;\n\tep = container_of (_ep, struct goku_ep, ep);\n\n\tif (ep->num == 0) {\n\t\tif (value) {\n\t\t\tep->dev->ep0state = EP0_STALL;\n\t\t\tep->dev->ep[0].stopped = 1;\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t \n\t} else if (!ep->ep.desc) {\n\t\tDBG(ep->dev, \"%s %s inactive?\\n\", __func__, ep->ep.name);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\tretval = -EAGAIN;\n\telse if (ep->is_in && value\n\t\t\t \n\t\t\t&& (readl(&ep->dev->regs->DataSet)\n\t\t\t\t\t& DATASET_AB(ep->num)))\n\t\tretval = -EAGAIN;\n\telse if (!value)\n\t\tgoku_clear_halt(ep);\n\telse {\n\t\tep->stopped = 1;\n\t\tVDBG(ep->dev, \"%s set halt\\n\", ep->ep.name);\n\t\tcommand(ep->dev->regs, COMMAND_STALL, ep->num);\n\t\treadl(ep->reg_status);\n\t}\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn retval;\n}\n\nstatic int goku_fifo_status(struct usb_ep *_ep)\n{\n\tstruct goku_ep\t\t\t*ep;\n\tstruct goku_udc_regs __iomem\t*regs;\n\tu32\t\t\t\tsize;\n\n\tif (!_ep)\n\t\treturn -ENODEV;\n\tep = container_of(_ep, struct goku_ep, ep);\n\n\t \n\tif (ep->is_in)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tregs = ep->dev->regs;\n\tsize = readl(&regs->EPxSizeLA[ep->num]) & DATASIZE;\n\tsize += readl(&regs->EPxSizeLB[ep->num]) & DATASIZE;\n\tVDBG(ep->dev, \"%s %s %u\\n\", __func__, ep->ep.name, size);\n\treturn size;\n}\n\nstatic void goku_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct goku_ep\t\t\t*ep;\n\tstruct goku_udc_regs __iomem\t*regs;\n\tu32\t\t\t\tsize;\n\n\tif (!_ep)\n\t\treturn;\n\tep = container_of(_ep, struct goku_ep, ep);\n\tVDBG(ep->dev, \"%s %s\\n\", __func__, ep->ep.name);\n\n\t \n\tif (!ep->ep.desc && ep->num != 0) {\n\t\tDBG(ep->dev, \"%s %s inactive?\\n\", __func__, ep->ep.name);\n\t\treturn;\n\t}\n\n\tregs = ep->dev->regs;\n\tsize = readl(&regs->EPxSizeLA[ep->num]);\n\tsize &= DATASIZE;\n\n\t \n\tif (size)\n\t\tcommand(regs, COMMAND_FIFO_CLEAR, ep->num);\n}\n\nstatic const struct usb_ep_ops goku_ep_ops = {\n\t.enable\t\t= goku_ep_enable,\n\t.disable\t= goku_ep_disable,\n\n\t.alloc_request\t= goku_alloc_request,\n\t.free_request\t= goku_free_request,\n\n\t.queue\t\t= goku_queue,\n\t.dequeue\t= goku_dequeue,\n\n\t.set_halt\t= goku_set_halt,\n\t.fifo_status\t= goku_fifo_status,\n\t.fifo_flush\t= goku_fifo_flush,\n};\n\n \n\nstatic int goku_get_frame(struct usb_gadget *_gadget)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic struct usb_ep *goku_match_ep(struct usb_gadget *g,\n\t\tstruct usb_endpoint_descriptor *desc,\n\t\tstruct usb_ss_ep_comp_descriptor *ep_comp)\n{\n\tstruct goku_udc\t*dev = to_goku_udc(g);\n\tstruct usb_ep *ep;\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tep = &dev->ep[3].ep;\n\t\tif (usb_gadget_ep_match_desc(g, ep, desc, ep_comp))\n\t\t\treturn ep;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (usb_endpoint_dir_in(desc)) {\n\t\t\t \n\t\t\tep = &dev->ep[2].ep;\n\t\t\tif (usb_gadget_ep_match_desc(g, ep, desc, ep_comp))\n\t\t\t\treturn ep;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t  ;\n\t}\n\n\treturn NULL;\n}\n\nstatic int goku_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int goku_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops goku_ops = {\n\t.get_frame\t= goku_get_frame,\n\t.udc_start\t= goku_udc_start,\n\t.udc_stop\t= goku_udc_stop,\n\t.match_ep\t= goku_match_ep,\n\t \n\t \n};\n\n \n\nstatic inline const char *dmastr(void)\n{\n\tif (use_dma == 0)\n\t\treturn \"(dma disabled)\";\n\telse if (use_dma == 2)\n\t\treturn \"(dma IN and OUT)\";\n\telse\n\t\treturn \"(dma IN)\";\n}\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic const char proc_node_name [] = \"driver/udc\";\n\n#define FOURBITS \"%s%s%s%s\"\n#define EIGHTBITS FOURBITS FOURBITS\n\nstatic void dump_intmask(struct seq_file *m, const char *label, u32 mask)\n{\n\t \n\tseq_printf(m, \"%s %05X =\" FOURBITS EIGHTBITS EIGHTBITS \"\\n\",\n\t\t   label, mask,\n\t\t   (mask & INT_PWRDETECT) ? \" power\" : \"\",\n\t\t   (mask & INT_SYSERROR) ? \" sys\" : \"\",\n\t\t   (mask & INT_MSTRDEND) ? \" in-dma\" : \"\",\n\t\t   (mask & INT_MSTWRTMOUT) ? \" wrtmo\" : \"\",\n\n\t\t   (mask & INT_MSTWREND) ? \" out-dma\" : \"\",\n\t\t   (mask & INT_MSTWRSET) ? \" wrset\" : \"\",\n\t\t   (mask & INT_ERR) ? \" err\" : \"\",\n\t\t   (mask & INT_SOF) ? \" sof\" : \"\",\n\n\t\t   (mask & INT_EP3NAK) ? \" ep3nak\" : \"\",\n\t\t   (mask & INT_EP2NAK) ? \" ep2nak\" : \"\",\n\t\t   (mask & INT_EP1NAK) ? \" ep1nak\" : \"\",\n\t\t   (mask & INT_EP3DATASET) ? \" ep3\" : \"\",\n\n\t\t   (mask & INT_EP2DATASET) ? \" ep2\" : \"\",\n\t\t   (mask & INT_EP1DATASET) ? \" ep1\" : \"\",\n\t\t   (mask & INT_STATUSNAK) ? \" ep0snak\" : \"\",\n\t\t   (mask & INT_STATUS) ? \" ep0status\" : \"\",\n\n\t\t   (mask & INT_SETUP) ? \" setup\" : \"\",\n\t\t   (mask & INT_ENDPOINT0) ? \" ep0\" : \"\",\n\t\t   (mask & INT_USBRESET) ? \" reset\" : \"\",\n\t\t   (mask & INT_SUSPEND) ? \" suspend\" : \"\");\n}\n\nstatic const char *udc_ep_state(enum ep0state state)\n{\n\tswitch (state) {\n\tcase EP0_DISCONNECT:\n\t\treturn \"ep0_disconnect\";\n\tcase EP0_IDLE:\n\t\treturn \"ep0_idle\";\n\tcase EP0_IN:\n\t\treturn \"ep0_in\";\n\tcase EP0_OUT:\n\t\treturn \"ep0_out\";\n\tcase EP0_STATUS:\n\t\treturn \"ep0_status\";\n\tcase EP0_STALL:\n\t\treturn \"ep0_stall\";\n\tcase EP0_SUSPEND:\n\t\treturn \"ep0_suspend\";\n\t}\n\n\treturn \"ep0_?\";\n}\n\nstatic const char *udc_ep_status(u32 status)\n{\n\tswitch (status & EPxSTATUS_EP_MASK) {\n\tcase EPxSTATUS_EP_READY:\n\t\treturn \"ready\";\n\tcase EPxSTATUS_EP_DATAIN:\n\t\treturn \"packet\";\n\tcase EPxSTATUS_EP_FULL:\n\t\treturn \"full\";\n\tcase EPxSTATUS_EP_TX_ERR:\t \n\t\treturn \"tx_err\";\n\tcase EPxSTATUS_EP_RX_ERR:\n\t\treturn \"rx_err\";\n\tcase EPxSTATUS_EP_BUSY:\t\t \n\t\treturn \"busy\";\n\tcase EPxSTATUS_EP_STALL:\n\t\treturn \"stall\";\n\tcase EPxSTATUS_EP_INVALID:\t \n\t\treturn \"invalid\";\n\t}\n\n\treturn \"?\";\n}\n\nstatic int udc_proc_read(struct seq_file *m, void *v)\n{\n\tstruct goku_udc\t\t\t*dev = m->private;\n\tstruct goku_udc_regs __iomem\t*regs = dev->regs;\n\tunsigned long\t\t\tflags;\n\tint\t\t\t\ti, is_usb_connected;\n\tu32\t\t\t\ttmp;\n\n\tlocal_irq_save(flags);\n\n\t \n\ttmp = readl(&regs->power_detect);\n\tis_usb_connected = tmp & PW_DETECT;\n\tseq_printf(m,\n\t\t   \"%s - %s\\n\"\n\t\t   \"%s version: %s %s\\n\"\n\t\t   \"Gadget driver: %s\\n\"\n\t\t   \"Host %s, %s\\n\"\n\t\t   \"\\n\",\n\t\t   pci_name(dev->pdev), driver_desc,\n\t\t   driver_name, DRIVER_VERSION, dmastr(),\n\t\t   dev->driver ? dev->driver->driver.name : \"(none)\",\n\t\t   is_usb_connected\n\t\t\t   ? ((tmp & PW_PULLUP) ? \"full speed\" : \"powered\")\n\t\t\t   : \"disconnected\",\n\t\t   udc_ep_state(dev->ep0state));\n\n\tdump_intmask(m, \"int_status\", readl(&regs->int_status));\n\tdump_intmask(m, \"int_enable\", readl(&regs->int_enable));\n\n\tif (!is_usb_connected || !dev->driver || (tmp & PW_PULLUP) == 0)\n\t\tgoto done;\n\n\t \n\tseq_printf(m, \"\\nirqs %lu\\ndataset %02x single.bcs %02x.%02x state %x addr %u\\n\",\n\t\t   dev->irqs, readl(&regs->DataSet),\n\t\t   readl(&regs->EPxSingle), readl(&regs->EPxBCS),\n\t\t   readl(&regs->UsbState),\n\t\t   readl(&regs->address));\n\tif (seq_has_overflowed(m))\n\t\tgoto done;\n\n\ttmp = readl(&regs->dma_master);\n\tseq_printf(m, \"dma %03X =\" EIGHTBITS \"%s %s\\n\",\n\t\t   tmp,\n\t\t   (tmp & MST_EOPB_DIS) ? \" eopb-\" : \"\",\n\t\t   (tmp & MST_EOPB_ENA) ? \" eopb+\" : \"\",\n\t\t   (tmp & MST_TIMEOUT_DIS) ? \" tmo-\" : \"\",\n\t\t   (tmp & MST_TIMEOUT_ENA) ? \" tmo+\" : \"\",\n\n\t\t   (tmp & MST_RD_EOPB) ? \" eopb\" : \"\",\n\t\t   (tmp & MST_RD_RESET) ? \" in_reset\" : \"\",\n\t\t   (tmp & MST_WR_RESET) ? \" out_reset\" : \"\",\n\t\t   (tmp & MST_RD_ENA) ? \" IN\" : \"\",\n\n\t\t   (tmp & MST_WR_ENA) ? \" OUT\" : \"\",\n\t\t   (tmp & MST_CONNECTION) ? \"ep1in/ep2out\" : \"ep1out/ep2in\");\n\tif (seq_has_overflowed(m))\n\t\tgoto done;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tstruct goku_ep\t\t*ep = &dev->ep [i];\n\t\tstruct goku_request\t*req;\n\n\t\tif (i && !ep->ep.desc)\n\t\t\tcontinue;\n\n\t\ttmp = readl(ep->reg_status);\n\t\tseq_printf(m, \"%s %s max %u %s, irqs %lu, status %02x (%s) \" FOURBITS \"\\n\",\n\t\t\t   ep->ep.name,\n\t\t\t   ep->is_in ? \"in\" : \"out\",\n\t\t\t   ep->ep.maxpacket,\n\t\t\t   ep->dma ? \"dma\" : \"pio\",\n\t\t\t   ep->irqs,\n\t\t\t   tmp, udc_ep_status(tmp),\n\t\t\t   (tmp & EPxSTATUS_TOGGLE) ? \"data1\" : \"data0\",\n\t\t\t   (tmp & EPxSTATUS_SUSPEND) ? \" suspend\" : \"\",\n\t\t\t   (tmp & EPxSTATUS_FIFO_DISABLE) ? \" disable\" : \"\",\n\t\t\t   (tmp & EPxSTATUS_STAGE_ERROR) ? \" ep0stat\" : \"\");\n\t\tif (seq_has_overflowed(m))\n\t\t\tgoto done;\n\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tseq_puts(m, \"\\t(nothing queued)\\n\");\n\t\t\tif (seq_has_overflowed(m))\n\t\t\t\tgoto done;\n\t\t\tcontinue;\n\t\t}\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tif (ep->dma && req->queue.prev == &ep->queue) {\n\t\t\t\tif (i == UDC_MSTRD_ENDPOINT)\n\t\t\t\t\ttmp = readl(&regs->in_dma_current);\n\t\t\t\telse\n\t\t\t\t\ttmp = readl(&regs->out_dma_current);\n\t\t\t\ttmp -= req->req.dma;\n\t\t\t\ttmp++;\n\t\t\t} else\n\t\t\t\ttmp = req->req.actual;\n\n\t\t\tseq_printf(m, \"\\treq %p len %u/%u buf %p\\n\",\n\t\t\t\t   &req->req, tmp, req->req.length,\n\t\t\t\t   req->req.buf);\n\t\t\tif (seq_has_overflowed(m))\n\t\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n#endif\t \n\n \n\nstatic void udc_reinit (struct goku_udc *dev)\n{\n\tstatic char *names [] = { \"ep0\", \"ep1-bulk\", \"ep2-bulk\", \"ep3-bulk\" };\n\n\tunsigned i;\n\n\tINIT_LIST_HEAD (&dev->gadget.ep_list);\n\tdev->gadget.ep0 = &dev->ep [0].ep;\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tdev->ep0state = EP0_DISCONNECT;\n\tdev->irqs = 0;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct goku_ep\t*ep = &dev->ep[i];\n\n\t\tep->num = i;\n\t\tep->ep.name = names[i];\n\t\tep->reg_fifo = &dev->regs->ep_fifo [i];\n\t\tep->reg_status = &dev->regs->ep_status [i];\n\t\tep->reg_mode = &dev->regs->ep_mode[i];\n\n\t\tep->ep.ops = &goku_ep_ops;\n\t\tlist_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);\n\t\tep->dev = dev;\n\t\tINIT_LIST_HEAD (&ep->queue);\n\n\t\tep_reset(NULL, ep);\n\n\t\tif (i == 0)\n\t\t\tep->ep.caps.type_control = true;\n\t\telse\n\t\t\tep->ep.caps.type_bulk = true;\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\n\tdev->ep[0].reg_mode = NULL;\n\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep, MAX_EP0_SIZE);\n\tlist_del_init (&dev->ep[0].ep.ep_list);\n}\n\nstatic void udc_reset(struct goku_udc *dev)\n{\n\tstruct goku_udc_regs __iomem\t*regs = dev->regs;\n\n\twritel(0, &regs->power_detect);\n\twritel(0, &regs->int_enable);\n\treadl(&regs->int_enable);\n\tdev->int_enable = 0;\n\n\t \n\tudelay(250);\n\twritel(PW_RESETB, &regs->power_detect);\n\treadl(&regs->int_enable);\n}\n\nstatic void ep0_start(struct goku_udc *dev)\n{\n\tstruct goku_udc_regs __iomem\t*regs = dev->regs;\n\tunsigned\t\t\ti;\n\n\tVDBG(dev, \"%s\\n\", __func__);\n\n\tudc_reset(dev);\n\tudc_reinit (dev);\n\t\n\n\t \n\twritel(   G_REQMODE_SET_INTF | G_REQMODE_GET_INTF\n\t\t| G_REQMODE_SET_CONF | G_REQMODE_GET_CONF\n\t\t| G_REQMODE_GET_DESC\n\t\t| G_REQMODE_CLEAR_FEAT\n\t\t, &regs->reqmode);\n\n\tfor (i = 0; i < 4; i++)\n\t\tdev->ep[i].irqs = 0;\n\n\t \n\tfor (i = 0; i < DESC_LEN; i++)\n\t\twritel(0, &regs->descriptors[i]);\n\twritel(0, &regs->UsbReady);\n\n\t \n\twritel(PW_RESETB | PW_PULLUP, &regs->power_detect);\n\tdev->int_enable = INT_DEVWIDE | INT_EP0;\n\twritel(dev->int_enable, &dev->regs->int_enable);\n\treadl(&regs->int_enable);\n\tdev->gadget.speed = USB_SPEED_FULL;\n\tdev->ep0state = EP0_IDLE;\n}\n\nstatic void udc_enable(struct goku_udc *dev)\n{\n\t \n\tif (readl(&dev->regs->power_detect) & PW_DETECT)\n\t\tep0_start(dev);\n\telse {\n\t\tDBG(dev, \"%s\\n\", __func__);\n\t\tdev->int_enable = INT_PWRDETECT;\n\t\twritel(dev->int_enable, &dev->regs->int_enable);\n\t}\n}\n\n \n\n \n\n \nstatic int goku_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct goku_udc\t*dev = to_goku_udc(g);\n\n\t \n\tdev->driver = driver;\n\n\t \n\tudc_enable(dev);\n\n\treturn 0;\n}\n\nstatic void stop_activity(struct goku_udc *dev)\n{\n\tunsigned\ti;\n\n\tDBG (dev, \"%s\\n\", __func__);\n\n\t \n\tudc_reset (dev);\n\tfor (i = 0; i < 4; i++)\n\t\tnuke(&dev->ep [i], -ESHUTDOWN);\n\n\tif (dev->driver)\n\t\tudc_enable(dev);\n}\n\nstatic int goku_udc_stop(struct usb_gadget *g)\n{\n\tstruct goku_udc\t*dev = to_goku_udc(g);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->driver = NULL;\n\tstop_activity(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic void ep0_setup(struct goku_udc *dev)\n{\n\tstruct goku_udc_regs __iomem\t*regs = dev->regs;\n\tstruct usb_ctrlrequest\t\tctrl;\n\tint\t\t\t\ttmp;\n\n\t \n\tctrl.bRequestType = readl(&regs->bRequestType);\n\tctrl.bRequest = readl(&regs->bRequest);\n\tctrl.wValue  = cpu_to_le16((readl(&regs->wValueH)  << 8)\n\t\t\t\t\t| readl(&regs->wValueL));\n\tctrl.wIndex  = cpu_to_le16((readl(&regs->wIndexH)  << 8)\n\t\t\t\t\t| readl(&regs->wIndexL));\n\tctrl.wLength = cpu_to_le16((readl(&regs->wLengthH) << 8)\n\t\t\t\t\t| readl(&regs->wLengthL));\n\twritel(0, &regs->SetupRecv);\n\n\tnuke(&dev->ep[0], 0);\n\tdev->ep[0].stopped = 0;\n\tif (likely(ctrl.bRequestType & USB_DIR_IN)) {\n\t\tdev->ep[0].is_in = 1;\n\t\tdev->ep0state = EP0_IN;\n\t\t \n\t\twritel(ICONTROL_STATUSNAK, &dev->regs->IntControl);\n\t} else {\n\t\tdev->ep[0].is_in = 0;\n\t\tdev->ep0state = EP0_OUT;\n\n\t\t \n\t\tswitch (ctrl.bRequest) {\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tswitch (ctrl.bRequestType) {\n\t\t\tcase USB_RECIP_ENDPOINT:\n\t\t\t\ttmp = le16_to_cpu(ctrl.wIndex) & 0x0f;\n\t\t\t\t \n\t\t\t\tif (tmp > 3 ||\n\t\t\t\t    (!dev->ep[tmp].ep.desc && tmp != 0))\n\t\t\t\t\tgoto stall;\n\t\t\t\tif (ctrl.wIndex & cpu_to_le16(\n\t\t\t\t\t\tUSB_DIR_IN)) {\n\t\t\t\t\tif (!dev->ep[tmp].is_in)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t} else {\n\t\t\t\t\tif (dev->ep[tmp].is_in)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t}\n\t\t\t\tif (ctrl.wValue != cpu_to_le16(\n\t\t\t\t\t\tUSB_ENDPOINT_HALT))\n\t\t\t\t\tgoto stall;\n\t\t\t\tif (tmp)\n\t\t\t\t\tgoku_clear_halt(&dev->ep[tmp]);\nsucceed:\n\t\t\t\t \n\t\t\t\twritel(~(1<<0), &regs->EOP);\n\t\t\t\tdev->ep[0].stopped = 1;\n\t\t\t\tdev->ep0state = EP0_STATUS;\n\t\t\t\treturn;\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\t \n\t\t\t\tif (ctrl.wValue != cpu_to_le16(1))\n\t\t\t\t\tgoto stall;\n\t\t\t\tVDBG(dev, \"clear dev remote wakeup\\n\");\n\t\t\t\tgoto succeed;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tgoto stall;\n\t\t\tdefault:\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef USB_TRACE\n\tVDBG(dev, \"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\tctrl.bRequestType, ctrl.bRequest,\n\t\tle16_to_cpu(ctrl.wValue), le16_to_cpu(ctrl.wIndex),\n\t\tle16_to_cpu(ctrl.wLength));\n#endif\n\n\t \n\tdev->req_config = (ctrl.bRequest == USB_REQ_SET_CONFIGURATION\n\t\t\t\t&& ctrl.bRequestType == USB_RECIP_DEVICE);\n\tif (unlikely(dev->req_config))\n\t\tdev->configured = (ctrl.wValue != cpu_to_le16(0));\n\n\t \n\tspin_unlock (&dev->lock);\n\ttmp = dev->driver->setup(&dev->gadget, &ctrl);\n\tspin_lock (&dev->lock);\n\tif (unlikely(tmp < 0)) {\nstall:\n#ifdef USB_TRACE\n\t\tVDBG(dev, \"req %02x.%02x protocol STALL; err %d\\n\",\n\t\t\t\tctrl.bRequestType, ctrl.bRequest, tmp);\n#endif\n\t\tcommand(regs, COMMAND_STALL, 0);\n\t\tdev->ep[0].stopped = 1;\n\t\tdev->ep0state = EP0_STALL;\n\t}\n\n\t \n}\n\n#define ACK(irqbit) { \\\n\t\tstat &= ~irqbit; \\\n\t\twritel(~irqbit, &regs->int_status); \\\n\t\thandled = 1; \\\n\t\t}\n\nstatic irqreturn_t goku_irq(int irq, void *_dev)\n{\n\tstruct goku_udc\t\t\t*dev = _dev;\n\tstruct goku_udc_regs __iomem\t*regs = dev->regs;\n\tstruct goku_ep\t\t\t*ep;\n\tu32\t\t\t\tstat, handled = 0;\n\tunsigned\t\t\ti, rescans = 5;\n\n\tspin_lock(&dev->lock);\n\nrescan:\n\tstat = readl(&regs->int_status) & dev->int_enable;\n        if (!stat)\n\t\tgoto done;\n\tdev->irqs++;\n\n\t \n\tif (unlikely(stat & INT_DEVWIDE)) {\n\t\tif (stat & INT_SYSERROR) {\n\t\t\tERROR(dev, \"system error\\n\");\n\t\t\tstop_activity(dev);\n\t\t\tstat = 0;\n\t\t\thandled = 1;\n\t\t\t\n\t\t\tdev->driver = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (stat & INT_PWRDETECT) {\n\t\t\twritel(~stat, &regs->int_status);\n\t\t\tif (readl(&dev->regs->power_detect) & PW_DETECT) {\n\t\t\t\tVDBG(dev, \"connect\\n\");\n\t\t\t\tep0_start(dev);\n\t\t\t} else {\n\t\t\t\tDBG(dev, \"disconnect\\n\");\n\t\t\t\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\t\t\t\tstop_activity(dev);\n\t\t\t\tdev->ep0state = EP0_DISCONNECT;\n\t\t\t\tdev->int_enable = INT_DEVWIDE;\n\t\t\t\twritel(dev->int_enable, &dev->regs->int_enable);\n\t\t\t}\n\t\t\tstat = 0;\n\t\t\thandled = 1;\n\t\t\tgoto done;\n\t\t}\n\t\tif (stat & INT_SUSPEND) {\n\t\t\tACK(INT_SUSPEND);\n\t\t\tif (readl(&regs->ep_status[0]) & EPxSTATUS_SUSPEND) {\n\t\t\t\tswitch (dev->ep0state) {\n\t\t\t\tcase EP0_DISCONNECT:\n\t\t\t\tcase EP0_SUSPEND:\n\t\t\t\t\tgoto pm_next;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tDBG(dev, \"USB suspend\\n\");\n\t\t\t\tdev->ep0state = EP0_SUSPEND;\n\t\t\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t\t\t&& dev->driver\n\t\t\t\t\t\t&& dev->driver->suspend) {\n\t\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\t\t\tspin_lock(&dev->lock);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dev->ep0state != EP0_SUSPEND) {\n\t\t\t\t\tDBG(dev, \"bogus USB resume %d\\n\",\n\t\t\t\t\t\tdev->ep0state);\n\t\t\t\t\tgoto pm_next;\n\t\t\t\t}\n\t\t\t\tDBG(dev, \"USB resume\\n\");\n\t\t\t\tdev->ep0state = EP0_IDLE;\n\t\t\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t\t\t&& dev->driver\n\t\t\t\t\t\t&& dev->driver->resume) {\n\t\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\t\tdev->driver->resume(&dev->gadget);\n\t\t\t\t\tspin_lock(&dev->lock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\npm_next:\n\t\tif (stat & INT_USBRESET) {\t\t \n\t\t\tACK(INT_USBRESET);\n\t\t\tINFO(dev, \"USB reset done, gadget %s\\n\",\n\t\t\t\tdev->driver->driver.name);\n\t\t}\n\t\t\n\t}\n\n\t \n\tif (stat & INT_SETUP) {\n\t\tACK(INT_SETUP);\n\t\tdev->ep[0].irqs++;\n\t\tep0_setup(dev);\n\t}\n        if (stat & INT_STATUSNAK) {\n\t\tACK(INT_STATUSNAK|INT_ENDPOINT0);\n\t\tif (dev->ep0state == EP0_IN) {\n\t\t\tep = &dev->ep[0];\n\t\t\tep->irqs++;\n\t\t\tnuke(ep, 0);\n\t\t\twritel(~(1<<0), &regs->EOP);\n\t\t\tdev->ep0state = EP0_STATUS;\n\t\t}\n\t}\n        if (stat & INT_ENDPOINT0) {\n\t\tACK(INT_ENDPOINT0);\n\t\tep = &dev->ep[0];\n\t\tep->irqs++;\n\t\tpio_advance(ep);\n        }\n\n\t \n        if (stat & INT_MSTRDEND) {\t \n\t\tACK(INT_MSTRDEND);\n\t\tep = &dev->ep[UDC_MSTRD_ENDPOINT];\n\t\tep->irqs++;\n\t\tdma_advance(dev, ep);\n        }\n        if (stat & INT_MSTWREND) {\t \n\t\tACK(INT_MSTWREND);\n\t\tep = &dev->ep[UDC_MSTWR_ENDPOINT];\n\t\tep->irqs++;\n\t\tdma_advance(dev, ep);\n        }\n        if (stat & INT_MSTWRTMOUT) {\t \n\t\tACK(INT_MSTWRTMOUT);\n\t\tep = &dev->ep[UDC_MSTWR_ENDPOINT];\n\t\tep->irqs++;\n\t\tERROR(dev, \"%s write timeout ?\\n\", ep->ep.name);\n\t\t\n        }\n\n\t \n\tfor (i = 1; i < 4; i++) {\n\t\tu32\t\ttmp = INT_EPxDATASET(i);\n\n\t\tif (!(stat & tmp))\n\t\t\tcontinue;\n\t\tep = &dev->ep[i];\n\t\tpio_advance(ep);\n\t\tif (list_empty (&ep->queue))\n\t\t\tpio_irq_disable(dev, regs, i);\n\t\tstat &= ~tmp;\n\t\thandled = 1;\n\t\tep->irqs++;\n\t}\n\n\tif (rescans--)\n\t\tgoto rescan;\n\ndone:\n\t(void)readl(&regs->int_enable);\n\tspin_unlock(&dev->lock);\n\tif (stat)\n\t\tDBG(dev, \"unhandled irq status: %05x (%05x, %05x)\\n\", stat,\n\t\t\t\treadl(&regs->int_status), dev->int_enable);\n\treturn IRQ_RETVAL(handled);\n}\n\n#undef ACK\n\n \n\nstatic void gadget_release(struct device *_dev)\n{\n\tstruct goku_udc\t*dev = dev_get_drvdata(_dev);\n\n\tkfree(dev);\n}\n\n \n\nstatic void goku_remove(struct pci_dev *pdev)\n{\n\tstruct goku_udc\t\t*dev = pci_get_drvdata(pdev);\n\n\tDBG(dev, \"%s\\n\", __func__);\n\n\tusb_del_gadget_udc(&dev->gadget);\n\n\tBUG_ON(dev->driver);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\tremove_proc_entry(proc_node_name, NULL);\n#endif\n\tif (dev->regs)\n\t\tudc_reset(dev);\n\tif (dev->got_irq)\n\t\tfree_irq(pdev->irq, dev);\n\tif (dev->regs)\n\t\tiounmap(dev->regs);\n\tif (dev->got_region)\n\t\trelease_mem_region(pci_resource_start (pdev, 0),\n\t\t\t\tpci_resource_len (pdev, 0));\n\tif (dev->enabled)\n\t\tpci_disable_device(pdev);\n\n\tdev->regs = NULL;\n\n\tINFO(dev, \"unbind\\n\");\n}\n\n \n\nstatic int goku_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct goku_udc\t\t*dev = NULL;\n\tunsigned long\t\tresource, len;\n\tvoid __iomem\t\t*base = NULL;\n\tint\t\t\tretval;\n\n\tif (!pdev->irq) {\n\t\tprintk(KERN_ERR \"Check PCI %s IRQ setup!\\n\", pci_name(pdev));\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n\n\t \n\tdev = kzalloc (sizeof *dev, GFP_KERNEL);\n\tif (!dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\tspin_lock_init(&dev->lock);\n\tdev->pdev = pdev;\n\tdev->gadget.ops = &goku_ops;\n\tdev->gadget.max_speed = USB_SPEED_FULL;\n\n\t \n\tdev->gadget.name = driver_name;\n\n\t \n\tretval = pci_enable_device(pdev);\n\tif (retval < 0) {\n\t\tDBG(dev, \"can't enable, %d\\n\", retval);\n\t\tgoto err;\n\t}\n\tdev->enabled = 1;\n\n\tresource = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\tif (!request_mem_region(resource, len, driver_name)) {\n\t\tDBG(dev, \"controller already in use\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err;\n\t}\n\tdev->got_region = 1;\n\n\tbase = ioremap(resource, len);\n\tif (base == NULL) {\n\t\tDBG(dev, \"can't map memory\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto err;\n\t}\n\tdev->regs = (struct goku_udc_regs __iomem *) base;\n\n\tINFO(dev, \"%s\\n\", driver_desc);\n\tINFO(dev, \"version: \" DRIVER_VERSION \" %s\\n\", dmastr());\n\tINFO(dev, \"irq %d, pci mem %p\\n\", pdev->irq, base);\n\n\t \n\tudc_reset(dev);\n\tudc_reinit (dev);\n\tif (request_irq(pdev->irq, goku_irq, IRQF_SHARED,\n\t\t\tdriver_name, dev) != 0) {\n\t\tDBG(dev, \"request interrupt %d failed\\n\", pdev->irq);\n\t\tretval = -EBUSY;\n\t\tgoto err;\n\t}\n\tdev->got_irq = 1;\n\tif (use_dma)\n\t\tpci_set_master(pdev);\n\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\tproc_create_single_data(proc_node_name, 0, NULL, udc_proc_read, dev);\n#endif\n\n\tretval = usb_add_gadget_udc_release(&pdev->dev, &dev->gadget,\n\t\t\tgadget_release);\n\tif (retval)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tif (dev)\n\t\tgoku_remove (pdev);\n\t \n\tkfree(dev);\n\treturn retval;\n}\n\n\n \n\nstatic const struct pci_device_id pci_ids[] = { {\n\t.class =\tPCI_CLASS_SERIAL_USB_DEVICE,\n\t.class_mask =\t~0,\n\t.vendor =\t0x102f,\t\t \n\t.device =\t0x0107,\t\t \n\t.subvendor =\tPCI_ANY_ID,\n\t.subdevice =\tPCI_ANY_ID,\n\n}, {   }\n};\nMODULE_DEVICE_TABLE (pci, pci_ids);\n\nstatic struct pci_driver goku_pci_driver = {\n\t.name =\t\tdriver_name,\n\t.id_table =\tpci_ids,\n\n\t.probe =\tgoku_probe,\n\t.remove =\tgoku_remove,\n\n\t \n};\n\nmodule_pci_driver(goku_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}