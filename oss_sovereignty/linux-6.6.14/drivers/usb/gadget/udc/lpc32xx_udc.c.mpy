{
  "module_name": "lpc32xx_udc.c",
  "hash_id": "f664664d2e0c14e65af2608729e9311f6a04624c3066e5937bc939b677cd08af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/lpc32xx_udc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/slab.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/isp1301.h>\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#endif\n\n \ntypedef void (*usc_chg_event)(int);\nstruct lpc32xx_usbd_cfg {\n\tint vbus_drv_pol;    \n\tusc_chg_event conn_chgb;  \n\tusc_chg_event susp_chgb;  \n\tusc_chg_event rmwk_chgb;  \n};\n\n \n\n \n#define\tNUM_ENDPOINTS\t16\n\n \n#define IRQ_USB_LP\t0\n#define IRQ_USB_HP\t1\n#define IRQ_USB_DEVDMA\t2\n#define IRQ_USB_ATX\t3\n\n#define EP_OUT 0  \n#define EP_IN 1  \n\n \n#define EP_MASK_SEL(ep, dir) (1 << (((ep) * 2) + dir))\n\n#define EP_INT_TYPE 0\n#define EP_ISO_TYPE 1\n#define EP_BLK_TYPE 2\n#define EP_CTL_TYPE 3\n\n \n#define WAIT_FOR_SETUP 0  \n#define DATA_IN        1  \n#define DATA_OUT       2  \n\n \nstruct lpc32xx_usbd_dd_gad {\n\tu32 dd_next_phy;\n\tu32 dd_setup;\n\tu32 dd_buffer_addr;\n\tu32 dd_status;\n\tu32 dd_iso_ps_mem_addr;\n\tu32 this_dma;\n\tu32 iso_status[6];  \n\tu32 dd_next_v;\n};\n\n \nstruct lpc32xx_ep {\n\tstruct usb_ep\t\tep;\n\tstruct list_head\tqueue;\n\tstruct lpc32xx_udc\t*udc;\n\n\tu32\t\t\thwep_num_base;  \n\tu32\t\t\thwep_num;  \n\tu32\t\t\tmaxpacket;\n\tu32\t\t\tlep;\n\n\tbool\t\t\tis_in;\n\tbool\t\t\treq_pending;\n\tu32\t\t\teptype;\n\n\tu32                     totalints;\n\n\tbool\t\t\twedge;\n};\n\nenum atx_type {\n\tISP1301,\n\tSTOTG04,\n};\n\n \nstruct lpc32xx_udc {\n\tstruct usb_gadget\tgadget;\n\tstruct usb_gadget_driver *driver;\n\tstruct platform_device\t*pdev;\n\tstruct device\t\t*dev;\n\tspinlock_t\t\tlock;\n\tstruct i2c_client\t*isp1301_i2c_client;\n\n\t \n\tstruct lpc32xx_usbd_cfg\t*board;\n\tvoid __iomem\t\t*udp_baseaddr;\n\tint\t\t\tudp_irq[4];\n\tstruct clk\t\t*usb_slv_clk;\n\n\t \n\tu32\t\t\t*udca_v_base;\n\tu32\t\t\tudca_p_base;\n\tstruct dma_pool\t\t*dd_cache;\n\n\t \n\tu32\t\t\tenabled_devints;\n\tu32\t\t\tenabled_hwepints;\n\tu32\t\t\tdev_status;\n\tu32\t\t\trealized_eps;\n\n\t \n\tu8\t\t\tvbus;\n\tu8\t\t\tlast_vbus;\n\tint\t\t\tpullup;\n\tint\t\t\tpoweron;\n\tenum atx_type\t\tatx;\n\n\t \n\tstruct work_struct\tpullup_job;\n\tstruct work_struct\tpower_job;\n\n\t \n\tstruct lpc32xx_ep\tep[NUM_ENDPOINTS];\n\tbool\t\t\tenabled;\n\tbool\t\t\tclocked;\n\tbool\t\t\tsuspended;\n\tint                     ep0state;\n\tatomic_t                enabled_ep_cnt;\n\twait_queue_head_t       ep_disable_wait_queue;\n};\n\n \nstruct lpc32xx_request {\n\tstruct usb_request\treq;\n\tstruct list_head\tqueue;\n\tstruct lpc32xx_usbd_dd_gad *dd_desc_ptr;\n\tbool\t\t\tmapped;\n\tbool\t\t\tsend_zlp;\n};\n\nstatic inline struct lpc32xx_udc *to_udc(struct usb_gadget *g)\n{\n\treturn container_of(g, struct lpc32xx_udc, gadget);\n}\n\n#define ep_dbg(epp, fmt, arg...) \\\n\tdev_dbg(epp->udc->dev, \"%s: \" fmt, __func__, ## arg)\n#define ep_err(epp, fmt, arg...) \\\n\tdev_err(epp->udc->dev, \"%s: \" fmt, __func__, ## arg)\n#define ep_info(epp, fmt, arg...) \\\n\tdev_info(epp->udc->dev, \"%s: \" fmt, __func__, ## arg)\n#define ep_warn(epp, fmt, arg...) \\\n\tdev_warn(epp->udc->dev, \"%s:\" fmt, __func__, ## arg)\n\n#define UDCA_BUFF_SIZE (128)\n\n \n\n#define USBD_DEVINTST(x)\t((x) + 0x200)\n#define USBD_DEVINTEN(x)\t((x) + 0x204)\n#define USBD_DEVINTCLR(x)\t((x) + 0x208)\n#define USBD_DEVINTSET(x)\t((x) + 0x20C)\n#define USBD_CMDCODE(x)\t\t((x) + 0x210)\n#define USBD_CMDDATA(x)\t\t((x) + 0x214)\n#define USBD_RXDATA(x)\t\t((x) + 0x218)\n#define USBD_TXDATA(x)\t\t((x) + 0x21C)\n#define USBD_RXPLEN(x)\t\t((x) + 0x220)\n#define USBD_TXPLEN(x)\t\t((x) + 0x224)\n#define USBD_CTRL(x)\t\t((x) + 0x228)\n#define USBD_DEVINTPRI(x)\t((x) + 0x22C)\n#define USBD_EPINTST(x)\t\t((x) + 0x230)\n#define USBD_EPINTEN(x)\t\t((x) + 0x234)\n#define USBD_EPINTCLR(x)\t((x) + 0x238)\n#define USBD_EPINTSET(x)\t((x) + 0x23C)\n#define USBD_EPINTPRI(x)\t((x) + 0x240)\n#define USBD_REEP(x)\t\t((x) + 0x244)\n#define USBD_EPIND(x)\t\t((x) + 0x248)\n#define USBD_EPMAXPSIZE(x)\t((x) + 0x24C)\n \n \n#define USBD_DMARST(x)\t\t((x) + 0x250)\n#define USBD_DMARCLR(x)\t\t((x) + 0x254)\n#define USBD_DMARSET(x)\t\t((x) + 0x258)\n \n#define USBD_UDCAH(x)\t\t((x) + 0x280)\n \n#define USBD_EPDMAST(x)\t\t((x) + 0x284)\n#define USBD_EPDMAEN(x)\t\t((x) + 0x288)\n#define USBD_EPDMADIS(x)\t((x) + 0x28C)\n \n#define USBD_DMAINTST(x)\t((x) + 0x290)\n#define USBD_DMAINTEN(x)\t((x) + 0x294)\n \n#define USBD_EOTINTST(x)\t((x) + 0x2A0)\n#define USBD_EOTINTCLR(x)\t((x) + 0x2A4)\n#define USBD_EOTINTSET(x)\t((x) + 0x2A8)\n \n#define USBD_NDDRTINTST(x)\t((x) + 0x2AC)\n#define USBD_NDDRTINTCLR(x)\t((x) + 0x2B0)\n#define USBD_NDDRTINTSET(x)\t((x) + 0x2B4)\n \n#define USBD_SYSERRTINTST(x)\t((x) + 0x2B8)\n#define USBD_SYSERRTINTCLR(x)\t((x) + 0x2BC)\n#define USBD_SYSERRTINTSET(x)\t((x) + 0x2C0)\n\n \n#define USBD_ERR_INT\t\t(1 << 9)\n#define USBD_EP_RLZED\t\t(1 << 8)\n#define USBD_TXENDPKT\t\t(1 << 7)\n#define USBD_RXENDPKT\t\t(1 << 6)\n#define USBD_CDFULL\t\t(1 << 5)\n#define USBD_CCEMPTY\t\t(1 << 4)\n#define USBD_DEV_STAT\t\t(1 << 3)\n#define USBD_EP_SLOW\t\t(1 << 2)\n#define USBD_EP_FAST\t\t(1 << 1)\n#define USBD_FRAME\t\t(1 << 0)\n\n \n \n#define USBD_RX_EP_SEL(e)\t(1 << ((e) << 1))\n\n \n#define USBD_TX_EP_SEL(e)\t(1 << (((e) << 1) + 1))\n\n \n \n#define USBD_EP_SEL(e)\t\t(1 << (e))\n\n \n#define USBD_SYS_ERR_INT\t(1 << 2)\n#define USBD_NEW_DD_INT\t\t(1 << 1)\n#define USBD_EOT_INT\t\t(1 << 0)\n\n \n#define USBD_PKT_RDY\t\t(1 << 11)\n#define USBD_DV\t\t\t(1 << 10)\n#define USBD_PK_LEN_MASK\t0x3FF\n\n \n#define USBD_LOG_ENDPOINT(e)\t((e) << 2)\n#define USBD_WR_EN\t\t(1 << 1)\n#define USBD_RD_EN\t\t(1 << 0)\n\n \n#define USBD_CMD_CODE(c)\t((c) << 16)\n#define USBD_CMD_PHASE(p)\t((p) << 8)\n\n \n#define USBD_DMAEP(e)\t\t(1 << (e))\n\n \nstruct lpc32xx_usbd_dd {\n\tu32 *dd_next;\n\tu32 dd_setup;\n\tu32 dd_buffer_addr;\n\tu32 dd_status;\n\tu32 dd_iso_ps_mem_addr;\n};\n\n \n#define DD_SETUP_ATLE_DMA_MODE\t0x01\n#define DD_SETUP_NEXT_DD_VALID\t0x04\n#define DD_SETUP_ISO_EP\t\t0x10\n#define DD_SETUP_PACKETLEN(n)\t(((n) & 0x7FF) << 5)\n#define DD_SETUP_DMALENBYTES(n)\t(((n) & 0xFFFF) << 16)\n\n \n#define DD_STATUS_DD_RETIRED\t0x01\n#define DD_STATUS_STS_MASK\t0x1E\n#define DD_STATUS_STS_NS\t0x00  \n#define DD_STATUS_STS_BS\t0x02  \n#define DD_STATUS_STS_NC\t0x04  \n#define DD_STATUS_STS_DUR\t0x06  \n#define DD_STATUS_STS_DOR\t0x08  \n#define DD_STATUS_STS_SE\t0x12  \n#define DD_STATUS_PKT_VAL\t0x20  \n#define DD_STATUS_LSB_EX\t0x40  \n#define DD_STATUS_MSB_EX\t0x80  \n#define DD_STATUS_MLEN(n)\t(((n) >> 8) & 0x3F)\n#define DD_STATUS_CURDMACNT(n)\t(((n) >> 16) & 0xFFFF)\n\n \n \n#define FRAME_INT\t\t0x00000001\n#define EP_FAST_INT\t\t0x00000002\n#define EP_SLOW_INT\t\t0x00000004\n#define DEV_STAT_INT\t\t0x00000008\n#define CCEMTY_INT\t\t0x00000010\n#define CDFULL_INT\t\t0x00000020\n#define RxENDPKT_INT\t\t0x00000040\n#define TxENDPKT_INT\t\t0x00000080\n#define EP_RLZED_INT\t\t0x00000100\n#define ERR_INT\t\t\t0x00000200\n\n \n#define PKT_LNGTH_MASK\t\t0x000003FF\n#define PKT_DV\t\t\t0x00000400\n#define PKT_RDY\t\t\t0x00000800\n\n \n#define CTRL_RD_EN\t\t0x00000001\n#define CTRL_WR_EN\t\t0x00000002\n\n \n#define CMD_SET_ADDR\t\t0x00D00500\n#define CMD_CFG_DEV\t\t0x00D80500\n#define CMD_SET_MODE\t\t0x00F30500\n#define CMD_RD_FRAME\t\t0x00F50500\n#define DAT_RD_FRAME\t\t0x00F50200\n#define CMD_RD_TEST\t\t0x00FD0500\n#define DAT_RD_TEST\t\t0x00FD0200\n#define CMD_SET_DEV_STAT\t0x00FE0500\n#define CMD_GET_DEV_STAT\t0x00FE0500\n#define DAT_GET_DEV_STAT\t0x00FE0200\n#define CMD_GET_ERR_CODE\t0x00FF0500\n#define DAT_GET_ERR_CODE\t0x00FF0200\n#define CMD_RD_ERR_STAT\t\t0x00FB0500\n#define DAT_RD_ERR_STAT\t\t0x00FB0200\n#define DAT_WR_BYTE(x)\t\t(0x00000100 | ((x) << 16))\n#define CMD_SEL_EP(x)\t\t(0x00000500 | ((x) << 16))\n#define DAT_SEL_EP(x)\t\t(0x00000200 | ((x) << 16))\n#define CMD_SEL_EP_CLRI(x)\t(0x00400500 | ((x) << 16))\n#define DAT_SEL_EP_CLRI(x)\t(0x00400200 | ((x) << 16))\n#define CMD_SET_EP_STAT(x)\t(0x00400500 | ((x) << 16))\n#define CMD_CLR_BUF\t\t0x00F20500\n#define DAT_CLR_BUF\t\t0x00F20200\n#define CMD_VALID_BUF\t\t0x00FA0500\n\n \n#define DEV_ADDR_MASK\t\t0x7F\n#define DEV_EN\t\t\t0x80\n\n \n#define CONF_DVICE\t\t0x01\n\n \n#define AP_CLK\t\t\t0x01\n#define INAK_CI\t\t\t0x02\n#define INAK_CO\t\t\t0x04\n#define INAK_II\t\t\t0x08\n#define INAK_IO\t\t\t0x10\n#define INAK_BI\t\t\t0x20\n#define INAK_BO\t\t\t0x40\n\n \n#define DEV_CON\t\t\t0x01\n#define DEV_CON_CH\t\t0x02\n#define DEV_SUS\t\t\t0x04\n#define DEV_SUS_CH\t\t0x08\n#define DEV_RST\t\t\t0x10\n\n \n#define ERR_EC_MASK\t\t0x0F\n#define ERR_EA\t\t\t0x10\n\n \n#define ERR_PID\t\t\t0x01\n#define ERR_UEPKT\t\t0x02\n#define ERR_DCRC\t\t0x04\n#define ERR_TIMOUT\t\t0x08\n#define ERR_EOP\t\t\t0x10\n#define ERR_B_OVRN\t\t0x20\n#define ERR_BTSTF\t\t0x40\n#define ERR_TGL\t\t\t0x80\n\n \n#define EP_SEL_F\t\t0x01\n#define EP_SEL_ST\t\t0x02\n#define EP_SEL_STP\t\t0x04\n#define EP_SEL_PO\t\t0x08\n#define EP_SEL_EPN\t\t0x10\n#define EP_SEL_B_1_FULL\t\t0x20\n#define EP_SEL_B_2_FULL\t\t0x40\n\n \n#define EP_STAT_ST\t\t0x01\n#define EP_STAT_DA\t\t0x20\n#define EP_STAT_RF_MO\t\t0x40\n#define EP_STAT_CND_ST\t\t0x80\n\n \n#define CLR_BUF_PO\t\t0x01\n\n \n#define EOT_INT\t\t\t0x01\n#define NDD_REQ_INT\t\t0x02\n#define SYS_ERR_INT\t\t0x04\n\n#define\tDRIVER_VERSION\t\"1.03\"\nstatic const char driver_name[] = \"lpc32xx_udc\";\n\n \n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\nstatic char *epnames[] = {\"INT\", \"ISO\", \"BULK\", \"CTRL\"};\nstatic const char debug_filename[] = \"driver/udc\";\n\nstatic void proc_ep_show(struct seq_file *s, struct lpc32xx_ep *ep)\n{\n\tstruct lpc32xx_request *req;\n\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"%12s, maxpacket %4d %3s\",\n\t\t\tep->ep.name, ep->ep.maxpacket,\n\t\t\tep->is_in ? \"in\" : \"out\");\n\tseq_printf(s, \" type %4s\", epnames[ep->eptype]);\n\tseq_printf(s, \" ints: %12d\", ep->totalints);\n\n\tif (list_empty(&ep->queue))\n\t\tseq_printf(s, \"\\t(queue empty)\\n\");\n\telse {\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tu32 length = req->req.actual;\n\n\t\t\tseq_printf(s, \"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t   &req->req, length,\n\t\t\t\t   req->req.length, req->req.buf);\n\t\t}\n\t}\n}\n\nstatic int udc_show(struct seq_file *s, void *unused)\n{\n\tstruct lpc32xx_udc *udc = s->private;\n\tstruct lpc32xx_ep *ep;\n\tunsigned long flags;\n\n\tseq_printf(s, \"%s: version %s\\n\", driver_name, DRIVER_VERSION);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tseq_printf(s, \"vbus %s, pullup %s, %s powered%s, gadget %s\\n\\n\",\n\t\t   udc->vbus ? \"present\" : \"off\",\n\t\t   udc->enabled ? (udc->vbus ? \"active\" : \"enabled\") :\n\t\t   \"disabled\",\n\t\t   udc->gadget.is_selfpowered ? \"self\" : \"VBUS\",\n\t\t   udc->suspended ? \", suspended\" : \"\",\n\t\t   udc->driver ? udc->driver->driver.name : \"(none)\");\n\n\tif (udc->enabled && udc->vbus) {\n\t\tproc_ep_show(s, &udc->ep[0]);\n\t\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list)\n\t\t\tproc_ep_show(s, ep);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(udc);\n\nstatic void create_debug_file(struct lpc32xx_udc *udc)\n{\n\tdebugfs_create_file(debug_filename, 0, NULL, udc, &udc_fops);\n}\n\nstatic void remove_debug_file(struct lpc32xx_udc *udc)\n{\n\tdebugfs_lookup_and_remove(debug_filename, NULL);\n}\n\n#else\nstatic inline void create_debug_file(struct lpc32xx_udc *udc) {}\nstatic inline void remove_debug_file(struct lpc32xx_udc *udc) {}\n#endif\n\n \nstatic void isp1301_udc_configure(struct lpc32xx_udc *udc)\n{\n\tu8 value;\n\ts32 vendor, product;\n\n\tvendor = i2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x00);\n\tproduct = i2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x02);\n\n\tif (vendor == 0x0483 && product == 0xa0c4)\n\t\tudc->atx = STOTG04;\n\n\t \n\t \n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\tMC1_UART_EN);\n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_MODE_CONTROL_1, (MC1_SPEED_REG | MC1_DAT_SE0));\n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\n\n\tvalue = MC2_BI_DI;\n\tif (udc->atx != STOTG04)\n\t\tvalue |= MC2_SPD_SUSP_CTRL;\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_MODE_CONTROL_2, value);\n\n\t \n\tif (udc->board->vbus_drv_pol != 0)\n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DRV);\n\telse\n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\t\tOTG1_VBUS_DRV);\n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_OTG_CONTROL_1,\n\t\t(0 | OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DISCHRG);\n\tmsleep(1);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\tOTG1_VBUS_DISCHRG);\n\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\n\tdev_info(udc->dev, \"ISP1301 Vendor ID  : 0x%04x\\n\", vendor);\n\tdev_info(udc->dev, \"ISP1301 Product ID : 0x%04x\\n\", product);\n\tdev_info(udc->dev, \"ISP1301 Version ID : 0x%04x\\n\",\n\t\t i2c_smbus_read_word_data(udc->isp1301_i2c_client, 0x14));\n\n}\n\n \nstatic void isp1301_pullup_set(struct lpc32xx_udc *udc)\n{\n\tif (udc->pullup)\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1, OTG1_DP_PULLUP);\n\telse\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\t\tOTG1_DP_PULLUP);\n}\n\nstatic void pullup_work(struct work_struct *work)\n{\n\tstruct lpc32xx_udc *udc =\n\t\tcontainer_of(work, struct lpc32xx_udc, pullup_job);\n\n\tisp1301_pullup_set(udc);\n}\n\nstatic void isp1301_pullup_enable(struct lpc32xx_udc *udc, int en_pullup,\n\t\t\t\t  int block)\n{\n\tif (en_pullup == udc->pullup)\n\t\treturn;\n\n\tudc->pullup = en_pullup;\n\tif (block)\n\t\tisp1301_pullup_set(udc);\n\telse\n\t\t \n\t\tschedule_work(&udc->pullup_job);\n}\n\n#ifdef CONFIG_PM\n \nstatic void isp1301_set_powerstate(struct lpc32xx_udc *udc, int enable)\n{\n\t \n\tif (udc->atx == STOTG04)\n\t\treturn;\n\n\tif (enable != 0)\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\t\tMC2_GLOBAL_PWR_DN);\n\telse\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_MODE_CONTROL_2, MC2_GLOBAL_PWR_DN);\n}\n\nstatic void power_work(struct work_struct *work)\n{\n\tstruct lpc32xx_udc *udc =\n\t\tcontainer_of(work, struct lpc32xx_udc, power_job);\n\n\tisp1301_set_powerstate(udc, udc->poweron);\n}\n#endif\n\n \n \nstatic void udc_protocol_cmd_w(struct lpc32xx_udc *udc, u32 cmd)\n{\n\tu32 pass = 0;\n\tint to;\n\n\t \n\tu32 tmp = readl(USBD_DEVINTST(udc->udp_baseaddr));\n\t(void) tmp;\n\n\twhile (pass == 0) {\n\t\twritel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));\n\n\t\t \n\t\twritel(cmd, USBD_CMDCODE(udc->udp_baseaddr));\n\t\tto = 10000;\n\t\twhile (((readl(USBD_DEVINTST(udc->udp_baseaddr)) &\n\t\t\t USBD_CCEMPTY) == 0) && (to > 0)) {\n\t\t\tto--;\n\t\t}\n\n\t\tif (to > 0)\n\t\t\tpass = 1;\n\n\t\tcpu_relax();\n\t}\n}\n\n \nstatic inline void udc_protocol_cmd_data_w(struct lpc32xx_udc *udc, u32 cmd,\n\t\t\t\t\t   u32 data)\n{\n\tudc_protocol_cmd_w(udc, cmd);\n\tudc_protocol_cmd_w(udc, data);\n}\n\n \nstatic u32 udc_protocol_cmd_r(struct lpc32xx_udc *udc, u32 cmd)\n{\n\tint to = 1000;\n\n\t \n\twritel((USBD_CDFULL | USBD_CCEMPTY),\n\t\t     USBD_DEVINTCLR(udc->udp_baseaddr));\n\n\t \n\tudc_protocol_cmd_w(udc, cmd);\n\n\twhile ((!(readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CDFULL))\n\t       && (to > 0))\n\t\tto--;\n\tif (!to)\n\t\tdev_dbg(udc->dev,\n\t\t\t\"Protocol engine didn't receive response (CDFULL)\\n\");\n\n\treturn readl(USBD_CMDDATA(udc->udp_baseaddr));\n}\n\n \n \nstatic inline void uda_enable_devint(struct lpc32xx_udc *udc, u32 devmask)\n{\n\tudc->enabled_devints |= devmask;\n\twritel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));\n}\n\n \nstatic inline void uda_disable_devint(struct lpc32xx_udc *udc, u32 mask)\n{\n\tudc->enabled_devints &= ~mask;\n\twritel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));\n}\n\n \nstatic inline void uda_clear_devint(struct lpc32xx_udc *udc, u32 mask)\n{\n\twritel(mask, USBD_DEVINTCLR(udc->udp_baseaddr));\n}\n\n \n \nstatic void uda_enable_hwepint(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc->enabled_hwepints |= (1 << hwep);\n\twritel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));\n}\n\n \nstatic void uda_disable_hwepint(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc->enabled_hwepints &= ~(1 << hwep);\n\twritel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));\n}\n\n \nstatic inline void uda_clear_hwepint(struct lpc32xx_udc *udc, u32 hwep)\n{\n\twritel((1 << hwep), USBD_EPINTCLR(udc->udp_baseaddr));\n}\n\n \nstatic inline void udc_ep_dma_enable(struct lpc32xx_udc *udc, u32 hwep)\n{\n\twritel((1 << hwep), USBD_EPDMAEN(udc->udp_baseaddr));\n}\n\n \nstatic inline void udc_ep_dma_disable(struct lpc32xx_udc *udc, u32 hwep)\n{\n\twritel((1 << hwep), USBD_EPDMADIS(udc->udp_baseaddr));\n}\n\n \n \nstatic void udc_realize_hwep(struct lpc32xx_udc *udc, u32 hwep,\n\t\t\t     u32 maxpacket)\n{\n\tint to = 1000;\n\n\twritel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));\n\twritel(hwep, USBD_EPIND(udc->udp_baseaddr));\n\tudc->realized_eps |= (1 << hwep);\n\twritel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));\n\twritel(maxpacket, USBD_EPMAXPSIZE(udc->udp_baseaddr));\n\n\t \n\twhile ((!(readl(USBD_DEVINTST(udc->udp_baseaddr)) &\n\t\t  USBD_EP_RLZED)) && (to > 0))\n\t\tto--;\n\tif (!to)\n\t\tdev_dbg(udc->dev, \"EP not correctly realized in hardware\\n\");\n\n\twritel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));\n}\n\n \nstatic void udc_unrealize_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc->realized_eps &= ~(1 << hwep);\n\twritel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));\n}\n\n \n \nstatic u32 udc_selep_clrint(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_protocol_cmd_w(udc, CMD_SEL_EP_CLRI(hwep));\n\treturn udc_protocol_cmd_r(udc, DAT_SEL_EP_CLRI(hwep));\n}\n\n \nstatic void udc_disable_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\n\t\t\t\tDAT_WR_BYTE(EP_STAT_DA));\n}\n\n \nstatic void udc_stall_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\n\t\t\t\tDAT_WR_BYTE(EP_STAT_ST));\n}\n\n \nstatic void udc_clrstall_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),\n\t\t\t\tDAT_WR_BYTE(0));\n}\n\n \nstatic void udc_select_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_protocol_cmd_w(udc, CMD_SEL_EP(hwep));\n}\n\n \n \nstatic void udc_clr_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_select_hwep(udc, hwep);\n\tudc_protocol_cmd_w(udc, CMD_CLR_BUF);\n}\n\n \nstatic void udc_val_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep)\n{\n\tudc_select_hwep(udc, hwep);\n\tudc_protocol_cmd_w(udc, CMD_VALID_BUF);\n}\n\nstatic inline u32 udc_clearep_getsts(struct lpc32xx_udc *udc, u32 hwep)\n{\n\t \n\tuda_clear_hwepint(udc, hwep);\n\treturn udc_selep_clrint(udc, hwep);\n}\n\n \n \nstatic struct lpc32xx_usbd_dd_gad *udc_dd_alloc(struct lpc32xx_udc *udc)\n{\n\tdma_addr_t\t\t\tdma;\n\tstruct lpc32xx_usbd_dd_gad\t*dd;\n\n\tdd = dma_pool_alloc(udc->dd_cache, GFP_ATOMIC | GFP_DMA, &dma);\n\tif (dd)\n\t\tdd->this_dma = dma;\n\n\treturn dd;\n}\n\n \nstatic void udc_dd_free(struct lpc32xx_udc *udc, struct lpc32xx_usbd_dd_gad *dd)\n{\n\tdma_pool_free(udc->dd_cache, dd, dd->this_dma);\n}\n\n \n \nstatic void udc_clk_set(struct lpc32xx_udc *udc, int enable)\n{\n\tif (enable != 0) {\n\t\tif (udc->clocked)\n\t\t\treturn;\n\n\t\tudc->clocked = 1;\n\t\tclk_prepare_enable(udc->usb_slv_clk);\n\t} else {\n\t\tif (!udc->clocked)\n\t\t\treturn;\n\n\t\tudc->clocked = 0;\n\t\tclk_disable_unprepare(udc->usb_slv_clk);\n\t}\n}\n\n \nstatic void udc_set_address(struct lpc32xx_udc *udc, u32 addr)\n{\n\t \n\tudc_protocol_cmd_data_w(udc, CMD_SET_ADDR,\n\t\t\t\tDAT_WR_BYTE(DEV_EN | addr));\n}\n\n \nstatic int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\n{\n\tstruct lpc32xx_request *req;\n\tu32 hwep = ep->hwep_num;\n\n\tep->req_pending = 1;\n\n\t \n\treq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\n\n\t \n\tudc->udca_v_base[hwep] = req->dd_desc_ptr->this_dma;\n\n\t \n\tudc_ep_dma_enable(udc, hwep);\n\n\t \n\tif (req->req.length % ep->ep.maxpacket)\n\t\treq->send_zlp = 0;\n\n\treturn 0;\n}\n\n \nstatic int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\n{\n\tstruct lpc32xx_request *req;\n\tu32 hwep = ep->hwep_num;\n\n\tep->req_pending = 1;\n\n\t \n\treq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\n\n\t \n\tudc->udca_v_base[hwep] = req->dd_desc_ptr->this_dma;\n\n\t \n\tudc_ep_dma_enable(udc, hwep);\n\treturn 0;\n}\n\nstatic void udc_disable(struct lpc32xx_udc *udc)\n{\n\tu32 i;\n\n\t \n\tudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));\n\tudc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(0));\n\n\t \n\tuda_disable_devint(udc, 0x3FF);\n\n\t \n\tfor (i = 0; i < 32; i++) {\n\t\tuda_disable_hwepint(udc, i);\n\t\tuda_clear_hwepint(udc, i);\n\t\tudc_disable_hwep(udc, i);\n\t\tudc_unrealize_hwep(udc, i);\n\t\tudc->udca_v_base[i] = 0;\n\n\t\t \n\t\tudc_ep_dma_disable(udc, i);\n\t\twritel((1 << i), USBD_EOTINTCLR(udc->udp_baseaddr));\n\t\twritel((1 << i), USBD_NDDRTINTCLR(udc->udp_baseaddr));\n\t\twritel((1 << i), USBD_SYSERRTINTCLR(udc->udp_baseaddr));\n\t\twritel((1 << i), USBD_DMARCLR(udc->udp_baseaddr));\n\t}\n\n\t \n\twritel(0, USBD_DMAINTEN(udc->udp_baseaddr));\n\n\twritel(0, USBD_UDCAH(udc->udp_baseaddr));\n}\n\nstatic void udc_enable(struct lpc32xx_udc *udc)\n{\n\tu32 i;\n\tstruct lpc32xx_ep *ep = &udc->ep[0];\n\n\t \n\tudc_disable(udc);\n\n\t \n\tudc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(DEV_CON));\n\n\t \n\twritel(USBD_EP_FAST, USBD_DEVINTPRI(udc->udp_baseaddr));\n\twritel(0xFFFF, USBD_EPINTPRI(udc->udp_baseaddr));\n\n\t \n\twritel(0x3FF, USBD_DEVINTCLR(udc->udp_baseaddr));\n\n\t \n\twritel(udc->udca_p_base, USBD_UDCAH(udc->udp_baseaddr));\n\n\t \n\tfor (i = 0; i <= 1; i++) {\n\t\tudc_realize_hwep(udc, i, ep->ep.maxpacket);\n\t\tuda_enable_hwepint(udc, i);\n\t\tudc_select_hwep(udc, i);\n\t\tudc_clrstall_hwep(udc, i);\n\t\tudc_clr_buffer_hwep(udc, i);\n\t}\n\n\t \n\tuda_clear_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |\n\t\t\t       USBD_EP_FAST));\n\tuda_enable_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |\n\t\t\t\tUSBD_EP_FAST));\n\n\t \n\tudc_set_address(udc, 0);\n\tudc_set_address(udc, 0);\n\n\t \n\twritel((USBD_SYS_ERR_INT | USBD_EOT_INT),\n\t\t     USBD_DMAINTEN(udc->udp_baseaddr));\n\n\tudc->dev_status = 0;\n}\n\n \n \nstatic void uda_power_event(struct lpc32xx_udc *udc, u32 conn)\n{\n\t \n\tif (udc->board->conn_chgb != NULL)\n\t\tudc->board->conn_chgb(conn);\n}\n\n \nstatic void uda_resm_susp_event(struct lpc32xx_udc *udc, u32 conn)\n{\n\t \n\tif (udc->board->susp_chgb != NULL)\n\t\tudc->board->susp_chgb(conn);\n\n\tif (conn)\n\t\tudc->suspended = 0;\n\telse\n\t\tudc->suspended = 1;\n}\n\n \nstatic void uda_remwkp_cgh(struct lpc32xx_udc *udc)\n{\n\tif (udc->board->rmwk_chgb != NULL)\n\t\tudc->board->rmwk_chgb(udc->dev_status &\n\t\t\t\t      (1 << USB_DEVICE_REMOTE_WAKEUP));\n}\n\n \nstatic void udc_pop_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes)\n{\n\tint n, i, bl;\n\tu16 *p16;\n\tu32 *p32, tmp, cbytes;\n\n\t \n\tswitch (((uintptr_t) data) & 0x3) {\n\tcase 0:  \n\t\tp32 = (u32 *) data;\n\t\tcbytes = (bytes & ~0x3);\n\n\t\t \n\t\tfor (n = 0; n < cbytes; n += 4)\n\t\t\t*p32++ = readl(USBD_RXDATA(udc->udp_baseaddr));\n\n\t\t \n\t\tbl = bytes - cbytes;\n\t\tif (bl) {\n\t\t\ttmp = readl(USBD_RXDATA(udc->udp_baseaddr));\n\t\t\tfor (n = 0; n < bl; n++)\n\t\t\t\tdata[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);\n\n\t\t}\n\t\tbreak;\n\n\tcase 1:  \n\tcase 3:\n\t\t \n\t\tfor (n = 0; n < bytes; n += 4) {\n\t\t\ttmp = readl(USBD_RXDATA(udc->udp_baseaddr));\n\n\t\t\tbl = bytes - n;\n\t\t\tif (bl > 4)\n\t\t\t\tbl = 4;\n\n\t\t\tfor (i = 0; i < bl; i++)\n\t\t\t\tdata[n + i] = (u8) ((tmp >> (i * 8)) & 0xFF);\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\t\tp16 = (u16 *) data;\n\t\tcbytes = (bytes & ~0x3);\n\n\t\t \n\t\tfor (n = 0; n < cbytes; n += 4) {\n\t\t\ttmp = readl(USBD_RXDATA(udc->udp_baseaddr));\n\t\t\t*p16++ = (u16)(tmp & 0xFFFF);\n\t\t\t*p16++ = (u16)((tmp >> 16) & 0xFFFF);\n\t\t}\n\n\t\t \n\t\tbl = bytes - cbytes;\n\t\tif (bl) {\n\t\t\ttmp = readl(USBD_RXDATA(udc->udp_baseaddr));\n\t\t\tfor (n = 0; n < bl; n++)\n\t\t\t\tdata[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic u32 udc_read_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,\n\t\t\t u32 bytes)\n{\n\tu32 tmpv;\n\tint to = 1000;\n\tu32 tmp, hwrep = ((hwep & 0x1E) << 1) | CTRL_RD_EN;\n\n\t \n\twritel(hwrep, USBD_CTRL(udc->udp_baseaddr));\n\n\t \n\twhile ((((tmpv = readl(USBD_RXPLEN(udc->udp_baseaddr))) &\n\t\t PKT_RDY) == 0)\t&& (to > 0))\n\t\tto--;\n\tif (!to)\n\t\tdev_dbg(udc->dev, \"No packet ready on FIFO EP read\\n\");\n\n\t \n\ttmp = tmpv & PKT_LNGTH_MASK;\n\tif (bytes < tmp)\n\t\ttmp = bytes;\n\n\tif ((tmp > 0) && (data != NULL))\n\t\tudc_pop_fifo(udc, (u8 *) data, tmp);\n\n\twritel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));\n\n\t \n\tudc_clr_buffer_hwep(udc, hwep);\n\n\treturn tmp;\n}\n\n \nstatic void udc_stuff_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes)\n{\n\tint n, i, bl;\n\tu16 *p16;\n\tu32 *p32, tmp, cbytes;\n\n\t \n\tswitch (((uintptr_t) data) & 0x3) {\n\tcase 0:  \n\t\tp32 = (u32 *) data;\n\t\tcbytes = (bytes & ~0x3);\n\n\t\t \n\t\tfor (n = 0; n < cbytes; n += 4)\n\t\t\twritel(*p32++, USBD_TXDATA(udc->udp_baseaddr));\n\n\t\t \n\t\tbl = bytes - cbytes;\n\t\tif (bl) {\n\t\t\ttmp = 0;\n\t\t\tfor (n = 0; n < bl; n++)\n\t\t\t\ttmp |= data[cbytes + n] << (n * 8);\n\n\t\t\twritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\n\t\t}\n\t\tbreak;\n\n\tcase 1:  \n\tcase 3:\n\t\t \n\t\tfor (n = 0; n < bytes; n += 4) {\n\t\t\tbl = bytes - n;\n\t\t\tif (bl > 4)\n\t\t\t\tbl = 4;\n\n\t\t\ttmp = 0;\n\t\t\tfor (i = 0; i < bl; i++)\n\t\t\t\ttmp |= data[n + i] << (i * 8);\n\n\t\t\twritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\n\t\t}\n\t\tbreak;\n\n\tcase 2:  \n\t\tp16 = (u16 *) data;\n\t\tcbytes = (bytes & ~0x3);\n\n\t\t \n\t\tfor (n = 0; n < cbytes; n += 4) {\n\t\t\ttmp = *p16++ & 0xFFFF;\n\t\t\ttmp |= (*p16++ & 0xFFFF) << 16;\n\t\t\twritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\n\t\t}\n\n\t\t \n\t\tbl = bytes - cbytes;\n\t\tif (bl) {\n\t\t\ttmp = 0;\n\t\t\tfor (n = 0; n < bl; n++)\n\t\t\t\ttmp |= data[cbytes + n] << (n * 8);\n\n\t\t\twritel(tmp, USBD_TXDATA(udc->udp_baseaddr));\n\t\t}\n\t\tbreak;\n\t}\n}\n\n \nstatic void udc_write_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,\n\t\t\t   u32 bytes)\n{\n\tu32 hwwep = ((hwep & 0x1E) << 1) | CTRL_WR_EN;\n\n\tif ((bytes > 0) && (data == NULL))\n\t\treturn;\n\n\t \n\twritel(hwwep, USBD_CTRL(udc->udp_baseaddr));\n\n\twritel(bytes, USBD_TXPLEN(udc->udp_baseaddr));\n\n\t \n\tif (bytes == 0)\n\t\twritel(0, USBD_TXDATA(udc->udp_baseaddr));\n\telse\n\t\tudc_stuff_fifo(udc, (u8 *) data, bytes);\n\n\twritel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));\n\n\tudc_val_buffer_hwep(udc, hwep);\n}\n\n \nstatic void uda_usb_reset(struct lpc32xx_udc *udc)\n{\n\tu32 i = 0;\n\t \n\tudc_enable(udc);\n\tudc->gadget.speed = USB_SPEED_FULL;\n\n\tfor (i = 1; i < NUM_ENDPOINTS; i++) {\n\t\tstruct lpc32xx_ep *ep = &udc->ep[i];\n\t\tep->req_pending = 0;\n\t}\n}\n\n \nstatic void udc_ep0_send_zlp(struct lpc32xx_udc *udc)\n{\n\tudc_write_hwep(udc, EP_IN, NULL, 0);\n}\n\n \nstatic u16 udc_get_current_frame(struct lpc32xx_udc *udc)\n{\n\tu16 flo, fhi;\n\n\tudc_protocol_cmd_w(udc, CMD_RD_FRAME);\n\tflo = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);\n\tfhi = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);\n\n\treturn (fhi << 8) | flo;\n}\n\n \nstatic inline void udc_set_device_configured(struct lpc32xx_udc *udc)\n{\n\tudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(CONF_DVICE));\n}\n\n \nstatic inline void udc_set_device_unconfigured(struct lpc32xx_udc *udc)\n{\n\tudc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));\n}\n\n \nstatic void udc_reinit(struct lpc32xx_udc *udc)\n{\n\tu32 i;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tINIT_LIST_HEAD(&udc->gadget.ep0->ep_list);\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct lpc32xx_ep *ep = &udc->ep[i];\n\n\t\tif (i != 0)\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tep->req_pending = 0;\n\t}\n\n\tudc->ep0state = WAIT_FOR_SETUP;\n}\n\n \nstatic void done(struct lpc32xx_ep *ep, struct lpc32xx_request *req, int status)\n{\n\tstruct lpc32xx_udc *udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (ep->lep) {\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->req, ep->is_in);\n\n\t\t \n\t\tudc_dd_free(udc, req->dd_desc_ptr);\n\t}\n\n\tif (status && status != -ESHUTDOWN)\n\t\tep_dbg(ep, \"%s done %p, status %d\\n\", ep->ep.name, req, status);\n\n\tep->req_pending = 0;\n\tspin_unlock(&udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&udc->lock);\n}\n\n \nstatic void nuke(struct lpc32xx_ep *ep, int status)\n{\n\tstruct lpc32xx_request *req;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\n\t\tdone(ep, req, status);\n\t}\n\n\tif (status == -ESHUTDOWN) {\n\t\tuda_disable_hwepint(ep->udc, ep->hwep_num);\n\t\tudc_disable_hwep(ep->udc, ep->hwep_num);\n\t}\n}\n\n \nstatic int udc_ep0_in_req(struct lpc32xx_udc *udc)\n{\n\tstruct lpc32xx_request *req;\n\tstruct lpc32xx_ep *ep0 = &udc->ep[0];\n\tu32 tsend, ts = 0;\n\n\tif (list_empty(&ep0->queue))\n\t\t \n\t\treturn 0;\n\telse\n\t\treq = list_entry(ep0->queue.next, struct lpc32xx_request,\n\t\t\t\t queue);\n\n\ttsend = ts = req->req.length - req->req.actual;\n\tif (ts == 0) {\n\t\t \n\t\tudc_ep0_send_zlp(udc);\n\t\tdone(ep0, req, 0);\n\t\treturn 1;\n\t} else if (ts > ep0->ep.maxpacket)\n\t\tts = ep0->ep.maxpacket;  \n\n\t \n\tudc_write_hwep(udc, EP_IN, (req->req.buf + req->req.actual), ts);\n\n\t \n\treq->req.actual += ts;\n\n\tif (tsend >= ep0->ep.maxpacket)\n\t\treturn 0;  \n\n\t \n\tudc->ep0state = WAIT_FOR_SETUP;\n\tdone(ep0, req, 0);\n\treturn 1;\n}\n\n \nstatic int udc_ep0_out_req(struct lpc32xx_udc *udc)\n{\n\tstruct lpc32xx_request *req;\n\tstruct lpc32xx_ep *ep0 = &udc->ep[0];\n\tu32 tr, bufferspace;\n\n\tif (list_empty(&ep0->queue))\n\t\treturn 0;\n\telse\n\t\treq = list_entry(ep0->queue.next, struct lpc32xx_request,\n\t\t\t\t queue);\n\n\tif (req) {\n\t\tif (req->req.length == 0) {\n\t\t\t \n\t\t\tdone(ep0, req, 0);\n\t\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tbufferspace = req->req.length - req->req.actual;\n\t\tif (bufferspace > ep0->ep.maxpacket)\n\t\t\tbufferspace = ep0->ep.maxpacket;\n\n\t\t \n\t\tprefetchw(req->req.buf + req->req.actual);\n\t\ttr = udc_read_hwep(udc, EP_OUT, req->req.buf + req->req.actual,\n\t\t\t\t   bufferspace);\n\t\treq->req.actual += bufferspace;\n\n\t\tif (tr < ep0->ep.maxpacket) {\n\t\t\t \n\t\t\tdone(ep0, req, 0);\n\t\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void stop_activity(struct lpc32xx_udc *udc)\n{\n\tstruct usb_gadget_driver *driver = udc->driver;\n\tint i;\n\n\tif (udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->suspended = 0;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct lpc32xx_ep *ep = &udc->ep[i];\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\tif (driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tdriver->disconnect(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\tisp1301_pullup_enable(udc, 0, 0);\n\tudc_disable(udc);\n\tudc_reinit(udc);\n}\n\n \nstatic void pullup(struct lpc32xx_udc *udc, int is_on)\n{\n\tif (!udc->clocked)\n\t\treturn;\n\n\tif (!udc->enabled || !udc->vbus)\n\t\tis_on = 0;\n\n\tif (is_on != udc->pullup)\n\t\tisp1301_pullup_enable(udc, is_on, 0);\n}\n\n \nstatic int lpc32xx_ep_disable(struct usb_ep *_ep)\n{\n\tstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\n\tstruct lpc32xx_udc *udc = ep->udc;\n\tunsigned long\tflags;\n\n\tif ((ep->hwep_num_base == 0) || (ep->hwep_num == 0))\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tnuke(ep, -ESHUTDOWN);\n\n\t \n\tudc_ep_dma_disable(udc, ep->hwep_num);\n\twritel(1 << ep->hwep_num, USBD_EOTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_NDDRTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_SYSERRTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_DMARCLR(udc->udp_baseaddr));\n\n\t \n\tudc->udca_v_base[ep->hwep_num] = 0;\n\n\t \n\tuda_clear_hwepint(udc, ep->hwep_num);\n\tudc_unrealize_hwep(udc, ep->hwep_num);\n\n\tep->hwep_num = 0;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tatomic_dec(&udc->enabled_ep_cnt);\n\twake_up(&udc->ep_disable_wait_queue);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_ep_enable(struct usb_ep *_ep,\n\t\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\n\tstruct lpc32xx_udc *udc;\n\tu16 maxpacket;\n\tu32 tmp;\n\tunsigned long flags;\n\n\t \n\tif ((!_ep) || (!ep) || (!desc) ||\n\t    (desc->bDescriptorType != USB_DT_ENDPOINT))\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\tmaxpacket = usb_endpoint_maxp(desc);\n\tif ((maxpacket == 0) || (maxpacket > ep->maxpacket)) {\n\t\tdev_dbg(udc->dev, \"bad ep descriptor's packet size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ep->hwep_num_base == 0) {\n\t\tdev_dbg(udc->dev, \"Can't re-enable EP0!!!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {\n\t\tdev_dbg(udc->dev, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\ttmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tswitch (tmp) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\treturn -EINVAL;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (maxpacket > ep->maxpacket) {\n\t\t\tdev_dbg(udc->dev,\n\t\t\t\t\"Bad INT endpoint maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tswitch (maxpacket) {\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(udc->dev,\n\t\t\t\t\"Bad BULK endpoint maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tbreak;\n\t}\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;\n\tep->ep.maxpacket = maxpacket;\n\n\t \n\tif (ep->is_in)\n\t\t \n\t\tep->hwep_num = ep->hwep_num_base + EP_IN;\n\telse\n\t\tep->hwep_num = ep->hwep_num_base;\n\n\tep_dbg(ep, \"EP enabled: %s, HW:%d, MP:%d IN:%d\\n\", ep->ep.name,\n\t       ep->hwep_num, maxpacket, (ep->is_in == 1));\n\n\t \n\tudc_realize_hwep(udc, ep->hwep_num, ep->ep.maxpacket);\n\tudc_clr_buffer_hwep(udc, ep->hwep_num);\n\tuda_disable_hwepint(udc, ep->hwep_num);\n\tudc_clrstall_hwep(udc, ep->hwep_num);\n\n\t \n\tudc_ep_dma_disable(udc, ep->hwep_num);\n\twritel(1 << ep->hwep_num, USBD_EOTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_NDDRTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_SYSERRTINTCLR(udc->udp_baseaddr));\n\twritel(1 << ep->hwep_num, USBD_DMARCLR(udc->udp_baseaddr));\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tatomic_inc(&udc->enabled_ep_cnt);\n\treturn 0;\n}\n\n \nstatic struct usb_request *lpc32xx_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct lpc32xx_request *req;\n\n\treq = kzalloc(sizeof(struct lpc32xx_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->req;\n}\n\n \nstatic void lpc32xx_ep_free_request(struct usb_ep *_ep,\n\t\t\t\t    struct usb_request *_req)\n{\n\tstruct lpc32xx_request *req;\n\n\treq = container_of(_req, struct lpc32xx_request, req);\n\tBUG_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\n \nstatic int lpc32xx_ep_queue(struct usb_ep *_ep,\n\t\t\t    struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct lpc32xx_request *req;\n\tstruct lpc32xx_ep *ep;\n\tstruct lpc32xx_udc *udc;\n\tunsigned long flags;\n\tint status = 0;\n\n\treq = container_of(_req, struct lpc32xx_request, req);\n\tep = container_of(_ep, struct lpc32xx_ep, ep);\n\n\tif (!_ep || !_req || !_req->complete || !_req->buf ||\n\t    !list_empty(&req->queue))\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\n\tif (udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -EPIPE;\n\n\tif (ep->lep) {\n\t\tstruct lpc32xx_usbd_dd_gad *dd;\n\n\t\tstatus = usb_gadget_map_request(&udc->gadget, _req, ep->is_in);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tdd = udc_dd_alloc(udc);\n\t\tif (!dd) {\n\t\t\t \n\t\t\treturn -ENOMEM;\n\t\t}\n\t\treq->dd_desc_ptr = dd;\n\n\t\t \n\t\tdd->dd_next_phy = dd->dd_next_v = 0;\n\t\tdd->dd_buffer_addr = req->req.dma;\n\t\tdd->dd_status = 0;\n\n\t\t \n\t\tif (ep->eptype == EP_ISO_TYPE) {\n\t\t\tdd->dd_setup = DD_SETUP_ISO_EP |\n\t\t\t\tDD_SETUP_PACKETLEN(0) |\n\t\t\t\tDD_SETUP_DMALENBYTES(1);\n\t\t\tdd->dd_iso_ps_mem_addr = dd->this_dma + 24;\n\t\t\tif (ep->is_in)\n\t\t\t\tdd->iso_status[0] = req->req.length;\n\t\t\telse\n\t\t\t\tdd->iso_status[0] = 0;\n\t\t} else\n\t\t\tdd->dd_setup = DD_SETUP_PACKETLEN(ep->ep.maxpacket) |\n\t\t\t\tDD_SETUP_DMALENBYTES(req->req.length);\n\t}\n\n\tep_dbg(ep, \"%s queue req %p len %d buf %p (in=%d) z=%d\\n\", _ep->name,\n\t       _req, _req->length, _req->buf, ep->is_in, _req->zero);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\treq->send_zlp = _req->zero;\n\n\t \n\tif (list_empty(&ep->queue)) {\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\t\tif (ep->hwep_num_base == 0) {\n\t\t\t \n\t\t\tif (ep->is_in) {\n\t\t\t\t \n\t\t\t\tudc->ep0state = DATA_IN;\n\t\t\t\tstatus = udc_ep0_in_req(udc);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tudc->ep0state = DATA_OUT;\n\t\t\t\tstatus = udc_ep0_out_req(udc);\n\t\t\t}\n\t\t} else if (ep->is_in) {\n\t\t\t \n\t\t\tif (!ep->req_pending)\n\t\t\t\tudc_ep_in_req_dma(udc, ep);\n\t\t} else\n\t\t\t \n\t\t\tif (!ep->req_pending)\n\t\t\t\tudc_ep_out_req_dma(udc, ep);\n\t} else\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn (status < 0) ? status : 0;\n}\n\n \nstatic int lpc32xx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct lpc32xx_ep *ep;\n\tstruct lpc32xx_request *req = NULL, *iter;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct lpc32xx_ep, ep);\n\tif (!_ep || ep->hwep_num_base == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\n\tstruct lpc32xx_udc *udc;\n\tunsigned long flags;\n\n\tif ((!ep) || (ep->hwep_num <= 1))\n\t\treturn -EINVAL;\n\n\t \n\tif (ep->is_in)\n\t\treturn -EAGAIN;\n\n\tudc = ep->udc;\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (value == 1) {\n\t\t \n\t\tudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),\n\t\t\t\t\tDAT_WR_BYTE(EP_STAT_ST));\n\t} else {\n\t\t \n\t\tep->wedge = 0;\n\t\tudc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),\n\t\t\t\t\tDAT_WR_BYTE(0));\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_ep_set_wedge(struct usb_ep *_ep)\n{\n\tstruct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);\n\n\tif (!_ep || !ep->udc)\n\t\treturn -EINVAL;\n\n\tep->wedge = 1;\n\n\treturn usb_ep_set_halt(_ep);\n}\n\nstatic const struct usb_ep_ops lpc32xx_ep_ops = {\n\t.enable\t\t= lpc32xx_ep_enable,\n\t.disable\t= lpc32xx_ep_disable,\n\t.alloc_request\t= lpc32xx_ep_alloc_request,\n\t.free_request\t= lpc32xx_ep_free_request,\n\t.queue\t\t= lpc32xx_ep_queue,\n\t.dequeue\t= lpc32xx_ep_dequeue,\n\t.set_halt\t= lpc32xx_ep_set_halt,\n\t.set_wedge\t= lpc32xx_ep_set_wedge,\n};\n\n \nstatic void udc_send_in_zlp(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\n{\n\t \n\tudc_clearep_getsts(udc, ep->hwep_num);\n\n\t \n\tudc_write_hwep(udc, ep->hwep_num, NULL, 0);\n}\n\n \nstatic void udc_handle_eps(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\n{\n\tu32 epstatus;\n\tstruct lpc32xx_request *req;\n\n\tif (ep->hwep_num <= 0)\n\t\treturn;\n\n\tuda_clear_hwepint(udc, ep->hwep_num);\n\n\t \n\tif (!(udc->enabled_hwepints & (1 << ep->hwep_num)))\n\t\treturn;\n\n\t \n\tepstatus = udc_clearep_getsts(udc, ep->hwep_num);\n\n\t \n\tif (epstatus & EP_SEL_F)\n\t\treturn;\n\n\tif (ep->is_in) {\n\t\tudc_send_in_zlp(udc, ep);\n\t\tuda_disable_hwepint(udc, ep->hwep_num);\n\t} else\n\t\treturn;\n\n\t \n\treq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\n\tif (req) {\n\t\tdone(ep, req, 0);\n\n\t\t \n\t\tif (!list_empty(&ep->queue)) {\n\t\t\tif (ep->is_in)\n\t\t\t\tudc_ep_in_req_dma(udc, ep);\n\t\t\telse\n\t\t\t\tudc_ep_out_req_dma(udc, ep);\n\t\t} else\n\t\t\tep->req_pending = 0;\n\t}\n}\n\n\n \nstatic void udc_handle_dma_ep(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)\n{\n\tu32 status;\n\tstruct lpc32xx_request *req;\n\tstruct lpc32xx_usbd_dd_gad *dd;\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\tep->totalints++;\n#endif\n\n\treq = list_entry(ep->queue.next, struct lpc32xx_request, queue);\n\tif (!req) {\n\t\tep_err(ep, \"DMA interrupt on no req!\\n\");\n\t\treturn;\n\t}\n\tdd = req->dd_desc_ptr;\n\n\t \n\tif (!(dd->dd_status & DD_STATUS_DD_RETIRED))\n\t\tep_warn(ep, \"DMA descriptor did not retire\\n\");\n\n\t \n\tudc_ep_dma_disable(udc, ep->hwep_num);\n\twritel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));\n\twritel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));\n\n\t \n\tif (readl(USBD_SYSERRTINTST(udc->udp_baseaddr)) &\n\t    (1 << ep->hwep_num)) {\n\t\twritel((1 << ep->hwep_num),\n\t\t\t     USBD_SYSERRTINTCLR(udc->udp_baseaddr));\n\t\tep_err(ep, \"AHB critical error!\\n\");\n\t\tep->req_pending = 0;\n\n\t\t \n\t\tdone(ep, req, -ECONNABORTED);\n\t\treturn;\n\t}\n\n\t \n\tstatus = dd->dd_status;\n\tswitch (status & DD_STATUS_STS_MASK) {\n\tcase DD_STATUS_STS_NS:\n\t\t \n\t\tep->req_pending = 0;\n\t\tep_err(ep, \"DMA critical EP error: DD not serviced (0x%x)!\\n\",\n\t\t       status);\n\n\t\tdone(ep, req, -ECONNABORTED);\n\t\treturn;\n\n\tcase DD_STATUS_STS_BS:\n\t\t \n\t\tep->req_pending = 0;\n\t\tep_err(ep, \"DMA critical EP error: EOT prior to service completion (0x%x)!\\n\",\n\t\t       status);\n\t\tdone(ep, req, -ECONNABORTED);\n\t\treturn;\n\n\tcase DD_STATUS_STS_NC:\n\tcase DD_STATUS_STS_DUR:\n\t\t \n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tep->req_pending = 0;\n\t\tep_err(ep, \"DMA critical EP error: System error (0x%x)!\\n\",\n\t\t       status);\n\t\tdone(ep, req, -ECONNABORTED);\n\t\treturn;\n\t}\n\n\t \n\tif (ep->eptype == EP_ISO_TYPE) {\n\t\tif (ep->is_in)\n\t\t\treq->req.actual = req->req.length;\n\t\telse\n\t\t\treq->req.actual = dd->iso_status[0] & 0xFFFF;\n\t} else\n\t\treq->req.actual += DD_STATUS_CURDMACNT(status);\n\n\t \n\tif (req->send_zlp) {\n\t\t \n\t\tif (udc_clearep_getsts(udc, ep->hwep_num) & EP_SEL_F) {\n\t\t\tudc_clearep_getsts(udc, ep->hwep_num);\n\t\t\tuda_enable_hwepint(udc, ep->hwep_num);\n\t\t\tudc_clearep_getsts(udc, ep->hwep_num);\n\n\t\t\t \n\t\t\treturn;\n\t\t} else\n\t\t\tudc_send_in_zlp(udc, ep);\n\t}\n\n\t \n\tdone(ep, req, 0);\n\n\t \n\tudc_clearep_getsts(udc, ep->hwep_num);\n\tif (!list_empty((&ep->queue))) {\n\t\tif (ep->is_in)\n\t\t\tudc_ep_in_req_dma(udc, ep);\n\t\telse\n\t\t\tudc_ep_out_req_dma(udc, ep);\n\t} else\n\t\tep->req_pending = 0;\n\n}\n\n \nstatic void udc_handle_dev(struct lpc32xx_udc *udc)\n{\n\tu32 tmp;\n\n\tudc_protocol_cmd_w(udc, CMD_GET_DEV_STAT);\n\ttmp = udc_protocol_cmd_r(udc, DAT_GET_DEV_STAT);\n\n\tif (tmp & DEV_RST)\n\t\tuda_usb_reset(udc);\n\telse if (tmp & DEV_CON_CH)\n\t\tuda_power_event(udc, (tmp & DEV_CON));\n\telse if (tmp & DEV_SUS_CH) {\n\t\tif (tmp & DEV_SUS) {\n\t\t\tif (udc->vbus == 0)\n\t\t\t\tstop_activity(udc);\n\t\t\telse if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&\n\t\t\t\t udc->driver) {\n\t\t\t\t \n\t\t\t\tudc->poweron = 0;\n\t\t\t\tschedule_work(&udc->pullup_job);\n\t\t\t\tuda_resm_susp_event(udc, 1);\n\t\t\t}\n\t\t} else if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&\n\t\t\t   udc->driver && udc->vbus) {\n\t\t\tuda_resm_susp_event(udc, 0);\n\t\t\t \n\t\t\tudc->poweron = 1;\n\t\t\tschedule_work(&udc->pullup_job);\n\t\t}\n\t}\n}\n\nstatic int udc_get_status(struct lpc32xx_udc *udc, u16 reqtype, u16 wIndex)\n{\n\tstruct lpc32xx_ep *ep;\n\tu32 ep0buff = 0, tmp;\n\n\tswitch (reqtype & USB_RECIP_MASK) {\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;  \n\n\tcase USB_RECIP_DEVICE:\n\t\tep0buff = udc->gadget.is_selfpowered;\n\t\tif (udc->dev_status & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\tep0buff |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\ttmp = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tep = &udc->ep[tmp];\n\t\tif ((tmp == 0) || (tmp >= NUM_ENDPOINTS))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (wIndex & USB_DIR_IN) {\n\t\t\tif (!ep->is_in)\n\t\t\t\treturn -EOPNOTSUPP;  \n\t\t} else if (ep->is_in)\n\t\t\treturn -EOPNOTSUPP;  \n\n\t\t \n\t\tudc_protocol_cmd_w(udc, CMD_SEL_EP(ep->hwep_num));\n\t\ttmp = udc_protocol_cmd_r(udc, DAT_SEL_EP(ep->hwep_num));\n\n\t\tif (tmp & EP_SEL_ST)\n\t\t\tep0buff = (1 << USB_ENDPOINT_HALT);\n\t\telse\n\t\t\tep0buff = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tudc_write_hwep(udc, EP_IN, &ep0buff, 2);\n\n\treturn 0;\n}\n\nstatic void udc_handle_ep0_setup(struct lpc32xx_udc *udc)\n{\n\tstruct lpc32xx_ep *ep, *ep0 = &udc->ep[0];\n\tstruct usb_ctrlrequest ctrlpkt;\n\tint i, bytes;\n\tu16 wIndex, wValue, reqtype, req, tmp;\n\n\t \n\tnuke(ep0, -EPROTO);\n\n\t \n\tbytes = udc_read_hwep(udc, EP_OUT, (u32 *) &ctrlpkt, 8);\n\tif (bytes != 8) {\n\t\tep_warn(ep0, \"Incorrectly sized setup packet (s/b 8, is %d)!\\n\",\n\t\t\tbytes);\n\t\treturn;\n\t}\n\n\t \n\twIndex = le16_to_cpu(ctrlpkt.wIndex);\n\twValue = le16_to_cpu(ctrlpkt.wValue);\n\treqtype = le16_to_cpu(ctrlpkt.bRequestType);\n\n\t \n\tif (likely(reqtype & USB_DIR_IN))\n\t\tep0->is_in = 1;\n\telse\n\t\tep0->is_in = 0;\n\n\t \n\treq = le16_to_cpu(ctrlpkt.bRequest);\n\tswitch (req) {\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tswitch (reqtype) {\n\t\tcase (USB_TYPE_STANDARD | USB_RECIP_DEVICE):\n\t\t\tif (wValue != USB_DEVICE_REMOTE_WAKEUP)\n\t\t\t\tgoto stall;  \n\n\t\t\t \n\t\t\tif (req == USB_REQ_CLEAR_FEATURE)\n\t\t\t\tudc->dev_status &=\n\t\t\t\t\t~(1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\t\telse\n\t\t\t\tudc->dev_status |=\n\t\t\t\t\t(1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\t\tuda_remwkp_cgh(udc);\n\t\t\tgoto zlp_send;\n\n\t\tcase (USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):\n\t\t\ttmp = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif ((wValue != USB_ENDPOINT_HALT) ||\n\t\t\t    (tmp >= NUM_ENDPOINTS))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tep = &udc->ep[tmp];\n\t\t\ttmp = ep->hwep_num;\n\t\t\tif (tmp == 0)\n\t\t\t\tbreak;\n\n\t\t\tif (req == USB_REQ_SET_FEATURE)\n\t\t\t\tudc_stall_hwep(udc, tmp);\n\t\t\telse if (!ep->wedge)\n\t\t\t\tudc_clrstall_hwep(udc, tmp);\n\n\t\t\tgoto zlp_send;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (reqtype == (USB_TYPE_STANDARD | USB_RECIP_DEVICE)) {\n\t\t\tudc_set_address(udc, wValue);\n\t\t\tgoto zlp_send;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_GET_STATUS:\n\t\tudc_get_status(udc, reqtype, wIndex);\n\t\treturn;\n\n\tdefault:\n\t\tbreak;  \n\t}\n\n\tif (likely(udc->driver)) {\n\t\t \n\t\tspin_unlock(&udc->lock);\n\t\ti = udc->driver->setup(&udc->gadget, &ctrlpkt);\n\n\t\tspin_lock(&udc->lock);\n\t\tif (req == USB_REQ_SET_CONFIGURATION) {\n\t\t\t \n\t\t\tif (wValue) {\n\t\t\t\t \n\t\t\t\tudc_set_device_configured(udc);\n\n\t\t\t\tudc_protocol_cmd_data_w(udc, CMD_SET_MODE,\n\t\t\t\t\t\t\tDAT_WR_BYTE(AP_CLK |\n\t\t\t\t\t\t\tINAK_BI | INAK_II));\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tudc_set_device_unconfigured(udc);\n\n\t\t\t\t \n\t\t\t\tudc_protocol_cmd_data_w(udc, CMD_SET_MODE,\n\t\t\t\t\t\t\tDAT_WR_BYTE(AP_CLK));\n\t\t\t}\n\t\t}\n\n\t\tif (i < 0) {\n\t\t\t \n\t\t\tdev_dbg(udc->dev,\n\t\t\t\t\"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\treqtype, req, i);\n\t\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\t\tgoto stall;\n\t\t}\n\t}\n\n\tif (!ep0->is_in)\n\t\tudc_ep0_send_zlp(udc);  \n\n\treturn;\n\nstall:\n\tudc_stall_hwep(udc, EP_IN);\n\treturn;\n\nzlp_send:\n\tudc_ep0_send_zlp(udc);\n\treturn;\n}\n\n \nstatic void udc_handle_ep0_in(struct lpc32xx_udc *udc)\n{\n\tstruct lpc32xx_ep *ep0 = &udc->ep[0];\n\tu32 epstatus;\n\n\t \n\tepstatus = udc_clearep_getsts(udc, EP_IN);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\tep0->totalints++;\n#endif\n\n\t \n\tif (epstatus & EP_SEL_ST) {\n\t\tudc_clrstall_hwep(udc, EP_IN);\n\t\tnuke(ep0, -ECONNABORTED);\n\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\treturn;\n\t}\n\n\t \n\tif (!(epstatus & EP_SEL_F)) {\n\t\t \n\t\tif (udc->ep0state == DATA_IN)\n\t\t\tudc_ep0_in_req(udc);\n\t\telse {\n\t\t\t \n\t\t\tnuke(ep0, -ECONNABORTED);\n\t\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\t}\n\t}\n}\n\n \nstatic void udc_handle_ep0_out(struct lpc32xx_udc *udc)\n{\n\tstruct lpc32xx_ep *ep0 = &udc->ep[0];\n\tu32 epstatus;\n\n\t \n\tepstatus = udc_clearep_getsts(udc, EP_OUT);\n\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\tep0->totalints++;\n#endif\n\n\t \n\tif (epstatus & EP_SEL_ST) {\n\t\tudc_clrstall_hwep(udc, EP_OUT);\n\t\tnuke(ep0, -ECONNABORTED);\n\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\treturn;\n\t}\n\n\t \n\tif (epstatus & EP_SEL_EPN)\n\t\treturn;\n\t \n\tif (epstatus & EP_SEL_STP) {\n\t\tnuke(ep0, 0);\n\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t}\n\n\t \n\tif (epstatus & EP_SEL_F)\n\t\t \n\t\tswitch (udc->ep0state) {\n\t\tcase WAIT_FOR_SETUP:\n\t\t\tudc_handle_ep0_setup(udc);\n\t\t\tbreak;\n\n\t\tcase DATA_OUT:\n\t\t\tudc_ep0_out_req(udc);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tnuke(ep0, -ECONNABORTED);\n\t\t\tudc->ep0state = WAIT_FOR_SETUP;\n\t\t}\n}\n\n \nstatic int lpc32xx_get_frame(struct usb_gadget *gadget)\n{\n\tint frame;\n\tunsigned long flags;\n\tstruct lpc32xx_udc *udc = to_udc(gadget);\n\n\tif (!udc->clocked)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tframe = (int) udc_get_current_frame(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn frame;\n}\n\nstatic int lpc32xx_wakeup(struct usb_gadget *gadget)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int lpc32xx_set_selfpowered(struct usb_gadget *gadget, int is_on)\n{\n\tgadget->is_selfpowered = (is_on != 0);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tunsigned long flags;\n\tstruct lpc32xx_udc *udc = to_udc(gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (udc->driver) {\n\t\tudc_clk_set(udc, 1);\n\t\tudc_enable(udc);\n\t\tpullup(udc, is_active);\n\t} else {\n\t\tstop_activity(udc);\n\t\tpullup(udc, 0);\n\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t \n\t\tif (atomic_read(&udc->enabled_ep_cnt))\n\t\t\twait_event_interruptible(udc->ep_disable_wait_queue,\n\t\t\t\t (atomic_read(&udc->enabled_ep_cnt) == 0));\n\n\t\tspin_lock_irqsave(&udc->lock, flags);\n\n\t\tudc_clk_set(udc, 0);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int lpc32xx_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct lpc32xx_udc *udc = to_udc(gadget);\n\n\t \n\tpullup(udc, is_on);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_start(struct usb_gadget *, struct usb_gadget_driver *);\nstatic int lpc32xx_stop(struct usb_gadget *);\n\nstatic const struct usb_gadget_ops lpc32xx_udc_ops = {\n\t.get_frame\t\t= lpc32xx_get_frame,\n\t.wakeup\t\t\t= lpc32xx_wakeup,\n\t.set_selfpowered\t= lpc32xx_set_selfpowered,\n\t.vbus_session\t\t= lpc32xx_vbus_session,\n\t.pullup\t\t\t= lpc32xx_pullup,\n\t.udc_start\t\t= lpc32xx_start,\n\t.udc_stop\t\t= lpc32xx_stop,\n};\n\nstatic void nop_release(struct device *dev)\n{\n\t \n}\n\nstatic const struct lpc32xx_udc controller_template = {\n\t.gadget = {\n\t\t.ops\t= &lpc32xx_udc_ops,\n\t\t.name\t= driver_name,\n\t\t.dev\t= {\n\t\t\t.init_name = \"gadget\",\n\t\t\t.release = nop_release,\n\t\t}\n\t},\n\t.ep[0] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep0\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 0,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 0,\n\t\t.eptype\t\t= EP_CTL_TYPE,\n\t},\n\t.ep[1] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep1-int\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 2,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 1,\n\t\t.eptype\t\t= EP_INT_TYPE,\n\t},\n\t.ep[2] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep2-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 4,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 2,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n\t.ep[3] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep3-iso\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 1023,\n\t\t.hwep_num_base\t= 6,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 3,\n\t\t.eptype\t\t= EP_ISO_TYPE,\n\t},\n\t.ep[4] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep4-int\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 8,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 4,\n\t\t.eptype\t\t= EP_INT_TYPE,\n\t},\n\t.ep[5] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep5-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 10,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 5,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n\t.ep[6] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep6-iso\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 1023,\n\t\t.hwep_num_base\t= 12,\n\t\t.hwep_num\t= 0,  \n\t\t.lep\t\t= 6,\n\t\t.eptype\t\t= EP_ISO_TYPE,\n\t},\n\t.ep[7] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep7-int\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 14,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 7,\n\t\t.eptype\t\t= EP_INT_TYPE,\n\t},\n\t.ep[8] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep8-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 16,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 8,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n\t.ep[9] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep9-iso\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 1023,\n\t\t.hwep_num_base\t= 18,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 9,\n\t\t.eptype\t\t= EP_ISO_TYPE,\n\t},\n\t.ep[10] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep10-int\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 20,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 10,\n\t\t.eptype\t\t= EP_INT_TYPE,\n\t},\n\t.ep[11] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep11-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 22,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 11,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n\t.ep[12] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep12-iso\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 1023,\n\t\t.hwep_num_base\t= 24,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 12,\n\t\t.eptype\t\t= EP_ISO_TYPE,\n\t},\n\t.ep[13] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep13-int\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 26,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 13,\n\t\t.eptype\t\t= EP_INT_TYPE,\n\t},\n\t.ep[14] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep14-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 64,\n\t\t.hwep_num_base\t= 28,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 14,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n\t.ep[15] = {\n\t\t.ep = {\n\t\t\t.name\t= \"ep15-bulk\",\n\t\t\t.ops\t= &lpc32xx_ep_ops,\n\t\t\t.caps\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.maxpacket\t= 1023,\n\t\t.hwep_num_base\t= 30,\n\t\t.hwep_num\t= 0,\n\t\t.lep\t\t= 15,\n\t\t.eptype\t\t= EP_BLK_TYPE,\n\t},\n};\n\n \nstatic irqreturn_t lpc32xx_usb_lp_irq(int irq, void *_udc)\n{\n\tu32 tmp, devstat;\n\tstruct lpc32xx_udc *udc = _udc;\n\n\tspin_lock(&udc->lock);\n\n\t \n\tdevstat = readl(USBD_DEVINTST(udc->udp_baseaddr));\n\n\tdevstat &= ~USBD_EP_FAST;\n\twritel(devstat, USBD_DEVINTCLR(udc->udp_baseaddr));\n\tdevstat = devstat & udc->enabled_devints;\n\n\t \n\tif (devstat & USBD_DEV_STAT)\n\t\tudc_handle_dev(udc);\n\n\t \n\n\t \n\tif (devstat & ERR_INT) {\n\t\t \n\t\tudc_protocol_cmd_w(udc, CMD_RD_ERR_STAT);\n\t\ttmp = udc_protocol_cmd_r(udc, DAT_RD_ERR_STAT);\n\t\tdev_dbg(udc->dev, \"Device error (0x%x)!\\n\", tmp);\n\t}\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t lpc32xx_usb_hp_irq(int irq, void *_udc)\n{\n\tu32 tmp;\n\tstruct lpc32xx_udc *udc = _udc;\n\n\tspin_lock(&udc->lock);\n\n\t \n\twritel(USBD_EP_FAST, USBD_DEVINTCLR(udc->udp_baseaddr));\n\n\t \n\ttmp = readl(USBD_EPINTST(udc->udp_baseaddr));\n\n\t \n\tif (tmp & (EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {\n\t\t \n\t\tif (tmp & (EP_MASK_SEL(0, EP_IN)))\n\t\t\tudc_handle_ep0_in(udc);\n\n\t\t \n\t\tif (tmp & (EP_MASK_SEL(0, EP_OUT)))\n\t\t\tudc_handle_ep0_out(udc);\n\t}\n\n\t \n\tif (tmp & ~(EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 1; i < NUM_ENDPOINTS; i++) {\n\t\t\tif (tmp & (1 << udc->ep[i].hwep_num))\n\t\t\t\tudc_handle_eps(udc, &udc->ep[i]);\n\t\t}\n\t}\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t lpc32xx_usb_devdma_irq(int irq, void *_udc)\n{\n\tstruct lpc32xx_udc *udc = _udc;\n\n\tint i;\n\tu32 tmp;\n\n\tspin_lock(&udc->lock);\n\n\t \n\ttmp = readl(USBD_EOTINTST(udc->udp_baseaddr)) |\n\t\t(readl(USBD_EPDMAST(udc->udp_baseaddr)) &\n\t\t readl(USBD_NDDRTINTST(udc->udp_baseaddr))) |\n\t\treadl(USBD_SYSERRTINTST(udc->udp_baseaddr));\n\tfor (i = 1; i < NUM_ENDPOINTS; i++) {\n\t\tif (tmp & (1 << udc->ep[i].hwep_num))\n\t\t\tudc_handle_dma_ep(udc, &udc->ep[i]);\n\t}\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void vbus_work(struct lpc32xx_udc *udc)\n{\n\tu8 value;\n\n\tif (udc->enabled != 0) {\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1, OTG1_VBUS_DISCHRG);\n\n\t\t \n\t\tmsleep(100);\n\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\t\tOTG1_VBUS_DISCHRG);\n\n\t\t \n\t\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\t\tISP1301_I2C_INTERRUPT_LATCH |\n\t\t\tISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\n\t\t \n\t\tvalue = i2c_smbus_read_byte_data(udc->isp1301_i2c_client,\n\t\t\t\t\t\t ISP1301_I2C_INTERRUPT_SOURCE);\n\n\t\t \n\t\tif (value & INT_SESS_VLD)\n\t\t\tudc->vbus = 1;\n\t\telse\n\t\t\tudc->vbus = 0;\n\n\t\t \n\t\tif (udc->last_vbus != udc->vbus) {\n\t\t\tudc->last_vbus = udc->vbus;\n\t\t\tlpc32xx_vbus_session(&udc->gadget, udc->vbus);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t lpc32xx_usb_vbus_irq(int irq, void *_udc)\n{\n\tstruct lpc32xx_udc *udc = _udc;\n\n\tvbus_work(udc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int lpc32xx_start(struct usb_gadget *gadget,\n\t\t\t struct usb_gadget_driver *driver)\n{\n\tstruct lpc32xx_udc *udc = to_udc(gadget);\n\n\tif (!driver || driver->max_speed < USB_SPEED_FULL || !driver->setup) {\n\t\tdev_err(udc->dev, \"bad parameter.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udc->driver) {\n\t\tdev_err(udc->dev, \"UDC already has a gadget driver\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tudc->driver = driver;\n\tudc->gadget.dev.of_node = udc->dev->of_node;\n\tudc->enabled = 1;\n\tudc->gadget.is_selfpowered = 1;\n\tudc->vbus = 0;\n\n\t \n\tudc->last_vbus = udc->vbus = 0;\n\tvbus_work(udc);\n\n\t \n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_FALLING, INT_SESS_VLD | INT_VBUS_VLD);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_RISING, INT_SESS_VLD | INT_VBUS_VLD);\n\n\treturn 0;\n}\n\nstatic int lpc32xx_stop(struct usb_gadget *gadget)\n{\n\tstruct lpc32xx_udc *udc = to_udc(gadget);\n\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\ti2c_smbus_write_byte_data(udc->isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\n\tif (udc->clocked) {\n\t\tspin_lock(&udc->lock);\n\t\tstop_activity(udc);\n\t\tspin_unlock(&udc->lock);\n\n\t\t \n\t\tif (atomic_read(&udc->enabled_ep_cnt))\n\t\t\twait_event_interruptible(udc->ep_disable_wait_queue,\n\t\t\t\t(atomic_read(&udc->enabled_ep_cnt) == 0));\n\n\t\tspin_lock(&udc->lock);\n\t\tudc_clk_set(udc, 0);\n\t\tspin_unlock(&udc->lock);\n\t}\n\n\tudc->enabled = 0;\n\tudc->driver = NULL;\n\n\treturn 0;\n}\n\nstatic void lpc32xx_udc_shutdown(struct platform_device *dev)\n{\n\t \n\tstruct lpc32xx_udc *udc = platform_get_drvdata(dev);\n\n\tpullup(udc, 0);\n}\n\n \n\nstatic void lpc32xx_usbd_conn_chg(int conn)\n{\n\t \n}\n\nstatic void lpc32xx_usbd_susp_chg(int susp)\n{\n\t \n}\n\nstatic void lpc32xx_rmwkup_chg(int remote_wakup_enable)\n{\n\t \n}\n\nstatic struct lpc32xx_usbd_cfg lpc32xx_usbddata = {\n\t.vbus_drv_pol = 0,\n\t.conn_chgb = &lpc32xx_usbd_conn_chg,\n\t.susp_chgb = &lpc32xx_usbd_susp_chg,\n\t.rmwk_chgb = &lpc32xx_rmwkup_chg,\n};\n\n\nstatic u64 lpc32xx_usbd_dmamask = ~(u32) 0x7F;\n\nstatic int lpc32xx_udc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct lpc32xx_udc *udc;\n\tint retval, i;\n\tdma_addr_t dma_handle;\n\tstruct device_node *isp1301_node;\n\n\tudc = devm_kmemdup(dev, &controller_template, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i <= 15; i++)\n\t\tudc->ep[i].udc = udc;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\n\t \n\tudc->gadget.dev.parent = dev;\n\tudc->pdev = pdev;\n\tudc->dev = &pdev->dev;\n\tudc->enabled = 0;\n\n\tif (pdev->dev.of_node) {\n\t\tisp1301_node = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\"transceiver\", 0);\n\t} else {\n\t\tisp1301_node = NULL;\n\t}\n\n\tudc->isp1301_i2c_client = isp1301_get_client(isp1301_node);\n\tof_node_put(isp1301_node);\n\tif (!udc->isp1301_i2c_client) {\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tdev_info(udc->dev, \"ISP1301 I2C device at address 0x%x\\n\",\n\t\t udc->isp1301_i2c_client->addr);\n\n\tpdev->dev.dma_mask = &lpc32xx_usbd_dmamask;\n\tretval = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (retval)\n\t\treturn retval;\n\n\tudc->board = &lpc32xx_usbddata;\n\n\t \n\n\tspin_lock_init(&udc->lock);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tudc->udp_irq[i] = platform_get_irq(pdev, i);\n\t\tif (udc->udp_irq[i] < 0)\n\t\t\treturn udc->udp_irq[i];\n\t}\n\n\tudc->udp_baseaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->udp_baseaddr)) {\n\t\tdev_err(udc->dev, \"IO map failure\\n\");\n\t\treturn PTR_ERR(udc->udp_baseaddr);\n\t}\n\n\t \n\tudc->usb_slv_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(udc->usb_slv_clk)) {\n\t\tdev_err(udc->dev, \"failed to acquire USB device clock\\n\");\n\t\treturn PTR_ERR(udc->usb_slv_clk);\n\t}\n\n\t \n\tretval = clk_prepare_enable(udc->usb_slv_clk);\n\tif (retval < 0) {\n\t\tdev_err(udc->dev, \"failed to start USB device clock\\n\");\n\t\treturn retval;\n\t}\n\n\t \n\tudc->poweron = udc->pullup = 0;\n\tINIT_WORK(&udc->pullup_job, pullup_work);\n#ifdef CONFIG_PM\n\tINIT_WORK(&udc->power_job, power_work);\n#endif\n\n\t \n\tudc->clocked = 1;\n\n\tisp1301_udc_configure(udc);\n\t \n\tudc->udca_v_base = dma_alloc_coherent(&pdev->dev, UDCA_BUFF_SIZE,\n\t\t\t\t\t      &dma_handle,\n\t\t\t\t\t      (GFP_KERNEL | GFP_DMA));\n\tif (!udc->udca_v_base) {\n\t\tdev_err(udc->dev, \"error getting UDCA region\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto i2c_fail;\n\t}\n\tudc->udca_p_base = dma_handle;\n\tdev_dbg(udc->dev, \"DMA buffer(0x%x bytes), P:0x%08x, V:0x%p\\n\",\n\t\tUDCA_BUFF_SIZE, udc->udca_p_base, udc->udca_v_base);\n\n\t \n\tudc->dd_cache = dma_pool_create(\"udc_dd\", udc->dev,\n\t\t\t\t\tsizeof(struct lpc32xx_usbd_dd_gad),\n\t\t\t\t\tsizeof(u32), 0);\n\tif (!udc->dd_cache) {\n\t\tdev_err(udc->dev, \"error getting DD DMA region\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto dma_alloc_fail;\n\t}\n\n\t \n\tudc_disable(udc);\n\tudc_reinit(udc);\n\n\t \n\tretval = devm_request_irq(dev, udc->udp_irq[IRQ_USB_LP],\n\t\t\t\t  lpc32xx_usb_lp_irq, 0, \"udc_lp\", udc);\n\tif (retval < 0) {\n\t\tdev_err(udc->dev, \"LP request irq %d failed\\n\",\n\t\t\tudc->udp_irq[IRQ_USB_LP]);\n\t\tgoto irq_req_fail;\n\t}\n\tretval = devm_request_irq(dev, udc->udp_irq[IRQ_USB_HP],\n\t\t\t\t  lpc32xx_usb_hp_irq, 0, \"udc_hp\", udc);\n\tif (retval < 0) {\n\t\tdev_err(udc->dev, \"HP request irq %d failed\\n\",\n\t\t\tudc->udp_irq[IRQ_USB_HP]);\n\t\tgoto irq_req_fail;\n\t}\n\n\tretval = devm_request_irq(dev, udc->udp_irq[IRQ_USB_DEVDMA],\n\t\t\t\t  lpc32xx_usb_devdma_irq, 0, \"udc_dma\", udc);\n\tif (retval < 0) {\n\t\tdev_err(udc->dev, \"DEV request irq %d failed\\n\",\n\t\t\tudc->udp_irq[IRQ_USB_DEVDMA]);\n\t\tgoto irq_req_fail;\n\t}\n\n\t \n\tretval = devm_request_threaded_irq(dev, udc->udp_irq[IRQ_USB_ATX], NULL,\n\t\t\t\t\t   lpc32xx_usb_vbus_irq, IRQF_ONESHOT,\n\t\t\t\t\t   \"udc_otg\", udc);\n\tif (retval < 0) {\n\t\tdev_err(udc->dev, \"VBUS request irq %d failed\\n\",\n\t\t\tudc->udp_irq[IRQ_USB_ATX]);\n\t\tgoto irq_req_fail;\n\t}\n\n\t \n\tinit_waitqueue_head(&udc->ep_disable_wait_queue);\n\tatomic_set(&udc->enabled_ep_cnt, 0);\n\n\tretval = usb_add_gadget_udc(dev, &udc->gadget);\n\tif (retval < 0)\n\t\tgoto add_gadget_fail;\n\n\tdev_set_drvdata(dev, udc);\n\tdevice_init_wakeup(dev, 1);\n\tcreate_debug_file(udc);\n\n\t \n\tudc_clk_set(udc, 0);\n\n\tdev_info(udc->dev, \"%s version %s\\n\", driver_name, DRIVER_VERSION);\n\treturn 0;\n\nadd_gadget_fail:\nirq_req_fail:\n\tdma_pool_destroy(udc->dd_cache);\ndma_alloc_fail:\n\tdma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,\n\t\t\t  udc->udca_v_base, udc->udca_p_base);\ni2c_fail:\n\tclk_disable_unprepare(udc->usb_slv_clk);\n\tdev_err(udc->dev, \"%s probe failed, %d\\n\", driver_name, retval);\n\n\treturn retval;\n}\n\nstatic int lpc32xx_udc_remove(struct platform_device *pdev)\n{\n\tstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tif (udc->driver)\n\t\treturn -EBUSY;\n\n\tudc_clk_set(udc, 1);\n\tudc_disable(udc);\n\tpullup(udc, 0);\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tremove_debug_file(udc);\n\n\tdma_pool_destroy(udc->dd_cache);\n\tdma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,\n\t\t\t  udc->udca_v_base, udc->udca_p_base);\n\n\tclk_disable_unprepare(udc->usb_slv_clk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int lpc32xx_udc_suspend(struct platform_device *pdev, pm_message_t mesg)\n{\n\tstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\n\n\tif (udc->clocked) {\n\t\t \n\t\tudc->poweron = 0;\n\t\tisp1301_set_powerstate(udc, 0);\n\n\t\t \n\t\tudc_clk_set(udc, 0);\n\n\t\t \n\t\tudc->clocked = 1;\n\n\t\t \n\t\tclk_disable_unprepare(udc->usb_slv_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int lpc32xx_udc_resume(struct platform_device *pdev)\n{\n\tstruct lpc32xx_udc *udc = platform_get_drvdata(pdev);\n\n\tif (udc->clocked) {\n\t\t \n\t\tclk_prepare_enable(udc->usb_slv_clk);\n\n\t\t \n\t\tudc_clk_set(udc, 1);\n\n\t\t \n\t\tudc->poweron = 1;\n\t\tisp1301_set_powerstate(udc, 1);\n\t}\n\n\treturn 0;\n}\n#else\n#define\tlpc32xx_udc_suspend\tNULL\n#define\tlpc32xx_udc_resume\tNULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id lpc32xx_udc_of_match[] = {\n\t{ .compatible = \"nxp,lpc3220-udc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, lpc32xx_udc_of_match);\n#endif\n\nstatic struct platform_driver lpc32xx_udc_driver = {\n\t.remove\t\t= lpc32xx_udc_remove,\n\t.shutdown\t= lpc32xx_udc_shutdown,\n\t.suspend\t= lpc32xx_udc_suspend,\n\t.resume\t\t= lpc32xx_udc_resume,\n\t.driver\t\t= {\n\t\t.name\t= driver_name,\n\t\t.of_match_table = of_match_ptr(lpc32xx_udc_of_match),\n\t},\n};\n\nmodule_platform_driver_probe(lpc32xx_udc_driver, lpc32xx_udc_probe);\n\nMODULE_DESCRIPTION(\"LPC32XX udc driver\");\nMODULE_AUTHOR(\"Kevin Wells <kevin.wells@nxp.com>\");\nMODULE_AUTHOR(\"Roland Stigge <stigge@antcom.de>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:lpc32xx_udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}