{
  "module_name": "core.c",
  "hash_id": "5b14ee00f0021ace5a6b7faafbfbc3d44e0ef176855f01d69f1fd9a111908c98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed-vhub/core.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n\n#include \"vhub.h\"\n\nvoid ast_vhub_done(struct ast_vhub_ep *ep, struct ast_vhub_req *req,\n\t\t   int status)\n{\n\tbool internal = req->internal;\n\tstruct ast_vhub *vhub = ep->vhub;\n\n\tEPVDBG(ep, \"completing request @%p, status %d\\n\", req, status);\n\n\tlist_del_init(&req->queue);\n\n\tif ((req->req.status == -EINPROGRESS) ||  (status == -EOVERFLOW))\n\t\treq->req.status = status;\n\n\tif (req->req.dma) {\n\t\tif (!WARN_ON(!ep->dev))\n\t\t\tusb_gadget_unmap_request_by_dev(&vhub->pdev->dev,\n\t\t\t\t\t\t &req->req, ep->epn.is_in);\n\t\treq->req.dma = 0;\n\t}\n\n\t \n\tif (!internal) {\n\t\tspin_unlock(&ep->vhub->lock);\n\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\tspin_lock(&ep->vhub->lock);\n\t}\n}\n\nvoid ast_vhub_nuke(struct ast_vhub_ep *ep, int status)\n{\n\tstruct ast_vhub_req *req;\n\tint count = 0;\n\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct ast_vhub_req, queue);\n\t\tast_vhub_done(ep, req, status);\n\t\tcount++;\n\t}\n\tif (count)\n\t\tEPDBG(ep, \"Nuked %d request(s)\\n\", count);\n}\n\nstruct usb_request *ast_vhub_alloc_request(struct usb_ep *u_ep,\n\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct ast_vhub_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\treturn &req->req;\n}\n\nvoid ast_vhub_free_request(struct usb_ep *u_ep, struct usb_request *u_req)\n{\n\tstruct ast_vhub_req *req = to_ast_req(u_req);\n\n\tkfree(req);\n}\n\nstatic irqreturn_t ast_vhub_irq(int irq, void *data)\n{\n\tstruct ast_vhub *vhub = data;\n\tirqreturn_t iret = IRQ_NONE;\n\tu32 i, istat;\n\n\t \n\tif (!vhub->ep0_bufs)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&vhub->lock);\n\n\t \n\tistat = readl(vhub->regs + AST_VHUB_ISR);\n\tif (!istat)\n\t\tgoto bail;\n\twritel(istat, vhub->regs + AST_VHUB_ISR);\n\tiret = IRQ_HANDLED;\n\n\tUDCVDBG(vhub, \"irq status=%08x, ep_acks=%08x ep_nacks=%08x\\n\",\n\t       istat,\n\t       readl(vhub->regs + AST_VHUB_EP_ACK_ISR),\n\t       readl(vhub->regs + AST_VHUB_EP_NACK_ISR));\n\n\t \n\tif (istat & VHUB_IRQ_EP_POOL_ACK_STALL) {\n\t\tu32 ep_acks = readl(vhub->regs + AST_VHUB_EP_ACK_ISR);\n\t\twritel(ep_acks, vhub->regs + AST_VHUB_EP_ACK_ISR);\n\n\t\tfor (i = 0; ep_acks && i < vhub->max_epns; i++) {\n\t\t\tu32 mask = VHUB_EP_IRQ(i);\n\t\t\tif (ep_acks & mask) {\n\t\t\t\tast_vhub_epn_ack_irq(&vhub->epns[i]);\n\t\t\t\tep_acks &= ~mask;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (istat & vhub->port_irq_mask) {\n\t\tfor (i = 0; i < vhub->max_ports; i++) {\n\t\t\tif (istat & VHUB_DEV_IRQ(i))\n\t\t\t\tast_vhub_dev_irq(&vhub->ports[i].dev);\n\t\t}\n\t}\n\n\t \n\tif (istat & (VHUB_IRQ_HUB_EP0_OUT_ACK_STALL |\n\t\t     VHUB_IRQ_HUB_EP0_IN_ACK_STALL |\n\t\t     VHUB_IRQ_HUB_EP0_SETUP)) {\n\t\tif (istat & VHUB_IRQ_HUB_EP0_IN_ACK_STALL)\n\t\t\tast_vhub_ep0_handle_ack(&vhub->ep0, true);\n\t\tif (istat & VHUB_IRQ_HUB_EP0_OUT_ACK_STALL)\n\t\t\tast_vhub_ep0_handle_ack(&vhub->ep0, false);\n\t\tif (istat & VHUB_IRQ_HUB_EP0_SETUP)\n\t\t\tast_vhub_ep0_handle_setup(&vhub->ep0);\n\t}\n\n\t \n\tif (istat & (VHUB_IRQ_BUS_RESUME |\n\t\t     VHUB_IRQ_BUS_SUSPEND |\n\t\t     VHUB_IRQ_BUS_RESET)) {\n\t\tif (istat & VHUB_IRQ_BUS_RESUME)\n\t\t\tast_vhub_hub_resume(vhub);\n\t\tif (istat & VHUB_IRQ_BUS_SUSPEND)\n\t\t\tast_vhub_hub_suspend(vhub);\n\t\tif (istat & VHUB_IRQ_BUS_RESET)\n\t\t\tast_vhub_hub_reset(vhub);\n\t}\n\n bail:\n\tspin_unlock(&vhub->lock);\n\treturn iret;\n}\n\nvoid ast_vhub_init_hw(struct ast_vhub *vhub)\n{\n\tu32 ctrl, port_mask, epn_mask;\n\n\tUDCDBG(vhub,\"(Re)Starting HW ...\\n\");\n\n\t \n\tctrl = VHUB_CTRL_PHY_CLK |\n\t\tVHUB_CTRL_PHY_RESET_DIS;\n\n        \n\n\t \n\tctrl |= VHUB_CTRL_ISO_RSP_CTRL | VHUB_CTRL_SPLIT_IN;\n\twritel(ctrl, vhub->regs + AST_VHUB_CTRL);\n\tudelay(1);\n\n\t \n\tif (AST_VHUB_DESCS_COUNT == 256) {\n\t\tctrl |= VHUB_CTRL_LONG_DESC;\n\t\twritel(ctrl, vhub->regs + AST_VHUB_CTRL);\n\t} else {\n\t\tBUILD_BUG_ON(AST_VHUB_DESCS_COUNT != 32);\n\t}\n\n\t \n\tport_mask = GENMASK(vhub->max_ports, 1);\n\twritel(VHUB_SW_RESET_ROOT_HUB |\n\t       VHUB_SW_RESET_DMA_CONTROLLER |\n\t       VHUB_SW_RESET_EP_POOL |\n\t       port_mask, vhub->regs + AST_VHUB_SW_RESET);\n\tudelay(1);\n\twritel(0, vhub->regs + AST_VHUB_SW_RESET);\n\n\t \n\tepn_mask = GENMASK(vhub->max_epns - 1, 0);\n\twritel(0, vhub->regs + AST_VHUB_EP_ACK_IER);\n\twritel(0, vhub->regs + AST_VHUB_EP_NACK_IER);\n\twritel(epn_mask, vhub->regs + AST_VHUB_EP_ACK_ISR);\n\twritel(epn_mask, vhub->regs + AST_VHUB_EP_NACK_ISR);\n\n\t \n\twritel(0, vhub->regs + AST_VHUB_EP0_CTRL);\n\twritel(VHUB_EP1_CTRL_RESET_TOGGLE |\n\t       VHUB_EP1_CTRL_ENABLE,\n\t       vhub->regs + AST_VHUB_EP1_CTRL);\n\twritel(0, vhub->regs + AST_VHUB_EP1_STS_CHG);\n\n\t \n\twritel(vhub->ep0.buf_dma, vhub->regs + AST_VHUB_EP0_DATA);\n\n\t \n\twritel(0, vhub->regs + AST_VHUB_CONF);\n\n\t \n\tif (vhub->force_usb1)\n\t\tctrl |= VHUB_CTRL_FULL_SPEED_ONLY;\n\n\tctrl |= VHUB_CTRL_UPSTREAM_CONNECT;\n\twritel(ctrl, vhub->regs + AST_VHUB_CTRL);\n\n\t \n\twritel(VHUB_IRQ_HUB_EP0_IN_ACK_STALL |\n\t       VHUB_IRQ_HUB_EP0_OUT_ACK_STALL |\n\t       VHUB_IRQ_HUB_EP0_SETUP |\n\t       VHUB_IRQ_EP_POOL_ACK_STALL |\n\t       VHUB_IRQ_BUS_RESUME |\n\t       VHUB_IRQ_BUS_SUSPEND |\n\t       VHUB_IRQ_BUS_RESET,\n\t       vhub->regs + AST_VHUB_IER);\n}\n\nstatic void ast_vhub_remove(struct platform_device *pdev)\n{\n\tstruct ast_vhub *vhub = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\tint i;\n\n\tif (!vhub || !vhub->regs)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < vhub->max_ports; i++)\n\t\tast_vhub_del_dev(&vhub->ports[i].dev);\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\twritel(0, vhub->regs + AST_VHUB_IER);\n\twritel(VHUB_IRQ_ACK_ALL, vhub->regs + AST_VHUB_ISR);\n\n\t \n\twritel(VHUB_CTRL_PHY_CLK |\n\t       VHUB_CTRL_PHY_RESET_DIS,\n\t       vhub->regs + AST_VHUB_CTRL);\n\n\tif (vhub->clk)\n\t\tclk_disable_unprepare(vhub->clk);\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\tif (vhub->ep0_bufs)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  AST_VHUB_EP0_MAX_PACKET *\n\t\t\t\t  (vhub->max_ports + 1),\n\t\t\t\t  vhub->ep0_bufs,\n\t\t\t\t  vhub->ep0_bufs_dma);\n\tvhub->ep0_bufs = NULL;\n}\n\nstatic int ast_vhub_probe(struct platform_device *pdev)\n{\n\tenum usb_device_speed max_speed;\n\tstruct ast_vhub *vhub;\n\tstruct resource *res;\n\tint i, rc = 0;\n\tconst struct device_node *np = pdev->dev.of_node;\n\n\tvhub = devm_kzalloc(&pdev->dev, sizeof(*vhub), GFP_KERNEL);\n\tif (!vhub)\n\t\treturn -ENOMEM;\n\n\trc = of_property_read_u32(np, \"aspeed,vhub-downstream-ports\",\n\t\t\t\t  &vhub->max_ports);\n\tif (rc < 0)\n\t\tvhub->max_ports = AST_VHUB_NUM_PORTS;\n\n\tvhub->ports = devm_kcalloc(&pdev->dev, vhub->max_ports,\n\t\t\t\t   sizeof(*vhub->ports), GFP_KERNEL);\n\tif (!vhub->ports)\n\t\treturn -ENOMEM;\n\n\trc = of_property_read_u32(np, \"aspeed,vhub-generic-endpoints\",\n\t\t\t\t  &vhub->max_epns);\n\tif (rc < 0)\n\t\tvhub->max_epns = AST_VHUB_NUM_GEN_EPs;\n\n\tvhub->epns = devm_kcalloc(&pdev->dev, vhub->max_epns,\n\t\t\t\t  sizeof(*vhub->epns), GFP_KERNEL);\n\tif (!vhub->epns)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&vhub->lock);\n\tvhub->pdev = pdev;\n\tvhub->port_irq_mask = GENMASK(VHUB_IRQ_DEV1_BIT + vhub->max_ports - 1,\n\t\t\t\t      VHUB_IRQ_DEV1_BIT);\n\n\tvhub->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(vhub->regs)) {\n\t\tdev_err(&pdev->dev, \"Failed to map resources\\n\");\n\t\treturn PTR_ERR(vhub->regs);\n\t}\n\tUDCDBG(vhub, \"vHub@%pR mapped @%p\\n\", res, vhub->regs);\n\n\tplatform_set_drvdata(pdev, vhub);\n\n\tvhub->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(vhub->clk)) {\n\t\trc = PTR_ERR(vhub->clk);\n\t\tgoto err;\n\t}\n\trc = clk_prepare_enable(vhub->clk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Error couldn't enable clock (%d)\\n\", rc);\n\t\tgoto err;\n\t}\n\n\t \n\tmax_speed = usb_get_maximum_speed(&pdev->dev);\n\tif (max_speed != USB_SPEED_UNKNOWN && max_speed < USB_SPEED_HIGH)\n\t\tvhub->force_usb1 = true;\n\n\t \n\twritel(0, vhub->regs + AST_VHUB_IER);\n\twritel(VHUB_IRQ_ACK_ALL, vhub->regs + AST_VHUB_ISR);\n\n\t \n\tvhub->irq = platform_get_irq(pdev, 0);\n\tif (vhub->irq < 0) {\n\t\trc = vhub->irq;\n\t\tgoto err;\n\t}\n\trc = devm_request_irq(&pdev->dev, vhub->irq, ast_vhub_irq, 0,\n\t\t\t      KBUILD_MODNAME, vhub);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to request interrupt\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tvhub->ep0_bufs = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t    AST_VHUB_EP0_MAX_PACKET *\n\t\t\t\t\t    (vhub->max_ports + 1),\n\t\t\t\t\t    &vhub->ep0_bufs_dma, GFP_KERNEL);\n\tif (!vhub->ep0_bufs) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate EP0 DMA buffers\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto err;\n\t}\n\tUDCVDBG(vhub, \"EP0 DMA buffers @%p (DMA 0x%08x)\\n\",\n\t\tvhub->ep0_bufs, (u32)vhub->ep0_bufs_dma);\n\n\t \n\tast_vhub_init_ep0(vhub, &vhub->ep0, NULL);\n\n\t \n\tfor (i = 0; i < vhub->max_ports && rc == 0; i++)\n\t\trc = ast_vhub_init_dev(vhub, i);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\trc = ast_vhub_init_hub(vhub);\n\tif (rc)\n\t\tgoto err;\n\n\t \n\tast_vhub_init_hw(vhub);\n\n\tdev_info(&pdev->dev, \"Initialized virtual hub in USB%d mode\\n\",\n\t\t vhub->force_usb1 ? 1 : 2);\n\n\treturn 0;\n err:\n\tast_vhub_remove(pdev);\n\treturn rc;\n}\n\nstatic const struct of_device_id ast_vhub_dt_ids[] = {\n\t{\n\t\t.compatible = \"aspeed,ast2400-usb-vhub\",\n\t},\n\t{\n\t\t.compatible = \"aspeed,ast2500-usb-vhub\",\n\t},\n\t{\n\t\t.compatible = \"aspeed,ast2600-usb-vhub\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ast_vhub_dt_ids);\n\nstatic struct platform_driver ast_vhub_driver = {\n\t.probe\t\t= ast_vhub_probe,\n\t.remove_new\t= ast_vhub_remove,\n\t.driver\t\t= {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.of_match_table\t= ast_vhub_dt_ids,\n\t},\n};\nmodule_platform_driver(ast_vhub_driver);\n\nMODULE_DESCRIPTION(\"Aspeed vHub udc driver\");\nMODULE_AUTHOR(\"Benjamin Herrenschmidt <benh@kernel.crashing.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}