{
  "module_name": "hub.c",
  "hash_id": "83464406c56d4a738f088be0f263e98600971e71b1471792fe6136cce368170a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed-vhub/hub.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/bcd.h>\n#include <linux/version.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"vhub.h\"\n\n \n#define KERNEL_REL\tbin2bcd(LINUX_VERSION_MAJOR)\n#define KERNEL_VER\tbin2bcd(LINUX_VERSION_PATCHLEVEL)\n\nenum {\n\tAST_VHUB_STR_INDEX_MAX = 4,\n\tAST_VHUB_STR_MANUF = 3,\n\tAST_VHUB_STR_PRODUCT = 2,\n\tAST_VHUB_STR_SERIAL = 1,\n};\n\nstatic const struct usb_device_descriptor ast_vhub_dev_desc = {\n\t.bLength\t\t= USB_DT_DEVICE_SIZE,\n\t.bDescriptorType\t= USB_DT_DEVICE,\n\t.bcdUSB\t\t\t= cpu_to_le16(0x0200),\n\t.bDeviceClass\t\t= USB_CLASS_HUB,\n\t.bDeviceSubClass\t= 0,\n\t.bDeviceProtocol\t= 1,\n\t.bMaxPacketSize0\t= 64,\n\t.idVendor\t\t= cpu_to_le16(0x1d6b),\n\t.idProduct\t\t= cpu_to_le16(0x0107),\n\t.bcdDevice\t\t= cpu_to_le16(0x0100),\n\t.iManufacturer\t\t= AST_VHUB_STR_MANUF,\n\t.iProduct\t\t= AST_VHUB_STR_PRODUCT,\n\t.iSerialNumber\t\t= AST_VHUB_STR_SERIAL,\n\t.bNumConfigurations\t= 1,\n};\n\nstatic const struct usb_qualifier_descriptor ast_vhub_qual_desc = {\n\t.bLength = 0xA,\n\t.bDescriptorType = USB_DT_DEVICE_QUALIFIER,\n\t.bcdUSB = cpu_to_le16(0x0200),\n\t.bDeviceClass = USB_CLASS_HUB,\n\t.bDeviceSubClass = 0,\n\t.bDeviceProtocol = 0,\n\t.bMaxPacketSize0 = 64,\n\t.bNumConfigurations = 1,\n\t.bRESERVED = 0,\n};\n\n \n\n \n#define AST_VHUB_CONF_DESC_SIZE\t(USB_DT_CONFIG_SIZE + \\\n\t\t\t\t USB_DT_INTERFACE_SIZE + \\\n\t\t\t\t USB_DT_ENDPOINT_SIZE)\n\nstatic const struct ast_vhub_full_cdesc ast_vhub_conf_desc = {\n\t.cfg = {\n\t\t.bLength\t\t= USB_DT_CONFIG_SIZE,\n\t\t.bDescriptorType\t= USB_DT_CONFIG,\n\t\t.wTotalLength\t\t= cpu_to_le16(AST_VHUB_CONF_DESC_SIZE),\n\t\t.bNumInterfaces\t\t= 1,\n\t\t.bConfigurationValue\t= 1,\n\t\t.iConfiguration\t\t= 0,\n\t\t.bmAttributes\t\t= USB_CONFIG_ATT_ONE |\n\t\t\t\t\t  USB_CONFIG_ATT_SELFPOWER |\n\t\t\t\t\t  USB_CONFIG_ATT_WAKEUP,\n\t\t.bMaxPower\t\t= 0,\n\t},\n\t.intf = {\n\t\t.bLength\t\t= USB_DT_INTERFACE_SIZE,\n\t\t.bDescriptorType\t= USB_DT_INTERFACE,\n\t\t.bInterfaceNumber\t= 0,\n\t\t.bAlternateSetting\t= 0,\n\t\t.bNumEndpoints\t\t= 1,\n\t\t.bInterfaceClass\t= USB_CLASS_HUB,\n\t\t.bInterfaceSubClass\t= 0,\n\t\t.bInterfaceProtocol\t= 0,\n\t\t.iInterface\t\t= 0,\n\t},\n\t.ep = {\n\t\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t\t.bEndpointAddress\t= 0x81,\n\t\t.bmAttributes\t\t= USB_ENDPOINT_XFER_INT,\n\t\t.wMaxPacketSize\t\t= cpu_to_le16(1),\n\t\t.bInterval\t\t= 0x0c,\n\t},\n};\n\n#define AST_VHUB_HUB_DESC_SIZE\t(USB_DT_HUB_NONVAR_SIZE + 2)\n\nstatic const struct usb_hub_descriptor ast_vhub_hub_desc = {\n\t.bDescLength\t\t\t= AST_VHUB_HUB_DESC_SIZE,\n\t.bDescriptorType\t\t= USB_DT_HUB,\n\t.bNbrPorts\t\t\t= AST_VHUB_NUM_PORTS,\n\t.wHubCharacteristics\t\t= cpu_to_le16(HUB_CHAR_NO_LPSM),\n\t.bPwrOn2PwrGood\t\t\t= 10,\n\t.bHubContrCurrent\t\t= 0,\n\t.u.hs.DeviceRemovable[0]\t= 0,\n\t.u.hs.DeviceRemovable[1]\t= 0xff,\n};\n\n \nstatic const struct usb_string ast_vhub_str_array[] = {\n\t{\n\t\t.id = AST_VHUB_STR_SERIAL,\n\t\t.s = \"00000000\"\n\t},\n\t{\n\t\t.id = AST_VHUB_STR_PRODUCT,\n\t\t.s = \"USB Virtual Hub\"\n\t},\n\t{\n\t\t.id = AST_VHUB_STR_MANUF,\n\t\t.s = \"Aspeed\"\n\t},\n\t{ }\n};\n\nstatic const struct usb_gadget_strings ast_vhub_strings = {\n\t.language = 0x0409,\n\t.strings = (struct usb_string *)ast_vhub_str_array\n};\n\nstatic int ast_vhub_hub_dev_status(struct ast_vhub_ep *ep,\n\t\t\t\t   u16 wIndex, u16 wValue)\n{\n\tu8 st0;\n\n\tEPDBG(ep, \"GET_STATUS(dev)\\n\");\n\n\t \n\tst0 = 1 << USB_DEVICE_SELF_POWERED;\n\n\t \n\tif (ep->vhub->wakeup_en)\n\t\tst0 |= 1 << USB_DEVICE_REMOTE_WAKEUP;\n\n\treturn ast_vhub_simple_reply(ep, st0, 0);\n}\n\nstatic int ast_vhub_hub_ep_status(struct ast_vhub_ep *ep,\n\t\t\t\t  u16 wIndex, u16 wValue)\n{\n\tint ep_num;\n\tu8 st0 = 0;\n\n\tep_num = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\tEPDBG(ep, \"GET_STATUS(ep%d)\\n\", ep_num);\n\n\t \n\tif (ep_num == 1) {\n\t\tif (ep->vhub->ep1_stalled)\n\t\t\tst0 |= 1 << USB_ENDPOINT_HALT;\n\t} else if (ep_num != 0)\n\t\treturn std_req_stall;\n\n\treturn ast_vhub_simple_reply(ep, st0, 0);\n}\n\nstatic int ast_vhub_hub_dev_feature(struct ast_vhub_ep *ep,\n\t\t\t\t    u16 wIndex, u16 wValue,\n\t\t\t\t    bool is_set)\n{\n\tu32 val;\n\n\tEPDBG(ep, \"%s_FEATURE(dev val=%02x)\\n\",\n\t      is_set ? \"SET\" : \"CLEAR\", wValue);\n\n\tif (wValue == USB_DEVICE_REMOTE_WAKEUP) {\n\t\tep->vhub->wakeup_en = is_set;\n\t\tEPDBG(ep, \"Hub remote wakeup %s\\n\",\n\t\t      is_set ? \"enabled\" : \"disabled\");\n\t\treturn std_req_complete;\n\t}\n\n\tif (wValue == USB_DEVICE_TEST_MODE) {\n\t\tval = readl(ep->vhub->regs + AST_VHUB_CTRL);\n\t\tval &= ~GENMASK(10, 8);\n\t\tval |= VHUB_CTRL_SET_TEST_MODE((wIndex >> 8) & 0x7);\n\t\twritel(val, ep->vhub->regs + AST_VHUB_CTRL);\n\n\t\treturn std_req_complete;\n\t}\n\n\treturn std_req_stall;\n}\n\nstatic int ast_vhub_hub_ep_feature(struct ast_vhub_ep *ep,\n\t\t\t\t   u16 wIndex, u16 wValue,\n\t\t\t\t   bool is_set)\n{\n\tint ep_num;\n\tu32 reg;\n\n\tep_num = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\tEPDBG(ep, \"%s_FEATURE(ep%d val=%02x)\\n\",\n\t      is_set ? \"SET\" : \"CLEAR\", ep_num, wValue);\n\n\tif (ep_num > 1)\n\t\treturn std_req_stall;\n\tif (wValue != USB_ENDPOINT_HALT)\n\t\treturn std_req_stall;\n\tif (ep_num == 0)\n\t\treturn std_req_complete;\n\n\tEPDBG(ep, \"%s stall on EP 1\\n\",\n\t      is_set ? \"setting\" : \"clearing\");\n\n\tep->vhub->ep1_stalled = is_set;\n\treg = readl(ep->vhub->regs + AST_VHUB_EP1_CTRL);\n\tif (is_set) {\n\t\treg |= VHUB_EP1_CTRL_STALL;\n\t} else {\n\t\treg &= ~VHUB_EP1_CTRL_STALL;\n\t\treg |= VHUB_EP1_CTRL_RESET_TOGGLE;\n\t}\n\twritel(reg, ep->vhub->regs + AST_VHUB_EP1_CTRL);\n\n\treturn std_req_complete;\n}\n\nstatic int ast_vhub_rep_desc(struct ast_vhub_ep *ep,\n\t\t\t     u8 desc_type, u16 len)\n{\n\tsize_t dsize;\n\tstruct ast_vhub *vhub = ep->vhub;\n\n\tEPDBG(ep, \"GET_DESCRIPTOR(type:%d)\\n\", desc_type);\n\n\t \n\tswitch(desc_type) {\n\tcase USB_DT_DEVICE:\n\t\tdsize = USB_DT_DEVICE_SIZE;\n\t\tmemcpy(ep->buf, &vhub->vhub_dev_desc, dsize);\n\t\tBUILD_BUG_ON(dsize > sizeof(vhub->vhub_dev_desc));\n\t\tBUILD_BUG_ON(USB_DT_DEVICE_SIZE >= AST_VHUB_EP0_MAX_PACKET);\n\t\tbreak;\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\tcase USB_DT_CONFIG:\n\t\tdsize = AST_VHUB_CONF_DESC_SIZE;\n\t\tmemcpy(ep->buf, &vhub->vhub_conf_desc, dsize);\n\t\t((u8 *)ep->buf)[1] = desc_type;\n\t\tBUILD_BUG_ON(dsize > sizeof(vhub->vhub_conf_desc));\n\t\tBUILD_BUG_ON(AST_VHUB_CONF_DESC_SIZE >= AST_VHUB_EP0_MAX_PACKET);\n\t\tbreak;\n\tcase USB_DT_HUB:\n\t\tdsize = AST_VHUB_HUB_DESC_SIZE;\n\t\tmemcpy(ep->buf, &vhub->vhub_hub_desc, dsize);\n\t\tBUILD_BUG_ON(dsize > sizeof(vhub->vhub_hub_desc));\n\t\tBUILD_BUG_ON(AST_VHUB_HUB_DESC_SIZE >= AST_VHUB_EP0_MAX_PACKET);\n\t\tbreak;\n\tcase USB_DT_DEVICE_QUALIFIER:\n\t\tdsize = sizeof(vhub->vhub_qual_desc);\n\t\tmemcpy(ep->buf, &vhub->vhub_qual_desc, dsize);\n\t\tbreak;\n\tdefault:\n\t\treturn std_req_stall;\n\t}\n\n\t \n\tif (len > dsize)\n\t\tlen = dsize;\n\n\t \n\treturn ast_vhub_reply(ep, NULL, len);\n}\n\nstatic struct usb_gadget_strings*\nast_vhub_str_of_container(struct usb_gadget_string_container *container)\n{\n\treturn (struct usb_gadget_strings *)container->stash;\n}\n\nstatic int ast_vhub_collect_languages(struct ast_vhub *vhub, void *buf,\n\t\t\t\t      size_t size)\n{\n\tint rc, hdr_len, nlangs, max_langs;\n\tstruct usb_gadget_strings *lang_str;\n\tstruct usb_gadget_string_container *container;\n\tstruct usb_string_descriptor *sdesc = buf;\n\n\tnlangs = 0;\n\thdr_len = sizeof(struct usb_descriptor_header);\n\tmax_langs = (size - hdr_len) / sizeof(sdesc->wData[0]);\n\tlist_for_each_entry(container, &vhub->vhub_str_desc, list) {\n\t\tif (nlangs >= max_langs)\n\t\t\tbreak;\n\n\t\tlang_str = ast_vhub_str_of_container(container);\n\t\tsdesc->wData[nlangs++] = cpu_to_le16(lang_str->language);\n\t}\n\n\trc = hdr_len + nlangs * sizeof(sdesc->wData[0]);\n\tsdesc->bLength = rc;\n\tsdesc->bDescriptorType = USB_DT_STRING;\n\n\treturn rc;\n}\n\nstatic struct usb_gadget_strings *ast_vhub_lookup_string(struct ast_vhub *vhub,\n\t\t\t\t\t\t\t u16 lang_id)\n{\n\tstruct usb_gadget_strings *lang_str;\n\tstruct usb_gadget_string_container *container;\n\n\tlist_for_each_entry(container, &vhub->vhub_str_desc, list) {\n\t\tlang_str = ast_vhub_str_of_container(container);\n\t\tif (lang_str->language == lang_id)\n\t\t\treturn lang_str;\n\t}\n\n\treturn NULL;\n}\n\nstatic int ast_vhub_rep_string(struct ast_vhub_ep *ep,\n\t\t\t       u8 string_id, u16 lang_id,\n\t\t\t       u16 len)\n{\n\tint rc;\n\tu8 buf[256];\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct usb_gadget_strings *lang_str;\n\n\tif (string_id == 0) {\n\t\trc = ast_vhub_collect_languages(vhub, buf, sizeof(buf));\n\t} else {\n\t\tlang_str = ast_vhub_lookup_string(vhub, lang_id);\n\t\tif (!lang_str)\n\t\t\treturn std_req_stall;\n\n\t\trc = usb_gadget_get_string(lang_str, string_id, buf);\n\t}\n\n\tif (rc < 0 || rc >= AST_VHUB_EP0_MAX_PACKET)\n\t\treturn std_req_stall;\n\n\t \n\tmemcpy(ep->buf, buf, rc);\n\treturn ast_vhub_reply(ep, NULL, min_t(u16, rc, len));\n}\n\nenum std_req_rc ast_vhub_std_hub_request(struct ast_vhub_ep *ep,\n\t\t\t\t\t struct usb_ctrlrequest *crq)\n{\n\tstruct ast_vhub *vhub = ep->vhub;\n\tu16 wValue, wIndex, wLength;\n\n\twValue = le16_to_cpu(crq->wValue);\n\twIndex = le16_to_cpu(crq->wIndex);\n\twLength = le16_to_cpu(crq->wLength);\n\n\t \n\tif (vhub->speed == USB_SPEED_UNKNOWN) {\n\t\tu32 ustat = readl(vhub->regs + AST_VHUB_USBSTS);\n\t\tif (ustat & VHUB_USBSTS_HISPEED)\n\t\t\tvhub->speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tvhub->speed = USB_SPEED_FULL;\n\t\tUDCDBG(vhub, \"USB status=%08x speed=%s\\n\", ustat,\n\t\t       vhub->speed == USB_SPEED_HIGH ? \"high\" : \"full\");\n\t}\n\n\tswitch ((crq->bRequestType << 8) | crq->bRequest) {\n\t\t \n\tcase DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\t\tEPDBG(ep, \"SET_ADDRESS: Got address %x\\n\", wValue);\n\t\twritel(wValue, vhub->regs + AST_VHUB_CONF);\n\t\treturn std_req_complete;\n\n\t\t \n\tcase DeviceRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_hub_dev_status(ep, wIndex, wValue);\n\tcase InterfaceRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_simple_reply(ep, 0, 0);\n\tcase EndpointRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_hub_ep_status(ep, wIndex, wValue);\n\n\t\t \n\tcase DeviceOutRequest | USB_REQ_SET_FEATURE:\n\t\treturn ast_vhub_hub_dev_feature(ep, wIndex, wValue, true);\n\tcase DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\n\t\treturn ast_vhub_hub_dev_feature(ep, wIndex, wValue, false);\n\tcase EndpointOutRequest | USB_REQ_SET_FEATURE:\n\t\treturn ast_vhub_hub_ep_feature(ep, wIndex, wValue, true);\n\tcase EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\t\treturn ast_vhub_hub_ep_feature(ep, wIndex, wValue, false);\n\n\t\t \n\tcase DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\t\treturn ast_vhub_simple_reply(ep, 1);\n\tcase DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\t\tif (wValue != 1)\n\t\t\treturn std_req_stall;\n\t\treturn std_req_complete;\n\n\t\t \n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\tswitch (wValue >> 8) {\n\t\tcase USB_DT_DEVICE:\n\t\tcase USB_DT_CONFIG:\n\t\tcase USB_DT_DEVICE_QUALIFIER:\n\t\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\t\treturn ast_vhub_rep_desc(ep, wValue >> 8,\n\t\t\t\t\t\t wLength);\n\t\tcase USB_DT_STRING:\n\t\t\treturn ast_vhub_rep_string(ep, wValue & 0xff,\n\t\t\t\t\t\t   wIndex, wLength);\n\t\t}\n\t\treturn std_req_stall;\n\n\t\t \n\tcase DeviceRequest | USB_REQ_GET_INTERFACE:\n\t\treturn ast_vhub_simple_reply(ep, 0);\n\tcase DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\t\tif (wValue != 0 || wIndex != 0)\n\t\t\treturn std_req_stall;\n\t\treturn std_req_complete;\n\t}\n\treturn std_req_stall;\n}\n\nstatic void ast_vhub_update_hub_ep1(struct ast_vhub *vhub,\n\t\t\t\t    unsigned int port)\n{\n\t \n\tu32 reg = readl(vhub->regs + AST_VHUB_EP1_STS_CHG);\n\tu32 pmask = (1 << (port + 1));\n\tif (vhub->ports[port].change)\n\t\treg |= pmask;\n\telse\n\t\treg &= ~pmask;\n\twritel(reg, vhub->regs + AST_VHUB_EP1_STS_CHG);\n}\n\nstatic void ast_vhub_change_port_stat(struct ast_vhub *vhub,\n\t\t\t\t      unsigned int port,\n\t\t\t\t      u16 clr_flags,\n\t\t\t\t      u16 set_flags,\n\t\t\t\t      bool set_c)\n{\n\tstruct ast_vhub_port *p = &vhub->ports[port];\n\tu16 prev;\n\n\t \n\tprev = p->status;\n\tp->status = (prev & ~clr_flags) | set_flags;\n\tDDBG(&p->dev, \"port %d status %04x -> %04x (C=%d)\\n\",\n\t     port + 1, prev, p->status, set_c);\n\n\t \n\tif (set_c) {\n\t\tu16 chg = p->status ^ prev;\n\n\t\t \n\t\tchg &= USB_PORT_STAT_C_CONNECTION |\n\t\t       USB_PORT_STAT_C_ENABLE |\n\t\t       USB_PORT_STAT_C_SUSPEND |\n\t\t       USB_PORT_STAT_C_OVERCURRENT |\n\t\t       USB_PORT_STAT_C_RESET |\n\t\t       USB_PORT_STAT_C_L1;\n\n\t\t \n\t\tif (p->status & USB_PORT_STAT_ENABLE)\n\t\t\tchg &= ~USB_PORT_STAT_C_ENABLE;\n\n\t\tp->change = chg;\n\t\tast_vhub_update_hub_ep1(vhub, port);\n\t}\n}\n\nstatic void ast_vhub_send_host_wakeup(struct ast_vhub *vhub)\n{\n\tu32 reg = readl(vhub->regs + AST_VHUB_CTRL);\n\tUDCDBG(vhub, \"Waking up host !\\n\");\n\treg |= VHUB_CTRL_MANUAL_REMOTE_WAKEUP;\n\twritel(reg, vhub->regs + AST_VHUB_CTRL);\n}\n\nvoid ast_vhub_device_connect(struct ast_vhub *vhub,\n\t\t\t     unsigned int port, bool on)\n{\n\tif (on)\n\t\tast_vhub_change_port_stat(vhub, port, 0,\n\t\t\t\t\t  USB_PORT_STAT_CONNECTION, true);\n\telse\n\t\tast_vhub_change_port_stat(vhub, port,\n\t\t\t\t\t  USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t  USB_PORT_STAT_ENABLE,\n\t\t\t\t\t  0, true);\n\n\t \n\tif (vhub->wakeup_en)\n\t\tast_vhub_send_host_wakeup(vhub);\n}\n\nstatic void ast_vhub_wake_work(struct work_struct *work)\n{\n\tstruct ast_vhub *vhub = container_of(work,\n\t\t\t\t\t     struct ast_vhub,\n\t\t\t\t\t     wake_work);\n\tunsigned long flags;\n\tunsigned int i;\n\n\t \n\tspin_lock_irqsave(&vhub->lock, flags);\n\tfor (i = 0; i < vhub->max_ports; i++) {\n\t\tstruct ast_vhub_port *p = &vhub->ports[i];\n\n\t\tif (!(p->status & USB_PORT_STAT_SUSPEND))\n\t\t\tcontinue;\n\t\tast_vhub_change_port_stat(vhub, i,\n\t\t\t\t\t  USB_PORT_STAT_SUSPEND,\n\t\t\t\t\t  0, true);\n\t\tast_vhub_dev_resume(&p->dev);\n\t}\n\tast_vhub_send_host_wakeup(vhub);\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n}\n\nvoid ast_vhub_hub_wake_all(struct ast_vhub *vhub)\n{\n\t \n\tschedule_work(&vhub->wake_work);\n}\n\nstatic void ast_vhub_port_reset(struct ast_vhub *vhub, u8 port)\n{\n\tstruct ast_vhub_port *p = &vhub->ports[port];\n\tu16 set, clr, speed;\n\n\t \n\tast_vhub_change_port_stat(vhub, port,\n\t\t\t\t  USB_PORT_STAT_ENABLE |\n\t\t\t\t  USB_PORT_STAT_SUSPEND,\n\t\t\t\t  USB_PORT_STAT_RESET,\n\t\t\t\t  false);\n\n\tif (!p->dev.driver)\n\t\treturn;\n\n\t \n\tast_vhub_dev_reset(&p->dev);\n\n\t \n\tspeed = p->dev.driver->max_speed;\n\tif (speed == USB_SPEED_UNKNOWN || speed > vhub->speed)\n\t\tspeed = vhub->speed;\n\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\tset = USB_PORT_STAT_LOW_SPEED;\n\t\tclr = USB_PORT_STAT_HIGH_SPEED;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tset = 0;\n\t\tclr = USB_PORT_STAT_LOW_SPEED |\n\t\t\tUSB_PORT_STAT_HIGH_SPEED;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tset = USB_PORT_STAT_HIGH_SPEED;\n\t\tclr = USB_PORT_STAT_LOW_SPEED;\n\t\tbreak;\n\tdefault:\n\t\tUDCDBG(vhub, \"Unsupported speed %d when\"\n\t\t       \" connecting device\\n\",\n\t\t       speed);\n\t\treturn;\n\t}\n\tclr |= USB_PORT_STAT_RESET;\n\tset |= USB_PORT_STAT_ENABLE;\n\n\t \n\tast_vhub_change_port_stat(vhub, port, clr, set, true);\n}\n\nstatic enum std_req_rc ast_vhub_set_port_feature(struct ast_vhub_ep *ep,\n\t\t\t\t\t\t u8 port, u16 feat)\n{\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct ast_vhub_port *p;\n\n\tif (port == 0 || port > vhub->max_ports)\n\t\treturn std_req_stall;\n\tport--;\n\tp = &vhub->ports[port];\n\n\tswitch(feat) {\n\tcase USB_PORT_FEAT_SUSPEND:\n\t\tif (!(p->status & USB_PORT_STAT_ENABLE))\n\t\t\treturn std_req_complete;\n\t\tast_vhub_change_port_stat(vhub, port,\n\t\t\t\t\t  0, USB_PORT_STAT_SUSPEND,\n\t\t\t\t\t  false);\n\t\tast_vhub_dev_suspend(&p->dev);\n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_RESET:\n\t\tEPDBG(ep, \"Port reset !\\n\");\n\t\tast_vhub_port_reset(vhub, port);\n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_POWER:\n\t\t \n\t\tif (p->status & USB_PORT_STAT_CONNECTION) {\n\t\t\tp->change |= USB_PORT_STAT_C_CONNECTION;\n\t\t\tast_vhub_update_hub_ep1(vhub, port);\n\t\t}\n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_TEST:\n\tcase USB_PORT_FEAT_INDICATOR:\n\t\t \n\t\treturn std_req_complete;\n\t}\n\treturn std_req_stall;\n}\n\nstatic enum std_req_rc ast_vhub_clr_port_feature(struct ast_vhub_ep *ep,\n\t\t\t\t\t\t u8 port, u16 feat)\n{\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct ast_vhub_port *p;\n\n\tif (port == 0 || port > vhub->max_ports)\n\t\treturn std_req_stall;\n\tport--;\n\tp = &vhub->ports[port];\n\n\tswitch(feat) {\n\tcase USB_PORT_FEAT_ENABLE:\n\t\tast_vhub_change_port_stat(vhub, port,\n\t\t\t\t\t  USB_PORT_STAT_ENABLE |\n\t\t\t\t\t  USB_PORT_STAT_SUSPEND, 0,\n\t\t\t\t\t  false);\n\t\tast_vhub_dev_suspend(&p->dev);\n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_SUSPEND:\n\t\tif (!(p->status & USB_PORT_STAT_SUSPEND))\n\t\t\treturn std_req_complete;\n\t\tast_vhub_change_port_stat(vhub, port,\n\t\t\t\t\t  USB_PORT_STAT_SUSPEND, 0,\n\t\t\t\t\t  false);\n\t\tast_vhub_dev_resume(&p->dev);\n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_POWER:\n\t\t \n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_INDICATOR:\n\t\t \n\t\treturn std_req_complete;\n\tcase USB_PORT_FEAT_C_CONNECTION:\n\tcase USB_PORT_FEAT_C_ENABLE:\n\tcase USB_PORT_FEAT_C_SUSPEND:\n\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\tcase USB_PORT_FEAT_C_RESET:\n\t\t \n\t\tp->change &= ~(1u << (feat - 16));\n\t\tast_vhub_update_hub_ep1(vhub, port);\n\t\treturn std_req_complete;\n\t}\n\treturn std_req_stall;\n}\n\nstatic enum std_req_rc ast_vhub_get_port_stat(struct ast_vhub_ep *ep,\n\t\t\t\t\t      u8 port)\n{\n\tstruct ast_vhub *vhub = ep->vhub;\n\tu16 stat, chg;\n\n\tif (port == 0 || port > vhub->max_ports)\n\t\treturn std_req_stall;\n\tport--;\n\n\tstat = vhub->ports[port].status;\n\tchg = vhub->ports[port].change;\n\n\t \n\tstat |= USB_PORT_STAT_POWER;\n\n\tEPDBG(ep, \" port status=%04x change=%04x\\n\", stat, chg);\n\n\treturn ast_vhub_simple_reply(ep,\n\t\t\t\t     stat & 0xff,\n\t\t\t\t     stat >> 8,\n\t\t\t\t     chg & 0xff,\n\t\t\t\t     chg >> 8);\n}\n\nenum std_req_rc ast_vhub_class_hub_request(struct ast_vhub_ep *ep,\n\t\t\t\t\t   struct usb_ctrlrequest *crq)\n{\n\tu16 wValue, wIndex, wLength;\n\n\twValue = le16_to_cpu(crq->wValue);\n\twIndex = le16_to_cpu(crq->wIndex);\n\twLength = le16_to_cpu(crq->wLength);\n\n\tswitch ((crq->bRequestType << 8) | crq->bRequest) {\n\tcase GetHubStatus:\n\t\tEPDBG(ep, \"GetHubStatus\\n\");\n\t\treturn ast_vhub_simple_reply(ep, 0, 0, 0, 0);\n\tcase GetPortStatus:\n\t\tEPDBG(ep, \"GetPortStatus(%d)\\n\", wIndex & 0xff);\n\t\treturn ast_vhub_get_port_stat(ep, wIndex & 0xf);\n\tcase GetHubDescriptor:\n\t\tif (wValue != (USB_DT_HUB << 8))\n\t\t\treturn std_req_stall;\n\t\tEPDBG(ep, \"GetHubDescriptor(%d)\\n\", wIndex & 0xff);\n\t\treturn ast_vhub_rep_desc(ep, USB_DT_HUB, wLength);\n\tcase SetHubFeature:\n\tcase ClearHubFeature:\n\t\tEPDBG(ep, \"Get/SetHubFeature(%d)\\n\", wValue);\n\t\t \n\t\tif (wValue == C_HUB_LOCAL_POWER ||\n\t\t    wValue == C_HUB_OVER_CURRENT)\n\t\t\treturn std_req_complete;\n\t\treturn std_req_stall;\n\tcase SetPortFeature:\n\t\tEPDBG(ep, \"SetPortFeature(%d,%d)\\n\", wIndex & 0xf, wValue);\n\t\treturn ast_vhub_set_port_feature(ep, wIndex & 0xf, wValue);\n\tcase ClearPortFeature:\n\t\tEPDBG(ep, \"ClearPortFeature(%d,%d)\\n\", wIndex & 0xf, wValue);\n\t\treturn ast_vhub_clr_port_feature(ep, wIndex & 0xf, wValue);\n\tcase ClearTTBuffer:\n\tcase ResetTT:\n\tcase StopTT:\n\t\treturn std_req_complete;\n\tcase GetTTState:\n\t\treturn ast_vhub_simple_reply(ep, 0, 0, 0, 0);\n\tdefault:\n\t\tEPDBG(ep, \"Unknown class request\\n\");\n\t}\n\treturn std_req_stall;\n}\n\nvoid ast_vhub_hub_suspend(struct ast_vhub *vhub)\n{\n\tunsigned int i;\n\n\tUDCDBG(vhub, \"USB bus suspend\\n\");\n\n\tif (vhub->suspended)\n\t\treturn;\n\n\tvhub->suspended = true;\n\n\t \n\tfor (i = 0; i < vhub->max_ports; i++) {\n\t\tstruct ast_vhub_port *p = &vhub->ports[i];\n\n\t\tif (!(p->status & USB_PORT_STAT_SUSPEND))\n\t\t\tast_vhub_dev_suspend(&p->dev);\n\t}\n}\n\nvoid ast_vhub_hub_resume(struct ast_vhub *vhub)\n{\n\tunsigned int i;\n\n\tUDCDBG(vhub, \"USB bus resume\\n\");\n\n\tif (!vhub->suspended)\n\t\treturn;\n\n\tvhub->suspended = false;\n\n\t \n\tfor (i = 0; i < vhub->max_ports; i++) {\n\t\tstruct ast_vhub_port *p = &vhub->ports[i];\n\n\t\tif (!(p->status & USB_PORT_STAT_SUSPEND))\n\t\t\tast_vhub_dev_resume(&p->dev);\n\t}\n}\n\nvoid ast_vhub_hub_reset(struct ast_vhub *vhub)\n{\n\tunsigned int i;\n\n\tUDCDBG(vhub, \"USB bus reset\\n\");\n\n\t \n\tif (vhub->speed == USB_SPEED_UNKNOWN)\n\t\treturn;\n\n\t \n\tvhub->suspended = false;\n\n\t \n\tvhub->speed = USB_SPEED_UNKNOWN;\n\n\t \n\tvhub->wakeup_en = false;\n\n\t \n\tfor (i = 0; i < vhub->max_ports; i++) {\n\t\tstruct ast_vhub_port *p = &vhub->ports[i];\n\n\t\t \n\t\tp->status &= USB_PORT_STAT_CONNECTION;\n\t\tp->change = 0;\n\n\t\t \n\t\tast_vhub_dev_suspend(&p->dev);\n\t}\n\n\t \n\twritel(0, vhub->regs + AST_VHUB_CONF);\n\twritel(0, vhub->regs + AST_VHUB_EP0_CTRL);\n\twritel(VHUB_EP1_CTRL_RESET_TOGGLE |\n\t       VHUB_EP1_CTRL_ENABLE,\n\t       vhub->regs + AST_VHUB_EP1_CTRL);\n\twritel(0, vhub->regs + AST_VHUB_EP1_STS_CHG);\n}\n\nstatic void ast_vhub_of_parse_dev_desc(struct ast_vhub *vhub,\n\t\t\t\t       const struct device_node *vhub_np)\n{\n\tu16 id;\n\tu32 data;\n\n\tif (!of_property_read_u32(vhub_np, \"vhub-vendor-id\", &data)) {\n\t\tid = (u16)data;\n\t\tvhub->vhub_dev_desc.idVendor = cpu_to_le16(id);\n\t}\n\tif (!of_property_read_u32(vhub_np, \"vhub-product-id\", &data)) {\n\t\tid = (u16)data;\n\t\tvhub->vhub_dev_desc.idProduct = cpu_to_le16(id);\n\t}\n\tif (!of_property_read_u32(vhub_np, \"vhub-device-revision\", &data)) {\n\t\tid = (u16)data;\n\t\tvhub->vhub_dev_desc.bcdDevice = cpu_to_le16(id);\n\t}\n}\n\nstatic void ast_vhub_fixup_usb1_dev_desc(struct ast_vhub *vhub)\n{\n\tvhub->vhub_dev_desc.bcdUSB = cpu_to_le16(0x0100);\n\tvhub->vhub_dev_desc.bDeviceProtocol = 0;\n}\n\nstatic struct usb_gadget_string_container*\nast_vhub_str_container_alloc(struct ast_vhub *vhub)\n{\n\tunsigned int size;\n\tstruct usb_string *str_array;\n\tstruct usb_gadget_strings *lang_str;\n\tstruct usb_gadget_string_container *container;\n\n\tsize = sizeof(*container);\n\tsize += sizeof(struct usb_gadget_strings);\n\tsize += sizeof(struct usb_string) * AST_VHUB_STR_INDEX_MAX;\n\tcontainer = devm_kzalloc(&vhub->pdev->dev, size, GFP_KERNEL);\n\tif (!container)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlang_str = ast_vhub_str_of_container(container);\n\tstr_array = (struct usb_string *)(lang_str + 1);\n\tlang_str->strings = str_array;\n\treturn container;\n}\n\nstatic void ast_vhub_str_deep_copy(struct usb_gadget_strings *dest,\n\t\t\t\t   const struct usb_gadget_strings *src)\n{\n\tstruct usb_string *src_array = src->strings;\n\tstruct usb_string *dest_array = dest->strings;\n\n\tdest->language = src->language;\n\tif (src_array && dest_array) {\n\t\tdo {\n\t\t\t*dest_array = *src_array;\n\t\t\tdest_array++;\n\t\t\tsrc_array++;\n\t\t} while (src_array->s);\n\t}\n}\n\nstatic int ast_vhub_str_alloc_add(struct ast_vhub *vhub,\n\t\t\t\t  const struct usb_gadget_strings *src_str)\n{\n\tstruct usb_gadget_strings *dest_str;\n\tstruct usb_gadget_string_container *container;\n\n\tcontainer = ast_vhub_str_container_alloc(vhub);\n\tif (IS_ERR(container))\n\t\treturn PTR_ERR(container);\n\n\tdest_str = ast_vhub_str_of_container(container);\n\tast_vhub_str_deep_copy(dest_str, src_str);\n\tlist_add_tail(&container->list, &vhub->vhub_str_desc);\n\n\treturn 0;\n}\n\nstatic const struct {\n\tconst char *name;\n\tu8 id;\n} str_id_map[] = {\n\t{\"manufacturer\",\tAST_VHUB_STR_MANUF},\n\t{\"product\",\t\tAST_VHUB_STR_PRODUCT},\n\t{\"serial-number\",\tAST_VHUB_STR_SERIAL},\n\t{},\n};\n\nstatic int ast_vhub_of_parse_str_desc(struct ast_vhub *vhub,\n\t\t\t\t      const struct device_node *desc_np)\n{\n\tu32 langid;\n\tint ret = 0;\n\tint i, offset;\n\tconst char *str;\n\tstruct device_node *child;\n\tstruct usb_string str_array[AST_VHUB_STR_INDEX_MAX];\n\tstruct usb_gadget_strings lang_str = {\n\t\t.strings = (struct usb_string *)str_array,\n\t};\n\n\tfor_each_child_of_node(desc_np, child) {\n\t\tif (of_property_read_u32(child, \"reg\", &langid))\n\t\t\tcontinue;  \n\n\t\tif (!usb_validate_langid(langid))\n\t\t\tcontinue;  \n\n\t\tlang_str.language = langid;\n\t\tfor (i = offset = 0; str_id_map[i].name; i++) {\n\t\t\tstr = of_get_property(child, str_id_map[i].name, NULL);\n\t\t\tif (str) {\n\t\t\t\tstr_array[offset].s = str;\n\t\t\t\tstr_array[offset].id = str_id_map[i].id;\n\t\t\t\toffset++;\n\t\t\t}\n\t\t}\n\t\tstr_array[offset].id = 0;\n\t\tstr_array[offset].s = NULL;\n\n\t\tret = ast_vhub_str_alloc_add(vhub, &lang_str);\n\t\tif (ret) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ast_vhub_init_desc(struct ast_vhub *vhub)\n{\n\tint ret;\n\tstruct device_node *desc_np;\n\tconst struct device_node *vhub_np = vhub->pdev->dev.of_node;\n\n\t \n\tmemcpy(&vhub->vhub_dev_desc, &ast_vhub_dev_desc,\n\t\tsizeof(vhub->vhub_dev_desc));\n\tast_vhub_of_parse_dev_desc(vhub, vhub_np);\n\tif (vhub->force_usb1)\n\t\tast_vhub_fixup_usb1_dev_desc(vhub);\n\n\t \n\tmemcpy(&vhub->vhub_conf_desc, &ast_vhub_conf_desc,\n\t\tsizeof(vhub->vhub_conf_desc));\n\n\t \n\tmemcpy(&vhub->vhub_hub_desc, &ast_vhub_hub_desc,\n\t\tsizeof(vhub->vhub_hub_desc));\n\tvhub->vhub_hub_desc.bNbrPorts = vhub->max_ports;\n\n\t \n\tINIT_LIST_HEAD(&vhub->vhub_str_desc);\n\tdesc_np = of_get_child_by_name(vhub_np, \"vhub-strings\");\n\tif (desc_np) {\n\t\tret = ast_vhub_of_parse_str_desc(vhub, desc_np);\n\t\tof_node_put(desc_np);\n\t}\n\telse\n\t\tret = ast_vhub_str_alloc_add(vhub, &ast_vhub_strings);\n\n\t \n\tmemcpy(&vhub->vhub_qual_desc, &ast_vhub_qual_desc,\n\t\tsizeof(vhub->vhub_qual_desc));\n\n\treturn ret;\n}\n\nint ast_vhub_init_hub(struct ast_vhub *vhub)\n{\n\tvhub->speed = USB_SPEED_UNKNOWN;\n\tINIT_WORK(&vhub->wake_work, ast_vhub_wake_work);\n\n\treturn ast_vhub_init_desc(vhub);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}