{
  "module_name": "epn.c",
  "hash_id": "04e3400bf5c9f744a613e9c9fa9619c161d02770aa0acc6c49d1a6a1dc27de70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed-vhub/epn.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n\n#include \"vhub.h\"\n\n#define EXTRA_CHECKS\n\n#ifdef EXTRA_CHECKS\n#define CHECK(ep, expr, fmt...)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (!(expr)) EPDBG(ep, \"CHECK:\" fmt);\t\t\\\n\t} while(0)\n#else\n#define CHECK(ep, expr, fmt...)\tdo { } while(0)\n#endif\n\nstatic void ast_vhub_epn_kick(struct ast_vhub_ep *ep, struct ast_vhub_req *req)\n{\n\tunsigned int act = req->req.actual;\n\tunsigned int len = req->req.length;\n\tunsigned int chunk;\n\n\t \n\tWARN_ON(req->active);\n\n\t \n\tchunk = len - act;\n\tif (chunk > ep->ep.maxpacket)\n\t\tchunk = ep->ep.maxpacket;\n\telse if ((chunk < ep->ep.maxpacket) || !req->req.zero)\n\t\treq->last_desc = 1;\n\n\tEPVDBG(ep, \"kick req %p act=%d/%d chunk=%d last=%d\\n\",\n\t       req, act, len, chunk, req->last_desc);\n\n\t \n\tif (!req->req.dma) {\n\n\t\t \n\t\tif (ep->epn.is_in) {\n\t\t\tmemcpy(ep->buf, req->req.buf + act, chunk);\n\t\t\tvhub_dma_workaround(ep->buf);\n\t\t}\n\t\twritel(ep->buf_dma, ep->epn.regs + AST_VHUB_EP_DESC_BASE);\n\t} else {\n\t\tif (ep->epn.is_in)\n\t\t\tvhub_dma_workaround(req->req.buf);\n\t\twritel(req->req.dma + act, ep->epn.regs + AST_VHUB_EP_DESC_BASE);\n\t}\n\n\t \n\treq->active = true;\n\twritel(VHUB_EP_DMA_SET_TX_SIZE(chunk),\n\t       ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\twritel(VHUB_EP_DMA_SET_TX_SIZE(chunk) | VHUB_EP_DMA_SINGLE_KICK,\n\t       ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n}\n\nstatic void ast_vhub_epn_handle_ack(struct ast_vhub_ep *ep)\n{\n\tstruct ast_vhub_req *req;\n\tunsigned int len;\n\tint status = 0;\n\tu32 stat;\n\n\t \n\tstat = readl(ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\n\t \n\treq = list_first_entry_or_null(&ep->queue, struct ast_vhub_req, queue);\n\n\tEPVDBG(ep, \"ACK status=%08x is_in=%d, req=%p (active=%d)\\n\",\n\t       stat, ep->epn.is_in, req, req ? req->active : 0);\n\n\t \n\tif (!req)\n\t\treturn;\n\n\t \n\tif (!req->active)\n\t\tgoto next_chunk;\n\n\t \n\tif (VHUB_EP_DMA_RPTR(stat) != 0) {\n\t\tEPDBG(ep, \"DMA read pointer not 0 !\\n\");\n\t\treturn;\n\t}\n\n\t \n\treq->active = false;\n\n\t \n\tlen = VHUB_EP_DMA_TX_SIZE(stat);\n\n\t \n\tif (!req->req.dma && !ep->epn.is_in && len) {\n\t\tif (req->req.actual + len > req->req.length) {\n\t\t\treq->last_desc = 1;\n\t\t\tstatus = -EOVERFLOW;\n\t\t\tgoto done;\n\t\t} else {\n\t\t\tmemcpy(req->req.buf + req->req.actual, ep->buf, len);\n\t\t}\n\t}\n\t \n\treq->req.actual += len;\n\n\t \n\tif (len < ep->ep.maxpacket)\n\t\treq->last_desc = 1;\n\ndone:\n\t \n\tif (req->last_desc >= 0) {\n\t\tast_vhub_done(ep, req, status);\n\t\treq = list_first_entry_or_null(&ep->queue, struct ast_vhub_req,\n\t\t\t\t\t       queue);\n\n\t\t \n\t\tif (!req || req->active)\n\t\t\treturn;\n\t}\n\n next_chunk:\n\tast_vhub_epn_kick(ep, req);\n}\n\nstatic inline unsigned int ast_vhub_count_free_descs(struct ast_vhub_ep *ep)\n{\n\t \n\treturn (ep->epn.d_last + AST_VHUB_DESCS_COUNT - ep->epn.d_next - 1) &\n\t\t(AST_VHUB_DESCS_COUNT - 1);\n}\n\nstatic void ast_vhub_epn_kick_desc(struct ast_vhub_ep *ep,\n\t\t\t\t   struct ast_vhub_req *req)\n{\n\tstruct ast_vhub_desc *desc = NULL;\n\tunsigned int act = req->act_count;\n\tunsigned int len = req->req.length;\n\tunsigned int chunk;\n\n\t \n\treq->active = true;\n\n\t \n\tif (req->last_desc >= 0)\n\t\treturn;\n\n\tEPVDBG(ep, \"kick act=%d/%d chunk_max=%d free_descs=%d\\n\",\n\t       act, len, ep->epn.chunk_max, ast_vhub_count_free_descs(ep));\n\n\t \n\twhile (ast_vhub_count_free_descs(ep) && req->last_desc < 0) {\n\t\tunsigned int d_num;\n\n\t\t \n\t\td_num = ep->epn.d_next;\n\t\tdesc = &ep->epn.descs[d_num];\n\t\tep->epn.d_next = (d_num + 1) & (AST_VHUB_DESCS_COUNT - 1);\n\n\t\t \n\t\tchunk = len - act;\n\t\tif (chunk <= ep->epn.chunk_max) {\n\t\t\t \n\t\t\tif (!chunk || !req->req.zero || (chunk % ep->ep.maxpacket) != 0)\n\t\t\t\treq->last_desc = d_num;\n\t\t} else {\n\t\t\tchunk = ep->epn.chunk_max;\n\t\t}\n\n\t\tEPVDBG(ep, \" chunk: act=%d/%d chunk=%d last=%d desc=%d free=%d\\n\",\n\t\t       act, len, chunk, req->last_desc, d_num,\n\t\t       ast_vhub_count_free_descs(ep));\n\n\t\t \n\t\tdesc->w0 = cpu_to_le32(req->req.dma + act);\n\n\t\t \n\n\t\t \n\t\tdesc->w1 = cpu_to_le32(VHUB_DSC1_IN_SET_LEN(chunk));\n\t\tif (req->last_desc >= 0 || !ast_vhub_count_free_descs(ep))\n\t\t\tdesc->w1 |= cpu_to_le32(VHUB_DSC1_IN_INTERRUPT);\n\n\t\t \n\t\treq->act_count = act = act + chunk;\n\t}\n\n\tif (likely(desc))\n\t\tvhub_dma_workaround(desc);\n\n\t \n\twritel(VHUB_EP_DMA_SET_CPU_WPTR(ep->epn.d_next),\n\t       ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\n\tEPVDBG(ep, \"HW kicked, d_next=%d dstat=%08x\\n\",\n\t       ep->epn.d_next, readl(ep->epn.regs + AST_VHUB_EP_DESC_STATUS));\n}\n\nstatic void ast_vhub_epn_handle_ack_desc(struct ast_vhub_ep *ep)\n{\n\tstruct ast_vhub_req *req;\n\tunsigned int len, d_last;\n\tu32 stat, stat1;\n\n\t \n\tdo {\n\t\tstat = readl(ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\t\tstat1 = readl(ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\t} while(stat != stat1);\n\n\t \n\td_last = VHUB_EP_DMA_RPTR(stat);\n\n\t \n\treq = list_first_entry_or_null(&ep->queue, struct ast_vhub_req, queue);\n\n\tEPVDBG(ep, \"ACK status=%08x is_in=%d ep->d_last=%d..%d\\n\",\n\t       stat, ep->epn.is_in, ep->epn.d_last, d_last);\n\n\t \n\twhile (ep->epn.d_last != d_last) {\n\t\tstruct ast_vhub_desc *desc;\n\t\tunsigned int d_num;\n\t\tbool is_last_desc;\n\n\t\t \n\t\td_num = ep->epn.d_last;\n\t\tdesc = &ep->epn.descs[d_num];\n\t\tep->epn.d_last = (d_num + 1) & (AST_VHUB_DESCS_COUNT - 1);\n\n\t\t \n\t\tlen = VHUB_DSC1_IN_LEN(le32_to_cpu(desc->w1));\n\n\t\tEPVDBG(ep, \" desc %d len=%d req=%p (act=%d)\\n\",\n\t\t       d_num, len, req, req ? req->active : 0);\n\n\t\t \n\t\tif (!req || !req->active)\n\t\t\tcontinue;\n\n\t\t \n\t\treq->req.actual += len;\n\n\t\t \n\t\tis_last_desc = req->last_desc == d_num;\n\t\tCHECK(ep, is_last_desc == (len < ep->ep.maxpacket ||\n\t\t\t\t\t   (req->req.actual >= req->req.length &&\n\t\t\t\t\t    !req->req.zero)),\n\t\t      \"Last packet discrepancy: last_desc=%d len=%d r.act=%d \"\n\t\t      \"r.len=%d r.zero=%d mp=%d\\n\",\n\t\t      is_last_desc, len, req->req.actual, req->req.length,\n\t\t      req->req.zero, ep->ep.maxpacket);\n\n\t\tif (is_last_desc) {\n\t\t\t \n\t\t\tCHECK(ep, d_last == ep->epn.d_last,\n\t\t\t      \"DMA read ptr mismatch %d vs %d\\n\",\n\t\t\t      d_last, ep->epn.d_last);\n\n\t\t\t \n\t\t\tast_vhub_done(ep, req, 0);\n\t\t\treq = list_first_entry_or_null(&ep->queue,\n\t\t\t\t\t\t       struct ast_vhub_req,\n\t\t\t\t\t\t       queue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (req)\n\t\tast_vhub_epn_kick_desc(ep, req);\n}\n\nvoid ast_vhub_epn_ack_irq(struct ast_vhub_ep *ep)\n{\n\tif (ep->epn.desc_mode)\n\t\tast_vhub_epn_handle_ack_desc(ep);\n\telse\n\t\tast_vhub_epn_handle_ack(ep);\n}\n\nstatic int ast_vhub_epn_queue(struct usb_ep* u_ep, struct usb_request *u_req,\n\t\t\t      gfp_t gfp_flags)\n{\n\tstruct ast_vhub_req *req = to_ast_req(u_req);\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tunsigned long flags;\n\tbool empty;\n\tint rc;\n\n\t \n\tif (!u_req || !u_req->complete || !u_req->buf) {\n\t\tdev_warn(&vhub->pdev->dev, \"Bogus EPn request ! u_req=%p\\n\", u_req);\n\t\tif (u_req) {\n\t\t\tdev_warn(&vhub->pdev->dev, \"complete=%p internal=%d\\n\",\n\t\t\t\t u_req->complete, req->internal);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!ep->epn.enabled || !u_ep->desc || !ep->dev || !ep->d_idx ||\n\t    !ep->dev->enabled) {\n\t\tEPDBG(ep, \"Enqueuing request on wrong or disabled EP\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (ep->epn.desc_mode ||\n\t    ((((unsigned long)u_req->buf & 7) == 0) &&\n\t     (ep->epn.is_in || !(u_req->length & (u_ep->maxpacket - 1))))) {\n\t\trc = usb_gadget_map_request_by_dev(&vhub->pdev->dev, u_req,\n\t\t\t\t\t    ep->epn.is_in);\n\t\tif (rc) {\n\t\t\tdev_warn(&vhub->pdev->dev,\n\t\t\t\t \"Request mapping failure %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t} else\n\t\tu_req->dma = 0;\n\n\tEPVDBG(ep, \"enqueue req @%p\\n\", req);\n\tEPVDBG(ep, \" l=%d dma=0x%x zero=%d noshort=%d noirq=%d is_in=%d\\n\",\n\t       u_req->length, (u32)u_req->dma, u_req->zero,\n\t       u_req->short_not_ok, u_req->no_interrupt,\n\t       ep->epn.is_in);\n\n\t \n\tu_req->status = -EINPROGRESS;\n\tu_req->actual = 0;\n\treq->act_count = 0;\n\treq->active = false;\n\treq->last_desc = -1;\n\tspin_lock_irqsave(&vhub->lock, flags);\n\tempty = list_empty(&ep->queue);\n\n\t \n\tlist_add_tail(&req->queue, &ep->queue);\n\tif (empty) {\n\t\tif (ep->epn.desc_mode)\n\t\t\tast_vhub_epn_kick_desc(ep, req);\n\t\telse\n\t\t\tast_vhub_epn_kick(ep, req);\n\t}\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ast_vhub_stop_active_req(struct ast_vhub_ep *ep,\n\t\t\t\t     bool restart_ep)\n{\n\tu32 state, reg, loops;\n\n\t \n\tif (ep->epn.desc_mode)\n\t\twritel(VHUB_EP_DMA_CTRL_RESET, ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\telse\n\t\twritel(0, ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\n\t \n\tfor (loops = 0; loops < 1000; loops++) {\n\t\tstate = readl(ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t\tstate = VHUB_EP_DMA_PROC_STATUS(state);\n\t\tif (state == EP_DMA_PROC_RX_IDLE ||\n\t\t    state == EP_DMA_PROC_TX_IDLE)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\tif (loops >= 1000)\n\t\tdev_warn(&ep->vhub->pdev->dev, \"Timeout waiting for DMA\\n\");\n\n\t \n\tif (!restart_ep)\n\t\treturn;\n\n\t \n\tif (ep->epn.desc_mode) {\n\t\t \n\t\treg = VHUB_EP_DMA_SET_RPTR(ep->epn.d_next) |\n\t\t\tVHUB_EP_DMA_SET_CPU_WPTR(ep->epn.d_next);\n\t\twritel(reg, ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\n\t\t \n\t\twritel(ep->epn.dma_conf,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t} else {\n\t\t \n\t\twritel(ep->epn.dma_conf,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t}\n}\n\nstatic int ast_vhub_epn_dequeue(struct usb_ep* u_ep, struct usb_request *u_req)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct ast_vhub_req *req = NULL, *iter;\n\tunsigned long flags;\n\tint rc = -EINVAL;\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != u_req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\n\tif (req) {\n\t\tEPVDBG(ep, \"dequeue req @%p active=%d\\n\",\n\t\t       req, req->active);\n\t\tif (req->active)\n\t\t\tast_vhub_stop_active_req(ep, true);\n\t\tast_vhub_done(ep, req, -ECONNRESET);\n\t\trc = 0;\n\t}\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\treturn rc;\n}\n\nvoid ast_vhub_update_epn_stall(struct ast_vhub_ep *ep)\n{\n\tu32 reg;\n\n\tif (WARN_ON(ep->d_idx == 0))\n\t\treturn;\n\treg = readl(ep->epn.regs + AST_VHUB_EP_CONFIG);\n\tif (ep->epn.stalled || ep->epn.wedged)\n\t\treg |= VHUB_EP_CFG_STALL_CTRL;\n\telse\n\t\treg &= ~VHUB_EP_CFG_STALL_CTRL;\n\twritel(reg, ep->epn.regs + AST_VHUB_EP_CONFIG);\n\n\tif (!ep->epn.stalled && !ep->epn.wedged)\n\t\twritel(VHUB_EP_TOGGLE_SET_EPNUM(ep->epn.g_idx),\n\t\t       ep->vhub->regs + AST_VHUB_EP_TOGGLE);\n}\n\nstatic int ast_vhub_set_halt_and_wedge(struct usb_ep* u_ep, bool halt,\n\t\t\t\t      bool wedge)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tunsigned long flags;\n\n\tEPDBG(ep, \"Set halt (%d) & wedge (%d)\\n\", halt, wedge);\n\n\tif (!u_ep || !u_ep->desc)\n\t\treturn -EINVAL;\n\tif (ep->d_idx == 0)\n\t\treturn 0;\n\tif (ep->epn.is_iso)\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\tif (halt && ep->epn.is_in && !list_empty(&ep->queue)) {\n\t\tspin_unlock_irqrestore(&vhub->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tep->epn.stalled = halt;\n\tep->epn.wedged = wedge;\n\tast_vhub_update_epn_stall(ep);\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_vhub_epn_set_halt(struct usb_ep *u_ep, int value)\n{\n\treturn ast_vhub_set_halt_and_wedge(u_ep, value != 0, false);\n}\n\nstatic int ast_vhub_epn_set_wedge(struct usb_ep *u_ep)\n{\n\treturn ast_vhub_set_halt_and_wedge(u_ep, true, true);\n}\n\nstatic int ast_vhub_epn_disable(struct usb_ep* u_ep)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tunsigned long flags;\n\tu32 imask, ep_ier;\n\n\tEPDBG(ep, \"Disabling !\\n\");\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\tep->epn.enabled = false;\n\n\t \n\tast_vhub_stop_active_req(ep, false);\n\n\t \n\twritel(0, ep->epn.regs + AST_VHUB_EP_CONFIG);\n\n\t \n\timask = VHUB_EP_IRQ(ep->epn.g_idx);\n\tep_ier = readl(vhub->regs + AST_VHUB_EP_ACK_IER);\n\tep_ier &= ~imask;\n\twritel(ep_ier, vhub->regs + AST_VHUB_EP_ACK_IER);\n\twritel(imask, vhub->regs + AST_VHUB_EP_ACK_ISR);\n\n\t \n\tast_vhub_nuke(ep, -ESHUTDOWN);\n\n\t \n\tep->ep.desc = NULL;\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_vhub_epn_enable(struct usb_ep* u_ep,\n\t\t\t       const struct usb_endpoint_descriptor *desc)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub_dev *dev;\n\tstruct ast_vhub *vhub;\n\tu16 maxpacket, type;\n\tunsigned long flags;\n\tu32 ep_conf, ep_ier, imask;\n\n\t \n\tif (!u_ep || !desc)\n\t\treturn -EINVAL;\n\n\tmaxpacket = usb_endpoint_maxp(desc);\n\tif (!ep->d_idx || !ep->dev ||\n\t    desc->bDescriptorType != USB_DT_ENDPOINT ||\n\t    maxpacket == 0 || maxpacket > ep->ep.maxpacket) {\n\t\tEPDBG(ep, \"Invalid EP enable,d_idx=%d,dev=%p,type=%d,mp=%d/%d\\n\",\n\t\t      ep->d_idx, ep->dev, desc->bDescriptorType,\n\t\t      maxpacket, ep->ep.maxpacket);\n\t\treturn -EINVAL;\n\t}\n\tif (ep->d_idx != usb_endpoint_num(desc)) {\n\t\tEPDBG(ep, \"EP number mismatch !\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ep->epn.enabled) {\n\t\tEPDBG(ep, \"Already enabled\\n\");\n\t\treturn -EBUSY;\n\t}\n\tdev = ep->dev;\n\tvhub = ep->vhub;\n\n\t \n\tif (!dev->driver) {\n\t\tEPDBG(ep, \"Bogus device state: driver=%p speed=%d\\n\",\n\t\t       dev->driver, dev->gadget.speed);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tep->epn.is_in = usb_endpoint_dir_in(desc);\n\tep->ep.maxpacket = maxpacket;\n\ttype = usb_endpoint_type(desc);\n\tep->epn.d_next = ep->epn.d_last = 0;\n\tep->epn.is_iso = false;\n\tep->epn.stalled = false;\n\tep->epn.wedged = false;\n\n\tEPDBG(ep, \"Enabling [%s] %s num %d maxpacket=%d\\n\",\n\t      ep->epn.is_in ? \"in\" : \"out\", usb_ep_type_string(type),\n\t      usb_endpoint_num(desc), maxpacket);\n\n\t \n\tep->epn.desc_mode = ep->epn.descs && ep->epn.is_in;\n\tif (ep->epn.desc_mode)\n\t\tmemset(ep->epn.descs, 0, 8 * AST_VHUB_DESCS_COUNT);\n\n\t \n\tep->epn.chunk_max = ep->ep.maxpacket;\n\tif (ep->epn.is_in) {\n\t\tep->epn.chunk_max <<= 3;\n\t\twhile (ep->epn.chunk_max > 4095)\n\t\t\tep->epn.chunk_max -= ep->ep.maxpacket;\n\t}\n\n\tswitch(type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tEPDBG(ep, \"Only one control endpoint\\n\");\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep_conf = VHUB_EP_CFG_SET_TYPE(EP_TYPE_INT);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep_conf = VHUB_EP_CFG_SET_TYPE(EP_TYPE_BULK);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tep_conf = VHUB_EP_CFG_SET_TYPE(EP_TYPE_ISO);\n\t\tep->epn.is_iso = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (maxpacket < 1024)\n\t\tep_conf |= VHUB_EP_CFG_SET_MAX_PKT(maxpacket);\n\tif (!ep->epn.is_in)\n\t\tep_conf |= VHUB_EP_CFG_DIR_OUT;\n\tep_conf |= VHUB_EP_CFG_SET_EP_NUM(usb_endpoint_num(desc));\n\tep_conf |= VHUB_EP_CFG_ENABLE;\n\tep_conf |= VHUB_EP_CFG_SET_DEV(dev->index + 1);\n\tEPVDBG(ep, \"config=%08x\\n\", ep_conf);\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\twritel(0, ep->epn.regs + AST_VHUB_EP_CONFIG);\n\twritel(VHUB_EP_DMA_CTRL_RESET,\n\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\n\t \n\twritel(ep_conf, ep->epn.regs + AST_VHUB_EP_CONFIG);\n\n\tif (ep->epn.desc_mode) {\n\t\t \n\t\twritel(0, ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\n\t\t \n\t\twritel(ep->epn.descs_dma,\n\t\t       ep->epn.regs + AST_VHUB_EP_DESC_BASE);\n\n\t\t \n\t\tep->epn.dma_conf = VHUB_EP_DMA_DESC_MODE;\n\t\tif (ep->epn.is_in)\n\t\t\tep->epn.dma_conf |= VHUB_EP_DMA_IN_LONG_MODE;\n\n\t\t \n\t\twritel(ep->epn.dma_conf | VHUB_EP_DMA_CTRL_RESET,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\n\t\t \n\t\twritel(ep->epn.dma_conf,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t} else {\n\t\t \n\t\tep->epn.dma_conf = VHUB_EP_DMA_SINGLE_STAGE;\n\n\t\t \n\t\twritel(ep->epn.dma_conf | VHUB_EP_DMA_CTRL_RESET,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t\twritel(ep->epn.dma_conf,\n\t\t       ep->epn.regs + AST_VHUB_EP_DMA_CTLSTAT);\n\t\twritel(0, ep->epn.regs + AST_VHUB_EP_DESC_STATUS);\n\t}\n\n\t \n\twritel(VHUB_EP_TOGGLE_SET_EPNUM(ep->epn.g_idx),\n\t       vhub->regs + AST_VHUB_EP_TOGGLE);\n\n\t \n\timask = VHUB_EP_IRQ(ep->epn.g_idx);\n\twritel(imask, vhub->regs + AST_VHUB_EP_ACK_ISR);\n\tep_ier = readl(vhub->regs + AST_VHUB_EP_ACK_IER);\n\tep_ier |= imask;\n\twritel(ep_ier, vhub->regs + AST_VHUB_EP_ACK_IER);\n\n\t \n\tep->epn.enabled = true;\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic void ast_vhub_epn_dispose(struct usb_ep *u_ep)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\n\tif (WARN_ON(!ep->dev || !ep->d_idx))\n\t\treturn;\n\n\tEPDBG(ep, \"Releasing endpoint\\n\");\n\n\t \n\tlist_del_init(&ep->ep.ep_list);\n\n\t \n\tep->dev->epns[ep->d_idx - 1] = NULL;\n\n\t \n\tkfree(ep->ep.name);\n\tep->ep.name = NULL;\n\tdma_free_coherent(&ep->vhub->pdev->dev,\n\t\t\t  AST_VHUB_EPn_MAX_PACKET +\n\t\t\t  8 * AST_VHUB_DESCS_COUNT,\n\t\t\t  ep->buf, ep->buf_dma);\n\tep->buf = NULL;\n\tep->epn.descs = NULL;\n\n\t \n\tep->dev = NULL;\n}\n\nstatic const struct usb_ep_ops ast_vhub_epn_ops = {\n\t.enable\t\t= ast_vhub_epn_enable,\n\t.disable\t= ast_vhub_epn_disable,\n\t.dispose\t= ast_vhub_epn_dispose,\n\t.queue\t\t= ast_vhub_epn_queue,\n\t.dequeue\t= ast_vhub_epn_dequeue,\n\t.set_halt\t= ast_vhub_epn_set_halt,\n\t.set_wedge\t= ast_vhub_epn_set_wedge,\n\t.alloc_request\t= ast_vhub_alloc_request,\n\t.free_request\t= ast_vhub_free_request,\n};\n\nstruct ast_vhub_ep *ast_vhub_alloc_epn(struct ast_vhub_dev *d, u8 addr)\n{\n\tstruct ast_vhub *vhub = d->vhub;\n\tstruct ast_vhub_ep *ep;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&vhub->lock, flags);\n\tfor (i = 0; i < vhub->max_epns; i++)\n\t\tif (vhub->epns[i].dev == NULL)\n\t\t\tbreak;\n\tif (i >= vhub->max_epns) {\n\t\tspin_unlock_irqrestore(&vhub->lock, flags);\n\t\treturn NULL;\n\t}\n\n\t \n\tep = &vhub->epns[i];\n\tep->dev = d;\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\tDDBG(d, \"Allocating gen EP %d for addr %d\\n\", i, addr);\n\tINIT_LIST_HEAD(&ep->queue);\n\tep->d_idx = addr;\n\tep->vhub = vhub;\n\tep->ep.ops = &ast_vhub_epn_ops;\n\tep->ep.name = kasprintf(GFP_KERNEL, \"ep%d\", addr);\n\td->epns[addr-1] = ep;\n\tep->epn.g_idx = i;\n\tep->epn.regs = vhub->regs + 0x200 + (i * 0x10);\n\n\tep->buf = dma_alloc_coherent(&vhub->pdev->dev,\n\t\t\t\t     AST_VHUB_EPn_MAX_PACKET +\n\t\t\t\t     8 * AST_VHUB_DESCS_COUNT,\n\t\t\t\t     &ep->buf_dma, GFP_KERNEL);\n\tif (!ep->buf) {\n\t\tkfree(ep->ep.name);\n\t\tep->ep.name = NULL;\n\t\treturn NULL;\n\t}\n\tep->epn.descs = ep->buf + AST_VHUB_EPn_MAX_PACKET;\n\tep->epn.descs_dma = ep->buf_dma + AST_VHUB_EPn_MAX_PACKET;\n\n\tusb_ep_set_maxpacket_limit(&ep->ep, AST_VHUB_EPn_MAX_PACKET);\n\tlist_add_tail(&ep->ep.ep_list, &d->gadget.ep_list);\n\tep->ep.caps.type_iso = true;\n\tep->ep.caps.type_bulk = true;\n\tep->ep.caps.type_int = true;\n\tep->ep.caps.dir_in = true;\n\tep->ep.caps.dir_out = true;\n\n\treturn ep;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}