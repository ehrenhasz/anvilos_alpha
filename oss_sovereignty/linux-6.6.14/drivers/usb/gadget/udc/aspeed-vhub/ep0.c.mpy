{
  "module_name": "ep0.c",
  "hash_id": "46f917a0ea178fcdae87330f9570850b223cacb8c78d9d9409acd3c2d58098f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed-vhub/ep0.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n\n#include \"vhub.h\"\n\nint ast_vhub_reply(struct ast_vhub_ep *ep, char *ptr, int len)\n{\n\tstruct usb_request *req = &ep->ep0.req.req;\n\tint rc;\n\n\tif (WARN_ON(ep->d_idx != 0))\n\t\treturn std_req_stall;\n\tif (WARN_ON(!ep->ep0.dir_in))\n\t\treturn std_req_stall;\n\tif (WARN_ON(len > AST_VHUB_EP0_MAX_PACKET))\n\t\treturn std_req_stall;\n\tif (WARN_ON(req->status == -EINPROGRESS))\n\t\treturn std_req_stall;\n\n\treq->buf = ptr;\n\treq->length = len;\n\treq->complete = NULL;\n\treq->zero = true;\n\n\t \n\tspin_unlock(&ep->vhub->lock);\n\tif (ep->ep.ops->queue(&ep->ep, req, GFP_ATOMIC))\n\t\trc = std_req_stall;\n\telse\n\t\trc = std_req_data;\n\tspin_lock(&ep->vhub->lock);\n\treturn rc;\n}\n\nint __ast_vhub_simple_reply(struct ast_vhub_ep *ep, int len, ...)\n{\n\tu8 *buffer = ep->buf;\n\tunsigned int i;\n\tva_list args;\n\n\tva_start(args, len);\n\n\t \n\tfor (i = 0; i < len; i++)\n\t\tbuffer[i] = va_arg(args, int);\n\tva_end(args);\n\n\t \n\treturn ast_vhub_reply(ep, NULL, len);\n}\n\nvoid ast_vhub_ep0_handle_setup(struct ast_vhub_ep *ep)\n{\n\tstruct usb_ctrlrequest crq;\n\tenum std_req_rc std_req_rc;\n\tint rc = -ENODEV;\n\n\tif (WARN_ON(ep->d_idx != 0))\n\t\treturn;\n\n\t \n\tmemcpy_fromio(&crq, ep->ep0.setup, sizeof(crq));\n\n\tEPDBG(ep, \"SETUP packet %02x/%02x/%04x/%04x/%04x [%s] st=%d\\n\",\n\t      crq.bRequestType, crq.bRequest,\n\t       le16_to_cpu(crq.wValue),\n\t       le16_to_cpu(crq.wIndex),\n\t       le16_to_cpu(crq.wLength),\n\t       (crq.bRequestType & USB_DIR_IN) ? \"in\" : \"out\",\n\t       ep->ep0.state);\n\n\t \n\tif (ep->ep0.state != ep0_state_token &&\n\t    ep->ep0.state != ep0_state_stall) {\n\t\tEPDBG(ep, \"wrong state\\n\");\n\t\tast_vhub_nuke(ep, -EIO);\n\t}\n\n\t \n\tep->ep0.state = ep0_state_data;\n\tep->ep0.dir_in = !!(crq.bRequestType & USB_DIR_IN);\n\n\t \n\tstd_req_rc = std_req_driver;\n\tif (ep->dev == NULL) {\n\t\tif ((crq.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\t\tstd_req_rc = ast_vhub_std_hub_request(ep, &crq);\n\t\telse if ((crq.bRequestType & USB_TYPE_MASK) == USB_TYPE_CLASS)\n\t\t\tstd_req_rc = ast_vhub_class_hub_request(ep, &crq);\n\t\telse\n\t\t\tstd_req_rc = std_req_stall;\n\t} else if ((crq.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tstd_req_rc = ast_vhub_std_dev_request(ep, &crq);\n\n\t \n\tswitch(std_req_rc) {\n\tcase std_req_complete:\n\t\tgoto complete;\n\tcase std_req_stall:\n\t\tgoto stall;\n\tcase std_req_driver:\n\t\tbreak;\n\tcase std_req_data:\n\t\treturn;\n\t}\n\n\t \n\tif (WARN_ON(!ep->dev))\n\t\tgoto stall;\n\tif (ep->dev->driver) {\n\t\tEPDBG(ep, \"forwarding to gadget...\\n\");\n\t\tspin_unlock(&ep->vhub->lock);\n\t\trc = ep->dev->driver->setup(&ep->dev->gadget, &crq);\n\t\tspin_lock(&ep->vhub->lock);\n\t\tEPDBG(ep, \"driver returned %d\\n\", rc);\n\t} else {\n\t\tEPDBG(ep, \"no gadget for request !\\n\");\n\t}\n\tif (rc >= 0)\n\t\treturn;\n\n stall:\n\tEPDBG(ep, \"stalling\\n\");\n\twritel(VHUB_EP0_CTRL_STALL, ep->ep0.ctlstat);\n\tep->ep0.state = ep0_state_stall;\n\tep->ep0.dir_in = false;\n\treturn;\n\n complete:\n\tEPVDBG(ep, \"sending [in] status with no data\\n\");\n\twritel(VHUB_EP0_TX_BUFF_RDY, ep->ep0.ctlstat);\n\tep->ep0.state = ep0_state_status;\n\tep->ep0.dir_in = false;\n}\n\n\nstatic void ast_vhub_ep0_do_send(struct ast_vhub_ep *ep,\n\t\t\t\t struct ast_vhub_req *req)\n{\n\tunsigned int chunk;\n\tu32 reg;\n\n\t \n\tif (req->req.length == 0)\n\t\treq->last_desc = 1;\n\n\t \n\tif (req->last_desc >= 0) {\n\t\tEPVDBG(ep, \"complete send %d/%d\\n\",\n\t\t       req->req.actual, req->req.length);\n\t\tep->ep0.state = ep0_state_status;\n\t\twritel(VHUB_EP0_RX_BUFF_RDY, ep->ep0.ctlstat);\n\t\tast_vhub_done(ep, req, 0);\n\t\treturn;\n\t}\n\n\t \n\tchunk = req->req.length - req->req.actual;\n\tif (chunk > ep->ep.maxpacket)\n\t\tchunk = ep->ep.maxpacket;\n\telse if ((chunk < ep->ep.maxpacket) || !req->req.zero)\n\t\treq->last_desc = 1;\n\n\tEPVDBG(ep, \"send chunk=%d last=%d, req->act=%d mp=%d\\n\",\n\t       chunk, req->last_desc, req->req.actual, ep->ep.maxpacket);\n\n\t \n\tif (chunk && req->req.buf)\n\t\tmemcpy(ep->buf, req->req.buf + req->req.actual, chunk);\n\n\tvhub_dma_workaround(ep->buf);\n\n\t \n\treg = VHUB_EP0_SET_TX_LEN(chunk);\n\twritel(reg, ep->ep0.ctlstat);\n\twritel(reg | VHUB_EP0_TX_BUFF_RDY, ep->ep0.ctlstat);\n\treq->req.actual += chunk;\n}\n\nstatic void ast_vhub_ep0_rx_prime(struct ast_vhub_ep *ep)\n{\n\tEPVDBG(ep, \"rx prime\\n\");\n\n\t \n\twritel(VHUB_EP0_RX_BUFF_RDY, ep->ep0.ctlstat);\n}\n\nstatic void ast_vhub_ep0_do_receive(struct ast_vhub_ep *ep, struct ast_vhub_req *req,\n\t\t\t\t    unsigned int len)\n{\n\tunsigned int remain;\n\tint rc = 0;\n\n\t \n\tremain = req->req.length - req->req.actual;\n\n\tEPVDBG(ep, \"receive got=%d remain=%d\\n\", len, remain);\n\n\t \n\tif (len > remain) {\n\t\tEPDBG(ep, \"receiving too much (ovf: %d) !\\n\",\n\t\t      len - remain);\n\t\tlen = remain;\n\t\trc = -EOVERFLOW;\n\t}\n\n\t \n\tif (len < ep->ep.maxpacket && len != remain) {\n\t\tEPDBG(ep, \"using expected data len instead\\n\");\n\t\tlen = remain;\n\t}\n\n\tif (len && req->req.buf)\n\t\tmemcpy(req->req.buf + req->req.actual, ep->buf, len);\n\treq->req.actual += len;\n\n\t \n\tif (len < ep->ep.maxpacket || len == remain) {\n\t\tep->ep0.state = ep0_state_status;\n\t\twritel(VHUB_EP0_TX_BUFF_RDY, ep->ep0.ctlstat);\n\t\tast_vhub_done(ep, req, rc);\n\t} else\n\t\tast_vhub_ep0_rx_prime(ep);\n}\n\nvoid ast_vhub_ep0_handle_ack(struct ast_vhub_ep *ep, bool in_ack)\n{\n\tstruct ast_vhub_req *req;\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct device *dev = &vhub->pdev->dev;\n\tbool stall = false;\n\tu32 stat;\n\n\t \n\tstat = readl(ep->ep0.ctlstat);\n\n\t \n\treq = list_first_entry_or_null(&ep->queue, struct ast_vhub_req, queue);\n\n\tEPVDBG(ep, \"ACK status=%08x,state=%d is_in=%d in_ack=%d req=%p\\n\",\n\t\tstat, ep->ep0.state, ep->ep0.dir_in, in_ack, req);\n\n\tswitch(ep->ep0.state) {\n\tcase ep0_state_token:\n\t\t \n\t\tif (req) {\n\t\t\tdev_warn(dev, \"request present while in TOKEN state\\n\");\n\t\t\tast_vhub_nuke(ep, -EINVAL);\n\t\t}\n\t\tdev_warn(dev, \"ack while in TOKEN state\\n\");\n\t\tstall = true;\n\t\tbreak;\n\tcase ep0_state_data:\n\t\t \n\t\tif ((ep->ep0.dir_in && (stat & VHUB_EP0_TX_BUFF_RDY)) ||\n\t\t    (!ep->ep0.dir_in && (stat & VHUB_EP0_RX_BUFF_RDY)) ||\n\t\t    (ep->ep0.dir_in != in_ack)) {\n\t\t\t \n\t\t\tdev_warn(dev, \"irq state mismatch\");\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (!req) {\n\t\t\tdev_warn(dev, \"data phase, no request\\n\");\n\t\t\tstall = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ep->ep0.dir_in)\n\t\t\tast_vhub_ep0_do_send(ep, req);\n\t\telse\n\t\t\tast_vhub_ep0_do_receive(ep, req, VHUB_EP0_RX_LEN(stat));\n\t\treturn;\n\tcase ep0_state_status:\n\t\t \n\t\tif (req) {\n\t\t\tdev_warn(dev, \"request present while in STATUS state\\n\");\n\t\t\tast_vhub_nuke(ep, -EINVAL);\n\t\t}\n\n\t\t \n\t\tif (ep->ep0.dir_in == in_ack) {\n\t\t\tdev_warn(dev, \"status direction mismatch\\n\");\n\t\t\tstall = true;\n\t\t}\n\t\tbreak;\n\tcase ep0_state_stall:\n\t\t \n\t\tast_vhub_nuke(ep, -EIO);\n\t\tbreak;\n\t}\n\n\t \n\tif (stall) {\n\t\twritel(VHUB_EP0_CTRL_STALL, ep->ep0.ctlstat);\n\t\tep->ep0.state = ep0_state_stall;\n\t} else\n\t\tep->ep0.state = ep0_state_token;\n}\n\nstatic int ast_vhub_ep0_queue(struct usb_ep* u_ep, struct usb_request *u_req,\n\t\t\t      gfp_t gfp_flags)\n{\n\tstruct ast_vhub_req *req = to_ast_req(u_req);\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct device *dev = &vhub->pdev->dev;\n\tunsigned long flags;\n\n\t \n\tif (!u_req || (!u_req->complete && !req->internal)) {\n\t\tdev_warn(dev, \"Bogus EP0 request ! u_req=%p\\n\", u_req);\n\t\tif (u_req) {\n\t\t\tdev_warn(dev, \"complete=%p internal=%d\\n\",\n\t\t\t\t u_req->complete, req->internal);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (WARN_ON(ep->d_idx != 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (ep->dev && !ep->dev->enabled)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (u_req->length && !u_req->buf && !req->internal) {\n\t\tdev_warn(dev, \"Request with no buffer !\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tEPVDBG(ep, \"enqueue req @%p\\n\", req);\n\tEPVDBG(ep, \"  l=%d zero=%d noshort=%d is_in=%d\\n\",\n\t       u_req->length, u_req->zero,\n\t       u_req->short_not_ok, ep->ep0.dir_in);\n\n\t \n\tu_req->status = -EINPROGRESS;\n\tu_req->actual = 0;\n\treq->last_desc = -1;\n\treq->active = false;\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\tif (!list_empty(&ep->queue) ||\n\t    ep->ep0.state == ep0_state_token ||\n\t    ep->ep0.state == ep0_state_stall) {\n\t\tdev_warn(dev, \"EP0: Request in wrong state\\n\");\n\t        EPVDBG(ep, \"EP0: list_empty=%d state=%d\\n\",\n\t\t       list_empty(&ep->queue), ep->ep0.state);\n\t\tspin_unlock_irqrestore(&vhub->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tlist_add_tail(&req->queue, &ep->queue);\n\n\tif (ep->ep0.dir_in) {\n\t\t \n\t\tast_vhub_ep0_do_send(ep, req);\n\t} else if (u_req->length == 0) {\n\t\t \n\t\tEPVDBG(ep, \"0-length rx completion\\n\");\n\t\tep->ep0.state = ep0_state_status;\n\t\twritel(VHUB_EP0_TX_BUFF_RDY, ep->ep0.ctlstat);\n\t\tast_vhub_done(ep, req, 0);\n\t} else {\n\t\t \n\t\tast_vhub_ep0_rx_prime(ep);\n\t}\n\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_vhub_ep0_dequeue(struct usb_ep* u_ep, struct usb_request *u_req)\n{\n\tstruct ast_vhub_ep *ep = to_ast_ep(u_ep);\n\tstruct ast_vhub *vhub = ep->vhub;\n\tstruct ast_vhub_req *req;\n\tunsigned long flags;\n\tint rc = -EINVAL;\n\n\tspin_lock_irqsave(&vhub->lock, flags);\n\n\t \n\treq = list_first_entry_or_null(&ep->queue, struct ast_vhub_req, queue);\n\n\t \n\tif (req && u_req == &req->req) {\n\t\tEPVDBG(ep, \"dequeue req @%p\\n\", req);\n\n\t\t \n\t\tast_vhub_done(ep, req, -ECONNRESET);\n\n\t\t \n\t\twritel(VHUB_EP0_CTRL_STALL, ep->ep0.ctlstat);\n\t\tep->ep0.state = ep0_state_status;\n\t\tep->ep0.dir_in = false;\n\t\trc = 0;\n\t}\n\tspin_unlock_irqrestore(&vhub->lock, flags);\n\treturn rc;\n}\n\n\nstatic const struct usb_ep_ops ast_vhub_ep0_ops = {\n\t.queue\t\t= ast_vhub_ep0_queue,\n\t.dequeue\t= ast_vhub_ep0_dequeue,\n\t.alloc_request\t= ast_vhub_alloc_request,\n\t.free_request\t= ast_vhub_free_request,\n};\n\nvoid ast_vhub_reset_ep0(struct ast_vhub_dev *dev)\n{\n\tstruct ast_vhub_ep *ep = &dev->ep0;\n\n\tast_vhub_nuke(ep, -EIO);\n\tep->ep0.state = ep0_state_token;\n}\n\n\nvoid ast_vhub_init_ep0(struct ast_vhub *vhub, struct ast_vhub_ep *ep,\n\t\t       struct ast_vhub_dev *dev)\n{\n\tmemset(ep, 0, sizeof(*ep));\n\n\tINIT_LIST_HEAD(&ep->ep.ep_list);\n\tINIT_LIST_HEAD(&ep->queue);\n\tep->ep.ops = &ast_vhub_ep0_ops;\n\tep->ep.name = \"ep0\";\n\tep->ep.caps.type_control = true;\n\tusb_ep_set_maxpacket_limit(&ep->ep, AST_VHUB_EP0_MAX_PACKET);\n\tep->d_idx = 0;\n\tep->dev = dev;\n\tep->vhub = vhub;\n\tep->ep0.state = ep0_state_token;\n\tINIT_LIST_HEAD(&ep->ep0.req.queue);\n\tep->ep0.req.internal = true;\n\n\t \n\tif (dev) {\n\t\tep->ep0.ctlstat = dev->regs + AST_VHUB_DEV_EP0_CTRL;\n\t\tep->ep0.setup = vhub->regs +\n\t\t\tAST_VHUB_SETUP0 + 8 * (dev->index + 1);\n\t\tep->buf = vhub->ep0_bufs +\n\t\t\tAST_VHUB_EP0_MAX_PACKET * (dev->index + 1);\n\t\tep->buf_dma = vhub->ep0_bufs_dma +\n\t\t\tAST_VHUB_EP0_MAX_PACKET * (dev->index + 1);\n\t} else {\n\t\tep->ep0.ctlstat = vhub->regs + AST_VHUB_EP0_CTRL;\n\t\tep->ep0.setup = vhub->regs + AST_VHUB_SETUP0;\n\t\tep->buf = vhub->ep0_bufs;\n\t\tep->buf_dma = vhub->ep0_bufs_dma;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}