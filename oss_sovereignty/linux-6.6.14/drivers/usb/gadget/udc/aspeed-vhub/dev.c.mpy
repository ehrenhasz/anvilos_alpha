{
  "module_name": "dev.c",
  "hash_id": "e40d807f05d3ac1233227cb844c8293bfc86ea2c9bf7fad7a00cf488e4eafead",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed-vhub/dev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"vhub.h\"\n\nvoid ast_vhub_dev_irq(struct ast_vhub_dev *d)\n{\n\tu32 istat = readl(d->regs + AST_VHUB_DEV_ISR);\n\n\twritel(istat, d->regs + AST_VHUB_DEV_ISR);\n\n\tif (istat & VHUV_DEV_IRQ_EP0_IN_ACK_STALL)\n\t\tast_vhub_ep0_handle_ack(&d->ep0, true);\n\tif (istat & VHUV_DEV_IRQ_EP0_OUT_ACK_STALL)\n\t\tast_vhub_ep0_handle_ack(&d->ep0, false);\n\tif (istat & VHUV_DEV_IRQ_EP0_SETUP)\n\t\tast_vhub_ep0_handle_setup(&d->ep0);\n}\n\nstatic void ast_vhub_dev_enable(struct ast_vhub_dev *d)\n{\n\tu32 reg, hmsk, i;\n\n\tif (d->enabled)\n\t\treturn;\n\n\t \n\tast_vhub_reset_ep0(d);\n\n\t \n\treg = VHUB_DEV_EN_ENABLE_PORT |\n\t\tVHUB_DEV_EN_EP0_IN_ACK_IRQEN |\n\t\tVHUB_DEV_EN_EP0_OUT_ACK_IRQEN |\n\t\tVHUB_DEV_EN_EP0_SETUP_IRQEN;\n\tif (d->gadget.speed == USB_SPEED_HIGH)\n\t\treg |= VHUB_DEV_EN_SPEED_SEL_HIGH;\n\twritel(reg, d->regs + AST_VHUB_DEV_EN_CTRL);\n\n\t \n\thmsk = VHUB_IRQ_DEVICE1 << d->index;\n\treg = readl(d->vhub->regs + AST_VHUB_IER);\n\treg |= hmsk;\n\twritel(reg, d->vhub->regs + AST_VHUB_IER);\n\n\t \n\twritel(d->ep0.buf_dma, d->regs + AST_VHUB_DEV_EP0_DATA);\n\n\t \n\tfor (i = 0; i < d->max_epns; i++) {\n\t\tstruct ast_vhub_ep *ep = d->epns[i];\n\n\t\tif (ep && (ep->epn.stalled || ep->epn.wedged)) {\n\t\t\tep->epn.stalled = false;\n\t\t\tep->epn.wedged = false;\n\t\t\tast_vhub_update_epn_stall(ep);\n\t\t}\n\t}\n\n\t \n\td->wakeup_en = false;\n\td->enabled = true;\n}\n\nstatic void ast_vhub_dev_disable(struct ast_vhub_dev *d)\n{\n\tu32 reg, hmsk;\n\n\tif (!d->enabled)\n\t\treturn;\n\n\t \n\thmsk = VHUB_IRQ_DEVICE1 << d->index;\n\treg = readl(d->vhub->regs + AST_VHUB_IER);\n\treg &= ~hmsk;\n\twritel(reg, d->vhub->regs + AST_VHUB_IER);\n\n\t \n\twritel(0, d->regs + AST_VHUB_DEV_EN_CTRL);\n\td->gadget.speed = USB_SPEED_UNKNOWN;\n\td->enabled = false;\n}\n\nstatic int ast_vhub_dev_feature(struct ast_vhub_dev *d,\n\t\t\t\tu16 wIndex, u16 wValue,\n\t\t\t\tbool is_set)\n{\n\tu32 val;\n\n\tDDBG(d, \"%s_FEATURE(dev val=%02x)\\n\",\n\t     is_set ? \"SET\" : \"CLEAR\", wValue);\n\n\tif (wValue == USB_DEVICE_REMOTE_WAKEUP) {\n\t\td->wakeup_en = is_set;\n\t\treturn std_req_complete;\n\t}\n\n\tif (wValue == USB_DEVICE_TEST_MODE) {\n\t\tval = readl(d->vhub->regs + AST_VHUB_CTRL);\n\t\tval &= ~GENMASK(10, 8);\n\t\tval |= VHUB_CTRL_SET_TEST_MODE((wIndex >> 8) & 0x7);\n\t\twritel(val, d->vhub->regs + AST_VHUB_CTRL);\n\n\t\treturn std_req_complete;\n\t}\n\n\treturn std_req_driver;\n}\n\nstatic int ast_vhub_ep_feature(struct ast_vhub_dev *d,\n\t\t\t       u16 wIndex, u16 wValue, bool is_set)\n{\n\tstruct ast_vhub_ep *ep;\n\tint ep_num;\n\n\tep_num = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\tDDBG(d, \"%s_FEATURE(ep%d val=%02x)\\n\",\n\t     is_set ? \"SET\" : \"CLEAR\", ep_num, wValue);\n\tif (ep_num == 0)\n\t\treturn std_req_complete;\n\tif (ep_num >= d->max_epns || !d->epns[ep_num - 1])\n\t\treturn std_req_stall;\n\tif (wValue != USB_ENDPOINT_HALT)\n\t\treturn std_req_driver;\n\n\tep = d->epns[ep_num - 1];\n\tif (WARN_ON(!ep))\n\t\treturn std_req_stall;\n\n\tif (!ep->epn.enabled || !ep->ep.desc || ep->epn.is_iso ||\n\t    ep->epn.is_in != !!(wIndex & USB_DIR_IN))\n\t\treturn std_req_stall;\n\n\tDDBG(d, \"%s stall on EP %d\\n\",\n\t     is_set ? \"setting\" : \"clearing\", ep_num);\n\tep->epn.stalled = is_set;\n\tast_vhub_update_epn_stall(ep);\n\n\treturn std_req_complete;\n}\n\nstatic int ast_vhub_dev_status(struct ast_vhub_dev *d,\n\t\t\t       u16 wIndex, u16 wValue)\n{\n\tu8 st0;\n\n\tDDBG(d, \"GET_STATUS(dev)\\n\");\n\n\tst0 = d->gadget.is_selfpowered << USB_DEVICE_SELF_POWERED;\n\tif (d->wakeup_en)\n\t\tst0 |= 1 << USB_DEVICE_REMOTE_WAKEUP;\n\n\treturn ast_vhub_simple_reply(&d->ep0, st0, 0);\n}\n\nstatic int ast_vhub_ep_status(struct ast_vhub_dev *d,\n\t\t\t      u16 wIndex, u16 wValue)\n{\n\tint ep_num = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\tstruct ast_vhub_ep *ep;\n\tu8 st0 = 0;\n\n\tDDBG(d, \"GET_STATUS(ep%d)\\n\", ep_num);\n\n\tif (ep_num >= d->max_epns)\n\t\treturn std_req_stall;\n\tif (ep_num != 0) {\n\t\tep = d->epns[ep_num - 1];\n\t\tif (!ep)\n\t\t\treturn std_req_stall;\n\t\tif (!ep->epn.enabled || !ep->ep.desc || ep->epn.is_iso ||\n\t\t    ep->epn.is_in != !!(wIndex & USB_DIR_IN))\n\t\t\treturn std_req_stall;\n\t\tif (ep->epn.stalled)\n\t\t\tst0 |= 1 << USB_ENDPOINT_HALT;\n\t}\n\n\treturn ast_vhub_simple_reply(&d->ep0, st0, 0);\n}\n\nstatic void ast_vhub_dev_set_address(struct ast_vhub_dev *d, u8 addr)\n{\n\tu32 reg;\n\n\tDDBG(d, \"SET_ADDRESS: Got address %x\\n\", addr);\n\n\treg = readl(d->regs + AST_VHUB_DEV_EN_CTRL);\n\treg &= ~VHUB_DEV_EN_ADDR_MASK;\n\treg |= VHUB_DEV_EN_SET_ADDR(addr);\n\twritel(reg, d->regs + AST_VHUB_DEV_EN_CTRL);\n}\n\nint ast_vhub_std_dev_request(struct ast_vhub_ep *ep,\n\t\t\t     struct usb_ctrlrequest *crq)\n{\n\tstruct ast_vhub_dev *d = ep->dev;\n\tu16 wValue, wIndex;\n\n\t \n\tif (!d->driver || !d->enabled) {\n\t\tEPDBG(ep,\n\t\t      \"Device is wrong state driver=%p enabled=%d\\n\",\n\t\t      d->driver, d->enabled);\n\t\treturn std_req_stall;\n\t}\n\n\t \n\n\t \n\tif (d->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\td->gadget.speed = ep->vhub->speed;\n\t\tif (d->gadget.speed > d->driver->max_speed)\n\t\t\td->gadget.speed = d->driver->max_speed;\n\t\tDDBG(d, \"fist packet, captured speed %d\\n\",\n\t\t     d->gadget.speed);\n\t}\n\n\twValue = le16_to_cpu(crq->wValue);\n\twIndex = le16_to_cpu(crq->wIndex);\n\n\tswitch ((crq->bRequestType << 8) | crq->bRequest) {\n\t\t \n\tcase DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\t\tast_vhub_dev_set_address(d, wValue);\n\t\treturn std_req_complete;\n\n\t\t \n\tcase DeviceRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_dev_status(d, wIndex, wValue);\n\tcase InterfaceRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_simple_reply(ep, 0, 0);\n\tcase EndpointRequest | USB_REQ_GET_STATUS:\n\t\treturn ast_vhub_ep_status(d, wIndex, wValue);\n\n\t\t \n\tcase DeviceOutRequest | USB_REQ_SET_FEATURE:\n\t\treturn ast_vhub_dev_feature(d, wIndex, wValue, true);\n\tcase DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\n\t\treturn ast_vhub_dev_feature(d, wIndex, wValue, false);\n\tcase EndpointOutRequest | USB_REQ_SET_FEATURE:\n\t\treturn ast_vhub_ep_feature(d, wIndex, wValue, true);\n\tcase EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\t\treturn ast_vhub_ep_feature(d, wIndex, wValue, false);\n\t}\n\treturn std_req_driver;\n}\n\nstatic int ast_vhub_udc_wakeup(struct usb_gadget* gadget)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\tunsigned long flags;\n\tint rc = -EINVAL;\n\n\tspin_lock_irqsave(&d->vhub->lock, flags);\n\tif (!d->wakeup_en)\n\t\tgoto err;\n\n\tDDBG(d, \"Device initiated wakeup\\n\");\n\n\t \n\tast_vhub_hub_wake_all(d->vhub);\n\trc = 0;\n err:\n\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\treturn rc;\n}\n\nstatic int ast_vhub_udc_get_frame(struct usb_gadget* gadget)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\n\treturn (readl(d->vhub->regs + AST_VHUB_USBSTS) >> 16) & 0x7ff;\n}\n\nstatic void ast_vhub_dev_nuke(struct ast_vhub_dev *d)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < d->max_epns; i++) {\n\t\tif (!d->epns[i])\n\t\t\tcontinue;\n\t\tast_vhub_nuke(d->epns[i], -ESHUTDOWN);\n\t}\n}\n\nstatic int ast_vhub_udc_pullup(struct usb_gadget* gadget, int on)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&d->vhub->lock, flags);\n\n\tDDBG(d, \"pullup(%d)\\n\", on);\n\n\t \n\tast_vhub_device_connect(d->vhub, d->index, on);\n\n\t \n\tif (d->enabled) {\n\t\tast_vhub_dev_nuke(d);\n\t\tast_vhub_dev_disable(d);\n\t}\n\n\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_vhub_udc_start(struct usb_gadget *gadget,\n\t\t\t      struct usb_gadget_driver *driver)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&d->vhub->lock, flags);\n\n\tDDBG(d, \"start\\n\");\n\n\t \n\td->driver = driver;\n\td->gadget.is_selfpowered = 1;\n\n\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_ep *ast_vhub_udc_match_ep(struct usb_gadget *gadget,\n\t\t\t\t\t    struct usb_endpoint_descriptor *desc,\n\t\t\t\t\t    struct usb_ss_ep_comp_descriptor *ss)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\tstruct ast_vhub_ep *ep;\n\tstruct usb_ep *u_ep;\n\tunsigned int max, addr, i;\n\n\tDDBG(d, \"Match EP type %d\\n\", usb_endpoint_type(desc));\n\n\t \n\tlist_for_each_entry(u_ep, &gadget->ep_list, ep_list) {\n\t\tif (usb_gadget_ep_match_desc(gadget, u_ep, desc, ss)) {\n\t\t\tDDBG(d, \" -> using existing EP%d\\n\",\n\t\t\t     to_ast_ep(u_ep)->d_idx);\n\t\t\treturn u_ep;\n\t\t}\n\t}\n\n\t \n\tswitch(usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\treturn NULL;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tif (gadget_is_dualspeed(gadget))\n\t\t\tmax = 1024;\n\t\telse\n\t\t\tmax = 1023;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (gadget_is_dualspeed(gadget))\n\t\t\tmax = 512;\n\t\telse\n\t\t\tmax = 64;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (gadget_is_dualspeed(gadget))\n\t\t\tmax = 1024;\n\t\telse\n\t\t\tmax = 64;\n\t\tbreak;\n\t}\n\tif (usb_endpoint_maxp(desc) > max)\n\t\treturn NULL;\n\n\t \n\tfor (i = 0; i < d->max_epns; i++)\n\t\tif (d->epns[i] == NULL)\n\t\t\tbreak;\n\tif (i >= d->max_epns)\n\t\treturn NULL;\n\taddr = i + 1;\n\n\t \n\tep = ast_vhub_alloc_epn(d, addr);\n\tif (!ep)\n\t\treturn NULL;\n\tDDBG(d, \"Allocated epn#%d for port EP%d\\n\",\n\t     ep->epn.g_idx, addr);\n\n\treturn &ep->ep;\n}\n\nstatic int ast_vhub_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct ast_vhub_dev *d = to_ast_dev(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&d->vhub->lock, flags);\n\n\tDDBG(d, \"stop\\n\");\n\n\td->driver = NULL;\n\td->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tast_vhub_dev_nuke(d);\n\n\tif (d->enabled)\n\t\tast_vhub_dev_disable(d);\n\n\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops ast_vhub_udc_ops = {\n\t.get_frame\t= ast_vhub_udc_get_frame,\n\t.wakeup\t\t= ast_vhub_udc_wakeup,\n\t.pullup\t\t= ast_vhub_udc_pullup,\n\t.udc_start\t= ast_vhub_udc_start,\n\t.udc_stop\t= ast_vhub_udc_stop,\n\t.match_ep\t= ast_vhub_udc_match_ep,\n};\n\nvoid ast_vhub_dev_suspend(struct ast_vhub_dev *d)\n{\n\tif (d->driver && d->driver->suspend) {\n\t\tspin_unlock(&d->vhub->lock);\n\t\td->driver->suspend(&d->gadget);\n\t\tspin_lock(&d->vhub->lock);\n\t}\n}\n\nvoid ast_vhub_dev_resume(struct ast_vhub_dev *d)\n{\n\tif (d->driver && d->driver->resume) {\n\t\tspin_unlock(&d->vhub->lock);\n\t\td->driver->resume(&d->gadget);\n\t\tspin_lock(&d->vhub->lock);\n\t}\n}\n\nvoid ast_vhub_dev_reset(struct ast_vhub_dev *d)\n{\n\t \n\tif (!d->driver) {\n\t\tast_vhub_dev_disable(d);\n\t\treturn;\n\t}\n\n\t \n\tif (!d->enabled) {\n\t\tDDBG(d, \"Reset of disabled device, enabling...\\n\");\n\t\tast_vhub_dev_enable(d);\n\t} else {\n\t\tDDBG(d, \"Reset of enabled device, resetting...\\n\");\n\t\tspin_unlock(&d->vhub->lock);\n\t\tusb_gadget_udc_reset(&d->gadget, d->driver);\n\t\tspin_lock(&d->vhub->lock);\n\n\t\t \n\t\tast_vhub_dev_disable(d);\n\t\tast_vhub_dev_enable(d);\n\t}\n}\n\nvoid ast_vhub_del_dev(struct ast_vhub_dev *d)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&d->vhub->lock, flags);\n\tif (!d->registered) {\n\t\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\t\treturn;\n\t}\n\td->registered = false;\n\tspin_unlock_irqrestore(&d->vhub->lock, flags);\n\n\tusb_del_gadget_udc(&d->gadget);\n\tdevice_unregister(d->port_dev);\n\tkfree(d->epns);\n}\n\nstatic void ast_vhub_dev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nint ast_vhub_init_dev(struct ast_vhub *vhub, unsigned int idx)\n{\n\tstruct ast_vhub_dev *d = &vhub->ports[idx].dev;\n\tstruct device *parent = &vhub->pdev->dev;\n\tint rc;\n\n\td->vhub = vhub;\n\td->index = idx;\n\td->name = devm_kasprintf(parent, GFP_KERNEL, \"port%d\", idx+1);\n\td->regs = vhub->regs + 0x100 + 0x10 * idx;\n\n\tast_vhub_init_ep0(vhub, &d->ep0, d);\n\n\t \n\td->max_epns = min_t(u32, vhub->max_epns, 30);\n\td->epns = kcalloc(d->max_epns, sizeof(*d->epns), GFP_KERNEL);\n\tif (!d->epns)\n\t\treturn -ENOMEM;\n\n\t \n\td->port_dev = kzalloc(sizeof(struct device), GFP_KERNEL);\n\tif (!d->port_dev) {\n\t\trc = -ENOMEM;\n\t\tgoto fail_alloc;\n\t}\n\tdevice_initialize(d->port_dev);\n\td->port_dev->release = ast_vhub_dev_release;\n\td->port_dev->parent = parent;\n\tdev_set_name(d->port_dev, \"%s:p%d\", dev_name(parent), idx + 1);\n\trc = device_add(d->port_dev);\n\tif (rc)\n\t\tgoto fail_add;\n\n\t \n\tINIT_LIST_HEAD(&d->gadget.ep_list);\n\td->gadget.ops = &ast_vhub_udc_ops;\n\td->gadget.ep0 = &d->ep0.ep;\n\td->gadget.name = KBUILD_MODNAME;\n\tif (vhub->force_usb1)\n\t\td->gadget.max_speed = USB_SPEED_FULL;\n\telse\n\t\td->gadget.max_speed = USB_SPEED_HIGH;\n\td->gadget.speed = USB_SPEED_UNKNOWN;\n\td->gadget.dev.of_node = vhub->pdev->dev.of_node;\n\td->gadget.dev.of_node_reused = true;\n\n\trc = usb_add_gadget_udc(d->port_dev, &d->gadget);\n\tif (rc != 0)\n\t\tgoto fail_udc;\n\td->registered = true;\n\n\treturn 0;\n fail_udc:\n\tdevice_del(d->port_dev);\n fail_add:\n\tput_device(d->port_dev);\n fail_alloc:\n\tkfree(d->epns);\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}