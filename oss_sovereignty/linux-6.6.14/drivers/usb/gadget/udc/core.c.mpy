{
  "module_name": "core.c",
  "hash_id": "db6c73e2bbc43c58882e61a98ad37fa69f2d685e9dcdf0ad5c8e83146df909b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\"UDC core: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/idr.h>\n#include <linux/err.h>\n#include <linux/dma-mapping.h>\n#include <linux/sched/task_stack.h>\n#include <linux/workqueue.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb.h>\n\n#include \"trace.h\"\n\nstatic DEFINE_IDA(gadget_id_numbers);\n\nstatic const struct bus_type gadget_bus_type;\n\n \nstruct usb_udc {\n\tstruct usb_gadget_driver\t*driver;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct device\t\t\tdev;\n\tstruct list_head\t\tlist;\n\tbool\t\t\t\tvbus;\n\tbool\t\t\t\tstarted;\n\tbool\t\t\t\tallow_connect;\n\tstruct work_struct\t\tvbus_work;\n\tstruct mutex\t\t\tconnect_lock;\n};\n\nstatic const struct class udc_class;\nstatic LIST_HEAD(udc_list);\n\n \nstatic DEFINE_MUTEX(udc_lock);\n\n \n\n \nvoid usb_ep_set_maxpacket_limit(struct usb_ep *ep,\n\t\t\t\t\t      unsigned maxpacket_limit)\n{\n\tep->maxpacket_limit = maxpacket_limit;\n\tep->maxpacket = maxpacket_limit;\n\n\ttrace_usb_ep_set_maxpacket_limit(ep, 0);\n}\nEXPORT_SYMBOL_GPL(usb_ep_set_maxpacket_limit);\n\n \nint usb_ep_enable(struct usb_ep *ep)\n{\n\tint ret = 0;\n\n\tif (ep->enabled)\n\t\tgoto out;\n\n\t \n\tif (usb_endpoint_maxp(ep->desc) == 0) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ep->ops->enable(ep, ep->desc);\n\tif (ret)\n\t\tgoto out;\n\n\tep->enabled = true;\n\nout:\n\ttrace_usb_ep_enable(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_enable);\n\n \nint usb_ep_disable(struct usb_ep *ep)\n{\n\tint ret = 0;\n\n\tif (!ep->enabled)\n\t\tgoto out;\n\n\tret = ep->ops->disable(ep);\n\tif (ret)\n\t\tgoto out;\n\n\tep->enabled = false;\n\nout:\n\ttrace_usb_ep_disable(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_disable);\n\n \nstruct usb_request *usb_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t       gfp_t gfp_flags)\n{\n\tstruct usb_request *req = NULL;\n\n\treq = ep->ops->alloc_request(ep, gfp_flags);\n\n\ttrace_usb_ep_alloc_request(ep, req, req ? 0 : -ENOMEM);\n\n\treturn req;\n}\nEXPORT_SYMBOL_GPL(usb_ep_alloc_request);\n\n \nvoid usb_ep_free_request(struct usb_ep *ep,\n\t\t\t\t       struct usb_request *req)\n{\n\ttrace_usb_ep_free_request(ep, req, 0);\n\tep->ops->free_request(ep, req);\n}\nEXPORT_SYMBOL_GPL(usb_ep_free_request);\n\n \nint usb_ep_queue(struct usb_ep *ep,\n\t\t\t       struct usb_request *req, gfp_t gfp_flags)\n{\n\tint ret = 0;\n\n\tif (WARN_ON_ONCE(!ep->enabled && ep->address)) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\tret = ep->ops->queue(ep, req, gfp_flags);\n\nout:\n\ttrace_usb_ep_queue(ep, req, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_queue);\n\n \nint usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tint ret;\n\n\tret = ep->ops->dequeue(ep, req);\n\ttrace_usb_ep_dequeue(ep, req, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_dequeue);\n\n \nint usb_ep_set_halt(struct usb_ep *ep)\n{\n\tint ret;\n\n\tret = ep->ops->set_halt(ep, 1);\n\ttrace_usb_ep_set_halt(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_set_halt);\n\n \nint usb_ep_clear_halt(struct usb_ep *ep)\n{\n\tint ret;\n\n\tret = ep->ops->set_halt(ep, 0);\n\ttrace_usb_ep_clear_halt(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_clear_halt);\n\n \nint usb_ep_set_wedge(struct usb_ep *ep)\n{\n\tint ret;\n\n\tif (ep->ops->set_wedge)\n\t\tret = ep->ops->set_wedge(ep);\n\telse\n\t\tret = ep->ops->set_halt(ep, 1);\n\n\ttrace_usb_ep_set_wedge(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_set_wedge);\n\n \nint usb_ep_fifo_status(struct usb_ep *ep)\n{\n\tint ret;\n\n\tif (ep->ops->fifo_status)\n\t\tret = ep->ops->fifo_status(ep);\n\telse\n\t\tret = -EOPNOTSUPP;\n\n\ttrace_usb_ep_fifo_status(ep, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_ep_fifo_status);\n\n \nvoid usb_ep_fifo_flush(struct usb_ep *ep)\n{\n\tif (ep->ops->fifo_flush)\n\t\tep->ops->fifo_flush(ep);\n\n\ttrace_usb_ep_fifo_flush(ep, 0);\n}\nEXPORT_SYMBOL_GPL(usb_ep_fifo_flush);\n\n \n\n \nint usb_gadget_frame_number(struct usb_gadget *gadget)\n{\n\tint ret;\n\n\tret = gadget->ops->get_frame(gadget);\n\n\ttrace_usb_gadget_frame_number(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_frame_number);\n\n \nint usb_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->wakeup) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->wakeup(gadget);\n\nout:\n\ttrace_usb_gadget_wakeup(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_wakeup);\n\n \nint usb_gadget_set_remote_wakeup(struct usb_gadget *gadget, int set)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->set_remote_wakeup) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->set_remote_wakeup(gadget, set);\n\nout:\n\ttrace_usb_gadget_set_remote_wakeup(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_set_remote_wakeup);\n\n \nint usb_gadget_set_selfpowered(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->set_selfpowered) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->set_selfpowered(gadget, 1);\n\nout:\n\ttrace_usb_gadget_set_selfpowered(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_set_selfpowered);\n\n \nint usb_gadget_clear_selfpowered(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->set_selfpowered) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->set_selfpowered(gadget, 0);\n\nout:\n\ttrace_usb_gadget_clear_selfpowered(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_clear_selfpowered);\n\n \nint usb_gadget_vbus_connect(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->vbus_session) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->vbus_session(gadget, 1);\n\nout:\n\ttrace_usb_gadget_vbus_connect(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_vbus_connect);\n\n \nint usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->vbus_draw) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->vbus_draw(gadget, mA);\n\tif (!ret)\n\t\tgadget->mA = mA;\n\nout:\n\ttrace_usb_gadget_vbus_draw(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_vbus_draw);\n\n \nint usb_gadget_vbus_disconnect(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->vbus_session) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->vbus_session(gadget, 0);\n\nout:\n\ttrace_usb_gadget_vbus_disconnect(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_vbus_disconnect);\n\nstatic int usb_gadget_connect_locked(struct usb_gadget *gadget)\n\t__must_hold(&gadget->udc->connect_lock)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->pullup) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (gadget->deactivated || !gadget->udc->allow_connect || !gadget->udc->started) {\n\t\t \n\t\tgadget->connected = true;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->pullup(gadget, 1);\n\tif (!ret)\n\t\tgadget->connected = 1;\n\nout:\n\ttrace_usb_gadget_connect(gadget, ret);\n\n\treturn ret;\n}\n\n \nint usb_gadget_connect(struct usb_gadget *gadget)\n{\n\tint ret;\n\n\tmutex_lock(&gadget->udc->connect_lock);\n\tret = usb_gadget_connect_locked(gadget);\n\tmutex_unlock(&gadget->udc->connect_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_connect);\n\nstatic int usb_gadget_disconnect_locked(struct usb_gadget *gadget)\n\t__must_hold(&gadget->udc->connect_lock)\n{\n\tint ret = 0;\n\n\tif (!gadget->ops->pullup) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (!gadget->connected)\n\t\tgoto out;\n\n\tif (gadget->deactivated || !gadget->udc->started) {\n\t\t \n\t\tgadget->connected = false;\n\t\tgoto out;\n\t}\n\n\tret = gadget->ops->pullup(gadget, 0);\n\tif (!ret)\n\t\tgadget->connected = 0;\n\n\tmutex_lock(&udc_lock);\n\tif (gadget->udc->driver)\n\t\tgadget->udc->driver->disconnect(gadget);\n\tmutex_unlock(&udc_lock);\n\nout:\n\ttrace_usb_gadget_disconnect(gadget, ret);\n\n\treturn ret;\n}\n\n \nint usb_gadget_disconnect(struct usb_gadget *gadget)\n{\n\tint ret;\n\n\tmutex_lock(&gadget->udc->connect_lock);\n\tret = usb_gadget_disconnect_locked(gadget);\n\tmutex_unlock(&gadget->udc->connect_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_disconnect);\n\n \nint usb_gadget_deactivate(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tmutex_lock(&gadget->udc->connect_lock);\n\tif (gadget->deactivated)\n\t\tgoto unlock;\n\n\tif (gadget->connected) {\n\t\tret = usb_gadget_disconnect_locked(gadget);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\t \n\t\tgadget->connected = true;\n\t}\n\tgadget->deactivated = true;\n\nunlock:\n\tmutex_unlock(&gadget->udc->connect_lock);\n\ttrace_usb_gadget_deactivate(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_deactivate);\n\n \nint usb_gadget_activate(struct usb_gadget *gadget)\n{\n\tint ret = 0;\n\n\tmutex_lock(&gadget->udc->connect_lock);\n\tif (!gadget->deactivated)\n\t\tgoto unlock;\n\n\tgadget->deactivated = false;\n\n\t \n\tif (gadget->connected)\n\t\tret = usb_gadget_connect_locked(gadget);\n\nunlock:\n\tmutex_unlock(&gadget->udc->connect_lock);\n\ttrace_usb_gadget_activate(gadget, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_activate);\n\n \n\n#ifdef\tCONFIG_HAS_DMA\n\nint usb_gadget_map_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in)\n{\n\tif (req->length == 0)\n\t\treturn 0;\n\n\tif (req->num_sgs) {\n\t\tint     mapped;\n\n\t\tmapped = dma_map_sg(dev, req->sg, req->num_sgs,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\tif (mapped == 0) {\n\t\t\tdev_err(dev, \"failed to map SGs\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->num_mapped_sgs = mapped;\n\t} else {\n\t\tif (is_vmalloc_addr(req->buf)) {\n\t\t\tdev_err(dev, \"buffer is not dma capable\\n\");\n\t\t\treturn -EFAULT;\n\t\t} else if (object_is_on_stack(req->buf)) {\n\t\t\tdev_err(dev, \"buffer is on stack\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->dma = dma_map_single(dev, req->buf, req->length,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(dev, req->dma)) {\n\t\t\tdev_err(dev, \"failed to map buffer\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->dma_mapped = 1;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_map_request_by_dev);\n\nint usb_gadget_map_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in)\n{\n\treturn usb_gadget_map_request_by_dev(gadget->dev.parent, req, is_in);\n}\nEXPORT_SYMBOL_GPL(usb_gadget_map_request);\n\nvoid usb_gadget_unmap_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in)\n{\n\tif (req->length == 0)\n\t\treturn;\n\n\tif (req->num_mapped_sgs) {\n\t\tdma_unmap_sg(dev, req->sg, req->num_sgs,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\t\treq->num_mapped_sgs = 0;\n\t} else if (req->dma_mapped) {\n\t\tdma_unmap_single(dev, req->dma, req->length,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\treq->dma_mapped = 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_gadget_unmap_request_by_dev);\n\nvoid usb_gadget_unmap_request(struct usb_gadget *gadget,\n\t\tstruct usb_request *req, int is_in)\n{\n\tusb_gadget_unmap_request_by_dev(gadget->dev.parent, req, is_in);\n}\nEXPORT_SYMBOL_GPL(usb_gadget_unmap_request);\n\n#endif\t \n\n \n\n \nvoid usb_gadget_giveback_request(struct usb_ep *ep,\n\t\tstruct usb_request *req)\n{\n\tif (likely(req->status == 0))\n\t\tusb_led_activity(USB_LED_EVENT_GADGET);\n\n\ttrace_usb_gadget_giveback_request(ep, req, 0);\n\n\treq->complete(ep, req);\n}\nEXPORT_SYMBOL_GPL(usb_gadget_giveback_request);\n\n \n\n \nstruct usb_ep *gadget_find_ep_by_name(struct usb_gadget *g, const char *name)\n{\n\tstruct usb_ep *ep;\n\n\tgadget_for_each_ep(ep, g) {\n\t\tif (!strcmp(ep->name, name))\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(gadget_find_ep_by_name);\n\n \n\nint usb_gadget_ep_match_desc(struct usb_gadget *gadget,\n\t\tstruct usb_ep *ep, struct usb_endpoint_descriptor *desc,\n\t\tstruct usb_ss_ep_comp_descriptor *ep_comp)\n{\n\tu8\t\ttype;\n\tu16\t\tmax;\n\tint\t\tnum_req_streams = 0;\n\n\t \n\tif (ep->claimed)\n\t\treturn 0;\n\n\ttype = usb_endpoint_type(desc);\n\tmax = usb_endpoint_maxp(desc);\n\n\tif (usb_endpoint_dir_in(desc) && !ep->caps.dir_in)\n\t\treturn 0;\n\tif (usb_endpoint_dir_out(desc) && !ep->caps.dir_out)\n\t\treturn 0;\n\n\tif (max > ep->maxpacket_limit)\n\t\treturn 0;\n\n\t \n\tif (!gadget_is_dualspeed(gadget) && usb_endpoint_maxp_mult(desc) > 1)\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\treturn 0;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (!ep->caps.type_iso)\n\t\t\treturn 0;\n\t\t \n\t\tif (!gadget_is_dualspeed(gadget) && max > 1023)\n\t\t\treturn 0;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (!ep->caps.type_bulk)\n\t\t\treturn 0;\n\t\tif (ep_comp && gadget_is_superspeed(gadget)) {\n\t\t\t \n\t\t\tnum_req_streams = ep_comp->bmAttributes & 0x1f;\n\t\t\tif (num_req_streams > ep->max_streams)\n\t\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tif (!ep->caps.type_int && !ep->caps.type_bulk)\n\t\t\treturn 0;\n\t\t \n\t\tif (!gadget_is_dualspeed(gadget) && max > 64)\n\t\t\treturn 0;\n\t\tbreak;\n\t}\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_ep_match_desc);\n\n \nint usb_gadget_check_config(struct usb_gadget *gadget)\n{\n\tif (gadget->ops->check_config)\n\t\treturn gadget->ops->check_config(gadget);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_check_config);\n\n \n\nstatic void usb_gadget_state_work(struct work_struct *work)\n{\n\tstruct usb_gadget *gadget = work_to_gadget(work);\n\tstruct usb_udc *udc = gadget->udc;\n\n\tif (udc)\n\t\tsysfs_notify(&udc->dev.kobj, NULL, \"state\");\n}\n\nvoid usb_gadget_set_state(struct usb_gadget *gadget,\n\t\tenum usb_device_state state)\n{\n\tgadget->state = state;\n\tschedule_work(&gadget->work);\n}\nEXPORT_SYMBOL_GPL(usb_gadget_set_state);\n\n \n\n \nstatic void usb_udc_connect_control_locked(struct usb_udc *udc) __must_hold(&udc->connect_lock)\n{\n\tif (udc->vbus)\n\t\tusb_gadget_connect_locked(udc->gadget);\n\telse\n\t\tusb_gadget_disconnect_locked(udc->gadget);\n}\n\nstatic void vbus_event_work(struct work_struct *work)\n{\n\tstruct usb_udc *udc = container_of(work, struct usb_udc, vbus_work);\n\n\tmutex_lock(&udc->connect_lock);\n\tusb_udc_connect_control_locked(udc);\n\tmutex_unlock(&udc->connect_lock);\n}\n\n \nvoid usb_udc_vbus_handler(struct usb_gadget *gadget, bool status)\n{\n\tstruct usb_udc *udc = gadget->udc;\n\n\tif (udc) {\n\t\tudc->vbus = status;\n\t\tschedule_work(&udc->vbus_work);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_udc_vbus_handler);\n\n \nvoid usb_gadget_udc_reset(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tdriver->reset(gadget);\n\tusb_gadget_set_state(gadget, USB_STATE_DEFAULT);\n}\nEXPORT_SYMBOL_GPL(usb_gadget_udc_reset);\n\n \nstatic inline int usb_gadget_udc_start_locked(struct usb_udc *udc)\n\t__must_hold(&udc->connect_lock)\n{\n\tint ret;\n\n\tif (udc->started) {\n\t\tdev_err(&udc->dev, \"UDC had already started\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = udc->gadget->ops->udc_start(udc->gadget, udc->driver);\n\tif (!ret)\n\t\tudc->started = true;\n\n\treturn ret;\n}\n\n \nstatic inline void usb_gadget_udc_stop_locked(struct usb_udc *udc)\n\t__must_hold(&udc->connect_lock)\n{\n\tif (!udc->started) {\n\t\tdev_err(&udc->dev, \"UDC had already stopped\\n\");\n\t\treturn;\n\t}\n\n\tudc->gadget->ops->udc_stop(udc->gadget);\n\tudc->started = false;\n}\n\n \nstatic inline void usb_gadget_udc_set_speed(struct usb_udc *udc,\n\t\t\t\t\t    enum usb_device_speed speed)\n{\n\tstruct usb_gadget *gadget = udc->gadget;\n\tenum usb_device_speed s;\n\n\tif (speed == USB_SPEED_UNKNOWN)\n\t\ts = gadget->max_speed;\n\telse\n\t\ts = min(speed, gadget->max_speed);\n\n\tif (s == USB_SPEED_SUPER_PLUS && gadget->ops->udc_set_ssp_rate)\n\t\tgadget->ops->udc_set_ssp_rate(gadget, gadget->max_ssp_rate);\n\telse if (gadget->ops->udc_set_speed)\n\t\tgadget->ops->udc_set_speed(gadget, s);\n}\n\n \nstatic inline void usb_gadget_enable_async_callbacks(struct usb_udc *udc)\n{\n\tstruct usb_gadget *gadget = udc->gadget;\n\n\tif (gadget->ops->udc_async_callbacks)\n\t\tgadget->ops->udc_async_callbacks(gadget, true);\n}\n\n \nstatic inline void usb_gadget_disable_async_callbacks(struct usb_udc *udc)\n{\n\tstruct usb_gadget *gadget = udc->gadget;\n\n\tif (gadget->ops->udc_async_callbacks)\n\t\tgadget->ops->udc_async_callbacks(gadget, false);\n}\n\n \nstatic void usb_udc_release(struct device *dev)\n{\n\tstruct usb_udc *udc;\n\n\tudc = container_of(dev, struct usb_udc, dev);\n\tdev_dbg(dev, \"releasing '%s'\\n\", dev_name(dev));\n\tkfree(udc);\n}\n\nstatic const struct attribute_group *usb_udc_attr_groups[];\n\nstatic void usb_udc_nop_release(struct device *dev)\n{\n\tdev_vdbg(dev, \"%s\\n\", __func__);\n}\n\n \nvoid usb_initialize_gadget(struct device *parent, struct usb_gadget *gadget,\n\t\tvoid (*release)(struct device *dev))\n{\n\tINIT_WORK(&gadget->work, usb_gadget_state_work);\n\tgadget->dev.parent = parent;\n\n\tif (release)\n\t\tgadget->dev.release = release;\n\telse\n\t\tgadget->dev.release = usb_udc_nop_release;\n\n\tdevice_initialize(&gadget->dev);\n\tgadget->dev.bus = &gadget_bus_type;\n}\nEXPORT_SYMBOL_GPL(usb_initialize_gadget);\n\n \nint usb_add_gadget(struct usb_gadget *gadget)\n{\n\tstruct usb_udc\t\t*udc;\n\tint\t\t\tret = -ENOMEM;\n\n\tudc = kzalloc(sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\tgoto error;\n\n\tdevice_initialize(&udc->dev);\n\tudc->dev.release = usb_udc_release;\n\tudc->dev.class = &udc_class;\n\tudc->dev.groups = usb_udc_attr_groups;\n\tudc->dev.parent = gadget->dev.parent;\n\tret = dev_set_name(&udc->dev, \"%s\",\n\t\t\tkobject_name(&gadget->dev.parent->kobj));\n\tif (ret)\n\t\tgoto err_put_udc;\n\n\tudc->gadget = gadget;\n\tgadget->udc = udc;\n\tmutex_init(&udc->connect_lock);\n\n\tudc->started = false;\n\n\tmutex_lock(&udc_lock);\n\tlist_add_tail(&udc->list, &udc_list);\n\tmutex_unlock(&udc_lock);\n\tINIT_WORK(&udc->vbus_work, vbus_event_work);\n\n\tret = device_add(&udc->dev);\n\tif (ret)\n\t\tgoto err_unlist_udc;\n\n\tusb_gadget_set_state(gadget, USB_STATE_NOTATTACHED);\n\tudc->vbus = true;\n\n\tret = ida_alloc(&gadget_id_numbers, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto err_del_udc;\n\tgadget->id_number = ret;\n\tdev_set_name(&gadget->dev, \"gadget.%d\", ret);\n\n\tret = device_add(&gadget->dev);\n\tif (ret)\n\t\tgoto err_free_id;\n\n\treturn 0;\n\n err_free_id:\n\tida_free(&gadget_id_numbers, gadget->id_number);\n\n err_del_udc:\n\tflush_work(&gadget->work);\n\tdevice_del(&udc->dev);\n\n err_unlist_udc:\n\tmutex_lock(&udc_lock);\n\tlist_del(&udc->list);\n\tmutex_unlock(&udc_lock);\n\n err_put_udc:\n\tput_device(&udc->dev);\n\n error:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_add_gadget);\n\n \nint usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,\n\t\tvoid (*release)(struct device *dev))\n{\n\tint\tret;\n\n\tusb_initialize_gadget(parent, gadget, release);\n\tret = usb_add_gadget(gadget);\n\tif (ret)\n\t\tusb_put_gadget(gadget);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_add_gadget_udc_release);\n\n \nchar *usb_get_gadget_udc_name(void)\n{\n\tstruct usb_udc *udc;\n\tchar *name = NULL;\n\n\t \n\tmutex_lock(&udc_lock);\n\tlist_for_each_entry(udc, &udc_list, list) {\n\t\tif (!udc->driver) {\n\t\t\tname = kstrdup(udc->gadget->name, GFP_KERNEL);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&udc_lock);\n\treturn name;\n}\nEXPORT_SYMBOL_GPL(usb_get_gadget_udc_name);\n\n \nint usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget)\n{\n\treturn usb_add_gadget_udc_release(parent, gadget, NULL);\n}\nEXPORT_SYMBOL_GPL(usb_add_gadget_udc);\n\n \nvoid usb_del_gadget(struct usb_gadget *gadget)\n{\n\tstruct usb_udc *udc = gadget->udc;\n\n\tif (!udc)\n\t\treturn;\n\n\tdev_vdbg(gadget->dev.parent, \"unregistering gadget\\n\");\n\n\tmutex_lock(&udc_lock);\n\tlist_del(&udc->list);\n\tmutex_unlock(&udc_lock);\n\n\tkobject_uevent(&udc->dev.kobj, KOBJ_REMOVE);\n\tflush_work(&gadget->work);\n\tdevice_del(&gadget->dev);\n\tida_free(&gadget_id_numbers, gadget->id_number);\n\tcancel_work_sync(&udc->vbus_work);\n\tdevice_unregister(&udc->dev);\n}\nEXPORT_SYMBOL_GPL(usb_del_gadget);\n\n \nvoid usb_del_gadget_udc(struct usb_gadget *gadget)\n{\n\tusb_del_gadget(gadget);\n\tusb_put_gadget(gadget);\n}\nEXPORT_SYMBOL_GPL(usb_del_gadget_udc);\n\n \n\nstatic int gadget_match_driver(struct device *dev, struct device_driver *drv)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_udc *udc = gadget->udc;\n\tstruct usb_gadget_driver *driver = container_of(drv,\n\t\t\tstruct usb_gadget_driver, driver);\n\n\t \n\tif (driver->udc_name &&\n\t\t\tstrcmp(driver->udc_name, dev_name(&udc->dev)) != 0)\n\t\treturn 0;\n\n\t \n\tif (driver->is_bound)\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nstatic int gadget_bind_driver(struct device *dev)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_udc *udc = gadget->udc;\n\tstruct usb_gadget_driver *driver = container_of(dev->driver,\n\t\t\tstruct usb_gadget_driver, driver);\n\tint ret = 0;\n\n\tmutex_lock(&udc_lock);\n\tif (driver->is_bound) {\n\t\tmutex_unlock(&udc_lock);\n\t\treturn -ENXIO;\t\t \n\t}\n\tdriver->is_bound = true;\n\tudc->driver = driver;\n\tmutex_unlock(&udc_lock);\n\n\tdev_dbg(&udc->dev, \"binding gadget driver [%s]\\n\", driver->function);\n\n\tusb_gadget_udc_set_speed(udc, driver->max_speed);\n\n\tret = driver->bind(udc->gadget, driver);\n\tif (ret)\n\t\tgoto err_bind;\n\n\tmutex_lock(&udc->connect_lock);\n\tret = usb_gadget_udc_start_locked(udc);\n\tif (ret) {\n\t\tmutex_unlock(&udc->connect_lock);\n\t\tgoto err_start;\n\t}\n\tusb_gadget_enable_async_callbacks(udc);\n\tudc->allow_connect = true;\n\tusb_udc_connect_control_locked(udc);\n\tmutex_unlock(&udc->connect_lock);\n\n\tkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\n\treturn 0;\n\n err_start:\n\tdriver->unbind(udc->gadget);\n\n err_bind:\n\tif (ret != -EISNAM)\n\t\tdev_err(&udc->dev, \"failed to start %s: %d\\n\",\n\t\t\tdriver->function, ret);\n\n\tmutex_lock(&udc_lock);\n\tudc->driver = NULL;\n\tdriver->is_bound = false;\n\tmutex_unlock(&udc_lock);\n\n\treturn ret;\n}\n\nstatic void gadget_unbind_driver(struct device *dev)\n{\n\tstruct usb_gadget *gadget = dev_to_usb_gadget(dev);\n\tstruct usb_udc *udc = gadget->udc;\n\tstruct usb_gadget_driver *driver = udc->driver;\n\n\tdev_dbg(&udc->dev, \"unbinding gadget driver [%s]\\n\", driver->function);\n\n\tudc->allow_connect = false;\n\tcancel_work_sync(&udc->vbus_work);\n\tmutex_lock(&udc->connect_lock);\n\tusb_gadget_disconnect_locked(gadget);\n\tusb_gadget_disable_async_callbacks(udc);\n\tif (gadget->irq)\n\t\tsynchronize_irq(gadget->irq);\n\tmutex_unlock(&udc->connect_lock);\n\n\tudc->driver->unbind(gadget);\n\n\tmutex_lock(&udc->connect_lock);\n\tusb_gadget_udc_stop_locked(udc);\n\tmutex_unlock(&udc->connect_lock);\n\n\tmutex_lock(&udc_lock);\n\tdriver->is_bound = false;\n\tudc->driver = NULL;\n\tmutex_unlock(&udc_lock);\n\n\tkobject_uevent(&udc->dev.kobj, KOBJ_CHANGE);\n}\n\n \n\nint usb_gadget_register_driver_owner(struct usb_gadget_driver *driver,\n\t\tstruct module *owner, const char *mod_name)\n{\n\tint ret;\n\n\tif (!driver || !driver->bind || !driver->setup)\n\t\treturn -EINVAL;\n\n\tdriver->driver.bus = &gadget_bus_type;\n\tdriver->driver.owner = owner;\n\tdriver->driver.mod_name = mod_name;\n\tret = driver_register(&driver->driver);\n\tif (ret) {\n\t\tpr_warn(\"%s: driver registration failed: %d\\n\",\n\t\t\t\tdriver->function, ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&udc_lock);\n\tif (!driver->is_bound) {\n\t\tif (driver->match_existing_only) {\n\t\t\tpr_warn(\"%s: couldn't find an available UDC or it's busy\\n\",\n\t\t\t\t\tdriver->function);\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\tpr_info(\"%s: couldn't find an available UDC\\n\",\n\t\t\t\t\tdriver->function);\n\t\t\tret = 0;\n\t\t}\n\t}\n\tmutex_unlock(&udc_lock);\n\n\tif (ret)\n\t\tdriver_unregister(&driver->driver);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_register_driver_owner);\n\nint usb_gadget_unregister_driver(struct usb_gadget_driver *driver)\n{\n\tif (!driver || !driver->unbind)\n\t\treturn -EINVAL;\n\n\tdriver_unregister(&driver->driver);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_gadget_unregister_driver);\n\n \n\nstatic ssize_t srp_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct usb_udc\t\t*udc = container_of(dev, struct usb_udc, dev);\n\n\tif (sysfs_streq(buf, \"1\"))\n\t\tusb_gadget_wakeup(udc->gadget);\n\n\treturn n;\n}\nstatic DEVICE_ATTR_WO(srp);\n\nstatic ssize_t soft_connect_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct usb_udc\t\t*udc = container_of(dev, struct usb_udc, dev);\n\tssize_t\t\t\tret;\n\n\tdevice_lock(&udc->gadget->dev);\n\tif (!udc->driver) {\n\t\tdev_err(dev, \"soft-connect without a gadget driver\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (sysfs_streq(buf, \"connect\")) {\n\t\tmutex_lock(&udc->connect_lock);\n\t\tusb_gadget_udc_start_locked(udc);\n\t\tusb_gadget_connect_locked(udc->gadget);\n\t\tmutex_unlock(&udc->connect_lock);\n\t} else if (sysfs_streq(buf, \"disconnect\")) {\n\t\tmutex_lock(&udc->connect_lock);\n\t\tusb_gadget_disconnect_locked(udc->gadget);\n\t\tusb_gadget_udc_stop_locked(udc);\n\t\tmutex_unlock(&udc->connect_lock);\n\t} else {\n\t\tdev_err(dev, \"unsupported command '%s'\\n\", buf);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = n;\nout:\n\tdevice_unlock(&udc->gadget->dev);\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(soft_connect);\n\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct usb_udc\t\t*udc = container_of(dev, struct usb_udc, dev);\n\tstruct usb_gadget\t*gadget = udc->gadget;\n\n\treturn sprintf(buf, \"%s\\n\", usb_state_string(gadget->state));\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic ssize_t function_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct usb_udc\t\t*udc = container_of(dev, struct usb_udc, dev);\n\tstruct usb_gadget_driver *drv;\n\tint\t\t\trc = 0;\n\n\tmutex_lock(&udc_lock);\n\tdrv = udc->driver;\n\tif (drv && drv->function)\n\t\trc = scnprintf(buf, PAGE_SIZE, \"%s\\n\", drv->function);\n\tmutex_unlock(&udc_lock);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(function);\n\n#define USB_UDC_SPEED_ATTR(name, param)\t\t\t\t\t\\\nssize_t name##_show(struct device *dev,\t\t\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_udc *udc = container_of(dev, struct usb_udc, dev);\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\",\t\t\t\\\n\t\t\tusb_speed_string(udc->gadget->param));\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\nstatic USB_UDC_SPEED_ATTR(current_speed, speed);\nstatic USB_UDC_SPEED_ATTR(maximum_speed, max_speed);\n\n#define USB_UDC_ATTR(name)\t\t\t\t\t\\\nssize_t name##_show(struct device *dev,\t\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct usb_udc\t\t*udc = container_of(dev, struct usb_udc, dev); \\\n\tstruct usb_gadget\t*gadget = udc->gadget;\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn scnprintf(buf, PAGE_SIZE, \"%d\\n\", gadget->name);\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\nstatic USB_UDC_ATTR(is_otg);\nstatic USB_UDC_ATTR(is_a_peripheral);\nstatic USB_UDC_ATTR(b_hnp_enable);\nstatic USB_UDC_ATTR(a_hnp_support);\nstatic USB_UDC_ATTR(a_alt_hnp_support);\nstatic USB_UDC_ATTR(is_selfpowered);\n\nstatic struct attribute *usb_udc_attrs[] = {\n\t&dev_attr_srp.attr,\n\t&dev_attr_soft_connect.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_function.attr,\n\t&dev_attr_current_speed.attr,\n\t&dev_attr_maximum_speed.attr,\n\n\t&dev_attr_is_otg.attr,\n\t&dev_attr_is_a_peripheral.attr,\n\t&dev_attr_b_hnp_enable.attr,\n\t&dev_attr_a_hnp_support.attr,\n\t&dev_attr_a_alt_hnp_support.attr,\n\t&dev_attr_is_selfpowered.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group usb_udc_attr_group = {\n\t.attrs = usb_udc_attrs,\n};\n\nstatic const struct attribute_group *usb_udc_attr_groups[] = {\n\t&usb_udc_attr_group,\n\tNULL,\n};\n\nstatic int usb_udc_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct usb_udc\t*udc = container_of(dev, struct usb_udc, dev);\n\tint\t\t\tret;\n\n\tret = add_uevent_var(env, \"USB_UDC_NAME=%s\", udc->gadget->name);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add uevent USB_UDC_NAME\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&udc_lock);\n\tif (udc->driver)\n\t\tret = add_uevent_var(env, \"USB_UDC_DRIVER=%s\",\n\t\t\t\tudc->driver->function);\n\tmutex_unlock(&udc_lock);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add uevent USB_UDC_DRIVER\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct class udc_class = {\n\t.name\t\t= \"udc\",\n\t.dev_uevent\t= usb_udc_uevent,\n};\n\nstatic const struct bus_type gadget_bus_type = {\n\t.name = \"gadget\",\n\t.probe = gadget_bind_driver,\n\t.remove = gadget_unbind_driver,\n\t.match = gadget_match_driver,\n};\n\nstatic int __init usb_udc_init(void)\n{\n\tint rc;\n\n\trc = class_register(&udc_class);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bus_register(&gadget_bus_type);\n\tif (rc)\n\t\tclass_unregister(&udc_class);\n\treturn rc;\n}\nsubsys_initcall(usb_udc_init);\n\nstatic void __exit usb_udc_exit(void)\n{\n\tbus_unregister(&gadget_bus_type);\n\tclass_unregister(&udc_class);\n}\nmodule_exit(usb_udc_exit);\n\nMODULE_DESCRIPTION(\"UDC Framework\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}