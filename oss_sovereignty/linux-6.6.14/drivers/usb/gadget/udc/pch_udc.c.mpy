{
  "module_name": "pch_udc.c",
  "hash_id": "d156435595216dfc52e89805ae335f53776afc545d00e19cdb43232b831adab4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/pch_udc.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/irq.h>\n\n#define PCH_VBUS_PERIOD\t\t3000\t \n#define PCH_VBUS_INTERVAL\t10\t \n\n \n#define UDC_EP_REG_SHIFT\t0x20\t \n\n#define UDC_EPCTL_ADDR\t\t0x00\t \n#define UDC_EPSTS_ADDR\t\t0x04\t \n#define UDC_BUFIN_FRAMENUM_ADDR\t0x08\t \n#define UDC_BUFOUT_MAXPKT_ADDR\t0x0C\t \n#define UDC_SUBPTR_ADDR\t\t0x10\t \n#define UDC_DESPTR_ADDR\t\t0x14\t \n#define UDC_CONFIRM_ADDR\t0x18\t \n\n#define UDC_DEVCFG_ADDR\t\t0x400\t \n#define UDC_DEVCTL_ADDR\t\t0x404\t \n#define UDC_DEVSTS_ADDR\t\t0x408\t \n#define UDC_DEVIRQSTS_ADDR\t0x40C\t \n#define UDC_DEVIRQMSK_ADDR\t0x410\t \n#define UDC_EPIRQSTS_ADDR\t0x414\t \n#define UDC_EPIRQMSK_ADDR\t0x418\t \n#define UDC_DEVLPM_ADDR\t\t0x41C\t \n#define UDC_CSR_BUSY_ADDR\t0x4f0\t \n#define UDC_SRST_ADDR\t\t0x4fc\t \n#define UDC_CSR_ADDR\t\t0x500\t \n\n \n \n#define UDC_EPCTL_MRXFLUSH\t\t(1 << 12)\n#define UDC_EPCTL_RRDY\t\t\t(1 << 9)\n#define UDC_EPCTL_CNAK\t\t\t(1 << 8)\n#define UDC_EPCTL_SNAK\t\t\t(1 << 7)\n#define UDC_EPCTL_NAK\t\t\t(1 << 6)\n#define UDC_EPCTL_P\t\t\t(1 << 3)\n#define UDC_EPCTL_F\t\t\t(1 << 1)\n#define UDC_EPCTL_S\t\t\t(1 << 0)\n#define UDC_EPCTL_ET_SHIFT\t\t4\n \n#define UDC_EPCTL_ET_MASK\t\t0x00000030\n \n#define UDC_EPCTL_ET_CONTROL\t\t0\n#define UDC_EPCTL_ET_ISO\t\t1\n#define UDC_EPCTL_ET_BULK\t\t2\n#define UDC_EPCTL_ET_INTERRUPT\t\t3\n\n \n \n#define UDC_EPSTS_XFERDONE\t\t(1 << 27)\n#define UDC_EPSTS_RSS\t\t\t(1 << 26)\n#define UDC_EPSTS_RCS\t\t\t(1 << 25)\n#define UDC_EPSTS_TXEMPTY\t\t(1 << 24)\n#define UDC_EPSTS_TDC\t\t\t(1 << 10)\n#define UDC_EPSTS_HE\t\t\t(1 << 9)\n#define UDC_EPSTS_MRXFIFO_EMP\t\t(1 << 8)\n#define UDC_EPSTS_BNA\t\t\t(1 << 7)\n#define UDC_EPSTS_IN\t\t\t(1 << 6)\n#define UDC_EPSTS_OUT_SHIFT\t\t4\n \n#define UDC_EPSTS_OUT_MASK\t\t0x00000030\n#define UDC_EPSTS_ALL_CLR_MASK\t\t0x1F0006F0\n \n#define UDC_EPSTS_OUT_SETUP\t\t2\n#define UDC_EPSTS_OUT_DATA\t\t1\n\n \n \n#define UDC_DEVCFG_CSR_PRG\t\t(1 << 17)\n#define UDC_DEVCFG_SP\t\t\t(1 << 3)\n \n#define UDC_DEVCFG_SPD_HS\t\t0x0\n#define UDC_DEVCFG_SPD_FS\t\t0x1\n#define UDC_DEVCFG_SPD_LS\t\t0x2\n\n \n \n#define UDC_DEVCTL_THLEN_SHIFT\t\t24\n#define UDC_DEVCTL_BRLEN_SHIFT\t\t16\n#define UDC_DEVCTL_CSR_DONE\t\t(1 << 13)\n#define UDC_DEVCTL_SD\t\t\t(1 << 10)\n#define UDC_DEVCTL_MODE\t\t\t(1 << 9)\n#define UDC_DEVCTL_BREN\t\t\t(1 << 8)\n#define UDC_DEVCTL_THE\t\t\t(1 << 7)\n#define UDC_DEVCTL_DU\t\t\t(1 << 4)\n#define UDC_DEVCTL_TDE\t\t\t(1 << 3)\n#define UDC_DEVCTL_RDE\t\t\t(1 << 2)\n#define UDC_DEVCTL_RES\t\t\t(1 << 0)\n\n \n \n#define UDC_DEVSTS_TS_SHIFT\t\t18\n#define UDC_DEVSTS_ENUM_SPEED_SHIFT\t13\n#define UDC_DEVSTS_ALT_SHIFT\t\t8\n#define UDC_DEVSTS_INTF_SHIFT\t\t4\n#define UDC_DEVSTS_CFG_SHIFT\t\t0\n \n#define UDC_DEVSTS_TS_MASK\t\t0xfffc0000\n#define UDC_DEVSTS_ENUM_SPEED_MASK\t0x00006000\n#define UDC_DEVSTS_ALT_MASK\t\t0x00000f00\n#define UDC_DEVSTS_INTF_MASK\t\t0x000000f0\n#define UDC_DEVSTS_CFG_MASK\t\t0x0000000f\n \n#define UDC_DEVSTS_ENUM_SPEED_FULL\t1\n#define UDC_DEVSTS_ENUM_SPEED_HIGH\t0\n#define UDC_DEVSTS_ENUM_SPEED_LOW\t2\n#define UDC_DEVSTS_ENUM_SPEED_FULLX\t3\n\n \n \n#define UDC_DEVINT_RWKP\t\t\t(1 << 7)\n#define UDC_DEVINT_ENUM\t\t\t(1 << 6)\n#define UDC_DEVINT_SOF\t\t\t(1 << 5)\n#define UDC_DEVINT_US\t\t\t(1 << 4)\n#define UDC_DEVINT_UR\t\t\t(1 << 3)\n#define UDC_DEVINT_ES\t\t\t(1 << 2)\n#define UDC_DEVINT_SI\t\t\t(1 << 1)\n#define UDC_DEVINT_SC\t\t\t(1 << 0)\n \n#define UDC_DEVINT_MSK\t\t\t0x7f\n\n \n \n#define UDC_EPINT_IN_SHIFT\t\t0\n#define UDC_EPINT_OUT_SHIFT\t\t16\n#define UDC_EPINT_IN_EP0\t\t(1 << 0)\n#define UDC_EPINT_OUT_EP0\t\t(1 << 16)\n \n#define UDC_EPINT_MSK_DISABLE_ALL\t0xffffffff\n\n \n \n#define UDC_CSR_BUSY\t\t\t(1 << 0)\n\n \n \n#define UDC_PSRST\t\t\t(1 << 1)\n#define UDC_SRST\t\t\t(1 << 0)\n\n \n \n#define UDC_CSR_NE_NUM_SHIFT\t\t0\n#define UDC_CSR_NE_DIR_SHIFT\t\t4\n#define UDC_CSR_NE_TYPE_SHIFT\t\t5\n#define UDC_CSR_NE_CFG_SHIFT\t\t7\n#define UDC_CSR_NE_INTF_SHIFT\t\t11\n#define UDC_CSR_NE_ALT_SHIFT\t\t15\n#define UDC_CSR_NE_MAX_PKT_SHIFT\t19\n \n#define UDC_CSR_NE_NUM_MASK\t\t0x0000000f\n#define UDC_CSR_NE_DIR_MASK\t\t0x00000010\n#define UDC_CSR_NE_TYPE_MASK\t\t0x00000060\n#define UDC_CSR_NE_CFG_MASK\t\t0x00000780\n#define UDC_CSR_NE_INTF_MASK\t\t0x00007800\n#define UDC_CSR_NE_ALT_MASK\t\t0x00078000\n#define UDC_CSR_NE_MAX_PKT_MASK\t\t0x3ff80000\n\n#define PCH_UDC_CSR(ep)\t(UDC_CSR_ADDR + ep*4)\n#define PCH_UDC_EPINT(in, num)\\\n\t\t(1 << (num + (in ? UDC_EPINT_IN_SHIFT : UDC_EPINT_OUT_SHIFT)))\n\n \n#define UDC_EP0IN_IDX\t\t0\n#define UDC_EP0OUT_IDX\t\t1\n#define UDC_EPIN_IDX(ep)\t(ep * 2)\n#define UDC_EPOUT_IDX(ep)\t(ep * 2 + 1)\n#define PCH_UDC_EP0\t\t0\n#define PCH_UDC_EP1\t\t1\n#define PCH_UDC_EP2\t\t2\n#define PCH_UDC_EP3\t\t3\n\n \n#define PCH_UDC_EP_NUM\t\t32\t \n#define PCH_UDC_USED_EP_NUM\t4\t \n \n#define PCH_UDC_BRLEN\t\t0x0F\t \n#define PCH_UDC_THLEN\t\t0x1F\t \n \n#define UDC_EP0IN_BUFF_SIZE\t16\n#define UDC_EPIN_BUFF_SIZE\t256\n#define UDC_EP0OUT_BUFF_SIZE\t16\n#define UDC_EPOUT_BUFF_SIZE\t256\n \n#define UDC_EP0IN_MAX_PKT_SIZE\t64\n#define UDC_EP0OUT_MAX_PKT_SIZE\t64\n#define UDC_BULK_MAX_PKT_SIZE\t512\n\n \n#define DMA_DIR_RX\t\t1\t \n#define DMA_DIR_TX\t\t2\t \n#define DMA_ADDR_INVALID\t(~(dma_addr_t)0)\n#define UDC_DMA_MAXPACKET\t65536\t \n\n \nstruct pch_udc_data_dma_desc {\n\tu32 status;\n\tu32 reserved;\n\tu32 dataptr;\n\tu32 next;\n};\n\n \nstruct pch_udc_stp_dma_desc {\n\tu32 status;\n\tu32 reserved;\n\tstruct usb_ctrlrequest request;\n} __attribute((packed));\n\n \n \n#define PCH_UDC_BUFF_STS\t0xC0000000\n#define PCH_UDC_BS_HST_RDY\t0x00000000\n#define PCH_UDC_BS_DMA_BSY\t0x40000000\n#define PCH_UDC_BS_DMA_DONE\t0x80000000\n#define PCH_UDC_BS_HST_BSY\t0xC0000000\n \n#define PCH_UDC_RXTX_STS\t0x30000000\n#define PCH_UDC_RTS_SUCC\t0x00000000\n#define PCH_UDC_RTS_DESERR\t0x10000000\n#define PCH_UDC_RTS_BUFERR\t0x30000000\n \n#define PCH_UDC_DMA_LAST\t0x08000000\n \n#define PCH_UDC_RXTX_BYTES\t0x0000ffff\n\n \nstruct pch_udc_cfg_data {\n\tu16 cur_cfg;\n\tu16 cur_intf;\n\tu16 cur_alt;\n};\n\n \nstruct pch_udc_ep {\n\tstruct usb_ep\t\t\tep;\n\tdma_addr_t\t\t\ttd_stp_phys;\n\tdma_addr_t\t\t\ttd_data_phys;\n\tstruct pch_udc_stp_dma_desc\t*td_stp;\n\tstruct pch_udc_data_dma_desc\t*td_data;\n\tstruct pch_udc_dev\t\t*dev;\n\tunsigned long\t\t\toffset_addr;\n\tstruct list_head\t\tqueue;\n\tunsigned\t\t\tnum:5,\n\t\t\t\t\tin:1,\n\t\t\t\t\thalted:1;\n\tunsigned long\t\t\tepsts;\n};\n\n \nstruct pch_vbus_gpio_data {\n\tstruct gpio_desc\t*port;\n\tint\t\t\tintr;\n\tstruct work_struct\tirq_work_fall;\n\tstruct work_struct\tirq_work_rise;\n};\n\n \nstruct pch_udc_dev {\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\tstruct pci_dev\t\t\t*pdev;\n\tstruct pch_udc_ep\t\tep[PCH_UDC_EP_NUM];\n\tspinlock_t\t\t\tlock;  \n\tunsigned\n\t\t\tstall:1,\n\t\t\tprot_stall:1,\n\t\t\tsuspended:1,\n\t\t\tconnected:1,\n\t\t\tvbus_session:1,\n\t\t\tset_cfg_not_acked:1,\n\t\t\twaiting_zlp_ack:1;\n\tstruct dma_pool\t\t*data_requests;\n\tstruct dma_pool\t\t*stp_requests;\n\tdma_addr_t\t\t\tdma_addr;\n\tstruct usb_ctrlrequest\t\tsetup_data;\n\tvoid __iomem\t\t\t*base_addr;\n\tunsigned short\t\t\tbar;\n\tstruct pch_udc_cfg_data\t\tcfg_data;\n\tstruct pch_vbus_gpio_data\tvbus_gpio;\n};\n#define to_pch_udc(g)\t(container_of((g), struct pch_udc_dev, gadget))\n\n#define PCH_UDC_PCI_BAR_QUARK_X1000\t0\n#define PCH_UDC_PCI_BAR\t\t\t1\n\n#define PCI_DEVICE_ID_INTEL_QUARK_X1000_UDC\t0x0939\n#define PCI_DEVICE_ID_INTEL_EG20T_UDC\t\t0x8808\n\n#define PCI_DEVICE_ID_ML7213_IOH_UDC\t0x801D\n#define PCI_DEVICE_ID_ML7831_IOH_UDC\t0x8808\n\nstatic const char\tep0_string[] = \"ep0in\";\nstatic DEFINE_SPINLOCK(udc_stall_spinlock);\t \nstatic bool speed_fs;\nmodule_param_named(speed_fs, speed_fs, bool, S_IRUGO);\nMODULE_PARM_DESC(speed_fs, \"true for Full speed operation\");\n\n \nstruct pch_udc_request {\n\tstruct usb_request\t\treq;\n\tdma_addr_t\t\t\ttd_data_phys;\n\tstruct pch_udc_data_dma_desc\t*td_data;\n\tstruct pch_udc_data_dma_desc\t*td_data_last;\n\tstruct list_head\t\tqueue;\n\tunsigned\t\t\tdma_going:1,\n\t\t\t\t\tdma_done:1;\n\tunsigned\t\t\tchain_len;\n};\n\nstatic inline u32 pch_udc_readl(struct pch_udc_dev *dev, unsigned long reg)\n{\n\treturn ioread32(dev->base_addr + reg);\n}\n\nstatic inline void pch_udc_writel(struct pch_udc_dev *dev,\n\t\t\t\t    unsigned long val, unsigned long reg)\n{\n\tiowrite32(val, dev->base_addr + reg);\n}\n\nstatic inline void pch_udc_bit_set(struct pch_udc_dev *dev,\n\t\t\t\t     unsigned long reg,\n\t\t\t\t     unsigned long bitmask)\n{\n\tpch_udc_writel(dev, pch_udc_readl(dev, reg) | bitmask, reg);\n}\n\nstatic inline void pch_udc_bit_clr(struct pch_udc_dev *dev,\n\t\t\t\t     unsigned long reg,\n\t\t\t\t     unsigned long bitmask)\n{\n\tpch_udc_writel(dev, pch_udc_readl(dev, reg) & ~(bitmask), reg);\n}\n\nstatic inline u32 pch_udc_ep_readl(struct pch_udc_ep *ep, unsigned long reg)\n{\n\treturn ioread32(ep->dev->base_addr + ep->offset_addr + reg);\n}\n\nstatic inline void pch_udc_ep_writel(struct pch_udc_ep *ep,\n\t\t\t\t    unsigned long val, unsigned long reg)\n{\n\tiowrite32(val, ep->dev->base_addr + ep->offset_addr + reg);\n}\n\nstatic inline void pch_udc_ep_bit_set(struct pch_udc_ep *ep,\n\t\t\t\t     unsigned long reg,\n\t\t\t\t     unsigned long bitmask)\n{\n\tpch_udc_ep_writel(ep, pch_udc_ep_readl(ep, reg) | bitmask, reg);\n}\n\nstatic inline void pch_udc_ep_bit_clr(struct pch_udc_ep *ep,\n\t\t\t\t     unsigned long reg,\n\t\t\t\t     unsigned long bitmask)\n{\n\tpch_udc_ep_writel(ep, pch_udc_ep_readl(ep, reg) & ~(bitmask), reg);\n}\n\n \nstatic void pch_udc_csr_busy(struct pch_udc_dev *dev)\n{\n\tunsigned int count = 200;\n\n\t \n\twhile ((pch_udc_readl(dev, UDC_CSR_BUSY_ADDR) & UDC_CSR_BUSY)\n\t\t&& --count)\n\t\tcpu_relax();\n\tif (!count)\n\t\tdev_err(&dev->pdev->dev, \"%s: wait error\\n\", __func__);\n}\n\n \nstatic void pch_udc_write_csr(struct pch_udc_dev *dev, unsigned long val,\n\t\t\t       unsigned int ep)\n{\n\tunsigned long reg = PCH_UDC_CSR(ep);\n\n\tpch_udc_csr_busy(dev);\t\t \n\tpch_udc_writel(dev, val, reg);\n\tpch_udc_csr_busy(dev);\t\t \n}\n\n \nstatic u32 pch_udc_read_csr(struct pch_udc_dev *dev, unsigned int ep)\n{\n\tunsigned long reg = PCH_UDC_CSR(ep);\n\n\tpch_udc_csr_busy(dev);\t\t \n\tpch_udc_readl(dev, reg);\t \n\tpch_udc_csr_busy(dev);\t\t \n\treturn pch_udc_readl(dev, reg);\n}\n\n \nstatic inline void pch_udc_rmt_wakeup(struct pch_udc_dev *dev)\n{\n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n\tmdelay(1);\n\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n}\n\n \nstatic inline int pch_udc_get_frame(struct pch_udc_dev *dev)\n{\n\tu32 frame = pch_udc_readl(dev, UDC_DEVSTS_ADDR);\n\treturn (frame & UDC_DEVSTS_TS_MASK) >> UDC_DEVSTS_TS_SHIFT;\n}\n\n \nstatic inline void pch_udc_clear_selfpowered(struct pch_udc_dev *dev)\n{\n\tpch_udc_bit_clr(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_SP);\n}\n\n \nstatic inline void pch_udc_set_selfpowered(struct pch_udc_dev *dev)\n{\n\tpch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_SP);\n}\n\n \nstatic inline void pch_udc_set_disconnect(struct pch_udc_dev *dev)\n{\n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\n}\n\n \nstatic void pch_udc_clear_disconnect(struct pch_udc_dev *dev)\n{\n\t \n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\n\tmdelay(1);\n\t \n\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n}\n\nstatic void pch_udc_init(struct pch_udc_dev *dev);\n\n \nstatic void pch_udc_reconnect(struct pch_udc_dev *dev)\n{\n\tpch_udc_init(dev);\n\n\t \n\t \n\tpch_udc_bit_clr(dev, UDC_DEVIRQMSK_ADDR,\n\t\t\tUDC_DEVINT_UR | UDC_DEVINT_ENUM);\n\n\t \n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_SD);\n\tmdelay(1);\n\t \n\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RES);\n}\n\n \nstatic inline void pch_udc_vbus_session(struct pch_udc_dev *dev,\n\t\t\t\t\t  int is_active)\n{\n\tunsigned long\t\tiflags;\n\n\tspin_lock_irqsave(&dev->lock, iflags);\n\tif (is_active) {\n\t\tpch_udc_reconnect(dev);\n\t\tdev->vbus_session = 1;\n\t} else {\n\t\tif (dev->driver && dev->driver->disconnect) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, iflags);\n\t\t\tdev->driver->disconnect(&dev->gadget);\n\t\t\tspin_lock_irqsave(&dev->lock, iflags);\n\t\t}\n\t\tpch_udc_set_disconnect(dev);\n\t\tdev->vbus_session = 0;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n}\n\n \nstatic void pch_udc_ep_set_stall(struct pch_udc_ep *ep)\n{\n\tif (ep->in) {\n\t\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_F);\n\t\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\n\t} else {\n\t\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\n\t}\n}\n\n \nstatic inline void pch_udc_ep_clear_stall(struct pch_udc_ep *ep)\n{\n\t \n\tpch_udc_ep_bit_clr(ep, UDC_EPCTL_ADDR, UDC_EPCTL_S);\n\t \n\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);\n}\n\n \nstatic inline void pch_udc_ep_set_trfr_type(struct pch_udc_ep *ep,\n\t\t\t\t\tu8 type)\n{\n\tpch_udc_ep_writel(ep, ((type << UDC_EPCTL_ET_SHIFT) &\n\t\t\t\tUDC_EPCTL_ET_MASK), UDC_EPCTL_ADDR);\n}\n\n \nstatic void pch_udc_ep_set_bufsz(struct pch_udc_ep *ep,\n\t\t\t\t\t\t u32 buf_size, u32 ep_in)\n{\n\tu32 data;\n\tif (ep_in) {\n\t\tdata = pch_udc_ep_readl(ep, UDC_BUFIN_FRAMENUM_ADDR);\n\t\tdata = (data & 0xffff0000) | (buf_size & 0xffff);\n\t\tpch_udc_ep_writel(ep, data, UDC_BUFIN_FRAMENUM_ADDR);\n\t} else {\n\t\tdata = pch_udc_ep_readl(ep, UDC_BUFOUT_MAXPKT_ADDR);\n\t\tdata = (buf_size << 16) | (data & 0xffff);\n\t\tpch_udc_ep_writel(ep, data, UDC_BUFOUT_MAXPKT_ADDR);\n\t}\n}\n\n \nstatic void pch_udc_ep_set_maxpkt(struct pch_udc_ep *ep, u32 pkt_size)\n{\n\tu32 data = pch_udc_ep_readl(ep, UDC_BUFOUT_MAXPKT_ADDR);\n\tdata = (data & 0xffff0000) | (pkt_size & 0xffff);\n\tpch_udc_ep_writel(ep, data, UDC_BUFOUT_MAXPKT_ADDR);\n}\n\n \nstatic inline void pch_udc_ep_set_subptr(struct pch_udc_ep *ep, u32 addr)\n{\n\tpch_udc_ep_writel(ep, addr, UDC_SUBPTR_ADDR);\n}\n\n \nstatic inline void pch_udc_ep_set_ddptr(struct pch_udc_ep *ep, u32 addr)\n{\n\tpch_udc_ep_writel(ep, addr, UDC_DESPTR_ADDR);\n}\n\n \nstatic inline void pch_udc_ep_set_pd(struct pch_udc_ep *ep)\n{\n\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_P);\n}\n\n \nstatic inline void pch_udc_ep_set_rrdy(struct pch_udc_ep *ep)\n{\n\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_RRDY);\n}\n\n \nstatic inline void pch_udc_ep_clear_rrdy(struct pch_udc_ep *ep)\n{\n\tpch_udc_ep_bit_clr(ep, UDC_EPCTL_ADDR, UDC_EPCTL_RRDY);\n}\n\n \nstatic inline void pch_udc_set_dma(struct pch_udc_dev *dev, int dir)\n{\n\tif (dir == DMA_DIR_RX)\n\t\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RDE);\n\telse if (dir == DMA_DIR_TX)\n\t\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_TDE);\n}\n\n \nstatic inline void pch_udc_clear_dma(struct pch_udc_dev *dev, int dir)\n{\n\tif (dir == DMA_DIR_RX)\n\t\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_RDE);\n\telse if (dir == DMA_DIR_TX)\n\t\tpch_udc_bit_clr(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_TDE);\n}\n\n \nstatic inline void pch_udc_set_csr_done(struct pch_udc_dev *dev)\n{\n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR, UDC_DEVCTL_CSR_DONE);\n}\n\n \nstatic inline void pch_udc_disable_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t    u32 mask)\n{\n\tpch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, mask);\n}\n\n \nstatic inline void pch_udc_enable_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t   u32 mask)\n{\n\tpch_udc_bit_clr(dev, UDC_DEVIRQMSK_ADDR, mask);\n}\n\n \nstatic inline void pch_udc_disable_ep_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t\tu32 mask)\n{\n\tpch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, mask);\n}\n\n \nstatic inline void pch_udc_enable_ep_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t      u32 mask)\n{\n\tpch_udc_bit_clr(dev, UDC_EPIRQMSK_ADDR, mask);\n}\n\n \nstatic inline u32 pch_udc_read_device_interrupts(struct pch_udc_dev *dev)\n{\n\treturn pch_udc_readl(dev, UDC_DEVIRQSTS_ADDR);\n}\n\n \nstatic inline void pch_udc_write_device_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t\t     u32 val)\n{\n\tpch_udc_writel(dev, val, UDC_DEVIRQSTS_ADDR);\n}\n\n \nstatic inline u32 pch_udc_read_ep_interrupts(struct pch_udc_dev *dev)\n{\n\treturn pch_udc_readl(dev, UDC_EPIRQSTS_ADDR);\n}\n\n \nstatic inline void pch_udc_write_ep_interrupts(struct pch_udc_dev *dev,\n\t\t\t\t\t     u32 val)\n{\n\tpch_udc_writel(dev, val, UDC_EPIRQSTS_ADDR);\n}\n\n \nstatic inline u32 pch_udc_read_device_status(struct pch_udc_dev *dev)\n{\n\treturn pch_udc_readl(dev, UDC_DEVSTS_ADDR);\n}\n\n \nstatic inline u32 pch_udc_read_ep_control(struct pch_udc_ep *ep)\n{\n\treturn pch_udc_ep_readl(ep, UDC_EPCTL_ADDR);\n}\n\n \nstatic inline void pch_udc_clear_ep_control(struct pch_udc_ep *ep)\n{\n\treturn pch_udc_ep_writel(ep, 0, UDC_EPCTL_ADDR);\n}\n\n \nstatic inline u32 pch_udc_read_ep_status(struct pch_udc_ep *ep)\n{\n\treturn pch_udc_ep_readl(ep, UDC_EPSTS_ADDR);\n}\n\n \nstatic inline void pch_udc_clear_ep_status(struct pch_udc_ep *ep,\n\t\t\t\t\t u32 stat)\n{\n\treturn pch_udc_ep_writel(ep, stat, UDC_EPSTS_ADDR);\n}\n\n \nstatic inline void pch_udc_ep_set_nak(struct pch_udc_ep *ep)\n{\n\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_SNAK);\n}\n\n \nstatic void pch_udc_ep_clear_nak(struct pch_udc_ep *ep)\n{\n\tunsigned int loopcnt = 0;\n\tstruct pch_udc_dev *dev = ep->dev;\n\n\tif (!(pch_udc_ep_readl(ep, UDC_EPCTL_ADDR) & UDC_EPCTL_NAK))\n\t\treturn;\n\tif (!ep->in) {\n\t\tloopcnt = 10000;\n\t\twhile (!(pch_udc_read_ep_status(ep) & UDC_EPSTS_MRXFIFO_EMP) &&\n\t\t\t--loopcnt)\n\t\t\tudelay(5);\n\t\tif (!loopcnt)\n\t\t\tdev_err(&dev->pdev->dev, \"%s: RxFIFO not Empty\\n\",\n\t\t\t\t__func__);\n\t}\n\tloopcnt = 10000;\n\twhile ((pch_udc_read_ep_control(ep) & UDC_EPCTL_NAK) && --loopcnt) {\n\t\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_CNAK);\n\t\tudelay(5);\n\t}\n\tif (!loopcnt)\n\t\tdev_err(&dev->pdev->dev, \"%s: Clear NAK not set for ep%d%s\\n\",\n\t\t\t__func__, ep->num, (ep->in ? \"in\" : \"out\"));\n}\n\n \nstatic void pch_udc_ep_fifo_flush(struct pch_udc_ep *ep, int dir)\n{\n\tif (dir) {\t \n\t\tpch_udc_ep_bit_set(ep, UDC_EPCTL_ADDR, UDC_EPCTL_F);\n\t\treturn;\n\t}\n}\n\n \nstatic void pch_udc_ep_enable(struct pch_udc_ep *ep,\n\t\t\t       struct pch_udc_cfg_data *cfg,\n\t\t\t       const struct usb_endpoint_descriptor *desc)\n{\n\tu32 val = 0;\n\tu32 buff_size = 0;\n\n\tpch_udc_ep_set_trfr_type(ep, desc->bmAttributes);\n\tif (ep->in)\n\t\tbuff_size = UDC_EPIN_BUFF_SIZE;\n\telse\n\t\tbuff_size = UDC_EPOUT_BUFF_SIZE;\n\tpch_udc_ep_set_bufsz(ep, buff_size, ep->in);\n\tpch_udc_ep_set_maxpkt(ep, usb_endpoint_maxp(desc));\n\tpch_udc_ep_set_nak(ep);\n\tpch_udc_ep_fifo_flush(ep, ep->in);\n\t \n\tval = ep->num << UDC_CSR_NE_NUM_SHIFT | ep->in << UDC_CSR_NE_DIR_SHIFT |\n\t      ((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) <<\n\t\tUDC_CSR_NE_TYPE_SHIFT) |\n\t      (cfg->cur_cfg << UDC_CSR_NE_CFG_SHIFT) |\n\t      (cfg->cur_intf << UDC_CSR_NE_INTF_SHIFT) |\n\t      (cfg->cur_alt << UDC_CSR_NE_ALT_SHIFT) |\n\t      usb_endpoint_maxp(desc) << UDC_CSR_NE_MAX_PKT_SHIFT;\n\n\tif (ep->in)\n\t\tpch_udc_write_csr(ep->dev, val, UDC_EPIN_IDX(ep->num));\n\telse\n\t\tpch_udc_write_csr(ep->dev, val, UDC_EPOUT_IDX(ep->num));\n}\n\n \nstatic void pch_udc_ep_disable(struct pch_udc_ep *ep)\n{\n\tif (ep->in) {\n\t\t \n\t\tpch_udc_ep_writel(ep, UDC_EPCTL_F, UDC_EPCTL_ADDR);\n\t\t \n\t\tpch_udc_ep_writel(ep, UDC_EPCTL_SNAK, UDC_EPCTL_ADDR);\n\t\tpch_udc_ep_bit_set(ep, UDC_EPSTS_ADDR, UDC_EPSTS_IN);\n\t} else {\n\t\t \n\t\tpch_udc_ep_writel(ep, UDC_EPCTL_SNAK, UDC_EPCTL_ADDR);\n\t}\n\t \n\tpch_udc_ep_writel(ep, 0, UDC_DESPTR_ADDR);\n}\n\n \nstatic void pch_udc_wait_ep_stall(struct pch_udc_ep *ep)\n{\n\tunsigned int count = 10000;\n\n\t \n\twhile ((pch_udc_read_ep_control(ep) & UDC_EPCTL_S) && --count)\n\t\tudelay(5);\n\tif (!count)\n\t\tdev_err(&ep->dev->pdev->dev, \"%s: wait error\\n\", __func__);\n}\n\n \nstatic void pch_udc_init(struct pch_udc_dev *dev)\n{\n\tif (NULL == dev) {\n\t\tpr_err(\"%s: Invalid address\\n\", __func__);\n\t\treturn;\n\t}\n\t \n\tpch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\n\tpch_udc_writel(dev, UDC_SRST | UDC_PSRST, UDC_SRST_ADDR);\n\tmdelay(1);\n\tpch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\n\tpch_udc_writel(dev, 0x00, UDC_SRST_ADDR);\n\tmdelay(1);\n\t \n\tpch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, UDC_DEVINT_MSK);\n\tpch_udc_bit_set(dev, UDC_DEVIRQSTS_ADDR, UDC_DEVINT_MSK);\n\n\t \n\tpch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\n\tpch_udc_bit_set(dev, UDC_EPIRQSTS_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\n\n\t \n\tif (speed_fs)\n\t\tpch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_CSR_PRG |\n\t\t\t\tUDC_DEVCFG_SP | UDC_DEVCFG_SPD_FS);\n\telse  \n\t\tpch_udc_bit_set(dev, UDC_DEVCFG_ADDR, UDC_DEVCFG_CSR_PRG |\n\t\t\t\tUDC_DEVCFG_SP | UDC_DEVCFG_SPD_HS);\n\tpch_udc_bit_set(dev, UDC_DEVCTL_ADDR,\n\t\t\t(PCH_UDC_THLEN << UDC_DEVCTL_THLEN_SHIFT) |\n\t\t\t(PCH_UDC_BRLEN << UDC_DEVCTL_BRLEN_SHIFT) |\n\t\t\tUDC_DEVCTL_MODE | UDC_DEVCTL_BREN |\n\t\t\tUDC_DEVCTL_THE);\n}\n\n \nstatic void pch_udc_exit(struct pch_udc_dev *dev)\n{\n\t \n\tpch_udc_bit_set(dev, UDC_DEVIRQMSK_ADDR, UDC_DEVINT_MSK);\n\t \n\tpch_udc_bit_set(dev, UDC_EPIRQMSK_ADDR, UDC_EPINT_MSK_DISABLE_ALL);\n\t \n\tpch_udc_set_disconnect(dev);\n}\n\n \nstatic int pch_udc_pcd_get_frame(struct usb_gadget *gadget)\n{\n\tstruct pch_udc_dev\t*dev;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\tdev = container_of(gadget, struct pch_udc_dev, gadget);\n\treturn pch_udc_get_frame(dev);\n}\n\n \nstatic int pch_udc_pcd_wakeup(struct usb_gadget *gadget)\n{\n\tstruct pch_udc_dev\t*dev;\n\tunsigned long\t\tflags;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\tdev = container_of(gadget, struct pch_udc_dev, gadget);\n\tspin_lock_irqsave(&dev->lock, flags);\n\tpch_udc_rmt_wakeup(dev);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn 0;\n}\n\n \nstatic int pch_udc_pcd_selfpowered(struct usb_gadget *gadget, int value)\n{\n\tstruct pch_udc_dev\t*dev;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\tgadget->is_selfpowered = (value != 0);\n\tdev = container_of(gadget, struct pch_udc_dev, gadget);\n\tif (value)\n\t\tpch_udc_set_selfpowered(dev);\n\telse\n\t\tpch_udc_clear_selfpowered(dev);\n\treturn 0;\n}\n\n \nstatic int pch_udc_pcd_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct pch_udc_dev\t*dev;\n\tunsigned long\t\tiflags;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\n\tdev = container_of(gadget, struct pch_udc_dev, gadget);\n\n\tspin_lock_irqsave(&dev->lock, iflags);\n\tif (is_on) {\n\t\tpch_udc_reconnect(dev);\n\t} else {\n\t\tif (dev->driver && dev->driver->disconnect) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, iflags);\n\t\t\tdev->driver->disconnect(&dev->gadget);\n\t\t\tspin_lock_irqsave(&dev->lock, iflags);\n\t\t}\n\t\tpch_udc_set_disconnect(dev);\n\t}\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n\n\treturn 0;\n}\n\n \nstatic int pch_udc_pcd_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct pch_udc_dev\t*dev;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\tdev = container_of(gadget, struct pch_udc_dev, gadget);\n\tpch_udc_vbus_session(dev, is_active);\n\treturn 0;\n}\n\n \nstatic int pch_udc_pcd_vbus_draw(struct usb_gadget *gadget, unsigned int mA)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pch_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int pch_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops pch_udc_ops = {\n\t.get_frame = pch_udc_pcd_get_frame,\n\t.wakeup = pch_udc_pcd_wakeup,\n\t.set_selfpowered = pch_udc_pcd_selfpowered,\n\t.pullup = pch_udc_pcd_pullup,\n\t.vbus_session = pch_udc_pcd_vbus_session,\n\t.vbus_draw = pch_udc_pcd_vbus_draw,\n\t.udc_start = pch_udc_start,\n\t.udc_stop = pch_udc_stop,\n};\n\n \nstatic int pch_vbus_gpio_get_value(struct pch_udc_dev *dev)\n{\n\tint vbus = 0;\n\n\tif (dev->vbus_gpio.port)\n\t\tvbus = gpiod_get_value(dev->vbus_gpio.port) ? 1 : 0;\n\telse\n\t\tvbus = -1;\n\n\treturn vbus;\n}\n\n \nstatic void pch_vbus_gpio_work_fall(struct work_struct *irq_work)\n{\n\tstruct pch_vbus_gpio_data *vbus_gpio = container_of(irq_work,\n\t\tstruct pch_vbus_gpio_data, irq_work_fall);\n\tstruct pch_udc_dev *dev =\n\t\tcontainer_of(vbus_gpio, struct pch_udc_dev, vbus_gpio);\n\tint vbus_saved = -1;\n\tint vbus;\n\tint count;\n\n\tif (!dev->vbus_gpio.port)\n\t\treturn;\n\n\tfor (count = 0; count < (PCH_VBUS_PERIOD / PCH_VBUS_INTERVAL);\n\t\tcount++) {\n\t\tvbus = pch_vbus_gpio_get_value(dev);\n\n\t\tif ((vbus_saved == vbus) && (vbus == 0)) {\n\t\t\tdev_dbg(&dev->pdev->dev, \"VBUS fell\");\n\t\t\tif (dev->driver\n\t\t\t\t&& dev->driver->disconnect) {\n\t\t\t\tdev->driver->disconnect(\n\t\t\t\t\t&dev->gadget);\n\t\t\t}\n\t\t\tif (dev->vbus_gpio.intr)\n\t\t\t\tpch_udc_init(dev);\n\t\t\telse\n\t\t\t\tpch_udc_reconnect(dev);\n\t\t\treturn;\n\t\t}\n\t\tvbus_saved = vbus;\n\t\tmdelay(PCH_VBUS_INTERVAL);\n\t}\n}\n\n \nstatic void pch_vbus_gpio_work_rise(struct work_struct *irq_work)\n{\n\tstruct pch_vbus_gpio_data *vbus_gpio = container_of(irq_work,\n\t\tstruct pch_vbus_gpio_data, irq_work_rise);\n\tstruct pch_udc_dev *dev =\n\t\tcontainer_of(vbus_gpio, struct pch_udc_dev, vbus_gpio);\n\tint vbus;\n\n\tif (!dev->vbus_gpio.port)\n\t\treturn;\n\n\tmdelay(PCH_VBUS_INTERVAL);\n\tvbus = pch_vbus_gpio_get_value(dev);\n\n\tif (vbus == 1) {\n\t\tdev_dbg(&dev->pdev->dev, \"VBUS rose\");\n\t\tpch_udc_reconnect(dev);\n\t\treturn;\n\t}\n}\n\n \nstatic irqreturn_t pch_vbus_gpio_irq(int irq, void *data)\n{\n\tstruct pch_udc_dev *dev = (struct pch_udc_dev *)data;\n\n\tif (!dev->vbus_gpio.port || !dev->vbus_gpio.intr)\n\t\treturn IRQ_NONE;\n\n\tif (pch_vbus_gpio_get_value(dev))\n\t\tschedule_work(&dev->vbus_gpio.irq_work_rise);\n\telse\n\t\tschedule_work(&dev->vbus_gpio.irq_work_fall);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int pch_vbus_gpio_init(struct pch_udc_dev *dev)\n{\n\tstruct device *d = &dev->pdev->dev;\n\tint err;\n\tint irq_num = 0;\n\tstruct gpio_desc *gpiod;\n\n\tdev->vbus_gpio.port = NULL;\n\tdev->vbus_gpio.intr = 0;\n\n\t \n\tgpiod = devm_gpiod_get_optional(d, NULL, GPIOD_IN);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\tgpiod_set_consumer_name(gpiod, \"pch_vbus\");\n\n\tdev->vbus_gpio.port = gpiod;\n\tINIT_WORK(&dev->vbus_gpio.irq_work_fall, pch_vbus_gpio_work_fall);\n\n\tirq_num = gpiod_to_irq(gpiod);\n\tif (irq_num > 0) {\n\t\tirq_set_irq_type(irq_num, IRQ_TYPE_EDGE_BOTH);\n\t\terr = request_irq(irq_num, pch_vbus_gpio_irq, 0,\n\t\t\t\"vbus_detect\", dev);\n\t\tif (!err) {\n\t\t\tdev->vbus_gpio.intr = irq_num;\n\t\t\tINIT_WORK(&dev->vbus_gpio.irq_work_rise,\n\t\t\t\tpch_vbus_gpio_work_rise);\n\t\t} else {\n\t\t\tpr_err(\"%s: can't request irq %d, err: %d\\n\",\n\t\t\t\t__func__, irq_num, err);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void pch_vbus_gpio_free(struct pch_udc_dev *dev)\n{\n\tif (dev->vbus_gpio.intr)\n\t\tfree_irq(dev->vbus_gpio.intr, dev);\n}\n\n \nstatic void complete_req(struct pch_udc_ep *ep, struct pch_udc_request *req,\n\t\t\t\t\t\t\t\t int status)\n\t__releases(&dev->lock)\n\t__acquires(&dev->lock)\n{\n\tstruct pch_udc_dev\t*dev;\n\tunsigned halted = ep->halted;\n\n\tlist_del_init(&req->queue);\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tdev = ep->dev;\n\tusb_gadget_unmap_request(&dev->gadget, &req->req, ep->in);\n\tep->halted = 1;\n\tspin_unlock(&dev->lock);\n\tif (!ep->in)\n\t\tpch_udc_ep_clear_rrdy(ep);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&dev->lock);\n\tep->halted = halted;\n}\n\n \nstatic void empty_req_queue(struct pch_udc_ep *ep)\n{\n\tstruct pch_udc_request\t*req;\n\n\tep->halted = 1;\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct pch_udc_request, queue);\n\t\tcomplete_req(ep, req, -ESHUTDOWN);\t \n\t}\n}\n\n \nstatic void pch_udc_free_dma_chain(struct pch_udc_dev *dev,\n\t\t\t\t   struct pch_udc_request *req)\n{\n\tstruct pch_udc_data_dma_desc *td = req->td_data;\n\tunsigned i = req->chain_len;\n\n\tdma_addr_t addr2;\n\tdma_addr_t addr = (dma_addr_t)td->next;\n\ttd->next = 0x00;\n\tfor (; i > 1; --i) {\n\t\t \n\t\ttd = phys_to_virt(addr);\n\t\taddr2 = (dma_addr_t)td->next;\n\t\tdma_pool_free(dev->data_requests, td, addr);\n\t\taddr = addr2;\n\t}\n\treq->chain_len = 1;\n}\n\n \nstatic int pch_udc_create_dma_chain(struct pch_udc_ep *ep,\n\t\t\t\t    struct pch_udc_request *req,\n\t\t\t\t    unsigned long buf_len,\n\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct pch_udc_data_dma_desc *td = req->td_data, *last;\n\tunsigned long bytes = req->req.length, i = 0;\n\tdma_addr_t dma_addr;\n\tunsigned len = 1;\n\n\tif (req->chain_len > 1)\n\t\tpch_udc_free_dma_chain(ep->dev, req);\n\n\ttd->dataptr = req->req.dma;\n\ttd->status = PCH_UDC_BS_HST_BSY;\n\n\tfor (; ; bytes -= buf_len, ++len) {\n\t\ttd->status = PCH_UDC_BS_HST_BSY | min(buf_len, bytes);\n\t\tif (bytes <= buf_len)\n\t\t\tbreak;\n\t\tlast = td;\n\t\ttd = dma_pool_alloc(ep->dev->data_requests, gfp_flags,\n\t\t\t\t    &dma_addr);\n\t\tif (!td)\n\t\t\tgoto nomem;\n\t\ti += buf_len;\n\t\ttd->dataptr = req->td_data->dataptr + i;\n\t\tlast->next = dma_addr;\n\t}\n\n\treq->td_data_last = td;\n\ttd->status |= PCH_UDC_DMA_LAST;\n\ttd->next = req->td_data_phys;\n\treq->chain_len = len;\n\treturn 0;\n\nnomem:\n\tif (len > 1) {\n\t\treq->chain_len = len;\n\t\tpch_udc_free_dma_chain(ep->dev, req);\n\t}\n\treq->chain_len = 1;\n\treturn -ENOMEM;\n}\n\n \nstatic int prepare_dma(struct pch_udc_ep *ep, struct pch_udc_request *req,\n\t\t\t  gfp_t gfp)\n{\n\tint\tretval;\n\n\t \n\tretval = pch_udc_create_dma_chain(ep, req, ep->ep.maxpacket, gfp);\n\tif (retval) {\n\t\tpr_err(\"%s: could not create DMA chain:%d\\n\", __func__, retval);\n\t\treturn retval;\n\t}\n\tif (ep->in)\n\t\treq->td_data->status = (req->td_data->status &\n\t\t\t\t~PCH_UDC_BUFF_STS) | PCH_UDC_BS_HST_RDY;\n\treturn 0;\n}\n\n \nstatic void process_zlp(struct pch_udc_ep *ep, struct pch_udc_request *req)\n{\n\tstruct pch_udc_dev\t*dev = ep->dev;\n\n\t \n\tcomplete_req(ep, req, 0);\n\n\t \n\tif (dev->set_cfg_not_acked) {\n\t\tpch_udc_set_csr_done(dev);\n\t\tdev->set_cfg_not_acked = 0;\n\t}\n\t \n\tif (!dev->stall && dev->waiting_zlp_ack) {\n\t\tpch_udc_ep_clear_nak(&(dev->ep[UDC_EP0IN_IDX]));\n\t\tdev->waiting_zlp_ack = 0;\n\t}\n}\n\n \nstatic void pch_udc_start_rxrequest(struct pch_udc_ep *ep,\n\t\t\t\t\t struct pch_udc_request *req)\n{\n\tstruct pch_udc_data_dma_desc *td_data;\n\n\tpch_udc_clear_dma(ep->dev, DMA_DIR_RX);\n\ttd_data = req->td_data;\n\t \n\twhile (1) {\n\t\ttd_data->status = (td_data->status & ~PCH_UDC_BUFF_STS) |\n\t\t\t\t    PCH_UDC_BS_HST_RDY;\n\t\tif ((td_data->status & PCH_UDC_DMA_LAST) ==  PCH_UDC_DMA_LAST)\n\t\t\tbreak;\n\t\ttd_data = phys_to_virt(td_data->next);\n\t}\n\t \n\tpch_udc_ep_set_ddptr(ep, req->td_data_phys);\n\treq->dma_going = 1;\n\tpch_udc_enable_ep_interrupts(ep->dev, UDC_EPINT_OUT_EP0 << ep->num);\n\tpch_udc_set_dma(ep->dev, DMA_DIR_RX);\n\tpch_udc_ep_clear_nak(ep);\n\tpch_udc_ep_set_rrdy(ep);\n}\n\n \nstatic int pch_udc_pcd_ep_enable(struct usb_ep *usbep,\n\t\t\t\t    const struct usb_endpoint_descriptor *desc)\n{\n\tstruct pch_udc_ep\t*ep;\n\tstruct pch_udc_dev\t*dev;\n\tunsigned long\t\tiflags;\n\n\tif (!usbep || (usbep->name == ep0_string) || !desc ||\n\t    (desc->bDescriptorType != USB_DT_ENDPOINT) || !desc->wMaxPacketSize)\n\t\treturn -EINVAL;\n\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tdev = ep->dev;\n\tif (!dev->driver || (dev->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\tspin_lock_irqsave(&dev->lock, iflags);\n\tep->ep.desc = desc;\n\tep->halted = 0;\n\tpch_udc_ep_enable(ep, &ep->dev->cfg_data, desc);\n\tep->ep.maxpacket = usb_endpoint_maxp(desc);\n\tpch_udc_enable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n\treturn 0;\n}\n\n \nstatic int pch_udc_pcd_ep_disable(struct usb_ep *usbep)\n{\n\tstruct pch_udc_ep\t*ep;\n\tunsigned long\tiflags;\n\n\tif (!usbep)\n\t\treturn -EINVAL;\n\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tif ((usbep->name == ep0_string) || !ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->dev->lock, iflags);\n\tempty_req_queue(ep);\n\tep->halted = 1;\n\tpch_udc_ep_disable(ep);\n\tpch_udc_disable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\n\tep->ep.desc = NULL;\n\tINIT_LIST_HEAD(&ep->queue);\n\tspin_unlock_irqrestore(&ep->dev->lock, iflags);\n\treturn 0;\n}\n\n \nstatic struct usb_request *pch_udc_alloc_request(struct usb_ep *usbep,\n\t\t\t\t\t\t  gfp_t gfp)\n{\n\tstruct pch_udc_request\t\t*req;\n\tstruct pch_udc_ep\t\t*ep;\n\tstruct pch_udc_data_dma_desc\t*dma_desc;\n\n\tif (!usbep)\n\t\treturn NULL;\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\treq = kzalloc(sizeof *req, gfp);\n\tif (!req)\n\t\treturn NULL;\n\treq->req.dma = DMA_ADDR_INVALID;\n\tINIT_LIST_HEAD(&req->queue);\n\tif (!ep->dev->dma_addr)\n\t\treturn &req->req;\n\t \n\tdma_desc = dma_pool_alloc(ep->dev->data_requests, gfp,\n\t\t\t\t  &req->td_data_phys);\n\tif (NULL == dma_desc) {\n\t\tkfree(req);\n\t\treturn NULL;\n\t}\n\t \n\tdma_desc->status |= PCH_UDC_BS_HST_BSY;\n\tdma_desc->dataptr = lower_32_bits(DMA_ADDR_INVALID);\n\treq->td_data = dma_desc;\n\treq->td_data_last = dma_desc;\n\treq->chain_len = 1;\n\treturn &req->req;\n}\n\n \nstatic void pch_udc_free_request(struct usb_ep *usbep,\n\t\t\t\t  struct usb_request *usbreq)\n{\n\tstruct pch_udc_ep\t*ep;\n\tstruct pch_udc_request\t*req;\n\tstruct pch_udc_dev\t*dev;\n\n\tif (!usbep || !usbreq)\n\t\treturn;\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\treq = container_of(usbreq, struct pch_udc_request, req);\n\tdev = ep->dev;\n\tif (!list_empty(&req->queue))\n\t\tdev_err(&dev->pdev->dev, \"%s: %s req=0x%p queue not empty\\n\",\n\t\t\t__func__, usbep->name, req);\n\tif (req->td_data != NULL) {\n\t\tif (req->chain_len > 1)\n\t\t\tpch_udc_free_dma_chain(ep->dev, req);\n\t\tdma_pool_free(ep->dev->data_requests, req->td_data,\n\t\t\t      req->td_data_phys);\n\t}\n\tkfree(req);\n}\n\n \nstatic int pch_udc_pcd_queue(struct usb_ep *usbep, struct usb_request *usbreq,\n\t\t\t\t\t\t\t\t gfp_t gfp)\n{\n\tint retval = 0;\n\tstruct pch_udc_ep\t*ep;\n\tstruct pch_udc_dev\t*dev;\n\tstruct pch_udc_request\t*req;\n\tunsigned long\tiflags;\n\n\tif (!usbep || !usbreq || !usbreq->complete || !usbreq->buf)\n\t\treturn -EINVAL;\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tdev = ep->dev;\n\tif (!ep->ep.desc && ep->num)\n\t\treturn -EINVAL;\n\treq = container_of(usbreq, struct pch_udc_request, req);\n\tif (!list_empty(&req->queue))\n\t\treturn -EINVAL;\n\tif (!dev->driver || (dev->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\tspin_lock_irqsave(&dev->lock, iflags);\n\t \n\tretval = usb_gadget_map_request(&dev->gadget, usbreq, ep->in);\n\tif (retval)\n\t\tgoto probe_end;\n\tif (usbreq->length > 0) {\n\t\tretval = prepare_dma(ep, req, GFP_ATOMIC);\n\t\tif (retval)\n\t\t\tgoto probe_end;\n\t}\n\tusbreq->actual = 0;\n\tusbreq->status = -EINPROGRESS;\n\treq->dma_done = 0;\n\tif (list_empty(&ep->queue) && !ep->halted) {\n\t\t \n\t\tif (!usbreq->length) {\n\t\t\tprocess_zlp(ep, req);\n\t\t\tretval = 0;\n\t\t\tgoto probe_end;\n\t\t}\n\t\tif (!ep->in) {\n\t\t\tpch_udc_start_rxrequest(ep, req);\n\t\t} else {\n\t\t\t \n\t\t\tpch_udc_wait_ep_stall(ep);\n\t\t\tpch_udc_ep_clear_nak(ep);\n\t\t\tpch_udc_enable_ep_interrupts(ep->dev, (1 << ep->num));\n\t\t}\n\t}\n\t \n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\nprobe_end:\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n\treturn retval;\n}\n\n \nstatic int pch_udc_pcd_dequeue(struct usb_ep *usbep,\n\t\t\t\tstruct usb_request *usbreq)\n{\n\tstruct pch_udc_ep\t*ep;\n\tstruct pch_udc_request\t*req;\n\tunsigned long\t\tflags;\n\tint ret = -EINVAL;\n\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tif (!usbep || !usbreq || (!ep->ep.desc && ep->num))\n\t\treturn ret;\n\treq = container_of(usbreq, struct pch_udc_request, req);\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\t \n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tif (&req->req == usbreq) {\n\t\t\tpch_udc_ep_set_nak(ep);\n\t\t\tif (!list_empty(&req->queue))\n\t\t\t\tcomplete_req(ep, req, -ECONNRESET);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn ret;\n}\n\n \nstatic int pch_udc_pcd_set_halt(struct usb_ep *usbep, int halt)\n{\n\tstruct pch_udc_ep\t*ep;\n\tunsigned long iflags;\n\tint ret;\n\n\tif (!usbep)\n\t\treturn -EINVAL;\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tif (!ep->ep.desc && !ep->num)\n\t\treturn -EINVAL;\n\tif (!ep->dev->driver || (ep->dev->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\tspin_lock_irqsave(&udc_stall_spinlock, iflags);\n\tif (list_empty(&ep->queue)) {\n\t\tif (halt) {\n\t\t\tif (ep->num == PCH_UDC_EP0)\n\t\t\t\tep->dev->stall = 1;\n\t\t\tpch_udc_ep_set_stall(ep);\n\t\t\tpch_udc_enable_ep_interrupts(\n\t\t\t\tep->dev, PCH_UDC_EPINT(ep->in, ep->num));\n\t\t} else {\n\t\t\tpch_udc_ep_clear_stall(ep);\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tret = -EAGAIN;\n\t}\n\tspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\n\treturn ret;\n}\n\n \nstatic int pch_udc_pcd_set_wedge(struct usb_ep *usbep)\n{\n\tstruct pch_udc_ep\t*ep;\n\tunsigned long iflags;\n\tint ret;\n\n\tif (!usbep)\n\t\treturn -EINVAL;\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tif (!ep->ep.desc && !ep->num)\n\t\treturn -EINVAL;\n\tif (!ep->dev->driver || (ep->dev->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\tspin_lock_irqsave(&udc_stall_spinlock, iflags);\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tif (ep->num == PCH_UDC_EP0)\n\t\t\tep->dev->stall = 1;\n\t\tpch_udc_ep_set_stall(ep);\n\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t     PCH_UDC_EPINT(ep->in, ep->num));\n\t\tep->dev->prot_stall = 1;\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\n\treturn ret;\n}\n\n \nstatic void pch_udc_pcd_fifo_flush(struct usb_ep *usbep)\n{\n\tstruct pch_udc_ep  *ep;\n\n\tif (!usbep)\n\t\treturn;\n\n\tep = container_of(usbep, struct pch_udc_ep, ep);\n\tif (ep->ep.desc || !ep->num)\n\t\tpch_udc_ep_fifo_flush(ep, ep->in);\n}\n\nstatic const struct usb_ep_ops pch_udc_ep_ops = {\n\t.enable\t\t= pch_udc_pcd_ep_enable,\n\t.disable\t= pch_udc_pcd_ep_disable,\n\t.alloc_request\t= pch_udc_alloc_request,\n\t.free_request\t= pch_udc_free_request,\n\t.queue\t\t= pch_udc_pcd_queue,\n\t.dequeue\t= pch_udc_pcd_dequeue,\n\t.set_halt\t= pch_udc_pcd_set_halt,\n\t.set_wedge\t= pch_udc_pcd_set_wedge,\n\t.fifo_status\t= NULL,\n\t.fifo_flush\t= pch_udc_pcd_fifo_flush,\n};\n\n \nstatic void pch_udc_init_setup_buff(struct pch_udc_stp_dma_desc *td_stp)\n{\n\tstatic u32\tpky_marker;\n\n\tif (!td_stp)\n\t\treturn;\n\ttd_stp->reserved = ++pky_marker;\n\tmemset(&td_stp->request, 0xFF, sizeof td_stp->request);\n\ttd_stp->status = PCH_UDC_BS_HST_RDY;\n}\n\n \nstatic void pch_udc_start_next_txrequest(struct pch_udc_ep *ep)\n{\n\tstruct pch_udc_request *req;\n\tstruct pch_udc_data_dma_desc *td_data;\n\n\tif (pch_udc_read_ep_control(ep) & UDC_EPCTL_P)\n\t\treturn;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\t \n\treq = list_entry(ep->queue.next, struct pch_udc_request, queue);\n\tif (req->dma_going)\n\t\treturn;\n\tif (!req->td_data)\n\t\treturn;\n\tpch_udc_wait_ep_stall(ep);\n\treq->dma_going = 1;\n\tpch_udc_ep_set_ddptr(ep, 0);\n\ttd_data = req->td_data;\n\twhile (1) {\n\t\ttd_data->status = (td_data->status & ~PCH_UDC_BUFF_STS) |\n\t\t\t\t   PCH_UDC_BS_HST_RDY;\n\t\tif ((td_data->status & PCH_UDC_DMA_LAST) == PCH_UDC_DMA_LAST)\n\t\t\tbreak;\n\t\ttd_data = phys_to_virt(td_data->next);\n\t}\n\tpch_udc_ep_set_ddptr(ep, req->td_data_phys);\n\tpch_udc_set_dma(ep->dev, DMA_DIR_TX);\n\tpch_udc_ep_set_pd(ep);\n\tpch_udc_enable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\n\tpch_udc_ep_clear_nak(ep);\n}\n\n \nstatic void pch_udc_complete_transfer(struct pch_udc_ep *ep)\n{\n\tstruct pch_udc_request *req;\n\tstruct pch_udc_dev *dev = ep->dev;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\treq = list_entry(ep->queue.next, struct pch_udc_request, queue);\n\tif ((req->td_data_last->status & PCH_UDC_BUFF_STS) !=\n\t    PCH_UDC_BS_DMA_DONE)\n\t\treturn;\n\tif ((req->td_data_last->status & PCH_UDC_RXTX_STS) !=\n\t     PCH_UDC_RTS_SUCC) {\n\t\tdev_err(&dev->pdev->dev, \"Invalid RXTX status (0x%08x) \"\n\t\t\t\"epstatus=0x%08x\\n\",\n\t\t       (req->td_data_last->status & PCH_UDC_RXTX_STS),\n\t\t       (int)(ep->epsts));\n\t\treturn;\n\t}\n\n\treq->req.actual = req->req.length;\n\treq->td_data_last->status = PCH_UDC_BS_HST_BSY | PCH_UDC_DMA_LAST;\n\treq->td_data->status = PCH_UDC_BS_HST_BSY | PCH_UDC_DMA_LAST;\n\tcomplete_req(ep, req, 0);\n\treq->dma_going = 0;\n\tif (!list_empty(&ep->queue)) {\n\t\tpch_udc_wait_ep_stall(ep);\n\t\tpch_udc_ep_clear_nak(ep);\n\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t     PCH_UDC_EPINT(ep->in, ep->num));\n\t} else {\n\t\tpch_udc_disable_ep_interrupts(ep->dev,\n\t\t\t\t\t      PCH_UDC_EPINT(ep->in, ep->num));\n\t}\n}\n\n \nstatic void pch_udc_complete_receiver(struct pch_udc_ep *ep)\n{\n\tstruct pch_udc_request *req;\n\tstruct pch_udc_dev *dev = ep->dev;\n\tunsigned int count;\n\tstruct pch_udc_data_dma_desc *td;\n\tdma_addr_t addr;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\t \n\treq = list_entry(ep->queue.next, struct pch_udc_request, queue);\n\tpch_udc_clear_dma(ep->dev, DMA_DIR_RX);\n\tpch_udc_ep_set_ddptr(ep, 0);\n\tif ((req->td_data_last->status & PCH_UDC_BUFF_STS) ==\n\t    PCH_UDC_BS_DMA_DONE)\n\t\ttd = req->td_data_last;\n\telse\n\t\ttd = req->td_data;\n\n\twhile (1) {\n\t\tif ((td->status & PCH_UDC_RXTX_STS) != PCH_UDC_RTS_SUCC) {\n\t\t\tdev_err(&dev->pdev->dev, \"Invalid RXTX status=0x%08x \"\n\t\t\t\t\"epstatus=0x%08x\\n\",\n\t\t\t\t(req->td_data->status & PCH_UDC_RXTX_STS),\n\t\t\t\t(int)(ep->epsts));\n\t\t\treturn;\n\t\t}\n\t\tif ((td->status & PCH_UDC_BUFF_STS) == PCH_UDC_BS_DMA_DONE)\n\t\t\tif (td->status & PCH_UDC_DMA_LAST) {\n\t\t\t\tcount = td->status & PCH_UDC_RXTX_BYTES;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (td == req->td_data_last) {\n\t\t\tdev_err(&dev->pdev->dev, \"Not complete RX descriptor\");\n\t\t\treturn;\n\t\t}\n\t\taddr = (dma_addr_t)td->next;\n\t\ttd = phys_to_virt(addr);\n\t}\n\t \n\tif (!count && (req->req.length == UDC_DMA_MAXPACKET))\n\t\tcount = UDC_DMA_MAXPACKET;\n\treq->td_data->status |= PCH_UDC_DMA_LAST;\n\ttd->status |= PCH_UDC_BS_HST_BSY;\n\n\treq->dma_going = 0;\n\treq->req.actual = count;\n\tcomplete_req(ep, req, 0);\n\t \n\tif (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct pch_udc_request, queue);\n\t\tpch_udc_start_rxrequest(ep, req);\n\t}\n}\n\n \nstatic void pch_udc_svc_data_in(struct pch_udc_dev *dev, int ep_num)\n{\n\tu32\tepsts;\n\tstruct pch_udc_ep\t*ep;\n\n\tep = &dev->ep[UDC_EPIN_IDX(ep_num)];\n\tepsts = ep->epsts;\n\tep->epsts = 0;\n\n\tif (!(epsts & (UDC_EPSTS_IN | UDC_EPSTS_BNA  | UDC_EPSTS_HE |\n\t\t       UDC_EPSTS_TDC | UDC_EPSTS_RCS | UDC_EPSTS_TXEMPTY |\n\t\t       UDC_EPSTS_RSS | UDC_EPSTS_XFERDONE)))\n\t\treturn;\n\tif ((epsts & UDC_EPSTS_BNA))\n\t\treturn;\n\tif (epsts & UDC_EPSTS_HE)\n\t\treturn;\n\tif (epsts & UDC_EPSTS_RSS) {\n\t\tpch_udc_ep_set_stall(ep);\n\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t     PCH_UDC_EPINT(ep->in, ep->num));\n\t}\n\tif (epsts & UDC_EPSTS_RCS) {\n\t\tif (!dev->prot_stall) {\n\t\t\tpch_udc_ep_clear_stall(ep);\n\t\t} else {\n\t\t\tpch_udc_ep_set_stall(ep);\n\t\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t\tPCH_UDC_EPINT(ep->in, ep->num));\n\t\t}\n\t}\n\tif (epsts & UDC_EPSTS_TDC)\n\t\tpch_udc_complete_transfer(ep);\n\t \n\tif ((epsts & UDC_EPSTS_IN) && !(epsts & UDC_EPSTS_RSS) &&\n\t    !(epsts & UDC_EPSTS_TDC) && !(epsts & UDC_EPSTS_TXEMPTY))\n\t\tpch_udc_start_next_txrequest(ep);\n}\n\n \nstatic void pch_udc_svc_data_out(struct pch_udc_dev *dev, int ep_num)\n{\n\tu32\t\t\tepsts;\n\tstruct pch_udc_ep\t\t*ep;\n\tstruct pch_udc_request\t\t*req = NULL;\n\n\tep = &dev->ep[UDC_EPOUT_IDX(ep_num)];\n\tepsts = ep->epsts;\n\tep->epsts = 0;\n\n\tif ((epsts & UDC_EPSTS_BNA) && (!list_empty(&ep->queue))) {\n\t\t \n\t\treq = list_entry(ep->queue.next, struct pch_udc_request,\n\t\t\t\t queue);\n\t\tif ((req->td_data_last->status & PCH_UDC_BUFF_STS) !=\n\t\t     PCH_UDC_BS_DMA_DONE) {\n\t\t\tif (!req->dma_going)\n\t\t\t\tpch_udc_start_rxrequest(ep, req);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (epsts & UDC_EPSTS_HE)\n\t\treturn;\n\tif (epsts & UDC_EPSTS_RSS) {\n\t\tpch_udc_ep_set_stall(ep);\n\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t     PCH_UDC_EPINT(ep->in, ep->num));\n\t}\n\tif (epsts & UDC_EPSTS_RCS) {\n\t\tif (!dev->prot_stall) {\n\t\t\tpch_udc_ep_clear_stall(ep);\n\t\t} else {\n\t\t\tpch_udc_ep_set_stall(ep);\n\t\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t\tPCH_UDC_EPINT(ep->in, ep->num));\n\t\t}\n\t}\n\tif (((epsts & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\n\t    UDC_EPSTS_OUT_DATA) {\n\t\tif (ep->dev->prot_stall == 1) {\n\t\t\tpch_udc_ep_set_stall(ep);\n\t\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t\tPCH_UDC_EPINT(ep->in, ep->num));\n\t\t} else {\n\t\t\tpch_udc_complete_receiver(ep);\n\t\t}\n\t}\n\tif (list_empty(&ep->queue))\n\t\tpch_udc_set_dma(dev, DMA_DIR_RX);\n}\n\nstatic int pch_udc_gadget_setup(struct pch_udc_dev *dev)\n\t__must_hold(&dev->lock)\n{\n\tint rc;\n\n\t \n\tif (!dev->driver)\n\t\treturn -ESHUTDOWN;\n\n\tspin_unlock(&dev->lock);\n\trc = dev->driver->setup(&dev->gadget, &dev->setup_data);\n\tspin_lock(&dev->lock);\n\treturn rc;\n}\n\n \nstatic void pch_udc_svc_control_in(struct pch_udc_dev *dev)\n{\n\tu32\tepsts;\n\tstruct pch_udc_ep\t*ep;\n\tstruct pch_udc_ep\t*ep_out;\n\n\tep = &dev->ep[UDC_EP0IN_IDX];\n\tep_out = &dev->ep[UDC_EP0OUT_IDX];\n\tepsts = ep->epsts;\n\tep->epsts = 0;\n\n\tif (!(epsts & (UDC_EPSTS_IN | UDC_EPSTS_BNA | UDC_EPSTS_HE |\n\t\t       UDC_EPSTS_TDC | UDC_EPSTS_RCS | UDC_EPSTS_TXEMPTY |\n\t\t       UDC_EPSTS_XFERDONE)))\n\t\treturn;\n\tif ((epsts & UDC_EPSTS_BNA))\n\t\treturn;\n\tif (epsts & UDC_EPSTS_HE)\n\t\treturn;\n\tif ((epsts & UDC_EPSTS_TDC) && (!dev->stall)) {\n\t\tpch_udc_complete_transfer(ep);\n\t\tpch_udc_clear_dma(dev, DMA_DIR_RX);\n\t\tep_out->td_data->status = (ep_out->td_data->status &\n\t\t\t\t\t~PCH_UDC_BUFF_STS) |\n\t\t\t\t\tPCH_UDC_BS_HST_RDY;\n\t\tpch_udc_ep_clear_nak(ep_out);\n\t\tpch_udc_set_dma(dev, DMA_DIR_RX);\n\t\tpch_udc_ep_set_rrdy(ep_out);\n\t}\n\t \n\tif ((epsts & UDC_EPSTS_IN) && !(epsts & UDC_EPSTS_TDC) &&\n\t     !(epsts & UDC_EPSTS_TXEMPTY))\n\t\tpch_udc_start_next_txrequest(ep);\n}\n\n \nstatic void pch_udc_svc_control_out(struct pch_udc_dev *dev)\n\t__releases(&dev->lock)\n\t__acquires(&dev->lock)\n{\n\tu32\tstat;\n\tint setup_supported;\n\tstruct pch_udc_ep\t*ep;\n\n\tep = &dev->ep[UDC_EP0OUT_IDX];\n\tstat = ep->epsts;\n\tep->epsts = 0;\n\n\t \n\tif (((stat & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\n\t    UDC_EPSTS_OUT_SETUP) {\n\t\tdev->stall = 0;\n\t\tdev->ep[UDC_EP0IN_IDX].halted = 0;\n\t\tdev->ep[UDC_EP0OUT_IDX].halted = 0;\n\t\tdev->setup_data = ep->td_stp->request;\n\t\tpch_udc_init_setup_buff(ep->td_stp);\n\t\tpch_udc_clear_dma(dev, DMA_DIR_RX);\n\t\tpch_udc_ep_fifo_flush(&(dev->ep[UDC_EP0IN_IDX]),\n\t\t\t\t      dev->ep[UDC_EP0IN_IDX].in);\n\t\tif ((dev->setup_data.bRequestType & USB_DIR_IN))\n\t\t\tdev->gadget.ep0 = &dev->ep[UDC_EP0IN_IDX].ep;\n\t\telse  \n\t\t\tdev->gadget.ep0 = &ep->ep;\n\t\t \n\t\tif ((dev->setup_data.bRequestType == 0x21) &&\n\t\t    (dev->setup_data.bRequest == 0xFF))\n\t\t\tdev->prot_stall = 0;\n\t\t \n\t\tsetup_supported = pch_udc_gadget_setup(dev);\n\n\t\tif (dev->setup_data.bRequestType & USB_DIR_IN) {\n\t\t\tep->td_data->status = (ep->td_data->status &\n\t\t\t\t\t\t~PCH_UDC_BUFF_STS) |\n\t\t\t\t\t\tPCH_UDC_BS_HST_RDY;\n\t\t\tpch_udc_ep_set_ddptr(ep, ep->td_data_phys);\n\t\t}\n\t\t \n\t\tif (setup_supported >= 0 && setup_supported <\n\t\t\t\t\t    UDC_EP0IN_MAX_PKT_SIZE) {\n\t\t\tpch_udc_ep_clear_nak(&(dev->ep[UDC_EP0IN_IDX]));\n\t\t\t \n\t\t\tif (!(dev->setup_data.bRequestType & USB_DIR_IN)) {\n\t\t\t\tpch_udc_set_dma(dev, DMA_DIR_RX);\n\t\t\t\tpch_udc_ep_clear_nak(ep);\n\t\t\t}\n\t\t} else if (setup_supported < 0) {\n\t\t\t \n\t\t\tpch_udc_ep_set_stall(&(dev->ep[UDC_EP0IN_IDX]));\n\t\t\tpch_udc_enable_ep_interrupts(ep->dev,\n\t\t\t\t\t\tPCH_UDC_EPINT(ep->in, ep->num));\n\t\t\tdev->stall = 0;\n\t\t\tpch_udc_set_dma(dev, DMA_DIR_RX);\n\t\t} else {\n\t\t\tdev->waiting_zlp_ack = 1;\n\t\t}\n\t} else if ((((stat & UDC_EPSTS_OUT_MASK) >> UDC_EPSTS_OUT_SHIFT) ==\n\t\t     UDC_EPSTS_OUT_DATA) && !dev->stall) {\n\t\tpch_udc_clear_dma(dev, DMA_DIR_RX);\n\t\tpch_udc_ep_set_ddptr(ep, 0);\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\tep->epsts = stat;\n\t\t\tpch_udc_svc_data_out(dev, PCH_UDC_EP0);\n\t\t}\n\t\tpch_udc_set_dma(dev, DMA_DIR_RX);\n\t}\n\tpch_udc_ep_set_rrdy(ep);\n}\n\n\n \nstatic void pch_udc_postsvc_epinters(struct pch_udc_dev *dev, int ep_num)\n{\n\tstruct pch_udc_ep\t*ep = &dev->ep[UDC_EPIN_IDX(ep_num)];\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\tpch_udc_enable_ep_interrupts(ep->dev, PCH_UDC_EPINT(ep->in, ep->num));\n\tpch_udc_ep_clear_nak(ep);\n}\n\n \nstatic void pch_udc_read_all_epstatus(struct pch_udc_dev *dev, u32 ep_intr)\n{\n\tint i;\n\tstruct pch_udc_ep\t*ep;\n\n\tfor (i = 0; i < PCH_UDC_USED_EP_NUM; i++) {\n\t\t \n\t\tif (ep_intr & (0x1 << i)) {\n\t\t\tep = &dev->ep[UDC_EPIN_IDX(i)];\n\t\t\tep->epsts = pch_udc_read_ep_status(ep);\n\t\t\tpch_udc_clear_ep_status(ep, ep->epsts);\n\t\t}\n\t\t \n\t\tif (ep_intr & (0x10000 << i)) {\n\t\t\tep = &dev->ep[UDC_EPOUT_IDX(i)];\n\t\t\tep->epsts = pch_udc_read_ep_status(ep);\n\t\t\tpch_udc_clear_ep_status(ep, ep->epsts);\n\t\t}\n\t}\n}\n\n \nstatic void pch_udc_activate_control_ep(struct pch_udc_dev *dev)\n{\n\tstruct pch_udc_ep\t*ep;\n\tu32 val;\n\n\t \n\tep = &dev->ep[UDC_EP0IN_IDX];\n\tpch_udc_clear_ep_control(ep);\n\tpch_udc_ep_fifo_flush(ep, ep->in);\n\tpch_udc_ep_set_bufsz(ep, UDC_EP0IN_BUFF_SIZE, ep->in);\n\tpch_udc_ep_set_maxpkt(ep, UDC_EP0IN_MAX_PKT_SIZE);\n\t \n\tep->td_data      = NULL;\n\tep->td_stp       = NULL;\n\tep->td_data_phys = 0;\n\tep->td_stp_phys  = 0;\n\n\t \n\tep = &dev->ep[UDC_EP0OUT_IDX];\n\tpch_udc_clear_ep_control(ep);\n\tpch_udc_ep_fifo_flush(ep, ep->in);\n\tpch_udc_ep_set_bufsz(ep, UDC_EP0OUT_BUFF_SIZE, ep->in);\n\tpch_udc_ep_set_maxpkt(ep, UDC_EP0OUT_MAX_PKT_SIZE);\n\tval = UDC_EP0OUT_MAX_PKT_SIZE << UDC_CSR_NE_MAX_PKT_SHIFT;\n\tpch_udc_write_csr(ep->dev, val, UDC_EP0OUT_IDX);\n\n\t \n\tpch_udc_init_setup_buff(ep->td_stp);\n\t \n\tpch_udc_ep_set_subptr(ep, ep->td_stp_phys);\n\t \n\tpch_udc_ep_set_ddptr(ep, ep->td_data_phys);\n\n\t \n\tep->td_data->status  = PCH_UDC_DMA_LAST;\n\tep->td_data->dataptr = dev->dma_addr;\n\tep->td_data->next    = ep->td_data_phys;\n\n\tpch_udc_ep_clear_nak(ep);\n}\n\n\n \nstatic void pch_udc_svc_ur_interrupt(struct pch_udc_dev *dev)\n{\n\tstruct pch_udc_ep\t*ep;\n\tint i;\n\n\tpch_udc_clear_dma(dev, DMA_DIR_TX);\n\tpch_udc_clear_dma(dev, DMA_DIR_RX);\n\t \n\tpch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\n\t \n\tpch_udc_write_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\n\n\tfor (i = 0; i < PCH_UDC_EP_NUM; i++) {\n\t\tep = &dev->ep[i];\n\t\tpch_udc_clear_ep_status(ep, UDC_EPSTS_ALL_CLR_MASK);\n\t\tpch_udc_clear_ep_control(ep);\n\t\tpch_udc_ep_set_ddptr(ep, 0);\n\t\tpch_udc_write_csr(ep->dev, 0x00, i);\n\t}\n\tdev->stall = 0;\n\tdev->prot_stall = 0;\n\tdev->waiting_zlp_ack = 0;\n\tdev->set_cfg_not_acked = 0;\n\n\t \n\tfor (i = 0; i < (PCH_UDC_USED_EP_NUM*2); i++) {\n\t\tep = &dev->ep[i];\n\t\tpch_udc_ep_set_nak(ep);\n\t\tpch_udc_ep_fifo_flush(ep, ep->in);\n\t\t \n\t\tempty_req_queue(ep);\n\t}\n\tif (dev->driver) {\n\t\tspin_unlock(&dev->lock);\n\t\tusb_gadget_udc_reset(&dev->gadget, dev->driver);\n\t\tspin_lock(&dev->lock);\n\t}\n}\n\n \nstatic void pch_udc_svc_enum_interrupt(struct pch_udc_dev *dev)\n{\n\tu32 dev_stat, dev_speed;\n\tu32 speed = USB_SPEED_FULL;\n\n\tdev_stat = pch_udc_read_device_status(dev);\n\tdev_speed = (dev_stat & UDC_DEVSTS_ENUM_SPEED_MASK) >>\n\t\t\t\t\t\t UDC_DEVSTS_ENUM_SPEED_SHIFT;\n\tswitch (dev_speed) {\n\tcase UDC_DEVSTS_ENUM_SPEED_HIGH:\n\t\tspeed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase  UDC_DEVSTS_ENUM_SPEED_FULL:\n\t\tspeed = USB_SPEED_FULL;\n\t\tbreak;\n\tcase  UDC_DEVSTS_ENUM_SPEED_LOW:\n\t\tspeed = USB_SPEED_LOW;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tdev->gadget.speed = speed;\n\tpch_udc_activate_control_ep(dev);\n\tpch_udc_enable_ep_interrupts(dev, UDC_EPINT_IN_EP0 | UDC_EPINT_OUT_EP0);\n\tpch_udc_set_dma(dev, DMA_DIR_TX);\n\tpch_udc_set_dma(dev, DMA_DIR_RX);\n\tpch_udc_ep_set_rrdy(&(dev->ep[UDC_EP0OUT_IDX]));\n\n\t \n\tpch_udc_enable_interrupts(dev, UDC_DEVINT_UR | UDC_DEVINT_US |\n\t\t\t\t\tUDC_DEVINT_ES | UDC_DEVINT_ENUM |\n\t\t\t\t\tUDC_DEVINT_SI | UDC_DEVINT_SC);\n}\n\n \nstatic void pch_udc_svc_intf_interrupt(struct pch_udc_dev *dev)\n{\n\tu32 reg, dev_stat = 0;\n\tint i;\n\n\tdev_stat = pch_udc_read_device_status(dev);\n\tdev->cfg_data.cur_intf = (dev_stat & UDC_DEVSTS_INTF_MASK) >>\n\t\t\t\t\t\t\t UDC_DEVSTS_INTF_SHIFT;\n\tdev->cfg_data.cur_alt = (dev_stat & UDC_DEVSTS_ALT_MASK) >>\n\t\t\t\t\t\t\t UDC_DEVSTS_ALT_SHIFT;\n\tdev->set_cfg_not_acked = 1;\n\t \n\tmemset(&dev->setup_data, 0 , sizeof dev->setup_data);\n\tdev->setup_data.bRequest = USB_REQ_SET_INTERFACE;\n\tdev->setup_data.bRequestType = USB_RECIP_INTERFACE;\n\tdev->setup_data.wValue = cpu_to_le16(dev->cfg_data.cur_alt);\n\tdev->setup_data.wIndex = cpu_to_le16(dev->cfg_data.cur_intf);\n\t \n\t \n\treg = pch_udc_read_csr(dev, UDC_EP0OUT_IDX);\n\treg = (reg & ~UDC_CSR_NE_INTF_MASK) |\n\t      (dev->cfg_data.cur_intf << UDC_CSR_NE_INTF_SHIFT);\n\treg = (reg & ~UDC_CSR_NE_ALT_MASK) |\n\t      (dev->cfg_data.cur_alt << UDC_CSR_NE_ALT_SHIFT);\n\tpch_udc_write_csr(dev, reg, UDC_EP0OUT_IDX);\n\tfor (i = 0; i < PCH_UDC_USED_EP_NUM * 2; i++) {\n\t\t \n\t\tpch_udc_ep_clear_stall(&(dev->ep[i]));\n\t\tdev->ep[i].halted = 0;\n\t}\n\tdev->stall = 0;\n\tpch_udc_gadget_setup(dev);\n}\n\n \nstatic void pch_udc_svc_cfg_interrupt(struct pch_udc_dev *dev)\n{\n\tint i;\n\tu32 reg, dev_stat = 0;\n\n\tdev_stat = pch_udc_read_device_status(dev);\n\tdev->set_cfg_not_acked = 1;\n\tdev->cfg_data.cur_cfg = (dev_stat & UDC_DEVSTS_CFG_MASK) >>\n\t\t\t\tUDC_DEVSTS_CFG_SHIFT;\n\t \n\tmemset(&dev->setup_data, 0 , sizeof dev->setup_data);\n\tdev->setup_data.bRequest = USB_REQ_SET_CONFIGURATION;\n\tdev->setup_data.wValue = cpu_to_le16(dev->cfg_data.cur_cfg);\n\t \n\t \n\treg = pch_udc_read_csr(dev, UDC_EP0OUT_IDX);\n\treg = (reg & ~UDC_CSR_NE_CFG_MASK) |\n\t      (dev->cfg_data.cur_cfg << UDC_CSR_NE_CFG_SHIFT);\n\tpch_udc_write_csr(dev, reg, UDC_EP0OUT_IDX);\n\tfor (i = 0; i < PCH_UDC_USED_EP_NUM * 2; i++) {\n\t\t \n\t\tpch_udc_ep_clear_stall(&(dev->ep[i]));\n\t\tdev->ep[i].halted = 0;\n\t}\n\tdev->stall = 0;\n\n\t \n\tpch_udc_gadget_setup(dev);\n}\n\n \nstatic void pch_udc_dev_isr(struct pch_udc_dev *dev, u32 dev_intr)\n{\n\tint vbus;\n\n\t \n\tif (dev_intr & UDC_DEVINT_UR) {\n\t\tpch_udc_svc_ur_interrupt(dev);\n\t\tdev_dbg(&dev->pdev->dev, \"USB_RESET\\n\");\n\t}\n\t \n\tif (dev_intr & UDC_DEVINT_ENUM) {\n\t\tpch_udc_svc_enum_interrupt(dev);\n\t\tdev_dbg(&dev->pdev->dev, \"USB_ENUM\\n\");\n\t}\n\t \n\tif (dev_intr & UDC_DEVINT_SI)\n\t\tpch_udc_svc_intf_interrupt(dev);\n\t \n\tif (dev_intr & UDC_DEVINT_SC)\n\t\tpch_udc_svc_cfg_interrupt(dev);\n\t \n\tif (dev_intr & UDC_DEVINT_US) {\n\t\tif (dev->driver\n\t\t\t&& dev->driver->suspend) {\n\t\t\tspin_unlock(&dev->lock);\n\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\tspin_lock(&dev->lock);\n\t\t}\n\n\t\tvbus = pch_vbus_gpio_get_value(dev);\n\t\tif ((dev->vbus_session == 0)\n\t\t\t&& (vbus != 1)) {\n\t\t\tif (dev->driver && dev->driver->disconnect) {\n\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\tdev->driver->disconnect(&dev->gadget);\n\t\t\t\tspin_lock(&dev->lock);\n\t\t\t}\n\t\t\tpch_udc_reconnect(dev);\n\t\t} else if ((dev->vbus_session == 0)\n\t\t\t&& (vbus == 1)\n\t\t\t&& !dev->vbus_gpio.intr)\n\t\t\tschedule_work(&dev->vbus_gpio.irq_work_fall);\n\n\t\tdev_dbg(&dev->pdev->dev, \"USB_SUSPEND\\n\");\n\t}\n\t \n\tif (dev_intr & UDC_DEVINT_SOF)\n\t\tdev_dbg(&dev->pdev->dev, \"SOF\\n\");\n\t \n\tif (dev_intr & UDC_DEVINT_ES)\n\t\tdev_dbg(&dev->pdev->dev, \"ES\\n\");\n\t \n\tif (dev_intr & UDC_DEVINT_RWKP)\n\t\tdev_dbg(&dev->pdev->dev, \"RWKP\\n\");\n}\n\n \nstatic irqreturn_t pch_udc_isr(int irq, void *pdev)\n{\n\tstruct pch_udc_dev *dev = (struct pch_udc_dev *) pdev;\n\tu32 dev_intr, ep_intr;\n\tint i;\n\n\tdev_intr = pch_udc_read_device_interrupts(dev);\n\tep_intr = pch_udc_read_ep_interrupts(dev);\n\n\t \n\tif (dev_intr == ep_intr)\n\t\tif (dev_intr == pch_udc_readl(dev, UDC_DEVCFG_ADDR)) {\n\t\t\tdev_dbg(&dev->pdev->dev, \"UDC: Hung up\\n\");\n\t\t\t \n\t\t\tpch_udc_writel(dev, UDC_SRST, UDC_SRST_ADDR);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\tif (dev_intr)\n\t\t \n\t\tpch_udc_write_device_interrupts(dev, dev_intr);\n\tif (ep_intr)\n\t\t \n\t\tpch_udc_write_ep_interrupts(dev, ep_intr);\n\tif (!dev_intr && !ep_intr)\n\t\treturn IRQ_NONE;\n\tspin_lock(&dev->lock);\n\tif (dev_intr)\n\t\tpch_udc_dev_isr(dev, dev_intr);\n\tif (ep_intr) {\n\t\tpch_udc_read_all_epstatus(dev, ep_intr);\n\t\t \n\t\tif (ep_intr & UDC_EPINT_IN_EP0) {\n\t\t\tpch_udc_svc_control_in(dev);\n\t\t\tpch_udc_postsvc_epinters(dev, 0);\n\t\t}\n\t\t \n\t\tif (ep_intr & UDC_EPINT_OUT_EP0)\n\t\t\tpch_udc_svc_control_out(dev);\n\t\t \n\t\tfor (i = 1; i < PCH_UDC_USED_EP_NUM; i++) {\n\t\t\tif (ep_intr & (1 <<  i)) {\n\t\t\t\tpch_udc_svc_data_in(dev, i);\n\t\t\t\tpch_udc_postsvc_epinters(dev, i);\n\t\t\t}\n\t\t}\n\t\t \n\t\tfor (i = UDC_EPINT_OUT_SHIFT + 1; i < (UDC_EPINT_OUT_SHIFT +\n\t\t\t\t\t\t PCH_UDC_USED_EP_NUM); i++)\n\t\t\tif (ep_intr & (1 <<  i))\n\t\t\t\tpch_udc_svc_data_out(dev, i -\n\t\t\t\t\t\t\t UDC_EPINT_OUT_SHIFT);\n\t}\n\tspin_unlock(&dev->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void pch_udc_setup_ep0(struct pch_udc_dev *dev)\n{\n\t \n\tpch_udc_enable_ep_interrupts(dev, UDC_EPINT_IN_EP0 |\n\t\t\t\t\t\tUDC_EPINT_OUT_EP0);\n\t \n\tpch_udc_enable_interrupts(dev, UDC_DEVINT_UR | UDC_DEVINT_US |\n\t\t\t\t       UDC_DEVINT_ES | UDC_DEVINT_ENUM |\n\t\t\t\t       UDC_DEVINT_SI | UDC_DEVINT_SC);\n}\n\n \nstatic void pch_udc_pcd_reinit(struct pch_udc_dev *dev)\n{\n\tconst char *const ep_string[] = {\n\t\tep0_string, \"ep0out\", \"ep1in\", \"ep1out\", \"ep2in\", \"ep2out\",\n\t\t\"ep3in\", \"ep3out\", \"ep4in\", \"ep4out\", \"ep5in\", \"ep5out\",\n\t\t\"ep6in\", \"ep6out\", \"ep7in\", \"ep7out\", \"ep8in\", \"ep8out\",\n\t\t\"ep9in\", \"ep9out\", \"ep10in\", \"ep10out\", \"ep11in\", \"ep11out\",\n\t\t\"ep12in\", \"ep12out\", \"ep13in\", \"ep13out\", \"ep14in\", \"ep14out\",\n\t\t\"ep15in\", \"ep15out\",\n\t};\n\tint i;\n\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\n\t \n\tmemset(dev->ep, 0, sizeof dev->ep);\n\tfor (i = 0; i < PCH_UDC_EP_NUM; i++) {\n\t\tstruct pch_udc_ep *ep = &dev->ep[i];\n\t\tep->dev = dev;\n\t\tep->halted = 1;\n\t\tep->num = i / 2;\n\t\tep->in = ~i & 1;\n\t\tep->ep.name = ep_string[i];\n\t\tep->ep.ops = &pch_udc_ep_ops;\n\t\tif (ep->in) {\n\t\t\tep->offset_addr = ep->num * UDC_EP_REG_SHIFT;\n\t\t\tep->ep.caps.dir_in = true;\n\t\t} else {\n\t\t\tep->offset_addr = (UDC_EPINT_OUT_SHIFT + ep->num) *\n\t\t\t\t\t  UDC_EP_REG_SHIFT;\n\t\t\tep->ep.caps.dir_out = true;\n\t\t}\n\t\tif (i == UDC_EP0IN_IDX || i == UDC_EP0OUT_IDX) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\t\t \n\t\tusb_ep_set_maxpacket_limit(&ep->ep, UDC_BULK_MAX_PKT_SIZE);\n\t\tlist_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0IN_IDX].ep, UDC_EP0IN_MAX_PKT_SIZE);\n\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0OUT_IDX].ep, UDC_EP0OUT_MAX_PKT_SIZE);\n\n\t \n\tlist_del_init(&dev->ep[UDC_EP0IN_IDX].ep.ep_list);\n\tlist_del_init(&dev->ep[UDC_EP0OUT_IDX].ep.ep_list);\n\n\tdev->gadget.ep0 = &dev->ep[UDC_EP0IN_IDX].ep;\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n}\n\n \nstatic int pch_udc_pcd_init(struct pch_udc_dev *dev)\n{\n\tint ret;\n\n\tpch_udc_init(dev);\n\tpch_udc_pcd_reinit(dev);\n\n\tret = pch_vbus_gpio_init(dev);\n\tif (ret)\n\t\tpch_udc_exit(dev);\n\treturn ret;\n}\n\n \nstatic int init_dma_pools(struct pch_udc_dev *dev)\n{\n\tstruct pch_udc_stp_dma_desc\t*td_stp;\n\tstruct pch_udc_data_dma_desc\t*td_data;\n\tvoid\t\t\t\t*ep0out_buf;\n\n\t \n\tdev->data_requests = dma_pool_create(\"data_requests\", &dev->pdev->dev,\n\t\tsizeof(struct pch_udc_data_dma_desc), 0, 0);\n\tif (!dev->data_requests) {\n\t\tdev_err(&dev->pdev->dev, \"%s: can't get request data pool\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev->stp_requests = dma_pool_create(\"setup requests\", &dev->pdev->dev,\n\t\tsizeof(struct pch_udc_stp_dma_desc), 0, 0);\n\tif (!dev->stp_requests) {\n\t\tdev_err(&dev->pdev->dev, \"%s: can't get setup request pool\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\t \n\ttd_stp = dma_pool_alloc(dev->stp_requests, GFP_KERNEL,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IDX].td_stp_phys);\n\tif (!td_stp) {\n\t\tdev_err(&dev->pdev->dev,\n\t\t\t\"%s: can't allocate setup dma descriptor\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdev->ep[UDC_EP0OUT_IDX].td_stp = td_stp;\n\n\t \n\ttd_data = dma_pool_alloc(dev->data_requests, GFP_KERNEL,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IDX].td_data_phys);\n\tif (!td_data) {\n\t\tdev_err(&dev->pdev->dev,\n\t\t\t\"%s: can't allocate data dma descriptor\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdev->ep[UDC_EP0OUT_IDX].td_data = td_data;\n\tdev->ep[UDC_EP0IN_IDX].td_stp = NULL;\n\tdev->ep[UDC_EP0IN_IDX].td_stp_phys = 0;\n\tdev->ep[UDC_EP0IN_IDX].td_data = NULL;\n\tdev->ep[UDC_EP0IN_IDX].td_data_phys = 0;\n\n\tep0out_buf = devm_kzalloc(&dev->pdev->dev, UDC_EP0OUT_BUFF_SIZE * 4,\n\t\t\t\t  GFP_KERNEL);\n\tif (!ep0out_buf)\n\t\treturn -ENOMEM;\n\tdev->dma_addr = dma_map_single(&dev->pdev->dev, ep0out_buf,\n\t\t\t\t       UDC_EP0OUT_BUFF_SIZE * 4,\n\t\t\t\t       DMA_FROM_DEVICE);\n\treturn dma_mapping_error(&dev->pdev->dev, dev->dma_addr);\n}\n\nstatic int pch_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct pch_udc_dev\t*dev = to_pch_udc(g);\n\n\tdev->driver = driver;\n\n\t \n\tpch_udc_setup_ep0(dev);\n\n\t \n\tif ((pch_vbus_gpio_get_value(dev) != 0) || !dev->vbus_gpio.intr)\n\t\tpch_udc_clear_disconnect(dev);\n\n\tdev->connected = 1;\n\treturn 0;\n}\n\nstatic int pch_udc_stop(struct usb_gadget *g)\n{\n\tstruct pch_udc_dev\t*dev = to_pch_udc(g);\n\n\tpch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\n\n\t \n\tdev->driver = NULL;\n\tdev->connected = 0;\n\n\t \n\tpch_udc_set_disconnect(dev);\n\n\treturn 0;\n}\n\nstatic void pch_vbus_gpio_remove_table(void *table)\n{\n\tgpiod_remove_lookup_table(table);\n}\n\nstatic int pch_vbus_gpio_add_table(struct device *d, void *table)\n{\n\tgpiod_add_lookup_table(table);\n\treturn devm_add_action_or_reset(d, pch_vbus_gpio_remove_table, table);\n}\n\nstatic struct gpiod_lookup_table pch_udc_minnow_vbus_gpio_table = {\n\t.dev_id\t\t= \"0000:02:02.4\",\n\t.table\t\t= {\n\t\tGPIO_LOOKUP(\"sch_gpio.33158\", 12, NULL, GPIO_ACTIVE_HIGH),\n\t\t{}\n\t},\n};\n\nstatic int pch_udc_minnow_platform_init(struct device *d)\n{\n\treturn pch_vbus_gpio_add_table(d, &pch_udc_minnow_vbus_gpio_table);\n}\n\nstatic int pch_udc_quark_platform_init(struct device *d)\n{\n\tstruct pch_udc_dev *dev = dev_get_drvdata(d);\n\n\tdev->bar = PCH_UDC_PCI_BAR_QUARK_X1000;\n\treturn 0;\n}\n\nstatic void pch_udc_shutdown(struct pci_dev *pdev)\n{\n\tstruct pch_udc_dev *dev = pci_get_drvdata(pdev);\n\n\tpch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\n\tpch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\n\n\t \n\tpch_udc_set_disconnect(dev);\n}\n\nstatic void pch_udc_remove(struct pci_dev *pdev)\n{\n\tstruct pch_udc_dev\t*dev = pci_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&dev->gadget);\n\n\t \n\tif (dev->driver)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"%s: gadget driver still bound!!!\\n\", __func__);\n\t \n\tdma_pool_destroy(dev->data_requests);\n\n\tif (dev->stp_requests) {\n\t\t \n\t\tif (dev->ep[UDC_EP0OUT_IDX].td_stp) {\n\t\t\tdma_pool_free(dev->stp_requests,\n\t\t\t\tdev->ep[UDC_EP0OUT_IDX].td_stp,\n\t\t\t\tdev->ep[UDC_EP0OUT_IDX].td_stp_phys);\n\t\t}\n\t\tif (dev->ep[UDC_EP0OUT_IDX].td_data) {\n\t\t\tdma_pool_free(dev->stp_requests,\n\t\t\t\tdev->ep[UDC_EP0OUT_IDX].td_data,\n\t\t\t\tdev->ep[UDC_EP0OUT_IDX].td_data_phys);\n\t\t}\n\t\tdma_pool_destroy(dev->stp_requests);\n\t}\n\n\tif (dev->dma_addr)\n\t\tdma_unmap_single(&dev->pdev->dev, dev->dma_addr,\n\t\t\t\t UDC_EP0OUT_BUFF_SIZE * 4, DMA_FROM_DEVICE);\n\n\tpch_vbus_gpio_free(dev);\n\n\tpch_udc_exit(dev);\n}\n\nstatic int __maybe_unused pch_udc_suspend(struct device *d)\n{\n\tstruct pch_udc_dev *dev = dev_get_drvdata(d);\n\n\tpch_udc_disable_interrupts(dev, UDC_DEVINT_MSK);\n\tpch_udc_disable_ep_interrupts(dev, UDC_EPINT_MSK_DISABLE_ALL);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused pch_udc_resume(struct device *d)\n{\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(pch_udc_pm, pch_udc_suspend, pch_udc_resume);\n\ntypedef int (*platform_init_fn)(struct device *);\n\nstatic int pch_udc_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tplatform_init_fn platform_init = (platform_init_fn)id->driver_data;\n\tint\t\t\tretval;\n\tstruct pch_udc_dev\t*dev;\n\n\t \n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\t \n\tretval = pcim_enable_device(pdev);\n\tif (retval)\n\t\treturn retval;\n\n\tdev->bar = PCH_UDC_PCI_BAR;\n\tdev->pdev = pdev;\n\tpci_set_drvdata(pdev, dev);\n\n\t \n\tif (platform_init) {\n\t\tretval = platform_init(&pdev->dev);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tretval = pcim_iomap_regions(pdev, BIT(dev->bar), pci_name(pdev));\n\tif (retval)\n\t\treturn retval;\n\n\tdev->base_addr = pcim_iomap_table(pdev)[dev->bar];\n\n\t \n\tretval = pch_udc_pcd_init(dev);\n\tif (retval)\n\t\treturn retval;\n\n\tpci_enable_msi(pdev);\n\n\tretval = devm_request_irq(&pdev->dev, pdev->irq, pch_udc_isr,\n\t\t\t\t  IRQF_SHARED, KBUILD_MODNAME, dev);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"%s: request_irq(%d) fail\\n\", __func__,\n\t\t\tpdev->irq);\n\t\tgoto finished;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\t \n\tspin_lock_init(&dev->lock);\n\tdev->gadget.ops = &pch_udc_ops;\n\n\tretval = init_dma_pools(dev);\n\tif (retval)\n\t\tgoto finished;\n\n\tdev->gadget.name = KBUILD_MODNAME;\n\tdev->gadget.max_speed = USB_SPEED_HIGH;\n\n\t \n\tpch_udc_set_disconnect(dev);\n\tretval = usb_add_gadget_udc(&pdev->dev, &dev->gadget);\n\tif (retval)\n\t\tgoto finished;\n\treturn 0;\n\nfinished:\n\tpch_udc_remove(pdev);\n\treturn retval;\n}\n\nstatic const struct pci_device_id pch_udc_pcidev_id[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_QUARK_X1000_UDC),\n\t\t.class = PCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask = 0xffffffff,\n\t\t.driver_data = (kernel_ulong_t)&pch_udc_quark_platform_init,\n\t},\n\t{\n\t\tPCI_DEVICE_SUB(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EG20T_UDC,\n\t\t\t       PCI_VENDOR_ID_CIRCUITCO, PCI_SUBSYSTEM_ID_CIRCUITCO_MINNOWBOARD),\n\t\t.class = PCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask = 0xffffffff,\n\t\t.driver_data = (kernel_ulong_t)&pch_udc_minnow_platform_init,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_EG20T_UDC),\n\t\t.class = PCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask = 0xffffffff,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ROHM, PCI_DEVICE_ID_ML7213_IOH_UDC),\n\t\t.class = PCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask = 0xffffffff,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ROHM, PCI_DEVICE_ID_ML7831_IOH_UDC),\n\t\t.class = PCI_CLASS_SERIAL_USB_DEVICE,\n\t\t.class_mask = 0xffffffff,\n\t},\n\t{ 0 },\n};\n\nMODULE_DEVICE_TABLE(pci, pch_udc_pcidev_id);\n\nstatic struct pci_driver pch_udc_driver = {\n\t.name =\tKBUILD_MODNAME,\n\t.id_table =\tpch_udc_pcidev_id,\n\t.probe =\tpch_udc_probe,\n\t.remove =\tpch_udc_remove,\n\t.shutdown =\tpch_udc_shutdown,\n\t.driver = {\n\t\t.pm = &pch_udc_pm,\n\t},\n};\n\nmodule_pci_driver(pch_udc_driver);\n\nMODULE_DESCRIPTION(\"Intel EG20T USB Device Controller\");\nMODULE_AUTHOR(\"LAPIS Semiconductor, <tomoya-linux@dsn.lapis-semi.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}