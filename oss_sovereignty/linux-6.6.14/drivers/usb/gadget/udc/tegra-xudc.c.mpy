{
  "module_name": "tegra-xudc.c",
  "hash_id": "9b3b8ffe1b0cb2536baa05c366830520662f17ad53f25d9a278bb8ebade329f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/tegra-xudc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/tegra/xusb.h>\n#include <linux/pm_domain.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/role.h>\n#include <linux/usb/phy.h>\n#include <linux/workqueue.h>\n\n \n#define DB 0x004\n#define  DB_TARGET_MASK GENMASK(15, 8)\n#define  DB_TARGET(x) (((x) << 8) & DB_TARGET_MASK)\n#define  DB_STREAMID_MASK GENMASK(31, 16)\n#define  DB_STREAMID(x) (((x) << 16) & DB_STREAMID_MASK)\n#define ERSTSZ 0x008\n#define  ERSTSZ_ERSTXSZ_SHIFT(x) ((x) * 16)\n#define  ERSTSZ_ERSTXSZ_MASK GENMASK(15, 0)\n#define ERSTXBALO(x) (0x010 + 8 * (x))\n#define ERSTXBAHI(x) (0x014 + 8 * (x))\n#define ERDPLO 0x020\n#define  ERDPLO_EHB BIT(3)\n#define ERDPHI 0x024\n#define EREPLO 0x028\n#define  EREPLO_ECS BIT(0)\n#define  EREPLO_SEGI BIT(1)\n#define EREPHI 0x02c\n#define CTRL 0x030\n#define  CTRL_RUN BIT(0)\n#define  CTRL_LSE BIT(1)\n#define  CTRL_IE BIT(4)\n#define  CTRL_SMI_EVT BIT(5)\n#define  CTRL_SMI_DSE BIT(6)\n#define  CTRL_EWE BIT(7)\n#define  CTRL_DEVADDR_MASK GENMASK(30, 24)\n#define  CTRL_DEVADDR(x) (((x) << 24) & CTRL_DEVADDR_MASK)\n#define  CTRL_ENABLE BIT(31)\n#define ST 0x034\n#define  ST_RC BIT(0)\n#define  ST_IP BIT(4)\n#define RT_IMOD\t0x038\n#define  RT_IMOD_IMODI_MASK GENMASK(15, 0)\n#define  RT_IMOD_IMODI(x) ((x) & RT_IMOD_IMODI_MASK)\n#define  RT_IMOD_IMODC_MASK GENMASK(31, 16)\n#define  RT_IMOD_IMODC(x) (((x) << 16) & RT_IMOD_IMODC_MASK)\n#define PORTSC 0x03c\n#define  PORTSC_CCS BIT(0)\n#define  PORTSC_PED BIT(1)\n#define  PORTSC_PR BIT(4)\n#define  PORTSC_PLS_SHIFT 5\n#define  PORTSC_PLS_MASK GENMASK(8, 5)\n#define  PORTSC_PLS_U0 0x0\n#define  PORTSC_PLS_U2 0x2\n#define  PORTSC_PLS_U3 0x3\n#define  PORTSC_PLS_DISABLED 0x4\n#define  PORTSC_PLS_RXDETECT 0x5\n#define  PORTSC_PLS_INACTIVE 0x6\n#define  PORTSC_PLS_RESUME 0xf\n#define  PORTSC_PLS(x) (((x) << PORTSC_PLS_SHIFT) & PORTSC_PLS_MASK)\n#define  PORTSC_PS_SHIFT 10\n#define  PORTSC_PS_MASK GENMASK(13, 10)\n#define  PORTSC_PS_UNDEFINED 0x0\n#define  PORTSC_PS_FS 0x1\n#define  PORTSC_PS_LS 0x2\n#define  PORTSC_PS_HS 0x3\n#define  PORTSC_PS_SS 0x4\n#define  PORTSC_LWS BIT(16)\n#define  PORTSC_CSC BIT(17)\n#define  PORTSC_WRC BIT(19)\n#define  PORTSC_PRC BIT(21)\n#define  PORTSC_PLC BIT(22)\n#define  PORTSC_CEC BIT(23)\n#define  PORTSC_WPR BIT(30)\n#define  PORTSC_CHANGE_MASK (PORTSC_CSC | PORTSC_WRC | PORTSC_PRC | \\\n\t\t\t     PORTSC_PLC | PORTSC_CEC)\n#define ECPLO 0x040\n#define ECPHI 0x044\n#define MFINDEX 0x048\n#define  MFINDEX_FRAME_SHIFT 3\n#define  MFINDEX_FRAME_MASK GENMASK(13, 3)\n#define PORTPM 0x04c\n#define  PORTPM_L1S_MASK GENMASK(1, 0)\n#define  PORTPM_L1S_DROP 0x0\n#define  PORTPM_L1S_ACCEPT 0x1\n#define  PORTPM_L1S_NYET 0x2\n#define  PORTPM_L1S_STALL 0x3\n#define  PORTPM_L1S(x) ((x) & PORTPM_L1S_MASK)\n#define  PORTPM_RWE BIT(3)\n#define  PORTPM_U2TIMEOUT_MASK GENMASK(15, 8)\n#define  PORTPM_U1TIMEOUT_MASK GENMASK(23, 16)\n#define  PORTPM_FLA BIT(24)\n#define  PORTPM_VBA BIT(25)\n#define  PORTPM_WOC BIT(26)\n#define  PORTPM_WOD BIT(27)\n#define  PORTPM_U1E BIT(28)\n#define  PORTPM_U2E BIT(29)\n#define  PORTPM_FRWE BIT(30)\n#define  PORTPM_PNG_CYA BIT(31)\n#define EP_HALT 0x050\n#define EP_PAUSE 0x054\n#define EP_RELOAD 0x058\n#define EP_STCHG 0x05c\n#define DEVNOTIF_LO 0x064\n#define  DEVNOTIF_LO_TRIG BIT(0)\n#define  DEVNOTIF_LO_TYPE_MASK GENMASK(7, 4)\n#define  DEVNOTIF_LO_TYPE(x) (((x) << 4)  & DEVNOTIF_LO_TYPE_MASK)\n#define  DEVNOTIF_LO_TYPE_FUNCTION_WAKE 0x1\n#define DEVNOTIF_HI 0x068\n#define PORTHALT 0x06c\n#define  PORTHALT_HALT_LTSSM BIT(0)\n#define  PORTHALT_HALT_REJECT BIT(1)\n#define  PORTHALT_STCHG_REQ BIT(20)\n#define  PORTHALT_STCHG_INTR_EN BIT(24)\n#define PORT_TM\t0x070\n#define EP_THREAD_ACTIVE 0x074\n#define EP_STOPPED 0x078\n#define HSFSPI_COUNT0 0x100\n#define HSFSPI_COUNT13 0x134\n#define  HSFSPI_COUNT13_U2_RESUME_K_DURATION_MASK GENMASK(29, 0)\n#define  HSFSPI_COUNT13_U2_RESUME_K_DURATION(x) ((x) & \\\n\t\t\t\tHSFSPI_COUNT13_U2_RESUME_K_DURATION_MASK)\n#define BLCG 0x840\n#define SSPX_CORE_CNT0 0x610\n#define  SSPX_CORE_CNT0_PING_TBURST_MASK GENMASK(7, 0)\n#define  SSPX_CORE_CNT0_PING_TBURST(x) ((x) & SSPX_CORE_CNT0_PING_TBURST_MASK)\n#define SSPX_CORE_CNT30 0x688\n#define  SSPX_CORE_CNT30_LMPITP_TIMER_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT30_LMPITP_TIMER(x) ((x) & \\\n\t\t\t\t\tSSPX_CORE_CNT30_LMPITP_TIMER_MASK)\n#define SSPX_CORE_CNT32 0x690\n#define  SSPX_CORE_CNT32_POLL_TBURST_MAX_MASK GENMASK(7, 0)\n#define  SSPX_CORE_CNT32_POLL_TBURST_MAX(x) ((x) & \\\n\t\t\t\t\tSSPX_CORE_CNT32_POLL_TBURST_MAX_MASK)\n#define SSPX_CORE_CNT56 0x6fc\n#define  SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX_MASK)\n#define SSPX_CORE_CNT57 0x700\n#define  SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX_MASK)\n#define SSPX_CORE_CNT65 0x720\n#define  SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT65_TX_SCD_END_TRPT_MID_MASK)\n#define SSPX_CORE_CNT66 0x724\n#define  SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID_MASK)\n#define SSPX_CORE_CNT67 0x728\n#define  SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID_MASK)\n#define SSPX_CORE_CNT72 0x73c\n#define  SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT_MASK GENMASK(19, 0)\n#define  SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT(x) ((x) & \\\n\t\t\t\tSSPX_CORE_CNT72_SCD_LFPS_TIMEOUT_MASK)\n#define SSPX_CORE_PADCTL4 0x750\n#define  SSPX_CORE_PADCTL4_RXDAT_VLD_TIMEOUT_U3_MASK GENMASK(19, 0)\n#define  SSPX_CORE_PADCTL4_RXDAT_VLD_TIMEOUT_U3(x) ((x) & \\\n\t\t\t\tSSPX_CORE_PADCTL4_RXDAT_VLD_TIMEOUT_U3_MASK)\n#define  BLCG_DFPCI BIT(0)\n#define  BLCG_UFPCI BIT(1)\n#define  BLCG_FE BIT(2)\n#define  BLCG_COREPLL_PWRDN BIT(8)\n#define  BLCG_IOPLL_0_PWRDN BIT(9)\n#define  BLCG_IOPLL_1_PWRDN BIT(10)\n#define  BLCG_IOPLL_2_PWRDN BIT(11)\n#define  BLCG_ALL 0x1ff\n#define CFG_DEV_SSPI_XFER 0x858\n#define  CFG_DEV_SSPI_XFER_ACKTIMEOUT_MASK GENMASK(31, 0)\n#define  CFG_DEV_SSPI_XFER_ACKTIMEOUT(x) ((x) & \\\n\t\t\t\t\tCFG_DEV_SSPI_XFER_ACKTIMEOUT_MASK)\n#define CFG_DEV_FE 0x85c\n#define  CFG_DEV_FE_PORTREGSEL_MASK GENMASK(1, 0)\n#define  CFG_DEV_FE_PORTREGSEL_SS_PI 1\n#define  CFG_DEV_FE_PORTREGSEL_HSFS_PI 2\n#define  CFG_DEV_FE_PORTREGSEL(x) ((x) & CFG_DEV_FE_PORTREGSEL_MASK)\n#define  CFG_DEV_FE_INFINITE_SS_RETRY BIT(29)\n\n \n#define XUSB_DEV_CFG_1 0x004\n#define  XUSB_DEV_CFG_1_IO_SPACE_EN BIT(0)\n#define  XUSB_DEV_CFG_1_MEMORY_SPACE_EN BIT(1)\n#define  XUSB_DEV_CFG_1_BUS_MASTER_EN BIT(2)\n#define XUSB_DEV_CFG_4 0x010\n#define  XUSB_DEV_CFG_4_BASE_ADDR_MASK GENMASK(31, 15)\n#define XUSB_DEV_CFG_5 0x014\n\n \n#define XUSB_DEV_CONFIGURATION_0 0x180\n#define  XUSB_DEV_CONFIGURATION_0_EN_FPCI BIT(0)\n#define XUSB_DEV_INTR_MASK_0 0x188\n#define  XUSB_DEV_INTR_MASK_0_IP_INT_MASK BIT(16)\n\nstruct tegra_xudc_ep_context {\n\t__le32 info0;\n\t__le32 info1;\n\t__le32 deq_lo;\n\t__le32 deq_hi;\n\t__le32 tx_info;\n\t__le32 rsvd[11];\n};\n\n#define EP_STATE_DISABLED 0\n#define EP_STATE_RUNNING 1\n#define EP_STATE_HALTED 2\n#define EP_STATE_STOPPED 3\n#define EP_STATE_ERROR 4\n\n#define EP_TYPE_INVALID 0\n#define EP_TYPE_ISOCH_OUT 1\n#define EP_TYPE_BULK_OUT 2\n#define EP_TYPE_INTERRUPT_OUT 3\n#define EP_TYPE_CONTROL 4\n#define EP_TYPE_ISCOH_IN 5\n#define EP_TYPE_BULK_IN 6\n#define EP_TYPE_INTERRUPT_IN 7\n\n#define BUILD_EP_CONTEXT_RW(name, member, shift, mask)\t\t\t\\\nstatic inline u32 ep_ctx_read_##name(struct tegra_xudc_ep_context *ctx)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (le32_to_cpu(ctx->member) >> (shift)) & (mask);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\nep_ctx_write_##name(struct tegra_xudc_ep_context *ctx, u32 val)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 tmp;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttmp = le32_to_cpu(ctx->member) & ~((mask) << (shift));\t\t\\\n\ttmp |= (val & (mask)) << (shift);\t\t\t\t\\\n\tctx->member = cpu_to_le32(tmp);\t\t\t\t\t\\\n}\n\nBUILD_EP_CONTEXT_RW(state, info0, 0, 0x7)\nBUILD_EP_CONTEXT_RW(mult, info0, 8, 0x3)\nBUILD_EP_CONTEXT_RW(max_pstreams, info0, 10, 0x1f)\nBUILD_EP_CONTEXT_RW(lsa, info0, 15, 0x1)\nBUILD_EP_CONTEXT_RW(interval, info0, 16, 0xff)\nBUILD_EP_CONTEXT_RW(cerr, info1, 1, 0x3)\nBUILD_EP_CONTEXT_RW(type, info1, 3, 0x7)\nBUILD_EP_CONTEXT_RW(hid, info1, 7, 0x1)\nBUILD_EP_CONTEXT_RW(max_burst_size, info1, 8, 0xff)\nBUILD_EP_CONTEXT_RW(max_packet_size, info1, 16, 0xffff)\nBUILD_EP_CONTEXT_RW(dcs, deq_lo, 0, 0x1)\nBUILD_EP_CONTEXT_RW(deq_lo, deq_lo, 4, 0xfffffff)\nBUILD_EP_CONTEXT_RW(deq_hi, deq_hi, 0, 0xffffffff)\nBUILD_EP_CONTEXT_RW(avg_trb_len, tx_info, 0, 0xffff)\nBUILD_EP_CONTEXT_RW(max_esit_payload, tx_info, 16, 0xffff)\nBUILD_EP_CONTEXT_RW(edtla, rsvd[0], 0, 0xffffff)\nBUILD_EP_CONTEXT_RW(rsvd, rsvd[0], 24, 0x1)\nBUILD_EP_CONTEXT_RW(partial_td, rsvd[0], 25, 0x1)\nBUILD_EP_CONTEXT_RW(splitxstate, rsvd[0], 26, 0x1)\nBUILD_EP_CONTEXT_RW(seq_num, rsvd[0], 27, 0x1f)\nBUILD_EP_CONTEXT_RW(cerrcnt, rsvd[1], 18, 0x3)\nBUILD_EP_CONTEXT_RW(data_offset, rsvd[2], 0, 0x1ffff)\nBUILD_EP_CONTEXT_RW(numtrbs, rsvd[2], 22, 0x1f)\nBUILD_EP_CONTEXT_RW(devaddr, rsvd[6], 0, 0x7f)\n\nstatic inline u64 ep_ctx_read_deq_ptr(struct tegra_xudc_ep_context *ctx)\n{\n\treturn ((u64)ep_ctx_read_deq_hi(ctx) << 32) |\n\t\t(ep_ctx_read_deq_lo(ctx) << 4);\n}\n\nstatic inline void\nep_ctx_write_deq_ptr(struct tegra_xudc_ep_context *ctx, u64 addr)\n{\n\tep_ctx_write_deq_lo(ctx, lower_32_bits(addr) >> 4);\n\tep_ctx_write_deq_hi(ctx, upper_32_bits(addr));\n}\n\nstruct tegra_xudc_trb {\n\t__le32 data_lo;\n\t__le32 data_hi;\n\t__le32 status;\n\t__le32 control;\n};\n\n#define TRB_TYPE_RSVD 0\n#define TRB_TYPE_NORMAL 1\n#define TRB_TYPE_SETUP_STAGE 2\n#define TRB_TYPE_DATA_STAGE 3\n#define TRB_TYPE_STATUS_STAGE 4\n#define TRB_TYPE_ISOCH 5\n#define TRB_TYPE_LINK 6\n#define TRB_TYPE_TRANSFER_EVENT 32\n#define TRB_TYPE_PORT_STATUS_CHANGE_EVENT 34\n#define TRB_TYPE_STREAM 48\n#define TRB_TYPE_SETUP_PACKET_EVENT 63\n\n#define TRB_CMPL_CODE_INVALID 0\n#define TRB_CMPL_CODE_SUCCESS 1\n#define TRB_CMPL_CODE_DATA_BUFFER_ERR 2\n#define TRB_CMPL_CODE_BABBLE_DETECTED_ERR 3\n#define TRB_CMPL_CODE_USB_TRANS_ERR 4\n#define TRB_CMPL_CODE_TRB_ERR 5\n#define TRB_CMPL_CODE_STALL 6\n#define TRB_CMPL_CODE_INVALID_STREAM_TYPE_ERR 10\n#define TRB_CMPL_CODE_SHORT_PACKET 13\n#define TRB_CMPL_CODE_RING_UNDERRUN 14\n#define TRB_CMPL_CODE_RING_OVERRUN 15\n#define TRB_CMPL_CODE_EVENT_RING_FULL_ERR 21\n#define TRB_CMPL_CODE_STOPPED 26\n#define TRB_CMPL_CODE_ISOCH_BUFFER_OVERRUN 31\n#define TRB_CMPL_CODE_STREAM_NUMP_ERROR 219\n#define TRB_CMPL_CODE_PRIME_PIPE_RECEIVED 220\n#define TRB_CMPL_CODE_HOST_REJECTED 221\n#define TRB_CMPL_CODE_CTRL_DIR_ERR 222\n#define TRB_CMPL_CODE_CTRL_SEQNUM_ERR 223\n\n#define BUILD_TRB_RW(name, member, shift, mask)\t\t\t\t\\\nstatic inline u32 trb_read_##name(struct tegra_xudc_trb *trb)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\treturn (le32_to_cpu(trb->member) >> (shift)) & (mask);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic inline void\t\t\t\t\t\t\t\\\ntrb_write_##name(struct tegra_xudc_trb *trb, u32 val)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tu32 tmp;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\ttmp = le32_to_cpu(trb->member) & ~((mask) << (shift));\t\t\\\n\ttmp |= (val & (mask)) << (shift);\t\t\t\t\\\n\ttrb->member = cpu_to_le32(tmp);\t\t\t\t\t\\\n}\n\nBUILD_TRB_RW(data_lo, data_lo, 0, 0xffffffff)\nBUILD_TRB_RW(data_hi, data_hi, 0, 0xffffffff)\nBUILD_TRB_RW(seq_num, status, 0, 0xffff)\nBUILD_TRB_RW(transfer_len, status, 0, 0xffffff)\nBUILD_TRB_RW(td_size, status, 17, 0x1f)\nBUILD_TRB_RW(cmpl_code, status, 24, 0xff)\nBUILD_TRB_RW(cycle, control, 0, 0x1)\nBUILD_TRB_RW(toggle_cycle, control, 1, 0x1)\nBUILD_TRB_RW(isp, control, 2, 0x1)\nBUILD_TRB_RW(chain, control, 4, 0x1)\nBUILD_TRB_RW(ioc, control, 5, 0x1)\nBUILD_TRB_RW(type, control, 10, 0x3f)\nBUILD_TRB_RW(stream_id, control, 16, 0xffff)\nBUILD_TRB_RW(endpoint_id, control, 16, 0x1f)\nBUILD_TRB_RW(tlbpc, control, 16, 0xf)\nBUILD_TRB_RW(data_stage_dir, control, 16, 0x1)\nBUILD_TRB_RW(frame_id, control, 20, 0x7ff)\nBUILD_TRB_RW(sia, control, 31, 0x1)\n\nstatic inline u64 trb_read_data_ptr(struct tegra_xudc_trb *trb)\n{\n\treturn ((u64)trb_read_data_hi(trb) << 32) |\n\t\ttrb_read_data_lo(trb);\n}\n\nstatic inline void trb_write_data_ptr(struct tegra_xudc_trb *trb, u64 addr)\n{\n\ttrb_write_data_lo(trb, lower_32_bits(addr));\n\ttrb_write_data_hi(trb, upper_32_bits(addr));\n}\n\nstruct tegra_xudc_request {\n\tstruct usb_request usb_req;\n\n\tsize_t buf_queued;\n\tunsigned int trbs_queued;\n\tunsigned int trbs_needed;\n\tbool need_zlp;\n\n\tstruct tegra_xudc_trb *first_trb;\n\tstruct tegra_xudc_trb *last_trb;\n\n\tstruct list_head list;\n};\n\nstruct tegra_xudc_ep {\n\tstruct tegra_xudc *xudc;\n\tstruct usb_ep usb_ep;\n\tunsigned int index;\n\tchar name[8];\n\n\tstruct tegra_xudc_ep_context *context;\n\n#define XUDC_TRANSFER_RING_SIZE 64\n\tstruct tegra_xudc_trb *transfer_ring;\n\tdma_addr_t transfer_ring_phys;\n\n\tunsigned int enq_ptr;\n\tunsigned int deq_ptr;\n\tbool pcs;\n\tbool ring_full;\n\tbool stream_rejected;\n\n\tstruct list_head queue;\n\tconst struct usb_endpoint_descriptor *desc;\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n};\n\nstruct tegra_xudc_sel_timing {\n\t__u8 u1sel;\n\t__u8 u1pel;\n\t__le16 u2sel;\n\t__le16 u2pel;\n};\n\nenum tegra_xudc_setup_state {\n\tWAIT_FOR_SETUP,\n\tDATA_STAGE_XFER,\n\tDATA_STAGE_RECV,\n\tSTATUS_STAGE_XFER,\n\tSTATUS_STAGE_RECV,\n};\n\nstruct tegra_xudc_setup_packet {\n\tstruct usb_ctrlrequest ctrl_req;\n\tunsigned int seq_num;\n};\n\nstruct tegra_xudc_save_regs {\n\tu32 ctrl;\n\tu32 portpm;\n};\n\nstruct tegra_xudc {\n\tstruct device *dev;\n\tconst struct tegra_xudc_soc *soc;\n\tstruct tegra_xusb_padctl *padctl;\n\n\tspinlock_t lock;\n\n\tstruct usb_gadget gadget;\n\tstruct usb_gadget_driver *driver;\n\n#define XUDC_NR_EVENT_RINGS 2\n#define XUDC_EVENT_RING_SIZE 4096\n\tstruct tegra_xudc_trb *event_ring[XUDC_NR_EVENT_RINGS];\n\tdma_addr_t event_ring_phys[XUDC_NR_EVENT_RINGS];\n\tunsigned int event_ring_index;\n\tunsigned int event_ring_deq_ptr;\n\tbool ccs;\n\n#define XUDC_NR_EPS 32\n\tstruct tegra_xudc_ep ep[XUDC_NR_EPS];\n\tstruct tegra_xudc_ep_context *ep_context;\n\tdma_addr_t ep_context_phys;\n\n\tstruct device *genpd_dev_device;\n\tstruct device *genpd_dev_ss;\n\tstruct device_link *genpd_dl_device;\n\tstruct device_link *genpd_dl_ss;\n\n\tstruct dma_pool *transfer_ring_pool;\n\n\tbool queued_setup_packet;\n\tstruct tegra_xudc_setup_packet setup_packet;\n\tenum tegra_xudc_setup_state setup_state;\n\tu16 setup_seq_num;\n\n\tu16 dev_addr;\n\tu16 isoch_delay;\n\tstruct tegra_xudc_sel_timing sel_timing;\n\tu8 test_mode_pattern;\n\tu16 status_buf;\n\tstruct tegra_xudc_request *ep0_req;\n\n\tbool pullup;\n\n\tunsigned int nr_enabled_eps;\n\tunsigned int nr_isoch_eps;\n\n\tunsigned int device_state;\n\tunsigned int resume_state;\n\n\tint irq;\n\n\tvoid __iomem *base;\n\tresource_size_t phys_base;\n\tvoid __iomem *ipfs;\n\tvoid __iomem *fpci;\n\n\tstruct regulator_bulk_data *supplies;\n\n\tstruct clk_bulk_data *clks;\n\n\tbool device_mode;\n\tstruct work_struct usb_role_sw_work;\n\n\tstruct phy **usb3_phy;\n\tstruct phy *curr_usb3_phy;\n\tstruct phy **utmi_phy;\n\tstruct phy *curr_utmi_phy;\n\n\tstruct tegra_xudc_save_regs saved_regs;\n\tbool suspended;\n\tbool powergated;\n\n\tstruct usb_phy **usbphy;\n\tstruct usb_phy *curr_usbphy;\n\tstruct notifier_block vbus_nb;\n\n\tstruct completion disconnect_complete;\n\n\tbool selfpowered;\n\n#define TOGGLE_VBUS_WAIT_MS 100\n\tstruct delayed_work plc_reset_work;\n\tbool wait_csc;\n\n\tstruct delayed_work port_reset_war_work;\n\tbool wait_for_sec_prc;\n};\n\n#define XUDC_TRB_MAX_BUFFER_SIZE 65536\n#define XUDC_MAX_ISOCH_EPS 4\n#define XUDC_INTERRUPT_MODERATION_US 0\n\nstatic struct usb_endpoint_descriptor tegra_xudc_ep0_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bEndpointAddress = 0,\n\t.bmAttributes = USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize = cpu_to_le16(64),\n};\n\nstruct tegra_xudc_soc {\n\tconst char * const *supply_names;\n\tunsigned int num_supplies;\n\tconst char * const *clock_names;\n\tunsigned int num_clks;\n\tunsigned int num_phys;\n\tbool u1_enable;\n\tbool u2_enable;\n\tbool lpm_enable;\n\tbool invalid_seq_num;\n\tbool pls_quirk;\n\tbool port_reset_quirk;\n\tbool port_speed_quirk;\n\tbool has_ipfs;\n};\n\nstatic inline u32 fpci_readl(struct tegra_xudc *xudc, unsigned int offset)\n{\n\treturn readl(xudc->fpci + offset);\n}\n\nstatic inline void fpci_writel(struct tegra_xudc *xudc, u32 val,\n\t\t\t       unsigned int offset)\n{\n\twritel(val, xudc->fpci + offset);\n}\n\nstatic inline u32 ipfs_readl(struct tegra_xudc *xudc, unsigned int offset)\n{\n\treturn readl(xudc->ipfs + offset);\n}\n\nstatic inline void ipfs_writel(struct tegra_xudc *xudc, u32 val,\n\t\t\t       unsigned int offset)\n{\n\twritel(val, xudc->ipfs + offset);\n}\n\nstatic inline u32 xudc_readl(struct tegra_xudc *xudc, unsigned int offset)\n{\n\treturn readl(xudc->base + offset);\n}\n\nstatic inline void xudc_writel(struct tegra_xudc *xudc, u32 val,\n\t\t\t       unsigned int offset)\n{\n\twritel(val, xudc->base + offset);\n}\n\nstatic inline int xudc_readl_poll(struct tegra_xudc *xudc,\n\t\t\t\t  unsigned int offset, u32 mask, u32 val)\n{\n\tu32 regval;\n\n\treturn readl_poll_timeout_atomic(xudc->base + offset, regval,\n\t\t\t\t\t (regval & mask) == val, 1, 100);\n}\n\nstatic inline struct tegra_xudc *to_xudc(struct usb_gadget *gadget)\n{\n\treturn container_of(gadget, struct tegra_xudc, gadget);\n}\n\nstatic inline struct tegra_xudc_ep *to_xudc_ep(struct usb_ep *ep)\n{\n\treturn container_of(ep, struct tegra_xudc_ep, usb_ep);\n}\n\nstatic inline struct tegra_xudc_request *to_xudc_req(struct usb_request *req)\n{\n\treturn container_of(req, struct tegra_xudc_request, usb_req);\n}\n\nstatic inline void dump_trb(struct tegra_xudc *xudc, const char *type,\n\t\t\t    struct tegra_xudc_trb *trb)\n{\n\tdev_dbg(xudc->dev,\n\t\t\"%s: %p, lo = %#x, hi = %#x, status = %#x, control = %#x\\n\",\n\t\ttype, trb, trb->data_lo, trb->data_hi, trb->status,\n\t\ttrb->control);\n}\n\nstatic void tegra_xudc_limit_port_speed(struct tegra_xudc *xudc)\n{\n\tu32 val;\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_CNT56);\n\tval &= ~(SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX_MASK);\n\tval |= SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX(0x260);\n\txudc_writel(xudc, val, SSPX_CORE_CNT56);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT57);\n\tval &= ~(SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX_MASK);\n\tval |= SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX(0x6D6);\n\txudc_writel(xudc, val, SSPX_CORE_CNT57);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT65);\n\tval &= ~(SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID(0x4B0);\n\txudc_writel(xudc, val, SSPX_CORE_CNT66);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT66);\n\tval &= ~(SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID(0x4B0);\n\txudc_writel(xudc, val, SSPX_CORE_CNT66);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT67);\n\tval &= ~(SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID(0x4B0);\n\txudc_writel(xudc, val, SSPX_CORE_CNT67);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT72);\n\tval &= ~(SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT_MASK);\n\tval |= SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT(0x10);\n\txudc_writel(xudc, val, SSPX_CORE_CNT72);\n}\n\nstatic void tegra_xudc_restore_port_speed(struct tegra_xudc *xudc)\n{\n\tu32 val;\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_CNT56);\n\tval &= ~(SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX_MASK);\n\tval |= SSPX_CORE_CNT56_SCD_BIT0_TRPT_MAX(0x438);\n\txudc_writel(xudc, val, SSPX_CORE_CNT56);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT57);\n\tval &= ~(SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX_MASK);\n\tval |= SSPX_CORE_CNT57_SCD_BIT1_TRPT_MAX(0x528);\n\txudc_writel(xudc, val, SSPX_CORE_CNT57);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT65);\n\tval &= ~(SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT65_TX_SCD_END_TRPT_MID(0xE10);\n\txudc_writel(xudc, val, SSPX_CORE_CNT66);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT66);\n\tval &= ~(SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT66_TX_SCD_BIT0_TRPT_MID(0x348);\n\txudc_writel(xudc, val, SSPX_CORE_CNT66);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT67);\n\tval &= ~(SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID_MASK);\n\tval |= SSPX_CORE_CNT67_TX_SCD_BIT1_TRPT_MID(0x5a0);\n\txudc_writel(xudc, val, SSPX_CORE_CNT67);\n\n\tval = xudc_readl(xudc, SSPX_CORE_CNT72);\n\tval &= ~(SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT_MASK);\n\tval |= SSPX_CORE_CNT72_SCD_LFPS_TIMEOUT(0x1c21);\n\txudc_writel(xudc, val, SSPX_CORE_CNT72);\n}\n\nstatic void tegra_xudc_device_mode_on(struct tegra_xudc *xudc)\n{\n\tint err;\n\n\tpm_runtime_get_sync(xudc->dev);\n\n\ttegra_phy_xusb_utmi_pad_power_on(xudc->curr_utmi_phy);\n\n\terr = phy_power_on(xudc->curr_utmi_phy);\n\tif (err < 0)\n\t\tdev_err(xudc->dev, \"UTMI power on failed: %d\\n\", err);\n\n\terr = phy_power_on(xudc->curr_usb3_phy);\n\tif (err < 0)\n\t\tdev_err(xudc->dev, \"USB3 PHY power on failed: %d\\n\", err);\n\n\tdev_dbg(xudc->dev, \"device mode on\\n\");\n\n\tphy_set_mode_ext(xudc->curr_utmi_phy, PHY_MODE_USB_OTG,\n\t\t\t USB_ROLE_DEVICE);\n}\n\nstatic void tegra_xudc_device_mode_off(struct tegra_xudc *xudc)\n{\n\tbool connected = false;\n\tu32 pls, val;\n\tint err;\n\n\tdev_dbg(xudc->dev, \"device mode off\\n\");\n\n\tconnected = !!(xudc_readl(xudc, PORTSC) & PORTSC_CCS);\n\n\treinit_completion(&xudc->disconnect_complete);\n\n\tif (xudc->soc->port_speed_quirk)\n\t\ttegra_xudc_restore_port_speed(xudc);\n\n\tphy_set_mode_ext(xudc->curr_utmi_phy, PHY_MODE_USB_OTG, USB_ROLE_NONE);\n\n\tpls = (xudc_readl(xudc, PORTSC) & PORTSC_PLS_MASK) >>\n\t\tPORTSC_PLS_SHIFT;\n\n\t \n\tif (xudc->soc->pls_quirk && xudc->gadget.speed == USB_SPEED_SUPER &&\n\t    (pls == PORTSC_PLS_RESUME || pls == PORTSC_PLS_U2)) {\n\t\tval = xudc_readl(xudc, PORTPM);\n\t\tval |= PORTPM_FRWE;\n\t\txudc_writel(xudc, val, PORTPM);\n\n\t\tval = xudc_readl(xudc, PORTSC);\n\t\tval &= ~(PORTSC_CHANGE_MASK | PORTSC_PLS_MASK);\n\t\tval |= PORTSC_LWS | PORTSC_PLS(PORTSC_PLS_U0);\n\t\txudc_writel(xudc, val, PORTSC);\n\t}\n\n\t \n\tif (connected)\n\t\twait_for_completion(&xudc->disconnect_complete);\n\n\t \n\tsynchronize_irq(xudc->irq);\n\n\ttegra_phy_xusb_utmi_pad_power_down(xudc->curr_utmi_phy);\n\n\terr = phy_power_off(xudc->curr_utmi_phy);\n\tif (err < 0)\n\t\tdev_err(xudc->dev, \"UTMI PHY power off failed: %d\\n\", err);\n\n\terr = phy_power_off(xudc->curr_usb3_phy);\n\tif (err < 0)\n\t\tdev_err(xudc->dev, \"USB3 PHY power off failed: %d\\n\", err);\n\n\tpm_runtime_put(xudc->dev);\n}\n\nstatic void tegra_xudc_usb_role_sw_work(struct work_struct *work)\n{\n\tstruct tegra_xudc *xudc = container_of(work, struct tegra_xudc,\n\t\t\t\t\t       usb_role_sw_work);\n\n\tif (xudc->device_mode)\n\t\ttegra_xudc_device_mode_on(xudc);\n\telse\n\t\ttegra_xudc_device_mode_off(xudc);\n}\n\nstatic int tegra_xudc_get_phy_index(struct tegra_xudc *xudc,\n\t\t\t\t\t      struct usb_phy *usbphy)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\tif (xudc->usbphy[i] && usbphy == xudc->usbphy[i])\n\t\t\treturn i;\n\t}\n\n\tdev_info(xudc->dev, \"phy index could not be found for shared USB PHY\");\n\treturn -1;\n}\n\nstatic void tegra_xudc_update_data_role(struct tegra_xudc *xudc,\n\t\t\t\t\t      struct usb_phy *usbphy)\n{\n\tint phy_index;\n\n\tif ((xudc->device_mode && usbphy->last_event == USB_EVENT_VBUS) ||\n\t    (!xudc->device_mode && usbphy->last_event != USB_EVENT_VBUS)) {\n\t\tdev_dbg(xudc->dev, \"Same role(%d) received. Ignore\",\n\t\t\txudc->device_mode);\n\t\treturn;\n\t}\n\n\txudc->device_mode = (usbphy->last_event == USB_EVENT_VBUS) ? true :\n\t\t\t\t\t\t\t\t     false;\n\n\tphy_index = tegra_xudc_get_phy_index(xudc, usbphy);\n\tdev_dbg(xudc->dev, \"%s(): current phy index is %d\\n\", __func__,\n\t\tphy_index);\n\n\tif (!xudc->suspended && phy_index != -1) {\n\t\txudc->curr_utmi_phy = xudc->utmi_phy[phy_index];\n\t\txudc->curr_usb3_phy = xudc->usb3_phy[phy_index];\n\t\txudc->curr_usbphy = usbphy;\n\t\tschedule_work(&xudc->usb_role_sw_work);\n\t}\n}\n\nstatic int tegra_xudc_vbus_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long action, void *data)\n{\n\tstruct tegra_xudc *xudc = container_of(nb, struct tegra_xudc,\n\t\t\t\t\t       vbus_nb);\n\tstruct usb_phy *usbphy = (struct usb_phy *)data;\n\n\tdev_dbg(xudc->dev, \"%s(): event is %d\\n\", __func__, usbphy->last_event);\n\n\ttegra_xudc_update_data_role(xudc, usbphy);\n\n\treturn NOTIFY_OK;\n}\n\nstatic void tegra_xudc_plc_reset_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tegra_xudc *xudc = container_of(dwork, struct tegra_xudc,\n\t\t\t\t\t       plc_reset_work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (xudc->wait_csc) {\n\t\tu32 pls = (xudc_readl(xudc, PORTSC) & PORTSC_PLS_MASK) >>\n\t\t\tPORTSC_PLS_SHIFT;\n\n\t\tif (pls == PORTSC_PLS_INACTIVE) {\n\t\t\tdev_info(xudc->dev, \"PLS = Inactive. Toggle VBUS\\n\");\n\t\t\tphy_set_mode_ext(xudc->curr_utmi_phy, PHY_MODE_USB_OTG,\n\t\t\t\t\t USB_ROLE_NONE);\n\t\t\tphy_set_mode_ext(xudc->curr_utmi_phy, PHY_MODE_USB_OTG,\n\t\t\t\t\t USB_ROLE_DEVICE);\n\n\t\t\txudc->wait_csc = false;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n}\n\nstatic void tegra_xudc_port_reset_war_work(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct tegra_xudc *xudc =\n\t\tcontainer_of(dwork, struct tegra_xudc, port_reset_war_work);\n\tunsigned long flags;\n\tu32 pls;\n\tint ret;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (xudc->device_mode && xudc->wait_for_sec_prc) {\n\t\tpls = (xudc_readl(xudc, PORTSC) & PORTSC_PLS_MASK) >>\n\t\t\tPORTSC_PLS_SHIFT;\n\t\tdev_dbg(xudc->dev, \"pls = %x\\n\", pls);\n\n\t\tif (pls == PORTSC_PLS_DISABLED) {\n\t\t\tdev_dbg(xudc->dev, \"toggle vbus\\n\");\n\t\t\t \n\t\t\tret = tegra_phy_xusb_utmi_port_reset(\n\t\t\t\txudc->curr_utmi_phy);\n\t\t\tif (ret == 1)\n\t\t\t\txudc->wait_for_sec_prc = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n}\n\nstatic dma_addr_t trb_virt_to_phys(struct tegra_xudc_ep *ep,\n\t\t\t\t   struct tegra_xudc_trb *trb)\n{\n\tunsigned int index;\n\n\tindex = trb - ep->transfer_ring;\n\n\tif (WARN_ON(index >= XUDC_TRANSFER_RING_SIZE))\n\t\treturn 0;\n\n\treturn (ep->transfer_ring_phys + index * sizeof(*trb));\n}\n\nstatic struct tegra_xudc_trb *trb_phys_to_virt(struct tegra_xudc_ep *ep,\n\t\t\t\t\t       dma_addr_t addr)\n{\n\tstruct tegra_xudc_trb *trb;\n\tunsigned int index;\n\n\tindex = (addr - ep->transfer_ring_phys) / sizeof(*trb);\n\n\tif (WARN_ON(index >= XUDC_TRANSFER_RING_SIZE))\n\t\treturn NULL;\n\n\ttrb = &ep->transfer_ring[index];\n\n\treturn trb;\n}\n\nstatic void ep_reload(struct tegra_xudc *xudc, unsigned int ep)\n{\n\txudc_writel(xudc, BIT(ep), EP_RELOAD);\n\txudc_readl_poll(xudc, EP_RELOAD, BIT(ep), 0);\n}\n\nstatic void ep_pause(struct tegra_xudc *xudc, unsigned int ep)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_PAUSE);\n\tif (val & BIT(ep))\n\t\treturn;\n\tval |= BIT(ep);\n\n\txudc_writel(xudc, val, EP_PAUSE);\n\n\txudc_readl_poll(xudc, EP_STCHG, BIT(ep), BIT(ep));\n\n\txudc_writel(xudc, BIT(ep), EP_STCHG);\n}\n\nstatic void ep_unpause(struct tegra_xudc *xudc, unsigned int ep)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_PAUSE);\n\tif (!(val & BIT(ep)))\n\t\treturn;\n\tval &= ~BIT(ep);\n\n\txudc_writel(xudc, val, EP_PAUSE);\n\n\txudc_readl_poll(xudc, EP_STCHG, BIT(ep), BIT(ep));\n\n\txudc_writel(xudc, BIT(ep), EP_STCHG);\n}\n\nstatic void ep_unpause_all(struct tegra_xudc *xudc)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_PAUSE);\n\n\txudc_writel(xudc, 0, EP_PAUSE);\n\n\txudc_readl_poll(xudc, EP_STCHG, val, val);\n\n\txudc_writel(xudc, val, EP_STCHG);\n}\n\nstatic void ep_halt(struct tegra_xudc *xudc, unsigned int ep)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_HALT);\n\tif (val & BIT(ep))\n\t\treturn;\n\tval |= BIT(ep);\n\txudc_writel(xudc, val, EP_HALT);\n\n\txudc_readl_poll(xudc, EP_STCHG, BIT(ep), BIT(ep));\n\n\txudc_writel(xudc, BIT(ep), EP_STCHG);\n}\n\nstatic void ep_unhalt(struct tegra_xudc *xudc, unsigned int ep)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_HALT);\n\tif (!(val & BIT(ep)))\n\t\treturn;\n\tval &= ~BIT(ep);\n\txudc_writel(xudc, val, EP_HALT);\n\n\txudc_readl_poll(xudc, EP_STCHG, BIT(ep), BIT(ep));\n\n\txudc_writel(xudc, BIT(ep), EP_STCHG);\n}\n\nstatic void ep_unhalt_all(struct tegra_xudc *xudc)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, EP_HALT);\n\tif (!val)\n\t\treturn;\n\txudc_writel(xudc, 0, EP_HALT);\n\n\txudc_readl_poll(xudc, EP_STCHG, val, val);\n\n\txudc_writel(xudc, val, EP_STCHG);\n}\n\nstatic void ep_wait_for_stopped(struct tegra_xudc *xudc, unsigned int ep)\n{\n\txudc_readl_poll(xudc, EP_STOPPED, BIT(ep), BIT(ep));\n\txudc_writel(xudc, BIT(ep), EP_STOPPED);\n}\n\nstatic void ep_wait_for_inactive(struct tegra_xudc *xudc, unsigned int ep)\n{\n\txudc_readl_poll(xudc, EP_THREAD_ACTIVE, BIT(ep), 0);\n}\n\nstatic void tegra_xudc_req_done(struct tegra_xudc_ep *ep,\n\t\t\t\tstruct tegra_xudc_request *req, int status)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\n\tdev_dbg(xudc->dev, \"completing request %p on EP %u with status %d\\n\",\n\t\t req, ep->index, status);\n\n\tif (likely(req->usb_req.status == -EINPROGRESS))\n\t\treq->usb_req.status = status;\n\n\tlist_del_init(&req->list);\n\n\tif (usb_endpoint_xfer_control(ep->desc)) {\n\t\tusb_gadget_unmap_request(&xudc->gadget, &req->usb_req,\n\t\t\t\t\t (xudc->setup_state ==\n\t\t\t\t\t  DATA_STAGE_XFER));\n\t} else {\n\t\tusb_gadget_unmap_request(&xudc->gadget, &req->usb_req,\n\t\t\t\t\t usb_endpoint_dir_in(ep->desc));\n\t}\n\n\tspin_unlock(&xudc->lock);\n\tusb_gadget_giveback_request(&ep->usb_ep, &req->usb_req);\n\tspin_lock(&xudc->lock);\n}\n\nstatic void tegra_xudc_ep_nuke(struct tegra_xudc_ep *ep, int status)\n{\n\tstruct tegra_xudc_request *req;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct tegra_xudc_request,\n\t\t\t\t       list);\n\t\ttegra_xudc_req_done(ep, req, status);\n\t}\n}\n\nstatic unsigned int ep_available_trbs(struct tegra_xudc_ep *ep)\n{\n\tif (ep->ring_full)\n\t\treturn 0;\n\n\tif (ep->deq_ptr > ep->enq_ptr)\n\t\treturn ep->deq_ptr - ep->enq_ptr - 1;\n\n\treturn XUDC_TRANSFER_RING_SIZE - (ep->enq_ptr - ep->deq_ptr) - 2;\n}\n\nstatic void tegra_xudc_queue_one_trb(struct tegra_xudc_ep *ep,\n\t\t\t\t     struct tegra_xudc_request *req,\n\t\t\t\t     struct tegra_xudc_trb *trb,\n\t\t\t\t     bool ioc)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tdma_addr_t buf_addr;\n\tsize_t len;\n\n\tlen = min_t(size_t, XUDC_TRB_MAX_BUFFER_SIZE, req->usb_req.length -\n\t\t    req->buf_queued);\n\tif (len > 0)\n\t\tbuf_addr = req->usb_req.dma + req->buf_queued;\n\telse\n\t\tbuf_addr = 0;\n\n\ttrb_write_data_ptr(trb, buf_addr);\n\n\ttrb_write_transfer_len(trb, len);\n\ttrb_write_td_size(trb, req->trbs_needed - req->trbs_queued - 1);\n\n\tif (req->trbs_queued == req->trbs_needed - 1 ||\n\t\t(req->need_zlp && req->trbs_queued == req->trbs_needed - 2))\n\t\ttrb_write_chain(trb, 0);\n\telse\n\t\ttrb_write_chain(trb, 1);\n\n\ttrb_write_ioc(trb, ioc);\n\n\tif (usb_endpoint_dir_out(ep->desc) ||\n\t    (usb_endpoint_xfer_control(ep->desc) &&\n\t     (xudc->setup_state == DATA_STAGE_RECV)))\n\t\ttrb_write_isp(trb, 1);\n\telse\n\t\ttrb_write_isp(trb, 0);\n\n\tif (usb_endpoint_xfer_control(ep->desc)) {\n\t\tif (xudc->setup_state == DATA_STAGE_XFER ||\n\t\t    xudc->setup_state == DATA_STAGE_RECV)\n\t\t\ttrb_write_type(trb, TRB_TYPE_DATA_STAGE);\n\t\telse\n\t\t\ttrb_write_type(trb, TRB_TYPE_STATUS_STAGE);\n\n\t\tif (xudc->setup_state == DATA_STAGE_XFER ||\n\t\t    xudc->setup_state == STATUS_STAGE_XFER)\n\t\t\ttrb_write_data_stage_dir(trb, 1);\n\t\telse\n\t\t\ttrb_write_data_stage_dir(trb, 0);\n\t} else if (usb_endpoint_xfer_isoc(ep->desc)) {\n\t\ttrb_write_type(trb, TRB_TYPE_ISOCH);\n\t\ttrb_write_sia(trb, 1);\n\t\ttrb_write_frame_id(trb, 0);\n\t\ttrb_write_tlbpc(trb, 0);\n\t} else if (usb_ss_max_streams(ep->comp_desc)) {\n\t\ttrb_write_type(trb, TRB_TYPE_STREAM);\n\t\ttrb_write_stream_id(trb, req->usb_req.stream_id);\n\t} else {\n\t\ttrb_write_type(trb, TRB_TYPE_NORMAL);\n\t\ttrb_write_stream_id(trb, 0);\n\t}\n\n\ttrb_write_cycle(trb, ep->pcs);\n\n\treq->trbs_queued++;\n\treq->buf_queued += len;\n\n\tdump_trb(xudc, \"TRANSFER\", trb);\n}\n\nstatic unsigned int tegra_xudc_queue_trbs(struct tegra_xudc_ep *ep,\n\t\t\t\t\t  struct tegra_xudc_request *req)\n{\n\tunsigned int i, count, available;\n\tbool wait_td = false;\n\n\tavailable = ep_available_trbs(ep);\n\tcount = req->trbs_needed - req->trbs_queued;\n\tif (available < count) {\n\t\tcount = available;\n\t\tep->ring_full = true;\n\t}\n\n\t \n\n\tif (req->need_zlp && usb_endpoint_xfer_control(ep->desc) && count > 1)\n\t\twait_td = true;\n\n\tif (!req->first_trb)\n\t\treq->first_trb = &ep->transfer_ring[ep->enq_ptr];\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct tegra_xudc_trb *trb = &ep->transfer_ring[ep->enq_ptr];\n\t\tbool ioc = false;\n\n\t\tif ((i == count - 1) || (wait_td && i == count - 2))\n\t\t\tioc = true;\n\n\t\ttegra_xudc_queue_one_trb(ep, req, trb, ioc);\n\t\treq->last_trb = trb;\n\n\t\tep->enq_ptr++;\n\t\tif (ep->enq_ptr == XUDC_TRANSFER_RING_SIZE - 1) {\n\t\t\ttrb = &ep->transfer_ring[ep->enq_ptr];\n\t\t\ttrb_write_cycle(trb, ep->pcs);\n\t\t\tep->pcs = !ep->pcs;\n\t\t\tep->enq_ptr = 0;\n\t\t}\n\n\t\tif (ioc)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic void tegra_xudc_ep_ring_doorbell(struct tegra_xudc_ep *ep)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tu32 val;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\tval = DB_TARGET(ep->index);\n\tif (usb_endpoint_xfer_control(ep->desc)) {\n\t\tval |= DB_STREAMID(xudc->setup_seq_num);\n\t} else if (usb_ss_max_streams(ep->comp_desc) > 0) {\n\t\tstruct tegra_xudc_request *req;\n\n\t\t \n\t\tif (ep->stream_rejected)\n\t\t\treturn;\n\n\t\treq = list_first_entry(&ep->queue, struct tegra_xudc_request,\n\t\t\t\t       list);\n\t\tval |= DB_STREAMID(req->usb_req.stream_id);\n\t}\n\n\tdev_dbg(xudc->dev, \"ring doorbell: %#x\\n\", val);\n\txudc_writel(xudc, val, DB);\n}\n\nstatic void tegra_xudc_ep_kick_queue(struct tegra_xudc_ep *ep)\n{\n\tstruct tegra_xudc_request *req;\n\tbool trbs_queued = false;\n\n\tlist_for_each_entry(req, &ep->queue, list) {\n\t\tif (ep->ring_full)\n\t\t\tbreak;\n\n\t\tif (tegra_xudc_queue_trbs(ep, req) > 0)\n\t\t\ttrbs_queued = true;\n\t}\n\n\tif (trbs_queued)\n\t\ttegra_xudc_ep_ring_doorbell(ep);\n}\n\nstatic int\n__tegra_xudc_ep_queue(struct tegra_xudc_ep *ep, struct tegra_xudc_request *req)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tint err;\n\n\tif (usb_endpoint_xfer_control(ep->desc) && !list_empty(&ep->queue)) {\n\t\tdev_err(xudc->dev, \"control EP has pending transfers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_endpoint_xfer_control(ep->desc)) {\n\t\terr = usb_gadget_map_request(&xudc->gadget, &req->usb_req,\n\t\t\t\t\t     (xudc->setup_state ==\n\t\t\t\t\t      DATA_STAGE_XFER));\n\t} else {\n\t\terr = usb_gadget_map_request(&xudc->gadget, &req->usb_req,\n\t\t\t\t\t     usb_endpoint_dir_in(ep->desc));\n\t}\n\n\tif (err < 0) {\n\t\tdev_err(xudc->dev, \"failed to map request: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treq->first_trb = NULL;\n\treq->last_trb = NULL;\n\treq->buf_queued = 0;\n\treq->trbs_queued = 0;\n\treq->need_zlp = false;\n\treq->trbs_needed = DIV_ROUND_UP(req->usb_req.length,\n\t\t\t\t\tXUDC_TRB_MAX_BUFFER_SIZE);\n\tif (req->usb_req.length == 0)\n\t\treq->trbs_needed++;\n\n\tif (!usb_endpoint_xfer_isoc(ep->desc) &&\n\t    req->usb_req.zero && req->usb_req.length &&\n\t    ((req->usb_req.length % ep->usb_ep.maxpacket) == 0)) {\n\t\treq->trbs_needed++;\n\t\treq->need_zlp = true;\n\t}\n\n\treq->usb_req.status = -EINPROGRESS;\n\treq->usb_req.actual = 0;\n\n\tlist_add_tail(&req->list, &ep->queue);\n\n\ttegra_xudc_ep_kick_queue(ep);\n\n\treturn 0;\n}\n\nstatic int\ntegra_xudc_ep_queue(struct usb_ep *usb_ep, struct usb_request *usb_req,\n\t\t    gfp_t gfp)\n{\n\tstruct tegra_xudc_request *req;\n\tstruct tegra_xudc_ep *ep;\n\tstruct tegra_xudc *xudc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!usb_ep || !usb_req)\n\t\treturn -EINVAL;\n\n\tep = to_xudc_ep(usb_ep);\n\treq = to_xudc_req(usb_req);\n\txudc = ep->xudc;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\tif (xudc->powergated || !ep->desc) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tret = __tegra_xudc_ep_queue(ep, req);\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void squeeze_transfer_ring(struct tegra_xudc_ep *ep,\n\t\t\t\t  struct tegra_xudc_request *req)\n{\n\tstruct tegra_xudc_trb *trb = req->first_trb;\n\tbool pcs_enq = trb_read_cycle(trb);\n\tbool pcs;\n\n\t \n\twhile (trb != &ep->transfer_ring[ep->enq_ptr]) {\n\t\tpcs = trb_read_cycle(trb);\n\t\tmemset(trb, 0, sizeof(*trb));\n\t\ttrb_write_cycle(trb, !pcs);\n\t\ttrb++;\n\n\t\tif (trb_read_type(trb) == TRB_TYPE_LINK)\n\t\t\ttrb = ep->transfer_ring;\n\t}\n\n\t \n\tep->enq_ptr = req->first_trb - ep->transfer_ring;\n\t \n\tep->pcs = pcs_enq;\n\tep->ring_full = false;\n\tlist_for_each_entry_continue(req, &ep->queue, list) {\n\t\treq->usb_req.status = -EINPROGRESS;\n\t\treq->usb_req.actual = 0;\n\n\t\treq->first_trb = NULL;\n\t\treq->last_trb = NULL;\n\t\treq->buf_queued = 0;\n\t\treq->trbs_queued = 0;\n\t}\n}\n\n \nstatic bool trb_in_request(struct tegra_xudc_ep *ep,\n\t\t\t   struct tegra_xudc_request *req,\n\t\t\t   struct tegra_xudc_trb *trb)\n{\n\tdev_dbg(ep->xudc->dev, \"%s: request %p -> %p; trb %p\\n\", __func__,\n\t\treq->first_trb, req->last_trb, trb);\n\n\tif (trb >= req->first_trb && (trb <= req->last_trb ||\n\t\t\t\t      req->last_trb < req->first_trb))\n\t\treturn true;\n\n\tif (trb < req->first_trb && trb <= req->last_trb &&\n\t    req->last_trb < req->first_trb)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic bool trb_before_request(struct tegra_xudc_ep *ep,\n\t\t\t       struct tegra_xudc_request *req,\n\t\t\t       struct tegra_xudc_trb *trb)\n{\n\tstruct tegra_xudc_trb *enq_trb = &ep->transfer_ring[ep->enq_ptr];\n\n\tdev_dbg(ep->xudc->dev, \"%s: request %p -> %p; enq ptr: %p; trb %p\\n\",\n\t\t__func__, req->first_trb, req->last_trb, enq_trb, trb);\n\n\tif (trb < req->first_trb && (enq_trb <= trb ||\n\t\t\t\t     req->first_trb < enq_trb))\n\t\treturn true;\n\n\tif (trb > req->first_trb && req->first_trb < enq_trb && enq_trb <= trb)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int\n__tegra_xudc_ep_dequeue(struct tegra_xudc_ep *ep,\n\t\t\tstruct tegra_xudc_request *req)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tstruct tegra_xudc_request *r = NULL, *iter;\n\tstruct tegra_xudc_trb *deq_trb;\n\tbool busy, kick_queue = false;\n\tint ret = 0;\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, list) {\n\t\tif (iter != req)\n\t\t\tcontinue;\n\t\tr = iter;\n\t\tbreak;\n\t}\n\n\tif (!r)\n\t\treturn -EINVAL;\n\n\t \n\tif (!req->trbs_queued) {\n\t\ttegra_xudc_req_done(ep, req, -ECONNRESET);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ep_ctx_read_state(ep->context) == EP_STATE_RUNNING) {\n\t\tep_pause(xudc, ep->index);\n\t\tep_wait_for_inactive(xudc, ep->index);\n\t}\n\n\tdeq_trb = trb_phys_to_virt(ep, ep_ctx_read_deq_ptr(ep->context));\n\t \n\tbusy = (trb_read_cycle(deq_trb) == ep_ctx_read_dcs(ep->context));\n\n\tif (trb_in_request(ep, req, deq_trb) && busy) {\n\t\t \n\t\tdma_addr_t deq_ptr;\n\n\t\tsqueeze_transfer_ring(ep, req);\n\n\t\treq->usb_req.actual = ep_ctx_read_edtla(ep->context);\n\t\ttegra_xudc_req_done(ep, req, -ECONNRESET);\n\t\tkick_queue = true;\n\n\t\t \n\t\tif (req->usb_req.actual > 0) {\n\t\t\t \n\t\t\tep_ctx_write_edtla(ep->context, 0);\n\t\t\tep_ctx_write_partial_td(ep->context, 0);\n\t\t\tep_ctx_write_data_offset(ep->context, 0);\n\n\t\t\tdeq_ptr = trb_virt_to_phys(ep,\n\t\t\t\t\t&ep->transfer_ring[ep->enq_ptr]);\n\n\t\t\tif (dma_mapping_error(xudc->dev, deq_ptr)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t} else {\n\t\t\t\tep_ctx_write_deq_ptr(ep->context, deq_ptr);\n\t\t\t\tep_ctx_write_dcs(ep->context, ep->pcs);\n\t\t\t\tep_reload(xudc, ep->index);\n\t\t\t}\n\t\t}\n\t} else if (trb_before_request(ep, req, deq_trb) && busy) {\n\t\t \n\t\tsqueeze_transfer_ring(ep, req);\n\n\t\ttegra_xudc_req_done(ep, req, -ECONNRESET);\n\t\tkick_queue = true;\n\t} else {\n\t\t \n\t\ttegra_xudc_req_done(ep, req, -ECONNRESET);\n\t\tret = -EINVAL;\n\t}\n\n\t \n\tep_unpause(xudc, ep->index);\n\n\tif (kick_queue)\n\t\ttegra_xudc_ep_kick_queue(ep);\n\n\treturn ret;\n}\n\nstatic int\ntegra_xudc_ep_dequeue(struct usb_ep *usb_ep, struct usb_request *usb_req)\n{\n\tstruct tegra_xudc_request *req;\n\tstruct tegra_xudc_ep *ep;\n\tstruct tegra_xudc *xudc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!usb_ep || !usb_req)\n\t\treturn -EINVAL;\n\n\tep = to_xudc_ep(usb_ep);\n\treq = to_xudc_req(usb_req);\n\txudc = ep->xudc;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (xudc->powergated || !ep->desc) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tret = __tegra_xudc_ep_dequeue(ep, req);\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int __tegra_xudc_ep_set_halt(struct tegra_xudc_ep *ep, bool halt)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\n\tif (!ep->desc)\n\t\treturn -EINVAL;\n\n\tif (usb_endpoint_xfer_isoc(ep->desc)) {\n\t\tdev_err(xudc->dev, \"can't halt isochronous EP\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!!(xudc_readl(xudc, EP_HALT) & BIT(ep->index)) == halt) {\n\t\tdev_dbg(xudc->dev, \"EP %u already %s\\n\", ep->index,\n\t\t\thalt ? \"halted\" : \"not halted\");\n\t\treturn 0;\n\t}\n\n\tif (halt) {\n\t\tep_halt(xudc, ep->index);\n\t} else {\n\t\tep_ctx_write_state(ep->context, EP_STATE_DISABLED);\n\n\t\tep_reload(xudc, ep->index);\n\n\t\tep_ctx_write_state(ep->context, EP_STATE_RUNNING);\n\t\tep_ctx_write_rsvd(ep->context, 0);\n\t\tep_ctx_write_partial_td(ep->context, 0);\n\t\tep_ctx_write_splitxstate(ep->context, 0);\n\t\tep_ctx_write_seq_num(ep->context, 0);\n\n\t\tep_reload(xudc, ep->index);\n\t\tep_unpause(xudc, ep->index);\n\t\tep_unhalt(xudc, ep->index);\n\n\t\ttegra_xudc_ep_ring_doorbell(ep);\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_ep_set_halt(struct usb_ep *usb_ep, int value)\n{\n\tstruct tegra_xudc_ep *ep;\n\tstruct tegra_xudc *xudc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!usb_ep)\n\t\treturn -EINVAL;\n\n\tep = to_xudc_ep(usb_ep);\n\txudc = ep->xudc;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\tif (xudc->powergated) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tif (value && usb_endpoint_dir_in(ep->desc) &&\n\t    !list_empty(&ep->queue)) {\n\t\tdev_err(xudc->dev, \"can't halt EP with requests pending\\n\");\n\t\tret = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tret = __tegra_xudc_ep_set_halt(ep, value);\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void tegra_xudc_ep_context_setup(struct tegra_xudc_ep *ep)\n{\n\tconst struct usb_endpoint_descriptor *desc = ep->desc;\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc = ep->comp_desc;\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tu16 maxpacket, maxburst = 0, esit = 0;\n\tu32 val;\n\n\tmaxpacket = usb_endpoint_maxp(desc);\n\tif (xudc->gadget.speed == USB_SPEED_SUPER) {\n\t\tif (!usb_endpoint_xfer_control(desc))\n\t\t\tmaxburst = comp_desc->bMaxBurst;\n\n\t\tif (usb_endpoint_xfer_int(desc) || usb_endpoint_xfer_isoc(desc))\n\t\t\tesit = le16_to_cpu(comp_desc->wBytesPerInterval);\n\t} else if ((xudc->gadget.speed < USB_SPEED_SUPER) &&\n\t\t   (usb_endpoint_xfer_int(desc) ||\n\t\t    usb_endpoint_xfer_isoc(desc))) {\n\t\tif (xudc->gadget.speed == USB_SPEED_HIGH) {\n\t\t\tmaxburst = usb_endpoint_maxp_mult(desc) - 1;\n\t\t\tif (maxburst == 0x3) {\n\t\t\t\tdev_warn(xudc->dev,\n\t\t\t\t\t \"invalid endpoint maxburst\\n\");\n\t\t\t\tmaxburst = 0x2;\n\t\t\t}\n\t\t}\n\t\tesit = maxpacket * (maxburst + 1);\n\t}\n\n\tmemset(ep->context, 0, sizeof(*ep->context));\n\n\tep_ctx_write_state(ep->context, EP_STATE_RUNNING);\n\tep_ctx_write_interval(ep->context, desc->bInterval);\n\tif (xudc->gadget.speed == USB_SPEED_SUPER) {\n\t\tif (usb_endpoint_xfer_isoc(desc)) {\n\t\t\tep_ctx_write_mult(ep->context,\n\t\t\t\t\t  comp_desc->bmAttributes & 0x3);\n\t\t}\n\n\t\tif (usb_endpoint_xfer_bulk(desc)) {\n\t\t\tep_ctx_write_max_pstreams(ep->context,\n\t\t\t\t\t\t  comp_desc->bmAttributes &\n\t\t\t\t\t\t  0x1f);\n\t\t\tep_ctx_write_lsa(ep->context, 1);\n\t\t}\n\t}\n\n\tif (!usb_endpoint_xfer_control(desc) && usb_endpoint_dir_out(desc))\n\t\tval = usb_endpoint_type(desc);\n\telse\n\t\tval = usb_endpoint_type(desc) + EP_TYPE_CONTROL;\n\n\tep_ctx_write_type(ep->context, val);\n\tep_ctx_write_cerr(ep->context, 0x3);\n\tep_ctx_write_max_packet_size(ep->context, maxpacket);\n\tep_ctx_write_max_burst_size(ep->context, maxburst);\n\n\tep_ctx_write_deq_ptr(ep->context, ep->transfer_ring_phys);\n\tep_ctx_write_dcs(ep->context, ep->pcs);\n\n\t \n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tval = 8;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tval = 1024;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_ISOC:\n\tdefault:\n\t\tval = 3072;\n\t\tbreak;\n\t}\n\n\tep_ctx_write_avg_trb_len(ep->context, val);\n\tep_ctx_write_max_esit_payload(ep->context, esit);\n\n\tep_ctx_write_cerrcnt(ep->context, 0x3);\n}\n\nstatic void setup_link_trb(struct tegra_xudc_ep *ep,\n\t\t\t   struct tegra_xudc_trb *trb)\n{\n\ttrb_write_data_ptr(trb, ep->transfer_ring_phys);\n\ttrb_write_type(trb, TRB_TYPE_LINK);\n\ttrb_write_toggle_cycle(trb, 1);\n}\n\nstatic int __tegra_xudc_ep_disable(struct tegra_xudc_ep *ep)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\n\tif (ep_ctx_read_state(ep->context) == EP_STATE_DISABLED) {\n\t\tdev_err(xudc->dev, \"endpoint %u already disabled\\n\",\n\t\t\tep->index);\n\t\treturn -EINVAL;\n\t}\n\n\tep_ctx_write_state(ep->context, EP_STATE_DISABLED);\n\n\tep_reload(xudc, ep->index);\n\n\ttegra_xudc_ep_nuke(ep, -ESHUTDOWN);\n\n\txudc->nr_enabled_eps--;\n\tif (usb_endpoint_xfer_isoc(ep->desc))\n\t\txudc->nr_isoch_eps--;\n\n\tep->desc = NULL;\n\tep->comp_desc = NULL;\n\n\tmemset(ep->context, 0, sizeof(*ep->context));\n\n\tep_unpause(xudc, ep->index);\n\tep_unhalt(xudc, ep->index);\n\tif (xudc_readl(xudc, EP_STOPPED) & BIT(ep->index))\n\t\txudc_writel(xudc, BIT(ep->index), EP_STOPPED);\n\n\t \n\tif ((xudc->device_state == USB_STATE_CONFIGURED) &&\n\t    (xudc->nr_enabled_eps == 1)) {\n\t\tu32 val;\n\n\t\txudc->device_state = USB_STATE_ADDRESS;\n\t\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\t\tval = xudc_readl(xudc, CTRL);\n\t\tval &= ~CTRL_RUN;\n\t\txudc_writel(xudc, val, CTRL);\n\t}\n\n\tdev_info(xudc->dev, \"ep %u disabled\\n\", ep->index);\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_ep_disable(struct usb_ep *usb_ep)\n{\n\tstruct tegra_xudc_ep *ep;\n\tstruct tegra_xudc *xudc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!usb_ep)\n\t\treturn -EINVAL;\n\n\tep = to_xudc_ep(usb_ep);\n\txudc = ep->xudc;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\tif (xudc->powergated) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tret = __tegra_xudc_ep_disable(ep);\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int __tegra_xudc_ep_enable(struct tegra_xudc_ep *ep,\n\t\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct tegra_xudc *xudc = ep->xudc;\n\tunsigned int i;\n\tu32 val;\n\n\tif (xudc->gadget.speed == USB_SPEED_SUPER &&\n\t\t!usb_endpoint_xfer_control(desc) && !ep->usb_ep.comp_desc)\n\t\treturn -EINVAL;\n\n\t \n\tif (ep_ctx_read_state(ep->context) != EP_STATE_DISABLED)\n\t\t__tegra_xudc_ep_disable(ep);\n\n\tep->desc = desc;\n\tep->comp_desc = ep->usb_ep.comp_desc;\n\n\tif (usb_endpoint_xfer_isoc(desc)) {\n\t\tif (xudc->nr_isoch_eps > XUDC_MAX_ISOCH_EPS) {\n\t\t\tdev_err(xudc->dev, \"too many isochronous endpoints\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\txudc->nr_isoch_eps++;\n\t}\n\n\tmemset(ep->transfer_ring, 0, XUDC_TRANSFER_RING_SIZE *\n\t       sizeof(*ep->transfer_ring));\n\tsetup_link_trb(ep, &ep->transfer_ring[XUDC_TRANSFER_RING_SIZE - 1]);\n\n\tep->enq_ptr = 0;\n\tep->deq_ptr = 0;\n\tep->pcs = true;\n\tep->ring_full = false;\n\txudc->nr_enabled_eps++;\n\n\ttegra_xudc_ep_context_setup(ep);\n\n\t \n\tif (usb_endpoint_xfer_control(desc))\n\t\tgoto out;\n\n\t \n\tif (xudc->device_state == USB_STATE_ADDRESS) {\n\t\tval = xudc_readl(xudc, CTRL);\n\t\tval |= CTRL_RUN;\n\t\txudc_writel(xudc, val, CTRL);\n\n\t\txudc->device_state = USB_STATE_CONFIGURED;\n\t\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(desc)) {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++) {\n\t\t\tif (xudc->ep[i].desc &&\n\t\t\t    usb_endpoint_xfer_bulk(xudc->ep[i].desc))\n\t\t\t\tep_pause(xudc, i);\n\t\t}\n\t}\n\n\tep_reload(xudc, ep->index);\n\tep_unpause(xudc, ep->index);\n\tep_unhalt(xudc, ep->index);\n\n\tif (usb_endpoint_xfer_isoc(desc)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++) {\n\t\t\tif (xudc->ep[i].desc &&\n\t\t\t    usb_endpoint_xfer_bulk(xudc->ep[i].desc))\n\t\t\t\tep_unpause(xudc, i);\n\t\t}\n\t}\n\nout:\n\tdev_info(xudc->dev, \"EP %u (type: %s, dir: %s) enabled\\n\", ep->index,\n\t\t usb_ep_type_string(usb_endpoint_type(ep->desc)),\n\t\t usb_endpoint_dir_in(ep->desc) ? \"in\" : \"out\");\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_ep_enable(struct usb_ep *usb_ep,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct tegra_xudc_ep *ep;\n\tstruct tegra_xudc *xudc;\n\tunsigned long flags;\n\tint ret;\n\n\tif  (!usb_ep || !desc || (desc->bDescriptorType != USB_DT_ENDPOINT))\n\t\treturn -EINVAL;\n\n\tep = to_xudc_ep(usb_ep);\n\txudc = ep->xudc;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\tif (xudc->powergated) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tret = __tegra_xudc_ep_enable(ep, desc);\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct usb_request *\ntegra_xudc_ep_alloc_request(struct usb_ep *usb_ep, gfp_t gfp)\n{\n\tstruct tegra_xudc_request *req;\n\n\treq = kzalloc(sizeof(*req), gfp);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->list);\n\n\treturn &req->usb_req;\n}\n\nstatic void tegra_xudc_ep_free_request(struct usb_ep *usb_ep,\n\t\t\t\t       struct usb_request *usb_req)\n{\n\tstruct tegra_xudc_request *req = to_xudc_req(usb_req);\n\n\tkfree(req);\n}\n\nstatic const struct usb_ep_ops tegra_xudc_ep_ops = {\n\t.enable = tegra_xudc_ep_enable,\n\t.disable = tegra_xudc_ep_disable,\n\t.alloc_request = tegra_xudc_ep_alloc_request,\n\t.free_request = tegra_xudc_ep_free_request,\n\t.queue = tegra_xudc_ep_queue,\n\t.dequeue = tegra_xudc_ep_dequeue,\n\t.set_halt = tegra_xudc_ep_set_halt,\n};\n\nstatic int tegra_xudc_ep0_enable(struct usb_ep *usb_ep,\n\t\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EBUSY;\n}\n\nstatic int tegra_xudc_ep0_disable(struct usb_ep *usb_ep)\n{\n\treturn -EBUSY;\n}\n\nstatic const struct usb_ep_ops tegra_xudc_ep0_ops = {\n\t.enable = tegra_xudc_ep0_enable,\n\t.disable = tegra_xudc_ep0_disable,\n\t.alloc_request = tegra_xudc_ep_alloc_request,\n\t.free_request = tegra_xudc_ep_free_request,\n\t.queue = tegra_xudc_ep_queue,\n\t.dequeue = tegra_xudc_ep_dequeue,\n\t.set_halt = tegra_xudc_ep_set_halt,\n};\n\nstatic int tegra_xudc_gadget_get_frame(struct usb_gadget *gadget)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\tif (xudc->powergated) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\n\tret = (xudc_readl(xudc, MFINDEX) & MFINDEX_FRAME_MASK) >>\n\t\tMFINDEX_FRAME_SHIFT;\nunlock:\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void tegra_xudc_resume_device_state(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\tu32 val;\n\n\tep_unpause_all(xudc);\n\n\t \n\tval = xudc_readl(xudc, PORTSC);\n\tif (((val & PORTSC_PLS_MASK) >> PORTSC_PLS_SHIFT) != PORTSC_PLS_U0) {\n\t\tval &= ~(PORTSC_CHANGE_MASK | PORTSC_PLS_MASK);\n\t\tval |= PORTSC_LWS | PORTSC_PLS(PORTSC_PLS_U0);\n\t\txudc_writel(xudc, val, PORTSC);\n\t}\n\n\tif (xudc->device_state == USB_STATE_SUSPENDED) {\n\t\txudc->device_state = xudc->resume_state;\n\t\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\t\txudc->resume_state = 0;\n\t}\n\n\t \n\tndelay(500);\n\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++)\n\t\ttegra_xudc_ep_ring_doorbell(&xudc->ep[i]);\n}\n\nstatic int tegra_xudc_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 val;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (xudc->powergated) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto unlock;\n\t}\n\tval = xudc_readl(xudc, PORTPM);\n\tdev_dbg(xudc->dev, \"%s: PORTPM=%#x, speed=%x\\n\", __func__,\n\t\t\tval, gadget->speed);\n\n\tif (((xudc->gadget.speed <= USB_SPEED_HIGH) &&\n\t     (val & PORTPM_RWE)) ||\n\t    ((xudc->gadget.speed == USB_SPEED_SUPER) &&\n\t     (val & PORTPM_FRWE))) {\n\t\ttegra_xudc_resume_device_state(xudc);\n\n\t\t \n\t\tif (xudc->gadget.speed == USB_SPEED_SUPER) {\n\t\t\tval = DEVNOTIF_LO_TYPE(DEVNOTIF_LO_TYPE_FUNCTION_WAKE)\n\t\t\t\t\t     | DEVNOTIF_LO_TRIG;\n\t\t\txudc_writel(xudc, 0, DEVNOTIF_HI);\n\t\t\txudc_writel(xudc, val, DEVNOTIF_LO);\n\t\t}\n\t}\n\nunlock:\n\tdev_dbg(xudc->dev, \"%s: ret value is %d\", __func__, ret);\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int tegra_xudc_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\tunsigned long flags;\n\tu32 val;\n\n\tpm_runtime_get_sync(xudc->dev);\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (is_on != xudc->pullup) {\n\t\tval = xudc_readl(xudc, CTRL);\n\t\tif (is_on)\n\t\t\tval |= CTRL_ENABLE;\n\t\telse\n\t\t\tval &= ~CTRL_ENABLE;\n\t\txudc_writel(xudc, val, CTRL);\n\t}\n\n\txudc->pullup = is_on;\n\tdev_dbg(xudc->dev, \"%s: pullup:%d\", __func__, is_on);\n\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tpm_runtime_put(xudc->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_gadget_start(struct usb_gadget *gadget,\n\t\t\t\t   struct usb_gadget_driver *driver)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\tunsigned int i;\n\n\tif (!driver)\n\t\treturn -EINVAL;\n\n\tpm_runtime_get_sync(xudc->dev);\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tif (xudc->driver) {\n\t\tret = -EBUSY;\n\t\tgoto unlock;\n\t}\n\n\txudc->setup_state = WAIT_FOR_SETUP;\n\txudc->device_state = USB_STATE_DEFAULT;\n\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\tret = __tegra_xudc_ep_enable(&xudc->ep[0], &tegra_xudc_ep0_desc);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\tval = xudc_readl(xudc, CTRL);\n\tval |= CTRL_IE | CTRL_LSE;\n\txudc_writel(xudc, val, CTRL);\n\n\tval = xudc_readl(xudc, PORTHALT);\n\tval |= PORTHALT_STCHG_INTR_EN;\n\txudc_writel(xudc, val, PORTHALT);\n\n\tif (xudc->pullup) {\n\t\tval = xudc_readl(xudc, CTRL);\n\t\tval |= CTRL_ENABLE;\n\t\txudc_writel(xudc, val, CTRL);\n\t}\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++)\n\t\tif (xudc->usbphy[i])\n\t\t\totg_set_peripheral(xudc->usbphy[i]->otg, gadget);\n\n\txudc->driver = driver;\nunlock:\n\tdev_dbg(xudc->dev, \"%s: ret value is %d\", __func__, ret);\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tpm_runtime_put(xudc->dev);\n\n\treturn ret;\n}\n\nstatic int tegra_xudc_gadget_stop(struct usb_gadget *gadget)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\tunsigned long flags;\n\tu32 val;\n\tunsigned int i;\n\n\tpm_runtime_get_sync(xudc->dev);\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++)\n\t\tif (xudc->usbphy[i])\n\t\t\totg_set_peripheral(xudc->usbphy[i]->otg, NULL);\n\n\tval = xudc_readl(xudc, CTRL);\n\tval &= ~(CTRL_IE | CTRL_ENABLE);\n\txudc_writel(xudc, val, CTRL);\n\n\t__tegra_xudc_ep_disable(&xudc->ep[0]);\n\n\txudc->driver = NULL;\n\tdev_dbg(xudc->dev, \"Gadget stopped\");\n\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tpm_runtime_put(xudc->dev);\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_gadget_vbus_draw(struct usb_gadget *gadget,\n\t\t\t\t\t\tunsigned int m_a)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\n\tdev_dbg(xudc->dev, \"%s: %u mA\\n\", __func__, m_a);\n\n\tif (xudc->curr_usbphy && xudc->curr_usbphy->chg_type == SDP_TYPE)\n\t\treturn usb_phy_set_power(xudc->curr_usbphy, m_a);\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_set_selfpowered(struct usb_gadget *gadget, int is_on)\n{\n\tstruct tegra_xudc *xudc = to_xudc(gadget);\n\n\tdev_dbg(xudc->dev, \"%s: %d\\n\", __func__, is_on);\n\txudc->selfpowered = !!is_on;\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops tegra_xudc_gadget_ops = {\n\t.get_frame = tegra_xudc_gadget_get_frame,\n\t.wakeup = tegra_xudc_gadget_wakeup,\n\t.pullup = tegra_xudc_gadget_pullup,\n\t.udc_start = tegra_xudc_gadget_start,\n\t.udc_stop = tegra_xudc_gadget_stop,\n\t.vbus_draw = tegra_xudc_gadget_vbus_draw,\n\t.set_selfpowered = tegra_xudc_set_selfpowered,\n};\n\nstatic void no_op_complete(struct usb_ep *ep, struct usb_request *req)\n{\n}\n\nstatic int\ntegra_xudc_ep0_queue_status(struct tegra_xudc *xudc,\n\t\tvoid (*cmpl)(struct usb_ep *, struct usb_request *))\n{\n\txudc->ep0_req->usb_req.buf = NULL;\n\txudc->ep0_req->usb_req.dma = 0;\n\txudc->ep0_req->usb_req.length = 0;\n\txudc->ep0_req->usb_req.complete = cmpl;\n\txudc->ep0_req->usb_req.context = xudc;\n\n\treturn __tegra_xudc_ep_queue(&xudc->ep[0], xudc->ep0_req);\n}\n\nstatic int\ntegra_xudc_ep0_queue_data(struct tegra_xudc *xudc, void *buf, size_t len,\n\t\tvoid (*cmpl)(struct usb_ep *, struct usb_request *))\n{\n\txudc->ep0_req->usb_req.buf = buf;\n\txudc->ep0_req->usb_req.length = len;\n\txudc->ep0_req->usb_req.complete = cmpl;\n\txudc->ep0_req->usb_req.context = xudc;\n\n\treturn __tegra_xudc_ep_queue(&xudc->ep[0], xudc->ep0_req);\n}\n\nstatic void tegra_xudc_ep0_req_done(struct tegra_xudc *xudc)\n{\n\tswitch (xudc->setup_state) {\n\tcase DATA_STAGE_XFER:\n\t\txudc->setup_state = STATUS_STAGE_RECV;\n\t\ttegra_xudc_ep0_queue_status(xudc, no_op_complete);\n\t\tbreak;\n\tcase DATA_STAGE_RECV:\n\t\txudc->setup_state = STATUS_STAGE_XFER;\n\t\ttegra_xudc_ep0_queue_status(xudc, no_op_complete);\n\t\tbreak;\n\tdefault:\n\t\txudc->setup_state = WAIT_FOR_SETUP;\n\t\tbreak;\n\t}\n}\n\nstatic int tegra_xudc_ep0_delegate_req(struct tegra_xudc *xudc,\n\t\t\t\t       struct usb_ctrlrequest *ctrl)\n{\n\tint ret;\n\n\tspin_unlock(&xudc->lock);\n\tret = xudc->driver->setup(&xudc->gadget, ctrl);\n\tspin_lock(&xudc->lock);\n\n\treturn ret;\n}\n\nstatic void set_feature_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct tegra_xudc *xudc = req->context;\n\n\tif (xudc->test_mode_pattern) {\n\t\txudc_writel(xudc, xudc->test_mode_pattern, PORT_TM);\n\t\txudc->test_mode_pattern = 0;\n\t}\n}\n\nstatic int tegra_xudc_ep0_set_feature(struct tegra_xudc *xudc,\n\t\t\t\t      struct usb_ctrlrequest *ctrl)\n{\n\tbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\n\tu32 feature = le16_to_cpu(ctrl->wValue);\n\tu32 index = le16_to_cpu(ctrl->wIndex);\n\tu32 val, ep;\n\tint ret;\n\n\tif (le16_to_cpu(ctrl->wLength) != 0)\n\t\treturn -EINVAL;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (feature) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif ((xudc->gadget.speed == USB_SPEED_SUPER) ||\n\t\t\t    (xudc->device_state == USB_STATE_DEFAULT))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tval = xudc_readl(xudc, PORTPM);\n\t\t\tif (set)\n\t\t\t\tval |= PORTPM_RWE;\n\t\t\telse\n\t\t\t\tval &= ~PORTPM_RWE;\n\n\t\t\txudc_writel(xudc, val, PORTPM);\n\t\t\tbreak;\n\t\tcase USB_DEVICE_U1_ENABLE:\n\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\tif ((xudc->device_state != USB_STATE_CONFIGURED) ||\n\t\t\t    (xudc->gadget.speed != USB_SPEED_SUPER))\n\t\t\t\treturn -EINVAL;\n\n\t\t\tval = xudc_readl(xudc, PORTPM);\n\t\t\tif ((feature == USB_DEVICE_U1_ENABLE) &&\n\t\t\t     xudc->soc->u1_enable) {\n\t\t\t\tif (set)\n\t\t\t\t\tval |= PORTPM_U1E;\n\t\t\t\telse\n\t\t\t\t\tval &= ~PORTPM_U1E;\n\t\t\t}\n\n\t\t\tif ((feature == USB_DEVICE_U2_ENABLE) &&\n\t\t\t     xudc->soc->u2_enable) {\n\t\t\t\tif (set)\n\t\t\t\t\tval |= PORTPM_U2E;\n\t\t\t\telse\n\t\t\t\t\tval &= ~PORTPM_U2E;\n\t\t\t}\n\n\t\t\txudc_writel(xudc, val, PORTPM);\n\t\t\tbreak;\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\tif (xudc->gadget.speed != USB_SPEED_HIGH)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (!set)\n\t\t\t\treturn -EINVAL;\n\n\t\t\txudc->test_mode_pattern = index >> 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tif (xudc->device_state != USB_STATE_CONFIGURED)\n\t\t\treturn -EINVAL;\n\n\t\tswitch (feature) {\n\t\tcase USB_INTRF_FUNC_SUSPEND:\n\t\t\tif (set) {\n\t\t\t\tval = xudc_readl(xudc, PORTPM);\n\n\t\t\t\tif (index & USB_INTRF_FUNC_SUSPEND_RW)\n\t\t\t\t\tval |= PORTPM_FRWE;\n\t\t\t\telse\n\t\t\t\t\tval &= ~PORTPM_FRWE;\n\n\t\t\t\txudc_writel(xudc, val, PORTPM);\n\t\t\t}\n\n\t\t\treturn tegra_xudc_ep0_delegate_req(xudc, ctrl);\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = (index & USB_ENDPOINT_NUMBER_MASK) * 2 +\n\t\t\t((index & USB_DIR_IN) ? 1 : 0);\n\n\t\tif ((xudc->device_state == USB_STATE_DEFAULT) ||\n\t\t    ((xudc->device_state == USB_STATE_ADDRESS) &&\n\t\t     (index != 0)))\n\t\t\treturn -EINVAL;\n\n\t\tret = __tegra_xudc_ep_set_halt(&xudc->ep[ep], set);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn tegra_xudc_ep0_queue_status(xudc, set_feature_complete);\n}\n\nstatic int tegra_xudc_ep0_get_status(struct tegra_xudc *xudc,\n\t\t\t\t     struct usb_ctrlrequest *ctrl)\n{\n\tstruct tegra_xudc_ep_context *ep_ctx;\n\tu32 val, ep, index = le16_to_cpu(ctrl->wIndex);\n\tu16 status = 0;\n\n\tif (!(ctrl->bRequestType & USB_DIR_IN))\n\t\treturn -EINVAL;\n\n\tif ((le16_to_cpu(ctrl->wValue) != 0) ||\n\t    (le16_to_cpu(ctrl->wLength) != 2))\n\t\treturn -EINVAL;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tval = xudc_readl(xudc, PORTPM);\n\n\t\tif (xudc->selfpowered)\n\t\t\tstatus |= BIT(USB_DEVICE_SELF_POWERED);\n\n\t\tif ((xudc->gadget.speed < USB_SPEED_SUPER) &&\n\t\t    (val & PORTPM_RWE))\n\t\t\tstatus |= BIT(USB_DEVICE_REMOTE_WAKEUP);\n\n\t\tif (xudc->gadget.speed == USB_SPEED_SUPER) {\n\t\t\tif (val & PORTPM_U1E)\n\t\t\t\tstatus |= BIT(USB_DEV_STAT_U1_ENABLED);\n\t\t\tif (val & PORTPM_U2E)\n\t\t\t\tstatus |= BIT(USB_DEV_STAT_U2_ENABLED);\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tif (xudc->gadget.speed == USB_SPEED_SUPER) {\n\t\t\tstatus |= USB_INTRF_STAT_FUNC_RW_CAP;\n\t\t\tval = xudc_readl(xudc, PORTPM);\n\t\t\tif (val & PORTPM_FRWE)\n\t\t\t\tstatus |= USB_INTRF_STAT_FUNC_RW;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = (index & USB_ENDPOINT_NUMBER_MASK) * 2 +\n\t\t\t((index & USB_DIR_IN) ? 1 : 0);\n\t\tep_ctx = &xudc->ep_context[ep];\n\n\t\tif ((xudc->device_state != USB_STATE_CONFIGURED) &&\n\t\t    ((xudc->device_state != USB_STATE_ADDRESS) || (ep != 0)))\n\t\t\treturn -EINVAL;\n\n\t\tif (ep_ctx_read_state(ep_ctx) == EP_STATE_DISABLED)\n\t\t\treturn -EINVAL;\n\n\t\tif (xudc_readl(xudc, EP_HALT) & BIT(ep))\n\t\t\tstatus |= BIT(USB_ENDPOINT_HALT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\txudc->status_buf = cpu_to_le16(status);\n\treturn tegra_xudc_ep0_queue_data(xudc, &xudc->status_buf,\n\t\t\t\t\t sizeof(xudc->status_buf),\n\t\t\t\t\t no_op_complete);\n}\n\nstatic void set_sel_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\t \n}\n\nstatic int tegra_xudc_ep0_set_sel(struct tegra_xudc *xudc,\n\t\t\t\t  struct usb_ctrlrequest *ctrl)\n{\n\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE |\n\t\t\t\t     USB_TYPE_STANDARD))\n\t\treturn -EINVAL;\n\n\tif (xudc->device_state == USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\tif ((le16_to_cpu(ctrl->wIndex) != 0) ||\n\t    (le16_to_cpu(ctrl->wValue) != 0) ||\n\t    (le16_to_cpu(ctrl->wLength) != 6))\n\t\treturn -EINVAL;\n\n\treturn tegra_xudc_ep0_queue_data(xudc, &xudc->sel_timing,\n\t\t\t\t\t sizeof(xudc->sel_timing),\n\t\t\t\t\t set_sel_complete);\n}\n\nstatic void set_isoch_delay_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\t \n}\n\nstatic int tegra_xudc_ep0_set_isoch_delay(struct tegra_xudc *xudc,\n\t\t\t\t\t  struct usb_ctrlrequest *ctrl)\n{\n\tu32 delay = le16_to_cpu(ctrl->wValue);\n\n\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE |\n\t\t\t\t   USB_TYPE_STANDARD))\n\t\treturn -EINVAL;\n\n\tif ((delay > 65535) || (le16_to_cpu(ctrl->wIndex) != 0) ||\n\t    (le16_to_cpu(ctrl->wLength) != 0))\n\t\treturn -EINVAL;\n\n\txudc->isoch_delay = delay;\n\n\treturn tegra_xudc_ep0_queue_status(xudc, set_isoch_delay_complete);\n}\n\nstatic void set_address_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct tegra_xudc *xudc = req->context;\n\n\tif ((xudc->device_state == USB_STATE_DEFAULT) &&\n\t    (xudc->dev_addr != 0)) {\n\t\txudc->device_state = USB_STATE_ADDRESS;\n\t\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\t} else if ((xudc->device_state == USB_STATE_ADDRESS) &&\n\t\t   (xudc->dev_addr == 0)) {\n\t\txudc->device_state = USB_STATE_DEFAULT;\n\t\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\t}\n}\n\nstatic int tegra_xudc_ep0_set_address(struct tegra_xudc *xudc,\n\t\t\t\t      struct usb_ctrlrequest *ctrl)\n{\n\tstruct tegra_xudc_ep *ep0 = &xudc->ep[0];\n\tu32 val, addr = le16_to_cpu(ctrl->wValue);\n\n\tif (ctrl->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE |\n\t\t\t\t     USB_TYPE_STANDARD))\n\t\treturn -EINVAL;\n\n\tif ((addr > 127) || (le16_to_cpu(ctrl->wIndex) != 0) ||\n\t    (le16_to_cpu(ctrl->wLength) != 0))\n\t\treturn -EINVAL;\n\n\tif (xudc->device_state == USB_STATE_CONFIGURED)\n\t\treturn -EINVAL;\n\n\tdev_dbg(xudc->dev, \"set address: %u\\n\", addr);\n\n\txudc->dev_addr = addr;\n\tval = xudc_readl(xudc, CTRL);\n\tval &= ~(CTRL_DEVADDR_MASK);\n\tval |= CTRL_DEVADDR(addr);\n\txudc_writel(xudc, val, CTRL);\n\n\tep_ctx_write_devaddr(ep0->context, addr);\n\n\treturn tegra_xudc_ep0_queue_status(xudc, set_address_complete);\n}\n\nstatic int tegra_xudc_ep0_standard_req(struct tegra_xudc *xudc,\n\t\t\t\t      struct usb_ctrlrequest *ctrl)\n{\n\tint ret;\n\n\tswitch (ctrl->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_GET_STATUS\\n\");\n\t\tret = tegra_xudc_ep0_get_status(xudc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_ADDRESS:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_SET_ADDRESS\\n\");\n\t\tret = tegra_xudc_ep0_set_address(xudc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_SEL:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_SET_SEL\\n\");\n\t\tret = tegra_xudc_ep0_set_sel(xudc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_SET_ISOCH_DELAY\\n\");\n\t\tret = tegra_xudc_ep0_set_isoch_delay(xudc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_CLEAR/SET_FEATURE\\n\");\n\t\tret = tegra_xudc_ep0_set_feature(xudc, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tdev_dbg(xudc->dev, \"USB_REQ_SET_CONFIGURATION\\n\");\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tret = tegra_xudc_ep0_delegate_req(xudc, ctrl);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void tegra_xudc_handle_ep0_setup_packet(struct tegra_xudc *xudc,\n\t\t\t\t\t       struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t       u16 seq_num)\n{\n\tint ret;\n\n\txudc->setup_seq_num = seq_num;\n\n\t \n\tep_unhalt(xudc, 0);\n\n\t \n\tif (xudc->soc->invalid_seq_num &&\n\t    (seq_num == 0xfffe || seq_num == 0xffff)) {\n\t\tdev_warn(xudc->dev, \"invalid sequence number detected\\n\");\n\t\tep_halt(xudc, 0);\n\t\treturn;\n\t}\n\n\tif (ctrl->wLength)\n\t\txudc->setup_state = (ctrl->bRequestType & USB_DIR_IN) ?\n\t\t\tDATA_STAGE_XFER :  DATA_STAGE_RECV;\n\telse\n\t\txudc->setup_state = STATUS_STAGE_XFER;\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tret = tegra_xudc_ep0_standard_req(xudc, ctrl);\n\telse\n\t\tret = tegra_xudc_ep0_delegate_req(xudc, ctrl);\n\n\tif (ret < 0) {\n\t\tdev_warn(xudc->dev, \"setup request failed: %d\\n\", ret);\n\t\txudc->setup_state = WAIT_FOR_SETUP;\n\t\tep_halt(xudc, 0);\n\t}\n}\n\nstatic void tegra_xudc_handle_ep0_event(struct tegra_xudc *xudc,\n\t\t\t\t\tstruct tegra_xudc_trb *event)\n{\n\tstruct usb_ctrlrequest *ctrl = (struct usb_ctrlrequest *)event;\n\tu16 seq_num = trb_read_seq_num(event);\n\n\tif (xudc->setup_state != WAIT_FOR_SETUP) {\n\t\t \n\t\tmemcpy(&xudc->setup_packet.ctrl_req, ctrl, sizeof(*ctrl));\n\t\txudc->setup_packet.seq_num = seq_num;\n\t\txudc->queued_setup_packet = true;\n\t} else {\n\t\ttegra_xudc_handle_ep0_setup_packet(xudc, ctrl, seq_num);\n\t}\n}\n\nstatic struct tegra_xudc_request *\ntrb_to_request(struct tegra_xudc_ep *ep, struct tegra_xudc_trb *trb)\n{\n\tstruct tegra_xudc_request *req;\n\n\tlist_for_each_entry(req, &ep->queue, list) {\n\t\tif (!req->trbs_queued)\n\t\t\tbreak;\n\n\t\tif (trb_in_request(ep, req, trb))\n\t\t\treturn req;\n\t}\n\n\treturn NULL;\n}\n\nstatic void tegra_xudc_handle_transfer_completion(struct tegra_xudc *xudc,\n\t\t\t\t\t\t  struct tegra_xudc_ep *ep,\n\t\t\t\t\t\t  struct tegra_xudc_trb *event)\n{\n\tstruct tegra_xudc_request *req;\n\tstruct tegra_xudc_trb *trb;\n\tbool short_packet;\n\n\tshort_packet = (trb_read_cmpl_code(event) ==\n\t\t\tTRB_CMPL_CODE_SHORT_PACKET);\n\n\ttrb = trb_phys_to_virt(ep, trb_read_data_ptr(event));\n\treq = trb_to_request(ep, trb);\n\n\t \n\tif (req && (short_packet || (!trb_read_chain(trb) &&\n\t\t(req->trbs_needed == req->trbs_queued)))) {\n\t\tstruct tegra_xudc_trb *last = req->last_trb;\n\t\tunsigned int residual;\n\n\t\tresidual = trb_read_transfer_len(event);\n\t\treq->usb_req.actual = req->usb_req.length - residual;\n\n\t\tdev_dbg(xudc->dev, \"bytes transferred %u / %u\\n\",\n\t\t\treq->usb_req.actual, req->usb_req.length);\n\n\t\ttegra_xudc_req_done(ep, req, 0);\n\n\t\tif (ep->desc && usb_endpoint_xfer_control(ep->desc))\n\t\t\ttegra_xudc_ep0_req_done(xudc);\n\n\t\t \n\t\tif (short_packet) {\n\t\t\tep->deq_ptr = (last - ep->transfer_ring) + 1;\n\t\t\tif (ep->deq_ptr == XUDC_TRANSFER_RING_SIZE - 1)\n\t\t\t\tep->deq_ptr = 0;\n\t\t}\n\t} else if (!req) {\n\t\tdev_warn(xudc->dev, \"transfer event on dequeued request\\n\");\n\t}\n\n\tif (ep->desc)\n\t\ttegra_xudc_ep_kick_queue(ep);\n}\n\nstatic void tegra_xudc_handle_transfer_event(struct tegra_xudc *xudc,\n\t\t\t\t\t     struct tegra_xudc_trb *event)\n{\n\tunsigned int ep_index = trb_read_endpoint_id(event);\n\tstruct tegra_xudc_ep *ep = &xudc->ep[ep_index];\n\tstruct tegra_xudc_trb *trb;\n\tu16 comp_code;\n\n\tif (ep_ctx_read_state(ep->context) == EP_STATE_DISABLED) {\n\t\tdev_warn(xudc->dev, \"transfer event on disabled EP %u\\n\",\n\t\t\t ep_index);\n\t\treturn;\n\t}\n\n\t \n\ttrb = trb_phys_to_virt(ep, trb_read_data_ptr(event));\n\tcomp_code = trb_read_cmpl_code(event);\n\tif (comp_code != TRB_CMPL_CODE_BABBLE_DETECTED_ERR) {\n\t\tep->deq_ptr = (trb - ep->transfer_ring) + 1;\n\n\t\tif (ep->deq_ptr == XUDC_TRANSFER_RING_SIZE - 1)\n\t\t\tep->deq_ptr = 0;\n\t\tep->ring_full = false;\n\t}\n\n\tswitch (comp_code) {\n\tcase TRB_CMPL_CODE_SUCCESS:\n\tcase TRB_CMPL_CODE_SHORT_PACKET:\n\t\ttegra_xudc_handle_transfer_completion(xudc, ep, event);\n\t\tbreak;\n\tcase TRB_CMPL_CODE_HOST_REJECTED:\n\t\tdev_info(xudc->dev, \"stream rejected on EP %u\\n\", ep_index);\n\n\t\tep->stream_rejected = true;\n\t\tbreak;\n\tcase TRB_CMPL_CODE_PRIME_PIPE_RECEIVED:\n\t\tdev_info(xudc->dev, \"prime pipe received on EP %u\\n\", ep_index);\n\n\t\tif (ep->stream_rejected) {\n\t\t\tep->stream_rejected = false;\n\t\t\t \n\t\t\tep_wait_for_stopped(xudc, ep_index);\n\t\t}\n\t\ttegra_xudc_ep_ring_doorbell(ep);\n\t\tbreak;\n\tcase TRB_CMPL_CODE_BABBLE_DETECTED_ERR:\n\t\t \n\t\tep_wait_for_stopped(xudc, ep_index);\n\t\tep->enq_ptr = ep->deq_ptr;\n\t\ttegra_xudc_ep_nuke(ep, -EIO);\n\t\tfallthrough;\n\tcase TRB_CMPL_CODE_STREAM_NUMP_ERROR:\n\tcase TRB_CMPL_CODE_CTRL_DIR_ERR:\n\tcase TRB_CMPL_CODE_INVALID_STREAM_TYPE_ERR:\n\tcase TRB_CMPL_CODE_RING_UNDERRUN:\n\tcase TRB_CMPL_CODE_RING_OVERRUN:\n\tcase TRB_CMPL_CODE_ISOCH_BUFFER_OVERRUN:\n\tcase TRB_CMPL_CODE_USB_TRANS_ERR:\n\tcase TRB_CMPL_CODE_TRB_ERR:\n\t\tdev_err(xudc->dev, \"completion error %#x on EP %u\\n\",\n\t\t\tcomp_code, ep_index);\n\n\t\tep_halt(xudc, ep_index);\n\t\tbreak;\n\tcase TRB_CMPL_CODE_CTRL_SEQNUM_ERR:\n\t\tdev_info(xudc->dev, \"sequence number error\\n\");\n\n\t\t \n\t\ttegra_xudc_ep_nuke(ep, -EINVAL);\n\t\txudc->setup_state = WAIT_FOR_SETUP;\n\t\tif (!xudc->queued_setup_packet)\n\t\t\tbreak;\n\n\t\ttegra_xudc_handle_ep0_setup_packet(xudc,\n\t\t\t\t\t\t   &xudc->setup_packet.ctrl_req,\n\t\t\t\t\t\t   xudc->setup_packet.seq_num);\n\t\txudc->queued_setup_packet = false;\n\t\tbreak;\n\tcase TRB_CMPL_CODE_STOPPED:\n\t\tdev_dbg(xudc->dev, \"stop completion code on EP %u\\n\",\n\t\t\tep_index);\n\n\t\t \n\t\ttegra_xudc_ep_nuke(ep, -ECONNREFUSED);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(xudc->dev, \"completion event %#x on EP %u\\n\",\n\t\t\tcomp_code, ep_index);\n\t\tbreak;\n\t}\n}\n\nstatic void tegra_xudc_reset(struct tegra_xudc *xudc)\n{\n\tstruct tegra_xudc_ep *ep0 = &xudc->ep[0];\n\tdma_addr_t deq_ptr;\n\tunsigned int i;\n\n\txudc->setup_state = WAIT_FOR_SETUP;\n\txudc->device_state = USB_STATE_DEFAULT;\n\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\tep_unpause_all(xudc);\n\n\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++)\n\t\ttegra_xudc_ep_nuke(&xudc->ep[i], -ESHUTDOWN);\n\n\t \n\tep0->deq_ptr = ep0->enq_ptr;\n\tep0->ring_full = false;\n\n\txudc->setup_seq_num = 0;\n\txudc->queued_setup_packet = false;\n\n\tep_ctx_write_rsvd(ep0->context, 0);\n\tep_ctx_write_partial_td(ep0->context, 0);\n\tep_ctx_write_splitxstate(ep0->context, 0);\n\tep_ctx_write_seq_num(ep0->context, 0);\n\n\tdeq_ptr = trb_virt_to_phys(ep0, &ep0->transfer_ring[ep0->deq_ptr]);\n\n\tif (!dma_mapping_error(xudc->dev, deq_ptr)) {\n\t\tep_ctx_write_deq_ptr(ep0->context, deq_ptr);\n\t\tep_ctx_write_dcs(ep0->context, ep0->pcs);\n\t}\n\n\tep_unhalt_all(xudc);\n\tep_reload(xudc, 0);\n\tep_unpause(xudc, 0);\n}\n\nstatic void tegra_xudc_port_connect(struct tegra_xudc *xudc)\n{\n\tstruct tegra_xudc_ep *ep0 = &xudc->ep[0];\n\tu16 maxpacket;\n\tu32 val;\n\n\tval = (xudc_readl(xudc, PORTSC) & PORTSC_PS_MASK) >> PORTSC_PS_SHIFT;\n\tswitch (val) {\n\tcase PORTSC_PS_LS:\n\t\txudc->gadget.speed = USB_SPEED_LOW;\n\t\tbreak;\n\tcase PORTSC_PS_FS:\n\t\txudc->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\tcase PORTSC_PS_HS:\n\t\txudc->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase PORTSC_PS_SS:\n\t\txudc->gadget.speed = USB_SPEED_SUPER;\n\t\tbreak;\n\tdefault:\n\t\txudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\n\txudc->device_state = USB_STATE_DEFAULT;\n\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\txudc->setup_state = WAIT_FOR_SETUP;\n\n\tif (xudc->gadget.speed == USB_SPEED_SUPER)\n\t\tmaxpacket = 512;\n\telse\n\t\tmaxpacket = 64;\n\n\tep_ctx_write_max_packet_size(ep0->context, maxpacket);\n\ttegra_xudc_ep0_desc.wMaxPacketSize = cpu_to_le16(maxpacket);\n\tusb_ep_set_maxpacket_limit(&ep0->usb_ep, maxpacket);\n\n\tif (!xudc->soc->u1_enable) {\n\t\tval = xudc_readl(xudc, PORTPM);\n\t\tval &= ~(PORTPM_U1TIMEOUT_MASK);\n\t\txudc_writel(xudc, val, PORTPM);\n\t}\n\n\tif (!xudc->soc->u2_enable) {\n\t\tval = xudc_readl(xudc, PORTPM);\n\t\tval &= ~(PORTPM_U2TIMEOUT_MASK);\n\t\txudc_writel(xudc, val, PORTPM);\n\t}\n\n\tif (xudc->gadget.speed <= USB_SPEED_HIGH) {\n\t\tval = xudc_readl(xudc, PORTPM);\n\t\tval &= ~(PORTPM_L1S_MASK);\n\t\tif (xudc->soc->lpm_enable)\n\t\t\tval |= PORTPM_L1S(PORTPM_L1S_ACCEPT);\n\t\telse\n\t\t\tval |= PORTPM_L1S(PORTPM_L1S_NYET);\n\t\txudc_writel(xudc, val, PORTPM);\n\t}\n\n\tval = xudc_readl(xudc, ST);\n\tif (val & ST_RC)\n\t\txudc_writel(xudc, ST_RC, ST);\n}\n\nstatic void tegra_xudc_port_disconnect(struct tegra_xudc *xudc)\n{\n\ttegra_xudc_reset(xudc);\n\n\tif (xudc->driver && xudc->driver->disconnect) {\n\t\tspin_unlock(&xudc->lock);\n\t\txudc->driver->disconnect(&xudc->gadget);\n\t\tspin_lock(&xudc->lock);\n\t}\n\n\txudc->device_state = USB_STATE_NOTATTACHED;\n\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\tcomplete(&xudc->disconnect_complete);\n}\n\nstatic void tegra_xudc_port_reset(struct tegra_xudc *xudc)\n{\n\ttegra_xudc_reset(xudc);\n\n\tif (xudc->driver) {\n\t\tspin_unlock(&xudc->lock);\n\t\tusb_gadget_udc_reset(&xudc->gadget, xudc->driver);\n\t\tspin_lock(&xudc->lock);\n\t}\n\n\ttegra_xudc_port_connect(xudc);\n}\n\nstatic void tegra_xudc_port_suspend(struct tegra_xudc *xudc)\n{\n\tdev_dbg(xudc->dev, \"port suspend\\n\");\n\n\txudc->resume_state = xudc->device_state;\n\txudc->device_state = USB_STATE_SUSPENDED;\n\tusb_gadget_set_state(&xudc->gadget, xudc->device_state);\n\n\tif (xudc->driver->suspend) {\n\t\tspin_unlock(&xudc->lock);\n\t\txudc->driver->suspend(&xudc->gadget);\n\t\tspin_lock(&xudc->lock);\n\t}\n}\n\nstatic void tegra_xudc_port_resume(struct tegra_xudc *xudc)\n{\n\tdev_dbg(xudc->dev, \"port resume\\n\");\n\n\ttegra_xudc_resume_device_state(xudc);\n\n\tif (xudc->driver->resume) {\n\t\tspin_unlock(&xudc->lock);\n\t\txudc->driver->resume(&xudc->gadget);\n\t\tspin_lock(&xudc->lock);\n\t}\n}\n\nstatic inline void clear_port_change(struct tegra_xudc *xudc, u32 flag)\n{\n\tu32 val;\n\n\tval = xudc_readl(xudc, PORTSC);\n\tval &= ~PORTSC_CHANGE_MASK;\n\tval |= flag;\n\txudc_writel(xudc, val, PORTSC);\n}\n\nstatic void __tegra_xudc_handle_port_status(struct tegra_xudc *xudc)\n{\n\tu32 portsc, porthalt;\n\n\tporthalt = xudc_readl(xudc, PORTHALT);\n\tif ((porthalt & PORTHALT_STCHG_REQ) &&\n\t    (porthalt & PORTHALT_HALT_LTSSM)) {\n\t\tdev_dbg(xudc->dev, \"STCHG_REQ, PORTHALT = %#x\\n\", porthalt);\n\t\tporthalt &= ~PORTHALT_HALT_LTSSM;\n\t\txudc_writel(xudc, porthalt, PORTHALT);\n\t}\n\n\tportsc = xudc_readl(xudc, PORTSC);\n\tif ((portsc & PORTSC_PRC) && (portsc & PORTSC_PR)) {\n\t\tdev_dbg(xudc->dev, \"PRC, PR, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_PRC | PORTSC_PED);\n#define TOGGLE_VBUS_WAIT_MS 100\n\t\tif (xudc->soc->port_reset_quirk) {\n\t\t\tschedule_delayed_work(&xudc->port_reset_war_work,\n\t\t\t\tmsecs_to_jiffies(TOGGLE_VBUS_WAIT_MS));\n\t\t\txudc->wait_for_sec_prc = 1;\n\t\t}\n\t}\n\n\tif ((portsc & PORTSC_PRC) && !(portsc & PORTSC_PR)) {\n\t\tdev_dbg(xudc->dev, \"PRC, Not PR, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_PRC | PORTSC_PED);\n\t\ttegra_xudc_port_reset(xudc);\n\t\tcancel_delayed_work(&xudc->port_reset_war_work);\n\t\txudc->wait_for_sec_prc = 0;\n\t}\n\n\tportsc = xudc_readl(xudc, PORTSC);\n\tif (portsc & PORTSC_WRC) {\n\t\tdev_dbg(xudc->dev, \"WRC, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_WRC | PORTSC_PED);\n\t\tif (!(xudc_readl(xudc, PORTSC) & PORTSC_WPR))\n\t\t\ttegra_xudc_port_reset(xudc);\n\t}\n\n\tportsc = xudc_readl(xudc, PORTSC);\n\tif (portsc & PORTSC_CSC) {\n\t\tdev_dbg(xudc->dev, \"CSC, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_CSC);\n\n\t\tif (portsc & PORTSC_CCS)\n\t\t\ttegra_xudc_port_connect(xudc);\n\t\telse\n\t\t\ttegra_xudc_port_disconnect(xudc);\n\n\t\tif (xudc->wait_csc) {\n\t\t\tcancel_delayed_work(&xudc->plc_reset_work);\n\t\t\txudc->wait_csc = false;\n\t\t}\n\t}\n\n\tportsc = xudc_readl(xudc, PORTSC);\n\tif (portsc & PORTSC_PLC) {\n\t\tu32 pls = (portsc & PORTSC_PLS_MASK) >> PORTSC_PLS_SHIFT;\n\n\t\tdev_dbg(xudc->dev, \"PLC, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_PLC);\n\t\tswitch (pls) {\n\t\tcase PORTSC_PLS_U3:\n\t\t\ttegra_xudc_port_suspend(xudc);\n\t\t\tbreak;\n\t\tcase PORTSC_PLS_U0:\n\t\t\tif (xudc->gadget.speed < USB_SPEED_SUPER)\n\t\t\t\ttegra_xudc_port_resume(xudc);\n\t\t\tbreak;\n\t\tcase PORTSC_PLS_RESUME:\n\t\t\tif (xudc->gadget.speed == USB_SPEED_SUPER)\n\t\t\t\ttegra_xudc_port_resume(xudc);\n\t\t\tbreak;\n\t\tcase PORTSC_PLS_INACTIVE:\n\t\t\tschedule_delayed_work(&xudc->plc_reset_work,\n\t\t\t\t\tmsecs_to_jiffies(TOGGLE_VBUS_WAIT_MS));\n\t\t\txudc->wait_csc = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (portsc & PORTSC_CEC) {\n\t\tdev_warn(xudc->dev, \"CEC, PORTSC = %#x\\n\", portsc);\n\t\tclear_port_change(xudc, PORTSC_CEC);\n\t}\n\n\tdev_dbg(xudc->dev, \"PORTSC = %#x\\n\", xudc_readl(xudc, PORTSC));\n}\n\nstatic void tegra_xudc_handle_port_status(struct tegra_xudc *xudc)\n{\n\twhile ((xudc_readl(xudc, PORTSC) & PORTSC_CHANGE_MASK) ||\n\t       (xudc_readl(xudc, PORTHALT) & PORTHALT_STCHG_REQ))\n\t\t__tegra_xudc_handle_port_status(xudc);\n}\n\nstatic void tegra_xudc_handle_event(struct tegra_xudc *xudc,\n\t\t\t\t    struct tegra_xudc_trb *event)\n{\n\tu32 type = trb_read_type(event);\n\n\tdump_trb(xudc, \"EVENT\", event);\n\n\tswitch (type) {\n\tcase TRB_TYPE_PORT_STATUS_CHANGE_EVENT:\n\t\ttegra_xudc_handle_port_status(xudc);\n\t\tbreak;\n\tcase TRB_TYPE_TRANSFER_EVENT:\n\t\ttegra_xudc_handle_transfer_event(xudc, event);\n\t\tbreak;\n\tcase TRB_TYPE_SETUP_PACKET_EVENT:\n\t\ttegra_xudc_handle_ep0_event(xudc, event);\n\t\tbreak;\n\tdefault:\n\t\tdev_info(xudc->dev, \"Unrecognized TRB type = %#x\\n\", type);\n\t\tbreak;\n\t}\n}\n\nstatic void tegra_xudc_process_event_ring(struct tegra_xudc *xudc)\n{\n\tstruct tegra_xudc_trb *event;\n\tdma_addr_t erdp;\n\n\twhile (true) {\n\t\tevent = xudc->event_ring[xudc->event_ring_index] +\n\t\t\txudc->event_ring_deq_ptr;\n\n\t\tif (trb_read_cycle(event) != xudc->ccs)\n\t\t\tbreak;\n\n\t\ttegra_xudc_handle_event(xudc, event);\n\n\t\txudc->event_ring_deq_ptr++;\n\t\tif (xudc->event_ring_deq_ptr == XUDC_EVENT_RING_SIZE) {\n\t\t\txudc->event_ring_deq_ptr = 0;\n\t\t\txudc->event_ring_index++;\n\t\t}\n\n\t\tif (xudc->event_ring_index == XUDC_NR_EVENT_RINGS) {\n\t\t\txudc->event_ring_index = 0;\n\t\t\txudc->ccs = !xudc->ccs;\n\t\t}\n\t}\n\n\terdp = xudc->event_ring_phys[xudc->event_ring_index] +\n\t\txudc->event_ring_deq_ptr * sizeof(*event);\n\n\txudc_writel(xudc, upper_32_bits(erdp), ERDPHI);\n\txudc_writel(xudc, lower_32_bits(erdp) | ERDPLO_EHB, ERDPLO);\n}\n\nstatic irqreturn_t tegra_xudc_irq(int irq, void *data)\n{\n\tstruct tegra_xudc *xudc = data;\n\tunsigned long flags;\n\tu32 val;\n\n\tval = xudc_readl(xudc, ST);\n\tif (!(val & ST_IP))\n\t\treturn IRQ_NONE;\n\txudc_writel(xudc, ST_IP, ST);\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\ttegra_xudc_process_event_ring(xudc);\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_xudc_alloc_ep(struct tegra_xudc *xudc, unsigned int index)\n{\n\tstruct tegra_xudc_ep *ep = &xudc->ep[index];\n\n\tep->xudc = xudc;\n\tep->index = index;\n\tep->context = &xudc->ep_context[index];\n\tINIT_LIST_HEAD(&ep->queue);\n\n\t \n\tif (index == 1)\n\t\treturn 0;\n\n\tep->transfer_ring = dma_pool_alloc(xudc->transfer_ring_pool,\n\t\t\t\t\t   GFP_KERNEL,\n\t\t\t\t\t   &ep->transfer_ring_phys);\n\tif (!ep->transfer_ring)\n\t\treturn -ENOMEM;\n\n\tif (index) {\n\t\tsnprintf(ep->name, sizeof(ep->name), \"ep%u%s\", index / 2,\n\t\t\t (index % 2 == 0) ? \"out\" : \"in\");\n\t\tep->usb_ep.name = ep->name;\n\t\tusb_ep_set_maxpacket_limit(&ep->usb_ep, 1024);\n\t\tep->usb_ep.max_streams = 16;\n\t\tep->usb_ep.ops = &tegra_xudc_ep_ops;\n\t\tep->usb_ep.caps.type_bulk = true;\n\t\tep->usb_ep.caps.type_int = true;\n\t\tif (index & 1)\n\t\t\tep->usb_ep.caps.dir_in = true;\n\t\telse\n\t\t\tep->usb_ep.caps.dir_out = true;\n\t\tlist_add_tail(&ep->usb_ep.ep_list, &xudc->gadget.ep_list);\n\t} else {\n\t\tstrscpy(ep->name, \"ep0\", 3);\n\t\tep->usb_ep.name = ep->name;\n\t\tusb_ep_set_maxpacket_limit(&ep->usb_ep, 512);\n\t\tep->usb_ep.ops = &tegra_xudc_ep0_ops;\n\t\tep->usb_ep.caps.type_control = true;\n\t\tep->usb_ep.caps.dir_in = true;\n\t\tep->usb_ep.caps.dir_out = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_xudc_free_ep(struct tegra_xudc *xudc, unsigned int index)\n{\n\tstruct tegra_xudc_ep *ep = &xudc->ep[index];\n\n\t \n\tif (index == 1)\n\t\treturn;\n\n\tdma_pool_free(xudc->transfer_ring_pool, ep->transfer_ring,\n\t\t      ep->transfer_ring_phys);\n}\n\nstatic int tegra_xudc_alloc_eps(struct tegra_xudc *xudc)\n{\n\tstruct usb_request *req;\n\tunsigned int i;\n\tint err;\n\n\txudc->ep_context =\n\t\tdma_alloc_coherent(xudc->dev, XUDC_NR_EPS *\n\t\t\t\t    sizeof(*xudc->ep_context),\n\t\t\t\t    &xudc->ep_context_phys, GFP_KERNEL);\n\tif (!xudc->ep_context)\n\t\treturn -ENOMEM;\n\n\txudc->transfer_ring_pool =\n\t\tdmam_pool_create(dev_name(xudc->dev), xudc->dev,\n\t\t\t\t XUDC_TRANSFER_RING_SIZE *\n\t\t\t\t sizeof(struct tegra_xudc_trb),\n\t\t\t\t sizeof(struct tegra_xudc_trb), 0);\n\tif (!xudc->transfer_ring_pool) {\n\t\terr = -ENOMEM;\n\t\tgoto free_ep_context;\n\t}\n\n\tINIT_LIST_HEAD(&xudc->gadget.ep_list);\n\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++) {\n\t\terr = tegra_xudc_alloc_ep(xudc, i);\n\t\tif (err < 0)\n\t\t\tgoto free_eps;\n\t}\n\n\treq = tegra_xudc_ep_alloc_request(&xudc->ep[0].usb_ep, GFP_KERNEL);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tgoto free_eps;\n\t}\n\txudc->ep0_req = to_xudc_req(req);\n\n\treturn 0;\n\nfree_eps:\n\tfor (; i > 0; i--)\n\t\ttegra_xudc_free_ep(xudc, i - 1);\nfree_ep_context:\n\tdma_free_coherent(xudc->dev, XUDC_NR_EPS * sizeof(*xudc->ep_context),\n\t\t\t  xudc->ep_context, xudc->ep_context_phys);\n\treturn err;\n}\n\nstatic void tegra_xudc_init_eps(struct tegra_xudc *xudc)\n{\n\txudc_writel(xudc, lower_32_bits(xudc->ep_context_phys), ECPLO);\n\txudc_writel(xudc, upper_32_bits(xudc->ep_context_phys), ECPHI);\n}\n\nstatic void tegra_xudc_free_eps(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\n\ttegra_xudc_ep_free_request(&xudc->ep[0].usb_ep,\n\t\t\t\t   &xudc->ep0_req->usb_req);\n\n\tfor (i = 0; i < ARRAY_SIZE(xudc->ep); i++)\n\t\ttegra_xudc_free_ep(xudc, i);\n\n\tdma_free_coherent(xudc->dev, XUDC_NR_EPS * sizeof(*xudc->ep_context),\n\t\t\t  xudc->ep_context, xudc->ep_context_phys);\n}\n\nstatic int tegra_xudc_alloc_event_ring(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xudc->event_ring); i++) {\n\t\txudc->event_ring[i] =\n\t\t\tdma_alloc_coherent(xudc->dev, XUDC_EVENT_RING_SIZE *\n\t\t\t\t\t   sizeof(*xudc->event_ring[i]),\n\t\t\t\t\t   &xudc->event_ring_phys[i],\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!xudc->event_ring[i])\n\t\t\tgoto free_dma;\n\t}\n\n\treturn 0;\n\nfree_dma:\n\tfor (; i > 0; i--) {\n\t\tdma_free_coherent(xudc->dev, XUDC_EVENT_RING_SIZE *\n\t\t\t\t  sizeof(*xudc->event_ring[i - 1]),\n\t\t\t\t  xudc->event_ring[i - 1],\n\t\t\t\t  xudc->event_ring_phys[i - 1]);\n\t}\n\treturn -ENOMEM;\n}\n\nstatic void tegra_xudc_init_event_ring(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\tu32 val;\n\n\tfor (i = 0; i < ARRAY_SIZE(xudc->event_ring); i++) {\n\t\tmemset(xudc->event_ring[i], 0, XUDC_EVENT_RING_SIZE *\n\t\t       sizeof(*xudc->event_ring[i]));\n\n\t\tval = xudc_readl(xudc, ERSTSZ);\n\t\tval &= ~(ERSTSZ_ERSTXSZ_MASK << ERSTSZ_ERSTXSZ_SHIFT(i));\n\t\tval |= XUDC_EVENT_RING_SIZE << ERSTSZ_ERSTXSZ_SHIFT(i);\n\t\txudc_writel(xudc, val, ERSTSZ);\n\n\t\txudc_writel(xudc, lower_32_bits(xudc->event_ring_phys[i]),\n\t\t\t    ERSTXBALO(i));\n\t\txudc_writel(xudc, upper_32_bits(xudc->event_ring_phys[i]),\n\t\t\t    ERSTXBAHI(i));\n\t}\n\n\tval = lower_32_bits(xudc->event_ring_phys[0]);\n\txudc_writel(xudc, val, ERDPLO);\n\tval |= EREPLO_ECS;\n\txudc_writel(xudc, val, EREPLO);\n\n\tval = upper_32_bits(xudc->event_ring_phys[0]);\n\txudc_writel(xudc, val, ERDPHI);\n\txudc_writel(xudc, val, EREPHI);\n\n\txudc->ccs = true;\n\txudc->event_ring_index = 0;\n\txudc->event_ring_deq_ptr = 0;\n}\n\nstatic void tegra_xudc_free_event_ring(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(xudc->event_ring); i++) {\n\t\tdma_free_coherent(xudc->dev, XUDC_EVENT_RING_SIZE *\n\t\t\t\t  sizeof(*xudc->event_ring[i]),\n\t\t\t\t  xudc->event_ring[i],\n\t\t\t\t  xudc->event_ring_phys[i]);\n\t}\n}\n\nstatic void tegra_xudc_fpci_ipfs_init(struct tegra_xudc *xudc)\n{\n\tu32 val;\n\n\tif (xudc->soc->has_ipfs) {\n\t\tval = ipfs_readl(xudc, XUSB_DEV_CONFIGURATION_0);\n\t\tval |= XUSB_DEV_CONFIGURATION_0_EN_FPCI;\n\t\tipfs_writel(xudc, val, XUSB_DEV_CONFIGURATION_0);\n\t\tusleep_range(10, 15);\n\t}\n\n\t \n\tval = XUSB_DEV_CFG_1_IO_SPACE_EN | XUSB_DEV_CFG_1_MEMORY_SPACE_EN |\n\t\tXUSB_DEV_CFG_1_BUS_MASTER_EN;\n\tfpci_writel(xudc, val, XUSB_DEV_CFG_1);\n\n\t \n\tval = fpci_readl(xudc, XUSB_DEV_CFG_4);\n\tval &= ~(XUSB_DEV_CFG_4_BASE_ADDR_MASK);\n\tval |= xudc->phys_base & (XUSB_DEV_CFG_4_BASE_ADDR_MASK);\n\n\tfpci_writel(xudc, val, XUSB_DEV_CFG_4);\n\tfpci_writel(xudc, upper_32_bits(xudc->phys_base), XUSB_DEV_CFG_5);\n\n\tusleep_range(100, 200);\n\n\tif (xudc->soc->has_ipfs) {\n\t\t \n\t\tval = ipfs_readl(xudc, XUSB_DEV_INTR_MASK_0);\n\t\tval |= XUSB_DEV_INTR_MASK_0_IP_INT_MASK;\n\t\tipfs_writel(xudc, val, XUSB_DEV_INTR_MASK_0);\n\t}\n}\n\nstatic void tegra_xudc_device_params_init(struct tegra_xudc *xudc)\n{\n\tu32 val, imod;\n\n\tif (xudc->soc->has_ipfs) {\n\t\tval = xudc_readl(xudc, BLCG);\n\t\tval |= BLCG_ALL;\n\t\tval &= ~(BLCG_DFPCI | BLCG_UFPCI | BLCG_FE |\n\t\t\t\tBLCG_COREPLL_PWRDN);\n\t\tval |= BLCG_IOPLL_0_PWRDN;\n\t\tval |= BLCG_IOPLL_1_PWRDN;\n\t\tval |= BLCG_IOPLL_2_PWRDN;\n\n\t\txudc_writel(xudc, val, BLCG);\n\t}\n\n\tif (xudc->soc->port_speed_quirk)\n\t\ttegra_xudc_limit_port_speed(xudc);\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_PADCTL4);\n\tval &= ~(SSPX_CORE_PADCTL4_RXDAT_VLD_TIMEOUT_U3_MASK);\n\tval |= SSPX_CORE_PADCTL4_RXDAT_VLD_TIMEOUT_U3(0x5dc0);\n\txudc_writel(xudc, val, SSPX_CORE_PADCTL4);\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_CNT0);\n\tval &= ~(SSPX_CORE_CNT0_PING_TBURST_MASK);\n\tval |= SSPX_CORE_CNT0_PING_TBURST(0xa);\n\txudc_writel(xudc, val, SSPX_CORE_CNT0);\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_CNT30);\n\tval &= ~(SSPX_CORE_CNT30_LMPITP_TIMER_MASK);\n\tval |= SSPX_CORE_CNT30_LMPITP_TIMER(0x978);\n\txudc_writel(xudc, val, SSPX_CORE_CNT30);\n\n\tif (xudc->soc->lpm_enable) {\n\t\t \n\t\tval = xudc_readl(xudc, HSFSPI_COUNT13);\n\t\tval &= ~(HSFSPI_COUNT13_U2_RESUME_K_DURATION_MASK);\n\t\tval |= HSFSPI_COUNT13_U2_RESUME_K_DURATION(0x2c88);\n\t\txudc_writel(xudc, val, HSFSPI_COUNT13);\n\t}\n\n\t \n\tval = xudc_readl(xudc, SSPX_CORE_CNT32);\n\tval &= ~(SSPX_CORE_CNT32_POLL_TBURST_MAX_MASK);\n\tval |= SSPX_CORE_CNT32_POLL_TBURST_MAX(0xb0);\n\txudc_writel(xudc, val, SSPX_CORE_CNT32);\n\n\t \n\tval = xudc_readl(xudc, CFG_DEV_FE);\n\tval &= ~(CFG_DEV_FE_PORTREGSEL_MASK);\n\tval |= CFG_DEV_FE_PORTREGSEL(CFG_DEV_FE_PORTREGSEL_HSFS_PI);\n\txudc_writel(xudc, val, CFG_DEV_FE);\n\n\tval = xudc_readl(xudc, PORTSC);\n\tval &= ~(PORTSC_CHANGE_MASK | PORTSC_PLS_MASK);\n\tval |= PORTSC_LWS | PORTSC_PLS(PORTSC_PLS_RXDETECT);\n\txudc_writel(xudc, val, PORTSC);\n\n\t \n\tval = xudc_readl(xudc, CFG_DEV_FE);\n\tval &= ~(CFG_DEV_FE_PORTREGSEL_MASK);\n\tval |= CFG_DEV_FE_PORTREGSEL_SS_PI & CFG_DEV_FE_PORTREGSEL_MASK;\n\txudc_writel(xudc, val, CFG_DEV_FE);\n\n\tval = xudc_readl(xudc, PORTSC);\n\tval &= ~(PORTSC_CHANGE_MASK | PORTSC_PLS_MASK);\n\tval |= PORTSC_LWS | PORTSC_PLS(PORTSC_PLS_RXDETECT);\n\txudc_writel(xudc, val, PORTSC);\n\n\t \n\tval = xudc_readl(xudc, CFG_DEV_FE);\n\tval &= ~(CFG_DEV_FE_PORTREGSEL_MASK);\n\txudc_writel(xudc, val, CFG_DEV_FE);\n\n\t \n\tval = xudc_readl(xudc, CFG_DEV_FE);\n\tval |= CFG_DEV_FE_INFINITE_SS_RETRY;\n\txudc_writel(xudc, val, CFG_DEV_FE);\n\n\t \n\timod = XUDC_INTERRUPT_MODERATION_US * 4;\n\tval = xudc_readl(xudc, RT_IMOD);\n\tval &= ~((RT_IMOD_IMODI_MASK) | (RT_IMOD_IMODC_MASK));\n\tval |= (RT_IMOD_IMODI(imod) | RT_IMOD_IMODC(imod));\n\txudc_writel(xudc, val, RT_IMOD);\n\n\t \n\tval = xudc_readl(xudc, CFG_DEV_SSPI_XFER);\n\tval &= ~(CFG_DEV_SSPI_XFER_ACKTIMEOUT_MASK);\n\tval |= CFG_DEV_SSPI_XFER_ACKTIMEOUT(0xf000);\n\txudc_writel(xudc, val, CFG_DEV_SSPI_XFER);\n}\n\nstatic int tegra_xudc_phy_get(struct tegra_xudc *xudc)\n{\n\tint err = 0, usb3;\n\tunsigned int i;\n\n\txudc->utmi_phy = devm_kcalloc(xudc->dev, xudc->soc->num_phys,\n\t\t\t\t\t   sizeof(*xudc->utmi_phy), GFP_KERNEL);\n\tif (!xudc->utmi_phy)\n\t\treturn -ENOMEM;\n\n\txudc->usb3_phy = devm_kcalloc(xudc->dev, xudc->soc->num_phys,\n\t\t\t\t\t   sizeof(*xudc->usb3_phy), GFP_KERNEL);\n\tif (!xudc->usb3_phy)\n\t\treturn -ENOMEM;\n\n\txudc->usbphy = devm_kcalloc(xudc->dev, xudc->soc->num_phys,\n\t\t\t\t\t   sizeof(*xudc->usbphy), GFP_KERNEL);\n\tif (!xudc->usbphy)\n\t\treturn -ENOMEM;\n\n\txudc->vbus_nb.notifier_call = tegra_xudc_vbus_notify;\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\tchar phy_name[] = \"usb.-.\";\n\n\t\t \n\t\tsnprintf(phy_name, sizeof(phy_name), \"usb2-%d\", i);\n\t\txudc->utmi_phy[i] = devm_phy_optional_get(xudc->dev, phy_name);\n\t\tif (IS_ERR(xudc->utmi_phy[i])) {\n\t\t\terr = PTR_ERR(xudc->utmi_phy[i]);\n\t\t\tdev_err_probe(xudc->dev, err,\n\t\t\t\t      \"failed to get usb2-%d PHY\\n\", i);\n\t\t\tgoto clean_up;\n\t\t} else if (xudc->utmi_phy[i]) {\n\t\t\t \n\t\t\txudc->usbphy[i] = devm_usb_get_phy_by_node(xudc->dev,\n\t\t\t\t\t\txudc->utmi_phy[i]->dev.of_node,\n\t\t\t\t\t\tNULL);\n\t\t\tif (IS_ERR(xudc->usbphy[i])) {\n\t\t\t\terr = PTR_ERR(xudc->usbphy[i]);\n\t\t\t\tdev_err_probe(xudc->dev, err,\n\t\t\t\t\t      \"failed to get usbphy-%d\\n\", i);\n\t\t\t\tgoto clean_up;\n\t\t\t}\n\t\t} else if (!xudc->utmi_phy[i]) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tusb3 = tegra_xusb_padctl_get_usb3_companion(xudc->padctl, i);\n\t\tif (usb3 < 0)\n\t\t\tcontinue;\n\n\t\tsnprintf(phy_name, sizeof(phy_name), \"usb3-%d\", usb3);\n\t\txudc->usb3_phy[i] = devm_phy_optional_get(xudc->dev, phy_name);\n\t\tif (IS_ERR(xudc->usb3_phy[i])) {\n\t\t\terr = PTR_ERR(xudc->usb3_phy[i]);\n\t\t\tdev_err_probe(xudc->dev, err,\n\t\t\t\t      \"failed to get usb3-%d PHY\\n\", usb3);\n\t\t\tgoto clean_up;\n\t\t} else if (xudc->usb3_phy[i])\n\t\t\tdev_dbg(xudc->dev, \"usb3-%d PHY registered\", usb3);\n\t}\n\n\treturn err;\n\nclean_up:\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\txudc->usb3_phy[i] = NULL;\n\t\txudc->utmi_phy[i] = NULL;\n\t\txudc->usbphy[i] = NULL;\n\t}\n\n\treturn err;\n}\n\nstatic void tegra_xudc_phy_exit(struct tegra_xudc *xudc)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\tphy_exit(xudc->usb3_phy[i]);\n\t\tphy_exit(xudc->utmi_phy[i]);\n\t}\n}\n\nstatic int tegra_xudc_phy_init(struct tegra_xudc *xudc)\n{\n\tint err;\n\tunsigned int i;\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\terr = phy_init(xudc->utmi_phy[i]);\n\t\tif (err < 0) {\n\t\t\tdev_err(xudc->dev, \"UTMI PHY #%u initialization failed: %d\\n\", i, err);\n\t\t\tgoto exit_phy;\n\t\t}\n\n\t\terr = phy_init(xudc->usb3_phy[i]);\n\t\tif (err < 0) {\n\t\t\tdev_err(xudc->dev, \"USB3 PHY #%u initialization failed: %d\\n\", i, err);\n\t\t\tgoto exit_phy;\n\t\t}\n\t}\n\treturn 0;\n\nexit_phy:\n\ttegra_xudc_phy_exit(xudc);\n\treturn err;\n}\n\nstatic const char * const tegra210_xudc_supply_names[] = {\n\t\"hvdd-usb\",\n\t\"avddio-usb\",\n};\n\nstatic const char * const tegra210_xudc_clock_names[] = {\n\t\"dev\",\n\t\"ss\",\n\t\"ss_src\",\n\t\"hs_src\",\n\t\"fs_src\",\n};\n\nstatic const char * const tegra186_xudc_clock_names[] = {\n\t\"dev\",\n\t\"ss\",\n\t\"ss_src\",\n\t\"fs_src\",\n};\n\nstatic struct tegra_xudc_soc tegra210_xudc_soc_data = {\n\t.supply_names = tegra210_xudc_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra210_xudc_supply_names),\n\t.clock_names = tegra210_xudc_clock_names,\n\t.num_clks = ARRAY_SIZE(tegra210_xudc_clock_names),\n\t.num_phys = 4,\n\t.u1_enable = false,\n\t.u2_enable = true,\n\t.lpm_enable = false,\n\t.invalid_seq_num = true,\n\t.pls_quirk = true,\n\t.port_reset_quirk = true,\n\t.port_speed_quirk = false,\n\t.has_ipfs = true,\n};\n\nstatic struct tegra_xudc_soc tegra186_xudc_soc_data = {\n\t.clock_names = tegra186_xudc_clock_names,\n\t.num_clks = ARRAY_SIZE(tegra186_xudc_clock_names),\n\t.num_phys = 4,\n\t.u1_enable = true,\n\t.u2_enable = true,\n\t.lpm_enable = false,\n\t.invalid_seq_num = false,\n\t.pls_quirk = false,\n\t.port_reset_quirk = false,\n\t.port_speed_quirk = false,\n\t.has_ipfs = false,\n};\n\nstatic struct tegra_xudc_soc tegra194_xudc_soc_data = {\n\t.clock_names = tegra186_xudc_clock_names,\n\t.num_clks = ARRAY_SIZE(tegra186_xudc_clock_names),\n\t.num_phys = 4,\n\t.u1_enable = true,\n\t.u2_enable = true,\n\t.lpm_enable = true,\n\t.invalid_seq_num = false,\n\t.pls_quirk = false,\n\t.port_reset_quirk = false,\n\t.port_speed_quirk = true,\n\t.has_ipfs = false,\n};\n\nstatic struct tegra_xudc_soc tegra234_xudc_soc_data = {\n\t.clock_names = tegra186_xudc_clock_names,\n\t.num_clks = ARRAY_SIZE(tegra186_xudc_clock_names),\n\t.num_phys = 4,\n\t.u1_enable = true,\n\t.u2_enable = true,\n\t.lpm_enable = true,\n\t.invalid_seq_num = false,\n\t.pls_quirk = false,\n\t.port_reset_quirk = false,\n\t.has_ipfs = false,\n};\n\nstatic const struct of_device_id tegra_xudc_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra210-xudc\",\n\t\t.data = &tegra210_xudc_soc_data\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra186-xudc\",\n\t\t.data = &tegra186_xudc_soc_data\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra194-xudc\",\n\t\t.data = &tegra194_xudc_soc_data\n\t},\n\t{\n\t\t.compatible = \"nvidia,tegra234-xudc\",\n\t\t.data = &tegra234_xudc_soc_data\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra_xudc_of_match);\n\nstatic void tegra_xudc_powerdomain_remove(struct tegra_xudc *xudc)\n{\n\tif (xudc->genpd_dl_ss)\n\t\tdevice_link_del(xudc->genpd_dl_ss);\n\tif (xudc->genpd_dl_device)\n\t\tdevice_link_del(xudc->genpd_dl_device);\n\tif (xudc->genpd_dev_ss)\n\t\tdev_pm_domain_detach(xudc->genpd_dev_ss, true);\n\tif (xudc->genpd_dev_device)\n\t\tdev_pm_domain_detach(xudc->genpd_dev_device, true);\n}\n\nstatic int tegra_xudc_powerdomain_init(struct tegra_xudc *xudc)\n{\n\tstruct device *dev = xudc->dev;\n\tint err;\n\n\txudc->genpd_dev_device = dev_pm_domain_attach_by_name(dev, \"dev\");\n\tif (IS_ERR(xudc->genpd_dev_device)) {\n\t\terr = PTR_ERR(xudc->genpd_dev_device);\n\t\tdev_err(dev, \"failed to get device power domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\txudc->genpd_dev_ss = dev_pm_domain_attach_by_name(dev, \"ss\");\n\tif (IS_ERR(xudc->genpd_dev_ss)) {\n\t\terr = PTR_ERR(xudc->genpd_dev_ss);\n\t\tdev_err(dev, \"failed to get SuperSpeed power domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\txudc->genpd_dl_device = device_link_add(dev, xudc->genpd_dev_device,\n\t\t\t\t\t\tDL_FLAG_PM_RUNTIME |\n\t\t\t\t\t\tDL_FLAG_STATELESS);\n\tif (!xudc->genpd_dl_device) {\n\t\tdev_err(dev, \"failed to add USB device link\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\txudc->genpd_dl_ss = device_link_add(dev, xudc->genpd_dev_ss,\n\t\t\t\t\t    DL_FLAG_PM_RUNTIME |\n\t\t\t\t\t    DL_FLAG_STATELESS);\n\tif (!xudc->genpd_dl_ss) {\n\t\tdev_err(dev, \"failed to add SuperSpeed device link\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xudc_probe(struct platform_device *pdev)\n{\n\tstruct tegra_xudc *xudc;\n\tstruct resource *res;\n\tunsigned int i;\n\tint err;\n\n\txudc = devm_kzalloc(&pdev->dev, sizeof(*xudc), GFP_KERNEL);\n\tif (!xudc)\n\t\treturn -ENOMEM;\n\n\txudc->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, xudc);\n\n\txudc->soc = of_device_get_match_data(&pdev->dev);\n\tif (!xudc->soc)\n\t\treturn -ENODEV;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"base\");\n\txudc->base = devm_ioremap_resource(&pdev->dev, res);\n\tif (IS_ERR(xudc->base))\n\t\treturn PTR_ERR(xudc->base);\n\txudc->phys_base = res->start;\n\n\txudc->fpci = devm_platform_ioremap_resource_byname(pdev, \"fpci\");\n\tif (IS_ERR(xudc->fpci))\n\t\treturn PTR_ERR(xudc->fpci);\n\n\tif (xudc->soc->has_ipfs) {\n\t\txudc->ipfs = devm_platform_ioremap_resource_byname(pdev, \"ipfs\");\n\t\tif (IS_ERR(xudc->ipfs))\n\t\t\treturn PTR_ERR(xudc->ipfs);\n\t}\n\n\txudc->irq = platform_get_irq(pdev, 0);\n\tif (xudc->irq < 0)\n\t\treturn xudc->irq;\n\n\terr = devm_request_irq(&pdev->dev, xudc->irq, tegra_xudc_irq, 0,\n\t\t\t       dev_name(&pdev->dev), xudc);\n\tif (err < 0) {\n\t\tdev_err(xudc->dev, \"failed to claim IRQ#%u: %d\\n\", xudc->irq,\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\txudc->clks = devm_kcalloc(&pdev->dev, xudc->soc->num_clks, sizeof(*xudc->clks),\n\t\t\t\t  GFP_KERNEL);\n\tif (!xudc->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < xudc->soc->num_clks; i++)\n\t\txudc->clks[i].id = xudc->soc->clock_names[i];\n\n\terr = devm_clk_bulk_get(&pdev->dev, xudc->soc->num_clks, xudc->clks);\n\tif (err) {\n\t\tdev_err_probe(xudc->dev, err, \"failed to request clocks\\n\");\n\t\treturn err;\n\t}\n\n\txudc->supplies = devm_kcalloc(&pdev->dev, xudc->soc->num_supplies,\n\t\t\t\t      sizeof(*xudc->supplies), GFP_KERNEL);\n\tif (!xudc->supplies)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < xudc->soc->num_supplies; i++)\n\t\txudc->supplies[i].supply = xudc->soc->supply_names[i];\n\n\terr = devm_regulator_bulk_get(&pdev->dev, xudc->soc->num_supplies,\n\t\t\t\t      xudc->supplies);\n\tif (err) {\n\t\tdev_err_probe(xudc->dev, err, \"failed to request regulators\\n\");\n\t\treturn err;\n\t}\n\n\txudc->padctl = tegra_xusb_padctl_get(&pdev->dev);\n\tif (IS_ERR(xudc->padctl))\n\t\treturn PTR_ERR(xudc->padctl);\n\n\terr = regulator_bulk_enable(xudc->soc->num_supplies, xudc->supplies);\n\tif (err) {\n\t\tdev_err(xudc->dev, \"failed to enable regulators: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\terr = tegra_xudc_phy_get(xudc);\n\tif (err)\n\t\tgoto disable_regulator;\n\n\terr = tegra_xudc_powerdomain_init(xudc);\n\tif (err)\n\t\tgoto put_powerdomains;\n\n\terr = tegra_xudc_phy_init(xudc);\n\tif (err)\n\t\tgoto put_powerdomains;\n\n\terr = tegra_xudc_alloc_event_ring(xudc);\n\tif (err)\n\t\tgoto disable_phy;\n\n\terr = tegra_xudc_alloc_eps(xudc);\n\tif (err)\n\t\tgoto free_event_ring;\n\n\tspin_lock_init(&xudc->lock);\n\n\tinit_completion(&xudc->disconnect_complete);\n\n\tINIT_WORK(&xudc->usb_role_sw_work, tegra_xudc_usb_role_sw_work);\n\n\tINIT_DELAYED_WORK(&xudc->plc_reset_work, tegra_xudc_plc_reset_work);\n\n\tINIT_DELAYED_WORK(&xudc->port_reset_war_work,\n\t\t\t\ttegra_xudc_port_reset_war_work);\n\n\tpm_runtime_enable(&pdev->dev);\n\n\txudc->gadget.ops = &tegra_xudc_gadget_ops;\n\txudc->gadget.ep0 = &xudc->ep[0].usb_ep;\n\txudc->gadget.name = \"tegra-xudc\";\n\txudc->gadget.max_speed = USB_SPEED_SUPER;\n\n\terr = usb_add_gadget_udc(&pdev->dev, &xudc->gadget);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to add USB gadget: %d\\n\", err);\n\t\tgoto free_eps;\n\t}\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\tif (!xudc->usbphy[i])\n\t\t\tcontinue;\n\n\t\tusb_register_notifier(xudc->usbphy[i], &xudc->vbus_nb);\n\t\ttegra_xudc_update_data_role(xudc, xudc->usbphy[i]);\n\t}\n\n\treturn 0;\n\nfree_eps:\n\tpm_runtime_disable(&pdev->dev);\n\ttegra_xudc_free_eps(xudc);\nfree_event_ring:\n\ttegra_xudc_free_event_ring(xudc);\ndisable_phy:\n\ttegra_xudc_phy_exit(xudc);\nput_powerdomains:\n\ttegra_xudc_powerdomain_remove(xudc);\ndisable_regulator:\n\tregulator_bulk_disable(xudc->soc->num_supplies, xudc->supplies);\nput_padctl:\n\ttegra_xusb_padctl_put(xudc->padctl);\n\n\treturn err;\n}\n\nstatic void tegra_xudc_remove(struct platform_device *pdev)\n{\n\tstruct tegra_xudc *xudc = platform_get_drvdata(pdev);\n\tunsigned int i;\n\n\tpm_runtime_get_sync(xudc->dev);\n\n\tcancel_delayed_work_sync(&xudc->plc_reset_work);\n\tcancel_work_sync(&xudc->usb_role_sw_work);\n\n\tusb_del_gadget_udc(&xudc->gadget);\n\n\ttegra_xudc_free_eps(xudc);\n\ttegra_xudc_free_event_ring(xudc);\n\n\ttegra_xudc_powerdomain_remove(xudc);\n\n\tregulator_bulk_disable(xudc->soc->num_supplies, xudc->supplies);\n\n\tfor (i = 0; i < xudc->soc->num_phys; i++) {\n\t\tphy_power_off(xudc->utmi_phy[i]);\n\t\tphy_power_off(xudc->usb3_phy[i]);\n\t}\n\n\ttegra_xudc_phy_exit(xudc);\n\n\tpm_runtime_disable(xudc->dev);\n\tpm_runtime_put(xudc->dev);\n\n\ttegra_xusb_padctl_put(xudc->padctl);\n}\n\nstatic int __maybe_unused tegra_xudc_powergate(struct tegra_xudc *xudc)\n{\n\tunsigned long flags;\n\n\tdev_dbg(xudc->dev, \"entering ELPG\\n\");\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\n\txudc->powergated = true;\n\txudc->saved_regs.ctrl = xudc_readl(xudc, CTRL);\n\txudc->saved_regs.portpm = xudc_readl(xudc, PORTPM);\n\txudc_writel(xudc, 0, CTRL);\n\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tclk_bulk_disable_unprepare(xudc->soc->num_clks, xudc->clks);\n\n\tregulator_bulk_disable(xudc->soc->num_supplies, xudc->supplies);\n\n\tdev_dbg(xudc->dev, \"entering ELPG done\\n\");\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_xudc_unpowergate(struct tegra_xudc *xudc)\n{\n\tunsigned long flags;\n\tint err;\n\n\tdev_dbg(xudc->dev, \"exiting ELPG\\n\");\n\n\terr = regulator_bulk_enable(xudc->soc->num_supplies,\n\t\t\txudc->supplies);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = clk_bulk_prepare_enable(xudc->soc->num_clks, xudc->clks);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra_xudc_fpci_ipfs_init(xudc);\n\n\ttegra_xudc_device_params_init(xudc);\n\n\ttegra_xudc_init_event_ring(xudc);\n\n\ttegra_xudc_init_eps(xudc);\n\n\txudc_writel(xudc, xudc->saved_regs.portpm, PORTPM);\n\txudc_writel(xudc, xudc->saved_regs.ctrl, CTRL);\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\txudc->powergated = false;\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tdev_dbg(xudc->dev, \"exiting ELPG done\\n\");\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_xudc_suspend(struct device *dev)\n{\n\tstruct tegra_xudc *xudc = dev_get_drvdata(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\txudc->suspended = true;\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tflush_work(&xudc->usb_role_sw_work);\n\n\tif (!pm_runtime_status_suspended(dev)) {\n\t\t \n\t\ttegra_xudc_device_mode_off(xudc);\n\t\ttegra_xudc_powergate(xudc);\n\t}\n\n\tpm_runtime_disable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_xudc_resume(struct device *dev)\n{\n\tstruct tegra_xudc *xudc = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint err;\n\n\terr = tegra_xudc_unpowergate(xudc);\n\tif (err < 0)\n\t\treturn err;\n\n\tspin_lock_irqsave(&xudc->lock, flags);\n\txudc->suspended = false;\n\tspin_unlock_irqrestore(&xudc->lock, flags);\n\n\tschedule_work(&xudc->usb_role_sw_work);\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_xudc_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_xudc *xudc = dev_get_drvdata(dev);\n\n\treturn tegra_xudc_powergate(xudc);\n}\n\nstatic int __maybe_unused tegra_xudc_runtime_resume(struct device *dev)\n{\n\tstruct tegra_xudc *xudc = dev_get_drvdata(dev);\n\n\treturn tegra_xudc_unpowergate(xudc);\n}\n\nstatic const struct dev_pm_ops tegra_xudc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_xudc_suspend, tegra_xudc_resume)\n\tSET_RUNTIME_PM_OPS(tegra_xudc_runtime_suspend,\n\t\t\t   tegra_xudc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver tegra_xudc_driver = {\n\t.probe = tegra_xudc_probe,\n\t.remove_new = tegra_xudc_remove,\n\t.driver = {\n\t\t.name = \"tegra-xudc\",\n\t\t.pm = &tegra_xudc_pm_ops,\n\t\t.of_match_table = tegra_xudc_of_match,\n\t},\n};\nmodule_platform_driver(tegra_xudc_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra XUSB Device Controller\");\nMODULE_AUTHOR(\"Andrew Bresticker <abrestic@chromium.org>\");\nMODULE_AUTHOR(\"Hui Fu <hfu@nvidia.com>\");\nMODULE_AUTHOR(\"Nagarjuna Kristam <nkristam@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}