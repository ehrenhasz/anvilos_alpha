{
  "module_name": "omap_udc.c",
  "hash_id": "704c9f4aa46bfb88c708a7fdaf2f33f811b1eb5beb89c680f7d0a3507d51ff1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/omap_udc.c",
  "human_readable_source": "\n \n\n#undef\tDEBUG\n#undef\tVERBOSE\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/prefetch.h>\n#include <linux/io.h>\n\n#include <asm/byteorder.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n#include <asm/mach-types.h>\n\n#include <linux/omap-dma.h>\n#include <linux/platform_data/usb-omap1.h>\n\n#include <linux/soc/ti/omap1-usb.h>\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/soc/ti/omap1-io.h>\n\n#include \"omap_udc.h\"\n\n#undef\tUSB_TRACE\n\n \n#define\tUSE_DMA\n\n \n#define\tUSE_ISO\n\n#define\tDRIVER_DESC\t\"OMAP UDC driver\"\n#define\tDRIVER_VERSION\t\"4 October 2004\"\n\n#define OMAP_DMA_USB_W2FC_TX0\t\t29\n#define OMAP_DMA_USB_W2FC_RX0\t\t26\n\n \n#ifdef\tUSE_ISO\nstatic unsigned fifo_mode = 3;\n#else\nstatic unsigned fifo_mode;\n#endif\n\n \nmodule_param(fifo_mode, uint, 0);\nMODULE_PARM_DESC(fifo_mode, \"endpoint configuration\");\n\n#ifdef\tUSE_DMA\nstatic bool use_dma = 1;\n\n \nmodule_param(use_dma, bool, 0);\nMODULE_PARM_DESC(use_dma, \"enable/disable DMA\");\n#else\t \n\n \n#define\tuse_dma\t\t0\n#endif\t \n\n\nstatic const char driver_name[] = \"omap_udc\";\nstatic const char driver_desc[] = DRIVER_DESC;\n\n \n\n \n\nstatic void use_ep(struct omap_ep *ep, u16 select)\n{\n\tu16\tnum = ep->bEndpointAddress & 0x0f;\n\n\tif (ep->bEndpointAddress & USB_DIR_IN)\n\t\tnum |= UDC_EP_DIR;\n\tomap_writew(num | select, UDC_EP_NUM);\n\t \n}\n\nstatic inline void deselect_ep(void)\n{\n\tu16 w;\n\n\tw = omap_readw(UDC_EP_NUM);\n\tw &= ~UDC_EP_SEL;\n\tomap_writew(w, UDC_EP_NUM);\n\t \n}\n\nstatic void dma_channel_claim(struct omap_ep *ep, unsigned preferred);\n\n \n\nstatic int omap_ep_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct omap_ep\t*ep = container_of(_ep, struct omap_ep, ep);\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\tu16\t\tmaxp;\n\n\t \n\tif (!_ep || !desc\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT\n\t\t\t|| ep->bEndpointAddress != desc->bEndpointAddress\n\t\t\t|| ep->maxpacket < usb_endpoint_maxp(desc)) {\n\t\tDBG(\"%s, bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmaxp = usb_endpoint_maxp(desc);\n\tif ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK\n\t\t\t\t&& maxp != ep->maxpacket)\n\t\t\t|| usb_endpoint_maxp(desc) > ep->maxpacket\n\t\t\t|| !desc->wMaxPacketSize) {\n\t\tDBG(\"%s, bad %s maxpacket\\n\", __func__, _ep->name);\n\t\treturn -ERANGE;\n\t}\n\n#ifdef\tUSE_ISO\n\tif ((desc->bmAttributes == USB_ENDPOINT_XFER_ISOC\n\t\t\t\t&& desc->bInterval != 1)) {\n\t\t \n\t\tDBG(\"%s, unsupported ISO period %dms\\n\", _ep->name,\n\t\t\t\t1 << (desc->bInterval - 1));\n\t\treturn -EDOM;\n\t}\n#else\n\tif (desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tDBG(\"%s, ISO nyet\\n\", _ep->name);\n\t\treturn -EDOM;\n\t}\n#endif\n\n\t \n\tif (ep->bmAttributes != desc->bmAttributes\n\t\t\t&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK\n\t\t\t&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {\n\t\tDBG(\"%s, %s type mismatch\\n\", __func__, _ep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tDBG(\"%s, bogus device state\\n\", __func__);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tep->ep.desc = desc;\n\tep->irqs = 0;\n\tep->stopped = 0;\n\tep->ep.maxpacket = maxp;\n\n\t \n\tep->dma_channel = 0;\n\tep->has_dma = 0;\n\tep->lch = -1;\n\tuse_ep(ep, UDC_EP_SEL);\n\tomap_writew(udc->clr_halt, UDC_CTRL);\n\tep->ackwait = 0;\n\tdeselect_ep();\n\n\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\n\t\tlist_add(&ep->iso, &udc->iso);\n\n\t \n\tif (use_dma && desc->bmAttributes == USB_ENDPOINT_XFER_BULK)\n\t\t \n\t\tdma_channel_claim(ep, 0);\n\n\t \n\tif (desc->bmAttributes != USB_ENDPOINT_XFER_ISOC\n\t\t\t&& !ep->has_dma\n\t\t\t&& !(ep->bEndpointAddress & USB_DIR_IN)) {\n\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\tep->ackwait = 1 + ep->double_buf;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tVDBG(\"%s enabled\\n\", _ep->name);\n\treturn 0;\n}\n\nstatic void nuke(struct omap_ep *, int status);\n\nstatic int omap_ep_disable(struct usb_ep *_ep)\n{\n\tstruct omap_ep\t*ep = container_of(_ep, struct omap_ep, ep);\n\tunsigned long\tflags;\n\n\tif (!_ep || !ep->ep.desc) {\n\t\tDBG(\"%s, %s not enabled\\n\", __func__,\n\t\t\t_ep ? ep->ep.name : NULL);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tep->ep.desc = NULL;\n\tnuke(ep, -ESHUTDOWN);\n\tep->ep.maxpacket = ep->maxpacket;\n\tep->has_dma = 0;\n\tomap_writew(UDC_SET_HALT, UDC_CTRL);\n\tlist_del_init(&ep->iso);\n\tdel_timer(&ep->timer);\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\tVDBG(\"%s disabled\\n\", _ep->name);\n\treturn 0;\n}\n\n \n\nstatic struct usb_request *\nomap_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\n{\n\tstruct omap_req\t*req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void\nomap_free_request(struct usb_ep *ep, struct usb_request *_req)\n{\n\tstruct omap_req\t*req = container_of(_req, struct omap_req, req);\n\n\tkfree(req);\n}\n\n \n\nstatic void\ndone(struct omap_ep *ep, struct omap_req *req, int status)\n{\n\tstruct omap_udc\t\t*udc = ep->udc;\n\tunsigned\t\tstopped = ep->stopped;\n\n\tlist_del_init(&req->queue);\n\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (use_dma && ep->has_dma)\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->req,\n\t\t\t\t(ep->bEndpointAddress & USB_DIR_IN));\n\n#ifndef\tUSB_TRACE\n\tif (status && status != -ESHUTDOWN)\n#endif\n\t\tVDBG(\"complete %s req %p stat %d len %u/%u\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\t \n\tep->stopped = 1;\n\tspin_unlock(&ep->udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->udc->lock);\n\tep->stopped = stopped;\n}\n\n \n\n#define UDC_FIFO_FULL\t\t(UDC_NON_ISO_FIFO_FULL | UDC_ISO_FIFO_FULL)\n#define UDC_FIFO_UNWRITABLE\t(UDC_EP_HALTED | UDC_FIFO_FULL)\n\n#define FIFO_EMPTY\t(UDC_NON_ISO_FIFO_EMPTY | UDC_ISO_FIFO_EMPTY)\n#define FIFO_UNREADABLE (UDC_EP_HALTED | FIFO_EMPTY)\n\nstatic inline int\nwrite_packet(u8 *buf, struct omap_req *req, unsigned max)\n{\n\tunsigned\tlen;\n\tu16\t\t*wp;\n\n\tlen = min(req->req.length - req->req.actual, max);\n\treq->req.actual += len;\n\n\tmax = len;\n\tif (likely((((int)buf) & 1) == 0)) {\n\t\twp = (u16 *)buf;\n\t\twhile (max >= 2) {\n\t\t\tomap_writew(*wp++, UDC_DATA);\n\t\t\tmax -= 2;\n\t\t}\n\t\tbuf = (u8 *)wp;\n\t}\n\twhile (max--)\n\t\tomap_writeb(*buf++, UDC_DATA);\n\treturn len;\n}\n\n \n\n\n \nstatic int write_fifo(struct omap_ep *ep, struct omap_req *req)\n{\n\tu8\t\t*buf;\n\tunsigned\tcount;\n\tint\t\tis_last;\n\tu16\t\tep_stat;\n\n\tbuf = req->req.buf + req->req.actual;\n\tprefetch(buf);\n\n\t \n\tep_stat = omap_readw(UDC_STAT_FLG);\n\tif (ep_stat & UDC_FIFO_UNWRITABLE)\n\t\treturn 0;\n\n\tcount = ep->ep.maxpacket;\n\tcount = write_packet(buf, req, count);\n\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\tep->ackwait = 1;\n\n\t \n\tif (count != ep->ep.maxpacket)\n\t\tis_last = 1;\n\telse if (req->req.length == req->req.actual\n\t\t\t&& !req->req.zero)\n\t\tis_last = 1;\n\telse\n\t\tis_last = 0;\n\n\t \n\tif (is_last)\n\t\tdone(ep, req, 0);\n\treturn is_last;\n}\n\nstatic inline int\nread_packet(u8 *buf, struct omap_req *req, unsigned avail)\n{\n\tunsigned\tlen;\n\tu16\t\t*wp;\n\n\tlen = min(req->req.length - req->req.actual, avail);\n\treq->req.actual += len;\n\tavail = len;\n\n\tif (likely((((int)buf) & 1) == 0)) {\n\t\twp = (u16 *)buf;\n\t\twhile (avail >= 2) {\n\t\t\t*wp++ = omap_readw(UDC_DATA);\n\t\t\tavail -= 2;\n\t\t}\n\t\tbuf = (u8 *)wp;\n\t}\n\twhile (avail--)\n\t\t*buf++ = omap_readb(UDC_DATA);\n\treturn len;\n}\n\n \nstatic int read_fifo(struct omap_ep *ep, struct omap_req *req)\n{\n\tu8\t\t*buf;\n\tunsigned\tcount, avail;\n\tint\t\tis_last;\n\n\tbuf = req->req.buf + req->req.actual;\n\tprefetchw(buf);\n\n\tfor (;;) {\n\t\tu16\tep_stat = omap_readw(UDC_STAT_FLG);\n\n\t\tis_last = 0;\n\t\tif (ep_stat & FIFO_EMPTY) {\n\t\t\tif (!ep->double_buf)\n\t\t\t\tbreak;\n\t\t\tep->fnf = 1;\n\t\t}\n\t\tif (ep_stat & UDC_EP_HALTED)\n\t\t\tbreak;\n\n\t\tif (ep_stat & UDC_FIFO_FULL)\n\t\t\tavail = ep->ep.maxpacket;\n\t\telse  {\n\t\t\tavail = omap_readw(UDC_RXFSTAT);\n\t\t\tep->fnf = ep->double_buf;\n\t\t}\n\t\tcount = read_packet(buf, req, avail);\n\n\t\t \n\t\tif (count < ep->ep.maxpacket) {\n\t\t\tis_last = 1;\n\t\t\t \n\t\t\tif (count != avail) {\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\tavail -= count;\n\t\t\t\twhile (avail--)\n\t\t\t\t\tomap_readw(UDC_DATA);\n\t\t\t}\n\t\t} else if (req->req.length == req->req.actual)\n\t\t\tis_last = 1;\n\t\telse\n\t\t\tis_last = 0;\n\n\t\tif (!ep->bEndpointAddress)\n\t\t\tbreak;\n\t\tif (is_last)\n\t\t\tdone(ep, req, 0);\n\t\tbreak;\n\t}\n\treturn is_last;\n}\n\n \n\nstatic u16 dma_src_len(struct omap_ep *ep, dma_addr_t start)\n{\n\tdma_addr_t\tend;\n\n\t \n\tif (cpu_is_omap15xx())\n\t\treturn 0;\n\n\tend = omap_get_dma_src_pos(ep->lch);\n\tif (end == ep->dma_counter)\n\t\treturn 0;\n\n\tend |= start & (0xffff << 16);\n\tif (end < start)\n\t\tend += 0x10000;\n\treturn end - start;\n}\n\nstatic u16 dma_dest_len(struct omap_ep *ep, dma_addr_t start)\n{\n\tdma_addr_t\tend;\n\n\tend = omap_get_dma_dst_pos(ep->lch);\n\tif (end == ep->dma_counter)\n\t\treturn 0;\n\n\tend |= start & (0xffff << 16);\n\tif (cpu_is_omap15xx())\n\t\tend++;\n\tif (end < start)\n\t\tend += 0x10000;\n\treturn end - start;\n}\n\n\n \n\nstatic void next_in_dma(struct omap_ep *ep, struct omap_req *req)\n{\n\tu16\t\ttxdma_ctrl, w;\n\tunsigned\tlength = req->req.length - req->req.actual;\n\tconst int\tsync_mode = cpu_is_omap15xx()\n\t\t\t\t? OMAP_DMA_SYNC_FRAME\n\t\t\t\t: OMAP_DMA_SYNC_ELEMENT;\n\tint\t\tdma_trigger = 0;\n\n\t \n\tif ((cpu_is_omap16xx() && length <= UDC_TXN_TSC)\n\t\t\t|| (cpu_is_omap15xx() && length < ep->maxpacket)) {\n\t\ttxdma_ctrl = UDC_TXN_EOT | length;\n\t\tomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S8,\n\t\t\t\tlength, 1, sync_mode, dma_trigger, 0);\n\t} else {\n\t\tlength = min(length / ep->maxpacket,\n\t\t\t\t(unsigned) UDC_TXN_TSC + 1);\n\t\ttxdma_ctrl = length;\n\t\tomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,\n\t\t\t\tep->ep.maxpacket >> 1, length, sync_mode,\n\t\t\t\tdma_trigger, 0);\n\t\tlength *= ep->maxpacket;\n\t}\n\tomap_set_dma_src_params(ep->lch, OMAP_DMA_PORT_EMIFF,\n\t\tOMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,\n\t\t0, 0);\n\n\tomap_start_dma(ep->lch);\n\tep->dma_counter = omap_get_dma_src_pos(ep->lch);\n\tw = omap_readw(UDC_DMA_IRQ_EN);\n\tw |= UDC_TX_DONE_IE(ep->dma_channel);\n\tomap_writew(w, UDC_DMA_IRQ_EN);\n\tomap_writew(UDC_TXN_START | txdma_ctrl, UDC_TXDMA(ep->dma_channel));\n\treq->dma_bytes = length;\n}\n\nstatic void finish_in_dma(struct omap_ep *ep, struct omap_req *req, int status)\n{\n\tu16 w;\n\n\tif (status == 0) {\n\t\treq->req.actual += req->dma_bytes;\n\n\t\t \n\t\tif (req->req.actual < req->req.length)\n\t\t\treturn;\n\t\tif (req->req.zero\n\t\t\t\t&& req->dma_bytes != 0\n\t\t\t\t&& (req->req.actual % ep->maxpacket) == 0)\n\t\t\treturn;\n\t} else\n\t\treq->req.actual += dma_src_len(ep, req->req.dma\n\t\t\t\t\t\t\t+ req->req.actual);\n\n\t \n\tomap_stop_dma(ep->lch);\n\tw = omap_readw(UDC_DMA_IRQ_EN);\n\tw &= ~UDC_TX_DONE_IE(ep->dma_channel);\n\tomap_writew(w, UDC_DMA_IRQ_EN);\n\tdone(ep, req, status);\n}\n\nstatic void next_out_dma(struct omap_ep *ep, struct omap_req *req)\n{\n\tunsigned packets = req->req.length - req->req.actual;\n\tint dma_trigger = 0;\n\tu16 w;\n\n\t \n\tpackets /= ep->ep.maxpacket;\n\tpackets = min(packets, (unsigned)UDC_RXN_TC + 1);\n\treq->dma_bytes = packets * ep->ep.maxpacket;\n\tomap_set_dma_transfer_params(ep->lch, OMAP_DMA_DATA_TYPE_S16,\n\t\t\tep->ep.maxpacket >> 1, packets,\n\t\t\tOMAP_DMA_SYNC_ELEMENT,\n\t\t\tdma_trigger, 0);\n\tomap_set_dma_dest_params(ep->lch, OMAP_DMA_PORT_EMIFF,\n\t\tOMAP_DMA_AMODE_POST_INC, req->req.dma + req->req.actual,\n\t\t0, 0);\n\tep->dma_counter = omap_get_dma_dst_pos(ep->lch);\n\n\tomap_writew(UDC_RXN_STOP | (packets - 1), UDC_RXDMA(ep->dma_channel));\n\tw = omap_readw(UDC_DMA_IRQ_EN);\n\tw |= UDC_RX_EOT_IE(ep->dma_channel);\n\tomap_writew(w, UDC_DMA_IRQ_EN);\n\tomap_writew(ep->bEndpointAddress & 0xf, UDC_EP_NUM);\n\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\n\tomap_start_dma(ep->lch);\n}\n\nstatic void\nfinish_out_dma(struct omap_ep *ep, struct omap_req *req, int status, int one)\n{\n\tu16\tcount, w;\n\n\tif (status == 0)\n\t\tep->dma_counter = (u16) (req->req.dma + req->req.actual);\n\tcount = dma_dest_len(ep, req->req.dma + req->req.actual);\n\tcount += req->req.actual;\n\tif (one)\n\t\tcount--;\n\tif (count <= req->req.length)\n\t\treq->req.actual = count;\n\n\tif (count != req->dma_bytes || status)\n\t\tomap_stop_dma(ep->lch);\n\n\t \n\telse if (req->req.actual < req->req.length)\n\t\treturn;\n\n\t \n\tw = omap_readw(UDC_DMA_IRQ_EN);\n\tw &= ~UDC_RX_EOT_IE(ep->dma_channel);\n\tomap_writew(w, UDC_DMA_IRQ_EN);\n\tdone(ep, req, status);\n}\n\nstatic void dma_irq(struct omap_udc *udc, u16 irq_src)\n{\n\tu16\t\tdman_stat = omap_readw(UDC_DMAN_STAT);\n\tstruct omap_ep\t*ep;\n\tstruct omap_req\t*req;\n\n\t \n\tif (irq_src & UDC_TXN_DONE) {\n\t\tep = &udc->ep[16 + UDC_DMA_TX_SRC(dman_stat)];\n\t\tep->irqs++;\n\t\t \n\t\tif (!list_empty(&ep->queue)) {\n\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\t\tstruct omap_req, queue);\n\t\t\tfinish_in_dma(ep, req, 0);\n\t\t}\n\t\tomap_writew(UDC_TXN_DONE, UDC_IRQ_SRC);\n\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\tstruct omap_req, queue);\n\t\t\tnext_in_dma(ep, req);\n\t\t}\n\t}\n\n\t \n\tif (irq_src & UDC_RXN_EOT) {\n\t\tep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];\n\t\tep->irqs++;\n\t\t \n\t\tif (!list_empty(&ep->queue)) {\n\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\tstruct omap_req, queue);\n\t\t\tfinish_out_dma(ep, req, 0, dman_stat & UDC_DMA_RX_SB);\n\t\t}\n\t\tomap_writew(UDC_RXN_EOT, UDC_IRQ_SRC);\n\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\tstruct omap_req, queue);\n\t\t\tnext_out_dma(ep, req);\n\t\t}\n\t}\n\n\tif (irq_src & UDC_RXN_CNT) {\n\t\tep = &udc->ep[UDC_DMA_RX_SRC(dman_stat)];\n\t\tep->irqs++;\n\t\t \n\t\tVDBG(\"%s, RX_CNT irq?\\n\", ep->ep.name);\n\t\tomap_writew(UDC_RXN_CNT, UDC_IRQ_SRC);\n\t}\n}\n\nstatic void dma_error(int lch, u16 ch_status, void *data)\n{\n\tstruct omap_ep\t*ep = data;\n\n\t \n\t \n\tERR(\"%s dma error, lch %d status %02x\\n\", ep->ep.name, lch, ch_status);\n\n\t \n}\n\nstatic void dma_channel_claim(struct omap_ep *ep, unsigned channel)\n{\n\tu16\treg;\n\tint\tstatus, restart, is_in;\n\tint\tdma_channel;\n\n\tis_in = ep->bEndpointAddress & USB_DIR_IN;\n\tif (is_in)\n\t\treg = omap_readw(UDC_TXDMA_CFG);\n\telse\n\t\treg = omap_readw(UDC_RXDMA_CFG);\n\treg |= UDC_DMA_REQ;\t\t \n\n\tep->dma_channel = 0;\n\tep->lch = -1;\n\tif (channel == 0 || channel > 3) {\n\t\tif ((reg & 0x0f00) == 0)\n\t\t\tchannel = 3;\n\t\telse if ((reg & 0x00f0) == 0)\n\t\t\tchannel = 2;\n\t\telse if ((reg & 0x000f) == 0)\t \n\t\t\tchannel = 1;\n\t\telse {\n\t\t\tstatus = -EMLINK;\n\t\t\tgoto just_restart;\n\t\t}\n\t}\n\treg |= (0x0f & ep->bEndpointAddress) << (4 * (channel - 1));\n\tep->dma_channel = channel;\n\n\tif (is_in) {\n\t\tdma_channel = OMAP_DMA_USB_W2FC_TX0 - 1 + channel;\n\t\tstatus = omap_request_dma(dma_channel,\n\t\t\tep->ep.name, dma_error, ep, &ep->lch);\n\t\tif (status == 0) {\n\t\t\tomap_writew(reg, UDC_TXDMA_CFG);\n\t\t\t \n\t\t\tomap_set_dma_src_burst_mode(ep->lch,\n\t\t\t\t\t\tOMAP_DMA_DATA_BURST_4);\n\t\t\tomap_set_dma_src_data_pack(ep->lch, 1);\n\t\t\t \n\t\t\tomap_set_dma_dest_params(ep->lch,\n\t\t\t\tOMAP_DMA_PORT_TIPB,\n\t\t\t\tOMAP_DMA_AMODE_CONSTANT,\n\t\t\t\tUDC_DATA_DMA,\n\t\t\t\t0, 0);\n\t\t}\n\t} else {\n\t\tdma_channel = OMAP_DMA_USB_W2FC_RX0 - 1 + channel;\n\t\tstatus = omap_request_dma(dma_channel,\n\t\t\tep->ep.name, dma_error, ep, &ep->lch);\n\t\tif (status == 0) {\n\t\t\tomap_writew(reg, UDC_RXDMA_CFG);\n\t\t\t \n\t\t\tomap_set_dma_src_params(ep->lch,\n\t\t\t\tOMAP_DMA_PORT_TIPB,\n\t\t\t\tOMAP_DMA_AMODE_CONSTANT,\n\t\t\t\tUDC_DATA_DMA,\n\t\t\t\t0, 0);\n\t\t\t \n\t\t\tomap_set_dma_dest_burst_mode(ep->lch,\n\t\t\t\t\t\tOMAP_DMA_DATA_BURST_4);\n\t\t\tomap_set_dma_dest_data_pack(ep->lch, 1);\n\t\t}\n\t}\n\tif (status)\n\t\tep->dma_channel = 0;\n\telse {\n\t\tep->has_dma = 1;\n\t\tomap_disable_dma_irq(ep->lch, OMAP_DMA_BLOCK_IRQ);\n\n\t\t \n\t\tif (!cpu_is_omap15xx())\n\t\t\tomap_set_dma_channel_mode(ep->lch, OMAP_DMA_LCH_P);\n\t}\n\njust_restart:\n\t \n\trestart = !ep->stopped && !list_empty(&ep->queue);\n\n\tif (status)\n\t\tDBG(\"%s no dma channel: %d%s\\n\", ep->ep.name, status,\n\t\t\trestart ? \" (restart)\" : \"\");\n\telse\n\t\tDBG(\"%s claimed %cxdma%d lch %d%s\\n\", ep->ep.name,\n\t\t\tis_in ? 't' : 'r',\n\t\t\tep->dma_channel - 1, ep->lch,\n\t\t\trestart ? \" (restart)\" : \"\");\n\n\tif (restart) {\n\t\tstruct omap_req\t*req;\n\t\treq = container_of(ep->queue.next, struct omap_req, queue);\n\t\tif (ep->has_dma)\n\t\t\t(is_in ? next_in_dma : next_out_dma)(ep, req);\n\t\telse {\n\t\t\tuse_ep(ep, UDC_EP_SEL);\n\t\t\t(is_in ? write_fifo : read_fifo)(ep, req);\n\t\t\tdeselect_ep();\n\t\t\tif (!is_in) {\n\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t\t}\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic void dma_channel_release(struct omap_ep *ep)\n{\n\tint\t\tshift = 4 * (ep->dma_channel - 1);\n\tu16\t\tmask = 0x0f << shift;\n\tstruct omap_req\t*req;\n\tint\t\tactive;\n\n\t \n\tif (!list_empty(&ep->queue))\n\t\treq = container_of(ep->queue.next, struct omap_req, queue);\n\telse\n\t\treq = NULL;\n\n\tactive = omap_get_dma_active_status(ep->lch);\n\n\tDBG(\"%s release %s %cxdma%d %p\\n\", ep->ep.name,\n\t\t\tactive ? \"active\" : \"idle\",\n\t\t\t(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',\n\t\t\tep->dma_channel - 1, req);\n\n\t \n\n\t \n\tif (ep->bEndpointAddress & USB_DIR_IN) {\n\t\tomap_writew((omap_readw(UDC_TXDMA_CFG) & ~mask) | UDC_DMA_REQ,\n\t\t\t\t\tUDC_TXDMA_CFG);\n\n\t\tif (req) {\n\t\t\tfinish_in_dma(ep, req, -ECONNRESET);\n\n\t\t\t \n\t\t\tuse_ep(ep, UDC_EP_SEL);\n\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\tdeselect_ep();\n\t\t}\n\t\twhile (omap_readw(UDC_TXDMA_CFG) & mask)\n\t\t\tudelay(10);\n\t} else {\n\t\tomap_writew((omap_readw(UDC_RXDMA_CFG) & ~mask) | UDC_DMA_REQ,\n\t\t\t\t\tUDC_RXDMA_CFG);\n\n\t\t \n\t\twhile (omap_readw(UDC_RXDMA_CFG) & mask)\n\t\t\tudelay(10);\n\t\tif (req)\n\t\t\tfinish_out_dma(ep, req, -ECONNRESET, 0);\n\t}\n\tomap_free_dma(ep->lch);\n\tep->dma_channel = 0;\n\tep->lch = -1;\n\t \n}\n\n\n \n\nstatic int\nomap_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct omap_ep\t*ep = container_of(_ep, struct omap_ep, ep);\n\tstruct omap_req\t*req = container_of(_req, struct omap_req, req);\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\tint\t\tis_iso = 0;\n\n\t \n\tif (!_req || !req->req.complete || !req->req.buf\n\t\t\t|| !list_empty(&req->queue)) {\n\t\tDBG(\"%s, bad params\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!_ep || (!ep->ep.desc && ep->bEndpointAddress)) {\n\t\tDBG(\"%s, bad ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tif (req->req.length > ep->ep.maxpacket)\n\t\t\treturn -EMSGSIZE;\n\t\tis_iso = 1;\n\t}\n\n\t \n\tif (use_dma\n\t\t\t&& ep->has_dma\n\t\t\t&& ep->bEndpointAddress != 0\n\t\t\t&& (ep->bEndpointAddress & USB_DIR_IN) == 0\n\t\t\t&& (req->req.length % ep->ep.maxpacket) != 0) {\n\t\tDBG(\"%s, no partial packet OUT reads\\n\", __func__);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tudc = ep->udc;\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tif (use_dma && ep->has_dma)\n\t\tusb_gadget_map_request(&udc->gadget, &req->req,\n\t\t\t\t(ep->bEndpointAddress & USB_DIR_IN));\n\n\tVDBG(\"%s queue req %p, len %d buf %p\\n\",\n\t\tep->ep.name, _req, _req->length, _req->buf);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\n\t \n\tif (is_iso) {\n\t\tu16 w;\n\n\t\tw = omap_readw(UDC_IRQ_EN);\n\t\tw |= UDC_SOF_IE;\n\t\tomap_writew(w, UDC_IRQ_EN);\n\t} else if (list_empty(&ep->queue) && !ep->stopped && !ep->ackwait) {\n\t\tint\tis_in;\n\n\t\tif (ep->bEndpointAddress == 0) {\n\t\t\tif (!udc->ep0_pending || !list_empty(&ep->queue)) {\n\t\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\t\treturn -EL2HLT;\n\t\t\t}\n\n\t\t\t \n\t\t\tis_in = udc->ep0_in;\n\t\t\tif (!req->req.length) {\n\n\t\t\t\t \n\t\t\t\tif (udc->ep0_set_config) {\n\t\t\t\t\tu16\tirq_en = omap_readw(UDC_IRQ_EN);\n\n\t\t\t\t\tirq_en |= UDC_DS_CHG_IE | UDC_EP0_IE;\n\t\t\t\t\tif (!udc->ep0_reset_config)\n\t\t\t\t\t\tirq_en |= UDC_EPN_RX_IE\n\t\t\t\t\t\t\t| UDC_EPN_TX_IE;\n\t\t\t\t\tomap_writew(irq_en, UDC_IRQ_EN);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tomap_writew(UDC_EP_SEL | UDC_EP_DIR,\n\t\t\t\t\t\tUDC_EP_NUM);\n\t\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\n\t\t\t\t \n\t\t\t\tudc->ep0_pending = 0;\n\t\t\t\tdone(ep, req, 0);\n\t\t\t\treq = NULL;\n\n\t\t\t \n\t\t\t} else if (is_in) {\n\t\t\t\tomap_writew(UDC_EP_SEL | UDC_EP_DIR,\n\t\t\t\t\t\tUDC_EP_NUM);\n\t\t\t} else {\n\t\t\t\tif (udc->ep0_setup)\n\t\t\t\t\tgoto irq_wait;\n\t\t\t\tomap_writew(UDC_EP_SEL, UDC_EP_NUM);\n\t\t\t}\n\t\t} else {\n\t\t\tis_in = ep->bEndpointAddress & USB_DIR_IN;\n\t\t\tif (!ep->has_dma)\n\t\t\t\tuse_ep(ep, UDC_EP_SEL);\n\t\t\t \n\t\t}\n\n\t\tif (ep->has_dma)\n\t\t\t(is_in ? next_in_dma : next_out_dma)(ep, req);\n\t\telse if (req) {\n\t\t\tif ((is_in ? write_fifo : read_fifo)(ep, req) == 1)\n\t\t\t\treq = NULL;\n\t\t\tdeselect_ep();\n\t\t\tif (!is_in) {\n\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t\t}\n\t\t\t \n\t\t}\n\t}\n\nirq_wait:\n\t \n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int omap_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct omap_ep\t*ep = container_of(_ep, struct omap_ep, ep);\n\tstruct omap_req\t*req = NULL, *iter;\n\tunsigned long\tflags;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (use_dma && ep->dma_channel && ep->queue.next == &req->queue) {\n\t\tint channel = ep->dma_channel;\n\n\t\t \n\t\tdma_channel_release(ep);\n\t\tdma_channel_claim(ep, channel);\n\t} else\n\t\tdone(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int omap_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct omap_ep\t*ep = container_of(_ep, struct omap_ep, ep);\n\tunsigned long\tflags;\n\tint\t\tstatus = -EOPNOTSUPP;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\t \n\tif (ep->bEndpointAddress == 0) {\n\t\tif (!ep->udc->ep0_pending)\n\t\t\tstatus = -EINVAL;\n\t\telse if (value) {\n\t\t\tif (ep->udc->ep0_set_config) {\n\t\t\t\tWARNING(\"error changing config?\\n\");\n\t\t\t\tomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\n\t\t\t}\n\t\t\tomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\n\t\t\tep->udc->ep0_pending = 0;\n\t\t\tstatus = 0;\n\t\t} else  \n\t\t\tstatus = 0;\n\n\t \n\t} else if (ep->bmAttributes != USB_ENDPOINT_XFER_ISOC && ep->ep.desc) {\n\n\t\t \n\t\tif ((ep->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t&& !list_empty(&ep->queue)) {\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (value) {\n\t\t\tint\tchannel;\n\n\t\t\tif (use_dma && ep->dma_channel\n\t\t\t\t\t&& !list_empty(&ep->queue)) {\n\t\t\t\tchannel = ep->dma_channel;\n\t\t\t\tdma_channel_release(ep);\n\t\t\t} else\n\t\t\t\tchannel = 0;\n\n\t\t\tuse_ep(ep, UDC_EP_SEL);\n\t\t\tif (omap_readw(UDC_STAT_FLG) & UDC_NON_ISO_FIFO_EMPTY) {\n\t\t\t\tomap_writew(UDC_SET_HALT, UDC_CTRL);\n\t\t\t\tstatus = 0;\n\t\t\t} else\n\t\t\t\tstatus = -EAGAIN;\n\t\t\tdeselect_ep();\n\n\t\t\tif (channel)\n\t\t\t\tdma_channel_claim(ep, channel);\n\t\t} else {\n\t\t\tuse_ep(ep, 0);\n\t\t\tomap_writew(ep->udc->clr_halt, UDC_CTRL);\n\t\t\tep->ackwait = 0;\n\t\t\tif (!(ep->bEndpointAddress & USB_DIR_IN)) {\n\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t\t}\n\t\t}\n\t}\ndone:\n\tVDBG(\"%s %s halt stat %d\\n\", ep->ep.name,\n\t\tvalue ? \"set\" : \"clear\", status);\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn status;\n}\n\nstatic const struct usb_ep_ops omap_ep_ops = {\n\t.enable\t\t= omap_ep_enable,\n\t.disable\t= omap_ep_disable,\n\n\t.alloc_request\t= omap_alloc_request,\n\t.free_request\t= omap_free_request,\n\n\t.queue\t\t= omap_ep_queue,\n\t.dequeue\t= omap_ep_dequeue,\n\n\t.set_halt\t= omap_ep_set_halt,\n\t \n\t \n};\n\n \n\nstatic int omap_get_frame(struct usb_gadget *gadget)\n{\n\tu16\tsof = omap_readw(UDC_SOF);\n\treturn (sof & UDC_TS_OK) ? (sof & UDC_TS) : -EL2NSYNC;\n}\n\nstatic int omap_wakeup(struct usb_gadget *gadget)\n{\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\tint\t\tretval = -EHOSTUNREACH;\n\n\tudc = container_of(gadget, struct omap_udc, gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (udc->devstat & UDC_SUS) {\n\t\t \n\t\tif (udc->devstat & (UDC_B_HNP_ENABLE|UDC_R_WK_OK)) {\n\t\t\tDBG(\"remote wakeup...\\n\");\n\t\t\tomap_writew(UDC_RMT_WKP, UDC_SYSCON2);\n\t\t\tretval = 0;\n\t\t}\n\n\t \n\t} else if (!(udc->devstat & UDC_ATT)) {\n\t\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\t\tretval = otg_start_srp(udc->transceiver->otg);\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn retval;\n}\n\nstatic int\nomap_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)\n{\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\tu16\t\tsyscon1;\n\n\tgadget->is_selfpowered = (is_selfpowered != 0);\n\tudc = container_of(gadget, struct omap_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tsyscon1 = omap_readw(UDC_SYSCON1);\n\tif (is_selfpowered)\n\t\tsyscon1 |= UDC_SELF_PWR;\n\telse\n\t\tsyscon1 &= ~UDC_SELF_PWR;\n\tomap_writew(syscon1, UDC_SYSCON1);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int can_pullup(struct omap_udc *udc)\n{\n\treturn udc->driver && udc->softconnect && udc->vbus_active;\n}\n\nstatic void pullup_enable(struct omap_udc *udc)\n{\n\tu16 w;\n\n\tw = omap_readw(UDC_SYSCON1);\n\tw |= UDC_PULLUP_EN;\n\tomap_writew(w, UDC_SYSCON1);\n\tif (!gadget_is_otg(&udc->gadget) && !cpu_is_omap15xx()) {\n\t\tu32 l;\n\n\t\tl = omap_readl(OTG_CTRL);\n\t\tl |= OTG_BSESSVLD;\n\t\tomap_writel(l, OTG_CTRL);\n\t}\n\tomap_writew(UDC_DS_CHG_IE, UDC_IRQ_EN);\n}\n\nstatic void pullup_disable(struct omap_udc *udc)\n{\n\tu16 w;\n\n\tif (!gadget_is_otg(&udc->gadget) && !cpu_is_omap15xx()) {\n\t\tu32 l;\n\n\t\tl = omap_readl(OTG_CTRL);\n\t\tl &= ~OTG_BSESSVLD;\n\t\tomap_writel(l, OTG_CTRL);\n\t}\n\tomap_writew(UDC_DS_CHG_IE, UDC_IRQ_EN);\n\tw = omap_readw(UDC_SYSCON1);\n\tw &= ~UDC_PULLUP_EN;\n\tomap_writew(w, UDC_SYSCON1);\n}\n\nstatic struct omap_udc *udc;\n\nstatic void omap_udc_enable_clock(int enable)\n{\n\tif (udc == NULL || udc->dc_clk == NULL || udc->hhc_clk == NULL)\n\t\treturn;\n\n\tif (enable) {\n\t\tclk_enable(udc->dc_clk);\n\t\tclk_enable(udc->hhc_clk);\n\t\tudelay(100);\n\t} else {\n\t\tclk_disable(udc->hhc_clk);\n\t\tclk_disable(udc->dc_clk);\n\t}\n}\n\n \nstatic int omap_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\tu32 l;\n\n\tudc = container_of(gadget, struct omap_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tVDBG(\"VBUS %s\\n\", is_active ? \"on\" : \"off\");\n\tudc->vbus_active = (is_active != 0);\n\tif (cpu_is_omap15xx()) {\n\t\t \n\t\tl = omap_readl(FUNC_MUX_CTRL_0);\n\t\tif (is_active)\n\t\t\tl |= VBUS_CTRL_1510;\n\t\telse\n\t\t\tl &= ~VBUS_CTRL_1510;\n\t\tomap_writel(l, FUNC_MUX_CTRL_0);\n\t}\n\tif (udc->dc_clk != NULL && is_active) {\n\t\tif (!udc->clk_requested) {\n\t\t\tomap_udc_enable_clock(1);\n\t\t\tudc->clk_requested = 1;\n\t\t}\n\t}\n\tif (can_pullup(udc))\n\t\tpullup_enable(udc);\n\telse\n\t\tpullup_disable(udc);\n\tif (udc->dc_clk != NULL && !is_active) {\n\t\tif (udc->clk_requested) {\n\t\t\tomap_udc_enable_clock(0);\n\t\t\tudc->clk_requested = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int omap_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{\n\tstruct omap_udc\t*udc;\n\n\tudc = container_of(gadget, struct omap_udc, gadget);\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\treturn usb_phy_set_power(udc->transceiver, mA);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int omap_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct omap_udc\t*udc;\n\tunsigned long\tflags;\n\n\tudc = container_of(gadget, struct omap_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->softconnect = (is_on != 0);\n\tif (can_pullup(udc))\n\t\tpullup_enable(udc);\n\telse\n\t\tpullup_disable(udc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int omap_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int omap_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops omap_gadget_ops = {\n\t.get_frame\t\t= omap_get_frame,\n\t.wakeup\t\t\t= omap_wakeup,\n\t.set_selfpowered\t= omap_set_selfpowered,\n\t.vbus_session\t\t= omap_vbus_session,\n\t.vbus_draw\t\t= omap_vbus_draw,\n\t.pullup\t\t\t= omap_pullup,\n\t.udc_start\t\t= omap_udc_start,\n\t.udc_stop\t\t= omap_udc_stop,\n};\n\n \n\n \nstatic void nuke(struct omap_ep *ep, int status)\n{\n\tstruct omap_req\t*req;\n\n\tep->stopped = 1;\n\n\tif (use_dma && ep->dma_channel)\n\t\tdma_channel_release(ep);\n\n\tuse_ep(ep, 0);\n\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\tif (ep->bEndpointAddress && ep->bmAttributes != USB_ENDPOINT_XFER_ISOC)\n\t\tomap_writew(UDC_SET_HALT, UDC_CTRL);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct omap_req, queue);\n\t\tdone(ep, req, status);\n\t}\n}\n\n \nstatic void udc_quiesce(struct omap_udc *udc)\n{\n\tstruct omap_ep\t*ep;\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tnuke(&udc->ep[0], -ESHUTDOWN);\n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list)\n\t\tnuke(ep, -ESHUTDOWN);\n}\n\n \n\nstatic void update_otg(struct omap_udc *udc)\n{\n\tu16\tdevstat;\n\n\tif (!gadget_is_otg(&udc->gadget))\n\t\treturn;\n\n\tif (omap_readl(OTG_CTRL) & OTG_ID)\n\t\tdevstat = omap_readw(UDC_DEVSTAT);\n\telse\n\t\tdevstat = 0;\n\n\tudc->gadget.b_hnp_enable = !!(devstat & UDC_B_HNP_ENABLE);\n\tudc->gadget.a_hnp_support = !!(devstat & UDC_A_HNP_SUPPORT);\n\tudc->gadget.a_alt_hnp_support = !!(devstat & UDC_A_ALT_HNP_SUPPORT);\n\n\t \n\tif (udc->gadget.b_hnp_enable) {\n\t\tu32 l;\n\n\t\tl = omap_readl(OTG_CTRL);\n\t\tl |= OTG_B_HNPEN | OTG_B_BUSREQ;\n\t\tl &= ~OTG_PULLUP;\n\t\tomap_writel(l, OTG_CTRL);\n\t}\n}\n\nstatic void ep0_irq(struct omap_udc *udc, u16 irq_src)\n{\n\tstruct omap_ep\t*ep0 = &udc->ep[0];\n\tstruct omap_req\t*req = NULL;\n\n\tep0->irqs++;\n\n\t \n\tif (irq_src & UDC_SETUP) {\n\t\tu16\tack = irq_src & (UDC_EP0_TX|UDC_EP0_RX);\n\n\t\tnuke(ep0, 0);\n\t\tif (ack) {\n\t\t\tomap_writew(ack, UDC_IRQ_SRC);\n\t\t\tirq_src = UDC_SETUP;\n\t\t}\n\t}\n\n\t \n\tif (!list_empty(&ep0->queue))\n\t\treq = container_of(ep0->queue.next, struct omap_req, queue);\n\n\t \n\tif (irq_src & UDC_EP0_TX) {\n\t\tint\tstat;\n\n\t\tomap_writew(UDC_EP0_TX, UDC_IRQ_SRC);\n\t\tomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\n\t\tstat = omap_readw(UDC_STAT_FLG);\n\t\tif (stat & UDC_ACK) {\n\t\t\tif (udc->ep0_in) {\n\t\t\t\t \n\t\t\t\tif (req)\n\t\t\t\t\tstat = write_fifo(ep0, req);\n\t\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t\t\tif (!req && udc->ep0_pending) {\n\t\t\t\t\tomap_writew(UDC_EP_SEL, UDC_EP_NUM);\n\t\t\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t\t\t\tudc->ep0_pending = 0;\n\t\t\t\t}  \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t\t\tif (req)\n\t\t\t\t\tdone(ep0, req, 0);\n\t\t\t}\n\t\t\treq = NULL;\n\t\t} else if (stat & UDC_STALL) {\n\t\t\tomap_writew(UDC_CLR_HALT, UDC_CTRL);\n\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t} else {\n\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t}\n\t}\n\n\t \n\tif (irq_src & UDC_EP0_RX) {\n\t\tint\tstat;\n\n\t\tomap_writew(UDC_EP0_RX, UDC_IRQ_SRC);\n\t\tomap_writew(UDC_EP_SEL, UDC_EP_NUM);\n\t\tstat = omap_readw(UDC_STAT_FLG);\n\t\tif (stat & UDC_ACK) {\n\t\t\tif (!udc->ep0_in) {\n\t\t\t\tstat = 0;\n\t\t\t\t \n\t\t\t\tstat = read_fifo(ep0, req);\n\t\t\t\tif (!req || stat < 0) {\n\t\t\t\t\tomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\n\t\t\t\t\tudc->ep0_pending = 0;\n\t\t\t\t\tstat = 0;\n\t\t\t\t} else if (stat == 0)\n\t\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\tomap_writew(0, UDC_EP_NUM);\n\n\t\t\t\t \n\t\t\t\tif (stat == 1) {\n\t\t\t\t\tdone(ep0, req, 0);\n\t\t\t\t\t \n\t\t\t\t\tomap_writew(UDC_EP_SEL | UDC_EP_DIR,\n\t\t\t\t\t\t\tUDC_EP_NUM);\n\t\t\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t\t\t\tudc->ep0_pending = 0;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t\t\tif (req)\n\t\t\t\t\tdone(ep0, req, 0);\n\t\t\t}\n\t\t} else if (stat & UDC_STALL) {\n\t\t\tomap_writew(UDC_CLR_HALT, UDC_CTRL);\n\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t} else {\n\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t}\n\t}\n\n\t \n\tif (irq_src & UDC_SETUP) {\n\t\tunion u {\n\t\t\tu16\t\t\tword[4];\n\t\t\tstruct usb_ctrlrequest\tr;\n\t\t} u;\n\t\tint\t\t\tstatus = -EINVAL;\n\t\tstruct omap_ep\t\t*ep;\n\n\t\t \n\t\tdo {\n\t\t\tomap_writew(UDC_SETUP_SEL, UDC_EP_NUM);\n\t\t\t \n\t\t\tu.word[0] = omap_readw(UDC_DATA);\n\t\t\tu.word[1] = omap_readw(UDC_DATA);\n\t\t\tu.word[2] = omap_readw(UDC_DATA);\n\t\t\tu.word[3] = omap_readw(UDC_DATA);\n\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t} while (omap_readw(UDC_IRQ_SRC) & UDC_SETUP);\n\n#define\tw_value\t\tle16_to_cpu(u.r.wValue)\n#define\tw_index\t\tle16_to_cpu(u.r.wIndex)\n#define\tw_length\tle16_to_cpu(u.r.wLength)\n\n\t\t \n\t\tudc->ep0_in = (u.r.bRequestType & USB_DIR_IN) != 0;\n\t\tudc->ep0_set_config = 0;\n\t\tudc->ep0_pending = 1;\n\t\tep0->stopped = 0;\n\t\tep0->ackwait = 0;\n\t\tswitch (u.r.bRequest) {\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\t \n\t\t\tif (u.r.bRequestType != USB_RECIP_DEVICE)\n\t\t\t\tgoto delegate;\n\t\t\tif (w_length != 0)\n\t\t\t\tgoto do_stall;\n\t\t\tudc->ep0_set_config = 1;\n\t\t\tudc->ep0_reset_config = (w_value == 0);\n\t\t\tVDBG(\"set config %d\\n\", w_value);\n\n\t\t\t \n\t\t\tif (udc->ep0_reset_config)\n\t\t\t\tomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\n\t\t\telse\n\t\t\t\tomap_writew(UDC_DEV_CFG, UDC_SYSCON2);\n\t\t\tupdate_otg(udc);\n\t\t\tgoto delegate;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\t \n\t\t\tif (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (w_value != USB_ENDPOINT_HALT\n\t\t\t\t\t|| w_length != 0)\n\t\t\t\tgoto do_stall;\n\t\t\tep = &udc->ep[w_index & 0xf];\n\t\t\tif (ep != ep0) {\n\t\t\t\tif (w_index & USB_DIR_IN)\n\t\t\t\t\tep += 16;\n\t\t\t\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\n\t\t\t\t\t\t|| !ep->ep.desc)\n\t\t\t\t\tgoto do_stall;\n\t\t\t\tuse_ep(ep, 0);\n\t\t\t\tomap_writew(udc->clr_halt, UDC_CTRL);\n\t\t\t\tep->ackwait = 0;\n\t\t\t\tif (!(ep->bEndpointAddress & USB_DIR_IN)) {\n\t\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t}\n\t\t\tVDBG(\"%s halt cleared by host\\n\", ep->name);\n\t\t\tgoto ep0out_status_stage;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\t \n\t\t\tif (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (w_value != USB_ENDPOINT_HALT\n\t\t\t\t\t|| w_length != 0)\n\t\t\t\tgoto do_stall;\n\t\t\tep = &udc->ep[w_index & 0xf];\n\t\t\tif (w_index & USB_DIR_IN)\n\t\t\t\tep += 16;\n\t\t\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\n\t\t\t\t\t|| ep == ep0 || !ep->ep.desc)\n\t\t\t\tgoto do_stall;\n\t\t\tif (use_dma && ep->has_dma) {\n\t\t\t\t \n\t\t\t\tDBG(\"%s host set_halt, NYET\\n\", ep->name);\n\t\t\t\tgoto do_stall;\n\t\t\t}\n\t\t\tuse_ep(ep, 0);\n\t\t\t \n\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\tomap_writew(UDC_SET_HALT, UDC_CTRL);\n\t\t\tVDBG(\"%s halted by host\\n\", ep->name);\nep0out_status_stage:\n\t\t\tstatus = 0;\n\t\t\tomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\n\t\t\tomap_writew(UDC_CLR_EP, UDC_CTRL);\n\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t\tudc->ep0_pending = 0;\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\t \n\t\t\tif (u.r.bRequestType != (USB_DIR_IN|USB_RECIP_ENDPOINT))\n\t\t\t\tgoto intf_status;\n\n\t\t\t \n\t\t\tif (!(w_index & 0xf))\n\t\t\t\tgoto zero_status;\n\n\t\t\t \n\t\t\tep = &udc->ep[w_index & 0xf];\n\t\t\tif (w_index & USB_DIR_IN)\n\t\t\t\tep += 16;\n\t\t\tif (!ep->ep.desc)\n\t\t\t\tgoto do_stall;\n\n\t\t\t \n\t\t\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\tgoto zero_status;\n\n\t\t\t \n\t\t\tERR(\"%s status, can't report\\n\", ep->ep.name);\n\t\t\tgoto do_stall;\n\nintf_status:\n\t\t\t \n\t\t\tif (u.r.bRequestType\n\t\t\t\t\t!= (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\t\tgoto delegate;\n\nzero_status:\n\t\t\t \n\t\t\tomap_writew(UDC_EP_SEL|UDC_EP_DIR, UDC_EP_NUM);\n\t\t\tomap_writew(0, UDC_DATA);\n\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\tomap_writew(UDC_EP_DIR, UDC_EP_NUM);\n\t\t\tstatus = 0;\n\t\t\tVDBG(\"GET_STATUS, interface %d\\n\", w_index);\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\ndelegate:\n\t\t\t \n\t\t\tif (!udc->ep0_in && w_length) {\n\t\t\t\tomap_writew(0, UDC_EP_NUM);\n\t\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\t}\n\n\t\t\t \n\t\t\tVDBG(\"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t\t\tu.r.bRequestType, u.r.bRequest,\n\t\t\t\tw_value, w_index, w_length);\n\n#undef\tw_value\n#undef\tw_index\n#undef\tw_length\n\n\t\t\t \n\t\t\tudc->ep0_setup = 1;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tstatus = udc->driver->setup(&udc->gadget, &u.r);\n\t\t\tspin_lock(&udc->lock);\n\t\t\tudc->ep0_setup = 0;\n\t\t}\n\n\t\tif (status < 0) {\ndo_stall:\n\t\t\tVDBG(\"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\t\tu.r.bRequestType, u.r.bRequest, status);\n\t\t\tif (udc->ep0_set_config) {\n\t\t\t\tif (udc->ep0_reset_config)\n\t\t\t\t\tWARNING(\"error resetting config?\\n\");\n\t\t\t\telse\n\t\t\t\t\tomap_writew(UDC_CLR_CFG, UDC_SYSCON2);\n\t\t\t}\n\t\t\tomap_writew(UDC_STALL_CMD, UDC_SYSCON2);\n\t\t\tudc->ep0_pending = 0;\n\t\t}\n\t}\n}\n\n \n\n#define OTG_FLAGS (UDC_B_HNP_ENABLE|UDC_A_HNP_SUPPORT|UDC_A_ALT_HNP_SUPPORT)\n\nstatic void devstate_irq(struct omap_udc *udc, u16 irq_src)\n{\n\tu16\tdevstat, change;\n\n\tdevstat = omap_readw(UDC_DEVSTAT);\n\tchange = devstat ^ udc->devstat;\n\tudc->devstat = devstat;\n\n\tif (change & (UDC_USB_RESET|UDC_ATT)) {\n\t\tudc_quiesce(udc);\n\n\t\tif (change & UDC_ATT) {\n\t\t\t \n\t\t\tif (devstat & UDC_ATT) {\n\t\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\t\t\tVDBG(\"connect\\n\");\n\t\t\t\tif (IS_ERR_OR_NULL(udc->transceiver))\n\t\t\t\t\tpullup_enable(udc);\n\t\t\t\t \n\t\t\t} else if (udc->gadget.speed != USB_SPEED_UNKNOWN) {\n\t\t\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\t\t\tif (IS_ERR_OR_NULL(udc->transceiver))\n\t\t\t\t\tpullup_disable(udc);\n\t\t\t\tDBG(\"disconnect, gadget %s\\n\",\n\t\t\t\t\tudc->driver->driver.name);\n\t\t\t\tif (udc->driver->disconnect) {\n\t\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\t\tudc->driver->disconnect(&udc->gadget);\n\t\t\t\t\tspin_lock(&udc->lock);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchange &= ~UDC_ATT;\n\t\t}\n\n\t\tif (change & UDC_USB_RESET) {\n\t\t\tif (devstat & UDC_USB_RESET) {\n\t\t\t\tVDBG(\"RESET=1\\n\");\n\t\t\t} else {\n\t\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\t\t\tINFO(\"USB reset done, gadget %s\\n\",\n\t\t\t\t\tudc->driver->driver.name);\n\t\t\t\t \n\t\t\t\tomap_writew(UDC_DS_CHG_IE | UDC_EP0_IE,\n\t\t\t\t\t\tUDC_IRQ_EN);\n\t\t\t}\n\t\t\tchange &= ~UDC_USB_RESET;\n\t\t}\n\t}\n\tif (change & UDC_SUS) {\n\t\tif (udc->gadget.speed != USB_SPEED_UNKNOWN) {\n\t\t\t \n\t\t\tif (devstat & UDC_SUS) {\n\t\t\t\tVDBG(\"suspend\\n\");\n\t\t\t\tupdate_otg(udc);\n\t\t\t\t \n\t\t\t\tif (udc->gadget.speed == USB_SPEED_FULL\n\t\t\t\t\t\t&& udc->driver->suspend) {\n\t\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\t\t\tspin_lock(&udc->lock);\n\t\t\t\t}\n\t\t\t\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\t\t\t\tusb_phy_set_suspend(\n\t\t\t\t\t\t\tudc->transceiver, 1);\n\t\t\t} else {\n\t\t\t\tVDBG(\"resume\\n\");\n\t\t\t\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\t\t\t\tusb_phy_set_suspend(\n\t\t\t\t\t\t\tudc->transceiver, 0);\n\t\t\t\tif (udc->gadget.speed == USB_SPEED_FULL\n\t\t\t\t\t\t&& udc->driver->resume) {\n\t\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\t\t\tspin_lock(&udc->lock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tchange &= ~UDC_SUS;\n\t}\n\tif (!cpu_is_omap15xx() && (change & OTG_FLAGS)) {\n\t\tupdate_otg(udc);\n\t\tchange &= ~OTG_FLAGS;\n\t}\n\n\tchange &= ~(UDC_CFG|UDC_DEF|UDC_ADD);\n\tif (change)\n\t\tVDBG(\"devstat %03x, ignore change %03x\\n\",\n\t\t\tdevstat,  change);\n\n\tomap_writew(UDC_DS_CHG, UDC_IRQ_SRC);\n}\n\nstatic irqreturn_t omap_udc_irq(int irq, void *_udc)\n{\n\tstruct omap_udc\t*udc = _udc;\n\tu16\t\tirq_src;\n\tirqreturn_t\tstatus = IRQ_NONE;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tirq_src = omap_readw(UDC_IRQ_SRC);\n\n\t \n\tif (irq_src & UDC_DS_CHG) {\n\t\tdevstate_irq(_udc, irq_src);\n\t\tstatus = IRQ_HANDLED;\n\t\tirq_src &= ~UDC_DS_CHG;\n\t}\n\n\t \n\tif (irq_src & (UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX)) {\n\t\tep0_irq(_udc, irq_src);\n\t\tstatus = IRQ_HANDLED;\n\t\tirq_src &= ~(UDC_EP0_RX|UDC_SETUP|UDC_EP0_TX);\n\t}\n\n\t \n\tif (use_dma && (irq_src & (UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT))) {\n\t\tdma_irq(_udc, irq_src);\n\t\tstatus = IRQ_HANDLED;\n\t\tirq_src &= ~(UDC_TXN_DONE|UDC_RXN_CNT|UDC_RXN_EOT);\n\t}\n\n\tirq_src &= ~(UDC_IRQ_SOF | UDC_EPN_TX|UDC_EPN_RX);\n\tif (irq_src)\n\t\tDBG(\"udc_irq, unhandled %03x\\n\", irq_src);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn status;\n}\n\n \n#define PIO_OUT_TIMEOUT\t(jiffies + HZ/3)\n#define HALF_FULL(f)\t(!((f)&(UDC_NON_ISO_FIFO_FULL|UDC_NON_ISO_FIFO_EMPTY)))\n\nstatic void pio_out_timer(struct timer_list *t)\n{\n\tstruct omap_ep\t*ep = from_timer(ep, t, timer);\n\tunsigned long\tflags;\n\tu16\t\tstat_flg;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tif (!list_empty(&ep->queue) && ep->ackwait) {\n\t\tuse_ep(ep, UDC_EP_SEL);\n\t\tstat_flg = omap_readw(UDC_STAT_FLG);\n\n\t\tif ((stat_flg & UDC_ACK) && (!(stat_flg & UDC_FIFO_EN)\n\t\t\t\t|| (ep->double_buf && HALF_FULL(stat_flg)))) {\n\t\t\tstruct omap_req\t*req;\n\n\t\t\tVDBG(\"%s: lose, %04x\\n\", ep->ep.name, stat_flg);\n\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\tstruct omap_req, queue);\n\t\t\t(void) read_fifo(ep, req);\n\t\t\tomap_writew(ep->bEndpointAddress, UDC_EP_NUM);\n\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t} else\n\t\t\tdeselect_ep();\n\t}\n\tmod_timer(&ep->timer, PIO_OUT_TIMEOUT);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n}\n\nstatic irqreturn_t omap_udc_pio_irq(int irq, void *_dev)\n{\n\tu16\t\tepn_stat, irq_src;\n\tirqreturn_t\tstatus = IRQ_NONE;\n\tstruct omap_ep\t*ep;\n\tint\t\tepnum;\n\tstruct omap_udc\t*udc = _dev;\n\tstruct omap_req\t*req;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tepn_stat = omap_readw(UDC_EPN_STAT);\n\tirq_src = omap_readw(UDC_IRQ_SRC);\n\n\t \n\tif (irq_src & UDC_EPN_RX) {\n\t\tepnum = (epn_stat >> 8) & 0x0f;\n\t\tomap_writew(UDC_EPN_RX, UDC_IRQ_SRC);\n\t\tstatus = IRQ_HANDLED;\n\t\tep = &udc->ep[epnum];\n\t\tep->irqs++;\n\n\t\tomap_writew(epnum | UDC_EP_SEL, UDC_EP_NUM);\n\t\tep->fnf = 0;\n\t\tif (omap_readw(UDC_STAT_FLG) & UDC_ACK) {\n\t\t\tep->ackwait--;\n\t\t\tif (!list_empty(&ep->queue)) {\n\t\t\t\tint stat;\n\t\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\t\tstruct omap_req, queue);\n\t\t\t\tstat = read_fifo(ep, req);\n\t\t\t\tif (!ep->double_buf)\n\t\t\t\t\tep->fnf = 1;\n\t\t\t}\n\t\t}\n\t\t \n\t\tepn_stat = omap_readw(UDC_EPN_STAT);\n\t\tepn_stat = omap_readw(UDC_EPN_STAT);\n\t\tomap_writew(epnum, UDC_EP_NUM);\n\n\t\t \n\t\tif (ep->fnf) {\n\t\t\tomap_writew(UDC_SET_FIFO_EN, UDC_CTRL);\n\t\t\tep->ackwait = 1 + ep->double_buf;\n\t\t}\n\t\tmod_timer(&ep->timer, PIO_OUT_TIMEOUT);\n\t}\n\n\t \n\telse if (irq_src & UDC_EPN_TX) {\n\t\tepnum = epn_stat & 0x0f;\n\t\tomap_writew(UDC_EPN_TX, UDC_IRQ_SRC);\n\t\tstatus = IRQ_HANDLED;\n\t\tep = &udc->ep[16 + epnum];\n\t\tep->irqs++;\n\n\t\tomap_writew(epnum | UDC_EP_DIR | UDC_EP_SEL, UDC_EP_NUM);\n\t\tif (omap_readw(UDC_STAT_FLG) & UDC_ACK) {\n\t\t\tep->ackwait = 0;\n\t\t\tif (!list_empty(&ep->queue)) {\n\t\t\t\treq = container_of(ep->queue.next,\n\t\t\t\t\t\tstruct omap_req, queue);\n\t\t\t\t(void) write_fifo(ep, req);\n\t\t\t}\n\t\t}\n\t\t \n\t\tepn_stat = omap_readw(UDC_EPN_STAT);\n\t\tepn_stat = omap_readw(UDC_EPN_STAT);\n\t\tomap_writew(epnum | UDC_EP_DIR, UDC_EP_NUM);\n\t\t \n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\n#ifdef\tUSE_ISO\nstatic irqreturn_t omap_udc_iso_irq(int irq, void *_dev)\n{\n\tstruct omap_udc\t*udc = _dev;\n\tstruct omap_ep\t*ep;\n\tint\t\tpending = 0;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tlist_for_each_entry(ep, &udc->iso, iso) {\n\t\tu16\t\tstat;\n\t\tstruct omap_req\t*req;\n\n\t\tif (ep->has_dma || list_empty(&ep->queue))\n\t\t\tcontinue;\n\t\treq = list_entry(ep->queue.next, struct omap_req, queue);\n\n\t\tuse_ep(ep, UDC_EP_SEL);\n\t\tstat = omap_readw(UDC_STAT_FLG);\n\n\t\t \n\t\tif (ep->bEndpointAddress & USB_DIR_IN) {\n\t\t\tif (stat & UDC_MISS_IN)\n\t\t\t\t ;\n\t\t\telse\n\t\t\t\twrite_fifo(ep, req);\n\t\t} else {\n\t\t\tint\tstatus = 0;\n\n\t\t\tif (stat & UDC_NO_RXPACKET)\n\t\t\t\tstatus = -EREMOTEIO;\n\t\t\telse if (stat & UDC_ISO_ERR)\n\t\t\t\tstatus = -EILSEQ;\n\t\t\telse if (stat & UDC_DATA_FLUSH)\n\t\t\t\tstatus = -ENOSR;\n\n\t\t\tif (status)\n\t\t\t\t ;\n\t\t\telse\n\t\t\t\tread_fifo(ep, req);\n\t\t}\n\t\tdeselect_ep();\n\t\t \n\n\t\tep->irqs++;\n\t\tif (!list_empty(&ep->queue))\n\t\t\tpending = 1;\n\t}\n\tif (!pending) {\n\t\tu16 w;\n\n\t\tw = omap_readw(UDC_IRQ_EN);\n\t\tw &= ~UDC_SOF_IE;\n\t\tomap_writew(w, UDC_IRQ_EN);\n\t}\n\tomap_writew(UDC_IRQ_SOF, UDC_IRQ_SRC);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn IRQ_HANDLED;\n}\n#endif\n\n \n\nstatic inline int machine_without_vbus_sense(void)\n{\n\treturn  machine_is_omap_osk() || machine_is_sx1();\n}\n\nstatic int omap_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tint\t\tstatus;\n\tstruct omap_ep\t*ep;\n\tunsigned long\tflags;\n\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\tep->irqs = 0;\n\t\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC)\n\t\t\tcontinue;\n\t\tuse_ep(ep, 0);\n\t\tomap_writew(UDC_SET_HALT, UDC_CTRL);\n\t}\n\tudc->ep0_pending = 0;\n\tudc->ep[0].irqs = 0;\n\tudc->softconnect = 1;\n\n\t \n\tudc->driver = driver;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->dc_clk != NULL)\n\t\tomap_udc_enable_clock(1);\n\n\tomap_writew(UDC_IRQ_SRC_MASK, UDC_IRQ_SRC);\n\n\t \n\tif (!IS_ERR_OR_NULL(udc->transceiver)) {\n\t\tstatus = otg_set_peripheral(udc->transceiver->otg,\n\t\t\t\t\t\t&udc->gadget);\n\t\tif (status < 0) {\n\t\t\tERR(\"can't bind to transceiver\\n\");\n\t\t\tudc->driver = NULL;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tstatus = 0;\n\t\tif (can_pullup(udc))\n\t\t\tpullup_enable(udc);\n\t\telse\n\t\t\tpullup_disable(udc);\n\t}\n\n\t \n\tif (machine_without_vbus_sense())\n\t\tomap_vbus_session(&udc->gadget, 1);\n\ndone:\n\tif (udc->dc_clk != NULL)\n\t\tomap_udc_enable_clock(0);\n\n\treturn status;\n}\n\nstatic int omap_udc_stop(struct usb_gadget *g)\n{\n\tunsigned long\tflags;\n\n\tif (udc->dc_clk != NULL)\n\t\tomap_udc_enable_clock(1);\n\n\tif (machine_without_vbus_sense())\n\t\tomap_vbus_session(&udc->gadget, 0);\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\t(void) otg_set_peripheral(udc->transceiver->otg, NULL);\n\telse\n\t\tpullup_disable(udc);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc_quiesce(udc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tudc->driver = NULL;\n\n\tif (udc->dc_clk != NULL)\n\t\tomap_udc_enable_clock(0);\n\n\treturn 0;\n}\n\n \n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\n#include <linux/seq_file.h>\n\nstatic const char proc_filename[] = \"driver/udc\";\n\n#define FOURBITS \"%s%s%s%s\"\n#define EIGHTBITS \"%s%s%s%s%s%s%s%s\"\n\nstatic void proc_ep_show(struct seq_file *s, struct omap_ep *ep)\n{\n\tu16\t\tstat_flg;\n\tstruct omap_req\t*req;\n\tchar\t\tbuf[20];\n\n\tuse_ep(ep, 0);\n\n\tif (use_dma && ep->has_dma)\n\t\tsnprintf(buf, sizeof buf, \"(%cxdma%d lch%d) \",\n\t\t\t(ep->bEndpointAddress & USB_DIR_IN) ? 't' : 'r',\n\t\t\tep->dma_channel - 1, ep->lch);\n\telse\n\t\tbuf[0] = 0;\n\n\tstat_flg = omap_readw(UDC_STAT_FLG);\n\tseq_printf(s,\n\t\t\"\\n%s %s%s%sirqs %ld stat %04x \" EIGHTBITS FOURBITS \"%s\\n\",\n\t\tep->name, buf,\n\t\tep->double_buf ? \"dbuf \" : \"\",\n\t\t({ char *s;\n\t\tswitch (ep->ackwait) {\n\t\tcase 0:\n\t\t\ts = \"\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ts = \"(ackw) \";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ts = \"(ackw2) \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts = \"(?) \";\n\t\t\tbreak;\n\t\t} s; }),\n\t\tep->irqs, stat_flg,\n\t\t(stat_flg & UDC_NO_RXPACKET) ? \"no_rxpacket \" : \"\",\n\t\t(stat_flg & UDC_MISS_IN) ? \"miss_in \" : \"\",\n\t\t(stat_flg & UDC_DATA_FLUSH) ? \"data_flush \" : \"\",\n\t\t(stat_flg & UDC_ISO_ERR) ? \"iso_err \" : \"\",\n\t\t(stat_flg & UDC_ISO_FIFO_EMPTY) ? \"iso_fifo_empty \" : \"\",\n\t\t(stat_flg & UDC_ISO_FIFO_FULL) ? \"iso_fifo_full \" : \"\",\n\t\t(stat_flg & UDC_EP_HALTED) ? \"HALT \" : \"\",\n\t\t(stat_flg & UDC_STALL) ? \"STALL \" : \"\",\n\t\t(stat_flg & UDC_NAK) ? \"NAK \" : \"\",\n\t\t(stat_flg & UDC_ACK) ? \"ACK \" : \"\",\n\t\t(stat_flg & UDC_FIFO_EN) ? \"fifo_en \" : \"\",\n\t\t(stat_flg & UDC_NON_ISO_FIFO_EMPTY) ? \"fifo_empty \" : \"\",\n\t\t(stat_flg & UDC_NON_ISO_FIFO_FULL) ? \"fifo_full \" : \"\");\n\n\tif (list_empty(&ep->queue))\n\t\tseq_printf(s, \"\\t(queue empty)\\n\");\n\telse\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tunsigned\tlength = req->req.actual;\n\n\t\t\tif (use_dma && buf[0]) {\n\t\t\t\tlength += ((ep->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t\t\t? dma_src_len : dma_dest_len)\n\t\t\t\t\t(ep, req->req.dma + length);\n\t\t\t\tbuf[0] = 0;\n\t\t\t}\n\t\t\tseq_printf(s, \"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t\t&req->req, length,\n\t\t\t\t\treq->req.length, req->req.buf);\n\t\t}\n}\n\nstatic char *trx_mode(unsigned m, int enabled)\n{\n\tswitch (m) {\n\tcase 0:\n\t\treturn enabled ? \"*6wire\" : \"unused\";\n\tcase 1:\n\t\treturn \"4wire\";\n\tcase 2:\n\t\treturn \"3wire\";\n\tcase 3:\n\t\treturn \"6wire\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int proc_otg_show(struct seq_file *s)\n{\n\tu32\t\ttmp;\n\tu32\t\ttrans = 0;\n\tchar\t\t*ctrl_name = \"(UNKNOWN)\";\n\n\ttmp = omap_readl(OTG_REV);\n\tctrl_name = \"transceiver_ctrl\";\n\ttrans = omap_readw(USB_TRANSCEIVER_CTRL);\n\tseq_printf(s, \"\\nOTG rev %d.%d, %s %05x\\n\",\n\t\ttmp >> 4, tmp & 0xf, ctrl_name, trans);\n\ttmp = omap_readw(OTG_SYSCON_1);\n\tseq_printf(s, \"otg_syscon1 %08x usb2 %s, usb1 %s, usb0 %s,\"\n\t\t\tFOURBITS \"\\n\", tmp,\n\t\ttrx_mode(USB2_TRX_MODE(tmp), trans & CONF_USB2_UNI_R),\n\t\ttrx_mode(USB1_TRX_MODE(tmp), trans & CONF_USB1_UNI_R),\n\t\t(USB0_TRX_MODE(tmp) == 0 && !cpu_is_omap1710())\n\t\t\t? \"internal\"\n\t\t\t: trx_mode(USB0_TRX_MODE(tmp), 1),\n\t\t(tmp & OTG_IDLE_EN) ? \" !otg\" : \"\",\n\t\t(tmp & HST_IDLE_EN) ? \" !host\" : \"\",\n\t\t(tmp & DEV_IDLE_EN) ? \" !dev\" : \"\",\n\t\t(tmp & OTG_RESET_DONE) ? \" reset_done\" : \" reset_active\");\n\ttmp = omap_readl(OTG_SYSCON_2);\n\tseq_printf(s, \"otg_syscon2 %08x%s\" EIGHTBITS\n\t\t\t\" b_ase_brst=%d hmc=%d\\n\", tmp,\n\t\t(tmp & OTG_EN) ? \" otg_en\" : \"\",\n\t\t(tmp & USBX_SYNCHRO) ? \" synchro\" : \"\",\n\t\t \n\t\t(tmp & SRP_DATA) ? \" srp_data\" : \"\",\n\t\t(tmp & SRP_VBUS) ? \" srp_vbus\" : \"\",\n\t\t(tmp & OTG_PADEN) ? \" otg_paden\" : \"\",\n\t\t(tmp & HMC_PADEN) ? \" hmc_paden\" : \"\",\n\t\t(tmp & UHOST_EN) ? \" uhost_en\" : \"\",\n\t\t(tmp & HMC_TLLSPEED) ? \" tllspeed\" : \"\",\n\t\t(tmp & HMC_TLLATTACH) ? \" tllattach\" : \"\",\n\t\tB_ASE_BRST(tmp),\n\t\tOTG_HMC(tmp));\n\ttmp = omap_readl(OTG_CTRL);\n\tseq_printf(s, \"otg_ctrl    %06x\" EIGHTBITS EIGHTBITS \"%s\\n\", tmp,\n\t\t(tmp & OTG_ASESSVLD) ? \" asess\" : \"\",\n\t\t(tmp & OTG_BSESSEND) ? \" bsess_end\" : \"\",\n\t\t(tmp & OTG_BSESSVLD) ? \" bsess\" : \"\",\n\t\t(tmp & OTG_VBUSVLD) ? \" vbus\" : \"\",\n\t\t(tmp & OTG_ID) ? \" id\" : \"\",\n\t\t(tmp & OTG_DRIVER_SEL) ? \" DEVICE\" : \" HOST\",\n\t\t(tmp & OTG_A_SETB_HNPEN) ? \" a_setb_hnpen\" : \"\",\n\t\t(tmp & OTG_A_BUSREQ) ? \" a_bus\" : \"\",\n\t\t(tmp & OTG_B_HNPEN) ? \" b_hnpen\" : \"\",\n\t\t(tmp & OTG_B_BUSREQ) ? \" b_bus\" : \"\",\n\t\t(tmp & OTG_BUSDROP) ? \" busdrop\" : \"\",\n\t\t(tmp & OTG_PULLDOWN) ? \" down\" : \"\",\n\t\t(tmp & OTG_PULLUP) ? \" up\" : \"\",\n\t\t(tmp & OTG_DRV_VBUS) ? \" drv\" : \"\",\n\t\t(tmp & OTG_PD_VBUS) ? \" pd_vb\" : \"\",\n\t\t(tmp & OTG_PU_VBUS) ? \" pu_vb\" : \"\",\n\t\t(tmp & OTG_PU_ID) ? \" pu_id\" : \"\"\n\t\t);\n\ttmp = omap_readw(OTG_IRQ_EN);\n\tseq_printf(s, \"otg_irq_en  %04x\" \"\\n\", tmp);\n\ttmp = omap_readw(OTG_IRQ_SRC);\n\tseq_printf(s, \"otg_irq_src %04x\" \"\\n\", tmp);\n\ttmp = omap_readw(OTG_OUTCTRL);\n\tseq_printf(s, \"otg_outctrl %04x\" \"\\n\", tmp);\n\ttmp = omap_readw(OTG_TEST);\n\tseq_printf(s, \"otg_test    %04x\" \"\\n\", tmp);\n\treturn 0;\n}\n\nstatic int proc_udc_show(struct seq_file *s, void *_)\n{\n\tu32\t\ttmp;\n\tstruct omap_ep\t*ep;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tseq_printf(s, \"%s, version: \" DRIVER_VERSION\n#ifdef\tUSE_ISO\n\t\t\" (iso)\"\n#endif\n\t\t\"%s\\n\",\n\t\tdriver_desc,\n\t\tuse_dma ?  \" (dma)\" : \"\");\n\n\ttmp = omap_readw(UDC_REV) & 0xff;\n\tseq_printf(s,\n\t\t\"UDC rev %d.%d, fifo mode %d, gadget %s\\n\"\n\t\t\"hmc %d, transceiver %s\\n\",\n\t\ttmp >> 4, tmp & 0xf,\n\t\tfifo_mode,\n\t\tudc->driver ? udc->driver->driver.name : \"(none)\",\n\t\tHMC,\n\t\tudc->transceiver\n\t\t\t? udc->transceiver->label\n\t\t\t: (cpu_is_omap1710()\n\t\t\t\t? \"external\" : \"(none)\"));\n\tseq_printf(s, \"ULPD control %04x req %04x status %04x\\n\",\n\t\tomap_readw(ULPD_CLOCK_CTRL),\n\t\tomap_readw(ULPD_SOFT_REQ),\n\t\tomap_readw(ULPD_STATUS_REQ));\n\n\t \n\tif (!cpu_is_omap15xx())\n\t\tproc_otg_show(s);\n\n\ttmp = omap_readw(UDC_SYSCON1);\n\tseq_printf(s, \"\\nsyscon1     %04x\" EIGHTBITS \"\\n\", tmp,\n\t\t(tmp & UDC_CFG_LOCK) ? \" cfg_lock\" : \"\",\n\t\t(tmp & UDC_DATA_ENDIAN) ? \" data_endian\" : \"\",\n\t\t(tmp & UDC_DMA_ENDIAN) ? \" dma_endian\" : \"\",\n\t\t(tmp & UDC_NAK_EN) ? \" nak\" : \"\",\n\t\t(tmp & UDC_AUTODECODE_DIS) ? \" autodecode_dis\" : \"\",\n\t\t(tmp & UDC_SELF_PWR) ? \" self_pwr\" : \"\",\n\t\t(tmp & UDC_SOFF_DIS) ? \" soff_dis\" : \"\",\n\t\t(tmp & UDC_PULLUP_EN) ? \" PULLUP\" : \"\");\n\t \n\n\t \n\tif (!(tmp & UDC_PULLUP_EN)) {\n\t\tseq_printf(s, \"(suspended)\\n\");\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn 0;\n\t}\n\n\ttmp = omap_readw(UDC_DEVSTAT);\n\tseq_printf(s, \"devstat     %04x\" EIGHTBITS \"%s%s\\n\", tmp,\n\t\t(tmp & UDC_B_HNP_ENABLE) ? \" b_hnp\" : \"\",\n\t\t(tmp & UDC_A_HNP_SUPPORT) ? \" a_hnp\" : \"\",\n\t\t(tmp & UDC_A_ALT_HNP_SUPPORT) ? \" a_alt_hnp\" : \"\",\n\t\t(tmp & UDC_R_WK_OK) ? \" r_wk_ok\" : \"\",\n\t\t(tmp & UDC_USB_RESET) ? \" usb_reset\" : \"\",\n\t\t(tmp & UDC_SUS) ? \" SUS\" : \"\",\n\t\t(tmp & UDC_CFG) ? \" CFG\" : \"\",\n\t\t(tmp & UDC_ADD) ? \" ADD\" : \"\",\n\t\t(tmp & UDC_DEF) ? \" DEF\" : \"\",\n\t\t(tmp & UDC_ATT) ? \" ATT\" : \"\");\n\tseq_printf(s, \"sof         %04x\\n\", omap_readw(UDC_SOF));\n\ttmp = omap_readw(UDC_IRQ_EN);\n\tseq_printf(s, \"irq_en      %04x\" FOURBITS \"%s\\n\", tmp,\n\t\t(tmp & UDC_SOF_IE) ? \" sof\" : \"\",\n\t\t(tmp & UDC_EPN_RX_IE) ? \" epn_rx\" : \"\",\n\t\t(tmp & UDC_EPN_TX_IE) ? \" epn_tx\" : \"\",\n\t\t(tmp & UDC_DS_CHG_IE) ? \" ds_chg\" : \"\",\n\t\t(tmp & UDC_EP0_IE) ? \" ep0\" : \"\");\n\ttmp = omap_readw(UDC_IRQ_SRC);\n\tseq_printf(s, \"irq_src     %04x\" EIGHTBITS \"%s%s\\n\", tmp,\n\t\t(tmp & UDC_TXN_DONE) ? \" txn_done\" : \"\",\n\t\t(tmp & UDC_RXN_CNT) ? \" rxn_cnt\" : \"\",\n\t\t(tmp & UDC_RXN_EOT) ? \" rxn_eot\" : \"\",\n\t\t(tmp & UDC_IRQ_SOF) ? \" sof\" : \"\",\n\t\t(tmp & UDC_EPN_RX) ? \" epn_rx\" : \"\",\n\t\t(tmp & UDC_EPN_TX) ? \" epn_tx\" : \"\",\n\t\t(tmp & UDC_DS_CHG) ? \" ds_chg\" : \"\",\n\t\t(tmp & UDC_SETUP) ? \" setup\" : \"\",\n\t\t(tmp & UDC_EP0_RX) ? \" ep0out\" : \"\",\n\t\t(tmp & UDC_EP0_TX) ? \" ep0in\" : \"\");\n\tif (use_dma) {\n\t\tunsigned i;\n\n\t\ttmp = omap_readw(UDC_DMA_IRQ_EN);\n\t\tseq_printf(s, \"dma_irq_en  %04x%s\" EIGHTBITS \"\\n\", tmp,\n\t\t\t(tmp & UDC_TX_DONE_IE(3)) ? \" tx2_done\" : \"\",\n\t\t\t(tmp & UDC_RX_CNT_IE(3)) ? \" rx2_cnt\" : \"\",\n\t\t\t(tmp & UDC_RX_EOT_IE(3)) ? \" rx2_eot\" : \"\",\n\n\t\t\t(tmp & UDC_TX_DONE_IE(2)) ? \" tx1_done\" : \"\",\n\t\t\t(tmp & UDC_RX_CNT_IE(2)) ? \" rx1_cnt\" : \"\",\n\t\t\t(tmp & UDC_RX_EOT_IE(2)) ? \" rx1_eot\" : \"\",\n\n\t\t\t(tmp & UDC_TX_DONE_IE(1)) ? \" tx0_done\" : \"\",\n\t\t\t(tmp & UDC_RX_CNT_IE(1)) ? \" rx0_cnt\" : \"\",\n\t\t\t(tmp & UDC_RX_EOT_IE(1)) ? \" rx0_eot\" : \"\");\n\n\t\ttmp = omap_readw(UDC_RXDMA_CFG);\n\t\tseq_printf(s, \"rxdma_cfg   %04x\\n\", tmp);\n\t\tif (tmp) {\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif ((tmp & (0x0f << (i * 4))) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tseq_printf(s, \"rxdma[%d]    %04x\\n\", i,\n\t\t\t\t\t\tomap_readw(UDC_RXDMA(i + 1)));\n\t\t\t}\n\t\t}\n\t\ttmp = omap_readw(UDC_TXDMA_CFG);\n\t\tseq_printf(s, \"txdma_cfg   %04x\\n\", tmp);\n\t\tif (tmp) {\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tif (!(tmp & (0x0f << (i * 4))))\n\t\t\t\t\tcontinue;\n\t\t\t\tseq_printf(s, \"txdma[%d]    %04x\\n\", i,\n\t\t\t\t\t\tomap_readw(UDC_TXDMA(i + 1)));\n\t\t\t}\n\t\t}\n\t}\n\n\ttmp = omap_readw(UDC_DEVSTAT);\n\tif (tmp & UDC_ATT) {\n\t\tproc_ep_show(s, &udc->ep[0]);\n\t\tif (tmp & UDC_ADD) {\n\t\t\tlist_for_each_entry(ep, &udc->gadget.ep_list,\n\t\t\t\t\tep.ep_list) {\n\t\t\t\tif (ep->ep.desc)\n\t\t\t\t\tproc_ep_show(s, ep);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic void create_proc_file(void)\n{\n\tproc_create_single(proc_filename, 0, NULL, proc_udc_show);\n}\n\nstatic void remove_proc_file(void)\n{\n\tremove_proc_entry(proc_filename, NULL);\n}\n\n#else\n\nstatic inline void create_proc_file(void) {}\nstatic inline void remove_proc_file(void) {}\n\n#endif\n\n \n\n \nstatic unsigned\nomap_ep_setup(char *name, u8 addr, u8 type,\n\t\tunsigned buf, unsigned maxp, int dbuf)\n{\n\tstruct omap_ep\t*ep;\n\tu16\t\tepn_rxtx = 0;\n\n\t \n\tep = &udc->ep[addr & 0xf];\n\tif (addr & USB_DIR_IN)\n\t\tep += 16;\n\n\t \n\tBUG_ON(ep->name[0]);\n\n\t \n\tif (type == USB_ENDPOINT_XFER_ISOC) {\n\t\tswitch (maxp) {\n\t\tcase 8:\n\t\t\tepn_rxtx = 0 << 12;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tepn_rxtx = 1 << 12;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tepn_rxtx = 2 << 12;\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tepn_rxtx = 3 << 12;\n\t\t\tbreak;\n\t\tcase 128:\n\t\t\tepn_rxtx = 4 << 12;\n\t\t\tbreak;\n\t\tcase 256:\n\t\t\tepn_rxtx = 5 << 12;\n\t\t\tbreak;\n\t\tcase 512:\n\t\t\tepn_rxtx = 6 << 12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tepn_rxtx |= UDC_EPN_RX_ISO;\n\t\tdbuf = 1;\n\t} else {\n\t\t \n\t\tif (!use_dma || cpu_is_omap15xx())\n\t\t\tdbuf = 0;\n\n\t\tswitch (maxp) {\n\t\tcase 8:\n\t\t\tepn_rxtx = 0 << 12;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tepn_rxtx = 1 << 12;\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tepn_rxtx = 2 << 12;\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tepn_rxtx = 3 << 12;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t\tif (dbuf && addr)\n\t\t\tepn_rxtx |= UDC_EPN_RX_DB;\n\t\ttimer_setup(&ep->timer, pio_out_timer, 0);\n\t}\n\tif (addr)\n\t\tepn_rxtx |= UDC_EPN_RX_VALID;\n\tBUG_ON(buf & 0x07);\n\tepn_rxtx |= buf >> 3;\n\n\tDBG(\"%s addr %02x rxtx %04x maxp %d%s buf %d\\n\",\n\t\tname, addr, epn_rxtx, maxp, dbuf ? \"x2\" : \"\", buf);\n\n\tif (addr & USB_DIR_IN)\n\t\tomap_writew(epn_rxtx, UDC_EP_TX(addr & 0xf));\n\telse\n\t\tomap_writew(epn_rxtx, UDC_EP_RX(addr));\n\n\t \n\tbuf += maxp;\n\tif (dbuf)\n\t\tbuf += maxp;\n\tBUG_ON(buf > 2048);\n\n\t \n\tBUG_ON(strlen(name) >= sizeof ep->name);\n\tstrscpy(ep->name, name, sizeof(ep->name));\n\tINIT_LIST_HEAD(&ep->queue);\n\tINIT_LIST_HEAD(&ep->iso);\n\tep->bEndpointAddress = addr;\n\tep->bmAttributes = type;\n\tep->double_buf = dbuf;\n\tep->udc = udc;\n\n\tswitch (type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tep->ep.caps.type_control = true;\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tep->ep.caps.type_iso = true;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep->ep.caps.type_bulk = true;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep->ep.caps.type_int = true;\n\t\tbreak;\n\t}\n\n\tif (addr & USB_DIR_IN)\n\t\tep->ep.caps.dir_in = true;\n\telse\n\t\tep->ep.caps.dir_out = true;\n\n\tep->ep.name = ep->name;\n\tep->ep.ops = &omap_ep_ops;\n\tep->maxpacket = maxp;\n\tusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\n\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\n\treturn buf;\n}\n\nstatic void omap_udc_release(struct device *dev)\n{\n\tpullup_disable(udc);\n\tif (!IS_ERR_OR_NULL(udc->transceiver)) {\n\t\tusb_put_phy(udc->transceiver);\n\t\tudc->transceiver = NULL;\n\t}\n\tomap_writew(0, UDC_SYSCON1);\n\tremove_proc_file();\n\tif (udc->dc_clk) {\n\t\tif (udc->clk_requested)\n\t\t\tomap_udc_enable_clock(0);\n\t\tclk_unprepare(udc->hhc_clk);\n\t\tclk_unprepare(udc->dc_clk);\n\t\tclk_put(udc->hhc_clk);\n\t\tclk_put(udc->dc_clk);\n\t}\n\tif (udc->done)\n\t\tcomplete(udc->done);\n\tkfree(udc);\n}\n\nstatic int\nomap_udc_setup(struct platform_device *odev, struct usb_phy *xceiv)\n{\n\tunsigned\ttmp, buf;\n\n\t \n\tomap_writew(0, UDC_SYSCON1);\n\tomap_writew(0, UDC_IRQ_EN);\n\tomap_writew(UDC_IRQ_SRC_MASK, UDC_IRQ_SRC);\n\tomap_writew(0, UDC_DMA_IRQ_EN);\n\tomap_writew(0, UDC_RXDMA_CFG);\n\tomap_writew(0, UDC_TXDMA_CFG);\n\n\t \n\t \n\n\tudc = kzalloc(sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&udc->lock);\n\n\tudc->gadget.ops = &omap_gadget_ops;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tINIT_LIST_HEAD(&udc->iso);\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.max_speed = USB_SPEED_FULL;\n\tudc->gadget.name = driver_name;\n\tudc->gadget.quirk_ep_out_aligned_size = 1;\n\tudc->transceiver = xceiv;\n\n\t \n\tbuf = omap_ep_setup(\"ep0\", 0, USB_ENDPOINT_XFER_CONTROL,\n\t\t\t8  , 64  , 0);\n\tlist_del_init(&udc->ep[0].ep.ep_list);\n\n\t \n\tfor (tmp = 1; tmp < 15; tmp++) {\n\t\tomap_writew(0, UDC_EP_RX(tmp));\n\t\tomap_writew(0, UDC_EP_TX(tmp));\n\t}\n\n#define OMAP_BULK_EP(name, addr) \\\n\tbuf = omap_ep_setup(name \"-bulk\", addr, \\\n\t\t\tUSB_ENDPOINT_XFER_BULK, buf, 64, 1);\n#define OMAP_INT_EP(name, addr, maxp) \\\n\tbuf = omap_ep_setup(name \"-int\", addr, \\\n\t\t\tUSB_ENDPOINT_XFER_INT, buf, maxp, 0);\n#define OMAP_ISO_EP(name, addr, maxp) \\\n\tbuf = omap_ep_setup(name \"-iso\", addr, \\\n\t\t\tUSB_ENDPOINT_XFER_ISOC, buf, maxp, 1);\n\n\tswitch (fifo_mode) {\n\tcase 0:\n\t\tOMAP_BULK_EP(\"ep1in\",  USB_DIR_IN  | 1);\n\t\tOMAP_BULK_EP(\"ep2out\", USB_DIR_OUT | 2);\n\t\tOMAP_INT_EP(\"ep3in\",   USB_DIR_IN  | 3, 16);\n\t\tbreak;\n\tcase 1:\n\t\tOMAP_BULK_EP(\"ep1in\",  USB_DIR_IN  | 1);\n\t\tOMAP_BULK_EP(\"ep2out\", USB_DIR_OUT | 2);\n\t\tOMAP_INT_EP(\"ep9in\",   USB_DIR_IN  | 9, 16);\n\n\t\tOMAP_BULK_EP(\"ep3in\",  USB_DIR_IN  | 3);\n\t\tOMAP_BULK_EP(\"ep4out\", USB_DIR_OUT | 4);\n\t\tOMAP_INT_EP(\"ep10in\",  USB_DIR_IN  | 10, 16);\n\n\t\tOMAP_BULK_EP(\"ep5in\",  USB_DIR_IN  | 5);\n\t\tOMAP_BULK_EP(\"ep5out\", USB_DIR_OUT | 5);\n\t\tOMAP_INT_EP(\"ep11in\",  USB_DIR_IN  | 11, 16);\n\n\t\tOMAP_BULK_EP(\"ep6in\",  USB_DIR_IN  | 6);\n\t\tOMAP_BULK_EP(\"ep6out\", USB_DIR_OUT | 6);\n\t\tOMAP_INT_EP(\"ep12in\",  USB_DIR_IN  | 12, 16);\n\n\t\tOMAP_BULK_EP(\"ep7in\",  USB_DIR_IN  | 7);\n\t\tOMAP_BULK_EP(\"ep7out\", USB_DIR_OUT | 7);\n\t\tOMAP_INT_EP(\"ep13in\",  USB_DIR_IN  | 13, 16);\n\t\tOMAP_INT_EP(\"ep13out\", USB_DIR_OUT | 13, 16);\n\n\t\tOMAP_BULK_EP(\"ep8in\",  USB_DIR_IN  | 8);\n\t\tOMAP_BULK_EP(\"ep8out\", USB_DIR_OUT | 8);\n\t\tOMAP_INT_EP(\"ep14in\",  USB_DIR_IN  | 14, 16);\n\t\tOMAP_INT_EP(\"ep14out\", USB_DIR_OUT | 14, 16);\n\n\t\tOMAP_BULK_EP(\"ep15in\",  USB_DIR_IN  | 15);\n\t\tOMAP_BULK_EP(\"ep15out\", USB_DIR_OUT | 15);\n\n\t\tbreak;\n\n#ifdef\tUSE_ISO\n\tcase 2:\t\t\t \n\t\tOMAP_ISO_EP(\"ep1in\",   USB_DIR_IN  | 1, 256);\n\t\tOMAP_ISO_EP(\"ep2out\",  USB_DIR_OUT | 2, 256);\n\t\tOMAP_ISO_EP(\"ep3in\",   USB_DIR_IN  | 3, 128);\n\t\tOMAP_ISO_EP(\"ep4out\",  USB_DIR_OUT | 4, 128);\n\n\t\tOMAP_INT_EP(\"ep5in\",   USB_DIR_IN  | 5, 16);\n\n\t\tOMAP_BULK_EP(\"ep6in\",  USB_DIR_IN  | 6);\n\t\tOMAP_BULK_EP(\"ep7out\", USB_DIR_OUT | 7);\n\t\tOMAP_INT_EP(\"ep8in\",   USB_DIR_IN  | 8, 16);\n\t\tbreak;\n\tcase 3:\t\t\t \n\t\tOMAP_BULK_EP(\"ep1in\",  USB_DIR_IN  | 1);\n\t\tOMAP_BULK_EP(\"ep2out\", USB_DIR_OUT | 2);\n\t\tOMAP_INT_EP(\"ep3in\",   USB_DIR_IN  | 3, 16);\n\n\t\tOMAP_BULK_EP(\"ep4in\",  USB_DIR_IN  | 4);\n\t\tOMAP_BULK_EP(\"ep5out\", USB_DIR_OUT | 5);\n\t\tOMAP_INT_EP(\"ep6in\",   USB_DIR_IN  | 6, 16);\n\n\t\tOMAP_ISO_EP(\"ep7in\",   USB_DIR_IN  | 7, 256);\n\t\tOMAP_ISO_EP(\"ep8out\",  USB_DIR_OUT | 8, 256);\n\t\tOMAP_INT_EP(\"ep9in\",   USB_DIR_IN  | 9, 16);\n\t\tbreak;\n#endif\n\n\t \n\n\tdefault:\n\t\tERR(\"unsupported fifo_mode #%d\\n\", fifo_mode);\n\t\treturn -ENODEV;\n\t}\n\tomap_writew(UDC_CFG_LOCK|UDC_SELF_PWR, UDC_SYSCON1);\n\tINFO(\"fifo mode %d, %d bytes not used\\n\", fifo_mode, 2048 - buf);\n\treturn 0;\n}\n\nstatic int omap_udc_probe(struct platform_device *pdev)\n{\n\tint\t\t\tstatus = -ENODEV;\n\tint\t\t\thmc;\n\tstruct usb_phy\t\t*xceiv = NULL;\n\tconst char\t\t*type = NULL;\n\tstruct omap_usb_config\t*config = dev_get_platdata(&pdev->dev);\n\tstruct clk\t\t*dc_clk = NULL;\n\tstruct clk\t\t*hhc_clk = NULL;\n\n\t \n\tif (!request_mem_region(pdev->resource[0].start,\n\t\t\tresource_size(&pdev->resource[0]),\n\t\t\tdriver_name)) {\n\t\tDBG(\"request_mem_region failed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (cpu_is_omap16xx()) {\n\t\tdc_clk = clk_get(&pdev->dev, \"usb_dc_ck\");\n\t\thhc_clk = clk_get(&pdev->dev, \"usb_hhc_ck\");\n\t\tBUG_ON(IS_ERR(dc_clk) || IS_ERR(hhc_clk));\n\t\t \n\t\tclk_prepare_enable(dc_clk);\n\t\tclk_prepare_enable(hhc_clk);\n\t\tudelay(100);\n\t}\n\n\tINFO(\"OMAP UDC rev %d.%d%s\\n\",\n\t\tomap_readw(UDC_REV) >> 4, omap_readw(UDC_REV) & 0xf,\n\t\tconfig->otg ? \", Mini-AB\" : \"\");\n\n\t \n\tif (cpu_is_omap15xx()) {\n\t\thmc = HMC_1510;\n\t\ttype = \"(unknown)\";\n\n\t\tif (machine_without_vbus_sense()) {\n\t\t\t \n\t\t\tu32 tmp = omap_readl(FUNC_MUX_CTRL_0);\n\t\t\ttmp &= ~VBUS_CTRL_1510;\n\t\t\tomap_writel(tmp, FUNC_MUX_CTRL_0);\n\t\t\ttmp |= VBUS_MODE_1510;\n\t\t\ttmp &= ~VBUS_CTRL_1510;\n\t\t\tomap_writel(tmp, FUNC_MUX_CTRL_0);\n\t\t}\n\t} else {\n\t\t \n\t\txceiv = usb_get_phy(USB_PHY_TYPE_USB2);\n\t\tif (!IS_ERR_OR_NULL(xceiv))\n\t\t\ttype = xceiv->label;\n\t\telse if (config->otg) {\n\t\t\tDBG(\"OTG requires external transceiver!\\n\");\n\t\t\tgoto cleanup0;\n\t\t}\n\n\t\thmc = HMC_1610;\n\n\t\tswitch (hmc) {\n\t\tcase 0:\t\t\t \n\t\tcase 4:\n\t\tcase 12:\n\t\tcase 20:\n\t\t\tif (!cpu_is_omap1710()) {\n\t\t\t\ttype = \"integrated\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\tcase 11:\n\t\tcase 16:\n\t\tcase 19:\n\t\tcase 25:\n\t\t\tif (IS_ERR_OR_NULL(xceiv)) {\n\t\t\t\tDBG(\"external transceiver not registered!\\n\");\n\t\t\t\ttype = \"unknown\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 21:\t\t\t \n\t\t\ttype = \"loopback\";\n\t\t\tbreak;\n\t\tcase 14:\t\t\t \n\t\t\tif (cpu_is_omap1710())\n\t\t\t\tgoto bad_on_1710;\n\t\t\tfallthrough;\n\t\tcase 13:\n\t\tcase 15:\n\t\t\ttype = \"no\";\n\t\t\tbreak;\n\n\t\tdefault:\nbad_on_1710:\n\t\t\tERR(\"unrecognized UDC HMC mode %d\\n\", hmc);\n\t\t\tgoto cleanup0;\n\t\t}\n\t}\n\n\tINFO(\"hmc mode %d, %s transceiver\\n\", hmc, type);\n\n\t \n\tstatus = omap_udc_setup(pdev, xceiv);\n\tif (status)\n\t\tgoto cleanup0;\n\n\txceiv = NULL;\n\t \n\tpullup_disable(udc);\n#if\tIS_ENABLED(CONFIG_USB_OHCI_HCD)\n\tudc->gadget.is_otg = (config->otg != 0);\n#endif\n\n\t \n\tif (omap_readw(UDC_REV) >= 0x61)\n\t\tudc->clr_halt = UDC_RESET_EP | UDC_CLRDATA_TOGGLE;\n\telse\n\t\tudc->clr_halt = UDC_RESET_EP;\n\n\t \n\tstatus = devm_request_irq(&pdev->dev, pdev->resource[1].start,\n\t\t\t\t  omap_udc_irq, 0, driver_name, udc);\n\tif (status != 0) {\n\t\tERR(\"can't get irq %d, err %d\\n\",\n\t\t\t(int) pdev->resource[1].start, status);\n\t\tgoto cleanup1;\n\t}\n\n\t \n\tstatus = devm_request_irq(&pdev->dev, pdev->resource[2].start,\n\t\t\t\t  omap_udc_pio_irq, 0, \"omap_udc pio\", udc);\n\tif (status != 0) {\n\t\tERR(\"can't get irq %d, err %d\\n\",\n\t\t\t(int) pdev->resource[2].start, status);\n\t\tgoto cleanup1;\n\t}\n#ifdef\tUSE_ISO\n\tstatus = devm_request_irq(&pdev->dev, pdev->resource[3].start,\n\t\t\t\t  omap_udc_iso_irq, 0, \"omap_udc iso\", udc);\n\tif (status != 0) {\n\t\tERR(\"can't get irq %d, err %d\\n\",\n\t\t\t(int) pdev->resource[3].start, status);\n\t\tgoto cleanup1;\n\t}\n#endif\n\tif (cpu_is_omap16xx()) {\n\t\tudc->dc_clk = dc_clk;\n\t\tudc->hhc_clk = hhc_clk;\n\t\tclk_disable(hhc_clk);\n\t\tclk_disable(dc_clk);\n\t}\n\n\tcreate_proc_file();\n\treturn usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,\n\t\t\t\t\t  omap_udc_release);\n\ncleanup1:\n\tkfree(udc);\n\tudc = NULL;\n\ncleanup0:\n\tif (!IS_ERR_OR_NULL(xceiv))\n\t\tusb_put_phy(xceiv);\n\n\tif (cpu_is_omap16xx()) {\n\t\tclk_disable_unprepare(hhc_clk);\n\t\tclk_disable_unprepare(dc_clk);\n\t\tclk_put(hhc_clk);\n\t\tclk_put(dc_clk);\n\t}\n\n\trelease_mem_region(pdev->resource[0].start,\n\t\t\t   resource_size(&pdev->resource[0]));\n\n\treturn status;\n}\n\nstatic void omap_udc_remove(struct platform_device *pdev)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tudc->done = &done;\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\twait_for_completion(&done);\n\n\trelease_mem_region(pdev->resource[0].start,\n\t\t\t   resource_size(&pdev->resource[0]));\n}\n\n \n\nstatic int omap_udc_suspend(struct platform_device *dev, pm_message_t message)\n{\n\tu32\tdevstat;\n\n\tdevstat = omap_readw(UDC_DEVSTAT);\n\n\t \n\tif ((devstat & UDC_ATT) != 0 && (devstat & UDC_SUS) == 0) {\n\t\tWARNING(\"session active; suspend requires disconnect\\n\");\n\t\tomap_pullup(&udc->gadget, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_udc_resume(struct platform_device *dev)\n{\n\tDBG(\"resume + wakeup/SRP\\n\");\n\tomap_pullup(&udc->gadget, 1);\n\n\t \n\tmsleep(100);\n\treturn omap_wakeup(&udc->gadget);\n}\n\n \n\nstatic struct platform_driver udc_driver = {\n\t.probe\t\t= omap_udc_probe,\n\t.remove_new\t= omap_udc_remove,\n\t.suspend\t= omap_udc_suspend,\n\t.resume\t\t= omap_udc_resume,\n\t.driver\t\t= {\n\t\t.name\t= driver_name,\n\t},\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:omap_udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}