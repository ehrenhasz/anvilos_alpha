{
  "module_name": "fsl_udc_core.c",
  "hash_id": "9e46b1186b7c33a60e4e24502553388449046c47a931dcae83552aecbdc8d386",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/fsl_udc_core.c",
  "human_readable_source": "\n \n\n#undef VERBOSE\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/fsl_devices.h>\n#include <linux/dmapool.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/unaligned.h>\n#include <asm/dma.h>\n\n#include \"fsl_usb2_udc.h\"\n\n#define\tDRIVER_DESC\t\"Freescale High-Speed USB SOC Device Controller driver\"\n#define\tDRIVER_AUTHOR\t\"Li Yang/Jiang Bo\"\n#define\tDRIVER_VERSION\t\"Apr 20, 2007\"\n\n#define\tDMA_ADDR_INVALID\t(~(dma_addr_t)0)\n\nstatic const char driver_name[] = \"fsl-usb2-udc\";\n\nstatic struct usb_dr_device __iomem *dr_regs;\n\nstatic struct usb_sys_interface __iomem *usb_sys_regs;\n\n \nstatic struct fsl_udc *udc_controller = NULL;\n\nstatic const struct usb_endpoint_descriptor\nfsl_ep0_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\t0,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize =\tUSB_MAX_CTRL_PAYLOAD,\n};\n\nstatic void fsl_ep_fifo_flush(struct usb_ep *_ep);\n\n#ifdef CONFIG_PPC32\n \nstatic u32 _fsl_readl_be(const unsigned __iomem *p)\n{\n\treturn in_be32(p);\n}\n\nstatic u32 _fsl_readl_le(const unsigned __iomem *p)\n{\n\treturn in_le32(p);\n}\n\nstatic void _fsl_writel_be(u32 v, unsigned __iomem *p)\n{\n\tout_be32(p, v);\n}\n\nstatic void _fsl_writel_le(u32 v, unsigned __iomem *p)\n{\n\tout_le32(p, v);\n}\n\nstatic u32 (*_fsl_readl)(const unsigned __iomem *p);\nstatic void (*_fsl_writel)(u32 v, unsigned __iomem *p);\n\n#define fsl_readl(p)\t\t(*_fsl_readl)((p))\n#define fsl_writel(v, p)\t(*_fsl_writel)((v), (p))\n\nstatic inline void fsl_set_accessors(struct fsl_usb2_platform_data *pdata)\n{\n\tif (pdata->big_endian_mmio) {\n\t\t_fsl_readl = _fsl_readl_be;\n\t\t_fsl_writel = _fsl_writel_be;\n\t} else {\n\t\t_fsl_readl = _fsl_readl_le;\n\t\t_fsl_writel = _fsl_writel_le;\n\t}\n}\n\nstatic inline u32 cpu_to_hc32(const u32 x)\n{\n\treturn udc_controller->pdata->big_endian_desc\n\t\t? (__force u32)cpu_to_be32(x)\n\t\t: (__force u32)cpu_to_le32(x);\n}\n\nstatic inline u32 hc32_to_cpu(const u32 x)\n{\n\treturn udc_controller->pdata->big_endian_desc\n\t\t? be32_to_cpu((__force __be32)x)\n\t\t: le32_to_cpu((__force __le32)x);\n}\n#else  \nstatic inline void fsl_set_accessors(struct fsl_usb2_platform_data *pdata) {}\n\n#define fsl_readl(addr)\t\treadl(addr)\n#define fsl_writel(val32, addr) writel(val32, addr)\n#define cpu_to_hc32(x)\t\tcpu_to_le32(x)\n#define hc32_to_cpu(x)\t\tle32_to_cpu(x)\n#endif  \n\n \n \nstatic void done(struct fsl_ep *ep, struct fsl_req *req, int status)\n__releases(ep->udc->lock)\n__acquires(ep->udc->lock)\n{\n\tstruct fsl_udc *udc = NULL;\n\tunsigned char stopped = ep->stopped;\n\tstruct ep_td_struct *curr_td, *next_td;\n\tint j;\n\n\tudc = (struct fsl_udc *)ep->udc;\n\t \n\tlist_del_init(&req->queue);\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\t \n\tnext_td = req->head;\n\tfor (j = 0; j < req->dtd_count; j++) {\n\t\tcurr_td = next_td;\n\t\tif (j != req->dtd_count - 1) {\n\t\t\tnext_td = curr_td->next_td_virt;\n\t\t}\n\t\tdma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);\n\t}\n\n\tusb_gadget_unmap_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\n\n\tif (status && (status != -ESHUTDOWN))\n\t\tVDBG(\"complete %s req %p stat %d len %u/%u\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\tep->stopped = 1;\n\n\tspin_unlock(&ep->udc->lock);\n\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\n\tspin_lock(&ep->udc->lock);\n\tep->stopped = stopped;\n}\n\n \nstatic void nuke(struct fsl_ep *ep, int status)\n{\n\tep->stopped = 1;\n\n\t \n\tfsl_ep_fifo_flush(&ep->ep);\n\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct fsl_req *req = NULL;\n\n\t\treq = list_entry(ep->queue.next, struct fsl_req, queue);\n\t\tdone(ep, req, status);\n\t}\n}\n\n \n\nstatic int dr_controller_setup(struct fsl_udc *udc)\n{\n\tunsigned int tmp, portctrl, ep_num;\n\tunsigned int max_no_of_ep;\n\tunsigned int ctrl;\n\tunsigned long timeout;\n\n#define FSL_UDC_RESET_TIMEOUT 1000\n\n\t \n\tportctrl = fsl_readl(&dr_regs->portsc1);\n\tportctrl &= ~(PORTSCX_PHY_TYPE_SEL | PORTSCX_PORT_WIDTH);\n\tswitch (udc->phy_mode) {\n\tcase FSL_USB2_PHY_ULPI:\n\t\tif (udc->pdata->have_sysif_regs) {\n\t\t\tif (udc->pdata->controller_ver) {\n\t\t\t\t \n\t\t\t\tctrl = __raw_readl(&usb_sys_regs->control);\n\t\t\t\tctrl &= ~USB_CTRL_UTMI_PHY_EN;\n\t\t\t\tctrl |= USB_CTRL_USB_EN;\n\t\t\t\t__raw_writel(ctrl, &usb_sys_regs->control);\n\t\t\t}\n\t\t}\n\t\tportctrl |= PORTSCX_PTS_ULPI;\n\t\tbreak;\n\tcase FSL_USB2_PHY_UTMI_WIDE:\n\t\tportctrl |= PORTSCX_PTW_16BIT;\n\t\tfallthrough;\n\tcase FSL_USB2_PHY_UTMI:\n\tcase FSL_USB2_PHY_UTMI_DUAL:\n\t\tif (udc->pdata->have_sysif_regs) {\n\t\t\tif (udc->pdata->controller_ver) {\n\t\t\t\t \n\t\t\t\tctrl = __raw_readl(&usb_sys_regs->control);\n\t\t\t\tctrl |= (USB_CTRL_UTMI_PHY_EN |\n\t\t\t\t\tUSB_CTRL_USB_EN);\n\t\t\t\t__raw_writel(ctrl, &usb_sys_regs->control);\n\t\t\t\tmdelay(FSL_UTMI_PHY_DLY);  \n\t\t\t}\n\t\t}\n\t\tportctrl |= PORTSCX_PTS_UTMI;\n\t\tbreak;\n\tcase FSL_USB2_PHY_SERIAL:\n\t\tportctrl |= PORTSCX_PTS_FSLS;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tfsl_writel(portctrl, &dr_regs->portsc1);\n\n\t \n\ttmp = fsl_readl(&dr_regs->usbcmd);\n\ttmp &= ~USB_CMD_RUN_STOP;\n\tfsl_writel(tmp, &dr_regs->usbcmd);\n\n\ttmp = fsl_readl(&dr_regs->usbcmd);\n\ttmp |= USB_CMD_CTRL_RESET;\n\tfsl_writel(tmp, &dr_regs->usbcmd);\n\n\t \n\ttimeout = jiffies + FSL_UDC_RESET_TIMEOUT;\n\twhile (fsl_readl(&dr_regs->usbcmd) & USB_CMD_CTRL_RESET) {\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tERR(\"udc reset timeout!\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t \n\ttmp = fsl_readl(&dr_regs->usbmode);\n\ttmp &= ~USB_MODE_CTRL_MODE_MASK;\t \n\ttmp |= USB_MODE_CTRL_MODE_DEVICE;\n\t \n\ttmp |= USB_MODE_SETUP_LOCK_OFF;\n\tif (udc->pdata->es)\n\t\ttmp |= USB_MODE_ES;\n\tfsl_writel(tmp, &dr_regs->usbmode);\n\n\t \n\tfsl_writel(0, &dr_regs->usbsts);\n\n\ttmp = udc->ep_qh_dma;\n\ttmp &= USB_EP_LIST_ADDRESS_MASK;\n\tfsl_writel(tmp, &dr_regs->endpointlistaddr);\n\n\tVDBG(\"vir[qh_base] is %p phy[qh_base] is 0x%8x reg is 0x%8x\",\n\t\tudc->ep_qh, (int)tmp,\n\t\tfsl_readl(&dr_regs->endpointlistaddr));\n\n\tmax_no_of_ep = (0x0000001F & fsl_readl(&dr_regs->dccparams));\n\tfor (ep_num = 1; ep_num < max_no_of_ep; ep_num++) {\n\t\ttmp = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\t\ttmp &= ~(EPCTRL_TX_TYPE | EPCTRL_RX_TYPE);\n\t\ttmp |= (EPCTRL_EP_TYPE_BULK << EPCTRL_TX_EP_TYPE_SHIFT)\n\t\t| (EPCTRL_EP_TYPE_BULK << EPCTRL_RX_EP_TYPE_SHIFT);\n\t\tfsl_writel(tmp, &dr_regs->endptctrl[ep_num]);\n\t}\n\t \n\tif (udc->pdata->have_sysif_regs) {\n\t\tctrl = __raw_readl(&usb_sys_regs->control);\n\t\tctrl |= USB_CTRL_IOENB;\n\t\t__raw_writel(ctrl, &usb_sys_regs->control);\n\t}\n\n#if defined(CONFIG_PPC32) && !defined(CONFIG_NOT_COHERENT_CACHE)\n\t \n\n\tif (udc->pdata->have_sysif_regs) {\n\t\t \n\t\ttmp = SNOOP_SIZE_2GB;\t \n\t\t__raw_writel(tmp, &usb_sys_regs->snoop1);\n\t\ttmp |= 0x80000000;\t \n\t\t__raw_writel(tmp, &usb_sys_regs->snoop2);\n\t}\n#endif\n\n\treturn 0;\n}\n\n \nstatic void dr_controller_run(struct fsl_udc *udc)\n{\n\tu32 temp;\n\n\t \n\ttemp = USB_INTR_INT_EN | USB_INTR_ERR_INT_EN\n\t\t| USB_INTR_PTC_DETECT_EN | USB_INTR_RESET_EN\n\t\t| USB_INTR_DEVICE_SUSPEND | USB_INTR_SYS_ERR_EN;\n\n\tfsl_writel(temp, &dr_regs->usbintr);\n\n\t \n\tudc->stopped = 0;\n\n\t \n\ttemp = fsl_readl(&dr_regs->usbmode);\n\ttemp |= USB_MODE_CTRL_MODE_DEVICE;\n\tfsl_writel(temp, &dr_regs->usbmode);\n\n\t \n\ttemp = fsl_readl(&dr_regs->usbcmd);\n\ttemp |= USB_CMD_RUN_STOP;\n\tfsl_writel(temp, &dr_regs->usbcmd);\n}\n\nstatic void dr_controller_stop(struct fsl_udc *udc)\n{\n\tunsigned int tmp;\n\n\tpr_debug(\"%s\\n\", __func__);\n\n\t \n\tif (udc->gadget.is_otg) {\n\t\tif (!(fsl_readl(&dr_regs->otgsc) & OTGSC_STS_USB_ID)) {\n\t\t\tpr_debug(\"udc: Leaving early\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tfsl_writel(0, &dr_regs->usbintr);\n\n\t \n\tudc->stopped = 1;\n\n\t \n \n\n\t \n\ttmp = fsl_readl(&dr_regs->usbcmd);\n\ttmp &= ~USB_CMD_RUN_STOP;\n\tfsl_writel(tmp, &dr_regs->usbcmd);\n}\n\nstatic void dr_ep_setup(unsigned char ep_num, unsigned char dir,\n\t\t\tunsigned char ep_type)\n{\n\tunsigned int tmp_epctrl = 0;\n\n\ttmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\tif (dir) {\n\t\tif (ep_num)\n\t\t\ttmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;\n\t\ttmp_epctrl |= EPCTRL_TX_ENABLE;\n\t\ttmp_epctrl &= ~EPCTRL_TX_TYPE;\n\t\ttmp_epctrl |= ((unsigned int)(ep_type)\n\t\t\t\t<< EPCTRL_TX_EP_TYPE_SHIFT);\n\t} else {\n\t\tif (ep_num)\n\t\t\ttmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;\n\t\ttmp_epctrl |= EPCTRL_RX_ENABLE;\n\t\ttmp_epctrl &= ~EPCTRL_RX_TYPE;\n\t\ttmp_epctrl |= ((unsigned int)(ep_type)\n\t\t\t\t<< EPCTRL_RX_EP_TYPE_SHIFT);\n\t}\n\n\tfsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);\n}\n\nstatic void\ndr_ep_change_stall(unsigned char ep_num, unsigned char dir, int value)\n{\n\tu32 tmp_epctrl = 0;\n\n\ttmp_epctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\n\tif (value) {\n\t\t \n\t\tif (dir)\n\t\t\ttmp_epctrl |= EPCTRL_TX_EP_STALL;\n\t\telse\n\t\t\ttmp_epctrl |= EPCTRL_RX_EP_STALL;\n\t} else {\n\t\t \n\t\tif (dir) {\n\t\t\ttmp_epctrl &= ~EPCTRL_TX_EP_STALL;\n\t\t\ttmp_epctrl |= EPCTRL_TX_DATA_TOGGLE_RST;\n\t\t} else {\n\t\t\ttmp_epctrl &= ~EPCTRL_RX_EP_STALL;\n\t\t\ttmp_epctrl |= EPCTRL_RX_DATA_TOGGLE_RST;\n\t\t}\n\t}\n\tfsl_writel(tmp_epctrl, &dr_regs->endptctrl[ep_num]);\n}\n\n \nstatic int dr_ep_get_stall(unsigned char ep_num, unsigned char dir)\n{\n\tu32 epctrl;\n\n\tepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\tif (dir)\n\t\treturn (epctrl & EPCTRL_TX_EP_STALL) ? 1 : 0;\n\telse\n\t\treturn (epctrl & EPCTRL_RX_EP_STALL) ? 1 : 0;\n}\n\n \n\n \nstatic void struct_ep_qh_setup(struct fsl_udc *udc, unsigned char ep_num,\n\t\tunsigned char dir, unsigned char ep_type,\n\t\tunsigned int max_pkt_len,\n\t\tunsigned int zlt, unsigned char mult)\n{\n\tstruct ep_queue_head *p_QH = &udc->ep_qh[2 * ep_num + dir];\n\tunsigned int tmp = 0;\n\n\t \n\tswitch (ep_type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\ttmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\n\t\t\t| EP_QUEUE_HEAD_IOS;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ttmp = (max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\n\t\t\t| (mult << EP_QUEUE_HEAD_MULT_POS);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttmp = max_pkt_len << EP_QUEUE_HEAD_MAX_PKT_LEN_POS;\n\t\tbreak;\n\tdefault:\n\t\tVDBG(\"error ep type is %d\", ep_type);\n\t\treturn;\n\t}\n\tif (zlt)\n\t\ttmp |= EP_QUEUE_HEAD_ZLT_SEL;\n\n\tp_QH->max_pkt_length = cpu_to_hc32(tmp);\n\tp_QH->next_dtd_ptr = 1;\n\tp_QH->size_ioc_int_sts = 0;\n}\n\n \nstatic void ep0_setup(struct fsl_udc *udc)\n{\n\t \n\tstruct_ep_qh_setup(udc, 0, USB_RECV, USB_ENDPOINT_XFER_CONTROL,\n\t\t\tUSB_MAX_CTRL_PAYLOAD, 0, 0);\n\tstruct_ep_qh_setup(udc, 0, USB_SEND, USB_ENDPOINT_XFER_CONTROL,\n\t\t\tUSB_MAX_CTRL_PAYLOAD, 0, 0);\n\tdr_ep_setup(0, USB_RECV, USB_ENDPOINT_XFER_CONTROL);\n\tdr_ep_setup(0, USB_SEND, USB_ENDPOINT_XFER_CONTROL);\n\n\treturn;\n\n}\n\n \n\n \nstatic int fsl_ep_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct fsl_udc *udc = NULL;\n\tstruct fsl_ep *ep = NULL;\n\tunsigned short max = 0;\n\tunsigned char mult = 0, zlt;\n\tint retval = -EINVAL;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct fsl_ep, ep);\n\n\t \n\tif (!_ep || !desc\n\t\t\t|| (desc->bDescriptorType != USB_DT_ENDPOINT))\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\n\tif (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\n\tmax = usb_endpoint_maxp(desc);\n\n\t \n\tzlt = 1;\n\n\t \n\tswitch (desc->bmAttributes & 0x03) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tmult = 0;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tmult = usb_endpoint_maxp_mult(desc);\n\t\t \n\t\tif (mult > 3)\n\t\t\tgoto en_done;\n\t\tbreak;\n\tdefault:\n\t\tgoto en_done;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tep->ep.maxpacket = max;\n\tep->ep.desc = desc;\n\tep->stopped = 0;\n\n\t \n\t \n\tstruct_ep_qh_setup(udc, (unsigned char) ep_index(ep),\n\t\t\t(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t\t?  USB_SEND : USB_RECV),\n\t\t\t(unsigned char) (desc->bmAttributes\n\t\t\t\t\t& USB_ENDPOINT_XFERTYPE_MASK),\n\t\t\tmax, zlt, mult);\n\n\t \n\tdr_ep_setup((unsigned char) ep_index(ep),\n\t\t\t(unsigned char) ((desc->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t\t? USB_SEND : USB_RECV),\n\t\t\t(unsigned char) (desc->bmAttributes\n\t\t\t\t\t& USB_ENDPOINT_XFERTYPE_MASK));\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tretval = 0;\n\n\tVDBG(\"enabled %s (ep%d%s) maxpacket %d\",ep->ep.name,\n\t\t\tep->ep.desc->bEndpointAddress & 0x0f,\n\t\t\t(desc->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t? \"in\" : \"out\", max);\nen_done:\n\treturn retval;\n}\n\n \nstatic int fsl_ep_disable(struct usb_ep *_ep)\n{\n\tstruct fsl_udc *udc = NULL;\n\tstruct fsl_ep *ep = NULL;\n\tunsigned long flags;\n\tu32 epctrl;\n\tint ep_num;\n\n\tep = container_of(_ep, struct fsl_ep, ep);\n\tif (!_ep || !ep->ep.desc) {\n\t\tVDBG(\"%s not enabled\", _ep ? ep->ep.name : NULL);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tep_num = ep_index(ep);\n\tepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\tif (ep_is_in(ep)) {\n\t\tepctrl &= ~(EPCTRL_TX_ENABLE | EPCTRL_TX_TYPE);\n\t\tepctrl |= EPCTRL_EP_TYPE_BULK << EPCTRL_TX_EP_TYPE_SHIFT;\n\t} else {\n\t\tepctrl &= ~(EPCTRL_RX_ENABLE | EPCTRL_TX_TYPE);\n\t\tepctrl |= EPCTRL_EP_TYPE_BULK << EPCTRL_RX_EP_TYPE_SHIFT;\n\t}\n\tfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\n\n\tudc = (struct fsl_udc *)ep->udc;\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tnuke(ep, -ESHUTDOWN);\n\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tVDBG(\"disabled %s OK\", _ep->name);\n\treturn 0;\n}\n\n \nstatic struct usb_request *\nfsl_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct fsl_req *req;\n\n\treq = kzalloc(sizeof *req, gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->req.dma = DMA_ADDR_INVALID;\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void fsl_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct fsl_req *req = NULL;\n\n\treq = container_of(_req, struct fsl_req, req);\n\n\tif (_req)\n\t\tkfree(req);\n}\n\n \nstatic void fsl_prime_ep(struct fsl_ep *ep, struct ep_td_struct *td)\n{\n\tstruct ep_queue_head *qh = get_qh_by_ep(ep);\n\n\t \n\tqh->next_dtd_ptr = cpu_to_hc32(td->td_dma\n\t\t\t& EP_QUEUE_HEAD_NEXT_POINTER_MASK);\n\n\t \n\tqh->size_ioc_int_sts &= cpu_to_hc32(~(EP_QUEUE_HEAD_STATUS_ACTIVE\n\t\t\t\t\t| EP_QUEUE_HEAD_STATUS_HALT));\n\n\t \n\twmb();\n\n\t \n\tfsl_writel(ep_is_in(ep) ? (1 << (ep_index(ep) + 16))\n\t\t\t: (1 << (ep_index(ep))), &dr_regs->endpointprime);\n}\n\n \nstatic void fsl_queue_td(struct fsl_ep *ep, struct fsl_req *req)\n{\n\tu32 temp, bitmask, tmp_stat;\n\n\t \n\n\tbitmask = ep_is_in(ep)\n\t\t? (1 << (ep_index(ep) + 16))\n\t\t: (1 << (ep_index(ep)));\n\n\t \n\tif (!(list_empty(&ep->queue)) && !(ep_index(ep) == 0)) {\n\t\t \n\t\tstruct fsl_req *lastreq;\n\t\tlastreq = list_entry(ep->queue.prev, struct fsl_req, queue);\n\t\tlastreq->tail->next_td_ptr =\n\t\t\tcpu_to_hc32(req->head->td_dma & DTD_ADDR_MASK);\n\t\t \n\t\twmb();\n\t\t \n\t\tif (fsl_readl(&dr_regs->endpointprime) & bitmask)\n\t\t\treturn;\n\n\t\tdo {\n\t\t\t \n\t\t\ttemp = fsl_readl(&dr_regs->usbcmd);\n\t\t\tfsl_writel(temp | USB_CMD_ATDTW, &dr_regs->usbcmd);\n\n\t\t\t \n\t\t\ttmp_stat = fsl_readl(&dr_regs->endptstatus) & bitmask;\n\n\t\t} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_ATDTW));\n\n\t\t \n\t\ttemp = fsl_readl(&dr_regs->usbcmd);\n\t\tfsl_writel(temp & ~USB_CMD_ATDTW, &dr_regs->usbcmd);\n\n\t\tif (tmp_stat)\n\t\t\treturn;\n\t}\n\n\tfsl_prime_ep(ep, req->head);\n}\n\n \nstatic struct ep_td_struct *fsl_build_dtd(struct fsl_req *req, unsigned *length,\n\t\tdma_addr_t *dma, int *is_last, gfp_t gfp_flags)\n{\n\tu32 swap_temp;\n\tstruct ep_td_struct *dtd;\n\n\t \n\t*length = min(req->req.length - req->req.actual,\n\t\t\t(unsigned)EP_MAX_LENGTH_TRANSFER);\n\n\tdtd = dma_pool_alloc(udc_controller->td_pool, gfp_flags, dma);\n\tif (dtd == NULL)\n\t\treturn dtd;\n\n\tdtd->td_dma = *dma;\n\t \n\tswap_temp = hc32_to_cpu(dtd->size_ioc_sts);\n\tswap_temp &= ~DTD_RESERVED_FIELDS;\n\tdtd->size_ioc_sts = cpu_to_hc32(swap_temp);\n\n\t \n\tswap_temp = (u32) (req->req.dma + req->req.actual);\n\tdtd->buff_ptr0 = cpu_to_hc32(swap_temp);\n\tdtd->buff_ptr1 = cpu_to_hc32(swap_temp + 0x1000);\n\tdtd->buff_ptr2 = cpu_to_hc32(swap_temp + 0x2000);\n\tdtd->buff_ptr3 = cpu_to_hc32(swap_temp + 0x3000);\n\tdtd->buff_ptr4 = cpu_to_hc32(swap_temp + 0x4000);\n\n\treq->req.actual += *length;\n\n\t \n\tif (req->req.zero) {\n\t\tif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\n\t\t\t*is_last = 1;\n\t\telse\n\t\t\t*is_last = 0;\n\t} else if (req->req.length == req->req.actual)\n\t\t*is_last = 1;\n\telse\n\t\t*is_last = 0;\n\n\tif ((*is_last) == 0)\n\t\tVDBG(\"multi-dtd request!\");\n\t \n\tswap_temp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);\n\n\t \n\tif (*is_last && !req->req.no_interrupt)\n\t\tswap_temp |= DTD_IOC;\n\n\tdtd->size_ioc_sts = cpu_to_hc32(swap_temp);\n\n\tmb();\n\n\tVDBG(\"length = %d address= 0x%x\", *length, (int)*dma);\n\n\treturn dtd;\n}\n\n \nstatic int fsl_req_to_dtd(struct fsl_req *req, gfp_t gfp_flags)\n{\n\tunsigned\tcount;\n\tint\t\tis_last;\n\tint\t\tis_first =1;\n\tstruct ep_td_struct\t*last_dtd = NULL, *dtd;\n\tdma_addr_t dma;\n\n\tdo {\n\t\tdtd = fsl_build_dtd(req, &count, &dma, &is_last, gfp_flags);\n\t\tif (dtd == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (is_first) {\n\t\t\tis_first = 0;\n\t\t\treq->head = dtd;\n\t\t} else {\n\t\t\tlast_dtd->next_td_ptr = cpu_to_hc32(dma);\n\t\t\tlast_dtd->next_td_virt = dtd;\n\t\t}\n\t\tlast_dtd = dtd;\n\n\t\treq->dtd_count++;\n\t} while (!is_last);\n\n\tdtd->next_td_ptr = cpu_to_hc32(DTD_NEXT_TERMINATE);\n\n\treq->tail = dtd;\n\n\treturn 0;\n}\n\n \nstatic int\nfsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);\n\tstruct fsl_req *req = container_of(_req, struct fsl_req, req);\n\tstruct fsl_udc *udc;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (!_req || !req->req.complete || !req->req.buf\n\t\t\t|| !list_empty(&req->queue)) {\n\t\tVDBG(\"%s, bad params\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(!_ep || !ep->ep.desc)) {\n\t\tVDBG(\"%s, bad ep\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (usb_endpoint_xfer_isoc(ep->ep.desc)) {\n\t\tif (req->req.length > ep->ep.maxpacket)\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\tudc = ep->udc;\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\treq->ep = ep;\n\n\tret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\n\tif (ret)\n\t\treturn ret;\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->dtd_count = 0;\n\n\t \n\tif (!fsl_req_to_dtd(req, gfp_flags)) {\n\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\tfsl_queue_td(ep, req);\n\t} else {\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int fsl_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct fsl_ep *ep = container_of(_ep, struct fsl_ep, ep);\n\tstruct fsl_req *req = NULL;\n\tstruct fsl_req *iter;\n\tunsigned long flags;\n\tint ep_num, stopped, ret = 0;\n\tu32 epctrl;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tstopped = ep->stopped;\n\n\t \n\tep->stopped = 1;\n\tep_num = ep_index(ep);\n\tepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\tif (ep_is_in(ep))\n\t\tepctrl &= ~EPCTRL_TX_ENABLE;\n\telse\n\t\tepctrl &= ~EPCTRL_RX_ENABLE;\n\tfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\t_req->status = -ECONNRESET;\n\t\tfsl_ep_fifo_flush(_ep);\t \n\n\t\t \n\t\tif (req->queue.next != &ep->queue) {\n\t\t\tstruct fsl_req *next_req;\n\n\t\t\tnext_req = list_entry(req->queue.next, struct fsl_req,\n\t\t\t\t\tqueue);\n\n\t\t\t \n\t\t\tfsl_prime_ep(ep, next_req->head);\n\t\t}\n\t \n\t} else {\n\t\tstruct fsl_req *prev_req;\n\n\t\tprev_req = list_entry(req->queue.prev, struct fsl_req, queue);\n\t\tprev_req->tail->next_td_ptr = req->tail->next_td_ptr;\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\n\t \nout:\tepctrl = fsl_readl(&dr_regs->endptctrl[ep_num]);\n\tif (ep_is_in(ep))\n\t\tepctrl |= EPCTRL_TX_ENABLE;\n\telse\n\t\tepctrl |= EPCTRL_RX_ENABLE;\n\tfsl_writel(epctrl, &dr_regs->endptctrl[ep_num]);\n\tep->stopped = stopped;\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn ret;\n}\n\n \n\n \nstatic int fsl_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct fsl_ep *ep = NULL;\n\tunsigned long flags;\n\tint status = -EOPNOTSUPP;\t \n\tunsigned char ep_dir = 0, ep_num = 0;\n\tstruct fsl_udc *udc = NULL;\n\n\tep = container_of(_ep, struct fsl_ep, ep);\n\tudc = ep->udc;\n\tif (!_ep || !ep->ep.desc) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(ep->ep.desc)) {\n\t\tstatus = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (value && ep_is_in(ep) && !list_empty(&ep->queue)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tstatus = 0;\n\tep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;\n\tep_num = (unsigned char)(ep_index(ep));\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tdr_ep_change_stall(ep_num, ep_dir, value);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\tif (ep_index(ep) == 0) {\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tudc->ep0_dir = 0;\n\t}\nout:\n\tVDBG(\" %s %s halt stat %d\", ep->ep.name,\n\t\t\tvalue ?  \"set\" : \"clear\", status);\n\n\treturn status;\n}\n\nstatic int fsl_ep_fifo_status(struct usb_ep *_ep)\n{\n\tstruct fsl_ep *ep;\n\tstruct fsl_udc *udc;\n\tint size = 0;\n\tu32 bitmask;\n\tstruct ep_queue_head *qh;\n\n\tif (!_ep || !_ep->desc || !(_ep->desc->bEndpointAddress&0xF))\n\t\treturn -ENODEV;\n\n\tep = container_of(_ep, struct fsl_ep, ep);\n\n\tudc = (struct fsl_udc *)ep->udc;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tqh = get_qh_by_ep(ep);\n\n\tbitmask = (ep_is_in(ep)) ? (1 << (ep_index(ep) + 16)) :\n\t    (1 << (ep_index(ep)));\n\n\tif (fsl_readl(&dr_regs->endptstatus) & bitmask)\n\t\tsize = (qh->size_ioc_int_sts & DTD_PACKET_SIZE)\n\t\t    >> DTD_LENGTH_BIT_POS;\n\n\tpr_debug(\"%s %u\\n\", __func__, size);\n\treturn size;\n}\n\nstatic void fsl_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct fsl_ep *ep;\n\tint ep_num, ep_dir;\n\tu32 bits;\n\tunsigned long timeout;\n#define FSL_UDC_FLUSH_TIMEOUT 1000\n\n\tif (!_ep) {\n\t\treturn;\n\t} else {\n\t\tep = container_of(_ep, struct fsl_ep, ep);\n\t\tif (!ep->ep.desc)\n\t\t\treturn;\n\t}\n\tep_num = ep_index(ep);\n\tep_dir = ep_is_in(ep) ? USB_SEND : USB_RECV;\n\n\tif (ep_num == 0)\n\t\tbits = (1 << 16) | 1;\n\telse if (ep_dir == USB_SEND)\n\t\tbits = 1 << (16 + ep_num);\n\telse\n\t\tbits = 1 << ep_num;\n\n\ttimeout = jiffies + FSL_UDC_FLUSH_TIMEOUT;\n\tdo {\n\t\tfsl_writel(bits, &dr_regs->endptflush);\n\n\t\t \n\t\twhile (fsl_readl(&dr_regs->endptflush)) {\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tERR(\"ep flush timeout\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\t\t \n\t} while (fsl_readl(&dr_regs->endptstatus) & bits);\n}\n\nstatic const struct usb_ep_ops fsl_ep_ops = {\n\t.enable = fsl_ep_enable,\n\t.disable = fsl_ep_disable,\n\n\t.alloc_request = fsl_alloc_request,\n\t.free_request = fsl_free_request,\n\n\t.queue = fsl_ep_queue,\n\t.dequeue = fsl_ep_dequeue,\n\n\t.set_halt = fsl_ep_set_halt,\n\t.fifo_status = fsl_ep_fifo_status,\n\t.fifo_flush = fsl_ep_fifo_flush,\t \n};\n\n \n\n \nstatic int fsl_get_frame(struct usb_gadget *gadget)\n{\n\treturn (int)(fsl_readl(&dr_regs->frindex) & USB_FRINDEX_MASKS);\n}\n\n \nstatic int fsl_wakeup(struct usb_gadget *gadget)\n{\n\tstruct fsl_udc *udc = container_of(gadget, struct fsl_udc, gadget);\n\tu32 portsc;\n\n\t \n\tif (!udc->remote_wakeup)\n\t\treturn -ENOTSUPP;\n\n\tportsc = fsl_readl(&dr_regs->portsc1);\n\t \n\tif (!(portsc & PORTSCX_PORT_SUSPEND))\n\t\treturn 0;\n\t \n\tportsc |= PORTSCX_PORT_FORCE_RESUME;\n\tfsl_writel(portsc, &dr_regs->portsc1);\n\treturn 0;\n}\n\nstatic int can_pullup(struct fsl_udc *udc)\n{\n\treturn udc->driver && udc->softconnect && udc->vbus_active;\n}\n\n \nstatic int fsl_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct fsl_udc\t*udc;\n\tunsigned long\tflags;\n\n\tudc = container_of(gadget, struct fsl_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tVDBG(\"VBUS %s\", is_active ? \"on\" : \"off\");\n\tudc->vbus_active = (is_active != 0);\n\tif (can_pullup(udc))\n\t\tfsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),\n\t\t\t\t&dr_regs->usbcmd);\n\telse\n\t\tfsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),\n\t\t\t\t&dr_regs->usbcmd);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic int fsl_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{\n\tstruct fsl_udc *udc;\n\n\tudc = container_of(gadget, struct fsl_udc, gadget);\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\treturn usb_phy_set_power(udc->transceiver, mA);\n\treturn -ENOTSUPP;\n}\n\n \nstatic int fsl_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct fsl_udc *udc;\n\n\tudc = container_of(gadget, struct fsl_udc, gadget);\n\n\tif (!udc->vbus_active)\n\t\treturn -EOPNOTSUPP;\n\n\tudc->softconnect = (is_on != 0);\n\tif (can_pullup(udc))\n\t\tfsl_writel((fsl_readl(&dr_regs->usbcmd) | USB_CMD_RUN_STOP),\n\t\t\t\t&dr_regs->usbcmd);\n\telse\n\t\tfsl_writel((fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP),\n\t\t\t\t&dr_regs->usbcmd);\n\n\treturn 0;\n}\n\nstatic int fsl_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int fsl_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops fsl_gadget_ops = {\n\t.get_frame = fsl_get_frame,\n\t.wakeup = fsl_wakeup,\n   \n\t.vbus_session = fsl_vbus_session,\n\t.vbus_draw = fsl_vbus_draw,\n\t.pullup = fsl_pullup,\n\t.udc_start = fsl_udc_start,\n\t.udc_stop = fsl_udc_stop,\n};\n\n \nstatic void fsl_noop_complete(struct usb_ep *ep, struct usb_request *req) { }\n\n \nstatic void ep0stall(struct fsl_udc *udc)\n{\n\tu32 tmp;\n\n\t \n\ttmp = fsl_readl(&dr_regs->endptctrl[0]);\n\ttmp |= EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL;\n\tfsl_writel(tmp, &dr_regs->endptctrl[0]);\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = 0;\n}\n\n \nstatic int ep0_prime_status(struct fsl_udc *udc, int direction)\n{\n\tstruct fsl_req *req = udc->status_req;\n\tstruct fsl_ep *ep;\n\tint ret;\n\n\tif (direction == EP_DIR_IN)\n\t\tudc->ep0_dir = USB_DIR_IN;\n\telse\n\t\tudc->ep0_dir = USB_DIR_OUT;\n\n\tep = &udc->eps[0];\n\tif (udc->ep0_state != DATA_STATE_XMIT)\n\t\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\n\treq->ep = ep;\n\treq->req.length = 0;\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->req.complete = fsl_noop_complete;\n\treq->dtd_count = 0;\n\n\tret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\n\tif (ret)\n\t\treturn ret;\n\n\tif (fsl_req_to_dtd(req, GFP_ATOMIC) == 0)\n\t\tfsl_queue_td(ep, req);\n\telse\n\t\treturn -ENOMEM;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treturn 0;\n}\n\nstatic void udc_reset_ep_queue(struct fsl_udc *udc, u8 pipe)\n{\n\tstruct fsl_ep *ep = get_ep_by_pipe(udc, pipe);\n\n\tif (ep->ep.name)\n\t\tnuke(ep, -ESHUTDOWN);\n}\n\n \nstatic void ch9setaddress(struct fsl_udc *udc, u16 value, u16 index, u16 length)\n{\n\t \n\tudc->device_address = (u8) value;\n\t \n\tudc->usb_state = USB_STATE_ADDRESS;\n\t \n\tif (ep0_prime_status(udc, EP_DIR_IN))\n\t\tep0stall(udc);\n}\n\n \nstatic void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,\n\t\tu16 index, u16 length)\n{\n\tu16 tmp = 0;\t\t \n\tstruct fsl_req *req;\n\tstruct fsl_ep *ep;\n\tint ret;\n\n\tep = &udc->eps[0];\n\n\tif ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\n\t\t \n\t\ttmp = udc->gadget.is_selfpowered;\n\t\ttmp |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\t} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {\n\t\t \n\t\t \n\t\ttmp = 0;\n\t} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {\n\t\t \n\t\tstruct fsl_ep *target_ep;\n\n\t\ttarget_ep = get_ep_by_pipe(udc, get_pipe_by_windex(index));\n\n\t\t \n\t\tif (!target_ep->ep.desc)\n\t\t\tgoto stall;\n\t\ttmp = dr_ep_get_stall(ep_index(target_ep), ep_is_in(target_ep))\n\t\t\t\t<< USB_ENDPOINT_HALT;\n\t}\n\n\tudc->ep0_dir = USB_DIR_IN;\n\t \n\treq = udc->status_req;\n\t \n\t*((u16 *) req->req.buf) = cpu_to_le16(tmp);\n\n\treq->ep = ep;\n\treq->req.length = 2;\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->req.complete = fsl_noop_complete;\n\treq->dtd_count = 0;\n\n\tret = usb_gadget_map_request(&ep->udc->gadget, &req->req, ep_is_in(ep));\n\tif (ret)\n\t\tgoto stall;\n\n\t \n\tif ((fsl_req_to_dtd(req, GFP_ATOMIC) == 0))\n\t\tfsl_queue_td(ep, req);\n\telse\t\t\t \n\t\tgoto stall;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\tudc->ep0_state = DATA_STATE_XMIT;\n\tif (ep0_prime_status(udc, EP_DIR_OUT))\n\t\tep0stall(udc);\n\n\treturn;\nstall:\n\tep0stall(udc);\n}\n\nstatic void setup_received_irq(struct fsl_udc *udc,\n\t\tstruct usb_ctrlrequest *setup)\n__releases(udc->lock)\n__acquires(udc->lock)\n{\n\tu16 wValue = le16_to_cpu(setup->wValue);\n\tu16 wIndex = le16_to_cpu(setup->wIndex);\n\tu16 wLength = le16_to_cpu(setup->wLength);\n\n\tudc_reset_ep_queue(udc, 0);\n\n\t \n\tswitch (setup->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t \n\t\tif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\n\t\t\t\t\t!= (USB_DIR_IN | USB_TYPE_STANDARD))\n\t\t\tbreak;\n\t\tch9getstatus(udc, setup->bRequestType, wValue, wIndex, wLength);\n\t\treturn;\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\t \n\t\tif (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD\n\t\t\t\t\t\t| USB_RECIP_DEVICE))\n\t\t\tbreak;\n\t\tch9setaddress(udc, wValue, wIndex, wLength);\n\t\treturn;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t \n\t{\n\t\tint rc = -EOPNOTSUPP;\n\t\tu16 ptc = 0;\n\n\t\tif ((setup->bRequestType & (USB_RECIP_MASK | USB_TYPE_MASK))\n\t\t\t\t== (USB_RECIP_ENDPOINT | USB_TYPE_STANDARD)) {\n\t\t\tint pipe = get_pipe_by_windex(wIndex);\n\t\t\tstruct fsl_ep *ep;\n\n\t\t\tif (wValue != 0 || wLength != 0 || pipe >= udc->max_ep)\n\t\t\t\tbreak;\n\t\t\tep = get_ep_by_pipe(udc, pipe);\n\n\t\t\tspin_unlock(&udc->lock);\n\t\t\trc = fsl_ep_set_halt(&ep->ep,\n\t\t\t\t\t(setup->bRequest == USB_REQ_SET_FEATURE)\n\t\t\t\t\t\t? 1 : 0);\n\t\t\tspin_lock(&udc->lock);\n\n\t\t} else if ((setup->bRequestType & (USB_RECIP_MASK\n\t\t\t\t| USB_TYPE_MASK)) == (USB_RECIP_DEVICE\n\t\t\t\t| USB_TYPE_STANDARD)) {\n\t\t\t \n\t\t\tif (wValue == USB_DEVICE_TEST_MODE)\n\t\t\t\tptc = wIndex >> 8;\n\t\t\telse if (gadget_is_otg(&udc->gadget)) {\n\t\t\t\tif (setup->bRequest ==\n\t\t\t\t    USB_DEVICE_B_HNP_ENABLE)\n\t\t\t\t\tudc->gadget.b_hnp_enable = 1;\n\t\t\t\telse if (setup->bRequest ==\n\t\t\t\t\t USB_DEVICE_A_HNP_SUPPORT)\n\t\t\t\t\tudc->gadget.a_hnp_support = 1;\n\t\t\t\telse if (setup->bRequest ==\n\t\t\t\t\t USB_DEVICE_A_ALT_HNP_SUPPORT)\n\t\t\t\t\tudc->gadget.a_alt_hnp_support = 1;\n\t\t\t}\n\t\t\trc = 0;\n\t\t} else\n\t\t\tbreak;\n\n\t\tif (rc == 0) {\n\t\t\tif (ep0_prime_status(udc, EP_DIR_IN))\n\t\t\t\tep0stall(udc);\n\t\t}\n\t\tif (ptc) {\n\t\t\tu32 tmp;\n\n\t\t\tmdelay(10);\n\t\t\ttmp = fsl_readl(&dr_regs->portsc1) | (ptc << 16);\n\t\t\tfsl_writel(tmp, &dr_regs->portsc1);\n\t\t\tprintk(KERN_INFO \"udc: switch to test mode %d.\\n\", ptc);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (wLength) {\n\t\t \n\t\tudc->ep0_dir = (setup->bRequestType & USB_DIR_IN)\n\t\t\t\t?  USB_DIR_IN : USB_DIR_OUT;\n\t\tspin_unlock(&udc->lock);\n\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\tep0stall(udc);\n\t\tspin_lock(&udc->lock);\n\t\tudc->ep0_state = (setup->bRequestType & USB_DIR_IN)\n\t\t\t\t?  DATA_STATE_XMIT : DATA_STATE_RECV;\n\t\t \n\t\tif (udc->ep0_state == DATA_STATE_XMIT)\n\t\t\tif (ep0_prime_status(udc, EP_DIR_OUT))\n\t\t\t\tep0stall(udc);\n\n\t} else {\n\t\t \n\t\tudc->ep0_dir = USB_DIR_IN;\n\t\tspin_unlock(&udc->lock);\n\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\tep0stall(udc);\n\t\tspin_lock(&udc->lock);\n\t\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\t}\n}\n\n \nstatic void ep0_req_complete(struct fsl_udc *udc, struct fsl_ep *ep0,\n\t\tstruct fsl_req *req)\n{\n\tif (udc->usb_state == USB_STATE_ADDRESS) {\n\t\t \n\t\tu32 new_address = (u32) udc->device_address;\n\t\tfsl_writel(new_address << USB_DEVICE_ADDRESS_BIT_POS,\n\t\t\t\t&dr_regs->deviceaddr);\n\t}\n\n\tdone(ep0, req, 0);\n\n\tswitch (udc->ep0_state) {\n\tcase DATA_STATE_XMIT:\n\t\t \n\t\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\t\tbreak;\n\tcase DATA_STATE_RECV:\n\t\t \n\t\tif (ep0_prime_status(udc, EP_DIR_IN))\n\t\t\tep0stall(udc);\n\t\tbreak;\n\tcase WAIT_FOR_OUT_STATUS:\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tbreak;\n\tcase WAIT_FOR_SETUP:\n\t\tERR(\"Unexpected ep0 packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tep0stall(udc);\n\t\tbreak;\n\t}\n}\n\n \nstatic void tripwire_handler(struct fsl_udc *udc, u8 ep_num, u8 *buffer_ptr)\n{\n\tu32 temp;\n\tstruct ep_queue_head *qh;\n\tstruct fsl_usb2_platform_data *pdata = udc->pdata;\n\n\tqh = &udc->ep_qh[ep_num * 2 + EP_DIR_OUT];\n\n\t \n\ttemp = fsl_readl(&dr_regs->endptsetupstat);\n\tfsl_writel(temp | (1 << ep_num), &dr_regs->endptsetupstat);\n\n\t \n\tdo {\n\t\t \n\t\ttemp = fsl_readl(&dr_regs->usbcmd);\n\t\tfsl_writel(temp | USB_CMD_SUTW, &dr_regs->usbcmd);\n\n\t\t \n\t\tif (pdata->le_setup_buf) {\n\t\t\tu32 *p = (u32 *)buffer_ptr;\n\t\t\tu32 *s = (u32 *)qh->setup_buffer;\n\n\t\t\t \n\t\t\t*p++ = le32_to_cpu(*s++);\n\t\t\t*p = le32_to_cpu(*s);\n\t\t} else {\n\t\t\tmemcpy(buffer_ptr, (u8 *) qh->setup_buffer, 8);\n\t\t}\n\t} while (!(fsl_readl(&dr_regs->usbcmd) & USB_CMD_SUTW));\n\n\t \n\ttemp = fsl_readl(&dr_regs->usbcmd);\n\tfsl_writel(temp & ~USB_CMD_SUTW, &dr_regs->usbcmd);\n}\n\n \nstatic int process_ep_req(struct fsl_udc *udc, int pipe,\n\t\tstruct fsl_req *curr_req)\n{\n\tstruct ep_td_struct *curr_td;\n\tint\tactual, remaining_length, j, tmp;\n\tint\tstatus = 0;\n\tint\terrors = 0;\n\tstruct  ep_queue_head *curr_qh = &udc->ep_qh[pipe];\n\tint direction = pipe % 2;\n\n\tcurr_td = curr_req->head;\n\tactual = curr_req->req.length;\n\n\tfor (j = 0; j < curr_req->dtd_count; j++) {\n\t\tremaining_length = (hc32_to_cpu(curr_td->size_ioc_sts)\n\t\t\t\t\t& DTD_PACKET_SIZE)\n\t\t\t\t>> DTD_LENGTH_BIT_POS;\n\t\tactual -= remaining_length;\n\n\t\terrors = hc32_to_cpu(curr_td->size_ioc_sts);\n\t\tif (errors & DTD_ERROR_MASK) {\n\t\t\tif (errors & DTD_STATUS_HALTED) {\n\t\t\t\tERR(\"dTD error %08x QH=%d\\n\", errors, pipe);\n\t\t\t\t \n\t\t\t\ttmp = hc32_to_cpu(curr_qh->size_ioc_int_sts);\n\t\t\t\ttmp &= ~errors;\n\t\t\t\tcurr_qh->size_ioc_int_sts = cpu_to_hc32(tmp);\n\t\t\t\tstatus = -EPIPE;\n\t\t\t\t \n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (errors & DTD_STATUS_DATA_BUFF_ERR) {\n\t\t\t\tVDBG(\"Transfer overflow\");\n\t\t\t\tstatus = -EPROTO;\n\t\t\t\tbreak;\n\t\t\t} else if (errors & DTD_STATUS_TRANSACTION_ERR) {\n\t\t\t\tVDBG(\"ISO error\");\n\t\t\t\tstatus = -EILSEQ;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tERR(\"Unknown error has occurred (0x%x)!\\n\",\n\t\t\t\t\terrors);\n\n\t\t} else if (hc32_to_cpu(curr_td->size_ioc_sts)\n\t\t\t\t& DTD_STATUS_ACTIVE) {\n\t\t\tVDBG(\"Request not complete\");\n\t\t\tstatus = REQ_UNCOMPLETE;\n\t\t\treturn status;\n\t\t} else if (remaining_length) {\n\t\t\tif (direction) {\n\t\t\t\tVDBG(\"Transmit dTD remaining length not zero\");\n\t\t\t\tstatus = -EPROTO;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tVDBG(\"dTD transmitted successful\");\n\t\t}\n\n\t\tif (j != curr_req->dtd_count - 1)\n\t\t\tcurr_td = (struct ep_td_struct *)curr_td->next_td_virt;\n\t}\n\n\tif (status)\n\t\treturn status;\n\n\tcurr_req->req.actual = actual;\n\n\treturn 0;\n}\n\n \nstatic void dtd_complete_irq(struct fsl_udc *udc)\n{\n\tu32 bit_pos;\n\tint i, ep_num, direction, bit_mask, status;\n\tstruct fsl_ep *curr_ep;\n\tstruct fsl_req *curr_req, *temp_req;\n\n\t \n\tbit_pos = fsl_readl(&dr_regs->endptcomplete);\n\tfsl_writel(bit_pos, &dr_regs->endptcomplete);\n\n\tif (!bit_pos)\n\t\treturn;\n\n\tfor (i = 0; i < udc->max_ep; i++) {\n\t\tep_num = i >> 1;\n\t\tdirection = i % 2;\n\n\t\tbit_mask = 1 << (ep_num + 16 * direction);\n\n\t\tif (!(bit_pos & bit_mask))\n\t\t\tcontinue;\n\n\t\tcurr_ep = get_ep_by_pipe(udc, i);\n\n\t\t \n\t\tif (!curr_ep->ep.name) {\n\t\t\tWARNING(\"Invalid EP?\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_safe(curr_req, temp_req, &curr_ep->queue,\n\t\t\t\tqueue) {\n\t\t\tstatus = process_ep_req(udc, i, curr_req);\n\n\t\t\tVDBG(\"status of process_ep_req= %d, ep = %d\",\n\t\t\t\t\tstatus, ep_num);\n\t\t\tif (status == REQ_UNCOMPLETE)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcurr_req->req.status = status;\n\n\t\t\tif (ep_num == 0) {\n\t\t\t\tep0_req_complete(udc, curr_ep, curr_req);\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tdone(curr_ep, curr_req, status);\n\t\t}\n\t}\n}\n\nstatic inline enum usb_device_speed portscx_device_speed(u32 reg)\n{\n\tswitch (reg & PORTSCX_PORT_SPEED_MASK) {\n\tcase PORTSCX_PORT_SPEED_HIGH:\n\t\treturn USB_SPEED_HIGH;\n\tcase PORTSCX_PORT_SPEED_FULL:\n\t\treturn USB_SPEED_FULL;\n\tcase PORTSCX_PORT_SPEED_LOW:\n\t\treturn USB_SPEED_LOW;\n\tdefault:\n\t\treturn USB_SPEED_UNKNOWN;\n\t}\n}\n\n \nstatic void port_change_irq(struct fsl_udc *udc)\n{\n\tif (udc->bus_reset)\n\t\tudc->bus_reset = 0;\n\n\t \n\tif (!(fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET))\n\t\t \n\t\tudc->gadget.speed =\n\t\t\tportscx_device_speed(fsl_readl(&dr_regs->portsc1));\n\n\t \n\tif (!udc->resume_state)\n\t\tudc->usb_state = USB_STATE_DEFAULT;\n}\n\n \nstatic void suspend_irq(struct fsl_udc *udc)\n{\n\tudc->resume_state = udc->usb_state;\n\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\t \n\tif (udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n}\n\nstatic void bus_resume(struct fsl_udc *udc)\n{\n\tudc->usb_state = udc->resume_state;\n\tudc->resume_state = 0;\n\n\t \n\tif (udc->driver->resume)\n\t\tudc->driver->resume(&udc->gadget);\n}\n\n \nstatic int reset_queues(struct fsl_udc *udc, bool bus_reset)\n{\n\tu8 pipe;\n\n\tfor (pipe = 0; pipe < udc->max_pipes; pipe++)\n\t\tudc_reset_ep_queue(udc, pipe);\n\n\t \n\tspin_unlock(&udc->lock);\n\tif (bus_reset)\n\t\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\telse\n\t\tudc->driver->disconnect(&udc->gadget);\n\tspin_lock(&udc->lock);\n\n\treturn 0;\n}\n\n \nstatic void reset_irq(struct fsl_udc *udc)\n{\n\tu32 temp;\n\tunsigned long timeout;\n\n\t \n\ttemp = fsl_readl(&dr_regs->deviceaddr);\n\tfsl_writel(temp & ~USB_DEVICE_ADDRESS_MASK, &dr_regs->deviceaddr);\n\n\tudc->device_address = 0;\n\n\t \n\tudc->resume_state = 0;\n\tudc->ep0_dir = 0;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->remote_wakeup = 0;\t \n\tudc->gadget.b_hnp_enable = 0;\n\tudc->gadget.a_hnp_support = 0;\n\tudc->gadget.a_alt_hnp_support = 0;\n\n\t \n\ttemp = fsl_readl(&dr_regs->endptsetupstat);\n\tfsl_writel(temp, &dr_regs->endptsetupstat);\n\n\t \n\ttemp = fsl_readl(&dr_regs->endptcomplete);\n\tfsl_writel(temp, &dr_regs->endptcomplete);\n\n\ttimeout = jiffies + 100;\n\twhile (fsl_readl(&dr_regs->endpointprime)) {\n\t\t \n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tERR(\"Timeout for reset\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t \n\tfsl_writel(0xffffffff, &dr_regs->endptflush);\n\n\tif (fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_RESET) {\n\t\tVDBG(\"Bus reset\");\n\t\t \n\t\tudc->bus_reset = 1;\n\t\t \n\t\treset_queues(udc, true);\n\t\tudc->usb_state = USB_STATE_DEFAULT;\n\t} else {\n\t\tVDBG(\"Controller reset\");\n\t\t \n\t\tdr_controller_setup(udc);\n\n\t\t \n\t\treset_queues(udc, false);\n\n\t\tep0_setup(udc);\n\n\t\t \n\t\tdr_controller_run(udc);\n\t\tudc->usb_state = USB_STATE_ATTACHED;\n\t}\n}\n\n \nstatic irqreturn_t fsl_udc_irq(int irq, void *_udc)\n{\n\tstruct fsl_udc *udc = _udc;\n\tu32 irq_src;\n\tirqreturn_t status = IRQ_NONE;\n\tunsigned long flags;\n\n\t \n\tif (udc->stopped)\n\t\treturn IRQ_NONE;\n\tspin_lock_irqsave(&udc->lock, flags);\n\tirq_src = fsl_readl(&dr_regs->usbsts) & fsl_readl(&dr_regs->usbintr);\n\t \n\tfsl_writel(irq_src, &dr_regs->usbsts);\n\n\t \n\n\t \n\tif (udc->usb_state == USB_STATE_SUSPENDED)\n\t\tif ((fsl_readl(&dr_regs->portsc1) & PORTSCX_PORT_SUSPEND) == 0)\n\t\t\tbus_resume(udc);\n\n\t \n\tif (irq_src & USB_STS_INT) {\n\t\tVDBG(\"Packet int\");\n\t\t \n\t\tif (fsl_readl(&dr_regs->endptsetupstat) & EP_SETUP_STATUS_EP0) {\n\t\t\ttripwire_handler(udc, 0,\n\t\t\t\t\t(u8 *) (&udc->local_setup_buff));\n\t\t\tsetup_received_irq(udc, &udc->local_setup_buff);\n\t\t\tstatus = IRQ_HANDLED;\n\t\t}\n\n\t\t \n\t\tif (fsl_readl(&dr_regs->endptcomplete)) {\n\t\t\tdtd_complete_irq(udc);\n\t\t\tstatus = IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif (irq_src & USB_STS_SOF) {\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tif (irq_src & USB_STS_PORT_CHANGE) {\n\t\tport_change_irq(udc);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tif (irq_src & USB_STS_RESET) {\n\t\tVDBG(\"reset int\");\n\t\treset_irq(udc);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\t \n\tif (irq_src & USB_STS_SUSPEND) {\n\t\tsuspend_irq(udc);\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & (USB_STS_ERR | USB_STS_SYS_ERR)) {\n\t\tVDBG(\"Error IRQ %x\", irq_src);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\n \nstatic int fsl_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tint retval = 0;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&udc_controller->lock, flags);\n\n\t \n\tudc_controller->driver = driver;\n\tspin_unlock_irqrestore(&udc_controller->lock, flags);\n\tg->is_selfpowered = 1;\n\n\tif (!IS_ERR_OR_NULL(udc_controller->transceiver)) {\n\t\t \n\t\tudc_controller->stopped = 1;\n\t\tprintk(KERN_INFO \"Suspend udc for OTG auto detect\\n\");\n\n\t\t \n\t\tif (!IS_ERR_OR_NULL(udc_controller->transceiver)) {\n\t\t\tretval = otg_set_peripheral(\n\t\t\t\t\tudc_controller->transceiver->otg,\n\t\t\t\t\t\t    &udc_controller->gadget);\n\t\t\tif (retval < 0) {\n\t\t\t\tERR(\"can't bind to transceiver\\n\");\n\t\t\t\tudc_controller->driver = NULL;\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tdr_controller_run(udc_controller);\n\t\tudc_controller->usb_state = USB_STATE_ATTACHED;\n\t\tudc_controller->ep0_state = WAIT_FOR_SETUP;\n\t\tudc_controller->ep0_dir = 0;\n\t}\n\n\treturn retval;\n}\n\n \nstatic int fsl_udc_stop(struct usb_gadget *g)\n{\n\tstruct fsl_ep *loop_ep;\n\tunsigned long flags;\n\n\tif (!IS_ERR_OR_NULL(udc_controller->transceiver))\n\t\totg_set_peripheral(udc_controller->transceiver->otg, NULL);\n\n\t \n\tdr_controller_stop(udc_controller);\n\n\t \n\tudc_controller->usb_state = USB_STATE_ATTACHED;\n\tudc_controller->ep0_state = WAIT_FOR_SETUP;\n\tudc_controller->ep0_dir = 0;\n\n\t \n\tspin_lock_irqsave(&udc_controller->lock, flags);\n\tudc_controller->gadget.speed = USB_SPEED_UNKNOWN;\n\tnuke(&udc_controller->eps[0], -ESHUTDOWN);\n\tlist_for_each_entry(loop_ep, &udc_controller->gadget.ep_list,\n\t\t\tep.ep_list)\n\t\tnuke(loop_ep, -ESHUTDOWN);\n\tspin_unlock_irqrestore(&udc_controller->lock, flags);\n\n\tudc_controller->driver = NULL;\n\n\treturn 0;\n}\n\n \n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\n#include <linux/seq_file.h>\n\nstatic const char proc_filename[] = \"driver/fsl_usb2_udc\";\n\nstatic int fsl_proc_read(struct seq_file *m, void *v)\n{\n\tunsigned long flags;\n\tint i;\n\tu32 tmp_reg;\n\tstruct fsl_ep *ep = NULL;\n\tstruct fsl_req *req;\n\n\tstruct fsl_udc *udc = udc_controller;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tseq_printf(m,\n\t\t\tDRIVER_DESC \"\\n\"\n\t\t\t\"%s version: %s\\n\"\n\t\t\t\"Gadget driver: %s\\n\\n\",\n\t\t\tdriver_name, DRIVER_VERSION,\n\t\t\tudc->driver ? udc->driver->driver.name : \"(none)\");\n\n\t \n\ttmp_reg = fsl_readl(&dr_regs->usbcmd);\n\tseq_printf(m,\n\t\t\t\"USBCMD reg:\\n\"\n\t\t\t\"SetupTW: %d\\n\"\n\t\t\t\"Run/Stop: %s\\n\\n\",\n\t\t\t(tmp_reg & USB_CMD_SUTW) ? 1 : 0,\n\t\t\t(tmp_reg & USB_CMD_RUN_STOP) ? \"Run\" : \"Stop\");\n\n\ttmp_reg = fsl_readl(&dr_regs->usbsts);\n\tseq_printf(m,\n\t\t\t\"USB Status Reg:\\n\"\n\t\t\t\"Dr Suspend: %d Reset Received: %d System Error: %s \"\n\t\t\t\"USB Error Interrupt: %s\\n\\n\",\n\t\t\t(tmp_reg & USB_STS_SUSPEND) ? 1 : 0,\n\t\t\t(tmp_reg & USB_STS_RESET) ? 1 : 0,\n\t\t\t(tmp_reg & USB_STS_SYS_ERR) ? \"Err\" : \"Normal\",\n\t\t\t(tmp_reg & USB_STS_ERR) ? \"Err detected\" : \"No err\");\n\n\ttmp_reg = fsl_readl(&dr_regs->usbintr);\n\tseq_printf(m,\n\t\t\t\"USB Interrupt Enable Reg:\\n\"\n\t\t\t\"Sleep Enable: %d SOF Received Enable: %d \"\n\t\t\t\"Reset Enable: %d\\n\"\n\t\t\t\"System Error Enable: %d \"\n\t\t\t\"Port Change Detected Enable: %d\\n\"\n\t\t\t\"USB Error Intr Enable: %d USB Intr Enable: %d\\n\\n\",\n\t\t\t(tmp_reg & USB_INTR_DEVICE_SUSPEND) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_SOF_EN) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_RESET_EN) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_SYS_ERR_EN) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_PTC_DETECT_EN) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_ERR_INT_EN) ? 1 : 0,\n\t\t\t(tmp_reg & USB_INTR_INT_EN) ? 1 : 0);\n\n\ttmp_reg = fsl_readl(&dr_regs->frindex);\n\tseq_printf(m,\n\t\t\t\"USB Frame Index Reg: Frame Number is 0x%x\\n\\n\",\n\t\t\t(tmp_reg & USB_FRINDEX_MASKS));\n\n\ttmp_reg = fsl_readl(&dr_regs->deviceaddr);\n\tseq_printf(m,\n\t\t\t\"USB Device Address Reg: Device Addr is 0x%x\\n\\n\",\n\t\t\t(tmp_reg & USB_DEVICE_ADDRESS_MASK));\n\n\ttmp_reg = fsl_readl(&dr_regs->endpointlistaddr);\n\tseq_printf(m,\n\t\t\t\"USB Endpoint List Address Reg: \"\n\t\t\t\"Device Addr is 0x%x\\n\\n\",\n\t\t\t(tmp_reg & USB_EP_LIST_ADDRESS_MASK));\n\n\ttmp_reg = fsl_readl(&dr_regs->portsc1);\n\tseq_printf(m,\n\t\t\"USB Port Status&Control Reg:\\n\"\n\t\t\"Port Transceiver Type : %s Port Speed: %s\\n\"\n\t\t\"PHY Low Power Suspend: %s Port Reset: %s \"\n\t\t\"Port Suspend Mode: %s\\n\"\n\t\t\"Over-current Change: %s \"\n\t\t\"Port Enable/Disable Change: %s\\n\"\n\t\t\"Port Enabled/Disabled: %s \"\n\t\t\"Current Connect Status: %s\\n\\n\", ( {\n\t\t\tconst char *s;\n\t\t\tswitch (tmp_reg & PORTSCX_PTS_FSLS) {\n\t\t\tcase PORTSCX_PTS_UTMI:\n\t\t\t\ts = \"UTMI\"; break;\n\t\t\tcase PORTSCX_PTS_ULPI:\n\t\t\t\ts = \"ULPI \"; break;\n\t\t\tcase PORTSCX_PTS_FSLS:\n\t\t\t\ts = \"FS/LS Serial\"; break;\n\t\t\tdefault:\n\t\t\t\ts = \"None\"; break;\n\t\t\t}\n\t\t\ts;} ),\n\t\tusb_speed_string(portscx_device_speed(tmp_reg)),\n\t\t(tmp_reg & PORTSCX_PHY_LOW_POWER_SPD) ?\n\t\t\"Normal PHY mode\" : \"Low power mode\",\n\t\t(tmp_reg & PORTSCX_PORT_RESET) ? \"In Reset\" :\n\t\t\"Not in Reset\",\n\t\t(tmp_reg & PORTSCX_PORT_SUSPEND) ? \"In \" : \"Not in\",\n\t\t(tmp_reg & PORTSCX_OVER_CURRENT_CHG) ? \"Dected\" :\n\t\t\"No\",\n\t\t(tmp_reg & PORTSCX_PORT_EN_DIS_CHANGE) ? \"Disable\" :\n\t\t\"Not change\",\n\t\t(tmp_reg & PORTSCX_PORT_ENABLE) ? \"Enable\" :\n\t\t\"Not correct\",\n\t\t(tmp_reg & PORTSCX_CURRENT_CONNECT_STATUS) ?\n\t\t\"Attached\" : \"Not-Att\");\n\n\ttmp_reg = fsl_readl(&dr_regs->usbmode);\n\tseq_printf(m,\n\t\t\t\"USB Mode Reg: Controller Mode is: %s\\n\\n\", ( {\n\t\t\t\tconst char *s;\n\t\t\t\tswitch (tmp_reg & USB_MODE_CTRL_MODE_HOST) {\n\t\t\t\tcase USB_MODE_CTRL_MODE_IDLE:\n\t\t\t\t\ts = \"Idle\"; break;\n\t\t\t\tcase USB_MODE_CTRL_MODE_DEVICE:\n\t\t\t\t\ts = \"Device Controller\"; break;\n\t\t\t\tcase USB_MODE_CTRL_MODE_HOST:\n\t\t\t\t\ts = \"Host Controller\"; break;\n\t\t\t\tdefault:\n\t\t\t\t\ts = \"None\"; break;\n\t\t\t\t}\n\t\t\t\ts;\n\t\t\t} ));\n\n\ttmp_reg = fsl_readl(&dr_regs->endptsetupstat);\n\tseq_printf(m,\n\t\t\t\"Endpoint Setup Status Reg: SETUP on ep 0x%x\\n\\n\",\n\t\t\t(tmp_reg & EP_SETUP_STATUS_MASK));\n\n\tfor (i = 0; i < udc->max_ep / 2; i++) {\n\t\ttmp_reg = fsl_readl(&dr_regs->endptctrl[i]);\n\t\tseq_printf(m, \"EP Ctrl Reg [0x%x]: = [0x%x]\\n\", i, tmp_reg);\n\t}\n\ttmp_reg = fsl_readl(&dr_regs->endpointprime);\n\tseq_printf(m, \"EP Prime Reg = [0x%x]\\n\\n\", tmp_reg);\n\n\tif (udc->pdata->have_sysif_regs) {\n\t\ttmp_reg = usb_sys_regs->snoop1;\n\t\tseq_printf(m, \"Snoop1 Reg : = [0x%x]\\n\\n\", tmp_reg);\n\n\t\ttmp_reg = usb_sys_regs->control;\n\t\tseq_printf(m, \"General Control Reg : = [0x%x]\\n\\n\", tmp_reg);\n\t}\n\n\t \n\tep = &udc->eps[0];\n\tseq_printf(m, \"For %s Maxpkt is 0x%x index is 0x%x\\n\",\n\t\t\tep->ep.name, ep_maxpacket(ep), ep_index(ep));\n\n\tif (list_empty(&ep->queue)) {\n\t\tseq_puts(m, \"its req queue is empty\\n\\n\");\n\t} else {\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tseq_printf(m,\n\t\t\t\t\"req %p actual 0x%x length 0x%x buf %p\\n\",\n\t\t\t\t&req->req, req->req.actual,\n\t\t\t\treq->req.length, req->req.buf);\n\t\t}\n\t}\n\t \n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\tif (ep->ep.desc) {\n\t\t\tseq_printf(m,\n\t\t\t\t\t\"\\nFor %s Maxpkt is 0x%x \"\n\t\t\t\t\t\"index is 0x%x\\n\",\n\t\t\t\t\tep->ep.name, ep_maxpacket(ep),\n\t\t\t\t\tep_index(ep));\n\n\t\t\tif (list_empty(&ep->queue)) {\n\t\t\t\tseq_puts(m, \"its req queue is empty\\n\\n\");\n\t\t\t} else {\n\t\t\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\t\t\tseq_printf(m,\n\t\t\t\t\t\t\"req %p actual 0x%x length \"\n\t\t\t\t\t\t\"0x%x  buf %p\\n\",\n\t\t\t\t\t\t&req->req, req->req.actual,\n\t\t\t\t\t\treq->req.length, req->req.buf);\n\t\t\t\t}\t \n\t\t\t}\t \n\t\t}\t \n\t}\t \n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n#define create_proc_file() \\\n\tproc_create_single(proc_filename, 0, NULL, fsl_proc_read)\n#define remove_proc_file()\tremove_proc_entry(proc_filename, NULL)\n\n#else\t\t\t\t \n\n#define create_proc_file()\tdo {} while (0)\n#define remove_proc_file()\tdo {} while (0)\n\n#endif\t\t\t\t \n\n \n\n \nstatic void fsl_udc_release(struct device *dev)\n{\n\tcomplete(udc_controller->done);\n\tdma_free_coherent(dev->parent, udc_controller->ep_qh_size,\n\t\t\tudc_controller->ep_qh, udc_controller->ep_qh_dma);\n\tkfree(udc_controller);\n}\n\n \n \nstatic int struct_udc_setup(struct fsl_udc *udc,\n\t\tstruct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata;\n\tsize_t size;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tudc->phy_mode = pdata->phy_mode;\n\n\tudc->eps = kcalloc(udc->max_ep, sizeof(struct fsl_ep), GFP_KERNEL);\n\tif (!udc->eps) {\n\t\tERR(\"kmalloc udc endpoint status failed\\n\");\n\t\tgoto eps_alloc_failed;\n\t}\n\n\t \n\tsize = udc->max_ep * sizeof(struct ep_queue_head);\n\tif (size < QH_ALIGNMENT)\n\t\tsize = QH_ALIGNMENT;\n\telse if ((size % QH_ALIGNMENT) != 0) {\n\t\tsize += QH_ALIGNMENT + 1;\n\t\tsize &= ~(QH_ALIGNMENT - 1);\n\t}\n\tudc->ep_qh = dma_alloc_coherent(&pdev->dev, size,\n\t\t\t\t\t&udc->ep_qh_dma, GFP_KERNEL);\n\tif (!udc->ep_qh) {\n\t\tERR(\"malloc QHs for udc failed\\n\");\n\t\tgoto ep_queue_alloc_failed;\n\t}\n\n\tudc->ep_qh_size = size;\n\n\t \n\t \n\tudc->status_req = container_of(fsl_alloc_request(NULL, GFP_KERNEL),\n\t\t\tstruct fsl_req, req);\n\tif (!udc->status_req) {\n\t\tERR(\"kzalloc for udc status request failed\\n\");\n\t\tgoto udc_status_alloc_failed;\n\t}\n\n\t \n\tudc->status_req->req.buf = kmalloc(8, GFP_KERNEL);\n\tif (!udc->status_req->req.buf) {\n\t\tERR(\"kzalloc for udc request buffer failed\\n\");\n\t\tgoto udc_req_buf_alloc_failed;\n\t}\n\n\tudc->resume_state = USB_STATE_NOTATTACHED;\n\tudc->usb_state = USB_STATE_POWERED;\n\tudc->ep0_dir = 0;\n\tudc->remote_wakeup = 0;\t \n\n\treturn 0;\n\nudc_req_buf_alloc_failed:\n\tkfree(udc->status_req);\nudc_status_alloc_failed:\n\tkfree(udc->ep_qh);\n\tudc->ep_qh_size = 0;\nep_queue_alloc_failed:\n\tkfree(udc->eps);\neps_alloc_failed:\n\tudc->phy_mode = 0;\n\treturn -1;\n\n}\n\n \nstatic int struct_ep_setup(struct fsl_udc *udc, unsigned char index,\n\t\tchar *name, int link)\n{\n\tstruct fsl_ep *ep = &udc->eps[index];\n\n\tep->udc = udc;\n\tstrcpy(ep->name, name);\n\tep->ep.name = ep->name;\n\n\tep->ep.ops = &fsl_ep_ops;\n\tep->stopped = 0;\n\n\tif (index == 0) {\n\t\tep->ep.caps.type_control = true;\n\t} else {\n\t\tep->ep.caps.type_iso = true;\n\t\tep->ep.caps.type_bulk = true;\n\t\tep->ep.caps.type_int = true;\n\t}\n\n\tif (index & 1)\n\t\tep->ep.caps.dir_in = true;\n\telse\n\t\tep->ep.caps.dir_out = true;\n\n\t \n\tusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\n\n\t \n\tINIT_LIST_HEAD(&ep->queue);\n\n\t \n\tif (link)\n\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\tep->gadget = &udc->gadget;\n\tep->qh = &udc->ep_qh[index];\n\n\treturn 0;\n}\n\n \nstatic int fsl_udc_probe(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata;\n\tstruct resource *res;\n\tint ret = -ENODEV;\n\tunsigned int i;\n\tu32 dccparams;\n\n\tudc_controller = kzalloc(sizeof(struct fsl_udc), GFP_KERNEL);\n\tif (udc_controller == NULL)\n\t\treturn -ENOMEM;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tudc_controller->pdata = pdata;\n\tspin_lock_init(&udc_controller->lock);\n\tudc_controller->stopped = 1;\n\n#ifdef CONFIG_USB_OTG\n\tif (pdata->operating_mode == FSL_USB2_DR_OTG) {\n\t\tudc_controller->transceiver = usb_get_phy(USB_PHY_TYPE_USB2);\n\t\tif (IS_ERR_OR_NULL(udc_controller->transceiver)) {\n\t\t\tERR(\"Can't find OTG driver!\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_kfree;\n\t\t}\n\t}\n#endif\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENXIO;\n\t\tgoto err_kfree;\n\t}\n\n\tif (pdata->operating_mode == FSL_USB2_DR_DEVICE) {\n\t\tif (!request_mem_region(res->start, resource_size(res),\n\t\t\t\t\tdriver_name)) {\n\t\t\tERR(\"request mem region for %s failed\\n\", pdev->name);\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_kfree;\n\t\t}\n\t}\n\n\tdr_regs = ioremap(res->start, resource_size(res));\n\tif (!dr_regs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_mem_region;\n\t}\n\n\tpdata->regs = (void __iomem *)dr_regs;\n\n\t \n\tif (pdata->init && pdata->init(pdev)) {\n\t\tret = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tfsl_set_accessors(pdata);\n\n\tif (pdata->have_sysif_regs)\n\t\tusb_sys_regs = (void *)dr_regs + USB_DR_SYS_OFFSET;\n\n\t \n\tdccparams = fsl_readl(&dr_regs->dccparams);\n\tif (!(dccparams & DCCPARAMS_DC)) {\n\t\tERR(\"This SOC doesn't support device role\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_exit;\n\t}\n\t \n\t \n\tudc_controller->max_ep = (dccparams & DCCPARAMS_DEN_MASK) * 2;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret <= 0) {\n\t\tret = ret ? : -ENODEV;\n\t\tgoto err_exit;\n\t}\n\tudc_controller->irq = ret;\n\n\tret = request_irq(udc_controller->irq, fsl_udc_irq, IRQF_SHARED,\n\t\t\tdriver_name, udc_controller);\n\tif (ret != 0) {\n\t\tERR(\"cannot request irq %d err %d\\n\",\n\t\t\t\tudc_controller->irq, ret);\n\t\tgoto err_exit;\n\t}\n\n\t \n\tif (struct_udc_setup(udc_controller, pdev)) {\n\t\tERR(\"Can't initialize udc data structure\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tif (IS_ERR_OR_NULL(udc_controller->transceiver)) {\n\t\t \n\t\tdr_controller_setup(udc_controller);\n\t}\n\n\t \n\tudc_controller->gadget.ops = &fsl_gadget_ops;\n\tudc_controller->gadget.max_speed = USB_SPEED_HIGH;\n\tudc_controller->gadget.ep0 = &udc_controller->eps[0].ep;\n\tINIT_LIST_HEAD(&udc_controller->gadget.ep_list);\n\tudc_controller->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc_controller->gadget.name = driver_name;\n\n\t \n\tdev_set_name(&udc_controller->gadget.dev, \"gadget\");\n\tudc_controller->gadget.dev.of_node = pdev->dev.of_node;\n\n\tif (!IS_ERR_OR_NULL(udc_controller->transceiver))\n\t\tudc_controller->gadget.is_otg = 1;\n\n\t \n\tep0_setup(udc_controller);\n\n\t \n\tstruct_ep_setup(udc_controller, 0, \"ep0\", 0);\n\t \n\tudc_controller->eps[0].ep.desc = &fsl_ep0_desc;\n\tusb_ep_set_maxpacket_limit(&udc_controller->eps[0].ep,\n\t\t\t\t   USB_MAX_CTRL_PAYLOAD);\n\n\t \n\tfor (i = 1; i < (int)(udc_controller->max_ep / 2); i++) {\n\t\tchar name[14];\n\n\t\tsprintf(name, \"ep%dout\", i);\n\t\tstruct_ep_setup(udc_controller, i * 2, name, 1);\n\t\tsprintf(name, \"ep%din\", i);\n\t\tstruct_ep_setup(udc_controller, i * 2 + 1, name, 1);\n\t}\n\n\t \n\tudc_controller->td_pool = dma_pool_create(\"udc_td\", &pdev->dev,\n\t\t\tsizeof(struct ep_td_struct),\n\t\t\tDTD_ALIGNMENT, UDC_DMA_BOUNDARY);\n\tif (udc_controller->td_pool == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tret = usb_add_gadget_udc_release(&pdev->dev, &udc_controller->gadget,\n\t\t\tfsl_udc_release);\n\tif (ret)\n\t\tgoto err_del_udc;\n\n\tcreate_proc_file();\n\treturn 0;\n\nerr_del_udc:\n\tdma_pool_destroy(udc_controller->td_pool);\nerr_free_irq:\n\tfree_irq(udc_controller->irq, udc_controller);\nerr_exit:\n\tif (pdata->exit)\n\t\tpdata->exit(pdev);\nerr_iounmap:\n\tiounmap(dr_regs);\nerr_release_mem_region:\n\tif (pdata->operating_mode == FSL_USB2_DR_DEVICE)\n\t\trelease_mem_region(res->start, resource_size(res));\nerr_kfree:\n\tkfree(udc_controller);\n\tudc_controller = NULL;\n\treturn ret;\n}\n\n \nstatic int fsl_udc_remove(struct platform_device *pdev)\n{\n\tstruct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tif (!udc_controller)\n\t\treturn -ENODEV;\n\n\tudc_controller->done = &done;\n\tusb_del_gadget_udc(&udc_controller->gadget);\n\n\t \n\tremove_proc_file();\n\n\t \n\tkfree(udc_controller->status_req->req.buf);\n\tkfree(udc_controller->status_req);\n\tkfree(udc_controller->eps);\n\n\tdma_pool_destroy(udc_controller->td_pool);\n\tfree_irq(udc_controller->irq, udc_controller);\n\tiounmap(dr_regs);\n\tif (res && (pdata->operating_mode == FSL_USB2_DR_DEVICE))\n\t\trelease_mem_region(res->start, resource_size(res));\n\n\t \n\twait_for_completion(&done);\n\n\t \n\tif (pdata->exit)\n\t\tpdata->exit(pdev);\n\n\treturn 0;\n}\n\n \nstatic int fsl_udc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tdr_controller_stop(udc_controller);\n\treturn 0;\n}\n\n \nstatic int fsl_udc_resume(struct platform_device *pdev)\n{\n\t \n\tif (udc_controller->stopped) {\n\t\tdr_controller_setup(udc_controller);\n\t\tdr_controller_run(udc_controller);\n\t}\n\tudc_controller->usb_state = USB_STATE_ATTACHED;\n\tudc_controller->ep0_state = WAIT_FOR_SETUP;\n\tudc_controller->ep0_dir = 0;\n\treturn 0;\n}\n\nstatic int fsl_udc_otg_suspend(struct device *dev, pm_message_t state)\n{\n\tstruct fsl_udc *udc = udc_controller;\n\tu32 mode, usbcmd;\n\n\tmode = fsl_readl(&dr_regs->usbmode) & USB_MODE_CTRL_MODE_MASK;\n\n\tpr_debug(\"%s(): mode 0x%x stopped %d\\n\", __func__, mode, udc->stopped);\n\n\t \n\tif (udc->stopped) {\n\t\tpr_debug(\"gadget already stopped, leaving early\\n\");\n\t\tudc->already_stopped = 1;\n\t\treturn 0;\n\t}\n\n\tif (mode != USB_MODE_CTRL_MODE_DEVICE) {\n\t\tpr_debug(\"gadget not in device mode, leaving early\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tusbcmd = fsl_readl(&dr_regs->usbcmd) & ~USB_CMD_RUN_STOP;\n\tfsl_writel(usbcmd, &dr_regs->usbcmd);\n\n\tudc->stopped = 1;\n\n\tpr_info(\"USB Gadget suspended\\n\");\n\n\treturn 0;\n}\n\nstatic int fsl_udc_otg_resume(struct device *dev)\n{\n\tpr_debug(\"%s(): stopped %d  already_stopped %d\\n\", __func__,\n\t\t udc_controller->stopped, udc_controller->already_stopped);\n\n\t \n\tif (udc_controller->already_stopped) {\n\t\tudc_controller->already_stopped = 0;\n\t\tpr_debug(\"gadget was already stopped, leaving early\\n\");\n\t\treturn 0;\n\t}\n\n\tpr_info(\"USB Gadget resume\\n\");\n\n\treturn fsl_udc_resume(NULL);\n}\n \nstatic const struct platform_device_id fsl_udc_devtype[] = {\n\t{\n\t\t.name = \"fsl-usb2-udc\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, fsl_udc_devtype);\nstatic struct platform_driver udc_driver = {\n\t.remove\t\t= fsl_udc_remove,\n\t.id_table\t= fsl_udc_devtype,\n\t \n\t.suspend\t= fsl_udc_suspend,\n\t.resume\t\t= fsl_udc_resume,\n\t.driver\t\t= {\n\t\t\t.name = driver_name,\n\t\t\t \n\t\t\t.suspend = fsl_udc_otg_suspend,\n\t\t\t.resume  = fsl_udc_otg_resume,\n\t},\n};\n\nmodule_platform_driver_probe(udc_driver, fsl_udc_probe);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:fsl-usb2-udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}