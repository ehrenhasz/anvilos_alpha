{
  "module_name": "renesas_usbf.c",
  "hash_id": "a573058d05e475ab569195f2966b2661aeaf19c403dfabdaafb12422ee0c1bb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/renesas_usbf.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/kfifo.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/role.h>\n\n#define USBF_NUM_ENDPOINTS\t16\n#define USBF_EP0_MAX_PCKT_SIZE\t64\n\n \n#define USBF_REG_USB_CONTROL\t0x000\n#define     USBF_USB_PUE2\t\tBIT(2)\n#define     USBF_USB_CONNECTB\t\tBIT(3)\n#define     USBF_USB_DEFAULT\t\tBIT(4)\n#define     USBF_USB_CONF\t\tBIT(5)\n#define     USBF_USB_SUSPEND\t\tBIT(6)\n#define     USBF_USB_RSUM_IN\t\tBIT(7)\n#define     USBF_USB_SOF_RCV\t\tBIT(8)\n#define     USBF_USB_FORCEFS\t\tBIT(9)\n#define     USBF_USB_INT_SEL\t\tBIT(10)\n#define     USBF_USB_SOF_CLK_MODE\tBIT(11)\n\n#define USBF_REG_USB_STATUS\t0x004\n#define     USBF_USB_RSUM_OUT\t\tBIT(1)\n#define     USBF_USB_SPND_OUT\t\tBIT(2)\n#define     USBF_USB_USB_RST\t\tBIT(3)\n#define     USBF_USB_DEFAULT_ST\t\tBIT(4)\n#define     USBF_USB_CONF_ST\t\tBIT(5)\n#define     USBF_USB_SPEED_MODE\t\tBIT(6)\n#define     USBF_USB_SOF_DELAY_STATUS\tBIT(31)\n\n#define USBF_REG_USB_ADDRESS\t0x008\n#define     USBF_USB_SOF_STATUS\t\tBIT(15)\n#define     USBF_USB_SET_USB_ADDR(_a)\t((_a) << 16)\n#define     USBF_USB_GET_FRAME(_r)\t((_r) & 0x7FF)\n\n#define USBF_REG_SETUP_DATA0\t0x018\n#define USBF_REG_SETUP_DATA1\t0x01C\n#define USBF_REG_USB_INT_STA\t0x020\n#define     USBF_USB_RSUM_INT\t\tBIT(1)\n#define     USBF_USB_SPND_INT\t\tBIT(2)\n#define     USBF_USB_USB_RST_INT\tBIT(3)\n#define     USBF_USB_SOF_INT\t\tBIT(4)\n#define     USBF_USB_SOF_ERROR_INT\tBIT(5)\n#define     USBF_USB_SPEED_MODE_INT\tBIT(6)\n#define     USBF_USB_EPN_INT(_n)\t(BIT(8) << (_n))  \n\n#define USBF_REG_USB_INT_ENA\t0x024\n#define     USBF_USB_RSUM_EN\t\tBIT(1)\n#define     USBF_USB_SPND_EN\t\tBIT(2)\n#define     USBF_USB_USB_RST_EN\t\tBIT(3)\n#define     USBF_USB_SOF_EN\t\tBIT(4)\n#define     USBF_USB_SOF_ERROR_EN\tBIT(5)\n#define     USBF_USB_SPEED_MODE_EN\tBIT(6)\n#define     USBF_USB_EPN_EN(_n)\t\t(BIT(8) << (_n))  \n\n#define USBF_BASE_EP0\t\t0x028\n \n#define     USBF_REG_EP0_CONTROL\t0x00\n#define         USBF_EP0_ONAK\t\t\tBIT(0)\n#define         USBF_EP0_INAK\t\t\tBIT(1)\n#define         USBF_EP0_STL\t\t\tBIT(2)\n#define         USBF_EP0_PERR_NAK_CLR\t\tBIT(3)\n#define         USBF_EP0_INAK_EN\t\tBIT(4)\n#define         USBF_EP0_DW_MASK\t\t(0x3 << 5)\n#define         USBF_EP0_DW(_s)\t\t\t((_s) << 5)\n#define         USBF_EP0_DEND\t\t\tBIT(7)\n#define         USBF_EP0_BCLR\t\t\tBIT(8)\n#define         USBF_EP0_PIDCLR\t\t\tBIT(9)\n#define         USBF_EP0_AUTO\t\t\tBIT(16)\n#define         USBF_EP0_OVERSEL\t\tBIT(17)\n#define         USBF_EP0_STGSEL\t\t\tBIT(18)\n\n#define     USBF_REG_EP0_STATUS\t\t0x04\n#define         USBF_EP0_SETUP_INT\t\tBIT(0)\n#define         USBF_EP0_STG_START_INT\t\tBIT(1)\n#define         USBF_EP0_STG_END_INT\t\tBIT(2)\n#define         USBF_EP0_STALL_INT\t\tBIT(3)\n#define         USBF_EP0_IN_INT\t\t\tBIT(4)\n#define         USBF_EP0_OUT_INT\t\tBIT(5)\n#define         USBF_EP0_OUT_OR_INT\t\tBIT(6)\n#define         USBF_EP0_OUT_NULL_INT\t\tBIT(7)\n#define         USBF_EP0_IN_EMPTY\t\tBIT(8)\n#define         USBF_EP0_IN_FULL\t\tBIT(9)\n#define         USBF_EP0_IN_DATA\t\tBIT(10)\n#define         USBF_EP0_IN_NAK_INT\t\tBIT(11)\n#define         USBF_EP0_OUT_EMPTY\t\tBIT(12)\n#define         USBF_EP0_OUT_FULL\t\tBIT(13)\n#define         USBF_EP0_OUT_NULL\t\tBIT(14)\n#define         USBF_EP0_OUT_NAK_INT\t\tBIT(15)\n#define         USBF_EP0_PERR_NAK_INT\t\tBIT(16)\n#define         USBF_EP0_PERR_NAK\t\tBIT(17)\n#define         USBF_EP0_PID\t\t\tBIT(18)\n\n#define     USBF_REG_EP0_INT_ENA\t0x08\n#define         USBF_EP0_SETUP_EN\t\tBIT(0)\n#define         USBF_EP0_STG_START_EN\t\tBIT(1)\n#define         USBF_EP0_STG_END_EN\t\tBIT(2)\n#define         USBF_EP0_STALL_EN\t\tBIT(3)\n#define         USBF_EP0_IN_EN\t\t\tBIT(4)\n#define         USBF_EP0_OUT_EN\t\t\tBIT(5)\n#define         USBF_EP0_OUT_OR_EN\t\tBIT(6)\n#define         USBF_EP0_OUT_NULL_EN\t\tBIT(7)\n#define         USBF_EP0_IN_NAK_EN\t\tBIT(11)\n#define         USBF_EP0_OUT_NAK_EN\t\tBIT(15)\n#define         USBF_EP0_PERR_NAK_EN\t\tBIT(16)\n\n#define     USBF_REG_EP0_LENGTH\t\t0x0C\n#define         USBF_EP0_LDATA\t\t\t(0x7FF << 0)\n#define     USBF_REG_EP0_READ\t\t0x10\n#define     USBF_REG_EP0_WRITE\t\t0x14\n\n#define USBF_BASE_EPN(_n)\t(0x040 + (_n) * 0x020)\n \n#define     USBF_REG_EPN_CONTROL\t0x000\n#define         USBF_EPN_ONAK\t\t\tBIT(0)\n#define         USBF_EPN_OSTL\t\t\tBIT(2)\n#define         USBF_EPN_ISTL\t\t\tBIT(3)\n#define         USBF_EPN_OSTL_EN\t\tBIT(4)\n#define         USBF_EPN_DW_MASK\t\t(0x3 << 5)\n#define         USBF_EPN_DW(_s)\t\t\t((_s) << 5)\n#define         USBF_EPN_DEND\t\t\tBIT(7)\n#define         USBF_EPN_CBCLR\t\t\tBIT(8)\n#define         USBF_EPN_BCLR\t\t\tBIT(9)\n#define         USBF_EPN_OPIDCLR\t\tBIT(10)\n#define         USBF_EPN_IPIDCLR\t\tBIT(11)\n#define         USBF_EPN_AUTO\t\t\tBIT(16)\n#define         USBF_EPN_OVERSEL\t\tBIT(17)\n#define         USBF_EPN_MODE_MASK\t\t(0x3 << 24)\n#define         USBF_EPN_MODE_BULK\t\t(0x0 << 24)\n#define         USBF_EPN_MODE_INTR\t\t(0x1 << 24)\n#define         USBF_EPN_MODE_ISO\t\t(0x2 << 24)\n#define         USBF_EPN_DIR0\t\t\tBIT(26)\n#define         USBF_EPN_BUF_TYPE_DOUBLE\tBIT(30)\n#define         USBF_EPN_EN\t\t\tBIT(31)\n\n#define     USBF_REG_EPN_STATUS\t\t0x004\n#define         USBF_EPN_IN_EMPTY\t\tBIT(0)\n#define         USBF_EPN_IN_FULL\t\tBIT(1)\n#define         USBF_EPN_IN_DATA\t\tBIT(2)\n#define         USBF_EPN_IN_INT\t\t\tBIT(3)\n#define         USBF_EPN_IN_STALL_INT\t\tBIT(4)\n#define         USBF_EPN_IN_NAK_ERR_INT\t\tBIT(5)\n#define         USBF_EPN_IN_END_INT\t\tBIT(7)\n#define         USBF_EPN_IPID\t\t\tBIT(10)\n#define         USBF_EPN_OUT_EMPTY\t\tBIT(16)\n#define         USBF_EPN_OUT_FULL\t\tBIT(17)\n#define         USBF_EPN_OUT_NULL_INT\t\tBIT(18)\n#define         USBF_EPN_OUT_INT\t\tBIT(19)\n#define         USBF_EPN_OUT_STALL_INT\t\tBIT(20)\n#define         USBF_EPN_OUT_NAK_ERR_INT\tBIT(21)\n#define         USBF_EPN_OUT_OR_INT\t\tBIT(22)\n#define         USBF_EPN_OUT_END_INT\t\tBIT(23)\n#define         USBF_EPN_ISO_CRC\t\tBIT(24)\n#define         USBF_EPN_ISO_OR\t\t\tBIT(26)\n#define         USBF_EPN_OUT_NOTKN\t\tBIT(27)\n#define         USBF_EPN_ISO_OPID\t\tBIT(28)\n#define         USBF_EPN_ISO_PIDERR\t\tBIT(29)\n\n#define     USBF_REG_EPN_INT_ENA\t0x008\n#define         USBF_EPN_IN_EN\t\t\tBIT(3)\n#define         USBF_EPN_IN_STALL_EN\t\tBIT(4)\n#define         USBF_EPN_IN_NAK_ERR_EN\t\tBIT(5)\n#define         USBF_EPN_IN_END_EN\t\tBIT(7)\n#define         USBF_EPN_OUT_NULL_EN\t\tBIT(18)\n#define         USBF_EPN_OUT_EN\t\t\tBIT(19)\n#define         USBF_EPN_OUT_STALL_EN\t\tBIT(20)\n#define         USBF_EPN_OUT_NAK_ERR_EN\t\tBIT(21)\n#define         USBF_EPN_OUT_OR_EN\t\tBIT(22)\n#define         USBF_EPN_OUT_END_EN\t\tBIT(23)\n\n#define     USBF_REG_EPN_DMA_CTRL\t0x00C\n#define         USBF_EPN_DMAMODE0\t\tBIT(0)\n#define         USBF_EPN_DMA_EN\t\t\tBIT(4)\n#define         USBF_EPN_STOP_SET\t\tBIT(8)\n#define         USBF_EPN_BURST_SET\t\tBIT(9)\n#define         USBF_EPN_DEND_SET\t\tBIT(10)\n#define         USBF_EPN_STOP_MODE\t\tBIT(11)\n\n#define     USBF_REG_EPN_PCKT_ADRS\t0x010\n#define         USBF_EPN_MPKT(_l)\t\t((_l) << 0)\n#define         USBF_EPN_BASEAD(_a)\t\t((_a) << 16)\n\n#define     USBF_REG_EPN_LEN_DCNT\t0x014\n#define         USBF_EPN_GET_LDATA(_r)\t\t((_r) & 0x7FF)\n#define         USBF_EPN_SET_DMACNT(_c)\t\t((_c) << 16)\n#define         USBF_EPN_GET_DMACNT(_r)\t\t(((_r) >> 16) & 0x1ff)\n\n#define     USBF_REG_EPN_READ\t\t0x018\n#define     USBF_REG_EPN_WRITE\t\t0x01C\n\n \n#define USBF_REG_AHBSCTR\t0x1000\n#define USBF_REG_AHBMCTR\t0x1004\n#define     USBF_SYS_WBURST_TYPE\tBIT(2)\n#define     USBF_SYS_ARBITER_CTR\tBIT(31)\n\n#define USBF_REG_AHBBINT\t0x1008\n#define     USBF_SYS_ERR_MASTER\t\t (0x0F << 0)\n#define     USBF_SYS_SBUS_ERRINT0\t BIT(4)\n#define     USBF_SYS_SBUS_ERRINT1\t BIT(5)\n#define     USBF_SYS_MBUS_ERRINT\t BIT(6)\n#define     USBF_SYS_VBUS_INT\t\t BIT(13)\n#define     USBF_SYS_DMA_ENDINT_EPN(_n)\t (BIT(16) << (_n))  \n\n#define USBF_REG_AHBBINTEN\t0x100C\n#define     USBF_SYS_SBUS_ERRINT0EN\t  BIT(4)\n#define     USBF_SYS_SBUS_ERRINT1EN\t  BIT(5)\n#define     USBF_SYS_MBUS_ERRINTEN\t  BIT(6)\n#define     USBF_SYS_VBUS_INTEN\t\t  BIT(13)\n#define     USBF_SYS_DMA_ENDINTEN_EPN(_n) (BIT(16) << (_n))  \n\n#define USBF_REG_EPCTR\t\t0x1010\n#define     USBF_SYS_EPC_RST\t\tBIT(0)\n#define     USBF_SYS_PLL_RST\t\tBIT(2)\n#define     USBF_SYS_PLL_LOCK\t\tBIT(4)\n#define     USBF_SYS_PLL_RESUME\t\tBIT(5)\n#define     USBF_SYS_VBUS_LEVEL\t\tBIT(8)\n#define     USBF_SYS_DIRPD\t\tBIT(12)\n\n#define USBF_REG_USBSSVER\t0x1020\n#define USBF_REG_USBSSCONF\t0x1024\n#define    USBF_SYS_DMA_AVAILABLE(_n)\t(BIT(0) << (_n))  \n#define    USBF_SYS_EP_AVAILABLE(_n)\t(BIT(16) << (_n))  \n\n#define USBF_BASE_DMA_EPN(_n)\t(0x1110 + (_n) * 0x010)\n \n#define     USBF_REG_DMA_EPN_DCR1\t0x00\n#define         USBF_SYS_EPN_REQEN\t\tBIT(0)\n#define         USBF_SYS_EPN_DIR0\t\tBIT(1)\n#define         USBF_SYS_EPN_SET_DMACNT(_c)\t((_c) << 16)\n#define         USBF_SYS_EPN_GET_DMACNT(_r)\t(((_r) >> 16) & 0x0FF)\n\n#define     USBF_REG_DMA_EPN_DCR2\t0x04\n#define         USBF_SYS_EPN_MPKT(_s)\t\t((_s) << 0)\n#define         USBF_SYS_EPN_LMPKT(_l)\t\t((_l) << 16)\n\n#define     USBF_REG_DMA_EPN_TADR\t0x08\n\n \nstruct usbf_req {\n\tstruct usb_request\treq;\n\tstruct list_head\tqueue;\n\tunsigned int\t\tis_zero_sent : 1;\n\tunsigned int\t\tis_mapped : 1;\n\tenum {\n\t\tUSBF_XFER_START,\n\t\tUSBF_XFER_WAIT_DMA,\n\t\tUSBF_XFER_SEND_NULL,\n\t\tUSBF_XFER_WAIT_END,\n\t\tUSBF_XFER_WAIT_DMA_SHORT,\n\t\tUSBF_XFER_WAIT_BRIDGE,\n\t}\t\t\txfer_step;\n\tsize_t\t\t\tdma_size;\n};\n\n \nstruct usbf_ep {\n\tstruct usb_ep\t\tep;\n\tchar\t\t\tname[32];\n\tstruct list_head\tqueue;\n\tunsigned int\t\tis_processing : 1;\n\tunsigned int\t\tis_in : 1;\n\tstruct\t\t\tusbf_udc *udc;\n\tvoid __iomem\t\t*regs;\n\tvoid __iomem\t\t*dma_regs;\n\tunsigned int\t\tid : 8;\n\tunsigned int\t\tdisabled : 1;\n\tunsigned int\t\tis_wedged : 1;\n\tunsigned int\t\tdelayed_status : 1;\n\tu32\t\t\tstatus;\n\tvoid\t\t\t(*bridge_on_dma_end)(struct usbf_ep *ep);\n};\n\nenum usbf_ep0state {\n\tEP0_IDLE,\n\tEP0_IN_DATA_PHASE,\n\tEP0_OUT_DATA_PHASE,\n\tEP0_OUT_STATUS_START_PHASE,\n\tEP0_OUT_STATUS_PHASE,\n\tEP0_OUT_STATUS_END_PHASE,\n\tEP0_IN_STATUS_START_PHASE,\n\tEP0_IN_STATUS_PHASE,\n\tEP0_IN_STATUS_END_PHASE,\n};\n\nstruct usbf_udc {\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\tstruct device\t\t\t*dev;\n\tvoid __iomem\t\t\t*regs;\n\tspinlock_t\t\t\tlock;\n\tbool\t\t\t\tis_remote_wakeup;\n\tbool\t\t\t\tis_usb_suspended;\n\tstruct usbf_ep\t\t\tep[USBF_NUM_ENDPOINTS];\n\t \n\tenum usbf_ep0state\t\tep0state;\n\tstruct usbf_req\t\t\tsetup_reply;\n\tu8\t\t\t\tep0_buf[USBF_EP0_MAX_PCKT_SIZE];\n};\n\nstruct usbf_ep_info {\n\tconst char\t\t*name;\n\tstruct usb_ep_caps\tcaps;\n\tu16\t\t\tbase_addr;\n\tunsigned int\t\tis_double : 1;\n\tu16\t\t\tmaxpacket_limit;\n};\n\n#define USBF_SINGLE_BUFFER 0\n#define USBF_DOUBLE_BUFFER 1\n#define USBF_EP_INFO(_name, _caps, _base_addr, _is_double, _maxpacket_limit)  \\\n\t{                                                                     \\\n\t\t.name            = _name,                                     \\\n\t\t.caps            = _caps,                                     \\\n\t\t.base_addr       = _base_addr,                                \\\n\t\t.is_double       = _is_double,                                \\\n\t\t.maxpacket_limit = _maxpacket_limit,                          \\\n\t}\n\n \nstatic const struct usbf_ep_info usbf_ep_info[USBF_NUM_ENDPOINTS] = {\n\t \n\t[0] = USBF_EP_INFO(\"ep0-ctrl\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0000, USBF_SINGLE_BUFFER, USBF_EP0_MAX_PCKT_SIZE),\n\t \n\t[1] = USBF_EP_INFO(\"ep1-bulk\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0020, USBF_DOUBLE_BUFFER, 512),\n\t \n\t[2] = USBF_EP_INFO(\"ep2-bulk\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0120, USBF_DOUBLE_BUFFER, 512),\n\t \n\t[3] = USBF_EP_INFO(\"ep3-bulk\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0220, USBF_SINGLE_BUFFER, 512),\n\t \n\t[4] = USBF_EP_INFO(\"ep4-bulk\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x02A0, USBF_SINGLE_BUFFER, 512),\n\t \n\t[5] = USBF_EP_INFO(\"ep5-bulk\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0320, USBF_SINGLE_BUFFER, 512),\n\t \n\t[6] = USBF_EP_INFO(\"ep6-int\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x03A0, USBF_SINGLE_BUFFER, 1024),\n\t \n\t[7] = USBF_EP_INFO(\"ep7-int\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x04A0, USBF_SINGLE_BUFFER, 1024),\n\t \n\t[8] = USBF_EP_INFO(\"ep8-int\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0520, USBF_SINGLE_BUFFER, 1024),\n\t \n\t[9] = USBF_EP_INFO(\"ep9-int\",\n\t\t\t   USB_EP_CAPS(USB_EP_CAPS_TYPE_INT,\n\t\t\t\t       USB_EP_CAPS_DIR_ALL),\n\t\t\t   0x0620, USBF_SINGLE_BUFFER, 1024),\n\t \n\t[10] = USBF_EP_INFO(\"ep10-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x0720, USBF_DOUBLE_BUFFER, 1024),\n\t \n\t[11] = USBF_EP_INFO(\"ep11-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x0920, USBF_DOUBLE_BUFFER, 1024),\n\t \n\t[12] = USBF_EP_INFO(\"ep12-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x0B20, USBF_DOUBLE_BUFFER, 1024),\n\t \n\t[13] = USBF_EP_INFO(\"ep13-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x0D20, USBF_DOUBLE_BUFFER, 1024),\n\t \n\t[14] = USBF_EP_INFO(\"ep14-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x0F20, USBF_DOUBLE_BUFFER, 1024),\n\t \n\t[15] = USBF_EP_INFO(\"ep15-iso\",\n\t\t\t    USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t\t    0x1120, USBF_DOUBLE_BUFFER, 1024),\n};\n\nstatic inline u32 usbf_reg_readl(struct usbf_udc *udc, uint offset)\n{\n\treturn readl(udc->regs + offset);\n}\n\nstatic inline void usbf_reg_writel(struct usbf_udc *udc, uint offset, u32 val)\n{\n\twritel(val, udc->regs + offset);\n}\n\nstatic inline void usbf_reg_bitset(struct usbf_udc *udc, uint offset, u32 set)\n{\n\tu32 tmp;\n\n\ttmp = usbf_reg_readl(udc, offset);\n\ttmp |= set;\n\tusbf_reg_writel(udc, offset, tmp);\n}\n\nstatic inline void usbf_reg_bitclr(struct usbf_udc *udc, uint offset, u32 clr)\n{\n\tu32 tmp;\n\n\ttmp = usbf_reg_readl(udc, offset);\n\ttmp &= ~clr;\n\tusbf_reg_writel(udc, offset, tmp);\n}\n\nstatic inline void usbf_reg_clrset(struct usbf_udc *udc, uint offset,\n\t\t\t\t   u32 clr, u32 set)\n{\n\tu32 tmp;\n\n\ttmp = usbf_reg_readl(udc, offset);\n\ttmp &= ~clr;\n\ttmp |= set;\n\tusbf_reg_writel(udc, offset, tmp);\n}\n\nstatic inline u32 usbf_ep_reg_readl(struct usbf_ep *ep, uint offset)\n{\n\treturn readl(ep->regs + offset);\n}\n\nstatic inline void usbf_ep_reg_read_rep(struct usbf_ep *ep, uint offset,\n\t\t\t\t       void *dst, uint count)\n{\n\treadsl(ep->regs + offset, dst, count);\n}\n\nstatic inline void usbf_ep_reg_writel(struct usbf_ep *ep, uint offset, u32 val)\n{\n\twritel(val, ep->regs + offset);\n}\n\nstatic inline void usbf_ep_reg_write_rep(struct usbf_ep *ep, uint offset,\n\t\t\t\t\t const void *src, uint count)\n{\n\twritesl(ep->regs + offset, src, count);\n}\n\nstatic inline void usbf_ep_reg_bitset(struct usbf_ep *ep, uint offset, u32 set)\n{\n\tu32 tmp;\n\n\ttmp = usbf_ep_reg_readl(ep, offset);\n\ttmp |= set;\n\tusbf_ep_reg_writel(ep, offset, tmp);\n}\n\nstatic inline void usbf_ep_reg_bitclr(struct usbf_ep *ep, uint offset, u32 clr)\n{\n\tu32 tmp;\n\n\ttmp = usbf_ep_reg_readl(ep, offset);\n\ttmp &= ~clr;\n\tusbf_ep_reg_writel(ep, offset, tmp);\n}\n\nstatic inline void usbf_ep_reg_clrset(struct usbf_ep *ep, uint offset,\n\t\t\t\t      u32 clr, u32 set)\n{\n\tu32 tmp;\n\n\ttmp = usbf_ep_reg_readl(ep, offset);\n\ttmp &= ~clr;\n\ttmp |= set;\n\tusbf_ep_reg_writel(ep, offset, tmp);\n}\n\nstatic inline u32 usbf_ep_dma_reg_readl(struct usbf_ep *ep, uint offset)\n{\n\treturn readl(ep->dma_regs + offset);\n}\n\nstatic inline void usbf_ep_dma_reg_writel(struct usbf_ep *ep, uint offset,\n\t\t\t\t\t  u32 val)\n{\n\twritel(val, ep->dma_regs + offset);\n}\n\nstatic inline void usbf_ep_dma_reg_bitset(struct usbf_ep *ep, uint offset,\n\t\t\t\t\t  u32 set)\n{\n\tu32 tmp;\n\n\ttmp = usbf_ep_dma_reg_readl(ep, offset);\n\ttmp |= set;\n\tusbf_ep_dma_reg_writel(ep, offset, tmp);\n}\n\nstatic inline void usbf_ep_dma_reg_bitclr(struct usbf_ep *ep, uint offset,\n\t\t\t\t\t  u32 clr)\n{\n\tu32 tmp;\n\n\ttmp = usbf_ep_dma_reg_readl(ep, offset);\n\ttmp &= ~clr;\n\tusbf_ep_dma_reg_writel(ep, offset, tmp);\n}\n\nstatic void usbf_ep0_send_null(struct usbf_ep *ep0, bool is_data1)\n{\n\tu32 set;\n\n\tset = USBF_EP0_DEND;\n\tif (is_data1)\n\t\tset |= USBF_EP0_PIDCLR;\n\n\tusbf_ep_reg_bitset(ep0, USBF_REG_EP0_CONTROL, set);\n}\n\nstatic int usbf_ep0_pio_in(struct usbf_ep *ep0, struct usbf_req *req)\n{\n\tunsigned int left;\n\tunsigned int nb;\n\tconst void *buf;\n\tu32 ctrl;\n\tu32 last;\n\n\tleft = req->req.length - req->req.actual;\n\n\tif (left == 0) {\n\t\tif (!req->is_zero_sent) {\n\t\t\tif (req->req.length == 0) {\n\t\t\t\tdev_dbg(ep0->udc->dev, \"ep0 send null\\n\");\n\t\t\t\tusbf_ep0_send_null(ep0, false);\n\t\t\t\treq->is_zero_sent = 1;\n\t\t\t\treturn -EINPROGRESS;\n\t\t\t}\n\t\t\tif ((req->req.actual % ep0->ep.maxpacket) == 0) {\n\t\t\t\tif (req->req.zero) {\n\t\t\t\t\tdev_dbg(ep0->udc->dev, \"ep0 send null\\n\");\n\t\t\t\t\tusbf_ep0_send_null(ep0, false);\n\t\t\t\t\treq->is_zero_sent = 1;\n\t\t\t\t\treturn -EINPROGRESS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (left > ep0->ep.maxpacket)\n\t\tleft = ep0->ep.maxpacket;\n\n\tbuf = req->req.buf;\n\tbuf += req->req.actual;\n\n\tnb = left / sizeof(u32);\n\tif (nb) {\n\t\tusbf_ep_reg_write_rep(ep0, USBF_REG_EP0_WRITE, buf, nb);\n\t\tbuf += (nb * sizeof(u32));\n\t\treq->req.actual += (nb * sizeof(u32));\n\t\tleft -= (nb * sizeof(u32));\n\t}\n\tctrl = usbf_ep_reg_readl(ep0, USBF_REG_EP0_CONTROL);\n\tctrl &= ~USBF_EP0_DW_MASK;\n\tif (left) {\n\t\tmemcpy(&last, buf, left);\n\t\tusbf_ep_reg_writel(ep0, USBF_REG_EP0_WRITE, last);\n\t\tctrl |= USBF_EP0_DW(left);\n\t\treq->req.actual += left;\n\t}\n\tusbf_ep_reg_writel(ep0, USBF_REG_EP0_CONTROL, ctrl | USBF_EP0_DEND);\n\n\tdev_dbg(ep0->udc->dev, \"ep0 send %u/%u\\n\",\n\t\treq->req.actual, req->req.length);\n\n\treturn -EINPROGRESS;\n}\n\nstatic int usbf_ep0_pio_out(struct usbf_ep *ep0, struct usbf_req *req)\n{\n\tint req_status = 0;\n\tunsigned int count;\n\tunsigned int recv;\n\tunsigned int left;\n\tunsigned int nb;\n\tvoid *buf;\n\tu32 last;\n\n\tif (ep0->status & USBF_EP0_OUT_INT) {\n\t\trecv = usbf_ep_reg_readl(ep0, USBF_REG_EP0_LENGTH) & USBF_EP0_LDATA;\n\t\tcount = recv;\n\n\t\tbuf = req->req.buf;\n\t\tbuf += req->req.actual;\n\n\t\tleft = req->req.length - req->req.actual;\n\n\t\tdev_dbg(ep0->udc->dev, \"ep0 recv %u, left %u\\n\", count, left);\n\n\t\tif (left > ep0->ep.maxpacket)\n\t\t\tleft = ep0->ep.maxpacket;\n\n\t\tif (count > left) {\n\t\t\treq_status = -EOVERFLOW;\n\t\t\tcount = left;\n\t\t}\n\n\t\tif (count) {\n\t\t\tnb = count / sizeof(u32);\n\t\t\tif (nb) {\n\t\t\t\tusbf_ep_reg_read_rep(ep0, USBF_REG_EP0_READ,\n\t\t\t\t\tbuf, nb);\n\t\t\t\tbuf += (nb * sizeof(u32));\n\t\t\t\treq->req.actual += (nb * sizeof(u32));\n\t\t\t\tcount -= (nb * sizeof(u32));\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tlast = usbf_ep_reg_readl(ep0, USBF_REG_EP0_READ);\n\t\t\t\tmemcpy(buf, &last, count);\n\t\t\t\treq->req.actual += count;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(ep0->udc->dev, \"ep0 recv %u/%u\\n\",\n\t\t\treq->req.actual, req->req.length);\n\n\t\tif (req_status) {\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 req.status=%d\\n\", req_status);\n\t\t\treq->req.status = req_status;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (recv < ep0->ep.maxpacket) {\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 short packet\\n\");\n\t\t\t \n\t\t\treq->req.status = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (req->req.actual == req->req.length) {\n\t\t\treq->req.status = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (ep0->status & USBF_EP0_OUT_NULL_INT) {\n\t\t \n\t\tdev_dbg(ep0->udc->dev, \"ep0 null packet\\n\");\n\t\tif (req->req.actual != req->req.length) {\n\t\t\treq->req.status = req->req.short_not_ok ?\n\t\t\t\t\t  -EREMOTEIO : 0;\n\t\t} else {\n\t\t\treq->req.status = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void usbf_ep0_fifo_flush(struct usbf_ep *ep0)\n{\n\tu32 sts;\n\tint ret;\n\n\tusbf_ep_reg_bitset(ep0, USBF_REG_EP0_CONTROL, USBF_EP0_BCLR);\n\n\tret = readl_poll_timeout_atomic(ep0->regs + USBF_REG_EP0_STATUS, sts,\n\t\t(sts & (USBF_EP0_IN_DATA | USBF_EP0_IN_EMPTY)) == USBF_EP0_IN_EMPTY,\n\t\t0,  10000);\n\tif (ret)\n\t\tdev_err(ep0->udc->dev, \"ep0 flush fifo timed out\\n\");\n\n}\n\nstatic void usbf_epn_send_null(struct usbf_ep *epn)\n{\n\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_CONTROL, USBF_EPN_DEND);\n}\n\nstatic void usbf_epn_send_residue(struct usbf_ep *epn, const void *buf,\n\t\t\t\t  unsigned int size)\n{\n\tu32 tmp;\n\n\tmemcpy(&tmp, buf, size);\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_WRITE, tmp);\n\n\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_DW_MASK,\n\t\t\t\tUSBF_EPN_DW(size) | USBF_EPN_DEND);\n}\n\nstatic int usbf_epn_pio_in(struct usbf_ep *epn, struct usbf_req *req)\n{\n\tunsigned int left;\n\tunsigned int nb;\n\tconst void *buf;\n\n\tleft = req->req.length - req->req.actual;\n\n\tif (left == 0) {\n\t\tif (!req->is_zero_sent) {\n\t\t\tif (req->req.length == 0) {\n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u send_null\\n\", epn->id);\n\t\t\t\tusbf_epn_send_null(epn);\n\t\t\t\treq->is_zero_sent = 1;\n\t\t\t\treturn -EINPROGRESS;\n\t\t\t}\n\t\t\tif ((req->req.actual % epn->ep.maxpacket) == 0) {\n\t\t\t\tif (req->req.zero) {\n\t\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u send_null\\n\",\n\t\t\t\t\t\tepn->id);\n\t\t\t\t\tusbf_epn_send_null(epn);\n\t\t\t\t\treq->is_zero_sent = 1;\n\t\t\t\t\treturn -EINPROGRESS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (left > epn->ep.maxpacket)\n\t\tleft = epn->ep.maxpacket;\n\n\tbuf = req->req.buf;\n\tbuf += req->req.actual;\n\n\tnb = left / sizeof(u32);\n\tif (nb) {\n\t\tusbf_ep_reg_write_rep(epn, USBF_REG_EPN_WRITE, buf, nb);\n\t\tbuf += (nb * sizeof(u32));\n\t\treq->req.actual += (nb * sizeof(u32));\n\t\tleft -= (nb * sizeof(u32));\n\t}\n\n\tif (left) {\n\t\tusbf_epn_send_residue(epn, buf, left);\n\t\treq->req.actual += left;\n\t} else {\n\t\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_CONTROL,\n\t\t\t\t\tUSBF_EPN_DW_MASK,\n\t\t\t\t\tUSBF_EPN_DEND);\n\t}\n\n\tdev_dbg(epn->udc->dev, \"ep%u send %u/%u\\n\", epn->id, req->req.actual,\n\t\treq->req.length);\n\n\treturn -EINPROGRESS;\n}\n\nstatic void usbf_epn_enable_in_end_int(struct usbf_ep *epn)\n{\n\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_INT_ENA, USBF_EPN_IN_END_EN);\n}\n\nstatic int usbf_epn_dma_in(struct usbf_ep *epn, struct usbf_req *req)\n{\n\tunsigned int left;\n\tu32 npkt;\n\tu32 lastpkt;\n\tint ret;\n\n\tif (!IS_ALIGNED((uintptr_t)req->req.buf, 4)) {\n\t\tdev_dbg(epn->udc->dev, \"ep%u buf unaligned -> fallback pio\\n\",\n\t\t\tepn->id);\n\t\treturn usbf_epn_pio_in(epn, req);\n\t}\n\n\tleft = req->req.length - req->req.actual;\n\n\tswitch (req->xfer_step) {\n\tdefault:\n\tcase USBF_XFER_START:\n\t\tif (left == 0) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u send null\\n\", epn->id);\n\t\t\tusbf_epn_send_null(epn);\n\t\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\t\tbreak;\n\t\t}\n\t\tif (left < 4) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u send residue %u\\n\", epn->id,\n\t\t\t\tleft);\n\t\t\tusbf_epn_send_residue(epn,\n\t\t\t\treq->req.buf + req->req.actual, left);\n\t\t\treq->req.actual += left;\n\t\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = usb_gadget_map_request(&epn->udc->gadget, &req->req, 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(epn->udc->dev, \"usb_gadget_map_request failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\treq->is_mapped = 1;\n\n\t\tnpkt = DIV_ROUND_UP(left, epn->ep.maxpacket);\n\t\tlastpkt = (left % epn->ep.maxpacket);\n\t\tif (lastpkt == 0)\n\t\t\tlastpkt = epn->ep.maxpacket;\n\t\tlastpkt &= ~0x3;  \n\n\t\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_DCR2,\n\t\t\tUSBF_SYS_EPN_MPKT(epn->ep.maxpacket) | USBF_SYS_EPN_LMPKT(lastpkt));\n\t\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_TADR,\n\t\t\treq->req.dma);\n\t\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_DCR1,\n\t\t\tUSBF_SYS_EPN_SET_DMACNT(npkt));\n\t\tusbf_ep_dma_reg_bitset(epn, USBF_REG_DMA_EPN_DCR1,\n\t\t\tUSBF_SYS_EPN_REQEN);\n\n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_LEN_DCNT, USBF_EPN_SET_DMACNT(npkt));\n\n\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_CONTROL, USBF_EPN_AUTO);\n\n\t\t \n\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_IN_EN | USBF_EPN_IN_END_EN);\n\t\tepn->bridge_on_dma_end = usbf_epn_enable_in_end_int;\n\n\t\t \n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS, ~(u32)USBF_EPN_IN_END_INT);\n\n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_DMA_CTRL,\n\t\t\tUSBF_EPN_BURST_SET | USBF_EPN_DMAMODE0);\n\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_DMA_CTRL,\n\t\t\tUSBF_EPN_DMA_EN);\n\n\t\treq->dma_size = (npkt - 1) * epn->ep.maxpacket + lastpkt;\n\n\t\tdev_dbg(epn->udc->dev, \"ep%u dma xfer %zu\\n\", epn->id,\n\t\t\treq->dma_size);\n\n\t\treq->xfer_step = USBF_XFER_WAIT_DMA;\n\t\tbreak;\n\n\tcase USBF_XFER_WAIT_DMA:\n\t\tif (!(epn->status & USBF_EPN_IN_END_INT)) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma not done\\n\", epn->id);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u dma done\\n\", epn->id);\n\n\t\tusb_gadget_unmap_request(&epn->udc->gadget, &req->req, 1);\n\t\treq->is_mapped = 0;\n\n\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_CONTROL, USBF_EPN_AUTO);\n\n\t\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_IN_END_EN,\n\t\t\tUSBF_EPN_IN_EN);\n\n\t\treq->req.actual += req->dma_size;\n\n\t\tleft = req->req.length - req->req.actual;\n\t\tif (left) {\n\t\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS, ~(u32)USBF_EPN_IN_INT);\n\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u send residue %u\\n\", epn->id,\n\t\t\t\tleft);\n\t\t\tusbf_epn_send_residue(epn,\n\t\t\t\treq->req.buf + req->req.actual, left);\n\t\t\treq->req.actual += left;\n\t\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req->req.actual % epn->ep.maxpacket) {\n\t\t\t \n\t\t\tdev_dbg(epn->udc->dev, \"ep%u send short\\n\", epn->id);\n\t\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS,\n\t\t\t\t~(u32)USBF_EPN_IN_INT);\n\t\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_DEND);\n\n\t\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (req->req.zero) {\n\t\t\treq->xfer_step = USBF_XFER_SEND_NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\tbreak;\n\n\tcase USBF_XFER_SEND_NULL:\n\t\tdev_dbg(epn->udc->dev, \"ep%u send null\\n\", epn->id);\n\t\tusbf_epn_send_null(epn);\n\t\treq->xfer_step = USBF_XFER_WAIT_END;\n\t\tbreak;\n\n\tcase USBF_XFER_WAIT_END:\n\t\tif (!(epn->status & USBF_EPN_IN_INT)) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u end not done\\n\", epn->id);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u send done %u/%u\\n\", epn->id,\n\t\t\treq->req.actual, req->req.length);\n\t\treq->xfer_step = USBF_XFER_START;\n\t\treturn 0;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void usbf_epn_recv_residue(struct usbf_ep *epn, void *buf,\n\t\t\t\t  unsigned int size)\n{\n\tu32 last;\n\n\tlast = usbf_ep_reg_readl(epn, USBF_REG_EPN_READ);\n\tmemcpy(buf, &last, size);\n}\n\nstatic int usbf_epn_pio_out(struct usbf_ep *epn, struct usbf_req *req)\n{\n\tint req_status = 0;\n\tunsigned int count;\n\tunsigned int recv;\n\tunsigned int left;\n\tunsigned int nb;\n\tvoid *buf;\n\n\tif (epn->status & USBF_EPN_OUT_INT) {\n\t\trecv = USBF_EPN_GET_LDATA(\n\t\t\tusbf_ep_reg_readl(epn, USBF_REG_EPN_LEN_DCNT));\n\t\tcount = recv;\n\n\t\tbuf = req->req.buf;\n\t\tbuf += req->req.actual;\n\n\t\tleft = req->req.length - req->req.actual;\n\n\t\tdev_dbg(epn->udc->dev, \"ep%u recv %u, left %u, mpkt %u\\n\", epn->id,\n\t\t\trecv, left, epn->ep.maxpacket);\n\n\t\tif (left > epn->ep.maxpacket)\n\t\t\tleft = epn->ep.maxpacket;\n\n\t\tif (count > left) {\n\t\t\treq_status = -EOVERFLOW;\n\t\t\tcount = left;\n\t\t}\n\n\t\tif (count) {\n\t\t\tnb = count / sizeof(u32);\n\t\t\tif (nb) {\n\t\t\t\tusbf_ep_reg_read_rep(epn, USBF_REG_EPN_READ,\n\t\t\t\t\tbuf, nb);\n\t\t\t\tbuf += (nb * sizeof(u32));\n\t\t\t\treq->req.actual += (nb * sizeof(u32));\n\t\t\t\tcount -= (nb * sizeof(u32));\n\t\t\t}\n\t\t\tif (count) {\n\t\t\t\tusbf_epn_recv_residue(epn, buf, count);\n\t\t\t\treq->req.actual += count;\n\t\t\t}\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u recv %u/%u\\n\", epn->id,\n\t\t\treq->req.actual, req->req.length);\n\n\t\tif (req_status) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u req.status=%d\\n\", epn->id,\n\t\t\t\treq_status);\n\t\t\treq->req.status = req_status;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (recv < epn->ep.maxpacket) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u short packet\\n\", epn->id);\n\t\t\t \n\t\t\treq->req.status = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (req->req.actual == req->req.length) {\n\t\t\treq->req.status = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (epn->status & USBF_EPN_OUT_NULL_INT) {\n\t\t \n\t\tdev_dbg(epn->udc->dev, \"ep%u null packet\\n\", epn->id);\n\t\tif (req->req.actual != req->req.length) {\n\t\t\treq->req.status = req->req.short_not_ok ?\n\t\t\t\t\t  -EREMOTEIO : 0;\n\t\t} else {\n\t\t\treq->req.status = 0;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void usbf_epn_enable_out_end_int(struct usbf_ep *epn)\n{\n\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_INT_ENA, USBF_EPN_OUT_END_EN);\n}\n\nstatic void usbf_epn_process_queue(struct usbf_ep *epn);\n\nstatic void usbf_epn_dma_out_send_dma(struct usbf_ep *epn, dma_addr_t addr, u32 npkt, bool is_short)\n{\n\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_DCR2, USBF_SYS_EPN_MPKT(epn->ep.maxpacket));\n\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_TADR, addr);\n\n\tif (is_short) {\n\t\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_DCR1,\n\t\t\t\tUSBF_SYS_EPN_SET_DMACNT(1) | USBF_SYS_EPN_DIR0);\n\t\tusbf_ep_dma_reg_bitset(epn, USBF_REG_DMA_EPN_DCR1,\n\t\t\t\tUSBF_SYS_EPN_REQEN);\n\n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_LEN_DCNT,\n\t\t\t\tUSBF_EPN_SET_DMACNT(0));\n\n\t\t \n\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN | USBF_EPN_OUT_END_EN);\n\t\tepn->bridge_on_dma_end = usbf_epn_enable_out_end_int;\n\n\t\t \n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS,\n\t\t\t~(u32)USBF_EPN_OUT_END_INT);\n\n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_DMA_CTRL,\n\t\t\tUSBF_EPN_STOP_MODE | USBF_EPN_STOP_SET | USBF_EPN_DMAMODE0);\n\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_DMA_CTRL,\n\t\t\tUSBF_EPN_DMA_EN);\n\t\treturn;\n\t}\n\n\tusbf_ep_dma_reg_writel(epn, USBF_REG_DMA_EPN_DCR1,\n\t\tUSBF_SYS_EPN_SET_DMACNT(npkt) | USBF_SYS_EPN_DIR0);\n\tusbf_ep_dma_reg_bitset(epn, USBF_REG_DMA_EPN_DCR1,\n\t\tUSBF_SYS_EPN_REQEN);\n\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_LEN_DCNT,\n\t\tUSBF_EPN_SET_DMACNT(npkt));\n\n\t \n\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\tUSBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN,\n\t\tUSBF_EPN_OUT_END_EN);\n\n\t \n\tusbf_reg_bitclr(epn->udc, USBF_REG_AHBBINTEN,\n\t\tUSBF_SYS_DMA_ENDINTEN_EPN(epn->id));\n\n\t \n\tusbf_reg_writel(epn->udc, USBF_REG_AHBBINT,\n\t\tUSBF_SYS_DMA_ENDINT_EPN(epn->id));\n\n\t \n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS,\n\t\t~(u32)USBF_EPN_OUT_END_INT);\n\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_DMA_CTRL,\n\t\tUSBF_EPN_STOP_MODE | USBF_EPN_STOP_SET | USBF_EPN_DMAMODE0 | USBF_EPN_BURST_SET);\n\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_DMA_CTRL,\n\t\tUSBF_EPN_DMA_EN);\n}\n\nstatic size_t usbf_epn_dma_out_complete_dma(struct usbf_ep *epn, bool is_short)\n{\n\tu32 dmacnt;\n\tu32 tmp;\n\tint ret;\n\n\t \n\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\tUSBF_EPN_OUT_END_EN,\n\t\tUSBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN);\n\n\tif (is_short) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tusbf_reg_bitset(epn->udc, USBF_REG_AHBBINTEN,\n\t\tUSBF_SYS_DMA_ENDINTEN_EPN(epn->id));\n\n\ttmp = usbf_ep_reg_readl(epn, USBF_REG_EPN_LEN_DCNT);\n\tdmacnt = USBF_EPN_GET_DMACNT(tmp);\n\n\tif (dmacnt) {\n\t\t \n\t\tret = readl_poll_timeout_atomic(\n\t\t\tepn->dma_regs + USBF_REG_DMA_EPN_DCR1,\n\t\t\ttmp, (USBF_SYS_EPN_GET_DMACNT(tmp) == dmacnt),\n\t\t\t0,  10000);\n\t\tif (ret) {\n\t\t\tdev_err(epn->udc->dev, \"ep%u wait bridge timed out\\n\",\n\t\t\t\tepn->id);\n\t\t}\n\n\t\tusbf_ep_dma_reg_bitclr(epn, USBF_REG_DMA_EPN_DCR1,\n\t\t\tUSBF_SYS_EPN_REQEN);\n\n\t\t \n\t\treturn dmacnt * epn->ep.maxpacket;\n\t}\n\n\treturn 0;\n}\n\nstatic int usbf_epn_dma_out(struct usbf_ep *epn, struct usbf_req *req)\n{\n\tunsigned int dma_left;\n\tunsigned int count;\n\tunsigned int recv;\n\tunsigned int left;\n\tu32 npkt;\n\tint ret;\n\n\tif (!IS_ALIGNED((uintptr_t)req->req.buf, 4)) {\n\t\tdev_dbg(epn->udc->dev, \"ep%u buf unaligned -> fallback pio\\n\",\n\t\t\tepn->id);\n\t\treturn usbf_epn_pio_out(epn, req);\n\t}\n\n\tswitch (req->xfer_step) {\n\tdefault:\n\tcase USBF_XFER_START:\n\t\tif (epn->status & USBF_EPN_OUT_NULL_INT) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u null packet\\n\", epn->id);\n\t\t\tif (req->req.actual != req->req.length) {\n\t\t\t\treq->req.status = req->req.short_not_ok ?\n\t\t\t\t\t-EREMOTEIO : 0;\n\t\t\t} else {\n\t\t\t\treq->req.status = 0;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!(epn->status & USBF_EPN_OUT_INT)) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u OUT_INT not set -> spurious\\n\",\n\t\t\t\tepn->id);\n\t\t\tbreak;\n\t\t}\n\n\t\trecv = USBF_EPN_GET_LDATA(\n\t\t\tusbf_ep_reg_readl(epn, USBF_REG_EPN_LEN_DCNT));\n\t\tif (!recv) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv = 0 -> spurious\\n\",\n\t\t\t\tepn->id);\n\t\t\tbreak;\n\t\t}\n\n\t\tleft = req->req.length - req->req.actual;\n\n\t\tdev_dbg(epn->udc->dev, \"ep%u recv %u, left %u, mpkt %u\\n\", epn->id,\n\t\t\trecv, left, epn->ep.maxpacket);\n\n\t\tif (recv > left) {\n\t\t\tdev_err(epn->udc->dev, \"ep%u overflow (%u/%u)\\n\",\n\t\t\t\tepn->id, recv, left);\n\t\t\treq->req.status = -EOVERFLOW;\n\t\t\treturn -EOVERFLOW;\n\t\t}\n\n\t\tif (recv < epn->ep.maxpacket) {\n\t\t\t \n\t\t\tdev_dbg(epn->udc->dev, \"ep%u short packet\\n\", epn->id);\n\t\t\tif (recv <= 3) {\n\t\t\t\tusbf_epn_recv_residue(epn,\n\t\t\t\t\treq->req.buf + req->req.actual, recv);\n\t\t\t\treq->req.actual += recv;\n\n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u\\n\",\n\t\t\t\t\tepn->id, req->req.actual, req->req.length);\n\n\t\t\t\treq->xfer_step = USBF_XFER_START;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tret = usb_gadget_map_request(&epn->udc->gadget, &req->req, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(epn->udc->dev, \"map request failed (%d)\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treq->is_mapped = 1;\n\n\t\t\tusbf_epn_dma_out_send_dma(epn,\n\t\t\t\treq->req.dma + req->req.actual,\n\t\t\t\t1, true);\n\t\t\treq->dma_size = recv & ~0x3;\n\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma short xfer %zu\\n\", epn->id,\n\t\t\t\treq->dma_size);\n\n\t\t\treq->xfer_step = USBF_XFER_WAIT_DMA_SHORT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = usb_gadget_map_request(&epn->udc->gadget, &req->req, 0);\n\t\tif (ret < 0) {\n\t\t\tdev_err(epn->udc->dev, \"map request failed (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t\treq->is_mapped = 1;\n\n\t\t \n\t\tnpkt = left / epn->ep.maxpacket;\n\t\tusbf_epn_dma_out_send_dma(epn,\n\t\t\t\treq->req.dma + req->req.actual,\n\t\t\t\tnpkt, false);\n\t\treq->dma_size = npkt * epn->ep.maxpacket;\n\n\t\tdev_dbg(epn->udc->dev, \"ep%u dma xfer %zu (%u)\\n\", epn->id,\n\t\t\treq->dma_size, npkt);\n\n\t\treq->xfer_step = USBF_XFER_WAIT_DMA;\n\t\tbreak;\n\n\tcase USBF_XFER_WAIT_DMA_SHORT:\n\t\tif (!(epn->status & USBF_EPN_OUT_END_INT)) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma short not done\\n\", epn->id);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u dma short done\\n\", epn->id);\n\n\t\tusbf_epn_dma_out_complete_dma(epn, true);\n\n\t\tusb_gadget_unmap_request(&epn->udc->gadget, &req->req, 0);\n\t\treq->is_mapped = 0;\n\n\t\treq->req.actual += req->dma_size;\n\n\t\trecv = USBF_EPN_GET_LDATA(\n\t\t\tusbf_ep_reg_readl(epn, USBF_REG_EPN_LEN_DCNT));\n\n\t\tcount = recv & 0x3;\n\t\tif (count) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv residue %u\\n\", epn->id,\n\t\t\t\tcount);\n\t\t\tusbf_epn_recv_residue(epn,\n\t\t\t\treq->req.buf + req->req.actual, count);\n\t\t\treq->req.actual += count;\n\t\t}\n\n\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u\\n\", epn->id,\n\t\t\treq->req.actual, req->req.length);\n\n\t\treq->xfer_step = USBF_XFER_START;\n\t\treturn 0;\n\n\tcase USBF_XFER_WAIT_DMA:\n\t\tif (!(epn->status & USBF_EPN_OUT_END_INT)) {\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma not done\\n\", epn->id);\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u dma done\\n\", epn->id);\n\n\t\tdma_left = usbf_epn_dma_out_complete_dma(epn, false);\n\t\tif (dma_left) {\n\t\t\t \n\t\t\tcount = req->dma_size - dma_left;\n\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma xfer done %u\\n\", epn->id,\n\t\t\t\tcount);\n\n\t\t\treq->req.actual += count;\n\n\t\t\tif (epn->status & USBF_EPN_OUT_NULL_INT) {\n\t\t\t\t \n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma stopped by null pckt\\n\",\n\t\t\t\t\tepn->id);\n\t\t\t\tusb_gadget_unmap_request(&epn->udc->gadget,\n\t\t\t\t\t\t\t &req->req, 0);\n\t\t\t\treq->is_mapped = 0;\n\n\t\t\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS,\n\t\t\t\t\t~(u32)USBF_EPN_OUT_NULL_INT);\n\n\t\t\t\tif (req->req.actual != req->req.length) {\n\t\t\t\t\treq->req.status = req->req.short_not_ok ?\n\t\t\t\t\t\t  -EREMOTEIO : 0;\n\t\t\t\t} else {\n\t\t\t\t\treq->req.status = 0;\n\t\t\t\t}\n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u\\n\",\n\t\t\t\t\tepn->id, req->req.actual, req->req.length);\n\t\t\t\treq->xfer_step = USBF_XFER_START;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\trecv = USBF_EPN_GET_LDATA(\n\t\t\t\tusbf_ep_reg_readl(epn, USBF_REG_EPN_LEN_DCNT));\n\t\t\tleft = req->req.length - req->req.actual;\n\t\t\tif (recv > left) {\n\t\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\t\"ep%u overflow (%u/%u)\\n\", epn->id,\n\t\t\t\t\trecv, left);\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\tusb_gadget_unmap_request(&epn->udc->gadget,\n\t\t\t\t\t\t\t &req->req, 0);\n\t\t\t\treq->is_mapped = 0;\n\n\t\t\t\treq->xfer_step = USBF_XFER_START;\n\t\t\t\treturn -EOVERFLOW;\n\t\t\t}\n\n\t\t\tif (recv > 3) {\n\t\t\t\tusbf_epn_dma_out_send_dma(epn,\n\t\t\t\t\treq->req.dma + req->req.actual,\n\t\t\t\t\t1, true);\n\t\t\t\treq->dma_size = recv & ~0x3;\n\n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u dma short xfer %zu\\n\",\n\t\t\t\t\tepn->id, req->dma_size);\n\n\t\t\t\treq->xfer_step = USBF_XFER_WAIT_DMA_SHORT;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tusb_gadget_unmap_request(&epn->udc->gadget, &req->req, 0);\n\t\t\treq->is_mapped = 0;\n\n\t\t\tcount = recv & 0x3;\n\t\t\tif (count) {\n\t\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv residue %u\\n\",\n\t\t\t\t\tepn->id, count);\n\t\t\t\tusbf_epn_recv_residue(epn,\n\t\t\t\t\treq->req.buf + req->req.actual, count);\n\t\t\t\treq->req.actual += count;\n\t\t\t}\n\n\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u\\n\", epn->id,\n\t\t\t\treq->req.actual, req->req.length);\n\n\t\t\treq->xfer_step = USBF_XFER_START;\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_OUT_END_EN | USBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN);\n\t\tepn->status = 0;\n\t\tepn->bridge_on_dma_end = usbf_epn_process_queue;\n\n\t\treq->xfer_step = USBF_XFER_WAIT_BRIDGE;\n\t\tbreak;\n\n\tcase USBF_XFER_WAIT_BRIDGE:\n\t\tdev_dbg(epn->udc->dev, \"ep%u bridge transfers done\\n\", epn->id);\n\n\t\t \n\t\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_OUT_END_EN,\n\t\t\tUSBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN);\n\n\t\tusb_gadget_unmap_request(&epn->udc->gadget, &req->req, 0);\n\t\treq->is_mapped = 0;\n\n\t\treq->req.actual += req->dma_size;\n\n\t\treq->xfer_step = USBF_XFER_START;\n\t\tleft = req->req.length - req->req.actual;\n\t\tif (!left) {\n\t\t\t \n\t\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u\\n\", epn->id,\n\t\t\t\treq->req.actual, req->req.length);\n\t\t\treturn 0;\n\t\t}\n\t\tdev_dbg(epn->udc->dev, \"ep%u recv done %u/%u, wait more data\\n\",\n\t\t\tepn->id, req->req.actual, req->req.length);\n\t\tbreak;\n\t}\n\n\treturn -EINPROGRESS;\n}\n\nstatic void usbf_epn_dma_stop(struct usbf_ep *epn)\n{\n\tusbf_ep_dma_reg_bitclr(epn, USBF_REG_DMA_EPN_DCR1, USBF_SYS_EPN_REQEN);\n\n\t \n\tmdelay(10);\n\n\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_DMA_CTRL, USBF_EPN_DMA_EN);\n}\n\nstatic void usbf_epn_dma_abort(struct usbf_ep *epn,  struct usbf_req *req)\n{\n\tdev_dbg(epn->udc->dev, \"ep%u %s dma abort\\n\", epn->id,\n\t\tepn->is_in ? \"in\" : \"out\");\n\n\tepn->bridge_on_dma_end = NULL;\n\n\tusbf_epn_dma_stop(epn);\n\n\tusb_gadget_unmap_request(&epn->udc->gadget, &req->req,\n\t\t\t\t epn->is_in ? 1 : 0);\n\treq->is_mapped = 0;\n\n\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_CONTROL, USBF_EPN_AUTO);\n\n\tif (epn->is_in) {\n\t\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_IN_END_EN,\n\t\t\tUSBF_EPN_IN_EN);\n\t} else {\n\t\tusbf_ep_reg_clrset(epn, USBF_REG_EPN_INT_ENA,\n\t\t\tUSBF_EPN_OUT_END_EN,\n\t\t\tUSBF_EPN_OUT_EN | USBF_EPN_OUT_NULL_EN);\n\t}\n\n\t \n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS,\n\t\tUSBF_EPN_IN_END_INT | USBF_EPN_OUT_END_INT);\n\n\tusbf_reg_writel(epn->udc, USBF_REG_AHBBINT, USBF_SYS_DMA_ENDINT_EPN(epn->id));\n\n\t \n\tusbf_reg_bitset(epn->udc, USBF_REG_AHBBINTEN,\n\t\tUSBF_SYS_DMA_ENDINTEN_EPN(epn->id));\n\n\t \n\treq->xfer_step = USBF_XFER_START;\n}\n\nstatic void usbf_epn_fifo_flush(struct usbf_ep *epn)\n{\n\tu32 ctrl;\n\tu32 sts;\n\tint ret;\n\n\tdev_dbg(epn->udc->dev, \"ep%u %s fifo flush\\n\", epn->id,\n\t\tepn->is_in ? \"in\" : \"out\");\n\n\tctrl = usbf_ep_reg_readl(epn, USBF_REG_EPN_CONTROL);\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_CONTROL, ctrl | USBF_EPN_BCLR);\n\n\tif (ctrl & USBF_EPN_DIR0)\n\t\treturn;\n\n\tret = readl_poll_timeout_atomic(epn->regs + USBF_REG_EPN_STATUS, sts,\n\t\t(sts & (USBF_EPN_IN_DATA | USBF_EPN_IN_EMPTY)) == USBF_EPN_IN_EMPTY,\n\t\t0,  10000);\n\tif (ret)\n\t\tdev_err(epn->udc->dev, \"ep%u flush fifo timed out\\n\", epn->id);\n}\n\nstatic void usbf_ep_req_done(struct usbf_ep *ep, struct usbf_req *req,\n\t\t\t     int status)\n{\n\tlist_del_init(&req->queue);\n\n\tif (status) {\n\t\treq->req.status = status;\n\t} else {\n\t\tif (req->req.status == -EINPROGRESS)\n\t\t\treq->req.status = status;\n\t}\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s req done length %u/%u, status=%d\\n\", ep->id,\n\t\tep->is_in ? \"in\" : \"out\",\n\t\treq->req.actual, req->req.length, req->req.status);\n\n\tif (req->is_mapped)\n\t\tusbf_epn_dma_abort(ep, req);\n\n\tspin_unlock(&ep->udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->udc->lock);\n}\n\nstatic void usbf_ep_nuke(struct usbf_ep *ep, int status)\n{\n\tstruct usbf_req *req;\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s nuke status %d\\n\", ep->id,\n\t\tep->is_in ? \"in\" : \"out\",\n\t\tstatus);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct usbf_req, queue);\n\t\tusbf_ep_req_done(ep, req, status);\n\t}\n\n\tif (ep->id == 0)\n\t\tusbf_ep0_fifo_flush(ep);\n\telse\n\t\tusbf_epn_fifo_flush(ep);\n}\n\nstatic bool usbf_ep_is_stalled(struct usbf_ep *ep)\n{\n\tu32 ctrl;\n\n\tif (ep->id == 0) {\n\t\tctrl = usbf_ep_reg_readl(ep, USBF_REG_EP0_CONTROL);\n\t\treturn (ctrl & USBF_EP0_STL) ? true : false;\n\t}\n\n\tctrl = usbf_ep_reg_readl(ep, USBF_REG_EPN_CONTROL);\n\tif (ep->is_in)\n\t\treturn (ctrl & USBF_EPN_ISTL) ? true : false;\n\n\treturn (ctrl & USBF_EPN_OSTL) ? true : false;\n}\n\nstatic int usbf_epn_start_queue(struct usbf_ep *epn)\n{\n\tstruct usbf_req *req;\n\tint ret;\n\n\tif (usbf_ep_is_stalled(epn))\n\t\treturn 0;\n\n\treq = list_first_entry_or_null(&epn->queue, struct usbf_req, queue);\n\n\tif (epn->is_in) {\n\t\tif (req && !epn->is_processing) {\n\t\t\tret = epn->dma_regs ?\n\t\t\t\tusbf_epn_dma_in(epn, req) :\n\t\t\t\tusbf_epn_pio_in(epn, req);\n\t\t\tif (ret != -EINPROGRESS) {\n\t\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\t\"queued next request not in progress\\n\");\n\t\t\t\t\t \n\t\t\t\treturn ret ? ret : -EIO;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (req) {\n\t\t\t \n\t\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_ONAK);\n\n\t\t\t \n\t\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_INT_ENA,\n\t\t\t\tUSBF_EPN_OUT_INT | USBF_EPN_OUT_NULL_INT);\n\t\t} else {\n\t\t\t \n\t\t\tusbf_ep_reg_bitset(epn, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_ONAK);\n\t\t\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_INT_ENA,\n\t\t\t\tUSBF_EPN_OUT_INT | USBF_EPN_OUT_NULL_INT);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int usbf_ep_process_queue(struct usbf_ep *ep)\n{\n\tint (*usbf_ep_xfer)(struct usbf_ep *ep, struct usbf_req *req);\n\tstruct usbf_req *req;\n\tint is_processing;\n\tint ret;\n\n\tif (ep->is_in) {\n\t\tusbf_ep_xfer = usbf_ep0_pio_in;\n\t\tif (ep->id) {\n\t\t\tusbf_ep_xfer = ep->dma_regs ?\n\t\t\t\t\tusbf_epn_dma_in : usbf_epn_pio_in;\n\t\t}\n\t} else {\n\t\tusbf_ep_xfer = usbf_ep0_pio_out;\n\t\tif (ep->id) {\n\t\t\tusbf_ep_xfer = ep->dma_regs ?\n\t\t\t\t\tusbf_epn_dma_out : usbf_epn_pio_out;\n\t\t}\n\t}\n\n\treq = list_first_entry_or_null(&ep->queue, struct usbf_req, queue);\n\tif (!req) {\n\t\tdev_err(ep->udc->dev,\n\t\t\t\"no request available for ep%u %s process\\n\", ep->id,\n\t\t\tep->is_in ? \"in\" : \"out\");\n\t\treturn -ENOENT;\n\t}\n\n\tdo {\n\t\t \n\t\tif (!ep->is_in && ep->id != 0) {\n\t\t\tusbf_ep_reg_bitset(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_ONAK);\n\t\t}\n\n\t\tret = usbf_ep_xfer(ep, req);\n\t\tif (ret == -EINPROGRESS) {\n\t\t\tif (!ep->is_in && ep->id != 0) {\n\t\t\t\t \n\t\t\t\tusbf_ep_reg_bitclr(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\t\tUSBF_EPN_ONAK);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tis_processing = ep->is_processing;\n\t\tep->is_processing = 1;\n\t\tusbf_ep_req_done(ep, req, ret);\n\t\tep->is_processing = is_processing;\n\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (ep->id == 0)\n\t\t\t\tusbf_ep0_fifo_flush(ep);\n\t\t\telse\n\t\t\t\tusbf_epn_fifo_flush(ep);\n\t\t}\n\n\t\treq = list_first_entry_or_null(&ep->queue, struct usbf_req,\n\t\t\t\t\t       queue);\n\n\t\tif (ep->is_in)\n\t\t\tcontinue;\n\n\t\tif (ep->id != 0) {\n\t\t\tif (req) {\n\t\t\t\t \n\t\t\t\tusbf_ep_reg_bitclr(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\t\tUSBF_EPN_ONAK);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tusbf_ep_reg_bitclr(ep, USBF_REG_EPN_INT_ENA,\n\t\t\t\t\tUSBF_EPN_OUT_INT | USBF_EPN_OUT_NULL_INT);\n\t\t\t}\n\t\t}\n\t\t \n\t\treturn req ? -EINPROGRESS : 0;\n\n\t} while (req);\n\n\treturn 0;\n}\n\nstatic void usbf_ep_stall(struct usbf_ep *ep, bool stall)\n{\n\tstruct usbf_req *first;\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s %s\\n\", ep->id,\n\t\tep->is_in ? \"in\" : \"out\",\n\t\tstall ? \"stall\" : \"unstall\");\n\n\tif (ep->id == 0) {\n\t\tif (stall)\n\t\t\tusbf_ep_reg_bitset(ep, USBF_REG_EP0_CONTROL, USBF_EP0_STL);\n\t\telse\n\t\t\tusbf_ep_reg_bitclr(ep, USBF_REG_EP0_CONTROL, USBF_EP0_STL);\n\t\treturn;\n\t}\n\n\tif (stall) {\n\t\tif (ep->is_in)\n\t\t\tusbf_ep_reg_bitset(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_ISTL);\n\t\telse\n\t\t\tusbf_ep_reg_bitset(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_OSTL | USBF_EPN_OSTL_EN);\n\t} else {\n\t\tfirst = list_first_entry_or_null(&ep->queue, struct usbf_req, queue);\n\t\tif (first && first->is_mapped) {\n\t\t\t \n\t\t\tusbf_epn_dma_abort(ep, first);\n\t\t}\n\t\tusbf_epn_fifo_flush(ep);\n\t\tif (ep->is_in) {\n\t\t\tusbf_ep_reg_clrset(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_ISTL,\n\t\t\t\tUSBF_EPN_IPIDCLR);\n\t\t} else {\n\t\t\tusbf_ep_reg_clrset(ep, USBF_REG_EPN_CONTROL,\n\t\t\t\tUSBF_EPN_OSTL,\n\t\t\t\tUSBF_EPN_OSTL_EN | USBF_EPN_OPIDCLR);\n\t\t}\n\t\tusbf_epn_start_queue(ep);\n\t}\n}\n\nstatic void usbf_ep0_enable(struct usbf_ep *ep0)\n{\n\tusbf_ep_reg_writel(ep0, USBF_REG_EP0_CONTROL, USBF_EP0_INAK_EN | USBF_EP0_BCLR);\n\n\tusbf_ep_reg_writel(ep0, USBF_REG_EP0_INT_ENA,\n\t\tUSBF_EP0_SETUP_EN | USBF_EP0_STG_START_EN | USBF_EP0_STG_END_EN |\n\t\tUSBF_EP0_OUT_EN | USBF_EP0_OUT_NULL_EN | USBF_EP0_IN_EN);\n\n\tep0->udc->ep0state = EP0_IDLE;\n\tep0->disabled = 0;\n\n\t \n\tusbf_reg_bitset(ep0->udc, USBF_REG_USB_INT_ENA, USBF_USB_EPN_EN(0));\n}\n\nstatic int usbf_epn_enable(struct usbf_ep *epn)\n{\n\tu32 base_addr;\n\tu32 ctrl;\n\n\tbase_addr = usbf_ep_info[epn->id].base_addr;\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_PCKT_ADRS,\n\t\tUSBF_EPN_BASEAD(base_addr) | USBF_EPN_MPKT(epn->ep.maxpacket));\n\n\t \n\tif (epn->is_in) {\n\t\t \n\t\tusbf_ep_reg_writel(epn, USBF_REG_EPN_INT_ENA, USBF_EPN_IN_EN);\n\t}\n\n\t \n\tctrl = USBF_EPN_EN | USBF_EPN_BCLR;\n\tif (epn->is_in)\n\t\tctrl |= USBF_EPN_OSTL | USBF_EPN_OSTL_EN;\n\telse\n\t\tctrl |= USBF_EPN_DIR0 | USBF_EPN_ISTL | USBF_EPN_OSTL_EN | USBF_EPN_ONAK;\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_CONTROL, ctrl);\n\n\treturn 0;\n}\n\nstatic int usbf_ep_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tstruct usbf_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (ep->id == 0)\n\t\treturn -EINVAL;\n\n\tif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s mpkts %d\\n\", ep->id,\n\t\tusb_endpoint_dir_in(desc) ? \"in\" : \"out\",\n\t\tusb_endpoint_maxp(desc));\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tep->is_in = usb_endpoint_dir_in(desc);\n\tep->ep.maxpacket = usb_endpoint_maxp(desc);\n\n\tret = usbf_epn_enable(ep);\n\tif (ret)\n\t\tgoto end;\n\n\tep->disabled = 0;\n\n\t \n\tusbf_reg_bitset(udc, USBF_REG_USB_INT_ENA, USBF_USB_EPN_EN(ep->id));\n\n\t \n\tif (ep->dma_regs) {\n\t\tep->bridge_on_dma_end = NULL;\n\t\tusbf_reg_bitset(udc, USBF_REG_AHBBINTEN,\n\t\t\tUSBF_SYS_DMA_ENDINTEN_EPN(ep->id));\n\t}\n\n\tret = 0;\nend:\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn ret;\n}\n\nstatic int usbf_epn_disable(struct usbf_ep *epn)\n{\n\t \n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_INT_ENA, 0);\n\n\t \n\tusbf_ep_reg_bitclr(epn, USBF_REG_EPN_CONTROL, USBF_EPN_EN);\n\n\t \n\tusbf_ep_nuke(epn, -ESHUTDOWN);\n\n\treturn 0;\n}\n\nstatic int usbf_ep_disable(struct usb_ep *_ep)\n{\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tstruct usbf_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (ep->id == 0)\n\t\treturn -EINVAL;\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s mpkts %d\\n\", ep->id,\n\t\tep->is_in ? \"in\" : \"out\", ep->ep.maxpacket);\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tep->disabled = 1;\n\t \n\tif (ep->dma_regs) {\n\t\tusbf_reg_bitclr(udc, USBF_REG_AHBBINTEN,\n\t\t\tUSBF_SYS_DMA_ENDINTEN_EPN(ep->id));\n\t\tep->bridge_on_dma_end = NULL;\n\t}\n\t \n\tusbf_reg_bitclr(udc, USBF_REG_USB_INT_ENA, USBF_USB_EPN_EN(ep->id));\n\t \n\tret = usbf_epn_disable(ep);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int usbf_ep0_queue(struct usbf_ep *ep0, struct usbf_req *req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tint ret;\n\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\treq->is_zero_sent = 0;\n\n\tlist_add_tail(&req->queue, &ep0->queue);\n\n\tif (ep0->udc->ep0state == EP0_IN_STATUS_START_PHASE)\n\t\treturn 0;\n\n\tif (!ep0->is_in)\n\t\treturn 0;\n\n\tif (ep0->udc->ep0state == EP0_IN_STATUS_PHASE) {\n\t\tif (req->req.length) {\n\t\t\tdev_err(ep0->udc->dev,\n\t\t\t\t\"request lng %u for ep0 in status phase\\n\",\n\t\t\t\treq->req.length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tep0->delayed_status = 0;\n\t}\n\tif (!ep0->is_processing) {\n\t\tret = usbf_ep0_pio_in(ep0, req);\n\t\tif (ret != -EINPROGRESS) {\n\t\t\tdev_err(ep0->udc->dev,\n\t\t\t\t\"queued request not in progress\\n\");\n\t\t\t \n\t\t\treturn ret ? ret : -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int usbf_epn_queue(struct usbf_ep *ep, struct usbf_req *req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tint was_empty;\n\tint ret;\n\n\tif (ep->disabled) {\n\t\tdev_err(ep->udc->dev, \"ep%u request queue while disable\\n\",\n\t\t\tep->id);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\treq->is_zero_sent = 0;\n\treq->xfer_step = USBF_XFER_START;\n\n\twas_empty = list_empty(&ep->queue);\n\tlist_add_tail(&req->queue, &ep->queue);\n\tif (was_empty) {\n\t\tret = usbf_epn_start_queue(ep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int usbf_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct usbf_req *req = container_of(_req, struct usbf_req, req);\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tstruct usbf_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!_req || !_req->buf)\n\t\treturn -EINVAL;\n\n\tif (!udc || !udc->driver)\n\t\treturn -EINVAL;\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s req queue length %u, zero %u, short_not_ok %u\\n\",\n\t\tep->id, ep->is_in ? \"in\" : \"out\",\n\t\treq->req.length, req->req.zero, req->req.short_not_ok);\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tif (ep->id == 0)\n\t\tret = usbf_ep0_queue(ep, req, gfp_flags);\n\telse\n\t\tret = usbf_epn_queue(ep, req, gfp_flags);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn ret;\n}\n\nstatic int usbf_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct usbf_req *req = container_of(_req, struct usbf_req, req);\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tunsigned long flags;\n\tint is_processing;\n\tint first;\n\tint ret;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\tdev_dbg(ep->udc->dev, \"ep%u %s req dequeue length %u/%u\\n\",\n\t\tep->id, ep->is_in ? \"in\" : \"out\",\n\t\treq->req.actual, req->req.length);\n\n\tfirst = list_is_first(&req->queue, &ep->queue);\n\n\t \n\tis_processing = ep->is_processing;\n\tep->is_processing = 1;\n\tusbf_ep_req_done(ep, req, -ECONNRESET);\n\tep->is_processing = is_processing;\n\n\tif (first) {\n\t\t \n\t\tif (ep->id)\n\t\t\tusbf_epn_fifo_flush(ep);\n\t\telse\n\t\t\tusbf_ep0_fifo_flush(ep);\n\t}\n\n\tif (ep->id == 0) {\n\t\t \n\t\tusbf_ep_stall(ep, true);\n\t\tusbf_ep_nuke(ep, -ECONNRESET);\n\t\tep->udc->ep0state = EP0_IDLE;\n\t\tgoto end;\n\t}\n\n\tif (!first)\n\t\tgoto end;\n\n\tret = usbf_epn_start_queue(ep);\n\tif (ret) {\n\t\tusbf_ep_stall(ep, true);\n\t\tusbf_ep_nuke(ep, -EIO);\n\t}\nend:\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn 0;\n}\n\nstatic struct usb_request *usbf_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct usbf_req *req;\n\n\tif (!_ep)\n\t\treturn NULL;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void usbf_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct usbf_req *req;\n\tunsigned long flags;\n\tstruct usbf_ep *ep;\n\n\tif (!_ep || !_req)\n\t\treturn;\n\n\treq = container_of(_req, struct usbf_req, req);\n\tep = container_of(_ep, struct usbf_ep, ep);\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tlist_del_init(&req->queue);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\tkfree(req);\n}\n\nstatic int usbf_ep_set_halt(struct usb_ep *_ep, int halt)\n{\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tunsigned long flags;\n\tint ret;\n\n\tif (ep->id == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t\tgoto end;\n\t}\n\n\tusbf_ep_stall(ep, halt);\n\tif (!halt)\n\t\tep->is_wedged = 0;\n\n\tret = 0;\nend:\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int usbf_ep_set_wedge(struct usb_ep *_ep)\n{\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\tunsigned long flags;\n\tint ret;\n\n\tif (ep->id == 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t\tgoto end;\n\t}\n\tusbf_ep_stall(ep, 1);\n\tep->is_wedged = 1;\n\n\tret = 0;\nend:\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn ret;\n}\n\nstatic struct usb_ep_ops usbf_ep_ops = {\n\t.enable = usbf_ep_enable,\n\t.disable = usbf_ep_disable,\n\t.queue = usbf_ep_queue,\n\t.dequeue = usbf_ep_dequeue,\n\t.set_halt = usbf_ep_set_halt,\n\t.set_wedge = usbf_ep_set_wedge,\n\t.alloc_request = usbf_ep_alloc_request,\n\t.free_request = usbf_ep_free_request,\n};\n\nstatic void usbf_ep0_req_complete(struct usb_ep *_ep, struct usb_request *_req)\n{\n}\n\nstatic void usbf_ep0_fill_req(struct usbf_ep *ep0, struct usbf_req *req,\n\t\t\t      void *buf, unsigned int length,\n\t\t\t      void (*complete)(struct usb_ep *_ep,\n\t\t\t\t\t       struct usb_request *_req))\n{\n\tif (buf && length)\n\t\tmemcpy(ep0->udc->ep0_buf, buf, length);\n\n\treq->req.buf = ep0->udc->ep0_buf;\n\treq->req.length = length;\n\treq->req.dma = 0;\n\treq->req.zero = true;\n\treq->req.complete = complete ? complete : usbf_ep0_req_complete;\n\treq->req.status = -EINPROGRESS;\n\treq->req.context = NULL;\n\treq->req.actual = 0;\n}\n\nstatic struct usbf_ep *usbf_get_ep_by_addr(struct usbf_udc *udc, u8 address)\n{\n\tstruct usbf_ep *ep;\n\tunsigned int i;\n\n\tif ((address & USB_ENDPOINT_NUMBER_MASK) == 0)\n\t\treturn &udc->ep[0];\n\n\tfor (i = 1; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tep = &udc->ep[i];\n\n\t\tif (!ep->ep.desc)\n\t\t\tcontinue;\n\n\t\tif (ep->ep.desc->bEndpointAddress == address)\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\nstatic int usbf_req_delegate(struct usbf_udc *udc,\n\t\t\t     const struct usb_ctrlrequest *ctrlrequest)\n{\n\tint ret;\n\n\tspin_unlock(&udc->lock);\n\tret = udc->driver->setup(&udc->gadget, ctrlrequest);\n\tspin_lock(&udc->lock);\n\tif (ret < 0) {\n\t\tdev_dbg(udc->dev, \"udc driver setup failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (ret == USB_GADGET_DELAYED_STATUS) {\n\t\tdev_dbg(udc->dev, \"delayed status set\\n\");\n\t\tudc->ep[0].delayed_status = 1;\n\t\treturn 0;\n\t}\n\treturn ret;\n}\n\nstatic int usbf_req_get_status(struct usbf_udc *udc,\n\t\t\t       const struct usb_ctrlrequest *ctrlrequest)\n{\n\tstruct usbf_ep *ep;\n\tu16 status_data;\n\tu16 wLength;\n\tu16 wValue;\n\tu16 wIndex;\n\n\twValue  = le16_to_cpu(ctrlrequest->wValue);\n\twLength = le16_to_cpu(ctrlrequest->wLength);\n\twIndex  = le16_to_cpu(ctrlrequest->wIndex);\n\n\tswitch (ctrlrequest->bRequestType) {\n\tcase USB_DIR_IN | USB_RECIP_DEVICE | USB_TYPE_STANDARD:\n\t\tif ((wValue != 0) || (wIndex != 0) || (wLength != 2))\n\t\t\tgoto delegate;\n\n\t\tstatus_data = 0;\n\t\tif (udc->gadget.is_selfpowered)\n\t\t\tstatus_data |= BIT(USB_DEVICE_SELF_POWERED);\n\n\t\tif (udc->is_remote_wakeup)\n\t\t\tstatus_data |= BIT(USB_DEVICE_REMOTE_WAKEUP);\n\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_RECIP_ENDPOINT | USB_TYPE_STANDARD:\n\t\tif ((wValue != 0) || (wLength != 2))\n\t\t\tgoto delegate;\n\n\t\tep = usbf_get_ep_by_addr(udc, wIndex);\n\t\tif (!ep)\n\t\t\treturn -EINVAL;\n\n\t\tstatus_data = 0;\n\t\tif (usbf_ep_is_stalled(ep))\n\t\t\tstatus_data |= cpu_to_le16(1);\n\t\tbreak;\n\n\tcase USB_DIR_IN | USB_RECIP_INTERFACE | USB_TYPE_STANDARD:\n\t\tif ((wValue != 0) || (wLength != 2))\n\t\t\tgoto delegate;\n\t\tstatus_data = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tgoto delegate;\n\t}\n\n\tusbf_ep0_fill_req(&udc->ep[0], &udc->setup_reply, &status_data,\n\t\t\t  sizeof(status_data), NULL);\n\tusbf_ep0_queue(&udc->ep[0], &udc->setup_reply, GFP_ATOMIC);\n\n\treturn 0;\n\ndelegate:\n\treturn usbf_req_delegate(udc, ctrlrequest);\n}\n\nstatic int usbf_req_clear_set_feature(struct usbf_udc *udc,\n\t\t\t\t      const struct usb_ctrlrequest *ctrlrequest,\n\t\t\t\t      bool is_set)\n{\n\tstruct usbf_ep *ep;\n\tu16 wLength;\n\tu16 wValue;\n\tu16 wIndex;\n\n\twValue  = le16_to_cpu(ctrlrequest->wValue);\n\twLength = le16_to_cpu(ctrlrequest->wLength);\n\twIndex  = le16_to_cpu(ctrlrequest->wIndex);\n\n\tswitch (ctrlrequest->bRequestType) {\n\tcase USB_DIR_OUT | USB_RECIP_DEVICE:\n\t\tif ((wIndex != 0) || (wLength != 0))\n\t\t\tgoto delegate;\n\n\t\tif (wValue != cpu_to_le16(USB_DEVICE_REMOTE_WAKEUP))\n\t\t\tgoto delegate;\n\n\t\tudc->is_remote_wakeup = is_set;\n\t\tbreak;\n\n\tcase USB_DIR_OUT | USB_RECIP_ENDPOINT:\n\t\tif (wLength != 0)\n\t\t\tgoto delegate;\n\n\t\tep = usbf_get_ep_by_addr(udc, wIndex);\n\t\tif (!ep)\n\t\t\treturn -EINVAL;\n\n\t\tif ((ep->id == 0) && is_set) {\n\t\t\t \n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ep->is_wedged && !is_set) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tusbf_ep_stall(ep, is_set);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto delegate;\n\t}\n\n\treturn 0;\n\ndelegate:\n\treturn usbf_req_delegate(udc, ctrlrequest);\n}\n\nstatic void usbf_ep0_req_set_address_complete(struct usb_ep *_ep,\n\t\t\t\t\t      struct usb_request *_req)\n{\n\tstruct usbf_ep *ep = container_of(_ep, struct usbf_ep, ep);\n\n\t \n\tif (_req->status == 0) {\n\t\t \n\t\tusb_gadget_set_state(&ep->udc->gadget, USB_STATE_ADDRESS);\n\t}\n\n\t \n}\n\nstatic int usbf_req_set_address(struct usbf_udc *udc,\n\t\t\t\tconst struct usb_ctrlrequest *ctrlrequest)\n{\n\tu16 wLength;\n\tu16 wValue;\n\tu16 wIndex;\n\tu32 addr;\n\n\twValue  = le16_to_cpu(ctrlrequest->wValue);\n\twLength = le16_to_cpu(ctrlrequest->wLength);\n\twIndex  = le16_to_cpu(ctrlrequest->wIndex);\n\n\tif (ctrlrequest->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\n\t\tgoto delegate;\n\n\tif ((wIndex != 0) || (wLength != 0) || (wValue > 127))\n\t\treturn -EINVAL;\n\n\taddr = wValue;\n\t \n\tusbf_reg_writel(udc, USBF_REG_USB_ADDRESS, USBF_USB_SET_USB_ADDR(addr));\n\n\t \n\tusbf_ep0_fill_req(&udc->ep[0], &udc->setup_reply, NULL, 0,\n\t\t\t  usbf_ep0_req_set_address_complete);\n\tusbf_ep0_queue(&udc->ep[0], &udc->setup_reply, GFP_ATOMIC);\n\n\treturn 0;\n\ndelegate:\n\treturn usbf_req_delegate(udc, ctrlrequest);\n}\n\nstatic int usbf_req_set_configuration(struct usbf_udc *udc,\n\t\t\t\t      const struct usb_ctrlrequest *ctrlrequest)\n{\n\tu16 wLength;\n\tu16 wValue;\n\tu16 wIndex;\n\tint ret;\n\n\tret = usbf_req_delegate(udc, ctrlrequest);\n\tif (ret)\n\t\treturn ret;\n\n\twValue  = le16_to_cpu(ctrlrequest->wValue);\n\twLength = le16_to_cpu(ctrlrequest->wLength);\n\twIndex  = le16_to_cpu(ctrlrequest->wIndex);\n\n\tif ((ctrlrequest->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE)) ||\n\t    (wIndex != 0) || (wLength != 0)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (wValue & 0x00FF) {\n\t\tusbf_reg_bitset(udc, USBF_REG_USB_CONTROL, USBF_USB_CONF);\n\t} else {\n\t\tusbf_reg_bitclr(udc, USBF_REG_USB_CONTROL, USBF_USB_CONF);\n\t\t \n\t\tspin_unlock(&udc->lock);\n\t\tusb_gadget_set_state(&udc->gadget, USB_STATE_ADDRESS);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbf_handle_ep0_setup(struct usbf_ep *ep0)\n{\n\tunion {\n\t\tstruct usb_ctrlrequest ctrlreq;\n\t\tu32 raw[2];\n\t} crq;\n\tstruct usbf_udc *udc = ep0->udc;\n\tint ret;\n\n\t \n\tcrq.raw[0] = usbf_reg_readl(udc, USBF_REG_SETUP_DATA0);\n\tcrq.raw[1] = usbf_reg_readl(udc, USBF_REG_SETUP_DATA1);\n\n\tdev_dbg(ep0->udc->dev,\n\t\t\"ep0 req%02x.%02x, wValue 0x%04x, wIndex 0x%04x, wLength 0x%04x\\n\",\n\t\tcrq.ctrlreq.bRequestType, crq.ctrlreq.bRequest,\n\t\tcrq.ctrlreq.wValue, crq.ctrlreq.wIndex, crq.ctrlreq.wLength);\n\n\t \n\tif (crq.ctrlreq.wLength) {\n\t\tif (crq.ctrlreq.bRequestType & USB_DIR_IN) {\n\t\t\tudc->ep0state = EP0_IN_DATA_PHASE;\n\t\t\tusbf_ep_reg_clrset(ep0, USBF_REG_EP0_CONTROL,\n\t\t\t\tUSBF_EP0_INAK,\n\t\t\t\tUSBF_EP0_INAK_EN);\n\t\t\tep0->is_in = 1;\n\t\t} else {\n\t\t\tudc->ep0state = EP0_OUT_DATA_PHASE;\n\t\t\tusbf_ep_reg_bitclr(ep0, USBF_REG_EP0_CONTROL,\n\t\t\t\tUSBF_EP0_ONAK);\n\t\t\tep0->is_in = 0;\n\t\t}\n\t} else {\n\t\tudc->ep0state = EP0_IN_STATUS_START_PHASE;\n\t\tep0->is_in = 1;\n\t}\n\n\t \n\tep0->delayed_status = 0;\n\n\tif ((crq.ctrlreq.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD) {\n\t\t \n\t\tgoto delegate;\n\t}\n\n\tswitch (crq.ctrlreq.bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\tret = usbf_req_get_status(udc, &crq.ctrlreq);\n\t\tbreak;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tret = usbf_req_clear_set_feature(udc, &crq.ctrlreq, false);\n\t\tbreak;\n\n\tcase USB_REQ_SET_FEATURE:\n\t\tret = usbf_req_clear_set_feature(udc, &crq.ctrlreq, true);\n\t\tbreak;\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\tret = usbf_req_set_address(udc, &crq.ctrlreq);\n\t\tbreak;\n\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tret = usbf_req_set_configuration(udc, &crq.ctrlreq);\n\t\tbreak;\n\n\tdefault:\n\t\tgoto delegate;\n\t}\n\n\treturn ret;\n\ndelegate:\n\treturn usbf_req_delegate(udc, &crq.ctrlreq);\n}\n\nstatic int usbf_handle_ep0_data_status(struct usbf_ep *ep0,\n\t\t\t\t  const char *ep0state_name,\n\t\t\t\t  enum usbf_ep0state next_ep0state)\n{\n\tstruct usbf_udc *udc = ep0->udc;\n\tint ret;\n\n\tret = usbf_ep_process_queue(ep0);\n\tswitch (ret) {\n\tcase -ENOENT:\n\t\tdev_err(udc->dev,\n\t\t\t\"no request available for ep0 %s phase\\n\",\n\t\t\tep0state_name);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tudc->ep0state = next_ep0state;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(udc->dev,\n\t\t\t\"process queue failed for ep0 %s phase (%d)\\n\",\n\t\t\tep0state_name, ret);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int usbf_handle_ep0_out_status_start(struct usbf_ep *ep0)\n{\n\tstruct usbf_udc *udc = ep0->udc;\n\tstruct usbf_req *req;\n\n\tusbf_ep_reg_clrset(ep0, USBF_REG_EP0_CONTROL,\n\t\t\t\tUSBF_EP0_ONAK,\n\t\t\t\tUSBF_EP0_PIDCLR);\n\tep0->is_in = 0;\n\n\treq = list_first_entry_or_null(&ep0->queue, struct usbf_req, queue);\n\tif (!req) {\n\t\tusbf_ep0_fill_req(ep0, &udc->setup_reply, NULL, 0, NULL);\n\t\tusbf_ep0_queue(ep0, &udc->setup_reply, GFP_ATOMIC);\n\t} else {\n\t\tif (req->req.length) {\n\t\t\tdev_err(udc->dev,\n\t\t\t\t\"queued request length %u for ep0 out status phase\\n\",\n\t\t\t\treq->req.length);\n\t\t}\n\t}\n\tudc->ep0state = EP0_OUT_STATUS_PHASE;\n\treturn 0;\n}\n\nstatic int usbf_handle_ep0_in_status_start(struct usbf_ep *ep0)\n{\n\tstruct usbf_udc *udc = ep0->udc;\n\tstruct usbf_req *req;\n\tint ret;\n\n\tusbf_ep_reg_clrset(ep0, USBF_REG_EP0_CONTROL,\n\t\t\t\tUSBF_EP0_INAK,\n\t\t\t\tUSBF_EP0_INAK_EN | USBF_EP0_PIDCLR);\n\tep0->is_in = 1;\n\n\t \n\treq = list_first_entry_or_null(&ep0->queue, struct usbf_req, queue);\n\tif (!req) {\n\t\tif (ep0->delayed_status) {\n\t\t\tdev_dbg(ep0->udc->dev,\n\t\t\t\t\"EP0_IN_STATUS_START_PHASE ep0->delayed_status set\\n\");\n\t\t\tudc->ep0state = EP0_IN_STATUS_PHASE;\n\t\t\treturn 0;\n\t\t}\n\n\t\tusbf_ep0_fill_req(ep0, &udc->setup_reply, NULL,\n\t\t\t  0, NULL);\n\t\tusbf_ep0_queue(ep0, &udc->setup_reply,\n\t\t\t       GFP_ATOMIC);\n\n\t\treq = list_first_entry_or_null(&ep0->queue, struct usbf_req, queue);\n\t} else {\n\t\tif (req->req.length) {\n\t\t\tdev_err(udc->dev,\n\t\t\t\t\"queued request length %u for ep0 in status phase\\n\",\n\t\t\t\treq->req.length);\n\t\t}\n\t}\n\n\tret = usbf_ep0_pio_in(ep0, req);\n\tif (ret != -EINPROGRESS) {\n\t\tusbf_ep_req_done(ep0, req, ret);\n\t\tudc->ep0state = EP0_IN_STATUS_END_PHASE;\n\t\treturn 0;\n\t}\n\n\tudc->ep0state = EP0_IN_STATUS_PHASE;\n\treturn 0;\n}\n\nstatic void usbf_ep0_interrupt(struct usbf_ep *ep0)\n{\n\tstruct usbf_udc *udc = ep0->udc;\n\tu32 sts, prev_sts;\n\tint prev_ep0state;\n\tint ret;\n\n\tep0->status = usbf_ep_reg_readl(ep0, USBF_REG_EP0_STATUS);\n\tusbf_ep_reg_writel(ep0, USBF_REG_EP0_STATUS, ~ep0->status);\n\n\tdev_dbg(ep0->udc->dev, \"ep0 status=0x%08x, enable=%08x\\n, ctrl=0x%08x\\n\",\n\t\tep0->status,\n\t\tusbf_ep_reg_readl(ep0, USBF_REG_EP0_INT_ENA),\n\t\tusbf_ep_reg_readl(ep0, USBF_REG_EP0_CONTROL));\n\n\tsts = ep0->status & (USBF_EP0_SETUP_INT | USBF_EP0_IN_INT | USBF_EP0_OUT_INT |\n\t\t\t     USBF_EP0_OUT_NULL_INT | USBF_EP0_STG_START_INT |\n\t\t\t     USBF_EP0_STG_END_INT);\n\n\tret = 0;\n\tdo {\n\t\tdev_dbg(ep0->udc->dev, \"udc->ep0state=%d\\n\", udc->ep0state);\n\n\t\tprev_sts = sts;\n\t\tprev_ep0state = udc->ep0state;\n\t\tswitch (udc->ep0state) {\n\t\tcase EP0_IDLE:\n\t\t\tif (!(sts & USBF_EP0_SETUP_INT))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_SETUP_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle setup\\n\");\n\t\t\tret = usbf_handle_ep0_setup(ep0);\n\t\t\tbreak;\n\n\t\tcase EP0_IN_DATA_PHASE:\n\t\t\tif (!(sts & USBF_EP0_IN_INT))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_IN_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle in data phase\\n\");\n\t\t\tret = usbf_handle_ep0_data_status(ep0,\n\t\t\t\t\"in data\", EP0_OUT_STATUS_START_PHASE);\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_STATUS_START_PHASE:\n\t\t\tif (!(sts & USBF_EP0_STG_START_INT))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_STG_START_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle out status start phase\\n\");\n\t\t\tret = usbf_handle_ep0_out_status_start(ep0);\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_STATUS_PHASE:\n\t\t\tif (!(sts & (USBF_EP0_OUT_INT | USBF_EP0_OUT_NULL_INT)))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~(USBF_EP0_OUT_INT | USBF_EP0_OUT_NULL_INT);\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle out status phase\\n\");\n\t\t\tret = usbf_handle_ep0_data_status(ep0,\n\t\t\t\t\"out status\",\n\t\t\t\tEP0_OUT_STATUS_END_PHASE);\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_STATUS_END_PHASE:\n\t\t\tif (!(sts & (USBF_EP0_STG_END_INT | USBF_EP0_SETUP_INT)))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_STG_END_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle out status end phase\\n\");\n\t\t\tudc->ep0state = EP0_IDLE;\n\t\t\tbreak;\n\n\t\tcase EP0_OUT_DATA_PHASE:\n\t\t\tif (!(sts & (USBF_EP0_OUT_INT | USBF_EP0_OUT_NULL_INT)))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~(USBF_EP0_OUT_INT | USBF_EP0_OUT_NULL_INT);\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle out data phase\\n\");\n\t\t\tret = usbf_handle_ep0_data_status(ep0,\n\t\t\t\t\"out data\", EP0_IN_STATUS_START_PHASE);\n\t\t\tbreak;\n\n\t\tcase EP0_IN_STATUS_START_PHASE:\n\t\t\tif (!(sts & USBF_EP0_STG_START_INT))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_STG_START_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle in status start phase\\n\");\n\t\t\tret = usbf_handle_ep0_in_status_start(ep0);\n\t\t\tbreak;\n\n\t\tcase EP0_IN_STATUS_PHASE:\n\t\t\tif (!(sts & USBF_EP0_IN_INT))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_IN_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle in status phase\\n\");\n\t\t\tret = usbf_handle_ep0_data_status(ep0,\n\t\t\t\t\"in status\", EP0_IN_STATUS_END_PHASE);\n\t\t\tbreak;\n\n\t\tcase EP0_IN_STATUS_END_PHASE:\n\t\t\tif (!(sts & (USBF_EP0_STG_END_INT | USBF_EP0_SETUP_INT)))\n\t\t\t\tbreak;\n\n\t\t\tsts &= ~USBF_EP0_STG_END_INT;\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 handle in status end\\n\");\n\t\t\tudc->ep0state = EP0_IDLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tudc->ep0state = EP0_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret) {\n\t\t\tdev_dbg(ep0->udc->dev, \"ep0 failed (%d)\\n\", ret);\n\t\t\t \n\t\t\tusbf_ep_stall(ep0, true);\n\n\t\t\t \n\t\t\tusbf_ep_nuke(ep0, -EPROTO);\n\n\t\t\tudc->ep0state = EP0_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t} while ((prev_ep0state != udc->ep0state) || (prev_sts != sts));\n\n\tdev_dbg(ep0->udc->dev, \"ep0 done udc->ep0state=%d, status=0x%08x. next=0x%08x\\n\",\n\t\tudc->ep0state, sts,\n\t\tusbf_ep_reg_readl(ep0, USBF_REG_EP0_STATUS));\n}\n\nstatic void usbf_epn_process_queue(struct usbf_ep *epn)\n{\n\tint ret;\n\n\tret = usbf_ep_process_queue(epn);\n\tswitch (ret) {\n\tcase -ENOENT:\n\t\tdev_warn(epn->udc->dev, \"ep%u %s, no request available\\n\",\n\t\t\tepn->id, epn->is_in ? \"in\" : \"out\");\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\t \n\t\tret = 0;\n\t\tbreak;\n\tcase 0:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(epn->udc->dev, \"ep%u %s, process queue failed (%d)\\n\",\n\t\t\tepn->id, epn->is_in ? \"in\" : \"out\", ret);\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(epn->udc->dev, \"ep%u %s failed (%d)\\n\", epn->id,\n\t\t\tepn->is_in ? \"in\" : \"out\", ret);\n\t\tusbf_ep_stall(epn, true);\n\t\tusbf_ep_nuke(epn, ret);\n\t}\n}\n\nstatic void usbf_epn_interrupt(struct usbf_ep *epn)\n{\n\tu32 sts;\n\tu32 ena;\n\n\tepn->status = usbf_ep_reg_readl(epn, USBF_REG_EPN_STATUS);\n\tena = usbf_ep_reg_readl(epn, USBF_REG_EPN_INT_ENA);\n\tusbf_ep_reg_writel(epn, USBF_REG_EPN_STATUS, ~(epn->status & ena));\n\n\tdev_dbg(epn->udc->dev, \"ep%u %s status=0x%08x, enable=%08x\\n, ctrl=0x%08x\\n\",\n\t\tepn->id, epn->is_in ? \"in\" : \"out\", epn->status, ena,\n\t\tusbf_ep_reg_readl(epn, USBF_REG_EPN_CONTROL));\n\n\tif (epn->disabled) {\n\t\tdev_warn(epn->udc->dev, \"ep%u %s, interrupt while disabled\\n\",\n\t\t\tepn->id, epn->is_in ? \"in\" : \"out\");\n\t\treturn;\n\t}\n\n\tsts = epn->status & ena;\n\n\tif (sts & (USBF_EPN_IN_END_INT | USBF_EPN_IN_INT)) {\n\t\tsts &= ~(USBF_EPN_IN_END_INT | USBF_EPN_IN_INT);\n\t\tdev_dbg(epn->udc->dev, \"ep%u %s process queue (in interrupts)\\n\",\n\t\t\tepn->id, epn->is_in ? \"in\" : \"out\");\n\t\tusbf_epn_process_queue(epn);\n\t}\n\n\tif (sts & (USBF_EPN_OUT_END_INT | USBF_EPN_OUT_INT | USBF_EPN_OUT_NULL_INT)) {\n\t\tsts &= ~(USBF_EPN_OUT_END_INT | USBF_EPN_OUT_INT | USBF_EPN_OUT_NULL_INT);\n\t\tdev_dbg(epn->udc->dev, \"ep%u %s process queue (out interrupts)\\n\",\n\t\t\tepn->id, epn->is_in ? \"in\" : \"out\");\n\t\tusbf_epn_process_queue(epn);\n\t}\n\n\tdev_dbg(epn->udc->dev, \"ep%u %s done status=0x%08x. next=0x%08x\\n\",\n\t\tepn->id, epn->is_in ? \"in\" : \"out\",\n\t\tsts, usbf_ep_reg_readl(epn, USBF_REG_EPN_STATUS));\n}\n\nstatic void usbf_ep_reset(struct usbf_ep *ep)\n{\n\tep->status = 0;\n\t \n\tusbf_ep_nuke(ep, -ESHUTDOWN);\n}\n\nstatic void usbf_reset(struct usbf_udc *udc)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tif (udc->ep[i].disabled)\n\t\t\tcontinue;\n\n\t\tusbf_ep_reset(&udc->ep[i]);\n\t}\n\n\tif (usbf_reg_readl(udc, USBF_REG_USB_STATUS) & USBF_USB_SPEED_MODE)\n\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\telse\n\t\tudc->gadget.speed = USB_SPEED_FULL;\n\n\t \n\tudc->is_remote_wakeup = false;\n\n\t \n\tusbf_ep0_enable(&udc->ep[0]);\n\n\tif (udc->driver) {\n\t\t \n\t\tspin_unlock(&udc->lock);\n\t\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\nstatic void usbf_driver_suspend(struct usbf_udc *udc)\n{\n\tif (udc->is_usb_suspended) {\n\t\tdev_dbg(udc->dev, \"already suspended\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(udc->dev, \"do usb suspend\\n\");\n\tudc->is_usb_suspended = true;\n\n\tif (udc->driver && udc->driver->suspend) {\n\t\tspin_unlock(&udc->lock);\n\t\tudc->driver->suspend(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\n\t\t \n\t}\n}\n\nstatic void usbf_driver_resume(struct usbf_udc *udc)\n{\n\tif (!udc->is_usb_suspended)\n\t\treturn;\n\n\tdev_dbg(udc->dev, \"do usb resume\\n\");\n\tudc->is_usb_suspended = false;\n\n\tif (udc->driver && udc->driver->resume) {\n\t\tspin_unlock(&udc->lock);\n\t\tudc->driver->resume(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\nstatic irqreturn_t usbf_epc_irq(int irq, void *_udc)\n{\n\tstruct usbf_udc *udc = (struct usbf_udc *)_udc;\n\tunsigned long flags;\n\tstruct usbf_ep *ep;\n\tu32 int_sts;\n\tu32 int_en;\n\tint i;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tint_en = usbf_reg_readl(udc, USBF_REG_USB_INT_ENA);\n\tint_sts = usbf_reg_readl(udc, USBF_REG_USB_INT_STA) & int_en;\n\tusbf_reg_writel(udc, USBF_REG_USB_INT_STA, ~int_sts);\n\n\tdev_dbg(udc->dev, \"int_sts=0x%08x\\n\", int_sts);\n\n\tif (int_sts & USBF_USB_RSUM_INT) {\n\t\tdev_dbg(udc->dev, \"handle resume\\n\");\n\t\tusbf_driver_resume(udc);\n\t}\n\n\tif (int_sts & USBF_USB_USB_RST_INT) {\n\t\tdev_dbg(udc->dev, \"handle bus reset\\n\");\n\t\tusbf_driver_resume(udc);\n\t\tusbf_reset(udc);\n\t}\n\n\tif (int_sts & USBF_USB_SPEED_MODE_INT) {\n\t\tif (usbf_reg_readl(udc, USBF_REG_USB_STATUS) & USBF_USB_SPEED_MODE)\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\tdev_dbg(udc->dev, \"handle speed change (%s)\\n\",\n\t\t\tudc->gadget.speed == USB_SPEED_HIGH ? \"High\" : \"Full\");\n\t}\n\n\tif (int_sts & USBF_USB_EPN_INT(0)) {\n\t\tusbf_driver_resume(udc);\n\t\tusbf_ep0_interrupt(&udc->ep[0]);\n\t}\n\n\tfor (i = 1; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tep = &udc->ep[i];\n\n\t\tif (int_sts & USBF_USB_EPN_INT(i)) {\n\t\t\tusbf_driver_resume(udc);\n\t\t\tusbf_epn_interrupt(ep);\n\t\t}\n\t}\n\n\tif (int_sts & USBF_USB_SPND_INT) {\n\t\tdev_dbg(udc->dev, \"handle suspend\\n\");\n\t\tusbf_driver_suspend(udc);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t usbf_ahb_epc_irq(int irq, void *_udc)\n{\n\tstruct usbf_udc *udc = (struct usbf_udc *)_udc;\n\tunsigned long flags;\n\tstruct usbf_ep *epn;\n\tu32 sysbint;\n\tvoid (*ep_action)(struct usbf_ep *epn);\n\tint i;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tsysbint = usbf_reg_readl(udc, USBF_REG_AHBBINT);\n\tusbf_reg_writel(udc, USBF_REG_AHBBINT, sysbint);\n\n\tif ((sysbint & USBF_SYS_VBUS_INT) == USBF_SYS_VBUS_INT) {\n\t\tif (usbf_reg_readl(udc, USBF_REG_EPCTR) & USBF_SYS_VBUS_LEVEL) {\n\t\t\tdev_dbg(udc->dev, \"handle vbus (1)\\n\");\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tusb_udc_vbus_handler(&udc->gadget, true);\n\t\t\tusb_gadget_set_state(&udc->gadget, USB_STATE_POWERED);\n\t\t\tspin_lock(&udc->lock);\n\t\t} else {\n\t\t\tdev_dbg(udc->dev, \"handle vbus (0)\\n\");\n\t\t\tudc->is_usb_suspended = false;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tusb_udc_vbus_handler(&udc->gadget, false);\n\t\t\tusb_gadget_set_state(&udc->gadget,\n\t\t\t\t\t     USB_STATE_NOTATTACHED);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tfor (i = 1; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tif (sysbint & USBF_SYS_DMA_ENDINT_EPN(i)) {\n\t\t\tepn = &udc->ep[i];\n\t\t\tdev_dbg(epn->udc->dev,\n\t\t\t\t\"ep%u handle DMA complete. action=%ps\\n\",\n\t\t\t\tepn->id, epn->bridge_on_dma_end);\n\t\t\tep_action = epn->bridge_on_dma_end;\n\t\t\tif (ep_action) {\n\t\t\t\tepn->bridge_on_dma_end = NULL;\n\t\t\t\tep_action(epn);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int usbf_udc_start(struct usb_gadget *gadget,\n\t\t\t  struct usb_gadget_driver *driver)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\tunsigned long flags;\n\n\tdev_info(udc->dev, \"start (driver '%s')\\n\", driver->driver.name);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tudc->driver = driver;\n\n\t \n\tusbf_reg_writel(udc, USBF_REG_AHBBINTEN, USBF_SYS_VBUS_INTEN);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbf_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tusbf_reg_writel(udc, USBF_REG_AHBBINTEN, 0);\n\n\tudc->driver = NULL;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tdev_info(udc->dev, \"stopped\\n\");\n\n\treturn 0;\n}\n\nstatic int usbf_get_frame(struct usb_gadget *gadget)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\n\treturn USBF_USB_GET_FRAME(usbf_reg_readl(udc, USBF_REG_USB_ADDRESS));\n}\n\nstatic void usbf_attach(struct usbf_udc *udc)\n{\n\t \n\tusbf_reg_clrset(udc, USBF_REG_USB_CONTROL,\n\t\tUSBF_USB_CONNECTB | USBF_USB_DEFAULT | USBF_USB_CONF,\n\t\tUSBF_USB_PUE2);\n\n\t \n\tusbf_reg_bitset(udc, USBF_REG_USB_INT_ENA,\n\t\tUSBF_USB_USB_RST_EN | USBF_USB_SPEED_MODE_EN | USBF_USB_RSUM_EN | USBF_USB_SPND_EN);\n}\n\nstatic void usbf_detach(struct usbf_udc *udc)\n{\n\tint i;\n\n\t \n\tusbf_reg_writel(udc, USBF_REG_USB_INT_ENA, 0);\n\n\tfor (i = 0; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tif (udc->ep[i].disabled)\n\t\t\tcontinue;\n\n\t\tusbf_ep_reset(&udc->ep[i]);\n\t}\n\n\t \n\tusbf_reg_clrset(udc, USBF_REG_USB_CONTROL,\n\t\tUSBF_USB_PUE2 | USBF_USB_DEFAULT | USBF_USB_CONF,\n\t\tUSBF_USB_CONNECTB);\n}\n\nstatic int usbf_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\tunsigned long flags;\n\n\tdev_dbg(udc->dev, \"pullup %d\\n\", is_on);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (is_on)\n\t\tusbf_attach(udc);\n\telse\n\t\tusbf_detach(udc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbf_udc_set_selfpowered(struct usb_gadget *gadget,\n\t\t\t\t    int is_selfpowered)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tgadget->is_selfpowered = (is_selfpowered != 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbf_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct usbf_udc *udc = container_of(gadget, struct usbf_udc, gadget);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!udc->is_remote_wakeup) {\n\t\tdev_dbg(udc->dev, \"remote wakeup not allowed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tdev_dbg(udc->dev, \"do wakeup\\n\");\n\n\t \n\tusbf_reg_bitset(udc, USBF_REG_USB_CONTROL, USBF_USB_RSUM_IN);\n\tusbf_reg_bitclr(udc, USBF_REG_USB_CONTROL, USBF_USB_RSUM_IN);\n\n\tret = 0;\nend:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\nstatic struct usb_gadget_ops usbf_gadget_ops = {\n\t.get_frame = usbf_get_frame,\n\t.pullup = usbf_pullup,\n\t.udc_start = usbf_udc_start,\n\t.udc_stop = usbf_udc_stop,\n\t.set_selfpowered = usbf_udc_set_selfpowered,\n\t.wakeup = usbf_udc_wakeup,\n};\n\nstatic int usbf_epn_check(struct usbf_ep *epn)\n{\n\tconst char *type_txt;\n\tconst char *buf_txt;\n\tint ret = 0;\n\tu32 ctrl;\n\n\tctrl = usbf_ep_reg_readl(epn, USBF_REG_EPN_CONTROL);\n\n\tswitch (ctrl & USBF_EPN_MODE_MASK) {\n\tcase USBF_EPN_MODE_BULK:\n\t\ttype_txt = \"bulk\";\n\t\tif (epn->ep.caps.type_control || epn->ep.caps.type_iso ||\n\t\t    !epn->ep.caps.type_bulk || epn->ep.caps.type_int) {\n\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\"ep%u caps mismatch, bulk expected\\n\", epn->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USBF_EPN_MODE_INTR:\n\t\ttype_txt = \"intr\";\n\t\tif (epn->ep.caps.type_control || epn->ep.caps.type_iso ||\n\t\t    epn->ep.caps.type_bulk || !epn->ep.caps.type_int) {\n\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\"ep%u caps mismatch, int expected\\n\", epn->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USBF_EPN_MODE_ISO:\n\t\ttype_txt = \"iso\";\n\t\tif (epn->ep.caps.type_control || !epn->ep.caps.type_iso ||\n\t\t    epn->ep.caps.type_bulk || epn->ep.caps.type_int) {\n\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\"ep%u caps mismatch, iso expected\\n\", epn->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\ttype_txt = \"unknown\";\n\t\tdev_err(epn->udc->dev, \"ep%u unknown type\\n\", epn->id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ctrl & USBF_EPN_BUF_TYPE_DOUBLE) {\n\t\tbuf_txt = \"double\";\n\t\tif (!usbf_ep_info[epn->id].is_double) {\n\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\"ep%u buffer mismatch, double expected\\n\",\n\t\t\t\tepn->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tbuf_txt = \"single\";\n\t\tif (usbf_ep_info[epn->id].is_double) {\n\t\t\tdev_err(epn->udc->dev,\n\t\t\t\t\"ep%u buffer mismatch, single expected\\n\",\n\t\t\t\tepn->id);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\n\tdev_dbg(epn->udc->dev, \"ep%u (%s) %s, %s buffer %u, checked %s\\n\",\n\t\t epn->id, epn->ep.name, type_txt, buf_txt,\n\t\t epn->ep.maxpacket_limit, ret ? \"failed\" : \"ok\");\n\n\treturn ret;\n}\n\nstatic int usbf_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usbf_udc *udc;\n\tstruct usbf_ep *ep;\n\tunsigned int i;\n\tint irq;\n\tint ret;\n\n\tudc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, udc);\n\n\tudc->dev = dev;\n\tspin_lock_init(&udc->lock);\n\n\tudc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->regs))\n\t\treturn PTR_ERR(udc->regs);\n\n\tdevm_pm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_resume_and_get(&pdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev_info(dev, \"USBF version: %08x\\n\",\n\t\tusbf_reg_readl(udc, USBF_REG_USBSSVER));\n\n\t \n\tusbf_reg_bitclr(udc, USBF_REG_EPCTR, USBF_SYS_EPC_RST);\n\n\t \n\tudc->gadget.speed = USB_SPEED_FULL;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.ops = &usbf_gadget_ops;\n\n\tudc->gadget.name = dev->driver->name;\n\tudc->gadget.dev.parent = dev;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\n\t \n\tudc->gadget.quirk_avoids_skb_reserve = 1;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\t \n\tINIT_LIST_HEAD(&udc->setup_reply.queue);\n\n\tfor (i = 0; i < ARRAY_SIZE(udc->ep); i++) {\n\t\tep = &udc->ep[i];\n\n\t\tif (!(usbf_reg_readl(udc, USBF_REG_USBSSCONF) &\n\t\t      USBF_SYS_EP_AVAILABLE(i))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&ep->queue);\n\n\t\tep->id = i;\n\t\tep->disabled = 1;\n\t\tep->udc = udc;\n\t\tep->ep.ops = &usbf_ep_ops;\n\t\tep->ep.name = usbf_ep_info[i].name;\n\t\tep->ep.caps = usbf_ep_info[i].caps;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep,\n\t\t\t\t\t   usbf_ep_info[i].maxpacket_limit);\n\n\t\tif (ep->id == 0) {\n\t\t\tep->regs = ep->udc->regs + USBF_BASE_EP0;\n\t\t} else {\n\t\t\tep->regs = ep->udc->regs + USBF_BASE_EPN(ep->id - 1);\n\t\t\tret = usbf_epn_check(ep);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (usbf_reg_readl(udc, USBF_REG_USBSSCONF) &\n\t\t\t    USBF_SYS_DMA_AVAILABLE(i)) {\n\t\t\t\tep->dma_regs = ep->udc->regs +\n\t\t\t\t\t       USBF_BASE_DMA_EPN(ep->id - 1);\n\t\t\t}\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\t}\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(dev, irq, usbf_epc_irq, 0, \"usbf-epc\", udc);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot request irq %d err %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tirq = platform_get_irq(pdev, 1);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(dev, irq, usbf_ahb_epc_irq, 0, \"usbf-ahb-epc\", udc);\n\tif (ret) {\n\t\tdev_err(dev, \"cannot request irq %d err %d\\n\", irq, ret);\n\t\treturn ret;\n\t}\n\n\tusbf_reg_bitset(udc, USBF_REG_AHBMCTR, USBF_SYS_WBURST_TYPE);\n\n\tusbf_reg_bitset(udc, USBF_REG_USB_CONTROL,\n\t\tUSBF_USB_INT_SEL | USBF_USB_SOF_RCV | USBF_USB_SOF_CLK_MODE);\n\n\tret = usb_add_gadget_udc(dev, &udc->gadget);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void usbf_remove(struct platform_device *pdev)\n{\n\tstruct usbf_udc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tpm_runtime_put(&pdev->dev);\n}\n\nstatic const struct of_device_id usbf_match[] = {\n\t{ .compatible = \"renesas,rzn1-usbf\" },\n\t{}  \n};\nMODULE_DEVICE_TABLE(of, usbf_match);\n\nstatic struct platform_driver udc_driver = {\n\t.driver = {\n\t\t.name = \"usbf_renesas\",\n\t\t.of_match_table = usbf_match,\n\t},\n\t.probe          = usbf_probe,\n\t.remove_new     = usbf_remove,\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_AUTHOR(\"Herve Codina <herve.codina@bootlin.com>\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 & RZ/N1 USB Function driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}