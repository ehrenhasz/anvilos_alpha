{
  "module_name": "renesas_usb3.c",
  "hash_id": "ddc70ee41e6fa23d4b92370b6fc8b5bc88aa52ebc96ed97ca36d322af41d18aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/renesas_usb3.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/extcon-provider.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/of.h>\n#include <linux/usb/role.h>\n#include <linux/usb/rzv2m_usb3drd.h>\n\n \n#define USB3_AXI_INT_STA\t0x008\n#define USB3_AXI_INT_ENA\t0x00c\n#define USB3_DMA_INT_STA\t0x010\n#define USB3_DMA_INT_ENA\t0x014\n#define USB3_DMA_CH0_CON(n)\t(0x030 + ((n) - 1) * 0x10)  \n#define USB3_DMA_CH0_PRD_ADR(n)\t(0x034 + ((n) - 1) * 0x10)  \n#define USB3_USB_COM_CON\t0x200\n#define USB3_USB20_CON\t\t0x204\n#define USB3_USB30_CON\t\t0x208\n#define USB3_USB_STA\t\t0x210\n#define USB3_DRD_CON(p)\t\t((p)->is_rzv2m ? 0x400 : 0x218)\n#define USB3_USB_INT_STA_1\t0x220\n#define USB3_USB_INT_STA_2\t0x224\n#define USB3_USB_INT_ENA_1\t0x228\n#define USB3_USB_INT_ENA_2\t0x22c\n#define USB3_STUP_DAT_0\t\t0x230\n#define USB3_STUP_DAT_1\t\t0x234\n#define USB3_USB_OTG_STA(p)\t((p)->is_rzv2m ? 0x410 : 0x268)\n#define USB3_USB_OTG_INT_STA(p)\t((p)->is_rzv2m ? 0x414 : 0x26c)\n#define USB3_USB_OTG_INT_ENA(p)\t((p)->is_rzv2m ? 0x418 : 0x270)\n#define USB3_P0_MOD\t\t0x280\n#define USB3_P0_CON\t\t0x288\n#define USB3_P0_STA\t\t0x28c\n#define USB3_P0_INT_STA\t\t0x290\n#define USB3_P0_INT_ENA\t\t0x294\n#define USB3_P0_LNG\t\t0x2a0\n#define USB3_P0_READ\t\t0x2a4\n#define USB3_P0_WRITE\t\t0x2a8\n#define USB3_PIPE_COM\t\t0x2b0\n#define USB3_PN_MOD\t\t0x2c0\n#define USB3_PN_RAMMAP\t\t0x2c4\n#define USB3_PN_CON\t\t0x2c8\n#define USB3_PN_STA\t\t0x2cc\n#define USB3_PN_INT_STA\t\t0x2d0\n#define USB3_PN_INT_ENA\t\t0x2d4\n#define USB3_PN_LNG\t\t0x2e0\n#define USB3_PN_READ\t\t0x2e4\n#define USB3_PN_WRITE\t\t0x2e8\n#define USB3_SSIFCMD\t\t0x340\n\n \n#define AXI_INT_DMAINT\t\tBIT(31)\n#define AXI_INT_EPCINT\t\tBIT(30)\n \n#define AXI_INT_PRDEN_CLR_STA_SHIFT(n)\t(16 + (n) - 1)\n#define AXI_INT_PRDERR_STA_SHIFT(n)\t(0 + (n) - 1)\n#define AXI_INT_PRDEN_CLR_STA(n)\t(1 << AXI_INT_PRDEN_CLR_STA_SHIFT(n))\n#define AXI_INT_PRDERR_STA(n)\t\t(1 << AXI_INT_PRDERR_STA_SHIFT(n))\n\n \n#define DMA_INT(n)\t\tBIT(n)\n\n \n#define DMA_CON_PIPE_DIR\tBIT(15)\t\t \n#define DMA_CON_PIPE_NO_SHIFT\t8\n#define DMA_CON_PIPE_NO_MASK\tGENMASK(12, DMA_CON_PIPE_NO_SHIFT)\n#define DMA_COM_PIPE_NO(n)\t(((n) << DMA_CON_PIPE_NO_SHIFT) & \\\n\t\t\t\t\t DMA_CON_PIPE_NO_MASK)\n#define DMA_CON_PRD_EN\t\tBIT(0)\n\n \n#define LCLKSEL_LSEL\t\tBIT(18)\n\n \n#define USB_COM_CON_CONF\t\tBIT(24)\n#define USB_COM_CON_PN_WDATAIF_NL\tBIT(23)\n#define USB_COM_CON_PN_RDATAIF_NL\tBIT(22)\n#define USB_COM_CON_PN_LSTTR_PP\t\tBIT(21)\n#define USB_COM_CON_SPD_MODE\t\tBIT(17)\n#define USB_COM_CON_EP0_EN\t\tBIT(16)\n#define USB_COM_CON_DEV_ADDR_SHIFT\t8\n#define USB_COM_CON_DEV_ADDR_MASK\tGENMASK(14, USB_COM_CON_DEV_ADDR_SHIFT)\n#define USB_COM_CON_DEV_ADDR(n)\t\t(((n) << USB_COM_CON_DEV_ADDR_SHIFT) & \\\n\t\t\t\t\t USB_COM_CON_DEV_ADDR_MASK)\n#define USB_COM_CON_RX_DETECTION\tBIT(1)\n#define USB_COM_CON_PIPE_CLR\t\tBIT(0)\n\n \n#define USB20_CON_B2_PUE\t\tBIT(31)\n#define USB20_CON_B2_SUSPEND\t\tBIT(24)\n#define USB20_CON_B2_CONNECT\t\tBIT(17)\n#define USB20_CON_B2_TSTMOD_SHIFT\t8\n#define USB20_CON_B2_TSTMOD_MASK\tGENMASK(10, USB20_CON_B2_TSTMOD_SHIFT)\n#define USB20_CON_B2_TSTMOD(n)\t\t(((n) << USB20_CON_B2_TSTMOD_SHIFT) & \\\n\t\t\t\t\t USB20_CON_B2_TSTMOD_MASK)\n#define USB20_CON_B2_TSTMOD_EN\t\tBIT(0)\n\n \n#define USB30_CON_POW_SEL_SHIFT\t\t24\n#define USB30_CON_POW_SEL_MASK\t\tGENMASK(26, USB30_CON_POW_SEL_SHIFT)\n#define USB30_CON_POW_SEL_IN_U3\t\tBIT(26)\n#define USB30_CON_POW_SEL_IN_DISCON\t0\n#define USB30_CON_POW_SEL_P2_TO_P0\tBIT(25)\n#define USB30_CON_POW_SEL_P0_TO_P3\tBIT(24)\n#define USB30_CON_POW_SEL_P0_TO_P2\t0\n#define USB30_CON_B3_PLLWAKE\t\tBIT(23)\n#define USB30_CON_B3_CONNECT\t\tBIT(17)\n#define USB30_CON_B3_HOTRST_CMP\t\tBIT(1)\n\n \n#define USB_STA_SPEED_MASK\t(BIT(2) | BIT(1))\n#define USB_STA_SPEED_HS\tBIT(2)\n#define USB_STA_SPEED_FS\tBIT(1)\n#define USB_STA_SPEED_SS\t0\n#define USB_STA_VBUS_STA\tBIT(0)\n\n \n#define DRD_CON_PERI_RST\tBIT(31)\t\t \n#define DRD_CON_HOST_RST\tBIT(30)\t\t \n#define DRD_CON_PERI_CON\tBIT(24)\n#define DRD_CON_VBOUT\t\tBIT(0)\n\n \n#define USB_INT_1_B3_PLLWKUP\tBIT(31)\n#define USB_INT_1_B3_LUPSUCS\tBIT(30)\n#define USB_INT_1_B3_DISABLE\tBIT(27)\n#define USB_INT_1_B3_WRMRST\tBIT(21)\n#define USB_INT_1_B3_HOTRST\tBIT(20)\n#define USB_INT_1_B2_USBRST\tBIT(12)\n#define USB_INT_1_B2_L1SPND\tBIT(11)\n#define USB_INT_1_B2_SPND\tBIT(9)\n#define USB_INT_1_B2_RSUM\tBIT(8)\n#define USB_INT_1_SPEED\t\tBIT(1)\n#define USB_INT_1_VBUS_CNG\tBIT(0)\n\n \n#define USB_INT_2_PIPE(n)\tBIT(n)\n\n \n#define USB_OTG_IDMON(p)\t((p)->is_rzv2m ? BIT(0) : BIT(4))\n\n \n#define P0_MOD_DIR\t\tBIT(6)\n\n \n#define PX_CON_BYTE_EN_MASK\t\t(BIT(10) | BIT(9))\n#define PX_CON_BYTE_EN_SHIFT\t\t9\n#define PX_CON_BYTE_EN_BYTES(n)\t\t(((n) << PX_CON_BYTE_EN_SHIFT) & \\\n\t\t\t\t\t PX_CON_BYTE_EN_MASK)\n#define PX_CON_SEND\t\t\tBIT(8)\n\n \n#define P0_CON_ST_RES_MASK\t\t(BIT(27) | BIT(26))\n#define P0_CON_ST_RES_FORCE_STALL\tBIT(27)\n#define P0_CON_ST_RES_NORMAL\t\tBIT(26)\n#define P0_CON_ST_RES_FORCE_NRDY\t0\n#define P0_CON_OT_RES_MASK\t\t(BIT(25) | BIT(24))\n#define P0_CON_OT_RES_FORCE_STALL\tBIT(25)\n#define P0_CON_OT_RES_NORMAL\t\tBIT(24)\n#define P0_CON_OT_RES_FORCE_NRDY\t0\n#define P0_CON_IN_RES_MASK\t\t(BIT(17) | BIT(16))\n#define P0_CON_IN_RES_FORCE_STALL\tBIT(17)\n#define P0_CON_IN_RES_NORMAL\t\tBIT(16)\n#define P0_CON_IN_RES_FORCE_NRDY\t0\n#define P0_CON_RES_WEN\t\t\tBIT(7)\n#define P0_CON_BCLR\t\t\tBIT(1)\n\n \n#define PX_STA_BUFSTS\t\tBIT(0)\n\n \n#define P0_INT_STSED\t\tBIT(18)\n#define P0_INT_STSST\t\tBIT(17)\n#define P0_INT_SETUP\t\tBIT(16)\n#define P0_INT_RCVNL\t\tBIT(8)\n#define P0_INT_ERDY\t\tBIT(7)\n#define P0_INT_FLOW\t\tBIT(6)\n#define P0_INT_STALL\t\tBIT(2)\n#define P0_INT_NRDY\t\tBIT(1)\n#define P0_INT_BFRDY\t\tBIT(0)\n#define P0_INT_ALL_BITS\t\t(P0_INT_STSED | P0_INT_SETUP | P0_INT_BFRDY)\n\n \n#define PN_MOD_DIR\t\tBIT(6)\n#define PN_MOD_TYPE_SHIFT\t4\n#define PN_MOD_TYPE_MASK\tGENMASK(5, PN_MOD_TYPE_SHIFT)\n#define PN_MOD_TYPE(n)\t\t(((n) << PN_MOD_TYPE_SHIFT) & \\\n\t\t\t\t PN_MOD_TYPE_MASK)\n#define PN_MOD_EPNUM_MASK\tGENMASK(3, 0)\n#define PN_MOD_EPNUM(n)\t\t((n) & PN_MOD_EPNUM_MASK)\n\n \n#define PN_RAMMAP_RAMAREA_SHIFT\t29\n#define PN_RAMMAP_RAMAREA_MASK\tGENMASK(31, PN_RAMMAP_RAMAREA_SHIFT)\n#define PN_RAMMAP_RAMAREA_16KB\tBIT(31)\n#define PN_RAMMAP_RAMAREA_8KB\t(BIT(30) | BIT(29))\n#define PN_RAMMAP_RAMAREA_4KB\tBIT(30)\n#define PN_RAMMAP_RAMAREA_2KB\tBIT(29)\n#define PN_RAMMAP_RAMAREA_1KB\t0\n#define PN_RAMMAP_MPKT_SHIFT\t16\n#define PN_RAMMAP_MPKT_MASK\tGENMASK(26, PN_RAMMAP_MPKT_SHIFT)\n#define PN_RAMMAP_MPKT(n)\t(((n) << PN_RAMMAP_MPKT_SHIFT) & \\\n\t\t\t\t PN_RAMMAP_MPKT_MASK)\n#define PN_RAMMAP_RAMIF_SHIFT\t14\n#define PN_RAMMAP_RAMIF_MASK\tGENMASK(15, PN_RAMMAP_RAMIF_SHIFT)\n#define PN_RAMMAP_RAMIF(n)\t(((n) << PN_RAMMAP_RAMIF_SHIFT) & \\\n\t\t\t\t PN_RAMMAP_RAMIF_MASK)\n#define PN_RAMMAP_BASEAD_MASK\tGENMASK(13, 0)\n#define PN_RAMMAP_BASEAD(offs)\t(((offs) >> 3) & PN_RAMMAP_BASEAD_MASK)\n#define PN_RAMMAP_DATA(area, ramif, basead)\t((PN_RAMMAP_##area) | \\\n\t\t\t\t\t\t (PN_RAMMAP_RAMIF(ramif)) | \\\n\t\t\t\t\t\t (PN_RAMMAP_BASEAD(basead)))\n\n \n#define PN_CON_EN\t\tBIT(31)\n#define PN_CON_DATAIF_EN\tBIT(30)\n#define PN_CON_RES_MASK\t\t(BIT(17) | BIT(16))\n#define PN_CON_RES_FORCE_STALL\tBIT(17)\n#define PN_CON_RES_NORMAL\tBIT(16)\n#define PN_CON_RES_FORCE_NRDY\t0\n#define PN_CON_LAST\t\tBIT(11)\n#define PN_CON_RES_WEN\t\tBIT(7)\n#define PN_CON_CLR\t\tBIT(0)\n\n \n#define PN_INT_LSTTR\tBIT(4)\n#define PN_INT_BFRDY\tBIT(0)\n\n \n#define SSIFCMD_URES_U2\t\tBIT(9)\n#define SSIFCMD_URES_U1\t\tBIT(8)\n#define SSIFCMD_UDIR_U2\t\tBIT(7)\n#define SSIFCMD_UDIR_U1\t\tBIT(6)\n#define SSIFCMD_UREQ_U2\t\tBIT(5)\n#define SSIFCMD_UREQ_U1\t\tBIT(4)\n\n#define USB3_EP0_SS_MAX_PACKET_SIZE\t512\n#define USB3_EP0_HSFS_MAX_PACKET_SIZE\t64\n#define USB3_EP0_BUF_SIZE\t\t8\n#define USB3_MAX_NUM_PIPES(p)\t\t((p)->is_rzv2m ? 16 : 6)\t \n#define USB3_WAIT_US\t\t\t3\n#define USB3_DMA_NUM_SETTING_AREA\t4\n \n#define USB3_DMA_MAX_XFER_SIZE\t\t32768\n#define USB3_DMA_PRD_SIZE\t\t4096\n\nstruct renesas_usb3;\n\n \nstruct renesas_usb3_prd {\n\tu32 word1;\n#define USB3_PRD1_E\t\tBIT(30)\t\t \n#define USB3_PRD1_U\t\tBIT(29)\t\t \n#define USB3_PRD1_D\t\tBIT(28)\t\t \n#define USB3_PRD1_INT\t\tBIT(27)\t\t \n#define USB3_PRD1_LST\t\tBIT(26)\t\t \n#define USB3_PRD1_B_INC\t\tBIT(24)\n#define USB3_PRD1_MPS_8\t\t0\n#define USB3_PRD1_MPS_16\tBIT(21)\n#define USB3_PRD1_MPS_32\tBIT(22)\n#define USB3_PRD1_MPS_64\t(BIT(22) | BIT(21))\n#define USB3_PRD1_MPS_512\tBIT(23)\n#define USB3_PRD1_MPS_1024\t(BIT(23) | BIT(21))\n#define USB3_PRD1_MPS_RESERVED\t(BIT(23) | BIT(22) | BIT(21))\n#define USB3_PRD1_SIZE_MASK\tGENMASK(15, 0)\n\n\tu32 bap;\n};\n#define USB3_DMA_NUM_PRD_ENTRIES\t(USB3_DMA_PRD_SIZE / \\\n\t\t\t\t\t  sizeof(struct renesas_usb3_prd))\n#define USB3_DMA_MAX_XFER_SIZE_ALL_PRDS\t(USB3_DMA_PRD_SIZE / \\\n\t\t\t\t\t sizeof(struct renesas_usb3_prd) * \\\n\t\t\t\t\t USB3_DMA_MAX_XFER_SIZE)\n\nstruct renesas_usb3_dma {\n\tstruct renesas_usb3_prd *prd;\n\tdma_addr_t prd_dma;\n\tint num;\t \n\tbool used;\n};\n\nstruct renesas_usb3_request {\n\tstruct usb_request\treq;\n\tstruct list_head\tqueue;\n};\n\n#define USB3_EP_NAME_SIZE\t8\nstruct renesas_usb3_ep {\n\tstruct usb_ep ep;\n\tstruct renesas_usb3 *usb3;\n\tstruct renesas_usb3_dma *dma;\n\tint num;\n\tchar ep_name[USB3_EP_NAME_SIZE];\n\tstruct list_head queue;\n\tu32 rammap_val;\n\tbool dir_in;\n\tbool halt;\n\tbool wedge;\n\tbool started;\n};\n\nstruct renesas_usb3_priv {\n\tint ramsize_per_ramif;\t\t \n\tint num_ramif;\n\tint ramsize_per_pipe;\t\t \n\tbool workaround_for_vbus;\t \n\tbool is_rzv2m;\t\t\t \n};\n\nstruct renesas_usb3 {\n\tvoid __iomem *reg;\n\tvoid __iomem *drd_reg;\n\tstruct reset_control *usbp_rstc;\n\n\tstruct usb_gadget gadget;\n\tstruct usb_gadget_driver *driver;\n\tstruct extcon_dev *extcon;\n\tstruct work_struct extcon_work;\n\tstruct phy *phy;\n\tstruct dentry *dentry;\n\n\tstruct usb_role_switch *role_sw;\n\tstruct device *host_dev;\n\tstruct work_struct role_work;\n\tenum usb_role role;\n\n\tstruct renesas_usb3_ep *usb3_ep;\n\tint num_usb3_eps;\n\n\tstruct renesas_usb3_dma dma[USB3_DMA_NUM_SETTING_AREA];\n\n\tspinlock_t lock;\n\tint disabled_count;\n\n\tstruct usb_request *ep0_req;\n\n\tenum usb_role connection_state;\n\tu16 test_mode;\n\tu8 ep0_buf[USB3_EP0_BUF_SIZE];\n\tbool softconnect;\n\tbool workaround_for_vbus;\n\tbool extcon_host;\t\t \n\tbool extcon_usb;\t\t \n\tbool forced_b_device;\n\tbool start_to_connect;\n\tbool role_sw_by_connector;\n\tbool is_rzv2m;\n};\n\n#define gadget_to_renesas_usb3(_gadget)\t\\\n\t\tcontainer_of(_gadget, struct renesas_usb3, gadget)\n#define renesas_usb3_to_gadget(renesas_usb3) (&renesas_usb3->gadget)\n#define usb3_to_dev(_usb3)\t(_usb3->gadget.dev.parent)\n\n#define usb_ep_to_usb3_ep(_ep) container_of(_ep, struct renesas_usb3_ep, ep)\n#define usb3_ep_to_usb3(_usb3_ep) (_usb3_ep->usb3)\n#define usb_req_to_usb3_req(_req) container_of(_req, \\\n\t\t\t\t\t    struct renesas_usb3_request, req)\n\n#define usb3_get_ep(usb3, n) ((usb3)->usb3_ep + (n))\n#define usb3_for_each_ep(usb3_ep, usb3, i)\t\t\t\\\n\t\tfor ((i) = 0, usb3_ep = usb3_get_ep(usb3, (i));\t\\\n\t\t     (i) < (usb3)->num_usb3_eps;\t\t\\\n\t\t     (i)++, usb3_ep = usb3_get_ep(usb3, (i)))\n\n#define usb3_get_dma(usb3, i)\t(&(usb3)->dma[i])\n#define usb3_for_each_dma(usb3, dma, i)\t\t\t\t\\\n\t\tfor ((i) = 0, dma = usb3_get_dma((usb3), (i));\t\\\n\t\t     (i) < USB3_DMA_NUM_SETTING_AREA;\t\t\\\n\t\t     (i)++, dma = usb3_get_dma((usb3), (i)))\n\nstatic const char udc_name[] = \"renesas_usb3\";\n\nstatic bool use_dma = 1;\nmodule_param(use_dma, bool, 0644);\nMODULE_PARM_DESC(use_dma, \"use dedicated DMAC\");\n\nstatic void usb3_write(struct renesas_usb3 *usb3, u32 data, u32 offs)\n{\n\tiowrite32(data, usb3->reg + offs);\n}\n\nstatic u32 usb3_read(struct renesas_usb3 *usb3, u32 offs)\n{\n\treturn ioread32(usb3->reg + offs);\n}\n\nstatic void usb3_set_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\n{\n\tu32 val = usb3_read(usb3, offs);\n\n\tval |= bits;\n\tusb3_write(usb3, val, offs);\n}\n\nstatic void usb3_clear_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\n{\n\tu32 val = usb3_read(usb3, offs);\n\n\tval &= ~bits;\n\tusb3_write(usb3, val, offs);\n}\n\nstatic void usb3_drd_write(struct renesas_usb3 *usb3, u32 data, u32 offs)\n{\n\tvoid __iomem *reg;\n\n\tif (usb3->is_rzv2m)\n\t\treg = usb3->drd_reg + offs - USB3_DRD_CON(usb3);\n\telse\n\t\treg = usb3->reg + offs;\n\n\tiowrite32(data, reg);\n}\n\nstatic u32 usb3_drd_read(struct renesas_usb3 *usb3, u32 offs)\n{\n\tvoid __iomem *reg;\n\n\tif (usb3->is_rzv2m)\n\t\treg = usb3->drd_reg + offs - USB3_DRD_CON(usb3);\n\telse\n\t\treg = usb3->reg + offs;\n\n\treturn ioread32(reg);\n}\n\nstatic void usb3_drd_set_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\n{\n\tu32 val = usb3_drd_read(usb3, offs);\n\n\tval |= bits;\n\tusb3_drd_write(usb3, val, offs);\n}\n\nstatic void usb3_drd_clear_bit(struct renesas_usb3 *usb3, u32 bits, u32 offs)\n{\n\tu32 val = usb3_drd_read(usb3, offs);\n\n\tval &= ~bits;\n\tusb3_drd_write(usb3, val, offs);\n}\n\nstatic int usb3_wait(struct renesas_usb3 *usb3, u32 reg, u32 mask,\n\t\t     u32 expected)\n{\n\tint i;\n\n\tfor (i = 0; i < USB3_WAIT_US; i++) {\n\t\tif ((usb3_read(usb3, reg) & mask) == expected)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\tdev_dbg(usb3_to_dev(usb3), \"%s: timed out (%8x, %08x, %08x)\\n\",\n\t\t__func__, reg, mask, expected);\n\n\treturn -EBUSY;\n}\n\nstatic void renesas_usb3_extcon_work(struct work_struct *work)\n{\n\tstruct renesas_usb3 *usb3 = container_of(work, struct renesas_usb3,\n\t\t\t\t\t\t extcon_work);\n\n\textcon_set_state_sync(usb3->extcon, EXTCON_USB_HOST, usb3->extcon_host);\n\textcon_set_state_sync(usb3->extcon, EXTCON_USB, usb3->extcon_usb);\n}\n\nstatic void usb3_enable_irq_1(struct renesas_usb3 *usb3, u32 bits)\n{\n\tusb3_set_bit(usb3, bits, USB3_USB_INT_ENA_1);\n}\n\nstatic void usb3_disable_irq_1(struct renesas_usb3 *usb3, u32 bits)\n{\n\tusb3_clear_bit(usb3, bits, USB3_USB_INT_ENA_1);\n}\n\nstatic void usb3_enable_pipe_irq(struct renesas_usb3 *usb3, int num)\n{\n\tusb3_set_bit(usb3, USB_INT_2_PIPE(num), USB3_USB_INT_ENA_2);\n}\n\nstatic void usb3_disable_pipe_irq(struct renesas_usb3 *usb3, int num)\n{\n\tusb3_clear_bit(usb3, USB_INT_2_PIPE(num), USB3_USB_INT_ENA_2);\n}\n\nstatic bool usb3_is_host(struct renesas_usb3 *usb3)\n{\n\treturn !(usb3_drd_read(usb3, USB3_DRD_CON(usb3)) & DRD_CON_PERI_CON);\n}\n\nstatic void usb3_init_axi_bridge(struct renesas_usb3 *usb3)\n{\n\t \n\tusb3_write(usb3, ~0, USB3_DMA_INT_STA);\n\tusb3_write(usb3, 0, USB3_DMA_INT_ENA);\n\tusb3_set_bit(usb3, AXI_INT_DMAINT | AXI_INT_EPCINT, USB3_AXI_INT_ENA);\n}\n\nstatic void usb3_init_epc_registers(struct renesas_usb3 *usb3)\n{\n\tusb3_write(usb3, ~0, USB3_USB_INT_STA_1);\n\tif (!usb3->workaround_for_vbus)\n\t\tusb3_enable_irq_1(usb3, USB_INT_1_VBUS_CNG);\n}\n\nstatic bool usb3_wakeup_usb2_phy(struct renesas_usb3 *usb3)\n{\n\tif (!(usb3_read(usb3, USB3_USB20_CON) & USB20_CON_B2_SUSPEND))\n\t\treturn true;\t \n\n\tusb3_clear_bit(usb3, USB20_CON_B2_SUSPEND, USB3_USB20_CON);\n\tusb3_enable_irq_1(usb3, USB_INT_1_B2_RSUM);\n\n\treturn false;\n}\n\nstatic void usb3_usb2_pullup(struct renesas_usb3 *usb3, int pullup)\n{\n\tu32 bits = USB20_CON_B2_PUE | USB20_CON_B2_CONNECT;\n\n\tif (usb3->softconnect && pullup)\n\t\tusb3_set_bit(usb3, bits, USB3_USB20_CON);\n\telse\n\t\tusb3_clear_bit(usb3, bits, USB3_USB20_CON);\n}\n\nstatic void usb3_set_test_mode(struct renesas_usb3 *usb3)\n{\n\tu32 val = usb3_read(usb3, USB3_USB20_CON);\n\n\tval &= ~USB20_CON_B2_TSTMOD_MASK;\n\tval |= USB20_CON_B2_TSTMOD(usb3->test_mode);\n\tusb3_write(usb3, val | USB20_CON_B2_TSTMOD_EN, USB3_USB20_CON);\n\tif (!usb3->test_mode)\n\t\tusb3_clear_bit(usb3, USB20_CON_B2_TSTMOD_EN, USB3_USB20_CON);\n}\n\nstatic void usb3_start_usb2_connection(struct renesas_usb3 *usb3)\n{\n\tusb3->disabled_count++;\n\tusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\n\tusb3_set_bit(usb3, USB_COM_CON_SPD_MODE, USB3_USB_COM_CON);\n\tusb3_usb2_pullup(usb3, 1);\n}\n\nstatic int usb3_is_usb3_phy_in_u3(struct renesas_usb3 *usb3)\n{\n\treturn usb3_read(usb3, USB3_USB30_CON) & USB30_CON_POW_SEL_IN_U3;\n}\n\nstatic bool usb3_wakeup_usb3_phy(struct renesas_usb3 *usb3)\n{\n\tif (!usb3_is_usb3_phy_in_u3(usb3))\n\t\treturn true;\t \n\n\tusb3_set_bit(usb3, USB30_CON_B3_PLLWAKE, USB3_USB30_CON);\n\tusb3_enable_irq_1(usb3, USB_INT_1_B3_PLLWKUP);\n\n\treturn false;\n}\n\nstatic u16 usb3_feature_get_un_enabled(struct renesas_usb3 *usb3)\n{\n\tu32 mask_u2 = SSIFCMD_UDIR_U2 | SSIFCMD_UREQ_U2;\n\tu32 mask_u1 = SSIFCMD_UDIR_U1 | SSIFCMD_UREQ_U1;\n\tu32 val = usb3_read(usb3, USB3_SSIFCMD);\n\tu16 ret = 0;\n\n\t \n\tif (!(val & mask_u2))\n\t\tret |= 1 << USB_DEV_STAT_U2_ENABLED;\n\tif (!(val & mask_u1))\n\t\tret |= 1 << USB_DEV_STAT_U1_ENABLED;\n\n\treturn ret;\n}\n\nstatic void usb3_feature_u2_enable(struct renesas_usb3 *usb3, bool enable)\n{\n\tu32 bits = SSIFCMD_UDIR_U2 | SSIFCMD_UREQ_U2;\n\n\t \n\tif (enable)\n\t\tusb3_clear_bit(usb3, bits, USB3_SSIFCMD);\n\telse\n\t\tusb3_set_bit(usb3, bits, USB3_SSIFCMD);\n}\n\nstatic void usb3_feature_u1_enable(struct renesas_usb3 *usb3, bool enable)\n{\n\tu32 bits = SSIFCMD_UDIR_U1 | SSIFCMD_UREQ_U1;\n\n\t \n\tif (enable)\n\t\tusb3_clear_bit(usb3, bits, USB3_SSIFCMD);\n\telse\n\t\tusb3_set_bit(usb3, bits, USB3_SSIFCMD);\n}\n\nstatic void usb3_start_operation_for_usb3(struct renesas_usb3 *usb3)\n{\n\tusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\n\tusb3_clear_bit(usb3, USB_COM_CON_SPD_MODE, USB3_USB_COM_CON);\n\tusb3_set_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\n}\n\nstatic void usb3_start_usb3_connection(struct renesas_usb3 *usb3)\n{\n\tusb3_start_operation_for_usb3(usb3);\n\tusb3_set_bit(usb3, USB_COM_CON_RX_DETECTION, USB3_USB_COM_CON);\n\n\tusb3_enable_irq_1(usb3, USB_INT_1_B3_LUPSUCS | USB_INT_1_B3_DISABLE |\n\t\t\t  USB_INT_1_SPEED);\n}\n\nstatic void usb3_stop_usb3_connection(struct renesas_usb3 *usb3)\n{\n\tusb3_clear_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\n}\n\nstatic void usb3_transition_to_default_state(struct renesas_usb3 *usb3,\n\t\t\t\t\t     bool is_usb3)\n{\n\tusb3_set_bit(usb3, USB_INT_2_PIPE(0), USB3_USB_INT_ENA_2);\n\tusb3_write(usb3, P0_INT_ALL_BITS, USB3_P0_INT_STA);\n\tusb3_set_bit(usb3, P0_INT_ALL_BITS, USB3_P0_INT_ENA);\n\n\tif (is_usb3)\n\t\tusb3_enable_irq_1(usb3, USB_INT_1_B3_WRMRST |\n\t\t\t\t  USB_INT_1_B3_HOTRST);\n\telse\n\t\tusb3_enable_irq_1(usb3, USB_INT_1_B2_SPND |\n\t\t\t\t  USB_INT_1_B2_L1SPND | USB_INT_1_B2_USBRST);\n}\n\nstatic void usb3_connect(struct renesas_usb3 *usb3)\n{\n\tif (usb3_wakeup_usb3_phy(usb3))\n\t\tusb3_start_usb3_connection(usb3);\n}\n\nstatic void usb3_reset_epc(struct renesas_usb3 *usb3)\n{\n\tusb3_clear_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\n\tusb3_clear_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\n\tusb3_set_bit(usb3, USB_COM_CON_PIPE_CLR, USB3_USB_COM_CON);\n\tusb3->test_mode = 0;\n\tusb3_set_test_mode(usb3);\n}\n\nstatic void usb3_disconnect(struct renesas_usb3 *usb3)\n{\n\tusb3->disabled_count = 0;\n\tusb3_usb2_pullup(usb3, 0);\n\tusb3_clear_bit(usb3, USB30_CON_B3_CONNECT, USB3_USB30_CON);\n\tusb3_reset_epc(usb3);\n\tusb3_disable_irq_1(usb3, USB_INT_1_B2_RSUM | USB_INT_1_B3_PLLWKUP |\n\t\t\t   USB_INT_1_B3_LUPSUCS | USB_INT_1_B3_DISABLE |\n\t\t\t   USB_INT_1_SPEED | USB_INT_1_B3_WRMRST |\n\t\t\t   USB_INT_1_B3_HOTRST | USB_INT_1_B2_SPND |\n\t\t\t   USB_INT_1_B2_L1SPND | USB_INT_1_B2_USBRST);\n\tusb3_clear_bit(usb3, USB_COM_CON_SPD_MODE, USB3_USB_COM_CON);\n\tusb3_init_epc_registers(usb3);\n\n\tif (usb3->driver)\n\t\tusb3->driver->disconnect(&usb3->gadget);\n}\n\nstatic void usb3_check_vbus(struct renesas_usb3 *usb3)\n{\n\tif (usb3->workaround_for_vbus) {\n\t\tusb3_connect(usb3);\n\t} else {\n\t\tusb3->extcon_usb = !!(usb3_read(usb3, USB3_USB_STA) &\n\t\t\t\t\t\t\tUSB_STA_VBUS_STA);\n\t\tif (usb3->extcon_usb)\n\t\t\tusb3_connect(usb3);\n\t\telse\n\t\t\tusb3_disconnect(usb3);\n\n\t\tschedule_work(&usb3->extcon_work);\n\t}\n}\n\nstatic void renesas_usb3_role_work(struct work_struct *work)\n{\n\tstruct renesas_usb3 *usb3 =\n\t\t\tcontainer_of(work, struct renesas_usb3, role_work);\n\n\tusb_role_switch_set_role(usb3->role_sw, usb3->role);\n}\n\nstatic void usb3_set_mode(struct renesas_usb3 *usb3, bool host)\n{\n\tif (usb3->is_rzv2m) {\n\t\tif (host) {\n\t\t\tusb3_drd_set_bit(usb3, DRD_CON_PERI_RST, USB3_DRD_CON(usb3));\n\t\t\tusb3_drd_clear_bit(usb3, DRD_CON_HOST_RST, USB3_DRD_CON(usb3));\n\t\t} else {\n\t\t\tusb3_drd_set_bit(usb3, DRD_CON_HOST_RST, USB3_DRD_CON(usb3));\n\t\t\tusb3_drd_clear_bit(usb3, DRD_CON_PERI_RST, USB3_DRD_CON(usb3));\n\t\t}\n\t}\n\n\tif (host)\n\t\tusb3_drd_clear_bit(usb3, DRD_CON_PERI_CON, USB3_DRD_CON(usb3));\n\telse\n\t\tusb3_drd_set_bit(usb3, DRD_CON_PERI_CON, USB3_DRD_CON(usb3));\n}\n\nstatic void usb3_set_mode_by_role_sw(struct renesas_usb3 *usb3, bool host)\n{\n\tif (usb3->role_sw) {\n\t\tusb3->role = host ? USB_ROLE_HOST : USB_ROLE_DEVICE;\n\t\tschedule_work(&usb3->role_work);\n\t} else {\n\t\tusb3_set_mode(usb3, host);\n\t}\n}\n\nstatic void usb3_vbus_out(struct renesas_usb3 *usb3, bool enable)\n{\n\tif (enable)\n\t\tusb3_drd_set_bit(usb3, DRD_CON_VBOUT, USB3_DRD_CON(usb3));\n\telse\n\t\tusb3_drd_clear_bit(usb3, DRD_CON_VBOUT, USB3_DRD_CON(usb3));\n}\n\nstatic void usb3_mode_config(struct renesas_usb3 *usb3, bool host, bool a_dev)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (!usb3->role_sw_by_connector ||\n\t    usb3->connection_state != USB_ROLE_NONE) {\n\t\tusb3_set_mode_by_role_sw(usb3, host);\n\t\tusb3_vbus_out(usb3, a_dev);\n\t}\n\t \n\tif ((!host && a_dev) || usb3->start_to_connect)\n\t\tusb3_connect(usb3);\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n}\n\nstatic bool usb3_is_a_device(struct renesas_usb3 *usb3)\n{\n\treturn !(usb3_drd_read(usb3, USB3_USB_OTG_STA(usb3)) & USB_OTG_IDMON(usb3));\n}\n\nstatic void usb3_check_id(struct renesas_usb3 *usb3)\n{\n\tusb3->extcon_host = usb3_is_a_device(usb3);\n\n\tif ((!usb3->role_sw_by_connector && usb3->extcon_host &&\n\t     !usb3->forced_b_device) || usb3->connection_state == USB_ROLE_HOST)\n\t\tusb3_mode_config(usb3, true, true);\n\telse\n\t\tusb3_mode_config(usb3, false, false);\n\n\tschedule_work(&usb3->extcon_work);\n}\n\nstatic void renesas_usb3_init_controller(struct renesas_usb3 *usb3)\n{\n\tusb3_init_axi_bridge(usb3);\n\tusb3_init_epc_registers(usb3);\n\tusb3_set_bit(usb3, USB_COM_CON_PN_WDATAIF_NL |\n\t\t     USB_COM_CON_PN_RDATAIF_NL | USB_COM_CON_PN_LSTTR_PP,\n\t\t     USB3_USB_COM_CON);\n\tusb3_drd_write(usb3, USB_OTG_IDMON(usb3), USB3_USB_OTG_INT_STA(usb3));\n\tusb3_drd_write(usb3, USB_OTG_IDMON(usb3), USB3_USB_OTG_INT_ENA(usb3));\n\n\tusb3_check_id(usb3);\n\tusb3_check_vbus(usb3);\n}\n\nstatic void renesas_usb3_stop_controller(struct renesas_usb3 *usb3)\n{\n\tusb3_disconnect(usb3);\n\tusb3_write(usb3, 0, USB3_P0_INT_ENA);\n\tusb3_drd_write(usb3, 0, USB3_USB_OTG_INT_ENA(usb3));\n\tusb3_write(usb3, 0, USB3_USB_INT_ENA_1);\n\tusb3_write(usb3, 0, USB3_USB_INT_ENA_2);\n\tusb3_write(usb3, 0, USB3_AXI_INT_ENA);\n}\n\nstatic void usb3_irq_epc_int_1_pll_wakeup(struct renesas_usb3 *usb3)\n{\n\tusb3_disable_irq_1(usb3, USB_INT_1_B3_PLLWKUP);\n\tusb3_clear_bit(usb3, USB30_CON_B3_PLLWAKE, USB3_USB30_CON);\n\tusb3_start_usb3_connection(usb3);\n}\n\nstatic void usb3_irq_epc_int_1_linkup_success(struct renesas_usb3 *usb3)\n{\n\tusb3_transition_to_default_state(usb3, true);\n}\n\nstatic void usb3_irq_epc_int_1_resume(struct renesas_usb3 *usb3)\n{\n\tusb3_disable_irq_1(usb3, USB_INT_1_B2_RSUM);\n\tusb3_start_usb2_connection(usb3);\n\tusb3_transition_to_default_state(usb3, false);\n}\n\nstatic void usb3_irq_epc_int_1_suspend(struct renesas_usb3 *usb3)\n{\n\tusb3_disable_irq_1(usb3, USB_INT_1_B2_SPND);\n\n\tif (usb3->gadget.speed != USB_SPEED_UNKNOWN &&\n\t    usb3->gadget.state != USB_STATE_NOTATTACHED) {\n\t\tif (usb3->driver && usb3->driver->suspend)\n\t\t\tusb3->driver->suspend(&usb3->gadget);\n\t\tusb_gadget_set_state(&usb3->gadget, USB_STATE_SUSPENDED);\n\t}\n}\n\nstatic void usb3_irq_epc_int_1_disable(struct renesas_usb3 *usb3)\n{\n\tusb3_stop_usb3_connection(usb3);\n\tif (usb3_wakeup_usb2_phy(usb3))\n\t\tusb3_irq_epc_int_1_resume(usb3);\n}\n\nstatic void usb3_irq_epc_int_1_bus_reset(struct renesas_usb3 *usb3)\n{\n\tusb3_reset_epc(usb3);\n\tif (usb3->disabled_count < 3)\n\t\tusb3_start_usb3_connection(usb3);\n\telse\n\t\tusb3_start_usb2_connection(usb3);\n}\n\nstatic void usb3_irq_epc_int_1_vbus_change(struct renesas_usb3 *usb3)\n{\n\tusb3_check_vbus(usb3);\n}\n\nstatic void usb3_irq_epc_int_1_hot_reset(struct renesas_usb3 *usb3)\n{\n\tusb3_reset_epc(usb3);\n\tusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\n\n\t \n\tusb3_set_bit(usb3, USB30_CON_B3_HOTRST_CMP, USB3_USB30_CON);\n}\n\nstatic void usb3_irq_epc_int_1_warm_reset(struct renesas_usb3 *usb3)\n{\n\tusb3_reset_epc(usb3);\n\tusb3_set_bit(usb3, USB_COM_CON_EP0_EN, USB3_USB_COM_CON);\n\n\tusb3_start_operation_for_usb3(usb3);\n\tusb3_enable_irq_1(usb3, USB_INT_1_SPEED);\n}\n\nstatic void usb3_irq_epc_int_1_speed(struct renesas_usb3 *usb3)\n{\n\tu32 speed = usb3_read(usb3, USB3_USB_STA) & USB_STA_SPEED_MASK;\n\n\tswitch (speed) {\n\tcase USB_STA_SPEED_SS:\n\t\tusb3->gadget.speed = USB_SPEED_SUPER;\n\t\tusb3->gadget.ep0->maxpacket = USB3_EP0_SS_MAX_PACKET_SIZE;\n\t\tbreak;\n\tcase USB_STA_SPEED_HS:\n\t\tusb3->gadget.speed = USB_SPEED_HIGH;\n\t\tusb3->gadget.ep0->maxpacket = USB3_EP0_HSFS_MAX_PACKET_SIZE;\n\t\tbreak;\n\tcase USB_STA_SPEED_FS:\n\t\tusb3->gadget.speed = USB_SPEED_FULL;\n\t\tusb3->gadget.ep0->maxpacket = USB3_EP0_HSFS_MAX_PACKET_SIZE;\n\t\tbreak;\n\tdefault:\n\t\tusb3->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n}\n\nstatic void usb3_irq_epc_int_1(struct renesas_usb3 *usb3, u32 int_sta_1)\n{\n\tif (int_sta_1 & USB_INT_1_B3_PLLWKUP)\n\t\tusb3_irq_epc_int_1_pll_wakeup(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B3_LUPSUCS)\n\t\tusb3_irq_epc_int_1_linkup_success(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B3_HOTRST)\n\t\tusb3_irq_epc_int_1_hot_reset(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B3_WRMRST)\n\t\tusb3_irq_epc_int_1_warm_reset(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B3_DISABLE)\n\t\tusb3_irq_epc_int_1_disable(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B2_USBRST)\n\t\tusb3_irq_epc_int_1_bus_reset(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B2_RSUM)\n\t\tusb3_irq_epc_int_1_resume(usb3);\n\n\tif (int_sta_1 & USB_INT_1_B2_SPND)\n\t\tusb3_irq_epc_int_1_suspend(usb3);\n\n\tif (int_sta_1 & USB_INT_1_SPEED)\n\t\tusb3_irq_epc_int_1_speed(usb3);\n\n\tif (int_sta_1 & USB_INT_1_VBUS_CNG)\n\t\tusb3_irq_epc_int_1_vbus_change(usb3);\n}\n\nstatic struct renesas_usb3_request *__usb3_get_request(struct renesas_usb3_ep\n\t\t\t\t\t\t       *usb3_ep)\n{\n\treturn list_first_entry_or_null(&usb3_ep->queue,\n\t\t\t\t\tstruct renesas_usb3_request, queue);\n}\n\nstatic struct renesas_usb3_request *usb3_get_request(struct renesas_usb3_ep\n\t\t\t\t\t\t     *usb3_ep)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tstruct renesas_usb3_request *usb3_req;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tusb3_req = __usb3_get_request(usb3_ep);\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\treturn usb3_req;\n}\n\nstatic void __usb3_request_done(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\tstruct renesas_usb3_request *usb3_req,\n\t\t\t\tint status)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tdev_dbg(usb3_to_dev(usb3), \"giveback: ep%2d, %u, %u, %d\\n\",\n\t\tusb3_ep->num, usb3_req->req.length, usb3_req->req.actual,\n\t\tstatus);\n\tusb3_req->req.status = status;\n\tusb3_ep->started = false;\n\tlist_del_init(&usb3_req->queue);\n\tspin_unlock(&usb3->lock);\n\tusb_gadget_giveback_request(&usb3_ep->ep, &usb3_req->req);\n\tspin_lock(&usb3->lock);\n}\n\nstatic void usb3_request_done(struct renesas_usb3_ep *usb3_ep,\n\t\t\t      struct renesas_usb3_request *usb3_req, int status)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\t__usb3_request_done(usb3_ep, usb3_req, status);\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n}\n\nstatic void usb3_irq_epc_pipe0_status_end(struct renesas_usb3 *usb3)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\n\tstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\n\n\tif (usb3_req)\n\t\tusb3_request_done(usb3_ep, usb3_req, 0);\n\tif (usb3->test_mode)\n\t\tusb3_set_test_mode(usb3);\n}\n\nstatic void usb3_get_setup_data(struct renesas_usb3 *usb3,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\n\tu32 *data = (u32 *)ctrl;\n\n\t*data++ = usb3_read(usb3, USB3_STUP_DAT_0);\n\t*data = usb3_read(usb3, USB3_STUP_DAT_1);\n\n\t \n\tusb3_ep->dir_in = !!(ctrl->bRequestType & USB_DIR_IN);\n}\n\nstatic void usb3_set_p0_con_update_res(struct renesas_usb3 *usb3, u32 res)\n{\n\tu32 val = usb3_read(usb3, USB3_P0_CON);\n\n\tval &= ~(P0_CON_ST_RES_MASK | P0_CON_OT_RES_MASK | P0_CON_IN_RES_MASK);\n\tval |= res | P0_CON_RES_WEN;\n\tusb3_write(usb3, val, USB3_P0_CON);\n}\n\nstatic void usb3_set_p0_con_for_ctrl_read_data(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\n\t\t\t\t   P0_CON_OT_RES_FORCE_STALL |\n\t\t\t\t   P0_CON_IN_RES_NORMAL);\n}\n\nstatic void usb3_set_p0_con_for_ctrl_read_status(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\n\t\t\t\t   P0_CON_OT_RES_FORCE_STALL |\n\t\t\t\t   P0_CON_IN_RES_NORMAL);\n}\n\nstatic void usb3_set_p0_con_for_ctrl_write_data(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\n\t\t\t\t   P0_CON_OT_RES_NORMAL |\n\t\t\t\t   P0_CON_IN_RES_FORCE_STALL);\n}\n\nstatic void usb3_set_p0_con_for_ctrl_write_status(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\n\t\t\t\t   P0_CON_OT_RES_NORMAL |\n\t\t\t\t   P0_CON_IN_RES_FORCE_STALL);\n}\n\nstatic void usb3_set_p0_con_for_no_data(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_NORMAL |\n\t\t\t\t   P0_CON_OT_RES_FORCE_STALL |\n\t\t\t\t   P0_CON_IN_RES_FORCE_STALL);\n}\n\nstatic void usb3_set_p0_con_stall(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_STALL |\n\t\t\t\t   P0_CON_OT_RES_FORCE_STALL |\n\t\t\t\t   P0_CON_IN_RES_FORCE_STALL);\n}\n\nstatic void usb3_set_p0_con_stop(struct renesas_usb3 *usb3)\n{\n\tusb3_set_p0_con_update_res(usb3, P0_CON_ST_RES_FORCE_NRDY |\n\t\t\t\t   P0_CON_OT_RES_FORCE_NRDY |\n\t\t\t\t   P0_CON_IN_RES_FORCE_NRDY);\n}\n\nstatic int usb3_pn_change(struct renesas_usb3 *usb3, int num)\n{\n\tif (num == 0 || num > usb3->num_usb3_eps)\n\t\treturn -ENXIO;\n\n\tusb3_write(usb3, num, USB3_PIPE_COM);\n\n\treturn 0;\n}\n\nstatic void usb3_set_pn_con_update_res(struct renesas_usb3 *usb3, u32 res)\n{\n\tu32 val = usb3_read(usb3, USB3_PN_CON);\n\n\tval &= ~PN_CON_RES_MASK;\n\tval |= res & PN_CON_RES_MASK;\n\tval |= PN_CON_RES_WEN;\n\tusb3_write(usb3, val, USB3_PN_CON);\n}\n\nstatic void usb3_pn_start(struct renesas_usb3 *usb3)\n{\n\tusb3_set_pn_con_update_res(usb3, PN_CON_RES_NORMAL);\n}\n\nstatic void usb3_pn_stop(struct renesas_usb3 *usb3)\n{\n\tusb3_set_pn_con_update_res(usb3, PN_CON_RES_FORCE_NRDY);\n}\n\nstatic void usb3_pn_stall(struct renesas_usb3 *usb3)\n{\n\tusb3_set_pn_con_update_res(usb3, PN_CON_RES_FORCE_STALL);\n}\n\nstatic int usb3_pn_con_clear(struct renesas_usb3 *usb3)\n{\n\tusb3_set_bit(usb3, PN_CON_CLR, USB3_PN_CON);\n\n\treturn usb3_wait(usb3, USB3_PN_CON, PN_CON_CLR, 0);\n}\n\nstatic bool usb3_is_transfer_complete(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t      struct renesas_usb3_request *usb3_req)\n{\n\tstruct usb_request *req = &usb3_req->req;\n\n\tif ((!req->zero && req->actual == req->length) ||\n\t    (req->actual % usb3_ep->ep.maxpacket) || (req->length == 0))\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int usb3_wait_pipe_status(struct renesas_usb3_ep *usb3_ep, u32 mask)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tu32 sta_reg = usb3_ep->num ? USB3_PN_STA : USB3_P0_STA;\n\n\treturn usb3_wait(usb3, sta_reg, mask, mask);\n}\n\nstatic void usb3_set_px_con_send(struct renesas_usb3_ep *usb3_ep, int bytes,\n\t\t\t\t bool last)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tu32 con_reg = usb3_ep->num ? USB3_PN_CON : USB3_P0_CON;\n\tu32 val = usb3_read(usb3, con_reg);\n\n\tval |= PX_CON_SEND | PX_CON_BYTE_EN_BYTES(bytes);\n\tval |= (usb3_ep->num && last) ? PN_CON_LAST : 0;\n\tusb3_write(usb3, val, con_reg);\n}\n\nstatic int usb3_write_pipe(struct renesas_usb3_ep *usb3_ep,\n\t\t\t   struct renesas_usb3_request *usb3_req,\n\t\t\t   u32 fifo_reg)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tint i;\n\tint len = min_t(unsigned, usb3_req->req.length - usb3_req->req.actual,\n\t\t\tusb3_ep->ep.maxpacket);\n\tu8 *buf = usb3_req->req.buf + usb3_req->req.actual;\n\tu32 tmp = 0;\n\tbool is_last = !len ? true : false;\n\n\tif (usb3_wait_pipe_status(usb3_ep, PX_STA_BUFSTS) < 0)\n\t\treturn -EBUSY;\n\n\t \n\tusb3_req->req.actual += len;\n\n\t \n\tif (len >= 4) {\n\t\tiowrite32_rep(usb3->reg + fifo_reg, buf, len / 4);\n\t\tbuf += (len / 4) * 4;\n\t\tlen %= 4;\t \n\t}\n\n\tif (len) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\ttmp |= buf[i] << (8 * i);\n\t\tusb3_write(usb3, tmp, fifo_reg);\n\t}\n\n\tif (!is_last)\n\t\tis_last = usb3_is_transfer_complete(usb3_ep, usb3_req);\n\t \n\tusb3_set_px_con_send(usb3_ep, len, is_last);\n\n\treturn is_last ? 0 : -EAGAIN;\n}\n\nstatic u32 usb3_get_received_length(struct renesas_usb3_ep *usb3_ep)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tu32 lng_reg = usb3_ep->num ? USB3_PN_LNG : USB3_P0_LNG;\n\n\treturn usb3_read(usb3, lng_reg);\n}\n\nstatic int usb3_read_pipe(struct renesas_usb3_ep *usb3_ep,\n\t\t\t  struct renesas_usb3_request *usb3_req, u32 fifo_reg)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tint i;\n\tint len = min_t(unsigned, usb3_req->req.length - usb3_req->req.actual,\n\t\t\tusb3_get_received_length(usb3_ep));\n\tu8 *buf = usb3_req->req.buf + usb3_req->req.actual;\n\tu32 tmp = 0;\n\n\tif (!len)\n\t\treturn 0;\n\n\t \n\tusb3_req->req.actual += len;\n\n\t \n\tif (len >= 4) {\n\t\tioread32_rep(usb3->reg + fifo_reg, buf, len / 4);\n\t\tbuf += (len / 4) * 4;\n\t\tlen %= 4;\n\t}\n\n\tif (len) {\n\t\ttmp = usb3_read(usb3, fifo_reg);\n\t\tfor (i = 0; i < len; i++)\n\t\t\tbuf[i] = (tmp >> (8 * i)) & 0xff;\n\t}\n\n\treturn usb3_is_transfer_complete(usb3_ep, usb3_req) ? 0 : -EAGAIN;\n}\n\nstatic void usb3_set_status_stage(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t  struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tif (usb3_ep->dir_in) {\n\t\tusb3_set_p0_con_for_ctrl_read_status(usb3);\n\t} else {\n\t\tif (!usb3_req->req.length)\n\t\t\tusb3_set_p0_con_for_no_data(usb3);\n\t\telse\n\t\t\tusb3_set_p0_con_for_ctrl_write_status(usb3);\n\t}\n}\n\nstatic void usb3_p0_xfer(struct renesas_usb3_ep *usb3_ep,\n\t\t\t struct renesas_usb3_request *usb3_req)\n{\n\tint ret;\n\n\tif (usb3_ep->dir_in)\n\t\tret = usb3_write_pipe(usb3_ep, usb3_req, USB3_P0_WRITE);\n\telse\n\t\tret = usb3_read_pipe(usb3_ep, usb3_req, USB3_P0_READ);\n\n\tif (!ret)\n\t\tusb3_set_status_stage(usb3_ep, usb3_req);\n}\n\nstatic void usb3_start_pipe0(struct renesas_usb3_ep *usb3_ep,\n\t\t\t     struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tif (usb3_ep->started)\n\t\treturn;\n\n\tusb3_ep->started = true;\n\n\tif (usb3_ep->dir_in) {\n\t\tusb3_set_bit(usb3, P0_MOD_DIR, USB3_P0_MOD);\n\t\tusb3_set_p0_con_for_ctrl_read_data(usb3);\n\t} else {\n\t\tusb3_clear_bit(usb3, P0_MOD_DIR, USB3_P0_MOD);\n\t\tif (usb3_req->req.length)\n\t\t\tusb3_set_p0_con_for_ctrl_write_data(usb3);\n\t}\n\n\tusb3_p0_xfer(usb3_ep, usb3_req);\n}\n\nstatic void usb3_enable_dma_pipen(struct renesas_usb3 *usb3)\n{\n\tusb3_set_bit(usb3, PN_CON_DATAIF_EN, USB3_PN_CON);\n}\n\nstatic void usb3_disable_dma_pipen(struct renesas_usb3 *usb3)\n{\n\tusb3_clear_bit(usb3, PN_CON_DATAIF_EN, USB3_PN_CON);\n}\n\nstatic void usb3_enable_dma_irq(struct renesas_usb3 *usb3, int num)\n{\n\tusb3_set_bit(usb3, DMA_INT(num), USB3_DMA_INT_ENA);\n}\n\nstatic void usb3_disable_dma_irq(struct renesas_usb3 *usb3, int num)\n{\n\tusb3_clear_bit(usb3, DMA_INT(num), USB3_DMA_INT_ENA);\n}\n\nstatic u32 usb3_dma_mps_to_prd_word1(struct renesas_usb3_ep *usb3_ep)\n{\n\tswitch (usb3_ep->ep.maxpacket) {\n\tcase 8:\n\t\treturn USB3_PRD1_MPS_8;\n\tcase 16:\n\t\treturn USB3_PRD1_MPS_16;\n\tcase 32:\n\t\treturn USB3_PRD1_MPS_32;\n\tcase 64:\n\t\treturn USB3_PRD1_MPS_64;\n\tcase 512:\n\t\treturn USB3_PRD1_MPS_512;\n\tcase 1024:\n\t\treturn USB3_PRD1_MPS_1024;\n\tdefault:\n\t\treturn USB3_PRD1_MPS_RESERVED;\n\t}\n}\n\nstatic bool usb3_dma_get_setting_area(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t      struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tstruct renesas_usb3_dma *dma;\n\tint i;\n\tbool ret = false;\n\n\tif (usb3_req->req.length > USB3_DMA_MAX_XFER_SIZE_ALL_PRDS) {\n\t\tdev_dbg(usb3_to_dev(usb3), \"%s: the length is too big (%d)\\n\",\n\t\t\t__func__, usb3_req->req.length);\n\t\treturn false;\n\t}\n\n\t \n\tif (!usb3_req->req.length)\n\t\treturn false;\n\n\tif (usb3_dma_mps_to_prd_word1(usb3_ep) == USB3_PRD1_MPS_RESERVED)\n\t\treturn false;\n\n\tusb3_for_each_dma(usb3, dma, i) {\n\t\tif (dma->used)\n\t\t\tcontinue;\n\n\t\tif (usb_gadget_map_request(&usb3->gadget, &usb3_req->req,\n\t\t\t\t\t   usb3_ep->dir_in) < 0)\n\t\t\tbreak;\n\n\t\tdma->used = true;\n\t\tusb3_ep->dma = dma;\n\t\tret = true;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb3_dma_put_setting_area(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t      struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tint i;\n\tstruct renesas_usb3_dma *dma;\n\n\tusb3_for_each_dma(usb3, dma, i) {\n\t\tif (usb3_ep->dma == dma) {\n\t\t\tusb_gadget_unmap_request(&usb3->gadget, &usb3_req->req,\n\t\t\t\t\t\t usb3_ep->dir_in);\n\t\t\tdma->used = false;\n\t\t\tusb3_ep->dma = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void usb3_dma_fill_prd(struct renesas_usb3_ep *usb3_ep,\n\t\t\t      struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3_prd *cur_prd = usb3_ep->dma->prd;\n\tu32 remain = usb3_req->req.length;\n\tu32 dma = usb3_req->req.dma;\n\tu32 len;\n\tint i = 0;\n\n\tdo {\n\t\tlen = min_t(u32, remain, USB3_DMA_MAX_XFER_SIZE) &\n\t\t\t    USB3_PRD1_SIZE_MASK;\n\t\tcur_prd->word1 = usb3_dma_mps_to_prd_word1(usb3_ep) |\n\t\t\t\t USB3_PRD1_B_INC | len;\n\t\tcur_prd->bap = dma;\n\t\tremain -= len;\n\t\tdma += len;\n\t\tif (!remain || (i + 1) < USB3_DMA_NUM_PRD_ENTRIES)\n\t\t\tbreak;\n\n\t\tcur_prd++;\n\t\ti++;\n\t} while (1);\n\n\tcur_prd->word1 |= USB3_PRD1_E | USB3_PRD1_INT;\n\tif (usb3_ep->dir_in)\n\t\tcur_prd->word1 |= USB3_PRD1_LST;\n}\n\nstatic void usb3_dma_kick_prd(struct renesas_usb3_ep *usb3_ep)\n{\n\tstruct renesas_usb3_dma *dma = usb3_ep->dma;\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tu32 dma_con = DMA_COM_PIPE_NO(usb3_ep->num) | DMA_CON_PRD_EN;\n\n\tif (usb3_ep->dir_in)\n\t\tdma_con |= DMA_CON_PIPE_DIR;\n\n\twmb();\t \n\n\tusb3_write(usb3, 1 << usb3_ep->num, USB3_DMA_INT_STA);\n\tusb3_write(usb3, AXI_INT_PRDEN_CLR_STA(dma->num) |\n\t\t   AXI_INT_PRDERR_STA(dma->num), USB3_AXI_INT_STA);\n\n\tusb3_write(usb3, dma->prd_dma, USB3_DMA_CH0_PRD_ADR(dma->num));\n\tusb3_write(usb3, dma_con, USB3_DMA_CH0_CON(dma->num));\n\tusb3_enable_dma_irq(usb3, usb3_ep->num);\n}\n\nstatic void usb3_dma_stop_prd(struct renesas_usb3_ep *usb3_ep)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tstruct renesas_usb3_dma *dma = usb3_ep->dma;\n\n\tusb3_disable_dma_irq(usb3, usb3_ep->num);\n\tusb3_write(usb3, 0, USB3_DMA_CH0_CON(dma->num));\n}\n\nstatic int usb3_dma_update_status(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t  struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3_prd *cur_prd = usb3_ep->dma->prd;\n\tstruct usb_request *req = &usb3_req->req;\n\tu32 remain, len;\n\tint i = 0;\n\tint status = 0;\n\n\trmb();\t \n\n\tdo {\n\t\tif (cur_prd->word1 & USB3_PRD1_D)\n\t\t\tstatus = -EIO;\n\t\tif (cur_prd->word1 & USB3_PRD1_E)\n\t\t\tlen = req->length % USB3_DMA_MAX_XFER_SIZE;\n\t\telse\n\t\t\tlen = USB3_DMA_MAX_XFER_SIZE;\n\t\tremain = cur_prd->word1 & USB3_PRD1_SIZE_MASK;\n\t\treq->actual += len - remain;\n\n\t\tif (cur_prd->word1 & USB3_PRD1_E ||\n\t\t    (i + 1) < USB3_DMA_NUM_PRD_ENTRIES)\n\t\t\tbreak;\n\n\t\tcur_prd++;\n\t\ti++;\n\t} while (1);\n\n\treturn status;\n}\n\nstatic bool usb3_dma_try_start(struct renesas_usb3_ep *usb3_ep,\n\t\t\t       struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tif (!use_dma)\n\t\treturn false;\n\n\tif (usb3_dma_get_setting_area(usb3_ep, usb3_req)) {\n\t\tusb3_pn_stop(usb3);\n\t\tusb3_enable_dma_pipen(usb3);\n\t\tusb3_dma_fill_prd(usb3_ep, usb3_req);\n\t\tusb3_dma_kick_prd(usb3_ep);\n\t\tusb3_pn_start(usb3);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int usb3_dma_try_stop(struct renesas_usb3_ep *usb3_ep,\n\t\t\t     struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\tint status = 0;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (!usb3_ep->dma)\n\t\tgoto out;\n\n\tif (!usb3_pn_change(usb3, usb3_ep->num))\n\t\tusb3_disable_dma_pipen(usb3);\n\tusb3_dma_stop_prd(usb3_ep);\n\tstatus = usb3_dma_update_status(usb3_ep, usb3_req);\n\tusb3_dma_put_setting_area(usb3_ep, usb3_req);\n\nout:\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\treturn status;\n}\n\nstatic int renesas_usb3_dma_free_prd(struct renesas_usb3 *usb3,\n\t\t\t\t     struct device *dev)\n{\n\tint i;\n\tstruct renesas_usb3_dma *dma;\n\n\tusb3_for_each_dma(usb3, dma, i) {\n\t\tif (dma->prd) {\n\t\t\tdma_free_coherent(dev, USB3_DMA_PRD_SIZE,\n\t\t\t\t\t  dma->prd, dma->prd_dma);\n\t\t\tdma->prd = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_dma_alloc_prd(struct renesas_usb3 *usb3,\n\t\t\t\t      struct device *dev)\n{\n\tint i;\n\tstruct renesas_usb3_dma *dma;\n\n\tif (!use_dma)\n\t\treturn 0;\n\n\tusb3_for_each_dma(usb3, dma, i) {\n\t\tdma->prd = dma_alloc_coherent(dev, USB3_DMA_PRD_SIZE,\n\t\t\t\t\t      &dma->prd_dma, GFP_KERNEL);\n\t\tif (!dma->prd) {\n\t\t\trenesas_usb3_dma_free_prd(usb3, dev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tdma->num = i + 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void usb3_start_pipen(struct renesas_usb3_ep *usb3_ep,\n\t\t\t     struct renesas_usb3_request *usb3_req)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tstruct renesas_usb3_request *usb3_req_first;\n\tunsigned long flags;\n\tint ret = -EAGAIN;\n\tu32 enable_bits = 0;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (usb3_ep->halt || usb3_ep->started)\n\t\tgoto out;\n\tusb3_req_first = __usb3_get_request(usb3_ep);\n\tif (!usb3_req_first || usb3_req != usb3_req_first)\n\t\tgoto out;\n\n\tif (usb3_pn_change(usb3, usb3_ep->num) < 0)\n\t\tgoto out;\n\n\tusb3_ep->started = true;\n\n\tif (usb3_dma_try_start(usb3_ep, usb3_req))\n\t\tgoto out;\n\n\tusb3_pn_start(usb3);\n\n\tif (usb3_ep->dir_in) {\n\t\tret = usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE);\n\t\tenable_bits |= PN_INT_LSTTR;\n\t}\n\n\tif (ret < 0)\n\t\tenable_bits |= PN_INT_BFRDY;\n\n\tif (enable_bits) {\n\t\tusb3_set_bit(usb3, enable_bits, USB3_PN_INT_ENA);\n\t\tusb3_enable_pipe_irq(usb3, usb3_ep->num);\n\t}\nout:\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n}\n\nstatic int renesas_usb3_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\tstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tdev_dbg(usb3_to_dev(usb3), \"ep_queue: ep%2d, %u\\n\", usb3_ep->num,\n\t\t_req->length);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tlist_add_tail(&usb3_req->queue, &usb3_ep->queue);\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\tif (!usb3_ep->num)\n\t\tusb3_start_pipe0(usb3_ep, usb3_req);\n\telse\n\t\tusb3_start_pipen(usb3_ep, usb3_req);\n\n\treturn 0;\n}\n\nstatic void usb3_set_device_address(struct renesas_usb3 *usb3, u16 addr)\n{\n\t \n\tusb3_set_bit(usb3, USB_COM_CON_DEV_ADDR(addr), USB3_USB_COM_CON);\n}\n\nstatic bool usb3_std_req_set_address(struct renesas_usb3 *usb3,\n\t\t\t\t     struct usb_ctrlrequest *ctrl)\n{\n\tif (le16_to_cpu(ctrl->wValue) >= 128)\n\t\treturn true;\t \n\n\tusb3_set_device_address(usb3, le16_to_cpu(ctrl->wValue));\n\tusb3_set_p0_con_for_no_data(usb3);\n\n\treturn false;\n}\n\nstatic void usb3_pipe0_internal_xfer(struct renesas_usb3 *usb3,\n\t\t\t\t     void *tx_data, size_t len,\n\t\t\t\t     void (*complete)(struct usb_ep *ep,\n\t\t\t\t\t\t      struct usb_request *req))\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\n\n\tif (tx_data)\n\t\tmemcpy(usb3->ep0_buf, tx_data,\n\t\t       min_t(size_t, len, USB3_EP0_BUF_SIZE));\n\n\tusb3->ep0_req->buf = &usb3->ep0_buf;\n\tusb3->ep0_req->length = len;\n\tusb3->ep0_req->complete = complete;\n\trenesas_usb3_ep_queue(&usb3_ep->ep, usb3->ep0_req, GFP_ATOMIC);\n}\n\nstatic void usb3_pipe0_get_status_completion(struct usb_ep *ep,\n\t\t\t\t\t     struct usb_request *req)\n{\n}\n\nstatic bool usb3_std_req_get_status(struct renesas_usb3 *usb3,\n\t\t\t\t    struct usb_ctrlrequest *ctrl)\n{\n\tbool stall = false;\n\tstruct renesas_usb3_ep *usb3_ep;\n\tint num;\n\tu16 status = 0;\n\t__le16 tx_data;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tif (usb3->gadget.is_selfpowered)\n\t\t\tstatus |= 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (usb3->gadget.speed == USB_SPEED_SUPER)\n\t\t\tstatus |= usb3_feature_get_un_enabled(usb3);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tnum = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\t\tusb3_ep = usb3_get_ep(usb3, num);\n\t\tif (usb3_ep->halt)\n\t\t\tstatus |= 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tstall = true;\n\t\tbreak;\n\t}\n\n\tif (!stall) {\n\t\ttx_data = cpu_to_le16(status);\n\t\tdev_dbg(usb3_to_dev(usb3), \"get_status: req = %p\\n\",\n\t\t\tusb_req_to_usb3_req(usb3->ep0_req));\n\t\tusb3_pipe0_internal_xfer(usb3, &tx_data, sizeof(tx_data),\n\t\t\t\t\t usb3_pipe0_get_status_completion);\n\t}\n\n\treturn stall;\n}\n\nstatic bool usb3_std_req_feature_device(struct renesas_usb3 *usb3,\n\t\t\t\t\tstruct usb_ctrlrequest *ctrl, bool set)\n{\n\tbool stall = true;\n\tu16 w_value = le16_to_cpu(ctrl->wValue);\n\n\tswitch (w_value) {\n\tcase USB_DEVICE_TEST_MODE:\n\t\tif (!set)\n\t\t\tbreak;\n\t\tusb3->test_mode = le16_to_cpu(ctrl->wIndex) >> 8;\n\t\tstall = false;\n\t\tbreak;\n\tcase USB_DEVICE_U1_ENABLE:\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tif (usb3->gadget.speed != USB_SPEED_SUPER)\n\t\t\tbreak;\n\t\tif (w_value == USB_DEVICE_U1_ENABLE)\n\t\t\tusb3_feature_u1_enable(usb3, set);\n\t\tif (w_value == USB_DEVICE_U2_ENABLE)\n\t\t\tusb3_feature_u2_enable(usb3, set);\n\t\tstall = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn stall;\n}\n\nstatic int usb3_set_halt_p0(struct renesas_usb3_ep *usb3_ep, bool halt)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tif (unlikely(usb3_ep->num))\n\t\treturn -EINVAL;\n\n\tusb3_ep->halt = halt;\n\tif (halt)\n\t\tusb3_set_p0_con_stall(usb3);\n\telse\n\t\tusb3_set_p0_con_stop(usb3);\n\n\treturn 0;\n}\n\nstatic int usb3_set_halt_pn(struct renesas_usb3_ep *usb3_ep, bool halt,\n\t\t\t    bool is_clear_feature)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (!usb3_pn_change(usb3, usb3_ep->num)) {\n\t\tusb3_ep->halt = halt;\n\t\tif (halt) {\n\t\t\tusb3_pn_stall(usb3);\n\t\t} else if (!is_clear_feature || !usb3_ep->wedge) {\n\t\t\tusb3_pn_con_clear(usb3);\n\t\t\tusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\n\t\t\tusb3_pn_stop(usb3);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usb3_set_halt(struct renesas_usb3_ep *usb3_ep, bool halt,\n\t\t\t bool is_clear_feature)\n{\n\tint ret = 0;\n\n\tif (halt && usb3_ep->started)\n\t\treturn -EAGAIN;\n\n\tif (usb3_ep->num)\n\t\tret = usb3_set_halt_pn(usb3_ep, halt, is_clear_feature);\n\telse\n\t\tret = usb3_set_halt_p0(usb3_ep, halt);\n\n\treturn ret;\n}\n\nstatic bool usb3_std_req_feature_endpoint(struct renesas_usb3 *usb3,\n\t\t\t\t\t  struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t  bool set)\n{\n\tint num = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\tstruct renesas_usb3_ep *usb3_ep;\n\tstruct renesas_usb3_request *usb3_req;\n\n\tif (le16_to_cpu(ctrl->wValue) != USB_ENDPOINT_HALT)\n\t\treturn true;\t \n\n\tusb3_ep = usb3_get_ep(usb3, num);\n\tusb3_set_halt(usb3_ep, set, true);\n\n\t \n\tif (!set) {\n\t\tusb3_ep->started = false;\n\t\tusb3_req = usb3_get_request(usb3_ep);\n\t\tif (usb3_req)\n\t\t\tusb3_start_pipen(usb3_ep, usb3_req);\n\t}\n\n\treturn false;\n}\n\nstatic bool usb3_std_req_feature(struct renesas_usb3 *usb3,\n\t\t\t\t struct usb_ctrlrequest *ctrl, bool set)\n{\n\tbool stall = false;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstall = usb3_std_req_feature_device(usb3, ctrl, set);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tstall = usb3_std_req_feature_endpoint(usb3, ctrl, set);\n\t\tbreak;\n\tdefault:\n\t\tstall = true;\n\t\tbreak;\n\t}\n\n\tif (!stall)\n\t\tusb3_set_p0_con_for_no_data(usb3);\n\n\treturn stall;\n}\n\nstatic void usb3_pipe0_set_sel_completion(struct usb_ep *ep,\n\t\t\t\t\t  struct usb_request *req)\n{\n\t \n}\n\nstatic bool usb3_std_req_set_sel(struct renesas_usb3 *usb3,\n\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tu16 w_length = le16_to_cpu(ctrl->wLength);\n\n\tif (w_length != 6)\n\t\treturn true;\t \n\n\tdev_dbg(usb3_to_dev(usb3), \"set_sel: req = %p\\n\",\n\t\tusb_req_to_usb3_req(usb3->ep0_req));\n\tusb3_pipe0_internal_xfer(usb3, NULL, 6, usb3_pipe0_set_sel_completion);\n\n\treturn false;\n}\n\nstatic bool usb3_std_req_set_configuration(struct renesas_usb3 *usb3,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl)\n{\n\tif (le16_to_cpu(ctrl->wValue) > 0)\n\t\tusb3_set_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\n\telse\n\t\tusb3_clear_bit(usb3, USB_COM_CON_CONF, USB3_USB_COM_CON);\n\n\treturn false;\n}\n\n \nstatic bool usb3_handle_standard_request(struct renesas_usb3 *usb3,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tbool ret = false;\n\tbool stall = false;\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tstall = usb3_std_req_set_address(usb3, ctrl);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tstall = usb3_std_req_get_status(usb3, ctrl);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tstall = usb3_std_req_feature(usb3, ctrl, false);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tstall = usb3_std_req_feature(usb3, ctrl, true);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_SEL:\n\t\t\tstall = usb3_std_req_set_sel(usb3, ctrl);\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\t\t \n\t\t\tstall = true;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tusb3_std_req_set_configuration(usb3, ctrl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (stall)\n\t\tusb3_set_p0_con_stall(usb3);\n\n\treturn ret;\n}\n\nstatic int usb3_p0_con_clear_buffer(struct renesas_usb3 *usb3)\n{\n\tusb3_set_bit(usb3, P0_CON_BCLR, USB3_P0_CON);\n\n\treturn usb3_wait(usb3, USB3_P0_CON, P0_CON_BCLR, 0);\n}\n\nstatic void usb3_irq_epc_pipe0_setup(struct renesas_usb3 *usb3)\n{\n\tstruct usb_ctrlrequest ctrl;\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\n\n\t \n\tif (usb3_ep->started)\n\t\tusb3_request_done(usb3_ep, usb3_get_request(usb3_ep),\n\t\t\t\t  -ECONNRESET);\n\n\tusb3_p0_con_clear_buffer(usb3);\n\tusb3_get_setup_data(usb3, &ctrl);\n\tif (!usb3_handle_standard_request(usb3, &ctrl))\n\t\tif (usb3->driver->setup(&usb3->gadget, &ctrl) < 0)\n\t\t\tusb3_set_p0_con_stall(usb3);\n}\n\nstatic void usb3_irq_epc_pipe0_bfrdy(struct renesas_usb3 *usb3)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, 0);\n\tstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\n\n\tif (!usb3_req)\n\t\treturn;\n\n\tusb3_p0_xfer(usb3_ep, usb3_req);\n}\n\nstatic void usb3_irq_epc_pipe0(struct renesas_usb3 *usb3)\n{\n\tu32 p0_int_sta = usb3_read(usb3, USB3_P0_INT_STA);\n\n\tp0_int_sta &= usb3_read(usb3, USB3_P0_INT_ENA);\n\tusb3_write(usb3, p0_int_sta, USB3_P0_INT_STA);\n\tif (p0_int_sta & P0_INT_STSED)\n\t\tusb3_irq_epc_pipe0_status_end(usb3);\n\tif (p0_int_sta & P0_INT_SETUP)\n\t\tusb3_irq_epc_pipe0_setup(usb3);\n\tif (p0_int_sta & P0_INT_BFRDY)\n\t\tusb3_irq_epc_pipe0_bfrdy(usb3);\n}\n\nstatic void usb3_request_done_pipen(struct renesas_usb3 *usb3,\n\t\t\t\t    struct renesas_usb3_ep *usb3_ep,\n\t\t\t\t    struct renesas_usb3_request *usb3_req,\n\t\t\t\t    int status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (usb3_pn_change(usb3, usb3_ep->num))\n\t\tusb3_pn_stop(usb3);\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\tusb3_disable_pipe_irq(usb3, usb3_ep->num);\n\tusb3_request_done(usb3_ep, usb3_req, status);\n\n\t \n\tusb3_req = usb3_get_request(usb3_ep);\n\tif (usb3_req)\n\t\tusb3_start_pipen(usb3_ep, usb3_req);\n}\n\nstatic void usb3_irq_epc_pipen_lsttr(struct renesas_usb3 *usb3, int num)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);\n\tstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\n\n\tif (!usb3_req)\n\t\treturn;\n\n\tif (usb3_ep->dir_in) {\n\t\tdev_dbg(usb3_to_dev(usb3), \"%s: len = %u, actual = %u\\n\",\n\t\t\t__func__, usb3_req->req.length, usb3_req->req.actual);\n\t\tusb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);\n\t}\n}\n\nstatic void usb3_irq_epc_pipen_bfrdy(struct renesas_usb3 *usb3, int num)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);\n\tstruct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);\n\tbool done = false;\n\n\tif (!usb3_req)\n\t\treturn;\n\n\tspin_lock(&usb3->lock);\n\tif (usb3_pn_change(usb3, num))\n\t\tgoto out;\n\n\tif (usb3_ep->dir_in) {\n\t\t \n\t\tif (!usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE))\n\t\t\tusb3_clear_bit(usb3, PN_INT_BFRDY, USB3_PN_INT_ENA);\n\t} else {\n\t\tif (!usb3_read_pipe(usb3_ep, usb3_req, USB3_PN_READ))\n\t\t\tdone = true;\n\t}\n\nout:\n\t \n\tspin_unlock(&usb3->lock);\n\n\tif (done)\n\t\tusb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);\n}\n\nstatic void usb3_irq_epc_pipen(struct renesas_usb3 *usb3, int num)\n{\n\tu32 pn_int_sta;\n\n\tspin_lock(&usb3->lock);\n\tif (usb3_pn_change(usb3, num) < 0) {\n\t\tspin_unlock(&usb3->lock);\n\t\treturn;\n\t}\n\n\tpn_int_sta = usb3_read(usb3, USB3_PN_INT_STA);\n\tpn_int_sta &= usb3_read(usb3, USB3_PN_INT_ENA);\n\tusb3_write(usb3, pn_int_sta, USB3_PN_INT_STA);\n\tspin_unlock(&usb3->lock);\n\tif (pn_int_sta & PN_INT_LSTTR)\n\t\tusb3_irq_epc_pipen_lsttr(usb3, num);\n\tif (pn_int_sta & PN_INT_BFRDY)\n\t\tusb3_irq_epc_pipen_bfrdy(usb3, num);\n}\n\nstatic void usb3_irq_epc_int_2(struct renesas_usb3 *usb3, u32 int_sta_2)\n{\n\tint i;\n\n\tfor (i = 0; i < usb3->num_usb3_eps; i++) {\n\t\tif (int_sta_2 & USB_INT_2_PIPE(i)) {\n\t\t\tif (!i)\n\t\t\t\tusb3_irq_epc_pipe0(usb3);\n\t\t\telse\n\t\t\t\tusb3_irq_epc_pipen(usb3, i);\n\t\t}\n\t}\n}\n\nstatic void usb3_irq_idmon_change(struct renesas_usb3 *usb3)\n{\n\tusb3_check_id(usb3);\n}\n\nstatic void usb3_irq_otg_int(struct renesas_usb3 *usb3)\n{\n\tu32 otg_int_sta = usb3_drd_read(usb3, USB3_USB_OTG_INT_STA(usb3));\n\n\totg_int_sta &= usb3_drd_read(usb3, USB3_USB_OTG_INT_ENA(usb3));\n\tif (otg_int_sta)\n\t\tusb3_drd_write(usb3, otg_int_sta, USB3_USB_OTG_INT_STA(usb3));\n\n\tif (otg_int_sta & USB_OTG_IDMON(usb3))\n\t\tusb3_irq_idmon_change(usb3);\n}\n\nstatic void usb3_irq_epc(struct renesas_usb3 *usb3)\n{\n\tu32 int_sta_1 = usb3_read(usb3, USB3_USB_INT_STA_1);\n\tu32 int_sta_2 = usb3_read(usb3, USB3_USB_INT_STA_2);\n\n\tint_sta_1 &= usb3_read(usb3, USB3_USB_INT_ENA_1);\n\tif (int_sta_1) {\n\t\tusb3_write(usb3, int_sta_1, USB3_USB_INT_STA_1);\n\t\tusb3_irq_epc_int_1(usb3, int_sta_1);\n\t}\n\n\tint_sta_2 &= usb3_read(usb3, USB3_USB_INT_ENA_2);\n\tif (int_sta_2)\n\t\tusb3_irq_epc_int_2(usb3, int_sta_2);\n\n\tif (!usb3->is_rzv2m)\n\t\tusb3_irq_otg_int(usb3);\n}\n\nstatic void usb3_irq_dma_int(struct renesas_usb3 *usb3, u32 dma_sta)\n{\n\tstruct renesas_usb3_ep *usb3_ep;\n\tstruct renesas_usb3_request *usb3_req;\n\tint i, status;\n\n\tfor (i = 0; i < usb3->num_usb3_eps; i++) {\n\t\tif (!(dma_sta & DMA_INT(i)))\n\t\t\tcontinue;\n\n\t\tusb3_ep = usb3_get_ep(usb3, i);\n\t\tif (!(usb3_read(usb3, USB3_AXI_INT_STA) &\n\t\t    AXI_INT_PRDEN_CLR_STA(usb3_ep->dma->num)))\n\t\t\tcontinue;\n\n\t\tusb3_req = usb3_get_request(usb3_ep);\n\t\tstatus = usb3_dma_try_stop(usb3_ep, usb3_req);\n\t\tusb3_request_done_pipen(usb3, usb3_ep, usb3_req, status);\n\t}\n}\n\nstatic void usb3_irq_dma(struct renesas_usb3 *usb3)\n{\n\tu32 dma_sta = usb3_read(usb3, USB3_DMA_INT_STA);\n\n\tdma_sta &= usb3_read(usb3, USB3_DMA_INT_ENA);\n\tif (dma_sta) {\n\t\tusb3_write(usb3, dma_sta, USB3_DMA_INT_STA);\n\t\tusb3_irq_dma_int(usb3, dma_sta);\n\t}\n}\n\nstatic irqreturn_t renesas_usb3_irq(int irq, void *_usb3)\n{\n\tstruct renesas_usb3 *usb3 = _usb3;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 axi_int_sta = usb3_read(usb3, USB3_AXI_INT_STA);\n\n\tif (axi_int_sta & AXI_INT_DMAINT) {\n\t\tusb3_irq_dma(usb3);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (axi_int_sta & AXI_INT_EPCINT) {\n\t\tusb3_irq_epc(usb3);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t renesas_usb3_otg_irq(int irq, void *_usb3)\n{\n\tstruct renesas_usb3 *usb3 = _usb3;\n\n\tusb3_irq_otg_int(usb3);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void usb3_write_pn_mod(struct renesas_usb3_ep *usb3_ep,\n\t\t\t      const struct usb_endpoint_descriptor *desc)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tu32 val = 0;\n\n\tval |= usb3_ep->dir_in ? PN_MOD_DIR : 0;\n\tval |= PN_MOD_TYPE(usb_endpoint_type(desc));\n\tval |= PN_MOD_EPNUM(usb_endpoint_num(desc));\n\tusb3_write(usb3, val, USB3_PN_MOD);\n}\n\nstatic u32 usb3_calc_ramarea(int ram_size)\n{\n\tWARN_ON(ram_size > SZ_16K);\n\n\tif (ram_size <= SZ_1K)\n\t\treturn PN_RAMMAP_RAMAREA_1KB;\n\telse if (ram_size <= SZ_2K)\n\t\treturn PN_RAMMAP_RAMAREA_2KB;\n\telse if (ram_size <= SZ_4K)\n\t\treturn PN_RAMMAP_RAMAREA_4KB;\n\telse if (ram_size <= SZ_8K)\n\t\treturn PN_RAMMAP_RAMAREA_8KB;\n\telse\n\t\treturn PN_RAMMAP_RAMAREA_16KB;\n}\n\nstatic u32 usb3_calc_rammap_val(struct renesas_usb3_ep *usb3_ep,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tint i;\n\tstatic const u32 max_packet_array[] = {8, 16, 32, 64, 512};\n\tu32 mpkt = PN_RAMMAP_MPKT(1024);\n\n\tfor (i = 0; i < ARRAY_SIZE(max_packet_array); i++) {\n\t\tif (usb_endpoint_maxp(desc) <= max_packet_array[i])\n\t\t\tmpkt = PN_RAMMAP_MPKT(max_packet_array[i]);\n\t}\n\n\treturn usb3_ep->rammap_val | mpkt;\n}\n\nstatic int usb3_enable_pipe_n(struct renesas_usb3_ep *usb3_ep,\n\t\t\t      const struct usb_endpoint_descriptor *desc)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tusb3_ep->dir_in = usb_endpoint_dir_in(desc);\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (!usb3_pn_change(usb3, usb3_ep->num)) {\n\t\tusb3_write_pn_mod(usb3_ep, desc);\n\t\tusb3_write(usb3, usb3_calc_rammap_val(usb3_ep, desc),\n\t\t\t   USB3_PN_RAMMAP);\n\t\tusb3_pn_con_clear(usb3);\n\t\tusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\n\t}\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usb3_disable_pipe_n(struct renesas_usb3_ep *usb3_ep)\n{\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tusb3_ep->halt = false;\n\n\tspin_lock_irqsave(&usb3->lock, flags);\n\tif (!usb3_pn_change(usb3, usb3_ep->num)) {\n\t\tusb3_write(usb3, 0, USB3_PN_INT_ENA);\n\t\tusb3_write(usb3, 0, USB3_PN_RAMMAP);\n\t\tusb3_clear_bit(usb3, PN_CON_EN, USB3_PN_CON);\n\t}\n\tspin_unlock_irqrestore(&usb3->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int renesas_usb3_ep_enable(struct usb_ep *_ep,\n\t\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\n\treturn usb3_enable_pipe_n(usb3_ep, desc);\n}\n\nstatic int renesas_usb3_ep_disable(struct usb_ep *_ep)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\tstruct renesas_usb3_request *usb3_req;\n\n\tdo {\n\t\tusb3_req = usb3_get_request(usb3_ep);\n\t\tif (!usb3_req)\n\t\t\tbreak;\n\t\tusb3_dma_try_stop(usb3_ep, usb3_req);\n\t\tusb3_request_done(usb3_ep, usb3_req, -ESHUTDOWN);\n\t} while (1);\n\n\treturn usb3_disable_pipe_n(usb3_ep);\n}\n\nstatic struct usb_request *__renesas_usb3_ep_alloc_request(gfp_t gfp_flags)\n{\n\tstruct renesas_usb3_request *usb3_req;\n\n\tusb3_req = kzalloc(sizeof(struct renesas_usb3_request), gfp_flags);\n\tif (!usb3_req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&usb3_req->queue);\n\n\treturn &usb3_req->req;\n}\n\nstatic void __renesas_usb3_ep_free_request(struct usb_request *_req)\n{\n\tstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\n\n\tkfree(usb3_req);\n}\n\nstatic struct usb_request *renesas_usb3_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\treturn __renesas_usb3_ep_alloc_request(gfp_flags);\n}\n\nstatic void renesas_usb3_ep_free_request(struct usb_ep *_ep,\n\t\t\t\t\t struct usb_request *_req)\n{\n\t__renesas_usb3_ep_free_request(_req);\n}\n\nstatic int renesas_usb3_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\tstruct renesas_usb3_request *usb3_req = usb_req_to_usb3_req(_req);\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\n\tdev_dbg(usb3_to_dev(usb3), \"ep_dequeue: ep%2d, %u\\n\", usb3_ep->num,\n\t\t_req->length);\n\n\tusb3_dma_try_stop(usb3_ep, usb3_req);\n\tusb3_request_done_pipen(usb3, usb3_ep, usb3_req, -ECONNRESET);\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn usb3_set_halt(usb_ep_to_usb3_ep(_ep), !!value, false);\n}\n\nstatic int renesas_usb3_ep_set_wedge(struct usb_ep *_ep)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\n\tusb3_ep->wedge = true;\n\treturn usb3_set_halt(usb3_ep, true, false);\n}\n\nstatic void renesas_usb3_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct renesas_usb3_ep *usb3_ep = usb_ep_to_usb3_ep(_ep);\n\tstruct renesas_usb3 *usb3 = usb3_ep_to_usb3(usb3_ep);\n\tunsigned long flags;\n\n\tif (usb3_ep->num) {\n\t\tspin_lock_irqsave(&usb3->lock, flags);\n\t\tif (!usb3_pn_change(usb3, usb3_ep->num)) {\n\t\t\tusb3_pn_con_clear(usb3);\n\t\t\tusb3_set_bit(usb3, PN_CON_EN, USB3_PN_CON);\n\t\t}\n\t\tspin_unlock_irqrestore(&usb3->lock, flags);\n\t} else {\n\t\tusb3_p0_con_clear_buffer(usb3);\n\t}\n}\n\nstatic const struct usb_ep_ops renesas_usb3_ep_ops = {\n\t.enable\t\t= renesas_usb3_ep_enable,\n\t.disable\t= renesas_usb3_ep_disable,\n\n\t.alloc_request\t= renesas_usb3_ep_alloc_request,\n\t.free_request\t= renesas_usb3_ep_free_request,\n\n\t.queue\t\t= renesas_usb3_ep_queue,\n\t.dequeue\t= renesas_usb3_ep_dequeue,\n\n\t.set_halt\t= renesas_usb3_ep_set_halt,\n\t.set_wedge\t= renesas_usb3_ep_set_wedge,\n\t.fifo_flush\t= renesas_usb3_ep_fifo_flush,\n};\n\n \nstatic int renesas_usb3_start(struct usb_gadget *gadget,\n\t\t\t      struct usb_gadget_driver *driver)\n{\n\tstruct renesas_usb3 *usb3;\n\n\tif (!driver || driver->max_speed < USB_SPEED_FULL ||\n\t    !driver->setup)\n\t\treturn -EINVAL;\n\n\tusb3 = gadget_to_renesas_usb3(gadget);\n\n\tif (usb3->is_rzv2m && usb3_is_a_device(usb3))\n\t\treturn -EBUSY;\n\n\t \n\tusb3->driver = driver;\n\n\tif (usb3->phy)\n\t\tphy_init(usb3->phy);\n\n\tpm_runtime_get_sync(usb3_to_dev(usb3));\n\n\t \n\tif (usb3->is_rzv2m)\n\t\trzv2m_usb3drd_reset(usb3_to_dev(usb3)->parent, false);\n\n\trenesas_usb3_init_controller(usb3);\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_stop(struct usb_gadget *gadget)\n{\n\tstruct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);\n\n\tusb3->softconnect = false;\n\tusb3->gadget.speed = USB_SPEED_UNKNOWN;\n\tusb3->driver = NULL;\n\tif (usb3->is_rzv2m)\n\t\trzv2m_usb3drd_reset(usb3_to_dev(usb3)->parent, false);\n\n\trenesas_usb3_stop_controller(usb3);\n\tif (usb3->phy)\n\t\tphy_exit(usb3->phy);\n\n\tpm_runtime_put(usb3_to_dev(usb3));\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_get_frame(struct usb_gadget *_gadget)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int renesas_usb3_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);\n\n\tusb3->softconnect = !!is_on;\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_set_selfpowered(struct usb_gadget *gadget, int is_self)\n{\n\tgadget->is_selfpowered = !!is_self;\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops renesas_usb3_gadget_ops = {\n\t.get_frame\t\t= renesas_usb3_get_frame,\n\t.udc_start\t\t= renesas_usb3_start,\n\t.udc_stop\t\t= renesas_usb3_stop,\n\t.pullup\t\t\t= renesas_usb3_pullup,\n\t.set_selfpowered\t= renesas_usb3_set_selfpowered,\n};\n\nstatic enum usb_role renesas_usb3_role_switch_get(struct usb_role_switch *sw)\n{\n\tstruct renesas_usb3 *usb3 = usb_role_switch_get_drvdata(sw);\n\tenum usb_role cur_role;\n\n\tpm_runtime_get_sync(usb3_to_dev(usb3));\n\tcur_role = usb3_is_host(usb3) ? USB_ROLE_HOST : USB_ROLE_DEVICE;\n\tpm_runtime_put(usb3_to_dev(usb3));\n\n\treturn cur_role;\n}\n\nstatic void handle_ext_role_switch_states(struct device *dev,\n\t\t\t\t\t    enum usb_role role)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\tstruct device *host = usb3->host_dev;\n\tenum usb_role cur_role = renesas_usb3_role_switch_get(usb3->role_sw);\n\n\tswitch (role) {\n\tcase USB_ROLE_NONE:\n\t\tusb3->connection_state = USB_ROLE_NONE;\n\t\tif (!usb3->is_rzv2m && cur_role == USB_ROLE_HOST)\n\t\t\tdevice_release_driver(host);\n\t\tif (usb3->driver) {\n\t\t\tif (usb3->is_rzv2m)\n\t\t\t\trzv2m_usb3drd_reset(dev->parent, false);\n\t\t\tusb3_disconnect(usb3);\n\t\t}\n\t\tusb3_vbus_out(usb3, false);\n\n\t\tif (usb3->is_rzv2m) {\n\t\t\trzv2m_usb3drd_reset(dev->parent, true);\n\t\t\tdevice_release_driver(host);\n\t\t}\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tif (usb3->connection_state == USB_ROLE_NONE) {\n\t\t\tusb3->connection_state = USB_ROLE_DEVICE;\n\t\t\tusb3_set_mode(usb3, false);\n\t\t\tif (usb3->driver) {\n\t\t\t\tif (usb3->is_rzv2m)\n\t\t\t\t\trenesas_usb3_init_controller(usb3);\n\t\t\t\tusb3_connect(usb3);\n\t\t\t}\n\t\t} else if (cur_role == USB_ROLE_HOST)  {\n\t\t\tdevice_release_driver(host);\n\t\t\tusb3_set_mode(usb3, false);\n\t\t\tif (usb3->driver)\n\t\t\t\tusb3_connect(usb3);\n\t\t}\n\t\tusb3_vbus_out(usb3, false);\n\t\tbreak;\n\tcase USB_ROLE_HOST:\n\t\tif (usb3->connection_state == USB_ROLE_NONE) {\n\t\t\tif (usb3->driver) {\n\t\t\t\tif (usb3->is_rzv2m)\n\t\t\t\t\trzv2m_usb3drd_reset(dev->parent, false);\n\t\t\t\tusb3_disconnect(usb3);\n\t\t\t}\n\n\t\t\tusb3->connection_state = USB_ROLE_HOST;\n\t\t\tusb3_set_mode(usb3, true);\n\t\t\tusb3_vbus_out(usb3, true);\n\t\t\tif (device_attach(host) < 0)\n\t\t\t\tdev_err(dev, \"device_attach(host) failed\\n\");\n\t\t} else if (cur_role == USB_ROLE_DEVICE) {\n\t\t\tusb3_disconnect(usb3);\n\t\t\t \n\t\t\tusb3_set_mode(usb3, true);\n\t\t\t \n\t\t\tif (device_attach(host) < 0)\n\t\t\t\tdev_err(dev, \"device_attach(host) failed\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void handle_role_switch_states(struct device *dev,\n\t\t\t\t\t    enum usb_role role)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\tstruct device *host = usb3->host_dev;\n\tenum usb_role cur_role = renesas_usb3_role_switch_get(usb3->role_sw);\n\n\tif (cur_role == USB_ROLE_HOST && role == USB_ROLE_DEVICE) {\n\t\tdevice_release_driver(host);\n\t\tusb3_set_mode(usb3, false);\n\t} else if (cur_role == USB_ROLE_DEVICE && role == USB_ROLE_HOST) {\n\t\t \n\t\tusb3_set_mode(usb3, true);\n\t\t \n\t\tif (device_attach(host) < 0)\n\t\t\tdev_err(dev, \"device_attach(host) failed\\n\");\n\t}\n}\n\nstatic int renesas_usb3_role_switch_set(struct usb_role_switch *sw,\n\t\t\t\t\tenum usb_role role)\n{\n\tstruct renesas_usb3 *usb3 = usb_role_switch_get_drvdata(sw);\n\n\tpm_runtime_get_sync(usb3_to_dev(usb3));\n\n\tif (usb3->role_sw_by_connector)\n\t\thandle_ext_role_switch_states(usb3_to_dev(usb3), role);\n\telse\n\t\thandle_role_switch_states(usb3_to_dev(usb3), role);\n\n\tpm_runtime_put(usb3_to_dev(usb3));\n\n\treturn 0;\n}\n\nstatic ssize_t role_store(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\tbool new_mode_is_host;\n\n\tif (!usb3->driver)\n\t\treturn -ENODEV;\n\n\tif (usb3->forced_b_device)\n\t\treturn -EBUSY;\n\n\tif (sysfs_streq(buf, \"host\"))\n\t\tnew_mode_is_host = true;\n\telse if (sysfs_streq(buf, \"peripheral\"))\n\t\tnew_mode_is_host = false;\n\telse\n\t\treturn -EINVAL;\n\n\tif (new_mode_is_host == usb3_is_host(usb3))\n\t\treturn -EINVAL;\n\n\tusb3_mode_config(usb3, new_mode_is_host, usb3_is_a_device(usb3));\n\n\treturn count;\n}\n\nstatic ssize_t role_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\n\tif (!usb3->driver)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%s\\n\", usb3_is_host(usb3) ? \"host\" : \"peripheral\");\n}\nstatic DEVICE_ATTR_RW(role);\n\nstatic int renesas_usb3_b_device_show(struct seq_file *s, void *unused)\n{\n\tstruct renesas_usb3 *usb3 = s->private;\n\n\tseq_printf(s, \"%d\\n\", usb3->forced_b_device);\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_b_device_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, renesas_usb3_b_device_show, inode->i_private);\n}\n\nstatic ssize_t renesas_usb3_b_device_write(struct file *file,\n\t\t\t\t\t   const char __user *ubuf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct renesas_usb3 *usb3 = s->private;\n\tchar buf[32];\n\n\tif (!usb3->driver)\n\t\treturn -ENODEV;\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tusb3->start_to_connect = false;\n\tif (usb3->workaround_for_vbus && usb3->forced_b_device &&\n\t    !strncmp(buf, \"2\", 1))\n\t\tusb3->start_to_connect = true;\n\telse if (!strncmp(buf, \"1\", 1))\n\t\tusb3->forced_b_device = true;\n\telse\n\t\tusb3->forced_b_device = false;\n\n\tif (usb3->workaround_for_vbus)\n\t\tusb3_disconnect(usb3);\n\n\t \n\tusb3_check_id(usb3);\n\n\treturn count;\n}\n\nstatic const struct file_operations renesas_usb3_b_device_fops = {\n\t.open = renesas_usb3_b_device_open,\n\t.write = renesas_usb3_b_device_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void renesas_usb3_debugfs_init(struct renesas_usb3 *usb3,\n\t\t\t\t      struct device *dev)\n{\n\tusb3->dentry = debugfs_create_dir(dev_name(dev), usb_debug_root);\n\n\tdebugfs_create_file(\"b_device\", 0644, usb3->dentry, usb3,\n\t\t\t    &renesas_usb3_b_device_fops);\n}\n\n \nstatic void renesas_usb3_remove(struct platform_device *pdev)\n{\n\tstruct renesas_usb3 *usb3 = platform_get_drvdata(pdev);\n\n\tdebugfs_remove_recursive(usb3->dentry);\n\tdevice_remove_file(&pdev->dev, &dev_attr_role);\n\n\tcancel_work_sync(&usb3->role_work);\n\tusb_role_switch_unregister(usb3->role_sw);\n\n\tusb_del_gadget_udc(&usb3->gadget);\n\treset_control_assert(usb3->usbp_rstc);\n\trenesas_usb3_dma_free_prd(usb3, &pdev->dev);\n\n\t__renesas_usb3_ep_free_request(usb3->ep0_req);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic int renesas_usb3_init_ep(struct renesas_usb3 *usb3, struct device *dev,\n\t\t\t\tconst struct renesas_usb3_priv *priv)\n{\n\tstruct renesas_usb3_ep *usb3_ep;\n\tint i;\n\n\t \n\tusb3->num_usb3_eps = priv->ramsize_per_ramif * priv->num_ramif * 2 /\n\t\t\t     priv->ramsize_per_pipe + 1;\n\n\tif (usb3->num_usb3_eps > USB3_MAX_NUM_PIPES(usb3))\n\t\tusb3->num_usb3_eps = USB3_MAX_NUM_PIPES(usb3);\n\n\tusb3->usb3_ep = devm_kcalloc(dev,\n\t\t\t\t     usb3->num_usb3_eps, sizeof(*usb3_ep),\n\t\t\t\t     GFP_KERNEL);\n\tif (!usb3->usb3_ep)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(dev, \"%s: num_usb3_eps = %d\\n\", __func__, usb3->num_usb3_eps);\n\t \n\tusb3_for_each_ep(usb3_ep, usb3, i) {\n\t\tsnprintf(usb3_ep->ep_name, sizeof(usb3_ep->ep_name), \"ep%d\", i);\n\t\tusb3_ep->usb3 = usb3;\n\t\tusb3_ep->num = i;\n\t\tusb3_ep->ep.name = usb3_ep->ep_name;\n\t\tusb3_ep->ep.ops = &renesas_usb3_ep_ops;\n\t\tINIT_LIST_HEAD(&usb3_ep->queue);\n\t\tINIT_LIST_HEAD(&usb3_ep->ep.ep_list);\n\t\tif (!i) {\n\t\t\t \n\t\t\tusb3->gadget.ep0 = &usb3_ep->ep;\n\t\t\tusb_ep_set_maxpacket_limit(&usb3_ep->ep,\n\t\t\t\t\t\tUSB3_EP0_SS_MAX_PACKET_SIZE);\n\t\t\tusb3_ep->ep.caps.type_control = true;\n\t\t\tusb3_ep->ep.caps.dir_in = true;\n\t\t\tusb3_ep->ep.caps.dir_out = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tusb_ep_set_maxpacket_limit(&usb3_ep->ep, ~0);\n\t\tlist_add_tail(&usb3_ep->ep.ep_list, &usb3->gadget.ep_list);\n\t\tusb3_ep->ep.caps.type_bulk = true;\n\t\tusb3_ep->ep.caps.type_int = true;\n\t\tif (i & 1)\n\t\t\tusb3_ep->ep.caps.dir_in = true;\n\t\telse\n\t\t\tusb3_ep->ep.caps.dir_out = true;\n\t}\n\n\treturn 0;\n}\n\nstatic void renesas_usb3_init_ram(struct renesas_usb3 *usb3, struct device *dev,\n\t\t\t\t  const struct renesas_usb3_priv *priv)\n{\n\tstruct renesas_usb3_ep *usb3_ep;\n\tint i;\n\tu32 ramif[2], basead[2];\t \n\tu32 *cur_ramif, *cur_basead;\n\tu32 val;\n\n\tmemset(ramif, 0, sizeof(ramif));\n\tmemset(basead, 0, sizeof(basead));\n\n\t \n\tusb3_for_each_ep(usb3_ep, usb3, i) {\n\t\tif (!i)\n\t\t\tcontinue;\t \n\t\tif (usb3_ep->ep.caps.dir_in) {\n\t\t\tcur_ramif = &ramif[0];\n\t\t\tcur_basead = &basead[0];\n\t\t} else {\n\t\t\tcur_ramif = &ramif[1];\n\t\t\tcur_basead = &basead[1];\n\t\t}\n\n\t\tif (*cur_basead > priv->ramsize_per_ramif)\n\t\t\tcontinue;\t \n\n\t\t \n\t\tval = PN_RAMMAP_RAMIF(*cur_ramif);\n\t\tval |= usb3_calc_ramarea(priv->ramsize_per_pipe);\n\t\tval |= PN_RAMMAP_BASEAD(*cur_basead);\n\t\tusb3_ep->rammap_val = val;\n\n\t\tdev_dbg(dev, \"ep%2d: val = %08x, ramif = %d, base = %x\\n\",\n\t\t\ti, val, *cur_ramif, *cur_basead);\n\n\t\t \n\t\tif (*cur_ramif + 1 == priv->num_ramif) {\n\t\t\t*cur_ramif = 0;\n\t\t\t*cur_basead += priv->ramsize_per_pipe;\n\t\t} else {\n\t\t\t(*cur_ramif)++;\n\t\t}\n\t}\n}\n\nstatic const struct renesas_usb3_priv renesas_usb3_priv_gen3 = {\n\t.ramsize_per_ramif = SZ_16K,\n\t.num_ramif = 4,\n\t.ramsize_per_pipe = SZ_4K,\n};\n\nstatic const struct renesas_usb3_priv renesas_usb3_priv_r8a77990 = {\n\t.ramsize_per_ramif = SZ_16K,\n\t.num_ramif = 4,\n\t.ramsize_per_pipe = SZ_4K,\n\t.workaround_for_vbus = true,\n};\n\nstatic const struct renesas_usb3_priv renesas_usb3_priv_rzv2m = {\n\t.ramsize_per_ramif = SZ_16K,\n\t.num_ramif = 1,\n\t.ramsize_per_pipe = SZ_4K,\n\t.is_rzv2m = true,\n};\n\nstatic const struct of_device_id usb3_of_match[] = {\n\t{\n\t\t.compatible = \"renesas,r8a774c0-usb3-peri\",\n\t\t.data = &renesas_usb3_priv_r8a77990,\n\t}, {\n\t\t.compatible = \"renesas,r8a7795-usb3-peri\",\n\t\t.data = &renesas_usb3_priv_gen3,\n\t}, {\n\t\t.compatible = \"renesas,r8a77990-usb3-peri\",\n\t\t.data = &renesas_usb3_priv_r8a77990,\n\t}, {\n\t\t.compatible = \"renesas,rzv2m-usb3-peri\",\n\t\t.data = &renesas_usb3_priv_rzv2m,\n\t}, {\n\t\t.compatible = \"renesas,rcar-gen3-usb3-peri\",\n\t\t.data = &renesas_usb3_priv_gen3,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, usb3_of_match);\n\nstatic const unsigned int renesas_usb3_cable[] = {\n\tEXTCON_USB,\n\tEXTCON_USB_HOST,\n\tEXTCON_NONE,\n};\n\nstatic struct usb_role_switch_desc renesas_usb3_role_switch_desc = {\n\t.set = renesas_usb3_role_switch_set,\n\t.get = renesas_usb3_role_switch_get,\n\t.allow_userspace_control = true,\n};\n\nstatic int renesas_usb3_probe(struct platform_device *pdev)\n{\n\tstruct renesas_usb3 *usb3;\n\tint irq, ret;\n\tconst struct renesas_usb3_priv *priv;\n\n\tpriv = of_device_get_match_data(&pdev->dev);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tusb3 = devm_kzalloc(&pdev->dev, sizeof(*usb3), GFP_KERNEL);\n\tif (!usb3)\n\t\treturn -ENOMEM;\n\n\tusb3->is_rzv2m = priv->is_rzv2m;\n\n\tusb3->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(usb3->reg))\n\t\treturn PTR_ERR(usb3->reg);\n\n\tplatform_set_drvdata(pdev, usb3);\n\tspin_lock_init(&usb3->lock);\n\n\tusb3->gadget.ops = &renesas_usb3_gadget_ops;\n\tusb3->gadget.name = udc_name;\n\tusb3->gadget.max_speed = USB_SPEED_SUPER;\n\tINIT_LIST_HEAD(&usb3->gadget.ep_list);\n\tret = renesas_usb3_init_ep(usb3, &pdev->dev, priv);\n\tif (ret < 0)\n\t\treturn ret;\n\trenesas_usb3_init_ram(usb3, &pdev->dev, priv);\n\n\tret = devm_request_irq(&pdev->dev, irq, renesas_usb3_irq, 0,\n\t\t\t       dev_name(&pdev->dev), usb3);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (usb3->is_rzv2m) {\n\t\tstruct rzv2m_usb3drd *ddata = dev_get_drvdata(pdev->dev.parent);\n\n\t\tusb3->drd_reg = ddata->reg;\n\t\tret = devm_request_irq(&pdev->dev, ddata->drd_irq,\n\t\t\t\t       renesas_usb3_otg_irq, 0,\n\t\t\t\t       dev_name(&pdev->dev), usb3);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tINIT_WORK(&usb3->extcon_work, renesas_usb3_extcon_work);\n\tusb3->extcon = devm_extcon_dev_allocate(&pdev->dev, renesas_usb3_cable);\n\tif (IS_ERR(usb3->extcon))\n\t\treturn PTR_ERR(usb3->extcon);\n\n\tret = devm_extcon_dev_register(&pdev->dev, usb3->extcon);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to register extcon\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tusb3->ep0_req = __renesas_usb3_ep_alloc_request(GFP_KERNEL);\n\tif (!usb3->ep0_req)\n\t\treturn -ENOMEM;\n\n\tret = renesas_usb3_dma_alloc_prd(usb3, &pdev->dev);\n\tif (ret < 0)\n\t\tgoto err_alloc_prd;\n\n\t \n\tusb3->phy = devm_phy_optional_get(&pdev->dev, \"usb\");\n\tif (IS_ERR(usb3->phy)) {\n\t\tret = PTR_ERR(usb3->phy);\n\t\tgoto err_add_udc;\n\t}\n\n\tusb3->usbp_rstc = devm_reset_control_get_optional_shared(&pdev->dev,\n\t\t\t\t\t\t\t\t NULL);\n\tif (IS_ERR(usb3->usbp_rstc)) {\n\t\tret = PTR_ERR(usb3->usbp_rstc);\n\t\tgoto err_add_udc;\n\t}\n\n\treset_control_deassert(usb3->usbp_rstc);\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = usb_add_gadget_udc(&pdev->dev, &usb3->gadget);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tret = device_create_file(&pdev->dev, &dev_attr_role);\n\tif (ret < 0)\n\t\tgoto err_dev_create;\n\n\tif (device_property_read_bool(&pdev->dev, \"usb-role-switch\")) {\n\t\tusb3->role_sw_by_connector = true;\n\t\trenesas_usb3_role_switch_desc.fwnode = dev_fwnode(&pdev->dev);\n\t}\n\n\trenesas_usb3_role_switch_desc.driver_data = usb3;\n\n\tINIT_WORK(&usb3->role_work, renesas_usb3_role_work);\n\tusb3->role_sw = usb_role_switch_register(&pdev->dev,\n\t\t\t\t\t&renesas_usb3_role_switch_desc);\n\tif (!IS_ERR(usb3->role_sw)) {\n\t\tusb3->host_dev = usb_of_get_companion_dev(&pdev->dev);\n\t\tif (!usb3->host_dev) {\n\t\t\t \n\t\t\tusb_role_switch_unregister(usb3->role_sw);\n\t\t\tusb3->role_sw = NULL;\n\t\t}\n\t} else {\n\t\tusb3->role_sw = NULL;\n\t}\n\n\tusb3->workaround_for_vbus = priv->workaround_for_vbus;\n\n\trenesas_usb3_debugfs_init(usb3, &pdev->dev);\n\n\tdev_info(&pdev->dev, \"probed%s\\n\", usb3->phy ? \" with phy\" : \"\");\n\n\treturn 0;\n\nerr_dev_create:\n\tusb_del_gadget_udc(&usb3->gadget);\n\nerr_reset:\n\treset_control_assert(usb3->usbp_rstc);\n\nerr_add_udc:\n\trenesas_usb3_dma_free_prd(usb3, &pdev->dev);\n\nerr_alloc_prd:\n\t__renesas_usb3_ep_free_request(usb3->ep0_req);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int renesas_usb3_suspend(struct device *dev)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\n\t \n\tif (!usb3->driver)\n\t\treturn 0;\n\n\trenesas_usb3_stop_controller(usb3);\n\tif (usb3->phy)\n\t\tphy_exit(usb3->phy);\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n\nstatic int renesas_usb3_resume(struct device *dev)\n{\n\tstruct renesas_usb3 *usb3 = dev_get_drvdata(dev);\n\n\t \n\tif (!usb3->driver)\n\t\treturn 0;\n\n\tif (usb3->phy)\n\t\tphy_init(usb3->phy);\n\tpm_runtime_get_sync(dev);\n\trenesas_usb3_init_controller(usb3);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(renesas_usb3_pm_ops, renesas_usb3_suspend,\n\t\t\trenesas_usb3_resume);\n\nstatic struct platform_driver renesas_usb3_driver = {\n\t.probe\t\t= renesas_usb3_probe,\n\t.remove_new\t= renesas_usb3_remove,\n\t.driver\t\t= {\n\t\t.name =\tudc_name,\n\t\t.pm\t\t= &renesas_usb3_pm_ops,\n\t\t.of_match_table = usb3_of_match,\n\t},\n};\nmodule_platform_driver(renesas_usb3_driver);\n\nMODULE_DESCRIPTION(\"Renesas USB3.0 Peripheral driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda <yoshihiro.shimoda.uh@renesas.com>\");\nMODULE_ALIAS(\"platform:renesas_usb3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}