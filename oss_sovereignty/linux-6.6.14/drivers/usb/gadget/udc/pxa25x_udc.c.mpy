{
  "module_name": "pxa25x_udc.c",
  "hash_id": "effd20753bd5c7022a43710c3370cdea069e8f1648c93557273bf5636ad3cdf3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/pxa25x_udc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n#include <linux/platform_data/pxa2xx_udc.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/io.h>\n#include <linux/prefetch.h>\n\n#include <asm/byteorder.h>\n#include <asm/dma.h>\n#include <asm/mach-types.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n\n#define UDCCR\t 0x0000  \n#define UDC_RES1 0x0004  \n#define UDC_RES2 0x0008  \n#define UDC_RES3 0x000C  \n#define UDCCS0\t 0x0010  \n#define UDCCS1\t 0x0014  \n#define UDCCS2\t 0x0018  \n#define UDCCS3\t 0x001C  \n#define UDCCS4\t 0x0020  \n#define UDCCS5\t 0x0024  \n#define UDCCS6\t 0x0028  \n#define UDCCS7\t 0x002C  \n#define UDCCS8\t 0x0030  \n#define UDCCS9\t 0x0034  \n#define UDCCS10\t 0x0038  \n#define UDCCS11\t 0x003C  \n#define UDCCS12\t 0x0040  \n#define UDCCS13\t 0x0044  \n#define UDCCS14\t 0x0048  \n#define UDCCS15\t 0x004C  \n#define UFNRH\t 0x0060  \n#define UFNRL\t 0x0064  \n#define UBCR2\t 0x0068  \n#define UBCR4\t 0x006c  \n#define UBCR7\t 0x0070  \n#define UBCR9\t 0x0074  \n#define UBCR12\t 0x0078  \n#define UBCR14\t 0x007c  \n#define UDDR0\t 0x0080  \n#define UDDR1\t 0x0100  \n#define UDDR2\t 0x0180  \n#define UDDR3\t 0x0200  \n#define UDDR4\t 0x0400  \n#define UDDR5\t 0x00A0  \n#define UDDR6\t 0x0600  \n#define UDDR7\t 0x0680  \n#define UDDR8\t 0x0700  \n#define UDDR9\t 0x0900  \n#define UDDR10\t 0x00C0  \n#define UDDR11\t 0x0B00  \n#define UDDR12\t 0x0B80  \n#define UDDR13\t 0x0C00  \n#define UDDR14\t 0x0E00  \n#define UDDR15\t 0x00E0  \n\n#define UICR0\t 0x0050  \n#define UICR1\t 0x0054  \n\n#define USIR0\t 0x0058  \n#define USIR1\t 0x005C  \n\n#define UDCCR_UDE\t(1 << 0)\t \n#define UDCCR_UDA\t(1 << 1)\t \n#define UDCCR_RSM\t(1 << 2)\t \n#define UDCCR_RESIR\t(1 << 3)\t \n#define UDCCR_SUSIR\t(1 << 4)\t \n#define UDCCR_SRM\t(1 << 5)\t \n#define UDCCR_RSTIR\t(1 << 6)\t \n#define UDCCR_REM\t(1 << 7)\t \n\n#define UDCCS0_OPR\t(1 << 0)\t \n#define UDCCS0_IPR\t(1 << 1)\t \n#define UDCCS0_FTF\t(1 << 2)\t \n#define UDCCS0_DRWF\t(1 << 3)\t \n#define UDCCS0_SST\t(1 << 4)\t \n#define UDCCS0_FST\t(1 << 5)\t \n#define UDCCS0_RNE\t(1 << 6)\t \n#define UDCCS0_SA\t(1 << 7)\t \n\n#define UDCCS_BI_TFS\t(1 << 0)\t \n#define UDCCS_BI_TPC\t(1 << 1)\t \n#define UDCCS_BI_FTF\t(1 << 2)\t \n#define UDCCS_BI_TUR\t(1 << 3)\t \n#define UDCCS_BI_SST\t(1 << 4)\t \n#define UDCCS_BI_FST\t(1 << 5)\t \n#define UDCCS_BI_TSP\t(1 << 7)\t \n\n#define UDCCS_BO_RFS\t(1 << 0)\t \n#define UDCCS_BO_RPC\t(1 << 1)\t \n#define UDCCS_BO_DME\t(1 << 3)\t \n#define UDCCS_BO_SST\t(1 << 4)\t \n#define UDCCS_BO_FST\t(1 << 5)\t \n#define UDCCS_BO_RNE\t(1 << 6)\t \n#define UDCCS_BO_RSP\t(1 << 7)\t \n\n#define UDCCS_II_TFS\t(1 << 0)\t \n#define UDCCS_II_TPC\t(1 << 1)\t \n#define UDCCS_II_FTF\t(1 << 2)\t \n#define UDCCS_II_TUR\t(1 << 3)\t \n#define UDCCS_II_TSP\t(1 << 7)\t \n\n#define UDCCS_IO_RFS\t(1 << 0)\t \n#define UDCCS_IO_RPC\t(1 << 1)\t \n#ifdef CONFIG_ARCH_IXP4XX  \n#define UDCCS_IO_ROF\t(1 << 3)\t \n#endif\n#ifdef CONFIG_ARCH_PXA\n#define UDCCS_IO_ROF\t(1 << 2)\t \n#endif\n#define UDCCS_IO_DME\t(1 << 3)\t \n#define UDCCS_IO_RNE\t(1 << 6)\t \n#define UDCCS_IO_RSP\t(1 << 7)\t \n\n#define UDCCS_INT_TFS\t(1 << 0)\t \n#define UDCCS_INT_TPC\t(1 << 1)\t \n#define UDCCS_INT_FTF\t(1 << 2)\t \n#define UDCCS_INT_TUR\t(1 << 3)\t \n#define UDCCS_INT_SST\t(1 << 4)\t \n#define UDCCS_INT_FST\t(1 << 5)\t \n#define UDCCS_INT_TSP\t(1 << 7)\t \n\n#define UICR0_IM0\t(1 << 0)\t \n#define UICR0_IM1\t(1 << 1)\t \n#define UICR0_IM2\t(1 << 2)\t \n#define UICR0_IM3\t(1 << 3)\t \n#define UICR0_IM4\t(1 << 4)\t \n#define UICR0_IM5\t(1 << 5)\t \n#define UICR0_IM6\t(1 << 6)\t \n#define UICR0_IM7\t(1 << 7)\t \n\n#define UICR1_IM8\t(1 << 0)\t \n#define UICR1_IM9\t(1 << 1)\t \n#define UICR1_IM10\t(1 << 2)\t \n#define UICR1_IM11\t(1 << 3)\t \n#define UICR1_IM12\t(1 << 4)\t \n#define UICR1_IM13\t(1 << 5)\t \n#define UICR1_IM14\t(1 << 6)\t \n#define UICR1_IM15\t(1 << 7)\t \n\n#define USIR0_IR0\t(1 << 0)\t \n#define USIR0_IR1\t(1 << 1)\t \n#define USIR0_IR2\t(1 << 2)\t \n#define USIR0_IR3\t(1 << 3)\t \n#define USIR0_IR4\t(1 << 4)\t \n#define USIR0_IR5\t(1 << 5)\t \n#define USIR0_IR6\t(1 << 6)\t \n#define USIR0_IR7\t(1 << 7)\t \n\n#define USIR1_IR8\t(1 << 0)\t \n#define USIR1_IR9\t(1 << 1)\t \n#define USIR1_IR10\t(1 << 2)\t \n#define USIR1_IR11\t(1 << 3)\t \n#define USIR1_IR12\t(1 << 4)\t \n#define USIR1_IR13\t(1 << 5)\t \n#define USIR1_IR14\t(1 << 6)\t \n#define USIR1_IR15\t(1 << 7)\t \n\n \n\n#define\tDRIVER_VERSION\t\"30-June-2007\"\n#define\tDRIVER_DESC\t\"PXA 25x USB Device Controller driver\"\n\n\nstatic const char driver_name [] = \"pxa25x_udc\";\n\nstatic const char ep0name [] = \"ep0\";\n\n\n#ifdef CONFIG_ARCH_IXP4XX\n\n \n#ifdef CONFIG_ARCH_PXA\n#error \"Can't configure both IXP and PXA\"\n#endif\n\n \n#define clk_get(dev,name)\tNULL\n#define clk_enable(clk)\t\tdo { } while (0)\n#define clk_disable(clk)\tdo { } while (0)\n#define clk_put(clk)\t\tdo { } while (0)\n\n#endif\n\n#include \"pxa25x_udc.h\"\n\n\n#ifdef\tCONFIG_USB_PXA25X_SMALL\n#define SIZE_STR\t\" (small)\"\n#else\n#define SIZE_STR\t\"\"\n#endif\n\n \n\nstatic void pxa25x_ep_fifo_flush (struct usb_ep *ep);\nstatic void nuke (struct pxa25x_ep *, int status);\n\n \nstatic void pullup_off(void)\n{\n\tstruct pxa2xx_udc_mach_info\t\t*mach = the_controller->mach;\n\tint off_level = mach->gpio_pullup_inverted;\n\n\tif (gpio_is_valid(mach->gpio_pullup))\n\t\tgpio_set_value(mach->gpio_pullup, off_level);\n\telse if (mach->udc_command)\n\t\tmach->udc_command(PXA2XX_UDC_CMD_DISCONNECT);\n}\n\nstatic void pullup_on(void)\n{\n\tstruct pxa2xx_udc_mach_info\t\t*mach = the_controller->mach;\n\tint on_level = !mach->gpio_pullup_inverted;\n\n\tif (gpio_is_valid(mach->gpio_pullup))\n\t\tgpio_set_value(mach->gpio_pullup, on_level);\n\telse if (mach->udc_command)\n\t\tmach->udc_command(PXA2XX_UDC_CMD_CONNECT);\n}\n\n#if defined(CONFIG_CPU_BIG_ENDIAN)\n \nstatic inline void udc_set_reg(struct pxa25x_udc *dev, u32 reg, u32 val)\n{\n\tiowrite32be(val, dev->regs + reg);\n}\n\nstatic inline u32 udc_get_reg(struct pxa25x_udc *dev, u32 reg)\n{\n\treturn ioread32be(dev->regs + reg);\n}\n#else\nstatic inline void udc_set_reg(struct pxa25x_udc *dev, u32 reg, u32 val)\n{\n\twritel(val, dev->regs + reg);\n}\n\nstatic inline u32 udc_get_reg(struct pxa25x_udc *dev, u32 reg)\n{\n\treturn readl(dev->regs + reg);\n}\n#endif\n\nstatic void pio_irq_enable(struct pxa25x_ep *ep)\n{\n\tu32 bEndpointAddress = ep->bEndpointAddress & 0xf;\n\n        if (bEndpointAddress < 8)\n\t\tudc_set_reg(ep->dev, UICR0, udc_get_reg(ep->dev, UICR0) &\n\t\t\t\t\t\t~(1 << bEndpointAddress));\n        else {\n                bEndpointAddress -= 8;\n\t\tudc_set_reg(ep->dev, UICR1, udc_get_reg(ep->dev, UICR1) &\n\t\t\t\t\t\t~(1 << bEndpointAddress));\n\t}\n}\n\nstatic void pio_irq_disable(struct pxa25x_ep *ep)\n{\n\tu32 bEndpointAddress = ep->bEndpointAddress & 0xf;\n\n        if (bEndpointAddress < 8)\n                udc_set_reg(ep->dev, UICR0, udc_get_reg(ep->dev, UICR0) |\n\t\t\t\t\t\t(1 << bEndpointAddress));\n        else {\n                bEndpointAddress -= 8;\n                udc_set_reg(ep->dev, UICR1, udc_get_reg(ep->dev, UICR1) |\n\t\t\t\t\t\t(1 << bEndpointAddress));\n        }\n}\n\n \n#define UDCCR_MASK_BITS         (UDCCR_REM | UDCCR_SRM | UDCCR_UDE)\n\nstatic inline void udc_set_mask_UDCCR(struct pxa25x_udc *dev, int mask)\n{\n\tu32 udccr = udc_get_reg(dev, UDCCR);\n\n\tudc_set_reg(dev, (udccr & UDCCR_MASK_BITS) | (mask & UDCCR_MASK_BITS), UDCCR);\n}\n\nstatic inline void udc_clear_mask_UDCCR(struct pxa25x_udc *dev, int mask)\n{\n\tu32 udccr = udc_get_reg(dev, UDCCR);\n\n\tudc_set_reg(dev, (udccr & UDCCR_MASK_BITS) & ~(mask & UDCCR_MASK_BITS), UDCCR);\n}\n\nstatic inline void udc_ack_int_UDCCR(struct pxa25x_udc *dev, int mask)\n{\n\t \n\tu32 udccr = udc_get_reg(dev, UDCCR) & UDCCR_MASK_BITS;\n\n\tudc_set_reg(dev, udccr | (mask & ~UDCCR_MASK_BITS), UDCCR);\n}\n\nstatic inline u32 udc_ep_get_UDCCS(struct pxa25x_ep *ep)\n{\n\treturn udc_get_reg(ep->dev, ep->regoff_udccs);\n}\n\nstatic inline void udc_ep_set_UDCCS(struct pxa25x_ep *ep, u32 data)\n{\n\tudc_set_reg(ep->dev, data, ep->regoff_udccs);\n}\n\nstatic inline u32 udc_ep0_get_UDCCS(struct pxa25x_udc *dev)\n{\n\treturn udc_get_reg(dev, UDCCS0);\n}\n\nstatic inline void udc_ep0_set_UDCCS(struct pxa25x_udc *dev, u32 data)\n{\n\tudc_set_reg(dev, data, UDCCS0);\n}\n\nstatic inline u32 udc_ep_get_UDDR(struct pxa25x_ep *ep)\n{\n\treturn udc_get_reg(ep->dev, ep->regoff_uddr);\n}\n\nstatic inline void udc_ep_set_UDDR(struct pxa25x_ep *ep, u32 data)\n{\n\tudc_set_reg(ep->dev, data, ep->regoff_uddr);\n}\n\nstatic inline u32 udc_ep_get_UBCR(struct pxa25x_ep *ep)\n{\n\treturn udc_get_reg(ep->dev, ep->regoff_ubcr);\n}\n\n \nstatic int pxa25x_ep_enable (struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct pxa25x_ep        *ep;\n\tstruct pxa25x_udc       *dev;\n\n\tep = container_of (_ep, struct pxa25x_ep, ep);\n\tif (!_ep || !desc || _ep->name == ep0name\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT\n\t\t\t|| ep->bEndpointAddress != desc->bEndpointAddress\n\t\t\t|| ep->fifo_size < usb_endpoint_maxp (desc)) {\n\t\tDMSG(\"%s, bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ep->bmAttributes != desc->bmAttributes\n\t\t\t&& ep->bmAttributes != USB_ENDPOINT_XFER_BULK\n\t\t\t&& desc->bmAttributes != USB_ENDPOINT_XFER_INT) {\n\t\tDMSG(\"%s, %s type mismatch\\n\", __func__, _ep->name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK\n\t\t\t\t&& usb_endpoint_maxp (desc)\n\t\t\t\t\t\t!= BULK_FIFO_SIZE)\n\t\t\t|| !desc->wMaxPacketSize) {\n\t\tDMSG(\"%s, bad %s maxpacket\\n\", __func__, _ep->name);\n\t\treturn -ERANGE;\n\t}\n\n\tdev = ep->dev;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tDMSG(\"%s, bogus device state\\n\", __func__);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tep->ep.desc = desc;\n\tep->stopped = 0;\n\tep->pio_irqs = 0;\n\tep->ep.maxpacket = usb_endpoint_maxp (desc);\n\n\t \n\tpxa25x_ep_fifo_flush (_ep);\n\n\t \n\n\tDBG(DBG_VERBOSE, \"enabled %s\\n\", _ep->name);\n\treturn 0;\n}\n\nstatic int pxa25x_ep_disable (struct usb_ep *_ep)\n{\n\tstruct pxa25x_ep\t*ep;\n\tunsigned long\t\tflags;\n\n\tep = container_of (_ep, struct pxa25x_ep, ep);\n\tif (!_ep || !ep->ep.desc) {\n\t\tDMSG(\"%s, %s not enabled\\n\", __func__,\n\t\t\t_ep ? ep->ep.name : NULL);\n\t\treturn -EINVAL;\n\t}\n\tlocal_irq_save(flags);\n\n\tnuke (ep, -ESHUTDOWN);\n\n\t \n\tpxa25x_ep_fifo_flush (_ep);\n\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\n\tlocal_irq_restore(flags);\n\tDBG(DBG_VERBOSE, \"%s disabled\\n\", _ep->name);\n\treturn 0;\n}\n\n \n\n \n\n \nstatic struct usb_request *\npxa25x_ep_alloc_request (struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct pxa25x_request *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD (&req->queue);\n\treturn &req->req;\n}\n\n\n \nstatic void\npxa25x_ep_free_request (struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct pxa25x_request\t*req;\n\n\treq = container_of (_req, struct pxa25x_request, req);\n\tWARN_ON(!list_empty (&req->queue));\n\tkfree(req);\n}\n\n \n\n \nstatic void done(struct pxa25x_ep *ep, struct pxa25x_request *req, int status)\n{\n\tunsigned\t\tstopped = ep->stopped;\n\n\tlist_del_init(&req->queue);\n\n\tif (likely (req->req.status == -EINPROGRESS))\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tDBG(DBG_VERBOSE, \"complete %s req %p stat %d len %u/%u\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\t \n\tep->stopped = 1;\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tep->stopped = stopped;\n}\n\n\nstatic inline void ep0_idle (struct pxa25x_udc *dev)\n{\n\tdev->ep0state = EP0_IDLE;\n}\n\nstatic int\nwrite_packet(struct pxa25x_ep *ep, struct pxa25x_request *req, unsigned max)\n{\n\tu8\t\t*buf;\n\tunsigned\tlength, count;\n\n\tbuf = req->req.buf + req->req.actual;\n\tprefetch(buf);\n\n\t \n\tlength = min(req->req.length - req->req.actual, max);\n\treq->req.actual += length;\n\n\tcount = length;\n\twhile (likely(count--))\n\t\tudc_ep_set_UDDR(ep, *buf++);\n\n\treturn length;\n}\n\n \nstatic int\nwrite_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\n{\n\tunsigned\t\tmax;\n\n\tmax = usb_endpoint_maxp(ep->ep.desc);\n\tdo {\n\t\tunsigned\tcount;\n\t\tint\t\tis_last, is_short;\n\n\t\tcount = write_packet(ep, req, max);\n\n\t\t \n\t\tif (unlikely (count != max))\n\t\t\tis_last = is_short = 1;\n\t\telse {\n\t\t\tif (likely(req->req.length != req->req.actual)\n\t\t\t\t\t|| req->req.zero)\n\t\t\t\tis_last = 0;\n\t\t\telse\n\t\t\t\tis_last = 1;\n\t\t\t \n\t\t\tis_short = unlikely (max < ep->fifo_size);\n\t\t}\n\n\t\tDBG(DBG_VERY_NOISY, \"wrote %s %d bytes%s%s %d left %p\\n\",\n\t\t\tep->ep.name, count,\n\t\t\tis_last ? \"/L\" : \"\", is_short ? \"/S\" : \"\",\n\t\t\treq->req.length - req->req.actual, req);\n\n\t\t \n\t\tudc_ep_set_UDCCS(ep, UDCCS_BI_TPC);\n\t\tif (is_short)\n\t\t\tudc_ep_set_UDCCS(ep, UDCCS_BI_TSP);\n\n\t\t \n\t\tif (is_last) {\n\t\t\tdone (ep, req, 0);\n\t\t\tif (list_empty(&ep->queue))\n\t\t\t\tpio_irq_disable(ep);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\n\t} while (udc_ep_get_UDCCS(ep) & UDCCS_BI_TFS);\n\treturn 0;\n}\n\n \nstatic inline\nvoid ep0start(struct pxa25x_udc *dev, u32 flags, const char *tag)\n{\n\tudc_ep0_set_UDCCS(dev, flags|UDCCS0_SA|UDCCS0_OPR);\n\tudc_set_reg(dev, USIR0, USIR0_IR0);\n\tdev->req_pending = 0;\n\tDBG(DBG_VERY_NOISY, \"%s %s, %02x/%02x\\n\",\n\t\t__func__, tag, udc_ep0_get_UDCCS(dev), flags);\n}\n\nstatic int\nwrite_ep0_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\n{\n\tstruct pxa25x_udc *dev = ep->dev;\n\tunsigned\tcount;\n\tint\t\tis_short;\n\n\tcount = write_packet(&dev->ep[0], req, EP0_FIFO_SIZE);\n\tep->dev->stats.write.bytes += count;\n\n\t \n\tis_short = (count != EP0_FIFO_SIZE);\n\n\tDBG(DBG_VERY_NOISY, \"ep0in %d bytes %d left %p\\n\", count,\n\t\treq->req.length - req->req.actual, req);\n\n\tif (unlikely (is_short)) {\n\t\tif (ep->dev->req_pending)\n\t\t\tep0start(ep->dev, UDCCS0_IPR, \"short IN\");\n\t\telse\n\t\t\tudc_ep0_set_UDCCS(dev, UDCCS0_IPR);\n\n\t\tcount = req->req.length;\n\t\tdone (ep, req, 0);\n\t\tep0_idle(ep->dev);\n#ifndef CONFIG_ARCH_IXP4XX\n#if 1\n\t\t \n\t\tif (count >= EP0_FIFO_SIZE) {\n\t\t\tcount = 100;\n\t\t\tdo {\n\t\t\t\tif ((udc_ep0_get_UDCCS(dev) & UDCCS0_OPR) != 0) {\n\t\t\t\t\t \n\t\t\t\t\tudc_ep0_set_UDCCS(dev, UDCCS0_OPR);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcount--;\n\t\t\t\tudelay(1);\n\t\t\t} while (count);\n\t\t}\n#endif\n#endif\n\t} else if (ep->dev->req_pending)\n\t\tep0start(ep->dev, 0, \"IN\");\n\treturn is_short;\n}\n\n\n \nstatic int\nread_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\n{\n\tfor (;;) {\n\t\tu32\t\tudccs;\n\t\tu8\t\t*buf;\n\t\tunsigned\tbufferspace, count, is_short;\n\n\t\t \n\t\tudccs = udc_ep_get_UDCCS(ep);\n\t\tif (unlikely ((udccs & UDCCS_BO_RPC) == 0))\n\t\t\tbreak;\n\t\tbuf = req->req.buf + req->req.actual;\n\t\tprefetchw(buf);\n\t\tbufferspace = req->req.length - req->req.actual;\n\n\t\t \n\t\tif (likely (udccs & UDCCS_BO_RNE)) {\n\t\t\tcount = 1 + (0x0ff & udc_ep_get_UBCR(ep));\n\t\t\treq->req.actual += min (count, bufferspace);\n\t\t} else  \n\t\t\tcount = 0;\n\t\tis_short = (count < ep->ep.maxpacket);\n\t\tDBG(DBG_VERY_NOISY, \"read %s %02x, %d bytes%s req %p %d/%d\\n\",\n\t\t\tep->ep.name, udccs, count,\n\t\t\tis_short ? \"/S\" : \"\",\n\t\t\treq, req->req.actual, req->req.length);\n\t\twhile (likely (count-- != 0)) {\n\t\t\tu8\tbyte = (u8) udc_ep_get_UDDR(ep);\n\n\t\t\tif (unlikely (bufferspace == 0)) {\n\t\t\t\t \n\t\t\t\tif (req->req.status != -EOVERFLOW)\n\t\t\t\t\tDMSG(\"%s overflow %d\\n\",\n\t\t\t\t\t\tep->ep.name, count);\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t} else {\n\t\t\t\t*buf++ = byte;\n\t\t\t\tbufferspace--;\n\t\t\t}\n\t\t}\n\t\tudc_ep_set_UDCCS(ep, UDCCS_BO_RPC);\n\t\t \n\n\t\t \n\t\tif (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tif (udccs & UDCCS_IO_ROF)\n\t\t\t\treq->req.status = -EHOSTUNREACH;\n\t\t\t \n\t\t\tis_short = 1;\n\t\t}\n\n\t\t \n\t\tif (is_short || req->req.actual == req->req.length) {\n\t\t\tdone (ep, req, 0);\n\t\t\tif (list_empty(&ep->queue))\n\t\t\t\tpio_irq_disable(ep);\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t}\n\treturn 0;\n}\n\n \nstatic int\nread_ep0_fifo (struct pxa25x_ep *ep, struct pxa25x_request *req)\n{\n\tu8\t\t*buf, byte;\n\tunsigned\tbufferspace;\n\n\tbuf = req->req.buf + req->req.actual;\n\tbufferspace = req->req.length - req->req.actual;\n\n\twhile (udc_ep_get_UDCCS(ep) & UDCCS0_RNE) {\n\t\tbyte = (u8) UDDR0;\n\n\t\tif (unlikely (bufferspace == 0)) {\n\t\t\t \n\t\t\tif (req->req.status != -EOVERFLOW)\n\t\t\t\tDMSG(\"%s overflow\\n\", ep->ep.name);\n\t\t\treq->req.status = -EOVERFLOW;\n\t\t} else {\n\t\t\t*buf++ = byte;\n\t\t\treq->req.actual++;\n\t\t\tbufferspace--;\n\t\t}\n\t}\n\n\tudc_ep_set_UDCCS(ep, UDCCS0_OPR | UDCCS0_IPR);\n\n\t \n\tif (req->req.actual >= req->req.length)\n\t\treturn 1;\n\n\t \n\treturn 0;\n}\n\n \n\nstatic int\npxa25x_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct pxa25x_request\t*req;\n\tstruct pxa25x_ep\t*ep;\n\tstruct pxa25x_udc\t*dev;\n\tunsigned long\t\tflags;\n\n\treq = container_of(_req, struct pxa25x_request, req);\n\tif (unlikely (!_req || !_req->complete || !_req->buf\n\t\t\t|| !list_empty(&req->queue))) {\n\t\tDMSG(\"%s, bad params\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = container_of(_ep, struct pxa25x_ep, ep);\n\tif (unlikely(!_ep || (!ep->ep.desc && ep->ep.name != ep0name))) {\n\t\tDMSG(\"%s, bad ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = ep->dev;\n\tif (unlikely (!dev->driver\n\t\t\t|| dev->gadget.speed == USB_SPEED_UNKNOWN)) {\n\t\tDMSG(\"%s, bogus device state\\n\", __func__);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (unlikely (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\n\t\t\t&& req->req.length > usb_endpoint_maxp(ep->ep.desc)))\n\t\treturn -EMSGSIZE;\n\n\tDBG(DBG_NOISY, \"%s queue req %p, len %d buf %p\\n\",\n\t\t_ep->name, _req, _req->length, _req->buf);\n\n\tlocal_irq_save(flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\t \n\tif (list_empty(&ep->queue) && !ep->stopped) {\n\t\tif (ep->ep.desc == NULL ) {\n\t\t\tunsigned\tlength = _req->length;\n\n\t\t\tswitch (dev->ep0state) {\n\t\t\tcase EP0_IN_DATA_PHASE:\n\t\t\t\tdev->stats.write.ops++;\n\t\t\t\tif (write_ep0_fifo(ep, req))\n\t\t\t\t\treq = NULL;\n\t\t\t\tbreak;\n\n\t\t\tcase EP0_OUT_DATA_PHASE:\n\t\t\t\tdev->stats.read.ops++;\n\t\t\t\t \n\t\t\t\tif (dev->req_config) {\n\t\t\t\t\tDBG(DBG_VERBOSE, \"ep0 config ack%s\\n\",\n\t\t\t\t\t\tdev->has_cfr ?  \"\" : \" raced\");\n\t\t\t\t\tif (dev->has_cfr)\n\t\t\t\t\t\tudc_set_reg(dev, UDCCFR, UDCCFR_AREN |\n\t\t\t\t\t\t\t    UDCCFR_ACM | UDCCFR_MB1);\n\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t\tdev->ep0state = EP0_END_XFER;\n\t\t\t\t\tlocal_irq_restore (flags);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif (dev->req_pending)\n\t\t\t\t\tep0start(dev, UDCCS0_IPR, \"OUT\");\n\t\t\t\tif (length == 0 || ((udc_ep0_get_UDCCS(dev) & UDCCS0_RNE) != 0\n\t\t\t\t\t\t&& read_ep0_fifo(ep, req))) {\n\t\t\t\t\tep0_idle(dev);\n\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t\treq = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tDMSG(\"ep0 i/o, odd state %d\\n\", dev->ep0state);\n\t\t\t\tlocal_irq_restore (flags);\n\t\t\t\treturn -EL2HLT;\n\t\t\t}\n\t\t \n\t\t} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0) {\n\t\t\tif ((udc_ep_get_UDCCS(ep) & UDCCS_BI_TFS) != 0\n\t\t\t\t\t&& write_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t} else if ((udc_ep_get_UDCCS(ep) & UDCCS_BO_RFS) != 0\n\t\t\t\t&& read_fifo(ep, req)) {\n\t\t\treq = NULL;\n\t\t}\n\n\t\tif (likely(req && ep->ep.desc))\n\t\t\tpio_irq_enable(ep);\n\t}\n\n\t \n\tif (likely(req != NULL))\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n\n \nstatic void nuke(struct pxa25x_ep *ep, int status)\n{\n\tstruct pxa25x_request *req;\n\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct pxa25x_request,\n\t\t\t\tqueue);\n\t\tdone(ep, req, status);\n\t}\n\tif (ep->ep.desc)\n\t\tpio_irq_disable(ep);\n}\n\n\n \nstatic int pxa25x_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct pxa25x_ep\t*ep;\n\tstruct pxa25x_request\t*req = NULL;\n\tstruct pxa25x_request\t*iter;\n\tunsigned long\t\tflags;\n\n\tep = container_of(_ep, struct pxa25x_ep, ep);\n\tif (!_ep || ep->ep.name == ep0name)\n\t\treturn -EINVAL;\n\n\tlocal_irq_save(flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tlocal_irq_restore(flags);\n\t\treturn -EINVAL;\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\n\n \n\nstatic int pxa25x_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct pxa25x_ep\t*ep;\n\tunsigned long\t\tflags;\n\n\tep = container_of(_ep, struct pxa25x_ep, ep);\n\tif (unlikely (!_ep\n\t\t\t|| (!ep->ep.desc && ep->ep.name != ep0name))\n\t\t\t|| ep->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tDMSG(\"%s, bad ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (value == 0) {\n\t\t \n\t\tDMSG(\"only host can clear %s halt\\n\", _ep->name);\n\t\treturn -EROFS;\n\t}\n\n\tlocal_irq_save(flags);\n\n\tif ((ep->bEndpointAddress & USB_DIR_IN) != 0\n\t\t\t&& ((udc_ep_get_UDCCS(ep) & UDCCS_BI_TFS) == 0\n\t\t\t   || !list_empty(&ep->queue))) {\n\t\tlocal_irq_restore(flags);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tudc_ep_set_UDCCS(ep, UDCCS_BI_FST|UDCCS_BI_FTF);\n\n\t \n\tif (!ep->ep.desc) {\n\t\tstart_watchdog(ep->dev);\n\t\tep->dev->req_pending = 0;\n\t\tep->dev->ep0state = EP0_STALL;\n\n\t \n\t} else {\n\t\tunsigned i;\n\t\tfor (i = 0; i < 1000; i += 20) {\n\t\t\tif (udc_ep_get_UDCCS(ep) & UDCCS_BI_SST)\n\t\t\t\tbreak;\n\t\t\tudelay(20);\n\t\t}\n\t}\n\tlocal_irq_restore(flags);\n\n\tDBG(DBG_VERBOSE, \"%s halt\\n\", _ep->name);\n\treturn 0;\n}\n\nstatic int pxa25x_ep_fifo_status(struct usb_ep *_ep)\n{\n\tstruct pxa25x_ep        *ep;\n\n\tep = container_of(_ep, struct pxa25x_ep, ep);\n\tif (!_ep) {\n\t\tDMSG(\"%s, bad ep\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\t \n\tif ((ep->bEndpointAddress & USB_DIR_IN) != 0)\n\t\treturn -EOPNOTSUPP;\n\tif (ep->dev->gadget.speed == USB_SPEED_UNKNOWN\n\t\t\t|| (udc_ep_get_UDCCS(ep) & UDCCS_BO_RFS) == 0)\n\t\treturn 0;\n\telse\n\t\treturn (udc_ep_get_UBCR(ep) & 0xfff) + 1;\n}\n\nstatic void pxa25x_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct pxa25x_ep        *ep;\n\n\tep = container_of(_ep, struct pxa25x_ep, ep);\n\tif (!_ep || ep->ep.name == ep0name || !list_empty(&ep->queue)) {\n\t\tDMSG(\"%s, bad ep\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\tif ((ep->bEndpointAddress & USB_DIR_IN) == 0) {\n\t\twhile (((udc_ep_get_UDCCS(ep)) & UDCCS_BO_RNE) != 0)\n\t\t\t(void)udc_ep_get_UDDR(ep);\n\t\treturn;\n\t}\n\n\t \n\tudc_ep_set_UDCCS(ep, UDCCS_BI_TPC|UDCCS_BI_FTF|UDCCS_BI_TUR\n\t\t| (ep->bmAttributes == USB_ENDPOINT_XFER_ISOC\n\t\t\t? 0 : UDCCS_BI_SST));\n}\n\n\nstatic const struct usb_ep_ops pxa25x_ep_ops = {\n\t.enable\t\t= pxa25x_ep_enable,\n\t.disable\t= pxa25x_ep_disable,\n\n\t.alloc_request\t= pxa25x_ep_alloc_request,\n\t.free_request\t= pxa25x_ep_free_request,\n\n\t.queue\t\t= pxa25x_ep_queue,\n\t.dequeue\t= pxa25x_ep_dequeue,\n\n\t.set_halt\t= pxa25x_ep_set_halt,\n\t.fifo_status\t= pxa25x_ep_fifo_status,\n\t.fifo_flush\t= pxa25x_ep_fifo_flush,\n};\n\n\n \n\nstatic int pxa25x_udc_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct pxa25x_udc\t*dev;\n\n\tdev = container_of(_gadget, struct pxa25x_udc, gadget);\n\treturn ((udc_get_reg(dev, UFNRH) & 0x07) << 8) |\n\t\t(udc_get_reg(dev, UFNRL) & 0xff);\n}\n\nstatic int pxa25x_udc_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct pxa25x_udc\t*udc;\n\n\tudc = container_of(_gadget, struct pxa25x_udc, gadget);\n\n\t \n\tif ((udc_ep0_get_UDCCS(udc) & UDCCS0_DRWF) == 0)\n\t\treturn -EHOSTUNREACH;\n\tudc_set_mask_UDCCR(udc, UDCCR_RSM);\n\treturn 0;\n}\n\nstatic void stop_activity(struct pxa25x_udc *, struct usb_gadget_driver *);\nstatic void udc_enable (struct pxa25x_udc *);\nstatic void udc_disable(struct pxa25x_udc *);\n\n \nstatic int pullup(struct pxa25x_udc *udc)\n{\n\tint is_active = udc->vbus && udc->pullup && !udc->suspended;\n\tDMSG(\"%s\\n\", is_active ? \"active\" : \"inactive\");\n\tif (is_active) {\n\t\tif (!udc->active) {\n\t\t\tudc->active = 1;\n\t\t\t \n\t\t\tclk_enable(udc->clk);\n\t\t\tudc_enable(udc);\n\t\t}\n\t} else {\n\t\tif (udc->active) {\n\t\t\tif (udc->gadget.speed != USB_SPEED_UNKNOWN) {\n\t\t\t\tDMSG(\"disconnect %s\\n\", udc->driver\n\t\t\t\t\t? udc->driver->driver.name\n\t\t\t\t\t: \"(no driver)\");\n\t\t\t\tstop_activity(udc, udc->driver);\n\t\t\t}\n\t\t\tudc_disable(udc);\n\t\t\t \n\t\t\tclk_disable(udc->clk);\n\t\t\tudc->active = 0;\n\t\t}\n\n\t}\n\treturn 0;\n}\n\n \nstatic int pxa25x_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct pxa25x_udc\t*udc;\n\n\tudc = container_of(_gadget, struct pxa25x_udc, gadget);\n\tudc->vbus = is_active;\n\tDMSG(\"vbus %s\\n\", is_active ? \"supplied\" : \"inactive\");\n\tpullup(udc);\n\treturn 0;\n}\n\n \nstatic int pxa25x_udc_pullup(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct pxa25x_udc\t*udc;\n\n\tudc = container_of(_gadget, struct pxa25x_udc, gadget);\n\n\t \n\tif (!gpio_is_valid(udc->mach->gpio_pullup) && !udc->mach->udc_command)\n\t\treturn -EOPNOTSUPP;\n\n\tudc->pullup = (is_active != 0);\n\tpullup(udc);\n\treturn 0;\n}\n\n \nstatic int pxa25x_udc_vbus_draw(struct usb_gadget *_gadget, unsigned mA)\n{\n\tstruct pxa25x_udc\t*udc;\n\n\tudc = container_of(_gadget, struct pxa25x_udc, gadget);\n\n\tif (!IS_ERR_OR_NULL(udc->transceiver))\n\t\treturn usb_phy_set_power(udc->transceiver, mA);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pxa25x_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int pxa25x_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops pxa25x_udc_ops = {\n\t.get_frame\t= pxa25x_udc_get_frame,\n\t.wakeup\t\t= pxa25x_udc_wakeup,\n\t.vbus_session\t= pxa25x_udc_vbus_session,\n\t.pullup\t\t= pxa25x_udc_pullup,\n\t.vbus_draw\t= pxa25x_udc_vbus_draw,\n\t.udc_start\t= pxa25x_udc_start,\n\t.udc_stop\t= pxa25x_udc_stop,\n};\n\n \n\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n\nstatic int udc_debug_show(struct seq_file *m, void *_d)\n{\n\tstruct pxa25x_udc\t*dev = m->private;\n\tunsigned long\t\tflags;\n\tint\t\t\ti;\n\tu32\t\t\ttmp;\n\n\tlocal_irq_save(flags);\n\n\t \n\tseq_printf(m, DRIVER_DESC \"\\n\"\n\t\t\"%s version: %s\\nGadget driver: %s\\nHost %s\\n\\n\",\n\t\tdriver_name, DRIVER_VERSION SIZE_STR \"(pio)\",\n\t\tdev->driver ? dev->driver->driver.name : \"(none)\",\n\t\tdev->gadget.speed == USB_SPEED_FULL ? \"full speed\" : \"disconnected\");\n\n\t \n\tseq_printf(m,\n\t\t\"uicr %02X.%02X, usir %02X.%02x, ufnr %02X.%02X\\n\",\n\t\tudc_get_reg(dev, UICR1), udc_get_reg(dev, UICR0),\n\t\tudc_get_reg(dev, USIR1), udc_get_reg(dev, USIR0),\n\t\tudc_get_reg(dev, UFNRH), udc_get_reg(dev, UFNRL));\n\n\ttmp = udc_get_reg(dev, UDCCR);\n\tseq_printf(m,\n\t\t\"udccr %02X =%s%s%s%s%s%s%s%s\\n\", tmp,\n\t\t(tmp & UDCCR_REM) ? \" rem\" : \"\",\n\t\t(tmp & UDCCR_RSTIR) ? \" rstir\" : \"\",\n\t\t(tmp & UDCCR_SRM) ? \" srm\" : \"\",\n\t\t(tmp & UDCCR_SUSIR) ? \" susir\" : \"\",\n\t\t(tmp & UDCCR_RESIR) ? \" resir\" : \"\",\n\t\t(tmp & UDCCR_RSM) ? \" rsm\" : \"\",\n\t\t(tmp & UDCCR_UDA) ? \" uda\" : \"\",\n\t\t(tmp & UDCCR_UDE) ? \" ude\" : \"\");\n\n\ttmp = udc_ep0_get_UDCCS(dev);\n\tseq_printf(m,\n\t\t\"udccs0 %02X =%s%s%s%s%s%s%s%s\\n\", tmp,\n\t\t(tmp & UDCCS0_SA) ? \" sa\" : \"\",\n\t\t(tmp & UDCCS0_RNE) ? \" rne\" : \"\",\n\t\t(tmp & UDCCS0_FST) ? \" fst\" : \"\",\n\t\t(tmp & UDCCS0_SST) ? \" sst\" : \"\",\n\t\t(tmp & UDCCS0_DRWF) ? \" dwrf\" : \"\",\n\t\t(tmp & UDCCS0_FTF) ? \" ftf\" : \"\",\n\t\t(tmp & UDCCS0_IPR) ? \" ipr\" : \"\",\n\t\t(tmp & UDCCS0_OPR) ? \" opr\" : \"\");\n\n\tif (dev->has_cfr) {\n\t\ttmp = udc_get_reg(dev, UDCCFR);\n\t\tseq_printf(m,\n\t\t\t\"udccfr %02X =%s%s\\n\", tmp,\n\t\t\t(tmp & UDCCFR_AREN) ? \" aren\" : \"\",\n\t\t\t(tmp & UDCCFR_ACM) ? \" acm\" : \"\");\n\t}\n\n\tif (dev->gadget.speed != USB_SPEED_FULL || !dev->driver)\n\t\tgoto done;\n\n\tseq_printf(m, \"ep0 IN %lu/%lu, OUT %lu/%lu\\nirqs %lu\\n\\n\",\n\t\tdev->stats.write.bytes, dev->stats.write.ops,\n\t\tdev->stats.read.bytes, dev->stats.read.ops,\n\t\tdev->stats.irqs);\n\n\t \n\tfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\n\t\tstruct pxa25x_ep\t*ep = &dev->ep [i];\n\t\tstruct pxa25x_request\t*req;\n\n\t\tif (i != 0) {\n\t\t\tconst struct usb_endpoint_descriptor\t*desc;\n\n\t\t\tdesc = ep->ep.desc;\n\t\t\tif (!desc)\n\t\t\t\tcontinue;\n\t\t\ttmp = udc_ep_get_UDCCS(&dev->ep[i]);\n\t\t\tseq_printf(m,\n\t\t\t\t\"%s max %d %s udccs %02x irqs %lu\\n\",\n\t\t\t\tep->ep.name, usb_endpoint_maxp(desc),\n\t\t\t\t\"pio\", tmp, ep->pio_irqs);\n\t\t\t \n\n\t\t} else  \n\t\t\tseq_printf(m, \"ep0 max 16 pio irqs %lu\\n\",\n\t\t\t\tep->pio_irqs);\n\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tseq_printf(m, \"\\t(nothing queued)\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\tseq_printf(m,\n\t\t\t\t\t\"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t\t&req->req, req->req.actual,\n\t\t\t\t\treq->req.length, req->req.buf);\n\t\t}\n\t}\n\ndone:\n\tlocal_irq_restore(flags);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(udc_debug);\n\n#define create_debug_files(dev) \\\n\tdo { \\\n\t\tdebugfs_create_file(dev->gadget.name, \\\n\t\t\tS_IRUGO, NULL, dev, &udc_debug_fops); \\\n\t} while (0)\n#define remove_debug_files(dev) debugfs_lookup_and_remove(dev->gadget.name, NULL)\n\n#else\t \n\n#define create_debug_files(dev) do {} while (0)\n#define remove_debug_files(dev) do {} while (0)\n\n#endif\t \n\n \n\n \nstatic void udc_disable(struct pxa25x_udc *dev)\n{\n\t \n\tudc_set_mask_UDCCR(dev, UDCCR_SRM|UDCCR_REM);\n\tudc_set_reg(dev, UICR0, 0xff);\n\tudc_set_reg(dev, UICR1, 0xff);\n\tudc_set_reg(dev, UFNRH, UFNRH_SIM);\n\n\t \n\tpullup_off();\n\n\tudc_clear_mask_UDCCR(dev, UDCCR_UDE);\n\n\tep0_idle (dev);\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n}\n\n\n \nstatic void udc_reinit(struct pxa25x_udc *dev)\n{\n\tu32\ti;\n\n\t \n\tINIT_LIST_HEAD (&dev->gadget.ep_list);\n\tINIT_LIST_HEAD (&dev->gadget.ep0->ep_list);\n\tdev->ep0state = EP0_IDLE;\n\tdev->gadget.quirk_altset_not_supp = 1;\n\n\t \n\tfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\n\t\tstruct pxa25x_ep *ep = &dev->ep[i];\n\n\t\tif (i != 0)\n\t\t\tlist_add_tail (&ep->ep.ep_list, &dev->gadget.ep_list);\n\n\t\tep->ep.desc = NULL;\n\t\tep->stopped = 0;\n\t\tINIT_LIST_HEAD (&ep->queue);\n\t\tep->pio_irqs = 0;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ep->ep.maxpacket);\n\t}\n\n\t \n}\n\n \nstatic void udc_enable (struct pxa25x_udc *dev)\n{\n\tudc_clear_mask_UDCCR(dev, UDCCR_UDE);\n\n\t \n\tudc_ack_int_UDCCR(dev, UDCCR_SUSIR| UDCCR_RESIR);\n\n\tep0_idle(dev);\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tdev->stats.irqs = 0;\n\n\t \n\tudc_set_mask_UDCCR(dev, UDCCR_UDE);\n\tif (!(udc_get_reg(dev, UDCCR) & UDCCR_UDA))\n\t\tudc_ack_int_UDCCR(dev, UDCCR_RSTIR);\n\n\tif (dev->has_cfr  ) {\n\t\t \n\t\tudc_set_reg(dev, UDCCFR, UDCCFR_ACM | UDCCFR_MB1);\n\t} else {\n\t\t \n\t\tudc_set_reg(dev, UDC_RES1, 0x00);\n\t\tudc_set_reg(dev, UDC_RES2, 0x00);\n\t}\n\n\t \n\tudc_clear_mask_UDCCR(dev, UDCCR_SRM | UDCCR_REM);\n\n\t \n\tudc_set_reg(dev, UICR0, udc_get_reg(dev, UICR0) & ~UICR0_IM0);\n\n\t \n\tpullup_on();\n}\n\n\n \nstatic int pxa25x_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct pxa25x_udc\t*dev = to_pxa25x(g);\n\tint\t\t\tretval;\n\n\t \n\tdev->driver = driver;\n\tdev->pullup = 1;\n\n\t \n\t \n\tif (!IS_ERR_OR_NULL(dev->transceiver)) {\n\t\tretval = otg_set_peripheral(dev->transceiver->otg,\n\t\t\t\t\t\t&dev->gadget);\n\t\tif (retval)\n\t\t\tgoto bind_fail;\n\t}\n\n\tdump_state(dev);\n\treturn 0;\nbind_fail:\n\treturn retval;\n}\n\nstatic void\nreset_gadget(struct pxa25x_udc *dev, struct usb_gadget_driver *driver)\n{\n\tint i;\n\n\t \n\tif (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\n\t\tstruct pxa25x_ep *ep = &dev->ep[i];\n\n\t\tep->stopped = 1;\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\tdel_timer_sync(&dev->timer);\n\n\t \n\tif (driver)\n\t\tusb_gadget_udc_reset(&dev->gadget, driver);\n\n\t \n\tudc_reinit(dev);\n}\n\nstatic void\nstop_activity(struct pxa25x_udc *dev, struct usb_gadget_driver *driver)\n{\n\tint i;\n\n\t \n\tif (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tfor (i = 0; i < PXA_UDC_NUM_ENDPOINTS; i++) {\n\t\tstruct pxa25x_ep *ep = &dev->ep[i];\n\n\t\tep->stopped = 1;\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\tdel_timer_sync(&dev->timer);\n\n\t \n\tif (driver)\n\t\tdriver->disconnect(&dev->gadget);\n\n\t \n\tudc_reinit(dev);\n}\n\nstatic int pxa25x_udc_stop(struct usb_gadget*g)\n{\n\tstruct pxa25x_udc\t*dev = to_pxa25x(g);\n\n\tlocal_irq_disable();\n\tdev->pullup = 0;\n\tstop_activity(dev, NULL);\n\tlocal_irq_enable();\n\n\tif (!IS_ERR_OR_NULL(dev->transceiver))\n\t\t(void) otg_set_peripheral(dev->transceiver->otg, NULL);\n\n\tdev->driver = NULL;\n\n\tdump_state(dev);\n\n\treturn 0;\n}\n\n \n\nstatic inline void clear_ep_state (struct pxa25x_udc *dev)\n{\n\tunsigned i;\n\n\t \n\tfor (i = 1; i < PXA_UDC_NUM_ENDPOINTS; i++)\n\t\tnuke(&dev->ep[i], -ECONNABORTED);\n}\n\nstatic void udc_watchdog(struct timer_list *t)\n{\n\tstruct pxa25x_udc\t*dev = from_timer(dev, t, timer);\n\n\tlocal_irq_disable();\n\tif (dev->ep0state == EP0_STALL\n\t\t\t&& (udc_ep0_get_UDCCS(dev) & UDCCS0_FST) == 0\n\t\t\t&& (udc_ep0_get_UDCCS(dev) & UDCCS0_SST) == 0) {\n\t\tudc_ep0_set_UDCCS(dev, UDCCS0_FST|UDCCS0_FTF);\n\t\tDBG(DBG_VERBOSE, \"ep0 re-stall\\n\");\n\t\tstart_watchdog(dev);\n\t}\n\tlocal_irq_enable();\n}\n\nstatic void handle_ep0 (struct pxa25x_udc *dev)\n{\n\tu32\t\t\tudccs0 = udc_ep0_get_UDCCS(dev);\n\tstruct pxa25x_ep\t*ep = &dev->ep [0];\n\tstruct pxa25x_request\t*req;\n\tunion {\n\t\tstruct usb_ctrlrequest\tr;\n\t\tu8\t\t\traw [8];\n\t\tu32\t\t\tword [2];\n\t} u;\n\n\tif (list_empty(&ep->queue))\n\t\treq = NULL;\n\telse\n\t\treq = list_entry(ep->queue.next, struct pxa25x_request, queue);\n\n\t \n\tif (udccs0 & UDCCS0_SST) {\n\t\tnuke(ep, -EPIPE);\n\t\tudc_ep0_set_UDCCS(dev, UDCCS0_SST);\n\t\tdel_timer(&dev->timer);\n\t\tep0_idle(dev);\n\t}\n\n\t \n\tif ((udccs0 & UDCCS0_SA) != 0 && dev->ep0state != EP0_IDLE) {\n\t\tnuke(ep, 0);\n\t\tdel_timer(&dev->timer);\n\t\tep0_idle(dev);\n\t}\n\n\tswitch (dev->ep0state) {\n\tcase EP0_IDLE:\n\t\t \n\t\tudccs0 = udc_ep0_get_UDCCS(dev);\n\n\t\t \n\t\tif (likely((udccs0 & (UDCCS0_OPR|UDCCS0_SA|UDCCS0_RNE))\n\t\t\t\t== (UDCCS0_OPR|UDCCS0_SA|UDCCS0_RNE))) {\n\t\t\tint i;\n\n\t\t\tnuke (ep, -EPROTO);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tif (unlikely(!(udc_ep0_get_UDCCS(dev) & UDCCS0_RNE))) {\nbad_setup:\n\t\t\t\t\tDMSG(\"SETUP %d!\\n\", i);\n\t\t\t\t\tgoto stall;\n\t\t\t\t}\n\t\t\t\tu.raw [i] = (u8) UDDR0;\n\t\t\t}\n\t\t\tif (unlikely((udc_ep0_get_UDCCS(dev) & UDCCS0_RNE) != 0))\n\t\t\t\tgoto bad_setup;\n\ngot_setup:\n\t\t\tDBG(DBG_VERBOSE, \"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t\t\tu.r.bRequestType, u.r.bRequest,\n\t\t\t\tle16_to_cpu(u.r.wValue),\n\t\t\t\tle16_to_cpu(u.r.wIndex),\n\t\t\t\tle16_to_cpu(u.r.wLength));\n\n\t\t\t \n\t\t\tdev->req_std = (u.r.bRequestType & USB_TYPE_MASK)\n\t\t\t\t\t\t== USB_TYPE_STANDARD;\n\t\t\tdev->req_config = 0;\n\t\t\tdev->req_pending = 1;\n\t\t\tswitch (u.r.bRequest) {\n\t\t\t \n\t\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\t\tif (u.r.bRequestType == USB_RECIP_DEVICE) {\n\t\t\t\t\t \nconfig_change:\n\t\t\t\t\tdev->req_config = 1;\n\t\t\t\t\tclear_ep_state(dev);\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase USB_REQ_SET_INTERFACE:\n\t\t\t\tif (u.r.bRequestType == USB_RECIP_INTERFACE) {\n\t\t\t\t\t \n\t\t\t\t\tDMSG(\"broken set_interface (%d/%d)\\n\",\n\t\t\t\t\t\tle16_to_cpu(u.r.wIndex),\n\t\t\t\t\t\tle16_to_cpu(u.r.wValue));\n\t\t\t\t\tgoto config_change;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t\tif (u.r.bRequestType == USB_RECIP_DEVICE) {\n\t\t\t\t\tep0start(dev, 0, \"address\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (u.r.bRequestType & USB_DIR_IN)\n\t\t\t\tdev->ep0state = EP0_IN_DATA_PHASE;\n\t\t\telse\n\t\t\t\tdev->ep0state = EP0_OUT_DATA_PHASE;\n\n\t\t\ti = dev->driver->setup(&dev->gadget, &u.r);\n\t\t\tif (i < 0) {\n\t\t\t\t \n\t\t\t\tif (dev->req_config) {\n\t\t\t\t\t \n\t\t\t\t\tWARNING(\"config change %02x fail %d?\\n\",\n\t\t\t\t\t\tu.r.bRequest, i);\n\t\t\t\t\treturn;\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\tDBG(DBG_VERBOSE, \"protocol STALL, \"\n\t\t\t\t\t\"%02x err %d\\n\", udc_ep0_get_UDCCS(dev), i);\nstall:\n\t\t\t\t \n\t\t\t\tep0start(dev, UDCCS0_FST|UDCCS0_FTF, \"stall\");\n\t\t\t\tstart_watchdog(dev);\n\t\t\t\tdev->ep0state = EP0_STALL;\n\n\t\t\t \n\t\t\t} else if (dev->req_pending) {\n\t\t\t\tif (likely(dev->ep0state == EP0_IN_DATA_PHASE\n\t\t\t\t\t\t|| dev->req_std || u.r.wLength))\n\t\t\t\t\tep0start(dev, 0, \"defer\");\n\t\t\t\telse\n\t\t\t\t\tep0start(dev, UDCCS0_IPR, \"defer/IPR\");\n\t\t\t}\n\n\t\t\t \n\t\t\treturn;\n\n\t\t} else if (likely((udccs0 & (UDCCS0_OPR|UDCCS0_SA))\n\t\t\t\t== (UDCCS0_OPR|UDCCS0_SA))) {\n\t\t\tunsigned i;\n\n\t\t\t \n\t\t\tDBG(DBG_VERBOSE, \"e131\\n\");\n\t\t\tnuke(ep, -EPROTO);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\tu.raw [i] = (u8) UDDR0;\n\t\t\tif ((u.r.bRequestType & USB_RECIP_MASK)\n\t\t\t\t\t> USB_RECIP_OTHER)\n\t\t\t\tgoto stall;\n\t\t\tif (u.word [0] == 0 && u.word [1] == 0)\n\t\t\t\tgoto stall;\n\t\t\tgoto got_setup;\n\t\t} else {\n\t\t\t \n\t\t\tudc_ep0_set_UDCCS(dev, udccs0 & (UDCCS0_SA|UDCCS0_OPR));\n\t\t}\n\t\tbreak;\n\tcase EP0_IN_DATA_PHASE:\t\t\t \n\t\tif (udccs0 & UDCCS0_OPR) {\n\t\t\tudc_ep0_set_UDCCS(dev, UDCCS0_OPR|UDCCS0_FTF);\n\t\t\tDBG(DBG_VERBOSE, \"ep0in premature status\\n\");\n\t\t\tif (req)\n\t\t\t\tdone(ep, req, 0);\n\t\t\tep0_idle(dev);\n\t\t} else   {\n\t\t\tif (req) {\n\t\t\t\t \n\t\t\t\t(void) write_ep0_fifo(ep, req);\n\t\t\t}  \n\t\t}\n\t\tbreak;\n\tcase EP0_OUT_DATA_PHASE:\t\t \n\t\tif (udccs0 & UDCCS0_OPR) {\n\t\t\tif (req) {\n\t\t\t\t \n\t\t\t\tif (read_ep0_fifo(ep, req))\n\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t \n\t\t\t}  \n\t\t} else   {\n\t\t\tDBG(DBG_VERBOSE, \"ep0out premature status\\n\");\n\t\t\tif (req)\n\t\t\t\tdone(ep, req, 0);\n\t\t\tep0_idle(dev);\n\t\t}\n\t\tbreak;\n\tcase EP0_END_XFER:\n\t\tif (req)\n\t\t\tdone(ep, req, 0);\n\t\t \n\t\tif (udccs0 & UDCCS0_OPR)\n\t\t\tudc_ep0_set_UDCCS(dev, UDCCS0_OPR);\n\t\tep0_idle(dev);\n\t\tbreak;\n\tcase EP0_STALL:\n\t\tudc_ep0_set_UDCCS(dev, UDCCS0_FST);\n\t\tbreak;\n\t}\n\tudc_set_reg(dev, USIR0, USIR0_IR0);\n}\n\nstatic void handle_ep(struct pxa25x_ep *ep)\n{\n\tstruct pxa25x_request\t*req;\n\tint\t\t\tis_in = ep->bEndpointAddress & USB_DIR_IN;\n\tint\t\t\tcompleted;\n\tu32\t\t\tudccs, tmp;\n\n\tdo {\n\t\tcompleted = 0;\n\t\tif (likely (!list_empty(&ep->queue)))\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct pxa25x_request, queue);\n\t\telse\n\t\t\treq = NULL;\n\n\t\t \n\n\t\tudccs = udc_ep_get_UDCCS(ep);\n\t\tif (unlikely(is_in)) {\t \n\t\t\ttmp = UDCCS_BI_TUR;\n\t\t\tif (likely(ep->bmAttributes == USB_ENDPOINT_XFER_BULK))\n\t\t\t\ttmp |= UDCCS_BI_SST;\n\t\t\ttmp &= udccs;\n\t\t\tif (likely (tmp))\n\t\t\t\tudc_ep_set_UDCCS(ep, tmp);\n\t\t\tif (req && likely ((udccs & UDCCS_BI_TFS) != 0))\n\t\t\t\tcompleted = write_fifo(ep, req);\n\n\t\t} else {\t \n\t\t\tif (likely(ep->bmAttributes == USB_ENDPOINT_XFER_BULK))\n\t\t\t\ttmp = UDCCS_BO_SST | UDCCS_BO_DME;\n\t\t\telse\n\t\t\t\ttmp = UDCCS_IO_ROF | UDCCS_IO_DME;\n\t\t\ttmp &= udccs;\n\t\t\tif (likely(tmp))\n\t\t\t\tudc_ep_set_UDCCS(ep, tmp);\n\n\t\t\t \n\t\t\tif (likely(req)) {\n\t\t\t\tcompleted = read_fifo(ep, req);\n\t\t\t} else\n\t\t\t\tpio_irq_disable(ep);\n\t\t}\n\t\tep->pio_irqs++;\n\t} while (completed);\n}\n\n \nstatic irqreturn_t\npxa25x_udc_irq(int irq, void *_dev)\n{\n\tstruct pxa25x_udc\t*dev = _dev;\n\tint\t\t\thandled;\n\n\tdev->stats.irqs++;\n\tdo {\n\t\tu32\t\tudccr = udc_get_reg(dev, UDCCR);\n\n\t\thandled = 0;\n\n\t\t \n\t\tif (unlikely(udccr & UDCCR_SUSIR)) {\n\t\t\tudc_ack_int_UDCCR(dev, UDCCR_SUSIR);\n\t\t\thandled = 1;\n\t\t\tDBG(DBG_VERBOSE, \"USB suspend\\n\");\n\n\t\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t\t&& dev->driver\n\t\t\t\t\t&& dev->driver->suspend)\n\t\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\tep0_idle (dev);\n\t\t}\n\n\t\t \n\t\tif (unlikely(udccr & UDCCR_RESIR)) {\n\t\t\tudc_ack_int_UDCCR(dev, UDCCR_RESIR);\n\t\t\thandled = 1;\n\t\t\tDBG(DBG_VERBOSE, \"USB resume\\n\");\n\n\t\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t\t&& dev->driver\n\t\t\t\t\t&& dev->driver->resume)\n\t\t\t\tdev->driver->resume(&dev->gadget);\n\t\t}\n\n\t\t \n\t\tif (unlikely(udccr & UDCCR_RSTIR)) {\n\t\t\tudc_ack_int_UDCCR(dev, UDCCR_RSTIR);\n\t\t\thandled = 1;\n\n\t\t\tif ((udc_get_reg(dev, UDCCR) & UDCCR_UDA) == 0) {\n\t\t\t\tDBG(DBG_VERBOSE, \"USB reset start\\n\");\n\n\t\t\t\t \n\t\t\t\treset_gadget(dev, dev->driver);\n\n\t\t\t} else {\n\t\t\t\tDBG(DBG_VERBOSE, \"USB reset end\\n\");\n\t\t\t\tdev->gadget.speed = USB_SPEED_FULL;\n\t\t\t\tmemset(&dev->stats, 0, sizeof dev->stats);\n\t\t\t\t \n\t\t\t}\n\n\t\t} else {\n\t\t\tu32\tusir0 = udc_get_reg(dev, USIR0) &\n\t\t\t\t\t~udc_get_reg(dev, UICR0);\n\t\t\tu32\tusir1 = udc_get_reg(dev, USIR1) &\n\t\t\t\t\t~udc_get_reg(dev, UICR1);\n\t\t\tint\ti;\n\n\t\t\tif (unlikely (!usir0 && !usir1))\n\t\t\t\tcontinue;\n\n\t\t\tDBG(DBG_VERY_NOISY, \"irq %02x.%02x\\n\", usir1, usir0);\n\n\t\t\t \n\t\t\tif (usir0 & USIR0_IR0) {\n\t\t\t\tdev->ep[0].pio_irqs++;\n\t\t\t\thandle_ep0(dev);\n\t\t\t\thandled = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tfor (i = 0; i < 8; i++) {\n\t\t\t\tu32\ttmp = 1 << i;\n\n\t\t\t\tif (i && (usir0 & tmp)) {\n\t\t\t\t\thandle_ep(&dev->ep[i]);\n\t\t\t\t\tudc_set_reg(dev, USIR0,\n\t\t\t\t\t\tudc_get_reg(dev, USIR0) | tmp);\n\t\t\t\t\thandled = 1;\n\t\t\t\t}\n#ifndef\tCONFIG_USB_PXA25X_SMALL\n\t\t\t\tif (usir1 & tmp) {\n\t\t\t\t\thandle_ep(&dev->ep[i+8]);\n\t\t\t\t\tudc_set_reg(dev, USIR1,\n\t\t\t\t\t\tudc_get_reg(dev, USIR1) | tmp);\n\t\t\t\t\thandled = 1;\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t}\n\n\t\t \n\n\t} while (handled);\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void nop_release (struct device *dev)\n{\n\tDMSG(\"%s %s\\n\", __func__, dev_name(dev));\n}\n\n \nstatic struct pxa25x_udc memory = {\n\t.gadget = {\n\t\t.ops\t\t= &pxa25x_udc_ops,\n\t\t.ep0\t\t= &memory.ep[0].ep,\n\t\t.name\t\t= driver_name,\n\t\t.dev = {\n\t\t\t.init_name\t= \"gadget\",\n\t\t\t.release\t= nop_release,\n\t\t},\n\t},\n\n\t \n\t.ep[0] = {\n\t\t.ep = {\n\t\t\t.name\t\t= ep0name,\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= EP0_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_ALL),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.regoff_udccs\t= UDCCS0,\n\t\t.regoff_uddr\t= UDDR0,\n\t},\n\n\t \n\t.ep[1] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep1in-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 1,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS1,\n\t\t.regoff_uddr\t= UDDR1,\n\t},\n\t.ep[2] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep2out-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = 2,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS2,\n\t\t.regoff_ubcr\t= UBCR2,\n\t\t.regoff_uddr\t= UDDR2,\n\t},\n#ifndef CONFIG_USB_PXA25X_SMALL\n\t.ep[3] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep3in-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 3,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS3,\n\t\t.regoff_uddr\t= UDDR3,\n\t},\n\t.ep[4] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep4out-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = 4,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS4,\n\t\t.regoff_ubcr\t= UBCR4,\n\t\t.regoff_uddr\t= UDDR4,\n\t},\n\t.ep[5] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep5in-int\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= INT_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(0, 0),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= INT_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 5,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_INT,\n\t\t.regoff_udccs\t= UDCCS5,\n\t\t.regoff_uddr\t= UDDR5,\n\t},\n\n\t \n\t.ep[6] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep6in-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 6,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS6,\n\t\t.regoff_uddr\t= UDDR6,\n\t},\n\t.ep[7] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep7out-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = 7,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS7,\n\t\t.regoff_ubcr\t= UBCR7,\n\t\t.regoff_uddr\t= UDDR7,\n\t},\n\t.ep[8] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep8in-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 8,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS8,\n\t\t.regoff_uddr\t= UDDR8,\n\t},\n\t.ep[9] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep9out-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = 9,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS9,\n\t\t.regoff_ubcr\t= UBCR9,\n\t\t.regoff_uddr\t= UDDR9,\n\t},\n\t.ep[10] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep10in-int\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= INT_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(0, 0),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= INT_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 10,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_INT,\n\t\t.regoff_udccs\t= UDCCS10,\n\t\t.regoff_uddr\t= UDDR10,\n\t},\n\n\t \n\t.ep[11] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep11in-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 11,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS11,\n\t\t.regoff_uddr\t= UDDR11,\n\t},\n\t.ep[12] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep12out-bulk\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= BULK_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_BULK,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= BULK_FIFO_SIZE,\n\t\t.bEndpointAddress = 12,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_BULK,\n\t\t.regoff_udccs\t= UDCCS12,\n\t\t.regoff_ubcr\t= UBCR12,\n\t\t.regoff_uddr\t= UDDR12,\n\t},\n\t.ep[13] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep13in-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_IN),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 13,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS13,\n\t\t.regoff_uddr\t= UDDR13,\n\t},\n\t.ep[14] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep14out-iso\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= ISO_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(USB_EP_CAPS_TYPE_ISO,\n\t\t\t\t\t\tUSB_EP_CAPS_DIR_OUT),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= ISO_FIFO_SIZE,\n\t\t.bEndpointAddress = 14,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_ISOC,\n\t\t.regoff_udccs\t= UDCCS14,\n\t\t.regoff_ubcr\t= UBCR14,\n\t\t.regoff_uddr\t= UDDR14,\n\t},\n\t.ep[15] = {\n\t\t.ep = {\n\t\t\t.name\t\t= \"ep15in-int\",\n\t\t\t.ops\t\t= &pxa25x_ep_ops,\n\t\t\t.maxpacket\t= INT_FIFO_SIZE,\n\t\t\t.caps\t\t= USB_EP_CAPS(0, 0),\n\t\t},\n\t\t.dev\t\t= &memory,\n\t\t.fifo_size\t= INT_FIFO_SIZE,\n\t\t.bEndpointAddress = USB_DIR_IN | 15,\n\t\t.bmAttributes\t= USB_ENDPOINT_XFER_INT,\n\t\t.regoff_udccs\t= UDCCS15,\n\t\t.regoff_uddr\t= UDDR15,\n\t},\n#endif  \n};\n\n#define CP15R0_VENDOR_MASK\t0xffffe000\n\n#if\tdefined(CONFIG_ARCH_PXA)\n#define CP15R0_XSCALE_VALUE\t0x69052000\t \n\n#elif\tdefined(CONFIG_ARCH_IXP4XX)\n#define CP15R0_XSCALE_VALUE\t0x69054000\t \n\n#endif\n\n#define CP15R0_PROD_MASK\t0x000003f0\n#define PXA25x\t\t\t0x00000100\t \n#define PXA210\t\t\t0x00000120\n\n#define CP15R0_REV_MASK\t\t0x0000000f\n\n#define CP15R0_PRODREV_MASK\t(CP15R0_PROD_MASK | CP15R0_REV_MASK)\n\n#define PXA255_A0\t\t0x00000106\t \n#define PXA250_C0\t\t0x00000105\t \n#define PXA250_B2\t\t0x00000104\n#define PXA250_B1\t\t0x00000103\t \n#define PXA250_B0\t\t0x00000102\n#define PXA250_A1\t\t0x00000101\n#define PXA250_A0\t\t0x00000100\n\n#define PXA210_C0\t\t0x00000125\n#define PXA210_B2\t\t0x00000124\n#define PXA210_B1\t\t0x00000123\n#define PXA210_B0\t\t0x00000122\n#define IXP425_A0\t\t0x000001c1\n#define IXP425_B0\t\t0x000001f1\n#define IXP465_AD\t\t0x00000200\n\n \nstatic int pxa25x_udc_probe(struct platform_device *pdev)\n{\n\tstruct pxa25x_udc *dev = &memory;\n\tint retval, irq;\n\tu32 chiprev;\n\n\tpr_info(\"%s: version %s\\n\", driver_name, DRIVER_VERSION);\n\n\t \n\tasm(\"mrc p15, 0, %0, c0, c0\" : \"=r\" (chiprev));\n\tif ((chiprev & CP15R0_VENDOR_MASK) != CP15R0_XSCALE_VALUE) {\n\t\tpr_err(\"%s: not XScale!\\n\", driver_name);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tswitch (chiprev & CP15R0_PRODREV_MASK) {\n#if\tdefined(CONFIG_ARCH_PXA)\n\tcase PXA255_A0:\n\t\tdev->has_cfr = 1;\n\t\tbreak;\n\tcase PXA250_A0:\n\tcase PXA250_A1:\n\t\t \n\t\tfallthrough;\n\tcase PXA250_B2: case PXA210_B2:\n\tcase PXA250_B1: case PXA210_B1:\n\tcase PXA250_B0: case PXA210_B0:\n\t\t \n\t\tfallthrough;\n\tcase PXA250_C0: case PXA210_C0:\n\t\tbreak;\n#elif\tdefined(CONFIG_ARCH_IXP4XX)\n\tcase IXP425_A0:\n\tcase IXP425_B0:\n\tcase IXP465_AD:\n\t\tdev->has_cfr = 1;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tpr_err(\"%s: unrecognized processor: %08x\\n\",\n\t\t\tdriver_name, chiprev);\n\t\t \n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tdev->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(dev->regs))\n\t\treturn PTR_ERR(dev->regs);\n\n\tdev->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(dev->clk))\n\t\treturn PTR_ERR(dev->clk);\n\n\tpr_debug(\"%s: IRQ %d%s%s\\n\", driver_name, irq,\n\t\tdev->has_cfr ? \"\" : \" (!cfr)\",\n\t\tSIZE_STR \"(pio)\"\n\t\t);\n\n\t \n\tdev->dev = &pdev->dev;\n\tdev->mach = dev_get_platdata(&pdev->dev);\n\n\tdev->transceiver = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\n\n\tif (gpio_is_valid(dev->mach->gpio_pullup)) {\n\t\tretval = devm_gpio_request(&pdev->dev, dev->mach->gpio_pullup,\n\t\t\t\t\t   \"pca25x_udc GPIO PULLUP\");\n\t\tif (retval) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"can't get pullup gpio %d, err: %d\\n\",\n\t\t\t\tdev->mach->gpio_pullup, retval);\n\t\t\tgoto err;\n\t\t}\n\t\tgpio_direction_output(dev->mach->gpio_pullup, 0);\n\t}\n\n\ttimer_setup(&dev->timer, udc_watchdog, 0);\n\n\tthe_controller = dev;\n\tplatform_set_drvdata(pdev, dev);\n\n\tudc_disable(dev);\n\tudc_reinit(dev);\n\n\tdev->vbus = 0;\n\n\t \n\tretval = devm_request_irq(&pdev->dev, irq, pxa25x_udc_irq, 0,\n\t\t\t\t  driver_name, dev);\n\tif (retval != 0) {\n\t\tpr_err(\"%s: can't get irq %d, err %d\\n\",\n\t\t\tdriver_name, irq, retval);\n\t\tgoto err;\n\t}\n\tdev->got_irq = 1;\n\n\tcreate_debug_files(dev);\n\n\tretval = usb_add_gadget_udc(&pdev->dev, &dev->gadget);\n\tif (!retval)\n\t\treturn retval;\n\n\tremove_debug_files(dev);\n err:\n\tif (!IS_ERR_OR_NULL(dev->transceiver))\n\t\tdev->transceiver = NULL;\n\treturn retval;\n}\n\nstatic void pxa25x_udc_shutdown(struct platform_device *_dev)\n{\n\tpullup_off();\n}\n\nstatic int pxa25x_udc_remove(struct platform_device *pdev)\n{\n\tstruct pxa25x_udc *dev = platform_get_drvdata(pdev);\n\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\tusb_del_gadget_udc(&dev->gadget);\n\tdev->pullup = 0;\n\tpullup(dev);\n\n\tremove_debug_files(dev);\n\n\tif (!IS_ERR_OR_NULL(dev->transceiver))\n\t\tdev->transceiver = NULL;\n\n\tthe_controller = NULL;\n\treturn 0;\n}\n\n \n\n#ifdef\tCONFIG_PM\n\n \nstatic int pxa25x_udc_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct pxa25x_udc\t*udc = platform_get_drvdata(dev);\n\tunsigned long flags;\n\n\tif (!gpio_is_valid(udc->mach->gpio_pullup) && !udc->mach->udc_command)\n\t\tWARNING(\"USB host won't detect disconnect!\\n\");\n\tudc->suspended = 1;\n\n\tlocal_irq_save(flags);\n\tpullup(udc);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\nstatic int pxa25x_udc_resume(struct platform_device *dev)\n{\n\tstruct pxa25x_udc\t*udc = platform_get_drvdata(dev);\n\tunsigned long flags;\n\n\tudc->suspended = 0;\n\tlocal_irq_save(flags);\n\tpullup(udc);\n\tlocal_irq_restore(flags);\n\n\treturn 0;\n}\n\n#else\n#define\tpxa25x_udc_suspend\tNULL\n#define\tpxa25x_udc_resume\tNULL\n#endif\n\n \n\nstatic struct platform_driver udc_driver = {\n\t.shutdown\t= pxa25x_udc_shutdown,\n\t.probe\t\t= pxa25x_udc_probe,\n\t.remove\t\t= pxa25x_udc_remove,\n\t.suspend\t= pxa25x_udc_suspend,\n\t.resume\t\t= pxa25x_udc_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa25x-udc\",\n\t},\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Frank Becker, Robert Schwebel, David Brownell\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa25x-udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}