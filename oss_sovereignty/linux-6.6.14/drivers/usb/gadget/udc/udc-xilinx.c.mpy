{
  "module_name": "udc-xilinx.c",
  "hash_id": "0e88533937e4863891ffca13fcf78ab13f643c646c7fe7e32cc9958e982caa66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/udc-xilinx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n \n#define XUSB_EP0_CONFIG_OFFSET\t\t0x0000   \n#define XUSB_SETUP_PKT_ADDR_OFFSET\t0x0080   \n#define XUSB_ADDRESS_OFFSET\t\t0x0100   \n#define XUSB_CONTROL_OFFSET\t\t0x0104   \n#define XUSB_STATUS_OFFSET\t\t0x0108   \n#define XUSB_FRAMENUM_OFFSET\t\t0x010C\t \n#define XUSB_IER_OFFSET\t\t\t0x0110\t \n#define XUSB_BUFFREADY_OFFSET\t\t0x0114\t \n#define XUSB_TESTMODE_OFFSET\t\t0x0118\t \n#define XUSB_DMA_RESET_OFFSET\t\t0x0200   \n#define XUSB_DMA_CONTROL_OFFSET\t\t0x0204\t \n#define XUSB_DMA_DSAR_ADDR_OFFSET\t0x0208\t \n#define XUSB_DMA_DDAR_ADDR_OFFSET\t0x020C\t \n#define XUSB_DMA_LENGTH_OFFSET\t\t0x0210\t \n#define XUSB_DMA_STATUS_OFFSET\t\t0x0214\t \n\n \n#define XUSB_EP_CFGSTATUS_OFFSET\t0x00\t \n#define XUSB_EP_BUF0COUNT_OFFSET\t0x08\t \n#define XUSB_EP_BUF1COUNT_OFFSET\t0x0C\t \n\n#define XUSB_CONTROL_USB_READY_MASK\t0x80000000  \n#define XUSB_CONTROL_USB_RMTWAKE_MASK\t0x40000000  \n\n \n#define XUSB_STATUS_GLOBAL_INTR_MASK\t0x80000000  \n#define XUSB_STATUS_DMADONE_MASK\t0x04000000  \n#define XUSB_STATUS_DMAERR_MASK\t\t0x02000000  \n#define XUSB_STATUS_DMABUSY_MASK\t0x80000000  \n#define XUSB_STATUS_RESUME_MASK\t\t0x01000000  \n#define XUSB_STATUS_RESET_MASK\t\t0x00800000  \n#define XUSB_STATUS_SUSPEND_MASK\t0x00400000  \n#define XUSB_STATUS_DISCONNECT_MASK\t0x00200000  \n#define XUSB_STATUS_FIFO_BUFF_RDY_MASK\t0x00100000  \n#define XUSB_STATUS_FIFO_BUFF_FREE_MASK\t0x00080000  \n#define XUSB_STATUS_SETUP_PACKET_MASK\t0x00040000  \n#define XUSB_STATUS_EP1_BUFF2_COMP_MASK\t0x00000200  \n#define XUSB_STATUS_EP1_BUFF1_COMP_MASK\t0x00000002  \n#define XUSB_STATUS_EP0_BUFF2_COMP_MASK\t0x00000100  \n#define XUSB_STATUS_EP0_BUFF1_COMP_MASK\t0x00000001  \n#define XUSB_STATUS_HIGH_SPEED_MASK\t0x00010000  \n \n#define XUSB_STATUS_INTR_EVENT_MASK\t0x01E00000\n \n#define XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK\t0x0000FEFF\n \n#define XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK\t0x00000101\n#define XUSB_STATUS_EP_BUFF2_SHIFT\t8\t    \n\n \n#define XUSB_EP_CFG_VALID_MASK\t\t0x80000000  \n#define XUSB_EP_CFG_STALL_MASK\t\t0x40000000  \n#define XUSB_EP_CFG_DATA_TOGGLE_MASK\t0x08000000  \n\n \n#define XUSB_MAX_ENDPOINTS\t\t8\t \n#define XUSB_EP_NUMBER_ZERO\t\t0\t \n \n#define XUSB_DMA_READ_FROM_DPRAM\t0x80000000\n#define XUSB_DMA_DMASR_BUSY\t\t0x80000000  \n#define XUSB_DMA_DMASR_ERROR\t\t0x40000000  \n \n#define XUSB_DMA_BRR_CTRL\t\t0x40000000  \n \n#define SETUP_PHASE\t\t\t0x0000\t \n#define DATA_PHASE\t\t\t0x0001   \n#define STATUS_PHASE\t\t\t0x0002   \n\n#define EP0_MAX_PACKET\t\t64  \n#define STATUSBUFF_SIZE\t\t2   \n#define EPNAME_SIZE\t\t4   \n\n \n#define to_udc(g)\t container_of((g), struct xusb_udc, gadget)\n#define to_xusb_ep(ep)\t container_of((ep), struct xusb_ep, ep_usb)\n#define to_xusb_req(req) container_of((req), struct xusb_req, usb_req)\n\n \nstruct xusb_req {\n\tstruct usb_request usb_req;\n\tstruct list_head queue;\n\tstruct xusb_ep *ep;\n};\n\n \nstruct xusb_ep {\n\tstruct usb_ep ep_usb;\n\tstruct list_head queue;\n\tstruct xusb_udc *udc;\n\tconst struct usb_endpoint_descriptor *desc;\n\tu32  rambase;\n\tu32  offset;\n\tchar name[4];\n\tu16  epnumber;\n\tu16  maxpacket;\n\tu16  buffer0count;\n\tu16  buffer1count;\n\tu8   curbufnum;\n\tbool buffer0ready;\n\tbool buffer1ready;\n\tbool is_in;\n\tbool is_iso;\n};\n\n \nstruct xusb_udc {\n\tstruct usb_gadget gadget;\n\tstruct xusb_ep ep[8];\n\tstruct usb_gadget_driver *driver;\n\tstruct usb_ctrlrequest setup;\n\tstruct xusb_req *req;\n\tstruct device *dev;\n\tu32 usb_state;\n\tu32 remote_wkp;\n\tu32 setupseqtx;\n\tu32 setupseqrx;\n\tvoid __iomem *addr;\n\tspinlock_t lock;\n\tbool dma_enabled;\n\tstruct clk *clk;\n\n\tunsigned int (*read_fn)(void __iomem *reg);\n\tvoid (*write_fn)(void __iomem *, u32, u32);\n};\n\n \nstatic u32 rambase[8] = { 0x22, 0x1000, 0x1100, 0x1200, 0x1300, 0x1400, 0x1500,\n\t\t\t  0x1600 };\n\nstatic const char driver_name[] = \"xilinx-udc\";\nstatic const char ep0name[] = \"ep0\";\n\n \nstatic const struct usb_endpoint_descriptor config_bulk_out_desc = {\n\t.bLength\t\t= USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType\t= USB_DT_ENDPOINT,\n\t.bEndpointAddress\t= USB_DIR_OUT,\n\t.bmAttributes\t\t= USB_ENDPOINT_XFER_BULK,\n\t.wMaxPacketSize\t\t= cpu_to_le16(EP0_MAX_PACKET),\n};\n\n \nstatic void xudc_write32(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32(val, addr + offset);\n}\n\n \nstatic unsigned int xudc_read32(void __iomem *addr)\n{\n\treturn ioread32(addr);\n}\n\n \nstatic void xudc_write32_be(void __iomem *addr, u32 offset, u32 val)\n{\n\tiowrite32be(val, addr + offset);\n}\n\n \nstatic unsigned int xudc_read32_be(void __iomem *addr)\n{\n\treturn ioread32be(addr);\n}\n\n \nstatic void xudc_wrstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tu32 epcfgreg;\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset)|\n\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\tudc->write_fn(udc->addr, ep0->offset + XUSB_EP_BUF0COUNT_OFFSET, 0);\n\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n}\n\n \nstatic void xudc_epconfig(struct xusb_ep *ep, struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\n\t \n\tepcfgreg = ((ep->is_in << 29) | (ep->is_iso << 28) |\n\t\t   (ep->ep_usb.maxpacket << 15) | (ep->rambase));\n\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\n\t \n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF0COUNT_OFFSET,\n\t\t      ep->buffer0count);\n\tudc->write_fn(udc->addr, ep->offset + XUSB_EP_BUF1COUNT_OFFSET,\n\t\t      ep->buffer1count);\n\tif (ep->buffer0ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\tif (ep->buffer1ready)\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n}\n\n \nstatic int xudc_start_dma(struct xusb_ep *ep, dma_addr_t src,\n\t\t\t  dma_addr_t dst, u32 length)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tint rc = 0;\n\tu32 timeout = 500;\n\tu32 reg;\n\n\t \n\tudc->write_fn(udc->addr, XUSB_DMA_DSAR_ADDR_OFFSET, src);\n\tudc->write_fn(udc->addr, XUSB_DMA_DDAR_ADDR_OFFSET, dst);\n\tudc->write_fn(udc->addr, XUSB_DMA_LENGTH_OFFSET, length);\n\n\t \n\tdo {\n\t\treg = udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET);\n\t\tif (!(reg &  XUSB_DMA_DMASR_BUSY))\n\t\t\tbreak;\n\n\t\t \n\t\ttimeout--;\n\t\tif (!timeout) {\n\t\t\tdev_err(udc->dev, \"DMA timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t} while (1);\n\n\tif ((udc->read_fn(udc->addr + XUSB_DMA_STATUS_OFFSET) &\n\t\t\t  XUSB_DMA_DMASR_ERROR) == XUSB_DMA_DMASR_ERROR){\n\t\tdev_err(udc->dev, \"DMA Error\\n\");\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n \nstatic int xudc_dma_send(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tsrc = req->usb_req.dma + req->usb_req.actual;\n\tif (req->usb_req.length)\n\t\tdma_sync_single_for_device(udc->dev, src,\n\t\t\t\t\t   length, DMA_TO_DEVICE);\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tdst = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n \nstatic int xudc_dma_receive(struct xusb_ep *ep, struct xusb_req *req,\n\t\t\t    u8 *buffer, u32 length)\n{\n\tu32 *eprambase;\n\tdma_addr_t src;\n\tdma_addr_t dst;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tdst = req->usb_req.dma + req->usb_req.actual;\n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << ep->epnumber));\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr +\n\t\t\t     ep->rambase + ep->ep_usb.maxpacket);\n\t\tsrc = virt_to_phys(eprambase);\n\t\tudc->write_fn(udc->addr, XUSB_DMA_CONTROL_OFFSET,\n\t\t\t      XUSB_DMA_BRR_CTRL | XUSB_DMA_READ_FROM_DPRAM |\n\t\t\t      (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\n\treturn xudc_start_dma(ep, src, dst, length);\n}\n\n \nstatic int xudc_eptxrx(struct xusb_ep *ep, struct xusb_req *req,\n\t\t       u8 *bufferptr, u32 bufferlen)\n{\n\tu32 *eprambase;\n\tu32 bytestosend;\n\tint rc = 0;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tbytestosend = bufferlen;\n\tif (udc->dma_enabled) {\n\t\tif (ep->is_in)\n\t\t\trc = xudc_dma_send(ep, req, bufferptr, bufferlen);\n\t\telse\n\t\t\trc = xudc_dma_receive(ep, req, bufferptr, bufferlen);\n\t\treturn rc;\n\t}\n\t \n\tif (!ep->curbufnum && !ep->buffer0ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy_toio((void __iomem *)eprambase, bufferptr,\n\t\t\t\t    bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF0COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy_toio((void __iomem *)bufferptr, eprambase,\n\t\t\t\t    bytestosend);\n\t\t}\n\t\t \n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = 1;\n\t\tep->curbufnum = 1;\n\t} else if (ep->curbufnum && !ep->buffer1ready) {\n\t\t \n\t\teprambase = (u32 __force *)(udc->addr + ep->rambase +\n\t\t\t     ep->ep_usb.maxpacket);\n\t\tif (ep->is_in) {\n\t\t\tmemcpy_toio((void __iomem *)eprambase, bufferptr,\n\t\t\t\t    bytestosend);\n\t\t\tudc->write_fn(udc->addr, ep->offset +\n\t\t\t\t      XUSB_EP_BUF1COUNT_OFFSET, bufferlen);\n\t\t} else {\n\t\t\tmemcpy_toio((void __iomem *)bufferptr, eprambase,\n\t\t\t\t    bytestosend);\n\t\t}\n\t\t \n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << (ep->epnumber + XUSB_STATUS_EP_BUFF2_SHIFT));\n\t\tep->buffer1ready = 1;\n\t\tep->curbufnum = 0;\n\t} else {\n\t\t \n\t\treturn -EAGAIN;\n\t}\n\treturn rc;\n}\n\n \nstatic void xudc_done(struct xusb_ep *ep, struct xusb_req *req, int status)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\n\tif (req->usb_req.status == -EINPROGRESS)\n\t\treq->usb_req.status = status;\n\telse\n\t\tstatus = req->usb_req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tdev_dbg(udc->dev, \"%s done %p, status %d\\n\",\n\t\t\tep->ep_usb.name, req, status);\n\t \n\tif (udc->dma_enabled && ep->epnumber && req->usb_req.length)\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t ep->is_in);\n\n\tif (req->usb_req.complete) {\n\t\tspin_unlock(&udc->lock);\n\t\treq->usb_req.complete(&ep->ep_usb, &req->usb_req);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\n \nstatic int xudc_read_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu8 *buf;\n\tu32 is_short, count, bufferspace;\n\tu8 bufoffset;\n\tu8 two_pkts = 0;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\n\tif (ep->buffer0ready && ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"Packet NOT ready!\\n\");\n\t\treturn retval;\n\t}\ntop:\n\tif (ep->curbufnum)\n\t\tbufoffset = XUSB_EP_BUF1COUNT_OFFSET;\n\telse\n\t\tbufoffset = XUSB_EP_BUF0COUNT_OFFSET;\n\n\tcount = udc->read_fn(udc->addr + ep->offset + bufoffset);\n\n\tif (!ep->buffer0ready && !ep->buffer1ready)\n\t\ttwo_pkts = 1;\n\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetchw(buf);\n\tbufferspace = req->usb_req.length - req->usb_req.actual;\n\tis_short = count < ep->ep_usb.maxpacket;\n\n\tif (unlikely(!bufferspace)) {\n\t\t \n\t\tif (req->usb_req.status != -EOVERFLOW)\n\t\t\tdev_dbg(udc->dev, \"%s overflow %d\\n\",\n\t\t\t\tep->ep_usb.name, count);\n\t\treq->usb_req.status = -EOVERFLOW;\n\t\txudc_done(ep, req, -EOVERFLOW);\n\t\treturn 0;\n\t}\n\n\tret = xudc_eptxrx(ep, req, buf, count);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += min(count, bufferspace);\n\t\tdev_dbg(udc->dev, \"read %s, %d bytes%s req %p %d/%d\\n\",\n\t\t\tep->ep_usb.name, count, is_short ? \"/S\" : \"\", req,\n\t\t\treq->usb_req.actual, req->usb_req.length);\n\n\t\t \n\t\tif ((req->usb_req.actual == req->usb_req.length) || is_short) {\n\t\t\tif (udc->dma_enabled && req->usb_req.length)\n\t\t\t\tdma_sync_single_for_cpu(udc->dev,\n\t\t\t\t\t\t\treq->usb_req.dma,\n\t\t\t\t\t\t\treq->usb_req.actual,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\txudc_done(ep, req, 0);\n\t\t\treturn 0;\n\t\t}\n\t\tif (two_pkts) {\n\t\t\ttwo_pkts = 0;\n\t\t\tgoto top;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"receive busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t \n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic int xudc_write_fifo(struct xusb_ep *ep, struct xusb_req *req)\n{\n\tu32 max;\n\tu32 length;\n\tint ret;\n\tint retval = -EAGAIN;\n\tstruct xusb_udc *udc = ep->udc;\n\tint is_last, is_short = 0;\n\tu8 *buf;\n\n\tmax = le16_to_cpu(ep->desc->wMaxPacketSize);\n\tbuf = req->usb_req.buf + req->usb_req.actual;\n\tprefetch(buf);\n\tlength = req->usb_req.length - req->usb_req.actual;\n\tlength = min(length, max);\n\n\tret = xudc_eptxrx(ep, req, buf, length);\n\tswitch (ret) {\n\tcase 0:\n\t\treq->usb_req.actual += length;\n\t\tif (unlikely(length != max)) {\n\t\t\tis_last = is_short = 1;\n\t\t} else {\n\t\t\tif (likely(req->usb_req.length !=\n\t\t\t\t   req->usb_req.actual) || req->usb_req.zero)\n\t\t\t\tis_last = 0;\n\t\t\telse\n\t\t\t\tis_last = 1;\n\t\t}\n\t\tdev_dbg(udc->dev, \"%s: wrote %s %d bytes%s%s %d left %p\\n\",\n\t\t\t__func__, ep->ep_usb.name, length, is_last ? \"/L\" : \"\",\n\t\t\tis_short ? \"/S\" : \"\",\n\t\t\treq->usb_req.length - req->usb_req.actual, req);\n\t\t \n\t\tif (is_last) {\n\t\t\txudc_done(ep, req, 0);\n\t\t\tretval = 0;\n\t\t}\n\t\tbreak;\n\tcase -EAGAIN:\n\t\tdev_dbg(udc->dev, \"Send busy\\n\");\n\t\tbreak;\n\tcase -EINVAL:\n\tcase -ETIMEDOUT:\n\t\t \n\t\txudc_done(ep, req, -ECONNRESET);\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n \nstatic void xudc_nuke(struct xusb_ep *ep, int status)\n{\n\tstruct xusb_req *req;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\t\txudc_done(ep, req, status);\n\t}\n}\n\n \nstatic int xudc_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tu32 epcfgreg;\n\n\tif (!_ep || (!ep->desc && ep->epnumber)) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tudc = ep->udc;\n\n\tif (ep->is_in && (!list_empty(&ep->queue)) && value) {\n\t\tdev_dbg(udc->dev, \"requests pending can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (ep->buffer0ready || ep->buffer1ready) {\n\t\tdev_dbg(udc->dev, \"HW buffers busy can't halt\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (value) {\n\t\t \n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t} else {\n\t\t \n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t \n\t\t\tepcfgreg = udc->read_fn(ep->udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic int __xudc_ep_enable(struct xusb_ep *ep,\n\t\t\t    const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_udc *udc = ep->udc;\n\tu32 tmp;\n\tu32 epcfg;\n\tu32 ier;\n\tu16 maxpacket;\n\n\tep->is_in = ((desc->bEndpointAddress & USB_DIR_IN) != 0);\n\t \n\tep->epnumber = (desc->bEndpointAddress & 0x0f);\n\tep->desc = desc;\n\tep->ep_usb.desc = desc;\n\ttmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tep->ep_usb.maxpacket = maxpacket = le16_to_cpu(desc->wMaxPacketSize);\n\n\tswitch (tmp) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tdev_dbg(udc->dev, \"only one control endpoint\\n\");\n\t\t \n\t\tep->is_iso = 0;\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tep->is_iso = 0;\n\t\tif (maxpacket > 64) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\t \n\t\tep->is_iso = 0;\n\t\tif (!(is_power_of_2(maxpacket) && maxpacket >= 8 &&\n\t\t\t\tmaxpacket <= 512)) {\n\t\t\tdev_dbg(udc->dev, \"bogus maxpacket %d\\n\", maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tep->is_iso = 1;\n\t\tbreak;\n\t}\n\n\tep->buffer0ready = false;\n\tep->buffer1ready = false;\n\tep->curbufnum = 0;\n\tep->rambase = rambase[ep->epnumber];\n\txudc_epconfig(ep, udc);\n\n\tdev_dbg(udc->dev, \"Enable Endpoint %d max pkt is %d\\n\",\n\t\tep->epnumber, maxpacket);\n\n\t \n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg |= XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\tif (ep->epnumber)\n\t\tep->rambase <<= 2;\n\n\t \n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier |= (XUSB_STATUS_INTR_BUFF_COMP_SHIFT_MASK << ep->epnumber);\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t \n\tif (ep->epnumber && !ep->is_in) {\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t      1 << ep->epnumber);\n\t\tep->buffer0ready = true;\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET,\n\t\t\t     (1 << (ep->epnumber +\n\t\t\t      XUSB_STATUS_EP_BUFF2_SHIFT)));\n\t\tep->buffer1ready = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xudc_ep_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct xusb_ep *ep;\n\tstruct xusb_udc *udc;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"%s: bad ep or descriptor\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep_enable(ep, desc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int xudc_ep_disable(struct usb_ep *_ep)\n{\n\tstruct xusb_ep *ep;\n\tunsigned long flags;\n\tu32 epcfg;\n\tstruct xusb_udc *udc;\n\n\tif (!_ep) {\n\t\tpr_debug(\"%s: invalid ep\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_xusb_ep(_ep);\n\tudc = ep->udc;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\txudc_nuke(ep, -ESHUTDOWN);\n\n\t \n\tep->desc = NULL;\n\tep->ep_usb.desc = NULL;\n\n\tdev_dbg(udc->dev, \"USB Ep %d disable\\n \", ep->epnumber);\n\t \n\tepcfg = udc->read_fn(udc->addr + ep->offset);\n\tepcfg &= ~XUSB_EP_CFG_VALID_MASK;\n\tudc->write_fn(udc->addr, ep->offset, epcfg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic struct usb_request *xudc_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_ep *ep = to_xusb_ep(_ep);\n\tstruct xusb_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->ep = ep;\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->usb_req;\n}\n\n \nstatic void xudc_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\n\tkfree(req);\n}\n\n \nstatic int __xudc_ep0_queue(struct xusb_ep *ep0, struct xusb_req *req)\n{\n\tstruct xusb_udc *udc = ep0->udc;\n\tu32 length;\n\tu8 *corebuf;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (!list_empty(&ep0->queue)) {\n\t\tdev_dbg(udc->dev, \"%s:ep0 busy\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\treq->usb_req.status = -EINPROGRESS;\n\treq->usb_req.actual = 0;\n\n\tlist_add_tail(&req->queue, &ep0->queue);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\tprefetch(req->usb_req.buf);\n\t\tlength = req->usb_req.length;\n\t\tcorebuf = (void __force *) ((ep0->rambase << 2) +\n\t\t\t   udc->addr);\n\t\tlength = req->usb_req.actual = min_t(u32, length,\n\t\t\t\t\t\t     EP0_MAX_PACKET);\n\t\tmemcpy_toio((void __iomem *)corebuf, req->usb_req.buf, length);\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, length);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t} else {\n\t\tif (udc->setup.wLength) {\n\t\t\t \n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t} else {\n\t\t\txudc_wrstatus(udc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int xudc_ep0_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct xusb_req *req\t= to_xusb_req(_req);\n\tstruct xusb_ep\t*ep0\t= to_xusb_ep(_ep);\n\tstruct xusb_udc *udc\t= ep0->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __xudc_ep0_queue(ep0, req);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int xudc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct xusb_req *req = to_xusb_req(_req);\n\tstruct xusb_ep\t*ep  = to_xusb_ep(_ep);\n\tstruct xusb_udc *udc = ep->udc;\n\tint  ret;\n\tunsigned long flags;\n\n\tif (!ep->desc) {\n\t\tdev_dbg(udc->dev, \"%s: queuing request to disabled %s\\n\",\n\t\t\t__func__, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tdev_dbg(udc->dev, \"%s, bogus device state\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tif (udc->dma_enabled) {\n\t\tret = usb_gadget_map_request(&udc->gadget, &req->usb_req,\n\t\t\t\t\t     ep->is_in);\n\t\tif (ret) {\n\t\t\tdev_dbg(udc->dev, \"gadget_map failed ep%d\\n\",\n\t\t\t\tep->epnumber);\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tif (list_empty(&ep->queue)) {\n\t\tif (ep->is_in) {\n\t\t\tdev_dbg(udc->dev, \"xudc_write_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_write_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t} else {\n\t\t\tdev_dbg(udc->dev, \"xudc_read_fifo from ep_queue\\n\");\n\t\t\tif (!xudc_read_fifo(ep, req))\n\t\t\t\treq = NULL;\n\t\t}\n\t}\n\n\tif (req != NULL)\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic int xudc_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct xusb_ep *ep\t= to_xusb_ep(_ep);\n\tstruct xusb_req *req\t= NULL;\n\tstruct xusb_req *iter;\n\tstruct xusb_udc *udc\t= ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->usb_req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\txudc_done(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int xudc_ep0_enable(struct usb_ep *ep,\n\t\t\t   const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int xudc_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\nstatic const struct usb_ep_ops xusb_ep0_ops = {\n\t.enable\t\t= xudc_ep0_enable,\n\t.disable\t= xudc_ep0_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep0_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\nstatic const struct usb_ep_ops xusb_ep_ops = {\n\t.enable\t\t= xudc_ep_enable,\n\t.disable\t= xudc_ep_disable,\n\t.alloc_request\t= xudc_ep_alloc_request,\n\t.free_request\t= xudc_free_request,\n\t.queue\t\t= xudc_ep_queue,\n\t.dequeue\t= xudc_ep_dequeue,\n\t.set_halt\t= xudc_ep_set_halt,\n};\n\n \nstatic int xudc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc;\n\tint frame;\n\n\tif (!gadget)\n\t\treturn -ENODEV;\n\n\tudc = to_udc(gadget);\n\tframe = udc->read_fn(udc->addr + XUSB_FRAMENUM_OFFSET);\n\treturn frame;\n}\n\n \nstatic int xudc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tu32 crtlreg;\n\tint status = -EINVAL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (!udc->remote_wkp)\n\t\tgoto done;\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_RMTWAKE_MASK;\n\t \n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\t \n\tmdelay(2);\n\n\tcrtlreg &= ~XUSB_CONTROL_USB_RMTWAKE_MASK;\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\tstatus = 0;\ndone:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\n \nstatic int xudc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\tu32 crtlreg;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tif (is_on)\n\t\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\telse\n\t\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void xudc_eps_init(struct xusb_udc *udc)\n{\n\tu32 ep_number;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tfor (ep_number = 0; ep_number < XUSB_MAX_ENDPOINTS; ep_number++) {\n\t\tstruct xusb_ep *ep = &udc->ep[ep_number];\n\n\t\tif (ep_number) {\n\t\t\tlist_add_tail(&ep->ep_usb.ep_list,\n\t\t\t\t      &udc->gadget.ep_list);\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb,\n\t\t\t\t\t\t  (unsigned short) ~0);\n\t\t\tsnprintf(ep->name, EPNAME_SIZE, \"ep%d\", ep_number);\n\t\t\tep->ep_usb.name = ep->name;\n\t\t\tep->ep_usb.ops = &xusb_ep_ops;\n\n\t\t\tep->ep_usb.caps.type_iso = true;\n\t\t\tep->ep_usb.caps.type_bulk = true;\n\t\t\tep->ep_usb.caps.type_int = true;\n\t\t} else {\n\t\t\tep->ep_usb.name = ep0name;\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep_usb, EP0_MAX_PACKET);\n\t\t\tep->ep_usb.ops = &xusb_ep0_ops;\n\n\t\t\tep->ep_usb.caps.type_control = true;\n\t\t}\n\n\t\tep->ep_usb.caps.dir_in = true;\n\t\tep->ep_usb.caps.dir_out = true;\n\n\t\tep->udc = udc;\n\t\tep->epnumber = ep_number;\n\t\tep->desc = NULL;\n\t\t \n\t\tep->offset = XUSB_EP0_CONFIG_OFFSET + (ep_number * 0x10);\n\t\tep->is_in = 0;\n\t\tep->is_iso = 0;\n\t\tep->maxpacket = 0;\n\t\txudc_epconfig(ep, udc);\n\n\t\t \n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n}\n\n \nstatic void xudc_stop_activity(struct xusb_udc *udc)\n{\n\tint i;\n\tstruct xusb_ep *ep;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\txudc_nuke(ep, -ESHUTDOWN);\n\t}\n}\n\n \nstatic int xudc_start(struct usb_gadget *gadget,\n\t\t      struct usb_gadget_driver *driver)\n{\n\tstruct xusb_udc *udc\t= to_udc(gadget);\n\tstruct xusb_ep *ep0\t= &udc->ep[XUSB_EP_NUMBER_ZERO];\n\tconst struct usb_endpoint_descriptor *desc = &config_bulk_out_desc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (udc->driver) {\n\t\tdev_err(udc->dev, \"%s is already bound to %s\\n\",\n\t\t\tudc->gadget.name, udc->driver->driver.name);\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\tudc->driver = driver;\n\tudc->gadget.speed = driver->max_speed;\n\n\t \n\tret = __xudc_ep_enable(ep0, desc);\n\n\t \n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\nerr:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\n \nstatic int xudc_stop(struct usb_gadget *gadget)\n{\n\tstruct xusb_udc *udc = to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->driver = NULL;\n\n\t \n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\tudc->remote_wkp = 0;\n\n\txudc_stop_activity(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops xusb_udc_ops = {\n\t.get_frame\t= xudc_get_frame,\n\t.wakeup\t\t= xudc_wakeup,\n\t.pullup\t\t= xudc_pullup,\n\t.udc_start\t= xudc_start,\n\t.udc_stop\t= xudc_stop,\n};\n\n \nstatic void xudc_clear_stall_all_ep(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep;\n\tu32 epcfgreg;\n\tint i;\n\n\tfor (i = 0; i < XUSB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\tif (ep->epnumber) {\n\t\t\t \n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep->offset);\n\t\t\tepcfgreg &= ~XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep->offset, epcfgreg);\n\t\t}\n\t}\n}\n\n \nstatic void xudc_startup_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\tu32 intrreg;\n\n\tif (intrstatus & XUSB_STATUS_RESET_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Reset\\n\");\n\n\t\tif (intrstatus & XUSB_STATUS_HIGH_SPEED_MASK)\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\n\t\txudc_stop_activity(udc);\n\t\txudc_clear_stall_all_ep(udc);\n\t\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\t\t \n\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\t\tudc->remote_wkp = 0;\n\n\t\t \n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_SUSPEND_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\t}\n\tif (intrstatus & XUSB_STATUS_SUSPEND_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Suspend\\n\");\n\n\t\t \n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\t\tif (udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_RESUME_MASK) {\n\t\tbool condition = (udc->usb_state != USB_STATE_SUSPENDED);\n\n\t\tdev_WARN_ONCE(udc->dev, condition,\n\t\t\t\t\"Resume IRQ while not suspended\\n\");\n\n\t\tdev_dbg(udc->dev, \"Resume\\n\");\n\n\t\t \n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_SUSPEND_MASK |\n\t\t\t   XUSB_STATUS_DISCONNECT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tudc->usb_state = 0;\n\n\t\tif (udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\tif (intrstatus & XUSB_STATUS_DISCONNECT_MASK) {\n\n\t\tdev_dbg(udc->dev, \"Disconnect\\n\");\n\n\t\t \n\t\tintrreg = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tintrreg |= XUSB_STATUS_RESET_MASK | XUSB_STATUS_RESUME_MASK |\n\t\t\t   XUSB_STATUS_SUSPEND_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, intrreg);\n\n\t\tif (udc->driver && udc->driver->disconnect) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->disconnect(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n}\n\n \nstatic void xudc_ep0_stall(struct xusb_udc *udc)\n{\n\tu32 epcfgreg;\n\tstruct xusb_ep *ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO];\n\n\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n}\n\n \nstatic void xudc_setaddress(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tint ret;\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET ADDRESS request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n \nstatic void xudc_getstatus(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu16 status = 0;\n\tu32 epcfgreg;\n\tint epnum;\n\tu32 halt;\n\tint ret;\n\n\tswitch (udc->setup.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t \n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tif (udc->remote_wkp)\n\t\t\tstatus |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = le16_to_cpu(udc->setup.wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum >= XUSB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\ttarget_ep = &udc->ep[epnum];\n\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\thalt = epcfgreg & XUSB_EP_CFG_STALL_MASK;\n\t\tif (le16_to_cpu(udc->setup.wIndex) & USB_DIR_IN) {\n\t\t\tif (!target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else {\n\t\t\tif (target_ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tif (halt)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\treq->usb_req.length = 2;\n\t*(__le16 *)req->usb_req.buf = cpu_to_le16(status);\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request\\n\");\n\txudc_ep0_stall(udc);\n}\n\n \nstatic void xudc_set_clear_feature(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0\t= &udc->ep[0];\n\tstruct xusb_req *req\t= udc->req;\n\tstruct xusb_ep *target_ep;\n\tu8 endpoint;\n\tu8 outinbit;\n\tu32 epcfgreg;\n\tint flag = (udc->setup.bRequest == USB_REQ_SET_FEATURE ? 1 : 0);\n\tint ret;\n\n\tswitch (udc->setup.bRequestType) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (le16_to_cpu(udc->setup.wValue)) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (flag)\n\t\t\t\tudc->remote_wkp = 1;\n\t\t\telse\n\t\t\t\tudc->remote_wkp = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\txudc_ep0_stall(udc);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (!udc->setup.wValue) {\n\t\t\tendpoint = le16_to_cpu(udc->setup.wIndex) &\n\t\t\t\t\t       USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (endpoint >= XUSB_MAX_ENDPOINTS) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget_ep = &udc->ep[endpoint];\n\t\t\toutinbit = le16_to_cpu(udc->setup.wIndex) &\n\t\t\t\t\t       USB_ENDPOINT_DIR_MASK;\n\t\t\toutinbit = outinbit >> 7;\n\n\t\t\t \n\t\t\tif (outinbit != target_ep->is_in) {\n\t\t\t\txudc_ep0_stall(udc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tepcfgreg = udc->read_fn(udc->addr + target_ep->offset);\n\t\t\tif (!endpoint) {\n\t\t\t\t \n\t\t\t\tepcfgreg &= ~XUSB_EP_CFG_STALL_MASK;\n\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t      target_ep->offset, epcfgreg);\n\t\t\t} else {\n\t\t\t\tif (flag) {\n\t\t\t\t\tepcfgreg |= XUSB_EP_CFG_STALL_MASK;\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tepcfgreg &= ~(XUSB_EP_CFG_STALL_MASK |\n\t\t\t\t\t\tXUSB_EP_CFG_DATA_TOGGLE_MASK);\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      target_ep->offset,\n\t\t\t\t\t\t      epcfgreg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\txudc_ep0_stall(udc);\n\t\treturn;\n\t}\n\n\treq->usb_req.length = 0;\n\tret = __xudc_ep0_queue(ep0, req);\n\tif (ret == 0)\n\t\treturn;\n\n\tdev_err(udc->dev, \"Can't respond to SET/CLEAR FEATURE\\n\");\n\txudc_ep0_stall(udc);\n}\n\n \nstatic void xudc_handle_setup(struct xusb_udc *udc)\n\t__must_hold(&udc->lock)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct usb_ctrlrequest setup;\n\tu32 *ep0rambase;\n\n\t \n\tep0rambase = (u32 __force *) (udc->addr + XUSB_SETUP_PKT_ADDR_OFFSET);\n\tmemcpy_toio((void __iomem *)&setup, ep0rambase, 8);\n\n\tudc->setup = setup;\n\tudc->setup.wValue = cpu_to_le16((u16 __force)setup.wValue);\n\tudc->setup.wIndex = cpu_to_le16((u16 __force)setup.wIndex);\n\tudc->setup.wLength = cpu_to_le16((u16 __force)setup.wLength);\n\n\t \n\txudc_nuke(ep0, -ECONNRESET);\n\n\tif (udc->setup.bRequestType & USB_DIR_IN) {\n\t\t \n\t\tudc->setupseqrx = STATUS_PHASE;\n\t\tudc->setupseqtx = DATA_PHASE;\n\t} else {\n\t\t \n\t\tudc->setupseqrx = DATA_PHASE;\n\t\tudc->setupseqtx = STATUS_PHASE;\n\t}\n\n\tswitch (udc->setup.bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t \n\t\tif ((udc->setup.bRequestType &\n\t\t\t\t(USB_DIR_IN | USB_TYPE_MASK)) !=\n\t\t\t\t(USB_DIR_IN | USB_TYPE_STANDARD))\n\t\t\tbreak;\n\t\txudc_getstatus(udc);\n\t\treturn;\n\tcase USB_REQ_SET_ADDRESS:\n\t\t \n\t\tif (udc->setup.bRequestType != (USB_DIR_OUT |\n\t\t\t\tUSB_TYPE_STANDARD | USB_RECIP_DEVICE))\n\t\t\tbreak;\n\t\txudc_setaddress(udc);\n\t\treturn;\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t \n\t\tif ((udc->setup.bRequestType & USB_TYPE_MASK)\n\t\t\t\t!= USB_TYPE_STANDARD)\n\t\t\tbreak;\n\t\txudc_set_clear_feature(udc);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock(&udc->lock);\n\tif (udc->driver->setup(&udc->gadget, &setup) < 0)\n\t\txudc_ep0_stall(udc);\n\tspin_lock(&udc->lock);\n}\n\n \nstatic void xudc_ep0_out(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tu8 *ep0rambase;\n\tunsigned int bytes_to_rx;\n\tvoid *buffer;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\n\tswitch (udc->setupseqrx) {\n\tcase STATUS_PHASE:\n\t\t \n\t\tudc->setupseqrx = SETUP_PHASE;\n\t\tudc->setupseqtx = SETUP_PHASE;\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tbytes_to_rx = udc->read_fn(udc->addr +\n\t\t\t\t\t   XUSB_EP_BUF0COUNT_OFFSET);\n\t\t \n\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t     (ep0->rambase << 2));\n\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\treq->usb_req.actual = req->usb_req.actual + bytes_to_rx;\n\t\tmemcpy_toio((void __iomem *)buffer, ep0rambase, bytes_to_rx);\n\n\t\tif (req->usb_req.length == req->usb_req.actual) {\n\t\t\t \n\t\t\txudc_wrstatus(udc);\n\t\t} else {\n\t\t\t \n\t\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, 0);\n\t\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void xudc_ep0_in(struct xusb_udc *udc)\n{\n\tstruct xusb_ep *ep0 = &udc->ep[0];\n\tstruct xusb_req *req;\n\tunsigned int bytes_to_tx;\n\tvoid *buffer;\n\tu32 epcfgreg;\n\tu16 count = 0;\n\tu16 length;\n\tu8 *ep0rambase;\n\tu8 test_mode = le16_to_cpu(udc->setup.wIndex) >> 8;\n\n\treq = list_first_entry(&ep0->queue, struct xusb_req, queue);\n\tbytes_to_tx = req->usb_req.length - req->usb_req.actual;\n\n\tswitch (udc->setupseqtx) {\n\tcase STATUS_PHASE:\n\t\tswitch (udc->setup.bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t \n\t\t\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET,\n\t\t\t\t      le16_to_cpu(udc->setup.wValue));\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tif (udc->setup.bRequestType ==\n\t\t\t\t\tUSB_RECIP_DEVICE) {\n\t\t\t\tif (le16_to_cpu(udc->setup.wValue) ==\n\t\t\t\t\t\tUSB_DEVICE_TEST_MODE)\n\t\t\t\t\tudc->write_fn(udc->addr,\n\t\t\t\t\t\t      XUSB_TESTMODE_OFFSET,\n\t\t\t\t\t\t      test_mode);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\treq->usb_req.actual = req->usb_req.length;\n\t\txudc_done(ep0, req, 0);\n\t\tbreak;\n\tcase DATA_PHASE:\n\t\tif (!bytes_to_tx) {\n\t\t\t \n\t\t\tepcfgreg = udc->read_fn(udc->addr + ep0->offset);\n\t\t\tepcfgreg |= XUSB_EP_CFG_DATA_TOGGLE_MASK;\n\t\t\tudc->write_fn(udc->addr, ep0->offset, epcfgreg);\n\t\t\tudc->setupseqtx = STATUS_PHASE;\n\t\t} else {\n\t\t\tlength = count = min_t(u32, bytes_to_tx,\n\t\t\t\t\t       EP0_MAX_PACKET);\n\t\t\t \n\t\t\tep0rambase = (u8 __force *) (udc->addr +\n\t\t\t\t     (ep0->rambase << 2));\n\t\t\tbuffer = req->usb_req.buf + req->usb_req.actual;\n\t\t\treq->usb_req.actual = req->usb_req.actual + length;\n\t\t\tmemcpy_toio((void __iomem *)ep0rambase, buffer, length);\n\t\t}\n\t\tudc->write_fn(udc->addr, XUSB_EP_BUF0COUNT_OFFSET, count);\n\t\tudc->write_fn(udc->addr, XUSB_BUFFREADY_OFFSET, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void xudc_ctrl_ep_handler(struct xusb_udc *udc, u32 intrstatus)\n{\n\n\tif (intrstatus & XUSB_STATUS_SETUP_PACKET_MASK) {\n\t\txudc_handle_setup(udc);\n\t} else {\n\t\tif (intrstatus & XUSB_STATUS_FIFO_BUFF_RDY_MASK)\n\t\t\txudc_ep0_out(udc);\n\t\telse if (intrstatus & XUSB_STATUS_FIFO_BUFF_FREE_MASK)\n\t\t\txudc_ep0_in(udc);\n\t}\n}\n\n \nstatic void xudc_nonctrl_ep_handler(struct xusb_udc *udc, u8 epnum,\n\t\t\t\t    u32 intrstatus)\n{\n\n\tstruct xusb_req *req;\n\tstruct xusb_ep *ep;\n\n\tep = &udc->ep[epnum];\n\t \n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF1_COMP_MASK << epnum))\n\t\tep->buffer0ready = 0;\n\tif (intrstatus & (XUSB_STATUS_EP0_BUFF2_COMP_MASK << epnum))\n\t\tep->buffer1ready = false;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\treq = list_first_entry(&ep->queue, struct xusb_req, queue);\n\n\tif (ep->is_in)\n\t\txudc_write_fifo(ep, req);\n\telse\n\t\txudc_read_fifo(ep, req);\n}\n\n \nstatic irqreturn_t xudc_irq(int irq, void *_udc)\n{\n\tstruct xusb_udc *udc = _udc;\n\tu32 intrstatus;\n\tu32 ier;\n\tu8 index;\n\tu32 bufintr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\tier &= ~XUSB_STATUS_INTR_EVENT_MASK;\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t \n\tintrstatus = udc->read_fn(udc->addr + XUSB_STATUS_OFFSET);\n\n\t \n\tif (intrstatus & XUSB_STATUS_INTR_EVENT_MASK) {\n\t\t \n\t\txudc_startup_handler(udc, intrstatus);\n\t}\n\n\t \n\tif (intrstatus & XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK) {\n\t\t \n\t\tier = udc->read_fn(udc->addr + XUSB_IER_OFFSET);\n\t\tier |= XUSB_STATUS_INTR_EVENT_MASK;\n\t\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\t\tif (intrstatus & XUSB_STATUS_EP0_BUFF1_COMP_MASK)\n\t\t\txudc_ctrl_ep_handler(udc, intrstatus);\n\n\t\tfor (index = 1; index < 8; index++) {\n\t\t\tbufintr = ((intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF1_COMP_MASK <<\n\t\t\t\t  (index - 1))) || (intrstatus &\n\t\t\t\t  (XUSB_STATUS_EP1_BUFF2_COMP_MASK <<\n\t\t\t\t  (index - 1))));\n\t\t\tif (bufintr) {\n\t\t\t\txudc_nonctrl_ep_handler(udc, index,\n\t\t\t\t\t\t\tintrstatus);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int xudc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct resource *res;\n\tstruct xusb_udc *udc;\n\tint irq;\n\tint ret;\n\tu32 ier;\n\tu8 *buff;\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\t \n\tudc->req = devm_kzalloc(&pdev->dev, sizeof(struct xusb_req),\n\t\t\t\tGFP_KERNEL);\n\tif (!udc->req)\n\t\treturn -ENOMEM;\n\n\tbuff = devm_kzalloc(&pdev->dev, STATUSBUFF_SIZE, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\tudc->req->usb_req.buf = buff;\n\n\t \n\tudc->addr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(udc->addr))\n\t\treturn PTR_ERR(udc->addr);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tret = devm_request_irq(&pdev->dev, irq, xudc_irq, 0,\n\t\t\t       dev_name(&pdev->dev), udc);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"unable to request irq %d\", irq);\n\t\tgoto fail;\n\t}\n\n\tudc->dma_enabled = of_property_read_bool(np, \"xlnx,has-builtin-dma\");\n\n\t \n\tudc->gadget.ops = &xusb_udc_ops;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.ep0 = &udc->ep[XUSB_EP_NUMBER_ZERO].ep_usb;\n\tudc->gadget.name = driver_name;\n\n\tudc->clk = devm_clk_get(&pdev->dev, \"s_axi_aclk\");\n\tif (IS_ERR(udc->clk)) {\n\t\tif (PTR_ERR(udc->clk) != -ENOENT) {\n\t\t\tret = PTR_ERR(udc->clk);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tdev_warn(&pdev->dev, \"s_axi_aclk clock property is not found\\n\");\n\t\tudc->clk = NULL;\n\t}\n\n\tret = clk_prepare_enable(udc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_init(&udc->lock);\n\n\t \n\tudc->write_fn = xudc_write32_be;\n\tudc->read_fn = xudc_read32_be;\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, USB_TEST_J);\n\tif ((udc->read_fn(udc->addr + XUSB_TESTMODE_OFFSET))\n\t\t\t!= USB_TEST_J) {\n\t\tudc->write_fn = xudc_write32;\n\t\tudc->read_fn = xudc_read32;\n\t}\n\tudc->write_fn(udc->addr, XUSB_TESTMODE_OFFSET, 0);\n\n\txudc_eps_init(udc);\n\n\t \n\tudc->write_fn(udc->addr, XUSB_ADDRESS_OFFSET, 0);\n\n\tret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (ret)\n\t\tgoto err_disable_unprepare_clk;\n\n\tudc->dev = &udc->gadget.dev;\n\n\t \n\tier = XUSB_STATUS_GLOBAL_INTR_MASK | XUSB_STATUS_INTR_EVENT_MASK |\n\t      XUSB_STATUS_FIFO_BUFF_RDY_MASK | XUSB_STATUS_FIFO_BUFF_FREE_MASK |\n\t      XUSB_STATUS_SETUP_PACKET_MASK |\n\t      XUSB_STATUS_INTR_BUFF_COMP_ALL_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_IER_OFFSET, ier);\n\n\tplatform_set_drvdata(pdev, udc);\n\n\tdev_vdbg(&pdev->dev, \"%s at 0x%08X mapped to %p %s\\n\",\n\t\t driver_name, (u32)res->start, udc->addr,\n\t\t udc->dma_enabled ? \"with DMA\" : \"without DMA\");\n\n\treturn 0;\n\nerr_disable_unprepare_clk:\n\tclk_disable_unprepare(udc->clk);\nfail:\n\tdev_err(&pdev->dev, \"probe failed, %d\\n\", ret);\n\treturn ret;\n}\n\n \nstatic void xudc_remove(struct platform_device *pdev)\n{\n\tstruct xusb_udc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tclk_disable_unprepare(udc->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xudc_suspend(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\n\tudc = dev_get_drvdata(dev);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg &= ~XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tif (udc->driver && udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n\n\tclk_disable(udc->clk);\n\n\treturn 0;\n}\n\nstatic int xudc_resume(struct device *dev)\n{\n\tstruct xusb_udc *udc;\n\tu32 crtlreg;\n\tunsigned long flags;\n\tint ret;\n\n\tudc = dev_get_drvdata(dev);\n\n\tret = clk_enable(udc->clk);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcrtlreg = udc->read_fn(udc->addr + XUSB_CONTROL_OFFSET);\n\tcrtlreg |= XUSB_CONTROL_USB_READY_MASK;\n\n\tudc->write_fn(udc->addr, XUSB_CONTROL_OFFSET, crtlreg);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n#endif  \n\nstatic const struct dev_pm_ops xudc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xudc_suspend, xudc_resume)\n};\n\n \nstatic const struct of_device_id usb_of_match[] = {\n\t{ .compatible = \"xlnx,usb2-device-4.00.a\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, usb_of_match);\n\nstatic struct platform_driver xudc_driver = {\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = usb_of_match,\n\t\t.pm\t= &xudc_pm_ops,\n\t},\n\t.probe = xudc_probe,\n\t.remove_new = xudc_remove,\n};\n\nmodule_platform_driver(xudc_driver);\n\nMODULE_DESCRIPTION(\"Xilinx udc driver\");\nMODULE_AUTHOR(\"Xilinx, Inc\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}