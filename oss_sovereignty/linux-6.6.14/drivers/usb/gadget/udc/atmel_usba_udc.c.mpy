{
  "module_name": "atmel_usba_udc.c",
  "hash_id": "0f7a1c84b5be5e36938a089a078f1c2b1463c94fadea18b741a930674e2e431b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/atmel_usba_udc.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/clk/at91_pmc.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/ctype.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/delay.h>\n#include <linux/of.h>\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n\n#include \"atmel_usba_udc.h\"\n#define USBA_VBUS_IRQFLAGS (IRQF_ONESHOT \\\n\t\t\t   | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING)\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n\nstatic int queue_dbg_open(struct inode *inode, struct file *file)\n{\n\tstruct usba_ep *ep = inode->i_private;\n\tstruct usba_request *req, *req_copy;\n\tstruct list_head *queue_data;\n\n\tqueue_data = kmalloc(sizeof(*queue_data), GFP_KERNEL);\n\tif (!queue_data)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD(queue_data);\n\n\tspin_lock_irq(&ep->udc->lock);\n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\treq_copy = kmemdup(req, sizeof(*req_copy), GFP_ATOMIC);\n\t\tif (!req_copy)\n\t\t\tgoto fail;\n\t\tlist_add_tail(&req_copy->queue, queue_data);\n\t}\n\tspin_unlock_irq(&ep->udc->lock);\n\n\tfile->private_data = queue_data;\n\treturn 0;\n\nfail:\n\tspin_unlock_irq(&ep->udc->lock);\n\tlist_for_each_entry_safe(req, req_copy, queue_data, queue) {\n\t\tlist_del(&req->queue);\n\t\tkfree(req);\n\t}\n\tkfree(queue_data);\n\treturn -ENOMEM;\n}\n\n \nstatic ssize_t queue_dbg_read(struct file *file, char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct list_head *queue = file->private_data;\n\tstruct usba_request *req, *tmp_req;\n\tsize_t len, remaining, actual = 0;\n\tchar tmpbuf[38];\n\n\tif (!access_ok(buf, nbytes))\n\t\treturn -EFAULT;\n\n\tinode_lock(file_inode(file));\n\tlist_for_each_entry_safe(req, tmp_req, queue, queue) {\n\t\tlen = snprintf(tmpbuf, sizeof(tmpbuf),\n\t\t\t\t\"%8p %08x %c%c%c %5d %c%c%c\\n\",\n\t\t\t\treq->req.buf, req->req.length,\n\t\t\t\treq->req.no_interrupt ? 'i' : 'I',\n\t\t\t\treq->req.zero ? 'Z' : 'z',\n\t\t\t\treq->req.short_not_ok ? 's' : 'S',\n\t\t\t\treq->req.status,\n\t\t\t\treq->submitted ? 'F' : 'f',\n\t\t\t\treq->using_dma ? 'D' : 'd',\n\t\t\t\treq->last_transaction ? 'L' : 'l');\n\t\tlen = min(len, sizeof(tmpbuf));\n\t\tif (len > nbytes)\n\t\t\tbreak;\n\n\t\tlist_del(&req->queue);\n\t\tkfree(req);\n\n\t\tremaining = __copy_to_user(buf, tmpbuf, len);\n\t\tactual += len - remaining;\n\t\tif (remaining)\n\t\t\tbreak;\n\n\t\tnbytes -= len;\n\t\tbuf += len;\n\t}\n\tinode_unlock(file_inode(file));\n\n\treturn actual;\n}\n\nstatic int queue_dbg_release(struct inode *inode, struct file *file)\n{\n\tstruct list_head *queue_data = file->private_data;\n\tstruct usba_request *req, *tmp_req;\n\n\tlist_for_each_entry_safe(req, tmp_req, queue_data, queue) {\n\t\tlist_del(&req->queue);\n\t\tkfree(req);\n\t}\n\tkfree(queue_data);\n\treturn 0;\n}\n\nstatic int regs_dbg_open(struct inode *inode, struct file *file)\n{\n\tstruct usba_udc *udc;\n\tunsigned int i;\n\tu32 *data;\n\tint ret = -ENOMEM;\n\n\tinode_lock(inode);\n\tudc = inode->i_private;\n\tdata = kmalloc(inode->i_size, GFP_KERNEL);\n\tif (!data)\n\t\tgoto out;\n\n\tspin_lock_irq(&udc->lock);\n\tfor (i = 0; i < inode->i_size / 4; i++)\n\t\tdata[i] = readl_relaxed(udc->regs + i * 4);\n\tspin_unlock_irq(&udc->lock);\n\n\tfile->private_data = data;\n\tret = 0;\n\nout:\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t regs_dbg_read(struct file *file, char __user *buf,\n\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(file);\n\tint ret;\n\n\tinode_lock(inode);\n\tret = simple_read_from_buffer(buf, nbytes, ppos,\n\t\t\tfile->private_data,\n\t\t\tfile_inode(file)->i_size);\n\tinode_unlock(inode);\n\n\treturn ret;\n}\n\nstatic int regs_dbg_release(struct inode *inode, struct file *file)\n{\n\tkfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations queue_dbg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= queue_dbg_open,\n\t.llseek\t\t= no_llseek,\n\t.read\t\t= queue_dbg_read,\n\t.release\t= queue_dbg_release,\n};\n\nstatic const struct file_operations regs_dbg_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= regs_dbg_open,\n\t.llseek\t\t= generic_file_llseek,\n\t.read\t\t= regs_dbg_read,\n\t.release\t= regs_dbg_release,\n};\n\nstatic void usba_ep_init_debugfs(struct usba_udc *udc,\n\t\tstruct usba_ep *ep)\n{\n\tstruct dentry *ep_root;\n\n\tep_root = debugfs_create_dir(ep->ep.name, udc->debugfs_root);\n\tep->debugfs_dir = ep_root;\n\n\tdebugfs_create_file(\"queue\", 0400, ep_root, ep, &queue_dbg_fops);\n\tif (ep->can_dma)\n\t\tdebugfs_create_u32(\"dma_status\", 0400, ep_root,\n\t\t\t\t   &ep->last_dma_status);\n\tif (ep_is_control(ep))\n\t\tdebugfs_create_u32(\"state\", 0400, ep_root, &ep->state);\n}\n\nstatic void usba_ep_cleanup_debugfs(struct usba_ep *ep)\n{\n\tdebugfs_remove_recursive(ep->debugfs_dir);\n}\n\nstatic void usba_init_debugfs(struct usba_udc *udc)\n{\n\tstruct dentry *root;\n\tstruct resource *regs_resource;\n\n\troot = debugfs_create_dir(udc->gadget.name, usb_debug_root);\n\tudc->debugfs_root = root;\n\n\tregs_resource = platform_get_resource(udc->pdev, IORESOURCE_MEM,\n\t\t\t\tCTRL_IOMEM_ID);\n\n\tif (regs_resource) {\n\t\tdebugfs_create_file_size(\"regs\", 0400, root, udc,\n\t\t\t\t\t &regs_dbg_fops,\n\t\t\t\t\t resource_size(regs_resource));\n\t}\n\n\tusba_ep_init_debugfs(udc, to_usba_ep(udc->gadget.ep0));\n}\n\nstatic void usba_cleanup_debugfs(struct usba_udc *udc)\n{\n\tusba_ep_cleanup_debugfs(to_usba_ep(udc->gadget.ep0));\n\tdebugfs_remove_recursive(udc->debugfs_root);\n}\n#else\nstatic inline void usba_ep_init_debugfs(struct usba_udc *udc,\n\t\t\t\t\t struct usba_ep *ep)\n{\n\n}\n\nstatic inline void usba_ep_cleanup_debugfs(struct usba_ep *ep)\n{\n\n}\n\nstatic inline void usba_init_debugfs(struct usba_udc *udc)\n{\n\n}\n\nstatic inline void usba_cleanup_debugfs(struct usba_udc *udc)\n{\n\n}\n#endif\n\nstatic ushort fifo_mode;\n\nmodule_param(fifo_mode, ushort, 0x0);\nMODULE_PARM_DESC(fifo_mode, \"Endpoint configuration mode\");\n\n \n\n \nstatic struct usba_fifo_cfg mode_1_cfg[] = {\n{ .hw_ep_num = 0, .fifo_size = 64,\t.nr_banks = 1, },\n{ .hw_ep_num = 1, .fifo_size = 1024,\t.nr_banks = 2, },\n{ .hw_ep_num = 2, .fifo_size = 1024,\t.nr_banks = 1, },\n{ .hw_ep_num = 3, .fifo_size = 1024,\t.nr_banks = 1, },\n{ .hw_ep_num = 4, .fifo_size = 1024,\t.nr_banks = 1, },\n{ .hw_ep_num = 5, .fifo_size = 1024,\t.nr_banks = 1, },\n{ .hw_ep_num = 6, .fifo_size = 1024,\t.nr_banks = 1, },\n};\n\n \nstatic struct usba_fifo_cfg mode_2_cfg[] = {\n{ .hw_ep_num = 0, .fifo_size = 64,\t.nr_banks = 1, },\n{ .hw_ep_num = 1, .fifo_size = 1024,\t.nr_banks = 3, },\n{ .hw_ep_num = 2, .fifo_size = 1024,\t.nr_banks = 2, },\n{ .hw_ep_num = 3, .fifo_size = 1024,\t.nr_banks = 2, },\n};\n\n \nstatic struct usba_fifo_cfg mode_3_cfg[] = {\n{ .hw_ep_num = 0, .fifo_size = 64,\t.nr_banks = 1, },\n{ .hw_ep_num = 1, .fifo_size = 1024,\t.nr_banks = 2, },\n{ .hw_ep_num = 2, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 3, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 4, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 5, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 6, .fifo_size = 512,\t.nr_banks = 2, },\n};\n\n \nstatic struct usba_fifo_cfg mode_4_cfg[] = {\n{ .hw_ep_num = 0, .fifo_size = 64,\t.nr_banks = 1, },\n{ .hw_ep_num = 1, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 2, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 3, .fifo_size = 8,\t.nr_banks = 2, },\n{ .hw_ep_num = 4, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 5, .fifo_size = 512,\t.nr_banks = 2, },\n{ .hw_ep_num = 6, .fifo_size = 16,\t.nr_banks = 2, },\n{ .hw_ep_num = 7, .fifo_size = 8,\t.nr_banks = 2, },\n{ .hw_ep_num = 8, .fifo_size = 8,\t.nr_banks = 2, },\n};\n \n\nstatic int usba_config_fifo_table(struct usba_udc *udc)\n{\n\tint n;\n\n\tswitch (fifo_mode) {\n\tdefault:\n\t\tfifo_mode = 0;\n\t\tfallthrough;\n\tcase 0:\n\t\tudc->fifo_cfg = NULL;\n\t\tn = 0;\n\t\tbreak;\n\tcase 1:\n\t\tudc->fifo_cfg = mode_1_cfg;\n\t\tn = ARRAY_SIZE(mode_1_cfg);\n\t\tbreak;\n\tcase 2:\n\t\tudc->fifo_cfg = mode_2_cfg;\n\t\tn = ARRAY_SIZE(mode_2_cfg);\n\t\tbreak;\n\tcase 3:\n\t\tudc->fifo_cfg = mode_3_cfg;\n\t\tn = ARRAY_SIZE(mode_3_cfg);\n\t\tbreak;\n\tcase 4:\n\t\tudc->fifo_cfg = mode_4_cfg;\n\t\tn = ARRAY_SIZE(mode_4_cfg);\n\t\tbreak;\n\t}\n\tDBG(DBG_HW, \"Setup fifo_mode %d\\n\", fifo_mode);\n\n\treturn n;\n}\n\nstatic inline u32 usba_int_enb_get(struct usba_udc *udc)\n{\n\treturn udc->int_enb_cache;\n}\n\nstatic inline void usba_int_enb_set(struct usba_udc *udc, u32 mask)\n{\n\tu32 val;\n\n\tval = udc->int_enb_cache | mask;\n\tusba_writel(udc, INT_ENB, val);\n\tudc->int_enb_cache = val;\n}\n\nstatic inline void usba_int_enb_clear(struct usba_udc *udc, u32 mask)\n{\n\tu32 val;\n\n\tval = udc->int_enb_cache & ~mask;\n\tusba_writel(udc, INT_ENB, val);\n\tudc->int_enb_cache = val;\n}\n\nstatic int vbus_is_present(struct usba_udc *udc)\n{\n\tif (udc->vbus_pin)\n\t\treturn gpiod_get_value(udc->vbus_pin);\n\n\t \n\treturn 1;\n}\n\nstatic void toggle_bias(struct usba_udc *udc, int is_on)\n{\n\tif (udc->errata && udc->errata->toggle_bias)\n\t\tudc->errata->toggle_bias(udc, is_on);\n}\n\nstatic void generate_bias_pulse(struct usba_udc *udc)\n{\n\tif (!udc->bias_pulse_needed)\n\t\treturn;\n\n\tif (udc->errata && udc->errata->pulse_bias)\n\t\tudc->errata->pulse_bias(udc);\n\n\tudc->bias_pulse_needed = false;\n}\n\nstatic void next_fifo_transaction(struct usba_ep *ep, struct usba_request *req)\n{\n\tunsigned int transaction_len;\n\n\ttransaction_len = req->req.length - req->req.actual;\n\treq->last_transaction = 1;\n\tif (transaction_len > ep->ep.maxpacket) {\n\t\ttransaction_len = ep->ep.maxpacket;\n\t\treq->last_transaction = 0;\n\t} else if (transaction_len == ep->ep.maxpacket && req->req.zero)\n\t\treq->last_transaction = 0;\n\n\tDBG(DBG_QUEUE, \"%s: submit_transaction, req %p (length %d)%s\\n\",\n\t\tep->ep.name, req, transaction_len,\n\t\treq->last_transaction ? \", done\" : \"\");\n\n\tmemcpy_toio(ep->fifo, req->req.buf + req->req.actual, transaction_len);\n\tusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\n\treq->req.actual += transaction_len;\n}\n\nstatic void submit_request(struct usba_ep *ep, struct usba_request *req)\n{\n\tDBG(DBG_QUEUE, \"%s: submit_request: req %p (length %d)\\n\",\n\t\tep->ep.name, req, req->req.length);\n\n\treq->req.actual = 0;\n\treq->submitted = 1;\n\n\tif (req->using_dma) {\n\t\tif (req->req.length == 0) {\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\n\t\t\treturn;\n\t\t}\n\n\t\tif (req->req.zero)\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_SHORT_PACKET);\n\t\telse\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_SHORT_PACKET);\n\n\t\tusba_dma_writel(ep, ADDRESS, req->req.dma);\n\t\tusba_dma_writel(ep, CONTROL, req->ctrl);\n\t} else {\n\t\tnext_fifo_transaction(ep, req);\n\t\tif (req->last_transaction) {\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\n\t\t\tif (ep_is_control(ep))\n\t\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\n\t\t} else {\n\t\t\tif (ep_is_control(ep))\n\t\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\n\t\t}\n\t}\n}\n\nstatic void submit_next_request(struct usba_ep *ep)\n{\n\tstruct usba_request *req;\n\n\tif (list_empty(&ep->queue)) {\n\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY | USBA_RX_BK_RDY);\n\t\treturn;\n\t}\n\n\treq = list_entry(ep->queue.next, struct usba_request, queue);\n\tif (!req->submitted)\n\t\tsubmit_request(ep, req);\n}\n\nstatic void send_status(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tep->state = STATUS_STAGE_IN;\n\tusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\n\tusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\n}\n\nstatic void receive_data(struct usba_ep *ep)\n{\n\tstruct usba_udc *udc = ep->udc;\n\tstruct usba_request *req;\n\tunsigned long status;\n\tunsigned int bytecount, nr_busy;\n\tint is_complete = 0;\n\n\tstatus = usba_ep_readl(ep, STA);\n\tnr_busy = USBA_BFEXT(BUSY_BANKS, status);\n\n\tDBG(DBG_QUEUE, \"receive data: nr_busy=%u\\n\", nr_busy);\n\n\twhile (nr_busy > 0) {\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\n\t\t\tbreak;\n\t\t}\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\t struct usba_request, queue);\n\n\t\tbytecount = USBA_BFEXT(BYTE_COUNT, status);\n\n\t\tif (status & (1 << 31))\n\t\t\tis_complete = 1;\n\t\tif (req->req.actual + bytecount >= req->req.length) {\n\t\t\tis_complete = 1;\n\t\t\tbytecount = req->req.length - req->req.actual;\n\t\t}\n\n\t\tmemcpy_fromio(req->req.buf + req->req.actual,\n\t\t\t\tep->fifo, bytecount);\n\t\treq->req.actual += bytecount;\n\n\t\tusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\n\n\t\tif (is_complete) {\n\t\t\tDBG(DBG_QUEUE, \"%s: request done\\n\", ep->ep.name);\n\t\t\treq->req.status = 0;\n\t\t\tlist_del_init(&req->queue);\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\n\t\tstatus = usba_ep_readl(ep, STA);\n\t\tnr_busy = USBA_BFEXT(BUSY_BANKS, status);\n\n\t\tif (is_complete && ep_is_control(ep)) {\n\t\t\tsend_status(udc, ep);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nrequest_complete(struct usba_ep *ep, struct usba_request *req, int status)\n{\n\tstruct usba_udc *udc = ep->udc;\n\n\tWARN_ON(!list_empty(&req->queue));\n\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\n\tif (req->using_dma)\n\t\tusb_gadget_unmap_request(&udc->gadget, &req->req, ep->is_in);\n\n\tDBG(DBG_GADGET | DBG_REQ,\n\t\t\"%s: req %p complete: status %d, actual %u\\n\",\n\t\tep->ep.name, req, req->req.status, req->req.actual);\n\n\tspin_unlock(&udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&udc->lock);\n}\n\nstatic void\nrequest_complete_list(struct usba_ep *ep, struct list_head *list, int status)\n{\n\tstruct usba_request *req, *tmp_req;\n\n\tlist_for_each_entry_safe(req, tmp_req, list, queue) {\n\t\tlist_del_init(&req->queue);\n\t\trequest_complete(ep, req, status);\n\t}\n}\n\nstatic int\nusba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\tunsigned long flags, maxpacket;\n\tunsigned int nr_trans;\n\n\tDBG(DBG_GADGET, \"%s: ep_enable: desc=%p\\n\", ep->ep.name, desc);\n\n\tmaxpacket = usb_endpoint_maxp(desc);\n\n\tif (((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != ep->index)\n\t\t\t|| ep->index == 0\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT\n\t\t\t|| maxpacket == 0\n\t\t\t|| maxpacket > ep->fifo_size) {\n\t\tDBG(DBG_ERR, \"ep_enable: Invalid argument\");\n\t\treturn -EINVAL;\n\t}\n\n\tep->is_isoc = 0;\n\tep->is_in = 0;\n\n\tDBG(DBG_ERR, \"%s: EPT_CFG = 0x%lx (maxpacket = %lu)\\n\",\n\t\t\tep->ep.name, ep->ept_cfg, maxpacket);\n\n\tif (usb_endpoint_dir_in(desc)) {\n\t\tep->is_in = 1;\n\t\tep->ept_cfg |= USBA_EPT_DIR_IN;\n\t}\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tep->ept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (!ep->can_isoc) {\n\t\t\tDBG(DBG_ERR, \"ep_enable: %s is not isoc capable\\n\",\n\t\t\t\t\tep->ep.name);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tnr_trans = usb_endpoint_maxp_mult(desc);\n\t\tif (nr_trans > 3)\n\t\t\treturn -EINVAL;\n\n\t\tep->is_isoc = 1;\n\t\tep->ept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_ISO);\n\t\tep->ept_cfg |= USBA_BF(NB_TRANS, nr_trans);\n\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep->ept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep->ept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_INT);\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\tep->ep.desc = desc;\n\tep->ep.maxpacket = maxpacket;\n\n\tusba_ep_writel(ep, CFG, ep->ept_cfg);\n\tusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\n\n\tif (ep->can_dma) {\n\t\tu32 ctrl;\n\n\t\tusba_int_enb_set(udc, USBA_BF(EPT_INT, 1 << ep->index) |\n\t\t\t\t      USBA_BF(DMA_INT, 1 << ep->index));\n\t\tctrl = USBA_AUTO_VALID | USBA_INTDIS_DMA;\n\t\tusba_ep_writel(ep, CTL_ENB, ctrl);\n\t} else {\n\t\tusba_int_enb_set(udc, USBA_BF(EPT_INT, 1 << ep->index));\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tDBG(DBG_HW, \"EPT_CFG%d after init: %#08lx\\n\", ep->index,\n\t\t\t(unsigned long)usba_ep_readl(ep, CFG));\n\tDBG(DBG_HW, \"INT_ENB after init: %#08lx\\n\",\n\t\t\t(unsigned long)usba_int_enb_get(udc));\n\n\treturn 0;\n}\n\nstatic int usba_ep_disable(struct usb_ep *_ep)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\tLIST_HEAD(req_list);\n\tunsigned long flags;\n\n\tDBG(DBG_GADGET, \"ep_disable: %s\\n\", ep->ep.name);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!ep->ep.desc) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\tDBG(DBG_ERR, \"ep_disable: %s not enabled\\n\", ep->ep.name);\n\t\treturn -EINVAL;\n\t}\n\tep->ep.desc = NULL;\n\n\tlist_splice_init(&ep->queue, &req_list);\n\tif (ep->can_dma) {\n\t\tusba_dma_writel(ep, CONTROL, 0);\n\t\tusba_dma_writel(ep, ADDRESS, 0);\n\t\tusba_dma_readl(ep, STATUS);\n\t}\n\tusba_ep_writel(ep, CTL_DIS, USBA_EPT_ENABLE);\n\tusba_int_enb_clear(udc, USBA_BF(EPT_INT, 1 << ep->index));\n\n\trequest_complete_list(ep, &req_list, -ESHUTDOWN);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_request *\nusba_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct usba_request *req;\n\n\tDBG(DBG_GADGET, \"ep_alloc_request: %p, 0x%x\\n\", _ep, gfp_flags);\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void\nusba_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct usba_request *req = to_usba_req(_req);\n\n\tDBG(DBG_GADGET, \"ep_free_request: %p, %p\\n\", _ep, _req);\n\n\tkfree(req);\n}\n\nstatic int queue_dma(struct usba_udc *udc, struct usba_ep *ep,\n\t\tstruct usba_request *req, gfp_t gfp_flags)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tDBG(DBG_DMA, \"%s: req l/%u d/%pad %c%c%c\\n\",\n\t\tep->ep.name, req->req.length, &req->req.dma,\n\t\treq->req.zero ? 'Z' : 'z',\n\t\treq->req.short_not_ok ? 'S' : 's',\n\t\treq->req.no_interrupt ? 'I' : 'i');\n\n\tif (req->req.length > 0x10000) {\n\t\t \n\t\tDBG(DBG_ERR, \"invalid request length %u\\n\", req->req.length);\n\t\treturn -EINVAL;\n\t}\n\n\tret = usb_gadget_map_request(&udc->gadget, &req->req, ep->is_in);\n\tif (ret)\n\t\treturn ret;\n\n\treq->using_dma = 1;\n\treq->ctrl = USBA_BF(DMA_BUF_LEN, req->req.length)\n\t\t\t| USBA_DMA_CH_EN | USBA_DMA_END_BUF_IE\n\t\t\t| USBA_DMA_END_BUF_EN;\n\n\tif (!ep->is_in)\n\t\treq->ctrl |= USBA_DMA_END_TR_EN | USBA_DMA_END_TR_IE;\n\n\t \n\tret = -ESHUTDOWN;\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (ep->ep.desc) {\n\t\tif (list_empty(&ep->queue))\n\t\t\tsubmit_request(ep, req);\n\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int\nusba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct usba_request *req = to_usba_req(_req);\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tDBG(DBG_GADGET | DBG_QUEUE | DBG_REQ, \"%s: queue req %p, len %u\\n\",\n\t\t\tep->ep.name, req, _req->length);\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN ||\n\t    !ep->ep.desc)\n\t\treturn -ESHUTDOWN;\n\n\treq->submitted = 0;\n\treq->using_dma = 0;\n\treq->last_transaction = 0;\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tif (ep->can_dma)\n\t\treturn queue_dma(udc, ep, req, gfp_flags);\n\n\t \n\tret = -ESHUTDOWN;\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (ep->ep.desc) {\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\t\tif ((!ep_is_control(ep) && ep->is_in) ||\n\t\t\t(ep_is_control(ep)\n\t\t\t\t&& (ep->state == DATA_STAGE_IN\n\t\t\t\t\t|| ep->state == STATUS_STAGE_IN)))\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\n\t\telse\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_RX_BK_RDY);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic void\nusba_update_req(struct usba_ep *ep, struct usba_request *req, u32 status)\n{\n\treq->req.actual = req->req.length - USBA_BFEXT(DMA_BUF_LEN, status);\n}\n\nstatic int stop_dma(struct usba_ep *ep, u32 *pstatus)\n{\n\tunsigned int timeout;\n\tu32 status;\n\n\t \n\tusba_dma_writel(ep, CONTROL, 0);\n\n\t \n\tfor (timeout = 40; timeout; --timeout) {\n\t\tstatus = usba_dma_readl(ep, STATUS);\n\t\tif (!(status & USBA_DMA_CH_EN))\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (pstatus)\n\t\t*pstatus = status;\n\n\tif (timeout == 0) {\n\t\tdev_err(&ep->udc->pdev->dev,\n\t\t\t\"%s: timed out waiting for DMA FIFO to empty\\n\",\n\t\t\tep->ep.name);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int usba_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\tstruct usba_request *req = NULL;\n\tstruct usba_request *iter;\n\tunsigned long flags;\n\tu32 status;\n\n\tDBG(DBG_GADGET | DBG_QUEUE, \"ep_dequeue: %s, req %p\\n\",\n\t\t\tep->ep.name, _req);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tif (req->using_dma) {\n\t\t \n\t\tif (ep->queue.next == &req->queue) {\n\t\t\tstatus = usba_dma_readl(ep, STATUS);\n\t\t\tif (status & USBA_DMA_CH_EN)\n\t\t\t\tstop_dma(ep, &status);\n\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n\t\t\tep->last_dma_status = status;\n#endif\n\n\t\t\tusba_writel(udc, EPT_RST, 1 << ep->index);\n\n\t\t\tusba_update_req(ep, req, status);\n\t\t}\n\t}\n\n\t \n\tlist_del_init(&req->queue);\n\n\trequest_complete(ep, req, -ECONNRESET);\n\n\t \n\tsubmit_next_request(ep);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usba_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tDBG(DBG_GADGET, \"endpoint %s: %s HALT\\n\", ep->ep.name,\n\t\t\tvalue ? \"set\" : \"clear\");\n\n\tif (!ep->ep.desc) {\n\t\tDBG(DBG_ERR, \"Attempted to halt uninitialized ep %s\\n\",\n\t\t\t\tep->ep.name);\n\t\treturn -ENODEV;\n\t}\n\tif (ep->is_isoc) {\n\t\tDBG(DBG_ERR, \"Attempted to halt isochronous ep %s\\n\",\n\t\t\t\tep->ep.name);\n\t\treturn -ENOTTY;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (!list_empty(&ep->queue)\n\t\t\t|| ((value && ep->is_in && (usba_ep_readl(ep, STA)\n\t\t\t\t\t& USBA_BF(BUSY_BANKS, -1L))))) {\n\t\tret = -EAGAIN;\n\t} else {\n\t\tif (value)\n\t\t\tusba_ep_writel(ep, SET_STA, USBA_FORCE_STALL);\n\t\telse\n\t\t\tusba_ep_writel(ep, CLR_STA,\n\t\t\t\t\tUSBA_FORCE_STALL | USBA_TOGGLE_CLR);\n\t\tusba_ep_readl(ep, STA);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int usba_ep_fifo_status(struct usb_ep *_ep)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\n\treturn USBA_BFEXT(BYTE_COUNT, usba_ep_readl(ep, STA));\n}\n\nstatic void usba_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct usba_ep *ep = to_usba_ep(_ep);\n\tstruct usba_udc *udc = ep->udc;\n\n\tusba_writel(udc, EPT_RST, 1 << ep->index);\n}\n\nstatic const struct usb_ep_ops usba_ep_ops = {\n\t.enable\t\t= usba_ep_enable,\n\t.disable\t= usba_ep_disable,\n\t.alloc_request\t= usba_ep_alloc_request,\n\t.free_request\t= usba_ep_free_request,\n\t.queue\t\t= usba_ep_queue,\n\t.dequeue\t= usba_ep_dequeue,\n\t.set_halt\t= usba_ep_set_halt,\n\t.fifo_status\t= usba_ep_fifo_status,\n\t.fifo_flush\t= usba_ep_fifo_flush,\n};\n\nstatic int usba_udc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct usba_udc *udc = to_usba_udc(gadget);\n\n\treturn USBA_BFEXT(FRAME_NUMBER, usba_readl(udc, FNUM));\n}\n\nstatic int usba_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct usba_udc *udc = to_usba_udc(gadget);\n\tunsigned long flags;\n\tu32 ctrl;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (udc->devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP)) {\n\t\tctrl = usba_readl(udc, CTRL);\n\t\tusba_writel(udc, CTRL, ctrl | USBA_REMOTE_WAKE_UP);\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int\nusba_udc_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)\n{\n\tstruct usba_udc *udc = to_usba_udc(gadget);\n\tunsigned long flags;\n\n\tgadget->is_selfpowered = (is_selfpowered != 0);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (is_selfpowered)\n\t\tudc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\n\telse\n\t\tudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int atmel_usba_pullup(struct usb_gadget *gadget, int is_on);\nstatic int atmel_usba_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver);\nstatic int atmel_usba_stop(struct usb_gadget *gadget);\n\nstatic struct usb_ep *atmel_usba_match_ep(struct usb_gadget *gadget,\n\t\t\t\tstruct usb_endpoint_descriptor\t*desc,\n\t\t\t\tstruct usb_ss_ep_comp_descriptor *ep_comp)\n{\n\tstruct usb_ep\t*_ep;\n\tstruct usba_ep *ep;\n\n\t \n\tlist_for_each_entry(_ep, &gadget->ep_list, ep_list) {\n\t\tif (usb_gadget_ep_match_desc(gadget, _ep, desc, ep_comp))\n\t\t\tgoto found_ep;\n\t}\n\t \n\treturn NULL;\n\nfound_ep:\n\n\tif (fifo_mode == 0) {\n\t\t \n\t\tep = to_usba_ep(_ep);\n\n\t\tswitch (usb_endpoint_type(desc)) {\n\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tep->nr_banks = 1;\n\t\t\tbreak;\n\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tep->fifo_size = 1024;\n\t\t\tif (ep->udc->ep_prealloc)\n\t\t\t\tep->nr_banks = 2;\n\t\t\tbreak;\n\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tep->fifo_size = 512;\n\t\t\tif (ep->udc->ep_prealloc)\n\t\t\t\tep->nr_banks = 1;\n\t\t\tbreak;\n\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tif (desc->wMaxPacketSize == 0)\n\t\t\t\tep->fifo_size =\n\t\t\t\t    roundup_pow_of_two(_ep->maxpacket_limit);\n\t\t\telse\n\t\t\t\tep->fifo_size =\n\t\t\t\t    roundup_pow_of_two(le16_to_cpu(desc->wMaxPacketSize));\n\t\t\tif (ep->udc->ep_prealloc)\n\t\t\t\tep->nr_banks = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ep->fifo_size);\n\n\t\t \n\t\tif (ep->fifo_size  <= 8)\n\t\t\tep->ept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);\n\t\telse\n\t\t\t \n\t\t\tep->ept_cfg =\n\t\t\t\tUSBA_BF(EPT_SIZE, fls(ep->fifo_size - 1) - 3);\n\n\t\tep->ept_cfg |= USBA_BF(BK_NUMBER, ep->nr_banks);\n\t}\n\n\treturn _ep;\n}\n\nstatic const struct usb_gadget_ops usba_udc_ops = {\n\t.get_frame\t\t= usba_udc_get_frame,\n\t.wakeup\t\t\t= usba_udc_wakeup,\n\t.set_selfpowered\t= usba_udc_set_selfpowered,\n\t.pullup\t\t\t= atmel_usba_pullup,\n\t.udc_start\t\t= atmel_usba_start,\n\t.udc_stop\t\t= atmel_usba_stop,\n\t.match_ep\t\t= atmel_usba_match_ep,\n};\n\nstatic struct usb_endpoint_descriptor usba_ep0_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bEndpointAddress = 0,\n\t.bmAttributes = USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize = cpu_to_le16(64),\n\t \n\t.bInterval = 1,\n};\n\nstatic const struct usb_gadget usba_gadget_template = {\n\t.ops\t\t= &usba_udc_ops,\n\t.max_speed\t= USB_SPEED_HIGH,\n\t.name\t\t= \"atmel_usba_udc\",\n};\n\n \nstatic void reset_all_endpoints(struct usba_udc *udc)\n{\n\tstruct usba_ep *ep;\n\tstruct usba_request *req, *tmp_req;\n\n\tusba_writel(udc, EPT_RST, ~0UL);\n\n\tep = to_usba_ep(udc->gadget.ep0);\n\tlist_for_each_entry_safe(req, tmp_req, &ep->queue, queue) {\n\t\tlist_del_init(&req->queue);\n\t\trequest_complete(ep, req, -ECONNRESET);\n\t}\n}\n\nstatic struct usba_ep *get_ep_by_addr(struct usba_udc *udc, u16 wIndex)\n{\n\tstruct usba_ep *ep;\n\n\tif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\n\t\treturn to_usba_ep(udc->gadget.ep0);\n\n\tlist_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\tu8 bEndpointAddress;\n\n\t\tif (!ep->ep.desc)\n\t\t\tcontinue;\n\t\tbEndpointAddress = ep->ep.desc->bEndpointAddress;\n\t\tif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\n\t\t\tcontinue;\n\t\tif ((bEndpointAddress & USB_ENDPOINT_NUMBER_MASK)\n\t\t\t\t== (wIndex & USB_ENDPOINT_NUMBER_MASK))\n\t\t\treturn ep;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic inline void set_protocol_stall(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tusba_ep_writel(ep, SET_STA, USBA_FORCE_STALL);\n\tep->state = WAIT_FOR_SETUP;\n}\n\nstatic inline int is_stalled(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tif (usba_ep_readl(ep, STA) & USBA_FORCE_STALL)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline void set_address(struct usba_udc *udc, unsigned int addr)\n{\n\tu32 regval;\n\n\tDBG(DBG_BUS, \"setting address %u...\\n\", addr);\n\tregval = usba_readl(udc, CTRL);\n\tregval = USBA_BFINS(DEV_ADDR, addr, regval);\n\tusba_writel(udc, CTRL, regval);\n}\n\nstatic int do_test_mode(struct usba_udc *udc)\n{\n\tstatic const char test_packet_buffer[] = {\n\t\t \n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t \n\t\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t\t \n\t\t0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,\n\t\t \n\t\t0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t\t \n\t\t0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD,\n\t\t \n\t\t0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E\n\t};\n\tstruct usba_ep *ep;\n\tstruct device *dev = &udc->pdev->dev;\n\tint test_mode;\n\n\ttest_mode = udc->test_mode;\n\n\t \n\treset_all_endpoints(udc);\n\n\tswitch (test_mode) {\n\tcase 0x0100:\n\t\t \n\t\tusba_writel(udc, TST, USBA_TST_J_MODE);\n\t\tdev_info(dev, \"Entering Test_J mode...\\n\");\n\t\tbreak;\n\tcase 0x0200:\n\t\t \n\t\tusba_writel(udc, TST, USBA_TST_K_MODE);\n\t\tdev_info(dev, \"Entering Test_K mode...\\n\");\n\t\tbreak;\n\tcase 0x0300:\n\t\t \n\t\tep = &udc->usba_ep[0];\n\t\tusba_writel(udc, TST,\n\t\t\t\tUSBA_BF(SPEED_CFG, USBA_SPEED_CFG_FORCE_HIGH));\n\t\tusba_ep_writel(ep, CFG,\n\t\t\t\tUSBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)\n\t\t\t\t| USBA_EPT_DIR_IN\n\t\t\t\t| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)\n\t\t\t\t| USBA_BF(BK_NUMBER, 1));\n\t\tif (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {\n\t\t\tset_protocol_stall(udc, ep);\n\t\t\tdev_err(dev, \"Test_SE0_NAK: ep0 not mapped\\n\");\n\t\t} else {\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\n\t\t\tdev_info(dev, \"Entering Test_SE0_NAK mode...\\n\");\n\t\t}\n\t\tbreak;\n\tcase 0x0400:\n\t\t \n\t\tep = &udc->usba_ep[0];\n\t\tusba_ep_writel(ep, CFG,\n\t\t\t\tUSBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)\n\t\t\t\t| USBA_EPT_DIR_IN\n\t\t\t\t| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)\n\t\t\t\t| USBA_BF(BK_NUMBER, 1));\n\t\tif (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {\n\t\t\tset_protocol_stall(udc, ep);\n\t\t\tdev_err(dev, \"Test_Packet: ep0 not mapped\\n\");\n\t\t} else {\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\n\t\t\tusba_writel(udc, TST, USBA_TST_PKT_MODE);\n\t\t\tmemcpy_toio(ep->fifo, test_packet_buffer,\n\t\t\t\t\tsizeof(test_packet_buffer));\n\t\t\tusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\n\t\t\tdev_info(dev, \"Entering Test_Packet mode...\\n\");\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Invalid test mode: 0x%04x\\n\", test_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline bool feature_is_dev_remote_wakeup(struct usb_ctrlrequest *crq)\n{\n\tif (crq->wValue == cpu_to_le16(USB_DEVICE_REMOTE_WAKEUP))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool feature_is_dev_test_mode(struct usb_ctrlrequest *crq)\n{\n\tif (crq->wValue == cpu_to_le16(USB_DEVICE_TEST_MODE))\n\t\treturn true;\n\treturn false;\n}\n\nstatic inline bool feature_is_ep_halt(struct usb_ctrlrequest *crq)\n{\n\tif (crq->wValue == cpu_to_le16(USB_ENDPOINT_HALT))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,\n\t\tstruct usb_ctrlrequest *crq)\n{\n\tint retval = 0;\n\n\tswitch (crq->bRequest) {\n\tcase USB_REQ_GET_STATUS: {\n\t\tu16 status;\n\n\t\tif (crq->bRequestType == (USB_DIR_IN | USB_RECIP_DEVICE)) {\n\t\t\tstatus = cpu_to_le16(udc->devstatus);\n\t\t} else if (crq->bRequestType\n\t\t\t\t== (USB_DIR_IN | USB_RECIP_INTERFACE)) {\n\t\t\tstatus = cpu_to_le16(0);\n\t\t} else if (crq->bRequestType\n\t\t\t\t== (USB_DIR_IN | USB_RECIP_ENDPOINT)) {\n\t\t\tstruct usba_ep *target;\n\n\t\t\ttarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\n\t\t\tif (!target)\n\t\t\t\tgoto stall;\n\n\t\t\tstatus = 0;\n\t\t\tif (is_stalled(udc, target))\n\t\t\t\tstatus |= cpu_to_le16(1);\n\t\t} else\n\t\t\tgoto delegate;\n\n\t\t \n\t\tif (crq->wLength != cpu_to_le16(sizeof(status)))\n\t\t\tgoto stall;\n\t\tep->state = DATA_STAGE_IN;\n\t\twritew_relaxed(status, ep->fifo);\n\t\tusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\n\t\tbreak;\n\t}\n\n\tcase USB_REQ_CLEAR_FEATURE: {\n\t\tif (crq->bRequestType == USB_RECIP_DEVICE) {\n\t\t\tif (feature_is_dev_remote_wakeup(crq))\n\t\t\t\tudc->devstatus\n\t\t\t\t\t&= ~(1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tgoto stall;\n\t\t} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {\n\t\t\tstruct usba_ep *target;\n\n\t\t\tif (crq->wLength != cpu_to_le16(0)\n\t\t\t\t\t|| !feature_is_ep_halt(crq))\n\t\t\t\tgoto stall;\n\t\t\ttarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\n\t\t\tif (!target)\n\t\t\t\tgoto stall;\n\n\t\t\tusba_ep_writel(target, CLR_STA, USBA_FORCE_STALL);\n\t\t\tif (target->index != 0)\n\t\t\t\tusba_ep_writel(target, CLR_STA,\n\t\t\t\t\t\tUSBA_TOGGLE_CLR);\n\t\t} else {\n\t\t\tgoto delegate;\n\t\t}\n\n\t\tsend_status(udc, ep);\n\t\tbreak;\n\t}\n\n\tcase USB_REQ_SET_FEATURE: {\n\t\tif (crq->bRequestType == USB_RECIP_DEVICE) {\n\t\t\tif (feature_is_dev_test_mode(crq)) {\n\t\t\t\tsend_status(udc, ep);\n\t\t\t\tep->state = STATUS_STAGE_TEST;\n\t\t\t\tudc->test_mode = le16_to_cpu(crq->wIndex);\n\t\t\t\treturn 0;\n\t\t\t} else if (feature_is_dev_remote_wakeup(crq)) {\n\t\t\t\tudc->devstatus |= 1 << USB_DEVICE_REMOTE_WAKEUP;\n\t\t\t} else {\n\t\t\t\tgoto stall;\n\t\t\t}\n\t\t} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {\n\t\t\tstruct usba_ep *target;\n\n\t\t\tif (crq->wLength != cpu_to_le16(0)\n\t\t\t\t\t|| !feature_is_ep_halt(crq))\n\t\t\t\tgoto stall;\n\n\t\t\ttarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\n\t\t\tif (!target)\n\t\t\t\tgoto stall;\n\n\t\t\tusba_ep_writel(target, SET_STA, USBA_FORCE_STALL);\n\t\t} else\n\t\t\tgoto delegate;\n\n\t\tsend_status(udc, ep);\n\t\tbreak;\n\t}\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (crq->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\n\t\t\tgoto delegate;\n\n\t\tset_address(udc, le16_to_cpu(crq->wValue));\n\t\tsend_status(udc, ep);\n\t\tep->state = STATUS_STAGE_ADDR;\n\t\tbreak;\n\n\tdefault:\ndelegate:\n\t\tspin_unlock(&udc->lock);\n\t\tretval = udc->driver->setup(&udc->gadget, crq);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\treturn retval;\n\nstall:\n\tpr_err(\"udc: %s: Invalid setup request: %02x.%02x v%04x i%04x l%d, \"\n\t\t\"halting endpoint...\\n\",\n\t\tep->ep.name, crq->bRequestType, crq->bRequest,\n\t\tle16_to_cpu(crq->wValue), le16_to_cpu(crq->wIndex),\n\t\tle16_to_cpu(crq->wLength));\n\tset_protocol_stall(udc, ep);\n\treturn -1;\n}\n\nstatic void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tstruct usba_request *req;\n\tu32 epstatus;\n\tu32 epctrl;\n\nrestart:\n\tepstatus = usba_ep_readl(ep, STA);\n\tepctrl = usba_ep_readl(ep, CTL);\n\n\tDBG(DBG_INT, \"%s [%d]: s/%08x c/%08x\\n\",\n\t\t\tep->ep.name, ep->state, epstatus, epctrl);\n\n\treq = NULL;\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\t struct usba_request, queue);\n\n\tif ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {\n\t\tif (req->submitted)\n\t\t\tnext_fifo_transaction(ep, req);\n\t\telse\n\t\t\tsubmit_request(ep, req);\n\n\t\tif (req->last_transaction) {\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\n\t\t}\n\t\tgoto restart;\n\t}\n\tif ((epstatus & epctrl) & USBA_TX_COMPLETE) {\n\t\tusba_ep_writel(ep, CLR_STA, USBA_TX_COMPLETE);\n\n\t\tswitch (ep->state) {\n\t\tcase DATA_STAGE_IN:\n\t\t\tusba_ep_writel(ep, CTL_ENB, USBA_RX_BK_RDY);\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\n\t\t\tep->state = STATUS_STAGE_OUT;\n\t\t\tbreak;\n\t\tcase STATUS_STAGE_ADDR:\n\t\t\t \n\t\t\tusba_writel(udc, CTRL, (usba_readl(udc, CTRL)\n\t\t\t\t\t\t| USBA_FADDR_EN));\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\n\t\t\tep->state = WAIT_FOR_SETUP;\n\t\t\tbreak;\n\t\tcase STATUS_STAGE_IN:\n\t\t\tif (req) {\n\t\t\t\tlist_del_init(&req->queue);\n\t\t\t\trequest_complete(ep, req, 0);\n\t\t\t\tsubmit_next_request(ep);\n\t\t\t}\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\n\t\t\tep->state = WAIT_FOR_SETUP;\n\t\t\tbreak;\n\t\tcase STATUS_STAGE_TEST:\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\n\t\t\tep->state = WAIT_FOR_SETUP;\n\t\t\tif (do_test_mode(udc))\n\t\t\t\tset_protocol_stall(udc, ep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"udc: %s: TXCOMP: Invalid endpoint state %d, \"\n\t\t\t\t\"halting endpoint...\\n\",\n\t\t\t\tep->ep.name, ep->state);\n\t\t\tset_protocol_stall(udc, ep);\n\t\t\tbreak;\n\t\t}\n\n\t\tgoto restart;\n\t}\n\tif ((epstatus & epctrl) & USBA_RX_BK_RDY) {\n\t\tswitch (ep->state) {\n\t\tcase STATUS_STAGE_OUT:\n\t\t\tusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\n\n\t\t\tif (req) {\n\t\t\t\tlist_del_init(&req->queue);\n\t\t\t\trequest_complete(ep, req, 0);\n\t\t\t}\n\t\t\tep->state = WAIT_FOR_SETUP;\n\t\t\tbreak;\n\n\t\tcase DATA_STAGE_OUT:\n\t\t\treceive_data(ep);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\n\t\t\tpr_err(\"udc: %s: RXRDY: Invalid endpoint state %d, \"\n\t\t\t\t\"halting endpoint...\\n\",\n\t\t\t\tep->ep.name, ep->state);\n\t\t\tset_protocol_stall(udc, ep);\n\t\t\tbreak;\n\t\t}\n\n\t\tgoto restart;\n\t}\n\tif (epstatus & USBA_RX_SETUP) {\n\t\tunion {\n\t\t\tstruct usb_ctrlrequest crq;\n\t\t\tunsigned long data[2];\n\t\t} crq;\n\t\tunsigned int pkt_len;\n\t\tint ret;\n\n\t\tif (ep->state != WAIT_FOR_SETUP) {\n\t\t\t \n\t\t\tint status = -EPROTO;\n\n\t\t\t \n\t\t\tif (ep->state == STATUS_STAGE_OUT\n\t\t\t\t\t|| ep->state == STATUS_STAGE_IN) {\n\t\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\n\t\t\t\tstatus = 0;\n\t\t\t}\n\n\t\t\tif (req) {\n\t\t\t\tlist_del_init(&req->queue);\n\t\t\t\trequest_complete(ep, req, status);\n\t\t\t}\n\t\t}\n\n\t\tpkt_len = USBA_BFEXT(BYTE_COUNT, usba_ep_readl(ep, STA));\n\t\tDBG(DBG_HW, \"Packet length: %u\\n\", pkt_len);\n\t\tif (pkt_len != sizeof(crq)) {\n\t\t\tpr_warn(\"udc: Invalid packet length %u (expected %zu)\\n\",\n\t\t\t\tpkt_len, sizeof(crq));\n\t\t\tset_protocol_stall(udc, ep);\n\t\t\treturn;\n\t\t}\n\n\t\tDBG(DBG_FIFO, \"Copying ctrl request from 0x%p:\\n\", ep->fifo);\n\t\tmemcpy_fromio(crq.data, ep->fifo, sizeof(crq));\n\n\t\t \n\t\tusba_ep_writel(ep, CLR_STA, USBA_RX_SETUP);\n\n\t\t \n\n\t\tif (crq.crq.bRequestType & USB_DIR_IN) {\n\t\t\t \n\t\t\tep->state = DATA_STAGE_IN;\n\t\t} else {\n\t\t\tif (crq.crq.wLength != cpu_to_le16(0))\n\t\t\t\tep->state = DATA_STAGE_OUT;\n\t\t\telse\n\t\t\t\tep->state = STATUS_STAGE_IN;\n\t\t}\n\n\t\tret = -1;\n\t\tif (ep->index == 0)\n\t\t\tret = handle_ep0_setup(udc, ep, &crq.crq);\n\t\telse {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tret = udc->driver->setup(&udc->gadget, &crq.crq);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\n\t\tDBG(DBG_BUS, \"req %02x.%02x, length %d, state %d, ret %d\\n\",\n\t\t\tcrq.crq.bRequestType, crq.crq.bRequest,\n\t\t\tle16_to_cpu(crq.crq.wLength), ep->state, ret);\n\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tset_protocol_stall(udc, ep);\n\t\t}\n\t}\n}\n\nstatic void usba_ep_irq(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tstruct usba_request *req;\n\tu32 epstatus;\n\tu32 epctrl;\n\n\tepstatus = usba_ep_readl(ep, STA);\n\tepctrl = usba_ep_readl(ep, CTL);\n\n\tDBG(DBG_INT, \"%s: interrupt, status: 0x%08x\\n\", ep->ep.name, epstatus);\n\n\twhile ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {\n\t\tDBG(DBG_BUS, \"%s: TX PK ready\\n\", ep->ep.name);\n\n\t\tif (list_empty(&ep->queue)) {\n\t\t\tdev_warn(&udc->pdev->dev, \"ep_irq: queue empty\\n\");\n\t\t\tusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\n\t\t\treturn;\n\t\t}\n\n\t\treq = list_entry(ep->queue.next, struct usba_request, queue);\n\n\t\tif (req->using_dma) {\n\t\t\t \n\t\t\tusba_ep_writel(ep, SET_STA,\n\t\t\t\t\tUSBA_TX_PK_RDY);\n\t\t\tusba_ep_writel(ep, CTL_DIS,\n\t\t\t\t\tUSBA_TX_PK_RDY);\n\t\t\tlist_del_init(&req->queue);\n\t\t\tsubmit_next_request(ep);\n\t\t\trequest_complete(ep, req, 0);\n\t\t} else {\n\t\t\tif (req->submitted)\n\t\t\t\tnext_fifo_transaction(ep, req);\n\t\t\telse\n\t\t\t\tsubmit_request(ep, req);\n\n\t\t\tif (req->last_transaction) {\n\t\t\t\tlist_del_init(&req->queue);\n\t\t\t\tsubmit_next_request(ep);\n\t\t\t\trequest_complete(ep, req, 0);\n\t\t\t}\n\t\t}\n\n\t\tepstatus = usba_ep_readl(ep, STA);\n\t\tepctrl = usba_ep_readl(ep, CTL);\n\t}\n\tif ((epstatus & epctrl) & USBA_RX_BK_RDY) {\n\t\tDBG(DBG_BUS, \"%s: RX data ready\\n\", ep->ep.name);\n\t\treceive_data(ep);\n\t}\n}\n\nstatic void usba_dma_irq(struct usba_udc *udc, struct usba_ep *ep)\n{\n\tstruct usba_request *req;\n\tu32 status, control, pending;\n\n\tstatus = usba_dma_readl(ep, STATUS);\n\tcontrol = usba_dma_readl(ep, CONTROL);\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n\tep->last_dma_status = status;\n#endif\n\tpending = status & control;\n\tDBG(DBG_INT | DBG_DMA, \"dma irq, s/%#08x, c/%#08x\\n\", status, control);\n\n\tif (status & USBA_DMA_CH_EN) {\n\t\tdev_err(&udc->pdev->dev,\n\t\t\t\"DMA_CH_EN is set after transfer is finished!\\n\");\n\t\tdev_err(&udc->pdev->dev,\n\t\t\t\"status=%#08x, pending=%#08x, control=%#08x\\n\",\n\t\t\tstatus, pending, control);\n\n\t\t \n\t}\n\n\tif (list_empty(&ep->queue))\n\t\t \n\t\treturn;\n\n\tif (pending & (USBA_DMA_END_TR_ST | USBA_DMA_END_BUF_ST)) {\n\t\treq = list_entry(ep->queue.next, struct usba_request, queue);\n\t\tusba_update_req(ep, req, status);\n\n\t\tlist_del_init(&req->queue);\n\t\tsubmit_next_request(ep);\n\t\trequest_complete(ep, req, 0);\n\t}\n}\n\nstatic int start_clock(struct usba_udc *udc);\nstatic void stop_clock(struct usba_udc *udc);\n\nstatic irqreturn_t usba_udc_irq(int irq, void *devid)\n{\n\tstruct usba_udc *udc = devid;\n\tu32 status, int_enb;\n\tu32 dma_status;\n\tu32 ep_status;\n\n\tspin_lock(&udc->lock);\n\n\tint_enb = usba_int_enb_get(udc);\n\tstatus = usba_readl(udc, INT_STA) & (int_enb | USBA_HIGH_SPEED);\n\tDBG(DBG_INT, \"irq, status=%#08x\\n\", status);\n\n\tif (status & USBA_DET_SUSPEND) {\n\t\tusba_writel(udc, INT_CLR, USBA_DET_SUSPEND|USBA_WAKE_UP);\n\t\tusba_int_enb_set(udc, USBA_WAKE_UP);\n\t\tusba_int_enb_clear(udc, USBA_DET_SUSPEND);\n\t\tudc->suspended = true;\n\t\ttoggle_bias(udc, 0);\n\t\tudc->bias_pulse_needed = true;\n\t\tstop_clock(udc);\n\t\tDBG(DBG_BUS, \"Suspend detected\\n\");\n\t\tif (udc->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t&& udc->driver && udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tif (status & USBA_WAKE_UP) {\n\t\tstart_clock(udc);\n\t\ttoggle_bias(udc, 1);\n\t\tusba_writel(udc, INT_CLR, USBA_WAKE_UP);\n\t\tDBG(DBG_BUS, \"Wake Up CPU detected\\n\");\n\t}\n\n\tif (status & USBA_END_OF_RESUME) {\n\t\tudc->suspended = false;\n\t\tusba_writel(udc, INT_CLR, USBA_END_OF_RESUME);\n\t\tusba_int_enb_clear(udc, USBA_WAKE_UP);\n\t\tusba_int_enb_set(udc, USBA_DET_SUSPEND);\n\t\tgenerate_bias_pulse(udc);\n\t\tDBG(DBG_BUS, \"Resume detected\\n\");\n\t\tif (udc->gadget.speed != USB_SPEED_UNKNOWN\n\t\t\t\t&& udc->driver && udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tdma_status = USBA_BFEXT(DMA_INT, status);\n\tif (dma_status) {\n\t\tint i;\n\n\t\tusba_int_enb_set(udc, USBA_DET_SUSPEND);\n\n\t\tfor (i = 1; i <= USBA_NR_DMAS; i++)\n\t\t\tif (dma_status & (1 << i))\n\t\t\t\tusba_dma_irq(udc, &udc->usba_ep[i]);\n\t}\n\n\tep_status = USBA_BFEXT(EPT_INT, status);\n\tif (ep_status) {\n\t\tint i;\n\n\t\tusba_int_enb_set(udc, USBA_DET_SUSPEND);\n\n\t\tfor (i = 0; i < udc->num_ep; i++)\n\t\t\tif (ep_status & (1 << i)) {\n\t\t\t\tif (ep_is_control(&udc->usba_ep[i]))\n\t\t\t\t\tusba_control_irq(udc, &udc->usba_ep[i]);\n\t\t\t\telse\n\t\t\t\t\tusba_ep_irq(udc, &udc->usba_ep[i]);\n\t\t\t}\n\t}\n\n\tif (status & USBA_END_OF_RESET) {\n\t\tstruct usba_ep *ep0, *ep;\n\t\tint i;\n\n\t\tusba_writel(udc, INT_CLR,\n\t\t\tUSBA_END_OF_RESET|USBA_END_OF_RESUME\n\t\t\t|USBA_DET_SUSPEND|USBA_WAKE_UP);\n\t\tgenerate_bias_pulse(udc);\n\t\treset_all_endpoints(udc);\n\n\t\tif (udc->gadget.speed != USB_SPEED_UNKNOWN && udc->driver) {\n\t\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\n\t\tif (status & USBA_HIGH_SPEED)\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\telse\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\tDBG(DBG_BUS, \"%s bus reset detected\\n\",\n\t\t    usb_speed_string(udc->gadget.speed));\n\n\t\tep0 = &udc->usba_ep[0];\n\t\tep0->ep.desc = &usba_ep0_desc;\n\t\tep0->state = WAIT_FOR_SETUP;\n\t\tusba_ep_writel(ep0, CFG,\n\t\t\t\t(USBA_BF(EPT_SIZE, EP0_EPT_SIZE)\n\t\t\t\t| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL)\n\t\t\t\t| USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE)));\n\t\tusba_ep_writel(ep0, CTL_ENB,\n\t\t\t\tUSBA_EPT_ENABLE | USBA_RX_SETUP);\n\n\t\t \n\t\tudc->suspended = false;\n\t\tusba_int_enb_clear(udc, USBA_WAKE_UP);\n\n\t\tusba_int_enb_set(udc, USBA_BF(EPT_INT, 1) |\n\t\t\t\t      USBA_DET_SUSPEND | USBA_END_OF_RESUME);\n\n\t\t \n\t\tif (!(usba_ep_readl(ep0, CFG) & USBA_EPT_MAPPED))\n\t\t\tdev_err(&udc->pdev->dev,\n\t\t\t\t\"ODD: EP0 configuration is invalid!\\n\");\n\n\t\t \n\t\tfor (i = 1; i < udc->num_ep; i++) {\n\t\t\tep = &udc->usba_ep[i];\n\t\t\tif (ep->ep.claimed) {\n\t\t\t\tusba_ep_writel(ep, CFG, ep->ept_cfg);\n\t\t\t\tif (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED))\n\t\t\t\t\tdev_err(&udc->pdev->dev,\n\t\t\t\t\t\t\"ODD: EP%d configuration is invalid!\\n\", i);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int start_clock(struct usba_udc *udc)\n{\n\tint ret;\n\n\tif (udc->clocked)\n\t\treturn 0;\n\n\tpm_stay_awake(&udc->pdev->dev);\n\n\tret = clk_prepare_enable(udc->pclk);\n\tif (ret)\n\t\treturn ret;\n\tret = clk_prepare_enable(udc->hclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(udc->pclk);\n\t\treturn ret;\n\t}\n\n\tudc->clocked = true;\n\treturn 0;\n}\n\nstatic void stop_clock(struct usba_udc *udc)\n{\n\tif (!udc->clocked)\n\t\treturn;\n\n\tclk_disable_unprepare(udc->hclk);\n\tclk_disable_unprepare(udc->pclk);\n\n\tudc->clocked = false;\n\n\tpm_relax(&udc->pdev->dev);\n}\n\nstatic int usba_start(struct usba_udc *udc)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = start_clock(udc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (udc->suspended)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\ttoggle_bias(udc, 1);\n\tusba_writel(udc, CTRL, USBA_ENABLE_MASK);\n\t \n\tusba_writel(udc, INT_ENB, 0);\n\tudc->int_enb_cache = 0;\n\tusba_writel(udc, INT_CLR,\n\t\tUSBA_END_OF_RESET|USBA_END_OF_RESUME\n\t\t|USBA_DET_SUSPEND|USBA_WAKE_UP);\n\t \n\tusba_int_enb_set(udc, USBA_END_OF_RESET);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic void usba_stop(struct usba_udc *udc)\n{\n\tunsigned long flags;\n\n\tif (udc->suspended)\n\t\treturn;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\treset_all_endpoints(udc);\n\n\t \n\ttoggle_bias(udc, 0);\n\tusba_writel(udc, CTRL, USBA_DISABLE_MASK);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tstop_clock(udc);\n}\n\nstatic irqreturn_t usba_vbus_irq_thread(int irq, void *devid)\n{\n\tstruct usba_udc *udc = devid;\n\tint vbus;\n\n\t \n\tudelay(10);\n\n\tmutex_lock(&udc->vbus_mutex);\n\n\tvbus = vbus_is_present(udc);\n\tif (vbus != udc->vbus_prev) {\n\t\tif (vbus) {\n\t\t\tusba_start(udc);\n\t\t} else {\n\t\t\tudc->suspended = false;\n\t\t\tif (udc->driver->disconnect)\n\t\t\t\tudc->driver->disconnect(&udc->gadget);\n\n\t\t\tusba_stop(udc);\n\t\t}\n\t\tudc->vbus_prev = vbus;\n\t}\n\n\tmutex_unlock(&udc->vbus_mutex);\n\treturn IRQ_HANDLED;\n}\n\nstatic int atmel_usba_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tctrl = usba_readl(udc, CTRL);\n\tif (is_on)\n\t\tctrl &= ~USBA_DETACH;\n\telse\n\t\tctrl |= USBA_DETACH;\n\tusba_writel(udc, CTRL, ctrl);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int atmel_usba_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tint ret;\n\tstruct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->devstatus = 1 << USB_DEVICE_SELF_POWERED;\n\tudc->driver = driver;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tmutex_lock(&udc->vbus_mutex);\n\n\tif (udc->vbus_pin)\n\t\tenable_irq(gpiod_to_irq(udc->vbus_pin));\n\n\t \n\tudc->vbus_prev = vbus_is_present(udc);\n\tif (udc->vbus_prev) {\n\t\tret = usba_start(udc);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tmutex_unlock(&udc->vbus_mutex);\n\treturn 0;\n\nerr:\n\tif (udc->vbus_pin)\n\t\tdisable_irq(gpiod_to_irq(udc->vbus_pin));\n\n\tmutex_unlock(&udc->vbus_mutex);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\tudc->driver = NULL;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\nstatic int atmel_usba_stop(struct usb_gadget *gadget)\n{\n\tstruct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);\n\n\tif (udc->vbus_pin)\n\t\tdisable_irq(gpiod_to_irq(udc->vbus_pin));\n\n\tudc->suspended = false;\n\tusba_stop(udc);\n\n\tudc->driver = NULL;\n\n\treturn 0;\n}\n\nstatic void at91sam9rl_toggle_bias(struct usba_udc *udc, int is_on)\n{\n\tregmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN,\n\t\t\t   is_on ? AT91_PMC_BIASEN : 0);\n}\n\nstatic void at91sam9g45_pulse_bias(struct usba_udc *udc)\n{\n\tregmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN, 0);\n\tregmap_update_bits(udc->pmc, AT91_CKGR_UCKR, AT91_PMC_BIASEN,\n\t\t\t   AT91_PMC_BIASEN);\n}\n\nstatic const struct usba_udc_errata at91sam9rl_errata = {\n\t.toggle_bias = at91sam9rl_toggle_bias,\n};\n\nstatic const struct usba_udc_errata at91sam9g45_errata = {\n\t.pulse_bias = at91sam9g45_pulse_bias,\n};\n\nstatic const struct usba_ep_config ep_config_sam9[] = {\n\t{ .nr_banks = 1 },\t\t\t\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 3, .can_dma = 1 },\t\t \n\t{ .nr_banks = 3, .can_dma = 1 },\t\t \n\t{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },\t \n};\n\nstatic const struct usba_ep_config ep_config_sama5[] = {\n\t{ .nr_banks = 1 },\t\t\t\t \n\t{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n\t{ .nr_banks = 2, .can_isoc = 1 },\t\t \n};\n\nstatic const struct usba_udc_config udc_at91sam9rl_cfg = {\n\t.errata = &at91sam9rl_errata,\n\t.config = ep_config_sam9,\n\t.num_ep = ARRAY_SIZE(ep_config_sam9),\n\t.ep_prealloc = true,\n};\n\nstatic const struct usba_udc_config udc_at91sam9g45_cfg = {\n\t.errata = &at91sam9g45_errata,\n\t.config = ep_config_sam9,\n\t.num_ep = ARRAY_SIZE(ep_config_sam9),\n\t.ep_prealloc = true,\n};\n\nstatic const struct usba_udc_config udc_sama5d3_cfg = {\n\t.config = ep_config_sama5,\n\t.num_ep = ARRAY_SIZE(ep_config_sama5),\n\t.ep_prealloc = true,\n};\n\nstatic const struct usba_udc_config udc_sam9x60_cfg = {\n\t.num_ep = ARRAY_SIZE(ep_config_sam9),\n\t.config = ep_config_sam9,\n\t.ep_prealloc = false,\n};\n\nstatic const struct of_device_id atmel_udc_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9rl-udc\", .data = &udc_at91sam9rl_cfg },\n\t{ .compatible = \"atmel,at91sam9g45-udc\", .data = &udc_at91sam9g45_cfg },\n\t{ .compatible = \"atmel,sama5d3-udc\", .data = &udc_sama5d3_cfg },\n\t{ .compatible = \"microchip,sam9x60-udc\", .data = &udc_sam9x60_cfg },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_udc_dt_ids);\n\nstatic const struct of_device_id atmel_pmc_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9g45-pmc\" },\n\t{ .compatible = \"atmel,at91sam9rl-pmc\" },\n\t{ .compatible = \"atmel,at91sam9x5-pmc\" },\n\t{   }\n};\n\nstatic struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,\n\t\t\t\t\t\t    struct usba_udc *udc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct of_device_id *match;\n\tstruct device_node *pp;\n\tint i, ret;\n\tstruct usba_ep *eps, *ep;\n\tconst struct usba_udc_config *udc_config;\n\n\tmatch = of_match_node(atmel_udc_dt_ids, np);\n\tif (!match)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tudc_config = match->data;\n\tudc->ep_prealloc = udc_config->ep_prealloc;\n\tudc->errata = udc_config->errata;\n\tif (udc->errata) {\n\t\tpp = of_find_matching_node_and_match(NULL, atmel_pmc_dt_ids,\n\t\t\t\t\t\t     NULL);\n\t\tif (!pp)\n\t\t\treturn ERR_PTR(-ENODEV);\n\n\t\tudc->pmc = syscon_node_to_regmap(pp);\n\t\tof_node_put(pp);\n\t\tif (IS_ERR(udc->pmc))\n\t\t\treturn ERR_CAST(udc->pmc);\n\t}\n\n\tudc->num_ep = 0;\n\n\tudc->vbus_pin = devm_gpiod_get_optional(&pdev->dev, \"atmel,vbus\",\n\t\t\t\t\t\tGPIOD_IN);\n\tif (IS_ERR(udc->vbus_pin))\n\t\treturn ERR_CAST(udc->vbus_pin);\n\n\tif (fifo_mode == 0) {\n\t\tudc->num_ep = udc_config->num_ep;\n\t} else {\n\t\tudc->num_ep = usba_config_fifo_table(udc);\n\t}\n\n\teps = devm_kcalloc(&pdev->dev, udc->num_ep, sizeof(struct usba_ep),\n\t\t\t   GFP_KERNEL);\n\tif (!eps)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tudc->gadget.ep0 = &eps[0].ep;\n\n\tINIT_LIST_HEAD(&eps[0].ep.ep_list);\n\n\ti = 0;\n\twhile (i < udc->num_ep) {\n\t\tconst struct usba_ep_config *ep_cfg = &udc_config->config[i];\n\n\t\tep = &eps[i];\n\n\t\tep->index = fifo_mode ? udc->fifo_cfg[i].hw_ep_num : i;\n\n\t\t \n\t\tif (ep->index == 0)\n\t\t\tep->fifo_size = 64;\n\t\telse\n\t\t\tep->fifo_size = 1024;\n\n\t\tif (fifo_mode) {\n\t\t\tif (ep->fifo_size < udc->fifo_cfg[i].fifo_size)\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"Using default max fifo-size value\\n\");\n\t\t\telse\n\t\t\t\tep->fifo_size = udc->fifo_cfg[i].fifo_size;\n\t\t}\n\n\t\tep->nr_banks = ep_cfg->nr_banks;\n\t\tif (fifo_mode) {\n\t\t\tif (ep->nr_banks < udc->fifo_cfg[i].nr_banks)\n\t\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t\t \"Using default max nb-banks value\\n\");\n\t\t\telse\n\t\t\t\tep->nr_banks = udc->fifo_cfg[i].nr_banks;\n\t\t}\n\n\t\tep->can_dma = ep_cfg->can_dma;\n\t\tep->can_isoc = ep_cfg->can_isoc;\n\n\t\tsprintf(ep->name, \"ep%d\", ep->index);\n\t\tep->ep.name = ep->name;\n\n\t\tep->ep_regs = udc->regs + USBA_EPT_BASE(i);\n\t\tep->dma_regs = udc->regs + USBA_DMA_BASE(i);\n\t\tep->fifo = udc->fifo + USBA_FIFO_BASE(i);\n\t\tep->ep.ops = &usba_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ep->fifo_size);\n\t\tep->udc = udc;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\n\t\tif (ep->index == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = ep->can_isoc;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\n\t\tif (fifo_mode != 0) {\n\t\t\t \n\t\t\tif (ep->fifo_size  <= 8)\n\t\t\t\tep->ept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tep->ept_cfg =\n\t\t\t\t  USBA_BF(EPT_SIZE, fls(ep->fifo_size - 1) - 3);\n\n\t\t\tep->ept_cfg |= USBA_BF(BK_NUMBER, ep->nr_banks);\n\t\t}\n\n\t\tif (i)\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\n\t\ti++;\n\t}\n\n\tif (i == 0) {\n\t\tdev_err(&pdev->dev, \"of_probe: no endpoint specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn eps;\nerr:\n\treturn ERR_PTR(ret);\n}\n\nstatic int usba_udc_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct clk *pclk, *hclk;\n\tstruct usba_udc *udc;\n\tint irq, ret, i;\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tudc->gadget = usba_gadget_template;\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\tudc->regs = devm_platform_get_and_ioremap_resource(pdev, CTRL_IOMEM_ID, &res);\n\tif (IS_ERR(udc->regs))\n\t\treturn PTR_ERR(udc->regs);\n\tdev_info(&pdev->dev, \"MMIO registers at %pR mapped at %p\\n\",\n\t\t res, udc->regs);\n\n\tudc->fifo = devm_platform_get_and_ioremap_resource(pdev, FIFO_IOMEM_ID, &res);\n\tif (IS_ERR(udc->fifo))\n\t\treturn PTR_ERR(udc->fifo);\n\tdev_info(&pdev->dev, \"FIFO at %pR mapped at %p\\n\", res, udc->fifo);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(pclk))\n\t\treturn PTR_ERR(pclk);\n\thclk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(hclk))\n\t\treturn PTR_ERR(hclk);\n\n\tspin_lock_init(&udc->lock);\n\tmutex_init(&udc->vbus_mutex);\n\tudc->pdev = pdev;\n\tudc->pclk = pclk;\n\tudc->hclk = hclk;\n\n\tplatform_set_drvdata(pdev, udc);\n\n\t \n\tret = clk_prepare_enable(pclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable pclk, aborting.\\n\");\n\t\treturn ret;\n\t}\n\n\tusba_writel(udc, CTRL, USBA_DISABLE_MASK);\n\tclk_disable_unprepare(pclk);\n\n\tudc->usba_ep = atmel_udc_of_init(pdev, udc);\n\n\ttoggle_bias(udc, 0);\n\n\tif (IS_ERR(udc->usba_ep))\n\t\treturn PTR_ERR(udc->usba_ep);\n\n\tret = devm_request_irq(&pdev->dev, irq, usba_udc_irq, 0,\n\t\t\t\t\"atmel_usba_udc\", udc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot request irq %d (error %d)\\n\",\n\t\t\tirq, ret);\n\t\treturn ret;\n\t}\n\tudc->irq = irq;\n\n\tif (udc->vbus_pin) {\n\t\tirq_set_status_flags(gpiod_to_irq(udc->vbus_pin), IRQ_NOAUTOEN);\n\t\tret = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\tgpiod_to_irq(udc->vbus_pin), NULL,\n\t\t\t\tusba_vbus_irq_thread, USBA_VBUS_IRQFLAGS,\n\t\t\t\t\"atmel_usba_udc\", udc);\n\t\tif (ret) {\n\t\t\tudc->vbus_pin = NULL;\n\t\t\tdev_warn(&udc->pdev->dev,\n\t\t\t\t \"failed to request vbus irq; \"\n\t\t\t\t \"assuming always on\\n\");\n\t\t}\n\t}\n\n\tret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (ret)\n\t\treturn ret;\n\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tusba_init_debugfs(udc);\n\tfor (i = 1; i < udc->num_ep; i++)\n\t\tusba_ep_init_debugfs(udc, &udc->usba_ep[i]);\n\n\treturn 0;\n}\n\nstatic void usba_udc_remove(struct platform_device *pdev)\n{\n\tstruct usba_udc *udc;\n\tint i;\n\n\tudc = platform_get_drvdata(pdev);\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tfor (i = 1; i < udc->num_ep; i++)\n\t\tusba_ep_cleanup_debugfs(&udc->usba_ep[i]);\n\tusba_cleanup_debugfs(udc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int usba_udc_suspend(struct device *dev)\n{\n\tstruct usba_udc *udc = dev_get_drvdata(dev);\n\n\t \n\tif (!udc->driver)\n\t\treturn 0;\n\n\tmutex_lock(&udc->vbus_mutex);\n\n\tif (!device_may_wakeup(dev)) {\n\t\tudc->suspended = false;\n\t\tusba_stop(udc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (udc->vbus_pin) {\n\t\t \n\t\tusba_stop(udc);\n\t\tenable_irq_wake(gpiod_to_irq(udc->vbus_pin));\n\t}\n\n\tenable_irq_wake(udc->irq);\n\nout:\n\tmutex_unlock(&udc->vbus_mutex);\n\treturn 0;\n}\n\nstatic int usba_udc_resume(struct device *dev)\n{\n\tstruct usba_udc *udc = dev_get_drvdata(dev);\n\n\t \n\tif (!udc->driver)\n\t\treturn 0;\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (udc->vbus_pin)\n\t\t\tdisable_irq_wake(gpiod_to_irq(udc->vbus_pin));\n\n\t\tdisable_irq_wake(udc->irq);\n\t}\n\n\t \n\tmutex_lock(&udc->vbus_mutex);\n\tudc->vbus_prev = vbus_is_present(udc);\n\tif (udc->vbus_prev)\n\t\tusba_start(udc);\n\tmutex_unlock(&udc->vbus_mutex);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(usba_udc_pm_ops, usba_udc_suspend, usba_udc_resume);\n\nstatic struct platform_driver udc_driver = {\n\t.probe\t\t= usba_udc_probe,\n\t.remove_new\t= usba_udc_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"atmel_usba_udc\",\n\t\t.pm\t\t= &usba_udc_pm_ops,\n\t\t.of_match_table\t= atmel_udc_dt_ids,\n\t},\n};\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(\"Atmel USBA UDC driver\");\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:atmel_usba_udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}