{
  "module_name": "net2272.c",
  "hash_id": "adb26edddea6b954fe7df34a07b3092d53daeedf32feb8c38855dc9a9abfa9a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/net2272.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#include \"net2272.h\"\n\n#define DRIVER_DESC \"PLX NET2272 USB Peripheral Controller\"\n\nstatic const char driver_name[] = \"net2272\";\nstatic const char driver_vers[] = \"2006 October 17/mainline\";\nstatic const char driver_desc[] = DRIVER_DESC;\n\nstatic const char ep0name[] = \"ep0\";\nstatic const char * const ep_name[] = {\n\tep0name,\n\t\"ep-a\", \"ep-b\", \"ep-c\",\n};\n\n#ifdef CONFIG_USB_NET2272_DMA\n \nstatic bool use_dma = false;\nmodule_param(use_dma, bool, 0644);\n\n \nstatic ushort dma_ep = 1;\nmodule_param(dma_ep, ushort, 0644);\n\n \nstatic ushort dma_mode = 2;\nmodule_param(dma_mode, ushort, 0644);\n#else\n#define use_dma 0\n#define dma_ep 1\n#define dma_mode 2\n#endif\n\n \nstatic ushort fifo_mode;\nmodule_param(fifo_mode, ushort, 0644);\n\n \nstatic ushort enable_suspend;\nmodule_param(enable_suspend, ushort, 0644);\n\nstatic void assert_out_naking(struct net2272_ep *ep, const char *where)\n{\n\tu8 tmp;\n\n#ifndef DEBUG\n\treturn;\n#endif\n\n\ttmp = net2272_ep_read(ep, EP_STAT0);\n\tif ((tmp & (1 << NAK_OUT_PACKETS)) == 0) {\n\t\tdev_dbg(ep->dev->dev, \"%s %s %02x !NAK\\n\",\n\t\t\tep->ep.name, where, tmp);\n\t\tnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\n\t}\n}\n#define ASSERT_OUT_NAKING(ep) assert_out_naking(ep, __func__)\n\nstatic void stop_out_naking(struct net2272_ep *ep)\n{\n\tu8 tmp = net2272_ep_read(ep, EP_STAT0);\n\n\tif ((tmp & (1 << NAK_OUT_PACKETS)) != 0)\n\t\tnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\n}\n\n#define PIPEDIR(bAddress) (usb_pipein(bAddress) ? \"in\" : \"out\")\n\nstatic char *type_string(u8 bmAttributes)\n{\n\tswitch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_BULK: return \"bulk\";\n\tcase USB_ENDPOINT_XFER_ISOC: return \"iso\";\n\tcase USB_ENDPOINT_XFER_INT:  return \"intr\";\n\tdefault:                     return \"control\";\n\t}\n}\n\nstatic char *buf_state_string(unsigned state)\n{\n\tswitch (state) {\n\tcase BUFF_FREE:  return \"free\";\n\tcase BUFF_VALID: return \"valid\";\n\tcase BUFF_LCL:   return \"local\";\n\tcase BUFF_USB:   return \"usb\";\n\tdefault:         return \"unknown\";\n\t}\n}\n\nstatic char *dma_mode_string(void)\n{\n\tif (!use_dma)\n\t\treturn \"PIO\";\n\tswitch (dma_mode) {\n\tcase 0:  return \"SLOW DREQ\";\n\tcase 1:  return \"FAST DREQ\";\n\tcase 2:  return \"BURST\";\n\tdefault: return \"invalid\";\n\t}\n}\n\nstatic void net2272_dequeue_all(struct net2272_ep *);\nstatic int net2272_kick_dma(struct net2272_ep *, struct net2272_request *);\nstatic int net2272_fifo_status(struct usb_ep *);\n\nstatic const struct usb_ep_ops net2272_ep_ops;\n\n \n\nstatic int\nnet2272_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\n{\n\tstruct net2272 *dev;\n\tstruct net2272_ep *ep;\n\tu32 max;\n\tu8 tmp;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || !desc || ep->desc || _ep->name == ep0name\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tmax = usb_endpoint_maxp(desc);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\t_ep->maxpacket = max;\n\tep->desc = desc;\n\n\t \n\tep->stopped = 0;\n\tep->wedged = 0;\n\n\t \n\tnet2272_ep_write(ep, EP_MAXPKT0, max & 0xff);\n\tnet2272_ep_write(ep, EP_MAXPKT1, (max & 0xff00) >> 8);\n\n\t \n\tnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\n\ttmp = usb_endpoint_type(desc);\n\tif (usb_endpoint_xfer_bulk(desc)) {\n\t\t \n\t\tif ((dev->gadget.speed == USB_SPEED_HIGH && max != 512) ||\n\t\t    (dev->gadget.speed == USB_SPEED_FULL && max > 64)) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\tep->is_iso = usb_endpoint_xfer_isoc(desc) ? 1 : 0;\n\ttmp <<= ENDPOINT_TYPE;\n\ttmp |= ((desc->bEndpointAddress & 0x0f) << ENDPOINT_NUMBER);\n\ttmp |= usb_endpoint_dir_in(desc) << ENDPOINT_DIRECTION;\n\ttmp |= (1 << ENDPOINT_ENABLE);\n\n\t \n\tep->is_in = usb_endpoint_dir_in(desc);\n\tif (!ep->is_in)\n\t\tnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\n\n\tnet2272_ep_write(ep, EP_CFG, tmp);\n\n\t \n\ttmp = (1 << ep->num) | net2272_read(dev, IRQENB0);\n\tnet2272_write(dev, IRQENB0, tmp);\n\n\ttmp = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\n\t\t| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\n\t\t| net2272_ep_read(ep, EP_IRQENB);\n\tnet2272_ep_write(ep, EP_IRQENB, tmp);\n\n\ttmp = desc->bEndpointAddress;\n\tdev_dbg(dev->dev, \"enabled %s (ep%d%s-%s) max %04x cfg %02x\\n\",\n\t\t_ep->name, tmp & 0x0f, PIPEDIR(tmp),\n\t\ttype_string(desc->bmAttributes), max,\n\t\tnet2272_ep_read(ep, EP_CFG));\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn 0;\n}\n\nstatic void net2272_ep_reset(struct net2272_ep *ep)\n{\n\tu8 tmp;\n\n\tep->desc = NULL;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tusb_ep_set_maxpacket_limit(&ep->ep, ~0);\n\tep->ep.ops = &net2272_ep_ops;\n\n\t \n\tnet2272_ep_write(ep, EP_IRQENB, 0);\n\n\t \n\ttmp = (1 << NAK_OUT_PACKETS_MODE) | (1 << ALT_NAK_OUT_PACKETS);\n\tnet2272_ep_write(ep, EP_RSPSET, tmp);\n\n\ttmp = (1 << INTERRUPT_MODE) | (1 << HIDE_STATUS_PHASE);\n\tif (ep->num != 0)\n\t\ttmp |= (1 << ENDPOINT_TOGGLE) | (1 << ENDPOINT_HALT);\n\n\tnet2272_ep_write(ep, EP_RSPCLR, tmp);\n\n\t \n\tnet2272_ep_write(ep, EP_STAT0,\n\t\t\t  (1 << DATA_IN_TOKEN_INTERRUPT)\n\t\t\t| (1 << DATA_OUT_TOKEN_INTERRUPT)\n\t\t\t| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\n\t\t\t| (1 << DATA_PACKET_RECEIVED_INTERRUPT)\n\t\t\t| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT));\n\n\tnet2272_ep_write(ep, EP_STAT1,\n\t\t\t    (1 << TIMEOUT)\n\t\t\t  | (1 << USB_OUT_ACK_SENT)\n\t\t\t  | (1 << USB_OUT_NAK_SENT)\n\t\t\t  | (1 << USB_IN_ACK_RCVD)\n\t\t\t  | (1 << USB_IN_NAK_SENT)\n\t\t\t  | (1 << USB_STALL_SENT)\n\t\t\t  | (1 << LOCAL_OUT_ZLP)\n\t\t\t  | (1 << BUFFER_FLUSH));\n\n\t \n}\n\nstatic int net2272_disable(struct usb_ep *_ep)\n{\n\tstruct net2272_ep *ep;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || !ep->desc || _ep->name == ep0name)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tnet2272_dequeue_all(ep);\n\tnet2272_ep_reset(ep);\n\n\tdev_vdbg(ep->dev->dev, \"disabled %s\\n\", _ep->name);\n\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic struct usb_request *\nnet2272_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct net2272_request *req;\n\n\tif (!_ep)\n\t\treturn NULL;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void\nnet2272_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct net2272_request *req;\n\n\tif (!_ep || !_req)\n\t\treturn;\n\n\treq = container_of(_req, struct net2272_request, req);\n\tWARN_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\nstatic void\nnet2272_done(struct net2272_ep *ep, struct net2272_request *req, int status)\n{\n\tstruct net2272 *dev;\n\tunsigned stopped = ep->stopped;\n\n\tif (ep->num == 0) {\n\t\tif (ep->dev->protocol_stall) {\n\t\t\tep->stopped = 1;\n\t\t\tset_halt(ep);\n\t\t}\n\t\tallow_status(ep);\n\t}\n\n\tlist_del_init(&req->queue);\n\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tdev = ep->dev;\n\tif (use_dma && ep->dma)\n\t\tusb_gadget_unmap_request(&dev->gadget, &req->req,\n\t\t\t\tep->is_in);\n\n\tif (status && status != -ESHUTDOWN)\n\t\tdev_vdbg(dev->dev, \"complete %s req %p stat %d len %u/%u buf %p\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length, req->req.buf);\n\n\t \n\tep->stopped = 1;\n\tspin_unlock(&dev->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&dev->lock);\n\tep->stopped = stopped;\n}\n\nstatic int\nnet2272_write_packet(struct net2272_ep *ep, u8 *buf,\n\tstruct net2272_request *req, unsigned max)\n{\n\tu16 __iomem *ep_data = net2272_reg_addr(ep->dev, EP_DATA);\n\tu16 *bufp;\n\tunsigned length, count;\n\tu8 tmp;\n\n\tlength = min(req->req.length - req->req.actual, max);\n\treq->req.actual += length;\n\n\tdev_vdbg(ep->dev->dev, \"write packet %s req %p max %u len %u avail %u\\n\",\n\t\tep->ep.name, req, max, length,\n\t\t(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0));\n\n\tcount = length;\n\tbufp = (u16 *)buf;\n\n\twhile (likely(count >= 2)) {\n\t\t \n\t\twritew(*bufp++, ep_data);\n\t\tcount -= 2;\n\t}\n\tbuf = (u8 *)bufp;\n\n\t \n\tif (unlikely(count)) {\n\t\ttmp = net2272_read(ep->dev, LOCCTL);\n\t\tnet2272_write(ep->dev, LOCCTL, tmp & ~(1 << DATA_WIDTH));\n\t\twriteb(*buf, ep_data);\n\t\tnet2272_write(ep->dev, LOCCTL, tmp);\n\t}\n\treturn length;\n}\n\n \nstatic int\nnet2272_write_fifo(struct net2272_ep *ep, struct net2272_request *req)\n{\n\tu8 *buf;\n\tunsigned count, max;\n\tint status;\n\n\tdev_vdbg(ep->dev->dev, \"write_fifo %s actual %d len %d\\n\",\n\t\tep->ep.name, req->req.actual, req->req.length);\n\n\t \n top:\n\t \n\tnet2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));\n\twhile (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_FULL))) {\n\t\tbuf = req->req.buf + req->req.actual;\n\t\tprefetch(buf);\n\n\t\t \n\t\tnet2272_ep_read(ep, EP_STAT0);\n\n\t\tmax = (net2272_ep_read(ep, EP_AVAIL1) << 8) |\n\t\t\t(net2272_ep_read(ep, EP_AVAIL0));\n\n\t\tif (max < ep->ep.maxpacket)\n\t\t\tmax = (net2272_ep_read(ep, EP_AVAIL1) << 8)\n\t\t\t\t| (net2272_ep_read(ep, EP_AVAIL0));\n\n\t\tcount = net2272_write_packet(ep, buf, req, max);\n\t\t \n\t\tif (req->req.length == req->req.actual) {\n\t\t\t \n\t\t\tif (count < ep->ep.maxpacket)\n\t\t\t\tset_fifo_bytecount(ep, 0);\n\t\t\tnet2272_done(ep, req, 0);\n\n\t\t\tif (!list_empty(&ep->queue)) {\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\t\tstruct net2272_request,\n\t\t\t\t\t\tqueue);\n\t\t\t\tstatus = net2272_kick_dma(ep, req);\n\n\t\t\t\tif (status < 0)\n\t\t\t\t\tif ((net2272_ep_read(ep, EP_STAT0)\n\t\t\t\t\t\t\t& (1 << BUFFER_EMPTY)))\n\t\t\t\t\t\tgoto top;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\tnet2272_ep_write(ep, EP_STAT0, (1 << DATA_PACKET_TRANSMITTED_INTERRUPT));\n\t}\n\treturn 0;\n}\n\nstatic void\nnet2272_out_flush(struct net2272_ep *ep)\n{\n\tASSERT_OUT_NAKING(ep);\n\n\tnet2272_ep_write(ep, EP_STAT0, (1 << DATA_OUT_TOKEN_INTERRUPT)\n\t\t\t| (1 << DATA_PACKET_RECEIVED_INTERRUPT));\n\tnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\n}\n\nstatic int\nnet2272_read_packet(struct net2272_ep *ep, u8 *buf,\n\tstruct net2272_request *req, unsigned avail)\n{\n\tu16 __iomem *ep_data = net2272_reg_addr(ep->dev, EP_DATA);\n\tunsigned is_short;\n\tu16 *bufp;\n\n\treq->req.actual += avail;\n\n\tdev_vdbg(ep->dev->dev, \"read packet %s req %p len %u avail %u\\n\",\n\t\tep->ep.name, req, avail,\n\t\t(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0));\n\n\tis_short = (avail < ep->ep.maxpacket);\n\n\tif (unlikely(avail == 0)) {\n\t\t \n\t\t(void)readw(ep_data);\n\t\treturn is_short;\n\t}\n\n\t \n\tif (unlikely(avail % 2))\n\t\tavail++;\n\tbufp = (u16 *)buf;\n\n\tdo {\n\t\t*bufp++ = readw(ep_data);\n\t\tavail -= 2;\n\t} while (avail);\n\n\t \n\tif (net2272_ep_read(ep, EP_STAT0) & (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT))\n\t\tnet2272_ep_read(ep, EP_STAT0);\n\n\treturn is_short;\n}\n\nstatic int\nnet2272_read_fifo(struct net2272_ep *ep, struct net2272_request *req)\n{\n\tu8 *buf;\n\tunsigned is_short;\n\tint count;\n\tint tmp;\n\tint cleanup = 0;\n\n\tdev_vdbg(ep->dev->dev, \"read_fifo %s actual %d len %d\\n\",\n\t\tep->ep.name, req->req.actual, req->req.length);\n\n top:\n\tdo {\n\t\tbuf = req->req.buf + req->req.actual;\n\t\tprefetchw(buf);\n\n\t\tcount = (net2272_ep_read(ep, EP_AVAIL1) << 8)\n\t\t\t| net2272_ep_read(ep, EP_AVAIL0);\n\n\t\tnet2272_ep_write(ep, EP_STAT0,\n\t\t\t(1 << SHORT_PACKET_TRANSFERRED_INTERRUPT) |\n\t\t\t(1 << DATA_PACKET_RECEIVED_INTERRUPT));\n\n\t\ttmp = req->req.length - req->req.actual;\n\n\t\tif (count > tmp) {\n\t\t\tif ((tmp % ep->ep.maxpacket) != 0) {\n\t\t\t\tdev_err(ep->dev->dev,\n\t\t\t\t\t\"%s out fifo %d bytes, expected %d\\n\",\n\t\t\t\t\tep->ep.name, count, tmp);\n\t\t\t\tcleanup = 1;\n\t\t\t}\n\t\t\tcount = (tmp > 0) ? tmp : 0;\n\t\t}\n\n\t\tis_short = net2272_read_packet(ep, buf, req, count);\n\n\t\t \n\t\tif (unlikely(cleanup || is_short ||\n\t\t\t\treq->req.actual == req->req.length)) {\n\n\t\t\tif (cleanup) {\n\t\t\t\tnet2272_out_flush(ep);\n\t\t\t\tnet2272_done(ep, req, -EOVERFLOW);\n\t\t\t} else\n\t\t\t\tnet2272_done(ep, req, 0);\n\n\t\t\t \n\t\t\tif (unlikely(ep->num == 0)) {\n\t\t\t\tnet2272_ep_write(ep, EP_TRANSFER2, 0);\n\t\t\t\tnet2272_ep_write(ep, EP_TRANSFER1, 0);\n\t\t\t\tnet2272_ep_write(ep, EP_TRANSFER0, 0);\n\t\t\t}\n\n\t\t\tif (!list_empty(&ep->queue)) {\n\t\t\t\tint status;\n\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2272_request, queue);\n\t\t\t\tstatus = net2272_kick_dma(ep, req);\n\t\t\t\tif ((status < 0) &&\n\t\t\t\t    !(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_EMPTY)))\n\t\t\t\t\tgoto top;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t} while (!(net2272_ep_read(ep, EP_STAT0) & (1 << BUFFER_EMPTY)));\n\n\treturn 0;\n}\n\nstatic void\nnet2272_pio_advance(struct net2272_ep *ep)\n{\n\tstruct net2272_request *req;\n\n\tif (unlikely(list_empty(&ep->queue)))\n\t\treturn;\n\n\treq = list_entry(ep->queue.next, struct net2272_request, queue);\n\t(ep->is_in ? net2272_write_fifo : net2272_read_fifo)(ep, req);\n}\n\n \nstatic int\nnet2272_request_dma(struct net2272 *dev, unsigned ep, u32 buf,\n\tunsigned len, unsigned dir)\n{\n\tdev_vdbg(dev->dev, \"request_dma ep %d buf %08x len %d dir %d\\n\",\n\t\tep, buf, len, dir);\n\n\t \n\tif (dev->dma_busy)\n\t\treturn -EBUSY;\n\t \n\tif ((dir == 1) && (len > 0x1000000))\n\t\treturn -EINVAL;\n\n\tdev->dma_busy = 1;\n\n\t \n#ifdef CONFIG_USB_PCI\n\t \n\tswitch (dev->dev_id) {\n\tcase PCI_DEVICE_ID_RDK1:\n\t\t \n\t\twritel((1 << LOCAL_BUS_WIDTH) |\n\t\t\t(1 << TA_READY_INPUT_ENABLE) |\n\t\t\t(0 << LOCAL_BURST_ENABLE) |\n\t\t\t(1 << DONE_INTERRUPT_ENABLE) |\n\t\t\t(1 << LOCAL_ADDRESSING_MODE) |\n\t\t\t(1 << DEMAND_MODE) |\n\t\t\t(1 << DMA_EOT_ENABLE) |\n\t\t\t(1 << FAST_SLOW_TERMINATE_MODE_SELECT) |\n\t\t\t(1 << DMA_CHANNEL_INTERRUPT_SELECT),\n\t\t\tdev->rdk1.plx9054_base_addr + DMAMODE0);\n\n\t\twritel(0x100000, dev->rdk1.plx9054_base_addr + DMALADR0);\n\t\twritel(buf, dev->rdk1.plx9054_base_addr + DMAPADR0);\n\t\twritel(len, dev->rdk1.plx9054_base_addr + DMASIZ0);\n\t\twritel((dir << DIRECTION_OF_TRANSFER) |\n\t\t\t(1 << INTERRUPT_AFTER_TERMINAL_COUNT),\n\t\t\tdev->rdk1.plx9054_base_addr + DMADPR0);\n\t\twritel((1 << LOCAL_DMA_CHANNEL_0_INTERRUPT_ENABLE) |\n\t\t\treadl(dev->rdk1.plx9054_base_addr + INTCSR),\n\t\t\tdev->rdk1.plx9054_base_addr + INTCSR);\n\n\t\tbreak;\n\t}\n#endif\n\n\tnet2272_write(dev, DMAREQ,\n\t\t(0 << DMA_BUFFER_VALID) |\n\t\t(1 << DMA_REQUEST_ENABLE) |\n\t\t(1 << DMA_CONTROL_DACK) |\n\t\t(dev->dma_eot_polarity << EOT_POLARITY) |\n\t\t(dev->dma_dack_polarity << DACK_POLARITY) |\n\t\t(dev->dma_dreq_polarity << DREQ_POLARITY) |\n\t\t((ep >> 1) << DMA_ENDPOINT_SELECT));\n\n\t(void) net2272_read(dev, SCRATCH);\n\n\treturn 0;\n}\n\nstatic void\nnet2272_start_dma(struct net2272 *dev)\n{\n\t \n#ifdef CONFIG_USB_PCI\n\tswitch (dev->dev_id) {\n\tcase PCI_DEVICE_ID_RDK1:\n\t\twriteb((1 << CHANNEL_ENABLE) | (1 << CHANNEL_START),\n\t\t\tdev->rdk1.plx9054_base_addr + DMACSR0);\n\t\tbreak;\n\t}\n#endif\n}\n\n \nstatic int\nnet2272_kick_dma(struct net2272_ep *ep, struct net2272_request *req)\n{\n\tunsigned size;\n\tu8 tmp;\n\n\tif (!use_dma || (ep->num < 1) || (ep->num > 2) || !ep->dma)\n\t\treturn -EINVAL;\n\n\t \n\tif (req->req.length & 1)\n\t\treturn -EINVAL;\n\n\tdev_vdbg(ep->dev->dev, \"kick_dma %s req %p dma %08llx\\n\",\n\t\tep->ep.name, req, (unsigned long long) req->req.dma);\n\n\tnet2272_ep_write(ep, EP_RSPSET, 1 << ALT_NAK_OUT_PACKETS);\n\n\t \n\tif (ep->dev->dma_busy)\n\t\treturn -EBUSY;\n\n\t \n\tsize = req->req.length;\n\tsize &= ~1;\n\n\t \n\tif (ep->is_in) {\n\t\t \n\t\tif (net2272_request_dma(ep->dev, ep->num, req->req.dma, size, 0))\n\t\t\t \n\t\t\treturn -EBUSY;\n\t\treq->req.actual += size;\n\n\t \n\t} else {\n\t\ttmp = net2272_ep_read(ep, EP_STAT0);\n\n\t\t \n\t\tif (net2272_request_dma(ep->dev, ep->num, req->req.dma, size, 1))\n\t\t\t \n\t\t\treturn -EBUSY;\n\n\t\tif (!(tmp & (1 << BUFFER_EMPTY)))\n\t\t\tep->not_empty = 1;\n\t\telse\n\t\t\tep->not_empty = 0;\n\n\n\t\t \n\t\tnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\n\n\t\t \n\t\tif (tmp & (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)) {\n\n\t\t\t \n\t\t\tnet2272_write(ep->dev, DMAREQ,\n\t\t\t\t(0 << DMA_BUFFER_VALID) |\n\t\t\t\t(0 << DMA_REQUEST_ENABLE) |\n\t\t\t\t(1 << DMA_CONTROL_DACK) |\n\t\t\t\t(ep->dev->dma_eot_polarity << EOT_POLARITY) |\n\t\t\t\t(ep->dev->dma_dack_polarity << DACK_POLARITY) |\n\t\t\t\t(ep->dev->dma_dreq_polarity << DREQ_POLARITY) |\n\t\t\t\t((ep->num >> 1) << DMA_ENDPOINT_SELECT));\n\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tnet2272_ep_write(ep, EP_IRQENB, 0);\n\n\tnet2272_start_dma(ep->dev);\n\n\treturn 0;\n}\n\nstatic void net2272_cancel_dma(struct net2272 *dev)\n{\n#ifdef CONFIG_USB_PCI\n\tswitch (dev->dev_id) {\n\tcase PCI_DEVICE_ID_RDK1:\n\t\twriteb(0, dev->rdk1.plx9054_base_addr + DMACSR0);\n\t\twriteb(1 << CHANNEL_ABORT, dev->rdk1.plx9054_base_addr + DMACSR0);\n\t\twhile (!(readb(dev->rdk1.plx9054_base_addr + DMACSR0) &\n\t\t         (1 << CHANNEL_DONE)))\n\t\t\tcontinue;\t \n\n\t\t \n\t\twriteb(1 << CHANNEL_CLEAR_INTERRUPT,\n\t\t\tdev->rdk1.plx9054_base_addr + DMACSR0);\n\t\tbreak;\n\t}\n#endif\n\n\tdev->dma_busy = 0;\n}\n\n \n\nstatic int\nnet2272_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct net2272_request *req;\n\tstruct net2272_ep *ep;\n\tstruct net2272 *dev;\n\tunsigned long flags;\n\tint status = -1;\n\tu8 s;\n\n\treq = container_of(_req, struct net2272_request, req);\n\tif (!_req || !_req->complete || !_req->buf\n\t\t\t|| !list_empty(&req->queue))\n\t\treturn -EINVAL;\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0))\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (use_dma && ep->dma) {\n\t\tstatus = usb_gadget_map_request(&dev->gadget, _req,\n\t\t\t\tep->is_in);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tdev_vdbg(dev->dev, \"%s queue req %p, len %d buf %p dma %08llx %s\\n\",\n\t\t_ep->name, _req, _req->length, _req->buf,\n\t\t(unsigned long long) _req->dma, _req->zero ? \"zero\" : \"!zero\");\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\t \n\tif (list_empty(&ep->queue) && !ep->stopped) {\n\t\t \n\t\tif (ep->num == 0 && _req->length == 0) {\n\t\t\tnet2272_done(ep, req, 0);\n\t\t\tdev_vdbg(dev->dev, \"%s status ack\\n\", ep->ep.name);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\ts = net2272_ep_read(ep, EP_STAT0);\n\t\tif (s & (1 << BUFFER_EMPTY)) {\n\t\t\t \n\t\t\tif ((s & (1 << NAK_OUT_PACKETS)) &&\n\t\t\t    net2272_ep_read(ep, EP_STAT1) & (1 << LOCAL_OUT_ZLP)) {\n\t\t\t\tdev_dbg(dev->dev, \"WARNING: returning ZLP short packet termination!\\n\");\n\t\t\t\t \n\t\t\t\tstatus = net2272_read_fifo(ep, req);\n\t\t\t\t \n\t\t\t\tnet2272_ep_write(ep, EP_STAT0, (1 << NAK_OUT_PACKETS));\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tstatus = net2272_kick_dma(ep, req);\n\n\t\tif (status < 0) {\n\t\t\t \n\t\t\tstatus = 0;\n\n\t\t\tif (ep->is_in)\n\t\t\t\tstatus = net2272_write_fifo(ep, req);\n\t\t\telse {\n\t\t\t\ts = net2272_ep_read(ep, EP_STAT0);\n\t\t\t\tif ((s & (1 << BUFFER_EMPTY)) == 0)\n\t\t\t\t\tstatus = net2272_read_fifo(ep, req);\n\t\t\t}\n\n\t\t\tif (unlikely(status != 0)) {\n\t\t\t\tif (status > 0)\n\t\t\t\t\tstatus = 0;\n\t\t\t\treq = NULL;\n\t\t\t}\n\t\t}\n\t}\n\tif (likely(req))\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\tif (likely(!list_empty(&ep->queue)))\n\t\tnet2272_ep_write(ep, EP_RSPCLR, 1 << ALT_NAK_OUT_PACKETS);\n done:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void\nnet2272_dequeue_all(struct net2272_ep *ep)\n{\n\tstruct net2272_request *req;\n\n\t \n\tep->stopped = 1;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct net2272_request,\n\t\t\t\tqueue);\n\t\tnet2272_done(ep, req, -ESHUTDOWN);\n\t}\n}\n\n \nstatic int\nnet2272_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct net2272_ep *ep;\n\tstruct net2272_request *req = NULL, *iter;\n\tunsigned long flags;\n\tint stopped;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0) || !_req)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tstopped = ep->stopped;\n\tep->stopped = 1;\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tep->stopped = stopped;\n\t\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\tdev_dbg(ep->dev->dev, \"unlink (%s) pio\\n\", _ep->name);\n\t\tnet2272_done(ep, req, -ECONNRESET);\n\t}\n\tep->stopped = stopped;\n\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic int\nnet2272_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\n{\n\tstruct net2272_ep *ep;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0))\n\t\treturn -EINVAL;\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\tif (ep->desc   && usb_endpoint_xfer_isoc(ep->desc))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->dev->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\tret = -EAGAIN;\n\telse if (ep->is_in && value && net2272_fifo_status(_ep) != 0)\n\t\tret = -EAGAIN;\n\telse {\n\t\tdev_vdbg(ep->dev->dev, \"%s %s %s\\n\", _ep->name,\n\t\t\tvalue ? \"set\" : \"clear\",\n\t\t\twedged ? \"wedge\" : \"halt\");\n\t\t \n\t\tif (value) {\n\t\t\tif (ep->num == 0)\n\t\t\t\tep->dev->protocol_stall = 1;\n\t\t\telse\n\t\t\t\tset_halt(ep);\n\t\t\tif (wedged)\n\t\t\t\tep->wedged = 1;\n\t\t} else {\n\t\t\tclear_halt(ep);\n\t\t\tep->wedged = 0;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ep->dev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int\nnet2272_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn net2272_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int\nnet2272_set_wedge(struct usb_ep *_ep)\n{\n\tif (!_ep || _ep->name == ep0name)\n\t\treturn -EINVAL;\n\treturn net2272_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic int\nnet2272_fifo_status(struct usb_ep *_ep)\n{\n\tstruct net2272_ep *ep;\n\tu16 avail;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0))\n\t\treturn -ENODEV;\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tavail = net2272_ep_read(ep, EP_AVAIL1) << 8;\n\tavail |= net2272_ep_read(ep, EP_AVAIL0);\n\tif (avail > ep->fifo_size)\n\t\treturn -EOVERFLOW;\n\tif (ep->is_in)\n\t\tavail = ep->fifo_size - avail;\n\treturn avail;\n}\n\nstatic void\nnet2272_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct net2272_ep *ep;\n\n\tep = container_of(_ep, struct net2272_ep, ep);\n\tif (!_ep || (!ep->desc && ep->num != 0))\n\t\treturn;\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn;\n\n\tnet2272_ep_write(ep, EP_STAT1, 1 << BUFFER_FLUSH);\n}\n\nstatic const struct usb_ep_ops net2272_ep_ops = {\n\t.enable        = net2272_enable,\n\t.disable       = net2272_disable,\n\n\t.alloc_request = net2272_alloc_request,\n\t.free_request  = net2272_free_request,\n\n\t.queue         = net2272_queue,\n\t.dequeue       = net2272_dequeue,\n\n\t.set_halt      = net2272_set_halt,\n\t.set_wedge     = net2272_set_wedge,\n\t.fifo_status   = net2272_fifo_status,\n\t.fifo_flush    = net2272_fifo_flush,\n};\n\n \n\nstatic int\nnet2272_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct net2272 *dev;\n\tunsigned long flags;\n\tu16 ret;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct net2272, gadget);\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tret = net2272_read(dev, FRAME1) << 8;\n\tret |= net2272_read(dev, FRAME0);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int\nnet2272_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct net2272 *dev;\n\tu8 tmp;\n\tunsigned long flags;\n\n\tif (!_gadget)\n\t\treturn 0;\n\tdev = container_of(_gadget, struct net2272, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttmp = net2272_read(dev, USBCTL0);\n\tif (tmp & (1 << IO_WAKEUP_ENABLE))\n\t\tnet2272_write(dev, USBCTL1, (1 << GENERATE_RESUME));\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int\nnet2272_set_selfpowered(struct usb_gadget *_gadget, int value)\n{\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\n\t_gadget->is_selfpowered = (value != 0);\n\n\treturn 0;\n}\n\nstatic int\nnet2272_pullup(struct usb_gadget *_gadget, int is_on)\n{\n\tstruct net2272 *dev;\n\tu8 tmp;\n\tunsigned long flags;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct net2272, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\ttmp = net2272_read(dev, USBCTL0);\n\tdev->softconnect = (is_on != 0);\n\tif (is_on)\n\t\ttmp |= (1 << USB_DETECT_ENABLE);\n\telse\n\t\ttmp &= ~(1 << USB_DETECT_ENABLE);\n\tnet2272_write(dev, USBCTL0, tmp);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int net2272_start(struct usb_gadget *_gadget,\n\t\tstruct usb_gadget_driver *driver);\nstatic int net2272_stop(struct usb_gadget *_gadget);\nstatic void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable);\n\nstatic const struct usb_gadget_ops net2272_ops = {\n\t.get_frame\t= net2272_get_frame,\n\t.wakeup\t\t= net2272_wakeup,\n\t.set_selfpowered = net2272_set_selfpowered,\n\t.pullup\t\t= net2272_pullup,\n\t.udc_start\t= net2272_start,\n\t.udc_stop\t= net2272_stop,\n\t.udc_async_callbacks = net2272_async_callbacks,\n};\n\n \n\nstatic ssize_t\nregisters_show(struct device *_dev, struct device_attribute *attr, char *buf)\n{\n\tstruct net2272 *dev;\n\tchar *next;\n\tunsigned size, t;\n\tunsigned long flags;\n\tu8 t1, t2;\n\tint i;\n\tconst char *s;\n\n\tdev = dev_get_drvdata(_dev);\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tt = scnprintf(next, size, \"%s version %s,\"\n\t\t\"chiprev %02x, locctl %02x\\n\"\n\t\t\"irqenb0 %02x irqenb1 %02x \"\n\t\t\"irqstat0 %02x irqstat1 %02x\\n\",\n\t\tdriver_name, driver_vers, dev->chiprev,\n\t\tnet2272_read(dev, LOCCTL),\n\t\tnet2272_read(dev, IRQENB0),\n\t\tnet2272_read(dev, IRQENB1),\n\t\tnet2272_read(dev, IRQSTAT0),\n\t\tnet2272_read(dev, IRQSTAT1));\n\tsize -= t;\n\tnext += t;\n\n\t \n\tt1 = net2272_read(dev, DMAREQ);\n\tt = scnprintf(next, size, \"\\ndmareq %02x: %s %s%s%s%s\\n\",\n\t\tt1, ep_name[(t1 & 0x01) + 1],\n\t\tt1 & (1 << DMA_CONTROL_DACK) ? \"dack \" : \"\",\n\t\tt1 & (1 << DMA_REQUEST_ENABLE) ? \"reqenb \" : \"\",\n\t\tt1 & (1 << DMA_REQUEST) ? \"req \" : \"\",\n\t\tt1 & (1 << DMA_BUFFER_VALID) ? \"valid \" : \"\");\n\tsize -= t;\n\tnext += t;\n\n\t \n\tt1 = net2272_read(dev, USBCTL1);\n\tif (t1 & (1 << VBUS_PIN)) {\n\t\tif (t1 & (1 << USB_HIGH_SPEED))\n\t\t\ts = \"high speed\";\n\t\telse if (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\t\ts = \"powered\";\n\t\telse\n\t\t\ts = \"full speed\";\n\t} else\n\t\ts = \"not attached\";\n\tt = scnprintf(next, size,\n\t\t\"usbctl0 %02x usbctl1 %02x addr 0x%02x (%s)\\n\",\n\t\tnet2272_read(dev, USBCTL0), t1,\n\t\tnet2272_read(dev, OURADDR), s);\n\tsize -= t;\n\tnext += t;\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tstruct net2272_ep *ep;\n\n\t\tep = &dev->ep[i];\n\t\tif (i && !ep->desc)\n\t\t\tcontinue;\n\n\t\tt1 = net2272_ep_read(ep, EP_CFG);\n\t\tt2 = net2272_ep_read(ep, EP_RSPSET);\n\t\tt = scnprintf(next, size,\n\t\t\t\"\\n%s\\tcfg %02x rsp (%02x) %s%s%s%s%s%s%s%s\"\n\t\t\t\"irqenb %02x\\n\",\n\t\t\tep->ep.name, t1, t2,\n\t\t\t(t2 & (1 << ALT_NAK_OUT_PACKETS)) ? \"NAK \" : \"\",\n\t\t\t(t2 & (1 << HIDE_STATUS_PHASE)) ? \"hide \" : \"\",\n\t\t\t(t2 & (1 << AUTOVALIDATE)) ? \"auto \" : \"\",\n\t\t\t(t2 & (1 << INTERRUPT_MODE)) ? \"interrupt \" : \"\",\n\t\t\t(t2 & (1 << CONTROL_STATUS_PHASE_HANDSHAKE)) ? \"status \" : \"\",\n\t\t\t(t2 & (1 << NAK_OUT_PACKETS_MODE)) ? \"NAKmode \" : \"\",\n\t\t\t(t2 & (1 << ENDPOINT_TOGGLE)) ? \"DATA1 \" : \"DATA0 \",\n\t\t\t(t2 & (1 << ENDPOINT_HALT)) ? \"HALT \" : \"\",\n\t\t\tnet2272_ep_read(ep, EP_IRQENB));\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tt = scnprintf(next, size,\n\t\t\t\"\\tstat0 %02x stat1 %02x avail %04x \"\n\t\t\t\"(ep%d%s-%s)%s\\n\",\n\t\t\tnet2272_ep_read(ep, EP_STAT0),\n\t\t\tnet2272_ep_read(ep, EP_STAT1),\n\t\t\t(net2272_ep_read(ep, EP_AVAIL1) << 8) | net2272_ep_read(ep, EP_AVAIL0),\n\t\t\tt1 & 0x0f,\n\t\t\tep->is_in ? \"in\" : \"out\",\n\t\t\ttype_string(t1 >> 5),\n\t\t\tep->stopped ? \"*\" : \"\");\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tt = scnprintf(next, size,\n\t\t\t\"\\tep_transfer %06x\\n\",\n\t\t\t((net2272_ep_read(ep, EP_TRANSFER2) & 0xff) << 16) |\n\t\t\t((net2272_ep_read(ep, EP_TRANSFER1) & 0xff) << 8) |\n\t\t\t((net2272_ep_read(ep, EP_TRANSFER0) & 0xff)));\n\t\tsize -= t;\n\t\tnext += t;\n\n\t\tt1 = net2272_ep_read(ep, EP_BUFF_STATES) & 0x03;\n\t\tt2 = (net2272_ep_read(ep, EP_BUFF_STATES) >> 2) & 0x03;\n\t\tt = scnprintf(next, size,\n\t\t\t\"\\tbuf-a %s buf-b %s\\n\",\n\t\t\tbuf_state_string(t1),\n\t\t\tbuf_state_string(t2));\n\t\tsize -= t;\n\t\tnext += t;\n\t}\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn PAGE_SIZE - size;\n}\nstatic DEVICE_ATTR_RO(registers);\n\n \n\nstatic void\nnet2272_set_fifo_mode(struct net2272 *dev, int mode)\n{\n\tu8 tmp;\n\n\ttmp = net2272_read(dev, LOCCTL) & 0x3f;\n\ttmp |= (mode << 6);\n\tnet2272_write(dev, LOCCTL, tmp);\n\n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\n\t \n\tlist_add_tail(&dev->ep[1].ep.ep_list, &dev->gadget.ep_list);\n\n\tswitch (mode) {\n\tcase 0:\n\t\tlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\n\t\tdev->ep[1].fifo_size = dev->ep[2].fifo_size = 512;\n\t\tbreak;\n\tcase 1:\n\t\tlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\n\t\tdev->ep[1].fifo_size = 1024;\n\t\tdev->ep[2].fifo_size = 512;\n\t\tbreak;\n\tcase 2:\n\t\tlist_add_tail(&dev->ep[2].ep.ep_list, &dev->gadget.ep_list);\n\t\tdev->ep[1].fifo_size = dev->ep[2].fifo_size = 1024;\n\t\tbreak;\n\tcase 3:\n\t\tdev->ep[1].fifo_size = 1024;\n\t\tbreak;\n\t}\n\n\t \n\tlist_add_tail(&dev->ep[3].ep.ep_list, &dev->gadget.ep_list);\n\tdev->ep[3].fifo_size = 512;\n}\n\n \n\nstatic void\nnet2272_usb_reset(struct net2272 *dev)\n{\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tnet2272_cancel_dma(dev);\n\n\tnet2272_write(dev, IRQENB0, 0);\n\tnet2272_write(dev, IRQENB1, 0);\n\n\t \n\tnet2272_write(dev, IRQSTAT0, 0xff);\n\tnet2272_write(dev, IRQSTAT1, ~(1 << SUSPEND_REQUEST_INTERRUPT));\n\n\tnet2272_write(dev, DMAREQ,\n\t\t(0 << DMA_BUFFER_VALID) |\n\t\t(0 << DMA_REQUEST_ENABLE) |\n\t\t(1 << DMA_CONTROL_DACK) |\n\t\t(dev->dma_eot_polarity << EOT_POLARITY) |\n\t\t(dev->dma_dack_polarity << DACK_POLARITY) |\n\t\t(dev->dma_dreq_polarity << DREQ_POLARITY) |\n\t\t((dma_ep >> 1) << DMA_ENDPOINT_SELECT));\n\n\tnet2272_cancel_dma(dev);\n\tnet2272_set_fifo_mode(dev, (fifo_mode <= 3) ? fifo_mode : 0);\n\n\t \n\tnet2272_write(dev, LOCCTL, net2272_read(dev, LOCCTL) | (1 << DATA_WIDTH));\n\tnet2272_write(dev, LOCCTL1, (dma_mode << DMA_MODE));\n}\n\nstatic void\nnet2272_usb_reinit(struct net2272 *dev)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tstruct net2272_ep *ep = &dev->ep[i];\n\n\t\tep->ep.name = ep_name[i];\n\t\tep->dev = dev;\n\t\tep->num = i;\n\t\tep->not_empty = 0;\n\n\t\tif (use_dma && ep->num == dma_ep)\n\t\t\tep->dma = 1;\n\n\t\tif (i > 0 && i <= 3)\n\t\t\tep->fifo_size = 512;\n\t\telse\n\t\t\tep->fifo_size = 64;\n\t\tnet2272_ep_reset(ep);\n\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\tusb_ep_set_maxpacket_limit(&dev->ep[0].ep, 64);\n\n\tdev->gadget.ep0 = &dev->ep[0].ep;\n\tdev->ep[0].stopped = 0;\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n}\n\nstatic void\nnet2272_ep0_start(struct net2272 *dev)\n{\n\tstruct net2272_ep *ep0 = &dev->ep[0];\n\n\tnet2272_ep_write(ep0, EP_RSPSET,\n\t\t(1 << NAK_OUT_PACKETS_MODE) |\n\t\t(1 << ALT_NAK_OUT_PACKETS));\n\tnet2272_ep_write(ep0, EP_RSPCLR,\n\t\t(1 << HIDE_STATUS_PHASE) |\n\t\t(1 << CONTROL_STATUS_PHASE_HANDSHAKE));\n\tnet2272_write(dev, USBCTL0,\n\t\t(dev->softconnect << USB_DETECT_ENABLE) |\n\t\t(1 << USB_ROOT_PORT_WAKEUP_ENABLE) |\n\t\t(1 << IO_WAKEUP_ENABLE));\n\tnet2272_write(dev, IRQENB0,\n\t\t(1 << SETUP_PACKET_INTERRUPT_ENABLE) |\n\t\t(1 << ENDPOINT_0_INTERRUPT_ENABLE) |\n\t\t(1 << DMA_DONE_INTERRUPT_ENABLE));\n\tnet2272_write(dev, IRQENB1,\n\t\t(1 << VBUS_INTERRUPT_ENABLE) |\n\t\t(1 << ROOT_PORT_RESET_INTERRUPT_ENABLE) |\n\t\t(1 << SUSPEND_REQUEST_CHANGE_INTERRUPT_ENABLE));\n}\n\n \nstatic int net2272_start(struct usb_gadget *_gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct net2272 *dev;\n\tunsigned i;\n\n\tif (!driver || !driver->setup ||\n\t    driver->max_speed != USB_SPEED_HIGH)\n\t\treturn -EINVAL;\n\n\tdev = container_of(_gadget, struct net2272, gadget);\n\n\tfor (i = 0; i < 4; ++i)\n\t\tdev->ep[i].irqs = 0;\n\t \n\tdev->softconnect = 1;\n\tdev->driver = driver;\n\n\t \n\tnet2272_ep0_start(dev);\n\n\treturn 0;\n}\n\nstatic void\nstop_activity(struct net2272 *dev, struct usb_gadget_driver *driver)\n{\n\tint i;\n\n\t \n\tif (dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\n\t \n\tnet2272_usb_reset(dev);\n\tfor (i = 0; i < 4; ++i)\n\t\tnet2272_dequeue_all(&dev->ep[i]);\n\n\t \n\tif (dev->async_callbacks && driver) {\n\t\tspin_unlock(&dev->lock);\n\t\tdriver->disconnect(&dev->gadget);\n\t\tspin_lock(&dev->lock);\n\t}\n\n\tnet2272_usb_reinit(dev);\n}\n\nstatic int net2272_stop(struct usb_gadget *_gadget)\n{\n\tstruct net2272 *dev;\n\tunsigned long flags;\n\n\tdev = container_of(_gadget, struct net2272, gadget);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tstop_activity(dev, NULL);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tdev->driver = NULL;\n\n\treturn 0;\n}\n\nstatic void net2272_async_callbacks(struct usb_gadget *_gadget, bool enable)\n{\n\tstruct net2272\t*dev = container_of(_gadget, struct net2272, gadget);\n\n\tspin_lock_irq(&dev->lock);\n\tdev->async_callbacks = enable;\n\tspin_unlock_irq(&dev->lock);\n}\n\n \n \nstatic void\nnet2272_handle_dma(struct net2272_ep *ep)\n{\n\tstruct net2272_request *req;\n\tunsigned len;\n\tint status;\n\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct net2272_request, queue);\n\telse\n\t\treq = NULL;\n\n\tdev_vdbg(ep->dev->dev, \"handle_dma %s req %p\\n\", ep->ep.name, req);\n\n\t \n\tnet2272_write(ep->dev, DMAREQ,\n\t\t(0 << DMA_BUFFER_VALID)\n\t      | (0 << DMA_REQUEST_ENABLE)\n\t      | (1 << DMA_CONTROL_DACK)\n\t      | (ep->dev->dma_eot_polarity << EOT_POLARITY)\n\t      | (ep->dev->dma_dack_polarity << DACK_POLARITY)\n\t      | (ep->dev->dma_dreq_polarity << DREQ_POLARITY)\n\t      | (ep->dma << DMA_ENDPOINT_SELECT));\n\n\tep->dev->dma_busy = 0;\n\n\tnet2272_ep_write(ep, EP_IRQENB,\n\t\t  (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\n\t\t| (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\n\t\t| net2272_ep_read(ep, EP_IRQENB));\n\n\t \n\tif (ep->is_in) {\n\t\t \n\t\tif ((req->req.length % ep->ep.maxpacket != 0) ||\n\t\t\t\treq->req.zero)\n\t\t\tset_fifo_bytecount(ep, 0);\n\n\t\tnet2272_done(ep, req, 0);\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct net2272_request, queue);\n\t\t\tstatus = net2272_kick_dma(ep, req);\n\t\t\tif (status < 0)\n\t\t\t\tnet2272_pio_advance(ep);\n\t\t}\n\n\t \n\t} else {\n\t\t \n\t\tif (net2272_read(ep->dev, IRQSTAT0) &\n\t\t\t\t(1 << DMA_DONE_INTERRUPT)) {\n\t\t\t \n\t\t\tnet2272_cancel_dma(ep->dev);\n\t\t}\n\n\t\t \n\t\tlen = (net2272_ep_read(ep, EP_TRANSFER2) << 16)\n\t\t\t| (net2272_ep_read(ep, EP_TRANSFER1) << 8)\n\t\t\t| (net2272_ep_read(ep, EP_TRANSFER0));\n\n\t\tif (ep->not_empty)\n\t\t\tlen += 4;\n\n\t\treq->req.actual += len;\n\n\t\t \n\t\tnet2272_pio_advance(ep);\n\t}\n}\n\n \n\nstatic void\nnet2272_handle_ep(struct net2272_ep *ep)\n{\n\tstruct net2272_request *req;\n\tu8 stat0, stat1;\n\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct net2272_request, queue);\n\telse\n\t\treq = NULL;\n\n\t \n\tstat0 = net2272_ep_read(ep, EP_STAT0);\n\tstat1 = net2272_ep_read(ep, EP_STAT1);\n\tep->irqs++;\n\n\tdev_vdbg(ep->dev->dev, \"%s ack ep_stat0 %02x, ep_stat1 %02x, req %p\\n\",\n\t\tep->ep.name, stat0, stat1, req ? &req->req : NULL);\n\n\tnet2272_ep_write(ep, EP_STAT0, stat0 &\n\t\t~((1 << NAK_OUT_PACKETS)\n\t\t| (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT)));\n\tnet2272_ep_write(ep, EP_STAT1, stat1);\n\n\t \n\tif (!ep->is_in && (stat0 & (1 << DATA_PACKET_RECEIVED_INTERRUPT)))\n\t\tnet2272_pio_advance(ep);\n\t \n\telse if (stat0 & (1 << DATA_PACKET_TRANSMITTED_INTERRUPT))\n\t\tnet2272_pio_advance(ep);\n}\n\nstatic struct net2272_ep *\nnet2272_get_ep_by_addr(struct net2272 *dev, u16 wIndex)\n{\n\tstruct net2272_ep *ep;\n\n\tif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\n\t\treturn &dev->ep[0];\n\n\tlist_for_each_entry(ep, &dev->gadget.ep_list, ep.ep_list) {\n\t\tu8 bEndpointAddress;\n\n\t\tif (!ep->desc)\n\t\t\tcontinue;\n\t\tbEndpointAddress = ep->desc->bEndpointAddress;\n\t\tif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\n\t\t\tcontinue;\n\t\tif ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n \nstatic const u8 net2272_test_packet[] = {\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\n\t0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,\n\t0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD,\n\t0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFD, 0x7E\n};\n\nstatic void\nnet2272_set_test_mode(struct net2272 *dev, int mode)\n{\n\tint i;\n\n\t \n\tnet2272_write(dev, IRQENB0, 0x00);\n\tnet2272_write(dev, IRQENB1, 0x00);\n\n\t \n\tnet2272_write(dev, XCVRDIAG, 1 << FORCE_HIGH_SPEED);\n\n\tnet2272_write(dev, PAGESEL, 0);\n\tnet2272_write(dev, EP_STAT0, 1 << DATA_PACKET_TRANSMITTED_INTERRUPT);\n\tnet2272_write(dev, EP_RSPCLR,\n\t\t\t  (1 << CONTROL_STATUS_PHASE_HANDSHAKE)\n\t\t\t| (1 << HIDE_STATUS_PHASE));\n\tnet2272_write(dev, EP_CFG, 1 << ENDPOINT_DIRECTION);\n\tnet2272_write(dev, EP_STAT1, 1 << BUFFER_FLUSH);\n\n\t \n\twhile (!(net2272_read(dev, EP_STAT0) &\n\t\t\t\t(1 << DATA_PACKET_TRANSMITTED_INTERRUPT)))\n\t\t;\n\n\t \n\tnet2272_write(dev, USBTEST, mode);\n\n\t \n\tif (mode == USB_TEST_PACKET) {\n\t\t \n\t\tnet2272_write(dev, LOCCTL, net2272_read(dev, LOCCTL) &\n\t\t\t\t~(1 << DATA_WIDTH));\n\n\t\tfor (i = 0; i < sizeof(net2272_test_packet); ++i)\n\t\t\tnet2272_write(dev, EP_DATA, net2272_test_packet[i]);\n\n\t\t \n\t\tnet2272_write(dev, EP_TRANSFER0, 0);\n\t}\n}\n\nstatic void\nnet2272_handle_stat0_irqs(struct net2272 *dev, u8 stat)\n{\n\tstruct net2272_ep *ep;\n\tu8 num, scratch;\n\n\t \n\tif (unlikely(stat & (1 << SETUP_PACKET_INTERRUPT))) {\n\t\tunion {\n\t\t\tu8 raw[8];\n\t\t\tstruct usb_ctrlrequest\tr;\n\t\t} u;\n\t\tint tmp = 0;\n\t\tstruct net2272_request *req;\n\n\t\tif (dev->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\t\tif (net2272_read(dev, USBCTL1) & (1 << USB_HIGH_SPEED))\n\t\t\t\tdev->gadget.speed = USB_SPEED_HIGH;\n\t\t\telse\n\t\t\t\tdev->gadget.speed = USB_SPEED_FULL;\n\t\t\tdev_dbg(dev->dev, \"%s\\n\",\n\t\t\t\tusb_speed_string(dev->gadget.speed));\n\t\t}\n\n\t\tep = &dev->ep[0];\n\t\tep->irqs++;\n\n\t\t \n\t\tstat &= ~(1 << ENDPOINT_0_INTERRUPT);\n\t\twhile (!list_empty(&ep->queue)) {\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct net2272_request, queue);\n\t\t\tnet2272_done(ep, req,\n\t\t\t\t(req->req.actual == req->req.length) ? 0 : -EPROTO);\n\t\t}\n\t\tep->stopped = 0;\n\t\tdev->protocol_stall = 0;\n\t\tnet2272_ep_write(ep, EP_STAT0,\n\t\t\t    (1 << DATA_IN_TOKEN_INTERRUPT)\n\t\t\t  | (1 << DATA_OUT_TOKEN_INTERRUPT)\n\t\t\t  | (1 << DATA_PACKET_TRANSMITTED_INTERRUPT)\n\t\t\t  | (1 << DATA_PACKET_RECEIVED_INTERRUPT)\n\t\t\t  | (1 << SHORT_PACKET_TRANSFERRED_INTERRUPT));\n\t\tnet2272_ep_write(ep, EP_STAT1,\n\t\t\t    (1 << TIMEOUT)\n\t\t\t  | (1 << USB_OUT_ACK_SENT)\n\t\t\t  | (1 << USB_OUT_NAK_SENT)\n\t\t\t  | (1 << USB_IN_ACK_RCVD)\n\t\t\t  | (1 << USB_IN_NAK_SENT)\n\t\t\t  | (1 << USB_STALL_SENT)\n\t\t\t  | (1 << LOCAL_OUT_ZLP));\n\n\t\t \n\t\tnet2272_write(dev, PAGESEL, 0);\n\t\tnet2272_write(dev, EP_TRANSFER2, 0xff);\n\t\tnet2272_write(dev, EP_TRANSFER1, 0xff);\n\t\tnet2272_write(dev, EP_TRANSFER0, 0xff);\n\n\t\tu.raw[0] = net2272_read(dev, SETUP0);\n\t\tu.raw[1] = net2272_read(dev, SETUP1);\n\t\tu.raw[2] = net2272_read(dev, SETUP2);\n\t\tu.raw[3] = net2272_read(dev, SETUP3);\n\t\tu.raw[4] = net2272_read(dev, SETUP4);\n\t\tu.raw[5] = net2272_read(dev, SETUP5);\n\t\tu.raw[6] = net2272_read(dev, SETUP6);\n\t\tu.raw[7] = net2272_read(dev, SETUP7);\n\t\t \n\t\tle16_to_cpus(&u.r.wValue);\n\t\tle16_to_cpus(&u.r.wIndex);\n\t\tle16_to_cpus(&u.r.wLength);\n\n\t\t \n\t\tnet2272_write(dev, IRQSTAT0, 1 << SETUP_PACKET_INTERRUPT);\n\t\tstat ^= (1 << SETUP_PACKET_INTERRUPT);\n\n\t\t \n\t\tep->is_in = (u.r.bRequestType & USB_DIR_IN) != 0;\n\t\tif (ep->is_in) {\n\t\t\tscratch = (1 << DATA_PACKET_TRANSMITTED_INTERRUPT_ENABLE)\n\t\t\t\t| (1 << DATA_OUT_TOKEN_INTERRUPT_ENABLE)\n\t\t\t\t| (1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);\n\t\t\tstop_out_naking(ep);\n\t\t} else\n\t\t\tscratch = (1 << DATA_PACKET_RECEIVED_INTERRUPT_ENABLE)\n\t\t\t\t| (1 << DATA_OUT_TOKEN_INTERRUPT_ENABLE)\n\t\t\t\t| (1 << DATA_IN_TOKEN_INTERRUPT_ENABLE);\n\t\tnet2272_ep_write(ep, EP_IRQENB, scratch);\n\n\t\tif ((u.r.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD)\n\t\t\tgoto delegate;\n\t\tswitch (u.r.bRequest) {\n\t\tcase USB_REQ_GET_STATUS: {\n\t\t\tstruct net2272_ep *e;\n\t\t\tu16 status = 0;\n\n\t\t\tswitch (u.r.bRequestType & USB_RECIP_MASK) {\n\t\t\tcase USB_RECIP_ENDPOINT:\n\t\t\t\te = net2272_get_ep_by_addr(dev, u.r.wIndex);\n\t\t\t\tif (!e || u.r.wLength > 2)\n\t\t\t\t\tgoto do_stall;\n\t\t\t\tif (net2272_ep_read(e, EP_RSPSET) & (1 << ENDPOINT_HALT))\n\t\t\t\t\tstatus = cpu_to_le16(1);\n\t\t\t\telse\n\t\t\t\t\tstatus = cpu_to_le16(0);\n\n\t\t\t\t \n\t\t\t\tnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\n\t\t\t\twritew(status, net2272_reg_addr(dev, EP_DATA));\n\t\t\t\tset_fifo_bytecount(&dev->ep[0], 0);\n\t\t\t\tallow_status(ep);\n\t\t\t\tdev_vdbg(dev->dev, \"%s stat %02x\\n\",\n\t\t\t\t\tep->ep.name, status);\n\t\t\t\tgoto next_endpoints;\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (u.r.wLength > 2)\n\t\t\t\t\tgoto do_stall;\n\t\t\t\tif (dev->gadget.is_selfpowered)\n\t\t\t\t\tstatus = (1 << USB_DEVICE_SELF_POWERED);\n\n\t\t\t\t \n\t\t\t\tnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\n\t\t\t\twritew(status, net2272_reg_addr(dev, EP_DATA));\n\t\t\t\tset_fifo_bytecount(&dev->ep[0], 0);\n\t\t\t\tallow_status(ep);\n\t\t\t\tdev_vdbg(dev->dev, \"device stat %02x\\n\", status);\n\t\t\t\tgoto next_endpoints;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tif (u.r.wLength > 2)\n\t\t\t\t\tgoto do_stall;\n\n\t\t\t\t \n\t\t\t\tnet2272_ep_write(&dev->ep[0], EP_IRQENB, 0);\n\t\t\t\twritew(status, net2272_reg_addr(dev, EP_DATA));\n\t\t\t\tset_fifo_bytecount(&dev->ep[0], 0);\n\t\t\t\tallow_status(ep);\n\t\t\t\tdev_vdbg(dev->dev, \"interface status %02x\\n\", status);\n\t\t\t\tgoto next_endpoints;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\tcase USB_REQ_CLEAR_FEATURE: {\n\t\t\tstruct net2272_ep *e;\n\n\t\t\tif (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (u.r.wValue != USB_ENDPOINT_HALT ||\n\t\t\t    u.r.wLength != 0)\n\t\t\t\tgoto do_stall;\n\t\t\te = net2272_get_ep_by_addr(dev, u.r.wIndex);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall;\n\t\t\tif (e->wedged) {\n\t\t\t\tdev_vdbg(dev->dev, \"%s wedged, halt not cleared\\n\",\n\t\t\t\t\tep->ep.name);\n\t\t\t} else {\n\t\t\t\tdev_vdbg(dev->dev, \"%s clear halt\\n\", ep->ep.name);\n\t\t\t\tclear_halt(e);\n\t\t\t}\n\t\t\tallow_status(ep);\n\t\t\tgoto next_endpoints;\n\t\t}\n\t\tcase USB_REQ_SET_FEATURE: {\n\t\t\tstruct net2272_ep *e;\n\n\t\t\tif (u.r.bRequestType == USB_RECIP_DEVICE) {\n\t\t\t\tif (u.r.wIndex != NORMAL_OPERATION)\n\t\t\t\t\tnet2272_set_test_mode(dev, (u.r.wIndex >> 8));\n\t\t\t\tallow_status(ep);\n\t\t\t\tdev_vdbg(dev->dev, \"test mode: %d\\n\", u.r.wIndex);\n\t\t\t\tgoto next_endpoints;\n\t\t\t} else if (u.r.bRequestType != USB_RECIP_ENDPOINT)\n\t\t\t\tgoto delegate;\n\t\t\tif (u.r.wValue != USB_ENDPOINT_HALT ||\n\t\t\t    u.r.wLength != 0)\n\t\t\t\tgoto do_stall;\n\t\t\te = net2272_get_ep_by_addr(dev, u.r.wIndex);\n\t\t\tif (!e)\n\t\t\t\tgoto do_stall;\n\t\t\tset_halt(e);\n\t\t\tallow_status(ep);\n\t\t\tdev_vdbg(dev->dev, \"%s set halt\\n\", ep->ep.name);\n\t\t\tgoto next_endpoints;\n\t\t}\n\t\tcase USB_REQ_SET_ADDRESS: {\n\t\t\tnet2272_write(dev, OURADDR, u.r.wValue & 0xff);\n\t\t\tallow_status(ep);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n delegate:\n\t\t\tdev_vdbg(dev->dev, \"setup %02x.%02x v%04x i%04x \"\n\t\t\t\t\"ep_cfg %08x\\n\",\n\t\t\t\tu.r.bRequestType, u.r.bRequest,\n\t\t\t\tu.r.wValue, u.r.wIndex,\n\t\t\t\tnet2272_ep_read(ep, EP_CFG));\n\t\t\tif (dev->async_callbacks) {\n\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\ttmp = dev->driver->setup(&dev->gadget, &u.r);\n\t\t\t\tspin_lock(&dev->lock);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (tmp < 0) {\n do_stall:\n\t\t\tdev_vdbg(dev->dev, \"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\tu.r.bRequestType, u.r.bRequest, tmp);\n\t\t\tdev->protocol_stall = 1;\n\t\t}\n\t \n\t} else if (stat & (1 << DMA_DONE_INTERRUPT)) {\n\t\tnet2272_cancel_dma(dev);\n\t\tnet2272_write(dev, IRQSTAT0, 1 << DMA_DONE_INTERRUPT);\n\t\tstat &= ~(1 << DMA_DONE_INTERRUPT);\n\t\tnum = (net2272_read(dev, DMAREQ) & (1 << DMA_ENDPOINT_SELECT))\n\t\t\t? 2 : 1;\n\n\t\tep = &dev->ep[num];\n\t\tnet2272_handle_dma(ep);\n\t}\n\n next_endpoints:\n\t \n\tscratch = stat & 0x0f;\n\tstat &= ~0x0f;\n\tfor (num = 0; scratch; num++) {\n\t\tu8 t;\n\n\t\t \n\t\tt = 1 << num;\n\t\tif ((scratch & t) == 0)\n\t\t\tcontinue;\n\t\tscratch ^= t;\n\n\t\tep = &dev->ep[num];\n\t\tnet2272_handle_ep(ep);\n\t}\n\n\t \n\tstat &= ~(1 << SOF_INTERRUPT);\n\n\tif (stat)\n\t\tdev_dbg(dev->dev, \"unhandled irqstat0 %02x\\n\", stat);\n}\n\nstatic void\nnet2272_handle_stat1_irqs(struct net2272 *dev, u8 stat)\n{\n\tu8 tmp, mask;\n\n\t \n\ttmp = (1 << VBUS_INTERRUPT) | (1 << ROOT_PORT_RESET_INTERRUPT);\n\tmask = (1 << USB_HIGH_SPEED) | (1 << USB_FULL_SPEED);\n\n\tif (stat & tmp) {\n\t\tbool\treset = false;\n\t\tbool\tdisconnect = false;\n\n\t\t \n\t\tnet2272_write(dev, IRQSTAT1, tmp);\n\t\tif (dev->gadget.speed != USB_SPEED_UNKNOWN) {\n\t\t\tif ((stat & (1 << VBUS_INTERRUPT)) &&\n\t\t\t\t\t(net2272_read(dev, USBCTL1) &\n\t\t\t\t\t\t(1 << VBUS_PIN)) == 0) {\n\t\t\t\tdisconnect = true;\n\t\t\t\tdev_dbg(dev->dev, \"disconnect %s\\n\",\n\t\t\t\t\tdev->driver->driver.name);\n\t\t\t} else if ((stat & (1 << ROOT_PORT_RESET_INTERRUPT)) &&\n\t\t\t\t\t(net2272_read(dev, USBCTL1) & mask)\n\t\t\t\t\t\t== 0) {\n\t\t\t\treset = true;\n\t\t\t\tdev_dbg(dev->dev, \"reset %s\\n\",\n\t\t\t\t\tdev->driver->driver.name);\n\t\t\t}\n\n\t\t\tif (disconnect || reset) {\n\t\t\t\tstop_activity(dev, dev->driver);\n\t\t\t\tnet2272_ep0_start(dev);\n\t\t\t\tif (dev->async_callbacks) {\n\t\t\t\t\tspin_unlock(&dev->lock);\n\t\t\t\t\tif (reset)\n\t\t\t\t\t\tusb_gadget_udc_reset(&dev->gadget, dev->driver);\n\t\t\t\t\telse\n\t\t\t\t\t\t(dev->driver->disconnect)(&dev->gadget);\n\t\t\t\t\tspin_lock(&dev->lock);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tstat &= ~tmp;\n\n\t\tif (!stat)\n\t\t\treturn;\n\t}\n\n\ttmp = (1 << SUSPEND_REQUEST_CHANGE_INTERRUPT);\n\tif (stat & tmp) {\n\t\tnet2272_write(dev, IRQSTAT1, tmp);\n\t\tif (stat & (1 << SUSPEND_REQUEST_INTERRUPT)) {\n\t\t\tif (dev->async_callbacks && dev->driver->suspend)\n\t\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\tif (!enable_suspend) {\n\t\t\t\tstat &= ~(1 << SUSPEND_REQUEST_INTERRUPT);\n\t\t\t\tdev_dbg(dev->dev, \"Suspend disabled, ignoring\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (dev->async_callbacks && dev->driver->resume)\n\t\t\t\tdev->driver->resume(&dev->gadget);\n\t\t}\n\t\tstat &= ~tmp;\n\t}\n\n\t \n\tif (stat)\n\t\tnet2272_write(dev, IRQSTAT1, stat);\n\n\t \n\tstat &= ~((1 << CONTROL_STATUS_INTERRUPT)\n\t\t\t| (1 << SUSPEND_REQUEST_INTERRUPT)\n\t\t\t| (1 << RESUME_INTERRUPT));\n\tif (!stat)\n\t\treturn;\n\telse\n\t\tdev_dbg(dev->dev, \"unhandled irqstat1 %02x\\n\", stat);\n}\n\nstatic irqreturn_t net2272_irq(int irq, void *_dev)\n{\n\tstruct net2272 *dev = _dev;\n#if defined(PLX_PCI_RDK) || defined(PLX_PCI_RDK2)\n\tu32 intcsr;\n#endif\n#if defined(PLX_PCI_RDK)\n\tu8 dmareq;\n#endif\n\tspin_lock(&dev->lock);\n#if defined(PLX_PCI_RDK)\n\tintcsr = readl(dev->rdk1.plx9054_base_addr + INTCSR);\n\n\tif ((intcsr & LOCAL_INTERRUPT_TEST) == LOCAL_INTERRUPT_TEST) {\n\t\twritel(intcsr & ~(1 << PCI_INTERRUPT_ENABLE),\n\t\t\t\tdev->rdk1.plx9054_base_addr + INTCSR);\n\t\tnet2272_handle_stat1_irqs(dev, net2272_read(dev, IRQSTAT1));\n\t\tnet2272_handle_stat0_irqs(dev, net2272_read(dev, IRQSTAT0));\n\t\tintcsr = readl(dev->rdk1.plx9054_base_addr + INTCSR);\n\t\twritel(intcsr | (1 << PCI_INTERRUPT_ENABLE),\n\t\t\tdev->rdk1.plx9054_base_addr + INTCSR);\n\t}\n\tif ((intcsr & DMA_CHANNEL_0_TEST) == DMA_CHANNEL_0_TEST) {\n\t\twriteb((1 << CHANNEL_CLEAR_INTERRUPT | (0 << CHANNEL_ENABLE)),\n\t\t\t\tdev->rdk1.plx9054_base_addr + DMACSR0);\n\n\t\tdmareq = net2272_read(dev, DMAREQ);\n\t\tif (dmareq & 0x01)\n\t\t\tnet2272_handle_dma(&dev->ep[2]);\n\t\telse\n\t\t\tnet2272_handle_dma(&dev->ep[1]);\n\t}\n#endif\n#if defined(PLX_PCI_RDK2)\n\t \n\tintcsr = readl(dev->rdk2.fpga_base_addr + RDK2_IRQSTAT);\n\tif (!(intcsr & (1 << NET2272_PCI_IRQ))) {\n\t\tspin_unlock(&dev->lock);\n\t\treturn IRQ_NONE;\n\t}\n\t \n#endif\n\t \n#if !defined(PLX_PCI_RDK)\n\tnet2272_handle_stat1_irqs(dev, net2272_read(dev, IRQSTAT1));\n\tnet2272_handle_stat0_irqs(dev, net2272_read(dev, IRQSTAT0));\n#endif\n\tspin_unlock(&dev->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int net2272_present(struct net2272 *dev)\n{\n\t \n\tunsigned int ii;\n\tu8 val, refval;\n\n\t \n\trefval = net2272_read(dev, SCRATCH);\n\tfor (ii = 0; ii < 0x100; ii += 7) {\n\t\tnet2272_write(dev, SCRATCH, ii);\n\t\tval = net2272_read(dev, SCRATCH);\n\t\tif (val != ii) {\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"%s: write/read SCRATCH register test failed: \"\n\t\t\t\t\"wrote:0x%2.2x, read:0x%2.2x\\n\",\n\t\t\t\t__func__, ii, val);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t \n\tnet2272_write(dev, SCRATCH, refval);\n\n\t \n\trefval = net2272_read(dev, CHIPREV_2272);\n\tfor (ii = 0; ii < 0x100; ii += 7) {\n\t\tnet2272_write(dev, CHIPREV_2272, ii);\n\t\tval = net2272_read(dev, CHIPREV_2272);\n\t\tif (val != refval) {\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"%s: write/read CHIPREV register test failed: \"\n\t\t\t\t\"wrote 0x%2.2x, read:0x%2.2x expected:0x%2.2x\\n\",\n\t\t\t\t__func__, ii, val, refval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tval = net2272_read(dev, CHIPREV_LEGACY);\n\tif (val != NET2270_LEGACY_REV) {\n\t\t \n\t\tdev_dbg(dev->dev,\n\t\t\t\"%s: WARNING: UNEXPECTED NET2272 LEGACY REGISTER VALUE:\\n\"\n\t\t\t\" - CHIPREV_LEGACY: expected 0x%2.2x, got:0x%2.2x. (Not NET2272?)\\n\",\n\t\t\t__func__, NET2270_LEGACY_REV, val);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tval = net2272_read(dev, CHIPREV_2272);\n\tswitch (val) {\n\tcase CHIPREV_NET2272_R1:\n\t\t \n\t\tdev_dbg(dev->dev,\n\t\t\t\"%s: Rev 1 detected: newer silicon recommended for DMA support\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\tcase CHIPREV_NET2272_R1A:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_dbg(dev->dev,\n\t\t\t\"%s: unexpected silicon revision register value: \"\n\t\t\t\" CHIPREV_2272: 0x%2.2x\\n\",\n\t\t\t__func__, val);\n\t\t \n\t}\n\n\t \n\treturn 0;\n}\n\nstatic void\nnet2272_gadget_release(struct device *_dev)\n{\n\tstruct net2272 *dev = container_of(_dev, struct net2272, gadget.dev);\n\n\tkfree(dev);\n}\n\n \n\nstatic void\nnet2272_remove(struct net2272 *dev)\n{\n\tif (dev->added)\n\t\tusb_del_gadget(&dev->gadget);\n\tfree_irq(dev->irq, dev);\n\tiounmap(dev->base_addr);\n\tdevice_remove_file(dev->dev, &dev_attr_registers);\n\n\tdev_info(dev->dev, \"unbind\\n\");\n}\n\nstatic struct net2272 *net2272_probe_init(struct device *dev, unsigned int irq)\n{\n\tstruct net2272 *ret;\n\n\tif (!irq) {\n\t\tdev_dbg(dev, \"No IRQ!\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t \n\tret = kzalloc(sizeof(*ret), GFP_KERNEL);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&ret->lock);\n\tret->irq = irq;\n\tret->dev = dev;\n\tret->gadget.ops = &net2272_ops;\n\tret->gadget.max_speed = USB_SPEED_HIGH;\n\n\t \n\tret->gadget.name = driver_name;\n\tusb_initialize_gadget(dev, &ret->gadget, net2272_gadget_release);\n\n\treturn ret;\n}\n\nstatic int\nnet2272_probe_fin(struct net2272 *dev, unsigned int irqflags)\n{\n\tint ret;\n\n\t \n\tif (net2272_present(dev)) {\n\t\tdev_warn(dev->dev, \"2272 not found!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tnet2272_usb_reset(dev);\n\tnet2272_usb_reinit(dev);\n\n\tret = request_irq(dev->irq, net2272_irq, irqflags, driver_name, dev);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"request interrupt %i failed\\n\", dev->irq);\n\t\tgoto err;\n\t}\n\n\tdev->chiprev = net2272_read(dev, CHIPREV_2272);\n\n\t \n\tdev_info(dev->dev, \"%s\\n\", driver_desc);\n\tdev_info(dev->dev, \"irq %i, mem %p, chip rev %04x, dma %s\\n\",\n\t\tdev->irq, dev->base_addr, dev->chiprev,\n\t\tdma_mode_string());\n\tdev_info(dev->dev, \"version: %s\\n\", driver_vers);\n\n\tret = device_create_file(dev->dev, &dev_attr_registers);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tret = usb_add_gadget(&dev->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\tdev->added = 1;\n\n\treturn 0;\n\nerr_add_udc:\n\tdevice_remove_file(dev->dev, &dev_attr_registers);\n err_irq:\n\tfree_irq(dev->irq, dev);\n err:\n\treturn ret;\n}\n\n#ifdef CONFIG_USB_PCI\n\n \n\nstatic int\nnet2272_rdk1_probe(struct pci_dev *pdev, struct net2272 *dev)\n{\n\tunsigned long resource, len, tmp;\n\tvoid __iomem *mem_mapped_addr[4];\n\tint ret, i;\n\n\t \n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tif (i == 1)\n\t\t\tcontinue;\t \n\n\t\tresource = pci_resource_start(pdev, i);\n\t\tlen = pci_resource_len(pdev, i);\n\n\t\tif (!request_mem_region(resource, len, driver_name)) {\n\t\t\tdev_dbg(dev->dev, \"controller already in use\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmem_mapped_addr[i] = ioremap(resource, len);\n\t\tif (mem_mapped_addr[i] == NULL) {\n\t\t\trelease_mem_region(resource, len);\n\t\t\tdev_dbg(dev->dev, \"can't map memory\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev->rdk1.plx9054_base_addr = mem_mapped_addr[0];\n\tdev->rdk1.epld_base_addr = mem_mapped_addr[2];\n\tdev->base_addr = mem_mapped_addr[3];\n\n\t \n\ttmp = readl(dev->rdk1.plx9054_base_addr + LBRD1);\n\twritel((tmp & ~(3 << MEMORY_SPACE_LOCAL_BUS_WIDTH)) | W16_BIT,\n\t\t\tdev->rdk1.plx9054_base_addr + LBRD1);\n\n\t \n\twritel(readl(dev->rdk1.plx9054_base_addr + INTCSR) |\n\t\t\t(1 << PCI_INTERRUPT_ENABLE) |\n\t\t\t(1 << LOCAL_INTERRUPT_INPUT_ENABLE),\n\t\t\tdev->rdk1.plx9054_base_addr + INTCSR);\n\n\twriteb((1 << CHANNEL_CLEAR_INTERRUPT | (0 << CHANNEL_ENABLE)),\n\t\t\tdev->rdk1.plx9054_base_addr + DMACSR0);\n\n\t \n\twriteb((1 << EPLD_DMA_ENABLE) |\n\t\t(1 << DMA_CTL_DACK) |\n\t\t(1 << DMA_TIMEOUT_ENABLE) |\n\t\t(1 << USER) |\n\t\t(0 << MPX_MODE) |\n\t\t(1 << BUSWIDTH) |\n\t\t(1 << NET2272_RESET),\n\t\tdev->base_addr + EPLD_IO_CONTROL_REGISTER);\n\n\tmb();\n\twriteb(readb(dev->base_addr + EPLD_IO_CONTROL_REGISTER) &\n\t\t~(1 << NET2272_RESET),\n\t\tdev->base_addr + EPLD_IO_CONTROL_REGISTER);\n\tudelay(200);\n\n\treturn 0;\n\n err:\n\twhile (--i >= 0) {\n\t\tif (i == 1)\n\t\t\tcontinue;\t \n\t\tiounmap(mem_mapped_addr[i]);\n\t\trelease_mem_region(pci_resource_start(pdev, i),\n\t\t\tpci_resource_len(pdev, i));\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnet2272_rdk2_probe(struct pci_dev *pdev, struct net2272 *dev)\n{\n\tunsigned long resource, len;\n\tvoid __iomem *mem_mapped_addr[2];\n\tint ret, i;\n\n\t \n\n\t \n\tfor (i = 0; i < 2; ++i) {\n\t\tresource = pci_resource_start(pdev, i);\n\t\tlen = pci_resource_len(pdev, i);\n\n\t\tif (!request_mem_region(resource, len, driver_name)) {\n\t\t\tdev_dbg(dev->dev, \"controller already in use\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmem_mapped_addr[i] = ioremap(resource, len);\n\t\tif (mem_mapped_addr[i] == NULL) {\n\t\t\trelease_mem_region(resource, len);\n\t\t\tdev_dbg(dev->dev, \"can't map memory\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdev->rdk2.fpga_base_addr = mem_mapped_addr[0];\n\tdev->base_addr = mem_mapped_addr[1];\n\n\tmb();\n\t \n\twritel((1 << CHIP_RESET), dev->rdk2.fpga_base_addr + RDK2_LOCCTLRDK);\n\tudelay(200);\n\twritel((1 << BUS_WIDTH), dev->rdk2.fpga_base_addr + RDK2_LOCCTLRDK);\n\t \n\tdev_info(dev->dev, \"RDK2 FPGA version %08x\\n\",\n\t\treadl(dev->rdk2.fpga_base_addr + RDK2_FPGAREV));\n\t \n\twritel((1 << NET2272_PCI_IRQ), dev->rdk2.fpga_base_addr + RDK2_IRQENB);\n\n\treturn 0;\n\n err:\n\twhile (--i >= 0) {\n\t\tiounmap(mem_mapped_addr[i]);\n\t\trelease_mem_region(pci_resource_start(pdev, i),\n\t\t\tpci_resource_len(pdev, i));\n\t}\n\n\treturn ret;\n}\n\nstatic int\nnet2272_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct net2272 *dev;\n\tint ret;\n\n\tdev = net2272_probe_init(&pdev->dev, pdev->irq);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\tdev->dev_id = pdev->device;\n\n\tif (pci_enable_device(pdev) < 0) {\n\t\tret = -ENODEV;\n\t\tgoto err_put;\n\t}\n\n\tpci_set_master(pdev);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_RDK1: ret = net2272_rdk1_probe(pdev, dev); break;\n\tcase PCI_DEVICE_ID_RDK2: ret = net2272_rdk2_probe(pdev, dev); break;\n\tdefault: BUG();\n\t}\n\tif (ret)\n\t\tgoto err_pci;\n\n\tret = net2272_probe_fin(dev, 0);\n\tif (ret)\n\t\tgoto err_pci;\n\n\tpci_set_drvdata(pdev, dev);\n\n\treturn 0;\n\n err_pci:\n\tpci_disable_device(pdev);\n err_put:\n\tusb_put_gadget(&dev->gadget);\n\n\treturn ret;\n}\n\nstatic void\nnet2272_rdk1_remove(struct pci_dev *pdev, struct net2272 *dev)\n{\n\tint i;\n\n\t \n\twritel(readl(dev->rdk1.plx9054_base_addr + INTCSR) &\n\t\t~(1 << PCI_INTERRUPT_ENABLE),\n\t\tdev->rdk1.plx9054_base_addr + INTCSR);\n\n\t \n\tiounmap(dev->rdk1.plx9054_base_addr);\n\tiounmap(dev->rdk1.epld_base_addr);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (i == 1)\n\t\t\tcontinue;\t \n\t\trelease_mem_region(pci_resource_start(pdev, i),\n\t\t\tpci_resource_len(pdev, i));\n\t}\n}\n\nstatic void\nnet2272_rdk2_remove(struct pci_dev *pdev, struct net2272 *dev)\n{\n\tint i;\n\n\t \n\n\t \n\tiounmap(dev->rdk2.fpga_base_addr);\n\n\tfor (i = 0; i < 2; ++i)\n\t\trelease_mem_region(pci_resource_start(pdev, i),\n\t\t\tpci_resource_len(pdev, i));\n}\n\nstatic void\nnet2272_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net2272 *dev = pci_get_drvdata(pdev);\n\n\tnet2272_remove(dev);\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_RDK1: net2272_rdk1_remove(pdev, dev); break;\n\tcase PCI_DEVICE_ID_RDK2: net2272_rdk2_remove(pdev, dev); break;\n\tdefault: BUG();\n\t}\n\n\tpci_disable_device(pdev);\n\n\tusb_put_gadget(&dev->gadget);\n}\n\n \nstatic struct pci_device_id pci_ids[] = {\n\t{\t \n\t\t.class       = ((PCI_CLASS_BRIDGE_OTHER << 8) | 0xfe),\n\t\t.class_mask  = 0,\n\t\t.vendor      = PCI_VENDOR_ID_PLX,\n\t\t.device      = PCI_DEVICE_ID_RDK1,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t},\n\t{\t \n\t\t.class       = ((PCI_CLASS_BRIDGE_OTHER << 8) | 0xfe),\n\t\t.class_mask  = 0,\n\t\t.vendor      = PCI_VENDOR_ID_PLX,\n\t\t.device      = PCI_DEVICE_ID_RDK2,\n\t\t.subvendor   = PCI_ANY_ID,\n\t\t.subdevice   = PCI_ANY_ID,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nstatic struct pci_driver net2272_pci_driver = {\n\t.name     = driver_name,\n\t.id_table = pci_ids,\n\n\t.probe    = net2272_pci_probe,\n\t.remove   = net2272_pci_remove,\n};\n\nstatic int net2272_pci_register(void)\n{\n\treturn pci_register_driver(&net2272_pci_driver);\n}\n\nstatic void net2272_pci_unregister(void)\n{\n\tpci_unregister_driver(&net2272_pci_driver);\n}\n\n#else\nstatic inline int net2272_pci_register(void) { return 0; }\nstatic inline void net2272_pci_unregister(void) { }\n#endif\n\n \n\nstatic int\nnet2272_plat_probe(struct platform_device *pdev)\n{\n\tstruct net2272 *dev;\n\tint ret;\n\tunsigned int irqflags;\n\tresource_size_t base, len;\n\tstruct resource *iomem, *iomem_bus, *irq_res;\n\n\tirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tiomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tiomem_bus = platform_get_resource(pdev, IORESOURCE_BUS, 0);\n\tif (!irq_res || !iomem) {\n\t\tdev_err(&pdev->dev, \"must provide irq/base addr\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = net2272_probe_init(&pdev->dev, irq_res->start);\n\tif (IS_ERR(dev))\n\t\treturn PTR_ERR(dev);\n\n\tirqflags = 0;\n\tif (irq_res->flags & IORESOURCE_IRQ_HIGHEDGE)\n\t\tirqflags |= IRQF_TRIGGER_RISING;\n\tif (irq_res->flags & IORESOURCE_IRQ_LOWEDGE)\n\t\tirqflags |= IRQF_TRIGGER_FALLING;\n\tif (irq_res->flags & IORESOURCE_IRQ_HIGHLEVEL)\n\t\tirqflags |= IRQF_TRIGGER_HIGH;\n\tif (irq_res->flags & IORESOURCE_IRQ_LOWLEVEL)\n\t\tirqflags |= IRQF_TRIGGER_LOW;\n\n\tbase = iomem->start;\n\tlen = resource_size(iomem);\n\tif (iomem_bus)\n\t\tdev->base_shift = iomem_bus->start;\n\n\tif (!request_mem_region(base, len, driver_name)) {\n\t\tdev_dbg(dev->dev, \"get request memory region!\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\tdev->base_addr = ioremap(base, len);\n\tif (!dev->base_addr) {\n\t\tdev_dbg(dev->dev, \"can't map memory\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_req;\n\t}\n\n\tret = net2272_probe_fin(dev, IRQF_TRIGGER_LOW);\n\tif (ret)\n\t\tgoto err_io;\n\n\tplatform_set_drvdata(pdev, dev);\n\tdev_info(&pdev->dev, \"running in 16-bit, %sbyte swap local bus mode\\n\",\n\t\t(net2272_read(dev, LOCCTL) & (1 << BYTE_SWAP)) ? \"\" : \"no \");\n\n\treturn 0;\n\n err_io:\n\tiounmap(dev->base_addr);\n err_req:\n\trelease_mem_region(base, len);\n err:\n\tusb_put_gadget(&dev->gadget);\n\n\treturn ret;\n}\n\nstatic void\nnet2272_plat_remove(struct platform_device *pdev)\n{\n\tstruct net2272 *dev = platform_get_drvdata(pdev);\n\n\tnet2272_remove(dev);\n\n\trelease_mem_region(pdev->resource[0].start,\n\t\tresource_size(&pdev->resource[0]));\n\n\tusb_put_gadget(&dev->gadget);\n}\n\nstatic struct platform_driver net2272_plat_driver = {\n\t.probe   = net2272_plat_probe,\n\t.remove_new = net2272_plat_remove,\n\t.driver  = {\n\t\t.name  = driver_name,\n\t},\n\t \n};\nMODULE_ALIAS(\"platform:net2272\");\n\nstatic int __init net2272_init(void)\n{\n\tint ret;\n\n\tret = net2272_pci_register();\n\tif (ret)\n\t\treturn ret;\n\tret = platform_driver_register(&net2272_plat_driver);\n\tif (ret)\n\t\tgoto err_pci;\n\treturn ret;\n\nerr_pci:\n\tnet2272_pci_unregister();\n\treturn ret;\n}\nmodule_init(net2272_init);\n\nstatic void __exit net2272_cleanup(void)\n{\n\tnet2272_pci_unregister();\n\tplatform_driver_unregister(&net2272_plat_driver);\n}\nmodule_exit(net2272_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"PLX Technology, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}