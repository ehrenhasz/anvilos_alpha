{
  "module_name": "pxa25x_udc.h",
  "hash_id": "13a7f010e01a3a5a7d386772b2202755ed71f19f5cb103fe85cf18e4365429f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/pxa25x_udc.h",
  "human_readable_source": "\n \n\n#ifndef __LINUX_USB_GADGET_PXA25X_H\n#define __LINUX_USB_GADGET_PXA25X_H\n\n#include <linux/types.h>\n\n \n\n \n#define UFNRH_SIR\t(1 << 7)\t \n#define UFNRH_SIM\t(1 << 6)\t \n#define UFNRH_IPE14\t(1 << 5)\t \n#define UFNRH_IPE9\t(1 << 4)\t \n#define UFNRH_IPE4\t(1 << 3)\t \n\n \n#define\tUDCCFR\t\tUDC_RES2\t \n#define UDCCFR_AREN\t(1 << 7)\t \n#define UDCCFR_ACM\t(1 << 2)\t \n\n \n#define\tUDCCFR_MB1\t(0xff & ~(UDCCFR_AREN|UDCCFR_ACM))\n\n \n\nstruct pxa25x_udc;\n\nstruct pxa25x_ep {\n\tstruct usb_ep\t\t\t\tep;\n\tstruct pxa25x_udc\t\t\t*dev;\n\n\tstruct list_head\t\t\tqueue;\n\tunsigned long\t\t\t\tpio_irqs;\n\n\tunsigned short\t\t\t\tfifo_size;\n\tu8\t\t\t\t\tbEndpointAddress;\n\tu8\t\t\t\t\tbmAttributes;\n\n\tunsigned\t\t\t\tstopped : 1;\n\tunsigned\t\t\t\tdma_fixup : 1;\n\n\t \n\tu32\t\t\t\t\tregoff_udccs;\n\tu32\t\t\t\t\tregoff_ubcr;\n\tu32\t\t\t\t\tregoff_uddr;\n};\n\nstruct pxa25x_request {\n\tstruct usb_request\t\t\treq;\n\tstruct list_head\t\t\tqueue;\n};\n\nenum ep0_state {\n\tEP0_IDLE,\n\tEP0_IN_DATA_PHASE,\n\tEP0_OUT_DATA_PHASE,\n\tEP0_END_XFER,\n\tEP0_STALL,\n};\n\n#define EP0_FIFO_SIZE\t((unsigned)16)\n#define BULK_FIFO_SIZE\t((unsigned)64)\n#define ISO_FIFO_SIZE\t((unsigned)256)\n#define INT_FIFO_SIZE\t((unsigned)8)\n\nstruct udc_stats {\n\tstruct ep0stats {\n\t\tunsigned long\t\tops;\n\t\tunsigned long\t\tbytes;\n\t} read, write;\n\tunsigned long\t\t\tirqs;\n};\n\n#ifdef CONFIG_USB_PXA25X_SMALL\n \n#define\tPXA_UDC_NUM_ENDPOINTS\t3\n#endif\n\n#ifndef\tPXA_UDC_NUM_ENDPOINTS\n#define\tPXA_UDC_NUM_ENDPOINTS\t16\n#endif\n\nstruct pxa25x_udc {\n\tstruct usb_gadget\t\t\tgadget;\n\tstruct usb_gadget_driver\t\t*driver;\n\n\tenum ep0_state\t\t\t\tep0state;\n\tstruct udc_stats\t\t\tstats;\n\tunsigned\t\t\t\tgot_irq : 1,\n\t\t\t\t\t\tvbus : 1,\n\t\t\t\t\t\tpullup : 1,\n\t\t\t\t\t\thas_cfr : 1,\n\t\t\t\t\t\treq_pending : 1,\n\t\t\t\t\t\treq_std : 1,\n\t\t\t\t\t\treq_config : 1,\n\t\t\t\t\t\tsuspended : 1,\n\t\t\t\t\t\tactive : 1;\n\n#define start_watchdog(dev) mod_timer(&dev->timer, jiffies + (HZ/200))\n\tstruct timer_list\t\t\ttimer;\n\n\tstruct device\t\t\t\t*dev;\n\tstruct clk\t\t\t\t*clk;\n\tstruct pxa2xx_udc_mach_info\t\t*mach;\n\tstruct usb_phy\t\t\t\t*transceiver;\n\tu64\t\t\t\t\tdma_mask;\n\tstruct pxa25x_ep\t\t\tep [PXA_UDC_NUM_ENDPOINTS];\n\tvoid __iomem\t\t\t\t*regs;\n\tint\t\t\t\t\tusb_irq;\n\tint\t\t\t\t\tusb_disc_irq;\n};\n#define to_pxa25x(g)\t(container_of((g), struct pxa25x_udc, gadget))\n\n \n\nstatic struct pxa25x_udc *the_controller;\n\n \n\n \n#define DBG_NORMAL\t1\t \n#define DBG_VERBOSE\t2\t \n#define DBG_NOISY\t3\t \n#define DBG_VERY_NOISY\t4\t \n\n#define DMSG(stuff...)\tpr_debug(\"udc: \" stuff)\n\n#ifdef DEBUG\n\nstatic const char *state_name[] = {\n\t\"EP0_IDLE\",\n\t\"EP0_IN_DATA_PHASE\", \"EP0_OUT_DATA_PHASE\",\n\t\"EP0_END_XFER\", \"EP0_STALL\"\n};\n\n#ifdef VERBOSE_DEBUG\n#    define UDC_DEBUG DBG_VERBOSE\n#else\n#    define UDC_DEBUG DBG_NORMAL\n#endif\n\nstatic void __maybe_unused\ndump_udccr(const char *label)\n{\n\tu32\tudccr = UDCCR;\n\tDMSG(\"%s %02X =%s%s%s%s%s%s%s%s\\n\",\n\t\tlabel, udccr,\n\t\t(udccr & UDCCR_REM) ? \" rem\" : \"\",\n\t\t(udccr & UDCCR_RSTIR) ? \" rstir\" : \"\",\n\t\t(udccr & UDCCR_SRM) ? \" srm\" : \"\",\n\t\t(udccr & UDCCR_SUSIR) ? \" susir\" : \"\",\n\t\t(udccr & UDCCR_RESIR) ? \" resir\" : \"\",\n\t\t(udccr & UDCCR_RSM) ? \" rsm\" : \"\",\n\t\t(udccr & UDCCR_UDA) ? \" uda\" : \"\",\n\t\t(udccr & UDCCR_UDE) ? \" ude\" : \"\");\n}\n\nstatic void __maybe_unused\ndump_udccs0(const char *label)\n{\n\tu32\t\tudccs0 = UDCCS0;\n\n\tDMSG(\"%s %s %02X =%s%s%s%s%s%s%s%s\\n\",\n\t\tlabel, state_name[the_controller->ep0state], udccs0,\n\t\t(udccs0 & UDCCS0_SA) ? \" sa\" : \"\",\n\t\t(udccs0 & UDCCS0_RNE) ? \" rne\" : \"\",\n\t\t(udccs0 & UDCCS0_FST) ? \" fst\" : \"\",\n\t\t(udccs0 & UDCCS0_SST) ? \" sst\" : \"\",\n\t\t(udccs0 & UDCCS0_DRWF) ? \" dwrf\" : \"\",\n\t\t(udccs0 & UDCCS0_FTF) ? \" ftf\" : \"\",\n\t\t(udccs0 & UDCCS0_IPR) ? \" ipr\" : \"\",\n\t\t(udccs0 & UDCCS0_OPR) ? \" opr\" : \"\");\n}\n\nstatic inline u32 udc_ep_get_UDCCS(struct pxa25x_ep *);\n\nstatic void __maybe_unused\ndump_state(struct pxa25x_udc *dev)\n{\n\tu32\t\ttmp;\n\tunsigned\ti;\n\n\tDMSG(\"%s, uicr %02X.%02X, usir %02X.%02x, ufnr %02X.%02X\\n\",\n\t\tstate_name[dev->ep0state],\n\t\tUICR1, UICR0, USIR1, USIR0, UFNRH, UFNRL);\n\tdump_udccr(\"udccr\");\n\tif (dev->has_cfr) {\n\t\ttmp = UDCCFR;\n\t\tDMSG(\"udccfr %02X =%s%s\\n\", tmp,\n\t\t\t(tmp & UDCCFR_AREN) ? \" aren\" : \"\",\n\t\t\t(tmp & UDCCFR_ACM) ? \" acm\" : \"\");\n\t}\n\n\tif (!dev->driver) {\n\t\tDMSG(\"no gadget driver bound\\n\");\n\t\treturn;\n\t} else\n\t\tDMSG(\"ep0 driver '%s'\\n\", dev->driver->driver.name);\n\n\tdump_udccs0 (\"udccs0\");\n\tDMSG(\"ep0 IN %lu/%lu, OUT %lu/%lu\\n\",\n\t\tdev->stats.write.bytes, dev->stats.write.ops,\n\t\tdev->stats.read.bytes, dev->stats.read.ops);\n\n\tfor (i = 1; i < PXA_UDC_NUM_ENDPOINTS; i++) {\n\t\tif (dev->ep[i].ep.desc == NULL)\n\t\t\tcontinue;\n\t\tDMSG (\"udccs%d = %02x\\n\", i, udc_ep_get_UDCCS(&dev->ep[i]));\n\t}\n}\n\n#else\n\n#define\tdump_udccr(x)\tdo{}while(0)\n#define\tdump_udccs0(x)\tdo{}while(0)\n#define\tdump_state(x)\tdo{}while(0)\n\n#define UDC_DEBUG ((unsigned)0)\n\n#endif\n\n#define DBG(lvl, stuff...) do{if ((lvl) <= UDC_DEBUG) DMSG(stuff);}while(0)\n\n#define ERR(stuff...)\t\tpr_err(\"udc: \" stuff)\n#define WARNING(stuff...)\tpr_warn(\"udc: \" stuff)\n#define INFO(stuff...)\t\tpr_info(\"udc: \" stuff)\n\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}