{
  "module_name": "at91_udc.c",
  "hash_id": "ed9a26d18987ccf5dee1630262241106ee1819aa8d71057b2b9b294da1a61a11",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/at91_udc.c",
  "human_readable_source": "\n \n\n#undef\tVERBOSE_DEBUG\n#undef\tPACKET_TRACE\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/proc_fs.h>\n#include <linux/prefetch.h>\n#include <linux/clk.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_data/atmel.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/syscon/atmel-matrix.h>\n\n#include \"at91_udc.h\"\n\n\n \n\n#define\tDRIVER_VERSION\t\"3 May 2006\"\n\nstatic const char driver_name [] = \"at91_udc\";\n\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} ep_info[] = {\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\n\tEP_INFO(\"ep0\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep1\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep2\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep3-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep4\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep5\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_ALL, USB_EP_CAPS_DIR_ALL)),\n\n#undef EP_INFO\n};\n\n#define ep0name\t\tep_info[0].name\n\n#define VBUS_POLL_TIMEOUT\tmsecs_to_jiffies(1000)\n\n#define at91_udp_read(udc, reg) \\\n\t__raw_readl((udc)->udp_baseaddr + (reg))\n#define at91_udp_write(udc, reg, val) \\\n\t__raw_writel((val), (udc)->udp_baseaddr + (reg))\n\n \n\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\n#include <linux/seq_file.h>\n\nstatic const char debug_filename[] = \"driver/udc\";\n\n#define FOURBITS \"%s%s%s%s\"\n#define EIGHTBITS FOURBITS FOURBITS\n\nstatic void proc_ep_show(struct seq_file *s, struct at91_ep *ep)\n{\n\tstatic char\t\t*types[] = {\n\t\t\"control\", \"out-iso\", \"out-bulk\", \"out-int\",\n\t\t\"BOGUS\",   \"in-iso\",  \"in-bulk\",  \"in-int\"};\n\n\tu32\t\t\tcsr;\n\tstruct at91_request\t*req;\n\tunsigned long\tflags;\n\tstruct at91_udc\t*udc = ep->udc;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcsr = __raw_readl(ep->creg);\n\n\t \n\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"%s, maxpacket %d %s%s %s%s\\n\",\n\t\t\tep->ep.name, ep->ep.maxpacket,\n\t\t\tep->is_in ? \"in\" : \"out\",\n\t\t\tep->is_iso ? \" iso\" : \"\",\n\t\t\tep->is_pingpong\n\t\t\t\t? (ep->fifo_bank ? \"pong\" : \"ping\")\n\t\t\t\t: \"\",\n\t\t\tep->stopped ? \" stopped\" : \"\");\n\tseq_printf(s, \"csr %08x rxbytes=%d %s %s %s\" EIGHTBITS \"\\n\",\n\t\tcsr,\n\t\t(csr & 0x07ff0000) >> 16,\n\t\t(csr & (1 << 15)) ? \"enabled\" : \"disabled\",\n\t\t(csr & (1 << 11)) ? \"DATA1\" : \"DATA0\",\n\t\ttypes[(csr & 0x700) >> 8],\n\n\t\t \n\t\t(!(csr & 0x700))\n\t\t\t? ((csr & (1 << 7)) ? \" IN\" : \" OUT\")\n\t\t\t: \"\",\n\t\t(csr & (1 << 6)) ? \" rxdatabk1\" : \"\",\n\t\t(csr & (1 << 5)) ? \" forcestall\" : \"\",\n\t\t(csr & (1 << 4)) ? \" txpktrdy\" : \"\",\n\n\t\t(csr & (1 << 3)) ? \" stallsent\" : \"\",\n\t\t(csr & (1 << 2)) ? \" rxsetup\" : \"\",\n\t\t(csr & (1 << 1)) ? \" rxdatabk0\" : \"\",\n\t\t(csr & (1 << 0)) ? \" txcomp\" : \"\");\n\tif (list_empty (&ep->queue))\n\t\tseq_printf(s, \"\\t(queue empty)\\n\");\n\n\telse list_for_each_entry (req, &ep->queue, queue) {\n\t\tunsigned\tlength = req->req.actual;\n\n\t\tseq_printf(s, \"\\treq %p len %d/%d buf %p\\n\",\n\t\t\t\t&req->req, length,\n\t\t\t\treq->req.length, req->req.buf);\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic void proc_irq_show(struct seq_file *s, const char *label, u32 mask)\n{\n\tint i;\n\n\tseq_printf(s, \"%s %04x:%s%s\" FOURBITS, label, mask,\n\t\t(mask & (1 << 13)) ? \" wakeup\" : \"\",\n\t\t(mask & (1 << 12)) ? \" endbusres\" : \"\",\n\n\t\t(mask & (1 << 11)) ? \" sofint\" : \"\",\n\t\t(mask & (1 << 10)) ? \" extrsm\" : \"\",\n\t\t(mask & (1 << 9)) ? \" rxrsm\" : \"\",\n\t\t(mask & (1 << 8)) ? \" rxsusp\" : \"\");\n\tfor (i = 0; i < 8; i++) {\n\t\tif (mask & (1 << i))\n\t\t\tseq_printf(s, \" ep%d\", i);\n\t}\n\tseq_printf(s, \"\\n\");\n}\n\nstatic int proc_udc_show(struct seq_file *s, void *unused)\n{\n\tstruct at91_udc\t*udc = s->private;\n\tstruct at91_ep\t*ep;\n\tu32\t\ttmp;\n\n\tseq_printf(s, \"%s: version %s\\n\", driver_name, DRIVER_VERSION);\n\n\tseq_printf(s, \"vbus %s, pullup %s, %s powered%s, gadget %s\\n\\n\",\n\t\tudc->vbus ? \"present\" : \"off\",\n\t\tudc->enabled\n\t\t\t? (udc->vbus ? \"active\" : \"enabled\")\n\t\t\t: \"disabled\",\n\t\tudc->gadget.is_selfpowered ? \"self\" : \"VBUS\",\n\t\tudc->suspended ? \", suspended\" : \"\",\n\t\tudc->driver ? udc->driver->driver.name : \"(none)\");\n\n\t \n\tif (!udc->clocked) {\n\t\tseq_printf(s, \"(not clocked)\\n\");\n\t\treturn 0;\n\t}\n\n\ttmp = at91_udp_read(udc, AT91_UDP_FRM_NUM);\n\tseq_printf(s, \"frame %05x:%s%s frame=%d\\n\", tmp,\n\t\t(tmp & AT91_UDP_FRM_OK) ? \" ok\" : \"\",\n\t\t(tmp & AT91_UDP_FRM_ERR) ? \" err\" : \"\",\n\t\t(tmp & AT91_UDP_NUM));\n\n\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\tseq_printf(s, \"glbstate %02x:%s\" FOURBITS \"\\n\", tmp,\n\t\t(tmp & AT91_UDP_RMWUPE) ? \" rmwupe\" : \"\",\n\t\t(tmp & AT91_UDP_RSMINPR) ? \" rsminpr\" : \"\",\n\t\t(tmp & AT91_UDP_ESR) ? \" esr\" : \"\",\n\t\t(tmp & AT91_UDP_CONFG) ? \" confg\" : \"\",\n\t\t(tmp & AT91_UDP_FADDEN) ? \" fadden\" : \"\");\n\n\ttmp = at91_udp_read(udc, AT91_UDP_FADDR);\n\tseq_printf(s, \"faddr   %03x:%s fadd=%d\\n\", tmp,\n\t\t(tmp & AT91_UDP_FEN) ? \" fen\" : \"\",\n\t\t(tmp & AT91_UDP_FADD));\n\n\tproc_irq_show(s, \"imr   \", at91_udp_read(udc, AT91_UDP_IMR));\n\tproc_irq_show(s, \"isr   \", at91_udp_read(udc, AT91_UDP_ISR));\n\n\tif (udc->enabled && udc->vbus) {\n\t\tproc_ep_show(s, &udc->ep[0]);\n\t\tlist_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\t\tif (ep->ep.desc)\n\t\t\t\tproc_ep_show(s, ep);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void create_debug_file(struct at91_udc *udc)\n{\n\tudc->pde = proc_create_single_data(debug_filename, 0, NULL,\n\t\t\tproc_udc_show, udc);\n}\n\nstatic void remove_debug_file(struct at91_udc *udc)\n{\n\tif (udc->pde)\n\t\tremove_proc_entry(debug_filename, NULL);\n}\n\n#else\n\nstatic inline void create_debug_file(struct at91_udc *udc) {}\nstatic inline void remove_debug_file(struct at91_udc *udc) {}\n\n#endif\n\n\n \n\nstatic void done(struct at91_ep *ep, struct at91_request *req, int status)\n{\n\tunsigned\tstopped = ep->stopped;\n\tstruct at91_udc\t*udc = ep->udc;\n\n\tlist_del_init(&req->queue);\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\tif (status && status != -ESHUTDOWN)\n\t\tVDBG(\"%s done %p, status %d\\n\", ep->ep.name, req, status);\n\n\tep->stopped = 1;\n\tspin_unlock(&udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&udc->lock);\n\tep->stopped = stopped;\n\n\t \n\tif (list_empty(&ep->queue) && ep->int_mask != (1 << 0))\n\t\tat91_udp_write(udc, AT91_UDP_IDR, ep->int_mask);\n}\n\n \n\n \n#define\tRX_DATA_READY\t(AT91_UDP_RX_DATA_BK0 | AT91_UDP_RX_DATA_BK1)\n\n \n#define\tSET_FX\t(AT91_UDP_TXPKTRDY)\n#define\tCLR_FX\t(RX_DATA_READY | AT91_UDP_RXSETUP \\\n\t\t| AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)\n\n \nstatic int read_fifo (struct at91_ep *ep, struct at91_request *req)\n{\n\tu32 __iomem\t*creg = ep->creg;\n\tu8 __iomem\t*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\n\tu32\t\tcsr;\n\tu8\t\t*buf;\n\tunsigned int\tcount, bufferspace, is_done;\n\n\tbuf = req->req.buf + req->req.actual;\n\tbufferspace = req->req.length - req->req.actual;\n\n\t \nrescan:\n\tcsr = __raw_readl(creg);\n\tif ((csr & RX_DATA_READY) == 0)\n\t\treturn 0;\n\n\tcount = (csr & AT91_UDP_RXBYTECNT) >> 16;\n\tif (count > ep->ep.maxpacket)\n\t\tcount = ep->ep.maxpacket;\n\tif (count > bufferspace) {\n\t\tDBG(\"%s buffer overflow\\n\", ep->ep.name);\n\t\treq->req.status = -EOVERFLOW;\n\t\tcount = bufferspace;\n\t}\n\t__raw_readsb(dreg, buf, count);\n\n\t \n\tcsr |= CLR_FX;\n\tif (ep->is_pingpong) {\n\t\tif (ep->fifo_bank == 0) {\n\t\t\tcsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\n\t\t\tep->fifo_bank = 1;\n\t\t} else {\n\t\t\tcsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK1);\n\t\t\tep->fifo_bank = 0;\n\t\t}\n\t} else\n\t\tcsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\n\t__raw_writel(csr, creg);\n\n\treq->req.actual += count;\n\tis_done = (count < ep->ep.maxpacket);\n\tif (count == bufferspace)\n\t\tis_done = 1;\n\n\tPACKET(\"%s %p out/%d%s\\n\", ep->ep.name, &req->req, count,\n\t\t\tis_done ? \" (done)\" : \"\");\n\n\t \n\tif (is_done)\n\t\tdone(ep, req, 0);\n\telse if (ep->is_pingpong) {\n\t\t \n\t\tcsr = __raw_readl(creg);\n\n\t\tbufferspace -= count;\n\t\tbuf += count;\n\t\tgoto rescan;\n\t}\n\n\treturn is_done;\n}\n\n \nstatic int write_fifo(struct at91_ep *ep, struct at91_request *req)\n{\n\tu32 __iomem\t*creg = ep->creg;\n\tu32\t\tcsr = __raw_readl(creg);\n\tu8 __iomem\t*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\n\tunsigned\ttotal, count, is_last;\n\tu8\t\t*buf;\n\n\t \n\n\t \n\tif (unlikely(csr & (AT91_UDP_TXCOMP | AT91_UDP_TXPKTRDY))) {\n\t\tif (csr & AT91_UDP_TXCOMP) {\n\t\t\tcsr |= CLR_FX;\n\t\t\tcsr &= ~(SET_FX | AT91_UDP_TXCOMP);\n\t\t\t__raw_writel(csr, creg);\n\t\t\tcsr = __raw_readl(creg);\n\t\t}\n\t\tif (csr & AT91_UDP_TXPKTRDY)\n\t\t\treturn 0;\n\t}\n\n\tbuf = req->req.buf + req->req.actual;\n\tprefetch(buf);\n\ttotal = req->req.length - req->req.actual;\n\tif (ep->ep.maxpacket < total) {\n\t\tcount = ep->ep.maxpacket;\n\t\tis_last = 0;\n\t} else {\n\t\tcount = total;\n\t\tis_last = (count < ep->ep.maxpacket) || !req->req.zero;\n\t}\n\n\t \n\t__raw_writesb(dreg, buf, count);\n\tcsr &= ~SET_FX;\n\tcsr |= CLR_FX | AT91_UDP_TXPKTRDY;\n\t__raw_writel(csr, creg);\n\treq->req.actual += count;\n\n\tPACKET(\"%s %p in/%d%s\\n\", ep->ep.name, &req->req, count,\n\t\t\tis_last ? \" (done)\" : \"\");\n\tif (is_last)\n\t\tdone(ep, req, 0);\n\treturn is_last;\n}\n\nstatic void nuke(struct at91_ep *ep, int status)\n{\n\tstruct at91_request *req;\n\n\t \n\tep->stopped = 1;\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\tVDBG(\"%s %s\\n\", __func__, ep->ep.name);\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct at91_request, queue);\n\t\tdone(ep, req, status);\n\t}\n}\n\n \n\nstatic int at91_ep_enable(struct usb_ep *_ep,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct at91_ep\t*ep = container_of(_ep, struct at91_ep, ep);\n\tstruct at91_udc *udc;\n\tu16\t\tmaxpacket;\n\tu32\t\ttmp;\n\tunsigned long\tflags;\n\n\tif (!_ep || !ep\n\t\t\t|| !desc || _ep->name == ep0name\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT\n\t\t\t|| (maxpacket = usb_endpoint_maxp(desc)) == 0\n\t\t\t|| maxpacket > ep->maxpacket) {\n\t\tDBG(\"bad ep or descriptor\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tDBG(\"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\ttmp = usb_endpoint_type(desc);\n\tswitch (tmp) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tDBG(\"only one control endpoint\\n\");\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (maxpacket > 64)\n\t\t\tgoto bogus_max;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tswitch (maxpacket) {\n\t\tcase 8:\n\t\tcase 16:\n\t\tcase 32:\n\t\tcase 64:\n\t\t\tgoto ok;\n\t\t}\nbogus_max:\n\t\tDBG(\"bogus maxpacket %d\\n\", maxpacket);\n\t\treturn -EINVAL;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (!ep->is_pingpong) {\n\t\t\tDBG(\"iso requires double buffering\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\nok:\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tep->is_in = usb_endpoint_dir_in(desc);\n\tep->is_iso = (tmp == USB_ENDPOINT_XFER_ISOC);\n\tep->stopped = 0;\n\tif (ep->is_in)\n\t\ttmp |= 0x04;\n\ttmp <<= 8;\n\ttmp |= AT91_UDP_EPEDS;\n\t__raw_writel(tmp, ep->creg);\n\n\tep->ep.maxpacket = maxpacket;\n\n\t \n\tat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\n\tat91_udp_write(udc, AT91_UDP_RST_EP, 0);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int at91_ep_disable (struct usb_ep * _ep)\n{\n\tstruct at91_ep\t*ep = container_of(_ep, struct at91_ep, ep);\n\tstruct at91_udc\t*udc = ep->udc;\n\tunsigned long\tflags;\n\n\tif (ep == &ep->udc->ep[0])\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tnuke(ep, -ESHUTDOWN);\n\n\t \n\tep->ep.desc = NULL;\n\tep->ep.maxpacket = ep->maxpacket;\n\n\t \n\tif (ep->udc->clocked) {\n\t\tat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\n\t\tat91_udp_write(udc, AT91_UDP_RST_EP, 0);\n\t\t__raw_writel(0, ep->creg);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic struct usb_request *\nat91_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct at91_request *req;\n\n\treq = kzalloc(sizeof (struct at91_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->req;\n}\n\nstatic void at91_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct at91_request *req;\n\n\treq = container_of(_req, struct at91_request, req);\n\tBUG_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\nstatic int at91_ep_queue(struct usb_ep *_ep,\n\t\t\tstruct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct at91_request\t*req;\n\tstruct at91_ep\t\t*ep;\n\tstruct at91_udc\t\t*udc;\n\tint\t\t\tstatus;\n\tunsigned long\t\tflags;\n\n\treq = container_of(_req, struct at91_request, req);\n\tep = container_of(_ep, struct at91_ep, ep);\n\n\tif (!_req || !_req->complete\n\t\t\t|| !_req->buf || !list_empty(&req->queue)) {\n\t\tDBG(\"invalid request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!_ep || (!ep->ep.desc && ep->ep.name != ep0name)) {\n\t\tDBG(\"invalid ep\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\n\tif (!udc || !udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tDBG(\"invalid device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (list_empty(&ep->queue) && !ep->stopped) {\n\t\tint\tis_ep0;\n\n\t\t \n\t\tis_ep0 = (ep->ep.name == ep0name);\n\t\tif (is_ep0) {\n\t\t\tu32\ttmp;\n\n\t\t\tif (!udc->req_pending) {\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (udc->wait_for_config_ack) {\n\t\t\t\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\t\t\t\ttmp ^= AT91_UDP_CONFG;\n\t\t\t\tVDBG(\"toggle config\\n\");\n\t\t\t\tat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\n\t\t\t}\n\t\t\tif (req->req.length == 0) {\nep0_in_status:\n\t\t\t\tPACKET(\"ep0 in/status\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t\ttmp = __raw_readl(ep->creg);\n\t\t\t\ttmp &= ~SET_FX;\n\t\t\t\ttmp |= CLR_FX | AT91_UDP_TXPKTRDY;\n\t\t\t\t__raw_writel(tmp, ep->creg);\n\t\t\t\tudc->req_pending = 0;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (ep->is_in)\n\t\t\tstatus = write_fifo(ep, req);\n\t\telse {\n\t\t\tstatus = read_fifo(ep, req);\n\n\t\t\t \n\t\t\tif (status && is_ep0)\n\t\t\t\tgoto ep0_in_status;\n\t\t}\n\t} else\n\t\tstatus = 0;\n\n\tif (req && !status) {\n\t\tlist_add_tail (&req->queue, &ep->queue);\n\t\tat91_udp_write(udc, AT91_UDP_IER, ep->int_mask);\n\t}\ndone:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn (status < 0) ? status : 0;\n}\n\nstatic int at91_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct at91_ep\t\t*ep;\n\tstruct at91_request\t*req = NULL, *iter;\n\tunsigned long\t\tflags;\n\tstruct at91_udc\t\t*udc;\n\n\tep = container_of(_ep, struct at91_ep, ep);\n\tif (!_ep || ep->ep.name == ep0name)\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int at91_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct at91_ep\t*ep = container_of(_ep, struct at91_ep, ep);\n\tstruct at91_udc\t*udc = ep->udc;\n\tu32 __iomem\t*creg;\n\tu32\t\tcsr;\n\tunsigned long\tflags;\n\tint\t\tstatus = 0;\n\n\tif (!_ep || ep->is_iso || !ep->udc->clocked)\n\t\treturn -EINVAL;\n\n\tcreg = ep->creg;\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tcsr = __raw_readl(creg);\n\n\t \n\tif (ep->is_in && (!list_empty(&ep->queue) || (csr >> 16) != 0))\n\t\tstatus = -EAGAIN;\n\telse {\n\t\tcsr |= CLR_FX;\n\t\tcsr &= ~SET_FX;\n\t\tif (value) {\n\t\t\tcsr |= AT91_UDP_FORCESTALL;\n\t\t\tVDBG(\"halt %s\\n\", ep->ep.name);\n\t\t} else {\n\t\t\tat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\n\t\t\tat91_udp_write(udc, AT91_UDP_RST_EP, 0);\n\t\t\tcsr &= ~AT91_UDP_FORCESTALL;\n\t\t}\n\t\t__raw_writel(csr, creg);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn status;\n}\n\nstatic const struct usb_ep_ops at91_ep_ops = {\n\t.enable\t\t= at91_ep_enable,\n\t.disable\t= at91_ep_disable,\n\t.alloc_request\t= at91_ep_alloc_request,\n\t.free_request\t= at91_ep_free_request,\n\t.queue\t\t= at91_ep_queue,\n\t.dequeue\t= at91_ep_dequeue,\n\t.set_halt\t= at91_ep_set_halt,\n\t \n};\n\n \n\nstatic int at91_get_frame(struct usb_gadget *gadget)\n{\n\tstruct at91_udc *udc = to_udc(gadget);\n\n\tif (!to_udc(gadget)->clocked)\n\t\treturn -EINVAL;\n\treturn at91_udp_read(udc, AT91_UDP_FRM_NUM) & AT91_UDP_NUM;\n}\n\nstatic int at91_wakeup(struct usb_gadget *gadget)\n{\n\tstruct at91_udc\t*udc = to_udc(gadget);\n\tu32\t\tglbstate;\n\tunsigned long\tflags;\n\n\tDBG(\"%s\\n\", __func__ );\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!udc->clocked || !udc->suspended)\n\t\tgoto done;\n\n\t \n\n\tglbstate = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\tif (!(glbstate & AT91_UDP_ESR))\n\t\tgoto done;\n\tglbstate |= AT91_UDP_ESR;\n\tat91_udp_write(udc, AT91_UDP_GLB_STAT, glbstate);\n\ndone:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic void udc_reinit(struct at91_udc *udc)\n{\n\tu32 i;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tINIT_LIST_HEAD(&udc->gadget.ep0->ep_list);\n\tudc->gadget.quirk_stall_not_supp = 1;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct at91_ep *ep = &udc->ep[i];\n\n\t\tif (i != 0)\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\tep->ep.desc = NULL;\n\t\tep->stopped = 0;\n\t\tep->fifo_bank = 0;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ep->maxpacket);\n\t\tep->creg = (void __iomem *) udc->udp_baseaddr + AT91_UDP_CSR(i);\n\t\t \n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n}\n\nstatic void reset_gadget(struct at91_udc *udc)\n{\n\tstruct usb_gadget_driver *driver = udc->driver;\n\tint i;\n\n\tif (udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->suspended = 0;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct at91_ep *ep = &udc->ep[i];\n\n\t\tep->stopped = 1;\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\tif (driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tusb_gadget_udc_reset(&udc->gadget, driver);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\tudc_reinit(udc);\n}\n\nstatic void stop_activity(struct at91_udc *udc)\n{\n\tstruct usb_gadget_driver *driver = udc->driver;\n\tint i;\n\n\tif (udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->suspended = 0;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tstruct at91_ep *ep = &udc->ep[i];\n\t\tep->stopped = 1;\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\tif (driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tdriver->disconnect(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\t}\n\n\tudc_reinit(udc);\n}\n\nstatic void clk_on(struct at91_udc *udc)\n{\n\tif (udc->clocked)\n\t\treturn;\n\tudc->clocked = 1;\n\n\tclk_enable(udc->iclk);\n\tclk_enable(udc->fclk);\n}\n\nstatic void clk_off(struct at91_udc *udc)\n{\n\tif (!udc->clocked)\n\t\treturn;\n\tudc->clocked = 0;\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tclk_disable(udc->fclk);\n\tclk_disable(udc->iclk);\n}\n\n \nstatic void pullup(struct at91_udc *udc, int is_on)\n{\n\tif (!udc->enabled || !udc->vbus)\n\t\tis_on = 0;\n\tDBG(\"%sactive\\n\", is_on ? \"\" : \"in\");\n\n\tif (is_on) {\n\t\tclk_on(udc);\n\t\tat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXRSM);\n\t\tat91_udp_write(udc, AT91_UDP_TXVC, 0);\n\t} else {\n\t\tstop_activity(udc);\n\t\tat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXRSM);\n\t\tat91_udp_write(udc, AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);\n\t\tclk_off(udc);\n\t}\n\n\tif (udc->caps && udc->caps->pullup)\n\t\tudc->caps->pullup(udc, is_on);\n}\n\n \nstatic int at91_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct at91_udc\t*udc = to_udc(gadget);\n\tunsigned long\tflags;\n\n\t \n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->vbus = (is_active != 0);\n\tif (udc->driver)\n\t\tpullup(udc, is_active);\n\telse\n\t\tpullup(udc, 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int at91_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct at91_udc\t*udc = to_udc(gadget);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->enabled = is_on = !!is_on;\n\tpullup(udc, is_on);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int at91_set_selfpowered(struct usb_gadget *gadget, int is_on)\n{\n\tstruct at91_udc\t*udc = to_udc(gadget);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tgadget->is_selfpowered = (is_on != 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int at91_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver);\nstatic int at91_stop(struct usb_gadget *gadget);\n\nstatic const struct usb_gadget_ops at91_udc_ops = {\n\t.get_frame\t\t= at91_get_frame,\n\t.wakeup\t\t\t= at91_wakeup,\n\t.set_selfpowered\t= at91_set_selfpowered,\n\t.vbus_session\t\t= at91_vbus_session,\n\t.pullup\t\t\t= at91_pullup,\n\t.udc_start\t\t= at91_start,\n\t.udc_stop\t\t= at91_stop,\n\n\t \n\t \n};\n\n \n\nstatic int handle_ep(struct at91_ep *ep)\n{\n\tstruct at91_request\t*req;\n\tu32 __iomem\t\t*creg = ep->creg;\n\tu32\t\t\tcsr = __raw_readl(creg);\n\n\tif (!list_empty(&ep->queue))\n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct at91_request, queue);\n\telse\n\t\treq = NULL;\n\n\tif (ep->is_in) {\n\t\tif (csr & (AT91_UDP_STALLSENT | AT91_UDP_TXCOMP)) {\n\t\t\tcsr |= CLR_FX;\n\t\t\tcsr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_TXCOMP);\n\t\t\t__raw_writel(csr, creg);\n\t\t}\n\t\tif (req)\n\t\t\treturn write_fifo(ep, req);\n\n\t} else {\n\t\tif (csr & AT91_UDP_STALLSENT) {\n\t\t\t \n\t\t\tif (ep->is_iso && req)\n\t\t\t\treq->req.status = -EILSEQ;\n\t\t\tcsr |= CLR_FX;\n\t\t\tcsr &= ~(SET_FX | AT91_UDP_STALLSENT);\n\t\t\t__raw_writel(csr, creg);\n\t\t\tcsr = __raw_readl(creg);\n\t\t}\n\t\tif (req && (csr & RX_DATA_READY))\n\t\t\treturn read_fifo(ep, req);\n\t}\n\treturn 0;\n}\n\nunion setup {\n\tu8\t\t\traw[8];\n\tstruct usb_ctrlrequest\tr;\n};\n\nstatic void handle_setup(struct at91_udc *udc, struct at91_ep *ep, u32 csr)\n{\n\tu32 __iomem\t*creg = ep->creg;\n\tu8 __iomem\t*dreg = ep->creg + (AT91_UDP_FDR(0) - AT91_UDP_CSR(0));\n\tunsigned\trxcount, i = 0;\n\tu32\t\ttmp;\n\tunion setup\tpkt;\n\tint\t\tstatus = 0;\n\n\t \n\trxcount = (csr & AT91_UDP_RXBYTECNT) >> 16;\n\tif (likely(rxcount == 8)) {\n\t\twhile (rxcount--)\n\t\t\tpkt.raw[i++] = __raw_readb(dreg);\n\t\tif (pkt.r.bRequestType & USB_DIR_IN) {\n\t\t\tcsr |= AT91_UDP_DIR;\n\t\t\tep->is_in = 1;\n\t\t} else {\n\t\t\tcsr &= ~AT91_UDP_DIR;\n\t\t\tep->is_in = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tERR(\"SETUP len %d, csr %08x\\n\", rxcount, csr);\n\t\tstatus = -EINVAL;\n\t}\n\tcsr |= CLR_FX;\n\tcsr &= ~(SET_FX | AT91_UDP_RXSETUP);\n\t__raw_writel(csr, creg);\n\tudc->wait_for_addr_ack = 0;\n\tudc->wait_for_config_ack = 0;\n\tep->stopped = 0;\n\tif (unlikely(status != 0))\n\t\tgoto stall;\n\n#define w_index\t\tle16_to_cpu(pkt.r.wIndex)\n#define w_value\t\tle16_to_cpu(pkt.r.wValue)\n#define w_length\tle16_to_cpu(pkt.r.wLength)\n\n\tVDBG(\"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t\tpkt.r.bRequestType, pkt.r.bRequest,\n\t\t\tw_value, w_index, w_length);\n\n\t \n\tudc->req_pending = 1;\n\tcsr = __raw_readl(creg);\n\tcsr |= CLR_FX;\n\tcsr &= ~SET_FX;\n\tswitch ((pkt.r.bRequestType << 8) | pkt.r.bRequest) {\n\n\tcase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\n\t\t\t| USB_REQ_SET_ADDRESS:\n\t\t__raw_writel(csr | AT91_UDP_TXPKTRDY, creg);\n\t\tudc->addr = w_value;\n\t\tudc->wait_for_addr_ack = 1;\n\t\tudc->req_pending = 0;\n\t\t \n\t\treturn;\n\n\tcase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\n\t\t\t| USB_REQ_SET_CONFIGURATION:\n\t\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT) & AT91_UDP_CONFG;\n\t\tif (pkt.r.wValue)\n\t\t\tudc->wait_for_config_ack = (tmp == 0);\n\t\telse\n\t\t\tudc->wait_for_config_ack = (tmp != 0);\n\t\tif (udc->wait_for_config_ack)\n\t\t\tVDBG(\"wait for config\\n\");\n\t\t \n\t\tbreak;\n\n\t \n\tcase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\n\t\t\t| USB_REQ_GET_STATUS:\n\t\ttmp = (udc->gadget.is_selfpowered << USB_DEVICE_SELF_POWERED);\n\t\tif (at91_udp_read(udc, AT91_UDP_GLB_STAT) & AT91_UDP_ESR)\n\t\t\ttmp |= (1 << USB_DEVICE_REMOTE_WAKEUP);\n\t\tPACKET(\"get device status\\n\");\n\t\t__raw_writeb(tmp, dreg);\n\t\t__raw_writeb(0, dreg);\n\t\tgoto write_in;\n\t\t \n\tcase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\n\t\t\t| USB_REQ_SET_FEATURE:\n\t\tif (w_value != USB_DEVICE_REMOTE_WAKEUP)\n\t\t\tgoto stall;\n\t\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\t\ttmp |= AT91_UDP_ESR;\n\t\tat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\n\t\tgoto succeed;\n\tcase ((USB_TYPE_STANDARD|USB_RECIP_DEVICE) << 8)\n\t\t\t| USB_REQ_CLEAR_FEATURE:\n\t\tif (w_value != USB_DEVICE_REMOTE_WAKEUP)\n\t\t\tgoto stall;\n\t\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\t\ttmp &= ~AT91_UDP_ESR;\n\t\tat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\n\t\tgoto succeed;\n\n\t \n\tcase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_REQ_GET_STATUS:\n\t\tPACKET(\"get interface status\\n\");\n\t\t__raw_writeb(0, dreg);\n\t\t__raw_writeb(0, dreg);\n\t\tgoto write_in;\n\t\t \n\tcase ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_REQ_SET_FEATURE:\n\tcase ((USB_TYPE_STANDARD|USB_RECIP_INTERFACE) << 8)\n\t\t\t| USB_REQ_CLEAR_FEATURE:\n\t\tgoto stall;\n\n\t \n\tcase ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\n\t\t\t| USB_REQ_GET_STATUS:\n\t\ttmp = w_index & USB_ENDPOINT_NUMBER_MASK;\n\t\tep = &udc->ep[tmp];\n\t\tif (tmp >= NUM_ENDPOINTS || (tmp && !ep->ep.desc))\n\t\t\tgoto stall;\n\n\t\tif (tmp) {\n\t\t\tif ((w_index & USB_DIR_IN)) {\n\t\t\t\tif (!ep->is_in)\n\t\t\t\t\tgoto stall;\n\t\t\t} else if (ep->is_in)\n\t\t\t\tgoto stall;\n\t\t}\n\t\tPACKET(\"get %s status\\n\", ep->ep.name);\n\t\tif (__raw_readl(ep->creg) & AT91_UDP_FORCESTALL)\n\t\t\ttmp = (1 << USB_ENDPOINT_HALT);\n\t\telse\n\t\t\ttmp = 0;\n\t\t__raw_writeb(tmp, dreg);\n\t\t__raw_writeb(0, dreg);\n\t\tgoto write_in;\n\t\t \n\tcase ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\n\t\t\t| USB_REQ_SET_FEATURE:\n\t\ttmp = w_index & USB_ENDPOINT_NUMBER_MASK;\n\t\tep = &udc->ep[tmp];\n\t\tif (w_value != USB_ENDPOINT_HALT || tmp >= NUM_ENDPOINTS)\n\t\t\tgoto stall;\n\t\tif (!ep->ep.desc || ep->is_iso)\n\t\t\tgoto stall;\n\t\tif ((w_index & USB_DIR_IN)) {\n\t\t\tif (!ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else if (ep->is_in)\n\t\t\tgoto stall;\n\n\t\ttmp = __raw_readl(ep->creg);\n\t\ttmp &= ~SET_FX;\n\t\ttmp |= CLR_FX | AT91_UDP_FORCESTALL;\n\t\t__raw_writel(tmp, ep->creg);\n\t\tgoto succeed;\n\tcase ((USB_TYPE_STANDARD|USB_RECIP_ENDPOINT) << 8)\n\t\t\t| USB_REQ_CLEAR_FEATURE:\n\t\ttmp = w_index & USB_ENDPOINT_NUMBER_MASK;\n\t\tep = &udc->ep[tmp];\n\t\tif (w_value != USB_ENDPOINT_HALT || tmp >= NUM_ENDPOINTS)\n\t\t\tgoto stall;\n\t\tif (tmp == 0)\n\t\t\tgoto succeed;\n\t\tif (!ep->ep.desc || ep->is_iso)\n\t\t\tgoto stall;\n\t\tif ((w_index & USB_DIR_IN)) {\n\t\t\tif (!ep->is_in)\n\t\t\t\tgoto stall;\n\t\t} else if (ep->is_in)\n\t\t\tgoto stall;\n\n\t\tat91_udp_write(udc, AT91_UDP_RST_EP, ep->int_mask);\n\t\tat91_udp_write(udc, AT91_UDP_RST_EP, 0);\n\t\ttmp = __raw_readl(ep->creg);\n\t\ttmp |= CLR_FX;\n\t\ttmp &= ~(SET_FX | AT91_UDP_FORCESTALL);\n\t\t__raw_writel(tmp, ep->creg);\n\t\tif (!list_empty(&ep->queue))\n\t\t\thandle_ep(ep);\n\t\tgoto succeed;\n\t}\n\n#undef w_value\n#undef w_index\n#undef w_length\n\n\t \n\tif (udc->driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tstatus = udc->driver->setup(&udc->gadget, &pkt.r);\n\t\tspin_lock(&udc->lock);\n\t}\n\telse\n\t\tstatus = -ENODEV;\n\tif (status < 0) {\nstall:\n\t\tVDBG(\"req %02x.%02x protocol STALL; stat %d\\n\",\n\t\t\t\tpkt.r.bRequestType, pkt.r.bRequest, status);\n\t\tcsr |= AT91_UDP_FORCESTALL;\n\t\t__raw_writel(csr, creg);\n\t\tudc->req_pending = 0;\n\t}\n\treturn;\n\nsucceed:\n\t \n\tPACKET(\"ep0 in/status\\n\");\nwrite_in:\n\tcsr |= AT91_UDP_TXPKTRDY;\n\t__raw_writel(csr, creg);\n\tudc->req_pending = 0;\n}\n\nstatic void handle_ep0(struct at91_udc *udc)\n{\n\tstruct at91_ep\t\t*ep0 = &udc->ep[0];\n\tu32 __iomem\t\t*creg = ep0->creg;\n\tu32\t\t\tcsr = __raw_readl(creg);\n\tstruct at91_request\t*req;\n\n\tif (unlikely(csr & AT91_UDP_STALLSENT)) {\n\t\tnuke(ep0, -EPROTO);\n\t\tudc->req_pending = 0;\n\t\tcsr |= CLR_FX;\n\t\tcsr &= ~(SET_FX | AT91_UDP_STALLSENT | AT91_UDP_FORCESTALL);\n\t\t__raw_writel(csr, creg);\n\t\tVDBG(\"ep0 stalled\\n\");\n\t\tcsr = __raw_readl(creg);\n\t}\n\tif (csr & AT91_UDP_RXSETUP) {\n\t\tnuke(ep0, 0);\n\t\tudc->req_pending = 0;\n\t\thandle_setup(udc, ep0, csr);\n\t\treturn;\n\t}\n\n\tif (list_empty(&ep0->queue))\n\t\treq = NULL;\n\telse\n\t\treq = list_entry(ep0->queue.next, struct at91_request, queue);\n\n\t \n\tif (csr & AT91_UDP_TXCOMP) {\n\t\tcsr |= CLR_FX;\n\t\tcsr &= ~(SET_FX | AT91_UDP_TXCOMP);\n\n\t\t \n\t\tif (req && ep0->is_in) {\n\t\t\tif (handle_ep(ep0))\n\t\t\t\tudc->req_pending = 0;\n\n\t\t \n\t\t} else {\n\t\t\tudc->req_pending = 0;\n\t\t\t__raw_writel(csr, creg);\n\n\t\t\t \n\t\t\tif (udc->wait_for_addr_ack) {\n\t\t\t\tu32\ttmp;\n\n\t\t\t\tat91_udp_write(udc, AT91_UDP_FADDR,\n\t\t\t\t\t\tAT91_UDP_FEN | udc->addr);\n\t\t\t\ttmp = at91_udp_read(udc, AT91_UDP_GLB_STAT);\n\t\t\t\ttmp &= ~AT91_UDP_FADDEN;\n\t\t\t\tif (udc->addr)\n\t\t\t\t\ttmp |= AT91_UDP_FADDEN;\n\t\t\t\tat91_udp_write(udc, AT91_UDP_GLB_STAT, tmp);\n\n\t\t\t\tudc->wait_for_addr_ack = 0;\n\t\t\t\tVDBG(\"address %d\\n\", udc->addr);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\telse if (csr & AT91_UDP_RX_DATA_BK0) {\n\t\tcsr |= CLR_FX;\n\t\tcsr &= ~(SET_FX | AT91_UDP_RX_DATA_BK0);\n\n\t\t \n\t\tif (!ep0->is_in) {\n\t\t\tif (req) {\n\t\t\t\tif (handle_ep(ep0)) {\n\t\t\t\t\t \n\t\t\t\t\tPACKET(\"ep0 in/status\\n\");\n\t\t\t\t\tcsr = __raw_readl(creg);\n\t\t\t\t\tcsr &= ~SET_FX;\n\t\t\t\t\tcsr |= CLR_FX | AT91_UDP_TXPKTRDY;\n\t\t\t\t\t__raw_writel(csr, creg);\n\t\t\t\t\tudc->req_pending = 0;\n\t\t\t\t}\n\t\t\t} else if (udc->req_pending) {\n\t\t\t\t \n\t\t\t\tDBG(\"no control-OUT deferred responses!\\n\");\n\t\t\t\t__raw_writel(csr | AT91_UDP_FORCESTALL, creg);\n\t\t\t\tudc->req_pending = 0;\n\t\t\t}\n\n\t\t \n\t\t} else {\n\t\t\tPACKET(\"ep0 out/status ACK\\n\");\n\t\t\t__raw_writel(csr, creg);\n\n\t\t\t \n\t\t\tif (req)\n\t\t\t\tdone(ep0, req, 0);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t at91_udc_irq (int irq, void *_udc)\n{\n\tstruct at91_udc\t\t*udc = _udc;\n\tu32\t\t\trescans = 5;\n\tint\t\t\tdisable_clock = 0;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!udc->clocked) {\n\t\tclk_on(udc);\n\t\tdisable_clock = 1;\n\t}\n\n\twhile (rescans--) {\n\t\tu32 status;\n\n\t\tstatus = at91_udp_read(udc, AT91_UDP_ISR)\n\t\t\t& at91_udp_read(udc, AT91_UDP_IMR);\n\t\tif (!status)\n\t\t\tbreak;\n\n\t\t \n\t\tif (status & AT91_UDP_ENDBUSRES) {\n\t\t\tat91_udp_write(udc, AT91_UDP_IDR, ~MINIMUS_INTERRUPTUS);\n\t\t\tat91_udp_write(udc, AT91_UDP_IER, MINIMUS_INTERRUPTUS);\n\t\t\t \n\t\t\tat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_ENDBUSRES);\n\t\t\tat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_ENDBUSRES);\n\t\t\tVDBG(\"end bus reset\\n\");\n\t\t\tudc->addr = 0;\n\t\t\treset_gadget(udc);\n\n\t\t\t \n\t\t\tat91_udp_write(udc, AT91_UDP_CSR(0),\n\t\t\t\t\tAT91_UDP_EPEDS | AT91_UDP_EPTYPE_CTRL);\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\t\tudc->suspended = 0;\n\t\t\tat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_EP(0));\n\n\t\t\t \n\n\t\t \n\t\t} else if (status & AT91_UDP_RXSUSP) {\n\t\t\tat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXSUSP);\n\t\t\tat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_RXRSM);\n\t\t\tat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXSUSP);\n\t\t\t \n\t\t\tif (udc->suspended)\n\t\t\t\tcontinue;\n\t\t\tudc->suspended = 1;\n\n\t\t\t \n\t\t\tif (udc->driver && udc->driver->suspend) {\n\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\t\tspin_lock(&udc->lock);\n\t\t\t}\n\n\t\t \n\t\t} else if (status & AT91_UDP_RXRSM) {\n\t\t\tat91_udp_write(udc, AT91_UDP_IDR, AT91_UDP_RXRSM);\n\t\t\tat91_udp_write(udc, AT91_UDP_IER, AT91_UDP_RXSUSP);\n\t\t\tat91_udp_write(udc, AT91_UDP_ICR, AT91_UDP_RXRSM);\n\t\t\t \n\t\t\tif (!udc->suspended)\n\t\t\t\tcontinue;\n\t\t\tudc->suspended = 0;\n\n\t\t\t \n\t\t\tif (udc->driver && udc->driver->resume) {\n\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\t\tspin_lock(&udc->lock);\n\t\t\t}\n\n\t\t \n\t\t} else {\n\t\t\tint\t\ti;\n\t\t\tunsigned\tmask = 1;\n\t\t\tstruct at91_ep\t*ep = &udc->ep[1];\n\n\t\t\tif (status & mask)\n\t\t\t\thandle_ep0(udc);\n\t\t\tfor (i = 1; i < NUM_ENDPOINTS; i++) {\n\t\t\t\tmask <<= 1;\n\t\t\t\tif (status & mask)\n\t\t\t\t\thandle_ep(ep);\n\t\t\t\tep++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (disable_clock)\n\t\tclk_off(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void at91_vbus_update(struct at91_udc *udc, unsigned value)\n{\n\tif (value != udc->vbus)\n\t\tat91_vbus_session(&udc->gadget, value);\n}\n\nstatic irqreturn_t at91_vbus_irq(int irq, void *_udc)\n{\n\tstruct at91_udc\t*udc = _udc;\n\n\t \n\tudelay(10);\n\tat91_vbus_update(udc, gpiod_get_value(udc->board.vbus_pin));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void at91_vbus_timer_work(struct work_struct *work)\n{\n\tstruct at91_udc *udc = container_of(work, struct at91_udc,\n\t\t\t\t\t    vbus_timer_work);\n\n\tat91_vbus_update(udc, gpiod_get_value_cansleep(udc->board.vbus_pin));\n\n\tif (!timer_pending(&udc->vbus_timer))\n\t\tmod_timer(&udc->vbus_timer, jiffies + VBUS_POLL_TIMEOUT);\n}\n\nstatic void at91_vbus_timer(struct timer_list *t)\n{\n\tstruct at91_udc *udc = from_timer(udc, t, vbus_timer);\n\n\t \n\tschedule_work(&udc->vbus_timer_work);\n}\n\nstatic int at91_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct at91_udc\t*udc;\n\n\tudc = container_of(gadget, struct at91_udc, gadget);\n\tudc->driver = driver;\n\tudc->gadget.dev.of_node = udc->pdev->dev.of_node;\n\tudc->enabled = 1;\n\tudc->gadget.is_selfpowered = 1;\n\n\treturn 0;\n}\n\nstatic int at91_stop(struct usb_gadget *gadget)\n{\n\tstruct at91_udc *udc;\n\tunsigned long\tflags;\n\n\tudc = container_of(gadget, struct at91_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->enabled = 0;\n\tat91_udp_write(udc, AT91_UDP_IDR, ~0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tudc->driver = NULL;\n\n\treturn 0;\n}\n\n \n\nstatic void at91udc_shutdown(struct platform_device *dev)\n{\n\tstruct at91_udc *udc = platform_get_drvdata(dev);\n\tunsigned long\tflags;\n\n\t \n\tspin_lock_irqsave(&udc->lock, flags);\n\tpullup(platform_get_drvdata(dev), 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic int at91rm9200_udc_init(struct at91_udc *udc)\n{\n\tstruct at91_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\tcase 3:\n\t\t\tep->maxpacket = 8;\n\t\t\tbreak;\n\t\tcase 1 ... 2:\n\t\t\tep->maxpacket = 64;\n\t\t\tbreak;\n\t\tcase 4 ... 5:\n\t\t\tep->maxpacket = 256;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!udc->board.pullup_pin) {\n\t\tDBG(\"no D+ pullup?\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tgpiod_direction_output(udc->board.pullup_pin,\n\t\t\t       gpiod_is_active_low(udc->board.pullup_pin));\n\n\treturn 0;\n}\n\nstatic void at91rm9200_udc_pullup(struct at91_udc *udc, int is_on)\n{\n\tgpiod_set_value(udc->board.pullup_pin, is_on);\n}\n\nstatic const struct at91_udc_caps at91rm9200_udc_caps = {\n\t.init = at91rm9200_udc_init,\n\t.pullup = at91rm9200_udc_pullup,\n};\n\nstatic int at91sam9260_udc_init(struct at91_udc *udc)\n{\n\tstruct at91_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\n\t\tswitch (i) {\n\t\tcase 0 ... 3:\n\t\t\tep->maxpacket = 64;\n\t\t\tbreak;\n\t\tcase 4 ... 5:\n\t\t\tep->maxpacket = 512;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void at91sam9260_udc_pullup(struct at91_udc *udc, int is_on)\n{\n\tu32 txvc = at91_udp_read(udc, AT91_UDP_TXVC);\n\n\tif (is_on)\n\t\ttxvc |= AT91_UDP_TXVC_PUON;\n\telse\n\t\ttxvc &= ~AT91_UDP_TXVC_PUON;\n\n\tat91_udp_write(udc, AT91_UDP_TXVC, txvc);\n}\n\nstatic const struct at91_udc_caps at91sam9260_udc_caps = {\n\t.init = at91sam9260_udc_init,\n\t.pullup = at91sam9260_udc_pullup,\n};\n\nstatic int at91sam9261_udc_init(struct at91_udc *udc)\n{\n\tstruct at91_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tep->maxpacket = 8;\n\t\t\tbreak;\n\t\tcase 1 ... 3:\n\t\t\tep->maxpacket = 64;\n\t\t\tbreak;\n\t\tcase 4 ... 5:\n\t\t\tep->maxpacket = 256;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tudc->matrix = syscon_regmap_lookup_by_phandle(udc->pdev->dev.of_node,\n\t\t\t\t\t\t      \"atmel,matrix\");\n\treturn PTR_ERR_OR_ZERO(udc->matrix);\n}\n\nstatic void at91sam9261_udc_pullup(struct at91_udc *udc, int is_on)\n{\n\tu32 usbpucr = 0;\n\n\tif (is_on)\n\t\tusbpucr = AT91_MATRIX_USBPUCR_PUON;\n\n\tregmap_update_bits(udc->matrix, AT91SAM9261_MATRIX_USBPUCR,\n\t\t\t   AT91_MATRIX_USBPUCR_PUON, usbpucr);\n}\n\nstatic const struct at91_udc_caps at91sam9261_udc_caps = {\n\t.init = at91sam9261_udc_init,\n\t.pullup = at91sam9261_udc_pullup,\n};\n\nstatic int at91sam9263_udc_init(struct at91_udc *udc)\n{\n\tstruct at91_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\n\t\tswitch (i) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tep->maxpacket = 64;\n\t\t\tbreak;\n\t\tcase 4:\n\t\tcase 5:\n\t\t\tep->maxpacket = 256;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct at91_udc_caps at91sam9263_udc_caps = {\n\t.init = at91sam9263_udc_init,\n\t.pullup = at91sam9260_udc_pullup,\n};\n\nstatic const struct of_device_id at91_udc_dt_ids[] = {\n\t{\n\t\t.compatible = \"atmel,at91rm9200-udc\",\n\t\t.data = &at91rm9200_udc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9260-udc\",\n\t\t.data = &at91sam9260_udc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9261-udc\",\n\t\t.data = &at91sam9261_udc_caps,\n\t},\n\t{\n\t\t.compatible = \"atmel,at91sam9263-udc\",\n\t\t.data = &at91sam9263_udc_caps,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, at91_udc_dt_ids);\n\nstatic void at91udc_of_init(struct at91_udc *udc, struct device_node *np)\n{\n\tstruct at91_udc_data *board = &udc->board;\n\tconst struct of_device_id *match;\n\tu32 val;\n\n\tif (of_property_read_u32(np, \"atmel,vbus-polled\", &val) == 0)\n\t\tboard->vbus_polled = 1;\n\n\tboard->vbus_pin = fwnode_gpiod_get_index(of_fwnode_handle(np),\n\t\t\t\t\t\t \"atmel,vbus\", 0, GPIOD_IN,\n\t\t\t\t\t\t \"udc_vbus\");\n\tif (IS_ERR(board->vbus_pin))\n\t\tboard->vbus_pin = NULL;\n\n\tboard->pullup_pin = fwnode_gpiod_get_index(of_fwnode_handle(np),\n\t\t\t\t\t\t   \"atmel,pullup\", 0,\n\t\t\t\t\t\t   GPIOD_ASIS, \"udc_pullup\");\n\tif (IS_ERR(board->pullup_pin))\n\t\tboard->pullup_pin = NULL;\n\n\tmatch = of_match_node(at91_udc_dt_ids, np);\n\tif (match)\n\t\tudc->caps = match->data;\n}\n\nstatic int at91udc_probe(struct platform_device *pdev)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tstruct at91_udc\t*udc;\n\tint\t\tretval;\n\tstruct at91_ep\t*ep;\n\tint\t\ti;\n\n\tudc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\t \n\tudc->gadget.dev.parent = dev;\n\tat91udc_of_init(udc, pdev->dev.of_node);\n\tudc->pdev = pdev;\n\tudc->enabled = 0;\n\tspin_lock_init(&udc->lock);\n\n\tudc->gadget.ops = &at91_udc_ops;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\tudc->gadget.name = driver_name;\n\tudc->gadget.dev.init_name = \"gadget\";\n\n\tfor (i = 0; i < NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tep->ep.name = ep_info[i].name;\n\t\tep->ep.caps = ep_info[i].caps;\n\t\tep->ep.ops = &at91_ep_ops;\n\t\tep->udc = udc;\n\t\tep->int_mask = BIT(i);\n\t\tif (i != 0 && i != 3)\n\t\t\tep->is_pingpong = 1;\n\t}\n\n\tudc->udp_baseaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->udp_baseaddr))\n\t\treturn PTR_ERR(udc->udp_baseaddr);\n\n\tif (udc->caps && udc->caps->init) {\n\t\tretval = udc->caps->init(udc);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tudc_reinit(udc);\n\n\t \n\tudc->iclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(udc->iclk))\n\t\treturn PTR_ERR(udc->iclk);\n\n\tudc->fclk = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(udc->fclk))\n\t\treturn PTR_ERR(udc->fclk);\n\n\t \n\tclk_set_rate(udc->fclk, 48000000);\n\tretval = clk_prepare(udc->fclk);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = clk_prepare_enable(udc->iclk);\n\tif (retval)\n\t\tgoto err_unprepare_fclk;\n\n\tat91_udp_write(udc, AT91_UDP_TXVC, AT91_UDP_TXVC_TXVDIS);\n\tat91_udp_write(udc, AT91_UDP_IDR, 0xffffffff);\n\t \n\tat91_udp_write(udc, AT91_UDP_ICR, 0xffffffff);\n\tclk_disable(udc->iclk);\n\n\t \n\tudc->udp_irq = retval = platform_get_irq(pdev, 0);\n\tif (retval < 0)\n\t\tgoto err_unprepare_iclk;\n\tretval = devm_request_irq(dev, udc->udp_irq, at91_udc_irq, 0,\n\t\t\t\t  driver_name, udc);\n\tif (retval) {\n\t\tDBG(\"request irq %d failed\\n\", udc->udp_irq);\n\t\tgoto err_unprepare_iclk;\n\t}\n\n\tif (udc->board.vbus_pin) {\n\t\tgpiod_direction_input(udc->board.vbus_pin);\n\n\t\t \n\t\tudc->vbus = gpiod_get_value_cansleep(udc->board.vbus_pin);\n\n\t\tif (udc->board.vbus_polled) {\n\t\t\tINIT_WORK(&udc->vbus_timer_work, at91_vbus_timer_work);\n\t\t\ttimer_setup(&udc->vbus_timer, at91_vbus_timer, 0);\n\t\t\tmod_timer(&udc->vbus_timer,\n\t\t\t\t  jiffies + VBUS_POLL_TIMEOUT);\n\t\t} else {\n\t\t\tretval = devm_request_irq(dev,\n\t\t\t\t\tgpiod_to_irq(udc->board.vbus_pin),\n\t\t\t\t\tat91_vbus_irq, 0, driver_name, udc);\n\t\t\tif (retval) {\n\t\t\t\tDBG(\"request vbus irq %d failed\\n\",\n\t\t\t\t    desc_to_gpio(udc->board.vbus_pin));\n\t\t\t\tgoto err_unprepare_iclk;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tDBG(\"no VBUS detection, assuming always-on\\n\");\n\t\tudc->vbus = 1;\n\t}\n\tretval = usb_add_gadget_udc(dev, &udc->gadget);\n\tif (retval)\n\t\tgoto err_unprepare_iclk;\n\tdev_set_drvdata(dev, udc);\n\tdevice_init_wakeup(dev, 1);\n\tcreate_debug_file(udc);\n\n\tINFO(\"%s version %s\\n\", driver_name, DRIVER_VERSION);\n\treturn 0;\n\nerr_unprepare_iclk:\n\tclk_unprepare(udc->iclk);\nerr_unprepare_fclk:\n\tclk_unprepare(udc->fclk);\n\n\tDBG(\"%s probe failed, %d\\n\", driver_name, retval);\n\n\treturn retval;\n}\n\nstatic int at91udc_remove(struct platform_device *pdev)\n{\n\tstruct at91_udc *udc = platform_get_drvdata(pdev);\n\tunsigned long\tflags;\n\n\tDBG(\"remove\\n\");\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tif (udc->driver)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tpullup(udc, 0);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tremove_debug_file(udc);\n\tclk_unprepare(udc->fclk);\n\tclk_unprepare(udc->iclk);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int at91udc_suspend(struct platform_device *pdev, pm_message_t mesg)\n{\n\tstruct at91_udc *udc = platform_get_drvdata(pdev);\n\tint\t\twake = udc->driver && device_may_wakeup(&pdev->dev);\n\tunsigned long\tflags;\n\n\t \n\tif ((!udc->suspended && udc->addr)\n\t\t\t|| !wake\n\t\t\t|| at91_suspend_entering_slow_clock()) {\n\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\tpullup(udc, 0);\n\t\twake = 0;\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t} else\n\t\tenable_irq_wake(udc->udp_irq);\n\n\tudc->active_suspend = wake;\n\tif (udc->board.vbus_pin && !udc->board.vbus_polled && wake)\n\t\tenable_irq_wake(gpiod_to_irq(udc->board.vbus_pin));\n\treturn 0;\n}\n\nstatic int at91udc_resume(struct platform_device *pdev)\n{\n\tstruct at91_udc *udc = platform_get_drvdata(pdev);\n\tunsigned long\tflags;\n\n\tif (udc->board.vbus_pin && !udc->board.vbus_polled &&\n\t    udc->active_suspend)\n\t\tdisable_irq_wake(gpiod_to_irq(udc->board.vbus_pin));\n\n\t \n\tif (udc->active_suspend)\n\t\tdisable_irq_wake(udc->udp_irq);\n\telse {\n\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\tpullup(udc, 1);\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t}\n\treturn 0;\n}\n#else\n#define\tat91udc_suspend\tNULL\n#define\tat91udc_resume\tNULL\n#endif\n\nstatic struct platform_driver at91_udc_driver = {\n\t.remove\t\t= at91udc_remove,\n\t.shutdown\t= at91udc_shutdown,\n\t.suspend\t= at91udc_suspend,\n\t.resume\t\t= at91udc_resume,\n\t.driver\t\t= {\n\t\t.name\t= driver_name,\n\t\t.of_match_table\t= at91_udc_dt_ids,\n\t},\n};\n\nmodule_platform_driver_probe(at91_udc_driver, at91udc_probe);\n\nMODULE_DESCRIPTION(\"AT91 udc driver\");\nMODULE_AUTHOR(\"Thomas Rathbone, David Brownell\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:at91_udc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}