{
  "module_name": "fusb300_udc.c",
  "hash_id": "60f6b57ec0158aba6d0ec5859f118f5e6728149c8dfd3416379430871b614efa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/fusb300_udc.c",
  "human_readable_source": "\n \n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include \"fusb300_udc.h\"\n\nMODULE_DESCRIPTION(\"FUSB300  USB gadget driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yuan-Hsin Chen, Feng-Hsin Chiang <john453@faraday-tech.com>\");\nMODULE_ALIAS(\"platform:fusb300_udc\");\n\n#define DRIVER_VERSION\t\"20 October 2010\"\n\nstatic const char udc_name[] = \"fusb300_udc\";\nstatic const char * const fusb300_ep_name[] = {\n\t\"ep0\", \"ep1\", \"ep2\", \"ep3\", \"ep4\", \"ep5\", \"ep6\", \"ep7\", \"ep8\", \"ep9\",\n\t\"ep10\", \"ep11\", \"ep12\", \"ep13\", \"ep14\", \"ep15\"\n};\n\nstatic void done(struct fusb300_ep *ep, struct fusb300_request *req,\n\t\t int status);\n\nstatic void fusb300_enable_bit(struct fusb300 *fusb300, u32 offset,\n\t\t\t       u32 value)\n{\n\tu32 reg = ioread32(fusb300->reg + offset);\n\n\treg |= value;\n\tiowrite32(reg, fusb300->reg + offset);\n}\n\nstatic void fusb300_disable_bit(struct fusb300 *fusb300, u32 offset,\n\t\t\t\tu32 value)\n{\n\tu32 reg = ioread32(fusb300->reg + offset);\n\n\treg &= ~value;\n\tiowrite32(reg, fusb300->reg + offset);\n}\n\n\nstatic void fusb300_ep_setting(struct fusb300_ep *ep,\n\t\t\t       struct fusb300_ep_info info)\n{\n\tep->epnum = info.epnum;\n\tep->type = info.type;\n}\n\nstatic int fusb300_ep_release(struct fusb300_ep *ep)\n{\n\tif (!ep->epnum)\n\t\treturn 0;\n\tep->epnum = 0;\n\tep->stall = 0;\n\tep->wedged = 0;\n\treturn 0;\n}\n\nstatic void fusb300_set_fifo_entry(struct fusb300 *fusb300,\n\t\t\t\t   u32 ep)\n{\n\tu32 val = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n\n\tval &= ~FUSB300_EPSET1_FIFOENTRY_MSK;\n\tval |= FUSB300_EPSET1_FIFOENTRY(FUSB300_FIFO_ENTRY_NUM);\n\tiowrite32(val, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n}\n\nstatic void fusb300_set_start_entry(struct fusb300 *fusb300,\n\t\t\t\t    u8 ep)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n\tu32 start_entry = fusb300->fifo_entry_num * FUSB300_FIFO_ENTRY_NUM;\n\n\treg &= ~FUSB300_EPSET1_START_ENTRY_MSK\t;\n\treg |= FUSB300_EPSET1_START_ENTRY(start_entry);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n\tif (fusb300->fifo_entry_num == FUSB300_MAX_FIFO_ENTRY) {\n\t\tfusb300->fifo_entry_num = 0;\n\t\tfusb300->addrofs = 0;\n\t\tpr_err(\"fifo entry is over the maximum number!\\n\");\n\t} else\n\t\tfusb300->fifo_entry_num++;\n}\n\n \nstatic void fusb300_set_epaddrofs(struct fusb300 *fusb300,\n\t\t\t\t  struct fusb300_ep_info info)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\n\n\treg &= ~FUSB300_EPSET2_ADDROFS_MSK;\n\treg |= FUSB300_EPSET2_ADDROFS(fusb300->addrofs);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\n\tfusb300->addrofs += (info.maxpacket + 7) / 8 * FUSB300_FIFO_ENTRY_NUM;\n}\n\nstatic void ep_fifo_setting(struct fusb300 *fusb300,\n\t\t\t    struct fusb300_ep_info info)\n{\n\tfusb300_set_fifo_entry(fusb300, info.epnum);\n\tfusb300_set_start_entry(fusb300, info.epnum);\n\tfusb300_set_epaddrofs(fusb300, info);\n}\n\nstatic void fusb300_set_eptype(struct fusb300 *fusb300,\n\t\t\t       struct fusb300_ep_info info)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n\n\treg &= ~FUSB300_EPSET1_TYPE_MSK;\n\treg |= FUSB300_EPSET1_TYPE(info.type);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n}\n\nstatic void fusb300_set_epdir(struct fusb300 *fusb300,\n\t\t\t      struct fusb300_ep_info info)\n{\n\tu32 reg;\n\n\tif (!info.dir_in)\n\t\treturn;\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n\treg &= ~FUSB300_EPSET1_DIR_MSK;\n\treg |= FUSB300_EPSET1_DIRIN;\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n}\n\nstatic void fusb300_set_ep_active(struct fusb300 *fusb300,\n\t\t\t  u8 ep)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n\n\treg |= FUSB300_EPSET1_ACTEN;\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(ep));\n}\n\nstatic void fusb300_set_epmps(struct fusb300 *fusb300,\n\t\t\t      struct fusb300_ep_info info)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\n\n\treg &= ~FUSB300_EPSET2_MPS_MSK;\n\treg |= FUSB300_EPSET2_MPS(info.maxpacket);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET2(info.epnum));\n}\n\nstatic void fusb300_set_interval(struct fusb300 *fusb300,\n\t\t\t\t struct fusb300_ep_info info)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n\n\treg &= ~FUSB300_EPSET1_INTERVAL(0x7);\n\treg |= FUSB300_EPSET1_INTERVAL(info.interval);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n}\n\nstatic void fusb300_set_bwnum(struct fusb300 *fusb300,\n\t\t\t      struct fusb300_ep_info info)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n\n\treg &= ~FUSB300_EPSET1_BWNUM(0x3);\n\treg |= FUSB300_EPSET1_BWNUM(info.bw_num);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET1(info.epnum));\n}\n\nstatic void set_ep_reg(struct fusb300 *fusb300,\n\t\t      struct fusb300_ep_info info)\n{\n\tfusb300_set_eptype(fusb300, info);\n\tfusb300_set_epdir(fusb300, info);\n\tfusb300_set_epmps(fusb300, info);\n\n\tif (info.interval)\n\t\tfusb300_set_interval(fusb300, info);\n\n\tif (info.bw_num)\n\t\tfusb300_set_bwnum(fusb300, info);\n\n\tfusb300_set_ep_active(fusb300, info.epnum);\n}\n\nstatic int config_ep(struct fusb300_ep *ep,\n\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\tstruct fusb300_ep_info info;\n\n\tep->ep.desc = desc;\n\n\tinfo.interval = 0;\n\tinfo.addrofs = 0;\n\tinfo.bw_num = 0;\n\n\tinfo.type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tinfo.dir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\n\tinfo.maxpacket = usb_endpoint_maxp(desc);\n\tinfo.epnum = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\n\n\tif ((info.type == USB_ENDPOINT_XFER_INT) ||\n\t   (info.type == USB_ENDPOINT_XFER_ISOC)) {\n\t\tinfo.interval = desc->bInterval;\n\t\tif (info.type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tinfo.bw_num = usb_endpoint_maxp_mult(desc);\n\t}\n\n\tep_fifo_setting(fusb300, info);\n\n\tset_ep_reg(fusb300, info);\n\n\tfusb300_ep_setting(ep, info);\n\n\tfusb300->ep[info.epnum] = ep;\n\n\treturn 0;\n}\n\nstatic int fusb300_enable(struct usb_ep *_ep,\n\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct fusb300_ep *ep;\n\n\tep = container_of(_ep, struct fusb300_ep, ep);\n\n\tif (ep->fusb300->reenum) {\n\t\tep->fusb300->fifo_entry_num = 0;\n\t\tep->fusb300->addrofs = 0;\n\t\tep->fusb300->reenum = 0;\n\t}\n\n\treturn config_ep(ep, desc);\n}\n\nstatic int fusb300_disable(struct usb_ep *_ep)\n{\n\tstruct fusb300_ep *ep;\n\tstruct fusb300_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct fusb300_ep, ep);\n\n\tBUG_ON(!ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct fusb300_request, queue);\n\t\tspin_lock_irqsave(&ep->fusb300->lock, flags);\n\t\tdone(ep, req, -ECONNRESET);\n\t\tspin_unlock_irqrestore(&ep->fusb300->lock, flags);\n\t}\n\n\treturn fusb300_ep_release(ep);\n}\n\nstatic struct usb_request *fusb300_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\tgfp_t gfp_flags)\n{\n\tstruct fusb300_request *req;\n\n\treq = kzalloc(sizeof(struct fusb300_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void fusb300_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct fusb300_request *req;\n\n\treq = container_of(_req, struct fusb300_request, req);\n\tkfree(req);\n}\n\nstatic int enable_fifo_int(struct fusb300_ep *ep)\n{\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\n\tif (ep->epnum) {\n\t\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_IGER0,\n\t\t\tFUSB300_IGER0_EEPn_FIFO_INT(ep->epnum));\n\t} else {\n\t\tpr_err(\"can't enable_fifo_int ep0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int disable_fifo_int(struct fusb300_ep *ep)\n{\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\n\tif (ep->epnum) {\n\t\tfusb300_disable_bit(fusb300, FUSB300_OFFSET_IGER0,\n\t\t\tFUSB300_IGER0_EEPn_FIFO_INT(ep->epnum));\n\t} else {\n\t\tpr_err(\"can't disable_fifo_int ep0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void fusb300_set_cxlen(struct fusb300 *fusb300, u32 length)\n{\n\tu32 reg;\n\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_CSR);\n\treg &= ~FUSB300_CSR_LEN_MSK;\n\treg |= FUSB300_CSR_LEN(length);\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_CSR);\n}\n\n \nstatic void fusb300_wrcxf(struct fusb300_ep *ep,\n\t\t   struct fusb300_request *req)\n{\n\tint i = 0;\n\tu8 *tmp;\n\tu32 data;\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\tu32 length = req->req.length - req->req.actual;\n\n\ttmp = req->req.buf + req->req.actual;\n\n\tif (length > SS_CTL_MAX_PACKET_SIZE) {\n\t\tfusb300_set_cxlen(fusb300, SS_CTL_MAX_PACKET_SIZE);\n\t\tfor (i = (SS_CTL_MAX_PACKET_SIZE >> 2); i > 0; i--) {\n\t\t\tdata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16 |\n\t\t\t\t*(tmp + 3) << 24;\n\t\t\tiowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\t\ttmp += 4;\n\t\t}\n\t\treq->req.actual += SS_CTL_MAX_PACKET_SIZE;\n\t} else {  \n\t\tfusb300_set_cxlen(fusb300, length);\n\t\tfor (i = length >> 2; i > 0; i--) {\n\t\t\tdata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16 |\n\t\t\t\t*(tmp + 3) << 24;\n\t\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t\tiowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\t\ttmp = tmp + 4;\n\t\t}\n\t\tswitch (length % 4) {\n\t\tcase 1:\n\t\t\tdata = *tmp;\n\t\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t\tiowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata = *tmp | *(tmp + 1) << 8;\n\t\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t\tiowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdata = *tmp | *(tmp + 1) << 8 | *(tmp + 2) << 16;\n\t\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t\tiowrite32(data, fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treq->req.actual += length;\n\t}\n}\n\nstatic void fusb300_set_epnstall(struct fusb300 *fusb300, u8 ep)\n{\n\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_EPSET0(ep),\n\t\tFUSB300_EPSET0_STL);\n}\n\nstatic void fusb300_clear_epnstall(struct fusb300 *fusb300, u8 ep)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\n\n\tif (reg & FUSB300_EPSET0_STL) {\n\t\tprintk(KERN_DEBUG \"EP%d stall... Clear!!\\n\", ep);\n\t\treg |= FUSB300_EPSET0_STL_CLR;\n\t\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\n\t}\n}\n\nstatic void ep0_queue(struct fusb300_ep *ep, struct fusb300_request *req)\n{\n\tif (ep->fusb300->ep0_dir) {  \n\t\tif (req->req.length) {\n\t\t\tfusb300_wrcxf(ep, req);\n\t\t} else\n\t\t\tprintk(KERN_DEBUG \"%s : req->req.length = 0x%x\\n\",\n\t\t\t\t__func__, req->req.length);\n\t\tif ((req->req.length == req->req.actual) ||\n\t\t    (req->req.actual < ep->ep.maxpacket))\n\t\t\tdone(ep, req, 0);\n\t} else {  \n\t\tif (!req->req.length)\n\t\t\tdone(ep, req, 0);\n\t\telse\n\t\t\tfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_IGER1,\n\t\t\t\tFUSB300_IGER1_CX_OUT_INT);\n\t}\n}\n\nstatic int fusb300_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t gfp_t gfp_flags)\n{\n\tstruct fusb300_ep *ep;\n\tstruct fusb300_request *req;\n\tunsigned long flags;\n\tint request  = 0;\n\n\tep = container_of(_ep, struct fusb300_ep, ep);\n\treq = container_of(_req, struct fusb300_request, req);\n\n\tif (ep->fusb300->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&ep->fusb300->lock, flags);\n\n\tif (list_empty(&ep->queue))\n\t\trequest = 1;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\n\tif (ep->ep.desc == NULL)  \n\t\tep0_queue(ep, req);\n\telse if (request && !ep->stall)\n\t\tenable_fifo_int(ep);\n\n\tspin_unlock_irqrestore(&ep->fusb300->lock, flags);\n\n\treturn 0;\n}\n\nstatic int fusb300_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct fusb300_ep *ep;\n\tstruct fusb300_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct fusb300_ep, ep);\n\treq = container_of(_req, struct fusb300_request, req);\n\n\tspin_lock_irqsave(&ep->fusb300->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\tdone(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&ep->fusb300->lock, flags);\n\n\treturn 0;\n}\n\nstatic int fusb300_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedge)\n{\n\tstruct fusb300_ep *ep;\n\tstruct fusb300 *fusb300;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tep = container_of(_ep, struct fusb300_ep, ep);\n\n\tfusb300 = ep->fusb300;\n\n\tspin_lock_irqsave(&ep->fusb300->lock, flags);\n\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (value) {\n\t\tfusb300_set_epnstall(fusb300, ep->epnum);\n\t\tep->stall = 1;\n\t\tif (wedge)\n\t\t\tep->wedged = 1;\n\t} else {\n\t\tfusb300_clear_epnstall(fusb300, ep->epnum);\n\t\tep->stall = 0;\n\t\tep->wedged = 0;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&ep->fusb300->lock, flags);\n\treturn ret;\n}\n\nstatic int fusb300_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn fusb300_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int fusb300_set_wedge(struct usb_ep *_ep)\n{\n\treturn fusb300_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic void fusb300_fifo_flush(struct usb_ep *_ep)\n{\n}\n\nstatic const struct usb_ep_ops fusb300_ep_ops = {\n\t.enable\t\t= fusb300_enable,\n\t.disable\t= fusb300_disable,\n\n\t.alloc_request\t= fusb300_alloc_request,\n\t.free_request\t= fusb300_free_request,\n\n\t.queue\t\t= fusb300_queue,\n\t.dequeue\t= fusb300_dequeue,\n\n\t.set_halt\t= fusb300_set_halt,\n\t.fifo_flush\t= fusb300_fifo_flush,\n\t.set_wedge\t= fusb300_set_wedge,\n};\n\n \nstatic void fusb300_clear_int(struct fusb300 *fusb300, u32 offset,\n\t\t       u32 value)\n{\n\tiowrite32(value, fusb300->reg + offset);\n}\n\nstatic void fusb300_reset(void)\n{\n}\n\nstatic void fusb300_set_cxstall(struct fusb300 *fusb300)\n{\n\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_CSR,\n\t\t\t   FUSB300_CSR_STL);\n}\n\nstatic void fusb300_set_cxdone(struct fusb300 *fusb300)\n{\n\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_CSR,\n\t\t\t   FUSB300_CSR_DONE);\n}\n\n \nstatic void fusb300_rdcxf(struct fusb300 *fusb300,\n\t\t   u8 *buffer, u32 length)\n{\n\tint i = 0;\n\tu8 *tmp;\n\tu32 data;\n\n\ttmp = buffer;\n\n\tfor (i = (length >> 2); i > 0; i--) {\n\t\tdata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\t*(tmp + 3) = (data >> 24) & 0xFF;\n\t\ttmp = tmp + 4;\n\t}\n\n\tswitch (length % 4) {\n\tcase 1:\n\t\tdata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t*tmp = data & 0xFF;\n\t\tbreak;\n\tcase 2:\n\t\tdata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\tbreak;\n\tcase 3:\n\t\tdata = ioread32(fusb300->reg + FUSB300_OFFSET_CXPORT);\n\t\tprintk(KERN_DEBUG \"    0x%x\\n\", data);\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void fusb300_rdfifo(struct fusb300_ep *ep,\n\t\t\t  struct fusb300_request *req,\n\t\t\t  u32 length)\n{\n\tint i = 0;\n\tu8 *tmp;\n\tu32 data, reg;\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\n\ttmp = req->req.buf + req->req.actual;\n\treq->req.actual += length;\n\n\tif (req->req.actual > req->req.length)\n\t\tprintk(KERN_DEBUG \"req->req.actual > req->req.length\\n\");\n\n\tfor (i = (length >> 2); i > 0; i--) {\n\t\tdata = ioread32(fusb300->reg +\n\t\t\tFUSB300_OFFSET_EPPORT(ep->epnum));\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\t*(tmp + 3) = (data >> 24) & 0xFF;\n\t\ttmp = tmp + 4;\n\t}\n\n\tswitch (length % 4) {\n\tcase 1:\n\t\tdata = ioread32(fusb300->reg +\n\t\t\tFUSB300_OFFSET_EPPORT(ep->epnum));\n\t\t*tmp = data & 0xFF;\n\t\tbreak;\n\tcase 2:\n\t\tdata = ioread32(fusb300->reg +\n\t\t\tFUSB300_OFFSET_EPPORT(ep->epnum));\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\tbreak;\n\tcase 3:\n\t\tdata = ioread32(fusb300->reg +\n\t\t\tFUSB300_OFFSET_EPPORT(ep->epnum));\n\t\t*tmp = data & 0xFF;\n\t\t*(tmp + 1) = (data >> 8) & 0xFF;\n\t\t*(tmp + 2) = (data >> 16) & 0xFF;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdo {\n\t\treg = ioread32(fusb300->reg + FUSB300_OFFSET_IGR1);\n\t\treg &= FUSB300_IGR1_SYNF0_EMPTY_INT;\n\t\tif (i)\n\t\t\tprintk(KERN_INFO \"sync fifo is not empty!\\n\");\n\t\ti++;\n\t} while (!reg);\n}\n\nstatic u8 fusb300_get_epnstall(struct fusb300 *fusb300, u8 ep)\n{\n\tu8 value;\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPSET0(ep));\n\n\tvalue = reg & FUSB300_EPSET0_STL;\n\n\treturn value;\n}\n\nstatic u8 fusb300_get_cxstall(struct fusb300 *fusb300)\n{\n\tu8 value;\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_CSR);\n\n\tvalue = (reg & FUSB300_CSR_STL) >> 1;\n\n\treturn value;\n}\n\nstatic void request_error(struct fusb300 *fusb300)\n{\n\tfusb300_set_cxstall(fusb300);\n\tprintk(KERN_DEBUG \"request error!!\\n\");\n}\n\nstatic void get_status(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\n__releases(fusb300->lock)\n__acquires(fusb300->lock)\n{\n\tu8 ep;\n\tu16 status = 0;\n\tu16 w_index = ctrl->wIndex;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = w_index & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (ep) {\n\t\t\tif (fusb300_get_epnstall(fusb300, ep))\n\t\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\t} else {\n\t\t\tif (fusb300_get_cxstall(fusb300))\n\t\t\t\tstatus = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trequest_error(fusb300);\n\t\treturn;\t\t \n\t}\n\n\tfusb300->ep0_data = cpu_to_le16(status);\n\tfusb300->ep0_req->buf = &fusb300->ep0_data;\n\tfusb300->ep0_req->length = 2;\n\n\tspin_unlock(&fusb300->lock);\n\tfusb300_queue(fusb300->gadget.ep0, fusb300->ep0_req, GFP_KERNEL);\n\tspin_lock(&fusb300->lock);\n}\n\nstatic void set_feature(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\n{\n\tu8 ep;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tfusb300_set_cxdone(fusb300);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tfusb300_set_cxdone(fusb300);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\t\tep = w_index & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (ep)\n\t\t\tfusb300_set_epnstall(fusb300, ep);\n\t\telse\n\t\t\tfusb300_set_cxstall(fusb300);\n\t\tfusb300_set_cxdone(fusb300);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trequest_error(fusb300);\n\t\tbreak;\n\t}\n}\n\nstatic void fusb300_clear_seqnum(struct fusb300 *fusb300, u8 ep)\n{\n\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_EPSET0(ep),\n\t\t\t    FUSB300_EPSET0_CLRSEQNUM);\n}\n\nstatic void clear_feature(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\n{\n\tstruct fusb300_ep *ep =\n\t\tfusb300->ep[ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK];\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tfusb300_set_cxdone(fusb300);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tfusb300_set_cxdone(fusb300);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tif (ctrl->wIndex & USB_ENDPOINT_NUMBER_MASK) {\n\t\t\tif (ep->wedged) {\n\t\t\t\tfusb300_set_cxdone(fusb300);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ep->stall) {\n\t\t\t\tep->stall = 0;\n\t\t\t\tfusb300_clear_seqnum(fusb300, ep->epnum);\n\t\t\t\tfusb300_clear_epnstall(fusb300, ep->epnum);\n\t\t\t\tif (!list_empty(&ep->queue))\n\t\t\t\t\tenable_fifo_int(ep);\n\t\t\t}\n\t\t}\n\t\tfusb300_set_cxdone(fusb300);\n\t\tbreak;\n\tdefault:\n\t\trequest_error(fusb300);\n\t\tbreak;\n\t}\n}\n\nstatic void fusb300_set_dev_addr(struct fusb300 *fusb300, u16 addr)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_DAR);\n\n\treg &= ~FUSB300_DAR_DRVADDR_MSK;\n\treg |= FUSB300_DAR_DRVADDR(addr);\n\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_DAR);\n}\n\nstatic void set_address(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\n{\n\tif (ctrl->wValue >= 0x0100)\n\t\trequest_error(fusb300);\n\telse {\n\t\tfusb300_set_dev_addr(fusb300, ctrl->wValue);\n\t\tfusb300_set_cxdone(fusb300);\n\t}\n}\n\n#define UVC_COPY_DESCRIPTORS(mem, src) \\\n\tdo { \\\n\t\tconst struct usb_descriptor_header * const *__src; \\\n\t\tfor (__src = src; *__src; ++__src) { \\\n\t\t\tmemcpy(mem, *__src, (*__src)->bLength); \\\n\t\t\tmem += (*__src)->bLength; \\\n\t\t} \\\n\t} while (0)\n\nstatic int setup_packet(struct fusb300 *fusb300, struct usb_ctrlrequest *ctrl)\n{\n\tu8 *p = (u8 *)ctrl;\n\tu8 ret = 0;\n\tu8 i = 0;\n\n\tfusb300_rdcxf(fusb300, p, 8);\n\tfusb300->ep0_dir = ctrl->bRequestType & USB_DIR_IN;\n\tfusb300->ep0_length = ctrl->wLength;\n\n\t \n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tget_status(fusb300, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tclear_feature(fusb300, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tset_feature(fusb300, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tset_address(fusb300, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_DAR,\n\t\t\t\t\t   FUSB300_DAR_SETCONFG);\n\t\t\t \n\t\t\tfor (i = 1; i <= FUSB300_MAX_NUM_EP; i++)\n\t\t\t\tfusb300_clear_seqnum(fusb300, i);\n\t\t\tfusb300->reenum = 1;\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic void done(struct fusb300_ep *ep, struct fusb300_request *req,\n\t\t int status)\n{\n\tlist_del_init(&req->queue);\n\n\t \n\tif (ep->fusb300->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treq->req.status = -ESHUTDOWN;\n\telse\n\t\treq->req.status = status;\n\n\tspin_unlock(&ep->fusb300->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->fusb300->lock);\n\n\tif (ep->epnum) {\n\t\tdisable_fifo_int(ep);\n\t\tif (!list_empty(&ep->queue))\n\t\t\tenable_fifo_int(ep);\n\t} else\n\t\tfusb300_set_cxdone(ep->fusb300);\n}\n\nstatic void fusb300_fill_idma_prdtbl(struct fusb300_ep *ep, dma_addr_t d,\n\t\tu32 len)\n{\n\tu32 value;\n\tu32 reg;\n\n\t \n\tdo {\n\t\treg = ioread32(ep->fusb300->reg +\n\t\t\tFUSB300_OFFSET_EPPRD_W0(ep->epnum));\n\t\treg &= FUSB300_EPPRD0_H;\n\t} while (reg);\n\n\tiowrite32(d, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W1(ep->epnum));\n\n\tvalue = FUSB300_EPPRD0_BTC(len) | FUSB300_EPPRD0_H |\n\t\tFUSB300_EPPRD0_F | FUSB300_EPPRD0_L | FUSB300_EPPRD0_I;\n\tiowrite32(value, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W0(ep->epnum));\n\n\tiowrite32(0x0, ep->fusb300->reg + FUSB300_OFFSET_EPPRD_W2(ep->epnum));\n\n\tfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_EPPRDRDY,\n\t\tFUSB300_EPPRDR_EP_PRD_RDY(ep->epnum));\n}\n\nstatic void fusb300_wait_idma_finished(struct fusb300_ep *ep)\n{\n\tu32 reg;\n\n\tdo {\n\t\treg = ioread32(ep->fusb300->reg + FUSB300_OFFSET_IGR1);\n\t\tif ((reg & FUSB300_IGR1_VBUS_CHG_INT) ||\n\t\t    (reg & FUSB300_IGR1_WARM_RST_INT) ||\n\t\t    (reg & FUSB300_IGR1_HOT_RST_INT) ||\n\t\t    (reg & FUSB300_IGR1_USBRST_INT)\n\t\t)\n\t\t\tgoto IDMA_RESET;\n\t\treg = ioread32(ep->fusb300->reg + FUSB300_OFFSET_IGR0);\n\t\treg &= FUSB300_IGR0_EPn_PRD_INT(ep->epnum);\n\t} while (!reg);\n\n\tfusb300_clear_int(ep->fusb300, FUSB300_OFFSET_IGR0,\n\t\tFUSB300_IGR0_EPn_PRD_INT(ep->epnum));\n\treturn;\n\nIDMA_RESET:\n\treg = ioread32(ep->fusb300->reg + FUSB300_OFFSET_IGER0);\n\treg &= ~FUSB300_IGER0_EEPn_PRD_INT(ep->epnum);\n\tiowrite32(reg, ep->fusb300->reg + FUSB300_OFFSET_IGER0);\n}\n\nstatic void fusb300_set_idma(struct fusb300_ep *ep,\n\t\t\tstruct fusb300_request *req)\n{\n\tint ret;\n\n\tret = usb_gadget_map_request(&ep->fusb300->gadget,\n\t\t\t&req->req, DMA_TO_DEVICE);\n\tif (ret)\n\t\treturn;\n\n\tfusb300_enable_bit(ep->fusb300, FUSB300_OFFSET_IGER0,\n\t\tFUSB300_IGER0_EEPn_PRD_INT(ep->epnum));\n\n\tfusb300_fill_idma_prdtbl(ep, req->req.dma, req->req.length);\n\t \n\tfusb300_wait_idma_finished(ep);\n\n\tusb_gadget_unmap_request(&ep->fusb300->gadget,\n\t\t\t&req->req, DMA_TO_DEVICE);\n}\n\nstatic void in_ep_fifo_handler(struct fusb300_ep *ep)\n{\n\tstruct fusb300_request *req = list_entry(ep->queue.next,\n\t\t\t\t\tstruct fusb300_request, queue);\n\n\tif (req->req.length)\n\t\tfusb300_set_idma(ep, req);\n\tdone(ep, req, 0);\n}\n\nstatic void out_ep_fifo_handler(struct fusb300_ep *ep)\n{\n\tstruct fusb300 *fusb300 = ep->fusb300;\n\tstruct fusb300_request *req = list_entry(ep->queue.next,\n\t\t\t\t\t\t struct fusb300_request, queue);\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_EPFFR(ep->epnum));\n\tu32 length = reg & FUSB300_FFR_BYCNT;\n\n\tfusb300_rdfifo(ep, req, length);\n\n\t \n\tif ((req->req.length == req->req.actual) || (length < ep->ep.maxpacket))\n\t\tdone(ep, req, 0);\n}\n\nstatic void check_device_mode(struct fusb300 *fusb300)\n{\n\tu32 reg = ioread32(fusb300->reg + FUSB300_OFFSET_GCR);\n\n\tswitch (reg & FUSB300_GCR_DEVEN_MSK) {\n\tcase FUSB300_GCR_DEVEN_SS:\n\t\tfusb300->gadget.speed = USB_SPEED_SUPER;\n\t\tbreak;\n\tcase FUSB300_GCR_DEVEN_HS:\n\t\tfusb300->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase FUSB300_GCR_DEVEN_FS:\n\t\tfusb300->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\tdefault:\n\t\tfusb300->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\tprintk(KERN_INFO \"dev_mode = %d\\n\", (reg & FUSB300_GCR_DEVEN_MSK));\n}\n\n\nstatic void fusb300_ep0out(struct fusb300 *fusb300)\n{\n\tstruct fusb300_ep *ep = fusb300->ep[0];\n\tu32 reg;\n\n\tif (!list_empty(&ep->queue)) {\n\t\tstruct fusb300_request *req;\n\n\t\treq = list_first_entry(&ep->queue,\n\t\t\tstruct fusb300_request, queue);\n\t\tif (req->req.length)\n\t\t\tfusb300_rdcxf(ep->fusb300, req->req.buf,\n\t\t\t\treq->req.length);\n\t\tdone(ep, req, 0);\n\t\treg = ioread32(fusb300->reg + FUSB300_OFFSET_IGER1);\n\t\treg &= ~FUSB300_IGER1_CX_OUT_INT;\n\t\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_IGER1);\n\t} else\n\t\tpr_err(\"%s : empty queue\\n\", __func__);\n}\n\nstatic void fusb300_ep0in(struct fusb300 *fusb300)\n{\n\tstruct fusb300_request *req;\n\tstruct fusb300_ep *ep = fusb300->ep[0];\n\n\tif ((!list_empty(&ep->queue)) && (fusb300->ep0_dir)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\t\tstruct fusb300_request, queue);\n\t\tif (req->req.length)\n\t\t\tfusb300_wrcxf(ep, req);\n\t\tif ((req->req.length - req->req.actual) < ep->ep.maxpacket)\n\t\t\tdone(ep, req, 0);\n\t} else\n\t\tfusb300_set_cxdone(fusb300);\n}\n\nstatic void fusb300_grp2_handler(void)\n{\n}\n\nstatic void fusb300_grp3_handler(void)\n{\n}\n\nstatic void fusb300_grp4_handler(void)\n{\n}\n\nstatic void fusb300_grp5_handler(void)\n{\n}\n\nstatic irqreturn_t fusb300_irq(int irq, void *_fusb300)\n{\n\tstruct fusb300 *fusb300 = _fusb300;\n\tu32 int_grp1 = ioread32(fusb300->reg + FUSB300_OFFSET_IGR1);\n\tu32 int_grp1_en = ioread32(fusb300->reg + FUSB300_OFFSET_IGER1);\n\tu32 int_grp0 = ioread32(fusb300->reg + FUSB300_OFFSET_IGR0);\n\tu32 int_grp0_en = ioread32(fusb300->reg + FUSB300_OFFSET_IGER0);\n\tstruct usb_ctrlrequest ctrl;\n\tu8 in;\n\tu32 reg;\n\tint i;\n\n\tspin_lock(&fusb300->lock);\n\n\tint_grp1 &= int_grp1_en;\n\tint_grp0 &= int_grp0_en;\n\n\tif (int_grp1 & FUSB300_IGR1_WARM_RST_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_WARM_RST_INT);\n\t\tprintk(KERN_INFO\"fusb300_warmreset\\n\");\n\t\tfusb300_reset();\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_HOT_RST_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_HOT_RST_INT);\n\t\tprintk(KERN_INFO\"fusb300_hotreset\\n\");\n\t\tfusb300_reset();\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_USBRST_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_USBRST_INT);\n\t\tfusb300_reset();\n\t}\n\t \n\n\tif (int_grp1 & FUSB300_IGR1_CX_COMABT_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_CX_COMABT_INT);\n\t\tprintk(KERN_INFO\"fusb300_ep0abt\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_VBUS_CHG_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_VBUS_CHG_INT);\n\t\tprintk(KERN_INFO\"fusb300_vbus_change\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U3_EXIT_FAIL_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U3_EXIT_FAIL_INT);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U2_EXIT_FAIL_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U2_EXIT_FAIL_INT);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U1_EXIT_FAIL_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U1_EXIT_FAIL_INT);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U2_ENTRY_FAIL_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U2_ENTRY_FAIL_INT);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U1_ENTRY_FAIL_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U1_ENTRY_FAIL_INT);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U3_EXIT_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U3_EXIT_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U3_EXIT_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U2_EXIT_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U2_EXIT_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U2_EXIT_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U1_EXIT_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U1_EXIT_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U1_EXIT_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U3_ENTRY_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U3_ENTRY_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U3_ENTRY_INT\\n\");\n\t\tfusb300_enable_bit(fusb300, FUSB300_OFFSET_SSCR1,\n\t\t\t\t   FUSB300_SSCR1_GO_U3_DONE);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U2_ENTRY_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U2_ENTRY_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U2_ENTRY_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_U1_ENTRY_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_U1_ENTRY_INT);\n\t\tprintk(KERN_INFO \"FUSB300_IGR1_U1_ENTRY_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_RESM_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_RESM_INT);\n\t\tprintk(KERN_INFO \"fusb300_resume\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_SUSP_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_SUSP_INT);\n\t\tprintk(KERN_INFO \"fusb300_suspend\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_HS_LPM_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_HS_LPM_INT);\n\t\tprintk(KERN_INFO \"fusb300_HS_LPM_INT\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_DEV_MODE_CHG_INT) {\n\t\tfusb300_clear_int(fusb300, FUSB300_OFFSET_IGR1,\n\t\t\t\t  FUSB300_IGR1_DEV_MODE_CHG_INT);\n\t\tcheck_device_mode(fusb300);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_CX_COMFAIL_INT) {\n\t\tfusb300_set_cxstall(fusb300);\n\t\tprintk(KERN_INFO \"fusb300_ep0fail\\n\");\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_CX_SETUP_INT) {\n\t\tprintk(KERN_INFO \"fusb300_ep0setup\\n\");\n\t\tif (setup_packet(fusb300, &ctrl)) {\n\t\t\tspin_unlock(&fusb300->lock);\n\t\t\tif (fusb300->driver->setup(&fusb300->gadget, &ctrl) < 0)\n\t\t\t\tfusb300_set_cxstall(fusb300);\n\t\t\tspin_lock(&fusb300->lock);\n\t\t}\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_CX_CMDEND_INT)\n\t\tprintk(KERN_INFO \"fusb300_cmdend\\n\");\n\n\n\tif (int_grp1 & FUSB300_IGR1_CX_OUT_INT) {\n\t\tprintk(KERN_INFO \"fusb300_cxout\\n\");\n\t\tfusb300_ep0out(fusb300);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_CX_IN_INT) {\n\t\tprintk(KERN_INFO \"fusb300_cxin\\n\");\n\t\tfusb300_ep0in(fusb300);\n\t}\n\n\tif (int_grp1 & FUSB300_IGR1_INTGRP5)\n\t\tfusb300_grp5_handler();\n\n\tif (int_grp1 & FUSB300_IGR1_INTGRP4)\n\t\tfusb300_grp4_handler();\n\n\tif (int_grp1 & FUSB300_IGR1_INTGRP3)\n\t\tfusb300_grp3_handler();\n\n\tif (int_grp1 & FUSB300_IGR1_INTGRP2)\n\t\tfusb300_grp2_handler();\n\n\tif (int_grp0) {\n\t\tfor (i = 1; i < FUSB300_MAX_NUM_EP; i++) {\n\t\t\tif (int_grp0 & FUSB300_IGR0_EPn_FIFO_INT(i)) {\n\t\t\t\treg = ioread32(fusb300->reg +\n\t\t\t\t\tFUSB300_OFFSET_EPSET1(i));\n\t\t\t\tin = (reg & FUSB300_EPSET1_DIRIN) ? 1 : 0;\n\t\t\t\tif (in)\n\t\t\t\t\tin_ep_fifo_handler(fusb300->ep[i]);\n\t\t\t\telse\n\t\t\t\t\tout_ep_fifo_handler(fusb300->ep[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&fusb300->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fusb300_set_u2_timeout(struct fusb300 *fusb300,\n\t\t\t\t   u32 time)\n{\n\tu32 reg;\n\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_TT);\n\treg &= ~0xff;\n\treg |= FUSB300_SSCR2_U2TIMEOUT(time);\n\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_TT);\n}\n\nstatic void fusb300_set_u1_timeout(struct fusb300 *fusb300,\n\t\t\t\t   u32 time)\n{\n\tu32 reg;\n\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_TT);\n\treg &= ~(0xff << 8);\n\treg |= FUSB300_SSCR2_U1TIMEOUT(time);\n\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_TT);\n}\n\nstatic void init_controller(struct fusb300 *fusb300)\n{\n\tu32 reg;\n\tu32 mask = 0;\n\tu32 val = 0;\n\n\t \n\tmask = val = FUSB300_AHBBCR_S0_SPLIT_ON | FUSB300_AHBBCR_S1_SPLIT_ON;\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_AHBCR);\n\treg &= ~mask;\n\treg |= val;\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_AHBCR);\n\n\t \n\tmask = val = FUSB300_HSCR_HS_LPM_PERMIT;\n\treg = ioread32(fusb300->reg + FUSB300_OFFSET_HSCR);\n\treg &= ~mask;\n\treg |= val;\n\tiowrite32(reg, fusb300->reg + FUSB300_OFFSET_HSCR);\n\n\t \n\tfusb300_set_u2_timeout(fusb300, 0xff);\n\tfusb300_set_u1_timeout(fusb300, 0xff);\n\n\t \n\tiowrite32(0xcfffff9f, fusb300->reg + FUSB300_OFFSET_IGER1);\n}\n \nstatic int fusb300_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct fusb300 *fusb300 = to_fusb300(g);\n\n\t \n\tfusb300->driver = driver;\n\n\treturn 0;\n}\n\nstatic int fusb300_udc_stop(struct usb_gadget *g)\n{\n\tstruct fusb300 *fusb300 = to_fusb300(g);\n\n\tinit_controller(fusb300);\n\tfusb300->driver = NULL;\n\n\treturn 0;\n}\n \n\nstatic int fusb300_udc_pullup(struct usb_gadget *_gadget, int is_active)\n{\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops fusb300_gadget_ops = {\n\t.pullup\t\t= fusb300_udc_pullup,\n\t.udc_start\t= fusb300_udc_start,\n\t.udc_stop\t= fusb300_udc_stop,\n};\n\nstatic void fusb300_remove(struct platform_device *pdev)\n{\n\tstruct fusb300 *fusb300 = platform_get_drvdata(pdev);\n\tint i;\n\n\tusb_del_gadget_udc(&fusb300->gadget);\n\tiounmap(fusb300->reg);\n\tfree_irq(platform_get_irq(pdev, 0), fusb300);\n\tfree_irq(platform_get_irq(pdev, 1), fusb300);\n\n\tfusb300_free_request(&fusb300->ep[0]->ep, fusb300->ep0_req);\n\tfor (i = 0; i < FUSB300_MAX_NUM_EP; i++)\n\t\tkfree(fusb300->ep[i]);\n\tkfree(fusb300);\n}\n\nstatic int fusb300_probe(struct platform_device *pdev)\n{\n\tstruct resource *res, *ires, *ires1;\n\tvoid __iomem *reg = NULL;\n\tstruct fusb300 *fusb300 = NULL;\n\tstruct fusb300_ep *_ep[FUSB300_MAX_NUM_EP];\n\tint ret = 0;\n\tint i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tpr_err(\"platform_get_resource error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!ires) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev,\n\t\t\t\"platform_get_resource IORESOURCE_IRQ error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tires1 = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\n\tif (!ires1) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev,\n\t\t\t\"platform_get_resource IORESOURCE_IRQ 1 error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\treg = ioremap(res->start, resource_size(res));\n\tif (reg == NULL) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"ioremap error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\t \n\tfusb300 = kzalloc(sizeof(struct fusb300), GFP_KERNEL);\n\tif (fusb300 == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto clean_up;\n\t}\n\n\tfor (i = 0; i < FUSB300_MAX_NUM_EP; i++) {\n\t\t_ep[i] = kzalloc(sizeof(struct fusb300_ep), GFP_KERNEL);\n\t\tif (_ep[i] == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto clean_up;\n\t\t}\n\t\tfusb300->ep[i] = _ep[i];\n\t}\n\n\tspin_lock_init(&fusb300->lock);\n\n\tplatform_set_drvdata(pdev, fusb300);\n\n\tfusb300->gadget.ops = &fusb300_gadget_ops;\n\n\tfusb300->gadget.max_speed = USB_SPEED_HIGH;\n\tfusb300->gadget.name = udc_name;\n\tfusb300->reg = reg;\n\n\tret = request_irq(ires->start, fusb300_irq, IRQF_SHARED,\n\t\t\t  udc_name, fusb300);\n\tif (ret < 0) {\n\t\tpr_err(\"request_irq error (%d)\\n\", ret);\n\t\tgoto clean_up;\n\t}\n\n\tret = request_irq(ires1->start, fusb300_irq,\n\t\t\tIRQF_SHARED, udc_name, fusb300);\n\tif (ret < 0) {\n\t\tpr_err(\"request_irq1 error (%d)\\n\", ret);\n\t\tgoto err_request_irq1;\n\t}\n\n\tINIT_LIST_HEAD(&fusb300->gadget.ep_list);\n\n\tfor (i = 0; i < FUSB300_MAX_NUM_EP ; i++) {\n\t\tstruct fusb300_ep *ep = fusb300->ep[i];\n\n\t\tif (i != 0) {\n\t\t\tINIT_LIST_HEAD(&fusb300->ep[i]->ep.ep_list);\n\t\t\tlist_add_tail(&fusb300->ep[i]->ep.ep_list,\n\t\t\t\t     &fusb300->gadget.ep_list);\n\t\t}\n\t\tep->fusb300 = fusb300;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tep->ep.name = fusb300_ep_name[i];\n\t\tep->ep.ops = &fusb300_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, HS_BULK_MAX_PACKET_SIZE);\n\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\tusb_ep_set_maxpacket_limit(&fusb300->ep[0]->ep, HS_CTL_MAX_PACKET_SIZE);\n\tfusb300->ep[0]->epnum = 0;\n\tfusb300->gadget.ep0 = &fusb300->ep[0]->ep;\n\tINIT_LIST_HEAD(&fusb300->gadget.ep0->ep_list);\n\n\tfusb300->ep0_req = fusb300_alloc_request(&fusb300->ep[0]->ep,\n\t\t\t\tGFP_KERNEL);\n\tif (fusb300->ep0_req == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_request;\n\t}\n\n\tinit_controller(fusb300);\n\tret = usb_add_gadget_udc(&pdev->dev, &fusb300->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\n\tdev_info(&pdev->dev, \"version %s\\n\", DRIVER_VERSION);\n\n\treturn 0;\n\nerr_add_udc:\n\tfusb300_free_request(&fusb300->ep[0]->ep, fusb300->ep0_req);\n\nerr_alloc_request:\n\tfree_irq(ires1->start, fusb300);\n\nerr_request_irq1:\n\tfree_irq(ires->start, fusb300);\n\nclean_up:\n\tif (fusb300) {\n\t\tif (fusb300->ep0_req)\n\t\t\tfusb300_free_request(&fusb300->ep[0]->ep,\n\t\t\t\tfusb300->ep0_req);\n\t\tfor (i = 0; i < FUSB300_MAX_NUM_EP; i++)\n\t\t\tkfree(fusb300->ep[i]);\n\t\tkfree(fusb300);\n\t}\n\tif (reg)\n\t\tiounmap(reg);\n\n\treturn ret;\n}\n\nstatic struct platform_driver fusb300_driver = {\n\t.remove_new =\tfusb300_remove,\n\t.driver\t\t= {\n\t\t.name =\tudc_name,\n\t},\n};\n\nmodule_platform_driver_probe(fusb300_driver, fusb300_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}