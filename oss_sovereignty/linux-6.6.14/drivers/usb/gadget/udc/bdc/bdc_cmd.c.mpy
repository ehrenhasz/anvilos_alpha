{
  "module_name": "bdc_cmd.c",
  "hash_id": "cdb141f30a6b1b790fafc3251c16b6623c78448a118900b8d24c3665fdca61be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/bdc/bdc_cmd.c",
  "human_readable_source": "\n \n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\n#include \"bdc.h\"\n#include \"bdc_cmd.h\"\n#include \"bdc_dbg.h\"\n\n \nstatic int bdc_issue_cmd(struct bdc *bdc, u32 cmd_sc, u32 param0,\n\t\t\t\t\t\t\tu32 param1, u32 param2)\n{\n\tu32 timeout = BDC_CMD_TIMEOUT;\n\tu32 cmd_status;\n\tu32 temp;\n\n\tbdc_writel(bdc->regs, BDC_CMDPAR0, param0);\n\tbdc_writel(bdc->regs, BDC_CMDPAR1, param1);\n\tbdc_writel(bdc->regs, BDC_CMDPAR2, param2);\n\n\t \n\t \n\twmb();\n\tbdc_writel(bdc->regs, BDC_CMDSC, cmd_sc | BDC_CMD_CWS | BDC_CMD_SRD);\n\tdo {\n\t\ttemp = bdc_readl(bdc->regs, BDC_CMDSC);\n\t\tdev_dbg_ratelimited(bdc->dev, \"cmdsc=%x\", temp);\n\t\tcmd_status =  BDC_CMD_CST(temp);\n\t\tif (cmd_status != BDC_CMDS_BUSY)  {\n\t\t\tdev_dbg(bdc->dev,\n\t\t\t\t\"command completed cmd_sts:%x\\n\", cmd_status);\n\t\t\treturn cmd_status;\n\t\t}\n\t\tudelay(1);\n\t} while (timeout--);\n\n\tdev_err(bdc->dev,\n\t\t\"command operation timedout cmd_status=%d\\n\", cmd_status);\n\n\treturn cmd_status;\n}\n\n \nstatic int bdc_submit_cmd(struct bdc *bdc, u32 cmd_sc,\n\t\t\t\t\tu32 param0, u32 param1,\tu32 param2)\n{\n\tu32 temp, cmd_status;\n\tint ret;\n\n\ttemp = bdc_readl(bdc->regs, BDC_CMDSC);\n\tdev_dbg(bdc->dev,\n\t\t\"%s:CMDSC:%08x cmdsc:%08x param0=%08x param1=%08x param2=%08x\\n\",\n\t\t __func__, temp, cmd_sc, param0, param1, param2);\n\n\tcmd_status = BDC_CMD_CST(temp);\n\tif (cmd_status  ==  BDC_CMDS_BUSY) {\n\t\tdev_err(bdc->dev, \"command processor busy: %x\\n\", cmd_status);\n\t\treturn -EBUSY;\n\t}\n\tret = bdc_issue_cmd(bdc, cmd_sc, param0, param1, param2);\n\tswitch (ret) {\n\tcase BDC_CMDS_SUCC:\n\t\tdev_dbg(bdc->dev, \"command completed successfully\\n\");\n\t\tret = 0;\n\t\tbreak;\n\n\tcase BDC_CMDS_PARA:\n\t\tdev_err(bdc->dev, \"command parameter error\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase BDC_CMDS_STAT:\n\t\tdev_err(bdc->dev, \"Invalid device/ep state\\n\");\n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tcase BDC_CMDS_FAIL:\n\t\tdev_err(bdc->dev, \"Command failed?\\n\");\n\t\tret = -EAGAIN;\n\t\tbreak;\n\n\tcase BDC_CMDS_INTL:\n\t\tdev_err(bdc->dev, \"BDC Internal error\\n\");\n\t\tret = -ECONNRESET;\n\t\tbreak;\n\n\tcase BDC_CMDS_BUSY:\n\t\tdev_err(bdc->dev,\n\t\t\t\"command timedout waited for %dusec\\n\",\n\t\t\tBDC_CMD_TIMEOUT);\n\t\tret = -ECONNRESET;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(bdc->dev, \"Unknown command completion code:%x\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\n \nint bdc_dconfig_ep(struct bdc *bdc, struct bdc_ep *ep)\n{\n\tu32 cmd_sc;\n\n\tcmd_sc = BDC_SUB_CMD_DRP_EP|BDC_CMD_EPN(ep->ep_num)|BDC_CMD_EPC;\n\tdev_dbg(bdc->dev, \"%s ep->ep_num =%d cmd_sc=%x\\n\", __func__,\n\t\t\t\t\t\t\tep->ep_num, cmd_sc);\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\n}\n\n \nstatic void ep_bd_list_reinit(struct bdc_ep *ep)\n{\n\tstruct bdc *bdc = ep->bdc;\n\tstruct bdc_bd *bd;\n\n\tep->bd_list.eqp_bdi = 0;\n\tep->bd_list.hwd_bdi = 0;\n\tbd = ep->bd_list.bd_table_array[0]->start_bd;\n\tdev_dbg(bdc->dev, \"%s ep:%p bd:%p\\n\", __func__, ep, bd);\n\tmemset(bd, 0, sizeof(struct bdc_bd));\n\tbd->offset[3] |= cpu_to_le32(BD_SBF);\n}\n\n \nint bdc_config_ep(struct bdc *bdc, struct bdc_ep *ep)\n{\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n\tconst struct usb_endpoint_descriptor\t*desc;\n\tu32 param0, param1, param2, cmd_sc;\n\tu32 mps, mbs, mul, si;\n\tint ret;\n\n\tdesc = ep->desc;\n\tcomp_desc = ep->comp_desc;\n\tcmd_sc = mul = mbs = param2 = 0;\n\tparam0 = lower_32_bits(ep->bd_list.bd_table_array[0]->dma);\n\tparam1 = upper_32_bits(ep->bd_list.bd_table_array[0]->dma);\n\tcpu_to_le32s(&param0);\n\tcpu_to_le32s(&param1);\n\n\tdev_dbg(bdc->dev, \"%s: param0=%08x param1=%08x\",\n\t\t\t\t\t\t__func__, param0, param1);\n\tsi = desc->bInterval;\n\tsi = clamp_val(si, 1, 16) - 1;\n\n\tmps = usb_endpoint_maxp(desc);\n\tparam2 |= mps << MP_SHIFT;\n\tparam2 |= usb_endpoint_type(desc) << EPT_SHIFT;\n\n\tswitch (bdc->gadget.speed) {\n\tcase USB_SPEED_SUPER:\n\t\tif (usb_endpoint_xfer_int(desc) ||\n\t\t\t\t\tusb_endpoint_xfer_isoc(desc)) {\n\t\t\tparam2 |= si;\n\t\t\tif (usb_endpoint_xfer_isoc(desc) && comp_desc)\n\t\t\t\tmul = comp_desc->bmAttributes;\n\n\t\t}\n\t\tparam2 |= mul << EPM_SHIFT;\n\t\tif (comp_desc)\n\t\t\tmbs = comp_desc->bMaxBurst;\n\t\tparam2 |= mbs << MB_SHIFT;\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\n\t\tif (usb_endpoint_xfer_isoc(desc) ||\n\t\t\t\t\tusb_endpoint_xfer_int(desc)) {\n\t\t\tparam2 |= si;\n\n\t\t\tmbs = usb_endpoint_maxp_mult(desc);\n\t\t\tparam2 |= mbs << MB_SHIFT;\n\t\t}\n\t\tbreak;\n\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_LOW:\n\t\t \n\t\tif (usb_endpoint_xfer_isoc(desc))\n\t\t\tsi += 3;\n\n\t\t \n\t\tif (usb_endpoint_xfer_int(desc))\n\t\t\tsi = fls(desc->bInterval * 8) - 1;\n\n\t\tparam2 |= si;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdc->dev, \"UNKNOWN speed ERR\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd_sc |= BDC_CMD_EPC|BDC_CMD_EPN(ep->ep_num)|BDC_SUB_CMD_ADD_EP;\n\n\tdev_dbg(bdc->dev, \"cmd_sc=%x param2=%08x\\n\", cmd_sc, param2);\n\tret = bdc_submit_cmd(bdc, cmd_sc, param0, param1, param2);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"command failed :%x\\n\", ret);\n\t\treturn ret;\n\t}\n\tep_bd_list_reinit(ep);\n\n\treturn ret;\n}\n\n \nint bdc_ep_bla(struct bdc *bdc, struct bdc_ep *ep, dma_addr_t dma_addr)\n{\n\tu32 param0, param1;\n\tu32 cmd_sc = 0;\n\n\tdev_dbg(bdc->dev, \"%s: add=%08llx\\n\", __func__,\n\t\t\t\t(unsigned long long)(dma_addr));\n\tparam0 = lower_32_bits(dma_addr);\n\tparam1 = upper_32_bits(dma_addr);\n\tcpu_to_le32s(&param0);\n\tcpu_to_le32s(&param1);\n\n\tcmd_sc |= BDC_CMD_EPN(ep->ep_num)|BDC_CMD_BLA;\n\tdev_dbg(bdc->dev, \"cmd_sc=%x\\n\", cmd_sc);\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, param0, param1, 0);\n}\n\n \nint bdc_address_device(struct bdc *bdc, u32 add)\n{\n\tu32 cmd_sc = 0;\n\tu32 param2;\n\n\tdev_dbg(bdc->dev, \"%s: add=%d\\n\", __func__, add);\n\tcmd_sc |=  BDC_SUB_CMD_ADD|BDC_CMD_DVC;\n\tparam2 = add & 0x7f;\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, param2);\n}\n\n \nint bdc_function_wake_fh(struct bdc *bdc, u8 intf)\n{\n\tu32 param0, param1;\n\tu32 cmd_sc = 0;\n\n\tparam0 = param1 = 0;\n\tdev_dbg(bdc->dev, \"%s intf=%d\\n\", __func__, intf);\n\tcmd_sc  |=  BDC_CMD_FH;\n\tparam0 |= TRA_PACKET;\n\tparam0 |= (bdc->dev_addr << 25);\n\tparam1 |= DEV_NOTF_TYPE;\n\tparam1 |= (FWK_SUBTYPE<<4);\n\tdev_dbg(bdc->dev, \"param0=%08x param1=%08x\\n\", param0, param1);\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, param0, param1, 0);\n}\n\n \nint bdc_function_wake(struct bdc *bdc, u8 intf)\n{\n\tu32 cmd_sc = 0;\n\tu32 param2 = 0;\n\n\tdev_dbg(bdc->dev, \"%s intf=%d\", __func__, intf);\n\tparam2 |= intf;\n\tcmd_sc |= BDC_SUB_CMD_FWK|BDC_CMD_DNC;\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, param2);\n}\n\n \nint bdc_ep_set_stall(struct bdc *bdc, int epnum)\n{\n\tu32 cmd_sc = 0;\n\n\tdev_dbg(bdc->dev, \"%s epnum=%d\\n\", __func__, epnum);\n\t \n\tcmd_sc |=  BDC_SUB_CMD_EP_STL | BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\n\n\treturn bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\n}\n\n \nint bdc_ep_clear_stall(struct bdc *bdc, int epnum)\n{\n\tstruct bdc_ep *ep;\n\tu32 cmd_sc = 0;\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s: epnum=%d\\n\", __func__, epnum);\n\tep = bdc->bdc_ep_array[epnum];\n\t \n\tif (epnum != 1) {\n\t\t \n\t\tif (!(ep->flags & BDC_EP_STALL)) {\n\t\t\tret = bdc_ep_set_stall(bdc, epnum);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\t \n\tif (epnum != 1)\n\t\tcmd_sc |= BDC_CMD_EPO_RST_SN;\n\n\t \n\tcmd_sc |=  BDC_SUB_CMD_EP_RST | BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\n\n\tret = bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"command failed:%x\\n\", ret);\n\t\treturn ret;\n\t}\n\tbdc_notify_xfr(bdc, epnum);\n\n\treturn ret;\n}\n\n \nint bdc_stop_ep(struct bdc *bdc, int epnum)\n{\n\tstruct bdc_ep *ep;\n\tu32 cmd_sc = 0;\n\tint ret;\n\n\tep = bdc->bdc_ep_array[epnum];\n\tdev_dbg(bdc->dev, \"%s: ep:%s ep->flags:%08x\\n\", __func__,\n\t\t\t\t\t\tep->name, ep->flags);\n\t \n\tif (!(ep->flags & BDC_EP_ENABLED)) {\n\t\tdev_err(bdc->dev, \"stop endpoint called for disabled ep\\n\");\n\t\treturn   -EINVAL;\n\t}\n\tif ((ep->flags & BDC_EP_STALL) || (ep->flags & BDC_EP_STOP))\n\t\treturn 0;\n\n\t \n\tcmd_sc |= BDC_CMD_EP0_XSD | BDC_SUB_CMD_EP_STP\n\t\t\t\t| BDC_CMD_EPN(epnum) | BDC_CMD_EPO;\n\n\tret = bdc_submit_cmd(bdc, cmd_sc, 0, 0, 0);\n\tif (ret) {\n\t\tdev_err(bdc->dev,\n\t\t\t\"stop endpoint command didn't complete:%d ep:%s\\n\",\n\t\t\tret, ep->name);\n\t\treturn ret;\n\t}\n\tep->flags |= BDC_EP_STOP;\n\tbdc_dump_epsts(bdc);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}