{
  "module_name": "bdc_ep.c",
  "hash_id": "2973f78fbb9906acdec8a8649b99a89bc8e7d44e57540de7136b7f194403702a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/bdc/bdc_ep.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/dmapool.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/pm.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <asm/unaligned.h>\n#include <linux/platform_device.h>\n#include <linux/usb/composite.h>\n\n#include \"bdc.h\"\n#include \"bdc_ep.h\"\n#include \"bdc_cmd.h\"\n#include \"bdc_dbg.h\"\n\nstatic const char * const ep0_state_string[] =  {\n\t\"WAIT_FOR_SETUP\",\n\t\"WAIT_FOR_DATA_START\",\n\t\"WAIT_FOR_DATA_XMIT\",\n\t\"WAIT_FOR_STATUS_START\",\n\t\"WAIT_FOR_STATUS_XMIT\",\n\t\"STATUS_PENDING\"\n};\n\n \nstatic void ep_bd_list_free(struct bdc_ep *ep, u32 num_tabs)\n{\n\tstruct bd_list *bd_list = &ep->bd_list;\n\tstruct bdc *bdc = ep->bdc;\n\tstruct bd_table *bd_table;\n\tint index;\n\n\tdev_dbg(bdc->dev, \"%s ep:%s num_tabs:%d\\n\",\n\t\t\t\t __func__, ep->name, num_tabs);\n\n\tif (!bd_list->bd_table_array) {\n\t\tdev_dbg(bdc->dev, \"%s already freed\\n\", ep->name);\n\t\treturn;\n\t}\n\tfor (index = 0; index < num_tabs; index++) {\n\t\t \n\t\tbd_table = bd_list->bd_table_array[index];\n\t\tdev_dbg(bdc->dev, \"bd_table:%p index:%d\\n\", bd_table, index);\n\t\tif (!bd_table) {\n\t\t\tdev_dbg(bdc->dev, \"bd_table not allocated\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (!bd_table->start_bd) {\n\t\t\tdev_dbg(bdc->dev, \"bd dma pool not allocated\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(bdc->dev,\n\t\t\t\t\"Free dma pool start_bd:%p dma:%llx\\n\",\n\t\t\t\tbd_table->start_bd,\n\t\t\t\t(unsigned long long)bd_table->dma);\n\n\t\tdma_pool_free(bdc->bd_table_pool,\n\t\t\t\tbd_table->start_bd,\n\t\t\t\tbd_table->dma);\n\t\t \n\t\tkfree(bd_table);\n\t}\n\t \n\tkfree(ep->bd_list.bd_table_array);\n}\n\n \nstatic inline void chain_table(struct bd_table *prev_table,\n\t\t\t\t\tstruct bd_table *next_table,\n\t\t\t\t\tu32 bd_p_tab)\n{\n\t \n\tprev_table->start_bd[bd_p_tab-1].offset[0] =\n\t\t\t\tcpu_to_le32(lower_32_bits(next_table->dma));\n\n\tprev_table->start_bd[bd_p_tab-1].offset[1] =\n\t\t\t\tcpu_to_le32(upper_32_bits(next_table->dma));\n\n\tprev_table->start_bd[bd_p_tab-1].offset[2] =\n\t\t\t\t0x0;\n\n\tprev_table->start_bd[bd_p_tab-1].offset[3] =\n\t\t\t\tcpu_to_le32(MARK_CHAIN_BD);\n}\n\n \nstatic int ep_bd_list_alloc(struct bdc_ep *ep)\n{\n\tstruct bd_table *prev_table = NULL;\n\tint index, num_tabs, bd_p_tab;\n\tstruct bdc *bdc = ep->bdc;\n\tstruct bd_table *bd_table;\n\tdma_addr_t dma;\n\n\tif (usb_endpoint_xfer_isoc(ep->desc))\n\t\tnum_tabs = NUM_TABLES_ISOCH;\n\telse\n\t\tnum_tabs = NUM_TABLES;\n\n\tbd_p_tab = NUM_BDS_PER_TABLE;\n\t \n\tdev_dbg(bdc->dev,\n\t\t\"%s ep:%p num_tabs:%d\\n\",\n\t\t__func__, ep, num_tabs);\n\n\t \n\tep->bd_list.bd_table_array = kcalloc(num_tabs,\n\t\t\t\t\t     sizeof(struct bd_table *),\n\t\t\t\t\t     GFP_ATOMIC);\n\tif (!ep->bd_list.bd_table_array)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (index = 0; index < num_tabs; index++) {\n\t\t \n\t\tbd_table = kzalloc(sizeof(*bd_table), GFP_ATOMIC);\n\t\tif (!bd_table)\n\t\t\tgoto fail;\n\n\t\tbd_table->start_bd = dma_pool_zalloc(bdc->bd_table_pool,\n\t\t\t\t\t\t\tGFP_ATOMIC,\n\t\t\t\t\t\t\t&dma);\n\t\tif (!bd_table->start_bd) {\n\t\t\tkfree(bd_table);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tbd_table->dma = dma;\n\n\t\tdev_dbg(bdc->dev,\n\t\t\t\"index:%d start_bd:%p dma=%08llx prev_table:%p\\n\",\n\t\t\tindex, bd_table->start_bd,\n\t\t\t(unsigned long long)bd_table->dma, prev_table);\n\n\t\tep->bd_list.bd_table_array[index] = bd_table;\n\t\tif (prev_table)\n\t\t\tchain_table(prev_table, bd_table, bd_p_tab);\n\n\t\tprev_table = bd_table;\n\t}\n\tchain_table(prev_table, ep->bd_list.bd_table_array[0], bd_p_tab);\n\t \n\tep->bd_list.num_tabs = num_tabs;\n\tep->bd_list.max_bdi  = (num_tabs * bd_p_tab) - 1;\n\tep->bd_list.num_tabs = num_tabs;\n\tep->bd_list.num_bds_table = bd_p_tab;\n\tep->bd_list.eqp_bdi = 0;\n\tep->bd_list.hwd_bdi = 0;\n\n\treturn 0;\nfail:\n\t \n\tep_bd_list_free(ep, num_tabs);\n\n\treturn -ENOMEM;\n}\n\n \nstatic inline int bd_needed_req(struct bdc_req *req)\n{\n\tint bd_needed = 0;\n\tint remaining;\n\n\t \n\tif (req->usb_req.length == 0)\n\t\treturn 1;\n\n\t \n\tremaining = req->usb_req.length % BD_MAX_BUFF_SIZE;\n\tif (remaining)\n\t\tbd_needed++;\n\n\t \n\tremaining = req->usb_req.length / BD_MAX_BUFF_SIZE;\n\tbd_needed += remaining;\n\n\treturn bd_needed;\n}\n\n \nstatic int bd_add_to_bdi(struct bdc_ep *ep, dma_addr_t bd_dma_addr)\n{\n\tstruct bd_list *bd_list = &ep->bd_list;\n\tdma_addr_t dma_first_bd, dma_last_bd;\n\tstruct bdc *bdc = ep->bdc;\n\tstruct bd_table *bd_table;\n\tbool found = false;\n\tint tbi, bdi;\n\n\tdma_first_bd = dma_last_bd = 0;\n\tdev_dbg(bdc->dev, \"%s  %llx\\n\",\n\t\t\t__func__, (unsigned long long)bd_dma_addr);\n\t \n\tfor (tbi = 0; tbi < bd_list->num_tabs; tbi++) {\n\t\tbd_table = bd_list->bd_table_array[tbi];\n\t\tdma_first_bd = bd_table->dma;\n\t\tdma_last_bd = bd_table->dma +\n\t\t\t\t\t(sizeof(struct bdc_bd) *\n\t\t\t\t\t(bd_list->num_bds_table - 1));\n\t\tdev_dbg(bdc->dev, \"dma_first_bd:%llx dma_last_bd:%llx\\n\",\n\t\t\t\t\t(unsigned long long)dma_first_bd,\n\t\t\t\t\t(unsigned long long)dma_last_bd);\n\t\tif (bd_dma_addr >= dma_first_bd && bd_dma_addr <= dma_last_bd) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (unlikely(!found)) {\n\t\tdev_err(bdc->dev, \"%s FATAL err, bd not found\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\t \n\tbdi = (bd_dma_addr - dma_first_bd) / sizeof(struct bdc_bd);\n\n\t \n\treturn (bdi + (tbi * bd_list->num_bds_table));\n}\n\n \nstatic int bdi_to_tbi(struct bdc_ep *ep, int bdi)\n{\n\tint tbi;\n\n\ttbi = bdi / ep->bd_list.num_bds_table;\n\tdev_vdbg(ep->bdc->dev,\n\t\t\"bdi:%d num_bds_table:%d tbi:%d\\n\",\n\t\tbdi, ep->bd_list.num_bds_table, tbi);\n\n\treturn tbi;\n}\n\n \nstatic inline int find_end_bdi(struct bdc_ep *ep, int next_hwd_bdi)\n{\n\tint end_bdi;\n\n\tend_bdi = next_hwd_bdi - 1;\n\tif (end_bdi < 0)\n\t\tend_bdi = ep->bd_list.max_bdi - 1;\n\telse if ((end_bdi % (ep->bd_list.num_bds_table-1)) == 0)\n\t\tend_bdi--;\n\n\treturn end_bdi;\n}\n\n \nstatic int bd_available_ep(struct bdc_ep *ep)\n{\n\tstruct bd_list *bd_list = &ep->bd_list;\n\tint available1, available2;\n\tstruct bdc *bdc = ep->bdc;\n\tint chain_bd1, chain_bd2;\n\tint available_bd = 0;\n\n\tavailable1 = available2 = chain_bd1 = chain_bd2 = 0;\n\t \n\tif (bd_list->eqp_bdi == bd_list->hwd_bdi)\n\t\treturn bd_list->max_bdi - bd_list->num_tabs;\n\n\t \n\tif (bd_list->hwd_bdi < bd_list->eqp_bdi) {\n\t\t \n\t\tavailable1 = bd_list->max_bdi - bd_list->eqp_bdi;\n\t\tavailable2 = bd_list->hwd_bdi;\n\t\tchain_bd1 = available1 / bd_list->num_bds_table;\n\t\tchain_bd2 = available2 / bd_list->num_bds_table;\n\t\tdev_vdbg(bdc->dev, \"chain_bd1:%d chain_bd2:%d\\n\",\n\t\t\t\t\t\tchain_bd1, chain_bd2);\n\t\tavailable_bd = available1 + available2 - chain_bd1 - chain_bd2;\n\t} else {\n\t\t \n\t\tavailable1 = bd_list->hwd_bdi -  bd_list->eqp_bdi;\n\t\t \n\t\tif ((bd_list->hwd_bdi - bd_list->eqp_bdi)\n\t\t\t\t\t<= bd_list->num_bds_table) {\n\t\t\t \n\t\t\tif (!(bdi_to_tbi(ep, bd_list->hwd_bdi)\n\t\t\t\t\t== bdi_to_tbi(ep, bd_list->eqp_bdi))) {\n\t\t\t\tavailable_bd = available1 - 1;\n\t\t\t}\n\t\t} else {\n\t\t\tchain_bd1 = available1 / bd_list->num_bds_table;\n\t\t\tavailable_bd = available1 - chain_bd1;\n\t\t}\n\t}\n\t \n\tavailable_bd--;\n\tdev_vdbg(bdc->dev, \"available_bd:%d\\n\", available_bd);\n\n\treturn available_bd;\n}\n\n \nvoid bdc_notify_xfr(struct bdc *bdc, u32 epnum)\n{\n\tstruct bdc_ep *ep = bdc->bdc_ep_array[epnum];\n\n\tdev_vdbg(bdc->dev, \"%s epnum:%d\\n\", __func__, epnum);\n\t \n\tif (unlikely(ep->flags & BDC_EP_STOP))\n\t\tep->flags &= ~BDC_EP_STOP;\n\n\tbdc_writel(bdc->regs, BDC_XSFNTF, epnum);\n}\n\n \nstatic struct bdc_bd *bdi_to_bd(struct bdc_ep *ep, int bdi)\n{\n\tint tbi = bdi_to_tbi(ep, bdi);\n\tint local_bdi = 0;\n\n\tlocal_bdi = bdi - (tbi * ep->bd_list.num_bds_table);\n\tdev_vdbg(ep->bdc->dev,\n\t\t\"%s bdi:%d local_bdi:%d\\n\",\n\t\t __func__, bdi, local_bdi);\n\n\treturn (ep->bd_list.bd_table_array[tbi]->start_bd + local_bdi);\n}\n\n \nstatic void ep_bdlist_eqp_adv(struct bdc_ep *ep)\n{\n\tep->bd_list.eqp_bdi++;\n\t \n\tif (((ep->bd_list.eqp_bdi + 1) % ep->bd_list.num_bds_table) == 0)\n\t\tep->bd_list.eqp_bdi++;\n\n\t \n\tif (ep->bd_list.eqp_bdi == (ep->bd_list.max_bdi + 1))\n\t\tep->bd_list.eqp_bdi = 0;\n}\n\n \nstatic int setup_first_bd_ep0(struct bdc *bdc, struct bdc_req *req, u32 *dword3)\n{\n\tu16 wValue;\n\tu32 req_len;\n\n\treq->ep->dir = 0;\n\treq_len = req->usb_req.length;\n\tswitch (bdc->ep0_state) {\n\tcase WAIT_FOR_DATA_START:\n\t\t*dword3 |= BD_TYPE_DS;\n\t\tif (bdc->setup_pkt.bRequestType & USB_DIR_IN)\n\t\t\t*dword3 |= BD_DIR_IN;\n\n\t\t \n\t\twValue = le16_to_cpu(bdc->setup_pkt.wValue);\n\t\tif ((wValue > req_len) &&\n\t\t\t\t(req_len % bdc->gadget.ep0->maxpacket == 0)) {\n\t\t\tdev_dbg(bdc->dev, \"ZLP needed wVal:%d len:%d MaxP:%d\\n\",\n\t\t\t\t\twValue, req_len,\n\t\t\t\t\tbdc->gadget.ep0->maxpacket);\n\t\t\tbdc->zlp_needed = true;\n\t\t}\n\t\tbreak;\n\n\tcase WAIT_FOR_STATUS_START:\n\t\t*dword3 |= BD_TYPE_SS;\n\t\tif (!le16_to_cpu(bdc->setup_pkt.wLength) ||\n\t\t\t\t!(bdc->setup_pkt.bRequestType & USB_DIR_IN))\n\t\t\t*dword3 |= BD_DIR_IN;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdc->dev,\n\t\t\t\"Unknown ep0 state for queueing bd ep0_state:%s\\n\",\n\t\t\tep0_state_string[bdc->ep0_state]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int setup_bd_list_xfr(struct bdc *bdc, struct bdc_req *req, int num_bds)\n{\n\tdma_addr_t buf_add = req->usb_req.dma;\n\tu32 maxp, tfs, dword2, dword3;\n\tstruct bd_transfer *bd_xfr;\n\tstruct bd_list *bd_list;\n\tstruct bdc_ep *ep;\n\tstruct bdc_bd *bd;\n\tint ret, bdnum;\n\tu32 req_len;\n\n\tep = req->ep;\n\tbd_list = &ep->bd_list;\n\tbd_xfr = &req->bd_xfr;\n\tbd_xfr->req = req;\n\tbd_xfr->start_bdi = bd_list->eqp_bdi;\n\tbd = bdi_to_bd(ep, bd_list->eqp_bdi);\n\treq_len = req->usb_req.length;\n\tmaxp = usb_endpoint_maxp(ep->desc);\n\ttfs = roundup(req->usb_req.length, maxp);\n\ttfs = tfs/maxp;\n\tdev_vdbg(bdc->dev, \"%s ep:%s num_bds:%d tfs:%d r_len:%d bd:%p\\n\",\n\t\t\t\t__func__, ep->name, num_bds, tfs, req_len, bd);\n\n\tfor (bdnum = 0; bdnum < num_bds; bdnum++) {\n\t\tdword2 = dword3 = 0;\n\t\t \n\t\tif (!bdnum) {\n\t\t\tdword3 |= BD_SOT|BD_SBF|(tfs<<BD_TFS_SHIFT);\n\t\t\tdword2 |= BD_LTF;\n\t\t\t \n\t\t\tif (ep->ep_num == 1) {\n\t\t\t\tret = setup_first_bd_ep0(bdc, req, &dword3);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tif (!req->ep->dir)\n\t\t\tdword3 |= BD_ISP;\n\n\t\tif (req_len > BD_MAX_BUFF_SIZE) {\n\t\t\tdword2 |= BD_MAX_BUFF_SIZE;\n\t\t\treq_len -= BD_MAX_BUFF_SIZE;\n\t\t} else {\n\t\t\t \n\t\t\tdword2 |= req_len;\n\t\t\tdword3 |= BD_IOC;\n\t\t\tdword3 |= BD_EOT;\n\t\t}\n\t\t \n\t\tdword2 |= BD_INTR_TARGET(0);\n\t\tbd = bdi_to_bd(ep, ep->bd_list.eqp_bdi);\n\t\tif (unlikely(!bd)) {\n\t\t\tdev_err(bdc->dev, \"Err bd pointing to wrong addr\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tbd->offset[0] = cpu_to_le32(lower_32_bits(buf_add));\n\t\tbd->offset[1] = cpu_to_le32(upper_32_bits(buf_add));\n\t\tbd->offset[2] = cpu_to_le32(dword2);\n\t\tbd->offset[3] = cpu_to_le32(dword3);\n\t\t \n\t\tep_bdlist_eqp_adv(ep);\n\t\t \n\t\tbuf_add += BD_MAX_BUFF_SIZE;\n\t\tdev_vdbg(bdc->dev, \"buf_add:%08llx req_len:%d bd:%p eqp:%d\\n\",\n\t\t\t\t(unsigned long long)buf_add, req_len, bd,\n\t\t\t\t\t\t\tep->bd_list.eqp_bdi);\n\t\tbd = bdi_to_bd(ep, ep->bd_list.eqp_bdi);\n\t\tbd->offset[3] = cpu_to_le32(BD_SBF);\n\t}\n\t \n\tbd = bdi_to_bd(ep, bd_xfr->start_bdi);\n\tbd->offset[3] &= cpu_to_le32(~BD_SBF);\n\t \n\tbd_xfr->num_bds  = num_bds;\n\tbd_xfr->next_hwd_bdi = ep->bd_list.eqp_bdi;\n\t \n\twmb();\n\n\treturn 0;\n}\n\n \nstatic int bdc_queue_xfr(struct bdc *bdc, struct bdc_req *req)\n{\n\tint num_bds, bd_available;\n\tstruct bdc_ep *ep;\n\tint ret;\n\n\tep = req->ep;\n\tdev_dbg(bdc->dev, \"%s req:%p\\n\", __func__, req);\n\tdev_dbg(bdc->dev, \"eqp_bdi:%d hwd_bdi:%d\\n\",\n\t\t\tep->bd_list.eqp_bdi, ep->bd_list.hwd_bdi);\n\n\tnum_bds =  bd_needed_req(req);\n\tbd_available = bd_available_ep(ep);\n\n\t \n\tif (num_bds > bd_available)\n\t\treturn -ENOMEM;\n\n\tret = setup_bd_list_xfr(bdc, req, num_bds);\n\tif (ret)\n\t\treturn ret;\n\tlist_add_tail(&req->queue, &ep->queue);\n\tbdc_dbg_bd_list(bdc, ep);\n\tbdc_notify_xfr(bdc, ep->ep_num);\n\n\treturn 0;\n}\n\n \nstatic void bdc_req_complete(struct bdc_ep *ep, struct bdc_req *req,\n\t\t\t\t\t\tint status)\n{\n\tstruct bdc *bdc = ep->bdc;\n\n\tif (req == NULL)\n\t\treturn;\n\n\tdev_dbg(bdc->dev, \"%s ep:%s status:%d\\n\", __func__, ep->name, status);\n\tlist_del(&req->queue);\n\treq->usb_req.status = status;\n\tusb_gadget_unmap_request(&bdc->gadget, &req->usb_req, ep->dir);\n\tif (req->usb_req.complete) {\n\t\tspin_unlock(&bdc->lock);\n\t\tusb_gadget_giveback_request(&ep->usb_ep, &req->usb_req);\n\t\tspin_lock(&bdc->lock);\n\t}\n}\n\n \nint bdc_ep_disable(struct bdc_ep *ep)\n{\n\tstruct bdc_req *req;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tret = 0;\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s() ep->ep_num=%d\\n\", __func__, ep->ep_num);\n\t \n\tret = bdc_stop_ep(bdc, ep->ep_num);\n\n\t \n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct bdc_req,\n\t\t\t\tqueue);\n\t\tbdc_req_complete(ep, req, -ESHUTDOWN);\n\t}\n\t \n\tret = bdc_dconfig_ep(bdc, ep);\n\tif (ret)\n\t\tdev_warn(bdc->dev,\n\t\t\t\"dconfig fail but continue with memory free\");\n\n\tep->flags = 0;\n\t \n\tif (ep->ep_num == 1)\n\t\treturn 0;\n\n\t \n\tep_bd_list_free(ep, ep->bd_list.num_tabs);\n\tep->desc = NULL;\n\tep->comp_desc = NULL;\n\tep->usb_ep.desc = NULL;\n\tep->ep_type = 0;\n\n\treturn ret;\n}\n\n \nint bdc_ep_enable(struct bdc_ep *ep)\n{\n\tstruct bdc *bdc;\n\tint ret = 0;\n\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s NUM_TABLES:%d %d\\n\",\n\t\t\t\t\t__func__, NUM_TABLES, NUM_TABLES_ISOCH);\n\n\tret = ep_bd_list_alloc(ep);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"ep bd list allocation failed:%d\\n\", ret);\n\t\treturn -ENOMEM;\n\t}\n\tbdc_dbg_bd_list(bdc, ep);\n\t \n\tif (ep->ep_num == 1)\n\t\treturn ret;\n\n\t \n\tret = bdc_config_ep(bdc, ep);\n\tif (ret)\n\t\treturn ret;\n\n\tep->usb_ep.maxpacket = usb_endpoint_maxp(ep->desc);\n\tep->usb_ep.desc = ep->desc;\n\tep->usb_ep.comp_desc = ep->comp_desc;\n\tep->ep_type = usb_endpoint_type(ep->desc);\n\tep->flags |= BDC_EP_ENABLED;\n\n\treturn 0;\n}\n\n \n\n \nstatic int ep0_queue_status_stage(struct bdc *bdc)\n{\n\tstruct bdc_req *status_req;\n\tstruct bdc_ep *ep;\n\n\tstatus_req = &bdc->status_req;\n\tep = bdc->bdc_ep_array[1];\n\tstatus_req->ep = ep;\n\tstatus_req->usb_req.length = 0;\n\tstatus_req->usb_req.status = -EINPROGRESS;\n\tstatus_req->usb_req.actual = 0;\n\tstatus_req->usb_req.complete = NULL;\n\tbdc_queue_xfr(bdc, status_req);\n\n\treturn 0;\n}\n\n \nstatic int ep0_queue(struct bdc_ep *ep, struct bdc_req *req)\n{\n\tstruct bdc *bdc;\n\tint ret;\n\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\treq->usb_req.actual = 0;\n\treq->usb_req.status = -EINPROGRESS;\n\treq->epnum = ep->ep_num;\n\n\tif (bdc->delayed_status) {\n\t\tbdc->delayed_status = false;\n\t\t \n\t\tif (bdc->ep0_state == WAIT_FOR_STATUS_START) {\n\t\t\t \n\t\t\tep0_queue_status_stage(bdc);\n\t\t\tbdc->ep0_state = WAIT_FOR_STATUS_XMIT;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (req->usb_req.length == 0)\n\t\t\treturn 0;\n\n\t}\n\tret = usb_gadget_map_request(&bdc->gadget, &req->usb_req, ep->dir);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"dma mapping failed %s\\n\", ep->name);\n\t\treturn ret;\n\t}\n\n\treturn bdc_queue_xfr(bdc, req);\n}\n\n \nstatic int ep0_queue_data_stage(struct bdc *bdc)\n{\n\tstruct bdc_ep *ep;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tep = bdc->bdc_ep_array[1];\n\tbdc->ep0_req.ep = ep;\n\tbdc->ep0_req.usb_req.complete = NULL;\n\n\treturn ep0_queue(ep, &bdc->ep0_req);\n}\n\n \nstatic int ep_queue(struct bdc_ep *ep, struct bdc_req *req)\n{\n\tstruct bdc *bdc;\n\tint ret = 0;\n\n\tif (!req || !ep->usb_ep.desc)\n\t\treturn -EINVAL;\n\n\tbdc = ep->bdc;\n\n\treq->usb_req.actual = 0;\n\treq->usb_req.status = -EINPROGRESS;\n\treq->epnum = ep->ep_num;\n\n\tret = usb_gadget_map_request(&bdc->gadget, &req->usb_req, ep->dir);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"dma mapping failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn bdc_queue_xfr(bdc, req);\n}\n\n \nstatic int ep_dequeue(struct bdc_ep *ep, struct bdc_req *req)\n{\n\tint start_bdi, end_bdi, tbi, eqp_bdi, curr_hw_dqpi;\n\tbool start_pending, end_pending;\n\tbool first_remove = false;\n\tstruct bdc_req *first_req;\n\tstruct bdc_bd *bd_start;\n\tstruct bd_table *table;\n\tdma_addr_t next_bd_dma;\n\tu64   deq_ptr_64 = 0;\n\tstruct bdc  *bdc;\n\tu32    tmp_32;\n\tint ret;\n\n\tbdc = ep->bdc;\n\tstart_pending = end_pending = false;\n\teqp_bdi = ep->bd_list.eqp_bdi - 1;\n\n\tif (eqp_bdi < 0)\n\t\teqp_bdi = ep->bd_list.max_bdi;\n\n\tstart_bdi = req->bd_xfr.start_bdi;\n\tend_bdi = find_end_bdi(ep, req->bd_xfr.next_hwd_bdi);\n\n\tdev_dbg(bdc->dev, \"%s ep:%s start:%d end:%d\\n\",\n\t\t\t\t\t__func__, ep->name, start_bdi, end_bdi);\n\tdev_dbg(bdc->dev, \"%s ep=%p ep->desc=%p\\n\", __func__,\n\t\t\t\t\t\tep, (void *)ep->usb_ep.desc);\n\t \n\tif (!(bdc_readl(bdc->regs, BDC_USPC) & BDC_PST_MASK)) {\n\t\tret = bdc_stop_ep(bdc, ep->ep_num);\n\t\t \n\t\tif (ret)\n\t\t\treturn 0;\n\t} else\n\t\treturn 0;\n\n\t \n\n\t \n\ttmp_32 = bdc_readl(bdc->regs, BDC_EPSTS0);\n\tdeq_ptr_64 = tmp_32;\n\ttmp_32 = bdc_readl(bdc->regs, BDC_EPSTS1);\n\tdeq_ptr_64 |= ((u64)tmp_32 << 32);\n\n\t \n\tcurr_hw_dqpi = bd_add_to_bdi(ep, deq_ptr_64);\n\tif (curr_hw_dqpi < 0)\n\t\treturn curr_hw_dqpi;\n\n\t \n\n\t \n\tif (curr_hw_dqpi > eqp_bdi) {\n\t\t \n\t\tif (start_bdi >= curr_hw_dqpi || start_bdi <= eqp_bdi) {\n\t\t\tstart_pending = true;\n\t\t\tend_pending = true;\n\t\t} else if (end_bdi >= curr_hw_dqpi || end_bdi <= eqp_bdi) {\n\t\t\tend_pending = true;\n\t\t}\n\t} else {\n\t\tif (start_bdi >= curr_hw_dqpi) {\n\t\t\tstart_pending = true;\n\t\t\tend_pending = true;\n\t\t} else if (end_bdi >= curr_hw_dqpi) {\n\t\t\tend_pending = true;\n\t\t}\n\t}\n\tdev_dbg(bdc->dev,\n\t\t\"start_pending:%d end_pending:%d speed:%d\\n\",\n\t\tstart_pending, end_pending, bdc->gadget.speed);\n\n\t \n\tif (!start_pending && !end_pending)\n\t\treturn -EINVAL;\n\n\t \n\tif (bdc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn 0;\n\ttbi = bdi_to_tbi(ep, req->bd_xfr.next_hwd_bdi);\n\ttable = ep->bd_list.bd_table_array[tbi];\n\tnext_bd_dma =  table->dma +\n\t\t\tsizeof(struct bdc_bd)*(req->bd_xfr.next_hwd_bdi -\n\t\t\t\t\ttbi * ep->bd_list.num_bds_table);\n\n\tfirst_req = list_first_entry(&ep->queue, struct bdc_req,\n\t\t\tqueue);\n\n\tif (req == first_req)\n\t\tfirst_remove = true;\n\n\t \n\tif (start_pending && !first_remove) {\n\t\t \n\t\tbd_start = bdi_to_bd(ep, start_bdi);\n\t\tbd_start->offset[0] = cpu_to_le32(lower_32_bits(next_bd_dma));\n\t\tbd_start->offset[1] = cpu_to_le32(upper_32_bits(next_bd_dma));\n\t\tbd_start->offset[2] = 0x0;\n\t\tbd_start->offset[3] = cpu_to_le32(MARK_CHAIN_BD);\n\t\tbdc_dbg_bd_list(bdc, ep);\n\t} else if (end_pending) {\n\t\t \n\t\tret = bdc_ep_bla(bdc, ep, next_bd_dma);\n\t\tif (ret) {\n\t\t\tdev_err(bdc->dev, \"error in ep_bla:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ep_set_halt(struct bdc_ep *ep, u32 value)\n{\n\tstruct bdc *bdc;\n\tint ret;\n\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s ep:%s value=%d\\n\", __func__, ep->name, value);\n\n\tif (value) {\n\t\tdev_dbg(bdc->dev, \"Halt\\n\");\n\t\tif (ep->ep_num == 1)\n\t\t\tbdc->ep0_state = WAIT_FOR_SETUP;\n\n\t\tret = bdc_ep_set_stall(bdc, ep->ep_num);\n\t\tif (ret)\n\t\t\tdev_err(bdc->dev, \"failed to set STALL on %s\\n\",\n\t\t\t\tep->name);\n\t\telse\n\t\t\tep->flags |= BDC_EP_STALL;\n\t} else {\n\t\t \n\t\tdev_dbg(bdc->dev, \"Before Clear\\n\");\n\t\tret = bdc_ep_clear_stall(bdc, ep->ep_num);\n\t\tif (ret)\n\t\t\tdev_err(bdc->dev, \"failed to clear STALL on %s\\n\",\n\t\t\t\tep->name);\n\t\telse\n\t\t\tep->flags &= ~BDC_EP_STALL;\n\t\tdev_dbg(bdc->dev, \"After  Clear\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nvoid bdc_free_ep(struct bdc *bdc)\n{\n\tstruct bdc_ep *ep;\n\tu8\tepnum;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tfor (epnum = 1; epnum < bdc->num_eps; epnum++) {\n\t\tep = bdc->bdc_ep_array[epnum];\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tif (ep->flags & BDC_EP_ENABLED)\n\t\t\tep_bd_list_free(ep, ep->bd_list.num_tabs);\n\n\t\t \n\t\tif (epnum != 1)\n\t\t\tlist_del(&ep->usb_ep.ep_list);\n\n\t\tkfree(ep);\n\t}\n}\n\n \nstatic int bdc_set_test_mode(struct bdc *bdc)\n{\n\tu32 usb2_pm;\n\n\tusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\n\tusb2_pm &= ~BDC_PTC_MASK;\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tswitch (bdc->test_mode) {\n\tcase USB_TEST_J:\n\tcase USB_TEST_K:\n\tcase USB_TEST_SE0_NAK:\n\tcase USB_TEST_PACKET:\n\tcase USB_TEST_FORCE_ENABLE:\n\t\tusb2_pm |= bdc->test_mode << 28;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(bdc->dev, \"usb2_pm=%08x\", usb2_pm);\n\tbdc_writel(bdc->regs, BDC_USPPM2, usb2_pm);\n\n\treturn 0;\n}\n\n \nstatic void handle_xsr_succ_status(struct bdc *bdc, struct bdc_ep *ep,\n\t\t\t\t\t\t\tstruct bdc_sr *sreport)\n{\n\tint short_bdi, start_bdi, end_bdi, max_len_bds, chain_bds;\n\tstruct bd_list *bd_list = &ep->bd_list;\n\tint actual_length, length_short;\n\tstruct bd_transfer *bd_xfr;\n\tstruct bdc_bd *short_bd;\n\tstruct bdc_req *req;\n\tu64   deq_ptr_64 = 0;\n\tint status = 0;\n\tint sr_status;\n\tu32    tmp_32;\n\n\tdev_dbg(bdc->dev, \"%s  ep:%p\\n\", __func__, ep);\n\tbdc_dbg_srr(bdc, 0);\n\t \n\tif (ep->ignore_next_sr) {\n\t\tep->ignore_next_sr = false;\n\t\treturn;\n\t}\n\n\tif (unlikely(list_empty(&ep->queue))) {\n\t\tdev_warn(bdc->dev, \"xfr srr with no BD's queued\\n\");\n\t\treturn;\n\t}\n\treq = list_entry(ep->queue.next, struct bdc_req,\n\t\t\tqueue);\n\n\tbd_xfr = &req->bd_xfr;\n\tsr_status = XSF_STS(le32_to_cpu(sreport->offset[3]));\n\n\t \n\tif (sr_status == XSF_SHORT &&  bd_xfr->num_bds > 1) {\n\t\t \n\t\ttmp_32 = le32_to_cpu(sreport->offset[0]);\n\t\tdeq_ptr_64 = tmp_32;\n\t\ttmp_32 = le32_to_cpu(sreport->offset[1]);\n\t\tdeq_ptr_64 |= ((u64)tmp_32 << 32);\n\t\tshort_bdi = bd_add_to_bdi(ep, deq_ptr_64);\n\t\tif (unlikely(short_bdi < 0))\n\t\t\tdev_warn(bdc->dev, \"bd doesn't exist?\\n\");\n\n\t\tstart_bdi =  bd_xfr->start_bdi;\n\t\t \n\t\tif (start_bdi <= short_bdi) {\n\t\t\tmax_len_bds = short_bdi - start_bdi;\n\t\t\tif (max_len_bds <= bd_list->num_bds_table) {\n\t\t\t\tif (!(bdi_to_tbi(ep, start_bdi) ==\n\t\t\t\t\t\tbdi_to_tbi(ep, short_bdi)))\n\t\t\t\t\tmax_len_bds--;\n\t\t\t} else {\n\t\t\t\tchain_bds = max_len_bds/bd_list->num_bds_table;\n\t\t\t\tmax_len_bds -= chain_bds;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tchain_bds = (bd_list->max_bdi - start_bdi)/\n\t\t\t\t\t\t\tbd_list->num_bds_table;\n\t\t\tchain_bds += short_bdi/bd_list->num_bds_table;\n\t\t\tmax_len_bds = bd_list->max_bdi - start_bdi;\n\t\t\tmax_len_bds += short_bdi;\n\t\t\tmax_len_bds -= chain_bds;\n\t\t}\n\t\t \n\t\tend_bdi = find_end_bdi(ep, bd_xfr->next_hwd_bdi);\n\t\tif (!(end_bdi == short_bdi))\n\t\t\tep->ignore_next_sr = true;\n\n\t\tactual_length = max_len_bds * BD_MAX_BUFF_SIZE;\n\t\tshort_bd = bdi_to_bd(ep, short_bdi);\n\t\t \n\t\tlength_short = le32_to_cpu(short_bd->offset[2]) & 0x1FFFFF;\n\t\t \n\t\tlength_short -= SR_BD_LEN(le32_to_cpu(sreport->offset[2]));\n\t\tactual_length += length_short;\n\t\treq->usb_req.actual = actual_length;\n\t} else {\n\t\treq->usb_req.actual = req->usb_req.length -\n\t\t\tSR_BD_LEN(le32_to_cpu(sreport->offset[2]));\n\t\tdev_dbg(bdc->dev,\n\t\t\t\"len=%d actual=%d bd_xfr->next_hwd_bdi:%d\\n\",\n\t\t\treq->usb_req.length, req->usb_req.actual,\n\t\t\tbd_xfr->next_hwd_bdi);\n\t}\n\n\t \n\tep->bd_list.hwd_bdi = bd_xfr->next_hwd_bdi;\n\tif (req->usb_req.actual < req->usb_req.length) {\n\t\tdev_dbg(bdc->dev, \"short xfr on %d\\n\", ep->ep_num);\n\t\tif (req->usb_req.short_not_ok)\n\t\t\tstatus = -EREMOTEIO;\n\t}\n\tbdc_req_complete(ep, bd_xfr->req, status);\n}\n\n \n\n \nvoid bdc_xsf_ep0_setup_recv(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tstruct usb_ctrlrequest *setup_pkt;\n\tu32 len;\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s ep0_state:%s\\n\",\n\t\t__func__, ep0_state_string[bdc->ep0_state]);\n\t \n\tsetup_pkt = &bdc->setup_pkt;\n\tmemcpy(setup_pkt, &sreport->offset[0], sizeof(*setup_pkt));\n\tlen = le16_to_cpu(setup_pkt->wLength);\n\tif (!len)\n\t\tbdc->ep0_state = WAIT_FOR_STATUS_START;\n\telse\n\t\tbdc->ep0_state = WAIT_FOR_DATA_START;\n\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s exit ep0_state:%s\\n\",\n\t\t__func__, ep0_state_string[bdc->ep0_state]);\n}\n\n \nstatic void ep0_stall(struct bdc *bdc)\n{\n\tstruct bdc_ep\t*ep = bdc->bdc_ep_array[1];\n\tstruct bdc_req *req;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tbdc->delayed_status = false;\n\tep_set_halt(ep, 1);\n\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct bdc_req,\n\t\t\t\tqueue);\n\t\tbdc_req_complete(ep, req, -ESHUTDOWN);\n\t}\n}\n\n \nstatic int ep0_set_address(struct bdc *bdc, struct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = bdc->gadget.state;\n\tint ret = 0;\n\tu32 addr;\n\n\taddr = le16_to_cpu(ctrl->wValue);\n\tdev_dbg(bdc->dev,\n\t\t\"%s addr:%d dev state:%d\\n\",\n\t\t__func__, addr, state);\n\n\tif (addr > 127)\n\t\treturn -EINVAL;\n\n\tswitch (state) {\n\tcase USB_STATE_DEFAULT:\n\tcase USB_STATE_ADDRESS:\n\t\t \n\t\tret = bdc_address_device(bdc, addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (addr)\n\t\t\tusb_gadget_set_state(&bdc->gadget, USB_STATE_ADDRESS);\n\t\telse\n\t\t\tusb_gadget_set_state(&bdc->gadget, USB_STATE_DEFAULT);\n\n\t\tbdc->dev_addr = addr;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bdc->dev,\n\t\t\t\"SET Address in wrong device state %d\\n\",\n\t\t\tstate);\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ep0_handle_feature_dev(struct bdc *bdc, u16 wValue,\n\t\t\t\t\t\t\tu16 wIndex, bool set)\n{\n\tenum usb_device_state state = bdc->gadget.state;\n\tu32\tusppms = 0;\n\n\tdev_dbg(bdc->dev, \"%s set:%d dev state:%d\\n\",\n\t\t\t\t\t__func__, set, state);\n\tswitch (wValue) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tdev_dbg(bdc->dev, \"USB_DEVICE_REMOTE_WAKEUP\\n\");\n\t\tif (set)\n\t\t\tbdc->devstatus |= REMOTE_WAKE_ENABLE;\n\t\telse\n\t\t\tbdc->devstatus &= ~REMOTE_WAKE_ENABLE;\n\t\tbreak;\n\n\tcase USB_DEVICE_TEST_MODE:\n\t\tdev_dbg(bdc->dev, \"USB_DEVICE_TEST_MODE\\n\");\n\t\tif ((wIndex & 0xFF) ||\n\t\t\t\t(bdc->gadget.speed != USB_SPEED_HIGH) || !set)\n\t\t\treturn -EINVAL;\n\n\t\tbdc->test_mode = wIndex >> 8;\n\t\tbreak;\n\n\tcase USB_DEVICE_U1_ENABLE:\n\t\tdev_dbg(bdc->dev, \"USB_DEVICE_U1_ENABLE\\n\");\n\n\t\tif (bdc->gadget.speed != USB_SPEED_SUPER ||\n\t\t\t\t\t\tstate != USB_STATE_CONFIGURED)\n\t\t\treturn -EINVAL;\n\n\t\tusppms =  bdc_readl(bdc->regs, BDC_USPPMS);\n\t\tif (set) {\n\t\t\t \n\t\t\tusppms &= ~BDC_U1T(BDC_U1T_MASK);\n\t\t\tusppms |= BDC_U1T(U1_TIMEOUT);\n\t\t\tusppms |= BDC_U1E | BDC_PORT_W1S;\n\t\t\tbdc->devstatus |= (1 << USB_DEV_STAT_U1_ENABLED);\n\t\t} else {\n\t\t\tusppms &= ~BDC_U1E;\n\t\t\tusppms |= BDC_PORT_W1S;\n\t\t\tbdc->devstatus &= ~(1 << USB_DEV_STAT_U1_ENABLED);\n\t\t}\n\t\tbdc_writel(bdc->regs, BDC_USPPMS, usppms);\n\t\tbreak;\n\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tdev_dbg(bdc->dev, \"USB_DEVICE_U2_ENABLE\\n\");\n\n\t\tif (bdc->gadget.speed != USB_SPEED_SUPER ||\n\t\t\t\t\t\tstate != USB_STATE_CONFIGURED)\n\t\t\treturn -EINVAL;\n\n\t\tusppms = bdc_readl(bdc->regs, BDC_USPPMS);\n\t\tif (set) {\n\t\t\tusppms |= BDC_U2E;\n\t\t\tusppms |= BDC_U2A;\n\t\t\tbdc->devstatus |= (1 << USB_DEV_STAT_U2_ENABLED);\n\t\t} else {\n\t\t\tusppms &= ~BDC_U2E;\n\t\t\tusppms &= ~BDC_U2A;\n\t\t\tbdc->devstatus &= ~(1 << USB_DEV_STAT_U2_ENABLED);\n\t\t}\n\t\tbdc_writel(bdc->regs, BDC_USPPMS, usppms);\n\t\tbreak;\n\n\tcase USB_DEVICE_LTM_ENABLE:\n\t\tdev_dbg(bdc->dev, \"USB_DEVICE_LTM_ENABLE?\\n\");\n\t\tif (bdc->gadget.speed != USB_SPEED_SUPER ||\n\t\t\t\t\t\tstate != USB_STATE_CONFIGURED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdc->dev, \"Unknown wValue:%d\\n\", wValue);\n\t\treturn -EOPNOTSUPP;\n\t}  \n\n\treturn 0;\n}\n\n \nstatic int ep0_handle_feature(struct bdc *bdc,\n\t\t\t      struct usb_ctrlrequest *setup_pkt, bool set)\n{\n\tenum usb_device_state state = bdc->gadget.state;\n\tstruct bdc_ep *ep;\n\tu16 wValue;\n\tu16 wIndex;\n\tint epnum;\n\n\twValue = le16_to_cpu(setup_pkt->wValue);\n\twIndex = le16_to_cpu(setup_pkt->wIndex);\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s wValue=%d wIndex=%d\tdevstate=%08x speed=%d set=%d\",\n\t\t__func__, wValue, wIndex, state,\n\t\tbdc->gadget.speed, set);\n\n\tswitch (setup_pkt->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\treturn ep0_handle_feature_dev(bdc, wValue, wIndex, set);\n\tcase USB_RECIP_INTERFACE:\n\t\tdev_dbg(bdc->dev, \"USB_RECIP_INTERFACE\\n\");\n\t\t \n\t\tif (wValue != USB_INTRF_FUNC_SUSPEND)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (set) {\n\t\t\tif (wIndex & USB_INTRF_FUNC_SUSPEND_RW) {\n\t\t\t\tdev_dbg(bdc->dev, \"SET REMOTE_WAKEUP\\n\");\n\t\t\t\tbdc->devstatus |= REMOTE_WAKE_ENABLE;\n\t\t\t} else {\n\t\t\t\tdev_dbg(bdc->dev, \"CLEAR REMOTE_WAKEUP\\n\");\n\t\t\t\tbdc->devstatus &= ~REMOTE_WAKE_ENABLE;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tdev_dbg(bdc->dev, \"USB_RECIP_ENDPOINT\\n\");\n\t\tif (wValue != USB_ENDPOINT_HALT)\n\t\t\treturn -EINVAL;\n\n\t\tepnum = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum) {\n\t\t\tif ((wIndex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\n\t\t\t\tepnum = epnum * 2 + 1;\n\t\t\telse\n\t\t\t\tepnum *= 2;\n\t\t} else {\n\t\t\tepnum = 1;  \n\t\t}\n\t\t \n\t\tif (epnum == 1 && !set) {\n\t\t\tdev_dbg(bdc->dev, \"ep0 stall already cleared\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tdev_dbg(bdc->dev, \"epnum=%d\\n\", epnum);\n\t\tep = bdc->bdc_ep_array[epnum];\n\t\tif (!ep)\n\t\t\treturn -EINVAL;\n\n\t\treturn ep_set_halt(ep, set);\n\tdefault:\n\t\tdev_err(bdc->dev, \"Unknown recipient\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ep0_handle_status(struct bdc *bdc,\n\t\t\t     struct usb_ctrlrequest *setup_pkt)\n{\n\tenum usb_device_state state = bdc->gadget.state;\n\tstruct bdc_ep *ep;\n\tu16 usb_status = 0;\n\tu32 epnum;\n\tu16 wIndex;\n\n\t \n\tif (state == USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\twIndex = le16_to_cpu(setup_pkt->wIndex);\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tusb_status = bdc->devstatus;\n\tswitch (setup_pkt->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tdev_dbg(bdc->dev,\n\t\t\t\"USB_RECIP_DEVICE devstatus:%08x\\n\",\n\t\t\tbdc->devstatus);\n\t\t \n\t\tif (bdc->gadget.speed == USB_SPEED_SUPER)\n\t\t\tusb_status &= ~REMOTE_WAKE_ENABLE;\n\t\tbreak;\n\n\tcase USB_RECIP_INTERFACE:\n\t\tdev_dbg(bdc->dev, \"USB_RECIP_INTERFACE\\n\");\n\t\tif (bdc->gadget.speed == USB_SPEED_SUPER) {\n\t\t\t \n\t\t\tif (bdc->devstatus & REMOTE_WAKE_ENABLE)\n\t\t\t\tusb_status |= REMOTE_WAKE_ENABLE;\n\t\t} else {\n\t\t\tusb_status = 0;\n\t\t}\n\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tdev_dbg(bdc->dev, \"USB_RECIP_ENDPOINT\\n\");\n\t\tepnum = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum) {\n\t\t\tif ((wIndex & USB_ENDPOINT_DIR_MASK) == USB_DIR_IN)\n\t\t\t\tepnum = epnum*2 + 1;\n\t\t\telse\n\t\t\t\tepnum *= 2;\n\t\t} else {\n\t\t\tepnum = 1;  \n\t\t}\n\n\t\tep = bdc->bdc_ep_array[epnum];\n\t\tif (!ep) {\n\t\t\tdev_err(bdc->dev, \"ISSUE, GET_STATUS for invalid EP ?\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ep->flags & BDC_EP_STALL)\n\t\t\tusb_status |= 1 << USB_ENDPOINT_HALT;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdc->dev, \"Unknown recipient for get_status\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tdev_dbg(bdc->dev, \"usb_status=%08x\\n\", usb_status);\n\t*(__le16 *)bdc->ep0_response_buff = cpu_to_le16(usb_status);\n\tbdc->ep0_req.usb_req.length = 2;\n\tbdc->ep0_req.usb_req.buf = &bdc->ep0_response_buff;\n\tep0_queue_data_stage(bdc);\n\n\treturn 0;\n}\n\nstatic void ep0_set_sel_cmpl(struct usb_ep *_ep, struct usb_request *_req)\n{\n\t \n}\n\n \nstatic int ep0_set_sel(struct bdc *bdc,\n\t\t\t     struct usb_ctrlrequest *setup_pkt)\n{\n\tstruct bdc_ep\t*ep;\n\tu16\twLength;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\twLength = le16_to_cpu(setup_pkt->wLength);\n\tif (unlikely(wLength != 6)) {\n\t\tdev_err(bdc->dev, \"%s Wrong wLength:%d\\n\", __func__, wLength);\n\t\treturn -EINVAL;\n\t}\n\tep = bdc->bdc_ep_array[1];\n\tbdc->ep0_req.ep = ep;\n\tbdc->ep0_req.usb_req.length = 6;\n\tbdc->ep0_req.usb_req.buf = bdc->ep0_response_buff;\n\tbdc->ep0_req.usb_req.complete = ep0_set_sel_cmpl;\n\tep0_queue_data_stage(bdc);\n\n\treturn 0;\n}\n\n \nstatic int ep0_queue_zlp(struct bdc *bdc)\n{\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tbdc->ep0_req.ep = bdc->bdc_ep_array[1];\n\tbdc->ep0_req.usb_req.length = 0;\n\tbdc->ep0_req.usb_req.complete = NULL;\n\tbdc->ep0_state = WAIT_FOR_DATA_START;\n\tret = bdc_queue_xfr(bdc, &bdc->ep0_req);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"err queueing zlp :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\tbdc->ep0_state = WAIT_FOR_DATA_XMIT;\n\n\treturn 0;\n}\n\n \nstatic int handle_control_request(struct bdc *bdc)\n{\n\tenum usb_device_state state = bdc->gadget.state;\n\tstruct usb_ctrlrequest *setup_pkt;\n\tint delegate_setup = 0;\n\tint ret = 0;\n\tint config = 0;\n\n\tsetup_pkt = &bdc->setup_pkt;\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tif ((setup_pkt->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (setup_pkt->bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_SET_ADDRESS\\n\");\n\t\t\tret = ep0_set_address(bdc, setup_pkt);\n\t\t\tbdc->devstatus &= DEVSTATUS_CLEAR;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_CONFIGURATION:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_SET_CONFIGURATION\\n\");\n\t\t\tif (state == USB_STATE_ADDRESS) {\n\t\t\t\tusb_gadget_set_state(&bdc->gadget,\n\t\t\t\t\t\t\tUSB_STATE_CONFIGURED);\n\t\t\t} else if (state == USB_STATE_CONFIGURED) {\n\t\t\t\t \n\t\t\t\tconfig = le16_to_cpu(setup_pkt->wValue);\n\t\t\t\tif (!config)\n\t\t\t\t\tusb_gadget_set_state(\n\t\t\t\t\t\t\t&bdc->gadget,\n\t\t\t\t\t\t\tUSB_STATE_ADDRESS);\n\t\t\t}\n\t\t\tdelegate_setup = 1;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_SET_FEATURE\\n\");\n\t\t\tret = ep0_handle_feature(bdc, setup_pkt, 1);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_CLEAR_FEATURE\\n\");\n\t\t\tret = ep0_handle_feature(bdc, setup_pkt, 0);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_GET_STATUS\\n\");\n\t\t\tret = ep0_handle_status(bdc, setup_pkt);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_SEL:\n\t\t\tdev_dbg(bdc->dev, \"USB_REQ_SET_SEL\\n\");\n\t\t\tret = ep0_set_sel(bdc, setup_pkt);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\t\tdev_warn(bdc->dev,\n\t\t\t\"USB_REQ_SET_ISOCH_DELAY not handled\\n\");\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdelegate_setup = 1;\n\t\t}\n\t} else {\n\t\tdelegate_setup = 1;\n\t}\n\n\tif (delegate_setup) {\n\t\tspin_unlock(&bdc->lock);\n\t\tret = bdc->gadget_driver->setup(&bdc->gadget, setup_pkt);\n\t\tspin_lock(&bdc->lock);\n\t}\n\n\treturn ret;\n}\n\n \nvoid bdc_xsf_ep0_data_start(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tstruct bdc_ep *ep;\n\tint ret = 0;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tep = bdc->bdc_ep_array[1];\n\t \n\tif (ep->flags & BDC_EP_STALL) {\n\t\tret = ep_set_halt(ep, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\tif (bdc->ep0_state != WAIT_FOR_DATA_START)\n\t\tdev_warn(bdc->dev,\n\t\t\t\"Data stage not expected ep0_state:%s\\n\",\n\t\t\tep0_state_string[bdc->ep0_state]);\n\n\tret = handle_control_request(bdc);\n\tif (ret == USB_GADGET_DELAYED_STATUS) {\n\t\t \n\t\tbdc->delayed_status = true;\n\t\treturn;\n\t}\n\tif (!ret) {\n\t\tbdc->ep0_state = WAIT_FOR_DATA_XMIT;\n\t\tdev_dbg(bdc->dev,\n\t\t\t\"ep0_state:%s\", ep0_state_string[bdc->ep0_state]);\n\t\treturn;\n\t}\nerr:\n\tep0_stall(bdc);\n}\n\n \nvoid bdc_xsf_ep0_status_start(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tstruct usb_ctrlrequest *setup_pkt;\n\tstruct bdc_ep *ep;\n\tint ret = 0;\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s ep0_state:%s\",\n\t\t__func__, ep0_state_string[bdc->ep0_state]);\n\tep = bdc->bdc_ep_array[1];\n\n\t \n\tif (bdc->zlp_needed)\n\t\tbdc->zlp_needed = false;\n\n\tif (ep->flags & BDC_EP_STALL) {\n\t\tret = ep_set_halt(ep, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif ((bdc->ep0_state != WAIT_FOR_STATUS_START) &&\n\t\t\t\t(bdc->ep0_state != WAIT_FOR_DATA_XMIT))\n\t\tdev_err(bdc->dev,\n\t\t\t\"Status stage recv but ep0_state:%s\\n\",\n\t\t\tep0_state_string[bdc->ep0_state]);\n\n\t \n\tif (bdc->ep0_state == WAIT_FOR_DATA_XMIT) {\n\t\tbdc->ep0_state = STATUS_PENDING;\n\t\t \n\t\tdev_dbg(bdc->dev,\n\t\t\t\"status started but data  not transmitted yet\\n\");\n\t\treturn;\n\t}\n\tsetup_pkt = &bdc->setup_pkt;\n\n\t \n\tif (!le16_to_cpu(setup_pkt->wLength)) {\n\t\tret = handle_control_request(bdc);\n\t\tif (ret == USB_GADGET_DELAYED_STATUS) {\n\t\t\tbdc->delayed_status = true;\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\tif (!ret) {\n\t\t \n\t\tep0_queue_status_stage(bdc);\n\t\tbdc->ep0_state = WAIT_FOR_STATUS_XMIT;\n\t\tdev_dbg(bdc->dev,\n\t\t\t\"ep0_state:%s\", ep0_state_string[bdc->ep0_state]);\n\t\treturn;\n\t}\nerr:\n\tep0_stall(bdc);\n}\n\n \nstatic void ep0_xsf_complete(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tswitch (bdc->ep0_state) {\n\tcase WAIT_FOR_DATA_XMIT:\n\t\tbdc->ep0_state = WAIT_FOR_STATUS_START;\n\t\tbreak;\n\tcase WAIT_FOR_STATUS_XMIT:\n\t\tbdc->ep0_state = WAIT_FOR_SETUP;\n\t\tif (bdc->test_mode) {\n\t\t\tint ret;\n\n\t\t\tdev_dbg(bdc->dev, \"test_mode:%d\\n\", bdc->test_mode);\n\t\t\tret = bdc_set_test_mode(bdc);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(bdc->dev, \"Err in setting Test mode\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbdc->test_mode = 0;\n\t\t}\n\t\tbreak;\n\tcase STATUS_PENDING:\n\t\tbdc_xsf_ep0_status_start(bdc, sreport);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(bdc->dev,\n\t\t\t\"Unknown ep0_state:%s\\n\",\n\t\t\tep0_state_string[bdc->ep0_state]);\n\n\t}\n}\n\n \nvoid bdc_sr_xsf(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tstruct bdc_ep *ep;\n\tu32 sr_status;\n\tu8 ep_num;\n\n\tep_num = (le32_to_cpu(sreport->offset[3])>>4) & 0x1f;\n\tep = bdc->bdc_ep_array[ep_num];\n\tif (!ep || !(ep->flags & BDC_EP_ENABLED)) {\n\t\tdev_err(bdc->dev, \"xsf for ep not enabled\\n\");\n\t\treturn;\n\t}\n\t \n\tif (bdc->devstatus & FUNC_WAKE_ISSUED) {\n\t\tbdc->devstatus &= ~(FUNC_WAKE_ISSUED);\n\t\tdev_dbg(bdc->dev, \"%s clearing FUNC_WAKE_ISSUED flag\\n\",\n\t\t\t\t\t\t\t\t__func__);\n\t}\n\tsr_status = XSF_STS(le32_to_cpu(sreport->offset[3]));\n\tdev_dbg_ratelimited(bdc->dev, \"%s sr_status=%d ep:%s\\n\",\n\t\t\t\t\t__func__, sr_status, ep->name);\n\n\tswitch (sr_status) {\n\tcase XSF_SUCC:\n\tcase XSF_SHORT:\n\t\thandle_xsr_succ_status(bdc, ep, sreport);\n\t\tif (ep_num == 1)\n\t\t\tep0_xsf_complete(bdc, sreport);\n\t\tbreak;\n\n\tcase XSF_SETUP_RECV:\n\tcase XSF_DATA_START:\n\tcase XSF_STATUS_START:\n\t\tif (ep_num != 1) {\n\t\t\tdev_err(bdc->dev,\n\t\t\t\t\"ep0 related packets on non ep0 endpoint\");\n\t\t\treturn;\n\t\t}\n\t\tbdc->sr_xsf_ep0[sr_status - XSF_SETUP_RECV](bdc, sreport);\n\t\tbreak;\n\n\tcase XSF_BABB:\n\t\tif (ep_num == 1) {\n\t\t\tdev_dbg(bdc->dev, \"Babble on ep0 zlp_need:%d\\n\",\n\t\t\t\t\t\t\tbdc->zlp_needed);\n\t\t\t \n\t\t\tif (bdc->zlp_needed) {\n\t\t\t\t \n\t\t\t\tep0_queue_zlp(bdc);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdev_warn(bdc->dev, \"Babble on ep not handled\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(bdc->dev, \"sr status not handled:%x\\n\", sr_status);\n\t\tbreak;\n\t}\n}\n\nstatic int bdc_gadget_ep_queue(struct usb_ep *_ep,\n\t\t\t\tstruct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct bdc_req *req;\n\tunsigned long flags;\n\tstruct bdc_ep *ep;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tif (!_ep || !_ep->desc)\n\t\treturn -ESHUTDOWN;\n\n\tif (!_req || !_req->complete || !_req->buf)\n\t\treturn -EINVAL;\n\n\tep = to_bdc_ep(_ep);\n\treq = to_bdc_req(_req);\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s ep:%p req:%p\\n\", __func__, ep, req);\n\tdev_dbg(bdc->dev, \"queuing request %p to %s length %d zero:%d\\n\",\n\t\t\t\t_req, ep->name, _req->length, _req->zero);\n\n\tif (!ep->usb_ep.desc) {\n\t\tdev_warn(bdc->dev,\n\t\t\t\"trying to queue req %p to disabled %s\\n\",\n\t\t\t_req, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tif (_req->length > MAX_XFR_LEN) {\n\t\tdev_warn(bdc->dev,\n\t\t\t\"req length > supported MAX:%d requested:%d\\n\",\n\t\t\tMAX_XFR_LEN, _req->length);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tif (ep == bdc->bdc_ep_array[1])\n\t\tret = ep0_queue(ep, req);\n\telse\n\t\tret = ep_queue(ep, req);\n\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int bdc_gadget_ep_dequeue(struct usb_ep *_ep,\n\t\t\t\t  struct usb_request *_req)\n{\n\tstruct bdc_req *req;\n\tstruct bdc_req *iter;\n\tunsigned long flags;\n\tstruct bdc_ep *ep;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tep = to_bdc_ep(_ep);\n\treq = to_bdc_req(_req);\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s ep:%s req:%p\\n\", __func__, ep->name, req);\n\tbdc_dbg_bd_list(bdc, ep);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\n\treq = NULL;\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->usb_req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&bdc->lock, flags);\n\t\tdev_err(bdc->dev, \"usb_req !=req n\");\n\t\treturn -EINVAL;\n\t}\n\tret = ep_dequeue(ep, req);\n\tif (ret) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\tbdc_req_complete(ep, req, -ECONNRESET);\n\nerr:\n\tbdc_dbg_bd_list(bdc, ep);\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int bdc_gadget_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tunsigned long flags;\n\tstruct bdc_ep *ep;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tep = to_bdc_ep(_ep);\n\tbdc = ep->bdc;\n\tdev_dbg(bdc->dev, \"%s ep:%s value=%d\\n\", __func__, ep->name, value);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tif (usb_endpoint_xfer_isoc(ep->usb_ep.desc))\n\t\tret = -EINVAL;\n\telse if (!list_empty(&ep->queue))\n\t\tret = -EAGAIN;\n\telse\n\t\tret = ep_set_halt(ep, value);\n\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct usb_request *bdc_gadget_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t     gfp_t gfp_flags)\n{\n\tstruct bdc_req *req;\n\tstruct bdc_ep *ep;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tep = to_bdc_ep(_ep);\n\treq->ep = ep;\n\treq->epnum = ep->ep_num;\n\treq->usb_req.dma = DMA_ADDR_INVALID;\n\tdev_dbg(ep->bdc->dev, \"%s ep:%s req:%p\\n\", __func__, ep->name, req);\n\n\treturn &req->usb_req;\n}\n\nstatic void bdc_gadget_free_request(struct usb_ep *_ep,\n\t\t\t\t     struct usb_request *_req)\n{\n\tstruct bdc_req *req;\n\n\treq = to_bdc_req(_req);\n\tkfree(req);\n}\n\n \n\n \nstatic int bdc_gadget_ep_enable(struct usb_ep *_ep,\n\t\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\tunsigned long flags;\n\tstruct bdc_ep *ep;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"%s invalid parameters\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->wMaxPacketSize) {\n\t\tpr_debug(\"%s missing wMaxPacketSize\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep = to_bdc_ep(_ep);\n\tbdc = ep->bdc;\n\n\t \n\tif (ep == bdc->bdc_ep_array[1])\n\t\treturn -EINVAL;\n\n\tif (!bdc->gadget_driver\n\t    || bdc->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tdev_dbg(bdc->dev, \"%s Enabling %s\\n\", __func__, ep->name);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tep->desc = desc;\n\tep->comp_desc = _ep->comp_desc;\n\tret = bdc_ep_enable(ep);\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int bdc_gadget_ep_disable(struct usb_ep *_ep)\n{\n\tunsigned long flags;\n\tstruct bdc_ep *ep;\n\tstruct bdc *bdc;\n\tint ret;\n\n\tif (!_ep) {\n\t\tpr_debug(\"bdc: invalid parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\tep = to_bdc_ep(_ep);\n\tbdc = ep->bdc;\n\n\t \n\tif (ep == bdc->bdc_ep_array[1]) {\n\t\tdev_warn(bdc->dev, \"%s called for ep0\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(bdc->dev,\n\t\t\"%s() ep:%s ep->flags:%08x\\n\",\n\t\t__func__, ep->name, ep->flags);\n\n\tif (!(ep->flags & BDC_EP_ENABLED)) {\n\t\tif (bdc->gadget.speed != USB_SPEED_UNKNOWN)\n\t\t\tdev_warn(bdc->dev, \"%s is already disabled\\n\",\n\t\t\t\t ep->name);\n\t\treturn 0;\n\t}\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tret = bdc_ep_disable(ep);\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct usb_ep_ops bdc_gadget_ep_ops = {\n\t.enable = bdc_gadget_ep_enable,\n\t.disable = bdc_gadget_ep_disable,\n\t.alloc_request = bdc_gadget_alloc_request,\n\t.free_request = bdc_gadget_free_request,\n\t.queue = bdc_gadget_ep_queue,\n\t.dequeue = bdc_gadget_ep_dequeue,\n\t.set_halt = bdc_gadget_ep_set_halt\n};\n\n \nstatic int init_ep(struct bdc *bdc, u32 epnum, u32 dir)\n{\n\tstruct bdc_ep *ep;\n\n\tdev_dbg(bdc->dev, \"%s epnum=%d dir=%d\\n\", __func__, epnum, dir);\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep->bdc = bdc;\n\tep->dir = dir;\n\n\tif (dir)\n\t\tep->usb_ep.caps.dir_in = true;\n\telse\n\t\tep->usb_ep.caps.dir_out = true;\n\n\t \n\tif (epnum == 1) {\n\t\tep->ep_num = 1;\n\t\tbdc->bdc_ep_array[ep->ep_num] = ep;\n\t\tsnprintf(ep->name, sizeof(ep->name), \"ep%d\", epnum - 1);\n\t\tusb_ep_set_maxpacket_limit(&ep->usb_ep, EP0_MAX_PKT_SIZE);\n\t\tep->usb_ep.caps.type_control = true;\n\t\tep->comp_desc = NULL;\n\t\tbdc->gadget.ep0 = &ep->usb_ep;\n\t} else {\n\t\tif (dir)\n\t\t\tep->ep_num = epnum * 2 - 1;\n\t\telse\n\t\t\tep->ep_num = epnum * 2 - 2;\n\n\t\tbdc->bdc_ep_array[ep->ep_num] = ep;\n\t\tsnprintf(ep->name, sizeof(ep->name), \"ep%d%s\", epnum - 1,\n\t\t\t dir & 1 ? \"in\" : \"out\");\n\n\t\tusb_ep_set_maxpacket_limit(&ep->usb_ep, 1024);\n\t\tep->usb_ep.caps.type_iso = true;\n\t\tep->usb_ep.caps.type_bulk = true;\n\t\tep->usb_ep.caps.type_int = true;\n\t\tep->usb_ep.max_streams = 0;\n\t\tlist_add_tail(&ep->usb_ep.ep_list, &bdc->gadget.ep_list);\n\t}\n\tep->usb_ep.ops = &bdc_gadget_ep_ops;\n\tep->usb_ep.name = ep->name;\n\tep->flags = 0;\n\tep->ignore_next_sr = false;\n\tdev_dbg(bdc->dev, \"ep=%p ep->usb_ep.name=%s epnum=%d ep->epnum=%d\\n\",\n\t\t\t\tep, ep->usb_ep.name, epnum, ep->ep_num);\n\n\tINIT_LIST_HEAD(&ep->queue);\n\n\treturn 0;\n}\n\n \nint bdc_init_ep(struct bdc *bdc)\n{\n\tu8 epnum;\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tINIT_LIST_HEAD(&bdc->gadget.ep_list);\n\t \n\tret = init_ep(bdc, 1, 0);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"init ep ep0 fail %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (epnum = 2; epnum <= bdc->num_eps / 2; epnum++) {\n\t\t \n\t\tret = init_ep(bdc, epnum, 0);\n\t\tif (ret) {\n\t\t\tdev_err(bdc->dev,\n\t\t\t\t\"init ep failed for:%d error: %d\\n\",\n\t\t\t\tepnum, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = init_ep(bdc, epnum, 1);\n\t\tif (ret) {\n\t\t\tdev_err(bdc->dev,\n\t\t\t\t\"init ep failed for:%d error: %d\\n\",\n\t\t\t\tepnum, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}