{
  "module_name": "bdc_udc.c",
  "hash_id": "9e14e17cd476ee06d9c72a07aaf8a79da8c610387858f7bd3cb86a5006e0fcf5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/bdc/bdc_udc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/pm.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <asm/unaligned.h>\n#include <linux/platform_device.h>\n\n#include \"bdc.h\"\n#include \"bdc_ep.h\"\n#include \"bdc_cmd.h\"\n#include \"bdc_dbg.h\"\n\nstatic const struct usb_gadget_ops bdc_gadget_ops;\n\nstatic const char * const conn_speed_str[] =  {\n\t\"Not connected\",\n\t\"Full Speed\",\n\t\"Low Speed\",\n\t\"High Speed\",\n\t\"Super Speed\",\n};\n\n \nstatic struct usb_endpoint_descriptor bdc_gadget_ep0_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes = USB_ENDPOINT_XFER_CONTROL,\n\t.bEndpointAddress = 0,\n\t.wMaxPacketSize\t= cpu_to_le16(EP0_MAX_PKT_SIZE),\n};\n\n \nstatic void srr_dqp_index_advc(struct bdc *bdc, u32 srr_num)\n{\n\tstruct srr *srr;\n\n\tsrr = &bdc->srr;\n\tdev_dbg_ratelimited(bdc->dev, \"srr->dqp_index:%d\\n\", srr->dqp_index);\n\tsrr->dqp_index++;\n\t \n\tif (srr->dqp_index == NUM_SR_ENTRIES)\n\t\tsrr->dqp_index = 0;\n}\n\n \nstatic void bdc_uspc_connected(struct bdc *bdc)\n{\n\tu32 speed, temp;\n\tu32 usppms;\n\tint ret;\n\n\ttemp = bdc_readl(bdc->regs, BDC_USPC);\n\tspeed = BDC_PSP(temp);\n\tdev_dbg(bdc->dev, \"%s speed=%x\\n\", __func__, speed);\n\tswitch (speed) {\n\tcase BDC_SPEED_SS:\n\t\tbdc_gadget_ep0_desc.wMaxPacketSize =\n\t\t\t\t\t\tcpu_to_le16(EP0_MAX_PKT_SIZE);\n\t\tbdc->gadget.ep0->maxpacket = EP0_MAX_PKT_SIZE;\n\t\tbdc->gadget.speed = USB_SPEED_SUPER;\n\t\t \n\t\tusppms =  bdc_readl(bdc->regs, BDC_USPPMS);\n\t\tusppms &= ~BDC_U1T(0xff);\n\t\tusppms |= BDC_U1T(U1_TIMEOUT);\n\t\tusppms |= BDC_PORT_W1S;\n\t\tbdc_writel(bdc->regs, BDC_USPPMS, usppms);\n\t\tbreak;\n\n\tcase BDC_SPEED_HS:\n\t\tbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbdc->gadget.ep0->maxpacket = 64;\n\t\tbdc->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\n\tcase BDC_SPEED_FS:\n\t\tbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbdc->gadget.ep0->maxpacket = 64;\n\t\tbdc->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\n\tcase BDC_SPEED_LS:\n\t\tbdc_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);\n\t\tbdc->gadget.ep0->maxpacket = 8;\n\t\tbdc->gadget.speed = USB_SPEED_LOW;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(bdc->dev, \"UNDEFINED SPEED\\n\");\n\t\treturn;\n\t}\n\tdev_dbg(bdc->dev, \"connected at %s\\n\", conn_speed_str[speed]);\n\t \n\tbdc->bdc_ep_array[1]->desc = &bdc_gadget_ep0_desc;\n\tret = bdc_config_ep(bdc, bdc->bdc_ep_array[1]);\n\tif (ret)\n\t\tdev_err(bdc->dev, \"EP0 config failed\\n\");\n\tbdc->bdc_ep_array[1]->usb_ep.desc = &bdc_gadget_ep0_desc;\n\tbdc->bdc_ep_array[1]->flags |= BDC_EP_ENABLED;\n\tusb_gadget_set_state(&bdc->gadget, USB_STATE_DEFAULT);\n}\n\n \nstatic void bdc_uspc_disconnected(struct bdc *bdc, bool reinit)\n{\n\tstruct bdc_ep *ep;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\t \n\tep = bdc->bdc_ep_array[1];\n\tif (ep && (ep->flags & BDC_EP_ENABLED))\n\t\t \n\t\tbdc_ep_disable(ep);\n\n\tif (bdc->gadget_driver && bdc->gadget_driver->disconnect) {\n\t\tspin_unlock(&bdc->lock);\n\t\tbdc->gadget_driver->disconnect(&bdc->gadget);\n\t\tspin_lock(&bdc->lock);\n\t}\n\t \n\tbdc->gadget.speed = USB_SPEED_UNKNOWN;\n\tbdc->devstatus &= DEVSTATUS_CLEAR;\n\tbdc->delayed_status = false;\n\tbdc->reinit = reinit;\n\tbdc->test_mode = false;\n\tusb_gadget_set_state(&bdc->gadget, USB_STATE_NOTATTACHED);\n}\n\n \nstatic void bdc_func_wake_timer(struct work_struct *work)\n{\n\tstruct bdc *bdc = container_of(work, struct bdc, func_wake_notify.work);\n\tunsigned long flags;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\t \n\tif (bdc->devstatus & FUNC_WAKE_ISSUED) {\n\t\tdev_dbg(bdc->dev, \"FUNC_WAKE_ISSUED FLAG IS STILL SET\\n\");\n\t\t \n\t\tbdc_function_wake_fh(bdc, 0);\n\t\tschedule_delayed_work(&bdc->func_wake_notify,\n\t\t\t\t\t\tmsecs_to_jiffies(BDC_TNOTIFY));\n\t}\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n}\n\n \nstatic void handle_link_state_change(struct bdc *bdc, u32 uspc)\n{\n\tu32 link_state;\n\n\tdev_dbg(bdc->dev, \"Link state change\");\n\tlink_state = BDC_PST(uspc);\n\tswitch (link_state) {\n\tcase BDC_LINK_STATE_U3:\n\t\tif ((bdc->gadget.speed != USB_SPEED_UNKNOWN) &&\n\t\t\t\t\t\tbdc->gadget_driver->suspend) {\n\t\t\tdev_dbg(bdc->dev, \"Entered Suspend mode\\n\");\n\t\t\tspin_unlock(&bdc->lock);\n\t\t\tbdc->devstatus |= DEVICE_SUSPENDED;\n\t\t\tbdc->gadget_driver->suspend(&bdc->gadget);\n\t\t\tspin_lock(&bdc->lock);\n\t\t}\n\t\tbreak;\n\tcase BDC_LINK_STATE_U0:\n\t\tif (bdc->devstatus & REMOTE_WAKEUP_ISSUED) {\n\t\t\tbdc->devstatus &= ~REMOTE_WAKEUP_ISSUED;\n\t\t\tif (bdc->gadget.speed == USB_SPEED_SUPER) {\n\t\t\t\tbdc_function_wake_fh(bdc, 0);\n\t\t\t\tbdc->devstatus |= FUNC_WAKE_ISSUED;\n\t\t\t\t \n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t\t&bdc->func_wake_notify,\n\t\t\t\t\t\tmsecs_to_jiffies(BDC_TNOTIFY));\n\t\t\t\tdev_dbg(bdc->dev, \"sched func_wake_notify\\n\");\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase BDC_LINK_STATE_RESUME:\n\t\tdev_dbg(bdc->dev, \"Resumed from Suspend\\n\");\n\t\tif (bdc->devstatus & DEVICE_SUSPENDED) {\n\t\t\tbdc->gadget_driver->resume(&bdc->gadget);\n\t\t\tbdc->devstatus &= ~DEVICE_SUSPENDED;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(bdc->dev, \"link state:%d\\n\", link_state);\n\t}\n}\n\n \nvoid bdc_sr_uspc(struct bdc *bdc, struct bdc_sr *sreport)\n{\n\tu32 clear_flags = 0;\n\tu32 uspc;\n\tbool connected = false;\n\tbool disconn = false;\n\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tdev_dbg(bdc->dev, \"%s uspc=0x%08x\\n\", __func__, uspc);\n\n\t \n\tif (uspc & BDC_PCC) {\n\t\t \n\t\tif ((uspc & BDC_VBC) && !(uspc & BDC_VBS) && !(uspc & BDC_PCS))\n\t\t\tdisconn = true;\n\t\telse if ((uspc & BDC_PCS) && !BDC_PST(uspc))\n\t\t\tconnected = true;\n\t\tclear_flags |= BDC_PCC;\n\t}\n\n\t \n\tif ((uspc & BDC_VBC) && (uspc & BDC_VBS)) {\n\t\tif (bdc->pullup) {\n\t\t\tdev_dbg(bdc->dev, \"Do a softconnect\\n\");\n\t\t\t \n\t\t\tbdc_softconn(bdc);\n\t\t\tusb_gadget_set_state(&bdc->gadget, USB_STATE_POWERED);\n\t\t}\n\t\tclear_flags |= BDC_VBC;\n\t} else if ((uspc & BDC_PRS) || (uspc & BDC_PRC) || disconn) {\n\t\t \n\t\tdev_dbg(bdc->dev, \"Port reset or disconn\\n\");\n\t\tbdc_uspc_disconnected(bdc, disconn);\n\t\tclear_flags |= BDC_PRC;\n\t} else if ((uspc & BDC_PSC) && (uspc & BDC_PCS)) {\n\t\t \n\t\thandle_link_state_change(bdc, uspc);\n\t\tclear_flags |= BDC_PSC;\n\t}\n\n\t \n\tif (connected) {\n\t\t \n\t\tdev_dbg(bdc->dev, \"Connected\\n\");\n\t\tbdc_uspc_connected(bdc);\n\t\tbdc->devstatus &= ~(DEVICE_SUSPENDED);\n\t}\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tuspc &= (~BDC_USPSC_RW);\n\tdev_dbg(bdc->dev, \"uspc=%x\\n\", uspc);\n\tbdc_writel(bdc->regs, BDC_USPC, clear_flags);\n}\n\n \nstatic irqreturn_t bdc_udc_interrupt(int irq, void *_bdc)\n{\n\tu32 eqp_index, dqp_index, sr_type, srr_int;\n\tstruct bdc_sr *sreport;\n\tstruct bdc *bdc = _bdc;\n\tu32 status;\n\tint ret;\n\n\tspin_lock(&bdc->lock);\n\tstatus = bdc_readl(bdc->regs, BDC_BDCSC);\n\tif (!(status & BDC_GIP)) {\n\t\tspin_unlock(&bdc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\tsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\n\t \n\tif (!(srr_int & BDC_SRR_IP)) {\n\t\tdev_warn(bdc->dev, \"Global irq pending but SRR IP is 0\\n\");\n\t\tspin_unlock(&bdc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\teqp_index = BDC_SRR_EPI(srr_int);\n\tdqp_index = BDC_SRR_DPI(srr_int);\n\tdev_dbg(bdc->dev,\n\t\t\t\"%s eqp_index=%d dqp_index=%d  srr.dqp_index=%d\\n\\n\",\n\t\t\t __func__, eqp_index, dqp_index, bdc->srr.dqp_index);\n\n\t \n\tif (eqp_index == dqp_index) {\n\t\tdev_dbg(bdc->dev, \"SRR empty?\\n\");\n\t\tspin_unlock(&bdc->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (bdc->srr.dqp_index != eqp_index) {\n\t\tsreport = &bdc->srr.sr_bds[bdc->srr.dqp_index];\n\t\t \n\t\trmb();\n\t\tsr_type = le32_to_cpu(sreport->offset[3]) & BD_TYPE_BITMASK;\n\t\tdev_dbg_ratelimited(bdc->dev, \"sr_type=%d\\n\", sr_type);\n\t\tswitch (sr_type) {\n\t\tcase SR_XSF:\n\t\t\tbdc->sr_handler[0](bdc, sreport);\n\t\t\tbreak;\n\n\t\tcase SR_USPC:\n\t\t\tbdc->sr_handler[1](bdc, sreport);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(bdc->dev, \"SR:%d not handled\\n\", sr_type);\n\t\t}\n\t\t \n\t\tsrr_dqp_index_advc(bdc, 0);\n\t}\n\t \n\tsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\n\tsrr_int &= ~BDC_SRR_DPI_MASK;\n\tsrr_int &= ~(BDC_SRR_RWS|BDC_SRR_RST|BDC_SRR_ISR);\n\tsrr_int |= ((bdc->srr.dqp_index) << 16);\n\tsrr_int |= BDC_SRR_IP;\n\tbdc_writel(bdc->regs, BDC_SRRINT(0), srr_int);\n\tsrr_int = bdc_readl(bdc->regs, BDC_SRRINT(0));\n\tif (bdc->reinit) {\n\t\tret = bdc_reinit(bdc);\n\t\tif (ret)\n\t\t\tdev_err(bdc->dev, \"err in bdc reinit\\n\");\n\t}\n\n\tspin_unlock(&bdc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int bdc_udc_start(struct usb_gadget *gadget,\n\t\t\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct bdc *bdc = gadget_to_bdc(gadget);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tif (bdc->gadget_driver) {\n\t\tdev_err(bdc->dev, \"%s is already bound to %s\\n\",\n\t\t\tbdc->gadget.name,\n\t\t\tbdc->gadget_driver->driver.name);\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\t \n\tret = bdc_run(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"%s bdc run fail\\n\", __func__);\n\t\tgoto err;\n\t}\n\tbdc->gadget_driver = driver;\n\tbdc->gadget.dev.driver = &driver->driver;\nerr:\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int bdc_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct bdc *bdc = gadget_to_bdc(gadget);\n\tunsigned long flags;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tbdc_stop(bdc);\n\tbdc->gadget_driver = NULL;\n\tbdc->gadget.dev.driver = NULL;\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bdc_udc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct bdc *bdc = gadget_to_bdc(gadget);\n\tunsigned long flags;\n\tu32 uspc;\n\n\tdev_dbg(bdc->dev, \"%s() is_on:%d\\n\", __func__, is_on);\n\tif (!gadget)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tif (!is_on) {\n\t\tbdc_softdisconn(bdc);\n\t\tbdc->pullup = false;\n\t} else {\n\t\t \n\t\tbdc->pullup = true;\n\t\t \n\t\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\t\tif (uspc & BDC_VBS)\n\t\t\tbdc_softconn(bdc);\n\t}\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bdc_udc_set_selfpowered(struct usb_gadget *gadget,\n\t\tint is_self)\n{\n\tstruct bdc\t\t*bdc = gadget_to_bdc(gadget);\n\tunsigned long           flags;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tgadget->is_selfpowered = (is_self != 0);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tif (!is_self)\n\t\tbdc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\n\telse\n\t\tbdc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int bdc_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct bdc *bdc = gadget_to_bdc(gadget);\n\tunsigned long\t\tflags;\n\tu8\tlink_state;\n\tu32\tuspc;\n\tint ret = 0;\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s() bdc->devstatus=%08x\\n\",\n\t\t__func__, bdc->devstatus);\n\n\tif (!(bdc->devstatus & REMOTE_WAKE_ENABLE))\n\t\treturn  -EOPNOTSUPP;\n\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tlink_state = BDC_PST(uspc);\n\tdev_dbg(bdc->dev, \"link_state =%d portsc=%x\", link_state, uspc);\n\tif (link_state != BDC_LINK_STATE_U3) {\n\t\tdev_warn(bdc->dev,\n\t\t\t\"can't wakeup from link state %d\\n\",\n\t\t\tlink_state);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (bdc->gadget.speed == USB_SPEED_SUPER)\n\t\tbdc->devstatus |= REMOTE_WAKEUP_ISSUED;\n\n\tuspc &= ~BDC_PST_MASK;\n\tuspc &= (~BDC_USPSC_RW);\n\tuspc |=  BDC_PST(BDC_LINK_STATE_U0);\n\tuspc |=  BDC_SWS;\n\tbdc_writel(bdc->regs, BDC_USPC, uspc);\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tlink_state = BDC_PST(uspc);\n\tdev_dbg(bdc->dev, \"link_state =%d portsc=%x\", link_state, uspc);\nout:\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct usb_gadget_ops bdc_gadget_ops = {\n\t.wakeup = bdc_udc_wakeup,\n\t.set_selfpowered = bdc_udc_set_selfpowered,\n\t.pullup = bdc_udc_pullup,\n\t.udc_start = bdc_udc_start,\n\t.udc_stop = bdc_udc_stop,\n};\n\n \nint bdc_udc_init(struct bdc *bdc)\n{\n\tu32 temp;\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tbdc->gadget.ops = &bdc_gadget_ops;\n\tbdc->gadget.max_speed = USB_SPEED_SUPER;\n\tbdc->gadget.speed = USB_SPEED_UNKNOWN;\n\tbdc->gadget.dev.parent = bdc->dev;\n\n\tbdc->gadget.sg_supported = false;\n\n\n\tbdc->gadget.name = BRCM_BDC_NAME;\n\tret = devm_request_irq(bdc->dev, bdc->irq, bdc_udc_interrupt,\n\t\t\t\tIRQF_SHARED, BRCM_BDC_NAME, bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev,\n\t\t\t\"failed to request irq #%d %d\\n\",\n\t\t\tbdc->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = bdc_init_ep(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"bdc init ep fail: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = usb_add_gadget_udc(bdc->dev, &bdc->gadget);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"failed to register udc\\n\");\n\t\tgoto err0;\n\t}\n\tusb_gadget_set_state(&bdc->gadget, USB_STATE_NOTATTACHED);\n\tbdc->bdc_ep_array[1]->desc = &bdc_gadget_ep0_desc;\n\t \n\tret = bdc_ep_enable(bdc->bdc_ep_array[1]);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"fail to enable %s\\n\",\n\t\t\t\t\t\tbdc->bdc_ep_array[1]->name);\n\t\tgoto err1;\n\t}\n\tINIT_DELAYED_WORK(&bdc->func_wake_notify, bdc_func_wake_timer);\n\t \n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\ttemp |= BDC_GIE;\n\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\treturn 0;\nerr1:\n\tusb_del_gadget_udc(&bdc->gadget);\nerr0:\n\tbdc_free_ep(bdc);\n\n\treturn ret;\n}\n\nvoid bdc_udc_exit(struct bdc *bdc)\n{\n\tunsigned long flags;\n\n\tdev_dbg(bdc->dev, \"%s()\\n\", __func__);\n\tspin_lock_irqsave(&bdc->lock, flags);\n\tbdc_ep_disable(bdc->bdc_ep_array[1]);\n\tspin_unlock_irqrestore(&bdc->lock, flags);\n\n\tusb_del_gadget_udc(&bdc->gadget);\n\tbdc_free_ep(bdc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}