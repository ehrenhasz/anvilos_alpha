{
  "module_name": "bdc_core.c",
  "hash_id": "760717cd035e9a8770f2f3487a0d392dd28b62b3f97e6c987a8fd7f98e2816c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/bdc/bdc_core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/moduleparam.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/clk.h>\n\n#include \"bdc.h\"\n#include \"bdc_dbg.h\"\n\n \nstatic int poll_oip(struct bdc *bdc, u32 usec)\n{\n\tu32 status;\n\tint ret;\n\n\tret = readl_poll_timeout(bdc->regs + BDC_BDCSC, status,\n\t\t\t\t (BDC_CSTS(status) != BDC_OIP), 10, usec);\n\tif (ret)\n\t\tdev_err(bdc->dev, \"operation timedout BDCSC: 0x%08x\\n\", status);\n\telse\n\t\tdev_dbg(bdc->dev, \"%s complete status=%d\", __func__, BDC_CSTS(status));\n\n\treturn ret;\n}\n\n \nint bdc_stop(struct bdc *bdc)\n{\n\tint ret;\n\tu32 temp;\n\n\tdev_dbg(bdc->dev, \"%s ()\\n\\n\", __func__);\n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\t \n\tif (BDC_CSTS(temp) == BDC_HLT) {\n\t\tdev_vdbg(bdc->dev, \"BDC already halted\\n\");\n\t\treturn 0;\n\t}\n\ttemp &= ~BDC_COP_MASK;\n\ttemp |= BDC_COS|BDC_COP_STP;\n\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\n\tret = poll_oip(bdc, BDC_COP_TIMEOUT);\n\tif (ret)\n\t\tdev_err(bdc->dev, \"bdc stop operation failed\");\n\n\treturn ret;\n}\n\n \nint bdc_reset(struct bdc *bdc)\n{\n\tu32 temp;\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\t \n\tret = bdc_stop(bdc);\n\tif (ret)\n\t\treturn ret;\n\n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\ttemp &= ~BDC_COP_MASK;\n\ttemp |= BDC_COS|BDC_COP_RST;\n\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\tret = poll_oip(bdc, BDC_COP_TIMEOUT);\n\tif (ret)\n\t\tdev_err(bdc->dev, \"bdc reset operation failed\");\n\n\treturn ret;\n}\n\n \nint bdc_run(struct bdc *bdc)\n{\n\tu32 temp;\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\t \n\tif (BDC_CSTS(temp) == BDC_NOR) {\n\t\tdev_warn(bdc->dev, \"bdc is already in running state\\n\");\n\t\treturn 0;\n\t}\n\ttemp &= ~BDC_COP_MASK;\n\ttemp |= BDC_COP_RUN;\n\ttemp |= BDC_COS;\n\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\tret = poll_oip(bdc, BDC_COP_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"bdc run operation failed:%d\", ret);\n\t\treturn ret;\n\t}\n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\tif (BDC_CSTS(temp) != BDC_NOR) {\n\t\tdev_err(bdc->dev, \"bdc not in normal mode after RUN op :%d\\n\",\n\t\t\t\t\t\t\t\tBDC_CSTS(temp));\n\t\treturn -ESHUTDOWN;\n\t}\n\n\treturn 0;\n}\n\n \nvoid bdc_softconn(struct bdc *bdc)\n{\n\tu32 uspc;\n\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tuspc &= ~BDC_PST_MASK;\n\tuspc |= BDC_LINK_STATE_RX_DET;\n\tuspc |= BDC_SWS;\n\tdev_dbg(bdc->dev, \"%s () uspc=%08x\\n\", __func__, uspc);\n\tbdc_writel(bdc->regs, BDC_USPC, uspc);\n}\n\n \nvoid bdc_softdisconn(struct bdc *bdc)\n{\n\tu32 uspc;\n\n\tuspc = bdc_readl(bdc->regs, BDC_USPC);\n\tuspc |= BDC_SDC;\n\tuspc &= ~BDC_SCN;\n\tdev_dbg(bdc->dev, \"%s () uspc=%x\\n\", __func__, uspc);\n\tbdc_writel(bdc->regs, BDC_USPC, uspc);\n}\n\n \nstatic int scratchpad_setup(struct bdc *bdc)\n{\n\tint sp_buff_size;\n\tu32 low32;\n\tu32 upp32;\n\n\tsp_buff_size = BDC_SPB(bdc_readl(bdc->regs, BDC_BDCCFG0));\n\tdev_dbg(bdc->dev, \"%s() sp_buff_size=%d\\n\", __func__, sp_buff_size);\n\tif (!sp_buff_size) {\n\t\tdev_dbg(bdc->dev, \"Scratchpad buffer not needed\\n\");\n\t\treturn 0;\n\t}\n\t \n\tsp_buff_size = 1 << (sp_buff_size + 5);\n\tdev_dbg(bdc->dev, \"Allocating %d bytes for scratchpad\\n\", sp_buff_size);\n\tbdc->scratchpad.buff  =  dma_alloc_coherent(bdc->dev, sp_buff_size,\n\t\t\t\t\t\t    &bdc->scratchpad.sp_dma,\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\tif (!bdc->scratchpad.buff)\n\t\tgoto fail;\n\n\tbdc->sp_buff_size = sp_buff_size;\n\tbdc->scratchpad.size = sp_buff_size;\n\tlow32 = lower_32_bits(bdc->scratchpad.sp_dma);\n\tupp32 = upper_32_bits(bdc->scratchpad.sp_dma);\n\tcpu_to_le32s(&low32);\n\tcpu_to_le32s(&upp32);\n\tbdc_writel(bdc->regs, BDC_SPBBAL, low32);\n\tbdc_writel(bdc->regs, BDC_SPBBAH, upp32);\n\treturn 0;\n\nfail:\n\tbdc->scratchpad.buff = NULL;\n\n\treturn -ENOMEM;\n}\n\n \nstatic int setup_srr(struct bdc *bdc, int interrupter)\n{\n\tdev_dbg(bdc->dev, \"%s() NUM_SR_ENTRIES:%d\\n\", __func__, NUM_SR_ENTRIES);\n\t \n\tbdc_writel(bdc->regs, BDC_SRRINT(0), BDC_SRR_RWS | BDC_SRR_RST);\n\tbdc->srr.dqp_index = 0;\n\t \n\tbdc->srr.sr_bds = dma_alloc_coherent(bdc->dev,\n\t\t\t\t\t     NUM_SR_ENTRIES * sizeof(struct bdc_bd),\n\t\t\t\t\t     &bdc->srr.dma_addr, GFP_KERNEL);\n\tif (!bdc->srr.sr_bds)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic void bdc_mem_init(struct bdc *bdc, bool reinit)\n{\n\tu8 size = 0;\n\tu32 usb2_pm;\n\tu32 low32;\n\tu32 upp32;\n\tu32 temp;\n\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\tbdc->ep0_state = WAIT_FOR_SETUP;\n\tbdc->dev_addr = 0;\n\tbdc->srr.eqp_index = 0;\n\tbdc->srr.dqp_index = 0;\n\tbdc->zlp_needed = false;\n\tbdc->delayed_status = false;\n\n\tbdc_writel(bdc->regs, BDC_SPBBAL, bdc->scratchpad.sp_dma);\n\t \n\ttemp = BDC_SRR_RWS | BDC_SRR_RST;\n\t \n\tbdc_writel(bdc->regs, BDC_SRRINT(0), temp);\n\tdev_dbg(bdc->dev, \"bdc->srr.sr_bds =%p\\n\", bdc->srr.sr_bds);\n\ttemp = lower_32_bits(bdc->srr.dma_addr);\n\tsize = fls(NUM_SR_ENTRIES) - 2;\n\ttemp |= size;\n\tdev_dbg(bdc->dev, \"SRRBAL[0]=%08x NUM_SR_ENTRIES:%d size:%d\\n\",\n\t\t\t\t\t\ttemp, NUM_SR_ENTRIES, size);\n\n\tlow32 = lower_32_bits(temp);\n\tupp32 = upper_32_bits(bdc->srr.dma_addr);\n\tcpu_to_le32s(&low32);\n\tcpu_to_le32s(&upp32);\n\n\t \n\tbdc_writel(bdc->regs, BDC_SRRBAL(0), low32);\n\tbdc_writel(bdc->regs, BDC_SRRBAH(0), upp32);\n\n\ttemp = bdc_readl(bdc->regs, BDC_SRRINT(0));\n\ttemp |= BDC_SRR_IE;\n\ttemp &= ~(BDC_SRR_RST | BDC_SRR_RWS);\n\tbdc_writel(bdc->regs, BDC_SRRINT(0), temp);\n\n\t \n\ttemp = bdc_readl(bdc->regs, BDC_INTCTLS(0));\n\ttemp &= ~0xffff;\n\ttemp |= INT_CLS;\n\tbdc_writel(bdc->regs, BDC_INTCTLS(0), temp);\n\n\tusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\n\tdev_dbg(bdc->dev, \"usb2_pm=%08x\", usb2_pm);\n\t \n\tusb2_pm |= BDC_HLE;\n\tbdc_writel(bdc->regs, BDC_USPPM2, usb2_pm);\n\n\t \n\tusb2_pm = bdc_readl(bdc->regs, BDC_USPPM2);\n\tdev_dbg(bdc->dev, \"usb2_pm=%08x\\n\", usb2_pm);\n\n\t \n\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\t \n\ttemp |= BDC_MASK_MCW;\n\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\n\t \n\tif (reinit) {\n\t\tint i;\n\t\t \n\t\ttemp = bdc_readl(bdc->regs, BDC_BDCSC);\n\t\ttemp |= BDC_GIE;\n\t\tbdc_writel(bdc->regs, BDC_BDCSC, temp);\n\t\t \n\t\tmemset(bdc->scratchpad.buff, 0, bdc->sp_buff_size);\n\t\t \n\t\tmemset(bdc->srr.sr_bds, 0,\n\t\t\t\t\tNUM_SR_ENTRIES * sizeof(struct bdc_bd));\n\t\t \n\t\tif (!bdc->gadget.speed)\n\t\t\tfor (i = 1; i < bdc->num_eps; ++i)\n\t\t\t\tbdc->bdc_ep_array[i]->flags = 0;\n\t} else {\n\t\t \n\t\t \n\t\tbdc->sr_handler[0] = bdc_sr_xsf;\n\t\tbdc->sr_handler[1] = bdc_sr_uspc;\n\n\t\t \n\t\tbdc->sr_xsf_ep0[0] = bdc_xsf_ep0_setup_recv;\n\t\tbdc->sr_xsf_ep0[1] = bdc_xsf_ep0_data_start;\n\t\tbdc->sr_xsf_ep0[2] = bdc_xsf_ep0_status_start;\n\t}\n}\n\n \nstatic void bdc_mem_free(struct bdc *bdc)\n{\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\t \n\tif (bdc->srr.sr_bds)\n\t\tdma_free_coherent(bdc->dev,\n\t\t\t\t\tNUM_SR_ENTRIES * sizeof(struct bdc_bd),\n\t\t\t\t\tbdc->srr.sr_bds, bdc->srr.dma_addr);\n\n\t \n\tif (bdc->scratchpad.buff)\n\t\tdma_free_coherent(bdc->dev, bdc->sp_buff_size,\n\t\t\t\tbdc->scratchpad.buff, bdc->scratchpad.sp_dma);\n\n\t \n\tdma_pool_destroy(bdc->bd_table_pool);\n\n\t \n\tkfree(bdc->bdc_ep_array);\n\n\tbdc->srr.sr_bds = NULL;\n\tbdc->scratchpad.buff = NULL;\n\tbdc->bd_table_pool = NULL;\n\tbdc->bdc_ep_array = NULL;\n}\n\n \nint bdc_reinit(struct bdc *bdc)\n{\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s\\n\", __func__);\n\tret = bdc_stop(bdc);\n\tif (ret)\n\t\tgoto out;\n\n\tret = bdc_reset(bdc);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tbdc_mem_init(bdc, true);\n\tret = bdc_run(bdc);\nout:\n\tbdc->reinit = false;\n\n\treturn ret;\n}\n\n \nstatic int bdc_mem_alloc(struct bdc *bdc)\n{\n\tu32 page_size;\n\tunsigned int num_ieps, num_oeps;\n\n\tdev_dbg(bdc->dev,\n\t\t\"%s() NUM_BDS_PER_TABLE:%d\\n\", __func__,\n\t\tNUM_BDS_PER_TABLE);\n\tpage_size = BDC_PGS(bdc_readl(bdc->regs, BDC_BDCCFG0));\n\t \n\tpage_size = 1 << page_size;\n\t \n\tpage_size <<= 10;\n\tdev_dbg(bdc->dev, \"page_size=%d\\n\", page_size);\n\n\t \n\tbdc->bd_table_pool =\n\t    dma_pool_create(\"BDC BD tables\", bdc->dev, NUM_BDS_PER_TABLE * 16,\n\t\t\t\t\t\t\t\t16, page_size);\n\n\tif (!bdc->bd_table_pool)\n\t\tgoto fail;\n\n\tif (scratchpad_setup(bdc))\n\t\tgoto fail;\n\n\t \n\tnum_ieps = NUM_NCS(bdc_readl(bdc->regs, BDC_FSCNIC));\n\tnum_oeps = NUM_NCS(bdc_readl(bdc->regs, BDC_FSCNOC));\n\t \n\tbdc->num_eps = num_ieps + num_oeps + 2;\n\tdev_dbg(bdc->dev,\n\t\t\"ieps:%d eops:%d num_eps:%d\\n\",\n\t\tnum_ieps, num_oeps, bdc->num_eps);\n\t \n\tbdc->bdc_ep_array = kcalloc(bdc->num_eps, sizeof(struct bdc_ep *),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!bdc->bdc_ep_array)\n\t\tgoto fail;\n\n\tdev_dbg(bdc->dev, \"Allocating sr report0\\n\");\n\tif (setup_srr(bdc, 0))\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tdev_warn(bdc->dev, \"Couldn't initialize memory\\n\");\n\tbdc_mem_free(bdc);\n\n\treturn -ENOMEM;\n}\n\n \nstatic void bdc_hw_exit(struct bdc *bdc)\n{\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\tbdc_mem_free(bdc);\n}\n\n \nstatic int bdc_hw_init(struct bdc *bdc)\n{\n\tint ret;\n\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\tret = bdc_reset(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"err resetting bdc abort bdc init%d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = bdc_mem_alloc(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"Mem alloc failed, aborting\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tbdc_mem_init(bdc, 0);\n\tbdc_dbg_regs(bdc);\n\tdev_dbg(bdc->dev, \"HW Init done\\n\");\n\n\treturn 0;\n}\n\nstatic int bdc_phy_init(struct bdc *bdc)\n{\n\tint phy_num;\n\tint ret;\n\n\tfor (phy_num = 0; phy_num < bdc->num_phys; phy_num++) {\n\t\tret = phy_init(bdc->phys[phy_num]);\n\t\tif (ret)\n\t\t\tgoto err_exit_phy;\n\t\tret = phy_power_on(bdc->phys[phy_num]);\n\t\tif (ret) {\n\t\t\tphy_exit(bdc->phys[phy_num]);\n\t\t\tgoto err_exit_phy;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_exit_phy:\n\twhile (--phy_num >= 0) {\n\t\tphy_power_off(bdc->phys[phy_num]);\n\t\tphy_exit(bdc->phys[phy_num]);\n\t}\n\n\treturn ret;\n}\n\nstatic void bdc_phy_exit(struct bdc *bdc)\n{\n\tint phy_num;\n\n\tfor (phy_num = 0; phy_num < bdc->num_phys; phy_num++) {\n\t\tphy_power_off(bdc->phys[phy_num]);\n\t\tphy_exit(bdc->phys[phy_num]);\n\t}\n}\n\nstatic int bdc_probe(struct platform_device *pdev)\n{\n\tstruct bdc *bdc;\n\tint ret;\n\tint irq;\n\tu32 temp;\n\tstruct device *dev = &pdev->dev;\n\tint phy_num;\n\n\tdev_dbg(dev, \"%s()\\n\", __func__);\n\n\tbdc = devm_kzalloc(dev, sizeof(*bdc), GFP_KERNEL);\n\tif (!bdc)\n\t\treturn -ENOMEM;\n\n\tbdc->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(bdc->regs))\n\t\treturn PTR_ERR(bdc->regs);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tspin_lock_init(&bdc->lock);\n\tplatform_set_drvdata(pdev, bdc);\n\tbdc->irq = irq;\n\tbdc->dev = dev;\n\tdev_dbg(dev, \"bdc->regs: %p irq=%d\\n\", bdc->regs, bdc->irq);\n\n\tbdc->num_phys = of_count_phandle_with_args(dev->of_node,\n\t\t\t\t\t\t\"phys\", \"#phy-cells\");\n\tif (bdc->num_phys > 0) {\n\t\tbdc->phys = devm_kcalloc(dev, bdc->num_phys,\n\t\t\t\t\tsizeof(struct phy *), GFP_KERNEL);\n\t\tif (!bdc->phys)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tbdc->num_phys = 0;\n\t}\n\tdev_info(dev, \"Using %d phy(s)\\n\", bdc->num_phys);\n\n\tfor (phy_num = 0; phy_num < bdc->num_phys; phy_num++) {\n\t\tbdc->phys[phy_num] = devm_of_phy_get_by_index(\n\t\t\tdev, dev->of_node, phy_num);\n\t\tif (IS_ERR(bdc->phys[phy_num])) {\n\t\t\tret = PTR_ERR(bdc->phys[phy_num]);\n\t\t\tdev_err(bdc->dev,\n\t\t\t\t\"BDC phy specified but not found:%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tbdc->clk = devm_clk_get_optional(dev, \"sw_usbd\");\n\tif (IS_ERR(bdc->clk))\n\t\treturn PTR_ERR(bdc->clk);\n\n\tret = clk_prepare_enable(bdc->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"could not enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = bdc_phy_init(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"BDC phy init failure:%d\\n\", ret);\n\t\tgoto disable_clk;\n\t}\n\n\ttemp = bdc_readl(bdc->regs, BDC_BDCCAP1);\n\tif ((temp & BDC_P64) &&\n\t\t\t!dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(dev, \"Using 64-bit address\\n\");\n\t} else {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"No suitable DMA config available, abort\\n\");\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto phycleanup;\n\t\t}\n\t\tdev_dbg(dev, \"Using 32-bit address\\n\");\n\t}\n\tret = bdc_hw_init(bdc);\n\tif (ret) {\n\t\tdev_err(dev, \"BDC init failure:%d\\n\", ret);\n\t\tgoto phycleanup;\n\t}\n\tret = bdc_udc_init(bdc);\n\tif (ret) {\n\t\tdev_err(dev, \"BDC Gadget init failure:%d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\treturn 0;\n\ncleanup:\n\tbdc_hw_exit(bdc);\nphycleanup:\n\tbdc_phy_exit(bdc);\ndisable_clk:\n\tclk_disable_unprepare(bdc->clk);\n\treturn ret;\n}\n\nstatic void bdc_remove(struct platform_device *pdev)\n{\n\tstruct bdc *bdc;\n\n\tbdc  = platform_get_drvdata(pdev);\n\tdev_dbg(bdc->dev, \"%s ()\\n\", __func__);\n\tbdc_udc_exit(bdc);\n\tbdc_hw_exit(bdc);\n\tbdc_phy_exit(bdc);\n\tclk_disable_unprepare(bdc->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int bdc_suspend(struct device *dev)\n{\n\tstruct bdc *bdc = dev_get_drvdata(dev);\n\tint ret;\n\n\t \n\tret = bdc_stop(bdc);\n\tif (!ret)\n\t\tclk_disable_unprepare(bdc->clk);\n\n\treturn ret;\n}\n\nstatic int bdc_resume(struct device *dev)\n{\n\tstruct bdc *bdc = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_prepare_enable(bdc->clk);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"err enabling the clock\\n\");\n\t\treturn ret;\n\t}\n\tret = bdc_reinit(bdc);\n\tif (ret) {\n\t\tdev_err(bdc->dev, \"err in bdc reinit\\n\");\n\t\tclk_disable_unprepare(bdc->clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(bdc_pm_ops, bdc_suspend,\n\t\tbdc_resume);\n\nstatic const struct of_device_id bdc_of_match[] = {\n\t{ .compatible = \"brcm,bdc-udc-v2\" },\n\t{ .compatible = \"brcm,bdc\" },\n\t{   }\n};\n\nstatic struct platform_driver bdc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= BRCM_BDC_NAME,\n\t\t.pm = &bdc_pm_ops,\n\t\t.of_match_table\t= bdc_of_match,\n\t},\n\t.probe\t\t= bdc_probe,\n\t.remove_new\t= bdc_remove,\n};\n\nmodule_platform_driver(bdc_driver);\nMODULE_AUTHOR(\"Ashwini Pahuja <ashwini.linux@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(BRCM_BDC_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}