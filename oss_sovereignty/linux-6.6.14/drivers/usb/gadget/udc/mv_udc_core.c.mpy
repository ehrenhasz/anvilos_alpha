{
  "module_name": "mv_udc_core.c",
  "hash_id": "b5547a55c355617c15230519a4e3f2a4d23654353f7965ae286679641924e0bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/mv_udc_core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/pm.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/platform_data/mv_usb.h>\n#include <asm/unaligned.h>\n\n#include \"mv_udc.h\"\n\n#define DRIVER_DESC\t\t\"Marvell PXA USB Device Controller driver\"\n\n#define ep_dir(ep)\t(((ep)->ep_num == 0) ? \\\n\t\t\t\t((ep)->udc->ep0_dir) : ((ep)->direction))\n\n \n#define RESET_TIMEOUT\t\t10000\n#define FLUSH_TIMEOUT\t\t10000\n#define EPSTATUS_TIMEOUT\t10000\n#define PRIME_TIMEOUT\t\t10000\n#define READSAFE_TIMEOUT\t1000\n\n#define LOOPS_USEC_SHIFT\t1\n#define LOOPS_USEC\t\t(1 << LOOPS_USEC_SHIFT)\n#define LOOPS(timeout)\t\t((timeout) >> LOOPS_USEC_SHIFT)\n\nstatic DECLARE_COMPLETION(release_done);\n\nstatic const char driver_name[] = \"mv_udc\";\n\nstatic void nuke(struct mv_ep *ep, int status);\nstatic void stop_activity(struct mv_udc *udc, struct usb_gadget_driver *driver);\n\n \nstatic const struct usb_endpoint_descriptor mv_ep0_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bEndpointAddress =\t0,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize =\tEP0_MAX_PKT_SIZE,\n};\n\nstatic void ep0_reset(struct mv_udc *udc)\n{\n\tstruct mv_ep *ep;\n\tu32 epctrlx;\n\tint i = 0;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tep = &udc->eps[i];\n\t\tep->udc = udc;\n\n\t\t \n\t\tep->dqh = &udc->ep_dqh[i];\n\n\t\t \n\t\tep->dqh->max_packet_length =\n\t\t\t(EP0_MAX_PKT_SIZE << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\n\t\t\t| EP_QUEUE_HEAD_IOS;\n\n\t\tep->dqh->next_dtd_ptr = EP_QUEUE_HEAD_NEXT_TERMINATE;\n\n\t\tepctrlx = readl(&udc->op_regs->epctrlx[0]);\n\t\tif (i) {\t \n\t\t\tepctrlx |= EPCTRL_TX_ENABLE\n\t\t\t\t| (USB_ENDPOINT_XFER_CONTROL\n\t\t\t\t\t<< EPCTRL_TX_EP_TYPE_SHIFT);\n\n\t\t} else {\t \n\t\t\tepctrlx |= EPCTRL_RX_ENABLE\n\t\t\t\t| (USB_ENDPOINT_XFER_CONTROL\n\t\t\t\t\t<< EPCTRL_RX_EP_TYPE_SHIFT);\n\t\t}\n\n\t\twritel(epctrlx, &udc->op_regs->epctrlx[0]);\n\t}\n}\n\n \nstatic void ep0_stall(struct mv_udc *udc)\n{\n\tu32\tepctrlx;\n\n\t \n\tepctrlx = readl(&udc->op_regs->epctrlx[0]);\n\tepctrlx |= EPCTRL_RX_EP_STALL | EPCTRL_TX_EP_STALL;\n\twritel(epctrlx, &udc->op_regs->epctrlx[0]);\n\n\t \n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = EP_DIR_OUT;\n}\n\nstatic int process_ep_req(struct mv_udc *udc, int index,\n\tstruct mv_req *curr_req)\n{\n\tstruct mv_dtd\t*curr_dtd;\n\tstruct mv_dqh\t*curr_dqh;\n\tint actual, remaining_length;\n\tint i, direction;\n\tint retval = 0;\n\tu32 errors;\n\tu32 bit_pos;\n\n\tcurr_dqh = &udc->ep_dqh[index];\n\tdirection = index % 2;\n\n\tcurr_dtd = curr_req->head;\n\tactual = curr_req->req.length;\n\n\tfor (i = 0; i < curr_req->dtd_count; i++) {\n\t\tif (curr_dtd->size_ioc_sts & DTD_STATUS_ACTIVE) {\n\t\t\tdev_dbg(&udc->dev->dev, \"%s, dTD not completed\\n\",\n\t\t\t\tudc->eps[index].name);\n\t\t\treturn 1;\n\t\t}\n\n\t\terrors = curr_dtd->size_ioc_sts & DTD_ERROR_MASK;\n\t\tif (!errors) {\n\t\t\tremaining_length =\n\t\t\t\t(curr_dtd->size_ioc_sts\t& DTD_PACKET_SIZE)\n\t\t\t\t\t>> DTD_LENGTH_BIT_POS;\n\t\t\tactual -= remaining_length;\n\n\t\t\tif (remaining_length) {\n\t\t\t\tif (direction) {\n\t\t\t\t\tdev_dbg(&udc->dev->dev,\n\t\t\t\t\t\t\"TX dTD remains data\\n\");\n\t\t\t\t\tretval = -EPROTO;\n\t\t\t\t\tbreak;\n\t\t\t\t} else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_info(&udc->dev->dev,\n\t\t\t\t\"complete_tr error: ep=%d %s: error = 0x%x\\n\",\n\t\t\t\tindex >> 1, direction ? \"SEND\" : \"RECV\",\n\t\t\t\terrors);\n\t\t\tif (errors & DTD_STATUS_HALTED) {\n\t\t\t\t \n\t\t\t\tcurr_dqh->size_ioc_int_sts &= ~errors;\n\t\t\t\tretval = -EPIPE;\n\t\t\t} else if (errors & DTD_STATUS_DATA_BUFF_ERR) {\n\t\t\t\tretval = -EPROTO;\n\t\t\t} else if (errors & DTD_STATUS_TRANSACTION_ERR) {\n\t\t\t\tretval = -EILSEQ;\n\t\t\t}\n\t\t}\n\t\tif (i != curr_req->dtd_count - 1)\n\t\t\tcurr_dtd = (struct mv_dtd *)curr_dtd->next_dtd_virt;\n\t}\n\tif (retval)\n\t\treturn retval;\n\n\tif (direction == EP_DIR_OUT)\n\t\tbit_pos = 1 << curr_req->ep->ep_num;\n\telse\n\t\tbit_pos = 1 << (16 + curr_req->ep->ep_num);\n\n\twhile (curr_dqh->curr_dtd_ptr == curr_dtd->td_dma) {\n\t\tif (curr_dtd->dtd_next == EP_QUEUE_HEAD_NEXT_TERMINATE) {\n\t\t\twhile (readl(&udc->op_regs->epstatus) & bit_pos)\n\t\t\t\tudelay(1);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tcurr_req->req.actual = actual;\n\n\treturn 0;\n}\n\n \nstatic void done(struct mv_ep *ep, struct mv_req *req, int status)\n\t__releases(&ep->udc->lock)\n\t__acquires(&ep->udc->lock)\n{\n\tstruct mv_udc *udc = NULL;\n\tunsigned char stopped = ep->stopped;\n\tstruct mv_dtd *curr_td, *next_td;\n\tint j;\n\n\tudc = (struct mv_udc *)ep->udc;\n\t \n\tlist_del_init(&req->queue);\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\t \n\tnext_td = req->head;\n\tfor (j = 0; j < req->dtd_count; j++) {\n\t\tcurr_td = next_td;\n\t\tif (j != req->dtd_count - 1)\n\t\t\tnext_td = curr_td->next_dtd_virt;\n\t\tdma_pool_free(udc->dtd_pool, curr_td, curr_td->td_dma);\n\t}\n\n\tusb_gadget_unmap_request(&udc->gadget, &req->req, ep_dir(ep));\n\n\tif (status && (status != -ESHUTDOWN))\n\t\tdev_info(&udc->dev->dev, \"complete %s req %p stat %d len %u/%u\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\tep->stopped = 1;\n\n\tspin_unlock(&ep->udc->lock);\n\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\n\tspin_lock(&ep->udc->lock);\n\tep->stopped = stopped;\n}\n\nstatic int queue_dtd(struct mv_ep *ep, struct mv_req *req)\n{\n\tstruct mv_udc *udc;\n\tstruct mv_dqh *dqh;\n\tu32 bit_pos, direction;\n\tu32 usbcmd, epstatus;\n\tunsigned int loops;\n\tint retval = 0;\n\n\tudc = ep->udc;\n\tdirection = ep_dir(ep);\n\tdqh = &(udc->ep_dqh[ep->ep_num * 2 + direction]);\n\tbit_pos = 1 << (((direction == EP_DIR_OUT) ? 0 : 16) + ep->ep_num);\n\n\t \n\tif (!(list_empty(&ep->queue))) {\n\t\tstruct mv_req *lastreq;\n\t\tlastreq = list_entry(ep->queue.prev, struct mv_req, queue);\n\t\tlastreq->tail->dtd_next =\n\t\t\treq->head->td_dma & EP_QUEUE_HEAD_NEXT_POINTER_MASK;\n\n\t\twmb();\n\n\t\tif (readl(&udc->op_regs->epprime) & bit_pos)\n\t\t\tgoto done;\n\n\t\tloops = LOOPS(READSAFE_TIMEOUT);\n\t\twhile (1) {\n\t\t\t \n\t\t\tusbcmd = readl(&udc->op_regs->usbcmd);\n\t\t\tusbcmd |= USBCMD_ATDTW_TRIPWIRE_SET;\n\t\t\twritel(usbcmd, &udc->op_regs->usbcmd);\n\n\t\t\t \n\t\t\tepstatus = readl(&udc->op_regs->epstatus) & bit_pos;\n\n\t\t\t \n\t\t\tif (readl(&udc->op_regs->usbcmd)\n\t\t\t\t& USBCMD_ATDTW_TRIPWIRE_SET)\n\t\t\t\tbreak;\n\n\t\t\tloops--;\n\t\t\tif (loops == 0) {\n\t\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\t\"Timeout for ATDTW_TRIPWIRE...\\n\");\n\t\t\t\tretval = -ETIME;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tudelay(LOOPS_USEC);\n\t\t}\n\n\t\t \n\t\tusbcmd = readl(&udc->op_regs->usbcmd);\n\t\tusbcmd &= USBCMD_ATDTW_TRIPWIRE_CLEAR;\n\t\twritel(usbcmd, &udc->op_regs->usbcmd);\n\n\t\tif (epstatus)\n\t\t\tgoto done;\n\t}\n\n\t \n\tdqh->next_dtd_ptr = req->head->td_dma\n\t\t\t\t& EP_QUEUE_HEAD_NEXT_POINTER_MASK;\n\n\t \n\tdqh->size_ioc_int_sts &= ~(DTD_STATUS_ACTIVE | DTD_STATUS_HALTED);\n\n\t \n\twmb();\n\n\t \n\twritel(bit_pos, &udc->op_regs->epprime);\n\ndone:\n\treturn retval;\n}\n\nstatic struct mv_dtd *build_dtd(struct mv_req *req, unsigned *length,\n\t\tdma_addr_t *dma, int *is_last)\n{\n\tstruct mv_dtd *dtd;\n\tstruct mv_udc *udc;\n\tstruct mv_dqh *dqh;\n\tu32 temp, mult = 0;\n\n\t \n\tif (usb_endpoint_xfer_isoc(req->ep->ep.desc)) {\n\t\tdqh = req->ep->dqh;\n\t\tmult = (dqh->max_packet_length >> EP_QUEUE_HEAD_MULT_POS)\n\t\t\t\t& 0x3;\n\t\t*length = min(req->req.length - req->req.actual,\n\t\t\t\t(unsigned)(mult * req->ep->ep.maxpacket));\n\t} else\n\t\t*length = min(req->req.length - req->req.actual,\n\t\t\t\t(unsigned)EP_MAX_LENGTH_TRANSFER);\n\n\tudc = req->ep->udc;\n\n\t \n\tdtd = dma_pool_alloc(udc->dtd_pool, GFP_ATOMIC, dma);\n\tif (dtd == NULL)\n\t\treturn dtd;\n\n\tdtd->td_dma = *dma;\n\t \n\ttemp = (u32)(req->req.dma + req->req.actual);\n\tdtd->buff_ptr0 = cpu_to_le32(temp);\n\ttemp &= ~0xFFF;\n\tdtd->buff_ptr1 = cpu_to_le32(temp + 0x1000);\n\tdtd->buff_ptr2 = cpu_to_le32(temp + 0x2000);\n\tdtd->buff_ptr3 = cpu_to_le32(temp + 0x3000);\n\tdtd->buff_ptr4 = cpu_to_le32(temp + 0x4000);\n\n\treq->req.actual += *length;\n\n\t \n\tif (req->req.zero) {\n\t\tif (*length == 0 || (*length % req->ep->ep.maxpacket) != 0)\n\t\t\t*is_last = 1;\n\t\telse\n\t\t\t*is_last = 0;\n\t} else if (req->req.length == req->req.actual)\n\t\t*is_last = 1;\n\telse\n\t\t*is_last = 0;\n\n\t \n\ttemp = ((*length << DTD_LENGTH_BIT_POS) | DTD_STATUS_ACTIVE);\n\n\t \n\tif (*is_last && !req->req.no_interrupt)\n\t\ttemp |= DTD_IOC;\n\n\ttemp |= mult << 10;\n\n\tdtd->size_ioc_sts = temp;\n\n\tmb();\n\n\treturn dtd;\n}\n\n \nstatic int req_to_dtd(struct mv_req *req)\n{\n\tunsigned count;\n\tint is_last, is_first = 1;\n\tstruct mv_dtd *dtd, *last_dtd = NULL;\n\tdma_addr_t dma;\n\n\tdo {\n\t\tdtd = build_dtd(req, &count, &dma, &is_last);\n\t\tif (dtd == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tif (is_first) {\n\t\t\tis_first = 0;\n\t\t\treq->head = dtd;\n\t\t} else {\n\t\t\tlast_dtd->dtd_next = dma;\n\t\t\tlast_dtd->next_dtd_virt = dtd;\n\t\t}\n\t\tlast_dtd = dtd;\n\t\treq->dtd_count++;\n\t} while (!is_last);\n\n\t \n\tdtd->dtd_next = DTD_NEXT_TERMINATE;\n\n\treq->tail = dtd;\n\n\treturn 0;\n}\n\nstatic int mv_ep_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct mv_udc *udc;\n\tstruct mv_ep *ep;\n\tstruct mv_dqh *dqh;\n\tu16 max = 0;\n\tu32 bit_pos, epctrlx, direction;\n\tconst unsigned char zlt = 1;\n\tunsigned char ios, mult;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct mv_ep, ep);\n\tudc = ep->udc;\n\n\tif (!_ep || !desc\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tdirection = ep_dir(ep);\n\tmax = usb_endpoint_maxp(desc);\n\n\t \n\tbit_pos = 1 << ((direction == EP_DIR_OUT ? 0 : 16) + ep->ep_num);\n\n\t \n\tif ((readl(&udc->op_regs->epprime) & bit_pos)\n\t\t|| (readl(&udc->op_regs->epstatus) & bit_pos)) {\n\t\tdev_info(&udc->dev->dev,\n\t\t\t\"ep=%d %s: Init ERROR: ENDPTPRIME=0x%x,\"\n\t\t\t\" ENDPTSTATUS=0x%x, bit_pos=0x%x\\n\",\n\t\t\t(unsigned)ep->ep_num, direction ? \"SEND\" : \"RECV\",\n\t\t\t(unsigned)readl(&udc->op_regs->epprime),\n\t\t\t(unsigned)readl(&udc->op_regs->epstatus),\n\t\t\t(unsigned)bit_pos);\n\t\tgoto en_done;\n\t}\n\n\t \n\tios = 0;\n\tmult = 0;\n\tswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tios = 1;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tmult = usb_endpoint_maxp_mult(desc);\n\t\t \n\t\tif (mult > 3)\n\t\t\tgoto en_done;\n\t\tbreak;\n\tdefault:\n\t\tgoto en_done;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tdqh = ep->dqh;\n\tdqh->max_packet_length = (max << EP_QUEUE_HEAD_MAX_PKT_LEN_POS)\n\t\t| (mult << EP_QUEUE_HEAD_MULT_POS)\n\t\t| (zlt ? EP_QUEUE_HEAD_ZLT_SEL : 0)\n\t\t| (ios ? EP_QUEUE_HEAD_IOS : 0);\n\tdqh->next_dtd_ptr = 1;\n\tdqh->size_ioc_int_sts = 0;\n\n\tep->ep.maxpacket = max;\n\tep->ep.desc = desc;\n\tep->stopped = 0;\n\n\t \n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tif (direction == EP_DIR_IN) {\n\t\tepctrlx &= ~EPCTRL_TX_ALL_MASK;\n\t\tepctrlx |= EPCTRL_TX_ENABLE | EPCTRL_TX_DATA_TOGGLE_RST\n\t\t\t| ((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\n\t\t\t\t<< EPCTRL_TX_EP_TYPE_SHIFT);\n\t} else {\n\t\tepctrlx &= ~EPCTRL_RX_ALL_MASK;\n\t\tepctrlx |= EPCTRL_RX_ENABLE | EPCTRL_RX_DATA_TOGGLE_RST\n\t\t\t| ((desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\n\t\t\t\t<< EPCTRL_RX_EP_TYPE_SHIFT);\n\t}\n\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\n\t \n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tif ((epctrlx & EPCTRL_RX_ENABLE) == 0) {\n\t\tepctrlx |= (USB_ENDPOINT_XFER_BULK\n\t\t\t\t<< EPCTRL_RX_EP_TYPE_SHIFT);\n\t\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\t}\n\n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tif ((epctrlx & EPCTRL_TX_ENABLE) == 0) {\n\t\tepctrlx |= (USB_ENDPOINT_XFER_BULK\n\t\t\t\t<< EPCTRL_TX_EP_TYPE_SHIFT);\n\t\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\nen_done:\n\treturn -EINVAL;\n}\n\nstatic int  mv_ep_disable(struct usb_ep *_ep)\n{\n\tstruct mv_udc *udc;\n\tstruct mv_ep *ep;\n\tstruct mv_dqh *dqh;\n\tu32 epctrlx, direction;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct mv_ep, ep);\n\tif ((_ep == NULL) || !ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\n\t \n\tdqh = ep->dqh;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tdirection = ep_dir(ep);\n\n\t \n\tdqh->max_packet_length = 0;\n\n\t \n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tepctrlx &= ~((direction == EP_DIR_IN)\n\t\t\t? (EPCTRL_TX_ENABLE | EPCTRL_TX_TYPE)\n\t\t\t: (EPCTRL_RX_ENABLE | EPCTRL_RX_TYPE));\n\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\n\t \n\tnuke(ep, -ESHUTDOWN);\n\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_request *\nmv_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct mv_req *req;\n\n\treq = kzalloc(sizeof *req, gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->req.dma = DMA_ADDR_INVALID;\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void mv_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct mv_req *req = NULL;\n\n\treq = container_of(_req, struct mv_req, req);\n\n\tif (_req)\n\t\tkfree(req);\n}\n\nstatic void mv_ep_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct mv_udc *udc;\n\tu32 bit_pos, direction;\n\tstruct mv_ep *ep;\n\tunsigned int loops;\n\n\tif (!_ep)\n\t\treturn;\n\n\tep = container_of(_ep, struct mv_ep, ep);\n\tif (!ep->ep.desc)\n\t\treturn;\n\n\tudc = ep->udc;\n\tdirection = ep_dir(ep);\n\n\tif (ep->ep_num == 0)\n\t\tbit_pos = (1 << 16) | 1;\n\telse if (direction == EP_DIR_OUT)\n\t\tbit_pos = 1 << ep->ep_num;\n\telse\n\t\tbit_pos = 1 << (16 + ep->ep_num);\n\n\tloops = LOOPS(EPSTATUS_TIMEOUT);\n\tdo {\n\t\tunsigned int inter_loops;\n\n\t\tif (loops == 0) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"TIMEOUT for ENDPTSTATUS=0x%x, bit_pos=0x%x\\n\",\n\t\t\t\t(unsigned)readl(&udc->op_regs->epstatus),\n\t\t\t\t(unsigned)bit_pos);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\twritel(bit_pos, &udc->op_regs->epflush);\n\n\t\t \n\t\tinter_loops = LOOPS(FLUSH_TIMEOUT);\n\t\twhile (readl(&udc->op_regs->epflush)) {\n\t\t\t \n\t\t\tif (inter_loops == 0) {\n\t\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\t\"TIMEOUT for ENDPTFLUSH=0x%x,\"\n\t\t\t\t\t\"bit_pos=0x%x\\n\",\n\t\t\t\t\t(unsigned)readl(&udc->op_regs->epflush),\n\t\t\t\t\t(unsigned)bit_pos);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tinter_loops--;\n\t\t\tudelay(LOOPS_USEC);\n\t\t}\n\t\tloops--;\n\t} while (readl(&udc->op_regs->epstatus) & bit_pos);\n}\n\n \nstatic int\nmv_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\n{\n\tstruct mv_ep *ep = container_of(_ep, struct mv_ep, ep);\n\tstruct mv_req *req = container_of(_req, struct mv_req, req);\n\tstruct mv_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint retval;\n\n\t \n\tif (!_req || !req->req.complete || !req->req.buf\n\t\t\t|| !list_empty(&req->queue)) {\n\t\tdev_err(&udc->dev->dev, \"%s, bad params\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tif (unlikely(!_ep || !ep->ep.desc)) {\n\t\tdev_err(&udc->dev->dev, \"%s, bad ep\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tudc = ep->udc;\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\treq->ep = ep;\n\n\t \n\tretval = usb_gadget_map_request(&udc->gadget, _req, ep_dir(ep));\n\tif (retval)\n\t\treturn retval;\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->dtd_count = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tif (!req_to_dtd(req)) {\n\t\tretval = queue_dtd(ep, req);\n\t\tif (retval) {\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\tdev_err(&udc->dev->dev, \"Failed to queue dtd\\n\");\n\t\t\tgoto err_unmap_dma;\n\t\t}\n\t} else {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\tdev_err(&udc->dev->dev, \"Failed to dma_pool_alloc\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_unmap_dma;\n\t}\n\n\t \n\tif (ep->ep_num == 0)\n\t\tudc->ep0_state = DATA_STATE_XMIT;\n\n\t \n\tlist_add_tail(&req->queue, &ep->queue);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n\nerr_unmap_dma:\n\tusb_gadget_unmap_request(&udc->gadget, _req, ep_dir(ep));\n\n\treturn retval;\n}\n\nstatic void mv_prime_ep(struct mv_ep *ep, struct mv_req *req)\n{\n\tstruct mv_dqh *dqh = ep->dqh;\n\tu32 bit_pos;\n\n\t \n\tdqh->next_dtd_ptr = req->head->td_dma\n\t\t& EP_QUEUE_HEAD_NEXT_POINTER_MASK;\n\n\t \n\tdqh->size_ioc_int_sts &= ~(DTD_STATUS_ACTIVE | DTD_STATUS_HALTED);\n\n\t \n\twmb();\n\n\tbit_pos = 1 << (((ep_dir(ep) == EP_DIR_OUT) ? 0 : 16) + ep->ep_num);\n\n\t \n\twritel(bit_pos, &ep->udc->op_regs->epprime);\n}\n\n \nstatic int mv_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct mv_ep *ep = container_of(_ep, struct mv_ep, ep);\n\tstruct mv_req *req = NULL, *iter;\n\tstruct mv_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint stopped, ret = 0;\n\tu32 epctrlx;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tstopped = ep->stopped;\n\n\t \n\tep->stopped = 1;\n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tif (ep_dir(ep) == EP_DIR_IN)\n\t\tepctrlx &= ~EPCTRL_TX_ENABLE;\n\telse\n\t\tepctrlx &= ~EPCTRL_RX_ENABLE;\n\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\t_req->status = -ECONNRESET;\n\t\tmv_ep_fifo_flush(_ep);\t \n\n\t\t \n\t\tif (req->queue.next != &ep->queue) {\n\t\t\tstruct mv_req *next_req;\n\n\t\t\tnext_req = list_entry(req->queue.next,\n\t\t\t\tstruct mv_req, queue);\n\n\t\t\t \n\t\t\tmv_prime_ep(ep, next_req);\n\t\t} else {\n\t\t\tstruct mv_dqh *qh;\n\n\t\t\tqh = ep->dqh;\n\t\t\tqh->next_dtd_ptr = 1;\n\t\t\tqh->size_ioc_int_sts = 0;\n\t\t}\n\n\t\t \n\t} else {\n\t\tstruct mv_req *prev_req;\n\n\t\tprev_req = list_entry(req->queue.prev, struct mv_req, queue);\n\t\twritel(readl(&req->tail->dtd_next),\n\t\t\t\t&prev_req->tail->dtd_next);\n\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\n\t \nout:\n\tepctrlx = readl(&udc->op_regs->epctrlx[ep->ep_num]);\n\tif (ep_dir(ep) == EP_DIR_IN)\n\t\tepctrlx |= EPCTRL_TX_ENABLE;\n\telse\n\t\tepctrlx |= EPCTRL_RX_ENABLE;\n\twritel(epctrlx, &udc->op_regs->epctrlx[ep->ep_num]);\n\tep->stopped = stopped;\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn ret;\n}\n\nstatic void ep_set_stall(struct mv_udc *udc, u8 ep_num, u8 direction, int stall)\n{\n\tu32 epctrlx;\n\n\tepctrlx = readl(&udc->op_regs->epctrlx[ep_num]);\n\n\tif (stall) {\n\t\tif (direction == EP_DIR_IN)\n\t\t\tepctrlx |= EPCTRL_TX_EP_STALL;\n\t\telse\n\t\t\tepctrlx |= EPCTRL_RX_EP_STALL;\n\t} else {\n\t\tif (direction == EP_DIR_IN) {\n\t\t\tepctrlx &= ~EPCTRL_TX_EP_STALL;\n\t\t\tepctrlx |= EPCTRL_TX_DATA_TOGGLE_RST;\n\t\t} else {\n\t\t\tepctrlx &= ~EPCTRL_RX_EP_STALL;\n\t\t\tepctrlx |= EPCTRL_RX_DATA_TOGGLE_RST;\n\t\t}\n\t}\n\twritel(epctrlx, &udc->op_regs->epctrlx[ep_num]);\n}\n\nstatic int ep_is_stall(struct mv_udc *udc, u8 ep_num, u8 direction)\n{\n\tu32 epctrlx;\n\n\tepctrlx = readl(&udc->op_regs->epctrlx[ep_num]);\n\n\tif (direction == EP_DIR_OUT)\n\t\treturn (epctrlx & EPCTRL_RX_EP_STALL) ? 1 : 0;\n\telse\n\t\treturn (epctrlx & EPCTRL_TX_EP_STALL) ? 1 : 0;\n}\n\nstatic int mv_ep_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\n{\n\tstruct mv_ep *ep;\n\tunsigned long flags;\n\tint status = 0;\n\tstruct mv_udc *udc;\n\n\tep = container_of(_ep, struct mv_ep, ep);\n\tudc = ep->udc;\n\tif (!_ep || !ep->ep.desc) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC) {\n\t\tstatus = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tif (halt && (ep_dir(ep) == EP_DIR_IN) && !list_empty(&ep->queue)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tep_set_stall(udc, ep->ep_num, ep_dir(ep), halt);\n\tif (halt && wedge)\n\t\tep->wedge = 1;\n\telse if (!halt)\n\t\tep->wedge = 0;\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\tif (ep->ep_num == 0) {\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tudc->ep0_dir = EP_DIR_OUT;\n\t}\nout:\n\treturn status;\n}\n\nstatic int mv_ep_set_halt(struct usb_ep *_ep, int halt)\n{\n\treturn mv_ep_set_halt_wedge(_ep, halt, 0);\n}\n\nstatic int mv_ep_set_wedge(struct usb_ep *_ep)\n{\n\treturn mv_ep_set_halt_wedge(_ep, 1, 1);\n}\n\nstatic const struct usb_ep_ops mv_ep_ops = {\n\t.enable\t\t= mv_ep_enable,\n\t.disable\t= mv_ep_disable,\n\n\t.alloc_request\t= mv_alloc_request,\n\t.free_request\t= mv_free_request,\n\n\t.queue\t\t= mv_ep_queue,\n\t.dequeue\t= mv_ep_dequeue,\n\n\t.set_wedge\t= mv_ep_set_wedge,\n\t.set_halt\t= mv_ep_set_halt,\n\t.fifo_flush\t= mv_ep_fifo_flush,\t \n};\n\nstatic int udc_clock_enable(struct mv_udc *udc)\n{\n\treturn clk_prepare_enable(udc->clk);\n}\n\nstatic void udc_clock_disable(struct mv_udc *udc)\n{\n\tclk_disable_unprepare(udc->clk);\n}\n\nstatic void udc_stop(struct mv_udc *udc)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(&udc->op_regs->usbintr);\n\ttmp &= ~(USBINTR_INT_EN | USBINTR_ERR_INT_EN |\n\t\tUSBINTR_PORT_CHANGE_DETECT_EN | USBINTR_RESET_EN);\n\twritel(tmp, &udc->op_regs->usbintr);\n\n\tudc->stopped = 1;\n\n\t \n\ttmp = readl(&udc->op_regs->usbcmd);\n\ttmp &= ~USBCMD_RUN_STOP;\n\twritel(tmp, &udc->op_regs->usbcmd);\n}\n\nstatic void udc_start(struct mv_udc *udc)\n{\n\tu32 usbintr;\n\n\tusbintr = USBINTR_INT_EN | USBINTR_ERR_INT_EN\n\t\t| USBINTR_PORT_CHANGE_DETECT_EN\n\t\t| USBINTR_RESET_EN | USBINTR_DEVICE_SUSPEND;\n\t \n\twritel(usbintr, &udc->op_regs->usbintr);\n\n\tudc->stopped = 0;\n\n\t \n\twritel(USBCMD_RUN_STOP, &udc->op_regs->usbcmd);\n}\n\nstatic int udc_reset(struct mv_udc *udc)\n{\n\tunsigned int loops;\n\tu32 tmp, portsc;\n\n\t \n\ttmp = readl(&udc->op_regs->usbcmd);\n\ttmp &= ~USBCMD_RUN_STOP;\n\twritel(tmp, &udc->op_regs->usbcmd);\n\n\t \n\twritel(USBCMD_CTRL_RESET, &udc->op_regs->usbcmd);\n\n\t \n\tloops = LOOPS(RESET_TIMEOUT);\n\twhile (readl(&udc->op_regs->usbcmd) & USBCMD_CTRL_RESET) {\n\t\tif (loops == 0) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"Wait for RESET completed TIMEOUT\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tloops--;\n\t\tudelay(LOOPS_USEC);\n\t}\n\n\t \n\ttmp = readl(&udc->op_regs->usbmode);\n\ttmp |= USBMODE_CTRL_MODE_DEVICE;\n\n\t \n\ttmp |= USBMODE_SETUP_LOCK_OFF;\n\n\twritel(tmp, &udc->op_regs->usbmode);\n\n\twritel(0x0, &udc->op_regs->epsetupstat);\n\n\t \n\twritel(udc->ep_dqh_dma & USB_EP_LIST_ADDRESS_MASK,\n\t\t&udc->op_regs->eplistaddr);\n\n\tportsc = readl(&udc->op_regs->portsc[0]);\n\tif (readl(&udc->cap_regs->hcsparams) & HCSPARAMS_PPC)\n\t\tportsc &= (~PORTSCX_W1C_BITS | ~PORTSCX_PORT_POWER);\n\n\tif (udc->force_fs)\n\t\tportsc |= PORTSCX_FORCE_FULL_SPEED_CONNECT;\n\telse\n\t\tportsc &= (~PORTSCX_FORCE_FULL_SPEED_CONNECT);\n\n\twritel(portsc, &udc->op_regs->portsc[0]);\n\n\ttmp = readl(&udc->op_regs->epctrlx[0]);\n\ttmp &= ~(EPCTRL_TX_EP_STALL | EPCTRL_RX_EP_STALL);\n\twritel(tmp, &udc->op_regs->epctrlx[0]);\n\n\treturn 0;\n}\n\nstatic int mv_udc_enable_internal(struct mv_udc *udc)\n{\n\tint retval;\n\n\tif (udc->active)\n\t\treturn 0;\n\n\tdev_dbg(&udc->dev->dev, \"enable udc\\n\");\n\tretval = udc_clock_enable(udc);\n\tif (retval)\n\t\treturn retval;\n\n\tif (udc->pdata->phy_init) {\n\t\tretval = udc->pdata->phy_init(udc->phy_regs);\n\t\tif (retval) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"init phy error %d\\n\", retval);\n\t\t\tudc_clock_disable(udc);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tudc->active = 1;\n\n\treturn 0;\n}\n\nstatic int mv_udc_enable(struct mv_udc *udc)\n{\n\tif (udc->clock_gating)\n\t\treturn mv_udc_enable_internal(udc);\n\n\treturn 0;\n}\n\nstatic void mv_udc_disable_internal(struct mv_udc *udc)\n{\n\tif (udc->active) {\n\t\tdev_dbg(&udc->dev->dev, \"disable udc\\n\");\n\t\tif (udc->pdata->phy_deinit)\n\t\t\tudc->pdata->phy_deinit(udc->phy_regs);\n\t\tudc_clock_disable(udc);\n\t\tudc->active = 0;\n\t}\n}\n\nstatic void mv_udc_disable(struct mv_udc *udc)\n{\n\tif (udc->clock_gating)\n\t\tmv_udc_disable_internal(udc);\n}\n\nstatic int mv_udc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct mv_udc *udc;\n\tu16\tretval;\n\n\tif (!gadget)\n\t\treturn -ENODEV;\n\n\tudc = container_of(gadget, struct mv_udc, gadget);\n\n\tretval = readl(&udc->op_regs->frindex) & USB_FRINDEX_MASKS;\n\n\treturn retval;\n}\n\n \nstatic int mv_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct mv_udc *udc = container_of(gadget, struct mv_udc, gadget);\n\tu32 portsc;\n\n\t \n\tif (!udc->remote_wakeup)\n\t\treturn -ENOTSUPP;\n\n\tportsc = readl(&udc->op_regs->portsc);\n\t \n\tif (!(portsc & PORTSCX_PORT_SUSPEND))\n\t\treturn 0;\n\t \n\tportsc |= PORTSCX_PORT_FORCE_RESUME;\n\twritel(portsc, &udc->op_regs->portsc[0]);\n\treturn 0;\n}\n\nstatic int mv_udc_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct mv_udc *udc;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tudc = container_of(gadget, struct mv_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->vbus_active = (is_active != 0);\n\n\tdev_dbg(&udc->dev->dev, \"%s: softconnect %d, vbus_active %d\\n\",\n\t\t__func__, udc->softconnect, udc->vbus_active);\n\n\tif (udc->driver && udc->softconnect && udc->vbus_active) {\n\t\tretval = mv_udc_enable(udc);\n\t\tif (retval == 0) {\n\t\t\t \n\t\t\tudc_reset(udc);\n\t\t\tep0_reset(udc);\n\t\t\tudc_start(udc);\n\t\t}\n\t} else if (udc->driver && udc->softconnect) {\n\t\tif (!udc->active)\n\t\t\tgoto out;\n\n\t\t \n\t\tstop_activity(udc, udc->driver);\n\t\tudc_stop(udc);\n\t\tmv_udc_disable(udc);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn retval;\n}\n\nstatic int mv_udc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct mv_udc *udc;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tudc = container_of(gadget, struct mv_udc, gadget);\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->softconnect = (is_on != 0);\n\n\tdev_dbg(&udc->dev->dev, \"%s: softconnect %d, vbus_active %d\\n\",\n\t\t\t__func__, udc->softconnect, udc->vbus_active);\n\n\tif (udc->driver && udc->softconnect && udc->vbus_active) {\n\t\tretval = mv_udc_enable(udc);\n\t\tif (retval == 0) {\n\t\t\t \n\t\t\tudc_reset(udc);\n\t\t\tep0_reset(udc);\n\t\t\tudc_start(udc);\n\t\t}\n\t} else if (udc->driver && udc->vbus_active) {\n\t\t \n\t\tstop_activity(udc, udc->driver);\n\t\tudc_stop(udc);\n\t\tmv_udc_disable(udc);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn retval;\n}\n\nstatic int mv_udc_start(struct usb_gadget *, struct usb_gadget_driver *);\nstatic int mv_udc_stop(struct usb_gadget *);\n \nstatic const struct usb_gadget_ops mv_ops = {\n\n\t \n\t.get_frame\t= mv_udc_get_frame,\n\n\t \n\t.wakeup\t\t= mv_udc_wakeup,\n\n\t \n\t.vbus_session\t= mv_udc_vbus_session,\n\n\t \n\t.pullup\t\t= mv_udc_pullup,\n\t.udc_start\t= mv_udc_start,\n\t.udc_stop\t= mv_udc_stop,\n};\n\nstatic int eps_init(struct mv_udc *udc)\n{\n\tstruct mv_ep\t*ep;\n\tchar name[14];\n\tint i;\n\n\t \n\tep = &udc->eps[0];\n\tep->udc = udc;\n\tstrncpy(ep->name, \"ep0\", sizeof(ep->name));\n\tep->ep.name = ep->name;\n\tep->ep.ops = &mv_ep_ops;\n\tep->wedge = 0;\n\tep->stopped = 0;\n\tusb_ep_set_maxpacket_limit(&ep->ep, EP0_MAX_PKT_SIZE);\n\tep->ep.caps.type_control = true;\n\tep->ep.caps.dir_in = true;\n\tep->ep.caps.dir_out = true;\n\tep->ep_num = 0;\n\tep->ep.desc = &mv_ep0_desc;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tep->ep_type = USB_ENDPOINT_XFER_CONTROL;\n\n\t \n\tfor (i = 2; i < udc->max_eps * 2; i++) {\n\t\tep = &udc->eps[i];\n\t\tif (i % 2) {\n\t\t\tsnprintf(name, sizeof(name), \"ep%din\", i / 2);\n\t\t\tep->direction = EP_DIR_IN;\n\t\t\tep->ep.caps.dir_in = true;\n\t\t} else {\n\t\t\tsnprintf(name, sizeof(name), \"ep%dout\", i / 2);\n\t\t\tep->direction = EP_DIR_OUT;\n\t\t\tep->ep.caps.dir_out = true;\n\t\t}\n\t\tep->udc = udc;\n\t\tstrncpy(ep->name, name, sizeof(ep->name));\n\t\tep->ep.name = ep->name;\n\n\t\tep->ep.caps.type_iso = true;\n\t\tep->ep.caps.type_bulk = true;\n\t\tep->ep.caps.type_int = true;\n\n\t\tep->ep.ops = &mv_ep_ops;\n\t\tep->stopped = 0;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\n\t\tep->ep_num = i / 2;\n\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\n\t\tep->dqh = &udc->ep_dqh[i];\n\t}\n\n\treturn 0;\n}\n\n \nstatic void nuke(struct mv_ep *ep, int status)\n{\n\t \n\tep->stopped = 1;\n\n\t \n\tmv_ep_fifo_flush(&ep->ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct mv_req *req = NULL;\n\t\treq = list_entry(ep->queue.next, struct mv_req, queue);\n\t\tdone(ep, req, status);\n\t}\n}\n\nstatic void gadget_reset(struct mv_udc *udc, struct usb_gadget_driver *driver)\n{\n\tstruct mv_ep\t*ep;\n\n\tnuke(&udc->eps[0], -ESHUTDOWN);\n\n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\n\t \n\tif (driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tusb_gadget_udc_reset(&udc->gadget, driver);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n \nstatic void stop_activity(struct mv_udc *udc, struct usb_gadget_driver *driver)\n{\n\tstruct mv_ep\t*ep;\n\n\tnuke(&udc->eps[0], -ESHUTDOWN);\n\n\tlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\n\t\tnuke(ep, -ESHUTDOWN);\n\t}\n\n\t \n\tif (driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tdriver->disconnect(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\nstatic int mv_udc_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct mv_udc *udc;\n\tint retval = 0;\n\tunsigned long flags;\n\n\tudc = container_of(gadget, struct mv_udc, gadget);\n\n\tif (udc->driver)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tudc->driver = driver;\n\n\tudc->usb_state = USB_STATE_ATTACHED;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = EP_DIR_OUT;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->transceiver) {\n\t\tretval = otg_set_peripheral(udc->transceiver->otg,\n\t\t\t\t\t&udc->gadget);\n\t\tif (retval) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"unable to register peripheral to otg\\n\");\n\t\t\tudc->driver = NULL;\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\t \n\tif (udc->qwork)\n\t\tqueue_work(udc->qwork, &udc->vbus_work);\n\n\treturn 0;\n}\n\nstatic int mv_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct mv_udc *udc;\n\tunsigned long flags;\n\n\tudc = container_of(gadget, struct mv_udc, gadget);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tmv_udc_enable(udc);\n\tudc_stop(udc);\n\n\t \n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tstop_activity(udc, NULL);\n\tmv_udc_disable(udc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\t \n\tudc->driver = NULL;\n\n\treturn 0;\n}\n\nstatic void mv_set_ptc(struct mv_udc *udc, u32 mode)\n{\n\tu32 portsc;\n\n\tportsc = readl(&udc->op_regs->portsc[0]);\n\tportsc |= mode << 16;\n\twritel(portsc, &udc->op_regs->portsc[0]);\n}\n\nstatic void prime_status_complete(struct usb_ep *ep, struct usb_request *_req)\n{\n\tstruct mv_ep *mvep = container_of(ep, struct mv_ep, ep);\n\tstruct mv_req *req = container_of(_req, struct mv_req, req);\n\tstruct mv_udc *udc;\n\tunsigned long flags;\n\n\tudc = mvep->udc;\n\n\tdev_info(&udc->dev->dev, \"switch to test mode %d\\n\", req->test_mode);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (req->test_mode) {\n\t\tmv_set_ptc(udc, req->test_mode);\n\t\treq->test_mode = 0;\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic int\nudc_prime_status(struct mv_udc *udc, u8 direction, u16 status, bool empty)\n{\n\tint retval = 0;\n\tstruct mv_req *req;\n\tstruct mv_ep *ep;\n\n\tep = &udc->eps[0];\n\tudc->ep0_dir = direction;\n\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\n\treq = udc->status_req;\n\n\t \n\tif (empty == false) {\n\t\t*((u16 *) req->req.buf) = cpu_to_le16(status);\n\t\treq->req.length = 2;\n\t} else\n\t\treq->req.length = 0;\n\n\treq->ep = ep;\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\tif (udc->test_mode) {\n\t\treq->req.complete = prime_status_complete;\n\t\treq->test_mode = udc->test_mode;\n\t\tudc->test_mode = 0;\n\t} else\n\t\treq->req.complete = NULL;\n\treq->dtd_count = 0;\n\n\tif (req->req.dma == DMA_ADDR_INVALID) {\n\t\treq->req.dma = dma_map_single(ep->udc->gadget.dev.parent,\n\t\t\t\treq->req.buf, req->req.length,\n\t\t\t\tep_dir(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\treq->mapped = 1;\n\t}\n\n\t \n\tif (!req_to_dtd(req)) {\n\t\tretval = queue_dtd(ep, req);\n\t\tif (retval) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"Failed to queue dtd when prime status\\n\");\n\t\t\tgoto out;\n\t\t}\n\t} else{\t \n\t\tretval = -ENOMEM;\n\t\tdev_err(&udc->dev->dev,\n\t\t\t\"Failed to dma_pool_alloc when prime status\\n\");\n\t\tgoto out;\n\t}\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treturn 0;\nout:\n\tusb_gadget_unmap_request(&udc->gadget, &req->req, ep_dir(ep));\n\n\treturn retval;\n}\n\nstatic void mv_udc_testmode(struct mv_udc *udc, u16 index)\n{\n\tif (index <= USB_TEST_FORCE_ENABLE) {\n\t\tudc->test_mode = index;\n\t\tif (udc_prime_status(udc, EP_DIR_IN, 0, true))\n\t\t\tep0_stall(udc);\n\t} else\n\t\tdev_err(&udc->dev->dev,\n\t\t\t\"This test mode(%d) is not supported\\n\", index);\n}\n\nstatic void ch9setaddress(struct mv_udc *udc, struct usb_ctrlrequest *setup)\n{\n\tudc->dev_addr = (u8)setup->wValue;\n\n\t \n\tudc->usb_state = USB_STATE_ADDRESS;\n\n\tif (udc_prime_status(udc, EP_DIR_IN, 0, true))\n\t\tep0_stall(udc);\n}\n\nstatic void ch9getstatus(struct mv_udc *udc, u8 ep_num,\n\tstruct usb_ctrlrequest *setup)\n{\n\tu16 status = 0;\n\tint retval;\n\n\tif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\n\t\t!= (USB_DIR_IN | USB_TYPE_STANDARD))\n\t\treturn;\n\n\tif ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tstatus |= udc->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\t} else if ((setup->bRequestType & USB_RECIP_MASK)\n\t\t\t== USB_RECIP_INTERFACE) {\n\t\t \n\t\tstatus = 0;\n\t} else if ((setup->bRequestType & USB_RECIP_MASK)\n\t\t\t== USB_RECIP_ENDPOINT) {\n\t\tu8 ep_num, direction;\n\n\t\tep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tdirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\n\t\t\t\t? EP_DIR_IN : EP_DIR_OUT;\n\t\tstatus = ep_is_stall(udc, ep_num, direction)\n\t\t\t\t<< USB_ENDPOINT_HALT;\n\t}\n\n\tretval = udc_prime_status(udc, EP_DIR_IN, status, false);\n\tif (retval)\n\t\tep0_stall(udc);\n\telse\n\t\tudc->ep0_state = DATA_STATE_XMIT;\n}\n\nstatic void ch9clearfeature(struct mv_udc *udc, struct usb_ctrlrequest *setup)\n{\n\tu8 ep_num;\n\tu8 direction;\n\tstruct mv_ep *ep;\n\n\tif ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\n\t\t== ((USB_TYPE_STANDARD | USB_RECIP_DEVICE))) {\n\t\tswitch (setup->wValue) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tudc->remote_wakeup = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else if ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\n\t\t== ((USB_TYPE_STANDARD | USB_RECIP_ENDPOINT))) {\n\t\tswitch (setup->wValue) {\n\t\tcase USB_ENDPOINT_HALT:\n\t\t\tep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tdirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\n\t\t\t\t? EP_DIR_IN : EP_DIR_OUT;\n\t\t\tif (setup->wValue != 0 || setup->wLength != 0\n\t\t\t\t|| ep_num > udc->max_eps)\n\t\t\t\tgoto out;\n\t\t\tep = &udc->eps[ep_num * 2 + direction];\n\t\t\tif (ep->wedge == 1)\n\t\t\t\tbreak;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tep_set_stall(udc, ep_num, direction, 0);\n\t\t\tspin_lock(&udc->lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tgoto out;\n\n\tif (udc_prime_status(udc, EP_DIR_IN, 0, true))\n\t\tep0_stall(udc);\nout:\n\treturn;\n}\n\nstatic void ch9setfeature(struct mv_udc *udc, struct usb_ctrlrequest *setup)\n{\n\tu8 ep_num;\n\tu8 direction;\n\n\tif ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\n\t\t== ((USB_TYPE_STANDARD | USB_RECIP_DEVICE))) {\n\t\tswitch (setup->wValue) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tudc->remote_wakeup = 1;\n\t\t\tbreak;\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\tif (setup->wIndex & 0xFF\n\t\t\t\t||  udc->gadget.speed != USB_SPEED_HIGH)\n\t\t\t\tep0_stall(udc);\n\n\t\t\tif (udc->usb_state != USB_STATE_CONFIGURED\n\t\t\t\t&& udc->usb_state != USB_STATE_ADDRESS\n\t\t\t\t&& udc->usb_state != USB_STATE_DEFAULT)\n\t\t\t\tep0_stall(udc);\n\n\t\t\tmv_udc_testmode(udc, (setup->wIndex >> 8));\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else if ((setup->bRequestType & (USB_TYPE_MASK | USB_RECIP_MASK))\n\t\t== ((USB_TYPE_STANDARD | USB_RECIP_ENDPOINT))) {\n\t\tswitch (setup->wValue) {\n\t\tcase USB_ENDPOINT_HALT:\n\t\t\tep_num = setup->wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tdirection = (setup->wIndex & USB_ENDPOINT_DIR_MASK)\n\t\t\t\t? EP_DIR_IN : EP_DIR_OUT;\n\t\t\tif (setup->wValue != 0 || setup->wLength != 0\n\t\t\t\t|| ep_num > udc->max_eps)\n\t\t\t\tgoto out;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tep_set_stall(udc, ep_num, direction, 1);\n\t\t\tspin_lock(&udc->lock);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\tgoto out;\n\n\tif (udc_prime_status(udc, EP_DIR_IN, 0, true))\n\t\tep0_stall(udc);\nout:\n\treturn;\n}\n\nstatic void handle_setup_packet(struct mv_udc *udc, u8 ep_num,\n\tstruct usb_ctrlrequest *setup)\n\t__releases(&ep->udc->lock)\n\t__acquires(&ep->udc->lock)\n{\n\tbool delegate = false;\n\n\tnuke(&udc->eps[ep_num * 2 + EP_DIR_OUT], -ESHUTDOWN);\n\n\tdev_dbg(&udc->dev->dev, \"SETUP %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t\tsetup->bRequestType, setup->bRequest,\n\t\t\tsetup->wValue, setup->wIndex, setup->wLength);\n\t \n\tif ((setup->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (setup->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tch9getstatus(udc, ep_num, setup);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tch9setaddress(udc, setup);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tch9clearfeature(udc, setup);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tch9setfeature(udc, setup);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdelegate = true;\n\t\t}\n\t} else\n\t\tdelegate = true;\n\n\t \n\tif (delegate == true) {\n\t\t \n\t\tif (setup->wLength) {\n\t\t\t \n\t\t\tudc->ep0_dir = (setup->bRequestType & USB_DIR_IN)\n\t\t\t\t\t?  EP_DIR_IN : EP_DIR_OUT;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\t\tep0_stall(udc);\n\t\t\tspin_lock(&udc->lock);\n\t\t\tudc->ep0_state = (setup->bRequestType & USB_DIR_IN)\n\t\t\t\t\t?  DATA_STATE_XMIT : DATA_STATE_RECV;\n\t\t} else {\n\t\t\t \n\t\t\tudc->ep0_dir = EP_DIR_IN;\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\t\tep0_stall(udc);\n\t\t\tspin_lock(&udc->lock);\n\t\t\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\t\t}\n\t}\n}\n\n \nstatic void ep0_req_complete(struct mv_udc *udc,\n\tstruct mv_ep *ep0, struct mv_req *req)\n{\n\tu32 new_addr;\n\n\tif (udc->usb_state == USB_STATE_ADDRESS) {\n\t\t \n\t\tnew_addr = (u32)udc->dev_addr;\n\t\twritel(new_addr << USB_DEVICE_ADDRESS_BIT_SHIFT,\n\t\t\t&udc->op_regs->deviceaddr);\n\t}\n\n\tdone(ep0, req, 0);\n\n\tswitch (udc->ep0_state) {\n\tcase DATA_STATE_XMIT:\n\t\t \n\t\tif (udc_prime_status(udc, EP_DIR_OUT, 0, true))\n\t\t\tep0_stall(udc);\n\t\tbreak;\n\tcase DATA_STATE_RECV:\n\t\t \n\t\tif (udc_prime_status(udc, EP_DIR_IN, 0 , true))\n\t\t\tep0_stall(udc);\n\t\tbreak;\n\tcase WAIT_FOR_OUT_STATUS:\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tbreak;\n\tcase WAIT_FOR_SETUP:\n\t\tdev_err(&udc->dev->dev, \"unexpect ep0 packets\\n\");\n\t\tbreak;\n\tdefault:\n\t\tep0_stall(udc);\n\t\tbreak;\n\t}\n}\n\nstatic void get_setup_data(struct mv_udc *udc, u8 ep_num, u8 *buffer_ptr)\n{\n\tu32 temp;\n\tstruct mv_dqh *dqh;\n\n\tdqh = &udc->ep_dqh[ep_num * 2 + EP_DIR_OUT];\n\n\t \n\twritel((1 << ep_num), &udc->op_regs->epsetupstat);\n\n\t \n\tdo {\n\t\t \n\t\ttemp = readl(&udc->op_regs->usbcmd);\n\t\twritel(temp | USBCMD_SETUP_TRIPWIRE_SET, &udc->op_regs->usbcmd);\n\n\t\t \n\t\tmemcpy(buffer_ptr, (u8 *) dqh->setup_buffer, 8);\n\t} while (!(readl(&udc->op_regs->usbcmd) & USBCMD_SETUP_TRIPWIRE_SET));\n\n\t \n\ttemp = readl(&udc->op_regs->usbcmd);\n\twritel(temp & ~USBCMD_SETUP_TRIPWIRE_SET, &udc->op_regs->usbcmd);\n}\n\nstatic void irq_process_tr_complete(struct mv_udc *udc)\n{\n\tu32 tmp, bit_pos;\n\tint i, ep_num = 0, direction = 0;\n\tstruct mv_ep\t*curr_ep;\n\tstruct mv_req *curr_req, *temp_req;\n\tint status;\n\n\t \n\n\t \n\ttmp = readl(&udc->op_regs->epsetupstat);\n\n\tif (tmp) {\n\t\tfor (i = 0; i < udc->max_eps; i++) {\n\t\t\tif (tmp & (1 << i)) {\n\t\t\t\tget_setup_data(udc, i,\n\t\t\t\t\t(u8 *)(&udc->local_setup_buff));\n\t\t\t\thandle_setup_packet(udc, i,\n\t\t\t\t\t&udc->local_setup_buff);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\t \n\ttmp = readl(&udc->op_regs->epcomplete);\n\n\tif (!tmp)\n\t\treturn;\n\n\twritel(tmp, &udc->op_regs->epcomplete);\n\n\tfor (i = 0; i < udc->max_eps * 2; i++) {\n\t\tep_num = i >> 1;\n\t\tdirection = i % 2;\n\n\t\tbit_pos = 1 << (ep_num + 16 * direction);\n\n\t\tif (!(bit_pos & tmp))\n\t\t\tcontinue;\n\n\t\tif (i == 1)\n\t\t\tcurr_ep = &udc->eps[0];\n\t\telse\n\t\t\tcurr_ep = &udc->eps[i];\n\t\t \n\t\tlist_for_each_entry_safe(curr_req, temp_req,\n\t\t\t&curr_ep->queue, queue) {\n\t\t\tstatus = process_ep_req(udc, i, curr_req);\n\t\t\tif (status)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcurr_req->req.status = status;\n\n\t\t\t \n\t\t\tif (ep_num == 0) {\n\t\t\t\tep0_req_complete(udc, curr_ep, curr_req);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tdone(curr_ep, curr_req, status);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void irq_process_reset(struct mv_udc *udc)\n{\n\tu32 tmp;\n\tunsigned int loops;\n\n\tudc->ep0_dir = EP_DIR_OUT;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->remote_wakeup = 0;\t\t \n\n\t \n\ttmp = readl(&udc->op_regs->deviceaddr);\n\ttmp &= ~(USB_DEVICE_ADDRESS_MASK);\n\twritel(tmp, &udc->op_regs->deviceaddr);\n\n\t \n\ttmp = readl(&udc->op_regs->epsetupstat);\n\twritel(tmp, &udc->op_regs->epsetupstat);\n\n\t \n\ttmp = readl(&udc->op_regs->epcomplete);\n\twritel(tmp, &udc->op_regs->epcomplete);\n\n\t \n\tloops = LOOPS(PRIME_TIMEOUT);\n\twhile (readl(&udc->op_regs->epprime) & 0xFFFFFFFF) {\n\t\tif (loops == 0) {\n\t\t\tdev_err(&udc->dev->dev,\n\t\t\t\t\"Timeout for ENDPTPRIME = 0x%x\\n\",\n\t\t\t\treadl(&udc->op_regs->epprime));\n\t\t\tbreak;\n\t\t}\n\t\tloops--;\n\t\tudelay(LOOPS_USEC);\n\t}\n\n\t \n\twritel((u32)~0, &udc->op_regs->epflush);\n\n\tif (readl(&udc->op_regs->portsc[0]) & PORTSCX_PORT_RESET) {\n\t\tdev_info(&udc->dev->dev, \"usb bus reset\\n\");\n\t\tudc->usb_state = USB_STATE_DEFAULT;\n\t\t \n\t\tgadget_reset(udc, udc->driver);\n\t} else {\n\t\tdev_info(&udc->dev->dev, \"USB reset portsc 0x%x\\n\",\n\t\t\treadl(&udc->op_regs->portsc));\n\n\t\t \n\t\tudc_reset(udc);\n\n\t\t \n\t\tstop_activity(udc, udc->driver);\n\n\t\t \n\t\tep0_reset(udc);\n\n\t\t \n\t\tudc_start(udc);\n\n\t\tudc->usb_state = USB_STATE_ATTACHED;\n\t}\n}\n\nstatic void handle_bus_resume(struct mv_udc *udc)\n{\n\tudc->usb_state = udc->resume_state;\n\tudc->resume_state = 0;\n\n\t \n\tif (udc->driver) {\n\t\tif (udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n}\n\nstatic void irq_process_suspend(struct mv_udc *udc)\n{\n\tudc->resume_state = udc->usb_state;\n\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\tif (udc->driver->suspend) {\n\t\tspin_unlock(&udc->lock);\n\t\tudc->driver->suspend(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\nstatic void irq_process_port_change(struct mv_udc *udc)\n{\n\tu32 portsc;\n\n\tportsc = readl(&udc->op_regs->portsc[0]);\n\tif (!(portsc & PORTSCX_PORT_RESET)) {\n\t\t \n\t\tu32 speed = portsc & PORTSCX_PORT_SPEED_MASK;\n\t\tswitch (speed) {\n\t\tcase PORTSCX_PORT_SPEED_HIGH:\n\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\t\tbreak;\n\t\tcase PORTSCX_PORT_SPEED_FULL:\n\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\t\tbreak;\n\t\tcase PORTSCX_PORT_SPEED_LOW:\n\t\t\tudc->gadget.speed = USB_SPEED_LOW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (portsc & PORTSCX_PORT_SUSPEND) {\n\t\tudc->resume_state = udc->usb_state;\n\t\tudc->usb_state = USB_STATE_SUSPENDED;\n\t\tif (udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tif (!(portsc & PORTSCX_PORT_SUSPEND)\n\t\t&& udc->usb_state == USB_STATE_SUSPENDED) {\n\t\thandle_bus_resume(udc);\n\t}\n\n\tif (!udc->resume_state)\n\t\tudc->usb_state = USB_STATE_DEFAULT;\n}\n\nstatic void irq_process_error(struct mv_udc *udc)\n{\n\t \n\tudc->errors++;\n}\n\nstatic irqreturn_t mv_udc_irq(int irq, void *dev)\n{\n\tstruct mv_udc *udc = (struct mv_udc *)dev;\n\tu32 status, intr;\n\n\t \n\tif (udc->stopped)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&udc->lock);\n\n\tstatus = readl(&udc->op_regs->usbsts);\n\tintr = readl(&udc->op_regs->usbintr);\n\tstatus &= intr;\n\n\tif (status == 0) {\n\t\tspin_unlock(&udc->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(status, &udc->op_regs->usbsts);\n\n\tif (status & USBSTS_ERR)\n\t\tirq_process_error(udc);\n\n\tif (status & USBSTS_RESET)\n\t\tirq_process_reset(udc);\n\n\tif (status & USBSTS_PORT_CHANGE)\n\t\tirq_process_port_change(udc);\n\n\tif (status & USBSTS_INT)\n\t\tirq_process_tr_complete(udc);\n\n\tif (status & USBSTS_SUSPEND)\n\t\tirq_process_suspend(udc);\n\n\tspin_unlock(&udc->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mv_udc_vbus_irq(int irq, void *dev)\n{\n\tstruct mv_udc *udc = (struct mv_udc *)dev;\n\n\t \n\tif (udc->qwork)\n\t\tqueue_work(udc->qwork, &udc->vbus_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mv_udc_vbus_work(struct work_struct *work)\n{\n\tstruct mv_udc *udc;\n\tunsigned int vbus;\n\n\tudc = container_of(work, struct mv_udc, vbus_work);\n\tif (!udc->pdata->vbus)\n\t\treturn;\n\n\tvbus = udc->pdata->vbus->poll();\n\tdev_info(&udc->dev->dev, \"vbus is %d\\n\", vbus);\n\n\tif (vbus == VBUS_HIGH)\n\t\tmv_udc_vbus_session(&udc->gadget, 1);\n\telse if (vbus == VBUS_LOW)\n\t\tmv_udc_vbus_session(&udc->gadget, 0);\n}\n\n \nstatic void gadget_release(struct device *_dev)\n{\n\tstruct mv_udc *udc;\n\n\tudc = dev_get_drvdata(_dev);\n\n\tcomplete(udc->done);\n}\n\nstatic void mv_udc_remove(struct platform_device *pdev)\n{\n\tstruct mv_udc *udc;\n\n\tudc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tif (udc->qwork)\n\t\tdestroy_workqueue(udc->qwork);\n\n\t \n\tdma_pool_destroy(udc->dtd_pool);\n\n\tif (udc->ep_dqh)\n\t\tdma_free_coherent(&pdev->dev, udc->ep_dqh_size,\n\t\t\tudc->ep_dqh, udc->ep_dqh_dma);\n\n\tmv_udc_disable(udc);\n\n\t \n\twait_for_completion(udc->done);\n}\n\nstatic int mv_udc_probe(struct platform_device *pdev)\n{\n\tstruct mv_usb_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct mv_udc *udc;\n\tint retval = 0;\n\tstruct resource *r;\n\tsize_t size;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"missing platform_data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\n\tif (udc == NULL)\n\t\treturn -ENOMEM;\n\n\tudc->done = &release_done;\n\tudc->pdata = dev_get_platdata(&pdev->dev);\n\tspin_lock_init(&udc->lock);\n\n\tudc->dev = pdev;\n\n\tif (pdata->mode == MV_USB_MODE_OTG) {\n\t\tudc->transceiver = devm_usb_get_phy(&pdev->dev,\n\t\t\t\t\tUSB_PHY_TYPE_USB2);\n\t\tif (IS_ERR(udc->transceiver)) {\n\t\t\tretval = PTR_ERR(udc->transceiver);\n\n\t\t\tif (retval == -ENXIO)\n\t\t\t\treturn retval;\n\n\t\t\tudc->transceiver = NULL;\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t}\n\n\t \n\tudc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(udc->clk))\n\t\treturn PTR_ERR(udc->clk);\n\n\tr = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, \"capregs\");\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no I/O memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tudc->cap_regs = (struct mv_cap_regs __iomem *)\n\t\tdevm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (udc->cap_regs == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map I/O memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tr = platform_get_resource_byname(udc->dev, IORESOURCE_MEM, \"phyregs\");\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no phy I/O memory resource defined\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tudc->phy_regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (udc->phy_regs == NULL) {\n\t\tdev_err(&pdev->dev, \"failed to map phy I/O memory\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tretval = mv_udc_enable_internal(udc);\n\tif (retval)\n\t\treturn retval;\n\n\tudc->op_regs =\n\t\t(struct mv_op_regs __iomem *)((unsigned long)udc->cap_regs\n\t\t+ (readl(&udc->cap_regs->caplength_hciversion)\n\t\t\t& CAPLENGTH_MASK));\n\tudc->max_eps = readl(&udc->cap_regs->dccparams) & DCCPARAMS_DEN_MASK;\n\n\t \n\tudc_stop(udc);\n\twritel(0xFFFFFFFF, &udc->op_regs->usbsts);\n\n\tsize = udc->max_eps * sizeof(struct mv_dqh) *2;\n\tsize = (size + DQH_ALIGNMENT - 1) & ~(DQH_ALIGNMENT - 1);\n\tudc->ep_dqh = dma_alloc_coherent(&pdev->dev, size,\n\t\t\t\t\t&udc->ep_dqh_dma, GFP_KERNEL);\n\n\tif (udc->ep_dqh == NULL) {\n\t\tdev_err(&pdev->dev, \"allocate dQH memory failed\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_disable_clock;\n\t}\n\tudc->ep_dqh_size = size;\n\n\t \n\tudc->dtd_pool = dma_pool_create(\"mv_dtd\",\n\t\t\t&pdev->dev,\n\t\t\tsizeof(struct mv_dtd),\n\t\t\tDTD_ALIGNMENT,\n\t\t\tDMA_BOUNDARY);\n\n\tif (!udc->dtd_pool) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_free_dma;\n\t}\n\n\tsize = udc->max_eps * sizeof(struct mv_ep) *2;\n\tudc->eps = devm_kzalloc(&pdev->dev, size, GFP_KERNEL);\n\tif (udc->eps == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_destroy_dma;\n\t}\n\n\t \n\tudc->status_req = devm_kzalloc(&pdev->dev, sizeof(struct mv_req),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!udc->status_req) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_destroy_dma;\n\t}\n\tINIT_LIST_HEAD(&udc->status_req->queue);\n\n\t \n\tudc->status_req->req.buf = devm_kzalloc(&pdev->dev, 8, GFP_KERNEL);\n\tif (!udc->status_req->req.buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_destroy_dma;\n\t}\n\tudc->status_req->req.dma = DMA_ADDR_INVALID;\n\n\tudc->resume_state = USB_STATE_NOTATTACHED;\n\tudc->usb_state = USB_STATE_POWERED;\n\tudc->ep0_dir = EP_DIR_OUT;\n\tudc->remote_wakeup = 0;\n\n\tr = platform_get_resource(udc->dev, IORESOURCE_IRQ, 0);\n\tif (r == NULL) {\n\t\tdev_err(&pdev->dev, \"no IRQ resource defined\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_destroy_dma;\n\t}\n\tudc->irq = r->start;\n\tif (devm_request_irq(&pdev->dev, udc->irq, mv_udc_irq,\n\t\tIRQF_SHARED, driver_name, udc)) {\n\t\tdev_err(&pdev->dev, \"Request irq %d for UDC failed\\n\",\n\t\t\tudc->irq);\n\t\tretval = -ENODEV;\n\t\tgoto err_destroy_dma;\n\t}\n\n\t \n\tudc->gadget.ops = &mv_ops;\t \n\tudc->gadget.ep0 = &udc->eps[0].ep;\t \n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\t \n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\t \n\tudc->gadget.max_speed = USB_SPEED_HIGH;\t \n\n\t \n\tudc->gadget.name = driver_name;\t\t \n\n\teps_init(udc);\n\n\t \n\tif (udc->transceiver)\n\t\tudc->clock_gating = 1;\n\telse if (pdata->vbus) {\n\t\tudc->clock_gating = 1;\n\t\tretval = devm_request_threaded_irq(&pdev->dev,\n\t\t\t\tpdata->vbus->irq, NULL,\n\t\t\t\tmv_udc_vbus_irq, IRQF_ONESHOT, \"vbus\", udc);\n\t\tif (retval) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\"Can not request irq for VBUS, \"\n\t\t\t\t\"disable clock gating\\n\");\n\t\t\tudc->clock_gating = 0;\n\t\t}\n\n\t\tudc->qwork = create_singlethread_workqueue(\"mv_udc_queue\");\n\t\tif (!udc->qwork) {\n\t\t\tdev_err(&pdev->dev, \"cannot create workqueue\\n\");\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_destroy_dma;\n\t\t}\n\n\t\tINIT_WORK(&udc->vbus_work, mv_udc_vbus_work);\n\t}\n\n\t \n\tif (udc->clock_gating)\n\t\tmv_udc_disable_internal(udc);\n\telse\n\t\tudc->vbus_active = 1;\n\n\tretval = usb_add_gadget_udc_release(&pdev->dev, &udc->gadget,\n\t\t\tgadget_release);\n\tif (retval)\n\t\tgoto err_create_workqueue;\n\n\tplatform_set_drvdata(pdev, udc);\n\tdev_info(&pdev->dev, \"successful probe UDC device %s clock gating.\\n\",\n\t\tudc->clock_gating ? \"with\" : \"without\");\n\n\treturn 0;\n\nerr_create_workqueue:\n\tif (udc->qwork)\n\t\tdestroy_workqueue(udc->qwork);\nerr_destroy_dma:\n\tdma_pool_destroy(udc->dtd_pool);\nerr_free_dma:\n\tdma_free_coherent(&pdev->dev, udc->ep_dqh_size,\n\t\t\tudc->ep_dqh, udc->ep_dqh_dma);\nerr_disable_clock:\n\tmv_udc_disable_internal(udc);\n\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\nstatic int mv_udc_suspend(struct device *dev)\n{\n\tstruct mv_udc *udc;\n\n\tudc = dev_get_drvdata(dev);\n\n\t \n\tif (udc->transceiver)\n\t\treturn 0;\n\n\tif (udc->pdata->vbus && udc->pdata->vbus->poll)\n\t\tif (udc->pdata->vbus->poll() == VBUS_HIGH) {\n\t\t\tdev_info(&udc->dev->dev, \"USB cable is connected!\\n\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t \n\tif (!udc->clock_gating) {\n\t\tudc_stop(udc);\n\n\t\tspin_lock_irq(&udc->lock);\n\t\t \n\t\tstop_activity(udc, udc->driver);\n\t\tspin_unlock_irq(&udc->lock);\n\n\t\tmv_udc_disable_internal(udc);\n\t}\n\n\treturn 0;\n}\n\nstatic int mv_udc_resume(struct device *dev)\n{\n\tstruct mv_udc *udc;\n\tint retval;\n\n\tudc = dev_get_drvdata(dev);\n\n\t \n\tif (udc->transceiver)\n\t\treturn 0;\n\n\tif (!udc->clock_gating) {\n\t\tretval = mv_udc_enable_internal(udc);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (udc->driver && udc->softconnect) {\n\t\t\tudc_reset(udc);\n\t\t\tep0_reset(udc);\n\t\t\tudc_start(udc);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops mv_udc_pm_ops = {\n\t.suspend\t= mv_udc_suspend,\n\t.resume\t\t= mv_udc_resume,\n};\n#endif\n\nstatic void mv_udc_shutdown(struct platform_device *pdev)\n{\n\tstruct mv_udc *udc;\n\tu32 mode;\n\n\tudc = platform_get_drvdata(pdev);\n\t \n\tmv_udc_enable(udc);\n\tmode = readl(&udc->op_regs->usbmode);\n\tmode &= ~3;\n\twritel(mode, &udc->op_regs->usbmode);\n\tmv_udc_disable(udc);\n}\n\nstatic struct platform_driver udc_driver = {\n\t.probe\t\t= mv_udc_probe,\n\t.remove_new\t= mv_udc_remove,\n\t.shutdown\t= mv_udc_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"mv-udc\",\n#ifdef CONFIG_PM\n\t\t.pm\t= &mv_udc_pm_ops,\n#endif\n\t},\n};\n\nmodule_platform_driver(udc_driver);\nMODULE_ALIAS(\"platform:mv-udc\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Chao Xie <chao.xie@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}