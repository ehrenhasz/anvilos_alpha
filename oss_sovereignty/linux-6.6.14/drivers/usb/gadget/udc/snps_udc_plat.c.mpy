{
  "module_name": "snps_udc_plat.c",
  "hash_id": "8e0f242bbea8c611ffa3c9ddfdbb147cc4323bc7908a31ed2249417cad9be7e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/snps_udc_plat.c",
  "human_readable_source": "\n \n\n#include <linux/extcon.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/module.h>\n#include <linux/dmapool.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include \"amd5536udc.h\"\n\n \n#define UDC_MOD_DESCRIPTION     \"Synopsys UDC platform driver\"\n\nstatic void start_udc(struct udc *udc)\n{\n\tif (udc->driver) {\n\t\tdev_info(udc->dev, \"Connecting...\\n\");\n\t\tudc_enable_dev_setup_interrupts(udc);\n\t\tudc_basic_init(udc);\n\t\tudc->connected = 1;\n\t}\n}\n\nstatic void stop_udc(struct udc *udc)\n{\n\tint tmp;\n\tu32 reg;\n\n\tspin_lock(&udc->lock);\n\n\t \n\treg = readl(&udc->regs->ctl);\n\treg |= AMD_BIT(UDC_DEVCTL_SRX_FLUSH);\n\twritel(reg, &udc->regs->ctl);\n\n\treg = readl(&udc->regs->ctl);\n\treg &= ~(AMD_BIT(UDC_DEVCTL_SRX_FLUSH));\n\twritel(reg, &udc->regs->ctl);\n\tdev_dbg(udc->dev, \"ep rx queue flushed\\n\");\n\n\t \n\tudc_mask_unused_interrupts(udc);\n\n\t \n\tif (udc->driver) {\n\t\tspin_unlock(&udc->lock);\n\t\tudc->driver->disconnect(&udc->gadget);\n\t\tspin_lock(&udc->lock);\n\n\t\t \n\t\tfor (tmp = 0; tmp < UDC_EP_NUM; tmp++)\n\t\t\tempty_req_queue(&udc->ep[tmp]);\n\t}\n\tudc->connected = 0;\n\n\tspin_unlock(&udc->lock);\n\tdev_info(udc->dev, \"Device disconnected\\n\");\n}\n\nstatic void udc_drd_work(struct work_struct *work)\n{\n\tstruct udc *udc;\n\n\tudc = container_of(to_delayed_work(work),\n\t\t\t   struct udc, drd_work);\n\n\tif (udc->conn_type) {\n\t\tdev_dbg(udc->dev, \"idle -> device\\n\");\n\t\tstart_udc(udc);\n\t} else {\n\t\tdev_dbg(udc->dev, \"device -> idle\\n\");\n\t\tstop_udc(udc);\n\t}\n}\n\nstatic int usbd_connect_notify(struct notifier_block *self,\n\t\t\t       unsigned long event, void *ptr)\n{\n\tstruct udc *udc = container_of(self, struct udc, nb);\n\n\tdev_dbg(udc->dev, \"%s: event: %lu\\n\", __func__, event);\n\n\tudc->conn_type = event;\n\n\tschedule_delayed_work(&udc->drd_work, 0);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int udc_plat_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct udc *udc;\n\tint ret;\n\n\tudc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&udc->lock);\n\tudc->dev = dev;\n\n\tudc->virt_addr = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(udc->virt_addr))\n\t\treturn PTR_ERR(udc->virt_addr);\n\n\t \n\tudc->csr = udc->virt_addr + UDC_CSR_ADDR;\n\n\t \n\tudc->regs = udc->virt_addr + UDC_DEVCFG_ADDR;\n\n\t \n\tudc->ep_regs = udc->virt_addr + UDC_EPREGS_ADDR;\n\n\t \n\tudc->rxfifo = (u32 __iomem *)(udc->virt_addr + UDC_RXFIFO_ADDR);\n\tudc->txfifo = (u32 __iomem *)(udc->virt_addr + UDC_TXFIFO_ADDR);\n\n\tudc->phys_addr = (unsigned long)res->start;\n\n\tudc->irq = irq_of_parse_and_map(dev->of_node, 0);\n\tif (udc->irq <= 0) {\n\t\tdev_err(dev, \"Can't parse and map interrupt\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tudc->udc_phy = devm_of_phy_get_by_index(dev, dev->of_node, 0);\n\tif (IS_ERR(udc->udc_phy)) {\n\t\tdev_err(dev, \"Failed to obtain phy from device tree\\n\");\n\t\treturn PTR_ERR(udc->udc_phy);\n\t}\n\n\tret = phy_init(udc->udc_phy);\n\tif (ret) {\n\t\tdev_err(dev, \"UDC phy init failed\");\n\t\treturn ret;\n\t}\n\n\tret = phy_power_on(udc->udc_phy);\n\tif (ret) {\n\t\tdev_err(dev, \"UDC phy power on failed\");\n\t\tphy_exit(udc->udc_phy);\n\t\treturn ret;\n\t}\n\n\t \n\tif (of_property_present(dev->of_node, \"extcon\")) {\n\t\tudc->edev = extcon_get_edev_by_phandle(dev, 0);\n\t\tif (IS_ERR(udc->edev)) {\n\t\t\tif (PTR_ERR(udc->edev) == -EPROBE_DEFER)\n\t\t\t\treturn -EPROBE_DEFER;\n\t\t\tdev_err(dev, \"Invalid or missing extcon\\n\");\n\t\t\tret = PTR_ERR(udc->edev);\n\t\t\tgoto exit_phy;\n\t\t}\n\n\t\tudc->nb.notifier_call = usbd_connect_notify;\n\t\tret = extcon_register_notifier(udc->edev, EXTCON_USB,\n\t\t\t\t\t       &udc->nb);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Can't register extcon device\\n\");\n\t\t\tgoto exit_phy;\n\t\t}\n\n\t\tret = extcon_get_state(udc->edev, EXTCON_USB);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"Can't get cable state\\n\");\n\t\t\tgoto exit_extcon;\n\t\t} else if (ret) {\n\t\t\tudc->conn_type = ret;\n\t\t}\n\t\tINIT_DELAYED_WORK(&udc->drd_work, udc_drd_work);\n\t}\n\n\t \n\tif (use_dma) {\n\t\tret = init_dma_pools(udc);\n\t\tif (ret != 0)\n\t\t\tgoto exit_extcon;\n\t}\n\n\tret = devm_request_irq(dev, udc->irq, udc_irq, IRQF_SHARED,\n\t\t\t       \"snps-udc\", udc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Request irq %d failed for UDC\\n\", udc->irq);\n\t\tgoto exit_dma;\n\t}\n\n\tplatform_set_drvdata(pdev, udc);\n\tudc->chiprev = UDC_BCM_REV;\n\n\tif (udc_probe(udc)) {\n\t\tret = -ENODEV;\n\t\tgoto exit_dma;\n\t}\n\tdev_info(dev, \"Synopsys UDC platform driver probe successful\\n\");\n\n\treturn 0;\n\nexit_dma:\n\tif (use_dma)\n\t\tfree_dma_pools(udc);\nexit_extcon:\n\tif (udc->edev)\n\t\textcon_unregister_notifier(udc->edev, EXTCON_USB, &udc->nb);\nexit_phy:\n\tif (udc->udc_phy) {\n\t\tphy_power_off(udc->udc_phy);\n\t\tphy_exit(udc->udc_phy);\n\t}\n\treturn ret;\n}\n\nstatic void udc_plat_remove(struct platform_device *pdev)\n{\n\tstruct udc *dev;\n\n\tdev = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&dev->gadget);\n\t \n\tif (WARN_ON(dev->driver))\n\t\treturn;\n\n\t \n\tfree_dma_pools(dev);\n\n\tudc_remove(dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n\n\tphy_power_off(dev->udc_phy);\n\tphy_exit(dev->udc_phy);\n\textcon_unregister_notifier(dev->edev, EXTCON_USB, &dev->nb);\n\n\tdev_info(&pdev->dev, \"Synopsys UDC platform driver removed\\n\");\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int udc_plat_suspend(struct device *dev)\n{\n\tstruct udc *udc;\n\n\tudc = dev_get_drvdata(dev);\n\tstop_udc(udc);\n\n\tif (extcon_get_state(udc->edev, EXTCON_USB) > 0) {\n\t\tdev_dbg(udc->dev, \"device -> idle\\n\");\n\t\tstop_udc(udc);\n\t}\n\tphy_power_off(udc->udc_phy);\n\tphy_exit(udc->udc_phy);\n\n\treturn 0;\n}\n\nstatic int udc_plat_resume(struct device *dev)\n{\n\tstruct udc *udc;\n\tint ret;\n\n\tudc = dev_get_drvdata(dev);\n\n\tret = phy_init(udc->udc_phy);\n\tif (ret) {\n\t\tdev_err(udc->dev, \"UDC phy init failure\");\n\t\treturn ret;\n\t}\n\n\tret = phy_power_on(udc->udc_phy);\n\tif (ret) {\n\t\tdev_err(udc->dev, \"UDC phy power on failure\");\n\t\tphy_exit(udc->udc_phy);\n\t\treturn ret;\n\t}\n\n\tif (extcon_get_state(udc->edev, EXTCON_USB) > 0) {\n\t\tdev_dbg(udc->dev, \"idle -> device\\n\");\n\t\tstart_udc(udc);\n\t}\n\n\treturn 0;\n}\nstatic const struct dev_pm_ops udc_plat_pm_ops = {\n\t.suspend\t= udc_plat_suspend,\n\t.resume\t\t= udc_plat_resume,\n};\n#endif\n\nstatic const struct of_device_id of_udc_match[] = {\n\t{ .compatible = \"brcm,ns2-udc\", },\n\t{ .compatible = \"brcm,cygnus-udc\", },\n\t{ .compatible = \"brcm,iproc-udc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, of_udc_match);\n\nstatic struct platform_driver udc_plat_driver = {\n\t.probe\t\t= udc_plat_probe,\n\t.remove_new\t= udc_plat_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"snps-udc-plat\",\n\t\t.of_match_table = of_udc_match,\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &udc_plat_pm_ops,\n#endif\n\t},\n};\nmodule_platform_driver(udc_plat_driver);\n\nMODULE_DESCRIPTION(UDC_MOD_DESCRIPTION);\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}