{
  "module_name": "fsl_qe_udc.c",
  "hash_id": "26acf6e30d1b847754d1331f44cba4d31f43bd39d82720a524b89d07e3a59bed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/fsl_qe_udc.c",
  "human_readable_source": "\n \n\n#undef USB_TRACE\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/ioport.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/moduleparam.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <soc/fsl/qe/qe.h>\n#include <asm/cpm.h>\n#include <asm/dma.h>\n#include <asm/reg.h>\n#include \"fsl_qe_udc.h\"\n\n#define DRIVER_DESC     \"Freescale QE/CPM USB Device Controller driver\"\n#define DRIVER_AUTHOR   \"Xie XiaoBo\"\n#define DRIVER_VERSION  \"1.0\"\n\n#define DMA_ADDR_INVALID        (~(dma_addr_t)0)\n\nstatic const char driver_name[] = \"fsl_qe_udc\";\nstatic const char driver_desc[] = DRIVER_DESC;\n\n \nstatic const char *const ep_name[] = {\n\t\"ep0-control\",  \n\t \n\t\"ep1\",\n\t\"ep2\",\n\t\"ep3\",\n};\n\nstatic const struct usb_endpoint_descriptor qe_ep0_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\n\t.bEndpointAddress =\t0,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize =\tUSB_MAX_CTRL_PAYLOAD,\n};\n\n \n \nstatic void done(struct qe_ep *ep, struct qe_req *req, int status)\n{\n\tstruct qe_udc *udc = ep->udc;\n\tunsigned char stopped = ep->stopped;\n\n\t \n\tlist_del_init(&req->queue);\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (req->mapped) {\n\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\treq->req.dma, req->req.length,\n\t\t\tep_is_in(ep)\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t\treq->req.dma = DMA_ADDR_INVALID;\n\t\treq->mapped = 0;\n\t} else\n\t\tdma_sync_single_for_cpu(udc->gadget.dev.parent,\n\t\t\treq->req.dma, req->req.length,\n\t\t\tep_is_in(ep)\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\n\tif (status && (status != -ESHUTDOWN))\n\t\tdev_vdbg(udc->dev, \"complete %s req %p stat %d len %u/%u\\n\",\n\t\t\tep->ep.name, &req->req, status,\n\t\t\treq->req.actual, req->req.length);\n\n\t \n\tep->stopped = 1;\n\tspin_unlock(&udc->lock);\n\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\n\tspin_lock(&udc->lock);\n\n\tep->stopped = stopped;\n}\n\n \nstatic void nuke(struct qe_ep *ep, int status)\n{\n\t \n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct qe_req *req = NULL;\n\t\treq = list_entry(ep->queue.next, struct qe_req, queue);\n\n\t\tdone(ep, req, status);\n\t}\n}\n\n \n \nstatic int qe_eprx_stall_change(struct qe_ep *ep, int value)\n{\n\tu16 tem_usep;\n\tu8 epnum = ep->epnum;\n\tstruct qe_udc *udc = ep->udc;\n\n\ttem_usep = in_be16(&udc->usb_regs->usb_usep[epnum]);\n\ttem_usep = tem_usep & ~USB_RHS_MASK;\n\tif (value == 1)\n\t\ttem_usep |= USB_RHS_STALL;\n\telse if (ep->dir == USB_DIR_IN)\n\t\ttem_usep |= USB_RHS_IGNORE_OUT;\n\n\tout_be16(&udc->usb_regs->usb_usep[epnum], tem_usep);\n\treturn 0;\n}\n\nstatic int qe_eptx_stall_change(struct qe_ep *ep, int value)\n{\n\tu16 tem_usep;\n\tu8 epnum = ep->epnum;\n\tstruct qe_udc *udc = ep->udc;\n\n\ttem_usep = in_be16(&udc->usb_regs->usb_usep[epnum]);\n\ttem_usep = tem_usep & ~USB_THS_MASK;\n\tif (value == 1)\n\t\ttem_usep |= USB_THS_STALL;\n\telse if (ep->dir == USB_DIR_OUT)\n\t\ttem_usep |= USB_THS_IGNORE_IN;\n\n\tout_be16(&udc->usb_regs->usb_usep[epnum], tem_usep);\n\n\treturn 0;\n}\n\nstatic int qe_ep0_stall(struct qe_udc *udc)\n{\n\tqe_eptx_stall_change(&udc->eps[0], 1);\n\tqe_eprx_stall_change(&udc->eps[0], 1);\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = 0;\n\treturn 0;\n}\n\nstatic int qe_eprx_nack(struct qe_ep *ep)\n{\n\tu8 epnum = ep->epnum;\n\tstruct qe_udc *udc = ep->udc;\n\n\tif (ep->state == EP_STATE_IDLE) {\n\t\t \n\t\tclrsetbits_be16(&udc->usb_regs->usb_usep[epnum],\n\t\t\t\tUSB_RHS_MASK, USB_RHS_NACK);\n\n\t\t \n\t\tclrbits16(&udc->usb_regs->usb_usbmr,\n\t\t\t\t(USB_E_RXB_MASK | USB_E_BSY_MASK));\n\n\t\tep->state = EP_STATE_NACK;\n\t}\n\treturn 0;\n}\n\nstatic int qe_eprx_normal(struct qe_ep *ep)\n{\n\tstruct qe_udc *udc = ep->udc;\n\n\tif (ep->state == EP_STATE_NACK) {\n\t\tclrsetbits_be16(&udc->usb_regs->usb_usep[ep->epnum],\n\t\t\t\tUSB_RTHS_MASK, USB_THS_IGNORE_IN);\n\n\t\t \n\t\tout_be16(&udc->usb_regs->usb_usber,\n\t\t\t\tUSB_E_BSY_MASK | USB_E_RXB_MASK);\n\t\tsetbits16(&udc->usb_regs->usb_usbmr,\n\t\t\t\t(USB_E_RXB_MASK | USB_E_BSY_MASK));\n\n\t\tep->state = EP_STATE_IDLE;\n\t\tep->has_data = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int qe_ep_cmd_stoptx(struct qe_ep *ep)\n{\n\tif (ep->udc->soc_type == PORT_CPM)\n\t\tcpm_command(CPM_USB_STOP_TX | (ep->epnum << CPM_USB_EP_SHIFT),\n\t\t\t\tCPM_USB_STOP_TX_OPCODE);\n\telse\n\t\tqe_issue_cmd(QE_USB_STOP_TX, QE_CR_SUBBLOCK_USB,\n\t\t\t\tep->epnum, 0);\n\n\treturn 0;\n}\n\nstatic int qe_ep_cmd_restarttx(struct qe_ep *ep)\n{\n\tif (ep->udc->soc_type == PORT_CPM)\n\t\tcpm_command(CPM_USB_RESTART_TX | (ep->epnum <<\n\t\t\t\tCPM_USB_EP_SHIFT), CPM_USB_RESTART_TX_OPCODE);\n\telse\n\t\tqe_issue_cmd(QE_USB_RESTART_TX, QE_CR_SUBBLOCK_USB,\n\t\t\t\tep->epnum, 0);\n\n\treturn 0;\n}\n\nstatic int qe_ep_flushtxfifo(struct qe_ep *ep)\n{\n\tstruct qe_udc *udc = ep->udc;\n\tint i;\n\n\ti = (int)ep->epnum;\n\n\tqe_ep_cmd_stoptx(ep);\n\tout_8(&udc->usb_regs->usb_uscom,\n\t\tUSB_CMD_FLUSH_FIFO | (USB_CMD_EP_MASK & (ep->epnum)));\n\tout_be16(&udc->ep_param[i]->tbptr, in_be16(&udc->ep_param[i]->tbase));\n\tout_be32(&udc->ep_param[i]->tstate, 0);\n\tout_be16(&udc->ep_param[i]->tbcnt, 0);\n\n\tep->c_txbd = ep->txbase;\n\tep->n_txbd = ep->txbase;\n\tqe_ep_cmd_restarttx(ep);\n\treturn 0;\n}\n\nstatic int qe_ep_filltxfifo(struct qe_ep *ep)\n{\n\tstruct qe_udc *udc = ep->udc;\n\n\tout_8(&udc->usb_regs->usb_uscom,\n\t\t\tUSB_CMD_STR_FIFO | (USB_CMD_EP_MASK & (ep->epnum)));\n\treturn 0;\n}\n\nstatic int qe_epbds_reset(struct qe_udc *udc, int pipe_num)\n{\n\tstruct qe_ep *ep;\n\tu32 bdring_len;\n\tstruct qe_bd __iomem *bd;\n\tint i;\n\n\tep = &udc->eps[pipe_num];\n\n\tif (ep->dir == USB_DIR_OUT)\n\t\tbdring_len = USB_BDRING_LEN_RX;\n\telse\n\t\tbdring_len = USB_BDRING_LEN;\n\n\tbd = ep->rxbase;\n\tfor (i = 0; i < (bdring_len - 1); i++) {\n\t\tout_be32((u32 __iomem *)bd, R_E | R_I);\n\t\tbd++;\n\t}\n\tout_be32((u32 __iomem *)bd, R_E | R_I | R_W);\n\n\tbd = ep->txbase;\n\tfor (i = 0; i < USB_BDRING_LEN_TX - 1; i++) {\n\t\tout_be32(&bd->buf, 0);\n\t\tout_be32((u32 __iomem *)bd, 0);\n\t\tbd++;\n\t}\n\tout_be32((u32 __iomem *)bd, T_W);\n\n\treturn 0;\n}\n\nstatic int qe_ep_reset(struct qe_udc *udc, int pipe_num)\n{\n\tstruct qe_ep *ep;\n\tu16 tmpusep;\n\n\tep = &udc->eps[pipe_num];\n\ttmpusep = in_be16(&udc->usb_regs->usb_usep[pipe_num]);\n\ttmpusep &= ~USB_RTHS_MASK;\n\n\tswitch (ep->dir) {\n\tcase USB_DIR_BOTH:\n\t\tqe_ep_flushtxfifo(ep);\n\t\tbreak;\n\tcase USB_DIR_OUT:\n\t\ttmpusep |= USB_THS_IGNORE_IN;\n\t\tbreak;\n\tcase USB_DIR_IN:\n\t\tqe_ep_flushtxfifo(ep);\n\t\ttmpusep |= USB_RHS_IGNORE_OUT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tout_be16(&udc->usb_regs->usb_usep[pipe_num], tmpusep);\n\n\tqe_epbds_reset(udc, pipe_num);\n\n\treturn 0;\n}\n\nstatic int qe_ep_toggledata01(struct qe_ep *ep)\n{\n\tep->data01 ^= 0x1;\n\treturn 0;\n}\n\nstatic int qe_ep_bd_init(struct qe_udc *udc, unsigned char pipe_num)\n{\n\tstruct qe_ep *ep = &udc->eps[pipe_num];\n\tunsigned long tmp_addr = 0;\n\tstruct usb_ep_para __iomem *epparam;\n\tint i;\n\tstruct qe_bd __iomem *bd;\n\tint bdring_len;\n\n\tif (ep->dir == USB_DIR_OUT)\n\t\tbdring_len = USB_BDRING_LEN_RX;\n\telse\n\t\tbdring_len = USB_BDRING_LEN;\n\n\tepparam = udc->ep_param[pipe_num];\n\t \n\ttmp_addr = cpm_muram_alloc(sizeof(struct qe_bd) * (bdring_len +\n\t\t\t\tUSB_BDRING_LEN_TX), QE_ALIGNMENT_OF_BD);\n\tif (IS_ERR_VALUE(tmp_addr))\n\t\treturn -ENOMEM;\n\n\tout_be16(&epparam->rbase, (u16)tmp_addr);\n\tout_be16(&epparam->tbase, (u16)(tmp_addr +\n\t\t\t\t(sizeof(struct qe_bd) * bdring_len)));\n\n\tout_be16(&epparam->rbptr, in_be16(&epparam->rbase));\n\tout_be16(&epparam->tbptr, in_be16(&epparam->tbase));\n\n\tep->rxbase = cpm_muram_addr(tmp_addr);\n\tep->txbase = cpm_muram_addr(tmp_addr + (sizeof(struct qe_bd)\n\t\t\t\t* bdring_len));\n\tep->n_rxbd = ep->rxbase;\n\tep->e_rxbd = ep->rxbase;\n\tep->n_txbd = ep->txbase;\n\tep->c_txbd = ep->txbase;\n\tep->data01 = 0;  \n\n\t \n\tbd = ep->rxbase;\n\tfor (i = 0; i < bdring_len - 1; i++) {\n\t\tout_be32(&bd->buf, 0);\n\t\tout_be32((u32 __iomem *)bd, 0);\n\t\tbd++;\n\t}\n\tout_be32(&bd->buf, 0);\n\tout_be32((u32 __iomem *)bd, R_W);\n\n\tbd = ep->txbase;\n\tfor (i = 0; i < USB_BDRING_LEN_TX - 1; i++) {\n\t\tout_be32(&bd->buf, 0);\n\t\tout_be32((u32 __iomem *)bd, 0);\n\t\tbd++;\n\t}\n\tout_be32(&bd->buf, 0);\n\tout_be32((u32 __iomem *)bd, T_W);\n\n\treturn 0;\n}\n\nstatic int qe_ep_rxbd_update(struct qe_ep *ep)\n{\n\tunsigned int size;\n\tint i;\n\tunsigned int tmp;\n\tstruct qe_bd __iomem *bd;\n\tunsigned int bdring_len;\n\n\tif (ep->rxbase == NULL)\n\t\treturn -EINVAL;\n\n\tbd = ep->rxbase;\n\n\tep->rxframe = kmalloc(sizeof(*ep->rxframe), GFP_ATOMIC);\n\tif (!ep->rxframe)\n\t\treturn -ENOMEM;\n\n\tqe_frame_init(ep->rxframe);\n\n\tif (ep->dir == USB_DIR_OUT)\n\t\tbdring_len = USB_BDRING_LEN_RX;\n\telse\n\t\tbdring_len = USB_BDRING_LEN;\n\n\tsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) * (bdring_len + 1);\n\tep->rxbuffer = kzalloc(size, GFP_ATOMIC);\n\tif (!ep->rxbuffer) {\n\t\tkfree(ep->rxframe);\n\t\treturn -ENOMEM;\n\t}\n\n\tep->rxbuf_d = virt_to_phys((void *)ep->rxbuffer);\n\tif (ep->rxbuf_d == DMA_ADDR_INVALID) {\n\t\tep->rxbuf_d = dma_map_single(ep->udc->gadget.dev.parent,\n\t\t\t\t\tep->rxbuffer,\n\t\t\t\t\tsize,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tep->rxbufmap = 1;\n\t} else {\n\t\tdma_sync_single_for_device(ep->udc->gadget.dev.parent,\n\t\t\t\t\tep->rxbuf_d, size,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tep->rxbufmap = 0;\n\t}\n\n\tsize = ep->ep.maxpacket + USB_CRC_SIZE + 2;\n\ttmp = ep->rxbuf_d;\n\ttmp = (u32)(((tmp >> 2) << 2) + 4);\n\n\tfor (i = 0; i < bdring_len - 1; i++) {\n\t\tout_be32(&bd->buf, tmp);\n\t\tout_be32((u32 __iomem *)bd, (R_E | R_I));\n\t\ttmp = tmp + size;\n\t\tbd++;\n\t}\n\tout_be32(&bd->buf, tmp);\n\tout_be32((u32 __iomem *)bd, (R_E | R_I | R_W));\n\n\treturn 0;\n}\n\nstatic int qe_ep_register_init(struct qe_udc *udc, unsigned char pipe_num)\n{\n\tstruct qe_ep *ep = &udc->eps[pipe_num];\n\tstruct usb_ep_para __iomem *epparam;\n\tu16 usep, logepnum;\n\tu16 tmp;\n\tu8 rtfcr = 0;\n\n\tepparam = udc->ep_param[pipe_num];\n\n\tusep = 0;\n\tlogepnum = (ep->ep.desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tusep |= (logepnum << USB_EPNUM_SHIFT);\n\n\tswitch (ep->ep.desc->bmAttributes & 0x03) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tusep |= USB_TRANS_BULK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tusep |=  USB_TRANS_ISO;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tusep |= USB_TRANS_INT;\n\t\tbreak;\n\tdefault:\n\t\tusep |= USB_TRANS_CTR;\n\t\tbreak;\n\t}\n\n\tswitch (ep->dir) {\n\tcase USB_DIR_OUT:\n\t\tusep |= USB_THS_IGNORE_IN;\n\t\tbreak;\n\tcase USB_DIR_IN:\n\t\tusep |= USB_RHS_IGNORE_OUT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tout_be16(&udc->usb_regs->usb_usep[pipe_num], usep);\n\n\trtfcr = 0x30;\n\tout_8(&epparam->rbmr, rtfcr);\n\tout_8(&epparam->tbmr, rtfcr);\n\n\ttmp = (u16)(ep->ep.maxpacket + USB_CRC_SIZE);\n\t \n\ttmp = (u16)(((tmp >> 2) << 2) + 4);\n\tout_be16(&epparam->mrblr, tmp);\n\n\treturn 0;\n}\n\nstatic int qe_ep_init(struct qe_udc *udc,\n\t\t      unsigned char pipe_num,\n\t\t      const struct usb_endpoint_descriptor *desc)\n{\n\tstruct qe_ep *ep = &udc->eps[pipe_num];\n\tunsigned long flags;\n\tint reval = 0;\n\tu16 max = 0;\n\n\tmax = usb_endpoint_maxp(desc);\n\n\t \n\t \n\tif (pipe_num != 0) {\n\t\tswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tif (strstr(ep->ep.name, \"-iso\")\n\t\t\t\t\t|| strstr(ep->ep.name, \"-int\"))\n\t\t\t\tgoto en_done;\n\t\t\tswitch (udc->gadget.speed) {\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\tif ((max == 128) || (max == 256) || (max == 512))\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tswitch (max) {\n\t\t\t\tcase 4:\n\t\t\t\tcase 8:\n\t\t\t\tcase 16:\n\t\t\t\tcase 32:\n\t\t\t\tcase 64:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tcase USB_SPEED_LOW:\n\t\t\t\t\tgoto en_done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tif (strstr(ep->ep.name, \"-iso\"))\t \n\t\t\t\tgoto en_done;\n\t\t\tswitch (udc->gadget.speed) {\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\tif (max <= 1024)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tcase USB_SPEED_FULL:\n\t\t\t\tif (max <= 64)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tif (max <= 8)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto en_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tif (strstr(ep->ep.name, \"-bulk\")\n\t\t\t\t|| strstr(ep->ep.name, \"-int\"))\n\t\t\t\tgoto en_done;\n\t\t\tswitch (udc->gadget.speed) {\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\tif (max <= 1024)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tcase USB_SPEED_FULL:\n\t\t\t\tif (max <= 1023)\n\t\t\t\t\tbreak;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tgoto en_done;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tif (strstr(ep->ep.name, \"-iso\")\n\t\t\t\t|| strstr(ep->ep.name, \"-int\"))\n\t\t\t\tgoto en_done;\n\t\t\tswitch (udc->gadget.speed) {\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\tcase USB_SPEED_FULL:\n\t\t\t\tswitch (max) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 4:\n\t\t\t\tcase 8:\n\t\t\t\tcase 16:\n\t\t\t\tcase 32:\n\t\t\t\tcase 64:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto en_done;\n\t\t\t\t}\n\t\t\t\tfallthrough;\n\t\t\tcase USB_SPEED_LOW:\n\t\t\t\tswitch (max) {\n\t\t\t\tcase 1:\n\t\t\t\tcase 2:\n\t\t\t\tcase 4:\n\t\t\t\tcase 8:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tgoto en_done;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tgoto en_done;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto en_done;\n\t\t}\n\t}  \n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tep->ep.maxpacket = max;\n\tep->tm = (u8)(desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);\n\tep->ep.desc = desc;\n\tep->stopped = 0;\n\tep->init = 1;\n\n\tif (pipe_num == 0) {\n\t\tep->dir = USB_DIR_BOTH;\n\t\tudc->ep0_dir = USB_DIR_OUT;\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t} else\t{\n\t\tswitch (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) {\n\t\tcase USB_DIR_OUT:\n\t\t\tep->dir = USB_DIR_OUT;\n\t\t\tbreak;\n\t\tcase USB_DIR_IN:\n\t\t\tep->dir = USB_DIR_IN;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tqe_ep_bd_init(udc, pipe_num);\n\tif ((ep->tm == USBP_TM_CTL) || (ep->dir == USB_DIR_OUT)) {\n\t\treval = qe_ep_rxbd_update(ep);\n\t\tif (reval)\n\t\t\tgoto en_done1;\n\t}\n\n\tif ((ep->tm == USBP_TM_CTL) || (ep->dir == USB_DIR_IN)) {\n\t\tep->txframe = kmalloc(sizeof(*ep->txframe), GFP_ATOMIC);\n\t\tif (!ep->txframe)\n\t\t\tgoto en_done2;\n\t\tqe_frame_init(ep->txframe);\n\t}\n\n\tqe_ep_register_init(udc, pipe_num);\n\n\t \n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\nen_done2:\n\tkfree(ep->rxbuffer);\n\tkfree(ep->rxframe);\nen_done1:\n\tspin_unlock_irqrestore(&udc->lock, flags);\nen_done:\n\tdev_err(udc->dev, \"failed to initialize %s\\n\", ep->ep.name);\n\treturn -ENODEV;\n}\n\nstatic inline void qe_usb_enable(struct qe_udc *udc)\n{\n\tsetbits8(&udc->usb_regs->usb_usmod, USB_MODE_EN);\n}\n\nstatic inline void qe_usb_disable(struct qe_udc *udc)\n{\n\tclrbits8(&udc->usb_regs->usb_usmod, USB_MODE_EN);\n}\n\n \n\n\n \nstatic void recycle_one_rxbd(struct qe_ep *ep)\n{\n\tu32 bdstatus;\n\n\tbdstatus = in_be32((u32 __iomem *)ep->e_rxbd);\n\tbdstatus = R_I | R_E | (bdstatus & R_W);\n\tout_be32((u32 __iomem *)ep->e_rxbd, bdstatus);\n\n\tif (bdstatus & R_W)\n\t\tep->e_rxbd = ep->rxbase;\n\telse\n\t\tep->e_rxbd++;\n}\n\nstatic void recycle_rxbds(struct qe_ep *ep, unsigned char stopatnext)\n{\n\tu32 bdstatus;\n\tstruct qe_bd __iomem *bd, *nextbd;\n\tunsigned char stop = 0;\n\n\tnextbd = ep->n_rxbd;\n\tbd = ep->e_rxbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\n\twhile (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK) && !stop) {\n\t\tbdstatus = R_E | R_I | (bdstatus & R_W);\n\t\tout_be32((u32 __iomem *)bd, bdstatus);\n\n\t\tif (bdstatus & R_W)\n\t\t\tbd = ep->rxbase;\n\t\telse\n\t\t\tbd++;\n\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t\tif (stopatnext && (bd == nextbd))\n\t\t\tstop = 1;\n\t}\n\n\tep->e_rxbd = bd;\n}\n\nstatic void ep_recycle_rxbds(struct qe_ep *ep)\n{\n\tstruct qe_bd __iomem *bd = ep->n_rxbd;\n\tu32 bdstatus;\n\tu8 epnum = ep->epnum;\n\tstruct qe_udc *udc = ep->udc;\n\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\tif (!(bdstatus & R_E) && !(bdstatus & BD_LENGTH_MASK)) {\n\t\tbd = ep->rxbase +\n\t\t\t\t((in_be16(&udc->ep_param[epnum]->rbptr) -\n\t\t\t\t  in_be16(&udc->ep_param[epnum]->rbase))\n\t\t\t\t >> 3);\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\n\t\tif (bdstatus & R_W)\n\t\t\tbd = ep->rxbase;\n\t\telse\n\t\t\tbd++;\n\n\t\tep->e_rxbd = bd;\n\t\trecycle_rxbds(ep, 0);\n\t\tep->e_rxbd = ep->n_rxbd;\n\t} else\n\t\trecycle_rxbds(ep, 1);\n\n\tif (in_be16(&udc->usb_regs->usb_usber) & USB_E_BSY_MASK)\n\t\tout_be16(&udc->usb_regs->usb_usber, USB_E_BSY_MASK);\n\n\tif (ep->has_data <= 0 && (!list_empty(&ep->queue)))\n\t\tqe_eprx_normal(ep);\n\n\tep->localnack = 0;\n}\n\nstatic void setup_received_handle(struct qe_udc *udc,\n\t\t\t\t\tstruct usb_ctrlrequest *setup);\nstatic int qe_ep_rxframe_handle(struct qe_ep *ep);\nstatic void ep0_req_complete(struct qe_udc *udc, struct qe_req *req);\n \nstatic int ep0_setup_handle(struct qe_udc *udc)\n{\n\tstruct qe_ep *ep = &udc->eps[0];\n\tstruct qe_frame *pframe;\n\tunsigned int fsize;\n\tu8 *cp;\n\n\tpframe = ep->rxframe;\n\tif ((frame_get_info(pframe) & PID_SETUP)\n\t\t\t&& (udc->ep0_state == WAIT_FOR_SETUP)) {\n\t\tfsize = frame_get_length(pframe);\n\t\tif (unlikely(fsize != 8))\n\t\t\treturn -EINVAL;\n\t\tcp = (u8 *)&udc->local_setup_buff;\n\t\tmemcpy(cp, pframe->data, fsize);\n\t\tep->data01 = 1;\n\n\t\t \n\t\tsetup_received_handle(udc, &udc->local_setup_buff);\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\nstatic int qe_ep0_rx(struct qe_udc *udc)\n{\n\tstruct qe_ep *ep = &udc->eps[0];\n\tstruct qe_frame *pframe;\n\tstruct qe_bd __iomem *bd;\n\tu32 bdstatus, length;\n\tu32 vaddr;\n\n\tpframe = ep->rxframe;\n\n\tif (ep->dir == USB_DIR_IN) {\n\t\tdev_err(udc->dev, \"ep0 not a control endpoint\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbd = ep->n_rxbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\tlength = bdstatus & BD_LENGTH_MASK;\n\n\twhile (!(bdstatus & R_E) && length) {\n\t\tif ((bdstatus & R_F) && (bdstatus & R_L)\n\t\t\t&& !(bdstatus & R_ERROR)) {\n\t\t\tif (length == USB_CRC_SIZE) {\n\t\t\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\t\t\tdev_vdbg(udc->dev,\n\t\t\t\t\t\"receive a ZLP in status phase\\n\");\n\t\t\t} else {\n\t\t\t\tqe_frame_clean(pframe);\n\t\t\t\tvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\n\t\t\t\tframe_set_data(pframe, (u8 *)vaddr);\n\t\t\t\tframe_set_length(pframe,\n\t\t\t\t\t\t(length - USB_CRC_SIZE));\n\t\t\t\tframe_set_status(pframe, FRAME_OK);\n\t\t\t\tswitch (bdstatus & R_PID) {\n\t\t\t\tcase R_PID_SETUP:\n\t\t\t\t\tframe_set_info(pframe, PID_SETUP);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_PID_DATA1:\n\t\t\t\t\tframe_set_info(pframe, PID_DATA1);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tframe_set_info(pframe, PID_DATA0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((bdstatus & R_PID) == R_PID_SETUP)\n\t\t\t\t\tep0_setup_handle(udc);\n\t\t\t\telse\n\t\t\t\t\tqe_ep_rxframe_handle(ep);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(udc->dev, \"The receive frame with error!\\n\");\n\t\t}\n\n\t\t \n\t\trecycle_one_rxbd(ep);\n\n\t\t \n\t\tif (bdstatus & R_W)\n\t\t\tbd = ep->rxbase;\n\t\telse\n\t\t\tbd++;\n\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t\tlength = bdstatus & BD_LENGTH_MASK;\n\n\t}\n\n\tep->n_rxbd = bd;\n\n\treturn 0;\n}\n\nstatic int qe_ep_rxframe_handle(struct qe_ep *ep)\n{\n\tstruct qe_frame *pframe;\n\tu8 framepid = 0;\n\tunsigned int fsize;\n\tu8 *cp;\n\tstruct qe_req *req;\n\n\tpframe = ep->rxframe;\n\n\tif (frame_get_info(pframe) & PID_DATA1)\n\t\tframepid = 0x1;\n\n\tif (framepid != ep->data01) {\n\t\tdev_err(ep->udc->dev, \"the data01 error!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tfsize = frame_get_length(pframe);\n\tif (list_empty(&ep->queue)) {\n\t\tdev_err(ep->udc->dev, \"the %s have no requeue!\\n\", ep->name);\n\t} else {\n\t\treq = list_entry(ep->queue.next, struct qe_req, queue);\n\n\t\tcp = (u8 *)(req->req.buf) + req->req.actual;\n\t\tif (cp) {\n\t\t\tmemcpy(cp, pframe->data, fsize);\n\t\t\treq->req.actual += fsize;\n\t\t\tif ((fsize < ep->ep.maxpacket) ||\n\t\t\t\t\t(req->req.actual >= req->req.length)) {\n\t\t\t\tif (ep->epnum == 0)\n\t\t\t\t\tep0_req_complete(ep->udc, req);\n\t\t\t\telse\n\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\tif (list_empty(&ep->queue) && ep->epnum != 0)\n\t\t\t\t\tqe_eprx_nack(ep);\n\t\t\t}\n\t\t}\n\t}\n\n\tqe_ep_toggledata01(ep);\n\n\treturn 0;\n}\n\nstatic void ep_rx_tasklet(struct tasklet_struct *t)\n{\n\tstruct qe_udc *udc = from_tasklet(udc, t, rx_tasklet);\n\tstruct qe_ep *ep;\n\tstruct qe_frame *pframe;\n\tstruct qe_bd __iomem *bd;\n\tunsigned long flags;\n\tu32 bdstatus, length;\n\tu32 vaddr, i;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tfor (i = 1; i < USB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->eps[i];\n\n\t\tif (ep->dir == USB_DIR_IN || ep->enable_tasklet == 0) {\n\t\t\tdev_dbg(udc->dev,\n\t\t\t\t\"This is a transmit ep or disable tasklet!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tpframe = ep->rxframe;\n\t\tbd = ep->n_rxbd;\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t\tlength = bdstatus & BD_LENGTH_MASK;\n\n\t\twhile (!(bdstatus & R_E) && length) {\n\t\t\tif (list_empty(&ep->queue)) {\n\t\t\t\tqe_eprx_nack(ep);\n\t\t\t\tdev_dbg(udc->dev,\n\t\t\t\t\t\"The rxep have noreq %d\\n\",\n\t\t\t\t\tep->has_data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif ((bdstatus & R_F) && (bdstatus & R_L)\n\t\t\t\t&& !(bdstatus & R_ERROR)) {\n\t\t\t\tqe_frame_clean(pframe);\n\t\t\t\tvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\n\t\t\t\tframe_set_data(pframe, (u8 *)vaddr);\n\t\t\t\tframe_set_length(pframe,\n\t\t\t\t\t\t(length - USB_CRC_SIZE));\n\t\t\t\tframe_set_status(pframe, FRAME_OK);\n\t\t\t\tswitch (bdstatus & R_PID) {\n\t\t\t\tcase R_PID_DATA1:\n\t\t\t\t\tframe_set_info(pframe, PID_DATA1);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_PID_SETUP:\n\t\t\t\t\tframe_set_info(pframe, PID_SETUP);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tframe_set_info(pframe, PID_DATA0);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tqe_ep_rxframe_handle(ep);\n\t\t\t} else {\n\t\t\t\tdev_err(udc->dev,\n\t\t\t\t\t\"error in received frame\\n\");\n\t\t\t}\n\t\t\t \n\t\t\t \n\t\t\tout_be32((u32 __iomem *)bd, bdstatus & BD_STATUS_MASK);\n\t\t\tep->has_data--;\n\t\t\tif (!(ep->localnack))\n\t\t\t\trecycle_one_rxbd(ep);\n\n\t\t\t \n\t\t\tif (bdstatus & R_W)\n\t\t\t\tbd = ep->rxbase;\n\t\t\telse\n\t\t\t\tbd++;\n\n\t\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t\t\tlength = bdstatus & BD_LENGTH_MASK;\n\t\t}\n\n\t\tep->n_rxbd = bd;\n\n\t\tif (ep->localnack)\n\t\t\tep_recycle_rxbds(ep);\n\n\t\tep->enable_tasklet = 0;\n\t}  \n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic int qe_ep_rx(struct qe_ep *ep)\n{\n\tstruct qe_udc *udc;\n\tstruct qe_frame *pframe;\n\tstruct qe_bd __iomem *bd;\n\tu16 swoffs, ucoffs, emptybds;\n\n\tudc = ep->udc;\n\tpframe = ep->rxframe;\n\n\tif (ep->dir == USB_DIR_IN) {\n\t\tdev_err(udc->dev, \"transmit ep in rx function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbd = ep->n_rxbd;\n\n\tswoffs = (u16)(bd - ep->rxbase);\n\tucoffs = (u16)((in_be16(&udc->ep_param[ep->epnum]->rbptr) -\n\t\t\tin_be16(&udc->ep_param[ep->epnum]->rbase)) >> 3);\n\tif (swoffs < ucoffs)\n\t\temptybds = USB_BDRING_LEN_RX - ucoffs + swoffs;\n\telse\n\t\temptybds = swoffs - ucoffs;\n\n\tif (emptybds < MIN_EMPTY_BDS) {\n\t\tqe_eprx_nack(ep);\n\t\tep->localnack = 1;\n\t\tdev_vdbg(udc->dev, \"%d empty bds, send NACK\\n\", emptybds);\n\t}\n\tep->has_data = USB_BDRING_LEN_RX - emptybds;\n\n\tif (list_empty(&ep->queue)) {\n\t\tqe_eprx_nack(ep);\n\t\tdev_vdbg(udc->dev, \"The rxep have no req queued with %d BDs\\n\",\n\t\t\t\tep->has_data);\n\t\treturn 0;\n\t}\n\n\ttasklet_schedule(&udc->rx_tasklet);\n\tep->enable_tasklet = 1;\n\n\treturn 0;\n}\n\n \nstatic int qe_ep_tx(struct qe_ep *ep, struct qe_frame *frame)\n{\n\tstruct qe_udc *udc = ep->udc;\n\tstruct qe_bd __iomem *bd;\n\tu16 saveusbmr;\n\tu32 bdstatus, pidmask;\n\tu32 paddr;\n\n\tif (ep->dir == USB_DIR_OUT) {\n\t\tdev_err(udc->dev, \"receive ep passed to tx function\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsaveusbmr = in_be16(&udc->usb_regs->usb_usbmr);\n\tout_be16(&udc->usb_regs->usb_usbmr,\n\t\t\tsaveusbmr & ~(USB_E_TXB_MASK | USB_E_TXE_MASK));\n\n\tbd = ep->n_txbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\n\tif (!(bdstatus & (T_R | BD_LENGTH_MASK))) {\n\t\tif (frame_get_length(frame) == 0) {\n\t\t\tframe_set_data(frame, udc->nullbuf);\n\t\t\tframe_set_length(frame, 2);\n\t\t\tframe->info |= (ZLP | NO_CRC);\n\t\t\tdev_vdbg(udc->dev, \"the frame size = 0\\n\");\n\t\t}\n\t\tpaddr = virt_to_phys((void *)frame->data);\n\t\tout_be32(&bd->buf, paddr);\n\t\tbdstatus = (bdstatus&T_W);\n\t\tif (!(frame_get_info(frame) & NO_CRC))\n\t\t\tbdstatus |= T_R | T_I | T_L | T_TC\n\t\t\t\t\t| frame_get_length(frame);\n\t\telse\n\t\t\tbdstatus |= T_R | T_I | T_L | frame_get_length(frame);\n\n\t\t \n\t\tif ((ep->epnum == 0) && (udc->ep0_state == DATA_STATE_NEED_ZLP))\n\t\t\tep->data01 = 0x1;\n\n\t\tif (ep->data01) {\n\t\t\tpidmask = T_PID_DATA1;\n\t\t\tframe->info |= PID_DATA1;\n\t\t} else {\n\t\t\tpidmask = T_PID_DATA0;\n\t\t\tframe->info |= PID_DATA0;\n\t\t}\n\t\tbdstatus |= T_CNF;\n\t\tbdstatus |= pidmask;\n\t\tout_be32((u32 __iomem *)bd, bdstatus);\n\t\tqe_ep_filltxfifo(ep);\n\n\t\t \n\t\tout_be16(&udc->usb_regs->usb_usbmr, saveusbmr);\n\n\t\tqe_ep_toggledata01(ep);\n\t\tif (bdstatus & T_W)\n\t\t\tep->n_txbd = ep->txbase;\n\t\telse\n\t\t\tep->n_txbd++;\n\n\t\treturn 0;\n\t} else {\n\t\tout_be16(&udc->usb_regs->usb_usbmr, saveusbmr);\n\t\tdev_vdbg(udc->dev, \"The tx bd is not ready!\\n\");\n\t\treturn -EBUSY;\n\t}\n}\n\n \nstatic int txcomplete(struct qe_ep *ep, unsigned char restart)\n{\n\tif (ep->tx_req != NULL) {\n\t\tstruct qe_req *req = ep->tx_req;\n\t\tunsigned zlp = 0, last_len = 0;\n\n\t\tlast_len = min_t(unsigned, req->req.length - ep->sent,\n\t\t\t\tep->ep.maxpacket);\n\n\t\tif (!restart) {\n\t\t\tint asent = ep->last;\n\t\t\tep->sent += asent;\n\t\t\tep->last -= asent;\n\t\t} else {\n\t\t\tep->last = 0;\n\t\t}\n\n\t\t \n\t\tif (req->req.zero) {\n\t\t\tif (last_len == 0 ||\n\t\t\t\t(req->req.length % ep->ep.maxpacket) != 0)\n\t\t\t\tzlp = 0;\n\t\t\telse\n\t\t\t\tzlp = 1;\n\t\t} else\n\t\t\tzlp = 0;\n\n\t\t \n\t\tif (((ep->tx_req->req.length - ep->sent) <= 0) && !zlp) {\n\t\t\tdone(ep, ep->tx_req, 0);\n\t\t\tep->tx_req = NULL;\n\t\t\tep->last = 0;\n\t\t\tep->sent = 0;\n\t\t}\n\t}\n\n\t \n\tif (ep->tx_req == NULL) {\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\tep->tx_req = list_entry(ep->queue.next,\tstruct qe_req,\n\t\t\t\t\t\t\tqueue);\n\t\t\tep->last = 0;\n\t\t\tep->sent = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int qe_usb_senddata(struct qe_ep *ep, struct qe_frame *frame)\n{\n\tunsigned int size;\n\tu8 *buf;\n\n\tqe_frame_clean(frame);\n\tsize = min_t(u32, (ep->tx_req->req.length - ep->sent),\n\t\t\t\tep->ep.maxpacket);\n\tbuf = (u8 *)ep->tx_req->req.buf + ep->sent;\n\tif (buf && size) {\n\t\tep->last = size;\n\t\tep->tx_req->req.actual += size;\n\t\tframe_set_data(frame, buf);\n\t\tframe_set_length(frame, size);\n\t\tframe_set_status(frame, FRAME_OK);\n\t\tframe_set_info(frame, 0);\n\t\treturn qe_ep_tx(ep, frame);\n\t}\n\treturn -EIO;\n}\n\n \nstatic int sendnulldata(struct qe_ep *ep, struct qe_frame *frame, uint infor)\n{\n\tstruct qe_udc *udc = ep->udc;\n\n\tif (frame == NULL)\n\t\treturn -ENODEV;\n\n\tqe_frame_clean(frame);\n\tframe_set_data(frame, (u8 *)udc->nullbuf);\n\tframe_set_length(frame, 2);\n\tframe_set_status(frame, FRAME_OK);\n\tframe_set_info(frame, (ZLP | NO_CRC | infor));\n\n\treturn qe_ep_tx(ep, frame);\n}\n\nstatic int frame_create_tx(struct qe_ep *ep, struct qe_frame *frame)\n{\n\tstruct qe_req *req = ep->tx_req;\n\tint reval;\n\n\tif (req == NULL)\n\t\treturn -ENODEV;\n\n\tif ((req->req.length - ep->sent) > 0)\n\t\treval = qe_usb_senddata(ep, frame);\n\telse\n\t\treval = sendnulldata(ep, frame, 0);\n\n\treturn reval;\n}\n\n \nstatic int ep0_prime_status(struct qe_udc *udc, int direction)\n{\n\n\tstruct qe_ep *ep = &udc->eps[0];\n\n\tif (direction == USB_DIR_IN) {\n\t\tudc->ep0_state = DATA_STATE_NEED_ZLP;\n\t\tudc->ep0_dir = USB_DIR_IN;\n\t\tsendnulldata(ep, ep->txframe, SETUP_STATUS | NO_REQ);\n\t} else {\n\t\tudc->ep0_dir = USB_DIR_OUT;\n\t\tudc->ep0_state = WAIT_FOR_OUT_STATUS;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ep0_req_complete(struct qe_udc *udc, struct qe_req *req)\n{\n\tstruct qe_ep *ep = &udc->eps[0];\n\t \n\n\tswitch (udc->ep0_state) {\n\tcase DATA_STATE_XMIT:\n\t\tdone(ep, req, 0);\n\t\t \n\t\tif (ep0_prime_status(udc, USB_DIR_OUT))\n\t\t\tqe_ep0_stall(udc);\n\t\tbreak;\n\n\tcase DATA_STATE_NEED_ZLP:\n\t\tdone(ep, req, 0);\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tbreak;\n\n\tcase DATA_STATE_RECV:\n\t\tdone(ep, req, 0);\n\t\t \n\t\tif (ep0_prime_status(udc, USB_DIR_IN))\n\t\t\tqe_ep0_stall(udc);\n\t\tbreak;\n\n\tcase WAIT_FOR_OUT_STATUS:\n\t\tdone(ep, req, 0);\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tbreak;\n\n\tcase WAIT_FOR_SETUP:\n\t\tdev_vdbg(udc->dev, \"Unexpected interrupt\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tqe_ep0_stall(udc);\n\t\tbreak;\n\t}\n}\n\nstatic int ep0_txcomplete(struct qe_ep *ep, unsigned char restart)\n{\n\tstruct qe_req *tx_req = NULL;\n\tstruct qe_frame *frame = ep->txframe;\n\n\tif ((frame_get_info(frame) & (ZLP | NO_REQ)) == (ZLP | NO_REQ)) {\n\t\tif (!restart)\n\t\t\tep->udc->ep0_state = WAIT_FOR_SETUP;\n\t\telse\n\t\t\tsendnulldata(ep, ep->txframe, SETUP_STATUS | NO_REQ);\n\t\treturn 0;\n\t}\n\n\ttx_req = ep->tx_req;\n\tif (tx_req != NULL) {\n\t\tif (!restart) {\n\t\t\tint asent = ep->last;\n\t\t\tep->sent += asent;\n\t\t\tep->last -= asent;\n\t\t} else {\n\t\t\tep->last = 0;\n\t\t}\n\n\t\t \n\t\tif ((ep->tx_req->req.length - ep->sent) <= 0) {\n\t\t\tep->tx_req->req.actual = (unsigned int)ep->sent;\n\t\t\tep0_req_complete(ep->udc, ep->tx_req);\n\t\t\tep->tx_req = NULL;\n\t\t\tep->last = 0;\n\t\t\tep->sent = 0;\n\t\t}\n\t} else {\n\t\tdev_vdbg(ep->udc->dev, \"the ep0_controller have no req\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int ep0_txframe_handle(struct qe_ep *ep)\n{\n\t \n\tif (frame_get_status(ep->txframe) & FRAME_ERROR) {\n\t\tqe_ep_flushtxfifo(ep);\n\t\tdev_vdbg(ep->udc->dev, \"The EP0 transmit data have error!\\n\");\n\t\tif (frame_get_info(ep->txframe) & PID_DATA0)\n\t\t\tep->data01 = 0;\n\t\telse\n\t\t\tep->data01 = 1;\n\n\t\tep0_txcomplete(ep, 1);\n\t} else\n\t\tep0_txcomplete(ep, 0);\n\n\tframe_create_tx(ep, ep->txframe);\n\treturn 0;\n}\n\nstatic int qe_ep0_txconf(struct qe_ep *ep)\n{\n\tstruct qe_bd __iomem *bd;\n\tstruct qe_frame *pframe;\n\tu32 bdstatus;\n\n\tbd = ep->c_txbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\twhile (!(bdstatus & T_R) && (bdstatus & ~T_W)) {\n\t\tpframe = ep->txframe;\n\n\t\t \n\t\tout_be32((u32 __iomem *)bd, bdstatus & T_W);\n\t\tout_be32(&bd->buf, 0);\n\t\tif (bdstatus & T_W)\n\t\t\tep->c_txbd = ep->txbase;\n\t\telse\n\t\t\tep->c_txbd++;\n\n\t\tif (ep->c_txbd == ep->n_txbd) {\n\t\t\tif (bdstatus & DEVICE_T_ERROR) {\n\t\t\t\tframe_set_status(pframe, FRAME_ERROR);\n\t\t\t\tif (bdstatus & T_TO)\n\t\t\t\t\tpframe->status |= TX_ER_TIMEOUT;\n\t\t\t\tif (bdstatus & T_UN)\n\t\t\t\t\tpframe->status |= TX_ER_UNDERUN;\n\t\t\t}\n\t\t\tep0_txframe_handle(ep);\n\t\t}\n\n\t\tbd = ep->c_txbd;\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t}\n\n\treturn 0;\n}\n\nstatic int ep_txframe_handle(struct qe_ep *ep)\n{\n\tif (frame_get_status(ep->txframe) & FRAME_ERROR) {\n\t\tqe_ep_flushtxfifo(ep);\n\t\tdev_vdbg(ep->udc->dev, \"The EP0 transmit data have error!\\n\");\n\t\tif (frame_get_info(ep->txframe) & PID_DATA0)\n\t\t\tep->data01 = 0;\n\t\telse\n\t\t\tep->data01 = 1;\n\n\t\ttxcomplete(ep, 1);\n\t} else\n\t\ttxcomplete(ep, 0);\n\n\tframe_create_tx(ep, ep->txframe);  \n\treturn 0;\n}\n\n \nstatic int qe_ep_txconf(struct qe_ep *ep)\n{\n\tstruct qe_bd __iomem *bd;\n\tstruct qe_frame *pframe = NULL;\n\tu32 bdstatus;\n\tunsigned char breakonrxinterrupt = 0;\n\n\tbd = ep->c_txbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\twhile (!(bdstatus & T_R) && (bdstatus & ~T_W)) {\n\t\tpframe = ep->txframe;\n\t\tif (bdstatus & DEVICE_T_ERROR) {\n\t\t\tframe_set_status(pframe, FRAME_ERROR);\n\t\t\tif (bdstatus & T_TO)\n\t\t\t\tpframe->status |= TX_ER_TIMEOUT;\n\t\t\tif (bdstatus & T_UN)\n\t\t\t\tpframe->status |= TX_ER_UNDERUN;\n\t\t}\n\n\t\t \n\t\tout_be32((u32 __iomem *)bd, bdstatus & T_W);\n\t\tout_be32(&bd->buf, 0);\n\t\tif (bdstatus & T_W)\n\t\t\tep->c_txbd = ep->txbase;\n\t\telse\n\t\t\tep->c_txbd++;\n\n\t\t \n\t\tep_txframe_handle(ep);\n\t\tbd = ep->c_txbd;\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t}\n\tif (breakonrxinterrupt)\n\t\treturn -EIO;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int ep_req_send(struct qe_ep *ep, struct qe_req *req)\n{\n\tint reval = 0;\n\n\tif (ep->tx_req == NULL) {\n\t\tep->sent = 0;\n\t\tep->last = 0;\n\t\ttxcomplete(ep, 0);  \n\t\treval = frame_create_tx(ep, ep->txframe);\n\t}\n\treturn reval;\n}\n\n \nstatic int ep_req_rx(struct qe_ep *ep, struct qe_req *req)\n{\n\tstruct qe_udc *udc = ep->udc;\n\tstruct qe_frame *pframe = NULL;\n\tstruct qe_bd __iomem *bd;\n\tu32 bdstatus, length;\n\tu32 vaddr, fsize;\n\tu8 *cp;\n\tu8 finish_req = 0;\n\tu8 framepid;\n\n\tif (list_empty(&ep->queue)) {\n\t\tdev_vdbg(udc->dev, \"the req already finish!\\n\");\n\t\treturn 0;\n\t}\n\tpframe = ep->rxframe;\n\n\tbd = ep->n_rxbd;\n\tbdstatus = in_be32((u32 __iomem *)bd);\n\tlength = bdstatus & BD_LENGTH_MASK;\n\n\twhile (!(bdstatus & R_E) && length) {\n\t\tif (finish_req)\n\t\t\tbreak;\n\t\tif ((bdstatus & R_F) && (bdstatus & R_L)\n\t\t\t\t\t&& !(bdstatus & R_ERROR)) {\n\t\t\tqe_frame_clean(pframe);\n\t\t\tvaddr = (u32)phys_to_virt(in_be32(&bd->buf));\n\t\t\tframe_set_data(pframe, (u8 *)vaddr);\n\t\t\tframe_set_length(pframe, (length - USB_CRC_SIZE));\n\t\t\tframe_set_status(pframe, FRAME_OK);\n\t\t\tswitch (bdstatus & R_PID) {\n\t\t\tcase R_PID_DATA1:\n\t\t\t\tframe_set_info(pframe, PID_DATA1); break;\n\t\t\tdefault:\n\t\t\t\tframe_set_info(pframe, PID_DATA0); break;\n\t\t\t}\n\t\t\t \n\n\t\t\tif (frame_get_info(pframe) & PID_DATA1)\n\t\t\t\tframepid = 0x1;\n\t\t\telse\n\t\t\t\tframepid = 0;\n\n\t\t\tif (framepid != ep->data01) {\n\t\t\t\tdev_vdbg(udc->dev, \"the data01 error!\\n\");\n\t\t\t} else {\n\t\t\t\tfsize = frame_get_length(pframe);\n\n\t\t\t\tcp = (u8 *)(req->req.buf) + req->req.actual;\n\t\t\t\tif (cp) {\n\t\t\t\t\tmemcpy(cp, pframe->data, fsize);\n\t\t\t\t\treq->req.actual += fsize;\n\t\t\t\t\tif ((fsize < ep->ep.maxpacket)\n\t\t\t\t\t\t|| (req->req.actual >=\n\t\t\t\t\t\t\treq->req.length)) {\n\t\t\t\t\t\tfinish_req = 1;\n\t\t\t\t\t\tdone(ep, req, 0);\n\t\t\t\t\t\tif (list_empty(&ep->queue))\n\t\t\t\t\t\t\tqe_eprx_nack(ep);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tqe_ep_toggledata01(ep);\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(udc->dev, \"The receive frame with error!\\n\");\n\t\t}\n\n\t\t \n\t\tout_be32((u32 __iomem *)bd, (bdstatus & BD_STATUS_MASK));\n\t\tep->has_data--;\n\n\t\t \n\t\tif (bdstatus & R_W)\n\t\t\tbd = ep->rxbase;\n\t\telse\n\t\t\tbd++;\n\n\t\tbdstatus = in_be32((u32 __iomem *)bd);\n\t\tlength = bdstatus & BD_LENGTH_MASK;\n\t}\n\n\tep->n_rxbd = bd;\n\tep_recycle_rxbds(ep);\n\n\treturn 0;\n}\n\n \nstatic int ep_req_receive(struct qe_ep *ep, struct qe_req *req)\n{\n\tif (ep->state == EP_STATE_NACK) {\n\t\tif (ep->has_data <= 0) {\n\t\t\t \n\t\t\tqe_eprx_normal(ep);\n\t\t} else {\n\t\t\t \n\t\t\tep_req_rx(ep, req);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic int qe_ep_enable(struct usb_ep *_ep,\n\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\tstruct qe_udc *udc;\n\tstruct qe_ep *ep;\n\tint retval = 0;\n\tunsigned char epnum;\n\n\tep = container_of(_ep, struct qe_ep, ep);\n\n\t \n\tif (!_ep || !desc || _ep->name == ep_name[0] ||\n\t\t\t(desc->bDescriptorType != USB_DT_ENDPOINT))\n\t\treturn -EINVAL;\n\n\tudc = ep->udc;\n\tif (!udc->driver || (udc->gadget.speed == USB_SPEED_UNKNOWN))\n\t\treturn -ESHUTDOWN;\n\n\tepnum = (u8)desc->bEndpointAddress & 0xF;\n\n\tretval = qe_ep_init(udc, epnum, desc);\n\tif (retval != 0) {\n\t\tcpm_muram_free(cpm_muram_offset(ep->rxbase));\n\t\tdev_dbg(udc->dev, \"enable ep%d failed\\n\", ep->epnum);\n\t\treturn -EINVAL;\n\t}\n\tdev_dbg(udc->dev, \"enable ep%d successful\\n\", ep->epnum);\n\treturn 0;\n}\n\nstatic int qe_ep_disable(struct usb_ep *_ep)\n{\n\tstruct qe_udc *udc;\n\tstruct qe_ep *ep;\n\tunsigned long flags;\n\tunsigned int size;\n\n\tep = container_of(_ep, struct qe_ep, ep);\n\tudc = ep->udc;\n\n\tif (!_ep || !ep->ep.desc) {\n\t\tdev_dbg(udc->dev, \"%s not enabled\\n\", _ep ? ep->ep.name : NULL);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tnuke(ep, -ESHUTDOWN);\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\tep->tx_req = NULL;\n\tqe_ep_reset(udc, ep->epnum);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tcpm_muram_free(cpm_muram_offset(ep->rxbase));\n\n\tif (ep->dir == USB_DIR_OUT)\n\t\tsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) *\n\t\t\t\t(USB_BDRING_LEN_RX + 1);\n\telse\n\t\tsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) *\n\t\t\t\t(USB_BDRING_LEN + 1);\n\n\tif (ep->dir != USB_DIR_IN) {\n\t\tkfree(ep->rxframe);\n\t\tif (ep->rxbufmap) {\n\t\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\t\t\tep->rxbuf_d, size,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tep->rxbuf_d = DMA_ADDR_INVALID;\n\t\t} else {\n\t\t\tdma_sync_single_for_cpu(\n\t\t\t\t\tudc->gadget.dev.parent,\n\t\t\t\t\tep->rxbuf_d, size,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t}\n\t\tkfree(ep->rxbuffer);\n\t}\n\n\tif (ep->dir != USB_DIR_OUT)\n\t\tkfree(ep->txframe);\n\n\tdev_dbg(udc->dev, \"disabled %s OK\\n\", _ep->name);\n\treturn 0;\n}\n\nstatic struct usb_request *qe_alloc_request(struct usb_ep *_ep,\tgfp_t gfp_flags)\n{\n\tstruct qe_req *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->req.dma = DMA_ADDR_INVALID;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void qe_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct qe_req *req;\n\n\treq = container_of(_req, struct qe_req, req);\n\n\tif (_req)\n\t\tkfree(req);\n}\n\nstatic int __qe_ep_queue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\n\tstruct qe_req *req = container_of(_req, struct qe_req, req);\n\tstruct qe_udc *udc;\n\tint reval;\n\n\tudc = ep->udc;\n\t \n\tif (!_req || !req->req.complete || !req->req.buf\n\t\t\t|| !list_empty(&req->queue)) {\n\t\tdev_dbg(udc->dev, \"bad params\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!_ep || (!ep->ep.desc && ep_index(ep))) {\n\t\tdev_dbg(udc->dev, \"bad ep\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\treq->ep = ep;\n\n\t \n\tif (req->req.dma == DMA_ADDR_INVALID) {\n\t\treq->req.dma = dma_map_single(ep->udc->gadget.dev.parent,\n\t\t\t\t\treq->req.buf,\n\t\t\t\t\treq->req.length,\n\t\t\t\t\tep_is_in(ep)\n\t\t\t\t\t? DMA_TO_DEVICE :\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\treq->mapped = 1;\n\t} else {\n\t\tdma_sync_single_for_device(ep->udc->gadget.dev.parent,\n\t\t\t\t\treq->req.dma, req->req.length,\n\t\t\t\t\tep_is_in(ep)\n\t\t\t\t\t? DMA_TO_DEVICE :\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\treq->mapped = 0;\n\t}\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\tdev_vdbg(udc->dev, \"gadget have request in %s! %d\\n\",\n\t\t\tep->name, req->req.length);\n\n\t \n\tif (ep_is_in(ep))\n\t\treval = ep_req_send(ep, req);\n\n\t \n\tif (ep_index(ep) == 0 && req->req.length > 0) {\n\t\tif (ep_is_in(ep))\n\t\t\tudc->ep0_state = DATA_STATE_XMIT;\n\t\telse\n\t\t\tudc->ep0_state = DATA_STATE_RECV;\n\t}\n\n\tif (ep->dir == USB_DIR_OUT)\n\t\treval = ep_req_receive(ep, req);\n\n\treturn 0;\n}\n\n \nstatic int qe_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t       gfp_t gfp_flags)\n{\n\tstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\n\tstruct qe_udc *udc = ep->udc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tret = __qe_ep_queue(_ep, _req);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\n \nstatic int qe_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct qe_ep *ep = container_of(_ep, struct qe_ep, ep);\n\tstruct qe_req *req = NULL;\n\tstruct qe_req *iter;\n\tunsigned long flags;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\n\tif (!req) {\n\t\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tdone(ep, req, -ECONNRESET);\n\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic int qe_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct qe_ep *ep;\n\tunsigned long flags;\n\tint status = -EOPNOTSUPP;\n\tstruct qe_udc *udc;\n\n\tep = container_of(_ep, struct qe_ep, ep);\n\tif (!_ep || !ep->ep.desc) {\n\t\tstatus = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tudc = ep->udc;\n\t \n\tif (value && ep_is_in(ep) && !list_empty(&ep->queue)) {\n\t\tstatus = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tstatus = 0;\n\tspin_lock_irqsave(&ep->udc->lock, flags);\n\tqe_eptx_stall_change(ep, value);\n\tqe_eprx_stall_change(ep, value);\n\tspin_unlock_irqrestore(&ep->udc->lock, flags);\n\n\tif (ep->epnum == 0) {\n\t\tudc->ep0_state = WAIT_FOR_SETUP;\n\t\tudc->ep0_dir = 0;\n\t}\n\n\t \n\tif (value == 0)\n\t\tep->data01 = 0;\nout:\n\tdev_vdbg(udc->dev, \"%s %s halt stat %d\\n\", ep->ep.name,\n\t\t\tvalue ?  \"set\" : \"clear\", status);\n\n\treturn status;\n}\n\nstatic const struct usb_ep_ops qe_ep_ops = {\n\t.enable = qe_ep_enable,\n\t.disable = qe_ep_disable,\n\n\t.alloc_request = qe_alloc_request,\n\t.free_request = qe_free_request,\n\n\t.queue = qe_ep_queue,\n\t.dequeue = qe_ep_dequeue,\n\n\t.set_halt = qe_ep_set_halt,\n};\n\n \n\n \nstatic int qe_get_frame(struct usb_gadget *gadget)\n{\n\tstruct qe_udc *udc = container_of(gadget, struct qe_udc, gadget);\n\tu16 tmp;\n\n\ttmp = in_be16(&udc->usb_param->frame_n);\n\tif (tmp & 0x8000)\n\t\treturn tmp & 0x07ff;\n\treturn -EINVAL;\n}\n\nstatic int fsl_qe_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver);\nstatic int fsl_qe_stop(struct usb_gadget *gadget);\n\n \nstatic const struct usb_gadget_ops qe_gadget_ops = {\n\t.get_frame = qe_get_frame,\n\t.udc_start = fsl_qe_start,\n\t.udc_stop = fsl_qe_stop,\n};\n\n \nstatic int udc_reset_ep_queue(struct qe_udc *udc, u8 pipe)\n{\n\tstruct qe_ep *ep = &udc->eps[pipe];\n\n\tnuke(ep, -ECONNRESET);\n\tep->tx_req = NULL;\n\treturn 0;\n}\n\nstatic int reset_queues(struct qe_udc *udc)\n{\n\tu8 pipe;\n\n\tfor (pipe = 0; pipe < USB_MAX_ENDPOINTS; pipe++)\n\t\tudc_reset_ep_queue(udc, pipe);\n\n\t \n\tspin_unlock(&udc->lock);\n\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\tspin_lock(&udc->lock);\n\n\treturn 0;\n}\n\nstatic void ch9setaddress(struct qe_udc *udc, u16 value, u16 index,\n\t\t\tu16 length)\n{\n\t \n\tudc->device_address = (u8) value;\n\t \n\tudc->usb_state = USB_STATE_ADDRESS;\n\n\t \n\tif (ep0_prime_status(udc, USB_DIR_IN))\n\t\tqe_ep0_stall(udc);\n}\n\nstatic void ownercomplete(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct qe_req *req = container_of(_req, struct qe_req, req);\n\n\treq->req.buf = NULL;\n\tkfree(req);\n}\n\nstatic void ch9getstatus(struct qe_udc *udc, u8 request_type, u16 value,\n\t\t\tu16 index, u16 length)\n{\n\tu16 usb_status = 0;\n\tstruct qe_req *req;\n\tstruct qe_ep *ep;\n\tint status = 0;\n\n\tep = &udc->eps[0];\n\tif ((request_type & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\n\t\t \n\t\tusb_status = 1 << USB_DEVICE_SELF_POWERED;\n\t} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_INTERFACE) {\n\t\t \n\t\t \n\t\tusb_status = 0;\n\t} else if ((request_type & USB_RECIP_MASK) == USB_RECIP_ENDPOINT) {\n\t\t \n\t\tint pipe = index & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (pipe >= USB_MAX_ENDPOINTS)\n\t\t\tgoto stall;\n\t\tstruct qe_ep *target_ep = &udc->eps[pipe];\n\t\tu16 usep;\n\n\t\t \n\t\tif (!target_ep->ep.desc)\n\t\t\tgoto stall;\n\n\t\tusep = in_be16(&udc->usb_regs->usb_usep[pipe]);\n\t\tif (index & USB_DIR_IN) {\n\t\t\tif (target_ep->dir != USB_DIR_IN)\n\t\t\t\tgoto stall;\n\t\t\tif ((usep & USB_THS_MASK) == USB_THS_STALL)\n\t\t\t\tusb_status = 1 << USB_ENDPOINT_HALT;\n\t\t} else {\n\t\t\tif (target_ep->dir != USB_DIR_OUT)\n\t\t\t\tgoto stall;\n\t\t\tif ((usep & USB_RHS_MASK) == USB_RHS_STALL)\n\t\t\t\tusb_status = 1 << USB_ENDPOINT_HALT;\n\t\t}\n\t}\n\n\treq = container_of(qe_alloc_request(&ep->ep, GFP_KERNEL),\n\t\t\t\t\tstruct qe_req, req);\n\treq->req.length = 2;\n\treq->req.buf = udc->statusbuf;\n\t*(u16 *)req->req.buf = cpu_to_le16(usb_status);\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\treq->req.complete = ownercomplete;\n\n\tudc->ep0_dir = USB_DIR_IN;\n\n\t \n\tstatus = __qe_ep_queue(&ep->ep, &req->req);\n\n\tif (status == 0)\n\t\treturn;\nstall:\n\tdev_err(udc->dev, \"Can't respond to getstatus request \\n\");\n\tqe_ep0_stall(udc);\n}\n\n \nstatic void setup_received_handle(struct qe_udc *udc,\n\t\t\t\tstruct usb_ctrlrequest *setup)\n{\n\t \n\tu16 wValue = le16_to_cpu(setup->wValue);\n\tu16 wIndex = le16_to_cpu(setup->wIndex);\n\tu16 wLength = le16_to_cpu(setup->wLength);\n\n\t \n\tudc_reset_ep_queue(udc, 0);\n\n\tif (setup->bRequestType & USB_DIR_IN)\n\t\tudc->ep0_dir = USB_DIR_IN;\n\telse\n\t\tudc->ep0_dir = USB_DIR_OUT;\n\n\tswitch (setup->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\t \n\t\tif ((setup->bRequestType & (USB_DIR_IN | USB_TYPE_MASK))\n\t\t\t\t\t!= (USB_DIR_IN | USB_TYPE_STANDARD))\n\t\t\tbreak;\n\t\tch9getstatus(udc, setup->bRequestType, wValue, wIndex,\n\t\t\t\t\twLength);\n\t\treturn;\n\n\tcase USB_REQ_SET_ADDRESS:\n\t\t \n\t\tif (setup->bRequestType != (USB_DIR_OUT | USB_TYPE_STANDARD |\n\t\t\t\t\t\tUSB_RECIP_DEVICE))\n\t\t\tbreak;\n\t\tch9setaddress(udc, wValue, wIndex, wLength);\n\t\treturn;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\tcase USB_REQ_SET_FEATURE:\n\t\t \n\t\tif ((setup->bRequestType & USB_TYPE_MASK)\n\t\t\t\t\t!= USB_TYPE_STANDARD)\n\t\t\tbreak;\n\n\t\tif ((setup->bRequestType & USB_RECIP_MASK)\n\t\t\t\t== USB_RECIP_ENDPOINT) {\n\t\t\tint pipe = wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\t\tstruct qe_ep *ep;\n\n\t\t\tif (wValue != 0 || wLength != 0\n\t\t\t\t|| pipe >= USB_MAX_ENDPOINTS)\n\t\t\t\tbreak;\n\t\t\tep = &udc->eps[pipe];\n\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tqe_ep_set_halt(&ep->ep,\n\t\t\t\t\t(setup->bRequest == USB_REQ_SET_FEATURE)\n\t\t\t\t\t\t? 1 : 0);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\n\t\tep0_prime_status(udc, USB_DIR_IN);\n\n\t\treturn;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (wLength) {\n\t\t \n\t\tif (setup->bRequestType & USB_DIR_IN) {\n\t\t\tudc->ep0_state = DATA_STATE_XMIT;\n\t\t\tudc->ep0_dir = USB_DIR_IN;\n\t\t} else {\n\t\t\tudc->ep0_state = DATA_STATE_RECV;\n\t\t\tudc->ep0_dir = USB_DIR_OUT;\n\t\t}\n\t\tspin_unlock(&udc->lock);\n\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\tqe_ep0_stall(udc);\n\t\tspin_lock(&udc->lock);\n\t} else {\n\t\t \n\t\tudc->ep0_dir = USB_DIR_IN;\n\t\tspin_unlock(&udc->lock);\n\t\tif (udc->driver->setup(&udc->gadget,\n\t\t\t\t\t&udc->local_setup_buff) < 0)\n\t\t\tqe_ep0_stall(udc);\n\t\tspin_lock(&udc->lock);\n\t\tudc->ep0_state = DATA_STATE_NEED_ZLP;\n\t}\n}\n\n \nstatic void suspend_irq(struct qe_udc *udc)\n{\n\tudc->resume_state = udc->usb_state;\n\tudc->usb_state = USB_STATE_SUSPENDED;\n\n\t \n\tif (udc->driver->suspend)\n\t\tudc->driver->suspend(&udc->gadget);\n}\n\nstatic void resume_irq(struct qe_udc *udc)\n{\n\tudc->usb_state = udc->resume_state;\n\tudc->resume_state = 0;\n\n\t \n\tif (udc->driver->resume)\n\t\tudc->driver->resume(&udc->gadget);\n}\n\nstatic void idle_irq(struct qe_udc *udc)\n{\n\tu8 usbs;\n\n\tusbs = in_8(&udc->usb_regs->usb_usbs);\n\tif (usbs & USB_IDLE_STATUS_MASK) {\n\t\tif ((udc->usb_state) != USB_STATE_SUSPENDED)\n\t\t\tsuspend_irq(udc);\n\t} else {\n\t\tif (udc->usb_state == USB_STATE_SUSPENDED)\n\t\t\tresume_irq(udc);\n\t}\n}\n\nstatic int reset_irq(struct qe_udc *udc)\n{\n\tunsigned char i;\n\n\tif (udc->usb_state == USB_STATE_DEFAULT)\n\t\treturn 0;\n\n\tqe_usb_disable(udc);\n\tout_8(&udc->usb_regs->usb_usadr, 0);\n\n\tfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\n\t\tif (udc->eps[i].init)\n\t\t\tqe_ep_reset(udc, i);\n\t}\n\n\treset_queues(udc);\n\tudc->usb_state = USB_STATE_DEFAULT;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = USB_DIR_OUT;\n\tqe_usb_enable(udc);\n\treturn 0;\n}\n\nstatic int bsy_irq(struct qe_udc *udc)\n{\n\treturn 0;\n}\n\nstatic int txe_irq(struct qe_udc *udc)\n{\n\treturn 0;\n}\n\n \nstatic int tx_irq(struct qe_udc *udc)\n{\n\tstruct qe_ep *ep;\n\tstruct qe_bd __iomem *bd;\n\tint i, res = 0;\n\n\tif ((udc->usb_state == USB_STATE_ADDRESS)\n\t\t&& (in_8(&udc->usb_regs->usb_usadr) == 0))\n\t\tout_8(&udc->usb_regs->usb_usadr, udc->device_address);\n\n\tfor (i = (USB_MAX_ENDPOINTS-1); ((i >= 0) && (res == 0)); i--) {\n\t\tep = &udc->eps[i];\n\t\tif (ep && ep->init && (ep->dir != USB_DIR_OUT)) {\n\t\t\tbd = ep->c_txbd;\n\t\t\tif (!(in_be32((u32 __iomem *)bd) & T_R)\n\t\t\t\t\t\t&& (in_be32(&bd->buf))) {\n\t\t\t\t \n\t\t\t\tif (ep->epnum == 0)\n\t\t\t\t\tres = qe_ep0_txconf(ep);\n\t\t\t\telse\n\t\t\t\t\tres = qe_ep_txconf(ep);\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\n \nstatic void rx_irq(struct qe_udc *udc)\n{\n\tstruct qe_ep *ep;\n\tstruct qe_bd __iomem *bd;\n\tint i;\n\n\tfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\n\t\tep = &udc->eps[i];\n\t\tif (ep && ep->init && (ep->dir != USB_DIR_IN)) {\n\t\t\tbd = ep->n_rxbd;\n\t\t\tif (!(in_be32((u32 __iomem *)bd) & R_E)\n\t\t\t\t\t\t&& (in_be32(&bd->buf))) {\n\t\t\t\tif (ep->epnum == 0) {\n\t\t\t\t\tqe_ep0_rx(udc);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tqe_ep_rx(ep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic irqreturn_t qe_udc_irq(int irq, void *_udc)\n{\n\tstruct qe_udc *udc = (struct qe_udc *)_udc;\n\tu16 irq_src;\n\tirqreturn_t status = IRQ_NONE;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tirq_src = in_be16(&udc->usb_regs->usb_usber) &\n\t\tin_be16(&udc->usb_regs->usb_usbmr);\n\t \n\tout_be16(&udc->usb_regs->usb_usber, irq_src);\n\t \n\tif (irq_src & USB_E_IDLE_MASK) {\n\t\tidle_irq(udc);\n\t\tirq_src &= ~USB_E_IDLE_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & USB_E_TXB_MASK) {\n\t\ttx_irq(udc);\n\t\tirq_src &= ~USB_E_TXB_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & USB_E_RXB_MASK) {\n\t\trx_irq(udc);\n\t\tirq_src &= ~USB_E_RXB_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & USB_E_RESET_MASK) {\n\t\treset_irq(udc);\n\t\tirq_src &= ~USB_E_RESET_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & USB_E_BSY_MASK) {\n\t\tbsy_irq(udc);\n\t\tirq_src &= ~USB_E_BSY_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tif (irq_src & USB_E_TXE_MASK) {\n\t\ttxe_irq(udc);\n\t\tirq_src &= ~USB_E_TXE_MASK;\n\t\tstatus = IRQ_HANDLED;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn status;\n}\n\n \nstatic int fsl_qe_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct qe_udc *udc;\n\tunsigned long flags;\n\n\tudc = container_of(gadget, struct qe_udc, gadget);\n\t \n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tudc->driver = driver;\n\tudc->gadget.speed = driver->max_speed;\n\n\t \n\tqe_usb_enable(udc);\n\n\tout_be16(&udc->usb_regs->usb_usber, 0xffff);\n\tout_be16(&udc->usb_regs->usb_usbmr, USB_E_DEFAULT_DEVICE);\n\tudc->usb_state = USB_STATE_ATTACHED;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = USB_DIR_OUT;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int fsl_qe_stop(struct usb_gadget *gadget)\n{\n\tstruct qe_udc *udc;\n\tstruct qe_ep *loop_ep;\n\tunsigned long flags;\n\n\tudc = container_of(gadget, struct qe_udc, gadget);\n\t \n\tqe_usb_disable(udc);\n\n\t \n\tudc->usb_state = USB_STATE_ATTACHED;\n\tudc->ep0_state = WAIT_FOR_SETUP;\n\tudc->ep0_dir = 0;\n\n\t \n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tnuke(&udc->eps[0], -ESHUTDOWN);\n\tlist_for_each_entry(loop_ep, &udc->gadget.ep_list, ep.ep_list)\n\t\tnuke(loop_ep, -ESHUTDOWN);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tudc->driver = NULL;\n\n\treturn 0;\n}\n\n \nstatic struct qe_udc *qe_udc_config(struct platform_device *ofdev)\n{\n\tstruct qe_udc *udc;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tunsigned long tmp_addr = 0;\n\tstruct usb_device_para __iomem *usbpram;\n\tunsigned int i;\n\tu64 size;\n\tu32 offset;\n\n\tudc = kzalloc(sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\tgoto cleanup;\n\n\tudc->dev = &ofdev->dev;\n\n\t \n\toffset = *of_get_address(np, 1, &size, NULL);\n\tudc->usb_param = cpm_muram_addr(offset);\n\tmemset_io(udc->usb_param, 0, size);\n\n\tusbpram = udc->usb_param;\n\tout_be16(&usbpram->frame_n, 0);\n\tout_be32(&usbpram->rstate, 0);\n\n\ttmp_addr = cpm_muram_alloc((USB_MAX_ENDPOINTS *\n\t\t\t\t\tsizeof(struct usb_ep_para)),\n\t\t\t\t\t   USB_EP_PARA_ALIGNMENT);\n\tif (IS_ERR_VALUE(tmp_addr))\n\t\tgoto cleanup;\n\n\tfor (i = 0; i < USB_MAX_ENDPOINTS; i++) {\n\t\tout_be16(&usbpram->epptr[i], (u16)tmp_addr);\n\t\tudc->ep_param[i] = cpm_muram_addr(tmp_addr);\n\t\ttmp_addr += 32;\n\t}\n\n\tmemset_io(udc->ep_param[0], 0,\n\t\t\tUSB_MAX_ENDPOINTS * sizeof(struct usb_ep_para));\n\n\tudc->resume_state = USB_STATE_NOTATTACHED;\n\tudc->usb_state = USB_STATE_POWERED;\n\tudc->ep0_dir = 0;\n\n\tspin_lock_init(&udc->lock);\n\treturn udc;\n\ncleanup:\n\tkfree(udc);\n\treturn NULL;\n}\n\n \nstatic int qe_udc_reg_init(struct qe_udc *udc)\n{\n\tstruct usb_ctlr __iomem *qe_usbregs;\n\tqe_usbregs = udc->usb_regs;\n\n\t \n\tout_8(&qe_usbregs->usb_usmod, 0x01);\n\t \n\tout_8(&qe_usbregs->usb_usmod, 0x00);\n\n\t \n\tout_be16(&qe_usbregs->usb_usbmr, 0);\n\tout_8(&qe_usbregs->usb_uscom, 0);\n\tout_be16(&qe_usbregs->usb_usber, USBER_ALL_CLEAR);\n\n\treturn 0;\n}\n\nstatic int qe_ep_config(struct qe_udc *udc, unsigned char pipe_num)\n{\n\tstruct qe_ep *ep = &udc->eps[pipe_num];\n\n\tep->udc = udc;\n\tstrcpy(ep->name, ep_name[pipe_num]);\n\tep->ep.name = ep_name[pipe_num];\n\n\tif (pipe_num == 0) {\n\t\tep->ep.caps.type_control = true;\n\t} else {\n\t\tep->ep.caps.type_iso = true;\n\t\tep->ep.caps.type_bulk = true;\n\t\tep->ep.caps.type_int = true;\n\t}\n\n\tep->ep.caps.dir_in = true;\n\tep->ep.caps.dir_out = true;\n\n\tep->ep.ops = &qe_ep_ops;\n\tep->stopped = 1;\n\tusb_ep_set_maxpacket_limit(&ep->ep, (unsigned short) ~0);\n\tep->ep.desc = NULL;\n\tep->dir = 0xff;\n\tep->epnum = (u8)pipe_num;\n\tep->sent = 0;\n\tep->last = 0;\n\tep->init = 0;\n\tep->rxframe = NULL;\n\tep->txframe = NULL;\n\tep->tx_req = NULL;\n\tep->state = EP_STATE_IDLE;\n\tep->has_data = 0;\n\n\t \n\tINIT_LIST_HEAD(&ep->queue);\n\n\t \n\tif (pipe_num != 0)\n\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\n\tep->gadget = &udc->gadget;\n\n\treturn 0;\n}\n\n \nstatic void qe_udc_release(struct device *dev)\n{\n\tstruct qe_udc *udc = container_of(dev, struct qe_udc, gadget.dev);\n\tint i;\n\n\tcomplete(udc->done);\n\tcpm_muram_free(cpm_muram_offset(udc->ep_param[0]));\n\tfor (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\t\tudc->ep_param[i] = NULL;\n\n\tkfree(udc);\n}\n\n \nstatic const struct of_device_id qe_udc_match[];\nstatic int qe_udc_probe(struct platform_device *ofdev)\n{\n\tstruct qe_udc *udc;\n\tconst struct of_device_id *match;\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct qe_ep *ep;\n\tunsigned int ret = 0;\n\tunsigned int i;\n\tconst void *prop;\n\n\tmatch = of_match_device(qe_udc_match, &ofdev->dev);\n\tif (!match)\n\t\treturn -EINVAL;\n\n\tprop = of_get_property(np, \"mode\", NULL);\n\tif (!prop || strcmp(prop, \"peripheral\"))\n\t\treturn -ENODEV;\n\n\t \n\tudc = qe_udc_config(ofdev);\n\tif (!udc) {\n\t\tdev_err(&ofdev->dev, \"failed to initialize\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tudc->soc_type = (unsigned long)match->data;\n\tudc->usb_regs = of_iomap(np, 0);\n\tif (!udc->usb_regs) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\t \n\tqe_udc_reg_init(udc);\n\n\t \n\tudc->gadget.ops = &qe_gadget_ops;\n\n\t \n\tudc->gadget.ep0 = &udc->eps[0].ep;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\t \n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tudc->gadget.name = driver_name;\n\tudc->gadget.dev.parent = &ofdev->dev;\n\n\t \n\tfor (i = 0; i < USB_MAX_ENDPOINTS ; i++) {\n\t\t \n\n\t\t \n\t\tqe_ep_config(udc, (unsigned char)i);\n\t}\n\n\t \n\tret = qe_ep_init(udc, 0, &qe_ep0_desc);\n\tif (ret)\n\t\tgoto err2;\n\n\t \n\tudc->nullbuf = devm_kzalloc(&ofdev->dev, 256, GFP_KERNEL);\n\tif (udc->nullbuf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err3;\n\t}\n\n\t \n\tudc->statusbuf = devm_kzalloc(&ofdev->dev, 2, GFP_KERNEL);\n\tif (udc->statusbuf == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err3;\n\t}\n\n\tudc->nullp = virt_to_phys((void *)udc->nullbuf);\n\tif (udc->nullp == DMA_ADDR_INVALID) {\n\t\tudc->nullp = dma_map_single(\n\t\t\t\t\tudc->gadget.dev.parent,\n\t\t\t\t\tudc->nullbuf,\n\t\t\t\t\t256,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\tudc->nullmap = 1;\n\t} else {\n\t\tdma_sync_single_for_device(udc->gadget.dev.parent,\n\t\t\t\t\tudc->nullp, 256,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t}\n\n\ttasklet_setup(&udc->rx_tasklet, ep_rx_tasklet);\n\t \n\tudc->usb_irq = irq_of_parse_and_map(np, 0);\n\tif (!udc->usb_irq) {\n\t\tret = -EINVAL;\n\t\tgoto err_noirq;\n\t}\n\n\tret = request_irq(udc->usb_irq, qe_udc_irq, 0,\n\t\t\t\tdriver_name, udc);\n\tif (ret) {\n\t\tdev_err(udc->dev, \"cannot request irq %d err %d\\n\",\n\t\t\t\tudc->usb_irq, ret);\n\t\tgoto err4;\n\t}\n\n\tret = usb_add_gadget_udc_release(&ofdev->dev, &udc->gadget,\n\t\t\tqe_udc_release);\n\tif (ret)\n\t\tgoto err5;\n\n\tplatform_set_drvdata(ofdev, udc);\n\tdev_info(udc->dev,\n\t\t\t\"%s USB controller initialized as device\\n\",\n\t\t\t(udc->soc_type == PORT_QE) ? \"QE\" : \"CPM\");\n\treturn 0;\n\nerr5:\n\tfree_irq(udc->usb_irq, udc);\nerr4:\n\tirq_dispose_mapping(udc->usb_irq);\nerr_noirq:\n\tif (udc->nullmap) {\n\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\tudc->nullp, 256,\n\t\t\t\tDMA_TO_DEVICE);\n\t\t\tudc->nullp = DMA_ADDR_INVALID;\n\t} else {\n\t\tdma_sync_single_for_cpu(udc->gadget.dev.parent,\n\t\t\tudc->nullp, 256,\n\t\t\t\tDMA_TO_DEVICE);\n\t}\nerr3:\n\tep = &udc->eps[0];\n\tcpm_muram_free(cpm_muram_offset(ep->rxbase));\n\tkfree(ep->rxframe);\n\tkfree(ep->rxbuffer);\n\tkfree(ep->txframe);\nerr2:\n\tiounmap(udc->usb_regs);\nerr1:\n\tkfree(udc);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic int qe_udc_suspend(struct platform_device *dev, pm_message_t state)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int qe_udc_resume(struct platform_device *dev)\n{\n\treturn -ENOTSUPP;\n}\n#endif\n\nstatic void qe_udc_remove(struct platform_device *ofdev)\n{\n\tstruct qe_udc *udc = platform_get_drvdata(ofdev);\n\tstruct qe_ep *ep;\n\tunsigned int size;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\n\tudc->done = &done;\n\ttasklet_disable(&udc->rx_tasklet);\n\n\tif (udc->nullmap) {\n\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\tudc->nullp, 256,\n\t\t\t\tDMA_TO_DEVICE);\n\t\t\tudc->nullp = DMA_ADDR_INVALID;\n\t} else {\n\t\tdma_sync_single_for_cpu(udc->gadget.dev.parent,\n\t\t\tudc->nullp, 256,\n\t\t\t\tDMA_TO_DEVICE);\n\t}\n\n\tep = &udc->eps[0];\n\tcpm_muram_free(cpm_muram_offset(ep->rxbase));\n\tsize = (ep->ep.maxpacket + USB_CRC_SIZE + 2) * (USB_BDRING_LEN + 1);\n\n\tkfree(ep->rxframe);\n\tif (ep->rxbufmap) {\n\t\tdma_unmap_single(udc->gadget.dev.parent,\n\t\t\t\tep->rxbuf_d, size,\n\t\t\t\tDMA_FROM_DEVICE);\n\t\tep->rxbuf_d = DMA_ADDR_INVALID;\n\t} else {\n\t\tdma_sync_single_for_cpu(udc->gadget.dev.parent,\n\t\t\t\tep->rxbuf_d, size,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tkfree(ep->rxbuffer);\n\tkfree(ep->txframe);\n\n\tfree_irq(udc->usb_irq, udc);\n\tirq_dispose_mapping(udc->usb_irq);\n\n\ttasklet_kill(&udc->rx_tasklet);\n\n\tiounmap(udc->usb_regs);\n\n\t \n\twait_for_completion(&done);\n}\n\n \nstatic const struct of_device_id qe_udc_match[] = {\n\t{\n\t\t.compatible = \"fsl,mpc8323-qe-usb\",\n\t\t.data = (void *)PORT_QE,\n\t},\n\t{\n\t\t.compatible = \"fsl,mpc8360-qe-usb\",\n\t\t.data = (void *)PORT_QE,\n\t},\n\t{\n\t\t.compatible = \"fsl,mpc8272-cpm-usb\",\n\t\t.data = (void *)PORT_CPM,\n\t},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, qe_udc_match);\n\nstatic struct platform_driver udc_driver = {\n\t.driver = {\n\t\t.name = driver_name,\n\t\t.of_match_table = qe_udc_match,\n\t},\n\t.probe          = qe_udc_probe,\n\t.remove_new     = qe_udc_remove,\n#ifdef CONFIG_PM\n\t.suspend        = qe_udc_suspend,\n\t.resume         = qe_udc_resume,\n#endif\n};\n\nmodule_platform_driver(udc_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}