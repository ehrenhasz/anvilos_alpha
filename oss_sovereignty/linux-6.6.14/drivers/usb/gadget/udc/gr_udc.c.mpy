{
  "module_name": "gr_udc.c",
  "hash_id": "cd8fe3997dfdf909c15aea4fbbda037c78c9a79083ab00be58fd76a4b26f4106",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/gr_udc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/of.h>\n\n#include <asm/byteorder.h>\n\n#include \"gr_udc.h\"\n\n#define\tDRIVER_NAME\t\"gr_udc\"\n#define\tDRIVER_DESC\t\"Aeroflex Gaisler GRUSBDC USB Peripheral Controller\"\n\nstatic const char driver_name[] = DRIVER_NAME;\n\n#define gr_read32(x) (ioread32be((x)))\n#define gr_write32(x, v) (iowrite32be((v), (x)))\n\n \n#define GR_SPEED(status) \\\n\t((status & GR_STATUS_SP) ? USB_SPEED_FULL : USB_SPEED_HIGH)\n#define GR_SPEED_STR(status) usb_speed_string(GR_SPEED(status))\n\n \n#define GR_BUFFER_SIZE(epctrl)\t\t\t\t\t      \\\n\t((((epctrl) & GR_EPCTRL_BUFSZ_MASK) >> GR_EPCTRL_BUFSZ_POS) * \\\n\t GR_EPCTRL_BUFSZ_SCALER)\n\n \n \n\nstatic const char * const gr_modestring[] = {\"control\", \"iso\", \"bulk\", \"int\"};\n\nstatic const char *gr_ep0state_string(enum gr_ep0state state)\n{\n\tstatic const char *const names[] = {\n\t\t[GR_EP0_DISCONNECT] = \"disconnect\",\n\t\t[GR_EP0_SETUP] = \"setup\",\n\t\t[GR_EP0_IDATA] = \"idata\",\n\t\t[GR_EP0_ODATA] = \"odata\",\n\t\t[GR_EP0_ISTATUS] = \"istatus\",\n\t\t[GR_EP0_OSTATUS] = \"ostatus\",\n\t\t[GR_EP0_STALL] = \"stall\",\n\t\t[GR_EP0_SUSPEND] = \"suspend\",\n\t};\n\n\tif (state < 0 || state >= ARRAY_SIZE(names))\n\t\treturn \"UNKNOWN\";\n\n\treturn names[state];\n}\n\n#ifdef VERBOSE_DEBUG\n\nstatic void gr_dbgprint_request(const char *str, struct gr_ep *ep,\n\t\t\t\tstruct gr_request *req)\n{\n\tint buflen = ep->is_in ? req->req.length : req->req.actual;\n\tint rowlen = 32;\n\tint plen = min(rowlen, buflen);\n\n\tdev_dbg(ep->dev->dev, \"%s: 0x%p, %d bytes data%s:\\n\", str, req, buflen,\n\t\t(buflen > plen ? \" (truncated)\" : \"\"));\n\tprint_hex_dump_debug(\"   \", DUMP_PREFIX_NONE,\n\t\t\t     rowlen, 4, req->req.buf, plen, false);\n}\n\nstatic void gr_dbgprint_devreq(struct gr_udc *dev, u8 type, u8 request,\n\t\t\t       u16 value, u16 index, u16 length)\n{\n\tdev_vdbg(dev->dev, \"REQ: %02x.%02x v%04x i%04x l%04x\\n\",\n\t\t type, request, value, index, length);\n}\n#else  \n\nstatic void gr_dbgprint_request(const char *str, struct gr_ep *ep,\n\t\t\t\tstruct gr_request *req) {}\n\nstatic void gr_dbgprint_devreq(struct gr_udc *dev, u8 type, u8 request,\n\t\t\t       u16 value, u16 index, u16 length) {}\n\n#endif  \n\n \n \n\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\n\nstatic void gr_seq_ep_show(struct seq_file *seq, struct gr_ep *ep)\n{\n\tu32 epctrl = gr_read32(&ep->regs->epctrl);\n\tu32 epstat = gr_read32(&ep->regs->epstat);\n\tint mode = (epctrl & GR_EPCTRL_TT_MASK) >> GR_EPCTRL_TT_POS;\n\tstruct gr_request *req;\n\n\tseq_printf(seq, \"%s:\\n\", ep->ep.name);\n\tseq_printf(seq, \"  mode = %s\\n\", gr_modestring[mode]);\n\tseq_printf(seq, \"  halted: %d\\n\", !!(epctrl & GR_EPCTRL_EH));\n\tseq_printf(seq, \"  disabled: %d\\n\", !!(epctrl & GR_EPCTRL_ED));\n\tseq_printf(seq, \"  valid: %d\\n\", !!(epctrl & GR_EPCTRL_EV));\n\tseq_printf(seq, \"  dma_start = %d\\n\", ep->dma_start);\n\tseq_printf(seq, \"  stopped = %d\\n\", ep->stopped);\n\tseq_printf(seq, \"  wedged = %d\\n\", ep->wedged);\n\tseq_printf(seq, \"  callback = %d\\n\", ep->callback);\n\tseq_printf(seq, \"  maxpacket = %d\\n\", ep->ep.maxpacket);\n\tseq_printf(seq, \"  maxpacket_limit = %d\\n\", ep->ep.maxpacket_limit);\n\tseq_printf(seq, \"  bytes_per_buffer = %d\\n\", ep->bytes_per_buffer);\n\tif (mode == 1 || mode == 3)\n\t\tseq_printf(seq, \"  nt = %d\\n\",\n\t\t\t   (epctrl & GR_EPCTRL_NT_MASK) >> GR_EPCTRL_NT_POS);\n\n\tseq_printf(seq, \"  Buffer 0: %s %s%d\\n\",\n\t\t   epstat & GR_EPSTAT_B0 ? \"valid\" : \"invalid\",\n\t\t   epstat & GR_EPSTAT_BS ? \" \" : \"selected \",\n\t\t   (epstat & GR_EPSTAT_B0CNT_MASK) >> GR_EPSTAT_B0CNT_POS);\n\tseq_printf(seq, \"  Buffer 1: %s %s%d\\n\",\n\t\t   epstat & GR_EPSTAT_B1 ? \"valid\" : \"invalid\",\n\t\t   epstat & GR_EPSTAT_BS ? \"selected \" : \" \",\n\t\t   (epstat & GR_EPSTAT_B1CNT_MASK) >> GR_EPSTAT_B1CNT_POS);\n\n\tif (list_empty(&ep->queue)) {\n\t\tseq_puts(seq, \"  Queue: empty\\n\\n\");\n\t\treturn;\n\t}\n\n\tseq_puts(seq, \"  Queue:\\n\");\n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tstruct gr_dma_desc *desc;\n\t\tstruct gr_dma_desc *next;\n\n\t\tseq_printf(seq, \"    0x%p: 0x%p %d %d\\n\", req,\n\t\t\t   &req->req.buf, req->req.actual, req->req.length);\n\n\t\tnext = req->first_desc;\n\t\tdo {\n\t\t\tdesc = next;\n\t\t\tnext = desc->next_desc;\n\t\t\tseq_printf(seq, \"    %c 0x%p (0x%08x): 0x%05x 0x%08x\\n\",\n\t\t\t\t   desc == req->curr_desc ? 'c' : ' ',\n\t\t\t\t   desc, desc->paddr, desc->ctrl, desc->data);\n\t\t} while (desc != req->last_desc);\n\t}\n\tseq_puts(seq, \"\\n\");\n}\n\nstatic int gr_dfs_show(struct seq_file *seq, void *v)\n{\n\tstruct gr_udc *dev = seq->private;\n\tu32 control = gr_read32(&dev->regs->control);\n\tu32 status = gr_read32(&dev->regs->status);\n\tstruct gr_ep *ep;\n\n\tseq_printf(seq, \"usb state = %s\\n\",\n\t\t   usb_state_string(dev->gadget.state));\n\tseq_printf(seq, \"address = %d\\n\",\n\t\t   (control & GR_CONTROL_UA_MASK) >> GR_CONTROL_UA_POS);\n\tseq_printf(seq, \"speed = %s\\n\", GR_SPEED_STR(status));\n\tseq_printf(seq, \"ep0state = %s\\n\", gr_ep0state_string(dev->ep0state));\n\tseq_printf(seq, \"irq_enabled = %d\\n\", dev->irq_enabled);\n\tseq_printf(seq, \"remote_wakeup = %d\\n\", dev->remote_wakeup);\n\tseq_printf(seq, \"test_mode = %d\\n\", dev->test_mode);\n\tseq_puts(seq, \"\\n\");\n\n\tlist_for_each_entry(ep, &dev->ep_list, ep_list)\n\t\tgr_seq_ep_show(seq, ep);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(gr_dfs);\n\nstatic void gr_dfs_create(struct gr_udc *dev)\n{\n\tconst char *name = \"gr_udc_state\";\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(dev_name(dev->dev), usb_debug_root);\n\tdebugfs_create_file(name, 0444, root, dev, &gr_dfs_fops);\n}\n\nstatic void gr_dfs_delete(struct gr_udc *dev)\n{\n\tdebugfs_lookup_and_remove(dev_name(dev->dev), usb_debug_root);\n}\n\n#else  \n\nstatic void gr_dfs_create(struct gr_udc *dev) {}\nstatic void gr_dfs_delete(struct gr_udc *dev) {}\n\n#endif  \n\n \n \n\n \nstatic struct gr_dma_desc *gr_alloc_dma_desc(struct gr_ep *ep, gfp_t gfp_flags)\n{\n\tdma_addr_t paddr;\n\tstruct gr_dma_desc *dma_desc;\n\n\tdma_desc = dma_pool_zalloc(ep->dev->desc_pool, gfp_flags, &paddr);\n\tif (!dma_desc) {\n\t\tdev_err(ep->dev->dev, \"Could not allocate from DMA pool\\n\");\n\t\treturn NULL;\n\t}\n\n\tdma_desc->paddr = paddr;\n\n\treturn dma_desc;\n}\n\nstatic inline void gr_free_dma_desc(struct gr_udc *dev,\n\t\t\t\t    struct gr_dma_desc *desc)\n{\n\tdma_pool_free(dev->desc_pool, desc, (dma_addr_t)desc->paddr);\n}\n\n \nstatic void gr_free_dma_desc_chain(struct gr_udc *dev, struct gr_request *req)\n{\n\tstruct gr_dma_desc *desc;\n\tstruct gr_dma_desc *next;\n\n\tnext = req->first_desc;\n\tif (!next)\n\t\treturn;\n\n\tdo {\n\t\tdesc = next;\n\t\tnext = desc->next_desc;\n\t\tgr_free_dma_desc(dev, desc);\n\t} while (desc != req->last_desc);\n\n\treq->first_desc = NULL;\n\treq->curr_desc = NULL;\n\treq->last_desc = NULL;\n}\n\nstatic void gr_ep0_setup(struct gr_udc *dev, struct gr_request *req);\n\n \nstatic void gr_finish_request(struct gr_ep *ep, struct gr_request *req,\n\t\t\t      int status)\n\t__releases(&dev->lock)\n\t__acquires(&dev->lock)\n{\n\tstruct gr_udc *dev;\n\n\tlist_del_init(&req->queue);\n\n\tif (likely(req->req.status == -EINPROGRESS))\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tdev = ep->dev;\n\tusb_gadget_unmap_request(&dev->gadget, &req->req, ep->is_in);\n\tgr_free_dma_desc_chain(dev, req);\n\n\tif (ep->is_in) {  \n\t\treq->req.actual = req->req.length;\n\t} else if (req->oddlen && req->req.actual > req->evenlen) {\n\t\t \n\t\tchar *buftail = ((char *)req->req.buf + req->evenlen);\n\n\t\tmemcpy(buftail, ep->tailbuf, req->oddlen);\n\n\t\tif (req->req.actual > req->req.length) {\n\t\t\t \n\t\t\tdev_dbg(ep->dev->dev, \"Overflow for ep %s\\n\",\n\t\t\t\tep->ep.name);\n\t\t\tgr_dbgprint_request(\"OVFL\", ep, req);\n\t\t\treq->req.status = -EOVERFLOW;\n\t\t}\n\t}\n\n\tif (!status) {\n\t\tif (ep->is_in)\n\t\t\tgr_dbgprint_request(\"SENT\", ep, req);\n\t\telse\n\t\t\tgr_dbgprint_request(\"RECV\", ep, req);\n\t}\n\n\t \n\tep->callback = 1;\n\tif (req == dev->ep0reqo && !status) {\n\t\tif (req->setup)\n\t\t\tgr_ep0_setup(dev, req);\n\t\telse\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"Unexpected non setup packet on ep0in\\n\");\n\t} else if (req->req.complete) {\n\t\tspin_unlock(&dev->lock);\n\n\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\n\t\tspin_lock(&dev->lock);\n\t}\n\tep->callback = 0;\n}\n\nstatic struct usb_request *gr_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\n{\n\tstruct gr_request *req;\n\n\treq = kzalloc(sizeof(*req), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\n \nstatic void gr_start_dma(struct gr_ep *ep)\n{\n\tstruct gr_request *req;\n\tu32 dmactrl;\n\n\tif (list_empty(&ep->queue)) {\n\t\tep->dma_start = 0;\n\t\treturn;\n\t}\n\n\treq = list_first_entry(&ep->queue, struct gr_request, queue);\n\n\t \n\tBUG_ON(!req->curr_desc);\n\n\t \n\tif (!ep->is_in && req->oddlen)\n\t\treq->last_desc->data = ep->tailbuf_paddr;\n\n\twmb();  \n\n\t \n\tgr_write32(&ep->regs->dmaaddr, req->curr_desc->paddr);\n\n\t \n\tdmactrl = gr_read32(&ep->regs->dmactrl);\n\tgr_write32(&ep->regs->dmactrl, dmactrl | GR_DMACTRL_DA);\n\n\tep->dma_start = 1;\n}\n\n \nstatic void gr_dma_advance(struct gr_ep *ep, int status)\n{\n\tstruct gr_request *req;\n\n\treq = list_first_entry(&ep->queue, struct gr_request, queue);\n\tgr_finish_request(ep, req, status);\n\tgr_start_dma(ep);  \n}\n\n \nstatic void gr_abort_dma(struct gr_ep *ep)\n{\n\tu32 dmactrl;\n\n\tdmactrl = gr_read32(&ep->regs->dmactrl);\n\tgr_write32(&ep->regs->dmactrl, dmactrl | GR_DMACTRL_AD);\n}\n\n \nstatic int gr_add_dma_desc(struct gr_ep *ep, struct gr_request *req,\n\t\t\t   dma_addr_t data, unsigned size, gfp_t gfp_flags)\n{\n\tstruct gr_dma_desc *desc;\n\n\tdesc = gr_alloc_dma_desc(ep, gfp_flags);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tdesc->data = data;\n\tif (ep->is_in)\n\t\tdesc->ctrl =\n\t\t\t(GR_DESC_IN_CTRL_LEN_MASK & size) | GR_DESC_IN_CTRL_EN;\n\telse\n\t\tdesc->ctrl = GR_DESC_OUT_CTRL_IE;\n\n\tif (!req->first_desc) {\n\t\treq->first_desc = desc;\n\t\treq->curr_desc = desc;\n\t} else {\n\t\treq->last_desc->next_desc = desc;\n\t\treq->last_desc->next = desc->paddr;\n\t\treq->last_desc->ctrl |= GR_DESC_OUT_CTRL_NX;\n\t}\n\treq->last_desc = desc;\n\n\treturn 0;\n}\n\n \nstatic int gr_setup_out_desc_list(struct gr_ep *ep, struct gr_request *req,\n\t\t\t\t  gfp_t gfp_flags)\n{\n\tu16 bytes_left;  \n\tu16 bytes_used;  \n\tint ret = 0;\n\n\treq->first_desc = NULL;  \n\tbytes_left = req->req.length;\n\tbytes_used = 0;\n\twhile (bytes_left > 0) {\n\t\tdma_addr_t start = req->req.dma + bytes_used;\n\t\tu16 size = min(bytes_left, ep->bytes_per_buffer);\n\n\t\tif (size < ep->bytes_per_buffer) {\n\t\t\t \n\t\t\treq->evenlen = req->req.length - bytes_left;\n\t\t\treq->oddlen = size;\n\t\t}\n\n\t\tret = gr_add_dma_desc(ep, req, start, size, gfp_flags);\n\t\tif (ret)\n\t\t\tgoto alloc_err;\n\n\t\tbytes_left -= size;\n\t\tbytes_used += size;\n\t}\n\n\treq->first_desc->ctrl |= GR_DESC_OUT_CTRL_EN;\n\n\treturn 0;\n\nalloc_err:\n\tgr_free_dma_desc_chain(ep->dev, req);\n\n\treturn ret;\n}\n\n \nstatic int gr_setup_in_desc_list(struct gr_ep *ep, struct gr_request *req,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tu16 bytes_left;  \n\tu16 bytes_used;  \n\tint ret = 0;\n\n\treq->first_desc = NULL;  \n\tbytes_left = req->req.length;\n\tbytes_used = 0;\n\tdo {  \n\t\tdma_addr_t start = req->req.dma + bytes_used;\n\t\tu16 size = min(bytes_left, ep->bytes_per_buffer);\n\n\t\tret = gr_add_dma_desc(ep, req, start, size, gfp_flags);\n\t\tif (ret)\n\t\t\tgoto alloc_err;\n\n\t\tbytes_left -= size;\n\t\tbytes_used += size;\n\t} while (bytes_left > 0);\n\n\t \n\tif (req->req.zero && (req->req.length % ep->ep.maxpacket == 0)) {\n\t\tret = gr_add_dma_desc(ep, req, 0, 0, gfp_flags);\n\t\tif (ret)\n\t\t\tgoto alloc_err;\n\t}\n\n\t \n\treq->last_desc->ctrl |= GR_DESC_IN_CTRL_PI;\n\n\treturn 0;\n\nalloc_err:\n\tgr_free_dma_desc_chain(ep->dev, req);\n\n\treturn ret;\n}\n\n \nstatic int gr_queue(struct gr_ep *ep, struct gr_request *req, gfp_t gfp_flags)\n{\n\tstruct gr_udc *dev = ep->dev;\n\tint ret;\n\n\tif (unlikely(!ep->ep.desc && ep->num != 0)) {\n\t\tdev_err(dev->dev, \"No ep descriptor for %s\\n\", ep->ep.name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(!req->req.buf || !list_empty(&req->queue))) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Invalid request for %s: buf=%p list_empty=%d\\n\",\n\t\t\tep->ep.name, req->req.buf, list_empty(&req->queue));\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {\n\t\tdev_err(dev->dev, \"-ESHUTDOWN\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (dev->ep0state == GR_EP0_SUSPEND) {\n\t\tdev_err(dev->dev, \"-EBUSY\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tret = usb_gadget_map_request(&dev->gadget, &req->req, ep->is_in);\n\tif (ret) {\n\t\tdev_err(dev->dev, \"usb_gadget_map_request\");\n\t\treturn ret;\n\t}\n\n\tif (ep->is_in)\n\t\tret = gr_setup_in_desc_list(ep, req, gfp_flags);\n\telse\n\t\tret = gr_setup_out_desc_list(ep, req, gfp_flags);\n\tif (ret)\n\t\treturn ret;\n\n\treq->req.status = -EINPROGRESS;\n\treq->req.actual = 0;\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\t \n\tif (!ep->dma_start && likely(!ep->stopped))\n\t\tgr_start_dma(ep);\n\n\treturn 0;\n}\n\n \nstatic inline int gr_queue_int(struct gr_ep *ep, struct gr_request *req,\n\t\t\t       gfp_t gfp_flags)\n{\n\tif (ep->is_in)\n\t\tgr_dbgprint_request(\"RESP\", ep, req);\n\n\treturn gr_queue(ep, req, gfp_flags);\n}\n\n \n \n\n \nstatic void gr_ep_nuke(struct gr_ep *ep)\n{\n\tstruct gr_request *req;\n\n\tep->stopped = 1;\n\tep->dma_start = 0;\n\tgr_abort_dma(ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_first_entry(&ep->queue, struct gr_request, queue);\n\t\tgr_finish_request(ep, req, -ESHUTDOWN);\n\t}\n}\n\n \nstatic void gr_ep_reset(struct gr_ep *ep)\n{\n\tgr_write32(&ep->regs->epctrl, 0);\n\tgr_write32(&ep->regs->dmactrl, 0);\n\n\tep->ep.maxpacket = MAX_CTRL_PL_SIZE;\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\tep->dma_start = 0;\n}\n\n \nstatic void gr_control_stall(struct gr_udc *dev)\n{\n\tu32 epctrl;\n\n\tepctrl = gr_read32(&dev->epo[0].regs->epctrl);\n\tgr_write32(&dev->epo[0].regs->epctrl, epctrl | GR_EPCTRL_CS);\n\tepctrl = gr_read32(&dev->epi[0].regs->epctrl);\n\tgr_write32(&dev->epi[0].regs->epctrl, epctrl | GR_EPCTRL_CS);\n\n\tdev->ep0state = GR_EP0_STALL;\n}\n\n \nstatic int gr_ep_halt_wedge(struct gr_ep *ep, int halt, int wedge, int fromhost)\n{\n\tu32 epctrl;\n\tint retval = 0;\n\n\tif (ep->num && !ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tif (ep->num && ep->ep.desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (!ep->num) {\n\t\tif (halt && !fromhost) {\n\t\t\t \n\t\t\tgr_control_stall(ep->dev);\n\t\t\tdev_dbg(ep->dev->dev, \"EP: stall ep0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(ep->dev->dev, \"EP: %s halt %s\\n\",\n\t\t(halt ? (wedge ? \"wedge\" : \"set\") : \"clear\"), ep->ep.name);\n\n\tepctrl = gr_read32(&ep->regs->epctrl);\n\tif (halt) {\n\t\t \n\t\tgr_write32(&ep->regs->epctrl, epctrl | GR_EPCTRL_EH);\n\t\tep->stopped = 1;\n\t\tif (wedge)\n\t\t\tep->wedged = 1;\n\t} else {\n\t\tgr_write32(&ep->regs->epctrl, epctrl & ~GR_EPCTRL_EH);\n\t\tep->stopped = 0;\n\t\tep->wedged = 0;\n\n\t\t \n\t\tif (!ep->dma_start)\n\t\t\tgr_start_dma(ep);\n\t}\n\n\treturn retval;\n}\n\n \nstatic inline void gr_set_ep0state(struct gr_udc *dev, enum gr_ep0state value)\n{\n\tif (dev->ep0state != value)\n\t\tdev_vdbg(dev->dev, \"STATE:  ep0state=%s\\n\",\n\t\t\t gr_ep0state_string(value));\n\tdev->ep0state = value;\n}\n\n \nstatic void gr_disable_interrupts_and_pullup(struct gr_udc *dev)\n{\n\tgr_write32(&dev->regs->control, 0);\n\twmb();  \n\tdev->irq_enabled = 0;\n}\n\n \nstatic void gr_stop_activity(struct gr_udc *dev)\n{\n\tstruct gr_ep *ep;\n\n\tlist_for_each_entry(ep, &dev->ep_list, ep_list)\n\t\tgr_ep_nuke(ep);\n\n\tgr_disable_interrupts_and_pullup(dev);\n\n\tgr_set_ep0state(dev, GR_EP0_DISCONNECT);\n\tusb_gadget_set_state(&dev->gadget, USB_STATE_NOTATTACHED);\n}\n\n \n \n\nstatic void gr_ep0_testmode_complete(struct usb_ep *_ep,\n\t\t\t\t     struct usb_request *_req)\n{\n\tstruct gr_ep *ep;\n\tstruct gr_udc *dev;\n\tu32 control;\n\n\tep = container_of(_ep, struct gr_ep, ep);\n\tdev = ep->dev;\n\n\tspin_lock(&dev->lock);\n\n\tcontrol = gr_read32(&dev->regs->control);\n\tcontrol |= GR_CONTROL_TM | (dev->test_mode << GR_CONTROL_TS_POS);\n\tgr_write32(&dev->regs->control, control);\n\n\tspin_unlock(&dev->lock);\n}\n\nstatic void gr_ep0_dummy_complete(struct usb_ep *_ep, struct usb_request *_req)\n{\n\t \n}\n\n \nstatic int gr_ep0_respond(struct gr_udc *dev, u8 *buf, int length,\n\t\t\t  void (*complete)(struct usb_ep *ep,\n\t\t\t\t\t   struct usb_request *req))\n{\n\tu8 *reqbuf = dev->ep0reqi->req.buf;\n\tint status;\n\tint i;\n\n\tfor (i = 0; i < length; i++)\n\t\treqbuf[i] = buf[i];\n\tdev->ep0reqi->req.length = length;\n\tdev->ep0reqi->req.complete = complete;\n\n\tstatus = gr_queue_int(&dev->epi[0], dev->ep0reqi, GFP_ATOMIC);\n\tif (status < 0)\n\t\tdev_err(dev->dev,\n\t\t\t\"Could not queue ep0in setup response: %d\\n\", status);\n\n\treturn status;\n}\n\n \nstatic inline int gr_ep0_respond_u16(struct gr_udc *dev, u16 response)\n{\n\t__le16 le_response = cpu_to_le16(response);\n\n\treturn gr_ep0_respond(dev, (u8 *)&le_response, 2,\n\t\t\t      gr_ep0_dummy_complete);\n}\n\n \nstatic inline int gr_ep0_respond_empty(struct gr_udc *dev)\n{\n\treturn gr_ep0_respond(dev, NULL, 0, gr_ep0_dummy_complete);\n}\n\n \nstatic void gr_set_address(struct gr_udc *dev, u8 address)\n{\n\tu32 control;\n\n\tcontrol = gr_read32(&dev->regs->control) & ~GR_CONTROL_UA_MASK;\n\tcontrol |= (address << GR_CONTROL_UA_POS) & GR_CONTROL_UA_MASK;\n\tcontrol |= GR_CONTROL_SU;\n\tgr_write32(&dev->regs->control, control);\n}\n\n \nstatic int gr_device_request(struct gr_udc *dev, u8 type, u8 request,\n\t\t\t     u16 value, u16 index)\n{\n\tu16 response;\n\tu8 test;\n\n\tswitch (request) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\tdev_dbg(dev->dev, \"STATUS: address %d\\n\", value & 0xff);\n\t\tgr_set_address(dev, value & 0xff);\n\t\tif (value)\n\t\t\tusb_gadget_set_state(&dev->gadget, USB_STATE_ADDRESS);\n\t\telse\n\t\t\tusb_gadget_set_state(&dev->gadget, USB_STATE_DEFAULT);\n\t\treturn gr_ep0_respond_empty(dev);\n\n\tcase USB_REQ_GET_STATUS:\n\t\t \n\t\tresponse = 0x0001 | (dev->remote_wakeup ? 0x0002 : 0);\n\t\treturn gr_ep0_respond_u16(dev, response);\n\n\tcase USB_REQ_SET_FEATURE:\n\t\tswitch (value) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t \n\t\t\tdev->remote_wakeup = 1;\n\t\t\treturn gr_ep0_respond_empty(dev);\n\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t \n\t\t\ttest = index >> 8;\n\t\t\tif (test >= USB_TEST_J && test <= USB_TEST_PACKET) {\n\t\t\t\tdev->test_mode = test;\n\t\t\t\treturn gr_ep0_respond(dev, NULL, 0,\n\t\t\t\t\t\t      gr_ep0_testmode_complete);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tswitch (value) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t \n\t\t\tdev->remote_wakeup = 0;\n\t\t\treturn gr_ep0_respond_empty(dev);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 1;  \n}\n\n \nstatic int gr_interface_request(struct gr_udc *dev, u8 type, u8 request,\n\t\t\t\tu16 value, u16 index)\n{\n\tif (dev->gadget.state != USB_STATE_CONFIGURED)\n\t\treturn -1;\n\n\t \n\n\tswitch (request) {\n\tcase USB_REQ_GET_STATUS:\n\t\treturn gr_ep0_respond_u16(dev, 0x0000);\n\n\tcase USB_REQ_SET_FEATURE:\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn 1;  \n}\n\n \nstatic int gr_endpoint_request(struct gr_udc *dev, u8 type, u8 request,\n\t\t\t       u16 value, u16 index)\n{\n\tstruct gr_ep *ep;\n\tint status;\n\tint halted;\n\tu8 epnum = index & USB_ENDPOINT_NUMBER_MASK;\n\tu8 is_in = index & USB_ENDPOINT_DIR_MASK;\n\n\tif ((is_in && epnum >= dev->nepi) || (!is_in && epnum >= dev->nepo))\n\t\treturn -1;\n\n\tif (dev->gadget.state != USB_STATE_CONFIGURED && epnum != 0)\n\t\treturn -1;\n\n\tep = (is_in ? &dev->epi[epnum] : &dev->epo[epnum]);\n\n\tswitch (request) {\n\tcase USB_REQ_GET_STATUS:\n\t\thalted = gr_read32(&ep->regs->epctrl) & GR_EPCTRL_EH;\n\t\treturn gr_ep0_respond_u16(dev, halted ? 0x0001 : 0);\n\n\tcase USB_REQ_SET_FEATURE:\n\t\tswitch (value) {\n\t\tcase USB_ENDPOINT_HALT:\n\t\t\tstatus = gr_ep_halt_wedge(ep, 1, 0, 1);\n\t\t\tif (status >= 0)\n\t\t\t\tstatus = gr_ep0_respond_empty(dev);\n\t\t\treturn status;\n\t\t}\n\t\tbreak;\n\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tswitch (value) {\n\t\tcase USB_ENDPOINT_HALT:\n\t\t\tif (ep->wedged)\n\t\t\t\treturn -1;\n\t\t\tstatus = gr_ep_halt_wedge(ep, 0, 0, 1);\n\t\t\tif (status >= 0)\n\t\t\t\tstatus = gr_ep0_respond_empty(dev);\n\t\t\treturn status;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 1;  \n}\n\n \nstatic void gr_ep0out_requeue(struct gr_udc *dev)\n{\n\tint ret = gr_queue_int(&dev->epo[0], dev->ep0reqo, GFP_ATOMIC);\n\n\tif (ret)\n\t\tdev_err(dev->dev, \"Could not queue ep0out setup request: %d\\n\",\n\t\t\tret);\n}\n\n \nstatic void gr_ep0_setup(struct gr_udc *dev, struct gr_request *req)\n\t__releases(&dev->lock)\n\t__acquires(&dev->lock)\n{\n\tunion {\n\t\tstruct usb_ctrlrequest ctrl;\n\t\tu8 raw[8];\n\t\tu32 word[2];\n\t} u;\n\tu8 type;\n\tu8 request;\n\tu16 value;\n\tu16 index;\n\tu16 length;\n\tint i;\n\tint status;\n\n\t \n\tif (dev->ep0state == GR_EP0_STALL) {\n\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\t\tif (!req->req.actual)\n\t\t\tgoto out;\n\t}\n\n\tif (dev->ep0state == GR_EP0_ISTATUS) {\n\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\t\tif (req->req.actual > 0)\n\t\t\tdev_dbg(dev->dev,\n\t\t\t\t\"Unexpected setup packet at state %s\\n\",\n\t\t\t\tgr_ep0state_string(GR_EP0_ISTATUS));\n\t\telse\n\t\t\tgoto out;  \n\t} else if (dev->ep0state != GR_EP0_SETUP) {\n\t\tdev_info(dev->dev,\n\t\t\t \"Unexpected ep0out request at state %s - stalling\\n\",\n\t\t\t gr_ep0state_string(dev->ep0state));\n\t\tgr_control_stall(dev);\n\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\t\tgoto out;\n\t} else if (!req->req.actual) {\n\t\tdev_dbg(dev->dev, \"Unexpected ZLP at state %s\\n\",\n\t\t\tgr_ep0state_string(dev->ep0state));\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < req->req.actual; i++)\n\t\tu.raw[i] = ((u8 *)req->req.buf)[i];\n\n\ttype = u.ctrl.bRequestType;\n\trequest = u.ctrl.bRequest;\n\tvalue = le16_to_cpu(u.ctrl.wValue);\n\tindex = le16_to_cpu(u.ctrl.wIndex);\n\tlength = le16_to_cpu(u.ctrl.wLength);\n\n\tgr_dbgprint_devreq(dev, type, request, value, index, length);\n\n\t \n\tif (length) {\n\t\tif (type & USB_DIR_IN)\n\t\t\tgr_set_ep0state(dev, GR_EP0_IDATA);\n\t\telse\n\t\t\tgr_set_ep0state(dev, GR_EP0_ODATA);\n\t}\n\n\tstatus = 1;  \n\tif ((type & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (type & USB_RECIP_MASK) {\n\t\tcase USB_RECIP_DEVICE:\n\t\t\tstatus = gr_device_request(dev, type, request,\n\t\t\t\t\t\t   value, index);\n\t\t\tbreak;\n\t\tcase USB_RECIP_ENDPOINT:\n\t\t\tstatus =  gr_endpoint_request(dev, type, request,\n\t\t\t\t\t\t      value, index);\n\t\t\tbreak;\n\t\tcase USB_RECIP_INTERFACE:\n\t\t\tstatus = gr_interface_request(dev, type, request,\n\t\t\t\t\t\t      value, index);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status > 0) {\n\t\tspin_unlock(&dev->lock);\n\n\t\tdev_vdbg(dev->dev, \"DELEGATE\\n\");\n\t\tstatus = dev->driver->setup(&dev->gadget, &u.ctrl);\n\n\t\tspin_lock(&dev->lock);\n\t}\n\n\t \n\tif (unlikely(status < 0)) {\n\t\tdev_vdbg(dev->dev, \"STALL\\n\");\n\t\tgr_control_stall(dev);\n\t}\n\n\tif ((type & USB_TYPE_MASK) == USB_TYPE_STANDARD &&\n\t    request == USB_REQ_SET_CONFIGURATION) {\n\t\tif (!value) {\n\t\t\tdev_dbg(dev->dev, \"STATUS: deconfigured\\n\");\n\t\t\tusb_gadget_set_state(&dev->gadget, USB_STATE_ADDRESS);\n\t\t} else if (status >= 0) {\n\t\t\t \n\t\t\tdev_dbg(dev->dev, \"STATUS: configured: %d\\n\", value);\n\t\t\tusb_gadget_set_state(&dev->gadget,\n\t\t\t\t\t     USB_STATE_CONFIGURED);\n\t\t}\n\t}\n\n\t \n\tif (dev->ep0state == GR_EP0_ODATA)\n\t\tgr_set_ep0state(dev, GR_EP0_OSTATUS);\n\telse if (dev->ep0state == GR_EP0_IDATA)\n\t\tgr_set_ep0state(dev, GR_EP0_ISTATUS);\n\telse\n\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\nout:\n\tgr_ep0out_requeue(dev);\n}\n\n \n \n\n \nstatic void gr_vbus_connected(struct gr_udc *dev, u32 status)\n{\n\tu32 control;\n\n\tdev->gadget.speed = GR_SPEED(status);\n\tusb_gadget_set_state(&dev->gadget, USB_STATE_POWERED);\n\n\t \n\tcontrol = (GR_CONTROL_SI | GR_CONTROL_UI | GR_CONTROL_VI |\n\t\t   GR_CONTROL_SP | GR_CONTROL_EP);\n\tgr_write32(&dev->regs->control, control);\n}\n\n \nstatic void gr_enable_vbus_detect(struct gr_udc *dev)\n{\n\tu32 status;\n\n\tdev->irq_enabled = 1;\n\twmb();  \n\tgr_write32(&dev->regs->control, GR_CONTROL_VI);\n\n\t \n\tstatus = gr_read32(&dev->regs->status);\n\tif (status & GR_STATUS_VB)\n\t\tgr_vbus_connected(dev, status);\n}\n\n \nstatic void gr_vbus_disconnected(struct gr_udc *dev)\n{\n\tgr_stop_activity(dev);\n\n\t \n\tif (dev->driver && dev->driver->disconnect) {\n\t\tspin_unlock(&dev->lock);\n\n\t\tdev->driver->disconnect(&dev->gadget);\n\n\t\tspin_lock(&dev->lock);\n\t}\n\n\tgr_enable_vbus_detect(dev);\n}\n\n \nstatic void gr_udc_usbreset(struct gr_udc *dev, u32 status)\n{\n\tgr_set_address(dev, 0);\n\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\tusb_gadget_set_state(&dev->gadget, USB_STATE_DEFAULT);\n\tdev->gadget.speed = GR_SPEED(status);\n\n\tgr_ep_nuke(&dev->epo[0]);\n\tgr_ep_nuke(&dev->epi[0]);\n\tdev->epo[0].stopped = 0;\n\tdev->epi[0].stopped = 0;\n\tgr_ep0out_requeue(dev);\n}\n\n \n \n\n \nstatic int gr_handle_in_ep(struct gr_ep *ep)\n{\n\tstruct gr_request *req;\n\n\treq = list_first_entry(&ep->queue, struct gr_request, queue);\n\tif (!req->last_desc)\n\t\treturn 0;\n\n\tif (READ_ONCE(req->last_desc->ctrl) & GR_DESC_IN_CTRL_EN)\n\t\treturn 0;  \n\n\tif (gr_read32(&ep->regs->epstat) & (GR_EPSTAT_B1 | GR_EPSTAT_B0))\n\t\treturn 0;  \n\n\t \n\tgr_dma_advance(ep, 0);\n\n\treturn 1;\n}\n\n \nstatic int gr_handle_out_ep(struct gr_ep *ep)\n{\n\tu32 ep_dmactrl;\n\tu32 ctrl;\n\tu16 len;\n\tstruct gr_request *req;\n\tstruct gr_udc *dev = ep->dev;\n\n\treq = list_first_entry(&ep->queue, struct gr_request, queue);\n\tif (!req->curr_desc)\n\t\treturn 0;\n\n\tctrl = READ_ONCE(req->curr_desc->ctrl);\n\tif (ctrl & GR_DESC_OUT_CTRL_EN)\n\t\treturn 0;  \n\n\t \n\tlen = ctrl & GR_DESC_OUT_CTRL_LEN_MASK;\n\treq->req.actual += len;\n\tif (ctrl & GR_DESC_OUT_CTRL_SE)\n\t\treq->setup = 1;\n\n\tif (len < ep->ep.maxpacket || req->req.actual >= req->req.length) {\n\t\t \n\n\t\tif ((ep == &dev->epo[0]) && (dev->ep0state == GR_EP0_OSTATUS)) {\n\t\t\t \n\t\t\tgr_ep0_respond_empty(dev);\n\t\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\t\t}\n\n\t\tgr_dma_advance(ep, 0);\n\t} else {\n\t\t \n\t\treq->curr_desc = req->curr_desc->next_desc;\n\t\treq->curr_desc->ctrl |= GR_DESC_OUT_CTRL_EN;\n\n\t\tep_dmactrl = gr_read32(&ep->regs->dmactrl);\n\t\tgr_write32(&ep->regs->dmactrl, ep_dmactrl | GR_DMACTRL_DA);\n\t}\n\n\treturn 1;\n}\n\n \nstatic int gr_handle_state_changes(struct gr_udc *dev)\n{\n\tu32 status = gr_read32(&dev->regs->status);\n\tint handled = 0;\n\tint powstate = !(dev->gadget.state == USB_STATE_NOTATTACHED ||\n\t\t\t dev->gadget.state == USB_STATE_ATTACHED);\n\n\t \n\tif (!powstate && (status & GR_STATUS_VB)) {\n\t\tdev_dbg(dev->dev, \"STATUS: vbus valid detected\\n\");\n\t\tgr_vbus_connected(dev, status);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (powstate && !(status & GR_STATUS_VB)) {\n\t\tdev_dbg(dev->dev, \"STATUS: vbus invalid detected\\n\");\n\t\tgr_vbus_disconnected(dev);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (status & GR_STATUS_UR) {\n\t\tdev_dbg(dev->dev, \"STATUS: USB reset - speed is %s\\n\",\n\t\t\tGR_SPEED_STR(status));\n\t\tgr_write32(&dev->regs->status, GR_STATUS_UR);\n\t\tgr_udc_usbreset(dev, status);\n\t\thandled = 1;\n\t}\n\n\t \n\tif (dev->gadget.speed != GR_SPEED(status)) {\n\t\tdev_dbg(dev->dev, \"STATUS: USB Speed change to %s\\n\",\n\t\t\tGR_SPEED_STR(status));\n\t\tdev->gadget.speed = GR_SPEED(status);\n\t\thandled = 1;\n\t}\n\n\t \n\tif ((dev->ep0state != GR_EP0_SUSPEND) && !(status & GR_STATUS_SU)) {\n\t\tdev_dbg(dev->dev, \"STATUS: USB suspend\\n\");\n\t\tgr_set_ep0state(dev, GR_EP0_SUSPEND);\n\t\tdev->suspended_from = dev->gadget.state;\n\t\tusb_gadget_set_state(&dev->gadget, USB_STATE_SUSPENDED);\n\n\t\tif ((dev->gadget.speed != USB_SPEED_UNKNOWN) &&\n\t\t    dev->driver && dev->driver->suspend) {\n\t\t\tspin_unlock(&dev->lock);\n\n\t\t\tdev->driver->suspend(&dev->gadget);\n\n\t\t\tspin_lock(&dev->lock);\n\t\t}\n\t\thandled = 1;\n\t}\n\n\t \n\tif ((dev->ep0state == GR_EP0_SUSPEND) && (status & GR_STATUS_SU)) {\n\t\tdev_dbg(dev->dev, \"STATUS: USB resume\\n\");\n\t\tif (dev->suspended_from == USB_STATE_POWERED)\n\t\t\tgr_set_ep0state(dev, GR_EP0_DISCONNECT);\n\t\telse\n\t\t\tgr_set_ep0state(dev, GR_EP0_SETUP);\n\t\tusb_gadget_set_state(&dev->gadget, dev->suspended_from);\n\n\t\tif ((dev->gadget.speed != USB_SPEED_UNKNOWN) &&\n\t\t    dev->driver && dev->driver->resume) {\n\t\t\tspin_unlock(&dev->lock);\n\n\t\t\tdev->driver->resume(&dev->gadget);\n\n\t\t\tspin_lock(&dev->lock);\n\t\t}\n\t\thandled = 1;\n\t}\n\n\treturn handled;\n}\n\n \nstatic irqreturn_t gr_irq_handler(int irq, void *_dev)\n{\n\tstruct gr_udc *dev = _dev;\n\tstruct gr_ep *ep;\n\tint handled = 0;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tif (!dev->irq_enabled)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < dev->nepi; i++) {\n\t\tep = &dev->epi[i];\n\t\tif (!ep->stopped && !ep->callback && !list_empty(&ep->queue))\n\t\t\thandled = gr_handle_in_ep(ep) || handled;\n\t}\n\n\t \n\tfor (i = 0; i < dev->nepo; i++) {\n\t\tep = &dev->epo[i];\n\t\tif (!ep->stopped && !ep->callback && !list_empty(&ep->queue))\n\t\t\thandled = gr_handle_out_ep(ep) || handled;\n\t}\n\n\t \n\thandled = gr_handle_state_changes(dev) || handled;\n\n\t \n\tif (!handled) {\n\t\tlist_for_each_entry(ep, &dev->ep_list, ep_list) {\n\t\t\tif (gr_read32(&ep->regs->dmactrl) & GR_DMACTRL_AE) {\n\t\t\t\tdev_err(dev->dev,\n\t\t\t\t\t\"AMBA Error occurred for %s\\n\",\n\t\t\t\t\tep->ep.name);\n\t\t\t\thandled = 1;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn handled ? IRQ_HANDLED : IRQ_NONE;\n}\n\n \nstatic irqreturn_t gr_irq(int irq, void *_dev)\n{\n\tstruct gr_udc *dev = _dev;\n\n\tif (!dev->irq_enabled)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\n \n \n\n \nstatic int gr_ep_enable(struct usb_ep *_ep,\n\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct gr_udc *dev;\n\tstruct gr_ep *ep;\n\tu8 mode;\n\tu8 nt;\n\tu16 max;\n\tu16 buffer_size = 0;\n\tu32 epctrl;\n\n\tep = container_of(_ep, struct gr_ep, ep);\n\tif (!_ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tdev = ep->dev;\n\n\t \n\tif (ep == &dev->epo[0] || ep == &dev->epi[0])\n\t\treturn -EINVAL;\n\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tepctrl = gr_read32(&ep->regs->epctrl);\n\tif (epctrl & GR_EPCTRL_EV)\n\t\treturn -EBUSY;\n\n\t \n\tif (!ep->is_in != !usb_endpoint_dir_in(desc))\n\t\treturn -EINVAL;\n\n\t \n\tif ((!ep->is_in && ep->num >= dev->nepo) ||\n\t    (ep->is_in && ep->num >= dev->nepi))\n\t\treturn -EINVAL;\n\n\tif (usb_endpoint_xfer_control(desc)) {\n\t\tmode = 0;\n\t} else if (usb_endpoint_xfer_isoc(desc)) {\n\t\tmode = 1;\n\t} else if (usb_endpoint_xfer_bulk(desc)) {\n\t\tmode = 2;\n\t} else if (usb_endpoint_xfer_int(desc)) {\n\t\tmode = 3;\n\t} else {\n\t\tdev_err(dev->dev, \"Unknown transfer type for %s\\n\",\n\t\t\tep->ep.name);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmax = usb_endpoint_maxp(desc);\n\tnt = usb_endpoint_maxp_mult(desc) - 1;\n\tbuffer_size = GR_BUFFER_SIZE(epctrl);\n\tif (nt && (mode == 0 || mode == 2)) {\n\t\tdev_err(dev->dev,\n\t\t\t\"%s mode: multiple trans./microframe not valid\\n\",\n\t\t\t(mode == 2 ? \"Bulk\" : \"Control\"));\n\t\treturn -EINVAL;\n\t} else if (nt == 0x3) {\n\t\tdev_err(dev->dev,\n\t\t\t\"Invalid value 0x3 for additional trans./microframe\\n\");\n\t\treturn -EINVAL;\n\t} else if ((nt + 1) * max > buffer_size) {\n\t\tdev_err(dev->dev, \"Hw buffer size %d < max payload %d * %d\\n\",\n\t\t\tbuffer_size, (nt + 1), max);\n\t\treturn -EINVAL;\n\t} else if (max == 0) {\n\t\tdev_err(dev->dev, \"Max payload cannot be set to 0\\n\");\n\t\treturn -EINVAL;\n\t} else if (max > ep->ep.maxpacket_limit) {\n\t\tdev_err(dev->dev, \"Requested max payload %d > limit %d\\n\",\n\t\t\tmax, ep->ep.maxpacket_limit);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock(&ep->dev->lock);\n\n\tif (!ep->stopped) {\n\t\tspin_unlock(&ep->dev->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tep->stopped = 0;\n\tep->wedged = 0;\n\tep->ep.desc = desc;\n\tep->ep.maxpacket = max;\n\tep->dma_start = 0;\n\n\n\tif (nt) {\n\t\t \n\t\tep->bytes_per_buffer = (nt + 1) * max;\n\t} else if (ep->is_in) {\n\t\t \n\t\tep->bytes_per_buffer = (buffer_size / max) * max;\n\t} else {\n\t\t \n\t\tep->bytes_per_buffer = max;\n\t}\n\n\tepctrl = (max << GR_EPCTRL_MAXPL_POS)\n\t\t| (nt << GR_EPCTRL_NT_POS)\n\t\t| (mode << GR_EPCTRL_TT_POS)\n\t\t| GR_EPCTRL_EV;\n\tif (ep->is_in)\n\t\tepctrl |= GR_EPCTRL_PI;\n\tgr_write32(&ep->regs->epctrl, epctrl);\n\n\tgr_write32(&ep->regs->dmactrl, GR_DMACTRL_IE | GR_DMACTRL_AI);\n\n\tspin_unlock(&ep->dev->lock);\n\n\tdev_dbg(ep->dev->dev, \"EP: %s enabled - %s with %d bytes/buffer\\n\",\n\t\tep->ep.name, gr_modestring[mode], ep->bytes_per_buffer);\n\treturn 0;\n}\n\n \nstatic int gr_ep_disable(struct usb_ep *_ep)\n{\n\tstruct gr_ep *ep;\n\tstruct gr_udc *dev;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct gr_ep, ep);\n\tif (!_ep || !ep->ep.desc)\n\t\treturn -ENODEV;\n\n\tdev = ep->dev;\n\n\t \n\tif (ep == &dev->epo[0] || ep == &dev->epi[0])\n\t\treturn -EINVAL;\n\n\tif (dev->ep0state == GR_EP0_SUSPEND)\n\t\treturn -EBUSY;\n\n\tdev_dbg(ep->dev->dev, \"EP: disable %s\\n\", ep->ep.name);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tgr_ep_nuke(ep);\n\tgr_ep_reset(ep);\n\tep->ep.desc = NULL;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void gr_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct gr_request *req;\n\n\tif (!_ep || !_req)\n\t\treturn;\n\treq = container_of(_req, struct gr_request, req);\n\n\t \n\tWARN(!list_empty(&req->queue),\n\t     \"request not dequeued properly before freeing\\n\");\n\n\tkfree(req);\n}\n\n \nstatic int gr_queue_ext(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct gr_ep *ep;\n\tstruct gr_request *req;\n\tstruct gr_udc *dev;\n\tint ret;\n\n\tif (unlikely(!_ep || !_req))\n\t\treturn -EINVAL;\n\n\tep = container_of(_ep, struct gr_ep, ep);\n\treq = container_of(_req, struct gr_request, req);\n\tdev = ep->dev;\n\n\tspin_lock(&ep->dev->lock);\n\n\t \n\tif ((ep == &dev->epi[0]) && (dev->ep0state == GR_EP0_ODATA)) {\n\t\tep = &dev->epo[0];\n\t\tep->ep.driver_data = dev->epi[0].ep.driver_data;\n\t}\n\n\tif (ep->is_in)\n\t\tgr_dbgprint_request(\"EXTERN\", ep, req);\n\n\tret = gr_queue(ep, req, GFP_ATOMIC);\n\n\tspin_unlock(&ep->dev->lock);\n\n\treturn ret;\n}\n\n \nstatic int gr_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct gr_request *req = NULL, *iter;\n\tstruct gr_ep *ep;\n\tstruct gr_udc *dev;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct gr_ep, ep);\n\tif (!_ep || !_req || (!ep->ep.desc && ep->num != 0))\n\t\treturn -EINVAL;\n\tdev = ep->dev;\n\tif (!dev->driver)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (dev->ep0state == GR_EP0_SUSPEND)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\t \n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\treq = iter;\n\t\tbreak;\n\t}\n\tif (!req) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (list_first_entry(&ep->queue, struct gr_request, queue) == req) {\n\t\t \n\t\tgr_abort_dma(ep);\n\t\tif (ep->stopped)\n\t\t\tgr_finish_request(ep, req, -ECONNRESET);\n\t\telse\n\t\t\tgr_dma_advance(ep, -ECONNRESET);\n\t} else if (!list_empty(&req->queue)) {\n\t\t \n\t\tgr_finish_request(ep, req, -ECONNRESET);\n\t} else {\n\t\tret = -EOPNOTSUPP;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int gr_set_halt_wedge(struct usb_ep *_ep, int halt, int wedge)\n{\n\tint ret;\n\tstruct gr_ep *ep;\n\n\tif (!_ep)\n\t\treturn -ENODEV;\n\tep = container_of(_ep, struct gr_ep, ep);\n\n\tspin_lock(&ep->dev->lock);\n\n\t \n\tif (halt && ep->is_in && !list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tret = gr_ep_halt_wedge(ep, halt, wedge, 0);\n\nout:\n\tspin_unlock(&ep->dev->lock);\n\n\treturn ret;\n}\n\n \nstatic int gr_set_halt(struct usb_ep *_ep, int halt)\n{\n\treturn gr_set_halt_wedge(_ep, halt, 0);\n}\n\n \nstatic int gr_set_wedge(struct usb_ep *_ep)\n{\n\treturn gr_set_halt_wedge(_ep, 1, 1);\n}\n\n \nstatic int gr_fifo_status(struct usb_ep *_ep)\n{\n\tstruct gr_ep *ep;\n\tu32 epstat;\n\tu32 bytes = 0;\n\n\tif (!_ep)\n\t\treturn -ENODEV;\n\tep = container_of(_ep, struct gr_ep, ep);\n\n\tepstat = gr_read32(&ep->regs->epstat);\n\n\tif (epstat & GR_EPSTAT_B0)\n\t\tbytes += (epstat & GR_EPSTAT_B0CNT_MASK) >> GR_EPSTAT_B0CNT_POS;\n\tif (epstat & GR_EPSTAT_B1)\n\t\tbytes += (epstat & GR_EPSTAT_B1CNT_MASK) >> GR_EPSTAT_B1CNT_POS;\n\n\treturn bytes;\n}\n\n\n \nstatic void gr_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct gr_ep *ep;\n\tu32 epctrl;\n\n\tif (!_ep)\n\t\treturn;\n\tep = container_of(_ep, struct gr_ep, ep);\n\tdev_vdbg(ep->dev->dev, \"EP: flush fifo %s\\n\", ep->ep.name);\n\n\tspin_lock(&ep->dev->lock);\n\n\tepctrl = gr_read32(&ep->regs->epctrl);\n\tepctrl |= GR_EPCTRL_CB;\n\tgr_write32(&ep->regs->epctrl, epctrl);\n\n\tspin_unlock(&ep->dev->lock);\n}\n\nstatic const struct usb_ep_ops gr_ep_ops = {\n\t.enable\t\t= gr_ep_enable,\n\t.disable\t= gr_ep_disable,\n\n\t.alloc_request\t= gr_alloc_request,\n\t.free_request\t= gr_free_request,\n\n\t.queue\t\t= gr_queue_ext,\n\t.dequeue\t= gr_dequeue,\n\n\t.set_halt\t= gr_set_halt,\n\t.set_wedge\t= gr_set_wedge,\n\t.fifo_status\t= gr_fifo_status,\n\t.fifo_flush\t= gr_fifo_flush,\n};\n\n \n \n\nstatic int gr_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct gr_udc *dev;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct gr_udc, gadget);\n\treturn gr_read32(&dev->regs->status) & GR_STATUS_FN_MASK;\n}\n\nstatic int gr_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct gr_udc *dev;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct gr_udc, gadget);\n\n\t \n\tif (!dev->remote_wakeup)\n\t\treturn -EINVAL;\n\n\tspin_lock(&dev->lock);\n\n\tgr_write32(&dev->regs->control,\n\t\t   gr_read32(&dev->regs->control) | GR_CONTROL_RW);\n\n\tspin_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int gr_pullup(struct usb_gadget *_gadget, int is_on)\n{\n\tstruct gr_udc *dev;\n\tu32 control;\n\n\tif (!_gadget)\n\t\treturn -ENODEV;\n\tdev = container_of(_gadget, struct gr_udc, gadget);\n\n\tspin_lock(&dev->lock);\n\n\tcontrol = gr_read32(&dev->regs->control);\n\tif (is_on)\n\t\tcontrol |= GR_CONTROL_EP;\n\telse\n\t\tcontrol &= ~GR_CONTROL_EP;\n\tgr_write32(&dev->regs->control, control);\n\n\tspin_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int gr_udc_start(struct usb_gadget *gadget,\n\t\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct gr_udc *dev = to_gr_udc(gadget);\n\n\tspin_lock(&dev->lock);\n\n\t \n\tdev->driver = driver;\n\n\t \n\tgr_enable_vbus_detect(dev);\n\n\tspin_unlock(&dev->lock);\n\n\treturn 0;\n}\n\nstatic int gr_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct gr_udc *dev = to_gr_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tdev->driver = NULL;\n\tgr_stop_activity(dev);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops gr_ops = {\n\t.get_frame\t= gr_get_frame,\n\t.wakeup         = gr_wakeup,\n\t.pullup         = gr_pullup,\n\t.udc_start\t= gr_udc_start,\n\t.udc_stop\t= gr_udc_stop,\n\t \n};\n\n \n \n\nstatic const char * const onames[] = {\n\t\"ep0out\", \"ep1out\", \"ep2out\", \"ep3out\", \"ep4out\", \"ep5out\",\n\t\"ep6out\", \"ep7out\", \"ep8out\", \"ep9out\", \"ep10out\", \"ep11out\",\n\t\"ep12out\", \"ep13out\", \"ep14out\", \"ep15out\"\n};\n\nstatic const char * const inames[] = {\n\t\"ep0in\", \"ep1in\", \"ep2in\", \"ep3in\", \"ep4in\", \"ep5in\",\n\t\"ep6in\", \"ep7in\", \"ep8in\", \"ep9in\", \"ep10in\", \"ep11in\",\n\t\"ep12in\", \"ep13in\", \"ep14in\", \"ep15in\"\n};\n\n \nstatic int gr_ep_init(struct gr_udc *dev, int num, int is_in, u32 maxplimit)\n{\n\tstruct gr_ep *ep;\n\tstruct gr_request *req;\n\tstruct usb_request *_req;\n\tvoid *buf;\n\n\tif (is_in) {\n\t\tep = &dev->epi[num];\n\t\tep->ep.name = inames[num];\n\t\tep->regs = &dev->regs->epi[num];\n\t} else {\n\t\tep = &dev->epo[num];\n\t\tep->ep.name = onames[num];\n\t\tep->regs = &dev->regs->epo[num];\n\t}\n\n\tgr_ep_reset(ep);\n\tep->num = num;\n\tep->is_in = is_in;\n\tep->dev = dev;\n\tep->ep.ops = &gr_ep_ops;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tif (num == 0) {\n\t\t_req = gr_alloc_request(&ep->ep, GFP_ATOMIC);\n\t\tif (!_req)\n\t\t\treturn -ENOMEM;\n\n\t\tbuf = devm_kzalloc(dev->dev, PAGE_SIZE, GFP_DMA | GFP_ATOMIC);\n\t\tif (!buf) {\n\t\t\tgr_free_request(&ep->ep, _req);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\treq = container_of(_req, struct gr_request, req);\n\t\treq->req.buf = buf;\n\t\treq->req.length = MAX_CTRL_PL_SIZE;\n\n\t\tif (is_in)\n\t\t\tdev->ep0reqi = req;  \n\t\telse\n\t\t\tdev->ep0reqo = req;  \n\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, MAX_CTRL_PL_SIZE);\n\t\tep->bytes_per_buffer = MAX_CTRL_PL_SIZE;\n\n\t\tep->ep.caps.type_control = true;\n\t} else {\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, (u16)maxplimit);\n\t\tlist_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);\n\n\t\tep->ep.caps.type_iso = true;\n\t\tep->ep.caps.type_bulk = true;\n\t\tep->ep.caps.type_int = true;\n\t}\n\tlist_add_tail(&ep->ep_list, &dev->ep_list);\n\n\tif (is_in)\n\t\tep->ep.caps.dir_in = true;\n\telse\n\t\tep->ep.caps.dir_out = true;\n\n\tep->tailbuf = dma_alloc_coherent(dev->dev, ep->ep.maxpacket_limit,\n\t\t\t\t\t &ep->tailbuf_paddr, GFP_ATOMIC);\n\tif (!ep->tailbuf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n \nstatic int gr_udc_init(struct gr_udc *dev)\n{\n\tstruct device_node *np = dev->dev->of_node;\n\tu32 epctrl_val;\n\tu32 dmactrl_val;\n\tint i;\n\tint ret = 0;\n\tu32 bufsize;\n\n\tgr_set_address(dev, 0);\n\n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tdev->gadget.ep0 = &dev->epi[0].ep;\n\n\tINIT_LIST_HEAD(&dev->ep_list);\n\tgr_set_ep0state(dev, GR_EP0_DISCONNECT);\n\n\tfor (i = 0; i < dev->nepo; i++) {\n\t\tif (of_property_read_u32_index(np, \"epobufsizes\", i, &bufsize))\n\t\t\tbufsize = 1024;\n\t\tret = gr_ep_init(dev, i, 0, bufsize);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < dev->nepi; i++) {\n\t\tif (of_property_read_u32_index(np, \"epibufsizes\", i, &bufsize))\n\t\t\tbufsize = 1024;\n\t\tret = gr_ep_init(dev, i, 1, bufsize);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tdev->remote_wakeup = 0;\n\n\t \n\tepctrl_val = (MAX_CTRL_PL_SIZE << GR_EPCTRL_MAXPL_POS) | GR_EPCTRL_EV;\n\tdmactrl_val = GR_DMACTRL_IE | GR_DMACTRL_AI;\n\tgr_write32(&dev->epo[0].regs->epctrl, epctrl_val);\n\tgr_write32(&dev->epi[0].regs->epctrl, epctrl_val | GR_EPCTRL_PI);\n\tgr_write32(&dev->epo[0].regs->dmactrl, dmactrl_val);\n\tgr_write32(&dev->epi[0].regs->dmactrl, dmactrl_val);\n\n\treturn 0;\n}\n\nstatic void gr_ep_remove(struct gr_udc *dev, int num, int is_in)\n{\n\tstruct gr_ep *ep;\n\n\tif (is_in)\n\t\tep = &dev->epi[num];\n\telse\n\t\tep = &dev->epo[num];\n\n\tif (ep->tailbuf)\n\t\tdma_free_coherent(dev->dev, ep->ep.maxpacket_limit,\n\t\t\t\t  ep->tailbuf, ep->tailbuf_paddr);\n}\n\nstatic int gr_remove(struct platform_device *pdev)\n{\n\tstruct gr_udc *dev = platform_get_drvdata(pdev);\n\tint i;\n\n\tif (dev->added)\n\t\tusb_del_gadget_udc(&dev->gadget);  \n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\tgr_dfs_delete(dev);\n\tdma_pool_destroy(dev->desc_pool);\n\tplatform_set_drvdata(pdev, NULL);\n\n\tgr_free_request(&dev->epi[0].ep, &dev->ep0reqi->req);\n\tgr_free_request(&dev->epo[0].ep, &dev->ep0reqo->req);\n\n\tfor (i = 0; i < dev->nepo; i++)\n\t\tgr_ep_remove(dev, i, 0);\n\tfor (i = 0; i < dev->nepi; i++)\n\t\tgr_ep_remove(dev, i, 1);\n\n\treturn 0;\n}\nstatic int gr_request_irq(struct gr_udc *dev, int irq)\n{\n\treturn devm_request_threaded_irq(dev->dev, irq, gr_irq, gr_irq_handler,\n\t\t\t\t\t IRQF_SHARED, driver_name, dev);\n}\n\nstatic int gr_probe(struct platform_device *pdev)\n{\n\tstruct gr_udc *dev;\n\tstruct gr_regs __iomem *regs;\n\tint retval;\n\tu32 status;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tdev->dev = &pdev->dev;\n\n\tregs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\tdev->irq = platform_get_irq(pdev, 0);\n\tif (dev->irq < 0)\n\t\treturn dev->irq;\n\n\t \n\tdev->irqi = platform_get_irq(pdev, 1);\n\tif (dev->irqi > 0) {\n\t\tdev->irqo = platform_get_irq(pdev, 2);\n\t\tif (dev->irqo < 0)\n\t\t\treturn dev->irqo;\n\t} else {\n\t\tdev->irqi = 0;\n\t}\n\n\tdev->gadget.name = driver_name;\n\tdev->gadget.max_speed = USB_SPEED_HIGH;\n\tdev->gadget.ops = &gr_ops;\n\n\tspin_lock_init(&dev->lock);\n\tdev->regs = regs;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\t \n\tstatus = gr_read32(&dev->regs->status);\n\tdev->nepi = ((status & GR_STATUS_NEPI_MASK) >> GR_STATUS_NEPI_POS) + 1;\n\tdev->nepo = ((status & GR_STATUS_NEPO_MASK) >> GR_STATUS_NEPO_POS) + 1;\n\n\tif (!(status & GR_STATUS_DM)) {\n\t\tdev_err(dev->dev, \"Slave mode cores are not supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\t \n\tdev->desc_pool = dma_pool_create(\"desc_pool\", dev->dev,\n\t\t\t\t\t sizeof(struct gr_dma_desc), 4, 0);\n\tif (!dev->desc_pool) {\n\t\tdev_err(dev->dev, \"Could not allocate DMA pool\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tretval = usb_add_gadget_udc(dev->dev, &dev->gadget);\n\tif (retval) {\n\t\tdev_err(dev->dev, \"Could not add gadget udc\");\n\t\tgoto out;\n\t}\n\tdev->added = 1;\n\n\tspin_lock(&dev->lock);\n\n\tretval = gr_udc_init(dev);\n\tif (retval) {\n\t\tspin_unlock(&dev->lock);\n\t\tgoto out;\n\t}\n\n\t \n\tgr_disable_interrupts_and_pullup(dev);\n\n\tspin_unlock(&dev->lock);\n\n\tgr_dfs_create(dev);\n\n\tretval = gr_request_irq(dev, dev->irq);\n\tif (retval) {\n\t\tdev_err(dev->dev, \"Failed to request irq %d\\n\", dev->irq);\n\t\tgoto out;\n\t}\n\n\tif (dev->irqi) {\n\t\tretval = gr_request_irq(dev, dev->irqi);\n\t\tif (retval) {\n\t\t\tdev_err(dev->dev, \"Failed to request irqi %d\\n\",\n\t\t\t\tdev->irqi);\n\t\t\tgoto out;\n\t\t}\n\t\tretval = gr_request_irq(dev, dev->irqo);\n\t\tif (retval) {\n\t\t\tdev_err(dev->dev, \"Failed to request irqo %d\\n\",\n\t\t\t\tdev->irqo);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (dev->irqi)\n\t\tdev_info(dev->dev, \"regs: %p, irqs %d, %d, %d\\n\", dev->regs,\n\t\t\t dev->irq, dev->irqi, dev->irqo);\n\telse\n\t\tdev_info(dev->dev, \"regs: %p, irq %d\\n\", dev->regs, dev->irq);\n\nout:\n\tif (retval)\n\t\tgr_remove(pdev);\n\n\treturn retval;\n}\n\nstatic const struct of_device_id gr_match[] = {\n\t{.name = \"GAISLER_USBDC\"},\n\t{.name = \"01_021\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, gr_match);\n\nstatic struct platform_driver gr_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = gr_match,\n\t},\n\t.probe = gr_probe,\n\t.remove = gr_remove,\n};\nmodule_platform_driver(gr_driver);\n\nMODULE_AUTHOR(\"Aeroflex Gaisler AB.\");\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}