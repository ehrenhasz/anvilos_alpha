{
  "module_name": "dummy_hcd.c",
  "hash_id": "ea9645b4c56890b9e8f787434606be8f5bfcd6dfd418b9efcc49dde3250c22ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/dummy_hcd.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/hcd.h>\n#include <linux/scatterlist.h>\n\n#include <asm/byteorder.h>\n#include <linux/io.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n#define DRIVER_DESC\t\"USB Host+Gadget Emulator\"\n#define DRIVER_VERSION\t\"02 May 2005\"\n\n#define POWER_BUDGET\t500\t \n#define POWER_BUDGET_3\t900\t \n\nstatic const char\tdriver_name[] = \"dummy_hcd\";\nstatic const char\tdriver_desc[] = \"USB Host+Gadget Emulator\";\n\nstatic const char\tgadget_name[] = \"dummy_udc\";\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n\nstruct dummy_hcd_module_parameters {\n\tbool is_super_speed;\n\tbool is_high_speed;\n\tunsigned int num;\n};\n\nstatic struct dummy_hcd_module_parameters mod_data = {\n\t.is_super_speed = false,\n\t.is_high_speed = true,\n\t.num = 1,\n};\nmodule_param_named(is_super_speed, mod_data.is_super_speed, bool, S_IRUGO);\nMODULE_PARM_DESC(is_super_speed, \"true to simulate SuperSpeed connection\");\nmodule_param_named(is_high_speed, mod_data.is_high_speed, bool, S_IRUGO);\nMODULE_PARM_DESC(is_high_speed, \"true to simulate HighSpeed connection\");\nmodule_param_named(num, mod_data.num, uint, S_IRUGO);\nMODULE_PARM_DESC(num, \"number of emulated controllers\");\n \n\n \nstruct dummy_ep {\n\tstruct list_head\t\tqueue;\n\tunsigned long\t\t\tlast_io;\t \n\tstruct usb_gadget\t\t*gadget;\n\tconst struct usb_endpoint_descriptor *desc;\n\tstruct usb_ep\t\t\tep;\n\tunsigned\t\t\thalted:1;\n\tunsigned\t\t\twedged:1;\n\tunsigned\t\t\talready_seen:1;\n\tunsigned\t\t\tsetup_stage:1;\n\tunsigned\t\t\tstream_en:1;\n};\n\nstruct dummy_request {\n\tstruct list_head\t\tqueue;\t\t \n\tstruct usb_request\t\treq;\n};\n\nstatic inline struct dummy_ep *usb_ep_to_dummy_ep(struct usb_ep *_ep)\n{\n\treturn container_of(_ep, struct dummy_ep, ep);\n}\n\nstatic inline struct dummy_request *usb_request_to_dummy_request\n\t\t(struct usb_request *_req)\n{\n\treturn container_of(_req, struct dummy_request, req);\n}\n\n \n\n \n\nstatic const char ep0name[] = \"ep0\";\n\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} ep_info[] = {\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\n \n#define TYPE_BULK_OR_INT\t(USB_EP_CAPS_TYPE_BULK | USB_EP_CAPS_TYPE_INT)\n\n\t \n\tEP_INFO(ep0name,\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\t \n\tEP_INFO(\"ep1in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep2out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n \n\tEP_INFO(\"ep5in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep6in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep7out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n \n\tEP_INFO(\"ep10in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep11in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep12out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n \n\tEP_INFO(\"ep15in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\n\t \n\tEP_INFO(\"ep1out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep2in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\n\t \n\tEP_INFO(\"ep-aout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-bin\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep-cout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-dout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-ein\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep-fout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-gin\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep-hout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-iout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-jin\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep-kout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep-lin\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep-mout\",\n\t\tUSB_EP_CAPS(TYPE_BULK_OR_INT, USB_EP_CAPS_DIR_OUT)),\n\n#undef EP_INFO\n};\n\n#define DUMMY_ENDPOINTS\tARRAY_SIZE(ep_info)\n\n \n\n#define FIFO_SIZE\t\t64\n\nstruct urbp {\n\tstruct urb\t\t*urb;\n\tstruct list_head\turbp_list;\n\tstruct sg_mapping_iter\tmiter;\n\tu32\t\t\tmiter_started;\n};\n\n\nenum dummy_rh_state {\n\tDUMMY_RH_RESET,\n\tDUMMY_RH_SUSPENDED,\n\tDUMMY_RH_RUNNING\n};\n\nstruct dummy_hcd {\n\tstruct dummy\t\t\t*dum;\n\tenum dummy_rh_state\t\trh_state;\n\tstruct timer_list\t\ttimer;\n\tu32\t\t\t\tport_status;\n\tu32\t\t\t\told_status;\n\tunsigned long\t\t\tre_timeout;\n\n\tstruct usb_device\t\t*udev;\n\tstruct list_head\t\turbp_list;\n\tstruct urbp\t\t\t*next_frame_urbp;\n\n\tu32\t\t\t\tstream_en_ep;\n\tu8\t\t\t\tnum_stream[30 / 2];\n\n\tunsigned\t\t\tactive:1;\n\tunsigned\t\t\told_active:1;\n\tunsigned\t\t\tresuming:1;\n};\n\nstruct dummy {\n\tspinlock_t\t\t\tlock;\n\n\t \n\tstruct dummy_ep\t\t\tep[DUMMY_ENDPOINTS];\n\tint\t\t\t\taddress;\n\tint\t\t\t\tcallback_usage;\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\tstruct dummy_request\t\tfifo_req;\n\tu8\t\t\t\tfifo_buf[FIFO_SIZE];\n\tu16\t\t\t\tdevstatus;\n\tunsigned\t\t\tints_enabled:1;\n\tunsigned\t\t\tudc_suspended:1;\n\tunsigned\t\t\tpullup:1;\n\n\t \n\tstruct dummy_hcd\t\t*hs_hcd;\n\tstruct dummy_hcd\t\t*ss_hcd;\n};\n\nstatic inline struct dummy_hcd *hcd_to_dummy_hcd(struct usb_hcd *hcd)\n{\n\treturn (struct dummy_hcd *) (hcd->hcd_priv);\n}\n\nstatic inline struct usb_hcd *dummy_hcd_to_hcd(struct dummy_hcd *dum)\n{\n\treturn container_of((void *) dum, struct usb_hcd, hcd_priv);\n}\n\nstatic inline struct device *dummy_dev(struct dummy_hcd *dum)\n{\n\treturn dummy_hcd_to_hcd(dum)->self.controller;\n}\n\nstatic inline struct device *udc_dev(struct dummy *dum)\n{\n\treturn dum->gadget.dev.parent;\n}\n\nstatic inline struct dummy *ep_to_dummy(struct dummy_ep *ep)\n{\n\treturn container_of(ep->gadget, struct dummy, gadget);\n}\n\nstatic inline struct dummy_hcd *gadget_to_dummy_hcd(struct usb_gadget *gadget)\n{\n\tstruct dummy *dum = container_of(gadget, struct dummy, gadget);\n\tif (dum->gadget.speed == USB_SPEED_SUPER)\n\t\treturn dum->ss_hcd;\n\telse\n\t\treturn dum->hs_hcd;\n}\n\nstatic inline struct dummy *gadget_dev_to_dummy(struct device *dev)\n{\n\treturn container_of(dev, struct dummy, gadget.dev);\n}\n\n \n\n \n\n \nstatic void nuke(struct dummy *dum, struct dummy_ep *ep)\n{\n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct dummy_request\t*req;\n\n\t\treq = list_entry(ep->queue.next, struct dummy_request, queue);\n\t\tlist_del_init(&req->queue);\n\t\treq->req.status = -ESHUTDOWN;\n\n\t\tspin_unlock(&dum->lock);\n\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\tspin_lock(&dum->lock);\n\t}\n}\n\n \nstatic void stop_activity(struct dummy *dum)\n{\n\tint i;\n\n\t \n\tdum->address = 0;\n\n\t \n\n\t \n\tfor (i = 0; i < DUMMY_ENDPOINTS; ++i)\n\t\tnuke(dum, &dum->ep[i]);\n\n\t \n}\n\n \nstatic void set_link_state_by_speed(struct dummy_hcd *dum_hcd)\n{\n\tstruct dummy *dum = dum_hcd->dum;\n\n\tif (dummy_hcd_to_hcd(dum_hcd)->speed == HCD_USB3) {\n\t\tif ((dum_hcd->port_status & USB_SS_PORT_STAT_POWER) == 0) {\n\t\t\tdum_hcd->port_status = 0;\n\t\t} else if (!dum->pullup || dum->udc_suspended) {\n\t\t\t \n\t\t\tdum_hcd->port_status &= ~(USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t\tUSB_PORT_STAT_ENABLE);\n\t\t\tif ((dum_hcd->old_status &\n\t\t\t     USB_PORT_STAT_CONNECTION) != 0)\n\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\t\t} else {\n\t\t\t \n\t\t\tdum_hcd->port_status |= (USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t\t USB_PORT_STAT_SPEED_5GBPS) ;\n\t\t\tif ((dum_hcd->old_status &\n\t\t\t     USB_PORT_STAT_CONNECTION) == 0)\n\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\t\t\tif ((dum_hcd->port_status & USB_PORT_STAT_ENABLE) &&\n\t\t\t    (dum_hcd->port_status &\n\t\t\t     USB_PORT_STAT_LINK_STATE) == USB_SS_PORT_LS_U0 &&\n\t\t\t    dum_hcd->rh_state != DUMMY_RH_SUSPENDED)\n\t\t\t\tdum_hcd->active = 1;\n\t\t}\n\t} else {\n\t\tif ((dum_hcd->port_status & USB_PORT_STAT_POWER) == 0) {\n\t\t\tdum_hcd->port_status = 0;\n\t\t} else if (!dum->pullup || dum->udc_suspended) {\n\t\t\t \n\t\t\tdum_hcd->port_status &= ~(USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t\tUSB_PORT_STAT_ENABLE |\n\t\t\t\t\t\tUSB_PORT_STAT_LOW_SPEED |\n\t\t\t\t\t\tUSB_PORT_STAT_HIGH_SPEED |\n\t\t\t\t\t\tUSB_PORT_STAT_SUSPEND);\n\t\t\tif ((dum_hcd->old_status &\n\t\t\t     USB_PORT_STAT_CONNECTION) != 0)\n\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\t\t} else {\n\t\t\tdum_hcd->port_status |= USB_PORT_STAT_CONNECTION;\n\t\t\tif ((dum_hcd->old_status &\n\t\t\t     USB_PORT_STAT_CONNECTION) == 0)\n\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t(USB_PORT_STAT_C_CONNECTION << 16);\n\t\t\tif ((dum_hcd->port_status & USB_PORT_STAT_ENABLE) == 0)\n\t\t\t\tdum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\n\t\t\telse if ((dum_hcd->port_status &\n\t\t\t\t  USB_PORT_STAT_SUSPEND) == 0 &&\n\t\t\t\t\tdum_hcd->rh_state != DUMMY_RH_SUSPENDED)\n\t\t\t\tdum_hcd->active = 1;\n\t\t}\n\t}\n}\n\n \nstatic void set_link_state(struct dummy_hcd *dum_hcd)\n\t__must_hold(&dum->lock)\n{\n\tstruct dummy *dum = dum_hcd->dum;\n\tunsigned int power_bit;\n\n\tdum_hcd->active = 0;\n\tif (dum->pullup)\n\t\tif ((dummy_hcd_to_hcd(dum_hcd)->speed == HCD_USB3 &&\n\t\t     dum->gadget.speed != USB_SPEED_SUPER) ||\n\t\t    (dummy_hcd_to_hcd(dum_hcd)->speed != HCD_USB3 &&\n\t\t     dum->gadget.speed == USB_SPEED_SUPER))\n\t\t\treturn;\n\n\tset_link_state_by_speed(dum_hcd);\n\tpower_bit = (dummy_hcd_to_hcd(dum_hcd)->speed == HCD_USB3 ?\n\t\t\tUSB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);\n\n\tif ((dum_hcd->port_status & USB_PORT_STAT_ENABLE) == 0 ||\n\t     dum_hcd->active)\n\t\tdum_hcd->resuming = 0;\n\n\t \n\tif ((dum_hcd->port_status & power_bit) == 0 ||\n\t\t\t(dum_hcd->port_status & USB_PORT_STAT_RESET) != 0) {\n\t\tunsigned int disconnect = power_bit &\n\t\t\t\tdum_hcd->old_status & (~dum_hcd->port_status);\n\t\tunsigned int reset = USB_PORT_STAT_RESET &\n\t\t\t\t(~dum_hcd->old_status) & dum_hcd->port_status;\n\n\t\t \n\t\tif (dum->ints_enabled && (disconnect || reset)) {\n\t\t\tstop_activity(dum);\n\t\t\t++dum->callback_usage;\n\t\t\tspin_unlock(&dum->lock);\n\t\t\tif (reset)\n\t\t\t\tusb_gadget_udc_reset(&dum->gadget, dum->driver);\n\t\t\telse\n\t\t\t\tdum->driver->disconnect(&dum->gadget);\n\t\t\tspin_lock(&dum->lock);\n\t\t\t--dum->callback_usage;\n\t\t}\n\t} else if (dum_hcd->active != dum_hcd->old_active &&\n\t\t\tdum->ints_enabled) {\n\t\t++dum->callback_usage;\n\t\tspin_unlock(&dum->lock);\n\t\tif (dum_hcd->old_active && dum->driver->suspend)\n\t\t\tdum->driver->suspend(&dum->gadget);\n\t\telse if (!dum_hcd->old_active &&  dum->driver->resume)\n\t\t\tdum->driver->resume(&dum->gadget);\n\t\tspin_lock(&dum->lock);\n\t\t--dum->callback_usage;\n\t}\n\n\tdum_hcd->old_status = dum_hcd->port_status;\n\tdum_hcd->old_active = dum_hcd->active;\n}\n\n \n\n \n\n#define is_enabled(dum) \\\n\t(dum->port_status & USB_PORT_STAT_ENABLE)\n\nstatic int dummy_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct dummy\t\t*dum;\n\tstruct dummy_hcd\t*dum_hcd;\n\tstruct dummy_ep\t\t*ep;\n\tunsigned\t\tmax;\n\tint\t\t\tretval;\n\n\tep = usb_ep_to_dummy_ep(_ep);\n\tif (!_ep || !desc || ep->desc || _ep->name == ep0name\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\tdum = ep_to_dummy(ep);\n\tif (!dum->driver)\n\t\treturn -ESHUTDOWN;\n\n\tdum_hcd = gadget_to_dummy_hcd(&dum->gadget);\n\tif (!is_enabled(dum_hcd))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tmax = usb_endpoint_maxp(desc);\n\n\t \n\tretval = -EINVAL;\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (strstr(ep->ep.name, \"-iso\")\n\t\t\t\t|| strstr(ep->ep.name, \"-int\")) {\n\t\t\tgoto done;\n\t\t}\n\t\tswitch (dum->gadget.speed) {\n\t\tcase USB_SPEED_SUPER:\n\t\t\tif (max == 1024)\n\t\t\t\tbreak;\n\t\t\tgoto done;\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (max == 512)\n\t\t\t\tbreak;\n\t\t\tgoto done;\n\t\tcase USB_SPEED_FULL:\n\t\t\tif (max == 8 || max == 16 || max == 32 || max == 64)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (strstr(ep->ep.name, \"-iso\"))  \n\t\t\tgoto done;\n\t\t \n\t\tswitch (dum->gadget.speed) {\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (max <= 1024)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase USB_SPEED_FULL:\n\t\t\tif (max <= 64)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (max <= 8)\n\t\t\t\tbreak;\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (strstr(ep->ep.name, \"-bulk\")\n\t\t\t\t|| strstr(ep->ep.name, \"-int\"))\n\t\t\tgoto done;\n\t\t \n\t\tswitch (dum->gadget.speed) {\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\tif (max <= 1024)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase USB_SPEED_FULL:\n\t\t\tif (max <= 1023)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tgoto done;\n\t}\n\n\t_ep->maxpacket = max;\n\tif (usb_ss_max_streams(_ep->comp_desc)) {\n\t\tif (!usb_endpoint_xfer_bulk(desc)) {\n\t\t\tdev_err(udc_dev(dum), \"Can't enable stream support on \"\n\t\t\t\t\t\"non-bulk ep %s\\n\", _ep->name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tep->stream_en = 1;\n\t}\n\tep->desc = desc;\n\n\tdev_dbg(udc_dev(dum), \"enabled %s (ep%d%s-%s) maxpacket %d stream %s\\n\",\n\t\t_ep->name,\n\t\tdesc->bEndpointAddress & 0x0f,\n\t\t(desc->bEndpointAddress & USB_DIR_IN) ? \"in\" : \"out\",\n\t\tusb_ep_type_string(usb_endpoint_type(desc)),\n\t\tmax, ep->stream_en ? \"enabled\" : \"disabled\");\n\n\t \n\tep->halted = ep->wedged = 0;\n\tretval = 0;\ndone:\n\treturn retval;\n}\n\nstatic int dummy_disable(struct usb_ep *_ep)\n{\n\tstruct dummy_ep\t\t*ep;\n\tstruct dummy\t\t*dum;\n\tunsigned long\t\tflags;\n\n\tep = usb_ep_to_dummy_ep(_ep);\n\tif (!_ep || !ep->desc || _ep->name == ep0name)\n\t\treturn -EINVAL;\n\tdum = ep_to_dummy(ep);\n\n\tspin_lock_irqsave(&dum->lock, flags);\n\tep->desc = NULL;\n\tep->stream_en = 0;\n\tnuke(dum, ep);\n\tspin_unlock_irqrestore(&dum->lock, flags);\n\n\tdev_dbg(udc_dev(dum), \"disabled %s\\n\", _ep->name);\n\treturn 0;\n}\n\nstatic struct usb_request *dummy_alloc_request(struct usb_ep *_ep,\n\t\tgfp_t mem_flags)\n{\n\tstruct dummy_request\t*req;\n\n\tif (!_ep)\n\t\treturn NULL;\n\n\treq = kzalloc(sizeof(*req), mem_flags);\n\tif (!req)\n\t\treturn NULL;\n\tINIT_LIST_HEAD(&req->queue);\n\treturn &req->req;\n}\n\nstatic void dummy_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct dummy_request\t*req;\n\n\tif (!_ep || !_req) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\treq = usb_request_to_dummy_request(_req);\n\tWARN_ON(!list_empty(&req->queue));\n\tkfree(req);\n}\n\nstatic void fifo_complete(struct usb_ep *ep, struct usb_request *req)\n{\n}\n\nstatic int dummy_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\tgfp_t mem_flags)\n{\n\tstruct dummy_ep\t\t*ep;\n\tstruct dummy_request\t*req;\n\tstruct dummy\t\t*dum;\n\tstruct dummy_hcd\t*dum_hcd;\n\tunsigned long\t\tflags;\n\n\treq = usb_request_to_dummy_request(_req);\n\tif (!_req || !list_empty(&req->queue) || !_req->complete)\n\t\treturn -EINVAL;\n\n\tep = usb_ep_to_dummy_ep(_ep);\n\tif (!_ep || (!ep->desc && _ep->name != ep0name))\n\t\treturn -EINVAL;\n\n\tdum = ep_to_dummy(ep);\n\tdum_hcd = gadget_to_dummy_hcd(&dum->gadget);\n\tif (!dum->driver || !is_enabled(dum_hcd))\n\t\treturn -ESHUTDOWN;\n\n#if 0\n\tdev_dbg(udc_dev(dum), \"ep %p queue req %p to %s, len %d buf %p\\n\",\n\t\t\tep, _req, _ep->name, _req->length, _req->buf);\n#endif\n\t_req->status = -EINPROGRESS;\n\t_req->actual = 0;\n\tspin_lock_irqsave(&dum->lock, flags);\n\n\t \n\tif (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\n\t\t\tlist_empty(&dum->fifo_req.queue) &&\n\t\t\tlist_empty(&ep->queue) &&\n\t\t\t_req->length <= FIFO_SIZE) {\n\t\treq = &dum->fifo_req;\n\t\treq->req = *_req;\n\t\treq->req.buf = dum->fifo_buf;\n\t\tmemcpy(dum->fifo_buf, _req->buf, _req->length);\n\t\treq->req.context = dum;\n\t\treq->req.complete = fifo_complete;\n\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\t\tspin_unlock(&dum->lock);\n\t\t_req->actual = _req->length;\n\t\t_req->status = 0;\n\t\tusb_gadget_giveback_request(_ep, _req);\n\t\tspin_lock(&dum->lock);\n\t}  else\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\tspin_unlock_irqrestore(&dum->lock, flags);\n\n\t \n\treturn 0;\n}\n\nstatic int dummy_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct dummy_ep\t\t*ep;\n\tstruct dummy\t\t*dum;\n\tint\t\t\tretval = -EINVAL;\n\tunsigned long\t\tflags;\n\tstruct dummy_request\t*req = NULL, *iter;\n\n\tif (!_ep || !_req)\n\t\treturn retval;\n\tep = usb_ep_to_dummy_ep(_ep);\n\tdum = ep_to_dummy(ep);\n\n\tif (!dum->driver)\n\t\treturn -ESHUTDOWN;\n\n\tlocal_irq_save(flags);\n\tspin_lock(&dum->lock);\n\tlist_for_each_entry(iter, &ep->queue, queue) {\n\t\tif (&iter->req != _req)\n\t\t\tcontinue;\n\t\tlist_del_init(&iter->queue);\n\t\t_req->status = -ECONNRESET;\n\t\treq = iter;\n\t\tretval = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&dum->lock);\n\n\tif (retval == 0) {\n\t\tdev_dbg(udc_dev(dum),\n\t\t\t\t\"dequeued req %p from %s, len %d buf %p\\n\",\n\t\t\t\treq, _ep->name, _req->length, _req->buf);\n\t\tusb_gadget_giveback_request(_ep, _req);\n\t}\n\tlocal_irq_restore(flags);\n\treturn retval;\n}\n\nstatic int\ndummy_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\n{\n\tstruct dummy_ep\t\t*ep;\n\tstruct dummy\t\t*dum;\n\n\tif (!_ep)\n\t\treturn -EINVAL;\n\tep = usb_ep_to_dummy_ep(_ep);\n\tdum = ep_to_dummy(ep);\n\tif (!dum->driver)\n\t\treturn -ESHUTDOWN;\n\tif (!value)\n\t\tep->halted = ep->wedged = 0;\n\telse if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\n\t\t\t!list_empty(&ep->queue))\n\t\treturn -EAGAIN;\n\telse {\n\t\tep->halted = 1;\n\t\tif (wedged)\n\t\t\tep->wedged = 1;\n\t}\n\t \n\treturn 0;\n}\n\nstatic int\ndummy_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn dummy_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int dummy_set_wedge(struct usb_ep *_ep)\n{\n\tif (!_ep || _ep->name == ep0name)\n\t\treturn -EINVAL;\n\treturn dummy_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic const struct usb_ep_ops dummy_ep_ops = {\n\t.enable\t\t= dummy_enable,\n\t.disable\t= dummy_disable,\n\n\t.alloc_request\t= dummy_alloc_request,\n\t.free_request\t= dummy_free_request,\n\n\t.queue\t\t= dummy_queue,\n\t.dequeue\t= dummy_dequeue,\n\n\t.set_halt\t= dummy_set_halt,\n\t.set_wedge\t= dummy_set_wedge,\n};\n\n \n\n \nstatic int dummy_g_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct timespec64 ts64;\n\n\tktime_get_ts64(&ts64);\n\treturn ts64.tv_nsec / NSEC_PER_MSEC;\n}\n\nstatic int dummy_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct dummy_hcd *dum_hcd;\n\n\tdum_hcd = gadget_to_dummy_hcd(_gadget);\n\tif (!(dum_hcd->dum->devstatus & ((1 << USB_DEVICE_B_HNP_ENABLE)\n\t\t\t\t| (1 << USB_DEVICE_REMOTE_WAKEUP))))\n\t\treturn -EINVAL;\n\tif ((dum_hcd->port_status & USB_PORT_STAT_CONNECTION) == 0)\n\t\treturn -ENOLINK;\n\tif ((dum_hcd->port_status & USB_PORT_STAT_SUSPEND) == 0 &&\n\t\t\t dum_hcd->rh_state != DUMMY_RH_SUSPENDED)\n\t\treturn -EIO;\n\n\t \n\n\t \n\tdum_hcd->resuming = 1;\n\tdum_hcd->re_timeout = jiffies + msecs_to_jiffies(20);\n\tmod_timer(&dummy_hcd_to_hcd(dum_hcd)->rh_timer, dum_hcd->re_timeout);\n\treturn 0;\n}\n\nstatic int dummy_set_selfpowered(struct usb_gadget *_gadget, int value)\n{\n\tstruct dummy\t*dum;\n\n\t_gadget->is_selfpowered = (value != 0);\n\tdum = gadget_to_dummy_hcd(_gadget)->dum;\n\tif (value)\n\t\tdum->devstatus |= (1 << USB_DEVICE_SELF_POWERED);\n\telse\n\t\tdum->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\treturn 0;\n}\n\nstatic void dummy_udc_update_ep0(struct dummy *dum)\n{\n\tif (dum->gadget.speed == USB_SPEED_SUPER)\n\t\tdum->ep[0].ep.maxpacket = 9;\n\telse\n\t\tdum->ep[0].ep.maxpacket = 64;\n}\n\nstatic int dummy_pullup(struct usb_gadget *_gadget, int value)\n{\n\tstruct dummy_hcd *dum_hcd;\n\tstruct dummy\t*dum;\n\tunsigned long\tflags;\n\n\tdum = gadget_dev_to_dummy(&_gadget->dev);\n\tdum_hcd = gadget_to_dummy_hcd(_gadget);\n\n\tspin_lock_irqsave(&dum->lock, flags);\n\tdum->pullup = (value != 0);\n\tset_link_state(dum_hcd);\n\tif (value == 0) {\n\t\t \n\t\twhile (dum->callback_usage > 0) {\n\t\t\tspin_unlock_irqrestore(&dum->lock, flags);\n\t\t\tusleep_range(1000, 2000);\n\t\t\tspin_lock_irqsave(&dum->lock, flags);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dum->lock, flags);\n\n\tusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\n\treturn 0;\n}\n\nstatic void dummy_udc_set_speed(struct usb_gadget *_gadget,\n\t\tenum usb_device_speed speed)\n{\n\tstruct dummy\t*dum;\n\n\tdum = gadget_dev_to_dummy(&_gadget->dev);\n\tdum->gadget.speed = speed;\n\tdummy_udc_update_ep0(dum);\n}\n\nstatic void dummy_udc_async_callbacks(struct usb_gadget *_gadget, bool enable)\n{\n\tstruct dummy\t*dum = gadget_dev_to_dummy(&_gadget->dev);\n\n\tspin_lock_irq(&dum->lock);\n\tdum->ints_enabled = enable;\n\tspin_unlock_irq(&dum->lock);\n}\n\nstatic int dummy_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int dummy_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops dummy_ops = {\n\t.get_frame\t= dummy_g_get_frame,\n\t.wakeup\t\t= dummy_wakeup,\n\t.set_selfpowered = dummy_set_selfpowered,\n\t.pullup\t\t= dummy_pullup,\n\t.udc_start\t= dummy_udc_start,\n\t.udc_stop\t= dummy_udc_stop,\n\t.udc_set_speed\t= dummy_udc_set_speed,\n\t.udc_async_callbacks = dummy_udc_async_callbacks,\n};\n\n \n\n \nstatic ssize_t function_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct dummy\t*dum = gadget_dev_to_dummy(dev);\n\n\tif (!dum->driver || !dum->driver->function)\n\t\treturn 0;\n\treturn scnprintf(buf, PAGE_SIZE, \"%s\\n\", dum->driver->function);\n}\nstatic DEVICE_ATTR_RO(function);\n\n \n\n \n\nstatic int dummy_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct dummy_hcd\t*dum_hcd = gadget_to_dummy_hcd(g);\n\tstruct dummy\t\t*dum = dum_hcd->dum;\n\n\tswitch (g->speed) {\n\t \n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dummy_dev(dum_hcd), \"Unsupported driver max speed %d\\n\",\n\t\t\t\tdriver->max_speed);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tspin_lock_irq(&dum->lock);\n\tdum->devstatus = 0;\n\tdum->driver = driver;\n\tspin_unlock_irq(&dum->lock);\n\n\treturn 0;\n}\n\nstatic int dummy_udc_stop(struct usb_gadget *g)\n{\n\tstruct dummy_hcd\t*dum_hcd = gadget_to_dummy_hcd(g);\n\tstruct dummy\t\t*dum = dum_hcd->dum;\n\n\tspin_lock_irq(&dum->lock);\n\tdum->ints_enabled = 0;\n\tstop_activity(dum);\n\tdum->driver = NULL;\n\tspin_unlock_irq(&dum->lock);\n\n\treturn 0;\n}\n\n#undef is_enabled\n\n \nstatic void init_dummy_udc_hw(struct dummy *dum)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&dum->gadget.ep_list);\n\tfor (i = 0; i < DUMMY_ENDPOINTS; i++) {\n\t\tstruct dummy_ep\t*ep = &dum->ep[i];\n\n\t\tif (!ep_info[i].name)\n\t\t\tbreak;\n\t\tep->ep.name = ep_info[i].name;\n\t\tep->ep.caps = ep_info[i].caps;\n\t\tep->ep.ops = &dummy_ep_ops;\n\t\tlist_add_tail(&ep->ep.ep_list, &dum->gadget.ep_list);\n\t\tep->halted = ep->wedged = ep->already_seen =\n\t\t\t\tep->setup_stage = 0;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ~0);\n\t\tep->ep.max_streams = 16;\n\t\tep->last_io = jiffies;\n\t\tep->gadget = &dum->gadget;\n\t\tep->desc = NULL;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t}\n\n\tdum->gadget.ep0 = &dum->ep[0].ep;\n\tlist_del_init(&dum->ep[0].ep.ep_list);\n\tINIT_LIST_HEAD(&dum->fifo_req.queue);\n\n#ifdef CONFIG_USB_OTG\n\tdum->gadget.is_otg = 1;\n#endif\n}\n\nstatic int dummy_udc_probe(struct platform_device *pdev)\n{\n\tstruct dummy\t*dum;\n\tint\t\trc;\n\n\tdum = *((void **)dev_get_platdata(&pdev->dev));\n\t \n\tmemzero_explicit(&dum->gadget, sizeof(struct usb_gadget));\n\tdum->gadget.name = gadget_name;\n\tdum->gadget.ops = &dummy_ops;\n\tif (mod_data.is_super_speed)\n\t\tdum->gadget.max_speed = USB_SPEED_SUPER;\n\telse if (mod_data.is_high_speed)\n\t\tdum->gadget.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tdum->gadget.max_speed = USB_SPEED_FULL;\n\n\tdum->gadget.dev.parent = &pdev->dev;\n\tinit_dummy_udc_hw(dum);\n\n\trc = usb_add_gadget_udc(&pdev->dev, &dum->gadget);\n\tif (rc < 0)\n\t\tgoto err_udc;\n\n\trc = device_create_file(&dum->gadget.dev, &dev_attr_function);\n\tif (rc < 0)\n\t\tgoto err_dev;\n\tplatform_set_drvdata(pdev, dum);\n\treturn rc;\n\nerr_dev:\n\tusb_del_gadget_udc(&dum->gadget);\nerr_udc:\n\treturn rc;\n}\n\nstatic void dummy_udc_remove(struct platform_device *pdev)\n{\n\tstruct dummy\t*dum = platform_get_drvdata(pdev);\n\n\tdevice_remove_file(&dum->gadget.dev, &dev_attr_function);\n\tusb_del_gadget_udc(&dum->gadget);\n}\n\nstatic void dummy_udc_pm(struct dummy *dum, struct dummy_hcd *dum_hcd,\n\t\tint suspend)\n{\n\tspin_lock_irq(&dum->lock);\n\tdum->udc_suspended = suspend;\n\tset_link_state(dum_hcd);\n\tspin_unlock_irq(&dum->lock);\n}\n\nstatic int dummy_udc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct dummy\t\t*dum = platform_get_drvdata(pdev);\n\tstruct dummy_hcd\t*dum_hcd = gadget_to_dummy_hcd(&dum->gadget);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\tdummy_udc_pm(dum, dum_hcd, 1);\n\tusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\n\treturn 0;\n}\n\nstatic int dummy_udc_resume(struct platform_device *pdev)\n{\n\tstruct dummy\t\t*dum = platform_get_drvdata(pdev);\n\tstruct dummy_hcd\t*dum_hcd = gadget_to_dummy_hcd(&dum->gadget);\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\tdummy_udc_pm(dum, dum_hcd, 0);\n\tusb_hcd_poll_rh_status(dummy_hcd_to_hcd(dum_hcd));\n\treturn 0;\n}\n\nstatic struct platform_driver dummy_udc_driver = {\n\t.probe\t\t= dummy_udc_probe,\n\t.remove_new\t= dummy_udc_remove,\n\t.suspend\t= dummy_udc_suspend,\n\t.resume\t\t= dummy_udc_resume,\n\t.driver\t\t= {\n\t\t.name\t= gadget_name,\n\t},\n};\n\n \n\nstatic unsigned int dummy_get_ep_idx(const struct usb_endpoint_descriptor *desc)\n{\n\tunsigned int index;\n\n\tindex = usb_endpoint_num(desc) << 1;\n\tif (usb_endpoint_dir_in(desc))\n\t\tindex |= 1;\n\treturn index;\n}\n\n \n\nstatic int dummy_ep_stream_en(struct dummy_hcd *dum_hcd, struct urb *urb)\n{\n\tconst struct usb_endpoint_descriptor *desc = &urb->ep->desc;\n\tu32 index;\n\n\tif (!usb_endpoint_xfer_bulk(desc))\n\t\treturn 0;\n\n\tindex = dummy_get_ep_idx(desc);\n\treturn (1 << index) & dum_hcd->stream_en_ep;\n}\n\n \nstatic int get_max_streams_for_pipe(struct dummy_hcd *dum_hcd,\n\t\tunsigned int pipe)\n{\n\tint max_streams;\n\n\tmax_streams = dum_hcd->num_stream[usb_pipeendpoint(pipe)];\n\tif (usb_pipeout(pipe))\n\t\tmax_streams >>= 4;\n\telse\n\t\tmax_streams &= 0xf;\n\tmax_streams++;\n\treturn max_streams;\n}\n\nstatic void set_max_streams_for_pipe(struct dummy_hcd *dum_hcd,\n\t\tunsigned int pipe, unsigned int streams)\n{\n\tint max_streams;\n\n\tstreams--;\n\tmax_streams = dum_hcd->num_stream[usb_pipeendpoint(pipe)];\n\tif (usb_pipeout(pipe)) {\n\t\tstreams <<= 4;\n\t\tmax_streams &= 0xf;\n\t} else {\n\t\tmax_streams &= 0xf0;\n\t}\n\tmax_streams |= streams;\n\tdum_hcd->num_stream[usb_pipeendpoint(pipe)] = max_streams;\n}\n\nstatic int dummy_validate_stream(struct dummy_hcd *dum_hcd, struct urb *urb)\n{\n\tunsigned int max_streams;\n\tint enabled;\n\n\tenabled = dummy_ep_stream_en(dum_hcd, urb);\n\tif (!urb->stream_id) {\n\t\tif (enabled)\n\t\t\treturn -EINVAL;\n\t\treturn 0;\n\t}\n\tif (!enabled)\n\t\treturn -EINVAL;\n\n\tmax_streams = get_max_streams_for_pipe(dum_hcd,\n\t\t\tusb_pipeendpoint(urb->pipe));\n\tif (urb->stream_id > max_streams) {\n\t\tdev_err(dummy_dev(dum_hcd), \"Stream id %d is out of range.\\n\",\n\t\t\t\turb->stream_id);\n\t\tBUG();\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int dummy_urb_enqueue(\n\tstruct usb_hcd\t\t\t*hcd,\n\tstruct urb\t\t\t*urb,\n\tgfp_t\t\t\t\tmem_flags\n) {\n\tstruct dummy_hcd *dum_hcd;\n\tstruct urbp\t*urbp;\n\tunsigned long\tflags;\n\tint\t\trc;\n\n\turbp = kmalloc(sizeof *urbp, mem_flags);\n\tif (!urbp)\n\t\treturn -ENOMEM;\n\turbp->urb = urb;\n\turbp->miter_started = 0;\n\n\tdum_hcd = hcd_to_dummy_hcd(hcd);\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\n\trc = dummy_validate_stream(dum_hcd, urb);\n\tif (rc) {\n\t\tkfree(urbp);\n\t\tgoto done;\n\t}\n\n\trc = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (rc) {\n\t\tkfree(urbp);\n\t\tgoto done;\n\t}\n\n\tif (!dum_hcd->udev) {\n\t\tdum_hcd->udev = urb->dev;\n\t\tusb_get_dev(dum_hcd->udev);\n\t} else if (unlikely(dum_hcd->udev != urb->dev))\n\t\tdev_err(dummy_dev(dum_hcd), \"usb_device address has changed!\\n\");\n\n\tlist_add_tail(&urbp->urbp_list, &dum_hcd->urbp_list);\n\turb->hcpriv = urbp;\n\tif (!dum_hcd->next_frame_urbp)\n\t\tdum_hcd->next_frame_urbp = urbp;\n\tif (usb_pipetype(urb->pipe) == PIPE_CONTROL)\n\t\turb->error_count = 1;\t\t \n\n\t \n\tif (!timer_pending(&dum_hcd->timer))\n\t\tmod_timer(&dum_hcd->timer, jiffies + 1);\n\n done:\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\treturn rc;\n}\n\nstatic int dummy_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct dummy_hcd *dum_hcd;\n\tunsigned long\tflags;\n\tint\t\trc;\n\n\t \n\tdum_hcd = hcd_to_dummy_hcd(hcd);\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (!rc && dum_hcd->rh_state != DUMMY_RH_RUNNING &&\n\t\t\t!list_empty(&dum_hcd->urbp_list))\n\t\tmod_timer(&dum_hcd->timer, jiffies);\n\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\treturn rc;\n}\n\nstatic int dummy_perform_transfer(struct urb *urb, struct dummy_request *req,\n\t\tu32 len)\n{\n\tvoid *ubuf, *rbuf;\n\tstruct urbp *urbp = urb->hcpriv;\n\tint to_host;\n\tstruct sg_mapping_iter *miter = &urbp->miter;\n\tu32 trans = 0;\n\tu32 this_sg;\n\tbool next_sg;\n\n\tto_host = usb_urb_dir_in(urb);\n\trbuf = req->req.buf + req->req.actual;\n\n\tif (!urb->num_sgs) {\n\t\tubuf = urb->transfer_buffer + urb->actual_length;\n\t\tif (to_host)\n\t\t\tmemcpy(ubuf, rbuf, len);\n\t\telse\n\t\t\tmemcpy(rbuf, ubuf, len);\n\t\treturn len;\n\t}\n\n\tif (!urbp->miter_started) {\n\t\tu32 flags = SG_MITER_ATOMIC;\n\n\t\tif (to_host)\n\t\t\tflags |= SG_MITER_TO_SG;\n\t\telse\n\t\t\tflags |= SG_MITER_FROM_SG;\n\n\t\tsg_miter_start(miter, urb->sg, urb->num_sgs, flags);\n\t\turbp->miter_started = 1;\n\t}\n\tnext_sg = sg_miter_next(miter);\n\tif (next_sg == false) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\tdo {\n\t\tubuf = miter->addr;\n\t\tthis_sg = min_t(u32, len, miter->length);\n\t\tmiter->consumed = this_sg;\n\t\ttrans += this_sg;\n\n\t\tif (to_host)\n\t\t\tmemcpy(ubuf, rbuf, this_sg);\n\t\telse\n\t\t\tmemcpy(rbuf, ubuf, this_sg);\n\t\tlen -= this_sg;\n\n\t\tif (!len)\n\t\t\tbreak;\n\t\tnext_sg = sg_miter_next(miter);\n\t\tif (next_sg == false) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trbuf += this_sg;\n\t} while (1);\n\n\tsg_miter_stop(miter);\n\treturn trans;\n}\n\n \nstatic int transfer(struct dummy_hcd *dum_hcd, struct urb *urb,\n\t\tstruct dummy_ep *ep, int limit, int *status)\n{\n\tstruct dummy\t\t*dum = dum_hcd->dum;\n\tstruct dummy_request\t*req;\n\tint\t\t\tsent = 0;\n\ntop:\n\t \n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tunsigned\thost_len, dev_len, len;\n\t\tint\t\tis_short, to_host;\n\t\tint\t\trescan = 0;\n\n\t\tif (dummy_ep_stream_en(dum_hcd, urb)) {\n\t\t\tif ((urb->stream_id != req->req.stream_id))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\thost_len = urb->transfer_buffer_length - urb->actual_length;\n\t\tdev_len = req->req.length - req->req.actual;\n\t\tlen = min(host_len, dev_len);\n\n\t\t \n\n\t\tto_host = usb_urb_dir_in(urb);\n\t\tif (unlikely(len == 0))\n\t\t\tis_short = 1;\n\t\telse {\n\t\t\t \n\t\t\tif (limit < ep->ep.maxpacket && limit < len)\n\t\t\t\tbreak;\n\t\t\tlen = min_t(unsigned, len, limit);\n\t\t\tif (len == 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (len >= ep->ep.maxpacket) {\n\t\t\t\tis_short = 0;\n\t\t\t\tif (len % ep->ep.maxpacket)\n\t\t\t\t\trescan = 1;\n\t\t\t\tlen -= len % ep->ep.maxpacket;\n\t\t\t} else {\n\t\t\t\tis_short = 1;\n\t\t\t}\n\n\t\t\tlen = dummy_perform_transfer(urb, req, len);\n\n\t\t\tep->last_io = jiffies;\n\t\t\tif ((int)len < 0) {\n\t\t\t\treq->req.status = len;\n\t\t\t} else {\n\t\t\t\tlimit -= len;\n\t\t\t\tsent += len;\n\t\t\t\turb->actual_length += len;\n\t\t\t\treq->req.actual += len;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (is_short) {\n\t\t\tif (host_len == dev_len) {\n\t\t\t\treq->req.status = 0;\n\t\t\t\t*status = 0;\n\t\t\t} else if (to_host) {\n\t\t\t\treq->req.status = 0;\n\t\t\t\tif (dev_len > host_len)\n\t\t\t\t\t*status = -EOVERFLOW;\n\t\t\t\telse\n\t\t\t\t\t*status = 0;\n\t\t\t} else {\n\t\t\t\t*status = 0;\n\t\t\t\tif (host_len > dev_len)\n\t\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\telse\n\t\t\t\t\treq->req.status = 0;\n\t\t\t}\n\n\t\t \n\t\t} else {\n\t\t\tif (req->req.length == req->req.actual) {\n\t\t\t\tif (req->req.zero && to_host)\n\t\t\t\t\trescan = 1;\n\t\t\t\telse\n\t\t\t\t\treq->req.status = 0;\n\t\t\t}\n\t\t\tif (urb->transfer_buffer_length == urb->actual_length) {\n\t\t\t\tif (urb->transfer_flags & URB_ZERO_PACKET &&\n\t\t\t\t    !to_host)\n\t\t\t\t\trescan = 1;\n\t\t\t\telse\n\t\t\t\t\t*status = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (req->req.status != -EINPROGRESS) {\n\t\t\tlist_del_init(&req->queue);\n\n\t\t\tspin_unlock(&dum->lock);\n\t\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\t\tspin_lock(&dum->lock);\n\n\t\t\t \n\t\t\trescan = 1;\n\t\t}\n\n\t\t \n\t\tif (*status != -EINPROGRESS)\n\t\t\tbreak;\n\n\t\t \n\t\tif (rescan)\n\t\t\tgoto top;\n\t}\n\treturn sent;\n}\n\nstatic int periodic_bytes(struct dummy *dum, struct dummy_ep *ep)\n{\n\tint\tlimit = ep->ep.maxpacket;\n\n\tif (dum->gadget.speed == USB_SPEED_HIGH) {\n\t\tint\ttmp;\n\n\t\t \n\t\ttmp = usb_endpoint_maxp_mult(ep->desc);\n\t\ttmp *= 8  ;\n\t\tlimit += limit * tmp;\n\t}\n\tif (dum->gadget.speed == USB_SPEED_SUPER) {\n\t\tswitch (usb_endpoint_type(ep->desc)) {\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t \n\t\t\tlimit = 3 * 16 * 1024 * 8;\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t \n\t\t\tlimit = 3 * 1024 * 8;\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn limit;\n}\n\n#define is_active(dum_hcd)\t((dum_hcd->port_status & \\\n\t\t(USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE | \\\n\t\t\tUSB_PORT_STAT_SUSPEND)) \\\n\t\t== (USB_PORT_STAT_CONNECTION | USB_PORT_STAT_ENABLE))\n\nstatic struct dummy_ep *find_endpoint(struct dummy *dum, u8 address)\n{\n\tint\t\ti;\n\n\tif (!is_active((dum->gadget.speed == USB_SPEED_SUPER ?\n\t\t\tdum->ss_hcd : dum->hs_hcd)))\n\t\treturn NULL;\n\tif (!dum->ints_enabled)\n\t\treturn NULL;\n\tif ((address & ~USB_DIR_IN) == 0)\n\t\treturn &dum->ep[0];\n\tfor (i = 1; i < DUMMY_ENDPOINTS; i++) {\n\t\tstruct dummy_ep\t*ep = &dum->ep[i];\n\n\t\tif (!ep->desc)\n\t\t\tcontinue;\n\t\tif (ep->desc->bEndpointAddress == address)\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n#undef is_active\n\n#define Dev_Request\t(USB_TYPE_STANDARD | USB_RECIP_DEVICE)\n#define Dev_InRequest\t(Dev_Request | USB_DIR_IN)\n#define Intf_Request\t(USB_TYPE_STANDARD | USB_RECIP_INTERFACE)\n#define Intf_InRequest\t(Intf_Request | USB_DIR_IN)\n#define Ep_Request\t(USB_TYPE_STANDARD | USB_RECIP_ENDPOINT)\n#define Ep_InRequest\t(Ep_Request | USB_DIR_IN)\n\n\n \nstatic int handle_control_request(struct dummy_hcd *dum_hcd, struct urb *urb,\n\t\t\t\t  struct usb_ctrlrequest *setup,\n\t\t\t\t  int *status)\n{\n\tstruct dummy_ep\t\t*ep2;\n\tstruct dummy\t\t*dum = dum_hcd->dum;\n\tint\t\t\tret_val = 1;\n\tunsigned\tw_index;\n\tunsigned\tw_value;\n\n\tw_index = le16_to_cpu(setup->wIndex);\n\tw_value = le16_to_cpu(setup->wValue);\n\tswitch (setup->bRequest) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (setup->bRequestType != Dev_Request)\n\t\t\tbreak;\n\t\tdum->address = w_value;\n\t\t*status = 0;\n\t\tdev_dbg(udc_dev(dum), \"set_address = %d\\n\",\n\t\t\t\tw_value);\n\t\tret_val = 0;\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (setup->bRequestType == Dev_Request) {\n\t\t\tret_val = 0;\n\t\t\tswitch (w_value) {\n\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_B_HNP_ENABLE:\n\t\t\t\tdum->gadget.b_hnp_enable = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_HNP_SUPPORT:\n\t\t\t\tdum->gadget.a_hnp_support = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_ALT_HNP_SUPPORT:\n\t\t\t\tdum->gadget.a_alt_hnp_support = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_U1_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_U1_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_U2_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_LTM_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_LTM_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (ret_val == 0) {\n\t\t\t\tdum->devstatus |= (1 << w_value);\n\t\t\t\t*status = 0;\n\t\t\t}\n\t\t} else if (setup->bRequestType == Ep_Request) {\n\t\t\t \n\t\t\tep2 = find_endpoint(dum, w_index);\n\t\t\tif (!ep2 || ep2->ep.name == ep0name) {\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tep2->halted = 1;\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tif (setup->bRequestType == Dev_Request) {\n\t\t\tret_val = 0;\n\t\t\tswitch (w_value) {\n\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\tw_value = USB_DEVICE_REMOTE_WAKEUP;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_U1_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_U1_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_U2_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_LTM_ENABLE:\n\t\t\t\tif (dummy_hcd_to_hcd(dum_hcd)->speed ==\n\t\t\t\t    HCD_USB3)\n\t\t\t\t\tw_value = USB_DEV_STAT_LTM_ENABLED;\n\t\t\t\telse\n\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret_val == 0) {\n\t\t\t\tdum->devstatus &= ~(1 << w_value);\n\t\t\t\t*status = 0;\n\t\t\t}\n\t\t} else if (setup->bRequestType == Ep_Request) {\n\t\t\t \n\t\t\tep2 = find_endpoint(dum, w_index);\n\t\t\tif (!ep2) {\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ep2->wedged)\n\t\t\t\tep2->halted = 0;\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (setup->bRequestType == Dev_InRequest\n\t\t\t\t|| setup->bRequestType == Intf_InRequest\n\t\t\t\t|| setup->bRequestType == Ep_InRequest) {\n\t\t\tchar *buf;\n\t\t\t \n\t\t\tbuf = (char *)urb->transfer_buffer;\n\t\t\tif (urb->transfer_buffer_length > 0) {\n\t\t\t\tif (setup->bRequestType == Ep_InRequest) {\n\t\t\t\t\tep2 = find_endpoint(dum, w_index);\n\t\t\t\t\tif (!ep2) {\n\t\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbuf[0] = ep2->halted;\n\t\t\t\t} else if (setup->bRequestType ==\n\t\t\t\t\t   Dev_InRequest) {\n\t\t\t\t\tbuf[0] = (u8)dum->devstatus;\n\t\t\t\t} else\n\t\t\t\t\tbuf[0] = 0;\n\t\t\t}\n\t\t\tif (urb->transfer_buffer_length > 1)\n\t\t\t\tbuf[1] = 0;\n\t\t\turb->actual_length = min_t(u32, 2,\n\t\t\t\turb->transfer_buffer_length);\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret_val;\n}\n\n \nstatic void dummy_timer(struct timer_list *t)\n{\n\tstruct dummy_hcd\t*dum_hcd = from_timer(dum_hcd, t, timer);\n\tstruct dummy\t\t*dum = dum_hcd->dum;\n\tstruct urbp\t\t*urbp, *tmp;\n\tunsigned long\t\tflags;\n\tint\t\t\tlimit, total;\n\tint\t\t\ti;\n\n\t \n\t \n\tswitch (dum->gadget.speed) {\n\tcase USB_SPEED_LOW:\n\t\ttotal = 8  * 12 ;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\ttotal = 64  * 19 ;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\ttotal = 512  * 13  * 8 ;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\t \n\t\ttotal = 490000;\n\t\tbreak;\n\tdefault:\t \n\t\tdev_err(dummy_dev(dum_hcd), \"bogus device speed\\n\");\n\t\ttotal = 0;\n\t\tbreak;\n\t}\n\n\t \n\n\t \n\tspin_lock_irqsave(&dum->lock, flags);\n\n\tif (!dum_hcd->udev) {\n\t\tdev_err(dummy_dev(dum_hcd),\n\t\t\t\t\"timer fired with no URBs pending?\\n\");\n\t\tspin_unlock_irqrestore(&dum->lock, flags);\n\t\treturn;\n\t}\n\tdum_hcd->next_frame_urbp = NULL;\n\n\tfor (i = 0; i < DUMMY_ENDPOINTS; i++) {\n\t\tif (!ep_info[i].name)\n\t\t\tbreak;\n\t\tdum->ep[i].already_seen = 0;\n\t}\n\nrestart:\n\tlist_for_each_entry_safe(urbp, tmp, &dum_hcd->urbp_list, urbp_list) {\n\t\tstruct urb\t\t*urb;\n\t\tstruct dummy_request\t*req;\n\t\tu8\t\t\taddress;\n\t\tstruct dummy_ep\t\t*ep = NULL;\n\t\tint\t\t\tstatus = -EINPROGRESS;\n\n\t\t \n\t\tif (urbp == dum_hcd->next_frame_urbp)\n\t\t\tbreak;\n\n\t\turb = urbp->urb;\n\t\tif (urb->unlinked)\n\t\t\tgoto return_urb;\n\t\telse if (dum_hcd->rh_state != DUMMY_RH_RUNNING)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (total <= 0)\n\t\t\tcontinue;\n\n\t\t \n\t\taddress = usb_pipeendpoint (urb->pipe);\n\t\tif (usb_urb_dir_in(urb))\n\t\t\taddress |= USB_DIR_IN;\n\t\tep = find_endpoint(dum, address);\n\t\tif (!ep) {\n\t\t\t \n\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\"no ep configured for urb %p\\n\",\n\t\t\t\turb);\n\t\t\tstatus = -EPROTO;\n\t\t\tgoto return_urb;\n\t\t}\n\n\t\tif (ep->already_seen)\n\t\t\tcontinue;\n\t\tep->already_seen = 1;\n\t\tif (ep == &dum->ep[0] && urb->error_count) {\n\t\t\tep->setup_stage = 1;\t \n\t\t\turb->error_count = 0;\n\t\t}\n\t\tif (ep->halted && !ep->setup_stage) {\n\t\t\t \n\t\t\tdev_dbg(dummy_dev(dum_hcd), \"ep %s halted, urb %p\\n\",\n\t\t\t\t\tep->ep.name, urb);\n\t\t\tstatus = -EPIPE;\n\t\t\tgoto return_urb;\n\t\t}\n\t\t \n\n\t\t \n\t\tif (ep == &dum->ep[0] && ep->setup_stage) {\n\t\t\tstruct usb_ctrlrequest\t\tsetup;\n\t\t\tint\t\t\t\tvalue;\n\n\t\t\tsetup = *(struct usb_ctrlrequest *) urb->setup_packet;\n\t\t\t \n\t\t\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\t\t\tlist_del_init(&req->queue);\n\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\tdev_dbg(udc_dev(dum), \"stale req = %p\\n\",\n\t\t\t\t\t\treq);\n\n\t\t\t\tspin_unlock(&dum->lock);\n\t\t\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\t\t\tspin_lock(&dum->lock);\n\t\t\t\tep->already_seen = 0;\n\t\t\t\tgoto restart;\n\t\t\t}\n\n\t\t\t \n\t\t\tep->last_io = jiffies;\n\t\t\tep->setup_stage = 0;\n\t\t\tep->halted = 0;\n\n\t\t\tvalue = handle_control_request(dum_hcd, urb, &setup,\n\t\t\t\t\t\t       &status);\n\n\t\t\t \n\t\t\tif (value > 0) {\n\t\t\t\t++dum->callback_usage;\n\t\t\t\tspin_unlock(&dum->lock);\n\t\t\t\tvalue = dum->driver->setup(&dum->gadget,\n\t\t\t\t\t\t&setup);\n\t\t\t\tspin_lock(&dum->lock);\n\t\t\t\t--dum->callback_usage;\n\n\t\t\t\tif (value >= 0) {\n\t\t\t\t\t \n\t\t\t\t\tlimit = 64*1024;\n\t\t\t\t\tgoto treat_control_like_bulk;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t}\n\n\t\t\tif (value < 0) {\n\t\t\t\tif (value != -EOPNOTSUPP)\n\t\t\t\t\tdev_dbg(udc_dev(dum),\n\t\t\t\t\t\t\"setup --> %d\\n\",\n\t\t\t\t\t\tvalue);\n\t\t\t\tstatus = -EPIPE;\n\t\t\t\turb->actual_length = 0;\n\t\t\t}\n\n\t\t\tgoto return_urb;\n\t\t}\n\n\t\t \n\t\tlimit = total;\n\t\tswitch (usb_pipetype(urb->pipe)) {\n\t\tcase PIPE_ISOCHRONOUS:\n\t\t\t \n\t\t\tlimit = max(limit, periodic_bytes(dum, ep));\n\t\t\tstatus = -EINVAL;\t \n\t\t\tbreak;\n\n\t\tcase PIPE_INTERRUPT:\n\t\t\t \n\t\t\tlimit = max(limit, periodic_bytes(dum, ep));\n\t\t\tfallthrough;\n\n\t\tdefault:\ntreat_control_like_bulk:\n\t\t\tep->last_io = jiffies;\n\t\t\ttotal -= transfer(dum_hcd, urb, ep, limit, &status);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (status == -EINPROGRESS)\n\t\t\tcontinue;\n\nreturn_urb:\n\t\tlist_del(&urbp->urbp_list);\n\t\tkfree(urbp);\n\t\tif (ep)\n\t\t\tep->already_seen = ep->setup_stage = 0;\n\n\t\tusb_hcd_unlink_urb_from_ep(dummy_hcd_to_hcd(dum_hcd), urb);\n\t\tspin_unlock(&dum->lock);\n\t\tusb_hcd_giveback_urb(dummy_hcd_to_hcd(dum_hcd), urb, status);\n\t\tspin_lock(&dum->lock);\n\n\t\tgoto restart;\n\t}\n\n\tif (list_empty(&dum_hcd->urbp_list)) {\n\t\tusb_put_dev(dum_hcd->udev);\n\t\tdum_hcd->udev = NULL;\n\t} else if (dum_hcd->rh_state == DUMMY_RH_RUNNING) {\n\t\t \n\t\tmod_timer(&dum_hcd->timer, jiffies + msecs_to_jiffies(1));\n\t}\n\n\tspin_unlock_irqrestore(&dum->lock, flags);\n}\n\n \n\n#define PORT_C_MASK \\\n\t((USB_PORT_STAT_C_CONNECTION \\\n\t| USB_PORT_STAT_C_ENABLE \\\n\t| USB_PORT_STAT_C_SUSPEND \\\n\t| USB_PORT_STAT_C_OVERCURRENT \\\n\t| USB_PORT_STAT_C_RESET) << 16)\n\nstatic int dummy_hub_status(struct usb_hcd *hcd, char *buf)\n{\n\tstruct dummy_hcd\t*dum_hcd;\n\tunsigned long\t\tflags;\n\tint\t\t\tretval = 0;\n\n\tdum_hcd = hcd_to_dummy_hcd(hcd);\n\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto done;\n\n\tif (dum_hcd->resuming && time_after_eq(jiffies, dum_hcd->re_timeout)) {\n\t\tdum_hcd->port_status |= (USB_PORT_STAT_C_SUSPEND << 16);\n\t\tdum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\n\t\tset_link_state(dum_hcd);\n\t}\n\n\tif ((dum_hcd->port_status & PORT_C_MASK) != 0) {\n\t\t*buf = (1 << 1);\n\t\tdev_dbg(dummy_dev(dum_hcd), \"port status 0x%08x has changes\\n\",\n\t\t\t\tdum_hcd->port_status);\n\t\tretval = 1;\n\t\tif (dum_hcd->rh_state == DUMMY_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t}\ndone:\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\treturn retval;\n}\n\n \nstatic struct {\n\tstruct usb_bos_descriptor bos;\n\tstruct usb_ss_cap_descriptor ss_cap;\n} __packed usb3_bos_desc = {\n\n\t.bos = {\n\t\t.bLength\t\t= USB_DT_BOS_SIZE,\n\t\t.bDescriptorType\t= USB_DT_BOS,\n\t\t.wTotalLength\t\t= cpu_to_le16(sizeof(usb3_bos_desc)),\n\t\t.bNumDeviceCaps\t\t= 1,\n\t},\n\t.ss_cap = {\n\t\t.bLength\t\t= USB_DT_USB_SS_CAP_SIZE,\n\t\t.bDescriptorType\t= USB_DT_DEVICE_CAPABILITY,\n\t\t.bDevCapabilityType\t= USB_SS_CAP_TYPE,\n\t\t.wSpeedSupported\t= cpu_to_le16(USB_5GBPS_OPERATION),\n\t\t.bFunctionalitySupport\t= ilog2(USB_5GBPS_OPERATION),\n\t},\n};\n\nstatic inline void\nss_hub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof *desc);\n\tdesc->bDescriptorType = USB_DT_SS_HUB;\n\tdesc->bDescLength = 12;\n\tdesc->wHubCharacteristics = cpu_to_le16(\n\t\t\tHUB_CHAR_INDV_PORT_LPSM |\n\t\t\tHUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = 1;\n\tdesc->u.ss.bHubHdrDecLat = 0x04;  \n\tdesc->u.ss.DeviceRemovable = 0;\n}\n\nstatic inline void hub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof *desc);\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bDescLength = 9;\n\tdesc->wHubCharacteristics = cpu_to_le16(\n\t\t\tHUB_CHAR_INDV_PORT_LPSM |\n\t\t\tHUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = 1;\n\tdesc->u.hs.DeviceRemovable[0] = 0;\n\tdesc->u.hs.DeviceRemovable[1] = 0xff;\t \n}\n\nstatic int dummy_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength\n) {\n\tstruct dummy_hcd *dum_hcd;\n\tint\t\tretval = 0;\n\tunsigned long\tflags;\n\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\treturn -ETIMEDOUT;\n\n\tdum_hcd = hcd_to_dummy_hcd(hcd);\n\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t \"USB_PORT_FEAT_SUSPEND req not \"\n\t\t\t\t\t \"supported for USB 3.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (dum_hcd->port_status & USB_PORT_STAT_SUSPEND) {\n\t\t\t\t \n\t\t\t\tdum_hcd->resuming = 1;\n\t\t\t\tdum_hcd->re_timeout = jiffies +\n\t\t\t\t\t\tmsecs_to_jiffies(20);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(dummy_dev(dum_hcd), \"power-off\\n\");\n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tdum_hcd->port_status &= ~USB_SS_PORT_STAT_POWER;\n\t\t\telse\n\t\t\t\tdum_hcd->port_status &= ~USB_PORT_STAT_POWER;\n\t\t\tset_link_state(dum_hcd);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tgoto error;\n\t\t\tfallthrough;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tdum_hcd->port_status &= ~(1 << wValue);\n\t\t\tset_link_state(dum_hcd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t \n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tif (hcd->speed == HCD_USB3 &&\n\t\t\t\t(wLength < USB_DT_SS_HUB_SIZE ||\n\t\t\t\t wValue != (USB_DT_SS_HUB << 8))) {\n\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\"Wrong hub descriptor type for \"\n\t\t\t\t\"USB 3.0 roothub.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (hcd->speed == HCD_USB3)\n\t\t\tss_hub_descriptor((struct usb_hub_descriptor *) buf);\n\t\telse\n\t\t\thub_descriptor((struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\tif (hcd->speed != HCD_USB3)\n\t\t\tgoto error;\n\n\t\tif ((wValue >> 8) != USB_DT_BOS)\n\t\t\tgoto error;\n\n\t\tmemcpy(buf, &usb3_bos_desc, sizeof(usb3_bos_desc));\n\t\tretval = sizeof(usb3_bos_desc);\n\t\tbreak;\n\n\tcase GetHubStatus:\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (wIndex != 1)\n\t\t\tretval = -EPIPE;\n\n\t\t \n\t\tif (dum_hcd->resuming &&\n\t\t\t\ttime_after_eq(jiffies, dum_hcd->re_timeout)) {\n\t\t\tdum_hcd->port_status |= (USB_PORT_STAT_C_SUSPEND << 16);\n\t\t\tdum_hcd->port_status &= ~USB_PORT_STAT_SUSPEND;\n\t\t}\n\t\tif ((dum_hcd->port_status & USB_PORT_STAT_RESET) != 0 &&\n\t\t\t\ttime_after_eq(jiffies, dum_hcd->re_timeout)) {\n\t\t\tdum_hcd->port_status |= (USB_PORT_STAT_C_RESET << 16);\n\t\t\tdum_hcd->port_status &= ~USB_PORT_STAT_RESET;\n\t\t\tif (dum_hcd->dum->pullup) {\n\t\t\t\tdum_hcd->port_status |= USB_PORT_STAT_ENABLE;\n\n\t\t\t\tif (hcd->speed < HCD_USB3) {\n\t\t\t\t\tswitch (dum_hcd->dum->gadget.speed) {\n\t\t\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t\t      USB_PORT_STAT_HIGH_SPEED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase USB_SPEED_LOW:\n\t\t\t\t\t\tdum_hcd->dum->gadget.ep0->\n\t\t\t\t\t\t\tmaxpacket = 8;\n\t\t\t\t\t\tdum_hcd->port_status |=\n\t\t\t\t\t\t\tUSB_PORT_STAT_LOW_SPEED;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset_link_state(dum_hcd);\n\t\t((__le16 *) buf)[0] = cpu_to_le16(dum_hcd->port_status);\n\t\t((__le16 *) buf)[1] = cpu_to_le16(dum_hcd->port_status >> 16);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tretval = -EPIPE;\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t \"USB_PORT_FEAT_LINK_STATE req not \"\n\t\t\t\t\t \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\t\t \n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t \"USB_PORT_FEAT_U1/2_TIMEOUT req not \"\n\t\t\t\t\t \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t \"USB_PORT_FEAT_SUSPEND req not \"\n\t\t\t\t\t \"supported for USB 3.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (dum_hcd->active) {\n\t\t\t\tdum_hcd->port_status |= USB_PORT_STAT_SUSPEND;\n\n\t\t\t\t \n\t\t\t\tset_link_state(dum_hcd);\n\t\t\t\tif (((1 << USB_DEVICE_B_HNP_ENABLE)\n\t\t\t\t\t\t& dum_hcd->dum->devstatus) != 0)\n\t\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t\t\t\"no HNP yet!\\n\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tdum_hcd->port_status |= USB_SS_PORT_STAT_POWER;\n\t\t\telse\n\t\t\t\tdum_hcd->port_status |= USB_PORT_STAT_POWER;\n\t\t\tset_link_state(dum_hcd);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\t \n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t\t \"USB_PORT_FEAT_BH_PORT_RESET req not \"\n\t\t\t\t\t \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (!(dum_hcd->port_status & USB_PORT_STAT_CONNECTION))\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tdum_hcd->port_status =\n\t\t\t\t\t(USB_SS_PORT_STAT_POWER |\n\t\t\t\t\t USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t USB_PORT_STAT_RESET);\n\t\t\t} else {\n\t\t\t\tdum_hcd->port_status &= ~(USB_PORT_STAT_ENABLE\n\t\t\t\t\t| USB_PORT_STAT_LOW_SPEED\n\t\t\t\t\t| USB_PORT_STAT_HIGH_SPEED);\n\t\t\t\tdum_hcd->port_status |= USB_PORT_STAT_RESET;\n\t\t\t}\n\t\t\t \n\t\t\tdum_hcd->dum->devstatus &=\n\t\t\t\t(1 << USB_DEVICE_SELF_POWERED);\n\t\t\t \n\t\t\tdum_hcd->re_timeout = jiffies + msecs_to_jiffies(50);\n\t\t\tset_link_state(dum_hcd);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tdefault:\n\t\t \n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase GetPortErrorCount:\n\t\tif (hcd->speed != HCD_USB3) {\n\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t \"GetPortErrorCount req not \"\n\t\t\t\t \"supported for USB 2.0 roothub\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\tcase SetHubDepth:\n\t\tif (hcd->speed != HCD_USB3) {\n\t\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\t \"SetHubDepth req not supported for \"\n\t\t\t\t \"USB 2.0 roothub\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dummy_dev(dum_hcd),\n\t\t\t\"hub control req%04x v%04x i%04x l%d\\n\",\n\t\t\ttypeReq, wValue, wIndex, wLength);\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\n\tif ((dum_hcd->port_status & PORT_C_MASK) != 0)\n\t\tusb_hcd_poll_rh_status(hcd);\n\treturn retval;\n}\n\nstatic int dummy_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\n\n\tdev_dbg(&hcd->self.root_hub->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irq(&dum_hcd->dum->lock);\n\tdum_hcd->rh_state = DUMMY_RH_SUSPENDED;\n\tset_link_state(dum_hcd);\n\thcd->state = HC_STATE_SUSPENDED;\n\tspin_unlock_irq(&dum_hcd->dum->lock);\n\treturn 0;\n}\n\nstatic int dummy_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\n\tint rc = 0;\n\n\tdev_dbg(&hcd->self.root_hub->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irq(&dum_hcd->dum->lock);\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\trc = -ESHUTDOWN;\n\t} else {\n\t\tdum_hcd->rh_state = DUMMY_RH_RUNNING;\n\t\tset_link_state(dum_hcd);\n\t\tif (!list_empty(&dum_hcd->urbp_list))\n\t\t\tmod_timer(&dum_hcd->timer, jiffies);\n\t\thcd->state = HC_STATE_RUNNING;\n\t}\n\tspin_unlock_irq(&dum_hcd->dum->lock);\n\treturn rc;\n}\n\n \n\nstatic inline ssize_t show_urb(char *buf, size_t size, struct urb *urb)\n{\n\tint ep = usb_pipeendpoint(urb->pipe);\n\n\treturn scnprintf(buf, size,\n\t\t\"urb/%p %s ep%d%s%s len %d/%d\\n\",\n\t\turb,\n\t\t({ char *s;\n\t\tswitch (urb->dev->speed) {\n\t\tcase USB_SPEED_LOW:\n\t\t\ts = \"ls\";\n\t\t\tbreak;\n\t\tcase USB_SPEED_FULL:\n\t\t\ts = \"fs\";\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\t\ts = \"hs\";\n\t\t\tbreak;\n\t\tcase USB_SPEED_SUPER:\n\t\t\ts = \"ss\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts = \"?\";\n\t\t\tbreak;\n\t\t } s; }),\n\t\tep, ep ? (usb_urb_dir_in(urb) ? \"in\" : \"out\") : \"\",\n\t\t({ char *s; \\\n\t\tswitch (usb_pipetype(urb->pipe)) { \\\n\t\tcase PIPE_CONTROL: \\\n\t\t\ts = \"\"; \\\n\t\t\tbreak; \\\n\t\tcase PIPE_BULK: \\\n\t\t\ts = \"-bulk\"; \\\n\t\t\tbreak; \\\n\t\tcase PIPE_INTERRUPT: \\\n\t\t\ts = \"-int\"; \\\n\t\t\tbreak; \\\n\t\tdefault: \\\n\t\t\ts = \"-iso\"; \\\n\t\t\tbreak; \\\n\t\t} s; }),\n\t\turb->actual_length, urb->transfer_buffer_length);\n}\n\nstatic ssize_t urbs_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct usb_hcd\t\t*hcd = dev_get_drvdata(dev);\n\tstruct dummy_hcd\t*dum_hcd = hcd_to_dummy_hcd(hcd);\n\tstruct urbp\t\t*urbp;\n\tsize_t\t\t\tsize = 0;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\tlist_for_each_entry(urbp, &dum_hcd->urbp_list, urbp_list) {\n\t\tsize_t\t\ttemp;\n\n\t\ttemp = show_urb(buf, PAGE_SIZE - size, urbp->urb);\n\t\tbuf += temp;\n\t\tsize += temp;\n\t}\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RO(urbs);\n\nstatic int dummy_start_ss(struct dummy_hcd *dum_hcd)\n{\n\ttimer_setup(&dum_hcd->timer, dummy_timer, 0);\n\tdum_hcd->rh_state = DUMMY_RH_RUNNING;\n\tdum_hcd->stream_en_ep = 0;\n\tINIT_LIST_HEAD(&dum_hcd->urbp_list);\n\tdummy_hcd_to_hcd(dum_hcd)->power_budget = POWER_BUDGET_3;\n\tdummy_hcd_to_hcd(dum_hcd)->state = HC_STATE_RUNNING;\n\tdummy_hcd_to_hcd(dum_hcd)->uses_new_polling = 1;\n#ifdef CONFIG_USB_OTG\n\tdummy_hcd_to_hcd(dum_hcd)->self.otg_port = 1;\n#endif\n\treturn 0;\n\n\t \n\treturn device_create_file(dummy_dev(dum_hcd), &dev_attr_urbs);\n}\n\nstatic int dummy_start(struct usb_hcd *hcd)\n{\n\tstruct dummy_hcd\t*dum_hcd = hcd_to_dummy_hcd(hcd);\n\n\t \n\tif (!usb_hcd_is_primary_hcd(hcd))\n\t\treturn dummy_start_ss(dum_hcd);\n\n\tspin_lock_init(&dum_hcd->dum->lock);\n\ttimer_setup(&dum_hcd->timer, dummy_timer, 0);\n\tdum_hcd->rh_state = DUMMY_RH_RUNNING;\n\n\tINIT_LIST_HEAD(&dum_hcd->urbp_list);\n\n\thcd->power_budget = POWER_BUDGET;\n\thcd->state = HC_STATE_RUNNING;\n\thcd->uses_new_polling = 1;\n\n#ifdef CONFIG_USB_OTG\n\thcd->self.otg_port = 1;\n#endif\n\n\t \n\treturn device_create_file(dummy_dev(dum_hcd), &dev_attr_urbs);\n}\n\nstatic void dummy_stop(struct usb_hcd *hcd)\n{\n\tdevice_remove_file(dummy_dev(hcd_to_dummy_hcd(hcd)), &dev_attr_urbs);\n\tdev_info(dummy_dev(hcd_to_dummy_hcd(hcd)), \"stopped\\n\");\n}\n\n \n\nstatic int dummy_h_get_frame(struct usb_hcd *hcd)\n{\n\treturn dummy_g_get_frame(NULL);\n}\n\nstatic int dummy_setup(struct usb_hcd *hcd)\n{\n\tstruct dummy *dum;\n\n\tdum = *((void **)dev_get_platdata(hcd->self.controller));\n\thcd->self.sg_tablesize = ~0;\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tdum->hs_hcd = hcd_to_dummy_hcd(hcd);\n\t\tdum->hs_hcd->dum = dum;\n\t\t \n\t\thcd->speed = HCD_USB2;\n\t\thcd->self.root_hub->speed = USB_SPEED_HIGH;\n\t} else {\n\t\tdum->ss_hcd = hcd_to_dummy_hcd(hcd);\n\t\tdum->ss_hcd->dum = dum;\n\t\thcd->speed = HCD_USB3;\n\t\thcd->self.root_hub->speed = USB_SPEED_SUPER;\n\t}\n\treturn 0;\n}\n\n \nstatic int dummy_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,\n\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\tunsigned int num_streams, gfp_t mem_flags)\n{\n\tstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\n\tunsigned long flags;\n\tint max_stream;\n\tint ret_streams = num_streams;\n\tunsigned int index;\n\tunsigned int i;\n\n\tif (!num_eps)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\tfor (i = 0; i < num_eps; i++) {\n\t\tindex = dummy_get_ep_idx(&eps[i]->desc);\n\t\tif ((1 << index) & dum_hcd->stream_en_ep) {\n\t\t\tret_streams = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmax_stream = usb_ss_max_streams(&eps[i]->ss_ep_comp);\n\t\tif (!max_stream) {\n\t\t\tret_streams = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tif (max_stream < ret_streams) {\n\t\t\tdev_dbg(dummy_dev(dum_hcd), \"Ep 0x%x only supports %u \"\n\t\t\t\t\t\"stream IDs.\\n\",\n\t\t\t\t\teps[i]->desc.bEndpointAddress,\n\t\t\t\t\tmax_stream);\n\t\t\tret_streams = max_stream;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_eps; i++) {\n\t\tindex = dummy_get_ep_idx(&eps[i]->desc);\n\t\tdum_hcd->stream_en_ep |= 1 << index;\n\t\tset_max_streams_for_pipe(dum_hcd,\n\t\t\t\tusb_endpoint_num(&eps[i]->desc), ret_streams);\n\t}\nout:\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\treturn ret_streams;\n}\n\n \nstatic int dummy_free_streams(struct usb_hcd *hcd, struct usb_device *udev,\n\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\tgfp_t mem_flags)\n{\n\tstruct dummy_hcd *dum_hcd = hcd_to_dummy_hcd(hcd);\n\tunsigned long flags;\n\tint ret;\n\tunsigned int index;\n\tunsigned int i;\n\n\tspin_lock_irqsave(&dum_hcd->dum->lock, flags);\n\tfor (i = 0; i < num_eps; i++) {\n\t\tindex = dummy_get_ep_idx(&eps[i]->desc);\n\t\tif (!((1 << index) & dum_hcd->stream_en_ep)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_eps; i++) {\n\t\tindex = dummy_get_ep_idx(&eps[i]->desc);\n\t\tdum_hcd->stream_en_ep &= ~(1 << index);\n\t\tset_max_streams_for_pipe(dum_hcd,\n\t\t\t\tusb_endpoint_num(&eps[i]->desc), 0);\n\t}\n\tret = 0;\nout:\n\tspin_unlock_irqrestore(&dum_hcd->dum->lock, flags);\n\treturn ret;\n}\n\nstatic struct hc_driver dummy_hcd = {\n\t.description =\t\t(char *) driver_name,\n\t.product_desc =\t\t\"Dummy host controller\",\n\t.hcd_priv_size =\tsizeof(struct dummy_hcd),\n\n\t.reset =\t\tdummy_setup,\n\t.start =\t\tdummy_start,\n\t.stop =\t\t\tdummy_stop,\n\n\t.urb_enqueue =\t\tdummy_urb_enqueue,\n\t.urb_dequeue =\t\tdummy_urb_dequeue,\n\n\t.get_frame_number =\tdummy_h_get_frame,\n\n\t.hub_status_data =\tdummy_hub_status,\n\t.hub_control =\t\tdummy_hub_control,\n\t.bus_suspend =\t\tdummy_bus_suspend,\n\t.bus_resume =\t\tdummy_bus_resume,\n\n\t.alloc_streams =\tdummy_alloc_streams,\n\t.free_streams =\t\tdummy_free_streams,\n};\n\nstatic int dummy_hcd_probe(struct platform_device *pdev)\n{\n\tstruct dummy\t\t*dum;\n\tstruct usb_hcd\t\t*hs_hcd;\n\tstruct usb_hcd\t\t*ss_hcd;\n\tint\t\t\tretval;\n\n\tdev_info(&pdev->dev, \"%s, driver \" DRIVER_VERSION \"\\n\", driver_desc);\n\tdum = *((void **)dev_get_platdata(&pdev->dev));\n\n\tif (mod_data.is_super_speed)\n\t\tdummy_hcd.flags = HCD_USB3 | HCD_SHARED;\n\telse if (mod_data.is_high_speed)\n\t\tdummy_hcd.flags = HCD_USB2;\n\telse\n\t\tdummy_hcd.flags = HCD_USB11;\n\ths_hcd = usb_create_hcd(&dummy_hcd, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hs_hcd)\n\t\treturn -ENOMEM;\n\ths_hcd->has_tt = 1;\n\n\tretval = usb_add_hcd(hs_hcd, 0, 0);\n\tif (retval)\n\t\tgoto put_usb2_hcd;\n\n\tif (mod_data.is_super_speed) {\n\t\tss_hcd = usb_create_shared_hcd(&dummy_hcd, &pdev->dev,\n\t\t\t\t\tdev_name(&pdev->dev), hs_hcd);\n\t\tif (!ss_hcd) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto dealloc_usb2_hcd;\n\t\t}\n\n\t\tretval = usb_add_hcd(ss_hcd, 0, 0);\n\t\tif (retval)\n\t\t\tgoto put_usb3_hcd;\n\t}\n\treturn 0;\n\nput_usb3_hcd:\n\tusb_put_hcd(ss_hcd);\ndealloc_usb2_hcd:\n\tusb_remove_hcd(hs_hcd);\nput_usb2_hcd:\n\tusb_put_hcd(hs_hcd);\n\tdum->hs_hcd = dum->ss_hcd = NULL;\n\treturn retval;\n}\n\nstatic void dummy_hcd_remove(struct platform_device *pdev)\n{\n\tstruct dummy\t\t*dum;\n\n\tdum = hcd_to_dummy_hcd(platform_get_drvdata(pdev))->dum;\n\n\tif (dum->ss_hcd) {\n\t\tusb_remove_hcd(dummy_hcd_to_hcd(dum->ss_hcd));\n\t\tusb_put_hcd(dummy_hcd_to_hcd(dum->ss_hcd));\n\t}\n\n\tusb_remove_hcd(dummy_hcd_to_hcd(dum->hs_hcd));\n\tusb_put_hcd(dummy_hcd_to_hcd(dum->hs_hcd));\n\n\tdum->hs_hcd = NULL;\n\tdum->ss_hcd = NULL;\n}\n\nstatic int dummy_hcd_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct dummy_hcd\t*dum_hcd;\n\tint\t\t\trc = 0;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\thcd = platform_get_drvdata(pdev);\n\tdum_hcd = hcd_to_dummy_hcd(hcd);\n\tif (dum_hcd->rh_state == DUMMY_RH_RUNNING) {\n\t\tdev_warn(&pdev->dev, \"Root hub isn't suspended!\\n\");\n\t\trc = -EBUSY;\n\t} else\n\t\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\treturn rc;\n}\n\nstatic int dummy_hcd_resume(struct platform_device *pdev)\n{\n\tstruct usb_hcd\t\t*hcd;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\thcd = platform_get_drvdata(pdev);\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tusb_hcd_poll_rh_status(hcd);\n\treturn 0;\n}\n\nstatic struct platform_driver dummy_hcd_driver = {\n\t.probe\t\t= dummy_hcd_probe,\n\t.remove_new\t= dummy_hcd_remove,\n\t.suspend\t= dummy_hcd_suspend,\n\t.resume\t\t= dummy_hcd_resume,\n\t.driver\t\t= {\n\t\t.name\t= driver_name,\n\t},\n};\n\n \n#define MAX_NUM_UDC\t32\nstatic struct platform_device *the_udc_pdev[MAX_NUM_UDC];\nstatic struct platform_device *the_hcd_pdev[MAX_NUM_UDC];\n\nstatic int __init dummy_hcd_init(void)\n{\n\tint\tretval = -ENOMEM;\n\tint\ti;\n\tstruct\tdummy *dum[MAX_NUM_UDC] = {};\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (!mod_data.is_high_speed && mod_data.is_super_speed)\n\t\treturn -EINVAL;\n\n\tif (mod_data.num < 1 || mod_data.num > MAX_NUM_UDC) {\n\t\tpr_err(\"Number of emulated UDC must be in range of 1...%d\\n\",\n\t\t\t\tMAX_NUM_UDC);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tthe_hcd_pdev[i] = platform_device_alloc(driver_name, i);\n\t\tif (!the_hcd_pdev[i]) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_put(the_hcd_pdev[i--]);\n\t\t\treturn retval;\n\t\t}\n\t}\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tthe_udc_pdev[i] = platform_device_alloc(gadget_name, i);\n\t\tif (!the_udc_pdev[i]) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_put(the_udc_pdev[i--]);\n\t\t\tgoto err_alloc_udc;\n\t\t}\n\t}\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tdum[i] = kzalloc(sizeof(struct dummy), GFP_KERNEL);\n\t\tif (!dum[i]) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_add_pdata;\n\t\t}\n\t\tretval = platform_device_add_data(the_hcd_pdev[i], &dum[i],\n\t\t\t\tsizeof(void *));\n\t\tif (retval)\n\t\t\tgoto err_add_pdata;\n\t\tretval = platform_device_add_data(the_udc_pdev[i], &dum[i],\n\t\t\t\tsizeof(void *));\n\t\tif (retval)\n\t\t\tgoto err_add_pdata;\n\t}\n\n\tretval = platform_driver_register(&dummy_hcd_driver);\n\tif (retval < 0)\n\t\tgoto err_add_pdata;\n\tretval = platform_driver_register(&dummy_udc_driver);\n\tif (retval < 0)\n\t\tgoto err_register_udc_driver;\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tretval = platform_device_add(the_hcd_pdev[i]);\n\t\tif (retval < 0) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_del(the_hcd_pdev[i--]);\n\t\t\tgoto err_add_hcd;\n\t\t}\n\t}\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tif (!dum[i]->hs_hcd ||\n\t\t\t\t(!dum[i]->ss_hcd && mod_data.is_super_speed)) {\n\t\t\t \n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_add_udc;\n\t\t}\n\t}\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tretval = platform_device_add(the_udc_pdev[i]);\n\t\tif (retval < 0) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_del(the_udc_pdev[i--]);\n\t\t\tgoto err_add_udc;\n\t\t}\n\t}\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tif (!platform_get_drvdata(the_udc_pdev[i])) {\n\t\t\t \n\t\t\tretval = -EINVAL;\n\t\t\tgoto err_probe_udc;\n\t\t}\n\t}\n\treturn retval;\n\nerr_probe_udc:\n\tfor (i = 0; i < mod_data.num; i++)\n\t\tplatform_device_del(the_udc_pdev[i]);\nerr_add_udc:\n\tfor (i = 0; i < mod_data.num; i++)\n\t\tplatform_device_del(the_hcd_pdev[i]);\nerr_add_hcd:\n\tplatform_driver_unregister(&dummy_udc_driver);\nerr_register_udc_driver:\n\tplatform_driver_unregister(&dummy_hcd_driver);\nerr_add_pdata:\n\tfor (i = 0; i < mod_data.num; i++)\n\t\tkfree(dum[i]);\n\tfor (i = 0; i < mod_data.num; i++)\n\t\tplatform_device_put(the_udc_pdev[i]);\nerr_alloc_udc:\n\tfor (i = 0; i < mod_data.num; i++)\n\t\tplatform_device_put(the_hcd_pdev[i]);\n\treturn retval;\n}\nmodule_init(dummy_hcd_init);\n\nstatic void __exit dummy_hcd_cleanup(void)\n{\n\tint i;\n\n\tfor (i = 0; i < mod_data.num; i++) {\n\t\tstruct dummy *dum;\n\n\t\tdum = *((void **)dev_get_platdata(&the_udc_pdev[i]->dev));\n\n\t\tplatform_device_unregister(the_udc_pdev[i]);\n\t\tplatform_device_unregister(the_hcd_pdev[i]);\n\t\tkfree(dum);\n\t}\n\tplatform_driver_unregister(&dummy_udc_driver);\n\tplatform_driver_unregister(&dummy_hcd_driver);\n}\nmodule_exit(dummy_hcd_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}