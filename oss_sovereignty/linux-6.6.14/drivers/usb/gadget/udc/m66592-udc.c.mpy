{
  "module_name": "m66592-udc.c",
  "hash_id": "5d293a91cbcccc8bea5a6dfee42141502418920610f0c58e31bba271e61a4ca4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/m66592-udc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include \"m66592-udc.h\"\n\nMODULE_DESCRIPTION(\"M66592 USB gadget driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_ALIAS(\"platform:m66592_udc\");\n\n#define DRIVER_VERSION\t\"21 July 2009\"\n\nstatic const char udc_name[] = \"m66592_udc\";\nstatic const char *m66592_ep_name[] = {\n\t\"ep0\", \"ep1\", \"ep2\", \"ep3\", \"ep4\", \"ep5\", \"ep6\", \"ep7\"\n};\n\nstatic void disable_controller(struct m66592 *m66592);\nstatic void irq_ep0_write(struct m66592_ep *ep, struct m66592_request *req);\nstatic void irq_packet_write(struct m66592_ep *ep, struct m66592_request *req);\nstatic int m66592_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags);\n\nstatic void transfer_complete(struct m66592_ep *ep,\n\t\tstruct m66592_request *req, int status);\n\n \nstatic inline u16 get_usb_speed(struct m66592 *m66592)\n{\n\treturn (m66592_read(m66592, M66592_DVSTCTR) & M66592_RHST);\n}\n\nstatic void enable_pipe_irq(struct m66592 *m66592, u16 pipenum,\n\t\tunsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = m66592_read(m66592, M66592_INTENB0);\n\tm66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,\n\t\t\tM66592_INTENB0);\n\tm66592_bset(m66592, (1 << pipenum), reg);\n\tm66592_write(m66592, tmp, M66592_INTENB0);\n}\n\nstatic void disable_pipe_irq(struct m66592 *m66592, u16 pipenum,\n\t\tunsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = m66592_read(m66592, M66592_INTENB0);\n\tm66592_bclr(m66592, M66592_BEMPE | M66592_NRDYE | M66592_BRDYE,\n\t\t\tM66592_INTENB0);\n\tm66592_bclr(m66592, (1 << pipenum), reg);\n\tm66592_write(m66592, tmp, M66592_INTENB0);\n}\n\nstatic void m66592_usb_connect(struct m66592 *m66592)\n{\n\tm66592_bset(m66592, M66592_CTRE, M66592_INTENB0);\n\tm66592_bset(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,\n\t\t\tM66592_INTENB0);\n\tm66592_bset(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);\n\n\tm66592_bset(m66592, M66592_DPRPU, M66592_SYSCFG);\n}\n\nstatic void m66592_usb_disconnect(struct m66592 *m66592)\n__releases(m66592->lock)\n__acquires(m66592->lock)\n{\n\tm66592_bclr(m66592, M66592_CTRE, M66592_INTENB0);\n\tm66592_bclr(m66592, M66592_WDST | M66592_RDST | M66592_CMPL,\n\t\t\tM66592_INTENB0);\n\tm66592_bclr(m66592, M66592_BEMPE | M66592_BRDYE, M66592_INTENB0);\n\tm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\n\n\tm66592->gadget.speed = USB_SPEED_UNKNOWN;\n\tspin_unlock(&m66592->lock);\n\tm66592->driver->disconnect(&m66592->gadget);\n\tspin_lock(&m66592->lock);\n\n\tdisable_controller(m66592);\n\tINIT_LIST_HEAD(&m66592->ep[0].queue);\n}\n\nstatic inline u16 control_reg_get_pid(struct m66592 *m66592, u16 pipenum)\n{\n\tu16 pid = 0;\n\tunsigned long offset;\n\n\tif (pipenum == 0)\n\t\tpid = m66592_read(m66592, M66592_DCPCTR) & M66592_PID;\n\telse if (pipenum < M66592_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tpid = m66592_read(m66592, offset) & M66592_PID;\n\t} else\n\t\tpr_err(\"unexpect pipe num (%d)\\n\", pipenum);\n\n\treturn pid;\n}\n\nstatic inline void control_reg_set_pid(struct m66592 *m66592, u16 pipenum,\n\t\tu16 pid)\n{\n\tunsigned long offset;\n\n\tif (pipenum == 0)\n\t\tm66592_mdfy(m66592, pid, M66592_PID, M66592_DCPCTR);\n\telse if (pipenum < M66592_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tm66592_mdfy(m66592, pid, M66592_PID, offset);\n\t} else\n\t\tpr_err(\"unexpect pipe num (%d)\\n\", pipenum);\n}\n\nstatic inline void pipe_start(struct m66592 *m66592, u16 pipenum)\n{\n\tcontrol_reg_set_pid(m66592, pipenum, M66592_PID_BUF);\n}\n\nstatic inline void pipe_stop(struct m66592 *m66592, u16 pipenum)\n{\n\tcontrol_reg_set_pid(m66592, pipenum, M66592_PID_NAK);\n}\n\nstatic inline void pipe_stall(struct m66592 *m66592, u16 pipenum)\n{\n\tcontrol_reg_set_pid(m66592, pipenum, M66592_PID_STALL);\n}\n\nstatic inline u16 control_reg_get(struct m66592 *m66592, u16 pipenum)\n{\n\tu16 ret = 0;\n\tunsigned long offset;\n\n\tif (pipenum == 0)\n\t\tret = m66592_read(m66592, M66592_DCPCTR);\n\telse if (pipenum < M66592_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tret = m66592_read(m66592, offset);\n\t} else\n\t\tpr_err(\"unexpect pipe num (%d)\\n\", pipenum);\n\n\treturn ret;\n}\n\nstatic inline void control_reg_sqclr(struct m66592 *m66592, u16 pipenum)\n{\n\tunsigned long offset;\n\n\tpipe_stop(m66592, pipenum);\n\n\tif (pipenum == 0)\n\t\tm66592_bset(m66592, M66592_SQCLR, M66592_DCPCTR);\n\telse if (pipenum < M66592_MAX_NUM_PIPE) {\n\t\toffset = get_pipectr_addr(pipenum);\n\t\tm66592_bset(m66592, M66592_SQCLR, offset);\n\t} else\n\t\tpr_err(\"unexpect pipe num(%d)\\n\", pipenum);\n}\n\nstatic inline int get_buffer_size(struct m66592 *m66592, u16 pipenum)\n{\n\tu16 tmp;\n\tint size;\n\n\tif (pipenum == 0) {\n\t\ttmp = m66592_read(m66592, M66592_DCPCFG);\n\t\tif ((tmp & M66592_CNTMD) != 0)\n\t\t\tsize = 256;\n\t\telse {\n\t\t\ttmp = m66592_read(m66592, M66592_DCPMAXP);\n\t\t\tsize = tmp & M66592_MAXP;\n\t\t}\n\t} else {\n\t\tm66592_write(m66592, pipenum, M66592_PIPESEL);\n\t\ttmp = m66592_read(m66592, M66592_PIPECFG);\n\t\tif ((tmp & M66592_CNTMD) != 0) {\n\t\t\ttmp = m66592_read(m66592, M66592_PIPEBUF);\n\t\t\tsize = ((tmp >> 10) + 1) * 64;\n\t\t} else {\n\t\t\ttmp = m66592_read(m66592, M66592_PIPEMAXP);\n\t\t\tsize = tmp & M66592_MXPS;\n\t\t}\n\t}\n\n\treturn size;\n}\n\nstatic inline void pipe_change(struct m66592 *m66592, u16 pipenum)\n{\n\tstruct m66592_ep *ep = m66592->pipenum2ep[pipenum];\n\tunsigned short mbw;\n\n\tif (ep->use_dma)\n\t\treturn;\n\n\tm66592_mdfy(m66592, pipenum, M66592_CURPIPE, ep->fifosel);\n\n\tndelay(450);\n\n\tif (m66592->pdata->on_chip)\n\t\tmbw = M66592_MBW_32;\n\telse\n\t\tmbw = M66592_MBW_16;\n\n\tm66592_bset(m66592, mbw, ep->fifosel);\n}\n\nstatic int pipe_buffer_setting(struct m66592 *m66592,\n\t\tstruct m66592_pipe_info *info)\n{\n\tu16 bufnum = 0, buf_bsize = 0;\n\tu16 pipecfg = 0;\n\n\tif (info->pipe == 0)\n\t\treturn -EINVAL;\n\n\tm66592_write(m66592, info->pipe, M66592_PIPESEL);\n\n\tif (info->dir_in)\n\t\tpipecfg |= M66592_DIR;\n\tpipecfg |= info->type;\n\tpipecfg |= info->epnum;\n\tswitch (info->type) {\n\tcase M66592_INT:\n\t\tbufnum = 4 + (info->pipe - M66592_BASE_PIPENUM_INT);\n\t\tbuf_bsize = 0;\n\t\tbreak;\n\tcase M66592_BULK:\n\t\t \n\t\tif (info->pipe >= M66592_BASE_PIPENUM_BULK)\n\t\t\tbufnum = info->pipe - M66592_BASE_PIPENUM_BULK;\n\t\telse\n\t\t\tbufnum = info->pipe - M66592_BASE_PIPENUM_ISOC;\n\n\t\tbufnum = M66592_BASE_BUFNUM + (bufnum * 16);\n\t\tbuf_bsize = 7;\n\t\tpipecfg |= M66592_DBLB;\n\t\tif (!info->dir_in)\n\t\t\tpipecfg |= M66592_SHTNAK;\n\t\tbreak;\n\tcase M66592_ISO:\n\t\tbufnum = M66592_BASE_BUFNUM +\n\t\t\t (info->pipe - M66592_BASE_PIPENUM_ISOC) * 16;\n\t\tbuf_bsize = 7;\n\t\tbreak;\n\t}\n\n\tif (buf_bsize && ((bufnum + 16) >= M66592_MAX_BUFNUM)) {\n\t\tpr_err(\"m66592 pipe memory is insufficient\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tm66592_write(m66592, pipecfg, M66592_PIPECFG);\n\tm66592_write(m66592, (buf_bsize << 10) | (bufnum), M66592_PIPEBUF);\n\tm66592_write(m66592, info->maxpacket, M66592_PIPEMAXP);\n\tif (info->interval)\n\t\tinfo->interval--;\n\tm66592_write(m66592, info->interval, M66592_PIPEPERI);\n\n\treturn 0;\n}\n\nstatic void pipe_buffer_release(struct m66592 *m66592,\n\t\t\t\tstruct m66592_pipe_info *info)\n{\n\tif (info->pipe == 0)\n\t\treturn;\n\n\tif (is_bulk_pipe(info->pipe)) {\n\t\tm66592->bulk--;\n\t} else if (is_interrupt_pipe(info->pipe))\n\t\tm66592->interrupt--;\n\telse if (is_isoc_pipe(info->pipe)) {\n\t\tm66592->isochronous--;\n\t\tif (info->type == M66592_BULK)\n\t\t\tm66592->bulk--;\n\t} else\n\t\tpr_err(\"ep_release: unexpect pipenum (%d)\\n\",\n\t\t\t\tinfo->pipe);\n}\n\nstatic void pipe_initialize(struct m66592_ep *ep)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tunsigned short mbw;\n\n\tm66592_mdfy(m66592, 0, M66592_CURPIPE, ep->fifosel);\n\n\tm66592_write(m66592, M66592_ACLRM, ep->pipectr);\n\tm66592_write(m66592, 0, ep->pipectr);\n\tm66592_write(m66592, M66592_SQCLR, ep->pipectr);\n\tif (ep->use_dma) {\n\t\tm66592_mdfy(m66592, ep->pipenum, M66592_CURPIPE, ep->fifosel);\n\n\t\tndelay(450);\n\n\t\tif (m66592->pdata->on_chip)\n\t\t\tmbw = M66592_MBW_32;\n\t\telse\n\t\t\tmbw = M66592_MBW_16;\n\n\t\tm66592_bset(m66592, mbw, ep->fifosel);\n\t}\n}\n\nstatic void m66592_ep_setting(struct m66592 *m66592, struct m66592_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc,\n\t\tu16 pipenum, int dma)\n{\n\tif ((pipenum != 0) && dma) {\n\t\tif (m66592->num_dma == 0) {\n\t\t\tm66592->num_dma++;\n\t\t\tep->use_dma = 1;\n\t\t\tep->fifoaddr = M66592_D0FIFO;\n\t\t\tep->fifosel = M66592_D0FIFOSEL;\n\t\t\tep->fifoctr = M66592_D0FIFOCTR;\n\t\t\tep->fifotrn = M66592_D0FIFOTRN;\n\t\t} else if (!m66592->pdata->on_chip && m66592->num_dma == 1) {\n\t\t\tm66592->num_dma++;\n\t\t\tep->use_dma = 1;\n\t\t\tep->fifoaddr = M66592_D1FIFO;\n\t\t\tep->fifosel = M66592_D1FIFOSEL;\n\t\t\tep->fifoctr = M66592_D1FIFOCTR;\n\t\t\tep->fifotrn = M66592_D1FIFOTRN;\n\t\t} else {\n\t\t\tep->use_dma = 0;\n\t\t\tep->fifoaddr = M66592_CFIFO;\n\t\t\tep->fifosel = M66592_CFIFOSEL;\n\t\t\tep->fifoctr = M66592_CFIFOCTR;\n\t\t\tep->fifotrn = 0;\n\t\t}\n\t} else {\n\t\tep->use_dma = 0;\n\t\tep->fifoaddr = M66592_CFIFO;\n\t\tep->fifosel = M66592_CFIFOSEL;\n\t\tep->fifoctr = M66592_CFIFOCTR;\n\t\tep->fifotrn = 0;\n\t}\n\n\tep->pipectr = get_pipectr_addr(pipenum);\n\tep->pipenum = pipenum;\n\tep->ep.maxpacket = usb_endpoint_maxp(desc);\n\tm66592->pipenum2ep[pipenum] = ep;\n\tm66592->epaddr2ep[desc->bEndpointAddress&USB_ENDPOINT_NUMBER_MASK] = ep;\n\tINIT_LIST_HEAD(&ep->queue);\n}\n\nstatic void m66592_ep_release(struct m66592_ep *ep)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tu16 pipenum = ep->pipenum;\n\n\tif (pipenum == 0)\n\t\treturn;\n\n\tif (ep->use_dma)\n\t\tm66592->num_dma--;\n\tep->pipenum = 0;\n\tep->busy = 0;\n\tep->use_dma = 0;\n}\n\nstatic int alloc_pipe_config(struct m66592_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tstruct m66592_pipe_info info;\n\tint dma = 0;\n\tint *counter;\n\tint ret;\n\n\tep->ep.desc = desc;\n\n\tBUG_ON(ep->pipenum);\n\n\tswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (m66592->bulk >= M66592_MAX_NUM_BULK) {\n\t\t\tif (m66592->isochronous >= M66592_MAX_NUM_ISOC) {\n\t\t\t\tpr_err(\"bulk pipe is insufficient\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t} else {\n\t\t\t\tinfo.pipe = M66592_BASE_PIPENUM_ISOC\n\t\t\t\t\t\t+ m66592->isochronous;\n\t\t\t\tcounter = &m66592->isochronous;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.pipe = M66592_BASE_PIPENUM_BULK + m66592->bulk;\n\t\t\tcounter = &m66592->bulk;\n\t\t}\n\t\tinfo.type = M66592_BULK;\n\t\tdma = 1;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (m66592->interrupt >= M66592_MAX_NUM_INT) {\n\t\t\tpr_err(\"interrupt pipe is insufficient\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tinfo.pipe = M66592_BASE_PIPENUM_INT + m66592->interrupt;\n\t\tinfo.type = M66592_INT;\n\t\tcounter = &m66592->interrupt;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (m66592->isochronous >= M66592_MAX_NUM_ISOC) {\n\t\t\tpr_err(\"isochronous pipe is insufficient\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tinfo.pipe = M66592_BASE_PIPENUM_ISOC + m66592->isochronous;\n\t\tinfo.type = M66592_ISO;\n\t\tcounter = &m66592->isochronous;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unexpect xfer type\\n\");\n\t\treturn -EINVAL;\n\t}\n\tep->type = info.type;\n\n\tinfo.epnum = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;\n\tinfo.maxpacket = usb_endpoint_maxp(desc);\n\tinfo.interval = desc->bInterval;\n\tif (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)\n\t\tinfo.dir_in = 1;\n\telse\n\t\tinfo.dir_in = 0;\n\n\tret = pipe_buffer_setting(m66592, &info);\n\tif (ret < 0) {\n\t\tpr_err(\"pipe_buffer_setting fail\\n\");\n\t\treturn ret;\n\t}\n\n\t(*counter)++;\n\tif ((counter == &m66592->isochronous) && info.type == M66592_BULK)\n\t\tm66592->bulk++;\n\n\tm66592_ep_setting(m66592, ep, desc, info.pipe, dma);\n\tpipe_initialize(ep);\n\n\treturn 0;\n}\n\nstatic int free_pipe_config(struct m66592_ep *ep)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tstruct m66592_pipe_info info;\n\n\tinfo.pipe = ep->pipenum;\n\tinfo.type = ep->type;\n\tpipe_buffer_release(m66592, &info);\n\tm66592_ep_release(ep);\n\n\treturn 0;\n}\n\n \nstatic void pipe_irq_enable(struct m66592 *m66592, u16 pipenum)\n{\n\tenable_irq_ready(m66592, pipenum);\n\tenable_irq_nrdy(m66592, pipenum);\n}\n\nstatic void pipe_irq_disable(struct m66592 *m66592, u16 pipenum)\n{\n\tdisable_irq_ready(m66592, pipenum);\n\tdisable_irq_nrdy(m66592, pipenum);\n}\n\n \nstatic void control_end(struct m66592 *m66592, unsigned ccpl)\n{\n\tm66592->ep[0].internal_ccpl = ccpl;\n\tpipe_start(m66592, 0);\n\tm66592_bset(m66592, M66592_CCPL, M66592_DCPCTR);\n}\n\nstatic void start_ep0_write(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\n\tpipe_change(m66592, ep->pipenum);\n\tm66592_mdfy(m66592, M66592_ISEL | M66592_PIPE0,\n\t\t\t(M66592_ISEL | M66592_CURPIPE),\n\t\t\tM66592_CFIFOSEL);\n\tm66592_write(m66592, M66592_BCLR, ep->fifoctr);\n\tif (req->req.length == 0) {\n\t\tm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\n\t\tpipe_start(m66592, 0);\n\t\ttransfer_complete(ep, req, 0);\n\t} else {\n\t\tm66592_write(m66592, ~M66592_BEMP0, M66592_BEMPSTS);\n\t\tirq_ep0_write(ep, req);\n\t}\n}\n\nstatic void start_packet_write(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tu16 tmp;\n\n\tpipe_change(m66592, ep->pipenum);\n\tdisable_irq_empty(m66592, ep->pipenum);\n\tpipe_start(m66592, ep->pipenum);\n\n\ttmp = m66592_read(m66592, ep->fifoctr);\n\tif (unlikely((tmp & M66592_FRDY) == 0))\n\t\tpipe_irq_enable(m66592, ep->pipenum);\n\telse\n\t\tirq_packet_write(ep, req);\n}\n\nstatic void start_packet_read(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tstruct m66592 *m66592 = ep->m66592;\n\tu16 pipenum = ep->pipenum;\n\n\tif (ep->pipenum == 0) {\n\t\tm66592_mdfy(m66592, M66592_PIPE0,\n\t\t\t\t(M66592_ISEL | M66592_CURPIPE),\n\t\t\t\tM66592_CFIFOSEL);\n\t\tm66592_write(m66592, M66592_BCLR, ep->fifoctr);\n\t\tpipe_start(m66592, pipenum);\n\t\tpipe_irq_enable(m66592, pipenum);\n\t} else {\n\t\tif (ep->use_dma) {\n\t\t\tm66592_bset(m66592, M66592_TRCLR, ep->fifosel);\n\t\t\tpipe_change(m66592, pipenum);\n\t\t\tm66592_bset(m66592, M66592_TRENB, ep->fifosel);\n\t\t\tm66592_write(m66592,\n\t\t\t\t(req->req.length + ep->ep.maxpacket - 1)\n\t\t\t\t\t/ ep->ep.maxpacket,\n\t\t\t\tep->fifotrn);\n\t\t}\n\t\tpipe_start(m66592, pipenum);\t \n\t\tpipe_irq_enable(m66592, pipenum);\n\t}\n}\n\nstatic void start_packet(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\n\t\tstart_packet_write(ep, req);\n\telse\n\t\tstart_packet_read(ep, req);\n}\n\nstatic void start_ep0(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tu16 ctsq;\n\n\tctsq = m66592_read(ep->m66592, M66592_INTSTS0) & M66592_CTSQ;\n\n\tswitch (ctsq) {\n\tcase M66592_CS_RDDS:\n\t\tstart_ep0_write(ep, req);\n\t\tbreak;\n\tcase M66592_CS_WRDS:\n\t\tstart_packet_read(ep, req);\n\t\tbreak;\n\n\tcase M66592_CS_WRND:\n\t\tcontrol_end(ep->m66592, 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"start_ep0: unexpect ctsq(%x)\\n\", ctsq);\n\t\tbreak;\n\t}\n}\n\nstatic void init_controller(struct m66592 *m66592)\n{\n\tunsigned int endian;\n\n\tif (m66592->pdata->on_chip) {\n\t\tif (m66592->pdata->endian)\n\t\t\tendian = 0;  \n\t\telse\n\t\t\tendian = M66592_LITTLE;  \n\n\t\tm66592_bset(m66592, M66592_HSE, M66592_SYSCFG);\t \n\t\tm66592_bclr(m66592, M66592_USBE, M66592_SYSCFG);\n\t\tm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\n\t\tm66592_bset(m66592, M66592_USBE, M66592_SYSCFG);\n\n\t\t \n\t\tm66592_bset(m66592, 0x8000, M66592_DVSTCTR);\n\t\tm66592_bset(m66592, 0x1000, M66592_TESTMODE);\n\t\tm66592_bclr(m66592, 0x8000, M66592_DVSTCTR);\n\n\t\tm66592_bset(m66592, M66592_INTL, M66592_INTENB1);\n\n\t\tm66592_write(m66592, 0, M66592_CFBCFG);\n\t\tm66592_write(m66592, 0, M66592_D0FBCFG);\n\t\tm66592_bset(m66592, endian, M66592_CFBCFG);\n\t\tm66592_bset(m66592, endian, M66592_D0FBCFG);\n\t} else {\n\t\tunsigned int clock, vif, irq_sense;\n\n\t\tif (m66592->pdata->endian)\n\t\t\tendian = M66592_BIGEND;  \n\t\telse\n\t\t\tendian = 0;  \n\n\t\tif (m66592->pdata->vif)\n\t\t\tvif = M66592_LDRV;  \n\t\telse\n\t\t\tvif = 0;  \n\n\t\tswitch (m66592->pdata->xtal) {\n\t\tcase M66592_PLATDATA_XTAL_12MHZ:\n\t\t\tclock = M66592_XTAL12;\n\t\t\tbreak;\n\t\tcase M66592_PLATDATA_XTAL_24MHZ:\n\t\t\tclock = M66592_XTAL24;\n\t\t\tbreak;\n\t\tcase M66592_PLATDATA_XTAL_48MHZ:\n\t\t\tclock = M66592_XTAL48;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"m66592-udc: xtal configuration error\\n\");\n\t\t\tclock = 0;\n\t\t}\n\n\t\tswitch (m66592->irq_trigger) {\n\t\tcase IRQF_TRIGGER_LOW:\n\t\t\tirq_sense = M66592_INTL;\n\t\t\tbreak;\n\t\tcase IRQF_TRIGGER_FALLING:\n\t\t\tirq_sense = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"m66592-udc: irq trigger config error\\n\");\n\t\t\tirq_sense = 0;\n\t\t}\n\n\t\tm66592_bset(m66592,\n\t\t\t    (vif & M66592_LDRV) | (endian & M66592_BIGEND),\n\t\t\t    M66592_PINCFG);\n\t\tm66592_bset(m66592, M66592_HSE, M66592_SYSCFG);\t \n\t\tm66592_mdfy(m66592, clock & M66592_XTAL, M66592_XTAL,\n\t\t\t    M66592_SYSCFG);\n\t\tm66592_bclr(m66592, M66592_USBE, M66592_SYSCFG);\n\t\tm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\n\t\tm66592_bset(m66592, M66592_USBE, M66592_SYSCFG);\n\n\t\tm66592_bset(m66592, M66592_XCKE, M66592_SYSCFG);\n\n\t\tmsleep(3);\n\n\t\tm66592_bset(m66592, M66592_RCKE | M66592_PLLC, M66592_SYSCFG);\n\n\t\tmsleep(1);\n\n\t\tm66592_bset(m66592, M66592_SCKE, M66592_SYSCFG);\n\n\t\tm66592_bset(m66592, irq_sense & M66592_INTL, M66592_INTENB1);\n\t\tm66592_write(m66592, M66592_BURST | M66592_CPU_ADR_RD_WR,\n\t\t\t     M66592_DMA0CFG);\n\t}\n}\n\nstatic void disable_controller(struct m66592 *m66592)\n{\n\tm66592_bclr(m66592, M66592_UTST, M66592_TESTMODE);\n\tif (!m66592->pdata->on_chip) {\n\t\tm66592_bclr(m66592, M66592_SCKE, M66592_SYSCFG);\n\t\tudelay(1);\n\t\tm66592_bclr(m66592, M66592_PLLC, M66592_SYSCFG);\n\t\tudelay(1);\n\t\tm66592_bclr(m66592, M66592_RCKE, M66592_SYSCFG);\n\t\tudelay(1);\n\t\tm66592_bclr(m66592, M66592_XCKE, M66592_SYSCFG);\n\t}\n}\n\nstatic void m66592_start_xclock(struct m66592 *m66592)\n{\n\tu16 tmp;\n\n\tif (!m66592->pdata->on_chip) {\n\t\ttmp = m66592_read(m66592, M66592_SYSCFG);\n\t\tif (!(tmp & M66592_XCKE))\n\t\t\tm66592_bset(m66592, M66592_XCKE, M66592_SYSCFG);\n\t}\n}\n\n \nstatic void transfer_complete(struct m66592_ep *ep,\n\t\tstruct m66592_request *req, int status)\n__releases(m66592->lock)\n__acquires(m66592->lock)\n{\n\tint restart = 0;\n\n\tif (unlikely(ep->pipenum == 0)) {\n\t\tif (ep->internal_ccpl) {\n\t\t\tep->internal_ccpl = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlist_del_init(&req->queue);\n\tif (ep->m66592->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treq->req.status = -ESHUTDOWN;\n\telse\n\t\treq->req.status = status;\n\n\tif (!list_empty(&ep->queue))\n\t\trestart = 1;\n\n\tspin_unlock(&ep->m66592->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&ep->m66592->lock);\n\n\tif (restart) {\n\t\treq = list_entry(ep->queue.next, struct m66592_request, queue);\n\t\tif (ep->ep.desc)\n\t\t\tstart_packet(ep, req);\n\t}\n}\n\nstatic void irq_ep0_write(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tint i;\n\tu16 tmp;\n\tunsigned bufsize;\n\tsize_t size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct m66592 *m66592 = ep->m66592;\n\n\tpipe_change(m66592, pipenum);\n\tm66592_bset(m66592, M66592_ISEL, ep->fifosel);\n\n\ti = 0;\n\tdo {\n\t\ttmp = m66592_read(m66592, ep->fifoctr);\n\t\tif (i++ > 100000) {\n\t\t\tpr_err(\"pipe0 is busy. maybe cpu i/o bus \"\n\t\t\t\t\"conflict. please power off this controller.\");\n\t\t\treturn;\n\t\t}\n\t\tndelay(1);\n\t} while ((tmp & M66592_FRDY) == 0);\n\n\t \n\tbufsize = get_buffer_size(m66592, pipenum);\n\tbuf = req->req.buf + req->req.actual;\n\tsize = min(bufsize, req->req.length - req->req.actual);\n\n\t \n\tif (req->req.buf) {\n\t\tif (size > 0)\n\t\t\tm66592_write_fifo(m66592, ep, buf, size);\n\t\tif ((size == 0) || ((size % ep->ep.maxpacket) != 0))\n\t\t\tm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\n\t}\n\n\t \n\treq->req.actual += size;\n\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tdisable_irq_ready(m66592, pipenum);\n\t\tdisable_irq_empty(m66592, pipenum);\n\t} else {\n\t\tdisable_irq_ready(m66592, pipenum);\n\t\tenable_irq_empty(m66592, pipenum);\n\t}\n\tpipe_start(m66592, pipenum);\n}\n\nstatic void irq_packet_write(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tu16 tmp;\n\tunsigned bufsize;\n\tsize_t size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct m66592 *m66592 = ep->m66592;\n\n\tpipe_change(m66592, pipenum);\n\ttmp = m66592_read(m66592, ep->fifoctr);\n\tif (unlikely((tmp & M66592_FRDY) == 0)) {\n\t\tpipe_stop(m66592, pipenum);\n\t\tpipe_irq_disable(m66592, pipenum);\n\t\tpr_err(\"write fifo not ready. pipnum=%d\\n\", pipenum);\n\t\treturn;\n\t}\n\n\t \n\tbufsize = get_buffer_size(m66592, pipenum);\n\tbuf = req->req.buf + req->req.actual;\n\tsize = min(bufsize, req->req.length - req->req.actual);\n\n\t \n\tif (req->req.buf) {\n\t\tm66592_write_fifo(m66592, ep, buf, size);\n\t\tif ((size == 0)\n\t\t\t\t|| ((size % ep->ep.maxpacket) != 0)\n\t\t\t\t|| ((bufsize != ep->ep.maxpacket)\n\t\t\t\t\t&& (bufsize > size)))\n\t\t\tm66592_bset(m66592, M66592_BVAL, ep->fifoctr);\n\t}\n\n\t \n\treq->req.actual += size;\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tdisable_irq_ready(m66592, pipenum);\n\t\tenable_irq_empty(m66592, pipenum);\n\t} else {\n\t\tdisable_irq_empty(m66592, pipenum);\n\t\tpipe_irq_enable(m66592, pipenum);\n\t}\n}\n\nstatic void irq_packet_read(struct m66592_ep *ep, struct m66592_request *req)\n{\n\tu16 tmp;\n\tint rcv_len, bufsize, req_len;\n\tint size;\n\tvoid *buf;\n\tu16 pipenum = ep->pipenum;\n\tstruct m66592 *m66592 = ep->m66592;\n\tint finish = 0;\n\n\tpipe_change(m66592, pipenum);\n\ttmp = m66592_read(m66592, ep->fifoctr);\n\tif (unlikely((tmp & M66592_FRDY) == 0)) {\n\t\treq->req.status = -EPIPE;\n\t\tpipe_stop(m66592, pipenum);\n\t\tpipe_irq_disable(m66592, pipenum);\n\t\tpr_err(\"read fifo not ready\");\n\t\treturn;\n\t}\n\n\t \n\trcv_len = tmp & M66592_DTLN;\n\tbufsize = get_buffer_size(m66592, pipenum);\n\n\tbuf = req->req.buf + req->req.actual;\n\treq_len = req->req.length - req->req.actual;\n\tif (rcv_len < bufsize)\n\t\tsize = min(rcv_len, req_len);\n\telse\n\t\tsize = min(bufsize, req_len);\n\n\t \n\treq->req.actual += size;\n\n\t \n\tif ((!req->req.zero && (req->req.actual == req->req.length))\n\t\t\t|| (size % ep->ep.maxpacket)\n\t\t\t|| (size == 0)) {\n\t\tpipe_stop(m66592, pipenum);\n\t\tpipe_irq_disable(m66592, pipenum);\n\t\tfinish = 1;\n\t}\n\n\t \n\tif (req->req.buf) {\n\t\tif (size == 0)\n\t\t\tm66592_write(m66592, M66592_BCLR, ep->fifoctr);\n\t\telse\n\t\t\tm66592_read_fifo(m66592, ep->fifoaddr, buf, size);\n\t}\n\n\tif ((ep->pipenum != 0) && finish)\n\t\ttransfer_complete(ep, req, 0);\n}\n\nstatic void irq_pipe_ready(struct m66592 *m66592, u16 status, u16 enb)\n{\n\tu16 check;\n\tu16 pipenum;\n\tstruct m66592_ep *ep;\n\tstruct m66592_request *req;\n\n\tif ((status & M66592_BRDY0) && (enb & M66592_BRDY0)) {\n\t\tm66592_write(m66592, ~M66592_BRDY0, M66592_BRDYSTS);\n\t\tm66592_mdfy(m66592, M66592_PIPE0, M66592_CURPIPE,\n\t\t\t\tM66592_CFIFOSEL);\n\n\t\tep = &m66592->ep[0];\n\t\treq = list_entry(ep->queue.next, struct m66592_request, queue);\n\t\tirq_packet_read(ep, req);\n\t} else {\n\t\tfor (pipenum = 1; pipenum < M66592_MAX_NUM_PIPE; pipenum++) {\n\t\t\tcheck = 1 << pipenum;\n\t\t\tif ((status & check) && (enb & check)) {\n\t\t\t\tm66592_write(m66592, ~check, M66592_BRDYSTS);\n\t\t\t\tep = m66592->pipenum2ep[pipenum];\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\t\t struct m66592_request, queue);\n\t\t\t\tif (ep->ep.desc->bEndpointAddress & USB_DIR_IN)\n\t\t\t\t\tirq_packet_write(ep, req);\n\t\t\t\telse\n\t\t\t\t\tirq_packet_read(ep, req);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void irq_pipe_empty(struct m66592 *m66592, u16 status, u16 enb)\n{\n\tu16 tmp;\n\tu16 check;\n\tu16 pipenum;\n\tstruct m66592_ep *ep;\n\tstruct m66592_request *req;\n\n\tif ((status & M66592_BEMP0) && (enb & M66592_BEMP0)) {\n\t\tm66592_write(m66592, ~M66592_BEMP0, M66592_BEMPSTS);\n\n\t\tep = &m66592->ep[0];\n\t\treq = list_entry(ep->queue.next, struct m66592_request, queue);\n\t\tirq_ep0_write(ep, req);\n\t} else {\n\t\tfor (pipenum = 1; pipenum < M66592_MAX_NUM_PIPE; pipenum++) {\n\t\t\tcheck = 1 << pipenum;\n\t\t\tif ((status & check) && (enb & check)) {\n\t\t\t\tm66592_write(m66592, ~check, M66592_BEMPSTS);\n\t\t\t\ttmp = control_reg_get(m66592, pipenum);\n\t\t\t\tif ((tmp & M66592_INBUFM) == 0) {\n\t\t\t\t\tdisable_irq_empty(m66592, pipenum);\n\t\t\t\t\tpipe_irq_disable(m66592, pipenum);\n\t\t\t\t\tpipe_stop(m66592, pipenum);\n\t\t\t\t\tep = m66592->pipenum2ep[pipenum];\n\t\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\t\t\t struct m66592_request,\n\t\t\t\t\t\t\t queue);\n\t\t\t\t\tif (!list_empty(&ep->queue))\n\t\t\t\t\t\ttransfer_complete(ep, req, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void get_status(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\n__releases(m66592->lock)\n__acquires(m66592->lock)\n{\n\tstruct m66592_ep *ep;\n\tu16 pid;\n\tu16 status = 0;\n\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tpid = control_reg_get_pid(m66592, ep->pipenum);\n\t\tif (pid == M66592_PID_STALL)\n\t\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\t\telse\n\t\t\tstatus = 0;\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(m66592, 0);\n\t\treturn;\t\t \n\t}\n\n\tm66592->ep0_data = cpu_to_le16(status);\n\tm66592->ep0_req->buf = &m66592->ep0_data;\n\tm66592->ep0_req->length = 2;\n\t \n\tspin_unlock(&m66592->lock);\n\tm66592_queue(m66592->gadget.ep0, m66592->ep0_req, GFP_KERNEL);\n\tspin_lock(&m66592->lock);\n}\n\nstatic void clear_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\n{\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tcontrol_end(m66592, 1);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tcontrol_end(m66592, 1);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tstruct m66592_ep *ep;\n\t\tstruct m66592_request *req;\n\t\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\t\tep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tpipe_stop(m66592, ep->pipenum);\n\t\tcontrol_reg_sqclr(m66592, ep->pipenum);\n\n\t\tcontrol_end(m66592, 1);\n\n\t\treq = list_entry(ep->queue.next,\n\t\tstruct m66592_request, queue);\n\t\tif (ep->busy) {\n\t\t\tep->busy = 0;\n\t\t\tif (list_empty(&ep->queue))\n\t\t\t\tbreak;\n\t\t\tstart_packet(ep, req);\n\t\t} else if (!list_empty(&ep->queue))\n\t\t\tpipe_start(m66592, ep->pipenum);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(m66592, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void set_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\n{\n\tu16 tmp;\n\tint timeout = 3000;\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (le16_to_cpu(ctrl->wValue)) {\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\tcontrol_end(m66592, 1);\n\t\t\t \n\t\t\tdo {\n\t\t\t\ttmp = m66592_read(m66592, M66592_INTSTS0) &\n\t\t\t\t\t\t\t\tM66592_CTSQ;\n\t\t\t\tudelay(1);\n\t\t\t} while (tmp != M66592_CS_IDST && timeout-- > 0);\n\n\t\t\tif (tmp == M66592_CS_IDST)\n\t\t\t\tm66592_bset(m66592,\n\t\t\t\t\t    le16_to_cpu(ctrl->wIndex >> 8),\n\t\t\t\t\t    M66592_TESTMODE);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpipe_stall(m66592, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tcontrol_end(m66592, 1);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT: {\n\t\tstruct m66592_ep *ep;\n\t\tu16 w_index = le16_to_cpu(ctrl->wIndex);\n\n\t\tep = m66592->epaddr2ep[w_index & USB_ENDPOINT_NUMBER_MASK];\n\t\tpipe_stall(m66592, ep->pipenum);\n\n\t\tcontrol_end(m66592, 1);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpipe_stall(m66592, 0);\n\t\tbreak;\n\t}\n}\n\n \nstatic int setup_packet(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)\n{\n\tu16 *p = (u16 *)ctrl;\n\tunsigned long offset = M66592_USBREQ;\n\tint i, ret = 0;\n\n\t \n\tm66592_write(m66592, ~M66592_VALID, M66592_INTSTS0);\n\n\tfor (i = 0; i < 4; i++)\n\t\tp[i] = m66592_read(m66592, offset + i*2);\n\n\t \n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tget_status(m66592, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tclear_feature(m66592, ctrl);\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tset_feature(m66592, ctrl);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tret = 1;\n\treturn ret;\n}\n\nstatic void m66592_update_usb_speed(struct m66592 *m66592)\n{\n\tu16 speed = get_usb_speed(m66592);\n\n\tswitch (speed) {\n\tcase M66592_HSMODE:\n\t\tm66592->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase M66592_FSMODE:\n\t\tm66592->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\tdefault:\n\t\tm66592->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tpr_err(\"USB speed unknown\\n\");\n\t}\n}\n\nstatic void irq_device_state(struct m66592 *m66592)\n{\n\tu16 dvsq;\n\n\tdvsq = m66592_read(m66592, M66592_INTSTS0) & M66592_DVSQ;\n\tm66592_write(m66592, ~M66592_DVST, M66592_INTSTS0);\n\n\tif (dvsq == M66592_DS_DFLT) {\t \n\t\tusb_gadget_udc_reset(&m66592->gadget, m66592->driver);\n\t\tm66592_update_usb_speed(m66592);\n\t}\n\tif (m66592->old_dvsq == M66592_DS_CNFG && dvsq != M66592_DS_CNFG)\n\t\tm66592_update_usb_speed(m66592);\n\tif ((dvsq == M66592_DS_CNFG || dvsq == M66592_DS_ADDS)\n\t\t\t&& m66592->gadget.speed == USB_SPEED_UNKNOWN)\n\t\tm66592_update_usb_speed(m66592);\n\n\tm66592->old_dvsq = dvsq;\n}\n\nstatic void irq_control_stage(struct m66592 *m66592)\n__releases(m66592->lock)\n__acquires(m66592->lock)\n{\n\tstruct usb_ctrlrequest ctrl;\n\tu16 ctsq;\n\n\tctsq = m66592_read(m66592, M66592_INTSTS0) & M66592_CTSQ;\n\tm66592_write(m66592, ~M66592_CTRT, M66592_INTSTS0);\n\n\tswitch (ctsq) {\n\tcase M66592_CS_IDST: {\n\t\tstruct m66592_ep *ep;\n\t\tstruct m66592_request *req;\n\t\tep = &m66592->ep[0];\n\t\treq = list_entry(ep->queue.next, struct m66592_request, queue);\n\t\ttransfer_complete(ep, req, 0);\n\t\t}\n\t\tbreak;\n\n\tcase M66592_CS_RDDS:\n\tcase M66592_CS_WRDS:\n\tcase M66592_CS_WRND:\n\t\tif (setup_packet(m66592, &ctrl)) {\n\t\t\tspin_unlock(&m66592->lock);\n\t\t\tif (m66592->driver->setup(&m66592->gadget, &ctrl) < 0)\n\t\t\t\tpipe_stall(m66592, 0);\n\t\t\tspin_lock(&m66592->lock);\n\t\t}\n\t\tbreak;\n\tcase M66592_CS_RDSS:\n\tcase M66592_CS_WRSS:\n\t\tcontrol_end(m66592, 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"ctrl_stage: unexpect ctsq(%x)\\n\", ctsq);\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t m66592_irq(int irq, void *_m66592)\n{\n\tstruct m66592 *m66592 = _m66592;\n\tu16 intsts0;\n\tu16 intenb0;\n\tu16 savepipe;\n\tu16 mask0;\n\n\tspin_lock(&m66592->lock);\n\n\tintsts0 = m66592_read(m66592, M66592_INTSTS0);\n\tintenb0 = m66592_read(m66592, M66592_INTENB0);\n\n\tif (m66592->pdata->on_chip && !intsts0 && !intenb0) {\n\t\t \n\t\tm66592_start_xclock(m66592);\n\t\tintsts0 = m66592_read(m66592, M66592_INTSTS0);\n\t\tintenb0 = m66592_read(m66592, M66592_INTENB0);\n\t}\n\n\tsavepipe = m66592_read(m66592, M66592_CFIFOSEL);\n\n\tmask0 = intsts0 & intenb0;\n\tif (mask0) {\n\t\tu16 brdysts = m66592_read(m66592, M66592_BRDYSTS);\n\t\tu16 bempsts = m66592_read(m66592, M66592_BEMPSTS);\n\t\tu16 brdyenb = m66592_read(m66592, M66592_BRDYENB);\n\t\tu16 bempenb = m66592_read(m66592, M66592_BEMPENB);\n\n\t\tif (mask0 & M66592_VBINT) {\n\t\t\tm66592_write(m66592,  0xffff & ~M66592_VBINT,\n\t\t\t\t\tM66592_INTSTS0);\n\t\t\tm66592_start_xclock(m66592);\n\n\t\t\t \n\t\t\tm66592->old_vbus = m66592_read(m66592, M66592_INTSTS0)\n\t\t\t\t\t& M66592_VBSTS;\n\t\t\tm66592->scount = M66592_MAX_SAMPLING;\n\n\t\t\tmod_timer(&m66592->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t}\n\t\tif (intsts0 & M66592_DVSQ)\n\t\t\tirq_device_state(m66592);\n\n\t\tif ((intsts0 & M66592_BRDY) && (intenb0 & M66592_BRDYE)\n\t\t\t\t&& (brdysts & brdyenb)) {\n\t\t\tirq_pipe_ready(m66592, brdysts, brdyenb);\n\t\t}\n\t\tif ((intsts0 & M66592_BEMP) && (intenb0 & M66592_BEMPE)\n\t\t\t\t&& (bempsts & bempenb)) {\n\t\t\tirq_pipe_empty(m66592, bempsts, bempenb);\n\t\t}\n\n\t\tif (intsts0 & M66592_CTRT)\n\t\t\tirq_control_stage(m66592);\n\t}\n\n\tm66592_write(m66592, savepipe, M66592_CFIFOSEL);\n\n\tspin_unlock(&m66592->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void m66592_timer(struct timer_list *t)\n{\n\tstruct m66592 *m66592 = from_timer(m66592, t, timer);\n\tunsigned long flags;\n\tu16 tmp;\n\n\tspin_lock_irqsave(&m66592->lock, flags);\n\ttmp = m66592_read(m66592, M66592_SYSCFG);\n\tif (!(tmp & M66592_RCKE)) {\n\t\tm66592_bset(m66592, M66592_RCKE | M66592_PLLC, M66592_SYSCFG);\n\t\tudelay(10);\n\t\tm66592_bset(m66592, M66592_SCKE, M66592_SYSCFG);\n\t}\n\tif (m66592->scount > 0) {\n\t\ttmp = m66592_read(m66592, M66592_INTSTS0) & M66592_VBSTS;\n\t\tif (tmp == m66592->old_vbus) {\n\t\t\tm66592->scount--;\n\t\t\tif (m66592->scount == 0) {\n\t\t\t\tif (tmp == M66592_VBSTS)\n\t\t\t\t\tm66592_usb_connect(m66592);\n\t\t\t\telse\n\t\t\t\t\tm66592_usb_disconnect(m66592);\n\t\t\t} else {\n\t\t\t\tmod_timer(&m66592->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t\t}\n\t\t} else {\n\t\t\tm66592->scount = M66592_MAX_SAMPLING;\n\t\t\tm66592->old_vbus = tmp;\n\t\t\tmod_timer(&m66592->timer,\n\t\t\t\t\tjiffies + msecs_to_jiffies(50));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&m66592->lock, flags);\n}\n\n \nstatic int m66592_enable(struct usb_ep *_ep,\n\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\tstruct m66592_ep *ep;\n\n\tep = container_of(_ep, struct m66592_ep, ep);\n\treturn alloc_pipe_config(ep, desc);\n}\n\nstatic int m66592_disable(struct usb_ep *_ep)\n{\n\tstruct m66592_ep *ep;\n\tstruct m66592_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct m66592_ep, ep);\n\tBUG_ON(!ep);\n\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next, struct m66592_request, queue);\n\t\tspin_lock_irqsave(&ep->m66592->lock, flags);\n\t\ttransfer_complete(ep, req, -ECONNRESET);\n\t\tspin_unlock_irqrestore(&ep->m66592->lock, flags);\n\t}\n\n\tpipe_irq_disable(ep->m66592, ep->pipenum);\n\treturn free_pipe_config(ep);\n}\n\nstatic struct usb_request *m66592_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\tgfp_t gfp_flags)\n{\n\tstruct m66592_request *req;\n\n\treq = kzalloc(sizeof(struct m66592_request), gfp_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void m66592_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct m66592_request *req;\n\n\treq = container_of(_req, struct m66592_request, req);\n\tkfree(req);\n}\n\nstatic int m66592_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct m66592_ep *ep;\n\tstruct m66592_request *req;\n\tunsigned long flags;\n\tint request = 0;\n\n\tep = container_of(_ep, struct m66592_ep, ep);\n\treq = container_of(_req, struct m66592_request, req);\n\n\tif (ep->m66592->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&ep->m66592->lock, flags);\n\n\tif (list_empty(&ep->queue))\n\t\trequest = 1;\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\n\tif (ep->ep.desc == NULL)\t \n\t\tstart_ep0(ep, req);\n\telse {\n\t\tif (request && !ep->busy)\n\t\t\tstart_packet(ep, req);\n\t}\n\n\tspin_unlock_irqrestore(&ep->m66592->lock, flags);\n\n\treturn 0;\n}\n\nstatic int m66592_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct m66592_ep *ep;\n\tstruct m66592_request *req;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct m66592_ep, ep);\n\treq = container_of(_req, struct m66592_request, req);\n\n\tspin_lock_irqsave(&ep->m66592->lock, flags);\n\tif (!list_empty(&ep->queue))\n\t\ttransfer_complete(ep, req, -ECONNRESET);\n\tspin_unlock_irqrestore(&ep->m66592->lock, flags);\n\n\treturn 0;\n}\n\nstatic int m66592_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct m66592_ep *ep = container_of(_ep, struct m66592_ep, ep);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ep->m66592->lock, flags);\n\tif (!list_empty(&ep->queue)) {\n\t\tret = -EAGAIN;\n\t} else if (value) {\n\t\tep->busy = 1;\n\t\tpipe_stall(ep->m66592, ep->pipenum);\n\t} else {\n\t\tep->busy = 0;\n\t\tpipe_stop(ep->m66592, ep->pipenum);\n\t}\n\tspin_unlock_irqrestore(&ep->m66592->lock, flags);\n\treturn ret;\n}\n\nstatic void m66592_fifo_flush(struct usb_ep *_ep)\n{\n\tstruct m66592_ep *ep;\n\tunsigned long flags;\n\n\tep = container_of(_ep, struct m66592_ep, ep);\n\tspin_lock_irqsave(&ep->m66592->lock, flags);\n\tif (list_empty(&ep->queue) && !ep->busy) {\n\t\tpipe_stop(ep->m66592, ep->pipenum);\n\t\tm66592_bclr(ep->m66592, M66592_BCLR, ep->fifoctr);\n\t}\n\tspin_unlock_irqrestore(&ep->m66592->lock, flags);\n}\n\nstatic const struct usb_ep_ops m66592_ep_ops = {\n\t.enable\t\t= m66592_enable,\n\t.disable\t= m66592_disable,\n\n\t.alloc_request\t= m66592_alloc_request,\n\t.free_request\t= m66592_free_request,\n\n\t.queue\t\t= m66592_queue,\n\t.dequeue\t= m66592_dequeue,\n\n\t.set_halt\t= m66592_set_halt,\n\t.fifo_flush\t= m66592_fifo_flush,\n};\n\n \nstatic int m66592_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct m66592 *m66592 = to_m66592(g);\n\n\t \n\tm66592->driver = driver;\n\n\tm66592_bset(m66592, M66592_VBSE | M66592_URST, M66592_INTENB0);\n\tif (m66592_read(m66592, M66592_INTSTS0) & M66592_VBSTS) {\n\t\tm66592_start_xclock(m66592);\n\t\t \n\t\tm66592->old_vbus = m66592_read(m66592,\n\t\t\t\t\t M66592_INTSTS0) & M66592_VBSTS;\n\t\tm66592->scount = M66592_MAX_SAMPLING;\n\t\tmod_timer(&m66592->timer, jiffies + msecs_to_jiffies(50));\n\t}\n\n\treturn 0;\n}\n\nstatic int m66592_udc_stop(struct usb_gadget *g)\n{\n\tstruct m66592 *m66592 = to_m66592(g);\n\n\tm66592_bclr(m66592, M66592_VBSE | M66592_URST, M66592_INTENB0);\n\n\tinit_controller(m66592);\n\tdisable_controller(m66592);\n\n\tm66592->driver = NULL;\n\n\treturn 0;\n}\n\n \nstatic int m66592_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct m66592 *m66592 = gadget_to_m66592(_gadget);\n\treturn m66592_read(m66592, M66592_FRMNUM) & 0x03FF;\n}\n\nstatic int m66592_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct m66592 *m66592 = gadget_to_m66592(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&m66592->lock, flags);\n\tif (is_on)\n\t\tm66592_bset(m66592, M66592_DPRPU, M66592_SYSCFG);\n\telse\n\t\tm66592_bclr(m66592, M66592_DPRPU, M66592_SYSCFG);\n\tspin_unlock_irqrestore(&m66592->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops m66592_gadget_ops = {\n\t.get_frame\t\t= m66592_get_frame,\n\t.udc_start\t\t= m66592_udc_start,\n\t.udc_stop\t\t= m66592_udc_stop,\n\t.pullup\t\t\t= m66592_pullup,\n};\n\nstatic void m66592_remove(struct platform_device *pdev)\n{\n\tstruct m66592\t\t*m66592 = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&m66592->gadget);\n\n\ttimer_shutdown_sync(&m66592->timer);\n\tiounmap(m66592->reg);\n\tfree_irq(platform_get_irq(pdev, 0), m66592);\n\tm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\n\tif (m66592->pdata->on_chip) {\n\t\tclk_disable(m66592->clk);\n\t\tclk_put(m66592->clk);\n\t}\n\tkfree(m66592);\n}\n\nstatic void nop_completion(struct usb_ep *ep, struct usb_request *r)\n{\n}\n\nstatic int m66592_probe(struct platform_device *pdev)\n{\n\tstruct resource *res, *ires;\n\tvoid __iomem *reg = NULL;\n\tstruct m66592 *m66592 = NULL;\n\tchar clk_name[8];\n\tint ret = 0;\n\tint i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tpr_err(\"platform_get_resource error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!ires) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev,\n\t\t\t\"platform_get_resource IORESOURCE_IRQ error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\treg = ioremap(res->start, resource_size(res));\n\tif (reg == NULL) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"ioremap error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tif (dev_get_platdata(&pdev->dev) == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clean_up;\n\t}\n\n\t \n\tm66592 = kzalloc(sizeof(struct m66592), GFP_KERNEL);\n\tif (m66592 == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto clean_up;\n\t}\n\n\tm66592->pdata = dev_get_platdata(&pdev->dev);\n\tm66592->irq_trigger = ires->flags & IRQF_TRIGGER_MASK;\n\n\tspin_lock_init(&m66592->lock);\n\tplatform_set_drvdata(pdev, m66592);\n\n\tm66592->gadget.ops = &m66592_gadget_ops;\n\tm66592->gadget.max_speed = USB_SPEED_HIGH;\n\tm66592->gadget.name = udc_name;\n\n\ttimer_setup(&m66592->timer, m66592_timer, 0);\n\tm66592->reg = reg;\n\n\tret = request_irq(ires->start, m66592_irq, IRQF_SHARED,\n\t\t\tudc_name, m66592);\n\tif (ret < 0) {\n\t\tpr_err(\"request_irq error (%d)\\n\", ret);\n\t\tgoto clean_up;\n\t}\n\n\tif (m66592->pdata->on_chip) {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"usbf%d\", pdev->id);\n\t\tm66592->clk = clk_get(&pdev->dev, clk_name);\n\t\tif (IS_ERR(m66592->clk)) {\n\t\t\tdev_err(&pdev->dev, \"cannot get clock \\\"%s\\\"\\n\",\n\t\t\t\tclk_name);\n\t\t\tret = PTR_ERR(m66592->clk);\n\t\t\tgoto clean_up2;\n\t\t}\n\t\tclk_enable(m66592->clk);\n\t}\n\n\tINIT_LIST_HEAD(&m66592->gadget.ep_list);\n\tm66592->gadget.ep0 = &m66592->ep[0].ep;\n\tINIT_LIST_HEAD(&m66592->gadget.ep0->ep_list);\n\tfor (i = 0; i < M66592_MAX_NUM_PIPE; i++) {\n\t\tstruct m66592_ep *ep = &m66592->ep[i];\n\n\t\tif (i != 0) {\n\t\t\tINIT_LIST_HEAD(&m66592->ep[i].ep.ep_list);\n\t\t\tlist_add_tail(&m66592->ep[i].ep.ep_list,\n\t\t\t\t\t&m66592->gadget.ep_list);\n\t\t}\n\t\tep->m66592 = m66592;\n\t\tINIT_LIST_HEAD(&ep->queue);\n\t\tep->ep.name = m66592_ep_name[i];\n\t\tep->ep.ops = &m66592_ep_ops;\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, 512);\n\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\t}\n\tusb_ep_set_maxpacket_limit(&m66592->ep[0].ep, 64);\n\tm66592->ep[0].pipenum = 0;\n\tm66592->ep[0].fifoaddr = M66592_CFIFO;\n\tm66592->ep[0].fifosel = M66592_CFIFOSEL;\n\tm66592->ep[0].fifoctr = M66592_CFIFOCTR;\n\tm66592->ep[0].fifotrn = 0;\n\tm66592->ep[0].pipectr = get_pipectr_addr(0);\n\tm66592->pipenum2ep[0] = &m66592->ep[0];\n\tm66592->epaddr2ep[0] = &m66592->ep[0];\n\n\tm66592->ep0_req = m66592_alloc_request(&m66592->ep[0].ep, GFP_KERNEL);\n\tif (m66592->ep0_req == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto clean_up3;\n\t}\n\tm66592->ep0_req->complete = nop_completion;\n\n\tinit_controller(m66592);\n\n\tret = usb_add_gadget_udc(&pdev->dev, &m66592->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\n\tdev_info(&pdev->dev, \"version %s\\n\", DRIVER_VERSION);\n\treturn 0;\n\nerr_add_udc:\n\tm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\n\tm66592->ep0_req = NULL;\nclean_up3:\n\tif (m66592->pdata->on_chip) {\n\t\tclk_disable(m66592->clk);\n\t\tclk_put(m66592->clk);\n\t}\nclean_up2:\n\tfree_irq(ires->start, m66592);\nclean_up:\n\tif (m66592) {\n\t\tif (m66592->ep0_req)\n\t\t\tm66592_free_request(&m66592->ep[0].ep, m66592->ep0_req);\n\t\tkfree(m66592);\n\t}\n\tif (reg)\n\t\tiounmap(reg);\n\n\treturn ret;\n}\n\n \nstatic struct platform_driver m66592_driver = {\n\t.remove_new =\tm66592_remove,\n\t.driver\t\t= {\n\t\t.name =\tudc_name,\n\t},\n};\n\nmodule_platform_driver_probe(m66592_driver, m66592_probe);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}