{
  "module_name": "aspeed_udc.c",
  "hash_id": "b40c2d527ead6719794c9d75be9db6f14694ad454c68579fcb7f6b2a4a7cceca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/aspeed_udc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/slab.h>\n\n#define AST_UDC_NUM_ENDPOINTS\t\t(1 + 4)\n#define AST_UDC_EP0_MAX_PACKET\t\t64\t \n#define AST_UDC_EPn_MAX_PACKET\t\t1024\t \n#define AST_UDC_DESCS_COUNT\t\t256\t \n#define AST_UDC_DESC_MODE\t\t1\t \n\n#define AST_UDC_EP_DMA_SIZE\t\t(AST_UDC_EPn_MAX_PACKET + 8 * AST_UDC_DESCS_COUNT)\n\n \n\n#define AST_UDC_FUNC_CTRL\t\t0x00\t \n#define AST_UDC_CONFIG\t\t\t0x04\t \n#define AST_UDC_IER\t\t\t0x08\t \n#define AST_UDC_ISR\t\t\t0x0C\t \n#define AST_UDC_EP_ACK_IER\t\t0x10\t \n#define AST_UDC_EP_NAK_IER\t\t0x14\t \n#define AST_UDC_EP_ACK_ISR\t\t0x18\t \n#define AST_UDC_EP_NAK_ISR\t\t0x1C\t \n#define AST_UDC_DEV_RESET\t\t0x20\t \n#define AST_UDC_STS\t\t\t0x24\t \n#define AST_VHUB_EP_DATA\t\t0x28\t \n#define AST_VHUB_ISO_TX_FAIL\t\t0x2C\t \n#define AST_UDC_EP0_CTRL\t\t0x30\t \n#define AST_UDC_EP0_DATA_BUFF\t\t0x34\t \n#define AST_UDC_SETUP0\t\t\t0x80     \n#define AST_UDC_SETUP1\t\t\t0x84     \n\n\n \n#define USB_PHY_CLK_EN\t\t\tBIT(31)\n#define USB_FIFO_DYN_PWRD_EN\t\tBIT(19)\n#define USB_EP_LONG_DESC\t\tBIT(18)\n#define USB_BIST_TEST_PASS\t\tBIT(13)\n#define USB_BIST_TURN_ON\t\tBIT(12)\n#define USB_PHY_RESET_DIS\t\tBIT(11)\n#define USB_TEST_MODE(x)\t\t((x) << 8)\n#define USB_FORCE_TIMER_HS\t\tBIT(7)\n#define USB_FORCE_HS\t\t\tBIT(6)\n#define USB_REMOTE_WAKEUP_12MS\t\tBIT(5)\n#define USB_REMOTE_WAKEUP_EN\t\tBIT(4)\n#define USB_AUTO_REMOTE_WAKEUP_EN\tBIT(3)\n#define USB_STOP_CLK_IN_SUPEND\t\tBIT(2)\n#define USB_UPSTREAM_FS\t\t\tBIT(1)\n#define USB_UPSTREAM_EN\t\t\tBIT(0)\n\n \n#define UDC_CFG_SET_ADDR(x)\t\t((x) & 0x3f)\n#define UDC_CFG_ADDR_MASK\t\t(0x3f)\n\n \n#define UDC_IRQ_EP_POOL_NAK\t\tBIT(17)\n#define UDC_IRQ_EP_POOL_ACK_STALL\tBIT(16)\n#define UDC_IRQ_BUS_RESUME\t\tBIT(8)\n#define UDC_IRQ_BUS_SUSPEND\t\tBIT(7)\n#define UDC_IRQ_BUS_RESET\t\tBIT(6)\n#define UDC_IRQ_EP0_IN_DATA_NAK\t\tBIT(4)\n#define UDC_IRQ_EP0_IN_ACK_STALL\tBIT(3)\n#define UDC_IRQ_EP0_OUT_NAK\t\tBIT(2)\n#define UDC_IRQ_EP0_OUT_ACK_STALL\tBIT(1)\n#define UDC_IRQ_EP0_SETUP\t\tBIT(0)\n#define UDC_IRQ_ACK_ALL\t\t\t(0x1ff)\n\n \n#define USB_EP3_ISR\t\t\tBIT(3)\n#define USB_EP2_ISR\t\t\tBIT(2)\n#define USB_EP1_ISR\t\t\tBIT(1)\n#define USB_EP0_ISR\t\t\tBIT(0)\n#define UDC_IRQ_EP_ACK_ALL\t\t(0xf)\n\n \n#define ROOT_UDC_SOFT_RESET\t\tBIT(0)\n\n \n#define UDC_STS_HIGHSPEED\t\tBIT(27)\n\n \n#define EP_TOGGLE_SET_EPNUM(x)\t\t((x) & 0x3)\n\n \n#define EP0_GET_RX_LEN(x)\t\t((x >> 16) & 0x7f)\n#define EP0_TX_LEN(x)\t\t\t((x & 0x7f) << 8)\n#define EP0_RX_BUFF_RDY\t\t\tBIT(2)\n#define EP0_TX_BUFF_RDY\t\t\tBIT(1)\n#define EP0_STALL\t\t\tBIT(0)\n\n \n\n#define AST_UDC_EP_CONFIG\t\t0x00\t \n#define AST_UDC_EP_DMA_CTRL\t\t0x04\t \n#define AST_UDC_EP_DMA_BUFF\t\t0x08\t \n#define AST_UDC_EP_DMA_STS\t\t0x0C\t \n\n#define AST_UDC_EP_BASE\t\t\t0x200\n#define AST_UDC_EP_OFFSET\t\t0x10\n\n \n#define EP_SET_MAX_PKT(x)\t\t((x & 0x3ff) << 16)\n#define EP_DATA_FETCH_CTRL(x)\t\t((x & 0x3) << 14)\n#define EP_AUTO_DATA_DISABLE\t\t(0x1 << 13)\n#define EP_SET_EP_STALL\t\t\t(0x1 << 12)\n#define EP_SET_EP_NUM(x)\t\t((x & 0xf) << 8)\n#define EP_SET_TYPE_MASK(x)\t\t((x) << 5)\n#define EP_TYPE_BULK\t\t\t(0x1)\n#define EP_TYPE_INT\t\t\t(0x2)\n#define EP_TYPE_ISO\t\t\t(0x3)\n#define EP_DIR_OUT\t\t\t(0x1 << 4)\n#define EP_ALLOCATED_MASK\t\t(0x7 << 1)\n#define EP_ENABLE\t\t\tBIT(0)\n\n \n#define EP_DMA_CTRL_GET_PROC_STS(x)\t((x >> 4) & 0xf)\n#define EP_DMA_CTRL_STS_RX_IDLE\t\t0x0\n#define EP_DMA_CTRL_STS_TX_IDLE\t\t0x8\n#define EP_DMA_CTRL_IN_LONG_MODE\t(0x1 << 3)\n#define EP_DMA_CTRL_RESET\t\t(0x1 << 2)\n#define EP_DMA_SINGLE_STAGE\t\t(0x1 << 1)\n#define EP_DMA_DESC_MODE\t\t(0x1 << 0)\n\n \n#define EP_DMA_SET_TX_SIZE(x)\t\t((x & 0x7ff) << 16)\n#define EP_DMA_GET_TX_SIZE(x)\t\t(((x) >> 16) & 0x7ff)\n#define EP_DMA_GET_RPTR(x)\t\t(((x) >> 8) & 0xff)\n#define EP_DMA_GET_WPTR(x)\t\t((x) & 0xff)\n#define EP_DMA_SINGLE_KICK\t\t(1 << 0)  \n\n \n#define AST_EP_DMA_DESC_INTR_ENABLE\tBIT(31)\n#define AST_EP_DMA_DESC_PID_DATA0\t(0 << 14)\n#define AST_EP_DMA_DESC_PID_DATA2\tBIT(14)\n#define AST_EP_DMA_DESC_PID_DATA1\t(2 << 14)\n#define AST_EP_DMA_DESC_PID_MDATA\t(3 << 14)\n#define EP_DESC1_IN_LEN(x)\t\t((x) & 0x1fff)\n#define AST_EP_DMA_DESC_MAX_LEN\t\t(7680)  \n\nstruct ast_udc_request {\n\tstruct usb_request\treq;\n\tstruct list_head\tqueue;\n\tunsigned\t\tmapped:1;\n\tunsigned int\t\tactual_dma_length;\n\tu32\t\t\tsaved_dma_wptr;\n};\n\n#define to_ast_req(__req) container_of(__req, struct ast_udc_request, req)\n\nstruct ast_dma_desc {\n\tu32\tdes_0;\n\tu32\tdes_1;\n};\n\nstruct ast_udc_ep {\n\tstruct usb_ep\t\t\tep;\n\n\t \n\tstruct list_head\t\tqueue;\n\n\tstruct ast_udc_dev\t\t*udc;\n\tvoid __iomem\t\t\t*ep_reg;\n\tvoid\t\t\t\t*epn_buf;\n\tdma_addr_t\t\t\tepn_buf_dma;\n\tconst struct usb_endpoint_descriptor\t*desc;\n\n\t \n\tstruct ast_dma_desc\t\t*descs;\n\tdma_addr_t\t\t\tdescs_dma;\n\tu32\t\t\t\tdescs_wptr;\n\tu32\t\t\t\tchunk_max;\n\n\tbool\t\t\t\tdir_in:1;\n\tunsigned\t\t\tstopped:1;\n\tbool\t\t\t\tdesc_mode:1;\n};\n\n#define to_ast_ep(__ep) container_of(__ep, struct ast_udc_ep, ep)\n\nstruct ast_udc_dev {\n\tstruct platform_device\t\t*pdev;\n\tvoid __iomem\t\t\t*reg;\n\tint\t\t\t\tirq;\n\tspinlock_t\t\t\tlock;\n\tstruct clk\t\t\t*clk;\n\tstruct work_struct\t\twake_work;\n\n\t \n\tvoid\t\t\t\t*ep0_buf;\n\tdma_addr_t\t\t\tep0_buf_dma;\n\tstruct ast_udc_ep\t\tep[AST_UDC_NUM_ENDPOINTS];\n\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\tvoid __iomem\t\t\t*creq;\n\tenum usb_device_state\t\tsuspended_from;\n\tint\t\t\t\tdesc_mode;\n\n\t \n\tbool\t\t\t\tforce_usb1:1;\n\tunsigned\t\t\tis_control_tx:1;\n\tbool\t\t\t\twakeup_en:1;\n};\n\n#define to_ast_dev(__g) container_of(__g, struct ast_udc_dev, gadget)\n\nstatic const char * const ast_ep_name[] = {\n\t\"ep0\", \"ep1\", \"ep2\", \"ep3\", \"ep4\"\n};\n\n#ifdef AST_UDC_DEBUG_ALL\n#define AST_UDC_DEBUG\n#define AST_SETUP_DEBUG\n#define AST_EP_DEBUG\n#define AST_ISR_DEBUG\n#endif\n\n#ifdef AST_SETUP_DEBUG\n#define SETUP_DBG(u, fmt, ...)\t\\\n\tdev_dbg(&(u)->pdev->dev, \"%s() \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define SETUP_DBG(u, fmt, ...)\n#endif\n\n#ifdef AST_EP_DEBUG\n#define EP_DBG(e, fmt, ...)\t\\\n\tdev_dbg(&(e)->udc->pdev->dev, \"%s():%s \" fmt, __func__,\t\\\n\t\t (e)->ep.name, ##__VA_ARGS__)\n#else\n#define EP_DBG(ep, fmt, ...)\t((void)(ep))\n#endif\n\n#ifdef AST_UDC_DEBUG\n#define UDC_DBG(u, fmt, ...)\t\\\n\tdev_dbg(&(u)->pdev->dev, \"%s() \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define UDC_DBG(u, fmt, ...)\n#endif\n\n#ifdef AST_ISR_DEBUG\n#define ISR_DBG(u, fmt, ...)\t\\\n\tdev_dbg(&(u)->pdev->dev, \"%s() \" fmt, __func__, ##__VA_ARGS__)\n#else\n#define ISR_DBG(u, fmt, ...)\n#endif\n\n \n#define ast_udc_read(udc, offset) \\\n\treadl((udc)->reg + (offset))\n#define ast_udc_write(udc, val, offset) \\\n\twritel((val), (udc)->reg + (offset))\n\n#define ast_ep_read(ep, reg) \\\n\treadl((ep)->ep_reg + (reg))\n#define ast_ep_write(ep, val, reg) \\\n\twritel((val), (ep)->ep_reg + (reg))\n\n \n\nstatic void ast_udc_done(struct ast_udc_ep *ep, struct ast_udc_request *req,\n\t\t\t int status)\n{\n\tstruct ast_udc_dev *udc = ep->udc;\n\n\tEP_DBG(ep, \"req @%p, len (%d/%d), buf:0x%x, dir:0x%x\\n\",\n\t       req, req->req.actual, req->req.length,\n\t       (u32)req->req.buf, ep->dir_in);\n\n\tlist_del(&req->queue);\n\n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = status;\n\telse\n\t\tstatus = req->req.status;\n\n\tif (status && status != -ESHUTDOWN)\n\t\tEP_DBG(ep, \"done req:%p, status:%d\\n\", req, status);\n\n\tspin_unlock(&udc->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&udc->lock);\n}\n\nstatic void ast_udc_nuke(struct ast_udc_ep *ep, int status)\n{\n\tint count = 0;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct ast_udc_request *req;\n\n\t\treq = list_entry(ep->queue.next, struct ast_udc_request,\n\t\t\t\t queue);\n\t\tast_udc_done(ep, req, status);\n\t\tcount++;\n\t}\n\n\tif (count)\n\t\tEP_DBG(ep, \"Nuked %d request(s)\\n\", count);\n}\n\n \nstatic void ast_udc_stop_activity(struct ast_udc_dev *udc)\n{\n\tstruct ast_udc_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < AST_UDC_NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tep->stopped = 1;\n\t\tast_udc_nuke(ep, -ESHUTDOWN);\n\t}\n}\n\nstatic int ast_udc_ep_enable(struct usb_ep *_ep,\n\t\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tu16 maxpacket = usb_endpoint_maxp(desc);\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_dev *udc = ep->udc;\n\tu8 epnum = usb_endpoint_num(desc);\n\tunsigned long flags;\n\tu32 ep_conf = 0;\n\tu8 dir_in;\n\tu8 type;\n\n\tif (!_ep || !ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT ||\n\t    maxpacket == 0 || maxpacket > ep->ep.maxpacket) {\n\t\tEP_DBG(ep, \"Failed, invalid EP enable param\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udc->driver) {\n\t\tEP_DBG(ep, \"bogus device state\\n\");\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tEP_DBG(ep, \"maxpacket:0x%x\\n\", maxpacket);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tep->desc = desc;\n\tep->stopped = 0;\n\tep->ep.maxpacket = maxpacket;\n\tep->chunk_max = AST_EP_DMA_DESC_MAX_LEN;\n\n\tif (maxpacket < AST_UDC_EPn_MAX_PACKET)\n\t\tep_conf = EP_SET_MAX_PKT(maxpacket);\n\n\tep_conf |= EP_SET_EP_NUM(epnum);\n\n\ttype = usb_endpoint_type(desc);\n\tdir_in = usb_endpoint_dir_in(desc);\n\tep->dir_in = dir_in;\n\tif (!ep->dir_in)\n\t\tep_conf |= EP_DIR_OUT;\n\n\tEP_DBG(ep, \"type %d, dir_in %d\\n\", type, dir_in);\n\tswitch (type) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tep_conf |= EP_SET_TYPE_MASK(EP_TYPE_ISO);\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep_conf |= EP_SET_TYPE_MASK(EP_TYPE_BULK);\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep_conf |= EP_SET_TYPE_MASK(EP_TYPE_INT);\n\t\tbreak;\n\t}\n\n\tep->desc_mode = udc->desc_mode && ep->descs_dma && ep->dir_in;\n\tif (ep->desc_mode) {\n\t\tast_ep_write(ep, EP_DMA_CTRL_RESET, AST_UDC_EP_DMA_CTRL);\n\t\tast_ep_write(ep, 0, AST_UDC_EP_DMA_STS);\n\t\tast_ep_write(ep, ep->descs_dma, AST_UDC_EP_DMA_BUFF);\n\n\t\t \n\t\tast_ep_write(ep, EP_DMA_CTRL_IN_LONG_MODE | EP_DMA_DESC_MODE,\n\t\t\t     AST_UDC_EP_DMA_CTRL);\n\n\t\tep->descs_wptr = 0;\n\n\t} else {\n\t\tast_ep_write(ep, EP_DMA_CTRL_RESET, AST_UDC_EP_DMA_CTRL);\n\t\tast_ep_write(ep, EP_DMA_SINGLE_STAGE, AST_UDC_EP_DMA_CTRL);\n\t\tast_ep_write(ep, 0, AST_UDC_EP_DMA_STS);\n\t}\n\n\t \n\tast_udc_write(udc, EP_TOGGLE_SET_EPNUM(epnum), AST_VHUB_EP_DATA);\n\n\t \n\tast_ep_write(ep, ep_conf | EP_ENABLE, AST_UDC_EP_CONFIG);\n\n\tEP_DBG(ep, \"ep_config: 0x%x\\n\", ast_ep_read(ep, AST_UDC_EP_CONFIG));\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_udc_ep_disable(struct usb_ep *_ep)\n{\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_dev *udc = ep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tep->ep.desc = NULL;\n\tep->stopped = 1;\n\n\tast_udc_nuke(ep, -ESHUTDOWN);\n\tast_ep_write(ep, 0, AST_UDC_EP_CONFIG);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_request *ast_udc_ep_alloc_request(struct usb_ep *_ep,\n\t\t\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_request *req;\n\n\treq = kzalloc(sizeof(struct ast_udc_request), gfp_flags);\n\tif (!req) {\n\t\tEP_DBG(ep, \"request allocation failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\nstatic void ast_udc_ep_free_request(struct usb_ep *_ep,\n\t\t\t\t    struct usb_request *_req)\n{\n\tstruct ast_udc_request *req = to_ast_req(_req);\n\n\tkfree(req);\n}\n\nstatic int ast_dma_descriptor_setup(struct ast_udc_ep *ep, u32 dma_buf,\n\t\t\t\t    u16 tx_len, struct ast_udc_request *req)\n{\n\tstruct ast_udc_dev *udc = ep->udc;\n\tstruct device *dev = &udc->pdev->dev;\n\tbool last = false;\n\tint chunk, count;\n\tu32 offset;\n\n\tif (!ep->descs) {\n\t\tdev_warn(dev, \"%s: Empty DMA descs list failure\\n\",\n\t\t\t ep->ep.name);\n\t\treturn -EINVAL;\n\t}\n\n\tchunk = tx_len;\n\toffset = count = 0;\n\n\tEP_DBG(ep, \"req @%p, %s:%d, %s:0x%x, %s:0x%x\\n\", req,\n\t       \"wptr\", ep->descs_wptr, \"dma_buf\", dma_buf,\n\t       \"tx_len\", tx_len);\n\n\t \n\twhile (chunk >= 0 && !last && count < AST_UDC_DESCS_COUNT) {\n\n\t\tep->descs[ep->descs_wptr].des_0 = dma_buf + offset;\n\n\t\tif (chunk > ep->chunk_max) {\n\t\t\tep->descs[ep->descs_wptr].des_1 = ep->chunk_max;\n\t\t} else {\n\t\t\tep->descs[ep->descs_wptr].des_1 = chunk;\n\t\t\tlast = true;\n\t\t}\n\n\t\tchunk -= ep->chunk_max;\n\n\t\tEP_DBG(ep, \"descs[%d]: 0x%x 0x%x\\n\",\n\t\t       ep->descs_wptr,\n\t\t       ep->descs[ep->descs_wptr].des_0,\n\t\t       ep->descs[ep->descs_wptr].des_1);\n\n\t\tif (count == 0)\n\t\t\treq->saved_dma_wptr = ep->descs_wptr;\n\n\t\tep->descs_wptr++;\n\t\tcount++;\n\n\t\tif (ep->descs_wptr >= AST_UDC_DESCS_COUNT)\n\t\t\tep->descs_wptr = 0;\n\n\t\toffset = ep->chunk_max * count;\n\t}\n\n\treturn 0;\n}\n\nstatic void ast_udc_epn_kick(struct ast_udc_ep *ep, struct ast_udc_request *req)\n{\n\tu32 tx_len;\n\tu32 last;\n\n\tlast = req->req.length - req->req.actual;\n\ttx_len = last > ep->ep.maxpacket ? ep->ep.maxpacket : last;\n\n\tEP_DBG(ep, \"kick req @%p, len:%d, dir:%d\\n\",\n\t       req, tx_len, ep->dir_in);\n\n\tast_ep_write(ep, req->req.dma + req->req.actual, AST_UDC_EP_DMA_BUFF);\n\n\t \n\tast_ep_write(ep, EP_DMA_SET_TX_SIZE(tx_len), AST_UDC_EP_DMA_STS);\n\tast_ep_write(ep, EP_DMA_SET_TX_SIZE(tx_len) | EP_DMA_SINGLE_KICK,\n\t\t     AST_UDC_EP_DMA_STS);\n}\n\nstatic void ast_udc_epn_kick_desc(struct ast_udc_ep *ep,\n\t\t\t\t  struct ast_udc_request *req)\n{\n\tu32 descs_max_size;\n\tu32 tx_len;\n\tu32 last;\n\n\tdescs_max_size = AST_EP_DMA_DESC_MAX_LEN * AST_UDC_DESCS_COUNT;\n\n\tlast = req->req.length - req->req.actual;\n\ttx_len = last > descs_max_size ? descs_max_size : last;\n\n\tEP_DBG(ep, \"kick req @%p, %s:%d, %s:0x%x, %s:0x%x (%d/%d), %s:0x%x\\n\",\n\t       req, \"tx_len\", tx_len, \"dir_in\", ep->dir_in,\n\t       \"dma\", req->req.dma + req->req.actual,\n\t       req->req.actual, req->req.length,\n\t       \"descs_max_size\", descs_max_size);\n\n\tif (!ast_dma_descriptor_setup(ep, req->req.dma + req->req.actual,\n\t\t\t\t      tx_len, req))\n\t\treq->actual_dma_length += tx_len;\n\n\t \n\tmb();\n\n\tast_ep_write(ep, ep->descs_wptr, AST_UDC_EP_DMA_STS);\n\n\tEP_DBG(ep, \"descs_wptr:%d, dstat:0x%x, dctrl:0x%x\\n\",\n\t       ep->descs_wptr,\n\t       ast_ep_read(ep, AST_UDC_EP_DMA_STS),\n\t       ast_ep_read(ep, AST_UDC_EP_DMA_CTRL));\n}\n\nstatic void ast_udc_ep0_queue(struct ast_udc_ep *ep,\n\t\t\t      struct ast_udc_request *req)\n{\n\tstruct ast_udc_dev *udc = ep->udc;\n\tu32 tx_len;\n\tu32 last;\n\n\tlast = req->req.length - req->req.actual;\n\ttx_len = last > ep->ep.maxpacket ? ep->ep.maxpacket : last;\n\n\tast_udc_write(udc, req->req.dma + req->req.actual,\n\t\t      AST_UDC_EP0_DATA_BUFF);\n\n\tif (ep->dir_in) {\n\t\t \n\t\tSETUP_DBG(udc, \"IN: %s:0x%x, %s:0x%x, %s:%d (%d/%d), %s:%d\\n\",\n\t\t\t  \"buf\", (u32)req->req.buf,\n\t\t\t  \"dma\", req->req.dma + req->req.actual,\n\t\t\t  \"tx_len\", tx_len,\n\t\t\t  req->req.actual, req->req.length,\n\t\t\t  \"dir_in\", ep->dir_in);\n\n\t\treq->req.actual += tx_len;\n\t\tast_udc_write(udc, EP0_TX_LEN(tx_len), AST_UDC_EP0_CTRL);\n\t\tast_udc_write(udc, EP0_TX_LEN(tx_len) | EP0_TX_BUFF_RDY,\n\t\t\t      AST_UDC_EP0_CTRL);\n\n\t} else {\n\t\t \n\t\tSETUP_DBG(udc, \"OUT: %s:%x, %s:%x, %s:(%d/%d), %s:%d\\n\",\n\t\t\t  \"buf\", (u32)req->req.buf,\n\t\t\t  \"dma\", req->req.dma + req->req.actual,\n\t\t\t  \"len\", req->req.actual, req->req.length,\n\t\t\t  \"dir_in\", ep->dir_in);\n\n\t\tif (!req->req.length) {\n\t\t\t \n\t\t\tast_udc_write(udc, EP0_TX_BUFF_RDY, AST_UDC_EP0_CTRL);\n\t\t\tep->dir_in = 0x1;\n\t\t} else\n\t\t\tast_udc_write(udc, EP0_RX_BUFF_RDY, AST_UDC_EP0_CTRL);\n\t}\n}\n\nstatic int ast_udc_ep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct ast_udc_request *req = to_ast_req(_req);\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_dev *udc = ep->udc;\n\tstruct device *dev = &udc->pdev->dev;\n\tunsigned long flags;\n\tint rc;\n\n\tif (unlikely(!_req || !_req->complete || !_req->buf || !_ep)) {\n\t\tdev_warn(dev, \"Invalid EP request !\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ep->stopped) {\n\t\tdev_warn(dev, \"%s is already stopped !\\n\", _ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tlist_add_tail(&req->queue, &ep->queue);\n\n\treq->req.actual = 0;\n\treq->req.status = -EINPROGRESS;\n\treq->actual_dma_length = 0;\n\n\trc = usb_gadget_map_request(&udc->gadget, &req->req, ep->dir_in);\n\tif (rc) {\n\t\tEP_DBG(ep, \"Request mapping failure %d\\n\", rc);\n\t\tdev_warn(dev, \"Request mapping failure %d\\n\", rc);\n\t\tgoto end;\n\t}\n\n\tEP_DBG(ep, \"enqueue req @%p\\n\", req);\n\tEP_DBG(ep, \"l=%d, dma:0x%x, zero:%d, is_in:%d\\n\",\n\t\t_req->length, _req->dma, _req->zero, ep->dir_in);\n\n\t \n\tif (ep->ep.desc == NULL) {\n\t\tif ((req->req.dma % 4) != 0) {\n\t\t\tdev_warn(dev, \"EP0 req dma alignment error\\n\");\n\t\t\trc = -ESHUTDOWN;\n\t\t\tgoto end;\n\t\t}\n\n\t\tast_udc_ep0_queue(ep, req);\n\t\tgoto end;\n\t}\n\n\t \n\tif (list_is_singular(&ep->queue)) {\n\t\tif (ep->desc_mode)\n\t\t\tast_udc_epn_kick_desc(ep, req);\n\t\telse\n\t\t\tast_udc_epn_kick(ep, req);\n\t}\n\nend:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn rc;\n}\n\nstatic int ast_udc_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_dev *udc = ep->udc;\n\tstruct ast_udc_request *req;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tlist_for_each_entry(req, &ep->queue, queue) {\n\t\tif (&req->req == _req) {\n\t\t\tlist_del_init(&req->queue);\n\t\t\tast_udc_done(ep, req, -ESHUTDOWN);\n\t\t\t_req->status = -ECONNRESET;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (&req->req != _req)\n\t\trc = -EINVAL;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn rc;\n}\n\nstatic int ast_udc_ep_set_halt(struct usb_ep *_ep, int value)\n{\n\tstruct ast_udc_ep *ep = to_ast_ep(_ep);\n\tstruct ast_udc_dev *udc = ep->udc;\n\tunsigned long flags;\n\tint epnum;\n\tu32 ctrl;\n\n\tEP_DBG(ep, \"val:%d\\n\", value);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tepnum = usb_endpoint_num(ep->desc);\n\n\t \n\tif (epnum == 0) {\n\t\tctrl = ast_udc_read(udc, AST_UDC_EP0_CTRL);\n\t\tif (value)\n\t\t\tctrl |= EP0_STALL;\n\t\telse\n\t\t\tctrl &= ~EP0_STALL;\n\n\t\tast_udc_write(udc, ctrl, AST_UDC_EP0_CTRL);\n\n\t} else {\n\t \n\t\tctrl = ast_udc_read(udc, AST_UDC_EP_CONFIG);\n\t\tif (value)\n\t\t\tctrl |= EP_SET_EP_STALL;\n\t\telse\n\t\t\tctrl &= ~EP_SET_EP_STALL;\n\n\t\tast_ep_write(ep, ctrl, AST_UDC_EP_CONFIG);\n\n\t\t \n\t\tep->stopped = value ? 1 : 0;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops ast_udc_ep_ops = {\n\t.enable\t\t= ast_udc_ep_enable,\n\t.disable\t= ast_udc_ep_disable,\n\t.alloc_request\t= ast_udc_ep_alloc_request,\n\t.free_request\t= ast_udc_ep_free_request,\n\t.queue\t\t= ast_udc_ep_queue,\n\t.dequeue\t= ast_udc_ep_dequeue,\n\t.set_halt\t= ast_udc_ep_set_halt,\n\t \n};\n\nstatic void ast_udc_ep0_rx(struct ast_udc_dev *udc)\n{\n\tast_udc_write(udc, udc->ep0_buf_dma, AST_UDC_EP0_DATA_BUFF);\n\tast_udc_write(udc, EP0_RX_BUFF_RDY, AST_UDC_EP0_CTRL);\n}\n\nstatic void ast_udc_ep0_tx(struct ast_udc_dev *udc)\n{\n\tast_udc_write(udc, udc->ep0_buf_dma, AST_UDC_EP0_DATA_BUFF);\n\tast_udc_write(udc, EP0_TX_BUFF_RDY, AST_UDC_EP0_CTRL);\n}\n\nstatic void ast_udc_ep0_out(struct ast_udc_dev *udc)\n{\n\tstruct device *dev = &udc->pdev->dev;\n\tstruct ast_udc_ep *ep = &udc->ep[0];\n\tstruct ast_udc_request *req;\n\tu16 rx_len;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\treq = list_entry(ep->queue.next, struct ast_udc_request, queue);\n\n\trx_len = EP0_GET_RX_LEN(ast_udc_read(udc, AST_UDC_EP0_CTRL));\n\treq->req.actual += rx_len;\n\n\tSETUP_DBG(udc, \"req %p (%d/%d)\\n\", req,\n\t\t  req->req.actual, req->req.length);\n\n\tif ((rx_len < ep->ep.maxpacket) ||\n\t    (req->req.actual == req->req.length)) {\n\t\tast_udc_ep0_tx(udc);\n\t\tif (!ep->dir_in)\n\t\t\tast_udc_done(ep, req, 0);\n\n\t} else {\n\t\tif (rx_len > req->req.length) {\n\t\t\t\n\t\t\tdev_warn(dev, \"Something wrong (%d/%d)\\n\",\n\t\t\t\t req->req.actual, req->req.length);\n\t\t\tast_udc_ep0_tx(udc);\n\t\t\tast_udc_done(ep, req, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tep->dir_in = 0;\n\n\t\t \n\t\tast_udc_ep0_queue(ep, req);\n\t}\n}\n\nstatic void ast_udc_ep0_in(struct ast_udc_dev *udc)\n{\n\tstruct ast_udc_ep *ep = &udc->ep[0];\n\tstruct ast_udc_request *req;\n\n\tif (list_empty(&ep->queue)) {\n\t\tif (udc->is_control_tx) {\n\t\t\tast_udc_ep0_rx(udc);\n\t\t\tudc->is_control_tx = 0;\n\t\t}\n\n\t\treturn;\n\t}\n\n\treq = list_entry(ep->queue.next, struct ast_udc_request, queue);\n\n\tSETUP_DBG(udc, \"req %p (%d/%d)\\n\", req,\n\t\t  req->req.actual, req->req.length);\n\n\tif (req->req.length == req->req.actual) {\n\t\tif (req->req.length)\n\t\t\tast_udc_ep0_rx(udc);\n\n\t\tif (ep->dir_in)\n\t\t\tast_udc_done(ep, req, 0);\n\n\t} else {\n\t\t \n\t\tast_udc_ep0_queue(ep, req);\n\t}\n}\n\nstatic void ast_udc_epn_handle(struct ast_udc_dev *udc, u16 ep_num)\n{\n\tstruct ast_udc_ep *ep = &udc->ep[ep_num];\n\tstruct ast_udc_request *req;\n\tu16 len = 0;\n\n\tif (list_empty(&ep->queue))\n\t\treturn;\n\n\treq = list_first_entry(&ep->queue, struct ast_udc_request, queue);\n\n\tlen = EP_DMA_GET_TX_SIZE(ast_ep_read(ep, AST_UDC_EP_DMA_STS));\n\treq->req.actual += len;\n\n\tEP_DBG(ep, \"req @%p, length:(%d/%d), %s:0x%x\\n\", req,\n\t\treq->req.actual, req->req.length, \"len\", len);\n\n\t \n\tif (req->req.length == req->req.actual) {\n\t\tast_udc_done(ep, req, 0);\n\t\treq = list_first_entry_or_null(&ep->queue,\n\t\t\t\t\t       struct ast_udc_request,\n\t\t\t\t\t       queue);\n\n\t} else {\n\t\t \n\t\tif (len < ep->ep.maxpacket) {\n\t\t\tast_udc_done(ep, req, 0);\n\t\t\treq = list_first_entry_or_null(&ep->queue,\n\t\t\t\t\t\t       struct ast_udc_request,\n\t\t\t\t\t\t       queue);\n\t\t}\n\t}\n\n\t \n\tif (req)\n\t\tast_udc_epn_kick(ep, req);\n}\n\nstatic void ast_udc_epn_handle_desc(struct ast_udc_dev *udc, u16 ep_num)\n{\n\tstruct ast_udc_ep *ep = &udc->ep[ep_num];\n\tstruct device *dev = &udc->pdev->dev;\n\tstruct ast_udc_request *req;\n\tu32 proc_sts, wr_ptr, rd_ptr;\n\tu32 len_in_desc, ctrl;\n\tu16 total_len = 0;\n\tint i;\n\n\tif (list_empty(&ep->queue)) {\n\t\tdev_warn(dev, \"%s request queue empty!\\n\", ep->ep.name);\n\t\treturn;\n\t}\n\n\treq = list_first_entry(&ep->queue, struct ast_udc_request, queue);\n\n\tctrl = ast_ep_read(ep, AST_UDC_EP_DMA_CTRL);\n\tproc_sts = EP_DMA_CTRL_GET_PROC_STS(ctrl);\n\n\t \n\tif (proc_sts != EP_DMA_CTRL_STS_RX_IDLE &&\n\t    proc_sts != EP_DMA_CTRL_STS_TX_IDLE) {\n\t\tdev_warn(dev, \"EP DMA CTRL: 0x%x, PS:0x%x\\n\",\n\t\t\t ast_ep_read(ep, AST_UDC_EP_DMA_CTRL),\n\t\t\t proc_sts);\n\t\treturn;\n\t}\n\n\tctrl = ast_ep_read(ep, AST_UDC_EP_DMA_STS);\n\trd_ptr = EP_DMA_GET_RPTR(ctrl);\n\twr_ptr = EP_DMA_GET_WPTR(ctrl);\n\n\tif (rd_ptr != wr_ptr) {\n\t\tdev_warn(dev, \"desc list is not empty ! %s:%d, %s:%d\\n\",\n\t\t\"rptr\", rd_ptr, \"wptr\", wr_ptr);\n\t\treturn;\n\t}\n\n\tEP_DBG(ep, \"rd_ptr:%d, wr_ptr:%d\\n\", rd_ptr, wr_ptr);\n\ti = req->saved_dma_wptr;\n\n\tdo {\n\t\tlen_in_desc = EP_DESC1_IN_LEN(ep->descs[i].des_1);\n\t\tEP_DBG(ep, \"desc[%d] len: %d\\n\", i, len_in_desc);\n\t\ttotal_len += len_in_desc;\n\t\ti++;\n\t\tif (i >= AST_UDC_DESCS_COUNT)\n\t\t\ti = 0;\n\n\t} while (i != wr_ptr);\n\n\treq->req.actual += total_len;\n\n\tEP_DBG(ep, \"req @%p, length:(%d/%d), %s:0x%x\\n\", req,\n\t\treq->req.actual, req->req.length, \"len\", total_len);\n\n\t \n\tif (req->req.length == req->req.actual) {\n\t\tast_udc_done(ep, req, 0);\n\t\treq = list_first_entry_or_null(&ep->queue,\n\t\t\t\t\t       struct ast_udc_request,\n\t\t\t\t\t       queue);\n\n\t} else {\n\t\t \n\t\tif (total_len < ep->ep.maxpacket) {\n\t\t\tast_udc_done(ep, req, 0);\n\t\t\treq = list_first_entry_or_null(&ep->queue,\n\t\t\t\t\t\t       struct ast_udc_request,\n\t\t\t\t\t\t       queue);\n\t\t}\n\t}\n\n\t \n\tif (req && (req->actual_dma_length == req->req.actual)) {\n\t\tEP_DBG(ep, \"More requests\\n\");\n\t\tast_udc_epn_kick_desc(ep, req);\n\t}\n}\n\nstatic void ast_udc_ep0_data_tx(struct ast_udc_dev *udc, u8 *tx_data, u32 len)\n{\n\tif (len) {\n\t\tmemcpy(udc->ep0_buf, tx_data, len);\n\n\t\tast_udc_write(udc, udc->ep0_buf_dma, AST_UDC_EP0_DATA_BUFF);\n\t\tast_udc_write(udc, EP0_TX_LEN(len), AST_UDC_EP0_CTRL);\n\t\tast_udc_write(udc, EP0_TX_LEN(len) | EP0_TX_BUFF_RDY,\n\t\t\t      AST_UDC_EP0_CTRL);\n\t\tudc->is_control_tx = 1;\n\n\t} else\n\t\tast_udc_write(udc, EP0_TX_BUFF_RDY, AST_UDC_EP0_CTRL);\n}\n\nstatic void ast_udc_getstatus(struct ast_udc_dev *udc)\n{\n\tstruct usb_ctrlrequest crq;\n\tstruct ast_udc_ep *ep;\n\tu16 status = 0;\n\tu16 epnum = 0;\n\n\tmemcpy_fromio(&crq, udc->creq, sizeof(crq));\n\n\tswitch (crq.bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\t \n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = crq.wIndex & USB_ENDPOINT_NUMBER_MASK;\n\t\tstatus = udc->ep[epnum].stopped;\n\t\tbreak;\n\tdefault:\n\t\tgoto stall;\n\t}\n\n\tep = &udc->ep[epnum];\n\tEP_DBG(ep, \"status: 0x%x\\n\", status);\n\tast_udc_ep0_data_tx(udc, (u8 *)&status, sizeof(status));\n\n\treturn;\n\nstall:\n\tEP_DBG(ep, \"Can't respond request\\n\");\n\tast_udc_write(udc, ast_udc_read(udc, AST_UDC_EP0_CTRL) | EP0_STALL,\n\t\t      AST_UDC_EP0_CTRL);\n}\n\nstatic void ast_udc_ep0_handle_setup(struct ast_udc_dev *udc)\n{\n\tstruct ast_udc_ep *ep = &udc->ep[0];\n\tstruct ast_udc_request *req;\n\tstruct usb_ctrlrequest crq;\n\tint req_num = 0;\n\tint rc = 0;\n\tu32 reg;\n\n\tmemcpy_fromio(&crq, udc->creq, sizeof(crq));\n\n\tSETUP_DBG(udc, \"SETUP packet: %02x/%02x/%04x/%04x/%04x\\n\",\n\t\t  crq.bRequestType, crq.bRequest, le16_to_cpu(crq.wValue),\n\t\t  le16_to_cpu(crq.wIndex), le16_to_cpu(crq.wLength));\n\n\t \n\tlist_for_each_entry(req, &udc->ep[0].queue, queue) {\n\t\treq_num++;\n\t\tEP_DBG(ep, \"there is req %p in ep0 queue !\\n\", req);\n\t}\n\n\tif (req_num)\n\t\tast_udc_nuke(&udc->ep[0], -ETIMEDOUT);\n\n\tudc->ep[0].dir_in = crq.bRequestType & USB_DIR_IN;\n\n\tif ((crq.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (crq.bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\tif (ast_udc_read(udc, AST_UDC_STS) & UDC_STS_HIGHSPEED)\n\t\t\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\t\telse\n\t\t\t\tudc->gadget.speed = USB_SPEED_FULL;\n\n\t\t\tSETUP_DBG(udc, \"set addr: 0x%x\\n\", crq.wValue);\n\t\t\treg = ast_udc_read(udc, AST_UDC_CONFIG);\n\t\t\treg &= ~UDC_CFG_ADDR_MASK;\n\t\t\treg |= UDC_CFG_SET_ADDR(crq.wValue);\n\t\t\tast_udc_write(udc, reg, AST_UDC_CONFIG);\n\t\t\tgoto req_complete;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tSETUP_DBG(udc, \"ep0: CLEAR FEATURE\\n\");\n\t\t\tgoto req_driver;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tSETUP_DBG(udc, \"ep0: SET FEATURE\\n\");\n\t\t\tgoto req_driver;\n\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tast_udc_getstatus(udc);\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\tgoto req_driver;\n\t\t}\n\n\t}\n\nreq_driver:\n\tif (udc->driver) {\n\t\tSETUP_DBG(udc, \"Forwarding %s to gadget...\\n\",\n\t\t\t  udc->gadget.name);\n\n\t\tspin_unlock(&udc->lock);\n\t\trc = udc->driver->setup(&udc->gadget, &crq);\n\t\tspin_lock(&udc->lock);\n\n\t} else {\n\t\tSETUP_DBG(udc, \"No gadget for request !\\n\");\n\t}\n\n\tif (rc >= 0)\n\t\treturn;\n\n\t \n\tSETUP_DBG(udc, \"Stalling, rc:0x%x\\n\", rc);\n\tast_udc_write(udc, ast_udc_read(udc, AST_UDC_EP0_CTRL) | EP0_STALL,\n\t\t      AST_UDC_EP0_CTRL);\n\treturn;\n\nreq_complete:\n\tSETUP_DBG(udc, \"ep0: Sending IN status without data\\n\");\n\tast_udc_write(udc, EP0_TX_BUFF_RDY, AST_UDC_EP0_CTRL);\n}\n\nstatic irqreturn_t ast_udc_isr(int irq, void *data)\n{\n\tstruct ast_udc_dev *udc = (struct ast_udc_dev *)data;\n\tstruct ast_udc_ep *ep;\n\tu32 isr, ep_isr;\n\tint i;\n\n\tspin_lock(&udc->lock);\n\n\tisr = ast_udc_read(udc, AST_UDC_ISR);\n\tif (!isr)\n\t\tgoto done;\n\n\t \n\tast_udc_write(udc, isr, AST_UDC_ISR);\n\n\tif (isr & UDC_IRQ_BUS_RESET) {\n\t\tISR_DBG(udc, \"UDC_IRQ_BUS_RESET\\n\");\n\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t\tep = &udc->ep[1];\n\t\tEP_DBG(ep, \"dctrl:0x%x\\n\",\n\t\t       ast_ep_read(ep, AST_UDC_EP_DMA_CTRL));\n\n\t\tif (udc->driver && udc->driver->reset) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->reset(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tif (isr & UDC_IRQ_BUS_SUSPEND) {\n\t\tISR_DBG(udc, \"UDC_IRQ_BUS_SUSPEND\\n\");\n\t\tudc->suspended_from = udc->gadget.state;\n\t\tusb_gadget_set_state(&udc->gadget, USB_STATE_SUSPENDED);\n\n\t\tif (udc->driver && udc->driver->suspend) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->suspend(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tif (isr & UDC_IRQ_BUS_RESUME) {\n\t\tISR_DBG(udc, \"UDC_IRQ_BUS_RESUME\\n\");\n\t\tusb_gadget_set_state(&udc->gadget, udc->suspended_from);\n\n\t\tif (udc->driver && udc->driver->resume) {\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tudc->driver->resume(&udc->gadget);\n\t\t\tspin_lock(&udc->lock);\n\t\t}\n\t}\n\n\tif (isr & UDC_IRQ_EP0_IN_ACK_STALL) {\n\t\tISR_DBG(udc, \"UDC_IRQ_EP0_IN_ACK_STALL\\n\");\n\t\tast_udc_ep0_in(udc);\n\t}\n\n\tif (isr & UDC_IRQ_EP0_OUT_ACK_STALL) {\n\t\tISR_DBG(udc, \"UDC_IRQ_EP0_OUT_ACK_STALL\\n\");\n\t\tast_udc_ep0_out(udc);\n\t}\n\n\tif (isr & UDC_IRQ_EP0_SETUP) {\n\t\tISR_DBG(udc, \"UDC_IRQ_EP0_SETUP\\n\");\n\t\tast_udc_ep0_handle_setup(udc);\n\t}\n\n\tif (isr & UDC_IRQ_EP_POOL_ACK_STALL) {\n\t\tISR_DBG(udc, \"UDC_IRQ_EP_POOL_ACK_STALL\\n\");\n\t\tep_isr = ast_udc_read(udc, AST_UDC_EP_ACK_ISR);\n\n\t\t \n\t\tast_udc_write(udc, ep_isr, AST_UDC_EP_ACK_ISR);\n\n\t\t \n\t\tfor (i = 0; i < AST_UDC_NUM_ENDPOINTS - 1; i++) {\n\t\t\tif (ep_isr & (0x1 << i)) {\n\t\t\t\tep = &udc->ep[i + 1];\n\t\t\t\tif (ep->desc_mode)\n\t\t\t\t\tast_udc_epn_handle_desc(udc, i + 1);\n\t\t\t\telse\n\t\t\t\t\tast_udc_epn_handle(udc, i + 1);\n\t\t\t}\n\t\t}\n\t}\n\ndone:\n\tspin_unlock(&udc->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic int ast_udc_gadget_getframe(struct usb_gadget *gadget)\n{\n\tstruct ast_udc_dev *udc = to_ast_dev(gadget);\n\n\treturn (ast_udc_read(udc, AST_UDC_STS) >> 16) & 0x7ff;\n}\n\nstatic void ast_udc_wake_work(struct work_struct *work)\n{\n\tstruct ast_udc_dev *udc = container_of(work, struct ast_udc_dev,\n\t\t\t\t\t       wake_work);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tUDC_DBG(udc, \"Wakeup Host !\\n\");\n\tctrl = ast_udc_read(udc, AST_UDC_FUNC_CTRL);\n\tast_udc_write(udc, ctrl | USB_REMOTE_WAKEUP_EN, AST_UDC_FUNC_CTRL);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\nstatic void ast_udc_wakeup_all(struct ast_udc_dev *udc)\n{\n\t \n\tschedule_work(&udc->wake_work);\n}\n\nstatic int ast_udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct ast_udc_dev *udc = to_ast_dev(gadget);\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tif (!udc->wakeup_en) {\n\t\tUDC_DBG(udc, \"Remote Wakeup is disabled\\n\");\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tUDC_DBG(udc, \"Device initiated wakeup\\n\");\n\tast_udc_wakeup_all(udc);\n\nerr:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn rc;\n}\n\n \nstatic int ast_udc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct ast_udc_dev *udc = to_ast_dev(gadget);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tUDC_DBG(udc, \"is_on: %d\\n\", is_on);\n\tif (is_on)\n\t\tctrl = ast_udc_read(udc, AST_UDC_FUNC_CTRL) | USB_UPSTREAM_EN;\n\telse\n\t\tctrl = ast_udc_read(udc, AST_UDC_FUNC_CTRL) & ~USB_UPSTREAM_EN;\n\n\tast_udc_write(udc, ctrl, AST_UDC_FUNC_CTRL);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_udc_start(struct usb_gadget *gadget,\n\t\t\t struct usb_gadget_driver *driver)\n{\n\tstruct ast_udc_dev *udc = to_ast_dev(gadget);\n\tstruct ast_udc_ep *ep;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tUDC_DBG(udc, \"\\n\");\n\tudc->driver = driver;\n\tudc->gadget.dev.of_node = udc->pdev->dev.of_node;\n\n\tfor (i = 0; i < AST_UDC_NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tep->stopped = 0;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int ast_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct ast_udc_dev *udc = to_ast_dev(gadget);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tUDC_DBG(udc, \"\\n\");\n\tctrl = ast_udc_read(udc, AST_UDC_FUNC_CTRL) & ~USB_UPSTREAM_EN;\n\tast_udc_write(udc, ctrl, AST_UDC_FUNC_CTRL);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->driver = NULL;\n\n\tast_udc_stop_activity(udc);\n\tusb_gadget_set_state(&udc->gadget, USB_STATE_NOTATTACHED);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops ast_udc_ops = {\n\t.get_frame\t\t= ast_udc_gadget_getframe,\n\t.wakeup\t\t\t= ast_udc_wakeup,\n\t.pullup\t\t\t= ast_udc_pullup,\n\t.udc_start\t\t= ast_udc_start,\n\t.udc_stop\t\t= ast_udc_stop,\n};\n\n \nstatic void ast_udc_init_ep(struct ast_udc_dev *udc)\n{\n\tstruct ast_udc_ep *ep;\n\tint i;\n\n\tfor (i = 0; i < AST_UDC_NUM_ENDPOINTS; i++) {\n\t\tep = &udc->ep[i];\n\t\tep->ep.name = ast_ep_name[i];\n\t\tif (i == 0) {\n\t\t\tep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t}\n\t\tep->ep.caps.dir_in = true;\n\t\tep->ep.caps.dir_out = true;\n\n\t\tep->ep.ops = &ast_udc_ep_ops;\n\t\tep->udc = udc;\n\n\t\tINIT_LIST_HEAD(&ep->queue);\n\n\t\tif (i == 0) {\n\t\t\tusb_ep_set_maxpacket_limit(&ep->ep,\n\t\t\t\t\t\t   AST_UDC_EP0_MAX_PACKET);\n\t\t\tcontinue;\n\t\t}\n\n\t\tep->ep_reg = udc->reg + AST_UDC_EP_BASE +\n\t\t\t\t(AST_UDC_EP_OFFSET * (i - 1));\n\n\t\tep->epn_buf = udc->ep0_buf + (i * AST_UDC_EP_DMA_SIZE);\n\t\tep->epn_buf_dma = udc->ep0_buf_dma + (i * AST_UDC_EP_DMA_SIZE);\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, AST_UDC_EPn_MAX_PACKET);\n\n\t\tep->descs = ep->epn_buf + AST_UDC_EPn_MAX_PACKET;\n\t\tep->descs_dma = ep->epn_buf_dma + AST_UDC_EPn_MAX_PACKET;\n\t\tep->descs_wptr = 0;\n\n\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t}\n}\n\nstatic void ast_udc_init_dev(struct ast_udc_dev *udc)\n{\n\tINIT_WORK(&udc->wake_work, ast_udc_wake_work);\n}\n\nstatic void ast_udc_init_hw(struct ast_udc_dev *udc)\n{\n\tu32 ctrl;\n\n\t \n\tctrl = USB_PHY_CLK_EN | USB_PHY_RESET_DIS;\n\tast_udc_write(udc, ctrl, AST_UDC_FUNC_CTRL);\n\n\tudelay(1);\n\tast_udc_write(udc, 0, AST_UDC_DEV_RESET);\n\n\t \n\tif (AST_UDC_DESCS_COUNT == 256) {\n\t\tctrl |= USB_EP_LONG_DESC;\n\t\tast_udc_write(udc, ctrl, AST_UDC_FUNC_CTRL);\n\t}\n\n\t \n\tast_udc_write(udc, 0, AST_UDC_IER);\n\tast_udc_write(udc, UDC_IRQ_ACK_ALL, AST_UDC_ISR);\n\n\t \n\tctrl = UDC_IRQ_EP_POOL_ACK_STALL | UDC_IRQ_BUS_RESUME |\n\t       UDC_IRQ_BUS_SUSPEND | UDC_IRQ_BUS_RESET |\n\t       UDC_IRQ_EP0_IN_ACK_STALL | UDC_IRQ_EP0_OUT_ACK_STALL |\n\t       UDC_IRQ_EP0_SETUP;\n\tast_udc_write(udc, ctrl, AST_UDC_IER);\n\n\t \n\tast_udc_write(udc, UDC_IRQ_EP_ACK_ALL, AST_UDC_EP_ACK_IER);\n\tast_udc_write(udc, UDC_IRQ_EP_ACK_ALL, AST_UDC_EP_ACK_ISR);\n\n\tast_udc_write(udc, 0, AST_UDC_EP0_CTRL);\n}\n\nstatic int ast_udc_remove(struct platform_device *pdev)\n{\n\tstruct ast_udc_dev *udc = platform_get_drvdata(pdev);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tif (udc->driver)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\t \n\tctrl = ast_udc_read(udc, AST_UDC_FUNC_CTRL) & ~USB_UPSTREAM_EN;\n\tast_udc_write(udc, ctrl, AST_UDC_FUNC_CTRL);\n\n\tclk_disable_unprepare(udc->clk);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (udc->ep0_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  AST_UDC_EP_DMA_SIZE * AST_UDC_NUM_ENDPOINTS,\n\t\t\t\t  udc->ep0_buf,\n\t\t\t\t  udc->ep0_buf_dma);\n\n\tudc->ep0_buf = NULL;\n\n\treturn 0;\n}\n\nstatic int ast_udc_probe(struct platform_device *pdev)\n{\n\tenum usb_device_speed max_speed;\n\tstruct device *dev = &pdev->dev;\n\tstruct ast_udc_dev *udc;\n\tint rc;\n\n\tudc = devm_kzalloc(&pdev->dev, sizeof(struct ast_udc_dev), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tudc->gadget.dev.parent = dev;\n\tudc->pdev = pdev;\n\tspin_lock_init(&udc->lock);\n\n\tudc->gadget.ops = &ast_udc_ops;\n\tudc->gadget.ep0 = &udc->ep[0].ep;\n\tudc->gadget.name = \"aspeed-udc\";\n\tudc->gadget.dev.init_name = \"gadget\";\n\n\tudc->reg = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->reg)) {\n\t\tdev_err(&pdev->dev, \"Failed to map resources\\n\");\n\t\treturn PTR_ERR(udc->reg);\n\t}\n\n\tplatform_set_drvdata(pdev, udc);\n\n\tudc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(udc->clk)) {\n\t\trc = PTR_ERR(udc->clk);\n\t\tgoto err;\n\t}\n\trc = clk_prepare_enable(udc->clk);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to enable clock (0x%x)\\n\", rc);\n\t\tgoto err;\n\t}\n\n\t \n\tmax_speed = usb_get_maximum_speed(&pdev->dev);\n\tif (max_speed != USB_SPEED_UNKNOWN && max_speed < USB_SPEED_HIGH)\n\t\tudc->force_usb1 = true;\n\n\t \n\tudc->ep0_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t  AST_UDC_EP_DMA_SIZE *\n\t\t\t\t\t  AST_UDC_NUM_ENDPOINTS,\n\t\t\t\t\t  &udc->ep0_buf_dma, GFP_KERNEL);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->creq = udc->reg + AST_UDC_SETUP0;\n\n\t \n\tudc->desc_mode = AST_UDC_DESC_MODE;\n\n\tdev_info(&pdev->dev, \"DMA %s\\n\", udc->desc_mode ?\n\t\t \"descriptor mode\" : \"single mode\");\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tINIT_LIST_HEAD(&udc->gadget.ep0->ep_list);\n\n\t \n\tast_udc_init_ep(udc);\n\n\t \n\tast_udc_init_dev(udc);\n\n\t \n\tast_udc_init_hw(udc);\n\n\t \n\tudc->irq = platform_get_irq(pdev, 0);\n\tif (udc->irq < 0) {\n\t\trc = udc->irq;\n\t\tgoto err;\n\t}\n\n\trc = devm_request_irq(&pdev->dev, udc->irq, ast_udc_isr, 0,\n\t\t\t      KBUILD_MODNAME, udc);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to request interrupt\\n\");\n\t\tgoto err;\n\t}\n\n\trc = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (rc) {\n\t\tdev_err(&pdev->dev, \"Failed to add gadget udc\\n\");\n\t\tgoto err;\n\t}\n\n\tdev_info(&pdev->dev, \"Initialized udc in USB%s mode\\n\",\n\t\t udc->force_usb1 ? \"1\" : \"2\");\n\n\treturn 0;\n\nerr:\n\tdev_err(&pdev->dev, \"Failed to udc probe, rc:0x%x\\n\", rc);\n\tast_udc_remove(pdev);\n\n\treturn rc;\n}\n\nstatic const struct of_device_id ast_udc_of_dt_ids[] = {\n\t{ .compatible = \"aspeed,ast2600-udc\", },\n\t{}\n};\n\nMODULE_DEVICE_TABLE(of, ast_udc_of_dt_ids);\n\nstatic struct platform_driver ast_udc_driver = {\n\t.probe\t\t\t= ast_udc_probe,\n\t.remove\t\t\t= ast_udc_remove,\n\t.driver\t\t\t= {\n\t\t.name\t\t\t= KBUILD_MODNAME,\n\t\t.of_match_table\t\t= ast_udc_of_dt_ids,\n\t},\n};\n\nmodule_platform_driver(ast_udc_driver);\n\nMODULE_DESCRIPTION(\"ASPEED UDC driver\");\nMODULE_AUTHOR(\"Neal Liu <neal_liu@aspeedtech.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}