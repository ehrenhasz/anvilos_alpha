{
  "module_name": "cdns2-gadget.h",
  "hash_id": "45fb3b716d9b46fa3559358e764a30d1fe07e4ba7fb792e0f52b2db2da33b210",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/cdns2/cdns2-gadget.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_CDNS2_GADGET\n#define __LINUX_CDNS2_GADGET\n\n#include <linux/usb/gadget.h>\n#include <linux/dma-direction.h>\n\n \n\n \nstruct cdns2_ep0_regs {\n\t__u8 rxbc;\n\t__u8 txbc;\n\t__u8 cs;\n\t__u8 reserved1[4];\n\t__u8 fifo;\n\t__le32 reserved2[94];\n\t__u8 setupdat[8];\n\t__u8 reserved4[88];\n\t__u8 maxpack;\n} __packed __aligned(4);\n\n \n \n#define EP0CS_STALL\tBIT(0)\n \n#define EP0CS_HSNAK\tBIT(1)\n \n#define EP0CS_TXBSY_MSK\tBIT(2)\n \n#define EP0CS_RXBSY_MSK\tBIT(3)\n \n#define EP0CS_DSTALL\tBIT(4)\n \n#define EP0CS_CHGSET\tBIT(7)\n\n \n \n#define EP0_FIFO_IO_TX\tBIT(4)\n \n#define EP0_FIFO_AUTO\tBIT(5)\n \n#define EP0_FIFO_COMMIT\tBIT(6)\n \n#define EP0_FIFO_ACCES\tBIT(7)\n\n \nstruct cdns2_epx_base {\n\t__le16 rxbc;\n\t__u8 rxcon;\n\t__u8 rxcs;\n\t__le16 txbc;\n\t__u8 txcon;\n\t__u8 txcs;\n} __packed __aligned(4);\n\n \n \n#define EPX_CON_BUF\t\tGENMASK(1, 0)\n \n#define EPX_CON_TYPE\t\tGENMASK(3, 2)\n \n#define EPX_CON_TYPE_ISOC\t0x4\n \n#define EPX_CON_TYPE_BULK\t0x8\n \n#define EPX_CON_TYPE_INT\t0xC\n \n#define EPX_CON_ISOD\t\tGENMASK(5, 4)\n#define EPX_CON_ISOD_SHIFT\t0x4\n \n#define EPX_CON_STALL\t\tBIT(6)\n \n#define EPX_CON_VAL\t\tBIT(7)\n\n \n \n#define EPX_CS_ERR(p)\t\t((p) & BIT(0))\n\n \nstruct cdns2_epx_regs {\n\t__le32 reserved[2];\n\tstruct cdns2_epx_base ep[15];\n\t__u8 reserved2[290];\n\t__u8 endprst;\n\t__u8 reserved3[41];\n\t__le16 isoautoarm;\n\t__u8 reserved4[10];\n\t__le16 isodctrl;\n\t__le16 reserved5;\n\t__le16 isoautodump;\n\t__le32 reserved6;\n\t__le16 rxmaxpack[15];\n\t__le32 reserved7[65];\n\t__le32 rxstaddr[15];\n\t__u8 reserved8[4];\n\t__le32 txstaddr[15];\n\t__u8 reserved9[98];\n\t__le16 txmaxpack[15];\n} __packed __aligned(4);\n\n \n \n#define ENDPRST_EP\tGENMASK(3, 0)\n \n#define ENDPRST_IO_TX\tBIT(4)\n \n#define ENDPRST_TOGRST\tBIT(5)\n \n#define ENDPRST_FIFORST\tBIT(6)\n \n#define ENDPRST_TOGSETQ\tBIT(7)\n\n \nstruct cdns2_interrupt_regs {\n\t__u8 reserved[396];\n\t__u8 usbirq;\n\t__u8 extirq;\n\t__le16 rxpngirq;\n\t__le16 reserved1[4];\n\t__u8 usbien;\n\t__u8 extien;\n\t__le16 reserved2[3];\n\t__u8 usbivect;\n} __packed __aligned(4);\n\n \n \n#define EXTIRQ_VBUSFAULT_FALL BIT(0)\n \n#define EXTIRQ_VBUSFAULT_RISE BIT(1)\n \n#define EXTIRQ_WAKEUP\tBIT(7)\n\n \n \n#define USBIRQ_SUDAV\tBIT(0)\n \n#define USBIRQ_SOF\tBIT(1)\n \n#define USBIRQ_SUTOK\tBIT(2)\n \n#define USBIRQ_SUSPEND\tBIT(3)\n \n#define USBIRQ_URESET\tBIT(4)\n \n#define USBIRQ_HSPEED\tBIT(5)\n \n#define USBIRQ_LPM\tBIT(7)\n\n#define USB_IEN_INIT (USBIRQ_SUDAV | USBIRQ_SUSPEND | USBIRQ_URESET \\\n\t\t      | USBIRQ_HSPEED | USBIRQ_LPM)\n \nstruct cdns2_usb_regs {\n\t__u8 reserved[4];\n\t__u16 lpmctrl;\n\t__u8 lpmclock;\n\t__u8 reserved2[411];\n\t__u8 endprst;\n\t__u8 usbcs;\n\t__le16 frmnr;\n\t__u8 fnaddr;\n\t__u8 clkgate;\n\t__u8 fifoctrl;\n\t__u8 speedctrl;\n\t__u8 sleep_clkgate;\n\t__u8 reserved3[533];\n\t__u8 cpuctrl;\n} __packed __aligned(4);\n\n \n \n#define LPMCTRLLL_HIRD\t\tGENMASK(7, 4)\n \n#define LPMCTRLLH_BREMOTEWAKEUP\tBIT(8)\n \n#define LPMCTRLLH_LPMNYET\tBIT(16)\n\n \n \n#define LPMCLOCK_SLEEP_ENTRY\tBIT(7)\n\n \n \n#define USBCS_LPMNYET\t\tBIT(2)\n \n#define USBCS_SIGRSUME\t\tBIT(5)\n \n#define USBCS_DISCON\t\tBIT(6)\n \n#define USBCS_WAKESRC\t\tBIT(7)\n\n \n \n#define FIFOCTRL_EP\t\tGENMASK(3, 0)\n \n#define FIFOCTRL_IO_TX\t\tBIT(4)\n \n#define FIFOCTRL_FIFOAUTO\tBIT(5)\n \n#define FIFOCTRL_FIFOCMIT\tBIT(6)\n \n#define FIFOCTRL_FIFOACC\tBIT(7)\n\n \n \n#define SPEEDCTRL_FS\t\tBIT(1)\n \n#define SPEEDCTRL_HS\t\tBIT(2)\n \n#define SPEEDCTRL_HSDISABLE\tBIT(7)\n\n \n \n#define CPUCTRL_SW_RST\t\tBIT(1)\n\n \nstruct cdns2_adma_regs {\n\t__le32 conf;\n\t__le32 sts;\n\t__le32 reserved1[5];\n\t__le32 ep_sel;\n\t__le32 ep_traddr;\n\t__le32 ep_cfg;\n\t__le32 ep_cmd;\n\t__le32 ep_sts;\n\t__le32 reserved2;\n\t__le32 ep_sts_en;\n\t__le32 drbl;\n\t__le32 ep_ien;\n\t__le32 ep_ists;\n\t__le32 axim_ctrl;\n\t__le32 axim_id;\n\t__le32 reserved3;\n\t__le32 axim_cap;\n\t__le32 reserved4;\n\t__le32 axim_ctrl0;\n\t__le32 axim_ctrl1;\n};\n\n#define CDNS2_ADMA_REGS_OFFSET\t0x400\n\n \n \n#define DMA_CONF_CFGRST\t\tBIT(0)\n \n#define DMA_CONF_DSING\t\tBIT(8)\n \n#define DMA_CONF_DMULT\t\tBIT(9)\n\n \n \n#define DMA_EP_CFG_ENABLE\tBIT(0)\n\n \n \n#define DMA_EP_CMD_EPRST\tBIT(0)\n \n#define DMA_EP_CMD_DRDY\t\tBIT(6)\n \n#define DMA_EP_CMD_DFLUSH\tBIT(7)\n\n \n \n#define DMA_EP_STS_IOC\t\tBIT(2)\n \n#define DMA_EP_STS_ISP\t\tBIT(3)\n \n#define DMA_EP_STS_DESCMIS\tBIT(4)\n \n#define DMA_EP_STS_TRBERR\tBIT(7)\n \n#define DMA_EP_STS_DBUSY\tBIT(9)\n \n#define DMA_EP_STS_CCS(p)\t((p) & BIT(11))\n \n#define DMA_EP_STS_OUTSMM\tBIT(14)\n \n#define DMA_EP_STS_ISOERR\tBIT(15)\n\n \n \n#define DMA_EP_STS_EN_DESCMISEN\tBIT(4)\n \n#define DMA_EP_STS_EN_TRBERREN\tBIT(7)\n \n#define DMA_EP_STS_EN_OUTSMMEN\tBIT(14)\n \n#define DMA_EP_STS_EN_ISOERREN\tBIT(15)\n\n \n#define DMA_EP_IEN(index)\t(1 << (index))\n#define DMA_EP_IEN_EP_OUT0\tBIT(0)\n#define DMA_EP_IEN_EP_IN0\tBIT(16)\n\n \n#define DMA_EP_ISTS(index)\t(1 << (index))\n#define DMA_EP_ISTS_EP_OUT0\tBIT(0)\n#define DMA_EP_ISTS_EP_IN0\tBIT(16)\n\n#define gadget_to_cdns2_device(g) (container_of(g, struct cdns2_device, gadget))\n#define ep_to_cdns2_ep(ep) (container_of(ep, struct cdns2_endpoint, endpoint))\n\n \n#define TRBS_PER_SEGMENT\t600\n#define ISO_MAX_INTERVAL\t8\n#define MAX_TRB_LENGTH\t\tBIT(16)\n#define MAX_ISO_SIZE\t\t3076\n \n#define TRB_MAX_ISO_BUFF_SHIFT\t12\n#define TRB_MAX_ISO_BUFF_SIZE\tBIT(TRB_MAX_ISO_BUFF_SHIFT)\n \n#define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr) (TRB_MAX_ISO_BUFF_SIZE - \\\n\t\t\t\t\t((addr) & (TRB_MAX_ISO_BUFF_SIZE - 1)))\n\n#if TRBS_PER_SEGMENT < 2\n#error \"Incorrect TRBS_PER_SEGMENT. Minimal Transfer Ring size is 2.\"\n#endif\n\n \nstruct cdns2_trb {\n\t__le32 buffer;\n\t__le32 length;\n\t__le32 control;\n};\n\n#define TRB_SIZE\t\t(sizeof(struct cdns2_trb))\n \n#define TRB_ISO_RESERVED\t2\n#define TR_SEG_SIZE\t\t(TRB_SIZE * (TRBS_PER_SEGMENT + TRB_ISO_RESERVED))\n\n \n#define TRB_TYPE_BITMASK\tGENMASK(15, 10)\n#define TRB_TYPE(p)\t\t((p) << 10)\n#define TRB_FIELD_TO_TYPE(p)\t(((p) & TRB_TYPE_BITMASK) >> 10)\n\n \n \n#define TRB_NORMAL\t\t1\n \n#define TRB_LINK\t\t6\n\n \n#define TRB_CYCLE\t\tBIT(0)\n \n#define TRB_TOGGLE\t\tBIT(1)\n \n#define TRB_ISP\t\t\tBIT(2)\n \n#define TRB_CHAIN\t\tBIT(4)\n \n#define TRB_IOC\t\t\tBIT(5)\n\n \n#define TRB_LEN(p)\t\t((p) & GENMASK(16, 0))\n#define TRB_BURST(p)\t\t(((p) << 24) & GENMASK(31, 24))\n#define TRB_FIELD_TO_BURST(p)\t(((p) & GENMASK(31, 24)) >> 24)\n\n \n#define TRB_BUFFER(p)\t\t((p) & GENMASK(31, 0))\n\n \n \n\n \n#define USB_DEVICE_MAX_ADDRESS\t127\n\n \n#define CDNS2_ENDPOINTS_NUM\t31\n\n#define CDNS2_EP_ZLP_BUF_SIZE\t512\n\n \n \n\nstruct cdns2_device;\n\n \nstruct cdns2_ring {\n\tstruct cdns2_trb *trbs;\n\tdma_addr_t dma;\n\tint free_trbs;\n\tu8 pcs;\n\tu8 ccs;\n\tint enqueue;\n\tint dequeue;\n};\n\n \nstruct cdns2_endpoint {\n\tstruct usb_ep endpoint;\n\tstruct list_head pending_list;\n\tstruct list_head deferred_list;\n\n\tstruct cdns2_device\t*pdev;\n\tchar name[20];\n\n\tstruct cdns2_ring ring;\n\n#define EP_ENABLED\t\tBIT(0)\n#define EP_STALLED\t\tBIT(1)\n#define EP_STALL_PENDING\tBIT(2)\n#define EP_WEDGE\t\tBIT(3)\n#define\tEP_CLAIMED\t\tBIT(4)\n#define EP_RING_FULL\t\tBIT(5)\n#define EP_DEFERRED_DRDY\tBIT(6)\n\n\tu32 ep_state;\n\n\tu8 idx;\n\tu8 dir;\n\tu8 num;\n\tu8 type;\n\tint interval;\n\tu8 buffering;\n\tu8 trb_burst_size;\n\tbool skip;\n\n\tunsigned int wa1_set:1;\n\tstruct cdns2_trb *wa1_trb;\n\tunsigned int wa1_trb_index;\n\tunsigned int wa1_cycle_bit:1;\n};\n\n \nstruct cdns2_request {\n\tstruct usb_request request;\n\tstruct cdns2_endpoint *pep;\n\tstruct cdns2_trb *trb;\n\tint start_trb;\n\tint end_trb;\n\tstruct list_head list;\n\tint finished_trb;\n\tint num_of_trb;\n};\n\n#define to_cdns2_request(r) (container_of(r, struct cdns2_request, request))\n\n \n#define CDNS2_SETUP_STAGE\t\t0x0\n#define CDNS2_DATA_STAGE\t\t0x1\n#define CDNS2_STATUS_STAGE\t\t0x2\n\n \nstruct cdns2_device {\n\tstruct device *dev;\n\tstruct usb_gadget gadget;\n\tstruct usb_gadget_driver *gadget_driver;\n\n\t \n\tspinlock_t lock;\n\tint irq;\n\tvoid __iomem *regs;\n\tstruct cdns2_usb_regs __iomem *usb_regs;\n\tstruct cdns2_ep0_regs __iomem *ep0_regs;\n\tstruct cdns2_epx_regs __iomem *epx_regs;\n\tstruct cdns2_interrupt_regs __iomem *interrupt_regs;\n\tstruct cdns2_adma_regs __iomem *adma_regs;\n\tstruct dma_pool *eps_dma_pool;\n\tstruct usb_ctrlrequest setup;\n\tstruct cdns2_request ep0_preq;\n\tu8 ep0_stage;\n\tvoid *zlp_buf;\n\tu8 dev_address;\n\tstruct cdns2_endpoint eps[CDNS2_ENDPOINTS_NUM];\n\tu32 selected_ep;\n\tbool is_selfpowered;\n\tbool may_wakeup;\n\tbool status_completion_no_call;\n\tbool in_lpm;\n\tstruct work_struct pending_status_wq;\n\tstruct usb_request *pending_status_request;\n\tu32 eps_supported;\n\tu8 burst_opt[MAX_ISO_SIZE + 1];\n\n\t \n\tu16 onchip_tx_buf;\n\tu16 onchip_rx_buf;\n};\n\n#define CDNS2_IF_EP_EXIST(pdev, ep_num, dir) \\\n\t\t\t ((pdev)->eps_supported & \\\n\t\t\t (BIT(ep_num) << ((dir) ? 0 : 16)))\n\ndma_addr_t cdns2_trb_virt_to_dma(struct cdns2_endpoint *pep,\n\t\t\t\t struct cdns2_trb *trb);\nvoid cdns2_pending_setup_status_handler(struct work_struct *work);\nvoid cdns2_select_ep(struct cdns2_device *pdev, u32 ep);\nstruct cdns2_request *cdns2_next_preq(struct list_head *list);\nstruct usb_request *cdns2_gadget_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t  gfp_t gfp_flags);\nvoid cdns2_gadget_ep_free_request(struct usb_ep *ep,\n\t\t\t\t  struct usb_request *request);\nint cdns2_gadget_ep_dequeue(struct usb_ep *ep, struct usb_request *request);\nvoid cdns2_gadget_giveback(struct cdns2_endpoint *pep,\n\t\t\t   struct cdns2_request *priv_req,\n\t\t\t   int status);\nvoid cdns2_init_ep0(struct cdns2_device *pdev, struct cdns2_endpoint *pep);\nvoid cdns2_ep0_config(struct cdns2_device *pdev);\nvoid cdns2_handle_ep0_interrupt(struct cdns2_device *pdev, int dir);\nvoid cdns2_handle_setup_packet(struct cdns2_device *pdev);\nint cdns2_gadget_resume(struct cdns2_device *pdev, bool hibernated);\nint cdns2_gadget_suspend(struct cdns2_device *pdev);\nvoid cdns2_gadget_remove(struct cdns2_device *pdev);\nint cdns2_gadget_init(struct cdns2_device *pdev);\nvoid set_reg_bit_8(void __iomem *ptr, u8 mask);\nint cdns2_halt_endpoint(struct cdns2_device *pdev, struct cdns2_endpoint *pep,\n\t\t\tint value);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}