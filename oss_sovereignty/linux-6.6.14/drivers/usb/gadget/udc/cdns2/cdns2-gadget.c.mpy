{
  "module_name": "cdns2-gadget.c",
  "hash_id": "f380affce09d67c7191797e9a33b809fa539c868657c9c77e86483eeb75025a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/cdns2/cdns2-gadget.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/interrupt.h>\n#include <linux/property.h>\n#include <linux/dmapool.h>\n#include <linux/iopoll.h>\n\n#include \"cdns2-gadget.h\"\n#include \"cdns2-trace.h\"\n\n \nstatic void set_reg_bit_32(void __iomem *ptr, u32 mask)\n{\n\tmask = readl(ptr) | mask;\n\twritel(mask, ptr);\n}\n\n \nstatic void clear_reg_bit_32(void __iomem *ptr, u32 mask)\n{\n\tmask = readl(ptr) & ~mask;\n\twritel(mask, ptr);\n}\n\n \nstatic void clear_reg_bit_8(void __iomem *ptr, u8 mask)\n{\n\tmask = readb(ptr) & ~mask;\n\twriteb(mask, ptr);\n}\n\n \nvoid set_reg_bit_8(void __iomem *ptr, u8 mask)\n{\n\tmask = readb(ptr) | mask;\n\twriteb(mask, ptr);\n}\n\nstatic int cdns2_get_dma_pos(struct cdns2_device *pdev,\n\t\t\t     struct cdns2_endpoint *pep)\n{\n\tint dma_index;\n\n\tdma_index = readl(&pdev->adma_regs->ep_traddr) - pep->ring.dma;\n\n\treturn dma_index / TRB_SIZE;\n}\n\n \nstruct cdns2_request *cdns2_next_preq(struct list_head *list)\n{\n\treturn list_first_entry_or_null(list, struct cdns2_request, list);\n}\n\nvoid cdns2_select_ep(struct cdns2_device *pdev, u32 ep)\n{\n\tif (pdev->selected_ep == ep)\n\t\treturn;\n\n\tpdev->selected_ep = ep;\n\twritel(ep, &pdev->adma_regs->ep_sel);\n}\n\ndma_addr_t cdns2_trb_virt_to_dma(struct cdns2_endpoint *pep,\n\t\t\t\t struct cdns2_trb *trb)\n{\n\tu32 offset = (char *)trb - (char *)pep->ring.trbs;\n\n\treturn pep->ring.dma + offset;\n}\n\nstatic void cdns2_free_tr_segment(struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_ring *ring = &pep->ring;\n\n\tif (pep->ring.trbs) {\n\t\tdma_pool_free(pdev->eps_dma_pool, ring->trbs, ring->dma);\n\t\tmemset(ring, 0, sizeof(*ring));\n\t}\n}\n\n \nstatic int cdns2_alloc_tr_segment(struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_trb *link_trb;\n\tstruct cdns2_ring *ring;\n\n\tring = &pep->ring;\n\n\tif (!ring->trbs) {\n\t\tring->trbs = dma_pool_alloc(pdev->eps_dma_pool,\n\t\t\t\t\t    GFP_DMA32 | GFP_ATOMIC,\n\t\t\t\t\t    &ring->dma);\n\t\tif (!ring->trbs)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemset(ring->trbs, 0, TR_SEG_SIZE);\n\n\tif (!pep->num)\n\t\treturn 0;\n\n\t \n\tlink_trb = (ring->trbs + (TRBS_PER_SEGMENT - 1));\n\tlink_trb->buffer = cpu_to_le32(TRB_BUFFER(ring->dma));\n\tlink_trb->control = cpu_to_le32(TRB_CYCLE | TRB_TYPE(TRB_LINK) |\n\t\t\t\t\tTRB_TOGGLE);\n\n\treturn 0;\n}\n\n \nstatic void cdns2_ep_stall_flush(struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tint val;\n\n\ttrace_cdns2_ep_halt(pep, 1, 1);\n\n\twritel(DMA_EP_CMD_DFLUSH, &pdev->adma_regs->ep_cmd);\n\n\t \n\treadl_poll_timeout_atomic(&pdev->adma_regs->ep_cmd, val,\n\t\t\t\t  !(val & DMA_EP_CMD_DFLUSH), 1, 1000);\n\tpep->ep_state |= EP_STALLED;\n\tpep->ep_state &= ~EP_STALL_PENDING;\n}\n\n \nstatic void cdns2_ep_inc_trb(int *index, u8 *cs, int trb_in_seg)\n{\n\t(*index)++;\n\tif (*index == (trb_in_seg - 1)) {\n\t\t*index = 0;\n\t\t*cs ^=  1;\n\t}\n}\n\nstatic void cdns2_ep_inc_enq(struct cdns2_ring *ring)\n{\n\tring->free_trbs--;\n\tcdns2_ep_inc_trb(&ring->enqueue, &ring->pcs, TRBS_PER_SEGMENT);\n}\n\nstatic void cdns2_ep_inc_deq(struct cdns2_ring *ring)\n{\n\tring->free_trbs++;\n\tcdns2_ep_inc_trb(&ring->dequeue, &ring->ccs, TRBS_PER_SEGMENT);\n}\n\n \nstatic void cdns2_enable_l1(struct cdns2_device *pdev, int enable)\n{\n\tif (enable) {\n\t\tclear_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_LPMNYET);\n\t\twriteb(LPMCLOCK_SLEEP_ENTRY, &pdev->usb_regs->lpmclock);\n\t} else {\n\t\tset_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_LPMNYET);\n\t}\n}\n\nstatic enum usb_device_speed cdns2_get_speed(struct cdns2_device *pdev)\n{\n\tu8 speed = readb(&pdev->usb_regs->speedctrl);\n\n\tif (speed & SPEEDCTRL_HS)\n\t\treturn USB_SPEED_HIGH;\n\telse if (speed & SPEEDCTRL_FS)\n\t\treturn USB_SPEED_FULL;\n\n\treturn USB_SPEED_UNKNOWN;\n}\n\nstatic struct cdns2_trb *cdns2_next_trb(struct cdns2_endpoint *pep,\n\t\t\t\t\tstruct cdns2_trb *trb)\n{\n\tif (trb == (pep->ring.trbs + (TRBS_PER_SEGMENT - 1)))\n\t\treturn pep->ring.trbs;\n\telse\n\t\treturn ++trb;\n}\n\nvoid cdns2_gadget_giveback(struct cdns2_endpoint *pep,\n\t\t\t   struct cdns2_request *preq,\n\t\t\t   int status)\n{\n\tstruct usb_request *request = &preq->request;\n\tstruct cdns2_device *pdev = pep->pdev;\n\n\tlist_del_init(&preq->list);\n\n\tif (request->status == -EINPROGRESS)\n\t\trequest->status = status;\n\n\tusb_gadget_unmap_request_by_dev(pdev->dev, request, pep->dir);\n\n\t \n\tpreq->finished_trb = 0;\n\n\ttrace_cdns2_request_giveback(preq);\n\n\tif (request->complete) {\n\t\tspin_unlock(&pdev->lock);\n\t\tusb_gadget_giveback_request(&pep->endpoint, request);\n\t\tspin_lock(&pdev->lock);\n\t}\n\n\tif (request->buf == pdev->zlp_buf)\n\t\tcdns2_gadget_ep_free_request(&pep->endpoint, request);\n}\n\nstatic void cdns2_wa1_restore_cycle_bit(struct cdns2_endpoint *pep)\n{\n\t \n\tif (pep->wa1_set) {\n\t\ttrace_cdns2_wa1(pep, \"restore cycle bit\");\n\n\t\tpep->wa1_set = 0;\n\t\tpep->wa1_trb_index = 0xFFFF;\n\t\tif (pep->wa1_cycle_bit)\n\t\t\tpep->wa1_trb->control |= cpu_to_le32(0x1);\n\t\telse\n\t\t\tpep->wa1_trb->control &= cpu_to_le32(~0x1);\n\t}\n}\n\nstatic int cdns2_wa1_update_guard(struct cdns2_endpoint *pep,\n\t\t\t\t  struct cdns2_trb *trb)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\n\tif (!pep->wa1_set) {\n\t\tu32 doorbell;\n\n\t\tdoorbell = !!(readl(&pdev->adma_regs->ep_cmd) & DMA_EP_CMD_DRDY);\n\n\t\tif (doorbell) {\n\t\t\tpep->wa1_cycle_bit = pep->ring.pcs ? TRB_CYCLE : 0;\n\t\t\tpep->wa1_set = 1;\n\t\t\tpep->wa1_trb = trb;\n\t\t\tpep->wa1_trb_index = pep->ring.enqueue;\n\t\t\ttrace_cdns2_wa1(pep, \"set guard\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void cdns2_wa1_tray_restore_cycle_bit(struct cdns2_device *pdev,\n\t\t\t\t\t     struct cdns2_endpoint *pep)\n{\n\tint dma_index;\n\tu32 doorbell;\n\n\tdoorbell = !!(readl(&pdev->adma_regs->ep_cmd) & DMA_EP_CMD_DRDY);\n\tdma_index = cdns2_get_dma_pos(pdev, pep);\n\n\tif (!doorbell || dma_index != pep->wa1_trb_index)\n\t\tcdns2_wa1_restore_cycle_bit(pep);\n}\n\nstatic int cdns2_prepare_ring(struct cdns2_device *pdev,\n\t\t\t      struct cdns2_endpoint *pep,\n\t\t\t      int num_trbs)\n{\n\tstruct cdns2_trb *link_trb = NULL;\n\tint doorbell, dma_index;\n\tstruct cdns2_ring *ring;\n\tu32 ch_bit = 0;\n\n\tring = &pep->ring;\n\n\tif (num_trbs > ring->free_trbs) {\n\t\tpep->ep_state |= EP_RING_FULL;\n\t\ttrace_cdns2_no_room_on_ring(\"Ring full\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif ((ring->enqueue + num_trbs)  >= (TRBS_PER_SEGMENT - 1)) {\n\t\tdoorbell = !!(readl(&pdev->adma_regs->ep_cmd) & DMA_EP_CMD_DRDY);\n\t\tdma_index = cdns2_get_dma_pos(pdev, pep);\n\n\t\t \n\t\tif (doorbell && dma_index == TRBS_PER_SEGMENT - 1) {\n\t\t\tpep->ep_state |= EP_DEFERRED_DRDY;\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t \n\t\tlink_trb = ring->trbs + (TRBS_PER_SEGMENT - 1);\n\n\t\t \n\t\tif (pep->type == USB_ENDPOINT_XFER_ISOC || TRBS_PER_SEGMENT > 2)\n\t\t\tch_bit = TRB_CHAIN;\n\n\t\tlink_trb->control = cpu_to_le32(((ring->pcs) ? TRB_CYCLE : 0) |\n\t\t\t\t    TRB_TYPE(TRB_LINK) | TRB_TOGGLE | ch_bit);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdns2_dbg_request_trbs(struct cdns2_endpoint *pep,\n\t\t\t\t   struct cdns2_request *preq)\n{\n\tstruct cdns2_trb *link_trb = pep->ring.trbs + (TRBS_PER_SEGMENT - 1);\n\tstruct cdns2_trb *trb = preq->trb;\n\tint num_trbs = preq->num_of_trb;\n\tint i = 0;\n\n\twhile (i < num_trbs) {\n\t\ttrace_cdns2_queue_trb(pep, trb + i);\n\t\tif (trb + i == link_trb) {\n\t\t\ttrb = pep->ring.trbs;\n\t\t\tnum_trbs = num_trbs - i;\n\t\t\ti = 0;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic unsigned int cdns2_count_trbs(struct cdns2_endpoint *pep,\n\t\t\t\t     u64 addr, u64 len)\n{\n\tunsigned int num_trbs = 1;\n\n\tif (pep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\t \n\t\tnum_trbs = DIV_ROUND_UP(len +\n\t\t\t\t\t(addr & (TRB_MAX_ISO_BUFF_SIZE - 1)),\n\t\t\t\t\tTRB_MAX_ISO_BUFF_SIZE);\n\n\t\tif (pep->interval > 1)\n\t\t\tnum_trbs = pep->dir ? num_trbs * pep->interval : 1;\n\t} else if (pep->dir) {\n\t\t \n\t\tnum_trbs++;\n\t}\n\n\treturn num_trbs;\n}\n\nstatic unsigned int cdns2_count_sg_trbs(struct cdns2_endpoint *pep,\n\t\t\t\t\tstruct usb_request *req)\n{\n\tunsigned int i, len, full_len, num_trbs = 0;\n\tstruct scatterlist *sg;\n\tint trb_len = 0;\n\n\tfull_len = req->length;\n\n\tfor_each_sg(req->sg, sg, req->num_sgs, i) {\n\t\tlen = sg_dma_len(sg);\n\t\tnum_trbs += cdns2_count_trbs(pep, sg_dma_address(sg), len);\n\t\tlen = min(len, full_len);\n\n\t\t \n\t\tif (pep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tu8 temp;\n\n\t\t\ttrb_len += len;\n\t\t\ttemp = trb_len >> 10;\n\n\t\t\tif (temp) {\n\t\t\t\tif (trb_len % 1024)\n\t\t\t\t\tnum_trbs = num_trbs + temp;\n\t\t\t\telse\n\t\t\t\t\tnum_trbs = num_trbs + temp - 1;\n\n\t\t\t\ttrb_len = trb_len - (temp << 10);\n\t\t\t}\n\t\t}\n\n\t\tfull_len -= len;\n\t\tif (full_len == 0)\n\t\t\tbreak;\n\t}\n\n\treturn num_trbs;\n}\n\n \nstatic void cdsn2_isoc_burst_opt(struct cdns2_device *pdev)\n{\n\tint axi_burst_option[]  =  {1, 2, 4, 8, 16, 32, 64, 128};\n\tint best_burst;\n\tint array_size;\n\tint opt_burst;\n\tint trb_size;\n\tint i, j;\n\n\tarray_size = ARRAY_SIZE(axi_burst_option);\n\n\tfor (i = 0; i <= MAX_ISO_SIZE; i++) {\n\t\ttrb_size = i / 4;\n\t\tbest_burst = trb_size ? trb_size : 1;\n\n\t\tfor (j = 0; j < array_size; j++) {\n\t\t\topt_burst = trb_size / axi_burst_option[j];\n\t\t\topt_burst += trb_size % axi_burst_option[j];\n\n\t\t\tif (opt_burst < best_burst) {\n\t\t\t\tbest_burst = opt_burst;\n\t\t\t\tpdev->burst_opt[i] = axi_burst_option[j];\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void cdns2_ep_tx_isoc(struct cdns2_endpoint *pep,\n\t\t\t     struct cdns2_request *preq,\n\t\t\t     int num_trbs)\n{\n\tstruct scatterlist *sg = NULL;\n\tu32 remaining_packet_size = 0;\n\tstruct cdns2_trb *trb;\n\tbool first_trb = true;\n\tdma_addr_t trb_dma;\n\tu32 trb_buff_len;\n\tu32 block_length;\n\tint td_idx = 0;\n\tint split_size;\n\tu32 full_len;\n\tint enqd_len;\n\tint sent_len;\n\tint sg_iter;\n\tu32 control;\n\tint num_tds;\n\tu32 length;\n\n\t \n\tnum_tds = pep->dir ? pep->interval : 1;\n\tsplit_size = preq->request.num_sgs ? 1024 : 3072;\n\n\tfor (td_idx = 0; td_idx < num_tds; td_idx++) {\n\t\tif (preq->request.num_sgs) {\n\t\t\tsg = preq->request.sg;\n\t\t\ttrb_dma = sg_dma_address(sg);\n\t\t\tblock_length = sg_dma_len(sg);\n\t\t} else {\n\t\t\ttrb_dma = preq->request.dma;\n\t\t\tblock_length = preq->request.length;\n\t\t}\n\n\t\tfull_len = preq->request.length;\n\t\tsg_iter = preq->request.num_sgs ? preq->request.num_sgs : 1;\n\t\tremaining_packet_size = split_size;\n\n\t\tfor (enqd_len = 0;  enqd_len < full_len;\n\t\t     enqd_len += trb_buff_len) {\n\t\t\tif (remaining_packet_size == 0)\n\t\t\t\tremaining_packet_size = split_size;\n\n\t\t\t \n\t\t\ttrb_buff_len = TRB_BUFF_LEN_UP_TO_BOUNDARY(trb_dma);\n\t\t\ttrb_buff_len = min(trb_buff_len, remaining_packet_size);\n\t\t\ttrb_buff_len = min(trb_buff_len, block_length);\n\n\t\t\tif (trb_buff_len > full_len - enqd_len)\n\t\t\t\ttrb_buff_len = full_len - enqd_len;\n\n\t\t\tcontrol = TRB_TYPE(TRB_NORMAL);\n\n\t\t\t \n\t\t\tif (enqd_len + trb_buff_len >= full_len || !pep->dir)\n\t\t\t\tcontrol |= TRB_IOC | TRB_ISP;\n\n\t\t\t \n\t\t\tif (first_trb) {\n\t\t\t\tfirst_trb = false;\n\t\t\t\tif (pep->ring.pcs == 0)\n\t\t\t\t\tcontrol |= TRB_CYCLE;\n\t\t\t} else {\n\t\t\t\tcontrol |= pep->ring.pcs;\n\t\t\t}\n\n\t\t\tif (enqd_len + trb_buff_len < full_len)\n\t\t\t\tcontrol |= TRB_CHAIN;\n\n\t\t\tlength = TRB_LEN(trb_buff_len) |\n\t\t\t\t TRB_BURST(pep->pdev->burst_opt[trb_buff_len]);\n\n\t\t\ttrb = pep->ring.trbs + pep->ring.enqueue;\n\t\t\ttrb->buffer = cpu_to_le32(TRB_BUFFER(trb_dma));\n\t\t\ttrb->length = cpu_to_le32(length);\n\t\t\ttrb->control = cpu_to_le32(control);\n\n\t\t\ttrb_dma += trb_buff_len;\n\t\t\tsent_len = trb_buff_len;\n\n\t\t\tif (sg && sent_len >= block_length) {\n\t\t\t\t \n\t\t\t\t--sg_iter;\n\t\t\t\tsent_len -= block_length;\n\t\t\t\tif (sg_iter != 0) {\n\t\t\t\t\tsg = sg_next(sg);\n\t\t\t\t\ttrb_dma = sg_dma_address(sg);\n\t\t\t\t\tblock_length = sg_dma_len(sg);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tremaining_packet_size -= trb_buff_len;\n\t\t\tblock_length -= sent_len;\n\t\t\tpreq->end_trb = pep->ring.enqueue;\n\n\t\t\tcdns2_ep_inc_enq(&pep->ring);\n\t\t}\n\t}\n}\n\nstatic void cdns2_ep_tx_bulk(struct cdns2_endpoint *pep,\n\t\t\t     struct cdns2_request *preq,\n\t\t\t     int trbs_per_td)\n{\n\tstruct scatterlist *sg = NULL;\n\tstruct cdns2_ring *ring;\n\tstruct cdns2_trb *trb;\n\tdma_addr_t trb_dma;\n\tint sg_iter = 0;\n\tu32 control;\n\tu32 length;\n\n\tif (preq->request.num_sgs) {\n\t\tsg = preq->request.sg;\n\t\ttrb_dma = sg_dma_address(sg);\n\t\tlength = sg_dma_len(sg);\n\t} else {\n\t\ttrb_dma = preq->request.dma;\n\t\tlength = preq->request.length;\n\t}\n\n\tring = &pep->ring;\n\n\tfor (sg_iter = 0; sg_iter < trbs_per_td; sg_iter++) {\n\t\tcontrol = TRB_TYPE(TRB_NORMAL) | ring->pcs | TRB_ISP;\n\t\ttrb = pep->ring.trbs + ring->enqueue;\n\n\t\tif (pep->dir && sg_iter == trbs_per_td - 1) {\n\t\t\tpreq->end_trb = ring->enqueue;\n\t\t\tcontrol = ring->pcs | TRB_TYPE(TRB_LINK) | TRB_CHAIN\n\t\t\t\t  | TRB_IOC;\n\t\t\tcdns2_ep_inc_enq(&pep->ring);\n\n\t\t\tif (ring->enqueue == 0)\n\t\t\t\tcontrol |= TRB_TOGGLE;\n\n\t\t\t \n\t\t\ttrb->buffer = cpu_to_le32(pep->ring.dma +\n\t\t\t\t\t\t  (ring->enqueue * TRB_SIZE));\n\t\t\ttrb->length = 0;\n\t\t\ttrb->control = cpu_to_le32(control);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (sg_iter == 0)\n\t\t\tcontrol = control ^ TRB_CYCLE;\n\n\t\t \n\t\tif (sg_iter == (trbs_per_td - (pep->dir ? 2 : 1)))\n\t\t\tcontrol |= TRB_IOC;\n\t\telse\n\t\t\tcontrol |= TRB_CHAIN;\n\n\t\ttrb->buffer = cpu_to_le32(trb_dma);\n\t\ttrb->length = cpu_to_le32(TRB_BURST(pep->trb_burst_size) |\n\t\t\t\t\t   TRB_LEN(length));\n\t\ttrb->control = cpu_to_le32(control);\n\n\t\tif (sg && sg_iter < (trbs_per_td - 1)) {\n\t\t\tsg = sg_next(sg);\n\t\t\ttrb_dma = sg_dma_address(sg);\n\t\t\tlength = sg_dma_len(sg);\n\t\t}\n\n\t\tpreq->end_trb = ring->enqueue;\n\t\tcdns2_ep_inc_enq(&pep->ring);\n\t}\n}\n\nstatic void cdns2_set_drdy(struct cdns2_device *pdev,\n\t\t\t   struct cdns2_endpoint *pep)\n{\n\ttrace_cdns2_ring(pep);\n\n\t \n\tdma_wmb();\n\n\t \n\twritel(DMA_EP_STS_TRBERR | DMA_EP_STS_DESCMIS,\n\t       &pdev->adma_regs->ep_sts);\n\twritel(DMA_EP_CMD_DRDY, &pdev->adma_regs->ep_cmd);\n\n\tif (readl(&pdev->adma_regs->ep_sts) & DMA_EP_STS_TRBERR) {\n\t\twritel(DMA_EP_STS_TRBERR, &pdev->adma_regs->ep_sts);\n\t\twritel(DMA_EP_CMD_DRDY, &pdev->adma_regs->ep_cmd);\n\t}\n\n\ttrace_cdns2_doorbell_epx(pep, readl(&pdev->adma_regs->ep_traddr));\n}\n\nstatic int cdns2_prepare_first_isoc_transfer(struct cdns2_device *pdev,\n\t\t\t\t\t     struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_trb *trb;\n\tu32 buffer;\n\tu8 hw_ccs;\n\n\tif ((readl(&pdev->adma_regs->ep_cmd) & DMA_EP_CMD_DRDY))\n\t\treturn -EBUSY;\n\n\tif (!pep->dir) {\n\t\tset_reg_bit_32(&pdev->adma_regs->ep_cfg, DMA_EP_CFG_ENABLE);\n\t\twritel(pep->ring.dma + pep->ring.dequeue,\n\t\t       &pdev->adma_regs->ep_traddr);\n\t\treturn 0;\n\t}\n\n\t \n\tbuffer = pep->ring.dma + pep->ring.dequeue * TRB_SIZE;\n\thw_ccs = !!DMA_EP_STS_CCS(readl(&pdev->adma_regs->ep_sts));\n\n\ttrb = &pep->ring.trbs[TRBS_PER_SEGMENT];\n\ttrb->length = 0;\n\ttrb->buffer = cpu_to_le32(TRB_BUFFER(buffer));\n\ttrb->control = cpu_to_le32((hw_ccs ? TRB_CYCLE : 0) | TRB_TYPE(TRB_NORMAL));\n\n\t \n\ttrb++;\n\ttrb->length = 0;\n\ttrb->buffer = cpu_to_le32(TRB_BUFFER(buffer));\n\ttrb->control = cpu_to_le32((hw_ccs ? TRB_CYCLE : 0) |\n\t\t\t\t    TRB_TYPE(TRB_LINK) | TRB_CHAIN);\n\n\tif (hw_ccs !=  pep->ring.ccs)\n\t\ttrb->control |= cpu_to_le32(TRB_TOGGLE);\n\n\tset_reg_bit_32(&pdev->adma_regs->ep_cfg, DMA_EP_CFG_ENABLE);\n\twritel(pep->ring.dma + (TRBS_PER_SEGMENT * TRB_SIZE),\n\t       &pdev->adma_regs->ep_traddr);\n\n\treturn 0;\n}\n\n \nstatic int cdns2_ep_run_transfer(struct cdns2_endpoint *pep,\n\t\t\t\t struct cdns2_request *preq)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_ring *ring;\n\tu32 togle_pcs = 1;\n\tint num_trbs;\n\tint ret;\n\n\tcdns2_select_ep(pdev, pep->endpoint.address);\n\n\tif (preq->request.sg)\n\t\tnum_trbs = cdns2_count_sg_trbs(pep, &preq->request);\n\telse\n\t\tnum_trbs = cdns2_count_trbs(pep, preq->request.dma,\n\t\t\t\t\t    preq->request.length);\n\n\tret = cdns2_prepare_ring(pdev, pep, num_trbs);\n\tif (ret)\n\t\treturn ret;\n\n\tring = &pep->ring;\n\tpreq->start_trb = ring->enqueue;\n\tpreq->trb = ring->trbs + ring->enqueue;\n\n\tif (usb_endpoint_xfer_isoc(pep->endpoint.desc)) {\n\t\tcdns2_ep_tx_isoc(pep, preq, num_trbs);\n\t} else {\n\t\ttogle_pcs = cdns2_wa1_update_guard(pep, ring->trbs + ring->enqueue);\n\t\tcdns2_ep_tx_bulk(pep, preq, num_trbs);\n\t}\n\n\tpreq->num_of_trb = num_trbs;\n\n\t \n\tdma_wmb();\n\n\t \n\tif (togle_pcs)\n\t\tpreq->trb->control = preq->trb->control ^ cpu_to_le32(1);\n\n\tcdns2_wa1_tray_restore_cycle_bit(pdev, pep);\n\tcdns2_dbg_request_trbs(pep, preq);\n\n\tif (!pep->wa1_set && !(pep->ep_state & EP_STALLED) && !pep->skip) {\n\t\tif (pep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tret = cdns2_prepare_first_isoc_transfer(pdev, pep);\n\t\t\tif (ret)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\tcdns2_set_drdy(pdev, pep);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cdns2_start_all_request(struct cdns2_device *pdev,\n\t\t\t\t   struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_request *preq;\n\tint ret;\n\n\twhile (!list_empty(&pep->deferred_list)) {\n\t\tpreq = cdns2_next_preq(&pep->deferred_list);\n\n\t\tret = cdns2_ep_run_transfer(pep, preq);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlist_move_tail(&preq->list, &pep->pending_list);\n\t}\n\n\tpep->ep_state &= ~EP_RING_FULL;\n\n\treturn 0;\n}\n\n \nstatic bool cdns2_trb_handled(struct cdns2_endpoint *pep,\n\t\t\t      struct cdns2_request *preq)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_ring *ring;\n\tstruct cdns2_trb *trb;\n\tint current_index = 0;\n\tint handled = 0;\n\tint doorbell;\n\n\tring = &pep->ring;\n\tcurrent_index = cdns2_get_dma_pos(pdev, pep);\n\tdoorbell = !!(readl(&pdev->adma_regs->ep_cmd) & DMA_EP_CMD_DRDY);\n\n\t \n\tif (current_index >= TRBS_PER_SEGMENT)\n\t\tgoto finish;\n\n\t \n\tif (preq->start_trb < preq->end_trb) {\n\t\tif (ring->dequeue > preq->end_trb)\n\t\t\tgoto finish;\n\n\t\tif (ring->dequeue < preq->start_trb)\n\t\t\tgoto finish;\n\t}\n\n\tif (preq->start_trb > preq->end_trb && ring->dequeue > preq->end_trb &&\n\t    ring->dequeue < preq->start_trb)\n\t\tgoto finish;\n\n\tif (preq->start_trb == preq->end_trb && ring->dequeue != preq->end_trb)\n\t\tgoto finish;\n\n\ttrb = &ring->trbs[ring->dequeue];\n\n\tif ((le32_to_cpu(trb->control) & TRB_CYCLE) != ring->ccs)\n\t\tgoto finish;\n\n\tif (doorbell == 1 && current_index == ring->dequeue)\n\t\tgoto finish;\n\n\t \n\tif (TRBS_PER_SEGMENT == 2 && pep->type != USB_ENDPOINT_XFER_ISOC) {\n\t\thandled = 1;\n\t\tgoto finish;\n\t}\n\n\tif (ring->enqueue == ring->dequeue &&\n\t    ring->free_trbs == 0) {\n\t\thandled = 1;\n\t} else if (ring->dequeue < current_index) {\n\t\tif ((current_index == (TRBS_PER_SEGMENT - 1)) &&\n\t\t    !ring->dequeue)\n\t\t\tgoto finish;\n\n\t\thandled = 1;\n\t} else if (ring->dequeue  > current_index) {\n\t\thandled = 1;\n\t}\n\nfinish:\n\ttrace_cdns2_request_handled(preq, current_index, handled);\n\n\treturn handled;\n}\n\nstatic void cdns2_skip_isoc_td(struct cdns2_device *pdev,\n\t\t\t       struct cdns2_endpoint *pep,\n\t\t\t       struct cdns2_request *preq)\n{\n\tstruct cdns2_trb *trb;\n\tint i;\n\n\ttrb = pep->ring.trbs + pep->ring.dequeue;\n\n\tfor (i = preq->finished_trb ; i < preq->num_of_trb; i++) {\n\t\tpreq->finished_trb++;\n\t\ttrace_cdns2_complete_trb(pep, trb);\n\t\tcdns2_ep_inc_deq(&pep->ring);\n\t\ttrb = cdns2_next_trb(pep, trb);\n\t}\n\n\tcdns2_gadget_giveback(pep, preq, 0);\n\tcdns2_prepare_first_isoc_transfer(pdev, pep);\n\tpep->skip = false;\n\tcdns2_set_drdy(pdev, pep);\n}\n\nstatic void cdns2_transfer_completed(struct cdns2_device *pdev,\n\t\t\t\t     struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_request *preq = NULL;\n\tbool request_handled = false;\n\tstruct cdns2_trb *trb;\n\n\twhile (!list_empty(&pep->pending_list)) {\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\t\ttrb = pep->ring.trbs + pep->ring.dequeue;\n\n\t\t \n\t\twhile (TRB_FIELD_TO_TYPE(le32_to_cpu(trb->control)) == TRB_LINK &&\n\t\t       le32_to_cpu(trb->length)) {\n\t\t\ttrace_cdns2_complete_trb(pep, trb);\n\t\t\tcdns2_ep_inc_deq(&pep->ring);\n\t\t\ttrb = pep->ring.trbs + pep->ring.dequeue;\n\t\t}\n\n\t\t \n\t\tcdns2_select_ep(pdev, pep->endpoint.address);\n\n\t\twhile (cdns2_trb_handled(pep, preq)) {\n\t\t\tpreq->finished_trb++;\n\n\t\t\tif (preq->finished_trb >= preq->num_of_trb)\n\t\t\t\trequest_handled = true;\n\n\t\t\ttrb = pep->ring.trbs + pep->ring.dequeue;\n\t\t\ttrace_cdns2_complete_trb(pep, trb);\n\n\t\t\tif (pep->dir && pep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\t \n\t\t\t\tpreq->request.actual = preq->request.length;\n\t\t\telse\n\t\t\t\tpreq->request.actual +=\n\t\t\t\t\tTRB_LEN(le32_to_cpu(trb->length));\n\n\t\t\tcdns2_ep_inc_deq(&pep->ring);\n\t\t}\n\n\t\tif (request_handled) {\n\t\t\tcdns2_gadget_giveback(pep, preq, 0);\n\t\t\trequest_handled = false;\n\t\t} else {\n\t\t\tgoto prepare_next_td;\n\t\t}\n\n\t\tif (pep->type != USB_ENDPOINT_XFER_ISOC &&\n\t\t    TRBS_PER_SEGMENT == 2)\n\t\t\tbreak;\n\t}\n\nprepare_next_td:\n\tif (pep->skip && preq)\n\t\tcdns2_skip_isoc_td(pdev, pep, preq);\n\n\tif (!(pep->ep_state & EP_STALLED) &&\n\t    !(pep->ep_state & EP_STALL_PENDING))\n\t\tcdns2_start_all_request(pdev, pep);\n}\n\nstatic void cdns2_wakeup(struct cdns2_device *pdev)\n{\n\tif (!pdev->may_wakeup)\n\t\treturn;\n\n\t \n\tset_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_SIGRSUME);\n}\n\nstatic void cdns2_rearm_transfer(struct cdns2_endpoint *pep, u8 rearm)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\n\tcdns2_wa1_restore_cycle_bit(pep);\n\n\tif (rearm) {\n\t\ttrace_cdns2_ring(pep);\n\n\t\t \n\t\tdma_wmb();\n\n\t\twritel(DMA_EP_CMD_DRDY, &pdev->adma_regs->ep_cmd);\n\n\t\tcdns2_wakeup(pdev);\n\n\t\ttrace_cdns2_doorbell_epx(pep,\n\t\t\t\t\t readl(&pdev->adma_regs->ep_traddr));\n\t}\n}\n\nstatic void cdns2_handle_epx_interrupt(struct cdns2_endpoint *pep)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tu8 isoerror = 0;\n\tu32 ep_sts_reg;\n\tu32 val;\n\n\tcdns2_select_ep(pdev, pep->endpoint.address);\n\n\ttrace_cdns2_epx_irq(pdev, pep);\n\n\tep_sts_reg = readl(&pdev->adma_regs->ep_sts);\n\twritel(ep_sts_reg, &pdev->adma_regs->ep_sts);\n\n\tif (pep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tu8 mult;\n\t\tu8 cs;\n\n\t\tmult = USB_EP_MAXP_MULT(pep->endpoint.desc->wMaxPacketSize);\n\t\tcs = pep->dir ? readb(&pdev->epx_regs->ep[pep->num - 1].txcs) :\n\t\t\t\treadb(&pdev->epx_regs->ep[pep->num - 1].rxcs);\n\t\tif (mult > 0)\n\t\t\tisoerror = EPX_CS_ERR(cs);\n\t}\n\n\t \n\tif ((ep_sts_reg & DMA_EP_STS_ISOERR) || isoerror) {\n\t\tclear_reg_bit_32(&pdev->adma_regs->ep_cfg, DMA_EP_CFG_ENABLE);\n\n\t\t \n\t\treadl_poll_timeout_atomic(&pdev->adma_regs->ep_sts, val,\n\t\t\t\t\t  !(val & DMA_EP_STS_DBUSY), 1, 125);\n\n\t\twritel(DMA_EP_CMD_DFLUSH, &pep->pdev->adma_regs->ep_cmd);\n\n\t\t \n\t\treadl_poll_timeout_atomic(&pep->pdev->adma_regs->ep_cmd, val,\n\t\t\t\t\t  !(val & DMA_EP_CMD_DFLUSH), 1, 10);\n\n\t\tpep->skip = true;\n\t}\n\n\tif (ep_sts_reg & DMA_EP_STS_TRBERR || pep->skip) {\n\t\tif (pep->ep_state & EP_STALL_PENDING &&\n\t\t    !(ep_sts_reg & DMA_EP_STS_DESCMIS))\n\t\t\tcdns2_ep_stall_flush(pep);\n\n\t\t \n\t\tif (pep->type == USB_ENDPOINT_XFER_ISOC && !pep->wa1_set) {\n\t\t\tif (!pep->dir)\n\t\t\t\tclear_reg_bit_32(&pdev->adma_regs->ep_cfg,\n\t\t\t\t\t\t DMA_EP_CFG_ENABLE);\n\n\t\t\tcdns2_transfer_completed(pdev, pep);\n\t\t\tif (pep->ep_state & EP_DEFERRED_DRDY) {\n\t\t\t\tpep->ep_state &= ~EP_DEFERRED_DRDY;\n\t\t\t\tcdns2_set_drdy(pdev, pep);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tcdns2_transfer_completed(pdev, pep);\n\n\t\tif (!(pep->ep_state & EP_STALLED) &&\n\t\t    !(pep->ep_state & EP_STALL_PENDING)) {\n\t\t\tif (pep->ep_state & EP_DEFERRED_DRDY) {\n\t\t\t\tpep->ep_state &= ~EP_DEFERRED_DRDY;\n\t\t\t\tcdns2_start_all_request(pdev, pep);\n\t\t\t} else {\n\t\t\t\tcdns2_rearm_transfer(pep, pep->wa1_set);\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif ((ep_sts_reg & DMA_EP_STS_IOC) || (ep_sts_reg & DMA_EP_STS_ISP))\n\t\tcdns2_transfer_completed(pdev, pep);\n}\n\nstatic void cdns2_disconnect_gadget(struct cdns2_device *pdev)\n{\n\tif (pdev->gadget_driver && pdev->gadget_driver->disconnect)\n\t\tpdev->gadget_driver->disconnect(&pdev->gadget);\n}\n\nstatic irqreturn_t cdns2_usb_irq_handler(int irq, void *data)\n{\n\tstruct cdns2_device *pdev = data;\n\tunsigned long reg_ep_ists;\n\tu8 reg_usb_irq_m;\n\tu8 reg_ext_irq_m;\n\tu8 reg_usb_irq;\n\tu8 reg_ext_irq;\n\n\tif (pdev->in_lpm)\n\t\treturn IRQ_NONE;\n\n\treg_usb_irq_m = readb(&pdev->interrupt_regs->usbien);\n\treg_ext_irq_m = readb(&pdev->interrupt_regs->extien);\n\n\t \n\twriteb(0, &pdev->interrupt_regs->usbien);\n\twriteb(0, &pdev->interrupt_regs->extien);\n\twritel(0, &pdev->adma_regs->ep_ien);\n\n\t \n\twritel(0, &pdev->adma_regs->ep_sts);\n\twriteb(0, &pdev->interrupt_regs->usbirq);\n\twriteb(0, &pdev->interrupt_regs->extirq);\n\n\treg_ep_ists = readl(&pdev->adma_regs->ep_ists);\n\treg_usb_irq = readb(&pdev->interrupt_regs->usbirq);\n\treg_ext_irq = readb(&pdev->interrupt_regs->extirq);\n\n\tif (reg_ep_ists || (reg_usb_irq & reg_usb_irq_m) ||\n\t    (reg_ext_irq & reg_ext_irq_m))\n\t\treturn IRQ_WAKE_THREAD;\n\n\twriteb(USB_IEN_INIT, &pdev->interrupt_regs->usbien);\n\twriteb(EXTIRQ_WAKEUP, &pdev->interrupt_regs->extien);\n\twritel(~0, &pdev->adma_regs->ep_ien);\n\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t cdns2_thread_usb_irq_handler(struct cdns2_device *pdev)\n{\n\tu8 usb_irq, ext_irq;\n\tint speed;\n\tint i;\n\n\text_irq = readb(&pdev->interrupt_regs->extirq) & EXTIRQ_WAKEUP;\n\twriteb(ext_irq, &pdev->interrupt_regs->extirq);\n\n\tusb_irq = readb(&pdev->interrupt_regs->usbirq) & USB_IEN_INIT;\n\twriteb(usb_irq, &pdev->interrupt_regs->usbirq);\n\n\tif (!ext_irq && !usb_irq)\n\t\treturn IRQ_NONE;\n\n\ttrace_cdns2_usb_irq(usb_irq, ext_irq);\n\n\tif (ext_irq & EXTIRQ_WAKEUP) {\n\t\tif (pdev->gadget_driver && pdev->gadget_driver->resume) {\n\t\t\tspin_unlock(&pdev->lock);\n\t\t\tpdev->gadget_driver->resume(&pdev->gadget);\n\t\t\tspin_lock(&pdev->lock);\n\t\t}\n\t}\n\n\tif (usb_irq & USBIRQ_LPM) {\n\t\tu8 reg = readb(&pdev->usb_regs->lpmctrl);\n\n\t\t \n\t\tif (!(reg & LPMCTRLLH_LPMNYET))\n\t\t\twriteb(0, &pdev->usb_regs->sleep_clkgate);\n\t}\n\n\tif (usb_irq & USBIRQ_SUSPEND) {\n\t\tif (pdev->gadget_driver && pdev->gadget_driver->suspend) {\n\t\t\tspin_unlock(&pdev->lock);\n\t\t\tpdev->gadget_driver->suspend(&pdev->gadget);\n\t\t\tspin_lock(&pdev->lock);\n\t\t}\n\t}\n\n\tif (usb_irq & USBIRQ_URESET) {\n\t\tif (pdev->gadget_driver) {\n\t\t\tpdev->dev_address = 0;\n\n\t\t\tspin_unlock(&pdev->lock);\n\t\t\tusb_gadget_udc_reset(&pdev->gadget,\n\t\t\t\t\t     pdev->gadget_driver);\n\t\t\tspin_lock(&pdev->lock);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 100; i++) {\n\t\t\t\tmdelay(1);\n\t\t\t\tspeed = cdns2_get_speed(pdev);\n\t\t\t\tif (speed == USB_SPEED_HIGH)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpdev->gadget.speed = speed;\n\t\t\tcdns2_enable_l1(pdev, 0);\n\t\t\tcdns2_ep0_config(pdev);\n\t\t\tpdev->may_wakeup = 0;\n\t\t}\n\t}\n\n\tif (usb_irq & USBIRQ_SUDAV) {\n\t\tpdev->ep0_stage = CDNS2_SETUP_STAGE;\n\t\tcdns2_handle_setup_packet(pdev);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t cdns2_thread_irq_handler(int irq, void *data)\n{\n\tstruct cdns2_device *pdev = data;\n\tunsigned long  dma_ep_ists;\n\tunsigned long flags;\n\tunsigned int bit;\n\n\tlocal_bh_disable();\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tcdns2_thread_usb_irq_handler(pdev);\n\n\tdma_ep_ists = readl(&pdev->adma_regs->ep_ists);\n\tif (!dma_ep_ists)\n\t\tgoto unlock;\n\n\ttrace_cdns2_dma_ep_ists(dma_ep_ists);\n\n\t \n\tif (dma_ep_ists & DMA_EP_ISTS_EP_OUT0)\n\t\tcdns2_handle_ep0_interrupt(pdev, USB_DIR_OUT);\n\n\t \n\tif (dma_ep_ists & DMA_EP_ISTS_EP_IN0)\n\t\tcdns2_handle_ep0_interrupt(pdev, USB_DIR_IN);\n\n\tdma_ep_ists &= ~(DMA_EP_ISTS_EP_OUT0 | DMA_EP_ISTS_EP_IN0);\n\n\tfor_each_set_bit(bit, &dma_ep_ists, sizeof(u32) * BITS_PER_BYTE) {\n\t\tu8 ep_idx = bit > 16 ? (bit - 16) * 2 : (bit * 2) - 1;\n\n\t\t \n\t\tcdns2_handle_epx_interrupt(&pdev->eps[ep_idx]);\n\t}\n\nunlock:\n\twritel(~0, &pdev->adma_regs->ep_ien);\n\twriteb(USB_IEN_INIT, &pdev->interrupt_regs->usbien);\n\twriteb(EXTIRQ_WAKEUP, &pdev->interrupt_regs->extien);\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\tlocal_bh_enable();\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void cdns2_eps_onchip_buffer_init(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep;\n\tint min_buf_tx = 0;\n\tint min_buf_rx = 0;\n\tu16 tx_offset = 0;\n\tu16 rx_offset = 0;\n\tint free;\n\tint i;\n\n\tfor (i = 0; i < CDNS2_ENDPOINTS_NUM; i++) {\n\t\tpep = &pdev->eps[i];\n\n\t\tif (!(pep->ep_state & EP_CLAIMED))\n\t\t\tcontinue;\n\n\t\tif (pep->dir)\n\t\t\tmin_buf_tx += pep->buffering;\n\t\telse\n\t\t\tmin_buf_rx += pep->buffering;\n\t}\n\n\tfor (i = 0; i < CDNS2_ENDPOINTS_NUM; i++) {\n\t\tpep = &pdev->eps[i];\n\n\t\tif (!(pep->ep_state & EP_CLAIMED))\n\t\t\tcontinue;\n\n\t\tif (pep->dir) {\n\t\t\tfree = pdev->onchip_tx_buf - min_buf_tx;\n\n\t\t\tif (free + pep->buffering >= 4)\n\t\t\t\tfree = 4;\n\t\t\telse\n\t\t\t\tfree = free + pep->buffering;\n\n\t\t\tmin_buf_tx = min_buf_tx - pep->buffering + free;\n\n\t\t\tpep->buffering = free;\n\n\t\t\twritel(tx_offset,\n\t\t\t       &pdev->epx_regs->txstaddr[pep->num - 1]);\n\t\t\tpdev->epx_regs->txstaddr[pep->num - 1] = tx_offset;\n\n\t\t\tdev_dbg(pdev->dev, \"%s onchip address %04x, buffering: %d\\n\",\n\t\t\t\tpep->name, tx_offset, pep->buffering);\n\n\t\t\ttx_offset += pep->buffering * 1024;\n\t\t} else {\n\t\t\tfree = pdev->onchip_rx_buf - min_buf_rx;\n\n\t\t\tif (free + pep->buffering >= 4)\n\t\t\t\tfree = 4;\n\t\t\telse\n\t\t\t\tfree = free + pep->buffering;\n\n\t\t\tmin_buf_rx = min_buf_rx - pep->buffering + free;\n\n\t\t\tpep->buffering = free;\n\t\t\twritel(rx_offset,\n\t\t\t       &pdev->epx_regs->rxstaddr[pep->num - 1]);\n\n\t\t\tdev_dbg(pdev->dev, \"%s onchip address %04x, buffering: %d\\n\",\n\t\t\t\tpep->name, rx_offset, pep->buffering);\n\n\t\t\trx_offset += pep->buffering * 1024;\n\t\t}\n\t}\n}\n\n \nstatic int cdns2_ep_config(struct cdns2_endpoint *pep, bool enable)\n{\n\tbool is_iso_ep = (pep->type == USB_ENDPOINT_XFER_ISOC);\n\tstruct cdns2_device *pdev = pep->pdev;\n\tu32 max_packet_size;\n\tu8 dir = 0;\n\tu8 ep_cfg;\n\tu8 mult;\n\tu32 val;\n\tint ret;\n\n\tswitch (pep->type) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep_cfg = EPX_CON_TYPE_INT;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep_cfg = EPX_CON_TYPE_BULK;\n\t\tbreak;\n\tdefault:\n\t\tmult = USB_EP_MAXP_MULT(pep->endpoint.desc->wMaxPacketSize);\n\t\tep_cfg = mult << EPX_CON_ISOD_SHIFT;\n\t\tep_cfg |= EPX_CON_TYPE_ISOC;\n\n\t\tif (pep->dir) {\n\t\t\tset_reg_bit_8(&pdev->epx_regs->isoautoarm, BIT(pep->num));\n\t\t\tset_reg_bit_8(&pdev->epx_regs->isoautodump, BIT(pep->num));\n\t\t\tset_reg_bit_8(&pdev->epx_regs->isodctrl, BIT(pep->num));\n\t\t}\n\t}\n\n\tswitch (pdev->gadget.speed) {\n\tcase USB_SPEED_FULL:\n\t\tmax_packet_size = is_iso_ep ? 1023 : 64;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tmax_packet_size = is_iso_ep ? 1024 : 512;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tep_cfg |= (EPX_CON_VAL | (pep->buffering - 1));\n\n\tif (pep->dir) {\n\t\tdir = FIFOCTRL_IO_TX;\n\t\twritew(max_packet_size, &pdev->epx_regs->txmaxpack[pep->num - 1]);\n\t\twriteb(ep_cfg, &pdev->epx_regs->ep[pep->num - 1].txcon);\n\t} else {\n\t\twritew(max_packet_size, &pdev->epx_regs->rxmaxpack[pep->num - 1]);\n\t\twriteb(ep_cfg, &pdev->epx_regs->ep[pep->num - 1].rxcon);\n\t}\n\n\twriteb(pep->num | dir | FIFOCTRL_FIFOAUTO,\n\t       &pdev->usb_regs->fifoctrl);\n\twriteb(pep->num | dir, &pdev->epx_regs->endprst);\n\twriteb(pep->num | ENDPRST_FIFORST | ENDPRST_TOGRST | dir,\n\t       &pdev->epx_regs->endprst);\n\n\tif (max_packet_size == 1024)\n\t\tpep->trb_burst_size = 128;\n\telse if (max_packet_size >= 512)\n\t\tpep->trb_burst_size = 64;\n\telse\n\t\tpep->trb_burst_size = 16;\n\n\tcdns2_select_ep(pdev, pep->num | pep->dir);\n\twritel(DMA_EP_CMD_EPRST | DMA_EP_CMD_DFLUSH, &pdev->adma_regs->ep_cmd);\n\n\tret = readl_poll_timeout_atomic(&pdev->adma_regs->ep_cmd, val,\n\t\t\t\t\t!(val & (DMA_EP_CMD_DFLUSH |\n\t\t\t\t\tDMA_EP_CMD_EPRST)),\n\t\t\t\t\t1, 1000);\n\n\tif (ret)\n\t\treturn ret;\n\n\twritel(DMA_EP_STS_TRBERR | DMA_EP_STS_ISOERR, &pdev->adma_regs->ep_sts_en);\n\n\tif (enable)\n\t\twritel(DMA_EP_CFG_ENABLE, &pdev->adma_regs->ep_cfg);\n\n\ttrace_cdns2_epx_hw_cfg(pdev, pep);\n\n\tdev_dbg(pdev->dev, \"Configure %s: with MPS: %08x, ep con: %02x\\n\",\n\t\tpep->name, max_packet_size, ep_cfg);\n\n\treturn 0;\n}\n\nstruct usb_request *cdns2_gadget_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t  gfp_t gfp_flags)\n{\n\tstruct cdns2_endpoint *pep = ep_to_cdns2_ep(ep);\n\tstruct cdns2_request *preq;\n\n\tpreq = kzalloc(sizeof(*preq), gfp_flags);\n\tif (!preq)\n\t\treturn NULL;\n\n\tpreq->pep = pep;\n\n\ttrace_cdns2_alloc_request(preq);\n\n\treturn &preq->request;\n}\n\nvoid cdns2_gadget_ep_free_request(struct usb_ep *ep,\n\t\t\t\t  struct usb_request *request)\n{\n\tstruct cdns2_request *preq = to_cdns2_request(request);\n\n\ttrace_cdns2_free_request(preq);\n\tkfree(preq);\n}\n\nstatic int cdns2_gadget_ep_enable(struct usb_ep *ep,\n\t\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tu32 reg = DMA_EP_STS_EN_TRBERREN;\n\tstruct cdns2_endpoint *pep;\n\tstruct cdns2_device *pdev;\n\tunsigned long flags;\n\tint enable = 1;\n\tint ret = 0;\n\n\tif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT ||\n\t    !desc->wMaxPacketSize) {\n\t\treturn -EINVAL;\n\t}\n\n\tpep = ep_to_cdns2_ep(ep);\n\tpdev = pep->pdev;\n\n\tif (dev_WARN_ONCE(pdev->dev, pep->ep_state & EP_ENABLED,\n\t\t\t  \"%s is already enabled\\n\", pep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tpep->type = usb_endpoint_type(desc);\n\tpep->interval = desc->bInterval ? BIT(desc->bInterval - 1) : 0;\n\n\tif (pdev->gadget.speed == USB_SPEED_FULL)\n\t\tif (pep->type == USB_ENDPOINT_XFER_INT)\n\t\t\tpep->interval = desc->bInterval;\n\n\tif (pep->interval > ISO_MAX_INTERVAL &&\n\t    pep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tdev_err(pdev->dev, \"ISO period is limited to %d (current: %d)\\n\",\n\t\t\tISO_MAX_INTERVAL, pep->interval);\n\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (pep->type == USB_ENDPOINT_XFER_ISOC  && !pep->dir)\n\t\tenable = 0;\n\n\tret = cdns2_alloc_tr_segment(pep);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = cdns2_ep_config(pep, enable);\n\tif (ret) {\n\t\tcdns2_free_tr_segment(pep);\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\ttrace_cdns2_gadget_ep_enable(pep);\n\n\tpep->ep_state &= ~(EP_STALLED | EP_STALL_PENDING);\n\tpep->ep_state |= EP_ENABLED;\n\tpep->wa1_set = 0;\n\tpep->ring.enqueue = 0;\n\tpep->ring.dequeue = 0;\n\treg = readl(&pdev->adma_regs->ep_sts);\n\tpep->ring.pcs = !!DMA_EP_STS_CCS(reg);\n\tpep->ring.ccs = !!DMA_EP_STS_CCS(reg);\n\n\twritel(pep->ring.dma, &pdev->adma_regs->ep_traddr);\n\n\t \n\tpep->ring.free_trbs = TRBS_PER_SEGMENT - 1;\n\nexit:\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int cdns2_gadget_ep_disable(struct usb_ep *ep)\n{\n\tstruct cdns2_endpoint *pep;\n\tstruct cdns2_request *preq;\n\tstruct cdns2_device *pdev;\n\tunsigned long flags;\n\tint val;\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tpep = ep_to_cdns2_ep(ep);\n\tpdev = pep->pdev;\n\n\tif (dev_WARN_ONCE(pdev->dev, !(pep->ep_state & EP_ENABLED),\n\t\t\t  \"%s is already disabled\\n\", pep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\ttrace_cdns2_gadget_ep_disable(pep);\n\n\tcdns2_select_ep(pdev, ep->desc->bEndpointAddress);\n\n\tclear_reg_bit_32(&pdev->adma_regs->ep_cfg, DMA_EP_CFG_ENABLE);\n\n\t \n\treadl_poll_timeout_atomic(&pdev->adma_regs->ep_sts, val,\n\t\t\t\t  !(val & DMA_EP_STS_DBUSY), 1, 10);\n\twritel(DMA_EP_CMD_EPRST, &pdev->adma_regs->ep_cmd);\n\n\treadl_poll_timeout_atomic(&pdev->adma_regs->ep_cmd, val,\n\t\t\t\t  !(val & (DMA_EP_CMD_DFLUSH | DMA_EP_CMD_EPRST)),\n\t\t\t\t  1, 1000);\n\n\twhile (!list_empty(&pep->pending_list)) {\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\t\tcdns2_gadget_giveback(pep, preq, -ESHUTDOWN);\n\t}\n\n\twhile (!list_empty(&pep->deferred_list)) {\n\t\tpreq = cdns2_next_preq(&pep->deferred_list);\n\t\tcdns2_gadget_giveback(pep, preq, -ESHUTDOWN);\n\t}\n\n\tep->desc = NULL;\n\tpep->ep_state &= ~EP_ENABLED;\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdns2_ep_enqueue(struct cdns2_endpoint *pep,\n\t\t\t    struct cdns2_request *preq,\n\t\t\t    gfp_t gfp_flags)\n{\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct usb_request *request;\n\tint ret;\n\n\trequest = &preq->request;\n\trequest->actual = 0;\n\trequest->status = -EINPROGRESS;\n\n\tret = usb_gadget_map_request_by_dev(pdev->dev, request, pep->dir);\n\tif (ret) {\n\t\ttrace_cdns2_request_enqueue_error(preq);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&preq->list, &pep->deferred_list);\n\ttrace_cdns2_request_enqueue(preq);\n\n\tif (!(pep->ep_state & EP_STALLED) && !(pep->ep_state & EP_STALL_PENDING))\n\t\tcdns2_start_all_request(pdev, pep);\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct usb_request *zlp_request;\n\tstruct cdns2_request *preq;\n\tstruct cdns2_endpoint *pep;\n\tstruct cdns2_device *pdev;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!request || !ep)\n\t\treturn -EINVAL;\n\n\tpep = ep_to_cdns2_ep(ep);\n\tpdev = pep->pdev;\n\n\tif (!(pep->ep_state & EP_ENABLED)) {\n\t\tdev_err(pdev->dev, \"%s: can't queue to disabled endpoint\\n\",\n\t\t\tpep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tpreq =  to_cdns2_request(request);\n\tret = cdns2_ep_enqueue(pep, preq, gfp_flags);\n\n\tif (ret == 0 && request->zero && request->length &&\n\t    (request->length % ep->maxpacket == 0)) {\n\t\tstruct cdns2_request *preq;\n\n\t\tzlp_request = cdns2_gadget_ep_alloc_request(ep, GFP_ATOMIC);\n\t\tzlp_request->buf = pdev->zlp_buf;\n\t\tzlp_request->length = 0;\n\n\t\tpreq = to_cdns2_request(zlp_request);\n\t\tret = cdns2_ep_enqueue(pep, preq, gfp_flags);\n\t}\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\treturn ret;\n}\n\nint cdns2_gadget_ep_dequeue(struct usb_ep *ep,\n\t\t\t    struct usb_request *request)\n{\n\tstruct cdns2_request *preq, *preq_temp, *cur_preq;\n\tstruct cdns2_endpoint *pep;\n\tstruct cdns2_trb *link_trb;\n\tu8 req_on_hw_ring = 0;\n\tunsigned long flags;\n\tu32 buffer;\n\tint val, i;\n\n\tif (!ep || !request || !ep->desc)\n\t\treturn -EINVAL;\n\n\tpep = ep_to_cdns2_ep(ep);\n\tif (!pep->endpoint.desc) {\n\t\tdev_err(pep->pdev->dev, \"%s: can't dequeue to disabled endpoint\\n\",\n\t\t\tpep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (!(pep->ep_state & EP_ENABLED))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pep->pdev->lock, flags);\n\n\tcur_preq = to_cdns2_request(request);\n\ttrace_cdns2_request_dequeue(cur_preq);\n\n\tlist_for_each_entry_safe(preq, preq_temp, &pep->pending_list, list) {\n\t\tif (cur_preq == preq) {\n\t\t\treq_on_hw_ring = 1;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(preq, preq_temp, &pep->deferred_list, list) {\n\t\tif (cur_preq == preq)\n\t\t\tgoto found;\n\t}\n\n\tgoto not_found;\n\nfound:\n\tlink_trb = preq->trb;\n\n\t \n\tif (req_on_hw_ring && link_trb) {\n\t\t \n\t\twritel(DMA_EP_CMD_DFLUSH, &pep->pdev->adma_regs->ep_cmd);\n\n\t\t \n\t\treadl_poll_timeout_atomic(&pep->pdev->adma_regs->ep_cmd, val,\n\t\t\t\t\t  !(val & DMA_EP_CMD_DFLUSH), 1, 1000);\n\n\t\tbuffer = cpu_to_le32(TRB_BUFFER(pep->ring.dma +\n\t\t\t\t    ((preq->end_trb + 1) * TRB_SIZE)));\n\n\t\tfor (i = 0; i < preq->num_of_trb; i++) {\n\t\t\tlink_trb->buffer = buffer;\n\t\t\tlink_trb->control = cpu_to_le32((le32_to_cpu(link_trb->control)\n\t\t\t\t\t    & TRB_CYCLE) | TRB_CHAIN |\n\t\t\t\t\t    TRB_TYPE(TRB_LINK));\n\n\t\t\ttrace_cdns2_queue_trb(pep, link_trb);\n\t\t\tlink_trb = cdns2_next_trb(pep, link_trb);\n\t\t}\n\n\t\tif (pep->wa1_trb == preq->trb)\n\t\t\tcdns2_wa1_restore_cycle_bit(pep);\n\t}\n\n\tcdns2_gadget_giveback(pep, cur_preq, -ECONNRESET);\n\n\tpreq = cdns2_next_preq(&pep->pending_list);\n\tif (preq)\n\t\tcdns2_rearm_transfer(pep, 1);\n\nnot_found:\n\tspin_unlock_irqrestore(&pep->pdev->lock, flags);\n\treturn 0;\n}\n\nint cdns2_halt_endpoint(struct cdns2_device *pdev,\n\t\t\tstruct cdns2_endpoint *pep,\n\t\t\tint value)\n{\n\tu8 __iomem *conf;\n\tint dir = 0;\n\n\tif (!(pep->ep_state & EP_ENABLED))\n\t\treturn -EPERM;\n\n\tif (pep->dir) {\n\t\tdir = ENDPRST_IO_TX;\n\t\tconf = &pdev->epx_regs->ep[pep->num - 1].txcon;\n\t} else {\n\t\tconf = &pdev->epx_regs->ep[pep->num - 1].rxcon;\n\t}\n\n\tif (!value) {\n\t\tstruct cdns2_trb *trb = NULL;\n\t\tstruct cdns2_request *preq;\n\t\tstruct cdns2_trb trb_tmp;\n\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\t\tif (preq) {\n\t\t\ttrb = preq->trb;\n\t\t\tif (trb) {\n\t\t\t\ttrb_tmp = *trb;\n\t\t\t\ttrb->control = trb->control ^ cpu_to_le32(TRB_CYCLE);\n\t\t\t}\n\t\t}\n\n\t\ttrace_cdns2_ep_halt(pep, 0, 0);\n\n\t\t \n\t\twriteb(dir | pep->num, &pdev->epx_regs->endprst);\n\t\twriteb(dir | ENDPRST_TOGRST | pep->num,\n\t\t       &pdev->epx_regs->endprst);\n\n\t\tclear_reg_bit_8(conf, EPX_CON_STALL);\n\n\t\tpep->ep_state &= ~(EP_STALLED | EP_STALL_PENDING);\n\n\t\tif (preq) {\n\t\t\tif (trb)\n\t\t\t\t*trb = trb_tmp;\n\n\t\t\tcdns2_rearm_transfer(pep, 1);\n\t\t}\n\n\t\tcdns2_start_all_request(pdev, pep);\n\t} else {\n\t\ttrace_cdns2_ep_halt(pep, 1, 0);\n\t\tset_reg_bit_8(conf, EPX_CON_STALL);\n\t\twriteb(dir | pep->num, &pdev->epx_regs->endprst);\n\t\twriteb(dir | ENDPRST_FIFORST | pep->num,\n\t\t       &pdev->epx_regs->endprst);\n\t\tpep->ep_state |= EP_STALLED;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cdns2_gadget_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct cdns2_endpoint *pep = ep_to_cdns2_ep(ep);\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_request *preq;\n\tunsigned long flags = 0;\n\tint ret;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tpreq = cdns2_next_preq(&pep->pending_list);\n\tif (value && preq) {\n\t\ttrace_cdns2_ep_busy_try_halt_again(pep);\n\t\tret = -EAGAIN;\n\t\tgoto done;\n\t}\n\n\tif (!value)\n\t\tpep->ep_state &= ~EP_WEDGE;\n\n\tret = cdns2_halt_endpoint(pdev, pep, value);\n\ndone:\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\treturn ret;\n}\n\nstatic int cdns2_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct cdns2_endpoint *pep = ep_to_cdns2_ep(ep);\n\n\tcdns2_gadget_ep_set_halt(ep, 1);\n\tpep->ep_state |= EP_WEDGE;\n\n\treturn 0;\n}\n\nstatic struct\ncdns2_endpoint *cdns2_find_available_ep(struct cdns2_device *pdev,\n\t\t\t\t\tstruct usb_endpoint_descriptor *desc)\n{\n\tstruct cdns2_endpoint *pep;\n\tstruct usb_ep *ep;\n\tint ep_correct;\n\n\tlist_for_each_entry(ep, &pdev->gadget.ep_list, ep_list) {\n\t\tunsigned long num;\n\t\tint ret;\n\t\t \n\t\tchar c[2] = {ep->name[2], '\\0'};\n\n\t\tret = kstrtoul(c, 10, &num);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\tpep = ep_to_cdns2_ep(ep);\n\n\t\tif (pep->num != num)\n\t\t\tcontinue;\n\n\t\tep_correct = (pep->endpoint.caps.dir_in &&\n\t\t\t      usb_endpoint_dir_in(desc)) ||\n\t\t\t     (pep->endpoint.caps.dir_out &&\n\t\t\t      usb_endpoint_dir_out(desc));\n\n\t\tif (ep_correct && !(pep->ep_state & EP_CLAIMED))\n\t\t\treturn pep;\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstatic struct\nusb_ep *cdns2_gadget_match_ep(struct usb_gadget *gadget,\n\t\t\t      struct usb_endpoint_descriptor *desc,\n\t\t\t      struct usb_ss_ep_comp_descriptor *comp_desc)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tstruct cdns2_endpoint *pep;\n\tunsigned long flags;\n\n\tpep = cdns2_find_available_ep(pdev, desc);\n\tif (IS_ERR(pep)) {\n\t\tdev_err(pdev->dev, \"no available ep\\n\");\n\t\treturn NULL;\n\t}\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_ISOC)\n\t\tpep->buffering = 4;\n\telse\n\t\tpep->buffering = 1;\n\n\tpep->ep_state |= EP_CLAIMED;\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn &pep->endpoint;\n}\n\nstatic const struct usb_ep_ops cdns2_gadget_ep_ops = {\n\t.enable = cdns2_gadget_ep_enable,\n\t.disable = cdns2_gadget_ep_disable,\n\t.alloc_request = cdns2_gadget_ep_alloc_request,\n\t.free_request = cdns2_gadget_ep_free_request,\n\t.queue = cdns2_gadget_ep_queue,\n\t.dequeue = cdns2_gadget_ep_dequeue,\n\t.set_halt = cdns2_gadget_ep_set_halt,\n\t.set_wedge = cdns2_gadget_ep_set_wedge,\n};\n\nstatic int cdns2_gadget_get_frame(struct usb_gadget *gadget)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\n\treturn readw(&pdev->usb_regs->frmnr);\n}\n\nstatic int cdns2_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tcdns2_wakeup(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_set_selfpowered(struct usb_gadget *gadget,\n\t\t\t\t\tint is_selfpowered)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tpdev->is_selfpowered = !!is_selfpowered;\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\treturn 0;\n}\n\n \nstatic void cdns2_quiesce(struct cdns2_device *pdev)\n{\n\tset_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_DISCON);\n\n\t \n\twriteb(0, &pdev->interrupt_regs->extien),\n\twriteb(0, &pdev->interrupt_regs->usbien),\n\twritew(0, &pdev->adma_regs->ep_ien);\n\n\t \n\twriteb(0x0, &pdev->interrupt_regs->usbirq);\n}\n\nstatic void cdns2_gadget_config(struct cdns2_device *pdev)\n{\n\tcdns2_ep0_config(pdev);\n\n\t \n\twritel(~0x0, &pdev->adma_regs->ep_ien);\n\tcdns2_enable_l1(pdev, 0);\n\twriteb(USB_IEN_INIT, &pdev->interrupt_regs->usbien);\n\twriteb(EXTIRQ_WAKEUP, &pdev->interrupt_regs->extien);\n\twritel(DMA_CONF_DMULT, &pdev->adma_regs->conf);\n}\n\nstatic int cdns2_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tunsigned long flags;\n\n\ttrace_cdns2_pullup(is_on);\n\n\t \n\tdisable_irq(pdev->irq);\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tif (is_on) {\n\t\tcdns2_gadget_config(pdev);\n\t\tclear_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_DISCON);\n\t} else {\n\t\tcdns2_quiesce(pdev);\n\t}\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\tenable_irq(pdev->irq);\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_udc_start(struct usb_gadget *gadget,\n\t\t\t\t  struct usb_gadget_driver *driver)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tenum usb_device_speed max_speed = driver->max_speed;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tpdev->gadget_driver = driver;\n\n\t \n\tmax_speed = min(driver->max_speed, gadget->max_speed);\n\n\tswitch (max_speed) {\n\tcase USB_SPEED_FULL:\n\t\twriteb(SPEEDCTRL_HSDISABLE, &pdev->usb_regs->speedctrl);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\twriteb(0, &pdev->usb_regs->speedctrl);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdev->dev, \"invalid maximum_speed parameter %d\\n\",\n\t\t\tmax_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tmax_speed = USB_SPEED_HIGH;\n\t\tbreak;\n\t}\n\n\t \n\twriteb(ENDPRST_IO_TX, &pdev->usb_regs->endprst);\n\twriteb(ENDPRST_FIFORST | ENDPRST_TOGRST | ENDPRST_IO_TX,\n\t       &pdev->usb_regs->endprst);\n\twriteb(ENDPRST_FIFORST | ENDPRST_TOGRST, &pdev->usb_regs->endprst);\n\n\tcdns2_eps_onchip_buffer_init(pdev);\n\n\tcdns2_gadget_config(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct cdns2_device *pdev = gadget_to_cdns2_device(gadget);\n\tstruct cdns2_endpoint *pep;\n\tu32 bEndpointAddress;\n\tstruct usb_ep *ep;\n\tint val;\n\n\tpdev->gadget_driver = NULL;\n\tpdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tlist_for_each_entry(ep, &pdev->gadget.ep_list, ep_list) {\n\t\tpep = ep_to_cdns2_ep(ep);\n\t\tbEndpointAddress = pep->num | pep->dir;\n\t\tcdns2_select_ep(pdev, bEndpointAddress);\n\t\twritel(DMA_EP_CMD_EPRST, &pdev->adma_regs->ep_cmd);\n\t\treadl_poll_timeout_atomic(&pdev->adma_regs->ep_cmd, val,\n\t\t\t\t\t  !(val & DMA_EP_CMD_EPRST), 1, 100);\n\t}\n\n\tcdns2_quiesce(pdev);\n\n\twriteb(ENDPRST_IO_TX, &pdev->usb_regs->endprst);\n\twriteb(ENDPRST_FIFORST | ENDPRST_TOGRST | ENDPRST_IO_TX,\n\t       &pdev->epx_regs->endprst);\n\twriteb(ENDPRST_FIFORST | ENDPRST_TOGRST, &pdev->epx_regs->endprst);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops cdns2_gadget_ops = {\n\t.get_frame = cdns2_gadget_get_frame,\n\t.wakeup = cdns2_gadget_wakeup,\n\t.set_selfpowered = cdns2_gadget_set_selfpowered,\n\t.pullup = cdns2_gadget_pullup,\n\t.udc_start = cdns2_gadget_udc_start,\n\t.udc_stop = cdns2_gadget_udc_stop,\n\t.match_ep = cdns2_gadget_match_ep,\n};\n\nstatic void cdns2_free_all_eps(struct cdns2_device *pdev)\n{\n\tint i;\n\n\tfor (i = 0; i < CDNS2_ENDPOINTS_NUM; i++)\n\t\tcdns2_free_tr_segment(&pdev->eps[i]);\n}\n\n \nstatic int cdns2_init_eps(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep;\n\tint i;\n\n\tfor (i = 0; i < CDNS2_ENDPOINTS_NUM; i++) {\n\t\tbool direction = !(i & 1);  \n\t\tu8 epnum = ((i + 1) >> 1);\n\n\t\t \n\t\tif (!CDNS2_IF_EP_EXIST(pdev, epnum, direction))\n\t\t\tcontinue;\n\n\t\tpep = &pdev->eps[i];\n\t\tpep->pdev = pdev;\n\t\tpep->num = epnum;\n\t\t \n\t\tpep->dir = direction ? USB_DIR_IN : USB_DIR_OUT;\n\t\tpep->idx = i;\n\n\t\t \n\t\tif (!epnum) {\n\t\t\tint ret;\n\n\t\t\tsnprintf(pep->name, sizeof(pep->name), \"ep%d%s\",\n\t\t\t\t epnum, \"BiDir\");\n\n\t\t\tcdns2_init_ep0(pdev, pep);\n\n\t\t\tret = cdns2_alloc_tr_segment(pep);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(pdev->dev, \"Failed to init ep0\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(pep->name, sizeof(pep->name), \"ep%d%s\",\n\t\t\t\t epnum, !!direction ? \"in\" : \"out\");\n\t\t\tpep->endpoint.name = pep->name;\n\n\t\t\tusb_ep_set_maxpacket_limit(&pep->endpoint, 1024);\n\t\t\tpep->endpoint.ops = &cdns2_gadget_ep_ops;\n\t\t\tlist_add_tail(&pep->endpoint.ep_list, &pdev->gadget.ep_list);\n\n\t\t\tpep->endpoint.caps.dir_in = direction;\n\t\t\tpep->endpoint.caps.dir_out = !direction;\n\n\t\t\tpep->endpoint.caps.type_iso = 1;\n\t\t\tpep->endpoint.caps.type_bulk = 1;\n\t\t\tpep->endpoint.caps.type_int = 1;\n\t\t}\n\n\t\tpep->endpoint.name = pep->name;\n\t\tpep->ep_state = 0;\n\n\t\tdev_dbg(pdev->dev, \"Init %s, SupType: CTRL: %s, INT: %s, \"\n\t\t\t\"BULK: %s, ISOC %s, SupDir IN: %s, OUT: %s\\n\",\n\t\t\tpep->name,\n\t\t\t(pep->endpoint.caps.type_control) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_int) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_bulk) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_iso) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.dir_in) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.dir_out) ? \"yes\" : \"no\");\n\n\t\tINIT_LIST_HEAD(&pep->pending_list);\n\t\tINIT_LIST_HEAD(&pep->deferred_list);\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_start(struct cdns2_device *pdev)\n{\n\tu32 max_speed;\n\tvoid *buf;\n\tint val;\n\tint ret;\n\n\tpdev->usb_regs = pdev->regs;\n\tpdev->ep0_regs = pdev->regs;\n\tpdev->epx_regs = pdev->regs;\n\tpdev->interrupt_regs = pdev->regs;\n\tpdev->adma_regs = pdev->regs + CDNS2_ADMA_REGS_OFFSET;\n\n\t \n\tset_reg_bit_8(&pdev->usb_regs->cpuctrl, CPUCTRL_SW_RST);\n\n\tret = readl_poll_timeout_atomic(&pdev->usb_regs->cpuctrl, val,\n\t\t\t\t\t!(val & CPUCTRL_SW_RST), 1, 10000);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"Error: reset controller timeout\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tusb_initialize_gadget(pdev->dev, &pdev->gadget, NULL);\n\n\tdevice_property_read_u16(pdev->dev, \"cdns,on-chip-tx-buff-size\",\n\t\t\t\t &pdev->onchip_tx_buf);\n\tdevice_property_read_u16(pdev->dev, \"cdns,on-chip-rx-buff-size\",\n\t\t\t\t &pdev->onchip_rx_buf);\n\tdevice_property_read_u32(pdev->dev, \"cdns,avail-endpoints\",\n\t\t\t\t &pdev->eps_supported);\n\n\t \n\tif (!pdev->onchip_tx_buf && !pdev->onchip_rx_buf) {\n\t\tret = -EINVAL;\n\t\tdev_err(pdev->dev, \"Invalid on-chip memory configuration\\n\");\n\t\tgoto put_gadget;\n\t}\n\n\tif (!(pdev->eps_supported & ~0x00010001)) {\n\t\tret = -EINVAL;\n\t\tdev_err(pdev->dev, \"No hardware endpoints available\\n\");\n\t\tgoto put_gadget;\n\t}\n\n\tmax_speed = usb_get_maximum_speed(pdev->dev);\n\n\tswitch (max_speed) {\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdev->dev, \"invalid maximum_speed parameter %d\\n\",\n\t\t\tmax_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\tmax_speed = USB_SPEED_HIGH;\n\t\tbreak;\n\t}\n\n\tpdev->gadget.max_speed = max_speed;\n\tpdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tpdev->gadget.ops = &cdns2_gadget_ops;\n\tpdev->gadget.name = \"usbhs-gadget\";\n\tpdev->gadget.quirk_avoids_skb_reserve = 1;\n\tpdev->gadget.irq = pdev->irq;\n\n\tspin_lock_init(&pdev->lock);\n\tINIT_WORK(&pdev->pending_status_wq, cdns2_pending_setup_status_handler);\n\n\t \n\tINIT_LIST_HEAD(&pdev->gadget.ep_list);\n\tpdev->eps_dma_pool = dma_pool_create(\"cdns2_eps_dma_pool\", pdev->dev,\n\t\t\t\t\t     TR_SEG_SIZE, 8, 0);\n\tif (!pdev->eps_dma_pool) {\n\t\tdev_err(pdev->dev, \"Failed to create TRB dma pool\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto put_gadget;\n\t}\n\n\tret = cdns2_init_eps(pdev);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"Failed to create endpoints\\n\");\n\t\tgoto destroy_dma_pool;\n\t}\n\n\tpdev->gadget.sg_supported = 1;\n\n\tpdev->zlp_buf = kzalloc(CDNS2_EP_ZLP_BUF_SIZE, GFP_KERNEL);\n\tif (!pdev->zlp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto destroy_dma_pool;\n\t}\n\n\t \n\tbuf = dma_alloc_coherent(pdev->dev, 8, &pdev->ep0_preq.request.dma,\n\t\t\t\t GFP_DMA);\n\tpdev->ep0_preq.request.buf = buf;\n\n\tif (!pdev->ep0_preq.request.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto free_zlp_buf;\n\t}\n\n\t \n\tret = usb_add_gadget(&pdev->gadget);\n\tif (ret < 0) {\n\t\tdev_err(pdev->dev, \"Failed to add gadget\\n\");\n\t\tgoto free_ep0_buf;\n\t}\n\n\treturn 0;\n\nfree_ep0_buf:\n\tdma_free_coherent(pdev->dev, 8, pdev->ep0_preq.request.buf,\n\t\t\t  pdev->ep0_preq.request.dma);\nfree_zlp_buf:\n\tkfree(pdev->zlp_buf);\ndestroy_dma_pool:\n\tdma_pool_destroy(pdev->eps_dma_pool);\nput_gadget:\n\tusb_put_gadget(&pdev->gadget);\n\n\treturn ret;\n}\n\nint cdns2_gadget_suspend(struct cdns2_device *pdev)\n{\n\tunsigned long flags;\n\n\tcdns2_disconnect_gadget(pdev);\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tpdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\ttrace_cdns2_device_state(\"notattached\");\n\tusb_gadget_set_state(&pdev->gadget, USB_STATE_NOTATTACHED);\n\tcdns2_enable_l1(pdev, 0);\n\n\t \n\twriteb(0, &pdev->interrupt_regs->usbien);\n\twritel(0, &pdev->adma_regs->ep_ien);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nint cdns2_gadget_resume(struct cdns2_device *pdev, bool hibernated)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tif (!pdev->gadget_driver) {\n\t\tspin_unlock_irqrestore(&pdev->lock, flags);\n\t\treturn 0;\n\t}\n\n\tcdns2_gadget_config(pdev);\n\n\tif (hibernated)\n\t\tclear_reg_bit_8(&pdev->usb_regs->usbcs, USBCS_DISCON);\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nvoid cdns2_gadget_remove(struct cdns2_device *pdev)\n{\n\tpm_runtime_mark_last_busy(pdev->dev);\n\tpm_runtime_put_autosuspend(pdev->dev);\n\n\tusb_del_gadget(&pdev->gadget);\n\tcdns2_free_all_eps(pdev);\n\n\tdma_pool_destroy(pdev->eps_dma_pool);\n\tkfree(pdev->zlp_buf);\n\tusb_put_gadget(&pdev->gadget);\n}\n\nint cdns2_gadget_init(struct cdns2_device *pdev)\n{\n\tint ret;\n\n\t \n\tret = dma_set_mask_and_coherent(pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"Failed to set dma mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_get_sync(pdev->dev);\n\n\tcdsn2_isoc_burst_opt(pdev);\n\n\tret = cdns2_gadget_start(pdev);\n\tif (ret) {\n\t\tpm_runtime_put_sync(pdev->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(pdev->dev, pdev->irq,\n\t\t\t\t\tcdns2_usb_irq_handler,\n\t\t\t\t\tcdns2_thread_irq_handler,\n\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\tdev_name(pdev->dev),\n\t\t\t\t\tpdev);\n\tif (ret)\n\t\tgoto err0;\n\n\treturn 0;\n\nerr0:\n\tcdns2_gadget_remove(pdev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}