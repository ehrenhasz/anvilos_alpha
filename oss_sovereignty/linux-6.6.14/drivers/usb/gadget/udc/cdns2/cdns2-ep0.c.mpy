{
  "module_name": "cdns2-ep0.c",
  "hash_id": "b7a67c3c4a6e91515d98cbc5c2823ac0fa15e0b6d2b00f07aeced35684e51d2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/cdns2/cdns2-ep0.c",
  "human_readable_source": "\n \n\n#include <linux/usb/composite.h>\n#include <asm/unaligned.h>\n\n#include \"cdns2-gadget.h\"\n#include \"cdns2-trace.h\"\n\nstatic struct usb_endpoint_descriptor cdns2_gadget_ep0_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes =\t USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize = cpu_to_le16(64)\n};\n\nstatic int cdns2_w_index_to_ep_index(u16 wIndex)\n{\n\tif (!(wIndex & USB_ENDPOINT_NUMBER_MASK))\n\t\treturn 0;\n\n\treturn ((wIndex & USB_ENDPOINT_NUMBER_MASK) * 2) +\n\t\t(wIndex & USB_ENDPOINT_DIR_MASK ? 1 : 0) - 1;\n}\n\nstatic bool cdns2_check_new_setup(struct cdns2_device *pdev)\n{\n\tu8 reg;\n\n\treg = readb(&pdev->ep0_regs->cs);\n\n\treturn !!(reg & EP0CS_CHGSET);\n}\n\nstatic void cdns2_ep0_enqueue(struct cdns2_device *pdev, dma_addr_t dma_addr,\n\t\t\t      unsigned int length, int zlp)\n{\n\tstruct cdns2_adma_regs __iomem *regs = pdev->adma_regs;\n\tstruct cdns2_endpoint *pep = &pdev->eps[0];\n\tstruct cdns2_ring *ring = &pep->ring;\n\n\tring->trbs[0].buffer = cpu_to_le32(TRB_BUFFER(dma_addr));\n\tring->trbs[0].length = cpu_to_le32(TRB_LEN(length));\n\n\tif (zlp) {\n\t\tring->trbs[0].control = cpu_to_le32(TRB_CYCLE |\n\t\t\t\t\t\t    TRB_TYPE(TRB_NORMAL));\n\t\tring->trbs[1].buffer = cpu_to_le32(TRB_BUFFER(dma_addr));\n\t\tring->trbs[1].length = cpu_to_le32(TRB_LEN(0));\n\t\tring->trbs[1].control = cpu_to_le32(TRB_CYCLE | TRB_IOC |\n\t\t\t\t\tTRB_TYPE(TRB_NORMAL));\n\t} else {\n\t\tring->trbs[0].control = cpu_to_le32(TRB_CYCLE | TRB_IOC |\n\t\t\t\t\tTRB_TYPE(TRB_NORMAL));\n\t\tring->trbs[1].control = 0;\n\t}\n\n\ttrace_cdns2_queue_trb(pep, ring->trbs);\n\n\tif (!pep->dir)\n\t\twritel(0, &pdev->ep0_regs->rxbc);\n\n\tcdns2_select_ep(pdev, pep->dir);\n\n\twritel(DMA_EP_STS_TRBERR, &regs->ep_sts);\n\twritel(pep->ring.dma, &regs->ep_traddr);\n\n\ttrace_cdns2_doorbell_ep0(pep, readl(&regs->ep_traddr));\n\n\twritel(DMA_EP_CMD_DRDY, &regs->ep_cmd);\n}\n\nstatic int cdns2_ep0_delegate_req(struct cdns2_device *pdev)\n{\n\tint ret;\n\n\tspin_unlock(&pdev->lock);\n\tret = pdev->gadget_driver->setup(&pdev->gadget, &pdev->setup);\n\tspin_lock(&pdev->lock);\n\n\treturn ret;\n}\n\nstatic void cdns2_ep0_stall(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep = &pdev->eps[0];\n\tstruct cdns2_request *preq;\n\n\tpreq = cdns2_next_preq(&pep->pending_list);\n\tset_reg_bit_8(&pdev->ep0_regs->cs, EP0CS_DSTALL);\n\n\tif (pdev->ep0_stage == CDNS2_DATA_STAGE && preq)\n\t\tcdns2_gadget_giveback(pep, preq, -ECONNRESET);\n\telse if (preq)\n\t\tlist_del_init(&preq->list);\n\n\tpdev->ep0_stage = CDNS2_SETUP_STAGE;\n\tpep->ep_state |= EP_STALLED;\n}\n\nstatic void cdns2_status_stage(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep = &pdev->eps[0];\n\tstruct cdns2_request *preq;\n\n\tpreq = cdns2_next_preq(&pep->pending_list);\n\tif (preq)\n\t\tlist_del_init(&preq->list);\n\n\tpdev->ep0_stage = CDNS2_SETUP_STAGE;\n\twriteb(EP0CS_HSNAK, &pdev->ep0_regs->cs);\n}\n\nstatic int cdns2_req_ep0_set_configuration(struct cdns2_device *pdev,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl_req)\n{\n\tenum usb_device_state state = pdev->gadget.state;\n\tu32 config = le16_to_cpu(ctrl_req->wValue);\n\tint ret;\n\n\tif (state < USB_STATE_ADDRESS) {\n\t\tdev_err(pdev->dev, \"Set Configuration - bad device state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = cdns2_ep0_delegate_req(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\ttrace_cdns2_device_state(config ? \"configured\" : \"addressed\");\n\n\tif (!config)\n\t\tusb_gadget_set_state(&pdev->gadget, USB_STATE_ADDRESS);\n\n\treturn 0;\n}\n\nstatic int cdns2_req_ep0_set_address(struct cdns2_device *pdev, u32 addr)\n{\n\tenum usb_device_state device_state = pdev->gadget.state;\n\tu8 reg;\n\n\tif (addr > USB_DEVICE_MAX_ADDRESS) {\n\t\tdev_err(pdev->dev,\n\t\t\t\"Device address (%d) cannot be greater than %d\\n\",\n\t\t\taddr, USB_DEVICE_MAX_ADDRESS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_state == USB_STATE_CONFIGURED) {\n\t\tdev_err(pdev->dev,\n\t\t\t\"can't set_address from configured state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = readb(&pdev->usb_regs->fnaddr);\n\tpdev->dev_address = reg;\n\n\tusb_gadget_set_state(&pdev->gadget,\n\t\t\t     (addr ? USB_STATE_ADDRESS : USB_STATE_DEFAULT));\n\n\ttrace_cdns2_device_state(addr ? \"addressed\" : \"default\");\n\n\treturn 0;\n}\n\nstatic int cdns2_req_ep0_handle_status(struct cdns2_device *pdev,\n\t\t\t\t       struct usb_ctrlrequest *ctrl)\n{\n\tstruct cdns2_endpoint *pep;\n\t__le16 *response_pkt;\n\tu16 status = 0;\n\tint ep_sts;\n\tu32 recip;\n\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = pdev->gadget.is_selfpowered;\n\t\tstatus |= pdev->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\treturn cdns2_ep0_delegate_req(pdev);\n\tcase USB_RECIP_ENDPOINT:\n\t\tep_sts = cdns2_w_index_to_ep_index(le16_to_cpu(ctrl->wIndex));\n\t\tpep = &pdev->eps[ep_sts];\n\n\t\tif (pep->ep_state & EP_STALLED)\n\t\t\tstatus =  BIT(USB_ENDPOINT_HALT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tput_unaligned_le16(status, (__le16 *)pdev->ep0_preq.request.buf);\n\n\tcdns2_ep0_enqueue(pdev, pdev->ep0_preq.request.dma,\n\t\t\t  sizeof(*response_pkt), 0);\n\n\treturn 0;\n}\n\nstatic int cdns2_ep0_handle_feature_device(struct cdns2_device *pdev,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t   int set)\n{\n\tenum usb_device_state state;\n\tenum usb_device_speed speed;\n\tint ret = 0;\n\tu32 wValue;\n\tu16 tmode;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\tstate = pdev->gadget.state;\n\tspeed = pdev->gadget.speed;\n\n\tswitch (wValue) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tpdev->may_wakeup = !!set;\n\t\tbreak;\n\tcase USB_DEVICE_TEST_MODE:\n\t\tif (state != USB_STATE_CONFIGURED || speed > USB_SPEED_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\ttmode = le16_to_cpu(ctrl->wIndex);\n\n\t\tif (!set || (tmode & 0xff) != 0)\n\t\t\treturn -EINVAL;\n\n\t\ttmode >>= 8;\n\t\tswitch (tmode) {\n\t\tcase USB_TEST_J:\n\t\tcase USB_TEST_K:\n\t\tcase USB_TEST_SE0_NAK:\n\t\tcase USB_TEST_PACKET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns2_ep0_handle_feature_intf(struct cdns2_device *pdev,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t int set)\n{\n\tint ret = 0;\n\tu32 wValue;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\n\tswitch (wValue) {\n\tcase USB_INTRF_FUNC_SUSPEND:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns2_ep0_handle_feature_endpoint(struct cdns2_device *pdev,\n\t\t\t\t\t     struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t     int set)\n{\n\tstruct cdns2_endpoint *pep;\n\tu8 wValue;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\tpep = &pdev->eps[cdns2_w_index_to_ep_index(le16_to_cpu(ctrl->wIndex))];\n\n\tif (wValue != USB_ENDPOINT_HALT)\n\t\treturn -EINVAL;\n\n\tif (!(le16_to_cpu(ctrl->wIndex) & ~USB_DIR_IN))\n\t\treturn 0;\n\n\tswitch (wValue) {\n\tcase USB_ENDPOINT_HALT:\n\t\tif (set || !(pep->ep_state & EP_WEDGE))\n\t\t\treturn cdns2_halt_endpoint(pdev, pep, set);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(pdev->dev, \"WARN Incorrect wValue %04x\\n\", wValue);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns2_req_ep0_handle_feature(struct cdns2_device *pdev,\n\t\t\t\t\tstruct usb_ctrlrequest *ctrl,\n\t\t\t\t\tint set)\n{\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\treturn cdns2_ep0_handle_feature_device(pdev, ctrl, set);\n\tcase USB_RECIP_INTERFACE:\n\t\treturn cdns2_ep0_handle_feature_intf(pdev, ctrl, set);\n\tcase USB_RECIP_ENDPOINT:\n\t\treturn cdns2_ep0_handle_feature_endpoint(pdev, ctrl, set);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cdns2_ep0_std_request(struct cdns2_device *pdev)\n{\n\tstruct usb_ctrlrequest *ctrl = &pdev->setup;\n\tint ret;\n\n\tswitch (ctrl->bRequest) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\tret = cdns2_req_ep0_set_address(pdev,\n\t\t\t\t\t\tle16_to_cpu(ctrl->wValue));\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tret = cdns2_req_ep0_set_configuration(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tret = cdns2_req_ep0_handle_status(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tret = cdns2_req_ep0_handle_feature(pdev, ctrl, 0);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tret = cdns2_req_ep0_handle_feature(pdev, ctrl, 1);\n\t\tbreak;\n\tdefault:\n\t\tret = cdns2_ep0_delegate_req(pdev);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void __pending_setup_status_handler(struct cdns2_device *pdev)\n{\n\tstruct usb_request *request = pdev->pending_status_request;\n\n\tif (pdev->status_completion_no_call && request && request->complete) {\n\t\trequest->complete(&pdev->eps[0].endpoint, request);\n\t\tpdev->status_completion_no_call = 0;\n\t}\n}\n\nvoid cdns2_pending_setup_status_handler(struct work_struct *work)\n{\n\tstruct cdns2_device *pdev = container_of(work, struct cdns2_device,\n\t\t\t\t\t\t pending_status_wq);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\t__pending_setup_status_handler(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n}\n\nvoid cdns2_handle_setup_packet(struct cdns2_device *pdev)\n{\n\tstruct usb_ctrlrequest *ctrl = &pdev->setup;\n\tstruct cdns2_endpoint *pep = &pdev->eps[0];\n\tstruct cdns2_request *preq;\n\tint ret = 0;\n\tu16 len;\n\tu8 reg;\n\tint i;\n\n\twriteb(EP0CS_CHGSET, &pdev->ep0_regs->cs);\n\n\tfor (i = 0; i < 8; i++)\n\t\t((u8 *)&pdev->setup)[i] = readb(&pdev->ep0_regs->setupdat[i]);\n\n\t \n\tif (cdns2_check_new_setup(pdev)) {\n\t\ttrace_cdns2_ep0_setup(\"overridden\");\n\t\treturn;\n\t}\n\n\ttrace_cdns2_ctrl_req(ctrl);\n\n\tif (!pdev->gadget_driver)\n\t\tgoto out;\n\n\tif (pdev->gadget.state == USB_STATE_NOTATTACHED) {\n\t\tdev_err(pdev->dev, \"ERR: Setup detected in unattached state\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpep = &pdev->eps[0];\n\n\t \n\tpep->ep_state &= ~EP_STALLED;\n\n\tif (!list_empty(&pep->pending_list)) {\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\t\tcdns2_gadget_giveback(pep, preq, -ECONNRESET);\n\t}\n\n\tlen = le16_to_cpu(ctrl->wLength);\n\tif (len)\n\t\tpdev->ep0_stage = CDNS2_DATA_STAGE;\n\telse\n\t\tpdev->ep0_stage = CDNS2_STATUS_STAGE;\n\n\tpep->dir = ctrl->bRequestType & USB_DIR_IN;\n\n\t \n\treg = readb(&pdev->usb_regs->fnaddr);\n\tif (pdev->setup.bRequest != USB_REQ_SET_ADDRESS &&\n\t    pdev->dev_address != reg)\n\t\tcdns2_req_ep0_set_address(pdev, reg);\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tret = cdns2_ep0_std_request(pdev);\n\telse\n\t\tret = cdns2_ep0_delegate_req(pdev);\n\n\tif (ret == USB_GADGET_DELAYED_STATUS) {\n\t\ttrace_cdns2_ep0_status_stage(\"delayed\");\n\t\treturn;\n\t}\n\nout:\n\tif (ret < 0)\n\t\tcdns2_ep0_stall(pdev);\n\telse if (pdev->ep0_stage == CDNS2_STATUS_STAGE)\n\t\tcdns2_status_stage(pdev);\n}\n\nstatic void cdns2_transfer_completed(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep = &pdev->eps[0];\n\n\tif (!list_empty(&pep->pending_list)) {\n\t\tstruct cdns2_request *preq;\n\n\t\ttrace_cdns2_complete_trb(pep, pep->ring.trbs);\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\n\t\tpreq->request.actual =\n\t\t\tTRB_LEN(le32_to_cpu(pep->ring.trbs->length));\n\t\tcdns2_gadget_giveback(pep, preq, 0);\n\t}\n\n\tcdns2_status_stage(pdev);\n}\n\nvoid cdns2_handle_ep0_interrupt(struct cdns2_device *pdev, int dir)\n{\n\tu32 ep_sts_reg;\n\n\tcdns2_select_ep(pdev, dir);\n\n\ttrace_cdns2_ep0_irq(pdev);\n\n\tep_sts_reg = readl(&pdev->adma_regs->ep_sts);\n\twritel(ep_sts_reg, &pdev->adma_regs->ep_sts);\n\n\t__pending_setup_status_handler(pdev);\n\n\tif ((ep_sts_reg & DMA_EP_STS_IOC) || (ep_sts_reg & DMA_EP_STS_ISP)) {\n\t\tpdev->eps[0].dir = dir;\n\t\tcdns2_transfer_completed(pdev);\n\t}\n}\n\n \nstatic int cdns2_gadget_ep0_enable(struct usb_ep *ep,\n\t\t\t\t   const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int cdns2_gadget_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\nstatic int cdns2_gadget_ep0_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct cdns2_endpoint *pep = ep_to_cdns2_ep(ep);\n\tstruct cdns2_device *pdev = pep->pdev;\n\tunsigned long flags;\n\n\tif (!value)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tcdns2_ep0_stall(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdns2_gadget_ep0_set_wedge(struct usb_ep *ep)\n{\n\treturn cdns2_gadget_ep0_set_halt(ep, 1);\n}\n\nstatic int cdns2_gadget_ep0_queue(struct usb_ep *ep,\n\t\t\t\t  struct usb_request *request,\n\t\t\t\t  gfp_t gfp_flags)\n{\n\tstruct cdns2_endpoint *pep = ep_to_cdns2_ep(ep);\n\tstruct cdns2_device *pdev = pep->pdev;\n\tstruct cdns2_request *preq;\n\tunsigned long flags;\n\tu8 zlp = 0;\n\tint ret;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tpreq = to_cdns2_request(request);\n\n\ttrace_cdns2_request_enqueue(preq);\n\n\t \n\tif (cdns2_check_new_setup(pdev)) {\n\t\ttrace_cdns2_ep0_setup(\"overridden\");\n\t\tspin_unlock_irqrestore(&pdev->lock, flags);\n\t\treturn -ECONNRESET;\n\t}\n\n\t \n\tif (pdev->ep0_stage == CDNS2_STATUS_STAGE) {\n\t\tcdns2_status_stage(pdev);\n\n\t\trequest->actual = 0;\n\t\tpdev->status_completion_no_call = true;\n\t\tpdev->pending_status_request = request;\n\t\tusb_gadget_set_state(&pdev->gadget, USB_STATE_CONFIGURED);\n\t\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\t\t \n\t\tqueue_work(system_freezable_wq, &pdev->pending_status_wq);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&pep->pending_list)) {\n\t\ttrace_cdns2_ep0_setup(\"pending\");\n\t\tdev_err(pdev->dev,\n\t\t\t\"can't handle multiple requests for ep0\\n\");\n\t\tspin_unlock_irqrestore(&pdev->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tret = usb_gadget_map_request_by_dev(pdev->dev, request, pep->dir);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&pdev->lock, flags);\n\t\tdev_err(pdev->dev, \"failed to map request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trequest->status = -EINPROGRESS;\n\tlist_add_tail(&preq->list, &pep->pending_list);\n\n\tif (request->zero && request->length &&\n\t    (request->length % ep->maxpacket == 0))\n\t\tzlp = 1;\n\n\tcdns2_ep0_enqueue(pdev, request->dma, request->length, zlp);\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops cdns2_gadget_ep0_ops = {\n\t.enable = cdns2_gadget_ep0_enable,\n\t.disable = cdns2_gadget_ep0_disable,\n\t.alloc_request = cdns2_gadget_ep_alloc_request,\n\t.free_request = cdns2_gadget_ep_free_request,\n\t.queue = cdns2_gadget_ep0_queue,\n\t.dequeue = cdns2_gadget_ep_dequeue,\n\t.set_halt = cdns2_gadget_ep0_set_halt,\n\t.set_wedge = cdns2_gadget_ep0_set_wedge,\n};\n\nvoid cdns2_ep0_config(struct cdns2_device *pdev)\n{\n\tstruct cdns2_endpoint *pep;\n\n\tpep = &pdev->eps[0];\n\n\tif (!list_empty(&pep->pending_list)) {\n\t\tstruct cdns2_request *preq;\n\n\t\tpreq = cdns2_next_preq(&pep->pending_list);\n\t\tlist_del_init(&preq->list);\n\t}\n\n\twriteb(EP0_FIFO_AUTO, &pdev->ep0_regs->fifo);\n\tcdns2_select_ep(pdev, USB_DIR_OUT);\n\twritel(DMA_EP_CFG_ENABLE, &pdev->adma_regs->ep_cfg);\n\n\twriteb(EP0_FIFO_IO_TX | EP0_FIFO_AUTO, &pdev->ep0_regs->fifo);\n\tcdns2_select_ep(pdev, USB_DIR_IN);\n\twritel(DMA_EP_CFG_ENABLE, &pdev->adma_regs->ep_cfg);\n\n\twriteb(pdev->gadget.ep0->maxpacket, &pdev->ep0_regs->maxpack);\n\twritel(DMA_EP_IEN_EP_OUT0 | DMA_EP_IEN_EP_IN0,\n\t       &pdev->adma_regs->ep_ien);\n}\n\nvoid cdns2_init_ep0(struct cdns2_device *pdev,\n\t\t    struct cdns2_endpoint *pep)\n{\n\tu16 maxpacket = le16_to_cpu(cdns2_gadget_ep0_desc.wMaxPacketSize);\n\n\tusb_ep_set_maxpacket_limit(&pep->endpoint, maxpacket);\n\n\tpep->endpoint.ops = &cdns2_gadget_ep0_ops;\n\tpep->endpoint.desc = &cdns2_gadget_ep0_desc;\n\tpep->endpoint.caps.type_control = true;\n\tpep->endpoint.caps.dir_in = true;\n\tpep->endpoint.caps.dir_out = true;\n\n\tpdev->gadget.ep0 = &pep->endpoint;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}