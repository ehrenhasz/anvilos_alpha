{
  "module_name": "trace.h",
  "hash_id": "5412e8df7008209e95d256a72b5eb8e479a4720c043318bb0d41f6a700d1dbb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/trace.h",
  "human_readable_source": "\n \n\n#undef TRACE_SYSTEM\n#define TRACE_SYSTEM gadget\n\n#if !defined(__UDC_TRACE_H) || defined(TRACE_HEADER_MULTI_READ)\n#define __UDC_TRACE_H\n\n#include <linux/types.h>\n#include <linux/tracepoint.h>\n#include <asm/byteorder.h>\n#include <linux/usb/gadget.h>\n\nDECLARE_EVENT_CLASS(udc_log_gadget,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret),\n\tTP_STRUCT__entry(\n\t\t__field(enum usb_device_speed, speed)\n\t\t__field(enum usb_device_speed, max_speed)\n\t\t__field(enum usb_device_state, state)\n\t\t__field(unsigned, mA)\n\t\t__field(unsigned, sg_supported)\n\t\t__field(unsigned, is_otg)\n\t\t__field(unsigned, is_a_peripheral)\n\t\t__field(unsigned, b_hnp_enable)\n\t\t__field(unsigned, a_hnp_support)\n\t\t__field(unsigned, hnp_polling_support)\n\t\t__field(unsigned, host_request_flag)\n\t\t__field(unsigned, quirk_ep_out_aligned_size)\n\t\t__field(unsigned, quirk_altset_not_supp)\n\t\t__field(unsigned, quirk_stall_not_supp)\n\t\t__field(unsigned, quirk_zlp_not_supp)\n\t\t__field(unsigned, is_selfpowered)\n\t\t__field(unsigned, deactivated)\n\t\t__field(unsigned, connected)\n\t\t__field(int, ret)\n\t),\n\tTP_fast_assign(\n\t\t__entry->speed = g->speed;\n\t\t__entry->max_speed = g->max_speed;\n\t\t__entry->state = g->state;\n\t\t__entry->mA = g->mA;\n\t\t__entry->sg_supported = g->sg_supported;\n\t\t__entry->is_otg = g->is_otg;\n\t\t__entry->is_a_peripheral = g->is_a_peripheral;\n\t\t__entry->b_hnp_enable = g->b_hnp_enable;\n\t\t__entry->a_hnp_support = g->a_hnp_support;\n\t\t__entry->hnp_polling_support = g->hnp_polling_support;\n\t\t__entry->host_request_flag = g->host_request_flag;\n\t\t__entry->quirk_ep_out_aligned_size = g->quirk_ep_out_aligned_size;\n\t\t__entry->quirk_altset_not_supp = g->quirk_altset_not_supp;\n\t\t__entry->quirk_stall_not_supp = g->quirk_stall_not_supp;\n\t\t__entry->quirk_zlp_not_supp = g->quirk_zlp_not_supp;\n\t\t__entry->is_selfpowered = g->is_selfpowered;\n\t\t__entry->deactivated = g->deactivated;\n\t\t__entry->connected = g->connected;\n\t\t__entry->ret = ret;\n\t),\n\tTP_printk(\"speed %d/%d state %d %dmA [%s%s%s%s%s%s%s%s%s%s%s%s%s%s] --> %d\",\n\t\t__entry->speed, __entry->max_speed, __entry->state, __entry->mA,\n\t\t__entry->sg_supported ? \"sg:\" : \"\",\n\t\t__entry->is_otg ? \"OTG:\" : \"\",\n\t\t__entry->is_a_peripheral ? \"a_peripheral:\" : \"\",\n\t\t__entry->b_hnp_enable ? \"b_hnp:\" : \"\",\n\t\t__entry->a_hnp_support ? \"a_hnp:\" : \"\",\n\t\t__entry->hnp_polling_support ? \"hnp_poll:\" : \"\",\n\t\t__entry->host_request_flag ? \"hostreq:\" : \"\",\n\t\t__entry->quirk_ep_out_aligned_size ? \"out_aligned:\" : \"\",\n\t\t__entry->quirk_altset_not_supp ? \"no_altset:\" : \"\",\n\t\t__entry->quirk_stall_not_supp ? \"no_stall:\" : \"\",\n\t\t__entry->quirk_zlp_not_supp ? \"no_zlp\" : \"\",\n\t\t__entry->is_selfpowered ? \"self-powered:\" : \"bus-powered:\",\n\t\t__entry->deactivated ? \"deactivated:\" : \"activated:\",\n\t\t__entry->connected ? \"connected\" : \"disconnected\",\n\t\t__entry->ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_frame_number,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_wakeup,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_set_remote_wakeup,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_set_selfpowered,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_clear_selfpowered,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_vbus_connect,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_vbus_draw,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_vbus_disconnect,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_connect,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_disconnect,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_deactivate,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDEFINE_EVENT(udc_log_gadget, usb_gadget_activate,\n\tTP_PROTO(struct usb_gadget *g, int ret),\n\tTP_ARGS(g, ret)\n);\n\nDECLARE_EVENT_CLASS(udc_log_ep,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret),\n\tTP_STRUCT__entry(\n\t\t__string(name, ep->name)\n\t\t__field(unsigned, maxpacket)\n\t\t__field(unsigned, maxpacket_limit)\n\t\t__field(unsigned, max_streams)\n\t\t__field(unsigned, mult)\n\t\t__field(unsigned, maxburst)\n\t\t__field(u8, address)\n\t\t__field(bool, claimed)\n\t\t__field(bool, enabled)\n\t\t__field(int, ret)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(name, ep->name);\n\t\t__entry->maxpacket = ep->maxpacket;\n\t\t__entry->maxpacket_limit = ep->maxpacket_limit;\n\t\t__entry->max_streams = ep->max_streams;\n\t\t__entry->mult = ep->mult;\n\t\t__entry->maxburst = ep->maxburst;\n\t\t__entry->address = ep->address,\n\t\t__entry->claimed = ep->claimed;\n\t\t__entry->enabled = ep->enabled;\n\t\t__entry->ret = ret;\n\t),\n\tTP_printk(\"%s: mps %d/%d streams %d mult %d burst %d addr %02x %s%s --> %d\",\n\t\t__get_str(name), __entry->maxpacket, __entry->maxpacket_limit,\n\t\t__entry->max_streams, __entry->mult, __entry->maxburst,\n\t\t__entry->address, __entry->claimed ? \"claimed:\" : \"released:\",\n\t\t__entry->enabled ? \"enabled\" : \"disabled\", ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_set_maxpacket_limit,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_enable,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_disable,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_set_halt,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_clear_halt,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_set_wedge,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_fifo_status,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDEFINE_EVENT(udc_log_ep, usb_ep_fifo_flush,\n\tTP_PROTO(struct usb_ep *ep, int ret),\n\tTP_ARGS(ep, ret)\n);\n\nDECLARE_EVENT_CLASS(udc_log_req,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret),\n\tTP_STRUCT__entry(\n\t\t__string(name, ep->name)\n\t\t__field(unsigned, length)\n\t\t__field(unsigned, actual)\n\t\t__field(unsigned, num_sgs)\n\t\t__field(unsigned, num_mapped_sgs)\n\t\t__field(unsigned, stream_id)\n\t\t__field(unsigned, no_interrupt)\n\t\t__field(unsigned, zero)\n\t\t__field(unsigned, short_not_ok)\n\t\t__field(int, status)\n\t\t__field(int, ret)\n\t\t__field(struct usb_request *, req)\n\t),\n\tTP_fast_assign(\n\t\t__assign_str(name, ep->name);\n\t\t__entry->length = req->length;\n\t\t__entry->actual = req->actual;\n\t\t__entry->num_sgs = req->num_sgs;\n\t\t__entry->num_mapped_sgs = req->num_mapped_sgs;\n\t\t__entry->stream_id = req->stream_id;\n\t\t__entry->no_interrupt = req->no_interrupt;\n\t\t__entry->zero = req->zero;\n\t\t__entry->short_not_ok = req->short_not_ok;\n\t\t__entry->status = req->status;\n\t\t__entry->ret = ret;\n\t\t__entry->req = req;\n\t),\n\tTP_printk(\"%s: req %p length %d/%d sgs %d/%d stream %d %s%s%s status %d --> %d\",\n\t\t__get_str(name),__entry->req,  __entry->actual, __entry->length,\n\t\t__entry->num_mapped_sgs, __entry->num_sgs, __entry->stream_id,\n\t\t__entry->zero ? \"Z\" : \"z\",\n\t\t__entry->short_not_ok ? \"S\" : \"s\",\n\t\t__entry->no_interrupt ? \"i\" : \"I\",\n\t\t__entry->status, __entry->ret\n\t)\n);\n\nDEFINE_EVENT(udc_log_req, usb_ep_alloc_request,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret)\n);\n\nDEFINE_EVENT(udc_log_req, usb_ep_free_request,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret)\n);\n\nDEFINE_EVENT(udc_log_req, usb_ep_queue,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret)\n);\n\nDEFINE_EVENT(udc_log_req, usb_ep_dequeue,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret)\n);\n\nDEFINE_EVENT(udc_log_req, usb_gadget_giveback_request,\n\tTP_PROTO(struct usb_ep *ep, struct usb_request *req, int ret),\n\tTP_ARGS(ep, req, ret)\n);\n\n#endif  \n\n \n\n#undef TRACE_INCLUDE_PATH\n#define TRACE_INCLUDE_PATH .\n\n#undef TRACE_INCLUDE_FILE\n#define TRACE_INCLUDE_FILE trace\n\n#include <trace/define_trace.h>\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}