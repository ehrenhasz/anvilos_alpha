{
  "module_name": "snps_udc_core.c",
  "hash_id": "956bde8160a5807e06b735536cfc8d1ba834e5cb88e125c7b060bfcfc7b1d698",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/snps_udc_core.c",
  "human_readable_source": "\n \n\n \n\n \n#define UDC_MOD_DESCRIPTION\t\t\"Synopsys USB Device Controller\"\n#define UDC_DRIVER_VERSION_STRING\t\"01.00.0206\"\n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/ioctl.h>\n#include <linux/fs.h>\n#include <linux/dmapool.h>\n#include <linux/prefetch.h>\n#include <linux/moduleparam.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include \"amd5536udc.h\"\n\nstatic void udc_setup_endpoints(struct udc *dev);\nstatic void udc_soft_reset(struct udc *dev);\nstatic struct udc_request *udc_alloc_bna_dummy(struct udc_ep *ep);\nstatic void udc_free_request(struct usb_ep *usbep, struct usb_request *usbreq);\n\n \nstatic const char mod_desc[] = UDC_MOD_DESCRIPTION;\nstatic const char name[] = \"udc\";\n\n \nstatic const struct usb_ep_ops udc_ep_ops;\n\n \nstatic union udc_setup_data setup_data;\n\n \nstatic struct udc *udc;\n\n \nstatic DEFINE_SPINLOCK(udc_irq_spinlock);\n \nstatic DEFINE_SPINLOCK(udc_stall_spinlock);\n\n \nstatic unsigned int udc_rxfifo_pending;\n\n \nstatic int soft_reset_occured;\nstatic int soft_reset_after_usbreset_occured;\n\n \nstatic struct timer_list udc_timer;\nstatic int stop_timer;\n\n \nstatic int set_rde = -1;\n\nstatic DECLARE_COMPLETION(on_exit);\nstatic struct timer_list udc_pollstall_timer;\nstatic int stop_pollstall_timer;\nstatic DECLARE_COMPLETION(on_pollstall_exit);\n\n \nstatic const char ep0_string[] = \"ep0in\";\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} ep_info[] = {\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\n\tEP_INFO(ep0_string,\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep1in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep2in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep3in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep4in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep5in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep6in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep7in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep8in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep9in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep10in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep11in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep12in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep13in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep14in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep15in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep0out\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep1out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep2out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep3out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep4out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep5out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep6out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep7out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep8out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep9out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep10out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep11out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep12out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep13out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep14out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep15out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\n#undef EP_INFO\n};\n\n \nstatic int use_dma_bufferfill_mode;\n \nstatic unsigned long hs_tx_buf = UDC_EPIN_BUFF_SIZE;\n\n \n \nstatic void print_regs(struct udc *dev)\n{\n\tDBG(dev, \"------- Device registers -------\\n\");\n\tDBG(dev, \"dev config     = %08x\\n\", readl(&dev->regs->cfg));\n\tDBG(dev, \"dev control    = %08x\\n\", readl(&dev->regs->ctl));\n\tDBG(dev, \"dev status     = %08x\\n\", readl(&dev->regs->sts));\n\tDBG(dev, \"\\n\");\n\tDBG(dev, \"dev int's      = %08x\\n\", readl(&dev->regs->irqsts));\n\tDBG(dev, \"dev intmask    = %08x\\n\", readl(&dev->regs->irqmsk));\n\tDBG(dev, \"\\n\");\n\tDBG(dev, \"dev ep int's   = %08x\\n\", readl(&dev->regs->ep_irqsts));\n\tDBG(dev, \"dev ep intmask = %08x\\n\", readl(&dev->regs->ep_irqmsk));\n\tDBG(dev, \"\\n\");\n\tDBG(dev, \"USE DMA        = %d\\n\", use_dma);\n\tif (use_dma && use_dma_ppb && !use_dma_ppb_du) {\n\t\tDBG(dev, \"DMA mode       = PPBNDU (packet per buffer \"\n\t\t\t\"WITHOUT desc. update)\\n\");\n\t\tdev_info(dev->dev, \"DMA mode (%s)\\n\", \"PPBNDU\");\n\t} else if (use_dma && use_dma_ppb && use_dma_ppb_du) {\n\t\tDBG(dev, \"DMA mode       = PPBDU (packet per buffer \"\n\t\t\t\"WITH desc. update)\\n\");\n\t\tdev_info(dev->dev, \"DMA mode (%s)\\n\", \"PPBDU\");\n\t}\n\tif (use_dma && use_dma_bufferfill_mode) {\n\t\tDBG(dev, \"DMA mode       = BF (buffer fill mode)\\n\");\n\t\tdev_info(dev->dev, \"DMA mode (%s)\\n\", \"BF\");\n\t}\n\tif (!use_dma)\n\t\tdev_info(dev->dev, \"FIFO mode\\n\");\n\tDBG(dev, \"-------------------------------------------------------\\n\");\n}\n\n \nint udc_mask_unused_interrupts(struct udc *dev)\n{\n\tu32 tmp;\n\n\t \n\ttmp =\tAMD_BIT(UDC_DEVINT_SVC) |\n\t\tAMD_BIT(UDC_DEVINT_ENUM) |\n\t\tAMD_BIT(UDC_DEVINT_US) |\n\t\tAMD_BIT(UDC_DEVINT_UR) |\n\t\tAMD_BIT(UDC_DEVINT_ES) |\n\t\tAMD_BIT(UDC_DEVINT_SI) |\n\t\tAMD_BIT(UDC_DEVINT_SOF)|\n\t\tAMD_BIT(UDC_DEVINT_SC);\n\twritel(tmp, &dev->regs->irqmsk);\n\n\t \n\twritel(UDC_EPINT_MSK_DISABLE_ALL, &dev->regs->ep_irqmsk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(udc_mask_unused_interrupts);\n\n \nstatic int udc_enable_ep0_interrupts(struct udc *dev)\n{\n\tu32 tmp;\n\n\tDBG(dev, \"udc_enable_ep0_interrupts()\\n\");\n\n\t \n\ttmp = readl(&dev->regs->ep_irqmsk);\n\t \n\ttmp &= AMD_UNMASK_BIT(UDC_EPINT_IN_EP0)\n\t\t& AMD_UNMASK_BIT(UDC_EPINT_OUT_EP0);\n\twritel(tmp, &dev->regs->ep_irqmsk);\n\n\treturn 0;\n}\n\n \nint udc_enable_dev_setup_interrupts(struct udc *dev)\n{\n\tu32 tmp;\n\n\tDBG(dev, \"enable device interrupts for setup data\\n\");\n\n\t \n\ttmp = readl(&dev->regs->irqmsk);\n\n\t \n\ttmp &= AMD_UNMASK_BIT(UDC_DEVINT_SI)\n\t\t& AMD_UNMASK_BIT(UDC_DEVINT_SC)\n\t\t& AMD_UNMASK_BIT(UDC_DEVINT_UR)\n\t\t& AMD_UNMASK_BIT(UDC_DEVINT_SVC)\n\t\t& AMD_UNMASK_BIT(UDC_DEVINT_ENUM);\n\twritel(tmp, &dev->regs->irqmsk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(udc_enable_dev_setup_interrupts);\n\n \nstatic int udc_set_txfifo_addr(struct udc_ep *ep)\n{\n\tstruct udc\t*dev;\n\tu32 tmp;\n\tint i;\n\n\tif (!ep || !(ep->in))\n\t\treturn -EINVAL;\n\n\tdev = ep->dev;\n\tep->txfifo = dev->txfifo;\n\n\t \n\tfor (i = 0; i < ep->num; i++) {\n\t\tif (dev->ep[i].regs) {\n\t\t\t \n\t\t\ttmp = readl(&dev->ep[i].regs->bufin_framenum);\n\t\t\ttmp = AMD_GETBITS(tmp, UDC_EPIN_BUFF_SIZE);\n\t\t\tep->txfifo += tmp;\n\t\t}\n\t}\n\treturn 0;\n}\n\n \nstatic u32 cnak_pending;\n\nstatic void UDC_QUEUE_CNAK(struct udc_ep *ep, unsigned num)\n{\n\tif (readl(&ep->regs->ctl) & AMD_BIT(UDC_EPCTL_NAK)) {\n\t\tDBG(ep->dev, \"NAK could not be cleared for ep%d\\n\", num);\n\t\tcnak_pending |= 1 << (num);\n\t\tep->naking = 1;\n\t} else\n\t\tcnak_pending = cnak_pending & (~(1 << (num)));\n}\n\n\n \nstatic int\nudc_ep_enable(struct usb_ep *usbep, const struct usb_endpoint_descriptor *desc)\n{\n\tstruct udc_ep\t\t*ep;\n\tstruct udc\t\t*dev;\n\tu32\t\t\ttmp;\n\tunsigned long\t\tiflags;\n\tu8 udc_csr_epix;\n\tunsigned\t\tmaxpacket;\n\n\tif (!usbep\n\t\t\t|| usbep->name == ep0_string\n\t\t\t|| !desc\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\tdev = ep->dev;\n\n\tDBG(dev, \"udc_ep_enable() ep %d\\n\", ep->num);\n\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&dev->lock, iflags);\n\tep->ep.desc = desc;\n\n\tep->halted = 0;\n\n\t \n\ttmp = readl(&dev->ep[ep->num].regs->ctl);\n\ttmp = AMD_ADDBITS(tmp, desc->bmAttributes, UDC_EPCTL_ET);\n\twritel(tmp, &dev->ep[ep->num].regs->ctl);\n\n\t \n\tmaxpacket = usb_endpoint_maxp(desc);\n\ttmp = readl(&dev->ep[ep->num].regs->bufout_maxpkt);\n\ttmp = AMD_ADDBITS(tmp, maxpacket, UDC_EP_MAX_PKT_SIZE);\n\tep->ep.maxpacket = maxpacket;\n\twritel(tmp, &dev->ep[ep->num].regs->bufout_maxpkt);\n\n\t \n\tif (ep->in) {\n\n\t\t \n\t\tudc_csr_epix = ep->num;\n\n\t\t \n\t\ttmp = readl(&dev->ep[ep->num].regs->bufin_framenum);\n\t\t \n\t\ttmp = AMD_ADDBITS(\n\t\t\t\ttmp,\n\t\t\t\tmaxpacket * UDC_EPIN_BUFF_SIZE_MULT\n\t\t\t\t\t  / UDC_DWORD_BYTES,\n\t\t\t\tUDC_EPIN_BUFF_SIZE);\n\t\twritel(tmp, &dev->ep[ep->num].regs->bufin_framenum);\n\n\t\t \n\t\tudc_set_txfifo_addr(ep);\n\n\t\t \n\t\ttmp = readl(&ep->regs->ctl);\n\t\ttmp |= AMD_BIT(UDC_EPCTL_F);\n\t\twritel(tmp, &ep->regs->ctl);\n\n\t \n\t} else {\n\t\t \n\t\tudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\n\n\t\t \n\t\ttmp = readl(&dev->csr->ne[ep->num - UDC_CSR_EP_OUT_IX_OFS]);\n\t\ttmp = AMD_ADDBITS(tmp, maxpacket,\n\t\t\t\t\tUDC_CSR_NE_MAX_PKT);\n\t\twritel(tmp, &dev->csr->ne[ep->num - UDC_CSR_EP_OUT_IX_OFS]);\n\n\t\tif (use_dma && !ep->in) {\n\t\t\t \n\t\t\tep->bna_dummy_req = udc_alloc_bna_dummy(ep);\n\t\t\tep->bna_occurred = 0;\n\t\t}\n\n\t\tif (ep->num != UDC_EP0OUT_IX)\n\t\t\tdev->data_ep_enabled = 1;\n\t}\n\n\t \n\ttmp = readl(&dev->csr->ne[udc_csr_epix]);\n\t \n\ttmp = AMD_ADDBITS(tmp, maxpacket, UDC_CSR_NE_MAX_PKT);\n\t \n\ttmp = AMD_ADDBITS(tmp, desc->bEndpointAddress, UDC_CSR_NE_NUM);\n\t \n\ttmp = AMD_ADDBITS(tmp, ep->in, UDC_CSR_NE_DIR);\n\t \n\ttmp = AMD_ADDBITS(tmp, desc->bmAttributes, UDC_CSR_NE_TYPE);\n\t \n\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_config, UDC_CSR_NE_CFG);\n\t \n\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_intf, UDC_CSR_NE_INTF);\n\t \n\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_alt, UDC_CSR_NE_ALT);\n\t \n\twritel(tmp, &dev->csr->ne[udc_csr_epix]);\n\n\t \n\ttmp = readl(&dev->regs->ep_irqmsk);\n\ttmp &= AMD_UNMASK_BIT(ep->num);\n\twritel(tmp, &dev->regs->ep_irqmsk);\n\n\t \n\tif (!use_dma || ep->in) {\n\t\ttmp = readl(&ep->regs->ctl);\n\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\twritel(tmp, &ep->regs->ctl);\n\t\tep->naking = 0;\n\t\tUDC_QUEUE_CNAK(ep, ep->num);\n\t}\n\ttmp = desc->bEndpointAddress;\n\tDBG(dev, \"%s enabled\\n\", usbep->name);\n\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n\treturn 0;\n}\n\n \nstatic void ep_init(struct udc_regs __iomem *regs, struct udc_ep *ep)\n{\n\tu32\t\ttmp;\n\n\tVDBG(ep->dev, \"ep-%d reset\\n\", ep->num);\n\tep->ep.desc = NULL;\n\tep->ep.ops = &udc_ep_ops;\n\tINIT_LIST_HEAD(&ep->queue);\n\n\tusb_ep_set_maxpacket_limit(&ep->ep,(u16) ~0);\n\t \n\ttmp = readl(&ep->regs->ctl);\n\ttmp |= AMD_BIT(UDC_EPCTL_SNAK);\n\twritel(tmp, &ep->regs->ctl);\n\tep->naking = 1;\n\n\t \n\ttmp = readl(&regs->ep_irqmsk);\n\ttmp |= AMD_BIT(ep->num);\n\twritel(tmp, &regs->ep_irqmsk);\n\n\tif (ep->in) {\n\t\t \n\t\ttmp = readl(&ep->regs->ctl);\n\t\ttmp &= AMD_UNMASK_BIT(UDC_EPCTL_P);\n\t\twritel(tmp, &ep->regs->ctl);\n\n\t\ttmp = readl(&ep->regs->sts);\n\t\ttmp |= AMD_BIT(UDC_EPSTS_IN);\n\t\twritel(tmp, &ep->regs->sts);\n\n\t\t \n\t\ttmp = readl(&ep->regs->ctl);\n\t\ttmp |= AMD_BIT(UDC_EPCTL_F);\n\t\twritel(tmp, &ep->regs->ctl);\n\n\t}\n\t \n\twritel(0, &ep->regs->desptr);\n}\n\n \nstatic int udc_ep_disable(struct usb_ep *usbep)\n{\n\tstruct udc_ep\t*ep = NULL;\n\tunsigned long\tiflags;\n\n\tif (!usbep)\n\t\treturn -EINVAL;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\tif (usbep->name == ep0_string || !ep->ep.desc)\n\t\treturn -EINVAL;\n\n\tDBG(ep->dev, \"Disable ep-%d\\n\", ep->num);\n\n\tspin_lock_irqsave(&ep->dev->lock, iflags);\n\tudc_free_request(&ep->ep, &ep->bna_dummy_req->req);\n\tempty_req_queue(ep);\n\tep_init(ep->dev->regs, ep);\n\tspin_unlock_irqrestore(&ep->dev->lock, iflags);\n\n\treturn 0;\n}\n\n \nstatic struct usb_request *\nudc_alloc_request(struct usb_ep *usbep, gfp_t gfp)\n{\n\tstruct udc_request\t*req;\n\tstruct udc_data_dma\t*dma_desc;\n\tstruct udc_ep\t*ep;\n\n\tif (!usbep)\n\t\treturn NULL;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\n\tVDBG(ep->dev, \"udc_alloc_req(): ep%d\\n\", ep->num);\n\treq = kzalloc(sizeof(struct udc_request), gfp);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->req.dma = DMA_DONT_USE;\n\tINIT_LIST_HEAD(&req->queue);\n\n\tif (ep->dma) {\n\t\t \n\t\tdma_desc = dma_pool_alloc(ep->dev->data_requests, gfp,\n\t\t\t\t\t\t&req->td_phys);\n\t\tif (!dma_desc) {\n\t\t\tkfree(req);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tVDBG(ep->dev, \"udc_alloc_req: req = %p dma_desc = %p, \"\n\t\t\t\t\"td_phys = %lx\\n\",\n\t\t\t\treq, dma_desc,\n\t\t\t\t(unsigned long)req->td_phys);\n\t\t \n\t\tdma_desc->status = AMD_ADDBITS(dma_desc->status,\n\t\t\t\t\t\tUDC_DMA_STP_STS_BS_HOST_BUSY,\n\t\t\t\t\t\tUDC_DMA_STP_STS_BS);\n\t\tdma_desc->bufptr = cpu_to_le32(DMA_DONT_USE);\n\t\treq->td_data = dma_desc;\n\t\treq->td_data_last = NULL;\n\t\treq->chain_len = 1;\n\t}\n\n\treturn &req->req;\n}\n\n \nstatic void udc_free_dma_chain(struct udc *dev, struct udc_request *req)\n{\n\tstruct udc_data_dma *td = req->td_data;\n\tunsigned int i;\n\n\tdma_addr_t addr_next = 0x00;\n\tdma_addr_t addr = (dma_addr_t)td->next;\n\n\tDBG(dev, \"free chain req = %p\\n\", req);\n\n\t \n\tfor (i = 1; i < req->chain_len; i++) {\n\t\ttd = phys_to_virt(addr);\n\t\taddr_next = (dma_addr_t)td->next;\n\t\tdma_pool_free(dev->data_requests, td, addr);\n\t\taddr = addr_next;\n\t}\n}\n\n \nstatic void\nudc_free_request(struct usb_ep *usbep, struct usb_request *usbreq)\n{\n\tstruct udc_ep\t*ep;\n\tstruct udc_request\t*req;\n\n\tif (!usbep || !usbreq)\n\t\treturn;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\treq = container_of(usbreq, struct udc_request, req);\n\tVDBG(ep->dev, \"free_req req=%p\\n\", req);\n\tBUG_ON(!list_empty(&req->queue));\n\tif (req->td_data) {\n\t\tVDBG(ep->dev, \"req->td_data=%p\\n\", req->td_data);\n\n\t\t \n\t\tif (req->chain_len > 1)\n\t\t\tudc_free_dma_chain(ep->dev, req);\n\n\t\tdma_pool_free(ep->dev->data_requests, req->td_data,\n\t\t\t\t\t\t\treq->td_phys);\n\t}\n\tkfree(req);\n}\n\n \nstatic void udc_init_bna_dummy(struct udc_request *req)\n{\n\tif (req) {\n\t\t \n\t\treq->td_data->status |= AMD_BIT(UDC_DMA_IN_STS_L);\n\t\t \n\t\treq->td_data->next = req->td_phys;\n\t\t \n\t\treq->td_data->status\n\t\t\t= AMD_ADDBITS(req->td_data->status,\n\t\t\t\t\tUDC_DMA_STP_STS_BS_DMA_DONE,\n\t\t\t\t\tUDC_DMA_STP_STS_BS);\n#ifdef UDC_VERBOSE\n\t\tpr_debug(\"bna desc = %p, sts = %08x\\n\",\n\t\t\treq->td_data, req->td_data->status);\n#endif\n\t}\n}\n\n \nstatic struct udc_request *udc_alloc_bna_dummy(struct udc_ep *ep)\n{\n\tstruct udc_request *req = NULL;\n\tstruct usb_request *_req = NULL;\n\n\t \n\t_req = udc_alloc_request(&ep->ep, GFP_ATOMIC);\n\tif (_req) {\n\t\treq = container_of(_req, struct udc_request, req);\n\t\tep->bna_dummy_req = req;\n\t\tudc_init_bna_dummy(req);\n\t}\n\treturn req;\n}\n\n \nstatic void\nudc_txfifo_write(struct udc_ep *ep, struct usb_request *req)\n{\n\tu8\t\t\t*req_buf;\n\tu32\t\t\t*buf;\n\tint\t\t\ti, j;\n\tunsigned\t\tbytes = 0;\n\tunsigned\t\tremaining = 0;\n\n\tif (!req || !ep)\n\t\treturn;\n\n\treq_buf = req->buf + req->actual;\n\tprefetch(req_buf);\n\tremaining = req->length - req->actual;\n\n\tbuf = (u32 *) req_buf;\n\n\tbytes = ep->ep.maxpacket;\n\tif (bytes > remaining)\n\t\tbytes = remaining;\n\n\t \n\tfor (i = 0; i < bytes / UDC_DWORD_BYTES; i++)\n\t\twritel(*(buf + i), ep->txfifo);\n\n\t \n\tfor (j = 0; j < bytes % UDC_DWORD_BYTES; j++) {\n\t\twriteb((u8)(*(buf + i) >> (j << UDC_BITS_PER_BYTE_SHIFT)),\n\t\t\t\t\t\t\tep->txfifo);\n\t}\n\n\t \n\twritel(0, &ep->regs->confirm);\n}\n\n \nstatic int udc_rxfifo_read_dwords(struct udc *dev, u32 *buf, int dwords)\n{\n\tint i;\n\n\tVDBG(dev, \"udc_read_dwords(): %d dwords\\n\", dwords);\n\n\tfor (i = 0; i < dwords; i++)\n\t\t*(buf + i) = readl(dev->rxfifo);\n\treturn 0;\n}\n\n \nstatic int udc_rxfifo_read_bytes(struct udc *dev, u8 *buf, int bytes)\n{\n\tint i, j;\n\tu32 tmp;\n\n\tVDBG(dev, \"udc_read_bytes(): %d bytes\\n\", bytes);\n\n\t \n\tfor (i = 0; i < bytes / UDC_DWORD_BYTES; i++)\n\t\t*((u32 *)(buf + (i<<2))) = readl(dev->rxfifo);\n\n\t \n\tif (bytes % UDC_DWORD_BYTES) {\n\t\ttmp = readl(dev->rxfifo);\n\t\tfor (j = 0; j < bytes % UDC_DWORD_BYTES; j++) {\n\t\t\t*(buf + (i<<2) + j) = (u8)(tmp & UDC_BYTE_MASK);\n\t\t\ttmp = tmp >> UDC_BITS_PER_BYTE;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nudc_rxfifo_read(struct udc_ep *ep, struct udc_request *req)\n{\n\tu8 *buf;\n\tunsigned buf_space;\n\tunsigned bytes = 0;\n\tunsigned finished = 0;\n\n\t \n\tbytes = readl(&ep->regs->sts);\n\tbytes = AMD_GETBITS(bytes, UDC_EPSTS_RX_PKT_SIZE);\n\n\tbuf_space = req->req.length - req->req.actual;\n\tbuf = req->req.buf + req->req.actual;\n\tif (bytes > buf_space) {\n\t\tif ((buf_space % ep->ep.maxpacket) != 0) {\n\t\t\tDBG(ep->dev,\n\t\t\t\t\"%s: rx %d bytes, rx-buf space = %d bytesn\\n\",\n\t\t\t\tep->ep.name, bytes, buf_space);\n\t\t\treq->req.status = -EOVERFLOW;\n\t\t}\n\t\tbytes = buf_space;\n\t}\n\treq->req.actual += bytes;\n\n\t \n\tif (((bytes % ep->ep.maxpacket) != 0) || (!bytes)\n\t\t|| ((req->req.actual == req->req.length) && !req->req.zero))\n\t\tfinished = 1;\n\n\t \n\tVDBG(ep->dev, \"ep %s: rxfifo read %d bytes\\n\", ep->ep.name, bytes);\n\tudc_rxfifo_read_bytes(ep->dev, buf, bytes);\n\n\treturn finished;\n}\n\n \nstatic int udc_create_dma_chain(\n\tstruct udc_ep *ep,\n\tstruct udc_request *req,\n\tunsigned long buf_len, gfp_t gfp_flags\n)\n{\n\tunsigned long bytes = req->req.length;\n\tunsigned int i;\n\tdma_addr_t dma_addr;\n\tstruct udc_data_dma\t*td = NULL;\n\tstruct udc_data_dma\t*last = NULL;\n\tunsigned long txbytes;\n\tunsigned create_new_chain = 0;\n\tunsigned len;\n\n\tVDBG(ep->dev, \"udc_create_dma_chain: bytes=%ld buf_len=%ld\\n\",\n\t     bytes, buf_len);\n\tdma_addr = DMA_DONT_USE;\n\n\t \n\tif (!ep->in)\n\t\treq->td_data->status &= AMD_CLEAR_BIT(UDC_DMA_IN_STS_L);\n\n\t \n\tlen = req->req.length / ep->ep.maxpacket;\n\tif (req->req.length % ep->ep.maxpacket)\n\t\tlen++;\n\n\tif (len > req->chain_len) {\n\t\t \n\t\tif (req->chain_len > 1)\n\t\t\tudc_free_dma_chain(ep->dev, req);\n\t\treq->chain_len = len;\n\t\tcreate_new_chain = 1;\n\t}\n\n\ttd = req->td_data;\n\t \n\tfor (i = buf_len; i < bytes; i += buf_len) {\n\t\t \n\t\tif (create_new_chain) {\n\t\t\ttd = dma_pool_alloc(ep->dev->data_requests,\n\t\t\t\t\t    gfp_flags, &dma_addr);\n\t\t\tif (!td)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\ttd->status = 0;\n\t\t} else if (i == buf_len) {\n\t\t\t \n\t\t\ttd = (struct udc_data_dma *)phys_to_virt(\n\t\t\t\t\t\treq->td_data->next);\n\t\t\ttd->status = 0;\n\t\t} else {\n\t\t\ttd = (struct udc_data_dma *)phys_to_virt(last->next);\n\t\t\ttd->status = 0;\n\t\t}\n\n\t\tif (td)\n\t\t\ttd->bufptr = req->req.dma + i;  \n\t\telse\n\t\t\tbreak;\n\n\t\t \n\t\tif ((bytes - i) >= buf_len) {\n\t\t\ttxbytes = buf_len;\n\t\t} else {\n\t\t\t \n\t\t\ttxbytes = bytes - i;\n\t\t}\n\n\t\t \n\t\tif (i == buf_len) {\n\t\t\tif (create_new_chain)\n\t\t\t\treq->td_data->next = dma_addr;\n\t\t\t \n\t\t\t \n\t\t\tif (ep->in) {\n\t\t\t\t \n\t\t\t\treq->td_data->status =\n\t\t\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\t\t\t    ep->ep.maxpacket,\n\t\t\t\t\t\t    UDC_DMA_IN_STS_TXBYTES);\n\t\t\t\t \n\t\t\t\ttd->status = AMD_ADDBITS(td->status,\n\t\t\t\t\t\t\ttxbytes,\n\t\t\t\t\t\t\tUDC_DMA_IN_STS_TXBYTES);\n\t\t\t}\n\t\t} else {\n\t\t\tif (create_new_chain)\n\t\t\t\tlast->next = dma_addr;\n\t\t\t \n\t\t\tif (ep->in) {\n\t\t\t\t \n\t\t\t\ttd->status = AMD_ADDBITS(td->status,\n\t\t\t\t\t\t\ttxbytes,\n\t\t\t\t\t\t\tUDC_DMA_IN_STS_TXBYTES);\n\t\t\t}\n\t\t}\n\t\tlast = td;\n\t}\n\t \n\tif (td) {\n\t\ttd->status |= AMD_BIT(UDC_DMA_IN_STS_L);\n\t\t \n\t\treq->td_data_last = td;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int prep_dma(struct udc_ep *ep, struct udc_request *req, gfp_t gfp)\n{\n\tint\tretval = 0;\n\tu32\ttmp;\n\n\tVDBG(ep->dev, \"prep_dma\\n\");\n\tVDBG(ep->dev, \"prep_dma ep%d req->td_data=%p\\n\",\n\t\t\tep->num, req->td_data);\n\n\t \n\treq->td_data->bufptr = req->req.dma;\n\n\t \n\treq->td_data->status |= AMD_BIT(UDC_DMA_IN_STS_L);\n\n\t \n\tif (use_dma_ppb) {\n\n\t\tretval = udc_create_dma_chain(ep, req, ep->ep.maxpacket, gfp);\n\t\tif (retval != 0) {\n\t\t\tif (retval == -ENOMEM)\n\t\t\t\tDBG(ep->dev, \"Out of DMA memory\\n\");\n\t\t\treturn retval;\n\t\t}\n\t\tif (ep->in) {\n\t\t\tif (req->req.length == ep->ep.maxpacket) {\n\t\t\t\t \n\t\t\t\treq->td_data->status =\n\t\t\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\t\t\tep->ep.maxpacket,\n\t\t\t\t\t\tUDC_DMA_IN_STS_TXBYTES);\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (ep->in) {\n\t\tVDBG(ep->dev, \"IN: use_dma_ppb=%d req->req.len=%d \"\n\t\t\t\t\"maxpacket=%d ep%d\\n\",\n\t\t\t\tuse_dma_ppb, req->req.length,\n\t\t\t\tep->ep.maxpacket, ep->num);\n\t\t \n\t\tif (!use_dma_ppb || req->req.length < ep->ep.maxpacket\n\t\t\t\t|| ep->num == UDC_EP0OUT_IX\n\t\t\t\t|| ep->num == UDC_EP0IN_IX) {\n\t\t\t \n\t\t\treq->td_data->status =\n\t\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\t\t\treq->req.length,\n\t\t\t\t\t\tUDC_DMA_IN_STS_TXBYTES);\n\t\t\t \n\t\t\treq->td_data->status =\n\t\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tUDC_DMA_IN_STS_FRAMENUM);\n\t\t}\n\t\t \n\t\treq->td_data->status =\n\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\tUDC_DMA_STP_STS_BS_HOST_BUSY,\n\t\t\t\tUDC_DMA_STP_STS_BS);\n\t} else {\n\t\tVDBG(ep->dev, \"OUT set host ready\\n\");\n\t\t \n\t\treq->td_data->status =\n\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\tUDC_DMA_STP_STS_BS_HOST_READY,\n\t\t\t\tUDC_DMA_STP_STS_BS);\n\n\t\t \n\t\tif (ep->naking) {\n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\tep->naking = 0;\n\t\t\tUDC_QUEUE_CNAK(ep, ep->num);\n\t\t}\n\n\t}\n\n\treturn retval;\n}\n\n \nstatic void\ncomplete_req(struct udc_ep *ep, struct udc_request *req, int sts)\n__releases(ep->dev->lock)\n__acquires(ep->dev->lock)\n{\n\tstruct udc\t\t*dev;\n\tunsigned\t\thalted;\n\n\tVDBG(ep->dev, \"complete_req(): ep%d\\n\", ep->num);\n\n\tdev = ep->dev;\n\t \n\tif (ep->dma)\n\t\tusb_gadget_unmap_request(&dev->gadget, &req->req, ep->in);\n\n\thalted = ep->halted;\n\tep->halted = 1;\n\n\t \n\tif (req->req.status == -EINPROGRESS)\n\t\treq->req.status = sts;\n\n\t \n\tlist_del_init(&req->queue);\n\n\tVDBG(ep->dev, \"req %p => complete %d bytes at %s with sts %d\\n\",\n\t\t&req->req, req->req.length, ep->ep.name, sts);\n\n\tspin_unlock(&dev->lock);\n\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\tspin_lock(&dev->lock);\n\tep->halted = halted;\n}\n\n \nstatic struct udc_data_dma *udc_get_last_dma_desc(struct udc_request *req)\n{\n\tstruct udc_data_dma\t*td;\n\n\ttd = req->td_data;\n\twhile (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L)))\n\t\ttd = phys_to_virt(td->next);\n\n\treturn td;\n\n}\n\n \nstatic u32 udc_get_ppbdu_rxbytes(struct udc_request *req)\n{\n\tstruct udc_data_dma\t*td;\n\tu32 count;\n\n\ttd = req->td_data;\n\t \n\tcount = AMD_GETBITS(td->status, UDC_DMA_OUT_STS_RXBYTES);\n\n\twhile (td && !(td->status & AMD_BIT(UDC_DMA_IN_STS_L))) {\n\t\ttd = phys_to_virt(td->next);\n\t\t \n\t\tif (td) {\n\t\t\tcount += AMD_GETBITS(td->status,\n\t\t\t\tUDC_DMA_OUT_STS_RXBYTES);\n\t\t}\n\t}\n\n\treturn count;\n\n}\n\n \nstatic void udc_set_rde(struct udc *dev)\n{\n\tu32 tmp;\n\n\tVDBG(dev, \"udc_set_rde()\\n\");\n\t \n\tif (timer_pending(&udc_timer)) {\n\t\tset_rde = 0;\n\t\tmod_timer(&udc_timer, jiffies - 1);\n\t}\n\t \n\ttmp = readl(&dev->regs->ctl);\n\ttmp |= AMD_BIT(UDC_DEVCTL_RDE);\n\twritel(tmp, &dev->regs->ctl);\n}\n\n \nstatic int\nudc_queue(struct usb_ep *usbep, struct usb_request *usbreq, gfp_t gfp)\n{\n\tint\t\t\tretval = 0;\n\tu8\t\t\topen_rxfifo = 0;\n\tunsigned long\t\tiflags;\n\tstruct udc_ep\t\t*ep;\n\tstruct udc_request\t*req;\n\tstruct udc\t\t*dev;\n\tu32\t\t\ttmp;\n\n\t \n\treq = container_of(usbreq, struct udc_request, req);\n\n\tif (!usbep || !usbreq || !usbreq->complete || !usbreq->buf\n\t\t\t|| !list_empty(&req->queue))\n\t\treturn -EINVAL;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\tif (!ep->ep.desc && (ep->num != 0 && ep->num != UDC_EP0OUT_IX))\n\t\treturn -EINVAL;\n\n\tVDBG(ep->dev, \"udc_queue(): ep%d-in=%d\\n\", ep->num, ep->in);\n\tdev = ep->dev;\n\n\tif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (ep->dma) {\n\t\tVDBG(dev, \"DMA map req %p\\n\", req);\n\t\tretval = usb_gadget_map_request(&udc->gadget, usbreq, ep->in);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tVDBG(dev, \"%s queue req %p, len %d req->td_data=%p buf %p\\n\",\n\t\t\tusbep->name, usbreq, usbreq->length,\n\t\t\treq->td_data, usbreq->buf);\n\n\tspin_lock_irqsave(&dev->lock, iflags);\n\tusbreq->actual = 0;\n\tusbreq->status = -EINPROGRESS;\n\treq->dma_done = 0;\n\n\t \n\tif (list_empty(&ep->queue)) {\n\t\t \n\t\tif (usbreq->length == 0) {\n\t\t\t \n\t\t\tcomplete_req(ep, req, 0);\n\t\t\tVDBG(dev, \"%s: zlp\\n\", ep->ep.name);\n\t\t\t \n\t\t\tif (dev->set_cfg_not_acked) {\n\t\t\t\ttmp = readl(&dev->regs->ctl);\n\t\t\t\ttmp |= AMD_BIT(UDC_DEVCTL_CSR_DONE);\n\t\t\t\twritel(tmp, &dev->regs->ctl);\n\t\t\t\tdev->set_cfg_not_acked = 0;\n\t\t\t}\n\t\t\t \n\t\t\tif (dev->waiting_zlp_ack_ep0in) {\n\t\t\t\t \n\t\t\t\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\t\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t\t\tdev->ep[UDC_EP0IN_IX].naking = 0;\n\t\t\t\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX],\n\t\t\t\t\t\t\tUDC_EP0IN_IX);\n\t\t\t\tdev->waiting_zlp_ack_ep0in = 0;\n\t\t\t}\n\t\t\tgoto finished;\n\t\t}\n\t\tif (ep->dma) {\n\t\t\tretval = prep_dma(ep, req, GFP_ATOMIC);\n\t\t\tif (retval != 0)\n\t\t\t\tgoto finished;\n\t\t\t \n\t\t\tif (ep->in) {\n\t\t\t\t \n\t\t\t\treq->td_data->status =\n\t\t\t\t\tAMD_ADDBITS(req->td_data->status,\n\t\t\t\t\t\tUDC_DMA_IN_STS_BS_HOST_READY,\n\t\t\t\t\t\tUDC_DMA_IN_STS_BS);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!ep->in) {\n\t\t\t\t \n\t\t\t\tif (timer_pending(&udc_timer)) {\n\t\t\t\t\tset_rde = 0;\n\t\t\t\t\tmod_timer(&udc_timer, jiffies - 1);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ttmp = readl(&dev->regs->ctl);\n\t\t\t\ttmp &= AMD_UNMASK_BIT(UDC_DEVCTL_RDE);\n\t\t\t\twritel(tmp, &dev->regs->ctl);\n\t\t\t\topen_rxfifo = 1;\n\n\t\t\t\t \n\t\t\t\tif (ep->bna_occurred) {\n\t\t\t\t\tVDBG(dev, \"copy to BNA dummy desc.\\n\");\n\t\t\t\t\tmemcpy(ep->bna_dummy_req->td_data,\n\t\t\t\t\t\treq->td_data,\n\t\t\t\t\t\tsizeof(struct udc_data_dma));\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\twritel(req->td_phys, &ep->regs->desptr);\n\n\t\t\t \n\t\t\tif (ep->naking) {\n\t\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\t\tep->naking = 0;\n\t\t\t\tUDC_QUEUE_CNAK(ep, ep->num);\n\t\t\t}\n\n\t\t\tif (ep->in) {\n\t\t\t\t \n\t\t\t\ttmp = readl(&dev->regs->ep_irqmsk);\n\t\t\t\ttmp &= AMD_UNMASK_BIT(ep->num);\n\t\t\t\twritel(tmp, &dev->regs->ep_irqmsk);\n\t\t\t}\n\t\t} else if (ep->in) {\n\t\t\t\t \n\t\t\t\ttmp = readl(&dev->regs->ep_irqmsk);\n\t\t\t\ttmp &= AMD_UNMASK_BIT(ep->num);\n\t\t\t\twritel(tmp, &dev->regs->ep_irqmsk);\n\t\t\t}\n\n\t} else if (ep->dma) {\n\n\t\t \n\t\tif (ep->in) {\n\t\t\tretval = prep_dma(ep, req, GFP_ATOMIC);\n\t\t\tif (retval != 0)\n\t\t\t\tgoto finished;\n\t\t}\n\t}\n\tVDBG(dev, \"list_add\\n\");\n\t \n\tif (req) {\n\n\t\tlist_add_tail(&req->queue, &ep->queue);\n\n\t\t \n\t\tif (open_rxfifo) {\n\t\t\t \n\t\t\treq->dma_going = 1;\n\t\t\tudc_set_rde(dev);\n\t\t\tif (ep->num != UDC_EP0OUT_IX)\n\t\t\t\tdev->data_ep_queued = 1;\n\t\t}\n\t\t \n\t\tif (!ep->in) {\n\t\t\tif (!use_dma && udc_rxfifo_pending) {\n\t\t\t\tDBG(dev, \"udc_queue(): pending bytes in \"\n\t\t\t\t\t\"rxfifo after nyet\\n\");\n\t\t\t\t \n\t\t\t\tif (udc_rxfifo_read(ep, req)) {\n\t\t\t\t\t \n\t\t\t\t\tcomplete_req(ep, req, 0);\n\t\t\t\t}\n\t\t\t\tudc_rxfifo_pending = 0;\n\n\t\t\t}\n\t\t}\n\t}\n\nfinished:\n\tspin_unlock_irqrestore(&dev->lock, iflags);\n\treturn retval;\n}\n\n \nvoid empty_req_queue(struct udc_ep *ep)\n{\n\tstruct udc_request\t*req;\n\n\tep->halted = 1;\n\twhile (!list_empty(&ep->queue)) {\n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct udc_request,\n\t\t\tqueue);\n\t\tcomplete_req(ep, req, -ESHUTDOWN);\n\t}\n}\nEXPORT_SYMBOL_GPL(empty_req_queue);\n\n \nstatic int udc_dequeue(struct usb_ep *usbep, struct usb_request *usbreq)\n{\n\tstruct udc_ep\t\t*ep;\n\tstruct udc_request\t*req;\n\tunsigned\t\thalted;\n\tunsigned long\t\tiflags;\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\tif (!usbep || !usbreq || (!ep->ep.desc && (ep->num != 0\n\t\t\t\t&& ep->num != UDC_EP0OUT_IX)))\n\t\treturn -EINVAL;\n\n\treq = container_of(usbreq, struct udc_request, req);\n\n\tspin_lock_irqsave(&ep->dev->lock, iflags);\n\thalted = ep->halted;\n\tep->halted = 1;\n\t \n\tif (ep->queue.next == &req->queue) {\n\t\tif (ep->dma && req->dma_going) {\n\t\t\tif (ep->in)\n\t\t\t\tep->cancel_transfer = 1;\n\t\t\telse {\n\t\t\t\tu32 tmp;\n\t\t\t\tu32 dma_sts;\n\t\t\t\t \n\t\t\t\ttmp = readl(&udc->regs->ctl);\n\t\t\t\twritel(tmp & AMD_UNMASK_BIT(UDC_DEVCTL_RDE),\n\t\t\t\t\t\t\t&udc->regs->ctl);\n\t\t\t\t \n\t\t\t\tdma_sts = AMD_GETBITS(req->td_data->status,\n\t\t\t\t\t\t\tUDC_DMA_OUT_STS_BS);\n\t\t\t\tif (dma_sts != UDC_DMA_OUT_STS_BS_HOST_READY)\n\t\t\t\t\tep->cancel_transfer = 1;\n\t\t\t\telse {\n\t\t\t\t\tudc_init_bna_dummy(ep->req);\n\t\t\t\t\twritel(ep->bna_dummy_req->td_phys,\n\t\t\t\t\t\t&ep->regs->desptr);\n\t\t\t\t}\n\t\t\t\twritel(tmp, &udc->regs->ctl);\n\t\t\t}\n\t\t}\n\t}\n\tcomplete_req(ep, req, -ECONNRESET);\n\tep->halted = halted;\n\n\tspin_unlock_irqrestore(&ep->dev->lock, iflags);\n\treturn 0;\n}\n\n \nstatic int\nudc_set_halt(struct usb_ep *usbep, int halt)\n{\n\tstruct udc_ep\t*ep;\n\tu32 tmp;\n\tunsigned long iflags;\n\tint retval = 0;\n\n\tif (!usbep)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"set_halt %s: halt=%d\\n\", usbep->name, halt);\n\n\tep = container_of(usbep, struct udc_ep, ep);\n\tif (!ep->ep.desc && (ep->num != 0 && ep->num != UDC_EP0OUT_IX))\n\t\treturn -EINVAL;\n\tif (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc_stall_spinlock, iflags);\n\t \n\tif (halt) {\n\t\tif (ep->num == 0)\n\t\t\tep->dev->stall_ep0in = 1;\n\t\telse {\n\t\t\t \n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_S);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\tep->halted = 1;\n\n\t\t\t \n\t\t\tif (!timer_pending(&udc_pollstall_timer)) {\n\t\t\t\tudc_pollstall_timer.expires = jiffies +\n\t\t\t\t\tHZ * UDC_POLLSTALL_TIMER_USECONDS\n\t\t\t\t\t/ (1000 * 1000);\n\t\t\t\tif (!stop_pollstall_timer) {\n\t\t\t\t\tDBG(ep->dev, \"start polltimer\\n\");\n\t\t\t\t\tadd_timer(&udc_pollstall_timer);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (ep->halted) {\n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\t \n\t\t\ttmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\n\t\t\t \n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\tep->halted = 0;\n\t\t\tUDC_QUEUE_CNAK(ep, ep->num);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&udc_stall_spinlock, iflags);\n\treturn retval;\n}\n\n \nstatic const struct usb_ep_ops udc_ep_ops = {\n\t.enable\t\t= udc_ep_enable,\n\t.disable\t= udc_ep_disable,\n\n\t.alloc_request\t= udc_alloc_request,\n\t.free_request\t= udc_free_request,\n\n\t.queue\t\t= udc_queue,\n\t.dequeue\t= udc_dequeue,\n\n\t.set_halt\t= udc_set_halt,\n\t \n};\n\n \n\n \nstatic int udc_get_frame(struct usb_gadget *gadget)\n{\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int udc_remote_wakeup(struct udc *dev)\n{\n\tunsigned long flags;\n\tu32 tmp;\n\n\tDBG(dev, \"UDC initiates remote wakeup\\n\");\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\ttmp = readl(&dev->regs->ctl);\n\ttmp |= AMD_BIT(UDC_DEVCTL_RES);\n\twritel(tmp, &dev->regs->ctl);\n\ttmp &= AMD_CLEAR_BIT(UDC_DEVCTL_RES);\n\twritel(tmp, &dev->regs->ctl);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn 0;\n}\n\n \nstatic int udc_wakeup(struct usb_gadget *gadget)\n{\n\tstruct udc\t\t*dev;\n\n\tif (!gadget)\n\t\treturn -EINVAL;\n\tdev = container_of(gadget, struct udc, gadget);\n\tudc_remote_wakeup(dev);\n\n\treturn 0;\n}\n\nstatic int amd5536_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int amd5536_udc_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops udc_ops = {\n\t.wakeup\t\t= udc_wakeup,\n\t.get_frame\t= udc_get_frame,\n\t.udc_start\t= amd5536_udc_start,\n\t.udc_stop\t= amd5536_udc_stop,\n};\n\n \nstatic void make_ep_lists(struct udc *dev)\n{\n\t \n\tINIT_LIST_HEAD(&dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[UDC_EPIN_STATUS_IX].ep.ep_list,\n\t\t\t\t\t\t&dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[UDC_EPIN_IX].ep.ep_list,\n\t\t\t\t\t\t&dev->gadget.ep_list);\n\tlist_add_tail(&dev->ep[UDC_EPOUT_IX].ep.ep_list,\n\t\t\t\t\t\t&dev->gadget.ep_list);\n\n\t \n\tdev->ep[UDC_EPIN_STATUS_IX].fifo_depth = UDC_EPIN_SMALLINT_BUFF_SIZE;\n\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\tdev->ep[UDC_EPIN_IX].fifo_depth = UDC_FS_EPIN_BUFF_SIZE;\n\telse if (dev->gadget.speed == USB_SPEED_HIGH)\n\t\tdev->ep[UDC_EPIN_IX].fifo_depth = hs_tx_buf;\n\tdev->ep[UDC_EPOUT_IX].fifo_depth = UDC_RXFIFO_SIZE;\n}\n\n \nvoid udc_basic_init(struct udc *dev)\n{\n\tu32\ttmp;\n\n\tDBG(dev, \"udc_basic_init()\\n\");\n\n\tdev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tif (timer_pending(&udc_timer)) {\n\t\tset_rde = 0;\n\t\tmod_timer(&udc_timer, jiffies - 1);\n\t}\n\t \n\tif (timer_pending(&udc_pollstall_timer))\n\t\tmod_timer(&udc_pollstall_timer, jiffies - 1);\n\t \n\ttmp = readl(&dev->regs->ctl);\n\ttmp &= AMD_UNMASK_BIT(UDC_DEVCTL_RDE);\n\ttmp &= AMD_UNMASK_BIT(UDC_DEVCTL_TDE);\n\twritel(tmp, &dev->regs->ctl);\n\n\t \n\ttmp = readl(&dev->regs->cfg);\n\ttmp |= AMD_BIT(UDC_DEVCFG_CSR_PRG);\n\t \n\ttmp |= AMD_BIT(UDC_DEVCFG_SP);\n\t \n\ttmp |= AMD_BIT(UDC_DEVCFG_RWKP);\n\twritel(tmp, &dev->regs->cfg);\n\n\tmake_ep_lists(dev);\n\n\tdev->data_ep_enabled = 0;\n\tdev->data_ep_queued = 0;\n}\nEXPORT_SYMBOL_GPL(udc_basic_init);\n\n \nstatic int startup_registers(struct udc *dev)\n{\n\tu32 tmp;\n\n\t \n\tudc_soft_reset(dev);\n\n\t \n\tudc_mask_unused_interrupts(dev);\n\n\t \n\tudc_basic_init(dev);\n\t \n\tudc_setup_endpoints(dev);\n\n\t \n\ttmp = readl(&dev->regs->cfg);\n\tif (use_fullspeed)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_FS, UDC_DEVCFG_SPD);\n\telse\n\t\ttmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_HS, UDC_DEVCFG_SPD);\n\twritel(tmp, &dev->regs->cfg);\n\n\treturn 0;\n}\n\n \nstatic void udc_setup_endpoints(struct udc *dev)\n{\n\tstruct udc_ep\t*ep;\n\tu32\ttmp;\n\tu32\treg;\n\n\tDBG(dev, \"udc_setup_endpoints()\\n\");\n\n\t \n\ttmp = readl(&dev->regs->sts);\n\ttmp = AMD_GETBITS(tmp, UDC_DEVSTS_ENUM_SPEED);\n\tif (tmp == UDC_DEVSTS_ENUM_SPEED_HIGH)\n\t\tdev->gadget.speed = USB_SPEED_HIGH;\n\telse if (tmp == UDC_DEVSTS_ENUM_SPEED_FULL)\n\t\tdev->gadget.speed = USB_SPEED_FULL;\n\n\t \n\tfor (tmp = 0; tmp < UDC_EP_NUM; tmp++) {\n\t\tep = &dev->ep[tmp];\n\t\tep->dev = dev;\n\t\tep->ep.name = ep_info[tmp].name;\n\t\tep->ep.caps = ep_info[tmp].caps;\n\t\tep->num = tmp;\n\t\t \n\t\tep->txfifo = dev->txfifo;\n\n\t\t \n\t\tif (tmp < UDC_EPIN_NUM) {\n\t\t\tep->fifo_depth = UDC_TXFIFO_SIZE;\n\t\t\tep->in = 1;\n\t\t} else {\n\t\t\tep->fifo_depth = UDC_RXFIFO_SIZE;\n\t\t\tep->in = 0;\n\n\t\t}\n\t\tep->regs = &dev->ep_regs[tmp];\n\t\t \n\t\tif (!ep->ep.desc)\n\t\t\tep_init(dev->regs, ep);\n\n\t\tif (use_dma) {\n\t\t\t \n\t\t\tep->dma = &dev->regs->ctl;\n\n\t\t\t \n\t\t\tif (tmp != UDC_EP0IN_IX && tmp != UDC_EP0OUT_IX\n\t\t\t\t\t\t&& tmp > UDC_EPIN_NUM) {\n\t\t\t\t \n\t\t\t\treg = readl(&dev->ep[tmp].regs->ctl);\n\t\t\t\treg |= AMD_BIT(UDC_EPCTL_SNAK);\n\t\t\t\twritel(reg, &dev->ep[tmp].regs->ctl);\n\t\t\t\tdev->ep[tmp].naking = 1;\n\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (dev->gadget.speed == USB_SPEED_FULL) {\n\t\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0IN_IX].ep,\n\t\t\t\t\t   UDC_FS_EP0IN_MAX_PKT_SIZE);\n\t\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0OUT_IX].ep,\n\t\t\t\t\t   UDC_FS_EP0OUT_MAX_PKT_SIZE);\n\t} else if (dev->gadget.speed == USB_SPEED_HIGH) {\n\t\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0IN_IX].ep,\n\t\t\t\t\t   UDC_EP0IN_MAX_PKT_SIZE);\n\t\tusb_ep_set_maxpacket_limit(&dev->ep[UDC_EP0OUT_IX].ep,\n\t\t\t\t\t   UDC_EP0OUT_MAX_PKT_SIZE);\n\t}\n\n\t \n\tdev->gadget.ep0 = &dev->ep[UDC_EP0IN_IX].ep;\n\tdev->ep[UDC_EP0IN_IX].halted = 0;\n\tINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\n\n\t \n\tdev->cur_config = 0;\n\tdev->cur_intf = 0;\n\tdev->cur_alt = 0;\n}\n\n \nstatic void usb_connect(struct udc *dev)\n{\n\t \n\tif (dev->connected)\n\t\treturn;\n\n\tdev_info(dev->dev, \"USB Connect\\n\");\n\n\tdev->connected = 1;\n\n\t \n\tudc_basic_init(dev);\n\n\t \n\tudc_enable_dev_setup_interrupts(dev);\n}\n\n \nstatic void usb_disconnect(struct udc *dev)\n{\n\tu32 tmp;\n\n\t \n\tif (!dev->connected)\n\t\treturn;\n\n\tdev_info(dev->dev, \"USB Disconnect\\n\");\n\n\tdev->connected = 0;\n\n\t \n\tudc_mask_unused_interrupts(dev);\n\n\tif (dev->driver) {\n\t\tspin_unlock(&dev->lock);\n\t\tdev->driver->disconnect(&dev->gadget);\n\t\tspin_lock(&dev->lock);\n\n\t\t \n\t\tfor (tmp = 0; tmp < UDC_EP_NUM; tmp++)\n\t\t\tempty_req_queue(&dev->ep[tmp]);\n\t}\n\n\t \n\tep_init(dev->regs, &dev->ep[UDC_EP0IN_IX]);\n\n\tif (!soft_reset_occured) {\n\t\t \n\t\tudc_soft_reset(dev);\n\t\tsoft_reset_occured++;\n\t}\n\n\t \n\tudc_enable_dev_setup_interrupts(dev);\n\t \n\tif (use_fullspeed) {\n\t\ttmp = readl(&dev->regs->cfg);\n\t\ttmp = AMD_ADDBITS(tmp, UDC_DEVCFG_SPD_FS, UDC_DEVCFG_SPD);\n\t\twritel(tmp, &dev->regs->cfg);\n\t}\n}\n\n \nstatic void udc_soft_reset(struct udc *dev)\n{\n\tunsigned long\tflags;\n\n\tDBG(dev, \"Soft reset\\n\");\n\t \n\twritel(UDC_EPINT_MSK_DISABLE_ALL, &dev->regs->ep_irqsts);\n\t \n\twritel(UDC_DEV_MSK_DISABLE, &dev->regs->irqsts);\n\n\t \n\tif (dev->chiprev != UDC_BCM_REV) {\n\t\tspin_lock_irqsave(&udc_irq_spinlock, flags);\n\t\twritel(AMD_BIT(UDC_DEVCFG_SOFTRESET), &dev->regs->cfg);\n\t\treadl(&dev->regs->cfg);\n\t\tspin_unlock_irqrestore(&udc_irq_spinlock, flags);\n\t}\n}\n\n \nstatic void udc_timer_function(struct timer_list *unused)\n{\n\tu32 tmp;\n\n\tspin_lock_irq(&udc_irq_spinlock);\n\n\tif (set_rde > 0) {\n\t\t \n\t\tif (set_rde > 1) {\n\t\t\t \n\t\t\ttmp = readl(&udc->regs->ctl);\n\t\t\ttmp |= AMD_BIT(UDC_DEVCTL_RDE);\n\t\t\twritel(tmp, &udc->regs->ctl);\n\t\t\tset_rde = -1;\n\t\t} else if (readl(&udc->regs->sts)\n\t\t\t\t& AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY)) {\n\t\t\t \n\t\t\tudc_timer.expires = jiffies + HZ/UDC_RDE_TIMER_DIV;\n\t\t\tif (!stop_timer)\n\t\t\t\tadd_timer(&udc_timer);\n\t\t} else {\n\t\t\t \n\t\t\tset_rde++;\n\t\t\t \n\t\t\tudc_timer.expires = jiffies + HZ*UDC_RDE_TIMER_SECONDS;\n\t\t\tif (!stop_timer)\n\t\t\t\tadd_timer(&udc_timer);\n\t\t}\n\n\t} else\n\t\tset_rde = -1;  \n\tspin_unlock_irq(&udc_irq_spinlock);\n\tif (stop_timer)\n\t\tcomplete(&on_exit);\n\n}\n\n \nstatic void udc_handle_halt_state(struct udc_ep *ep)\n{\n\tu32 tmp;\n\t \n\tif (ep->halted == 1) {\n\t\ttmp = readl(&ep->regs->ctl);\n\t\t \n\t\tif (!(tmp & AMD_BIT(UDC_EPCTL_S))) {\n\t\t\t \n\n\t\t\t \n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\tep->halted = 0;\n\t\t\tUDC_QUEUE_CNAK(ep, ep->num);\n\t\t}\n\t}\n}\n\n \nstatic void udc_pollstall_timer_function(struct timer_list *unused)\n{\n\tstruct udc_ep *ep;\n\tint halted = 0;\n\n\tspin_lock_irq(&udc_stall_spinlock);\n\t \n\tep = &udc->ep[UDC_EPIN_IX];\n\tudc_handle_halt_state(ep);\n\tif (ep->halted)\n\t\thalted = 1;\n\t \n\tep = &udc->ep[UDC_EPOUT_IX];\n\tudc_handle_halt_state(ep);\n\tif (ep->halted)\n\t\thalted = 1;\n\n\t \n\tif (!stop_pollstall_timer && halted) {\n\t\tudc_pollstall_timer.expires = jiffies +\n\t\t\t\t\tHZ * UDC_POLLSTALL_TIMER_USECONDS\n\t\t\t\t\t/ (1000 * 1000);\n\t\tadd_timer(&udc_pollstall_timer);\n\t}\n\tspin_unlock_irq(&udc_stall_spinlock);\n\n\tif (stop_pollstall_timer)\n\t\tcomplete(&on_pollstall_exit);\n}\n\n \nstatic void activate_control_endpoints(struct udc *dev)\n{\n\tu32 tmp;\n\n\tDBG(dev, \"activate_control_endpoints\\n\");\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\ttmp |= AMD_BIT(UDC_EPCTL_F);\n\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\n\t \n\tdev->ep[UDC_EP0IN_IX].in = 1;\n\tdev->ep[UDC_EP0OUT_IX].in = 0;\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->bufin_framenum);\n\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_FS_EPIN0_BUFF_SIZE,\n\t\t\t\t\tUDC_EPIN_BUFF_SIZE);\n\telse if (dev->gadget.speed == USB_SPEED_HIGH)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_EPIN0_BUFF_SIZE,\n\t\t\t\t\tUDC_EPIN_BUFF_SIZE);\n\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->bufin_framenum);\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->bufout_maxpkt);\n\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_FS_EP0IN_MAX_PKT_SIZE,\n\t\t\t\t\tUDC_EP_MAX_PKT_SIZE);\n\telse if (dev->gadget.speed == USB_SPEED_HIGH)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_EP0IN_MAX_PKT_SIZE,\n\t\t\t\tUDC_EP_MAX_PKT_SIZE);\n\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->bufout_maxpkt);\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->bufout_maxpkt);\n\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_FS_EP0OUT_MAX_PKT_SIZE,\n\t\t\t\t\tUDC_EP_MAX_PKT_SIZE);\n\telse if (dev->gadget.speed == USB_SPEED_HIGH)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_EP0OUT_MAX_PKT_SIZE,\n\t\t\t\t\tUDC_EP_MAX_PKT_SIZE);\n\twritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->bufout_maxpkt);\n\n\t \n\ttmp = readl(&dev->csr->ne[0]);\n\tif (dev->gadget.speed == USB_SPEED_FULL)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_FS_EP0OUT_MAX_PKT_SIZE,\n\t\t\t\t\tUDC_CSR_NE_MAX_PKT);\n\telse if (dev->gadget.speed == USB_SPEED_HIGH)\n\t\ttmp = AMD_ADDBITS(tmp, UDC_EP0OUT_MAX_PKT_SIZE,\n\t\t\t\t\tUDC_CSR_NE_MAX_PKT);\n\twritel(tmp, &dev->csr->ne[0]);\n\n\tif (use_dma) {\n\t\tdev->ep[UDC_EP0OUT_IX].td->status |=\n\t\t\tAMD_BIT(UDC_DMA_OUT_STS_L);\n\t\t \n\t\twritel(dev->ep[UDC_EP0OUT_IX].td_stp_dma,\n\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->subptr);\n\t\twritel(dev->ep[UDC_EP0OUT_IX].td_phys,\n\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->desptr);\n\t\t \n\t\tif (timer_pending(&udc_timer)) {\n\t\t\tset_rde = 0;\n\t\t\tmod_timer(&udc_timer, jiffies - 1);\n\t\t}\n\t\t \n\t\tif (timer_pending(&udc_pollstall_timer))\n\t\t\tmod_timer(&udc_pollstall_timer, jiffies - 1);\n\t\t \n\t\ttmp = readl(&dev->regs->ctl);\n\t\ttmp |= AMD_BIT(UDC_DEVCTL_MODE)\n\t\t\t\t| AMD_BIT(UDC_DEVCTL_RDE)\n\t\t\t\t| AMD_BIT(UDC_DEVCTL_TDE);\n\t\tif (use_dma_bufferfill_mode)\n\t\t\ttmp |= AMD_BIT(UDC_DEVCTL_BF);\n\t\telse if (use_dma_ppb_du)\n\t\t\ttmp |= AMD_BIT(UDC_DEVCTL_DU);\n\t\twritel(tmp, &dev->regs->ctl);\n\t}\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\tdev->ep[UDC_EP0IN_IX].naking = 0;\n\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX], UDC_EP0IN_IX);\n\n\t \n\ttmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\twritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\tdev->ep[UDC_EP0OUT_IX].naking = 0;\n\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX], UDC_EP0OUT_IX);\n}\n\n \nstatic int setup_ep0(struct udc *dev)\n{\n\tactivate_control_endpoints(dev);\n\t \n\tudc_enable_ep0_interrupts(dev);\n\t \n\tudc_enable_dev_setup_interrupts(dev);\n\n\treturn 0;\n}\n\n \nstatic int amd5536_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct udc *dev = to_amd5536_udc(g);\n\tu32 tmp;\n\n\tdev->driver = driver;\n\n\t \n\tdev->ep[UDC_EP0OUT_IX].ep.driver_data =\n\t\tdev->ep[UDC_EP0IN_IX].ep.driver_data;\n\n\t \n\tsetup_ep0(dev);\n\n\t \n\ttmp = readl(&dev->regs->ctl);\n\ttmp = tmp & AMD_CLEAR_BIT(UDC_DEVCTL_SD);\n\twritel(tmp, &dev->regs->ctl);\n\n\tusb_connect(dev);\n\n\treturn 0;\n}\n\n \nstatic void\nshutdown(struct udc *dev, struct usb_gadget_driver *driver)\n__releases(dev->lock)\n__acquires(dev->lock)\n{\n\tint tmp;\n\n\t \n\tudc_basic_init(dev);\n\n\tfor (tmp = 0; tmp < UDC_EP_NUM; tmp++)\n\t\tempty_req_queue(&dev->ep[tmp]);\n\n\tudc_setup_endpoints(dev);\n}\n\n \nstatic int amd5536_udc_stop(struct usb_gadget *g)\n{\n\tstruct udc *dev = to_amd5536_udc(g);\n\tunsigned long flags;\n\tu32 tmp;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tudc_mask_unused_interrupts(dev);\n\tshutdown(dev, NULL);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tdev->driver = NULL;\n\n\t \n\ttmp = readl(&dev->regs->ctl);\n\ttmp |= AMD_BIT(UDC_DEVCTL_SD);\n\twritel(tmp, &dev->regs->ctl);\n\n\treturn 0;\n}\n\n \nstatic void udc_process_cnak_queue(struct udc *dev)\n{\n\tu32 tmp;\n\tu32 reg;\n\n\t \n\tDBG(dev, \"CNAK pending queue processing\\n\");\n\tfor (tmp = 0; tmp < UDC_EPIN_NUM_USED; tmp++) {\n\t\tif (cnak_pending & (1 << tmp)) {\n\t\t\tDBG(dev, \"CNAK pending for ep%d\\n\", tmp);\n\t\t\t \n\t\t\treg = readl(&dev->ep[tmp].regs->ctl);\n\t\t\treg |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(reg, &dev->ep[tmp].regs->ctl);\n\t\t\tdev->ep[tmp].naking = 0;\n\t\t\tUDC_QUEUE_CNAK(&dev->ep[tmp], dev->ep[tmp].num);\n\t\t}\n\t}\n\t \n\tif (cnak_pending & (1 << UDC_EP0OUT_IX)) {\n\t\tDBG(dev, \"CNAK pending for ep%d\\n\", UDC_EP0OUT_IX);\n\t\t \n\t\treg = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\t\treg |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\twritel(reg, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\t\tdev->ep[UDC_EP0OUT_IX].naking = 0;\n\t\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX],\n\t\t\t\tdev->ep[UDC_EP0OUT_IX].num);\n\t}\n}\n\n \nstatic void udc_ep0_set_rde(struct udc *dev)\n{\n\tif (use_dma) {\n\t\t \n\t\tif (!dev->data_ep_enabled || dev->data_ep_queued) {\n\t\t\tudc_set_rde(dev);\n\t\t} else {\n\t\t\t \n\t\t\tif (set_rde != 0 && !timer_pending(&udc_timer)) {\n\t\t\t\tudc_timer.expires =\n\t\t\t\t\tjiffies + HZ/UDC_RDE_TIMER_DIV;\n\t\t\t\tset_rde = 1;\n\t\t\t\tif (!stop_timer)\n\t\t\t\t\tadd_timer(&udc_timer);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n \nstatic irqreturn_t udc_data_out_isr(struct udc *dev, int ep_ix)\n{\n\tirqreturn_t\t\tret_val = IRQ_NONE;\n\tu32\t\t\ttmp;\n\tstruct udc_ep\t\t*ep;\n\tstruct udc_request\t*req;\n\tunsigned int\t\tcount;\n\tstruct udc_data_dma\t*td = NULL;\n\tunsigned\t\tdma_done;\n\n\tVDBG(dev, \"ep%d irq\\n\", ep_ix);\n\tep = &dev->ep[ep_ix];\n\n\ttmp = readl(&ep->regs->sts);\n\tif (use_dma) {\n\t\t \n\t\tif (tmp & AMD_BIT(UDC_EPSTS_BNA)) {\n\t\t\tDBG(dev, \"BNA ep%dout occurred - DESPTR = %x\\n\",\n\t\t\t\t\tep->num, readl(&ep->regs->desptr));\n\t\t\t \n\t\t\twritel(tmp | AMD_BIT(UDC_EPSTS_BNA), &ep->regs->sts);\n\t\t\tif (!ep->cancel_transfer)\n\t\t\t\tep->bna_occurred = 1;\n\t\t\telse\n\t\t\t\tep->cancel_transfer = 0;\n\t\t\tret_val = IRQ_HANDLED;\n\t\t\tgoto finished;\n\t\t}\n\t}\n\t \n\tif (tmp & AMD_BIT(UDC_EPSTS_HE)) {\n\t\tdev_err(dev->dev, \"HE ep%dout occurred\\n\", ep->num);\n\n\t\t \n\t\twritel(tmp | AMD_BIT(UDC_EPSTS_HE), &ep->regs->sts);\n\t\tret_val = IRQ_HANDLED;\n\t\tgoto finished;\n\t}\n\n\tif (!list_empty(&ep->queue)) {\n\n\t\t \n\t\treq = list_entry(ep->queue.next,\n\t\t\tstruct udc_request, queue);\n\t} else {\n\t\treq = NULL;\n\t\tudc_rxfifo_pending = 1;\n\t}\n\tVDBG(dev, \"req = %p\\n\", req);\n\t \n\tif (!use_dma) {\n\n\t\t \n\t\tif (req && udc_rxfifo_read(ep, req)) {\n\t\t\tret_val = IRQ_HANDLED;\n\n\t\t\t \n\t\t\tcomplete_req(ep, req, 0);\n\t\t\t \n\t\t\tif (!list_empty(&ep->queue) && !ep->halted) {\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct udc_request, queue);\n\t\t\t} else\n\t\t\t\treq = NULL;\n\t\t}\n\n\t \n\t} else if (!ep->cancel_transfer && req) {\n\t\tret_val = IRQ_HANDLED;\n\n\t\t \n\t\tif (!use_dma_ppb) {\n\t\t\tdma_done = AMD_GETBITS(req->td_data->status,\n\t\t\t\t\t\tUDC_DMA_OUT_STS_BS);\n\t\t \n\t\t} else {\n\t\t\t \n\t\t\tif (ep->bna_occurred) {\n\t\t\t\tVDBG(dev, \"Recover desc. from BNA dummy\\n\");\n\t\t\t\tmemcpy(req->td_data, ep->bna_dummy_req->td_data,\n\t\t\t\t\t\tsizeof(struct udc_data_dma));\n\t\t\t\tep->bna_occurred = 0;\n\t\t\t\tudc_init_bna_dummy(ep->req);\n\t\t\t}\n\t\t\ttd = udc_get_last_dma_desc(req);\n\t\t\tdma_done = AMD_GETBITS(td->status, UDC_DMA_OUT_STS_BS);\n\t\t}\n\t\tif (dma_done == UDC_DMA_OUT_STS_BS_DMA_DONE) {\n\t\t\t \n\t\t\tif (!use_dma_ppb) {\n\t\t\t\t \n\t\t\t\tcount = AMD_GETBITS(req->td_data->status,\n\t\t\t\t\t\tUDC_DMA_OUT_STS_RXBYTES);\n\t\t\t\tVDBG(dev, \"rx bytes=%u\\n\", count);\n\t\t\t \n\t\t\t} else {\n\t\t\t\tVDBG(dev, \"req->td_data=%p\\n\", req->td_data);\n\t\t\t\tVDBG(dev, \"last desc = %p\\n\", td);\n\t\t\t\t \n\t\t\t\tif (use_dma_ppb_du) {\n\t\t\t\t\t \n\t\t\t\t\tcount = udc_get_ppbdu_rxbytes(req);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tcount = AMD_GETBITS(td->status,\n\t\t\t\t\t\tUDC_DMA_OUT_STS_RXBYTES);\n\t\t\t\t\tif (!count && req->req.length\n\t\t\t\t\t\t== UDC_DMA_MAXPACKET) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tcount = UDC_DMA_MAXPACKET;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tVDBG(dev, \"last desc rx bytes=%u\\n\", count);\n\t\t\t}\n\n\t\t\ttmp = req->req.length - req->req.actual;\n\t\t\tif (count > tmp) {\n\t\t\t\tif ((tmp % ep->ep.maxpacket) != 0) {\n\t\t\t\t\tDBG(dev, \"%s: rx %db, space=%db\\n\",\n\t\t\t\t\t\tep->ep.name, count, tmp);\n\t\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\t}\n\t\t\t\tcount = tmp;\n\t\t\t}\n\t\t\treq->req.actual += count;\n\t\t\treq->dma_going = 0;\n\t\t\t \n\t\t\tcomplete_req(ep, req, 0);\n\n\t\t\t \n\t\t\tif (!list_empty(&ep->queue) && !ep->halted) {\n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct udc_request,\n\t\t\t\t\tqueue);\n\t\t\t\t \n\t\t\t\tif (req->dma_going == 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (prep_dma(ep, req, GFP_ATOMIC) != 0)\n\t\t\t\t\t\tgoto finished;\n\t\t\t\t\t \n\t\t\t\t\twritel(req->td_phys,\n\t\t\t\t\t\t&ep->regs->desptr);\n\t\t\t\t\treq->dma_going = 1;\n\t\t\t\t\t \n\t\t\t\t\tudc_set_rde(dev);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (ep->bna_dummy_req) {\n\t\t\t\t\t \n\t\t\t\t\twritel(ep->bna_dummy_req->td_phys,\n\t\t\t\t\t\t&ep->regs->desptr);\n\t\t\t\t\tep->bna_occurred = 0;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (set_rde != 0\n\t\t\t\t\t\t&& !timer_pending(&udc_timer)) {\n\t\t\t\t\tudc_timer.expires =\n\t\t\t\t\t\tjiffies\n\t\t\t\t\t\t+ HZ*UDC_RDE_TIMER_SECONDS;\n\t\t\t\t\tset_rde = 1;\n\t\t\t\t\tif (!stop_timer)\n\t\t\t\t\t\tadd_timer(&udc_timer);\n\t\t\t\t}\n\t\t\t\tif (ep->num != UDC_EP0OUT_IX)\n\t\t\t\t\tdev->data_ep_queued = 0;\n\t\t\t}\n\n\t\t} else {\n\t\t\t \n\t\t\tudc_set_rde(dev);\n\t\t}\n\n\t} else if (ep->cancel_transfer) {\n\t\tret_val = IRQ_HANDLED;\n\t\tep->cancel_transfer = 0;\n\t}\n\n\t \n\tif (cnak_pending) {\n\t\t \n\t\tif (readl(&dev->regs->sts) & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\n\t\t\tudc_process_cnak_queue(dev);\n\t}\n\n\t \n\twritel(UDC_EPSTS_OUT_CLEAR, &ep->regs->sts);\nfinished:\n\treturn ret_val;\n}\n\n \nstatic irqreturn_t udc_data_in_isr(struct udc *dev, int ep_ix)\n{\n\tirqreturn_t ret_val = IRQ_NONE;\n\tu32 tmp;\n\tu32 epsts;\n\tstruct udc_ep *ep;\n\tstruct udc_request *req;\n\tstruct udc_data_dma *td;\n\tunsigned len;\n\n\tep = &dev->ep[ep_ix];\n\n\tepsts = readl(&ep->regs->sts);\n\tif (use_dma) {\n\t\t \n\t\tif (epsts & AMD_BIT(UDC_EPSTS_BNA)) {\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"BNA ep%din occurred - DESPTR = %08lx\\n\",\n\t\t\t\tep->num,\n\t\t\t\t(unsigned long) readl(&ep->regs->desptr));\n\n\t\t\t \n\t\t\twritel(epsts, &ep->regs->sts);\n\t\t\tret_val = IRQ_HANDLED;\n\t\t\tgoto finished;\n\t\t}\n\t}\n\t \n\tif (epsts & AMD_BIT(UDC_EPSTS_HE)) {\n\t\tdev_err(dev->dev,\n\t\t\t\"HE ep%dn occurred - DESPTR = %08lx\\n\",\n\t\t\tep->num, (unsigned long) readl(&ep->regs->desptr));\n\n\t\t \n\t\twritel(epsts | AMD_BIT(UDC_EPSTS_HE), &ep->regs->sts);\n\t\tret_val = IRQ_HANDLED;\n\t\tgoto finished;\n\t}\n\n\t \n\tif (epsts & AMD_BIT(UDC_EPSTS_TDC)) {\n\t\tVDBG(dev, \"TDC set- completion\\n\");\n\t\tret_val = IRQ_HANDLED;\n\t\tif (!ep->cancel_transfer && !list_empty(&ep->queue)) {\n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct udc_request, queue);\n\t\t\t \n\t\t\tif (use_dma_ppb_du) {\n\t\t\t\ttd = udc_get_last_dma_desc(req);\n\t\t\t\tif (td)\n\t\t\t\t\treq->req.actual = req->req.length;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treq->req.actual = req->req.length;\n\t\t\t}\n\n\t\t\tif (req->req.actual == req->req.length) {\n\t\t\t\t \n\t\t\t\tcomplete_req(ep, req, 0);\n\t\t\t\treq->dma_going = 0;\n\t\t\t\t \n\t\t\t\tif (list_empty(&ep->queue)) {\n\t\t\t\t\t \n\t\t\t\t\ttmp = readl(&dev->regs->ep_irqmsk);\n\t\t\t\t\ttmp |= AMD_BIT(ep->num);\n\t\t\t\t\twritel(tmp, &dev->regs->ep_irqmsk);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tep->cancel_transfer = 0;\n\n\t}\n\t \n\tif ((epsts & AMD_BIT(UDC_EPSTS_IN))\n\t\t\t&& !(epsts & AMD_BIT(UDC_EPSTS_TDC))) {\n\t\tret_val = IRQ_HANDLED;\n\t\tif (!list_empty(&ep->queue)) {\n\t\t\t \n\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\tstruct udc_request, queue);\n\t\t\t \n\t\t\tif (!use_dma) {\n\t\t\t\t \n\t\t\t\tudc_txfifo_write(ep, &req->req);\n\t\t\t\tlen = req->req.length - req->req.actual;\n\t\t\t\tif (len > ep->ep.maxpacket)\n\t\t\t\t\tlen = ep->ep.maxpacket;\n\t\t\t\treq->req.actual += len;\n\t\t\t\tif (req->req.actual == req->req.length\n\t\t\t\t\t|| (len != ep->ep.maxpacket)) {\n\t\t\t\t\t \n\t\t\t\t\tcomplete_req(ep, req, 0);\n\t\t\t\t}\n\t\t\t \n\t\t\t} else if (req && !req->dma_going) {\n\t\t\t\tVDBG(dev, \"IN DMA : req=%p req->td_data=%p\\n\",\n\t\t\t\t\treq, req->td_data);\n\t\t\t\tif (req->td_data) {\n\n\t\t\t\t\treq->dma_going = 1;\n\n\t\t\t\t\t \n\t\t\t\t\tif (use_dma_ppb && req->req.length >\n\t\t\t\t\t\t\tep->ep.maxpacket) {\n\t\t\t\t\t\treq->td_data->status &=\n\t\t\t\t\t\t\tAMD_CLEAR_BIT(\n\t\t\t\t\t\t\tUDC_DMA_IN_STS_L);\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\twritel(req->td_phys, &ep->regs->desptr);\n\n\t\t\t\t\t \n\t\t\t\t\treq->td_data->status =\n\t\t\t\t\t\tAMD_ADDBITS(\n\t\t\t\t\t\treq->td_data->status,\n\t\t\t\t\t\tUDC_DMA_IN_STS_BS_HOST_READY,\n\t\t\t\t\t\tUDC_DMA_IN_STS_BS);\n\n\t\t\t\t\t \n\t\t\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\t\t\ttmp |= AMD_BIT(UDC_EPCTL_P);\n\t\t\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else if (!use_dma && ep->in) {\n\t\t\t \n\t\t\ttmp = readl(\n\t\t\t\t&dev->regs->ep_irqmsk);\n\t\t\ttmp |= AMD_BIT(ep->num);\n\t\t\twritel(tmp,\n\t\t\t\t&dev->regs->ep_irqmsk);\n\t\t}\n\t}\n\t \n\twritel(epsts, &ep->regs->sts);\n\nfinished:\n\treturn ret_val;\n\n}\n\n \nstatic irqreturn_t udc_control_out_isr(struct udc *dev)\n__releases(dev->lock)\n__acquires(dev->lock)\n{\n\tirqreturn_t ret_val = IRQ_NONE;\n\tu32 tmp;\n\tint setup_supported;\n\tu32 count;\n\tint set = 0;\n\tstruct udc_ep\t*ep;\n\tstruct udc_ep\t*ep_tmp;\n\n\tep = &dev->ep[UDC_EP0OUT_IX];\n\n\t \n\twritel(AMD_BIT(UDC_EPINT_OUT_EP0), &dev->regs->ep_irqsts);\n\n\ttmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->sts);\n\t \n\tif (tmp & AMD_BIT(UDC_EPSTS_BNA)) {\n\t\tVDBG(dev, \"ep0: BNA set\\n\");\n\t\twritel(AMD_BIT(UDC_EPSTS_BNA),\n\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->sts);\n\t\tep->bna_occurred = 1;\n\t\tret_val = IRQ_HANDLED;\n\t\tgoto finished;\n\t}\n\n\t \n\ttmp = AMD_GETBITS(tmp, UDC_EPSTS_OUT);\n\tVDBG(dev, \"data_typ = %x\\n\", tmp);\n\n\t \n\tif (tmp == UDC_EPSTS_OUT_SETUP) {\n\t\tret_val = IRQ_HANDLED;\n\n\t\tep->dev->stall_ep0in = 0;\n\t\tdev->waiting_zlp_ack_ep0in = 0;\n\n\t\t \n\t\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\ttmp |= AMD_BIT(UDC_EPCTL_SNAK);\n\t\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\tdev->ep[UDC_EP0IN_IX].naking = 1;\n\t\t \n\t\tif (use_dma) {\n\n\t\t\t \n\t\t\twritel(UDC_EPSTS_OUT_CLEAR,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->sts);\n\n\t\t\tsetup_data.data[0] =\n\t\t\t\tdev->ep[UDC_EP0OUT_IX].td_stp->data12;\n\t\t\tsetup_data.data[1] =\n\t\t\t\tdev->ep[UDC_EP0OUT_IX].td_stp->data34;\n\t\t\t \n\t\t\tdev->ep[UDC_EP0OUT_IX].td_stp->status =\n\t\t\t\t\tUDC_DMA_STP_STS_BS_HOST_READY;\n\t\t} else {\n\t\t\t \n\t\t\tudc_rxfifo_read_dwords(dev, setup_data.data, 2);\n\t\t}\n\n\t\t \n\t\tif ((setup_data.request.bRequestType & USB_DIR_IN) != 0) {\n\t\t\tdev->gadget.ep0 = &dev->ep[UDC_EP0IN_IX].ep;\n\t\t\t \n\t\t\tudc_ep0_set_rde(dev);\n\t\t\tset = 0;\n\t\t} else {\n\t\t\tdev->gadget.ep0 = &dev->ep[UDC_EP0OUT_IX].ep;\n\t\t\t \n\t\t\tif (ep->bna_dummy_req) {\n\t\t\t\t \n\t\t\t\twritel(ep->bna_dummy_req->td_phys,\n\t\t\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->desptr);\n\t\t\t\tep->bna_occurred = 0;\n\t\t\t}\n\n\t\t\tset = 1;\n\t\t\tdev->ep[UDC_EP0OUT_IX].naking = 1;\n\t\t\t \n\t\t\tset_rde = 1;\n\t\t\tif (!timer_pending(&udc_timer)) {\n\t\t\t\tudc_timer.expires = jiffies +\n\t\t\t\t\t\t\tHZ/UDC_RDE_TIMER_DIV;\n\t\t\t\tif (!stop_timer)\n\t\t\t\t\tadd_timer(&udc_timer);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (setup_data.data[0] == UDC_MSCRES_DWORD0\n\t\t\t\t&& setup_data.data[1] == UDC_MSCRES_DWORD1) {\n\t\t\tDBG(dev, \"MSC Reset\\n\");\n\t\t\t \n\t\t\tep_tmp = &udc->ep[UDC_EPIN_IX];\n\t\t\tudc_set_halt(&ep_tmp->ep, 0);\n\t\t\tep_tmp = &udc->ep[UDC_EPOUT_IX];\n\t\t\tudc_set_halt(&ep_tmp->ep, 0);\n\t\t}\n\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\tsetup_supported = dev->driver->setup(&dev->gadget,\n\t\t\t\t\t\t&setup_data.request);\n\t\tspin_lock(&dev->lock);\n\n\t\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t \n\t\tif (setup_supported >= 0 && setup_supported <\n\t\t\t\tUDC_EP0IN_MAXPACKET) {\n\t\t\t \n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t\tdev->ep[UDC_EP0IN_IX].naking = 0;\n\t\t\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0IN_IX], UDC_EP0IN_IX);\n\n\t\t \n\t\t} else if (setup_supported < 0) {\n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_S);\n\t\t\twritel(tmp, &dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t} else\n\t\t\tdev->waiting_zlp_ack_ep0in = 1;\n\n\n\t\t \n\t\tif (!set) {\n\t\t\ttmp = readl(&dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_CNAK);\n\t\t\twritel(tmp, &dev->ep[UDC_EP0OUT_IX].regs->ctl);\n\t\t\tdev->ep[UDC_EP0OUT_IX].naking = 0;\n\t\t\tUDC_QUEUE_CNAK(&dev->ep[UDC_EP0OUT_IX], UDC_EP0OUT_IX);\n\t\t}\n\n\t\tif (!use_dma) {\n\t\t\t \n\t\t\twritel(UDC_EPSTS_OUT_CLEAR,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->sts);\n\t\t}\n\n\t \n\t} else if (tmp == UDC_EPSTS_OUT_DATA) {\n\t\t \n\t\twritel(UDC_EPSTS_OUT_CLEAR, &dev->ep[UDC_EP0OUT_IX].regs->sts);\n\n\t\t \n\t\tif (use_dma) {\n\t\t\t \n\t\t\tif (list_empty(&dev->ep[UDC_EP0OUT_IX].queue)) {\n\t\t\t\tVDBG(dev, \"ZLP\\n\");\n\n\t\t\t\t \n\t\t\t\tdev->ep[UDC_EP0OUT_IX].td->status =\n\t\t\t\t\tAMD_ADDBITS(\n\t\t\t\t\tdev->ep[UDC_EP0OUT_IX].td->status,\n\t\t\t\t\tUDC_DMA_OUT_STS_BS_HOST_READY,\n\t\t\t\t\tUDC_DMA_OUT_STS_BS);\n\t\t\t\t \n\t\t\t\tudc_ep0_set_rde(dev);\n\t\t\t\tret_val = IRQ_HANDLED;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tret_val |= udc_data_out_isr(dev, UDC_EP0OUT_IX);\n\t\t\t\t \n\t\t\t\twritel(dev->ep[UDC_EP0OUT_IX].td_phys,\n\t\t\t\t\t&dev->ep[UDC_EP0OUT_IX].regs->desptr);\n\t\t\t\t \n\t\t\t\tudc_ep0_set_rde(dev);\n\t\t\t}\n\t\t} else {\n\n\t\t\t \n\t\t\tcount = readl(&dev->ep[UDC_EP0OUT_IX].regs->sts);\n\t\t\tcount = AMD_GETBITS(count, UDC_EPSTS_RX_PKT_SIZE);\n\t\t\t \n\t\t\tcount = 0;\n\n\t\t\t \n\t\t\tif (count != 0) {\n\t\t\t\tret_val |= udc_data_out_isr(dev, UDC_EP0OUT_IX);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\treadl(&dev->ep[UDC_EP0OUT_IX].regs->confirm);\n\t\t\t\tret_val = IRQ_HANDLED;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (cnak_pending) {\n\t\t \n\t\tif (readl(&dev->regs->sts) & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\n\t\t\tudc_process_cnak_queue(dev);\n\t}\n\nfinished:\n\treturn ret_val;\n}\n\n \nstatic irqreturn_t udc_control_in_isr(struct udc *dev)\n{\n\tirqreturn_t ret_val = IRQ_NONE;\n\tu32 tmp;\n\tstruct udc_ep *ep;\n\tstruct udc_request *req;\n\tunsigned len;\n\n\tep = &dev->ep[UDC_EP0IN_IX];\n\n\t \n\twritel(AMD_BIT(UDC_EPINT_IN_EP0), &dev->regs->ep_irqsts);\n\n\ttmp = readl(&dev->ep[UDC_EP0IN_IX].regs->sts);\n\t \n\tif (tmp & AMD_BIT(UDC_EPSTS_TDC)) {\n\t\tVDBG(dev, \"isr: TDC clear\\n\");\n\t\tret_val = IRQ_HANDLED;\n\n\t\t \n\t\twritel(AMD_BIT(UDC_EPSTS_TDC),\n\t\t\t\t&dev->ep[UDC_EP0IN_IX].regs->sts);\n\n\t \n\t} else if (tmp & AMD_BIT(UDC_EPSTS_IN)) {\n\t\tret_val = IRQ_HANDLED;\n\n\t\tif (ep->dma) {\n\t\t\t \n\t\t\twritel(AMD_BIT(UDC_EPSTS_IN),\n\t\t\t\t&dev->ep[UDC_EP0IN_IX].regs->sts);\n\t\t}\n\t\tif (dev->stall_ep0in) {\n\t\t\tDBG(dev, \"stall ep0in\\n\");\n\t\t\t \n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\ttmp |= AMD_BIT(UDC_EPCTL_S);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t} else {\n\t\t\tif (!list_empty(&ep->queue)) {\n\t\t\t\t \n\t\t\t\treq = list_entry(ep->queue.next,\n\t\t\t\t\t\tstruct udc_request, queue);\n\n\t\t\t\tif (ep->dma) {\n\t\t\t\t\t \n\t\t\t\t\twritel(req->td_phys, &ep->regs->desptr);\n\t\t\t\t\t \n\t\t\t\t\treq->td_data->status =\n\t\t\t\t\t\tAMD_ADDBITS(\n\t\t\t\t\t\treq->td_data->status,\n\t\t\t\t\t\tUDC_DMA_STP_STS_BS_HOST_READY,\n\t\t\t\t\t\tUDC_DMA_STP_STS_BS);\n\n\t\t\t\t\t \n\t\t\t\t\ttmp =\n\t\t\t\t\treadl(&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\t\t\t\t\ttmp |= AMD_BIT(UDC_EPCTL_P);\n\t\t\t\t\twritel(tmp,\n\t\t\t\t\t&dev->ep[UDC_EP0IN_IX].regs->ctl);\n\n\t\t\t\t\t \n\t\t\t\t\treq->req.actual = req->req.length;\n\n\t\t\t\t\t \n\t\t\t\t\tcomplete_req(ep, req, 0);\n\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tudc_txfifo_write(ep, &req->req);\n\n\t\t\t\t\t \n\t\t\t\t\tlen = req->req.length - req->req.actual;\n\t\t\t\t\tif (len > ep->ep.maxpacket)\n\t\t\t\t\t\tlen = ep->ep.maxpacket;\n\n\t\t\t\t\treq->req.actual += len;\n\t\t\t\t\tif (req->req.actual == req->req.length\n\t\t\t\t\t\t|| (len != ep->ep.maxpacket)) {\n\t\t\t\t\t\t \n\t\t\t\t\t\tcomplete_req(ep, req, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\tep->halted = 0;\n\t\tdev->stall_ep0in = 0;\n\t\tif (!ep->dma) {\n\t\t\t \n\t\t\twritel(AMD_BIT(UDC_EPSTS_IN),\n\t\t\t\t&dev->ep[UDC_EP0IN_IX].regs->sts);\n\t\t}\n\t}\n\n\treturn ret_val;\n}\n\n\n \nstatic irqreturn_t udc_dev_isr(struct udc *dev, u32 dev_irq)\n__releases(dev->lock)\n__acquires(dev->lock)\n{\n\tirqreturn_t ret_val = IRQ_NONE;\n\tu32 tmp;\n\tu32 cfg;\n\tstruct udc_ep *ep;\n\tu16 i;\n\tu8 udc_csr_epix;\n\n\t \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_SC)) {\n\t\tret_val = IRQ_HANDLED;\n\n\t\t \n\t\ttmp = readl(&dev->regs->sts);\n\t\tcfg = AMD_GETBITS(tmp, UDC_DEVSTS_CFG);\n\t\tDBG(dev, \"SET_CONFIG interrupt: config=%d\\n\", cfg);\n\t\tdev->cur_config = cfg;\n\t\tdev->set_cfg_not_acked = 1;\n\n\t\t \n\t\tmemset(&setup_data, 0 , sizeof(union udc_setup_data));\n\t\tsetup_data.request.bRequest = USB_REQ_SET_CONFIGURATION;\n\t\tsetup_data.request.wValue = cpu_to_le16(dev->cur_config);\n\n\t\t \n\t\tfor (i = 0; i < UDC_EP_NUM; i++) {\n\t\t\tep = &dev->ep[i];\n\t\t\tif (ep->in) {\n\n\t\t\t\t \n\t\t\t\tudc_csr_epix = ep->num;\n\n\n\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\n\t\t\t}\n\n\t\t\ttmp = readl(&dev->csr->ne[udc_csr_epix]);\n\t\t\t \n\t\t\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_config,\n\t\t\t\t\t\tUDC_CSR_NE_CFG);\n\t\t\t \n\t\t\twritel(tmp, &dev->csr->ne[udc_csr_epix]);\n\n\t\t\t \n\t\t\tep->halted = 0;\n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\ttmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t}\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\ttmp = dev->driver->setup(&dev->gadget, &setup_data.request);\n\t\tspin_lock(&dev->lock);\n\n\t}  \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_SI)) {\n\t\tret_val = IRQ_HANDLED;\n\n\t\tdev->set_cfg_not_acked = 1;\n\t\t \n\t\ttmp = readl(&dev->regs->sts);\n\t\tdev->cur_alt = AMD_GETBITS(tmp, UDC_DEVSTS_ALT);\n\t\tdev->cur_intf = AMD_GETBITS(tmp, UDC_DEVSTS_INTF);\n\n\t\t \n\t\tmemset(&setup_data, 0 , sizeof(union udc_setup_data));\n\t\tsetup_data.request.bRequest = USB_REQ_SET_INTERFACE;\n\t\tsetup_data.request.bRequestType = USB_RECIP_INTERFACE;\n\t\tsetup_data.request.wValue = cpu_to_le16(dev->cur_alt);\n\t\tsetup_data.request.wIndex = cpu_to_le16(dev->cur_intf);\n\n\t\tDBG(dev, \"SET_INTERFACE interrupt: alt=%d intf=%d\\n\",\n\t\t\t\tdev->cur_alt, dev->cur_intf);\n\n\t\t \n\t\tfor (i = 0; i < UDC_EP_NUM; i++) {\n\t\t\tep = &dev->ep[i];\n\t\t\tif (ep->in) {\n\n\t\t\t\t \n\t\t\t\tudc_csr_epix = ep->num;\n\n\n\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tudc_csr_epix = ep->num - UDC_CSR_EP_OUT_IX_OFS;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\ttmp = readl(&dev->csr->ne[udc_csr_epix]);\n\t\t\t \n\t\t\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_intf,\n\t\t\t\t\t\tUDC_CSR_NE_INTF);\n\t\t\t \n\t\t\t \n\t\t\ttmp = AMD_ADDBITS(tmp, ep->dev->cur_alt,\n\t\t\t\t\t\tUDC_CSR_NE_ALT);\n\t\t\t \n\t\t\twritel(tmp, &dev->csr->ne[udc_csr_epix]);\n\n\t\t\t \n\t\t\tep->halted = 0;\n\t\t\ttmp = readl(&ep->regs->ctl);\n\t\t\ttmp = tmp & AMD_CLEAR_BIT(UDC_EPCTL_S);\n\t\t\twritel(tmp, &ep->regs->ctl);\n\t\t}\n\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\ttmp = dev->driver->setup(&dev->gadget, &setup_data.request);\n\t\tspin_lock(&dev->lock);\n\n\t}  \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_UR)) {\n\t\tDBG(dev, \"USB Reset interrupt\\n\");\n\t\tret_val = IRQ_HANDLED;\n\n\t\t \n\t\tsoft_reset_occured = 0;\n\n\t\tdev->waiting_zlp_ack_ep0in = 0;\n\t\tdev->set_cfg_not_acked = 0;\n\n\t\t \n\t\tudc_mask_unused_interrupts(dev);\n\n\t\t \n\t\tspin_unlock(&dev->lock);\n\t\tif (dev->sys_suspended && dev->driver->resume) {\n\t\t\tdev->driver->resume(&dev->gadget);\n\t\t\tdev->sys_suspended = 0;\n\t\t}\n\t\tusb_gadget_udc_reset(&dev->gadget, dev->driver);\n\t\tspin_lock(&dev->lock);\n\n\t\t \n\t\tempty_req_queue(&dev->ep[UDC_EP0IN_IX]);\n\t\tep_init(dev->regs, &dev->ep[UDC_EP0IN_IX]);\n\n\t\t \n\t\ttmp = readl(&dev->regs->sts);\n\t\tif (!(tmp & AMD_BIT(UDC_DEVSTS_RXFIFO_EMPTY))\n\t\t\t\t&& !soft_reset_after_usbreset_occured) {\n\t\t\tudc_soft_reset(dev);\n\t\t\tsoft_reset_after_usbreset_occured++;\n\t\t}\n\n\t\t \n\t\tDBG(dev, \"DMA machine reset\\n\");\n\t\ttmp = readl(&dev->regs->cfg);\n\t\twritel(tmp | AMD_BIT(UDC_DEVCFG_DMARST), &dev->regs->cfg);\n\t\twritel(tmp, &dev->regs->cfg);\n\n\t\t \n\t\tudc_basic_init(dev);\n\n\t\t \n\t\tudc_enable_dev_setup_interrupts(dev);\n\n\t\t \n\t\ttmp = readl(&dev->regs->irqmsk);\n\t\ttmp &= AMD_UNMASK_BIT(UDC_DEVINT_US);\n\t\twritel(tmp, &dev->regs->irqmsk);\n\n\t}  \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_US)) {\n\t\tDBG(dev, \"USB Suspend interrupt\\n\");\n\t\tret_val = IRQ_HANDLED;\n\t\tif (dev->driver->suspend) {\n\t\t\tspin_unlock(&dev->lock);\n\t\t\tdev->sys_suspended = 1;\n\t\t\tdev->driver->suspend(&dev->gadget);\n\t\t\tspin_lock(&dev->lock);\n\t\t}\n\t}  \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_ENUM)) {\n\t\tDBG(dev, \"ENUM interrupt\\n\");\n\t\tret_val = IRQ_HANDLED;\n\t\tsoft_reset_after_usbreset_occured = 0;\n\n\t\t \n\t\tempty_req_queue(&dev->ep[UDC_EP0IN_IX]);\n\t\tep_init(dev->regs, &dev->ep[UDC_EP0IN_IX]);\n\n\t\t \n\t\tudc_setup_endpoints(dev);\n\t\tdev_info(dev->dev, \"Connect: %s\\n\",\n\t\t\t usb_speed_string(dev->gadget.speed));\n\n\t\t \n\t\tactivate_control_endpoints(dev);\n\n\t\t \n\t\tudc_enable_ep0_interrupts(dev);\n\t}\n\t \n\tif (dev_irq & AMD_BIT(UDC_DEVINT_SVC)) {\n\t\tDBG(dev, \"USB SVC interrupt\\n\");\n\t\tret_val = IRQ_HANDLED;\n\n\t\t \n\t\ttmp = readl(&dev->regs->sts);\n\t\tif (!(tmp & AMD_BIT(UDC_DEVSTS_SESSVLD))) {\n\t\t\t \n\t\t\ttmp = readl(&dev->regs->irqmsk);\n\t\t\ttmp |= AMD_BIT(UDC_DEVINT_US);\n\t\t\twritel(tmp, &dev->regs->irqmsk);\n\t\t\tDBG(dev, \"USB Disconnect (session valid low)\\n\");\n\t\t\t \n\t\t\tusb_disconnect(udc);\n\t\t}\n\n\t}\n\n\treturn ret_val;\n}\n\n \nirqreturn_t udc_irq(int irq, void *pdev)\n{\n\tstruct udc *dev = pdev;\n\tu32 reg;\n\tu16 i;\n\tu32 ep_irq;\n\tirqreturn_t ret_val = IRQ_NONE;\n\n\tspin_lock(&dev->lock);\n\n\t \n\treg = readl(&dev->regs->ep_irqsts);\n\tif (reg) {\n\t\tif (reg & AMD_BIT(UDC_EPINT_OUT_EP0))\n\t\t\tret_val |= udc_control_out_isr(dev);\n\t\tif (reg & AMD_BIT(UDC_EPINT_IN_EP0))\n\t\t\tret_val |= udc_control_in_isr(dev);\n\n\t\t \n\t\tfor (i = 1; i < UDC_EP_NUM; i++) {\n\t\t\tep_irq = 1 << i;\n\t\t\tif (!(reg & ep_irq) || i == UDC_EPINT_OUT_EP0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\twritel(ep_irq, &dev->regs->ep_irqsts);\n\n\t\t\t \n\t\t\tif (i > UDC_EPIN_NUM)\n\t\t\t\tret_val |= udc_data_out_isr(dev, i);\n\t\t\telse\n\t\t\t\tret_val |= udc_data_in_isr(dev, i);\n\t\t}\n\n\t}\n\n\n\t \n\treg = readl(&dev->regs->irqsts);\n\tif (reg) {\n\t\t \n\t\twritel(reg, &dev->regs->irqsts);\n\t\tret_val |= udc_dev_isr(dev, reg);\n\t}\n\n\n\tspin_unlock(&dev->lock);\n\treturn ret_val;\n}\nEXPORT_SYMBOL_GPL(udc_irq);\n\n \nvoid gadget_release(struct device *pdev)\n{\n\tstruct amd5536udc *dev = dev_get_drvdata(pdev);\n\tkfree(dev);\n}\nEXPORT_SYMBOL_GPL(gadget_release);\n\n \nvoid udc_remove(struct udc *dev)\n{\n\t \n\tstop_timer++;\n\tif (timer_pending(&udc_timer))\n\t\twait_for_completion(&on_exit);\n\tdel_timer_sync(&udc_timer);\n\t \n\tstop_pollstall_timer++;\n\tif (timer_pending(&udc_pollstall_timer))\n\t\twait_for_completion(&on_pollstall_exit);\n\tdel_timer_sync(&udc_pollstall_timer);\n\tudc = NULL;\n}\nEXPORT_SYMBOL_GPL(udc_remove);\n\n \nvoid free_dma_pools(struct udc *dev)\n{\n\tdma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td,\n\t\t      dev->ep[UDC_EP0OUT_IX].td_phys);\n\tdma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td_stp,\n\t\t      dev->ep[UDC_EP0OUT_IX].td_stp_dma);\n\tdma_pool_destroy(dev->stp_requests);\n\tdma_pool_destroy(dev->data_requests);\n}\nEXPORT_SYMBOL_GPL(free_dma_pools);\n\n \nint init_dma_pools(struct udc *dev)\n{\n\tstruct udc_stp_dma\t*td_stp;\n\tstruct udc_data_dma\t*td_data;\n\tint retval;\n\n\t \n\tif (use_dma_ppb) {\n\t\tuse_dma_bufferfill_mode = 0;\n\t} else {\n\t\tuse_dma_ppb_du = 0;\n\t\tuse_dma_bufferfill_mode = 1;\n\t}\n\n\t \n\tdev->data_requests = dma_pool_create(\"data_requests\", dev->dev,\n\t\tsizeof(struct udc_data_dma), 0, 0);\n\tif (!dev->data_requests) {\n\t\tDBG(dev, \"can't get request data pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev->ep[UDC_EP0IN_IX].dma = &dev->regs->ctl;\n\n\t \n\tdev->stp_requests = dma_pool_create(\"setup requests\", dev->dev,\n\t\tsizeof(struct udc_stp_dma), 0, 0);\n\tif (!dev->stp_requests) {\n\t\tDBG(dev, \"can't get stp request pool\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_create_dma_pool;\n\t}\n\t \n\ttd_stp = dma_pool_alloc(dev->stp_requests, GFP_KERNEL,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IX].td_stp_dma);\n\tif (!td_stp) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_dma;\n\t}\n\tdev->ep[UDC_EP0OUT_IX].td_stp = td_stp;\n\n\t \n\ttd_data = dma_pool_alloc(dev->stp_requests, GFP_KERNEL,\n\t\t\t\t&dev->ep[UDC_EP0OUT_IX].td_phys);\n\tif (!td_data) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_alloc_phys;\n\t}\n\tdev->ep[UDC_EP0OUT_IX].td = td_data;\n\treturn 0;\n\nerr_alloc_phys:\n\tdma_pool_free(dev->stp_requests, dev->ep[UDC_EP0OUT_IX].td_stp,\n\t\t      dev->ep[UDC_EP0OUT_IX].td_stp_dma);\nerr_alloc_dma:\n\tdma_pool_destroy(dev->stp_requests);\n\tdev->stp_requests = NULL;\nerr_create_dma_pool:\n\tdma_pool_destroy(dev->data_requests);\n\tdev->data_requests = NULL;\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(init_dma_pools);\n\n \nint udc_probe(struct udc *dev)\n{\n\tchar\t\ttmp[128];\n\tu32\t\treg;\n\tint\t\tretval;\n\n\t \n\tdev->gadget.ops = &udc_ops;\n\n\tdev_set_name(&dev->gadget.dev, \"gadget\");\n\tdev->gadget.name = name;\n\tdev->gadget.max_speed = USB_SPEED_HIGH;\n\n\t \n\tstartup_registers(dev);\n\n\tdev_info(dev->dev, \"%s\\n\", mod_desc);\n\n\tsnprintf(tmp, sizeof(tmp), \"%d\", dev->irq);\n\n\t \n\tif (dev->chiprev == UDC_HSA0_REV ||\n\t    dev->chiprev == UDC_HSB1_REV) {\n\t\tdev_info(dev->dev, \"irq %s, pci mem %08lx, chip rev %02x(Geode5536 %s)\\n\",\n\t\t\t tmp, dev->phys_addr, dev->chiprev,\n\t\t\t (dev->chiprev == UDC_HSA0_REV) ?\n\t\t\t \"A0\" : \"B1\");\n\t\tstrcpy(tmp, UDC_DRIVER_VERSION_STRING);\n\t\tif (dev->chiprev == UDC_HSA0_REV) {\n\t\t\tdev_err(dev->dev, \"chip revision is A0; too old\\n\");\n\t\t\tretval = -ENODEV;\n\t\t\tgoto finished;\n\t\t}\n\t\tdev_info(dev->dev,\n\t\t\t \"driver version: %s(for Geode5536 B1)\\n\", tmp);\n\t}\n\n\tudc = dev;\n\n\tretval = usb_add_gadget_udc_release(udc->dev, &dev->gadget,\n\t\t\t\t\t    gadget_release);\n\tif (retval)\n\t\tgoto finished;\n\n\t \n\ttimer_setup(&udc_timer, udc_timer_function, 0);\n\ttimer_setup(&udc_pollstall_timer, udc_pollstall_timer_function, 0);\n\n\t \n\treg = readl(&dev->regs->ctl);\n\treg |= AMD_BIT(UDC_DEVCTL_SD);\n\twritel(reg, &dev->regs->ctl);\n\n\t \n\tprint_regs(dev);\n\n\treturn 0;\n\nfinished:\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(udc_probe);\n\nMODULE_DESCRIPTION(UDC_MOD_DESCRIPTION);\nMODULE_AUTHOR(\"Thomas Dahlmann\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}