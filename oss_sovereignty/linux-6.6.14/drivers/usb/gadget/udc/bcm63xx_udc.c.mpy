{
  "module_name": "bcm63xx_udc.c",
  "hash_id": "a0054b98e13e52a150eac6cdfb36df04cd5b5e18a81cc02501c6081ec911be6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/bcm63xx_udc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bug.h>\n#include <linux/clk.h>\n#include <linux/compiler.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/platform_device.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/workqueue.h>\n\n#include <bcm63xx_cpu.h>\n#include <bcm63xx_iudma.h>\n#include <bcm63xx_dev_usb_usbd.h>\n#include <bcm63xx_io.h>\n#include <bcm63xx_regs.h>\n\n#define DRV_MODULE_NAME\t\t\"bcm63xx_udc\"\n\nstatic const char bcm63xx_ep0name[] = \"ep0\";\n\nstatic const struct {\n\tconst char *name;\n\tconst struct usb_ep_caps caps;\n} bcm63xx_ep_info[] = {\n#define EP_INFO(_name, _caps) \\\n\t{ \\\n\t\t.name = _name, \\\n\t\t.caps = _caps, \\\n\t}\n\n\tEP_INFO(bcm63xx_ep0name,\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_CONTROL, USB_EP_CAPS_DIR_ALL)),\n\tEP_INFO(\"ep1in-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep2out-bulk\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_BULK, USB_EP_CAPS_DIR_OUT)),\n\tEP_INFO(\"ep3in-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_IN)),\n\tEP_INFO(\"ep4out-int\",\n\t\tUSB_EP_CAPS(USB_EP_CAPS_TYPE_INT, USB_EP_CAPS_DIR_OUT)),\n\n#undef EP_INFO\n};\n\nstatic bool use_fullspeed;\nmodule_param(use_fullspeed, bool, S_IRUGO);\nMODULE_PARM_DESC(use_fullspeed, \"true for fullspeed only\");\n\n \nstatic bool irq_coalesce;\nmodule_param(irq_coalesce, bool, S_IRUGO);\nMODULE_PARM_DESC(irq_coalesce, \"take one IRQ per RX transfer\");\n\n#define BCM63XX_NUM_EP\t\t\t5\n#define BCM63XX_NUM_IUDMA\t\t6\n#define BCM63XX_NUM_FIFO_PAIRS\t\t3\n\n#define IUDMA_RESET_TIMEOUT_US\t\t10000\n\n#define IUDMA_EP0_RXCHAN\t\t0\n#define IUDMA_EP0_TXCHAN\t\t1\n\n#define IUDMA_MAX_FRAGMENT\t\t2048\n#define BCM63XX_MAX_CTRL_PKT\t\t64\n\n#define BCMEP_CTRL\t\t\t0x00\n#define BCMEP_ISOC\t\t\t0x01\n#define BCMEP_BULK\t\t\t0x02\n#define BCMEP_INTR\t\t\t0x03\n\n#define BCMEP_OUT\t\t\t0x00\n#define BCMEP_IN\t\t\t0x01\n\n#define BCM63XX_SPD_FULL\t\t1\n#define BCM63XX_SPD_HIGH\t\t0\n\n#define IUDMA_DMAC_OFFSET\t\t0x200\n#define IUDMA_DMAS_OFFSET\t\t0x400\n\nenum bcm63xx_ep0_state {\n\tEP0_REQUEUE,\n\tEP0_IDLE,\n\tEP0_IN_DATA_PHASE_SETUP,\n\tEP0_IN_DATA_PHASE_COMPLETE,\n\tEP0_OUT_DATA_PHASE_SETUP,\n\tEP0_OUT_DATA_PHASE_COMPLETE,\n\tEP0_OUT_STATUS_PHASE,\n\tEP0_IN_FAKE_STATUS_PHASE,\n\tEP0_SHUTDOWN,\n};\n\nstatic const char __maybe_unused bcm63xx_ep0_state_names[][32] = {\n\t\"REQUEUE\",\n\t\"IDLE\",\n\t\"IN_DATA_PHASE_SETUP\",\n\t\"IN_DATA_PHASE_COMPLETE\",\n\t\"OUT_DATA_PHASE_SETUP\",\n\t\"OUT_DATA_PHASE_COMPLETE\",\n\t\"OUT_STATUS_PHASE\",\n\t\"IN_FAKE_STATUS_PHASE\",\n\t\"SHUTDOWN\",\n};\n\n \nstruct iudma_ch_cfg {\n\tint\t\t\t\tep_num;\n\tint\t\t\t\tn_bds;\n\tint\t\t\t\tep_type;\n\tint\t\t\t\tdir;\n\tint\t\t\t\tn_fifo_slots;\n\tint\t\t\t\tmax_pkt_hs;\n\tint\t\t\t\tmax_pkt_fs;\n};\n\nstatic const struct iudma_ch_cfg iudma_defaults[] = {\n\n\t \n\t[0] = { -1,   4, BCMEP_CTRL, BCMEP_OUT,  32,    64,     64 },\n\t[1] = {  0,   4, BCMEP_CTRL, BCMEP_OUT,  32,    64,     64 },\n\t[2] = {  2,  16, BCMEP_BULK, BCMEP_OUT, 128,   512,     64 },\n\t[3] = {  1,  16, BCMEP_BULK, BCMEP_IN,  128,   512,     64 },\n\t[4] = {  4,   4, BCMEP_INTR, BCMEP_OUT,  32,    64,     64 },\n\t[5] = {  3,   4, BCMEP_INTR, BCMEP_IN,   32,    64,     64 },\n};\n\nstruct bcm63xx_udc;\n\n \nstruct iudma_ch {\n\tunsigned int\t\t\tch_idx;\n\tint\t\t\t\tep_num;\n\tbool\t\t\t\tenabled;\n\tint\t\t\t\tmax_pkt;\n\tbool\t\t\t\tis_tx;\n\tstruct bcm63xx_ep\t\t*bep;\n\tstruct bcm63xx_udc\t\t*udc;\n\n\tstruct bcm_enet_desc\t\t*read_bd;\n\tstruct bcm_enet_desc\t\t*write_bd;\n\tstruct bcm_enet_desc\t\t*end_bd;\n\tint\t\t\t\tn_bds_used;\n\n\tstruct bcm_enet_desc\t\t*bd_ring;\n\tdma_addr_t\t\t\tbd_ring_dma;\n\tunsigned int\t\t\tn_bds;\n};\n\n \nstruct bcm63xx_ep {\n\tunsigned int\t\t\tep_num;\n\tstruct iudma_ch\t\t\t*iudma;\n\tstruct usb_ep\t\t\tep;\n\tstruct bcm63xx_udc\t\t*udc;\n\tstruct list_head\t\tqueue;\n\tunsigned\t\t\thalted:1;\n};\n\n \nstruct bcm63xx_req {\n\tstruct list_head\t\tqueue;\t\t \n\tstruct usb_request\t\treq;\n\tunsigned int\t\t\toffset;\n\tunsigned int\t\t\tbd_bytes;\n\tstruct iudma_ch\t\t\t*iudma;\n};\n\n \nstruct bcm63xx_udc {\n\tspinlock_t\t\t\tlock;\n\n\tstruct device\t\t\t*dev;\n\tstruct bcm63xx_usbd_platform_data *pd;\n\tstruct clk\t\t\t*usbd_clk;\n\tstruct clk\t\t\t*usbh_clk;\n\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\n\tvoid __iomem\t\t\t*usbd_regs;\n\tvoid __iomem\t\t\t*iudma_regs;\n\n\tstruct bcm63xx_ep\t\tbep[BCM63XX_NUM_EP];\n\tstruct iudma_ch\t\t\tiudma[BCM63XX_NUM_IUDMA];\n\n\tint\t\t\t\tcfg;\n\tint\t\t\t\tiface;\n\tint\t\t\t\talt_iface;\n\n\tstruct bcm63xx_req\t\tep0_ctrl_req;\n\tu8\t\t\t\t*ep0_ctrl_buf;\n\n\tint\t\t\t\tep0state;\n\tstruct work_struct\t\tep0_wq;\n\n\tunsigned long\t\t\twedgemap;\n\n\tunsigned\t\t\tep0_req_reset:1;\n\tunsigned\t\t\tep0_req_set_cfg:1;\n\tunsigned\t\t\tep0_req_set_iface:1;\n\tunsigned\t\t\tep0_req_shutdown:1;\n\n\tunsigned\t\t\tep0_req_completed:1;\n\tstruct usb_request\t\t*ep0_reply;\n\tstruct usb_request\t\t*ep0_request;\n};\n\nstatic const struct usb_ep_ops bcm63xx_udc_ep_ops;\n\n \n\nstatic inline struct bcm63xx_udc *gadget_to_udc(struct usb_gadget *g)\n{\n\treturn container_of(g, struct bcm63xx_udc, gadget);\n}\n\nstatic inline struct bcm63xx_ep *our_ep(struct usb_ep *ep)\n{\n\treturn container_of(ep, struct bcm63xx_ep, ep);\n}\n\nstatic inline struct bcm63xx_req *our_req(struct usb_request *req)\n{\n\treturn container_of(req, struct bcm63xx_req, req);\n}\n\nstatic inline u32 usbd_readl(struct bcm63xx_udc *udc, u32 off)\n{\n\treturn bcm_readl(udc->usbd_regs + off);\n}\n\nstatic inline void usbd_writel(struct bcm63xx_udc *udc, u32 val, u32 off)\n{\n\tbcm_writel(val, udc->usbd_regs + off);\n}\n\nstatic inline u32 usb_dma_readl(struct bcm63xx_udc *udc, u32 off)\n{\n\treturn bcm_readl(udc->iudma_regs + off);\n}\n\nstatic inline void usb_dma_writel(struct bcm63xx_udc *udc, u32 val, u32 off)\n{\n\tbcm_writel(val, udc->iudma_regs + off);\n}\n\nstatic inline u32 usb_dmac_readl(struct bcm63xx_udc *udc, u32 off, int chan)\n{\n\treturn bcm_readl(udc->iudma_regs + IUDMA_DMAC_OFFSET + off +\n\t\t\t(ENETDMA_CHAN_WIDTH * chan));\n}\n\nstatic inline void usb_dmac_writel(struct bcm63xx_udc *udc, u32 val, u32 off,\n\t\t\t\t\tint chan)\n{\n\tbcm_writel(val, udc->iudma_regs + IUDMA_DMAC_OFFSET + off +\n\t\t\t(ENETDMA_CHAN_WIDTH * chan));\n}\n\nstatic inline u32 usb_dmas_readl(struct bcm63xx_udc *udc, u32 off, int chan)\n{\n\treturn bcm_readl(udc->iudma_regs + IUDMA_DMAS_OFFSET + off +\n\t\t\t(ENETDMA_CHAN_WIDTH * chan));\n}\n\nstatic inline void usb_dmas_writel(struct bcm63xx_udc *udc, u32 val, u32 off,\n\t\t\t\t\tint chan)\n{\n\tbcm_writel(val, udc->iudma_regs + IUDMA_DMAS_OFFSET + off +\n\t\t\t(ENETDMA_CHAN_WIDTH * chan));\n}\n\nstatic inline void set_clocks(struct bcm63xx_udc *udc, bool is_enabled)\n{\n\tif (is_enabled) {\n\t\tclk_enable(udc->usbh_clk);\n\t\tclk_enable(udc->usbd_clk);\n\t\tudelay(10);\n\t} else {\n\t\tclk_disable(udc->usbd_clk);\n\t\tclk_disable(udc->usbh_clk);\n\t}\n}\n\n \n\n \nstatic void bcm63xx_ep_dma_select(struct bcm63xx_udc *udc, int idx)\n{\n\tu32 val = usbd_readl(udc, USBD_CONTROL_REG);\n\n\tval &= ~USBD_CONTROL_INIT_SEL_MASK;\n\tval |= idx << USBD_CONTROL_INIT_SEL_SHIFT;\n\tusbd_writel(udc, val, USBD_CONTROL_REG);\n}\n\n \nstatic void bcm63xx_set_stall(struct bcm63xx_udc *udc, struct bcm63xx_ep *bep,\n\tbool is_stalled)\n{\n\tu32 val;\n\n\tval = USBD_STALL_UPDATE_MASK |\n\t\t(is_stalled ? USBD_STALL_ENABLE_MASK : 0) |\n\t\t(bep->ep_num << USBD_STALL_EPNUM_SHIFT);\n\tusbd_writel(udc, val, USBD_STALL_REG);\n}\n\n \nstatic void bcm63xx_fifo_setup(struct bcm63xx_udc *udc)\n{\n\tint is_hs = udc->gadget.speed == USB_SPEED_HIGH;\n\tu32 i, val, rx_fifo_slot, tx_fifo_slot;\n\n\t \n\trx_fifo_slot = tx_fifo_slot = 0;\n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i += 2) {\n\t\tconst struct iudma_ch_cfg *rx_cfg = &iudma_defaults[i];\n\t\tconst struct iudma_ch_cfg *tx_cfg = &iudma_defaults[i + 1];\n\n\t\tbcm63xx_ep_dma_select(udc, i >> 1);\n\n\t\tval = (rx_fifo_slot << USBD_RXFIFO_CONFIG_START_SHIFT) |\n\t\t\t((rx_fifo_slot + rx_cfg->n_fifo_slots - 1) <<\n\t\t\t USBD_RXFIFO_CONFIG_END_SHIFT);\n\t\trx_fifo_slot += rx_cfg->n_fifo_slots;\n\t\tusbd_writel(udc, val, USBD_RXFIFO_CONFIG_REG);\n\t\tusbd_writel(udc,\n\t\t\t    is_hs ? rx_cfg->max_pkt_hs : rx_cfg->max_pkt_fs,\n\t\t\t    USBD_RXFIFO_EPSIZE_REG);\n\n\t\tval = (tx_fifo_slot << USBD_TXFIFO_CONFIG_START_SHIFT) |\n\t\t\t((tx_fifo_slot + tx_cfg->n_fifo_slots - 1) <<\n\t\t\t USBD_TXFIFO_CONFIG_END_SHIFT);\n\t\ttx_fifo_slot += tx_cfg->n_fifo_slots;\n\t\tusbd_writel(udc, val, USBD_TXFIFO_CONFIG_REG);\n\t\tusbd_writel(udc,\n\t\t\t    is_hs ? tx_cfg->max_pkt_hs : tx_cfg->max_pkt_fs,\n\t\t\t    USBD_TXFIFO_EPSIZE_REG);\n\n\t\tusbd_readl(udc, USBD_TXFIFO_EPSIZE_REG);\n\t}\n}\n\n \nstatic void bcm63xx_fifo_reset_ep(struct bcm63xx_udc *udc, int ep_num)\n{\n\tu32 val;\n\n\tbcm63xx_ep_dma_select(udc, ep_num);\n\n\tval = usbd_readl(udc, USBD_CONTROL_REG);\n\tval |= USBD_CONTROL_FIFO_RESET_MASK;\n\tusbd_writel(udc, val, USBD_CONTROL_REG);\n\tusbd_readl(udc, USBD_CONTROL_REG);\n}\n\n \nstatic void bcm63xx_fifo_reset(struct bcm63xx_udc *udc)\n{\n\tint i;\n\n\tfor (i = 0; i < BCM63XX_NUM_FIFO_PAIRS; i++)\n\t\tbcm63xx_fifo_reset_ep(udc, i);\n}\n\n \nstatic void bcm63xx_ep_init(struct bcm63xx_udc *udc)\n{\n\tu32 i, val;\n\n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\n\t\tconst struct iudma_ch_cfg *cfg = &iudma_defaults[i];\n\n\t\tif (cfg->ep_num < 0)\n\t\t\tcontinue;\n\n\t\tbcm63xx_ep_dma_select(udc, cfg->ep_num);\n\t\tval = (cfg->ep_type << USBD_EPNUM_TYPEMAP_TYPE_SHIFT) |\n\t\t\t((i >> 1) << USBD_EPNUM_TYPEMAP_DMA_CH_SHIFT);\n\t\tusbd_writel(udc, val, USBD_EPNUM_TYPEMAP_REG);\n\t}\n}\n\n \nstatic void bcm63xx_ep_setup(struct bcm63xx_udc *udc)\n{\n\tu32 val, i;\n\n\tusbd_writel(udc, USBD_CSR_SETUPADDR_DEF, USBD_CSR_SETUPADDR_REG);\n\n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\n\t\tconst struct iudma_ch_cfg *cfg = &iudma_defaults[i];\n\t\tint max_pkt = udc->gadget.speed == USB_SPEED_HIGH ?\n\t\t\t      cfg->max_pkt_hs : cfg->max_pkt_fs;\n\t\tint idx = cfg->ep_num;\n\n\t\tudc->iudma[i].max_pkt = max_pkt;\n\n\t\tif (idx < 0)\n\t\t\tcontinue;\n\t\tusb_ep_set_maxpacket_limit(&udc->bep[idx].ep, max_pkt);\n\n\t\tval = (idx << USBD_CSR_EP_LOG_SHIFT) |\n\t\t      (cfg->dir << USBD_CSR_EP_DIR_SHIFT) |\n\t\t      (cfg->ep_type << USBD_CSR_EP_TYPE_SHIFT) |\n\t\t      (udc->cfg << USBD_CSR_EP_CFG_SHIFT) |\n\t\t      (udc->iface << USBD_CSR_EP_IFACE_SHIFT) |\n\t\t      (udc->alt_iface << USBD_CSR_EP_ALTIFACE_SHIFT) |\n\t\t      (max_pkt << USBD_CSR_EP_MAXPKT_SHIFT);\n\t\tusbd_writel(udc, val, USBD_CSR_EP_REG(idx));\n\t}\n}\n\n \nstatic void iudma_write(struct bcm63xx_udc *udc, struct iudma_ch *iudma,\n\tstruct bcm63xx_req *breq)\n{\n\tint first_bd = 1, last_bd = 0, extra_zero_pkt = 0;\n\tunsigned int bytes_left = breq->req.length - breq->offset;\n\tconst int max_bd_bytes = !irq_coalesce && !iudma->is_tx ?\n\t\tiudma->max_pkt : IUDMA_MAX_FRAGMENT;\n\n\tiudma->n_bds_used = 0;\n\tbreq->bd_bytes = 0;\n\tbreq->iudma = iudma;\n\n\tif ((bytes_left % iudma->max_pkt == 0) && bytes_left && breq->req.zero)\n\t\textra_zero_pkt = 1;\n\n\tdo {\n\t\tstruct bcm_enet_desc *d = iudma->write_bd;\n\t\tu32 dmaflags = 0;\n\t\tunsigned int n_bytes;\n\n\t\tif (d == iudma->end_bd) {\n\t\t\tdmaflags |= DMADESC_WRAP_MASK;\n\t\t\tiudma->write_bd = iudma->bd_ring;\n\t\t} else {\n\t\t\tiudma->write_bd++;\n\t\t}\n\t\tiudma->n_bds_used++;\n\n\t\tn_bytes = min_t(int, bytes_left, max_bd_bytes);\n\t\tif (n_bytes)\n\t\t\tdmaflags |= n_bytes << DMADESC_LENGTH_SHIFT;\n\t\telse\n\t\t\tdmaflags |= (1 << DMADESC_LENGTH_SHIFT) |\n\t\t\t\t    DMADESC_USB_ZERO_MASK;\n\n\t\tdmaflags |= DMADESC_OWNER_MASK;\n\t\tif (first_bd) {\n\t\t\tdmaflags |= DMADESC_SOP_MASK;\n\t\t\tfirst_bd = 0;\n\t\t}\n\n\t\t \n\t\tif (extra_zero_pkt && !bytes_left)\n\t\t\textra_zero_pkt = 0;\n\n\t\tif (!iudma->is_tx || iudma->n_bds_used == iudma->n_bds ||\n\t\t    (n_bytes == bytes_left && !extra_zero_pkt)) {\n\t\t\tlast_bd = 1;\n\t\t\tdmaflags |= DMADESC_EOP_MASK;\n\t\t}\n\n\t\td->address = breq->req.dma + breq->offset;\n\t\tmb();\n\t\td->len_stat = dmaflags;\n\n\t\tbreq->offset += n_bytes;\n\t\tbreq->bd_bytes += n_bytes;\n\t\tbytes_left -= n_bytes;\n\t} while (!last_bd);\n\n\tusb_dmac_writel(udc, ENETDMAC_CHANCFG_EN_MASK,\n\t\t\tENETDMAC_CHANCFG_REG, iudma->ch_idx);\n}\n\n \nstatic int iudma_read(struct bcm63xx_udc *udc, struct iudma_ch *iudma)\n{\n\tint i, actual_len = 0;\n\tstruct bcm_enet_desc *d = iudma->read_bd;\n\n\tif (!iudma->n_bds_used)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < iudma->n_bds_used; i++) {\n\t\tu32 dmaflags;\n\n\t\tdmaflags = d->len_stat;\n\n\t\tif (dmaflags & DMADESC_OWNER_MASK)\n\t\t\treturn -EBUSY;\n\n\t\tactual_len += (dmaflags & DMADESC_LENGTH_MASK) >>\n\t\t\t      DMADESC_LENGTH_SHIFT;\n\t\tif (d == iudma->end_bd)\n\t\t\td = iudma->bd_ring;\n\t\telse\n\t\t\td++;\n\t}\n\n\tiudma->read_bd = d;\n\tiudma->n_bds_used = 0;\n\treturn actual_len;\n}\n\n \nstatic void iudma_reset_channel(struct bcm63xx_udc *udc, struct iudma_ch *iudma)\n{\n\tint timeout = IUDMA_RESET_TIMEOUT_US;\n\tstruct bcm_enet_desc *d;\n\tint ch_idx = iudma->ch_idx;\n\n\tif (!iudma->is_tx)\n\t\tbcm63xx_fifo_reset_ep(udc, max(0, iudma->ep_num));\n\n\t \n\tusb_dmac_writel(udc, 0, ENETDMAC_CHANCFG_REG, ch_idx);\n\n\twhile (usb_dmac_readl(udc, ENETDMAC_CHANCFG_REG, ch_idx) &\n\t\t\t\t   ENETDMAC_CHANCFG_EN_MASK) {\n\t\tudelay(1);\n\n\t\t \n\t\tif (iudma->is_tx && iudma->ep_num >= 0)\n\t\t\tbcm63xx_fifo_reset_ep(udc, iudma->ep_num);\n\n\t\tif (!timeout--) {\n\t\t\tdev_err(udc->dev, \"can't reset IUDMA channel %d\\n\",\n\t\t\t\tch_idx);\n\t\t\tbreak;\n\t\t}\n\t\tif (timeout == IUDMA_RESET_TIMEOUT_US / 2) {\n\t\t\tdev_warn(udc->dev, \"forcibly halting IUDMA channel %d\\n\",\n\t\t\t\t ch_idx);\n\t\t\tusb_dmac_writel(udc, ENETDMAC_CHANCFG_BUFHALT_MASK,\n\t\t\t\t\tENETDMAC_CHANCFG_REG, ch_idx);\n\t\t}\n\t}\n\tusb_dmac_writel(udc, ~0, ENETDMAC_IR_REG, ch_idx);\n\n\t \n\tfor (d = iudma->bd_ring; d <= iudma->end_bd; d++)\n\t\td->len_stat = 0;\n\tmb();\n\n\tiudma->read_bd = iudma->write_bd = iudma->bd_ring;\n\tiudma->n_bds_used = 0;\n\n\t \n\tusb_dmac_writel(udc, ENETDMAC_IR_BUFDONE_MASK,\n\t\t\tENETDMAC_IRMASK_REG, ch_idx);\n\tusb_dmac_writel(udc, 8, ENETDMAC_MAXBURST_REG, ch_idx);\n\n\tusb_dmas_writel(udc, iudma->bd_ring_dma, ENETDMAS_RSTART_REG, ch_idx);\n\tusb_dmas_writel(udc, 0, ENETDMAS_SRAM2_REG, ch_idx);\n}\n\n \nstatic int iudma_init_channel(struct bcm63xx_udc *udc, unsigned int ch_idx)\n{\n\tstruct iudma_ch *iudma = &udc->iudma[ch_idx];\n\tconst struct iudma_ch_cfg *cfg = &iudma_defaults[ch_idx];\n\tunsigned int n_bds = cfg->n_bds;\n\tstruct bcm63xx_ep *bep = NULL;\n\n\tiudma->ep_num = cfg->ep_num;\n\tiudma->ch_idx = ch_idx;\n\tiudma->is_tx = !!(ch_idx & 0x01);\n\tif (iudma->ep_num >= 0) {\n\t\tbep = &udc->bep[iudma->ep_num];\n\t\tbep->iudma = iudma;\n\t\tINIT_LIST_HEAD(&bep->queue);\n\t}\n\n\tiudma->bep = bep;\n\tiudma->udc = udc;\n\n\t \n\tif (iudma->ep_num <= 0)\n\t\tiudma->enabled = true;\n\n\tiudma->n_bds = n_bds;\n\tiudma->bd_ring = dmam_alloc_coherent(udc->dev,\n\t\tn_bds * sizeof(struct bcm_enet_desc),\n\t\t&iudma->bd_ring_dma, GFP_KERNEL);\n\tif (!iudma->bd_ring)\n\t\treturn -ENOMEM;\n\tiudma->end_bd = &iudma->bd_ring[n_bds - 1];\n\n\treturn 0;\n}\n\n \nstatic int iudma_init(struct bcm63xx_udc *udc)\n{\n\tint i, rc;\n\n\tusb_dma_writel(udc, ENETDMA_CFG_EN_MASK, ENETDMA_CFG_REG);\n\n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\n\t\trc = iudma_init_channel(udc, i);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tiudma_reset_channel(udc, &udc->iudma[i]);\n\t}\n\n\tusb_dma_writel(udc, BIT(BCM63XX_NUM_IUDMA)-1, ENETDMA_GLB_IRQMASK_REG);\n\treturn 0;\n}\n\n \nstatic void iudma_uninit(struct bcm63xx_udc *udc)\n{\n\tint i;\n\n\tusb_dma_writel(udc, 0, ENETDMA_GLB_IRQMASK_REG);\n\n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i++)\n\t\tiudma_reset_channel(udc, &udc->iudma[i]);\n\n\tusb_dma_writel(udc, 0, ENETDMA_CFG_REG);\n}\n\n \n\n \nstatic void bcm63xx_set_ctrl_irqs(struct bcm63xx_udc *udc, bool enable_irqs)\n{\n\tu32 val;\n\n\tusbd_writel(udc, 0, USBD_STATUS_REG);\n\n\tval = BIT(USBD_EVENT_IRQ_USB_RESET) |\n\t      BIT(USBD_EVENT_IRQ_SETUP) |\n\t      BIT(USBD_EVENT_IRQ_SETCFG) |\n\t      BIT(USBD_EVENT_IRQ_SETINTF) |\n\t      BIT(USBD_EVENT_IRQ_USB_LINK);\n\tusbd_writel(udc, enable_irqs ? val : 0, USBD_EVENT_IRQ_MASK_REG);\n\tusbd_writel(udc, val, USBD_EVENT_IRQ_STATUS_REG);\n}\n\n \nstatic void bcm63xx_select_phy_mode(struct bcm63xx_udc *udc, bool is_device)\n{\n\tu32 val, portmask = BIT(udc->pd->port_no);\n\n\tif (BCMCPU_IS_6328()) {\n\t\t \n\t\tval = bcm_gpio_readl(GPIO_PINMUX_OTHR_REG);\n\t\tval &= ~GPIO_PINMUX_OTHR_6328_USB_MASK;\n\t\tval |= is_device ? GPIO_PINMUX_OTHR_6328_USB_DEV :\n\t\t\t       GPIO_PINMUX_OTHR_6328_USB_HOST;\n\t\tbcm_gpio_writel(val, GPIO_PINMUX_OTHR_REG);\n\t}\n\n\tval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_UTMI_CTL_6368_REG);\n\tif (is_device) {\n\t\tval |= (portmask << USBH_PRIV_UTMI_CTL_HOSTB_SHIFT);\n\t\tval |= (portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\n\t} else {\n\t\tval &= ~(portmask << USBH_PRIV_UTMI_CTL_HOSTB_SHIFT);\n\t\tval &= ~(portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\n\t}\n\tbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_UTMI_CTL_6368_REG);\n\n\tval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_SWAP_6368_REG);\n\tif (is_device)\n\t\tval |= USBH_PRIV_SWAP_USBD_MASK;\n\telse\n\t\tval &= ~USBH_PRIV_SWAP_USBD_MASK;\n\tbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_SWAP_6368_REG);\n}\n\n \nstatic void bcm63xx_select_pullup(struct bcm63xx_udc *udc, bool is_on)\n{\n\tu32 val, portmask = BIT(udc->pd->port_no);\n\n\tval = bcm_rset_readl(RSET_USBH_PRIV, USBH_PRIV_UTMI_CTL_6368_REG);\n\tif (is_on)\n\t\tval &= ~(portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\n\telse\n\t\tval |= (portmask << USBH_PRIV_UTMI_CTL_NODRIV_SHIFT);\n\tbcm_rset_writel(RSET_USBH_PRIV, val, USBH_PRIV_UTMI_CTL_6368_REG);\n}\n\n \nstatic void bcm63xx_uninit_udc_hw(struct bcm63xx_udc *udc)\n{\n\tset_clocks(udc, true);\n\tiudma_uninit(udc);\n\tset_clocks(udc, false);\n\n\tclk_put(udc->usbd_clk);\n\tclk_put(udc->usbh_clk);\n}\n\n \nstatic int bcm63xx_init_udc_hw(struct bcm63xx_udc *udc)\n{\n\tint i, rc = 0;\n\tu32 val;\n\n\tudc->ep0_ctrl_buf = devm_kzalloc(udc->dev, BCM63XX_MAX_CTRL_PKT,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!udc->ep0_ctrl_buf)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\tfor (i = 0; i < BCM63XX_NUM_EP; i++) {\n\t\tstruct bcm63xx_ep *bep = &udc->bep[i];\n\n\t\tbep->ep.name = bcm63xx_ep_info[i].name;\n\t\tbep->ep.caps = bcm63xx_ep_info[i].caps;\n\t\tbep->ep_num = i;\n\t\tbep->ep.ops = &bcm63xx_udc_ep_ops;\n\t\tlist_add_tail(&bep->ep.ep_list, &udc->gadget.ep_list);\n\t\tbep->halted = 0;\n\t\tusb_ep_set_maxpacket_limit(&bep->ep, BCM63XX_MAX_CTRL_PKT);\n\t\tbep->udc = udc;\n\t\tbep->ep.desc = NULL;\n\t\tINIT_LIST_HEAD(&bep->queue);\n\t}\n\n\tudc->gadget.ep0 = &udc->bep[0].ep;\n\tlist_del(&udc->bep[0].ep.ep_list);\n\n\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\tudc->ep0state = EP0_SHUTDOWN;\n\n\tudc->usbh_clk = clk_get(udc->dev, \"usbh\");\n\tif (IS_ERR(udc->usbh_clk))\n\t\treturn -EIO;\n\n\tudc->usbd_clk = clk_get(udc->dev, \"usbd\");\n\tif (IS_ERR(udc->usbd_clk)) {\n\t\tclk_put(udc->usbh_clk);\n\t\treturn -EIO;\n\t}\n\n\tset_clocks(udc, true);\n\n\tval = USBD_CONTROL_AUTO_CSRS_MASK |\n\t      USBD_CONTROL_DONE_CSRS_MASK |\n\t      (irq_coalesce ? USBD_CONTROL_RXZSCFG_MASK : 0);\n\tusbd_writel(udc, val, USBD_CONTROL_REG);\n\n\tval = USBD_STRAPS_APP_SELF_PWR_MASK |\n\t      USBD_STRAPS_APP_RAM_IF_MASK |\n\t      USBD_STRAPS_APP_CSRPRGSUP_MASK |\n\t      USBD_STRAPS_APP_8BITPHY_MASK |\n\t      USBD_STRAPS_APP_RMTWKUP_MASK;\n\n\tif (udc->gadget.max_speed == USB_SPEED_HIGH)\n\t\tval |= (BCM63XX_SPD_HIGH << USBD_STRAPS_SPEED_SHIFT);\n\telse\n\t\tval |= (BCM63XX_SPD_FULL << USBD_STRAPS_SPEED_SHIFT);\n\tusbd_writel(udc, val, USBD_STRAPS_REG);\n\n\tbcm63xx_set_ctrl_irqs(udc, false);\n\n\tusbd_writel(udc, 0, USBD_EVENT_IRQ_CFG_LO_REG);\n\n\tval = USBD_EVENT_IRQ_CFG_FALLING(USBD_EVENT_IRQ_ENUM_ON) |\n\t      USBD_EVENT_IRQ_CFG_FALLING(USBD_EVENT_IRQ_SET_CSRS);\n\tusbd_writel(udc, val, USBD_EVENT_IRQ_CFG_HI_REG);\n\n\trc = iudma_init(udc);\n\tset_clocks(udc, false);\n\tif (rc)\n\t\tbcm63xx_uninit_udc_hw(udc);\n\n\treturn 0;\n}\n\n \n\n \nstatic int bcm63xx_ep_enable(struct usb_ep *ep,\n\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tstruct iudma_ch *iudma = bep->iudma;\n\tunsigned long flags;\n\n\tif (!ep || !desc || ep->name == bcm63xx_ep0name)\n\t\treturn -EINVAL;\n\n\tif (!udc->driver)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (iudma->enabled) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tiudma->enabled = true;\n\tBUG_ON(!list_empty(&bep->queue));\n\n\tiudma_reset_channel(udc, iudma);\n\n\tbep->halted = 0;\n\tbcm63xx_set_stall(udc, bep, false);\n\tclear_bit(bep->ep_num, &udc->wedgemap);\n\n\tep->desc = desc;\n\tep->maxpacket = usb_endpoint_maxp(desc);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic int bcm63xx_ep_disable(struct usb_ep *ep)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tstruct iudma_ch *iudma = bep->iudma;\n\tstruct bcm63xx_req *breq, *n;\n\tunsigned long flags;\n\n\tif (!ep || !ep->desc)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (!iudma->enabled) {\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tiudma->enabled = false;\n\n\tiudma_reset_channel(udc, iudma);\n\n\tif (!list_empty(&bep->queue)) {\n\t\tlist_for_each_entry_safe(breq, n, &bep->queue, queue) {\n\t\t\tusb_gadget_unmap_request(&udc->gadget, &breq->req,\n\t\t\t\t\t\t iudma->is_tx);\n\t\t\tlist_del(&breq->queue);\n\t\t\tbreq->req.status = -ESHUTDOWN;\n\n\t\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\t\tusb_gadget_giveback_request(&iudma->bep->ep, &breq->req);\n\t\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\t}\n\t}\n\tep->desc = NULL;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\n \nstatic struct usb_request *bcm63xx_udc_alloc_request(struct usb_ep *ep,\n\tgfp_t mem_flags)\n{\n\tstruct bcm63xx_req *breq;\n\n\tbreq = kzalloc(sizeof(*breq), mem_flags);\n\tif (!breq)\n\t\treturn NULL;\n\treturn &breq->req;\n}\n\n \nstatic void bcm63xx_udc_free_request(struct usb_ep *ep,\n\tstruct usb_request *req)\n{\n\tstruct bcm63xx_req *breq = our_req(req);\n\tkfree(breq);\n}\n\n \nstatic int bcm63xx_udc_queue(struct usb_ep *ep, struct usb_request *req,\n\tgfp_t mem_flags)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tstruct bcm63xx_req *breq = our_req(req);\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif (unlikely(!req || !req->complete || !req->buf || !ep))\n\t\treturn -EINVAL;\n\n\treq->actual = 0;\n\treq->status = 0;\n\tbreq->offset = 0;\n\n\tif (bep == &udc->bep[0]) {\n\t\t \n\t\tif (udc->ep0_reply)\n\t\t\treturn -EINVAL;\n\n\t\tudc->ep0_reply = req;\n\t\tschedule_work(&udc->ep0_wq);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (!bep->iudma->enabled) {\n\t\trc = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\trc = usb_gadget_map_request(&udc->gadget, req, bep->iudma->is_tx);\n\tif (rc == 0) {\n\t\tlist_add_tail(&breq->queue, &bep->queue);\n\t\tif (list_is_singular(&bep->queue))\n\t\t\tiudma_write(udc, bep->iudma, breq);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn rc;\n}\n\n \nstatic int bcm63xx_udc_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tstruct bcm63xx_req *breq = our_req(req), *cur;\n\tunsigned long flags;\n\tint rc = 0;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (list_empty(&bep->queue)) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcur = list_first_entry(&bep->queue, struct bcm63xx_req, queue);\n\tusb_gadget_unmap_request(&udc->gadget, &breq->req, bep->iudma->is_tx);\n\n\tif (breq == cur) {\n\t\tiudma_reset_channel(udc, bep->iudma);\n\t\tlist_del(&breq->queue);\n\n\t\tif (!list_empty(&bep->queue)) {\n\t\t\tstruct bcm63xx_req *next;\n\n\t\t\tnext = list_first_entry(&bep->queue,\n\t\t\t\tstruct bcm63xx_req, queue);\n\t\t\tiudma_write(udc, bep->iudma, next);\n\t\t}\n\t} else {\n\t\tlist_del(&breq->queue);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treq->status = -ESHUTDOWN;\n\treq->complete(ep, req);\n\n\treturn rc;\n}\n\n \nstatic int bcm63xx_udc_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tbcm63xx_set_stall(udc, bep, !!value);\n\tbep->halted = value;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int bcm63xx_udc_set_wedge(struct usb_ep *ep)\n{\n\tstruct bcm63xx_ep *bep = our_ep(ep);\n\tstruct bcm63xx_udc *udc = bep->udc;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tset_bit(bep->ep_num, &udc->wedgemap);\n\tbcm63xx_set_stall(udc, bep, true);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops bcm63xx_udc_ep_ops = {\n\t.enable\t\t= bcm63xx_ep_enable,\n\t.disable\t= bcm63xx_ep_disable,\n\n\t.alloc_request\t= bcm63xx_udc_alloc_request,\n\t.free_request\t= bcm63xx_udc_free_request,\n\n\t.queue\t\t= bcm63xx_udc_queue,\n\t.dequeue\t= bcm63xx_udc_dequeue,\n\n\t.set_halt\t= bcm63xx_udc_set_halt,\n\t.set_wedge\t= bcm63xx_udc_set_wedge,\n};\n\n \n\n \nstatic int bcm63xx_ep0_setup_callback(struct bcm63xx_udc *udc,\n\tstruct usb_ctrlrequest *ctrl)\n{\n\tint rc;\n\n\tspin_unlock_irq(&udc->lock);\n\trc = udc->driver->setup(&udc->gadget, ctrl);\n\tspin_lock_irq(&udc->lock);\n\treturn rc;\n}\n\n \nstatic int bcm63xx_ep0_spoof_set_cfg(struct bcm63xx_udc *udc)\n{\n\tstruct usb_ctrlrequest ctrl;\n\tint rc;\n\n\tctrl.bRequestType = USB_DIR_OUT | USB_RECIP_DEVICE;\n\tctrl.bRequest = USB_REQ_SET_CONFIGURATION;\n\tctrl.wValue = cpu_to_le16(udc->cfg);\n\tctrl.wIndex = 0;\n\tctrl.wLength = 0;\n\n\trc = bcm63xx_ep0_setup_callback(udc, &ctrl);\n\tif (rc < 0) {\n\t\tdev_warn_ratelimited(udc->dev,\n\t\t\t\"hardware auto-acked bad SET_CONFIGURATION(%d) request\\n\",\n\t\t\tudc->cfg);\n\t}\n\treturn rc;\n}\n\n \nstatic int bcm63xx_ep0_spoof_set_iface(struct bcm63xx_udc *udc)\n{\n\tstruct usb_ctrlrequest ctrl;\n\tint rc;\n\n\tctrl.bRequestType = USB_DIR_OUT | USB_RECIP_INTERFACE;\n\tctrl.bRequest = USB_REQ_SET_INTERFACE;\n\tctrl.wValue = cpu_to_le16(udc->alt_iface);\n\tctrl.wIndex = cpu_to_le16(udc->iface);\n\tctrl.wLength = 0;\n\n\trc = bcm63xx_ep0_setup_callback(udc, &ctrl);\n\tif (rc < 0) {\n\t\tdev_warn_ratelimited(udc->dev,\n\t\t\t\"hardware auto-acked bad SET_INTERFACE(%d,%d) request\\n\",\n\t\t\tudc->iface, udc->alt_iface);\n\t}\n\treturn rc;\n}\n\n \nstatic void bcm63xx_ep0_map_write(struct bcm63xx_udc *udc, int ch_idx,\n\tstruct usb_request *req)\n{\n\tstruct bcm63xx_req *breq = our_req(req);\n\tstruct iudma_ch *iudma = &udc->iudma[ch_idx];\n\n\tBUG_ON(udc->ep0_request);\n\tudc->ep0_request = req;\n\n\treq->actual = 0;\n\tbreq->offset = 0;\n\tusb_gadget_map_request(&udc->gadget, req, iudma->is_tx);\n\tiudma_write(udc, iudma, breq);\n}\n\n \nstatic void bcm63xx_ep0_complete(struct bcm63xx_udc *udc,\n\tstruct usb_request *req, int status)\n{\n\treq->status = status;\n\tif (status)\n\t\treq->actual = 0;\n\tif (req->complete) {\n\t\tspin_unlock_irq(&udc->lock);\n\t\treq->complete(&udc->bep[0].ep, req);\n\t\tspin_lock_irq(&udc->lock);\n\t}\n}\n\n \nstatic void bcm63xx_ep0_nuke_reply(struct bcm63xx_udc *udc, int is_tx)\n{\n\tstruct usb_request *req = udc->ep0_reply;\n\n\tudc->ep0_reply = NULL;\n\tusb_gadget_unmap_request(&udc->gadget, req, is_tx);\n\tif (udc->ep0_request == req) {\n\t\tudc->ep0_req_completed = 0;\n\t\tudc->ep0_request = NULL;\n\t}\n\tbcm63xx_ep0_complete(udc, req, -ESHUTDOWN);\n}\n\n \nstatic int bcm63xx_ep0_read_complete(struct bcm63xx_udc *udc)\n{\n\tstruct usb_request *req = udc->ep0_request;\n\n\tudc->ep0_req_completed = 0;\n\tudc->ep0_request = NULL;\n\n\treturn req->actual;\n}\n\n \nstatic void bcm63xx_ep0_internal_request(struct bcm63xx_udc *udc, int ch_idx,\n\tint length)\n{\n\tstruct usb_request *req = &udc->ep0_ctrl_req.req;\n\n\treq->buf = udc->ep0_ctrl_buf;\n\treq->length = length;\n\treq->complete = NULL;\n\n\tbcm63xx_ep0_map_write(udc, ch_idx, req);\n}\n\n \nstatic enum bcm63xx_ep0_state bcm63xx_ep0_do_setup(struct bcm63xx_udc *udc)\n{\n\tint rc;\n\tstruct usb_ctrlrequest *ctrl = (void *)udc->ep0_ctrl_buf;\n\n\trc = bcm63xx_ep0_read_complete(udc);\n\n\tif (rc < 0) {\n\t\tdev_err(udc->dev, \"missing SETUP packet\\n\");\n\t\treturn EP0_IDLE;\n\t}\n\n\t \n\tif (rc == 0)\n\t\treturn EP0_REQUEUE;\n\n\t \n\tif (rc != sizeof(*ctrl)) {\n\t\tdev_warn_ratelimited(udc->dev,\n\t\t\t\"malformed SETUP packet (%d bytes)\\n\", rc);\n\t\treturn EP0_REQUEUE;\n\t}\n\n\t \n\trc = bcm63xx_ep0_setup_callback(udc, ctrl);\n\tif (rc < 0) {\n\t\tbcm63xx_set_stall(udc, &udc->bep[0], true);\n\t\treturn EP0_REQUEUE;\n\t}\n\n\tif (!ctrl->wLength)\n\t\treturn EP0_REQUEUE;\n\telse if (ctrl->bRequestType & USB_DIR_IN)\n\t\treturn EP0_IN_DATA_PHASE_SETUP;\n\telse\n\t\treturn EP0_OUT_DATA_PHASE_SETUP;\n}\n\n \nstatic int bcm63xx_ep0_do_idle(struct bcm63xx_udc *udc)\n{\n\tif (udc->ep0_req_reset) {\n\t\tudc->ep0_req_reset = 0;\n\t} else if (udc->ep0_req_set_cfg) {\n\t\tudc->ep0_req_set_cfg = 0;\n\t\tif (bcm63xx_ep0_spoof_set_cfg(udc) >= 0)\n\t\t\tudc->ep0state = EP0_IN_FAKE_STATUS_PHASE;\n\t} else if (udc->ep0_req_set_iface) {\n\t\tudc->ep0_req_set_iface = 0;\n\t\tif (bcm63xx_ep0_spoof_set_iface(udc) >= 0)\n\t\t\tudc->ep0state = EP0_IN_FAKE_STATUS_PHASE;\n\t} else if (udc->ep0_req_completed) {\n\t\tudc->ep0state = bcm63xx_ep0_do_setup(udc);\n\t\treturn udc->ep0state == EP0_IDLE ? -EAGAIN : 0;\n\t} else if (udc->ep0_req_shutdown) {\n\t\tudc->ep0_req_shutdown = 0;\n\t\tudc->ep0_req_completed = 0;\n\t\tudc->ep0_request = NULL;\n\t\tiudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_RXCHAN]);\n\t\tusb_gadget_unmap_request(&udc->gadget,\n\t\t\t&udc->ep0_ctrl_req.req, 0);\n\n\t\t \n\t\tmb();\n\t\tudc->ep0state = EP0_SHUTDOWN;\n\t} else if (udc->ep0_reply) {\n\t\t \n\t\tdev_warn(udc->dev, \"nuking unexpected reply\\n\");\n\t\tbcm63xx_ep0_nuke_reply(udc, 0);\n\t} else {\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int bcm63xx_ep0_one_round(struct bcm63xx_udc *udc)\n{\n\tenum bcm63xx_ep0_state ep0state = udc->ep0state;\n\tbool shutdown = udc->ep0_req_reset || udc->ep0_req_shutdown;\n\n\tswitch (udc->ep0state) {\n\tcase EP0_REQUEUE:\n\t\t \n\t\tbcm63xx_ep0_internal_request(udc, IUDMA_EP0_RXCHAN,\n\t\t\t\t\t     BCM63XX_MAX_CTRL_PKT);\n\t\tep0state = EP0_IDLE;\n\t\tbreak;\n\tcase EP0_IDLE:\n\t\treturn bcm63xx_ep0_do_idle(udc);\n\tcase EP0_IN_DATA_PHASE_SETUP:\n\t\t \n\t\tif (udc->ep0_reply) {\n\t\t\tbcm63xx_ep0_map_write(udc, IUDMA_EP0_TXCHAN,\n\t\t\t\t\t      udc->ep0_reply);\n\t\t\tep0state = EP0_IN_DATA_PHASE_COMPLETE;\n\t\t} else if (shutdown) {\n\t\t\tep0state = EP0_REQUEUE;\n\t\t}\n\t\tbreak;\n\tcase EP0_IN_DATA_PHASE_COMPLETE: {\n\t\t \n\t\tif (udc->ep0_req_completed) {\n\t\t\tudc->ep0_reply = NULL;\n\t\t\tbcm63xx_ep0_read_complete(udc);\n\t\t\t \n\t\t\tep0state = EP0_REQUEUE;\n\t\t} else if (shutdown) {\n\t\t\tiudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_TXCHAN]);\n\t\t\tbcm63xx_ep0_nuke_reply(udc, 1);\n\t\t\tep0state = EP0_REQUEUE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase EP0_OUT_DATA_PHASE_SETUP:\n\t\t \n\t\tif (udc->ep0_reply) {\n\t\t\tbcm63xx_ep0_map_write(udc, IUDMA_EP0_RXCHAN,\n\t\t\t\t\t      udc->ep0_reply);\n\t\t\tep0state = EP0_OUT_DATA_PHASE_COMPLETE;\n\t\t} else if (shutdown) {\n\t\t\tep0state = EP0_REQUEUE;\n\t\t}\n\t\tbreak;\n\tcase EP0_OUT_DATA_PHASE_COMPLETE: {\n\t\t \n\t\tif (udc->ep0_req_completed) {\n\t\t\tudc->ep0_reply = NULL;\n\t\t\tbcm63xx_ep0_read_complete(udc);\n\n\t\t\t \n\t\t\tbcm63xx_ep0_internal_request(udc, IUDMA_EP0_TXCHAN, 0);\n\t\t\tep0state = EP0_OUT_STATUS_PHASE;\n\t\t} else if (shutdown) {\n\t\t\tiudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_RXCHAN]);\n\t\t\tbcm63xx_ep0_nuke_reply(udc, 0);\n\t\t\tep0state = EP0_REQUEUE;\n\t\t}\n\t\tbreak;\n\t}\n\tcase EP0_OUT_STATUS_PHASE:\n\t\t \n\t\tif (udc->ep0_req_completed) {\n\t\t\tbcm63xx_ep0_read_complete(udc);\n\t\t\tep0state = EP0_REQUEUE;\n\t\t} else if (shutdown) {\n\t\t\tiudma_reset_channel(udc, &udc->iudma[IUDMA_EP0_TXCHAN]);\n\t\t\tudc->ep0_request = NULL;\n\t\t\tep0state = EP0_REQUEUE;\n\t\t}\n\t\tbreak;\n\tcase EP0_IN_FAKE_STATUS_PHASE: {\n\t\t \n\t\tstruct usb_request *r = udc->ep0_reply;\n\n\t\tif (!r) {\n\t\t\tif (shutdown)\n\t\t\t\tep0state = EP0_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tbcm63xx_ep0_complete(udc, r, 0);\n\t\tudc->ep0_reply = NULL;\n\t\tep0state = EP0_IDLE;\n\t\tbreak;\n\t}\n\tcase EP0_SHUTDOWN:\n\t\tbreak;\n\t}\n\n\tif (udc->ep0state == ep0state)\n\t\treturn -EAGAIN;\n\n\tudc->ep0state = ep0state;\n\treturn 0;\n}\n\n \nstatic void bcm63xx_ep0_process(struct work_struct *w)\n{\n\tstruct bcm63xx_udc *udc = container_of(w, struct bcm63xx_udc, ep0_wq);\n\tspin_lock_irq(&udc->lock);\n\twhile (bcm63xx_ep0_one_round(udc) == 0)\n\t\t;\n\tspin_unlock_irq(&udc->lock);\n}\n\n \n\n \nstatic int bcm63xx_udc_get_frame(struct usb_gadget *gadget)\n{\n\tstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\n\n\treturn (usbd_readl(udc, USBD_STATUS_REG) &\n\t\tUSBD_STATUS_SOF_MASK) >> USBD_STATUS_SOF_SHIFT;\n}\n\n \nstatic int bcm63xx_udc_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\n\tunsigned long flags;\n\tint i, rc = -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (is_on && udc->ep0state == EP0_SHUTDOWN) {\n\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tudc->ep0state = EP0_REQUEUE;\n\t\tbcm63xx_fifo_setup(udc);\n\t\tbcm63xx_fifo_reset(udc);\n\t\tbcm63xx_ep_setup(udc);\n\n\t\tbitmap_zero(&udc->wedgemap, BCM63XX_NUM_EP);\n\t\tfor (i = 0; i < BCM63XX_NUM_EP; i++)\n\t\t\tbcm63xx_set_stall(udc, &udc->bep[i], false);\n\n\t\tbcm63xx_set_ctrl_irqs(udc, true);\n\t\tbcm63xx_select_pullup(gadget_to_udc(gadget), true);\n\t\trc = 0;\n\t} else if (!is_on && udc->ep0state != EP0_SHUTDOWN) {\n\t\tbcm63xx_select_pullup(gadget_to_udc(gadget), false);\n\n\t\tudc->ep0_req_shutdown = 1;\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\t\twhile (1) {\n\t\t\tschedule_work(&udc->ep0_wq);\n\t\t\tif (udc->ep0state == EP0_SHUTDOWN)\n\t\t\t\tbreak;\n\t\t\tmsleep(50);\n\t\t}\n\t\tbcm63xx_set_ctrl_irqs(udc, false);\n\t\tcancel_work_sync(&udc->ep0_wq);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn rc;\n}\n\n \nstatic int bcm63xx_udc_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\n\tunsigned long flags;\n\n\tif (!driver || driver->max_speed < USB_SPEED_HIGH ||\n\t    !driver->setup)\n\t\treturn -EINVAL;\n\tif (!udc)\n\t\treturn -ENODEV;\n\tif (udc->driver)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tset_clocks(udc, true);\n\tbcm63xx_fifo_setup(udc);\n\tbcm63xx_ep_init(udc);\n\tbcm63xx_ep_setup(udc);\n\tbcm63xx_fifo_reset(udc);\n\tbcm63xx_select_phy_mode(udc, true);\n\n\tudc->driver = driver;\n\tudc->gadget.dev.of_node = udc->dev->of_node;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int bcm63xx_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct bcm63xx_udc *udc = gadget_to_udc(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tudc->driver = NULL;\n\n\t \n\tmsleep(100);\n\n\tbcm63xx_select_phy_mode(udc, false);\n\tset_clocks(udc, false);\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops bcm63xx_udc_ops = {\n\t.get_frame\t= bcm63xx_udc_get_frame,\n\t.pullup\t\t= bcm63xx_udc_pullup,\n\t.udc_start\t= bcm63xx_udc_start,\n\t.udc_stop\t= bcm63xx_udc_stop,\n};\n\n \n\n \nstatic void bcm63xx_update_cfg_iface(struct bcm63xx_udc *udc)\n{\n\tu32 reg = usbd_readl(udc, USBD_STATUS_REG);\n\n\tudc->cfg = (reg & USBD_STATUS_CFG_MASK) >> USBD_STATUS_CFG_SHIFT;\n\tudc->iface = (reg & USBD_STATUS_INTF_MASK) >> USBD_STATUS_INTF_SHIFT;\n\tudc->alt_iface = (reg & USBD_STATUS_ALTINTF_MASK) >>\n\t\t\t USBD_STATUS_ALTINTF_SHIFT;\n\tbcm63xx_ep_setup(udc);\n}\n\n \nstatic int bcm63xx_update_link_speed(struct bcm63xx_udc *udc)\n{\n\tu32 reg = usbd_readl(udc, USBD_STATUS_REG);\n\tenum usb_device_speed oldspeed = udc->gadget.speed;\n\n\tswitch ((reg & USBD_STATUS_SPD_MASK) >> USBD_STATUS_SPD_SHIFT) {\n\tcase BCM63XX_SPD_HIGH:\n\t\tudc->gadget.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase BCM63XX_SPD_FULL:\n\t\tudc->gadget.speed = USB_SPEED_FULL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tdev_err(udc->dev,\n\t\t\t\"received SETUP packet with invalid link speed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udc->gadget.speed != oldspeed) {\n\t\tdev_info(udc->dev, \"link up, %s-speed mode\\n\",\n\t\t\t udc->gadget.speed == USB_SPEED_HIGH ? \"high\" : \"full\");\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n \nstatic void bcm63xx_update_wedge(struct bcm63xx_udc *udc, bool new_status)\n{\n\tint i;\n\n\tfor_each_set_bit(i, &udc->wedgemap, BCM63XX_NUM_EP) {\n\t\tbcm63xx_set_stall(udc, &udc->bep[i], new_status);\n\t\tif (!new_status)\n\t\t\tclear_bit(i, &udc->wedgemap);\n\t}\n}\n\n \nstatic irqreturn_t bcm63xx_udc_ctrl_isr(int irq, void *dev_id)\n{\n\tstruct bcm63xx_udc *udc = dev_id;\n\tu32 stat;\n\tbool disconnected = false, bus_reset = false;\n\n\tstat = usbd_readl(udc, USBD_EVENT_IRQ_STATUS_REG) &\n\t       usbd_readl(udc, USBD_EVENT_IRQ_MASK_REG);\n\n\tusbd_writel(udc, stat, USBD_EVENT_IRQ_STATUS_REG);\n\n\tspin_lock(&udc->lock);\n\tif (stat & BIT(USBD_EVENT_IRQ_USB_LINK)) {\n\t\t \n\n\t\tif (!(usbd_readl(udc, USBD_EVENTS_REG) &\n\t\t      USBD_EVENTS_USB_LINK_MASK) &&\n\t\t      udc->gadget.speed != USB_SPEED_UNKNOWN)\n\t\t\tdev_info(udc->dev, \"link down\\n\");\n\n\t\tudc->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tdisconnected = true;\n\t}\n\tif (stat & BIT(USBD_EVENT_IRQ_USB_RESET)) {\n\t\tbcm63xx_fifo_setup(udc);\n\t\tbcm63xx_fifo_reset(udc);\n\t\tbcm63xx_ep_setup(udc);\n\n\t\tbcm63xx_update_wedge(udc, false);\n\n\t\tudc->ep0_req_reset = 1;\n\t\tschedule_work(&udc->ep0_wq);\n\t\tbus_reset = true;\n\t}\n\tif (stat & BIT(USBD_EVENT_IRQ_SETUP)) {\n\t\tif (bcm63xx_update_link_speed(udc)) {\n\t\t\tbcm63xx_fifo_setup(udc);\n\t\t\tbcm63xx_ep_setup(udc);\n\t\t}\n\t\tbcm63xx_update_wedge(udc, true);\n\t}\n\tif (stat & BIT(USBD_EVENT_IRQ_SETCFG)) {\n\t\tbcm63xx_update_cfg_iface(udc);\n\t\tudc->ep0_req_set_cfg = 1;\n\t\tschedule_work(&udc->ep0_wq);\n\t}\n\tif (stat & BIT(USBD_EVENT_IRQ_SETINTF)) {\n\t\tbcm63xx_update_cfg_iface(udc);\n\t\tudc->ep0_req_set_iface = 1;\n\t\tschedule_work(&udc->ep0_wq);\n\t}\n\tspin_unlock(&udc->lock);\n\n\tif (disconnected && udc->driver)\n\t\tudc->driver->disconnect(&udc->gadget);\n\telse if (bus_reset && udc->driver)\n\t\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t bcm63xx_udc_data_isr(int irq, void *dev_id)\n{\n\tstruct iudma_ch *iudma = dev_id;\n\tstruct bcm63xx_udc *udc = iudma->udc;\n\tstruct bcm63xx_ep *bep;\n\tstruct usb_request *req = NULL;\n\tstruct bcm63xx_req *breq = NULL;\n\tint rc;\n\tbool is_done = false;\n\n\tspin_lock(&udc->lock);\n\n\tusb_dmac_writel(udc, ENETDMAC_IR_BUFDONE_MASK,\n\t\t\tENETDMAC_IR_REG, iudma->ch_idx);\n\tbep = iudma->bep;\n\trc = iudma_read(udc, iudma);\n\n\t \n\tif (iudma->ch_idx == IUDMA_EP0_RXCHAN ||\n\t    iudma->ch_idx == IUDMA_EP0_TXCHAN) {\n\t\treq = udc->ep0_request;\n\t\tbreq = our_req(req);\n\n\t\t \n\t\tif (rc >= 0) {\n\t\t\treq->actual += rc;\n\n\t\t\tif (req->actual >= req->length || breq->bd_bytes > rc) {\n\t\t\t\tudc->ep0_req_completed = 1;\n\t\t\t\tis_done = true;\n\t\t\t\tschedule_work(&udc->ep0_wq);\n\n\t\t\t\t \n\t\t\t\treq->actual = min(req->actual, req->length);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tiudma_write(udc, iudma, breq);\n\t\t\t}\n\t\t}\n\t} else if (!list_empty(&bep->queue)) {\n\t\tbreq = list_first_entry(&bep->queue, struct bcm63xx_req, queue);\n\t\treq = &breq->req;\n\n\t\tif (rc >= 0) {\n\t\t\treq->actual += rc;\n\n\t\t\tif (req->actual >= req->length || breq->bd_bytes > rc) {\n\t\t\t\tis_done = true;\n\t\t\t\tlist_del(&breq->queue);\n\n\t\t\t\treq->actual = min(req->actual, req->length);\n\n\t\t\t\tif (!list_empty(&bep->queue)) {\n\t\t\t\t\tstruct bcm63xx_req *next;\n\n\t\t\t\t\tnext = list_first_entry(&bep->queue,\n\t\t\t\t\t\tstruct bcm63xx_req, queue);\n\t\t\t\t\tiudma_write(udc, iudma, next);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tiudma_write(udc, iudma, breq);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&udc->lock);\n\n\tif (is_done) {\n\t\tusb_gadget_unmap_request(&udc->gadget, req, iudma->is_tx);\n\t\tif (req->complete)\n\t\t\treq->complete(&bep->ep, req);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int bcm63xx_usbd_dbg_show(struct seq_file *s, void *p)\n{\n\tstruct bcm63xx_udc *udc = s->private;\n\n\tif (!udc->driver)\n\t\treturn -ENODEV;\n\n\tseq_printf(s, \"ep0 state: %s\\n\",\n\t\t   bcm63xx_ep0_state_names[udc->ep0state]);\n\tseq_printf(s, \"  pending requests: %s%s%s%s%s%s%s\\n\",\n\t\t   udc->ep0_req_reset ? \"reset \" : \"\",\n\t\t   udc->ep0_req_set_cfg ? \"set_cfg \" : \"\",\n\t\t   udc->ep0_req_set_iface ? \"set_iface \" : \"\",\n\t\t   udc->ep0_req_shutdown ? \"shutdown \" : \"\",\n\t\t   udc->ep0_request ? \"pending \" : \"\",\n\t\t   udc->ep0_req_completed ? \"completed \" : \"\",\n\t\t   udc->ep0_reply ? \"reply \" : \"\");\n\tseq_printf(s, \"cfg: %d; iface: %d; alt_iface: %d\\n\",\n\t\t   udc->cfg, udc->iface, udc->alt_iface);\n\tseq_printf(s, \"regs:\\n\");\n\tseq_printf(s, \"  control: %08x; straps: %08x; status: %08x\\n\",\n\t\t   usbd_readl(udc, USBD_CONTROL_REG),\n\t\t   usbd_readl(udc, USBD_STRAPS_REG),\n\t\t   usbd_readl(udc, USBD_STATUS_REG));\n\tseq_printf(s, \"  events:  %08x; stall:  %08x\\n\",\n\t\t   usbd_readl(udc, USBD_EVENTS_REG),\n\t\t   usbd_readl(udc, USBD_STALL_REG));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(bcm63xx_usbd_dbg);\n\n \nstatic int bcm63xx_iudma_dbg_show(struct seq_file *s, void *p)\n{\n\tstruct bcm63xx_udc *udc = s->private;\n\tint ch_idx, i;\n\tu32 sram2, sram3;\n\n\tif (!udc->driver)\n\t\treturn -ENODEV;\n\n\tfor (ch_idx = 0; ch_idx < BCM63XX_NUM_IUDMA; ch_idx++) {\n\t\tstruct iudma_ch *iudma = &udc->iudma[ch_idx];\n\n\t\tseq_printf(s, \"IUDMA channel %d -- \", ch_idx);\n\t\tswitch (iudma_defaults[ch_idx].ep_type) {\n\t\tcase BCMEP_CTRL:\n\t\t\tseq_printf(s, \"control\");\n\t\t\tbreak;\n\t\tcase BCMEP_BULK:\n\t\t\tseq_printf(s, \"bulk\");\n\t\t\tbreak;\n\t\tcase BCMEP_INTR:\n\t\t\tseq_printf(s, \"interrupt\");\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(s, ch_idx & 0x01 ? \" tx\" : \" rx\");\n\t\tseq_printf(s, \" [ep%d]:\\n\",\n\t\t\t   max_t(int, iudma_defaults[ch_idx].ep_num, 0));\n\t\tseq_printf(s, \"  cfg: %08x; irqstat: %08x; irqmask: %08x; maxburst: %08x\\n\",\n\t\t\t   usb_dmac_readl(udc, ENETDMAC_CHANCFG_REG, ch_idx),\n\t\t\t   usb_dmac_readl(udc, ENETDMAC_IR_REG, ch_idx),\n\t\t\t   usb_dmac_readl(udc, ENETDMAC_IRMASK_REG, ch_idx),\n\t\t\t   usb_dmac_readl(udc, ENETDMAC_MAXBURST_REG, ch_idx));\n\n\t\tsram2 = usb_dmas_readl(udc, ENETDMAS_SRAM2_REG, ch_idx);\n\t\tsram3 = usb_dmas_readl(udc, ENETDMAS_SRAM3_REG, ch_idx);\n\t\tseq_printf(s, \"  base: %08x; index: %04x_%04x; desc: %04x_%04x %08x\\n\",\n\t\t\t   usb_dmas_readl(udc, ENETDMAS_RSTART_REG, ch_idx),\n\t\t\t   sram2 >> 16, sram2 & 0xffff,\n\t\t\t   sram3 >> 16, sram3 & 0xffff,\n\t\t\t   usb_dmas_readl(udc, ENETDMAS_SRAM4_REG, ch_idx));\n\t\tseq_printf(s, \"  desc: %d/%d used\", iudma->n_bds_used,\n\t\t\t   iudma->n_bds);\n\n\t\tif (iudma->bep)\n\t\t\tseq_printf(s, \"; %zu queued\\n\", list_count_nodes(&iudma->bep->queue));\n\t\telse\n\t\t\tseq_printf(s, \"\\n\");\n\n\t\tfor (i = 0; i < iudma->n_bds; i++) {\n\t\t\tstruct bcm_enet_desc *d = &iudma->bd_ring[i];\n\n\t\t\tseq_printf(s, \"  %03x (%02x): len_stat: %04x_%04x; pa %08x\",\n\t\t\t\t   i * sizeof(*d), i,\n\t\t\t\t   d->len_stat >> 16, d->len_stat & 0xffff,\n\t\t\t\t   d->address);\n\t\t\tif (d == iudma->read_bd)\n\t\t\t\tseq_printf(s, \"   <<RD\");\n\t\t\tif (d == iudma->write_bd)\n\t\t\t\tseq_printf(s, \"   <<WR\");\n\t\t\tseq_printf(s, \"\\n\");\n\t\t}\n\n\t\tseq_printf(s, \"\\n\");\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(bcm63xx_iudma_dbg);\n\n \nstatic void bcm63xx_udc_init_debugfs(struct bcm63xx_udc *udc)\n{\n\tstruct dentry *root;\n\n\tif (!IS_ENABLED(CONFIG_USB_GADGET_DEBUG_FS))\n\t\treturn;\n\n\troot = debugfs_create_dir(udc->gadget.name, usb_debug_root);\n\tdebugfs_create_file(\"usbd\", 0400, root, udc, &bcm63xx_usbd_dbg_fops);\n\tdebugfs_create_file(\"iudma\", 0400, root, udc, &bcm63xx_iudma_dbg_fops);\n}\n\n \nstatic void bcm63xx_udc_cleanup_debugfs(struct bcm63xx_udc *udc)\n{\n\tdebugfs_lookup_and_remove(udc->gadget.name, usb_debug_root);\n}\n\n \n\n \nstatic int bcm63xx_udc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct bcm63xx_usbd_platform_data *pd = dev_get_platdata(dev);\n\tstruct bcm63xx_udc *udc;\n\tint rc = -ENOMEM, i, irq;\n\n\tudc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, udc);\n\tudc->dev = dev;\n\tudc->pd = pd;\n\n\tif (!pd) {\n\t\tdev_err(dev, \"missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tudc->usbd_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(udc->usbd_regs))\n\t\treturn PTR_ERR(udc->usbd_regs);\n\n\tudc->iudma_regs = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(udc->iudma_regs))\n\t\treturn PTR_ERR(udc->iudma_regs);\n\n\tspin_lock_init(&udc->lock);\n\tINIT_WORK(&udc->ep0_wq, bcm63xx_ep0_process);\n\n\tudc->gadget.ops = &bcm63xx_udc_ops;\n\tudc->gadget.name = dev_name(dev);\n\n\tif (!pd->use_fullspeed && !use_fullspeed)\n\t\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\telse\n\t\tudc->gadget.max_speed = USB_SPEED_FULL;\n\n\t \n\trc = bcm63xx_init_udc_hw(udc);\n\tif (rc)\n\t\treturn rc;\n\n\trc = -ENXIO;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\trc = irq;\n\t\tgoto out_uninit;\n\t}\n\tif (devm_request_irq(dev, irq, &bcm63xx_udc_ctrl_isr, 0,\n\t\t\t     dev_name(dev), udc) < 0)\n\t\tgoto report_request_failure;\n\n\t \n\tfor (i = 0; i < BCM63XX_NUM_IUDMA; i++) {\n\t\tirq = platform_get_irq(pdev, i + 1);\n\t\tif (irq < 0) {\n\t\t\trc = irq;\n\t\t\tgoto out_uninit;\n\t\t}\n\t\tif (devm_request_irq(dev, irq, &bcm63xx_udc_data_isr, 0,\n\t\t\t\t     dev_name(dev), &udc->iudma[i]) < 0)\n\t\t\tgoto report_request_failure;\n\t}\n\n\tbcm63xx_udc_init_debugfs(udc);\n\trc = usb_add_gadget_udc(dev, &udc->gadget);\n\tif (!rc)\n\t\treturn 0;\n\n\tbcm63xx_udc_cleanup_debugfs(udc);\nout_uninit:\n\tbcm63xx_uninit_udc_hw(udc);\n\treturn rc;\n\nreport_request_failure:\n\tdev_err(dev, \"error requesting IRQ #%d\\n\", irq);\n\tgoto out_uninit;\n}\n\n \nstatic void bcm63xx_udc_remove(struct platform_device *pdev)\n{\n\tstruct bcm63xx_udc *udc = platform_get_drvdata(pdev);\n\n\tbcm63xx_udc_cleanup_debugfs(udc);\n\tusb_del_gadget_udc(&udc->gadget);\n\tBUG_ON(udc->driver);\n\n\tbcm63xx_uninit_udc_hw(udc);\n}\n\nstatic struct platform_driver bcm63xx_udc_driver = {\n\t.probe\t\t= bcm63xx_udc_probe,\n\t.remove_new\t= bcm63xx_udc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRV_MODULE_NAME,\n\t},\n};\nmodule_platform_driver(bcm63xx_udc_driver);\n\nMODULE_DESCRIPTION(\"BCM63xx USB Peripheral Controller\");\nMODULE_AUTHOR(\"Kevin Cernekee <cernekee@gmail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_MODULE_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}