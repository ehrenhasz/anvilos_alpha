{
  "module_name": "net2280.h",
  "hash_id": "94da40df275201e4dd4f99563398c7d3d02bb77320d0a27f793afe72aa6d5e1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/udc/net2280.h",
  "human_readable_source": "\n \n\n \n\n#include <linux/usb/net2280.h>\n#include <linux/usb/usb338x.h>\n\n \n\n#ifdef\t__KERNEL__\n\n \n\nstatic inline u32 get_idx_reg(struct net2280_regs __iomem *regs, u32 index)\n{\n\twritel(index, &regs->idxaddr);\n\t \n\treturn readl(&regs->idxdata);\n}\n\nstatic inline void\nset_idx_reg(struct net2280_regs __iomem *regs, u32 index, u32 value)\n{\n\twritel(index, &regs->idxaddr);\n\twritel(value, &regs->idxdata);\n\t \n}\n\n#endif\t \n\n#define PCI_VENDOR_ID_PLX_LEGACY 0x17cc\n\n#define PLX_LEGACY\t\tBIT(0)\n#define PLX_2280\t\tBIT(1)\n#define PLX_SUPERSPEED\t\tBIT(2)\n#define PLX_PCIE\t\tBIT(3)\n\n#define REG_DIAG\t\t0x0\n#define     RETRY_COUNTER                                       16\n#define     FORCE_PCI_SERR                                      11\n#define     FORCE_PCI_INTERRUPT                                 10\n#define     FORCE_USB_INTERRUPT                                 9\n#define     FORCE_CPU_INTERRUPT                                 8\n#define     ILLEGAL_BYTE_ENABLES                                5\n#define     FAST_TIMES                                          4\n#define     FORCE_RECEIVE_ERROR                                 2\n#define     FORCE_TRANSMIT_CRC_ERROR                            0\n#define REG_FRAME\t\t0x02\t \n#define REG_CHIPREV\t\t0x03\t \n#define\tREG_HS_NAK_RATE\t\t0x0a\t \n\n#define\tCHIPREV_1\t0x0100\n#define\tCHIPREV_1A\t0x0110\n\n \n#define DEFECT_7374_NUMBEROF_MAX_WAIT_LOOPS         200\n#define DEFECT_7374_PROCESSOR_WAIT_TIME             10\n\n \n#define EP0_SS_MAX_PACKET_SIZE  0x200\n#define EP0_HS_MAX_PACKET_SIZE  0x40\n#ifdef\t__KERNEL__\n\n \n\n \nstruct net2280_dma {\n\t__le32\t\tdmacount;\n\t__le32\t\tdmaaddr;\t\t \n\t__le32\t\tdmadesc;\t\t \n\t__le32\t\t_reserved;\n} __aligned(16);\n\n \n\n \n\nstruct net2280_ep {\n\tstruct usb_ep\t\t\t\tep;\n\tstruct net2280_ep_regs __iomem *cfg;\n\tstruct net2280_ep_regs\t\t\t__iomem *regs;\n\tstruct net2280_dma_regs\t\t\t__iomem *dma;\n\tstruct net2280_dma\t\t\t*dummy;\n\tdma_addr_t\t\t\t\ttd_dma;\t \n\tstruct net2280\t\t\t\t*dev;\n\tunsigned long\t\t\t\tirqs;\n\n\t \n\tstruct list_head\t\t\tqueue;\n\tconst struct usb_endpoint_descriptor\t*desc;\n\tunsigned\t\t\t\tnum : 8,\n\t\t\t\t\t\tfifo_size : 12,\n\t\t\t\t\t\tin_fifo_validate : 1,\n\t\t\t\t\t\tout_overflow : 1,\n\t\t\t\t\t\tstopped : 1,\n\t\t\t\t\t\twedged : 1,\n\t\t\t\t\t\tis_in : 1,\n\t\t\t\t\t\tis_iso : 1,\n\t\t\t\t\t\tresponded : 1;\n};\n\nstatic inline void allow_status(struct net2280_ep *ep)\n{\n\t \n\twritel(BIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE) |\n\t\tBIT(CLEAR_NAK_OUT_PACKETS) |\n\t\tBIT(CLEAR_NAK_OUT_PACKETS_MODE),\n\t\t&ep->regs->ep_rsp);\n\tep->stopped = 1;\n}\n\nstatic inline void allow_status_338x(struct net2280_ep *ep)\n{\n\t \n\twritel(BIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE), &ep->regs->ep_rsp);\n\n\tep->stopped = 1;\n\n\t \n\tep->responded = 0;\n}\n\nstruct net2280_request {\n\tstruct usb_request\t\treq;\n\tstruct net2280_dma\t\t*td;\n\tdma_addr_t\t\t\ttd_dma;\n\tstruct list_head\t\tqueue;\n\tunsigned\t\t\tmapped : 1,\n\t\t\t\t\tvalid : 1;\n};\n\nstruct net2280 {\n\t \n\tstruct usb_gadget\t\tgadget;\n\tspinlock_t\t\t\tlock;\n\tstruct net2280_ep\t\tep[9];\n\tstruct usb_gadget_driver\t*driver;\n\tunsigned\t\t\tenabled : 1,\n\t\t\t\t\tprotocol_stall : 1,\n\t\t\t\t\tsoftconnect : 1,\n\t\t\t\t\tgot_irq : 1,\n\t\t\t\t\tregion:1,\n\t\t\t\t\tadded:1,\n\t\t\t\t\tu1_enable:1,\n\t\t\t\t\tu2_enable:1,\n\t\t\t\t\tltm_enable:1,\n\t\t\t\t\twakeup_enable:1,\n\t\t\t\t\taddressed_state:1,\n\t\t\t\t\tasync_callbacks:1,\n\t\t\t\t\tbug7734_patched:1;\n\tu16\t\t\t\tchiprev;\n\tint enhanced_mode;\n\tint n_ep;\n\tkernel_ulong_t\t\t\tquirks;\n\n\n\t \n\tstruct pci_dev\t\t\t*pdev;\n\tstruct net2280_regs\t\t__iomem *regs;\n\tstruct net2280_usb_regs\t\t__iomem *usb;\n\tstruct usb338x_usb_ext_regs\t__iomem *usb_ext;\n\tstruct net2280_pci_regs\t\t__iomem *pci;\n\tstruct net2280_dma_regs\t\t__iomem *dma;\n\tstruct net2280_dep_regs\t\t__iomem *dep;\n\tstruct net2280_ep_regs\t\t__iomem *epregs;\n\tstruct usb338x_ll_regs\t\t__iomem *llregs;\n\tstruct usb338x_pl_regs\t\t__iomem *plregs;\n\n\tstruct dma_pool\t\t\t*requests;\n\t \n};\n\nstatic inline void set_halt(struct net2280_ep *ep)\n{\n\t \n\twritel(BIT(CLEAR_CONTROL_STATUS_PHASE_HANDSHAKE) |\n\t\t \n\t\t((ep->dev->chiprev == CHIPREV_1) << SET_NAK_OUT_PACKETS) |\n\t\tBIT(SET_ENDPOINT_HALT),\n\t\t&ep->regs->ep_rsp);\n}\n\nstatic inline void clear_halt(struct net2280_ep *ep)\n{\n\t \n\twritel(BIT(CLEAR_ENDPOINT_HALT) |\n\t\tBIT(CLEAR_ENDPOINT_TOGGLE) |\n\t\t     \n\t\t((ep->dev->chiprev == CHIPREV_1) << CLEAR_NAK_OUT_PACKETS),\n\t\t&ep->regs->ep_rsp);\n}\n\n \n#define DEFECT7374_FSM_FIELD    28\n\n \n#define DEFECT7374_FSM_WAITING_FOR_CONTROL_READ BIT(DEFECT7374_FSM_FIELD)\n\n \n#define\tDEFECT7374_FSM_NON_SS_CONTROL_READ (2 << DEFECT7374_FSM_FIELD)\n\n \n#define DEFECT7374_FSM_SS_CONTROL_READ (3 << DEFECT7374_FSM_FIELD)\n\n#ifdef USE_RDK_LEDS\n\nstatic inline void net2280_led_init(struct net2280 *dev)\n{\n\t \n\twritel(BIT(GPIO3_LED_SELECT) |\n\t\tBIT(GPIO3_OUTPUT_ENABLE) |\n\t\tBIT(GPIO2_OUTPUT_ENABLE) |\n\t\tBIT(GPIO1_OUTPUT_ENABLE) |\n\t\tBIT(GPIO0_OUTPUT_ENABLE),\n\t\t&dev->regs->gpioctl);\n}\n\n \nstatic inline\nvoid net2280_led_speed(struct net2280 *dev, enum usb_device_speed speed)\n{\n\tu32\tval = readl(&dev->regs->gpioctl);\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER:\t\t \n\t\tval |= BIT(GPIO0_DATA) | BIT(GPIO1_DATA);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\t\t \n\t\tval &= ~BIT(GPIO0_DATA);\n\t\tval |= BIT(GPIO1_DATA);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\t\t \n\t\tval &= ~BIT(GPIO1_DATA);\n\t\tval |= BIT(GPIO0_DATA);\n\t\tbreak;\n\tdefault:\t\t\t \n\t\tval &= ~(BIT(GPIO1_DATA) | BIT(GPIO0_DATA));\n\t\tbreak;\n\t}\n\twritel(val, &dev->regs->gpioctl);\n}\n\n \nstatic inline void net2280_led_active(struct net2280 *dev, int is_active)\n{\n\tu32\tval = readl(&dev->regs->gpioctl);\n\n\t \n\tif (is_active)\n\t\tval |= GPIO2_DATA;\n\telse\n\t\tval &= ~GPIO2_DATA;\n\twritel(val, &dev->regs->gpioctl);\n}\n\nstatic inline void net2280_led_shutdown(struct net2280 *dev)\n{\n\t \n\twritel(readl(&dev->regs->gpioctl) & ~0x0f,\n\t\t\t&dev->regs->gpioctl);\n}\n\n#else\n\n#define net2280_led_init(dev)\t\tdo { } while (0)\n#define net2280_led_speed(dev, speed)\tdo { } while (0)\n#define net2280_led_shutdown(dev)\tdo { } while (0)\n\n#endif\n\n \n\n#define ep_dbg(ndev, fmt, args...) \\\n\tdev_dbg((&((ndev)->pdev->dev)), fmt, ##args)\n\n#define ep_vdbg(ndev, fmt, args...) \\\n\tdev_vdbg((&((ndev)->pdev->dev)), fmt, ##args)\n\n#define ep_info(ndev, fmt, args...) \\\n\tdev_info((&((ndev)->pdev->dev)), fmt, ##args)\n\n#define ep_warn(ndev, fmt, args...) \\\n\tdev_warn((&((ndev)->pdev->dev)), fmt, ##args)\n\n#define ep_err(ndev, fmt, args...) \\\n\tdev_err((&((ndev)->pdev->dev)), fmt, ##args)\n\n \n\nstatic inline void set_fifo_bytecount(struct net2280_ep *ep, unsigned count)\n{\n\tif (ep->dev->pdev->vendor == 0x17cc)\n\t\twriteb(count, 2 + (u8 __iomem *) &ep->regs->ep_cfg);\n\telse{\n\t\tu32 tmp = readl(&ep->cfg->ep_cfg) &\n\t\t\t\t\t(~(0x07 << EP_FIFO_BYTE_COUNT));\n\t\twritel(tmp | (count << EP_FIFO_BYTE_COUNT), &ep->cfg->ep_cfg);\n\t}\n}\n\nstatic inline void start_out_naking(struct net2280_ep *ep)\n{\n\t \n\twritel(BIT(SET_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\n\t \n\treadl(&ep->regs->ep_rsp);\n}\n\nstatic inline void stop_out_naking(struct net2280_ep *ep)\n{\n\tu32\ttmp;\n\n\ttmp = readl(&ep->regs->ep_stat);\n\tif ((tmp & BIT(NAK_OUT_PACKETS)) != 0)\n\t\twritel(BIT(CLEAR_NAK_OUT_PACKETS), &ep->regs->ep_rsp);\n}\n\n\nstatic inline void set_max_speed(struct net2280_ep *ep, u32 max)\n{\n\tu32 reg;\n\tstatic const u32 ep_enhanced[9] = { 0x10, 0x60, 0x30, 0x80,\n\t\t\t\t\t  0x50, 0x20, 0x70, 0x40, 0x90 };\n\n\tif (ep->dev->enhanced_mode) {\n\t\treg = ep_enhanced[ep->num];\n\t\tswitch (ep->dev->gadget.speed) {\n\t\tcase USB_SPEED_SUPER:\n\t\t\treg += 2;\n\t\t\tbreak;\n\t\tcase USB_SPEED_FULL:\n\t\t\treg += 1;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\treg = (ep->num + 1) * 0x10;\n\t\tif (ep->dev->gadget.speed != USB_SPEED_HIGH)\n\t\t\treg += 1;\n\t}\n\n\tset_idx_reg(ep->dev->regs, reg, max);\n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}