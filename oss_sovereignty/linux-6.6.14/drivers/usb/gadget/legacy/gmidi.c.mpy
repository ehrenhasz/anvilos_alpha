{
  "module_name": "gmidi.c",
  "hash_id": "3484c2e10e88f15024e99098bcf56414de9a2ea2c9bdf80d506739dfd138a8c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/gmidi.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n\n#include <sound/initval.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n\n#include \"u_midi.h\"\n\n \n\nMODULE_AUTHOR(\"Ben Williamson\");\nMODULE_LICENSE(\"GPL v2\");\n\nstatic const char longname[] = \"MIDI Gadget\";\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\nstatic int index = SNDRV_DEFAULT_IDX1;\nmodule_param(index, int, S_IRUGO);\nMODULE_PARM_DESC(index, \"Index value for the USB MIDI Gadget adapter.\");\n\nstatic char *id = SNDRV_DEFAULT_STR1;\nmodule_param(id, charp, S_IRUGO);\nMODULE_PARM_DESC(id, \"ID string for the USB MIDI Gadget adapter.\");\n\nstatic unsigned int buflen = 512;\nmodule_param(buflen, uint, S_IRUGO);\nMODULE_PARM_DESC(buflen, \"MIDI buffer length\");\n\nstatic unsigned int qlen = 32;\nmodule_param(qlen, uint, S_IRUGO);\nMODULE_PARM_DESC(qlen, \"USB read and write request queue length\");\n\nstatic unsigned int in_ports = 1;\nmodule_param(in_ports, uint, S_IRUGO);\nMODULE_PARM_DESC(in_ports, \"Number of MIDI input ports\");\n\nstatic unsigned int out_ports = 1;\nmodule_param(out_ports, uint, S_IRUGO);\nMODULE_PARM_DESC(out_ports, \"Number of MIDI output ports\");\n\n \n#define DRIVER_VENDOR_NUM\t0x17b3\t\t \n#define DRIVER_PRODUCT_NUM\t0x0004\t\t \n\n \n\n#define STRING_DESCRIPTION_IDX\t\tUSB_GADGET_FIRST_AVAIL_IDX\n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tUSB_DT_DEVICE_SIZE,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\t \n\t.bDeviceClass =\t\tUSB_CLASS_PER_INTERFACE,\n\t.idVendor =\t\tcpu_to_le16(DRIVER_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(DRIVER_PRODUCT_NUM),\n\t \n\t \n\t.bNumConfigurations =\t1,\n};\n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s\t= \"Grey Innovation\",\n\t[USB_GADGET_PRODUCT_IDX].s\t= \"MIDI Gadget\",\n\t[USB_GADGET_SERIAL_IDX].s\t= \"\",\n\t[STRING_DESCRIPTION_IDX].s\t= \"MIDI\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_dev,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\nstatic struct usb_function_instance *fi_midi;\nstatic struct usb_function *f_midi;\n\nstatic int midi_unbind(struct usb_composite_dev *dev)\n{\n\tusb_put_function(f_midi);\n\tusb_put_function_instance(fi_midi);\n\treturn 0;\n}\n\nstatic struct usb_configuration midi_config = {\n\t.label\t\t= \"MIDI Gadget\",\n\t.bConfigurationValue = 1,\n\t \n\t.bmAttributes\t= USB_CONFIG_ATT_ONE,\n\t.MaxPower\t= CONFIG_USB_GADGET_VBUS_DRAW,\n};\n\nstatic int midi_bind_config(struct usb_configuration *c)\n{\n\tint status;\n\n\tf_midi = usb_get_function(fi_midi);\n\tif (IS_ERR(f_midi))\n\t\treturn PTR_ERR(f_midi);\n\n\tstatus = usb_add_function(c, f_midi);\n\tif (status < 0) {\n\t\tusb_put_function(f_midi);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int midi_bind(struct usb_composite_dev *cdev)\n{\n\tstruct f_midi_opts *midi_opts;\n\tint status;\n\n\tfi_midi = usb_get_function_instance(\"midi\");\n\tif (IS_ERR(fi_midi))\n\t\treturn PTR_ERR(fi_midi);\n\n\tmidi_opts = container_of(fi_midi, struct f_midi_opts, func_inst);\n\tmidi_opts->index = index;\n\tmidi_opts->id = id;\n\tmidi_opts->in_ports = in_ports;\n\tmidi_opts->out_ports = out_ports;\n\tmidi_opts->buflen = buflen;\n\tmidi_opts->qlen = qlen;\n\n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\tgoto put;\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\tmidi_config.iConfiguration = strings_dev[STRING_DESCRIPTION_IDX].id;\n\n\tstatus = usb_add_config(cdev, &midi_config, midi_bind_config);\n\tif (status < 0)\n\t\tgoto put;\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\tpr_info(\"%s\\n\", longname);\n\treturn 0;\nput:\n\tusb_put_function_instance(fi_midi);\n\treturn status;\n}\n\nstatic struct usb_composite_driver midi_driver = {\n\t.name\t\t= longname,\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_HIGH,\n\t.bind\t\t= midi_bind,\n\t.unbind\t\t= midi_unbind,\n};\n\nmodule_usb_composite_driver(midi_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}