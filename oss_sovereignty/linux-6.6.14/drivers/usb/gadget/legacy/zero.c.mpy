{
  "module_name": "zero.c",
  "hash_id": "daa5e32af8f1c17f91a96e7b296c6a96887eb55f3737c9bdd2f2f1f38fba0c58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/zero.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/usb/composite.h>\n\n#include \"g_zero.h\"\n \nUSB_GADGET_COMPOSITE_OPTIONS();\n\n#define DRIVER_VERSION\t\t\"Cinco de Mayo 2008\"\n\nstatic const char longname[] = \"Gadget Zero\";\n\n \nstatic bool loopdefault = 0;\nmodule_param(loopdefault, bool, S_IRUGO|S_IWUSR);\n\nstatic struct usb_zero_options gzero_options = {\n\t.isoc_interval = GZERO_ISOC_INTERVAL,\n\t.isoc_maxpacket = GZERO_ISOC_MAXPACKET,\n\t.bulk_buflen = GZERO_BULK_BUFLEN,\n\t.qlen = GZERO_QLEN,\n\t.ss_bulk_qlen = GZERO_SS_BULK_QLEN,\n\t.ss_iso_qlen = GZERO_SS_ISO_QLEN,\n};\n\n \n\n \n#ifndef\tCONFIG_USB_ZERO_HNPTEST\n#define DRIVER_VENDOR_NUM\t0x0525\t\t \n#define DRIVER_PRODUCT_NUM\t0xa4a0\t\t \n#define DEFAULT_AUTORESUME\t0\n#else\n#define DRIVER_VENDOR_NUM\t0x1a0a\t\t \n#define DRIVER_PRODUCT_NUM\t0xbadd\n#define DEFAULT_AUTORESUME\t5\n#endif\n\n \nstatic unsigned autoresume = DEFAULT_AUTORESUME;\nmodule_param(autoresume, uint, S_IRUGO);\nMODULE_PARM_DESC(autoresume, \"zero, or seconds before remote wakeup\");\n\n \nstatic unsigned max_autoresume;\nmodule_param(max_autoresume, uint, S_IRUGO);\nMODULE_PARM_DESC(max_autoresume, \"maximum seconds before remote wakeup\");\n\n \nstatic unsigned autoresume_interval_ms;\nmodule_param(autoresume_interval_ms, uint, S_IRUGO);\nMODULE_PARM_DESC(autoresume_interval_ms,\n\t\t\"milliseconds to increase successive wakeup delays\");\n\nstatic unsigned autoresume_step_ms;\n \n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\n\t \n\t.bDeviceClass =\t\tUSB_CLASS_VENDOR_SPEC,\n\n\t.idVendor =\t\tcpu_to_le16(DRIVER_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(DRIVER_PRODUCT_NUM),\n\t.bNumConfigurations =\t2,\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\n \n \nstatic char serial[] = \"0123456789.0123456789.0123456789\";\n\n#define USB_GZERO_SS_DESC\t(USB_GADGET_FIRST_AVAIL_IDX + 0)\n#define USB_GZERO_LB_DESC\t(USB_GADGET_FIRST_AVAIL_IDX + 1)\n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = longname,\n\t[USB_GADGET_SERIAL_IDX].s = serial,\n\t[USB_GZERO_SS_DESC].s\t= \"source and sink data\",\n\t[USB_GZERO_LB_DESC].s\t= \"loop input to output\",\n\t{  }\t\t\t \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_dev,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\n \n\nstatic struct timer_list\tautoresume_timer;\nstatic struct usb_composite_dev *autoresume_cdev;\n\nstatic void zero_autoresume(struct timer_list *unused)\n{\n\tstruct usb_composite_dev\t*cdev = autoresume_cdev;\n\tstruct usb_gadget\t\t*g = cdev->gadget;\n\n\t \n\tif (!cdev->config)\n\t\treturn;\n\n\t \n\tif (g->speed != USB_SPEED_UNKNOWN) {\n\t\tint status = usb_gadget_wakeup(g);\n\t\tINFO(cdev, \"%s --> %d\\n\", __func__, status);\n\t}\n}\n\nstatic void zero_suspend(struct usb_composite_dev *cdev)\n{\n\tif (cdev->gadget->speed == USB_SPEED_UNKNOWN)\n\t\treturn;\n\n\tif (autoresume) {\n\t\tif (max_autoresume &&\n\t\t\t(autoresume_step_ms > max_autoresume * 1000))\n\t\t\t\tautoresume_step_ms = autoresume * 1000;\n\n\t\tmod_timer(&autoresume_timer, jiffies +\n\t\t\tmsecs_to_jiffies(autoresume_step_ms));\n\t\tDBG(cdev, \"suspend, wakeup in %d milliseconds\\n\",\n\t\t\tautoresume_step_ms);\n\n\t\tautoresume_step_ms += autoresume_interval_ms;\n\t} else\n\t\tDBG(cdev, \"%s\\n\", __func__);\n}\n\nstatic void zero_resume(struct usb_composite_dev *cdev)\n{\n\tDBG(cdev, \"%s\\n\", __func__);\n\tdel_timer(&autoresume_timer);\n}\n\n \n\nstatic struct usb_configuration loopback_driver = {\n\t.label          = \"loopback\",\n\t.bConfigurationValue = 2,\n\t.bmAttributes   = USB_CONFIG_ATT_SELFPOWER,\n\t \n};\n\nstatic struct usb_function *func_ss;\nstatic struct usb_function_instance *func_inst_ss;\n\nstatic int ss_config_setup(struct usb_configuration *c,\n\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tswitch (ctrl->bRequest) {\n\tcase 0x5b:\n\tcase 0x5c:\n\t\treturn func_ss->setup(func_ss, ctrl);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic struct usb_configuration sourcesink_driver = {\n\t.label                  = \"source/sink\",\n\t.setup                  = ss_config_setup,\n\t.bConfigurationValue    = 3,\n\t.bmAttributes           = USB_CONFIG_ATT_SELFPOWER,\n\t \n};\n\nmodule_param_named(buflen, gzero_options.bulk_buflen, uint, 0);\nmodule_param_named(pattern, gzero_options.pattern, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(pattern, \"0 = all zeroes, 1 = mod63, 2 = none\");\n\nmodule_param_named(isoc_interval, gzero_options.isoc_interval, uint,\n\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(isoc_interval, \"1 - 16\");\n\nmodule_param_named(isoc_maxpacket, gzero_options.isoc_maxpacket, uint,\n\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(isoc_maxpacket, \"0 - 1023 (fs), 0 - 1024 (hs/ss)\");\n\nmodule_param_named(isoc_mult, gzero_options.isoc_mult, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(isoc_mult, \"0 - 2 (hs/ss only)\");\n\nmodule_param_named(isoc_maxburst, gzero_options.isoc_maxburst, uint,\n\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(isoc_maxburst, \"0 - 15 (ss only)\");\n\nstatic struct usb_function *func_lb;\nstatic struct usb_function_instance *func_inst_lb;\n\nmodule_param_named(qlen, gzero_options.qlen, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(qlen, \"depth of loopback queue\");\n\nmodule_param_named(ss_bulk_qlen, gzero_options.ss_bulk_qlen, uint,\n\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(bulk_qlen, \"depth of sourcesink queue for bulk transfer\");\n\nmodule_param_named(ss_iso_qlen, gzero_options.ss_iso_qlen, uint,\n\t\tS_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(iso_qlen, \"depth of sourcesink queue for iso transfer\");\n\nstatic int zero_bind(struct usb_composite_dev *cdev)\n{\n\tstruct f_ss_opts\t*ss_opts;\n\tstruct f_lb_opts\t*lb_opts;\n\tint\t\t\tstatus;\n\n\t \n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\treturn status;\n\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\tdevice_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;\n\n\tautoresume_cdev = cdev;\n\ttimer_setup(&autoresume_timer, zero_autoresume, 0);\n\n\tfunc_inst_ss = usb_get_function_instance(\"SourceSink\");\n\tif (IS_ERR(func_inst_ss))\n\t\treturn PTR_ERR(func_inst_ss);\n\n\tss_opts =  container_of(func_inst_ss, struct f_ss_opts, func_inst);\n\tss_opts->pattern = gzero_options.pattern;\n\tss_opts->isoc_interval = gzero_options.isoc_interval;\n\tss_opts->isoc_maxpacket = gzero_options.isoc_maxpacket;\n\tss_opts->isoc_mult = gzero_options.isoc_mult;\n\tss_opts->isoc_maxburst = gzero_options.isoc_maxburst;\n\tss_opts->bulk_buflen = gzero_options.bulk_buflen;\n\tss_opts->bulk_qlen = gzero_options.ss_bulk_qlen;\n\tss_opts->iso_qlen = gzero_options.ss_iso_qlen;\n\n\tfunc_ss = usb_get_function(func_inst_ss);\n\tif (IS_ERR(func_ss)) {\n\t\tstatus = PTR_ERR(func_ss);\n\t\tgoto err_put_func_inst_ss;\n\t}\n\n\tfunc_inst_lb = usb_get_function_instance(\"Loopback\");\n\tif (IS_ERR(func_inst_lb)) {\n\t\tstatus = PTR_ERR(func_inst_lb);\n\t\tgoto err_put_func_ss;\n\t}\n\n\tlb_opts = container_of(func_inst_lb, struct f_lb_opts, func_inst);\n\tlb_opts->bulk_buflen = gzero_options.bulk_buflen;\n\tlb_opts->qlen = gzero_options.qlen;\n\n\tfunc_lb = usb_get_function(func_inst_lb);\n\tif (IS_ERR(func_lb)) {\n\t\tstatus = PTR_ERR(func_lb);\n\t\tgoto err_put_func_inst_lb;\n\t}\n\n\tsourcesink_driver.iConfiguration = strings_dev[USB_GZERO_SS_DESC].id;\n\tloopback_driver.iConfiguration = strings_dev[USB_GZERO_LB_DESC].id;\n\n\t \n\tsourcesink_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;\n\tloopback_driver.bmAttributes &= ~USB_CONFIG_ATT_WAKEUP;\n\tsourcesink_driver.descriptors = NULL;\n\tloopback_driver.descriptors = NULL;\n\tif (autoresume) {\n\t\tsourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t\tloopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t\tautoresume_step_ms = autoresume * 1000;\n\t}\n\n\t \n\tif (gadget_is_otg(cdev->gadget)) {\n\t\tif (!otg_desc[0]) {\n\t\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\t\tusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\n\t\t\tif (!usb_desc) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto err_conf_flb;\n\t\t\t}\n\t\t\tusb_otg_descriptor_init(cdev->gadget, usb_desc);\n\t\t\totg_desc[0] = usb_desc;\n\t\t\totg_desc[1] = NULL;\n\t\t}\n\t\tsourcesink_driver.descriptors = otg_desc;\n\t\tsourcesink_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t\tloopback_driver.descriptors = otg_desc;\n\t\tloopback_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\t \n\tif (loopdefault) {\n\t\tusb_add_config_only(cdev, &loopback_driver);\n\t\tusb_add_config_only(cdev, &sourcesink_driver);\n\t} else {\n\t\tusb_add_config_only(cdev, &sourcesink_driver);\n\t\tusb_add_config_only(cdev, &loopback_driver);\n\t}\n\tstatus = usb_add_function(&sourcesink_driver, func_ss);\n\tif (status)\n\t\tgoto err_free_otg_desc;\n\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\tstatus = usb_add_function(&loopback_driver, func_lb);\n\tif (status)\n\t\tgoto err_free_otg_desc;\n\n\tusb_ep_autoconfig_reset(cdev->gadget);\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\n\tINFO(cdev, \"%s, version: \" DRIVER_VERSION \"\\n\", longname);\n\n\treturn 0;\n\nerr_free_otg_desc:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nerr_conf_flb:\n\tusb_put_function(func_lb);\n\tfunc_lb = NULL;\nerr_put_func_inst_lb:\n\tusb_put_function_instance(func_inst_lb);\n\tfunc_inst_lb = NULL;\nerr_put_func_ss:\n\tusb_put_function(func_ss);\n\tfunc_ss = NULL;\nerr_put_func_inst_ss:\n\tusb_put_function_instance(func_inst_ss);\n\tfunc_inst_ss = NULL;\n\treturn status;\n}\n\nstatic int zero_unbind(struct usb_composite_dev *cdev)\n{\n\tdel_timer_sync(&autoresume_timer);\n\tif (!IS_ERR_OR_NULL(func_ss))\n\t\tusb_put_function(func_ss);\n\tusb_put_function_instance(func_inst_ss);\n\tif (!IS_ERR_OR_NULL(func_lb))\n\t\tusb_put_function(func_lb);\n\tusb_put_function_instance(func_inst_lb);\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic struct usb_composite_driver zero_driver = {\n\t.name\t\t= \"zero\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_SUPER,\n\t.bind\t\t= zero_bind,\n\t.unbind\t\t= zero_unbind,\n\t.suspend\t= zero_suspend,\n\t.resume\t\t= zero_resume,\n};\n\nmodule_usb_composite_driver(zero_driver);\n\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}