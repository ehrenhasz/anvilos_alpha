{
  "module_name": "g_ffs.c",
  "hash_id": "976288e612076493c9f7a27f814c226150a84e770e9405d95b2a37fbd81fa4ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/g_ffs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"g_ffs: \" fmt\n\n#include <linux/module.h>\n\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\n#include <linux/netdevice.h>\n\n#  if defined USB_ETH_RNDIS\n#    undef USB_ETH_RNDIS\n#  endif\n#  ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n#    define USB_ETH_RNDIS y\n#  endif\n\n#  include \"u_ecm.h\"\n#  include \"u_gether.h\"\n#  ifdef USB_ETH_RNDIS\n#    include \"u_rndis.h\"\n#    include \"rndis.h\"\n#  endif\n#  include \"u_ether.h\"\n\nUSB_ETHERNET_MODULE_PARAMETERS();\n\n#  ifdef CONFIG_USB_FUNCTIONFS_ETH\nstatic int eth_bind_config(struct usb_configuration *c);\nstatic struct usb_function_instance *fi_ecm;\nstatic struct usb_function *f_ecm;\nstatic struct usb_function_instance *fi_geth;\nstatic struct usb_function *f_geth;\n#  endif\n#  ifdef CONFIG_USB_FUNCTIONFS_RNDIS\nstatic int bind_rndis_config(struct usb_configuration *c);\nstatic struct usb_function_instance *fi_rndis;\nstatic struct usb_function *f_rndis;\n#  endif\n#endif\n\n#include \"u_fs.h\"\n\n#define DRIVER_NAME\t\"g_ffs\"\n#define DRIVER_DESC\t\"USB Function Filesystem\"\n#define DRIVER_VERSION\t\"24 Aug 2004\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Michal Nazarewicz\");\nMODULE_LICENSE(\"GPL\");\n\n#define GFS_VENDOR_ID\t0x1d6b\t \n#define GFS_PRODUCT_ID\t0x0105\t \n\n#define GFS_MAX_DEVS\t10\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\nstatic struct usb_device_descriptor gfs_dev_desc = {\n\t.bLength\t\t= sizeof gfs_dev_desc,\n\t.bDescriptorType\t= USB_DT_DEVICE,\n\n\t \n\t.bDeviceClass\t\t= USB_CLASS_PER_INTERFACE,\n\n\t.idVendor\t\t= cpu_to_le16(GFS_VENDOR_ID),\n\t.idProduct\t\t= cpu_to_le16(GFS_PRODUCT_ID),\n};\n\nstatic char *func_names[GFS_MAX_DEVS];\nstatic unsigned int func_num;\n\nmodule_param_named(bDeviceClass,    gfs_dev_desc.bDeviceClass,    byte,   0644);\nMODULE_PARM_DESC(bDeviceClass, \"USB Device class\");\nmodule_param_named(bDeviceSubClass, gfs_dev_desc.bDeviceSubClass, byte,   0644);\nMODULE_PARM_DESC(bDeviceSubClass, \"USB Device subclass\");\nmodule_param_named(bDeviceProtocol, gfs_dev_desc.bDeviceProtocol, byte,   0644);\nMODULE_PARM_DESC(bDeviceProtocol, \"USB Device protocol\");\nmodule_param_array_named(functions, func_names, charp, &func_num, 0);\nMODULE_PARM_DESC(functions, \"USB Functions list\");\n\nstatic const struct usb_descriptor_header *gfs_otg_desc[2];\n\n \nstatic struct usb_string gfs_strings[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\t{ .s = \"FunctionFS + RNDIS\" },\n#endif\n#ifdef CONFIG_USB_FUNCTIONFS_ETH\n\t{ .s = \"FunctionFS + ECM\" },\n#endif\n#ifdef CONFIG_USB_FUNCTIONFS_GENERIC\n\t{ .s = \"FunctionFS\" },\n#endif\n\t{  }  \n};\n\nstatic struct usb_gadget_strings *gfs_dev_strings[] = {\n\t&(struct usb_gadget_strings) {\n\t\t.language\t= 0x0409,\t \n\t\t.strings\t= gfs_strings,\n\t},\n\tNULL,\n};\n\nstruct gfs_configuration {\n\tstruct usb_configuration c;\n\tint (*eth)(struct usb_configuration *c);\n\tint num;\n};\n\nstatic struct gfs_configuration gfs_configurations[] = {\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\t{\n\t\t.eth\t\t= bind_rndis_config,\n\t},\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_ETH\n\t{\n\t\t.eth\t\t= eth_bind_config,\n\t},\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_GENERIC\n\t{\n\t},\n#endif\n};\n\nstatic void *functionfs_acquire_dev(struct ffs_dev *dev);\nstatic void functionfs_release_dev(struct ffs_dev *dev);\nstatic int functionfs_ready_callback(struct ffs_data *ffs);\nstatic void functionfs_closed_callback(struct ffs_data *ffs);\nstatic int gfs_bind(struct usb_composite_dev *cdev);\nstatic int gfs_unbind(struct usb_composite_dev *cdev);\nstatic int gfs_do_config(struct usb_configuration *c);\n\n\nstatic struct usb_composite_driver gfs_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.dev\t\t= &gfs_dev_desc,\n\t.strings\t= gfs_dev_strings,\n\t.max_speed\t= USB_SPEED_SUPER,\n\t.bind\t\t= gfs_bind,\n\t.unbind\t\t= gfs_unbind,\n};\n\nstatic unsigned int missing_funcs;\nstatic bool gfs_registered;\nstatic bool gfs_single_func;\nstatic struct usb_function_instance **fi_ffs;\nstatic struct usb_function **f_ffs[] = {\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\tNULL,\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_ETH\n\tNULL,\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_GENERIC\n\tNULL,\n#endif\n};\n\n#define N_CONF ARRAY_SIZE(f_ffs)\n\nstatic int __init gfs_init(void)\n{\n\tstruct f_fs_opts *opts;\n\tint i;\n\tint ret = 0;\n\n\tif (func_num < 2) {\n\t\tgfs_single_func = true;\n\t\tfunc_num = 1;\n\t}\n\n\t \n\tf_ffs[0] = kcalloc(func_num * N_CONF, sizeof(*f_ffs), GFP_KERNEL);\n\tif (!f_ffs[0]) {\n\t\tret = -ENOMEM;\n\t\tgoto no_func;\n\t}\n\tfor (i = 1; i < N_CONF; ++i)\n\t\tf_ffs[i] = f_ffs[0] + i * func_num;\n\n\tfi_ffs = kcalloc(func_num, sizeof(*fi_ffs), GFP_KERNEL);\n\tif (!fi_ffs) {\n\t\tret = -ENOMEM;\n\t\tgoto no_func;\n\t}\n\n\tfor (i = 0; i < func_num; i++) {\n\t\tfi_ffs[i] = usb_get_function_instance(\"ffs\");\n\t\tif (IS_ERR(fi_ffs[i])) {\n\t\t\tret = PTR_ERR(fi_ffs[i]);\n\t\t\t--i;\n\t\t\tgoto no_dev;\n\t\t}\n\t\topts = to_f_fs_opts(fi_ffs[i]);\n\t\tif (gfs_single_func)\n\t\t\tret = ffs_single_dev(opts->dev);\n\t\telse\n\t\t\tret = ffs_name_dev(opts->dev, func_names[i]);\n\t\tif (ret)\n\t\t\tgoto no_dev;\n\t\topts->dev->ffs_ready_callback = functionfs_ready_callback;\n\t\topts->dev->ffs_closed_callback = functionfs_closed_callback;\n\t\topts->dev->ffs_acquire_dev_callback = functionfs_acquire_dev;\n\t\topts->dev->ffs_release_dev_callback = functionfs_release_dev;\n\t\topts->no_configfs = true;\n\t}\n\n\tmissing_funcs = func_num;\n\n\treturn 0;\nno_dev:\n\twhile (i >= 0)\n\t\tusb_put_function_instance(fi_ffs[i--]);\n\tkfree(fi_ffs);\nno_func:\n\tkfree(f_ffs[0]);\n\treturn ret;\n}\nmodule_init(gfs_init);\n\nstatic void __exit gfs_exit(void)\n{\n\tint i;\n\n\tif (gfs_registered)\n\t\tusb_composite_unregister(&gfs_driver);\n\tgfs_registered = false;\n\n\tkfree(f_ffs[0]);\n\n\tfor (i = 0; i < func_num; i++)\n\t\tusb_put_function_instance(fi_ffs[i]);\n\n\tkfree(fi_ffs);\n}\nmodule_exit(gfs_exit);\n\nstatic void *functionfs_acquire_dev(struct ffs_dev *dev)\n{\n\tif (!try_module_get(THIS_MODULE))\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn NULL;\n}\n\nstatic void functionfs_release_dev(struct ffs_dev *dev)\n{\n\tmodule_put(THIS_MODULE);\n}\n\n \nstatic int functionfs_ready_callback(struct ffs_data *ffs)\n{\n\tint ret = 0;\n\n\tif (--missing_funcs)\n\t\treturn 0;\n\n\tif (gfs_registered)\n\t\treturn -EBUSY;\n\n\tgfs_registered = true;\n\n\tret = usb_composite_probe(&gfs_driver);\n\tif (unlikely(ret < 0)) {\n\t\t++missing_funcs;\n\t\tgfs_registered = false;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void functionfs_closed_callback(struct ffs_data *ffs)\n{\n\tmissing_funcs++;\n\n\tif (gfs_registered)\n\t\tusb_composite_unregister(&gfs_driver);\n\tgfs_registered = false;\n}\n\n \nstatic int gfs_bind(struct usb_composite_dev *cdev)\n{\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\n\tstruct net_device *net;\n#endif\n\tint ret, i;\n\n\tif (missing_funcs)\n\t\treturn -ENODEV;\n#if defined CONFIG_USB_FUNCTIONFS_ETH\n\tif (can_support_ecm(cdev->gadget)) {\n\t\tstruct f_ecm_opts *ecm_opts;\n\n\t\tfi_ecm = usb_get_function_instance(\"ecm\");\n\t\tif (IS_ERR(fi_ecm))\n\t\t\treturn PTR_ERR(fi_ecm);\n\t\tecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\n\t\tnet = ecm_opts->net;\n\t} else {\n\t\tstruct f_gether_opts *geth_opts;\n\n\t\tfi_geth = usb_get_function_instance(\"geth\");\n\t\tif (IS_ERR(fi_geth))\n\t\t\treturn PTR_ERR(fi_geth);\n\t\tgeth_opts = container_of(fi_geth, struct f_gether_opts,\n\t\t\t\t\t func_inst);\n\t\tnet = geth_opts->net;\n\t}\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\t{\n\t\tfi_rndis = usb_get_function_instance(\"rndis\");\n\t\tif (IS_ERR(fi_rndis)) {\n\t\t\tret = PTR_ERR(fi_rndis);\n\t\t\tgoto error;\n\t\t}\n#ifndef CONFIG_USB_FUNCTIONFS_ETH\n\t\tnet = container_of(fi_rndis, struct f_rndis_opts,\n\t\t\t\t   func_inst)->net;\n#endif\n\t}\n#endif\n\n#if defined CONFIG_USB_FUNCTIONFS_ETH || defined CONFIG_USB_FUNCTIONFS_RNDIS\n\tgether_set_qmult(net, qmult);\n\tif (!gether_set_host_addr(net, host_addr))\n\t\tpr_info(\"using host ethernet address: %s\", host_addr);\n\tif (!gether_set_dev_addr(net, dev_addr))\n\t\tpr_info(\"using self ethernet address: %s\", dev_addr);\n#endif\n\n#if defined CONFIG_USB_FUNCTIONFS_RNDIS && defined CONFIG_USB_FUNCTIONFS_ETH\n\tgether_set_gadget(net, cdev->gadget);\n\tret = gether_register_netdev(net);\n\tif (ret)\n\t\tgoto error_rndis;\n\n\tif (can_support_ecm(cdev->gadget)) {\n\t\tstruct f_ecm_opts *ecm_opts;\n\n\t\tecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\n\t\tecm_opts->bound = true;\n\t} else {\n\t\tstruct f_gether_opts *geth_opts;\n\n\t\tgeth_opts = container_of(fi_geth, struct f_gether_opts,\n\t\t\t\t\t func_inst);\n\t\tgeth_opts->bound = true;\n\t}\n\n\trndis_borrow_net(fi_rndis, net);\n#endif\n\n\t \n\tret = usb_string_ids_tab(cdev, gfs_strings);\n\tif (unlikely(ret < 0))\n\t\tgoto error_rndis;\n\tgfs_dev_desc.iProduct = gfs_strings[USB_GADGET_PRODUCT_IDX].id;\n\n\tif (gadget_is_otg(cdev->gadget) && !gfs_otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\n\t\tif (!usb_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_rndis;\n\t\t}\n\t\tusb_otg_descriptor_init(cdev->gadget, usb_desc);\n\t\tgfs_otg_desc[0] = usb_desc;\n\t\tgfs_otg_desc[1] = NULL;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(gfs_configurations); ++i) {\n\t\tstruct gfs_configuration *c = gfs_configurations + i;\n\t\tint sid = USB_GADGET_FIRST_AVAIL_IDX + i;\n\n\t\tc->c.label\t\t\t= gfs_strings[sid].s;\n\t\tc->c.iConfiguration\t\t= gfs_strings[sid].id;\n\t\tc->c.bConfigurationValue\t= 1 + i;\n\t\tc->c.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER;\n\n\t\tc->num = i;\n\n\t\tret = usb_add_config(cdev, &c->c, gfs_do_config);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error_unbind;\n\t}\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\treturn 0;\n\n \nerror_unbind:\n\tkfree(gfs_otg_desc[0]);\n\tgfs_otg_desc[0] = NULL;\nerror_rndis:\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\tusb_put_function_instance(fi_rndis);\nerror:\n#endif\n#if defined CONFIG_USB_FUNCTIONFS_ETH\n\tif (can_support_ecm(cdev->gadget))\n\t\tusb_put_function_instance(fi_ecm);\n\telse\n\t\tusb_put_function_instance(fi_geth);\n#endif\n\treturn ret;\n}\n\n \nstatic int gfs_unbind(struct usb_composite_dev *cdev)\n{\n\tint i;\n\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\tusb_put_function(f_rndis);\n\tusb_put_function_instance(fi_rndis);\n#endif\n\n#if defined CONFIG_USB_FUNCTIONFS_ETH\n\tif (can_support_ecm(cdev->gadget)) {\n\t\tusb_put_function(f_ecm);\n\t\tusb_put_function_instance(fi_ecm);\n\t} else {\n\t\tusb_put_function(f_geth);\n\t\tusb_put_function_instance(fi_geth);\n\t}\n#endif\n\tfor (i = 0; i < N_CONF * func_num; ++i)\n\t\tusb_put_function(*(f_ffs[0] + i));\n\n\tkfree(gfs_otg_desc[0]);\n\tgfs_otg_desc[0] = NULL;\n\n\treturn 0;\n}\n\n \nstatic int gfs_do_config(struct usb_configuration *c)\n{\n\tstruct gfs_configuration *gc =\n\t\tcontainer_of(c, struct gfs_configuration, c);\n\tint i;\n\tint ret;\n\n\tif (missing_funcs)\n\t\treturn -ENODEV;\n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = gfs_otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tif (gc->eth) {\n\t\tret = gc->eth(c);\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < func_num; i++) {\n\t\tf_ffs[gc->num][i] = usb_get_function(fi_ffs[i]);\n\t\tif (IS_ERR(f_ffs[gc->num][i])) {\n\t\t\tret = PTR_ERR(f_ffs[gc->num][i]);\n\t\t\tgoto error;\n\t\t}\n\t\tret = usb_add_function(c, f_ffs[gc->num][i]);\n\t\tif (ret < 0) {\n\t\t\tusb_put_function(f_ffs[gc->num][i]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tif (c->next_interface_id < ARRAY_SIZE(c->interface))\n\t\tc->interface[c->next_interface_id] = NULL;\n\n\treturn 0;\nerror:\n\twhile (--i >= 0) {\n\t\tif (!IS_ERR(f_ffs[gc->num][i]))\n\t\t\tusb_remove_function(c, f_ffs[gc->num][i]);\n\t\tusb_put_function(f_ffs[gc->num][i]);\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_USB_FUNCTIONFS_ETH\n\nstatic int eth_bind_config(struct usb_configuration *c)\n{\n\tint status = 0;\n\n\tif (can_support_ecm(c->cdev->gadget)) {\n\t\tf_ecm = usb_get_function(fi_ecm);\n\t\tif (IS_ERR(f_ecm))\n\t\t\treturn PTR_ERR(f_ecm);\n\n\t\tstatus = usb_add_function(c, f_ecm);\n\t\tif (status < 0)\n\t\t\tusb_put_function(f_ecm);\n\n\t} else {\n\t\tf_geth = usb_get_function(fi_geth);\n\t\tif (IS_ERR(f_geth))\n\t\t\treturn PTR_ERR(f_geth);\n\n\t\tstatus = usb_add_function(c, f_geth);\n\t\tif (status < 0)\n\t\t\tusb_put_function(f_geth);\n\t}\n\treturn status;\n}\n\n#endif\n\n#ifdef CONFIG_USB_FUNCTIONFS_RNDIS\n\nstatic int bind_rndis_config(struct usb_configuration *c)\n{\n\tint status = 0;\n\n\tf_rndis = usb_get_function(fi_rndis);\n\tif (IS_ERR(f_rndis))\n\t\treturn PTR_ERR(f_rndis);\n\n\tstatus = usb_add_function(c, f_rndis);\n\tif (status < 0)\n\t\tusb_put_function(f_rndis);\n\n\treturn status;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}