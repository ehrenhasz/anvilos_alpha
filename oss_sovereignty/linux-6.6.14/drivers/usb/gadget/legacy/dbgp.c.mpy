{
  "module_name": "dbgp.c",
  "hash_id": "cb720bf406441de14e019af59ab1b319ba083a756d1d00a3dee76c45d3f9965a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/dbgp.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n\n#include \"u_serial.h\"\n\n#define DRIVER_VENDOR_ID\t0x0525  \n#define DRIVER_PRODUCT_ID\t0xc0de  \n\n#define USB_DEBUG_MAX_PACKET_SIZE     8\n#define DBGP_REQ_EP0_LEN              128\n#define DBGP_REQ_LEN                  512\n\nstatic struct dbgp {\n\tstruct usb_gadget  *gadget;\n\tstruct usb_request *req;\n\tstruct usb_ep      *i_ep;\n\tstruct usb_ep      *o_ep;\n#ifdef CONFIG_USB_G_DBGP_SERIAL\n\tstruct gserial     *serial;\n#endif\n} dbgp;\n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength = sizeof device_desc,\n\t.bDescriptorType = USB_DT_DEVICE,\n\t.bcdUSB = cpu_to_le16(0x0200),\n\t.bDeviceClass =\tUSB_CLASS_VENDOR_SPEC,\n\t.idVendor = cpu_to_le16(DRIVER_VENDOR_ID),\n\t.idProduct = cpu_to_le16(DRIVER_PRODUCT_ID),\n\t.bNumConfigurations = 1,\n};\n\nstatic struct usb_debug_descriptor dbg_desc = {\n\t.bLength = sizeof dbg_desc,\n\t.bDescriptorType = USB_DT_DEBUG,\n};\n\nstatic struct usb_endpoint_descriptor i_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t.bEndpointAddress = USB_DIR_IN,\n};\n\nstatic struct usb_endpoint_descriptor o_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes = USB_ENDPOINT_XFER_BULK,\n\t.bEndpointAddress = USB_DIR_OUT,\n};\n\n#ifdef CONFIG_USB_G_DBGP_PRINTK\nstatic int dbgp_consume(char *buf, unsigned len)\n{\n\tchar c;\n\n\tif (!len)\n\t\treturn 0;\n\n\tc = buf[len-1];\n\tif (c != 0)\n\t\tbuf[len-1] = 0;\n\n\tprintk(KERN_NOTICE \"%s%c\", buf, c);\n\treturn 0;\n}\n\nstatic void __disable_ep(struct usb_ep *ep)\n{\n\tusb_ep_disable(ep);\n}\n\nstatic void dbgp_disable_ep(void)\n{\n\t__disable_ep(dbgp.i_ep);\n\t__disable_ep(dbgp.o_ep);\n}\n\nstatic void dbgp_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tint stp;\n\tint err = 0;\n\tint status = req->status;\n\n\tif (ep == dbgp.i_ep) {\n\t\tstp = 1;\n\t\tgoto fail;\n\t}\n\n\tif (status != 0) {\n\t\tstp = 2;\n\t\tgoto release_req;\n\t}\n\n\tdbgp_consume(req->buf, req->actual);\n\n\treq->length = DBGP_REQ_LEN;\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tstp = 3;\n\t\tgoto release_req;\n\t}\n\n\treturn;\n\nrelease_req:\n\tkfree(req->buf);\n\tusb_ep_free_request(dbgp.o_ep, req);\n\tdbgp_disable_ep();\nfail:\n\tdev_dbg(&dbgp.gadget->dev,\n\t\t\"complete: failure (%d:%d) ==> %d\\n\", stp, err, status);\n}\n\nstatic int dbgp_enable_ep_req(struct usb_ep *ep)\n{\n\tint err, stp;\n\tstruct usb_request *req;\n\n\treq = usb_ep_alloc_request(ep, GFP_KERNEL);\n\tif (!req) {\n\t\terr = -ENOMEM;\n\t\tstp = 1;\n\t\tgoto fail_1;\n\t}\n\n\treq->buf = kzalloc(DBGP_REQ_LEN, GFP_KERNEL);\n\tif (!req->buf) {\n\t\terr = -ENOMEM;\n\t\tstp = 2;\n\t\tgoto fail_2;\n\t}\n\n\treq->complete = dbgp_complete;\n\treq->length = DBGP_REQ_LEN;\n\terr = usb_ep_queue(ep, req, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tstp = 3;\n\t\tgoto fail_3;\n\t}\n\n\treturn 0;\n\nfail_3:\n\tkfree(req->buf);\nfail_2:\n\tusb_ep_free_request(dbgp.o_ep, req);\nfail_1:\n\tdev_dbg(&dbgp.gadget->dev,\n\t\t\"enable ep req: failure (%d:%d)\\n\", stp, err);\n\treturn err;\n}\n\nstatic int __enable_ep(struct usb_ep *ep, struct usb_endpoint_descriptor *desc)\n{\n\tint err;\n\tep->desc = desc;\n\terr = usb_ep_enable(ep);\n\treturn err;\n}\n\nstatic int dbgp_enable_ep(void)\n{\n\tint err, stp;\n\n\terr = __enable_ep(dbgp.i_ep, &i_desc);\n\tif (err < 0) {\n\t\tstp = 1;\n\t\tgoto fail_1;\n\t}\n\n\terr = __enable_ep(dbgp.o_ep, &o_desc);\n\tif (err < 0) {\n\t\tstp = 2;\n\t\tgoto fail_2;\n\t}\n\n\terr = dbgp_enable_ep_req(dbgp.o_ep);\n\tif (err < 0) {\n\t\tstp = 3;\n\t\tgoto fail_3;\n\t}\n\n\treturn 0;\n\nfail_3:\n\t__disable_ep(dbgp.o_ep);\nfail_2:\n\t__disable_ep(dbgp.i_ep);\nfail_1:\n\tdev_dbg(&dbgp.gadget->dev, \"enable ep: failure (%d:%d)\\n\", stp, err);\n\treturn err;\n}\n#endif\n\nstatic void dbgp_disconnect(struct usb_gadget *gadget)\n{\n#ifdef CONFIG_USB_G_DBGP_PRINTK\n\tdbgp_disable_ep();\n#else\n\tgserial_disconnect(dbgp.serial);\n#endif\n}\n\nstatic void dbgp_unbind(struct usb_gadget *gadget)\n{\n#ifdef CONFIG_USB_G_DBGP_SERIAL\n\tkfree(dbgp.serial);\n\tdbgp.serial = NULL;\n#endif\n\tif (dbgp.req) {\n\t\tkfree(dbgp.req->buf);\n\t\tusb_ep_free_request(gadget->ep0, dbgp.req);\n\t\tdbgp.req = NULL;\n\t}\n}\n\n#ifdef CONFIG_USB_G_DBGP_SERIAL\nstatic unsigned char tty_line;\n#endif\n\nstatic int dbgp_configure_endpoints(struct usb_gadget *gadget)\n{\n\tint stp;\n\n\tusb_ep_autoconfig_reset(gadget);\n\n\tdbgp.i_ep = usb_ep_autoconfig(gadget, &i_desc);\n\tif (!dbgp.i_ep) {\n\t\tstp = 1;\n\t\tgoto fail_1;\n\t}\n\n\ti_desc.wMaxPacketSize =\n\t\tcpu_to_le16(USB_DEBUG_MAX_PACKET_SIZE);\n\n\tdbgp.o_ep = usb_ep_autoconfig(gadget, &o_desc);\n\tif (!dbgp.o_ep) {\n\t\tstp = 2;\n\t\tgoto fail_1;\n\t}\n\n\to_desc.wMaxPacketSize =\n\t\tcpu_to_le16(USB_DEBUG_MAX_PACKET_SIZE);\n\n\tdbg_desc.bDebugInEndpoint = i_desc.bEndpointAddress;\n\tdbg_desc.bDebugOutEndpoint = o_desc.bEndpointAddress;\n\n#ifdef CONFIG_USB_G_DBGP_SERIAL\n\tdbgp.serial->in = dbgp.i_ep;\n\tdbgp.serial->out = dbgp.o_ep;\n\n\tdbgp.serial->in->desc = &i_desc;\n\tdbgp.serial->out->desc = &o_desc;\n#endif\n\n\treturn 0;\n\nfail_1:\n\tdev_dbg(&dbgp.gadget->dev, \"ep config: failure (%d)\\n\", stp);\n\treturn -ENODEV;\n}\n\nstatic int dbgp_bind(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tint err, stp;\n\n\tdbgp.gadget = gadget;\n\n\tdbgp.req = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\n\tif (!dbgp.req) {\n\t\terr = -ENOMEM;\n\t\tstp = 1;\n\t\tgoto fail;\n\t}\n\n\tdbgp.req->buf = kmalloc(DBGP_REQ_EP0_LEN, GFP_KERNEL);\n\tif (!dbgp.req->buf) {\n\t\terr = -ENOMEM;\n\t\tstp = 2;\n\t\tgoto fail;\n\t}\n\n\tdbgp.req->length = DBGP_REQ_EP0_LEN;\n\n#ifdef CONFIG_USB_G_DBGP_SERIAL\n\tdbgp.serial = kzalloc(sizeof(struct gserial), GFP_KERNEL);\n\tif (!dbgp.serial) {\n\t\tstp = 3;\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (gserial_alloc_line(&tty_line)) {\n\t\tstp = 4;\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n#endif\n\n\terr = dbgp_configure_endpoints(gadget);\n\tif (err < 0) {\n\t\tstp = 5;\n\t\tgoto fail;\n\t}\n\n\tdev_dbg(&dbgp.gadget->dev, \"bind: success\\n\");\n\treturn 0;\n\nfail:\n\tdev_dbg(&gadget->dev, \"bind: failure (%d:%d)\\n\", stp, err);\n\tdbgp_unbind(gadget);\n\treturn err;\n}\n\nstatic void dbgp_setup_complete(struct usb_ep *ep,\n\t\t\t\tstruct usb_request *req)\n{\n\tdev_dbg(&dbgp.gadget->dev, \"setup complete: %d, %d/%d\\n\",\n\t\treq->status, req->actual, req->length);\n}\n\nstatic int dbgp_setup(struct usb_gadget *gadget,\n\t\t      const struct usb_ctrlrequest *ctrl)\n{\n\tstruct usb_request *req = dbgp.req;\n\tu8 request = ctrl->bRequest;\n\tu16 value = le16_to_cpu(ctrl->wValue);\n\tu16 length = le16_to_cpu(ctrl->wLength);\n\tint err = -EOPNOTSUPP;\n\tvoid *data = NULL;\n\tu16 len = 0;\n\n\tif (length > DBGP_REQ_LEN) {\n\t\tif (ctrl->bRequestType & USB_DIR_IN) {\n\t\t\t \n\t\t\t__le16 *temp = (__le16 *)&ctrl->wLength;\n\n\t\t\t*temp = cpu_to_le16(DBGP_REQ_LEN);\n\t\t\tlength = DBGP_REQ_LEN;\n\t\t} else {\n\t\t\treturn err;\n\t\t}\n\t}\n\n\n\tif (request == USB_REQ_GET_DESCRIPTOR) {\n\t\tswitch (value>>8) {\n\t\tcase USB_DT_DEVICE:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc device\\n\");\n\t\t\tlen = sizeof device_desc;\n\t\t\tdata = &device_desc;\n\t\t\tdevice_desc.bMaxPacketSize0 = gadget->ep0->maxpacket;\n\t\t\tbreak;\n\t\tcase USB_DT_DEBUG:\n\t\t\tdev_dbg(&dbgp.gadget->dev, \"setup: desc debug\\n\");\n\t\t\tlen = sizeof dbg_desc;\n\t\t\tdata = &dbg_desc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t\terr = 0;\n\t} else if (request == USB_REQ_SET_FEATURE &&\n\t\t   value == USB_DEVICE_DEBUG_MODE) {\n\t\tdev_dbg(&dbgp.gadget->dev, \"setup: feat debug\\n\");\n#ifdef CONFIG_USB_G_DBGP_PRINTK\n\t\terr = dbgp_enable_ep();\n#else\n\t\terr = dbgp_configure_endpoints(gadget);\n\t\tif (err < 0) {\n\t\t\tgoto fail;\n\t\t}\n\t\terr = gserial_connect(dbgp.serial, tty_line);\n#endif\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t} else\n\t\tgoto fail;\n\n\treq->length = min(length, len);\n\treq->zero = len < req->length;\n\tif (data && req->length)\n\t\tmemcpy(req->buf, data, req->length);\n\n\treq->complete = dbgp_setup_complete;\n\treturn usb_ep_queue(gadget->ep0, req, GFP_ATOMIC);\n\nfail:\n\tdev_dbg(&dbgp.gadget->dev,\n\t\t\"setup: failure req %x v %x\\n\", request, value);\n\treturn err;\n}\n\nstatic struct usb_gadget_driver dbgp_driver = {\n\t.function = \"dbgp\",\n\t.max_speed = USB_SPEED_HIGH,\n\t.bind = dbgp_bind,\n\t.unbind = dbgp_unbind,\n\t.setup = dbgp_setup,\n\t.reset = dbgp_disconnect,\n\t.disconnect = dbgp_disconnect,\n\t.driver\t= {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"dbgp\"\n\t},\n};\n\nstatic int __init dbgp_init(void)\n{\n\treturn usb_gadget_register_driver(&dbgp_driver);\n}\n\nstatic void __exit dbgp_exit(void)\n{\n\tusb_gadget_unregister_driver(&dbgp_driver);\n#ifdef CONFIG_USB_G_DBGP_SERIAL\n\tgserial_free_line(tty_line);\n#endif\n}\n\nMODULE_AUTHOR(\"Stephane Duverger\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(dbgp_init);\nmodule_exit(dbgp_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}