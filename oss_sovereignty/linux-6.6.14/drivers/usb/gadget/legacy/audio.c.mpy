{
  "module_name": "audio.c",
  "hash_id": "e88865b5f4e7fea4cae228c79880bb8c9ce5282a4742156f46625e65f172f80b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/audio.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb/composite.h>\n\n#define DRIVER_DESC\t\t\"Linux USB Audio Gadget\"\n#define DRIVER_VERSION\t\t\"Feb 2, 2012\"\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\n#ifndef CONFIG_GADGET_UAC1\n#include \"u_uac2.h\"\n\n \nstatic int p_chmask = UAC2_DEF_PCHMASK;\nmodule_param(p_chmask, uint, 0444);\nMODULE_PARM_DESC(p_chmask, \"Playback Channel Mask\");\n\n \nstatic int p_srates[UAC_MAX_RATES] = {UAC2_DEF_PSRATE};\nstatic int p_srates_cnt = 1;\nmodule_param_array_named(p_srate, p_srates, uint, &p_srates_cnt, 0444);\nMODULE_PARM_DESC(p_srate, \"Playback Sampling Rates (array)\");\n\n \nstatic int p_ssize = UAC2_DEF_PSSIZE;\nmodule_param(p_ssize, uint, 0444);\nMODULE_PARM_DESC(p_ssize, \"Playback Sample Size(bytes)\");\n\n \nstatic u8 p_hs_bint = UAC2_DEF_PHSBINT;\nmodule_param(p_hs_bint, byte, 0444);\nMODULE_PARM_DESC(p_hs_bint,\n\t\t\"Playback bInterval for HS/SS (1-4: fixed, 0: auto)\");\n\n \nstatic int c_chmask = UAC2_DEF_CCHMASK;\nmodule_param(c_chmask, uint, 0444);\nMODULE_PARM_DESC(c_chmask, \"Capture Channel Mask\");\n\n \nstatic int c_srates[UAC_MAX_RATES] = {UAC2_DEF_CSRATE};\nstatic int c_srates_cnt = 1;\nmodule_param_array_named(c_srate, c_srates, uint, &c_srates_cnt, 0444);\nMODULE_PARM_DESC(c_srate, \"Capture Sampling Rates (array)\");\n\n \nstatic int c_ssize = UAC2_DEF_CSSIZE;\nmodule_param(c_ssize, uint, 0444);\nMODULE_PARM_DESC(c_ssize, \"Capture Sample Size(bytes)\");\n\n \nstatic u8 c_hs_bint = UAC2_DEF_CHSBINT;\nmodule_param(c_hs_bint, byte, 0444);\nMODULE_PARM_DESC(c_hs_bint,\n\t\t\"Capture bInterval for HS/SS (1-4: fixed, 0: auto)\");\n\n#else\n#ifndef CONFIG_GADGET_UAC1_LEGACY\n#include \"u_uac1.h\"\n\n \nstatic int p_chmask = UAC1_DEF_PCHMASK;\nmodule_param(p_chmask, uint, 0444);\nMODULE_PARM_DESC(p_chmask, \"Playback Channel Mask\");\n\n \nstatic int p_srates[UAC_MAX_RATES] = {UAC1_DEF_PSRATE};\nstatic int p_srates_cnt = 1;\nmodule_param_array_named(p_srate, p_srates, uint, &p_srates_cnt, 0444);\nMODULE_PARM_DESC(p_srate, \"Playback Sampling Rates (array)\");\n\n \nstatic int p_ssize = UAC1_DEF_PSSIZE;\nmodule_param(p_ssize, uint, 0444);\nMODULE_PARM_DESC(p_ssize, \"Playback Sample Size(bytes)\");\n\n \nstatic int c_chmask = UAC1_DEF_CCHMASK;\nmodule_param(c_chmask, uint, 0444);\nMODULE_PARM_DESC(c_chmask, \"Capture Channel Mask\");\n\n \nstatic int c_srates[UAC_MAX_RATES] = {UAC1_DEF_CSRATE};\nstatic int c_srates_cnt = 1;\nmodule_param_array_named(c_srate, c_srates, uint, &c_srates_cnt, 0444);\nMODULE_PARM_DESC(c_srate, \"Capture Sampling Rates (array)\");\n\n \nstatic int c_ssize = UAC1_DEF_CSSIZE;\nmodule_param(c_ssize, uint, 0444);\nMODULE_PARM_DESC(c_ssize, \"Capture Sample Size(bytes)\");\n#else  \n#include \"u_uac1_legacy.h\"\n\nstatic char *fn_play = FILE_PCM_PLAYBACK;\nmodule_param(fn_play, charp, 0444);\nMODULE_PARM_DESC(fn_play, \"Playback PCM device file name\");\n\nstatic char *fn_cap = FILE_PCM_CAPTURE;\nmodule_param(fn_cap, charp, 0444);\nMODULE_PARM_DESC(fn_cap, \"Capture PCM device file name\");\n\nstatic char *fn_cntl = FILE_CONTROL;\nmodule_param(fn_cntl, charp, 0444);\nMODULE_PARM_DESC(fn_cntl, \"Control device file name\");\n\nstatic int req_buf_size = UAC1_OUT_EP_MAX_PACKET_SIZE;\nmodule_param(req_buf_size, int, 0444);\nMODULE_PARM_DESC(req_buf_size, \"ISO OUT endpoint request buffer size\");\n\nstatic int req_count = UAC1_REQ_COUNT;\nmodule_param(req_count, int, 0444);\nMODULE_PARM_DESC(req_count, \"ISO OUT endpoint request count\");\n\nstatic int audio_buf_size = UAC1_AUDIO_BUF_SIZE;\nmodule_param(audio_buf_size, int, 0444);\nMODULE_PARM_DESC(audio_buf_size, \"Audio buffer size\");\n#endif  \n#endif\n\n \n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language = 0x0409,\t \n\t.strings = strings_dev,\n};\n\nstatic struct usb_gadget_strings *audio_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\n#ifndef CONFIG_GADGET_UAC1\nstatic struct usb_function_instance *fi_uac2;\nstatic struct usb_function *f_uac2;\n#else\nstatic struct usb_function_instance *fi_uac1;\nstatic struct usb_function *f_uac1;\n#endif\n\n \n\n \n\n \n#define AUDIO_VENDOR_NUM\t\t0x1d6b\t \n#define AUDIO_PRODUCT_NUM\t\t0x0101\t \n\n \n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\n\t \n\n#ifdef CONFIG_GADGET_UAC1_LEGACY\n\t.bDeviceClass =\t\tUSB_CLASS_PER_INTERFACE,\n\t.bDeviceSubClass =\t0,\n\t.bDeviceProtocol =\t0,\n#else\n\t.bDeviceClass =\t\tUSB_CLASS_MISC,\n\t.bDeviceSubClass =\t0x02,\n\t.bDeviceProtocol =\t0x01,\n#endif\n\t \n\n\t \n\t.idVendor =\t\tcpu_to_le16(AUDIO_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(AUDIO_PRODUCT_NUM),\n\t \n\t \n\t \n\t \n\t.bNumConfigurations =\t1,\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\n \n\nstatic int audio_do_config(struct usb_configuration *c)\n{\n\tint status;\n\n\t \n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n#ifdef CONFIG_GADGET_UAC1\n\tf_uac1 = usb_get_function(fi_uac1);\n\tif (IS_ERR(f_uac1)) {\n\t\tstatus = PTR_ERR(f_uac1);\n\t\treturn status;\n\t}\n\n\tstatus = usb_add_function(c, f_uac1);\n\tif (status < 0) {\n\t\tusb_put_function(f_uac1);\n\t\treturn status;\n\t}\n#else\n\tf_uac2 = usb_get_function(fi_uac2);\n\tif (IS_ERR(f_uac2)) {\n\t\tstatus = PTR_ERR(f_uac2);\n\t\treturn status;\n\t}\n\n\tstatus = usb_add_function(c, f_uac2);\n\tif (status < 0) {\n\t\tusb_put_function(f_uac2);\n\t\treturn status;\n\t}\n#endif\n\n\treturn 0;\n}\n\nstatic struct usb_configuration audio_config_driver = {\n\t.label\t\t\t= DRIVER_DESC,\n\t.bConfigurationValue\t= 1,\n\t \n\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n};\n\n \n\nstatic int audio_bind(struct usb_composite_dev *cdev)\n{\n#ifndef CONFIG_GADGET_UAC1\n\tstruct f_uac2_opts\t*uac2_opts;\n\tint i;\n#else\n#ifndef CONFIG_GADGET_UAC1_LEGACY\n\tstruct f_uac1_opts\t*uac1_opts;\n\tint i;\n#else\n\tstruct f_uac1_legacy_opts\t*uac1_opts;\n#endif\n#endif\n\tint\t\t\tstatus;\n\n#ifndef CONFIG_GADGET_UAC1\n\tfi_uac2 = usb_get_function_instance(\"uac2\");\n\tif (IS_ERR(fi_uac2))\n\t\treturn PTR_ERR(fi_uac2);\n#else\n#ifndef CONFIG_GADGET_UAC1_LEGACY\n\tfi_uac1 = usb_get_function_instance(\"uac1\");\n#else\n\tfi_uac1 = usb_get_function_instance(\"uac1_legacy\");\n#endif\n\tif (IS_ERR(fi_uac1))\n\t\treturn PTR_ERR(fi_uac1);\n#endif\n\n#ifndef CONFIG_GADGET_UAC1\n\tuac2_opts = container_of(fi_uac2, struct f_uac2_opts, func_inst);\n\tuac2_opts->p_chmask = p_chmask;\n\n\tfor (i = 0; i < p_srates_cnt; ++i)\n\t\tuac2_opts->p_srates[i] = p_srates[i];\n\n\tuac2_opts->p_ssize = p_ssize;\n\tuac2_opts->p_hs_bint = p_hs_bint;\n\tuac2_opts->c_chmask = c_chmask;\n\n\tfor (i = 0; i < c_srates_cnt; ++i)\n\t\tuac2_opts->c_srates[i] = c_srates[i];\n\n\tuac2_opts->c_ssize = c_ssize;\n\tuac2_opts->c_hs_bint = c_hs_bint;\n\tuac2_opts->req_number = UAC2_DEF_REQ_NUM;\n#else\n#ifndef CONFIG_GADGET_UAC1_LEGACY\n\tuac1_opts = container_of(fi_uac1, struct f_uac1_opts, func_inst);\n\tuac1_opts->p_chmask = p_chmask;\n\n\tfor (i = 0; i < p_srates_cnt; ++i)\n\t\tuac1_opts->p_srates[i] = p_srates[i];\n\n\tuac1_opts->p_ssize = p_ssize;\n\tuac1_opts->c_chmask = c_chmask;\n\n\tfor (i = 0; i < c_srates_cnt; ++i)\n\t\tuac1_opts->c_srates[i] = c_srates[i];\n\n\tuac1_opts->c_ssize = c_ssize;\n\tuac1_opts->req_number = UAC1_DEF_REQ_NUM;\n#else  \n\tuac1_opts = container_of(fi_uac1, struct f_uac1_legacy_opts, func_inst);\n\tuac1_opts->fn_play = fn_play;\n\tuac1_opts->fn_cap = fn_cap;\n\tuac1_opts->fn_cntl = fn_cntl;\n\tuac1_opts->req_buf_size = req_buf_size;\n\tuac1_opts->req_count = req_count;\n\tuac1_opts->audio_buf_size = audio_buf_size;\n#endif  \n#endif\n\n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\tgoto fail;\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\n\tif (gadget_is_otg(cdev->gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\n\t\tif (!usb_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tusb_otg_descriptor_init(cdev->gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\tstatus = usb_add_config(cdev, &audio_config_driver, audio_do_config);\n\tif (status < 0)\n\t\tgoto fail_otg_desc;\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\n\tINFO(cdev, \"%s, version: %s\\n\", DRIVER_DESC, DRIVER_VERSION);\n\treturn 0;\n\nfail_otg_desc:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nfail:\n#ifndef CONFIG_GADGET_UAC1\n\tusb_put_function_instance(fi_uac2);\n#else\n\tusb_put_function_instance(fi_uac1);\n#endif\n\treturn status;\n}\n\nstatic int audio_unbind(struct usb_composite_dev *cdev)\n{\n#ifdef CONFIG_GADGET_UAC1\n\tif (!IS_ERR_OR_NULL(f_uac1))\n\t\tusb_put_function(f_uac1);\n\tif (!IS_ERR_OR_NULL(fi_uac1))\n\t\tusb_put_function_instance(fi_uac1);\n#else\n\tif (!IS_ERR_OR_NULL(f_uac2))\n\t\tusb_put_function(f_uac2);\n\tif (!IS_ERR_OR_NULL(fi_uac2))\n\t\tusb_put_function_instance(fi_uac2);\n#endif\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic struct usb_composite_driver audio_driver = {\n\t.name\t\t= \"g_audio\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= audio_strings,\n\t.max_speed\t= USB_SPEED_HIGH,\n\t.bind\t\t= audio_bind,\n\t.unbind\t\t= audio_unbind,\n};\n\nmodule_usb_composite_driver(audio_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Bryan Wu <cooloney@kernel.org>\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}