{
  "module_name": "printer.c",
  "hash_id": "55832e51350d516f89024bf885eff6d55f4390441e5ef2d01979d78a2679571c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/printer.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <asm/byteorder.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/g_printer.h>\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\n#define DRIVER_DESC\t\t\"Printer Gadget\"\n#define DRIVER_VERSION\t\t\"2015 FEB 17\"\n\nstatic const char shortname [] = \"printer\";\n\n#include \"u_printer.h\"\n\n \n\n \n\n \n#define PRINTER_VENDOR_NUM\t0x0525\t\t \n#define PRINTER_PRODUCT_NUM\t0xa4a8\t\t \n\n \n\nmodule_param_named(iSerialNum, coverwrite.serial_number, charp, S_IRUGO);\nMODULE_PARM_DESC(iSerialNum, \"1\");\n\nstatic char *iPNPstring;\nmodule_param(iPNPstring, charp, S_IRUGO);\nMODULE_PARM_DESC(iPNPstring, \"MFG:linux;MDL:g_printer;CLS:PRINTER;SN:1;\");\n\n \nstatic unsigned qlen = 10;\nmodule_param(qlen, uint, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(qlen, \"The number of 8k buffers to use per endpoint\");\n\n#define QLEN\tqlen\n\nstatic struct usb_function_instance *fi_printer;\nstatic struct usb_function *f_printer;\n\n \n\n \n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\t \n\t.bDeviceClass =\t\tUSB_CLASS_PER_INTERFACE,\n\t.bDeviceSubClass =\t0,\n\t.bDeviceProtocol =\t0,\n\t.idVendor =\t\tcpu_to_le16(PRINTER_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(PRINTER_PRODUCT_NUM),\n\t.bNumConfigurations =\t1\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\n \n\n \n\nstatic char\t\t\t\tproduct_desc [40] = DRIVER_DESC;\nstatic char\t\t\t\tserial_num [40] = \"1\";\nstatic char\t\t\t\t*pnp_string =\n\t\"MFG:linux;MDL:g_printer;CLS:PRINTER;SN:1;\";\n\n \nstatic struct usb_string\t\tstrings [] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = product_desc,\n\t[USB_GADGET_SERIAL_IDX].s =\tserial_num,\n\t{  }\t\t \n};\n\nstatic struct usb_gadget_strings\tstringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\nstatic struct usb_configuration printer_cfg_driver = {\n\t.label\t\t\t= \"printer\",\n\t.bConfigurationValue\t= 1,\n\t.bmAttributes\t\t= USB_CONFIG_ATT_ONE | USB_CONFIG_ATT_SELFPOWER,\n};\n\nstatic int printer_do_config(struct usb_configuration *c)\n{\n\tstruct usb_gadget\t*gadget = c->cdev->gadget;\n\tint\t\t\tstatus = 0;\n\n\tusb_ep_autoconfig_reset(gadget);\n\n\tusb_gadget_set_selfpowered(gadget);\n\n\tif (gadget_is_otg(gadget)) {\n\t\tprinter_cfg_driver.descriptors = otg_desc;\n\t\tprinter_cfg_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tf_printer = usb_get_function(fi_printer);\n\tif (IS_ERR(f_printer))\n\t\treturn PTR_ERR(f_printer);\n\n\tstatus = usb_add_function(c, f_printer);\n\tif (status < 0)\n\t\tusb_put_function(f_printer);\n\n\treturn status;\n}\n\nstatic int printer_bind(struct usb_composite_dev *cdev)\n{\n\tstruct f_printer_opts *opts;\n\tint ret;\n\n\tfi_printer = usb_get_function_instance(\"printer\");\n\tif (IS_ERR(fi_printer))\n\t\treturn PTR_ERR(fi_printer);\n\n\topts = container_of(fi_printer, struct f_printer_opts, func_inst);\n\topts->minor = 0;\n\topts->q_len = QLEN;\n\tif (iPNPstring) {\n\t\topts->pnp_string = kstrdup(iPNPstring, GFP_KERNEL);\n\t\tif (!opts->pnp_string) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_put_func_inst;\n\t\t}\n\t\topts->pnp_string_allocated = true;\n\t\t \n\t} else {\n\t\topts->pnp_string = pnp_string;\n\t}\n\n\tret = usb_string_ids_tab(cdev, strings);\n\tif (ret < 0)\n\t\tgoto fail_put_func_inst;\n\n\tdevice_desc.iManufacturer = strings[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings[USB_GADGET_PRODUCT_IDX].id;\n\tdevice_desc.iSerialNumber = strings[USB_GADGET_SERIAL_IDX].id;\n\n\tif (gadget_is_otg(cdev->gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\n\t\tif (!usb_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_put_func_inst;\n\t\t}\n\t\tusb_otg_descriptor_init(cdev->gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\tret = usb_add_config(cdev, &printer_cfg_driver, printer_do_config);\n\tif (ret)\n\t\tgoto fail_free_otg_desc;\n\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\treturn ret;\n\nfail_free_otg_desc:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nfail_put_func_inst:\n\tusb_put_function_instance(fi_printer);\n\treturn ret;\n}\n\nstatic int printer_unbind(struct usb_composite_dev *cdev)\n{\n\tusb_put_function(f_printer);\n\tusb_put_function_instance(fi_printer);\n\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic struct usb_composite_driver printer_driver = {\n\t.name           = shortname,\n\t.dev            = &device_desc,\n\t.strings        = dev_strings,\n\t.max_speed      = USB_SPEED_SUPER,\n\t.bind\t\t= printer_bind,\n\t.unbind\t\t= printer_unbind,\n};\n\nmodule_usb_composite_driver(printer_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Craig Nadler\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}