{
  "module_name": "serial.c",
  "hash_id": "e976a3ed3529456856e094e56792c4fcc1bd7ba0da270afee1bed388fdb26be4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/serial.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/kstrtox.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n\n#include \"u_serial.h\"\n\n\n \n\n#define GS_VERSION_STR\t\t\t\"v2.4\"\n#define GS_VERSION_NUM\t\t\t0x2400\n\n#define GS_LONG_NAME\t\t\t\"Gadget Serial\"\n#define GS_VERSION_NAME\t\t\tGS_LONG_NAME \" \" GS_VERSION_STR\n\n \nUSB_GADGET_COMPOSITE_OPTIONS();\n\n \n#define GS_VENDOR_ID\t\t\t0x0525\t \n#define GS_PRODUCT_ID\t\t\t0xa4a6\t \n#define GS_CDC_PRODUCT_ID\t\t0xa4a7\t \n#define GS_CDC_OBEX_PRODUCT_ID\t\t0xa4a9\t \n\n \n\n#define STRING_DESCRIPTION_IDX\t\tUSB_GADGET_FIRST_AVAIL_IDX\n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = GS_VERSION_NAME,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n\t[STRING_DESCRIPTION_IDX].s = NULL  ,\n\t{  }  \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_dev,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tUSB_DT_DEVICE_SIZE,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\t \n\t \n\t.bDeviceSubClass =\t0,\n\t.bDeviceProtocol =\t0,\n\t \n\t.idVendor =\t\tcpu_to_le16(GS_VENDOR_ID),\n\t \n\t.bcdDevice = cpu_to_le16(GS_VERSION_NUM),\n\t \n\t \n\t.bNumConfigurations =\t1,\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\n \n\n \nMODULE_DESCRIPTION(GS_VERSION_NAME);\nMODULE_AUTHOR(\"Al Borchers\");\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_LICENSE(\"GPL\");\n\nstatic bool use_acm = true;\nmodule_param(use_acm, bool, 0);\nMODULE_PARM_DESC(use_acm, \"Use CDC ACM, default=yes\");\n\nstatic bool use_obex = false;\nmodule_param(use_obex, bool, 0);\nMODULE_PARM_DESC(use_obex, \"Use CDC OBEX, default=no\");\n\nstatic unsigned n_ports = 1;\nmodule_param(n_ports, uint, 0);\nMODULE_PARM_DESC(n_ports, \"number of ports to create, default=1\");\n\nstatic bool enable = true;\n\nstatic int switch_gserial_enable(bool do_enable);\n\nstatic int enable_set(const char *s, const struct kernel_param *kp)\n{\n\tbool do_enable;\n\tint ret;\n\n\tif (!s)\t \n\t\treturn 0;\n\n\tret = kstrtobool(s, &do_enable);\n\tif (ret || enable == do_enable)\n\t\treturn ret;\n\n\tret = switch_gserial_enable(do_enable);\n\tif (!ret)\n\t\tenable = do_enable;\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops enable_ops = {\n\t.set = enable_set,\n\t.get = param_get_bool,\n};\n\nmodule_param_cb(enable, &enable_ops, &enable, 0644);\n\n \n\nstatic struct usb_configuration serial_config_driver = {\n\t \n\t \n\t \n\t.bmAttributes\t= USB_CONFIG_ATT_SELFPOWER,\n};\n\nstatic struct usb_function_instance *fi_serial[MAX_U_SERIAL_PORTS];\nstatic struct usb_function *f_serial[MAX_U_SERIAL_PORTS];\n\nstatic int serial_register_ports(struct usb_composite_dev *cdev,\n\t\tstruct usb_configuration *c, const char *f_name)\n{\n\tint i;\n\tint ret;\n\n\tret = usb_add_config_only(cdev, c);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < n_ports; i++) {\n\n\t\tfi_serial[i] = usb_get_function_instance(f_name);\n\t\tif (IS_ERR(fi_serial[i])) {\n\t\t\tret = PTR_ERR(fi_serial[i]);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tf_serial[i] = usb_get_function(fi_serial[i]);\n\t\tif (IS_ERR(f_serial[i])) {\n\t\t\tret = PTR_ERR(f_serial[i]);\n\t\t\tgoto err_get_func;\n\t\t}\n\n\t\tret = usb_add_function(c, f_serial[i]);\n\t\tif (ret)\n\t\t\tgoto err_add_func;\n\t}\n\n\treturn 0;\n\nerr_add_func:\n\tusb_put_function(f_serial[i]);\nerr_get_func:\n\tusb_put_function_instance(fi_serial[i]);\n\nfail:\n\ti--;\n\twhile (i >= 0) {\n\t\tusb_remove_function(c, f_serial[i]);\n\t\tusb_put_function(f_serial[i]);\n\t\tusb_put_function_instance(fi_serial[i]);\n\t\ti--;\n\t}\nout:\n\treturn ret;\n}\n\nstatic int gs_bind(struct usb_composite_dev *cdev)\n{\n\tint\t\t\tstatus;\n\n\t \n\n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\tgoto fail;\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\tstatus = strings_dev[STRING_DESCRIPTION_IDX].id;\n\tserial_config_driver.iConfiguration = status;\n\n\tif (gadget_is_otg(cdev->gadget)) {\n\t\tif (!otg_desc[0]) {\n\t\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\t\tusb_desc = usb_otg_descriptor_alloc(cdev->gadget);\n\t\t\tif (!usb_desc) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tusb_otg_descriptor_init(cdev->gadget, usb_desc);\n\t\t\totg_desc[0] = usb_desc;\n\t\t\totg_desc[1] = NULL;\n\t\t}\n\t\tserial_config_driver.descriptors = otg_desc;\n\t\tserial_config_driver.bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\t \n\tif (use_acm) {\n\t\tstatus  = serial_register_ports(cdev, &serial_config_driver,\n\t\t\t\t\"acm\");\n\t\tusb_ep_autoconfig_reset(cdev->gadget);\n\t} else if (use_obex)\n\t\tstatus = serial_register_ports(cdev, &serial_config_driver,\n\t\t\t\t\"obex\");\n\telse {\n\t\tstatus = serial_register_ports(cdev, &serial_config_driver,\n\t\t\t\t\"gser\");\n\t}\n\tif (status < 0)\n\t\tgoto fail1;\n\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\tINFO(cdev, \"%s\\n\", GS_VERSION_NAME);\n\n\treturn 0;\nfail1:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nfail:\n\treturn status;\n}\n\nstatic int gs_unbind(struct usb_composite_dev *cdev)\n{\n\tint i;\n\n\tfor (i = 0; i < n_ports; i++) {\n\t\tusb_put_function(f_serial[i]);\n\t\tusb_put_function_instance(fi_serial[i]);\n\t}\n\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic struct usb_composite_driver gserial_driver = {\n\t.name\t\t= \"g_serial\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_SUPER,\n\t.bind\t\t= gs_bind,\n\t.unbind\t\t= gs_unbind,\n};\n\nstatic int switch_gserial_enable(bool do_enable)\n{\n\tif (!serial_config_driver.label)\n\t\t \n\t\treturn 0;\n\n\tif (do_enable)\n\t\treturn usb_composite_probe(&gserial_driver);\n\n\tusb_composite_unregister(&gserial_driver);\n\treturn 0;\n}\n\nstatic int __init gserial_init(void)\n{\n\t \n\tif (use_acm) {\n\t\tserial_config_driver.label = \"CDC ACM config\";\n\t\tserial_config_driver.bConfigurationValue = 2;\n\t\tdevice_desc.bDeviceClass = USB_CLASS_COMM;\n\t\tdevice_desc.idProduct =\n\t\t\t\tcpu_to_le16(GS_CDC_PRODUCT_ID);\n\t} else if (use_obex) {\n\t\tserial_config_driver.label = \"CDC OBEX config\";\n\t\tserial_config_driver.bConfigurationValue = 3;\n\t\tdevice_desc.bDeviceClass = USB_CLASS_COMM;\n\t\tdevice_desc.idProduct =\n\t\t\tcpu_to_le16(GS_CDC_OBEX_PRODUCT_ID);\n\t} else {\n\t\tserial_config_driver.label = \"Generic Serial config\";\n\t\tserial_config_driver.bConfigurationValue = 1;\n\t\tdevice_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;\n\t\tdevice_desc.idProduct =\n\t\t\t\tcpu_to_le16(GS_PRODUCT_ID);\n\t}\n\tstrings_dev[STRING_DESCRIPTION_IDX].s = serial_config_driver.label;\n\n\tif (!enable)\n\t\treturn 0;\n\n\treturn usb_composite_probe(&gserial_driver);\n}\nmodule_init(gserial_init);\n\nstatic void __exit gserial_cleanup(void)\n{\n\tif (enable)\n\t\tusb_composite_unregister(&gserial_driver);\n}\nmodule_exit(gserial_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}