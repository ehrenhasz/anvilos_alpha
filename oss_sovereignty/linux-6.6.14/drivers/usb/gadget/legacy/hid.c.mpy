{
  "module_name": "hid.c",
  "hash_id": "9e3584613baef78c27c6581de55329a7e3c92733868b35393efe6892edf28ea0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/hid.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/g_hid.h>\n\n#define DRIVER_DESC\t\t\"HID Gadget\"\n#define DRIVER_VERSION\t\t\"2010/03/16\"\n\n#include \"u_hid.h\"\n\n \n\n#define HIDG_VENDOR_NUM\t\t0x0525\t \n#define HIDG_PRODUCT_NUM\t0xa4ac\t \n\n \n\nstruct hidg_func_node {\n\tstruct usb_function_instance *fi;\n\tstruct usb_function *f;\n\tstruct list_head node;\n\tstruct hidg_func_descriptor *func;\n};\n\nstatic LIST_HEAD(hidg_func_list);\n\n \nUSB_GADGET_COMPOSITE_OPTIONS();\n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\n\t \n\n\t \n\t \n\t \n\t.bDeviceClass =\t\tUSB_CLASS_PER_INTERFACE,\n\t.bDeviceSubClass =\t0,\n\t.bDeviceProtocol =\t0,\n\t \n\n\t \n\t.idVendor =\t\tcpu_to_le16(HIDG_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(HIDG_PRODUCT_NUM),\n\t \n\t \n\t \n\t \n\t.bNumConfigurations =\t1,\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\n \nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_dev,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\n\n\n \n\nstatic int do_config(struct usb_configuration *c)\n{\n\tstruct hidg_func_node *e, *n;\n\tint status = 0;\n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tlist_for_each_entry(e, &hidg_func_list, node) {\n\t\te->f = usb_get_function(e->fi);\n\t\tif (IS_ERR(e->f)) {\n\t\t\tstatus = PTR_ERR(e->f);\n\t\t\tgoto put;\n\t\t}\n\t\tstatus = usb_add_function(c, e->f);\n\t\tif (status < 0) {\n\t\t\tusb_put_function(e->f);\n\t\t\tgoto put;\n\t\t}\n\t}\n\n\treturn 0;\nput:\n\tlist_for_each_entry(n, &hidg_func_list, node) {\n\t\tif (n == e)\n\t\t\tbreak;\n\t\tusb_remove_function(c, n->f);\n\t\tusb_put_function(n->f);\n\t}\n\treturn status;\n}\n\nstatic struct usb_configuration config_driver = {\n\t.label\t\t\t= \"HID Gadget\",\n\t.bConfigurationValue\t= 1,\n\t \n\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n};\n\n \n\nstatic int hid_bind(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget *gadget = cdev->gadget;\n\tstruct hidg_func_node *n = NULL, *m, *iter_n;\n\tstruct f_hid_opts *hid_opts;\n\tint status, funcs;\n\n\tfuncs = list_count_nodes(&hidg_func_list);\n\tif (!funcs)\n\t\treturn -ENODEV;\n\n\tlist_for_each_entry(iter_n, &hidg_func_list, node) {\n\t\titer_n->fi = usb_get_function_instance(\"hid\");\n\t\tif (IS_ERR(iter_n->fi)) {\n\t\t\tstatus = PTR_ERR(iter_n->fi);\n\t\t\tn = iter_n;\n\t\t\tgoto put;\n\t\t}\n\t\thid_opts = container_of(iter_n->fi, struct f_hid_opts, func_inst);\n\t\thid_opts->subclass = iter_n->func->subclass;\n\t\thid_opts->protocol = iter_n->func->protocol;\n\t\thid_opts->report_length = iter_n->func->report_length;\n\t\thid_opts->report_desc_length = iter_n->func->report_desc_length;\n\t\thid_opts->report_desc = iter_n->func->report_desc;\n\t}\n\n\n\t \n\n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\tgoto put;\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\n\tif (gadget_is_otg(gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(gadget);\n\t\tif (!usb_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto put;\n\t\t}\n\t\tusb_otg_descriptor_init(gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\t \n\tstatus = usb_add_config(cdev, &config_driver, do_config);\n\tif (status < 0)\n\t\tgoto free_otg_desc;\n\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\tdev_info(&gadget->dev, DRIVER_DESC \", version: \" DRIVER_VERSION \"\\n\");\n\n\treturn 0;\n\nfree_otg_desc:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nput:\n\tlist_for_each_entry(m, &hidg_func_list, node) {\n\t\tif (m == n)\n\t\t\tbreak;\n\t\tusb_put_function_instance(m->fi);\n\t}\n\treturn status;\n}\n\nstatic int hid_unbind(struct usb_composite_dev *cdev)\n{\n\tstruct hidg_func_node *n;\n\n\tlist_for_each_entry(n, &hidg_func_list, node) {\n\t\tusb_put_function(n->f);\n\t\tusb_put_function_instance(n->fi);\n\t}\n\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic int hidg_plat_driver_probe(struct platform_device *pdev)\n{\n\tstruct hidg_func_descriptor *func = dev_get_platdata(&pdev->dev);\n\tstruct hidg_func_node *entry;\n\n\tif (!func) {\n\t\tdev_err(&pdev->dev, \"Platform data missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tentry->func = func;\n\tlist_add_tail(&entry->node, &hidg_func_list);\n\n\treturn 0;\n}\n\nstatic void hidg_plat_driver_remove(struct platform_device *pdev)\n{\n\tstruct hidg_func_node *e, *n;\n\n\tlist_for_each_entry_safe(e, n, &hidg_func_list, node) {\n\t\tlist_del(&e->node);\n\t\tkfree(e);\n\t}\n}\n\n\n \n\n\nstatic struct usb_composite_driver hidg_driver = {\n\t.name\t\t= \"g_hid\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_HIGH,\n\t.bind\t\t= hid_bind,\n\t.unbind\t\t= hid_unbind,\n};\n\nstatic struct platform_driver hidg_plat_driver = {\n\t.remove_new\t= hidg_plat_driver_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"hidg\",\n\t},\n};\n\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Fabien Chouteau, Peter Korsgaard\");\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init hidg_init(void)\n{\n\tint status;\n\n\tstatus = platform_driver_probe(&hidg_plat_driver,\n\t\t\t\thidg_plat_driver_probe);\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = usb_composite_probe(&hidg_driver);\n\tif (status < 0)\n\t\tplatform_driver_unregister(&hidg_plat_driver);\n\n\treturn status;\n}\nmodule_init(hidg_init);\n\nstatic void __exit hidg_cleanup(void)\n{\n\tusb_composite_unregister(&hidg_driver);\n\tplatform_driver_unregister(&hidg_plat_driver);\n}\nmodule_exit(hidg_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}