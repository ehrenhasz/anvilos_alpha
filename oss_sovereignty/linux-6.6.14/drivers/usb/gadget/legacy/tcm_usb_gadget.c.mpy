{
  "module_name": "tcm_usb_gadget.c",
  "hash_id": "4a650955929c65404d94c84986cbe241ba78b353612abc5bccce2a3be39f4fa6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/tcm_usb_gadget.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/storage.h>\n#include <scsi/scsi_tcq.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <asm/unaligned.h>\n\n#include \"u_tcm.h\"\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\n#define UAS_VENDOR_ID\t0x0525\t \n#define UAS_PRODUCT_ID\t0xa4a5\t \n\nstatic struct usb_device_descriptor usbg_device_desc = {\n\t.bLength =\t\tsizeof(usbg_device_desc),\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\t \n\t.bDeviceClass =\t\tUSB_CLASS_PER_INTERFACE,\n\t.idVendor =\t\tcpu_to_le16(UAS_VENDOR_ID),\n\t.idProduct =\t\tcpu_to_le16(UAS_PRODUCT_ID),\n\t.bNumConfigurations =   1,\n};\n\n#define USB_G_STR_CONFIG USB_GADGET_FIRST_AVAIL_IDX\n\nstatic struct usb_string\tusbg_us_strings[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s\t= \"Target Manufacturer\",\n\t[USB_GADGET_PRODUCT_IDX].s\t= \"Target Product\",\n\t[USB_GADGET_SERIAL_IDX].s\t= \"000000000001\",\n\t[USB_G_STR_CONFIG].s\t\t= \"default config\",\n\t{ },\n};\n\nstatic struct usb_gadget_strings usbg_stringtab = {\n\t.language = 0x0409,\n\t.strings = usbg_us_strings,\n};\n\nstatic struct usb_gadget_strings *usbg_strings[] = {\n\t&usbg_stringtab,\n\tNULL,\n};\n\nstatic struct usb_function_instance *fi_tcm;\nstatic struct usb_function *f_tcm;\n\nstatic int guas_unbind(struct usb_composite_dev *cdev)\n{\n\tif (!IS_ERR_OR_NULL(f_tcm))\n\t\tusb_put_function(f_tcm);\n\n\treturn 0;\n}\n\nstatic int tcm_do_config(struct usb_configuration *c)\n{\n\tint status;\n\n\tf_tcm = usb_get_function(fi_tcm);\n\tif (IS_ERR(f_tcm))\n\t\treturn PTR_ERR(f_tcm);\n\n\tstatus = usb_add_function(c, f_tcm);\n\tif (status < 0) {\n\t\tusb_put_function(f_tcm);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic struct usb_configuration usbg_config_driver = {\n\t.label                  = \"Linux Target\",\n\t.bConfigurationValue    = 1,\n\t.bmAttributes           = USB_CONFIG_ATT_SELFPOWER,\n};\n\nstatic int usbg_attach(struct usb_function_instance *f);\nstatic void usbg_detach(struct usb_function_instance *f);\n\nstatic int usb_target_bind(struct usb_composite_dev *cdev)\n{\n\tint ret;\n\n\tret = usb_string_ids_tab(cdev, usbg_us_strings);\n\tif (ret)\n\t\treturn ret;\n\n\tusbg_device_desc.iManufacturer =\n\t\tusbg_us_strings[USB_GADGET_MANUFACTURER_IDX].id;\n\tusbg_device_desc.iProduct = usbg_us_strings[USB_GADGET_PRODUCT_IDX].id;\n\tusbg_device_desc.iSerialNumber =\n\t\tusbg_us_strings[USB_GADGET_SERIAL_IDX].id;\n\tusbg_config_driver.iConfiguration =\n\t\tusbg_us_strings[USB_G_STR_CONFIG].id;\n\n\tret = usb_add_config(cdev, &usbg_config_driver, tcm_do_config);\n\tif (ret)\n\t\treturn ret;\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\treturn 0;\n}\n\nstatic struct usb_composite_driver usbg_driver = {\n\t.name           = \"g_target\",\n\t.dev            = &usbg_device_desc,\n\t.strings        = usbg_strings,\n\t.max_speed      = USB_SPEED_SUPER,\n\t.bind\t\t= usb_target_bind,\n\t.unbind         = guas_unbind,\n};\n\nstatic int usbg_attach(struct usb_function_instance *f)\n{\n\treturn usb_composite_probe(&usbg_driver);\n}\n\nstatic void usbg_detach(struct usb_function_instance *f)\n{\n\tusb_composite_unregister(&usbg_driver);\n}\n\nstatic int __init usb_target_gadget_init(void)\n{\n\tstruct f_tcm_opts *tcm_opts;\n\n\tfi_tcm = usb_get_function_instance(\"tcm\");\n\tif (IS_ERR(fi_tcm))\n\t\treturn PTR_ERR(fi_tcm);\n\n\ttcm_opts = container_of(fi_tcm, struct f_tcm_opts, func_inst);\n\tmutex_lock(&tcm_opts->dep_lock);\n\ttcm_opts->tcm_register_callback = usbg_attach;\n\ttcm_opts->tcm_unregister_callback = usbg_detach;\n\ttcm_opts->dependent = THIS_MODULE;\n\ttcm_opts->can_attach = true;\n\ttcm_opts->has_dep = true;\n\tmutex_unlock(&tcm_opts->dep_lock);\n\n\tfi_tcm->set_inst_name(fi_tcm, \"tcm-legacy\");\n\n\treturn 0;\n}\nmodule_init(usb_target_gadget_init);\n\nstatic void __exit usb_target_gadget_exit(void)\n{\n\tif (!IS_ERR_OR_NULL(fi_tcm))\n\t\tusb_put_function_instance(fi_tcm);\n\n}\nmodule_exit(usb_target_gadget_exit);\n\nMODULE_AUTHOR(\"Sebastian Andrzej Siewior <bigeasy@linutronix.de>\");\nMODULE_DESCRIPTION(\"usb-gadget fabric\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}