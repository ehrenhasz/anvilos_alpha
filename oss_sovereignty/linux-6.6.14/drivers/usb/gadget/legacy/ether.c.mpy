{
  "module_name": "ether.c",
  "hash_id": "48d34b8114c4b70e86f273c9d5aeed9f00dafb35fef2c94e1f8eaccf46108193",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/ether.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n\n#if defined USB_ETH_RNDIS\n#  undef USB_ETH_RNDIS\n#endif\n#ifdef CONFIG_USB_ETH_RNDIS\n#  define USB_ETH_RNDIS y\n#endif\n\n#include \"u_ether.h\"\n\n\n \n\n#define DRIVER_DESC\t\t\"Ethernet Gadget\"\n#define DRIVER_VERSION\t\t\"Memorial Day 2008\"\n\n#ifdef USB_ETH_RNDIS\n#define PREFIX\t\t\t\"RNDIS/\"\n#else\n#define PREFIX\t\t\t\"\"\n#endif\n\n \n\nstatic inline bool has_rndis(void)\n{\n#ifdef\tUSB_ETH_RNDIS\n\treturn true;\n#else\n\treturn false;\n#endif\n}\n\n#include <linux/module.h>\n\n#include \"u_ecm.h\"\n#include \"u_gether.h\"\n#ifdef\tUSB_ETH_RNDIS\n#include \"u_rndis.h\"\n#include \"rndis.h\"\n#else\n#define rndis_borrow_net(...) do {} while (0)\n#endif\n#include \"u_eem.h\"\n\n \nUSB_GADGET_COMPOSITE_OPTIONS();\n\nUSB_ETHERNET_MODULE_PARAMETERS();\n\n \n\n \n#define CDC_VENDOR_NUM\t\t0x0525\t \n#define CDC_PRODUCT_NUM\t\t0xa4a1\t \n\n \n#define\tSIMPLE_VENDOR_NUM\t0x049f\n#define\tSIMPLE_PRODUCT_NUM\t0x505a\n\n \n#define RNDIS_VENDOR_NUM\t0x0525\t \n#define RNDIS_PRODUCT_NUM\t0xa4a2\t \n\n \n#define EEM_VENDOR_NUM\t\t0x1d6b\t \n#define EEM_PRODUCT_NUM\t\t0x0102\t \n\n \n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\n\t \n\n\t.bDeviceClass =\t\tUSB_CLASS_COMM,\n\t.bDeviceSubClass =\t0,\n\t.bDeviceProtocol =\t0,\n\t \n\n\t \n\t.idVendor =\t\tcpu_to_le16 (CDC_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16 (CDC_PRODUCT_NUM),\n\t \n\t \n\t \n\t \n\t.bNumConfigurations =\t1,\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = PREFIX DRIVER_DESC,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings stringtab_dev = {\n\t.language\t= 0x0409,\t \n\t.strings\t= strings_dev,\n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&stringtab_dev,\n\tNULL,\n};\n\nstatic struct usb_function_instance *fi_ecm;\nstatic struct usb_function *f_ecm;\n\nstatic struct usb_function_instance *fi_eem;\nstatic struct usb_function *f_eem;\n\nstatic struct usb_function_instance *fi_geth;\nstatic struct usb_function *f_geth;\n\nstatic struct usb_function_instance *fi_rndis;\nstatic struct usb_function *f_rndis;\n\n \n\n \nstatic int rndis_do_config(struct usb_configuration *c)\n{\n\tint status;\n\n\t \n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tf_rndis = usb_get_function(fi_rndis);\n\tif (IS_ERR(f_rndis))\n\t\treturn PTR_ERR(f_rndis);\n\n\tstatus = usb_add_function(c, f_rndis);\n\tif (status < 0)\n\t\tusb_put_function(f_rndis);\n\n\treturn status;\n}\n\nstatic struct usb_configuration rndis_config_driver = {\n\t.label\t\t\t= \"RNDIS\",\n\t.bConfigurationValue\t= 2,\n\t \n\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n};\n\n \n\n#ifdef CONFIG_USB_ETH_EEM\nstatic bool use_eem = 1;\n#else\nstatic bool use_eem;\n#endif\nmodule_param(use_eem, bool, 0);\nMODULE_PARM_DESC(use_eem, \"use CDC EEM mode\");\n\n \nstatic int eth_do_config(struct usb_configuration *c)\n{\n\tint status = 0;\n\n\t \n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tif (use_eem) {\n\t\tf_eem = usb_get_function(fi_eem);\n\t\tif (IS_ERR(f_eem))\n\t\t\treturn PTR_ERR(f_eem);\n\n\t\tstatus = usb_add_function(c, f_eem);\n\t\tif (status < 0)\n\t\t\tusb_put_function(f_eem);\n\n\t\treturn status;\n\t} else if (can_support_ecm(c->cdev->gadget)) {\n\t\tf_ecm = usb_get_function(fi_ecm);\n\t\tif (IS_ERR(f_ecm))\n\t\t\treturn PTR_ERR(f_ecm);\n\n\t\tstatus = usb_add_function(c, f_ecm);\n\t\tif (status < 0)\n\t\t\tusb_put_function(f_ecm);\n\n\t\treturn status;\n\t} else {\n\t\tf_geth = usb_get_function(fi_geth);\n\t\tif (IS_ERR(f_geth))\n\t\t\treturn PTR_ERR(f_geth);\n\n\t\tstatus = usb_add_function(c, f_geth);\n\t\tif (status < 0)\n\t\t\tusb_put_function(f_geth);\n\n\t\treturn status;\n\t}\n\n}\n\nstatic struct usb_configuration eth_config_driver = {\n\t \n\t.bConfigurationValue\t= 1,\n\t \n\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n};\n\n \n\nstatic int eth_bind(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget\t*gadget = cdev->gadget;\n\tstruct f_eem_opts\t*eem_opts = NULL;\n\tstruct f_ecm_opts\t*ecm_opts = NULL;\n\tstruct f_gether_opts\t*geth_opts = NULL;\n\tstruct net_device\t*net;\n\tint\t\t\tstatus;\n\n\t \n\tif (use_eem) {\n\t\t \n\t\tfi_eem = usb_get_function_instance(\"eem\");\n\t\tif (IS_ERR(fi_eem))\n\t\t\treturn PTR_ERR(fi_eem);\n\n\t\teem_opts = container_of(fi_eem, struct f_eem_opts, func_inst);\n\n\t\tnet = eem_opts->net;\n\n\t\teth_config_driver.label = \"CDC Ethernet (EEM)\";\n\t\tdevice_desc.idVendor = cpu_to_le16(EEM_VENDOR_NUM);\n\t\tdevice_desc.idProduct = cpu_to_le16(EEM_PRODUCT_NUM);\n\t} else if (can_support_ecm(gadget)) {\n\t\t \n\n\t\tfi_ecm = usb_get_function_instance(\"ecm\");\n\t\tif (IS_ERR(fi_ecm))\n\t\t\treturn PTR_ERR(fi_ecm);\n\n\t\tecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\n\n\t\tnet = ecm_opts->net;\n\n\t\teth_config_driver.label = \"CDC Ethernet (ECM)\";\n\t} else {\n\t\t \n\n\t\tfi_geth = usb_get_function_instance(\"geth\");\n\t\tif (IS_ERR(fi_geth))\n\t\t\treturn PTR_ERR(fi_geth);\n\n\t\tgeth_opts = container_of(fi_geth, struct f_gether_opts,\n\t\t\t\t\t func_inst);\n\n\t\tnet = geth_opts->net;\n\n\t\teth_config_driver.label = \"CDC Subset/SAFE\";\n\n\t\tdevice_desc.idVendor = cpu_to_le16(SIMPLE_VENDOR_NUM);\n\t\tdevice_desc.idProduct = cpu_to_le16(SIMPLE_PRODUCT_NUM);\n\t\tif (!has_rndis())\n\t\t\tdevice_desc.bDeviceClass = USB_CLASS_VENDOR_SPEC;\n\t}\n\n\tgether_set_qmult(net, qmult);\n\tif (!gether_set_host_addr(net, host_addr))\n\t\tpr_info(\"using host ethernet address: %s\", host_addr);\n\tif (!gether_set_dev_addr(net, dev_addr))\n\t\tpr_info(\"using self ethernet address: %s\", dev_addr);\n\n\tif (has_rndis()) {\n\t\t \n\t\tgether_set_gadget(net, cdev->gadget);\n\t\tstatus = gether_register_netdev(net);\n\t\tif (status)\n\t\t\tgoto fail;\n\n\t\tif (use_eem)\n\t\t\teem_opts->bound = true;\n\t\telse if (can_support_ecm(gadget))\n\t\t\tecm_opts->bound = true;\n\t\telse\n\t\t\tgeth_opts->bound = true;\n\n\t\tfi_rndis = usb_get_function_instance(\"rndis\");\n\t\tif (IS_ERR(fi_rndis)) {\n\t\t\tstatus = PTR_ERR(fi_rndis);\n\t\t\tgoto fail;\n\t\t}\n\n\t\trndis_borrow_net(fi_rndis, net);\n\n\t\tdevice_desc.idVendor = cpu_to_le16(RNDIS_VENDOR_NUM);\n\t\tdevice_desc.idProduct = cpu_to_le16(RNDIS_PRODUCT_NUM);\n\t\tdevice_desc.bNumConfigurations = 2;\n\t}\n\n\t \n\n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (status < 0)\n\t\tgoto fail1;\n\tdevice_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\n\tif (gadget_is_otg(gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(gadget);\n\t\tif (!usb_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail1;\n\t\t}\n\t\tusb_otg_descriptor_init(gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\t \n\tif (has_rndis()) {\n\t\tstatus = usb_add_config(cdev, &rndis_config_driver,\n\t\t\t\trndis_do_config);\n\t\tif (status < 0)\n\t\t\tgoto fail2;\n\t}\n\n\tstatus = usb_add_config(cdev, &eth_config_driver, eth_do_config);\n\tif (status < 0)\n\t\tgoto fail2;\n\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\tdev_info(&gadget->dev, \"%s, version: \" DRIVER_VERSION \"\\n\",\n\t\t\tDRIVER_DESC);\n\n\treturn 0;\n\nfail2:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nfail1:\n\tif (has_rndis())\n\t\tusb_put_function_instance(fi_rndis);\nfail:\n\tif (use_eem)\n\t\tusb_put_function_instance(fi_eem);\n\telse if (can_support_ecm(gadget))\n\t\tusb_put_function_instance(fi_ecm);\n\telse\n\t\tusb_put_function_instance(fi_geth);\n\treturn status;\n}\n\nstatic int eth_unbind(struct usb_composite_dev *cdev)\n{\n\tif (has_rndis()) {\n\t\tusb_put_function(f_rndis);\n\t\tusb_put_function_instance(fi_rndis);\n\t}\n\tif (use_eem) {\n\t\tusb_put_function(f_eem);\n\t\tusb_put_function_instance(fi_eem);\n\t} else if (can_support_ecm(cdev->gadget)) {\n\t\tusb_put_function(f_ecm);\n\t\tusb_put_function_instance(fi_ecm);\n\t} else {\n\t\tusb_put_function(f_geth);\n\t\tusb_put_function_instance(fi_geth);\n\t}\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\nstatic struct usb_composite_driver eth_driver = {\n\t.name\t\t= \"g_ether\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_SUPER,\n\t.bind\t\t= eth_bind,\n\t.unbind\t\t= eth_unbind,\n};\n\nmodule_usb_composite_driver(eth_driver);\n\nMODULE_DESCRIPTION(PREFIX DRIVER_DESC);\nMODULE_AUTHOR(\"David Brownell, Benedikt Spanger\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}