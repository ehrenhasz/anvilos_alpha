{
  "module_name": "raw_gadget.c",
  "hash_id": "2070a94612cfcc46b9c77ed975c827548b5134e6e43a4fc6735b774ae801047b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/raw_gadget.c",
  "human_readable_source": "\n \n\n#include <linux/compiler.h>\n#include <linux/ctype.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/idr.h>\n#include <linux/kref.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/semaphore.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/wait.h>\n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/ch11.h>\n#include <linux/usb/gadget.h>\n\n#include <uapi/linux/usb/raw_gadget.h>\n\n#define\tDRIVER_DESC \"USB Raw Gadget\"\n#define DRIVER_NAME \"raw-gadget\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Andrey Konovalov\");\nMODULE_LICENSE(\"GPL\");\n\n \n\nstatic DEFINE_IDA(driver_id_numbers);\n#define DRIVER_DRIVER_NAME_LENGTH_MAX\t32\n\n#define RAW_EVENT_QUEUE_SIZE\t16\n\nstruct raw_event_queue {\n\t \n\tspinlock_t\t\tlock;\n\tstruct semaphore\tsema;\n\tstruct usb_raw_event\t*events[RAW_EVENT_QUEUE_SIZE];\n\tint\t\t\tsize;\n};\n\nstatic void raw_event_queue_init(struct raw_event_queue *queue)\n{\n\tspin_lock_init(&queue->lock);\n\tsema_init(&queue->sema, 0);\n\tqueue->size = 0;\n}\n\nstatic int raw_event_queue_add(struct raw_event_queue *queue,\n\tenum usb_raw_event_type type, size_t length, const void *data)\n{\n\tunsigned long flags;\n\tstruct usb_raw_event *event;\n\n\tspin_lock_irqsave(&queue->lock, flags);\n\tif (WARN_ON(queue->size >= RAW_EVENT_QUEUE_SIZE)) {\n\t\tspin_unlock_irqrestore(&queue->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tevent = kmalloc(sizeof(*event) + length, GFP_ATOMIC);\n\tif (!event) {\n\t\tspin_unlock_irqrestore(&queue->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\tevent->type = type;\n\tevent->length = length;\n\tif (event->length)\n\t\tmemcpy(&event->data[0], data, length);\n\tqueue->events[queue->size] = event;\n\tqueue->size++;\n\tup(&queue->sema);\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\treturn 0;\n}\n\nstatic struct usb_raw_event *raw_event_queue_fetch(\n\t\t\t\tstruct raw_event_queue *queue)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct usb_raw_event *event;\n\n\t \n\tret = down_interruptible(&queue->sema);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tspin_lock_irqsave(&queue->lock, flags);\n\t \n\tif (WARN_ON(!queue->size)) {\n\t\tspin_unlock_irqrestore(&queue->lock, flags);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\tevent = queue->events[0];\n\tqueue->size--;\n\tmemmove(&queue->events[0], &queue->events[1],\n\t\t\tqueue->size * sizeof(queue->events[0]));\n\tspin_unlock_irqrestore(&queue->lock, flags);\n\treturn event;\n}\n\nstatic void raw_event_queue_destroy(struct raw_event_queue *queue)\n{\n\tint i;\n\n\tfor (i = 0; i < queue->size; i++)\n\t\tkfree(queue->events[i]);\n\tqueue->size = 0;\n}\n\n \n\nstruct raw_dev;\n\nenum ep_state {\n\tSTATE_EP_DISABLED,\n\tSTATE_EP_ENABLED,\n};\n\nstruct raw_ep {\n\tstruct raw_dev\t\t*dev;\n\tenum ep_state\t\tstate;\n\tstruct usb_ep\t\t*ep;\n\tu8\t\t\taddr;\n\tstruct usb_request\t*req;\n\tbool\t\t\turb_queued;\n\tbool\t\t\tdisabling;\n\tssize_t\t\t\tstatus;\n};\n\nenum dev_state {\n\tSTATE_DEV_INVALID = 0,\n\tSTATE_DEV_OPENED,\n\tSTATE_DEV_INITIALIZED,\n\tSTATE_DEV_REGISTERING,\n\tSTATE_DEV_RUNNING,\n\tSTATE_DEV_CLOSED,\n\tSTATE_DEV_FAILED\n};\n\nstruct raw_dev {\n\tstruct kref\t\t\tcount;\n\tspinlock_t\t\t\tlock;\n\n\tconst char\t\t\t*udc_name;\n\tstruct usb_gadget_driver\tdriver;\n\n\t \n\tstruct device\t\t\t*dev;\n\n\t \n\tint\t\t\t\tdriver_id_number;\n\n\t \n\tenum dev_state\t\t\tstate;\n\tbool\t\t\t\tgadget_registered;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct usb_request\t\t*req;\n\tbool\t\t\t\tep0_in_pending;\n\tbool\t\t\t\tep0_out_pending;\n\tbool\t\t\t\tep0_urb_queued;\n\tssize_t\t\t\t\tep0_status;\n\tstruct raw_ep\t\t\teps[USB_RAW_EPS_NUM_MAX];\n\tint\t\t\t\teps_num;\n\n\tstruct completion\t\tep0_done;\n\tstruct raw_event_queue\t\tqueue;\n};\n\nstatic struct raw_dev *dev_new(void)\n{\n\tstruct raw_dev *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\t \n\tkref_init(&dev->count);\n\tspin_lock_init(&dev->lock);\n\tinit_completion(&dev->ep0_done);\n\traw_event_queue_init(&dev->queue);\n\tdev->driver_id_number = -1;\n\treturn dev;\n}\n\nstatic void dev_free(struct kref *kref)\n{\n\tstruct raw_dev *dev = container_of(kref, struct raw_dev, count);\n\tint i;\n\n\tkfree(dev->udc_name);\n\tkfree(dev->driver.udc_name);\n\tkfree(dev->driver.driver.name);\n\tif (dev->driver_id_number >= 0)\n\t\tida_free(&driver_id_numbers, dev->driver_id_number);\n\tif (dev->req) {\n\t\tif (dev->ep0_urb_queued)\n\t\t\tusb_ep_dequeue(dev->gadget->ep0, dev->req);\n\t\tusb_ep_free_request(dev->gadget->ep0, dev->req);\n\t}\n\traw_event_queue_destroy(&dev->queue);\n\tfor (i = 0; i < dev->eps_num; i++) {\n\t\tif (dev->eps[i].state == STATE_EP_DISABLED)\n\t\t\tcontinue;\n\t\tusb_ep_disable(dev->eps[i].ep);\n\t\tusb_ep_free_request(dev->eps[i].ep, dev->eps[i].req);\n\t\tkfree(dev->eps[i].ep->desc);\n\t\tdev->eps[i].state = STATE_EP_DISABLED;\n\t}\n\tkfree(dev);\n}\n\n \n\nstatic int raw_queue_event(struct raw_dev *dev,\n\tenum usb_raw_event_type type, size_t length, const void *data)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tret = raw_event_queue_add(&dev->queue, type, length, data);\n\tif (ret < 0) {\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t}\n\treturn ret;\n}\n\nstatic void gadget_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct raw_dev *dev = req->context;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (req->status)\n\t\tdev->ep0_status = req->status;\n\telse\n\t\tdev->ep0_status = req->actual;\n\tif (dev->ep0_in_pending)\n\t\tdev->ep0_in_pending = false;\n\telse\n\t\tdev->ep0_out_pending = false;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tcomplete(&dev->ep0_done);\n}\n\nstatic u8 get_ep_addr(const char *name)\n{\n\t \n\tif (isdigit(name[2]))\n\t\treturn simple_strtoul(&name[2], NULL, 10);\n\t \n\treturn USB_RAW_EP_ADDR_ANY;\n}\n\nstatic int gadget_bind(struct usb_gadget *gadget,\n\t\t\tstruct usb_gadget_driver *driver)\n{\n\tint ret = 0, i = 0;\n\tstruct raw_dev *dev = container_of(driver, struct raw_dev, driver);\n\tstruct usb_request *req;\n\tstruct usb_ep *ep;\n\tunsigned long flags;\n\n\tif (strcmp(gadget->name, dev->udc_name) != 0)\n\t\treturn -ENODEV;\n\n\tset_gadget_data(gadget, dev);\n\treq = usb_ep_alloc_request(gadget->ep0, GFP_KERNEL);\n\tif (!req) {\n\t\tdev_err(&gadget->dev, \"usb_ep_alloc_request failed\\n\");\n\t\tset_gadget_data(gadget, NULL);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->req = req;\n\tdev->req->context = dev;\n\tdev->req->complete = gadget_ep0_complete;\n\tdev->gadget = gadget;\n\tgadget_for_each_ep(ep, dev->gadget) {\n\t\tdev->eps[i].ep = ep;\n\t\tdev->eps[i].addr = get_ep_addr(ep->name);\n\t\tdev->eps[i].state = STATE_EP_DISABLED;\n\t\ti++;\n\t}\n\tdev->eps_num = i;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tret = raw_queue_event(dev, USB_RAW_EVENT_CONNECT, 0, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&gadget->dev, \"failed to queue event\\n\");\n\t\tset_gadget_data(gadget, NULL);\n\t\treturn ret;\n\t}\n\n\t \n\tkref_get(&dev->count);\n\treturn ret;\n}\n\nstatic void gadget_unbind(struct usb_gadget *gadget)\n{\n\tstruct raw_dev *dev = get_gadget_data(gadget);\n\n\tset_gadget_data(gadget, NULL);\n\t \n\tkref_put(&dev->count, dev_free);\n}\n\nstatic int gadget_setup(struct usb_gadget *gadget,\n\t\t\tconst struct usb_ctrlrequest *ctrl)\n{\n\tint ret = 0;\n\tstruct raw_dev *dev = get_gadget_data(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_err(&gadget->dev, \"ignoring, device is not running\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->ep0_in_pending || dev->ep0_out_pending) {\n\t\tdev_dbg(&gadget->dev, \"stalling, request already pending\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif ((ctrl->bRequestType & USB_DIR_IN) && ctrl->wLength)\n\t\tdev->ep0_in_pending = true;\n\telse\n\t\tdev->ep0_out_pending = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tret = raw_queue_event(dev, USB_RAW_EVENT_CONTROL, sizeof(*ctrl), ctrl);\n\tif (ret < 0)\n\t\tdev_err(&gadget->dev, \"failed to queue event\\n\");\n\tgoto out;\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\nout:\n\treturn ret;\n}\n\n \nstatic void gadget_disconnect(struct usb_gadget *gadget) { }\nstatic void gadget_suspend(struct usb_gadget *gadget) { }\nstatic void gadget_resume(struct usb_gadget *gadget) { }\nstatic void gadget_reset(struct usb_gadget *gadget) { }\n\n \n\nstatic struct miscdevice raw_misc_device;\n\nstatic int raw_open(struct inode *inode, struct file *fd)\n{\n\tstruct raw_dev *dev;\n\n\t \n\tif (fd->f_flags & O_NONBLOCK)\n\t\treturn -EINVAL;\n\n\tdev = dev_new();\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tfd->private_data = dev;\n\tdev->state = STATE_DEV_OPENED;\n\tdev->dev = raw_misc_device.this_device;\n\treturn 0;\n}\n\nstatic int raw_release(struct inode *inode, struct file *fd)\n{\n\tint ret = 0;\n\tstruct raw_dev *dev = fd->private_data;\n\tunsigned long flags;\n\tbool unregister = false;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tdev->state = STATE_DEV_CLOSED;\n\tif (!dev->gadget) {\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tgoto out_put;\n\t}\n\tif (dev->gadget_registered)\n\t\tunregister = true;\n\tdev->gadget_registered = false;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (unregister) {\n\t\tret = usb_gadget_unregister_driver(&dev->driver);\n\t\tif (ret != 0)\n\t\t\tdev_err(dev->dev,\n\t\t\t\t\"usb_gadget_unregister_driver() failed with %d\\n\",\n\t\t\t\tret);\n\t\t \n\t\tkref_put(&dev->count, dev_free);\n\t}\n\nout_put:\n\t \n\tkref_put(&dev->count, dev_free);\n\treturn ret;\n}\n\n \n\nstatic int raw_ioctl_init(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tint driver_id_number;\n\tstruct usb_raw_init arg;\n\tchar *udc_driver_name;\n\tchar *udc_device_name;\n\tchar *driver_driver_name;\n\tunsigned long flags;\n\n\tif (copy_from_user(&arg, (void __user *)value, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tswitch (arg.speed) {\n\tcase USB_SPEED_UNKNOWN:\n\t\targ.speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdriver_id_number = ida_alloc(&driver_id_numbers, GFP_KERNEL);\n\tif (driver_id_number < 0)\n\t\treturn driver_id_number;\n\n\tdriver_driver_name = kmalloc(DRIVER_DRIVER_NAME_LENGTH_MAX, GFP_KERNEL);\n\tif (!driver_driver_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_driver_id_number;\n\t}\n\tsnprintf(driver_driver_name, DRIVER_DRIVER_NAME_LENGTH_MAX,\n\t\t\t\tDRIVER_NAME \".%d\", driver_id_number);\n\n\tudc_driver_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);\n\tif (!udc_driver_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_driver_driver_name;\n\t}\n\tret = strscpy(udc_driver_name, &arg.driver_name[0],\n\t\t\t\tUDC_NAME_LENGTH_MAX);\n\tif (ret < 0)\n\t\tgoto out_free_udc_driver_name;\n\tret = 0;\n\n\tudc_device_name = kmalloc(UDC_NAME_LENGTH_MAX, GFP_KERNEL);\n\tif (!udc_device_name) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_udc_driver_name;\n\t}\n\tret = strscpy(udc_device_name, &arg.device_name[0],\n\t\t\t\tUDC_NAME_LENGTH_MAX);\n\tif (ret < 0)\n\t\tgoto out_free_udc_device_name;\n\tret = 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_OPENED) {\n\t\tdev_dbg(dev->dev, \"fail, device is not opened\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tdev->udc_name = udc_driver_name;\n\n\tdev->driver.function = DRIVER_DESC;\n\tdev->driver.max_speed = arg.speed;\n\tdev->driver.setup = gadget_setup;\n\tdev->driver.disconnect = gadget_disconnect;\n\tdev->driver.bind = gadget_bind;\n\tdev->driver.unbind = gadget_unbind;\n\tdev->driver.suspend = gadget_suspend;\n\tdev->driver.resume = gadget_resume;\n\tdev->driver.reset = gadget_reset;\n\tdev->driver.driver.name = driver_driver_name;\n\tdev->driver.udc_name = udc_device_name;\n\tdev->driver.match_existing_only = 1;\n\tdev->driver_id_number = driver_id_number;\n\n\tdev->state = STATE_DEV_INITIALIZED;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\nout_free_udc_device_name:\n\tkfree(udc_device_name);\nout_free_udc_driver_name:\n\tkfree(udc_driver_name);\nout_free_driver_driver_name:\n\tkfree(driver_driver_name);\nout_free_driver_id_number:\n\tida_free(&driver_id_numbers, driver_id_number);\n\treturn ret;\n}\n\nstatic int raw_ioctl_run(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tif (value)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_INITIALIZED) {\n\t\tdev_dbg(dev->dev, \"fail, device is not initialized\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tdev->state = STATE_DEV_REGISTERING;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tret = usb_gadget_register_driver(&dev->driver);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (ret) {\n\t\tdev_err(dev->dev,\n\t\t\t\"fail, usb_gadget_register_driver returned %d\\n\", ret);\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tgoto out_unlock;\n\t}\n\tdev->gadget_registered = true;\n\tdev->state = STATE_DEV_RUNNING;\n\t \n\tkref_get(&dev->count);\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_event_fetch(struct raw_dev *dev, unsigned long value)\n{\n\tstruct usb_raw_event arg;\n\tunsigned long flags;\n\tstruct usb_raw_event *event;\n\tuint32_t length;\n\n\tif (copy_from_user(&arg, (void __user *)value, sizeof(arg)))\n\t\treturn -EFAULT;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tevent = raw_event_queue_fetch(&dev->queue);\n\tif (PTR_ERR(event) == -EINTR) {\n\t\tdev_dbg(&dev->gadget->dev, \"event fetching interrupted\\n\");\n\t\treturn -EINTR;\n\t}\n\tif (IS_ERR(event)) {\n\t\tdev_err(&dev->gadget->dev, \"failed to fetch event\\n\");\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tlength = min(arg.length, event->length);\n\tif (copy_to_user((void __user *)value, event, sizeof(*event) + length)) {\n\t\tkfree(event);\n\t\treturn -EFAULT;\n\t}\n\n\tkfree(event);\n\treturn 0;\n}\n\nstatic void *raw_alloc_io_data(struct usb_raw_ep_io *io, void __user *ptr,\n\t\t\t\tbool get_from_user)\n{\n\tvoid *data;\n\n\tif (copy_from_user(io, ptr, sizeof(*io)))\n\t\treturn ERR_PTR(-EFAULT);\n\tif (io->ep >= USB_RAW_EPS_NUM_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (!usb_raw_io_flags_valid(io->flags))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (io->length > PAGE_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (get_from_user)\n\t\tdata = memdup_user(ptr + sizeof(*io), io->length);\n\telse {\n\t\tdata = kmalloc(io->length, GFP_KERNEL);\n\t\tif (!data)\n\t\t\tdata = ERR_PTR(-ENOMEM);\n\t}\n\treturn data;\n}\n\nstatic int raw_process_ep0_io(struct raw_dev *dev, struct usb_raw_ep_io *io,\n\t\t\t\tvoid *data, bool in)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->ep0_urb_queued) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, urb already queued\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif ((in && !dev->ep0_in_pending) ||\n\t\t\t(!in && !dev->ep0_out_pending)) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, wrong direction\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (WARN_ON(in && dev->ep0_out_pending)) {\n\t\tret = -ENODEV;\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tgoto out_unlock;\n\t}\n\tif (WARN_ON(!in && dev->ep0_in_pending)) {\n\t\tret = -ENODEV;\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tgoto out_unlock;\n\t}\n\n\tdev->req->buf = data;\n\tdev->req->length = io->length;\n\tdev->req->zero = usb_raw_io_flags_zero(io->flags);\n\tdev->ep0_urb_queued = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tret = usb_ep_queue(dev->gadget->ep0, dev->req, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_queue returned %d\\n\", ret);\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tgoto out_queue_failed;\n\t}\n\n\tret = wait_for_completion_interruptible(&dev->ep0_done);\n\tif (ret) {\n\t\tdev_dbg(&dev->gadget->dev, \"wait interrupted\\n\");\n\t\tusb_ep_dequeue(dev->gadget->ep0, dev->req);\n\t\twait_for_completion(&dev->ep0_done);\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tif (dev->ep0_status == -ECONNRESET)\n\t\t\tdev->ep0_status = -EINTR;\n\t\tgoto out_interrupted;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\nout_interrupted:\n\tret = dev->ep0_status;\nout_queue_failed:\n\tdev->ep0_urb_queued = false;\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep0_write(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tvoid *data;\n\tstruct usb_raw_ep_io io;\n\n\tdata = raw_alloc_io_data(&io, (void __user *)value, true);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tret = raw_process_ep0_io(dev, &io, data, true);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep0_read(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tvoid *data;\n\tstruct usb_raw_ep_io io;\n\tunsigned int length;\n\n\tdata = raw_alloc_io_data(&io, (void __user *)value, false);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tret = raw_process_ep0_io(dev, &io, data, false);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tlength = min(io.length, (unsigned int)ret);\n\tif (copy_to_user((void __user *)(value + sizeof(io)), data, length))\n\t\tret = -EFAULT;\n\telse\n\t\tret = length;\nfree:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep0_stall(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tif (value)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->ep0_urb_queued) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, urb already queued\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->ep0_in_pending && !dev->ep0_out_pending) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, no request pending\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tret = usb_ep_set_halt(dev->gadget->ep0);\n\tif (ret < 0)\n\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_set_halt returned %d\\n\", ret);\n\n\tif (dev->ep0_in_pending)\n\t\tdev->ep0_in_pending = false;\n\telse\n\t\tdev->ep0_out_pending = false;\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep_enable(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0, i;\n\tunsigned long flags;\n\tstruct usb_endpoint_descriptor *desc;\n\tstruct raw_ep *ep;\n\tbool ep_props_matched = false;\n\n\tdesc = memdup_user((void __user *)value, sizeof(*desc));\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t \n\tif (usb_endpoint_maxp(desc) == 0) {\n\t\tdev_dbg(dev->dev, \"fail, bad endpoint maxpacket\\n\");\n\t\tkfree(desc);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_free;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < dev->eps_num; i++) {\n\t\tep = &dev->eps[i];\n\t\tif (ep->addr != usb_endpoint_num(desc) &&\n\t\t\t\tep->addr != USB_RAW_EP_ADDR_ANY)\n\t\t\tcontinue;\n\t\tif (!usb_gadget_ep_match_desc(dev->gadget, ep->ep, desc, NULL))\n\t\t\tcontinue;\n\t\tep_props_matched = true;\n\t\tif (ep->state != STATE_EP_DISABLED)\n\t\t\tcontinue;\n\t\tep->ep->desc = desc;\n\t\tret = usb_ep_enable(ep->ep);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_enable returned %d\\n\", ret);\n\t\t\tgoto out_free;\n\t\t}\n\t\tep->req = usb_ep_alloc_request(ep->ep, GFP_ATOMIC);\n\t\tif (!ep->req) {\n\t\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_alloc_request failed\\n\");\n\t\t\tusb_ep_disable(ep->ep);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tep->state = STATE_EP_ENABLED;\n\t\tep->ep->driver_data = ep;\n\t\tret = i;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!ep_props_matched) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, bad endpoint descriptor\\n\");\n\t\tret = -EINVAL;\n\t} else {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, no endpoints available\\n\");\n\t\tret = -EBUSY;\n\t}\n\nout_free:\n\tkfree(desc);\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep_disable(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0, i = value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (i < 0 || i >= dev->eps_num) {\n\t\tdev_dbg(dev->dev, \"fail, invalid endpoint\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].state == STATE_EP_DISABLED) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, endpoint is not enabled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].disabling) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, disable already in progress\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].urb_queued) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, waiting for urb completion\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tdev->eps[i].disabling = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tusb_ep_disable(dev->eps[i].ep);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tusb_ep_free_request(dev->eps[i].ep, dev->eps[i].req);\n\tkfree(dev->eps[i].ep->desc);\n\tdev->eps[i].state = STATE_EP_DISABLED;\n\tdev->eps[i].disabling = false;\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep_set_clear_halt_wedge(struct raw_dev *dev,\n\t\tunsigned long value, bool set, bool halt)\n{\n\tint ret = 0, i = value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (i < 0 || i >= dev->eps_num) {\n\t\tdev_dbg(dev->dev, \"fail, invalid endpoint\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].state == STATE_EP_DISABLED) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, endpoint is not enabled\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].disabling) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, disable is in progress\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (dev->eps[i].urb_queued) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, waiting for urb completion\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (usb_endpoint_xfer_isoc(dev->eps[i].ep->desc)) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, can't halt/wedge ISO endpoint\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (set && halt) {\n\t\tret = usb_ep_set_halt(dev->eps[i].ep);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_set_halt returned %d\\n\", ret);\n\t} else if (!set && halt) {\n\t\tret = usb_ep_clear_halt(dev->eps[i].ep);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_clear_halt returned %d\\n\", ret);\n\t} else if (set && !halt) {\n\t\tret = usb_ep_set_wedge(dev->eps[i].ep);\n\t\tif (ret < 0)\n\t\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_set_wedge returned %d\\n\", ret);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic void gadget_ep_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct raw_ep *r_ep = (struct raw_ep *)ep->driver_data;\n\tstruct raw_dev *dev = r_ep->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (req->status)\n\t\tr_ep->status = req->status;\n\telse\n\t\tr_ep->status = req->actual;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tcomplete((struct completion *)req->context);\n}\n\nstatic int raw_process_ep_io(struct raw_dev *dev, struct usb_raw_ep_io *io,\n\t\t\t\tvoid *data, bool in)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct raw_ep *ep;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (io->ep >= dev->eps_num) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, invalid endpoint\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tep = &dev->eps[io->ep];\n\tif (ep->state != STATE_EP_ENABLED) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, endpoint is not enabled\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (ep->disabling) {\n\t\tdev_dbg(&dev->gadget->dev,\n\t\t\t\t\"fail, endpoint is already being disabled\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (ep->urb_queued) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, urb already queued\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tif (in != usb_endpoint_dir_in(ep->ep->desc)) {\n\t\tdev_dbg(&dev->gadget->dev, \"fail, wrong direction\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tep->dev = dev;\n\tep->req->context = &done;\n\tep->req->complete = gadget_ep_complete;\n\tep->req->buf = data;\n\tep->req->length = io->length;\n\tep->req->zero = usb_raw_io_flags_zero(io->flags);\n\tep->urb_queued = true;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tret = usb_ep_queue(ep->ep, ep->req, GFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(&dev->gadget->dev,\n\t\t\t\t\"fail, usb_ep_queue returned %d\\n\", ret);\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tdev->state = STATE_DEV_FAILED;\n\t\tgoto out_queue_failed;\n\t}\n\n\tret = wait_for_completion_interruptible(&done);\n\tif (ret) {\n\t\tdev_dbg(&dev->gadget->dev, \"wait interrupted\\n\");\n\t\tusb_ep_dequeue(ep->ep, ep->req);\n\t\twait_for_completion(&done);\n\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\tif (ep->status == -ECONNRESET)\n\t\t\tep->status = -EINTR;\n\t\tgoto out_interrupted;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\nout_interrupted:\n\tret = ep->status;\nout_queue_failed:\n\tep->urb_queued = false;\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep_write(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tchar *data;\n\tstruct usb_raw_ep_io io;\n\n\tdata = raw_alloc_io_data(&io, (void __user *)value, true);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tret = raw_process_ep_io(dev, &io, data, true);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int raw_ioctl_ep_read(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tchar *data;\n\tstruct usb_raw_ep_io io;\n\tunsigned int length;\n\n\tdata = raw_alloc_io_data(&io, (void __user *)value, false);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\tret = raw_process_ep_io(dev, &io, data, false);\n\tif (ret < 0)\n\t\tgoto free;\n\n\tlength = min(io.length, (unsigned int)ret);\n\tif (copy_to_user((void __user *)(value + sizeof(io)), data, length))\n\t\tret = -EFAULT;\n\telse\n\t\tret = length;\nfree:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int raw_ioctl_configure(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tif (value)\n\t\treturn -EINVAL;\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tusb_gadget_set_state(dev->gadget, USB_STATE_CONFIGURED);\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic int raw_ioctl_vbus_draw(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\tusb_gadget_vbus_draw(dev->gadget, 2 * value);\n\nout_unlock:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn ret;\n}\n\nstatic void fill_ep_caps(struct usb_ep_caps *caps,\n\t\t\t\tstruct usb_raw_ep_caps *raw_caps)\n{\n\traw_caps->type_control = caps->type_control;\n\traw_caps->type_iso = caps->type_iso;\n\traw_caps->type_bulk = caps->type_bulk;\n\traw_caps->type_int = caps->type_int;\n\traw_caps->dir_in = caps->dir_in;\n\traw_caps->dir_out = caps->dir_out;\n}\n\nstatic void fill_ep_limits(struct usb_ep *ep, struct usb_raw_ep_limits *limits)\n{\n\tlimits->maxpacket_limit = ep->maxpacket_limit;\n\tlimits->max_streams = ep->max_streams;\n}\n\nstatic int raw_ioctl_eps_info(struct raw_dev *dev, unsigned long value)\n{\n\tint ret = 0, i;\n\tunsigned long flags;\n\tstruct usb_raw_eps_info *info;\n\tstruct raw_ep *ep;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (dev->state != STATE_DEV_RUNNING) {\n\t\tdev_dbg(dev->dev, \"fail, device is not running\\n\");\n\t\tret = -EINVAL;\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tgoto out_free;\n\t}\n\tif (!dev->gadget) {\n\t\tdev_dbg(dev->dev, \"fail, gadget is not bound\\n\");\n\t\tret = -EBUSY;\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\tgoto out_free;\n\t}\n\n\tfor (i = 0; i < dev->eps_num; i++) {\n\t\tep = &dev->eps[i];\n\t\tstrscpy(&info->eps[i].name[0], ep->ep->name,\n\t\t\t\tUSB_RAW_EP_NAME_MAX);\n\t\tinfo->eps[i].addr = ep->addr;\n\t\tfill_ep_caps(&ep->ep->caps, &info->eps[i].caps);\n\t\tfill_ep_limits(ep->ep, &info->eps[i].limits);\n\t}\n\tret = dev->eps_num;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (copy_to_user((void __user *)value, info, sizeof(*info)))\n\t\tret = -EFAULT;\n\nout_free:\n\tkfree(info);\nout:\n\treturn ret;\n}\n\nstatic long raw_ioctl(struct file *fd, unsigned int cmd, unsigned long value)\n{\n\tstruct raw_dev *dev = fd->private_data;\n\tint ret = 0;\n\n\tif (!dev)\n\t\treturn -EBUSY;\n\n\tswitch (cmd) {\n\tcase USB_RAW_IOCTL_INIT:\n\t\tret = raw_ioctl_init(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_RUN:\n\t\tret = raw_ioctl_run(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EVENT_FETCH:\n\t\tret = raw_ioctl_event_fetch(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP0_WRITE:\n\t\tret = raw_ioctl_ep0_write(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP0_READ:\n\t\tret = raw_ioctl_ep0_read(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_ENABLE:\n\t\tret = raw_ioctl_ep_enable(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_DISABLE:\n\t\tret = raw_ioctl_ep_disable(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_WRITE:\n\t\tret = raw_ioctl_ep_write(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_READ:\n\t\tret = raw_ioctl_ep_read(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_CONFIGURE:\n\t\tret = raw_ioctl_configure(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_VBUS_DRAW:\n\t\tret = raw_ioctl_vbus_draw(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EPS_INFO:\n\t\tret = raw_ioctl_eps_info(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP0_STALL:\n\t\tret = raw_ioctl_ep0_stall(dev, value);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_SET_HALT:\n\t\tret = raw_ioctl_ep_set_clear_halt_wedge(\n\t\t\t\t\tdev, value, true, true);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_CLEAR_HALT:\n\t\tret = raw_ioctl_ep_set_clear_halt_wedge(\n\t\t\t\t\tdev, value, false, true);\n\t\tbreak;\n\tcase USB_RAW_IOCTL_EP_SET_WEDGE:\n\t\tret = raw_ioctl_ep_set_clear_halt_wedge(\n\t\t\t\t\tdev, value, true, false);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic const struct file_operations raw_fops = {\n\t.open =\t\t\traw_open,\n\t.unlocked_ioctl =\traw_ioctl,\n\t.compat_ioctl =\t\traw_ioctl,\n\t.release =\t\traw_release,\n\t.llseek =\t\tno_llseek,\n};\n\nstatic struct miscdevice raw_misc_device = {\n\t.minor = MISC_DYNAMIC_MINOR,\n\t.name = DRIVER_NAME,\n\t.fops = &raw_fops,\n};\n\nmodule_misc_device(raw_misc_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}