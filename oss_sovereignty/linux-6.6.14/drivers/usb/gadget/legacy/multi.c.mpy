{
  "module_name": "multi.c",
  "hash_id": "e1e39ac307f2027df7abe86477ed88072eb606eac8daaa07a6720b3e68d7e531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/gadget/legacy/multi.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/netdevice.h>\n\n#include \"u_serial.h\"\n#if defined USB_ETH_RNDIS\n#  undef USB_ETH_RNDIS\n#endif\n#ifdef CONFIG_USB_G_MULTI_RNDIS\n#  define USB_ETH_RNDIS y\n#endif\n\n\n#define DRIVER_DESC\t\t\"Multifunction Composite Gadget\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Michal Nazarewicz\");\nMODULE_LICENSE(\"GPL\");\n\n\n#include \"f_mass_storage.h\"\n\n#include \"u_ecm.h\"\n#ifdef USB_ETH_RNDIS\n#  include \"u_rndis.h\"\n#  include \"rndis.h\"\n#endif\n#include \"u_ether.h\"\n\nUSB_GADGET_COMPOSITE_OPTIONS();\n\nUSB_ETHERNET_MODULE_PARAMETERS();\n\n \n\n#define MULTI_VENDOR_NUM\t0x1d6b\t \n#define MULTI_PRODUCT_NUM\t0x0104\t \n\n\nenum {\n\t__MULTI_NO_CONFIG,\n#ifdef CONFIG_USB_G_MULTI_RNDIS\n\tMULTI_RNDIS_CONFIG_NUM,\n#endif\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tMULTI_CDC_CONFIG_NUM,\n#endif\n};\n\n\nstatic struct usb_device_descriptor device_desc = {\n\t.bLength =\t\tsizeof device_desc,\n\t.bDescriptorType =\tUSB_DT_DEVICE,\n\n\t \n\n\t.bDeviceClass =\t\tUSB_CLASS_MISC  ,\n\t.bDeviceSubClass =\t2,\n\t.bDeviceProtocol =\t1,\n\n\t \n\t.idVendor =\t\tcpu_to_le16(MULTI_VENDOR_NUM),\n\t.idProduct =\t\tcpu_to_le16(MULTI_PRODUCT_NUM),\n};\n\nstatic const struct usb_descriptor_header *otg_desc[2];\n\nenum {\n\tMULTI_STRING_RNDIS_CONFIG_IDX = USB_GADGET_FIRST_AVAIL_IDX,\n\tMULTI_STRING_CDC_CONFIG_IDX,\n};\n\nstatic struct usb_string strings_dev[] = {\n\t[USB_GADGET_MANUFACTURER_IDX].s = \"\",\n\t[USB_GADGET_PRODUCT_IDX].s = DRIVER_DESC,\n\t[USB_GADGET_SERIAL_IDX].s = \"\",\n\t[MULTI_STRING_RNDIS_CONFIG_IDX].s = \"Multifunction with RNDIS\",\n\t[MULTI_STRING_CDC_CONFIG_IDX].s   = \"Multifunction with CDC ECM\",\n\t{  }  \n};\n\nstatic struct usb_gadget_strings *dev_strings[] = {\n\t&(struct usb_gadget_strings){\n\t\t.language\t= 0x0409,\t \n\t\t.strings\t= strings_dev,\n\t},\n\tNULL,\n};\n\n\n\n\n \n\nstatic struct fsg_module_parameters fsg_mod_data = { .stall = 1 };\n#ifdef CONFIG_USB_GADGET_DEBUG_FILES\n\nstatic unsigned int fsg_num_buffers = CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS;\n\n#else\n\n \n#define fsg_num_buffers\tCONFIG_USB_GADGET_STORAGE_NUM_BUFFERS\n\n#endif  \n\nFSG_MODULE_PARAMETERS( , fsg_mod_data);\n\nstatic struct usb_function_instance *fi_acm;\nstatic struct usb_function_instance *fi_msg;\n\n \n\n#ifdef USB_ETH_RNDIS\nstatic struct usb_function_instance *fi_rndis;\nstatic struct usb_function *f_acm_rndis;\nstatic struct usb_function *f_rndis;\nstatic struct usb_function *f_msg_rndis;\n\nstatic int rndis_do_config(struct usb_configuration *c)\n{\n\tint ret;\n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tf_rndis = usb_get_function(fi_rndis);\n\tif (IS_ERR(f_rndis))\n\t\treturn PTR_ERR(f_rndis);\n\n\tret = usb_add_function(c, f_rndis);\n\tif (ret < 0)\n\t\tgoto err_func_rndis;\n\n\tf_acm_rndis = usb_get_function(fi_acm);\n\tif (IS_ERR(f_acm_rndis)) {\n\t\tret = PTR_ERR(f_acm_rndis);\n\t\tgoto err_func_acm;\n\t}\n\n\tret = usb_add_function(c, f_acm_rndis);\n\tif (ret)\n\t\tgoto err_conf;\n\n\tf_msg_rndis = usb_get_function(fi_msg);\n\tif (IS_ERR(f_msg_rndis)) {\n\t\tret = PTR_ERR(f_msg_rndis);\n\t\tgoto err_fsg;\n\t}\n\n\tret = usb_add_function(c, f_msg_rndis);\n\tif (ret)\n\t\tgoto err_run;\n\n\treturn 0;\nerr_run:\n\tusb_put_function(f_msg_rndis);\nerr_fsg:\n\tusb_remove_function(c, f_acm_rndis);\nerr_conf:\n\tusb_put_function(f_acm_rndis);\nerr_func_acm:\n\tusb_remove_function(c, f_rndis);\nerr_func_rndis:\n\tusb_put_function(f_rndis);\n\treturn ret;\n}\n\nstatic int rndis_config_register(struct usb_composite_dev *cdev)\n{\n\tstatic struct usb_configuration config = {\n\t\t.bConfigurationValue\t= MULTI_RNDIS_CONFIG_NUM,\n\t\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n\t};\n\n\tconfig.label          = strings_dev[MULTI_STRING_RNDIS_CONFIG_IDX].s;\n\tconfig.iConfiguration = strings_dev[MULTI_STRING_RNDIS_CONFIG_IDX].id;\n\n\treturn usb_add_config(cdev, &config, rndis_do_config);\n}\n\n#else\n\nstatic int rndis_config_register(struct usb_composite_dev *cdev)\n{\n\treturn 0;\n}\n\n#endif\n\n\n \n\n#ifdef CONFIG_USB_G_MULTI_CDC\nstatic struct usb_function_instance *fi_ecm;\nstatic struct usb_function *f_acm_multi;\nstatic struct usb_function *f_ecm;\nstatic struct usb_function *f_msg_multi;\n\nstatic int cdc_do_config(struct usb_configuration *c)\n{\n\tint ret;\n\n\tif (gadget_is_otg(c->cdev->gadget)) {\n\t\tc->descriptors = otg_desc;\n\t\tc->bmAttributes |= USB_CONFIG_ATT_WAKEUP;\n\t}\n\n\tf_ecm = usb_get_function(fi_ecm);\n\tif (IS_ERR(f_ecm))\n\t\treturn PTR_ERR(f_ecm);\n\n\tret = usb_add_function(c, f_ecm);\n\tif (ret < 0)\n\t\tgoto err_func_ecm;\n\n\t \n\tf_acm_multi = usb_get_function(fi_acm);\n\tif (IS_ERR(f_acm_multi)) {\n\t\tret = PTR_ERR(f_acm_multi);\n\t\tgoto err_func_acm;\n\t}\n\n\tret = usb_add_function(c, f_acm_multi);\n\tif (ret)\n\t\tgoto err_conf;\n\n\tf_msg_multi = usb_get_function(fi_msg);\n\tif (IS_ERR(f_msg_multi)) {\n\t\tret = PTR_ERR(f_msg_multi);\n\t\tgoto err_fsg;\n\t}\n\n\tret = usb_add_function(c, f_msg_multi);\n\tif (ret)\n\t\tgoto err_run;\n\n\treturn 0;\nerr_run:\n\tusb_put_function(f_msg_multi);\nerr_fsg:\n\tusb_remove_function(c, f_acm_multi);\nerr_conf:\n\tusb_put_function(f_acm_multi);\nerr_func_acm:\n\tusb_remove_function(c, f_ecm);\nerr_func_ecm:\n\tusb_put_function(f_ecm);\n\treturn ret;\n}\n\nstatic int cdc_config_register(struct usb_composite_dev *cdev)\n{\n\tstatic struct usb_configuration config = {\n\t\t.bConfigurationValue\t= MULTI_CDC_CONFIG_NUM,\n\t\t.bmAttributes\t\t= USB_CONFIG_ATT_SELFPOWER,\n\t};\n\n\tconfig.label          = strings_dev[MULTI_STRING_CDC_CONFIG_IDX].s;\n\tconfig.iConfiguration = strings_dev[MULTI_STRING_CDC_CONFIG_IDX].id;\n\n\treturn usb_add_config(cdev, &config, cdc_do_config);\n}\n\n#else\n\nstatic int cdc_config_register(struct usb_composite_dev *cdev)\n{\n\treturn 0;\n}\n\n#endif\n\n\n\n \n\nstatic int multi_bind(struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget *gadget = cdev->gadget;\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tstruct f_ecm_opts *ecm_opts;\n#endif\n#ifdef USB_ETH_RNDIS\n\tstruct f_rndis_opts *rndis_opts;\n#endif\n\tstruct fsg_opts *fsg_opts;\n\tstruct fsg_config config;\n\tint status;\n\n\tif (!can_support_ecm(cdev->gadget)) {\n\t\tdev_err(&gadget->dev, \"controller '%s' not usable\\n\",\n\t\t\tgadget->name);\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tfi_ecm = usb_get_function_instance(\"ecm\");\n\tif (IS_ERR(fi_ecm))\n\t\treturn PTR_ERR(fi_ecm);\n\n\tecm_opts = container_of(fi_ecm, struct f_ecm_opts, func_inst);\n\n\tgether_set_qmult(ecm_opts->net, qmult);\n\tif (!gether_set_host_addr(ecm_opts->net, host_addr))\n\t\tpr_info(\"using host ethernet address: %s\", host_addr);\n\tif (!gether_set_dev_addr(ecm_opts->net, dev_addr))\n\t\tpr_info(\"using self ethernet address: %s\", dev_addr);\n#endif\n\n#ifdef USB_ETH_RNDIS\n\tfi_rndis = usb_get_function_instance(\"rndis\");\n\tif (IS_ERR(fi_rndis)) {\n\t\tstatus = PTR_ERR(fi_rndis);\n\t\tgoto fail;\n\t}\n\n\trndis_opts = container_of(fi_rndis, struct f_rndis_opts, func_inst);\n\n\tgether_set_qmult(rndis_opts->net, qmult);\n\tif (!gether_set_host_addr(rndis_opts->net, host_addr))\n\t\tpr_info(\"using host ethernet address: %s\", host_addr);\n\tif (!gether_set_dev_addr(rndis_opts->net, dev_addr))\n\t\tpr_info(\"using self ethernet address: %s\", dev_addr);\n#endif\n\n#if (defined CONFIG_USB_G_MULTI_CDC && defined USB_ETH_RNDIS)\n\t \n\tgether_set_gadget(ecm_opts->net, cdev->gadget);\n\tstatus = gether_register_netdev(ecm_opts->net);\n\tif (status)\n\t\tgoto fail0;\n\n\trndis_borrow_net(fi_rndis, ecm_opts->net);\n\tecm_opts->bound = true;\n#endif\n\n\t \n\tfi_acm = usb_get_function_instance(\"acm\");\n\tif (IS_ERR(fi_acm)) {\n\t\tstatus = PTR_ERR(fi_acm);\n\t\tgoto fail0;\n\t}\n\n\t \n\tfi_msg = usb_get_function_instance(\"mass_storage\");\n\tif (IS_ERR(fi_msg)) {\n\t\tstatus = PTR_ERR(fi_msg);\n\t\tgoto fail1;\n\t}\n\tfsg_config_from_params(&config, &fsg_mod_data, fsg_num_buffers);\n\tfsg_opts = fsg_opts_from_func_inst(fi_msg);\n\n\tfsg_opts->no_configfs = true;\n\tstatus = fsg_common_set_num_buffers(fsg_opts->common, fsg_num_buffers);\n\tif (status)\n\t\tgoto fail2;\n\n\tstatus = fsg_common_set_cdev(fsg_opts->common, cdev, config.can_stall);\n\tif (status)\n\t\tgoto fail_set_cdev;\n\n\tfsg_common_set_sysfs(fsg_opts->common, true);\n\tstatus = fsg_common_create_luns(fsg_opts->common, &config);\n\tif (status)\n\t\tgoto fail_set_cdev;\n\n\tfsg_common_set_inquiry_string(fsg_opts->common, config.vendor_name,\n\t\t\t\t      config.product_name);\n\n\t \n\tstatus = usb_string_ids_tab(cdev, strings_dev);\n\tif (unlikely(status < 0))\n\t\tgoto fail_string_ids;\n\tdevice_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;\n\n\tif (gadget_is_otg(gadget) && !otg_desc[0]) {\n\t\tstruct usb_descriptor_header *usb_desc;\n\n\t\tusb_desc = usb_otg_descriptor_alloc(gadget);\n\t\tif (!usb_desc) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_string_ids;\n\t\t}\n\t\tusb_otg_descriptor_init(gadget, usb_desc);\n\t\totg_desc[0] = usb_desc;\n\t\totg_desc[1] = NULL;\n\t}\n\n\t \n\tstatus = rndis_config_register(cdev);\n\tif (unlikely(status < 0))\n\t\tgoto fail_otg_desc;\n\n\tstatus = cdc_config_register(cdev);\n\tif (unlikely(status < 0))\n\t\tgoto fail_otg_desc;\n\tusb_composite_overwrite_options(cdev, &coverwrite);\n\n\t \n\tdev_info(&gadget->dev, DRIVER_DESC \"\\n\");\n\treturn 0;\n\n\n\t \nfail_otg_desc:\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\nfail_string_ids:\n\tfsg_common_remove_luns(fsg_opts->common);\nfail_set_cdev:\n\tfsg_common_free_buffers(fsg_opts->common);\nfail2:\n\tusb_put_function_instance(fi_msg);\nfail1:\n\tusb_put_function_instance(fi_acm);\nfail0:\n#ifdef USB_ETH_RNDIS\n\tusb_put_function_instance(fi_rndis);\nfail:\n#endif\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tusb_put_function_instance(fi_ecm);\n#endif\n\treturn status;\n}\n\nstatic int multi_unbind(struct usb_composite_dev *cdev)\n{\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tusb_put_function(f_msg_multi);\n#endif\n#ifdef USB_ETH_RNDIS\n\tusb_put_function(f_msg_rndis);\n#endif\n\tusb_put_function_instance(fi_msg);\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tusb_put_function(f_acm_multi);\n#endif\n#ifdef USB_ETH_RNDIS\n\tusb_put_function(f_acm_rndis);\n#endif\n\tusb_put_function_instance(fi_acm);\n#ifdef USB_ETH_RNDIS\n\tusb_put_function(f_rndis);\n\tusb_put_function_instance(fi_rndis);\n#endif\n#ifdef CONFIG_USB_G_MULTI_CDC\n\tusb_put_function(f_ecm);\n\tusb_put_function_instance(fi_ecm);\n#endif\n\tkfree(otg_desc[0]);\n\totg_desc[0] = NULL;\n\n\treturn 0;\n}\n\n\n \n\n\nstatic struct usb_composite_driver multi_driver = {\n\t.name\t\t= \"g_multi\",\n\t.dev\t\t= &device_desc,\n\t.strings\t= dev_strings,\n\t.max_speed\t= USB_SPEED_SUPER,\n\t.bind\t\t= multi_bind,\n\t.unbind\t\t= multi_unbind,\n\t.needs_serial\t= 1,\n};\n\nmodule_usb_composite_driver(multi_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}