{
  "module_name": "c67x00-drv.c",
  "hash_id": "a26fadae946c48bb9b9cf3941894d3b99a133a9041e4a4e10482f140f0233c6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/c67x00/c67x00-drv.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/c67x00.h>\n\n#include \"c67x00.h\"\n#include \"c67x00-hcd.h\"\n\nstatic void c67x00_probe_sie(struct c67x00_sie *sie,\n\t\t\t     struct c67x00_device *dev, int sie_num)\n{\n\tspin_lock_init(&sie->lock);\n\tsie->dev = dev;\n\tsie->sie_num = sie_num;\n\tsie->mode = c67x00_sie_config(dev->pdata->sie_config, sie_num);\n\n\tswitch (sie->mode) {\n\tcase C67X00_SIE_HOST:\n\t\tc67x00_hcd_probe(sie);\n\t\tbreak;\n\n\tcase C67X00_SIE_UNUSED:\n\t\tdev_info(sie_dev(sie),\n\t\t\t \"Not using SIE %d as requested\\n\", sie->sie_num);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(sie_dev(sie),\n\t\t\t\"Unsupported configuration: 0x%x for SIE %d\\n\",\n\t\t\tsie->mode, sie->sie_num);\n\t\tbreak;\n\t}\n}\n\nstatic void c67x00_remove_sie(struct c67x00_sie *sie)\n{\n\tswitch (sie->mode) {\n\tcase C67X00_SIE_HOST:\n\t\tc67x00_hcd_remove(sie);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic irqreturn_t c67x00_irq(int irq, void *__dev)\n{\n\tstruct c67x00_device *c67x00 = __dev;\n\tstruct c67x00_sie *sie;\n\tu16 msg, int_status;\n\tint i, count = 8;\n\n\tint_status = c67x00_ll_hpi_status(c67x00);\n\tif (!int_status)\n\t\treturn IRQ_NONE;\n\n\twhile (int_status != 0 && (count-- >= 0)) {\n\t\tc67x00_ll_irq(c67x00, int_status);\n\t\tfor (i = 0; i < C67X00_SIES; i++) {\n\t\t\tsie = &c67x00->sie[i];\n\t\t\tmsg = 0;\n\t\t\tif (int_status & SIEMSG_FLG(i))\n\t\t\t\tmsg = c67x00_ll_fetch_siemsg(c67x00, i);\n\t\t\tif (sie->irq)\n\t\t\t\tsie->irq(sie, int_status, msg);\n\t\t}\n\t\tint_status = c67x00_ll_hpi_status(c67x00);\n\t}\n\n\tif (int_status)\n\t\tdev_warn(&c67x00->pdev->dev, \"Not all interrupts handled! \"\n\t\t\t \"status = 0x%04x\\n\", int_status);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int c67x00_drv_probe(struct platform_device *pdev)\n{\n\tstruct c67x00_device *c67x00;\n\tstruct c67x00_platform_data *pdata;\n\tstruct resource *res, *res2;\n\tint ret, i;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\tres2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!res2)\n\t\treturn -ENODEV;\n\n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata)\n\t\treturn -ENODEV;\n\n\tc67x00 = kzalloc(sizeof(*c67x00), GFP_KERNEL);\n\tif (!c67x00)\n\t\treturn -ENOMEM;\n\n\tif (!request_mem_region(res->start, resource_size(res),\n\t\t\t\tpdev->name)) {\n\t\tdev_err(&pdev->dev, \"Memory region busy\\n\");\n\t\tret = -EBUSY;\n\t\tgoto request_mem_failed;\n\t}\n\tc67x00->hpi.base = ioremap(res->start, resource_size(res));\n\tif (!c67x00->hpi.base) {\n\t\tdev_err(&pdev->dev, \"Unable to map HPI registers\\n\");\n\t\tret = -EIO;\n\t\tgoto map_failed;\n\t}\n\n\tspin_lock_init(&c67x00->hpi.lock);\n\tc67x00->hpi.regstep = pdata->hpi_regstep;\n\tc67x00->pdata = dev_get_platdata(&pdev->dev);\n\tc67x00->pdev = pdev;\n\n\tc67x00_ll_init(c67x00);\n\tc67x00_ll_hpi_reg_init(c67x00);\n\n\tret = request_irq(res2->start, c67x00_irq, 0, pdev->name, c67x00);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot claim IRQ\\n\");\n\t\tgoto request_irq_failed;\n\t}\n\n\tret = c67x00_ll_reset(c67x00);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Device reset failed\\n\");\n\t\tgoto reset_failed;\n\t}\n\n\tfor (i = 0; i < C67X00_SIES; i++)\n\t\tc67x00_probe_sie(&c67x00->sie[i], c67x00, i);\n\n\tplatform_set_drvdata(pdev, c67x00);\n\n\treturn 0;\n\n reset_failed:\n\tfree_irq(res2->start, c67x00);\n request_irq_failed:\n\tiounmap(c67x00->hpi.base);\n map_failed:\n\trelease_mem_region(res->start, resource_size(res));\n request_mem_failed:\n\tkfree(c67x00);\n\n\treturn ret;\n}\n\nstatic void c67x00_drv_remove(struct platform_device *pdev)\n{\n\tstruct c67x00_device *c67x00 = platform_get_drvdata(pdev);\n\tstruct resource *res;\n\tint i;\n\n\tfor (i = 0; i < C67X00_SIES; i++)\n\t\tc67x00_remove_sie(&c67x00->sie[i]);\n\n\tc67x00_ll_release(c67x00);\n\n\tres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tfree_irq(res->start, c67x00);\n\n\tiounmap(c67x00->hpi.base);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(res->start, resource_size(res));\n\n\tkfree(c67x00);\n}\n\nstatic struct platform_driver c67x00_driver = {\n\t.probe\t= c67x00_drv_probe,\n\t.remove_new = c67x00_drv_remove,\n\t.driver\t= {\n\t\t.name = \"c67x00\",\n\t},\n};\n\nmodule_platform_driver(c67x00_driver);\n\nMODULE_AUTHOR(\"Peter Korsgaard, Jan Veldeman, Grant Likely\");\nMODULE_DESCRIPTION(\"Cypress C67X00 USB Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:c67x00\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}