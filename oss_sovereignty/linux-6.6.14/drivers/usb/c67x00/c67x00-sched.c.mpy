{
  "module_name": "c67x00-sched.c",
  "hash_id": "27b0ab47c852ae2a62e914d802b004bdf41e96baf514c9b5e11b8f75a1ca92b2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/c67x00/c67x00-sched.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/slab.h>\n\n#include \"c67x00.h\"\n#include \"c67x00-hcd.h\"\n\n \n#define SETUP_STAGE\t\t0\n#define DATA_STAGE\t\t1\n#define STATUS_STAGE\t\t2\n\n \n\n \nstruct c67x00_ep_data {\n\tstruct list_head queue;\n\tstruct list_head node;\n\tstruct usb_host_endpoint *hep;\n\tstruct usb_device *dev;\n\tu16 next_frame;\t\t \n};\n\n \nstruct c67x00_td {\n\t \n\t__le16 ly_base_addr;\t \n\t__le16 port_length;\t \n\tu8 pid_ep;\t\t \n\tu8 dev_addr;\t\t \n\tu8 ctrl_reg;\t\t \n\tu8 status;\t\t \n\tu8 retry_cnt;\t\t \n#define TT_OFFSET\t\t2\n#define TT_CONTROL\t\t0\n#define TT_ISOCHRONOUS\t\t1\n#define TT_BULK\t\t\t2\n#define TT_INTERRUPT\t\t3\n\tu8 residue;\t\t \n\t__le16 next_td_addr;\t \n\t \n\tstruct list_head td_list;\n\tu16 td_addr;\n\tvoid *data;\n\tstruct urb *urb;\n\tunsigned long privdata;\n\n\t \n\tstruct c67x00_ep_data *ep_data;\n\tunsigned int pipe;\n};\n\nstruct c67x00_urb_priv {\n\tstruct list_head hep_node;\n\tstruct urb *urb;\n\tint port;\n\tint cnt;\t\t \n\tint status;\n\tstruct c67x00_ep_data *ep_data;\n};\n\n#define td_udev(td)\t((td)->ep_data->dev)\n\n#define CY_TD_SIZE\t\t12\n\n#define TD_PIDEP_OFFSET\t\t0x04\n#define TD_PIDEPMASK_PID\t0xF0\n#define TD_PIDEPMASK_EP\t\t0x0F\n#define TD_PORTLENMASK_DL\t0x03FF\n#define TD_PORTLENMASK_PN\t0xC000\n\n#define TD_STATUS_OFFSET\t0x07\n#define TD_STATUSMASK_ACK\t0x01\n#define TD_STATUSMASK_ERR\t0x02\n#define TD_STATUSMASK_TMOUT\t0x04\n#define TD_STATUSMASK_SEQ\t0x08\n#define TD_STATUSMASK_SETUP\t0x10\n#define TD_STATUSMASK_OVF\t0x20\n#define TD_STATUSMASK_NAK\t0x40\n#define TD_STATUSMASK_STALL\t0x80\n\n#define TD_ERROR_MASK\t\t(TD_STATUSMASK_ERR | TD_STATUSMASK_TMOUT | \\\n\t\t\t\t TD_STATUSMASK_STALL)\n\n#define TD_RETRYCNT_OFFSET\t0x08\n#define TD_RETRYCNTMASK_ACT_FLG\t0x10\n#define TD_RETRYCNTMASK_TX_TYPE\t0x0C\n#define TD_RETRYCNTMASK_RTY_CNT\t0x03\n\n#define TD_RESIDUE_OVERFLOW\t0x80\n\n#define TD_PID_IN\t\t0x90\n\n \n#define td_residue(td)\t\t((__s8)(td->residue))\n#define td_ly_base_addr(td)\t(__le16_to_cpu((td)->ly_base_addr))\n#define td_port_length(td)\t(__le16_to_cpu((td)->port_length))\n#define td_next_td_addr(td)\t(__le16_to_cpu((td)->next_td_addr))\n\n#define td_active(td)\t\t((td)->retry_cnt & TD_RETRYCNTMASK_ACT_FLG)\n#define td_length(td)\t\t(td_port_length(td) & TD_PORTLENMASK_DL)\n\n#define td_sequence_ok(td)\t(!td->status || \\\n\t\t\t\t (!(td->status & TD_STATUSMASK_SEQ) ==\t\\\n\t\t\t\t  !(td->ctrl_reg & SEQ_SEL)))\n\n#define td_acked(td)\t\t(!td->status || \\\n\t\t\t\t (td->status & TD_STATUSMASK_ACK))\n#define td_actual_bytes(td)\t(td_length(td) - td_residue(td))\n\n \n\n \nstatic void dbg_td(struct c67x00_hcd *c67x00, struct c67x00_td *td, char *msg)\n{\n\tstruct device *dev = c67x00_hcd_dev(c67x00);\n\n\tdev_dbg(dev, \"### %s at 0x%04x\\n\", msg, td->td_addr);\n\tdev_dbg(dev, \"urb:      0x%p\\n\", td->urb);\n\tdev_dbg(dev, \"endpoint:   %4d\\n\", usb_pipeendpoint(td->pipe));\n\tdev_dbg(dev, \"pipeout:    %4d\\n\", usb_pipeout(td->pipe));\n\tdev_dbg(dev, \"ly_base_addr: 0x%04x\\n\", td_ly_base_addr(td));\n\tdev_dbg(dev, \"port_length:  0x%04x\\n\", td_port_length(td));\n\tdev_dbg(dev, \"pid_ep:         0x%02x\\n\", td->pid_ep);\n\tdev_dbg(dev, \"dev_addr:       0x%02x\\n\", td->dev_addr);\n\tdev_dbg(dev, \"ctrl_reg:       0x%02x\\n\", td->ctrl_reg);\n\tdev_dbg(dev, \"status:         0x%02x\\n\", td->status);\n\tdev_dbg(dev, \"retry_cnt:      0x%02x\\n\", td->retry_cnt);\n\tdev_dbg(dev, \"residue:        0x%02x\\n\", td->residue);\n\tdev_dbg(dev, \"next_td_addr: 0x%04x\\n\", td_next_td_addr(td));\n\tdev_dbg(dev, \"data: %*ph\\n\", td_length(td), td->data);\n}\n\n \n \n\nstatic inline u16 c67x00_get_current_frame_number(struct c67x00_hcd *c67x00)\n{\n\treturn c67x00_ll_husb_get_frame(c67x00->sie) & HOST_FRAME_MASK;\n}\n\n \nstatic inline u16 frame_add(u16 a, u16 b)\n{\n\treturn (a + b) & HOST_FRAME_MASK;\n}\n\n \nstatic inline int frame_after(u16 a, u16 b)\n{\n\treturn ((HOST_FRAME_MASK + a - b) & HOST_FRAME_MASK) <\n\t    (HOST_FRAME_MASK / 2);\n}\n\n \nstatic inline int frame_after_eq(u16 a, u16 b)\n{\n\treturn ((HOST_FRAME_MASK + 1 + a - b) & HOST_FRAME_MASK) <\n\t    (HOST_FRAME_MASK / 2);\n}\n\n \n\n \nstatic void c67x00_release_urb(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tstruct c67x00_td *td;\n\tstruct c67x00_urb_priv *urbp;\n\n\tBUG_ON(!urb);\n\n\tc67x00->urb_count--;\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\tc67x00->urb_iso_count--;\n\t\tif (c67x00->urb_iso_count == 0)\n\t\t\tc67x00->max_frame_bw = MAX_FRAME_BW_STD;\n\t}\n\n\t \n\tlist_for_each_entry(td, &c67x00->td_list, td_list)\n\t\tif (urb == td->urb)\n\t\t\ttd->urb = NULL;\n\n\turbp = urb->hcpriv;\n\turb->hcpriv = NULL;\n\tlist_del(&urbp->hep_node);\n\tkfree(urbp);\n}\n\n \n\nstatic struct c67x00_ep_data *\nc67x00_ep_data_alloc(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tstruct usb_host_endpoint *hep = urb->ep;\n\tstruct c67x00_ep_data *ep_data;\n\tint type;\n\n\tc67x00->current_frame = c67x00_get_current_frame_number(c67x00);\n\n\t \n\tif (hep->hcpriv) {\n\t\tep_data = hep->hcpriv;\n\t\tif (frame_after(c67x00->current_frame, ep_data->next_frame))\n\t\t\tep_data->next_frame =\n\t\t\t    frame_add(c67x00->current_frame, 1);\n\t\treturn hep->hcpriv;\n\t}\n\n\t \n\tep_data = kzalloc(sizeof(*ep_data), GFP_ATOMIC);\n\tif (!ep_data)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ep_data->queue);\n\tINIT_LIST_HEAD(&ep_data->node);\n\tep_data->hep = hep;\n\n\t \n\tep_data->dev = usb_get_dev(urb->dev);\n\thep->hcpriv = ep_data;\n\n\t \n\tep_data->next_frame = frame_add(c67x00->current_frame, 1);\n\n\t \n\ttype = usb_pipetype(urb->pipe);\n\tif (list_empty(&ep_data->node)) {\n\t\tlist_add(&ep_data->node, &c67x00->list[type]);\n\t} else {\n\t\tstruct c67x00_ep_data *prev;\n\n\t\tlist_for_each_entry(prev, &c67x00->list[type], node) {\n\t\t\tif (prev->hep->desc.bEndpointAddress >\n\t\t\t    hep->desc.bEndpointAddress) {\n\t\t\t\tlist_add(&ep_data->node, prev->node.prev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ep_data;\n}\n\nstatic int c67x00_ep_data_free(struct usb_host_endpoint *hep)\n{\n\tstruct c67x00_ep_data *ep_data = hep->hcpriv;\n\n\tif (!ep_data)\n\t\treturn 0;\n\n\tif (!list_empty(&ep_data->queue))\n\t\treturn -EBUSY;\n\n\tusb_put_dev(ep_data->dev);\n\tlist_del(&ep_data->queue);\n\tlist_del(&ep_data->node);\n\n\tkfree(ep_data);\n\thep->hcpriv = NULL;\n\n\treturn 0;\n}\n\nvoid c67x00_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tunsigned long flags;\n\n\tif (!list_empty(&ep->urb_list))\n\t\tdev_warn(c67x00_hcd_dev(c67x00), \"error: urb list not empty\\n\");\n\n\tspin_lock_irqsave(&c67x00->lock, flags);\n\n\t \n\twhile (c67x00_ep_data_free(ep)) {\n\t\t \n\t\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\n\t\t \n\t\treinit_completion(&c67x00->endpoint_disable);\n\t\tc67x00_sched_kick(c67x00);\n\t\twait_for_completion_timeout(&c67x00->endpoint_disable, 1 * HZ);\n\n\t\tspin_lock_irqsave(&c67x00->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n}\n\n \n\nstatic inline int get_root_port(struct usb_device *dev)\n{\n\twhile (dev->parent->parent)\n\t\tdev = dev->parent;\n\treturn dev->portnum;\n}\n\nint c67x00_urb_enqueue(struct usb_hcd *hcd,\n\t\t       struct urb *urb, gfp_t mem_flags)\n{\n\tint ret;\n\tunsigned long flags;\n\tstruct c67x00_urb_priv *urbp;\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tint port = get_root_port(urb->dev)-1;\n\n\t \n\turbp = kzalloc(sizeof(*urbp), mem_flags);\n\tif (!urbp) {\n\t\tret = -ENOMEM;\n\t\tgoto err_urbp;\n\t}\n\n\tspin_lock_irqsave(&c67x00->lock, flags);\n\n\t \n\tif (!HC_IS_RUNNING(hcd->state)) {\n\t\tret = -ENODEV;\n\t\tgoto err_not_linked;\n\t}\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret)\n\t\tgoto err_not_linked;\n\n\tINIT_LIST_HEAD(&urbp->hep_node);\n\turbp->urb = urb;\n\turbp->port = port;\n\n\turbp->ep_data = c67x00_ep_data_alloc(c67x00, urb);\n\n\tif (!urbp->ep_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err_epdata;\n\t}\n\n\t \n\n\turb->hcpriv = urbp;\n\n\turb->actual_length = 0;\t \n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\turb->interval = SETUP_STAGE;\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (c67x00->urb_iso_count == 0)\n\t\t\tc67x00->max_frame_bw = MAX_FRAME_BW_ISO;\n\t\tc67x00->urb_iso_count++;\n\t\t \n\t\tif (list_empty(&urbp->ep_data->queue))\n\t\t\turb->start_frame = urbp->ep_data->next_frame;\n\t\telse {\n\t\t\t \n\t\t\tstruct urb *last_urb;\n\n\t\t\tlast_urb = list_entry(urbp->ep_data->queue.prev,\n\t\t\t\t\t      struct c67x00_urb_priv,\n\t\t\t\t\t      hep_node)->urb;\n\t\t\turb->start_frame =\n\t\t\t    frame_add(last_urb->start_frame,\n\t\t\t\t      last_urb->number_of_packets *\n\t\t\t\t      last_urb->interval);\n\t\t}\n\t\turbp->cnt = 0;\n\t\tbreak;\n\t}\n\n\t \n\tlist_add_tail(&urbp->hep_node, &urbp->ep_data->queue);\n\n\t \n\tif (!c67x00->urb_count++)\n\t\tc67x00_ll_hpi_enable_sofeop(c67x00->sie);\n\n\tc67x00_sched_kick(c67x00);\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\n\treturn 0;\n\nerr_epdata:\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\nerr_not_linked:\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\tkfree(urbp);\nerr_urbp:\n\n\treturn ret;\n}\n\nint c67x00_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&c67x00->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tc67x00_release_urb(c67x00, urb);\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\n\tspin_unlock(&c67x00->lock);\n\tusb_hcd_giveback_urb(hcd, urb, status);\n\tspin_lock(&c67x00->lock);\n\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\n\treturn 0;\n\n done:\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\treturn rc;\n}\n\n \n\n \nstatic void\nc67x00_giveback_urb(struct c67x00_hcd *c67x00, struct urb *urb, int status)\n{\n\tstruct c67x00_urb_priv *urbp;\n\n\tif (!urb)\n\t\treturn;\n\n\turbp = urb->hcpriv;\n\turbp->status = status;\n\n\tlist_del_init(&urbp->hep_node);\n\n\tc67x00_release_urb(c67x00, urb);\n\tusb_hcd_unlink_urb_from_ep(c67x00_hcd_to_hcd(c67x00), urb);\n\tspin_unlock(&c67x00->lock);\n\tusb_hcd_giveback_urb(c67x00_hcd_to_hcd(c67x00), urb, status);\n\tspin_lock(&c67x00->lock);\n}\n\n \n\nstatic int c67x00_claim_frame_bw(struct c67x00_hcd *c67x00, struct urb *urb,\n\t\t\t\t int len, int periodic)\n{\n\tstruct c67x00_urb_priv *urbp = urb->hcpriv;\n\tint bit_time;\n\n\t \n\n\t \n\tif (urbp->ep_data->dev->speed == USB_SPEED_LOW) {\n\t\t \n\t\tif (usb_pipein(urb->pipe))\n\t\t\tbit_time = 80240 + 7578*len;\n\t\telse\n\t\t\tbit_time = 80260 + 7467*len;\n\t} else {\n\t\t \n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tbit_time = usb_pipein(urb->pipe) ? 9050 : 7840;\n\t\telse\n\t\t\tbit_time = 11250;\n\t\tbit_time += 936*len;\n\t}\n\n\t \n\tbit_time = ((bit_time+50) / 100) + 106;\n\n\tif (unlikely(bit_time + c67x00->bandwidth_allocated >=\n\t\t     c67x00->max_frame_bw))\n\t\treturn -EMSGSIZE;\n\n\tif (unlikely(c67x00->next_td_addr + CY_TD_SIZE >=\n\t\t     c67x00->td_base_addr + SIE_TD_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (unlikely(c67x00->next_buf_addr + len >=\n\t\t     c67x00->buf_base_addr + SIE_TD_BUF_SIZE))\n\t\treturn -EMSGSIZE;\n\n\tif (periodic) {\n\t\tif (unlikely(bit_time + c67x00->periodic_bw_allocated >=\n\t\t\t     MAX_PERIODIC_BW(c67x00->max_frame_bw)))\n\t\t\treturn -EMSGSIZE;\n\t\tc67x00->periodic_bw_allocated += bit_time;\n\t}\n\n\tc67x00->bandwidth_allocated += bit_time;\n\treturn 0;\n}\n\n \n\n \nstatic int c67x00_create_td(struct c67x00_hcd *c67x00, struct urb *urb,\n\t\t\t    void *data, int len, int pid, int toggle,\n\t\t\t    unsigned long privdata)\n{\n\tstruct c67x00_td *td;\n\tstruct c67x00_urb_priv *urbp = urb->hcpriv;\n\tconst __u8 active_flag = 1, retry_cnt = 3;\n\t__u8 cmd = 0;\n\tint tt = 0;\n\n\tif (c67x00_claim_frame_bw(c67x00, urb, len, usb_pipeisoc(urb->pipe)\n\t\t\t\t  || usb_pipeint(urb->pipe)))\n\t\treturn -EMSGSIZE;\t \n\n\ttd = kzalloc(sizeof(*td), GFP_ATOMIC);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\ttd->pipe = urb->pipe;\n\ttd->ep_data = urbp->ep_data;\n\n\tif ((td_udev(td)->speed == USB_SPEED_LOW) &&\n\t    !(c67x00->low_speed_ports & (1 << urbp->port)))\n\t\tcmd |= PREAMBLE_EN;\n\n\tswitch (usb_pipetype(td->pipe)) {\n\tcase PIPE_ISOCHRONOUS:\n\t\ttt = TT_ISOCHRONOUS;\n\t\tcmd |= ISO_EN;\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\ttt = TT_CONTROL;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\ttt = TT_BULK;\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\ttt = TT_INTERRUPT;\n\t\tbreak;\n\t}\n\n\tif (toggle)\n\t\tcmd |= SEQ_SEL;\n\n\tcmd |= ARM_EN;\n\n\t \n\ttd->td_addr = c67x00->next_td_addr;\n\tc67x00->next_td_addr = c67x00->next_td_addr + CY_TD_SIZE;\n\n\t \n\ttd->ly_base_addr = __cpu_to_le16(c67x00->next_buf_addr);\n\ttd->port_length = __cpu_to_le16((c67x00->sie->sie_num << 15) |\n\t\t\t\t\t(urbp->port << 14) | (len & 0x3FF));\n\ttd->pid_ep = ((pid & 0xF) << TD_PIDEP_OFFSET) |\n\t    (usb_pipeendpoint(td->pipe) & 0xF);\n\ttd->dev_addr = usb_pipedevice(td->pipe) & 0x7F;\n\ttd->ctrl_reg = cmd;\n\ttd->status = 0;\n\ttd->retry_cnt = (tt << TT_OFFSET) | (active_flag << 4) | retry_cnt;\n\ttd->residue = 0;\n\ttd->next_td_addr = __cpu_to_le16(c67x00->next_td_addr);\n\n\t \n\ttd->data = data;\n\ttd->urb = urb;\n\ttd->privdata = privdata;\n\n\tc67x00->next_buf_addr += (len + 1) & ~0x01;\t \n\n\tlist_add_tail(&td->td_list, &c67x00->td_list);\n\treturn 0;\n}\n\nstatic inline void c67x00_release_td(struct c67x00_td *td)\n{\n\tlist_del_init(&td->td_list);\n\tkfree(td);\n}\n\n \n\nstatic int c67x00_add_data_urb(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tint remaining;\n\tint toggle;\n\tint pid;\n\tint ret = 0;\n\tint maxps;\n\tint need_empty;\n\n\ttoggle = usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t       usb_pipeout(urb->pipe));\n\tremaining = urb->transfer_buffer_length - urb->actual_length;\n\n\tmaxps = usb_maxpacket(urb->dev, urb->pipe);\n\n\tneed_empty = (urb->transfer_flags & URB_ZERO_PACKET) &&\n\t    usb_pipeout(urb->pipe) && !(remaining % maxps);\n\n\twhile (remaining || need_empty) {\n\t\tint len;\n\t\tchar *td_buf;\n\n\t\tlen = (remaining > maxps) ? maxps : remaining;\n\t\tif (!len)\n\t\t\tneed_empty = 0;\n\n\t\tpid = usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\n\t\ttd_buf = urb->transfer_buffer + urb->transfer_buffer_length -\n\t\t    remaining;\n\t\tret = c67x00_create_td(c67x00, urb, td_buf, len, pid, toggle,\n\t\t\t\t       DATA_STAGE);\n\t\tif (ret)\n\t\t\treturn ret;\t \n\n\t\ttoggle ^= 1;\n\t\tremaining -= len;\n\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int c67x00_add_ctrl_urb(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tint ret;\n\tint pid;\n\n\tswitch (urb->interval) {\n\tdefault:\n\tcase SETUP_STAGE:\n\t\tret = c67x00_create_td(c67x00, urb, urb->setup_packet,\n\t\t\t\t       8, USB_PID_SETUP, 0, SETUP_STAGE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\turb->interval = SETUP_STAGE;\n\t\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t      usb_pipeout(urb->pipe), 1);\n\t\tbreak;\n\tcase DATA_STAGE:\n\t\tif (urb->transfer_buffer_length) {\n\t\t\tret = c67x00_add_data_urb(c67x00, urb);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase STATUS_STAGE:\n\t\tpid = !usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\n\t\tret = c67x00_create_td(c67x00, urb, NULL, 0, pid, 1,\n\t\t\t\t       STATUS_STAGE);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int c67x00_add_int_urb(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tstruct c67x00_urb_priv *urbp = urb->hcpriv;\n\n\tif (frame_after_eq(c67x00->current_frame, urbp->ep_data->next_frame)) {\n\t\turbp->ep_data->next_frame =\n\t\t    frame_add(urbp->ep_data->next_frame, urb->interval);\n\t\treturn c67x00_add_data_urb(c67x00, urb);\n\t}\n\treturn 0;\n}\n\nstatic int c67x00_add_iso_urb(struct c67x00_hcd *c67x00, struct urb *urb)\n{\n\tstruct c67x00_urb_priv *urbp = urb->hcpriv;\n\n\tif (frame_after_eq(c67x00->current_frame, urbp->ep_data->next_frame)) {\n\t\tchar *td_buf;\n\t\tint len, pid, ret;\n\n\t\tBUG_ON(urbp->cnt >= urb->number_of_packets);\n\n\t\ttd_buf = urb->transfer_buffer +\n\t\t    urb->iso_frame_desc[urbp->cnt].offset;\n\t\tlen = urb->iso_frame_desc[urbp->cnt].length;\n\t\tpid = usb_pipeout(urb->pipe) ? USB_PID_OUT : USB_PID_IN;\n\n\t\tret = c67x00_create_td(c67x00, urb, td_buf, len, pid, 0,\n\t\t\t\t       urbp->cnt);\n\t\tif (ret) {\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00), \"create failed: %d\\n\",\n\t\t\t\tret);\n\t\t\turb->iso_frame_desc[urbp->cnt].actual_length = 0;\n\t\t\turb->iso_frame_desc[urbp->cnt].status = ret;\n\t\t\tif (urbp->cnt + 1 == urb->number_of_packets)\n\t\t\t\tc67x00_giveback_urb(c67x00, urb, 0);\n\t\t}\n\n\t\turbp->ep_data->next_frame =\n\t\t    frame_add(urbp->ep_data->next_frame, urb->interval);\n\t\turbp->cnt++;\n\t}\n\treturn 0;\n}\n\n \n\nstatic void c67x00_fill_from_list(struct c67x00_hcd *c67x00, int type,\n\t\t\t\t  int (*add)(struct c67x00_hcd *, struct urb *))\n{\n\tstruct c67x00_ep_data *ep_data;\n\tstruct urb *urb;\n\n\t \n\tlist_for_each_entry(ep_data, &c67x00->list[type], node) {\n\t\tif (!list_empty(&ep_data->queue)) {\n\t\t\t \n\t\t\t \n\t\t\turb = list_entry(ep_data->queue.next,\n\t\t\t\t\t struct c67x00_urb_priv,\n\t\t\t\t\t hep_node)->urb;\n\t\t\tadd(c67x00, urb);\n\t\t}\n\t}\n}\n\nstatic void c67x00_fill_frame(struct c67x00_hcd *c67x00)\n{\n\tstruct c67x00_td *td, *ttd;\n\n\t \n\tif (!list_empty(&c67x00->td_list)) {\n\t\tdev_warn(c67x00_hcd_dev(c67x00),\n\t\t\t \"TD list not empty! This should not happen!\\n\");\n\t\tlist_for_each_entry_safe(td, ttd, &c67x00->td_list, td_list) {\n\t\t\tdbg_td(c67x00, td, \"Unprocessed td\");\n\t\t\tc67x00_release_td(td);\n\t\t}\n\t}\n\n\t \n\tc67x00->bandwidth_allocated = 0;\n\tc67x00->periodic_bw_allocated = 0;\n\n\tc67x00->next_td_addr = c67x00->td_base_addr;\n\tc67x00->next_buf_addr = c67x00->buf_base_addr;\n\n\t \n\tc67x00_fill_from_list(c67x00, PIPE_ISOCHRONOUS, c67x00_add_iso_urb);\n\tc67x00_fill_from_list(c67x00, PIPE_INTERRUPT, c67x00_add_int_urb);\n\tc67x00_fill_from_list(c67x00, PIPE_CONTROL, c67x00_add_ctrl_urb);\n\tc67x00_fill_from_list(c67x00, PIPE_BULK, c67x00_add_data_urb);\n}\n\n \n\n \nstatic inline void\nc67x00_parse_td(struct c67x00_hcd *c67x00, struct c67x00_td *td)\n{\n\tc67x00_ll_read_mem_le16(c67x00->sie->dev,\n\t\t\t\ttd->td_addr, td, CY_TD_SIZE);\n\n\tif (usb_pipein(td->pipe) && td_actual_bytes(td))\n\t\tc67x00_ll_read_mem_le16(c67x00->sie->dev, td_ly_base_addr(td),\n\t\t\t\t\ttd->data, td_actual_bytes(td));\n}\n\nstatic int c67x00_td_to_error(struct c67x00_hcd *c67x00, struct c67x00_td *td)\n{\n\tif (td->status & TD_STATUSMASK_ERR) {\n\t\tdbg_td(c67x00, td, \"ERROR_FLAG\");\n\t\treturn -EILSEQ;\n\t}\n\tif (td->status & TD_STATUSMASK_STALL) {\n\t\t \n\t\treturn -EPIPE;\n\t}\n\tif (td->status & TD_STATUSMASK_TMOUT) {\n\t\tdbg_td(c67x00, td, \"TIMEOUT\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int c67x00_end_of_data(struct c67x00_td *td)\n{\n\tint maxps, need_empty, remaining;\n\tstruct urb *urb = td->urb;\n\tint act_bytes;\n\n\tact_bytes = td_actual_bytes(td);\n\n\tif (unlikely(!act_bytes))\n\t\treturn 1;\t \n\n\tmaxps = usb_maxpacket(td_udev(td), td->pipe);\n\n\tif (unlikely(act_bytes < maxps))\n\t\treturn 1;\t \n\n\tremaining = urb->transfer_buffer_length - urb->actual_length;\n\tneed_empty = (urb->transfer_flags & URB_ZERO_PACKET) &&\n\t    usb_pipeout(urb->pipe) && !(remaining % maxps);\n\n\tif (unlikely(!remaining && !need_empty))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \n\n \nstatic inline void c67x00_clear_pipe(struct c67x00_hcd *c67x00,\n\t\t\t\t     struct c67x00_td *last_td)\n{\n\tstruct c67x00_td *td, *tmp;\n\ttd = last_td;\n\ttmp = last_td;\n\twhile (td->td_list.next != &c67x00->td_list) {\n\t\ttd = list_entry(td->td_list.next, struct c67x00_td, td_list);\n\t\tif (td->pipe == last_td->pipe) {\n\t\t\tc67x00_release_td(td);\n\t\t\ttd = tmp;\n\t\t}\n\t\ttmp = td;\n\t}\n}\n\n \n\nstatic void c67x00_handle_successful_td(struct c67x00_hcd *c67x00,\n\t\t\t\t\tstruct c67x00_td *td)\n{\n\tstruct urb *urb = td->urb;\n\n\tif (!urb)\n\t\treturn;\n\n\turb->actual_length += td_actual_bytes(td);\n\n\tswitch (usb_pipetype(td->pipe)) {\n\t\t \n\tcase PIPE_CONTROL:\n\t\tswitch (td->privdata) {\n\t\tcase SETUP_STAGE:\n\t\t\turb->interval =\n\t\t\t    urb->transfer_buffer_length ?\n\t\t\t    DATA_STAGE : STATUS_STAGE;\n\t\t\t \n\t\t\turb->actual_length = 0;\n\t\t\tbreak;\n\n\t\tcase DATA_STAGE:\n\t\t\tif (c67x00_end_of_data(td)) {\n\t\t\t\turb->interval = STATUS_STAGE;\n\t\t\t\tc67x00_clear_pipe(c67x00, td);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase STATUS_STAGE:\n\t\t\turb->interval = 0;\n\t\t\tc67x00_giveback_urb(c67x00, urb, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase PIPE_INTERRUPT:\n\tcase PIPE_BULK:\n\t\tif (unlikely(c67x00_end_of_data(td))) {\n\t\t\tc67x00_clear_pipe(c67x00, td);\n\t\t\tc67x00_giveback_urb(c67x00, urb, 0);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void c67x00_handle_isoc(struct c67x00_hcd *c67x00, struct c67x00_td *td)\n{\n\tstruct urb *urb = td->urb;\n\tint cnt;\n\n\tif (!urb)\n\t\treturn;\n\n\tcnt = td->privdata;\n\n\tif (td->status & TD_ERROR_MASK)\n\t\turb->error_count++;\n\n\turb->iso_frame_desc[cnt].actual_length = td_actual_bytes(td);\n\turb->iso_frame_desc[cnt].status = c67x00_td_to_error(c67x00, td);\n\tif (cnt + 1 == urb->number_of_packets)\t \n\t\tc67x00_giveback_urb(c67x00, urb, 0);\n}\n\n \n\n \nstatic inline void c67x00_check_td_list(struct c67x00_hcd *c67x00)\n{\n\tstruct c67x00_td *td, *tmp;\n\tstruct urb *urb;\n\tint ack_ok;\n\tint clear_endpoint;\n\n\tlist_for_each_entry_safe(td, tmp, &c67x00->td_list, td_list) {\n\t\t \n\t\tc67x00_parse_td(c67x00, td);\n\t\turb = td->urb;\t \n\t\tack_ok = 0;\n\t\tclear_endpoint = 1;\n\n\t\t \n\t\tif (usb_pipeisoc(td->pipe)) {\n\t\t\tclear_endpoint = 0;\n\t\t\tc67x00_handle_isoc(c67x00, td);\n\t\t\tgoto cont;\n\t\t}\n\n\t\t \n\t\tif (td->status & TD_ERROR_MASK) {\n\t\t\tc67x00_giveback_urb(c67x00, urb,\n\t\t\t\t\t    c67x00_td_to_error(c67x00, td));\n\t\t\tgoto cont;\n\t\t}\n\n\t\tif ((td->status & TD_STATUSMASK_NAK) || !td_sequence_ok(td) ||\n\t\t    !td_acked(td))\n\t\t\tgoto cont;\n\n\t\t \n\t\tack_ok = 1;\n\n\t\tif (unlikely(td->status & TD_STATUSMASK_OVF)) {\n\t\t\tif (td_residue(td) & TD_RESIDUE_OVERFLOW) {\n\t\t\t\t \n\t\t\t\tc67x00_giveback_urb(c67x00, urb, -EOVERFLOW);\n\t\t\t\tgoto cont;\n\t\t\t}\n\t\t}\n\n\t\tclear_endpoint = 0;\n\t\tc67x00_handle_successful_td(c67x00, td);\n\ncont:\n\t\tif (clear_endpoint)\n\t\t\tc67x00_clear_pipe(c67x00, td);\n\t\tif (ack_ok)\n\t\t\tusb_settoggle(td_udev(td), usb_pipeendpoint(td->pipe),\n\t\t\t\t      usb_pipeout(td->pipe),\n\t\t\t\t      !(td->ctrl_reg & SEQ_SEL));\n\t\t \n\t\ttmp = list_entry(td->td_list.next, typeof(*td), td_list);\n\t\tc67x00_release_td(td);\n\t}\n}\n\n \n\nstatic inline int c67x00_all_tds_processed(struct c67x00_hcd *c67x00)\n{\n\t \n\treturn !c67x00_ll_husb_get_current_td(c67x00->sie);\n}\n\n \nstatic void c67x00_send_td(struct c67x00_hcd *c67x00, struct c67x00_td *td)\n{\n\tint len = td_length(td);\n\n\tif (len && ((td->pid_ep & TD_PIDEPMASK_PID) != TD_PID_IN))\n\t\tc67x00_ll_write_mem_le16(c67x00->sie->dev, td_ly_base_addr(td),\n\t\t\t\t\t td->data, len);\n\n\tc67x00_ll_write_mem_le16(c67x00->sie->dev,\n\t\t\t\t td->td_addr, td, CY_TD_SIZE);\n}\n\nstatic void c67x00_send_frame(struct c67x00_hcd *c67x00)\n{\n\tstruct c67x00_td *td;\n\n\tif (list_empty(&c67x00->td_list))\n\t\tdev_warn(c67x00_hcd_dev(c67x00),\n\t\t\t \"%s: td list should not be empty here!\\n\",\n\t\t\t __func__);\n\n\tlist_for_each_entry(td, &c67x00->td_list, td_list) {\n\t\tif (td->td_list.next == &c67x00->td_list)\n\t\t\ttd->next_td_addr = 0;\t \n\n\t\tc67x00_send_td(c67x00, td);\n\t}\n\n\tc67x00_ll_husb_set_current_td(c67x00->sie, c67x00->td_base_addr);\n}\n\n \n\n \nstatic void c67x00_do_work(struct c67x00_hcd *c67x00)\n{\n\tspin_lock(&c67x00->lock);\n\t \n\tif (!c67x00_all_tds_processed(c67x00))\n\t\tgoto out;\n\n\tc67x00_check_td_list(c67x00);\n\n\t \n\tcomplete(&c67x00->endpoint_disable);\n\n\tif (!list_empty(&c67x00->td_list))\n\t\tgoto out;\n\n\tc67x00->current_frame = c67x00_get_current_frame_number(c67x00);\n\tif (c67x00->current_frame == c67x00->last_frame)\n\t\tgoto out;\t \n\tc67x00->last_frame = c67x00->current_frame;\n\n\t \n\tif (!c67x00->urb_count) {\n\t\tc67x00_ll_hpi_disable_sofeop(c67x00->sie);\n\t\tgoto out;\n\t}\n\n\tc67x00_fill_frame(c67x00);\n\tif (!list_empty(&c67x00->td_list))\n\t\t \n\t\tc67x00_send_frame(c67x00);\n\n out:\n\tspin_unlock(&c67x00->lock);\n}\n\n \n\nstatic void c67x00_sched_work(struct work_struct *work)\n{\n\tstruct c67x00_hcd *c67x00;\n\n\tc67x00 = container_of(work, struct c67x00_hcd, work);\n\tc67x00_do_work(c67x00);\n}\n\nvoid c67x00_sched_kick(struct c67x00_hcd *c67x00)\n{\n\tqueue_work(system_highpri_wq, &c67x00->work);\n}\n\nint c67x00_sched_start_scheduler(struct c67x00_hcd *c67x00)\n{\n\tINIT_WORK(&c67x00->work, c67x00_sched_work);\n\treturn 0;\n}\n\nvoid c67x00_sched_stop_scheduler(struct c67x00_hcd *c67x00)\n{\n\tcancel_work_sync(&c67x00->work);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}