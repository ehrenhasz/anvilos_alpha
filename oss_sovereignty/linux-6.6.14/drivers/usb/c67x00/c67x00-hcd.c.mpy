{
  "module_name": "c67x00-hcd.c",
  "hash_id": "aeeff626a338a8663d55e3322b64c022126e71e50485f89746a54c679f2c93e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/c67x00/c67x00-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n\n#include \"c67x00.h\"\n#include \"c67x00-hcd.h\"\n\n \n\nstatic __u8 c67x00_hub_des[] = {\n\t0x09,\t\t\t \n\tUSB_DT_HUB,\t\t \n\t0x02,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0x32,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0xff,\t\t\t \n};\n\nstatic void c67x00_hub_reset_host_port(struct c67x00_sie *sie, int port)\n{\n\tstruct c67x00_hcd *c67x00 = sie->private_data;\n\tunsigned long flags;\n\n\tc67x00_ll_husb_reset(sie, port);\n\n\tspin_lock_irqsave(&c67x00->lock, flags);\n\tc67x00_ll_husb_reset_port(sie, port);\n\tspin_unlock_irqrestore(&c67x00->lock, flags);\n\n\tc67x00_ll_set_husb_eot(sie->dev, DEFAULT_EOT);\n}\n\nstatic int c67x00_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tstruct c67x00_sie *sie = c67x00->sie;\n\tu16 status;\n\tint i;\n\n\t*buf = 0;\n\tstatus = c67x00_ll_usb_get_status(sie);\n\tfor (i = 0; i < C67X00_PORTS; i++)\n\t\tif (status & PORT_CONNECT_CHANGE(i))\n\t\t\t*buf |= (1 << i);\n\n\t \n\t*buf <<= 1;\n\n\treturn !!*buf;\n}\n\nstatic int c67x00_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t      u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tstruct c67x00_sie *sie = c67x00->sie;\n\tu16 status, usb_status;\n\tint len = 0;\n\tunsigned int port = wIndex-1;\n\tu16 wPortChange, wPortStatus;\n\n\tswitch (typeReq) {\n\n\tcase GetHubStatus:\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tlen = 4;\t\t \n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tif (wIndex > C67X00_PORTS)\n\t\t\treturn -EPIPE;\n\n\t\tstatus = c67x00_ll_usb_get_status(sie);\n\t\tusb_status = c67x00_ll_get_usb_ctl(sie);\n\n\t\twPortChange = 0;\n\t\tif (status & PORT_CONNECT_CHANGE(port))\n\t\t\twPortChange |= USB_PORT_STAT_C_CONNECTION;\n\n\t\twPortStatus = USB_PORT_STAT_POWER;\n\t\tif (!(status & PORT_SE0_STATUS(port)))\n\t\t\twPortStatus |= USB_PORT_STAT_CONNECTION;\n\t\tif (usb_status & LOW_SPEED_PORT(port)) {\n\t\t\twPortStatus |= USB_PORT_STAT_LOW_SPEED;\n\t\t\tc67x00->low_speed_ports |= (1 << port);\n\t\t} else\n\t\t\tc67x00->low_speed_ports &= ~(1 << port);\n\n\t\tif (usb_status & SOF_EOP_EN(port))\n\t\t\twPortStatus |= USB_PORT_STAT_ENABLE;\n\n\t\t*(__le16 *) buf = cpu_to_le16(wPortStatus);\n\t\t*(__le16 *) (buf + 2) = cpu_to_le16(wPortChange);\n\t\tlen = 4;\n\t\tbreak;\n\n\tcase SetHubFeature:\t \n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tbreak;\n\n\tcase SetPortFeature:\n\t\tif (wIndex > C67X00_PORTS)\n\t\t\treturn -EPIPE;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"SetPortFeature %d (SUSPEND)\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tc67x00_hub_reset_host_port(sie, port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\t \n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"%s: SetPortFeature %d (0x%04x) Error!\\n\",\n\t\t\t\t__func__, port, wValue);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tbreak;\n\n\tcase ClearPortFeature:\n\t\tif (wIndex > C67X00_PORTS)\n\t\t\treturn -EPIPE;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\t \n\t\t\tc67x00_hub_reset_host_port(sie, port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): C_ENABLE\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): SUSPEND\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): C_SUSPEND\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): POWER\\n\", port);\n\t\t\treturn -EPIPE;\n\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tc67x00_ll_usb_clear_status(sie,\n\t\t\t\t\t\t   PORT_CONNECT_CHANGE(port));\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): OVER_CURRENT\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"ClearPortFeature (%d): C_RESET\\n\", port);\n\t\t\tlen = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_dbg(c67x00_hcd_dev(c67x00),\n\t\t\t\t\"%s: ClearPortFeature %d (0x%04x) Error!\\n\",\n\t\t\t\t__func__, port, wValue);\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tbreak;\n\n\tcase GetHubDescriptor:\n\t\tlen = min_t(unsigned int, sizeof(c67x00_hub_des), wLength);\n\t\tmemcpy(buf, c67x00_hub_des, len);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(c67x00_hcd_dev(c67x00), \"%s: unknown\\n\", __func__);\n\t\treturn -EPIPE;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void c67x00_hcd_irq(struct c67x00_sie *sie, u16 int_status, u16 msg)\n{\n\tstruct c67x00_hcd *c67x00 = sie->private_data;\n\tstruct usb_hcd *hcd = c67x00_hcd_to_hcd(c67x00);\n\n\t \n\tif (msg) {\n\t\tif (msg & HUSB_TDListDone)\n\t\t\tc67x00_sched_kick(c67x00);\n\t\telse\n\t\t\tdev_warn(c67x00_hcd_dev(c67x00),\n\t\t\t\t \"Unknown SIE msg flag(s): 0x%04x\\n\", msg);\n\t}\n\n\tif (unlikely(hcd->state == HC_STATE_HALT))\n\t\treturn;\n\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\treturn;\n\n\t \n\tif (int_status & SOFEOP_FLG(sie->sie_num)) {\n\t\tc67x00_ll_usb_clear_status(sie, SOF_EOP_IRQ_FLG);\n\t\tc67x00_sched_kick(c67x00);\n\t}\n}\n\n \nstatic int c67x00_hcd_start(struct usb_hcd *hcd)\n{\n\thcd->uses_new_polling = 1;\n\thcd->state = HC_STATE_RUNNING;\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\treturn 0;\n}\n\n \nstatic void c67x00_hcd_stop(struct usb_hcd *hcd)\n{\n\t \n}\n\nstatic int c67x00_hcd_get_frame(struct usb_hcd *hcd)\n{\n\tstruct c67x00_hcd *c67x00 = hcd_to_c67x00_hcd(hcd);\n\tu16 temp_val;\n\n\tdev_dbg(c67x00_hcd_dev(c67x00), \"%s\\n\", __func__);\n\ttemp_val = c67x00_ll_husb_get_frame(c67x00->sie);\n\ttemp_val &= HOST_FRAME_MASK;\n\treturn temp_val ? (temp_val - 1) : HOST_FRAME_MASK;\n}\n\nstatic const struct hc_driver c67x00_hc_driver = {\n\t.description\t= \"c67x00-hcd\",\n\t.product_desc\t= \"Cypress C67X00 Host Controller\",\n\t.hcd_priv_size\t= sizeof(struct c67x00_hcd),\n\t.flags\t\t= HCD_USB11 | HCD_MEMORY,\n\n\t \n\t.start\t\t= c67x00_hcd_start,\n\t.stop\t\t= c67x00_hcd_stop,\n\n\t \n\t.urb_enqueue\t= c67x00_urb_enqueue,\n\t.urb_dequeue\t= c67x00_urb_dequeue,\n\t.endpoint_disable = c67x00_endpoint_disable,\n\n\t \n\t.get_frame_number = c67x00_hcd_get_frame,\n\n\t \n\t.hub_status_data = c67x00_hub_status_data,\n\t.hub_control\t= c67x00_hub_control,\n};\n\n \n\nint c67x00_hcd_probe(struct c67x00_sie *sie)\n{\n\tstruct c67x00_hcd *c67x00;\n\tstruct usb_hcd *hcd;\n\tunsigned long flags;\n\tint retval;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&c67x00_hc_driver, sie_dev(sie), \"c67x00_sie\");\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto err0;\n\t}\n\tc67x00 = hcd_to_c67x00_hcd(hcd);\n\n\tspin_lock_init(&c67x00->lock);\n\tc67x00->sie = sie;\n\n\tINIT_LIST_HEAD(&c67x00->list[PIPE_ISOCHRONOUS]);\n\tINIT_LIST_HEAD(&c67x00->list[PIPE_INTERRUPT]);\n\tINIT_LIST_HEAD(&c67x00->list[PIPE_CONTROL]);\n\tINIT_LIST_HEAD(&c67x00->list[PIPE_BULK]);\n\tc67x00->urb_count = 0;\n\tINIT_LIST_HEAD(&c67x00->td_list);\n\tc67x00->td_base_addr = CY_HCD_BUF_ADDR + SIE_TD_OFFSET(sie->sie_num);\n\tc67x00->buf_base_addr = CY_HCD_BUF_ADDR + SIE_BUF_OFFSET(sie->sie_num);\n\tc67x00->max_frame_bw = MAX_FRAME_BW_STD;\n\n\tc67x00_ll_husb_init_host_port(sie);\n\n\tinit_completion(&c67x00->endpoint_disable);\n\tretval = c67x00_sched_start_scheduler(c67x00);\n\tif (retval)\n\t\tgoto err1;\n\n\tretval = usb_add_hcd(hcd, 0, 0);\n\tif (retval) {\n\t\tdev_dbg(sie_dev(sie), \"%s: usb_add_hcd returned %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto err2;\n\t}\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tspin_lock_irqsave(&sie->lock, flags);\n\tsie->private_data = c67x00;\n\tsie->irq = c67x00_hcd_irq;\n\tspin_unlock_irqrestore(&sie->lock, flags);\n\n\treturn retval;\n\n err2:\n\tc67x00_sched_stop_scheduler(c67x00);\n err1:\n\tusb_put_hcd(hcd);\n err0:\n\treturn retval;\n}\n\n \nvoid c67x00_hcd_remove(struct c67x00_sie *sie)\n{\n\tstruct c67x00_hcd *c67x00 = sie->private_data;\n\tstruct usb_hcd *hcd = c67x00_hcd_to_hcd(c67x00);\n\n\tc67x00_sched_stop_scheduler(c67x00);\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}