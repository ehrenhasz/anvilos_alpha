{
  "module_name": "c67x00-ll-hpi.c",
  "hash_id": "e20af506c592ba05c3aee276019259d17525682dee6ed6346b789e0e390cfc2a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/c67x00/c67x00-ll-hpi.c",
  "human_readable_source": "\n \n\n#include <asm/byteorder.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/usb/c67x00.h>\n#include \"c67x00.h\"\n\n#define COMM_REGS 14\n\nstruct c67x00_lcp_int_data {\n\tu16 regs[COMM_REGS];\n};\n\n \n \n\n#define COMM_ACK\t\t\t0x0FED\n#define COMM_NAK\t\t\t0xDEAD\n\n#define COMM_RESET\t\t\t0xFA50\n#define COMM_EXEC_INT\t\t\t0xCE01\n#define COMM_INT_NUM\t\t\t0x01C2\n\n \n#define COMM_R(x)\t\t\t(0x01C4 + 2 * (x))\n\n#define HUSB_SIE_pCurrentTDPtr(x)\t((x) ? 0x01B2 : 0x01B0)\n#define HUSB_SIE_pTDListDone_Sem(x)\t((x) ? 0x01B8 : 0x01B6)\n#define HUSB_pEOT\t\t\t0x01B4\n\n \n \n#define HUSB_SIE_INIT_INT(x)\t\t((x) ? 0x0073 : 0x0072)\n#define HUSB_RESET_INT\t\t\t0x0074\n\n#define SUSB_INIT_INT\t\t\t0x0071\n#define SUSB_INIT_INT_LOC\t\t(SUSB_INIT_INT * 2)\n\n \n\n \n#define HPI_DATA\t0\n#define HPI_MAILBOX\t1\n#define HPI_ADDR\t2\n#define HPI_STATUS\t3\n\n \n#define HPI_T_CYC_NS\t125\n\nstatic inline u16 hpi_read_reg(struct c67x00_device *dev, int reg)\n{\n\tndelay(HPI_T_CYC_NS);\n\treturn __raw_readw(dev->hpi.base + reg * dev->hpi.regstep);\n}\n\nstatic inline void hpi_write_reg(struct c67x00_device *dev, int reg, u16 value)\n{\n\tndelay(HPI_T_CYC_NS);\n\t__raw_writew(value, dev->hpi.base + reg * dev->hpi.regstep);\n}\n\nstatic inline u16 hpi_read_word_nolock(struct c67x00_device *dev, u16 reg)\n{\n\thpi_write_reg(dev, HPI_ADDR, reg);\n\treturn hpi_read_reg(dev, HPI_DATA);\n}\n\nstatic u16 hpi_read_word(struct c67x00_device *dev, u16 reg)\n{\n\tu16 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\tvalue = hpi_read_word_nolock(dev, reg);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n\n\treturn value;\n}\n\nstatic void hpi_write_word_nolock(struct c67x00_device *dev, u16 reg, u16 value)\n{\n\thpi_write_reg(dev, HPI_ADDR, reg);\n\thpi_write_reg(dev, HPI_DATA, value);\n}\n\nstatic void hpi_write_word(struct c67x00_device *dev, u16 reg, u16 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\thpi_write_word_nolock(dev, reg, value);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n}\n\n \nstatic void hpi_write_words_le16(struct c67x00_device *dev, u16 addr,\n\t\t\t\t __le16 *data, u16 count)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\n\thpi_write_reg(dev, HPI_ADDR, addr);\n\tfor (i = 0; i < count; i++)\n\t\thpi_write_reg(dev, HPI_DATA, le16_to_cpu(*data++));\n\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n}\n\n \nstatic void hpi_read_words_le16(struct c67x00_device *dev, u16 addr,\n\t\t\t\t__le16 *data, u16 count)\n{\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\thpi_write_reg(dev, HPI_ADDR, addr);\n\tfor (i = 0; i < count; i++)\n\t\t*data++ = cpu_to_le16(hpi_read_reg(dev, HPI_DATA));\n\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n}\n\nstatic void hpi_set_bits(struct c67x00_device *dev, u16 reg, u16 mask)\n{\n\tu16 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\tvalue = hpi_read_word_nolock(dev, reg);\n\thpi_write_word_nolock(dev, reg, value | mask);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n}\n\nstatic void hpi_clear_bits(struct c67x00_device *dev, u16 reg, u16 mask)\n{\n\tu16 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\tvalue = hpi_read_word_nolock(dev, reg);\n\thpi_write_word_nolock(dev, reg, value & ~mask);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n}\n\nstatic u16 hpi_recv_mbox(struct c67x00_device *dev)\n{\n\tu16 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\tvalue = hpi_read_reg(dev, HPI_MAILBOX);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n\n\treturn value;\n}\n\nstatic u16 hpi_send_mbox(struct c67x00_device *dev, u16 value)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\thpi_write_reg(dev, HPI_MAILBOX, value);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n\n\treturn value;\n}\n\nu16 c67x00_ll_hpi_status(struct c67x00_device *dev)\n{\n\tu16 value;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->hpi.lock, flags);\n\tvalue = hpi_read_reg(dev, HPI_STATUS);\n\tspin_unlock_irqrestore(&dev->hpi.lock, flags);\n\n\treturn value;\n}\n\nvoid c67x00_ll_hpi_reg_init(struct c67x00_device *dev)\n{\n\tint i;\n\n\thpi_recv_mbox(dev);\n\tc67x00_ll_hpi_status(dev);\n\thpi_write_word(dev, HPI_IRQ_ROUTING_REG, 0);\n\n\tfor (i = 0; i < C67X00_SIES; i++) {\n\t\thpi_write_word(dev, SIEMSG_REG(i), 0);\n\t\thpi_read_word(dev, SIEMSG_REG(i));\n\t}\n}\n\nvoid c67x00_ll_hpi_enable_sofeop(struct c67x00_sie *sie)\n{\n\thpi_set_bits(sie->dev, HPI_IRQ_ROUTING_REG,\n\t\t     SOFEOP_TO_HPI_EN(sie->sie_num));\n}\n\nvoid c67x00_ll_hpi_disable_sofeop(struct c67x00_sie *sie)\n{\n\thpi_clear_bits(sie->dev, HPI_IRQ_ROUTING_REG,\n\t\t       SOFEOP_TO_HPI_EN(sie->sie_num));\n}\n\n \n \n\nstatic inline int ll_recv_msg(struct c67x00_device *dev)\n{\n\tu16 res;\n\n\tres = wait_for_completion_timeout(&dev->hpi.lcp.msg_received, 5 * HZ);\n\tWARN_ON(!res);\n\n\treturn (res == 0) ? -EIO : 0;\n}\n\n \n \n\nu16 c67x00_ll_fetch_siemsg(struct c67x00_device *dev, int sie_num)\n{\n\tu16 val;\n\n\tval = hpi_read_word(dev, SIEMSG_REG(sie_num));\n\t \n\thpi_write_word(dev, SIEMSG_REG(sie_num), 0);\n\n\treturn val;\n}\n\nu16 c67x00_ll_get_usb_ctl(struct c67x00_sie *sie)\n{\n\treturn hpi_read_word(sie->dev, USB_CTL_REG(sie->sie_num));\n}\n\n \nvoid c67x00_ll_usb_clear_status(struct c67x00_sie *sie, u16 bits)\n{\n\thpi_write_word(sie->dev, USB_STAT_REG(sie->sie_num), bits);\n}\n\nu16 c67x00_ll_usb_get_status(struct c67x00_sie *sie)\n{\n\treturn hpi_read_word(sie->dev, USB_STAT_REG(sie->sie_num));\n}\n\n \n\nstatic int c67x00_comm_exec_int(struct c67x00_device *dev, u16 nr,\n\t\t\t\tstruct c67x00_lcp_int_data *data)\n{\n\tint i, rc;\n\n\tmutex_lock(&dev->hpi.lcp.mutex);\n\thpi_write_word(dev, COMM_INT_NUM, nr);\n\tfor (i = 0; i < COMM_REGS; i++)\n\t\thpi_write_word(dev, COMM_R(i), data->regs[i]);\n\thpi_send_mbox(dev, COMM_EXEC_INT);\n\trc = ll_recv_msg(dev);\n\tmutex_unlock(&dev->hpi.lcp.mutex);\n\n\treturn rc;\n}\n\n \n \n\nvoid c67x00_ll_set_husb_eot(struct c67x00_device *dev, u16 value)\n{\n\tmutex_lock(&dev->hpi.lcp.mutex);\n\thpi_write_word(dev, HUSB_pEOT, value);\n\tmutex_unlock(&dev->hpi.lcp.mutex);\n}\n\nstatic inline void c67x00_ll_husb_sie_init(struct c67x00_sie *sie)\n{\n\tstruct c67x00_device *dev = sie->dev;\n\tstruct c67x00_lcp_int_data data;\n\tint rc;\n\n\trc = c67x00_comm_exec_int(dev, HUSB_SIE_INIT_INT(sie->sie_num), &data);\n\tBUG_ON(rc);  \n}\n\nvoid c67x00_ll_husb_reset(struct c67x00_sie *sie, int port)\n{\n\tstruct c67x00_device *dev = sie->dev;\n\tstruct c67x00_lcp_int_data data;\n\tint rc;\n\n\tdata.regs[0] = 50;\t \n\tdata.regs[1] = port | (sie->sie_num << 1);\n\trc = c67x00_comm_exec_int(dev, HUSB_RESET_INT, &data);\n\tBUG_ON(rc);  \n}\n\nvoid c67x00_ll_husb_set_current_td(struct c67x00_sie *sie, u16 addr)\n{\n\thpi_write_word(sie->dev, HUSB_SIE_pCurrentTDPtr(sie->sie_num), addr);\n}\n\nu16 c67x00_ll_husb_get_current_td(struct c67x00_sie *sie)\n{\n\treturn hpi_read_word(sie->dev, HUSB_SIE_pCurrentTDPtr(sie->sie_num));\n}\n\nu16 c67x00_ll_husb_get_frame(struct c67x00_sie *sie)\n{\n\treturn hpi_read_word(sie->dev, HOST_FRAME_REG(sie->sie_num));\n}\n\nvoid c67x00_ll_husb_init_host_port(struct c67x00_sie *sie)\n{\n\t \n\thpi_set_bits(sie->dev, USB_CTL_REG(sie->sie_num), HOST_MODE);\n\tc67x00_ll_husb_sie_init(sie);\n\t \n\tc67x00_ll_usb_clear_status(sie, HOST_STAT_MASK);\n\t \n\tif (!(hpi_read_word(sie->dev, USB_CTL_REG(sie->sie_num)) & HOST_MODE))\n\t\tdev_warn(sie_dev(sie),\n\t\t\t \"SIE %d not set to host mode\\n\", sie->sie_num);\n}\n\nvoid c67x00_ll_husb_reset_port(struct c67x00_sie *sie, int port)\n{\n\t \n\tc67x00_ll_usb_clear_status(sie, PORT_CONNECT_CHANGE(port));\n\n\t \n\thpi_set_bits(sie->dev, HPI_IRQ_ROUTING_REG,\n\t\t     SOFEOP_TO_CPU_EN(sie->sie_num));\n\thpi_set_bits(sie->dev, HOST_IRQ_EN_REG(sie->sie_num),\n\t\t     SOF_EOP_IRQ_EN | DONE_IRQ_EN);\n\n\t \n\thpi_set_bits(sie->dev, USB_CTL_REG(sie->sie_num), PORT_RES_EN(port));\n}\n\n \n\nvoid c67x00_ll_irq(struct c67x00_device *dev, u16 int_status)\n{\n\tif ((int_status & MBX_OUT_FLG) == 0)\n\t\treturn;\n\n\tdev->hpi.lcp.last_msg = hpi_recv_mbox(dev);\n\tcomplete(&dev->hpi.lcp.msg_received);\n}\n\n \n\nint c67x00_ll_reset(struct c67x00_device *dev)\n{\n\tint rc;\n\n\tmutex_lock(&dev->hpi.lcp.mutex);\n\thpi_send_mbox(dev, COMM_RESET);\n\trc = ll_recv_msg(dev);\n\tmutex_unlock(&dev->hpi.lcp.mutex);\n\n\treturn rc;\n}\n\n \n\n \nvoid c67x00_ll_write_mem_le16(struct c67x00_device *dev, u16 addr,\n\t\t\t      void *data, int len)\n{\n\tu8 *buf = data;\n\n\t \n\tif (addr + len > 0xffff) {\n\t\tdev_err(&dev->pdev->dev,\n\t\t\t\"Trying to write beyond writable region!\\n\");\n\t\treturn;\n\t}\n\n\tif (addr & 0x01) {\n\t\t \n\t\tu16 tmp;\n\t\ttmp = hpi_read_word(dev, addr - 1);\n\t\ttmp = (tmp & 0x00ff) | (*buf++ << 8);\n\t\thpi_write_word(dev, addr - 1, tmp);\n\t\taddr++;\n\t\tlen--;\n\t}\n\n\thpi_write_words_le16(dev, addr, (__le16 *)buf, len / 2);\n\tbuf += len & ~0x01;\n\taddr += len & ~0x01;\n\tlen &= 0x01;\n\n\tif (len) {\n\t\tu16 tmp;\n\t\ttmp = hpi_read_word(dev, addr);\n\t\ttmp = (tmp & 0xff00) | *buf;\n\t\thpi_write_word(dev, addr, tmp);\n\t}\n}\n\n \nvoid c67x00_ll_read_mem_le16(struct c67x00_device *dev, u16 addr,\n\t\t\t     void *data, int len)\n{\n\tu8 *buf = data;\n\n\tif (addr & 0x01) {\n\t\t \n\t\tu16 tmp;\n\t\ttmp = hpi_read_word(dev, addr - 1);\n\t\t*buf++ = (tmp >> 8) & 0x00ff;\n\t\taddr++;\n\t\tlen--;\n\t}\n\n\thpi_read_words_le16(dev, addr, (__le16 *)buf, len / 2);\n\tbuf += len & ~0x01;\n\taddr += len & ~0x01;\n\tlen &= 0x01;\n\n\tif (len) {\n\t\tu16 tmp;\n\t\ttmp = hpi_read_word(dev, addr);\n\t\t*buf = tmp & 0x00ff;\n\t}\n}\n\n \n\nvoid c67x00_ll_init(struct c67x00_device *dev)\n{\n\tmutex_init(&dev->hpi.lcp.mutex);\n\tinit_completion(&dev->hpi.lcp.msg_received);\n}\n\nvoid c67x00_ll_release(struct c67x00_device *dev)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}