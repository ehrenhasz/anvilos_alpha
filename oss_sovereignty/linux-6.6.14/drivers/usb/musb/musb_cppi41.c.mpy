{
  "module_name": "musb_cppi41.c",
  "hash_id": "37ec14575340d978b99acdde234649d88f961e4e5020f168eb6615d6c06490d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_cppi41.c",
  "human_readable_source": "\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/sizes.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include \"cppi_dma.h\"\n#include \"musb_core.h\"\n#include \"musb_trace.h\"\n\n#define RNDIS_REG(x) (0x80 + ((x - 1) * 4))\n\n#define EP_MODE_AUTOREQ_NONE\t\t0\n#define EP_MODE_AUTOREQ_ALL_NEOP\t1\n#define EP_MODE_AUTOREQ_ALWAYS\t\t3\n\n#define EP_MODE_DMA_TRANSPARENT\t\t0\n#define EP_MODE_DMA_RNDIS\t\t1\n#define EP_MODE_DMA_GEN_RNDIS\t\t3\n\n#define USB_CTRL_TX_MODE\t0x70\n#define USB_CTRL_RX_MODE\t0x74\n#define USB_CTRL_AUTOREQ\t0xd0\n#define USB_TDOWN\t\t0xd8\n\n#define MUSB_DMA_NUM_CHANNELS 15\n\n#define DA8XX_USB_MODE\t\t0x10\n#define DA8XX_USB_AUTOREQ\t0x14\n#define DA8XX_USB_TEARDOWN\t0x1c\n\n#define DA8XX_DMA_NUM_CHANNELS 4\n\nstruct cppi41_dma_controller {\n\tstruct dma_controller controller;\n\tstruct cppi41_dma_channel *rx_channel;\n\tstruct cppi41_dma_channel *tx_channel;\n\tstruct hrtimer early_tx;\n\tstruct list_head early_tx_list;\n\tu32 rx_mode;\n\tu32 tx_mode;\n\tu32 auto_req;\n\n\tu32 tdown_reg;\n\tu32 autoreq_reg;\n\n\tvoid (*set_dma_mode)(struct cppi41_dma_channel *cppi41_channel,\n\t\t\t     unsigned int mode);\n\tu8 num_channels;\n};\n\nstatic void save_rx_toggle(struct cppi41_dma_channel *cppi41_channel)\n{\n\tu16 csr;\n\tu8 toggle;\n\n\tif (cppi41_channel->is_tx)\n\t\treturn;\n\tif (!is_host_active(cppi41_channel->controller->controller.musb))\n\t\treturn;\n\n\tcsr = musb_readw(cppi41_channel->hw_ep->regs, MUSB_RXCSR);\n\ttoggle = csr & MUSB_RXCSR_H_DATATOGGLE ? 1 : 0;\n\n\tcppi41_channel->usb_toggle = toggle;\n}\n\nstatic void update_rx_toggle(struct cppi41_dma_channel *cppi41_channel)\n{\n\tstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\n\tstruct musb *musb = hw_ep->musb;\n\tu16 csr;\n\tu8 toggle;\n\n\tif (cppi41_channel->is_tx)\n\t\treturn;\n\tif (!is_host_active(musb))\n\t\treturn;\n\n\tmusb_ep_select(musb->mregs, hw_ep->epnum);\n\tcsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\n\ttoggle = csr & MUSB_RXCSR_H_DATATOGGLE ? 1 : 0;\n\n\t \n\tif (!toggle && toggle == cppi41_channel->usb_toggle) {\n\t\tcsr |= MUSB_RXCSR_H_DATATOGGLE | MUSB_RXCSR_H_WR_DATATOGGLE;\n\t\tmusb_writew(cppi41_channel->hw_ep->regs, MUSB_RXCSR, csr);\n\t\tmusb_dbg(musb, \"Restoring DATA1 toggle.\");\n\t}\n\n\tcppi41_channel->usb_toggle = toggle;\n}\n\nstatic bool musb_is_tx_fifo_empty(struct musb_hw_ep *hw_ep)\n{\n\tu8\t\tepnum = hw_ep->epnum;\n\tstruct musb\t*musb = hw_ep->musb;\n\tvoid __iomem\t*epio = musb->endpoints[epnum].regs;\n\tu16\t\tcsr;\n\n\tmusb_ep_select(musb->mregs, hw_ep->epnum);\n\tcsr = musb_readw(epio, MUSB_TXCSR);\n\tif (csr & MUSB_TXCSR_TXPKTRDY)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void cppi41_dma_callback(void *private_data,\n\t\t\t\tconst struct dmaengine_result *result);\n\nstatic void cppi41_trans_done(struct cppi41_dma_channel *cppi41_channel)\n{\n\tstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem *epio = hw_ep->regs;\n\tu16 csr;\n\n\tif (!cppi41_channel->prog_len ||\n\t    (cppi41_channel->channel.status == MUSB_DMA_STATUS_FREE)) {\n\n\t\t \n\t\tcppi41_channel->channel.actual_len =\n\t\t\tcppi41_channel->transferred;\n\t\tcppi41_channel->channel.status = MUSB_DMA_STATUS_FREE;\n\t\tcppi41_channel->channel.rx_packet_done = true;\n\n\t\t \n\t\tif (cppi41_channel->tx_zlp && (cppi41_channel->transferred %\n\t\t\t\t\tcppi41_channel->packet_sz) == 0) {\n\t\t\tmusb_ep_select(musb->mregs, hw_ep->epnum);\n\t\t\tcsr = MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY;\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t}\n\n\t\ttrace_musb_cppi41_done(cppi41_channel);\n\t\tmusb_dma_completion(musb, hw_ep->epnum, cppi41_channel->is_tx);\n\t} else {\n\t\t \n\t\tstruct dma_chan *dc = cppi41_channel->dc;\n\t\tstruct dma_async_tx_descriptor *dma_desc;\n\t\tenum dma_transfer_direction direction;\n\t\tu32 remain_bytes;\n\n\t\tcppi41_channel->buf_addr += cppi41_channel->packet_sz;\n\n\t\tremain_bytes = cppi41_channel->total_len;\n\t\tremain_bytes -= cppi41_channel->transferred;\n\t\tremain_bytes = min(remain_bytes, cppi41_channel->packet_sz);\n\t\tcppi41_channel->prog_len = remain_bytes;\n\n\t\tdirection = cppi41_channel->is_tx ? DMA_MEM_TO_DEV\n\t\t\t: DMA_DEV_TO_MEM;\n\t\tdma_desc = dmaengine_prep_slave_single(dc,\n\t\t\t\tcppi41_channel->buf_addr,\n\t\t\t\tremain_bytes,\n\t\t\t\tdirection,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (WARN_ON(!dma_desc))\n\t\t\treturn;\n\n\t\tdma_desc->callback_result = cppi41_dma_callback;\n\t\tdma_desc->callback_param = &cppi41_channel->channel;\n\t\tcppi41_channel->cookie = dma_desc->tx_submit(dma_desc);\n\t\ttrace_musb_cppi41_cont(cppi41_channel);\n\t\tdma_async_issue_pending(dc);\n\n\t\tif (!cppi41_channel->is_tx) {\n\t\t\tmusb_ep_select(musb->mregs, hw_ep->epnum);\n\t\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\t\tcsr |= MUSB_RXCSR_H_REQPKT;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t}\n\t}\n}\n\nstatic enum hrtimer_restart cppi41_recheck_tx_req(struct hrtimer *timer)\n{\n\tstruct cppi41_dma_controller *controller;\n\tstruct cppi41_dma_channel *cppi41_channel, *n;\n\tstruct musb *musb;\n\tunsigned long flags;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\tcontroller = container_of(timer, struct cppi41_dma_controller,\n\t\t\tearly_tx);\n\tmusb = controller->controller.musb;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tlist_for_each_entry_safe(cppi41_channel, n, &controller->early_tx_list,\n\t\t\ttx_check) {\n\t\tbool empty;\n\t\tstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\n\n\t\tempty = musb_is_tx_fifo_empty(hw_ep);\n\t\tif (empty) {\n\t\t\tlist_del_init(&cppi41_channel->tx_check);\n\t\t\tcppi41_trans_done(cppi41_channel);\n\t\t}\n\t}\n\n\tif (!list_empty(&controller->early_tx_list) &&\n\t    !hrtimer_is_queued(&controller->early_tx)) {\n\t\tret = HRTIMER_RESTART;\n\t\thrtimer_forward_now(&controller->early_tx, 20 * NSEC_PER_USEC);\n\t}\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn ret;\n}\n\nstatic void cppi41_dma_callback(void *private_data,\n\t\t\t\tconst struct dmaengine_result *result)\n{\n\tstruct dma_channel *channel = private_data;\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\tstruct musb_hw_ep *hw_ep = cppi41_channel->hw_ep;\n\tstruct cppi41_dma_controller *controller;\n\tstruct musb *musb = hw_ep->musb;\n\tunsigned long flags;\n\tstruct dma_tx_state txstate;\n\tu32 transferred;\n\tint is_hs = 0;\n\tbool empty;\n\n\tcontroller = cppi41_channel->controller;\n\tif (controller->controller.dma_callback)\n\t\tcontroller->controller.dma_callback(&controller->controller);\n\n\tif (result->result == DMA_TRANS_ABORTED)\n\t\treturn;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tdmaengine_tx_status(cppi41_channel->dc, cppi41_channel->cookie,\n\t\t\t&txstate);\n\ttransferred = cppi41_channel->prog_len - txstate.residue;\n\tcppi41_channel->transferred += transferred;\n\n\ttrace_musb_cppi41_gb(cppi41_channel);\n\tupdate_rx_toggle(cppi41_channel);\n\n\tif (cppi41_channel->transferred == cppi41_channel->total_len ||\n\t\t\ttransferred < cppi41_channel->packet_sz)\n\t\tcppi41_channel->prog_len = 0;\n\n\tif (cppi41_channel->is_tx) {\n\t\tu8 type;\n\n\t\tif (is_host_active(musb))\n\t\t\ttype = hw_ep->out_qh->type;\n\t\telse\n\t\t\ttype = hw_ep->ep_in.type;\n\n\t\tif (type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t \n\t\t\tempty = true;\n\t\telse\n\t\t\tempty = musb_is_tx_fifo_empty(hw_ep);\n\t}\n\n\tif (!cppi41_channel->is_tx || empty) {\n\t\tcppi41_trans_done(cppi41_channel);\n\t\tgoto out;\n\t}\n\n\t \n\tif (is_host_active(musb)) {\n\t\tif (musb->port1_status & USB_PORT_STAT_HIGH_SPEED)\n\t\t\tis_hs = 1;\n\t} else {\n\t\tif (musb->g.speed == USB_SPEED_HIGH)\n\t\t\tis_hs = 1;\n\t}\n\tif (is_hs) {\n\t\tunsigned wait = 25;\n\n\t\tdo {\n\t\t\tempty = musb_is_tx_fifo_empty(hw_ep);\n\t\t\tif (empty) {\n\t\t\t\tcppi41_trans_done(cppi41_channel);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twait--;\n\t\t\tif (!wait)\n\t\t\t\tbreak;\n\t\t\tcpu_relax();\n\t\t} while (1);\n\t}\n\tlist_add_tail(&cppi41_channel->tx_check,\n\t\t\t&controller->early_tx_list);\n\tif (!hrtimer_is_queued(&controller->early_tx)) {\n\t\tunsigned long usecs = cppi41_channel->total_len / 10;\n\n\t\thrtimer_start_range_ns(&controller->early_tx,\n\t\t\t\t       usecs * NSEC_PER_USEC,\n\t\t\t\t       20 * NSEC_PER_USEC,\n\t\t\t\t       HRTIMER_MODE_REL);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nstatic u32 update_ep_mode(unsigned ep, unsigned mode, u32 old)\n{\n\tunsigned shift;\n\n\tshift = (ep - 1) * 2;\n\told &= ~(3 << shift);\n\told |= mode << shift;\n\treturn old;\n}\n\nstatic void cppi41_set_dma_mode(struct cppi41_dma_channel *cppi41_channel,\n\t\tunsigned mode)\n{\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tstruct musb *musb = controller->controller.musb;\n\tu32 port;\n\tu32 new_mode;\n\tu32 old_mode;\n\n\tif (cppi41_channel->is_tx)\n\t\told_mode = controller->tx_mode;\n\telse\n\t\told_mode = controller->rx_mode;\n\tport = cppi41_channel->port_num;\n\tnew_mode = update_ep_mode(port, mode, old_mode);\n\n\tif (new_mode == old_mode)\n\t\treturn;\n\tif (cppi41_channel->is_tx) {\n\t\tcontroller->tx_mode = new_mode;\n\t\tmusb_writel(musb->ctrl_base, USB_CTRL_TX_MODE, new_mode);\n\t} else {\n\t\tcontroller->rx_mode = new_mode;\n\t\tmusb_writel(musb->ctrl_base, USB_CTRL_RX_MODE, new_mode);\n\t}\n}\n\nstatic void da8xx_set_dma_mode(struct cppi41_dma_channel *cppi41_channel,\n\t\tunsigned int mode)\n{\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tstruct musb *musb = controller->controller.musb;\n\tunsigned int shift;\n\tu32 port;\n\tu32 new_mode;\n\tu32 old_mode;\n\n\told_mode = controller->tx_mode;\n\tport = cppi41_channel->port_num;\n\n\tshift = (port - 1) * 4;\n\tif (!cppi41_channel->is_tx)\n\t\tshift += 16;\n\tnew_mode = old_mode & ~(3 << shift);\n\tnew_mode |= mode << shift;\n\n\tif (new_mode == old_mode)\n\t\treturn;\n\tcontroller->tx_mode = new_mode;\n\tmusb_writel(musb->ctrl_base, DA8XX_USB_MODE, new_mode);\n}\n\n\nstatic void cppi41_set_autoreq_mode(struct cppi41_dma_channel *cppi41_channel,\n\t\tunsigned mode)\n{\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tu32 port;\n\tu32 new_mode;\n\tu32 old_mode;\n\n\told_mode = controller->auto_req;\n\tport = cppi41_channel->port_num;\n\tnew_mode = update_ep_mode(port, mode, old_mode);\n\n\tif (new_mode == old_mode)\n\t\treturn;\n\tcontroller->auto_req = new_mode;\n\tmusb_writel(controller->controller.musb->ctrl_base,\n\t\t    controller->autoreq_reg, new_mode);\n}\n\nstatic bool cppi41_configure_channel(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tstruct dma_chan *dc = cppi41_channel->dc;\n\tstruct dma_async_tx_descriptor *dma_desc;\n\tenum dma_transfer_direction direction;\n\tstruct musb *musb = cppi41_channel->controller->controller.musb;\n\tunsigned use_gen_rndis = 0;\n\n\tcppi41_channel->buf_addr = dma_addr;\n\tcppi41_channel->total_len = len;\n\tcppi41_channel->transferred = 0;\n\tcppi41_channel->packet_sz = packet_sz;\n\tcppi41_channel->tx_zlp = (cppi41_channel->is_tx && mode) ? 1 : 0;\n\n\t \n\tif (cppi41_channel->is_tx)\n\t\tuse_gen_rndis = 1;\n\n\tif (use_gen_rndis) {\n\t\t \n\t\tif (len > packet_sz) {\n\t\t\tmusb_writel(musb->ctrl_base,\n\t\t\t\tRNDIS_REG(cppi41_channel->port_num), len);\n\t\t\t \n\t\t\tcontroller->set_dma_mode(cppi41_channel,\n\t\t\t\t\tEP_MODE_DMA_GEN_RNDIS);\n\n\t\t\t \n\t\t\tcppi41_set_autoreq_mode(cppi41_channel,\n\t\t\t\t\tEP_MODE_AUTOREQ_ALL_NEOP);\n\t\t} else {\n\t\t\tmusb_writel(musb->ctrl_base,\n\t\t\t\t\tRNDIS_REG(cppi41_channel->port_num), 0);\n\t\t\tcontroller->set_dma_mode(cppi41_channel,\n\t\t\t\t\tEP_MODE_DMA_TRANSPARENT);\n\t\t\tcppi41_set_autoreq_mode(cppi41_channel,\n\t\t\t\t\tEP_MODE_AUTOREQ_NONE);\n\t\t}\n\t} else {\n\t\t \n\t\tcontroller->set_dma_mode(cppi41_channel,\n\t\t\t\tEP_MODE_DMA_TRANSPARENT);\n\t\tcppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);\n\t\tlen = min_t(u32, packet_sz, len);\n\t}\n\tcppi41_channel->prog_len = len;\n\tdirection = cppi41_channel->is_tx ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\n\tdma_desc = dmaengine_prep_slave_single(dc, dma_addr, len, direction,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!dma_desc)\n\t\treturn false;\n\n\tdma_desc->callback_result = cppi41_dma_callback;\n\tdma_desc->callback_param = channel;\n\tcppi41_channel->cookie = dma_desc->tx_submit(dma_desc);\n\tcppi41_channel->channel.rx_packet_done = false;\n\n\ttrace_musb_cppi41_config(cppi41_channel);\n\n\tsave_rx_toggle(cppi41_channel);\n\tdma_async_issue_pending(dc);\n\treturn true;\n}\n\nstatic struct dma_channel *cppi41_dma_channel_allocate(struct dma_controller *c,\n\t\t\t\tstruct musb_hw_ep *hw_ep, u8 is_tx)\n{\n\tstruct cppi41_dma_controller *controller = container_of(c,\n\t\t\tstruct cppi41_dma_controller, controller);\n\tstruct cppi41_dma_channel *cppi41_channel = NULL;\n\tu8 ch_num = hw_ep->epnum - 1;\n\n\tif (ch_num >= controller->num_channels)\n\t\treturn NULL;\n\n\tif (is_tx)\n\t\tcppi41_channel = &controller->tx_channel[ch_num];\n\telse\n\t\tcppi41_channel = &controller->rx_channel[ch_num];\n\n\tif (!cppi41_channel->dc)\n\t\treturn NULL;\n\n\tif (cppi41_channel->is_allocated)\n\t\treturn NULL;\n\n\tcppi41_channel->hw_ep = hw_ep;\n\tcppi41_channel->is_allocated = 1;\n\n\ttrace_musb_cppi41_alloc(cppi41_channel);\n\treturn &cppi41_channel->channel;\n}\n\nstatic void cppi41_dma_channel_release(struct dma_channel *channel)\n{\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\n\ttrace_musb_cppi41_free(cppi41_channel);\n\tif (cppi41_channel->is_allocated) {\n\t\tcppi41_channel->is_allocated = 0;\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\t\tchannel->actual_len = 0;\n\t}\n}\n\nstatic int cppi41_dma_channel_program(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tint ret;\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\tint hb_mult = 0;\n\n\tBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\n\t\tchannel->status == MUSB_DMA_STATUS_BUSY);\n\n\tif (is_host_active(cppi41_channel->controller->controller.musb)) {\n\t\tif (cppi41_channel->is_tx)\n\t\t\thb_mult = cppi41_channel->hw_ep->out_qh->hb_mult;\n\t\telse\n\t\t\thb_mult = cppi41_channel->hw_ep->in_qh->hb_mult;\n\t}\n\n\tchannel->status = MUSB_DMA_STATUS_BUSY;\n\tchannel->actual_len = 0;\n\n\tif (hb_mult)\n\t\tpacket_sz = hb_mult * (packet_sz & 0x7FF);\n\n\tret = cppi41_configure_channel(channel, packet_sz, mode, dma_addr, len);\n\tif (!ret)\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\n\treturn ret;\n}\n\nstatic int cppi41_is_compatible(struct dma_channel *channel, u16 maxpacket,\n\t\tvoid *buf, u32 length)\n{\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tstruct musb *musb = controller->controller.musb;\n\n\tif (is_host_active(musb)) {\n\t\tWARN_ON(1);\n\t\treturn 1;\n\t}\n\tif (cppi41_channel->hw_ep->ep_in.type != USB_ENDPOINT_XFER_BULK)\n\t\treturn 0;\n\tif (cppi41_channel->is_tx)\n\t\treturn 1;\n\t \n\treturn 0;\n}\n\nstatic int cppi41_dma_channel_abort(struct dma_channel *channel)\n{\n\tstruct cppi41_dma_channel *cppi41_channel = channel->private_data;\n\tstruct cppi41_dma_controller *controller = cppi41_channel->controller;\n\tstruct musb *musb = controller->controller.musb;\n\tvoid __iomem *epio = cppi41_channel->hw_ep->regs;\n\tint tdbit;\n\tint ret;\n\tunsigned is_tx;\n\tu16 csr;\n\n\tis_tx = cppi41_channel->is_tx;\n\ttrace_musb_cppi41_abort(cppi41_channel);\n\n\tif (cppi41_channel->channel.status == MUSB_DMA_STATUS_FREE)\n\t\treturn 0;\n\n\tlist_del_init(&cppi41_channel->tx_check);\n\tif (is_tx) {\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tcsr &= ~MUSB_TXCSR_DMAENAB;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t} else {\n\t\tcppi41_set_autoreq_mode(cppi41_channel, EP_MODE_AUTOREQ_NONE);\n\n\t\t \n\t\tudelay(250);\n\n\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\tcsr &= ~(MUSB_RXCSR_H_REQPKT | MUSB_RXCSR_DMAENAB);\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\t \n\t\tudelay(50);\n\n\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\tif (csr & MUSB_RXCSR_RXPKTRDY) {\n\t\t\tcsr |= MUSB_RXCSR_FLUSHFIFO;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t}\n\t}\n\n\t \n\tif (musb->ops->quirks & MUSB_DA8XX)\n\t\tmdelay(250);\n\n\ttdbit = 1 << cppi41_channel->port_num;\n\tif (is_tx)\n\t\ttdbit <<= 16;\n\n\tdo {\n\t\tif (is_tx)\n\t\t\tmusb_writel(musb->ctrl_base, controller->tdown_reg,\n\t\t\t\t    tdbit);\n\t\tret = dmaengine_terminate_all(cppi41_channel->dc);\n\t} while (ret == -EAGAIN);\n\n\tif (is_tx) {\n\t\tmusb_writel(musb->ctrl_base, controller->tdown_reg, tdbit);\n\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tif (csr & MUSB_TXCSR_TXPKTRDY) {\n\t\t\tcsr |= MUSB_TXCSR_FLUSHFIFO;\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t}\n\t}\n\n\tcppi41_channel->channel.status = MUSB_DMA_STATUS_FREE;\n\treturn 0;\n}\n\nstatic void cppi41_release_all_dma_chans(struct cppi41_dma_controller *ctrl)\n{\n\tstruct dma_chan *dc;\n\tint i;\n\n\tfor (i = 0; i < ctrl->num_channels; i++) {\n\t\tdc = ctrl->tx_channel[i].dc;\n\t\tif (dc)\n\t\t\tdma_release_channel(dc);\n\t\tdc = ctrl->rx_channel[i].dc;\n\t\tif (dc)\n\t\t\tdma_release_channel(dc);\n\t}\n}\n\nstatic void cppi41_dma_controller_stop(struct cppi41_dma_controller *controller)\n{\n\tcppi41_release_all_dma_chans(controller);\n}\n\nstatic int cppi41_dma_controller_start(struct cppi41_dma_controller *controller)\n{\n\tstruct musb *musb = controller->controller.musb;\n\tstruct device *dev = musb->controller;\n\tstruct device_node *np = dev->parent->of_node;\n\tstruct cppi41_dma_channel *cppi41_channel;\n\tint count;\n\tint i;\n\tint ret;\n\n\tcount = of_property_count_strings(np, \"dma-names\");\n\tif (count < 0)\n\t\treturn count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tstruct dma_chan *dc;\n\t\tstruct dma_channel *musb_dma;\n\t\tconst char *str;\n\t\tunsigned is_tx;\n\t\tunsigned int port;\n\n\t\tret = of_property_read_string_index(np, \"dma-names\", i, &str);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (strstarts(str, \"tx\"))\n\t\t\tis_tx = 1;\n\t\telse if (strstarts(str, \"rx\"))\n\t\t\tis_tx = 0;\n\t\telse {\n\t\t\tdev_err(dev, \"Wrong dmatype %s\\n\", str);\n\t\t\tgoto err;\n\t\t}\n\t\tret = kstrtouint(str + 2, 0, &port);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = -EINVAL;\n\t\tif (port > controller->num_channels || !port)\n\t\t\tgoto err;\n\t\tif (is_tx)\n\t\t\tcppi41_channel = &controller->tx_channel[port - 1];\n\t\telse\n\t\t\tcppi41_channel = &controller->rx_channel[port - 1];\n\n\t\tcppi41_channel->controller = controller;\n\t\tcppi41_channel->port_num = port;\n\t\tcppi41_channel->is_tx = is_tx;\n\t\tINIT_LIST_HEAD(&cppi41_channel->tx_check);\n\n\t\tmusb_dma = &cppi41_channel->channel;\n\t\tmusb_dma->private_data = cppi41_channel;\n\t\tmusb_dma->status = MUSB_DMA_STATUS_FREE;\n\t\tmusb_dma->max_len = SZ_4M;\n\n\t\tdc = dma_request_chan(dev->parent, str);\n\t\tif (IS_ERR(dc)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(dc),\n\t\t\t\t\t    \"Failed to request %s.\\n\", str);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcppi41_channel->dc = dc;\n\t}\n\treturn 0;\nerr:\n\tcppi41_release_all_dma_chans(controller);\n\treturn ret;\n}\n\nvoid cppi41_dma_controller_destroy(struct dma_controller *c)\n{\n\tstruct cppi41_dma_controller *controller = container_of(c,\n\t\t\tstruct cppi41_dma_controller, controller);\n\n\thrtimer_cancel(&controller->early_tx);\n\tcppi41_dma_controller_stop(controller);\n\tkfree(controller->rx_channel);\n\tkfree(controller->tx_channel);\n\tkfree(controller);\n}\nEXPORT_SYMBOL_GPL(cppi41_dma_controller_destroy);\n\nstruct dma_controller *\ncppi41_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tstruct cppi41_dma_controller *controller;\n\tint channel_size;\n\tint ret = 0;\n\n\tif (!musb->controller->parent->of_node) {\n\t\tdev_err(musb->controller, \"Need DT for the DMA engine.\\n\");\n\t\treturn NULL;\n\t}\n\n\tcontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\n\tif (!controller)\n\t\tgoto kzalloc_fail;\n\n\thrtimer_init(&controller->early_tx, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tcontroller->early_tx.function = cppi41_recheck_tx_req;\n\tINIT_LIST_HEAD(&controller->early_tx_list);\n\n\tcontroller->controller.channel_alloc = cppi41_dma_channel_allocate;\n\tcontroller->controller.channel_release = cppi41_dma_channel_release;\n\tcontroller->controller.channel_program = cppi41_dma_channel_program;\n\tcontroller->controller.channel_abort = cppi41_dma_channel_abort;\n\tcontroller->controller.is_compatible = cppi41_is_compatible;\n\tcontroller->controller.musb = musb;\n\n\tif (musb->ops->quirks & MUSB_DA8XX) {\n\t\tcontroller->tdown_reg = DA8XX_USB_TEARDOWN;\n\t\tcontroller->autoreq_reg = DA8XX_USB_AUTOREQ;\n\t\tcontroller->set_dma_mode = da8xx_set_dma_mode;\n\t\tcontroller->num_channels = DA8XX_DMA_NUM_CHANNELS;\n\t} else {\n\t\tcontroller->tdown_reg = USB_TDOWN;\n\t\tcontroller->autoreq_reg = USB_CTRL_AUTOREQ;\n\t\tcontroller->set_dma_mode = cppi41_set_dma_mode;\n\t\tcontroller->num_channels = MUSB_DMA_NUM_CHANNELS;\n\t}\n\n\tchannel_size = controller->num_channels *\n\t\t\tsizeof(struct cppi41_dma_channel);\n\tcontroller->rx_channel = kzalloc(channel_size, GFP_KERNEL);\n\tif (!controller->rx_channel)\n\t\tgoto rx_channel_alloc_fail;\n\tcontroller->tx_channel = kzalloc(channel_size, GFP_KERNEL);\n\tif (!controller->tx_channel)\n\t\tgoto tx_channel_alloc_fail;\n\n\tret = cppi41_dma_controller_start(controller);\n\tif (ret)\n\t\tgoto plat_get_fail;\n\treturn &controller->controller;\n\nplat_get_fail:\n\tkfree(controller->tx_channel);\ntx_channel_alloc_fail:\n\tkfree(controller->rx_channel);\nrx_channel_alloc_fail:\n\tkfree(controller);\nkzalloc_fail:\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ERR_PTR(ret);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cppi41_dma_controller_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}