{
  "module_name": "tusb6010.c",
  "hash_id": "c36251a217c4d4c0b326b72f649e90704ab45367bf077c3d2fd8467fb0db38a3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/tusb6010.c",
  "human_readable_source": "\n \n\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/err.h>\n#include <linux/prefetch.h>\n#include <linux/usb.h>\n#include <linux/irq.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb/usb_phy_generic.h>\n\n#include \"musb_core.h\"\n\nstruct tusb6010_glue {\n\tstruct device\t\t*dev;\n\tstruct platform_device\t*musb;\n\tstruct platform_device\t*phy;\n\tstruct gpio_desc\t*enable;\n\tstruct gpio_desc\t*intpin;\n};\n\nstatic void tusb_musb_set_vbus(struct musb *musb, int is_on);\n\n#define TUSB_REV_MAJOR(reg_val)\t\t((reg_val >> 4) & 0xf)\n#define TUSB_REV_MINOR(reg_val)\t\t(reg_val & 0xf)\n\n \nstatic u8 tusb_get_revision(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\tdie_id;\n\tu8\t\trev;\n\n\trev = musb_readl(tbase, TUSB_DMA_CTRL_REV) & 0xff;\n\tif (TUSB_REV_MAJOR(rev) == 3) {\n\t\tdie_id = TUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase,\n\t\t\t\tTUSB_DIDR1_HI));\n\t\tif (die_id >= TUSB_DIDR1_HI_REV_31)\n\t\t\trev |= 1;\n\t}\n\n\treturn rev;\n}\n\nstatic void tusb_print_revision(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu8\t\trev;\n\n\trev = musb->tusb_revision;\n\n\tpr_info(\"tusb: %s%i.%i %s%i.%i %s%i.%i %s%i.%i %s%i %s%i.%i\\n\",\n\t\t\"prcm\",\n\t\tTUSB_REV_MAJOR(musb_readl(tbase, TUSB_PRCM_REV)),\n\t\tTUSB_REV_MINOR(musb_readl(tbase, TUSB_PRCM_REV)),\n\t\t\"int\",\n\t\tTUSB_REV_MAJOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),\n\t\tTUSB_REV_MINOR(musb_readl(tbase, TUSB_INT_CTRL_REV)),\n\t\t\"gpio\",\n\t\tTUSB_REV_MAJOR(musb_readl(tbase, TUSB_GPIO_REV)),\n\t\tTUSB_REV_MINOR(musb_readl(tbase, TUSB_GPIO_REV)),\n\t\t\"dma\",\n\t\tTUSB_REV_MAJOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),\n\t\tTUSB_REV_MINOR(musb_readl(tbase, TUSB_DMA_CTRL_REV)),\n\t\t\"dieid\",\n\t\tTUSB_DIDR1_HI_CHIP_REV(musb_readl(tbase, TUSB_DIDR1_HI)),\n\t\t\"rev\",\n\t\tTUSB_REV_MAJOR(rev), TUSB_REV_MINOR(rev));\n}\n\n#define WBUS_QUIRK_MASK\t(TUSB_PHY_OTG_CTRL_TESTM2 | TUSB_PHY_OTG_CTRL_TESTM1 \\\n\t\t\t\t| TUSB_PHY_OTG_CTRL_TESTM0)\n\n \nstatic void tusb_wbus_quirk(struct musb *musb, int enabled)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tstatic u32\tphy_otg_ctrl, phy_otg_ena;\n\tu32\t\ttmp;\n\n\tif (enabled) {\n\t\tphy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\n\t\tphy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\n\t\ttmp = TUSB_PHY_OTG_CTRL_WRPROTECT\n\t\t\t\t| phy_otg_ena | WBUS_QUIRK_MASK;\n\t\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);\n\t\ttmp = phy_otg_ena & ~WBUS_QUIRK_MASK;\n\t\ttmp |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_TESTM2;\n\t\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);\n\t\tdev_dbg(musb->controller, \"Enabled tusb wbus quirk ctrl %08x ena %08x\\n\",\n\t\t\tmusb_readl(tbase, TUSB_PHY_OTG_CTRL),\n\t\t\tmusb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));\n\t} else if (musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE)\n\t\t\t\t\t& TUSB_PHY_OTG_CTRL_TESTM2) {\n\t\ttmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl;\n\t\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL, tmp);\n\t\ttmp = TUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena;\n\t\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, tmp);\n\t\tdev_dbg(musb->controller, \"Disabled tusb wbus quirk ctrl %08x ena %08x\\n\",\n\t\t\tmusb_readl(tbase, TUSB_PHY_OTG_CTRL),\n\t\t\tmusb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE));\n\t\tphy_otg_ctrl = 0;\n\t\tphy_otg_ena = 0;\n\t}\n}\n\nstatic u32 tusb_fifo_offset(u8 epnum)\n{\n\treturn 0x200 + (epnum * 0x20);\n}\n\nstatic u32 tusb_ep_offset(u8 epnum, u16 offset)\n{\n\treturn 0x10 + offset;\n}\n\n \nstatic void tusb_ep_select(void __iomem *mbase, u8 epnum)\n{\n\tmusb_writeb(mbase, MUSB_INDEX, epnum);\n}\n\n \nstatic u8 tusb_readb(void __iomem *addr, u32 offset)\n{\n\tu16 tmp;\n\tu8 val;\n\n\ttmp = __raw_readw(addr + (offset & ~1));\n\tif (offset & 1)\n\t\tval = (tmp >> 8);\n\telse\n\t\tval = tmp & 0xff;\n\n\treturn val;\n}\n\nstatic void tusb_writeb(void __iomem *addr, u32 offset, u8 data)\n{\n\tu16 tmp;\n\n\ttmp = __raw_readw(addr + (offset & ~1));\n\tif (offset & 1)\n\t\ttmp = (data << 8) | (tmp & 0xff);\n\telse\n\t\ttmp = (tmp & 0xff00) | data;\n\n\t__raw_writew(tmp, addr + (offset & ~1));\n}\n\n \n\nstatic inline void\ntusb_fifo_write_unaligned(void __iomem *fifo, const u8 *buf, u16 len)\n{\n\tu32\t\tval;\n\tint\t\ti;\n\n\tif (len > 4) {\n\t\tfor (i = 0; i < (len >> 2); i++) {\n\t\t\tmemcpy(&val, buf, 4);\n\t\t\tmusb_writel(fifo, 0, val);\n\t\t\tbuf += 4;\n\t\t}\n\t\tlen %= 4;\n\t}\n\tif (len > 0) {\n\t\t \n\t\tval = 0;\n\t\tmemcpy(&val, buf, len);\n\t\tmusb_writel(fifo, 0, val);\n\t}\n}\n\nstatic inline void tusb_fifo_read_unaligned(void __iomem *fifo,\n\t\t\t\t\t\tvoid *buf, u16 len)\n{\n\tu32\t\tval;\n\tint\t\ti;\n\n\tif (len > 4) {\n\t\tfor (i = 0; i < (len >> 2); i++) {\n\t\t\tval = musb_readl(fifo, 0);\n\t\t\tmemcpy(buf, &val, 4);\n\t\t\tbuf += 4;\n\t\t}\n\t\tlen %= 4;\n\t}\n\tif (len > 0) {\n\t\t \n\t\tval = musb_readl(fifo, 0);\n\t\tmemcpy(buf, &val, len);\n\t}\n}\n\nstatic void tusb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf)\n{\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem\t*ep_conf = hw_ep->conf;\n\tvoid __iomem\t*fifo = hw_ep->fifo;\n\tu8\t\tepnum = hw_ep->epnum;\n\n\tprefetch(buf);\n\n\tdev_dbg(musb->controller, \"%cX ep%d fifo %p count %d buf %p\\n\",\n\t\t\t'T', epnum, fifo, len, buf);\n\n\tif (epnum)\n\t\tmusb_writel(ep_conf, TUSB_EP_TX_OFFSET,\n\t\t\tTUSB_EP_CONFIG_XFR_SIZE(len));\n\telse\n\t\tmusb_writel(ep_conf, 0, TUSB_EP0_CONFIG_DIR_TX |\n\t\t\tTUSB_EP0_CONFIG_XFR_SIZE(len));\n\n\tif (likely((0x01 & (unsigned long) buf) == 0)) {\n\n\t\t \n\t\tif ((0x02 & (unsigned long) buf) == 0) {\n\t\t\tif (len >= 4) {\n\t\t\t\tiowrite32_rep(fifo, buf, len >> 2);\n\t\t\t\tbuf += (len & ~0x03);\n\t\t\t\tlen &= 0x03;\n\t\t\t}\n\t\t} else {\n\t\t\tif (len >= 2) {\n\t\t\t\tu32 val;\n\t\t\t\tint i;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < (len >> 2); i++) {\n\t\t\t\t\tval = (u32)(*(u16 *)buf);\n\t\t\t\t\tbuf += 2;\n\t\t\t\t\tval |= (*(u16 *)buf) << 16;\n\t\t\t\t\tbuf += 2;\n\t\t\t\t\tmusb_writel(fifo, 0, val);\n\t\t\t\t}\n\t\t\t\tlen &= 0x03;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (len > 0)\n\t\ttusb_fifo_write_unaligned(fifo, buf, len);\n}\n\nstatic void tusb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *buf)\n{\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem\t*ep_conf = hw_ep->conf;\n\tvoid __iomem\t*fifo = hw_ep->fifo;\n\tu8\t\tepnum = hw_ep->epnum;\n\n\tdev_dbg(musb->controller, \"%cX ep%d fifo %p count %d buf %p\\n\",\n\t\t\t'R', epnum, fifo, len, buf);\n\n\tif (epnum)\n\t\tmusb_writel(ep_conf, TUSB_EP_RX_OFFSET,\n\t\t\tTUSB_EP_CONFIG_XFR_SIZE(len));\n\telse\n\t\tmusb_writel(ep_conf, 0, TUSB_EP0_CONFIG_XFR_SIZE(len));\n\n\tif (likely((0x01 & (unsigned long) buf) == 0)) {\n\n\t\t \n\t\tif ((0x02 & (unsigned long) buf) == 0) {\n\t\t\tif (len >= 4) {\n\t\t\t\tioread32_rep(fifo, buf, len >> 2);\n\t\t\t\tbuf += (len & ~0x03);\n\t\t\t\tlen &= 0x03;\n\t\t\t}\n\t\t} else {\n\t\t\tif (len >= 2) {\n\t\t\t\tu32 val;\n\t\t\t\tint i;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < (len >> 2); i++) {\n\t\t\t\t\tval = musb_readl(fifo, 0);\n\t\t\t\t\t*(u16 *)buf = (u16)(val & 0xffff);\n\t\t\t\t\tbuf += 2;\n\t\t\t\t\t*(u16 *)buf = (u16)(val >> 16);\n\t\t\t\t\tbuf += 2;\n\t\t\t\t}\n\t\t\t\tlen &= 0x03;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (len > 0)\n\t\ttusb_fifo_read_unaligned(fifo, buf, len);\n}\n\nstatic struct musb *the_musb;\n\n \nstatic int tusb_draw_power(struct usb_phy *x, unsigned mA)\n{\n\tstruct musb\t*musb = the_musb;\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\treg;\n\n\t \n\tif (x->otg->default_a || mA < (musb->min_power << 1))\n\t\tmA = 0;\n\n\treg = musb_readl(tbase, TUSB_PRCM_MNGMT);\n\tif (mA) {\n\t\tmusb->is_bus_powered = 1;\n\t\treg |= TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN;\n\t} else {\n\t\tmusb->is_bus_powered = 0;\n\t\treg &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);\n\t}\n\tmusb_writel(tbase, TUSB_PRCM_MNGMT, reg);\n\n\tdev_dbg(musb->controller, \"draw max %d mA VBUS\\n\", mA);\n\treturn 0;\n}\n\n \nstatic void tusb_set_clock_source(struct musb *musb, unsigned mode)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\treg;\n\n\treg = musb_readl(tbase, TUSB_PRCM_CONF);\n\treg &= ~TUSB_PRCM_CONF_SYS_CLKSEL(0x3);\n\n\t \n\tif (mode > 0)\n\t\treg |= TUSB_PRCM_CONF_SYS_CLKSEL(mode & 0x3);\n\n\tmusb_writel(tbase, TUSB_PRCM_CONF, reg);\n\n\t \n}\n\n \nstatic void tusb_allow_idle(struct musb *musb, u32 wakeup_enables)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\treg;\n\n\tif ((wakeup_enables & TUSB_PRCM_WBUS)\n\t\t\t&& (musb->tusb_revision == TUSB_REV_30))\n\t\ttusb_wbus_quirk(musb, 1);\n\n\ttusb_set_clock_source(musb, 0);\n\n\twakeup_enables |= TUSB_PRCM_WNORCS;\n\tmusb_writel(tbase, TUSB_PRCM_WAKEUP_MASK, ~wakeup_enables);\n\n\t \n\n\treg = musb_readl(tbase, TUSB_PRCM_MNGMT);\n\t \n\tif (is_host_active(musb)) {\n\t\treg |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\n\t\treg &= ~TUSB_PRCM_MNGMT_OTG_SESS_END_EN;\n\t} else {\n\t\treg |= TUSB_PRCM_MNGMT_OTG_SESS_END_EN;\n\t\treg &= ~TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\n\t}\n\treg |= TUSB_PRCM_MNGMT_PM_IDLE | TUSB_PRCM_MNGMT_DEV_IDLE;\n\tmusb_writel(tbase, TUSB_PRCM_MNGMT, reg);\n\n\tdev_dbg(musb->controller, \"idle, wake on %02x\\n\", wakeup_enables);\n}\n\n \nstatic int tusb_musb_vbus_status(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\totg_stat, prcm_mngmt;\n\tint\t\tret = 0;\n\n\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\tprcm_mngmt = musb_readl(tbase, TUSB_PRCM_MNGMT);\n\n\t \n\tif (!(prcm_mngmt & TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN)) {\n\t\tu32 tmp = prcm_mngmt;\n\t\ttmp |= TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN;\n\t\tmusb_writel(tbase, TUSB_PRCM_MNGMT, tmp);\n\t\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\t\tmusb_writel(tbase, TUSB_PRCM_MNGMT, prcm_mngmt);\n\t}\n\n\tif (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID)\n\t\tret = 1;\n\n\treturn ret;\n}\n\nstatic void musb_do_idle(struct timer_list *t)\n{\n\tstruct musb\t*musb = from_timer(musb, t, dev_timer);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tswitch (musb->xceiv->otg->state) {\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tif ((musb->a_wait_bcon != 0)\n\t\t\t&& (musb->idle_timeout == 0\n\t\t\t\t|| time_after(jiffies, musb->idle_timeout))) {\n\t\t\tdev_dbg(musb->controller, \"Nothing connected %s, turning off VBUS\\n\",\n\t\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state));\n\t\t}\n\t\tfallthrough;\n\tcase OTG_STATE_A_IDLE:\n\t\ttusb_musb_set_vbus(musb, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!musb->is_active) {\n\t\tu32\twakeups;\n\n\t\t \n\t\tif (is_host_active(musb) && (musb->port1_status >> 16))\n\t\t\tgoto done;\n\n\t\tif (!musb->gadget_driver) {\n\t\t\twakeups = 0;\n\t\t} else {\n\t\t\twakeups = TUSB_PRCM_WHOSTDISCON\n\t\t\t\t| TUSB_PRCM_WBUS\n\t\t\t\t\t| TUSB_PRCM_WVBUS;\n\t\t\twakeups |= TUSB_PRCM_WID;\n\t\t}\n\t\ttusb_allow_idle(musb, wakeups);\n\t}\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\n \nstatic void tusb_musb_try_idle(struct musb *musb, unsigned long timeout)\n{\n\tunsigned long\t\tdefault_timeout = jiffies + msecs_to_jiffies(3);\n\tstatic unsigned long\tlast_timer;\n\n\tif (timeout == 0)\n\t\ttimeout = default_timeout;\n\n\t \n\tif (musb->is_active || ((musb->a_wait_bcon == 0)\n\t\t\t&& (musb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON))) {\n\t\tdev_dbg(musb->controller, \"%s active, deleting timer\\n\",\n\t\t\tusb_otg_state_string(musb->xceiv->otg->state));\n\t\tdel_timer(&musb->dev_timer);\n\t\tlast_timer = jiffies;\n\t\treturn;\n\t}\n\n\tif (time_after(last_timer, timeout)) {\n\t\tif (!timer_pending(&musb->dev_timer))\n\t\t\tlast_timer = timeout;\n\t\telse {\n\t\t\tdev_dbg(musb->controller, \"Longer idle timer already pending, ignoring\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tlast_timer = timeout;\n\n\tdev_dbg(musb->controller, \"%s inactive, for idle timer for %lu ms\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\t(unsigned long)jiffies_to_msecs(timeout - jiffies));\n\tmod_timer(&musb->dev_timer, timeout);\n}\n\n \n#define DEVCLOCK\t\t60000000\n#define OTG_TIMER_MS(msecs)\t((msecs) \\\n\t\t? (TUSB_DEV_OTG_TIMER_VAL((DEVCLOCK/1000)*(msecs)) \\\n\t\t\t\t| TUSB_DEV_OTG_TIMER_ENABLE) \\\n\t\t: 0)\n\nstatic void tusb_musb_set_vbus(struct musb *musb, int is_on)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\tconf, prcm, timer;\n\tu8\t\tdevctl;\n\tstruct usb_otg\t*otg = musb->xceiv->otg;\n\n\t \n\n\tprcm = musb_readl(tbase, TUSB_PRCM_MNGMT);\n\tconf = musb_readl(tbase, TUSB_DEV_CONF);\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\n\tif (is_on) {\n\t\ttimer = OTG_TIMER_MS(OTG_TIME_A_WAIT_VRISE);\n\t\totg->default_a = 1;\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\n\t\tconf |= TUSB_DEV_CONF_USB_HOST_MODE;\n\t\tMUSB_HST_MODE(musb);\n\t} else {\n\t\tu32\totg_stat;\n\n\t\ttimer = 0;\n\n\t\t \n\t\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\t\tif (!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS)) {\n\t\t\tswitch (musb->xceiv->otg->state) {\n\t\t\tcase OTG_STATE_A_WAIT_VRISE:\n\t\t\tcase OTG_STATE_A_WAIT_BCON:\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\n\t\t\t\tbreak;\n\t\t\tcase OTG_STATE_A_WAIT_VFALL:\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\t\t}\n\t\t\tmusb->is_active = 0;\n\t\t\totg->default_a = 1;\n\t\t\tMUSB_HST_MODE(musb);\n\t\t} else {\n\t\t\tmusb->is_active = 0;\n\t\t\totg->default_a = 0;\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t}\n\n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\tconf &= ~TUSB_DEV_CONF_USB_HOST_MODE;\n\t}\n\tprcm &= ~(TUSB_PRCM_MNGMT_15_SW_EN | TUSB_PRCM_MNGMT_33_SW_EN);\n\n\tmusb_writel(tbase, TUSB_PRCM_MNGMT, prcm);\n\tmusb_writel(tbase, TUSB_DEV_OTG_TIMER, timer);\n\tmusb_writel(tbase, TUSB_DEV_CONF, conf);\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\tdev_dbg(musb->controller, \"VBUS %s, devctl %02x otg %3x conf %08x prcm %08x\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\tmusb_readb(musb->mregs, MUSB_DEVCTL),\n\t\tmusb_readl(tbase, TUSB_DEV_OTG_STAT),\n\t\tconf, prcm);\n}\n\n \nstatic int tusb_musb_set_mode(struct musb *musb, u8 musb_mode)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tu32\t\totg_stat, phy_otg_ctrl, phy_otg_ena, dev_conf;\n\n\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\tphy_otg_ctrl = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\n\tphy_otg_ena = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\n\tdev_conf = musb_readl(tbase, TUSB_DEV_CONF);\n\n\tswitch (musb_mode) {\n\n\tcase MUSB_HOST:\t\t \n\t\tphy_otg_ctrl &= ~TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tdev_conf |= TUSB_DEV_CONF_ID_SEL;\n\t\tdev_conf &= ~TUSB_DEV_CONF_SOFT_ID;\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\t \n\t\tphy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tdev_conf |= (TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);\n\t\tbreak;\n\tcase MUSB_OTG:\t\t \n\t\tphy_otg_ctrl |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tphy_otg_ena |= TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\t\tdev_conf &= ~(TUSB_DEV_CONF_ID_SEL | TUSB_DEV_CONF_SOFT_ID);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(musb->controller, \"Trying to set mode %i\\n\", musb_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL,\n\t\t\tTUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ctrl);\n\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE,\n\t\t\tTUSB_PHY_OTG_CTRL_WRPROTECT | phy_otg_ena);\n\tmusb_writel(tbase, TUSB_DEV_CONF, dev_conf);\n\n\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\tif ((musb_mode == MUSB_PERIPHERAL) &&\n\t\t!(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS))\n\t\t\tINFO(\"Cannot be peripheral with mini-A cable \"\n\t\t\t\"otg_stat: %08x\\n\", otg_stat);\n\n\treturn 0;\n}\n\nstatic inline unsigned long\ntusb_otg_ints(struct musb *musb, u32 int_src, void __iomem *tbase)\n{\n\tu32\t\totg_stat = musb_readl(tbase, TUSB_DEV_OTG_STAT);\n\tunsigned long\tidle_timeout = 0;\n\tstruct usb_otg\t*otg = musb->xceiv->otg;\n\n\t \n\tif ((int_src & TUSB_INT_SRC_ID_STATUS_CHNG)) {\n\t\tint\tdefault_a;\n\n\t\tdefault_a = !(otg_stat & TUSB_DEV_OTG_STAT_ID_STATUS);\n\t\tdev_dbg(musb->controller, \"Default-%c\\n\", default_a ? 'A' : 'B');\n\t\totg->default_a = default_a;\n\t\ttusb_musb_set_vbus(musb, default_a);\n\n\t\t \n\t\tif (default_a)\n\t\t\tidle_timeout = jiffies + (HZ * 3);\n\t}\n\n\t \n\tif (int_src & TUSB_INT_SRC_VBUS_SENSE_CHNG) {\n\n\t\t \n\t\tif (!otg->default_a) {\n\t\t\t \n\t\t\tmusb->port1_status &=\n\t\t\t\t~(USB_PORT_STAT_CONNECTION\n\t\t\t\t| USB_PORT_STAT_ENABLE\n\t\t\t\t| USB_PORT_STAT_LOW_SPEED\n\t\t\t\t| USB_PORT_STAT_HIGH_SPEED\n\t\t\t\t| USB_PORT_STAT_TEST\n\t\t\t\t);\n\n\t\t\tif (otg_stat & TUSB_DEV_OTG_STAT_SESS_END) {\n\t\t\t\tdev_dbg(musb->controller, \"Forcing disconnect (no interrupt)\\n\");\n\t\t\t\tif (musb->xceiv->otg->state != OTG_STATE_B_IDLE) {\n\t\t\t\t\t \n\t\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\t\t\tmusb->int_usb |= MUSB_INTR_DISCONNECT;\n\t\t\t\t}\n\t\t\t\tmusb->is_active = 0;\n\t\t\t}\n\t\t\tdev_dbg(musb->controller, \"vbus change, %s, otg %03x\\n\",\n\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state), otg_stat);\n\t\t\tidle_timeout = jiffies + (1 * HZ);\n\t\t\tschedule_delayed_work(&musb->irq_work, 0);\n\n\t\t} else   {\n\t\t\tdev_dbg(musb->controller, \"vbus change, %s, otg %03x\\n\",\n\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state), otg_stat);\n\n\t\t\tswitch (musb->xceiv->otg->state) {\n\t\t\tcase OTG_STATE_A_IDLE:\n\t\t\t\tdev_dbg(musb->controller, \"Got SRP, turning on VBUS\\n\");\n\t\t\t\tmusb_platform_set_vbus(musb, 1);\n\n\t\t\t\t \n\t\t\t\tif (musb->a_wait_bcon != 0)\n\t\t\t\t\tmusb->is_active = 0;\n\t\t\t\telse\n\t\t\t\t\tmusb->is_active = 1;\n\n\t\t\t\t \n\t\t\t\tidle_timeout = jiffies + (2 * HZ);\n\n\t\t\t\tbreak;\n\t\t\tcase OTG_STATE_A_WAIT_VRISE:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tcase OTG_STATE_A_WAIT_VFALL:\n\t\t\t\t \n\t\t\t\tif (musb->vbuserr_retry) {\n\t\t\t\t\tmusb->vbuserr_retry--;\n\t\t\t\t\ttusb_musb_set_vbus(musb, 1);\n\t\t\t\t} else {\n\t\t\t\t\tmusb->vbuserr_retry\n\t\t\t\t\t\t= VBUSERR_RETRY_COUNT;\n\t\t\t\t\ttusb_musb_set_vbus(musb, 0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (int_src & TUSB_INT_SRC_OTG_TIMEOUT) {\n\t\tu8\tdevctl;\n\n\t\tdev_dbg(musb->controller, \"%s timer, %03x\\n\",\n\t\t\tusb_otg_state_string(musb->xceiv->otg->state), otg_stat);\n\n\t\tswitch (musb->xceiv->otg->state) {\n\t\tcase OTG_STATE_A_WAIT_VRISE:\n\t\t\t \n\t\t\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\t\tif (otg_stat & TUSB_DEV_OTG_STAT_VBUS_VALID) {\n\t\t\t\tif ((devctl & MUSB_DEVCTL_VBUS)\n\t\t\t\t\t\t!= MUSB_DEVCTL_VBUS) {\n\t\t\t\t\tdev_dbg(musb->controller, \"devctl %02x\\n\", devctl);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\n\t\t\t\tmusb->is_active = 0;\n\t\t\t\tidle_timeout = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(musb->a_wait_bcon);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tERR(\"vbus too slow, devctl %02x\\n\", devctl);\n\t\t\t\ttusb_musb_set_vbus(musb, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_WAIT_BCON:\n\t\t\tif (musb->a_wait_bcon != 0)\n\t\t\t\tidle_timeout = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(musb->a_wait_bcon);\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_SUSPEND:\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_WAIT_ACON:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tschedule_delayed_work(&musb->irq_work, 0);\n\n\treturn idle_timeout;\n}\n\nstatic irqreturn_t tusb_musb_interrupt(int irq, void *__hci)\n{\n\tstruct musb\t*musb = __hci;\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tunsigned long\tflags, idle_timeout = 0;\n\tu32\t\tint_mask, int_src;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\t \n\tint_mask = musb_readl(tbase, TUSB_INT_MASK);\n\tmusb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);\n\n\tint_src = musb_readl(tbase, TUSB_INT_SRC) & ~TUSB_INT_SRC_RESERVED_BITS;\n\tdev_dbg(musb->controller, \"TUSB IRQ %08x\\n\", int_src);\n\n\tmusb->int_usb = (u8) int_src;\n\n\t \n\tif (int_src & TUSB_INT_SRC_DEV_WAKEUP) {\n\t\tu32\treg;\n\t\tu32\ti;\n\n\t\tif (musb->tusb_revision == TUSB_REV_30)\n\t\t\ttusb_wbus_quirk(musb, 0);\n\n\t\t \n\n\t\t \n\t\tfor (i = 0xf7f7f7; i > 0xf7f7f7 - 1000; i--) {\n\t\t\tmusb_writel(tbase, TUSB_SCRATCH_PAD, 0);\n\t\t\tmusb_writel(tbase, TUSB_SCRATCH_PAD, i);\n\t\t\treg = musb_readl(tbase, TUSB_SCRATCH_PAD);\n\t\t\tif (reg == i)\n\t\t\t\tbreak;\n\t\t\tdev_dbg(musb->controller, \"TUSB NOR not ready\\n\");\n\t\t}\n\n\t\t \n\t\ttusb_set_clock_source(musb, 1);\n\n\t\treg = musb_readl(tbase, TUSB_PRCM_WAKEUP_SOURCE);\n\t\tmusb_writel(tbase, TUSB_PRCM_WAKEUP_CLEAR, reg);\n\t\tif (reg & ~TUSB_PRCM_WNORCS) {\n\t\t\tmusb->is_active = 1;\n\t\t\tschedule_delayed_work(&musb->irq_work, 0);\n\t\t}\n\t\tdev_dbg(musb->controller, \"wake %sactive %02x\\n\",\n\t\t\t\tmusb->is_active ? \"\" : \"in\", reg);\n\n\t\t \n\t}\n\n\tif (int_src & TUSB_INT_SRC_USB_IP_CONN)\n\t\tdel_timer(&musb->dev_timer);\n\n\t \n\tif (int_src & (TUSB_INT_SRC_VBUS_SENSE_CHNG\n\t\t\t\t| TUSB_INT_SRC_OTG_TIMEOUT\n\t\t\t\t| TUSB_INT_SRC_ID_STATUS_CHNG))\n\t\tidle_timeout = tusb_otg_ints(musb, int_src, tbase);\n\n\t \n\tif ((int_src & TUSB_INT_SRC_TXRX_DMA_DONE)) {\n\t\tu32\tdma_src = musb_readl(tbase, TUSB_DMA_INT_SRC);\n\n\t\tdev_dbg(musb->controller, \"DMA IRQ %08x\\n\", dma_src);\n\t\tmusb_writel(tbase, TUSB_DMA_INT_CLEAR, dma_src);\n\t}\n\n\t \n\tif (int_src & (TUSB_INT_SRC_USB_IP_TX | TUSB_INT_SRC_USB_IP_RX)) {\n\t\tu32\tmusb_src = musb_readl(tbase, TUSB_USBIP_INT_SRC);\n\n\t\tmusb_writel(tbase, TUSB_USBIP_INT_CLEAR, musb_src);\n\t\tmusb->int_rx = (((musb_src >> 16) & 0xffff) << 1);\n\t\tmusb->int_tx = (musb_src & 0xffff);\n\t} else {\n\t\tmusb->int_rx = 0;\n\t\tmusb->int_tx = 0;\n\t}\n\n\tif (int_src & (TUSB_INT_SRC_USB_IP_TX | TUSB_INT_SRC_USB_IP_RX | 0xff))\n\t\tmusb_interrupt(musb);\n\n\t \n\tmusb_writel(tbase, TUSB_INT_SRC_CLEAR,\n\t\tint_src & ~TUSB_INT_MASK_RESERVED_BITS);\n\n\ttusb_musb_try_idle(musb, idle_timeout);\n\n\tmusb_writel(tbase, TUSB_INT_MASK, int_mask);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dma_off;\n\n \nstatic void tusb_musb_enable(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\n\t \n\tmusb_writel(tbase, TUSB_INT_MASK, TUSB_INT_SRC_USB_IP_SOF);\n\n\t \n\tmusb_writel(tbase, TUSB_USBIP_INT_MASK, 0);\n\tmusb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);\n\tmusb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);\n\n\t \n\tmusb_writel(tbase, TUSB_USBIP_INT_CLEAR, 0x7fffffff);\n\tmusb_writel(tbase, TUSB_DMA_INT_CLEAR, 0x7fffffff);\n\tmusb_writel(tbase, TUSB_GPIO_INT_CLEAR, 0x1ff);\n\n\t \n\tmusb_writel(tbase, TUSB_INT_SRC_CLEAR, ~TUSB_INT_MASK_RESERVED_BITS);\n\n\t \n\tmusb_writel(tbase, TUSB_INT_CTRL_CONF,\n\t\t\tTUSB_INT_CTRL_CONF_INT_RELCYC(0));\n\n\tirq_set_irq_type(musb->nIrq, IRQ_TYPE_LEVEL_LOW);\n\n\t \n\tif (!(musb_readl(tbase, TUSB_DEV_OTG_STAT)\n\t\t\t& TUSB_DEV_OTG_STAT_ID_STATUS))\n\t\tmusb_writel(tbase, TUSB_INT_SRC_SET,\n\t\t\t\tTUSB_INT_SRC_ID_STATUS_CHNG);\n\n\tif (is_dma_capable() && dma_off)\n\t\tprintk(KERN_WARNING \"%s %s: dma not reactivated\\n\",\n\t\t\t\t__FILE__, __func__);\n\telse\n\t\tdma_off = 1;\n}\n\n \nstatic void tusb_musb_disable(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\n\t \n\n\t \n\tmusb_writel(tbase, TUSB_INT_MASK, ~TUSB_INT_MASK_RESERVED_BITS);\n\tmusb_writel(tbase, TUSB_USBIP_INT_MASK, 0x7fffffff);\n\tmusb_writel(tbase, TUSB_DMA_INT_MASK, 0x7fffffff);\n\tmusb_writel(tbase, TUSB_GPIO_INT_MASK, 0x1ff);\n\n\tdel_timer(&musb->dev_timer);\n\n\tif (is_dma_capable() && !dma_off) {\n\t\tprintk(KERN_WARNING \"%s %s: dma still active\\n\",\n\t\t\t\t__FILE__, __func__);\n\t\tdma_off = 1;\n\t}\n}\n\n \nstatic void tusb_setup_cpu_interface(struct musb *musb)\n{\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\n\t \n\tmusb_writel(tbase, TUSB_PULLUP_1_CTRL, 0x0000003F);\n\n\t \n\tmusb_writel(tbase, TUSB_PULLUP_2_CTRL, 0x01FFFFFF);\n\n\t \n\tmusb_writel(tbase, TUSB_GPIO_CONF, TUSB_GPIO_CONF_DMAREQ(0x3f));\n\n\t \n\tmusb_writel(tbase, TUSB_DMA_REQ_CONF,\n\t\tTUSB_DMA_REQ_CONF_BURST_SIZE(2) |\n\t\tTUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f) |\n\t\tTUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));\n\n\t \n\tmusb_writel(tbase, TUSB_WAIT_COUNT, 1);\n}\n\nstatic int tusb_musb_start(struct musb *musb)\n{\n\tstruct tusb6010_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tvoid __iomem\t*tbase = musb->ctrl_base;\n\tunsigned long\tflags;\n\tu32\t\treg;\n\tint\t\tret;\n\n\t \n\tgpiod_set_value(glue->enable, 1);\n\n\t \n\tret = read_poll_timeout(gpiod_get_value, reg, !reg, 5000, 100000, true,\n\t\t\t\tglue->intpin);\n\tif (ret) {\n\t\tpr_err(\"tusb: Powerup response failed\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (musb_readl(tbase, TUSB_PROD_TEST_RESET) !=\n\t\tTUSB_PROD_TEST_RESET_VAL) {\n\t\tprintk(KERN_ERR \"tusb: Unable to detect TUSB6010\\n\");\n\t\tgoto err;\n\t}\n\n\tmusb->tusb_revision = tusb_get_revision(musb);\n\ttusb_print_revision(musb);\n\tif (musb->tusb_revision < 2) {\n\t\tprintk(KERN_ERR \"tusb: Unsupported TUSB6010 revision %i\\n\",\n\t\t\t\tmusb->tusb_revision);\n\t\tgoto err;\n\t}\n\n\t \n\tmusb_writel(tbase, TUSB_VLYNQ_CTRL, 8);\n\n\t \n\ttusb_set_clock_source(musb, 1);\n\n\t \n\tmusb_writel(tbase, TUSB_PRCM_MNGMT,\n\t\tTUSB_PRCM_MNGMT_VBUS_VALID_TIMER(0xa) |\n\t\tTUSB_PRCM_MNGMT_VBUS_VALID_FLT_EN |\n\t\tTUSB_PRCM_MNGMT_OTG_SESS_END_EN |\n\t\tTUSB_PRCM_MNGMT_OTG_VBUS_DET_EN |\n\t\tTUSB_PRCM_MNGMT_OTG_ID_PULLUP);\n\ttusb_setup_cpu_interface(musb);\n\n\t \n\treg = musb_readl(tbase, TUSB_PHY_OTG_CTRL_ENABLE);\n\treg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL_ENABLE, reg);\n\n\treg = musb_readl(tbase, TUSB_PHY_OTG_CTRL);\n\treg |= TUSB_PHY_OTG_CTRL_WRPROTECT | TUSB_PHY_OTG_CTRL_OTG_ID_PULLUP;\n\tmusb_writel(tbase, TUSB_PHY_OTG_CTRL, reg);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn 0;\n\nerr:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\tgpiod_set_value(glue->enable, 0);\n\tmsleep(10);\n\n\treturn -ENODEV;\n}\n\nstatic int tusb_musb_init(struct musb *musb)\n{\n\tstruct platform_device\t*pdev;\n\tstruct resource\t\t*mem;\n\tvoid __iomem\t\t*sync = NULL;\n\tint\t\t\tret;\n\n\tmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\n\tif (IS_ERR_OR_NULL(musb->xceiv))\n\t\treturn -EPROBE_DEFER;\n\n\tpdev = to_platform_device(musb->controller);\n\n\t \n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!mem) {\n\t\tpr_debug(\"no async dma resource?\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\tmusb->async = mem->start;\n\n\t \n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!mem) {\n\t\tpr_debug(\"no sync dma resource?\\n\");\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\tmusb->sync = mem->start;\n\n\tsync = ioremap(mem->start, resource_size(mem));\n\tif (!sync) {\n\t\tpr_debug(\"ioremap for sync failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\tmusb->sync_va = sync;\n\n\t \n\tmusb->mregs += TUSB_BASE_OFFSET;\n\n\tret = tusb_musb_start(musb);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"Could not start tusb6010 (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto done;\n\t}\n\tmusb->isr = tusb_musb_interrupt;\n\n\tmusb->xceiv->set_power = tusb_draw_power;\n\tthe_musb = musb;\n\n\ttimer_setup(&musb->dev_timer, musb_do_idle, 0);\n\ndone:\n\tif (ret < 0) {\n\t\tif (sync)\n\t\t\tiounmap(sync);\n\n\t\tusb_put_phy(musb->xceiv);\n\t}\n\treturn ret;\n}\n\nstatic int tusb_musb_exit(struct musb *musb)\n{\n\tstruct tusb6010_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tdel_timer_sync(&musb->dev_timer);\n\tthe_musb = NULL;\n\n\tgpiod_set_value(glue->enable, 0);\n\tmsleep(10);\n\n\tiounmap(musb->sync_va);\n\n\tusb_put_phy(musb->xceiv);\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops tusb_ops = {\n\t.quirks\t\t= MUSB_DMA_TUSB_OMAP | MUSB_IN_TUSB |\n\t\t\t  MUSB_G_NO_SKB_RESERVE,\n\t.init\t\t= tusb_musb_init,\n\t.exit\t\t= tusb_musb_exit,\n\n\t.ep_offset\t= tusb_ep_offset,\n\t.ep_select\t= tusb_ep_select,\n\t.fifo_offset\t= tusb_fifo_offset,\n\t.readb\t\t= tusb_readb,\n\t.writeb\t\t= tusb_writeb,\n\t.read_fifo\t= tusb_read_fifo,\n\t.write_fifo\t= tusb_write_fifo,\n#ifdef CONFIG_USB_TUSB_OMAP_DMA\n\t.dma_init\t= tusb_dma_controller_create,\n\t.dma_exit\t= tusb_dma_controller_destroy,\n#endif\n\t.enable\t\t= tusb_musb_enable,\n\t.disable\t= tusb_musb_disable,\n\n\t.set_mode\t= tusb_musb_set_mode,\n\t.try_idle\t= tusb_musb_try_idle,\n\n\t.vbus_status\t= tusb_musb_vbus_status,\n\t.set_vbus\t= tusb_musb_set_vbus,\n};\n\nstatic const struct platform_device_info tusb_dev_info = {\n\t.name\t\t= \"musb-hdrc\",\n\t.id\t\t= PLATFORM_DEVID_AUTO,\n\t.dma_mask\t= DMA_BIT_MASK(32),\n};\n\nstatic int tusb_probe(struct platform_device *pdev)\n{\n\tstruct resource musb_resources[3];\n\tstruct musb_hdrc_platform_data\t*pdata = dev_get_platdata(&pdev->dev);\n\tstruct platform_device\t\t*musb;\n\tstruct tusb6010_glue\t\t*glue;\n\tstruct platform_device_info\tpinfo;\n\tint\t\t\t\tret;\n\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev\t\t\t= &pdev->dev;\n\n\tglue->enable = devm_gpiod_get(glue->dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(glue->enable))\n\t\treturn dev_err_probe(glue->dev, PTR_ERR(glue->enable),\n\t\t\t\t     \"could not obtain power on/off GPIO\\n\");\n\tglue->intpin = devm_gpiod_get(glue->dev, \"int\", GPIOD_IN);\n\tif (IS_ERR(glue->intpin))\n\t\treturn dev_err_probe(glue->dev, PTR_ERR(glue->intpin),\n\t\t\t\t     \"could not obtain INT GPIO\\n\");\n\n\tpdata->platform_ops\t\t= &tusb_ops;\n\n\tusb_phy_generic_register();\n\tplatform_set_drvdata(pdev, glue);\n\n\tmemset(musb_resources, 0x00, sizeof(*musb_resources) *\n\t\t\tARRAY_SIZE(musb_resources));\n\n\tmusb_resources[0].name = pdev->resource[0].name;\n\tmusb_resources[0].start = pdev->resource[0].start;\n\tmusb_resources[0].end = pdev->resource[0].end;\n\tmusb_resources[0].flags = pdev->resource[0].flags;\n\n\tmusb_resources[1].name = pdev->resource[1].name;\n\tmusb_resources[1].start = pdev->resource[1].start;\n\tmusb_resources[1].end = pdev->resource[1].end;\n\tmusb_resources[1].flags = pdev->resource[1].flags;\n\n\tmusb_resources[2] = DEFINE_RES_IRQ_NAMED(gpiod_to_irq(glue->intpin), \"mc\");\n\n\tpinfo = tusb_dev_info;\n\tpinfo.parent = &pdev->dev;\n\tpinfo.res = musb_resources;\n\tpinfo.num_res = ARRAY_SIZE(musb_resources);\n\tpinfo.data = pdata;\n\tpinfo.size_data = sizeof(*pdata);\n\n\tglue->musb = musb = platform_device_register_full(&pinfo);\n\tif (IS_ERR(musb)) {\n\t\tret = PTR_ERR(musb);\n\t\tdev_err(&pdev->dev, \"failed to register musb device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void tusb_remove(struct platform_device *pdev)\n{\n\tstruct tusb6010_glue\t\t*glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->musb);\n\tusb_phy_generic_unregister(glue->phy);\n}\n\nstatic struct platform_driver tusb_driver = {\n\t.probe\t\t= tusb_probe,\n\t.remove_new\t= tusb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"musb-tusb\",\n\t},\n};\n\nMODULE_DESCRIPTION(\"TUSB6010 MUSB Glue Layer\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_platform_driver(tusb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}