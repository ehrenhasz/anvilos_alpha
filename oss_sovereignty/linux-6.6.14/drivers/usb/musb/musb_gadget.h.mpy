{
  "module_name": "musb_gadget.h",
  "hash_id": "01ec48300702a889516ec1a3cdafa3b8b0011203de0b8b3f5647ade5bd397d5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_gadget.h",
  "human_readable_source": " \n \n\n#ifndef __MUSB_GADGET_H\n#define __MUSB_GADGET_H\n\n#include <linux/list.h>\n\n#if IS_ENABLED(CONFIG_USB_MUSB_GADGET) || IS_ENABLED(CONFIG_USB_MUSB_DUAL_ROLE)\nextern irqreturn_t musb_g_ep0_irq(struct musb *);\nextern void musb_g_tx(struct musb *, u8);\nextern void musb_g_rx(struct musb *, u8);\nextern void musb_g_reset(struct musb *);\nextern void musb_g_suspend(struct musb *);\nextern void musb_g_resume(struct musb *);\nextern void musb_g_wakeup(struct musb *);\nextern void musb_g_disconnect(struct musb *);\nextern void musb_gadget_cleanup(struct musb *);\nextern int musb_gadget_setup(struct musb *);\n\n#else\nstatic inline irqreturn_t musb_g_ep0_irq(struct musb *musb)\n{\n\treturn 0;\n}\n\nstatic inline void musb_g_tx(struct musb *musb, u8 epnum)\t{}\nstatic inline void musb_g_rx(struct musb *musb, u8 epnum)\t{}\nstatic inline void musb_g_reset(struct musb *musb)\t\t{}\nstatic inline void musb_g_suspend(struct musb *musb)\t\t{}\nstatic inline void musb_g_resume(struct musb *musb)\t\t{}\nstatic inline void musb_g_wakeup(struct musb *musb)\t\t{}\nstatic inline void musb_g_disconnect(struct musb *musb)\t\t{}\nstatic inline void musb_gadget_cleanup(struct musb *musb)\t{}\nstatic inline int musb_gadget_setup(struct musb *musb)\n{\n\treturn 0;\n}\n#endif\n\nenum buffer_map_state {\n\tUN_MAPPED = 0,\n\tPRE_MAPPED,\n\tMUSB_MAPPED\n};\n\nstruct musb_request {\n\tstruct usb_request\trequest;\n\tstruct list_head\tlist;\n\tstruct musb_ep\t\t*ep;\n\tstruct musb\t\t*musb;\n\tu8 tx;\t\t\t \n\tu8 epnum;\n\tenum buffer_map_state map_state;\n};\n\n#define to_musb_request(r)\tcontainer_of((r), struct musb_request, request)\n\nextern struct usb_request *\nmusb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);\nextern void musb_free_request(struct usb_ep *ep, struct usb_request *req);\n\n\n \nstruct musb_ep {\n\t \n\tstruct usb_ep\t\t\tend_point;\n\tchar\t\t\t\tname[12];\n\tstruct musb_hw_ep\t\t*hw_ep;\n\tstruct musb\t\t\t*musb;\n\tu8\t\t\t\tcurrent_epnum;\n\n\t \n\tu8\t\t\t\ttype;\n\tu8\t\t\t\tis_in;\n\tu16\t\t\t\tpacket_sz;\n\tconst struct usb_endpoint_descriptor\t*desc;\n\tstruct dma_channel\t\t*dma;\n\n\t \n\tstruct list_head\t\treq_list;\n\n\tu8\t\t\t\twedged;\n\n\t \n\tu8\t\t\t\tbusy;\n\n\tu8\t\t\t\thb_mult;\n};\n\n#define to_musb_ep(ep)\tcontainer_of((ep), struct musb_ep, end_point)\n\nstatic inline struct musb_request *next_request(struct musb_ep *ep)\n{\n\tstruct list_head\t*queue = &ep->req_list;\n\n\tif (list_empty(queue))\n\t\treturn NULL;\n\treturn container_of(queue->next, struct musb_request, list);\n}\n\nextern const struct usb_ep_ops musb_g_ep0_ops;\n\nextern void musb_g_giveback(struct musb_ep *, struct usb_request *, int);\n\nextern void musb_ep_restart(struct musb *, struct musb_request *);\n\n#endif\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}