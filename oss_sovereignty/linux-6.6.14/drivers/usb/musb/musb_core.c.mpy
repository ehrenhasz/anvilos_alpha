{
  "module_name": "musb_core.c",
  "hash_id": "724e939868bb839ffb4a6d31ca18f53dd17892de6e0319efe4daa769036bcad3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_core.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/kobject.h>\n#include <linux/prefetch.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb.h>\n#include <linux/usb/of.h>\n\n#include \"musb_core.h\"\n#include \"musb_trace.h\"\n\n#define TA_WAIT_BCON(m) max_t(int, (m)->a_wait_bcon, OTG_TIME_A_WAIT_BCON)\n\n\n#define DRIVER_AUTHOR \"Mentor Graphics, Texas Instruments, Nokia\"\n#define DRIVER_DESC \"Inventra Dual-Role USB Controller Driver\"\n\n#define MUSB_VERSION \"6.0\"\n\n#define DRIVER_INFO DRIVER_DESC \", v\" MUSB_VERSION\n\n#define MUSB_DRIVER_NAME \"musb-hdrc\"\nconst char musb_driver_name[] = MUSB_DRIVER_NAME;\n\nMODULE_DESCRIPTION(DRIVER_INFO);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" MUSB_DRIVER_NAME);\n\n\n \n\nstatic inline struct musb *dev_to_musb(struct device *dev)\n{\n\treturn dev_get_drvdata(dev);\n}\n\nenum musb_mode musb_get_mode(struct device *dev)\n{\n\tenum usb_dr_mode mode;\n\n\tmode = usb_get_dr_mode(dev);\n\tswitch (mode) {\n\tcase USB_DR_MODE_HOST:\n\t\treturn MUSB_HOST;\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\treturn MUSB_PERIPHERAL;\n\tcase USB_DR_MODE_OTG:\n\tcase USB_DR_MODE_UNKNOWN:\n\tdefault:\n\t\treturn MUSB_OTG;\n\t}\n}\nEXPORT_SYMBOL_GPL(musb_get_mode);\n\n \n\nstatic int musb_ulpi_read(struct usb_phy *phy, u32 reg)\n{\n\tvoid __iomem *addr = phy->io_priv;\n\tint\ti = 0;\n\tu8\tr;\n\tu8\tpower;\n\tint\tret;\n\n\tpm_runtime_get_sync(phy->io_dev);\n\n\t \n\tpower = musb_readb(addr, MUSB_POWER);\n\tpower &= ~MUSB_POWER_SUSPENDM;\n\tmusb_writeb(addr, MUSB_POWER, power);\n\n\t \n\n\tmusb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);\n\tmusb_writeb(addr, MUSB_ULPI_REG_CONTROL,\n\t\t\tMUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);\n\n\twhile (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)\n\t\t\t\t& MUSB_ULPI_REG_CMPLT)) {\n\t\ti++;\n\t\tif (i == 10000) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\tr = musb_readb(addr, MUSB_ULPI_REG_CONTROL);\n\tr &= ~MUSB_ULPI_REG_CMPLT;\n\tmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, r);\n\n\tret = musb_readb(addr, MUSB_ULPI_REG_DATA);\n\nout:\n\tpm_runtime_put(phy->io_dev);\n\n\treturn ret;\n}\n\nstatic int musb_ulpi_write(struct usb_phy *phy, u32 val, u32 reg)\n{\n\tvoid __iomem *addr = phy->io_priv;\n\tint\ti = 0;\n\tu8\tr = 0;\n\tu8\tpower;\n\tint\tret = 0;\n\n\tpm_runtime_get_sync(phy->io_dev);\n\n\t \n\tpower = musb_readb(addr, MUSB_POWER);\n\tpower &= ~MUSB_POWER_SUSPENDM;\n\tmusb_writeb(addr, MUSB_POWER, power);\n\n\tmusb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);\n\tmusb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)val);\n\tmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);\n\n\twhile (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)\n\t\t\t\t& MUSB_ULPI_REG_CMPLT)) {\n\t\ti++;\n\t\tif (i == 10000) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tr = musb_readb(addr, MUSB_ULPI_REG_CONTROL);\n\tr &= ~MUSB_ULPI_REG_CMPLT;\n\tmusb_writeb(addr, MUSB_ULPI_REG_CONTROL, r);\n\nout:\n\tpm_runtime_put(phy->io_dev);\n\n\treturn ret;\n}\n\nstatic struct usb_phy_io_ops musb_ulpi_access = {\n\t.read = musb_ulpi_read,\n\t.write = musb_ulpi_write,\n};\n\n \n\nstatic u32 musb_default_fifo_offset(u8 epnum)\n{\n\treturn 0x20 + (epnum * 4);\n}\n\n \nstatic void musb_flat_ep_select(void __iomem *mbase, u8 epnum)\n{\n}\n\nstatic u32 musb_flat_ep_offset(u8 epnum, u16 offset)\n{\n\treturn 0x100 + (0x10 * epnum) + offset;\n}\n\n \nstatic void musb_indexed_ep_select(void __iomem *mbase, u8 epnum)\n{\n\tmusb_writeb(mbase, MUSB_INDEX, epnum);\n}\n\nstatic u32 musb_indexed_ep_offset(u8 epnum, u16 offset)\n{\n\treturn 0x10 + offset;\n}\n\nstatic u32 musb_default_busctl_offset(u8 epnum, u16 offset)\n{\n\treturn 0x80 + (0x08 * epnum) + offset;\n}\n\nstatic u8 musb_default_readb(void __iomem *addr, u32 offset)\n{\n\tu8 data =  __raw_readb(addr + offset);\n\n\ttrace_musb_readb(__builtin_return_address(0), addr, offset, data);\n\treturn data;\n}\n\nstatic void musb_default_writeb(void __iomem *addr, u32 offset, u8 data)\n{\n\ttrace_musb_writeb(__builtin_return_address(0), addr, offset, data);\n\t__raw_writeb(data, addr + offset);\n}\n\nstatic u16 musb_default_readw(void __iomem *addr, u32 offset)\n{\n\tu16 data = __raw_readw(addr + offset);\n\n\ttrace_musb_readw(__builtin_return_address(0), addr, offset, data);\n\treturn data;\n}\n\nstatic void musb_default_writew(void __iomem *addr, u32 offset, u16 data)\n{\n\ttrace_musb_writew(__builtin_return_address(0), addr, offset, data);\n\t__raw_writew(data, addr + offset);\n}\n\nstatic u16 musb_default_get_toggle(struct musb_qh *qh, int is_out)\n{\n\tvoid __iomem *epio = qh->hw_ep->regs;\n\tu16 csr;\n\n\tif (is_out)\n\t\tcsr = musb_readw(epio, MUSB_TXCSR) & MUSB_TXCSR_H_DATATOGGLE;\n\telse\n\t\tcsr = musb_readw(epio, MUSB_RXCSR) & MUSB_RXCSR_H_DATATOGGLE;\n\n\treturn csr;\n}\n\nstatic u16 musb_default_set_toggle(struct musb_qh *qh, int is_out,\n\t\t\t\t   struct urb *urb)\n{\n\tu16 csr;\n\tu16 toggle;\n\n\ttoggle = usb_gettoggle(urb->dev, qh->epnum, is_out);\n\n\tif (is_out)\n\t\tcsr = toggle ? (MUSB_TXCSR_H_WR_DATATOGGLE\n\t\t\t\t| MUSB_TXCSR_H_DATATOGGLE)\n\t\t\t\t: MUSB_TXCSR_CLRDATATOG;\n\telse\n\t\tcsr = toggle ? (MUSB_RXCSR_H_WR_DATATOGGLE\n\t\t\t\t| MUSB_RXCSR_H_DATATOGGLE) : 0;\n\n\treturn csr;\n}\n\n \nstatic void musb_default_write_fifo(struct musb_hw_ep *hw_ep, u16 len,\n\t\t\t\t    const u8 *src)\n{\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem *fifo = hw_ep->fifo;\n\n\tif (unlikely(len == 0))\n\t\treturn;\n\n\tprefetch((u8 *)src);\n\n\tdev_dbg(musb->controller, \"%cX ep%d fifo %p count %d buf %p\\n\",\n\t\t\t'T', hw_ep->epnum, fifo, len, src);\n\n\t \n\tif (likely((0x01 & (unsigned long) src) == 0)) {\n\t\tu16\tindex = 0;\n\n\t\t \n\t\tif ((0x02 & (unsigned long) src) == 0) {\n\t\t\tif (len >= 4) {\n\t\t\t\tiowrite32_rep(fifo, src + index, len >> 2);\n\t\t\t\tindex += len & ~0x03;\n\t\t\t}\n\t\t\tif (len & 0x02) {\n\t\t\t\t__raw_writew(*(u16 *)&src[index], fifo);\n\t\t\t\tindex += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tif (len >= 2) {\n\t\t\t\tiowrite16_rep(fifo, src + index, len >> 1);\n\t\t\t\tindex += len & ~0x01;\n\t\t\t}\n\t\t}\n\t\tif (len & 0x01)\n\t\t\t__raw_writeb(src[index], fifo);\n\t} else  {\n\t\t \n\t\tiowrite8_rep(fifo, src, len);\n\t}\n}\n\n \nstatic void musb_default_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\n{\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem *fifo = hw_ep->fifo;\n\n\tif (unlikely(len == 0))\n\t\treturn;\n\n\tdev_dbg(musb->controller, \"%cX ep%d fifo %p count %d buf %p\\n\",\n\t\t\t'R', hw_ep->epnum, fifo, len, dst);\n\n\t \n\tif (likely((0x01 & (unsigned long) dst) == 0)) {\n\t\tu16\tindex = 0;\n\n\t\t \n\t\tif ((0x02 & (unsigned long) dst) == 0) {\n\t\t\tif (len >= 4) {\n\t\t\t\tioread32_rep(fifo, dst, len >> 2);\n\t\t\t\tindex = len & ~0x03;\n\t\t\t}\n\t\t\tif (len & 0x02) {\n\t\t\t\t*(u16 *)&dst[index] = __raw_readw(fifo);\n\t\t\t\tindex += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tif (len >= 2) {\n\t\t\t\tioread16_rep(fifo, dst, len >> 1);\n\t\t\t\tindex = len & ~0x01;\n\t\t\t}\n\t\t}\n\t\tif (len & 0x01)\n\t\t\tdst[index] = __raw_readb(fifo);\n\t} else  {\n\t\t \n\t\tioread8_rep(fifo, dst, len);\n\t}\n}\n\n \nu8 (*musb_readb)(void __iomem *addr, u32 offset);\nEXPORT_SYMBOL_GPL(musb_readb);\n\nvoid (*musb_writeb)(void __iomem *addr, u32 offset, u8 data);\nEXPORT_SYMBOL_GPL(musb_writeb);\n\nu8 (*musb_clearb)(void __iomem *addr, u32 offset);\nEXPORT_SYMBOL_GPL(musb_clearb);\n\nu16 (*musb_readw)(void __iomem *addr, u32 offset);\nEXPORT_SYMBOL_GPL(musb_readw);\n\nvoid (*musb_writew)(void __iomem *addr, u32 offset, u16 data);\nEXPORT_SYMBOL_GPL(musb_writew);\n\nu16 (*musb_clearw)(void __iomem *addr, u32 offset);\nEXPORT_SYMBOL_GPL(musb_clearw);\n\nu32 musb_readl(void __iomem *addr, u32 offset)\n{\n\tu32 data = __raw_readl(addr + offset);\n\n\ttrace_musb_readl(__builtin_return_address(0), addr, offset, data);\n\treturn data;\n}\nEXPORT_SYMBOL_GPL(musb_readl);\n\nvoid musb_writel(void __iomem *addr, u32 offset, u32 data)\n{\n\ttrace_musb_writel(__builtin_return_address(0), addr, offset, data);\n\t__raw_writel(data, addr + offset);\n}\nEXPORT_SYMBOL_GPL(musb_writel);\n\n#ifndef CONFIG_MUSB_PIO_ONLY\nstruct dma_controller *\n(*musb_dma_controller_create)(struct musb *musb, void __iomem *base);\nEXPORT_SYMBOL(musb_dma_controller_create);\n\nvoid (*musb_dma_controller_destroy)(struct dma_controller *c);\nEXPORT_SYMBOL(musb_dma_controller_destroy);\n#endif\n\n \nvoid musb_read_fifo(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\n{\n\treturn hw_ep->musb->io.read_fifo(hw_ep, len, dst);\n}\n\nvoid musb_write_fifo(struct musb_hw_ep *hw_ep, u16 len, const u8 *src)\n{\n\treturn hw_ep->musb->io.write_fifo(hw_ep, len, src);\n}\n\nstatic u8 musb_read_devctl(struct musb *musb)\n{\n\treturn musb_readb(musb->mregs, MUSB_DEVCTL);\n}\n\n \nint musb_set_host(struct musb *musb)\n{\n\tint error = 0;\n\tu8 devctl;\n\n\tif (!musb)\n\t\treturn -EINVAL;\n\n\tdevctl = musb_read_devctl(musb);\n\tif (!(devctl & MUSB_DEVCTL_BDEVICE)) {\n\t\ttrace_musb_state(musb, devctl, \"Already in host mode\");\n\t\tgoto init_data;\n\t}\n\n\tdevctl |= MUSB_DEVCTL_SESSION;\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\terror = readx_poll_timeout(musb_read_devctl, musb, devctl,\n\t\t\t\t   !(devctl & MUSB_DEVCTL_BDEVICE), 5000,\n\t\t\t\t   1000000);\n\tif (error) {\n\t\tdev_err(musb->controller, \"%s: could not set host: %02x\\n\",\n\t\t\t__func__, devctl);\n\n\t\treturn error;\n\t}\n\n\tdevctl = musb_read_devctl(musb);\n\ttrace_musb_state(musb, devctl, \"Host mode set\");\n\ninit_data:\n\tmusb->is_active = 1;\n\tmusb_set_state(musb, OTG_STATE_A_IDLE);\n\tMUSB_HST_MODE(musb);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(musb_set_host);\n\n \nint musb_set_peripheral(struct musb *musb)\n{\n\tint error = 0;\n\tu8 devctl;\n\n\tif (!musb)\n\t\treturn -EINVAL;\n\n\tdevctl = musb_read_devctl(musb);\n\tif (devctl & MUSB_DEVCTL_BDEVICE) {\n\t\ttrace_musb_state(musb, devctl, \"Already in peripheral mode\");\n\t\tgoto init_data;\n\t}\n\n\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\terror = readx_poll_timeout(musb_read_devctl, musb, devctl,\n\t\t\t\t   devctl & MUSB_DEVCTL_BDEVICE, 5000,\n\t\t\t\t   1000000);\n\tif (error) {\n\t\tdev_err(musb->controller, \"%s: could not set peripheral: %02x\\n\",\n\t\t\t__func__, devctl);\n\n\t\treturn error;\n\t}\n\n\tdevctl = musb_read_devctl(musb);\n\ttrace_musb_state(musb, devctl, \"Peripheral mode set\");\n\ninit_data:\n\tmusb->is_active = 0;\n\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\tMUSB_DEV_MODE(musb);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(musb_set_peripheral);\n\n \n\n \nstatic const u8 musb_test_packet[53] = {\n\t \n\n\t \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n\t \n\t0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,\n\t \n\t0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t \n\t0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd,\n\t \n\t0xfc, 0x7e, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0x7e\n\n\t \n};\n\nvoid musb_load_testpacket(struct musb *musb)\n{\n\tvoid __iomem\t*regs = musb->endpoints[0].regs;\n\n\tmusb_ep_select(musb->mregs, 0);\n\tmusb_write_fifo(musb->control_ep,\n\t\t\tsizeof(musb_test_packet), musb_test_packet);\n\tmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_TXPKTRDY);\n}\n\n \n\n \nstatic void musb_otg_timer_func(struct timer_list *t)\n{\n\tstruct musb\t*musb = from_timer(musb, t, otg_timer);\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\tmusb_dbg(musb,\n\t\t\t\"HNP: b_wait_acon timeout; back to b_peripheral\");\n\t\tmusb_g_disconnect(musb);\n\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tmusb->is_active = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_SUSPEND:\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tmusb_dbg(musb, \"HNP: %s timeout\",\n\t\t\t musb_otg_state_string(musb));\n\t\tmusb_platform_set_vbus(musb, 0);\n\t\tmusb_set_state(musb, OTG_STATE_A_WAIT_VFALL);\n\t\tbreak;\n\tdefault:\n\t\tmusb_dbg(musb, \"HNP: Unhandled mode %s\",\n\t\t\t musb_otg_state_string(musb));\n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\n \nvoid musb_hnp_stop(struct musb *musb)\n{\n\tstruct usb_hcd\t*hcd = musb->hcd;\n\tvoid __iomem\t*mbase = musb->mregs;\n\tu8\treg;\n\n\tmusb_dbg(musb, \"HNP: stop from %s\", musb_otg_state_string(musb));\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\tmusb_g_disconnect(musb);\n\t\tmusb_dbg(musb, \"HNP: back to %s\", musb_otg_state_string(musb));\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\tmusb_dbg(musb, \"HNP: Disabling HR\");\n\t\tif (hcd)\n\t\t\thcd->self.is_b_host = 0;\n\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tMUSB_DEV_MODE(musb);\n\t\treg = musb_readb(mbase, MUSB_POWER);\n\t\treg |= MUSB_POWER_SUSPENDM;\n\t\tmusb_writeb(mbase, MUSB_POWER, reg);\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tmusb_dbg(musb, \"HNP: Stopping in unknown state %s\",\n\t\t\t musb_otg_state_string(musb));\n\t}\n\n\t \n\tmusb->port1_status &= ~(USB_PORT_STAT_C_CONNECTION << 16);\n}\n\nstatic void musb_recover_from_babble(struct musb *musb);\n\nstatic void musb_handle_intr_resume(struct musb *musb, u8 devctl)\n{\n\tmusb_dbg(musb, \"RESUME (%s)\", musb_otg_state_string(musb));\n\n\tif (devctl & MUSB_DEVCTL_HM) {\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_SUSPEND:\n\t\t\t \n\t\t\tmusb->port1_status |=\n\t\t\t\t\t(USB_PORT_STAT_C_SUSPEND << 16)\n\t\t\t\t\t| MUSB_PORT_STAT_RESUME;\n\t\t\tmusb->rh_timer = jiffies\n\t\t\t\t+ msecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\tmusb_set_state(musb, OTG_STATE_A_HOST);\n\t\t\tmusb->is_active = 1;\n\t\t\tmusb_host_resume_root_hub(musb);\n\t\t\tschedule_delayed_work(&musb->finish_resume_work,\n\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT));\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_WAIT_ACON:\n\t\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\t\tmusb->is_active = 1;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARNING(\"bogus %s RESUME (%s)\\n\",\n\t\t\t\t\"host\",\n\t\t\t\tmusb_otg_state_string(musb));\n\t\t}\n\t} else {\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_SUSPEND:\n\t\t\t \n\t\t\tmusb_set_state(musb, OTG_STATE_A_HOST);\n\t\t\tmusb_host_resume_root_hub(musb);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_WAIT_ACON:\n\t\tcase OTG_STATE_B_PERIPHERAL:\n\t\t\t \n\t\t\tif ((devctl & MUSB_DEVCTL_VBUS)\n\t\t\t\t\t!= (3 << MUSB_DEVCTL_VBUS_SHIFT)\n\t\t\t\t\t) {\n\t\t\t\tmusb->int_usb |= MUSB_INTR_DISCONNECT;\n\t\t\t\tmusb->int_usb &= ~MUSB_INTR_SUSPEND;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmusb_g_resume(musb);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_IDLE:\n\t\t\tmusb->int_usb &= ~MUSB_INTR_SUSPEND;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARNING(\"bogus %s RESUME (%s)\\n\",\n\t\t\t\t\"peripheral\",\n\t\t\t\tmusb_otg_state_string(musb));\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t musb_handle_intr_sessreq(struct musb *musb, u8 devctl)\n{\n\tvoid __iomem *mbase = musb->mregs;\n\n\tif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS\n\t\t\t&& (devctl & MUSB_DEVCTL_BDEVICE)) {\n\t\tmusb_dbg(musb, \"SessReq while on B state\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmusb_dbg(musb, \"SESSION_REQUEST (%s)\", musb_otg_state_string(musb));\n\n\t \n\tmusb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);\n\tmusb->ep0_stage = MUSB_EP0_START;\n\tmusb_set_state(musb, OTG_STATE_A_IDLE);\n\tMUSB_HST_MODE(musb);\n\tmusb_platform_set_vbus(musb, 1);\n\n\treturn IRQ_NONE;\n}\n\nstatic void musb_handle_intr_vbuserr(struct musb *musb, u8 devctl)\n{\n\tint\tignore = 0;\n\n\t \n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_HOST:\n\t\t \n\tcase OTG_STATE_A_WAIT_BCON:\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\tif (musb->vbuserr_retry) {\n\t\t\tvoid __iomem *mbase = musb->mregs;\n\n\t\t\tmusb->vbuserr_retry--;\n\t\t\tignore = 1;\n\t\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\t\tmusb_writeb(mbase, MUSB_DEVCTL, devctl);\n\t\t} else {\n\t\t\tmusb->port1_status |=\n\t\t\t\t  USB_PORT_STAT_OVERCURRENT\n\t\t\t\t| (USB_PORT_STAT_C_OVERCURRENT << 16);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdev_printk(ignore ? KERN_DEBUG : KERN_ERR, musb->controller,\n\t\t\t\"VBUS_ERROR in %s (%02x, %s), retry #%d, port1 %08x\\n\",\n\t\t\tmusb_otg_state_string(musb),\n\t\t\tdevctl,\n\t\t\t({ char *s;\n\t\t\tswitch (devctl & MUSB_DEVCTL_VBUS) {\n\t\t\tcase 0 << MUSB_DEVCTL_VBUS_SHIFT:\n\t\t\t\ts = \"<SessEnd\"; break;\n\t\t\tcase 1 << MUSB_DEVCTL_VBUS_SHIFT:\n\t\t\t\ts = \"<AValid\"; break;\n\t\t\tcase 2 << MUSB_DEVCTL_VBUS_SHIFT:\n\t\t\t\ts = \"<VBusValid\"; break;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\ts = \"VALID\"; break;\n\t\t\t} s; }),\n\t\t\tVBUSERR_RETRY_COUNT - musb->vbuserr_retry,\n\t\t\tmusb->port1_status);\n\n\t \n\tif (!ignore)\n\t\tmusb_platform_set_vbus(musb, 0);\n}\n\nstatic void musb_handle_intr_suspend(struct musb *musb, u8 devctl)\n{\n\tmusb_dbg(musb, \"SUSPEND (%s) devctl %02x\",\n\t\t musb_otg_state_string(musb), devctl);\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\t \n\t\tmusb_hnp_stop(musb);\n\t\tmusb_host_resume_root_hub(musb);\n\t\tmusb_root_disconnect(musb);\n\t\tmusb_platform_try_idle(musb, jiffies\n\t\t\t\t+ msecs_to_jiffies(musb->a_wait_bcon\n\t\t\t\t\t? : OTG_TIME_A_WAIT_BCON));\n\n\t\tbreak;\n\tcase OTG_STATE_B_IDLE:\n\t\tif (!musb->is_active)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tmusb_g_suspend(musb);\n\t\tmusb->is_active = musb->g.b_hnp_enable;\n\t\tif (musb->is_active) {\n\t\t\tmusb_set_state(musb, OTG_STATE_B_WAIT_ACON);\n\t\t\tmusb_dbg(musb, \"HNP: Setting timer for b_ase0_brst\");\n\t\t\tmod_timer(&musb->otg_timer, jiffies\n\t\t\t\t+ msecs_to_jiffies(\n\t\t\t\t\t\tOTG_TIME_B_ASE0_BRST));\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tif (musb->a_wait_bcon != 0)\n\t\t\tmusb_platform_try_idle(musb, jiffies\n\t\t\t\t+ msecs_to_jiffies(musb->a_wait_bcon));\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\tmusb_set_state(musb, OTG_STATE_A_SUSPEND);\n\t\tmusb->is_active = musb->hcd->self.b_hnp_enable;\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\t \n\t\tmusb_dbg(musb, \"REVISIT: SUSPEND as B_HOST\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tmusb->is_active = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void musb_handle_intr_connect(struct musb *musb, u8 devctl, u8 int_usb)\n{\n\tstruct usb_hcd *hcd = musb->hcd;\n\n\tmusb->is_active = 1;\n\tmusb->ep0_stage = MUSB_EP0_START;\n\n\tmusb->intrtxe = musb->epmask;\n\tmusb_writew(musb->mregs, MUSB_INTRTXE, musb->intrtxe);\n\tmusb->intrrxe = musb->epmask & 0xfffe;\n\tmusb_writew(musb->mregs, MUSB_INTRRXE, musb->intrrxe);\n\tmusb_writeb(musb->mregs, MUSB_INTRUSBE, 0xf7);\n\tmusb->port1_status &= ~(USB_PORT_STAT_LOW_SPEED\n\t\t\t\t|USB_PORT_STAT_HIGH_SPEED\n\t\t\t\t|USB_PORT_STAT_ENABLE\n\t\t\t\t);\n\tmusb->port1_status |= USB_PORT_STAT_CONNECTION\n\t\t\t\t|(USB_PORT_STAT_C_CONNECTION << 16);\n\n\t \n\tif (devctl & MUSB_DEVCTL_LSDEV)\n\t\tmusb->port1_status |= USB_PORT_STAT_LOW_SPEED;\n\n\t \n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif (int_usb & MUSB_INTR_SUSPEND) {\n\t\t\tmusb_dbg(musb, \"HNP: SUSPEND+CONNECT, now b_host\");\n\t\t\tint_usb &= ~MUSB_INTR_SUSPEND;\n\t\t\tgoto b_host;\n\t\t} else\n\t\t\tmusb_dbg(musb, \"CONNECT as b_peripheral???\");\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\tmusb_dbg(musb, \"HNP: CONNECT, now b_host\");\nb_host:\n\t\tmusb_set_state(musb, OTG_STATE_B_HOST);\n\t\tif (musb->hcd)\n\t\t\tmusb->hcd->self.is_b_host = 1;\n\t\tdel_timer(&musb->otg_timer);\n\t\tbreak;\n\tdefault:\n\t\tif ((devctl & MUSB_DEVCTL_VBUS)\n\t\t\t\t== (3 << MUSB_DEVCTL_VBUS_SHIFT)) {\n\t\t\tmusb_set_state(musb, OTG_STATE_A_HOST);\n\t\t\tif (hcd)\n\t\t\t\thcd->self.is_b_host = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tmusb_host_poke_root_hub(musb);\n\n\tmusb_dbg(musb, \"CONNECT (%s) devctl %02x\",\n\t\t\tmusb_otg_state_string(musb), devctl);\n}\n\nstatic void musb_handle_intr_disconnect(struct musb *musb, u8 devctl)\n{\n\tmusb_dbg(musb, \"DISCONNECT (%s) as %s, devctl %02x\",\n\t\t\tmusb_otg_state_string(musb),\n\t\t\tMUSB_MODE(musb), devctl);\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_HOST:\n\tcase OTG_STATE_A_SUSPEND:\n\t\tmusb_host_resume_root_hub(musb);\n\t\tmusb_root_disconnect(musb);\n\t\tif (musb->a_wait_bcon != 0)\n\t\t\tmusb_platform_try_idle(musb, jiffies\n\t\t\t\t+ msecs_to_jiffies(musb->a_wait_bcon));\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\t \n\t\tmusb_root_disconnect(musb);\n\t\tif (musb->hcd)\n\t\t\tmusb->hcd->self.is_b_host = 0;\n\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tMUSB_DEV_MODE(musb);\n\t\tmusb_g_disconnect(musb);\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\tmusb_hnp_stop(musb);\n\t\tmusb_root_disconnect(musb);\n\t\tfallthrough;\n\tcase OTG_STATE_B_WAIT_ACON:\n\tcase OTG_STATE_B_PERIPHERAL:\n\tcase OTG_STATE_B_IDLE:\n\t\tmusb_g_disconnect(musb);\n\t\tbreak;\n\tdefault:\n\t\tWARNING(\"unhandled DISCONNECT transition (%s)\\n\",\n\t\t\tmusb_otg_state_string(musb));\n\t\tbreak;\n\t}\n}\n\n \nstatic void musb_handle_intr_reset(struct musb *musb)\n{\n\tif (is_host_active(musb)) {\n\t\t \n\t\tdev_err(musb->controller, \"Babble\\n\");\n\t\tmusb_recover_from_babble(musb);\n\t} else {\n\t\tmusb_dbg(musb, \"BUS RESET as %s\", musb_otg_state_string(musb));\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_SUSPEND:\n\t\t\tmusb_g_reset(musb);\n\t\t\tfallthrough;\n\t\tcase OTG_STATE_A_WAIT_BCON:\t \n\t\t\t \n\t\t\tmusb_dbg(musb, \"HNP: in %s, %d msec timeout\",\n\t\t\t\t musb_otg_state_string(musb),\n\t\t\t\tTA_WAIT_BCON(musb));\n\t\t\tmod_timer(&musb->otg_timer, jiffies\n\t\t\t\t+ msecs_to_jiffies(TA_WAIT_BCON(musb)));\n\t\t\tbreak;\n\t\tcase OTG_STATE_A_PERIPHERAL:\n\t\t\tdel_timer(&musb->otg_timer);\n\t\t\tmusb_g_reset(musb);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_WAIT_ACON:\n\t\t\tmusb_dbg(musb, \"HNP: RESET (%s), to b_peripheral\",\n\t\t\t\t musb_otg_state_string(musb));\n\t\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\t\tmusb_g_reset(musb);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_IDLE:\n\t\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\t\tfallthrough;\n\t\tcase OTG_STATE_B_PERIPHERAL:\n\t\t\tmusb_g_reset(musb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmusb_dbg(musb, \"Unhandled BUS RESET as %s\",\n\t\t\t\t musb_otg_state_string(musb));\n\t\t}\n\t}\n}\n\n \n\nstatic irqreturn_t musb_stage0_irq(struct musb *musb, u8 int_usb,\n\t\t\t\tu8 devctl)\n{\n\tirqreturn_t handled = IRQ_NONE;\n\n\tmusb_dbg(musb, \"<== DevCtl=%02x, int_usb=0x%x\", devctl, int_usb);\n\n\t \n\tif (int_usb & MUSB_INTR_RESUME) {\n\t\tmusb_handle_intr_resume(musb, devctl);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\t \n\tif (int_usb & MUSB_INTR_SESSREQ) {\n\t\tif (musb_handle_intr_sessreq(musb, devctl))\n\t\t\treturn IRQ_HANDLED;\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (int_usb & MUSB_INTR_VBUSERROR) {\n\t\tmusb_handle_intr_vbuserr(musb, devctl);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (int_usb & MUSB_INTR_SUSPEND) {\n\t\tmusb_handle_intr_suspend(musb, devctl);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (int_usb & MUSB_INTR_CONNECT) {\n\t\tmusb_handle_intr_connect(musb, devctl, int_usb);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (int_usb & MUSB_INTR_DISCONNECT) {\n\t\tmusb_handle_intr_disconnect(musb, devctl);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n\tif (int_usb & MUSB_INTR_RESET) {\n\t\tmusb_handle_intr_reset(musb);\n\t\thandled = IRQ_HANDLED;\n\t}\n\n#if 0\n \n\tif (int_usb & MUSB_INTR_SOF) {\n\t\tvoid __iomem *mbase = musb->mregs;\n\t\tstruct musb_hw_ep\t*ep;\n\t\tu8 epnum;\n\t\tu16 frame;\n\n\t\tdev_dbg(musb->controller, \"START_OF_FRAME\\n\");\n\t\thandled = IRQ_HANDLED;\n\n\t\t \n\t\tframe = musb_readw(mbase, MUSB_FRAME);\n\t\tep = musb->endpoints;\n\t\tfor (epnum = 1; (epnum < musb->nr_endpoints)\n\t\t\t\t\t&& (musb->epmask >= (1 << epnum));\n\t\t\t\tepnum++, ep++) {\n\t\t\t \n\t\t\tif (ep->dwWaitFrame >= frame) {\n\t\t\t\tep->dwWaitFrame = 0;\n\t\t\t\tpr_debug(\"SOF --> periodic TX%s on %d\\n\",\n\t\t\t\t\tep->tx_channel ? \" DMA\" : \"\",\n\t\t\t\t\tepnum);\n\t\t\t\tif (!ep->tx_channel)\n\t\t\t\t\tmusb_h_tx_start(musb, epnum);\n\t\t\t\telse\n\t\t\t\t\tcppi_hostdma_start(musb, epnum);\n\t\t\t}\n\t\t}\t\t \n\t}\n#endif\n\n\tschedule_delayed_work(&musb->irq_work, 0);\n\n\treturn handled;\n}\n\n \n\nstatic void musb_disable_interrupts(struct musb *musb)\n{\n\tvoid __iomem\t*mbase = musb->mregs;\n\n\t \n\tmusb_writeb(mbase, MUSB_INTRUSBE, 0);\n\tmusb->intrtxe = 0;\n\tmusb_writew(mbase, MUSB_INTRTXE, 0);\n\tmusb->intrrxe = 0;\n\tmusb_writew(mbase, MUSB_INTRRXE, 0);\n\n\t \n\tmusb_clearb(mbase, MUSB_INTRUSB);\n\tmusb_clearw(mbase, MUSB_INTRTX);\n\tmusb_clearw(mbase, MUSB_INTRRX);\n}\n\nstatic void musb_enable_interrupts(struct musb *musb)\n{\n\tvoid __iomem    *regs = musb->mregs;\n\n\t \n\tmusb->intrtxe = musb->epmask;\n\tmusb_writew(regs, MUSB_INTRTXE, musb->intrtxe);\n\tmusb->intrrxe = musb->epmask & 0xfffe;\n\tmusb_writew(regs, MUSB_INTRRXE, musb->intrrxe);\n\tmusb_writeb(regs, MUSB_INTRUSBE, 0xf7);\n\n}\n\n \nvoid musb_start(struct musb *musb)\n{\n\tvoid __iomem    *regs = musb->mregs;\n\tu8              devctl = musb_readb(regs, MUSB_DEVCTL);\n\tu8\t\tpower;\n\n\tmusb_dbg(musb, \"<== devctl %02x\", devctl);\n\n\tmusb_enable_interrupts(musb);\n\tmusb_writeb(regs, MUSB_TESTMODE, 0);\n\n\tpower = MUSB_POWER_ISOUPDATE;\n\t \n\tif (musb->config->maximum_speed == USB_SPEED_HIGH ||\n\t\t\tmusb->config->maximum_speed == USB_SPEED_UNKNOWN)\n\t\tpower |= MUSB_POWER_HSENAB;\n\tmusb_writeb(regs, MUSB_POWER, power);\n\n\tmusb->is_active = 0;\n\tdevctl = musb_readb(regs, MUSB_DEVCTL);\n\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\n\t \n\tif (musb->port_mode != MUSB_HOST &&\n\t    musb_get_state(musb) != OTG_STATE_A_WAIT_BCON &&\n\t    (devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS) {\n\t\tmusb->is_active = 1;\n\t} else {\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t}\n\n\tmusb_platform_enable(musb);\n\tmusb_writeb(regs, MUSB_DEVCTL, devctl);\n}\n\n \nvoid musb_stop(struct musb *musb)\n{\n\t \n\tmusb_platform_disable(musb);\n\tmusb_disable_interrupts(musb);\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\n\n\t \n\tmusb_platform_try_idle(musb, 0);\n}\n\n \n\n \nstatic ushort fifo_mode;\n\n \nmodule_param(fifo_mode, ushort, 0);\nMODULE_PARM_DESC(fifo_mode, \"initial endpoint configuration\");\n\n \n\n \nstatic struct musb_fifo_cfg mode_0_cfg[] = {\n{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, },\n{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },\n{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },\n};\n\n \nstatic struct musb_fifo_cfg mode_1_cfg[] = {\n{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },\n{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },\n{ .hw_ep_num = 2, .style = FIFO_RXTX, .maxpacket = 512, .mode = BUF_DOUBLE, },\n{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },\n{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },\n};\n\n \nstatic struct musb_fifo_cfg mode_2_cfg[] = {\n{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 960, },\n{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 1024, },\n};\n\n \nstatic struct musb_fifo_cfg mode_3_cfg[] = {\n{ .hw_ep_num = 1, .style = FIFO_TX,   .maxpacket = 512, .mode = BUF_DOUBLE, },\n{ .hw_ep_num = 1, .style = FIFO_RX,   .maxpacket = 512, .mode = BUF_DOUBLE, },\n{ .hw_ep_num = 2, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num = 2, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num = 3, .style = FIFO_RXTX, .maxpacket = 256, },\n{ .hw_ep_num = 4, .style = FIFO_RXTX, .maxpacket = 256, },\n};\n\n \nstatic struct musb_fifo_cfg mode_4_cfg[] = {\n{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  8, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  9, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num = 10, .style = FIFO_TX,   .maxpacket = 256, },\n{ .hw_ep_num = 10, .style = FIFO_RX,   .maxpacket = 64, },\n{ .hw_ep_num = 11, .style = FIFO_TX,   .maxpacket = 256, },\n{ .hw_ep_num = 11, .style = FIFO_RX,   .maxpacket = 64, },\n{ .hw_ep_num = 12, .style = FIFO_TX,   .maxpacket = 256, },\n{ .hw_ep_num = 12, .style = FIFO_RX,   .maxpacket = 64, },\n{ .hw_ep_num = 13, .style = FIFO_RXTX, .maxpacket = 4096, },\n{ .hw_ep_num = 14, .style = FIFO_RXTX, .maxpacket = 1024, },\n{ .hw_ep_num = 15, .style = FIFO_RXTX, .maxpacket = 1024, },\n};\n\n \nstatic struct musb_fifo_cfg mode_5_cfg[] = {\n{ .hw_ep_num =  1, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  1, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  2, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  2, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  3, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  3, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  4, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  4, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  5, .style = FIFO_TX,   .maxpacket = 512, },\n{ .hw_ep_num =  5, .style = FIFO_RX,   .maxpacket = 512, },\n{ .hw_ep_num =  6, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num =  6, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num =  7, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num =  7, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num =  8, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num =  8, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num =  9, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num =  9, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num = 10, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num = 10, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num = 11, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num = 11, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num = 12, .style = FIFO_TX,   .maxpacket = 32, },\n{ .hw_ep_num = 12, .style = FIFO_RX,   .maxpacket = 32, },\n{ .hw_ep_num = 13, .style = FIFO_RXTX, .maxpacket = 512, },\n{ .hw_ep_num = 14, .style = FIFO_RXTX, .maxpacket = 1024, },\n{ .hw_ep_num = 15, .style = FIFO_RXTX, .maxpacket = 1024, },\n};\n\n \nstatic int\nfifo_setup(struct musb *musb, struct musb_hw_ep  *hw_ep,\n\t\tconst struct musb_fifo_cfg *cfg, u16 offset)\n{\n\tvoid __iomem\t*mbase = musb->mregs;\n\tint\tsize = 0;\n\tu16\tmaxpacket = cfg->maxpacket;\n\tu16\tc_off = offset >> 3;\n\tu8\tc_size;\n\n\t \n\n\tsize = ffs(max(maxpacket, (u16) 8)) - 1;\n\tmaxpacket = 1 << size;\n\n\tc_size = size - 3;\n\tif (cfg->mode == BUF_DOUBLE) {\n\t\tif ((offset + (maxpacket << 1)) >\n\t\t\t\t(1 << (musb->config->ram_bits + 2)))\n\t\t\treturn -EMSGSIZE;\n\t\tc_size |= MUSB_FIFOSZ_DPB;\n\t} else {\n\t\tif ((offset + maxpacket) > (1 << (musb->config->ram_bits + 2)))\n\t\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tmusb_writeb(mbase, MUSB_INDEX, hw_ep->epnum);\n\n\t \n\tif (hw_ep->epnum == 1)\n\t\tmusb->bulk_ep = hw_ep;\n\t \n\tswitch (cfg->style) {\n\tcase FIFO_TX:\n\t\tmusb_writeb(mbase, MUSB_TXFIFOSZ, c_size);\n\t\tmusb_writew(mbase, MUSB_TXFIFOADD, c_off);\n\t\thw_ep->tx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\n\t\thw_ep->max_packet_sz_tx = maxpacket;\n\t\tbreak;\n\tcase FIFO_RX:\n\t\tmusb_writeb(mbase, MUSB_RXFIFOSZ, c_size);\n\t\tmusb_writew(mbase, MUSB_RXFIFOADD, c_off);\n\t\thw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\n\t\thw_ep->max_packet_sz_rx = maxpacket;\n\t\tbreak;\n\tcase FIFO_RXTX:\n\t\tmusb_writeb(mbase, MUSB_TXFIFOSZ, c_size);\n\t\tmusb_writew(mbase, MUSB_TXFIFOADD, c_off);\n\t\thw_ep->rx_double_buffered = !!(c_size & MUSB_FIFOSZ_DPB);\n\t\thw_ep->max_packet_sz_rx = maxpacket;\n\n\t\tmusb_writeb(mbase, MUSB_RXFIFOSZ, c_size);\n\t\tmusb_writew(mbase, MUSB_RXFIFOADD, c_off);\n\t\thw_ep->tx_double_buffered = hw_ep->rx_double_buffered;\n\t\thw_ep->max_packet_sz_tx = maxpacket;\n\n\t\thw_ep->is_shared_fifo = true;\n\t\tbreak;\n\t}\n\n\t \n\tmusb->epmask |= (1 << hw_ep->epnum);\n\n\treturn offset + (maxpacket << ((c_size & MUSB_FIFOSZ_DPB) ? 1 : 0));\n}\n\nstatic struct musb_fifo_cfg ep0_cfg = {\n\t.style = FIFO_RXTX, .maxpacket = 64,\n};\n\nstatic int ep_config_from_table(struct musb *musb)\n{\n\tconst struct musb_fifo_cfg\t*cfg;\n\tunsigned\t\ti, n;\n\tint\t\t\toffset;\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints;\n\n\tif (musb->config->fifo_cfg) {\n\t\tcfg = musb->config->fifo_cfg;\n\t\tn = musb->config->fifo_cfg_size;\n\t\tgoto done;\n\t}\n\n\tswitch (fifo_mode) {\n\tdefault:\n\t\tfifo_mode = 0;\n\t\tfallthrough;\n\tcase 0:\n\t\tcfg = mode_0_cfg;\n\t\tn = ARRAY_SIZE(mode_0_cfg);\n\t\tbreak;\n\tcase 1:\n\t\tcfg = mode_1_cfg;\n\t\tn = ARRAY_SIZE(mode_1_cfg);\n\t\tbreak;\n\tcase 2:\n\t\tcfg = mode_2_cfg;\n\t\tn = ARRAY_SIZE(mode_2_cfg);\n\t\tbreak;\n\tcase 3:\n\t\tcfg = mode_3_cfg;\n\t\tn = ARRAY_SIZE(mode_3_cfg);\n\t\tbreak;\n\tcase 4:\n\t\tcfg = mode_4_cfg;\n\t\tn = ARRAY_SIZE(mode_4_cfg);\n\t\tbreak;\n\tcase 5:\n\t\tcfg = mode_5_cfg;\n\t\tn = ARRAY_SIZE(mode_5_cfg);\n\t\tbreak;\n\t}\n\n\tpr_debug(\"%s: setup fifo_mode %d\\n\", musb_driver_name, fifo_mode);\n\n\ndone:\n\toffset = fifo_setup(musb, hw_ep, &ep0_cfg, 0);\n\t \n\n\t \n\n\tfor (i = 0; i < n; i++) {\n\t\tu8\tepn = cfg->hw_ep_num;\n\n\t\tif (epn >= musb->config->num_eps) {\n\t\t\tpr_debug(\"%s: invalid ep %d\\n\",\n\t\t\t\t\tmusb_driver_name, epn);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\toffset = fifo_setup(musb, hw_ep + epn, cfg++, offset);\n\t\tif (offset < 0) {\n\t\t\tpr_debug(\"%s: mem overrun, ep %d\\n\",\n\t\t\t\t\tmusb_driver_name, epn);\n\t\t\treturn offset;\n\t\t}\n\t\tepn++;\n\t\tmusb->nr_endpoints = max(epn, musb->nr_endpoints);\n\t}\n\n\tpr_debug(\"%s: %d/%d max ep, %d/%d memory\\n\",\n\t\t\tmusb_driver_name,\n\t\t\tn + 1, musb->config->num_eps * 2 - 1,\n\t\t\toffset, (1 << (musb->config->ram_bits + 2)));\n\n\tif (!musb->bulk_ep) {\n\t\tpr_debug(\"%s: missing bulk\\n\", musb_driver_name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic int ep_config_from_hw(struct musb *musb)\n{\n\tu8 epnum = 0;\n\tstruct musb_hw_ep *hw_ep;\n\tvoid __iomem *mbase = musb->mregs;\n\tint ret = 0;\n\n\tmusb_dbg(musb, \"<== static silicon ep config\");\n\n\t \n\n\tfor (epnum = 1; epnum < musb->config->num_eps; epnum++) {\n\t\tmusb_ep_select(mbase, epnum);\n\t\thw_ep = musb->endpoints + epnum;\n\n\t\tret = musb_read_fifosize(musb, hw_ep, epnum);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\t \n\n\t\t \n\t\tif (hw_ep->max_packet_sz_tx < 512\n\t\t\t\t|| hw_ep->max_packet_sz_rx < 512)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (musb->bulk_ep)\n\t\t\tcontinue;\n\t\tmusb->bulk_ep = hw_ep;\n\t}\n\n\tif (!musb->bulk_ep) {\n\t\tpr_debug(\"%s: missing bulk\\n\", musb_driver_name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nenum { MUSB_CONTROLLER_MHDRC, MUSB_CONTROLLER_HDRC, };\n\n \nstatic int musb_core_init(u16 musb_type, struct musb *musb)\n{\n\tu8 reg;\n\tchar *type;\n\tchar aInfo[90];\n\tvoid __iomem\t*mbase = musb->mregs;\n\tint\t\tstatus = 0;\n\tint\t\ti;\n\n\t \n\treg = musb_read_configdata(mbase);\n\n\tstrcpy(aInfo, (reg & MUSB_CONFIGDATA_UTMIDW) ? \"UTMI-16\" : \"UTMI-8\");\n\tif (reg & MUSB_CONFIGDATA_DYNFIFO) {\n\t\tstrcat(aInfo, \", dyn FIFOs\");\n\t\tmusb->dyn_fifo = true;\n\t}\n\tif (reg & MUSB_CONFIGDATA_MPRXE) {\n\t\tstrcat(aInfo, \", bulk combine\");\n\t\tmusb->bulk_combine = true;\n\t}\n\tif (reg & MUSB_CONFIGDATA_MPTXE) {\n\t\tstrcat(aInfo, \", bulk split\");\n\t\tmusb->bulk_split = true;\n\t}\n\tif (reg & MUSB_CONFIGDATA_HBRXE) {\n\t\tstrcat(aInfo, \", HB-ISO Rx\");\n\t\tmusb->hb_iso_rx = true;\n\t}\n\tif (reg & MUSB_CONFIGDATA_HBTXE) {\n\t\tstrcat(aInfo, \", HB-ISO Tx\");\n\t\tmusb->hb_iso_tx = true;\n\t}\n\tif (reg & MUSB_CONFIGDATA_SOFTCONE)\n\t\tstrcat(aInfo, \", SoftConn\");\n\n\tpr_debug(\"%s: ConfigData=0x%02x (%s)\\n\", musb_driver_name, reg, aInfo);\n\n\tif (MUSB_CONTROLLER_MHDRC == musb_type) {\n\t\tmusb->is_multipoint = 1;\n\t\ttype = \"M\";\n\t} else {\n\t\tmusb->is_multipoint = 0;\n\t\ttype = \"\";\n\t\tif (IS_ENABLED(CONFIG_USB) &&\n\t\t    !IS_ENABLED(CONFIG_USB_OTG_DISABLE_EXTERNAL_HUB)) {\n\t\t\tpr_err(\"%s: kernel must disable external hubs, please fix the configuration\\n\",\n\t\t\t       musb_driver_name);\n\t\t}\n\t}\n\n\t \n\tmusb->hwvers = musb_readw(mbase, MUSB_HWVERS);\n\tpr_debug(\"%s: %sHDRC RTL version %d.%d%s\\n\",\n\t\t musb_driver_name, type, MUSB_HWVERS_MAJOR(musb->hwvers),\n\t\t MUSB_HWVERS_MINOR(musb->hwvers),\n\t\t (musb->hwvers & MUSB_HWVERS_RC) ? \"RC\" : \"\");\n\n\t \n\tmusb_configure_ep0(musb);\n\n\t \n\tmusb->nr_endpoints = 1;\n\tmusb->epmask = 1;\n\n\tif (musb->dyn_fifo)\n\t\tstatus = ep_config_from_table(musb);\n\telse\n\t\tstatus = ep_config_from_hw(musb);\n\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tfor (i = 0; i < musb->nr_endpoints; i++) {\n\t\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + i;\n\n\t\thw_ep->fifo = musb->io.fifo_offset(i) + mbase;\n#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)\n\t\tif (musb->ops->quirks & MUSB_IN_TUSB) {\n\t\t\thw_ep->fifo_async = musb->async + 0x400 +\n\t\t\t\tmusb->io.fifo_offset(i);\n\t\t\thw_ep->fifo_sync = musb->sync + 0x400 +\n\t\t\t\tmusb->io.fifo_offset(i);\n\t\t\thw_ep->fifo_sync_va =\n\t\t\t\tmusb->sync_va + 0x400 + musb->io.fifo_offset(i);\n\n\t\t\tif (i == 0)\n\t\t\t\thw_ep->conf = mbase - 0x400 + TUSB_EP0_CONF;\n\t\t\telse\n\t\t\t\thw_ep->conf = mbase + 0x400 +\n\t\t\t\t\t(((i - 1) & 0xf) << 2);\n\t\t}\n#endif\n\n\t\thw_ep->regs = musb->io.ep_offset(i, 0) + mbase;\n\t\thw_ep->rx_reinit = 1;\n\t\thw_ep->tx_reinit = 1;\n\n\t\tif (hw_ep->max_packet_sz_tx) {\n\t\t\tmusb_dbg(musb, \"%s: hw_ep %d%s, %smax %d\",\n\t\t\t\tmusb_driver_name, i,\n\t\t\t\thw_ep->is_shared_fifo ? \"shared\" : \"tx\",\n\t\t\t\thw_ep->tx_double_buffered\n\t\t\t\t\t? \"doublebuffer, \" : \"\",\n\t\t\t\thw_ep->max_packet_sz_tx);\n\t\t}\n\t\tif (hw_ep->max_packet_sz_rx && !hw_ep->is_shared_fifo) {\n\t\t\tmusb_dbg(musb, \"%s: hw_ep %d%s, %smax %d\",\n\t\t\t\tmusb_driver_name, i,\n\t\t\t\t\"rx\",\n\t\t\t\thw_ep->rx_double_buffered\n\t\t\t\t\t? \"doublebuffer, \" : \"\",\n\t\t\t\thw_ep->max_packet_sz_rx);\n\t\t}\n\t\tif (!(hw_ep->max_packet_sz_tx || hw_ep->max_packet_sz_rx))\n\t\t\tmusb_dbg(musb, \"hw_ep %d not configured\", i);\n\t}\n\n\treturn 0;\n}\n\n \n\n \nirqreturn_t musb_interrupt(struct musb *musb)\n{\n\tirqreturn_t\tretval = IRQ_NONE;\n\tunsigned long\tstatus;\n\tunsigned long\tepnum;\n\tu8\t\tdevctl;\n\n\tif (!musb->int_usb && !musb->int_tx && !musb->int_rx)\n\t\treturn IRQ_NONE;\n\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\n\ttrace_musb_isr(musb);\n\n\t \n\n\tif (musb->int_usb)\n\t\tretval |= musb_stage0_irq(musb, musb->int_usb, devctl);\n\n\tif (musb->int_tx & 1) {\n\t\tif (is_host_active(musb))\n\t\t\tretval |= musb_h_ep0_irq(musb);\n\t\telse\n\t\t\tretval |= musb_g_ep0_irq(musb);\n\n\t\t \n\t\tmusb->int_tx &= ~BIT(0);\n\t}\n\n\tstatus = musb->int_tx;\n\n\tfor_each_set_bit(epnum, &status, 16) {\n\t\tretval = IRQ_HANDLED;\n\t\tif (is_host_active(musb))\n\t\t\tmusb_host_tx(musb, epnum);\n\t\telse\n\t\t\tmusb_g_tx(musb, epnum);\n\t}\n\n\tstatus = musb->int_rx;\n\n\tfor_each_set_bit(epnum, &status, 16) {\n\t\tretval = IRQ_HANDLED;\n\t\tif (is_host_active(musb))\n\t\t\tmusb_host_rx(musb, epnum);\n\t\telse\n\t\t\tmusb_g_rx(musb, epnum);\n\t}\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(musb_interrupt);\n\n#ifndef CONFIG_MUSB_PIO_ONLY\nstatic bool use_dma = true;\n\n \nmodule_param(use_dma, bool, 0644);\nMODULE_PARM_DESC(use_dma, \"enable/disable use of DMA\");\n\nvoid musb_dma_completion(struct musb *musb, u8 epnum, u8 transmit)\n{\n\t \n\n\tif (!epnum) {\n\t\tif (!is_cppi_enabled(musb)) {\n\t\t\t \n\t\t\tif (is_host_active(musb))\n\t\t\t\tmusb_h_ep0_irq(musb);\n\t\t\telse\n\t\t\t\tmusb_g_ep0_irq(musb);\n\t\t}\n\t} else {\n\t\t \n\t\tif (transmit) {\n\t\t\tif (is_host_active(musb))\n\t\t\t\tmusb_host_tx(musb, epnum);\n\t\t\telse\n\t\t\t\tmusb_g_tx(musb, epnum);\n\t\t} else {\n\t\t\t \n\t\t\tif (is_host_active(musb))\n\t\t\t\tmusb_host_rx(musb, epnum);\n\t\t\telse\n\t\t\t\tmusb_g_rx(musb, epnum);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(musb_dma_completion);\n\n#else\n#define use_dma\t\t\t0\n#endif\n\nstatic int (*musb_phy_callback)(enum musb_vbus_id_status status);\n\n \nint musb_mailbox(enum musb_vbus_id_status status)\n{\n\tif (musb_phy_callback)\n\t\treturn musb_phy_callback(status);\n\n\treturn -ENODEV;\n};\nEXPORT_SYMBOL_GPL(musb_mailbox);\n\n \n\nstatic ssize_t\nmode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct musb *musb = dev_to_musb(dev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tret = sprintf(buf, \"%s\\n\", musb_otg_state_string(musb));\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn ret;\n}\n\nstatic ssize_t\nmode_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t n)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned long\tflags;\n\tint\t\tstatus;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tif (sysfs_streq(buf, \"host\"))\n\t\tstatus = musb_platform_set_mode(musb, MUSB_HOST);\n\telse if (sysfs_streq(buf, \"peripheral\"))\n\t\tstatus = musb_platform_set_mode(musb, MUSB_PERIPHERAL);\n\telse if (sysfs_streq(buf, \"otg\"))\n\t\tstatus = musb_platform_set_mode(musb, MUSB_OTG);\n\telse\n\t\tstatus = -EINVAL;\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn (status == 0) ? n : status;\n}\nstatic DEVICE_ATTR_RW(mode);\n\nstatic ssize_t\nvbus_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t n)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned long\tflags;\n\tunsigned long\tval;\n\n\tif (sscanf(buf, \"%lu\", &val) < 1) {\n\t\tdev_err(dev, \"Invalid VBUS timeout ms value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\t \n\tmusb->a_wait_bcon = val ? max_t(int, val, OTG_TIME_A_WAIT_BCON) : 0 ;\n\tif (musb_get_state(musb) == OTG_STATE_A_WAIT_BCON)\n\t\tmusb->is_active = 0;\n\tmusb_platform_try_idle(musb, jiffies + msecs_to_jiffies(val));\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn n;\n}\n\nstatic ssize_t\nvbus_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned long\tflags;\n\tunsigned long\tval;\n\tint\t\tvbus;\n\tu8\t\tdevctl;\n\n\tpm_runtime_get_sync(dev);\n\tspin_lock_irqsave(&musb->lock, flags);\n\tval = musb->a_wait_bcon;\n\tvbus = musb_platform_get_vbus_status(musb);\n\tif (vbus < 0) {\n\t\t \n\t\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\tif ((devctl & MUSB_DEVCTL_VBUS)\n\t\t\t\t== (3 << MUSB_DEVCTL_VBUS_SHIFT))\n\t\t\tvbus = 1;\n\t\telse\n\t\t\tvbus = 0;\n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\tpm_runtime_put_sync(dev);\n\n\treturn sprintf(buf, \"Vbus %s, timeout %lu msec\\n\",\n\t\t\tvbus ? \"on\" : \"off\", val);\n}\nstatic DEVICE_ATTR_RW(vbus);\n\n \nstatic ssize_t srp_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t n)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned short\tsrp;\n\n\tif (sscanf(buf, \"%hu\", &srp) != 1\n\t\t\t|| (srp != 1)) {\n\t\tdev_err(dev, \"SRP: Value must be 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (srp == 1)\n\t\tmusb_g_wakeup(musb);\n\n\treturn n;\n}\nstatic DEVICE_ATTR_WO(srp);\n\nstatic struct attribute *musb_attrs[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_vbus.attr,\n\t&dev_attr_srp.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(musb);\n\n#define MUSB_QUIRK_B_INVALID_VBUS_91\t(MUSB_DEVCTL_BDEVICE | \\\n\t\t\t\t\t (2 << MUSB_DEVCTL_VBUS_SHIFT) | \\\n\t\t\t\t\t MUSB_DEVCTL_SESSION)\n#define MUSB_QUIRK_B_DISCONNECT_99\t(MUSB_DEVCTL_BDEVICE | \\\n\t\t\t\t\t (3 << MUSB_DEVCTL_VBUS_SHIFT) | \\\n\t\t\t\t\t MUSB_DEVCTL_SESSION)\n#define MUSB_QUIRK_A_DISCONNECT_19\t((3 << MUSB_DEVCTL_VBUS_SHIFT) | \\\n\t\t\t\t\t MUSB_DEVCTL_SESSION)\n\nstatic bool musb_state_needs_recheck(struct musb *musb, u8 devctl,\n\t\t\t\t     const char *desc)\n{\n\tif (musb->quirk_retries && !musb->flush_irq_work) {\n\t\ttrace_musb_state(musb, devctl, desc);\n\t\tschedule_delayed_work(&musb->irq_work,\n\t\t\t\t      msecs_to_jiffies(1000));\n\t\tmusb->quirk_retries--;\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void musb_pm_runtime_check_session(struct musb *musb)\n{\n\tu8 devctl, s;\n\tint error;\n\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\n\t \n\ts = MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV |\n\t\tMUSB_DEVCTL_HR;\n\tswitch (devctl & ~s) {\n\tcase MUSB_QUIRK_B_DISCONNECT_99:\n\t\tmusb_state_needs_recheck(musb, devctl,\n\t\t\t\"Poll devctl in case of suspend after disconnect\");\n\t\tbreak;\n\tcase MUSB_QUIRK_B_INVALID_VBUS_91:\n\t\tif (musb_state_needs_recheck(musb, devctl,\n\t\t\t\t\"Poll devctl on invalid vbus, assume no session\"))\n\t\t\treturn;\n\t\tfallthrough;\n\tcase MUSB_QUIRK_A_DISCONNECT_19:\n\t\tif (musb_state_needs_recheck(musb, devctl,\n\t\t\t\t\"Poll devctl on possible host mode disconnect\"))\n\t\t\treturn;\n\t\tif (!musb->session)\n\t\t\tbreak;\n\t\ttrace_musb_state(musb, devctl, \"Allow PM on possible host mode disconnect\");\n\t\tpm_runtime_mark_last_busy(musb->controller);\n\t\tpm_runtime_put_autosuspend(musb->controller);\n\t\tmusb->session = false;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\ts = devctl & MUSB_DEVCTL_SESSION;\n\tif (s == musb->session)\n\t\treturn;\n\n\t \n\tif (s) {\n\t\ttrace_musb_state(musb, devctl, \"Block PM on active session\");\n\t\terror = pm_runtime_get_sync(musb->controller);\n\t\tif (error < 0)\n\t\t\tdev_err(musb->controller, \"Could not enable: %i\\n\",\n\t\t\t\terror);\n\t\tmusb->quirk_retries = 3;\n\n\t\t \n\t\tif (devctl & MUSB_DEVCTL_BDEVICE)\n\t\t\tschedule_delayed_work(&musb->irq_work,\n\t\t\t\t\t      msecs_to_jiffies(3000));\n\t} else {\n\t\ttrace_musb_state(musb, devctl, \"Allow PM with no session\");\n\t\tpm_runtime_mark_last_busy(musb->controller);\n\t\tpm_runtime_put_autosuspend(musb->controller);\n\t}\n\n\tmusb->session = s;\n}\n\n \nstatic void musb_irq_work(struct work_struct *data)\n{\n\tstruct musb *musb = container_of(data, struct musb, irq_work.work);\n\tint error;\n\n\terror = pm_runtime_resume_and_get(musb->controller);\n\tif (error < 0) {\n\t\tdev_err(musb->controller, \"Could not enable: %i\\n\", error);\n\n\t\treturn;\n\t}\n\n\tmusb_pm_runtime_check_session(musb);\n\n\tif (musb_get_state(musb) != musb->xceiv_old_state) {\n\t\tmusb->xceiv_old_state = musb_get_state(musb);\n\t\tsysfs_notify(&musb->controller->kobj, NULL, \"mode\");\n\t}\n\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n}\n\nstatic void musb_recover_from_babble(struct musb *musb)\n{\n\tint ret;\n\tu8 devctl;\n\n\tmusb_disable_interrupts(musb);\n\n\t \n\tudelay(10);\n\n\tret  = musb_platform_recover(musb);\n\tif (ret) {\n\t\tmusb_enable_interrupts(musb);\n\t\treturn;\n\t}\n\n\t \n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\t \n\tmusb_root_disconnect(musb);\n\n\t \n\tif (musb->dyn_fifo)\n\t\tret = ep_config_from_table(musb);\n\telse\n\t\tret = ep_config_from_hw(musb);\n\n\t \n\tif (ret == 0)\n\t\tmusb_start(musb);\n}\n\n \n\nstatic struct musb *allocate_instance(struct device *dev,\n\t\tconst struct musb_hdrc_config *config, void __iomem *mbase)\n{\n\tstruct musb\t\t*musb;\n\tstruct musb_hw_ep\t*ep;\n\tint\t\t\tepnum;\n\tint\t\t\tret;\n\n\tmusb = devm_kzalloc(dev, sizeof(*musb), GFP_KERNEL);\n\tif (!musb)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&musb->control);\n\tINIT_LIST_HEAD(&musb->in_bulk);\n\tINIT_LIST_HEAD(&musb->out_bulk);\n\tINIT_LIST_HEAD(&musb->pending_list);\n\n\tmusb->vbuserr_retry = VBUSERR_RETRY_COUNT;\n\tmusb->a_wait_bcon = OTG_TIME_A_WAIT_BCON;\n\tmusb->mregs = mbase;\n\tmusb->ctrl_base = mbase;\n\tmusb->nIrq = -ENODEV;\n\tmusb->config = config;\n\tBUG_ON(musb->config->num_eps > MUSB_C_NUM_EPS);\n\tfor (epnum = 0, ep = musb->endpoints;\n\t\t\tepnum < musb->config->num_eps;\n\t\t\tepnum++, ep++) {\n\t\tep->musb = musb;\n\t\tep->epnum = epnum;\n\t}\n\n\tmusb->controller = dev;\n\n\tret = musb_host_alloc(musb);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tdev_set_drvdata(dev, musb);\n\n\treturn musb;\n\nerr_free:\n\treturn NULL;\n}\n\nstatic void musb_free(struct musb *musb)\n{\n\t \n\n\tif (musb->nIrq >= 0) {\n\t\tif (musb->irq_wake)\n\t\t\tdisable_irq_wake(musb->nIrq);\n\t\tfree_irq(musb->nIrq, musb);\n\t}\n\n\tmusb_host_free(musb);\n}\n\nstruct musb_pending_work {\n\tint (*callback)(struct musb *musb, void *data);\n\tvoid *data;\n\tstruct list_head node;\n};\n\n#ifdef CONFIG_PM\n \nstatic int musb_run_resume_work(struct musb *musb)\n{\n\tstruct musb_pending_work *w, *_w;\n\tunsigned long flags;\n\tint error = 0;\n\n\tspin_lock_irqsave(&musb->list_lock, flags);\n\tlist_for_each_entry_safe(w, _w, &musb->pending_list, node) {\n\t\tif (w->callback) {\n\t\t\terror = w->callback(musb, w->data);\n\t\t\tif (error < 0) {\n\t\t\t\tdev_err(musb->controller,\n\t\t\t\t\t\"resume callback %p failed: %i\\n\",\n\t\t\t\t\tw->callback, error);\n\t\t\t}\n\t\t}\n\t\tlist_del(&w->node);\n\t\tdevm_kfree(musb->controller, w);\n\t}\n\tspin_unlock_irqrestore(&musb->list_lock, flags);\n\n\treturn error;\n}\n#endif\n\n \nint musb_queue_resume_work(struct musb *musb,\n\t\t\t   int (*callback)(struct musb *musb, void *data),\n\t\t\t   void *data)\n{\n\tstruct musb_pending_work *w;\n\tunsigned long flags;\n\tbool is_suspended;\n\tint error;\n\n\tif (WARN_ON(!callback))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&musb->list_lock, flags);\n\tis_suspended = musb->is_runtime_suspended;\n\n\tif (is_suspended) {\n\t\tw = devm_kzalloc(musb->controller, sizeof(*w), GFP_ATOMIC);\n\t\tif (!w) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tw->callback = callback;\n\t\tw->data = data;\n\n\t\tlist_add_tail(&w->node, &musb->pending_list);\n\t\terror = 0;\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&musb->list_lock, flags);\n\n\tif (!is_suspended)\n\t\terror = callback(musb, data);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(musb_queue_resume_work);\n\nstatic void musb_deassert_reset(struct work_struct *work)\n{\n\tstruct musb *musb;\n\tunsigned long flags;\n\n\tmusb = container_of(work, struct musb, deassert_reset_work.work);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (musb->port1_status & USB_PORT_STAT_RESET)\n\t\tmusb_port_reset(musb, false);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\n \nstatic int\nmusb_init_controller(struct device *dev, int nIrq, void __iomem *ctrl)\n{\n\tint\t\t\tstatus;\n\tstruct musb\t\t*musb;\n\tstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\n\n\t \n\tif (!plat) {\n\t\tdev_err(dev, \"no platform_data?\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto fail0;\n\t}\n\n\t \n\tmusb = allocate_instance(dev, plat->config, ctrl);\n\tif (!musb) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail0;\n\t}\n\n\tspin_lock_init(&musb->lock);\n\tspin_lock_init(&musb->list_lock);\n\tmusb->min_power = plat->min_power;\n\tmusb->ops = plat->platform_ops;\n\tmusb->port_mode = plat->mode;\n\n\t \n\tmusb_readb = musb_default_readb;\n\tmusb_writeb = musb_default_writeb;\n\tmusb_readw = musb_default_readw;\n\tmusb_writew = musb_default_writew;\n\n\t \n\tstatus = musb_platform_init(musb);\n\tif (status < 0)\n\t\tgoto fail1;\n\n\tif (!musb->isr) {\n\t\tstatus = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\n\t \n\tif (musb->ops->quirks & MUSB_INDEXED_EP) {\n\t\tmusb->io.ep_offset = musb_indexed_ep_offset;\n\t\tmusb->io.ep_select = musb_indexed_ep_select;\n\t} else {\n\t\tmusb->io.ep_offset = musb_flat_ep_offset;\n\t\tmusb->io.ep_select = musb_flat_ep_select;\n\t}\n\n\tif (musb->ops->quirks & MUSB_G_NO_SKB_RESERVE)\n\t\tmusb->g.quirk_avoids_skb_reserve = 1;\n\n\t \n\tif (musb->ops->ep_offset)\n\t\tmusb->io.ep_offset = musb->ops->ep_offset;\n\tif (musb->ops->ep_select)\n\t\tmusb->io.ep_select = musb->ops->ep_select;\n\n\tif (musb->ops->fifo_mode)\n\t\tfifo_mode = musb->ops->fifo_mode;\n\telse\n\t\tfifo_mode = 4;\n\n\tif (musb->ops->fifo_offset)\n\t\tmusb->io.fifo_offset = musb->ops->fifo_offset;\n\telse\n\t\tmusb->io.fifo_offset = musb_default_fifo_offset;\n\n\tif (musb->ops->busctl_offset)\n\t\tmusb->io.busctl_offset = musb->ops->busctl_offset;\n\telse\n\t\tmusb->io.busctl_offset = musb_default_busctl_offset;\n\n\tif (musb->ops->readb)\n\t\tmusb_readb = musb->ops->readb;\n\tif (musb->ops->writeb)\n\t\tmusb_writeb = musb->ops->writeb;\n\tif (musb->ops->clearb)\n\t\tmusb_clearb = musb->ops->clearb;\n\telse\n\t\tmusb_clearb = musb_readb;\n\n\tif (musb->ops->readw)\n\t\tmusb_readw = musb->ops->readw;\n\tif (musb->ops->writew)\n\t\tmusb_writew = musb->ops->writew;\n\tif (musb->ops->clearw)\n\t\tmusb_clearw = musb->ops->clearw;\n\telse\n\t\tmusb_clearw = musb_readw;\n\n#ifndef CONFIG_MUSB_PIO_ONLY\n\tif (!musb->ops->dma_init || !musb->ops->dma_exit) {\n\t\tdev_err(dev, \"DMA controller not set\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto fail2;\n\t}\n\tmusb_dma_controller_create = musb->ops->dma_init;\n\tmusb_dma_controller_destroy = musb->ops->dma_exit;\n#endif\n\n\tif (musb->ops->read_fifo)\n\t\tmusb->io.read_fifo = musb->ops->read_fifo;\n\telse\n\t\tmusb->io.read_fifo = musb_default_read_fifo;\n\n\tif (musb->ops->write_fifo)\n\t\tmusb->io.write_fifo = musb->ops->write_fifo;\n\telse\n\t\tmusb->io.write_fifo = musb_default_write_fifo;\n\n\tif (musb->ops->get_toggle)\n\t\tmusb->io.get_toggle = musb->ops->get_toggle;\n\telse\n\t\tmusb->io.get_toggle = musb_default_get_toggle;\n\n\tif (musb->ops->set_toggle)\n\t\tmusb->io.set_toggle = musb->ops->set_toggle;\n\telse\n\t\tmusb->io.set_toggle = musb_default_set_toggle;\n\n\tif (IS_ENABLED(CONFIG_USB_PHY) && musb->xceiv && !musb->xceiv->io_ops) {\n\t\tmusb->xceiv->io_dev = musb->controller;\n\t\tmusb->xceiv->io_priv = musb->mregs;\n\t\tmusb->xceiv->io_ops = &musb_ulpi_access;\n\t}\n\n\tif (musb->ops->phy_callback)\n\t\tmusb_phy_callback = musb->ops->phy_callback;\n\n\t \n\tpm_runtime_use_autosuspend(musb->controller);\n\tpm_runtime_set_autosuspend_delay(musb->controller, 500);\n\tpm_runtime_enable(musb->controller);\n\tpm_runtime_get_sync(musb->controller);\n\n\tstatus = usb_phy_init(musb->xceiv);\n\tif (status < 0)\n\t\tgoto err_usb_phy_init;\n\n\tif (use_dma && dev->dma_mask) {\n\t\tmusb->dma_controller =\n\t\t\tmusb_dma_controller_create(musb, musb->mregs);\n\t\tif (IS_ERR(musb->dma_controller)) {\n\t\t\tstatus = PTR_ERR(musb->dma_controller);\n\t\t\tgoto fail2_5;\n\t\t}\n\t}\n\n\t \n\tmusb_platform_disable(musb);\n\tmusb_disable_interrupts(musb);\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\n\n\t \n\tmusb_writeb(musb->mregs, MUSB_POWER, 0);\n\n\t \n\tINIT_DELAYED_WORK(&musb->irq_work, musb_irq_work);\n\tINIT_DELAYED_WORK(&musb->deassert_reset_work, musb_deassert_reset);\n\tINIT_DELAYED_WORK(&musb->finish_resume_work, musb_host_finish_resume);\n\n\t \n\tstatus = musb_core_init(plat->config->multipoint\n\t\t\t? MUSB_CONTROLLER_MHDRC\n\t\t\t: MUSB_CONTROLLER_HDRC, musb);\n\tif (status < 0)\n\t\tgoto fail3;\n\n\ttimer_setup(&musb->otg_timer, musb_otg_timer_func, 0);\n\n\t \n\tif (request_irq(nIrq, musb->isr, IRQF_SHARED, dev_name(dev), musb)) {\n\t\tdev_err(dev, \"request_irq %d failed!\\n\", nIrq);\n\t\tstatus = -ENODEV;\n\t\tgoto fail3;\n\t}\n\tmusb->nIrq = nIrq;\n\t \n\tif (enable_irq_wake(nIrq) == 0) {\n\t\tmusb->irq_wake = 1;\n\t\tdevice_init_wakeup(dev, 1);\n\t} else {\n\t\tmusb->irq_wake = 0;\n\t}\n\n\t \n\tif (plat->extvbus) {\n\t\tu8 busctl = musb_readb(musb->mregs, MUSB_ULPI_BUSCONTROL);\n\t\tbusctl |= MUSB_ULPI_USE_EXTVBUS;\n\t\tmusb_writeb(musb->mregs, MUSB_ULPI_BUSCONTROL, busctl);\n\t}\n\n\tMUSB_DEV_MODE(musb);\n\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\n\tswitch (musb->port_mode) {\n\tcase MUSB_HOST:\n\t\tstatus = musb_host_setup(musb, plat->power);\n\t\tif (status < 0)\n\t\t\tgoto fail3;\n\t\tstatus = musb_platform_set_mode(musb, MUSB_HOST);\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\n\t\tstatus = musb_gadget_setup(musb);\n\t\tif (status < 0)\n\t\t\tgoto fail3;\n\t\tstatus = musb_platform_set_mode(musb, MUSB_PERIPHERAL);\n\t\tbreak;\n\tcase MUSB_OTG:\n\t\tstatus = musb_host_setup(musb, plat->power);\n\t\tif (status < 0)\n\t\t\tgoto fail3;\n\t\tstatus = musb_gadget_setup(musb);\n\t\tif (status) {\n\t\t\tmusb_host_cleanup(musb);\n\t\t\tgoto fail3;\n\t\t}\n\t\tstatus = musb_platform_set_mode(musb, MUSB_OTG);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported port mode %d\\n\", musb->port_mode);\n\t\tbreak;\n\t}\n\n\tif (status < 0)\n\t\tgoto fail3;\n\n\tmusb_init_debugfs(musb);\n\n\tmusb->is_initialized = 1;\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\n\treturn 0;\n\nfail3:\n\tcancel_delayed_work_sync(&musb->irq_work);\n\tcancel_delayed_work_sync(&musb->finish_resume_work);\n\tcancel_delayed_work_sync(&musb->deassert_reset_work);\n\tif (musb->dma_controller)\n\t\tmusb_dma_controller_destroy(musb->dma_controller);\n\nfail2_5:\n\tusb_phy_shutdown(musb->xceiv);\n\nerr_usb_phy_init:\n\tpm_runtime_dont_use_autosuspend(musb->controller);\n\tpm_runtime_put_sync(musb->controller);\n\tpm_runtime_disable(musb->controller);\n\nfail2:\n\tif (musb->irq_wake)\n\t\tdevice_init_wakeup(dev, 0);\n\tmusb_platform_exit(musb);\n\nfail1:\n\tdev_err_probe(musb->controller, status, \"%s failed\\n\", __func__);\n\n\tmusb_free(musb);\n\nfail0:\n\n\treturn status;\n\n}\n\n \n\n \nstatic int musb_probe(struct platform_device *pdev)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tint\t\tirq = platform_get_irq_byname(pdev, \"mc\");\n\tvoid __iomem\t*base;\n\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\treturn musb_init_controller(dev, irq, base);\n}\n\nstatic void musb_remove(struct platform_device *pdev)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned long\tflags;\n\n\t \n\tmusb_exit_debugfs(musb);\n\n\tcancel_delayed_work_sync(&musb->irq_work);\n\tcancel_delayed_work_sync(&musb->finish_resume_work);\n\tcancel_delayed_work_sync(&musb->deassert_reset_work);\n\tpm_runtime_get_sync(musb->controller);\n\tmusb_host_cleanup(musb);\n\tmusb_gadget_cleanup(musb);\n\n\tmusb_platform_disable(musb);\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb_disable_interrupts(musb);\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\tmusb_platform_exit(musb);\n\n\tpm_runtime_dont_use_autosuspend(musb->controller);\n\tpm_runtime_put_sync(musb->controller);\n\tpm_runtime_disable(musb->controller);\n\tmusb_phy_callback = NULL;\n\tif (musb->dma_controller)\n\t\tmusb_dma_controller_destroy(musb->dma_controller);\n\tusb_phy_shutdown(musb->xceiv);\n\tmusb_free(musb);\n\tdevice_init_wakeup(dev, 0);\n}\n\n#ifdef\tCONFIG_PM\n\nstatic void musb_save_context(struct musb *musb)\n{\n\tint i;\n\tvoid __iomem *musb_base = musb->mregs;\n\tvoid __iomem *epio;\n\n\tmusb->context.frame = musb_readw(musb_base, MUSB_FRAME);\n\tmusb->context.testmode = musb_readb(musb_base, MUSB_TESTMODE);\n\tmusb->context.busctl = musb_readb(musb_base, MUSB_ULPI_BUSCONTROL);\n\tmusb->context.power = musb_readb(musb_base, MUSB_POWER);\n\tmusb->context.intrusbe = musb_readb(musb_base, MUSB_INTRUSBE);\n\tmusb->context.index = musb_readb(musb_base, MUSB_INDEX);\n\tmusb->context.devctl = musb_readb(musb_base, MUSB_DEVCTL);\n\n\tfor (i = 0; i < musb->config->num_eps; ++i) {\n\t\tepio = musb->endpoints[i].regs;\n\t\tif (!epio)\n\t\t\tcontinue;\n\n\t\tmusb_writeb(musb_base, MUSB_INDEX, i);\n\t\tmusb->context.index_regs[i].txmaxp =\n\t\t\tmusb_readw(epio, MUSB_TXMAXP);\n\t\tmusb->context.index_regs[i].txcsr =\n\t\t\tmusb_readw(epio, MUSB_TXCSR);\n\t\tmusb->context.index_regs[i].rxmaxp =\n\t\t\tmusb_readw(epio, MUSB_RXMAXP);\n\t\tmusb->context.index_regs[i].rxcsr =\n\t\t\tmusb_readw(epio, MUSB_RXCSR);\n\n\t\tif (musb->dyn_fifo) {\n\t\t\tmusb->context.index_regs[i].txfifoadd =\n\t\t\t\t\tmusb_readw(musb_base, MUSB_TXFIFOADD);\n\t\t\tmusb->context.index_regs[i].rxfifoadd =\n\t\t\t\t\tmusb_readw(musb_base, MUSB_RXFIFOADD);\n\t\t\tmusb->context.index_regs[i].txfifosz =\n\t\t\t\t\tmusb_readb(musb_base, MUSB_TXFIFOSZ);\n\t\t\tmusb->context.index_regs[i].rxfifosz =\n\t\t\t\t\tmusb_readb(musb_base, MUSB_RXFIFOSZ);\n\t\t}\n\n\t\tmusb->context.index_regs[i].txtype =\n\t\t\tmusb_readb(epio, MUSB_TXTYPE);\n\t\tmusb->context.index_regs[i].txinterval =\n\t\t\tmusb_readb(epio, MUSB_TXINTERVAL);\n\t\tmusb->context.index_regs[i].rxtype =\n\t\t\tmusb_readb(epio, MUSB_RXTYPE);\n\t\tmusb->context.index_regs[i].rxinterval =\n\t\t\tmusb_readb(epio, MUSB_RXINTERVAL);\n\n\t\tmusb->context.index_regs[i].txfunaddr =\n\t\t\tmusb_read_txfunaddr(musb, i);\n\t\tmusb->context.index_regs[i].txhubaddr =\n\t\t\tmusb_read_txhubaddr(musb, i);\n\t\tmusb->context.index_regs[i].txhubport =\n\t\t\tmusb_read_txhubport(musb, i);\n\n\t\tmusb->context.index_regs[i].rxfunaddr =\n\t\t\tmusb_read_rxfunaddr(musb, i);\n\t\tmusb->context.index_regs[i].rxhubaddr =\n\t\t\tmusb_read_rxhubaddr(musb, i);\n\t\tmusb->context.index_regs[i].rxhubport =\n\t\t\tmusb_read_rxhubport(musb, i);\n\t}\n}\n\nstatic void musb_restore_context(struct musb *musb)\n{\n\tint i;\n\tvoid __iomem *musb_base = musb->mregs;\n\tvoid __iomem *epio;\n\tu8 power;\n\n\tmusb_writew(musb_base, MUSB_FRAME, musb->context.frame);\n\tmusb_writeb(musb_base, MUSB_TESTMODE, musb->context.testmode);\n\tmusb_writeb(musb_base, MUSB_ULPI_BUSCONTROL, musb->context.busctl);\n\n\t \n\tpower = musb_readb(musb_base, MUSB_POWER);\n\tpower &= MUSB_POWER_SUSPENDM | MUSB_POWER_RESUME;\n\tmusb->context.power &= ~(MUSB_POWER_SUSPENDM | MUSB_POWER_RESUME);\n\tpower |= musb->context.power;\n\tmusb_writeb(musb_base, MUSB_POWER, power);\n\n\tmusb_writew(musb_base, MUSB_INTRTXE, musb->intrtxe);\n\tmusb_writew(musb_base, MUSB_INTRRXE, musb->intrrxe);\n\tmusb_writeb(musb_base, MUSB_INTRUSBE, musb->context.intrusbe);\n\tif (musb->context.devctl & MUSB_DEVCTL_SESSION)\n\t\tmusb_writeb(musb_base, MUSB_DEVCTL, musb->context.devctl);\n\n\tfor (i = 0; i < musb->config->num_eps; ++i) {\n\t\tepio = musb->endpoints[i].regs;\n\t\tif (!epio)\n\t\t\tcontinue;\n\n\t\tmusb_writeb(musb_base, MUSB_INDEX, i);\n\t\tmusb_writew(epio, MUSB_TXMAXP,\n\t\t\tmusb->context.index_regs[i].txmaxp);\n\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\tmusb->context.index_regs[i].txcsr);\n\t\tmusb_writew(epio, MUSB_RXMAXP,\n\t\t\tmusb->context.index_regs[i].rxmaxp);\n\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\tmusb->context.index_regs[i].rxcsr);\n\n\t\tif (musb->dyn_fifo) {\n\t\t\tmusb_writeb(musb_base, MUSB_TXFIFOSZ,\n\t\t\t\tmusb->context.index_regs[i].txfifosz);\n\t\t\tmusb_writeb(musb_base, MUSB_RXFIFOSZ,\n\t\t\t\tmusb->context.index_regs[i].rxfifosz);\n\t\t\tmusb_writew(musb_base, MUSB_TXFIFOADD,\n\t\t\t\tmusb->context.index_regs[i].txfifoadd);\n\t\t\tmusb_writew(musb_base, MUSB_RXFIFOADD,\n\t\t\t\tmusb->context.index_regs[i].rxfifoadd);\n\t\t}\n\n\t\tmusb_writeb(epio, MUSB_TXTYPE,\n\t\t\t\tmusb->context.index_regs[i].txtype);\n\t\tmusb_writeb(epio, MUSB_TXINTERVAL,\n\t\t\t\tmusb->context.index_regs[i].txinterval);\n\t\tmusb_writeb(epio, MUSB_RXTYPE,\n\t\t\t\tmusb->context.index_regs[i].rxtype);\n\t\tmusb_writeb(epio, MUSB_RXINTERVAL,\n\n\t\t\t\tmusb->context.index_regs[i].rxinterval);\n\t\tmusb_write_txfunaddr(musb, i,\n\t\t\t\tmusb->context.index_regs[i].txfunaddr);\n\t\tmusb_write_txhubaddr(musb, i,\n\t\t\t\tmusb->context.index_regs[i].txhubaddr);\n\t\tmusb_write_txhubport(musb, i,\n\t\t\t\tmusb->context.index_regs[i].txhubport);\n\n\t\tmusb_write_rxfunaddr(musb, i,\n\t\t\t\tmusb->context.index_regs[i].rxfunaddr);\n\t\tmusb_write_rxhubaddr(musb, i,\n\t\t\t\tmusb->context.index_regs[i].rxhubaddr);\n\t\tmusb_write_rxhubport(musb, i,\n\t\t\t\tmusb->context.index_regs[i].rxhubport);\n\t}\n\tmusb_writeb(musb_base, MUSB_INDEX, musb->context.index);\n}\n\nstatic int musb_suspend(struct device *dev)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\tunsigned long\tflags;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn ret;\n\t}\n\n\tmusb_platform_disable(musb);\n\tmusb_disable_interrupts(musb);\n\n\tmusb->flush_irq_work = true;\n\twhile (flush_delayed_work(&musb->irq_work))\n\t\t;\n\tmusb->flush_irq_work = false;\n\n\tif (!(musb->ops->quirks & MUSB_PRESERVE_SESSION))\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\n\n\tWARN_ON(!list_empty(&musb->pending_list));\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (is_peripheral_active(musb)) {\n\t\t \n\t} else if (is_host_active(musb)) {\n\t\t \n\t}\n\n\tmusb_save_context(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn 0;\n}\n\nstatic int musb_resume(struct device *dev)\n{\n\tstruct musb *musb = dev_to_musb(dev);\n\tunsigned long flags;\n\tint error;\n\tu8 devctl;\n\tu8 mask;\n\n\t \n\n\tmusb_restore_context(musb);\n\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\tmask = MUSB_DEVCTL_BDEVICE | MUSB_DEVCTL_FSDEV | MUSB_DEVCTL_LSDEV;\n\tif ((devctl & mask) != (musb->context.devctl & mask))\n\t\tmusb->port1_status = 0;\n\n\tmusb_enable_interrupts(musb);\n\tmusb_platform_enable(musb);\n\n\t \n\tif (musb->port_mode == MUSB_HOST &&\n\t    !(musb->ops->quirks & MUSB_PRESERVE_SESSION)) {\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\t}\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\terror = musb_run_resume_work(musb);\n\tif (error)\n\t\tdev_err(musb->controller, \"resume work failed with %i\\n\",\n\t\t\terror);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n}\n\nstatic int musb_runtime_suspend(struct device *dev)\n{\n\tstruct musb\t*musb = dev_to_musb(dev);\n\n\tmusb_save_context(musb);\n\tmusb->is_runtime_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int musb_runtime_resume(struct device *dev)\n{\n\tstruct musb *musb = dev_to_musb(dev);\n\tunsigned long flags;\n\tint error;\n\n\t \n\tif (!musb->is_initialized)\n\t\treturn 0;\n\n\tmusb_restore_context(musb);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\terror = musb_run_resume_work(musb);\n\tif (error)\n\t\tdev_err(musb->controller, \"resume work failed with %i\\n\",\n\t\t\terror);\n\tmusb->is_runtime_suspended = 0;\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops musb_dev_pm_ops = {\n\t.suspend\t= musb_suspend,\n\t.resume\t\t= musb_resume,\n\t.runtime_suspend = musb_runtime_suspend,\n\t.runtime_resume = musb_runtime_resume,\n};\n\n#define MUSB_DEV_PM_OPS (&musb_dev_pm_ops)\n#else\n#define\tMUSB_DEV_PM_OPS\tNULL\n#endif\n\nstatic struct platform_driver musb_driver = {\n\t.driver = {\n\t\t.name\t\t= musb_driver_name,\n\t\t.bus\t\t= &platform_bus_type,\n\t\t.pm\t\t= MUSB_DEV_PM_OPS,\n\t\t.dev_groups\t= musb_groups,\n\t},\n\t.probe\t\t= musb_probe,\n\t.remove_new\t= musb_remove,\n};\n\nmodule_platform_driver(musb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}