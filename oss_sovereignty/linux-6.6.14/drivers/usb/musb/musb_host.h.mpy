{
  "module_name": "musb_host.h",
  "hash_id": "2212eaa1a2518896d72a4a8ab5fd52584dc7b13de280820b2846baf9efffe2dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_host.h",
  "human_readable_source": " \n \n\n#ifndef _MUSB_HOST_H\n#define _MUSB_HOST_H\n\n#include <linux/scatterlist.h>\n\n \nstruct musb_qh {\n\tstruct usb_host_endpoint *hep;\t\t \n\tstruct usb_device\t*dev;\n\tstruct musb_hw_ep\t*hw_ep;\t\t \n\n\tstruct list_head\tring;\t\t \n\t \t \n\tu8\t\t\tmux;\t\t \n\n\tunsigned\t\toffset;\t\t \n\tunsigned\t\tsegsize;\t \n\n\tu8\t\t\ttype_reg;\t \n\tu8\t\t\tintv_reg;\t \n\tu8\t\t\taddr_reg;\t \n\tu8\t\t\th_addr_reg;\t \n\tu8\t\t\th_port_reg;\t \n\n\tu8\t\t\tis_ready;\t \n\tu8\t\t\ttype;\t\t \n\tu8\t\t\tepnum;\n\tu8\t\t\thb_mult;\t \n\tu16\t\t\tmaxpacket;\n\tu16\t\t\tframe;\t\t \n\tunsigned\t\tiso_idx;\t \n\tstruct sg_mapping_iter sg_miter;\t \n\tbool\t\t\tuse_sg;\t\t \n};\n\n \nstatic inline struct musb_qh *first_qh(struct list_head *q)\n{\n\tif (list_empty(q))\n\t\treturn NULL;\n\treturn list_entry(q->next, struct musb_qh, ring);\n}\n\n\n#if IS_ENABLED(CONFIG_USB_MUSB_HOST) || IS_ENABLED(CONFIG_USB_MUSB_DUAL_ROLE)\nextern struct musb *hcd_to_musb(struct usb_hcd *);\nextern irqreturn_t musb_h_ep0_irq(struct musb *);\nextern int musb_host_alloc(struct musb *);\nextern int musb_host_setup(struct musb *, int);\nextern void musb_host_cleanup(struct musb *);\nextern void musb_host_tx(struct musb *, u8);\nextern void musb_host_rx(struct musb *, u8);\nextern void musb_root_disconnect(struct musb *musb);\nextern void musb_host_free(struct musb *);\nextern void musb_host_resume_root_hub(struct musb *musb);\nextern void musb_host_poke_root_hub(struct musb *musb);\nextern int musb_port_suspend(struct musb *musb, bool do_suspend);\nextern void musb_port_reset(struct musb *musb, bool do_reset);\nextern void musb_host_finish_resume(struct work_struct *work);\n#else\nstatic inline struct musb *hcd_to_musb(struct usb_hcd *hcd)\n{\n\treturn NULL;\n}\n\nstatic inline irqreturn_t musb_h_ep0_irq(struct musb *musb)\n{\n\treturn 0;\n}\n\nstatic inline int musb_host_alloc(struct musb *musb)\n{\n\treturn 0;\n}\n\nstatic inline int musb_host_setup(struct musb *musb, int power_budget)\n{\n\treturn 0;\n}\n\nstatic inline void musb_host_cleanup(struct musb *musb)\t\t{}\nstatic inline void musb_host_free(struct musb *musb)\t\t{}\nstatic inline void musb_host_tx(struct musb *musb, u8 epnum)\t{}\nstatic inline void musb_host_rx(struct musb *musb, u8 epnum)\t{}\nstatic inline void musb_root_disconnect(struct musb *musb)\t{}\nstatic inline void musb_host_resume_root_hub(struct musb *musb)\t{}\nstatic inline void musb_host_poke_root_hub(struct musb *musb)\t{}\nstatic inline int musb_port_suspend(struct musb *musb, bool do_suspend)\n{\n\treturn 0;\n}\nstatic inline void musb_port_reset(struct musb *musb, bool do_reset) {}\nstatic inline void musb_host_finish_resume(struct work_struct *work) {}\n#endif\n\nstruct usb_hcd;\n\nextern int musb_hub_status_data(struct usb_hcd *hcd, char *buf);\nextern int musb_hub_control(struct usb_hcd *hcd,\n\t\t\tu16 typeReq, u16 wValue, u16 wIndex,\n\t\t\tchar *buf, u16 wLength);\n\nstatic inline struct urb *next_urb(struct musb_qh *qh)\n{\n\tstruct list_head\t*queue;\n\n\tif (!qh)\n\t\treturn NULL;\n\tqueue = &qh->hep->urb_list;\n\tif (list_empty(queue))\n\t\treturn NULL;\n\treturn list_entry(queue->next, struct urb, urb_list);\n}\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}