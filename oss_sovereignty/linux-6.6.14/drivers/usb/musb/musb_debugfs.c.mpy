{
  "module_name": "musb_debugfs.c",
  "hash_id": "325e8b9fa60420ddf2bdb686047a89c58f6382266e92923375b8c19e09e6f78b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <linux/uaccess.h>\n\n#include \"musb_core.h\"\n#include \"musb_debug.h\"\n\nstruct musb_register_map {\n\tchar\t\t\t*name;\n\tunsigned\t\toffset;\n\tunsigned\t\tsize;\n};\n\nstatic const struct musb_register_map musb_regmap[] = {\n\t{ \"FAddr\",\tMUSB_FADDR,\t8 },\n\t{ \"Power\",\tMUSB_POWER,\t8 },\n\t{ \"Frame\",\tMUSB_FRAME,\t16 },\n\t{ \"Index\",\tMUSB_INDEX,\t8 },\n\t{ \"Testmode\",\tMUSB_TESTMODE,\t8 },\n\t{ \"TxMaxPp\",\tMUSB_TXMAXP,\t16 },\n\t{ \"TxCSRp\",\tMUSB_TXCSR,\t16 },\n\t{ \"RxMaxPp\",\tMUSB_RXMAXP,\t16 },\n\t{ \"RxCSR\",\tMUSB_RXCSR,\t16 },\n\t{ \"RxCount\",\tMUSB_RXCOUNT,\t16 },\n\t{ \"IntrRxE\",\tMUSB_INTRRXE,\t16 },\n\t{ \"IntrTxE\",\tMUSB_INTRTXE,\t16 },\n\t{ \"IntrUsbE\",\tMUSB_INTRUSBE,\t8 },\n\t{ \"DevCtl\",\tMUSB_DEVCTL,\t8 },\n\t{ \"VControl\",\t0x68,\t\t32 },\n\t{ \"HWVers\",\tMUSB_HWVERS,\t16 },\n\t{ \"LinkInfo\",\tMUSB_LINKINFO,\t8 },\n\t{ \"VPLen\",\tMUSB_VPLEN,\t8 },\n\t{ \"HS_EOF1\",\tMUSB_HS_EOF1,\t8 },\n\t{ \"FS_EOF1\",\tMUSB_FS_EOF1,\t8 },\n\t{ \"LS_EOF1\",\tMUSB_LS_EOF1,\t8 },\n\t{ \"SOFT_RST\",\t0x7F,\t\t8 },\n\t{ \"DMA_CNTLch0\",\t0x204,\t16 },\n\t{ \"DMA_ADDRch0\",\t0x208,\t32 },\n\t{ \"DMA_COUNTch0\",\t0x20C,\t32 },\n\t{ \"DMA_CNTLch1\",\t0x214,\t16 },\n\t{ \"DMA_ADDRch1\",\t0x218,\t32 },\n\t{ \"DMA_COUNTch1\",\t0x21C,\t32 },\n\t{ \"DMA_CNTLch2\",\t0x224,\t16 },\n\t{ \"DMA_ADDRch2\",\t0x228,\t32 },\n\t{ \"DMA_COUNTch2\",\t0x22C,\t32 },\n\t{ \"DMA_CNTLch3\",\t0x234,\t16 },\n\t{ \"DMA_ADDRch3\",\t0x238,\t32 },\n\t{ \"DMA_COUNTch3\",\t0x23C,\t32 },\n\t{ \"DMA_CNTLch4\",\t0x244,\t16 },\n\t{ \"DMA_ADDRch4\",\t0x248,\t32 },\n\t{ \"DMA_COUNTch4\",\t0x24C,\t32 },\n\t{ \"DMA_CNTLch5\",\t0x254,\t16 },\n\t{ \"DMA_ADDRch5\",\t0x258,\t32 },\n\t{ \"DMA_COUNTch5\",\t0x25C,\t32 },\n\t{ \"DMA_CNTLch6\",\t0x264,\t16 },\n\t{ \"DMA_ADDRch6\",\t0x268,\t32 },\n\t{ \"DMA_COUNTch6\",\t0x26C,\t32 },\n\t{ \"DMA_CNTLch7\",\t0x274,\t16 },\n\t{ \"DMA_ADDRch7\",\t0x278,\t32 },\n\t{ \"DMA_COUNTch7\",\t0x27C,\t32 },\n\t{ \"ConfigData\",\tMUSB_CONFIGDATA,8 },\n\t{ \"BabbleCtl\",\tMUSB_BABBLE_CTL,8 },\n\t{ \"TxFIFOsz\",\tMUSB_TXFIFOSZ,\t8 },\n\t{ \"RxFIFOsz\",\tMUSB_RXFIFOSZ,\t8 },\n\t{ \"TxFIFOadd\",\tMUSB_TXFIFOADD,\t16 },\n\t{ \"RxFIFOadd\",\tMUSB_RXFIFOADD,\t16 },\n\t{ \"EPInfo\",\tMUSB_EPINFO,\t8 },\n\t{ \"RAMInfo\",\tMUSB_RAMINFO,\t8 },\n\t{  }\t \n};\n\nstatic int musb_regdump_show(struct seq_file *s, void *unused)\n{\n\tstruct musb\t\t*musb = s->private;\n\tunsigned\t\ti;\n\n\tseq_printf(s, \"MUSB (M)HDRC Register Dump\\n\");\n\tpm_runtime_get_sync(musb->controller);\n\n\tfor (i = 0; i < ARRAY_SIZE(musb_regmap); i++) {\n\t\tswitch (musb_regmap[i].size) {\n\t\tcase 8:\n\t\t\tseq_printf(s, \"%-12s: %02x\\n\", musb_regmap[i].name,\n\t\t\t\t\tmusb_readb(musb->mregs, musb_regmap[i].offset));\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tseq_printf(s, \"%-12s: %04x\\n\", musb_regmap[i].name,\n\t\t\t\t\tmusb_readw(musb->mregs, musb_regmap[i].offset));\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\tseq_printf(s, \"%-12s: %08x\\n\", musb_regmap[i].name,\n\t\t\t\t\tmusb_readl(musb->mregs, musb_regmap[i].offset));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(musb_regdump);\n\nstatic int musb_test_mode_show(struct seq_file *s, void *unused)\n{\n\tstruct musb\t\t*musb = s->private;\n\tunsigned\t\ttest;\n\n\tpm_runtime_get_sync(musb->controller);\n\ttest = musb_readb(musb->mregs, MUSB_TESTMODE);\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\n\tif (test == (MUSB_TEST_FORCE_HOST | MUSB_TEST_FORCE_FS))\n\t\tseq_printf(s, \"force host full-speed\\n\");\n\n\telse if (test == (MUSB_TEST_FORCE_HOST | MUSB_TEST_FORCE_HS))\n\t\tseq_printf(s, \"force host high-speed\\n\");\n\n\telse if (test == MUSB_TEST_FORCE_HOST)\n\t\tseq_printf(s, \"force host\\n\");\n\n\telse if (test == MUSB_TEST_FIFO_ACCESS)\n\t\tseq_printf(s, \"fifo access\\n\");\n\n\telse if (test == MUSB_TEST_FORCE_FS)\n\t\tseq_printf(s, \"force full-speed\\n\");\n\n\telse if (test == MUSB_TEST_FORCE_HS)\n\t\tseq_printf(s, \"force high-speed\\n\");\n\n\telse if (test == MUSB_TEST_PACKET)\n\t\tseq_printf(s, \"test packet\\n\");\n\n\telse if (test == MUSB_TEST_K)\n\t\tseq_printf(s, \"test K\\n\");\n\n\telse if (test == MUSB_TEST_J)\n\t\tseq_printf(s, \"test J\\n\");\n\n\telse if (test == MUSB_TEST_SE0_NAK)\n\t\tseq_printf(s, \"test SE0 NAK\\n\");\n\n\treturn 0;\n}\n\nstatic int musb_test_mode_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, musb_test_mode_show, inode->i_private);\n}\n\nstatic ssize_t musb_test_mode_write(struct file *file,\n\t\tconst char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tstruct seq_file\t\t*s = file->private_data;\n\tstruct musb\t\t*musb = s->private;\n\tu8\t\t\ttest;\n\tchar\t\t\tbuf[24];\n\n\tmemset(buf, 0x00, sizeof(buf));\n\n\tif (copy_from_user(buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tpm_runtime_get_sync(musb->controller);\n\ttest = musb_readb(musb->mregs, MUSB_TESTMODE);\n\tif (test) {\n\t\tdev_err(musb->controller, \"Error: test mode is already set. \"\n\t\t\t\"Please do USB Bus Reset to start a new test.\\n\");\n\t\tgoto ret;\n\t}\n\n\tif (strstarts(buf, \"force host full-speed\"))\n\t\ttest = MUSB_TEST_FORCE_HOST | MUSB_TEST_FORCE_FS;\n\n\telse if (strstarts(buf, \"force host high-speed\"))\n\t\ttest = MUSB_TEST_FORCE_HOST | MUSB_TEST_FORCE_HS;\n\n\telse if (strstarts(buf, \"force host\"))\n\t\ttest = MUSB_TEST_FORCE_HOST;\n\n\telse if (strstarts(buf, \"fifo access\"))\n\t\ttest = MUSB_TEST_FIFO_ACCESS;\n\n\telse if (strstarts(buf, \"force full-speed\"))\n\t\ttest = MUSB_TEST_FORCE_FS;\n\n\telse if (strstarts(buf, \"force high-speed\"))\n\t\ttest = MUSB_TEST_FORCE_HS;\n\n\telse if (strstarts(buf, \"test packet\")) {\n\t\ttest = MUSB_TEST_PACKET;\n\t\tmusb_load_testpacket(musb);\n\t}\n\n\telse if (strstarts(buf, \"test K\"))\n\t\ttest = MUSB_TEST_K;\n\n\telse if (strstarts(buf, \"test J\"))\n\t\ttest = MUSB_TEST_J;\n\n\telse if (strstarts(buf, \"test SE0 NAK\"))\n\t\ttest = MUSB_TEST_SE0_NAK;\n\n\tmusb_writeb(musb->mregs, MUSB_TESTMODE, test);\n\nret:\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\treturn count;\n}\n\nstatic const struct file_operations musb_test_mode_fops = {\n\t.open\t\t\t= musb_test_mode_open,\n\t.write\t\t\t= musb_test_mode_write,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\nstatic int musb_softconnect_show(struct seq_file *s, void *unused)\n{\n\tstruct musb\t*musb = s->private;\n\tu8\t\treg;\n\tint\t\tconnect;\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_HOST:\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tpm_runtime_get_sync(musb->controller);\n\n\t\treg = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\tconnect = reg & MUSB_DEVCTL_SESSION ? 1 : 0;\n\n\t\tpm_runtime_mark_last_busy(musb->controller);\n\t\tpm_runtime_put_autosuspend(musb->controller);\n\t\tbreak;\n\tdefault:\n\t\tconnect = -1;\n\t}\n\n\tseq_printf(s, \"%d\\n\", connect);\n\n\treturn 0;\n}\n\nstatic int musb_softconnect_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, musb_softconnect_show, inode->i_private);\n}\n\nstatic ssize_t musb_softconnect_write(struct file *file,\n\t\tconst char __user *ubuf, size_t count, loff_t *ppos)\n{\n\tstruct seq_file\t\t*s = file->private_data;\n\tstruct musb\t\t*musb = s->private;\n\tchar\t\t\tbuf[2];\n\tu8\t\t\treg;\n\n\tmemset(buf, 0x00, sizeof(buf));\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tpm_runtime_get_sync(musb->controller);\n\tif (!strncmp(buf, \"0\", 1)) {\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_HOST:\n\t\t\tmusb_root_disconnect(musb);\n\t\t\treg = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\t\treg &= ~MUSB_DEVCTL_SESSION;\n\t\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, reg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else if (!strncmp(buf, \"1\", 1)) {\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_WAIT_BCON:\n\t\t\t \n\t\t\tmusb->context.devctl |= MUSB_DEVCTL_SESSION;\n\t\t\treg = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\t\treg |= MUSB_DEVCTL_SESSION;\n\t\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, reg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\treturn count;\n}\n\n \nstatic const struct file_operations musb_softconnect_fops = {\n\t.open\t\t\t= musb_softconnect_open,\n\t.write\t\t\t= musb_softconnect_write,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\nvoid musb_init_debugfs(struct musb *musb)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(dev_name(musb->controller), usb_debug_root);\n\tmusb->debugfs_root = root;\n\n\tdebugfs_create_file(\"regdump\", S_IRUGO, root, musb, &musb_regdump_fops);\n\tdebugfs_create_file(\"testmode\", S_IRUGO | S_IWUSR, root, musb,\n\t\t\t    &musb_test_mode_fops);\n\tdebugfs_create_file(\"softconnect\", S_IRUGO | S_IWUSR, root, musb,\n\t\t\t    &musb_softconnect_fops);\n}\n\nvoid   musb_exit_debugfs(struct musb *musb)\n{\n\tdebugfs_remove_recursive(musb->debugfs_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}