{
  "module_name": "ux500.c",
  "hash_id": "98f947b77814e6dee2c7b3de67bbb9b6f0e0ab3c447465cec7e5a920c3310231",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/ux500.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/usb/musb-ux500.h>\n\n#include \"musb_core.h\"\n\nstatic const struct musb_hdrc_config ux500_musb_hdrc_config = {\n\t.multipoint\t= true,\n\t.dyn_fifo\t= true,\n\t.num_eps\t= 16,\n\t.ram_bits\t= 16,\n};\n\nstruct ux500_glue {\n\tstruct device\t\t*dev;\n\tstruct platform_device\t*musb;\n\tstruct clk\t\t*clk;\n};\n#define glue_to_musb(g)\tplatform_get_drvdata(g->musb)\n\nstatic void ux500_musb_set_vbus(struct musb *musb, int is_on)\n{\n\tu8            devctl;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(1000);\n\t \n\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\n\tif (is_on) {\n\t\tif (musb->xceiv->otg->state == OTG_STATE_A_IDLE) {\n\t\t\t \n\t\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\t\t\t \n\t\t\twhile (musb_readb(musb->mregs, MUSB_DEVCTL) & 0x80) {\n\n\t\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\t\tdev_err(musb->controller,\n\t\t\t\t\t\"configured as A device timeout\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\t\t\tmusb->is_active = 1;\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\t\tMUSB_HST_MODE(musb);\n\t\t}\n\t} else {\n\t\tmusb->is_active = 0;\n\n\t\t \n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\tMUSB_DEV_MODE(musb);\n\t}\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\t \n\tif (!is_on)\n\t\tmdelay(200);\n\n\tdev_dbg(musb->controller, \"VBUS %s, devctl %02x\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\tmusb_readb(musb->mregs, MUSB_DEVCTL));\n}\n\nstatic int musb_otg_notifications(struct notifier_block *nb,\n\t\tunsigned long event, void *unused)\n{\n\tstruct musb *musb = container_of(nb, struct musb, nb);\n\n\tdev_dbg(musb->controller, \"musb_otg_notifications %ld %s\\n\",\n\t\t\tevent, usb_otg_state_string(musb->xceiv->otg->state));\n\n\tswitch (event) {\n\tcase UX500_MUSB_ID:\n\t\tdev_dbg(musb->controller, \"ID GND\\n\");\n\t\tux500_musb_set_vbus(musb, 1);\n\t\tbreak;\n\tcase UX500_MUSB_VBUS:\n\t\tdev_dbg(musb->controller, \"VBUS Connect\\n\");\n\t\tbreak;\n\tcase UX500_MUSB_NONE:\n\t\tdev_dbg(musb->controller, \"VBUS Disconnect\\n\");\n\t\tif (is_host_active(musb))\n\t\t\tux500_musb_set_vbus(musb, 0);\n\t\telse\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(musb->controller, \"ID float\\n\");\n\t\treturn NOTIFY_DONE;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic irqreturn_t ux500_musb_interrupt(int irq, void *__hci)\n{\n\tunsigned long   flags;\n\tirqreturn_t     retval = IRQ_NONE;\n\tstruct musb     *musb = __hci;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\n\tmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\n\tmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\n\n\tif (musb->int_usb || musb->int_tx || musb->int_rx)\n\t\tretval = musb_interrupt(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn retval;\n}\n\nstatic int ux500_musb_init(struct musb *musb)\n{\n\tint status;\n\n\tmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\n\tif (IS_ERR_OR_NULL(musb->xceiv)) {\n\t\tpr_err(\"HS USB OTG: no transceiver configured\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tmusb->nb.notifier_call = musb_otg_notifications;\n\tstatus = usb_register_notifier(musb->xceiv, &musb->nb);\n\tif (status < 0) {\n\t\tdev_dbg(musb->controller, \"notification register failed\\n\");\n\t\treturn status;\n\t}\n\n\tmusb->isr = ux500_musb_interrupt;\n\n\treturn 0;\n}\n\nstatic int ux500_musb_exit(struct musb *musb)\n{\n\tusb_unregister_notifier(musb->xceiv, &musb->nb);\n\n\tusb_put_phy(musb->xceiv);\n\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops ux500_ops = {\n\t.quirks\t\t= MUSB_DMA_UX500 | MUSB_INDEXED_EP,\n#ifdef CONFIG_USB_UX500_DMA\n\t.dma_init\t= ux500_dma_controller_create,\n\t.dma_exit\t= ux500_dma_controller_destroy,\n#endif\n\t.init\t\t= ux500_musb_init,\n\t.exit\t\t= ux500_musb_exit,\n\t.fifo_mode\t= 5,\n\n\t.set_vbus\t= ux500_musb_set_vbus,\n};\n\nstatic struct musb_hdrc_platform_data *\nux500_of_probe(struct platform_device *pdev, struct device_node *np)\n{\n\tstruct musb_hdrc_platform_data *pdata;\n\tconst char *mode;\n\tint strlen;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tmode = of_get_property(np, \"dr_mode\", &strlen);\n\tif (!mode) {\n\t\tdev_err(&pdev->dev, \"No 'dr_mode' property found\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (strlen > 0) {\n\t\tif (!strcmp(mode, \"host\"))\n\t\t\tpdata->mode = MUSB_HOST;\n\t\tif (!strcmp(mode, \"otg\"))\n\t\t\tpdata->mode = MUSB_OTG;\n\t\tif (!strcmp(mode, \"peripheral\"))\n\t\t\tpdata->mode = MUSB_PERIPHERAL;\n\t}\n\n\treturn pdata;\n}\n\nstatic int ux500_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data\t*pdata = dev_get_platdata(&pdev->dev);\n\tstruct device_node\t\t*np = pdev->dev.of_node;\n\tstruct platform_device\t\t*musb;\n\tstruct ux500_glue\t\t*glue;\n\tstruct clk\t\t\t*clk;\n\tint\t\t\t\tret = -ENOMEM;\n\n\tif (!pdata) {\n\t\tif (np) {\n\t\t\tpdata = ux500_of_probe(pdev, np);\n\t\t\tif (!pdata)\n\t\t\t\tgoto err0;\n\n\t\t\tpdev->dev.platform_data = pdata;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"no pdata or device tree found\\n\");\n\t\t\tgoto err0;\n\t\t}\n\t}\n\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\tgoto err0;\n\n\tmusb = platform_device_alloc(\"musb-hdrc\", PLATFORM_DEVID_AUTO);\n\tif (!musb) {\n\t\tdev_err(&pdev->dev, \"failed to allocate musb device\\n\");\n\t\tgoto err0;\n\t}\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(clk);\n\t\tgoto err1;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\tgoto err1;\n\t}\n\n\tmusb->dev.parent\t\t= &pdev->dev;\n\tmusb->dev.dma_mask\t\t= &pdev->dev.coherent_dma_mask;\n\tmusb->dev.coherent_dma_mask\t= pdev->dev.coherent_dma_mask;\n\tdevice_set_of_node_from_dev(&musb->dev, &pdev->dev);\n\n\tglue->dev\t\t\t= &pdev->dev;\n\tglue->musb\t\t\t= musb;\n\tglue->clk\t\t\t= clk;\n\n\tpdata->platform_ops\t\t= &ux500_ops;\n\tpdata->config \t\t\t= &ux500_musb_hdrc_config;\n\n\tplatform_set_drvdata(pdev, glue);\n\n\tret = platform_device_add_resources(musb, pdev->resource, pdev->num_resources);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto err2;\n\t}\n\n\tret = platform_device_add_data(musb, pdata, sizeof(*pdata));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add platform_data\\n\");\n\t\tgoto err2;\n\t}\n\n\tret = platform_device_add(musb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register musb device\\n\");\n\t\tgoto err2;\n\t}\n\n\treturn 0;\n\nerr2:\n\tclk_disable_unprepare(clk);\n\nerr1:\n\tplatform_device_put(musb);\n\nerr0:\n\treturn ret;\n}\n\nstatic void ux500_remove(struct platform_device *pdev)\n{\n\tstruct ux500_glue\t*glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->musb);\n\tclk_disable_unprepare(glue->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ux500_suspend(struct device *dev)\n{\n\tstruct ux500_glue\t*glue = dev_get_drvdata(dev);\n\tstruct musb\t\t*musb = glue_to_musb(glue);\n\n\tif (musb)\n\t\tusb_phy_set_suspend(musb->xceiv, 1);\n\n\tclk_disable_unprepare(glue->clk);\n\n\treturn 0;\n}\n\nstatic int ux500_resume(struct device *dev)\n{\n\tstruct ux500_glue\t*glue = dev_get_drvdata(dev);\n\tstruct musb\t\t*musb = glue_to_musb(glue);\n\tint\t\t\tret;\n\n\tret = clk_prepare_enable(glue->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tif (musb)\n\t\tusb_phy_set_suspend(musb->xceiv, 0);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ux500_pm_ops, ux500_suspend, ux500_resume);\n\nstatic const struct of_device_id ux500_match[] = {\n        { .compatible = \"stericsson,db8500-musb\", },\n        {}\n};\n\nMODULE_DEVICE_TABLE(of, ux500_match);\n\nstatic struct platform_driver ux500_driver = {\n\t.probe\t\t= ux500_probe,\n\t.remove_new\t= ux500_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"musb-ux500\",\n\t\t.pm\t= &ux500_pm_ops,\n\t\t.of_match_table = ux500_match,\n\t},\n};\n\nMODULE_DESCRIPTION(\"UX500 MUSB Glue Layer\");\nMODULE_AUTHOR(\"Mian Yousaf Kaukab <mian.yousaf.kaukab@stericsson.com>\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_platform_driver(ux500_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}