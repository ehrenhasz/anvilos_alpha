{
  "module_name": "ux500_dma.c",
  "hash_id": "540e62fd4de1c11ae136f6d3c71c33faf3b47aceb62bf9165e4cae2f11375c54",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/ux500_dma.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/pfn.h>\n#include <linux/sizes.h>\n#include <linux/platform_data/usb-musb-ux500.h>\n#include \"musb_core.h\"\n\nstatic const char *iep_chan_names[] = { \"iep_1_9\", \"iep_2_10\", \"iep_3_11\", \"iep_4_12\",\n\t\t\t\t\t\"iep_5_13\", \"iep_6_14\", \"iep_7_15\", \"iep_8\" };\nstatic const char *oep_chan_names[] = { \"oep_1_9\", \"oep_2_10\", \"oep_3_11\", \"oep_4_12\",\n\t\t\t\t\t\"oep_5_13\", \"oep_6_14\", \"oep_7_15\", \"oep_8\" };\n\nstruct ux500_dma_channel {\n\tstruct dma_channel channel;\n\tstruct ux500_dma_controller *controller;\n\tstruct musb_hw_ep *hw_ep;\n\tstruct dma_chan *dma_chan;\n\tunsigned int cur_len;\n\tdma_cookie_t cookie;\n\tu8 ch_num;\n\tu8 is_tx;\n\tu8 is_allocated;\n};\n\nstruct ux500_dma_controller {\n\tstruct dma_controller controller;\n\tstruct ux500_dma_channel rx_channel[UX500_MUSB_DMA_NUM_RX_TX_CHANNELS];\n\tstruct ux500_dma_channel tx_channel[UX500_MUSB_DMA_NUM_RX_TX_CHANNELS];\n\tvoid *private_data;\n\tdma_addr_t phy_base;\n};\n\n \nstatic void ux500_dma_callback(void *private_data)\n{\n\tstruct dma_channel *channel = private_data;\n\tstruct ux500_dma_channel *ux500_channel = channel->private_data;\n\tstruct musb_hw_ep       *hw_ep = ux500_channel->hw_ep;\n\tstruct musb *musb = hw_ep->musb;\n\tunsigned long flags;\n\n\tdev_dbg(musb->controller, \"DMA rx transfer done on hw_ep=%d\\n\",\n\t\thw_ep->epnum);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tux500_channel->channel.actual_len = ux500_channel->cur_len;\n\tux500_channel->channel.status = MUSB_DMA_STATUS_FREE;\n\tmusb_dma_completion(musb, hw_ep->epnum, ux500_channel->is_tx);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n}\n\nstatic bool ux500_configure_channel(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tstruct ux500_dma_channel *ux500_channel = channel->private_data;\n\tstruct musb_hw_ep *hw_ep = ux500_channel->hw_ep;\n\tstruct dma_chan *dma_chan = ux500_channel->dma_chan;\n\tstruct dma_async_tx_descriptor *dma_desc;\n\tenum dma_transfer_direction direction;\n\tstruct scatterlist sg;\n\tstruct dma_slave_config slave_conf;\n\tenum dma_slave_buswidth addr_width;\n\tstruct musb *musb = ux500_channel->controller->private_data;\n\tdma_addr_t usb_fifo_addr = (musb->io.fifo_offset(hw_ep->epnum) +\n\t\t\t\t\tux500_channel->controller->phy_base);\n\n\tdev_dbg(musb->controller,\n\t\t\"packet_sz=%d, mode=%d, dma_addr=0x%llx, len=%d is_tx=%d\\n\",\n\t\tpacket_sz, mode, (unsigned long long) dma_addr,\n\t\tlen, ux500_channel->is_tx);\n\n\tux500_channel->cur_len = len;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, pfn_to_page(PFN_DOWN(dma_addr)), len,\n\t\t\t\t\t    offset_in_page(dma_addr));\n\tsg_dma_address(&sg) = dma_addr;\n\tsg_dma_len(&sg) = len;\n\n\tdirection = ux500_channel->is_tx ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\n\taddr_width = (len & 0x3) ? DMA_SLAVE_BUSWIDTH_1_BYTE :\n\t\t\t\t\tDMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\tslave_conf.direction = direction;\n\tslave_conf.src_addr = usb_fifo_addr;\n\tslave_conf.src_addr_width = addr_width;\n\tslave_conf.src_maxburst = 16;\n\tslave_conf.dst_addr = usb_fifo_addr;\n\tslave_conf.dst_addr_width = addr_width;\n\tslave_conf.dst_maxburst = 16;\n\tslave_conf.device_fc = false;\n\n\tdmaengine_slave_config(dma_chan, &slave_conf);\n\n\tdma_desc = dmaengine_prep_slave_sg(dma_chan, &sg, 1, direction,\n\t\t\t\t\t     DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!dma_desc)\n\t\treturn false;\n\n\tdma_desc->callback = ux500_dma_callback;\n\tdma_desc->callback_param = channel;\n\tux500_channel->cookie = dma_desc->tx_submit(dma_desc);\n\n\tdma_async_issue_pending(dma_chan);\n\n\treturn true;\n}\n\nstatic struct dma_channel *ux500_dma_channel_allocate(struct dma_controller *c,\n\t\t\t\tstruct musb_hw_ep *hw_ep, u8 is_tx)\n{\n\tstruct ux500_dma_controller *controller = container_of(c,\n\t\t\tstruct ux500_dma_controller, controller);\n\tstruct ux500_dma_channel *ux500_channel = NULL;\n\tstruct musb *musb = controller->private_data;\n\tu8 ch_num = hw_ep->epnum - 1;\n\n\t \n\tif (ch_num > 7)\n\t\tch_num -= 8;\n\n\tif (ch_num >= UX500_MUSB_DMA_NUM_RX_TX_CHANNELS)\n\t\treturn NULL;\n\n\tux500_channel = is_tx ? &(controller->tx_channel[ch_num]) :\n\t\t\t\t&(controller->rx_channel[ch_num]) ;\n\n\t \n\tif (ux500_channel->is_allocated)\n\t\treturn NULL;\n\n\tux500_channel->hw_ep = hw_ep;\n\tux500_channel->is_allocated = 1;\n\n\tdev_dbg(musb->controller, \"hw_ep=%d, is_tx=0x%x, channel=%d\\n\",\n\t\thw_ep->epnum, is_tx, ch_num);\n\n\treturn &(ux500_channel->channel);\n}\n\nstatic void ux500_dma_channel_release(struct dma_channel *channel)\n{\n\tstruct ux500_dma_channel *ux500_channel = channel->private_data;\n\tstruct musb *musb = ux500_channel->controller->private_data;\n\n\tdev_dbg(musb->controller, \"channel=%d\\n\", ux500_channel->ch_num);\n\n\tif (ux500_channel->is_allocated) {\n\t\tux500_channel->is_allocated = 0;\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\t\tchannel->actual_len = 0;\n\t}\n}\n\nstatic int ux500_dma_is_compatible(struct dma_channel *channel,\n\t\tu16 maxpacket, void *buf, u32 length)\n{\n\tif ((maxpacket & 0x3)\t\t||\n\t\t((unsigned long int) buf & 0x3)\t||\n\t\t(length < 512)\t\t||\n\t\t(length & 0x3))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic int ux500_dma_channel_program(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tint ret;\n\n\tBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\n\t\tchannel->status == MUSB_DMA_STATUS_BUSY);\n\n\tchannel->status = MUSB_DMA_STATUS_BUSY;\n\tchannel->actual_len = 0;\n\tret = ux500_configure_channel(channel, packet_sz, mode, dma_addr, len);\n\tif (!ret)\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\n\treturn ret;\n}\n\nstatic int ux500_dma_channel_abort(struct dma_channel *channel)\n{\n\tstruct ux500_dma_channel *ux500_channel = channel->private_data;\n\tstruct ux500_dma_controller *controller = ux500_channel->controller;\n\tstruct musb *musb = controller->private_data;\n\tvoid __iomem *epio = musb->endpoints[ux500_channel->hw_ep->epnum].regs;\n\tu16 csr;\n\n\tdev_dbg(musb->controller, \"channel=%d, is_tx=%d\\n\",\n\t\tux500_channel->ch_num, ux500_channel->is_tx);\n\n\tif (channel->status == MUSB_DMA_STATUS_BUSY) {\n\t\tif (ux500_channel->is_tx) {\n\t\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\t\tcsr &= ~(MUSB_TXCSR_AUTOSET |\n\t\t\t\t MUSB_TXCSR_DMAENAB |\n\t\t\t\t MUSB_TXCSR_DMAMODE);\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t} else {\n\t\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\t\tcsr &= ~(MUSB_RXCSR_AUTOCLEAR |\n\t\t\t\t MUSB_RXCSR_DMAENAB |\n\t\t\t\t MUSB_RXCSR_DMAMODE);\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t}\n\n\t\tdmaengine_terminate_all(ux500_channel->dma_chan);\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\t}\n\treturn 0;\n}\n\nstatic void ux500_dma_controller_stop(struct ux500_dma_controller *controller)\n{\n\tstruct ux500_dma_channel *ux500_channel;\n\tstruct dma_channel *channel;\n\tu8 ch_num;\n\n\tfor (ch_num = 0; ch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS; ch_num++) {\n\t\tchannel = &controller->rx_channel[ch_num].channel;\n\t\tux500_channel = channel->private_data;\n\n\t\tux500_dma_channel_release(channel);\n\n\t\tif (ux500_channel->dma_chan)\n\t\t\tdma_release_channel(ux500_channel->dma_chan);\n\t}\n\n\tfor (ch_num = 0; ch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS; ch_num++) {\n\t\tchannel = &controller->tx_channel[ch_num].channel;\n\t\tux500_channel = channel->private_data;\n\n\t\tux500_dma_channel_release(channel);\n\n\t\tif (ux500_channel->dma_chan)\n\t\t\tdma_release_channel(ux500_channel->dma_chan);\n\t}\n}\n\nstatic int ux500_dma_controller_start(struct ux500_dma_controller *controller)\n{\n\tstruct ux500_dma_channel *ux500_channel = NULL;\n\tstruct musb *musb = controller->private_data;\n\tstruct device *dev = musb->controller;\n\tstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\n\tstruct ux500_musb_board_data *data;\n\tstruct dma_channel *dma_channel = NULL;\n\tchar **chan_names;\n\tu32 ch_num;\n\tu8 dir;\n\tu8 is_tx = 0;\n\n\tvoid **param_array;\n\tstruct ux500_dma_channel *channel_array;\n\tdma_cap_mask_t mask;\n\n\tif (!plat) {\n\t\tdev_err(musb->controller, \"No platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata = plat->board_data;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\n\t \n\tchannel_array = controller->rx_channel;\n\tparam_array = data ? data->dma_rx_param_array : NULL;\n\tchan_names = (char **)iep_chan_names;\n\n\tfor (dir = 0; dir < 2; dir++) {\n\t\tfor (ch_num = 0;\n\t\t     ch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS;\n\t\t     ch_num++) {\n\t\t\tux500_channel = &channel_array[ch_num];\n\t\t\tux500_channel->controller = controller;\n\t\t\tux500_channel->ch_num = ch_num;\n\t\t\tux500_channel->is_tx = is_tx;\n\n\t\t\tdma_channel = &(ux500_channel->channel);\n\t\t\tdma_channel->private_data = ux500_channel;\n\t\t\tdma_channel->status = MUSB_DMA_STATUS_FREE;\n\t\t\tdma_channel->max_len = SZ_16M;\n\n\t\t\tux500_channel->dma_chan =\n\t\t\t\tdma_request_chan(dev, chan_names[ch_num]);\n\n\t\t\tif (IS_ERR(ux500_channel->dma_chan))\n\t\t\t\tux500_channel->dma_chan =\n\t\t\t\t\tdma_request_channel(mask,\n\t\t\t\t\t\t\t    data ?\n\t\t\t\t\t\t\t    data->dma_filter :\n\t\t\t\t\t\t\t    NULL,\n\t\t\t\t\t\t\t    param_array ?\n\t\t\t\t\t\t\t    param_array[ch_num] :\n\t\t\t\t\t\t\t    NULL);\n\n\t\t\tif (!ux500_channel->dma_chan) {\n\t\t\t\tERR(\"Dma pipe allocation error dir=%d ch=%d\\n\",\n\t\t\t\t\tdir, ch_num);\n\n\t\t\t\t \n\t\t\t\tux500_dma_controller_stop(controller);\n\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\tchannel_array = controller->tx_channel;\n\t\tparam_array = data ? data->dma_tx_param_array : NULL;\n\t\tchan_names = (char **)oep_chan_names;\n\t\tis_tx = 1;\n\t}\n\n\treturn 0;\n}\n\nvoid ux500_dma_controller_destroy(struct dma_controller *c)\n{\n\tstruct ux500_dma_controller *controller = container_of(c,\n\t\t\tstruct ux500_dma_controller, controller);\n\n\tux500_dma_controller_stop(controller);\n\tkfree(controller);\n}\nEXPORT_SYMBOL_GPL(ux500_dma_controller_destroy);\n\nstruct dma_controller *\nux500_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tstruct ux500_dma_controller *controller;\n\tstruct platform_device *pdev = to_platform_device(musb->controller);\n\tstruct resource\t*iomem;\n\tint ret;\n\n\tcontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\n\tif (!controller)\n\t\tgoto kzalloc_fail;\n\n\tcontroller->private_data = musb;\n\n\t \n\tiomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iomem) {\n\t\tdev_err(musb->controller, \"no memory resource defined\\n\");\n\t\tgoto plat_get_fail;\n\t}\n\n\tcontroller->phy_base = (dma_addr_t) iomem->start;\n\n\tcontroller->controller.channel_alloc = ux500_dma_channel_allocate;\n\tcontroller->controller.channel_release = ux500_dma_channel_release;\n\tcontroller->controller.channel_program = ux500_dma_channel_program;\n\tcontroller->controller.channel_abort = ux500_dma_channel_abort;\n\tcontroller->controller.is_compatible = ux500_dma_is_compatible;\n\n\tret = ux500_dma_controller_start(controller);\n\tif (ret)\n\t\tgoto plat_get_fail;\n\treturn &controller->controller;\n\nplat_get_fail:\n\tkfree(controller);\nkzalloc_fail:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(ux500_dma_controller_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}