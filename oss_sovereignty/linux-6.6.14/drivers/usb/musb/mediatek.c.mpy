{
  "module_name": "mediatek.c",
  "hash_id": "9f19ae56a16f82e23fc2923916f680fd965a06f1db73df295202a011818c7982",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/mediatek.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/usb/role.h>\n#include <linux/usb/usb_phy_generic.h>\n#include \"musb_core.h\"\n#include \"musb_dma.h\"\n\n#define USB_L1INTS\t\t0x00a0\n#define USB_L1INTM\t\t0x00a4\n#define MTK_MUSB_TXFUNCADDR\t0x0480\n\n \n#define MUSB_RXTOG\t\t0x80\n#define MUSB_RXTOGEN\t\t0x82\n#define MUSB_TXTOG\t\t0x84\n#define MUSB_TXTOGEN\t\t0x86\n#define MTK_TOGGLE_EN\t\tGENMASK(15, 0)\n\n#define TX_INT_STATUS\t\tBIT(0)\n#define RX_INT_STATUS\t\tBIT(1)\n#define USBCOM_INT_STATUS\tBIT(2)\n#define DMA_INT_STATUS\t\tBIT(3)\n\n#define DMA_INTR_STATUS_MSK\tGENMASK(7, 0)\n#define DMA_INTR_UNMASK_SET_MSK\tGENMASK(31, 24)\n\n#define MTK_MUSB_CLKS_NUM\t3\n\nstruct mtk_glue {\n\tstruct device *dev;\n\tstruct musb *musb;\n\tstruct platform_device *musb_pdev;\n\tstruct platform_device *usb_phy;\n\tstruct phy *phy;\n\tstruct usb_phy *xceiv;\n\tenum phy_mode phy_mode;\n\tstruct clk_bulk_data clks[MTK_MUSB_CLKS_NUM];\n\tenum usb_role role;\n\tstruct usb_role_switch *role_sw;\n};\n\nstatic int mtk_musb_clks_get(struct mtk_glue *glue)\n{\n\tstruct device *dev = glue->dev;\n\n\tglue->clks[0].id = \"main\";\n\tglue->clks[1].id = \"mcu\";\n\tglue->clks[2].id = \"univpll\";\n\n\treturn devm_clk_bulk_get(dev, MTK_MUSB_CLKS_NUM, glue->clks);\n}\n\nstatic int mtk_otg_switch_set(struct mtk_glue *glue, enum usb_role role)\n{\n\tstruct musb *musb = glue->musb;\n\tu8 devctl = readb(musb->mregs + MUSB_DEVCTL);\n\tenum usb_role new_role;\n\n\tif (role == glue->role)\n\t\treturn 0;\n\n\tswitch (role) {\n\tcase USB_ROLE_HOST:\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tglue->phy_mode = PHY_MODE_USB_HOST;\n\t\tnew_role = USB_ROLE_HOST;\n\t\tif (glue->role == USB_ROLE_NONE)\n\t\t\tphy_power_on(glue->phy);\n\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\t\tMUSB_HST_MODE(musb);\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\tglue->phy_mode = PHY_MODE_USB_DEVICE;\n\t\tnew_role = USB_ROLE_DEVICE;\n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\t\tif (glue->role == USB_ROLE_NONE)\n\t\t\tphy_power_on(glue->phy);\n\n\t\tMUSB_DEV_MODE(musb);\n\t\tbreak;\n\tcase USB_ROLE_NONE:\n\t\tglue->phy_mode = PHY_MODE_USB_OTG;\n\t\tnew_role = USB_ROLE_NONE;\n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\t\tif (glue->role != USB_ROLE_NONE)\n\t\t\tphy_power_off(glue->phy);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(glue->dev, \"Invalid State\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tglue->role = new_role;\n\tphy_set_mode(glue->phy, glue->phy_mode);\n\n\treturn 0;\n}\n\nstatic int musb_usb_role_sx_set(struct usb_role_switch *sw, enum usb_role role)\n{\n\treturn mtk_otg_switch_set(usb_role_switch_get_drvdata(sw), role);\n}\n\nstatic enum usb_role musb_usb_role_sx_get(struct usb_role_switch *sw)\n{\n\tstruct mtk_glue *glue = usb_role_switch_get_drvdata(sw);\n\n\treturn glue->role;\n}\n\nstatic int mtk_otg_switch_init(struct mtk_glue *glue)\n{\n\tstruct usb_role_switch_desc role_sx_desc = { 0 };\n\n\trole_sx_desc.set = musb_usb_role_sx_set;\n\trole_sx_desc.get = musb_usb_role_sx_get;\n\trole_sx_desc.allow_userspace_control = true;\n\trole_sx_desc.fwnode = dev_fwnode(glue->dev);\n\trole_sx_desc.driver_data = glue;\n\tglue->role_sw = usb_role_switch_register(glue->dev, &role_sx_desc);\n\n\treturn PTR_ERR_OR_ZERO(glue->role_sw);\n}\n\nstatic void mtk_otg_switch_exit(struct mtk_glue *glue)\n{\n\treturn usb_role_switch_unregister(glue->role_sw);\n}\n\nstatic irqreturn_t generic_interrupt(int irq, void *__hci)\n{\n\tunsigned long flags;\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct musb *musb = __hci;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb->int_usb = musb_clearb(musb->mregs, MUSB_INTRUSB);\n\tmusb->int_rx = musb_clearw(musb->mregs, MUSB_INTRRX);\n\tmusb->int_tx = musb_clearw(musb->mregs, MUSB_INTRTX);\n\n\tif ((musb->int_usb & MUSB_INTR_RESET) && !is_host_active(musb)) {\n\t\t \n\t\tmusb_ep_select(musb->mregs, 0);\n\t\tmusb_writeb(musb->mregs, MUSB_FADDR, 0);\n\t}\n\n\tif (musb->int_usb || musb->int_tx || musb->int_rx)\n\t\tretval = musb_interrupt(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn retval;\n}\n\nstatic irqreturn_t mtk_musb_interrupt(int irq, void *dev_id)\n{\n\tirqreturn_t retval = IRQ_NONE;\n\tstruct musb *musb = (struct musb *)dev_id;\n\tu32 l1_ints;\n\n\tl1_ints = musb_readl(musb->mregs, USB_L1INTS) &\n\t\t\tmusb_readl(musb->mregs, USB_L1INTM);\n\n\tif (l1_ints & (TX_INT_STATUS | RX_INT_STATUS | USBCOM_INT_STATUS))\n\t\tretval = generic_interrupt(irq, musb);\n\n#if defined(CONFIG_USB_INVENTRA_DMA)\n\tif (l1_ints & DMA_INT_STATUS)\n\t\tretval = dma_controller_irq(irq, musb->dma_controller);\n#endif\n\treturn retval;\n}\n\nstatic u32 mtk_musb_busctl_offset(u8 epnum, u16 offset)\n{\n\treturn MTK_MUSB_TXFUNCADDR + offset + 8 * epnum;\n}\n\nstatic u8 mtk_musb_clearb(void __iomem *addr, unsigned int offset)\n{\n\tu8 data;\n\n\t \n\tdata = musb_readb(addr, offset);\n\tmusb_writeb(addr, offset, data);\n\treturn data;\n}\n\nstatic u16 mtk_musb_clearw(void __iomem *addr, unsigned int offset)\n{\n\tu16 data;\n\n\t \n\tdata = musb_readw(addr, offset);\n\tmusb_writew(addr, offset, data);\n\treturn data;\n}\n\nstatic int mtk_musb_set_mode(struct musb *musb, u8 mode)\n{\n\tstruct device *dev = musb->controller;\n\tstruct mtk_glue *glue = dev_get_drvdata(dev->parent);\n\tenum phy_mode new_mode;\n\tenum usb_role new_role;\n\n\tswitch (mode) {\n\tcase MUSB_HOST:\n\t\tnew_mode = PHY_MODE_USB_HOST;\n\t\tnew_role = USB_ROLE_HOST;\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\n\t\tnew_mode = PHY_MODE_USB_DEVICE;\n\t\tnew_role = USB_ROLE_DEVICE;\n\t\tbreak;\n\tcase MUSB_OTG:\n\t\tnew_mode = PHY_MODE_USB_OTG;\n\t\tnew_role = USB_ROLE_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(glue->dev, \"Invalid mode request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (glue->phy_mode == new_mode)\n\t\treturn 0;\n\n\tif (musb->port_mode != MUSB_OTG) {\n\t\tdev_err(glue->dev, \"Does not support changing modes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmtk_otg_switch_set(glue, new_role);\n\treturn 0;\n}\n\nstatic int mtk_musb_init(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct mtk_glue *glue = dev_get_drvdata(dev->parent);\n\tint ret;\n\n\tglue->musb = musb;\n\tmusb->phy = glue->phy;\n\tmusb->xceiv = glue->xceiv;\n\tmusb->is_host = false;\n\tmusb->isr = mtk_musb_interrupt;\n\n\t \n\tmusb_writew(musb->mregs, MUSB_TXTOGEN, MTK_TOGGLE_EN);\n\tmusb_writew(musb->mregs, MUSB_RXTOGEN, MTK_TOGGLE_EN);\n\n\tif (musb->port_mode == MUSB_OTG) {\n\t\tret = mtk_otg_switch_init(glue);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = phy_init(glue->phy);\n\tif (ret)\n\t\tgoto err_phy_init;\n\n\tret = phy_power_on(glue->phy);\n\tif (ret)\n\t\tgoto err_phy_power_on;\n\n\tphy_set_mode(glue->phy, glue->phy_mode);\n\n#if defined(CONFIG_USB_INVENTRA_DMA)\n\tmusb_writel(musb->mregs, MUSB_HSDMA_INTR,\n\t\t    DMA_INTR_STATUS_MSK | DMA_INTR_UNMASK_SET_MSK);\n#endif\n\tmusb_writel(musb->mregs, USB_L1INTM, TX_INT_STATUS | RX_INT_STATUS |\n\t\t    USBCOM_INT_STATUS | DMA_INT_STATUS);\n\treturn 0;\n\nerr_phy_power_on:\n\tphy_exit(glue->phy);\nerr_phy_init:\n\tif (musb->port_mode == MUSB_OTG)\n\t\tmtk_otg_switch_exit(glue);\n\treturn ret;\n}\n\nstatic u16 mtk_musb_get_toggle(struct musb_qh *qh, int is_out)\n{\n\tstruct musb *musb = qh->hw_ep->musb;\n\tu8 epnum = qh->hw_ep->epnum;\n\tu16 toggle;\n\n\ttoggle = musb_readw(musb->mregs, is_out ? MUSB_TXTOG : MUSB_RXTOG);\n\treturn toggle & (1 << epnum);\n}\n\nstatic u16 mtk_musb_set_toggle(struct musb_qh *qh, int is_out, struct urb *urb)\n{\n\tstruct musb *musb = qh->hw_ep->musb;\n\tu8 epnum = qh->hw_ep->epnum;\n\tu16 value, toggle;\n\n\ttoggle = usb_gettoggle(urb->dev, qh->epnum, is_out);\n\n\tif (is_out) {\n\t\tvalue = musb_readw(musb->mregs, MUSB_TXTOG);\n\t\tvalue |= toggle << epnum;\n\t\tmusb_writew(musb->mregs, MUSB_TXTOG, value);\n\t} else {\n\t\tvalue = musb_readw(musb->mregs, MUSB_RXTOG);\n\t\tvalue |= toggle << epnum;\n\t\tmusb_writew(musb->mregs, MUSB_RXTOG, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_musb_exit(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct mtk_glue *glue = dev_get_drvdata(dev->parent);\n\n\tmtk_otg_switch_exit(glue);\n\tphy_power_off(glue->phy);\n\tphy_exit(glue->phy);\n\tclk_bulk_disable_unprepare(MTK_MUSB_CLKS_NUM, glue->clks);\n\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops mtk_musb_ops = {\n\t.quirks = MUSB_DMA_INVENTRA,\n\t.init = mtk_musb_init,\n\t.get_toggle = mtk_musb_get_toggle,\n\t.set_toggle = mtk_musb_set_toggle,\n\t.exit = mtk_musb_exit,\n#ifdef CONFIG_USB_INVENTRA_DMA\n\t.dma_init = musbhs_dma_controller_create_noirq,\n\t.dma_exit = musbhs_dma_controller_destroy,\n#endif\n\t.clearb = mtk_musb_clearb,\n\t.clearw = mtk_musb_clearw,\n\t.busctl_offset = mtk_musb_busctl_offset,\n\t.set_mode = mtk_musb_set_mode,\n};\n\n#define MTK_MUSB_MAX_EP_NUM\t8\n#define MTK_MUSB_RAM_BITS\t11\n\nstatic struct musb_fifo_cfg mtk_musb_mode_cfg[] = {\n\t{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 4, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 4, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 5, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 5, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 6, .style = FIFO_TX, .maxpacket = 1024, },\n\t{ .hw_ep_num = 6, .style = FIFO_RX, .maxpacket = 1024, },\n\t{ .hw_ep_num = 7, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 7, .style = FIFO_RX, .maxpacket = 64, },\n};\n\nstatic const struct musb_hdrc_config mtk_musb_hdrc_config = {\n\t.fifo_cfg = mtk_musb_mode_cfg,\n\t.fifo_cfg_size = ARRAY_SIZE(mtk_musb_mode_cfg),\n\t.multipoint = true,\n\t.dyn_fifo = true,\n\t.num_eps = MTK_MUSB_MAX_EP_NUM,\n\t.ram_bits = MTK_MUSB_RAM_BITS,\n};\n\nstatic const struct platform_device_info mtk_dev_info = {\n\t.name = \"musb-hdrc\",\n\t.id = PLATFORM_DEVID_AUTO,\n\t.dma_mask = DMA_BIT_MASK(32),\n};\n\nstatic int mtk_musb_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data *pdata;\n\tstruct mtk_glue *glue;\n\tstruct platform_device_info pinfo;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tglue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev = dev;\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tret = of_platform_populate(np, NULL, NULL, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create child devices at %p\\n\", np);\n\t\treturn ret;\n\t}\n\n\tret = mtk_musb_clks_get(glue);\n\tif (ret)\n\t\treturn ret;\n\n\tpdata->config = &mtk_musb_hdrc_config;\n\tpdata->platform_ops = &mtk_musb_ops;\n\tpdata->mode = usb_get_dr_mode(dev);\n\n\tif (IS_ENABLED(CONFIG_USB_MUSB_HOST))\n\t\tpdata->mode = USB_DR_MODE_HOST;\n\telse if (IS_ENABLED(CONFIG_USB_MUSB_GADGET))\n\t\tpdata->mode = USB_DR_MODE_PERIPHERAL;\n\n\tswitch (pdata->mode) {\n\tcase USB_DR_MODE_HOST:\n\t\tglue->phy_mode = PHY_MODE_USB_HOST;\n\t\tglue->role = USB_ROLE_HOST;\n\t\tbreak;\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tglue->phy_mode = PHY_MODE_USB_DEVICE;\n\t\tglue->role = USB_ROLE_DEVICE;\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tglue->phy_mode = PHY_MODE_USB_OTG;\n\t\tglue->role = USB_ROLE_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Error 'dr_mode' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tglue->phy = devm_of_phy_get_by_index(dev, np, 0);\n\tif (IS_ERR(glue->phy)) {\n\t\tdev_err(dev, \"fail to getting phy %ld\\n\",\n\t\t\tPTR_ERR(glue->phy));\n\t\treturn PTR_ERR(glue->phy);\n\t}\n\n\tglue->usb_phy = usb_phy_generic_register();\n\tif (IS_ERR(glue->usb_phy)) {\n\t\tdev_err(dev, \"fail to registering usb-phy %ld\\n\",\n\t\t\tPTR_ERR(glue->usb_phy));\n\t\treturn PTR_ERR(glue->usb_phy);\n\t}\n\n\tglue->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\n\tif (IS_ERR(glue->xceiv)) {\n\t\tret = PTR_ERR(glue->xceiv);\n\t\tdev_err(dev, \"fail to getting usb-phy %d\\n\", ret);\n\t\tgoto err_unregister_usb_phy;\n\t}\n\n\tplatform_set_drvdata(pdev, glue);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tret = clk_bulk_prepare_enable(MTK_MUSB_CLKS_NUM, glue->clks);\n\tif (ret)\n\t\tgoto err_enable_clk;\n\n\tpinfo = mtk_dev_info;\n\tpinfo.parent = dev;\n\tpinfo.res = pdev->resource;\n\tpinfo.num_res = pdev->num_resources;\n\tpinfo.data = pdata;\n\tpinfo.size_data = sizeof(*pdata);\n\tpinfo.fwnode = of_fwnode_handle(np);\n\tpinfo.of_node_reused = true;\n\n\tglue->musb_pdev = platform_device_register_full(&pinfo);\n\tif (IS_ERR(glue->musb_pdev)) {\n\t\tret = PTR_ERR(glue->musb_pdev);\n\t\tdev_err(dev, \"failed to register musb device: %d\\n\", ret);\n\t\tgoto err_device_register;\n\t}\n\n\treturn 0;\n\nerr_device_register:\n\tclk_bulk_disable_unprepare(MTK_MUSB_CLKS_NUM, glue->clks);\nerr_enable_clk:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\nerr_unregister_usb_phy:\n\tusb_phy_generic_unregister(glue->usb_phy);\n\treturn ret;\n}\n\nstatic void mtk_musb_remove(struct platform_device *pdev)\n{\n\tstruct mtk_glue *glue = platform_get_drvdata(pdev);\n\tstruct platform_device *usb_phy = glue->usb_phy;\n\n\tplatform_device_unregister(glue->musb_pdev);\n\tusb_phy_generic_unregister(usb_phy);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mtk_musb_match[] = {\n\t{.compatible = \"mediatek,mtk-musb\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_musb_match);\n#endif\n\nstatic struct platform_driver mtk_musb_driver = {\n\t.probe = mtk_musb_probe,\n\t.remove_new = mtk_musb_remove,\n\t.driver = {\n\t\t   .name = \"musb-mtk\",\n\t\t   .of_match_table = of_match_ptr(mtk_musb_match),\n\t},\n};\n\nmodule_platform_driver(mtk_musb_driver);\n\nMODULE_DESCRIPTION(\"MediaTek MUSB Glue Layer\");\nMODULE_AUTHOR(\"Min Guo <min.guo@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}