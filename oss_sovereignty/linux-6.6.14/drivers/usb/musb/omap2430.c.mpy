{
  "module_name": "omap2430.c",
  "hash_id": "e5996b8af9fb563600aa4f43f87588588bf62756febfe4b6d0174a8ec015e699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/omap2430.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/usb/musb.h>\n#include <linux/phy/omap_control_phy.h>\n#include <linux/of_platform.h>\n\n#include \"musb_core.h\"\n#include \"omap2430.h\"\n\nstruct omap2430_glue {\n\tstruct device\t\t*dev;\n\tstruct platform_device\t*musb;\n\tenum musb_vbus_id_status status;\n\tstruct work_struct\tomap_musb_mailbox_work;\n\tstruct device\t\t*control_otghs;\n\tunsigned int\t\tis_runtime_suspended:1;\n\tunsigned int\t\tneeds_resume:1;\n\tunsigned int\t\tphy_suspended:1;\n};\n#define glue_to_musb(g)\t\tplatform_get_drvdata(g->musb)\n\nstatic struct omap2430_glue\t*_glue;\n\nstatic inline void omap2430_low_level_exit(struct musb *musb)\n{\n\tu32 l;\n\n\t \n\tl = musb_readl(musb->mregs, OTG_FORCESTDBY);\n\tl |= ENABLEFORCE;\t \n\tmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\n}\n\nstatic inline void omap2430_low_level_init(struct musb *musb)\n{\n\tu32 l;\n\n\tl = musb_readl(musb->mregs, OTG_FORCESTDBY);\n\tl &= ~ENABLEFORCE;\t \n\tmusb_writel(musb->mregs, OTG_FORCESTDBY, l);\n}\n\nstatic int omap2430_musb_mailbox(enum musb_vbus_id_status status)\n{\n\tstruct omap2430_glue\t*glue = _glue;\n\n\tif (!glue) {\n\t\tpr_err(\"%s: musb core is not yet initialized\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\tglue->status = status;\n\n\tif (!glue_to_musb(glue)) {\n\t\tpr_err(\"%s: musb core is not yet ready\\n\", __func__);\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tschedule_work(&glue->omap_musb_mailbox_work);\n\n\treturn 0;\n}\n\n \nstatic void omap_musb_set_mailbox(struct omap2430_glue *glue)\n{\n\tstruct musb *musb = glue_to_musb(glue);\n\tint error;\n\n\tpm_runtime_get_sync(musb->controller);\n\n\tdev_dbg(musb->controller, \"VBUS %s, devctl %02x\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\tmusb_readb(musb->mregs, MUSB_DEVCTL));\n\n\tswitch (glue->status) {\n\tcase MUSB_ID_GROUND:\n\t\tdev_dbg(musb->controller, \"ID GND\\n\");\n\t\tswitch (musb->xceiv->otg->state) {\n\t\tcase OTG_STATE_A_IDLE:\n\t\t\terror = musb_set_host(musb);\n\t\t\tif (error)\n\t\t\t\tbreak;\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\t\tfallthrough;\n\t\tcase OTG_STATE_A_WAIT_VRISE:\n\t\tcase OTG_STATE_A_WAIT_BCON:\n\t\tcase OTG_STATE_A_HOST:\n\t\t\t \n\t\t\totg_set_vbus(musb->xceiv->otg, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\t\tmusb->xceiv->last_event = USB_EVENT_ID;\n\t\t\tif (musb->gadget_driver) {\n\t\t\t\tomap_control_usb_set_mode(glue->control_otghs,\n\t\t\t\t\t\t\t  USB_MODE_HOST);\n\t\t\t\totg_set_vbus(musb->xceiv->otg, 1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase MUSB_VBUS_VALID:\n\t\tdev_dbg(musb->controller, \"VBUS Connect\\n\");\n\n\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\tmusb->xceiv->last_event = USB_EVENT_VBUS;\n\t\tomap_control_usb_set_mode(glue->control_otghs, USB_MODE_DEVICE);\n\t\tbreak;\n\n\tcase MUSB_ID_FLOAT:\n\tcase MUSB_VBUS_OFF:\n\t\tdev_dbg(musb->controller, \"VBUS Disconnect\\n\");\n\n\t\tmusb->xceiv->last_event = USB_EVENT_NONE;\n\t\tmusb_set_peripheral(musb);\n\t\totg_set_vbus(musb->xceiv->otg, 0);\n\t\tomap_control_usb_set_mode(glue->control_otghs,\n\t\t\tUSB_MODE_DISCONNECT);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(musb->controller, \"ID float\\n\");\n\t}\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\tatomic_notifier_call_chain(&musb->xceiv->notifier,\n\t\t\tmusb->xceiv->last_event, NULL);\n}\n\n\nstatic void omap_musb_mailbox_work(struct work_struct *mailbox_work)\n{\n\tstruct omap2430_glue *glue = container_of(mailbox_work,\n\t\t\t\tstruct omap2430_glue, omap_musb_mailbox_work);\n\n\tomap_musb_set_mailbox(glue);\n}\n\nstatic irqreturn_t omap2430_musb_interrupt(int irq, void *__hci)\n{\n\tunsigned long   flags;\n\tirqreturn_t     retval = IRQ_NONE;\n\tstruct musb     *musb = __hci;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\n\tmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\n\tmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\n\n\tif (musb->int_usb || musb->int_tx || musb->int_rx)\n\t\tretval = musb_interrupt(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn retval;\n}\n\nstatic int omap2430_musb_init(struct musb *musb)\n{\n\tu32 l;\n\tint status = 0;\n\tstruct device *dev = musb->controller;\n\tstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\n\tstruct omap_musb_board_data *data = plat->board_data;\n\n\t \n\tmusb->phy = devm_phy_get(dev->parent, \"usb2-phy\");\n\n\t \n\tmusb->xceiv = devm_usb_get_phy_by_phandle(dev->parent, \"usb-phy\", 0);\n\n\tif (IS_ERR(musb->xceiv)) {\n\t\tstatus = PTR_ERR(musb->xceiv);\n\n\t\tif (status == -ENXIO)\n\t\t\treturn status;\n\n\t\tdev_dbg(dev, \"HS USB OTG: no transceiver configured\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\tif (IS_ERR(musb->phy)) {\n\t\tdev_err(dev, \"HS USB OTG: no PHY configured\\n\");\n\t\treturn PTR_ERR(musb->phy);\n\t}\n\tmusb->isr = omap2430_musb_interrupt;\n\tphy_init(musb->phy);\n\tphy_power_on(musb->phy);\n\n\tl = musb_readl(musb->mregs, OTG_INTERFSEL);\n\n\tif (data->interface_type == MUSB_INTERFACE_UTMI) {\n\t\t \n\t\tl &= ~ULPI_12PIN;        \n\t\tl |= UTMI_8BIT;          \n\t} else {\n\t\tl |= ULPI_12PIN;\n\t}\n\n\tmusb_writel(musb->mregs, OTG_INTERFSEL, l);\n\n\tdev_dbg(dev, \"HS USB OTG: revision 0x%x, sysconfig 0x%02x, \"\n\t\t\t\"sysstatus 0x%x, intrfsel 0x%x, simenable  0x%x\\n\",\n\t\t\tmusb_readl(musb->mregs, OTG_REVISION),\n\t\t\tmusb_readl(musb->mregs, OTG_SYSCONFIG),\n\t\t\tmusb_readl(musb->mregs, OTG_SYSSTATUS),\n\t\t\tmusb_readl(musb->mregs, OTG_INTERFSEL),\n\t\t\tmusb_readl(musb->mregs, OTG_SIMENABLE));\n\n\treturn 0;\n}\n\nstatic void omap2430_musb_enable(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\n\n\tif (glue->status == MUSB_UNKNOWN)\n\t\tglue->status = MUSB_VBUS_OFF;\n\tomap_musb_set_mailbox(glue);\n}\n\nstatic void omap2430_musb_disable(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\n\n\tif (glue->status != MUSB_UNKNOWN)\n\t\tomap_control_usb_set_mode(glue->control_otghs,\n\t\t\tUSB_MODE_DISCONNECT);\n}\n\nstatic int omap2430_musb_exit(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev->parent);\n\n\tomap2430_low_level_exit(musb);\n\tphy_power_off(musb->phy);\n\tphy_exit(musb->phy);\n\tmusb->phy = NULL;\n\tcancel_work_sync(&glue->omap_musb_mailbox_work);\n\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops omap2430_ops = {\n\t.quirks\t\t= MUSB_DMA_INVENTRA,\n#ifdef CONFIG_USB_INVENTRA_DMA\n\t.dma_init\t= musbhs_dma_controller_create,\n\t.dma_exit\t= musbhs_dma_controller_destroy,\n#endif\n\t.init\t\t= omap2430_musb_init,\n\t.exit\t\t= omap2430_musb_exit,\n\n\t.enable\t\t= omap2430_musb_enable,\n\t.disable\t= omap2430_musb_disable,\n\n\t.phy_callback\t= omap2430_musb_mailbox,\n};\n\nstatic u64 omap2430_dmamask = DMA_BIT_MASK(32);\n\nstatic int omap2430_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data\t*pdata = dev_get_platdata(&pdev->dev);\n\tstruct omap_musb_board_data\t*data;\n\tstruct platform_device\t\t*musb;\n\tstruct omap2430_glue\t\t*glue;\n\tstruct device_node\t\t*np = pdev->dev.of_node;\n\tstruct musb_hdrc_config\t\t*config;\n\tstruct device_node\t\t*control_node;\n\tstruct platform_device\t\t*control_pdev;\n\tint\t\t\t\tret = -ENOMEM, val;\n\tbool\t\t\t\tpopulate_irqs = false;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\tgoto err0;\n\n\tmusb = platform_device_alloc(\"musb-hdrc\", PLATFORM_DEVID_AUTO);\n\tif (!musb) {\n\t\tdev_err(&pdev->dev, \"failed to allocate musb device\\n\");\n\t\tgoto err0;\n\t}\n\n\tmusb->dev.parent\t\t= &pdev->dev;\n\tmusb->dev.dma_mask\t\t= &omap2430_dmamask;\n\tmusb->dev.coherent_dma_mask\t= omap2430_dmamask;\n\n\t \n\tif (of_property_present(np, \"ti,hwmods\")) {\n\t\tdev_warn(&pdev->dev, \"please update to probe with ti-sysc\\n\");\n\t\tpopulate_irqs = true;\n\t} else {\n\t\tdevice_set_of_node_from_dev(&musb->dev, &pdev->dev);\n\t}\n\tof_node_put(np);\n\n\tglue->dev\t\t\t= &pdev->dev;\n\tglue->musb\t\t\t= musb;\n\tglue->status\t\t\t= MUSB_UNKNOWN;\n\tglue->control_otghs = ERR_PTR(-ENODEV);\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\tgoto err2;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto err2;\n\n\tconfig = devm_kzalloc(&pdev->dev, sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\tgoto err2;\n\n\tof_property_read_u32(np, \"mode\", (u32 *)&pdata->mode);\n\tof_property_read_u32(np, \"interface-type\",\n\t\t\t(u32 *)&data->interface_type);\n\tof_property_read_u32(np, \"num-eps\", (u32 *)&config->num_eps);\n\tof_property_read_u32(np, \"ram-bits\", (u32 *)&config->ram_bits);\n\tof_property_read_u32(np, \"power\", (u32 *)&pdata->power);\n\n\tret = of_property_read_u32(np, \"multipoint\", &val);\n\tif (!ret && val)\n\t\tconfig->multipoint = true;\n\n\tpdata->board_data\t= data;\n\tpdata->config\t\t= config;\n\n\tcontrol_node = of_parse_phandle(np, \"ctrl-module\", 0);\n\tif (control_node) {\n\t\tcontrol_pdev = of_find_device_by_node(control_node);\n\t\tof_node_put(control_node);\n\t\tif (!control_pdev) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get control device\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err2;\n\t\t}\n\t\tglue->control_otghs = &control_pdev->dev;\n\t}\n\n\tpdata->platform_ops\t\t= &omap2430_ops;\n\n\tplatform_set_drvdata(pdev, glue);\n\n\t \n\t_glue\t= glue;\n\n\tINIT_WORK(&glue->omap_musb_mailbox_work, omap_musb_mailbox_work);\n\n\tret = platform_device_add_resources(musb, pdev->resource, pdev->num_resources);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add resources\\n\");\n\t\tgoto err2;\n\t}\n\n\tif (populate_irqs) {\n\t\tstruct resource musb_res[3];\n\t\tstruct resource *res;\n\t\tint i = 0;\n\n\t\tmemset(musb_res, 0, sizeof(*musb_res) * ARRAY_SIZE(musb_res));\n\n\t\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\t\tif (!res) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tmusb_res[i].start = res->start;\n\t\tmusb_res[i].end = res->end;\n\t\tmusb_res[i].flags = res->flags;\n\t\tmusb_res[i].name = res->name;\n\t\ti++;\n\n\t\tret = of_irq_get_byname(np, \"mc\");\n\t\tif (ret > 0) {\n\t\t\tmusb_res[i].start = ret;\n\t\t\tmusb_res[i].flags = IORESOURCE_IRQ;\n\t\t\tmusb_res[i].name = \"mc\";\n\t\t\ti++;\n\t\t}\n\n\t\tret = of_irq_get_byname(np, \"dma\");\n\t\tif (ret > 0) {\n\t\t\tmusb_res[i].start = ret;\n\t\t\tmusb_res[i].flags = IORESOURCE_IRQ;\n\t\t\tmusb_res[i].name = \"dma\";\n\t\t\ti++;\n\t\t}\n\n\t\tret = platform_device_add_resources(musb, musb_res, i);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"failed to add IRQ resources\\n\");\n\t\t\tgoto err2;\n\t\t}\n\t}\n\n\tret = platform_device_add_data(musb, pdata, sizeof(*pdata));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to add platform_data\\n\");\n\t\tgoto err2;\n\t}\n\n\tpm_runtime_enable(glue->dev);\n\n\tret = platform_device_add(musb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register musb device\\n\");\n\t\tgoto err3;\n\t}\n\n\treturn 0;\n\nerr3:\n\tpm_runtime_disable(glue->dev);\n\nerr2:\n\tplatform_device_put(musb);\n\nerr0:\n\treturn ret;\n}\n\nstatic void omap2430_remove(struct platform_device *pdev)\n{\n\tstruct omap2430_glue *glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->musb);\n\tpm_runtime_disable(glue->dev);\n}\n\n#ifdef CONFIG_PM\n\nstatic int omap2430_runtime_suspend(struct device *dev)\n{\n\tstruct omap2430_glue\t\t*glue = dev_get_drvdata(dev);\n\tstruct musb\t\t\t*musb = glue_to_musb(glue);\n\n\tif (!musb)\n\t\treturn 0;\n\n\tmusb->context.otg_interfsel = musb_readl(musb->mregs,\n\t\t\t\t\t\t OTG_INTERFSEL);\n\n\tomap2430_low_level_exit(musb);\n\n\tif (!glue->phy_suspended) {\n\t\tphy_power_off(musb->phy);\n\t\tphy_exit(musb->phy);\n\t}\n\n\tglue->is_runtime_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int omap2430_runtime_resume(struct device *dev)\n{\n\tstruct omap2430_glue\t\t*glue = dev_get_drvdata(dev);\n\tstruct musb\t\t\t*musb = glue_to_musb(glue);\n\n\tif (!musb)\n\t\treturn 0;\n\n\tif (!glue->phy_suspended) {\n\t\tphy_init(musb->phy);\n\t\tphy_power_on(musb->phy);\n\t}\n\n\tomap2430_low_level_init(musb);\n\tmusb_writel(musb->mregs, OTG_INTERFSEL,\n\t\t    musb->context.otg_interfsel);\n\n\t \n\tusleep_range(200000, 250000);\n\n\tglue->is_runtime_suspended = 0;\n\n\treturn 0;\n}\n\n \nstatic int omap2430_suspend(struct device *dev)\n{\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev);\n\tstruct musb *musb = glue_to_musb(glue);\n\n\tphy_power_off(musb->phy);\n\tphy_exit(musb->phy);\n\tglue->phy_suspended = 1;\n\n\treturn 0;\n}\n\n \nstatic int omap2430_suspend_late(struct device *dev)\n{\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev);\n\n\tif (glue->is_runtime_suspended)\n\t\treturn 0;\n\n\tglue->needs_resume = 1;\n\n\treturn omap2430_runtime_suspend(dev);\n}\n\nstatic int omap2430_resume_early(struct device *dev)\n{\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev);\n\n\tif (!glue->needs_resume)\n\t\treturn 0;\n\n\tglue->needs_resume = 0;\n\n\treturn omap2430_runtime_resume(dev);\n}\n\nstatic int omap2430_resume(struct device *dev)\n{\n\tstruct omap2430_glue *glue = dev_get_drvdata(dev);\n\tstruct musb *musb = glue_to_musb(glue);\n\n\tphy_init(musb->phy);\n\tphy_power_on(musb->phy);\n\tglue->phy_suspended = 0;\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops omap2430_pm_ops = {\n\t.runtime_suspend = omap2430_runtime_suspend,\n\t.runtime_resume = omap2430_runtime_resume,\n\t.suspend = omap2430_suspend,\n\t.suspend_late = omap2430_suspend_late,\n\t.resume_early = omap2430_resume_early,\n\t.resume = omap2430_resume,\n};\n\n#define DEV_PM_OPS\t(&omap2430_pm_ops)\n#else\n#define DEV_PM_OPS\tNULL\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id omap2430_id_table[] = {\n\t{\n\t\t.compatible = \"ti,omap4-musb\"\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-musb\"\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap2430_id_table);\n#endif\n\nstatic struct platform_driver omap2430_driver = {\n\t.probe\t\t= omap2430_probe,\n\t.remove_new\t= omap2430_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"musb-omap2430\",\n\t\t.pm\t= DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(omap2430_id_table),\n\t},\n};\n\nmodule_platform_driver(omap2430_driver);\n\nMODULE_DESCRIPTION(\"OMAP2PLUS MUSB Glue Layer\");\nMODULE_AUTHOR(\"Felipe Balbi <balbi@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}