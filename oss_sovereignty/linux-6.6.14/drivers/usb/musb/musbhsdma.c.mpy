{
  "module_name": "musbhsdma.c",
  "hash_id": "2580eb3451fb663826a05b107aab60e18cb38fd30781f11967db22ce5d16a6ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musbhsdma.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include \"musb_core.h\"\n#include \"musb_dma.h\"\n\n#define MUSB_HSDMA_CHANNEL_OFFSET(_bchannel, _offset)\t\t\\\n\t\t(MUSB_HSDMA_BASE + (_bchannel << 4) + _offset)\n\n#define musb_read_hsdma_addr(mbase, bchannel)\t\\\n\tmusb_readl(mbase,\t\\\n\t\t   MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS))\n\n#define musb_write_hsdma_addr(mbase, bchannel, addr) \\\n\tmusb_writel(mbase, \\\n\t\t    MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_ADDRESS), \\\n\t\t    addr)\n\n#define musb_read_hsdma_count(mbase, bchannel)\t\\\n\tmusb_readl(mbase,\t\\\n\t\t   MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT))\n\n#define musb_write_hsdma_count(mbase, bchannel, len) \\\n\tmusb_writel(mbase, \\\n\t\t    MUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_COUNT), \\\n\t\t    len)\n \n#define MUSB_HSDMA_ENABLE_SHIFT\t\t0\n#define MUSB_HSDMA_TRANSMIT_SHIFT\t1\n#define MUSB_HSDMA_MODE1_SHIFT\t\t2\n#define MUSB_HSDMA_IRQENABLE_SHIFT\t3\n#define MUSB_HSDMA_ENDPOINT_SHIFT\t4\n#define MUSB_HSDMA_BUSERROR_SHIFT\t8\n#define MUSB_HSDMA_BURSTMODE_SHIFT\t9\n#define MUSB_HSDMA_BURSTMODE\t\t(3 << MUSB_HSDMA_BURSTMODE_SHIFT)\n#define MUSB_HSDMA_BURSTMODE_UNSPEC\t0\n#define MUSB_HSDMA_BURSTMODE_INCR4\t1\n#define MUSB_HSDMA_BURSTMODE_INCR8\t2\n#define MUSB_HSDMA_BURSTMODE_INCR16\t3\n\n#define MUSB_HSDMA_CHANNELS\t\t8\n\nstruct musb_dma_controller;\n\nstruct musb_dma_channel {\n\tstruct dma_channel\t\tchannel;\n\tstruct musb_dma_controller\t*controller;\n\tu32\t\t\t\tstart_addr;\n\tu32\t\t\t\tlen;\n\tu16\t\t\t\tmax_packet_sz;\n\tu8\t\t\t\tidx;\n\tu8\t\t\t\tepnum;\n\tu8\t\t\t\ttransmit;\n};\n\nstruct musb_dma_controller {\n\tstruct dma_controller\t\tcontroller;\n\tstruct musb_dma_channel\t\tchannel[MUSB_HSDMA_CHANNELS];\n\tvoid\t\t\t\t*private_data;\n\tvoid __iomem\t\t\t*base;\n\tu8\t\t\t\tchannel_count;\n\tu8\t\t\t\tused_channels;\n\tint\t\t\t\tirq;\n};\n\nstatic void dma_channel_release(struct dma_channel *channel);\n\nstatic void dma_controller_stop(struct musb_dma_controller *controller)\n{\n\tstruct musb *musb = controller->private_data;\n\tstruct dma_channel *channel;\n\tu8 bit;\n\n\tif (controller->used_channels != 0) {\n\t\tdev_err(musb->controller,\n\t\t\t\"Stopping DMA controller while channel active\\n\");\n\n\t\tfor (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {\n\t\t\tif (controller->used_channels & (1 << bit)) {\n\t\t\t\tchannel = &controller->channel[bit].channel;\n\t\t\t\tdma_channel_release(channel);\n\n\t\t\t\tif (!controller->used_channels)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic struct dma_channel *dma_channel_allocate(struct dma_controller *c,\n\t\t\t\tstruct musb_hw_ep *hw_ep, u8 transmit)\n{\n\tstruct musb_dma_controller *controller = container_of(c,\n\t\t\tstruct musb_dma_controller, controller);\n\tstruct musb_dma_channel *musb_channel = NULL;\n\tstruct dma_channel *channel = NULL;\n\tu8 bit;\n\n\tfor (bit = 0; bit < MUSB_HSDMA_CHANNELS; bit++) {\n\t\tif (!(controller->used_channels & (1 << bit))) {\n\t\t\tcontroller->used_channels |= (1 << bit);\n\t\t\tmusb_channel = &(controller->channel[bit]);\n\t\t\tmusb_channel->controller = controller;\n\t\t\tmusb_channel->idx = bit;\n\t\t\tmusb_channel->epnum = hw_ep->epnum;\n\t\t\tmusb_channel->transmit = transmit;\n\t\t\tchannel = &(musb_channel->channel);\n\t\t\tchannel->private_data = musb_channel;\n\t\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\t\t\tchannel->max_len = 0x100000;\n\t\t\t \n\t\t\tchannel->desired_mode = transmit;\n\t\t\tchannel->actual_len = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn channel;\n}\n\nstatic void dma_channel_release(struct dma_channel *channel)\n{\n\tstruct musb_dma_channel *musb_channel = channel->private_data;\n\n\tchannel->actual_len = 0;\n\tmusb_channel->start_addr = 0;\n\tmusb_channel->len = 0;\n\n\tmusb_channel->controller->used_channels &=\n\t\t~(1 << musb_channel->idx);\n\n\tchannel->status = MUSB_DMA_STATUS_UNKNOWN;\n}\n\nstatic void configure_channel(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tstruct musb_dma_channel *musb_channel = channel->private_data;\n\tstruct musb_dma_controller *controller = musb_channel->controller;\n\tstruct musb *musb = controller->private_data;\n\tvoid __iomem *mbase = controller->base;\n\tu8 bchannel = musb_channel->idx;\n\tu16 csr = 0;\n\n\tmusb_dbg(musb, \"%p, pkt_sz %d, addr %pad, len %d, mode %d\",\n\t\t\tchannel, packet_sz, &dma_addr, len, mode);\n\n\tif (mode) {\n\t\tcsr |= 1 << MUSB_HSDMA_MODE1_SHIFT;\n\t\tBUG_ON(len < packet_sz);\n\t}\n\tcsr |= MUSB_HSDMA_BURSTMODE_INCR16\n\t\t\t\t<< MUSB_HSDMA_BURSTMODE_SHIFT;\n\n\tcsr |= (musb_channel->epnum << MUSB_HSDMA_ENDPOINT_SHIFT)\n\t\t| (1 << MUSB_HSDMA_ENABLE_SHIFT)\n\t\t| (1 << MUSB_HSDMA_IRQENABLE_SHIFT)\n\t\t| (musb_channel->transmit\n\t\t\t\t? (1 << MUSB_HSDMA_TRANSMIT_SHIFT)\n\t\t\t\t: 0);\n\n\t \n\tmusb_write_hsdma_addr(mbase, bchannel, dma_addr);\n\tmusb_write_hsdma_count(mbase, bchannel, len);\n\n\t \n\tmusb_writew(mbase,\n\t\tMUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),\n\t\tcsr);\n}\n\nstatic int dma_channel_program(struct dma_channel *channel,\n\t\t\t\tu16 packet_sz, u8 mode,\n\t\t\t\tdma_addr_t dma_addr, u32 len)\n{\n\tstruct musb_dma_channel *musb_channel = channel->private_data;\n\tstruct musb_dma_controller *controller = musb_channel->controller;\n\tstruct musb *musb = controller->private_data;\n\n\tmusb_dbg(musb, \"ep%d-%s pkt_sz %d, dma_addr %pad length %d, mode %d\",\n\t\tmusb_channel->epnum,\n\t\tmusb_channel->transmit ? \"Tx\" : \"Rx\",\n\t\tpacket_sz, &dma_addr, len, mode);\n\n\tBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\n\t\tchannel->status == MUSB_DMA_STATUS_BUSY);\n\n\t \n\tif ((musb->hwvers >= MUSB_HWVERS_1800) && (dma_addr % 4))\n\t\treturn false;\n\n\tchannel->actual_len = 0;\n\tmusb_channel->start_addr = dma_addr;\n\tmusb_channel->len = len;\n\tmusb_channel->max_packet_sz = packet_sz;\n\tchannel->status = MUSB_DMA_STATUS_BUSY;\n\n\tconfigure_channel(channel, packet_sz, mode, dma_addr, len);\n\n\treturn true;\n}\n\nstatic int dma_channel_abort(struct dma_channel *channel)\n{\n\tstruct musb_dma_channel *musb_channel = channel->private_data;\n\tvoid __iomem *mbase = musb_channel->controller->base;\n\tstruct musb *musb = musb_channel->controller->private_data;\n\n\tu8 bchannel = musb_channel->idx;\n\tint offset;\n\tu16 csr;\n\n\tif (channel->status == MUSB_DMA_STATUS_BUSY) {\n\t\tif (musb_channel->transmit) {\n\t\t\toffset = musb->io.ep_offset(musb_channel->epnum,\n\t\t\t\t\t\tMUSB_TXCSR);\n\n\t\t\t \n\t\t\tcsr = musb_readw(mbase, offset);\n\t\t\tcsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);\n\t\t\tmusb_writew(mbase, offset, csr);\n\t\t\tcsr &= ~MUSB_TXCSR_DMAMODE;\n\t\t\tmusb_writew(mbase, offset, csr);\n\t\t} else {\n\t\t\toffset = musb->io.ep_offset(musb_channel->epnum,\n\t\t\t\t\t\tMUSB_RXCSR);\n\n\t\t\tcsr = musb_readw(mbase, offset);\n\t\t\tcsr &= ~(MUSB_RXCSR_AUTOCLEAR |\n\t\t\t\t MUSB_RXCSR_DMAENAB |\n\t\t\t\t MUSB_RXCSR_DMAMODE);\n\t\t\tmusb_writew(mbase, offset, csr);\n\t\t}\n\n\t\tmusb_writew(mbase,\n\t\t\tMUSB_HSDMA_CHANNEL_OFFSET(bchannel, MUSB_HSDMA_CONTROL),\n\t\t\t0);\n\t\tmusb_write_hsdma_addr(mbase, bchannel, 0);\n\t\tmusb_write_hsdma_count(mbase, bchannel, 0);\n\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\t}\n\n\treturn 0;\n}\n\nirqreturn_t dma_controller_irq(int irq, void *private_data)\n{\n\tstruct musb_dma_controller *controller = private_data;\n\tstruct musb *musb = controller->private_data;\n\tstruct musb_dma_channel *musb_channel;\n\tstruct dma_channel *channel;\n\n\tvoid __iomem *mbase = controller->base;\n\n\tirqreturn_t retval = IRQ_NONE;\n\n\tunsigned long flags;\n\n\tu8 bchannel;\n\tu8 int_hsdma;\n\n\tu32 addr, count;\n\tu16 csr;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tint_hsdma = musb_clearb(mbase, MUSB_HSDMA_INTR);\n\n\tif (!int_hsdma) {\n\t\tmusb_dbg(musb, \"spurious DMA irq\");\n\n\t\tfor (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {\n\t\t\tmusb_channel = (struct musb_dma_channel *)\n\t\t\t\t\t&(controller->channel[bchannel]);\n\t\t\tchannel = &musb_channel->channel;\n\t\t\tif (channel->status == MUSB_DMA_STATUS_BUSY) {\n\t\t\t\tcount = musb_read_hsdma_count(mbase, bchannel);\n\n\t\t\t\tif (count == 0)\n\t\t\t\t\tint_hsdma |= (1 << bchannel);\n\t\t\t}\n\t\t}\n\n\t\tmusb_dbg(musb, \"int_hsdma = 0x%x\", int_hsdma);\n\n\t\tif (!int_hsdma)\n\t\t\tgoto done;\n\t}\n\n\tfor (bchannel = 0; bchannel < MUSB_HSDMA_CHANNELS; bchannel++) {\n\t\tif (int_hsdma & (1 << bchannel)) {\n\t\t\tmusb_channel = (struct musb_dma_channel *)\n\t\t\t\t\t&(controller->channel[bchannel]);\n\t\t\tchannel = &musb_channel->channel;\n\n\t\t\tcsr = musb_readw(mbase,\n\t\t\t\t\tMUSB_HSDMA_CHANNEL_OFFSET(bchannel,\n\t\t\t\t\t\t\tMUSB_HSDMA_CONTROL));\n\n\t\t\tif (csr & (1 << MUSB_HSDMA_BUSERROR_SHIFT)) {\n\t\t\t\tmusb_channel->channel.status =\n\t\t\t\t\tMUSB_DMA_STATUS_BUS_ABORT;\n\t\t\t} else {\n\t\t\t\taddr = musb_read_hsdma_addr(mbase,\n\t\t\t\t\t\tbchannel);\n\t\t\t\tchannel->actual_len = addr\n\t\t\t\t\t- musb_channel->start_addr;\n\n\t\t\t\tmusb_dbg(musb, \"ch %p, 0x%x -> 0x%x (%zu / %d) %s\",\n\t\t\t\t\tchannel, musb_channel->start_addr,\n\t\t\t\t\taddr, channel->actual_len,\n\t\t\t\t\tmusb_channel->len,\n\t\t\t\t\t(channel->actual_len\n\t\t\t\t\t\t< musb_channel->len) ?\n\t\t\t\t\t\"=> reconfig 0\" : \"=> complete\");\n\n\t\t\t\tchannel->status = MUSB_DMA_STATUS_FREE;\n\n\t\t\t\t \n\t\t\t\tif (musb_channel->transmit &&\n\t\t\t\t\t(!channel->desired_mode ||\n\t\t\t\t\t(channel->actual_len %\n\t\t\t\t\t    musb_channel->max_packet_sz))) {\n\t\t\t\t\tu8  epnum  = musb_channel->epnum;\n\t\t\t\t\tint offset = musb->io.ep_offset(epnum,\n\t\t\t\t\t\t\t\t    MUSB_TXCSR);\n\t\t\t\t\tu16 txcsr;\n\n\t\t\t\t\t \n\t\t\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\t\t\ttxcsr = musb_readw(mbase, offset);\n\t\t\t\t\tif (channel->desired_mode == 1) {\n\t\t\t\t\t\ttxcsr &= ~(MUSB_TXCSR_DMAENAB\n\t\t\t\t\t\t\t| MUSB_TXCSR_AUTOSET);\n\t\t\t\t\t\tmusb_writew(mbase, offset, txcsr);\n\t\t\t\t\t\t \n\t\t\t\t\t\ttxcsr &= ~MUSB_TXCSR_DMAMODE;\n\t\t\t\t\t\ttxcsr |= MUSB_TXCSR_DMAENAB;\n\t\t\t\t\t}\n\t\t\t\t\ttxcsr |=  MUSB_TXCSR_TXPKTRDY;\n\t\t\t\t\tmusb_writew(mbase, offset, txcsr);\n\t\t\t\t}\n\t\t\t\tmusb_dma_completion(musb, musb_channel->epnum,\n\t\t\t\t\t\t    musb_channel->transmit);\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = IRQ_HANDLED;\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(dma_controller_irq);\n\nvoid musbhs_dma_controller_destroy(struct dma_controller *c)\n{\n\tstruct musb_dma_controller *controller = container_of(c,\n\t\t\tstruct musb_dma_controller, controller);\n\n\tdma_controller_stop(controller);\n\n\tif (controller->irq)\n\t\tfree_irq(controller->irq, c);\n\n\tkfree(controller);\n}\nEXPORT_SYMBOL_GPL(musbhs_dma_controller_destroy);\n\nstatic struct musb_dma_controller *\ndma_controller_alloc(struct musb *musb, void __iomem *base)\n{\n\tstruct musb_dma_controller *controller;\n\n\tcontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\n\tif (!controller)\n\t\treturn NULL;\n\n\tcontroller->channel_count = MUSB_HSDMA_CHANNELS;\n\tcontroller->private_data = musb;\n\tcontroller->base = base;\n\n\tcontroller->controller.channel_alloc = dma_channel_allocate;\n\tcontroller->controller.channel_release = dma_channel_release;\n\tcontroller->controller.channel_program = dma_channel_program;\n\tcontroller->controller.channel_abort = dma_channel_abort;\n\treturn controller;\n}\n\nstruct dma_controller *\nmusbhs_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tstruct musb_dma_controller *controller;\n\tstruct device *dev = musb->controller;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint irq = platform_get_irq_byname(pdev, \"dma\");\n\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"No DMA interrupt line!\\n\");\n\t\treturn NULL;\n\t}\n\n\tcontroller = dma_controller_alloc(musb, base);\n\tif (!controller)\n\t\treturn NULL;\n\n\tif (request_irq(irq, dma_controller_irq, 0,\n\t\t\tdev_name(musb->controller), controller)) {\n\t\tdev_err(dev, \"request_irq %d failed!\\n\", irq);\n\t\tmusb_dma_controller_destroy(&controller->controller);\n\n\t\treturn NULL;\n\t}\n\n\tcontroller->irq = irq;\n\n\treturn &controller->controller;\n}\nEXPORT_SYMBOL_GPL(musbhs_dma_controller_create);\n\nstruct dma_controller *\nmusbhs_dma_controller_create_noirq(struct musb *musb, void __iomem *base)\n{\n\tstruct musb_dma_controller *controller;\n\n\tcontroller = dma_controller_alloc(musb, base);\n\tif (!controller)\n\t\treturn NULL;\n\n\treturn &controller->controller;\n}\nEXPORT_SYMBOL_GPL(musbhs_dma_controller_create_noirq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}