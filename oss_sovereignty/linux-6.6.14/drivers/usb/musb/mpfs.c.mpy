{
  "module_name": "mpfs.c",
  "hash_id": "f66581abf8ee2e31919b8c244805f8f9456da9129a7f76156a3e205b4e2e3c07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/mpfs.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/usb/usb_phy_generic.h>\n#include \"musb_core.h\"\n#include \"musb_dma.h\"\n\n#define MPFS_MUSB_MAX_EP_NUM\t8\n#define MPFS_MUSB_RAM_BITS\t12\n\nstruct mpfs_glue {\n\tstruct device *dev;\n\tstruct platform_device *musb;\n\tstruct platform_device *phy;\n\tstruct clk *clk;\n};\n\nstatic struct musb_fifo_cfg mpfs_musb_mode_cfg[] = {\n\t{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 4, .style = FIFO_TX, .maxpacket = 1024, },\n\t{ .hw_ep_num = 4, .style = FIFO_RX, .maxpacket = 4096, },\n};\n\nstatic const struct musb_hdrc_config mpfs_musb_hdrc_config = {\n\t.fifo_cfg = mpfs_musb_mode_cfg,\n\t.fifo_cfg_size = ARRAY_SIZE(mpfs_musb_mode_cfg),\n\t.multipoint = true,\n\t.dyn_fifo = true,\n\t.num_eps = MPFS_MUSB_MAX_EP_NUM,\n\t.ram_bits = MPFS_MUSB_RAM_BITS,\n};\n\nstatic irqreturn_t mpfs_musb_interrupt(int irq, void *__hci)\n{\n\tunsigned long flags;\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct musb *musb = __hci;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\n\tmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\n\tmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\n\n\tif (musb->int_usb || musb->int_tx || musb->int_rx) {\n\t\tmusb_writeb(musb->mregs, MUSB_INTRUSB, musb->int_usb);\n\t\tmusb_writew(musb->mregs, MUSB_INTRTX, musb->int_tx);\n\t\tmusb_writew(musb->mregs, MUSB_INTRRX, musb->int_rx);\n\t\tret = musb_interrupt(musb);\n\t}\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn ret;\n}\n\nstatic void mpfs_musb_set_vbus(struct musb *musb, int is_on)\n{\n\tu8 devctl;\n\n\t \n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\n\tif (is_on) {\n\t\tmusb->is_active = 1;\n\t\tmusb->xceiv->otg->default_a = 1;\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\tMUSB_HST_MODE(musb);\n\t} else {\n\t\tmusb->is_active = 0;\n\n\t\t \n\t\tmusb->xceiv->otg->default_a = 0;\n\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\n\t\tMUSB_DEV_MODE(musb);\n\t}\n\n\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\tdev_dbg(musb->controller, \"VBUS %s, devctl %02x\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\tmusb_readb(musb->mregs, MUSB_DEVCTL));\n}\n\nstatic int mpfs_musb_init(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\n\tmusb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\n\tif (IS_ERR(musb->xceiv)) {\n\t\tdev_err(dev, \"HS UDC: no transceiver configured\\n\");\n\t\treturn PTR_ERR(musb->xceiv);\n\t}\n\n\tmusb->dyn_fifo = true;\n\tmusb->isr = mpfs_musb_interrupt;\n\n\tmusb_platform_set_vbus(musb, 1);\n\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops mpfs_ops = {\n\t.quirks\t\t= MUSB_DMA_INVENTRA,\n\t.init\t\t= mpfs_musb_init,\n\t.fifo_mode\t= 2,\n#ifdef CONFIG_USB_INVENTRA_DMA\n\t.dma_init\t= musbhs_dma_controller_create,\n\t.dma_exit\t= musbhs_dma_controller_destroy,\n#endif\n\t.set_vbus\t= mpfs_musb_set_vbus\n};\n\nstatic int mpfs_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct mpfs_glue *glue;\n\tstruct platform_device *musb_pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk;\n\tint ret;\n\n\tglue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tmusb_pdev = platform_device_alloc(\"musb-hdrc\", PLATFORM_DEVID_AUTO);\n\tif (!musb_pdev) {\n\t\tdev_err(dev, \"failed to allocate musb device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_phy_release;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to enable clock\\n\");\n\t\tgoto err_phy_release;\n\t}\n\n\tmusb_pdev->dev.parent = dev;\n\tmusb_pdev->dev.coherent_dma_mask = DMA_BIT_MASK(39);\n\tmusb_pdev->dev.dma_mask = &musb_pdev->dev.coherent_dma_mask;\n\tdevice_set_of_node_from_dev(&musb_pdev->dev, dev);\n\n\tglue->dev = dev;\n\tglue->musb = musb_pdev;\n\tglue->clk = clk;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto err_clk_disable;\n\t}\n\n\tpdata->config = &mpfs_musb_hdrc_config;\n\tpdata->platform_ops = &mpfs_ops;\n\n\tpdata->mode = usb_get_dr_mode(dev);\n\tif (pdata->mode == USB_DR_MODE_UNKNOWN) {\n\t\tdev_info(dev, \"No dr_mode property found, defaulting to otg\\n\");\n\t\tpdata->mode = USB_DR_MODE_OTG;\n\t}\n\n\tglue->phy = usb_phy_generic_register();\n\tif (IS_ERR(glue->phy)) {\n\t\tdev_err(dev, \"failed to register usb-phy %ld\\n\",\n\t\t\tPTR_ERR(glue->phy));\n\t\tret = PTR_ERR(glue->phy);\n\t\tgoto err_clk_disable;\n\t}\n\n\tplatform_set_drvdata(pdev, glue);\n\n\tret = platform_device_add_resources(musb_pdev, pdev->resource, pdev->num_resources);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add resources\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = platform_device_add_data(musb_pdev, pdata, sizeof(*pdata));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add platform_data\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = platform_device_add(musb_pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register musb device\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tdev_info(&pdev->dev, \"Registered MPFS MUSB driver\\n\");\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(clk);\n\nerr_phy_release:\n\tusb_phy_generic_unregister(glue->phy);\n\tplatform_device_put(musb_pdev);\n\treturn ret;\n}\n\nstatic void mpfs_remove(struct platform_device *pdev)\n{\n\tstruct mpfs_glue *glue = platform_get_drvdata(pdev);\n\n\tclk_disable_unprepare(glue->clk);\n\tplatform_device_unregister(glue->musb);\n\tusb_phy_generic_unregister(pdev);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mpfs_id_table[] = {\n\t{ .compatible = \"microchip,mpfs-musb\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mpfs_id_table);\n#endif\n\nstatic struct platform_driver mpfs_musb_driver = {\n\t.probe = mpfs_probe,\n\t.remove_new = mpfs_remove,\n\t.driver = {\n\t\t.name = \"mpfs-musb\",\n\t\t.of_match_table = of_match_ptr(mpfs_id_table)\n\t},\n};\n\nmodule_platform_driver(mpfs_musb_driver);\n\nMODULE_DESCRIPTION(\"PolarFire SoC MUSB Glue Layer\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}