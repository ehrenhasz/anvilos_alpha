{
  "module_name": "da8xx.c",
  "hash_id": "3b29e49f8649e10ae9cfc94eee279d1ff8f721abeec7d3a5c490e3bdf6775bf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/da8xx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb/usb_phy_generic.h>\n\n#include \"musb_core.h\"\n\n \n\n \n#define DA8XX_USB_REVISION_REG\t0x00\n#define DA8XX_USB_CTRL_REG\t0x04\n#define DA8XX_USB_STAT_REG\t0x08\n#define DA8XX_USB_EMULATION_REG 0x0c\n#define DA8XX_USB_SRP_FIX_TIME_REG 0x18\n#define DA8XX_USB_INTR_SRC_REG\t0x20\n#define DA8XX_USB_INTR_SRC_SET_REG 0x24\n#define DA8XX_USB_INTR_SRC_CLEAR_REG 0x28\n#define DA8XX_USB_INTR_MASK_REG 0x2c\n#define DA8XX_USB_INTR_MASK_SET_REG 0x30\n#define DA8XX_USB_INTR_MASK_CLEAR_REG 0x34\n#define DA8XX_USB_INTR_SRC_MASKED_REG 0x38\n#define DA8XX_USB_END_OF_INTR_REG 0x3c\n#define DA8XX_USB_GENERIC_RNDIS_EP_SIZE_REG(n) (0x50 + (((n) - 1) << 2))\n\n \n#define DA8XX_SOFT_RESET_MASK\t1\n\n#define DA8XX_USB_TX_EP_MASK\t0x1f\t\t \n#define DA8XX_USB_RX_EP_MASK\t0x1e\t\t \n\n \n#define DA8XX_INTR_USB_SHIFT\t16\n#define DA8XX_INTR_USB_MASK\t(0x1ff << DA8XX_INTR_USB_SHIFT)  \n\t\t\t\t\t \n#define DA8XX_INTR_DRVVBUS\t0x100\n#define DA8XX_INTR_RX_SHIFT\t8\n#define DA8XX_INTR_RX_MASK\t(DA8XX_USB_RX_EP_MASK << DA8XX_INTR_RX_SHIFT)\n#define DA8XX_INTR_TX_SHIFT\t0\n#define DA8XX_INTR_TX_MASK\t(DA8XX_USB_TX_EP_MASK << DA8XX_INTR_TX_SHIFT)\n\n#define DA8XX_MENTOR_CORE_OFFSET 0x400\n\nstruct da8xx_glue {\n\tstruct device\t\t*dev;\n\tstruct platform_device\t*musb;\n\tstruct platform_device\t*usb_phy;\n\tstruct clk\t\t*clk;\n\tstruct phy\t\t*phy;\n};\n\n \n\n \nstatic void da8xx_musb_enable(struct musb *musb)\n{\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\tu32 mask;\n\n\t \n\tmask = ((musb->epmask & DA8XX_USB_TX_EP_MASK) << DA8XX_INTR_TX_SHIFT) |\n\t       ((musb->epmask & DA8XX_USB_RX_EP_MASK) << DA8XX_INTR_RX_SHIFT) |\n\t       DA8XX_INTR_USB_MASK;\n\tmusb_writel(reg_base, DA8XX_USB_INTR_MASK_SET_REG, mask);\n\n\t \n\tmusb_writel(reg_base, DA8XX_USB_INTR_SRC_SET_REG,\n\t\t\tDA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT);\n}\n\n \nstatic void da8xx_musb_disable(struct musb *musb)\n{\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\n\tmusb_writel(reg_base, DA8XX_USB_INTR_MASK_CLEAR_REG,\n\t\t    DA8XX_INTR_USB_MASK |\n\t\t    DA8XX_INTR_TX_MASK | DA8XX_INTR_RX_MASK);\n\tmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\n}\n\n#define portstate(stmt)\t\tstmt\n\nstatic void da8xx_musb_set_vbus(struct musb *musb, int is_on)\n{\n\tWARN_ON(is_on && is_peripheral_active(musb));\n}\n\n#define\tPOLL_SECONDS\t2\n\nstatic void otg_timer(struct timer_list *t)\n{\n\tstruct musb\t\t*musb = from_timer(musb, t, dev_timer);\n\tvoid __iomem\t\t*mregs = musb->mregs;\n\tu8\t\t\tdevctl;\n\tunsigned long\t\tflags;\n\n\t \n\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\tdev_dbg(musb->controller, \"Poll devctl %02x (%s)\\n\", devctl,\n\t\tusb_otg_state_string(musb->xceiv->otg->state));\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tswitch (musb->xceiv->otg->state) {\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, devctl);\n\n\t\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\tif (devctl & MUSB_DEVCTL_BDEVICE) {\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t} else {\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\t\tMUSB_HST_MODE(musb);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\t \n\t\tif (devctl & MUSB_DEVCTL_VBUS) {\n\t\t\tmod_timer(&musb->dev_timer, jiffies + POLL_SECONDS * HZ);\n\t\t\tbreak;\n\t\t}\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tmusb_writel(musb->ctrl_base, DA8XX_USB_INTR_SRC_SET_REG,\n\t\t\t    MUSB_INTR_VBUSERROR << DA8XX_INTR_USB_SHIFT);\n\t\tbreak;\n\tcase OTG_STATE_B_IDLE:\n\t\t \n\t\tmusb_writeb(mregs, MUSB_DEVCTL, devctl | MUSB_DEVCTL_SESSION);\n\t\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\tif (devctl & MUSB_DEVCTL_BDEVICE)\n\t\t\tmod_timer(&musb->dev_timer, jiffies + POLL_SECONDS * HZ);\n\t\telse\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nstatic void da8xx_musb_try_idle(struct musb *musb, unsigned long timeout)\n{\n\tstatic unsigned long last_timer;\n\n\tif (timeout == 0)\n\t\ttimeout = jiffies + msecs_to_jiffies(3);\n\n\t \n\tif (musb->is_active || (musb->a_wait_bcon == 0 &&\n\t\t\t\tmusb->xceiv->otg->state == OTG_STATE_A_WAIT_BCON)) {\n\t\tdev_dbg(musb->controller, \"%s active, deleting timer\\n\",\n\t\t\tusb_otg_state_string(musb->xceiv->otg->state));\n\t\tdel_timer(&musb->dev_timer);\n\t\tlast_timer = jiffies;\n\t\treturn;\n\t}\n\n\tif (time_after(last_timer, timeout) && timer_pending(&musb->dev_timer)) {\n\t\tdev_dbg(musb->controller, \"Longer idle timer already pending, ignoring...\\n\");\n\t\treturn;\n\t}\n\tlast_timer = timeout;\n\n\tdev_dbg(musb->controller, \"%s inactive, starting idle timer for %u ms\\n\",\n\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\tjiffies_to_msecs(timeout - jiffies));\n\tmod_timer(&musb->dev_timer, timeout);\n}\n\nstatic irqreturn_t da8xx_musb_interrupt(int irq, void *hci)\n{\n\tstruct musb\t\t*musb = hci;\n\tvoid __iomem\t\t*reg_base = musb->ctrl_base;\n\tunsigned long\t\tflags;\n\tirqreturn_t\t\tret = IRQ_NONE;\n\tu32\t\t\tstatus;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\t \n\n\t \n\tstatus = musb_readl(reg_base, DA8XX_USB_INTR_SRC_MASKED_REG);\n\tif (!status)\n\t\tgoto eoi;\n\n\tmusb_writel(reg_base, DA8XX_USB_INTR_SRC_CLEAR_REG, status);\n\tdev_dbg(musb->controller, \"USB IRQ %08x\\n\", status);\n\n\tmusb->int_rx = (status & DA8XX_INTR_RX_MASK) >> DA8XX_INTR_RX_SHIFT;\n\tmusb->int_tx = (status & DA8XX_INTR_TX_MASK) >> DA8XX_INTR_TX_SHIFT;\n\tmusb->int_usb = (status & DA8XX_INTR_USB_MASK) >> DA8XX_INTR_USB_SHIFT;\n\n\t \n\tif (status & (DA8XX_INTR_DRVVBUS << DA8XX_INTR_USB_SHIFT)) {\n\t\tint drvvbus = musb_readl(reg_base, DA8XX_USB_STAT_REG);\n\t\tvoid __iomem *mregs = musb->mregs;\n\t\tu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\tint err;\n\n\t\terr = musb->int_usb & MUSB_INTR_VBUSERROR;\n\t\tif (err) {\n\t\t\t \n\t\t\tmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\n\t\t\tmod_timer(&musb->dev_timer, jiffies + POLL_SECONDS * HZ);\n\t\t\tWARNING(\"VBUS error workaround (delay coming)\\n\");\n\t\t} else if (drvvbus) {\n\t\t\tMUSB_HST_MODE(musb);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\t\tportstate(musb->port1_status |= USB_PORT_STAT_POWER);\n\t\t\tdel_timer(&musb->dev_timer);\n\t\t} else if (!(musb->int_usb & MUSB_INTR_BABBLE)) {\n\t\t\t \n\t\t\tmusb->is_active = 0;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\tportstate(musb->port1_status &= ~USB_PORT_STAT_POWER);\n\t\t}\n\n\t\tdev_dbg(musb->controller, \"VBUS %s (%s)%s, devctl %02x\\n\",\n\t\t\t\tdrvvbus ? \"on\" : \"off\",\n\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\t\t\terr ? \" ERROR\" : \"\",\n\t\t\t\tdevctl);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (musb->int_tx || musb->int_rx || musb->int_usb)\n\t\tret |= musb_interrupt(musb);\n\n eoi:\n\t \n\tif (ret == IRQ_HANDLED || status)\n\t\tmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\n\n\t \n\tif (musb->xceiv->otg->state == OTG_STATE_B_IDLE)\n\t\tmod_timer(&musb->dev_timer, jiffies + POLL_SECONDS * HZ);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn ret;\n}\n\nstatic int da8xx_musb_set_mode(struct musb *musb, u8 musb_mode)\n{\n\tstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tenum phy_mode phy_mode;\n\n\t \n\tif (!musb->is_initialized)\n\t\treturn phy_set_mode(glue->phy, PHY_MODE_USB_OTG);\n\n\tswitch (musb_mode) {\n\tcase MUSB_HOST:\t\t \n\t\tphy_mode = PHY_MODE_USB_HOST;\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\t \n\t\tphy_mode = PHY_MODE_USB_DEVICE;\n\t\tbreak;\n\tcase MUSB_OTG:\t\t \n\t\tphy_mode = PHY_MODE_USB_OTG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn phy_set_mode(glue->phy, phy_mode);\n}\n\nstatic int da8xx_musb_init(struct musb *musb)\n{\n\tstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\tu32 rev;\n\tint ret = -ENODEV;\n\n\tmusb->mregs += DA8XX_MENTOR_CORE_OFFSET;\n\n\tret = clk_prepare_enable(glue->clk);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\trev = musb_readl(reg_base, DA8XX_USB_REVISION_REG);\n\tif (!rev) {\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tmusb->xceiv = usb_get_phy(USB_PHY_TYPE_USB2);\n\tif (IS_ERR_OR_NULL(musb->xceiv)) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto fail;\n\t}\n\n\ttimer_setup(&musb->dev_timer, otg_timer, 0);\n\n\t \n\tmusb_writel(reg_base, DA8XX_USB_CTRL_REG, DA8XX_SOFT_RESET_MASK);\n\n\t \n\tret = phy_init(glue->phy);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"Failed to init phy.\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = phy_power_on(glue->phy);\n\tif (ret) {\n\t\tdev_err(glue->dev, \"Failed to power on phy.\\n\");\n\t\tgoto err_phy_power_on;\n\t}\n\n\tmsleep(5);\n\n\t \n\tpr_debug(\"DA8xx OTG revision %08x, control %02x\\n\", rev,\n\t\t musb_readb(reg_base, DA8XX_USB_CTRL_REG));\n\n\tmusb->isr = da8xx_musb_interrupt;\n\treturn 0;\n\nerr_phy_power_on:\n\tphy_exit(glue->phy);\nfail:\n\tclk_disable_unprepare(glue->clk);\n\treturn ret;\n}\n\nstatic int da8xx_musb_exit(struct musb *musb)\n{\n\tstruct da8xx_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tdel_timer_sync(&musb->dev_timer);\n\n\tphy_power_off(glue->phy);\n\tphy_exit(glue->phy);\n\tclk_disable_unprepare(glue->clk);\n\n\tusb_put_phy(musb->xceiv);\n\n\treturn 0;\n}\n\nstatic inline u8 get_vbus_power(struct device *dev)\n{\n\tstruct regulator *vbus_supply;\n\tint current_uA;\n\n\tvbus_supply = regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(vbus_supply))\n\t\treturn 255;\n\tcurrent_uA = regulator_get_current_limit(vbus_supply);\n\tregulator_put(vbus_supply);\n\tif (current_uA <= 0 || current_uA > 510000)\n\t\treturn 255;\n\treturn current_uA / 1000 / 2;\n}\n\n#ifdef CONFIG_USB_TI_CPPI41_DMA\nstatic void da8xx_dma_controller_callback(struct dma_controller *c)\n{\n\tstruct musb *musb = c->musb;\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\n\tmusb_writel(reg_base, DA8XX_USB_END_OF_INTR_REG, 0);\n}\n\nstatic struct dma_controller *\nda8xx_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tstruct dma_controller *controller;\n\n\tcontroller = cppi41_dma_controller_create(musb, base);\n\tif (IS_ERR_OR_NULL(controller))\n\t\treturn controller;\n\n\tcontroller->dma_callback = da8xx_dma_controller_callback;\n\n\treturn controller;\n}\n#endif\n\nstatic const struct musb_platform_ops da8xx_ops = {\n\t.quirks\t\t= MUSB_INDEXED_EP | MUSB_PRESERVE_SESSION |\n\t\t\t  MUSB_DMA_CPPI41 | MUSB_DA8XX,\n\t.init\t\t= da8xx_musb_init,\n\t.exit\t\t= da8xx_musb_exit,\n\n\t.fifo_mode\t= 2,\n#ifdef CONFIG_USB_TI_CPPI41_DMA\n\t.dma_init\t= da8xx_dma_controller_create,\n\t.dma_exit\t= cppi41_dma_controller_destroy,\n#endif\n\t.enable\t\t= da8xx_musb_enable,\n\t.disable\t= da8xx_musb_disable,\n\n\t.set_mode\t= da8xx_musb_set_mode,\n\t.try_idle\t= da8xx_musb_try_idle,\n\n\t.set_vbus\t= da8xx_musb_set_vbus,\n};\n\nstatic const struct platform_device_info da8xx_dev_info = {\n\t.name\t\t= \"musb-hdrc\",\n\t.id\t\t= PLATFORM_DEVID_AUTO,\n\t.dma_mask\t= DMA_BIT_MASK(32),\n};\n\nstatic const struct musb_hdrc_config da8xx_config = {\n\t.ram_bits = 10,\n\t.num_eps = 5,\n\t.multipoint = 1,\n};\n\nstatic struct of_dev_auxdata da8xx_auxdata_lookup[] = {\n\tOF_DEV_AUXDATA(\"ti,da830-cppi41\", 0x01e01000, \"cppi41-dmaengine\",\n\t\t       NULL),\n\t{}\n};\n\nstatic int da8xx_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data\t*pdata = dev_get_platdata(&pdev->dev);\n\tstruct da8xx_glue\t\t*glue;\n\tstruct platform_device_info\tpinfo;\n\tstruct clk\t\t\t*clk;\n\tstruct device_node\t\t*np = pdev->dev.of_node;\n\tint\t\t\t\tret;\n\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tclk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tglue->phy = devm_phy_get(&pdev->dev, \"usb-phy\");\n\tif (IS_ERR(glue->phy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(glue->phy),\n\t\t\t\t     \"failed to get phy\\n\");\n\n\tglue->dev\t\t\t= &pdev->dev;\n\tglue->clk\t\t\t= clk;\n\n\tif (IS_ENABLED(CONFIG_OF) && np) {\n\t\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata)\n\t\t\treturn -ENOMEM;\n\n\t\tpdata->config\t= &da8xx_config;\n\t\tpdata->mode\t= musb_get_mode(&pdev->dev);\n\t\tpdata->power\t= get_vbus_power(&pdev->dev);\n\t}\n\n\tpdata->platform_ops\t\t= &da8xx_ops;\n\n\tglue->usb_phy = usb_phy_generic_register();\n\tret = PTR_ERR_OR_ZERO(glue->usb_phy);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register usb_phy\\n\");\n\t\treturn ret;\n\t}\n\tplatform_set_drvdata(pdev, glue);\n\n\tret = of_platform_populate(pdev->dev.of_node, NULL,\n\t\t\t\t   da8xx_auxdata_lookup, &pdev->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tpinfo = da8xx_dev_info;\n\tpinfo.parent = &pdev->dev;\n\tpinfo.res = pdev->resource;\n\tpinfo.num_res = pdev->num_resources;\n\tpinfo.data = pdata;\n\tpinfo.size_data = sizeof(*pdata);\n\tpinfo.fwnode = of_fwnode_handle(np);\n\tpinfo.of_node_reused = true;\n\n\tglue->musb = platform_device_register_full(&pinfo);\n\tret = PTR_ERR_OR_ZERO(glue->musb);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register musb device: %d\\n\", ret);\n\t\tusb_phy_generic_unregister(glue->usb_phy);\n\t}\n\n\treturn ret;\n}\n\nstatic void da8xx_remove(struct platform_device *pdev)\n{\n\tstruct da8xx_glue\t\t*glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->musb);\n\tusb_phy_generic_unregister(glue->usb_phy);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int da8xx_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct da8xx_glue *glue = dev_get_drvdata(dev);\n\n\tret = phy_power_off(glue->phy);\n\tif (ret)\n\t\treturn ret;\n\tclk_disable_unprepare(glue->clk);\n\n\treturn 0;\n}\n\nstatic int da8xx_resume(struct device *dev)\n{\n\tint ret;\n\tstruct da8xx_glue *glue = dev_get_drvdata(dev);\n\n\tret = clk_prepare_enable(glue->clk);\n\tif (ret)\n\t\treturn ret;\n\treturn phy_power_on(glue->phy);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(da8xx_pm_ops, da8xx_suspend, da8xx_resume);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id da8xx_id_table[] = {\n\t{\n\t\t.compatible = \"ti,da830-musb\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, da8xx_id_table);\n#endif\n\nstatic struct platform_driver da8xx_driver = {\n\t.probe\t\t= da8xx_probe,\n\t.remove_new\t= da8xx_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"musb-da8xx\",\n\t\t.pm = &da8xx_pm_ops,\n\t\t.of_match_table = of_match_ptr(da8xx_id_table),\n\t},\n};\n\nMODULE_DESCRIPTION(\"DA8xx/OMAP-L1x MUSB Glue Layer\");\nMODULE_AUTHOR(\"Sergei Shtylyov <sshtylyov@ru.mvista.com>\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_platform_driver(da8xx_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}