{
  "module_name": "musb_virthub.c",
  "hash_id": "70b6b8736e29b5de1d5135dc2ab238e2eafcfde9174710e5ef66c6f6a04065e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_virthub.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/time.h>\n#include <linux/timer.h>\n\n#include <asm/unaligned.h>\n\n#include \"musb_core.h\"\n\nvoid musb_host_finish_resume(struct work_struct *work)\n{\n\tstruct musb *musb;\n\tunsigned long flags;\n\tu8 power;\n\n\tmusb = container_of(work, struct musb, finish_resume_work.work);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tpower = musb_readb(musb->mregs, MUSB_POWER);\n\tpower &= ~MUSB_POWER_RESUME;\n\tmusb_dbg(musb, \"root port resume stopped, power %02x\", power);\n\tmusb_writeb(musb->mregs, MUSB_POWER, power);\n\n\t \n\tmusb->is_active = 1;\n\tmusb->port1_status &= ~(USB_PORT_STAT_SUSPEND | MUSB_PORT_STAT_RESUME);\n\tmusb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;\n\tusb_hcd_poll_rh_status(musb->hcd);\n\t \n\tmusb_set_state(musb, OTG_STATE_A_HOST);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nint musb_port_suspend(struct musb *musb, bool do_suspend)\n{\n\tu8\t\tpower;\n\tvoid __iomem\t*mbase = musb->mregs;\n\n\tif (!is_host_active(musb))\n\t\treturn 0;\n\n\t \n\tpower = musb_readb(mbase, MUSB_POWER);\n\tif (do_suspend) {\n\t\tint retries = 10000;\n\n\t\tif (power & MUSB_POWER_RESUME)\n\t\t\treturn -EBUSY;\n\n\t\tif (!(power & MUSB_POWER_SUSPENDM)) {\n\t\t\tpower |= MUSB_POWER_SUSPENDM;\n\t\t\tmusb_writeb(mbase, MUSB_POWER, power);\n\n\t\t\t \n\t\t\tpower = musb_readb(mbase, MUSB_POWER);\n\t\t\twhile (power & MUSB_POWER_SUSPENDM) {\n\t\t\t\tpower = musb_readb(mbase, MUSB_POWER);\n\t\t\t\tif (retries-- < 1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tmusb_dbg(musb, \"Root port suspended, power %02x\", power);\n\n\t\tmusb->port1_status |= USB_PORT_STAT_SUSPEND;\n\t\tswitch (musb_get_state(musb)) {\n\t\tcase OTG_STATE_A_HOST:\n\t\t\tmusb_set_state(musb, OTG_STATE_A_SUSPEND);\n\t\t\tmusb->is_active = musb->xceiv &&\n\t\t\t\tmusb->xceiv->otg->host->b_hnp_enable;\n\t\t\tif (musb->is_active)\n\t\t\t\tmod_timer(&musb->otg_timer, jiffies\n\t\t\t\t\t+ msecs_to_jiffies(\n\t\t\t\t\t\tOTG_TIME_A_AIDL_BDIS));\n\t\t\tmusb_platform_try_idle(musb, 0);\n\t\t\tbreak;\n\t\tcase OTG_STATE_B_HOST:\n\t\t\tmusb_set_state(musb, OTG_STATE_B_WAIT_ACON);\n\t\t\tmusb->is_active = musb->xceiv &&\n\t\t\t\tmusb->xceiv->otg->host->b_hnp_enable;\n\t\t\tmusb_platform_try_idle(musb, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmusb_dbg(musb, \"bogus rh suspend? %s\",\n\t\t\t\t musb_otg_state_string(musb));\n\t\t}\n\t} else if (power & MUSB_POWER_SUSPENDM) {\n\t\tpower &= ~MUSB_POWER_SUSPENDM;\n\t\tpower |= MUSB_POWER_RESUME;\n\t\tmusb_writeb(mbase, MUSB_POWER, power);\n\n\t\tmusb_dbg(musb, \"Root port resuming, power %02x\", power);\n\n\t\tmusb->port1_status |= MUSB_PORT_STAT_RESUME;\n\t\tschedule_delayed_work(&musb->finish_resume_work,\n\t\t\t\t      msecs_to_jiffies(USB_RESUME_TIMEOUT));\n\t}\n\treturn 0;\n}\n\nvoid musb_port_reset(struct musb *musb, bool do_reset)\n{\n\tu8\t\tpower;\n\tvoid __iomem\t*mbase = musb->mregs;\n\n\tif (musb_get_state(musb) == OTG_STATE_B_IDLE) {\n\t\tmusb_dbg(musb, \"HNP: Returning from HNP; no hub reset from b_idle\");\n\t\tmusb->port1_status &= ~USB_PORT_STAT_RESET;\n\t\treturn;\n\t}\n\n\tif (!is_host_active(musb))\n\t\treturn;\n\n\t \n\tpower = musb_readb(mbase, MUSB_POWER);\n\tif (do_reset) {\n\t\t \n\t\tif (power &  MUSB_POWER_RESUME) {\n\t\t\tlong remain = (unsigned long) musb->rh_timer - jiffies;\n\n\t\t\tif (musb->rh_timer > 0 && remain > 0) {\n\t\t\t\t \n\t\t\t\tschedule_delayed_work(\n\t\t\t\t\t&musb->deassert_reset_work, remain);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tmusb_writeb(mbase, MUSB_POWER,\n\t\t\t\t    power & ~MUSB_POWER_RESUME);\n\n\t\t\t \n\t\t\tschedule_delayed_work(&musb->deassert_reset_work,\n\t\t\t\t\t      msecs_to_jiffies(1));\n\t\t\treturn;\n\t\t}\n\n\t\tpower &= 0xf0;\n\t\tmusb_writeb(mbase, MUSB_POWER,\n\t\t\t\tpower | MUSB_POWER_RESET);\n\n\t\tmusb->port1_status |= USB_PORT_STAT_RESET;\n\t\tmusb->port1_status &= ~USB_PORT_STAT_ENABLE;\n\t\tschedule_delayed_work(&musb->deassert_reset_work,\n\t\t\t\t      msecs_to_jiffies(50));\n\t} else {\n\t\tmusb_dbg(musb, \"root port reset stopped\");\n\t\tmusb_platform_pre_root_reset_end(musb);\n\t\tmusb_writeb(mbase, MUSB_POWER,\n\t\t\t\tpower & ~MUSB_POWER_RESET);\n\t\tmusb_platform_post_root_reset_end(musb);\n\n\t\tpower = musb_readb(mbase, MUSB_POWER);\n\t\tif (power & MUSB_POWER_HSMODE) {\n\t\t\tmusb_dbg(musb, \"high-speed device connected\");\n\t\t\tmusb->port1_status |= USB_PORT_STAT_HIGH_SPEED;\n\t\t}\n\n\t\tmusb->port1_status &= ~USB_PORT_STAT_RESET;\n\t\tmusb->port1_status |= USB_PORT_STAT_ENABLE\n\t\t\t\t\t| (USB_PORT_STAT_C_RESET << 16)\n\t\t\t\t\t| (USB_PORT_STAT_C_ENABLE << 16);\n\t\tusb_hcd_poll_rh_status(musb->hcd);\n\n\t\tmusb->vbuserr_retry = VBUSERR_RETRY_COUNT;\n\t}\n}\n\nvoid musb_root_disconnect(struct musb *musb)\n{\n\tmusb->port1_status = USB_PORT_STAT_POWER\n\t\t\t| (USB_PORT_STAT_C_CONNECTION << 16);\n\n\tusb_hcd_poll_rh_status(musb->hcd);\n\tmusb->is_active = 0;\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_SUSPEND:\n\t\tif (musb->xceiv && musb->xceiv->otg->host->b_hnp_enable) {\n\t\t\tmusb_set_state(musb, OTG_STATE_A_PERIPHERAL);\n\t\t\tmusb->g.is_a_peripheral = 1;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase OTG_STATE_A_HOST:\n\t\tmusb_set_state(musb, OTG_STATE_A_WAIT_BCON);\n\t\tmusb->is_active = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\t\tbreak;\n\tdefault:\n\t\tmusb_dbg(musb, \"host disconnect (%s)\",\n\t\t\t musb_otg_state_string(musb));\n\t}\n}\nEXPORT_SYMBOL_GPL(musb_root_disconnect);\n\n\n \n\n \nint musb_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\tint\t\tretval = 0;\n\n\t \n\tif (musb->port1_status & 0xffff0000) {\n\t\t*buf = 0x02;\n\t\tretval = 1;\n\t}\n\treturn retval;\n}\n\nstatic int musb_has_gadget(struct musb *musb)\n{\n\t \n#ifdef CONFIG_USB_MUSB_HOST\n\treturn 1;\n#else\n\treturn musb->port_mode == MUSB_HOST;\n#endif\n}\n\nint musb_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\tu32\t\ttemp;\n\tint\t\tretval = 0;\n\tunsigned long\tflags;\n\tbool\t\tstart_musb = false;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(hcd))) {\n\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif ((wIndex & 0xff) != 1)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tmusb_port_suspend(musb, false);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (!hcd->self.is_b_host)\n\t\t\t\tmusb_platform_set_vbus(musb, 0);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tmusb_dbg(musb, \"clear feature %d\", wValue);\n\t\tmusb->port1_status &= ~(1 << wValue);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\t{\n\t\tstruct usb_hub_descriptor *desc = (void *)buf;\n\n\t\tdesc->bDescLength = 9;\n\t\tdesc->bDescriptorType = USB_DT_HUB;\n\t\tdesc->bNbrPorts = 1;\n\t\tdesc->wHubCharacteristics = cpu_to_le16(\n\t\t\tHUB_CHAR_INDV_PORT_LPSM  \n\t\t\t| HUB_CHAR_NO_OCPM\t \n\t\t\t);\n\t\tdesc->bPwrOn2PwrGood = 5;\t \n\t\tdesc->bHubContrCurrent = 0;\n\n\t\t \n\t\tdesc->u.hs.DeviceRemovable[0] = 0x02;\t \n\t\tdesc->u.hs.DeviceRemovable[1] = 0xff;\n\t\t}\n\t\tbreak;\n\tcase GetHubStatus:\n\t\ttemp = 0;\n\t\t*(__le32 *) buf = cpu_to_le32(temp);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (wIndex != 1)\n\t\t\tgoto error;\n\n\t\tput_unaligned(cpu_to_le32(musb->port1_status\n\t\t\t\t\t& ~MUSB_PORT_STAT_RESUME),\n\t\t\t\t(__le32 *) buf);\n\n\t\t \n\t\tmusb_dbg(musb, \"port status %08x\", musb->port1_status);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif ((wIndex & 0xff) != 1)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\t \n\t\t\tif (!hcd->self.is_b_host && musb_has_gadget(musb))\n\t\t\t\tstart_musb = true;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tmusb_port_reset(musb, true);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tmusb_port_suspend(musb, true);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\tif (unlikely(is_host_active(musb)))\n\t\t\t\tgoto error;\n\n\t\t\twIndex >>= 8;\n\t\t\tswitch (wIndex) {\n\t\t\tcase USB_TEST_J:\n\t\t\t\tpr_debug(\"USB_TEST_J\\n\");\n\t\t\t\ttemp = MUSB_TEST_J;\n\t\t\t\tbreak;\n\t\t\tcase USB_TEST_K:\n\t\t\t\tpr_debug(\"USB_TEST_K\\n\");\n\t\t\t\ttemp = MUSB_TEST_K;\n\t\t\t\tbreak;\n\t\t\tcase USB_TEST_SE0_NAK:\n\t\t\t\tpr_debug(\"USB_TEST_SE0_NAK\\n\");\n\t\t\t\ttemp = MUSB_TEST_SE0_NAK;\n\t\t\t\tbreak;\n\t\t\tcase USB_TEST_PACKET:\n\t\t\t\tpr_debug(\"USB_TEST_PACKET\\n\");\n\t\t\t\ttemp = MUSB_TEST_PACKET;\n\t\t\t\tmusb_load_testpacket(musb);\n\t\t\t\tbreak;\n\t\t\tcase USB_TEST_FORCE_ENABLE:\n\t\t\t\tpr_debug(\"USB_TEST_FORCE_ENABLE\\n\");\n\t\t\t\ttemp = MUSB_TEST_FORCE_HOST\n\t\t\t\t\t| MUSB_TEST_FORCE_HS;\n\n\t\t\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL,\n\t\t\t\t\t\tMUSB_DEVCTL_SESSION);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\tpr_debug(\"TEST_FIFO_ACCESS\\n\");\n\t\t\t\ttemp = MUSB_TEST_FIFO_ACCESS;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tmusb_writeb(musb->mregs, MUSB_TESTMODE, temp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tmusb_dbg(musb, \"set feature %d\", wValue);\n\t\tmusb->port1_status |= 1 << wValue;\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\tif (start_musb)\n\t\tmusb_start(musb);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}