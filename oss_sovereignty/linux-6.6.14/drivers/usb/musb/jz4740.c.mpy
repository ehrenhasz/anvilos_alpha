{
  "module_name": "jz4740.c",
  "hash_id": "fda438ac0d70ad502f356131f5fce23683dfaaf0cd9d9c139926a0e0e5ea454b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/jz4740.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/usb/role.h>\n#include <linux/usb/usb_phy_generic.h>\n\n#include \"musb_core.h\"\n\nstruct jz4740_glue {\n\tstruct platform_device\t*pdev;\n\tstruct musb\t\t*musb;\n\tstruct clk\t\t*clk;\n\tstruct usb_role_switch\t*role_sw;\n};\n\nstatic irqreturn_t jz4740_musb_interrupt(int irq, void *__hci)\n{\n\tunsigned long\tflags;\n\tirqreturn_t\tretval = IRQ_NONE, retval_dma = IRQ_NONE;\n\tstruct musb\t*musb = __hci;\n\n\tif (IS_ENABLED(CONFIG_USB_INVENTRA_DMA) && musb->dma_controller)\n\t\tretval_dma = dma_controller_irq(irq, musb->dma_controller);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);\n\tmusb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);\n\tmusb->int_rx = musb_readw(musb->mregs, MUSB_INTRRX);\n\n\t \n\tmusb->int_usb &= MUSB_INTR_SUSPEND | MUSB_INTR_RESUME |\n\t\t\t MUSB_INTR_RESET | MUSB_INTR_SOF;\n\n\tif (musb->int_usb || musb->int_tx || musb->int_rx)\n\t\tretval = musb_interrupt(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\tif (retval == IRQ_HANDLED || retval_dma == IRQ_HANDLED)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\n\nstatic struct musb_fifo_cfg jz4740_musb_fifo_cfg[] = {\n\t{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 64, },\n};\n\nstatic const struct musb_hdrc_config jz4740_musb_config = {\n\t \n\t.multipoint\t= 0,\n\t \n\t.num_eps\t= 4,\n\t \n\t.ram_bits\t= 9,\n\t.fifo_cfg\t= jz4740_musb_fifo_cfg,\n\t.fifo_cfg_size\t= ARRAY_SIZE(jz4740_musb_fifo_cfg),\n};\n\nstatic int jz4740_musb_role_switch_set(struct usb_role_switch *sw,\n\t\t\t\t       enum usb_role role)\n{\n\tstruct jz4740_glue *glue = usb_role_switch_get_drvdata(sw);\n\tstruct usb_phy *phy = glue->musb->xceiv;\n\n\tif (!phy)\n\t\treturn 0;\n\n\tswitch (role) {\n\tcase USB_ROLE_NONE:\n\t\tatomic_notifier_call_chain(&phy->notifier, USB_EVENT_NONE, phy);\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tatomic_notifier_call_chain(&phy->notifier, USB_EVENT_VBUS, phy);\n\t\tbreak;\n\tcase USB_ROLE_HOST:\n\t\tatomic_notifier_call_chain(&phy->notifier, USB_EVENT_ID, phy);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int jz4740_musb_init(struct musb *musb)\n{\n\tstruct device *dev = musb->controller->parent;\n\tstruct jz4740_glue *glue = dev_get_drvdata(dev);\n\tstruct usb_role_switch_desc role_sw_desc = {\n\t\t.set = jz4740_musb_role_switch_set,\n\t\t.driver_data = glue,\n\t\t.fwnode = dev_fwnode(dev),\n\t};\n\tint err;\n\n\tglue->musb = musb;\n\n\tif (IS_ENABLED(CONFIG_GENERIC_PHY)) {\n\t\tmusb->phy = devm_of_phy_get_by_index(dev, dev->of_node, 0);\n\t\tif (IS_ERR(musb->phy)) {\n\t\t\terr = PTR_ERR(musb->phy);\n\t\t\tif (err != -ENODEV) {\n\t\t\t\tdev_err(dev, \"Unable to get PHY\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\n\t\t\tmusb->phy = NULL;\n\t\t}\n\t}\n\n\tif (musb->phy) {\n\t\terr = phy_init(musb->phy);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to init PHY\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = phy_power_on(musb->phy);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Unable to power on PHY\\n\");\n\t\t\tgoto err_phy_shutdown;\n\t\t}\n\t} else {\n\t\tif (dev->of_node)\n\t\t\tmusb->xceiv = devm_usb_get_phy_by_phandle(dev, \"phys\", 0);\n\t\telse\n\t\t\tmusb->xceiv = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);\n\t\tif (IS_ERR(musb->xceiv)) {\n\t\t\tdev_err(dev, \"No transceiver configured\\n\");\n\t\t\treturn PTR_ERR(musb->xceiv);\n\t\t}\n\t}\n\n\tglue->role_sw = usb_role_switch_register(dev, &role_sw_desc);\n\tif (IS_ERR(glue->role_sw)) {\n\t\tdev_err(dev, \"Failed to register USB role switch\\n\");\n\t\terr = PTR_ERR(glue->role_sw);\n\t\tgoto err_phy_power_down;\n\t}\n\n\t \n\tmusb->dyn_fifo = true;\n\n\tmusb->isr = jz4740_musb_interrupt;\n\n\treturn 0;\n\nerr_phy_power_down:\n\tif (musb->phy)\n\t\tphy_power_off(musb->phy);\nerr_phy_shutdown:\n\tif (musb->phy)\n\t\tphy_exit(musb->phy);\n\treturn err;\n}\n\nstatic int jz4740_musb_exit(struct musb *musb)\n{\n\tstruct jz4740_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tusb_role_switch_unregister(glue->role_sw);\n\tif (musb->phy) {\n\t\tphy_power_off(musb->phy);\n\t\tphy_exit(musb->phy);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct musb_platform_ops jz4740_musb_ops = {\n\t.quirks\t\t= MUSB_DMA_INVENTRA | MUSB_INDEXED_EP,\n\t.fifo_mode\t= 2,\n\t.init\t\t= jz4740_musb_init,\n\t.exit\t\t= jz4740_musb_exit,\n#ifdef CONFIG_USB_INVENTRA_DMA\n\t.dma_init\t= musbhs_dma_controller_create_noirq,\n\t.dma_exit\t= musbhs_dma_controller_destroy,\n#endif\n};\n\nstatic const struct musb_hdrc_platform_data jz4740_musb_pdata = {\n\t.mode\t\t= MUSB_PERIPHERAL,\n\t.config\t\t= &jz4740_musb_config,\n\t.platform_ops\t= &jz4740_musb_ops,\n};\n\nstatic struct musb_fifo_cfg jz4770_musb_fifo_cfg[] = {\n\t{ .hw_ep_num = 1, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 1, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 2, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 3, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 4, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 4, .style = FIFO_RX, .maxpacket = 512, },\n\t{ .hw_ep_num = 5, .style = FIFO_TX, .maxpacket = 512, },\n\t{ .hw_ep_num = 5, .style = FIFO_RX, .maxpacket = 512, },\n};\n\nstatic struct musb_hdrc_config jz4770_musb_config = {\n\t.multipoint\t= 1,\n\t.num_eps\t= 11,\n\t.ram_bits\t= 11,\n\t.fifo_cfg\t= jz4770_musb_fifo_cfg,\n\t.fifo_cfg_size\t= ARRAY_SIZE(jz4770_musb_fifo_cfg),\n};\n\nstatic const struct musb_hdrc_platform_data jz4770_musb_pdata = {\n\t.mode\t\t= MUSB_PERIPHERAL,  \n\t.config\t\t= &jz4770_musb_config,\n\t.platform_ops\t= &jz4740_musb_ops,\n};\n\nstatic int jz4740_probe(struct platform_device *pdev)\n{\n\tstruct device\t\t\t*dev = &pdev->dev;\n\tconst struct musb_hdrc_platform_data *pdata;\n\tstruct platform_device\t\t*musb;\n\tstruct jz4740_glue\t\t*glue;\n\tstruct clk\t\t\t*clk;\n\tint\t\t\t\tret;\n\n\tglue = devm_kzalloc(dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tpdata = of_device_get_match_data(dev);\n\tif (!pdata) {\n\t\tdev_err(dev, \"missing platform data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmusb = platform_device_alloc(\"musb-hdrc\", PLATFORM_DEVID_AUTO);\n\tif (!musb) {\n\t\tdev_err(dev, \"failed to allocate musb device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tclk = devm_clk_get(dev, \"udc\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\tret = PTR_ERR(clk);\n\t\tgoto err_platform_device_put;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clock\\n\");\n\t\tgoto err_platform_device_put;\n\t}\n\n\tmusb->dev.parent\t\t= dev;\n\tmusb->dev.dma_mask\t\t= &musb->dev.coherent_dma_mask;\n\tmusb->dev.coherent_dma_mask\t= DMA_BIT_MASK(32);\n\tdevice_set_of_node_from_dev(&musb->dev, dev);\n\n\tglue->pdev\t\t\t= musb;\n\tglue->clk\t\t\t= clk;\n\n\tplatform_set_drvdata(pdev, glue);\n\n\tret = platform_device_add_resources(musb, pdev->resource,\n\t\t\t\t\t    pdev->num_resources);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add resources\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = platform_device_add_data(musb, pdata, sizeof(*pdata));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add platform_data\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\tret = platform_device_add(musb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register musb device\\n\");\n\t\tgoto err_clk_disable;\n\t}\n\n\treturn 0;\n\nerr_clk_disable:\n\tclk_disable_unprepare(clk);\nerr_platform_device_put:\n\tplatform_device_put(musb);\n\treturn ret;\n}\n\nstatic void jz4740_remove(struct platform_device *pdev)\n{\n\tstruct jz4740_glue *glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->pdev);\n\tclk_disable_unprepare(glue->clk);\n}\n\nstatic const struct of_device_id jz4740_musb_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-musb\", .data = &jz4740_musb_pdata },\n\t{ .compatible = \"ingenic,jz4770-musb\", .data = &jz4770_musb_pdata },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, jz4740_musb_of_match);\n\nstatic struct platform_driver jz4740_driver = {\n\t.probe\t\t= jz4740_probe,\n\t.remove_new\t= jz4740_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"musb-jz4740\",\n\t\t.of_match_table = jz4740_musb_of_match,\n\t},\n};\n\nMODULE_DESCRIPTION(\"JZ4740 MUSB Glue Layer\");\nMODULE_AUTHOR(\"Apelete Seketeli <apelete@seketeli.net>\");\nMODULE_LICENSE(\"GPL v2\");\nmodule_platform_driver(jz4740_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}