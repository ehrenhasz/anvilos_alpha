{
  "module_name": "sunxi.c",
  "hash_id": "cdb9a6a8310f24e8d7eb1c5cfea64880578af1c0844d189912b05cf71637a81b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/sunxi.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/extcon.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy-sun4i-usb.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/soc/sunxi/sunxi_sram.h>\n#include <linux/usb/musb.h>\n#include <linux/usb/of.h>\n#include <linux/usb/usb_phy_generic.h>\n#include <linux/workqueue.h>\n#include \"musb_core.h\"\n\n \n#define SUNXI_MUSB_POWER\t\t\t0x0040\n#define SUNXI_MUSB_DEVCTL\t\t\t0x0041\n#define SUNXI_MUSB_INDEX\t\t\t0x0042\n#define SUNXI_MUSB_VEND0\t\t\t0x0043\n#define SUNXI_MUSB_INTRTX\t\t\t0x0044\n#define SUNXI_MUSB_INTRRX\t\t\t0x0046\n#define SUNXI_MUSB_INTRTXE\t\t\t0x0048\n#define SUNXI_MUSB_INTRRXE\t\t\t0x004a\n#define SUNXI_MUSB_INTRUSB\t\t\t0x004c\n#define SUNXI_MUSB_INTRUSBE\t\t\t0x0050\n#define SUNXI_MUSB_FRAME\t\t\t0x0054\n#define SUNXI_MUSB_TXFIFOSZ\t\t\t0x0090\n#define SUNXI_MUSB_TXFIFOADD\t\t\t0x0092\n#define SUNXI_MUSB_RXFIFOSZ\t\t\t0x0094\n#define SUNXI_MUSB_RXFIFOADD\t\t\t0x0096\n#define SUNXI_MUSB_FADDR\t\t\t0x0098\n#define SUNXI_MUSB_TXFUNCADDR\t\t\t0x0098\n#define SUNXI_MUSB_TXHUBADDR\t\t\t0x009a\n#define SUNXI_MUSB_TXHUBPORT\t\t\t0x009b\n#define SUNXI_MUSB_RXFUNCADDR\t\t\t0x009c\n#define SUNXI_MUSB_RXHUBADDR\t\t\t0x009e\n#define SUNXI_MUSB_RXHUBPORT\t\t\t0x009f\n#define SUNXI_MUSB_CONFIGDATA\t\t\t0x00c0\n\n \n#define SUNXI_MUSB_VEND0_PIO_MODE\t\t0\n\n \n#define SUNXI_MUSB_FL_ENABLED\t\t\t0\n#define SUNXI_MUSB_FL_HOSTMODE\t\t\t1\n#define SUNXI_MUSB_FL_HOSTMODE_PEND\t\t2\n#define SUNXI_MUSB_FL_VBUS_ON\t\t\t3\n#define SUNXI_MUSB_FL_PHY_ON\t\t\t4\n#define SUNXI_MUSB_FL_HAS_SRAM\t\t\t5\n#define SUNXI_MUSB_FL_HAS_RESET\t\t\t6\n#define SUNXI_MUSB_FL_NO_CONFIGDATA\t\t7\n#define SUNXI_MUSB_FL_PHY_MODE_PEND\t\t8\n\nstruct sunxi_musb_cfg {\n\tconst struct musb_hdrc_config *hdrc_config;\n\tbool has_sram;\n\tbool has_reset;\n\tbool no_configdata;\n};\n\n \nstatic struct musb *sunxi_musb;\n\nstruct sunxi_glue {\n\tstruct device\t\t*dev;\n\tstruct musb\t\t*musb;\n\tstruct platform_device\t*musb_pdev;\n\tstruct clk\t\t*clk;\n\tstruct reset_control\t*rst;\n\tstruct phy\t\t*phy;\n\tstruct platform_device\t*usb_phy;\n\tstruct usb_phy\t\t*xceiv;\n\tenum phy_mode\t\tphy_mode;\n\tunsigned long\t\tflags;\n\tstruct work_struct\twork;\n\tstruct extcon_dev\t*extcon;\n\tstruct notifier_block\thost_nb;\n};\n\n \nstatic void sunxi_musb_work(struct work_struct *work)\n{\n\tstruct sunxi_glue *glue = container_of(work, struct sunxi_glue, work);\n\tbool vbus_on, phy_on;\n\n\tif (!test_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags))\n\t\treturn;\n\n\tif (test_and_clear_bit(SUNXI_MUSB_FL_HOSTMODE_PEND, &glue->flags)) {\n\t\tstruct musb *musb = glue->musb;\n\t\tunsigned long flags;\n\t\tu8 devctl;\n\n\t\tspin_lock_irqsave(&musb->lock, flags);\n\n\t\tdevctl = readb(musb->mregs + SUNXI_MUSB_DEVCTL);\n\t\tif (test_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags)) {\n\t\t\tset_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\t\tMUSB_HST_MODE(musb);\n\t\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\t} else {\n\t\t\tclear_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t\tdevctl &= ~MUSB_DEVCTL_SESSION;\n\t\t}\n\t\twriteb(devctl, musb->mregs + SUNXI_MUSB_DEVCTL);\n\n\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t}\n\n\tvbus_on = test_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\n\tphy_on = test_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\n\n\tif (phy_on != vbus_on) {\n\t\tif (vbus_on) {\n\t\t\tphy_power_on(glue->phy);\n\t\t\tset_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\n\t\t} else {\n\t\t\tphy_power_off(glue->phy);\n\t\t\tclear_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\n\t\t}\n\t}\n\n\tif (test_and_clear_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags))\n\t\tphy_set_mode(glue->phy, glue->phy_mode);\n}\n\nstatic void sunxi_musb_set_vbus(struct musb *musb, int is_on)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tif (is_on) {\n\t\tset_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t} else {\n\t\tclear_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\n\t}\n\n\tschedule_work(&glue->work);\n}\n\nstatic void sunxi_musb_pre_root_reset_end(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tsun4i_usb_phy_set_squelch_detect(glue->phy, false);\n}\n\nstatic void sunxi_musb_post_root_reset_end(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tsun4i_usb_phy_set_squelch_detect(glue->phy, true);\n}\n\nstatic irqreturn_t sunxi_musb_interrupt(int irq, void *__hci)\n{\n\tstruct musb *musb = __hci;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb->int_usb = readb(musb->mregs + SUNXI_MUSB_INTRUSB);\n\tif (musb->int_usb)\n\t\twriteb(musb->int_usb, musb->mregs + SUNXI_MUSB_INTRUSB);\n\n\tif ((musb->int_usb & MUSB_INTR_RESET) && !is_host_active(musb)) {\n\t\t \n\t\tmusb_ep_select(musb->mregs, 0);\n\t\tmusb_writeb(musb->mregs, MUSB_FADDR, 0);\n\t}\n\n\tmusb->int_tx = readw(musb->mregs + SUNXI_MUSB_INTRTX);\n\tif (musb->int_tx)\n\t\twritew(musb->int_tx, musb->mregs + SUNXI_MUSB_INTRTX);\n\n\tmusb->int_rx = readw(musb->mregs + SUNXI_MUSB_INTRRX);\n\tif (musb->int_rx)\n\t\twritew(musb->int_rx, musb->mregs + SUNXI_MUSB_INTRRX);\n\n\tmusb_interrupt(musb);\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sunxi_musb_host_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *ptr)\n{\n\tstruct sunxi_glue *glue = container_of(nb, struct sunxi_glue, host_nb);\n\n\tif (event)\n\t\tset_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags);\n\telse\n\t\tclear_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags);\n\n\tset_bit(SUNXI_MUSB_FL_HOSTMODE_PEND, &glue->flags);\n\tschedule_work(&glue->work);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int sunxi_musb_init(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tint ret;\n\n\tsunxi_musb = musb;\n\tmusb->phy = glue->phy;\n\tmusb->xceiv = glue->xceiv;\n\n\tif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags)) {\n\t\tret = sunxi_sram_claim(musb->controller->parent);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(glue->clk);\n\tif (ret)\n\t\tgoto error_sram_release;\n\n\tif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags)) {\n\t\tret = reset_control_deassert(glue->rst);\n\t\tif (ret)\n\t\t\tgoto error_clk_disable;\n\t}\n\n\twriteb(SUNXI_MUSB_VEND0_PIO_MODE, musb->mregs + SUNXI_MUSB_VEND0);\n\n\t \n\tret = devm_extcon_register_notifier(glue->dev, glue->extcon,\n\t\t\t\t\tEXTCON_USB_HOST, &glue->host_nb);\n\tif (ret)\n\t\tgoto error_reset_assert;\n\n\tret = phy_init(glue->phy);\n\tif (ret)\n\t\tgoto error_reset_assert;\n\n\tmusb->isr = sunxi_musb_interrupt;\n\n\t \n\tpm_runtime_get(musb->controller);\n\n\treturn 0;\n\nerror_reset_assert:\n\tif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags))\n\t\treset_control_assert(glue->rst);\nerror_clk_disable:\n\tclk_disable_unprepare(glue->clk);\nerror_sram_release:\n\tif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags))\n\t\tsunxi_sram_release(musb->controller->parent);\n\treturn ret;\n}\n\nstatic int sunxi_musb_exit(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tpm_runtime_put(musb->controller);\n\n\tcancel_work_sync(&glue->work);\n\tif (test_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags))\n\t\tphy_power_off(glue->phy);\n\n\tphy_exit(glue->phy);\n\n\tif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags))\n\t\treset_control_assert(glue->rst);\n\n\tclk_disable_unprepare(glue->clk);\n\tif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags))\n\t\tsunxi_sram_release(musb->controller->parent);\n\n\tdevm_usb_put_phy(glue->dev, glue->xceiv);\n\n\treturn 0;\n}\n\nstatic void sunxi_musb_enable(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tglue->musb = musb;\n\n\t \n\tif (test_and_set_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags))\n\t\treturn;\n\n\tschedule_work(&glue->work);\n}\n\nstatic void sunxi_musb_disable(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\tclear_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags);\n}\n\nstatic struct dma_controller *\nsunxi_musb_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\treturn NULL;\n}\n\nstatic void sunxi_musb_dma_controller_destroy(struct dma_controller *c)\n{\n}\n\nstatic int sunxi_musb_set_mode(struct musb *musb, u8 mode)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tenum phy_mode new_mode;\n\n\tswitch (mode) {\n\tcase MUSB_HOST:\n\t\tnew_mode = PHY_MODE_USB_HOST;\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\n\t\tnew_mode = PHY_MODE_USB_DEVICE;\n\t\tbreak;\n\tcase MUSB_OTG:\n\t\tnew_mode = PHY_MODE_USB_OTG;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(musb->controller->parent,\n\t\t\t\"Error requested mode not supported by this kernel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (glue->phy_mode == new_mode)\n\t\treturn 0;\n\n\tif (musb->port_mode != MUSB_OTG) {\n\t\tdev_err(musb->controller->parent,\n\t\t\t\"Error changing modes is only supported in dual role mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (musb->port1_status & USB_PORT_STAT_ENABLE)\n\t\tmusb_root_disconnect(musb);\n\n\t \n\tglue->phy_mode = new_mode;\n\tset_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags);\n\tschedule_work(&glue->work);\n\n\treturn 0;\n}\n\nstatic int sunxi_musb_recover(struct musb *musb)\n{\n\tstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\n\n\t \n\tset_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags);\n\tschedule_work(&glue->work);\n\n\treturn 0;\n}\n\n \n\nstatic u32 sunxi_musb_fifo_offset(u8 epnum)\n{\n\treturn (epnum * 4);\n}\n\nstatic u32 sunxi_musb_ep_offset(u8 epnum, u16 offset)\n{\n\tWARN_ONCE(offset != 0,\n\t\t  \"sunxi_musb_ep_offset called with non 0 offset\\n\");\n\n\treturn 0x80;  \n}\n\nstatic u32 sunxi_musb_busctl_offset(u8 epnum, u16 offset)\n{\n\treturn SUNXI_MUSB_TXFUNCADDR + offset;\n}\n\nstatic u8 sunxi_musb_readb(void __iomem *addr, u32 offset)\n{\n\tstruct sunxi_glue *glue;\n\n\tif (addr == sunxi_musb->mregs) {\n\t\t \n\t\tswitch (offset) {\n\t\tcase MUSB_FADDR:\n\t\t\treturn readb(addr + SUNXI_MUSB_FADDR);\n\t\tcase MUSB_POWER:\n\t\t\treturn readb(addr + SUNXI_MUSB_POWER);\n\t\tcase MUSB_INTRUSB:\n\t\t\treturn readb(addr + SUNXI_MUSB_INTRUSB);\n\t\tcase MUSB_INTRUSBE:\n\t\t\treturn readb(addr + SUNXI_MUSB_INTRUSBE);\n\t\tcase MUSB_INDEX:\n\t\t\treturn readb(addr + SUNXI_MUSB_INDEX);\n\t\tcase MUSB_TESTMODE:\n\t\t\treturn 0;  \n\t\tcase MUSB_DEVCTL:\n\t\t\treturn readb(addr + SUNXI_MUSB_DEVCTL);\n\t\tcase MUSB_TXFIFOSZ:\n\t\t\treturn readb(addr + SUNXI_MUSB_TXFIFOSZ);\n\t\tcase MUSB_RXFIFOSZ:\n\t\t\treturn readb(addr + SUNXI_MUSB_RXFIFOSZ);\n\t\tcase MUSB_CONFIGDATA + 0x10:  \n\t\t\tglue = dev_get_drvdata(sunxi_musb->controller->parent);\n\t\t\t \n\t\t\tif (test_bit(SUNXI_MUSB_FL_NO_CONFIGDATA,\n\t\t\t\t     &glue->flags))\n\t\t\t\treturn 0xde;\n\n\t\t\treturn readb(addr + SUNXI_MUSB_CONFIGDATA);\n\t\tcase MUSB_ULPI_BUSCONTROL:\n\t\t\tdev_warn(sunxi_musb->controller->parent,\n\t\t\t\t\"sunxi-musb does not have ULPI bus control register\\n\");\n\t\t\treturn 0;\n\t\t \n\t\tcase SUNXI_MUSB_TXFUNCADDR:\n\t\tcase SUNXI_MUSB_TXHUBADDR:\n\t\tcase SUNXI_MUSB_TXHUBPORT:\n\t\tcase SUNXI_MUSB_RXFUNCADDR:\n\t\tcase SUNXI_MUSB_RXHUBADDR:\n\t\tcase SUNXI_MUSB_RXHUBPORT:\n\t\t\t \n\t\t\treturn readb(addr + offset);\n\t\tdefault:\n\t\t\tdev_err(sunxi_musb->controller->parent,\n\t\t\t\t\"Error unknown readb offset %u\\n\", offset);\n\t\t\treturn 0;\n\t\t}\n\t} else if (addr == (sunxi_musb->mregs + 0x80)) {\n\t\t \n\t\t \n\t\tif (offset >= MUSB_TXTYPE)\n\t\t\toffset += 2;\n\t\treturn readb(addr + offset);\n\t}\n\n\tdev_err(sunxi_musb->controller->parent,\n\t\t\"Error unknown readb at 0x%x bytes offset\\n\",\n\t\t(int)(addr - sunxi_musb->mregs));\n\treturn 0;\n}\n\nstatic void sunxi_musb_writeb(void __iomem *addr, unsigned offset, u8 data)\n{\n\tif (addr == sunxi_musb->mregs) {\n\t\t \n\t\tswitch (offset) {\n\t\tcase MUSB_FADDR:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_FADDR);\n\t\tcase MUSB_POWER:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_POWER);\n\t\tcase MUSB_INTRUSB:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_INTRUSB);\n\t\tcase MUSB_INTRUSBE:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_INTRUSBE);\n\t\tcase MUSB_INDEX:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_INDEX);\n\t\tcase MUSB_TESTMODE:\n\t\t\tif (data)\n\t\t\t\tdev_warn(sunxi_musb->controller->parent,\n\t\t\t\t\t\"sunxi-musb does not have testmode\\n\");\n\t\t\treturn;\n\t\tcase MUSB_DEVCTL:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_DEVCTL);\n\t\tcase MUSB_TXFIFOSZ:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_TXFIFOSZ);\n\t\tcase MUSB_RXFIFOSZ:\n\t\t\treturn writeb(data, addr + SUNXI_MUSB_RXFIFOSZ);\n\t\tcase MUSB_ULPI_BUSCONTROL:\n\t\t\tdev_warn(sunxi_musb->controller->parent,\n\t\t\t\t\"sunxi-musb does not have ULPI bus control register\\n\");\n\t\t\treturn;\n\t\t \n\t\tcase SUNXI_MUSB_TXFUNCADDR:\n\t\tcase SUNXI_MUSB_TXHUBADDR:\n\t\tcase SUNXI_MUSB_TXHUBPORT:\n\t\tcase SUNXI_MUSB_RXFUNCADDR:\n\t\tcase SUNXI_MUSB_RXHUBADDR:\n\t\tcase SUNXI_MUSB_RXHUBPORT:\n\t\t\t \n\t\t\treturn writeb(data, addr + offset);\n\t\tdefault:\n\t\t\tdev_err(sunxi_musb->controller->parent,\n\t\t\t\t\"Error unknown writeb offset %u\\n\", offset);\n\t\t\treturn;\n\t\t}\n\t} else if (addr == (sunxi_musb->mregs + 0x80)) {\n\t\t \n\t\tif (offset >= MUSB_TXTYPE)\n\t\t\toffset += 2;\n\t\treturn writeb(data, addr + offset);\n\t}\n\n\tdev_err(sunxi_musb->controller->parent,\n\t\t\"Error unknown writeb at 0x%x bytes offset\\n\",\n\t\t(int)(addr - sunxi_musb->mregs));\n}\n\nstatic u16 sunxi_musb_readw(void __iomem *addr, u32 offset)\n{\n\tif (addr == sunxi_musb->mregs) {\n\t\t \n\t\tswitch (offset) {\n\t\tcase MUSB_INTRTX:\n\t\t\treturn readw(addr + SUNXI_MUSB_INTRTX);\n\t\tcase MUSB_INTRRX:\n\t\t\treturn readw(addr + SUNXI_MUSB_INTRRX);\n\t\tcase MUSB_INTRTXE:\n\t\t\treturn readw(addr + SUNXI_MUSB_INTRTXE);\n\t\tcase MUSB_INTRRXE:\n\t\t\treturn readw(addr + SUNXI_MUSB_INTRRXE);\n\t\tcase MUSB_FRAME:\n\t\t\treturn readw(addr + SUNXI_MUSB_FRAME);\n\t\tcase MUSB_TXFIFOADD:\n\t\t\treturn readw(addr + SUNXI_MUSB_TXFIFOADD);\n\t\tcase MUSB_RXFIFOADD:\n\t\t\treturn readw(addr + SUNXI_MUSB_RXFIFOADD);\n\t\tcase MUSB_HWVERS:\n\t\t\treturn 0;  \n\t\tdefault:\n\t\t\tdev_err(sunxi_musb->controller->parent,\n\t\t\t\t\"Error unknown readw offset %u\\n\", offset);\n\t\t\treturn 0;\n\t\t}\n\t} else if (addr == (sunxi_musb->mregs + 0x80)) {\n\t\t \n\t\treturn readw(addr + offset);\n\t}\n\n\tdev_err(sunxi_musb->controller->parent,\n\t\t\"Error unknown readw at 0x%x bytes offset\\n\",\n\t\t(int)(addr - sunxi_musb->mregs));\n\treturn 0;\n}\n\nstatic void sunxi_musb_writew(void __iomem *addr, unsigned offset, u16 data)\n{\n\tif (addr == sunxi_musb->mregs) {\n\t\t \n\t\tswitch (offset) {\n\t\tcase MUSB_INTRTX:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_INTRTX);\n\t\tcase MUSB_INTRRX:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_INTRRX);\n\t\tcase MUSB_INTRTXE:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_INTRTXE);\n\t\tcase MUSB_INTRRXE:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_INTRRXE);\n\t\tcase MUSB_FRAME:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_FRAME);\n\t\tcase MUSB_TXFIFOADD:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_TXFIFOADD);\n\t\tcase MUSB_RXFIFOADD:\n\t\t\treturn writew(data, addr + SUNXI_MUSB_RXFIFOADD);\n\t\tdefault:\n\t\t\tdev_err(sunxi_musb->controller->parent,\n\t\t\t\t\"Error unknown writew offset %u\\n\", offset);\n\t\t\treturn;\n\t\t}\n\t} else if (addr == (sunxi_musb->mregs + 0x80)) {\n\t\t \n\t\treturn writew(data, addr + offset);\n\t}\n\n\tdev_err(sunxi_musb->controller->parent,\n\t\t\"Error unknown writew at 0x%x bytes offset\\n\",\n\t\t(int)(addr - sunxi_musb->mregs));\n}\n\nstatic const struct musb_platform_ops sunxi_musb_ops = {\n\t.quirks\t\t= MUSB_INDEXED_EP,\n\t.init\t\t= sunxi_musb_init,\n\t.exit\t\t= sunxi_musb_exit,\n\t.enable\t\t= sunxi_musb_enable,\n\t.disable\t= sunxi_musb_disable,\n\t.fifo_offset\t= sunxi_musb_fifo_offset,\n\t.ep_offset\t= sunxi_musb_ep_offset,\n\t.busctl_offset\t= sunxi_musb_busctl_offset,\n\t.readb\t\t= sunxi_musb_readb,\n\t.writeb\t\t= sunxi_musb_writeb,\n\t.readw\t\t= sunxi_musb_readw,\n\t.writew\t\t= sunxi_musb_writew,\n\t.dma_init\t= sunxi_musb_dma_controller_create,\n\t.dma_exit\t= sunxi_musb_dma_controller_destroy,\n\t.set_mode\t= sunxi_musb_set_mode,\n\t.recover\t= sunxi_musb_recover,\n\t.set_vbus\t= sunxi_musb_set_vbus,\n\t.pre_root_reset_end = sunxi_musb_pre_root_reset_end,\n\t.post_root_reset_end = sunxi_musb_post_root_reset_end,\n};\n\n#define SUNXI_MUSB_RAM_BITS\t11\n\n \nstatic struct musb_fifo_cfg sunxi_musb_mode_cfg_5eps[] = {\n\tMUSB_EP_FIFO_SINGLE(1, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(1, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(2, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(2, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(3, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(3, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(4, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(4, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(5, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(5, FIFO_RX, 512),\n};\n\n \nstatic struct musb_fifo_cfg sunxi_musb_mode_cfg_4eps[] = {\n\tMUSB_EP_FIFO_SINGLE(1, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(1, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(2, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(2, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(3, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(3, FIFO_RX, 512),\n\tMUSB_EP_FIFO_SINGLE(4, FIFO_TX, 512),\n\tMUSB_EP_FIFO_SINGLE(4, FIFO_RX, 512),\n};\n\nstatic const struct musb_hdrc_config sunxi_musb_hdrc_config_5eps = {\n\t.fifo_cfg       = sunxi_musb_mode_cfg_5eps,\n\t.fifo_cfg_size  = ARRAY_SIZE(sunxi_musb_mode_cfg_5eps),\n\t.multipoint\t= true,\n\t.dyn_fifo\t= true,\n\t \n\t.num_eps\t= (ARRAY_SIZE(sunxi_musb_mode_cfg_5eps) / 2) + 1,\n\t.ram_bits\t= SUNXI_MUSB_RAM_BITS,\n};\n\nstatic const struct musb_hdrc_config sunxi_musb_hdrc_config_4eps = {\n\t.fifo_cfg       = sunxi_musb_mode_cfg_4eps,\n\t.fifo_cfg_size  = ARRAY_SIZE(sunxi_musb_mode_cfg_4eps),\n\t.multipoint\t= true,\n\t.dyn_fifo\t= true,\n\t \n\t.num_eps\t= (ARRAY_SIZE(sunxi_musb_mode_cfg_4eps) / 2) + 1,\n\t.ram_bits\t= SUNXI_MUSB_RAM_BITS,\n};\n\nstatic int sunxi_musb_probe(struct platform_device *pdev)\n{\n\tstruct musb_hdrc_platform_data\tpdata;\n\tstruct platform_device_info\tpinfo;\n\tstruct sunxi_glue\t\t*glue;\n\tstruct device_node\t\t*np = pdev->dev.of_node;\n\tconst struct sunxi_musb_cfg\t*cfg;\n\tint ret;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Error no device tree node found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tswitch (usb_get_dr_mode(&pdev->dev)) {\n#if defined CONFIG_USB_MUSB_DUAL_ROLE || defined CONFIG_USB_MUSB_HOST\n\tcase USB_DR_MODE_HOST:\n\t\tpdata.mode = MUSB_HOST;\n\t\tglue->phy_mode = PHY_MODE_USB_HOST;\n\t\tbreak;\n#endif\n#if defined CONFIG_USB_MUSB_DUAL_ROLE || defined CONFIG_USB_MUSB_GADGET\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tpdata.mode = MUSB_PERIPHERAL;\n\t\tglue->phy_mode = PHY_MODE_USB_DEVICE;\n\t\tbreak;\n#endif\n#ifdef CONFIG_USB_MUSB_DUAL_ROLE\n\tcase USB_DR_MODE_OTG:\n\t\tpdata.mode = MUSB_OTG;\n\t\tglue->phy_mode = PHY_MODE_USB_OTG;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Invalid or missing 'dr_mode' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpdata.platform_ops\t= &sunxi_musb_ops;\n\n\tcfg = of_device_get_match_data(&pdev->dev);\n\tif (!cfg)\n\t\treturn -EINVAL;\n\n\tpdata.config = cfg->hdrc_config;\n\n\tglue->dev = &pdev->dev;\n\tINIT_WORK(&glue->work, sunxi_musb_work);\n\tglue->host_nb.notifier_call = sunxi_musb_host_notifier;\n\n\tif (cfg->has_sram)\n\t\tset_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags);\n\n\tif (cfg->has_reset)\n\t\tset_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags);\n\n\tif (cfg->no_configdata)\n\t\tset_bit(SUNXI_MUSB_FL_NO_CONFIGDATA, &glue->flags);\n\n\tglue->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(glue->clk)) {\n\t\tdev_err(&pdev->dev, \"Error getting clock: %ld\\n\",\n\t\t\tPTR_ERR(glue->clk));\n\t\treturn PTR_ERR(glue->clk);\n\t}\n\n\tif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags)) {\n\t\tglue->rst = devm_reset_control_get(&pdev->dev, NULL);\n\t\tif (IS_ERR(glue->rst))\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(glue->rst),\n\t\t\t\t\t     \"Error getting reset\\n\");\n\t}\n\n\tglue->extcon = extcon_get_edev_by_phandle(&pdev->dev, 0);\n\tif (IS_ERR(glue->extcon))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(glue->extcon),\n\t\t\t\t     \"Invalid or missing extcon\\n\");\n\n\tglue->phy = devm_phy_get(&pdev->dev, \"usb\");\n\tif (IS_ERR(glue->phy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(glue->phy),\n\t\t\t\t     \"Error getting phy\\n\");\n\n\tglue->usb_phy = usb_phy_generic_register();\n\tif (IS_ERR(glue->usb_phy)) {\n\t\tdev_err(&pdev->dev, \"Error registering usb-phy %ld\\n\",\n\t\t\tPTR_ERR(glue->usb_phy));\n\t\treturn PTR_ERR(glue->usb_phy);\n\t}\n\n\tglue->xceiv = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\n\tif (IS_ERR(glue->xceiv)) {\n\t\tret = PTR_ERR(glue->xceiv);\n\t\tdev_err(&pdev->dev, \"Error getting usb-phy %d\\n\", ret);\n\t\tgoto err_unregister_usb_phy;\n\t}\n\n\tplatform_set_drvdata(pdev, glue);\n\n\tmemset(&pinfo, 0, sizeof(pinfo));\n\tpinfo.name\t = \"musb-hdrc\";\n\tpinfo.id\t= PLATFORM_DEVID_AUTO;\n\tpinfo.parent\t= &pdev->dev;\n\tpinfo.fwnode\t= of_fwnode_handle(pdev->dev.of_node);\n\tpinfo.of_node_reused = true;\n\tpinfo.res\t= pdev->resource;\n\tpinfo.num_res\t= pdev->num_resources;\n\tpinfo.data\t= &pdata;\n\tpinfo.size_data = sizeof(pdata);\n\n\tglue->musb_pdev = platform_device_register_full(&pinfo);\n\tif (IS_ERR(glue->musb_pdev)) {\n\t\tret = PTR_ERR(glue->musb_pdev);\n\t\tdev_err(&pdev->dev, \"Error registering musb dev: %d\\n\", ret);\n\t\tgoto err_unregister_usb_phy;\n\t}\n\n\treturn 0;\n\nerr_unregister_usb_phy:\n\tusb_phy_generic_unregister(glue->usb_phy);\n\treturn ret;\n}\n\nstatic void sunxi_musb_remove(struct platform_device *pdev)\n{\n\tstruct sunxi_glue *glue = platform_get_drvdata(pdev);\n\tstruct platform_device *usb_phy = glue->usb_phy;\n\n\tplatform_device_unregister(glue->musb_pdev);\n\tusb_phy_generic_unregister(usb_phy);\n}\n\nstatic const struct sunxi_musb_cfg sun4i_a10_musb_cfg = {\n\t.hdrc_config = &sunxi_musb_hdrc_config_5eps,\n\t.has_sram = true,\n};\n\nstatic const struct sunxi_musb_cfg sun6i_a31_musb_cfg = {\n\t.hdrc_config = &sunxi_musb_hdrc_config_5eps,\n\t.has_reset = true,\n};\n\nstatic const struct sunxi_musb_cfg sun8i_a33_musb_cfg = {\n\t.hdrc_config = &sunxi_musb_hdrc_config_5eps,\n\t.has_reset = true,\n\t.no_configdata = true,\n};\n\nstatic const struct sunxi_musb_cfg sun8i_h3_musb_cfg = {\n\t.hdrc_config = &sunxi_musb_hdrc_config_4eps,\n\t.has_reset = true,\n\t.no_configdata = true,\n};\n\nstatic const struct sunxi_musb_cfg suniv_f1c100s_musb_cfg = {\n\t.hdrc_config = &sunxi_musb_hdrc_config_5eps,\n\t.has_sram = true,\n\t.has_reset = true,\n\t.no_configdata = true,\n};\n\nstatic const struct of_device_id sunxi_musb_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-musb\",\n\t  .data = &sun4i_a10_musb_cfg, },\n\t{ .compatible = \"allwinner,sun6i-a31-musb\",\n\t  .data = &sun6i_a31_musb_cfg, },\n\t{ .compatible = \"allwinner,sun8i-a33-musb\",\n\t  .data = &sun8i_a33_musb_cfg, },\n\t{ .compatible = \"allwinner,sun8i-h3-musb\",\n\t  .data = &sun8i_h3_musb_cfg, },\n\t{ .compatible = \"allwinner,suniv-f1c100s-musb\",\n\t  .data = &suniv_f1c100s_musb_cfg, },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sunxi_musb_match);\n\nstatic struct platform_driver sunxi_musb_driver = {\n\t.probe = sunxi_musb_probe,\n\t.remove_new = sunxi_musb_remove,\n\t.driver = {\n\t\t.name = \"musb-sunxi\",\n\t\t.of_match_table = sunxi_musb_match,\n\t},\n};\nmodule_platform_driver(sunxi_musb_driver);\n\nMODULE_DESCRIPTION(\"Allwinner sunxi MUSB Glue Layer\");\nMODULE_AUTHOR(\"Hans de Goede <hdegoede@redhat.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}