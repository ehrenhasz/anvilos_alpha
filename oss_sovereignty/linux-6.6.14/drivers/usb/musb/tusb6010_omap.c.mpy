{
  "module_name": "tusb6010_omap.c",
  "hash_id": "432520cd9c8db45e585264231996114f6c238c0a4307dc1387307aa11be037fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/tusb6010_omap.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/usb.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/dmaengine.h>\n\n#include \"musb_core.h\"\n#include \"tusb6010.h\"\n\n#define to_chdat(c)\t\t((struct tusb_omap_dma_ch *)(c)->private_data)\n\n#define MAX_DMAREQ\t\t5\t \n\nstruct tusb_dma_data {\n\ts8\t\t\tdmareq;\n\tstruct dma_chan\t\t*chan;\n};\n\nstruct tusb_omap_dma_ch {\n\tstruct musb\t\t*musb;\n\tvoid __iomem\t\t*tbase;\n\tunsigned long\t\tphys_offset;\n\tint\t\t\tepnum;\n\tu8\t\t\ttx;\n\tstruct musb_hw_ep\t*hw_ep;\n\n\tstruct tusb_dma_data\t*dma_data;\n\n\tstruct tusb_omap_dma\t*tusb_dma;\n\n\tdma_addr_t\t\tdma_addr;\n\n\tu32\t\t\tlen;\n\tu16\t\t\tpacket_sz;\n\tu16\t\t\ttransfer_packet_sz;\n\tu32\t\t\ttransfer_len;\n\tu32\t\t\tcompleted_len;\n};\n\nstruct tusb_omap_dma {\n\tstruct dma_controller\t\tcontroller;\n\tvoid __iomem\t\t\t*tbase;\n\n\tstruct tusb_dma_data\t\tdma_pool[MAX_DMAREQ];\n\tunsigned\t\t\tmultichannel:1;\n};\n\n \nstatic inline int tusb_omap_use_shared_dmareq(struct tusb_omap_dma_ch *chdat)\n{\n\tu32\t\treg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\n\n\tif (reg != 0) {\n\t\tdev_dbg(chdat->musb->controller, \"ep%i dmareq0 is busy for ep%i\\n\",\n\t\t\tchdat->epnum, reg & 0xf);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (chdat->tx)\n\t\treg = (1 << 4) | chdat->epnum;\n\telse\n\t\treg = chdat->epnum;\n\n\tmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\n\n\treturn 0;\n}\n\nstatic inline void tusb_omap_free_shared_dmareq(struct tusb_omap_dma_ch *chdat)\n{\n\tu32\t\treg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\n\n\tif ((reg & 0xf) != chdat->epnum) {\n\t\tprintk(KERN_ERR \"ep%i trying to release dmareq0 for ep%i\\n\",\n\t\t\tchdat->epnum, reg & 0xf);\n\t\treturn;\n\t}\n\tmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, 0);\n}\n\n \nstatic void tusb_omap_dma_cb(void *data)\n{\n\tstruct dma_channel\t*channel = (struct dma_channel *)data;\n\tstruct tusb_omap_dma_ch\t*chdat = to_chdat(channel);\n\tstruct tusb_omap_dma\t*tusb_dma = chdat->tusb_dma;\n\tstruct musb\t\t*musb = chdat->musb;\n\tstruct device\t\t*dev = musb->controller;\n\tstruct musb_hw_ep\t*hw_ep = chdat->hw_ep;\n\tvoid __iomem\t\t*ep_conf = hw_ep->conf;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tunsigned long\t\tremaining, flags, pio;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tdev_dbg(musb->controller, \"ep%i %s dma callback\\n\",\n\t\tchdat->epnum, chdat->tx ? \"tx\" : \"rx\");\n\n\tif (chdat->tx)\n\t\tremaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\n\telse\n\t\tremaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\n\n\tremaining = TUSB_EP_CONFIG_XFR_SIZE(remaining);\n\n\t \n\tif (unlikely(remaining > chdat->transfer_len)) {\n\t\tdev_dbg(musb->controller, \"Corrupt %s XFR_SIZE: 0x%08lx\\n\",\n\t\t\tchdat->tx ? \"tx\" : \"rx\", remaining);\n\t\tremaining = 0;\n\t}\n\n\tchannel->actual_len = chdat->transfer_len - remaining;\n\tpio = chdat->len - channel->actual_len;\n\n\tdev_dbg(musb->controller, \"DMA remaining %lu/%u\\n\", remaining, chdat->transfer_len);\n\n\t \n\tif (pio > 0 && pio < 32) {\n\t\tu8\t*buf;\n\n\t\tdev_dbg(musb->controller, \"Using PIO for remaining %lu bytes\\n\", pio);\n\t\tbuf = phys_to_virt((u32)chdat->dma_addr) + chdat->transfer_len;\n\t\tif (chdat->tx) {\n\t\t\tdma_unmap_single(dev, chdat->dma_addr,\n\t\t\t\t\t\tchdat->transfer_len,\n\t\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tmusb_write_fifo(hw_ep, pio, buf);\n\t\t} else {\n\t\t\tdma_unmap_single(dev, chdat->dma_addr,\n\t\t\t\t\t\tchdat->transfer_len,\n\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\tmusb_read_fifo(hw_ep, pio, buf);\n\t\t}\n\t\tchannel->actual_len += pio;\n\t}\n\n\tif (!tusb_dma->multichannel)\n\t\ttusb_omap_free_shared_dmareq(chdat);\n\n\tchannel->status = MUSB_DMA_STATUS_FREE;\n\n\tmusb_dma_completion(musb, chdat->epnum, chdat->tx);\n\n\t \n\tif ((chdat->transfer_len < chdat->packet_sz)\n\t\t\t|| (chdat->transfer_len % chdat->packet_sz != 0)) {\n\t\tu16\tcsr;\n\n\t\tif (chdat->tx) {\n\t\t\tdev_dbg(musb->controller, \"terminating short tx packet\\n\");\n\t\t\tmusb_ep_select(mbase, chdat->epnum);\n\t\t\tcsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\n\t\t\tcsr |= MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY\n\t\t\t\t| MUSB_TXCSR_P_WZC_BITS;\n\t\t\tmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nstatic int tusb_omap_dma_program(struct dma_channel *channel, u16 packet_sz,\n\t\t\t\tu8 rndis_mode, dma_addr_t dma_addr, u32 len)\n{\n\tstruct tusb_omap_dma_ch\t\t*chdat = to_chdat(channel);\n\tstruct tusb_omap_dma\t\t*tusb_dma = chdat->tusb_dma;\n\tstruct musb\t\t\t*musb = chdat->musb;\n\tstruct device\t\t\t*dev = musb->controller;\n\tstruct musb_hw_ep\t\t*hw_ep = chdat->hw_ep;\n\tvoid __iomem\t\t\t*mbase = musb->mregs;\n\tvoid __iomem\t\t\t*ep_conf = hw_ep->conf;\n\tdma_addr_t\t\t\tfifo_addr = hw_ep->fifo_sync;\n\tu32\t\t\t\tdma_remaining;\n\tu16\t\t\t\tcsr;\n\tu32\t\t\t\tpsize;\n\tstruct tusb_dma_data\t\t*dma_data;\n\tstruct dma_async_tx_descriptor\t*dma_desc;\n\tstruct dma_slave_config\t\tdma_cfg;\n\tenum dma_transfer_direction\tdma_dir;\n\tu32\t\t\t\tport_window;\n\tint\t\t\t\tret;\n\n\tif (unlikely(dma_addr & 0x1) || (len < 32) || (len > packet_sz))\n\t\treturn false;\n\n\t \n\tif (dma_addr & 0x2)\n\t\treturn false;\n\n\t \n\tif (chdat->tx)\n\t\tdma_remaining = musb_readl(ep_conf, TUSB_EP_TX_OFFSET);\n\telse\n\t\tdma_remaining = musb_readl(ep_conf, TUSB_EP_RX_OFFSET);\n\n\tdma_remaining = TUSB_EP_CONFIG_XFR_SIZE(dma_remaining);\n\tif (dma_remaining) {\n\t\tdev_dbg(musb->controller, \"Busy %s dma, not using: %08x\\n\",\n\t\t\tchdat->tx ? \"tx\" : \"rx\", dma_remaining);\n\t\treturn false;\n\t}\n\n\tchdat->transfer_len = len & ~0x1f;\n\n\tif (len < packet_sz)\n\t\tchdat->transfer_packet_sz = chdat->transfer_len;\n\telse\n\t\tchdat->transfer_packet_sz = packet_sz;\n\n\tdma_data = chdat->dma_data;\n\tif (!tusb_dma->multichannel) {\n\t\tif (tusb_omap_use_shared_dmareq(chdat) != 0) {\n\t\t\tdev_dbg(musb->controller, \"could not get dma for ep%i\\n\", chdat->epnum);\n\t\t\treturn false;\n\t\t}\n\t\tif (dma_data->dmareq < 0) {\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tchdat->packet_sz = packet_sz;\n\tchdat->len = len;\n\tchannel->actual_len = 0;\n\tchdat->dma_addr = dma_addr;\n\tchannel->status = MUSB_DMA_STATUS_BUSY;\n\n\t \n\tif (chdat->tx) {\n\t\tdma_dir = DMA_MEM_TO_DEV;\n\t\tdma_map_single(dev, phys_to_virt(dma_addr), len,\n\t\t\t\tDMA_TO_DEVICE);\n\t} else {\n\t\tdma_dir = DMA_DEV_TO_MEM;\n\t\tdma_map_single(dev, phys_to_virt(dma_addr), len,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tmemset(&dma_cfg, 0, sizeof(dma_cfg));\n\n\t \n\tif ((dma_addr & 0x3) == 0) {\n\t\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tdma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tport_window = 8;\n\t} else {\n\t\tdma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tdma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tport_window = 16;\n\n\t\tfifo_addr = hw_ep->fifo_async;\n\t}\n\n\tdev_dbg(musb->controller,\n\t\t\"ep%i %s dma: %pad len: %u(%u) packet_sz: %i(%i)\\n\",\n\t\tchdat->epnum, chdat->tx ? \"tx\" : \"rx\", &dma_addr,\n\t\tchdat->transfer_len, len, chdat->transfer_packet_sz, packet_sz);\n\n\tdma_cfg.src_addr = fifo_addr;\n\tdma_cfg.dst_addr = fifo_addr;\n\tdma_cfg.src_port_window_size = port_window;\n\tdma_cfg.src_maxburst = port_window;\n\tdma_cfg.dst_port_window_size = port_window;\n\tdma_cfg.dst_maxburst = port_window;\n\n\tret = dmaengine_slave_config(dma_data->chan, &dma_cfg);\n\tif (ret) {\n\t\tdev_err(musb->controller, \"DMA slave config failed: %d\\n\", ret);\n\t\treturn false;\n\t}\n\n\tdma_desc = dmaengine_prep_slave_single(dma_data->chan, dma_addr,\n\t\t\t\t\tchdat->transfer_len, dma_dir,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!dma_desc) {\n\t\tdev_err(musb->controller, \"DMA prep_slave_single failed\\n\");\n\t\treturn false;\n\t}\n\n\tdma_desc->callback = tusb_omap_dma_cb;\n\tdma_desc->callback_param = channel;\n\tdmaengine_submit(dma_desc);\n\n\tdev_dbg(musb->controller,\n\t\t\"ep%i %s using %i-bit %s dma from %pad to %pad\\n\",\n\t\tchdat->epnum, chdat->tx ? \"tx\" : \"rx\",\n\t\tdma_cfg.src_addr_width * 8,\n\t\t((dma_addr & 0x3) == 0) ? \"sync\" : \"async\",\n\t\t(dma_dir == DMA_MEM_TO_DEV) ? &dma_addr : &fifo_addr,\n\t\t(dma_dir == DMA_MEM_TO_DEV) ? &fifo_addr : &dma_addr);\n\n\t \n\tmusb_ep_select(mbase, chdat->epnum);\n\tif (chdat->tx) {\n\t\tcsr = musb_readw(hw_ep->regs, MUSB_TXCSR);\n\t\tcsr |= (MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB\n\t\t\t| MUSB_TXCSR_DMAMODE | MUSB_TXCSR_MODE);\n\t\tcsr &= ~MUSB_TXCSR_P_UNDERRUN;\n\t\tmusb_writew(hw_ep->regs, MUSB_TXCSR, csr);\n\t} else {\n\t\tcsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\n\t\tcsr |= MUSB_RXCSR_DMAENAB;\n\t\tcsr &= ~(MUSB_RXCSR_AUTOCLEAR | MUSB_RXCSR_DMAMODE);\n\t\tmusb_writew(hw_ep->regs, MUSB_RXCSR,\n\t\t\tcsr | MUSB_RXCSR_P_WZC_BITS);\n\t}\n\n\t \n\tdma_async_issue_pending(dma_data->chan);\n\n\tif (chdat->tx) {\n\t\t \n\t\tpsize = musb_readl(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET);\n\t\tpsize &= ~0x7ff;\n\t\tpsize |= chdat->transfer_packet_sz;\n\t\tmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET, psize);\n\n\t\tmusb_writel(ep_conf, TUSB_EP_TX_OFFSET,\n\t\t\tTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\n\t} else {\n\t\t \n\t\tpsize = musb_readl(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET);\n\t\tpsize &= ~(0x7ff << 16);\n\t\tpsize |= (chdat->transfer_packet_sz << 16);\n\t\tmusb_writel(ep_conf, TUSB_EP_MAX_PACKET_SIZE_OFFSET, psize);\n\n\t\tmusb_writel(ep_conf, TUSB_EP_RX_OFFSET,\n\t\t\tTUSB_EP_CONFIG_XFR_SIZE(chdat->transfer_len));\n\t}\n\n\treturn true;\n}\n\nstatic int tusb_omap_dma_abort(struct dma_channel *channel)\n{\n\tstruct tusb_omap_dma_ch\t*chdat = to_chdat(channel);\n\n\tif (chdat->dma_data)\n\t\tdmaengine_terminate_all(chdat->dma_data->chan);\n\n\tchannel->status = MUSB_DMA_STATUS_FREE;\n\n\treturn 0;\n}\n\nstatic inline int tusb_omap_dma_allocate_dmareq(struct tusb_omap_dma_ch *chdat)\n{\n\tu32\t\treg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\n\tint\t\ti, dmareq_nr = -1;\n\n\tfor (i = 0; i < MAX_DMAREQ; i++) {\n\t\tint cur = (reg & (0xf << (i * 5))) >> (i * 5);\n\t\tif (cur == 0) {\n\t\t\tdmareq_nr = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dmareq_nr == -1)\n\t\treturn -EAGAIN;\n\n\treg |= (chdat->epnum << (dmareq_nr * 5));\n\tif (chdat->tx)\n\t\treg |= ((1 << 4) << (dmareq_nr * 5));\n\tmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\n\n\tchdat->dma_data = &chdat->tusb_dma->dma_pool[dmareq_nr];\n\n\treturn 0;\n}\n\nstatic inline void tusb_omap_dma_free_dmareq(struct tusb_omap_dma_ch *chdat)\n{\n\tu32 reg;\n\n\tif (!chdat || !chdat->dma_data || chdat->dma_data->dmareq < 0)\n\t\treturn;\n\n\treg = musb_readl(chdat->tbase, TUSB_DMA_EP_MAP);\n\treg &= ~(0x1f << (chdat->dma_data->dmareq * 5));\n\tmusb_writel(chdat->tbase, TUSB_DMA_EP_MAP, reg);\n\n\tchdat->dma_data = NULL;\n}\n\nstatic struct dma_channel *dma_channel_pool[MAX_DMAREQ];\n\nstatic struct dma_channel *\ntusb_omap_dma_allocate(struct dma_controller *c,\n\t\tstruct musb_hw_ep *hw_ep,\n\t\tu8 tx)\n{\n\tint ret, i;\n\tstruct tusb_omap_dma\t*tusb_dma;\n\tstruct musb\t\t*musb;\n\tstruct dma_channel\t*channel = NULL;\n\tstruct tusb_omap_dma_ch\t*chdat = NULL;\n\tstruct tusb_dma_data\t*dma_data = NULL;\n\n\ttusb_dma = container_of(c, struct tusb_omap_dma, controller);\n\tmusb = tusb_dma->controller.musb;\n\n\t \n\tif (hw_ep->epnum == 0) {\n\t\tdev_dbg(musb->controller, \"Not allowing DMA for ep0 %s\\n\", tx ? \"tx\" : \"rx\");\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < MAX_DMAREQ; i++) {\n\t\tstruct dma_channel *ch = dma_channel_pool[i];\n\t\tif (ch->status == MUSB_DMA_STATUS_UNKNOWN) {\n\t\t\tch->status = MUSB_DMA_STATUS_FREE;\n\t\t\tchannel = ch;\n\t\t\tchdat = ch->private_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!channel)\n\t\treturn NULL;\n\n\tchdat->musb = tusb_dma->controller.musb;\n\tchdat->tbase = tusb_dma->tbase;\n\tchdat->hw_ep = hw_ep;\n\tchdat->epnum = hw_ep->epnum;\n\tchdat->completed_len = 0;\n\tchdat->tusb_dma = tusb_dma;\n\tif (tx)\n\t\tchdat->tx = 1;\n\telse\n\t\tchdat->tx = 0;\n\n\tchannel->max_len = 0x7fffffff;\n\tchannel->desired_mode = 0;\n\tchannel->actual_len = 0;\n\n\tif (!chdat->dma_data) {\n\t\tif (tusb_dma->multichannel) {\n\t\t\tret = tusb_omap_dma_allocate_dmareq(chdat);\n\t\t\tif (ret != 0)\n\t\t\t\tgoto free_dmareq;\n\t\t} else {\n\t\t\tchdat->dma_data = &tusb_dma->dma_pool[0];\n\t\t}\n\t}\n\n\tdma_data = chdat->dma_data;\n\n\tdev_dbg(musb->controller, \"ep%i %s dma: %s dmareq%i\\n\",\n\t\tchdat->epnum,\n\t\tchdat->tx ? \"tx\" : \"rx\",\n\t\ttusb_dma->multichannel ? \"shared\" : \"dedicated\",\n\t\tdma_data->dmareq);\n\n\treturn channel;\n\nfree_dmareq:\n\ttusb_omap_dma_free_dmareq(chdat);\n\n\tdev_dbg(musb->controller, \"ep%i: Could not get a DMA channel\\n\", chdat->epnum);\n\tchannel->status = MUSB_DMA_STATUS_UNKNOWN;\n\n\treturn NULL;\n}\n\nstatic void tusb_omap_dma_release(struct dma_channel *channel)\n{\n\tstruct tusb_omap_dma_ch\t*chdat = to_chdat(channel);\n\tstruct musb\t\t*musb = chdat->musb;\n\n\tdev_dbg(musb->controller, \"Release for ep%i\\n\", chdat->epnum);\n\n\tchannel->status = MUSB_DMA_STATUS_UNKNOWN;\n\n\tdmaengine_terminate_sync(chdat->dma_data->chan);\n\ttusb_omap_dma_free_dmareq(chdat);\n\n\tchannel = NULL;\n}\n\nvoid tusb_dma_controller_destroy(struct dma_controller *c)\n{\n\tstruct tusb_omap_dma\t*tusb_dma;\n\tint\t\t\ti;\n\n\ttusb_dma = container_of(c, struct tusb_omap_dma, controller);\n\tfor (i = 0; i < MAX_DMAREQ; i++) {\n\t\tstruct dma_channel *ch = dma_channel_pool[i];\n\t\tif (ch) {\n\t\t\tkfree(ch->private_data);\n\t\t\tkfree(ch);\n\t\t}\n\n\t\t \n\t\tif (tusb_dma && tusb_dma->dma_pool[i].chan)\n\t\t\tdma_release_channel(tusb_dma->dma_pool[i].chan);\n\t}\n\n\tkfree(tusb_dma);\n}\nEXPORT_SYMBOL_GPL(tusb_dma_controller_destroy);\n\nstatic int tusb_omap_allocate_dma_pool(struct tusb_omap_dma *tusb_dma)\n{\n\tstruct musb *musb = tusb_dma->controller.musb;\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; i < MAX_DMAREQ; i++) {\n\t\tstruct tusb_dma_data *dma_data = &tusb_dma->dma_pool[i];\n\n\t\t \n\t\tif (i == 0 || tusb_dma->multichannel) {\n\t\t\tchar ch_name[8];\n\n\t\t\tsprintf(ch_name, \"dmareq%d\", i);\n\t\t\tdma_data->chan = dma_request_chan(musb->controller,\n\t\t\t\t\t\t\t  ch_name);\n\t\t\tif (IS_ERR(dma_data->chan)) {\n\t\t\t\tdev_err(musb->controller,\n\t\t\t\t\t\"Failed to request %s\\n\", ch_name);\n\t\t\t\tret = PTR_ERR(dma_data->chan);\n\t\t\t\tgoto dma_error;\n\t\t\t}\n\n\t\t\tdma_data->dmareq = i;\n\t\t} else {\n\t\t\tdma_data->dmareq = -1;\n\t\t}\n\t}\n\n\treturn 0;\n\ndma_error:\n\tfor (; i >= 0; i--) {\n\t\tstruct tusb_dma_data *dma_data = &tusb_dma->dma_pool[i];\n\n\t\tif (dma_data->dmareq >= 0)\n\t\t\tdma_release_channel(dma_data->chan);\n\t}\n\n\treturn ret;\n}\n\nstruct dma_controller *\ntusb_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tvoid __iomem\t\t*tbase = musb->ctrl_base;\n\tstruct tusb_omap_dma\t*tusb_dma;\n\tint\t\t\ti;\n\n\t \n\n\tmusb_writel(musb->ctrl_base, TUSB_DMA_INT_MASK, 0x7fffffff);\n\tmusb_writel(musb->ctrl_base, TUSB_DMA_EP_MAP, 0);\n\n\tmusb_writel(tbase, TUSB_DMA_REQ_CONF,\n\t\tTUSB_DMA_REQ_CONF_BURST_SIZE(2)\n\t\t| TUSB_DMA_REQ_CONF_DMA_REQ_EN(0x3f)\n\t\t| TUSB_DMA_REQ_CONF_DMA_REQ_ASSER(2));\n\n\ttusb_dma = kzalloc(sizeof(struct tusb_omap_dma), GFP_KERNEL);\n\tif (!tusb_dma)\n\t\tgoto out;\n\n\ttusb_dma->controller.musb = musb;\n\ttusb_dma->tbase = musb->ctrl_base;\n\n\ttusb_dma->controller.channel_alloc = tusb_omap_dma_allocate;\n\ttusb_dma->controller.channel_release = tusb_omap_dma_release;\n\ttusb_dma->controller.channel_program = tusb_omap_dma_program;\n\ttusb_dma->controller.channel_abort = tusb_omap_dma_abort;\n\n\tif (musb->tusb_revision >= TUSB_REV_30)\n\t\ttusb_dma->multichannel = 1;\n\n\tfor (i = 0; i < MAX_DMAREQ; i++) {\n\t\tstruct dma_channel\t*ch;\n\t\tstruct tusb_omap_dma_ch\t*chdat;\n\n\t\tch = kzalloc(sizeof(struct dma_channel), GFP_KERNEL);\n\t\tif (!ch)\n\t\t\tgoto cleanup;\n\n\t\tdma_channel_pool[i] = ch;\n\n\t\tchdat = kzalloc(sizeof(struct tusb_omap_dma_ch), GFP_KERNEL);\n\t\tif (!chdat)\n\t\t\tgoto cleanup;\n\n\t\tch->status = MUSB_DMA_STATUS_UNKNOWN;\n\t\tch->private_data = chdat;\n\t}\n\n\tif (tusb_omap_allocate_dma_pool(tusb_dma))\n\t\tgoto cleanup;\n\n\treturn &tusb_dma->controller;\n\ncleanup:\n\tmusb_dma_controller_destroy(&tusb_dma->controller);\nout:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(tusb_dma_controller_create);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}