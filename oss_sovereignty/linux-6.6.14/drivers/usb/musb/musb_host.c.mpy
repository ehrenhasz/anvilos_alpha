{
  "module_name": "musb_host.c",
  "hash_id": "a382713f69ebe1a46c30c9d1916d1b0c39c850488bbf1981a6ced10704080a8c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_host.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/dma-mapping.h>\n\n#include \"musb_core.h\"\n#include \"musb_host.h\"\n#include \"musb_trace.h\"\n\n \n\n\n \n\nstruct musb *hcd_to_musb(struct usb_hcd *hcd)\n{\n\treturn *(struct musb **) hcd->hcd_priv;\n}\n\n\nstatic void musb_ep_program(struct musb *musb, u8 epnum,\n\t\t\tstruct urb *urb, int is_out,\n\t\t\tu8 *buf, u32 offset, u32 len);\n\n \nstatic void musb_h_tx_flush_fifo(struct musb_hw_ep *ep)\n{\n\tstruct musb\t*musb = ep->musb;\n\tvoid __iomem\t*epio = ep->regs;\n\tu16\t\tcsr;\n\tint\t\tretries = 1000;\n\n\tcsr = musb_readw(epio, MUSB_TXCSR);\n\twhile (csr & MUSB_TXCSR_FIFONOTEMPTY) {\n\t\tcsr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_TXPKTRDY;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\n\t\t \n\t\tif (dev_WARN_ONCE(musb->controller, retries-- < 1,\n\t\t\t\t\"Could not flush host TX%d fifo: csr: %04x\\n\",\n\t\t\t\tep->epnum, csr))\n\t\t\treturn;\n\t\tmdelay(1);\n\t}\n}\n\nstatic void musb_h_ep0_flush_fifo(struct musb_hw_ep *ep)\n{\n\tvoid __iomem\t*epio = ep->regs;\n\tu16\t\tcsr;\n\tint\t\tretries = 5;\n\n\t \n\tdo {\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tif (!(csr & (MUSB_CSR0_TXPKTRDY | MUSB_CSR0_RXPKTRDY)))\n\t\t\tbreak;\n\t\tmusb_writew(epio, MUSB_TXCSR, MUSB_CSR0_FLUSHFIFO);\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tudelay(10);\n\t} while (--retries);\n\n\tWARN(!retries, \"Could not flush host TX%d fifo: csr: %04x\\n\",\n\t\t\tep->epnum, csr);\n\n\t \n\tmusb_writew(epio, MUSB_TXCSR, 0);\n}\n\n \nstatic inline void musb_h_tx_start(struct musb_hw_ep *ep)\n{\n\tu16\ttxcsr;\n\n\t \n\tif (ep->epnum) {\n\t\ttxcsr = musb_readw(ep->regs, MUSB_TXCSR);\n\t\ttxcsr |= MUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_H_WZC_BITS;\n\t\tmusb_writew(ep->regs, MUSB_TXCSR, txcsr);\n\t} else {\n\t\ttxcsr = MUSB_CSR0_H_SETUPPKT | MUSB_CSR0_TXPKTRDY;\n\t\tmusb_writew(ep->regs, MUSB_CSR0, txcsr);\n\t}\n\n}\n\nstatic inline void musb_h_tx_dma_start(struct musb_hw_ep *ep)\n{\n\tu16\ttxcsr;\n\n\t \n\ttxcsr = musb_readw(ep->regs, MUSB_TXCSR);\n\ttxcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_H_WZC_BITS;\n\tif (is_cppi_enabled(ep->musb))\n\t\ttxcsr |= MUSB_TXCSR_DMAMODE;\n\tmusb_writew(ep->regs, MUSB_TXCSR, txcsr);\n}\n\nstatic void musb_ep_set_qh(struct musb_hw_ep *ep, int is_in, struct musb_qh *qh)\n{\n\tif (is_in != 0 || ep->is_shared_fifo)\n\t\tep->in_qh  = qh;\n\tif (is_in == 0 || ep->is_shared_fifo)\n\t\tep->out_qh = qh;\n}\n\nstatic struct musb_qh *musb_ep_get_qh(struct musb_hw_ep *ep, int is_in)\n{\n\treturn is_in ? ep->in_qh : ep->out_qh;\n}\n\n \nstatic void\nmusb_start_urb(struct musb *musb, int is_in, struct musb_qh *qh)\n{\n\tu32\t\t\tlen;\n\tvoid __iomem\t\t*mbase =  musb->mregs;\n\tstruct urb\t\t*urb = next_urb(qh);\n\tvoid\t\t\t*buf = urb->transfer_buffer;\n\tu32\t\t\toffset = 0;\n\tstruct musb_hw_ep\t*hw_ep = qh->hw_ep;\n\tint\t\t\tepnum = hw_ep->epnum;\n\n\t \n\tqh->offset = 0;\n\tqh->segsize = 0;\n\n\t \n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\tis_in = 0;\n\t\tmusb->ep0_stage = MUSB_EP0_START;\n\t\tbuf = urb->setup_packet;\n\t\tlen = 8;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tqh->iso_idx = 0;\n\t\tqh->frame = 0;\n\t\toffset = urb->iso_frame_desc[0].offset;\n\t\tlen = urb->iso_frame_desc[0].length;\n\t\tbreak;\n\tdefault:\t\t \n\t\t \n\t\tbuf = urb->transfer_buffer + urb->actual_length;\n\t\tlen = urb->transfer_buffer_length - urb->actual_length;\n\t}\n\n\ttrace_musb_urb_start(musb, urb);\n\n\t \n\tmusb_ep_set_qh(hw_ep, is_in, qh);\n\tmusb_ep_program(musb, epnum, urb, !is_in, buf, offset, len);\n\n\t \n\tif (is_in)\n\t\treturn;\n\n\t \n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tmusb_dbg(musb, \"check whether there's still time for periodic Tx\");\n\t\t \n\t\tif (1) {\t \n\t\t\t \n\t\t\tqh->frame = 0;\n\t\t\tgoto start;\n\t\t} else {\n\t\t\tqh->frame = urb->start_frame;\n\t\t\t \n\t\t\tmusb_dbg(musb, \"SOF for %d\", epnum);\n#if 1  \n\t\t\tmusb_writeb(mbase, MUSB_INTRUSBE, 0xff);\n#endif\n\t\t}\n\t\tbreak;\n\tdefault:\nstart:\n\t\tmusb_dbg(musb, \"Start TX%d %s\", epnum,\n\t\t\thw_ep->tx_channel ? \"dma\" : \"pio\");\n\n\t\tif (!hw_ep->tx_channel)\n\t\t\tmusb_h_tx_start(hw_ep);\n\t\telse if (is_cppi_enabled(musb) || tusb_dma_omap(musb))\n\t\t\tmusb_h_tx_dma_start(hw_ep);\n\t}\n}\n\n \nstatic void musb_giveback(struct musb *musb, struct urb *urb, int status)\n__releases(musb->lock)\n__acquires(musb->lock)\n{\n\ttrace_musb_urb_gb(musb, urb);\n\n\tusb_hcd_unlink_urb_from_ep(musb->hcd, urb);\n\tspin_unlock(&musb->lock);\n\tusb_hcd_giveback_urb(musb->hcd, urb, status);\n\tspin_lock(&musb->lock);\n}\n\n \nstatic void musb_advance_schedule(struct musb *musb, struct urb *urb,\n\t\t\t\t  struct musb_hw_ep *hw_ep, int is_in)\n{\n\tstruct musb_qh\t\t*qh = musb_ep_get_qh(hw_ep, is_in);\n\tstruct musb_hw_ep\t*ep = qh->hw_ep;\n\tint\t\t\tready = qh->is_ready;\n\tint\t\t\tstatus;\n\tu16\t\t\ttoggle;\n\n\tstatus = (urb->status == -EINPROGRESS) ? 0 : urb->status;\n\n\t \n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttoggle = musb->io.get_toggle(qh, !is_in);\n\t\tusb_settoggle(urb->dev, qh->epnum, !is_in, toggle ? 1 : 0);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (status == 0 && urb->error_count)\n\t\t\tstatus = -EXDEV;\n\t\tbreak;\n\t}\n\n\tqh->is_ready = 0;\n\tmusb_giveback(musb, urb, status);\n\tqh->is_ready = ready;\n\n\t \n\tqh = musb_ep_get_qh(hw_ep, is_in);\n\n\t \n\tif (qh && list_empty(&qh->hep->urb_list)) {\n\t\tstruct list_head\t*head;\n\t\tstruct dma_controller\t*dma = musb->dma_controller;\n\n\t\tif (is_in) {\n\t\t\tep->rx_reinit = 1;\n\t\t\tif (ep->rx_channel) {\n\t\t\t\tdma->channel_release(ep->rx_channel);\n\t\t\t\tep->rx_channel = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tep->tx_reinit = 1;\n\t\t\tif (ep->tx_channel) {\n\t\t\t\tdma->channel_release(ep->tx_channel);\n\t\t\t\tep->tx_channel = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmusb_ep_set_qh(ep, is_in, NULL);\n\t\tqh->hep->hcpriv = NULL;\n\n\t\tswitch (qh->type) {\n\n\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t \n\t\t\tif (qh->mux == 1) {\n\t\t\t\thead = qh->ring.prev;\n\t\t\t\tlist_del(&qh->ring);\n\t\t\t\tkfree(qh);\n\t\t\t\tqh = first_qh(head);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t \n\t\t\tkfree(qh);\n\t\t\tqh = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (qh != NULL && qh->is_ready) {\n\t\tmusb_dbg(musb, \"... next ep%d %cX urb %p\",\n\t\t    hw_ep->epnum, is_in ? 'R' : 'T', next_urb(qh));\n\t\tmusb_start_urb(musb, is_in, qh);\n\t}\n}\n\nstatic u16 musb_h_flush_rxfifo(struct musb_hw_ep *hw_ep, u16 csr)\n{\n\t \n\tcsr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_RXPKTRDY;\n\tcsr &= ~(MUSB_RXCSR_H_REQPKT\n\t\t| MUSB_RXCSR_H_AUTOREQ\n\t\t| MUSB_RXCSR_AUTOCLEAR);\n\n\t \n\tmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\n\tmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\n\n\t \n\treturn musb_readw(hw_ep->regs, MUSB_RXCSR);\n}\n\n \nstatic bool\nmusb_host_packet_rx(struct musb *musb, struct urb *urb, u8 epnum, u8 iso_err)\n{\n\tu16\t\t\trx_count;\n\tu8\t\t\t*buf;\n\tu16\t\t\tcsr;\n\tbool\t\t\tdone = false;\n\tu32\t\t\tlength;\n\tint\t\t\tdo_flush = 0;\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + epnum;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tstruct musb_qh\t\t*qh = hw_ep->in_qh;\n\tint\t\t\tpipe = urb->pipe;\n\tvoid\t\t\t*buffer = urb->transfer_buffer;\n\n\t \n\trx_count = musb_readw(epio, MUSB_RXCOUNT);\n\tmusb_dbg(musb, \"RX%d count %d, buffer %p len %d/%d\", epnum, rx_count,\n\t\t\turb->transfer_buffer, qh->offset,\n\t\t\turb->transfer_buffer_length);\n\n\t \n\tif (usb_pipeisoc(pipe)) {\n\t\tint\t\t\t\t\tstatus = 0;\n\t\tstruct usb_iso_packet_descriptor\t*d;\n\n\t\tif (iso_err) {\n\t\t\tstatus = -EILSEQ;\n\t\t\turb->error_count++;\n\t\t}\n\n\t\td = urb->iso_frame_desc + qh->iso_idx;\n\t\tbuf = buffer + d->offset;\n\t\tlength = d->length;\n\t\tif (rx_count > length) {\n\t\t\tif (status == 0) {\n\t\t\t\tstatus = -EOVERFLOW;\n\t\t\t\turb->error_count++;\n\t\t\t}\n\t\t\tmusb_dbg(musb, \"OVERFLOW %d into %d\", rx_count, length);\n\t\t\tdo_flush = 1;\n\t\t} else\n\t\t\tlength = rx_count;\n\t\turb->actual_length += length;\n\t\td->actual_length = length;\n\n\t\td->status = status;\n\n\t\t \n\t\tdone = (++qh->iso_idx >= urb->number_of_packets);\n\t} else {\n\t\t \n\t\tbuf = buffer + qh->offset;\n\t\tlength = urb->transfer_buffer_length - qh->offset;\n\t\tif (rx_count > length) {\n\t\t\tif (urb->status == -EINPROGRESS)\n\t\t\t\turb->status = -EOVERFLOW;\n\t\t\tmusb_dbg(musb, \"OVERFLOW %d into %d\", rx_count, length);\n\t\t\tdo_flush = 1;\n\t\t} else\n\t\t\tlength = rx_count;\n\t\turb->actual_length += length;\n\t\tqh->offset += length;\n\n\t\t \n\t\tdone = (urb->actual_length == urb->transfer_buffer_length)\n\t\t\t|| (rx_count < qh->maxpacket)\n\t\t\t|| (urb->status != -EINPROGRESS);\n\t\tif (done\n\t\t\t\t&& (urb->status == -EINPROGRESS)\n\t\t\t\t&& (urb->transfer_flags & URB_SHORT_NOT_OK)\n\t\t\t\t&& (urb->actual_length\n\t\t\t\t\t< urb->transfer_buffer_length))\n\t\t\turb->status = -EREMOTEIO;\n\t}\n\n\tmusb_read_fifo(hw_ep, length, buf);\n\n\tcsr = musb_readw(epio, MUSB_RXCSR);\n\tcsr |= MUSB_RXCSR_H_WZC_BITS;\n\tif (unlikely(do_flush))\n\t\tmusb_h_flush_rxfifo(hw_ep, csr);\n\telse {\n\t\t \n\t\tcsr &= ~(MUSB_RXCSR_RXPKTRDY | MUSB_RXCSR_H_REQPKT);\n\t\tif (!done)\n\t\t\tcsr |= MUSB_RXCSR_H_REQPKT;\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t}\n\n\treturn done;\n}\n\n \nstatic void\nmusb_rx_reinit(struct musb *musb, struct musb_qh *qh, u8 epnum)\n{\n\tstruct musb_hw_ep *ep = musb->endpoints + epnum;\n\tu16\tcsr;\n\n\t \n\n\t \n\tif (ep->is_shared_fifo) {\n\t\tcsr = musb_readw(ep->regs, MUSB_TXCSR);\n\t\tif (csr & MUSB_TXCSR_MODE) {\n\t\t\tmusb_h_tx_flush_fifo(ep);\n\t\t\tcsr = musb_readw(ep->regs, MUSB_TXCSR);\n\t\t\tmusb_writew(ep->regs, MUSB_TXCSR,\n\t\t\t\t    csr | MUSB_TXCSR_FRCDATATOG);\n\t\t}\n\n\t\t \n\t\tif (csr & MUSB_TXCSR_DMAMODE)\n\t\t\tmusb_writew(ep->regs, MUSB_TXCSR, MUSB_TXCSR_DMAMODE);\n\t\tmusb_writew(ep->regs, MUSB_TXCSR, 0);\n\n\t \n\t}\n\tcsr = musb_readw(ep->regs, MUSB_RXCSR);\n\tif (csr & MUSB_RXCSR_RXPKTRDY)\n\t\tWARNING(\"rx%d, packet/%d ready?\\n\", ep->epnum,\n\t\t\tmusb_readw(ep->regs, MUSB_RXCOUNT));\n\n\tmusb_h_flush_rxfifo(ep, MUSB_RXCSR_CLRDATATOG);\n\n\t \n\tif (musb->is_multipoint) {\n\t\tmusb_write_rxfunaddr(musb, epnum, qh->addr_reg);\n\t\tmusb_write_rxhubaddr(musb, epnum, qh->h_addr_reg);\n\t\tmusb_write_rxhubport(musb, epnum, qh->h_port_reg);\n\t} else\n\t\tmusb_writeb(musb->mregs, MUSB_FADDR, qh->addr_reg);\n\n\t \n\tmusb_writeb(ep->regs, MUSB_RXTYPE, qh->type_reg);\n\tmusb_writeb(ep->regs, MUSB_RXINTERVAL, qh->intv_reg);\n\t \n\t \n\tmusb_writew(ep->regs, MUSB_RXMAXP,\n\t\t\tqh->maxpacket | ((qh->hb_mult - 1) << 11));\n\n\tep->rx_reinit = 0;\n}\n\nstatic void musb_tx_dma_set_mode_mentor(struct musb_hw_ep *hw_ep, \n\t\t\t\t\tstruct musb_qh *qh,\n\t\t\t\t\tu32 *length, u8 *mode)\n{\n\tstruct dma_channel\t*channel = hw_ep->tx_channel;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tu16\t\t\tpkt_size = qh->maxpacket;\n\tu16\t\t\tcsr;\n\n\tif (*length > channel->max_len)\n\t\t*length = channel->max_len;\n\n\tcsr = musb_readw(epio, MUSB_TXCSR);\n\tif (*length > pkt_size) {\n\t\t*mode = 1;\n\t\tcsr |= MUSB_TXCSR_DMAMODE | MUSB_TXCSR_DMAENAB;\n\t\t \n\t\t \n\t\tif (qh->hb_mult == 1 || (qh->hb_mult > 1 &&\n\t\t\t\t\tcan_bulk_split(hw_ep->musb, qh->type)))\n\t\t\tcsr |= MUSB_TXCSR_AUTOSET;\n\t} else {\n\t\t*mode = 0;\n\t\tcsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAMODE);\n\t\tcsr |= MUSB_TXCSR_DMAENAB;  \n\t}\n\tchannel->desired_mode = *mode;\n\tmusb_writew(epio, MUSB_TXCSR, csr);\n}\n\nstatic void musb_tx_dma_set_mode_cppi_tusb(struct musb_hw_ep *hw_ep,\n\t\t\t\t\t   struct urb *urb,\n\t\t\t\t\t   u8 *mode)\n{\n\tstruct dma_channel *channel = hw_ep->tx_channel;\n\n\tchannel->actual_len = 0;\n\n\t \n\t*mode = (urb->transfer_flags & URB_ZERO_PACKET) ? 1 : 0;\n}\n\nstatic bool musb_tx_dma_program(struct dma_controller *dma,\n\t\tstruct musb_hw_ep *hw_ep, struct musb_qh *qh,\n\t\tstruct urb *urb, u32 offset, u32 length)\n{\n\tstruct dma_channel\t*channel = hw_ep->tx_channel;\n\tu16\t\t\tpkt_size = qh->maxpacket;\n\tu8\t\t\tmode;\n\n\tif (musb_dma_inventra(hw_ep->musb) || musb_dma_ux500(hw_ep->musb))\n\t\tmusb_tx_dma_set_mode_mentor(hw_ep, qh,\n\t\t\t\t\t    &length, &mode);\n\telse if (is_cppi_enabled(hw_ep->musb) || tusb_dma_omap(hw_ep->musb))\n\t\tmusb_tx_dma_set_mode_cppi_tusb(hw_ep, urb, &mode);\n\telse\n\t\treturn false;\n\n\tqh->segsize = length;\n\n\t \n\twmb();\n\n\tif (!dma->channel_program(channel, pkt_size, mode,\n\t\t\turb->transfer_dma + offset, length)) {\n\t\tvoid __iomem *epio = hw_ep->regs;\n\t\tu16 csr;\n\n\t\tdma->channel_release(channel);\n\t\thw_ep->tx_channel = NULL;\n\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tcsr &= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAENAB);\n\t\tmusb_writew(epio, MUSB_TXCSR, csr | MUSB_TXCSR_H_WZC_BITS);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic void musb_ep_program(struct musb *musb, u8 epnum,\n\t\t\tstruct urb *urb, int is_out,\n\t\t\tu8 *buf, u32 offset, u32 len)\n{\n\tstruct dma_controller\t*dma_controller;\n\tstruct dma_channel\t*dma_channel;\n\tu8\t\t\tdma_ok;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + epnum;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tstruct musb_qh\t\t*qh = musb_ep_get_qh(hw_ep, !is_out);\n\tu16\t\t\tpacket_sz = qh->maxpacket;\n\tu8\t\t\tuse_dma = 1;\n\tu16\t\t\tcsr;\n\n\tmusb_dbg(musb, \"%s hw%d urb %p spd%d dev%d ep%d%s \"\n\t\t\t\t\"h_addr%02x h_port%02x bytes %d\",\n\t\t\tis_out ? \"-->\" : \"<--\",\n\t\t\tepnum, urb, urb->dev->speed,\n\t\t\tqh->addr_reg, qh->epnum, is_out ? \"out\" : \"in\",\n\t\t\tqh->h_addr_reg, qh->h_port_reg,\n\t\t\tlen);\n\n\tmusb_ep_select(mbase, epnum);\n\n\tif (is_out && !len) {\n\t\tuse_dma = 0;\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tcsr &= ~MUSB_TXCSR_DMAENAB;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\thw_ep->tx_channel = NULL;\n\t}\n\n\t \n\tdma_controller = musb->dma_controller;\n\tif (use_dma && is_dma_capable() && epnum && dma_controller) {\n\t\tdma_channel = is_out ? hw_ep->tx_channel : hw_ep->rx_channel;\n\t\tif (!dma_channel) {\n\t\t\tdma_channel = dma_controller->channel_alloc(\n\t\t\t\t\tdma_controller, hw_ep, is_out);\n\t\t\tif (is_out)\n\t\t\t\thw_ep->tx_channel = dma_channel;\n\t\t\telse\n\t\t\t\thw_ep->rx_channel = dma_channel;\n\t\t}\n\t} else\n\t\tdma_channel = NULL;\n\n\t \n\n\t \n\tif (is_out) {\n\t\tu16\tcsr;\n\t\tu16\tint_txe;\n\t\tu16\tload_count;\n\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\n\t\t \n\t\tint_txe = musb->intrtxe;\n\t\tmusb_writew(mbase, MUSB_INTRTXE, int_txe & ~(1 << epnum));\n\n\t\t \n\t\tif (epnum) {\n\t\t\t \n\t\t\t \n\t\t\tif (!hw_ep->tx_double_buffered)\n\t\t\t\tmusb_h_tx_flush_fifo(hw_ep);\n\n\t\t\t \n\t\t\tcsr &= ~(MUSB_TXCSR_H_NAKTIMEOUT\n\t\t\t\t\t| MUSB_TXCSR_AUTOSET\n\t\t\t\t\t| MUSB_TXCSR_DMAENAB\n\t\t\t\t\t| MUSB_TXCSR_FRCDATATOG\n\t\t\t\t\t| MUSB_TXCSR_H_RXSTALL\n\t\t\t\t\t| MUSB_TXCSR_H_ERROR\n\t\t\t\t\t| MUSB_TXCSR_TXPKTRDY\n\t\t\t\t\t);\n\t\t\tcsr |= MUSB_TXCSR_MODE;\n\n\t\t\tif (!hw_ep->tx_double_buffered)\n\t\t\t\tcsr |= musb->io.set_toggle(qh, is_out, urb);\n\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\t \n\t\t\tcsr &= ~MUSB_TXCSR_DMAMODE;\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\t} else {\n\t\t\t \n\t\t\tmusb_h_ep0_flush_fifo(hw_ep);\n\t\t}\n\n\t\t \n\t\tif (musb->is_multipoint) {\n\t\t\tmusb_write_txfunaddr(musb, epnum, qh->addr_reg);\n\t\t\tmusb_write_txhubaddr(musb, epnum, qh->h_addr_reg);\n\t\t\tmusb_write_txhubport(musb, epnum, qh->h_port_reg);\n \n\t\t} else\n\t\t\tmusb_writeb(mbase, MUSB_FADDR, qh->addr_reg);\n\n\t\t \n\t\tif (epnum) {\n\t\t\tmusb_writeb(epio, MUSB_TXTYPE, qh->type_reg);\n\t\t\tif (can_bulk_split(musb, qh->type)) {\n\t\t\t\tqh->hb_mult = hw_ep->max_packet_sz_tx\n\t\t\t\t\t\t/ packet_sz;\n\t\t\t\tmusb_writew(epio, MUSB_TXMAXP, packet_sz\n\t\t\t\t\t| ((qh->hb_mult) - 1) << 11);\n\t\t\t} else {\n\t\t\t\tmusb_writew(epio, MUSB_TXMAXP,\n\t\t\t\t\t\tqh->maxpacket |\n\t\t\t\t\t\t((qh->hb_mult - 1) << 11));\n\t\t\t}\n\t\t\tmusb_writeb(epio, MUSB_TXINTERVAL, qh->intv_reg);\n\t\t} else {\n\t\t\tmusb_writeb(epio, MUSB_NAKLIMIT0, qh->intv_reg);\n\t\t\tif (musb->is_multipoint)\n\t\t\t\tmusb_writeb(epio, MUSB_TYPE0,\n\t\t\t\t\t\tqh->type_reg);\n\t\t}\n\n\t\tif (can_bulk_split(musb, qh->type))\n\t\t\tload_count = min((u32) hw_ep->max_packet_sz_tx,\n\t\t\t\t\t\tlen);\n\t\telse\n\t\t\tload_count = min((u32) packet_sz, len);\n\n\t\tif (dma_channel && musb_tx_dma_program(dma_controller,\n\t\t\t\t\thw_ep, qh, urb, offset, len))\n\t\t\tload_count = 0;\n\n\t\tif (load_count) {\n\t\t\t \n\t\t\tqh->segsize = load_count;\n\t\t\tif (!buf) {\n\t\t\t\tsg_miter_start(&qh->sg_miter, urb->sg, 1,\n\t\t\t\t\t\tSG_MITER_ATOMIC\n\t\t\t\t\t\t| SG_MITER_FROM_SG);\n\t\t\t\tif (!sg_miter_next(&qh->sg_miter)) {\n\t\t\t\t\tdev_err(musb->controller,\n\t\t\t\t\t\t\t\"error: sg\"\n\t\t\t\t\t\t\t\"list empty\\n\");\n\t\t\t\t\tsg_miter_stop(&qh->sg_miter);\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t\tbuf = qh->sg_miter.addr + urb->sg->offset +\n\t\t\t\t\turb->actual_length;\n\t\t\t\tload_count = min_t(u32, load_count,\n\t\t\t\t\t\tqh->sg_miter.length);\n\t\t\t\tmusb_write_fifo(hw_ep, load_count, buf);\n\t\t\t\tqh->sg_miter.consumed = load_count;\n\t\t\t\tsg_miter_stop(&qh->sg_miter);\n\t\t\t} else\n\t\t\t\tmusb_write_fifo(hw_ep, load_count, buf);\n\t\t}\nfinish:\n\t\t \n\t\tmusb_writew(mbase, MUSB_INTRTXE, int_txe);\n\n\t \n\t} else {\n\t\tu16 csr = 0;\n\n\t\tif (hw_ep->rx_reinit) {\n\t\t\tmusb_rx_reinit(musb, qh, epnum);\n\t\t\tcsr |= musb->io.set_toggle(qh, is_out, urb);\n\n\t\t\tif (qh->type == USB_ENDPOINT_XFER_INT)\n\t\t\t\tcsr |= MUSB_RXCSR_DISNYET;\n\n\t\t} else {\n\t\t\tcsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\n\n\t\t\tif (csr & (MUSB_RXCSR_RXPKTRDY\n\t\t\t\t\t| MUSB_RXCSR_DMAENAB\n\t\t\t\t\t| MUSB_RXCSR_H_REQPKT))\n\t\t\t\tERR(\"broken !rx_reinit, ep%d csr %04x\\n\",\n\t\t\t\t\t\thw_ep->epnum, csr);\n\n\t\t\t \n\t\t\tcsr &= MUSB_RXCSR_DISNYET;\n\t\t}\n\n\t\t \n\n\t\tif ((is_cppi_enabled(musb) || tusb_dma_omap(musb)) && dma_channel) {\n\t\t\t \n\t\t\tdma_channel->actual_len = 0L;\n\t\t\tqh->segsize = len;\n\n\t\t\t \n\t\t\tmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\n\t\t\tcsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\n\n\t\t\t \n\t\t\tdma_ok = dma_controller->channel_program(dma_channel,\n\t\t\t\t\tpacket_sz, !(urb->transfer_flags &\n\t\t\t\t\t\t     URB_SHORT_NOT_OK),\n\t\t\t\t\turb->transfer_dma + offset,\n\t\t\t\t\tqh->segsize);\n\t\t\tif (!dma_ok) {\n\t\t\t\tdma_controller->channel_release(dma_channel);\n\t\t\t\thw_ep->rx_channel = dma_channel = NULL;\n\t\t\t} else\n\t\t\t\tcsr |= MUSB_RXCSR_DMAENAB;\n\t\t}\n\n\t\tcsr |= MUSB_RXCSR_H_REQPKT;\n\t\tmusb_dbg(musb, \"RXCSR%d := %04x\", epnum, csr);\n\t\tmusb_writew(hw_ep->regs, MUSB_RXCSR, csr);\n\t\tcsr = musb_readw(hw_ep->regs, MUSB_RXCSR);\n\t}\n}\n\n \nstatic void musb_bulk_nak_timeout(struct musb *musb, struct musb_hw_ep *ep,\n\tint is_in)\n{\n\tstruct dma_channel\t*dma;\n\tstruct urb\t\t*urb;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tvoid __iomem\t\t*epio = ep->regs;\n\tstruct musb_qh\t\t*cur_qh, *next_qh;\n\tu16\t\t\trx_csr, tx_csr;\n\tu16\t\t\ttoggle;\n\n\tmusb_ep_select(mbase, ep->epnum);\n\tif (is_in) {\n\t\tdma = is_dma_capable() ? ep->rx_channel : NULL;\n\n\t\t \n\t\trx_csr = musb_readw(epio, MUSB_RXCSR);\n\t\trx_csr |= MUSB_RXCSR_H_WZC_BITS;\n\t\trx_csr &= ~MUSB_RXCSR_H_REQPKT;\n\t\tmusb_writew(epio, MUSB_RXCSR, rx_csr);\n\t\trx_csr &= ~MUSB_RXCSR_DATAERROR;\n\t\tmusb_writew(epio, MUSB_RXCSR, rx_csr);\n\n\t\tcur_qh = first_qh(&musb->in_bulk);\n\t} else {\n\t\tdma = is_dma_capable() ? ep->tx_channel : NULL;\n\n\t\t \n\t\ttx_csr = musb_readw(epio, MUSB_TXCSR);\n\t\ttx_csr |= MUSB_TXCSR_H_WZC_BITS;\n\t\ttx_csr &= ~MUSB_TXCSR_H_NAKTIMEOUT;\n\t\tmusb_writew(epio, MUSB_TXCSR, tx_csr);\n\n\t\tcur_qh = first_qh(&musb->out_bulk);\n\t}\n\tif (cur_qh) {\n\t\turb = next_urb(cur_qh);\n\t\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t\tdma->status = MUSB_DMA_STATUS_CORE_ABORT;\n\t\t\tmusb->dma_controller->channel_abort(dma);\n\t\t\turb->actual_length += dma->actual_len;\n\t\t\tdma->actual_len = 0L;\n\t\t}\n\t\ttoggle = musb->io.get_toggle(cur_qh, !is_in);\n\t\tusb_settoggle(urb->dev, cur_qh->epnum, !is_in, toggle ? 1 : 0);\n\n\t\tif (is_in) {\n\t\t\t \n\t\t\tlist_move_tail(&cur_qh->ring, &musb->in_bulk);\n\n\t\t\t \n\t\t\tnext_qh = first_qh(&musb->in_bulk);\n\n\t\t\t \n\t\t\tep->rx_reinit = 1;\n\t\t} else {\n\t\t\t \n\t\t\tlist_move_tail(&cur_qh->ring, &musb->out_bulk);\n\n\t\t\t \n\t\t\tnext_qh = first_qh(&musb->out_bulk);\n\n\t\t\t \n\t\t\tep->tx_reinit = 1;\n\t\t}\n\n\t\tif (next_qh)\n\t\t\tmusb_start_urb(musb, is_in, next_qh);\n\t}\n}\n\n \nstatic bool musb_h_ep0_continue(struct musb *musb, u16 len, struct urb *urb)\n{\n\tbool\t\t\t more = false;\n\tu8\t\t\t*fifo_dest = NULL;\n\tu16\t\t\tfifo_count = 0;\n\tstruct musb_hw_ep\t*hw_ep = musb->control_ep;\n\tstruct musb_qh\t\t*qh = hw_ep->in_qh;\n\tstruct usb_ctrlrequest\t*request;\n\n\tswitch (musb->ep0_stage) {\n\tcase MUSB_EP0_IN:\n\t\tfifo_dest = urb->transfer_buffer + urb->actual_length;\n\t\tfifo_count = min_t(size_t, len, urb->transfer_buffer_length -\n\t\t\t\t   urb->actual_length);\n\t\tif (fifo_count < len)\n\t\t\turb->status = -EOVERFLOW;\n\n\t\tmusb_read_fifo(hw_ep, fifo_count, fifo_dest);\n\n\t\turb->actual_length += fifo_count;\n\t\tif (len < qh->maxpacket) {\n\t\t\t \n\t\t} else if (urb->actual_length <\n\t\t\t\turb->transfer_buffer_length)\n\t\t\tmore = true;\n\t\tbreak;\n\tcase MUSB_EP0_START:\n\t\trequest = (struct usb_ctrlrequest *) urb->setup_packet;\n\n\t\tif (!request->wLength) {\n\t\t\tmusb_dbg(musb, \"start no-DATA\");\n\t\t\tbreak;\n\t\t} else if (request->bRequestType & USB_DIR_IN) {\n\t\t\tmusb_dbg(musb, \"start IN-DATA\");\n\t\t\tmusb->ep0_stage = MUSB_EP0_IN;\n\t\t\tmore = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tmusb_dbg(musb, \"start OUT-DATA\");\n\t\t\tmusb->ep0_stage = MUSB_EP0_OUT;\n\t\t\tmore = true;\n\t\t}\n\t\tfallthrough;\n\tcase MUSB_EP0_OUT:\n\t\tfifo_count = min_t(size_t, qh->maxpacket,\n\t\t\t\t   urb->transfer_buffer_length -\n\t\t\t\t   urb->actual_length);\n\t\tif (fifo_count) {\n\t\t\tfifo_dest = (u8 *) (urb->transfer_buffer\n\t\t\t\t\t+ urb->actual_length);\n\t\t\tmusb_dbg(musb, \"Sending %d byte%s to ep0 fifo %p\",\n\t\t\t\t\tfifo_count,\n\t\t\t\t\t(fifo_count == 1) ? \"\" : \"s\",\n\t\t\t\t\tfifo_dest);\n\t\t\tmusb_write_fifo(hw_ep, fifo_count, fifo_dest);\n\n\t\t\turb->actual_length += fifo_count;\n\t\t\tmore = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tERR(\"bogus ep0 stage %d\\n\", musb->ep0_stage);\n\t\tbreak;\n\t}\n\n\treturn more;\n}\n\n \nirqreturn_t musb_h_ep0_irq(struct musb *musb)\n{\n\tstruct urb\t\t*urb;\n\tu16\t\t\tcsr, len;\n\tint\t\t\tstatus = 0;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tstruct musb_hw_ep\t*hw_ep = musb->control_ep;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tstruct musb_qh\t\t*qh = hw_ep->in_qh;\n\tbool\t\t\tcomplete = false;\n\tirqreturn_t\t\tretval = IRQ_NONE;\n\n\t \n\turb = next_urb(qh);\n\n\tmusb_ep_select(mbase, 0);\n\tcsr = musb_readw(epio, MUSB_CSR0);\n\tlen = (csr & MUSB_CSR0_RXPKTRDY)\n\t\t\t? musb_readb(epio, MUSB_COUNT0)\n\t\t\t: 0;\n\n\tmusb_dbg(musb, \"<== csr0 %04x, qh %p, count %d, urb %p, stage %d\",\n\t\tcsr, qh, len, urb, musb->ep0_stage);\n\n\t \n\tif (MUSB_EP0_STATUS == musb->ep0_stage) {\n\t\tretval = IRQ_HANDLED;\n\t\tcomplete = true;\n\t}\n\n\t \n\tif (csr & MUSB_CSR0_H_RXSTALL) {\n\t\tmusb_dbg(musb, \"STALLING ENDPOINT\");\n\t\tstatus = -EPIPE;\n\n\t} else if (csr & MUSB_CSR0_H_ERROR) {\n\t\tmusb_dbg(musb, \"no response, csr0 %04x\", csr);\n\t\tstatus = -EPROTO;\n\n\t} else if (csr & MUSB_CSR0_H_NAKTIMEOUT) {\n\t\tmusb_dbg(musb, \"control NAK timeout\");\n\n\t\t \n\t\tmusb_writew(epio, MUSB_CSR0, 0);\n\t\tretval = IRQ_HANDLED;\n\t}\n\n\tif (status) {\n\t\tmusb_dbg(musb, \"aborting\");\n\t\tretval = IRQ_HANDLED;\n\t\tif (urb)\n\t\t\turb->status = status;\n\t\tcomplete = true;\n\n\t\t \n\t\tif (csr & MUSB_CSR0_H_REQPKT) {\n\t\t\tcsr &= ~MUSB_CSR0_H_REQPKT;\n\t\t\tmusb_writew(epio, MUSB_CSR0, csr);\n\t\t\tcsr &= ~MUSB_CSR0_H_NAKTIMEOUT;\n\t\t\tmusb_writew(epio, MUSB_CSR0, csr);\n\t\t} else {\n\t\t\tmusb_h_ep0_flush_fifo(hw_ep);\n\t\t}\n\n\t\tmusb_writeb(epio, MUSB_NAKLIMIT0, 0);\n\n\t\t \n\t\tmusb_writew(epio, MUSB_CSR0, 0);\n\t}\n\n\tif (unlikely(!urb)) {\n\t\t \n\t\tERR(\"no URB for end 0\\n\");\n\n\t\tmusb_h_ep0_flush_fifo(hw_ep);\n\t\tgoto done;\n\t}\n\n\tif (!complete) {\n\t\t \n\t\tif (musb_h_ep0_continue(musb, len, urb)) {\n\t\t\t \n\t\t\tcsr = (MUSB_EP0_IN == musb->ep0_stage)\n\t\t\t\t?  MUSB_CSR0_H_REQPKT : MUSB_CSR0_TXPKTRDY;\n\t\t} else {\n\t\t\t \n\t\t\tif (usb_pipeout(urb->pipe)\n\t\t\t\t\t|| !urb->transfer_buffer_length)\n\t\t\t\tcsr = MUSB_CSR0_H_STATUSPKT\n\t\t\t\t\t| MUSB_CSR0_H_REQPKT;\n\t\t\telse\n\t\t\t\tcsr = MUSB_CSR0_H_STATUSPKT\n\t\t\t\t\t| MUSB_CSR0_TXPKTRDY;\n\n\t\t\t \n\t\t\tcsr |= MUSB_CSR0_H_DIS_PING;\n\n\t\t\t \n\t\t\tmusb->ep0_stage = MUSB_EP0_STATUS;\n\n\t\t\tmusb_dbg(musb, \"ep0 STATUS, csr %04x\", csr);\n\n\t\t}\n\t\tmusb_writew(epio, MUSB_CSR0, csr);\n\t\tretval = IRQ_HANDLED;\n\t} else\n\t\tmusb->ep0_stage = MUSB_EP0_IDLE;\n\n\t \n\tif (complete)\n\t\tmusb_advance_schedule(musb, urb, hw_ep, 1);\ndone:\n\treturn retval;\n}\n\n\n#ifdef CONFIG_USB_INVENTRA_DMA\n\n \n\n#endif\n\n \nvoid musb_host_tx(struct musb *musb, u8 epnum)\n{\n\tint\t\t\tpipe;\n\tbool\t\t\tdone = false;\n\tu16\t\t\ttx_csr;\n\tsize_t\t\t\tlength = 0;\n\tsize_t\t\t\toffset = 0;\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + epnum;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tstruct musb_qh\t\t*qh = hw_ep->out_qh;\n\tstruct urb\t\t*urb = next_urb(qh);\n\tu32\t\t\tstatus = 0;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tstruct dma_channel\t*dma;\n\tbool\t\t\ttransfer_pending = false;\n\n\tmusb_ep_select(mbase, epnum);\n\ttx_csr = musb_readw(epio, MUSB_TXCSR);\n\n\t \n\tif (!urb) {\n\t\tmusb_dbg(musb, \"extra TX%d ready, csr %04x\", epnum, tx_csr);\n\t\treturn;\n\t}\n\n\tpipe = urb->pipe;\n\tdma = is_dma_capable() ? hw_ep->tx_channel : NULL;\n\ttrace_musb_urb_tx(musb, urb);\n\tmusb_dbg(musb, \"OUT/TX%d end, csr %04x%s\", epnum, tx_csr,\n\t\t\tdma ? \", dma\" : \"\");\n\n\t \n\tif (tx_csr & MUSB_TXCSR_H_RXSTALL) {\n\t\t \n\t\tmusb_dbg(musb, \"TX end %d stall\", epnum);\n\n\t\t \n\t\tstatus = -EPIPE;\n\n\t} else if (tx_csr & MUSB_TXCSR_H_ERROR) {\n\t\t \n\t\tmusb_dbg(musb, \"TX 3strikes on ep=%d\", epnum);\n\n\t\tstatus = -ETIMEDOUT;\n\n\t} else if (tx_csr & MUSB_TXCSR_H_NAKTIMEOUT) {\n\t\tif (USB_ENDPOINT_XFER_BULK == qh->type && qh->mux == 1\n\t\t\t\t&& !list_is_singular(&musb->out_bulk)) {\n\t\t\tmusb_dbg(musb, \"NAK timeout on TX%d ep\", epnum);\n\t\t\tmusb_bulk_nak_timeout(musb, hw_ep, 0);\n\t\t} else {\n\t\t\tmusb_dbg(musb, \"TX ep%d device not responding\", epnum);\n\t\t\t \n\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\t\t\tMUSB_TXCSR_H_WZC_BITS\n\t\t\t\t\t| MUSB_TXCSR_TXPKTRDY);\n\t\t}\n\t\treturn;\n\t}\n\ndone:\n\tif (status) {\n\t\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t\tdma->status = MUSB_DMA_STATUS_CORE_ABORT;\n\t\t\tmusb->dma_controller->channel_abort(dma);\n\t\t}\n\n\t\t \n\t\tmusb_h_tx_flush_fifo(hw_ep);\n\t\ttx_csr &= ~(MUSB_TXCSR_AUTOSET\n\t\t\t\t| MUSB_TXCSR_DMAENAB\n\t\t\t\t| MUSB_TXCSR_H_ERROR\n\t\t\t\t| MUSB_TXCSR_H_RXSTALL\n\t\t\t\t| MUSB_TXCSR_H_NAKTIMEOUT\n\t\t\t\t);\n\n\t\tmusb_ep_select(mbase, epnum);\n\t\tmusb_writew(epio, MUSB_TXCSR, tx_csr);\n\t\t \n\t\tmusb_writew(epio, MUSB_TXCSR, tx_csr);\n\t\tmusb_writeb(epio, MUSB_TXINTERVAL, 0);\n\n\t\tdone = true;\n\t}\n\n\t \n\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\tmusb_dbg(musb, \"extra TX%d ready, csr %04x\", epnum, tx_csr);\n\t\treturn;\n\t}\n\n\tif (is_dma_capable() && dma && !status) {\n\t\t \n\t\tif (tx_csr & MUSB_TXCSR_DMAMODE) {\n\t\t\t \n\t\t\ttx_csr &= musb_readw(epio, MUSB_TXCSR);\n\t\t\tif (tx_csr & MUSB_TXCSR_TXPKTRDY) {\n\t\t\t\ttx_csr &= ~(MUSB_TXCSR_DMAENAB |\n\t\t\t\t\t    MUSB_TXCSR_TXPKTRDY);\n\t\t\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\t\t\t    tx_csr | MUSB_TXCSR_H_WZC_BITS);\n\t\t\t}\n\t\t\ttx_csr &= ~(MUSB_TXCSR_DMAMODE |\n\t\t\t\t    MUSB_TXCSR_TXPKTRDY);\n\t\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\t\t    tx_csr | MUSB_TXCSR_H_WZC_BITS);\n\n\t\t\t \n\t\t\ttx_csr = musb_readw(epio, MUSB_TXCSR);\n\t\t}\n\n\t\t \n\t\tif (tx_csr & (MUSB_TXCSR_FIFONOTEMPTY | MUSB_TXCSR_TXPKTRDY)) {\n\t\t\tmusb_dbg(musb,\n\t\t\t\t\"DMA complete but FIFO not empty, CSR %04x\",\n\t\t\t\ttx_csr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!status || dma || usb_pipeisoc(pipe)) {\n\t\tif (dma)\n\t\t\tlength = dma->actual_len;\n\t\telse\n\t\t\tlength = qh->segsize;\n\t\tqh->offset += length;\n\n\t\tif (usb_pipeisoc(pipe)) {\n\t\t\tstruct usb_iso_packet_descriptor\t*d;\n\n\t\t\td = urb->iso_frame_desc + qh->iso_idx;\n\t\t\td->actual_length = length;\n\t\t\td->status = status;\n\t\t\tif (++qh->iso_idx >= urb->number_of_packets) {\n\t\t\t\tdone = true;\n\t\t\t} else {\n\t\t\t\td++;\n\t\t\t\toffset = d->offset;\n\t\t\t\tlength = d->length;\n\t\t\t}\n\t\t} else if (dma && urb->transfer_buffer_length == qh->offset) {\n\t\t\tdone = true;\n\t\t} else {\n\t\t\t \n\t\t\tif (qh->segsize < qh->maxpacket)\n\t\t\t\tdone = true;\n\t\t\telse if (qh->offset == urb->transfer_buffer_length\n\t\t\t\t\t&& !(urb->transfer_flags\n\t\t\t\t\t\t& URB_ZERO_PACKET))\n\t\t\t\tdone = true;\n\t\t\tif (!done) {\n\t\t\t\toffset = qh->offset;\n\t\t\t\tlength = urb->transfer_buffer_length - offset;\n\t\t\t\ttransfer_pending = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (urb->status != -EINPROGRESS) {\n\t\tdone = true;\n\t\tif (status == 0)\n\t\t\tstatus = urb->status;\n\t}\n\n\tif (done) {\n\t\t \n\t\turb->status = status;\n\t\turb->actual_length = qh->offset;\n\t\tmusb_advance_schedule(musb, urb, hw_ep, USB_DIR_OUT);\n\t\treturn;\n\t} else if ((usb_pipeisoc(pipe) || transfer_pending) && dma) {\n\t\tif (musb_tx_dma_program(musb->dma_controller, hw_ep, qh, urb,\n\t\t\t\toffset, length)) {\n\t\t\tif (is_cppi_enabled(musb) || tusb_dma_omap(musb))\n\t\t\t\tmusb_h_tx_dma_start(hw_ep);\n\t\t\treturn;\n\t\t}\n\t} else\tif (tx_csr & MUSB_TXCSR_DMAENAB) {\n\t\tmusb_dbg(musb, \"not complete, but DMA enabled?\");\n\t\treturn;\n\t}\n\n\t \n\tif (length > qh->maxpacket)\n\t\tlength = qh->maxpacket;\n\t \n\tusb_hcd_unmap_urb_for_dma(musb->hcd, urb);\n\n\t \n\tif (!urb->transfer_buffer) {\n\t\t \n\t\tif (!sg_miter_next(&qh->sg_miter)) {\n\t\t\tdev_err(musb->controller, \"error: sg list empty\\n\");\n\t\t\tsg_miter_stop(&qh->sg_miter);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tlength = min_t(u32, length, qh->sg_miter.length);\n\t\tmusb_write_fifo(hw_ep, length, qh->sg_miter.addr);\n\t\tqh->sg_miter.consumed = length;\n\t\tsg_miter_stop(&qh->sg_miter);\n\t} else {\n\t\tmusb_write_fifo(hw_ep, length, urb->transfer_buffer + offset);\n\t}\n\n\tqh->segsize = length;\n\n\tmusb_ep_select(mbase, epnum);\n\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\tMUSB_TXCSR_H_WZC_BITS | MUSB_TXCSR_TXPKTRDY);\n}\n\n#ifdef CONFIG_USB_TI_CPPI41_DMA\n \nstatic int musb_rx_dma_iso_cppi41(struct dma_controller *dma,\n\t\t\t\t  struct musb_hw_ep *hw_ep,\n\t\t\t\t  struct musb_qh *qh,\n\t\t\t\t  struct urb *urb,\n\t\t\t\t  size_t len)\n{\n\tstruct dma_channel *channel = hw_ep->rx_channel;\n\tvoid __iomem *epio = hw_ep->regs;\n\tdma_addr_t *buf;\n\tu32 length;\n\tu16 val;\n\n\tbuf = (void *)urb->iso_frame_desc[qh->iso_idx].offset +\n\t\t(u32)urb->transfer_dma;\n\n\tlength = urb->iso_frame_desc[qh->iso_idx].length;\n\n\tval = musb_readw(epio, MUSB_RXCSR);\n\tval |= MUSB_RXCSR_DMAENAB;\n\tmusb_writew(hw_ep->regs, MUSB_RXCSR, val);\n\n\treturn dma->channel_program(channel, qh->maxpacket, 0,\n\t\t\t\t   (u32)buf, length);\n}\n#else\nstatic inline int musb_rx_dma_iso_cppi41(struct dma_controller *dma,\n\t\t\t\t\t struct musb_hw_ep *hw_ep,\n\t\t\t\t\t struct musb_qh *qh,\n\t\t\t\t\t struct urb *urb,\n\t\t\t\t\t size_t len)\n{\n\treturn false;\n}\n#endif\n\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_UX500_DMA) || \\\n\tdefined(CONFIG_USB_TI_CPPI41_DMA)\n \nstatic int musb_rx_dma_inventra_cppi41(struct dma_controller *dma,\n\t\t\t\t       struct musb_hw_ep *hw_ep,\n\t\t\t\t       struct musb_qh *qh,\n\t\t\t\t       struct urb *urb,\n\t\t\t\t       size_t len)\n{\n\tstruct dma_channel *channel = hw_ep->rx_channel;\n\tvoid __iomem *epio = hw_ep->regs;\n\tu16 val;\n\tint pipe;\n\tbool done;\n\n\tpipe = urb->pipe;\n\n\tif (usb_pipeisoc(pipe)) {\n\t\tstruct usb_iso_packet_descriptor *d;\n\n\t\td = urb->iso_frame_desc + qh->iso_idx;\n\t\td->actual_length = len;\n\n\t\t \n\t\tif (d->status != -EILSEQ && d->status != -EOVERFLOW)\n\t\t\td->status = 0;\n\n\t\tif (++qh->iso_idx >= urb->number_of_packets) {\n\t\t\tdone = true;\n\t\t} else {\n\t\t\t \n\t\t\tif (musb_dma_cppi41(hw_ep->musb))\n\t\t\t\tdone = musb_rx_dma_iso_cppi41(dma, hw_ep, qh,\n\t\t\t\t\t\t\t      urb, len);\n\t\t\tdone = false;\n\t\t}\n\n\t} else  {\n\t\t \n\t\tdone = (urb->actual_length + len >=\n\t\t\turb->transfer_buffer_length\n\t\t\t|| channel->actual_len < qh->maxpacket\n\t\t\t|| channel->rx_packet_done);\n\t}\n\n\t \n\tif (!done) {\n\t\tval = musb_readw(epio, MUSB_RXCSR);\n\t\tval |= MUSB_RXCSR_H_REQPKT;\n\t\tmusb_writew(epio, MUSB_RXCSR, MUSB_RXCSR_H_WZC_BITS | val);\n\t}\n\n\treturn done;\n}\n\n \nstatic int musb_rx_dma_in_inventra_cppi41(struct dma_controller *dma,\n\t\t\t\t\t  struct musb_hw_ep *hw_ep,\n\t\t\t\t\t  struct musb_qh *qh,\n\t\t\t\t\t  struct urb *urb,\n\t\t\t\t\t  size_t len,\n\t\t\t\t\t  u8 iso_err)\n{\n\tstruct musb *musb = hw_ep->musb;\n\tvoid __iomem *epio = hw_ep->regs;\n\tstruct dma_channel *channel = hw_ep->rx_channel;\n\tu16 rx_count, val;\n\tint length, pipe, done;\n\tdma_addr_t buf;\n\n\trx_count = musb_readw(epio, MUSB_RXCOUNT);\n\tpipe = urb->pipe;\n\n\tif (usb_pipeisoc(pipe)) {\n\t\tint d_status = 0;\n\t\tstruct usb_iso_packet_descriptor *d;\n\n\t\td = urb->iso_frame_desc + qh->iso_idx;\n\n\t\tif (iso_err) {\n\t\t\td_status = -EILSEQ;\n\t\t\turb->error_count++;\n\t\t}\n\t\tif (rx_count > d->length) {\n\t\t\tif (d_status == 0) {\n\t\t\t\td_status = -EOVERFLOW;\n\t\t\t\turb->error_count++;\n\t\t\t}\n\t\t\tmusb_dbg(musb, \"** OVERFLOW %d into %d\",\n\t\t\t\trx_count, d->length);\n\n\t\t\tlength = d->length;\n\t\t} else\n\t\t\tlength = rx_count;\n\t\td->status = d_status;\n\t\tbuf = urb->transfer_dma + d->offset;\n\t} else {\n\t\tlength = rx_count;\n\t\tbuf = urb->transfer_dma + urb->actual_length;\n\t}\n\n\tchannel->desired_mode = 0;\n#ifdef USE_MODE1\n\t \n\tif ((urb->transfer_flags & URB_SHORT_NOT_OK)\n\t    && (urb->transfer_buffer_length - urb->actual_length)\n\t    > qh->maxpacket)\n\t\tchannel->desired_mode = 1;\n\tif (rx_count < hw_ep->max_packet_sz_rx) {\n\t\tlength = rx_count;\n\t\tchannel->desired_mode = 0;\n\t} else {\n\t\tlength = urb->transfer_buffer_length;\n\t}\n#endif\n\n\t \n\tval = musb_readw(epio, MUSB_RXCSR);\n\tval &= ~MUSB_RXCSR_H_REQPKT;\n\n\tif (channel->desired_mode == 0)\n\t\tval &= ~MUSB_RXCSR_H_AUTOREQ;\n\telse\n\t\tval |= MUSB_RXCSR_H_AUTOREQ;\n\tval |= MUSB_RXCSR_DMAENAB;\n\n\t \n\tif (qh->hb_mult == 1)\n\t\tval |= MUSB_RXCSR_AUTOCLEAR;\n\n\tmusb_writew(epio, MUSB_RXCSR, MUSB_RXCSR_H_WZC_BITS | val);\n\n\t \n\tdone = dma->channel_program(channel, qh->maxpacket,\n\t\t\t\t   channel->desired_mode,\n\t\t\t\t   buf, length);\n\n\tif (!done) {\n\t\tdma->channel_release(channel);\n\t\thw_ep->rx_channel = NULL;\n\t\tchannel = NULL;\n\t\tval = musb_readw(epio, MUSB_RXCSR);\n\t\tval &= ~(MUSB_RXCSR_DMAENAB\n\t\t\t | MUSB_RXCSR_H_AUTOREQ\n\t\t\t | MUSB_RXCSR_AUTOCLEAR);\n\t\tmusb_writew(epio, MUSB_RXCSR, val);\n\t}\n\n\treturn done;\n}\n#else\nstatic inline int musb_rx_dma_inventra_cppi41(struct dma_controller *dma,\n\t\t\t\t\t      struct musb_hw_ep *hw_ep,\n\t\t\t\t\t      struct musb_qh *qh,\n\t\t\t\t\t      struct urb *urb,\n\t\t\t\t\t      size_t len)\n{\n\treturn false;\n}\n\nstatic inline int musb_rx_dma_in_inventra_cppi41(struct dma_controller *dma,\n\t\t\t\t\t\t struct musb_hw_ep *hw_ep,\n\t\t\t\t\t\t struct musb_qh *qh,\n\t\t\t\t\t\t struct urb *urb,\n\t\t\t\t\t\t size_t len,\n\t\t\t\t\t\t u8 iso_err)\n{\n\treturn false;\n}\n#endif\n\n \nvoid musb_host_rx(struct musb *musb, u8 epnum)\n{\n\tstruct urb\t\t*urb;\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + epnum;\n\tstruct dma_controller\t*c = musb->dma_controller;\n\tvoid __iomem\t\t*epio = hw_ep->regs;\n\tstruct musb_qh\t\t*qh = hw_ep->in_qh;\n\tsize_t\t\t\txfer_len;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tu16\t\t\trx_csr, val;\n\tbool\t\t\tiso_err = false;\n\tbool\t\t\tdone = false;\n\tu32\t\t\tstatus;\n\tstruct dma_channel\t*dma;\n\tunsigned int sg_flags = SG_MITER_ATOMIC | SG_MITER_TO_SG;\n\n\tmusb_ep_select(mbase, epnum);\n\n\turb = next_urb(qh);\n\tdma = is_dma_capable() ? hw_ep->rx_channel : NULL;\n\tstatus = 0;\n\txfer_len = 0;\n\n\trx_csr = musb_readw(epio, MUSB_RXCSR);\n\tval = rx_csr;\n\n\tif (unlikely(!urb)) {\n\t\t \n\t\tmusb_dbg(musb, \"BOGUS RX%d ready, csr %04x, count %d\",\n\t\t\tepnum, val, musb_readw(epio, MUSB_RXCOUNT));\n\t\tmusb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);\n\t\treturn;\n\t}\n\n\ttrace_musb_urb_rx(musb, urb);\n\n\t \n\tif (rx_csr & MUSB_RXCSR_H_RXSTALL) {\n\t\tmusb_dbg(musb, \"RX end %d STALL\", epnum);\n\n\t\t \n\t\tstatus = -EPIPE;\n\n\t} else if (rx_csr & MUSB_RXCSR_H_ERROR) {\n\t\tdev_err(musb->controller, \"ep%d RX three-strikes error\", epnum);\n\n\t\t \n\t\tstatus = -ESHUTDOWN;\n\t\tmusb_writeb(epio, MUSB_RXINTERVAL, 0);\n\n\t\trx_csr &= ~MUSB_RXCSR_H_ERROR;\n\t\tmusb_writew(epio, MUSB_RXCSR, rx_csr);\n\n\t} else if (rx_csr & MUSB_RXCSR_DATAERROR) {\n\n\t\tif (USB_ENDPOINT_XFER_ISOC != qh->type) {\n\t\t\tmusb_dbg(musb, \"RX end %d NAK timeout\", epnum);\n\n\t\t\t \n\t\t\tif (usb_pipebulk(urb->pipe)\n\t\t\t\t\t&& qh->mux == 1\n\t\t\t\t\t&& !list_is_singular(&musb->in_bulk)) {\n\t\t\t\tmusb_bulk_nak_timeout(musb, hw_ep, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\trx_csr |= MUSB_RXCSR_H_WZC_BITS;\n\t\t\trx_csr &= ~MUSB_RXCSR_DATAERROR;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, rx_csr);\n\n\t\t\tgoto finish;\n\t\t} else {\n\t\t\tmusb_dbg(musb, \"RX end %d ISO data error\", epnum);\n\t\t\t \n\t\t\tiso_err = true;\n\t\t}\n\t} else if (rx_csr & MUSB_RXCSR_INCOMPRX) {\n\t\tmusb_dbg(musb, \"end %d high bandwidth incomplete ISO packet RX\",\n\t\t\t\tepnum);\n\t\tstatus = -EPROTO;\n\t}\n\n\t \n\tif (status) {\n\t\t \n\t\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t\tdma->status = MUSB_DMA_STATUS_CORE_ABORT;\n\t\t\tmusb->dma_controller->channel_abort(dma);\n\t\t\txfer_len = dma->actual_len;\n\t\t}\n\t\tmusb_h_flush_rxfifo(hw_ep, MUSB_RXCSR_CLRDATATOG);\n\t\tmusb_writeb(epio, MUSB_RXINTERVAL, 0);\n\t\tdone = true;\n\t\tgoto finish;\n\t}\n\n\tif (unlikely(dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY)) {\n\t\t \n\t\tERR(\"RX%d dma busy, csr %04x\\n\", epnum, rx_csr);\n\t\tgoto finish;\n\t}\n\n\t \n\n\t \n\tif (!musb_dma_inventra(musb) && !musb_dma_ux500(musb) &&\n\t    (rx_csr & MUSB_RXCSR_H_REQPKT)) {\n\t\t \n\t\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t\tdma->status = MUSB_DMA_STATUS_CORE_ABORT;\n\t\t\tmusb->dma_controller->channel_abort(dma);\n\t\t\txfer_len = dma->actual_len;\n\t\t\tdone = true;\n\t\t}\n\n\t\tmusb_dbg(musb, \"RXCSR%d %04x, reqpkt, len %zu%s\", epnum, rx_csr,\n\t\t\t\txfer_len, dma ? \", dma\" : \"\");\n\t\trx_csr &= ~MUSB_RXCSR_H_REQPKT;\n\n\t\tmusb_ep_select(mbase, epnum);\n\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\t\tMUSB_RXCSR_H_WZC_BITS | rx_csr);\n\t}\n\n\tif (dma && (rx_csr & MUSB_RXCSR_DMAENAB)) {\n\t\txfer_len = dma->actual_len;\n\n\t\tval &= ~(MUSB_RXCSR_DMAENAB\n\t\t\t| MUSB_RXCSR_H_AUTOREQ\n\t\t\t| MUSB_RXCSR_AUTOCLEAR\n\t\t\t| MUSB_RXCSR_RXPKTRDY);\n\t\tmusb_writew(hw_ep->regs, MUSB_RXCSR, val);\n\n\t\tif (musb_dma_inventra(musb) || musb_dma_ux500(musb) ||\n\t\t    musb_dma_cppi41(musb)) {\n\t\t\t    done = musb_rx_dma_inventra_cppi41(c, hw_ep, qh, urb, xfer_len);\n\t\t\t    musb_dbg(hw_ep->musb,\n\t\t\t\t    \"ep %d dma %s, rxcsr %04x, rxcount %d\",\n\t\t\t\t    epnum, done ? \"off\" : \"reset\",\n\t\t\t\t    musb_readw(epio, MUSB_RXCSR),\n\t\t\t\t    musb_readw(epio, MUSB_RXCOUNT));\n\t\t} else {\n\t\t\tdone = true;\n\t\t}\n\n\t} else if (urb->status == -EINPROGRESS) {\n\t\t \n\t\tif (unlikely(!(rx_csr & MUSB_RXCSR_RXPKTRDY))) {\n\t\t\tstatus = -EPROTO;\n\t\t\tERR(\"Rx interrupt with no errors or packet!\\n\");\n\n\t\t\t \n\n \n\t\t\t \n\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\tval &= ~MUSB_RXCSR_H_REQPKT;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, val);\n\t\t\tgoto finish;\n\t\t}\n\n\t\t \n\t\tif ((musb_dma_inventra(musb) || musb_dma_ux500(musb) ||\n\t\t    musb_dma_cppi41(musb)) && dma) {\n\t\t\tmusb_dbg(hw_ep->musb,\n\t\t\t\t\"RX%d count %d, buffer 0x%llx len %d/%d\",\n\t\t\t\tepnum, musb_readw(epio, MUSB_RXCOUNT),\n\t\t\t\t(unsigned long long) urb->transfer_dma\n\t\t\t\t+ urb->actual_length,\n\t\t\t\tqh->offset,\n\t\t\t\turb->transfer_buffer_length);\n\n\t\t\tif (musb_rx_dma_in_inventra_cppi41(c, hw_ep, qh, urb,\n\t\t\t\t\t\t\t   xfer_len, iso_err))\n\t\t\t\tgoto finish;\n\t\t\telse\n\t\t\t\tdev_err(musb->controller, \"error: rx_dma failed\\n\");\n\t\t}\n\n\t\tif (!dma) {\n\t\t\tunsigned int received_len;\n\n\t\t\t \n\t\t\tusb_hcd_unmap_urb_for_dma(musb->hcd, urb);\n\n\t\t\t \n\t\t\tif (!urb->transfer_buffer) {\n\t\t\t\tqh->use_sg = true;\n\t\t\t\tsg_miter_start(&qh->sg_miter, urb->sg, 1,\n\t\t\t\t\t\tsg_flags);\n\t\t\t}\n\n\t\t\tif (qh->use_sg) {\n\t\t\t\tif (!sg_miter_next(&qh->sg_miter)) {\n\t\t\t\t\tdev_err(musb->controller, \"error: sg list empty\\n\");\n\t\t\t\t\tsg_miter_stop(&qh->sg_miter);\n\t\t\t\t\tstatus = -EINVAL;\n\t\t\t\t\tdone = true;\n\t\t\t\t\tgoto finish;\n\t\t\t\t}\n\t\t\t\turb->transfer_buffer = qh->sg_miter.addr;\n\t\t\t\treceived_len = urb->actual_length;\n\t\t\t\tqh->offset = 0x0;\n\t\t\t\tdone = musb_host_packet_rx(musb, urb, epnum,\n\t\t\t\t\t\tiso_err);\n\t\t\t\t \n\t\t\t\treceived_len = urb->actual_length -\n\t\t\t\t\treceived_len;\n\t\t\t\tqh->sg_miter.consumed = received_len;\n\t\t\t\tsg_miter_stop(&qh->sg_miter);\n\t\t\t} else {\n\t\t\t\tdone = musb_host_packet_rx(musb, urb,\n\t\t\t\t\t\tepnum, iso_err);\n\t\t\t}\n\t\t\tmusb_dbg(musb, \"read %spacket\", done ? \"last \" : \"\");\n\t\t}\n\t}\n\nfinish:\n\turb->actual_length += xfer_len;\n\tqh->offset += xfer_len;\n\tif (done) {\n\t\tif (qh->use_sg) {\n\t\t\tqh->use_sg = false;\n\t\t\turb->transfer_buffer = NULL;\n\t\t}\n\n\t\tif (urb->status == -EINPROGRESS)\n\t\t\turb->status = status;\n\t\tmusb_advance_schedule(musb, urb, hw_ep, USB_DIR_IN);\n\t}\n}\n\n \nstatic int musb_schedule(\n\tstruct musb\t\t*musb,\n\tstruct musb_qh\t\t*qh,\n\tint\t\t\tis_in)\n{\n\tint\t\t\tidle = 0;\n\tint\t\t\tbest_diff;\n\tint\t\t\tbest_end, epnum;\n\tstruct musb_hw_ep\t*hw_ep = NULL;\n\tstruct list_head\t*head = NULL;\n\tu8\t\t\ttoggle;\n\tu8\t\t\ttxtype;\n\tstruct urb\t\t*urb = next_urb(qh);\n\n\t \n\tif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\n\t\thead = &musb->control;\n\t\thw_ep = musb->control_ep;\n\t\tgoto success;\n\t}\n\n\t \n\n\t \n\tbest_diff = 4096;\n\tbest_end = -1;\n\n\tfor (epnum = 1, hw_ep = musb->endpoints + 1;\n\t\t\tepnum < musb->nr_endpoints;\n\t\t\tepnum++, hw_ep++) {\n\t\tint\tdiff;\n\n\t\tif (musb_ep_get_qh(hw_ep, is_in) != NULL)\n\t\t\tcontinue;\n\n\t\tif (hw_ep == musb->bulk_ep)\n\t\t\tcontinue;\n\n\t\tif (is_in)\n\t\t\tdiff = hw_ep->max_packet_sz_rx;\n\t\telse\n\t\t\tdiff = hw_ep->max_packet_sz_tx;\n\t\tdiff -= (qh->maxpacket * qh->hb_mult);\n\n\t\tif (diff >= 0 && best_diff > diff) {\n\n\t\t\t \n\t\t\thw_ep = musb->endpoints + epnum;\n\t\t\ttoggle = usb_gettoggle(urb->dev, qh->epnum, !is_in);\n\t\t\ttxtype = (musb_readb(hw_ep->regs, MUSB_TXTYPE)\n\t\t\t\t\t>> 4) & 0x3;\n\t\t\tif (!is_in && (qh->type == USB_ENDPOINT_XFER_BULK) &&\n\t\t\t\ttoggle && (txtype == USB_ENDPOINT_XFER_ISOC))\n\t\t\t\tcontinue;\n\n\t\t\tbest_diff = diff;\n\t\t\tbest_end = epnum;\n\t\t}\n\t}\n\t \n\tif (best_end < 0 && qh->type == USB_ENDPOINT_XFER_BULK) {\n\t\thw_ep = musb->bulk_ep;\n\t\tif (is_in)\n\t\t\thead = &musb->in_bulk;\n\t\telse\n\t\t\thead = &musb->out_bulk;\n\n\t\t \n\t\tif (qh->dev)\n\t\t\tqh->intv_reg =\n\t\t\t\t(USB_SPEED_HIGH == qh->dev->speed) ? 8 : 4;\n\t\tgoto success;\n\t} else if (best_end < 0) {\n\t\tdev_err(musb->controller,\n\t\t\t\t\"%s hwep alloc failed for %dx%d\\n\",\n\t\t\t\tmusb_ep_xfertype_string(qh->type),\n\t\t\t\tqh->hb_mult, qh->maxpacket);\n\t\treturn -ENOSPC;\n\t}\n\n\tidle = 1;\n\tqh->mux = 0;\n\thw_ep = musb->endpoints + best_end;\n\tmusb_dbg(musb, \"qh %p periodic slot %d\", qh, best_end);\nsuccess:\n\tif (head) {\n\t\tidle = list_empty(head);\n\t\tlist_add_tail(&qh->ring, head);\n\t\tqh->mux = 1;\n\t}\n\tqh->hw_ep = hw_ep;\n\tqh->hep->hcpriv = qh;\n\tif (idle)\n\t\tmusb_start_urb(musb, is_in, qh);\n\treturn 0;\n}\n\nstatic int musb_urb_enqueue(\n\tstruct usb_hcd\t\t\t*hcd,\n\tstruct urb\t\t\t*urb,\n\tgfp_t\t\t\t\tmem_flags)\n{\n\tunsigned long\t\t\tflags;\n\tstruct musb\t\t\t*musb = hcd_to_musb(hcd);\n\tstruct usb_host_endpoint\t*hep = urb->ep;\n\tstruct musb_qh\t\t\t*qh;\n\tstruct usb_endpoint_descriptor\t*epd = &hep->desc;\n\tint\t\t\t\tret;\n\tunsigned\t\t\ttype_reg;\n\tunsigned\t\t\tinterval;\n\n\t \n\tif (!is_host_active(musb) || !musb->is_active)\n\t\treturn -ENODEV;\n\n\ttrace_musb_urb_enq(musb, urb);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tqh = ret ? NULL : hep->hcpriv;\n\tif (qh)\n\t\turb->hcpriv = qh;\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\t \n\tif (qh || ret)\n\t\treturn ret;\n\n\t \n\tqh = kzalloc(sizeof *qh, mem_flags);\n\tif (!qh) {\n\t\tspin_lock_irqsave(&musb->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tqh->hep = hep;\n\tqh->dev = urb->dev;\n\tINIT_LIST_HEAD(&qh->ring);\n\tqh->is_ready = 1;\n\n\tqh->maxpacket = usb_endpoint_maxp(epd);\n\tqh->type = usb_endpoint_type(epd);\n\n\t \n\tqh->hb_mult = usb_endpoint_maxp_mult(epd);\n\tif (qh->hb_mult > 1) {\n\t\tint ok = (qh->type == USB_ENDPOINT_XFER_ISOC);\n\n\t\tif (ok)\n\t\t\tok = (usb_pipein(urb->pipe) && musb->hb_iso_rx)\n\t\t\t\t|| (usb_pipeout(urb->pipe) && musb->hb_iso_tx);\n\t\tif (!ok) {\n\t\t\tdev_err(musb->controller,\n\t\t\t\t\"high bandwidth %s (%dx%d) not supported\\n\",\n\t\t\t\tmusb_ep_xfertype_string(qh->type),\n\t\t\t\tqh->hb_mult, qh->maxpacket & 0x7ff);\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto done;\n\t\t}\n\t\tqh->maxpacket &= 0x7ff;\n\t}\n\n\tqh->epnum = usb_endpoint_num(epd);\n\n\t \n\tqh->addr_reg = (u8) usb_pipedevice(urb->pipe);\n\n\t \n\ttype_reg = (qh->type << 4) | qh->epnum;\n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_LOW:\n\t\ttype_reg |= 0xc0;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\ttype_reg |= 0x80;\n\t\tbreak;\n\tdefault:\n\t\ttype_reg |= 0x40;\n\t}\n\tqh->type_reg = type_reg;\n\n\t \n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tif (urb->dev->speed <= USB_SPEED_FULL) {\n\t\t\tinterval = max_t(u8, epd->bInterval, 1);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tinterval = min_t(u8, epd->bInterval, 16);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tinterval = 0;\n\t}\n\tqh->intv_reg = interval;\n\n\t \n\tif (musb->is_multipoint) {\n\t\tstruct usb_device\t*parent = urb->dev->parent;\n\n\t\tif (parent != hcd->self.root_hub) {\n\t\t\tqh->h_addr_reg = (u8) parent->devnum;\n\n\t\t\t \n\t\t\tif (urb->dev->tt) {\n\t\t\t\tqh->h_port_reg = (u8) urb->dev->ttport;\n\t\t\t\tif (urb->dev->tt->hub)\n\t\t\t\t\tqh->h_addr_reg =\n\t\t\t\t\t\t(u8) urb->dev->tt->hub->devnum;\n\t\t\t\tif (urb->dev->tt->multi)\n\t\t\t\t\tqh->h_addr_reg |= 0x80;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&musb->lock, flags);\n\tif (hep->hcpriv || !next_urb(qh)) {\n\t\t \n\t\tkfree(qh);\n\t\tqh = NULL;\n\t\tret = 0;\n\t} else\n\t\tret = musb_schedule(musb, qh,\n\t\t\t\tepd->bEndpointAddress & USB_ENDPOINT_DIR_MASK);\n\n\tif (ret == 0) {\n\t\turb->hcpriv = qh;\n\t\t \n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\ndone:\n\tif (ret != 0) {\n\t\tspin_lock_irqsave(&musb->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t\tkfree(qh);\n\t}\n\treturn ret;\n}\n\n\n \nstatic int musb_cleanup_urb(struct urb *urb, struct musb_qh *qh)\n{\n\tstruct musb_hw_ep\t*ep = qh->hw_ep;\n\tstruct musb\t\t*musb = ep->musb;\n\tvoid __iomem\t\t*epio = ep->regs;\n\tunsigned\t\thw_end = ep->epnum;\n\tvoid __iomem\t\t*regs = ep->musb->mregs;\n\tint\t\t\tis_in = usb_pipein(urb->pipe);\n\tint\t\t\tstatus = 0;\n\tu16\t\t\tcsr;\n\tstruct dma_channel\t*dma = NULL;\n\n\tmusb_ep_select(regs, hw_end);\n\n\tif (is_dma_capable()) {\n\t\tdma = is_in ? ep->rx_channel : ep->tx_channel;\n\t\tif (dma) {\n\t\t\tstatus = ep->musb->dma_controller->channel_abort(dma);\n\t\t\tmusb_dbg(musb, \"abort %cX%d DMA for urb %p --> %d\",\n\t\t\t\tis_in ? 'R' : 'T', ep->epnum,\n\t\t\t\turb, status);\n\t\t\turb->actual_length += dma->actual_len;\n\t\t}\n\t}\n\n\t \n\tif (ep->epnum && is_in) {\n\t\t \n\t\tcsr = musb_h_flush_rxfifo(ep, 0);\n\n\t\t \n\t\tif (is_dma_capable() && dma)\n\t\t\tmusb_platform_clear_ep_rxintr(musb, ep->epnum);\n\t} else if (ep->epnum) {\n\t\tmusb_h_tx_flush_fifo(ep);\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tcsr &= ~(MUSB_TXCSR_AUTOSET\n\t\t\t| MUSB_TXCSR_DMAENAB\n\t\t\t| MUSB_TXCSR_H_RXSTALL\n\t\t\t| MUSB_TXCSR_H_NAKTIMEOUT\n\t\t\t| MUSB_TXCSR_H_ERROR\n\t\t\t| MUSB_TXCSR_TXPKTRDY);\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t \n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t \n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t} else  {\n\t\tmusb_h_ep0_flush_fifo(ep);\n\t}\n\tif (status == 0)\n\t\tmusb_advance_schedule(ep->musb, urb, ep, is_in);\n\treturn status;\n}\n\nstatic int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct musb\t\t*musb = hcd_to_musb(hcd);\n\tstruct musb_qh\t\t*qh;\n\tunsigned long\t\tflags;\n\tint\t\t\tis_in  = usb_pipein(urb->pipe);\n\tint\t\t\tret;\n\n\ttrace_musb_urb_deq(musb, urb);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tret = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (ret)\n\t\tgoto done;\n\n\tqh = urb->hcpriv;\n\tif (!qh)\n\t\tgoto done;\n\n\t \n\tif (!qh->is_ready\n\t\t\t|| urb->urb_list.prev != &qh->hep->urb_list\n\t\t\t|| musb_ep_get_qh(qh->hw_ep, is_in) != qh) {\n\t\tint\tready = qh->is_ready;\n\n\t\tqh->is_ready = 0;\n\t\tmusb_giveback(musb, urb, 0);\n\t\tqh->is_ready = ready;\n\n\t\t \n\t\tif (ready && list_empty(&qh->hep->urb_list)) {\n\t\t\tmusb_ep_set_qh(qh->hw_ep, is_in, NULL);\n\t\t\tqh->hep->hcpriv = NULL;\n\t\t\tlist_del(&qh->ring);\n\t\t\tkfree(qh);\n\t\t}\n\t} else\n\t\tret = musb_cleanup_urb(urb, qh);\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn ret;\n}\n\n \nstatic void\nmusb_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\n{\n\tu8\t\t\tis_in = hep->desc.bEndpointAddress & USB_DIR_IN;\n\tunsigned long\t\tflags;\n\tstruct musb\t\t*musb = hcd_to_musb(hcd);\n\tstruct musb_qh\t\t*qh;\n\tstruct urb\t\t*urb;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tqh = hep->hcpriv;\n\tif (qh == NULL)\n\t\tgoto exit;\n\n\t \n\n\t \n\tqh->is_ready = 0;\n\tif (musb_ep_get_qh(qh->hw_ep, is_in) == qh) {\n\t\turb = next_urb(qh);\n\n\t\t \n\t\tif (!urb->unlinked)\n\t\t\turb->status = -ESHUTDOWN;\n\n\t\t \n\t\tmusb_cleanup_urb(urb, qh);\n\n\t\t \n\t\twhile (!list_empty(&hep->urb_list)) {\n\t\t\turb = next_urb(qh);\n\t\t\turb->status = -ESHUTDOWN;\n\t\t\tmusb_advance_schedule(musb, urb, qh->hw_ep, is_in);\n\t\t}\n\t} else {\n\t\t \n\t\twhile (!list_empty(&hep->urb_list))\n\t\t\tmusb_giveback(musb, next_urb(qh), -ESHUTDOWN);\n\n\t\thep->hcpriv = NULL;\n\t\tlist_del(&qh->ring);\n\t\tkfree(qh);\n\t}\nexit:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nstatic int musb_h_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\n\treturn musb_readw(musb->mregs, MUSB_FRAME);\n}\n\nstatic int musb_h_start(struct usb_hcd *hcd)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\n\t \n\thcd->state = HC_STATE_RUNNING;\n\tmusb->port1_status = 0;\n\treturn 0;\n}\n\nstatic void musb_h_stop(struct usb_hcd *hcd)\n{\n\tmusb_stop(hcd_to_musb(hcd));\n\thcd->state = HC_STATE_HALT;\n}\n\nstatic int musb_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\tu8\t\tdevctl;\n\tint\t\tret;\n\n\tret = musb_port_suspend(musb, true);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!is_host_active(musb))\n\t\treturn 0;\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_A_SUSPEND:\n\t\treturn 0;\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\t \n\t\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\t\tif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)\n\t\t\tmusb_set_state(musb, OTG_STATE_A_WAIT_BCON);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (musb->is_active) {\n\t\tWARNING(\"trying to suspend as %s while active\\n\",\n\t\t\tmusb_otg_state_string(musb));\n\t\treturn -EBUSY;\n\t} else\n\t\treturn 0;\n}\n\nstatic int musb_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct musb *musb = hcd_to_musb(hcd);\n\n\tif (musb->config &&\n\t    musb->config->host_port_deassert_reset_at_resume)\n\t\tmusb_port_reset(musb, false);\n\n\treturn 0;\n}\n\n#ifndef CONFIG_MUSB_PIO_ONLY\n\n#define MUSB_USB_DMA_ALIGN 4\n\nstruct musb_temp_buffer {\n\tvoid *kmalloc_ptr;\n\tvoid *old_xfer_buffer;\n\tu8 data[];\n};\n\nstatic void musb_free_temp_buffer(struct urb *urb)\n{\n\tenum dma_data_direction dir;\n\tstruct musb_temp_buffer *temp;\n\tsize_t length;\n\n\tif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\n\t\treturn;\n\n\tdir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\ttemp = container_of(urb->transfer_buffer, struct musb_temp_buffer,\n\t\t\t    data);\n\n\tif (dir == DMA_FROM_DEVICE) {\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tlength = urb->transfer_buffer_length;\n\t\telse\n\t\t\tlength = urb->actual_length;\n\n\t\tmemcpy(temp->old_xfer_buffer, temp->data, length);\n\t}\n\turb->transfer_buffer = temp->old_xfer_buffer;\n\tkfree(temp->kmalloc_ptr);\n\n\turb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\n}\n\nstatic int musb_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)\n{\n\tenum dma_data_direction dir;\n\tstruct musb_temp_buffer *temp;\n\tvoid *kmalloc_ptr;\n\tsize_t kmalloc_size;\n\n\tif (urb->num_sgs || urb->sg ||\n\t    urb->transfer_buffer_length == 0 ||\n\t    !((uintptr_t)urb->transfer_buffer & (MUSB_USB_DMA_ALIGN - 1)))\n\t\treturn 0;\n\n\tdir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\n\t \n\tkmalloc_size = urb->transfer_buffer_length +\n\t\tsizeof(struct musb_temp_buffer) + MUSB_USB_DMA_ALIGN - 1;\n\n\tkmalloc_ptr = kmalloc(kmalloc_size, mem_flags);\n\tif (!kmalloc_ptr)\n\t\treturn -ENOMEM;\n\n\t \n\ttemp = PTR_ALIGN(kmalloc_ptr, MUSB_USB_DMA_ALIGN);\n\n\n\ttemp->kmalloc_ptr = kmalloc_ptr;\n\ttemp->old_xfer_buffer = urb->transfer_buffer;\n\tif (dir == DMA_TO_DEVICE)\n\t\tmemcpy(temp->data, urb->transfer_buffer,\n\t\t       urb->transfer_buffer_length);\n\turb->transfer_buffer = temp->data;\n\n\turb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\n\n\treturn 0;\n}\n\nstatic int musb_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t      gfp_t mem_flags)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\tint ret;\n\n\t \n\tif (musb->hwvers < MUSB_HWVERS_1800)\n\t\treturn usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n\n\tret = musb_alloc_temp_buffer(urb, mem_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n\tif (ret)\n\t\tmusb_free_temp_buffer(urb);\n\n\treturn ret;\n}\n\nstatic void musb_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct musb\t*musb = hcd_to_musb(hcd);\n\n\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n\n\t \n\tif (musb->hwvers < MUSB_HWVERS_1800)\n\t\treturn;\n\n\tmusb_free_temp_buffer(urb);\n}\n#endif  \n\nstatic const struct hc_driver musb_hc_driver = {\n\t.description\t\t= \"musb-hcd\",\n\t.product_desc\t\t= \"MUSB HDRC host driver\",\n\t.hcd_priv_size\t\t= sizeof(struct musb *),\n\t.flags\t\t\t= HCD_USB2 | HCD_DMA | HCD_MEMORY,\n\n\t \n\n\t.start\t\t\t= musb_h_start,\n\t.stop\t\t\t= musb_h_stop,\n\n\t.get_frame_number\t= musb_h_get_frame_number,\n\n\t.urb_enqueue\t\t= musb_urb_enqueue,\n\t.urb_dequeue\t\t= musb_urb_dequeue,\n\t.endpoint_disable\t= musb_h_disable,\n\n#ifndef CONFIG_MUSB_PIO_ONLY\n\t.map_urb_for_dma\t= musb_map_urb_for_dma,\n\t.unmap_urb_for_dma\t= musb_unmap_urb_for_dma,\n#endif\n\n\t.hub_status_data\t= musb_hub_status_data,\n\t.hub_control\t\t= musb_hub_control,\n\t.bus_suspend\t\t= musb_bus_suspend,\n\t.bus_resume\t\t= musb_bus_resume,\n\t \n\t \n};\n\nint musb_host_alloc(struct musb *musb)\n{\n\tstruct device\t*dev = musb->controller;\n\n\t \n\tmusb->hcd = usb_create_hcd(&musb_hc_driver, dev, dev_name(dev));\n\tif (!musb->hcd)\n\t\treturn -EINVAL;\n\n\t*musb->hcd->hcd_priv = (unsigned long) musb;\n\tmusb->hcd->self.uses_pio_for_control = 1;\n\tmusb->hcd->uses_new_polling = 1;\n\tmusb->hcd->has_tt = 1;\n\n\treturn 0;\n}\n\nvoid musb_host_cleanup(struct musb *musb)\n{\n\tif (musb->port_mode == MUSB_PERIPHERAL)\n\t\treturn;\n\tusb_remove_hcd(musb->hcd);\n}\n\nvoid musb_host_free(struct musb *musb)\n{\n\tusb_put_hcd(musb->hcd);\n}\n\nint musb_host_setup(struct musb *musb, int power_budget)\n{\n\tint ret;\n\tstruct usb_hcd *hcd = musb->hcd;\n\n\tif (musb->port_mode == MUSB_HOST) {\n\t\tMUSB_HST_MODE(musb);\n\t\tmusb_set_state(musb, OTG_STATE_A_IDLE);\n\t}\n\n\tif (musb->xceiv) {\n\t\totg_set_host(musb->xceiv->otg, &hcd->self);\n\t\tmusb->xceiv->otg->host = &hcd->self;\n\t} else {\n\t\tphy_set_mode(musb->phy, PHY_MODE_USB_HOST);\n\t}\n\n\t \n\thcd->self.otg_port = 0;\n\thcd->power_budget = 2 * (power_budget ? : 250);\n\thcd->skip_phy_initialization = 1;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n}\n\nvoid musb_host_resume_root_hub(struct musb *musb)\n{\n\tusb_hcd_resume_root_hub(musb->hcd);\n}\n\nvoid musb_host_poke_root_hub(struct musb *musb)\n{\n\tMUSB_HST_MODE(musb);\n\tif (musb->hcd->status_urb)\n\t\tusb_hcd_poll_rh_status(musb->hcd);\n\telse\n\t\tusb_hcd_resume_root_hub(musb->hcd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}