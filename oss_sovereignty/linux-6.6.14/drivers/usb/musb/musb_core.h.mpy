{
  "module_name": "musb_core.h",
  "hash_id": "e1801c68c27f771a191361ec263b76b1c0adc080f46a4fab1662223ddb5c6b26",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_core.h",
  "human_readable_source": " \n \n\n#ifndef __MUSB_CORE_H__\n#define __MUSB_CORE_H__\n\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/musb.h>\n#include <linux/phy/phy.h>\n#include <linux/workqueue.h>\n\nstruct musb;\nstruct musb_hw_ep;\nstruct musb_ep;\nstruct musb_qh;\n\n \n#define MUSB_HWVERS_MAJOR(x)\t((x >> 10) & 0x1f)\n#define MUSB_HWVERS_MINOR(x)\t(x & 0x3ff)\n#define MUSB_HWVERS_RC\t\t0x8000\n#define MUSB_HWVERS_1300\t0x52C\n#define MUSB_HWVERS_1400\t0x590\n#define MUSB_HWVERS_1800\t0x720\n#define MUSB_HWVERS_1900\t0x784\n#define MUSB_HWVERS_2000\t0x800\n\n#include \"musb_debug.h\"\n#include \"musb_dma.h\"\n\n#include \"musb_io.h\"\n\n#include \"musb_gadget.h\"\n#include <linux/usb/hcd.h>\n#include \"musb_host.h\"\n\n \n#define is_peripheral_active(m)\t\t(!(m)->is_host)\n#define is_host_active(m)\t\t((m)->is_host)\n\n \n\n#ifndef MUSB_C_NUM_EPS\n#define MUSB_C_NUM_EPS ((u8)16)\n#endif\n\n#ifndef MUSB_MAX_END0_PACKET\n#define MUSB_MAX_END0_PACKET ((u16)MUSB_EP0_FIFOSIZE)\n#endif\n\n \nenum musb_h_ep0_state {\n\tMUSB_EP0_IDLE,\n\tMUSB_EP0_START,\t\t\t \n\tMUSB_EP0_IN,\t\t\t \n\tMUSB_EP0_OUT,\t\t\t \n\tMUSB_EP0_STATUS,\t\t \n} __attribute__ ((packed));\n\n \nenum musb_g_ep0_state {\n\tMUSB_EP0_STAGE_IDLE,\t\t \n\tMUSB_EP0_STAGE_SETUP,\t\t \n\tMUSB_EP0_STAGE_TX,\t\t \n\tMUSB_EP0_STAGE_RX,\t\t \n\tMUSB_EP0_STAGE_STATUSIN,\t \n\tMUSB_EP0_STAGE_STATUSOUT,\t \n\tMUSB_EP0_STAGE_ACKWAIT,\t\t \n} __attribute__ ((packed));\n\n \n#define OTG_TIME_A_WAIT_VRISE\t100\t\t \n#define OTG_TIME_A_WAIT_BCON\t1100\t\t \n#define OTG_TIME_A_AIDL_BDIS\t200\t\t \n#define OTG_TIME_B_ASE0_BRST\t100\t\t \n\n \n\n#define MUSB_HST_MODE(_musb)\\\n\t{ (_musb)->is_host = true; }\n#define MUSB_DEV_MODE(_musb) \\\n\t{ (_musb)->is_host = false; }\n\n#define test_devctl_hst_mode(_x) \\\n\t(musb_readb((_x)->mregs, MUSB_DEVCTL)&MUSB_DEVCTL_HM)\n\n#define MUSB_MODE(musb) ((musb)->is_host ? \"Host\" : \"Peripheral\")\n\n \n\nstruct musb_io;\n\n \nstruct musb_platform_ops {\n\n#define MUSB_G_NO_SKB_RESERVE\tBIT(9)\n#define MUSB_DA8XX\t\tBIT(8)\n#define MUSB_PRESERVE_SESSION\tBIT(7)\n#define MUSB_DMA_UX500\t\tBIT(6)\n#define MUSB_DMA_CPPI41\t\tBIT(5)\n#define MUSB_DMA_CPPI\t\tBIT(4)\n#define MUSB_DMA_TUSB_OMAP\tBIT(3)\n#define MUSB_DMA_INVENTRA\tBIT(2)\n#define MUSB_IN_TUSB\t\tBIT(1)\n#define MUSB_INDEXED_EP\t\tBIT(0)\n\tu32\tquirks;\n\n\tint\t(*init)(struct musb *musb);\n\tint\t(*exit)(struct musb *musb);\n\n\tvoid\t(*enable)(struct musb *musb);\n\tvoid\t(*disable)(struct musb *musb);\n\n\tu32\t(*ep_offset)(u8 epnum, u16 offset);\n\tvoid\t(*ep_select)(void __iomem *mbase, u8 epnum);\n\tu16\tfifo_mode;\n\tu32\t(*fifo_offset)(u8 epnum);\n\tu32\t(*busctl_offset)(u8 epnum, u16 offset);\n\tu8\t(*readb)(void __iomem *addr, u32 offset);\n\tvoid\t(*writeb)(void __iomem *addr, u32 offset, u8 data);\n\tu8\t(*clearb)(void __iomem *addr, u32 offset);\n\tu16\t(*readw)(void __iomem *addr, u32 offset);\n\tvoid\t(*writew)(void __iomem *addr, u32 offset, u16 data);\n\tu16\t(*clearw)(void __iomem *addr, u32 offset);\n\tvoid\t(*read_fifo)(struct musb_hw_ep *hw_ep, u16 len, u8 *buf);\n\tvoid\t(*write_fifo)(struct musb_hw_ep *hw_ep, u16 len, const u8 *buf);\n\tu16\t(*get_toggle)(struct musb_qh *qh, int is_out);\n\tu16\t(*set_toggle)(struct musb_qh *qh, int is_out, struct urb *urb);\n\tstruct dma_controller *\n\t\t(*dma_init) (struct musb *musb, void __iomem *base);\n\tvoid\t(*dma_exit)(struct dma_controller *c);\n\tint\t(*set_mode)(struct musb *musb, u8 mode);\n\tvoid\t(*try_idle)(struct musb *musb, unsigned long timeout);\n\tint\t(*recover)(struct musb *musb);\n\n\tint\t(*vbus_status)(struct musb *musb);\n\tvoid\t(*set_vbus)(struct musb *musb, int on);\n\n\tvoid\t(*pre_root_reset_end)(struct musb *musb);\n\tvoid\t(*post_root_reset_end)(struct musb *musb);\n\tint\t(*phy_callback)(enum musb_vbus_id_status status);\n\tvoid\t(*clear_ep_rxintr)(struct musb *musb, int epnum);\n};\n\n \nstruct musb_hw_ep {\n\tstruct musb\t\t*musb;\n\tvoid __iomem\t\t*fifo;\n\tvoid __iomem\t\t*regs;\n\n#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)\n\tvoid __iomem\t\t*conf;\n#endif\n\n\t \n\tu8\t\t\tepnum;\n\n\t \n\tbool\t\t\tis_shared_fifo;\n\tbool\t\t\ttx_double_buffered;\n\tbool\t\t\trx_double_buffered;\n\tu16\t\t\tmax_packet_sz_tx;\n\tu16\t\t\tmax_packet_sz_rx;\n\n\tstruct dma_channel\t*tx_channel;\n\tstruct dma_channel\t*rx_channel;\n\n#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)\n\t \n\tdma_addr_t\t\tfifo_async;\n\tdma_addr_t\t\tfifo_sync;\n\tvoid __iomem\t\t*fifo_sync_va;\n#endif\n\n\t \n\tstruct musb_qh\t\t*in_qh;\n\tstruct musb_qh\t\t*out_qh;\n\n\tu8\t\t\trx_reinit;\n\tu8\t\t\ttx_reinit;\n\n\t \n\tstruct musb_ep\t\tep_in;\t\t\t \n\tstruct musb_ep\t\tep_out;\t\t\t \n};\n\nstatic inline struct musb_request *next_in_request(struct musb_hw_ep *hw_ep)\n{\n\treturn next_request(&hw_ep->ep_in);\n}\n\nstatic inline struct musb_request *next_out_request(struct musb_hw_ep *hw_ep)\n{\n\treturn next_request(&hw_ep->ep_out);\n}\n\nstruct musb_csr_regs {\n\t \n\tu16 txmaxp, txcsr, rxmaxp, rxcsr;\n\tu16 rxfifoadd, txfifoadd;\n\tu8 txtype, txinterval, rxtype, rxinterval;\n\tu8 rxfifosz, txfifosz;\n\tu8 txfunaddr, txhubaddr, txhubport;\n\tu8 rxfunaddr, rxhubaddr, rxhubport;\n};\n\nstruct musb_context_registers {\n\n\tu8 power;\n\tu8 intrusbe;\n\tu16 frame;\n\tu8 index, testmode;\n\n\tu8 devctl, busctl, misc;\n\tu32 otg_interfsel;\n\n\tstruct musb_csr_regs index_regs[MUSB_C_NUM_EPS];\n};\n\n \nstruct musb {\n\t \n\tspinlock_t\t\tlock;\n\tspinlock_t\t\tlist_lock;\t \n\n\tstruct musb_io\t\tio;\n\tconst struct musb_platform_ops *ops;\n\tstruct musb_context_registers context;\n\n\tirqreturn_t\t\t(*isr)(int, void *);\n\tstruct delayed_work\tirq_work;\n\tstruct delayed_work\tdeassert_reset_work;\n\tstruct delayed_work\tfinish_resume_work;\n\tstruct delayed_work\tgadget_work;\n\tu16\t\t\thwvers;\n\n\tu16\t\t\tintrrxe;\n\tu16\t\t\tintrtxe;\n \n#define MUSB_PORT_STAT_RESUME\t(1 << 31)\n\n\tu32\t\t\tport1_status;\n\n\tunsigned long\t\trh_timer;\n\n\tenum musb_h_ep0_state\tep0_stage;\n\n\t \n\tstruct musb_hw_ep\t*bulk_ep;\n\n\tstruct list_head\tcontrol;\t \n\tstruct list_head\tin_bulk;\t \n\tstruct list_head\tout_bulk;\t \n\tstruct list_head\tpending_list;\t \n\n\tstruct timer_list\totg_timer;\n\tstruct timer_list\tdev_timer;\n\tstruct notifier_block\tnb;\n\n\tstruct dma_controller\t*dma_controller;\n\n\tstruct device\t\t*controller;\n\tvoid __iomem\t\t*ctrl_base;\n\tvoid __iomem\t\t*mregs;\n\n#if IS_ENABLED(CONFIG_USB_MUSB_TUSB6010)\n\tdma_addr_t\t\tasync;\n\tdma_addr_t\t\tsync;\n\tvoid __iomem\t\t*sync_va;\n\tu8\t\t\ttusb_revision;\n#endif\n\n\t \n\tu8\t\t\tint_usb;\n\tu16\t\t\tint_rx;\n\tu16\t\t\tint_tx;\n\n\tstruct usb_phy\t\t*xceiv;\n\tstruct phy\t\t*phy;\n\n\tenum usb_otg_state\totg_state;\n\n\tint nIrq;\n\tunsigned\t\tirq_wake:1;\n\n\tstruct musb_hw_ep\t endpoints[MUSB_C_NUM_EPS];\n#define control_ep\t\tendpoints\n\n#define VBUSERR_RETRY_COUNT\t3\n\tu16\t\t\tvbuserr_retry;\n\tu16 epmask;\n\tu8 nr_endpoints;\n\n\tu8\t\t\tmin_power;\t \n\n\tenum musb_mode\t\tport_mode;\n\tbool\t\t\tsession;\n\tunsigned long\t\tquirk_retries;\n\tbool\t\t\tis_host;\n\n\tint\t\t\ta_wait_bcon;\t \n\tunsigned long\t\tidle_timeout;\t \n\n\tunsigned\t\tis_initialized:1;\n\tunsigned\t\tis_runtime_suspended:1;\n\n\t \n\tunsigned\t\tis_active:1;\n\n\tunsigned is_multipoint:1;\n\n\tunsigned\t\thb_iso_rx:1;\t \n\tunsigned\t\thb_iso_tx:1;\t \n\tunsigned\t\tdyn_fifo:1;\t \n\n\tunsigned\t\tbulk_split:1;\n#define\tcan_bulk_split(musb, type) \\\n\t(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_split)\n\n\tunsigned\t\tbulk_combine:1;\n#define\tcan_bulk_combine(musb, type) \\\n\t(((type) == USB_ENDPOINT_XFER_BULK) && (musb)->bulk_combine)\n\n\t \n\tunsigned\t\tis_suspended:1;\n\n\t \n\tunsigned\t\tmay_wakeup:1;\n\n\t \n\tunsigned\t\tis_self_powered:1;\n\tunsigned\t\tis_bus_powered:1;\n\n\tunsigned\t\tset_address:1;\n\tunsigned\t\ttest_mode:1;\n\tunsigned\t\tsoftconnect:1;\n\n\tunsigned\t\tflush_irq_work:1;\n\n\tu8\t\t\taddress;\n\tu8\t\t\ttest_mode_nr;\n\tu16\t\t\tackpend;\t\t \n\tenum musb_g_ep0_state\tep0_state;\n\tstruct usb_gadget\tg;\t\t\t \n\tstruct usb_gadget_driver *gadget_driver;\t \n\tstruct usb_hcd\t\t*hcd;\t\t\t \n\n\tconst struct musb_hdrc_config *config;\n\n\tint\t\t\txceiv_old_state;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry\t\t*debugfs_root;\n#endif\n};\n\n \n#include \"musb_regs.h\"\n\nstatic inline struct musb *gadget_to_musb(struct usb_gadget *g)\n{\n\treturn container_of(g, struct musb, g);\n}\n\nstatic inline char *musb_ep_xfertype_string(u8 type)\n{\n\tchar *s;\n\n\tswitch (type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\ts = \"ctrl\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ts = \"iso\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\ts = \"bulk\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ts = \"int\";\n\t\tbreak;\n\tdefault:\n\t\ts = \"\";\n\t\tbreak;\n\t}\n\treturn s;\n}\n\nstatic inline int musb_read_fifosize(struct musb *musb,\n\t\tstruct musb_hw_ep *hw_ep, u8 epnum)\n{\n\tvoid __iomem *mbase = musb->mregs;\n\tu8 reg = 0;\n\n\t \n\treg = musb_readb(mbase, musb->io.ep_offset(epnum, MUSB_FIFOSIZE));\n\t \n\tif (!reg)\n\t\treturn -ENODEV;\n\n\tmusb->nr_endpoints++;\n\tmusb->epmask |= (1 << epnum);\n\n\thw_ep->max_packet_sz_tx = 1 << (reg & 0x0f);\n\n\t \n\tif ((reg & 0xf0) == 0xf0) {\n\t\thw_ep->max_packet_sz_rx = hw_ep->max_packet_sz_tx;\n\t\thw_ep->is_shared_fifo = true;\n\t\treturn 0;\n\t} else {\n\t\thw_ep->max_packet_sz_rx = 1 << ((reg & 0xf0) >> 4);\n\t\thw_ep->is_shared_fifo = false;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void musb_configure_ep0(struct musb *musb)\n{\n\tmusb->endpoints[0].max_packet_sz_tx = MUSB_EP0_FIFOSIZE;\n\tmusb->endpoints[0].max_packet_sz_rx = MUSB_EP0_FIFOSIZE;\n\tmusb->endpoints[0].is_shared_fifo = true;\n}\n\n \n\nextern const char musb_driver_name[];\n\nextern void musb_stop(struct musb *musb);\nextern void musb_start(struct musb *musb);\n\nextern void musb_write_fifo(struct musb_hw_ep *ep, u16 len, const u8 *src);\nextern void musb_read_fifo(struct musb_hw_ep *ep, u16 len, u8 *dst);\n\nextern int musb_set_host(struct musb *musb);\nextern int musb_set_peripheral(struct musb *musb);\n\nextern void musb_load_testpacket(struct musb *);\n\nextern irqreturn_t musb_interrupt(struct musb *);\n\nextern void musb_hnp_stop(struct musb *musb);\n\nint musb_queue_resume_work(struct musb *musb,\n\t\t\t   int (*callback)(struct musb *musb, void *data),\n\t\t\t   void *data);\n\nstatic inline void musb_platform_set_vbus(struct musb *musb, int is_on)\n{\n\tif (musb->ops->set_vbus)\n\t\tmusb->ops->set_vbus(musb, is_on);\n}\n\nstatic inline void musb_platform_enable(struct musb *musb)\n{\n\tif (musb->ops->enable)\n\t\tmusb->ops->enable(musb);\n}\n\nstatic inline void musb_platform_disable(struct musb *musb)\n{\n\tif (musb->ops->disable)\n\t\tmusb->ops->disable(musb);\n}\n\nstatic inline int musb_platform_set_mode(struct musb *musb, u8 mode)\n{\n\tif (!musb->ops->set_mode)\n\t\treturn 0;\n\n\treturn musb->ops->set_mode(musb, mode);\n}\n\nstatic inline void musb_platform_try_idle(struct musb *musb,\n\t\tunsigned long timeout)\n{\n\tif (musb->ops->try_idle)\n\t\tmusb->ops->try_idle(musb, timeout);\n}\n\nstatic inline int  musb_platform_recover(struct musb *musb)\n{\n\tif (!musb->ops->recover)\n\t\treturn 0;\n\n\treturn musb->ops->recover(musb);\n}\n\nstatic inline int musb_platform_get_vbus_status(struct musb *musb)\n{\n\tif (!musb->ops->vbus_status)\n\t\treturn -EINVAL;\n\n\treturn musb->ops->vbus_status(musb);\n}\n\nstatic inline int musb_platform_init(struct musb *musb)\n{\n\tif (!musb->ops->init)\n\t\treturn -EINVAL;\n\n\treturn musb->ops->init(musb);\n}\n\nstatic inline int musb_platform_exit(struct musb *musb)\n{\n\tif (!musb->ops->exit)\n\t\treturn -EINVAL;\n\n\treturn musb->ops->exit(musb);\n}\n\nstatic inline void musb_platform_pre_root_reset_end(struct musb *musb)\n{\n\tif (musb->ops->pre_root_reset_end)\n\t\tmusb->ops->pre_root_reset_end(musb);\n}\n\nstatic inline void musb_platform_post_root_reset_end(struct musb *musb)\n{\n\tif (musb->ops->post_root_reset_end)\n\t\tmusb->ops->post_root_reset_end(musb);\n}\n\nstatic inline void musb_platform_clear_ep_rxintr(struct musb *musb, int epnum)\n{\n\tif (musb->ops->clear_ep_rxintr)\n\t\tmusb->ops->clear_ep_rxintr(musb, epnum);\n}\n\nstatic inline void musb_set_state(struct musb *musb,\n\t\t\t\t  enum usb_otg_state otg_state)\n{\n\tif (musb->xceiv)\n\t\tmusb->xceiv->otg->state = otg_state;\n\telse\n\t\tmusb->otg_state = otg_state;\n}\n\nstatic inline enum usb_otg_state musb_get_state(struct musb *musb)\n{\n\tif (musb->xceiv)\n\t\treturn musb->xceiv->otg->state;\n\n\treturn musb->otg_state;\n}\n\nstatic inline const char *musb_otg_state_string(struct musb *musb)\n{\n\treturn usb_otg_state_string(musb_get_state(musb));\n}\n\n \nextern enum musb_mode musb_get_mode(struct device *dev);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}