{
  "module_name": "musb_gadget.c",
  "hash_id": "96fa10f68a3aa0edabcf87fadea0b93926478dabf1d7d10611deaecbe1976779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_gadget.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include \"musb_core.h\"\n#include \"musb_trace.h\"\n\n\n \n\n#define is_buffer_mapped(req) (is_dma_capable() && \\\n\t\t\t\t\t(req->map_state != UN_MAPPED))\n\n \n\nstatic inline void map_dma_buffer(struct musb_request *request,\n\t\t\tstruct musb *musb, struct musb_ep *musb_ep)\n{\n\tint compatible = true;\n\tstruct dma_controller *dma = musb->dma_controller;\n\n\trequest->map_state = UN_MAPPED;\n\n\tif (!is_dma_capable() || !musb_ep->dma)\n\t\treturn;\n\n\t \n\tif (dma->is_compatible)\n\t\tcompatible = dma->is_compatible(musb_ep->dma,\n\t\t\t\tmusb_ep->packet_sz, request->request.buf,\n\t\t\t\trequest->request.length);\n\tif (!compatible)\n\t\treturn;\n\n\tif (request->request.dma == DMA_ADDR_INVALID) {\n\t\tdma_addr_t dma_addr;\n\t\tint ret;\n\n\t\tdma_addr = dma_map_single(\n\t\t\t\tmusb->controller,\n\t\t\t\trequest->request.buf,\n\t\t\t\trequest->request.length,\n\t\t\t\trequest->tx\n\t\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t\t: DMA_FROM_DEVICE);\n\t\tret = dma_mapping_error(musb->controller, dma_addr);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\trequest->request.dma = dma_addr;\n\t\trequest->map_state = MUSB_MAPPED;\n\t} else {\n\t\tdma_sync_single_for_device(musb->controller,\n\t\t\trequest->request.dma,\n\t\t\trequest->request.length,\n\t\t\trequest->tx\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t\trequest->map_state = PRE_MAPPED;\n\t}\n}\n\n \nstatic inline void unmap_dma_buffer(struct musb_request *request,\n\t\t\t\tstruct musb *musb)\n{\n\tstruct musb_ep *musb_ep = request->ep;\n\n\tif (!is_buffer_mapped(request) || !musb_ep->dma)\n\t\treturn;\n\n\tif (request->request.dma == DMA_ADDR_INVALID) {\n\t\tdev_vdbg(musb->controller,\n\t\t\t\t\"not unmapping a never mapped buffer\\n\");\n\t\treturn;\n\t}\n\tif (request->map_state == MUSB_MAPPED) {\n\t\tdma_unmap_single(musb->controller,\n\t\t\trequest->request.dma,\n\t\t\trequest->request.length,\n\t\t\trequest->tx\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t\trequest->request.dma = DMA_ADDR_INVALID;\n\t} else {  \n\t\tdma_sync_single_for_cpu(musb->controller,\n\t\t\trequest->request.dma,\n\t\t\trequest->request.length,\n\t\t\trequest->tx\n\t\t\t\t? DMA_TO_DEVICE\n\t\t\t\t: DMA_FROM_DEVICE);\n\t}\n\trequest->map_state = UN_MAPPED;\n}\n\n \nvoid musb_g_giveback(\n\tstruct musb_ep\t\t*ep,\n\tstruct usb_request\t*request,\n\tint\t\t\tstatus)\n__releases(ep->musb->lock)\n__acquires(ep->musb->lock)\n{\n\tstruct musb_request\t*req;\n\tstruct musb\t\t*musb;\n\tint\t\t\tbusy = ep->busy;\n\n\treq = to_musb_request(request);\n\n\tlist_del(&req->list);\n\tif (req->request.status == -EINPROGRESS)\n\t\treq->request.status = status;\n\tmusb = req->musb;\n\n\tep->busy = 1;\n\tspin_unlock(&musb->lock);\n\n\tif (!dma_mapping_error(&musb->g.dev, request->dma))\n\t\tunmap_dma_buffer(req, musb);\n\n\ttrace_musb_req_gb(req);\n\tusb_gadget_giveback_request(&req->ep->end_point, &req->request);\n\tspin_lock(&musb->lock);\n\tep->busy = busy;\n}\n\n \n\n \nstatic void nuke(struct musb_ep *ep, const int status)\n{\n\tstruct musb\t\t*musb = ep->musb;\n\tstruct musb_request\t*req = NULL;\n\tvoid __iomem *epio = ep->musb->endpoints[ep->current_epnum].regs;\n\n\tep->busy = 1;\n\n\tif (is_dma_capable() && ep->dma) {\n\t\tstruct dma_controller\t*c = ep->musb->dma_controller;\n\t\tint value;\n\n\t\tif (ep->is_in) {\n\t\t\t \n\t\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\t\t    MUSB_TXCSR_DMAMODE | MUSB_TXCSR_FLUSHFIFO);\n\t\t\tmusb_writew(epio, MUSB_TXCSR,\n\t\t\t\t\t0 | MUSB_TXCSR_FLUSHFIFO);\n\t\t} else {\n\t\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\t\t\t0 | MUSB_RXCSR_FLUSHFIFO);\n\t\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\t\t\t0 | MUSB_RXCSR_FLUSHFIFO);\n\t\t}\n\n\t\tvalue = c->channel_abort(ep->dma);\n\t\tmusb_dbg(musb, \"%s: abort DMA --> %d\", ep->name, value);\n\t\tc->channel_release(ep->dma);\n\t\tep->dma = NULL;\n\t}\n\n\twhile (!list_empty(&ep->req_list)) {\n\t\treq = list_first_entry(&ep->req_list, struct musb_request, list);\n\t\tmusb_g_giveback(ep, &req->request, status);\n\t}\n}\n\n \n\n \n\n \n\nstatic inline int max_ep_writesize(struct musb *musb, struct musb_ep *ep)\n{\n\tif (can_bulk_split(musb, ep->type))\n\t\treturn ep->hw_ep->max_packet_sz_tx;\n\telse\n\t\treturn ep->packet_sz;\n}\n\n \nstatic void txstate(struct musb *musb, struct musb_request *req)\n{\n\tu8\t\t\tepnum = req->epnum;\n\tstruct musb_ep\t\t*musb_ep;\n\tvoid __iomem\t\t*epio = musb->endpoints[epnum].regs;\n\tstruct usb_request\t*request;\n\tu16\t\t\tfifo_count = 0, csr;\n\tint\t\t\tuse_dma = 0;\n\n\tmusb_ep = req->ep;\n\n\t \n\tif (!musb_ep->desc) {\n\t\tmusb_dbg(musb, \"ep:%s disabled - ignore request\",\n\t\t\t\t\t\tmusb_ep->end_point.name);\n\t\treturn;\n\t}\n\n\t \n\tif (dma_channel_status(musb_ep->dma) == MUSB_DMA_STATUS_BUSY) {\n\t\tmusb_dbg(musb, \"dma pending...\");\n\t\treturn;\n\t}\n\n\t \n\tcsr = musb_readw(epio, MUSB_TXCSR);\n\n\trequest = &req->request;\n\tfifo_count = min(max_ep_writesize(musb, musb_ep),\n\t\t\t(int)(request->length - request->actual));\n\n\tif (csr & MUSB_TXCSR_TXPKTRDY) {\n\t\tmusb_dbg(musb, \"%s old packet still ready , txcsr %03x\",\n\t\t\t\tmusb_ep->end_point.name, csr);\n\t\treturn;\n\t}\n\n\tif (csr & MUSB_TXCSR_P_SENDSTALL) {\n\t\tmusb_dbg(musb, \"%s stalling, txcsr %03x\",\n\t\t\t\tmusb_ep->end_point.name, csr);\n\t\treturn;\n\t}\n\n\tmusb_dbg(musb, \"hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x\",\n\t\t\tepnum, musb_ep->packet_sz, fifo_count,\n\t\t\tcsr);\n\n#ifndef\tCONFIG_MUSB_PIO_ONLY\n\tif (is_buffer_mapped(req)) {\n\t\tstruct dma_controller\t*c = musb->dma_controller;\n\t\tsize_t request_size;\n\n\t\t \n\t\trequest_size = min_t(size_t, request->length - request->actual,\n\t\t\t\t\tmusb_ep->dma->max_len);\n\n\t\tuse_dma = (request->dma != DMA_ADDR_INVALID && request_size);\n\n\t\t \n\n\t\tif (musb_dma_inventra(musb) || musb_dma_ux500(musb)) {\n\t\t\tif (request_size < musb_ep->packet_sz)\n\t\t\t\tmusb_ep->dma->desired_mode = 0;\n\t\t\telse\n\t\t\t\tmusb_ep->dma->desired_mode = 1;\n\n\t\t\tuse_dma = use_dma && c->channel_program(\n\t\t\t\t\tmusb_ep->dma, musb_ep->packet_sz,\n\t\t\t\t\tmusb_ep->dma->desired_mode,\n\t\t\t\t\trequest->dma + request->actual, request_size);\n\t\t\tif (use_dma) {\n\t\t\t\tif (musb_ep->dma->desired_mode == 0) {\n\t\t\t\t\t \n\t\t\t\t\tcsr &= ~(MUSB_TXCSR_AUTOSET\n\t\t\t\t\t\t| MUSB_TXCSR_DMAENAB);\n\t\t\t\t\tmusb_writew(epio, MUSB_TXCSR, csr\n\t\t\t\t\t\t| MUSB_TXCSR_P_WZC_BITS);\n\t\t\t\t\tcsr &= ~MUSB_TXCSR_DMAMODE;\n\t\t\t\t\tcsr |= (MUSB_TXCSR_DMAENAB |\n\t\t\t\t\t\t\tMUSB_TXCSR_MODE);\n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\tcsr |= (MUSB_TXCSR_DMAENAB\n\t\t\t\t\t\t\t| MUSB_TXCSR_DMAMODE\n\t\t\t\t\t\t\t| MUSB_TXCSR_MODE);\n\t\t\t\t\t \n\t\t\t\t\tif (!musb_ep->hb_mult ||\n\t\t\t\t\t    can_bulk_split(musb,\n\t\t\t\t\t\t\t   musb_ep->type))\n\t\t\t\t\t\tcsr |= MUSB_TXCSR_AUTOSET;\n\t\t\t\t}\n\t\t\t\tcsr &= ~MUSB_TXCSR_P_UNDERRUN;\n\n\t\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\t}\n\t\t}\n\n\t\tif (is_cppi_enabled(musb)) {\n\t\t\t \n\t\t\tcsr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);\n\t\t\tcsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE |\n\t\t\t\tMUSB_TXCSR_MODE;\n\t\t\tmusb_writew(epio, MUSB_TXCSR, (MUSB_TXCSR_P_WZC_BITS &\n\t\t\t\t\t\t~MUSB_TXCSR_P_UNDERRUN) | csr);\n\n\t\t\t \n\t\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\n\t\t\t \n\t\t\t \n\t\t\tuse_dma = use_dma && c->channel_program(\n\t\t\t\t\tmusb_ep->dma, musb_ep->packet_sz,\n\t\t\t\t\t0,\n\t\t\t\t\trequest->dma + request->actual,\n\t\t\t\t\trequest_size);\n\t\t\tif (!use_dma) {\n\t\t\t\tc->channel_release(musb_ep->dma);\n\t\t\t\tmusb_ep->dma = NULL;\n\t\t\t\tcsr &= ~MUSB_TXCSR_DMAENAB;\n\t\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\t\t \n\t\t\t}\n\t\t} else if (tusb_dma_omap(musb))\n\t\t\tuse_dma = use_dma && c->channel_program(\n\t\t\t\t\tmusb_ep->dma, musb_ep->packet_sz,\n\t\t\t\t\trequest->zero,\n\t\t\t\t\trequest->dma + request->actual,\n\t\t\t\t\trequest_size);\n\t}\n#endif\n\n\tif (!use_dma) {\n\t\t \n\t\tunmap_dma_buffer(req, musb);\n\n\t\tmusb_write_fifo(musb_ep->hw_ep, fifo_count,\n\t\t\t\t(u8 *) (request->buf + request->actual));\n\t\trequest->actual += fifo_count;\n\t\tcsr |= MUSB_TXCSR_TXPKTRDY;\n\t\tcsr &= ~MUSB_TXCSR_P_UNDERRUN;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t}\n\n\t \n\tmusb_dbg(musb, \"%s TX/IN %s len %d/%d, txcsr %04x, fifo %d/%d\",\n\t\t\tmusb_ep->end_point.name, use_dma ? \"dma\" : \"pio\",\n\t\t\trequest->actual, request->length,\n\t\t\tmusb_readw(epio, MUSB_TXCSR),\n\t\t\tfifo_count,\n\t\t\tmusb_readw(epio, MUSB_TXMAXP));\n}\n\n \nvoid musb_g_tx(struct musb *musb, u8 epnum)\n{\n\tu16\t\t\tcsr;\n\tstruct musb_request\t*req;\n\tstruct usb_request\t*request;\n\tu8 __iomem\t\t*mbase = musb->mregs;\n\tstruct musb_ep\t\t*musb_ep = &musb->endpoints[epnum].ep_in;\n\tvoid __iomem\t\t*epio = musb->endpoints[epnum].regs;\n\tstruct dma_channel\t*dma;\n\n\tmusb_ep_select(mbase, epnum);\n\treq = next_request(musb_ep);\n\trequest = &req->request;\n\n\tcsr = musb_readw(epio, MUSB_TXCSR);\n\tmusb_dbg(musb, \"<== %s, txcsr %04x\", musb_ep->end_point.name, csr);\n\n\tdma = is_dma_capable() ? musb_ep->dma : NULL;\n\n\t \n\tif (csr & MUSB_TXCSR_P_SENTSTALL) {\n\t\tcsr |=\tMUSB_TXCSR_P_WZC_BITS;\n\t\tcsr &= ~MUSB_TXCSR_P_SENTSTALL;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\treturn;\n\t}\n\n\tif (csr & MUSB_TXCSR_P_UNDERRUN) {\n\t\t \n\t\tcsr |=\t MUSB_TXCSR_P_WZC_BITS;\n\t\tcsr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\tdev_vdbg(musb->controller, \"underrun on ep%d, req %p\\n\",\n\t\t\t\tepnum, request);\n\t}\n\n\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t \n\t\tmusb_dbg(musb, \"%s dma still busy?\", musb_ep->end_point.name);\n\t\treturn;\n\t}\n\n\tif (req) {\n\n\t\ttrace_musb_req_tx(req);\n\n\t\tif (dma && (csr & MUSB_TXCSR_DMAENAB)) {\n\t\t\tcsr |= MUSB_TXCSR_P_WZC_BITS;\n\t\t\tcsr &= ~(MUSB_TXCSR_DMAENAB | MUSB_TXCSR_P_UNDERRUN |\n\t\t\t\t MUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_AUTOSET);\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\t \n\t\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\t\trequest->actual += musb_ep->dma->actual_len;\n\t\t\tmusb_dbg(musb, \"TXCSR%d %04x, DMA off, len %zu, req %p\",\n\t\t\t\tepnum, csr, musb_ep->dma->actual_len, request);\n\t\t}\n\n\t\t \n\t\tif ((request->zero && request->length)\n\t\t\t&& (request->length % musb_ep->packet_sz == 0)\n\t\t\t&& (request->actual == request->length)) {\n\n\t\t\t \n\t\t\tif (csr & MUSB_TXCSR_TXPKTRDY)\n\t\t\t\treturn;\n\n\t\t\tmusb_writew(epio, MUSB_TXCSR, MUSB_TXCSR_MODE\n\t\t\t\t\t| MUSB_TXCSR_TXPKTRDY);\n\t\t\trequest->zero = 0;\n\t\t}\n\n\t\tif (request->actual == request->length) {\n\t\t\tmusb_g_giveback(musb_ep, request, 0);\n\t\t\t \n\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\treq = musb_ep->desc ? next_request(musb_ep) : NULL;\n\t\t\tif (!req) {\n\t\t\t\tmusb_dbg(musb, \"%s idle now\",\n\t\t\t\t\tmusb_ep->end_point.name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\ttxstate(musb, req);\n\t}\n}\n\n \n\n \nstatic void rxstate(struct musb *musb, struct musb_request *req)\n{\n\tconst u8\t\tepnum = req->epnum;\n\tstruct usb_request\t*request = &req->request;\n\tstruct musb_ep\t\t*musb_ep;\n\tvoid __iomem\t\t*epio = musb->endpoints[epnum].regs;\n\tunsigned\t\tlen = 0;\n\tu16\t\t\tfifo_count;\n\tu16\t\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\tstruct musb_hw_ep\t*hw_ep = &musb->endpoints[epnum];\n\tu8\t\t\tuse_mode_1;\n\n\tif (hw_ep->is_shared_fifo)\n\t\tmusb_ep = &hw_ep->ep_in;\n\telse\n\t\tmusb_ep = &hw_ep->ep_out;\n\n\tfifo_count = musb_ep->packet_sz;\n\n\t \n\tif (!musb_ep->desc) {\n\t\tmusb_dbg(musb, \"ep:%s disabled - ignore request\",\n\t\t\t\t\t\tmusb_ep->end_point.name);\n\t\treturn;\n\t}\n\n\t \n\tif (dma_channel_status(musb_ep->dma) == MUSB_DMA_STATUS_BUSY) {\n\t\tmusb_dbg(musb, \"DMA pending...\");\n\t\treturn;\n\t}\n\n\tif (csr & MUSB_RXCSR_P_SENDSTALL) {\n\t\tmusb_dbg(musb, \"%s stalling, RXCSR %04x\",\n\t\t    musb_ep->end_point.name, csr);\n\t\treturn;\n\t}\n\n\tif (is_cppi_enabled(musb) && is_buffer_mapped(req)) {\n\t\tstruct dma_controller\t*c = musb->dma_controller;\n\t\tstruct dma_channel\t*channel = musb_ep->dma;\n\n\t\t \n\t\tif (c->channel_program(channel,\n\t\t\t\tmusb_ep->packet_sz,\n\t\t\t\t!request->short_not_ok,\n\t\t\t\trequest->dma + request->actual,\n\t\t\t\trequest->length - request->actual)) {\n\n\t\t\t \n\t\t\tcsr &= ~(MUSB_RXCSR_AUTOCLEAR\n\t\t\t\t\t| MUSB_RXCSR_DMAMODE);\n\t\t\tcsr |= MUSB_RXCSR_DMAENAB | MUSB_RXCSR_P_WZC_BITS;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (csr & MUSB_RXCSR_RXPKTRDY) {\n\t\tfifo_count = musb_readw(epio, MUSB_RXCOUNT);\n\n\t\t \n\n\t\tif (request->short_not_ok && fifo_count == musb_ep->packet_sz)\n\t\t\tuse_mode_1 = 1;\n\t\telse\n\t\t\tuse_mode_1 = 0;\n\n\t\tif (request->actual < request->length) {\n\t\t\tif (!is_buffer_mapped(req))\n\t\t\t\tgoto buffer_aint_mapped;\n\n\t\t\tif (musb_dma_inventra(musb)) {\n\t\t\t\tstruct dma_controller\t*c;\n\t\t\t\tstruct dma_channel\t*channel;\n\t\t\t\tint\t\t\tuse_dma = 0;\n\t\t\t\tunsigned int transfer_size;\n\n\t\t\t\tc = musb->dma_controller;\n\t\t\t\tchannel = musb_ep->dma;\n\n\t \n\n\t\t\t\t \n\t\t\t\tif (use_mode_1) {\n\t\t\t\t\tcsr |= MUSB_RXCSR_AUTOCLEAR;\n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t\t\t\tcsr |= MUSB_RXCSR_DMAENAB;\n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\t\t\t\t \n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\t\t\t\tcsr | MUSB_RXCSR_DMAMODE);\n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\t\t\t\ttransfer_size = min_t(unsigned int,\n\t\t\t\t\t\t\trequest->length -\n\t\t\t\t\t\t\trequest->actual,\n\t\t\t\t\t\t\tchannel->max_len);\n\t\t\t\t\tmusb_ep->dma->desired_mode = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif (!musb_ep->hb_mult &&\n\t\t\t\t\t\tmusb_ep->hw_ep->rx_double_buffered)\n\t\t\t\t\t\tcsr |= MUSB_RXCSR_AUTOCLEAR;\n\t\t\t\t\tcsr |= MUSB_RXCSR_DMAENAB;\n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\t\t\t\ttransfer_size = min(request->length - request->actual,\n\t\t\t\t\t\t\t(unsigned)fifo_count);\n\t\t\t\t\tmusb_ep->dma->desired_mode = 0;\n\t\t\t\t}\n\n\t\t\t\tuse_dma = c->channel_program(\n\t\t\t\t\t\tchannel,\n\t\t\t\t\t\tmusb_ep->packet_sz,\n\t\t\t\t\t\tchannel->desired_mode,\n\t\t\t\t\t\trequest->dma\n\t\t\t\t\t\t+ request->actual,\n\t\t\t\t\t\ttransfer_size);\n\n\t\t\t\tif (use_dma)\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ((musb_dma_ux500(musb)) &&\n\t\t\t\t(request->actual < request->length)) {\n\n\t\t\t\tstruct dma_controller *c;\n\t\t\t\tstruct dma_channel *channel;\n\t\t\t\tunsigned int transfer_size = 0;\n\n\t\t\t\tc = musb->dma_controller;\n\t\t\t\tchannel = musb_ep->dma;\n\n\t\t\t\t \n\t\t\t\tif (fifo_count < musb_ep->packet_sz)\n\t\t\t\t\ttransfer_size = fifo_count;\n\t\t\t\telse if (request->short_not_ok)\n\t\t\t\t\ttransfer_size =\tmin_t(unsigned int,\n\t\t\t\t\t\t\trequest->length -\n\t\t\t\t\t\t\trequest->actual,\n\t\t\t\t\t\t\tchannel->max_len);\n\t\t\t\telse\n\t\t\t\t\ttransfer_size = min_t(unsigned int,\n\t\t\t\t\t\t\trequest->length -\n\t\t\t\t\t\t\trequest->actual,\n\t\t\t\t\t\t\t(unsigned)fifo_count);\n\n\t\t\t\tcsr &= ~MUSB_RXCSR_DMAMODE;\n\t\t\t\tcsr |= (MUSB_RXCSR_DMAENAB |\n\t\t\t\t\tMUSB_RXCSR_AUTOCLEAR);\n\n\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\t\t\tif (transfer_size <= musb_ep->packet_sz) {\n\t\t\t\t\tmusb_ep->dma->desired_mode = 0;\n\t\t\t\t} else {\n\t\t\t\t\tmusb_ep->dma->desired_mode = 1;\n\t\t\t\t\t \n\t\t\t\t\tcsr |= MUSB_RXCSR_DMAMODE;\n\t\t\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t\t\t}\n\n\t\t\t\tif (c->channel_program(channel,\n\t\t\t\t\t\t\tmusb_ep->packet_sz,\n\t\t\t\t\t\t\tchannel->desired_mode,\n\t\t\t\t\t\t\trequest->dma\n\t\t\t\t\t\t\t+ request->actual,\n\t\t\t\t\t\t\ttransfer_size))\n\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlen = request->length - request->actual;\n\t\t\tmusb_dbg(musb, \"%s OUT/RX pio fifo %d/%d, maxpacket %d\",\n\t\t\t\t\tmusb_ep->end_point.name,\n\t\t\t\t\tfifo_count, len,\n\t\t\t\t\tmusb_ep->packet_sz);\n\n\t\t\tfifo_count = min_t(unsigned, len, fifo_count);\n\n\t\t\tif (tusb_dma_omap(musb)) {\n\t\t\t\tstruct dma_controller *c = musb->dma_controller;\n\t\t\t\tstruct dma_channel *channel = musb_ep->dma;\n\t\t\t\tu32 dma_addr = request->dma + request->actual;\n\t\t\t\tint ret;\n\n\t\t\t\tret = c->channel_program(channel,\n\t\t\t\t\t\tmusb_ep->packet_sz,\n\t\t\t\t\t\tchannel->desired_mode,\n\t\t\t\t\t\tdma_addr,\n\t\t\t\t\t\tfifo_count);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tunmap_dma_buffer(req, musb);\n\n\t\t\t \n\t\t\tcsr &= ~(MUSB_RXCSR_DMAENAB | MUSB_RXCSR_AUTOCLEAR);\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\nbuffer_aint_mapped:\n\t\t\tfifo_count = min_t(unsigned int,\n\t\t\t\t\trequest->length - request->actual,\n\t\t\t\t\t(unsigned int)fifo_count);\n\t\t\tmusb_read_fifo(musb_ep->hw_ep, fifo_count, (u8 *)\n\t\t\t\t\t(request->buf + request->actual));\n\t\t\trequest->actual += fifo_count;\n\n\t\t\t \n\n\t\t\t \n\t\t\tcsr |= MUSB_RXCSR_P_WZC_BITS;\n\t\t\tcsr &= ~MUSB_RXCSR_RXPKTRDY;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t}\n\t}\n\n\t \n\tif (request->actual == request->length ||\n\t    fifo_count < musb_ep->packet_sz)\n\t\tmusb_g_giveback(musb_ep, request, 0);\n}\n\n \nvoid musb_g_rx(struct musb *musb, u8 epnum)\n{\n\tu16\t\t\tcsr;\n\tstruct musb_request\t*req;\n\tstruct usb_request\t*request;\n\tvoid __iomem\t\t*mbase = musb->mregs;\n\tstruct musb_ep\t\t*musb_ep;\n\tvoid __iomem\t\t*epio = musb->endpoints[epnum].regs;\n\tstruct dma_channel\t*dma;\n\tstruct musb_hw_ep\t*hw_ep = &musb->endpoints[epnum];\n\n\tif (hw_ep->is_shared_fifo)\n\t\tmusb_ep = &hw_ep->ep_in;\n\telse\n\t\tmusb_ep = &hw_ep->ep_out;\n\n\tmusb_ep_select(mbase, epnum);\n\n\treq = next_request(musb_ep);\n\tif (!req)\n\t\treturn;\n\n\ttrace_musb_req_rx(req);\n\trequest = &req->request;\n\n\tcsr = musb_readw(epio, MUSB_RXCSR);\n\tdma = is_dma_capable() ? musb_ep->dma : NULL;\n\n\tmusb_dbg(musb, \"<== %s, rxcsr %04x%s %p\", musb_ep->end_point.name,\n\t\t\tcsr, dma ? \" (dma)\" : \"\", request);\n\n\tif (csr & MUSB_RXCSR_P_SENTSTALL) {\n\t\tcsr |= MUSB_RXCSR_P_WZC_BITS;\n\t\tcsr &= ~MUSB_RXCSR_P_SENTSTALL;\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\treturn;\n\t}\n\n\tif (csr & MUSB_RXCSR_P_OVERRUN) {\n\t\t \n\t\tcsr &= ~MUSB_RXCSR_P_OVERRUN;\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\n\t\tmusb_dbg(musb, \"%s iso overrun on %p\", musb_ep->name, request);\n\t\tif (request->status == -EINPROGRESS)\n\t\t\trequest->status = -EOVERFLOW;\n\t}\n\tif (csr & MUSB_RXCSR_INCOMPRX) {\n\t\t \n\t\tmusb_dbg(musb, \"%s, incomprx\", musb_ep->end_point.name);\n\t}\n\n\tif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\n\t\t \n\t\tmusb_dbg(musb, \"%s busy, csr %04x\",\n\t\t\tmusb_ep->end_point.name, csr);\n\t\treturn;\n\t}\n\n\tif (dma && (csr & MUSB_RXCSR_DMAENAB)) {\n\t\tcsr &= ~(MUSB_RXCSR_AUTOCLEAR\n\t\t\t\t| MUSB_RXCSR_DMAENAB\n\t\t\t\t| MUSB_RXCSR_DMAMODE);\n\t\tmusb_writew(epio, MUSB_RXCSR,\n\t\t\tMUSB_RXCSR_P_WZC_BITS | csr);\n\n\t\trequest->actual += musb_ep->dma->actual_len;\n\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA) || \\\n\tdefined(CONFIG_USB_UX500_DMA)\n\t\t \n\t\tif ((dma->desired_mode == 0 && !hw_ep->rx_double_buffered)\n\t\t\t\t|| (dma->actual_len\n\t\t\t\t\t& (musb_ep->packet_sz - 1))) {\n\t\t\t \n\t\t\tcsr &= ~MUSB_RXCSR_RXPKTRDY;\n\t\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\t}\n\n\t\t \n\t\tif ((request->actual < request->length)\n\t\t\t\t&& (musb_ep->dma->actual_len\n\t\t\t\t\t== musb_ep->packet_sz)) {\n\t\t\t \n\t\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\t\tif ((csr & MUSB_RXCSR_RXPKTRDY) &&\n\t\t\t\thw_ep->rx_double_buffered)\n\t\t\t\tgoto exit;\n\t\t\treturn;\n\t\t}\n#endif\n\t\tmusb_g_giveback(musb_ep, request, 0);\n\t\t \n\t\tmusb_ep_select(mbase, epnum);\n\n\t\treq = next_request(musb_ep);\n\t\tif (!req)\n\t\t\treturn;\n\t}\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA) || \\\n\tdefined(CONFIG_USB_UX500_DMA)\nexit:\n#endif\n\t \n\trxstate(musb, req);\n}\n\n \n\nstatic int musb_gadget_enable(struct usb_ep *ep,\n\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tunsigned long\t\tflags;\n\tstruct musb_ep\t\t*musb_ep;\n\tstruct musb_hw_ep\t*hw_ep;\n\tvoid __iomem\t\t*regs;\n\tstruct musb\t\t*musb;\n\tvoid __iomem\t*mbase;\n\tu8\t\tepnum;\n\tu16\t\tcsr;\n\tunsigned\ttmp;\n\tint\t\tstatus = -EINVAL;\n\n\tif (!ep || !desc)\n\t\treturn -EINVAL;\n\n\tmusb_ep = to_musb_ep(ep);\n\thw_ep = musb_ep->hw_ep;\n\tregs = hw_ep->regs;\n\tmusb = musb_ep->musb;\n\tmbase = musb->mregs;\n\tepnum = musb_ep->current_epnum;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (musb_ep->desc) {\n\t\tstatus = -EBUSY;\n\t\tgoto fail;\n\t}\n\tmusb_ep->type = usb_endpoint_type(desc);\n\n\t \n\tif (usb_endpoint_num(desc) != epnum)\n\t\tgoto fail;\n\n\t \n\ttmp = usb_endpoint_maxp_mult(desc) - 1;\n\tif (tmp) {\n\t\tint ok;\n\n\t\tif (usb_endpoint_dir_in(desc))\n\t\t\tok = musb->hb_iso_tx;\n\t\telse\n\t\t\tok = musb->hb_iso_rx;\n\n\t\tif (!ok) {\n\t\t\tmusb_dbg(musb, \"no support for high bandwidth ISO\");\n\t\t\tgoto fail;\n\t\t}\n\t\tmusb_ep->hb_mult = tmp;\n\t} else {\n\t\tmusb_ep->hb_mult = 0;\n\t}\n\n\tmusb_ep->packet_sz = usb_endpoint_maxp(desc);\n\ttmp = musb_ep->packet_sz * (musb_ep->hb_mult + 1);\n\n\t \n\tmusb_ep_select(mbase, epnum);\n\tif (usb_endpoint_dir_in(desc)) {\n\n\t\tif (hw_ep->is_shared_fifo)\n\t\t\tmusb_ep->is_in = 1;\n\t\tif (!musb_ep->is_in)\n\t\t\tgoto fail;\n\n\t\tif (tmp > hw_ep->max_packet_sz_tx) {\n\t\t\tmusb_dbg(musb, \"packet size beyond hardware FIFO size\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmusb->intrtxe |= (1 << epnum);\n\t\tmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe);\n\n\t\t \n\t\t \n\t\tif (can_bulk_split(musb, musb_ep->type))\n\t\t\tmusb_ep->hb_mult = (hw_ep->max_packet_sz_tx /\n\t\t\t\t\t\tmusb_ep->packet_sz) - 1;\n\t\tmusb_writew(regs, MUSB_TXMAXP, musb_ep->packet_sz\n\t\t\t\t| (musb_ep->hb_mult << 11));\n\n\t\tcsr = MUSB_TXCSR_MODE | MUSB_TXCSR_CLRDATATOG;\n\t\tif (musb_readw(regs, MUSB_TXCSR)\n\t\t\t\t& MUSB_TXCSR_FIFONOTEMPTY)\n\t\t\tcsr |= MUSB_TXCSR_FLUSHFIFO;\n\t\tif (musb_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tcsr |= MUSB_TXCSR_P_ISO;\n\n\t\t \n\t\tmusb_writew(regs, MUSB_TXCSR, csr);\n\t\t \n\t\tmusb_writew(regs, MUSB_TXCSR, csr);\n\n\t} else {\n\n\t\tif (hw_ep->is_shared_fifo)\n\t\t\tmusb_ep->is_in = 0;\n\t\tif (musb_ep->is_in)\n\t\t\tgoto fail;\n\n\t\tif (tmp > hw_ep->max_packet_sz_rx) {\n\t\t\tmusb_dbg(musb, \"packet size beyond hardware FIFO size\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tmusb->intrrxe |= (1 << epnum);\n\t\tmusb_writew(mbase, MUSB_INTRRXE, musb->intrrxe);\n\n\t\t \n\t\t \n\t\tmusb_writew(regs, MUSB_RXMAXP, musb_ep->packet_sz\n\t\t\t\t| (musb_ep->hb_mult << 11));\n\n\t\t \n\t\tif (hw_ep->is_shared_fifo) {\n\t\t\tcsr = musb_readw(regs, MUSB_TXCSR);\n\t\t\tcsr &= ~(MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY);\n\t\t\tmusb_writew(regs, MUSB_TXCSR, csr);\n\t\t}\n\n\t\tcsr = MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_CLRDATATOG;\n\t\tif (musb_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tcsr |= MUSB_RXCSR_P_ISO;\n\t\telse if (musb_ep->type == USB_ENDPOINT_XFER_INT)\n\t\t\tcsr |= MUSB_RXCSR_DISNYET;\n\n\t\t \n\t\tmusb_writew(regs, MUSB_RXCSR, csr);\n\t\tmusb_writew(regs, MUSB_RXCSR, csr);\n\t}\n\n\t \n\tif (is_dma_capable() && musb->dma_controller) {\n\t\tstruct dma_controller\t*c = musb->dma_controller;\n\n\t\tmusb_ep->dma = c->channel_alloc(c, hw_ep,\n\t\t\t\t(desc->bEndpointAddress & USB_DIR_IN));\n\t} else\n\t\tmusb_ep->dma = NULL;\n\n\tmusb_ep->desc = desc;\n\tmusb_ep->busy = 0;\n\tmusb_ep->wedged = 0;\n\tstatus = 0;\n\n\tpr_debug(\"%s periph: enabled %s for %s %s, %smaxpacket %d\\n\",\n\t\t\tmusb_driver_name, musb_ep->end_point.name,\n\t\t\tmusb_ep_xfertype_string(musb_ep->type),\n\t\t\tmusb_ep->is_in ? \"IN\" : \"OUT\",\n\t\t\tmusb_ep->dma ? \"dma, \" : \"\",\n\t\t\tmusb_ep->packet_sz);\n\n\tschedule_delayed_work(&musb->irq_work, 0);\n\nfail:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn status;\n}\n\n \nstatic int musb_gadget_disable(struct usb_ep *ep)\n{\n\tunsigned long\tflags;\n\tstruct musb\t*musb;\n\tu8\t\tepnum;\n\tstruct musb_ep\t*musb_ep;\n\tvoid __iomem\t*epio;\n\n\tmusb_ep = to_musb_ep(ep);\n\tmusb = musb_ep->musb;\n\tepnum = musb_ep->current_epnum;\n\tepio = musb->endpoints[epnum].regs;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb_ep_select(musb->mregs, epnum);\n\n\t \n\tif (musb_ep->is_in) {\n\t\tmusb->intrtxe &= ~(1 << epnum);\n\t\tmusb_writew(musb->mregs, MUSB_INTRTXE, musb->intrtxe);\n\t\tmusb_writew(epio, MUSB_TXMAXP, 0);\n\t} else {\n\t\tmusb->intrrxe &= ~(1 << epnum);\n\t\tmusb_writew(musb->mregs, MUSB_INTRRXE, musb->intrrxe);\n\t\tmusb_writew(epio, MUSB_RXMAXP, 0);\n\t}\n\n\t \n\tnuke(musb_ep, -ESHUTDOWN);\n\n\tmusb_ep->desc = NULL;\n\tmusb_ep->end_point.desc = NULL;\n\n\tschedule_delayed_work(&musb->irq_work, 0);\n\n\tspin_unlock_irqrestore(&(musb->lock), flags);\n\n\tmusb_dbg(musb, \"%s\", musb_ep->end_point.name);\n\n\treturn 0;\n}\n\n \nstruct usb_request *musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\n{\n\tstruct musb_ep\t\t*musb_ep = to_musb_ep(ep);\n\tstruct musb_request\t*request;\n\n\trequest = kzalloc(sizeof *request, gfp_flags);\n\tif (!request)\n\t\treturn NULL;\n\n\trequest->request.dma = DMA_ADDR_INVALID;\n\trequest->epnum = musb_ep->current_epnum;\n\trequest->ep = musb_ep;\n\n\ttrace_musb_req_alloc(request);\n\treturn &request->request;\n}\n\n \nvoid musb_free_request(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct musb_request *request = to_musb_request(req);\n\n\ttrace_musb_req_free(request);\n\tkfree(request);\n}\n\nstatic LIST_HEAD(buffers);\n\nstruct free_record {\n\tstruct list_head\tlist;\n\tstruct device\t\t*dev;\n\tunsigned\t\tbytes;\n\tdma_addr_t\t\tdma;\n};\n\n \nvoid musb_ep_restart(struct musb *musb, struct musb_request *req)\n{\n\ttrace_musb_req_start(req);\n\tmusb_ep_select(musb->mregs, req->epnum);\n\tif (req->tx)\n\t\ttxstate(musb, req);\n\telse\n\t\trxstate(musb, req);\n}\n\nstatic int musb_ep_restart_resume_work(struct musb *musb, void *data)\n{\n\tstruct musb_request *req = data;\n\n\tmusb_ep_restart(musb, req);\n\n\treturn 0;\n}\n\nstatic int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,\n\t\t\tgfp_t gfp_flags)\n{\n\tstruct musb_ep\t\t*musb_ep;\n\tstruct musb_request\t*request;\n\tstruct musb\t\t*musb;\n\tint\t\t\tstatus;\n\tunsigned long\t\tlockflags;\n\n\tif (!ep || !req)\n\t\treturn -EINVAL;\n\tif (!req->buf)\n\t\treturn -ENODATA;\n\n\tmusb_ep = to_musb_ep(ep);\n\tmusb = musb_ep->musb;\n\n\trequest = to_musb_request(req);\n\trequest->musb = musb;\n\n\tif (request->ep != musb_ep)\n\t\treturn -EINVAL;\n\n\tstatus = pm_runtime_get(musb->controller);\n\tif ((status != -EINPROGRESS) && status < 0) {\n\t\tdev_err(musb->controller,\n\t\t\t\"pm runtime get failed in %s\\n\",\n\t\t\t__func__);\n\t\tpm_runtime_put_noidle(musb->controller);\n\n\t\treturn status;\n\t}\n\tstatus = 0;\n\n\ttrace_musb_req_enq(request);\n\n\t \n\trequest->request.actual = 0;\n\trequest->request.status = -EINPROGRESS;\n\trequest->epnum = musb_ep->current_epnum;\n\trequest->tx = musb_ep->is_in;\n\n\tmap_dma_buffer(request, musb, musb_ep);\n\n\tspin_lock_irqsave(&musb->lock, lockflags);\n\n\t \n\tif (!musb_ep->desc) {\n\t\tmusb_dbg(musb, \"req %p queued to %s while ep %s\",\n\t\t\t\treq, ep->name, \"disabled\");\n\t\tstatus = -ESHUTDOWN;\n\t\tunmap_dma_buffer(request, musb);\n\t\tgoto unlock;\n\t}\n\n\t \n\tlist_add_tail(&request->list, &musb_ep->req_list);\n\n\t \n\tif (!musb_ep->busy && &request->list == musb_ep->req_list.next) {\n\t\tstatus = musb_queue_resume_work(musb,\n\t\t\t\t\t\tmusb_ep_restart_resume_work,\n\t\t\t\t\t\trequest);\n\t\tif (status < 0) {\n\t\t\tdev_err(musb->controller, \"%s resume work: %i\\n\",\n\t\t\t\t__func__, status);\n\t\t\tlist_del(&request->list);\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&musb->lock, lockflags);\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\n\treturn status;\n}\n\nstatic int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *request)\n{\n\tstruct musb_ep\t\t*musb_ep = to_musb_ep(ep);\n\tstruct musb_request\t*req = to_musb_request(request);\n\tstruct musb_request\t*r;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus = 0;\n\tstruct musb\t\t*musb = musb_ep->musb;\n\n\tif (!ep || !request || req->ep != musb_ep)\n\t\treturn -EINVAL;\n\n\ttrace_musb_req_deq(req);\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tlist_for_each_entry(r, &musb_ep->req_list, list) {\n\t\tif (r == req)\n\t\t\tbreak;\n\t}\n\tif (r != req) {\n\t\tdev_err(musb->controller, \"request %p not queued to %s\\n\",\n\t\t\t\trequest, ep->name);\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (musb_ep->req_list.next != &req->list || musb_ep->busy)\n\t\tmusb_g_giveback(musb_ep, request, -ECONNRESET);\n\n\t \n\telse if (is_dma_capable() && musb_ep->dma) {\n\t\tstruct dma_controller\t*c = musb->dma_controller;\n\n\t\tmusb_ep_select(musb->mregs, musb_ep->current_epnum);\n\t\tif (c->channel_abort)\n\t\t\tstatus = c->channel_abort(musb_ep->dma);\n\t\telse\n\t\t\tstatus = -EBUSY;\n\t\tif (status == 0)\n\t\t\tmusb_g_giveback(musb_ep, request, -ECONNRESET);\n\t} else {\n\t\t \n\t\tmusb_g_giveback(musb_ep, request, -ECONNRESET);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn status;\n}\n\n \nstatic int musb_gadget_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct musb_ep\t\t*musb_ep = to_musb_ep(ep);\n\tu8\t\t\tepnum = musb_ep->current_epnum;\n\tstruct musb\t\t*musb = musb_ep->musb;\n\tvoid __iomem\t\t*epio = musb->endpoints[epnum].regs;\n\tvoid __iomem\t\t*mbase;\n\tunsigned long\t\tflags;\n\tu16\t\t\tcsr;\n\tstruct musb_request\t*request;\n\tint\t\t\tstatus = 0;\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\tmbase = musb->mregs;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif ((USB_ENDPOINT_XFER_ISOC == musb_ep->type)) {\n\t\tstatus = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmusb_ep_select(mbase, epnum);\n\n\trequest = next_request(musb_ep);\n\tif (value) {\n\t\tif (request) {\n\t\t\tmusb_dbg(musb, \"request in progress, cannot halt %s\",\n\t\t\t    ep->name);\n\t\t\tstatus = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tif (musb_ep->is_in) {\n\t\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\t\tif (csr & MUSB_TXCSR_FIFONOTEMPTY) {\n\t\t\t\tmusb_dbg(musb, \"FIFO busy, cannot halt %s\",\n\t\t\t\t\t\tep->name);\n\t\t\t\tstatus = -EAGAIN;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t} else\n\t\tmusb_ep->wedged = 0;\n\n\t \n\tmusb_dbg(musb, \"%s: %s stall\", ep->name, value ? \"set\" : \"clear\");\n\tif (musb_ep->is_in) {\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tcsr |= MUSB_TXCSR_P_WZC_BITS\n\t\t\t| MUSB_TXCSR_CLRDATATOG;\n\t\tif (value)\n\t\t\tcsr |= MUSB_TXCSR_P_SENDSTALL;\n\t\telse\n\t\t\tcsr &= ~(MUSB_TXCSR_P_SENDSTALL\n\t\t\t\t| MUSB_TXCSR_P_SENTSTALL);\n\t\tcsr &= ~MUSB_TXCSR_TXPKTRDY;\n\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t} else {\n\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\tcsr |= MUSB_RXCSR_P_WZC_BITS\n\t\t\t| MUSB_RXCSR_FLUSHFIFO\n\t\t\t| MUSB_RXCSR_CLRDATATOG;\n\t\tif (value)\n\t\t\tcsr |= MUSB_RXCSR_P_SENDSTALL;\n\t\telse\n\t\t\tcsr &= ~(MUSB_RXCSR_P_SENDSTALL\n\t\t\t\t| MUSB_RXCSR_P_SENTSTALL);\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t}\n\n\t \n\tif (!musb_ep->busy && !value && request) {\n\t\tmusb_dbg(musb, \"restarting the request\");\n\t\tmusb_ep_restart(musb, request);\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn status;\n}\n\n \nstatic int musb_gadget_set_wedge(struct usb_ep *ep)\n{\n\tstruct musb_ep\t\t*musb_ep = to_musb_ep(ep);\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tmusb_ep->wedged = 1;\n\n\treturn usb_ep_set_halt(ep);\n}\n\nstatic int musb_gadget_fifo_status(struct usb_ep *ep)\n{\n\tstruct musb_ep\t\t*musb_ep = to_musb_ep(ep);\n\tvoid __iomem\t\t*epio = musb_ep->hw_ep->regs;\n\tint\t\t\tretval = -EINVAL;\n\n\tif (musb_ep->desc && !musb_ep->is_in) {\n\t\tstruct musb\t\t*musb = musb_ep->musb;\n\t\tint\t\t\tepnum = musb_ep->current_epnum;\n\t\tvoid __iomem\t\t*mbase = musb->mregs;\n\t\tunsigned long\t\tflags;\n\n\t\tspin_lock_irqsave(&musb->lock, flags);\n\n\t\tmusb_ep_select(mbase, epnum);\n\t\t \n\t\tretval = musb_readw(epio, MUSB_RXCOUNT);\n\n\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t}\n\treturn retval;\n}\n\nstatic void musb_gadget_fifo_flush(struct usb_ep *ep)\n{\n\tstruct musb_ep\t*musb_ep = to_musb_ep(ep);\n\tstruct musb\t*musb = musb_ep->musb;\n\tu8\t\tepnum = musb_ep->current_epnum;\n\tvoid __iomem\t*epio = musb->endpoints[epnum].regs;\n\tvoid __iomem\t*mbase;\n\tunsigned long\tflags;\n\tu16\t\tcsr;\n\n\tmbase = musb->mregs;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb_ep_select(mbase, (u8) epnum);\n\n\t \n\tmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe & ~(1 << epnum));\n\n\tif (musb_ep->is_in) {\n\t\tcsr = musb_readw(epio, MUSB_TXCSR);\n\t\tif (csr & MUSB_TXCSR_FIFONOTEMPTY) {\n\t\t\tcsr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_P_WZC_BITS;\n\t\t\t \n\t\t\tcsr &= ~MUSB_TXCSR_TXPKTRDY;\n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t\t \n\t\t\tmusb_writew(epio, MUSB_TXCSR, csr);\n\t\t}\n\t} else {\n\t\tcsr = musb_readw(epio, MUSB_RXCSR);\n\t\tcsr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_P_WZC_BITS;\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t\tmusb_writew(epio, MUSB_RXCSR, csr);\n\t}\n\n\t \n\tmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n}\n\nstatic const struct usb_ep_ops musb_ep_ops = {\n\t.enable\t\t= musb_gadget_enable,\n\t.disable\t= musb_gadget_disable,\n\t.alloc_request\t= musb_alloc_request,\n\t.free_request\t= musb_free_request,\n\t.queue\t\t= musb_gadget_queue,\n\t.dequeue\t= musb_gadget_dequeue,\n\t.set_halt\t= musb_gadget_set_halt,\n\t.set_wedge\t= musb_gadget_set_wedge,\n\t.fifo_status\t= musb_gadget_fifo_status,\n\t.fifo_flush\t= musb_gadget_fifo_flush\n};\n\n \n\nstatic int musb_gadget_get_frame(struct usb_gadget *gadget)\n{\n\tstruct musb\t*musb = gadget_to_musb(gadget);\n\n\treturn (int)musb_readw(musb->mregs, MUSB_FRAME);\n}\n\nstatic int musb_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tstruct musb\t*musb = gadget_to_musb(gadget);\n\tvoid __iomem\t*mregs = musb->mregs;\n\tunsigned long\tflags;\n\tint\t\tstatus = -EINVAL;\n\tu8\t\tpower, devctl;\n\tint\t\tretries;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\t \n\t\tif (musb->may_wakeup && musb->is_suspended)\n\t\t\tbreak;\n\t\tgoto done;\n\tcase OTG_STATE_B_IDLE:\n\t\t \n\t\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\tmusb_dbg(musb, \"Sending SRP: devctl: %02x\", devctl);\n\t\tdevctl |= MUSB_DEVCTL_SESSION;\n\t\tmusb_writeb(mregs, MUSB_DEVCTL, devctl);\n\t\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\tretries = 100;\n\t\twhile (!(devctl & MUSB_DEVCTL_SESSION)) {\n\t\t\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\t\tif (retries-- < 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tretries = 10000;\n\t\twhile (devctl & MUSB_DEVCTL_SESSION) {\n\t\t\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\t\tif (retries-- < 1)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (musb->xceiv) {\n\t\t\tspin_unlock_irqrestore(&musb->lock, flags);\n\t\t\totg_start_srp(musb->xceiv->otg);\n\t\t\tspin_lock_irqsave(&musb->lock, flags);\n\t\t}\n\n\t\t \n\t\tmusb_platform_try_idle(musb,\n\t\t\tjiffies + msecs_to_jiffies(1 * HZ));\n\n\t\tstatus = 0;\n\t\tgoto done;\n\tdefault:\n\t\tmusb_dbg(musb, \"Unhandled wake: %s\",\n\t\t\t musb_otg_state_string(musb));\n\t\tgoto done;\n\t}\n\n\tstatus = 0;\n\n\tpower = musb_readb(mregs, MUSB_POWER);\n\tpower |= MUSB_POWER_RESUME;\n\tmusb_writeb(mregs, MUSB_POWER, power);\n\tmusb_dbg(musb, \"issue wakeup\");\n\n\t \n\tmdelay(2);\n\n\tpower = musb_readb(mregs, MUSB_POWER);\n\tpower &= ~MUSB_POWER_RESUME;\n\tmusb_writeb(mregs, MUSB_POWER, power);\ndone:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn status;\n}\n\nstatic int\nmusb_gadget_set_self_powered(struct usb_gadget *gadget, int is_selfpowered)\n{\n\tgadget->is_selfpowered = !!is_selfpowered;\n\treturn 0;\n}\n\nstatic void musb_pullup(struct musb *musb, int is_on)\n{\n\tu8 power;\n\n\tpower = musb_readb(musb->mregs, MUSB_POWER);\n\tif (is_on)\n\t\tpower |= MUSB_POWER_SOFTCONN;\n\telse\n\t\tpower &= ~MUSB_POWER_SOFTCONN;\n\n\t \n\n\tmusb_dbg(musb, \"gadget D+ pullup %s\",\n\t\tis_on ? \"on\" : \"off\");\n\tmusb_writeb(musb->mregs, MUSB_POWER, power);\n}\n\n#if 0\nstatic int musb_gadget_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tmusb_dbg(musb, \"<= %s =>\\n\", __func__);\n\n\t \n\n\treturn -EINVAL;\n}\n#endif\n\nstatic int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)\n{\n\tstruct musb\t*musb = gadget_to_musb(gadget);\n\n\treturn usb_phy_set_power(musb->xceiv, mA);\n}\n\nstatic void musb_gadget_work(struct work_struct *work)\n{\n\tstruct musb *musb;\n\tunsigned long flags;\n\n\tmusb = container_of(work, struct musb, gadget_work.work);\n\tpm_runtime_get_sync(musb->controller);\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb_pullup(musb, musb->softconnect);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n}\n\nstatic int musb_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct musb\t*musb = gadget_to_musb(gadget);\n\tunsigned long\tflags;\n\n\tis_on = !!is_on;\n\n\t \n\tspin_lock_irqsave(&musb->lock, flags);\n\tif (is_on != musb->softconnect) {\n\t\tmusb->softconnect = is_on;\n\t\tschedule_delayed_work(&musb->gadget_work, 0);\n\t}\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn 0;\n}\n\nstatic int musb_gadget_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver);\nstatic int musb_gadget_stop(struct usb_gadget *g);\n\nstatic const struct usb_gadget_ops musb_gadget_operations = {\n\t.get_frame\t\t= musb_gadget_get_frame,\n\t.wakeup\t\t\t= musb_gadget_wakeup,\n\t.set_selfpowered\t= musb_gadget_set_self_powered,\n\t \n\t.vbus_draw\t\t= musb_gadget_vbus_draw,\n\t.pullup\t\t\t= musb_gadget_pullup,\n\t.udc_start\t\t= musb_gadget_start,\n\t.udc_stop\t\t= musb_gadget_stop,\n};\n\n \n\n \n\n \n\nstatic void\ninit_peripheral_ep(struct musb *musb, struct musb_ep *ep, u8 epnum, int is_in)\n{\n\tstruct musb_hw_ep\t*hw_ep = musb->endpoints + epnum;\n\n\tmemset(ep, 0, sizeof *ep);\n\n\tep->current_epnum = epnum;\n\tep->musb = musb;\n\tep->hw_ep = hw_ep;\n\tep->is_in = is_in;\n\n\tINIT_LIST_HEAD(&ep->req_list);\n\n\tsprintf(ep->name, \"ep%d%s\", epnum,\n\t\t\t(!epnum || hw_ep->is_shared_fifo) ? \"\" : (\n\t\t\t\tis_in ? \"in\" : \"out\"));\n\tep->end_point.name = ep->name;\n\tINIT_LIST_HEAD(&ep->end_point.ep_list);\n\tif (!epnum) {\n\t\tusb_ep_set_maxpacket_limit(&ep->end_point, 64);\n\t\tep->end_point.caps.type_control = true;\n\t\tep->end_point.ops = &musb_g_ep0_ops;\n\t\tmusb->g.ep0 = &ep->end_point;\n\t} else {\n\t\tif (is_in)\n\t\t\tusb_ep_set_maxpacket_limit(&ep->end_point, hw_ep->max_packet_sz_tx);\n\t\telse\n\t\t\tusb_ep_set_maxpacket_limit(&ep->end_point, hw_ep->max_packet_sz_rx);\n\t\tep->end_point.caps.type_iso = true;\n\t\tep->end_point.caps.type_bulk = true;\n\t\tep->end_point.caps.type_int = true;\n\t\tep->end_point.ops = &musb_ep_ops;\n\t\tlist_add_tail(&ep->end_point.ep_list, &musb->g.ep_list);\n\t}\n\n\tif (!epnum || hw_ep->is_shared_fifo) {\n\t\tep->end_point.caps.dir_in = true;\n\t\tep->end_point.caps.dir_out = true;\n\t} else if (is_in)\n\t\tep->end_point.caps.dir_in = true;\n\telse\n\t\tep->end_point.caps.dir_out = true;\n}\n\n \nstatic inline void musb_g_init_endpoints(struct musb *musb)\n{\n\tu8\t\t\tepnum;\n\tstruct musb_hw_ep\t*hw_ep;\n\tunsigned\t\tcount = 0;\n\n\t \n\tINIT_LIST_HEAD(&(musb->g.ep_list));\n\n\tfor (epnum = 0, hw_ep = musb->endpoints;\n\t\t\tepnum < musb->nr_endpoints;\n\t\t\tepnum++, hw_ep++) {\n\t\tif (hw_ep->is_shared_fifo  ) {\n\t\t\tinit_peripheral_ep(musb, &hw_ep->ep_in, epnum, 0);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tif (hw_ep->max_packet_sz_tx) {\n\t\t\t\tinit_peripheral_ep(musb, &hw_ep->ep_in,\n\t\t\t\t\t\t\tepnum, 1);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif (hw_ep->max_packet_sz_rx) {\n\t\t\t\tinit_peripheral_ep(musb, &hw_ep->ep_out,\n\t\t\t\t\t\t\tepnum, 0);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint musb_gadget_setup(struct musb *musb)\n{\n\tint status;\n\n\t \n\n\tmusb->g.ops = &musb_gadget_operations;\n\tmusb->g.max_speed = USB_SPEED_HIGH;\n\tmusb->g.speed = USB_SPEED_UNKNOWN;\n\n\tMUSB_DEV_MODE(musb);\n\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\n\t \n\tmusb->g.name = musb_driver_name;\n\t \n\tmusb->g.is_otg = 0;\n\tINIT_DELAYED_WORK(&musb->gadget_work, musb_gadget_work);\n\tmusb_g_init_endpoints(musb);\n\n\tmusb->is_active = 0;\n\tmusb_platform_try_idle(musb, 0);\n\n\tstatus = usb_add_gadget_udc(musb->controller, &musb->g);\n\tif (status)\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\tmusb->g.dev.parent = NULL;\n\tdevice_unregister(&musb->g.dev);\n\treturn status;\n}\n\nvoid musb_gadget_cleanup(struct musb *musb)\n{\n\tif (musb->port_mode == MUSB_HOST)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&musb->gadget_work);\n\tusb_del_gadget_udc(&musb->g);\n}\n\n \nstatic int musb_gadget_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct musb\t\t*musb = gadget_to_musb(g);\n\tunsigned long\t\tflags;\n\tint\t\t\tretval = 0;\n\n\tif (driver->max_speed < USB_SPEED_HIGH) {\n\t\tretval = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tpm_runtime_get_sync(musb->controller);\n\n\tmusb->softconnect = 0;\n\tmusb->gadget_driver = driver;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\tmusb->is_active = 1;\n\n\tif (musb->xceiv)\n\t\totg_set_peripheral(musb->xceiv->otg, &musb->g);\n\telse\n\t\tphy_set_mode(musb->phy, PHY_MODE_USB_DEVICE);\n\n\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\tmusb_start(musb);\n\n\t \n\tif (musb->xceiv && musb->xceiv->last_event == USB_EVENT_ID)\n\t\tmusb_platform_set_vbus(musb, 1);\n\n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\n\treturn 0;\n\nerr:\n\treturn retval;\n}\n\n \nstatic int musb_gadget_stop(struct usb_gadget *g)\n{\n\tstruct musb\t*musb = gadget_to_musb(g);\n\tunsigned long\tflags;\n\n\tpm_runtime_get_sync(musb->controller);\n\n\t \n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tmusb_hnp_stop(musb);\n\n\t(void) musb_gadget_vbus_draw(&musb->g, 0);\n\n\tmusb_set_state(musb, OTG_STATE_UNDEFINED);\n\tmusb_stop(musb);\n\n\tif (musb->xceiv)\n\t\totg_set_peripheral(musb->xceiv->otg, NULL);\n\telse\n\t\tphy_set_mode(musb->phy, PHY_MODE_INVALID);\n\n\tmusb->is_active = 0;\n\tmusb->gadget_driver = NULL;\n\tmusb_platform_try_idle(musb, 0);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\t \n\n\t \n\tpm_runtime_mark_last_busy(musb->controller);\n\tpm_runtime_put_autosuspend(musb->controller);\n\n\treturn 0;\n}\n\n \n\n \n\nvoid musb_g_resume(struct musb *musb)\n{\n\tmusb->is_suspended = 0;\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_B_IDLE:\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tmusb->is_active = 1;\n\t\tif (musb->gadget_driver && musb->gadget_driver->resume) {\n\t\t\tspin_unlock(&musb->lock);\n\t\t\tmusb->gadget_driver->resume(&musb->g);\n\t\t\tspin_lock(&musb->lock);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARNING(\"unhandled RESUME transition (%s)\\n\",\n\t\t\tmusb_otg_state_string(musb));\n\t}\n}\n\n \nvoid musb_g_suspend(struct musb *musb)\n{\n\tu8\tdevctl;\n\n\tdevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\n\tmusb_dbg(musb, \"musb_g_suspend: devctl %02x\", devctl);\n\n\tswitch (musb_get_state(musb)) {\n\tcase OTG_STATE_B_IDLE:\n\t\tif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)\n\t\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tmusb->is_suspended = 1;\n\t\tif (musb->gadget_driver && musb->gadget_driver->suspend) {\n\t\t\tspin_unlock(&musb->lock);\n\t\t\tmusb->gadget_driver->suspend(&musb->g);\n\t\t\tspin_lock(&musb->lock);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tWARNING(\"unhandled SUSPEND transition (%s)\",\n\t\t\tmusb_otg_state_string(musb));\n\t}\n}\n\n \nvoid musb_g_wakeup(struct musb *musb)\n{\n\tmusb_gadget_wakeup(&musb->g);\n}\n\n \nvoid musb_g_disconnect(struct musb *musb)\n{\n\tvoid __iomem\t*mregs = musb->mregs;\n\tu8\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\n\tmusb_dbg(musb, \"musb_g_disconnect: devctl %02x\", devctl);\n\n\t \n\tmusb_writeb(mregs, MUSB_DEVCTL, devctl & MUSB_DEVCTL_SESSION);\n\n\t \n\t(void) musb_gadget_vbus_draw(&musb->g, 0);\n\n\tmusb->g.speed = USB_SPEED_UNKNOWN;\n\tif (musb->gadget_driver && musb->gadget_driver->disconnect) {\n\t\tspin_unlock(&musb->lock);\n\t\tmusb->gadget_driver->disconnect(&musb->g);\n\t\tspin_lock(&musb->lock);\n\t}\n\n\tswitch (musb_get_state(musb)) {\n\tdefault:\n\t\tmusb_dbg(musb, \"Unhandled disconnect %s, setting a_idle\",\n\t\t\t musb_otg_state_string(musb));\n\t\tmusb_set_state(musb, OTG_STATE_A_IDLE);\n\t\tMUSB_HST_MODE(musb);\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\tmusb_set_state(musb, OTG_STATE_A_WAIT_BCON);\n\t\tMUSB_HST_MODE(musb);\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\tcase OTG_STATE_B_HOST:\n\tcase OTG_STATE_B_PERIPHERAL:\n\tcase OTG_STATE_B_IDLE:\n\t\tmusb_set_state(musb, OTG_STATE_B_IDLE);\n\t\tbreak;\n\tcase OTG_STATE_B_SRP_INIT:\n\t\tbreak;\n\t}\n\n\tmusb->is_active = 0;\n}\n\nvoid musb_g_reset(struct musb *musb)\n__releases(musb->lock)\n__acquires(musb->lock)\n{\n\tvoid __iomem\t*mbase = musb->mregs;\n\tu8\t\tdevctl = musb_readb(mbase, MUSB_DEVCTL);\n\tu8\t\tpower;\n\n\tmusb_dbg(musb, \"<== %s driver '%s'\",\n\t\t\t(devctl & MUSB_DEVCTL_BDEVICE)\n\t\t\t\t? \"B-Device\" : \"A-Device\",\n\t\t\tmusb->gadget_driver\n\t\t\t\t? musb->gadget_driver->driver.name\n\t\t\t\t: NULL\n\t\t\t);\n\n\t \n\tif (musb->gadget_driver && musb->g.speed != USB_SPEED_UNKNOWN) {\n\t\tspin_unlock(&musb->lock);\n\t\tusb_gadget_udc_reset(&musb->g, musb->gadget_driver);\n\t\tspin_lock(&musb->lock);\n\t}\n\n\t \n\telse if (devctl & MUSB_DEVCTL_HR)\n\t\tmusb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);\n\n\n\t \n\tpower = musb_readb(mbase, MUSB_POWER);\n\tmusb->g.speed = (power & MUSB_POWER_HSMODE)\n\t\t\t? USB_SPEED_HIGH : USB_SPEED_FULL;\n\n\t \n\tmusb->is_active = 1;\n\tmusb->is_suspended = 0;\n\tMUSB_DEV_MODE(musb);\n\tmusb->address = 0;\n\tmusb->ep0_state = MUSB_EP0_STAGE_SETUP;\n\n\tmusb->may_wakeup = 0;\n\tmusb->g.b_hnp_enable = 0;\n\tmusb->g.a_alt_hnp_support = 0;\n\tmusb->g.a_hnp_support = 0;\n\tmusb->g.quirk_zlp_not_supp = 1;\n\n\t \n\tif (!musb->g.is_otg) {\n\t\t \n\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tmusb->g.is_a_peripheral = 0;\n\t} else if (devctl & MUSB_DEVCTL_BDEVICE) {\n\t\tmusb_set_state(musb, OTG_STATE_B_PERIPHERAL);\n\t\tmusb->g.is_a_peripheral = 0;\n\t} else {\n\t\tmusb_set_state(musb, OTG_STATE_A_PERIPHERAL);\n\t\tmusb->g.is_a_peripheral = 1;\n\t}\n\n\t \n\t(void) musb_gadget_vbus_draw(&musb->g, 8);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}