{
  "module_name": "musb_gadget_ep0.c",
  "hash_id": "e7e5a5ab300c0ac55dcdd2e4cbbea28c0d8caa53c1a7c9c1fe4874cd6f5a07d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_gadget_ep0.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/timer.h>\n#include <linux/spinlock.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n\n#include \"musb_core.h\"\n\n \n#define\tnext_ep0_request(musb)\tnext_in_request(&(musb)->endpoints[0])\n\n \n\nstatic char *decode_ep0stage(u8 stage)\n{\n\tswitch (stage) {\n\tcase MUSB_EP0_STAGE_IDLE:\treturn \"idle\";\n\tcase MUSB_EP0_STAGE_SETUP:\treturn \"setup\";\n\tcase MUSB_EP0_STAGE_TX:\t\treturn \"in\";\n\tcase MUSB_EP0_STAGE_RX:\t\treturn \"out\";\n\tcase MUSB_EP0_STAGE_ACKWAIT:\treturn \"wait\";\n\tcase MUSB_EP0_STAGE_STATUSIN:\treturn \"in/status\";\n\tcase MUSB_EP0_STAGE_STATUSOUT:\treturn \"out/status\";\n\tdefault:\t\t\treturn \"?\";\n\t}\n}\n\n \nstatic int service_tx_status_request(\n\tstruct musb *musb,\n\tconst struct usb_ctrlrequest *ctrlrequest)\n{\n\tvoid __iomem\t*mbase = musb->mregs;\n\tint handled = 1;\n\tu8 result[2], epnum = 0;\n\tconst u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;\n\n\tresult[1] = 0;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tresult[0] = musb->g.is_selfpowered << USB_DEVICE_SELF_POWERED;\n\t\tresult[0] |= musb->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\t\tif (musb->g.is_otg) {\n\t\t\tresult[0] |= musb->g.b_hnp_enable\n\t\t\t\t<< USB_DEVICE_B_HNP_ENABLE;\n\t\t\tresult[0] |= musb->g.a_alt_hnp_support\n\t\t\t\t<< USB_DEVICE_A_ALT_HNP_SUPPORT;\n\t\t\tresult[0] |= musb->g.a_hnp_support\n\t\t\t\t<< USB_DEVICE_A_HNP_SUPPORT;\n\t\t}\n\t\tbreak;\n\n\tcase USB_RECIP_INTERFACE:\n\t\tresult[0] = 0;\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT: {\n\t\tint\t\tis_in;\n\t\tstruct musb_ep\t*ep;\n\t\tu16\t\ttmp;\n\t\tvoid __iomem\t*regs;\n\n\t\tepnum = (u8) ctrlrequest->wIndex;\n\t\tif (!epnum) {\n\t\t\tresult[0] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tis_in = epnum & USB_DIR_IN;\n\t\tepnum &= 0x0f;\n\t\tif (epnum >= MUSB_C_NUM_EPS) {\n\t\t\thandled = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_in)\n\t\t\tep = &musb->endpoints[epnum].ep_in;\n\t\telse\n\t\t\tep = &musb->endpoints[epnum].ep_out;\n\t\tregs = musb->endpoints[epnum].regs;\n\n\t\tif (!ep->desc) {\n\t\t\thandled = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tmusb_ep_select(mbase, epnum);\n\t\tif (is_in)\n\t\t\ttmp = musb_readw(regs, MUSB_TXCSR)\n\t\t\t\t\t\t& MUSB_TXCSR_P_SENDSTALL;\n\t\telse\n\t\t\ttmp = musb_readw(regs, MUSB_RXCSR)\n\t\t\t\t\t\t& MUSB_RXCSR_P_SENDSTALL;\n\t\tmusb_ep_select(mbase, 0);\n\n\t\tresult[0] = tmp ? 1 : 0;\n\t\t} break;\n\n\tdefault:\n\t\t \n\t\thandled = 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (handled > 0) {\n\t\tu16\tlen = le16_to_cpu(ctrlrequest->wLength);\n\n\t\tif (len > 2)\n\t\t\tlen = 2;\n\t\tmusb_write_fifo(&musb->endpoints[0], len, result);\n\t}\n\n\treturn handled;\n}\n\n \nstatic int\nservice_in_request(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)\n{\n\tint handled = 0;\t \n\n\tif ((ctrlrequest->bRequestType & USB_TYPE_MASK)\n\t\t\t== USB_TYPE_STANDARD) {\n\t\tswitch (ctrlrequest->bRequest) {\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\thandled = service_tx_status_request(musb,\n\t\t\t\t\tctrlrequest);\n\t\t\tbreak;\n\n\t\t \n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn handled;\n}\n\n \nstatic void musb_g_ep0_giveback(struct musb *musb, struct usb_request *req)\n{\n\tmusb_g_giveback(&musb->endpoints[0].ep_in, req, 0);\n}\n\n \nstatic inline void musb_try_b_hnp_enable(struct musb *musb)\n{\n\tvoid __iomem\t*mbase = musb->mregs;\n\tu8\t\tdevctl;\n\n\tmusb_dbg(musb, \"HNP: Setting HR\");\n\tdevctl = musb_readb(mbase, MUSB_DEVCTL);\n\tmusb_writeb(mbase, MUSB_DEVCTL, devctl | MUSB_DEVCTL_HR);\n}\n\n \nstatic int\nservice_zero_data_request(struct musb *musb,\n\t\tstruct usb_ctrlrequest *ctrlrequest)\n__releases(musb->lock)\n__acquires(musb->lock)\n{\n\tint handled = -EINVAL;\n\tvoid __iomem *mbase = musb->mregs;\n\tconst u8 recip = ctrlrequest->bRequestType & USB_RECIP_MASK;\n\n\t \n\tif ((ctrlrequest->bRequestType & USB_TYPE_MASK)\n\t\t\t== USB_TYPE_STANDARD) {\n\t\tswitch (ctrlrequest->bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t \n\t\t\tmusb->set_address = true;\n\t\t\tmusb->address = (u8) (ctrlrequest->wValue & 0x7f);\n\t\t\thandled = 1;\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\tswitch (recip) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\tif (ctrlrequest->wValue\n\t\t\t\t\t\t!= USB_DEVICE_REMOTE_WAKEUP)\n\t\t\t\t\tbreak;\n\t\t\t\tmusb->may_wakeup = 0;\n\t\t\t\thandled = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tbreak;\n\t\t\tcase USB_RECIP_ENDPOINT:{\n\t\t\t\tconst u8\t\tepnum =\n\t\t\t\t\tctrlrequest->wIndex & 0x0f;\n\t\t\t\tstruct musb_ep\t\t*musb_ep;\n\t\t\t\tstruct musb_hw_ep\t*ep;\n\t\t\t\tstruct musb_request\t*request;\n\t\t\t\tvoid __iomem\t\t*regs;\n\t\t\t\tint\t\t\tis_in;\n\t\t\t\tu16\t\t\tcsr;\n\n\t\t\t\tif (epnum == 0 || epnum >= MUSB_C_NUM_EPS ||\n\t\t\t\t    ctrlrequest->wValue != USB_ENDPOINT_HALT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tep = musb->endpoints + epnum;\n\t\t\t\tregs = ep->regs;\n\t\t\t\tis_in = ctrlrequest->wIndex & USB_DIR_IN;\n\t\t\t\tif (is_in)\n\t\t\t\t\tmusb_ep = &ep->ep_in;\n\t\t\t\telse\n\t\t\t\t\tmusb_ep = &ep->ep_out;\n\t\t\t\tif (!musb_ep->desc)\n\t\t\t\t\tbreak;\n\n\t\t\t\thandled = 1;\n\t\t\t\t \n\t\t\t\tif (musb_ep->wedged)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\t\tif (is_in) {\n\t\t\t\t\tcsr  = musb_readw(regs, MUSB_TXCSR);\n\t\t\t\t\tcsr |= MUSB_TXCSR_CLRDATATOG |\n\t\t\t\t\t       MUSB_TXCSR_P_WZC_BITS;\n\t\t\t\t\tcsr &= ~(MUSB_TXCSR_P_SENDSTALL |\n\t\t\t\t\t\t MUSB_TXCSR_P_SENTSTALL |\n\t\t\t\t\t\t MUSB_TXCSR_TXPKTRDY);\n\t\t\t\t\tmusb_writew(regs, MUSB_TXCSR, csr);\n\t\t\t\t} else {\n\t\t\t\t\tcsr  = musb_readw(regs, MUSB_RXCSR);\n\t\t\t\t\tcsr |= MUSB_RXCSR_CLRDATATOG |\n\t\t\t\t\t       MUSB_RXCSR_P_WZC_BITS;\n\t\t\t\t\tcsr &= ~(MUSB_RXCSR_P_SENDSTALL |\n\t\t\t\t\t\t MUSB_RXCSR_P_SENTSTALL);\n\t\t\t\t\tmusb_writew(regs, MUSB_RXCSR, csr);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\trequest = next_request(musb_ep);\n\t\t\t\tif (!musb_ep->busy && request) {\n\t\t\t\t\tmusb_dbg(musb, \"restarting the request\");\n\t\t\t\t\tmusb_ep_restart(musb, request);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmusb_ep_select(mbase, 0);\n\t\t\t\t} break;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\thandled = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tswitch (recip) {\n\t\t\tcase USB_RECIP_DEVICE:\n\t\t\t\thandled = 1;\n\t\t\t\tswitch (ctrlrequest->wValue) {\n\t\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\t\tmusb->may_wakeup = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t\t\tif (musb->g.speed != USB_SPEED_HIGH)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t\tif (ctrlrequest->wIndex & 0xff)\n\t\t\t\t\t\tgoto stall;\n\n\t\t\t\t\tswitch (ctrlrequest->wIndex >> 8) {\n\t\t\t\t\tcase USB_TEST_J:\n\t\t\t\t\t\tpr_debug(\"USB_TEST_J\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_J;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase USB_TEST_K:\n\t\t\t\t\t\tpr_debug(\"USB_TEST_K\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_K;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase USB_TEST_SE0_NAK:\n\t\t\t\t\t\tpr_debug(\"USB_TEST_SE0_NAK\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_SE0_NAK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase USB_TEST_PACKET:\n\t\t\t\t\t\tpr_debug(\"USB_TEST_PACKET\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_PACKET;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 0xc0:\n\t\t\t\t\t\t \n\t\t\t\t\t\tpr_debug(\"TEST_FORCE_HS\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_FORCE_HS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0xc1:\n\t\t\t\t\t\t \n\t\t\t\t\t\tpr_debug(\"TEST_FORCE_FS\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_FORCE_FS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0xc2:\n\t\t\t\t\t\t \n\t\t\t\t\t\tpr_debug(\"TEST_FIFO_ACCESS\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_FIFO_ACCESS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 0xc3:\n\t\t\t\t\t\t \n\t\t\t\t\t\tpr_debug(\"TEST_FORCE_HOST\\n\");\n\t\t\t\t\t\tmusb->test_mode_nr =\n\t\t\t\t\t\t\tMUSB_TEST_FORCE_HOST;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t\t}\n\n\t\t\t\t\t \n\t\t\t\t\tif (handled > 0)\n\t\t\t\t\t\tmusb->test_mode = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_DEVICE_B_HNP_ENABLE:\n\t\t\t\t\tif (!musb->g.is_otg)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t\tmusb->g.b_hnp_enable = 1;\n\t\t\t\t\tmusb_try_b_hnp_enable(musb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_DEVICE_A_HNP_SUPPORT:\n\t\t\t\t\tif (!musb->g.is_otg)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t\tmusb->g.a_hnp_support = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_DEVICE_A_ALT_HNP_SUPPORT:\n\t\t\t\t\tif (!musb->g.is_otg)\n\t\t\t\t\t\tgoto stall;\n\t\t\t\t\tmusb->g.a_alt_hnp_support = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_DEVICE_DEBUG_MODE:\n\t\t\t\t\thandled = 0;\n\t\t\t\t\tbreak;\nstall:\n\t\t\t\tdefault:\n\t\t\t\t\thandled = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase USB_RECIP_INTERFACE:\n\t\t\t\tbreak;\n\n\t\t\tcase USB_RECIP_ENDPOINT:{\n\t\t\t\tconst u8\t\tepnum =\n\t\t\t\t\tctrlrequest->wIndex & 0x0f;\n\t\t\t\tstruct musb_ep\t\t*musb_ep;\n\t\t\t\tstruct musb_hw_ep\t*ep;\n\t\t\t\tvoid __iomem\t\t*regs;\n\t\t\t\tint\t\t\tis_in;\n\t\t\t\tu16\t\t\tcsr;\n\n\t\t\t\tif (epnum == 0 || epnum >= MUSB_C_NUM_EPS ||\n\t\t\t\t    ctrlrequest->wValue\t!= USB_ENDPOINT_HALT)\n\t\t\t\t\tbreak;\n\n\t\t\t\tep = musb->endpoints + epnum;\n\t\t\t\tregs = ep->regs;\n\t\t\t\tis_in = ctrlrequest->wIndex & USB_DIR_IN;\n\t\t\t\tif (is_in)\n\t\t\t\t\tmusb_ep = &ep->ep_in;\n\t\t\t\telse\n\t\t\t\t\tmusb_ep = &ep->ep_out;\n\t\t\t\tif (!musb_ep->desc)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmusb_ep_select(mbase, epnum);\n\t\t\t\tif (is_in) {\n\t\t\t\t\tcsr = musb_readw(regs, MUSB_TXCSR);\n\t\t\t\t\tif (csr & MUSB_TXCSR_FIFONOTEMPTY)\n\t\t\t\t\t\tcsr |= MUSB_TXCSR_FLUSHFIFO;\n\t\t\t\t\tcsr |= MUSB_TXCSR_P_SENDSTALL\n\t\t\t\t\t\t| MUSB_TXCSR_CLRDATATOG\n\t\t\t\t\t\t| MUSB_TXCSR_P_WZC_BITS;\n\t\t\t\t\tmusb_writew(regs, MUSB_TXCSR, csr);\n\t\t\t\t} else {\n\t\t\t\t\tcsr = musb_readw(regs, MUSB_RXCSR);\n\t\t\t\t\tcsr |= MUSB_RXCSR_P_SENDSTALL\n\t\t\t\t\t\t| MUSB_RXCSR_FLUSHFIFO\n\t\t\t\t\t\t| MUSB_RXCSR_CLRDATATOG\n\t\t\t\t\t\t| MUSB_RXCSR_P_WZC_BITS;\n\t\t\t\t\tmusb_writew(regs, MUSB_RXCSR, csr);\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tmusb_ep_select(mbase, 0);\n\t\t\t\thandled = 1;\n\t\t\t\t} break;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\thandled = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\thandled = 0;\n\t\t}\n\t} else\n\t\thandled = 0;\n\treturn handled;\n}\n\n \nstatic void ep0_rxstate(struct musb *musb)\n{\n\tvoid __iomem\t\t*regs = musb->control_ep->regs;\n\tstruct musb_request\t*request;\n\tstruct usb_request\t*req;\n\tu16\t\t\tcount, csr;\n\n\trequest = next_ep0_request(musb);\n\treq = &request->request;\n\n\t \n\tif (req) {\n\t\tvoid\t\t*buf = req->buf + req->actual;\n\t\tunsigned\tlen = req->length - req->actual;\n\n\t\t \n\t\tcount = musb_readb(regs, MUSB_COUNT0);\n\t\tif (count > len) {\n\t\t\treq->status = -EOVERFLOW;\n\t\t\tcount = len;\n\t\t}\n\t\tif (count > 0) {\n\t\t\tmusb_read_fifo(&musb->endpoints[0], count, buf);\n\t\t\treq->actual += count;\n\t\t}\n\t\tcsr = MUSB_CSR0_P_SVDRXPKTRDY;\n\t\tif (count < 64 || req->actual == req->length) {\n\t\t\tmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\n\t\t\tcsr |= MUSB_CSR0_P_DATAEND;\n\t\t} else\n\t\t\treq = NULL;\n\t} else\n\t\tcsr = MUSB_CSR0_P_SVDRXPKTRDY | MUSB_CSR0_P_SENDSTALL;\n\n\n\t \n\tif (req) {\n\t\tmusb->ackpend = csr;\n\t\tmusb_g_ep0_giveback(musb, req);\n\t\tif (!musb->ackpend)\n\t\t\treturn;\n\t\tmusb->ackpend = 0;\n\t}\n\tmusb_ep_select(musb->mregs, 0);\n\tmusb_writew(regs, MUSB_CSR0, csr);\n}\n\n \nstatic void ep0_txstate(struct musb *musb)\n{\n\tvoid __iomem\t\t*regs = musb->control_ep->regs;\n\tstruct musb_request\t*req = next_ep0_request(musb);\n\tstruct usb_request\t*request;\n\tu16\t\t\tcsr = MUSB_CSR0_TXPKTRDY;\n\tu8\t\t\t*fifo_src;\n\tu8\t\t\tfifo_count;\n\n\tif (!req) {\n\t\t \n\t\tmusb_dbg(musb, \"odd; csr0 %04x\", musb_readw(regs, MUSB_CSR0));\n\t\treturn;\n\t}\n\n\trequest = &req->request;\n\n\t \n\tfifo_src = (u8 *) request->buf + request->actual;\n\tfifo_count = min((unsigned) MUSB_EP0_FIFOSIZE,\n\t\trequest->length - request->actual);\n\tmusb_write_fifo(&musb->endpoints[0], fifo_count, fifo_src);\n\trequest->actual += fifo_count;\n\n\t \n\tif (fifo_count < MUSB_MAX_END0_PACKET\n\t\t\t|| (request->actual == request->length\n\t\t\t\t&& !request->zero)) {\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_STATUSOUT;\n\t\tcsr |= MUSB_CSR0_P_DATAEND;\n\t} else\n\t\trequest = NULL;\n\n\t \n\tif (request) {\n\t\tmusb->ackpend = csr;\n\t\tmusb_g_ep0_giveback(musb, request);\n\t\tif (!musb->ackpend)\n\t\t\treturn;\n\t\tmusb->ackpend = 0;\n\t}\n\n\t \n\tmusb_ep_select(musb->mregs, 0);\n\tmusb_writew(regs, MUSB_CSR0, csr);\n}\n\n \nstatic void\nmusb_read_setup(struct musb *musb, struct usb_ctrlrequest *req)\n{\n\tstruct musb_request\t*r;\n\tvoid __iomem\t\t*regs = musb->control_ep->regs;\n\n\tmusb_read_fifo(&musb->endpoints[0], sizeof *req, (u8 *)req);\n\n\t \n\tmusb_dbg(musb, \"SETUP req%02x.%02x v%04x i%04x l%d\",\n\t\treq->bRequestType,\n\t\treq->bRequest,\n\t\tle16_to_cpu(req->wValue),\n\t\tle16_to_cpu(req->wIndex),\n\t\tle16_to_cpu(req->wLength));\n\n\t \n\tr = next_ep0_request(musb);\n\tif (r)\n\t\tmusb_g_ep0_giveback(musb, &r->request);\n\n\t \n\tmusb->set_address = false;\n\tmusb->ackpend = MUSB_CSR0_P_SVDRXPKTRDY;\n\tif (req->wLength == 0) {\n\t\tif (req->bRequestType & USB_DIR_IN)\n\t\t\tmusb->ackpend |= MUSB_CSR0_TXPKTRDY;\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_ACKWAIT;\n\t} else if (req->bRequestType & USB_DIR_IN) {\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_TX;\n\t\tmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDRXPKTRDY);\n\t\twhile ((musb_readw(regs, MUSB_CSR0)\n\t\t\t\t& MUSB_CSR0_RXPKTRDY) != 0)\n\t\t\tcpu_relax();\n\t\tmusb->ackpend = 0;\n\t} else\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_RX;\n}\n\nstatic int\nforward_to_driver(struct musb *musb, const struct usb_ctrlrequest *ctrlrequest)\n__releases(musb->lock)\n__acquires(musb->lock)\n{\n\tint retval;\n\tif (!musb->gadget_driver)\n\t\treturn -EOPNOTSUPP;\n\tspin_unlock(&musb->lock);\n\tretval = musb->gadget_driver->setup(&musb->g, ctrlrequest);\n\tspin_lock(&musb->lock);\n\treturn retval;\n}\n\n \nirqreturn_t musb_g_ep0_irq(struct musb *musb)\n{\n\tu16\t\tcsr;\n\tu16\t\tlen;\n\tvoid __iomem\t*mbase = musb->mregs;\n\tvoid __iomem\t*regs = musb->endpoints[0].regs;\n\tirqreturn_t\tretval = IRQ_NONE;\n\n\tmusb_ep_select(mbase, 0);\t \n\tcsr = musb_readw(regs, MUSB_CSR0);\n\tlen = musb_readb(regs, MUSB_COUNT0);\n\n\tmusb_dbg(musb, \"csr %04x, count %d, ep0stage %s\",\n\t\t\tcsr, len, decode_ep0stage(musb->ep0_state));\n\n\tif (csr & MUSB_CSR0_P_DATAEND) {\n\t\t \n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (csr & MUSB_CSR0_P_SENTSTALL) {\n\t\tmusb_writew(regs, MUSB_CSR0,\n\t\t\t\tcsr & ~MUSB_CSR0_P_SENTSTALL);\n\t\tretval = IRQ_HANDLED;\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\n\t\tcsr = musb_readw(regs, MUSB_CSR0);\n\t}\n\n\t \n\tif (csr & MUSB_CSR0_P_SETUPEND) {\n\t\tmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SVDSETUPEND);\n\t\tretval = IRQ_HANDLED;\n\t\t \n\t\tswitch (musb->ep0_state) {\n\t\tcase MUSB_EP0_STAGE_TX:\n\t\t\tmusb->ep0_state = MUSB_EP0_STAGE_STATUSOUT;\n\t\t\tbreak;\n\t\tcase MUSB_EP0_STAGE_RX:\n\t\t\tmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERR(\"SetupEnd came in a wrong ep0stage %s\\n\",\n\t\t\t    decode_ep0stage(musb->ep0_state));\n\t\t}\n\t\tcsr = musb_readw(regs, MUSB_CSR0);\n\t\t \n\t}\n\n\t \n\tswitch (musb->ep0_state) {\n\n\tcase MUSB_EP0_STAGE_TX:\n\t\t \n\t\tif ((csr & MUSB_CSR0_TXPKTRDY) == 0) {\n\t\t\tep0_txstate(musb);\n\t\t\tretval = IRQ_HANDLED;\n\t\t}\n\t\tbreak;\n\n\tcase MUSB_EP0_STAGE_RX:\n\t\t \n\t\tif (csr & MUSB_CSR0_RXPKTRDY) {\n\t\t\tep0_rxstate(musb);\n\t\t\tretval = IRQ_HANDLED;\n\t\t}\n\t\tbreak;\n\n\tcase MUSB_EP0_STAGE_STATUSIN:\n\t\t \n\n\t\t \n\t\tif (musb->set_address) {\n\t\t\tmusb->set_address = false;\n\t\t\tmusb_writeb(mbase, MUSB_FADDR, musb->address);\n\t\t}\n\n\t\t \n\t\telse if (musb->test_mode) {\n\t\t\tmusb_dbg(musb, \"entering TESTMODE\");\n\n\t\t\tif (MUSB_TEST_PACKET == musb->test_mode_nr)\n\t\t\t\tmusb_load_testpacket(musb);\n\n\t\t\tmusb_writeb(mbase, MUSB_TESTMODE,\n\t\t\t\t\tmusb->test_mode_nr);\n\t\t}\n\t\tfallthrough;\n\n\tcase MUSB_EP0_STAGE_STATUSOUT:\n\t\t \n\t\t{\n\t\t\tstruct musb_request\t*req;\n\n\t\t\treq = next_ep0_request(musb);\n\t\t\tif (req)\n\t\t\t\tmusb_g_ep0_giveback(musb, &req->request);\n\t\t}\n\n\t\t \n\t\tif (csr & MUSB_CSR0_RXPKTRDY)\n\t\t\tgoto setup;\n\n\t\tretval = IRQ_HANDLED;\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\n\t\tbreak;\n\n\tcase MUSB_EP0_STAGE_IDLE:\n\t\t \n\t\tretval = IRQ_HANDLED;\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_SETUP;\n\t\tfallthrough;\n\n\tcase MUSB_EP0_STAGE_SETUP:\nsetup:\n\t\tif (csr & MUSB_CSR0_RXPKTRDY) {\n\t\t\tstruct usb_ctrlrequest\tsetup;\n\t\t\tint\t\t\thandled = 0;\n\n\t\t\tif (len != 8) {\n\t\t\t\tERR(\"SETUP packet len %d != 8 ?\\n\", len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmusb_read_setup(musb, &setup);\n\t\t\tretval = IRQ_HANDLED;\n\n\t\t\t \n\t\t\tif (unlikely(musb->g.speed == USB_SPEED_UNKNOWN)) {\n\t\t\t\tu8\tpower;\n\n\t\t\t\tprintk(KERN_NOTICE \"%s: peripheral reset \"\n\t\t\t\t\t\t\"irq lost!\\n\",\n\t\t\t\t\t\tmusb_driver_name);\n\t\t\t\tpower = musb_readb(mbase, MUSB_POWER);\n\t\t\t\tmusb->g.speed = (power & MUSB_POWER_HSMODE)\n\t\t\t\t\t? USB_SPEED_HIGH : USB_SPEED_FULL;\n\n\t\t\t}\n\n\t\t\tswitch (musb->ep0_state) {\n\n\t\t\t \n\t\t\tcase MUSB_EP0_STAGE_ACKWAIT:\n\t\t\t\thandled = service_zero_data_request(\n\t\t\t\t\t\tmusb, &setup);\n\n\t\t\t\t \n\t\t\t\tmusb->ackpend |= MUSB_CSR0_P_DATAEND;\n\n\t\t\t\t \n\t\t\t\tif (handled > 0)\n\t\t\t\t\tmusb->ep0_state =\n\t\t\t\t\t\tMUSB_EP0_STAGE_STATUSIN;\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tcase MUSB_EP0_STAGE_TX:\n\t\t\t\thandled = service_in_request(musb, &setup);\n\t\t\t\tif (handled > 0) {\n\t\t\t\t\tmusb->ackpend = MUSB_CSR0_TXPKTRDY\n\t\t\t\t\t\t| MUSB_CSR0_P_DATAEND;\n\t\t\t\t\tmusb->ep0_state =\n\t\t\t\t\t\tMUSB_EP0_STAGE_STATUSOUT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tdefault:\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tmusb_dbg(musb, \"handled %d, csr %04x, ep0stage %s\",\n\t\t\t\thandled, csr,\n\t\t\t\tdecode_ep0stage(musb->ep0_state));\n\n\t\t\t \n\t\t\tif (handled < 0)\n\t\t\t\tgoto stall;\n\t\t\telse if (handled > 0)\n\t\t\t\tgoto finish;\n\n\t\t\thandled = forward_to_driver(musb, &setup);\n\t\t\tif (handled < 0) {\n\t\t\t\tmusb_ep_select(mbase, 0);\nstall:\n\t\t\t\tmusb_dbg(musb, \"stall (%d)\", handled);\n\t\t\t\tmusb->ackpend |= MUSB_CSR0_P_SENDSTALL;\n\t\t\t\tmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\nfinish:\n\t\t\t\tmusb_writew(regs, MUSB_CSR0,\n\t\t\t\t\t\tmusb->ackpend);\n\t\t\t\tmusb->ackpend = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase MUSB_EP0_STAGE_ACKWAIT:\n\t\t \n\t\tretval = IRQ_HANDLED;\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tWARN_ON(1);\n\t\tmusb_writew(regs, MUSB_CSR0, MUSB_CSR0_P_SENDSTALL);\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\n\nstatic int\nmusb_g_ep0_enable(struct usb_ep *ep, const struct usb_endpoint_descriptor *desc)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int musb_g_ep0_disable(struct usb_ep *e)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int\nmusb_g_ep0_queue(struct usb_ep *e, struct usb_request *r, gfp_t gfp_flags)\n{\n\tstruct musb_ep\t\t*ep;\n\tstruct musb_request\t*req;\n\tstruct musb\t\t*musb;\n\tint\t\t\tstatus;\n\tunsigned long\t\tlockflags;\n\tvoid __iomem\t\t*regs;\n\n\tif (!e || !r)\n\t\treturn -EINVAL;\n\n\tep = to_musb_ep(e);\n\tmusb = ep->musb;\n\tregs = musb->control_ep->regs;\n\n\treq = to_musb_request(r);\n\treq->musb = musb;\n\treq->request.actual = 0;\n\treq->request.status = -EINPROGRESS;\n\treq->tx = ep->is_in;\n\n\tspin_lock_irqsave(&musb->lock, lockflags);\n\n\tif (!list_empty(&ep->req_list)) {\n\t\tstatus = -EBUSY;\n\t\tgoto cleanup;\n\t}\n\n\tswitch (musb->ep0_state) {\n\tcase MUSB_EP0_STAGE_RX:\t\t \n\tcase MUSB_EP0_STAGE_TX:\t\t \n\tcase MUSB_EP0_STAGE_ACKWAIT:\t \n\t\tstatus = 0;\n\t\tbreak;\n\tdefault:\n\t\tmusb_dbg(musb, \"ep0 request queued in state %d\",\n\t\t\t\tmusb->ep0_state);\n\t\tstatus = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t \n\tlist_add_tail(&req->list, &ep->req_list);\n\n\tmusb_dbg(musb, \"queue to %s (%s), length=%d\",\n\t\t\tep->name, ep->is_in ? \"IN/TX\" : \"OUT/RX\",\n\t\t\treq->request.length);\n\n\tmusb_ep_select(musb->mregs, 0);\n\n\t \n\tif (musb->ep0_state == MUSB_EP0_STAGE_TX)\n\t\tep0_txstate(musb);\n\n\t \n\telse if (musb->ep0_state == MUSB_EP0_STAGE_ACKWAIT) {\n\t\tif (req->request.length)\n\t\t\tstatus = -EINVAL;\n\t\telse {\n\t\t\tmusb->ep0_state = MUSB_EP0_STAGE_STATUSIN;\n\t\t\tmusb_writew(regs, MUSB_CSR0,\n\t\t\t\t\tmusb->ackpend | MUSB_CSR0_P_DATAEND);\n\t\t\tmusb->ackpend = 0;\n\t\t\tmusb_g_ep0_giveback(ep->musb, r);\n\t\t}\n\n\t \n\t} else if (musb->ackpend) {\n\t\tmusb_writew(regs, MUSB_CSR0, musb->ackpend);\n\t\tmusb->ackpend = 0;\n\t}\n\ncleanup:\n\tspin_unlock_irqrestore(&musb->lock, lockflags);\n\treturn status;\n}\n\nstatic int musb_g_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int musb_g_ep0_halt(struct usb_ep *e, int value)\n{\n\tstruct musb_ep\t\t*ep;\n\tstruct musb\t\t*musb;\n\tvoid __iomem\t\t*base, *regs;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus;\n\tu16\t\t\tcsr;\n\n\tif (!e || !value)\n\t\treturn -EINVAL;\n\n\tep = to_musb_ep(e);\n\tmusb = ep->musb;\n\tbase = musb->mregs;\n\tregs = musb->control_ep->regs;\n\tstatus = 0;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\tif (!list_empty(&ep->req_list)) {\n\t\tstatus = -EBUSY;\n\t\tgoto cleanup;\n\t}\n\n\tmusb_ep_select(base, 0);\n\tcsr = musb->ackpend;\n\n\tswitch (musb->ep0_state) {\n\n\t \n\tcase MUSB_EP0_STAGE_TX:\t\t \n\tcase MUSB_EP0_STAGE_ACKWAIT:\t \n\tcase MUSB_EP0_STAGE_RX:\t\t \n\t\tcsr = musb_readw(regs, MUSB_CSR0);\n\t\tfallthrough;\n\n\t \n\tcase MUSB_EP0_STAGE_STATUSIN:\t \n\tcase MUSB_EP0_STAGE_STATUSOUT:\t \n\n\t\tcsr |= MUSB_CSR0_P_SENDSTALL;\n\t\tmusb_writew(regs, MUSB_CSR0, csr);\n\t\tmusb->ep0_state = MUSB_EP0_STAGE_IDLE;\n\t\tmusb->ackpend = 0;\n\t\tbreak;\n\tdefault:\n\t\tmusb_dbg(musb, \"ep0 can't halt in state %d\", musb->ep0_state);\n\t\tstatus = -EINVAL;\n\t}\n\ncleanup:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\treturn status;\n}\n\nconst struct usb_ep_ops musb_g_ep0_ops = {\n\t.enable\t\t= musb_g_ep0_enable,\n\t.disable\t= musb_g_ep0_disable,\n\t.alloc_request\t= musb_alloc_request,\n\t.free_request\t= musb_free_request,\n\t.queue\t\t= musb_g_ep0_queue,\n\t.dequeue\t= musb_g_ep0_dequeue,\n\t.set_halt\t= musb_g_ep0_halt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}