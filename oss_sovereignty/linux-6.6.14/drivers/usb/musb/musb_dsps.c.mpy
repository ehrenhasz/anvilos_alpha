{
  "module_name": "musb_dsps.c",
  "hash_id": "49a6040e5854e8c9dbbb76d33e4785b149ff3e48d6c1756918f60e9caebcee63",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/musb/musb_dsps.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/err.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/pm_runtime.h>\n#include <linux/module.h>\n#include <linux/usb/usb_phy_generic.h>\n#include <linux/platform_data/usb-omap.h>\n#include <linux/sizes.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/usb/of.h>\n\n#include <linux/debugfs.h>\n\n#include \"musb_core.h\"\n\nstatic const struct of_device_id musb_dsps_of_match[];\n\n \nstruct dsps_musb_wrapper {\n\tu16\trevision;\n\tu16\tcontrol;\n\tu16\tstatus;\n\tu16\tepintr_set;\n\tu16\tepintr_clear;\n\tu16\tepintr_status;\n\tu16\tcoreintr_set;\n\tu16\tcoreintr_clear;\n\tu16\tcoreintr_status;\n\tu16\tphy_utmi;\n\tu16\tmode;\n\tu16\ttx_mode;\n\tu16\trx_mode;\n\n\t \n\tunsigned\treset:5;\n\n\t \n\tunsigned\tusb_shift:5;\n\tu32\t\tusb_mask;\n\tu32\t\tusb_bitmap;\n\tunsigned\tdrvvbus:5;\n\n\tunsigned\ttxep_shift:5;\n\tu32\t\ttxep_mask;\n\tu32\t\ttxep_bitmap;\n\n\tunsigned\trxep_shift:5;\n\tu32\t\trxep_mask;\n\tu32\t\trxep_bitmap;\n\n\t \n\tunsigned\totg_disable:5;\n\n\t \n\tunsigned\tiddig:5;\n\tunsigned\tiddig_mux:5;\n\t \n\tunsigned\tpoll_timeout;\n};\n\n \nstruct dsps_context {\n\tu32 control;\n\tu32 epintr;\n\tu32 coreintr;\n\tu32 phy_utmi;\n\tu32 mode;\n\tu32 tx_mode;\n\tu32 rx_mode;\n};\n\n \nstruct dsps_glue {\n\tstruct device *dev;\n\tstruct platform_device *musb;\t \n\tconst struct dsps_musb_wrapper *wrp;  \n\tint vbus_irq;\t\t\t \n\tunsigned long last_timer;     \n\tbool sw_babble_enabled;\n\tvoid __iomem *usbss_base;\n\n\tstruct dsps_context context;\n\tstruct debugfs_regset32 regset;\n\tstruct dentry *dbgfs_root;\n};\n\nstatic const struct debugfs_reg32 dsps_musb_regs[] = {\n\t{ \"revision\",\t\t0x00 },\n\t{ \"control\",\t\t0x14 },\n\t{ \"status\",\t\t0x18 },\n\t{ \"eoi\",\t\t0x24 },\n\t{ \"intr0_stat\",\t\t0x30 },\n\t{ \"intr1_stat\",\t\t0x34 },\n\t{ \"intr0_set\",\t\t0x38 },\n\t{ \"intr1_set\",\t\t0x3c },\n\t{ \"txmode\",\t\t0x70 },\n\t{ \"rxmode\",\t\t0x74 },\n\t{ \"autoreq\",\t\t0xd0 },\n\t{ \"srpfixtime\",\t\t0xd4 },\n\t{ \"tdown\",\t\t0xd8 },\n\t{ \"phy_utmi\",\t\t0xe0 },\n\t{ \"mode\",\t\t0xe8 },\n};\n\nstatic void dsps_mod_timer(struct dsps_glue *glue, int wait_ms)\n{\n\tstruct musb *musb = platform_get_drvdata(glue->musb);\n\tint wait;\n\n\tif (wait_ms < 0)\n\t\twait = msecs_to_jiffies(glue->wrp->poll_timeout);\n\telse\n\t\twait = msecs_to_jiffies(wait_ms);\n\n\tmod_timer(&musb->dev_timer, jiffies + wait);\n}\n\n \nstatic void dsps_mod_timer_optional(struct dsps_glue *glue)\n{\n\tif (glue->vbus_irq)\n\t\treturn;\n\n\tdsps_mod_timer(glue, -1);\n}\n\n \n#define USBSS_IRQ_STATUS\t0x28\n#define USBSS_IRQ_ENABLER\t0x2c\n#define USBSS_IRQ_CLEARR\t0x30\n\n#define USBSS_IRQ_PD_COMP\t(1 << 2)\n\n \nstatic void dsps_musb_enable(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\tu32 epmask, coremask;\n\n\t \n\tepmask = ((musb->epmask & wrp->txep_mask) << wrp->txep_shift) |\n\t       ((musb->epmask & wrp->rxep_mask) << wrp->rxep_shift);\n\tcoremask = (wrp->usb_bitmap & ~MUSB_INTR_SOF);\n\n\tmusb_writel(reg_base, wrp->epintr_set, epmask);\n\tmusb_writel(reg_base, wrp->coreintr_set, coremask);\n\t \n\tif (musb->xceiv->otg->state == OTG_STATE_B_IDLE)\n\t\tdsps_mod_timer(glue, -1);\n}\n\n \nstatic void dsps_musb_disable(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\n\tmusb_writel(reg_base, wrp->coreintr_clear, wrp->usb_bitmap);\n\tmusb_writel(reg_base, wrp->epintr_clear,\n\t\t\t wrp->txep_bitmap | wrp->rxep_bitmap);\n\tdel_timer_sync(&musb->dev_timer);\n}\n\n \nstatic int dsps_check_status(struct musb *musb, void *unused)\n{\n\tvoid __iomem *mregs = musb->mregs;\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tu8 devctl;\n\tint skip_session = 0;\n\n\tif (glue->vbus_irq)\n\t\tdel_timer(&musb->dev_timer);\n\n\t \n\tdevctl = musb_readb(mregs, MUSB_DEVCTL);\n\tdev_dbg(musb->controller, \"Poll devctl %02x (%s)\\n\", devctl,\n\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state));\n\n\tswitch (musb->xceiv->otg->state) {\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\tif (musb->port_mode == MUSB_HOST) {\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\n\t\t\tdsps_mod_timer_optional(glue);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\t \n\t\tif (musb->port_mode == MUSB_HOST) {\n\t\t\tdsps_mod_timer_optional(glue);\n\t\t\tbreak;\n\t\t}\n\t\tmusb_writeb(musb->mregs, MUSB_DEVCTL, 0);\n\t\tskip_session = 1;\n\t\tfallthrough;\n\n\tcase OTG_STATE_A_IDLE:\n\tcase OTG_STATE_B_IDLE:\n\t\tif (!glue->vbus_irq) {\n\t\t\tif (devctl & MUSB_DEVCTL_BDEVICE) {\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t\t\tMUSB_DEV_MODE(musb);\n\t\t\t} else {\n\t\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\n\t\t\t\tMUSB_HST_MODE(musb);\n\t\t\t}\n\n\t\t\tif (musb->port_mode == MUSB_PERIPHERAL)\n\t\t\t\tskip_session = 1;\n\n\t\t\tif (!(devctl & MUSB_DEVCTL_SESSION) && !skip_session)\n\t\t\t\tmusb_writeb(mregs, MUSB_DEVCTL,\n\t\t\t\t\t    MUSB_DEVCTL_SESSION);\n\t\t}\n\t\tdsps_mod_timer_optional(glue);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\tmusb_writel(musb->ctrl_base, wrp->coreintr_set,\n\t\t\t    MUSB_INTR_VBUSERROR << wrp->usb_shift);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void otg_timer(struct timer_list *t)\n{\n\tstruct musb *musb = from_timer(musb, t, dev_timer);\n\tstruct device *dev = musb->controller;\n\tunsigned long flags;\n\tint err;\n\n\terr = pm_runtime_get(dev);\n\tif ((err != -EINPROGRESS) && err < 0) {\n\t\tdev_err(dev, \"Poll could not pm_runtime_get: %i\\n\", err);\n\t\tpm_runtime_put_noidle(dev);\n\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\terr = musb_queue_resume_work(musb, dsps_check_status, NULL);\n\tif (err < 0)\n\t\tdev_err(dev, \"%s resume work: %i\\n\", __func__, err);\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\nstatic void dsps_musb_clear_ep_rxintr(struct musb *musb, int epnum)\n{\n\tu32 epintr;\n\tstruct dsps_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\n\t \n\tepintr = (1 << epnum) << wrp->rxep_shift;\n\tmusb_writel(musb->ctrl_base, wrp->epintr_status, epintr);\n}\n\nstatic irqreturn_t dsps_interrupt(int irq, void *hci)\n{\n\tstruct musb  *musb = hci;\n\tvoid __iomem *reg_base = musb->ctrl_base;\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tunsigned long flags;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 epintr, usbintr;\n\n\tspin_lock_irqsave(&musb->lock, flags);\n\n\t \n\tepintr = musb_readl(reg_base, wrp->epintr_status);\n\tmusb->int_rx = (epintr & wrp->rxep_bitmap) >> wrp->rxep_shift;\n\tmusb->int_tx = (epintr & wrp->txep_bitmap) >> wrp->txep_shift;\n\n\tif (epintr)\n\t\tmusb_writel(reg_base, wrp->epintr_status, epintr);\n\n\t \n\tusbintr = musb_readl(reg_base, wrp->coreintr_status);\n\tif (!usbintr && !epintr)\n\t\tgoto out;\n\n\tmusb->int_usb =\t(usbintr & wrp->usb_bitmap) >> wrp->usb_shift;\n\tif (usbintr)\n\t\tmusb_writel(reg_base, wrp->coreintr_status, usbintr);\n\n\tdev_dbg(musb->controller, \"usbintr (%x) epintr(%x)\\n\",\n\t\t\tusbintr, epintr);\n\n\tif (usbintr & ((1 << wrp->drvvbus) << wrp->usb_shift)) {\n\t\tint drvvbus = musb_readl(reg_base, wrp->status);\n\t\tvoid __iomem *mregs = musb->mregs;\n\t\tu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\n\t\tint err;\n\n\t\terr = musb->int_usb & MUSB_INTR_VBUSERROR;\n\t\tif (err) {\n\t\t\t \n\t\t\tmusb->int_usb &= ~MUSB_INTR_VBUSERROR;\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VFALL;\n\t\t\tdsps_mod_timer_optional(glue);\n\t\t\tWARNING(\"VBUS error workaround (delay coming)\\n\");\n\t\t} else if (drvvbus) {\n\t\t\tMUSB_HST_MODE(musb);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\n\t\t\tdsps_mod_timer_optional(glue);\n\t\t} else {\n\t\t\tmusb->is_active = 0;\n\t\t\tMUSB_DEV_MODE(musb);\n\t\t\tmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\n\t\t}\n\n\t\t \n\t\tdev_dbg(musb->controller, \"VBUS %s (%s)%s, devctl %02x\\n\",\n\t\t\t\tdrvvbus ? \"on\" : \"off\",\n\t\t\t\tusb_otg_state_string(musb->xceiv->otg->state),\n\t\t\t\terr ? \" ERROR\" : \"\",\n\t\t\t\tdevctl);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (musb->int_tx || musb->int_rx || musb->int_usb)\n\t\tret |= musb_interrupt(musb);\n\n\t \n\tswitch (musb->xceiv->otg->state) {\n\tcase OTG_STATE_B_IDLE:\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tdsps_mod_timer_optional(glue);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&musb->lock, flags);\n\n\treturn ret;\n}\n\nstatic int dsps_musb_dbg_init(struct musb *musb, struct dsps_glue *glue)\n{\n\tstruct dentry *root;\n\tchar buf[128];\n\n\tsprintf(buf, \"%s.dsps\", dev_name(musb->controller));\n\troot = debugfs_create_dir(buf, usb_debug_root);\n\tglue->dbgfs_root = root;\n\n\tglue->regset.regs = dsps_musb_regs;\n\tglue->regset.nregs = ARRAY_SIZE(dsps_musb_regs);\n\tglue->regset.base = musb->ctrl_base;\n\n\tdebugfs_create_regset32(\"regdump\", S_IRUGO, root, &glue->regset);\n\treturn 0;\n}\n\nstatic int dsps_musb_init(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tstruct platform_device *parent = to_platform_device(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tvoid __iomem *reg_base;\n\tstruct resource *r;\n\tu32 rev, val;\n\tint ret;\n\n\tr = platform_get_resource_byname(parent, IORESOURCE_MEM, \"control\");\n\treg_base = devm_ioremap_resource(dev, r);\n\tif (IS_ERR(reg_base))\n\t\treturn PTR_ERR(reg_base);\n\tmusb->ctrl_base = reg_base;\n\n\t \n\tmusb->xceiv = devm_usb_get_phy_by_phandle(dev->parent, \"phys\", 0);\n\tif (IS_ERR(musb->xceiv))\n\t\treturn PTR_ERR(musb->xceiv);\n\n\tmusb->phy = devm_phy_get(dev->parent, \"usb2-phy\");\n\n\t \n\trev = musb_readl(reg_base, wrp->revision);\n\tif (!rev)\n\t\treturn -ENODEV;\n\n\tif (IS_ERR(musb->phy))  {\n\t\tmusb->phy = NULL;\n\t} else {\n\t\tret = phy_init(musb->phy);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = phy_power_on(musb->phy);\n\t\tif (ret) {\n\t\t\tphy_exit(musb->phy);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttimer_setup(&musb->dev_timer, otg_timer, 0);\n\n\t \n\tmusb_writel(reg_base, wrp->control, (1 << wrp->reset));\n\n\tmusb->isr = dsps_interrupt;\n\n\t \n\tval = musb_readl(reg_base, wrp->phy_utmi);\n\tval &= ~(1 << wrp->otg_disable);\n\tmusb_writel(musb->ctrl_base, wrp->phy_utmi, val);\n\n\t \n\tval = musb_readb(musb->mregs, MUSB_BABBLE_CTL);\n\tif (val & MUSB_BABBLE_RCV_DISABLE) {\n\t\tglue->sw_babble_enabled = true;\n\t\tval |= MUSB_BABBLE_SW_SESSION_CTRL;\n\t\tmusb_writeb(musb->mregs, MUSB_BABBLE_CTL, val);\n\t}\n\n\tdsps_mod_timer(glue, -1);\n\n\treturn dsps_musb_dbg_init(musb, glue);\n}\n\nstatic int dsps_musb_exit(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\n\tdel_timer_sync(&musb->dev_timer);\n\tphy_power_off(musb->phy);\n\tphy_exit(musb->phy);\n\tdebugfs_remove_recursive(glue->dbgfs_root);\n\n\treturn 0;\n}\n\nstatic int dsps_musb_set_mode(struct musb *musb, u8 mode)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tvoid __iomem *ctrl_base = musb->ctrl_base;\n\tu32 reg;\n\n\treg = musb_readl(ctrl_base, wrp->mode);\n\n\tswitch (mode) {\n\tcase MUSB_HOST:\n\t\treg &= ~(1 << wrp->iddig);\n\n\t\t \n\t\treg |= (1 << wrp->iddig_mux);\n\n\t\tmusb_writel(ctrl_base, wrp->mode, reg);\n\t\tmusb_writel(ctrl_base, wrp->phy_utmi, 0x02);\n\t\tbreak;\n\tcase MUSB_PERIPHERAL:\n\t\treg |= (1 << wrp->iddig);\n\n\t\t \n\t\treg |= (1 << wrp->iddig_mux);\n\n\t\tmusb_writel(ctrl_base, wrp->mode, reg);\n\t\tbreak;\n\tcase MUSB_OTG:\n\t\tmusb_writel(ctrl_base, wrp->phy_utmi, 0x02);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(glue->dev, \"unsupported mode %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool dsps_sw_babble_control(struct musb *musb)\n{\n\tu8 babble_ctl;\n\tbool session_restart =  false;\n\n\tbabble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);\n\tdev_dbg(musb->controller, \"babble: MUSB_BABBLE_CTL value %x\\n\",\n\t\tbabble_ctl);\n\t \n\tdev_dbg(musb->controller, \"STUCK_J is %s\\n\",\n\t\tbabble_ctl & MUSB_BABBLE_STUCK_J ? \"set\" : \"reset\");\n\n\tif (babble_ctl & MUSB_BABBLE_STUCK_J) {\n\t\tint timeout = 10;\n\n\t\t \n\t\tbabble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);\n\t\tbabble_ctl |= MUSB_BABBLE_FORCE_TXIDLE;\n\t\tmusb_writeb(musb->mregs, MUSB_BABBLE_CTL, babble_ctl);\n\n\t\t \n\t\tdev_dbg(musb->controller, \"Set TXIDLE, wait J to clear\\n\");\n\t\tdo {\n\t\t\tbabble_ctl = musb_readb(musb->mregs, MUSB_BABBLE_CTL);\n\t\t\tudelay(1);\n\t\t} while ((babble_ctl & MUSB_BABBLE_STUCK_J) && timeout--);\n\n\t\t \n\t\tif (babble_ctl & MUSB_BABBLE_STUCK_J) {\n\t\t\t \n\t\t\tdev_dbg(musb->controller, \"J not cleared, misc (%x)\\n\",\n\t\t\t\tbabble_ctl);\n\t\t\tsession_restart = true;\n\t\t}\n\t} else {\n\t\tsession_restart = true;\n\t}\n\n\treturn session_restart;\n}\n\nstatic int dsps_musb_recover(struct musb *musb)\n{\n\tstruct device *dev = musb->controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(dev->parent);\n\tint session_restart = 0;\n\n\tif (glue->sw_babble_enabled)\n\t\tsession_restart = dsps_sw_babble_control(musb);\n\telse\n\t\tsession_restart = 1;\n\n\treturn session_restart ? 0 : -EPIPE;\n}\n\n \nstatic void dsps_read_fifo32(struct musb_hw_ep *hw_ep, u16 len, u8 *dst)\n{\n\tvoid __iomem *fifo = hw_ep->fifo;\n\n\tif (len >= 4) {\n\t\tioread32_rep(fifo, dst, len >> 2);\n\t\tdst += len & ~0x03;\n\t\tlen &= 0x03;\n\t}\n\n\t \n\tif (len > 0) {\n\t\tu32 val = musb_readl(fifo, 0);\n\t\tmemcpy(dst, &val, len);\n\t}\n}\n\n#ifdef CONFIG_USB_TI_CPPI41_DMA\nstatic void dsps_dma_controller_callback(struct dma_controller *c)\n{\n\tstruct musb *musb = c->musb;\n\tstruct dsps_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tvoid __iomem *usbss_base = glue->usbss_base;\n\tu32 status;\n\n\tstatus = musb_readl(usbss_base, USBSS_IRQ_STATUS);\n\tif (status & USBSS_IRQ_PD_COMP)\n\t\tmusb_writel(usbss_base, USBSS_IRQ_STATUS, USBSS_IRQ_PD_COMP);\n}\n\nstatic struct dma_controller *\ndsps_dma_controller_create(struct musb *musb, void __iomem *base)\n{\n\tstruct dma_controller *controller;\n\tstruct dsps_glue *glue = dev_get_drvdata(musb->controller->parent);\n\tvoid __iomem *usbss_base = glue->usbss_base;\n\n\tcontroller = cppi41_dma_controller_create(musb, base);\n\tif (IS_ERR_OR_NULL(controller))\n\t\treturn controller;\n\n\tmusb_writel(usbss_base, USBSS_IRQ_ENABLER, USBSS_IRQ_PD_COMP);\n\tcontroller->dma_callback = dsps_dma_controller_callback;\n\n\treturn controller;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void dsps_dma_controller_suspend(struct dsps_glue *glue)\n{\n\tvoid __iomem *usbss_base = glue->usbss_base;\n\n\tmusb_writel(usbss_base, USBSS_IRQ_CLEARR, USBSS_IRQ_PD_COMP);\n}\n\nstatic void dsps_dma_controller_resume(struct dsps_glue *glue)\n{\n\tvoid __iomem *usbss_base = glue->usbss_base;\n\n\tmusb_writel(usbss_base, USBSS_IRQ_ENABLER, USBSS_IRQ_PD_COMP);\n}\n#endif\n#else  \n#ifdef CONFIG_PM_SLEEP\nstatic void dsps_dma_controller_suspend(struct dsps_glue *glue) {}\nstatic void dsps_dma_controller_resume(struct dsps_glue *glue) {}\n#endif\n#endif  \n\nstatic struct musb_platform_ops dsps_ops = {\n\t.quirks\t\t= MUSB_DMA_CPPI41 | MUSB_INDEXED_EP,\n\t.init\t\t= dsps_musb_init,\n\t.exit\t\t= dsps_musb_exit,\n\n#ifdef CONFIG_USB_TI_CPPI41_DMA\n\t.dma_init\t= dsps_dma_controller_create,\n\t.dma_exit\t= cppi41_dma_controller_destroy,\n#endif\n\t.enable\t\t= dsps_musb_enable,\n\t.disable\t= dsps_musb_disable,\n\n\t.set_mode\t= dsps_musb_set_mode,\n\t.recover\t= dsps_musb_recover,\n\t.clear_ep_rxintr = dsps_musb_clear_ep_rxintr,\n};\n\nstatic u64 musb_dmamask = DMA_BIT_MASK(32);\n\nstatic int get_int_prop(struct device_node *dn, const char *s)\n{\n\tint ret;\n\tu32 val;\n\n\tret = of_property_read_u32(dn, s, &val);\n\tif (ret)\n\t\treturn 0;\n\treturn val;\n}\n\nstatic int dsps_create_musb_pdev(struct dsps_glue *glue,\n\t\tstruct platform_device *parent)\n{\n\tstruct musb_hdrc_platform_data pdata;\n\tstruct resource\tresources[2];\n\tstruct resource\t*res;\n\tstruct device *dev = &parent->dev;\n\tstruct musb_hdrc_config\t*config;\n\tstruct platform_device *musb;\n\tstruct device_node *dn = parent->dev.of_node;\n\tint ret, val;\n\n\tmemset(resources, 0, sizeof(resources));\n\tres = platform_get_resource_byname(parent, IORESOURCE_MEM, \"mc\");\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get memory.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tresources[0] = *res;\n\n\tret = platform_get_irq_byname(parent, \"mc\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresources[1].start = ret;\n\tresources[1].end = ret;\n\tresources[1].flags = IORESOURCE_IRQ | irq_get_trigger_type(ret);\n\tresources[1].name = \"mc\";\n\n\t \n\tmusb = platform_device_alloc(\"musb-hdrc\",\n\t\t\t(resources[0].start & 0xFFF) == 0x400 ? 0 : 1);\n\tif (!musb) {\n\t\tdev_err(dev, \"failed to allocate musb device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmusb->dev.parent\t\t= dev;\n\tmusb->dev.dma_mask\t\t= &musb_dmamask;\n\tmusb->dev.coherent_dma_mask\t= musb_dmamask;\n\tdevice_set_of_node_from_dev(&musb->dev, &parent->dev);\n\n\tglue->musb = musb;\n\n\tret = platform_device_add_resources(musb, resources,\n\t\t\tARRAY_SIZE(resources));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add resources\\n\");\n\t\tgoto err;\n\t}\n\n\tconfig = devm_kzalloc(&parent->dev, sizeof(*config), GFP_KERNEL);\n\tif (!config) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tpdata.config = config;\n\tpdata.platform_ops = &dsps_ops;\n\n\tconfig->num_eps = get_int_prop(dn, \"mentor,num-eps\");\n\tconfig->ram_bits = get_int_prop(dn, \"mentor,ram-bits\");\n\tconfig->host_port_deassert_reset_at_resume = 1;\n\tpdata.mode = musb_get_mode(dev);\n\t \n\tpdata.power = get_int_prop(dn, \"mentor,power\") / 2;\n\n\tret = of_property_read_u32(dn, \"mentor,multipoint\", &val);\n\tif (!ret && val)\n\t\tconfig->multipoint = true;\n\n\tconfig->maximum_speed = usb_get_maximum_speed(&parent->dev);\n\tswitch (config->maximum_speed) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tdev_warn(dev, \"ignore incorrect maximum_speed \"\n\t\t\t\t\"(super-speed) setting in dts\");\n\t\tfallthrough;\n\tdefault:\n\t\tconfig->maximum_speed = USB_SPEED_HIGH;\n\t}\n\n\tret = platform_device_add_data(musb, &pdata, sizeof(pdata));\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add platform_data\\n\");\n\t\tgoto err;\n\t}\n\n\tret = platform_device_add(musb);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to register musb device\\n\");\n\t\tgoto err;\n\t}\n\treturn 0;\n\nerr:\n\tplatform_device_put(musb);\n\treturn ret;\n}\n\nstatic irqreturn_t dsps_vbus_threaded_irq(int irq, void *priv)\n{\n\tstruct dsps_glue *glue = priv;\n\tstruct musb *musb = platform_get_drvdata(glue->musb);\n\n\tif (!musb)\n\t\treturn IRQ_NONE;\n\n\tdev_dbg(glue->dev, \"VBUS interrupt\\n\");\n\tdsps_mod_timer(glue, 0);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dsps_setup_optional_vbus_irq(struct platform_device *pdev,\n\t\t\t\t\tstruct dsps_glue *glue)\n{\n\tint error;\n\n\tglue->vbus_irq = platform_get_irq_byname(pdev, \"vbus\");\n\tif (glue->vbus_irq == -EPROBE_DEFER)\n\t\treturn -EPROBE_DEFER;\n\n\tif (glue->vbus_irq <= 0) {\n\t\tglue->vbus_irq = 0;\n\t\treturn 0;\n\t}\n\n\terror = devm_request_threaded_irq(glue->dev, glue->vbus_irq,\n\t\t\t\t\t  NULL, dsps_vbus_threaded_irq,\n\t\t\t\t\t  IRQF_ONESHOT,\n\t\t\t\t\t  \"vbus\", glue);\n\tif (error) {\n\t\tglue->vbus_irq = 0;\n\t\treturn error;\n\t}\n\tdev_dbg(glue->dev, \"VBUS irq %i configured\\n\", glue->vbus_irq);\n\n\treturn 0;\n}\n\nstatic int dsps_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *match;\n\tconst struct dsps_musb_wrapper *wrp;\n\tstruct dsps_glue *glue;\n\tint ret;\n\n\tif (!strcmp(pdev->name, \"musb-hdrc\"))\n\t\treturn -ENODEV;\n\n\tmatch = of_match_node(musb_dsps_of_match, pdev->dev.of_node);\n\tif (!match) {\n\t\tdev_err(&pdev->dev, \"fail to get matching of_match struct\\n\");\n\t\treturn -EINVAL;\n\t}\n\twrp = match->data;\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"ti,musb-dm816\"))\n\t\tdsps_ops.read_fifo = dsps_read_fifo32;\n\n\t \n\tglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\n\tif (!glue)\n\t\treturn -ENOMEM;\n\n\tglue->dev = &pdev->dev;\n\tglue->wrp = wrp;\n\tglue->usbss_base = of_iomap(pdev->dev.parent->of_node, 0);\n\tif (!glue->usbss_base)\n\t\treturn -ENXIO;\n\n\tplatform_set_drvdata(pdev, glue);\n\tpm_runtime_enable(&pdev->dev);\n\tret = dsps_create_musb_pdev(glue, pdev);\n\tif (ret)\n\t\tgoto err;\n\n\tif (usb_get_dr_mode(&pdev->dev) == USB_DR_MODE_PERIPHERAL) {\n\t\tret = dsps_setup_optional_vbus_irq(pdev, glue);\n\t\tif (ret)\n\t\t\tgoto unregister_pdev;\n\t}\n\n\treturn 0;\n\nunregister_pdev:\n\tplatform_device_unregister(glue->musb);\nerr:\n\tpm_runtime_disable(&pdev->dev);\n\tiounmap(glue->usbss_base);\n\treturn ret;\n}\n\nstatic void dsps_remove(struct platform_device *pdev)\n{\n\tstruct dsps_glue *glue = platform_get_drvdata(pdev);\n\n\tplatform_device_unregister(glue->musb);\n\n\tpm_runtime_disable(&pdev->dev);\n\tiounmap(glue->usbss_base);\n}\n\nstatic const struct dsps_musb_wrapper am33xx_driver_data = {\n\t.revision\t\t= 0x00,\n\t.control\t\t= 0x14,\n\t.status\t\t\t= 0x18,\n\t.epintr_set\t\t= 0x38,\n\t.epintr_clear\t\t= 0x40,\n\t.epintr_status\t\t= 0x30,\n\t.coreintr_set\t\t= 0x3c,\n\t.coreintr_clear\t\t= 0x44,\n\t.coreintr_status\t= 0x34,\n\t.phy_utmi\t\t= 0xe0,\n\t.mode\t\t\t= 0xe8,\n\t.tx_mode\t\t= 0x70,\n\t.rx_mode\t\t= 0x74,\n\t.reset\t\t\t= 0,\n\t.otg_disable\t\t= 21,\n\t.iddig\t\t\t= 8,\n\t.iddig_mux\t\t= 7,\n\t.usb_shift\t\t= 0,\n\t.usb_mask\t\t= 0x1ff,\n\t.usb_bitmap\t\t= (0x1ff << 0),\n\t.drvvbus\t\t= 8,\n\t.txep_shift\t\t= 0,\n\t.txep_mask\t\t= 0xffff,\n\t.txep_bitmap\t\t= (0xffff << 0),\n\t.rxep_shift\t\t= 16,\n\t.rxep_mask\t\t= 0xfffe,\n\t.rxep_bitmap\t\t= (0xfffe << 16),\n\t.poll_timeout\t\t= 2000,  \n};\n\nstatic const struct of_device_id musb_dsps_of_match[] = {\n\t{ .compatible = \"ti,musb-am33xx\",\n\t\t.data = &am33xx_driver_data, },\n\t{ .compatible = \"ti,musb-dm816\",\n\t\t.data = &am33xx_driver_data, },\n\t{  },\n};\nMODULE_DEVICE_TABLE(of, musb_dsps_of_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dsps_suspend(struct device *dev)\n{\n\tstruct dsps_glue *glue = dev_get_drvdata(dev);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tstruct musb *musb = platform_get_drvdata(glue->musb);\n\tvoid __iomem *mbase;\n\tint ret;\n\n\tif (!musb)\n\t\t \n\t\treturn 0;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn ret;\n\t}\n\n\tdel_timer_sync(&musb->dev_timer);\n\n\tmbase = musb->ctrl_base;\n\tglue->context.control = musb_readl(mbase, wrp->control);\n\tglue->context.epintr = musb_readl(mbase, wrp->epintr_set);\n\tglue->context.coreintr = musb_readl(mbase, wrp->coreintr_set);\n\tglue->context.phy_utmi = musb_readl(mbase, wrp->phy_utmi);\n\tglue->context.mode = musb_readl(mbase, wrp->mode);\n\tglue->context.tx_mode = musb_readl(mbase, wrp->tx_mode);\n\tglue->context.rx_mode = musb_readl(mbase, wrp->rx_mode);\n\n\tdsps_dma_controller_suspend(glue);\n\n\treturn 0;\n}\n\nstatic int dsps_resume(struct device *dev)\n{\n\tstruct dsps_glue *glue = dev_get_drvdata(dev);\n\tconst struct dsps_musb_wrapper *wrp = glue->wrp;\n\tstruct musb *musb = platform_get_drvdata(glue->musb);\n\tvoid __iomem *mbase;\n\n\tif (!musb)\n\t\treturn 0;\n\n\tdsps_dma_controller_resume(glue);\n\n\tmbase = musb->ctrl_base;\n\tmusb_writel(mbase, wrp->control, glue->context.control);\n\tmusb_writel(mbase, wrp->epintr_set, glue->context.epintr);\n\tmusb_writel(mbase, wrp->coreintr_set, glue->context.coreintr);\n\tmusb_writel(mbase, wrp->phy_utmi, glue->context.phy_utmi);\n\tmusb_writel(mbase, wrp->mode, glue->context.mode);\n\tmusb_writel(mbase, wrp->tx_mode, glue->context.tx_mode);\n\tmusb_writel(mbase, wrp->rx_mode, glue->context.rx_mode);\n\tif (musb->xceiv->otg->state == OTG_STATE_B_IDLE &&\n\t    musb->port_mode == MUSB_OTG)\n\t\tdsps_mod_timer(glue, -1);\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(dsps_pm_ops, dsps_suspend, dsps_resume);\n\nstatic struct platform_driver dsps_usbss_driver = {\n\t.probe\t\t= dsps_probe,\n\t.remove_new     = dsps_remove,\n\t.driver         = {\n\t\t.name   = \"musb-dsps\",\n\t\t.pm\t= &dsps_pm_ops,\n\t\t.of_match_table\t= musb_dsps_of_match,\n\t},\n};\n\nMODULE_DESCRIPTION(\"TI DSPS MUSB Glue Layer\");\nMODULE_AUTHOR(\"Ravi B <ravibabu@ti.com>\");\nMODULE_AUTHOR(\"Ajay Kumar Gupta <ajay.gupta@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_platform_driver(dsps_usbss_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}