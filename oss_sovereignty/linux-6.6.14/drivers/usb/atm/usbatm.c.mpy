{
  "module_name": "usbatm.c",
  "hash_id": "05b4992ebf6f37efb02fb8e7f89c0e5abc0778bcc195361da59e04160d3778f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/atm/usbatm.c",
  "human_readable_source": "\n \n\n \n\n#include \"usbatm.h\"\n\n#include <linux/uaccess.h>\n#include <linux/crc32.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/sched/signal.h>\n#include <linux/signal.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/timer.h>\n#include <linux/wait.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n\n#ifdef VERBOSE_DEBUG\nstatic int usbatm_print_packet(struct usbatm_data *instance, const unsigned char *data, int len);\n#define PACKETDEBUG(arg...)\tusbatm_print_packet(arg)\n#define vdbg(arg...)\t\tdev_dbg(arg)\n#else\n#define PACKETDEBUG(arg...)\n#define vdbg(arg...)\n#endif\n\n#define DRIVER_AUTHOR\t\"Johan Verrept, Duncan Sands <duncan.sands@free.fr>\"\n#define DRIVER_DESC\t\"Generic USB ATM/DSL I/O\"\n\nstatic const char usbatm_driver_name[] = \"usbatm\";\n\n#define UDSL_MAX_RCV_URBS\t\t16\n#define UDSL_MAX_SND_URBS\t\t16\n#define UDSL_MAX_BUF_SIZE\t\t65536\n#define UDSL_DEFAULT_RCV_URBS\t\t4\n#define UDSL_DEFAULT_SND_URBS\t\t4\n#define UDSL_DEFAULT_RCV_BUF_SIZE\t3392\t \n#define UDSL_DEFAULT_SND_BUF_SIZE\t3392\t \n\n#define ATM_CELL_HEADER\t\t\t(ATM_CELL_SIZE - ATM_CELL_PAYLOAD)\n\n#define THROTTLE_MSECS\t\t\t100\t \n\nstatic unsigned int num_rcv_urbs = UDSL_DEFAULT_RCV_URBS;\nstatic unsigned int num_snd_urbs = UDSL_DEFAULT_SND_URBS;\nstatic unsigned int rcv_buf_bytes = UDSL_DEFAULT_RCV_BUF_SIZE;\nstatic unsigned int snd_buf_bytes = UDSL_DEFAULT_SND_BUF_SIZE;\n\nmodule_param(num_rcv_urbs, uint, S_IRUGO);\nMODULE_PARM_DESC(num_rcv_urbs,\n\t\t \"Number of urbs used for reception (range: 0-\"\n\t\t __MODULE_STRING(UDSL_MAX_RCV_URBS) \", default: \"\n\t\t __MODULE_STRING(UDSL_DEFAULT_RCV_URBS) \")\");\n\nmodule_param(num_snd_urbs, uint, S_IRUGO);\nMODULE_PARM_DESC(num_snd_urbs,\n\t\t \"Number of urbs used for transmission (range: 0-\"\n\t\t __MODULE_STRING(UDSL_MAX_SND_URBS) \", default: \"\n\t\t __MODULE_STRING(UDSL_DEFAULT_SND_URBS) \")\");\n\nmodule_param(rcv_buf_bytes, uint, S_IRUGO);\nMODULE_PARM_DESC(rcv_buf_bytes,\n\t\t \"Size of the buffers used for reception, in bytes (range: 1-\"\n\t\t __MODULE_STRING(UDSL_MAX_BUF_SIZE) \", default: \"\n\t\t __MODULE_STRING(UDSL_DEFAULT_RCV_BUF_SIZE) \")\");\n\nmodule_param(snd_buf_bytes, uint, S_IRUGO);\nMODULE_PARM_DESC(snd_buf_bytes,\n\t\t \"Size of the buffers used for transmission, in bytes (range: 1-\"\n\t\t __MODULE_STRING(UDSL_MAX_BUF_SIZE) \", default: \"\n\t\t __MODULE_STRING(UDSL_DEFAULT_SND_BUF_SIZE) \")\");\n\n\n \n\nstruct usbatm_vcc_data {\n\t \n\tstruct list_head list;\n\tshort vpi;\n\tint vci;\n\tstruct atm_vcc *vcc;\n\n\t \n\tstruct sk_buff *sarb;\n};\n\n\n \n\nstruct usbatm_control {\n\tstruct atm_skb_data atm;\n\tu32 len;\n\tu32 crc;\n};\n\n#define UDSL_SKB(x)\t\t((struct usbatm_control *)(x)->cb)\n\n\n \n\nstatic void usbatm_atm_dev_close(struct atm_dev *atm_dev);\nstatic int usbatm_atm_open(struct atm_vcc *vcc);\nstatic void usbatm_atm_close(struct atm_vcc *vcc);\nstatic int usbatm_atm_ioctl(struct atm_dev *atm_dev, unsigned int cmd, void __user *arg);\nstatic int usbatm_atm_send(struct atm_vcc *vcc, struct sk_buff *skb);\nstatic int usbatm_atm_proc_read(struct atm_dev *atm_dev, loff_t *pos, char *page);\n\nstatic const struct atmdev_ops usbatm_atm_devops = {\n\t.dev_close\t= usbatm_atm_dev_close,\n\t.open\t\t= usbatm_atm_open,\n\t.close\t\t= usbatm_atm_close,\n\t.ioctl\t\t= usbatm_atm_ioctl,\n\t.send\t\t= usbatm_atm_send,\n\t.proc_read\t= usbatm_atm_proc_read,\n\t.owner\t\t= THIS_MODULE,\n};\n\n\n \n\nstatic inline unsigned int usbatm_pdu_length(unsigned int length)\n{\n\tlength += ATM_CELL_PAYLOAD - 1 + ATM_AAL5_TRAILER;\n\treturn length - length % ATM_CELL_PAYLOAD;\n}\n\nstatic inline void usbatm_pop(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tif (vcc->pop)\n\t\tvcc->pop(vcc, skb);\n\telse\n\t\tdev_kfree_skb_any(skb);\n}\n\n\n \n\nstatic struct urb *usbatm_pop_urb(struct usbatm_channel *channel)\n{\n\tstruct urb *urb;\n\n\tspin_lock_irq(&channel->lock);\n\tif (list_empty(&channel->list)) {\n\t\tspin_unlock_irq(&channel->lock);\n\t\treturn NULL;\n\t}\n\n\turb = list_entry(channel->list.next, struct urb, urb_list);\n\tlist_del(&urb->urb_list);\n\tspin_unlock_irq(&channel->lock);\n\n\treturn urb;\n}\n\nstatic int usbatm_submit_urb(struct urb *urb)\n{\n\tstruct usbatm_channel *channel = urb->context;\n\tint ret;\n\n\t \n\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tif (printk_ratelimit())\n\t\t\tatm_warn(channel->usbatm, \"%s: urb 0x%p submission failed (%d)!\\n\",\n\t\t\t\t__func__, urb, ret);\n\n\t\t \n\t\turb->status = -EAGAIN;\n\t\tspin_lock_irq(&channel->lock);\n\n\t\t \n\t\tlist_add(&urb->urb_list, &channel->list);\n\n\t\tspin_unlock_irq(&channel->lock);\n\n\t\t \n\t\tmod_timer(&channel->delay, jiffies + msecs_to_jiffies(THROTTLE_MSECS));\n\t}\n\n\treturn ret;\n}\n\nstatic void usbatm_complete(struct urb *urb)\n{\n\tstruct usbatm_channel *channel = urb->context;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\t \n\n\t \n\tspin_lock_irqsave(&channel->lock, flags);\n\n\t \n\tlist_add_tail(&urb->urb_list, &channel->list);\n\n\tspin_unlock_irqrestore(&channel->lock, flags);\n\n\tif (unlikely(status) &&\n\t\t\t(!(channel->usbatm->flags & UDSL_IGNORE_EILSEQ) ||\n\t\t\t status != -EILSEQ)) {\n\t\tif (status == -ESHUTDOWN)\n\t\t\treturn;\n\n\t\tif (printk_ratelimit())\n\t\t\tatm_warn(channel->usbatm, \"%s: urb 0x%p failed (%d)!\\n\",\n\t\t\t\t__func__, urb, status);\n\t\t \n\t\tmod_timer(&channel->delay, jiffies + msecs_to_jiffies(THROTTLE_MSECS));\n\t} else\n\t\ttasklet_schedule(&channel->tasklet);\n}\n\n\n \n\nstatic inline struct usbatm_vcc_data *usbatm_find_vcc(struct usbatm_data *instance,\n\t\t\t\t\t\t  short vpi, int vci)\n{\n\tstruct usbatm_vcc_data *vcc_data;\n\n\tlist_for_each_entry(vcc_data, &instance->vcc_list, list)\n\t\tif ((vcc_data->vci == vci) && (vcc_data->vpi == vpi))\n\t\t\treturn vcc_data;\n\treturn NULL;\n}\n\nstatic void usbatm_extract_one_cell(struct usbatm_data *instance, unsigned char *source)\n{\n\tstruct atm_vcc *vcc;\n\tstruct sk_buff *sarb;\n\tshort vpi = ((source[0] & 0x0f) << 4)  | (source[1] >> 4);\n\tint vci = ((source[1] & 0x0f) << 12) | (source[2] << 4) | (source[3] >> 4);\n\tu8 pti = ((source[3] & 0xe) >> 1);\n\n\tif ((vci != instance->cached_vci) || (vpi != instance->cached_vpi)) {\n\t\tinstance->cached_vpi = vpi;\n\t\tinstance->cached_vci = vci;\n\n\t\tinstance->cached_vcc = usbatm_find_vcc(instance, vpi, vci);\n\n\t\tif (!instance->cached_vcc)\n\t\t\tatm_rldbg(instance, \"%s: unknown vpi/vci (%hd/%d)!\\n\", __func__, vpi, vci);\n\t}\n\n\tif (!instance->cached_vcc)\n\t\treturn;\n\n\tvcc = instance->cached_vcc->vcc;\n\n\t \n\tif (pti == ATM_PTI_E2EF5) {\n\t\tif (printk_ratelimit())\n\t\t\tatm_warn(instance, \"%s: OAM not supported (vpi %d, vci %d)!\\n\",\n\t\t\t\t__func__, vpi, vci);\n\t\tatomic_inc(&vcc->stats->rx_err);\n\t\treturn;\n\t}\n\n\tsarb = instance->cached_vcc->sarb;\n\n\tif (sarb->tail + ATM_CELL_PAYLOAD > sarb->end) {\n\t\tatm_rldbg(instance, \"%s: buffer overrun (sarb->len %u, vcc: 0x%p)!\\n\",\n\t\t\t\t__func__, sarb->len, vcc);\n\t\t \n\t\tskb_trim(sarb, 0);\n\t}\n\n\tmemcpy(skb_tail_pointer(sarb), source + ATM_CELL_HEADER, ATM_CELL_PAYLOAD);\n\t__skb_put(sarb, ATM_CELL_PAYLOAD);\n\n\tif (pti & 1) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned int length;\n\t\tunsigned int pdu_length;\n\n\t\tlength = (source[ATM_CELL_SIZE - 6] << 8) + source[ATM_CELL_SIZE - 5];\n\n\t\t \n\t\tif (length > ATM_MAX_AAL5_PDU) {\n\t\t\tatm_rldbg(instance, \"%s: bogus length %u (vcc: 0x%p)!\\n\",\n\t\t\t\t  __func__, length, vcc);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpdu_length = usbatm_pdu_length(length);\n\n\t\tif (sarb->len < pdu_length) {\n\t\t\tatm_rldbg(instance, \"%s: bogus pdu_length %u (sarb->len: %u, vcc: 0x%p)!\\n\",\n\t\t\t\t  __func__, pdu_length, sarb->len, vcc);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (crc32_be(~0, skb_tail_pointer(sarb) - pdu_length, pdu_length) != 0xc704dd7b) {\n\t\t\tatm_rldbg(instance, \"%s: packet failed crc check (vcc: 0x%p)!\\n\",\n\t\t\t\t  __func__, vcc);\n\t\t\tatomic_inc(&vcc->stats->rx_err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tvdbg(&instance->usb_intf->dev,\n\t\t     \"%s: got packet (length: %u, pdu_length: %u, vcc: 0x%p)\",\n\t\t     __func__, length, pdu_length, vcc);\n\n\t\tskb = dev_alloc_skb(length);\n\t\tif (!skb) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tatm_err(instance, \"%s: no memory for skb (length: %u)!\\n\",\n\t\t\t\t\t__func__, length);\n\t\t\tatomic_inc(&vcc->stats->rx_drop);\n\t\t\tgoto out;\n\t\t}\n\n\t\tvdbg(&instance->usb_intf->dev,\n\t\t     \"%s: allocated new sk_buff (skb: 0x%p, skb->truesize: %u)\",\n\t\t     __func__, skb, skb->truesize);\n\n\t\tif (!atm_charge(vcc, skb->truesize)) {\n\t\t\tatm_rldbg(instance, \"%s: failed atm_charge (skb->truesize: %u)!\\n\",\n\t\t\t\t  __func__, skb->truesize);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto out;\t \n\t\t}\n\n\t\tskb_copy_to_linear_data(skb,\n\t\t\t\t\tskb_tail_pointer(sarb) - pdu_length,\n\t\t\t\t\tlength);\n\t\t__skb_put(skb, length);\n\n\t\tvdbg(&instance->usb_intf->dev,\n\t\t     \"%s: sending skb 0x%p, skb->len %u, skb->truesize %u\",\n\t\t     __func__, skb, skb->len, skb->truesize);\n\n\t\tPACKETDEBUG(instance, skb->data, skb->len);\n\n\t\tvcc->push(vcc, skb);\n\n\t\tatomic_inc(&vcc->stats->rx);\n\tout:\n\t\tskb_trim(sarb, 0);\n\t}\n}\n\nstatic void usbatm_extract_cells(struct usbatm_data *instance,\n\t\tunsigned char *source, unsigned int avail_data)\n{\n\tunsigned int stride = instance->rx_channel.stride;\n\tunsigned int buf_usage = instance->buf_usage;\n\n\t \n\n\tif (buf_usage > 0) {\n\t\t \n\t\tunsigned char *cell_buf = instance->cell_buf;\n\t\tunsigned int space_left = stride - buf_usage;\n\n\t\tif (avail_data >= space_left) {\n\t\t\t \n\t\t\tmemcpy(cell_buf + buf_usage, source, space_left);\n\t\t\tsource += space_left;\n\t\t\tavail_data -= space_left;\n\t\t\tusbatm_extract_one_cell(instance, cell_buf);\n\t\t\tinstance->buf_usage = 0;\n\t\t} else {\n\t\t\t \n\t\t\tmemcpy(cell_buf + buf_usage, source, avail_data);\n\t\t\tinstance->buf_usage = buf_usage + avail_data;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tfor (; avail_data >= stride; avail_data -= stride, source += stride)\n\t\tusbatm_extract_one_cell(instance, source);\n\n\tif (avail_data > 0) {\n\t\t \n\t\tmemcpy(instance->cell_buf, source, avail_data);\n\t\tinstance->buf_usage = avail_data;\n\t}\n}\n\n\n \n\nstatic unsigned int usbatm_write_cells(struct usbatm_data *instance,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u8 *target, unsigned int avail_space)\n{\n\tstruct usbatm_control *ctrl = UDSL_SKB(skb);\n\tstruct atm_vcc *vcc = ctrl->atm.vcc;\n\tunsigned int bytes_written;\n\tunsigned int stride = instance->tx_channel.stride;\n\n\tfor (bytes_written = 0; bytes_written < avail_space && ctrl->len;\n\t     bytes_written += stride, target += stride) {\n\t\tunsigned int data_len = min_t(unsigned int, skb->len, ATM_CELL_PAYLOAD);\n\t\tunsigned int left = ATM_CELL_PAYLOAD - data_len;\n\t\tu8 *ptr = target;\n\n\t\tptr[0] = vcc->vpi >> 4;\n\t\tptr[1] = (vcc->vpi << 4) | (vcc->vci >> 12);\n\t\tptr[2] = vcc->vci >> 4;\n\t\tptr[3] = vcc->vci << 4;\n\t\tptr[4] = 0xec;\n\t\tptr += ATM_CELL_HEADER;\n\n\t\tskb_copy_from_linear_data(skb, ptr, data_len);\n\t\tptr += data_len;\n\t\t__skb_pull(skb, data_len);\n\n\t\tif (!left)\n\t\t\tcontinue;\n\n\t\tmemset(ptr, 0, left);\n\n\t\tif (left >= ATM_AAL5_TRAILER) {\t \n\t\t\tu8 *trailer = target + ATM_CELL_SIZE - ATM_AAL5_TRAILER;\n\t\t\t \n\t\t\t \n\t\t\ttrailer[2] = ctrl->len >> 8;\n\t\t\ttrailer[3] = ctrl->len;\n\n\t\t\tctrl->crc = ~crc32_be(ctrl->crc, ptr, left - 4);\n\n\t\t\ttrailer[4] = ctrl->crc >> 24;\n\t\t\ttrailer[5] = ctrl->crc >> 16;\n\t\t\ttrailer[6] = ctrl->crc >> 8;\n\t\t\ttrailer[7] = ctrl->crc;\n\n\t\t\ttarget[3] |= 0x2;\t \n\n\t\t\tctrl->len = 0;\t\t \n\t\t} else\n\t\t\tctrl->crc = crc32_be(ctrl->crc, ptr, left);\n\t}\n\n\treturn bytes_written;\n}\n\n\n \n\nstatic void usbatm_rx_process(struct tasklet_struct *t)\n{\n\tstruct usbatm_data *instance = from_tasklet(instance, t,\n\t\t\t\t\t\t    rx_channel.tasklet);\n\tstruct urb *urb;\n\n\twhile ((urb = usbatm_pop_urb(&instance->rx_channel))) {\n\t\tvdbg(&instance->usb_intf->dev,\n\t\t     \"%s: processing urb 0x%p\", __func__, urb);\n\n\t\tif (usb_pipeisoc(urb->pipe)) {\n\t\t\tunsigned char *merge_start = NULL;\n\t\t\tunsigned int merge_length = 0;\n\t\t\tconst unsigned int packet_size = instance->rx_channel.packet_size;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\t\tif (!urb->iso_frame_desc[i].status) {\n\t\t\t\t\tunsigned int actual_length = urb->iso_frame_desc[i].actual_length;\n\n\t\t\t\t\tif (!merge_length)\n\t\t\t\t\t\tmerge_start = (unsigned char *)urb->transfer_buffer + urb->iso_frame_desc[i].offset;\n\t\t\t\t\tmerge_length += actual_length;\n\t\t\t\t\tif (merge_length && (actual_length < packet_size)) {\n\t\t\t\t\t\tusbatm_extract_cells(instance, merge_start, merge_length);\n\t\t\t\t\t\tmerge_length = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tatm_rldbg(instance, \"%s: status %d in frame %d!\\n\", __func__, urb->status, i);\n\t\t\t\t\tif (merge_length)\n\t\t\t\t\t\tusbatm_extract_cells(instance, merge_start, merge_length);\n\t\t\t\t\tmerge_length = 0;\n\t\t\t\t\tinstance->buf_usage = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (merge_length)\n\t\t\t\tusbatm_extract_cells(instance, merge_start, merge_length);\n\t\t} else\n\t\t\tif (!urb->status)\n\t\t\t\tusbatm_extract_cells(instance, urb->transfer_buffer, urb->actual_length);\n\t\t\telse\n\t\t\t\tinstance->buf_usage = 0;\n\n\t\tif (usbatm_submit_urb(urb))\n\t\t\treturn;\n\t}\n}\n\n\n \n\nstatic void usbatm_tx_process(struct tasklet_struct *t)\n{\n\tstruct usbatm_data *instance = from_tasklet(instance, t,\n\t\t\t\t\t\t    tx_channel.tasklet);\n\tstruct sk_buff *skb = instance->current_skb;\n\tstruct urb *urb = NULL;\n\tconst unsigned int buf_size = instance->tx_channel.buf_size;\n\tunsigned int bytes_written = 0;\n\tu8 *buffer = NULL;\n\n\tif (!skb)\n\t\tskb = skb_dequeue(&instance->sndqueue);\n\n\twhile (skb) {\n\t\tif (!urb) {\n\t\t\turb = usbatm_pop_urb(&instance->tx_channel);\n\t\t\tif (!urb)\n\t\t\t\tbreak;\t\t \n\t\t\tbuffer = urb->transfer_buffer;\n\t\t\tbytes_written = (urb->status == -EAGAIN) ?\n\t\t\t\turb->transfer_buffer_length : 0;\n\t\t}\n\n\t\tbytes_written += usbatm_write_cells(instance, skb,\n\t\t\t\t\t\t  buffer + bytes_written,\n\t\t\t\t\t\t  buf_size - bytes_written);\n\n\t\tvdbg(&instance->usb_intf->dev,\n\t\t     \"%s: wrote %u bytes from skb 0x%p to urb 0x%p\",\n\t\t     __func__, bytes_written, skb, urb);\n\n\t\tif (!UDSL_SKB(skb)->len) {\n\t\t\tstruct atm_vcc *vcc = UDSL_SKB(skb)->atm.vcc;\n\n\t\t\tusbatm_pop(vcc, skb);\n\t\t\tatomic_inc(&vcc->stats->tx);\n\n\t\t\tskb = skb_dequeue(&instance->sndqueue);\n\t\t}\n\n\t\tif (bytes_written == buf_size || (!skb && bytes_written)) {\n\t\t\turb->transfer_buffer_length = bytes_written;\n\n\t\t\tif (usbatm_submit_urb(urb))\n\t\t\t\tbreak;\n\t\t\turb = NULL;\n\t\t}\n\t}\n\n\tinstance->current_skb = skb;\n}\n\nstatic void usbatm_cancel_send(struct usbatm_data *instance,\n\t\t\t       struct atm_vcc *vcc)\n{\n\tstruct sk_buff *skb, *n;\n\n\tspin_lock_irq(&instance->sndqueue.lock);\n\tskb_queue_walk_safe(&instance->sndqueue, skb, n) {\n\t\tif (UDSL_SKB(skb)->atm.vcc == vcc) {\n\t\t\tatm_dbg(instance, \"%s: popping skb 0x%p\\n\", __func__, skb);\n\t\t\t__skb_unlink(skb, &instance->sndqueue);\n\t\t\tusbatm_pop(vcc, skb);\n\t\t}\n\t}\n\tspin_unlock_irq(&instance->sndqueue.lock);\n\n\ttasklet_disable(&instance->tx_channel.tasklet);\n\tif ((skb = instance->current_skb) && (UDSL_SKB(skb)->atm.vcc == vcc)) {\n\t\tatm_dbg(instance, \"%s: popping current skb (0x%p)\\n\", __func__, skb);\n\t\tinstance->current_skb = NULL;\n\t\tusbatm_pop(vcc, skb);\n\t}\n\ttasklet_enable(&instance->tx_channel.tasklet);\n}\n\nstatic int usbatm_atm_send(struct atm_vcc *vcc, struct sk_buff *skb)\n{\n\tstruct usbatm_data *instance = vcc->dev->dev_data;\n\tstruct usbatm_control *ctrl = UDSL_SKB(skb);\n\tint err;\n\n\t \n\tif (!instance || instance->disconnected) {\n#ifdef VERBOSE_DEBUG\n\t\tprintk_ratelimited(KERN_DEBUG \"%s: %s!\\n\", __func__, instance ? \"disconnected\" : \"NULL instance\");\n#endif\n\t\terr = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (vcc->qos.aal != ATM_AAL5) {\n\t\tatm_rldbg(instance, \"%s: unsupported ATM type %d!\\n\", __func__, vcc->qos.aal);\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (skb->len > ATM_MAX_AAL5_PDU) {\n\t\tatm_rldbg(instance, \"%s: packet too long (%d vs %d)!\\n\",\n\t\t\t\t__func__, skb->len, ATM_MAX_AAL5_PDU);\n\t\terr = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tPACKETDEBUG(instance, skb->data, skb->len);\n\n\t \n\tctrl->atm.vcc = vcc;\n\tctrl->len = skb->len;\n\tctrl->crc = crc32_be(~0, skb->data, skb->len);\n\n\tskb_queue_tail(&instance->sndqueue, skb);\n\ttasklet_schedule(&instance->tx_channel.tasklet);\n\n\treturn 0;\n\n fail:\n\tusbatm_pop(vcc, skb);\n\treturn err;\n}\n\n\n \n\nstatic void usbatm_destroy_instance(struct kref *kref)\n{\n\tstruct usbatm_data *instance = container_of(kref, struct usbatm_data, refcount);\n\n\ttasklet_kill(&instance->rx_channel.tasklet);\n\ttasklet_kill(&instance->tx_channel.tasklet);\n\tusb_put_dev(instance->usb_dev);\n\tkfree(instance);\n}\n\nstatic void usbatm_get_instance(struct usbatm_data *instance)\n{\n\tkref_get(&instance->refcount);\n}\n\nstatic void usbatm_put_instance(struct usbatm_data *instance)\n{\n\tkref_put(&instance->refcount, usbatm_destroy_instance);\n}\n\n\n \n\nstatic void usbatm_atm_dev_close(struct atm_dev *atm_dev)\n{\n\tstruct usbatm_data *instance = atm_dev->dev_data;\n\n\tif (!instance)\n\t\treturn;\n\n\tatm_dev->dev_data = NULL;  \n\tusbatm_put_instance(instance);\t \n}\n\nstatic int usbatm_atm_proc_read(struct atm_dev *atm_dev, loff_t *pos, char *page)\n{\n\tstruct usbatm_data *instance = atm_dev->dev_data;\n\tint left = *pos;\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\tif (!left--)\n\t\treturn sprintf(page, \"%s\\n\", instance->description);\n\n\tif (!left--)\n\t\treturn sprintf(page, \"MAC: %pM\\n\", atm_dev->esi);\n\n\tif (!left--)\n\t\treturn sprintf(page,\n\t\t\t       \"AAL5: tx %d ( %d err ), rx %d ( %d err, %d drop )\\n\",\n\t\t\t       atomic_read(&atm_dev->stats.aal5.tx),\n\t\t\t       atomic_read(&atm_dev->stats.aal5.tx_err),\n\t\t\t       atomic_read(&atm_dev->stats.aal5.rx),\n\t\t\t       atomic_read(&atm_dev->stats.aal5.rx_err),\n\t\t\t       atomic_read(&atm_dev->stats.aal5.rx_drop));\n\n\tif (!left--) {\n\t\tif (instance->disconnected)\n\t\t\treturn sprintf(page, \"Disconnected\\n\");\n\t\telse\n\t\t\tswitch (atm_dev->signal) {\n\t\t\tcase ATM_PHY_SIG_FOUND:\n\t\t\t\treturn sprintf(page, \"Line up\\n\");\n\t\t\tcase ATM_PHY_SIG_LOST:\n\t\t\t\treturn sprintf(page, \"Line down\\n\");\n\t\t\tdefault:\n\t\t\t\treturn sprintf(page, \"Line state unknown\\n\");\n\t\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int usbatm_atm_open(struct atm_vcc *vcc)\n{\n\tstruct usbatm_data *instance = vcc->dev->dev_data;\n\tstruct usbatm_vcc_data *new = NULL;\n\tint ret;\n\tint vci = vcc->vci;\n\tshort vpi = vcc->vpi;\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\t \n\tif ((vcc->qos.aal != ATM_AAL5)) {\n\t\tatm_warn(instance, \"%s: unsupported ATM type %d!\\n\", __func__, vcc->qos.aal);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif ((vcc->qos.rxtp.max_sdu < 0) || (vcc->qos.rxtp.max_sdu > ATM_MAX_AAL5_PDU)) {\n\t\tatm_dbg(instance, \"%s: max_sdu %d out of range!\\n\", __func__, vcc->qos.rxtp.max_sdu);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&instance->serialize);\t \n\n\tif (instance->disconnected) {\n\t\tatm_dbg(instance, \"%s: disconnected!\\n\", __func__);\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif (usbatm_find_vcc(instance, vpi, vci)) {\n\t\tatm_dbg(instance, \"%s: %hd/%d already in use!\\n\", __func__, vpi, vci);\n\t\tret = -EADDRINUSE;\n\t\tgoto fail;\n\t}\n\n\tnew = kzalloc(sizeof(struct usbatm_vcc_data), GFP_KERNEL);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tnew->vcc = vcc;\n\tnew->vpi = vpi;\n\tnew->vci = vci;\n\n\tnew->sarb = alloc_skb(usbatm_pdu_length(vcc->qos.rxtp.max_sdu), GFP_KERNEL);\n\tif (!new->sarb) {\n\t\tatm_err(instance, \"%s: no memory for SAR buffer!\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tvcc->dev_data = new;\n\n\ttasklet_disable(&instance->rx_channel.tasklet);\n\tinstance->cached_vcc = new;\n\tinstance->cached_vpi = vpi;\n\tinstance->cached_vci = vci;\n\tlist_add(&new->list, &instance->vcc_list);\n\ttasklet_enable(&instance->rx_channel.tasklet);\n\n\tset_bit(ATM_VF_ADDR, &vcc->flags);\n\tset_bit(ATM_VF_PARTIAL, &vcc->flags);\n\tset_bit(ATM_VF_READY, &vcc->flags);\n\n\tmutex_unlock(&instance->serialize);\n\n\tatm_dbg(instance, \"%s: allocated vcc data 0x%p\\n\", __func__, new);\n\n\treturn 0;\n\nfail:\n\tkfree(new);\n\tmutex_unlock(&instance->serialize);\n\treturn ret;\n}\n\nstatic void usbatm_atm_close(struct atm_vcc *vcc)\n{\n\tstruct usbatm_data *instance = vcc->dev->dev_data;\n\tstruct usbatm_vcc_data *vcc_data = vcc->dev_data;\n\n\tif (!instance || !vcc_data)\n\t\treturn;\n\n\tusbatm_cancel_send(instance, vcc);\n\n\tmutex_lock(&instance->serialize);\t \n\n\ttasklet_disable(&instance->rx_channel.tasklet);\n\tif (instance->cached_vcc == vcc_data) {\n\t\tinstance->cached_vcc = NULL;\n\t\tinstance->cached_vpi = ATM_VPI_UNSPEC;\n\t\tinstance->cached_vci = ATM_VCI_UNSPEC;\n\t}\n\tlist_del(&vcc_data->list);\n\ttasklet_enable(&instance->rx_channel.tasklet);\n\n\tkfree_skb(vcc_data->sarb);\n\tvcc_data->sarb = NULL;\n\n\tkfree(vcc_data);\n\tvcc->dev_data = NULL;\n\n\tvcc->vpi = ATM_VPI_UNSPEC;\n\tvcc->vci = ATM_VCI_UNSPEC;\n\tclear_bit(ATM_VF_READY, &vcc->flags);\n\tclear_bit(ATM_VF_PARTIAL, &vcc->flags);\n\tclear_bit(ATM_VF_ADDR, &vcc->flags);\n\n\tmutex_unlock(&instance->serialize);\n}\n\nstatic int usbatm_atm_ioctl(struct atm_dev *atm_dev, unsigned int cmd,\n\t\t\t  void __user *arg)\n{\n\tstruct usbatm_data *instance = atm_dev->dev_data;\n\n\tif (!instance || instance->disconnected)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase ATM_QUERYLOOP:\n\t\treturn put_user(ATM_LM_NONE, (int __user *)arg) ? -EFAULT : 0;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nstatic int usbatm_atm_init(struct usbatm_data *instance)\n{\n\tstruct atm_dev *atm_dev;\n\tint ret, i;\n\n\t \n\tatm_dev = atm_dev_register(instance->driver_name,\n\t\t\t\t   &instance->usb_intf->dev, &usbatm_atm_devops,\n\t\t\t\t   -1, NULL);\n\tif (!atm_dev) {\n\t\tusb_err(instance, \"%s: failed to register ATM device!\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tinstance->atm_dev = atm_dev;\n\n\tatm_dev->ci_range.vpi_bits = ATM_CI_MAX;\n\tatm_dev->ci_range.vci_bits = ATM_CI_MAX;\n\tatm_dev->signal = ATM_PHY_SIG_UNKNOWN;\n\n\t \n\tatm_dev->link_rate = 128 * 1000 / 424;\n\n\tif (instance->driver->atm_start && ((ret = instance->driver->atm_start(instance, atm_dev)) < 0)) {\n\t\tatm_err(instance, \"%s: atm_start failed: %d!\\n\", __func__, ret);\n\t\tgoto fail;\n\t}\n\n\tusbatm_get_instance(instance);\t \n\n\t \n\tmb();\n\tatm_dev->dev_data = instance;\n\n\t \n\tfor (i = 0; i < num_rcv_urbs; i++)\n\t\tusbatm_submit_urb(instance->urbs[i]);\n\n\treturn 0;\n\n fail:\n\tinstance->atm_dev = NULL;\n\tatm_dev_deregister(atm_dev);  \n\treturn ret;\n}\n\n\n \n\nstatic int usbatm_do_heavy_init(void *arg)\n{\n\tstruct usbatm_data *instance = arg;\n\tint ret;\n\n\tallow_signal(SIGTERM);\n\tcomplete(&instance->thread_started);\n\n\tret = instance->driver->heavy_init(instance, instance->usb_intf);\n\n\tif (!ret)\n\t\tret = usbatm_atm_init(instance);\n\n\tmutex_lock(&instance->serialize);\n\tinstance->thread = NULL;\n\tmutex_unlock(&instance->serialize);\n\n\tkthread_complete_and_exit(&instance->thread_exited, ret);\n}\n\nstatic int usbatm_heavy_init(struct usbatm_data *instance)\n{\n\tstruct task_struct *t;\n\n\tt = kthread_create(usbatm_do_heavy_init, instance, \"%s\",\n\t\t\tinstance->driver->driver_name);\n\tif (IS_ERR(t)) {\n\t\tusb_err(instance, \"%s: failed to create kernel_thread (%ld)!\\n\",\n\t\t\t\t__func__, PTR_ERR(t));\n\t\treturn PTR_ERR(t);\n\t}\n\n\tinstance->thread = t;\n\twake_up_process(t);\n\twait_for_completion(&instance->thread_started);\n\n\treturn 0;\n}\n\nstatic void usbatm_tasklet_schedule(struct timer_list *t)\n{\n\tstruct usbatm_channel *channel = from_timer(channel, t, delay);\n\n\ttasklet_schedule(&channel->tasklet);\n}\n\nstatic void usbatm_init_channel(struct usbatm_channel *channel)\n{\n\tspin_lock_init(&channel->lock);\n\tINIT_LIST_HEAD(&channel->list);\n\ttimer_setup(&channel->delay, usbatm_tasklet_schedule, 0);\n}\n\nint usbatm_usb_probe(struct usb_interface *intf, const struct usb_device_id *id,\n\t\t     struct usbatm_driver *driver)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usbatm_data *instance;\n\tchar *buf;\n\tint error = -ENOMEM;\n\tint i, length;\n\tunsigned int maxpacket, num_packets;\n\tsize_t size;\n\n\t \n\tsize = struct_size(instance, urbs, num_rcv_urbs + num_snd_urbs);\n\tinstance = kzalloc(size, GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\t \n\n\tinstance->driver = driver;\n\tstrscpy(instance->driver_name, driver->driver_name,\n\t\tsizeof(instance->driver_name));\n\n\tinstance->usb_dev = usb_dev;\n\tinstance->usb_intf = intf;\n\n\tbuf = instance->description;\n\tlength = sizeof(instance->description);\n\n\tif ((i = usb_string(usb_dev, usb_dev->descriptor.iProduct, buf, length)) < 0)\n\t\tgoto bind;\n\n\tbuf += i;\n\tlength -= i;\n\n\ti = scnprintf(buf, length, \" (\");\n\tbuf += i;\n\tlength -= i;\n\n\tif (length <= 0 || (i = usb_make_path(usb_dev, buf, length)) < 0)\n\t\tgoto bind;\n\n\tbuf += i;\n\tlength -= i;\n\n\tsnprintf(buf, length, \")\");\n\n bind:\n\tif (driver->bind && (error = driver->bind(instance, intf, id)) < 0) {\n\t\t\tdev_err(dev, \"%s: bind failed: %d!\\n\", __func__, error);\n\t\t\tgoto fail_free;\n\t}\n\n\t \n\n\tkref_init(&instance->refcount);\t\t \n\tmutex_init(&instance->serialize);\n\n\tinstance->thread = NULL;\n\tinit_completion(&instance->thread_started);\n\tinit_completion(&instance->thread_exited);\n\n\tINIT_LIST_HEAD(&instance->vcc_list);\n\tskb_queue_head_init(&instance->sndqueue);\n\n\tusbatm_init_channel(&instance->rx_channel);\n\tusbatm_init_channel(&instance->tx_channel);\n\ttasklet_setup(&instance->rx_channel.tasklet, usbatm_rx_process);\n\ttasklet_setup(&instance->tx_channel.tasklet, usbatm_tx_process);\n\tinstance->rx_channel.stride = ATM_CELL_SIZE + driver->rx_padding;\n\tinstance->tx_channel.stride = ATM_CELL_SIZE + driver->tx_padding;\n\tinstance->rx_channel.usbatm = instance->tx_channel.usbatm = instance;\n\n\tif ((instance->flags & UDSL_USE_ISOC) && driver->isoc_in)\n\t\tinstance->rx_channel.endpoint = usb_rcvisocpipe(usb_dev, driver->isoc_in);\n\telse\n\t\tinstance->rx_channel.endpoint = usb_rcvbulkpipe(usb_dev, driver->bulk_in);\n\n\tinstance->tx_channel.endpoint = usb_sndbulkpipe(usb_dev, driver->bulk_out);\n\n\t \n\tinstance->tx_channel.buf_size = max(instance->tx_channel.stride,\n\t\t\tsnd_buf_bytes - (snd_buf_bytes % instance->tx_channel.stride));\n\n\t \n\tmaxpacket = usb_maxpacket(usb_dev, instance->rx_channel.endpoint);\n\n\tif ((maxpacket < 1) || (maxpacket > UDSL_MAX_BUF_SIZE)) {\n\t\tdev_err(dev, \"%s: invalid endpoint %02x!\\n\", __func__,\n\t\t\t\tusb_pipeendpoint(instance->rx_channel.endpoint));\n\t\terror = -EINVAL;\n\t\tgoto fail_unbind;\n\t}\n\n\tnum_packets = max(1U, (rcv_buf_bytes + maxpacket / 2) / maxpacket);  \n\n\tif (num_packets * maxpacket > UDSL_MAX_BUF_SIZE)\n\t\tnum_packets--;\n\n\tinstance->rx_channel.buf_size = num_packets * maxpacket;\n\tinstance->rx_channel.packet_size = maxpacket;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstruct usbatm_channel *channel = i ?\n\t\t\t&instance->tx_channel : &instance->rx_channel;\n\n\t\tdev_dbg(dev, \"%s: using %d byte buffer for %s channel 0x%p\\n\",\n\t\t\t__func__, channel->buf_size, i ? \"tx\" : \"rx\", channel);\n\t}\n\n\t \n\n\tfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\n\t\tu8 *buffer;\n\t\tstruct usbatm_channel *channel = i < num_rcv_urbs ?\n\t\t\t&instance->rx_channel : &instance->tx_channel;\n\t\tstruct urb *urb;\n\t\tunsigned int iso_packets = usb_pipeisoc(channel->endpoint) ? channel->buf_size / channel->packet_size : 0;\n\n\t\turb = usb_alloc_urb(iso_packets, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail_unbind;\n\t\t}\n\n\t\tinstance->urbs[i] = urb;\n\n\t\t \n\t\tbuffer = kzalloc(channel->buf_size, GFP_KERNEL);\n\t\tif (!buffer) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto fail_unbind;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb, instance->usb_dev, channel->endpoint,\n\t\t\t\t  buffer, channel->buf_size, usbatm_complete, channel);\n\t\tif (iso_packets) {\n\t\t\tint j;\n\t\t\turb->interval = 1;\n\t\t\turb->transfer_flags = URB_ISO_ASAP;\n\t\t\turb->number_of_packets = iso_packets;\n\t\t\tfor (j = 0; j < iso_packets; j++) {\n\t\t\t\turb->iso_frame_desc[j].offset = channel->packet_size * j;\n\t\t\t\turb->iso_frame_desc[j].length = channel->packet_size;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i >= num_rcv_urbs)\n\t\t\tlist_add_tail(&urb->urb_list, &channel->list);\n\n\t\tvdbg(&intf->dev, \"%s: alloced buffer 0x%p buf size %u urb 0x%p\",\n\t\t     __func__, urb->transfer_buffer, urb->transfer_buffer_length, urb);\n\t}\n\n\tinstance->cached_vpi = ATM_VPI_UNSPEC;\n\tinstance->cached_vci = ATM_VCI_UNSPEC;\n\tinstance->cell_buf = kmalloc(instance->rx_channel.stride, GFP_KERNEL);\n\n\tif (!instance->cell_buf) {\n\t\terror = -ENOMEM;\n\t\tgoto fail_unbind;\n\t}\n\n\tif (!(instance->flags & UDSL_SKIP_HEAVY_INIT) && driver->heavy_init) {\n\t\terror = usbatm_heavy_init(instance);\n\t} else {\n\t\tcomplete(&instance->thread_exited);\t \n\t\terror = usbatm_atm_init(instance);\n\t}\n\n\tif (error < 0)\n\t\tgoto fail_unbind;\n\n\tusb_get_dev(usb_dev);\n\tusb_set_intfdata(intf, instance);\n\n\treturn 0;\n\n fail_unbind:\n\tif (instance->driver->unbind)\n\t\tinstance->driver->unbind(instance, intf);\n fail_free:\n\tkfree(instance->cell_buf);\n\n\tfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\n\t\tif (instance->urbs[i])\n\t\t\tkfree(instance->urbs[i]->transfer_buffer);\n\t\tusb_free_urb(instance->urbs[i]);\n\t}\n\n\tkfree(instance);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(usbatm_usb_probe);\n\nvoid usbatm_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\tstruct usbatm_data *instance = usb_get_intfdata(intf);\n\tstruct usbatm_vcc_data *vcc_data;\n\tint i;\n\n\tif (!instance) {\n\t\tdev_dbg(dev, \"%s: NULL instance!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tusb_set_intfdata(intf, NULL);\n\n\tmutex_lock(&instance->serialize);\n\tinstance->disconnected = 1;\n\tif (instance->thread != NULL)\n\t\tsend_sig(SIGTERM, instance->thread, 1);\n\tmutex_unlock(&instance->serialize);\n\n\twait_for_completion(&instance->thread_exited);\n\n\tmutex_lock(&instance->serialize);\n\tlist_for_each_entry(vcc_data, &instance->vcc_list, list)\n\t\tvcc_release_async(vcc_data->vcc, -EPIPE);\n\tmutex_unlock(&instance->serialize);\n\n\ttasklet_disable(&instance->rx_channel.tasklet);\n\ttasklet_disable(&instance->tx_channel.tasklet);\n\n\tfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++)\n\t\tusb_kill_urb(instance->urbs[i]);\n\n\tdel_timer_sync(&instance->rx_channel.delay);\n\tdel_timer_sync(&instance->tx_channel.delay);\n\n\t \n\t \n\tINIT_LIST_HEAD(&instance->rx_channel.list);\n\tINIT_LIST_HEAD(&instance->tx_channel.list);\n\n\ttasklet_enable(&instance->rx_channel.tasklet);\n\ttasklet_enable(&instance->tx_channel.tasklet);\n\n\tif (instance->atm_dev && instance->driver->atm_stop)\n\t\tinstance->driver->atm_stop(instance, instance->atm_dev);\n\n\tif (instance->driver->unbind)\n\t\tinstance->driver->unbind(instance, intf);\n\n\tinstance->driver_data = NULL;\n\n\tfor (i = 0; i < num_rcv_urbs + num_snd_urbs; i++) {\n\t\tkfree(instance->urbs[i]->transfer_buffer);\n\t\tusb_free_urb(instance->urbs[i]);\n\t}\n\n\tkfree(instance->cell_buf);\n\n\t \n\tif (instance->atm_dev) {\n\t\tatm_dev_deregister(instance->atm_dev);\n\t\tinstance->atm_dev = NULL;\n\t}\n\n\tusbatm_put_instance(instance);\t \n}\nEXPORT_SYMBOL_GPL(usbatm_usb_disconnect);\n\n\n \n\nstatic int __init usbatm_usb_init(void)\n{\n\tif (sizeof(struct usbatm_control) > sizeof_field(struct sk_buff, cb)) {\n\t\tpr_err(\"%s unusable with this kernel!\\n\", usbatm_driver_name);\n\t\treturn -EIO;\n\t}\n\n\tif ((num_rcv_urbs > UDSL_MAX_RCV_URBS)\n\t    || (num_snd_urbs > UDSL_MAX_SND_URBS)\n\t    || (rcv_buf_bytes < 1)\n\t    || (rcv_buf_bytes > UDSL_MAX_BUF_SIZE)\n\t    || (snd_buf_bytes < 1)\n\t    || (snd_buf_bytes > UDSL_MAX_BUF_SIZE))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\nmodule_init(usbatm_usb_init);\n\nstatic void __exit usbatm_usb_exit(void)\n{\n}\nmodule_exit(usbatm_usb_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n \n\n#ifdef VERBOSE_DEBUG\nstatic int usbatm_print_packet(struct usbatm_data *instance,\n\t\t\t       const unsigned char *data, int len)\n{\n\tunsigned char buffer[256];\n\tint i = 0, j = 0;\n\n\tfor (i = 0; i < len;) {\n\t\tbuffer[0] = '\\0';\n\t\tsprintf(buffer, \"%.3d :\", i);\n\t\tfor (j = 0; (j < 16) && (i < len); j++, i++)\n\t\t\tsprintf(buffer, \"%s %2.2x\", buffer, data[i]);\n\t\tdev_dbg(&instance->usb_intf->dev, \"%s\", buffer);\n\t}\n\treturn i;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}