{
  "module_name": "xusbatm.c",
  "hash_id": "145a24ef03a7a97c9968596971fc25161ff03ecbb562a89a7637fd34e0c3a81f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/atm/xusbatm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/etherdevice.h>\t\t \n\n#include \"usbatm.h\"\n\n\n#define XUSBATM_DRIVERS_MAX\t8\n\n#define XUSBATM_PARM(name, type, parmtype, desc) \\\n\tstatic type name[XUSBATM_DRIVERS_MAX]; \\\n\tstatic unsigned int num_##name; \\\n\tmodule_param_array(name, parmtype, &num_##name, 0444); \\\n\tMODULE_PARM_DESC(name, desc)\n\nXUSBATM_PARM(vendor, unsigned short, ushort, \"USB device vendor\");\nXUSBATM_PARM(product, unsigned short, ushort, \"USB device product\");\n\nXUSBATM_PARM(rx_endpoint, unsigned char, byte, \"rx endpoint number\");\nXUSBATM_PARM(tx_endpoint, unsigned char, byte, \"tx endpoint number\");\nXUSBATM_PARM(rx_padding, unsigned char, byte, \"rx padding (default 0)\");\nXUSBATM_PARM(tx_padding, unsigned char, byte, \"tx padding (default 0)\");\nXUSBATM_PARM(rx_altsetting, unsigned char, byte, \"rx altsetting (default 0)\");\nXUSBATM_PARM(tx_altsetting, unsigned char, byte, \"rx altsetting (default 0)\");\n\nstatic const char xusbatm_driver_name[] = \"xusbatm\";\n\nstatic struct usbatm_driver xusbatm_drivers[XUSBATM_DRIVERS_MAX];\nstatic struct usb_device_id xusbatm_usb_ids[XUSBATM_DRIVERS_MAX + 1];\nstatic struct usb_driver xusbatm_usb_driver;\n\nstatic struct usb_interface *xusbatm_find_intf(struct usb_device *usb_dev, int altsetting, u8 ep)\n{\n\tstruct usb_host_interface *alt;\n\tstruct usb_interface *intf;\n\tint i, j;\n\n\tfor (i = 0; i < usb_dev->actconfig->desc.bNumInterfaces; i++)\n\t\tif ((intf = usb_dev->actconfig->interface[i]) && (alt = usb_altnum_to_altsetting(intf, altsetting)))\n\t\t\tfor (j = 0; j < alt->desc.bNumEndpoints; j++)\n\t\t\t\tif (alt->endpoint[j].desc.bEndpointAddress == ep)\n\t\t\t\t\treturn intf;\n\treturn NULL;\n}\n\nstatic int xusbatm_capture_intf(struct usbatm_data *usbatm, struct usb_device *usb_dev,\n\t\tstruct usb_interface *intf, int altsetting, int claim)\n{\n\tint ifnum = intf->altsetting->desc.bInterfaceNumber;\n\tint ret;\n\n\tif (claim && (ret = usb_driver_claim_interface(&xusbatm_usb_driver, intf, usbatm))) {\n\t\tusb_err(usbatm, \"%s: failed to claim interface %2d (%d)!\\n\", __func__, ifnum, ret);\n\t\treturn ret;\n\t}\n\tret = usb_set_interface(usb_dev, ifnum, altsetting);\n\tif (ret) {\n\t\tusb_err(usbatm, \"%s: altsetting %2d for interface %2d failed (%d)!\\n\", __func__, altsetting, ifnum, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void xusbatm_release_intf(struct usb_device *usb_dev, struct usb_interface *intf, int claimed)\n{\n\tif (claimed) {\n\t\tusb_set_intfdata(intf, NULL);\n\t\tusb_driver_release_interface(&xusbatm_usb_driver, intf);\n\t}\n}\n\nstatic int xusbatm_bind(struct usbatm_data *usbatm,\n\t\t\tstruct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tint drv_ix = id - xusbatm_usb_ids;\n\tint rx_alt = rx_altsetting[drv_ix];\n\tint tx_alt = tx_altsetting[drv_ix];\n\tstruct usb_interface *rx_intf = xusbatm_find_intf(usb_dev, rx_alt, rx_endpoint[drv_ix]);\n\tstruct usb_interface *tx_intf = xusbatm_find_intf(usb_dev, tx_alt, tx_endpoint[drv_ix]);\n\tint ret;\n\n\tusb_dbg(usbatm, \"%s: binding driver %d: vendor %04x product %04x\"\n\t\t\" rx: ep %02x padd %d alt %2d tx: ep %02x padd %d alt %2d\\n\",\n\t\t__func__, drv_ix, vendor[drv_ix], product[drv_ix],\n\t\trx_endpoint[drv_ix], rx_padding[drv_ix], rx_alt,\n\t\ttx_endpoint[drv_ix], tx_padding[drv_ix], tx_alt);\n\n\tif (!rx_intf || !tx_intf) {\n\t\tif (!rx_intf)\n\t\t\tusb_dbg(usbatm, \"%s: no interface contains endpoint %02x in altsetting %2d\\n\",\n\t\t\t\t__func__, rx_endpoint[drv_ix], rx_alt);\n\t\tif (!tx_intf)\n\t\t\tusb_dbg(usbatm, \"%s: no interface contains endpoint %02x in altsetting %2d\\n\",\n\t\t\t\t__func__, tx_endpoint[drv_ix], tx_alt);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((rx_intf != intf) && (tx_intf != intf))\n\t\treturn -ENODEV;\n\n\tif ((rx_intf == tx_intf) && (rx_alt != tx_alt)) {\n\t\tusb_err(usbatm, \"%s: altsettings clash on interface %2d (%2d vs %2d)!\\n\", __func__,\n\t\t\t\trx_intf->altsetting->desc.bInterfaceNumber, rx_alt, tx_alt);\n\t\treturn -EINVAL;\n\t}\n\n\tusb_dbg(usbatm, \"%s: rx If#=%2d; tx If#=%2d\\n\", __func__,\n\t\t\trx_intf->altsetting->desc.bInterfaceNumber,\n\t\t\ttx_intf->altsetting->desc.bInterfaceNumber);\n\n\tret = xusbatm_capture_intf(usbatm, usb_dev, rx_intf, rx_alt, rx_intf != intf);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((tx_intf != rx_intf) && (ret = xusbatm_capture_intf(usbatm, usb_dev, tx_intf, tx_alt, tx_intf != intf))) {\n\t\txusbatm_release_intf(usb_dev, rx_intf, rx_intf != intf);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void xusbatm_unbind(struct usbatm_data *usbatm,\n\t\t\t   struct usb_interface *intf)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tint i;\n\n\tusb_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tfor (i = 0; i < usb_dev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *cur_intf = usb_dev->actconfig->interface[i];\n\n\t\tif (cur_intf && (usb_get_intfdata(cur_intf) == usbatm)) {\n\t\t\tusb_set_intfdata(cur_intf, NULL);\n\t\t\tusb_driver_release_interface(&xusbatm_usb_driver, cur_intf);\n\t\t}\n\t}\n}\n\nstatic int xusbatm_atm_start(struct usbatm_data *usbatm,\n\t\t\t     struct atm_dev *atm_dev)\n{\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\t \n\teth_random_addr(atm_dev->esi);\n\n\treturn 0;\n}\n\n\nstatic int xusbatm_usb_probe(struct usb_interface *intf,\n\t\t\t     const struct usb_device_id *id)\n{\n\treturn usbatm_usb_probe(intf, id,\n\t\t\t\txusbatm_drivers + (id - xusbatm_usb_ids));\n}\n\nstatic struct usb_driver xusbatm_usb_driver = {\n\t.name\t\t= xusbatm_driver_name,\n\t.probe\t\t= xusbatm_usb_probe,\n\t.disconnect\t= usbatm_usb_disconnect,\n\t.id_table\t= xusbatm_usb_ids\n};\n\nstatic int __init xusbatm_init(void)\n{\n\tint i;\n\n\tif (!num_vendor ||\n\t    num_vendor != num_product ||\n\t    num_vendor != num_rx_endpoint ||\n\t    num_vendor != num_tx_endpoint) {\n\t\tpr_warn(\"xusbatm: malformed module parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < num_vendor; i++) {\n\t\trx_endpoint[i] |= USB_DIR_IN;\n\t\ttx_endpoint[i] &= USB_ENDPOINT_NUMBER_MASK;\n\n\t\txusbatm_usb_ids[i].match_flags\t= USB_DEVICE_ID_MATCH_DEVICE;\n\t\txusbatm_usb_ids[i].idVendor\t= vendor[i];\n\t\txusbatm_usb_ids[i].idProduct\t= product[i];\n\n\t\txusbatm_drivers[i].driver_name\t= xusbatm_driver_name;\n\t\txusbatm_drivers[i].bind\t\t= xusbatm_bind;\n\t\txusbatm_drivers[i].unbind\t= xusbatm_unbind;\n\t\txusbatm_drivers[i].atm_start\t= xusbatm_atm_start;\n\t\txusbatm_drivers[i].bulk_in\t= rx_endpoint[i];\n\t\txusbatm_drivers[i].bulk_out\t= tx_endpoint[i];\n\t\txusbatm_drivers[i].rx_padding\t= rx_padding[i];\n\t\txusbatm_drivers[i].tx_padding\t= tx_padding[i];\n\t}\n\n\treturn usb_register(&xusbatm_usb_driver);\n}\nmodule_init(xusbatm_init);\n\nstatic void __exit xusbatm_exit(void)\n{\n\tusb_deregister(&xusbatm_usb_driver);\n}\nmodule_exit(xusbatm_exit);\n\nMODULE_AUTHOR(\"Roman Kagan, Duncan Sands\");\nMODULE_DESCRIPTION(\"Driver for USB ADSL modems initialized in userspace\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}