{
  "module_name": "ueagle-atm.c",
  "hash_id": "64ae892e51a5311b314cb46bdd003793f6c1570f895b4a02a5fb10de936ca5cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/atm/ueagle-atm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/crc32.h>\n#include <linux/usb.h>\n#include <linux/firmware.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#include <asm/unaligned.h>\n\n#include \"usbatm.h\"\n\n#define EAGLEUSBVERSION \"ueagle 1.4\"\n\n\n \n#define uea_dbg(usb_dev, format, args...)\t\\\n\tdo { \\\n\t\tif (debug >= 1) \\\n\t\t\tdev_dbg(&(usb_dev)->dev, \\\n\t\t\t\t\"[ueagle-atm dbg] %s: \" format, \\\n\t\t\t\t\t__func__, ##args); \\\n\t} while (0)\n\n#define uea_vdbg(usb_dev, format, args...)\t\\\n\tdo { \\\n\t\tif (debug >= 2) \\\n\t\t\tdev_dbg(&(usb_dev)->dev, \\\n\t\t\t\t\"[ueagle-atm vdbg]  \" format, ##args); \\\n\t} while (0)\n\n#define uea_enters(usb_dev) \\\n\tuea_vdbg(usb_dev, \"entering %s\\n\" , __func__)\n\n#define uea_leaves(usb_dev) \\\n\tuea_vdbg(usb_dev, \"leaving  %s\\n\" , __func__)\n\n#define uea_err(usb_dev, format, args...) \\\n\tdev_err(&(usb_dev)->dev , \"[UEAGLE-ATM] \" format , ##args)\n\n#define uea_warn(usb_dev, format, args...) \\\n\tdev_warn(&(usb_dev)->dev , \"[Ueagle-atm] \" format, ##args)\n\n#define uea_info(usb_dev, format, args...) \\\n\tdev_info(&(usb_dev)->dev , \"[ueagle-atm] \" format, ##args)\n\nstruct intr_pkt;\n\n \nstruct uea_cmvs_v1 {\n\tu32 address;\n\tu16 offset;\n\tu32 data;\n} __packed;\n\nstruct uea_cmvs_v2 {\n\tu32 group;\n\tu32 address;\n\tu32 offset;\n\tu32 data;\n} __packed;\n\n \nstruct cmv_dsc_e1 {\n\tu8 function;\n\tu16 idx;\n\tu32 address;\n\tu16 offset;\n};\n\nstruct cmv_dsc_e4 {\n\tu16 function;\n\tu16 offset;\n\tu16 address;\n\tu16 group;\n};\n\nunion cmv_dsc {\n\tstruct cmv_dsc_e1 e1;\n\tstruct cmv_dsc_e4 e4;\n};\n\nstruct uea_softc {\n\tstruct usb_device *usb_dev;\n\tstruct usbatm_data *usbatm;\n\n\tint modem_index;\n\tunsigned int driver_info;\n\tint annex;\n#define ANNEXA 0\n#define ANNEXB 1\n\n\tint booting;\n\tint reset;\n\n\twait_queue_head_t sync_q;\n\n\tstruct task_struct *kthread;\n\tu32 data;\n\tu32 data1;\n\n\tint cmv_ack;\n\tunion cmv_dsc cmv_dsc;\n\n\tstruct work_struct task;\n\tu16 pageno;\n\tu16 ovl;\n\n\tconst struct firmware *dsp_firm;\n\tstruct urb *urb_int;\n\n\tvoid (*dispatch_cmv)(struct uea_softc *, struct intr_pkt *);\n\tvoid (*schedule_load_page)(struct uea_softc *, struct intr_pkt *);\n\tint (*stat)(struct uea_softc *);\n\tint (*send_cmvs)(struct uea_softc *);\n\n\t \n\tstruct uea_stats {\n\t\tstruct {\n\t\t\tu32 state;\n\t\t\tu32 flags;\n\t\t\tu32 mflags;\n\t\t\tu32 vidcpe;\n\t\t\tu32 vidco;\n\t\t\tu32 dsrate;\n\t\t\tu32 usrate;\n\t\t\tu32 dsunc;\n\t\t\tu32 usunc;\n\t\t\tu32 dscorr;\n\t\t\tu32 uscorr;\n\t\t\tu32 txflow;\n\t\t\tu32 rxflow;\n\t\t\tu32 usattenuation;\n\t\t\tu32 dsattenuation;\n\t\t\tu32 dsmargin;\n\t\t\tu32 usmargin;\n\t\t\tu32 firmid;\n\t\t} phy;\n\t} stats;\n};\n\n \n#define ELSA_VID\t\t0x05CC\n#define ELSA_PID_PSTFIRM\t0x3350\n#define ELSA_PID_PREFIRM\t0x3351\n\n#define ELSA_PID_A_PREFIRM\t0x3352\n#define ELSA_PID_A_PSTFIRM\t0x3353\n#define ELSA_PID_B_PREFIRM\t0x3362\n#define ELSA_PID_B_PSTFIRM\t0x3363\n\n \n#define DEVOLO_VID\t\t\t0x1039\n#define DEVOLO_EAGLE_I_A_PID_PSTFIRM\t0x2110\n#define DEVOLO_EAGLE_I_A_PID_PREFIRM\t0x2111\n\n#define DEVOLO_EAGLE_I_B_PID_PSTFIRM\t0x2100\n#define DEVOLO_EAGLE_I_B_PID_PREFIRM\t0x2101\n\n#define DEVOLO_EAGLE_II_A_PID_PSTFIRM\t0x2130\n#define DEVOLO_EAGLE_II_A_PID_PREFIRM\t0x2131\n\n#define DEVOLO_EAGLE_II_B_PID_PSTFIRM\t0x2120\n#define DEVOLO_EAGLE_II_B_PID_PREFIRM\t0x2121\n\n \n#define ANALOG_VID\t\t0x1110\n#define ADI930_PID_PREFIRM\t0x9001\n#define ADI930_PID_PSTFIRM\t0x9000\n\n#define EAGLE_I_PID_PREFIRM\t0x9010\t \n#define EAGLE_I_PID_PSTFIRM\t0x900F\t \n\n#define EAGLE_IIC_PID_PREFIRM\t0x9024\t \n#define EAGLE_IIC_PID_PSTFIRM\t0x9023\t \n\n#define EAGLE_II_PID_PREFIRM\t0x9022\t \n#define EAGLE_II_PID_PSTFIRM\t0x9021\t \n\n#define EAGLE_III_PID_PREFIRM\t0x9032\t \n#define EAGLE_III_PID_PSTFIRM\t0x9031\t \n\n#define EAGLE_IV_PID_PREFIRM\t0x9042   \n#define EAGLE_IV_PID_PSTFIRM\t0x9041   \n\n \n#define USR_VID\t\t\t0x0BAF\n#define MILLER_A_PID_PREFIRM\t0x00F2\n#define MILLER_A_PID_PSTFIRM\t0x00F1\n#define MILLER_B_PID_PREFIRM\t0x00FA\n#define MILLER_B_PID_PSTFIRM\t0x00F9\n#define HEINEKEN_A_PID_PREFIRM\t0x00F6\n#define HEINEKEN_A_PID_PSTFIRM\t0x00F5\n#define HEINEKEN_B_PID_PREFIRM\t0x00F8\n#define HEINEKEN_B_PID_PSTFIRM\t0x00F7\n\n#define PREFIRM 0\n#define PSTFIRM (1<<7)\n#define AUTO_ANNEX_A (1<<8)\n#define AUTO_ANNEX_B (1<<9)\n\nenum {\n\tADI930 = 0,\n\tEAGLE_I,\n\tEAGLE_II,\n\tEAGLE_III,\n\tEAGLE_IV\n};\n\n \n#define UEA_IS_PREFIRM(x) \\\n\t(!((x)->driver_info & PSTFIRM))\n#define UEA_CHIP_VERSION(x) \\\n\t((x)->driver_info & 0xf)\n\n#define IS_ISDN(x) \\\n\t((x)->annex & ANNEXB)\n\n#define INS_TO_USBDEV(ins) (ins->usb_dev)\n\n#define GET_STATUS(data) \\\n\t((data >> 8) & 0xf)\n\n#define IS_OPERATIONAL(sc) \\\n\t((UEA_CHIP_VERSION(sc) != EAGLE_IV) ? \\\n\t(GET_STATUS(sc->stats.phy.state) == 2) : \\\n\t(sc->stats.phy.state == 7))\n\n \n\n#define FW_GET_BYTE(p) (*((__u8 *) (p)))\n\n#define FW_DIR \"ueagle-atm/\"\n#define EAGLE_FIRMWARE FW_DIR \"eagle.fw\"\n#define ADI930_FIRMWARE FW_DIR \"adi930.fw\"\n#define EAGLE_I_FIRMWARE FW_DIR \"eagleI.fw\"\n#define EAGLE_II_FIRMWARE FW_DIR \"eagleII.fw\"\n#define EAGLE_III_FIRMWARE FW_DIR \"eagleIII.fw\"\n#define EAGLE_IV_FIRMWARE FW_DIR \"eagleIV.fw\"\n\n#define DSP4I_FIRMWARE FW_DIR \"DSP4i.bin\"\n#define DSP4P_FIRMWARE FW_DIR \"DSP4p.bin\"\n#define DSP9I_FIRMWARE FW_DIR \"DSP9i.bin\"\n#define DSP9P_FIRMWARE FW_DIR \"DSP9p.bin\"\n#define DSPEI_FIRMWARE FW_DIR \"DSPei.bin\"\n#define DSPEP_FIRMWARE FW_DIR \"DSPep.bin\"\n#define FPGA930_FIRMWARE FW_DIR \"930-fpga.bin\"\n\n#define CMV4P_FIRMWARE FW_DIR \"CMV4p.bin\"\n#define CMV4PV2_FIRMWARE FW_DIR \"CMV4p.bin.v2\"\n#define CMV4I_FIRMWARE FW_DIR \"CMV4i.bin\"\n#define CMV4IV2_FIRMWARE FW_DIR \"CMV4i.bin.v2\"\n#define CMV9P_FIRMWARE FW_DIR \"CMV9p.bin\"\n#define CMV9PV2_FIRMWARE FW_DIR \"CMV9p.bin.v2\"\n#define CMV9I_FIRMWARE FW_DIR \"CMV9i.bin\"\n#define CMV9IV2_FIRMWARE FW_DIR \"CMV9i.bin.v2\"\n#define CMVEP_FIRMWARE FW_DIR \"CMVep.bin\"\n#define CMVEPV2_FIRMWARE FW_DIR \"CMVep.bin.v2\"\n#define CMVEI_FIRMWARE FW_DIR \"CMVei.bin\"\n#define CMVEIV2_FIRMWARE FW_DIR \"CMVei.bin.v2\"\n\n#define UEA_FW_NAME_MAX 30\n#define NB_MODEM 4\n\n#define BULK_TIMEOUT 300\n#define CTRL_TIMEOUT 1000\n\n#define ACK_TIMEOUT msecs_to_jiffies(3000)\n\n#define UEA_INTR_IFACE_NO\t0\n#define UEA_US_IFACE_NO\t\t1\n#define UEA_DS_IFACE_NO\t\t2\n\n#define FASTEST_ISO_INTF\t8\n\n#define UEA_BULK_DATA_PIPE\t0x02\n#define UEA_IDMA_PIPE\t\t0x04\n#define UEA_INTR_PIPE\t\t0x04\n#define UEA_ISO_DATA_PIPE\t0x08\n\n#define UEA_E1_SET_BLOCK\t0x0001\n#define UEA_E4_SET_BLOCK\t0x002c\n#define UEA_SET_MODE\t\t0x0003\n#define UEA_SET_2183_DATA\t0x0004\n#define UEA_SET_TIMEOUT\t\t0x0011\n\n#define UEA_LOOPBACK_OFF\t0x0002\n#define UEA_LOOPBACK_ON\t\t0x0003\n#define UEA_BOOT_IDMA\t\t0x0006\n#define UEA_START_RESET\t\t0x0007\n#define UEA_END_RESET\t\t0x0008\n\n#define UEA_SWAP_MAILBOX\t(0x3fcd | 0x4000)\n#define UEA_MPTX_START\t\t(0x3fce | 0x4000)\n#define UEA_MPTX_MAILBOX\t(0x3fd6 | 0x4000)\n#define UEA_MPRX_MAILBOX\t(0x3fdf | 0x4000)\n\n \nstruct block_index {\n\t__le32 PageOffset;\n\t__le32 NotLastBlock;\n\t__le32 dummy;\n\t__le32 PageSize;\n\t__le32 PageAddress;\n\t__le16 dummy1;\n\t__le16 PageNumber;\n} __packed;\n\n#define E4_IS_BOOT_PAGE(PageSize) ((le32_to_cpu(PageSize)) & 0x80000000)\n#define E4_PAGE_BYTES(PageSize) ((le32_to_cpu(PageSize) & 0x7fffffff) * 4)\n\n#define E4_L1_STRING_HEADER 0x10\n#define E4_MAX_PAGE_NUMBER 0x58\n#define E4_NO_SWAPPAGE_HEADERS 0x31\n\n \nstruct l1_code {\n\tu8 string_header[E4_L1_STRING_HEADER];\n\tu8 page_number_to_block_index[E4_MAX_PAGE_NUMBER];\n\tstruct block_index page_header[E4_NO_SWAPPAGE_HEADERS];\n\tu8 code[];\n} __packed;\n\n \nstruct block_info_e1 {\n\t__le16 wHdr;\n\t__le16 wAddress;\n\t__le16 wSize;\n\t__le16 wOvlOffset;\n\t__le16 wOvl;\t\t \n\t__le16 wLast;\n} __packed;\n#define E1_BLOCK_INFO_SIZE 12\n\nstruct block_info_e4 {\n\t__be16 wHdr;\n\t__u8 bBootPage;\n\t__u8 bPageNumber;\n\t__be32 dwSize;\n\t__be32 dwAddress;\n\t__be16 wReserved;\n} __packed;\n#define E4_BLOCK_INFO_SIZE 14\n\n#define UEA_BIHDR 0xabcd\n#define UEA_RESERVED 0xffff\n\n \n#define E1_PREAMBLE 0x535c\n#define E1_MODEMTOHOST 0x01\n#define E1_HOSTTOMODEM 0x10\n\n#define E1_MEMACCESS 0x1\n#define E1_ADSLDIRECTIVE 0x7\n#define E1_FUNCTION_TYPE(f) ((f) >> 4)\n#define E1_FUNCTION_SUBTYPE(f) ((f) & 0x0f)\n\n#define E4_MEMACCESS 0\n#define E4_ADSLDIRECTIVE 0xf\n#define E4_FUNCTION_TYPE(f) ((f) >> 8)\n#define E4_FUNCTION_SIZE(f) ((f) & 0x0f)\n#define E4_FUNCTION_SUBTYPE(f) (((f) >> 4) & 0x0f)\n\n \n#define E1_REQUESTREAD\t0x0\n#define E1_REQUESTWRITE\t0x1\n#define E1_REPLYREAD\t0x2\n#define E1_REPLYWRITE\t0x3\n\n#define E4_REQUESTREAD\t0x0\n#define E4_REQUESTWRITE\t0x4\n#define E4_REPLYREAD\t(E4_REQUESTREAD | 1)\n#define E4_REPLYWRITE\t(E4_REQUESTWRITE | 1)\n\n \n#define E1_KERNELREADY 0x0\n#define E1_MODEMREADY  0x1\n\n#define E4_KERNELREADY 0x0\n#define E4_MODEMREADY  0x1\n\n#define E1_MAKEFUNCTION(t, s) (((t) & 0xf) << 4 | ((s) & 0xf))\n#define E4_MAKEFUNCTION(t, st, s) (((t) & 0xf) << 8 | \\\n\t((st) & 0xf) << 4 | ((s) & 0xf))\n\n#define E1_MAKESA(a, b, c, d)\t\t\t\t\t\t\\\n\t(((c) & 0xff) << 24 |\t\t\t\t\t\t\\\n\t ((d) & 0xff) << 16 |\t\t\t\t\t\t\\\n\t ((a) & 0xff) << 8  |\t\t\t\t\t\t\\\n\t ((b) & 0xff))\n\n#define E1_GETSA1(a) ((a >> 8) & 0xff)\n#define E1_GETSA2(a) (a & 0xff)\n#define E1_GETSA3(a) ((a >> 24) & 0xff)\n#define E1_GETSA4(a) ((a >> 16) & 0xff)\n\n#define E1_SA_CNTL E1_MAKESA('C', 'N', 'T', 'L')\n#define E1_SA_DIAG E1_MAKESA('D', 'I', 'A', 'G')\n#define E1_SA_INFO E1_MAKESA('I', 'N', 'F', 'O')\n#define E1_SA_OPTN E1_MAKESA('O', 'P', 'T', 'N')\n#define E1_SA_RATE E1_MAKESA('R', 'A', 'T', 'E')\n#define E1_SA_STAT E1_MAKESA('S', 'T', 'A', 'T')\n\n#define E4_SA_CNTL 1\n#define E4_SA_STAT 2\n#define E4_SA_INFO 3\n#define E4_SA_TEST 4\n#define E4_SA_OPTN 5\n#define E4_SA_RATE 6\n#define E4_SA_DIAG 7\n#define E4_SA_CNFG 8\n\n \nstruct cmv_e1 {\n\t__le16 wPreamble;\n\t__u8 bDirection;\n\t__u8 bFunction;\n\t__le16 wIndex;\n\t__le32 dwSymbolicAddress;\n\t__le16 wOffsetAddress;\n\t__le32 dwData;\n} __packed;\n\nstruct cmv_e4 {\n\t__be16 wGroup;\n\t__be16 wFunction;\n\t__be16 wOffset;\n\t__be16 wAddress;\n\t__be32 dwData[6];\n} __packed;\n\n \nstruct swap_info_e1 {\n\t__u8 bSwapPageNo;\n\t__u8 bOvl;\t\t \n} __packed;\n\nstruct swap_info_e4 {\n\t__u8 bSwapPageNo;\n} __packed;\n\n \n#define e1_bSwapPageNo\tu.e1.s1.swapinfo.bSwapPageNo\n#define e1_bOvl\t\tu.e1.s1.swapinfo.bOvl\n#define e4_bSwapPageNo  u.e4.s1.swapinfo.bSwapPageNo\n\n#define INT_LOADSWAPPAGE 0x0001\n#define INT_INCOMINGCMV  0x0002\n\nunion intr_data_e1 {\n\tstruct {\n\t\tstruct swap_info_e1 swapinfo;\n\t\t__le16 wDataSize;\n\t} __packed s1;\n\tstruct {\n\t\tstruct cmv_e1 cmv;\n\t\t__le16 wDataSize;\n\t} __packed s2;\n} __packed;\n\nunion intr_data_e4 {\n\tstruct {\n\t\tstruct swap_info_e4 swapinfo;\n\t\t__le16 wDataSize;\n\t} __packed s1;\n\tstruct {\n\t\tstruct cmv_e4 cmv;\n\t\t__le16 wDataSize;\n\t} __packed s2;\n} __packed;\n\nstruct intr_pkt {\n\t__u8 bType;\n\t__u8 bNotification;\n\t__le16 wValue;\n\t__le16 wIndex;\n\t__le16 wLength;\n\t__le16 wInterrupt;\n\tunion {\n\t\tunion intr_data_e1 e1;\n\t\tunion intr_data_e4 e4;\n\t} u;\n} __packed;\n\n#define E1_INTR_PKT_SIZE 28\n#define E4_INTR_PKT_SIZE 64\n\nstatic struct usb_driver uea_driver;\nstatic DEFINE_MUTEX(uea_mutex);\nstatic const char * const chip_name[] = {\n\t\"ADI930\", \"Eagle I\", \"Eagle II\", \"Eagle III\", \"Eagle IV\"};\n\nstatic int modem_index;\nstatic unsigned int debug;\nstatic unsigned int altsetting[NB_MODEM] = {\n\t\t\t\t[0 ... (NB_MODEM - 1)] = FASTEST_ISO_INTF};\nstatic bool sync_wait[NB_MODEM];\nstatic char *cmv_file[NB_MODEM];\nstatic int annex[NB_MODEM];\n\nmodule_param(debug, uint, 0644);\nMODULE_PARM_DESC(debug, \"module debug level (0=off,1=on,2=verbose)\");\nmodule_param_array(altsetting, uint, NULL, 0644);\nMODULE_PARM_DESC(altsetting, \"alternate setting for incoming traffic: 0=bulk, \"\n\t\t\t     \"1=isoc slowest, ... , 8=isoc fastest (default)\");\nmodule_param_array(sync_wait, bool, NULL, 0644);\nMODULE_PARM_DESC(sync_wait, \"wait the synchronisation before starting ATM\");\nmodule_param_array(cmv_file, charp, NULL, 0644);\nMODULE_PARM_DESC(cmv_file,\n\t\t\"file name with configuration and management variables\");\nmodule_param_array(annex, uint, NULL, 0644);\nMODULE_PARM_DESC(annex,\n\t\t\"manually set annex a/b (0=auto, 1=annex a, 2=annex b)\");\n\n#define uea_wait(sc, cond, timeo) \\\n({ \\\n\tint _r = wait_event_interruptible_timeout(sc->sync_q, \\\n\t\t\t(cond) || kthread_should_stop(), timeo); \\\n\tif (kthread_should_stop()) \\\n\t\t_r = -ENODEV; \\\n\t_r; \\\n})\n\n#define UPDATE_ATM_STAT(type, val) \\\n\tdo { \\\n\t\tif (sc->usbatm->atm_dev) \\\n\t\t\tsc->usbatm->atm_dev->type = val; \\\n\t} while (0)\n\n#define UPDATE_ATM_SIGNAL(val) \\\n\tdo { \\\n\t\tif (sc->usbatm->atm_dev) \\\n\t\t\tatm_dev_signal_change(sc->usbatm->atm_dev, val); \\\n\t} while (0)\n\n\n \n#define LOAD_INTERNAL     0xA0\n#define F8051_USBCS       0x7f92\n\n \nstatic int uea_send_modem_cmd(struct usb_device *usb,\n\t\t\t      u16 addr, u16 size, const u8 *buff)\n{\n\tint ret = -ENOMEM;\n\tu8 *xfer_buff;\n\n\txfer_buff = kmemdup(buff, size, GFP_KERNEL);\n\tif (xfer_buff) {\n\t\tret = usb_control_msg(usb,\n\t\t\t\t      usb_sndctrlpipe(usb, 0),\n\t\t\t\t      LOAD_INTERNAL,\n\t\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t      USB_RECIP_DEVICE, addr, 0, xfer_buff,\n\t\t\t\t      size, CTRL_TIMEOUT);\n\t\tkfree(xfer_buff);\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret == size) ? 0 : -EIO;\n}\n\nstatic void uea_upload_pre_firmware(const struct firmware *fw_entry,\n\t\t\t\t\t\t\t\tvoid *context)\n{\n\tstruct usb_device *usb = context;\n\tconst u8 *pfw;\n\tu8 value;\n\tu32 crc = 0;\n\tint ret, size;\n\n\tuea_enters(usb);\n\tif (!fw_entry) {\n\t\tuea_err(usb, \"firmware is not available\\n\");\n\t\tgoto err;\n\t}\n\n\tpfw = fw_entry->data;\n\tsize = fw_entry->size;\n\tif (size < 4)\n\t\tgoto err_fw_corrupted;\n\n\tcrc = get_unaligned_le32(pfw);\n\tpfw += 4;\n\tsize -= 4;\n\tif (crc32_be(0, pfw, size) != crc)\n\t\tgoto err_fw_corrupted;\n\n\t \n\tvalue = 1;\n\tret = uea_send_modem_cmd(usb, F8051_USBCS, sizeof(value), &value);\n\n\tif (ret < 0) {\n\t\tuea_err(usb, \"modem reset failed with error %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\twhile (size > 3) {\n\t\tu8 len = FW_GET_BYTE(pfw);\n\t\tu16 add = get_unaligned_le16(pfw + 1);\n\n\t\tsize -= len + 3;\n\t\tif (size < 0)\n\t\t\tgoto err_fw_corrupted;\n\n\t\tret = uea_send_modem_cmd(usb, add, len, pfw + 3);\n\t\tif (ret < 0) {\n\t\t\tuea_err(usb, \"uploading firmware data failed \"\n\t\t\t\t\t\"with error %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t\tpfw += len + 3;\n\t}\n\n\tif (size != 0)\n\t\tgoto err_fw_corrupted;\n\n\t \n\tvalue = 0;\n\tret = uea_send_modem_cmd(usb, F8051_USBCS, 1, &value);\n\tif (ret < 0)\n\t\tuea_err(usb, \"modem de-assert failed with error %d\\n\", ret);\n\telse\n\t\tuea_info(usb, \"firmware uploaded\\n\");\n\n\tgoto err;\n\nerr_fw_corrupted:\n\tuea_err(usb, \"firmware is corrupted\\n\");\nerr:\n\trelease_firmware(fw_entry);\n\tuea_leaves(usb);\n}\n\n \nstatic int uea_load_firmware(struct usb_device *usb, unsigned int ver)\n{\n\tint ret;\n\tchar *fw_name = EAGLE_FIRMWARE;\n\n\tuea_enters(usb);\n\tuea_info(usb, \"pre-firmware device, uploading firmware\\n\");\n\n\tswitch (ver) {\n\tcase ADI930:\n\t\tfw_name = ADI930_FIRMWARE;\n\t\tbreak;\n\tcase EAGLE_I:\n\t\tfw_name = EAGLE_I_FIRMWARE;\n\t\tbreak;\n\tcase EAGLE_II:\n\t\tfw_name = EAGLE_II_FIRMWARE;\n\t\tbreak;\n\tcase EAGLE_III:\n\t\tfw_name = EAGLE_III_FIRMWARE;\n\t\tbreak;\n\tcase EAGLE_IV:\n\t\tfw_name = EAGLE_IV_FIRMWARE;\n\t\tbreak;\n\t}\n\n\tret = request_firmware_nowait(THIS_MODULE, 1, fw_name, &usb->dev,\n\t\t\t\t\tGFP_KERNEL, usb,\n\t\t\t\t\tuea_upload_pre_firmware);\n\tif (ret)\n\t\tuea_err(usb, \"firmware %s is not available\\n\", fw_name);\n\telse\n\t\tuea_info(usb, \"loading firmware %s\\n\", fw_name);\n\n\tuea_leaves(usb);\n\treturn ret;\n}\n\n \n\n \nstatic int check_dsp_e1(const u8 *dsp, unsigned int len)\n{\n\tu8 pagecount, blockcount;\n\tu16 blocksize;\n\tu32 pageoffset;\n\tunsigned int i, j, p, pp;\n\n\tpagecount = FW_GET_BYTE(dsp);\n\tp = 1;\n\n\t \n\tif (p + 4 * pagecount > len)\n\t\treturn 1;\n\n\tfor (i = 0; i < pagecount; i++) {\n\n\t\tpageoffset = get_unaligned_le32(dsp + p);\n\t\tp += 4;\n\n\t\tif (pageoffset == 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (pageoffset >= len)\n\t\t\treturn 1;\n\n\t\tpp = pageoffset;\n\t\tblockcount = FW_GET_BYTE(dsp + pp);\n\t\tpp += 1;\n\n\t\tfor (j = 0; j < blockcount; j++) {\n\n\t\t\t \n\t\t\tif (pp + 4 > len)\n\t\t\t\treturn 1;\n\n\t\t\tpp += 2;\t \n\t\t\tblocksize = get_unaligned_le16(dsp + pp);\n\t\t\tpp += 2;\n\n\t\t\t \n\t\t\tif (pp + blocksize > len)\n\t\t\t\treturn 1;\n\n\t\t\tpp += blocksize;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_dsp_e4(const u8 *dsp, int len)\n{\n\tint i;\n\tstruct l1_code *p = (struct l1_code *) dsp;\n\tunsigned int sum = p->code - dsp;\n\n\tif (len < sum)\n\t\treturn 1;\n\n\tif (strcmp(\"STRATIPHY ANEXA\", p->string_header) != 0 &&\n\t    strcmp(\"STRATIPHY ANEXB\", p->string_header) != 0)\n\t\treturn 1;\n\n\tfor (i = 0; i < E4_MAX_PAGE_NUMBER; i++) {\n\t\tstruct block_index *blockidx;\n\t\tu8 blockno = p->page_number_to_block_index[i];\n\t\tif (blockno >= E4_NO_SWAPPAGE_HEADERS)\n\t\t\tcontinue;\n\n\t\tdo {\n\t\t\tu64 l;\n\n\t\t\tif (blockno >= E4_NO_SWAPPAGE_HEADERS)\n\t\t\t\treturn 1;\n\n\t\t\tblockidx = &p->page_header[blockno++];\n\t\t\tif ((u8 *)(blockidx + 1) - dsp  >= len)\n\t\t\t\treturn 1;\n\n\t\t\tif (le16_to_cpu(blockidx->PageNumber) != i)\n\t\t\t\treturn 1;\n\n\t\t\tl = E4_PAGE_BYTES(blockidx->PageSize);\n\t\t\tsum += l;\n\t\t\tl += le32_to_cpu(blockidx->PageOffset);\n\t\t\tif (l > len)\n\t\t\t\treturn 1;\n\n\t\t \n\t\t} while (blockidx->NotLastBlock);\n\t}\n\n\treturn (sum == len) ? 0 : 1;\n}\n\n \nstatic int uea_idma_write(struct uea_softc *sc, const void *data, u32 size)\n{\n\tint ret = -ENOMEM;\n\tu8 *xfer_buff;\n\tint bytes_read;\n\n\txfer_buff = kmemdup(data, size, GFP_KERNEL);\n\tif (!xfer_buff) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"can't allocate xfer_buff\\n\");\n\t\treturn ret;\n\t}\n\n\tret = usb_bulk_msg(sc->usb_dev,\n\t\t\t usb_sndbulkpipe(sc->usb_dev, UEA_IDMA_PIPE),\n\t\t\t xfer_buff, size, &bytes_read, BULK_TIMEOUT);\n\n\tkfree(xfer_buff);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (size != bytes_read) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"size != bytes_read %d %d\\n\", size,\n\t\t       bytes_read);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int request_dsp(struct uea_softc *sc)\n{\n\tint ret;\n\tchar *dsp_name;\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\n\t\tif (IS_ISDN(sc))\n\t\t\tdsp_name = DSP4I_FIRMWARE;\n\t\telse\n\t\t\tdsp_name = DSP4P_FIRMWARE;\n\t} else if (UEA_CHIP_VERSION(sc) == ADI930) {\n\t\tif (IS_ISDN(sc))\n\t\t\tdsp_name = DSP9I_FIRMWARE;\n\t\telse\n\t\t\tdsp_name = DSP9P_FIRMWARE;\n\t} else {\n\t\tif (IS_ISDN(sc))\n\t\t\tdsp_name = DSPEI_FIRMWARE;\n\t\telse\n\t\t\tdsp_name = DSPEP_FIRMWARE;\n\t}\n\n\tret = request_firmware(&sc->dsp_firm, dsp_name, &sc->usb_dev->dev);\n\tif (ret < 0) {\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t       \"requesting firmware %s failed with error %d\\n\",\n\t\t\tdsp_name, ret);\n\t\treturn ret;\n\t}\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV)\n\t\tret = check_dsp_e4(sc->dsp_firm->data, sc->dsp_firm->size);\n\telse\n\t\tret = check_dsp_e1(sc->dsp_firm->data, sc->dsp_firm->size);\n\n\tif (ret) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"firmware %s is corrupted\\n\",\n\t\t       dsp_name);\n\t\trelease_firmware(sc->dsp_firm);\n\t\tsc->dsp_firm = NULL;\n\t\treturn -EILSEQ;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void uea_load_page_e1(struct work_struct *work)\n{\n\tstruct uea_softc *sc = container_of(work, struct uea_softc, task);\n\tu16 pageno = sc->pageno;\n\tu16 ovl = sc->ovl;\n\tstruct block_info_e1 bi;\n\n\tconst u8 *p;\n\tu8 pagecount, blockcount;\n\tu16 blockaddr, blocksize;\n\tu32 pageoffset;\n\tint i;\n\n\t \n\tif (ovl == 0 && pageno == 0) {\n\t\trelease_firmware(sc->dsp_firm);\n\t\tsc->dsp_firm = NULL;\n\t}\n\n\tif (sc->dsp_firm == NULL && request_dsp(sc) < 0)\n\t\treturn;\n\n\tp = sc->dsp_firm->data;\n\tpagecount = FW_GET_BYTE(p);\n\tp += 1;\n\n\tif (pageno >= pagecount)\n\t\tgoto bad1;\n\n\tp += 4 * pageno;\n\tpageoffset = get_unaligned_le32(p);\n\n\tif (pageoffset == 0)\n\t\tgoto bad1;\n\n\tp = sc->dsp_firm->data + pageoffset;\n\tblockcount = FW_GET_BYTE(p);\n\tp += 1;\n\n\tuea_dbg(INS_TO_USBDEV(sc),\n\t       \"sending %u blocks for DSP page %u\\n\", blockcount, pageno);\n\n\tbi.wHdr = cpu_to_le16(UEA_BIHDR);\n\tbi.wOvl = cpu_to_le16(ovl);\n\tbi.wOvlOffset = cpu_to_le16(ovl | 0x8000);\n\n\tfor (i = 0; i < blockcount; i++) {\n\t\tblockaddr = get_unaligned_le16(p);\n\t\tp += 2;\n\n\t\tblocksize = get_unaligned_le16(p);\n\t\tp += 2;\n\n\t\tbi.wSize = cpu_to_le16(blocksize);\n\t\tbi.wAddress = cpu_to_le16(blockaddr);\n\t\tbi.wLast = cpu_to_le16((i == blockcount - 1) ? 1 : 0);\n\n\t\t \n\t\tif (uea_idma_write(sc, &bi, E1_BLOCK_INFO_SIZE))\n\t\t\tgoto bad2;\n\n\t\t \n\t\tif (uea_idma_write(sc, p, blocksize))\n\t\t\tgoto bad2;\n\n\t\tp += blocksize;\n\t}\n\n\treturn;\n\nbad2:\n\tuea_err(INS_TO_USBDEV(sc), \"sending DSP block %u failed\\n\", i);\n\treturn;\nbad1:\n\tuea_err(INS_TO_USBDEV(sc), \"invalid DSP page %u requested\\n\", pageno);\n}\n\nstatic void __uea_load_page_e4(struct uea_softc *sc, u8 pageno, int boot)\n{\n\tstruct block_info_e4 bi;\n\tstruct block_index *blockidx;\n\tstruct l1_code *p = (struct l1_code *) sc->dsp_firm->data;\n\tu8 blockno = p->page_number_to_block_index[pageno];\n\n\tbi.wHdr = cpu_to_be16(UEA_BIHDR);\n\tbi.bBootPage = boot;\n\tbi.bPageNumber = pageno;\n\tbi.wReserved = cpu_to_be16(UEA_RESERVED);\n\n\tdo {\n\t\tconst u8 *blockoffset;\n\t\tunsigned int blocksize;\n\n\t\tblockidx = &p->page_header[blockno];\n\t\tblocksize = E4_PAGE_BYTES(blockidx->PageSize);\n\t\tblockoffset = sc->dsp_firm->data + le32_to_cpu(\n\t\t\t\t\t\t\tblockidx->PageOffset);\n\n\t\tbi.dwSize = cpu_to_be32(blocksize);\n\t\tbi.dwAddress = cpu_to_be32(le32_to_cpu(blockidx->PageAddress));\n\n\t\tuea_dbg(INS_TO_USBDEV(sc),\n\t\t\t\"sending block %u for DSP page \"\n\t\t\t\"%u size %u address %x\\n\",\n\t\t\tblockno, pageno, blocksize,\n\t\t\tle32_to_cpu(blockidx->PageAddress));\n\n\t\t \n\t\tif (uea_idma_write(sc, &bi, E4_BLOCK_INFO_SIZE))\n\t\t\tgoto bad;\n\n\t\t \n\t\tif (uea_idma_write(sc, blockoffset, blocksize))\n\t\t\tgoto bad;\n\n\t\tblockno++;\n\t} while (blockidx->NotLastBlock);\n\n\treturn;\n\nbad:\n\tuea_err(INS_TO_USBDEV(sc), \"sending DSP block %u failed\\n\", blockno);\n\treturn;\n}\n\nstatic void uea_load_page_e4(struct work_struct *work)\n{\n\tstruct uea_softc *sc = container_of(work, struct uea_softc, task);\n\tu8 pageno = sc->pageno;\n\tint i;\n\tstruct block_info_e4 bi;\n\tstruct l1_code *p;\n\n\tuea_dbg(INS_TO_USBDEV(sc), \"sending DSP page %u\\n\", pageno);\n\n\t \n\tif (pageno == 0) {\n\t\trelease_firmware(sc->dsp_firm);\n\t\tsc->dsp_firm = NULL;\n\t}\n\n\tif (sc->dsp_firm == NULL && request_dsp(sc) < 0)\n\t\treturn;\n\n\tp = (struct l1_code *) sc->dsp_firm->data;\n\tif (pageno >= le16_to_cpu(p->page_header[0].PageNumber)) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"invalid DSP \"\n\t\t\t\t\t\t\"page %u requested\\n\", pageno);\n\t\treturn;\n\t}\n\n\tif (pageno != 0) {\n\t\t__uea_load_page_e4(sc, pageno, 0);\n\t\treturn;\n\t}\n\n\tuea_dbg(INS_TO_USBDEV(sc),\n\t       \"sending Main DSP page %u\\n\", p->page_header[0].PageNumber);\n\n\tfor (i = 0; i < le16_to_cpu(p->page_header[0].PageNumber); i++) {\n\t\tif (E4_IS_BOOT_PAGE(p->page_header[i].PageSize))\n\t\t\t__uea_load_page_e4(sc, i, 1);\n\t}\n\n\tuea_dbg(INS_TO_USBDEV(sc) , \"sending start bi\\n\");\n\n\tbi.wHdr = cpu_to_be16(UEA_BIHDR);\n\tbi.bBootPage = 0;\n\tbi.bPageNumber = 0xff;\n\tbi.wReserved = cpu_to_be16(UEA_RESERVED);\n\tbi.dwSize = cpu_to_be32(E4_PAGE_BYTES(p->page_header[0].PageSize));\n\tbi.dwAddress = cpu_to_be32(le32_to_cpu(p->page_header[0].PageAddress));\n\n\t \n\tif (uea_idma_write(sc, &bi, E4_BLOCK_INFO_SIZE))\n\t\tuea_err(INS_TO_USBDEV(sc), \"sending DSP start bi failed\\n\");\n}\n\nstatic inline void wake_up_cmv_ack(struct uea_softc *sc)\n{\n\tBUG_ON(sc->cmv_ack);\n\tsc->cmv_ack = 1;\n\twake_up(&sc->sync_q);\n}\n\nstatic inline int wait_cmv_ack(struct uea_softc *sc)\n{\n\tint ret = uea_wait(sc, sc->cmv_ack , ACK_TIMEOUT);\n\n\tsc->cmv_ack = 0;\n\n\tuea_dbg(INS_TO_USBDEV(sc), \"wait_event_timeout : %d ms\\n\",\n\t\t\tjiffies_to_msecs(ret));\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn (ret == 0) ? -ETIMEDOUT : 0;\n}\n\n#define UCDC_SEND_ENCAPSULATED_COMMAND 0x00\n\nstatic int uea_request(struct uea_softc *sc,\n\t\tu16 value, u16 index, u16 size, const void *data)\n{\n\tu8 *xfer_buff;\n\tint ret = -ENOMEM;\n\n\txfer_buff = kmemdup(data, size, GFP_KERNEL);\n\tif (!xfer_buff) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"can't allocate xfer_buff\\n\");\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(sc->usb_dev, usb_sndctrlpipe(sc->usb_dev, 0),\n\t\t\t      UCDC_SEND_ENCAPSULATED_COMMAND,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t      value, index, xfer_buff, size, CTRL_TIMEOUT);\n\n\tkfree(xfer_buff);\n\tif (ret < 0) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"usb_control_msg error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ret != size) {\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t       \"usb_control_msg send only %d bytes (instead of %d)\\n\",\n\t\t       ret, size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int uea_cmv_e1(struct uea_softc *sc,\n\t\tu8 function, u32 address, u16 offset, u32 data)\n{\n\tstruct cmv_e1 cmv;\n\tint ret;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tuea_vdbg(INS_TO_USBDEV(sc), \"Function : %d-%d, Address : %c%c%c%c, \"\n\t\t\t\"offset : 0x%04x, data : 0x%08x\\n\",\n\t\t\tE1_FUNCTION_TYPE(function),\n\t\t\tE1_FUNCTION_SUBTYPE(function),\n\t\t\tE1_GETSA1(address), E1_GETSA2(address),\n\t\t\tE1_GETSA3(address),\n\t\t\tE1_GETSA4(address), offset, data);\n\n\t \n\tsc->cmv_dsc.e1.function = function | 0x2;\n\tsc->cmv_dsc.e1.idx++;\n\tsc->cmv_dsc.e1.address = address;\n\tsc->cmv_dsc.e1.offset = offset;\n\n\tcmv.wPreamble = cpu_to_le16(E1_PREAMBLE);\n\tcmv.bDirection = E1_HOSTTOMODEM;\n\tcmv.bFunction = function;\n\tcmv.wIndex = cpu_to_le16(sc->cmv_dsc.e1.idx);\n\tput_unaligned_le32(address, &cmv.dwSymbolicAddress);\n\tcmv.wOffsetAddress = cpu_to_le16(offset);\n\tput_unaligned_le32(data >> 16 | data << 16, &cmv.dwData);\n\n\tret = uea_request(sc, UEA_E1_SET_BLOCK, UEA_MPTX_START,\n\t\t\t\t\t\t\tsizeof(cmv), &cmv);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = wait_cmv_ack(sc);\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\nstatic int uea_cmv_e4(struct uea_softc *sc,\n\t\tu16 function, u16 group, u16 address, u16 offset, u32 data)\n{\n\tstruct cmv_e4 cmv;\n\tint ret;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tmemset(&cmv, 0, sizeof(cmv));\n\n\tuea_vdbg(INS_TO_USBDEV(sc), \"Function : %d-%d, Group : 0x%04x, \"\n\t\t \"Address : 0x%04x, offset : 0x%04x, data : 0x%08x\\n\",\n\t\t E4_FUNCTION_TYPE(function), E4_FUNCTION_SUBTYPE(function),\n\t\t group, address, offset, data);\n\n\t \n\tsc->cmv_dsc.e4.function = function | (0x1 << 4);\n\tsc->cmv_dsc.e4.offset = offset;\n\tsc->cmv_dsc.e4.address = address;\n\tsc->cmv_dsc.e4.group = group;\n\n\tcmv.wFunction = cpu_to_be16(function);\n\tcmv.wGroup = cpu_to_be16(group);\n\tcmv.wAddress = cpu_to_be16(address);\n\tcmv.wOffset = cpu_to_be16(offset);\n\tcmv.dwData[0] = cpu_to_be32(data);\n\n\tret = uea_request(sc, UEA_E4_SET_BLOCK, UEA_MPTX_START,\n\t\t\t\t\t\t\tsizeof(cmv), &cmv);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = wait_cmv_ack(sc);\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\nstatic inline int uea_read_cmv_e1(struct uea_softc *sc,\n\t\tu32 address, u16 offset, u32 *data)\n{\n\tint ret = uea_cmv_e1(sc, E1_MAKEFUNCTION(E1_MEMACCESS, E1_REQUESTREAD),\n\t\t\t  address, offset, 0);\n\tif (ret < 0)\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t\"reading cmv failed with error %d\\n\", ret);\n\telse\n\t\t*data = sc->data;\n\n\treturn ret;\n}\n\nstatic inline int uea_read_cmv_e4(struct uea_softc *sc,\n\t\tu8 size, u16 group, u16 address, u16 offset, u32 *data)\n{\n\tint ret = uea_cmv_e4(sc, E4_MAKEFUNCTION(E4_MEMACCESS,\n\t\t\t\t\t\t\tE4_REQUESTREAD, size),\n\t\t\t  group, address, offset, 0);\n\tif (ret < 0)\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t\"reading cmv failed with error %d\\n\", ret);\n\telse {\n\t\t*data = sc->data;\n\t\t \n\t\tif (size > 2)\n\t\t\t*(data + 1) = sc->data1;\n\t}\n\treturn ret;\n}\n\nstatic inline int uea_write_cmv_e1(struct uea_softc *sc,\n\t\tu32 address, u16 offset, u32 data)\n{\n\tint ret = uea_cmv_e1(sc, E1_MAKEFUNCTION(E1_MEMACCESS, E1_REQUESTWRITE),\n\t\t\t  address, offset, data);\n\tif (ret < 0)\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t\"writing cmv failed with error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic inline int uea_write_cmv_e4(struct uea_softc *sc,\n\t\tu8 size, u16 group, u16 address, u16 offset, u32 data)\n{\n\tint ret = uea_cmv_e4(sc, E4_MAKEFUNCTION(E4_MEMACCESS,\n\t\t\t\t\t\t\tE4_REQUESTWRITE, size),\n\t\t\t  group, address, offset, data);\n\tif (ret < 0)\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t\"writing cmv failed with error %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void uea_set_bulk_timeout(struct uea_softc *sc, u32 dsrate)\n{\n\tint ret;\n\tu16 timeout;\n\n\t \n\n\tif (UEA_CHIP_VERSION(sc) == ADI930 ||\n\t    altsetting[sc->modem_index] > 0 ||\n\t    sc->stats.phy.dsrate == dsrate)\n\t\treturn;\n\n\t \n\ttimeout = (dsrate <= 1024*1024) ? 0 : 1;\n\tret = uea_request(sc, UEA_SET_TIMEOUT, timeout, 0, NULL);\n\tuea_info(INS_TO_USBDEV(sc), \"setting new timeout %d%s\\n\",\n\t\t timeout,  ret < 0 ? \" failed\" : \"\");\n\n}\n\n \nstatic int uea_stat_e1(struct uea_softc *sc)\n{\n\tu32 data;\n\tint ret;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tdata = sc->stats.phy.state;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_STAT, 0, &sc->stats.phy.state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (GET_STATUS(sc->stats.phy.state)) {\n\tcase 0:\t\t \n\t\tuea_dbg(INS_TO_USBDEV(sc),\n\t\t       \"modem not yet synchronized\\n\");\n\t\treturn 0;\n\n\tcase 1:\t\t \n\t\tuea_dbg(INS_TO_USBDEV(sc), \"modem initializing\\n\");\n\t\treturn 0;\n\n\tcase 2:\t\t \n\t\tuea_vdbg(INS_TO_USBDEV(sc), \"modem operational\\n\");\n\t\tbreak;\n\n\tcase 3:\t\t \n\t\tuea_info(INS_TO_USBDEV(sc), \"modem synchronization failed\"\n\t\t\t\t\t\" (may be try other cmv/dsp)\\n\");\n\t\treturn -EAGAIN;\n\n\tcase 4 ... 6:\t \n\t\tuea_warn(INS_TO_USBDEV(sc),\n\t\t\t\t\"modem in test mode - not supported\\n\");\n\t\treturn -EAGAIN;\n\n\tcase 7:\t\t \n\t\tuea_info(INS_TO_USBDEV(sc), \"modem in fast-retain mode\\n\");\n\t\treturn 0;\n\tdefault:\n\t\tuea_err(INS_TO_USBDEV(sc), \"modem invalid SW mode %d\\n\",\n\t\t\tGET_STATUS(sc->stats.phy.state));\n\t\treturn -EAGAIN;\n\t}\n\n\tif (GET_STATUS(data) != 2) {\n\t\tuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_OFF, 0, NULL);\n\t\tuea_info(INS_TO_USBDEV(sc), \"modem operational\\n\");\n\n\t\t \n\t\trelease_firmware(sc->dsp_firm);\n\t\tsc->dsp_firm = NULL;\n\t}\n\n\t \n\tUPDATE_ATM_SIGNAL(ATM_PHY_SIG_FOUND);\n\n\t \n\twake_up(&sc->sync_q);\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 2, &sc->stats.phy.flags);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.mflags |= sc->stats.phy.flags;\n\n\t \n\tif (sc->stats.phy.flags) {\n\t\tuea_dbg(INS_TO_USBDEV(sc), \"Stat flag = 0x%x\\n\",\n\t\t       sc->stats.phy.flags);\n\t\treturn 0;\n\t}\n\n\tret = uea_read_cmv_e1(sc, E1_SA_RATE, 0, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tuea_set_bulk_timeout(sc, (data >> 16) * 32);\n\tsc->stats.phy.dsrate = (data >> 16) * 32;\n\tsc->stats.phy.usrate = (data & 0xffff) * 32;\n\tUPDATE_ATM_STAT(link_rate, sc->stats.phy.dsrate * 1000 / 424);\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 23, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.dsattenuation = (data & 0xff) / 2;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 47, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.usattenuation = (data & 0xff) / 2;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 25, &sc->stats.phy.dsmargin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 49, &sc->stats.phy.usmargin);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 51, &sc->stats.phy.rxflow);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 52, &sc->stats.phy.txflow);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 54, &sc->stats.phy.dsunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 58, &sc->stats.phy.usunc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 53, &sc->stats.phy.dscorr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = uea_read_cmv_e1(sc, E1_SA_DIAG, 57, &sc->stats.phy.uscorr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_INFO, 8, &sc->stats.phy.vidco);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = uea_read_cmv_e1(sc, E1_SA_INFO, 13, &sc->stats.phy.vidcpe);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int uea_stat_e4(struct uea_softc *sc)\n{\n\tu32 data;\n\tu32 tmp_arr[2];\n\tint ret;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tdata = sc->stats.phy.state;\n\n\t \n\tret = uea_read_cmv_e4(sc, 1, E4_SA_STAT, 0, 0, &sc->stats.phy.state);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (sc->stats.phy.state) {\n\tcase 0x0:\t \n\tcase 0x1:\n\tcase 0x3:\n\tcase 0x4:\n\t\tuea_dbg(INS_TO_USBDEV(sc), \"modem not yet \"\n\t\t\t\t\t\t\"synchronized\\n\");\n\t\treturn 0;\n\tcase 0x5:\t \n\tcase 0x6:\n\tcase 0x9:\n\tcase 0xa:\n\t\tuea_dbg(INS_TO_USBDEV(sc), \"modem initializing\\n\");\n\t\treturn 0;\n\tcase 0x2:\t \n\t\tuea_info(INS_TO_USBDEV(sc), \"modem synchronization \"\n\t\t\t\t\"failed (may be try other cmv/dsp)\\n\");\n\t\treturn -EAGAIN;\n\tcase 0x7:\t \n\t\tbreak;\n\tdefault:\n\t\tuea_warn(INS_TO_USBDEV(sc), \"unknown state: %x\\n\",\n\t\t\t\t\t\tsc->stats.phy.state);\n\t\treturn 0;\n\t}\n\n\tif (data != 7) {\n\t\tuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_OFF, 0, NULL);\n\t\tuea_info(INS_TO_USBDEV(sc), \"modem operational\\n\");\n\n\t\t \n\t\trelease_firmware(sc->dsp_firm);\n\t\tsc->dsp_firm = NULL;\n\t}\n\n\t \n\tUPDATE_ATM_SIGNAL(ATM_PHY_SIG_FOUND);\n\n\t \n\twake_up(&sc->sync_q);\n\n\t \n\t \n\tret = uea_read_cmv_e4(sc, 1, E4_SA_DIAG, 0, 0, &sc->stats.phy.flags);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.mflags |= sc->stats.phy.flags;\n\n\t \n\tif (sc->stats.phy.flags) {\n\t\tuea_dbg(INS_TO_USBDEV(sc), \"Stat flag = 0x%x\\n\",\n\t\t       sc->stats.phy.flags);\n\t\tif (sc->stats.phy.flags & 1)  \n\t\t\treturn -EAGAIN;\n\t\tif (sc->stats.phy.flags & 0x4000)  \n\t\t\treturn -EAGAIN;\n\t\treturn 0;\n\t}\n\n\t \n\tret = uea_read_cmv_e4(sc, 4, E4_SA_RATE, 0, 0, tmp_arr);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata = (tmp_arr[0]) ? tmp_arr[0] : tmp_arr[1];\n\tsc->stats.phy.usrate = data / 1000;\n\n\tret = uea_read_cmv_e4(sc, 4, E4_SA_RATE, 1, 0, tmp_arr);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata = (tmp_arr[0]) ? tmp_arr[0] : tmp_arr[1];\n\tuea_set_bulk_timeout(sc, data / 1000);\n\tsc->stats.phy.dsrate = data / 1000;\n\tUPDATE_ATM_STAT(link_rate, sc->stats.phy.dsrate * 1000 / 424);\n\n\tret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 68, 1, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.dsattenuation = data / 10;\n\n\tret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 69, 1, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.usattenuation = data / 10;\n\n\tret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 68, 3, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.dsmargin = data / 2;\n\n\tret = uea_read_cmv_e4(sc, 1, E4_SA_INFO, 69, 3, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tsc->stats.phy.usmargin = data / 10;\n\n\treturn 0;\n}\n\nstatic void cmvs_file_name(struct uea_softc *sc, char *const cmv_name, int ver)\n{\n\tchar file_arr[] = \"CMVxy.bin\";\n\tchar *file;\n\n\tkernel_param_lock(THIS_MODULE);\n\t \n\tif (cmv_file[sc->modem_index] == NULL) {\n\t\tif (UEA_CHIP_VERSION(sc) == ADI930)\n\t\t\tfile_arr[3] = '9';\n\t\telse if (UEA_CHIP_VERSION(sc) == EAGLE_IV)\n\t\t\tfile_arr[3] = '4';\n\t\telse\n\t\t\tfile_arr[3] = 'e';\n\n\t\tfile_arr[4] = IS_ISDN(sc) ? 'i' : 'p';\n\t\tfile = file_arr;\n\t} else\n\t\tfile = cmv_file[sc->modem_index];\n\n\tstrcpy(cmv_name, FW_DIR);\n\tstrlcat(cmv_name, file, UEA_FW_NAME_MAX);\n\tif (ver == 2)\n\t\tstrlcat(cmv_name, \".v2\", UEA_FW_NAME_MAX);\n\tkernel_param_unlock(THIS_MODULE);\n}\n\nstatic int request_cmvs_old(struct uea_softc *sc,\n\t\t void **cmvs, const struct firmware **fw)\n{\n\tint ret, size;\n\tu8 *data;\n\tchar cmv_name[UEA_FW_NAME_MAX];  \n\n\tcmvs_file_name(sc, cmv_name, 1);\n\tret = request_firmware(fw, cmv_name, &sc->usb_dev->dev);\n\tif (ret < 0) {\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t       \"requesting firmware %s failed with error %d\\n\",\n\t\t       cmv_name, ret);\n\t\treturn ret;\n\t}\n\n\tdata = (u8 *) (*fw)->data;\n\tsize = (*fw)->size;\n\tif (size < 1)\n\t\tgoto err_fw_corrupted;\n\n\tif (size != *data * sizeof(struct uea_cmvs_v1) + 1)\n\t\tgoto err_fw_corrupted;\n\n\t*cmvs = (void *)(data + 1);\n\treturn *data;\n\nerr_fw_corrupted:\n\tuea_err(INS_TO_USBDEV(sc), \"firmware %s is corrupted\\n\", cmv_name);\n\trelease_firmware(*fw);\n\treturn -EILSEQ;\n}\n\nstatic int request_cmvs(struct uea_softc *sc,\n\t\t void **cmvs, const struct firmware **fw, int *ver)\n{\n\tint ret, size;\n\tu32 crc;\n\tu8 *data;\n\tchar cmv_name[UEA_FW_NAME_MAX];  \n\n\tcmvs_file_name(sc, cmv_name, 2);\n\tret = request_firmware(fw, cmv_name, &sc->usb_dev->dev);\n\tif (ret < 0) {\n\t\t \n\t\tif (*ver == 1) {\n\t\t\tuea_warn(INS_TO_USBDEV(sc), \"requesting \"\n\t\t\t\t\t\t\t\"firmware %s failed, \"\n\t\t\t\t\"try to get older cmvs\\n\", cmv_name);\n\t\t\treturn request_cmvs_old(sc, cmvs, fw);\n\t\t}\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t       \"requesting firmware %s failed with error %d\\n\",\n\t\t       cmv_name, ret);\n\t\treturn ret;\n\t}\n\n\tsize = (*fw)->size;\n\tdata = (u8 *) (*fw)->data;\n\tif (size < 4 || strncmp(data, \"cmv2\", 4) != 0) {\n\t\tif (*ver == 1) {\n\t\t\tuea_warn(INS_TO_USBDEV(sc), \"firmware %s is corrupted,\"\n\t\t\t\t\" try to get older cmvs\\n\", cmv_name);\n\t\t\trelease_firmware(*fw);\n\t\t\treturn request_cmvs_old(sc, cmvs, fw);\n\t\t}\n\t\tgoto err_fw_corrupted;\n\t}\n\n\t*ver = 2;\n\n\tdata += 4;\n\tsize -= 4;\n\tif (size < 5)\n\t\tgoto err_fw_corrupted;\n\n\tcrc = get_unaligned_le32(data);\n\tdata += 4;\n\tsize -= 4;\n\tif (crc32_be(0, data, size) != crc)\n\t\tgoto err_fw_corrupted;\n\n\tif (size != *data * sizeof(struct uea_cmvs_v2) + 1)\n\t\tgoto err_fw_corrupted;\n\n\t*cmvs = (void *) (data + 1);\n\treturn *data;\n\nerr_fw_corrupted:\n\tuea_err(INS_TO_USBDEV(sc), \"firmware %s is corrupted\\n\", cmv_name);\n\trelease_firmware(*fw);\n\treturn -EILSEQ;\n}\n\nstatic int uea_send_cmvs_e1(struct uea_softc *sc)\n{\n\tint i, ret, len;\n\tvoid *cmvs_ptr;\n\tconst struct firmware *cmvs_fw;\n\tint ver = 1;  \n\n\t \n\tret = uea_write_cmv_e1(sc, E1_SA_CNTL, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = uea_read_cmv_e1(sc, E1_SA_INFO, 10, &sc->stats.phy.firmid);\n\tif (ret < 0)\n\t\treturn ret;\n\tuea_info(INS_TO_USBDEV(sc), \"ATU-R firmware version : %x\\n\",\n\t\t\tsc->stats.phy.firmid);\n\n\t \n\tret = len = request_cmvs(sc, &cmvs_ptr, &cmvs_fw, &ver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ver == 1) {\n\t\tstruct uea_cmvs_v1 *cmvs_v1 = cmvs_ptr;\n\n\t\tuea_warn(INS_TO_USBDEV(sc), \"use deprecated cmvs version, \"\n\t\t\t\"please update your firmware\\n\");\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = uea_write_cmv_e1(sc,\n\t\t\t\tget_unaligned_le32(&cmvs_v1[i].address),\n\t\t\t\tget_unaligned_le16(&cmvs_v1[i].offset),\n\t\t\t\tget_unaligned_le32(&cmvs_v1[i].data));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else if (ver == 2) {\n\t\tstruct uea_cmvs_v2 *cmvs_v2 = cmvs_ptr;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = uea_write_cmv_e1(sc,\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].address),\n\t\t\t\t(u16) get_unaligned_le32(&cmvs_v2[i].offset),\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].data));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tuea_err(INS_TO_USBDEV(sc), \"bad cmvs version %d\\n\", ver);\n\t\tgoto out;\n\t}\n\n\t \n\tret = uea_write_cmv_e1(sc, E1_SA_CNTL, 0, 2);\n\tuea_vdbg(INS_TO_USBDEV(sc), \"Entering in R-ACT-REQ state\\n\");\n\tuea_info(INS_TO_USBDEV(sc), \"modem started, waiting \"\n\t\t\t\t\t\t\"synchronization...\\n\");\nout:\n\trelease_firmware(cmvs_fw);\n\treturn ret;\n}\n\nstatic int uea_send_cmvs_e4(struct uea_softc *sc)\n{\n\tint i, ret, len;\n\tvoid *cmvs_ptr;\n\tconst struct firmware *cmvs_fw;\n\tint ver = 2;  \n\n\t \n\tret = uea_write_cmv_e4(sc, 1, E4_SA_CNTL, 0, 0, 1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tret = uea_read_cmv_e4(sc, 2, E4_SA_INFO, 55, 0, &sc->stats.phy.firmid);\n\tif (ret < 0)\n\t\treturn ret;\n\tuea_info(INS_TO_USBDEV(sc), \"ATU-R firmware version : %x\\n\",\n\t\t\tsc->stats.phy.firmid);\n\n\n\t \n\tret = len = request_cmvs(sc, &cmvs_ptr, &cmvs_fw, &ver);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (ver == 2) {\n\t\tstruct uea_cmvs_v2 *cmvs_v2 = cmvs_ptr;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tret = uea_write_cmv_e4(sc, 1,\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].group),\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].address),\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].offset),\n\t\t\t\tget_unaligned_le32(&cmvs_v2[i].data));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\t \n\t\tuea_err(INS_TO_USBDEV(sc), \"bad cmvs version %d\\n\", ver);\n\t\tgoto out;\n\t}\n\n\t \n\tret = uea_write_cmv_e4(sc, 1, E4_SA_CNTL, 0, 0, 2);\n\tuea_vdbg(INS_TO_USBDEV(sc), \"Entering in R-ACT-REQ state\\n\");\n\tuea_info(INS_TO_USBDEV(sc), \"modem started, waiting \"\n\t\t\t\t\t\t\"synchronization...\\n\");\nout:\n\trelease_firmware(cmvs_fw);\n\treturn ret;\n}\n\n \n\nstatic int uea_start_reset(struct uea_softc *sc)\n{\n\tu16 zero = 0;\t \n\tint ret;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tuea_info(INS_TO_USBDEV(sc), \"(re)booting started\\n\");\n\n\t \n\tsc->booting = 1;\n\t \n\tsc->cmv_ack = 0;\n\tUPDATE_ATM_SIGNAL(ATM_PHY_SIG_LOST);\n\n\t \n\tmemset(&sc->stats, 0, sizeof(struct uea_stats));\n\n\t \n\tuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_ON, 0, NULL);\n\tuea_request(sc, UEA_SET_MODE, UEA_BOOT_IDMA, 0, NULL);\n\n\t \n\tuea_request(sc, UEA_SET_MODE, UEA_START_RESET, 0, NULL);\n\n\t \n\tret = uea_wait(sc, 0, msecs_to_jiffies(100));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tuea_request(sc, UEA_SET_MODE, UEA_END_RESET, 0, NULL);\n\n\tif (UEA_CHIP_VERSION(sc) != EAGLE_IV) {\n\t\t \n\t\tuea_request(sc, UEA_SET_2183_DATA, UEA_MPTX_MAILBOX, 2, &zero);\n\t\tuea_request(sc, UEA_SET_2183_DATA, UEA_MPRX_MAILBOX, 2, &zero);\n\t\tuea_request(sc, UEA_SET_2183_DATA, UEA_SWAP_MAILBOX, 2, &zero);\n\t}\n\n\tret = uea_wait(sc, 0, msecs_to_jiffies(1000));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV)\n\t\tsc->cmv_dsc.e4.function = E4_MAKEFUNCTION(E4_ADSLDIRECTIVE,\n\t\t\t\t\t\t\tE4_MODEMREADY, 1);\n\telse\n\t\tsc->cmv_dsc.e1.function = E1_MAKEFUNCTION(E1_ADSLDIRECTIVE,\n\t\t\t\t\t\t\tE1_MODEMREADY);\n\n\t \n\tsc->booting = 0;\n\n\t \n\tsc->pageno = 0;\n\tsc->ovl = 0;\n\tschedule_work(&sc->task);\n\n\t \n\tret = wait_cmv_ack(sc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tuea_vdbg(INS_TO_USBDEV(sc), \"Ready CMV received\\n\");\n\n\tret = sc->send_cmvs(sc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsc->reset = 0;\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\n \n\nstatic int uea_kthread(void *data)\n{\n\tstruct uea_softc *sc = data;\n\tint ret = -EAGAIN;\n\n\tset_freezable();\n\tuea_enters(INS_TO_USBDEV(sc));\n\twhile (!kthread_should_stop()) {\n\t\tif (ret < 0 || sc->reset)\n\t\t\tret = uea_start_reset(sc);\n\t\tif (!ret)\n\t\t\tret = sc->stat(sc);\n\t\tif (ret != -EAGAIN)\n\t\t\tuea_wait(sc, 0, msecs_to_jiffies(1000));\n\t\ttry_to_freeze();\n\t}\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\n \nstatic int load_XILINX_firmware(struct uea_softc *sc)\n{\n\tconst struct firmware *fw_entry;\n\tint ret, size, u, ln;\n\tconst u8 *pfw;\n\tu8 value;\n\tchar *fw_name = FPGA930_FIRMWARE;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\n\tret = request_firmware(&fw_entry, fw_name, &sc->usb_dev->dev);\n\tif (ret) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"firmware %s is not available\\n\",\n\t\t       fw_name);\n\t\tgoto err0;\n\t}\n\n\tpfw = fw_entry->data;\n\tsize = fw_entry->size;\n\tif (size != 0x577B) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"firmware %s is corrupted\\n\",\n\t\t       fw_name);\n\t\tret = -EILSEQ;\n\t\tgoto err1;\n\t}\n\tfor (u = 0; u < size; u += ln) {\n\t\tln = min(size - u, 64);\n\t\tret = uea_request(sc, 0xe, 0, ln, pfw + u);\n\t\tif (ret < 0) {\n\t\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t       \"elsa download data failed (%d)\\n\", ret);\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\t \n\tret = uea_request(sc, 0xe, 1, 0, NULL);\n\tif (ret < 0) {\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t\t\t\"elsa download data failed (%d)\\n\", ret);\n\t\tgoto err1;\n\t}\n\n\t \n\tvalue = 0;\n\tret = uea_send_modem_cmd(sc->usb_dev, 0xe, 1, &value);\n\tif (ret < 0)\n\t\tuea_err(sc->usb_dev, \"elsa de-assert failed with error\"\n\t\t\t\t\t\t\t\t\" %d\\n\", ret);\n\nerr1:\n\trelease_firmware(fw_entry);\nerr0:\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\n \nstatic void uea_dispatch_cmv_e1(struct uea_softc *sc, struct intr_pkt *intr)\n{\n\tstruct cmv_dsc_e1 *dsc = &sc->cmv_dsc.e1;\n\tstruct cmv_e1 *cmv = &intr->u.e1.s2.cmv;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tif (le16_to_cpu(cmv->wPreamble) != E1_PREAMBLE)\n\t\tgoto bad1;\n\n\tif (cmv->bDirection != E1_MODEMTOHOST)\n\t\tgoto bad1;\n\n\t \n\tif (cmv->bFunction != dsc->function) {\n\t\tif (UEA_CHIP_VERSION(sc) == ADI930\n\t\t\t\t&& cmv->bFunction ==  E1_MAKEFUNCTION(2, 2)) {\n\t\t\tcmv->wIndex = cpu_to_le16(dsc->idx);\n\t\t\tput_unaligned_le32(dsc->address,\n\t\t\t\t\t\t&cmv->dwSymbolicAddress);\n\t\t\tcmv->wOffsetAddress = cpu_to_le16(dsc->offset);\n\t\t} else\n\t\t\tgoto bad2;\n\t}\n\n\tif (cmv->bFunction == E1_MAKEFUNCTION(E1_ADSLDIRECTIVE,\n\t\t\t\t\t\t\tE1_MODEMREADY)) {\n\t\twake_up_cmv_ack(sc);\n\t\tuea_leaves(INS_TO_USBDEV(sc));\n\t\treturn;\n\t}\n\n\t \n\tif (le16_to_cpu(cmv->wIndex) != dsc->idx ||\n\t    get_unaligned_le32(&cmv->dwSymbolicAddress) != dsc->address ||\n\t    le16_to_cpu(cmv->wOffsetAddress) != dsc->offset)\n\t\tgoto bad2;\n\n\tsc->data = get_unaligned_le32(&cmv->dwData);\n\tsc->data = sc->data << 16 | sc->data >> 16;\n\n\twake_up_cmv_ack(sc);\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn;\n\nbad2:\n\tuea_err(INS_TO_USBDEV(sc), \"unexpected cmv received, \"\n\t\t\t\"Function : %d, Subfunction : %d\\n\",\n\t\t\tE1_FUNCTION_TYPE(cmv->bFunction),\n\t\t\tE1_FUNCTION_SUBTYPE(cmv->bFunction));\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn;\n\nbad1:\n\tuea_err(INS_TO_USBDEV(sc), \"invalid cmv received, \"\n\t\t\t\"wPreamble %d, bDirection %d\\n\",\n\t\t\tle16_to_cpu(cmv->wPreamble), cmv->bDirection);\n\tuea_leaves(INS_TO_USBDEV(sc));\n}\n\n \nstatic void uea_dispatch_cmv_e4(struct uea_softc *sc, struct intr_pkt *intr)\n{\n\tstruct cmv_dsc_e4 *dsc = &sc->cmv_dsc.e4;\n\tstruct cmv_e4 *cmv = &intr->u.e4.s2.cmv;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\tuea_dbg(INS_TO_USBDEV(sc), \"cmv %x %x %x %x %x %x\\n\",\n\t\tbe16_to_cpu(cmv->wGroup), be16_to_cpu(cmv->wFunction),\n\t\tbe16_to_cpu(cmv->wOffset), be16_to_cpu(cmv->wAddress),\n\t\tbe32_to_cpu(cmv->dwData[0]), be32_to_cpu(cmv->dwData[1]));\n\n\tif (be16_to_cpu(cmv->wFunction) != dsc->function)\n\t\tgoto bad2;\n\n\tif (be16_to_cpu(cmv->wFunction) == E4_MAKEFUNCTION(E4_ADSLDIRECTIVE,\n\t\t\t\t\t\tE4_MODEMREADY, 1)) {\n\t\twake_up_cmv_ack(sc);\n\t\tuea_leaves(INS_TO_USBDEV(sc));\n\t\treturn;\n\t}\n\n\t \n\tif (be16_to_cpu(cmv->wOffset) != dsc->offset ||\n\t    be16_to_cpu(cmv->wGroup) != dsc->group ||\n\t    be16_to_cpu(cmv->wAddress) != dsc->address)\n\t\tgoto bad2;\n\n\tsc->data = be32_to_cpu(cmv->dwData[0]);\n\tsc->data1 = be32_to_cpu(cmv->dwData[1]);\n\twake_up_cmv_ack(sc);\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn;\n\nbad2:\n\tuea_err(INS_TO_USBDEV(sc), \"unexpected cmv received, \"\n\t\t\t\"Function : %d, Subfunction : %d\\n\",\n\t\t\tE4_FUNCTION_TYPE(cmv->wFunction),\n\t\t\tE4_FUNCTION_SUBTYPE(cmv->wFunction));\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn;\n}\n\nstatic void uea_schedule_load_page_e1(struct uea_softc *sc,\n\t\t\t\t\t\tstruct intr_pkt *intr)\n{\n\tsc->pageno = intr->e1_bSwapPageNo;\n\tsc->ovl = intr->e1_bOvl >> 4 | intr->e1_bOvl << 4;\n\tschedule_work(&sc->task);\n}\n\nstatic void uea_schedule_load_page_e4(struct uea_softc *sc,\n\t\t\t\t\t\tstruct intr_pkt *intr)\n{\n\tsc->pageno = intr->e4_bSwapPageNo;\n\tschedule_work(&sc->task);\n}\n\n \nstatic void uea_intr(struct urb *urb)\n{\n\tstruct uea_softc *sc = urb->context;\n\tstruct intr_pkt *intr = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\n\tif (unlikely(status < 0)) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"uea_intr() failed with %d\\n\",\n\t\t       status);\n\t\treturn;\n\t}\n\n\t \n\tif (intr->bType != 0x08 || sc->booting) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"wrong interrupt\\n\");\n\t\tgoto resubmit;\n\t}\n\n\tswitch (le16_to_cpu(intr->wInterrupt)) {\n\tcase INT_LOADSWAPPAGE:\n\t\tsc->schedule_load_page(sc, intr);\n\t\tbreak;\n\n\tcase INT_INCOMINGCMV:\n\t\tsc->dispatch_cmv(sc, intr);\n\t\tbreak;\n\n\tdefault:\n\t\tuea_err(INS_TO_USBDEV(sc), \"unknown interrupt %u\\n\",\n\t\t       le16_to_cpu(intr->wInterrupt));\n\t}\n\nresubmit:\n\tusb_submit_urb(sc->urb_int, GFP_ATOMIC);\n}\n\n \nstatic int uea_boot(struct uea_softc *sc, struct usb_interface *intf)\n{\n\tstruct intr_pkt *intr;\n\tint ret = -ENOMEM;\n\tint size;\n\n\tuea_enters(INS_TO_USBDEV(sc));\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\n\t\tsize = E4_INTR_PKT_SIZE;\n\t\tsc->dispatch_cmv = uea_dispatch_cmv_e4;\n\t\tsc->schedule_load_page = uea_schedule_load_page_e4;\n\t\tsc->stat = uea_stat_e4;\n\t\tsc->send_cmvs = uea_send_cmvs_e4;\n\t\tINIT_WORK(&sc->task, uea_load_page_e4);\n\t} else {\n\t\tsize = E1_INTR_PKT_SIZE;\n\t\tsc->dispatch_cmv = uea_dispatch_cmv_e1;\n\t\tsc->schedule_load_page = uea_schedule_load_page_e1;\n\t\tsc->stat = uea_stat_e1;\n\t\tsc->send_cmvs = uea_send_cmvs_e1;\n\t\tINIT_WORK(&sc->task, uea_load_page_e1);\n\t}\n\n\tinit_waitqueue_head(&sc->sync_q);\n\n\tif (UEA_CHIP_VERSION(sc) == ADI930)\n\t\tload_XILINX_firmware(sc);\n\n\tif (intf->cur_altsetting->desc.bNumEndpoints < 1) {\n\t\tret = -ENODEV;\n\t\tgoto err0;\n\t}\n\n\tintr = kmalloc(size, GFP_KERNEL);\n\tif (!intr)\n\t\tgoto err0;\n\n\tsc->urb_int = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!sc->urb_int)\n\t\tgoto err1;\n\n\tusb_fill_int_urb(sc->urb_int, sc->usb_dev,\n\t\t\t usb_rcvintpipe(sc->usb_dev, UEA_INTR_PIPE),\n\t\t\t intr, size, uea_intr, sc,\n\t\t\t intf->cur_altsetting->endpoint[0].desc.bInterval);\n\n\tret = usb_submit_urb(sc->urb_int, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tuea_err(INS_TO_USBDEV(sc),\n\t\t       \"urb submission failed with error %d\\n\", ret);\n\t\tgoto err1;\n\t}\n\n\t \n\tsc->kthread = kthread_create(uea_kthread, sc, \"ueagle-atm\");\n\tif (IS_ERR(sc->kthread)) {\n\t\tuea_err(INS_TO_USBDEV(sc), \"failed to create thread\\n\");\n\t\tret = PTR_ERR(sc->kthread);\n\t\tgoto err2;\n\t}\n\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn 0;\n\nerr2:\n\tusb_kill_urb(sc->urb_int);\nerr1:\n\tusb_free_urb(sc->urb_int);\n\tsc->urb_int = NULL;\n\tkfree(intr);\nerr0:\n\tuea_leaves(INS_TO_USBDEV(sc));\n\treturn ret;\n}\n\n \nstatic void uea_stop(struct uea_softc *sc)\n{\n\tint ret;\n\tuea_enters(INS_TO_USBDEV(sc));\n\tret = kthread_stop(sc->kthread);\n\tuea_dbg(INS_TO_USBDEV(sc), \"kthread finish with status %d\\n\", ret);\n\n\tuea_request(sc, UEA_SET_MODE, UEA_LOOPBACK_ON, 0, NULL);\n\n\tusb_kill_urb(sc->urb_int);\n\tkfree(sc->urb_int->transfer_buffer);\n\tusb_free_urb(sc->urb_int);\n\n\t \n\tflush_work(&sc->task);\n\n\trelease_firmware(sc->dsp_firm);\n\tuea_leaves(INS_TO_USBDEV(sc));\n}\n\n \nstatic struct uea_softc *dev_to_uea(struct device *dev)\n{\n\tstruct usb_interface *intf;\n\tstruct usbatm_data *usbatm;\n\n\tintf = to_usb_interface(dev);\n\tif (!intf)\n\t\treturn NULL;\n\n\tusbatm = usb_get_intfdata(intf);\n\tif (!usbatm)\n\t\treturn NULL;\n\n\treturn usbatm->driver_data;\n}\n\nstatic ssize_t stat_status_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint ret = -ENODEV;\n\tstruct uea_softc *sc;\n\n\tmutex_lock(&uea_mutex);\n\tsc = dev_to_uea(dev);\n\tif (!sc)\n\t\tgoto out;\n\tret = snprintf(buf, 10, \"%08x\\n\", sc->stats.phy.state);\nout:\n\tmutex_unlock(&uea_mutex);\n\treturn ret;\n}\n\nstatic ssize_t stat_status_store(struct device *dev, struct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tint ret = -ENODEV;\n\tstruct uea_softc *sc;\n\n\tmutex_lock(&uea_mutex);\n\tsc = dev_to_uea(dev);\n\tif (!sc)\n\t\tgoto out;\n\tsc->reset = 1;\n\tret = count;\nout:\n\tmutex_unlock(&uea_mutex);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RW(stat_status);\n\nstatic ssize_t stat_human_status_show(struct device *dev,\n\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tint ret = -ENODEV;\n\tint modem_state;\n\tstruct uea_softc *sc;\n\n\tmutex_lock(&uea_mutex);\n\tsc = dev_to_uea(dev);\n\tif (!sc)\n\t\tgoto out;\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\n\t\tswitch (sc->stats.phy.state) {\n\t\tcase 0x0:\t \n\t\tcase 0x1:\n\t\tcase 0x3:\n\t\tcase 0x4:\n\t\t\tmodem_state = 0;\n\t\t\tbreak;\n\t\tcase 0x5:\t \n\t\tcase 0x6:\n\t\tcase 0x9:\n\t\tcase 0xa:\n\t\t\tmodem_state = 1;\n\t\t\tbreak;\n\t\tcase 0x7:\t \n\t\t\tmodem_state = 2;\n\t\t\tbreak;\n\t\tcase 0x2:\t \n\t\t\tmodem_state = 3;\n\t\t\tbreak;\n\t\tdefault:\t \n\t\t\tmodem_state = 4;\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmodem_state = GET_STATUS(sc->stats.phy.state);\n\n\tswitch (modem_state) {\n\tcase 0:\n\t\tret = sprintf(buf, \"Modem is booting\\n\");\n\t\tbreak;\n\tcase 1:\n\t\tret = sprintf(buf, \"Modem is initializing\\n\");\n\t\tbreak;\n\tcase 2:\n\t\tret = sprintf(buf, \"Modem is operational\\n\");\n\t\tbreak;\n\tcase 3:\n\t\tret = sprintf(buf, \"Modem synchronization failed\\n\");\n\t\tbreak;\n\tdefault:\n\t\tret = sprintf(buf, \"Modem state is unknown\\n\");\n\t\tbreak;\n\t}\nout:\n\tmutex_unlock(&uea_mutex);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(stat_human_status);\n\nstatic ssize_t stat_delin_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tint ret = -ENODEV;\n\tstruct uea_softc *sc;\n\tchar *delin = \"GOOD\";\n\n\tmutex_lock(&uea_mutex);\n\tsc = dev_to_uea(dev);\n\tif (!sc)\n\t\tgoto out;\n\n\tif (UEA_CHIP_VERSION(sc) == EAGLE_IV) {\n\t\tif (sc->stats.phy.flags & 0x4000)\n\t\t\tdelin = \"RESET\";\n\t\telse if (sc->stats.phy.flags & 0x0001)\n\t\t\tdelin = \"LOSS\";\n\t} else {\n\t\tif (sc->stats.phy.flags & 0x0C00)\n\t\t\tdelin = \"ERROR\";\n\t\telse if (sc->stats.phy.flags & 0x0030)\n\t\t\tdelin = \"LOSS\";\n\t}\n\n\tret = sprintf(buf, \"%s\\n\", delin);\nout:\n\tmutex_unlock(&uea_mutex);\n\treturn ret;\n}\n\nstatic DEVICE_ATTR_RO(stat_delin);\n\n#define UEA_ATTR(name, reset)\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic ssize_t stat_##name##_show(struct device *dev,\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tint ret = -ENODEV;\t\t\t\t\t\\\n\tstruct uea_softc *sc;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\tmutex_lock(&uea_mutex);\t\t\t\t\t\\\n\tsc = dev_to_uea(dev);\t\t\t\t\t\\\n\tif (!sc)\t\t\t\t\t\t\\\n\t\tgoto out;\t\t\t\t\t\\\n\tret = snprintf(buf, 10, \"%08x\\n\", sc->stats.phy.name);\t\\\n\tif (reset)\t\t\t\t\t\t\\\n\t\tsc->stats.phy.name = 0;\t\t\t\t\\\nout:\t\t\t\t\t\t\t\t\\\n\tmutex_unlock(&uea_mutex);\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(stat_##name)\n\nUEA_ATTR(mflags, 1);\nUEA_ATTR(vidcpe, 0);\nUEA_ATTR(usrate, 0);\nUEA_ATTR(dsrate, 0);\nUEA_ATTR(usattenuation, 0);\nUEA_ATTR(dsattenuation, 0);\nUEA_ATTR(usmargin, 0);\nUEA_ATTR(dsmargin, 0);\nUEA_ATTR(txflow, 0);\nUEA_ATTR(rxflow, 0);\nUEA_ATTR(uscorr, 0);\nUEA_ATTR(dscorr, 0);\nUEA_ATTR(usunc, 0);\nUEA_ATTR(dsunc, 0);\nUEA_ATTR(firmid, 0);\n\n \n\nstatic int uea_getesi(struct uea_softc *sc, u_char *esi)\n{\n\tunsigned char mac_str[2 * ETH_ALEN + 1];\n\tint i;\n\tif (usb_string\n\t    (sc->usb_dev, sc->usb_dev->descriptor.iSerialNumber, mac_str,\n\t     sizeof(mac_str)) != 2 * ETH_ALEN)\n\t\treturn 1;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\tesi[i] = hex_to_bin(mac_str[2 * i]) * 16 +\n\t\t\t hex_to_bin(mac_str[2 * i + 1]);\n\n\treturn 0;\n}\n\n \nstatic int uea_atm_open(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\n{\n\tstruct uea_softc *sc = usbatm->driver_data;\n\n\treturn uea_getesi(sc, atm_dev->esi);\n}\n\nstatic int uea_heavy(struct usbatm_data *usbatm, struct usb_interface *intf)\n{\n\tstruct uea_softc *sc = usbatm->driver_data;\n\n\twait_event_interruptible(sc->sync_q, IS_OPERATIONAL(sc));\n\n\treturn 0;\n\n}\n\nstatic int claim_interface(struct usb_device *usb_dev,\n\t\t\t   struct usbatm_data *usbatm, int ifnum)\n{\n\tint ret;\n\tstruct usb_interface *intf = usb_ifnum_to_if(usb_dev, ifnum);\n\n\tif (!intf) {\n\t\tuea_err(usb_dev, \"interface %d not found\\n\", ifnum);\n\t\treturn -ENODEV;\n\t}\n\n\tret = usb_driver_claim_interface(&uea_driver, intf, usbatm);\n\tif (ret != 0)\n\t\tuea_err(usb_dev, \"can't claim interface %d, error %d\\n\", ifnum,\n\t\t       ret);\n\treturn ret;\n}\n\nstatic struct attribute *uea_attrs[] = {\n\t&dev_attr_stat_status.attr,\n\t&dev_attr_stat_mflags.attr,\n\t&dev_attr_stat_human_status.attr,\n\t&dev_attr_stat_delin.attr,\n\t&dev_attr_stat_vidcpe.attr,\n\t&dev_attr_stat_usrate.attr,\n\t&dev_attr_stat_dsrate.attr,\n\t&dev_attr_stat_usattenuation.attr,\n\t&dev_attr_stat_dsattenuation.attr,\n\t&dev_attr_stat_usmargin.attr,\n\t&dev_attr_stat_dsmargin.attr,\n\t&dev_attr_stat_txflow.attr,\n\t&dev_attr_stat_rxflow.attr,\n\t&dev_attr_stat_uscorr.attr,\n\t&dev_attr_stat_dscorr.attr,\n\t&dev_attr_stat_usunc.attr,\n\t&dev_attr_stat_dsunc.attr,\n\t&dev_attr_stat_firmid.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(uea);\n\nstatic int uea_bind(struct usbatm_data *usbatm, struct usb_interface *intf,\n\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tstruct uea_softc *sc;\n\tint ret, ifnum = intf->altsetting->desc.bInterfaceNumber;\n\tunsigned int alt;\n\n\tuea_enters(usb);\n\n\t \n\tif (ifnum != UEA_INTR_IFACE_NO)\n\t\treturn -ENODEV;\n\n\tusbatm->flags = (sync_wait[modem_index] ? 0 : UDSL_SKIP_HEAVY_INIT);\n\n\t \n\tret = claim_interface(usb, usbatm, UEA_US_IFACE_NO);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (UEA_CHIP_VERSION(id) != ADI930) {\n\t\t \n\t\tret = claim_interface(usb, usbatm, UEA_DS_IFACE_NO);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tsc = kzalloc(sizeof(struct uea_softc), GFP_KERNEL);\n\tif (!sc)\n\t\treturn -ENOMEM;\n\n\tsc->usb_dev = usb;\n\tusbatm->driver_data = sc;\n\tsc->usbatm = usbatm;\n\tsc->modem_index = (modem_index < NB_MODEM) ? modem_index++ : 0;\n\tsc->driver_info = id->driver_info;\n\n\t \n\tif (annex[sc->modem_index] == 1)\n\t\tsc->annex = ANNEXA;\n\telse if (annex[sc->modem_index] == 2)\n\t\tsc->annex = ANNEXB;\n\t \n\telse if (sc->driver_info & AUTO_ANNEX_A)\n\t\tsc->annex = ANNEXA;\n\telse if (sc->driver_info & AUTO_ANNEX_B)\n\t\tsc->annex = ANNEXB;\n\telse\n\t\tsc->annex = (le16_to_cpu\n\t\t(sc->usb_dev->descriptor.bcdDevice) & 0x80) ? ANNEXB : ANNEXA;\n\n\talt = altsetting[sc->modem_index];\n\t \n\tif (UEA_CHIP_VERSION(id) != ADI930 && alt > 0) {\n\t\tif (alt <= 8 &&\n\t\t\tusb_set_interface(usb, UEA_DS_IFACE_NO, alt) == 0) {\n\t\t\tuea_dbg(usb, \"set alternate %u for 2 interface\\n\", alt);\n\t\t\tuea_info(usb, \"using iso mode\\n\");\n\t\t\tusbatm->flags |= UDSL_USE_ISOC | UDSL_IGNORE_EILSEQ;\n\t\t} else {\n\t\t\tuea_err(usb, \"setting alternate %u failed for \"\n\t\t\t\t\t\"2 interface, using bulk mode\\n\", alt);\n\t\t}\n\t}\n\n\tret = uea_boot(sc, intf);\n\tif (ret < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tkfree(sc);\n\treturn ret;\n}\n\nstatic void uea_unbind(struct usbatm_data *usbatm, struct usb_interface *intf)\n{\n\tstruct uea_softc *sc = usbatm->driver_data;\n\n\tuea_stop(sc);\n\tkfree(sc);\n}\n\nstatic struct usbatm_driver uea_usbatm_driver = {\n\t.driver_name = \"ueagle-atm\",\n\t.bind = uea_bind,\n\t.atm_start = uea_atm_open,\n\t.unbind = uea_unbind,\n\t.heavy_init = uea_heavy,\n\t.bulk_in = UEA_BULK_DATA_PIPE,\n\t.bulk_out = UEA_BULK_DATA_PIPE,\n\t.isoc_in = UEA_ISO_DATA_PIPE,\n};\n\nstatic int uea_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tint ret;\n\n\tuea_enters(usb);\n\tuea_info(usb, \"ADSL device founded vid (%#X) pid (%#X) Rev (%#X): %s\\n\",\n\t\tle16_to_cpu(usb->descriptor.idVendor),\n\t\tle16_to_cpu(usb->descriptor.idProduct),\n\t\tle16_to_cpu(usb->descriptor.bcdDevice),\n\t\tchip_name[UEA_CHIP_VERSION(id)]);\n\n\tusb_reset_device(usb);\n\n\tif (UEA_IS_PREFIRM(id))\n\t\treturn uea_load_firmware(usb, UEA_CHIP_VERSION(id));\n\n\tret = usbatm_usb_probe(intf, id, &uea_usbatm_driver);\n\tif (ret == 0) {\n\t\tstruct usbatm_data *usbatm = usb_get_intfdata(intf);\n\t\tstruct uea_softc *sc = usbatm->driver_data;\n\n\t\t \n\t\tUPDATE_ATM_SIGNAL(ATM_PHY_SIG_LOST);\n\n\t\t \n\t\twake_up_process(sc->kthread);\n\t}\n\n\treturn ret;\n}\n\nstatic void uea_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_device *usb = interface_to_usbdev(intf);\n\tint ifnum = intf->altsetting->desc.bInterfaceNumber;\n\tuea_enters(usb);\n\n\t \n\tif (usb->config->desc.bNumInterfaces != 1 && ifnum == 0) {\n\t\tmutex_lock(&uea_mutex);\n\t\tusbatm_usb_disconnect(intf);\n\t\tmutex_unlock(&uea_mutex);\n\t\tuea_info(usb, \"ADSL device removed\\n\");\n\t}\n\n\tuea_leaves(usb);\n}\n\n \nstatic const struct usb_device_id uea_ids[] = {\n\t{USB_DEVICE(ANALOG_VID,\tADI930_PID_PREFIRM),\n\t\t.driver_info = ADI930 | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tADI930_PID_PSTFIRM),\n\t\t.driver_info = ADI930 | PSTFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_I_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_I_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_II_PID_PREFIRM),\n\t\t.driver_info = EAGLE_II | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_II_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_II | PSTFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_IIC_PID_PREFIRM),\n\t\t.driver_info = EAGLE_II | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_IIC_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_II | PSTFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_III_PID_PREFIRM),\n\t\t.driver_info = EAGLE_III | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_III_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_III | PSTFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_IV_PID_PREFIRM),\n\t\t.driver_info = EAGLE_IV | PREFIRM},\n\t{USB_DEVICE(ANALOG_VID,\tEAGLE_IV_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_IV | PSTFIRM},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_I_A_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_I_A_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM | AUTO_ANNEX_A},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_I_B_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_I_B_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM | AUTO_ANNEX_B},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_II_A_PID_PREFIRM),\n\t\t.driver_info = EAGLE_II | PREFIRM},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_II_A_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_II | PSTFIRM | AUTO_ANNEX_A},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_II_B_PID_PREFIRM),\n\t\t.driver_info = EAGLE_II | PREFIRM},\n\t{USB_DEVICE(DEVOLO_VID,\tDEVOLO_EAGLE_II_B_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_II | PSTFIRM | AUTO_ANNEX_B},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_PREFIRM),\n\t\t.driver_info = ADI930 | PREFIRM},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_PSTFIRM),\n\t\t.driver_info = ADI930 | PSTFIRM},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_A_PREFIRM),\n\t\t.driver_info = ADI930 | PREFIRM},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_A_PSTFIRM),\n\t\t.driver_info = ADI930 | PSTFIRM | AUTO_ANNEX_A},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_B_PREFIRM),\n\t\t.driver_info = ADI930 | PREFIRM},\n\t{USB_DEVICE(ELSA_VID,\tELSA_PID_B_PSTFIRM),\n\t\t.driver_info = ADI930 | PSTFIRM | AUTO_ANNEX_B},\n\t{USB_DEVICE(USR_VID,\tMILLER_A_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(USR_VID,\tMILLER_A_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM  | AUTO_ANNEX_A},\n\t{USB_DEVICE(USR_VID,\tMILLER_B_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(USR_VID,\tMILLER_B_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM  | AUTO_ANNEX_B},\n\t{USB_DEVICE(USR_VID,\tHEINEKEN_A_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(USR_VID,\tHEINEKEN_A_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM | AUTO_ANNEX_A},\n\t{USB_DEVICE(USR_VID,\tHEINEKEN_B_PID_PREFIRM),\n\t\t.driver_info = EAGLE_I | PREFIRM},\n\t{USB_DEVICE(USR_VID,\tHEINEKEN_B_PID_PSTFIRM),\n\t\t.driver_info = EAGLE_I | PSTFIRM | AUTO_ANNEX_B},\n\t{}\n};\n\n \nstatic struct usb_driver uea_driver = {\n\t.name = \"ueagle-atm\",\n\t.id_table = uea_ids,\n\t.probe = uea_probe,\n\t.disconnect = uea_disconnect,\n\t.dev_groups = uea_groups,\n};\n\nMODULE_DEVICE_TABLE(usb, uea_ids);\n\nmodule_usb_driver(uea_driver);\n\nMODULE_AUTHOR(\"Damien Bergamini/Matthieu Castet/Stanislaw W. Gruszka\");\nMODULE_DESCRIPTION(\"ADI 930/Eagle USB ADSL Modem driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_FIRMWARE(EAGLE_FIRMWARE);\nMODULE_FIRMWARE(ADI930_FIRMWARE);\nMODULE_FIRMWARE(EAGLE_I_FIRMWARE);\nMODULE_FIRMWARE(EAGLE_II_FIRMWARE);\nMODULE_FIRMWARE(EAGLE_III_FIRMWARE);\nMODULE_FIRMWARE(EAGLE_IV_FIRMWARE);\nMODULE_FIRMWARE(DSP4I_FIRMWARE);\nMODULE_FIRMWARE(DSP4P_FIRMWARE);\nMODULE_FIRMWARE(DSP9I_FIRMWARE);\nMODULE_FIRMWARE(DSP9P_FIRMWARE);\nMODULE_FIRMWARE(DSPEI_FIRMWARE);\nMODULE_FIRMWARE(DSPEP_FIRMWARE);\nMODULE_FIRMWARE(FPGA930_FIRMWARE);\nMODULE_FIRMWARE(CMV4P_FIRMWARE);\nMODULE_FIRMWARE(CMV4PV2_FIRMWARE);\nMODULE_FIRMWARE(CMV4I_FIRMWARE);\nMODULE_FIRMWARE(CMV4IV2_FIRMWARE);\nMODULE_FIRMWARE(CMV9P_FIRMWARE);\nMODULE_FIRMWARE(CMV9PV2_FIRMWARE);\nMODULE_FIRMWARE(CMV9I_FIRMWARE);\nMODULE_FIRMWARE(CMV9IV2_FIRMWARE);\nMODULE_FIRMWARE(CMVEP_FIRMWARE);\nMODULE_FIRMWARE(CMVEPV2_FIRMWARE);\nMODULE_FIRMWARE(CMVEI_FIRMWARE);\nMODULE_FIRMWARE(CMVEIV2_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}