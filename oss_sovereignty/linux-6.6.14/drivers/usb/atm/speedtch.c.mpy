{
  "module_name": "speedtch.c",
  "hash_id": "69e1c8de744fb93b3d340b0cf50e85f44dc14c900a39e0c0c0710c61f9bc76b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/atm/speedtch.c",
  "human_readable_source": "\n \n\n#include <asm/page.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n#include <linux/usb/ch9.h>\n#include <linux/workqueue.h>\n\n#include \"usbatm.h\"\n\n#define DRIVER_AUTHOR\t\"Johan Verrept, Duncan Sands <duncan.sands@free.fr>\"\n#define DRIVER_DESC\t\"Alcatel SpeedTouch USB driver\"\n\nstatic const char speedtch_driver_name[] = \"speedtch\";\n\n#define CTRL_TIMEOUT 2000\t \n#define DATA_TIMEOUT 2000\t \n\n#define OFFSET_7\t0\t\t \n#define OFFSET_b\t1\t\t \n#define OFFSET_d\t9\t\t \n#define OFFSET_e\t13\t\t \n#define OFFSET_f\t14\t\t \n\n#define SIZE_7\t\t1\n#define SIZE_b\t\t8\n#define SIZE_d\t\t4\n#define SIZE_e\t\t1\n#define SIZE_f\t\t1\n\n#define MIN_POLL_DELAY\t\t5000\t \n#define MAX_POLL_DELAY\t\t60000\t \n\n#define RESUBMIT_DELAY\t\t1000\t \n\n#define DEFAULT_BULK_ALTSETTING\t1\n#define DEFAULT_ISOC_ALTSETTING\t3\n#define DEFAULT_DL_512_FIRST\t0\n#define DEFAULT_ENABLE_ISOC\t0\n#define DEFAULT_SW_BUFFERING\t0\n\nstatic unsigned int altsetting = 0;  \nstatic bool dl_512_first = DEFAULT_DL_512_FIRST;\nstatic bool enable_isoc = DEFAULT_ENABLE_ISOC;\nstatic bool sw_buffering = DEFAULT_SW_BUFFERING;\n\n#define DEFAULT_B_MAX_DSL\t8128\n#define DEFAULT_MODEM_MODE\t11\n#define MODEM_OPTION_LENGTH\t16\nstatic const unsigned char DEFAULT_MODEM_OPTION[MODEM_OPTION_LENGTH] = {\n\t0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n};\n\nstatic unsigned int BMaxDSL = DEFAULT_B_MAX_DSL;\nstatic unsigned char ModemMode = DEFAULT_MODEM_MODE;\nstatic unsigned char ModemOption[MODEM_OPTION_LENGTH];\nstatic unsigned int num_ModemOption;\n\nmodule_param(altsetting, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(altsetting,\n\t\t\"Alternative setting for data interface (bulk_default: \"\n\t\t__MODULE_STRING(DEFAULT_BULK_ALTSETTING) \"; isoc_default: \"\n\t\t__MODULE_STRING(DEFAULT_ISOC_ALTSETTING) \")\");\n\nmodule_param(dl_512_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(dl_512_first,\n\t\t \"Read 512 bytes before sending firmware (default: \"\n\t\t __MODULE_STRING(DEFAULT_DL_512_FIRST) \")\");\n\nmodule_param(enable_isoc, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(enable_isoc,\n\t\t\"Use isochronous transfers if available (default: \"\n\t\t__MODULE_STRING(DEFAULT_ENABLE_ISOC) \")\");\n\nmodule_param(sw_buffering, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(sw_buffering,\n\t\t \"Enable software buffering (default: \"\n\t\t __MODULE_STRING(DEFAULT_SW_BUFFERING) \")\");\n\nmodule_param(BMaxDSL, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(BMaxDSL,\n\t\t\"default: \" __MODULE_STRING(DEFAULT_B_MAX_DSL));\n\nmodule_param(ModemMode, byte, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ModemMode,\n\t\t\"default: \" __MODULE_STRING(DEFAULT_MODEM_MODE));\n\nmodule_param_array(ModemOption, byte, &num_ModemOption, S_IRUGO);\nMODULE_PARM_DESC(ModemOption, \"default: 0x10,0x00,0x00,0x00,0x20\");\n\n#define INTERFACE_DATA\t\t1\n#define ENDPOINT_INT\t\t0x81\n#define ENDPOINT_BULK_DATA\t0x07\n#define ENDPOINT_ISOC_DATA\t0x07\n#define ENDPOINT_FIRMWARE\t0x05\n\nstruct speedtch_params {\n\tunsigned int altsetting;\n\tunsigned int BMaxDSL;\n\tunsigned char ModemMode;\n\tunsigned char ModemOption[MODEM_OPTION_LENGTH];\n};\n\nstruct speedtch_instance_data {\n\tstruct usbatm_data *usbatm;\n\n\tstruct speedtch_params params;  \n\n\tstruct timer_list status_check_timer;\n\tstruct work_struct status_check_work;\n\n\tunsigned char last_status;\n\n\tint poll_delay;  \n\n\tstruct timer_list resubmit_timer;\n\tstruct urb *int_urb;\n\tunsigned char int_data[16];\n\n\tunsigned char scratch_buffer[16];\n};\n\n \n\nstatic void speedtch_set_swbuff(struct speedtch_instance_data *instance, int state)\n{\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tint ret;\n\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x32, 0x40, state ? 0x01 : 0x00, 0x00, NULL, 0, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm,\n\t\t\t \"%sabling SW buffering: usb_control_msg returned %d\\n\",\n\t\t\t state ? \"En\" : \"Dis\", ret);\n\telse\n\t\tusb_dbg(usbatm, \"speedtch_set_swbuff: %sbled SW buffering\\n\", state ? \"En\" : \"Dis\");\n}\n\nstatic void speedtch_test_sequence(struct speedtch_instance_data *instance)\n{\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tunsigned char *buf = instance->scratch_buffer;\n\tint ret;\n\n\t \n\tbuf[0] = 0x1c;\n\tbuf[1] = 0x50;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x0b, 0x00, buf, 2, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URB147: %d\\n\", __func__, ret);\n\n\t \n\tbuf[0] = 0x32;\n\tbuf[1] = 0x00;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x02, 0x00, buf, 2, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URB148: %d\\n\", __func__, ret);\n\n\t \n\tbuf[0] = 0x01;\n\tbuf[1] = 0x00;\n\tbuf[2] = 0x01;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x03, 0x00, buf, 3, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URB149: %d\\n\", __func__, ret);\n\n\t \n\tbuf[0] = 0x01;\n\tbuf[1] = 0x00;\n\tbuf[2] = 0x01;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x04, 0x00, buf, 3, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URB150: %d\\n\", __func__, ret);\n\n\t \n\n\t \n\tbuf[0] = instance->params.ModemMode;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x11, 0x00, buf, 1, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URBext1: %d\\n\", __func__, ret);\n\n\t \n\t \n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x14, 0x00,\n\t\t\t      instance->params.ModemOption,\n\t\t\t      MODEM_OPTION_LENGTH, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URBext2: %d\\n\", __func__, ret);\n\n\t \n\tbuf[0] = instance->params.BMaxDSL & 0xff;\n\tbuf[1] = instance->params.BMaxDSL >> 8;\n\tret = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0x40, 0x12, 0x00, buf, 2, CTRL_TIMEOUT);\n\tif (ret < 0)\n\t\tusb_warn(usbatm, \"%s failed on URBext3: %d\\n\", __func__, ret);\n}\n\nstatic int speedtch_upload_firmware(struct speedtch_instance_data *instance,\n\t\t\t\t     const struct firmware *fw1,\n\t\t\t\t     const struct firmware *fw2)\n{\n\tunsigned char *buffer;\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tint actual_length;\n\tint ret = 0;\n\tint offset;\n\n\tusb_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tbuffer = (unsigned char *)__get_free_page(GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tusb_dbg(usbatm, \"%s: no memory for buffer!\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\tif (!usb_ifnum_to_if(usb_dev, 2)) {\n\t\tret = -ENODEV;\n\t\tusb_dbg(usbatm, \"%s: interface not found!\\n\", __func__);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (dl_512_first) {\t \n\t\tret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\n\t\t\t\t   buffer, 0x200, &actual_length, 2000);\n\n\t\tif (ret < 0 && ret != -ETIMEDOUT)\n\t\t\tusb_warn(usbatm, \"%s: read BLOCK0 from modem failed (%d)!\\n\", __func__, ret);\n\t\telse\n\t\t\tusb_dbg(usbatm, \"%s: BLOCK0 downloaded (%d bytes)\\n\", __func__, ret);\n\t}\n\n\t \n\tfor (offset = 0; offset < fw1->size; offset += PAGE_SIZE) {\n\t\tint thislen = min_t(int, PAGE_SIZE, fw1->size - offset);\n\t\tmemcpy(buffer, fw1->data + offset, thislen);\n\n\t\tret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\n\t\t\t\t   buffer, thislen, &actual_length, DATA_TIMEOUT);\n\n\t\tif (ret < 0) {\n\t\t\tusb_err(usbatm, \"%s: write BLOCK1 to modem failed (%d)!\\n\", __func__, ret);\n\t\t\tgoto out_free;\n\t\t}\n\t\tusb_dbg(usbatm, \"%s: BLOCK1 uploaded (%zu bytes)\\n\", __func__, fw1->size);\n\t}\n\n\t \n\n\t \n\tret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\n\t\t\t   buffer, 0x200, &actual_length, DATA_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tusb_err(usbatm, \"%s: read BLOCK2 from modem failed (%d)!\\n\", __func__, ret);\n\t\tgoto out_free;\n\t}\n\tusb_dbg(usbatm, \"%s: BLOCK2 downloaded (%d bytes)\\n\", __func__, actual_length);\n\n\t \n\tfor (offset = 0; offset < fw2->size; offset += PAGE_SIZE) {\n\t\tint thislen = min_t(int, PAGE_SIZE, fw2->size - offset);\n\t\tmemcpy(buffer, fw2->data + offset, thislen);\n\n\t\tret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\n\t\t\t\t   buffer, thislen, &actual_length, DATA_TIMEOUT);\n\n\t\tif (ret < 0) {\n\t\t\tusb_err(usbatm, \"%s: write BLOCK3 to modem failed (%d)!\\n\", __func__, ret);\n\t\t\tgoto out_free;\n\t\t}\n\t}\n\tusb_dbg(usbatm, \"%s: BLOCK3 uploaded (%zu bytes)\\n\", __func__, fw2->size);\n\n\t \n\n\t \n\tret = usb_bulk_msg(usb_dev, usb_rcvbulkpipe(usb_dev, ENDPOINT_FIRMWARE),\n\t\t\t   buffer, 0x200, &actual_length, DATA_TIMEOUT);\n\n\tif (ret < 0) {\n\t\tusb_err(usbatm, \"%s: read BLOCK4 from modem failed (%d)!\\n\", __func__, ret);\n\t\tgoto out_free;\n\t}\n\n\t \n\tusb_dbg(usbatm, \"%s: BLOCK4 downloaded (%d bytes)\\n\", __func__, actual_length);\n\n\t \n\tmsleep_interruptible(1000);\n\n\tif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, instance->params.altsetting)) < 0) {\n\t\tusb_err(usbatm, \"%s: setting interface to %d failed (%d)!\\n\", __func__, instance->params.altsetting, ret);\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (sw_buffering)\n\t\tspeedtch_set_swbuff(instance, 1);\n\n\t \n\tspeedtch_test_sequence(instance);\n\n\tret = 0;\n\nout_free:\n\tfree_page((unsigned long)buffer);\nout:\n\treturn ret;\n}\n\nstatic int speedtch_find_firmware(struct usbatm_data *usbatm, struct usb_interface *intf,\n\t\t\t\t  int phase, const struct firmware **fw_p)\n{\n\tstruct device *dev = &intf->dev;\n\tconst u16 bcdDevice = le16_to_cpu(interface_to_usbdev(intf)->descriptor.bcdDevice);\n\tconst u8 major_revision = bcdDevice >> 8;\n\tconst u8 minor_revision = bcdDevice & 0xff;\n\tchar buf[24];\n\n\tsprintf(buf, \"speedtch-%d.bin.%x.%02x\", phase, major_revision, minor_revision);\n\tusb_dbg(usbatm, \"%s: looking for %s\\n\", __func__, buf);\n\n\tif (request_firmware(fw_p, buf, dev)) {\n\t\tsprintf(buf, \"speedtch-%d.bin.%x\", phase, major_revision);\n\t\tusb_dbg(usbatm, \"%s: looking for %s\\n\", __func__, buf);\n\n\t\tif (request_firmware(fw_p, buf, dev)) {\n\t\t\tsprintf(buf, \"speedtch-%d.bin\", phase);\n\t\t\tusb_dbg(usbatm, \"%s: looking for %s\\n\", __func__, buf);\n\n\t\t\tif (request_firmware(fw_p, buf, dev)) {\n\t\t\t\tusb_err(usbatm, \"%s: no stage %d firmware found!\\n\", __func__, phase);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_info(usbatm, \"found stage %d firmware %s\\n\", phase, buf);\n\n\treturn 0;\n}\n\nstatic int speedtch_heavy_init(struct usbatm_data *usbatm, struct usb_interface *intf)\n{\n\tconst struct firmware *fw1, *fw2;\n\tstruct speedtch_instance_data *instance = usbatm->driver_data;\n\tint ret;\n\n\tif ((ret = speedtch_find_firmware(usbatm, intf, 1, &fw1)) < 0)\n\t\treturn ret;\n\n\tif ((ret = speedtch_find_firmware(usbatm, intf, 2, &fw2)) < 0) {\n\t\trelease_firmware(fw1);\n\t\treturn ret;\n\t}\n\n\tif ((ret = speedtch_upload_firmware(instance, fw1, fw2)) < 0)\n\t\tusb_err(usbatm, \"%s: firmware upload failed (%d)!\\n\", __func__, ret);\n\n\trelease_firmware(fw2);\n\trelease_firmware(fw1);\n\n\treturn ret;\n}\n\n\n \n\nstatic int speedtch_read_status(struct speedtch_instance_data *instance)\n{\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tunsigned char *buf = instance->scratch_buffer;\n\tint ret;\n\n\tmemset(buf, 0, 16);\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x12, 0xc0, 0x07, 0x00, buf + OFFSET_7, SIZE_7,\n\t\t\t      CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tatm_dbg(usbatm, \"%s: MSG 7 failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x12, 0xc0, 0x0b, 0x00, buf + OFFSET_b, SIZE_b,\n\t\t\t      CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tatm_dbg(usbatm, \"%s: MSG B failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x12, 0xc0, 0x0d, 0x00, buf + OFFSET_d, SIZE_d,\n\t\t\t      CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tatm_dbg(usbatm, \"%s: MSG D failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0xc0, 0x0e, 0x00, buf + OFFSET_e, SIZE_e,\n\t\t\t      CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tatm_dbg(usbatm, \"%s: MSG E failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x01, 0xc0, 0x0f, 0x00, buf + OFFSET_f, SIZE_f,\n\t\t\t      CTRL_TIMEOUT);\n\tif (ret < 0) {\n\t\tatm_dbg(usbatm, \"%s: MSG F failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int speedtch_start_synchro(struct speedtch_instance_data *instance)\n{\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tunsigned char *buf = instance->scratch_buffer;\n\tint ret;\n\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tmemset(buf, 0, 2);\n\n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x12, 0xc0, 0x04, 0x00,\n\t\t\t      buf, 2, CTRL_TIMEOUT);\n\n\tif (ret < 0)\n\t\tatm_warn(usbatm, \"failed to start ADSL synchronisation: %d\\n\", ret);\n\telse\n\t\tatm_dbg(usbatm, \"%s: modem prodded. %d bytes returned: %02x %02x\\n\",\n\t\t\t__func__, ret, buf[0], buf[1]);\n\n\treturn ret;\n}\n\nstatic void speedtch_check_status(struct work_struct *work)\n{\n\tstruct speedtch_instance_data *instance =\n\t\tcontainer_of(work, struct speedtch_instance_data,\n\t\t\t     status_check_work);\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct atm_dev *atm_dev = usbatm->atm_dev;\n\tunsigned char *buf = instance->scratch_buffer;\n\tint down_speed, up_speed, ret;\n\tunsigned char status;\n\n#ifdef VERBOSE_DEBUG\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n#endif\n\n\tret = speedtch_read_status(instance);\n\tif (ret < 0) {\n\t\tatm_warn(usbatm, \"error %d fetching device status\\n\", ret);\n\t\tinstance->poll_delay = min(2 * instance->poll_delay, MAX_POLL_DELAY);\n\t\treturn;\n\t}\n\n\tinstance->poll_delay = max(instance->poll_delay / 2, MIN_POLL_DELAY);\n\n\tstatus = buf[OFFSET_7];\n\n\tif ((status != instance->last_status) || !status) {\n\t\tatm_dbg(usbatm, \"%s: line state 0x%02x\\n\", __func__, status);\n\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\t\tif (instance->last_status)\n\t\t\t\tatm_info(usbatm, \"ADSL line is down\\n\");\n\t\t\t \n\t\t\tret = speedtch_start_synchro(instance);\n\t\t\tbreak;\n\n\t\tcase 0x08:\n\t\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\n\t\t\tatm_info(usbatm, \"ADSL line is blocked?\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x10:\n\t\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\t\tatm_info(usbatm, \"ADSL line is synchronising\\n\");\n\t\t\tbreak;\n\n\t\tcase 0x20:\n\t\t\tdown_speed = buf[OFFSET_b] | (buf[OFFSET_b + 1] << 8)\n\t\t\t\t| (buf[OFFSET_b + 2] << 16) | (buf[OFFSET_b + 3] << 24);\n\t\t\tup_speed = buf[OFFSET_b + 4] | (buf[OFFSET_b + 5] << 8)\n\t\t\t\t| (buf[OFFSET_b + 6] << 16) | (buf[OFFSET_b + 7] << 24);\n\n\t\t\tif (!(down_speed & 0x0000ffff) && !(up_speed & 0x0000ffff)) {\n\t\t\t\tdown_speed >>= 16;\n\t\t\t\tup_speed >>= 16;\n\t\t\t}\n\n\t\t\tatm_dev->link_rate = down_speed * 1000 / 424;\n\t\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_FOUND);\n\n\t\t\tatm_info(usbatm,\n\t\t\t\t \"ADSL line is up (%d kb/s down | %d kb/s up)\\n\",\n\t\t\t\t down_speed, up_speed);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\n\t\t\tatm_info(usbatm, \"unknown line state %02x\\n\", status);\n\t\t\tbreak;\n\t\t}\n\n\t\tinstance->last_status = status;\n\t}\n}\n\nstatic void speedtch_status_poll(struct timer_list *t)\n{\n\tstruct speedtch_instance_data *instance = from_timer(instance, t,\n\t\t\t\t\t\t             status_check_timer);\n\n\tschedule_work(&instance->status_check_work);\n\n\t \n\tif (instance->poll_delay < MAX_POLL_DELAY)\n\t\tmod_timer(&instance->status_check_timer, jiffies + msecs_to_jiffies(instance->poll_delay));\n\telse\n\t\tatm_warn(instance->usbatm, \"Too many failures - disabling line status polling\\n\");\n}\n\nstatic void speedtch_resubmit_int(struct timer_list *t)\n{\n\tstruct speedtch_instance_data *instance = from_timer(instance, t,\n\t\t\t\t\t\t\t     resubmit_timer);\n\tstruct urb *int_urb = instance->int_urb;\n\tint ret;\n\n\tatm_dbg(instance->usbatm, \"%s entered\\n\", __func__);\n\n\tif (int_urb) {\n\t\tret = usb_submit_urb(int_urb, GFP_ATOMIC);\n\t\tif (!ret)\n\t\t\tschedule_work(&instance->status_check_work);\n\t\telse {\n\t\t\tatm_dbg(instance->usbatm, \"%s: usb_submit_urb failed with result %d\\n\", __func__, ret);\n\t\t\tmod_timer(&instance->resubmit_timer, jiffies + msecs_to_jiffies(RESUBMIT_DELAY));\n\t\t}\n\t}\n}\n\nstatic void speedtch_handle_int(struct urb *int_urb)\n{\n\tstruct speedtch_instance_data *instance = int_urb->context;\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tunsigned int count = int_urb->actual_length;\n\tint status = int_urb->status;\n\tint ret;\n\n\t \n\tstatic const unsigned char up_int[6]   = { 0xa1, 0x00, 0x01, 0x00, 0x00, 0x00 };\n\t \n\tstatic const unsigned char down_int[6] = { 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tif (status < 0) {\n\t\tatm_dbg(usbatm, \"%s: nonzero urb status %d!\\n\", __func__, status);\n\t\tgoto fail;\n\t}\n\n\tif ((count == 6) && !memcmp(up_int, instance->int_data, 6)) {\n\t\tdel_timer(&instance->status_check_timer);\n\t\tatm_info(usbatm, \"DSL line goes up\\n\");\n\t} else if ((count == 6) && !memcmp(down_int, instance->int_data, 6)) {\n\t\tatm_info(usbatm, \"DSL line goes down\\n\");\n\t} else {\n\t\tint i;\n\n\t\tatm_dbg(usbatm, \"%s: unknown interrupt packet of length %d:\", __func__, count);\n\t\tfor (i = 0; i < count; i++)\n\t\t\tprintk(\" %02x\", instance->int_data[i]);\n\t\tprintk(\"\\n\");\n\t\tgoto fail;\n\t}\n\n\tint_urb = instance->int_urb;\n\tif (int_urb) {\n\t\tret = usb_submit_urb(int_urb, GFP_ATOMIC);\n\t\tschedule_work(&instance->status_check_work);\n\t\tif (ret < 0) {\n\t\t\tatm_dbg(usbatm, \"%s: usb_submit_urb failed with result %d\\n\", __func__, ret);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\treturn;\n\nfail:\n\tint_urb = instance->int_urb;\n\tif (int_urb)\n\t\tmod_timer(&instance->resubmit_timer, jiffies + msecs_to_jiffies(RESUBMIT_DELAY));\n}\n\nstatic int speedtch_atm_start(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\n{\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\tstruct speedtch_instance_data *instance = usbatm->driver_data;\n\tint i, ret;\n\tunsigned char mac_str[13];\n\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\t \n\tmemset(atm_dev->esi, 0, sizeof(atm_dev->esi));\n\tif (usb_string(usb_dev, usb_dev->descriptor.iSerialNumber, mac_str, sizeof(mac_str)) == 12) {\n\t\tfor (i = 0; i < 6; i++)\n\t\t\tatm_dev->esi[i] = (hex_to_bin(mac_str[i * 2]) << 4) +\n\t\t\t\thex_to_bin(mac_str[i * 2 + 1]);\n\t}\n\n\t \n\tret = speedtch_start_synchro(instance);\n\n\t \n\tif (instance->int_urb) {\n\t\tret = usb_submit_urb(instance->int_urb, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tatm_dbg(usbatm, \"%s: submission of interrupt URB failed (%d)!\\n\", __func__, ret);\n\t\t\tusb_free_urb(instance->int_urb);\n\t\t\tinstance->int_urb = NULL;\n\t\t}\n\t}\n\n\t \n\tmod_timer(&instance->status_check_timer, jiffies + msecs_to_jiffies(1000));\n\n\treturn 0;\n}\n\nstatic void speedtch_atm_stop(struct usbatm_data *usbatm, struct atm_dev *atm_dev)\n{\n\tstruct speedtch_instance_data *instance = usbatm->driver_data;\n\tstruct urb *int_urb = instance->int_urb;\n\n\tatm_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tdel_timer_sync(&instance->status_check_timer);\n\n\t \n\tinstance->int_urb = NULL;  \n\tmb();\n\tusb_kill_urb(int_urb);\n\tdel_timer_sync(&instance->resubmit_timer);\n\t \n\tusb_kill_urb(int_urb);\n\tdel_timer_sync(&instance->resubmit_timer);\n\tusb_free_urb(int_urb);\n\n\tflush_work(&instance->status_check_work);\n}\n\nstatic int speedtch_pre_reset(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int speedtch_post_reset(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n\n \n\nstatic const struct usb_device_id speedtch_usb_ids[] = {\n\t{USB_DEVICE(0x06b9, 0x4061)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, speedtch_usb_ids);\n\nstatic int speedtch_usb_probe(struct usb_interface *, const struct usb_device_id *);\n\nstatic struct usb_driver speedtch_usb_driver = {\n\t.name\t\t= speedtch_driver_name,\n\t.probe\t\t= speedtch_usb_probe,\n\t.disconnect\t= usbatm_usb_disconnect,\n\t.pre_reset\t= speedtch_pre_reset,\n\t.post_reset\t= speedtch_post_reset,\n\t.id_table\t= speedtch_usb_ids\n};\n\nstatic void speedtch_release_interfaces(struct usb_device *usb_dev,\n\t\t\t\t\tint num_interfaces)\n{\n\tstruct usb_interface *cur_intf;\n\tint i;\n\n\tfor (i = 0; i < num_interfaces; i++) {\n\t\tcur_intf = usb_ifnum_to_if(usb_dev, i);\n\t\tif (cur_intf) {\n\t\t\tusb_set_intfdata(cur_intf, NULL);\n\t\t\tusb_driver_release_interface(&speedtch_usb_driver, cur_intf);\n\t\t}\n\t}\n}\n\nstatic int speedtch_bind(struct usbatm_data *usbatm,\n\t\t\t struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usb_interface *cur_intf, *data_intf;\n\tstruct speedtch_instance_data *instance;\n\tint ifnum = intf->altsetting->desc.bInterfaceNumber;\n\tint num_interfaces = usb_dev->actconfig->desc.bNumInterfaces;\n\tint i, ret;\n\tint use_isoc;\n\n\tusb_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\t \n\n\tif (usb_dev->descriptor.bDeviceClass != USB_CLASS_VENDOR_SPEC) {\n\t\tusb_err(usbatm, \"%s: wrong device class %d\\n\", __func__, usb_dev->descriptor.bDeviceClass);\n\t\treturn -ENODEV;\n\t}\n\n\tdata_intf = usb_ifnum_to_if(usb_dev, INTERFACE_DATA);\n\tif (!data_intf) {\n\t\tusb_err(usbatm, \"%s: data interface not found!\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\n\tfor (i = 0; i < num_interfaces; i++) {\n\t\tcur_intf = usb_ifnum_to_if(usb_dev, i);\n\n\t\tif ((i != ifnum) && cur_intf) {\n\t\t\tret = usb_driver_claim_interface(&speedtch_usb_driver, cur_intf, usbatm);\n\n\t\t\tif (ret < 0) {\n\t\t\t\tusb_err(usbatm, \"%s: failed to claim interface %2d (%d)!\\n\", __func__, i, ret);\n\t\t\t\tspeedtch_release_interfaces(usb_dev, i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\n\tif (!instance) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_release;\n\t}\n\n\tinstance->usbatm = usbatm;\n\n\t \n\tinstance->params.altsetting = altsetting;\n\tinstance->params.BMaxDSL = BMaxDSL;\n\tinstance->params.ModemMode = ModemMode;\n\tmemcpy(instance->params.ModemOption, DEFAULT_MODEM_OPTION, MODEM_OPTION_LENGTH);\n\tmemcpy(instance->params.ModemOption, ModemOption, num_ModemOption);\n\tuse_isoc = enable_isoc;\n\n\tif (instance->params.altsetting)\n\t\tif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, instance->params.altsetting)) < 0) {\n\t\t\tusb_err(usbatm, \"%s: setting interface to %2d failed (%d)!\\n\", __func__, instance->params.altsetting, ret);\n\t\t\tinstance->params.altsetting = 0;  \n\t\t}\n\n\tif (!instance->params.altsetting && use_isoc)\n\t\tif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, DEFAULT_ISOC_ALTSETTING)) < 0) {\n\t\t\tusb_dbg(usbatm, \"%s: setting interface to %2d failed (%d)!\\n\", __func__, DEFAULT_ISOC_ALTSETTING, ret);\n\t\t\tuse_isoc = 0;  \n\t\t}\n\n\tif (use_isoc) {\n\t\tconst struct usb_host_interface *desc = data_intf->cur_altsetting;\n\t\tconst __u8 target_address = USB_DIR_IN | usbatm->driver->isoc_in;\n\n\t\tuse_isoc = 0;  \n\n\t\tfor (i = 0; i < desc->desc.bNumEndpoints; i++) {\n\t\t\tconst struct usb_endpoint_descriptor *endpoint_desc = &desc->endpoint[i].desc;\n\n\t\t\tif ((endpoint_desc->bEndpointAddress == target_address)) {\n\t\t\t\tuse_isoc =\n\t\t\t\t\tusb_endpoint_xfer_isoc(endpoint_desc);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!use_isoc)\n\t\t\tusb_info(usbatm, \"isochronous transfer not supported - using bulk\\n\");\n\t}\n\n\tif (!use_isoc && !instance->params.altsetting)\n\t\tif ((ret = usb_set_interface(usb_dev, INTERFACE_DATA, DEFAULT_BULK_ALTSETTING)) < 0) {\n\t\t\tusb_err(usbatm, \"%s: setting interface to %2d failed (%d)!\\n\", __func__, DEFAULT_BULK_ALTSETTING, ret);\n\t\t\tgoto fail_free;\n\t\t}\n\n\tif (!instance->params.altsetting)\n\t\tinstance->params.altsetting = use_isoc ? DEFAULT_ISOC_ALTSETTING : DEFAULT_BULK_ALTSETTING;\n\n\tusbatm->flags |= (use_isoc ? UDSL_USE_ISOC : 0);\n\n\tINIT_WORK(&instance->status_check_work, speedtch_check_status);\n\ttimer_setup(&instance->status_check_timer, speedtch_status_poll, 0);\n\tinstance->last_status = 0xff;\n\tinstance->poll_delay = MIN_POLL_DELAY;\n\n\ttimer_setup(&instance->resubmit_timer, speedtch_resubmit_int, 0);\n\n\tinstance->int_urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (instance->int_urb)\n\t\tusb_fill_int_urb(instance->int_urb, usb_dev,\n\t\t\t\t usb_rcvintpipe(usb_dev, ENDPOINT_INT),\n\t\t\t\t instance->int_data, sizeof(instance->int_data),\n\t\t\t\t speedtch_handle_int, instance, 16);\n\telse\n\t\tusb_dbg(usbatm, \"%s: no memory for interrupt urb!\\n\", __func__);\n\n\t \n\tret = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n\t\t\t      0x12, 0xc0, 0x07, 0x00,\n\t\t\t      instance->scratch_buffer + OFFSET_7, SIZE_7, 500);\n\n\tusbatm->flags |= (ret == SIZE_7 ? UDSL_SKIP_HEAVY_INIT : 0);\n\n\tusb_dbg(usbatm, \"%s: firmware %s loaded\\n\", __func__, usbatm->flags & UDSL_SKIP_HEAVY_INIT ? \"already\" : \"not\");\n\n\tif (!(usbatm->flags & UDSL_SKIP_HEAVY_INIT))\n\t\tif ((ret = usb_reset_device(usb_dev)) < 0) {\n\t\t\tusb_err(usbatm, \"%s: device reset failed (%d)!\\n\", __func__, ret);\n\t\t\tgoto fail_free;\n\t\t}\n\n        usbatm->driver_data = instance;\n\n\treturn 0;\n\nfail_free:\n\tusb_free_urb(instance->int_urb);\n\tkfree(instance);\nfail_release:\n\tspeedtch_release_interfaces(usb_dev, num_interfaces);\n\treturn ret;\n}\n\nstatic void speedtch_unbind(struct usbatm_data *usbatm, struct usb_interface *intf)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct speedtch_instance_data *instance = usbatm->driver_data;\n\n\tusb_dbg(usbatm, \"%s entered\\n\", __func__);\n\n\tspeedtch_release_interfaces(usb_dev, usb_dev->actconfig->desc.bNumInterfaces);\n\tusb_free_urb(instance->int_urb);\n\tkfree(instance);\n}\n\n\n \n\nstatic struct usbatm_driver speedtch_usbatm_driver = {\n\t.driver_name\t= speedtch_driver_name,\n\t.bind\t\t= speedtch_bind,\n\t.heavy_init\t= speedtch_heavy_init,\n\t.unbind\t\t= speedtch_unbind,\n\t.atm_start\t= speedtch_atm_start,\n\t.atm_stop\t= speedtch_atm_stop,\n\t.bulk_in\t= ENDPOINT_BULK_DATA,\n\t.bulk_out\t= ENDPOINT_BULK_DATA,\n\t.isoc_in\t= ENDPOINT_ISOC_DATA\n};\n\nstatic int speedtch_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\treturn usbatm_usb_probe(intf, id, &speedtch_usbatm_driver);\n}\n\nmodule_usb_driver(speedtch_usb_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}