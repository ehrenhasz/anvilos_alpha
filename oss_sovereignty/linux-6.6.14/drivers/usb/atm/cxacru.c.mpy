{
  "module_name": "cxacru.c",
  "hash_id": "8f3b0ce6eaee1fbceddedbc896be208ff74773c3a5b55e77f2e311edcf580077",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/atm/cxacru.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/firmware.h>\n#include <linux/mutex.h>\n#include <asm/unaligned.h>\n\n#include \"usbatm.h\"\n\n#define DRIVER_AUTHOR\t\"Roman Kagan, David Woodhouse, Duncan Sands, Simon Arlott\"\n#define DRIVER_DESC\t\"Conexant AccessRunner ADSL USB modem driver\"\n\nstatic const char cxacru_driver_name[] = \"cxacru\";\n\n#define CXACRU_EP_CMD\t\t0x01\t \n#define CXACRU_EP_DATA\t\t0x02\t \n\n#define CMD_PACKET_SIZE\t\t64\t \n#define CMD_MAX_CONFIG\t\t((CMD_PACKET_SIZE / 4 - 1) / 2)\n\n \n#define PLLFCLK_ADDR\t0x00350068\n#define PLLBCLK_ADDR\t0x0035006c\n#define SDRAMEN_ADDR\t0x00350010\n#define FW_ADDR\t\t0x00801000\n#define BR_ADDR\t\t0x00180600\n#define SIG_ADDR\t0x00180500\n#define BR_STACK_ADDR\t0x00187f10\n\n \n#define SDRAM_ENA\t0x1\n\n#define CMD_TIMEOUT\t2000\t \n#define POLL_INTERVAL\t1\t \n\n \nenum cxacru_fw_request {\n\tFW_CMD_ERR,\n\tFW_GET_VER,\n\tFW_READ_MEM,\n\tFW_WRITE_MEM,\n\tFW_RMW_MEM,\n\tFW_CHECKSUM_MEM,\n\tFW_GOTO_MEM,\n};\n\n \nenum cxacru_cm_request {\n\tCM_REQUEST_UNDEFINED = 0x80,\n\tCM_REQUEST_TEST,\n\tCM_REQUEST_CHIP_GET_MAC_ADDRESS,\n\tCM_REQUEST_CHIP_GET_DP_VERSIONS,\n\tCM_REQUEST_CHIP_ADSL_LINE_START,\n\tCM_REQUEST_CHIP_ADSL_LINE_STOP,\n\tCM_REQUEST_CHIP_ADSL_LINE_GET_STATUS,\n\tCM_REQUEST_CHIP_ADSL_LINE_GET_SPEED,\n\tCM_REQUEST_CARD_INFO_GET,\n\tCM_REQUEST_CARD_DATA_GET,\n\tCM_REQUEST_CARD_DATA_SET,\n\tCM_REQUEST_COMMAND_HW_IO,\n\tCM_REQUEST_INTERFACE_HW_IO,\n\tCM_REQUEST_CARD_SERIAL_DATA_PATH_GET,\n\tCM_REQUEST_CARD_SERIAL_DATA_PATH_SET,\n\tCM_REQUEST_CARD_CONTROLLER_VERSION_GET,\n\tCM_REQUEST_CARD_GET_STATUS,\n\tCM_REQUEST_CARD_GET_MAC_ADDRESS,\n\tCM_REQUEST_CARD_GET_DATA_LINK_STATUS,\n\tCM_REQUEST_MAX,\n};\n\n \nenum cxacru_cm_flash {\n\tCM_FLASH_READ = 0xa1,\n\tCM_FLASH_WRITE = 0xa2\n};\n\n \nenum cxacru_cm_status {\n\tCM_STATUS_UNDEFINED,\n\tCM_STATUS_SUCCESS,\n\tCM_STATUS_ERROR,\n\tCM_STATUS_UNSUPPORTED,\n\tCM_STATUS_UNIMPLEMENTED,\n\tCM_STATUS_PARAMETER_ERROR,\n\tCM_STATUS_DBG_LOOPBACK,\n\tCM_STATUS_MAX,\n};\n\n \nenum cxacru_info_idx {\n\tCXINF_DOWNSTREAM_RATE,\n\tCXINF_UPSTREAM_RATE,\n\tCXINF_LINK_STATUS,\n\tCXINF_LINE_STATUS,\n\tCXINF_MAC_ADDRESS_HIGH,\n\tCXINF_MAC_ADDRESS_LOW,\n\tCXINF_UPSTREAM_SNR_MARGIN,\n\tCXINF_DOWNSTREAM_SNR_MARGIN,\n\tCXINF_UPSTREAM_ATTENUATION,\n\tCXINF_DOWNSTREAM_ATTENUATION,\n\tCXINF_TRANSMITTER_POWER,\n\tCXINF_UPSTREAM_BITS_PER_FRAME,\n\tCXINF_DOWNSTREAM_BITS_PER_FRAME,\n\tCXINF_STARTUP_ATTEMPTS,\n\tCXINF_UPSTREAM_CRC_ERRORS,\n\tCXINF_DOWNSTREAM_CRC_ERRORS,\n\tCXINF_UPSTREAM_FEC_ERRORS,\n\tCXINF_DOWNSTREAM_FEC_ERRORS,\n\tCXINF_UPSTREAM_HEC_ERRORS,\n\tCXINF_DOWNSTREAM_HEC_ERRORS,\n\tCXINF_LINE_STARTABLE,\n\tCXINF_MODULATION,\n\tCXINF_ADSL_HEADEND,\n\tCXINF_ADSL_HEADEND_ENVIRONMENT,\n\tCXINF_CONTROLLER_VERSION,\n\t \n\tCXINF_MAX = 0x1c,\n};\n\nenum cxacru_poll_state {\n\tCXPOLL_STOPPING,\n\tCXPOLL_STOPPED,\n\tCXPOLL_POLLING,\n\tCXPOLL_SHUTDOWN\n};\n\nstruct cxacru_modem_type {\n\tu32 pll_f_clk;\n\tu32 pll_b_clk;\n\tint boot_rom_patch;\n};\n\nstruct cxacru_data {\n\tstruct usbatm_data *usbatm;\n\n\tconst struct cxacru_modem_type *modem_type;\n\n\tint line_status;\n\tstruct mutex adsl_state_serialize;\n\tint adsl_status;\n\tstruct delayed_work poll_work;\n\tu32 card_info[CXINF_MAX];\n\tstruct mutex poll_state_serialize;\n\tenum cxacru_poll_state poll_state;\n\n\t \n\tstruct mutex cm_serialize;\n\tu8 *rcv_buf;\n\tu8 *snd_buf;\n\tstruct urb *rcv_urb;\n\tstruct urb *snd_urb;\n\tstruct completion rcv_done;\n\tstruct completion snd_done;\n};\n\nstatic int cxacru_cm(struct cxacru_data *instance, enum cxacru_cm_request cm,\n\tu8 *wdata, int wsize, u8 *rdata, int rsize);\nstatic void cxacru_poll_status(struct work_struct *work);\n\n \n#define CXACRU__ATTR_INIT(_name) \\\nstatic DEVICE_ATTR_RO(_name)\n\n#define CXACRU_CMD_INIT(_name) \\\nstatic DEVICE_ATTR_RW(_name)\n\n#define CXACRU_SET_INIT(_name) \\\nstatic DEVICE_ATTR_WO(_name)\n\n#define CXACRU_ATTR_INIT(_value, _type, _name) \\\nstatic ssize_t _name##_show(struct device *dev, \\\n\tstruct device_attribute *attr, char *buf) \\\n{ \\\n\tstruct cxacru_data *instance = to_usbatm_driver_data(\\\n\t\tto_usb_interface(dev)); \\\n\\\n\tif (instance == NULL) \\\n\t\treturn -ENODEV; \\\n\\\n\treturn cxacru_sysfs_showattr_##_type(instance->card_info[_value], buf); \\\n} \\\nCXACRU__ATTR_INIT(_name)\n\n#define CXACRU_ATTR_CREATE(_v, _t, _name) CXACRU_DEVICE_CREATE_FILE(_name)\n#define CXACRU_CMD_CREATE(_name)          CXACRU_DEVICE_CREATE_FILE(_name)\n#define CXACRU_SET_CREATE(_name)          CXACRU_DEVICE_CREATE_FILE(_name)\n#define CXACRU__ATTR_CREATE(_name)        CXACRU_DEVICE_CREATE_FILE(_name)\n\n#define CXACRU_ATTR_REMOVE(_v, _t, _name) CXACRU_DEVICE_REMOVE_FILE(_name)\n#define CXACRU_CMD_REMOVE(_name)          CXACRU_DEVICE_REMOVE_FILE(_name)\n#define CXACRU_SET_REMOVE(_name)          CXACRU_DEVICE_REMOVE_FILE(_name)\n#define CXACRU__ATTR_REMOVE(_name)        CXACRU_DEVICE_REMOVE_FILE(_name)\n\nstatic ssize_t cxacru_sysfs_showattr_u32(u32 value, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", value);\n}\n\nstatic ssize_t cxacru_sysfs_showattr_s8(s8 value, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", value);\n}\n\nstatic ssize_t cxacru_sysfs_showattr_dB(s16 value, char *buf)\n{\n\tif (likely(value >= 0)) {\n\t\treturn snprintf(buf, PAGE_SIZE, \"%u.%02u\\n\",\n\t\t\t\t\tvalue / 100, value % 100);\n\t} else {\n\t\tvalue = -value;\n\t\treturn snprintf(buf, PAGE_SIZE, \"-%u.%02u\\n\",\n\t\t\t\t\tvalue / 100, value % 100);\n\t}\n}\n\nstatic ssize_t cxacru_sysfs_showattr_bool(u32 value, char *buf)\n{\n\tstatic char *str[] = { \"no\", \"yes\" };\n\n\tif (unlikely(value >= ARRAY_SIZE(str)))\n\t\treturn sprintf(buf, \"%u\\n\", value);\n\treturn sprintf(buf, \"%s\\n\", str[value]);\n}\n\nstatic ssize_t cxacru_sysfs_showattr_LINK(u32 value, char *buf)\n{\n\tstatic char *str[] = { NULL, \"not connected\", \"connected\", \"lost\" };\n\n\tif (unlikely(value >= ARRAY_SIZE(str) || str[value] == NULL))\n\t\treturn sprintf(buf, \"%u\\n\", value);\n\treturn sprintf(buf, \"%s\\n\", str[value]);\n}\n\nstatic ssize_t cxacru_sysfs_showattr_LINE(u32 value, char *buf)\n{\n\tstatic char *str[] = { \"down\", \"attempting to activate\",\n\t\t\"training\", \"channel analysis\", \"exchange\", \"up\",\n\t\t\"waiting\", \"initialising\"\n\t};\n\tif (unlikely(value >= ARRAY_SIZE(str)))\n\t\treturn sprintf(buf, \"%u\\n\", value);\n\treturn sprintf(buf, \"%s\\n\", str[value]);\n}\n\nstatic ssize_t cxacru_sysfs_showattr_MODU(u32 value, char *buf)\n{\n\tstatic char *str[] = {\n\t\t\t\"\",\n\t\t\t\"ANSI T1.413\",\n\t\t\t\"ITU-T G.992.1 (G.DMT)\",\n\t\t\t\"ITU-T G.992.2 (G.LITE)\"\n\t};\n\tif (unlikely(value >= ARRAY_SIZE(str)))\n\t\treturn sprintf(buf, \"%u\\n\", value);\n\treturn sprintf(buf, \"%s\\n\", str[value]);\n}\n\n \nstatic ssize_t mac_address_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct cxacru_data *instance = to_usbatm_driver_data(\n\t\t\tto_usb_interface(dev));\n\n\tif (instance == NULL || instance->usbatm->atm_dev == NULL)\n\t\treturn -ENODEV;\n\n\treturn sprintf(buf, \"%pM\\n\", instance->usbatm->atm_dev->esi);\n}\n\nstatic ssize_t adsl_state_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstatic char *str[] = { \"running\", \"stopped\" };\n\tstruct cxacru_data *instance = to_usbatm_driver_data(\n\t\t\tto_usb_interface(dev));\n\tu32 value;\n\n\tif (instance == NULL)\n\t\treturn -ENODEV;\n\n\tvalue = instance->card_info[CXINF_LINE_STARTABLE];\n\tif (unlikely(value >= ARRAY_SIZE(str)))\n\t\treturn sprintf(buf, \"%u\\n\", value);\n\treturn sprintf(buf, \"%s\\n\", str[value]);\n}\n\nstatic ssize_t adsl_state_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct cxacru_data *instance = to_usbatm_driver_data(\n\t\t\tto_usb_interface(dev));\n\tint ret;\n\tint poll = -1;\n\tchar str_cmd[8];\n\tint len = strlen(buf);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EACCES;\n\n\tret = sscanf(buf, \"%7s\", str_cmd);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\tret = 0;\n\n\tif (instance == NULL)\n\t\treturn -ENODEV;\n\n\tif (mutex_lock_interruptible(&instance->adsl_state_serialize))\n\t\treturn -ERESTARTSYS;\n\n\tif (!strcmp(str_cmd, \"stop\") || !strcmp(str_cmd, \"restart\")) {\n\t\tret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_STOP, NULL, 0, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tatm_err(instance->usbatm, \"change adsl state:\"\n\t\t\t\t\" CHIP_ADSL_LINE_STOP returned %d\\n\", ret);\n\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tret = len;\n\t\t\tpoll = CXPOLL_STOPPED;\n\t\t}\n\t}\n\n\t \n\tif (!strcmp(str_cmd, \"restart\"))\n\t\tmsleep(1500);\n\n\tif (!strcmp(str_cmd, \"start\") || !strcmp(str_cmd, \"restart\")) {\n\t\tret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_START, NULL, 0, NULL, 0);\n\t\tif (ret < 0) {\n\t\t\tatm_err(instance->usbatm, \"change adsl state:\"\n\t\t\t\t\" CHIP_ADSL_LINE_START returned %d\\n\", ret);\n\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\tret = len;\n\t\t\tpoll = CXPOLL_POLLING;\n\t\t}\n\t}\n\n\tif (!strcmp(str_cmd, \"poll\")) {\n\t\tret = len;\n\t\tpoll = CXPOLL_POLLING;\n\t}\n\n\tif (ret == 0) {\n\t\tret = -EINVAL;\n\t\tpoll = -1;\n\t}\n\n\tif (poll == CXPOLL_POLLING) {\n\t\tmutex_lock(&instance->poll_state_serialize);\n\t\tswitch (instance->poll_state) {\n\t\tcase CXPOLL_STOPPED:\n\t\t\t \n\t\t\tinstance->poll_state = CXPOLL_POLLING;\n\t\t\tbreak;\n\n\t\tcase CXPOLL_STOPPING:\n\t\t\t \n\t\t\tinstance->poll_state = CXPOLL_POLLING;\n\t\t\tfallthrough;\n\t\tcase CXPOLL_POLLING:\n\t\tcase CXPOLL_SHUTDOWN:\n\t\t\t \n\t\t\tpoll = -1;\n\t\t}\n\t\tmutex_unlock(&instance->poll_state_serialize);\n\t} else if (poll == CXPOLL_STOPPED) {\n\t\tmutex_lock(&instance->poll_state_serialize);\n\t\t \n\t\tif (instance->poll_state == CXPOLL_POLLING)\n\t\t\tinstance->poll_state = CXPOLL_STOPPING;\n\t\tmutex_unlock(&instance->poll_state_serialize);\n\t}\n\n\tmutex_unlock(&instance->adsl_state_serialize);\n\n\tif (poll == CXPOLL_POLLING)\n\t\tcxacru_poll_status(&instance->poll_work.work);\n\n\treturn ret;\n}\n\n \n\nstatic ssize_t adsl_config_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct cxacru_data *instance = to_usbatm_driver_data(\n\t\t\tto_usb_interface(dev));\n\tint len = strlen(buf);\n\tint ret, pos, num;\n\t__le32 data[CMD_PACKET_SIZE / 4];\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EACCES;\n\n\tif (instance == NULL)\n\t\treturn -ENODEV;\n\n\tpos = 0;\n\tnum = 0;\n\twhile (pos < len) {\n\t\tint tmp;\n\t\tu32 index;\n\t\tu32 value;\n\n\t\tret = sscanf(buf + pos, \"%x=%x%n\", &index, &value, &tmp);\n\t\tif (ret < 2)\n\t\t\treturn -EINVAL;\n\t\tif (index > 0x7f)\n\t\t\treturn -EINVAL;\n\t\tif (tmp < 0 || tmp > len - pos)\n\t\t\treturn -EINVAL;\n\t\tpos += tmp;\n\n\t\t \n\t\tif (buf[pos] == '\\n' && pos == len-1)\n\t\t\tpos++;\n\n\t\tdata[num * 2 + 1] = cpu_to_le32(index);\n\t\tdata[num * 2 + 2] = cpu_to_le32(value);\n\t\tnum++;\n\n\t\t \n\t\tif (pos >= len || num >= CMD_MAX_CONFIG) {\n\t\t\tchar log[CMD_MAX_CONFIG * 12 + 1];  \n\n\t\t\tdata[0] = cpu_to_le32(num);\n\t\t\tret = cxacru_cm(instance, CM_REQUEST_CARD_DATA_SET,\n\t\t\t\t(u8 *) data, 4 + num * 8, NULL, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tatm_err(instance->usbatm,\n\t\t\t\t\t\"set card data returned %d\\n\", ret);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\tfor (tmp = 0; tmp < num; tmp++)\n\t\t\t\tsnprintf(log + tmp*12, 13, \" %02x=%08x\",\n\t\t\t\t\tle32_to_cpu(data[tmp * 2 + 1]),\n\t\t\t\t\tle32_to_cpu(data[tmp * 2 + 2]));\n\t\t\tatm_info(instance->usbatm, \"config%s\\n\", log);\n\t\t\tnum = 0;\n\t\t}\n\t}\n\n\treturn len;\n}\n\n \n#define CXACRU_ALL_FILES(_action) \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_RATE,           u32,  downstream_rate); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_RATE,             u32,  upstream_rate); \\\nCXACRU_ATTR_##_action(CXINF_LINK_STATUS,               LINK, link_status); \\\nCXACRU_ATTR_##_action(CXINF_LINE_STATUS,               LINE, line_status); \\\nCXACRU__ATTR_##_action(                                      mac_address); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_SNR_MARGIN,       dB,   upstream_snr_margin); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_SNR_MARGIN,     dB,   downstream_snr_margin); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_ATTENUATION,      dB,   upstream_attenuation); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_ATTENUATION,    dB,   downstream_attenuation); \\\nCXACRU_ATTR_##_action(CXINF_TRANSMITTER_POWER,         s8,   transmitter_power); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_BITS_PER_FRAME,   u32,  upstream_bits_per_frame); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_BITS_PER_FRAME, u32,  downstream_bits_per_frame); \\\nCXACRU_ATTR_##_action(CXINF_STARTUP_ATTEMPTS,          u32,  startup_attempts); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_CRC_ERRORS,       u32,  upstream_crc_errors); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_CRC_ERRORS,     u32,  downstream_crc_errors); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_FEC_ERRORS,       u32,  upstream_fec_errors); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_FEC_ERRORS,     u32,  downstream_fec_errors); \\\nCXACRU_ATTR_##_action(CXINF_UPSTREAM_HEC_ERRORS,       u32,  upstream_hec_errors); \\\nCXACRU_ATTR_##_action(CXINF_DOWNSTREAM_HEC_ERRORS,     u32,  downstream_hec_errors); \\\nCXACRU_ATTR_##_action(CXINF_LINE_STARTABLE,            bool, line_startable); \\\nCXACRU_ATTR_##_action(CXINF_MODULATION,                MODU, modulation); \\\nCXACRU_ATTR_##_action(CXINF_ADSL_HEADEND,              u32,  adsl_headend); \\\nCXACRU_ATTR_##_action(CXINF_ADSL_HEADEND_ENVIRONMENT,  u32,  adsl_headend_environment); \\\nCXACRU_ATTR_##_action(CXINF_CONTROLLER_VERSION,        u32,  adsl_controller_version); \\\nCXACRU_CMD_##_action(                                        adsl_state); \\\nCXACRU_SET_##_action(                                        adsl_config);\n\nCXACRU_ALL_FILES(INIT);\n\nstatic struct attribute *cxacru_attrs[] = {\n\t&dev_attr_adsl_config.attr,\n\t&dev_attr_adsl_state.attr,\n\t&dev_attr_adsl_controller_version.attr,\n\t&dev_attr_adsl_headend_environment.attr,\n\t&dev_attr_adsl_headend.attr,\n\t&dev_attr_modulation.attr,\n\t&dev_attr_line_startable.attr,\n\t&dev_attr_downstream_hec_errors.attr,\n\t&dev_attr_upstream_hec_errors.attr,\n\t&dev_attr_downstream_fec_errors.attr,\n\t&dev_attr_upstream_fec_errors.attr,\n\t&dev_attr_downstream_crc_errors.attr,\n\t&dev_attr_upstream_crc_errors.attr,\n\t&dev_attr_startup_attempts.attr,\n\t&dev_attr_downstream_bits_per_frame.attr,\n\t&dev_attr_upstream_bits_per_frame.attr,\n\t&dev_attr_transmitter_power.attr,\n\t&dev_attr_downstream_attenuation.attr,\n\t&dev_attr_upstream_attenuation.attr,\n\t&dev_attr_downstream_snr_margin.attr,\n\t&dev_attr_upstream_snr_margin.attr,\n\t&dev_attr_mac_address.attr,\n\t&dev_attr_line_status.attr,\n\t&dev_attr_link_status.attr,\n\t&dev_attr_upstream_rate.attr,\n\t&dev_attr_downstream_rate.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cxacru);\n\n \nstatic void cxacru_blocking_completion(struct urb *urb)\n{\n\tcomplete(urb->context);\n}\n\nstruct cxacru_timer {\n\tstruct timer_list timer;\n\tstruct urb *urb;\n};\n\nstatic void cxacru_timeout_kill(struct timer_list *t)\n{\n\tstruct cxacru_timer *timer = from_timer(timer, t, timer);\n\n\tusb_unlink_urb(timer->urb);\n}\n\nstatic int cxacru_start_wait_urb(struct urb *urb, struct completion *done,\n\t\t\t\t int *actual_length)\n{\n\tstruct cxacru_timer timer = {\n\t\t.urb = urb,\n\t};\n\n\ttimer_setup_on_stack(&timer.timer, cxacru_timeout_kill, 0);\n\tmod_timer(&timer.timer, jiffies + msecs_to_jiffies(CMD_TIMEOUT));\n\twait_for_completion(done);\n\tdel_timer_sync(&timer.timer);\n\tdestroy_timer_on_stack(&timer.timer);\n\n\tif (actual_length)\n\t\t*actual_length = urb->actual_length;\n\treturn urb->status;  \n}\n\nstatic int cxacru_cm(struct cxacru_data *instance, enum cxacru_cm_request cm,\n\t\t     u8 *wdata, int wsize, u8 *rdata, int rsize)\n{\n\tint ret, actlen;\n\tint offb, offd;\n\tconst int stride = CMD_PACKET_SIZE - 4;\n\tu8 *wbuf = instance->snd_buf;\n\tu8 *rbuf = instance->rcv_buf;\n\tint wbuflen = ((wsize - 1) / stride + 1) * CMD_PACKET_SIZE;\n\tint rbuflen = ((rsize - 1) / stride + 1) * CMD_PACKET_SIZE;\n\n\tif (wbuflen > PAGE_SIZE || rbuflen > PAGE_SIZE) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"requested transfer size too large (%d, %d)\\n\",\n\t\t\t\twbuflen, rbuflen);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&instance->cm_serialize);\n\n\t \n\tinit_completion(&instance->rcv_done);\n\tret = usb_submit_urb(instance->rcv_urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"submit of read urb for cm %#x failed (%d)\\n\",\n\t\t\t\tcm, ret);\n\t\tgoto fail;\n\t}\n\n\tmemset(wbuf, 0, wbuflen);\n\t \n\twbuf[0] = cm;\n\tfor (offb = offd = 0; offd < wsize; offd += stride, offb += CMD_PACKET_SIZE) {\n\t\twbuf[offb] = cm;\n\t\tmemcpy(wbuf + offb + 4, wdata + offd, min_t(int, stride, wsize - offd));\n\t}\n\n\tinstance->snd_urb->transfer_buffer_length = wbuflen;\n\tinit_completion(&instance->snd_done);\n\tret = usb_submit_urb(instance->snd_urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"submit of write urb for cm %#x failed (%d)\\n\",\n\t\t\t\tcm, ret);\n\t\tgoto fail;\n\t}\n\n\tret = cxacru_start_wait_urb(instance->snd_urb, &instance->snd_done, NULL);\n\tif (ret < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"send of cm %#x failed (%d)\\n\", cm, ret);\n\t\tgoto fail;\n\t}\n\n\tret = cxacru_start_wait_urb(instance->rcv_urb, &instance->rcv_done, &actlen);\n\tif (ret < 0) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"receive of cm %#x failed (%d)\\n\", cm, ret);\n\t\tgoto fail;\n\t}\n\tif (actlen % CMD_PACKET_SIZE || !actlen) {\n\t\tif (printk_ratelimit())\n\t\t\tusb_err(instance->usbatm, \"invalid response length to cm %#x: %d\\n\",\n\t\t\t\tcm, actlen);\n\t\tret = -EIO;\n\t\tgoto fail;\n\t}\n\n\t \n\tfor (offb = offd = 0; offd < rsize && offb < actlen; offb += CMD_PACKET_SIZE) {\n\t\tif (rbuf[offb] != cm) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tusb_err(instance->usbatm, \"wrong cm %#x in response to cm %#x\\n\",\n\t\t\t\t\trbuf[offb], cm);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (rbuf[offb + 1] != CM_STATUS_SUCCESS) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tusb_err(instance->usbatm, \"response to cm %#x failed: %#x\\n\",\n\t\t\t\t\tcm, rbuf[offb + 1]);\n\t\t\tret = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (offd >= rsize)\n\t\t\tbreak;\n\t\tmemcpy(rdata + offd, rbuf + offb + 4, min_t(int, stride, rsize - offd));\n\t\toffd += stride;\n\t}\n\n\tret = offd;\n\tusb_dbg(instance->usbatm, \"cm %#x\\n\", cm);\nfail:\n\tmutex_unlock(&instance->cm_serialize);\nerr:\n\treturn ret;\n}\n\nstatic int cxacru_cm_get_array(struct cxacru_data *instance, enum cxacru_cm_request cm,\n\t\t\t       u32 *data, int size)\n{\n\tint ret, len;\n\t__le32 *buf;\n\tint offb;\n\tunsigned int offd;\n\tconst int stride = CMD_PACKET_SIZE / (4 * 2) - 1;\n\tint buflen =  ((size - 1) / stride + 1 + size * 2) * 4;\n\n\tbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = cxacru_cm(instance, cm, NULL, 0, (u8 *) buf, buflen);\n\tif (ret < 0)\n\t\tgoto cleanup;\n\n\t \n\tlen = ret / 4;\n\tfor (offb = 0; offb < len; ) {\n\t\tint l = le32_to_cpu(buf[offb++]);\n\n\t\tif (l < 0 || l > stride || l > (len - offb) / 2) {\n\t\t\tif (printk_ratelimit())\n\t\t\t\tusb_err(instance->usbatm, \"invalid data length from cm %#x: %d\\n\",\n\t\t\t\t\tcm, l);\n\t\t\tret = -EIO;\n\t\t\tgoto cleanup;\n\t\t}\n\t\twhile (l--) {\n\t\t\toffd = le32_to_cpu(buf[offb++]);\n\t\t\tif (offd >= size) {\n\t\t\t\tif (printk_ratelimit())\n\t\t\t\t\tusb_err(instance->usbatm, \"wrong index %#x in response to cm %#x\\n\",\n\t\t\t\t\t\toffd, cm);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\tdata[offd] = le32_to_cpu(buf[offb++]);\n\t\t}\n\t}\n\n\tret = 0;\n\ncleanup:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int cxacru_card_status(struct cxacru_data *instance)\n{\n\tint ret = cxacru_cm(instance, CM_REQUEST_CARD_GET_STATUS, NULL, 0, NULL, 0);\n\n\tif (ret < 0) {\t\t \n\t\tusb_dbg(instance->usbatm, \"cxacru_adsl_start: CARD_GET_STATUS returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int cxacru_atm_start(struct usbatm_data *usbatm_instance,\n\t\tstruct atm_dev *atm_dev)\n{\n\tstruct cxacru_data *instance = usbatm_instance->driver_data;\n\tstruct usb_interface *intf = usbatm_instance->usb_intf;\n\tint ret;\n\tint start_polling = 1;\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t \n\tret = cxacru_cm(instance, CM_REQUEST_CARD_GET_MAC_ADDRESS, NULL, 0,\n\t\t\tatm_dev->esi, sizeof(atm_dev->esi));\n\tif (ret < 0) {\n\t\tatm_err(usbatm_instance, \"cxacru_atm_start: CARD_GET_MAC_ADDRESS returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tmutex_lock(&instance->adsl_state_serialize);\n\tret = cxacru_cm(instance, CM_REQUEST_CHIP_ADSL_LINE_START, NULL, 0, NULL, 0);\n\tif (ret < 0)\n\t\tatm_err(usbatm_instance, \"cxacru_atm_start: CHIP_ADSL_LINE_START returned %d\\n\", ret);\n\n\t \n\tmutex_lock(&instance->poll_state_serialize);\n\tswitch (instance->poll_state) {\n\tcase CXPOLL_STOPPED:\n\t\t \n\t\tinstance->poll_state = CXPOLL_POLLING;\n\t\tbreak;\n\n\tcase CXPOLL_STOPPING:\n\t\t \n\t\tinstance->poll_state = CXPOLL_POLLING;\n\t\tfallthrough;\n\tcase CXPOLL_POLLING:\n\tcase CXPOLL_SHUTDOWN:\n\t\t \n\t\tstart_polling = 0;\n\t}\n\tmutex_unlock(&instance->poll_state_serialize);\n\tmutex_unlock(&instance->adsl_state_serialize);\n\n\tif (start_polling)\n\t\tcxacru_poll_status(&instance->poll_work.work);\n\treturn 0;\n}\n\nstatic void cxacru_poll_status(struct work_struct *work)\n{\n\tstruct cxacru_data *instance =\n\t\tcontainer_of(work, struct cxacru_data, poll_work.work);\n\tu32 buf[CXINF_MAX] = {};\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct atm_dev *atm_dev = usbatm->atm_dev;\n\tint keep_polling = 1;\n\tint ret;\n\n\tret = cxacru_cm_get_array(instance, CM_REQUEST_CARD_INFO_GET, buf, CXINF_MAX);\n\tif (ret < 0) {\n\t\tif (ret != -ESHUTDOWN)\n\t\t\tatm_warn(usbatm, \"poll status: error %d\\n\", ret);\n\n\t\tmutex_lock(&instance->poll_state_serialize);\n\t\tif (instance->poll_state != CXPOLL_SHUTDOWN) {\n\t\t\tinstance->poll_state = CXPOLL_STOPPED;\n\n\t\t\tif (ret != -ESHUTDOWN)\n\t\t\t\tatm_warn(usbatm, \"polling disabled, set adsl_state\"\n\t\t\t\t\t\t\" to 'start' or 'poll' to resume\\n\");\n\t\t}\n\t\tmutex_unlock(&instance->poll_state_serialize);\n\t\tgoto reschedule;\n\t}\n\n\tmemcpy(instance->card_info, buf, sizeof(instance->card_info));\n\n\tif (instance->adsl_status != buf[CXINF_LINE_STARTABLE]) {\n\t\tinstance->adsl_status = buf[CXINF_LINE_STARTABLE];\n\n\t\tswitch (instance->adsl_status) {\n\t\tcase 0:\n\t\t\tatm_info(usbatm, \"ADSL state: running\\n\");\n\t\t\tbreak;\n\n\t\tcase 1:\n\t\t\tatm_info(usbatm, \"ADSL state: stopped\\n\");\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tatm_info(usbatm, \"Unknown adsl status %02x\\n\", instance->adsl_status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (instance->line_status == buf[CXINF_LINE_STATUS])\n\t\tgoto reschedule;\n\n\tinstance->line_status = buf[CXINF_LINE_STATUS];\n\tswitch (instance->line_status) {\n\tcase 0:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: down\\n\");\n\t\tbreak;\n\n\tcase 1:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: attempting to activate\\n\");\n\t\tbreak;\n\n\tcase 2:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: training\\n\");\n\t\tbreak;\n\n\tcase 3:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: channel analysis\\n\");\n\t\tbreak;\n\n\tcase 4:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: exchange\\n\");\n\t\tbreak;\n\n\tcase 5:\n\t\tatm_dev->link_rate = buf[CXINF_DOWNSTREAM_RATE] * 1000 / 424;\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_FOUND);\n\n\t\tatm_info(usbatm, \"ADSL line: up (%d kb/s down | %d kb/s up)\\n\",\n\t\t     buf[CXINF_DOWNSTREAM_RATE], buf[CXINF_UPSTREAM_RATE]);\n\t\tbreak;\n\n\tcase 6:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: waiting\\n\");\n\t\tbreak;\n\n\tcase 7:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_LOST);\n\t\tatm_info(usbatm, \"ADSL line: initializing\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tatm_dev_signal_change(atm_dev, ATM_PHY_SIG_UNKNOWN);\n\t\tatm_info(usbatm, \"Unknown line state %02x\\n\", instance->line_status);\n\t\tbreak;\n\t}\nreschedule:\n\n\tmutex_lock(&instance->poll_state_serialize);\n\tif (instance->poll_state == CXPOLL_STOPPING &&\n\t\t\t\tinstance->adsl_status == 1 &&  \n\t\t\t\tinstance->line_status == 0)  \n\t\tinstance->poll_state = CXPOLL_STOPPED;\n\n\tif (instance->poll_state == CXPOLL_STOPPED)\n\t\tkeep_polling = 0;\n\tmutex_unlock(&instance->poll_state_serialize);\n\n\tif (keep_polling)\n\t\tschedule_delayed_work(&instance->poll_work,\n\t\t\t\tround_jiffies_relative(POLL_INTERVAL*HZ));\n}\n\nstatic int cxacru_fw(struct usb_device *usb_dev, enum cxacru_fw_request fw,\n\t\t     u8 code1, u8 code2, u32 addr, const u8 *data, int size)\n{\n\tint ret;\n\tu8 *buf;\n\tint offd, offb;\n\tconst int stride = CMD_PACKET_SIZE - 8;\n\n\tbuf = (u8 *) __get_free_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\toffb = offd = 0;\n\tdo {\n\t\tint l = min_t(int, stride, size - offd);\n\n\t\tbuf[offb++] = fw;\n\t\tbuf[offb++] = l;\n\t\tbuf[offb++] = code1;\n\t\tbuf[offb++] = code2;\n\t\tput_unaligned(cpu_to_le32(addr), (__le32 *)(buf + offb));\n\t\toffb += 4;\n\t\taddr += l;\n\t\tif (l)\n\t\t\tmemcpy(buf + offb, data + offd, l);\n\t\tif (l < stride)\n\t\t\tmemset(buf + offb + l, 0, stride - l);\n\t\toffb += stride;\n\t\toffd += stride;\n\t\tif ((offb >= PAGE_SIZE) || (offd >= size)) {\n\t\t\tret = usb_bulk_msg(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD),\n\t\t\t\t\t   buf, offb, NULL, CMD_TIMEOUT);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_dbg(&usb_dev->dev, \"sending fw %#x failed\\n\", fw);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\toffb = 0;\n\t\t}\n\t} while (offd < size);\n\tdev_dbg(&usb_dev->dev, \"sent fw %#x\\n\", fw);\n\n\tret = 0;\n\ncleanup:\n\tfree_page((unsigned long) buf);\n\treturn ret;\n}\n\nstatic void cxacru_upload_firmware(struct cxacru_data *instance,\n\t\t\t\t   const struct firmware *fw,\n\t\t\t\t   const struct firmware *bp)\n{\n\tint ret;\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct usb_device *usb_dev = usbatm->usb_dev;\n\t__le16 signature[] = { usb_dev->descriptor.idVendor,\n\t\t\t       usb_dev->descriptor.idProduct };\n\t__le32 val;\n\n\tusb_dbg(usbatm, \"%s\\n\", __func__);\n\n\t \n\tval = cpu_to_le32(instance->modem_type->pll_f_clk);\n\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, PLLFCLK_ADDR, (u8 *) &val, 4);\n\tif (ret) {\n\t\tusb_err(usbatm, \"FirmwarePllFClkValue failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tval = cpu_to_le32(instance->modem_type->pll_b_clk);\n\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, PLLBCLK_ADDR, (u8 *) &val, 4);\n\tif (ret) {\n\t\tusb_err(usbatm, \"FirmwarePllBClkValue failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tval = cpu_to_le32(SDRAM_ENA);\n\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, SDRAMEN_ADDR, (u8 *) &val, 4);\n\tif (ret) {\n\t\tusb_err(usbatm, \"Enable SDRAM failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tusb_info(usbatm, \"loading firmware\\n\");\n\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, FW_ADDR, fw->data, fw->size);\n\tif (ret) {\n\t\tusb_err(usbatm, \"Firmware upload failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tif (instance->modem_type->boot_rom_patch) {\n\t\tusb_info(usbatm, \"loading boot ROM patch\\n\");\n\t\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, BR_ADDR, bp->data, bp->size);\n\t\tif (ret) {\n\t\t\tusb_err(usbatm, \"Boot ROM patching failed: %d\\n\", ret);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, SIG_ADDR, (u8 *) signature, 4);\n\tif (ret) {\n\t\tusb_err(usbatm, \"Signature storing failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tusb_info(usbatm, \"starting device\\n\");\n\tif (instance->modem_type->boot_rom_patch) {\n\t\tval = cpu_to_le32(BR_ADDR);\n\t\tret = cxacru_fw(usb_dev, FW_WRITE_MEM, 0x2, 0x0, BR_STACK_ADDR, (u8 *) &val, 4);\n\t} else {\n\t\tret = cxacru_fw(usb_dev, FW_GOTO_MEM, 0x0, 0x0, FW_ADDR, NULL, 0);\n\t}\n\tif (ret) {\n\t\tusb_err(usbatm, \"Passing control to firmware failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tmsleep_interruptible(1000);\n\n\tusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD));\n\tusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_CMD));\n\tusb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_DATA));\n\tusb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_DATA));\n\n\tret = cxacru_cm(instance, CM_REQUEST_CARD_GET_STATUS, NULL, 0, NULL, 0);\n\tif (ret < 0) {\n\t\tusb_err(usbatm, \"modem failed to initialize: %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nstatic int cxacru_find_firmware(struct cxacru_data *instance,\n\t\t\t\tchar *phase, const struct firmware **fw_p)\n{\n\tstruct usbatm_data *usbatm = instance->usbatm;\n\tstruct device *dev = &usbatm->usb_intf->dev;\n\tchar buf[16];\n\n\tsprintf(buf, \"cxacru-%s.bin\", phase);\n\tusb_dbg(usbatm, \"cxacru_find_firmware: looking for %s\\n\", buf);\n\n\tif (request_firmware(fw_p, buf, dev)) {\n\t\tusb_dbg(usbatm, \"no stage %s firmware found\\n\", phase);\n\t\treturn -ENOENT;\n\t}\n\n\tusb_info(usbatm, \"found firmware %s\\n\", buf);\n\n\treturn 0;\n}\n\nstatic int cxacru_heavy_init(struct usbatm_data *usbatm_instance,\n\t\t\t     struct usb_interface *usb_intf)\n{\n\tconst struct firmware *fw, *bp;\n\tstruct cxacru_data *instance = usbatm_instance->driver_data;\n\tint ret = cxacru_find_firmware(instance, \"fw\", &fw);\n\n\tif (ret) {\n\t\tusb_warn(usbatm_instance, \"firmware (cxacru-fw.bin) unavailable (system misconfigured?)\\n\");\n\t\treturn ret;\n\t}\n\n\tif (instance->modem_type->boot_rom_patch) {\n\t\tret = cxacru_find_firmware(instance, \"bp\", &bp);\n\t\tif (ret) {\n\t\t\tusb_warn(usbatm_instance, \"boot ROM patch (cxacru-bp.bin) unavailable (system misconfigured?)\\n\");\n\t\t\trelease_firmware(fw);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcxacru_upload_firmware(instance, fw, bp);\n\n\tif (instance->modem_type->boot_rom_patch)\n\t\trelease_firmware(bp);\n\trelease_firmware(fw);\n\n\tret = cxacru_card_status(instance);\n\tif (ret)\n\t\tusb_dbg(usbatm_instance, \"modem initialisation failed\\n\");\n\telse\n\t\tusb_dbg(usbatm_instance, \"done setting up the modem\\n\");\n\n\treturn ret;\n}\n\nstatic int cxacru_bind(struct usbatm_data *usbatm_instance,\n\t\t       struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct cxacru_data *instance;\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct usb_host_endpoint *cmd_ep = usb_dev->ep_in[CXACRU_EP_CMD];\n\tint ret;\n\n\t \n\tinstance = kzalloc(sizeof(*instance), GFP_KERNEL);\n\tif (!instance)\n\t\treturn -ENOMEM;\n\n\tinstance->usbatm = usbatm_instance;\n\tinstance->modem_type = (struct cxacru_modem_type *) id->driver_info;\n\n\tmutex_init(&instance->poll_state_serialize);\n\tinstance->poll_state = CXPOLL_STOPPED;\n\tinstance->line_status = -1;\n\tinstance->adsl_status = -1;\n\n\tmutex_init(&instance->adsl_state_serialize);\n\n\tinstance->rcv_buf = (u8 *) __get_free_page(GFP_KERNEL);\n\tif (!instance->rcv_buf) {\n\t\tusb_dbg(usbatm_instance, \"cxacru_bind: no memory for rcv_buf\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tinstance->snd_buf = (u8 *) __get_free_page(GFP_KERNEL);\n\tif (!instance->snd_buf) {\n\t\tusb_dbg(usbatm_instance, \"cxacru_bind: no memory for snd_buf\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tinstance->rcv_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!instance->rcv_urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tinstance->snd_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!instance->snd_urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tif (!cmd_ep) {\n\t\tusb_dbg(usbatm_instance, \"cxacru_bind: no command endpoint\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tif ((cmd_ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK)\n\t\t\t== USB_ENDPOINT_XFER_INT) {\n\t\tusb_fill_int_urb(instance->rcv_urb,\n\t\t\tusb_dev, usb_rcvintpipe(usb_dev, CXACRU_EP_CMD),\n\t\t\tinstance->rcv_buf, PAGE_SIZE,\n\t\t\tcxacru_blocking_completion, &instance->rcv_done, 1);\n\n\t\tusb_fill_int_urb(instance->snd_urb,\n\t\t\tusb_dev, usb_sndintpipe(usb_dev, CXACRU_EP_CMD),\n\t\t\tinstance->snd_buf, PAGE_SIZE,\n\t\t\tcxacru_blocking_completion, &instance->snd_done, 4);\n\t} else {\n\t\tusb_fill_bulk_urb(instance->rcv_urb,\n\t\t\tusb_dev, usb_rcvbulkpipe(usb_dev, CXACRU_EP_CMD),\n\t\t\tinstance->rcv_buf, PAGE_SIZE,\n\t\t\tcxacru_blocking_completion, &instance->rcv_done);\n\n\t\tusb_fill_bulk_urb(instance->snd_urb,\n\t\t\tusb_dev, usb_sndbulkpipe(usb_dev, CXACRU_EP_CMD),\n\t\t\tinstance->snd_buf, PAGE_SIZE,\n\t\t\tcxacru_blocking_completion, &instance->snd_done);\n\t}\n\n\tmutex_init(&instance->cm_serialize);\n\n\tINIT_DELAYED_WORK(&instance->poll_work, cxacru_poll_status);\n\n\tusbatm_instance->driver_data = instance;\n\n\tusbatm_instance->flags = (cxacru_card_status(instance) ? 0 : UDSL_SKIP_HEAVY_INIT);\n\n\treturn 0;\n\n fail:\n\tfree_page((unsigned long) instance->snd_buf);\n\tfree_page((unsigned long) instance->rcv_buf);\n\tusb_free_urb(instance->snd_urb);\n\tusb_free_urb(instance->rcv_urb);\n\tkfree(instance);\n\n\treturn ret;\n}\n\nstatic void cxacru_unbind(struct usbatm_data *usbatm_instance,\n\t\tstruct usb_interface *intf)\n{\n\tstruct cxacru_data *instance = usbatm_instance->driver_data;\n\tint is_polling = 1;\n\n\tusb_dbg(usbatm_instance, \"cxacru_unbind entered\\n\");\n\n\tif (!instance) {\n\t\tusb_dbg(usbatm_instance, \"cxacru_unbind: NULL instance!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&instance->poll_state_serialize);\n\tBUG_ON(instance->poll_state == CXPOLL_SHUTDOWN);\n\n\t \n\tif (instance->poll_state == CXPOLL_STOPPED)\n\t\tis_polling = 0;\n\n\t \n\tinstance->poll_state = CXPOLL_SHUTDOWN;\n\tmutex_unlock(&instance->poll_state_serialize);\n\n\tif (is_polling)\n\t\tcancel_delayed_work_sync(&instance->poll_work);\n\n\tusb_kill_urb(instance->snd_urb);\n\tusb_kill_urb(instance->rcv_urb);\n\tusb_free_urb(instance->snd_urb);\n\tusb_free_urb(instance->rcv_urb);\n\n\tfree_page((unsigned long) instance->snd_buf);\n\tfree_page((unsigned long) instance->rcv_buf);\n\n\tkfree(instance);\n\n\tusbatm_instance->driver_data = NULL;\n}\n\nstatic const struct cxacru_modem_type cxacru_cafe = {\n\t.pll_f_clk = 0x02d874df,\n\t.pll_b_clk = 0x0196a51a,\n\t.boot_rom_patch = 1,\n};\n\nstatic const struct cxacru_modem_type cxacru_cb00 = {\n\t.pll_f_clk = 0x5,\n\t.pll_b_clk = 0x3,\n\t.boot_rom_patch = 0,\n};\n\nstatic const struct usb_device_id cxacru_usb_ids[] = {\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcafe),\t.driver_info = (unsigned long) &cxacru_cafe\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcb00),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcb01),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcb02),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcb06),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0572, 0xcb07),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x08e3, 0x0100),\t.driver_info = (unsigned long) &cxacru_cafe\n\t},\n\t{  \n\t\tUSB_DEVICE(0x08e3, 0x0102),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0eb0, 0x3457),\t.driver_info = (unsigned long) &cxacru_cafe\n\t},\n\t{  \n\t\tUSB_DEVICE(0x1803, 0x5510),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0675, 0x0200),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0586, 0x330a),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0586, 0x330b),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0659, 0x0020),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x0509, 0x0812),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x100d, 0xcb01),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{  \n\t\tUSB_DEVICE(0x100d, 0x3342),\t.driver_info = (unsigned long) &cxacru_cb00\n\t},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, cxacru_usb_ids);\n\nstatic struct usbatm_driver cxacru_driver = {\n\t.driver_name\t= cxacru_driver_name,\n\t.bind\t\t= cxacru_bind,\n\t.heavy_init\t= cxacru_heavy_init,\n\t.unbind\t\t= cxacru_unbind,\n\t.atm_start\t= cxacru_atm_start,\n\t.bulk_in\t= CXACRU_EP_DATA,\n\t.bulk_out\t= CXACRU_EP_DATA,\n\t.rx_padding\t= 3,\n\t.tx_padding\t= 11,\n};\n\nstatic int cxacru_usb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tchar buf[15];\n\n\t \n\tif (usb_dev->descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC\n\t\t\t&& usb_string(usb_dev, usb_dev->descriptor.iProduct,\n\t\t\t\tbuf, sizeof(buf)) > 0) {\n\t\tif (!strcmp(buf, \"USB NET CARD\")) {\n\t\t\tdev_info(&intf->dev, \"ignoring cx82310_eth device\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn usbatm_usb_probe(intf, id, &cxacru_driver);\n}\n\nstatic struct usb_driver cxacru_usb_driver = {\n\t.name\t\t= cxacru_driver_name,\n\t.probe\t\t= cxacru_usb_probe,\n\t.disconnect\t= usbatm_usb_disconnect,\n\t.id_table\t= cxacru_usb_ids,\n\t.dev_groups\t= cxacru_groups,\n};\n\nmodule_usb_driver(cxacru_usb_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}