{
  "module_name": "sddr09.c",
  "hash_id": "0a97fac4ad60fb4048d68fa9cb85550898548e16e917387d9b7fca4c79a476c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/sddr09.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-sddr09\"\n\nMODULE_DESCRIPTION(\"Driver for SanDisk SDDR-09 SmartMedia reader\");\nMODULE_AUTHOR(\"Andries Brouwer <aeb@cwi.nl>, Robert Baruch <autophile@starband.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\nstatic int usb_stor_sddr09_dpcm_init(struct us_data *us);\nstatic int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us);\nstatic int usb_stor_sddr09_init(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id sddr09_usb_ids[] = {\n#\tinclude \"unusual_sddr09.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, sddr09_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev sddr09_unusual_dev_list[] = {\n#\tinclude \"unusual_sddr09.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )\n#define LSB_of(s) ((s)&0xFF)\n#define MSB_of(s) ((s)>>8)\n\n \n\nstruct nand_flash_dev {\n\tint model_id;\n\tint chipshift;\t\t \n\tchar pageshift;\t\t \n\tchar blockshift;\t \n\tchar zoneshift;\t\t \n\t\t\t\t \n\tchar pageadrlen;\t \n};\n\n \n#define NAND_MFR_AMD\t\t0x01\n#define NAND_MFR_NATSEMI\t0x8f\n#define NAND_MFR_TOSHIBA\t0x98\n#define NAND_MFR_SAMSUNG\t0xec\n\nstatic inline char *nand_flash_manufacturer(int manuf_id) {\n\tswitch(manuf_id) {\n\tcase NAND_MFR_AMD:\n\t\treturn \"AMD\";\n\tcase NAND_MFR_NATSEMI:\n\t\treturn \"NATSEMI\";\n\tcase NAND_MFR_TOSHIBA:\n\t\treturn \"Toshiba\";\n\tcase NAND_MFR_SAMSUNG:\n\t\treturn \"Samsung\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \n\nstatic struct nand_flash_dev nand_flash_ids[] = {\n\t \n\t{ 0x6e, 20, 8, 4, 8, 2},\t \n\t{ 0xe8, 20, 8, 4, 8, 2},\t \n\t{ 0xec, 20, 8, 4, 8, 2},\t \n\t{ 0x64, 21, 8, 4, 9, 2}, \t \n\t{ 0xea, 21, 8, 4, 9, 2},\t \n\t{ 0x6b, 22, 9, 4, 9, 2},\t \n\t{ 0xe3, 22, 9, 4, 9, 2},\t \n\t{ 0xe5, 22, 9, 4, 9, 2},\t \n\t{ 0xe6, 23, 9, 4, 10, 2},\t \n\t{ 0x73, 24, 9, 5, 10, 2},\t \n\t{ 0x75, 25, 9, 5, 10, 2},\t \n\t{ 0x76, 26, 9, 5, 10, 3},\t \n\t{ 0x79, 27, 9, 5, 10, 3},\t \n\n\t \n\t{ 0x5d, 21, 9, 4, 8, 2},\t \n\t{ 0xd5, 22, 9, 4, 9, 2},\t \n\t{ 0xd6, 23, 9, 4, 10, 2},\t \n\t{ 0x57, 24, 9, 4, 11, 2},\t \n\t{ 0x58, 25, 9, 4, 12, 2},\t \n\t{ 0,}\n};\n\nstatic struct nand_flash_dev *\nnand_find_id(unsigned char id) {\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(nand_flash_ids); i++)\n\t\tif (nand_flash_ids[i].model_id == id)\n\t\t\treturn &(nand_flash_ids[i]);\n\treturn NULL;\n}\n\n \nstatic unsigned char parity[256];\nstatic unsigned char ecc2[256];\n\nstatic void nand_init_ecc(void) {\n\tint i, j, a;\n\n\tparity[0] = 0;\n\tfor (i = 1; i < 256; i++)\n\t\tparity[i] = (parity[i&(i-1)] ^ 1);\n\n\tfor (i = 0; i < 256; i++) {\n\t\ta = 0;\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (i & (1<<j)) {\n\t\t\t\tif ((j & 1) == 0)\n\t\t\t\t\ta ^= 0x04;\n\t\t\t\tif ((j & 2) == 0)\n\t\t\t\t\ta ^= 0x10;\n\t\t\t\tif ((j & 4) == 0)\n\t\t\t\t\ta ^= 0x40;\n\t\t\t}\n\t\t}\n\t\tecc2[i] = ~(a ^ (a<<1) ^ (parity[i] ? 0xa8 : 0));\n\t}\n}\n\n \nstatic void nand_compute_ecc(unsigned char *data, unsigned char *ecc) {\n\tint i, j, a;\n\tunsigned char par = 0, bit, bits[8] = {0};\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tpar ^= data[i];\n\t\tbit = parity[data[i]];\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tif ((i & (1<<j)) == 0)\n\t\t\t\tbits[j] ^= bit;\n\t}\n\n\t \n\ta = (bits[3] << 6) + (bits[2] << 4) + (bits[1] << 2) + bits[0];\n\tecc[0] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\n\n\ta = (bits[7] << 6) + (bits[6] << 4) + (bits[5] << 2) + bits[4];\n\tecc[1] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\n\n\tecc[2] = ecc2[par];\n}\n\nstatic int nand_compare_ecc(unsigned char *data, unsigned char *ecc) {\n\treturn (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);\n}\n\nstatic void nand_store_ecc(unsigned char *data, unsigned char *ecc) {\n\tmemcpy(data, ecc, 3);\n}\n\n \n\nstruct sddr09_card_info {\n\tunsigned long\tcapacity;\t \n\tint\t\tpagesize;\t \n\tint\t\tpageshift;\t \n\tint\t\tblocksize;\t \n\tint\t\tblockshift;\t \n\tint\t\tblockmask;\t \n\tint\t\t*lba_to_pba;\t \n\tint\t\t*pba_to_lba;\t \n\tint\t\tlbact;\t\t \n\tint\t\tflags;\n#define\tSDDR09_WP\t1\t\t \n};\n\n \n#define CONTROL_SHIFT 6\n\n \n#define LUN\t1\n#define\tLUNBITS\t(LUN << 5)\n\n \n#define UNDEF    0xffffffff\n#define SPARE    0xfffffffe\n#define UNUSABLE 0xfffffffd\n\nstatic const int erase_bad_lba_entries = 0;\n\n \n \nstatic int\nsddr09_send_command(struct us_data *us,\n\t\t    unsigned char request,\n\t\t    unsigned char direction,\n\t\t    unsigned char *xfer_data,\n\t\t    unsigned int xfer_len) {\n\tunsigned int pipe;\n\tunsigned char requesttype = (0x41 | direction);\n\tint rc;\n\n\t \n\n\tif (direction == USB_DIR_IN)\n\t\tpipe = us->recv_ctrl_pipe;\n\telse\n\t\tpipe = us->send_ctrl_pipe;\n\n\trc = usb_stor_ctrl_transfer(us, pipe, request, requesttype,\n\t\t\t\t   0, 0, xfer_data, xfer_len);\n\tswitch (rc) {\n\t\tcase USB_STOR_XFER_GOOD:\treturn 0;\n\t\tcase USB_STOR_XFER_STALLED:\treturn -EPIPE;\n\t\tdefault:\t\t\treturn -EIO;\n\t}\n}\n\nstatic int\nsddr09_send_scsi_command(struct us_data *us,\n\t\t\t unsigned char *command,\n\t\t\t unsigned int command_len) {\n\treturn sddr09_send_command(us, 0, USB_DIR_OUT, command, command_len);\n}\n\n#if 0\n \nstatic int\nsddr09_test_unit_ready(struct us_data *us) {\n\tunsigned char *command = us->iobuf;\n\tint result;\n\n\tmemset(command, 0, 6);\n\tcommand[1] = LUNBITS;\n\n\tresult = sddr09_send_scsi_command(us, command, 6);\n\n\tusb_stor_dbg(us, \"sddr09_test_unit_ready returns %d\\n\", result);\n\n\treturn result;\n}\n#endif\n\n \nstatic int\nsddr09_request_sense(struct us_data *us, unsigned char *sensebuf, int buflen) {\n\tunsigned char *command = us->iobuf;\n\tint result;\n\n\tmemset(command, 0, 12);\n\tcommand[0] = 0x03;\n\tcommand[1] = LUNBITS;\n\tcommand[4] = buflen;\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\tif (result)\n\t\treturn result;\n\n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\tsensebuf, buflen, NULL);\n\treturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\n}\n\n \n\nstatic int\nsddr09_readX(struct us_data *us, int x, unsigned long fromaddress,\n\t     int nr_of_pages, int bulklen, unsigned char *buf,\n\t     int use_sg) {\n\n\tunsigned char *command = us->iobuf;\n\tint result;\n\n\tcommand[0] = 0xE8;\n\tcommand[1] = LUNBITS | x;\n\tcommand[2] = MSB_of(fromaddress>>16);\n\tcommand[3] = LSB_of(fromaddress>>16); \n\tcommand[4] = MSB_of(fromaddress & 0xFFFF);\n\tcommand[5] = LSB_of(fromaddress & 0xFFFF); \n\tcommand[6] = 0;\n\tcommand[7] = 0;\n\tcommand[8] = 0;\n\tcommand[9] = 0;\n\tcommand[10] = MSB_of(nr_of_pages);\n\tcommand[11] = LSB_of(nr_of_pages);\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\n\tif (result) {\n\t\tusb_stor_dbg(us, \"Result for send_control in sddr09_read2%d %d\\n\",\n\t\t\t     x, result);\n\t\treturn result;\n\t}\n\n\tresult = usb_stor_bulk_transfer_sg(us, us->recv_bulk_pipe,\n\t\t\t\t       buf, bulklen, use_sg, NULL);\n\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Result for bulk_transfer in sddr09_read2%d %d\\n\",\n\t\t\t     x, result);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nsddr09_read20(struct us_data *us, unsigned long fromaddress,\n\t      int nr_of_pages, int pageshift, unsigned char *buf, int use_sg) {\n\tint bulklen = nr_of_pages << pageshift;\n\n\t \n\treturn sddr09_readX(us, 0, fromaddress, nr_of_pages, bulklen,\n\t\t\t    buf, use_sg);\n}\n\n \nstatic int\nsddr09_read21(struct us_data *us, unsigned long fromaddress,\n\t      int count, int controlshift, unsigned char *buf, int use_sg) {\n\n\tint bulklen = (count << controlshift);\n\treturn sddr09_readX(us, 1, fromaddress, count, bulklen,\n\t\t\t    buf, use_sg);\n}\n\n \nstatic int\nsddr09_read22(struct us_data *us, unsigned long fromaddress,\n\t      int nr_of_pages, int pageshift, unsigned char *buf, int use_sg) {\n\n\tint bulklen = (nr_of_pages << pageshift) + (nr_of_pages << CONTROL_SHIFT);\n\tusb_stor_dbg(us, \"reading %d pages, %d bytes\\n\", nr_of_pages, bulklen);\n\treturn sddr09_readX(us, 2, fromaddress, nr_of_pages, bulklen,\n\t\t\t    buf, use_sg);\n}\n\n#if 0\n \nstatic int\nsddr09_read23(struct us_data *us, unsigned long fromaddress,\n\t      int count, int controlshift, unsigned char *buf, int use_sg) {\n\n\tint bulklen = (count << controlshift);\n\treturn sddr09_readX(us, 3, fromaddress, count, bulklen,\n\t\t\t    buf, use_sg);\n}\n#endif\n\n \nstatic int\nsddr09_erase(struct us_data *us, unsigned long Eaddress) {\n\tunsigned char *command = us->iobuf;\n\tint result;\n\n\tusb_stor_dbg(us, \"erase address %lu\\n\", Eaddress);\n\n\tmemset(command, 0, 12);\n\tcommand[0] = 0xEA;\n\tcommand[1] = LUNBITS;\n\tcommand[6] = MSB_of(Eaddress>>16);\n\tcommand[7] = LSB_of(Eaddress>>16);\n\tcommand[8] = MSB_of(Eaddress & 0xFFFF);\n\tcommand[9] = LSB_of(Eaddress & 0xFFFF);\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\n\tif (result)\n\t\tusb_stor_dbg(us, \"Result for send_control in sddr09_erase %d\\n\",\n\t\t\t     result);\n\n\treturn result;\n}\n\n \n\n \nstatic int\nsddr09_writeX(struct us_data *us,\n\t      unsigned long Waddress, unsigned long Eaddress,\n\t      int nr_of_pages, int bulklen, unsigned char *buf, int use_sg) {\n\n\tunsigned char *command = us->iobuf;\n\tint result;\n\n\tcommand[0] = 0xE9;\n\tcommand[1] = LUNBITS;\n\n\tcommand[2] = MSB_of(Waddress>>16);\n\tcommand[3] = LSB_of(Waddress>>16);\n\tcommand[4] = MSB_of(Waddress & 0xFFFF);\n\tcommand[5] = LSB_of(Waddress & 0xFFFF);\n\n\tcommand[6] = MSB_of(Eaddress>>16);\n\tcommand[7] = LSB_of(Eaddress>>16);\n\tcommand[8] = MSB_of(Eaddress & 0xFFFF);\n\tcommand[9] = LSB_of(Eaddress & 0xFFFF);\n\n\tcommand[10] = MSB_of(nr_of_pages);\n\tcommand[11] = LSB_of(nr_of_pages);\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\n\tif (result) {\n\t\tusb_stor_dbg(us, \"Result for send_control in sddr09_writeX %d\\n\",\n\t\t\t     result);\n\t\treturn result;\n\t}\n\n\tresult = usb_stor_bulk_transfer_sg(us, us->send_bulk_pipe,\n\t\t\t\t       buf, bulklen, use_sg, NULL);\n\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Result for bulk_transfer in sddr09_writeX %d\\n\",\n\t\t\t     result);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nsddr09_write_inplace(struct us_data *us, unsigned long address,\n\t\t     int nr_of_pages, int pageshift, unsigned char *buf,\n\t\t     int use_sg) {\n\tint bulklen = (nr_of_pages << pageshift) + (nr_of_pages << CONTROL_SHIFT);\n\treturn sddr09_writeX(us, address, address, nr_of_pages, bulklen,\n\t\t\t     buf, use_sg);\n}\n\n#if 0\n \nstatic int\nsddr09_read_sg_test_only(struct us_data *us) {\n\tunsigned char *command = us->iobuf;\n\tint result, bulklen, nsg, ct;\n\tunsigned char *buf;\n\tunsigned long address;\n\n\tnsg = bulklen = 0;\n\tcommand[0] = 0xE7;\n\tcommand[1] = LUNBITS;\n\tcommand[2] = 0;\n\taddress = 040000; ct = 1;\n\tnsg++;\n\tbulklen += (ct << 9);\n\tcommand[4*nsg+2] = ct;\n\tcommand[4*nsg+1] = ((address >> 9) & 0xFF);\n\tcommand[4*nsg+0] = ((address >> 17) & 0xFF);\n\tcommand[4*nsg-1] = ((address >> 25) & 0xFF);\n\n\taddress = 0340000; ct = 1;\n\tnsg++;\n\tbulklen += (ct << 9);\n\tcommand[4*nsg+2] = ct;\n\tcommand[4*nsg+1] = ((address >> 9) & 0xFF);\n\tcommand[4*nsg+0] = ((address >> 17) & 0xFF);\n\tcommand[4*nsg-1] = ((address >> 25) & 0xFF);\n\n\taddress = 01000000; ct = 2;\n\tnsg++;\n\tbulklen += (ct << 9);\n\tcommand[4*nsg+2] = ct;\n\tcommand[4*nsg+1] = ((address >> 9) & 0xFF);\n\tcommand[4*nsg+0] = ((address >> 17) & 0xFF);\n\tcommand[4*nsg-1] = ((address >> 25) & 0xFF);\n\n\tcommand[2] = nsg;\n\n\tresult = sddr09_send_scsi_command(us, command, 4*nsg+3);\n\n\tif (result) {\n\t\tusb_stor_dbg(us, \"Result for send_control in sddr09_read_sg %d\\n\",\n\t\t\t     result);\n\t\treturn result;\n\t}\n\n\tbuf = kmalloc(bulklen, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\t       buf, bulklen, NULL);\n\tkfree(buf);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Result for bulk_transfer in sddr09_read_sg %d\\n\",\n\t\t\t     result);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n#endif\n\n \n\nstatic int\nsddr09_read_status(struct us_data *us, unsigned char *status) {\n\n\tunsigned char *command = us->iobuf;\n\tunsigned char *data = us->iobuf;\n\tint result;\n\n\tusb_stor_dbg(us, \"Reading status...\\n\");\n\n\tmemset(command, 0, 12);\n\tcommand[0] = 0xEC;\n\tcommand[1] = LUNBITS;\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\tif (result)\n\t\treturn result;\n\n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\t       data, 64, NULL);\n\t*status = data[0];\n\treturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\n}\n\nstatic int\nsddr09_read_data(struct us_data *us,\n\t\t unsigned long address,\n\t\t unsigned int sectors) {\n\n\tstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\n\tunsigned char *buffer;\n\tunsigned int lba, maxlba, pba;\n\tunsigned int page, pages;\n\tunsigned int len, offset;\n\tstruct scatterlist *sg;\n\tint result;\n\n\t\n\tlba = address >> info->blockshift;\n\tpage = (address & info->blockmask);\n\tmaxlba = info->capacity >> (info->pageshift + info->blockshift);\n\tif (lba >= maxlba)\n\t\treturn -EIO;\n\n\t\n\t\n\t\n\n\tlen = min(sectors, (unsigned int) info->blocksize) * info->pagesize;\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\t\n\t\n\n\tresult = 0;\n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors > 0) {\n\n\t\t \n\t\tpages = min(sectors, info->blocksize - page);\n\t\tlen = pages << info->pageshift;\n\n\t\t \n\t\tif (lba >= maxlba) {\n\t\t\tusb_stor_dbg(us, \"Error: Requested lba %u exceeds maximum %u\\n\",\n\t\t\t\t     lba, maxlba);\n\t\t\tresult = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpba = info->lba_to_pba[lba];\n\n\t\tif (pba == UNDEF) {\t \n\n\t\t\tusb_stor_dbg(us, \"Read %d zero pages (LBA %d) page %d\\n\",\n\t\t\t\t     pages, lba, page);\n\n\t\t\t \n\n\t\t\tmemset(buffer, 0, len);\n\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"Read %d pages, from PBA %d (LBA %d) page %d\\n\",\n\t\t\t\t     pages, pba, lba, page);\n\n\t\t\taddress = ((pba << info->blockshift) + page) << \n\t\t\t\tinfo->pageshift;\n\n\t\t\tresult = sddr09_read20(us, address>>1,\n\t\t\t\t\tpages, info->pageshift, buffer, 0);\n\t\t\tif (result)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, TO_XFER_BUF);\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages;\n\t}\n\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic unsigned int\nsddr09_find_unused_pba(struct sddr09_card_info *info, unsigned int lba) {\n\tstatic unsigned int lastpba = 1;\n\tint zonestart, end, i;\n\n\tzonestart = (lba/1000) << 10;\n\tend = info->capacity >> (info->blockshift + info->pageshift);\n\tend -= zonestart;\n\tif (end > 1024)\n\t\tend = 1024;\n\n\tfor (i = lastpba+1; i < end; i++) {\n\t\tif (info->pba_to_lba[zonestart+i] == UNDEF) {\n\t\t\tlastpba = i;\n\t\t\treturn zonestart+i;\n\t\t}\n\t}\n\tfor (i = 0; i <= lastpba; i++) {\n\t\tif (info->pba_to_lba[zonestart+i] == UNDEF) {\n\t\t\tlastpba = i;\n\t\t\treturn zonestart+i;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int\nsddr09_write_lba(struct us_data *us, unsigned int lba,\n\t\t unsigned int page, unsigned int pages,\n\t\t unsigned char *ptr, unsigned char *blockbuffer) {\n\n\tstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\n\tunsigned long address;\n\tunsigned int pba, lbap;\n\tunsigned int pagelen;\n\tunsigned char *bptr, *cptr, *xptr;\n\tunsigned char ecc[3];\n\tint i, result;\n\n\tlbap = ((lba % 1000) << 1) | 0x1000;\n\tif (parity[MSB_of(lbap) ^ LSB_of(lbap)])\n\t\tlbap ^= 1;\n\tpba = info->lba_to_pba[lba];\n\n\tif (pba == UNDEF) {\n\t\tpba = sddr09_find_unused_pba(info, lba);\n\t\tif (!pba) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09_write_lba: Out of unused blocks\\n\");\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tinfo->pba_to_lba[pba] = lba;\n\t\tinfo->lba_to_pba[lba] = pba;\n\t}\n\n\tif (pba == 1) {\n\t\t \n\t\tprintk(KERN_WARNING \"sddr09: avoid writing to pba 1\\n\");\n\t\treturn 0;\n\t}\n\n\tpagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);\n\n\t \n\taddress = (pba << (info->pageshift + info->blockshift));\n\tresult = sddr09_read22(us, address>>1, info->blocksize,\n\t\t\t       info->pageshift, blockbuffer, 0);\n\tif (result)\n\t\treturn result;\n\n\t \n\tfor (i = 0; i < info->blocksize; i++) {\n\t\tbptr = blockbuffer + i*pagelen;\n\t\tcptr = bptr + info->pagesize;\n\t\tnand_compute_ecc(bptr, ecc);\n\t\tif (!nand_compare_ecc(cptr+13, ecc)) {\n\t\t\tusb_stor_dbg(us, \"Warning: bad ecc in page %d- of pba %d\\n\",\n\t\t\t\t     i, pba);\n\t\t\tnand_store_ecc(cptr+13, ecc);\n\t\t}\n\t\tnand_compute_ecc(bptr+(info->pagesize / 2), ecc);\n\t\tif (!nand_compare_ecc(cptr+8, ecc)) {\n\t\t\tusb_stor_dbg(us, \"Warning: bad ecc in page %d+ of pba %d\\n\",\n\t\t\t\t     i, pba);\n\t\t\tnand_store_ecc(cptr+8, ecc);\n\t\t}\n\t\tcptr[6] = cptr[11] = MSB_of(lbap);\n\t\tcptr[7] = cptr[12] = LSB_of(lbap);\n\t}\n\n\t \n\txptr = ptr;\n\tfor (i = page; i < page+pages; i++) {\n\t\tbptr = blockbuffer + i*pagelen;\n\t\tcptr = bptr + info->pagesize;\n\t\tmemcpy(bptr, xptr, info->pagesize);\n\t\txptr += info->pagesize;\n\t\tnand_compute_ecc(bptr, ecc);\n\t\tnand_store_ecc(cptr+13, ecc);\n\t\tnand_compute_ecc(bptr+(info->pagesize / 2), ecc);\n\t\tnand_store_ecc(cptr+8, ecc);\n\t}\n\n\tusb_stor_dbg(us, \"Rewrite PBA %d (LBA %d)\\n\", pba, lba);\n\n\tresult = sddr09_write_inplace(us, address>>1, info->blocksize,\n\t\t\t\t      info->pageshift, blockbuffer, 0);\n\n\tusb_stor_dbg(us, \"sddr09_write_inplace returns %d\\n\", result);\n\n#if 0\n\t{\n\t\tunsigned char status = 0;\n\t\tint result2 = sddr09_read_status(us, &status);\n\t\tif (result2)\n\t\t\tusb_stor_dbg(us, \"cannot read status\\n\");\n\t\telse if (status != 0xc0)\n\t\t\tusb_stor_dbg(us, \"status after write: 0x%x\\n\", status);\n\t}\n#endif\n\n#if 0\n\t{\n\t\tint result2 = sddr09_test_unit_ready(us);\n\t}\n#endif\n\n\treturn result;\n}\n\nstatic int\nsddr09_write_data(struct us_data *us,\n\t\t  unsigned long address,\n\t\t  unsigned int sectors) {\n\n\tstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\n\tunsigned int lba, maxlba, page, pages;\n\tunsigned int pagelen, blocklen;\n\tunsigned char *blockbuffer;\n\tunsigned char *buffer;\n\tunsigned int len, offset;\n\tstruct scatterlist *sg;\n\tint result;\n\n\t \n\tlba = address >> info->blockshift;\n\tpage = (address & info->blockmask);\n\tmaxlba = info->capacity >> (info->pageshift + info->blockshift);\n\tif (lba >= maxlba)\n\t\treturn -EIO;\n\n\t \n\n\t \n\n\tpagelen = (1 << info->pageshift) + (1 << CONTROL_SHIFT);\n\tblocklen = (pagelen << info->blockshift);\n\tblockbuffer = kmalloc(blocklen, GFP_NOIO);\n\tif (!blockbuffer)\n\t\treturn -ENOMEM;\n\n\t \n\n\tlen = min(sectors, (unsigned int) info->blocksize) * info->pagesize;\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (!buffer) {\n\t\tkfree(blockbuffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tresult = 0;\n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors > 0) {\n\n\t\t \n\n\t\tpages = min(sectors, info->blocksize - page);\n\t\tlen = (pages << info->pageshift);\n\n\t\t \n\t\tif (lba >= maxlba) {\n\t\t\tusb_stor_dbg(us, \"Error: Requested lba %u exceeds maximum %u\\n\",\n\t\t\t\t     lba, maxlba);\n\t\t\tresult = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, FROM_XFER_BUF);\n\n\t\tresult = sddr09_write_lba(us, lba, page, pages,\n\t\t\t\tbuffer, blockbuffer);\n\t\tif (result)\n\t\t\tbreak;\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages;\n\t}\n\n\tkfree(buffer);\n\tkfree(blockbuffer);\n\n\treturn result;\n}\n\nstatic int\nsddr09_read_control(struct us_data *us,\n\t\tunsigned long address,\n\t\tunsigned int blocks,\n\t\tunsigned char *content,\n\t\tint use_sg) {\n\n\tusb_stor_dbg(us, \"Read control address %lu, blocks %d\\n\",\n\t\t     address, blocks);\n\n\treturn sddr09_read21(us, address, blocks,\n\t\t\t     CONTROL_SHIFT, content, use_sg);\n}\n\n \nstatic int\nsddr09_read_deviceID(struct us_data *us, unsigned char *deviceID) {\n\tunsigned char *command = us->iobuf;\n\tunsigned char *content = us->iobuf;\n\tint result, i;\n\n\tmemset(command, 0, 12);\n\tcommand[0] = 0xED;\n\tcommand[1] = LUNBITS;\n\n\tresult = sddr09_send_scsi_command(us, command, 12);\n\tif (result)\n\t\treturn result;\n\n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\tcontent, 64, NULL);\n\n\tfor (i = 0; i < 4; i++)\n\t\tdeviceID[i] = content[i];\n\n\treturn (result == USB_STOR_XFER_GOOD ? 0 : -EIO);\n}\n\nstatic int\nsddr09_get_wp(struct us_data *us, struct sddr09_card_info *info) {\n\tint result;\n\tunsigned char status;\n\tconst char *wp_fmt;\n\n\tresult = sddr09_read_status(us, &status);\n\tif (result) {\n\t\tusb_stor_dbg(us, \"read_status fails\\n\");\n\t\treturn result;\n\t}\n\tif ((status & 0x80) == 0) {\n\t\tinfo->flags |= SDDR09_WP;\t \n\t\twp_fmt = \" WP\";\n\t} else {\n\t\twp_fmt = \"\";\n\t}\n\tusb_stor_dbg(us, \"status 0x%02X%s%s%s%s\\n\", status, wp_fmt,\n\t\t     status & 0x40 ? \" Ready\" : \"\",\n\t\t     status & LUNBITS ? \" Suspended\" : \"\",\n\t\t     status & 0x01 ? \" Error\" : \"\");\n\n\treturn 0;\n}\n\n#if 0\n \nstatic int\nsddr09_reset(struct us_data *us) {\n\n\tunsigned char *command = us->iobuf;\n\n\tmemset(command, 0, 12);\n\tcommand[0] = 0xEB;\n\tcommand[1] = LUNBITS;\n\n\treturn sddr09_send_scsi_command(us, command, 12);\n}\n#endif\n\nstatic struct nand_flash_dev *\nsddr09_get_cardinfo(struct us_data *us, unsigned char flags) {\n\tstruct nand_flash_dev *cardinfo;\n\tunsigned char deviceID[4];\n\tchar blurbtxt[256];\n\tint result;\n\n\tusb_stor_dbg(us, \"Reading capacity...\\n\");\n\n\tresult = sddr09_read_deviceID(us, deviceID);\n\n\tif (result) {\n\t\tusb_stor_dbg(us, \"Result of read_deviceID is %d\\n\", result);\n\t\tprintk(KERN_WARNING \"sddr09: could not read card info\\n\");\n\t\treturn NULL;\n\t}\n\n\tsprintf(blurbtxt, \"sddr09: Found Flash card, ID = %4ph\", deviceID);\n\n\t \n\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\": Manuf. %s\",\n\t\tnand_flash_manufacturer(deviceID[0]));\n\n\t \n\tcardinfo = nand_find_id(deviceID[1]);\n\tif (cardinfo) {\n\t\t \n\t\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\t\", %d MB\", 1<<(cardinfo->chipshift - 20));\n\t} else {\n\t\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\t\", type unrecognized\");\n\t}\n\n\t \n\tif (deviceID[2] == 0xa5) {\n\t\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\t\", 128-bit ID\");\n\t}\n\n\t \n\tif (deviceID[3] == 0xc0) {\n\t\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\t\", extra cmd\");\n\t}\n\n\tif (flags & SDDR09_WP)\n\t\tsprintf(blurbtxt + strlen(blurbtxt),\n\t\t\t\", WP\");\n\n\tprintk(KERN_WARNING \"%s\\n\", blurbtxt);\n\n\treturn cardinfo;\n}\n\nstatic int\nsddr09_read_map(struct us_data *us) {\n\n\tstruct sddr09_card_info *info = (struct sddr09_card_info *) us->extra;\n\tint numblocks, alloc_len, alloc_blocks;\n\tint i, j, result;\n\tunsigned char *buffer, *buffer_end, *ptr;\n\tunsigned int lba, lbact;\n\n\tif (!info->capacity)\n\t\treturn -1;\n\n\t \n\n\tnumblocks = info->capacity >> (info->blockshift + info->pageshift);\n\n\t \n#define SDDR09_READ_MAP_BUFSZ 65536\n\n\talloc_blocks = min(numblocks, SDDR09_READ_MAP_BUFSZ >> CONTROL_SHIFT);\n\talloc_len = (alloc_blocks << CONTROL_SHIFT);\n\tbuffer = kmalloc(alloc_len, GFP_NOIO);\n\tif (!buffer) {\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\tbuffer_end = buffer + alloc_len;\n\n#undef SDDR09_READ_MAP_BUFSZ\n\n\tkfree(info->lba_to_pba);\n\tkfree(info->pba_to_lba);\n\tinfo->lba_to_pba = kmalloc_array(numblocks, sizeof(int), GFP_NOIO);\n\tinfo->pba_to_lba = kmalloc_array(numblocks, sizeof(int), GFP_NOIO);\n\n\tif (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {\n\t\tprintk(KERN_WARNING \"sddr09_read_map: out of memory\\n\");\n\t\tresult = -1;\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < numblocks; i++)\n\t\tinfo->lba_to_pba[i] = info->pba_to_lba[i] = UNDEF;\n\n\t \n\n\tptr = buffer_end;\n\tfor (i = 0; i < numblocks; i++) {\n\t\tptr += (1 << CONTROL_SHIFT);\n\t\tif (ptr >= buffer_end) {\n\t\t\tunsigned long address;\n\n\t\t\taddress = i << (info->pageshift + info->blockshift);\n\t\t\tresult = sddr09_read_control(\n\t\t\t\tus, address>>1,\n\t\t\t\tmin(alloc_blocks, numblocks - i),\n\t\t\t\tbuffer, 0);\n\t\t\tif (result) {\n\t\t\t\tresult = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tptr = buffer;\n\t\t}\n\n\t\tif (i == 0 || i == 1) {\n\t\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr[j] != 0)\n\t\t\t\tgoto nonz;\n\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t\tprintk(KERN_WARNING \"sddr09: PBA %d has no logical mapping\\n\",\n\t\t       i);\n\t\tcontinue;\n\n\tnonz:\n\t\t \n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (ptr[j] != 0xff)\n\t\t\t\tgoto nonff;\n\t\tcontinue;\n\n\tnonff:\n\t\t \n\t\tif (j < 6) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09: PBA %d has no logical mapping: \"\n\t\t\t       \"reserved area = %02X%02X%02X%02X \"\n\t\t\t       \"data status %02X block status %02X\\n\",\n\t\t\t       i, ptr[0], ptr[1], ptr[2], ptr[3],\n\t\t\t       ptr[4], ptr[5]);\n\t\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((ptr[6] >> 4) != 0x01) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09: PBA %d has invalid address field \"\n\t\t\t       \"%02X%02X/%02X%02X\\n\",\n\t\t\t       i, ptr[6], ptr[7], ptr[11], ptr[12]);\n\t\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (parity[ptr[6] ^ ptr[7]]) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09: Bad parity in LBA for block %d\"\n\t\t\t       \" (%02X %02X)\\n\", i, ptr[6], ptr[7]);\n\t\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlba = short_pack(ptr[7], ptr[6]);\n\t\tlba = (lba & 0x07FF) >> 1;\n\n\t\t \n\n\t\tif (lba >= 1000) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09: Bad low LBA %d for block %d\\n\",\n\t\t\t       lba, i);\n\t\t\tgoto possibly_erase;\n\t\t}\n\n\t\tlba += 1000*(i/0x400);\n\n\t\tif (info->lba_to_pba[lba] != UNDEF) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr09: LBA %d seen for PBA %d and %d\\n\",\n\t\t\t       lba, info->lba_to_pba[lba], i);\n\t\t\tgoto possibly_erase;\n\t\t}\n\n\t\tinfo->pba_to_lba[i] = lba;\n\t\tinfo->lba_to_pba[lba] = i;\n\t\tcontinue;\n\n\tpossibly_erase:\n\t\tif (erase_bad_lba_entries) {\n\t\t\tunsigned long address;\n\n\t\t\taddress = (i << (info->pageshift + info->blockshift));\n\t\t\tsddr09_erase(us, address>>1);\n\t\t\tinfo->pba_to_lba[i] = UNDEF;\n\t\t} else\n\t\t\tinfo->pba_to_lba[i] = UNUSABLE;\n\t}\n\n\t \n\tlbact = 0;\n\tfor (i = 0; i < numblocks; i += 1024) {\n\t\tint ct = 0;\n\n\t\tfor (j = 0; j < 1024 && i+j < numblocks; j++) {\n\t\t\tif (info->pba_to_lba[i+j] != UNUSABLE) {\n\t\t\t\tif (ct >= 1000)\n\t\t\t\t\tinfo->pba_to_lba[i+j] = SPARE;\n\t\t\t\telse\n\t\t\t\t\tct++;\n\t\t\t}\n\t\t}\n\t\tlbact += ct;\n\t}\n\tinfo->lbact = lbact;\n\tusb_stor_dbg(us, \"Found %d LBA's\\n\", lbact);\n\tresult = 0;\n\n done:\n\tif (result != 0) {\n\t\tkfree(info->lba_to_pba);\n\t\tkfree(info->pba_to_lba);\n\t\tinfo->lba_to_pba = NULL;\n\t\tinfo->pba_to_lba = NULL;\n\t}\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic void\nsddr09_card_info_destructor(void *extra) {\n\tstruct sddr09_card_info *info = (struct sddr09_card_info *)extra;\n\n\tif (!info)\n\t\treturn;\n\n\tkfree(info->lba_to_pba);\n\tkfree(info->pba_to_lba);\n}\n\nstatic int\nsddr09_common_init(struct us_data *us) {\n\tint result;\n\n\t \n\tif (us->pusb_dev->actconfig->desc.bConfigurationValue != 1) {\n\t\tusb_stor_dbg(us, \"active config #%d != 1 ??\\n\",\n\t\t\t     us->pusb_dev->actconfig->desc.bConfigurationValue);\n\t\treturn -EINVAL;\n\t}\n\n\tresult = usb_reset_configuration(us->pusb_dev);\n\tusb_stor_dbg(us, \"Result of usb_reset_configuration is %d\\n\", result);\n\tif (result == -EPIPE) {\n\t\tusb_stor_dbg(us, \"-- stall on control interface\\n\");\n\t} else if (result != 0) {\n\t\t \n\t\tusb_stor_dbg(us, \"-- Unknown error.  Rejecting device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tus->extra = kzalloc(sizeof(struct sddr09_card_info), GFP_NOIO);\n\tif (!us->extra)\n\t\treturn -ENOMEM;\n\tus->extra_destructor = sddr09_card_info_destructor;\n\n\tnand_init_ecc();\n\treturn 0;\n}\n\n\n \nstatic int\nusb_stor_sddr09_dpcm_init(struct us_data *us) {\n\tint result;\n\tunsigned char *data = us->iobuf;\n\n\tresult = sddr09_common_init(us);\n\tif (result)\n\t\treturn result;\n\n\tresult = sddr09_send_command(us, 0x01, USB_DIR_IN, data, 2);\n\tif (result) {\n\t\tusb_stor_dbg(us, \"send_command fails\\n\");\n\t\treturn result;\n\t}\n\n\tusb_stor_dbg(us, \"%02X %02X\\n\", data[0], data[1]);\n\t \n\n\tresult = sddr09_send_command(us, 0x08, USB_DIR_IN, data, 2);\n\tif (result) {\n\t\tusb_stor_dbg(us, \"2nd send_command fails\\n\");\n\t\treturn result;\n\t}\n\n\tusb_stor_dbg(us, \"%02X %02X\\n\", data[0], data[1]);\n\t \n\n\tresult = sddr09_request_sense(us, data, 18);\n\tif (result == 0 && data[2] != 0) {\n\t\tint j;\n\t\tfor (j=0; j<18; j++)\n\t\t\tprintk(\" %02X\", data[j]);\n\t\tprintk(\"\\n\");\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t}\n\n\t \n\n\treturn 0;\t\t \n}\n\n \nstatic int dpcm_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint ret;\n\n\tusb_stor_dbg(us, \"LUN=%d\\n\", (u8)srb->device->lun);\n\n\tswitch (srb->device->lun) {\n\tcase 0:\n\n\t\t \n\t\tret = usb_stor_CB_transport(srb, us);\n\t\tbreak;\n\n\tcase 1:\n\n\t\t \n\n\t\t \n\t\tsrb->device->lun = 0;\n\t\tret = sddr09_transport(srb, us);\n\t\tsrb->device->lun = 1;\n\t\tbreak;\n\n\tdefault:\n\t    usb_stor_dbg(us, \"Invalid LUN %d\\n\", (u8)srb->device->lun);\n\t\tret = USB_STOR_TRANSPORT_ERROR;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n\n \nstatic int sddr09_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstatic unsigned char sensekey = 0, sensecode = 0;\n\tstatic unsigned char havefakesense = 0;\n\tint result, i;\n\tunsigned char *ptr = us->iobuf;\n\tunsigned long capacity;\n\tunsigned int page, pages;\n\n\tstruct sddr09_card_info *info;\n\n\tstatic unsigned char inquiry_response[8] = {\n\t\t0x00, 0x80, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00\n\t};\n\n\t \n\tstatic unsigned char mode_page_01[19] = {\n\t\t0x00, 0x0F, 0x00, 0x0, 0x0, 0x0, 0x00,\n\t\t0x01, 0x0A,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\n\tinfo = (struct sddr09_card_info *)us->extra;\n\n\tif (srb->cmnd[0] == REQUEST_SENSE && havefakesense) {\n\t\t \n\t\tmemset(ptr, 0, 18);\n\t\tptr[0] = 0x70;\n\t\tptr[2] = sensekey;\n\t\tptr[7] = 11;\n\t\tptr[12] = sensecode;\n\t\tusb_stor_set_xfer_buf(ptr, 18, srb);\n\t\tsensekey = sensecode = havefakesense = 0;\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\thavefakesense = 1;\n\n\t \n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tmemcpy(ptr, inquiry_response, 8);\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\t\tstruct nand_flash_dev *cardinfo;\n\n\t\tsddr09_get_wp(us, info);\t \n\n\t\tcardinfo = sddr09_get_cardinfo(us, info->flags);\n\t\tif (!cardinfo) {\n\t\t\t \n\t\tinit_error:\n\t\t\tsensekey = 0x02;\t \n\t\t\tsensecode = 0x3a;\t \n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\n\t\tinfo->capacity = (1 << cardinfo->chipshift);\n\t\tinfo->pageshift = cardinfo->pageshift;\n\t\tinfo->pagesize = (1 << info->pageshift);\n\t\tinfo->blockshift = cardinfo->blockshift;\n\t\tinfo->blocksize = (1 << info->blockshift);\n\t\tinfo->blockmask = info->blocksize - 1;\n\n\t\t\n\t\tif (sddr09_read_map(us)) {\n\t\t\t \n\t\t\tgoto init_error;\n\t\t}\n\n\t\t\n\n\t\tcapacity = (info->lbact << info->blockshift) - 1;\n\n\t\t((__be32 *) ptr)[0] = cpu_to_be32(capacity);\n\n\t\t\n\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(info->pagesize);\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE_10) {\n\t\tint modepage = (srb->cmnd[2] & 0x3F);\n\n\t\t \n\t\t \n\t\tif (modepage == 0x01 || modepage == 0x3F) {\n\t\t\tusb_stor_dbg(us, \"Dummy up request for mode page 0x%x\\n\",\n\t\t\t\t     modepage);\n\n\t\t\tmemcpy(ptr, mode_page_01, sizeof(mode_page_01));\n\t\t\t((__be16*)ptr)[0] = cpu_to_be16(sizeof(mode_page_01) - 2);\n\t\t\tptr[3] = (info->flags & SDDR09_WP) ? 0x80 : 0;\n\t\t\tusb_stor_set_xfer_buf(ptr, sizeof(mode_page_01), srb);\n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t\t}\n\n\t\tsensekey = 0x05;\t \n\t\tsensecode = 0x24;\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\thavefakesense = 0;\n\n\tif (srb->cmnd[0] == READ_10) {\n\n\t\tpage = short_pack(srb->cmnd[3], srb->cmnd[2]);\n\t\tpage <<= 16;\n\t\tpage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\n\t\tpages = short_pack(srb->cmnd[8], srb->cmnd[7]);\n\n\t\tusb_stor_dbg(us, \"READ_10: read page %d pagect %d\\n\",\n\t\t\t     page, pages);\n\n\t\tresult = sddr09_read_data(us, page, pages);\n\t\treturn (result == 0 ? USB_STOR_TRANSPORT_GOOD :\n\t\t\t\tUSB_STOR_TRANSPORT_ERROR);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_10) {\n\n\t\tpage = short_pack(srb->cmnd[3], srb->cmnd[2]);\n\t\tpage <<= 16;\n\t\tpage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\n\t\tpages = short_pack(srb->cmnd[8], srb->cmnd[7]);\n\n\t\tusb_stor_dbg(us, \"WRITE_10: write page %d pagect %d\\n\",\n\t\t\t     page, pages);\n\n\t\tresult = sddr09_write_data(us, page, pages);\n\t\treturn (result == 0 ? USB_STOR_TRANSPORT_GOOD :\n\t\t\t\tUSB_STOR_TRANSPORT_ERROR);\n\t}\n\n\t \n\tif (srb->cmnd[0] != TEST_UNIT_READY &&\n\t    srb->cmnd[0] != REQUEST_SENSE) {\n\t\tsensekey = 0x05;\t \n\t\tsensecode = 0x20;\t \n\t\thavefakesense = 1;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\tfor (; srb->cmd_len<12; srb->cmd_len++)\n\t\tsrb->cmnd[srb->cmd_len] = 0;\n\n\tsrb->cmnd[1] = LUNBITS;\n\n\tptr[0] = 0;\n\tfor (i=0; i<12; i++)\n\t\tsprintf(ptr+strlen(ptr), \"%02X \", srb->cmnd[i]);\n\n\tusb_stor_dbg(us, \"Send control for command %s\\n\", ptr);\n\n\tresult = sddr09_send_scsi_command(us, srb->cmnd, 12);\n\tif (result) {\n\t\tusb_stor_dbg(us, \"sddr09_send_scsi_command returns %d\\n\",\n\t\t\t     result);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (scsi_bufflen(srb) == 0)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE ||\n\t    srb->sc_data_direction == DMA_FROM_DEVICE) {\n\t\tunsigned int pipe = (srb->sc_data_direction == DMA_TO_DEVICE)\n\t\t\t\t? us->send_bulk_pipe : us->recv_bulk_pipe;\n\n\t\tusb_stor_dbg(us, \"%s %d bytes\\n\",\n\t\t\t     (srb->sc_data_direction == DMA_TO_DEVICE) ?\n\t\t\t     \"sending\" : \"receiving\",\n\t\t\t     scsi_bufflen(srb));\n\n\t\tresult = usb_stor_bulk_srb(us, pipe, srb);\n\n\t\treturn (result == USB_STOR_XFER_GOOD ?\n\t\t\tUSB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_ERROR);\n\t} \n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int\nusb_stor_sddr09_init(struct us_data *us) {\n\treturn sddr09_common_init(us);\n}\n\nstatic struct scsi_host_template sddr09_host_template;\n\nstatic int sddr09_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - sddr09_usb_ids) + sddr09_unusual_dev_list,\n\t\t\t&sddr09_host_template);\n\tif (result)\n\t\treturn result;\n\n\tif (us->protocol == USB_PR_DPCM_USB) {\n\t\tus->transport_name = \"Control/Bulk-EUSB/SDDR09\";\n\t\tus->transport = dpcm_transport;\n\t\tus->transport_reset = usb_stor_CB_reset;\n\t\tus->max_lun = 1;\n\t} else {\n\t\tus->transport_name = \"EUSB/SDDR09\";\n\t\tus->transport = sddr09_transport;\n\t\tus->transport_reset = usb_stor_CB_reset;\n\t\tus->max_lun = 0;\n\t}\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver sddr09_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tsddr09_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tsddr09_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(sddr09_driver, sddr09_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}