{
  "module_name": "cypress_atacb.c",
  "hash_id": "e4990b15597d96f1c6a5f45bed5c50d787df57c1d62eb8539136a666326064ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/cypress_atacb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_eh.h>\n#include <linux/ata.h>\n\n#include \"usb.h\"\n#include \"protocol.h\"\n#include \"scsiglue.h\"\n#include \"debug.h\"\n\n#define DRV_NAME \"ums-cypress\"\n\nMODULE_DESCRIPTION(\"SAT support for Cypress USB/ATA bridges with ATACB\");\nMODULE_AUTHOR(\"Matthieu Castet <castet.matthieu@free.fr>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id cypress_usb_ids[] = {\n#\tinclude \"unusual_cypress.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, cypress_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev cypress_unusual_dev_list[] = {\n#\tinclude \"unusual_cypress.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n \nstatic void cypress_atacb_passthrough(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tunsigned char save_cmnd[MAX_COMMAND_SIZE];\n\n\tif (likely(srb->cmnd[0] != ATA_16 && srb->cmnd[0] != ATA_12)) {\n\t\tusb_stor_transparent_scsi_command(srb, us);\n\t\treturn;\n\t}\n\n\tmemcpy(save_cmnd, srb->cmnd, sizeof(save_cmnd));\n\tmemset(srb->cmnd, 0, MAX_COMMAND_SIZE);\n\n\t \n\tif (save_cmnd[1] >> 5)  \n\t\tgoto invalid_fld;\n\t \n\tswitch ((save_cmnd[1] >> 1) & 0xf) {\n\tcase 3:  \n\tcase 4:  \n\tcase 5:  \n\t\tbreak;\n\tdefault:\n\t\tgoto invalid_fld;\n\t}\n\n\t \n\tsrb->cmd_len = 16;\n\n\tsrb->cmnd[0] = 0x24;  \n\tsrb->cmnd[1] = 0x24;  \n\n\tsrb->cmnd[3] = 0xff - 1;  \n\tsrb->cmnd[4] = 1;  \n\n\tif (save_cmnd[0] == ATA_16) {\n\t\tsrb->cmnd[ 6] = save_cmnd[ 4];  \n\t\tsrb->cmnd[ 7] = save_cmnd[ 6];  \n\t\tsrb->cmnd[ 8] = save_cmnd[ 8];  \n\t\tsrb->cmnd[ 9] = save_cmnd[10];  \n\t\tsrb->cmnd[10] = save_cmnd[12];  \n\t\tsrb->cmnd[11] = save_cmnd[13];  \n\t\tsrb->cmnd[12] = save_cmnd[14];  \n\n\t\tif (save_cmnd[1] & 0x01) { \n\t\t\t \n\t\t\tif (save_cmnd[3] || save_cmnd[5] || save_cmnd[7] || save_cmnd[9]\n\t\t\t\t\t|| save_cmnd[11])\n\t\t\t\tgoto invalid_fld;\n\t\t}\n\t} else {  \n\t\tsrb->cmnd[ 6] = save_cmnd[3];  \n\t\tsrb->cmnd[ 7] = save_cmnd[4];  \n\t\tsrb->cmnd[ 8] = save_cmnd[5];  \n\t\tsrb->cmnd[ 9] = save_cmnd[6];  \n\t\tsrb->cmnd[10] = save_cmnd[7];  \n\t\tsrb->cmnd[11] = save_cmnd[8];  \n\t\tsrb->cmnd[12] = save_cmnd[9];  \n\n\t}\n\t \n\tif ((srb->cmnd[12] == ATA_CMD_SET_FEATURES)\n\t\t\t&& (srb->cmnd[6] == SETFEATURES_XFER))\n\t\tgoto invalid_fld;\n\n\tif (srb->cmnd[12] == ATA_CMD_ID_ATA || srb->cmnd[12] == ATA_CMD_ID_ATAPI)\n\t\tsrb->cmnd[2] |= (1<<7);  \n\n\n\tusb_stor_transparent_scsi_command(srb, us);\n\n\t \n\tif (srb->result == SAM_STAT_CHECK_CONDITION &&\n\t\t\tmemcmp(srb->sense_buffer, usb_stor_sense_invalidCDB,\n\t\t\t\tsizeof(usb_stor_sense_invalidCDB)) == 0) {\n\t\tusb_stor_dbg(us, \"cypress atacb not supported ???\\n\");\n\t\tgoto end;\n\t}\n\n\t \n\tif ((srb->result != (DID_ERROR << 16) &&\n\t\t\t\tsrb->result != (DID_ABORT << 16)) &&\n\t\t\tsave_cmnd[2] & 0x20) {\n\t\tstruct scsi_eh_save ses;\n\t\tunsigned char regs[8];\n\t\tunsigned char *sb = srb->sense_buffer;\n\t\tunsigned char *desc = sb + 8;\n\t\tint tmp_result;\n\n\t\t \n\t\tscsi_eh_prep_cmnd(srb, &ses, NULL, 0, sizeof(regs));\n\n\t\t \n\t\tsrb->cmd_len = 16;\n\t\tsrb->cmnd[2] = 1;\n\n\t\tusb_stor_transparent_scsi_command(srb, us);\n\t\tmemcpy(regs, srb->sense_buffer, sizeof(regs));\n\t\ttmp_result = srb->result;\n\t\tscsi_eh_restore_cmnd(srb, &ses);\n\t\t \n\t\tif (tmp_result != SAM_STAT_GOOD)\n\t\t\tgoto invalid_fld;\n\n\t\t \n\t\tmemset(sb, 0, SCSI_SENSE_BUFFERSIZE);\n\n\t\t \n\t\tsb[1] = RECOVERED_ERROR;\n\t\tsb[2] = 0;  \n\t\tsb[3] = 0x1D;\n\n\t\t \n\n\t\t \n\t\tsb[0] = 0x72;\n\t\tdesc[0] = 0x09;  \n\n\t\t \n\t\tsb[7] = 14;\n\t\tdesc[1] = 12;\n\n\t\t \n\t\tdesc[ 2] = 0x00;\n\t\tdesc[ 3] = regs[1];   \n\t\tdesc[ 5] = regs[2];   \n\t\tdesc[ 7] = regs[3];   \n\t\tdesc[ 9] = regs[4];   \n\t\tdesc[11] = regs[5];   \n\t\tdesc[12] = regs[6];   \n\t\tdesc[13] = regs[7];   \n\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t}\n\tgoto end;\ninvalid_fld:\n\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\n\tmemcpy(srb->sense_buffer,\n\t\t\tusb_stor_sense_invalidCDB,\n\t\t\tsizeof(usb_stor_sense_invalidCDB));\nend:\n\tmemcpy(srb->cmnd, save_cmnd, sizeof(save_cmnd));\n\tif (srb->cmnd[0] == ATA_12)\n\t\tsrb->cmd_len = 12;\n}\n\nstatic struct scsi_host_template cypress_host_template;\n\nstatic int cypress_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\tstruct usb_device *device;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - cypress_usb_ids) + cypress_unusual_dev_list,\n\t\t\t&cypress_host_template);\n\tif (result)\n\t\treturn result;\n\n\t \n\tdevice = interface_to_usbdev(intf);\n\tif (device->descriptor.iManufacturer != 0x38 ||\n\t    device->descriptor.iProduct != 0x4e ||\n\t    device->descriptor.iSerialNumber != 0x64) {\n\t\tus->protocol_name = \"Transparent SCSI with Cypress ATACB\";\n\t\tus->proto_handler = cypress_atacb_passthrough;\n\t} else {\n\t\tus->protocol_name = \"Transparent SCSI\";\n\t\tus->proto_handler = usb_stor_transparent_scsi_command;\n\t}\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver cypress_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tcypress_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tcypress_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(cypress_driver, cypress_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}