{
  "module_name": "alauda.c",
  "hash_id": "9bf6756100294b4166b4c6b0eaffe1a7cf99b7ad1519e54f7c649c65e972d87e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/alauda.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-alauda\"\n\nMODULE_DESCRIPTION(\"Driver for Alauda-based card readers\");\nMODULE_AUTHOR(\"Daniel Drake <dsd@gentoo.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n \n#define ALAUDA_STATUS_ERROR\t\t0x01\n#define ALAUDA_STATUS_READY\t\t0x40\n\n \n#define ALAUDA_GET_XD_MEDIA_STATUS\t0x08\n#define ALAUDA_GET_SM_MEDIA_STATUS\t0x98\n#define ALAUDA_ACK_XD_MEDIA_CHANGE\t0x0a\n#define ALAUDA_ACK_SM_MEDIA_CHANGE\t0x9a\n#define ALAUDA_GET_XD_MEDIA_SIG\t\t0x86\n#define ALAUDA_GET_SM_MEDIA_SIG\t\t0x96\n\n \n#define ALAUDA_BULK_CMD\t\t\t0x40\n\n \n#define ALAUDA_BULK_GET_REDU_DATA\t0x85\n#define ALAUDA_BULK_READ_BLOCK\t\t0x94\n#define ALAUDA_BULK_ERASE_BLOCK\t\t0xa3\n#define ALAUDA_BULK_WRITE_BLOCK\t\t0xb4\n#define ALAUDA_BULK_GET_STATUS2\t\t0xb7\n#define ALAUDA_BULK_RESET_MEDIA\t\t0xe0\n\n \n#define ALAUDA_PORT_XD\t\t\t0x00\n#define ALAUDA_PORT_SM\t\t\t0x01\n\n \n#define UNDEF    0xffff\n#define SPARE    0xfffe\n#define UNUSABLE 0xfffd\n\nstruct alauda_media_info {\n\tunsigned long capacity;\t\t \n\tunsigned int pagesize;\t\t \n\tunsigned int blocksize;\t\t \n\tunsigned int uzonesize;\t\t \n\tunsigned int zonesize;\t\t \n\tunsigned int blockmask;\t\t \n\n\tunsigned char pageshift;\n\tunsigned char blockshift;\n\tunsigned char zoneshift;\n\n\tu16 **lba_to_pba;\t\t \n\tu16 **pba_to_lba;\t\t \n};\n\nstruct alauda_info {\n\tstruct alauda_media_info port[2];\n\tint wr_ep;\t\t\t \n\n\tunsigned char sense_key;\n\tunsigned long sense_asc;\t \n\tunsigned long sense_ascq;\t \n};\n\n#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )\n#define LSB_of(s) ((s)&0xFF)\n#define MSB_of(s) ((s)>>8)\n\n#define MEDIA_PORT(us) us->srb->device->lun\n#define MEDIA_INFO(us) ((struct alauda_info *)us->extra)->port[MEDIA_PORT(us)]\n\n#define PBA_LO(pba) ((pba & 0xF) << 5)\n#define PBA_HI(pba) (pba >> 3)\n#define PBA_ZONE(pba) (pba >> 11)\n\nstatic int init_alauda(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id alauda_usb_ids[] = {\n#\tinclude \"unusual_alauda.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, alauda_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev alauda_unusual_dev_list[] = {\n#\tinclude \"unusual_alauda.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n \n\nstruct alauda_card_info {\n\tunsigned char id;\t\t \n\tunsigned char chipshift;\t \n\tunsigned char pageshift;\t \n\tunsigned char blockshift;\t \n\tunsigned char zoneshift;\t \n};\n\nstatic struct alauda_card_info alauda_card_ids[] = {\n\t \n\t{ 0x6e, 20, 8, 4, 8},\t \n\t{ 0xe8, 20, 8, 4, 8},\t \n\t{ 0xec, 20, 8, 4, 8},\t \n\t{ 0x64, 21, 8, 4, 9}, \t \n\t{ 0xea, 21, 8, 4, 9},\t \n\t{ 0x6b, 22, 9, 4, 9},\t \n\t{ 0xe3, 22, 9, 4, 9},\t \n\t{ 0xe5, 22, 9, 4, 9},\t \n\t{ 0xe6, 23, 9, 4, 10},\t \n\t{ 0x73, 24, 9, 5, 10},\t \n\t{ 0x75, 25, 9, 5, 10},\t \n\t{ 0x76, 26, 9, 5, 10},\t \n\t{ 0x79, 27, 9, 5, 10},\t \n\t{ 0x71, 28, 9, 5, 10},\t \n\n\t \n\t{ 0x5d, 21, 9, 4, 8},\t \n\t{ 0xd5, 22, 9, 4, 9},\t \n\t{ 0xd6, 23, 9, 4, 10},\t \n\t{ 0x57, 24, 9, 4, 11},\t \n\t{ 0x58, 25, 9, 4, 12},\t \n\t{ 0,}\n};\n\nstatic struct alauda_card_info *alauda_card_find_id(unsigned char id)\n{\n\tint i;\n\n\tfor (i = 0; alauda_card_ids[i].id != 0; i++)\n\t\tif (alauda_card_ids[i].id == id)\n\t\t\treturn &(alauda_card_ids[i]);\n\treturn NULL;\n}\n\n \n\nstatic unsigned char parity[256];\nstatic unsigned char ecc2[256];\n\nstatic void nand_init_ecc(void)\n{\n\tint i, j, a;\n\n\tparity[0] = 0;\n\tfor (i = 1; i < 256; i++)\n\t\tparity[i] = (parity[i&(i-1)] ^ 1);\n\n\tfor (i = 0; i < 256; i++) {\n\t\ta = 0;\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (i & (1<<j)) {\n\t\t\t\tif ((j & 1) == 0)\n\t\t\t\t\ta ^= 0x04;\n\t\t\t\tif ((j & 2) == 0)\n\t\t\t\t\ta ^= 0x10;\n\t\t\t\tif ((j & 4) == 0)\n\t\t\t\t\ta ^= 0x40;\n\t\t\t}\n\t\t}\n\t\tecc2[i] = ~(a ^ (a<<1) ^ (parity[i] ? 0xa8 : 0));\n\t}\n}\n\n \nstatic void nand_compute_ecc(unsigned char *data, unsigned char *ecc)\n{\n\tint i, j, a;\n\tunsigned char par = 0, bit, bits[8] = {0};\n\n\t \n\tfor (i = 0; i < 256; i++) {\n\t\tpar ^= data[i];\n\t\tbit = parity[data[i]];\n\t\tfor (j = 0; j < 8; j++)\n\t\t\tif ((i & (1<<j)) == 0)\n\t\t\t\tbits[j] ^= bit;\n\t}\n\n\t \n\ta = (bits[3] << 6) + (bits[2] << 4) + (bits[1] << 2) + bits[0];\n\tecc[0] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\n\n\ta = (bits[7] << 6) + (bits[6] << 4) + (bits[5] << 2) + bits[4];\n\tecc[1] = ~(a ^ (a<<1) ^ (parity[par] ? 0xaa : 0));\n\n\tecc[2] = ecc2[par];\n}\n\nstatic int nand_compare_ecc(unsigned char *data, unsigned char *ecc)\n{\n\treturn (data[0] == ecc[0] && data[1] == ecc[1] && data[2] == ecc[2]);\n}\n\nstatic void nand_store_ecc(unsigned char *data, unsigned char *ecc)\n{\n\tmemcpy(data, ecc, 3);\n}\n\n \n\n \nstatic void alauda_free_maps (struct alauda_media_info *media_info)\n{\n\tunsigned int shift = media_info->zoneshift\n\t\t+ media_info->blockshift + media_info->pageshift;\n\tunsigned int num_zones = media_info->capacity >> shift;\n\tunsigned int i;\n\n\tif (media_info->lba_to_pba != NULL)\n\t\tfor (i = 0; i < num_zones; i++) {\n\t\t\tkfree(media_info->lba_to_pba[i]);\n\t\t\tmedia_info->lba_to_pba[i] = NULL;\n\t\t}\n\n\tif (media_info->pba_to_lba != NULL)\n\t\tfor (i = 0; i < num_zones; i++) {\n\t\t\tkfree(media_info->pba_to_lba[i]);\n\t\t\tmedia_info->pba_to_lba[i] = NULL;\n\t\t}\n}\n\n \nstatic int alauda_get_media_status(struct us_data *us, unsigned char *data)\n{\n\tint rc;\n\tunsigned char command;\n\n\tif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\n\t\tcommand = ALAUDA_GET_XD_MEDIA_STATUS;\n\telse\n\t\tcommand = ALAUDA_GET_SM_MEDIA_STATUS;\n\n\trc = usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\n\t\tcommand, 0xc0, 0, 1, data, 2);\n\n\tif (rc == USB_STOR_XFER_GOOD)\n\t\tusb_stor_dbg(us, \"Media status %02X %02X\\n\", data[0], data[1]);\n\n\treturn rc;\n}\n\n \nstatic int alauda_ack_media(struct us_data *us)\n{\n\tunsigned char command;\n\n\tif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\n\t\tcommand = ALAUDA_ACK_XD_MEDIA_CHANGE;\n\telse\n\t\tcommand = ALAUDA_ACK_SM_MEDIA_CHANGE;\n\n\treturn usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\tcommand, 0x40, 0, 1, NULL, 0);\n}\n\n \nstatic int alauda_get_media_signature(struct us_data *us, unsigned char *data)\n{\n\tunsigned char command;\n\n\tif (MEDIA_PORT(us) == ALAUDA_PORT_XD)\n\t\tcommand = ALAUDA_GET_XD_MEDIA_SIG;\n\telse\n\t\tcommand = ALAUDA_GET_SM_MEDIA_SIG;\n\n\treturn usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\n\t\tcommand, 0xc0, 0, 0, data, 4);\n}\n\n \nstatic int alauda_reset_media(struct us_data *us)\n{\n\tunsigned char *command = us->iobuf;\n\n\tmemset(command, 0, 9);\n\tcommand[0] = ALAUDA_BULK_CMD;\n\tcommand[1] = ALAUDA_BULK_RESET_MEDIA;\n\tcommand[8] = MEDIA_PORT(us);\n\n\treturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n}\n\n \nstatic int alauda_init_media(struct us_data *us)\n{\n\tunsigned char *data = us->iobuf;\n\tint ready = 0;\n\tstruct alauda_card_info *media_info;\n\tunsigned int num_zones;\n\n\twhile (ready == 0) {\n\t\tmsleep(20);\n\n\t\tif (alauda_get_media_status(us, data) != USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (data[0] & 0x10)\n\t\t\tready = 1;\n\t}\n\n\tusb_stor_dbg(us, \"We are ready for action!\\n\");\n\n\tif (alauda_ack_media(us) != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmsleep(10);\n\n\tif (alauda_get_media_status(us, data) != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (data[0] != 0x14) {\n\t\tusb_stor_dbg(us, \"Media not ready after ack\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (alauda_get_media_signature(us, data) != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tusb_stor_dbg(us, \"Media signature: %4ph\\n\", data);\n\tmedia_info = alauda_card_find_id(data[1]);\n\tif (media_info == NULL) {\n\t\tpr_warn(\"alauda_init_media: Unrecognised media signature: %4ph\\n\",\n\t\t\tdata);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tMEDIA_INFO(us).capacity = 1 << media_info->chipshift;\n\tusb_stor_dbg(us, \"Found media with capacity: %ldMB\\n\",\n\t\t     MEDIA_INFO(us).capacity >> 20);\n\n\tMEDIA_INFO(us).pageshift = media_info->pageshift;\n\tMEDIA_INFO(us).blockshift = media_info->blockshift;\n\tMEDIA_INFO(us).zoneshift = media_info->zoneshift;\n\n\tMEDIA_INFO(us).pagesize = 1 << media_info->pageshift;\n\tMEDIA_INFO(us).blocksize = 1 << media_info->blockshift;\n\tMEDIA_INFO(us).zonesize = 1 << media_info->zoneshift;\n\n\tMEDIA_INFO(us).uzonesize = ((1 << media_info->zoneshift) / 128) * 125;\n\tMEDIA_INFO(us).blockmask = MEDIA_INFO(us).blocksize - 1;\n\n\tnum_zones = MEDIA_INFO(us).capacity >> (MEDIA_INFO(us).zoneshift\n\t\t+ MEDIA_INFO(us).blockshift + MEDIA_INFO(us).pageshift);\n\tMEDIA_INFO(us).pba_to_lba = kcalloc(num_zones, sizeof(u16*), GFP_NOIO);\n\tMEDIA_INFO(us).lba_to_pba = kcalloc(num_zones, sizeof(u16*), GFP_NOIO);\n\tif (MEDIA_INFO(us).pba_to_lba == NULL || MEDIA_INFO(us).lba_to_pba == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (alauda_reset_media(us) != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int alauda_check_media(struct us_data *us)\n{\n\tstruct alauda_info *info = (struct alauda_info *) us->extra;\n\tunsigned char *status = us->iobuf;\n\tint rc;\n\n\trc = alauda_get_media_status(us, status);\n\tif (rc != USB_STOR_XFER_GOOD) {\n\t\tstatus[0] = 0xF0;\t \n\t\tstatus[1] = 0;\n\t}\n\n\t \n\tif ((status[0] & 0x80) || ((status[0] & 0x1F) == 0x10)\n\t\t|| ((status[1] & 0x01) == 0)) {\n\t\tusb_stor_dbg(us, \"No media, or door open\\n\");\n\t\talauda_free_maps(&MEDIA_INFO(us));\n\t\tinfo->sense_key = 0x02;\n\t\tinfo->sense_asc = 0x3A;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\t \n\tif (status[0] & 0x08) {\n\t\tusb_stor_dbg(us, \"Media change detected\\n\");\n\t\talauda_free_maps(&MEDIA_INFO(us));\n\t\talauda_init_media(us);\n\n\t\tinfo->sense_key = UNIT_ATTENTION;\n\t\tinfo->sense_asc = 0x28;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int alauda_check_status2(struct us_data *us)\n{\n\tint rc;\n\tunsigned char command[] = {\n\t\tALAUDA_BULK_CMD, ALAUDA_BULK_GET_STATUS2,\n\t\t0, 0, 0, 0, 3, 0, MEDIA_PORT(us)\n\t};\n\tunsigned char data[3];\n\n\trc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\trc = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\tdata, 3, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\tusb_stor_dbg(us, \"%3ph\\n\", data);\n\tif (data[0] & ALAUDA_STATUS_ERROR)\n\t\treturn USB_STOR_XFER_ERROR;\n\n\treturn USB_STOR_XFER_GOOD;\n}\n\n \nstatic int alauda_get_redu_data(struct us_data *us, u16 pba, unsigned char *data)\n{\n\tint rc;\n\tunsigned char command[] = {\n\t\tALAUDA_BULK_CMD, ALAUDA_BULK_GET_REDU_DATA,\n\t\tPBA_HI(pba), PBA_ZONE(pba), 0, PBA_LO(pba), 0, 0, MEDIA_PORT(us)\n\t};\n\n\trc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\treturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\tdata, 16, NULL);\n}\n\n \nstatic u16 alauda_find_unused_pba(struct alauda_media_info *info,\n\tunsigned int zone)\n{\n\tu16 *pba_to_lba = info->pba_to_lba[zone];\n\tunsigned int i;\n\n\tfor (i = 0; i < info->zonesize; i++)\n\t\tif (pba_to_lba[i] == UNDEF)\n\t\t\treturn (zone << info->zoneshift) + i;\n\n\treturn 0;\n}\n\n \nstatic int alauda_read_map(struct us_data *us, unsigned int zone)\n{\n\tunsigned char *data = us->iobuf;\n\tint result;\n\tint i, j;\n\tunsigned int zonesize = MEDIA_INFO(us).zonesize;\n\tunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\n\tunsigned int lba_offset, lba_real, blocknum;\n\tunsigned int zone_base_lba = zone * uzonesize;\n\tunsigned int zone_base_pba = zone * zonesize;\n\tu16 *lba_to_pba = kcalloc(zonesize, sizeof(u16), GFP_NOIO);\n\tu16 *pba_to_lba = kcalloc(zonesize, sizeof(u16), GFP_NOIO);\n\tif (lba_to_pba == NULL || pba_to_lba == NULL) {\n\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto error;\n\t}\n\n\tusb_stor_dbg(us, \"Mapping blocks for zone %d\\n\", zone);\n\n\t \n\tfor (i = 0; i < zonesize; i++)\n\t\tlba_to_pba[i] = pba_to_lba[i] = UNDEF;\n\n\tfor (i = 0; i < zonesize; i++) {\n\t\tblocknum = zone_base_pba + i;\n\n\t\tresult = alauda_get_redu_data(us, blocknum, data);\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (data[j] != 0)\n\t\t\t\tgoto nonz;\n\t\tpba_to_lba[i] = UNUSABLE;\n\t\tusb_stor_dbg(us, \"PBA %d has no logical mapping\\n\", blocknum);\n\t\tcontinue;\n\n\tnonz:\n\t\t \n\t\tfor (j = 0; j < 16; j++)\n\t\t\tif (data[j] != 0xff)\n\t\t\t\tgoto nonff;\n\t\tcontinue;\n\n\tnonff:\n\t\t \n\t\tif (j < 6) {\n\t\t\tusb_stor_dbg(us, \"PBA %d has no logical mapping: reserved area = %02X%02X%02X%02X data status %02X block status %02X\\n\",\n\t\t\t\t     blocknum,\n\t\t\t\t     data[0], data[1], data[2], data[3],\n\t\t\t\t     data[4], data[5]);\n\t\t\tpba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((data[6] >> 4) != 0x01) {\n\t\t\tusb_stor_dbg(us, \"PBA %d has invalid address field %02X%02X/%02X%02X\\n\",\n\t\t\t\t     blocknum, data[6], data[7],\n\t\t\t\t     data[11], data[12]);\n\t\t\tpba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (parity[data[6] ^ data[7]]) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"alauda_read_map: Bad parity in LBA for block %d\"\n\t\t\t       \" (%02X %02X)\\n\", i, data[6], data[7]);\n\t\t\tpba_to_lba[i] = UNUSABLE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlba_offset = short_pack(data[7], data[6]);\n\t\tlba_offset = (lba_offset & 0x07FF) >> 1;\n\t\tlba_real = lba_offset + zone_base_lba;\n\n\t\t \n\n\t\tif (lba_offset >= uzonesize) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"alauda_read_map: Bad low LBA %d for block %d\\n\",\n\t\t\t       lba_real, blocknum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (lba_to_pba[lba_offset] != UNDEF) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"alauda_read_map: \"\n\t\t\t       \"LBA %d seen for PBA %d and %d\\n\",\n\t\t\t       lba_real, lba_to_pba[lba_offset], blocknum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpba_to_lba[i] = lba_real;\n\t\tlba_to_pba[lba_offset] = blocknum;\n\t\tcontinue;\n\t}\n\n\tMEDIA_INFO(us).lba_to_pba[zone] = lba_to_pba;\n\tMEDIA_INFO(us).pba_to_lba[zone] = pba_to_lba;\n\tresult = 0;\n\tgoto out;\n\nerror:\n\tkfree(lba_to_pba);\n\tkfree(pba_to_lba);\nout:\n\treturn result;\n}\n\n \nstatic void alauda_ensure_map_for_zone(struct us_data *us, unsigned int zone)\n{\n\tif (MEDIA_INFO(us).lba_to_pba[zone] == NULL\n\t\t|| MEDIA_INFO(us).pba_to_lba[zone] == NULL)\n\t\talauda_read_map(us, zone);\n}\n\n \nstatic int alauda_erase_block(struct us_data *us, u16 pba)\n{\n\tint rc;\n\tunsigned char command[] = {\n\t\tALAUDA_BULK_CMD, ALAUDA_BULK_ERASE_BLOCK, PBA_HI(pba),\n\t\tPBA_ZONE(pba), 0, PBA_LO(pba), 0x02, 0, MEDIA_PORT(us)\n\t};\n\tunsigned char buf[2];\n\n\tusb_stor_dbg(us, \"Erasing PBA %d\\n\", pba);\n\n\trc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\trc = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\tbuf, 2, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\tusb_stor_dbg(us, \"Erase result: %02X %02X\\n\", buf[0], buf[1]);\n\treturn rc;\n}\n\n \nstatic int alauda_read_block_raw(struct us_data *us, u16 pba,\n\t\tunsigned int page, unsigned int pages, unsigned char *data)\n{\n\tint rc;\n\tunsigned char command[] = {\n\t\tALAUDA_BULK_CMD, ALAUDA_BULK_READ_BLOCK, PBA_HI(pba),\n\t\tPBA_ZONE(pba), 0, PBA_LO(pba) + page, pages, 0, MEDIA_PORT(us)\n\t};\n\n\tusb_stor_dbg(us, \"pba %d page %d count %d\\n\", pba, page, pages);\n\n\trc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\treturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\tdata, (MEDIA_INFO(us).pagesize + 64) * pages, NULL);\n}\n\n \nstatic int alauda_read_block(struct us_data *us, u16 pba,\n\t\tunsigned int page, unsigned int pages, unsigned char *data)\n{\n\tint i, rc;\n\tunsigned int pagesize = MEDIA_INFO(us).pagesize;\n\n\trc = alauda_read_block_raw(us, pba, page, pages, data);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < pages; i++) {\n\t\tint dest_offset = i * pagesize;\n\t\tint src_offset = i * (pagesize + 64);\n\t\tmemmove(data + dest_offset, data + src_offset, pagesize);\n\t}\n\n\treturn rc;\n}\n\n \nstatic int alauda_write_block(struct us_data *us, u16 pba, unsigned char *data)\n{\n\tint rc;\n\tstruct alauda_info *info = (struct alauda_info *) us->extra;\n\tunsigned char command[] = {\n\t\tALAUDA_BULK_CMD, ALAUDA_BULK_WRITE_BLOCK, PBA_HI(pba),\n\t\tPBA_ZONE(pba), 0, PBA_LO(pba), 32, 0, MEDIA_PORT(us)\n\t};\n\n\tusb_stor_dbg(us, \"pba %d\\n\", pba);\n\n\trc = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\tcommand, 9, NULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\trc = usb_stor_bulk_transfer_buf(us, info->wr_ep, data,\n\t\t(MEDIA_INFO(us).pagesize + 64) * MEDIA_INFO(us).blocksize,\n\t\tNULL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn rc;\n\n\treturn alauda_check_status2(us);\n}\n\n \nstatic int alauda_write_lba(struct us_data *us, u16 lba,\n\t\t unsigned int page, unsigned int pages,\n\t\t unsigned char *ptr, unsigned char *blockbuffer)\n{\n\tu16 pba, lbap, new_pba;\n\tunsigned char *bptr, *cptr, *xptr;\n\tunsigned char ecc[3];\n\tint i, result;\n\tunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\n\tunsigned int zonesize = MEDIA_INFO(us).zonesize;\n\tunsigned int pagesize = MEDIA_INFO(us).pagesize;\n\tunsigned int blocksize = MEDIA_INFO(us).blocksize;\n\tunsigned int lba_offset = lba % uzonesize;\n\tunsigned int new_pba_offset;\n\tunsigned int zone = lba / uzonesize;\n\n\talauda_ensure_map_for_zone(us, zone);\n\n\tpba = MEDIA_INFO(us).lba_to_pba[zone][lba_offset];\n\tif (pba == 1) {\n\t\t \n\t\tprintk(KERN_WARNING\n\t\t       \"alauda_write_lba: avoid writing to pba 1\\n\");\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tnew_pba = alauda_find_unused_pba(&MEDIA_INFO(us), zone);\n\tif (!new_pba) {\n\t\tprintk(KERN_WARNING\n\t\t       \"alauda_write_lba: Out of unused blocks\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tif (pba != UNDEF) {\n\t\tresult = alauda_read_block_raw(us, pba, 0,\n\t\t\tblocksize, blockbuffer);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\treturn result;\n\t} else {\n\t\tmemset(blockbuffer, 0, blocksize * (pagesize + 64));\n\t}\n\n\tlbap = (lba_offset << 1) | 0x1000;\n\tif (parity[MSB_of(lbap) ^ LSB_of(lbap)])\n\t\tlbap ^= 1;\n\n\t \n\tfor (i = 0; i < blocksize; i++) {\n\t\tbptr = blockbuffer + (i * (pagesize + 64));\n\t\tcptr = bptr + pagesize;\n\t\tnand_compute_ecc(bptr, ecc);\n\t\tif (!nand_compare_ecc(cptr+13, ecc)) {\n\t\t\tusb_stor_dbg(us, \"Warning: bad ecc in page %d- of pba %d\\n\",\n\t\t\t\t     i, pba);\n\t\t\tnand_store_ecc(cptr+13, ecc);\n\t\t}\n\t\tnand_compute_ecc(bptr + (pagesize / 2), ecc);\n\t\tif (!nand_compare_ecc(cptr+8, ecc)) {\n\t\t\tusb_stor_dbg(us, \"Warning: bad ecc in page %d+ of pba %d\\n\",\n\t\t\t\t     i, pba);\n\t\t\tnand_store_ecc(cptr+8, ecc);\n\t\t}\n\t\tcptr[6] = cptr[11] = MSB_of(lbap);\n\t\tcptr[7] = cptr[12] = LSB_of(lbap);\n\t}\n\n\t \n\txptr = ptr;\n\tfor (i = page; i < page+pages; i++) {\n\t\tbptr = blockbuffer + (i * (pagesize + 64));\n\t\tcptr = bptr + pagesize;\n\t\tmemcpy(bptr, xptr, pagesize);\n\t\txptr += pagesize;\n\t\tnand_compute_ecc(bptr, ecc);\n\t\tnand_store_ecc(cptr+13, ecc);\n\t\tnand_compute_ecc(bptr + (pagesize / 2), ecc);\n\t\tnand_store_ecc(cptr+8, ecc);\n\t}\n\n\tresult = alauda_write_block(us, new_pba, blockbuffer);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn result;\n\n\tnew_pba_offset = new_pba - (zone * zonesize);\n\tMEDIA_INFO(us).pba_to_lba[zone][new_pba_offset] = lba;\n\tMEDIA_INFO(us).lba_to_pba[zone][lba_offset] = new_pba;\n\tusb_stor_dbg(us, \"Remapped LBA %d to PBA %d\\n\", lba, new_pba);\n\n\tif (pba != UNDEF) {\n\t\tunsigned int pba_offset = pba - (zone * zonesize);\n\t\tresult = alauda_erase_block(us, pba);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\treturn result;\n\t\tMEDIA_INFO(us).pba_to_lba[zone][pba_offset] = UNDEF;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int alauda_read_data(struct us_data *us, unsigned long address,\n\t\tunsigned int sectors)\n{\n\tunsigned char *buffer;\n\tu16 lba, max_lba;\n\tunsigned int page, len, offset;\n\tunsigned int blockshift = MEDIA_INFO(us).blockshift;\n\tunsigned int pageshift = MEDIA_INFO(us).pageshift;\n\tunsigned int blocksize = MEDIA_INFO(us).blocksize;\n\tunsigned int pagesize = MEDIA_INFO(us).pagesize;\n\tunsigned int uzonesize = MEDIA_INFO(us).uzonesize;\n\tstruct scatterlist *sg;\n\tint result;\n\n\t \n\n\tlen = min(sectors, blocksize) * (pagesize + 64);\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (!buffer)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tlba = address >> blockshift;\n\tpage = (address & MEDIA_INFO(us).blockmask);\n\tmax_lba = MEDIA_INFO(us).capacity >> (blockshift + pageshift);\n\n\tresult = USB_STOR_TRANSPORT_GOOD;\n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors > 0) {\n\t\tunsigned int zone = lba / uzonesize;  \n\t\tunsigned int lba_offset = lba - (zone * uzonesize);\n\t\tunsigned int pages;\n\t\tu16 pba;\n\t\talauda_ensure_map_for_zone(us, zone);\n\n\t\t \n\t\tif (lba >= max_lba) {\n\t\t\tusb_stor_dbg(us, \"Error: Requested lba %u exceeds maximum %u\\n\",\n\t\t\t\t     lba, max_lba);\n\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpages = min(sectors, blocksize - page);\n\t\tlen = pages << pageshift;\n\n\t\t \n\t\tpba = MEDIA_INFO(us).lba_to_pba[zone][lba_offset];\n\n\t\tif (pba == UNDEF) {\t \n\t\t\tusb_stor_dbg(us, \"Read %d zero pages (LBA %d) page %d\\n\",\n\t\t\t\t     pages, lba, page);\n\n\t\t\t \n\n\t\t\tmemset(buffer, 0, len);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"Read %d pages, from PBA %d (LBA %d) page %d\\n\",\n\t\t\t\t     pages, pba, lba, page);\n\n\t\t\tresult = alauda_read_block(us, pba, page, pages, buffer);\n\t\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, TO_XFER_BUF);\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages;\n\t}\n\n\tkfree(buffer);\n\treturn result;\n}\n\n \nstatic int alauda_write_data(struct us_data *us, unsigned long address,\n\t\tunsigned int sectors)\n{\n\tunsigned char *buffer, *blockbuffer;\n\tunsigned int page, len, offset;\n\tunsigned int blockshift = MEDIA_INFO(us).blockshift;\n\tunsigned int pageshift = MEDIA_INFO(us).pageshift;\n\tunsigned int blocksize = MEDIA_INFO(us).blocksize;\n\tunsigned int pagesize = MEDIA_INFO(us).pagesize;\n\tstruct scatterlist *sg;\n\tu16 lba, max_lba;\n\tint result;\n\n\t \n\n\tlen = min(sectors, blocksize) * pagesize;\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (!buffer)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tblockbuffer = kmalloc_array(pagesize + 64, blocksize, GFP_NOIO);\n\tif (!blockbuffer) {\n\t\tkfree(buffer);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tlba = address >> blockshift;\n\tpage = (address & MEDIA_INFO(us).blockmask);\n\tmax_lba = MEDIA_INFO(us).capacity >> (pageshift + blockshift);\n\n\tresult = USB_STOR_TRANSPORT_GOOD;\n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors > 0) {\n\t\t \n\t\tunsigned int pages = min(sectors, blocksize - page);\n\t\tlen = pages << pageshift;\n\n\t\t \n\t\tif (lba >= max_lba) {\n\t\t\tusb_stor_dbg(us, \"Requested lba %u exceeds maximum %u\\n\",\n\t\t\t\t     lba, max_lba);\n\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, FROM_XFER_BUF);\n\n\t\tresult = alauda_write_lba(us, lba, page, pages, buffer,\n\t\t\tblockbuffer);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tbreak;\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages;\n\t}\n\n\tkfree(buffer);\n\tkfree(blockbuffer);\n\treturn result;\n}\n\n \n\nstatic void alauda_info_destructor(void *extra)\n{\n\tstruct alauda_info *info = (struct alauda_info *) extra;\n\tint port;\n\n\tif (!info)\n\t\treturn;\n\n\tfor (port = 0; port < 2; port++) {\n\t\tstruct alauda_media_info *media_info = &info->port[port];\n\n\t\talauda_free_maps(media_info);\n\t\tkfree(media_info->lba_to_pba);\n\t\tkfree(media_info->pba_to_lba);\n\t}\n}\n\n \nstatic int init_alauda(struct us_data *us)\n{\n\tstruct alauda_info *info;\n\tstruct usb_host_interface *altsetting = us->pusb_intf->cur_altsetting;\n\tnand_init_ecc();\n\n\tus->extra = kzalloc(sizeof(struct alauda_info), GFP_NOIO);\n\tif (!us->extra)\n\t\treturn -ENOMEM;\n\n\tinfo = (struct alauda_info *) us->extra;\n\tus->extra_destructor = alauda_info_destructor;\n\n\tinfo->wr_ep = usb_sndbulkpipe(us->pusb_dev,\n\t\taltsetting->endpoint[0].desc.bEndpointAddress\n\t\t& USB_ENDPOINT_NUMBER_MASK);\n\n\treturn 0;\n}\n\nstatic int alauda_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint rc;\n\tstruct alauda_info *info = (struct alauda_info *) us->extra;\n\tunsigned char *ptr = us->iobuf;\n\tstatic unsigned char inquiry_response[36] = {\n\t\t0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\n\t};\n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tusb_stor_dbg(us, \"INQUIRY - Returning bogus response\\n\");\n\t\tmemcpy(ptr, inquiry_response, sizeof(inquiry_response));\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\tusb_stor_dbg(us, \"TEST_UNIT_READY\\n\");\n\t\treturn alauda_check_media(us);\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\t\tunsigned int num_zones;\n\t\tunsigned long capacity;\n\n\t\trc = alauda_check_media(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tnum_zones = MEDIA_INFO(us).capacity >> (MEDIA_INFO(us).zoneshift\n\t\t\t+ MEDIA_INFO(us).blockshift + MEDIA_INFO(us).pageshift);\n\n\t\tcapacity = num_zones * MEDIA_INFO(us).uzonesize\n\t\t\t* MEDIA_INFO(us).blocksize;\n\n\t\t \n\t\t((__be32 *) ptr)[0] = cpu_to_be32(capacity - 1);\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(512);\n\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == READ_10) {\n\t\tunsigned int page, pages;\n\n\t\trc = alauda_check_media(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tpage = short_pack(srb->cmnd[3], srb->cmnd[2]);\n\t\tpage <<= 16;\n\t\tpage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\n\t\tpages = short_pack(srb->cmnd[8], srb->cmnd[7]);\n\n\t\tusb_stor_dbg(us, \"READ_10: page %d pagect %d\\n\", page, pages);\n\n\t\treturn alauda_read_data(us, page, pages);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_10) {\n\t\tunsigned int page, pages;\n\n\t\trc = alauda_check_media(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tpage = short_pack(srb->cmnd[3], srb->cmnd[2]);\n\t\tpage <<= 16;\n\t\tpage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\n\t\tpages = short_pack(srb->cmnd[8], srb->cmnd[7]);\n\n\t\tusb_stor_dbg(us, \"WRITE_10: page %d pagect %d\\n\", page, pages);\n\n\t\treturn alauda_write_data(us, page, pages);\n\t}\n\n\tif (srb->cmnd[0] == REQUEST_SENSE) {\n\t\tusb_stor_dbg(us, \"REQUEST_SENSE\\n\");\n\n\t\tmemset(ptr, 0, 18);\n\t\tptr[0] = 0xF0;\n\t\tptr[2] = info->sense_key;\n\t\tptr[7] = 11;\n\t\tptr[12] = info->sense_asc;\n\t\tptr[13] = info->sense_ascq;\n\t\tusb_stor_set_xfer_buf(ptr, 18, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\t\t \n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tusb_stor_dbg(us, \"Gah! Unknown command: %d (0x%x)\\n\",\n\t\t     srb->cmnd[0], srb->cmnd[0]);\n\tinfo->sense_key = 0x05;\n\tinfo->sense_asc = 0x20;\n\tinfo->sense_ascq = 0x00;\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\nstatic struct scsi_host_template alauda_host_template;\n\nstatic int alauda_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - alauda_usb_ids) + alauda_unusual_dev_list,\n\t\t\t&alauda_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name  = \"Alauda Control/Bulk\";\n\tus->transport = alauda_transport;\n\tus->transport_reset = usb_stor_Bulk_reset;\n\tus->max_lun = 1;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver alauda_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\talauda_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\talauda_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(alauda_driver, alauda_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}