{
  "module_name": "uas-detect.h",
  "hash_id": "0a13102e355914e04a5f75a740beefd3f71de6f8b997a5df5238023d9db41c96",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/uas-detect.h",
  "human_readable_source": " \n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"usb.h\"\n\nstatic int uas_is_interface(struct usb_host_interface *intf)\n{\n\treturn (intf->desc.bInterfaceClass == USB_CLASS_MASS_STORAGE &&\n\t\tintf->desc.bInterfaceSubClass == USB_SC_SCSI &&\n\t\tintf->desc.bInterfaceProtocol == USB_PR_UAS);\n}\n\nstatic struct usb_host_interface *uas_find_uas_alt_setting(\n\t\tstruct usb_interface *intf)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tstruct usb_host_interface *alt = &intf->altsetting[i];\n\n\t\tif (uas_is_interface(alt))\n\t\t\treturn alt;\n\t}\n\n\treturn NULL;\n}\n\nstatic int uas_find_endpoints(struct usb_host_interface *alt,\n\t\t\t      struct usb_host_endpoint *eps[])\n{\n\tstruct usb_host_endpoint *endpoint = alt->endpoint;\n\tunsigned i, n_endpoints = alt->desc.bNumEndpoints;\n\n\tfor (i = 0; i < n_endpoints; i++) {\n\t\tunsigned char *extra = endpoint[i].extra;\n\t\tint len = endpoint[i].extralen;\n\t\twhile (len >= 3) {\n\t\t\tif (extra[1] == USB_DT_PIPE_USAGE) {\n\t\t\t\tunsigned pipe_id = extra[2];\n\t\t\t\tif (pipe_id > 0 && pipe_id < 5)\n\t\t\t\t\teps[pipe_id - 1] = &endpoint[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen -= extra[0];\n\t\t\textra += extra[0];\n\t\t}\n\t}\n\n\tif (!eps[0] || !eps[1] || !eps[2] || !eps[3])\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic int uas_use_uas_driver(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id,\n\t\t\t      unsigned long *flags_ret)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tunsigned long flags = id->driver_info;\n\tstruct usb_host_interface *alt;\n\tint r;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn 0;\n\n\tr = uas_find_endpoints(alt, eps);\n\tif (r < 0)\n\t\treturn 0;\n\n\t \n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x174c &&\n\t\t\t(le16_to_cpu(udev->descriptor.idProduct) == 0x5106 ||\n\t\t\t le16_to_cpu(udev->descriptor.idProduct) == 0x55aa)) {\n\t\tif (udev->actconfig->desc.bMaxPower == 0) {\n\t\t\t \n\t\t} else if (udev->speed < USB_SPEED_SUPER) {\n\t\t\t \n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else if (usb_ss_max_streams(&eps[1]->ss_ep_comp) == 32) {\n\t\t\t \n\t\t\tflags |= US_FL_IGNORE_UAS;\n\t\t} else {\n\t\t\t \n\t\t\tflags |= US_FL_MAX_SECTORS_240;\n\t\t}\n\t}\n\n\t \n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x0bc2)\n\t\tflags |= US_FL_NO_ATA_1X;\n\n\t \n\tif (le16_to_cpu(udev->descriptor.idVendor) == 0x0bda &&\n\t\t\tle16_to_cpu(udev->descriptor.idProduct) == 0x9210 &&\n\t\t\t(udev->manufacturer && !strcmp(udev->manufacturer, \"HIKSEMI\")) &&\n\t\t\t(udev->product && !strcmp(udev->product, \"MD202\")))\n\t\tflags |= US_FL_IGNORE_UAS;\n\n\tusb_stor_adjust_quirks(udev, &flags);\n\n\tif (flags & US_FL_IGNORE_UAS) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"UAS is ignored for this device, using usb-storage instead\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bus->sg_tablesize == 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"The driver for the USB controller %s does not support scatter-gather which is\\n\",\n\t\t\thcd->driver->description);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"required by the UAS driver. Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER && !hcd->can_do_streams) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\"USB controller %s does not support streams, which are required by the UAS driver.\\n\",\n\t\t\thcd_to_bus(hcd)->bus_name);\n\t\tdev_warn(&udev->dev,\n\t\t\t\"Please try an other USB controller if you wish to use UAS.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (flags_ret)\n\t\t*flags_ret = flags;\n\n\treturn 1;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}