{
  "module_name": "realtek_cr.c",
  "hash_id": "1817dd9ea8a084de662b20eba0f34a298830d8ca9f998c43cd768d383bf384ce",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/realtek_cr.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/kthread.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <linux/cdrom.h>\n\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/usb_usual.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-realtek\"\n\nMODULE_DESCRIPTION(\"Driver for Realtek USB Card Reader\");\nMODULE_AUTHOR(\"wwang <wei_wang@realsil.com.cn>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\nstatic int auto_delink_en = 1;\nmodule_param(auto_delink_en, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(auto_delink_en, \"auto delink mode (0=firmware, 1=software [default])\");\n\n#ifdef CONFIG_REALTEK_AUTOPM\nstatic int ss_en = 1;\nmodule_param(ss_en, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ss_en, \"enable selective suspend\");\n\nstatic int ss_delay = 50;\nmodule_param(ss_delay, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(ss_delay,\n\t\t \"seconds to delay before entering selective suspend\");\n\nenum RTS51X_STAT {\n\tRTS51X_STAT_INIT,\n\tRTS51X_STAT_IDLE,\n\tRTS51X_STAT_RUN,\n\tRTS51X_STAT_SS\n};\n\n#define POLLING_INTERVAL\t50\n\n#define rts51x_set_stat(chip, stat)\t\\\n\t((chip)->state = (enum RTS51X_STAT)(stat))\n#define rts51x_get_stat(chip)\t\t((chip)->state)\n\n#define SET_LUN_READY(chip, lun)\t((chip)->lun_ready |= ((u8)1 << (lun)))\n#define CLR_LUN_READY(chip, lun)\t((chip)->lun_ready &= ~((u8)1 << (lun)))\n#define TST_LUN_READY(chip, lun)\t((chip)->lun_ready & ((u8)1 << (lun)))\n\n#endif\n\nstruct rts51x_status {\n\tu16 vid;\n\tu16 pid;\n\tu8 cur_lun;\n\tu8 card_type;\n\tu8 total_lun;\n\tu16 fw_ver;\n\tu8 phy_exist;\n\tu8 multi_flag;\n\tu8 multi_card;\n\tu8 log_exist;\n\tunion {\n\t\tu8 detailed_type1;\n\t\tu8 detailed_type2;\n\t} detailed_type;\n\tu8 function[2];\n};\n\nstruct rts51x_chip {\n\tu16 vendor_id;\n\tu16 product_id;\n\tchar max_lun;\n\n\tstruct rts51x_status *status;\n\tint status_len;\n\n\tu32 flag;\n\tstruct us_data *us;\n\n#ifdef CONFIG_REALTEK_AUTOPM\n\tstruct timer_list rts51x_suspend_timer;\n\tunsigned long timer_expires;\n\tint pwr_state;\n\tu8 lun_ready;\n\tenum RTS51X_STAT state;\n\tint support_auto_delink;\n#endif\n\t \n\tproto_cmnd proto_handler_backup;\n};\n\n \n#define FLIDX_AUTO_DELINK\t\t0x01\n\n#define SCSI_LUN(srb)\t\t\t((srb)->device->lun)\n\n \n#define SET_BIT(data, idx)\t\t((data) |= 1 << (idx))\n#define CLR_BIT(data, idx)\t\t((data) &= ~(1 << (idx)))\n#define CHK_BIT(data, idx)\t\t((data) & (1 << (idx)))\n\n#define SET_AUTO_DELINK(chip)\t\t((chip)->flag |= FLIDX_AUTO_DELINK)\n#define CLR_AUTO_DELINK(chip)\t\t((chip)->flag &= ~FLIDX_AUTO_DELINK)\n#define CHK_AUTO_DELINK(chip)\t\t((chip)->flag & FLIDX_AUTO_DELINK)\n\n#define RTS51X_GET_VID(chip)\t\t((chip)->vendor_id)\n#define RTS51X_GET_PID(chip)\t\t((chip)->product_id)\n\n#define VENDOR_ID(chip)\t\t\t((chip)->status[0].vid)\n#define PRODUCT_ID(chip)\t\t((chip)->status[0].pid)\n#define FW_VERSION(chip)\t\t((chip)->status[0].fw_ver)\n#define STATUS_LEN(chip)\t\t((chip)->status_len)\n\n#define STATUS_SUCCESS\t\t0\n#define STATUS_FAIL\t\t1\n\n \n#define SUPPORT_DETAILED_TYPE1(chip)\t\\\n\t\tCHK_BIT((chip)->status[0].function[0], 1)\n#define SUPPORT_OT(chip)\t\t\\\n\t\tCHK_BIT((chip)->status[0].function[0], 2)\n#define SUPPORT_OC(chip)\t\t\\\n\t\tCHK_BIT((chip)->status[0].function[0], 3)\n#define SUPPORT_AUTO_DELINK(chip)\t\\\n\t\tCHK_BIT((chip)->status[0].function[0], 4)\n#define SUPPORT_SDIO(chip)\t\t\\\n\t\tCHK_BIT((chip)->status[0].function[1], 0)\n#define SUPPORT_DETAILED_TYPE2(chip)\t\\\n\t\tCHK_BIT((chip)->status[0].function[1], 1)\n\n#define CHECK_PID(chip, pid)\t\t(RTS51X_GET_PID(chip) == (pid))\n#define CHECK_FW_VER(chip, fw_ver)\t(FW_VERSION(chip) == (fw_ver))\n#define CHECK_ID(chip, pid, fw_ver)\t\\\n\t\t(CHECK_PID((chip), (pid)) && CHECK_FW_VER((chip), (fw_ver)))\n\nstatic int init_realtek_cr(struct us_data *us);\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{\\\n\tUSB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n\t.driver_info = (flags) \\\n}\n\nstatic const struct usb_device_id realtek_cr_ids[] = {\n#\tinclude \"unusual_realtek.h\"\n\t{}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, realtek_cr_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev realtek_cr_unusual_dev_list[] = {\n#\tinclude \"unusual_realtek.h\"\n\t{}\t\t\t \n};\n\n#undef UNUSUAL_DEV\n\nstatic int rts51x_bulk_transport(struct us_data *us, u8 lun,\n\t\t\t\t u8 *cmd, int cmd_len, u8 *buf, int buf_len,\n\t\t\t\t enum dma_data_direction dir, int *act_len)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *)us->iobuf;\n\tstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *)us->iobuf;\n\tint result;\n\tunsigned int residue;\n\tunsigned int cswlen;\n\tunsigned int cbwlen = US_BULK_CB_WRAP_LEN;\n\n\t \n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = cpu_to_le32(buf_len);\n\tbcb->Flags = (dir == DMA_FROM_DEVICE) ? US_BULK_FLAG_IN : 0;\n\tbcb->Tag = ++us->tag;\n\tbcb->Lun = lun;\n\tbcb->Length = cmd_len;\n\n\t \n\tmemset(bcb->CDB, 0, sizeof(bcb->CDB));\n\tmemcpy(bcb->CDB, cmd, bcb->Length);\n\n\t \n\tresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\t\t\t    bcb, cbwlen, NULL);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\t \n\n\tif (buf && buf_len) {\n\t\tunsigned int pipe = (dir == DMA_FROM_DEVICE) ?\n\t\t    us->recv_bulk_pipe : us->send_bulk_pipe;\n\t\tresult = usb_stor_bulk_transfer_buf(us, pipe,\n\t\t\t\t\t\t    buf, buf_len, NULL);\n\t\tif (result == USB_STOR_XFER_ERROR)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\t\t    bcs, US_BULK_CS_WRAP_LEN, &cswlen);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tif (bcs->Signature != cpu_to_le32(US_BULK_CS_SIGN)) {\n\t\tusb_stor_dbg(us, \"Signature mismatch: got %08X, expecting %08X\\n\",\n\t\t\t     le32_to_cpu(bcs->Signature), US_BULK_CS_SIGN);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tresidue = bcs->Residue;\n\tif (bcs->Tag != us->tag)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tif (residue)\n\t\tresidue = residue < buf_len ? residue : buf_len;\n\n\tif (act_len)\n\t\t*act_len = buf_len - residue;\n\n\t \n\tswitch (bcs->Status) {\n\tcase US_BULK_STAT_OK:\n\t\t \n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tcase US_BULK_STAT_FAIL:\n\t\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\tcase US_BULK_STAT_PHASE:\n\t\t \n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\nstatic int rts51x_bulk_transport_special(struct us_data *us, u8 lun,\n\t\t\t\t u8 *cmd, int cmd_len, u8 *buf, int buf_len,\n\t\t\t\t enum dma_data_direction dir, int *act_len)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;\n\tint result;\n\tunsigned int cswlen;\n\tunsigned int cbwlen = US_BULK_CB_WRAP_LEN;\n\n\t \n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = cpu_to_le32(buf_len);\n\tbcb->Flags = (dir == DMA_FROM_DEVICE) ? US_BULK_FLAG_IN : 0;\n\tbcb->Tag = ++us->tag;\n\tbcb->Lun = lun;\n\tbcb->Length = cmd_len;\n\n\t \n\tmemset(bcb->CDB, 0, sizeof(bcb->CDB));\n\tmemcpy(bcb->CDB, cmd, bcb->Length);\n\n\t \n\tresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\t\tbcb, cbwlen, NULL);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\t \n\n\tif (buf && buf_len) {\n\t\tunsigned int pipe = (dir == DMA_FROM_DEVICE) ?\n\t\t\t\tus->recv_bulk_pipe : us->send_bulk_pipe;\n\t\tresult = usb_stor_bulk_transfer_buf(us, pipe,\n\t\t\t\tbuf, buf_len, NULL);\n\t\tif (result == USB_STOR_XFER_ERROR)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tresult = usb_bulk_msg(us->pusb_dev, us->recv_bulk_pipe, bcs,\n\t\t\tUS_BULK_CS_WRAP_LEN, &cswlen, 250);\n\treturn result;\n}\n\n \nstatic int rts51x_get_max_lun(struct us_data *us)\n{\n\tint result;\n\n\t \n\tus->iobuf[0] = 0;\n\tresult = usb_stor_control_msg(us, us->recv_ctrl_pipe,\n\t\t\t\t      US_BULK_GET_MAX_LUN,\n\t\t\t\t      USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t\t      USB_RECIP_INTERFACE,\n\t\t\t\t      0, us->ifnum, us->iobuf, 1, 10 * HZ);\n\n\tusb_stor_dbg(us, \"GetMaxLUN command result is %d, data is %d\\n\",\n\t\t     result, us->iobuf[0]);\n\n\t \n\tif (result > 0)\n\t\treturn us->iobuf[0];\n\n\treturn 0;\n}\n\nstatic int rts51x_read_mem(struct us_data *us, u16 addr, u8 *data, u16 len)\n{\n\tint retval;\n\tu8 cmnd[12] = { 0 };\n\tu8 *buf;\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tusb_stor_dbg(us, \"addr = 0x%x, len = %d\\n\", addr, len);\n\n\tcmnd[0] = 0xF0;\n\tcmnd[1] = 0x0D;\n\tcmnd[2] = (u8) (addr >> 8);\n\tcmnd[3] = (u8) addr;\n\tcmnd[4] = (u8) (len >> 8);\n\tcmnd[5] = (u8) len;\n\n\tretval = rts51x_bulk_transport(us, 0, cmnd, 12,\n\t\t\t\t       buf, len, DMA_FROM_DEVICE, NULL);\n\tif (retval != USB_STOR_TRANSPORT_GOOD) {\n\t\tkfree(buf);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(data, buf, len);\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int rts51x_write_mem(struct us_data *us, u16 addr, u8 *data, u16 len)\n{\n\tint retval;\n\tu8 cmnd[12] = { 0 };\n\tu8 *buf;\n\n\tbuf = kmemdup(data, len, GFP_NOIO);\n\tif (buf == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tusb_stor_dbg(us, \"addr = 0x%x, len = %d\\n\", addr, len);\n\n\tcmnd[0] = 0xF0;\n\tcmnd[1] = 0x0E;\n\tcmnd[2] = (u8) (addr >> 8);\n\tcmnd[3] = (u8) addr;\n\tcmnd[4] = (u8) (len >> 8);\n\tcmnd[5] = (u8) len;\n\n\tretval = rts51x_bulk_transport(us, 0, cmnd, 12,\n\t\t\t\t       buf, len, DMA_TO_DEVICE, NULL);\n\tkfree(buf);\n\tif (retval != USB_STOR_TRANSPORT_GOOD)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int rts51x_read_status(struct us_data *us,\n\t\t\t      u8 lun, u8 *status, int len, int *actlen)\n{\n\tint retval;\n\tu8 cmnd[12] = { 0 };\n\tu8 *buf;\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (buf == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tusb_stor_dbg(us, \"lun = %d\\n\", lun);\n\n\tcmnd[0] = 0xF0;\n\tcmnd[1] = 0x09;\n\n\tretval = rts51x_bulk_transport(us, lun, cmnd, 12,\n\t\t\t\t       buf, len, DMA_FROM_DEVICE, actlen);\n\tif (retval != USB_STOR_TRANSPORT_GOOD) {\n\t\tkfree(buf);\n\t\treturn -EIO;\n\t}\n\n\tmemcpy(status, buf, len);\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int rts51x_check_status(struct us_data *us, u8 lun)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tint retval;\n\tu8 buf[16];\n\n\tretval = rts51x_read_status(us, lun, buf, 16, &(chip->status_len));\n\tif (retval != STATUS_SUCCESS)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"chip->status_len = %d\\n\", chip->status_len);\n\n\tchip->status[lun].vid = ((u16) buf[0] << 8) | buf[1];\n\tchip->status[lun].pid = ((u16) buf[2] << 8) | buf[3];\n\tchip->status[lun].cur_lun = buf[4];\n\tchip->status[lun].card_type = buf[5];\n\tchip->status[lun].total_lun = buf[6];\n\tchip->status[lun].fw_ver = ((u16) buf[7] << 8) | buf[8];\n\tchip->status[lun].phy_exist = buf[9];\n\tchip->status[lun].multi_flag = buf[10];\n\tchip->status[lun].multi_card = buf[11];\n\tchip->status[lun].log_exist = buf[12];\n\tif (chip->status_len == 16) {\n\t\tchip->status[lun].detailed_type.detailed_type1 = buf[13];\n\t\tchip->status[lun].function[0] = buf[14];\n\t\tchip->status[lun].function[1] = buf[15];\n\t}\n\n\treturn 0;\n}\n\nstatic int enable_oscillator(struct us_data *us)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = rts51x_read_mem(us, 0xFE77, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\tvalue |= 0x04;\n\tretval = rts51x_write_mem(us, 0xFE77, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\tretval = rts51x_read_mem(us, 0xFE77, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\tif (!(value & 0x04))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int __do_config_autodelink(struct us_data *us, u8 *data, u16 len)\n{\n\tint retval;\n\tu8 cmnd[12] = {0};\n\tu8 *buf;\n\n\tusb_stor_dbg(us, \"addr = 0xfe47, len = %d\\n\", len);\n\n\tbuf = kmemdup(data, len, GFP_NOIO);\n\tif (!buf)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tcmnd[0] = 0xF0;\n\tcmnd[1] = 0x0E;\n\tcmnd[2] = 0xfe;\n\tcmnd[3] = 0x47;\n\tcmnd[4] = (u8)(len >> 8);\n\tcmnd[5] = (u8)len;\n\n\tretval = rts51x_bulk_transport_special(us, 0, cmnd, 12, buf, len, DMA_TO_DEVICE, NULL);\n\tkfree(buf);\n\tif (retval != USB_STOR_TRANSPORT_GOOD) {\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int do_config_autodelink(struct us_data *us, int enable, int force)\n{\n\tint retval;\n\tu8 value;\n\n\tretval = rts51x_read_mem(us, 0xFE47, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\tif (enable) {\n\t\tif (force)\n\t\t\tvalue |= 0x03;\n\t\telse\n\t\t\tvalue |= 0x01;\n\t} else {\n\t\tvalue &= ~0x03;\n\t}\n\n\tusb_stor_dbg(us, \"set 0xfe47 to 0x%x\\n\", value);\n\n\t \n\tretval = __do_config_autodelink(us, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int config_autodelink_after_power_on(struct us_data *us)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tint retval;\n\tu8 value;\n\n\tif (!CHK_AUTO_DELINK(chip))\n\t\treturn 0;\n\n\tretval = rts51x_read_mem(us, 0xFE47, &value, 1);\n\tif (retval < 0)\n\t\treturn -EIO;\n\n\tif (auto_delink_en) {\n\t\tCLR_BIT(value, 0);\n\t\tCLR_BIT(value, 1);\n\t\tSET_BIT(value, 2);\n\n\t\tif (CHECK_ID(chip, 0x0138, 0x3882))\n\t\t\tCLR_BIT(value, 2);\n\n\t\tSET_BIT(value, 7);\n\n\t\t \n\t\tretval = __do_config_autodelink(us, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\n\t\tretval = enable_oscillator(us);\n\t\tif (retval == 0)\n\t\t\t(void)do_config_autodelink(us, 1, 0);\n\t} else {\n\t\t \n\n\t\tSET_BIT(value, 2);\n\n\t\tif (CHECK_ID(chip, 0x0138, 0x3882))\n\t\t\tCLR_BIT(value, 2);\n\n\t\tif (CHECK_ID(chip, 0x0159, 0x5889) ||\n\t\t    CHECK_ID(chip, 0x0138, 0x3880)) {\n\t\t\tCLR_BIT(value, 0);\n\t\t\tCLR_BIT(value, 7);\n\t\t}\n\n\t\t \n\t\tretval = __do_config_autodelink(us, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\n\t\tif (CHECK_ID(chip, 0x0159, 0x5888)) {\n\t\t\tvalue = 0xFF;\n\t\t\tretval = rts51x_write_mem(us, 0xFE79, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tvalue = 0x01;\n\t\t\tretval = rts51x_write_mem(us, 0x48, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int config_autodelink_before_power_down(struct us_data *us)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tint retval;\n\tu8 value;\n\n\tif (!CHK_AUTO_DELINK(chip))\n\t\treturn 0;\n\n\tif (auto_delink_en) {\n\t\tretval = rts51x_read_mem(us, 0xFE77, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\n\t\tSET_BIT(value, 2);\n\t\tretval = rts51x_write_mem(us, 0xFE77, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\n\t\tif (CHECK_ID(chip, 0x0159, 0x5888)) {\n\t\t\tvalue = 0x01;\n\t\t\tretval = rts51x_write_mem(us, 0x48, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\tretval = rts51x_read_mem(us, 0xFE47, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\n\t\tSET_BIT(value, 0);\n\t\tif (CHECK_ID(chip, 0x0138, 0x3882))\n\t\t\tSET_BIT(value, 2);\n\t\tretval = rts51x_write_mem(us, 0xFE77, &value, 1);\n\t\tif (retval < 0)\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (CHECK_ID(chip, 0x0159, 0x5889) ||\n\t\t    CHECK_ID(chip, 0x0138, 0x3880) ||\n\t\t    CHECK_ID(chip, 0x0138, 0x3882)) {\n\t\t\tretval = rts51x_read_mem(us, 0xFE47, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\n\t\t\tif (CHECK_ID(chip, 0x0159, 0x5889) ||\n\t\t\t    CHECK_ID(chip, 0x0138, 0x3880)) {\n\t\t\t\tSET_BIT(value, 0);\n\t\t\t\tSET_BIT(value, 7);\n\t\t\t}\n\n\t\t\tif (CHECK_ID(chip, 0x0138, 0x3882))\n\t\t\t\tSET_BIT(value, 2);\n\n\t\t\t \n\t\t\tretval = __do_config_autodelink(us, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (CHECK_ID(chip, 0x0159, 0x5888)) {\n\t\t\tvalue = 0x01;\n\t\t\tretval = rts51x_write_mem(us, 0x48, &value, 1);\n\t\t\tif (retval < 0)\n\t\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void fw5895_init(struct us_data *us)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tint retval;\n\tu8 val;\n\n\tif ((PRODUCT_ID(chip) != 0x0158) || (FW_VERSION(chip) != 0x5895)) {\n\t\tusb_stor_dbg(us, \"Not the specified device, return immediately!\\n\");\n\t} else {\n\t\tretval = rts51x_read_mem(us, 0xFD6F, &val, 1);\n\t\tif (retval == STATUS_SUCCESS && (val & 0x1F) == 0) {\n\t\t\tval = 0x1F;\n\t\t\tretval = rts51x_write_mem(us, 0xFD70, &val, 1);\n\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\tusb_stor_dbg(us, \"Write memory fail\\n\");\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"Read memory fail, OR (val & 0x1F) != 0\\n\");\n\t\t}\n\t}\n}\n#endif\n\n#ifdef CONFIG_REALTEK_AUTOPM\nstatic void fw5895_set_mmc_wp(struct us_data *us)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tint retval;\n\tu8 buf[13];\n\n\tif ((PRODUCT_ID(chip) != 0x0158) || (FW_VERSION(chip) != 0x5895)) {\n\t\tusb_stor_dbg(us, \"Not the specified device, return immediately!\\n\");\n\t} else {\n\t\tretval = rts51x_read_mem(us, 0xFD6F, buf, 1);\n\t\tif (retval == STATUS_SUCCESS && (buf[0] & 0x24) == 0x24) {\n\t\t\t \n\t\t\tretval = rts51x_read_mem(us, 0xD04E, buf, 1);\n\t\t\tif (retval == STATUS_SUCCESS) {\n\t\t\t\tbuf[0] |= 0x04;\n\t\t\t\tretval = rts51x_write_mem(us, 0xFD70, buf, 1);\n\t\t\t\tif (retval != STATUS_SUCCESS)\n\t\t\t\t\tusb_stor_dbg(us, \"Write memory fail\\n\");\n\t\t\t} else {\n\t\t\t\tusb_stor_dbg(us, \"Read memory fail\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"Read memory fail, OR (buf[0]&0x24)!=0x24\\n\");\n\t\t}\n\t}\n}\n\nstatic void rts51x_modi_suspend_timer(struct rts51x_chip *chip)\n{\n\tstruct us_data *us = chip->us;\n\n\tusb_stor_dbg(us, \"state:%d\\n\", rts51x_get_stat(chip));\n\n\tchip->timer_expires = jiffies + msecs_to_jiffies(1000*ss_delay);\n\tmod_timer(&chip->rts51x_suspend_timer, chip->timer_expires);\n}\n\nstatic void rts51x_suspend_timer_fn(struct timer_list *t)\n{\n\tstruct rts51x_chip *chip = from_timer(chip, t, rts51x_suspend_timer);\n\tstruct us_data *us = chip->us;\n\n\tswitch (rts51x_get_stat(chip)) {\n\tcase RTS51X_STAT_INIT:\n\tcase RTS51X_STAT_RUN:\n\t\trts51x_modi_suspend_timer(chip);\n\t\tbreak;\n\tcase RTS51X_STAT_IDLE:\n\tcase RTS51X_STAT_SS:\n\t\tusb_stor_dbg(us, \"RTS51X_STAT_SS, power.usage:%d\\n\",\n\t\t\t     atomic_read(&us->pusb_intf->dev.power.usage_count));\n\n\t\tif (atomic_read(&us->pusb_intf->dev.power.usage_count) > 0) {\n\t\t\tusb_stor_dbg(us, \"Ready to enter SS state\\n\");\n\t\t\trts51x_set_stat(chip, RTS51X_STAT_SS);\n\t\t\t \n\t\t\tpm_suspend_ignore_children(&us->pusb_intf->dev, true);\n\t\t\tusb_autopm_put_interface_async(us->pusb_intf);\n\t\t\tusb_stor_dbg(us, \"RTS51X_STAT_SS 01, power.usage:%d\\n\",\n\t\t\t\t     atomic_read(&us->pusb_intf->dev.power.usage_count));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tusb_stor_dbg(us, \"Unknown state !!!\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic inline int working_scsi(struct scsi_cmnd *srb)\n{\n\tif ((srb->cmnd[0] == TEST_UNIT_READY) ||\n\t    (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL)) {\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic void rts51x_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstruct rts51x_chip *chip = (struct rts51x_chip *)(us->extra);\n\tstatic int card_first_show = 1;\n\tstatic u8 media_not_present[] = { 0x70, 0, 0x02, 0, 0, 0, 0,\n\t\t10, 0, 0, 0, 0, 0x3A, 0, 0, 0, 0, 0\n\t};\n\tstatic u8 invalid_cmd_field[] = { 0x70, 0, 0x05, 0, 0, 0, 0,\n\t\t10, 0, 0, 0, 0, 0x24, 0, 0, 0, 0, 0\n\t};\n\tint ret;\n\n\tif (working_scsi(srb)) {\n\t\tusb_stor_dbg(us, \"working scsi, power.usage:%d\\n\",\n\t\t\t     atomic_read(&us->pusb_intf->dev.power.usage_count));\n\n\t\tif (atomic_read(&us->pusb_intf->dev.power.usage_count) <= 0) {\n\t\t\tret = usb_autopm_get_interface(us->pusb_intf);\n\t\t\tusb_stor_dbg(us, \"working scsi, ret=%d\\n\", ret);\n\t\t}\n\t\tif (rts51x_get_stat(chip) != RTS51X_STAT_RUN)\n\t\t\trts51x_set_stat(chip, RTS51X_STAT_RUN);\n\t\tchip->proto_handler_backup(srb, us);\n\t} else {\n\t\tif (rts51x_get_stat(chip) == RTS51X_STAT_SS) {\n\t\t\tusb_stor_dbg(us, \"NOT working scsi\\n\");\n\t\t\tif ((srb->cmnd[0] == TEST_UNIT_READY) &&\n\t\t\t    (chip->pwr_state == US_SUSPEND)) {\n\t\t\t\tif (TST_LUN_READY(chip, srb->device->lun)) {\n\t\t\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\t\t} else {\n\t\t\t\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t\t\tmemcpy(srb->sense_buffer,\n\t\t\t\t\t       media_not_present,\n\t\t\t\t\t       US_SENSE_SIZE);\n\t\t\t\t}\n\t\t\t\tusb_stor_dbg(us, \"TEST_UNIT_READY\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\t\t\t\tint prevent = srb->cmnd[4] & 0x1;\n\t\t\t\tif (prevent) {\n\t\t\t\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\t\t\t\tmemcpy(srb->sense_buffer,\n\t\t\t\t\t       invalid_cmd_field,\n\t\t\t\t\t       US_SENSE_SIZE);\n\t\t\t\t} else {\n\t\t\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\t\t}\n\t\t\t\tusb_stor_dbg(us, \"ALLOW_MEDIUM_REMOVAL\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"NOT working scsi, not SS\\n\");\n\t\t\tchip->proto_handler_backup(srb, us);\n\t\t\t \n\t\t\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\t\t\tif (srb->result == SAM_STAT_GOOD) {\n\t\t\t\t\tSET_LUN_READY(chip, srb->device->lun);\n\t\t\t\t\tif (card_first_show) {\n\t\t\t\t\t\tcard_first_show = 0;\n\t\t\t\t\t\tfw5895_set_mmc_wp(us);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tCLR_LUN_READY(chip, srb->device->lun);\n\t\t\t\t\tcard_first_show = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rts51x_get_stat(chip) != RTS51X_STAT_IDLE)\n\t\t\t\trts51x_set_stat(chip, RTS51X_STAT_IDLE);\n\t\t}\n\t}\nout:\n\tusb_stor_dbg(us, \"state:%d\\n\", rts51x_get_stat(chip));\n\tif (rts51x_get_stat(chip) == RTS51X_STAT_RUN)\n\t\trts51x_modi_suspend_timer(chip);\n}\n\nstatic int realtek_cr_autosuspend_setup(struct us_data *us)\n{\n\tstruct rts51x_chip *chip;\n\tstruct rts51x_status *status = NULL;\n\tu8 buf[16];\n\tint retval;\n\n\tchip = (struct rts51x_chip *)us->extra;\n\tchip->support_auto_delink = 0;\n\tchip->pwr_state = US_RESUME;\n\tchip->lun_ready = 0;\n\trts51x_set_stat(chip, RTS51X_STAT_INIT);\n\n\tretval = rts51x_read_status(us, 0, buf, 16, &(chip->status_len));\n\tif (retval != STATUS_SUCCESS) {\n\t\tusb_stor_dbg(us, \"Read status fail\\n\");\n\t\treturn -EIO;\n\t}\n\tstatus = chip->status;\n\tstatus->vid = ((u16) buf[0] << 8) | buf[1];\n\tstatus->pid = ((u16) buf[2] << 8) | buf[3];\n\tstatus->cur_lun = buf[4];\n\tstatus->card_type = buf[5];\n\tstatus->total_lun = buf[6];\n\tstatus->fw_ver = ((u16) buf[7] << 8) | buf[8];\n\tstatus->phy_exist = buf[9];\n\tstatus->multi_flag = buf[10];\n\tstatus->multi_card = buf[11];\n\tstatus->log_exist = buf[12];\n\tif (chip->status_len == 16) {\n\t\tstatus->detailed_type.detailed_type1 = buf[13];\n\t\tstatus->function[0] = buf[14];\n\t\tstatus->function[1] = buf[15];\n\t}\n\n\t \n\tchip = (struct rts51x_chip *)(us->extra);\n\tchip->proto_handler_backup = us->proto_handler;\n\t \n\tpm_runtime_set_autosuspend_delay(&us->pusb_dev->dev, 0);\n\t \n\tus->proto_handler = rts51x_invoke_transport;\n\n\tchip->timer_expires = 0;\n\ttimer_setup(&chip->rts51x_suspend_timer, rts51x_suspend_timer_fn, 0);\n\tfw5895_init(us);\n\n\t \n\tusb_enable_autosuspend(us->pusb_dev);\n\n\treturn 0;\n}\n#endif\n\nstatic void realtek_cr_destructor(void *extra)\n{\n\tstruct rts51x_chip *chip = extra;\n\n\tif (!chip)\n\t\treturn;\n\n#ifdef CONFIG_REALTEK_AUTOPM\n\tif (ss_en) {\n\t\tdel_timer(&chip->rts51x_suspend_timer);\n\t\tchip->timer_expires = 0;\n\t}\n#endif\n\tkfree(chip->status);\n}\n\n#ifdef CONFIG_PM\nstatic int realtek_cr_suspend(struct usb_interface *iface, pm_message_t message)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\t \n\tmutex_lock(&us->dev_mutex);\n\n\tconfig_autodelink_before_power_down(us);\n\n\tmutex_unlock(&us->dev_mutex);\n\n\treturn 0;\n}\n\nstatic int realtek_cr_resume(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\tfw5895_init(us);\n\tconfig_autodelink_after_power_on(us);\n\n\treturn 0;\n}\n#else\n#define realtek_cr_suspend\tNULL\n#define realtek_cr_resume\tNULL\n#endif\n\nstatic int init_realtek_cr(struct us_data *us)\n{\n\tstruct rts51x_chip *chip;\n\tint size, i, retval;\n\n\tchip = kzalloc(sizeof(struct rts51x_chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tus->extra = chip;\n\tus->extra_destructor = realtek_cr_destructor;\n\tus->max_lun = chip->max_lun = rts51x_get_max_lun(us);\n\tchip->us = us;\n\n\tusb_stor_dbg(us, \"chip->max_lun = %d\\n\", chip->max_lun);\n\n\tsize = (chip->max_lun + 1) * sizeof(struct rts51x_status);\n\tchip->status = kzalloc(size, GFP_KERNEL);\n\tif (!chip->status)\n\t\tgoto INIT_FAIL;\n\n\tfor (i = 0; i <= (int)(chip->max_lun); i++) {\n\t\tretval = rts51x_check_status(us, (u8) i);\n\t\tif (retval < 0)\n\t\t\tgoto INIT_FAIL;\n\t}\n\n\tif (CHECK_PID(chip, 0x0138) || CHECK_PID(chip, 0x0158) ||\n\t    CHECK_PID(chip, 0x0159)) {\n\t\tif (CHECK_FW_VER(chip, 0x5888) || CHECK_FW_VER(chip, 0x5889) ||\n\t\t\t\tCHECK_FW_VER(chip, 0x5901))\n\t\t\tSET_AUTO_DELINK(chip);\n\t\tif (STATUS_LEN(chip) == 16) {\n\t\t\tif (SUPPORT_AUTO_DELINK(chip))\n\t\t\t\tSET_AUTO_DELINK(chip);\n\t\t}\n\t}\n#ifdef CONFIG_REALTEK_AUTOPM\n\tif (ss_en)\n\t\trealtek_cr_autosuspend_setup(us);\n#endif\n\n\tusb_stor_dbg(us, \"chip->flag = 0x%x\\n\", chip->flag);\n\n\t(void)config_autodelink_after_power_on(us);\n\n\treturn 0;\n\nINIT_FAIL:\n\tif (us->extra) {\n\t\tkfree(chip->status);\n\t\tkfree(us->extra);\n\t\tus->extra = NULL;\n\t}\n\n\treturn -EIO;\n}\n\nstatic struct scsi_host_template realtek_cr_host_template;\n\nstatic int realtek_cr_probe(struct usb_interface *intf,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tdev_dbg(&intf->dev, \"Probe Realtek Card Reader!\\n\");\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t\t (id - realtek_cr_ids) +\n\t\t\t\t realtek_cr_unusual_dev_list,\n\t\t\t\t &realtek_cr_host_template);\n\tif (result)\n\t\treturn result;\n\n\tresult = usb_stor_probe2(us);\n\n\treturn result;\n}\n\nstatic struct usb_driver realtek_cr_driver = {\n\t.name = DRV_NAME,\n\t.probe = realtek_cr_probe,\n\t.disconnect = usb_stor_disconnect,\n\t \n\t \n\t.reset_resume = usb_stor_reset_resume,\n\t.suspend = realtek_cr_suspend,\n\t.resume = realtek_cr_resume,\n\t.pre_reset = usb_stor_pre_reset,\n\t.post_reset = usb_stor_post_reset,\n\t.id_table = realtek_cr_ids,\n\t.soft_unbind = 1,\n\t.supports_autosuspend = 1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(realtek_cr_driver, realtek_cr_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}