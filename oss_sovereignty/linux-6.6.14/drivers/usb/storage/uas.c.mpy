{
  "module_name": "uas.c",
  "hash_id": "070c38c4ad748ed19b2680f333ffe0b7914242182a39209a2efe3d85f19fbf1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/uas.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb_usual.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/storage.h>\n#include <linux/usb/uas.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_dbg.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n\n#include \"uas-detect.h\"\n#include \"scsiglue.h\"\n\n#define MAX_CMNDS 256\n\nstruct uas_dev_info {\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tstruct usb_anchor cmd_urbs;\n\tstruct usb_anchor sense_urbs;\n\tstruct usb_anchor data_urbs;\n\tunsigned long flags;\n\tint qdepth, resetting;\n\tunsigned cmd_pipe, status_pipe, data_in_pipe, data_out_pipe;\n\tunsigned use_streams:1;\n\tunsigned shutdown:1;\n\tstruct scsi_cmnd *cmnd[MAX_CMNDS];\n\tspinlock_t lock;\n\tstruct work_struct work;\n\tstruct work_struct scan_work;       \n};\n\nenum {\n\tSUBMIT_STATUS_URB\t= BIT(1),\n\tALLOC_DATA_IN_URB\t= BIT(2),\n\tSUBMIT_DATA_IN_URB\t= BIT(3),\n\tALLOC_DATA_OUT_URB\t= BIT(4),\n\tSUBMIT_DATA_OUT_URB\t= BIT(5),\n\tALLOC_CMD_URB\t\t= BIT(6),\n\tSUBMIT_CMD_URB\t\t= BIT(7),\n\tCOMMAND_INFLIGHT        = BIT(8),\n\tDATA_IN_URB_INFLIGHT    = BIT(9),\n\tDATA_OUT_URB_INFLIGHT   = BIT(10),\n\tCOMMAND_ABORTED         = BIT(11),\n\tIS_IN_WORK_LIST         = BIT(12),\n};\n\n \nstruct uas_cmd_info {\n\tunsigned int state;\n\tunsigned int uas_tag;\n\tstruct urb *cmd_urb;\n\tstruct urb *data_in_urb;\n\tstruct urb *data_out_urb;\n};\n\n \nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t\tstruct uas_dev_info *devinfo);\nstatic void uas_do_work(struct work_struct *work);\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller);\nstatic void uas_free_streams(struct uas_dev_info *devinfo);\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t\tint status);\n\n \nstatic struct workqueue_struct *workqueue;\n\nstatic void uas_do_work(struct work_struct *work)\n{\n\tstruct uas_dev_info *devinfo =\n\t\tcontainer_of(work, struct uas_dev_info, work);\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = scsi_cmd_priv(cmnd);\n\n\t\tif (!(cmdinfo->state & IS_IN_WORK_LIST))\n\t\t\tcontinue;\n\n\t\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\t\tif (!err)\n\t\t\tcmdinfo->state &= ~IS_IN_WORK_LIST;\n\t\telse\n\t\t\tqueue_work(workqueue, &devinfo->work);\n\t}\nout:\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_scan_work(struct work_struct *work)\n{\n\tstruct uas_dev_info *devinfo =\n\t\tcontainer_of(work, struct uas_dev_info, scan_work);\n\tstruct Scsi_Host *shost = usb_get_intfdata(devinfo->intf);\n\n\tdev_dbg(&devinfo->intf->dev, \"starting scan\\n\");\n\tscsi_scan_host(shost);\n\tdev_dbg(&devinfo->intf->dev, \"scan complete\\n\");\n}\n\nstatic void uas_add_work(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tcmdinfo->state |= IS_IN_WORK_LIST;\n\tqueue_work(workqueue, &devinfo->work);\n}\n\nstatic void uas_zap_pending(struct uas_dev_info *devinfo, int result)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\tstruct scsi_cmnd *cmnd;\n\tunsigned long flags;\n\tint i, err;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (!devinfo->cmnd[i])\n\t\t\tcontinue;\n\n\t\tcmnd = devinfo->cmnd[i];\n\t\tcmdinfo = scsi_cmd_priv(cmnd);\n\t\tuas_log_cmd_state(cmnd, __func__, 0);\n\t\t \n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tcmnd->result = result << 16;\n\t\terr = uas_try_complete(cmnd, __func__);\n\t\tWARN_ON(err != 0);\n\t}\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_sense(struct urb *urb, struct scsi_cmnd *cmnd)\n{\n\tstruct sense_iu *sense_iu = urb->transfer_buffer;\n\tstruct scsi_device *sdev = cmnd->device;\n\n\tif (urb->actual_length > 16) {\n\t\tunsigned len = be16_to_cpup(&sense_iu->len);\n\t\tif (len + 16 != urb->actual_length) {\n\t\t\tint newlen = min(len + 16, urb->actual_length) - 16;\n\t\t\tif (newlen < 0)\n\t\t\t\tnewlen = 0;\n\t\t\tsdev_printk(KERN_INFO, sdev, \"%s: urb length %d \"\n\t\t\t\t\"disagrees with IU sense data length %d, \"\n\t\t\t\t\"using %d bytes of sense data\\n\", __func__,\n\t\t\t\t\turb->actual_length, len, newlen);\n\t\t\tlen = newlen;\n\t\t}\n\t\tmemcpy(cmnd->sense_buffer, sense_iu->sense, len);\n\t}\n\n\tcmnd->result = sense_iu->status;\n}\n\nstatic void uas_log_cmd_state(struct scsi_cmnd *cmnd, const char *prefix,\n\t\t\t      int status)\n{\n\tstruct uas_cmd_info *ci = scsi_cmd_priv(cmnd);\n\n\tif (status == -ENODEV)  \n\t\treturn;\n\n\tscmd_printk(KERN_INFO, cmnd,\n\t\t    \"%s %d uas-tag %d inflight:%s%s%s%s%s%s%s%s%s%s%s%s \",\n\t\t    prefix, status, ci->uas_tag,\n\t\t    (ci->state & SUBMIT_STATUS_URB)     ? \" s-st\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_IN_URB)     ? \" a-in\"  : \"\",\n\t\t    (ci->state & SUBMIT_DATA_IN_URB)    ? \" s-in\"  : \"\",\n\t\t    (ci->state & ALLOC_DATA_OUT_URB)    ? \" a-out\" : \"\",\n\t\t    (ci->state & SUBMIT_DATA_OUT_URB)   ? \" s-out\" : \"\",\n\t\t    (ci->state & ALLOC_CMD_URB)         ? \" a-cmd\" : \"\",\n\t\t    (ci->state & SUBMIT_CMD_URB)        ? \" s-cmd\" : \"\",\n\t\t    (ci->state & COMMAND_INFLIGHT)      ? \" CMD\"   : \"\",\n\t\t    (ci->state & DATA_IN_URB_INFLIGHT)  ? \" IN\"    : \"\",\n\t\t    (ci->state & DATA_OUT_URB_INFLIGHT) ? \" OUT\"   : \"\",\n\t\t    (ci->state & COMMAND_ABORTED)       ? \" abort\" : \"\",\n\t\t    (ci->state & IS_IN_WORK_LIST)       ? \" work\"  : \"\");\n\tscsi_print_command(cmnd);\n}\n\nstatic void uas_free_unsubmitted_urbs(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo;\n\n\tif (!cmnd)\n\t\treturn;\n\n\tcmdinfo = scsi_cmd_priv(cmnd);\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB)\n\t\tusb_free_urb(cmdinfo->cmd_urb);\n\n\t \n\tif (!(cmdinfo->state & DATA_IN_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_in_urb);\n\tif (!(cmdinfo->state & DATA_OUT_URB_INFLIGHT))\n\t\tusb_free_urb(cmdinfo->data_out_urb);\n}\n\nstatic int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\n{\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & (COMMAND_INFLIGHT |\n\t\t\t      DATA_IN_URB_INFLIGHT |\n\t\t\t      DATA_OUT_URB_INFLIGHT |\n\t\t\t      COMMAND_ABORTED))\n\t\treturn -EBUSY;\n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tuas_free_unsubmitted_urbs(cmnd);\n\tscsi_done(cmnd);\n\treturn 0;\n}\n\nstatic void uas_xfer_data(struct urb *urb, struct scsi_cmnd *cmnd,\n\t\t\t  unsigned direction)\n{\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tint err;\n\n\tcmdinfo->state |= direction | SUBMIT_STATUS_URB;\n\terr = uas_submit_urbs(cmnd, cmnd->device->hostdata);\n\tif (err) {\n\t\tuas_add_work(cmnd);\n\t}\n}\n\nstatic bool uas_evaluate_response_iu(struct response_iu *riu, struct scsi_cmnd *cmnd)\n{\n\tu8 response_code = riu->response_code;\n\n\tswitch (response_code) {\n\tcase RC_INCORRECT_LUN:\n\t\tset_host_byte(cmnd, DID_BAD_TARGET);\n\t\tbreak;\n\tcase RC_TMF_SUCCEEDED:\n\t\tset_host_byte(cmnd, DID_OK);\n\t\tbreak;\n\tcase RC_TMF_NOT_SUPPORTED:\n\t\tset_host_byte(cmnd, DID_BAD_TARGET);\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"response iu\", response_code);\n\t\tset_host_byte(cmnd, DID_ERROR);\n\t\tbreak;\n\t}\n\n\treturn response_code == RC_TMF_SUCCEEDED;\n}\n\nstatic void uas_stat_cmplt(struct urb *urb)\n{\n\tstruct iu *iu = urb->transfer_buffer;\n\tstruct Scsi_Host *shost = urb->context;\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tstruct scsi_cmnd *cmnd;\n\tstruct uas_cmd_info *cmdinfo;\n\tunsigned long flags;\n\tunsigned int idx;\n\tint status = urb->status;\n\tbool success;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tdev_err(&urb->dev->dev, \"stat urb: status %d\\n\", status);\n\t\tgoto out;\n\t}\n\n\tidx = be16_to_cpup(&iu->tag) - 1;\n\tif (idx >= MAX_CMNDS || !devinfo->cmnd[idx]) {\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"stat urb: no pending cmd for uas-tag %d\\n\", idx + 1);\n\t\tgoto out;\n\t}\n\n\tcmnd = devinfo->cmnd[idx];\n\tcmdinfo = scsi_cmd_priv(cmnd);\n\n\tif (!(cmdinfo->state & COMMAND_INFLIGHT)) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected status cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tswitch (iu->iu_id) {\n\tcase IU_ID_STATUS:\n\t\tuas_sense(urb, cmnd);\n\t\tif (cmnd->result != 0) {\n\t\t\t \n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tcase IU_ID_READ_READY:\n\t\tif (!cmdinfo->data_in_urb ||\n\t\t\t\t(cmdinfo->state & DATA_IN_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected read rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_IN_URB);\n\t\tbreak;\n\tcase IU_ID_WRITE_READY:\n\t\tif (!cmdinfo->data_out_urb ||\n\t\t\t\t(cmdinfo->state & DATA_OUT_URB_INFLIGHT)) {\n\t\t\tuas_log_cmd_state(cmnd, \"unexpected write rdy\", 0);\n\t\t\tbreak;\n\t\t}\n\t\tuas_xfer_data(urb, cmnd, SUBMIT_DATA_OUT_URB);\n\t\tbreak;\n\tcase IU_ID_RESPONSE:\n\t\tcmdinfo->state &= ~COMMAND_INFLIGHT;\n\t\tsuccess = uas_evaluate_response_iu((struct response_iu *)iu, cmnd);\n\t\tif (!success) {\n\t\t\t \n\t\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\t\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\t\t}\n\t\tuas_try_complete(cmnd, __func__);\n\t\tbreak;\n\tdefault:\n\t\tuas_log_cmd_state(cmnd, \"bogus IU\", iu->iu_id);\n\t}\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\t \n\tif (data_in_urb) {\n\t\tusb_unlink_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_unlink_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n}\n\nstatic void uas_data_cmplt(struct urb *urb)\n{\n\tstruct scsi_cmnd *cmnd = urb->context;\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct scsi_data_buffer *sdb = &cmnd->sdb;\n\tunsigned long flags;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (cmdinfo->data_in_urb == urb) {\n\t\tcmdinfo->state &= ~DATA_IN_URB_INFLIGHT;\n\t\tcmdinfo->data_in_urb = NULL;\n\t} else if (cmdinfo->data_out_urb == urb) {\n\t\tcmdinfo->state &= ~DATA_OUT_URB_INFLIGHT;\n\t\tcmdinfo->data_out_urb = NULL;\n\t}\n\n\tif (devinfo->resetting)\n\t\tgoto out;\n\n\t \n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tuas_log_cmd_state(cmnd, \"unexpected data cmplt\", 0);\n\t\tgoto out;\n\t}\n\n\tif (status) {\n\t\tif (status != -ENOENT && status != -ECONNRESET && status != -ESHUTDOWN)\n\t\t\tuas_log_cmd_state(cmnd, \"data cmplt err\", status);\n\t\t \n\t\tscsi_set_resid(cmnd, sdb->length);\n\t} else {\n\t\tscsi_set_resid(cmnd, sdb->length - urb->actual_length);\n\t}\n\tuas_try_complete(cmnd, __func__);\nout:\n\tusb_free_urb(urb);\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n}\n\nstatic void uas_cmd_cmplt(struct urb *urb)\n{\n\tif (urb->status)\n\t\tdev_err(&urb->dev->dev, \"cmd cmplt err %d\\n\", urb->status);\n\n\tusb_free_urb(urb);\n}\n\nstatic struct urb *uas_alloc_data_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t      struct scsi_cmnd *cmnd,\n\t\t\t\t      enum dma_data_direction dir)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct scsi_data_buffer *sdb = &cmnd->sdb;\n\tunsigned int pipe = (dir == DMA_FROM_DEVICE)\n\t\t? devinfo->data_in_pipe : devinfo->data_out_pipe;\n\n\tif (!urb)\n\t\tgoto out;\n\tusb_fill_bulk_urb(urb, udev, pipe, NULL, sdb->length,\n\t\t\t  uas_data_cmplt, cmnd);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->num_sgs = udev->bus->sg_tablesize ? sdb->table.nents : 0;\n\turb->sg = sdb->table.sgl;\n out:\n\treturn urb;\n}\n\nstatic struct urb *uas_alloc_sense_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t       struct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct sense_iu *iu;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tiu = kzalloc(sizeof(*iu), gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->status_pipe, iu, sizeof(*iu),\n\t\t\t  uas_stat_cmplt, cmnd->device->host);\n\tif (devinfo->use_streams)\n\t\turb->stream_id = cmdinfo->uas_tag;\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\nstatic struct urb *uas_alloc_cmd_urb(struct uas_dev_info *devinfo, gfp_t gfp,\n\t\t\t\t\tstruct scsi_cmnd *cmnd)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct urb *urb = usb_alloc_urb(0, gfp);\n\tstruct command_iu *iu;\n\tint len;\n\n\tif (!urb)\n\t\tgoto out;\n\n\tlen = cmnd->cmd_len - 16;\n\tif (len < 0)\n\t\tlen = 0;\n\tlen = ALIGN(len, 4);\n\tiu = kzalloc(sizeof(*iu) + len, gfp);\n\tif (!iu)\n\t\tgoto free;\n\n\tiu->iu_id = IU_ID_COMMAND;\n\tiu->tag = cpu_to_be16(cmdinfo->uas_tag);\n\tiu->prio_attr = UAS_SIMPLE_TAG;\n\tiu->len = len;\n\tint_to_scsilun(sdev->lun, &iu->lun);\n\tmemcpy(iu->cdb, cmnd->cmnd, cmnd->cmd_len);\n\n\tusb_fill_bulk_urb(urb, udev, devinfo->cmd_pipe, iu, sizeof(*iu) + len,\n\t\t\t\t\t\t\tuas_cmd_cmplt, NULL);\n\turb->transfer_flags |= URB_FREE_BUFFER;\n out:\n\treturn urb;\n free:\n\tusb_free_urb(urb);\n\treturn NULL;\n}\n\n \n\nstatic struct urb *uas_submit_sense_urb(struct scsi_cmnd *cmnd, gfp_t gfp)\n{\n\tstruct uas_dev_info *devinfo = cmnd->device->hostdata;\n\tstruct urb *urb;\n\tint err;\n\n\turb = uas_alloc_sense_urb(devinfo, gfp, cmnd);\n\tif (!urb)\n\t\treturn NULL;\n\tusb_anchor_urb(urb, &devinfo->sense_urbs);\n\terr = usb_submit_urb(urb, gfp);\n\tif (err) {\n\t\tusb_unanchor_urb(urb);\n\t\tuas_log_cmd_state(cmnd, \"sense submit err\", err);\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\treturn urb;\n}\n\nstatic int uas_submit_urbs(struct scsi_cmnd *cmnd,\n\t\t\t   struct uas_dev_info *devinfo)\n{\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct urb *urb;\n\tint err;\n\n\tlockdep_assert_held(&devinfo->lock);\n\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\turb = uas_submit_sense_urb(cmnd, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~SUBMIT_STATUS_URB;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_IN_URB) {\n\t\tcmdinfo->data_in_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_FROM_DEVICE);\n\t\tif (!cmdinfo->data_in_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_IN_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_IN_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_in_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_in_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_in_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data in submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_IN_URB;\n\t\tcmdinfo->state |= DATA_IN_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_DATA_OUT_URB) {\n\t\tcmdinfo->data_out_urb = uas_alloc_data_urb(devinfo, GFP_ATOMIC,\n\t\t\t\t\t\t\tcmnd, DMA_TO_DEVICE);\n\t\tif (!cmdinfo->data_out_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_DATA_OUT_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_DATA_OUT_URB) {\n\t\tusb_anchor_urb(cmdinfo->data_out_urb, &devinfo->data_urbs);\n\t\terr = usb_submit_urb(cmdinfo->data_out_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->data_out_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"data out submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->state &= ~SUBMIT_DATA_OUT_URB;\n\t\tcmdinfo->state |= DATA_OUT_URB_INFLIGHT;\n\t}\n\n\tif (cmdinfo->state & ALLOC_CMD_URB) {\n\t\tcmdinfo->cmd_urb = uas_alloc_cmd_urb(devinfo, GFP_ATOMIC, cmnd);\n\t\tif (!cmdinfo->cmd_urb)\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\tcmdinfo->state &= ~ALLOC_CMD_URB;\n\t}\n\n\tif (cmdinfo->state & SUBMIT_CMD_URB) {\n\t\tusb_anchor_urb(cmdinfo->cmd_urb, &devinfo->cmd_urbs);\n\t\terr = usb_submit_urb(cmdinfo->cmd_urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(cmdinfo->cmd_urb);\n\t\t\tuas_log_cmd_state(cmnd, \"cmd submit err\", err);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tcmdinfo->cmd_urb = NULL;\n\t\tcmdinfo->state &= ~SUBMIT_CMD_URB;\n\t\tcmdinfo->state |= COMMAND_INFLIGHT;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_queuecommand_lck(struct scsi_cmnd *cmnd)\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tunsigned long flags;\n\tint idx, err;\n\n\t \n\tif (cmnd->device->host->host_self_blocked)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\tif ((devinfo->flags & US_FL_NO_ATA_1X) &&\n\t\t\t(cmnd->cmnd[0] == ATA_12 || cmnd->cmnd[0] == ATA_16)) {\n\t\tmemcpy(cmnd->sense_buffer, usb_stor_sense_invalidCDB,\n\t\t       sizeof(usb_stor_sense_invalidCDB));\n\t\tcmnd->result = SAM_STAT_CHECK_CONDITION;\n\t\tscsi_done(cmnd);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tif (devinfo->resetting) {\n\t\tset_host_byte(cmnd, DID_ERROR);\n\t\tscsi_done(cmnd);\n\t\tgoto zombie;\n\t}\n\n\t \n\tfor (idx = 0; idx < devinfo->qdepth; idx++) {\n\t\tif (!devinfo->cmnd[idx])\n\t\t\tbreak;\n\t}\n\tif (idx == devinfo->qdepth) {\n\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t}\n\n\tmemset(cmdinfo, 0, sizeof(*cmdinfo));\n\tcmdinfo->uas_tag = idx + 1;  \n\tcmdinfo->state = SUBMIT_STATUS_URB | ALLOC_CMD_URB | SUBMIT_CMD_URB;\n\n\tswitch (cmnd->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\t\tbreak;\n\tcase DMA_BIDIRECTIONAL:\n\t\tcmdinfo->state |= ALLOC_DATA_IN_URB | SUBMIT_DATA_IN_URB;\n\t\tfallthrough;\n\tcase DMA_TO_DEVICE:\n\t\tcmdinfo->state |= ALLOC_DATA_OUT_URB | SUBMIT_DATA_OUT_URB;\n\t\tbreak;\n\tcase DMA_NONE:\n\t\tbreak;\n\t}\n\n\tif (!devinfo->use_streams)\n\t\tcmdinfo->state &= ~(SUBMIT_DATA_IN_URB | SUBMIT_DATA_OUT_URB);\n\n\terr = uas_submit_urbs(cmnd, devinfo);\n\t \n\tif (err == -ENODEV) {\n\t\tset_host_byte(cmnd, DID_ERROR);\n\t\tscsi_done(cmnd);\n\t\tgoto zombie;\n\t}\n\tif (err) {\n\t\t \n\t\tif (cmdinfo->state & SUBMIT_STATUS_URB) {\n\t\t\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\t\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\t\t}\n\t\tuas_add_work(cmnd);\n\t}\n\n\tdevinfo->cmnd[idx] = cmnd;\nzombie:\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(uas_queuecommand)\n\n \nstatic int uas_eh_abort_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct uas_cmd_info *cmdinfo = scsi_cmd_priv(cmnd);\n\tstruct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n\tstruct urb *data_in_urb = NULL;\n\tstruct urb *data_out_urb = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tuas_log_cmd_state(cmnd, __func__, 0);\n\n\t \n\tcmdinfo->state |= COMMAND_ABORTED;\n\n\t \n\tdevinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n\tif (cmdinfo->state & DATA_IN_URB_INFLIGHT)\n\t\tdata_in_urb = usb_get_urb(cmdinfo->data_in_urb);\n\tif (cmdinfo->state & DATA_OUT_URB_INFLIGHT)\n\t\tdata_out_urb = usb_get_urb(cmdinfo->data_out_urb);\n\n\tuas_free_unsubmitted_urbs(cmnd);\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tif (data_in_urb) {\n\t\tusb_kill_urb(data_in_urb);\n\t\tusb_put_urb(data_in_urb);\n\t}\n\tif (data_out_urb) {\n\t\tusb_kill_urb(data_out_urb);\n\t\tusb_put_urb(data_out_urb);\n\t}\n\n\treturn FAILED;\n}\n\nstatic int uas_eh_device_reset_handler(struct scsi_cmnd *cmnd)\n{\n\tstruct scsi_device *sdev = cmnd->device;\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\tstruct usb_device *udev = devinfo->udev;\n\tunsigned long flags;\n\tint err;\n\n\terr = usb_lock_device_for_reset(udev, devinfo->intf);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, sdev->host,\n\t\t\t     \"%s FAILED to get lock err %d\\n\", __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s start\\n\", __func__);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_RESET);\n\n\terr = usb_reset_device(udev);\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 0;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tusb_unlock_device(udev);\n\n\tif (err) {\n\t\tshost_printk(KERN_INFO, sdev->host, \"%s FAILED err %d\\n\",\n\t\t\t     __func__, err);\n\t\treturn FAILED;\n\t}\n\n\tshost_printk(KERN_INFO, sdev->host, \"%s success\\n\", __func__);\n\treturn SUCCESS;\n}\n\nstatic int uas_target_alloc(struct scsi_target *starget)\n{\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)\n\t\t\tdev_to_shost(starget->dev.parent)->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_LUNS)\n\t\tstarget->no_report_luns = 1;\n\n\treturn 0;\n}\n\nstatic int uas_slave_alloc(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo =\n\t\t(struct uas_dev_info *)sdev->host->hostdata;\n\n\tsdev->hostdata = devinfo;\n\n\t \n\tblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\n\n\tif (devinfo->flags & US_FL_MAX_SECTORS_64)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 64);\n\telse if (devinfo->flags & US_FL_MAX_SECTORS_240)\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 240);\n\n\treturn 0;\n}\n\nstatic int uas_slave_configure(struct scsi_device *sdev)\n{\n\tstruct uas_dev_info *devinfo = sdev->hostdata;\n\n\tif (devinfo->flags & US_FL_NO_REPORT_OPCODES)\n\t\tsdev->no_report_opcodes = 1;\n\n\t \n\tif (devinfo->flags & US_FL_BROKEN_FUA)\n\t\tsdev->broken_fua = 1;\n\n\t \n\tif (devinfo->flags & US_FL_ALWAYS_SYNC) {\n\t\tsdev->skip_ms_page_3f = 1;\n\t\tsdev->skip_ms_page_8 = 1;\n\t\tsdev->wce_default_on = 1;\n\t}\n\n\t \n\tif (devinfo->flags & US_FL_NO_READ_CAPACITY_16)\n\t\tsdev->no_read_capacity_16 = 1;\n\n\t \n\tif (devinfo->flags & US_FL_NO_SAME)\n\t\tsdev->no_write_same = 1;\n\t \n\tif (devinfo->flags & US_FL_FIX_CAPACITY)\n\t\tsdev->fix_capacity = 1;\n\n\t \n\tif (devinfo->flags & US_FL_CAPACITY_HEURISTICS)\n\t\tsdev->guess_capacity = 1;\n\n\t \n\tif (devinfo->flags & US_FL_NO_WP_DETECT)\n\t\tsdev->skip_ms_page_3f = 1;\n\n\tscsi_change_queue_depth(sdev, devinfo->qdepth - 2);\n\treturn 0;\n}\n\nstatic const struct scsi_host_template uas_host_template = {\n\t.module = THIS_MODULE,\n\t.name = \"uas\",\n\t.queuecommand = uas_queuecommand,\n\t.target_alloc = uas_target_alloc,\n\t.slave_alloc = uas_slave_alloc,\n\t.slave_configure = uas_slave_configure,\n\t.eh_abort_handler = uas_eh_abort_handler,\n\t.eh_device_reset_handler = uas_eh_device_reset_handler,\n\t.this_id = -1,\n\t.skip_settle_delay = 1,\n\t.dma_boundary = PAGE_SIZE - 1,\n\t.cmd_size = sizeof(struct uas_cmd_info),\n};\n\n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n\t.driver_info = (flags) }\n\nstatic struct usb_device_id uas_usb_ids[] = {\n#\tinclude \"unusual_uas.h\"\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_BULK) },\n\t{ USB_INTERFACE_INFO(USB_CLASS_MASS_STORAGE, USB_SC_SCSI, USB_PR_UAS) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, uas_usb_ids);\n\n#undef UNUSUAL_DEV\n\nstatic int uas_switch_interface(struct usb_device *udev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt;\n\n\talt = uas_find_uas_alt_setting(intf);\n\tif (!alt)\n\t\treturn -ENODEV;\n\n\treturn usb_set_interface(udev, alt->desc.bInterfaceNumber,\n\t\t\talt->desc.bAlternateSetting);\n}\n\nstatic int uas_configure_endpoints(struct uas_dev_info *devinfo)\n{\n\tstruct usb_host_endpoint *eps[4] = { };\n\tstruct usb_device *udev = devinfo->udev;\n\tint r;\n\n\tr = uas_find_endpoints(devinfo->intf->cur_altsetting, eps);\n\tif (r)\n\t\treturn r;\n\n\tdevinfo->cmd_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[0]->desc));\n\tdevinfo->status_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[1]->desc));\n\tdevinfo->data_in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[2]->desc));\n\tdevinfo->data_out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t    usb_endpoint_num(&eps[3]->desc));\n\n\tif (udev->speed < USB_SPEED_SUPER) {\n\t\tdevinfo->qdepth = 32;\n\t\tdevinfo->use_streams = 0;\n\t} else {\n\t\tdevinfo->qdepth = usb_alloc_streams(devinfo->intf, eps + 1,\n\t\t\t\t\t\t    3, MAX_CMNDS, GFP_NOIO);\n\t\tif (devinfo->qdepth < 0)\n\t\t\treturn devinfo->qdepth;\n\t\tdevinfo->use_streams = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic void uas_free_streams(struct uas_dev_info *devinfo)\n{\n\tstruct usb_device *udev = devinfo->udev;\n\tstruct usb_host_endpoint *eps[3];\n\n\teps[0] = usb_pipe_endpoint(udev, devinfo->status_pipe);\n\teps[1] = usb_pipe_endpoint(udev, devinfo->data_in_pipe);\n\teps[2] = usb_pipe_endpoint(udev, devinfo->data_out_pipe);\n\tusb_free_streams(devinfo->intf, eps, 3, GFP_NOIO);\n}\n\nstatic int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tint result = -ENOMEM;\n\tstruct Scsi_Host *shost = NULL;\n\tstruct uas_dev_info *devinfo;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tunsigned long dev_flags;\n\n\tif (!uas_use_uas_driver(intf, id, &dev_flags))\n\t\treturn -ENODEV;\n\n\tif (uas_switch_interface(udev, intf))\n\t\treturn -ENODEV;\n\n\tshost = scsi_host_alloc(&uas_host_template,\n\t\t\t\tsizeof(struct uas_dev_info));\n\tif (!shost)\n\t\tgoto set_alt0;\n\n\tshost->max_cmd_len = 16 + 252;\n\tshost->max_id = 1;\n\tshost->max_lun = 256;\n\tshost->max_channel = 0;\n\tshost->sg_tablesize = udev->bus->sg_tablesize;\n\n\tdevinfo = (struct uas_dev_info *)shost->hostdata;\n\tdevinfo->intf = intf;\n\tdevinfo->udev = udev;\n\tdevinfo->resetting = 0;\n\tdevinfo->shutdown = 0;\n\tdevinfo->flags = dev_flags;\n\tinit_usb_anchor(&devinfo->cmd_urbs);\n\tinit_usb_anchor(&devinfo->sense_urbs);\n\tinit_usb_anchor(&devinfo->data_urbs);\n\tspin_lock_init(&devinfo->lock);\n\tINIT_WORK(&devinfo->work, uas_do_work);\n\tINIT_WORK(&devinfo->scan_work, uas_scan_work);\n\n\tresult = uas_configure_endpoints(devinfo);\n\tif (result)\n\t\tgoto set_alt0;\n\n\t \n\tshost->can_queue = devinfo->qdepth - 2;\n\n\tusb_set_intfdata(intf, shost);\n\tresult = scsi_add_host(shost, &intf->dev);\n\tif (result)\n\t\tgoto free_streams;\n\n\t \n\tschedule_work(&devinfo->scan_work);\n\n\treturn result;\n\nfree_streams:\n\tuas_free_streams(devinfo);\n\tusb_set_intfdata(intf, NULL);\nset_alt0:\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tif (shost)\n\t\tscsi_host_put(shost);\n\treturn result;\n}\n\nstatic int uas_cmnd_list_empty(struct uas_dev_info *devinfo)\n{\n\tunsigned long flags;\n\tint i, r = 1;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\n\tfor (i = 0; i < devinfo->qdepth; i++) {\n\t\tif (devinfo->cmnd[i]) {\n\t\t\tr = 0;  \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\treturn r;\n}\n\n \nstatic int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)\n{\n\tunsigned long start_time;\n\tint r;\n\n\tstart_time = jiffies;\n\tdo {\n\t\tflush_work(&devinfo->work);\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tr = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);\n\t\tif (r == 0)\n\t\t\treturn -ETIME;\n\n\t\tif (time_after(jiffies, start_time + 5 * HZ))\n\t\t\treturn -ETIME;\n\t} while (!uas_cmnd_list_empty(devinfo));\n\n\treturn 0;\n}\n\nstatic int uas_pre_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_block_requests(shost);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\tscsi_unblock_requests(shost);\n\t\treturn 1;\n\t}\n\n\tuas_free_streams(devinfo);\n\n\treturn 0;\n}\n\nstatic int uas_post_reset(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\tif (devinfo->shutdown)\n\t\treturn 0;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err && err != -ENODEV)\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\n\t \n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\tscsi_unblock_requests(shost);\n\n\treturn err ? 1 : 0;\n}\n\nstatic int uas_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (uas_wait_for_pending_cmnds(devinfo) != 0) {\n\t\tshost_printk(KERN_ERR, shost, \"%s: timed out\\n\", __func__);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nstatic int uas_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic int uas_reset_resume(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\tint err;\n\n\terr = uas_configure_endpoints(devinfo);\n\tif (err) {\n\t\tshost_printk(KERN_ERR, shost,\n\t\t\t     \"%s: alloc streams error %d after reset\",\n\t\t\t     __func__, err);\n\t\treturn -EIO;\n\t}\n\n\tspin_lock_irqsave(shost->host_lock, flags);\n\tscsi_report_bus_reset(shost, 0);\n\tspin_unlock_irqrestore(shost->host_lock, flags);\n\n\treturn 0;\n}\n\nstatic void uas_disconnect(struct usb_interface *intf)\n{\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&devinfo->lock, flags);\n\tdevinfo->resetting = 1;\n\tspin_unlock_irqrestore(&devinfo->lock, flags);\n\n\tcancel_work_sync(&devinfo->work);\n\tusb_kill_anchored_urbs(&devinfo->cmd_urbs);\n\tusb_kill_anchored_urbs(&devinfo->sense_urbs);\n\tusb_kill_anchored_urbs(&devinfo->data_urbs);\n\tuas_zap_pending(devinfo, DID_NO_CONNECT);\n\n\t \n\tcancel_work_sync(&devinfo->scan_work);\n\n\tscsi_remove_host(shost);\n\tuas_free_streams(devinfo);\n\tscsi_host_put(shost);\n}\n\n \nstatic void uas_shutdown(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct Scsi_Host *shost = usb_get_intfdata(intf);\n\tstruct uas_dev_info *devinfo = (struct uas_dev_info *)shost->hostdata;\n\n\tif (system_state != SYSTEM_RESTART)\n\t\treturn;\n\n\tdevinfo->shutdown = 1;\n\tuas_free_streams(devinfo);\n\tusb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, 0);\n\tusb_reset_device(udev);\n}\n\nstatic struct usb_driver uas_driver = {\n\t.name = \"uas\",\n\t.probe = uas_probe,\n\t.disconnect = uas_disconnect,\n\t.pre_reset = uas_pre_reset,\n\t.post_reset = uas_post_reset,\n\t.suspend = uas_suspend,\n\t.resume = uas_resume,\n\t.reset_resume = uas_reset_resume,\n\t.drvwrap.driver.shutdown = uas_shutdown,\n\t.id_table = uas_usb_ids,\n};\n\nstatic int __init uas_init(void)\n{\n\tint rv;\n\n\tworkqueue = alloc_workqueue(\"uas\", WQ_MEM_RECLAIM, 0);\n\tif (!workqueue)\n\t\treturn -ENOMEM;\n\n\trv = usb_register(&uas_driver);\n\tif (rv) {\n\t\tdestroy_workqueue(workqueue);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit uas_exit(void)\n{\n\tusb_deregister(&uas_driver);\n\tdestroy_workqueue(workqueue);\n}\n\nmodule_init(uas_init);\nmodule_exit(uas_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\nMODULE_AUTHOR(\n\t\"Hans de Goede <hdegoede@redhat.com>, Matthew Wilcox and Sarah Sharp\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}