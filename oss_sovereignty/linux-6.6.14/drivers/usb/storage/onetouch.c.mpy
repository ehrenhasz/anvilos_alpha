{
  "module_name": "onetouch.c",
  "hash_id": "dfb7b946dc2cc41ed6e68e02da3d8d397a68f0320dfdc9d7dd9ff3344c336c1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/onetouch.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/input.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/input.h>\n#include \"usb.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-onetouch\"\n\nMODULE_DESCRIPTION(\"Maxtor USB OneTouch hard drive button driver\");\nMODULE_AUTHOR(\"Nick Sillik <n.sillik@temple.edu>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n#define ONETOUCH_PKT_LEN        0x02\n#define ONETOUCH_BUTTON         KEY_PROG1\n\nstatic int onetouch_connect_input(struct us_data *ss);\nstatic void onetouch_release_input(void *onetouch_);\n\nstruct usb_onetouch {\n\tchar name[128];\n\tchar phys[64];\n\tstruct input_dev *dev;\t \n\tstruct usb_device *udev;\t \n\n\tstruct urb *irq;\t \n\tunsigned char *data;\t \n\tdma_addr_t data_dma;\n\tunsigned int is_open:1;\n};\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id onetouch_usb_ids[] = {\n#\tinclude \"unusual_onetouch.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, onetouch_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev onetouch_unusual_dev_list[] = {\n#\tinclude \"unusual_onetouch.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\nstatic void usb_onetouch_irq(struct urb *urb)\n{\n\tstruct usb_onetouch *onetouch = urb->context;\n\tsigned char *data = onetouch->data;\n\tstruct input_dev *dev = onetouch->dev;\n\tint status = urb->status;\n\tint retval;\n\n\tswitch (status) {\n\tcase 0:\t\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\t \n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\t \n\tdefault:\t\t \n\t\tgoto resubmit;\n\t}\n\n\tinput_report_key(dev, ONETOUCH_BUTTON, data[0] & 0x02);\n\tinput_sync(dev);\n\nresubmit:\n\tretval = usb_submit_urb (urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->dev, \"can't resubmit intr, %s-%s/input0, \"\n\t\t\t\"retval %d\\n\", onetouch->udev->bus->bus_name,\n\t\t\tonetouch->udev->devpath, retval);\n}\n\nstatic int usb_onetouch_open(struct input_dev *dev)\n{\n\tstruct usb_onetouch *onetouch = input_get_drvdata(dev);\n\n\tonetouch->is_open = 1;\n\tonetouch->irq->dev = onetouch->udev;\n\tif (usb_submit_urb(onetouch->irq, GFP_KERNEL)) {\n\t\tdev_err(&dev->dev, \"usb_submit_urb failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic void usb_onetouch_close(struct input_dev *dev)\n{\n\tstruct usb_onetouch *onetouch = input_get_drvdata(dev);\n\n\tusb_kill_urb(onetouch->irq);\n\tonetouch->is_open = 0;\n}\n\n#ifdef CONFIG_PM\nstatic void usb_onetouch_pm_hook(struct us_data *us, int action)\n{\n\tstruct usb_onetouch *onetouch = (struct usb_onetouch *) us->extra;\n\n\tif (onetouch->is_open) {\n\t\tswitch (action) {\n\t\tcase US_SUSPEND:\n\t\t\tusb_kill_urb(onetouch->irq);\n\t\t\tbreak;\n\t\tcase US_RESUME:\n\t\t\tif (usb_submit_urb(onetouch->irq, GFP_NOIO) != 0)\n\t\t\t\tdev_err(&onetouch->irq->dev->dev,\n\t\t\t\t\t\"usb_submit_urb failed\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n#endif  \n\nstatic int onetouch_connect_input(struct us_data *ss)\n{\n\tstruct usb_device *udev = ss->pusb_dev;\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_onetouch *onetouch;\n\tstruct input_dev *input_dev;\n\tint pipe, maxp;\n\tint error = -ENOMEM;\n\n\tinterface = ss->pusb_intf->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints != 3)\n\t\treturn -ENODEV;\n\n\tendpoint = &interface->endpoint[2].desc;\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\treturn -ENODEV;\n\n\tpipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(udev, pipe);\n\tmaxp = min(maxp, ONETOUCH_PKT_LEN);\n\n\tonetouch = kzalloc(sizeof(struct usb_onetouch), GFP_KERNEL);\n\tinput_dev = input_allocate_device();\n\tif (!onetouch || !input_dev)\n\t\tgoto fail1;\n\n\tonetouch->data = usb_alloc_coherent(udev, ONETOUCH_PKT_LEN,\n\t\t\t\t\t    GFP_KERNEL, &onetouch->data_dma);\n\tif (!onetouch->data)\n\t\tgoto fail1;\n\n\tonetouch->irq = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!onetouch->irq)\n\t\tgoto fail2;\n\n\tonetouch->udev = udev;\n\tonetouch->dev = input_dev;\n\n\tif (udev->manufacturer)\n\t\tstrscpy(onetouch->name, udev->manufacturer,\n\t\t\tsizeof(onetouch->name));\n\tif (udev->product) {\n\t\tif (udev->manufacturer)\n\t\t\tstrlcat(onetouch->name, \" \", sizeof(onetouch->name));\n\t\tstrlcat(onetouch->name, udev->product, sizeof(onetouch->name));\n\t}\n\n\tif (!strlen(onetouch->name))\n\t\tsnprintf(onetouch->name, sizeof(onetouch->name),\n\t\t\t \"Maxtor Onetouch %04x:%04x\",\n\t\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t\t le16_to_cpu(udev->descriptor.idProduct));\n\n\tusb_make_path(udev, onetouch->phys, sizeof(onetouch->phys));\n\tstrlcat(onetouch->phys, \"/input0\", sizeof(onetouch->phys));\n\n\tinput_dev->name = onetouch->name;\n\tinput_dev->phys = onetouch->phys;\n\tusb_to_input_id(udev, &input_dev->id);\n\tinput_dev->dev.parent = &udev->dev;\n\n\tset_bit(EV_KEY, input_dev->evbit);\n\tset_bit(ONETOUCH_BUTTON, input_dev->keybit);\n\tclear_bit(0, input_dev->keybit);\n\n\tinput_set_drvdata(input_dev, onetouch);\n\n\tinput_dev->open = usb_onetouch_open;\n\tinput_dev->close = usb_onetouch_close;\n\n\tusb_fill_int_urb(onetouch->irq, udev, pipe, onetouch->data, maxp,\n\t\t\t usb_onetouch_irq, onetouch, endpoint->bInterval);\n\tonetouch->irq->transfer_dma = onetouch->data_dma;\n\tonetouch->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tss->extra_destructor = onetouch_release_input;\n\tss->extra = onetouch;\n#ifdef CONFIG_PM\n\tss->suspend_resume_hook = usb_onetouch_pm_hook;\n#endif\n\n\terror = input_register_device(onetouch->dev);\n\tif (error)\n\t\tgoto fail3;\n\n\treturn 0;\n\n fail3:\tusb_free_urb(onetouch->irq);\n fail2:\tusb_free_coherent(udev, ONETOUCH_PKT_LEN,\n\t\t\t  onetouch->data, onetouch->data_dma);\n fail1:\tkfree(onetouch);\n\tinput_free_device(input_dev);\n\treturn error;\n}\n\nstatic void onetouch_release_input(void *onetouch_)\n{\n\tstruct usb_onetouch *onetouch = (struct usb_onetouch *) onetouch_;\n\n\tif (onetouch) {\n\t\tusb_kill_urb(onetouch->irq);\n\t\tinput_unregister_device(onetouch->dev);\n\t\tusb_free_urb(onetouch->irq);\n\t\tusb_free_coherent(onetouch->udev, ONETOUCH_PKT_LEN,\n\t\t\t\t  onetouch->data, onetouch->data_dma);\n\t}\n}\n\nstatic struct scsi_host_template onetouch_host_template;\n\nstatic int onetouch_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - onetouch_usb_ids) + onetouch_unusual_dev_list,\n\t\t\t&onetouch_host_template);\n\tif (result)\n\t\treturn result;\n\n\t \n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver onetouch_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tonetouch_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tonetouch_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(onetouch_driver, onetouch_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}