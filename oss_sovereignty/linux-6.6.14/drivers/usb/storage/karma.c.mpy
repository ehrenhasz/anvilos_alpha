{
  "module_name": "karma.c",
  "hash_id": "5d36043e4e8d9f7a76ddc7c054c8c187ec371d61607590677b36e69fa089004c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/karma.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-karma\"\n\nMODULE_DESCRIPTION(\"Driver for Rio Karma\");\nMODULE_AUTHOR(\"Bob Copeland <me@bobcopeland.com>, Keith Bennett <keith@mcs.st-and.ac.uk>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n#define RIO_PREFIX \"RIOP\\x00\"\n#define RIO_PREFIX_LEN 5\n#define RIO_SEND_LEN 40\n#define RIO_RECV_LEN 0x200\n\n#define RIO_ENTER_STORAGE 0x1\n#define RIO_LEAVE_STORAGE 0x2\n#define RIO_RESET 0xC\n\nstruct karma_data {\n\tint in_storage;\n\tchar *recv;\n};\n\nstatic int rio_karma_init(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id karma_usb_ids[] = {\n#\tinclude \"unusual_karma.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, karma_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev karma_unusual_dev_list[] = {\n#\tinclude \"unusual_karma.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n \nstatic int rio_karma_send_command(char cmd, struct us_data *us)\n{\n\tint result;\n\tunsigned long timeout;\n\tstatic unsigned char seq = 1;\n\tstruct karma_data *data = (struct karma_data *) us->extra;\n\n\tusb_stor_dbg(us, \"sending command %04x\\n\", cmd);\n\tmemset(us->iobuf, 0, RIO_SEND_LEN);\n\tmemcpy(us->iobuf, RIO_PREFIX, RIO_PREFIX_LEN);\n\tus->iobuf[5] = cmd;\n\tus->iobuf[6] = seq;\n\n\ttimeout = jiffies + msecs_to_jiffies(6000);\n\tfor (;;) {\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\tus->iobuf, RIO_SEND_LEN, NULL);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto err;\n\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\tdata->recv, RIO_RECV_LEN, NULL);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto err;\n\n\t\tif (data->recv[5] == seq)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tgoto err;\n\n\t\tus->iobuf[4] = 0x80;\n\t\tus->iobuf[5] = 0;\n\t\tmsleep(50);\n\t}\n\n\tseq++;\n\tif (seq == 0)\n\t\tseq = 1;\n\n\tusb_stor_dbg(us, \"sent command %04x\\n\", cmd);\n\treturn 0;\nerr:\n\tusb_stor_dbg(us, \"command %04x failed\\n\", cmd);\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\n \nstatic int rio_karma_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint ret;\n\tstruct karma_data *data = (struct karma_data *) us->extra;\n\n\tif (srb->cmnd[0] == READ_10 && !data->in_storage) {\n\t\tret = rio_karma_send_command(RIO_ENTER_STORAGE, us);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->in_storage = 1;\n\t\treturn usb_stor_Bulk_transport(srb, us);\n\t} else if (srb->cmnd[0] == START_STOP) {\n\t\tret = rio_karma_send_command(RIO_LEAVE_STORAGE, us);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdata->in_storage = 0;\n\t\treturn rio_karma_send_command(RIO_RESET, us);\n\t}\n\treturn usb_stor_Bulk_transport(srb, us);\n}\n\nstatic void rio_karma_destructor(void *extra)\n{\n\tstruct karma_data *data = (struct karma_data *) extra;\n\n\tkfree(data->recv);\n}\n\nstatic int rio_karma_init(struct us_data *us)\n{\n\tstruct karma_data *data = kzalloc(sizeof(struct karma_data), GFP_NOIO);\n\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->recv = kmalloc(RIO_RECV_LEN, GFP_NOIO);\n\tif (!data->recv) {\n\t\tkfree(data);\n\t\treturn -ENOMEM;\n\t}\n\n\tus->extra = data;\n\tus->extra_destructor = rio_karma_destructor;\n\tif (rio_karma_send_command(RIO_ENTER_STORAGE, us))\n\t\treturn -EIO;\n\n\tdata->in_storage = 1;\n\n\treturn 0;\n}\n\nstatic struct scsi_host_template karma_host_template;\n\nstatic int karma_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - karma_usb_ids) + karma_unusual_dev_list,\n\t\t\t&karma_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name = \"Rio Karma/Bulk\";\n\tus->transport = rio_karma_transport;\n\tus->transport_reset = usb_stor_Bulk_reset;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver karma_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tkarma_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tkarma_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(karma_driver, karma_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}