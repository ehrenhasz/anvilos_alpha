{
  "module_name": "usb.c",
  "hash_id": "8ebaf170469b126e3e2bad85b41e4fd40d98992e8454b3fd0329ba2bada48024",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/usb.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_USB_STORAGE_DEBUG\n#define DEBUG\n#endif\n\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/mutex.h>\n#include <linux/utsname.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"scsiglue.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"initializers.h\"\n\n#include \"sierra_ms.h\"\n#include \"option_ms.h\"\n\n#if IS_ENABLED(CONFIG_USB_UAS)\n#include \"uas-detect.h\"\n#endif\n\n#define DRV_NAME \"usb-storage\"\n\n \nMODULE_AUTHOR(\"Matthew Dharm <mdharm-usb@one-eyed-alien.net>\");\nMODULE_DESCRIPTION(\"USB Mass Storage driver for Linux\");\nMODULE_LICENSE(\"GPL\");\n\nstatic unsigned int delay_use = 1;\nmodule_param(delay_use, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(delay_use, \"seconds to delay before using a new device\");\n\nstatic char quirks[128];\nmodule_param_string(quirks, quirks, sizeof(quirks), S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(quirks, \"supplemental list of device IDs and their quirks\");\n\n\n \n\n \n\n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\n#define COMPLIANT_DEV\tUNUSUAL_DEV\n\n#define USUAL_DEV(use_protocol, use_transport) \\\n{ \\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n}\n\n#define UNUSUAL_VENDOR_INTF(idVendor, cl, sc, pr, \\\n\t\tvendor_name, product_name, use_protocol, use_transport, \\\n\t\tinit_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic const struct us_unusual_dev us_unusual_dev_list[] = {\n#\tinclude \"unusual_devs.h\"\n\t{ }\t\t \n};\n\nstatic const struct us_unusual_dev for_dynamic_ids =\n\t\tUSUAL_DEV(USB_SC_SCSI, USB_PR_BULK);\n\n#undef UNUSUAL_DEV\n#undef COMPLIANT_DEV\n#undef USUAL_DEV\n#undef UNUSUAL_VENDOR_INTF\n\n#ifdef CONFIG_LOCKDEP\n\nstatic struct lock_class_key us_interface_key[USB_MAXINTERFACES];\n\nstatic void us_set_lock_class(struct mutex *mutex,\n\t\tstruct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_config *config = udev->actconfig;\n\tint i;\n\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tif (config->interface[i] == intf)\n\t\t\tbreak;\n\t}\n\n\tBUG_ON(i == config->desc.bNumInterfaces);\n\n\tlockdep_set_class(mutex, &us_interface_key[i]);\n}\n\n#else\n\nstatic void us_set_lock_class(struct mutex *mutex,\n\t\tstruct usb_interface *intf)\n{\n}\n\n#endif\n\n#ifdef CONFIG_PM\t \n\nint usb_stor_suspend(struct usb_interface *iface, pm_message_t message)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\t \n\tmutex_lock(&us->dev_mutex);\n\n\tif (us->suspend_resume_hook)\n\t\t(us->suspend_resume_hook)(us, US_SUSPEND);\n\n\t \n\n\tmutex_unlock(&us->dev_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_stor_suspend);\n\nint usb_stor_resume(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\tmutex_lock(&us->dev_mutex);\n\n\tif (us->suspend_resume_hook)\n\t\t(us->suspend_resume_hook)(us, US_RESUME);\n\n\tmutex_unlock(&us->dev_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_stor_resume);\n\nint usb_stor_reset_resume(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\t \n\tusb_stor_report_bus_reset(us);\n\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_stor_reset_resume);\n\n#endif  \n\n \n\nint usb_stor_pre_reset(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\t \n\tmutex_lock(&us->dev_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_stor_pre_reset);\n\nint usb_stor_post_reset(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\n\t \n\tusb_stor_report_bus_reset(us);\n\n\t \n\n\tmutex_unlock(&us->dev_mutex);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_stor_post_reset);\n\n \n\nvoid fill_inquiry_response(struct us_data *us, unsigned char *data,\n\t\tunsigned int data_len)\n{\n\tif (data_len < 36)  \n\t\treturn;\n\n\tmemset(data+8, ' ', 28);\n\tif (data[0]&0x20) {  \n\t} else {\n\t\tu16 bcdDevice = le16_to_cpu(us->pusb_dev->descriptor.bcdDevice);\n\t\tint n;\n\n\t\tn = strlen(us->unusual_dev->vendorName);\n\t\tmemcpy(data+8, us->unusual_dev->vendorName, min(8, n));\n\t\tn = strlen(us->unusual_dev->productName);\n\t\tmemcpy(data+16, us->unusual_dev->productName, min(16, n));\n\n\t\tdata[32] = 0x30 + ((bcdDevice>>12) & 0x0F);\n\t\tdata[33] = 0x30 + ((bcdDevice>>8) & 0x0F);\n\t\tdata[34] = 0x30 + ((bcdDevice>>4) & 0x0F);\n\t\tdata[35] = 0x30 + ((bcdDevice) & 0x0F);\n\t}\n\n\tusb_stor_set_xfer_buf(data, data_len, us->srb);\n}\nEXPORT_SYMBOL_GPL(fill_inquiry_response);\n\nstatic int usb_stor_control_thread(void * __us)\n{\n\tstruct us_data *us = (struct us_data *)__us;\n\tstruct Scsi_Host *host = us_to_host(us);\n\tstruct scsi_cmnd *srb;\n\n\tfor (;;) {\n\t\tusb_stor_dbg(us, \"*** thread sleeping\\n\");\n\t\tif (wait_for_completion_interruptible(&us->cmnd_ready))\n\t\t\tbreak;\n\n\t\tusb_stor_dbg(us, \"*** thread awakened\\n\");\n\n\t\t \n\t\tmutex_lock(&(us->dev_mutex));\n\n\t\t \n\t\tscsi_lock(host);\n\n\t\t \n\t\tsrb = us->srb;\n\t\tif (srb == NULL) {\n\t\t\tscsi_unlock(host);\n\t\t\tmutex_unlock(&us->dev_mutex);\n\t\t\tusb_stor_dbg(us, \"-- exiting\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\t\tsrb->result = DID_ABORT << 16;\n\t\t\tgoto SkipForAbort;\n\t\t}\n\n\t\tscsi_unlock(host);\n\n\t\t \n\t\tif (srb->sc_data_direction == DMA_BIDIRECTIONAL) {\n\t\t\tusb_stor_dbg(us, \"UNKNOWN data direction\\n\");\n\t\t\tsrb->result = DID_ERROR << 16;\n\t\t}\n\n\t\t \n\t\telse if (srb->device->id &&\n\t\t\t\t!(us->fflags & US_FL_SCM_MULT_TARG)) {\n\t\t\tusb_stor_dbg(us, \"Bad target number (%d:%llu)\\n\",\n\t\t\t\t     srb->device->id,\n\t\t\t\t     srb->device->lun);\n\t\t\tsrb->result = DID_BAD_TARGET << 16;\n\t\t}\n\n\t\telse if (srb->device->lun > us->max_lun) {\n\t\t\tusb_stor_dbg(us, \"Bad LUN (%d:%llu)\\n\",\n\t\t\t\t     srb->device->id,\n\t\t\t\t     srb->device->lun);\n\t\t\tsrb->result = DID_BAD_TARGET << 16;\n\t\t}\n\n\t\t \n\t\telse if ((srb->cmnd[0] == INQUIRY) &&\n\t\t\t    (us->fflags & US_FL_FIX_INQUIRY)) {\n\t\t\tunsigned char data_ptr[36] = {\n\t\t\t    0x00, 0x80, 0x02, 0x02,\n\t\t\t    0x1F, 0x00, 0x00, 0x00};\n\n\t\t\tusb_stor_dbg(us, \"Faking INQUIRY command\\n\");\n\t\t\tfill_inquiry_response(us, data_ptr, 36);\n\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tUS_DEBUG(usb_stor_show_command(us, srb));\n\t\t\tus->proto_handler(srb, us);\n\t\t\tusb_mark_last_busy(us->pusb_dev);\n\t\t}\n\n\t\t \n\t\tscsi_lock(host);\n\n\t\t \n\t\tif (srb->result == DID_ABORT << 16) {\nSkipForAbort:\n\t\t\tusb_stor_dbg(us, \"scsi command aborted\\n\");\n\t\t\tsrb = NULL;\t \n\t\t}\n\n\t\t \n\t\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\t\tcomplete(&(us->notify));\n\n\t\t\t \n\t\t\tclear_bit(US_FLIDX_ABORTING, &us->dflags);\n\t\t\tclear_bit(US_FLIDX_TIMED_OUT, &us->dflags);\n\t\t}\n\n\t\t \n\t\tus->srb = NULL;\n\t\tscsi_unlock(host);\n\n\t\t \n\t\tmutex_unlock(&us->dev_mutex);\n\n\t\t \n\t\tif (srb) {\n\t\t\tusb_stor_dbg(us, \"scsi cmd done, result=0x%x\\n\",\n\t\t\t\t\tsrb->result);\n\t\t\tscsi_done_direct(srb);\n\t\t}\n\t}  \n\n\t \n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_stop())\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\treturn 0;\n}\n\n \n\n \nstatic int associate_dev(struct us_data *us, struct usb_interface *intf)\n{\n\t \n\tus->pusb_dev = interface_to_usbdev(intf);\n\tus->pusb_intf = intf;\n\tus->ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\tusb_stor_dbg(us, \"Vendor: 0x%04x, Product: 0x%04x, Revision: 0x%04x\\n\",\n\t\t     le16_to_cpu(us->pusb_dev->descriptor.idVendor),\n\t\t     le16_to_cpu(us->pusb_dev->descriptor.idProduct),\n\t\t     le16_to_cpu(us->pusb_dev->descriptor.bcdDevice));\n\tusb_stor_dbg(us, \"Interface Subclass: 0x%02x, Protocol: 0x%02x\\n\",\n\t\t     intf->cur_altsetting->desc.bInterfaceSubClass,\n\t\t     intf->cur_altsetting->desc.bInterfaceProtocol);\n\n\t \n\tusb_set_intfdata(intf, us);\n\n\t \n\tus->cr = kmalloc(sizeof(*us->cr), GFP_KERNEL);\n\tif (!us->cr)\n\t\treturn -ENOMEM;\n\n\tus->iobuf = usb_alloc_coherent(us->pusb_dev, US_IOBUF_SIZE,\n\t\t\tGFP_KERNEL, &us->iobuf_dma);\n\tif (!us->iobuf) {\n\t\tusb_stor_dbg(us, \"I/O buffer allocation failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \n#define TOLOWER(x) ((x) | 0x20)\n\n \nvoid usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)\n{\n\tchar *p;\n\tu16 vid = le16_to_cpu(udev->descriptor.idVendor);\n\tu16 pid = le16_to_cpu(udev->descriptor.idProduct);\n\tunsigned f = 0;\n\tunsigned int mask = (US_FL_SANE_SENSE | US_FL_BAD_SENSE |\n\t\t\tUS_FL_FIX_CAPACITY | US_FL_IGNORE_UAS |\n\t\t\tUS_FL_CAPACITY_HEURISTICS | US_FL_IGNORE_DEVICE |\n\t\t\tUS_FL_NOT_LOCKABLE | US_FL_MAX_SECTORS_64 |\n\t\t\tUS_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |\n\t\t\tUS_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |\n\t\t\tUS_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |\n\t\t\tUS_FL_INITIAL_READ10 | US_FL_WRITE_CACHE |\n\t\t\tUS_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES |\n\t\t\tUS_FL_MAX_SECTORS_240 | US_FL_NO_REPORT_LUNS |\n\t\t\tUS_FL_ALWAYS_SYNC);\n\n\tp = quirks;\n\twhile (*p) {\n\t\t \n\t\tif (vid == simple_strtoul(p, &p, 16) &&\n\t\t\t\t*p == ':' &&\n\t\t\t\tpid == simple_strtoul(p+1, &p, 16) &&\n\t\t\t\t*p == ':')\n\t\t\tbreak;\n\n\t\t \n\t\twhile (*p) {\n\t\t\tif (*p++ == ',')\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (!*p)\t \n\t\treturn;\n\n\t \n\twhile (*++p && *p != ',') {\n\t\tswitch (TOLOWER(*p)) {\n\t\tcase 'a':\n\t\t\tf |= US_FL_SANE_SENSE;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\t\tf |= US_FL_BAD_SENSE;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tf |= US_FL_FIX_CAPACITY;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tf |= US_FL_NO_READ_DISC_INFO;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tf |= US_FL_NO_READ_CAPACITY_16;\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tf |= US_FL_NO_REPORT_OPCODES;\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tf |= US_FL_MAX_SECTORS_240;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tf |= US_FL_CAPACITY_HEURISTICS;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tf |= US_FL_IGNORE_DEVICE;\n\t\t\tbreak;\n\t\tcase 'j':\n\t\t\tf |= US_FL_NO_REPORT_LUNS;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tf |= US_FL_NO_SAME;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tf |= US_FL_NOT_LOCKABLE;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tf |= US_FL_MAX_SECTORS_64;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tf |= US_FL_INITIAL_READ10;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tf |= US_FL_CAPACITY_OK;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tf |= US_FL_WRITE_CACHE;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tf |= US_FL_IGNORE_RESIDUE;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tf |= US_FL_SINGLE_LUN;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tf |= US_FL_NO_ATA_1X;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tf |= US_FL_IGNORE_UAS;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\tf |= US_FL_NO_WP_DETECT;\n\t\t\tbreak;\n\t\tcase 'y':\n\t\t\tf |= US_FL_ALWAYS_SYNC;\n\t\t\tbreak;\n\t\t \n\t\t}\n\t}\n\t*fflags = (*fflags & ~mask) | f;\n}\nEXPORT_SYMBOL_GPL(usb_stor_adjust_quirks);\n\n \nstatic int get_device_info(struct us_data *us, const struct usb_device_id *id,\n\t\tconst struct us_unusual_dev *unusual_dev)\n{\n\tstruct usb_device *dev = us->pusb_dev;\n\tstruct usb_interface_descriptor *idesc =\n\t\t&us->pusb_intf->cur_altsetting->desc;\n\tstruct device *pdev = &us->pusb_intf->dev;\n\n\t \n\tus->unusual_dev = unusual_dev;\n\tus->subclass = (unusual_dev->useProtocol == USB_SC_DEVICE) ?\n\t\t\tidesc->bInterfaceSubClass :\n\t\t\tunusual_dev->useProtocol;\n\tus->protocol = (unusual_dev->useTransport == USB_PR_DEVICE) ?\n\t\t\tidesc->bInterfaceProtocol :\n\t\t\tunusual_dev->useTransport;\n\tus->fflags = id->driver_info;\n\tusb_stor_adjust_quirks(us->pusb_dev, &us->fflags);\n\n\tif (us->fflags & US_FL_IGNORE_DEVICE) {\n\t\tdev_info(pdev, \"device ignored\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (dev->speed != USB_SPEED_HIGH)\n\t\tus->fflags &= ~US_FL_GO_SLOW;\n\n\tif (us->fflags)\n\t\tdev_info(pdev, \"Quirks match for vid %04x pid %04x: %lx\\n\",\n\t\t\t\tle16_to_cpu(dev->descriptor.idVendor),\n\t\t\t\tle16_to_cpu(dev->descriptor.idProduct),\n\t\t\t\tus->fflags);\n\n\t \n\tif (id->idVendor || id->idProduct) {\n\t\tstatic const char *msgs[3] = {\n\t\t\t\"an unneeded SubClass entry\",\n\t\t\t\"an unneeded Protocol entry\",\n\t\t\t\"unneeded SubClass and Protocol entries\"};\n\t\tstruct usb_device_descriptor *ddesc = &dev->descriptor;\n\t\tint msg = -1;\n\n\t\tif (unusual_dev->useProtocol != USB_SC_DEVICE &&\n\t\t\tus->subclass == idesc->bInterfaceSubClass)\n\t\t\tmsg += 1;\n\t\tif (unusual_dev->useTransport != USB_PR_DEVICE &&\n\t\t\tus->protocol == idesc->bInterfaceProtocol)\n\t\t\tmsg += 2;\n\t\tif (msg >= 0 && !(us->fflags & US_FL_NEED_OVERRIDE))\n\t\t\tdev_notice(pdev, \"This device \"\n\t\t\t\t\t\"(%04x,%04x,%04x S %02x P %02x)\"\n\t\t\t\t\t\" has %s in unusual_devs.h (kernel\"\n\t\t\t\t\t\" %s)\\n\"\n\t\t\t\t\t\"   Please send a copy of this message to \"\n\t\t\t\t\t\"<linux-usb@vger.kernel.org> and \"\n\t\t\t\t\t\"<usb-storage@lists.one-eyed-alien.net>\\n\",\n\t\t\t\t\tle16_to_cpu(ddesc->idVendor),\n\t\t\t\t\tle16_to_cpu(ddesc->idProduct),\n\t\t\t\t\tle16_to_cpu(ddesc->bcdDevice),\n\t\t\t\t\tidesc->bInterfaceSubClass,\n\t\t\t\t\tidesc->bInterfaceProtocol,\n\t\t\t\t\tmsgs[msg],\n\t\t\t\t\tutsname()->release);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void get_transport(struct us_data *us)\n{\n\tswitch (us->protocol) {\n\tcase USB_PR_CB:\n\t\tus->transport_name = \"Control/Bulk\";\n\t\tus->transport = usb_stor_CB_transport;\n\t\tus->transport_reset = usb_stor_CB_reset;\n\t\tus->max_lun = 7;\n\t\tbreak;\n\n\tcase USB_PR_CBI:\n\t\tus->transport_name = \"Control/Bulk/Interrupt\";\n\t\tus->transport = usb_stor_CB_transport;\n\t\tus->transport_reset = usb_stor_CB_reset;\n\t\tus->max_lun = 7;\n\t\tbreak;\n\n\tcase USB_PR_BULK:\n\t\tus->transport_name = \"Bulk\";\n\t\tus->transport = usb_stor_Bulk_transport;\n\t\tus->transport_reset = usb_stor_Bulk_reset;\n\t\tbreak;\n\t}\n}\n\n \nstatic void get_protocol(struct us_data *us)\n{\n\tswitch (us->subclass) {\n\tcase USB_SC_RBC:\n\t\tus->protocol_name = \"Reduced Block Commands (RBC)\";\n\t\tus->proto_handler = usb_stor_transparent_scsi_command;\n\t\tbreak;\n\n\tcase USB_SC_8020:\n\t\tus->protocol_name = \"8020i\";\n\t\tus->proto_handler = usb_stor_pad12_command;\n\t\tus->max_lun = 0;\n\t\tbreak;\n\n\tcase USB_SC_QIC:\n\t\tus->protocol_name = \"QIC-157\";\n\t\tus->proto_handler = usb_stor_pad12_command;\n\t\tus->max_lun = 0;\n\t\tbreak;\n\n\tcase USB_SC_8070:\n\t\tus->protocol_name = \"8070i\";\n\t\tus->proto_handler = usb_stor_pad12_command;\n\t\tus->max_lun = 0;\n\t\tbreak;\n\n\tcase USB_SC_SCSI:\n\t\tus->protocol_name = \"Transparent SCSI\";\n\t\tus->proto_handler = usb_stor_transparent_scsi_command;\n\t\tbreak;\n\n\tcase USB_SC_UFI:\n\t\tus->protocol_name = \"Uniform Floppy Interface (UFI)\";\n\t\tus->proto_handler = usb_stor_ufi_command;\n\t\tbreak;\n\t}\n}\n\n \nstatic int get_pipes(struct us_data *us)\n{\n\tstruct usb_host_interface *alt = us->pusb_intf->cur_altsetting;\n\tstruct usb_endpoint_descriptor *ep_in;\n\tstruct usb_endpoint_descriptor *ep_out;\n\tstruct usb_endpoint_descriptor *ep_int;\n\tint res;\n\n\t \n\tres = usb_find_common_endpoints(alt, &ep_in, &ep_out, NULL, NULL);\n\tif (res) {\n\t\tusb_stor_dbg(us, \"bulk endpoints not found\\n\");\n\t\treturn res;\n\t}\n\n\tres = usb_find_int_in_endpoint(alt, &ep_int);\n\tif (res && us->protocol == USB_PR_CBI) {\n\t\tusb_stor_dbg(us, \"interrupt endpoint not found\\n\");\n\t\treturn res;\n\t}\n\n\t \n\tus->send_ctrl_pipe = usb_sndctrlpipe(us->pusb_dev, 0);\n\tus->recv_ctrl_pipe = usb_rcvctrlpipe(us->pusb_dev, 0);\n\tus->send_bulk_pipe = usb_sndbulkpipe(us->pusb_dev,\n\t\tusb_endpoint_num(ep_out));\n\tus->recv_bulk_pipe = usb_rcvbulkpipe(us->pusb_dev,\n\t\tusb_endpoint_num(ep_in));\n\tif (ep_int) {\n\t\tus->recv_intr_pipe = usb_rcvintpipe(us->pusb_dev,\n\t\t\tusb_endpoint_num(ep_int));\n\t\tus->ep_bInterval = ep_int->bInterval;\n\t}\n\treturn 0;\n}\n\n \nstatic int usb_stor_acquire_resources(struct us_data *us)\n{\n\tint p;\n\tstruct task_struct *th;\n\n\tus->current_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!us->current_urb)\n\t\treturn -ENOMEM;\n\n\t \n\tif (us->unusual_dev->initFunction) {\n\t\tp = us->unusual_dev->initFunction(us);\n\t\tif (p)\n\t\t\treturn p;\n\t}\n\n\t \n\tth = kthread_run(usb_stor_control_thread, us, \"usb-storage\");\n\tif (IS_ERR(th)) {\n\t\tdev_warn(&us->pusb_intf->dev,\n\t\t\t\t\"Unable to start control thread\\n\");\n\t\treturn PTR_ERR(th);\n\t}\n\tus->ctl_thread = th;\n\n\treturn 0;\n}\n\n \nstatic void usb_stor_release_resources(struct us_data *us)\n{\n\t \n\tusb_stor_dbg(us, \"-- sending exit command to thread\\n\");\n\tcomplete(&us->cmnd_ready);\n\tif (us->ctl_thread)\n\t\tkthread_stop(us->ctl_thread);\n\n\t \n\tif (us->extra_destructor) {\n\t\tusb_stor_dbg(us, \"-- calling extra_destructor()\\n\");\n\t\tus->extra_destructor(us->extra);\n\t}\n\n\t \n\tkfree(us->extra);\n\tusb_free_urb(us->current_urb);\n}\n\n \nstatic void dissociate_dev(struct us_data *us)\n{\n\t \n\tkfree(us->cr);\n\tusb_free_coherent(us->pusb_dev, US_IOBUF_SIZE, us->iobuf, us->iobuf_dma);\n\n\t \n\tusb_set_intfdata(us->pusb_intf, NULL);\n}\n\n \nstatic void quiesce_and_remove_host(struct us_data *us)\n{\n\tstruct Scsi_Host *host = us_to_host(us);\n\n\t \n\tif (us->pusb_dev->state == USB_STATE_NOTATTACHED) {\n\t\tset_bit(US_FLIDX_DISCONNECTING, &us->dflags);\n\t\twake_up(&us->delay_wait);\n\t}\n\n\t \n\tcancel_delayed_work_sync(&us->scan_dwork);\n\n\t \n\tif (test_bit(US_FLIDX_SCAN_PENDING, &us->dflags))\n\t\tusb_autopm_put_interface_no_suspend(us->pusb_intf);\n\n\t \n\tscsi_remove_host(host);\n\n\t \n\tscsi_lock(host);\n\tset_bit(US_FLIDX_DISCONNECTING, &us->dflags);\n\tscsi_unlock(host);\n\twake_up(&us->delay_wait);\n}\n\n \nstatic void release_everything(struct us_data *us)\n{\n\tusb_stor_release_resources(us);\n\tdissociate_dev(us);\n\n\t \n\tscsi_host_put(us_to_host(us));\n}\n\n \nstatic void usb_stor_scan_dwork(struct work_struct *work)\n{\n\tstruct us_data *us = container_of(work, struct us_data,\n\t\t\tscan_dwork.work);\n\tstruct device *dev = &us->pusb_intf->dev;\n\n\tdev_dbg(dev, \"starting scan\\n\");\n\n\t \n\tif (us->protocol == USB_PR_BULK &&\n\t    !(us->fflags & US_FL_SINGLE_LUN) &&\n\t    !(us->fflags & US_FL_SCM_MULT_TARG)) {\n\t\tmutex_lock(&us->dev_mutex);\n\t\tus->max_lun = usb_stor_Bulk_max_lun(us);\n\t\t \n\t\tif (us->max_lun >= 8)\n\t\t\tus_to_host(us)->max_lun = us->max_lun+1;\n\t\tmutex_unlock(&us->dev_mutex);\n\t}\n\tscsi_scan_host(us_to_host(us));\n\tdev_dbg(dev, \"scan complete\\n\");\n\n\t \n\n\tusb_autopm_put_interface(us->pusb_intf);\n\tclear_bit(US_FLIDX_SCAN_PENDING, &us->dflags);\n}\n\nstatic unsigned int usb_stor_sg_tablesize(struct usb_interface *intf)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\n\tif (usb_dev->bus->sg_tablesize) {\n\t\treturn usb_dev->bus->sg_tablesize;\n\t}\n\treturn SG_ALL;\n}\n\n \nint usb_stor_probe1(struct us_data **pus,\n\t\tstruct usb_interface *intf,\n\t\tconst struct usb_device_id *id,\n\t\tconst struct us_unusual_dev *unusual_dev,\n\t\tconst struct scsi_host_template *sht)\n{\n\tstruct Scsi_Host *host;\n\tstruct us_data *us;\n\tint result;\n\n\tdev_info(&intf->dev, \"USB Mass Storage device detected\\n\");\n\n\t \n\thost = scsi_host_alloc(sht, sizeof(*us));\n\tif (!host) {\n\t\tdev_warn(&intf->dev, \"Unable to allocate the scsi host\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\thost->max_cmd_len = 16;\n\thost->sg_tablesize = usb_stor_sg_tablesize(intf);\n\t*pus = us = host_to_us(host);\n\tmutex_init(&(us->dev_mutex));\n\tus_set_lock_class(&us->dev_mutex, intf);\n\tinit_completion(&us->cmnd_ready);\n\tinit_completion(&(us->notify));\n\tinit_waitqueue_head(&us->delay_wait);\n\tINIT_DELAYED_WORK(&us->scan_dwork, usb_stor_scan_dwork);\n\n\t \n\tresult = associate_dev(us, intf);\n\tif (result)\n\t\tgoto BadDevice;\n\n\t \n\tresult = get_device_info(us, id, unusual_dev);\n\tif (result)\n\t\tgoto BadDevice;\n\n\t \n\tget_transport(us);\n\tget_protocol(us);\n\n\t \n\treturn 0;\n\nBadDevice:\n\tusb_stor_dbg(us, \"storage_probe() failed\\n\");\n\trelease_everything(us);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_stor_probe1);\n\n \nint usb_stor_probe2(struct us_data *us)\n{\n\tint result;\n\tstruct device *dev = &us->pusb_intf->dev;\n\n\t \n\tif (!us->transport || !us->proto_handler) {\n\t\tresult = -ENXIO;\n\t\tgoto BadDevice;\n\t}\n\tusb_stor_dbg(us, \"Transport: %s\\n\", us->transport_name);\n\tusb_stor_dbg(us, \"Protocol: %s\\n\", us->protocol_name);\n\n\tif (us->fflags & US_FL_SCM_MULT_TARG) {\n\t\t \n\t\tus->max_lun = 7;\n\t\t \n\t\tus_to_host(us)->this_id = 7;\n\t\t \n\t} else {\n\t\t \n\t\tus_to_host(us)->max_id = 1;\n\t\t \n\t\tif (us->transport == usb_stor_Bulk_transport)\n\t\t\tus_to_host(us)->no_scsi2_lun_in_cdb = 1;\n\t}\n\n\t \n\tif (us->fflags & US_FL_SINGLE_LUN)\n\t\tus->max_lun = 0;\n\n\t \n\tresult = get_pipes(us);\n\tif (result)\n\t\tgoto BadDevice;\n\n\t \n\tif (us->fflags & US_FL_INITIAL_READ10)\n\t\tset_bit(US_FLIDX_REDO_READ10, &us->dflags);\n\n\t \n\tresult = usb_stor_acquire_resources(us);\n\tif (result)\n\t\tgoto BadDevice;\n\tusb_autopm_get_interface_no_resume(us->pusb_intf);\n\tsnprintf(us->scsi_name, sizeof(us->scsi_name), \"usb-storage %s\",\n\t\t\t\t\tdev_name(&us->pusb_intf->dev));\n\tresult = scsi_add_host(us_to_host(us), dev);\n\tif (result) {\n\t\tdev_warn(dev,\n\t\t\t\t\"Unable to add the scsi host\\n\");\n\t\tgoto HostAddErr;\n\t}\n\n\t \n\tset_bit(US_FLIDX_SCAN_PENDING, &us->dflags);\n\n\tif (delay_use > 0)\n\t\tdev_dbg(dev, \"waiting for device to settle before scanning\\n\");\n\tqueue_delayed_work(system_freezable_wq, &us->scan_dwork,\n\t\t\tdelay_use * HZ);\n\treturn 0;\n\n\t \nHostAddErr:\n\tusb_autopm_put_interface_no_suspend(us->pusb_intf);\nBadDevice:\n\tusb_stor_dbg(us, \"storage_probe() failed\\n\");\n\trelease_everything(us);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_stor_probe2);\n\n \nvoid usb_stor_disconnect(struct usb_interface *intf)\n{\n\tstruct us_data *us = usb_get_intfdata(intf);\n\n\tquiesce_and_remove_host(us);\n\trelease_everything(us);\n}\nEXPORT_SYMBOL_GPL(usb_stor_disconnect);\n\nstatic struct scsi_host_template usb_stor_host_template;\n\n \nstatic int storage_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tconst struct us_unusual_dev *unusual_dev;\n\tstruct us_data *us;\n\tint result;\n\tint size;\n\n\t \n#if IS_ENABLED(CONFIG_USB_UAS)\n\tif (uas_use_uas_driver(intf, id, NULL))\n\t\treturn -ENXIO;\n#endif\n\n\t \n\tif (usb_usual_ignore_device(intf))\n\t\treturn -ENXIO;\n\n\t \n\n\tsize = ARRAY_SIZE(us_unusual_dev_list);\n\tif (id >= usb_storage_usb_ids && id < usb_storage_usb_ids + size) {\n\t\tunusual_dev = (id - usb_storage_usb_ids) + us_unusual_dev_list;\n\t} else {\n\t\tunusual_dev = &for_dynamic_ids;\n\n\t\tdev_dbg(&intf->dev, \"Use Bulk-Only transport with the Transparent SCSI protocol for dynamic id: 0x%04x 0x%04x\\n\",\n\t\t\tid->idVendor, id->idProduct);\n\t}\n\n\tresult = usb_stor_probe1(&us, intf, id, unusual_dev,\n\t\t\t\t &usb_stor_host_template);\n\tif (result)\n\t\treturn result;\n\n\t \n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver usb_storage_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tstorage_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tusb_storage_usb_ids,\n\t.supports_autosuspend = 1,\n\t.soft_unbind =\t1,\n};\n\nmodule_usb_stor_driver(usb_storage_driver, usb_stor_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}