{
  "module_name": "ene_ub6250.c",
  "hash_id": "6aa1742e2fb1e061eeb48bdf7408a46e5463d6beae4f0be1a444d7c12b5f167f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/ene_ub6250.c",
  "human_readable_source": "\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include <linux/firmware.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define SD_INIT1_FIRMWARE \"ene-ub6250/sd_init1.bin\"\n#define SD_INIT2_FIRMWARE \"ene-ub6250/sd_init2.bin\"\n#define SD_RW_FIRMWARE \"ene-ub6250/sd_rdwr.bin\"\n#define MS_INIT_FIRMWARE \"ene-ub6250/ms_init.bin\"\n#define MSP_RW_FIRMWARE \"ene-ub6250/msp_rdwr.bin\"\n#define MS_RW_FIRMWARE \"ene-ub6250/ms_rdwr.bin\"\n\n#define DRV_NAME \"ums_eneub6250\"\n\nMODULE_DESCRIPTION(\"Driver for ENE UB6250 reader\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\nMODULE_FIRMWARE(SD_INIT1_FIRMWARE);\nMODULE_FIRMWARE(SD_INIT2_FIRMWARE);\nMODULE_FIRMWARE(SD_RW_FIRMWARE);\nMODULE_FIRMWARE(MS_INIT_FIRMWARE);\nMODULE_FIRMWARE(MSP_RW_FIRMWARE);\nMODULE_FIRMWARE(MS_RW_FIRMWARE);\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n\t.driver_info = (flags)}\n\nstatic struct usb_device_id ene_ub6250_usb_ids[] = {\n#\tinclude \"unusual_ene_ub6250.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, ene_ub6250_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev ene_ub6250_unusual_dev_list[] = {\n#\tinclude \"unusual_ene_ub6250.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n\n \n#define ENE_BIN_CODE_LEN    0x800\n \n#define REG_CARD_STATUS     0xFF83\n#define REG_HW_TRAP1        0xFF89\n\n \n#define SS_SUCCESS\t\t0x000000\t \n#define SS_NOT_READY\t\t0x023A00\t \n#define SS_MEDIUM_ERR\t\t0x031100\t \n#define SS_HW_ERR\t\t0x040800\t \n#define SS_ILLEGAL_REQUEST\t0x052000\t \n#define SS_UNIT_ATTENTION\t0x062900\t \n\n \n#define SD_INIT1_PATTERN   1\n#define SD_INIT2_PATTERN   2\n#define SD_RW_PATTERN      3\n#define MS_INIT_PATTERN    4\n#define MSP_RW_PATTERN     5\n#define MS_RW_PATTERN      6\n#define SM_INIT_PATTERN    7\n#define SM_RW_PATTERN      8\n\n#define FDIR_WRITE         0\n#define FDIR_READ          1\n\n \n\n \n#define MS_REG_ST1_MB           0x80     \n#define MS_REG_ST1_FB1          0x40     \n#define MS_REG_ST1_DTER         0x20     \n#define MS_REG_ST1_UCDT         0x10     \n#define MS_REG_ST1_EXER         0x08     \n#define MS_REG_ST1_UCEX         0x04     \n#define MS_REG_ST1_FGER         0x02     \n#define MS_REG_ST1_UCFG         0x01     \n#define MS_REG_ST1_DEFAULT\t(MS_REG_ST1_MB | MS_REG_ST1_FB1 | MS_REG_ST1_DTER | MS_REG_ST1_UCDT | MS_REG_ST1_EXER | MS_REG_ST1_UCEX | MS_REG_ST1_FGER | MS_REG_ST1_UCFG)\n\n \n#define MS_REG_OVR_BKST\t\t0x80             \n#define MS_REG_OVR_BKST_OK\tMS_REG_OVR_BKST      \n#define MS_REG_OVR_BKST_NG\t0x00             \n#define MS_REG_OVR_PGST0\t0x40             \n#define MS_REG_OVR_PGST1\t0x20\n#define MS_REG_OVR_PGST_MASK\t(MS_REG_OVR_PGST0 | MS_REG_OVR_PGST1)\n#define MS_REG_OVR_PGST_OK\t(MS_REG_OVR_PGST0 | MS_REG_OVR_PGST1)  \n#define MS_REG_OVR_PGST_NG\tMS_REG_OVR_PGST1                       \n#define MS_REG_OVR_PGST_DATA_ERROR\t0x00         \n#define MS_REG_OVR_UDST\t\t\t0x10         \n#define MS_REG_OVR_UDST_UPDATING\t0x00         \n#define MS_REG_OVR_UDST_NO_UPDATE\tMS_REG_OVR_UDST\n#define MS_REG_OVR_RESERVED\t0x08\n#define MS_REG_OVR_DEFAULT\t(MS_REG_OVR_BKST_OK | MS_REG_OVR_PGST_OK | MS_REG_OVR_UDST_NO_UPDATE | MS_REG_OVR_RESERVED)\n\n \n#define MS_REG_MNG_SCMS0\t0x20     \n#define MS_REG_MNG_SCMS1\t0x10\n#define MS_REG_MNG_SCMS_MASK\t\t(MS_REG_MNG_SCMS0 | MS_REG_MNG_SCMS1)\n#define MS_REG_MNG_SCMS_COPY_OK\t\t(MS_REG_MNG_SCMS0 | MS_REG_MNG_SCMS1)\n#define MS_REG_MNG_SCMS_ONE_COPY\tMS_REG_MNG_SCMS1\n#define MS_REG_MNG_SCMS_NO_COPY\t0x00\n#define MS_REG_MNG_ATFLG\t0x08     \n#define MS_REG_MNG_ATFLG_OTHER\tMS_REG_MNG_ATFLG     \n#define MS_REG_MNG_ATFLG_ATTBL\t0x00\t \n#define MS_REG_MNG_SYSFLG\t0x04\t \n#define MS_REG_MNG_SYSFLG_USER\tMS_REG_MNG_SYSFLG    \n#define MS_REG_MNG_SYSFLG_BOOT\t0x00\t \n#define MS_REG_MNG_RESERVED\t0xc3\n#define MS_REG_MNG_DEFAULT\t(MS_REG_MNG_SCMS_COPY_OK | MS_REG_MNG_ATFLG_OTHER | MS_REG_MNG_SYSFLG_USER | MS_REG_MNG_RESERVED)\n\n\n#define MS_MAX_PAGES_PER_BLOCK\t\t32\n#define MS_MAX_INITIAL_ERROR_BLOCKS \t10\n#define MS_LIB_BITS_PER_BYTE\t\t8\n\n#define MS_SYSINF_FORMAT_FAT\t\t1\n#define MS_SYSINF_USAGE_GENERAL\t\t0\n\n#define MS_SYSINF_MSCLASS_TYPE_1\t1\n#define MS_SYSINF_PAGE_SIZE\t\tMS_BYTES_PER_PAGE  \n\n#define MS_SYSINF_CARDTYPE_RDONLY\t1\n#define MS_SYSINF_CARDTYPE_RDWR\t\t2\n#define MS_SYSINF_CARDTYPE_HYBRID\t3\n#define MS_SYSINF_SECURITY\t\t0x01\n#define MS_SYSINF_SECURITY_NO_SUPPORT\tMS_SYSINF_SECURITY\n#define MS_SYSINF_SECURITY_SUPPORT\t0\n\n#define MS_SYSINF_RESERVED1\t\t1\n#define MS_SYSINF_RESERVED2\t\t1\n\n#define MS_SYSENT_TYPE_INVALID_BLOCK\t0x01\n#define MS_SYSENT_TYPE_CIS_IDI\t\t0x0a     \n\n#define SIZE_OF_KIRO\t\t1024\n#define BYTE_MASK\t\t0xff\n\n \n#define MS_STATUS_WRITE_PROTECT\t0x0106\n#define MS_STATUS_SUCCESS\t0x0000\n#define MS_ERROR_FLASH_READ\t0x8003\n#define MS_ERROR_FLASH_ERASE\t0x8005\n#define MS_LB_ERROR\t\t0xfff0\n#define MS_LB_BOOT_BLOCK\t0xfff1\n#define MS_LB_INITIAL_ERROR\t0xfff2\n#define MS_STATUS_SUCCESS_WITH_ECC 0xfff3\n#define MS_LB_ACQUIRED_ERROR\t0xfff4\n#define MS_LB_NOT_USED_ERASED\t0xfff5\n#define MS_NOCARD_ERROR\t\t0xfff8\n#define MS_NO_MEMORY_ERROR\t0xfff9\n#define MS_STATUS_INT_ERROR\t0xfffa\n#define MS_STATUS_ERROR\t\t0xfffe\n#define MS_LB_NOT_USED\t\t0xffff\n\n#define MS_REG_MNG_SYSFLG\t0x04     \n#define MS_REG_MNG_SYSFLG_USER\tMS_REG_MNG_SYSFLG    \n\n#define MS_BOOT_BLOCK_ID                        0x0001\n#define MS_BOOT_BLOCK_FORMAT_VERSION            0x0100\n#define MS_BOOT_BLOCK_DATA_ENTRIES              2\n\n#define MS_NUMBER_OF_SYSTEM_ENTRY       \t4\n#define MS_NUMBER_OF_BOOT_BLOCK\t\t\t2\n#define MS_BYTES_PER_PAGE\t\t\t512\n#define MS_LOGICAL_BLOCKS_PER_SEGMENT\t\t496\n#define MS_LOGICAL_BLOCKS_IN_1ST_SEGMENT        494\n\n#define MS_PHYSICAL_BLOCKS_PER_SEGMENT\t\t0x200  \n#define MS_PHYSICAL_BLOCKS_PER_SEGMENT_MASK     0x1ff\n\n \n#define MS_REG_OVR_BKST\t\t0x80\t\t \n#define MS_REG_OVR_BKST_OK\tMS_REG_OVR_BKST\t \n#define MS_REG_OVR_BKST_NG\t0x00             \n\n \n#define MS_REG_ST1_DTER\t\t0x20\t \n#define MS_REG_ST1_EXER\t\t0x08\t \n#define MS_REG_ST1_FGER\t\t0x02\t \n\n \n \n#define MS_REG_ST0_WP\t\t0x01\t \n#define MS_REG_ST0_WP_ON\tMS_REG_ST0_WP\n\n#define MS_LIB_CTRL_RDONLY      0\n#define MS_LIB_CTRL_WRPROTECT   1\n\n \n#define ms_libconv_to_logical(pdx, PhyBlock) (((PhyBlock) >= (pdx)->MS_Lib.NumberOfPhyBlock) ? MS_STATUS_ERROR : (pdx)->MS_Lib.Phy2LogMap[PhyBlock])\n#define ms_libconv_to_physical(pdx, LogBlock) (((LogBlock) >= (pdx)->MS_Lib.NumberOfLogBlock) ? MS_STATUS_ERROR : (pdx)->MS_Lib.Log2PhyMap[LogBlock])\n\n#define ms_lib_ctrl_set(pdx, Flag)\t((pdx)->MS_Lib.flags |= (1 << (Flag)))\n#define ms_lib_ctrl_reset(pdx, Flag)\t((pdx)->MS_Lib.flags &= ~(1 << (Flag)))\n#define ms_lib_ctrl_check(pdx, Flag)\t((pdx)->MS_Lib.flags & (1 << (Flag)))\n\n#define ms_lib_iswritable(pdx) ((ms_lib_ctrl_check((pdx), MS_LIB_CTRL_RDONLY) == 0) && (ms_lib_ctrl_check(pdx, MS_LIB_CTRL_WRPROTECT) == 0))\n#define ms_lib_clear_pagemap(pdx) memset((pdx)->MS_Lib.pagemap, 0, sizeof((pdx)->MS_Lib.pagemap))\n#define memstick_logaddr(logadr1, logadr0) ((((u16)(logadr1)) << 8) | (logadr0))\n\n\n \n#define SD_Insert\tBIT(0)\n#define SD_Ready\tBIT(1)\n#define SD_MediaChange\tBIT(2)\n#define SD_IsMMC\tBIT(3)\n#define SD_HiCapacity\tBIT(4)\n#define SD_HiSpeed\tBIT(5)\n#define SD_WtP\t\tBIT(6)\n\t\t\t \n\n \n#define MS_Insert\tBIT(0)\n#define MS_Ready\tBIT(1)\n#define MS_MediaChange\tBIT(2)\n#define MS_IsMSPro\tBIT(3)\n#define MS_IsMSPHG\tBIT(4)\n\t\t\t \n#define MS_WtP\t\tBIT(6)\n\t\t\t \n\n \n#define SM_Insert\tBIT(0)\n#define SM_Ready\tBIT(1)\n#define SM_MediaChange\tBIT(2)\n\t\t\t \n#define SM_WtP\t\tBIT(6)\n#define SM_IsMS\t\tBIT(7)\n\nstruct ms_bootblock_cis {\n\tu8 bCistplDEVICE[6];     \n\tu8 bCistplDEVICE0C[6];   \n\tu8 bCistplJEDECC[4];     \n\tu8 bCistplMANFID[6];     \n\tu8 bCistplVER1[32];      \n\tu8 bCistplFUNCID[4];     \n\tu8 bCistplFUNCE0[4];     \n\tu8 bCistplFUNCE1[5];     \n\tu8 bCistplCONF[7];       \n\tu8 bCistplCFTBLENT0[10]; \n\tu8 bCistplCFTBLENT1[8];  \n\tu8 bCistplCFTBLENT2[12]; \n\tu8 bCistplCFTBLENT3[8];  \n\tu8 bCistplCFTBLENT4[17]; \n\tu8 bCistplCFTBLENT5[8];  \n\tu8 bCistplCFTBLENT6[17]; \n\tu8 bCistplCFTBLENT7[8];  \n\tu8 bCistplNOLINK[3];     \n} ;\n\nstruct ms_bootblock_idi {\n#define MS_IDI_GENERAL_CONF 0x848A\n\tu16 wIDIgeneralConfiguration;\t \n\tu16 wIDInumberOfCylinder;\t \n\tu16 wIDIreserved0;\t\t \n\tu16 wIDInumberOfHead;\t\t \n\tu16 wIDIbytesPerTrack;\t\t \n\tu16 wIDIbytesPerSector;\t\t \n\tu16 wIDIsectorsPerTrack;\t \n\tu16 wIDItotalSectors[2];\t \n\tu16 wIDIreserved1[11];\t\t \n\tu16 wIDIbufferType;\t\t \n\tu16 wIDIbufferSize;\t\t \n\tu16 wIDIlongCmdECC;\t\t \n\tu16 wIDIfirmVersion[4];\t\t \n\tu16 wIDImodelName[20];\t\t \n\tu16 wIDIreserved2;\t\t \n\tu16 wIDIlongWordSupported;\t \n\tu16 wIDIdmaSupported;\t\t \n\tu16 wIDIreserved3;\t\t \n\tu16 wIDIpioTiming;\t\t \n\tu16 wIDIdmaTiming;\t\t \n\tu16 wIDItransferParameter;\t \n\tu16 wIDIformattedCylinder;\t \n\tu16 wIDIformattedHead;\t\t \n\tu16 wIDIformattedSectorsPerTrack; \n\tu16 wIDIformattedTotalSectors[2]; \n\tu16 wIDImultiSector;\t\t \n\tu16 wIDIlbaSectors[2];\t\t \n\tu16 wIDIsingleWordDMA;\t\t \n\tu16 wIDImultiWordDMA;\t\t \n\tu16 wIDIreserved4[192];\t\t \n};\n\nstruct ms_bootblock_sysent_rec {\n\tu32 dwStart;\n\tu32 dwSize;\n\tu8 bType;\n\tu8 bReserved[3];\n};\n\nstruct ms_bootblock_sysent {\n\tstruct ms_bootblock_sysent_rec entry[MS_NUMBER_OF_SYSTEM_ENTRY];\n};\n\nstruct ms_bootblock_sysinf {\n\tu8 bMsClass;\t\t\t \n\tu8 bCardType;\t\t\t \n\tu16 wBlockSize;\t\t\t \n\tu16 wBlockNumber;\t\t \n\tu16 wTotalBlockNumber;\t\t \n\tu16 wPageSize;\t\t\t \n\tu8 bExtraSize;\t\t\t \n\tu8 bSecuritySupport;\n\tu8 bAssemblyDate[8];\n\tu8 bFactoryArea[4];\n\tu8 bAssemblyMakerCode;\n\tu8 bAssemblyMachineCode[3];\n\tu16 wMemoryMakerCode;\n\tu16 wMemoryDeviceCode;\n\tu16 wMemorySize;\n\tu8 bReserved1;\n\tu8 bReserved2;\n\tu8 bVCC;\n\tu8 bVPP;\n\tu16 wControllerChipNumber;\n\tu16 wControllerFunction;\t \n\tu8 bReserved3[9];\t\t \n\tu8 bParallelSupport;\t\t \n\tu16 wFormatValue;\t\t \n\tu8 bFormatType;\n\tu8 bUsage;\n\tu8 bDeviceType;\n\tu8 bReserved4[22];\n\tu8 bFUValue3;\n\tu8 bFUValue4;\n\tu8 bReserved5[15];\n};\n\nstruct ms_bootblock_header {\n\tu16 wBlockID;\n\tu16 wFormatVersion;\n\tu8 bReserved1[184];\n\tu8 bNumberOfDataEntry;\n\tu8 bReserved2[179];\n};\n\nstruct ms_bootblock_page0 {\n\tstruct ms_bootblock_header header;\n\tstruct ms_bootblock_sysent sysent;\n\tstruct ms_bootblock_sysinf sysinf;\n};\n\nstruct ms_bootblock_cis_idi {\n\tunion {\n\t\tstruct ms_bootblock_cis cis;\n\t\tu8 dmy[256];\n\t} cis;\n\n\tunion {\n\t\tstruct ms_bootblock_idi idi;\n\t\tu8 dmy[256];\n\t} idi;\n\n};\n\n \nstruct ms_lib_type_extdat {\n\tu8 reserved;\n\tu8 intr;\n\tu8 status0;\n\tu8 status1;\n\tu8 ovrflg;\n\tu8 mngflg;\n\tu16 logadr;\n};\n\nstruct ms_lib_ctrl {\n\tu32 flags;\n\tu32 BytesPerSector;\n\tu32 NumberOfCylinder;\n\tu32 SectorsPerCylinder;\n\tu16 cardType;\t\t\t \n\tu16 blockSize;\n\tu16 PagesPerBlock;\n\tu16 NumberOfPhyBlock;\n\tu16 NumberOfLogBlock;\n\tu16 NumberOfSegment;\n\tu16 *Phy2LogMap;\t\t \n\tu16 *Log2PhyMap;\t\t \n\tu16 wrtblk;\n\tunsigned char *pagemap[(MS_MAX_PAGES_PER_BLOCK + (MS_LIB_BITS_PER_BYTE-1)) / MS_LIB_BITS_PER_BYTE];\n\tunsigned char *blkpag;\n\tstruct ms_lib_type_extdat *blkext;\n\tunsigned char copybuf[512];\n};\n\n\n \n \n#define SD_BLOCK_LEN  9\n\nstruct ene_ub6250_info {\n\n\t \n\tu8\t\t*bbuf;\n\n\t \n\tu8\t\tSD_Status;\n\tu8\t\tMS_Status;\n\tu8\t\tSM_Status;\n\n\t \n\t \n\tu16\t\tSD_Block_Mult;\n\tu8\t\tSD_READ_BL_LEN;\n\tu16\t\tSD_C_SIZE;\n\tu8\t\tSD_C_SIZE_MULT;\n\n\t \n\tu8\t\tSD_SPEC_VER;\n\tu8\t\tSD_CSD_VER;\n\tu8\t\tSD20_HIGH_CAPACITY;\n\tu32\t\tHC_C_SIZE;\n\tu8\t\tMMC_SPEC_VER;\n\tu8\t\tMMC_BusWidth;\n\tu8\t\tMMC_HIGH_CAPACITY;\n\n\t \n\tbool\t\tMS_SWWP;\n\tu32\t\tMSP_TotalBlock;\n\tstruct ms_lib_ctrl MS_Lib;\n\tbool\t\tMS_IsRWPage;\n\tu16\t\tMS_Model;\n\n\t \n\tu8\t\tSM_DeviceID;\n\tu8\t\tSM_CardID;\n\n\tunsigned char\t*testbuf;\n\tu8\t\tBIN_FLAG;\n\tu32\t\tbl_num;\n\tint\t\tSrbStatus;\n\n\t \n\tbool\t\tPower_IsResum;\n};\n\nstatic int ene_sd_init(struct us_data *us);\nstatic int ene_ms_init(struct us_data *us);\nstatic int ene_load_bincode(struct us_data *us, unsigned char flag);\n\nstatic void ene_ub6250_info_destructor(void *extra)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) extra;\n\n\tif (!extra)\n\t\treturn;\n\tkfree(info->bbuf);\n}\n\nstatic int ene_send_scsi_cmd(struct us_data *us, u8 fDir, void *buf, int use_sg)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;\n\n\tint result;\n\tunsigned int residue;\n\tunsigned int cswlen = 0, partial = 0;\n\tunsigned int transfer_length = bcb->DataTransferLength;\n\n\t \n\t \n\tresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\t\t\t    bcb, US_BULK_CB_WRAP_LEN, NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"send cmd to out endpoint fail ---\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (buf) {\n\t\tunsigned int pipe = fDir;\n\n\t\tif (fDir  == FDIR_READ)\n\t\t\tpipe = us->recv_bulk_pipe;\n\t\telse\n\t\t\tpipe = us->send_bulk_pipe;\n\n\t\t \n\t\tif (use_sg) {\n\t\t\tresult = usb_stor_bulk_srb(us, pipe, us->srb);\n\t\t} else {\n\t\t\tresult = usb_stor_bulk_transfer_sg(us, pipe, buf,\n\t\t\t\t\t\ttransfer_length, 0, &partial);\n\t\t}\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"data transfer fail ---\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\t}\n\n\t \n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe, bcs,\n\t\t\t\t\t    US_BULK_CS_WRAP_LEN, &cswlen);\n\n\tif (result == USB_STOR_XFER_SHORT && cswlen == 0) {\n\t\tusb_stor_dbg(us, \"Received 0-length CSW; retrying...\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\t\t    bcs, US_BULK_CS_WRAP_LEN, &cswlen);\n\t}\n\n\tif (result == USB_STOR_XFER_STALLED) {\n\t\t \n\t\tusb_stor_dbg(us, \"Attempting to get CSW (2nd try)...\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\t\t\tbcs, US_BULK_CS_WRAP_LEN, NULL);\n\t}\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tresidue = le32_to_cpu(bcs->Residue);\n\n\t \n\tif (residue && !(us->fflags & US_FL_IGNORE_RESIDUE)) {\n\t\tresidue = min(residue, transfer_length);\n\t\tif (us->srb != NULL)\n\t\t\tscsi_set_resid(us->srb, max(scsi_get_resid(us->srb),\n\t\t\t\t\t\t\t\tresidue));\n\t}\n\n\tif (bcs->Status != US_BULK_STAT_OK)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int do_scsi_request_sense(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tunsigned char buf[18];\n\n\tmemset(buf, 0, 18);\n\tbuf[0] = 0x70;\t\t\t\t \n\tbuf[2] = info->SrbStatus >> 16;\t\t \n\tbuf[7] = 10;\t\t\t\t \n\tbuf[12] = info->SrbStatus >> 8;\t\t \n\tbuf[13] = info->SrbStatus;\t\t \n\n\tusb_stor_set_xfer_buf(buf, sizeof(buf), srb);\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int do_scsi_inquiry(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tunsigned char data_ptr[36] = {\n\t\t0x00, 0x00, 0x02, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x55,\n\t\t0x53, 0x42, 0x32, 0x2E, 0x30, 0x20, 0x20, 0x43, 0x61,\n\t\t0x72, 0x64, 0x52, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20,\n\t\t0x20, 0x20, 0x20, 0x20, 0x20, 0x30, 0x31, 0x30, 0x30 };\n\n\tusb_stor_set_xfer_buf(data_ptr, 36, srb);\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int sd_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif ((info->SD_Status & SD_Insert) && (info->SD_Status & SD_Ready))\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\telse {\n\t\tene_sd_init(us);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int sd_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tunsigned char mediaNoWP[12] = {\n\t\t0x0b, 0x00, 0x00, 0x08, 0x00, 0x00,\n\t\t0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\n\tunsigned char mediaWP[12]   = {\n\t\t0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,\n\t\t0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\n\n\tif (info->SD_Status & SD_WtP)\n\t\tusb_stor_set_xfer_buf(mediaWP, 12, srb);\n\telse\n\t\tusb_stor_set_xfer_buf(mediaNoWP, 12, srb);\n\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int sd_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tu32\tbl_num;\n\tu32\tbl_len;\n\tunsigned int offset = 0;\n\tunsigned char    buf[8];\n\tstruct scatterlist *sg = NULL;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tusb_stor_dbg(us, \"sd_scsi_read_capacity\\n\");\n\tif (info->SD_Status & SD_HiCapacity) {\n\t\tbl_len = 0x200;\n\t\tif (info->SD_Status & SD_IsMMC)\n\t\t\tbl_num = info->HC_C_SIZE-1;\n\t\telse\n\t\t\tbl_num = (info->HC_C_SIZE + 1) * 1024 - 1;\n\t} else {\n\t\tbl_len = 1 << (info->SD_READ_BL_LEN);\n\t\tbl_num = info->SD_Block_Mult * (info->SD_C_SIZE + 1)\n\t\t\t\t* (1 << (info->SD_C_SIZE_MULT + 2)) - 1;\n\t}\n\tinfo->bl_num = bl_num;\n\tusb_stor_dbg(us, \"bl_len = %x\\n\", bl_len);\n\tusb_stor_dbg(us, \"bl_num = %x\\n\", bl_num);\n\n\t \n\tbuf[0] = (bl_num >> 24) & 0xff;\n\tbuf[1] = (bl_num >> 16) & 0xff;\n\tbuf[2] = (bl_num >> 8) & 0xff;\n\tbuf[3] = (bl_num >> 0) & 0xff;\n\tbuf[4] = (bl_len >> 24) & 0xff;\n\tbuf[5] = (bl_len >> 16) & 0xff;\n\tbuf[6] = (bl_len >> 8) & 0xff;\n\tbuf[7] = (bl_len >> 0) & 0xff;\n\n\tusb_stor_access_xfer_buf(buf, 8, srb, &sg, &offset, TO_XFER_BUF);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int sd_scsi_read(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint result;\n\tunsigned char *cdb = srb->cmnd;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\n\t\t ((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\n\tu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\n\tu32 bnByte = bn * 0x200;\n\tu32 blenByte = blen * 0x200;\n\n\tif (bn > info->bl_num)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tresult = ene_load_bincode(us, SD_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Load SD RW pattern Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (info->SD_Status & SD_HiCapacity)\n\t\tbnByte = bn;\n\n\t \n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = blenByte;\n\tbcb->Flags  = US_BULK_FLAG_IN;\n\tbcb->CDB[0] = 0xF1;\n\tbcb->CDB[5] = (unsigned char)(bnByte);\n\tbcb->CDB[4] = (unsigned char)(bnByte>>8);\n\tbcb->CDB[3] = (unsigned char)(bnByte>>16);\n\tbcb->CDB[2] = (unsigned char)(bnByte>>24);\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, scsi_sglist(srb), 1);\n\treturn result;\n}\n\nstatic int sd_scsi_write(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint result;\n\tunsigned char *cdb = srb->cmnd;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\n\t\t ((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\n\tu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\n\tu32 bnByte = bn * 0x200;\n\tu32 blenByte = blen * 0x200;\n\n\tif (bn > info->bl_num)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tresult = ene_load_bincode(us, SD_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Load SD RW pattern Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (info->SD_Status & SD_HiCapacity)\n\t\tbnByte = bn;\n\n\t \n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = blenByte;\n\tbcb->Flags  = 0x00;\n\tbcb->CDB[0] = 0xF0;\n\tbcb->CDB[5] = (unsigned char)(bnByte);\n\tbcb->CDB[4] = (unsigned char)(bnByte>>8);\n\tbcb->CDB[3] = (unsigned char)(bnByte>>16);\n\tbcb->CDB[2] = (unsigned char)(bnByte>>24);\n\n\tresult = ene_send_scsi_cmd(us, FDIR_WRITE, scsi_sglist(srb), 1);\n\treturn result;\n}\n\n \n\nstatic int ms_lib_set_logicalpair(struct us_data *us, u16 logblk, u16 phyblk)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif ((logblk >= info->MS_Lib.NumberOfLogBlock) || (phyblk >= info->MS_Lib.NumberOfPhyBlock))\n\t\treturn (u32)-1;\n\n\tinfo->MS_Lib.Phy2LogMap[phyblk] = logblk;\n\tinfo->MS_Lib.Log2PhyMap[logblk] = phyblk;\n\n\treturn 0;\n}\n\nstatic int ms_lib_set_logicalblockmark(struct us_data *us, u16 phyblk, u16 mark)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\n\t\treturn (u32)-1;\n\n\tinfo->MS_Lib.Phy2LogMap[phyblk] = mark;\n\n\treturn 0;\n}\n\nstatic int ms_lib_set_initialerrorblock(struct us_data *us, u16 phyblk)\n{\n\treturn ms_lib_set_logicalblockmark(us, phyblk, MS_LB_INITIAL_ERROR);\n}\n\nstatic int ms_lib_set_bootblockmark(struct us_data *us, u16 phyblk)\n{\n\treturn ms_lib_set_logicalblockmark(us, phyblk, MS_LB_BOOT_BLOCK);\n}\n\nstatic int ms_lib_free_logicalmap(struct us_data *us)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tkfree(info->MS_Lib.Phy2LogMap);\n\tinfo->MS_Lib.Phy2LogMap = NULL;\n\n\tkfree(info->MS_Lib.Log2PhyMap);\n\tinfo->MS_Lib.Log2PhyMap = NULL;\n\n\treturn 0;\n}\n\nstatic int ms_lib_alloc_logicalmap(struct us_data *us)\n{\n\tu32  i;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tinfo->MS_Lib.Phy2LogMap = kmalloc_array(info->MS_Lib.NumberOfPhyBlock,\n\t\t\t\t\t\tsizeof(u16),\n\t\t\t\t\t\tGFP_KERNEL);\n\tinfo->MS_Lib.Log2PhyMap = kmalloc_array(info->MS_Lib.NumberOfLogBlock,\n\t\t\t\t\t\tsizeof(u16),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\tif ((info->MS_Lib.Phy2LogMap == NULL) || (info->MS_Lib.Log2PhyMap == NULL)) {\n\t\tms_lib_free_logicalmap(us);\n\t\treturn (u32)-1;\n\t}\n\n\tfor (i = 0; i < info->MS_Lib.NumberOfPhyBlock; i++)\n\t\tinfo->MS_Lib.Phy2LogMap[i] = MS_LB_NOT_USED;\n\n\tfor (i = 0; i < info->MS_Lib.NumberOfLogBlock; i++)\n\t\tinfo->MS_Lib.Log2PhyMap[i] = MS_LB_NOT_USED;\n\n\treturn 0;\n}\n\nstatic void ms_lib_clear_writebuf(struct us_data *us)\n{\n\tint i;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tinfo->MS_Lib.wrtblk = (u16)-1;\n\tms_lib_clear_pagemap(info);\n\n\tif (info->MS_Lib.blkpag)\n\t\tmemset(info->MS_Lib.blkpag, 0xff, info->MS_Lib.PagesPerBlock * info->MS_Lib.BytesPerSector);\n\n\tif (info->MS_Lib.blkext) {\n\t\tfor (i = 0; i < info->MS_Lib.PagesPerBlock; i++) {\n\t\t\tinfo->MS_Lib.blkext[i].status1 = MS_REG_ST1_DEFAULT;\n\t\t\tinfo->MS_Lib.blkext[i].ovrflg = MS_REG_OVR_DEFAULT;\n\t\t\tinfo->MS_Lib.blkext[i].mngflg = MS_REG_MNG_DEFAULT;\n\t\t\tinfo->MS_Lib.blkext[i].logadr = MS_LB_NOT_USED;\n\t\t}\n\t}\n}\n\nstatic int ms_count_freeblock(struct us_data *us, u16 PhyBlock)\n{\n\tu32 Ende, Count;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tEnde = PhyBlock + MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\tfor (Count = 0; PhyBlock < Ende; PhyBlock++) {\n\t\tswitch (info->MS_Lib.Phy2LogMap[PhyBlock]) {\n\t\tcase MS_LB_NOT_USED:\n\t\tcase MS_LB_NOT_USED_ERASED:\n\t\t\tCount++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn Count;\n}\n\nstatic int ms_read_readpage(struct us_data *us, u32 PhyBlockAddr,\n\t\tu8 PageNum, u32 *PageBuf, struct ms_lib_type_extdat *ExtraDat)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tu8 *bbuf = info->bbuf;\n\tint result;\n\tu32 bn = PhyBlockAddr * 0x20 + PageNum;\n\n\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x200;\n\tbcb->Flags      = US_BULK_FLAG_IN;\n\tbcb->CDB[0]     = 0xF1;\n\n\tbcb->CDB[1]     = 0x02;  \n\n\tbcb->CDB[5]     = (unsigned char)(bn);\n\tbcb->CDB[4]     = (unsigned char)(bn>>8);\n\tbcb->CDB[3]     = (unsigned char)(bn>>16);\n\tbcb->CDB[2]     = (unsigned char)(bn>>24);\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, PageBuf, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\n\t \n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x4;\n\tbcb->Flags      = US_BULK_FLAG_IN;\n\tbcb->CDB[0]     = 0xF1;\n\tbcb->CDB[1]     = 0x03;\n\n\tbcb->CDB[5]     = (unsigned char)(PageNum);\n\tbcb->CDB[4]     = (unsigned char)(PhyBlockAddr);\n\tbcb->CDB[3]     = (unsigned char)(PhyBlockAddr>>8);\n\tbcb->CDB[2]     = (unsigned char)(PhyBlockAddr>>16);\n\tbcb->CDB[6]     = 0x01;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tExtraDat->reserved = 0;\n\tExtraDat->intr     = 0x80;   \n\tExtraDat->status0  = 0x10;   \n\n\tExtraDat->status1  = 0x00;   \n\tExtraDat->ovrflg   = bbuf[0];\n\tExtraDat->mngflg   = bbuf[1];\n\tExtraDat->logadr   = memstick_logaddr(bbuf[2], bbuf[3]);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_lib_process_bootblock(struct us_data *us, u16 PhyBlock, u8 *PageData)\n{\n\tstruct ms_bootblock_sysent *SysEntry;\n\tstruct ms_bootblock_sysinf *SysInfo;\n\tu32 i, result;\n\tu8 PageNumber;\n\tu8 *PageBuffer;\n\tstruct ms_lib_type_extdat ExtraData;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tPageBuffer = kzalloc(MS_BYTES_PER_PAGE * 2, GFP_KERNEL);\n\tif (PageBuffer == NULL)\n\t\treturn (u32)-1;\n\n\tresult = (u32)-1;\n\n\tSysInfo = &(((struct ms_bootblock_page0 *)PageData)->sysinf);\n\n\tif ((SysInfo->bMsClass != MS_SYSINF_MSCLASS_TYPE_1) ||\n\t\t(be16_to_cpu(SysInfo->wPageSize) != MS_SYSINF_PAGE_SIZE) ||\n\t\t((SysInfo->bSecuritySupport & MS_SYSINF_SECURITY) == MS_SYSINF_SECURITY_SUPPORT) ||\n\t\t(SysInfo->bReserved1 != MS_SYSINF_RESERVED1) ||\n\t\t(SysInfo->bReserved2 != MS_SYSINF_RESERVED2) ||\n\t\t(SysInfo->bFormatType != MS_SYSINF_FORMAT_FAT) ||\n\t\t(SysInfo->bUsage != MS_SYSINF_USAGE_GENERAL))\n\t\tgoto exit;\n\t\t \n\tswitch (info->MS_Lib.cardType = SysInfo->bCardType) {\n\tcase MS_SYSINF_CARDTYPE_RDONLY:\n\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_RDWR:\n\t\tms_lib_ctrl_reset(info, MS_LIB_CTRL_RDONLY);\n\t\tbreak;\n\tcase MS_SYSINF_CARDTYPE_HYBRID:\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tinfo->MS_Lib.blockSize = be16_to_cpu(SysInfo->wBlockSize);\n\tinfo->MS_Lib.NumberOfPhyBlock = be16_to_cpu(SysInfo->wBlockNumber);\n\tinfo->MS_Lib.NumberOfLogBlock = be16_to_cpu(SysInfo->wTotalBlockNumber)-2;\n\tinfo->MS_Lib.PagesPerBlock = info->MS_Lib.blockSize * SIZE_OF_KIRO / MS_BYTES_PER_PAGE;\n\tinfo->MS_Lib.NumberOfSegment = info->MS_Lib.NumberOfPhyBlock / MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\tinfo->MS_Model = be16_to_cpu(SysInfo->wMemorySize);\n\n\t \n\tif (ms_lib_alloc_logicalmap(us))\n\t\tgoto exit;\n\n\t \n\tms_lib_set_bootblockmark(us, PhyBlock);\n\n\tSysEntry = &(((struct ms_bootblock_page0 *)PageData)->sysent);\n\n\tfor (i = 0; i < MS_NUMBER_OF_SYSTEM_ENTRY; i++) {\n\t\tu32  EntryOffset, EntrySize;\n\n\t\tEntryOffset = be32_to_cpu(SysEntry->entry[i].dwStart);\n\n\t\tif (EntryOffset == 0xffffff)\n\t\t\tcontinue;\n\t\tEntrySize = be32_to_cpu(SysEntry->entry[i].dwSize);\n\n\t\tif (EntrySize == 0)\n\t\t\tcontinue;\n\n\t\tif (EntryOffset + MS_BYTES_PER_PAGE + EntrySize > info->MS_Lib.blockSize * (u32)SIZE_OF_KIRO)\n\t\t\tcontinue;\n\n\t\tif (i == 0) {\n\t\t\tu8 PrevPageNumber = 0;\n\t\t\tu16 phyblk;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_INVALID_BLOCK)\n\t\t\t\tgoto exit;\n\n\t\t\twhile (EntrySize > 0) {\n\n\t\t\t\tPageNumber = (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1);\n\t\t\t\tif (PageNumber != PrevPageNumber) {\n\t\t\t\t\tswitch (ms_read_readpage(us, PhyBlock, PageNumber, (u32 *)PageBuffer, &ExtraData)) {\n\t\t\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\n\t\t\t\t\tPrevPageNumber = PageNumber;\n\t\t\t\t}\n\n\t\t\t\tphyblk = be16_to_cpu(*(u16 *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)));\n\t\t\t\tif (phyblk < 0x0fff)\n\t\t\t\t\tms_lib_set_initialerrorblock(us, phyblk);\n\n\t\t\t\tEntryOffset += 2;\n\t\t\t\tEntrySize -= 2;\n\t\t\t}\n\t\t} else if (i == 1) {   \n\t\t\tstruct ms_bootblock_idi *idi;\n\n\t\t\tif (SysEntry->entry[i].bType != MS_SYSENT_TYPE_CIS_IDI)\n\t\t\t\tgoto exit;\n\n\t\t\tswitch (ms_read_readpage(us, PhyBlock, (u8)(EntryOffset / MS_BYTES_PER_PAGE + 1), (u32 *)PageBuffer, &ExtraData)) {\n\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\tbreak;\n\t\t\tcase MS_STATUS_WRITE_PROTECT:\n\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\tcase MS_STATUS_ERROR:\n\t\t\tdefault:\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tidi = &((struct ms_bootblock_cis_idi *)(PageBuffer + (EntryOffset % MS_BYTES_PER_PAGE)))->idi.idi;\n\t\t\tif (le16_to_cpu(idi->wIDIgeneralConfiguration) != MS_IDI_GENERAL_CONF)\n\t\t\t\tgoto exit;\n\n\t\t\tinfo->MS_Lib.BytesPerSector = le16_to_cpu(idi->wIDIbytesPerSector);\n\t\t\tif (info->MS_Lib.BytesPerSector != MS_BYTES_PER_PAGE)\n\t\t\t\tgoto exit;\n\t\t}\n\t}  \n\n\tresult = 0;\n\nexit:\n\tif (result)\n\t\tms_lib_free_logicalmap(us);\n\n\tkfree(PageBuffer);\n\n\tresult = 0;\n\treturn result;\n}\n\nstatic void ms_lib_free_writebuf(struct us_data *us)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tinfo->MS_Lib.wrtblk = (u16)-1;  \n\n\t \n\n\tms_lib_clear_pagemap(info);  \n\n\tif (info->MS_Lib.blkpag) {\n\t\tkfree(info->MS_Lib.blkpag);   \n\t\tinfo->MS_Lib.blkpag = NULL;\n\t}\n\n\tif (info->MS_Lib.blkext) {\n\t\tkfree(info->MS_Lib.blkext);   \n\t\tinfo->MS_Lib.blkext = NULL;\n\t}\n}\n\n\nstatic void ms_lib_free_allocatedarea(struct us_data *us)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tms_lib_free_writebuf(us);  \n\tms_lib_free_logicalmap(us);  \n\n\t \n\tinfo->MS_Lib.flags = 0;\n\tinfo->MS_Lib.BytesPerSector = 0;\n\tinfo->MS_Lib.SectorsPerCylinder = 0;\n\n\tinfo->MS_Lib.cardType = 0;\n\tinfo->MS_Lib.blockSize = 0;\n\tinfo->MS_Lib.PagesPerBlock = 0;\n\n\tinfo->MS_Lib.NumberOfPhyBlock = 0;\n\tinfo->MS_Lib.NumberOfLogBlock = 0;\n}\n\n\nstatic int ms_lib_alloc_writebuf(struct us_data *us)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tinfo->MS_Lib.wrtblk = (u16)-1;\n\n\tinfo->MS_Lib.blkpag = kmalloc_array(info->MS_Lib.PagesPerBlock,\n\t\t\t\t\t    info->MS_Lib.BytesPerSector,\n\t\t\t\t\t    GFP_KERNEL);\n\tinfo->MS_Lib.blkext = kmalloc_array(info->MS_Lib.PagesPerBlock,\n\t\t\t\t\t    sizeof(struct ms_lib_type_extdat),\n\t\t\t\t\t    GFP_KERNEL);\n\n\tif ((info->MS_Lib.blkpag == NULL) || (info->MS_Lib.blkext == NULL)) {\n\t\tms_lib_free_writebuf(us);\n\t\treturn (u32)-1;\n\t}\n\n\tms_lib_clear_writebuf(us);\n\n\treturn 0;\n}\n\nstatic int ms_lib_force_setlogical_pair(struct us_data *us, u16 logblk, u16 phyblk)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (logblk == MS_LB_NOT_USED)\n\t\treturn 0;\n\n\tif ((logblk >= info->MS_Lib.NumberOfLogBlock) ||\n\t\t(phyblk >= info->MS_Lib.NumberOfPhyBlock))\n\t\treturn (u32)-1;\n\n\tinfo->MS_Lib.Phy2LogMap[phyblk] = logblk;\n\tinfo->MS_Lib.Log2PhyMap[logblk] = phyblk;\n\n\treturn 0;\n}\n\nstatic int ms_read_copyblock(struct us_data *us, u16 oldphy, u16 newphy,\n\t\t\tu16 PhyBlockAddr, u8 PageNum, unsigned char *buf, u16 len)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint result;\n\n\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x200*len;\n\tbcb->Flags = 0x00;\n\tbcb->CDB[0] = 0xF0;\n\tbcb->CDB[1] = 0x08;\n\tbcb->CDB[4] = (unsigned char)(oldphy);\n\tbcb->CDB[3] = (unsigned char)(oldphy>>8);\n\tbcb->CDB[2] = 0;  \n\tbcb->CDB[7] = (unsigned char)(newphy);\n\tbcb->CDB[6] = (unsigned char)(newphy>>8);\n\tbcb->CDB[5] = 0;  \n\tbcb->CDB[9] = (unsigned char)(PhyBlockAddr);\n\tbcb->CDB[8] = (unsigned char)(PhyBlockAddr>>8);\n\tbcb->CDB[10] = PageNum;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_read_eraseblock(struct us_data *us, u32 PhyBlockAddr)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint result;\n\tu32 bn = PhyBlockAddr;\n\n\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x200;\n\tbcb->Flags = US_BULK_FLAG_IN;\n\tbcb->CDB[0] = 0xF2;\n\tbcb->CDB[1] = 0x06;\n\tbcb->CDB[4] = (unsigned char)(bn);\n\tbcb->CDB[3] = (unsigned char)(bn>>8);\n\tbcb->CDB[2] = (unsigned char)(bn>>16);\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_lib_check_disableblock(struct us_data *us, u16 PhyBlock)\n{\n\tunsigned char *PageBuf = NULL;\n\tu16 result = MS_STATUS_SUCCESS;\n\tu16 blk, index = 0;\n\tstruct ms_lib_type_extdat extdat;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tPageBuf = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n\tif (PageBuf == NULL) {\n\t\tresult = MS_NO_MEMORY_ERROR;\n\t\tgoto exit;\n\t}\n\n\tms_read_readpage(us, PhyBlock, 1, (u32 *)PageBuf, &extdat);\n\tdo {\n\t\tblk = be16_to_cpu(PageBuf[index]);\n\t\tif (blk == MS_LB_NOT_USED)\n\t\t\tbreak;\n\t\tif (blk == info->MS_Lib.Log2PhyMap[0]) {\n\t\t\tresult = MS_ERROR_FLASH_READ;\n\t\t\tbreak;\n\t\t}\n\t\tindex++;\n\t} while (1);\n\nexit:\n\tkfree(PageBuf);\n\treturn result;\n}\n\nstatic int ms_lib_setacquired_errorblock(struct us_data *us, u16 phyblk)\n{\n\tu16 log;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\n\t\treturn (u32)-1;\n\n\tlog = info->MS_Lib.Phy2LogMap[phyblk];\n\n\tif (log < info->MS_Lib.NumberOfLogBlock)\n\t\tinfo->MS_Lib.Log2PhyMap[log] = MS_LB_NOT_USED;\n\n\tif (info->MS_Lib.Phy2LogMap[phyblk] != MS_LB_INITIAL_ERROR)\n\t\tinfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_ACQUIRED_ERROR;\n\n\treturn 0;\n}\n\nstatic int ms_lib_overwrite_extra(struct us_data *us, u32 PhyBlockAddr,\n\t\t\t\tu8 PageNum, u8 OverwriteFlag)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint result;\n\n\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x4;\n\tbcb->Flags = US_BULK_FLAG_IN;\n\tbcb->CDB[0] = 0xF2;\n\tbcb->CDB[1] = 0x05;\n\tbcb->CDB[5] = (unsigned char)(PageNum);\n\tbcb->CDB[4] = (unsigned char)(PhyBlockAddr);\n\tbcb->CDB[3] = (unsigned char)(PhyBlockAddr>>8);\n\tbcb->CDB[2] = (unsigned char)(PhyBlockAddr>>16);\n\tbcb->CDB[6] = OverwriteFlag;\n\tbcb->CDB[7] = 0xFF;\n\tbcb->CDB[8] = 0xFF;\n\tbcb->CDB[9] = 0xFF;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_lib_error_phyblock(struct us_data *us, u16 phyblk)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\n\t\treturn MS_STATUS_ERROR;\n\n\tms_lib_setacquired_errorblock(us, phyblk);\n\n\tif (ms_lib_iswritable(info))\n\t\treturn ms_lib_overwrite_extra(us, phyblk, 0, (u8)(~MS_REG_OVR_BKST & BYTE_MASK));\n\n\treturn MS_STATUS_SUCCESS;\n}\n\nstatic int ms_lib_erase_phyblock(struct us_data *us, u16 phyblk)\n{\n\tu16 log;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\n\t\treturn MS_STATUS_ERROR;\n\n\tlog = info->MS_Lib.Phy2LogMap[phyblk];\n\n\tif (log < info->MS_Lib.NumberOfLogBlock)\n\t\tinfo->MS_Lib.Log2PhyMap[log] = MS_LB_NOT_USED;\n\n\tinfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_NOT_USED;\n\n\tif (ms_lib_iswritable(info)) {\n\t\tswitch (ms_read_eraseblock(us, phyblk)) {\n\t\tcase MS_STATUS_SUCCESS:\n\t\t\tinfo->MS_Lib.Phy2LogMap[phyblk] = MS_LB_NOT_USED_ERASED;\n\t\t\treturn MS_STATUS_SUCCESS;\n\t\tcase MS_ERROR_FLASH_ERASE:\n\t\tcase MS_STATUS_INT_ERROR:\n\t\t\tms_lib_error_phyblock(us, phyblk);\n\t\t\treturn MS_ERROR_FLASH_ERASE;\n\t\tcase MS_STATUS_ERROR:\n\t\tdefault:\n\t\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_RDONLY);  \n\t\t\tms_lib_setacquired_errorblock(us, phyblk);\n\t\t\treturn MS_STATUS_ERROR;\n\t\t}\n\t}\n\n\tms_lib_setacquired_errorblock(us, phyblk);\n\n\treturn MS_STATUS_SUCCESS;\n}\n\nstatic int ms_lib_read_extra(struct us_data *us, u32 PhyBlock,\n\t\t\t\tu8 PageNum, struct ms_lib_type_extdat *ExtraDat)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tu8 *bbuf = info->bbuf;\n\tint result;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x4;\n\tbcb->Flags      = US_BULK_FLAG_IN;\n\tbcb->CDB[0]     = 0xF1;\n\tbcb->CDB[1]     = 0x03;\n\tbcb->CDB[5]     = (unsigned char)(PageNum);\n\tbcb->CDB[4]     = (unsigned char)(PhyBlock);\n\tbcb->CDB[3]     = (unsigned char)(PhyBlock>>8);\n\tbcb->CDB[2]     = (unsigned char)(PhyBlock>>16);\n\tbcb->CDB[6]     = 0x01;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tExtraDat->reserved = 0;\n\tExtraDat->intr     = 0x80;   \n\tExtraDat->status0  = 0x10;   \n\tExtraDat->status1  = 0x00;   \n\tExtraDat->ovrflg   = bbuf[0];\n\tExtraDat->mngflg   = bbuf[1];\n\tExtraDat->logadr   = memstick_logaddr(bbuf[2], bbuf[3]);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_libsearch_block_from_physical(struct us_data *us, u16 phyblk)\n{\n\tu16 blk;\n\tstruct ms_lib_type_extdat extdat;  \n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\n\tif (phyblk >= info->MS_Lib.NumberOfPhyBlock)\n\t\treturn MS_LB_ERROR;\n\n\tfor (blk = phyblk + 1; blk != phyblk; blk++) {\n\t\tif ((blk & MS_PHYSICAL_BLOCKS_PER_SEGMENT_MASK) == 0)\n\t\t\tblk -= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\n\t\tif (info->MS_Lib.Phy2LogMap[blk] == MS_LB_NOT_USED_ERASED) {\n\t\t\treturn blk;\n\t\t} else if (info->MS_Lib.Phy2LogMap[blk] == MS_LB_NOT_USED) {\n\t\t\tswitch (ms_lib_read_extra(us, blk, 0, &extdat)) {\n\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\tcase MS_STATUS_SUCCESS_WITH_ECC:\n\t\t\t\tbreak;\n\t\t\tcase MS_NOCARD_ERROR:\n\t\t\t\treturn MS_NOCARD_ERROR;\n\t\t\tcase MS_STATUS_INT_ERROR:\n\t\t\t\treturn MS_LB_ERROR;\n\t\t\tcase MS_ERROR_FLASH_READ:\n\t\t\tdefault:\n\t\t\t\tms_lib_setacquired_errorblock(us, blk);\n\t\t\t\tcontinue;\n\t\t\t}  \n\n\t\t\tif ((extdat.ovrflg & MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {\n\t\t\t\tms_lib_setacquired_errorblock(us, blk);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (ms_lib_erase_phyblock(us, blk)) {\n\t\t\tcase MS_STATUS_SUCCESS:\n\t\t\t\treturn blk;\n\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\treturn MS_LB_ERROR;\n\t\t\tcase MS_ERROR_FLASH_ERASE:\n\t\t\tdefault:\n\t\t\t\tms_lib_error_phyblock(us, blk);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}  \n\n\treturn MS_LB_ERROR;\n}\nstatic int ms_libsearch_block_from_logical(struct us_data *us, u16 logblk)\n{\n\tu16 phyblk;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tphyblk = ms_libconv_to_physical(info, logblk);\n\tif (phyblk >= MS_LB_ERROR) {\n\t\tif (logblk >= info->MS_Lib.NumberOfLogBlock)\n\t\t\treturn MS_LB_ERROR;\n\n\t\tphyblk = (logblk + MS_NUMBER_OF_BOOT_BLOCK) / MS_LOGICAL_BLOCKS_PER_SEGMENT;\n\t\tphyblk *= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\t\tphyblk += MS_PHYSICAL_BLOCKS_PER_SEGMENT - 1;\n\t}\n\n\treturn ms_libsearch_block_from_physical(us, phyblk);\n}\n\nstatic int ms_scsi_test_unit_ready(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\n\n\t \n\tif ((info->MS_Status & MS_Insert) && (info->MS_Status & MS_Ready)) {\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t} else {\n\t\tene_ms_init(us);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_scsi_mode_sense(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tunsigned char mediaNoWP[12] = {\n\t\t0x0b, 0x00, 0x00, 0x08, 0x00, 0x00,\n\t\t0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\n\tunsigned char mediaWP[12]   = {\n\t\t0x0b, 0x00, 0x80, 0x08, 0x00, 0x00,\n\t\t0x71, 0xc0, 0x00, 0x00, 0x02, 0x00 };\n\n\tif (info->MS_Status & MS_WtP)\n\t\tusb_stor_set_xfer_buf(mediaWP, 12, srb);\n\telse\n\t\tusb_stor_set_xfer_buf(mediaNoWP, 12, srb);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_scsi_read_capacity(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tu32   bl_num;\n\tu16    bl_len;\n\tunsigned int offset = 0;\n\tunsigned char    buf[8];\n\tstruct scatterlist *sg = NULL;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tusb_stor_dbg(us, \"ms_scsi_read_capacity\\n\");\n\tbl_len = 0x200;\n\tif (info->MS_Status & MS_IsMSPro)\n\t\tbl_num = info->MSP_TotalBlock - 1;\n\telse\n\t\tbl_num = info->MS_Lib.NumberOfLogBlock * info->MS_Lib.blockSize * 2 - 1;\n\n\tinfo->bl_num = bl_num;\n\tusb_stor_dbg(us, \"bl_len = %x\\n\", bl_len);\n\tusb_stor_dbg(us, \"bl_num = %x\\n\", bl_num);\n\n\t \n\tbuf[0] = (bl_num >> 24) & 0xff;\n\tbuf[1] = (bl_num >> 16) & 0xff;\n\tbuf[2] = (bl_num >> 8) & 0xff;\n\tbuf[3] = (bl_num >> 0) & 0xff;\n\tbuf[4] = (bl_len >> 24) & 0xff;\n\tbuf[5] = (bl_len >> 16) & 0xff;\n\tbuf[6] = (bl_len >> 8) & 0xff;\n\tbuf[7] = (bl_len >> 0) & 0xff;\n\n\tusb_stor_access_xfer_buf(buf, 8, srb, &sg, &offset, TO_XFER_BUF);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic void ms_lib_phy_to_log_range(u16 PhyBlock, u16 *LogStart, u16 *LogEnde)\n{\n\tPhyBlock /= MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\n\tif (PhyBlock) {\n\t\t*LogStart = MS_LOGICAL_BLOCKS_IN_1ST_SEGMENT + (PhyBlock - 1) * MS_LOGICAL_BLOCKS_PER_SEGMENT; \n\t\t*LogEnde = *LogStart + MS_LOGICAL_BLOCKS_PER_SEGMENT; \n\t} else {\n\t\t*LogStart = 0;\n\t\t*LogEnde = MS_LOGICAL_BLOCKS_IN_1ST_SEGMENT; \n\t}\n}\n\nstatic int ms_lib_read_extrablock(struct us_data *us, u32 PhyBlock,\n\tu8 PageNum, u8 blen, void *buf)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint     result;\n\n\t \n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x4 * blen;\n\tbcb->Flags      = US_BULK_FLAG_IN;\n\tbcb->CDB[0]     = 0xF1;\n\tbcb->CDB[1]     = 0x03;\n\tbcb->CDB[5]     = (unsigned char)(PageNum);\n\tbcb->CDB[4]     = (unsigned char)(PhyBlock);\n\tbcb->CDB[3]     = (unsigned char)(PhyBlock>>8);\n\tbcb->CDB[2]     = (unsigned char)(PhyBlock>>16);\n\tbcb->CDB[6]     = blen;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, buf, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ms_lib_scan_logicalblocknumber(struct us_data *us, u16 btBlk1st)\n{\n\tu16 PhyBlock, newblk, i;\n\tu16 LogStart, LogEnde;\n\tstruct ms_lib_type_extdat extdat;\n\tu32 count = 0, index = 0;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tu8 *bbuf = info->bbuf;\n\n\tfor (PhyBlock = 0; PhyBlock < info->MS_Lib.NumberOfPhyBlock;) {\n\t\tms_lib_phy_to_log_range(PhyBlock, &LogStart, &LogEnde);\n\n\t\tfor (i = 0; i < MS_PHYSICAL_BLOCKS_PER_SEGMENT; i++, PhyBlock++) {\n\t\t\tswitch (ms_libconv_to_logical(info, PhyBlock)) {\n\t\t\tcase MS_STATUS_ERROR:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (count == PhyBlock) {\n\t\t\t\tms_lib_read_extrablock(us, PhyBlock, 0, 0x80,\n\t\t\t\t\t\tbbuf);\n\t\t\t\tcount += 0x80;\n\t\t\t}\n\t\t\tindex = (PhyBlock % 0x80) * 4;\n\n\t\t\textdat.ovrflg = bbuf[index];\n\t\t\textdat.mngflg = bbuf[index+1];\n\t\t\textdat.logadr = memstick_logaddr(bbuf[index+2],\n\t\t\t\t\tbbuf[index+3]);\n\n\t\t\tif ((extdat.ovrflg & MS_REG_OVR_BKST) != MS_REG_OVR_BKST_OK) {\n\t\t\t\tms_lib_setacquired_errorblock(us, PhyBlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((extdat.mngflg & MS_REG_MNG_ATFLG) == MS_REG_MNG_ATFLG_ATTBL) {\n\t\t\t\tms_lib_erase_phyblock(us, PhyBlock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (extdat.logadr != MS_LB_NOT_USED) {\n\t\t\t\tif ((extdat.logadr < LogStart) || (LogEnde <= extdat.logadr)) {\n\t\t\t\t\tms_lib_erase_phyblock(us, PhyBlock);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnewblk = ms_libconv_to_physical(info, extdat.logadr);\n\n\t\t\t\tif (newblk != MS_LB_NOT_USED) {\n\t\t\t\t\tif (extdat.logadr == 0) {\n\t\t\t\t\t\tms_lib_set_logicalpair(us, extdat.logadr, PhyBlock);\n\t\t\t\t\t\tif (ms_lib_check_disableblock(us, btBlk1st)) {\n\t\t\t\t\t\t\tms_lib_set_logicalpair(us, extdat.logadr, newblk);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tms_lib_read_extra(us, newblk, 0, &extdat);\n\t\t\t\t\tif ((extdat.ovrflg & MS_REG_OVR_UDST) == MS_REG_OVR_UDST_UPDATING) {\n\t\t\t\t\t\tms_lib_erase_phyblock(us, PhyBlock);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tms_lib_erase_phyblock(us, newblk);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tms_lib_set_logicalpair(us, extdat.logadr, PhyBlock);\n\t\t\t}\n\t\t}\n\t}  \n\n\treturn MS_STATUS_SUCCESS;\n}\n\n\nstatic int ms_scsi_read(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint result;\n\tunsigned char *cdb = srb->cmnd;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tu32 bn = ((cdb[2] << 24) & 0xff000000) | ((cdb[3] << 16) & 0x00ff0000) |\n\t\t((cdb[4] << 8) & 0x0000ff00) | ((cdb[5] << 0) & 0x000000ff);\n\tu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\n\tu32 blenByte = blen * 0x200;\n\n\tif (bn > info->bl_num)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (info->MS_Status & MS_IsMSPro) {\n\t\tresult = ene_load_bincode(us, MSP_RW_PATTERN);\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"Load MPS RW pattern Fail !!\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\n\t\t \n\t\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\t\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\t\tbcb->DataTransferLength = blenByte;\n\t\tbcb->Flags  = US_BULK_FLAG_IN;\n\t\tbcb->CDB[0] = 0xF1;\n\t\tbcb->CDB[1] = 0x02;\n\t\tbcb->CDB[5] = (unsigned char)(bn);\n\t\tbcb->CDB[4] = (unsigned char)(bn>>8);\n\t\tbcb->CDB[3] = (unsigned char)(bn>>16);\n\t\tbcb->CDB[2] = (unsigned char)(bn>>24);\n\n\t\tresult = ene_send_scsi_cmd(us, FDIR_READ, scsi_sglist(srb), 1);\n\t} else {\n\t\tvoid *buf;\n\t\tint offset = 0;\n\t\tu16 phyblk, logblk;\n\t\tu8 PageNum;\n\t\tu16 len;\n\t\tu32 blkno;\n\n\t\tbuf = kmalloc(blenByte, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tpr_info(\"Load MS RW pattern Fail !!\\n\");\n\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tlogblk  = (u16)(bn / info->MS_Lib.PagesPerBlock);\n\t\tPageNum = (u8)(bn % info->MS_Lib.PagesPerBlock);\n\n\t\twhile (1) {\n\t\t\tif (blen > (info->MS_Lib.PagesPerBlock-PageNum))\n\t\t\t\tlen = info->MS_Lib.PagesPerBlock-PageNum;\n\t\t\telse\n\t\t\t\tlen = blen;\n\n\t\t\tphyblk = ms_libconv_to_physical(info, logblk);\n\t\t\tblkno  = phyblk * 0x20 + PageNum;\n\n\t\t\t \n\t\t\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\t\t\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\t\t\tbcb->DataTransferLength = 0x200 * len;\n\t\t\tbcb->Flags  = US_BULK_FLAG_IN;\n\t\t\tbcb->CDB[0] = 0xF1;\n\t\t\tbcb->CDB[1] = 0x02;\n\t\t\tbcb->CDB[5] = (unsigned char)(blkno);\n\t\t\tbcb->CDB[4] = (unsigned char)(blkno>>8);\n\t\t\tbcb->CDB[3] = (unsigned char)(blkno>>16);\n\t\t\tbcb->CDB[2] = (unsigned char)(blkno>>24);\n\n\t\t\tresult = ene_send_scsi_cmd(us, FDIR_READ, buf+offset, 0);\n\t\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\t\tpr_info(\"MS_SCSI_Read --- result = %x\\n\", result);\n\t\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tblen -= len;\n\t\t\tif (blen <= 0)\n\t\t\t\tbreak;\n\t\t\tlogblk++;\n\t\t\tPageNum = 0;\n\t\t\toffset += MS_BYTES_PER_PAGE*len;\n\t\t}\n\t\tusb_stor_set_xfer_buf(buf, blenByte, srb);\nexit:\n\t\tkfree(buf);\n\t}\n\treturn result;\n}\n\nstatic int ms_scsi_write(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint result;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tunsigned char *cdb = srb->cmnd;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tu32 bn = ((cdb[2] << 24) & 0xff000000) |\n\t\t\t((cdb[3] << 16) & 0x00ff0000) |\n\t\t\t((cdb[4] << 8) & 0x0000ff00) |\n\t\t\t((cdb[5] << 0) & 0x000000ff);\n\tu16 blen = ((cdb[7] << 8) & 0xff00) | ((cdb[8] << 0) & 0x00ff);\n\tu32 blenByte = blen * 0x200;\n\n\tif (bn > info->bl_num)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (info->MS_Status & MS_IsMSPro) {\n\t\tresult = ene_load_bincode(us, MSP_RW_PATTERN);\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tpr_info(\"Load MSP RW pattern Fail !!\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\n\t\t \n\t\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\t\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\t\tbcb->DataTransferLength = blenByte;\n\t\tbcb->Flags  = 0x00;\n\t\tbcb->CDB[0] = 0xF0;\n\t\tbcb->CDB[1] = 0x04;\n\t\tbcb->CDB[5] = (unsigned char)(bn);\n\t\tbcb->CDB[4] = (unsigned char)(bn>>8);\n\t\tbcb->CDB[3] = (unsigned char)(bn>>16);\n\t\tbcb->CDB[2] = (unsigned char)(bn>>24);\n\n\t\tresult = ene_send_scsi_cmd(us, FDIR_WRITE, scsi_sglist(srb), 1);\n\t} else {\n\t\tvoid *buf;\n\t\tint offset = 0;\n\t\tu16 PhyBlockAddr;\n\t\tu8 PageNum;\n\t\tu16 len, oldphy, newphy;\n\n\t\tbuf = kmalloc(blenByte, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\tusb_stor_set_xfer_buf(buf, blenByte, srb);\n\n\t\tresult = ene_load_bincode(us, MS_RW_PATTERN);\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tpr_info(\"Load MS RW pattern Fail !!\\n\");\n\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tPhyBlockAddr = (u16)(bn / info->MS_Lib.PagesPerBlock);\n\t\tPageNum      = (u8)(bn % info->MS_Lib.PagesPerBlock);\n\n\t\twhile (1) {\n\t\t\tif (blen > (info->MS_Lib.PagesPerBlock-PageNum))\n\t\t\t\tlen = info->MS_Lib.PagesPerBlock-PageNum;\n\t\t\telse\n\t\t\t\tlen = blen;\n\n\t\t\toldphy = ms_libconv_to_physical(info, PhyBlockAddr);  \n\t\t\tnewphy = ms_libsearch_block_from_logical(us, PhyBlockAddr);\n\n\t\t\tresult = ms_read_copyblock(us, oldphy, newphy, PhyBlockAddr, PageNum, buf+offset, len);\n\n\t\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\t\tpr_info(\"MS_SCSI_Write --- result = %x\\n\", result);\n\t\t\t\tresult =  USB_STOR_TRANSPORT_ERROR;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tinfo->MS_Lib.Phy2LogMap[oldphy] = MS_LB_NOT_USED_ERASED;\n\t\t\tms_lib_force_setlogical_pair(us, PhyBlockAddr, newphy);\n\n\t\t\tblen -= len;\n\t\t\tif (blen <= 0)\n\t\t\t\tbreak;\n\t\t\tPhyBlockAddr++;\n\t\t\tPageNum = 0;\n\t\t\toffset += MS_BYTES_PER_PAGE*len;\n\t\t}\nexit:\n\t\tkfree(buf);\n\t}\n\treturn result;\n}\n\n \n\nstatic int ene_get_card_type(struct us_data *us, u16 index, void *buf)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint result;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength\t= 0x01;\n\tbcb->Flags\t\t\t= US_BULK_FLAG_IN;\n\tbcb->CDB[0]\t\t\t= 0xED;\n\tbcb->CDB[2]\t\t\t= (unsigned char)(index>>8);\n\tbcb->CDB[3]\t\t\t= (unsigned char)index;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, buf, 0);\n\treturn result;\n}\n\nstatic int ene_get_card_status(struct us_data *us, u8 *buf)\n{\n\tu16 tmpreg;\n\tu32 reg4b;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\t \n\treg4b = *(u32 *)&buf[0x18];\n\tinfo->SD_READ_BL_LEN = (u8)((reg4b >> 8) & 0x0f);\n\n\ttmpreg = (u16) reg4b;\n\treg4b = *(u32 *)(&buf[0x14]);\n\tif ((info->SD_Status & SD_HiCapacity) && !(info->SD_Status & SD_IsMMC))\n\t\tinfo->HC_C_SIZE = (reg4b >> 8) & 0x3fffff;\n\n\tinfo->SD_C_SIZE = ((tmpreg & 0x03) << 10) | (u16)(reg4b >> 22);\n\tinfo->SD_C_SIZE_MULT = (u8)(reg4b >> 7)  & 0x07;\n\tif ((info->SD_Status & SD_HiCapacity) && (info->SD_Status & SD_IsMMC))\n\t\tinfo->HC_C_SIZE = *(u32 *)(&buf[0x100]);\n\n\tif (info->SD_READ_BL_LEN > SD_BLOCK_LEN) {\n\t\tinfo->SD_Block_Mult = 1 << (info->SD_READ_BL_LEN-SD_BLOCK_LEN);\n\t\tinfo->SD_READ_BL_LEN = SD_BLOCK_LEN;\n\t} else {\n\t\tinfo->SD_Block_Mult = 1;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ene_load_bincode(struct us_data *us, unsigned char flag)\n{\n\tint err;\n\tchar *fw_name = NULL;\n\tunsigned char *buf = NULL;\n\tconst struct firmware *sd_fw = NULL;\n\tint result = USB_STOR_TRANSPORT_ERROR;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tif (info->BIN_FLAG == flag)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tswitch (flag) {\n\t \n\tcase SD_INIT1_PATTERN:\n\t\tusb_stor_dbg(us, \"SD_INIT1_PATTERN\\n\");\n\t\tfw_name = SD_INIT1_FIRMWARE;\n\t\tbreak;\n\tcase SD_INIT2_PATTERN:\n\t\tusb_stor_dbg(us, \"SD_INIT2_PATTERN\\n\");\n\t\tfw_name = SD_INIT2_FIRMWARE;\n\t\tbreak;\n\tcase SD_RW_PATTERN:\n\t\tusb_stor_dbg(us, \"SD_RW_PATTERN\\n\");\n\t\tfw_name = SD_RW_FIRMWARE;\n\t\tbreak;\n\t \n\tcase MS_INIT_PATTERN:\n\t\tusb_stor_dbg(us, \"MS_INIT_PATTERN\\n\");\n\t\tfw_name = MS_INIT_FIRMWARE;\n\t\tbreak;\n\tcase MSP_RW_PATTERN:\n\t\tusb_stor_dbg(us, \"MSP_RW_PATTERN\\n\");\n\t\tfw_name = MSP_RW_FIRMWARE;\n\t\tbreak;\n\tcase MS_RW_PATTERN:\n\t\tusb_stor_dbg(us, \"MS_RW_PATTERN\\n\");\n\t\tfw_name = MS_RW_FIRMWARE;\n\t\tbreak;\n\tdefault:\n\t\tusb_stor_dbg(us, \"----------- Unknown PATTERN ----------\\n\");\n\t\tgoto nofw;\n\t}\n\n\terr = request_firmware(&sd_fw, fw_name, &us->pusb_dev->dev);\n\tif (err) {\n\t\tusb_stor_dbg(us, \"load firmware %s failed\\n\", fw_name);\n\t\tgoto nofw;\n\t}\n\tbuf = kmemdup(sd_fw->data, sd_fw->size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\tgoto nofw;\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = sd_fw->size;\n\tbcb->Flags = 0x00;\n\tbcb->CDB[0] = 0xEF;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_WRITE, buf, 0);\n\tif (us->srb != NULL)\n\t\tscsi_set_resid(us->srb, 0);\n\tinfo->BIN_FLAG = flag;\n\tkfree(buf);\n\nnofw:\n\trelease_firmware(sd_fw);\n\treturn result;\n}\n\nstatic int ms_card_init(struct us_data *us)\n{\n\tu32 result;\n\tu16 TmpBlock;\n\tunsigned char *PageBuffer0 = NULL, *PageBuffer1 = NULL;\n\tstruct ms_lib_type_extdat extdat;\n\tu16 btBlk1st, btBlk2nd;\n\tu32 btBlk1stErred;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\n\tprintk(KERN_INFO \"MS_CardInit start\\n\");\n\n\tms_lib_free_allocatedarea(us);  \n\n\t \n\tPageBuffer0 = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n\tPageBuffer1 = kmalloc(MS_BYTES_PER_PAGE, GFP_KERNEL);\n\tif ((PageBuffer0 == NULL) || (PageBuffer1 == NULL)) {\n\t\tresult = MS_NO_MEMORY_ERROR;\n\t\tgoto exit;\n\t}\n\n\tbtBlk1st = btBlk2nd = MS_LB_NOT_USED;\n\tbtBlk1stErred = 0;\n\n\tfor (TmpBlock = 0; TmpBlock < MS_MAX_INITIAL_ERROR_BLOCKS+2; TmpBlock++) {\n\n\t\tswitch (ms_read_readpage(us, TmpBlock, 0, (u32 *)PageBuffer0, &extdat)) {\n\t\tcase MS_STATUS_SUCCESS:\n\t\t\tbreak;\n\t\tcase MS_STATUS_INT_ERROR:\n\t\t\tbreak;\n\t\tcase MS_STATUS_ERROR:\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((extdat.ovrflg & MS_REG_OVR_BKST) == MS_REG_OVR_BKST_NG)\n\t\t\tcontinue;\n\n\t\tif (((extdat.mngflg & MS_REG_MNG_SYSFLG) == MS_REG_MNG_SYSFLG_USER) ||\n\t\t\t(be16_to_cpu(((struct ms_bootblock_page0 *)PageBuffer0)->header.wBlockID) != MS_BOOT_BLOCK_ID) ||\n\t\t\t(be16_to_cpu(((struct ms_bootblock_page0 *)PageBuffer0)->header.wFormatVersion) != MS_BOOT_BLOCK_FORMAT_VERSION) ||\n\t\t\t(((struct ms_bootblock_page0 *)PageBuffer0)->header.bNumberOfDataEntry != MS_BOOT_BLOCK_DATA_ENTRIES))\n\t\t\t\tcontinue;\n\n\t\tif (btBlk1st != MS_LB_NOT_USED) {\n\t\t\tbtBlk2nd = TmpBlock;\n\t\t\tbreak;\n\t\t}\n\n\t\tbtBlk1st = TmpBlock;\n\t\tmemcpy(PageBuffer1, PageBuffer0, MS_BYTES_PER_PAGE);\n\t\tif (extdat.status1 & (MS_REG_ST1_DTER | MS_REG_ST1_EXER | MS_REG_ST1_FGER))\n\t\t\tbtBlk1stErred = 1;\n\t}\n\n\tif (btBlk1st == MS_LB_NOT_USED) {\n\t\tresult = MS_STATUS_ERROR;\n\t\tgoto exit;\n\t}\n\n\t \n\tif ((extdat.status0 & MS_REG_ST0_WP) == MS_REG_ST0_WP_ON)\n\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_WRPROTECT);\n\n\tresult = MS_STATUS_ERROR;\n\t \n\tif (btBlk1stErred == 0)\n\t\tresult = ms_lib_process_bootblock(us, btBlk1st, PageBuffer1);\n\t\t \n\t \n\tif (result && (btBlk2nd != MS_LB_NOT_USED))\n\t\tresult = ms_lib_process_bootblock(us, btBlk2nd, PageBuffer0);\n\n\tif (result) {\n\t\tresult = MS_STATUS_ERROR;\n\t\tgoto exit;\n\t}\n\n\tfor (TmpBlock = 0; TmpBlock < btBlk1st; TmpBlock++)\n\t\tinfo->MS_Lib.Phy2LogMap[TmpBlock] = MS_LB_INITIAL_ERROR;\n\n\tinfo->MS_Lib.Phy2LogMap[btBlk1st] = MS_LB_BOOT_BLOCK;\n\n\tif (btBlk2nd != MS_LB_NOT_USED) {\n\t\tfor (TmpBlock = btBlk1st + 1; TmpBlock < btBlk2nd; TmpBlock++)\n\t\t\tinfo->MS_Lib.Phy2LogMap[TmpBlock] = MS_LB_INITIAL_ERROR;\n\n\t\tinfo->MS_Lib.Phy2LogMap[btBlk2nd] = MS_LB_BOOT_BLOCK;\n\t}\n\n\tresult = ms_lib_scan_logicalblocknumber(us, btBlk1st);\n\tif (result)\n\t\tgoto exit;\n\n\tfor (TmpBlock = MS_PHYSICAL_BLOCKS_PER_SEGMENT;\n\t\tTmpBlock < info->MS_Lib.NumberOfPhyBlock;\n\t\tTmpBlock += MS_PHYSICAL_BLOCKS_PER_SEGMENT) {\n\t\tif (ms_count_freeblock(us, TmpBlock) == 0) {\n\t\t\tms_lib_ctrl_set(info, MS_LIB_CTRL_WRPROTECT);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ms_lib_alloc_writebuf(us)) {\n\t\tresult = MS_NO_MEMORY_ERROR;\n\t\tgoto exit;\n\t}\n\n\tresult = MS_STATUS_SUCCESS;\n\nexit:\n\tkfree(PageBuffer1);\n\tkfree(PageBuffer0);\n\n\tprintk(KERN_INFO \"MS_CardInit end\\n\");\n\treturn result;\n}\n\nstatic int ene_ms_init(struct us_data *us)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tint result;\n\tu16 MSP_BlockSize, MSP_UserAreaBlocks;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tu8 *bbuf = info->bbuf;\n\tunsigned int s;\n\n\tprintk(KERN_INFO \"transport --- ENE_MSInit\\n\");\n\n\t \n\n\tresult = ene_load_bincode(us, MS_INIT_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tprintk(KERN_ERR \"Load MS Init Code Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x200;\n\tbcb->Flags      = US_BULK_FLAG_IN;\n\tbcb->CDB[0]     = 0xF1;\n\tbcb->CDB[1]     = 0x01;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tprintk(KERN_ERR \"Execution MS Init Code Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\t \n\tinfo->MS_Status = bbuf[0];\n\n\ts = info->MS_Status;\n\tif ((s & MS_Insert) && (s & MS_Ready)) {\n\t\tprintk(KERN_INFO \"Insert     = %x\\n\", !!(s & MS_Insert));\n\t\tprintk(KERN_INFO \"Ready      = %x\\n\", !!(s & MS_Ready));\n\t\tprintk(KERN_INFO \"IsMSPro    = %x\\n\", !!(s & MS_IsMSPro));\n\t\tprintk(KERN_INFO \"IsMSPHG    = %x\\n\", !!(s & MS_IsMSPHG));\n\t\tprintk(KERN_INFO \"WtP= %x\\n\", !!(s & MS_WtP));\n\t\tif (s & MS_IsMSPro) {\n\t\t\tMSP_BlockSize      = (bbuf[6] << 8) | bbuf[7];\n\t\t\tMSP_UserAreaBlocks = (bbuf[10] << 8) | bbuf[11];\n\t\t\tinfo->MSP_TotalBlock = MSP_BlockSize * MSP_UserAreaBlocks;\n\t\t} else {\n\t\t\tms_card_init(us);  \n\t\t}\n\t\tusb_stor_dbg(us, \"MS Init Code OK !!\\n\");\n\t} else {\n\t\tusb_stor_dbg(us, \"MS Card Not Ready --- %x\\n\", bbuf[0]);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int ene_sd_init(struct us_data *us)\n{\n\tint result;\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *) us->extra;\n\tu8 *bbuf = info->bbuf;\n\n\tusb_stor_dbg(us, \"transport --- ENE_SDInit\\n\");\n\t \n\tresult = ene_load_bincode(us, SD_INIT1_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Load SD Init Code Part-1 Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->Flags = US_BULK_FLAG_IN;\n\tbcb->CDB[0] = 0xF2;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, NULL, 0);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Execution SD Init Code Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tresult = ene_load_bincode(us, SD_INIT2_PATTERN);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Load SD Init Code Part-2 Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = 0x200;\n\tbcb->Flags              = US_BULK_FLAG_IN;\n\tbcb->CDB[0]             = 0xF1;\n\n\tresult = ene_send_scsi_cmd(us, FDIR_READ, bbuf, 0);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Execution SD Init Code Fail !!\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tinfo->SD_Status = bbuf[0];\n\tif ((info->SD_Status & SD_Insert) && (info->SD_Status & SD_Ready)) {\n\t\tunsigned int s = info->SD_Status;\n\n\t\tene_get_card_status(us, bbuf);\n\t\tusb_stor_dbg(us, \"Insert     = %x\\n\", !!(s & SD_Insert));\n\t\tusb_stor_dbg(us, \"Ready      = %x\\n\", !!(s & SD_Ready));\n\t\tusb_stor_dbg(us, \"IsMMC      = %x\\n\", !!(s & SD_IsMMC));\n\t\tusb_stor_dbg(us, \"HiCapacity = %x\\n\", !!(s & SD_HiCapacity));\n\t\tusb_stor_dbg(us, \"HiSpeed    = %x\\n\", !!(s & SD_HiSpeed));\n\t\tusb_stor_dbg(us, \"WtP        = %x\\n\", !!(s & SD_WtP));\n\t} else {\n\t\tusb_stor_dbg(us, \"SD Card Not Ready --- %x\\n\", bbuf[0]);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n\nstatic int ene_init(struct us_data *us)\n{\n\tint result;\n\tu8  misc_reg03;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\n\tu8 *bbuf = info->bbuf;\n\n\tresult = ene_get_card_type(us, REG_CARD_STATUS, bbuf);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmisc_reg03 = bbuf[0];\n\tif (misc_reg03 & 0x01) {\n\t\tif (!(info->SD_Status & SD_Ready)) {\n\t\t\tresult = ene_sd_init(us);\n\t\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\t}\n\tif (misc_reg03 & 0x02) {\n\t\tif (!(info->MS_Status & MS_Ready)) {\n\t\t\tresult = ene_ms_init(us);\n\t\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\t}\n\treturn result;\n}\n\n \nstatic int sd_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint    result;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)us->extra;\n\n\tswitch (srb->cmnd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tresult = sd_scsi_test_unit_ready(us, srb);\n\t\tbreak;  \n\tcase REQUEST_SENSE:\n\t\tresult = do_scsi_request_sense(us, srb);\n\t\tbreak;  \n\tcase INQUIRY:\n\t\tresult = do_scsi_inquiry(us, srb);\n\t\tbreak;  \n\tcase MODE_SENSE:\n\t\tresult = sd_scsi_mode_sense(us, srb);\n\t\tbreak;  \n\t \n\tcase READ_CAPACITY:\n\t\tresult = sd_scsi_read_capacity(us, srb);\n\t\tbreak;  \n\tcase READ_10:\n\t\tresult = sd_scsi_read(us, srb);\n\t\tbreak;  \n\tcase WRITE_10:\n\t\tresult = sd_scsi_write(us, srb);\n\t\tbreak;  \n\tdefault:\n\t\tinfo->SrbStatus = SS_ILLEGAL_REQUEST;\n\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\tbreak;\n\t}\n\tif (result == USB_STOR_TRANSPORT_GOOD)\n\t\tinfo->SrbStatus = SS_SUCCESS;\n\treturn result;\n}\n\n \nstatic int ms_scsi_irp(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tint result;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)us->extra;\n\n\tswitch (srb->cmnd[0]) {\n\tcase TEST_UNIT_READY:\n\t\tresult = ms_scsi_test_unit_ready(us, srb);\n\t\tbreak;  \n\tcase REQUEST_SENSE:\n\t\tresult = do_scsi_request_sense(us, srb);\n\t\tbreak;  \n\tcase INQUIRY:\n\t\tresult = do_scsi_inquiry(us, srb);\n\t\tbreak;  \n\tcase MODE_SENSE:\n\t\tresult = ms_scsi_mode_sense(us, srb);\n\t\tbreak;  \n\tcase READ_CAPACITY:\n\t\tresult = ms_scsi_read_capacity(us, srb);\n\t\tbreak;  \n\tcase READ_10:\n\t\tresult = ms_scsi_read(us, srb);\n\t\tbreak;  \n\tcase WRITE_10:\n\t\tresult = ms_scsi_write(us, srb);\n\t\tbreak;   \n\tdefault:\n\t\tinfo->SrbStatus = SS_ILLEGAL_REQUEST;\n\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\tbreak;\n\t}\n\tif (result == USB_STOR_TRANSPORT_GOOD)\n\t\tinfo->SrbStatus = SS_SUCCESS;\n\treturn result;\n}\n\nstatic int ene_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint result = USB_STOR_XFER_GOOD;\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\n\n\t \n\tscsi_set_resid(srb, 0);\n\tif (unlikely(!(info->SD_Status & SD_Ready) || (info->MS_Status & MS_Ready)))\n\t\tresult = ene_init(us);\n\tif (result == USB_STOR_XFER_GOOD) {\n\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\tif (info->SD_Status & SD_Ready)\n\t\t\tresult = sd_scsi_irp(us, srb);\n\n\t\tif (info->MS_Status & MS_Ready)\n\t\t\tresult = ms_scsi_irp(us, srb);\n\t}\n\treturn result;\n}\n\nstatic struct scsi_host_template ene_ub6250_host_template;\n\nstatic int ene_ub6250_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tint result;\n\tu8  misc_reg03;\n\tstruct us_data *us;\n\tstruct ene_ub6250_info *info;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t   (id - ene_ub6250_usb_ids) + ene_ub6250_unusual_dev_list,\n\t\t   &ene_ub6250_host_template);\n\tif (result)\n\t\treturn result;\n\n\t \n\tus->extra = kzalloc(sizeof(struct ene_ub6250_info), GFP_KERNEL);\n\tif (!us->extra)\n\t\treturn -ENOMEM;\n\tus->extra_destructor = ene_ub6250_info_destructor;\n\n\tinfo = (struct ene_ub6250_info *)(us->extra);\n\tinfo->bbuf = kmalloc(512, GFP_KERNEL);\n\tif (!info->bbuf) {\n\t\tkfree(us->extra);\n\t\treturn -ENOMEM;\n\t}\n\n\tus->transport_name = \"ene_ub6250\";\n\tus->transport = ene_transport;\n\tus->max_lun = 0;\n\n\tresult = usb_stor_probe2(us);\n\tif (result)\n\t\treturn result;\n\n\t \n\tresult = ene_get_card_type(us, REG_CARD_STATUS, info->bbuf);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_disconnect(intf);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tmisc_reg03 = info->bbuf[0];\n\tif (!(misc_reg03 & 0x01)) {\n\t\tpr_info(\"ums_eneub6250: This driver only supports SD/MS cards. \"\n\t\t\t\"It does not support SM cards.\\n\");\n\t}\n\n\treturn result;\n}\n\n\n#ifdef CONFIG_PM\n\nstatic int ene_ub6250_resume(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\n\n\tmutex_lock(&us->dev_mutex);\n\n\tif (us->suspend_resume_hook)\n\t\t(us->suspend_resume_hook)(us, US_RESUME);\n\n\tmutex_unlock(&us->dev_mutex);\n\n\tinfo->Power_IsResum = true;\n\t \n\tinfo->SD_Status = 0;\n\tinfo->MS_Status = 0;\n\tinfo->SM_Status = 0;\n\n\treturn 0;\n}\n\nstatic int ene_ub6250_reset_resume(struct usb_interface *iface)\n{\n\tstruct us_data *us = usb_get_intfdata(iface);\n\tstruct ene_ub6250_info *info = (struct ene_ub6250_info *)(us->extra);\n\n\t \n\tusb_stor_reset_resume(iface);\n\n\t \n\tinfo->Power_IsResum = true;\n\t \n\tinfo->SD_Status = 0;\n\tinfo->MS_Status = 0;\n\tinfo->SM_Status = 0;\n\n\treturn 0;\n}\n\n#else\n\n#define ene_ub6250_resume\t\tNULL\n#define ene_ub6250_reset_resume\t\tNULL\n\n#endif\n\nstatic struct usb_driver ene_ub6250_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tene_ub6250_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tene_ub6250_resume,\n\t.reset_resume =\tene_ub6250_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tene_ub6250_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(ene_ub6250_driver, ene_ub6250_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}