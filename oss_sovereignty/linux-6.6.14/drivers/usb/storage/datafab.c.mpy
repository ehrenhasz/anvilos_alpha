{
  "module_name": "datafab.c",
  "hash_id": "ac3a987113bc0b7fe5e2ff9abace72a53fb9e4045b48539ffa9a9865a19246a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/datafab.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-datafab\"\n\nMODULE_DESCRIPTION(\"Driver for Datafab USB Compact Flash reader\");\nMODULE_AUTHOR(\"Jimmie Mayfield <mayfield+datafab@sackheads.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\nstruct datafab_info {\n\tunsigned long   sectors;\t \n\tunsigned long   ssize;\t\t \n\tsigned char\tlun;\t\t \n\n\t \n\tunsigned char   sense_key;\n\tunsigned long   sense_asc;\t \n\tunsigned long   sense_ascq;\t \n};\n\nstatic int datafab_determine_lun(struct us_data *us,\n\t\t\t\t struct datafab_info *info);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id datafab_usb_ids[] = {\n#\tinclude \"unusual_datafab.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, datafab_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev datafab_unusual_dev_list[] = {\n#\tinclude \"unusual_datafab.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\nstatic inline int\ndatafab_bulk_read(struct us_data *us, unsigned char *data, unsigned int len) {\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\tdata, len, NULL);\n}\n\n\nstatic inline int\ndatafab_bulk_write(struct us_data *us, unsigned char *data, unsigned int len) {\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\tdata, len, NULL);\n}\n\n\nstatic int datafab_read_data(struct us_data *us,\n\t\t\t     struct datafab_info *info,\n\t\t\t     u32 sector,\n\t\t\t     u32 sectors)\n{\n\tunsigned char *command = us->iobuf;\n\tunsigned char *buffer;\n\tunsigned char  thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\t\n\t\n\t\n\t\n\t\n\tif (sectors > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (info->lun == -1) {\n\t\tresult = datafab_determine_lun(us, info);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn result;\n\t}\n\n\ttotallen = sectors * info->ssize;\n\n\t\n\t\n\t\n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t\n\t\t\n\n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n\n\t\tcommand[0] = 0;\n\t\tcommand[1] = thistime;\n\t\tcommand[2] = sector & 0xFF;\n\t\tcommand[3] = (sector >> 8) & 0xFF;\n\t\tcommand[4] = (sector >> 16) & 0xFF;\n\n\t\tcommand[5] = 0xE0 + (info->lun << 4);\n\t\tcommand[5] |= (sector >> 24) & 0x0F;\n\t\tcommand[6] = 0x20;\n\t\tcommand[7] = 0x01;\n\n\t\t\n\t\tresult = datafab_bulk_write(us, command, 8);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tresult = datafab_bulk_read(us, buffer, len);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t &sg, &sg_offset, TO_XFER_BUF);\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\n\nstatic int datafab_write_data(struct us_data *us,\n\t\t\t      struct datafab_info *info,\n\t\t\t      u32 sector,\n\t\t\t      u32 sectors)\n{\n\tunsigned char *command = us->iobuf;\n\tunsigned char *reply = us->iobuf;\n\tunsigned char *buffer;\n\tunsigned char thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\t\n\t\n\t\n\t\n\t\n\tif (sectors > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (info->lun == -1) {\n\t\tresult = datafab_determine_lun(us, info);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn result;\n\t}\n\n\ttotallen = sectors * info->ssize;\n\n\t\n\t\n\t\n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t\n\t\t\n\n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &sg_offset, FROM_XFER_BUF);\n\n\t\tcommand[0] = 0;\n\t\tcommand[1] = thistime;\n\t\tcommand[2] = sector & 0xFF;\n\t\tcommand[3] = (sector >> 8) & 0xFF;\n\t\tcommand[4] = (sector >> 16) & 0xFF;\n\n\t\tcommand[5] = 0xE0 + (info->lun << 4);\n\t\tcommand[5] |= (sector >> 24) & 0x0F;\n\t\tcommand[6] = 0x30;\n\t\tcommand[7] = 0x02;\n\n\t\t\n\t\tresult = datafab_bulk_write(us, command, 8);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tresult = datafab_bulk_write(us, buffer, len);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tresult = datafab_bulk_read(us, reply, 2);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\tif (reply[0] != 0x50 && reply[1] != 0) {\n\t\t\tusb_stor_dbg(us, \"Gah! write return code: %02x %02x\\n\",\n\t\t\t\t     reply[0], reply[1]);\n\t\t\tgoto leave;\n\t\t}\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\n\nstatic int datafab_determine_lun(struct us_data *us,\n\t\t\t\t struct datafab_info *info)\n{\n\t\n\t\n\t\n\t\n\t\n\n\tstatic unsigned char scommand[8] = { 0, 1, 0, 0, 0, 0xa0, 0xec, 1 };\n\tunsigned char *command = us->iobuf;\n\tunsigned char *buf;\n\tint count = 0, rc;\n\n\tif (!info)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemcpy(command, scommand, 8);\n\tbuf = kmalloc(512, GFP_NOIO);\n\tif (!buf)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tusb_stor_dbg(us, \"locating...\\n\");\n\n\t\n\t\n\twhile (count++ < 3) {\n\t\tcommand[5] = 0xa0;\n\n\t\trc = datafab_bulk_write(us, command, 8);\n\t\tif (rc != USB_STOR_XFER_GOOD) {\n\t\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\t\tgoto leave;\n\t\t}\n\n\t\trc = datafab_bulk_read(us, buf, 512);\n\t\tif (rc == USB_STOR_XFER_GOOD) {\n\t\t\tinfo->lun = 0;\n\t\t\trc = USB_STOR_TRANSPORT_GOOD;\n\t\t\tgoto leave;\n\t\t}\n\n\t\tcommand[5] = 0xb0;\n\n\t\trc = datafab_bulk_write(us, command, 8);\n\t\tif (rc != USB_STOR_XFER_GOOD) {\n\t\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\t\tgoto leave;\n\t\t}\n\n\t\trc = datafab_bulk_read(us, buf, 512);\n\t\tif (rc == USB_STOR_XFER_GOOD) {\n\t\t\tinfo->lun = 1;\n\t\t\trc = USB_STOR_TRANSPORT_GOOD;\n\t\t\tgoto leave;\n\t\t}\n\n\t\tmsleep(20);\n\t}\n\n\trc = USB_STOR_TRANSPORT_ERROR;\n\n leave:\n\tkfree(buf);\n\treturn rc;\n}\n\nstatic int datafab_id_device(struct us_data *us,\n\t\t\t     struct datafab_info *info)\n{\n\t\n\t\n\t\n\t\n\tstatic unsigned char scommand[8] = { 0, 1, 0, 0, 0, 0xa0, 0xec, 1 };\n\tunsigned char *command = us->iobuf;\n\tunsigned char *reply;\n\tint rc;\n\n\tif (!info)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (info->lun == -1) {\n\t\trc = datafab_determine_lun(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\t}\n\n\tmemcpy(command, scommand, 8);\n\treply = kmalloc(512, GFP_NOIO);\n\tif (!reply)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tcommand[5] += (info->lun << 4);\n\n\trc = datafab_bulk_write(us, command, 8);\n\tif (rc != USB_STOR_XFER_GOOD) {\n\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto leave;\n\t}\n\n\t\n\t\n\trc = datafab_bulk_read(us, reply, 512);\n\tif (rc == USB_STOR_XFER_GOOD) {\n\t\t\n\t\t\n\t\tinfo->sectors = ((u32)(reply[117]) << 24) | \n\t\t\t\t((u32)(reply[116]) << 16) |\n\t\t\t\t((u32)(reply[115]) <<  8) | \n\t\t\t\t((u32)(reply[114])      );\n\t\trc = USB_STOR_TRANSPORT_GOOD;\n\t\tgoto leave;\n\t}\n\n\trc = USB_STOR_TRANSPORT_ERROR;\n\n leave:\n\tkfree(reply);\n\treturn rc;\n}\n\n\nstatic int datafab_handle_mode_sense(struct us_data *us,\n\t\t\t\t     struct scsi_cmnd * srb, \n\t\t\t\t     int sense_6)\n{\n\tstatic unsigned char rw_err_page[12] = {\n\t\t0x1, 0xA, 0x21, 1, 0, 0, 0, 0, 1, 0, 0, 0\n\t};\n\tstatic unsigned char cache_page[12] = {\n\t\t0x8, 0xA, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic unsigned char rbac_page[12] = {\n\t\t0x1B, 0xA, 0, 0x81, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic unsigned char timer_page[8] = {\n\t\t0x1C, 0x6, 0, 0, 0, 0\n\t};\n\tunsigned char pc, page_code;\n\tunsigned int i = 0;\n\tstruct datafab_info *info = (struct datafab_info *) (us->extra);\n\tunsigned char *ptr = us->iobuf;\n\n\t\n\t\n\t\n\t\n\n\tpc = srb->cmnd[2] >> 6;\n\tpage_code = srb->cmnd[2] & 0x3F;\n\n\tswitch (pc) {\n\t   case 0x0:\n\t\t   usb_stor_dbg(us, \"Current values\\n\");\n\t\tbreak;\n\t   case 0x1:\n\t\t   usb_stor_dbg(us, \"Changeable values\\n\");\n\t\tbreak;\n\t   case 0x2:\n\t\t   usb_stor_dbg(us, \"Default values\\n\");\n\t\tbreak;\n\t   case 0x3:\n\t\t   usb_stor_dbg(us, \"Saves values\\n\");\n\t\tbreak;\n\t}\n\n\tmemset(ptr, 0, 8);\n\tif (sense_6) {\n\t\tptr[2] = 0x00;\t\t\n\t\ti = 4;\n\t} else {\n\t\tptr[3] = 0x00;\t\t\n\t\ti = 8;\n\t}\n\n\tswitch (page_code) {\n\t   default:\n\t\t\n\t\tinfo->sense_key = 0x05;\n\t\tinfo->sense_asc = 0x24;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t   case 0x1:\n\t\tmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\n\t\ti += sizeof(rw_err_page);\n\t\tbreak;\n\n\t   case 0x8:\n\t\tmemcpy(ptr + i, cache_page, sizeof(cache_page));\n\t\ti += sizeof(cache_page);\n\t\tbreak;\n\n\t   case 0x1B:\n\t\tmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\n\t\ti += sizeof(rbac_page);\n\t\tbreak;\n\n\t   case 0x1C:\n\t\tmemcpy(ptr + i, timer_page, sizeof(timer_page));\n\t\ti += sizeof(timer_page);\n\t\tbreak;\n\n\t   case 0x3F:\t\t\n\t\tmemcpy(ptr + i, timer_page, sizeof(timer_page));\n\t\ti += sizeof(timer_page);\n\t\tmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\n\t\ti += sizeof(rbac_page);\n\t\tmemcpy(ptr + i, cache_page, sizeof(cache_page));\n\t\ti += sizeof(cache_page);\n\t\tmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\n\t\ti += sizeof(rw_err_page);\n\t\tbreak;\n\t}\n\n\tif (sense_6)\n\t\tptr[0] = i - 1;\n\telse\n\t\t((__be16 *) ptr)[0] = cpu_to_be16(i - 2);\n\tusb_stor_set_xfer_buf(ptr, i, srb);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic void datafab_info_destructor(void *extra)\n{\n\t\n\t\n}\n\n\n\n\nstatic int datafab_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstruct datafab_info *info;\n\tint rc;\n\tunsigned long block, blocks;\n\tunsigned char *ptr = us->iobuf;\n\tstatic unsigned char inquiry_reply[8] = {\n\t\t0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\n\t};\n\n\tif (!us->extra) {\n\t\tus->extra = kzalloc(sizeof(struct datafab_info), GFP_NOIO);\n\t\tif (!us->extra)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tus->extra_destructor = datafab_info_destructor;\n  \t\t((struct datafab_info *)us->extra)->lun = -1;\n\t}\n\n\tinfo = (struct datafab_info *) (us->extra);\n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tusb_stor_dbg(us, \"INQUIRY - Returning bogus response\\n\");\n\t\tmemcpy(ptr, inquiry_reply, sizeof(inquiry_reply));\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\t\tinfo->ssize = 0x200;  \n\t\trc = datafab_id_device(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tusb_stor_dbg(us, \"READ_CAPACITY:  %ld sectors, %ld bytes per sector\\n\",\n\t\t\t     info->sectors, info->ssize);\n\n\t\t\n\t\t\n\t\t((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SELECT_10) {\n\t\tusb_stor_dbg(us, \"Gah! MODE_SELECT_10\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t\n\t\n\tif (srb->cmnd[0] == READ_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"READ_10: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn datafab_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == READ_12) {\n\t\t\n\t\t\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t\t ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"READ_12: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn datafab_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"WRITE_10: write block 0x%04lx count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn datafab_write_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_12) {\n\t\t\n\t\t\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t\t ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"WRITE_12: write block 0x%04lx count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn datafab_write_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\tusb_stor_dbg(us, \"TEST_UNIT_READY\\n\");\n\t\treturn datafab_id_device(us, info);\n\t}\n\n\tif (srb->cmnd[0] == REQUEST_SENSE) {\n\t\tusb_stor_dbg(us, \"REQUEST_SENSE - Returning faked response\\n\");\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tmemset(ptr, 0, 18);\n\t\tptr[0] = 0xF0;\n\t\tptr[2] = info->sense_key;\n\t\tptr[7] = 11;\n\t\tptr[12] = info->sense_asc;\n\t\tptr[13] = info->sense_ascq;\n\t\tusb_stor_set_xfer_buf(ptr, 18, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE) {\n\t\tusb_stor_dbg(us, \"MODE_SENSE_6 detected\\n\");\n\t\treturn datafab_handle_mode_sense(us, srb, 1);\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE_10) {\n\t\tusb_stor_dbg(us, \"MODE_SENSE_10 detected\\n\");\n\t\treturn datafab_handle_mode_sense(us, srb, 0);\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\t\t \n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == START_STOP) {\n\t\t \n\t\tusb_stor_dbg(us, \"START_STOP\\n\");\n\t\t \n\t\trc = datafab_id_device(us, info);\n\t\tif (rc == USB_STOR_TRANSPORT_GOOD) {\n\t\t\tinfo->sense_key = NO_SENSE;\n\t\t\tsrb->result = SUCCESS;\n\t\t} else {\n\t\t\tinfo->sense_key = UNIT_ATTENTION;\n\t\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\t}\n\t\treturn rc;\n\t}\n\n\tusb_stor_dbg(us, \"Gah! Unknown command: %d (0x%x)\\n\",\n\t\t     srb->cmnd[0], srb->cmnd[0]);\n\tinfo->sense_key = 0x05;\n\tinfo->sense_asc = 0x20;\n\tinfo->sense_ascq = 0x00;\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\nstatic struct scsi_host_template datafab_host_template;\n\nstatic int datafab_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - datafab_usb_ids) + datafab_unusual_dev_list,\n\t\t\t&datafab_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name  = \"Datafab Bulk-Only\";\n\tus->transport = datafab_transport;\n\tus->transport_reset = usb_stor_Bulk_reset;\n\tus->max_lun = 1;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver datafab_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tdatafab_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tdatafab_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(datafab_driver, datafab_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}