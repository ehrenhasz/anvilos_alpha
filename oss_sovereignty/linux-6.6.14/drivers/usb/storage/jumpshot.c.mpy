{
  "module_name": "jumpshot.c",
  "hash_id": "b1a6e73e58ada2e61968a7a22f4f364cd1a05c0261f65ff85150e8012895682b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/jumpshot.c",
  "human_readable_source": "\n \n \n  \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-jumpshot\"\n\nMODULE_DESCRIPTION(\"Driver for Lexar \\\"Jumpshot\\\" Compact Flash reader\");\nMODULE_AUTHOR(\"Jimmie Mayfield <mayfield+usb@sackheads.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id jumpshot_usb_ids[] = {\n#\tinclude \"unusual_jumpshot.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, jumpshot_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev jumpshot_unusual_dev_list[] = {\n#\tinclude \"unusual_jumpshot.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\nstruct jumpshot_info {\n   unsigned long   sectors;      \n   unsigned long   ssize;        \n\n    \n   unsigned char   sense_key;\n   unsigned long   sense_asc;    \n   unsigned long   sense_ascq;   \n};\n\nstatic inline int jumpshot_bulk_read(struct us_data *us,\n\t\t\t\t     unsigned char *data, \n\t\t\t\t     unsigned int len)\n{\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\tdata, len, NULL);\n}\n\n\nstatic inline int jumpshot_bulk_write(struct us_data *us,\n\t\t\t\t      unsigned char *data, \n\t\t\t\t      unsigned int len)\n{\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\tdata, len, NULL);\n}\n\n\nstatic int jumpshot_get_status(struct us_data  *us)\n{\n\tint rc;\n\n\tif (!us)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\trc = usb_stor_ctrl_transfer(us, us->recv_ctrl_pipe,\n\t\t\t\t   0, 0xA0, 0, 7, us->iobuf, 1);\n\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (us->iobuf[0] != 0x50) {\n\t\tusb_stor_dbg(us, \"0x%2x\\n\", us->iobuf[0]);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int jumpshot_read_data(struct us_data *us,\n\t\t\t      struct jumpshot_info *info,\n\t\t\t      u32 sector,\n\t\t\t      u32 sectors)\n{\n\tunsigned char *command = us->iobuf;\n\tunsigned char *buffer;\n\tunsigned char  thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\t \n\t\n\t\n\t\n\n\tif (sector > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\ttotallen = sectors * info->ssize;\n\n\t\n\t\n\t\n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t\n\t\t\n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n\n\t\tcommand[0] = 0;\n\t\tcommand[1] = thistime;\n\t\tcommand[2] = sector & 0xFF;\n\t\tcommand[3] = (sector >>  8) & 0xFF;\n\t\tcommand[4] = (sector >> 16) & 0xFF;\n\n\t\tcommand[5] = 0xE0 | ((sector >> 24) & 0x0F);\n\t\tcommand[6] = 0x20;\n\n\t\t\n\t\tresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\t\t\t\t       0, 0x20, 0, 1, command, 7);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tresult = jumpshot_bulk_read(us, buffer, len);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\tusb_stor_dbg(us, \"%d bytes\\n\", len);\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t &sg, &sg_offset, TO_XFER_BUF);\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\n\nstatic int jumpshot_write_data(struct us_data *us,\n\t\t\t       struct jumpshot_info *info,\n\t\t\t       u32 sector,\n\t\t\t       u32 sectors)\n{\n\tunsigned char *command = us->iobuf;\n\tunsigned char *buffer;\n\tunsigned char  thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result, waitcount;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\t\n\t\n\t\n\t\n\t\n\tif (sector > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\ttotallen = sectors * info->ssize;\n\n\t\n\t\n\t\n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t\n\t\t\n\n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &sg_offset, FROM_XFER_BUF);\n\n\t\tcommand[0] = 0;\n\t\tcommand[1] = thistime;\n\t\tcommand[2] = sector & 0xFF;\n\t\tcommand[3] = (sector >>  8) & 0xFF;\n\t\tcommand[4] = (sector >> 16) & 0xFF;\n\n\t\tcommand[5] = 0xE0 | ((sector >> 24) & 0x0F);\n\t\tcommand[6] = 0x30;\n\n\t\t\n\t\tresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\t\t0, 0x20, 0, 1, command, 7);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\tresult = jumpshot_bulk_write(us, buffer, len);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tgoto leave;\n\n\t\t\n\t\t\n\t\t\n\t\twaitcount = 0;\n\t\tdo {\n\t\t\tresult = jumpshot_get_status(us);\n\t\t\tif (result != USB_STOR_TRANSPORT_GOOD) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tmsleep(50); \n\t\t\t}\n\t\t} while ((result != USB_STOR_TRANSPORT_GOOD) && (waitcount < 10));\n\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tusb_stor_dbg(us, \"Gah!  Waitcount = 10.  Bad write!?\\n\");\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn result;\n\n leave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\nstatic int jumpshot_id_device(struct us_data *us,\n\t\t\t      struct jumpshot_info *info)\n{\n\tunsigned char *command = us->iobuf;\n\tunsigned char *reply;\n\tint \t rc;\n\n\tif (!info)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tcommand[0] = 0xE0;\n\tcommand[1] = 0xEC;\n\treply = kmalloc(512, GFP_NOIO);\n\tif (!reply)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\n\trc = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\t\t\t   0, 0x20, 0, 6, command, 2);\n\n\tif (rc != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Gah! send_control for read_capacity failed\\n\");\n\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto leave;\n\t}\n\n\t\n\trc = jumpshot_bulk_read(us, reply, 512);\n\tif (rc != USB_STOR_XFER_GOOD) {\n\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto leave;\n\t}\n\n\tinfo->sectors = ((u32)(reply[117]) << 24) |\n\t\t\t((u32)(reply[116]) << 16) |\n\t\t\t((u32)(reply[115]) <<  8) |\n\t\t\t((u32)(reply[114])      );\n\n\trc = USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(reply);\n\treturn rc;\n}\n\nstatic int jumpshot_handle_mode_sense(struct us_data *us,\n\t\t\t\t      struct scsi_cmnd * srb, \n\t\t\t\t      int sense_6)\n{\n\tstatic unsigned char rw_err_page[12] = {\n\t\t0x1, 0xA, 0x21, 1, 0, 0, 0, 0, 1, 0, 0, 0\n\t};\n\tstatic unsigned char cache_page[12] = {\n\t\t0x8, 0xA, 0x1, 0, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic unsigned char rbac_page[12] = {\n\t\t0x1B, 0xA, 0, 0x81, 0, 0, 0, 0, 0, 0, 0, 0\n\t};\n\tstatic unsigned char timer_page[8] = {\n\t\t0x1C, 0x6, 0, 0, 0, 0\n\t};\n\tunsigned char pc, page_code;\n\tunsigned int i = 0;\n\tstruct jumpshot_info *info = (struct jumpshot_info *) (us->extra);\n\tunsigned char *ptr = us->iobuf;\n\n\tpc = srb->cmnd[2] >> 6;\n\tpage_code = srb->cmnd[2] & 0x3F;\n\n\tswitch (pc) {\n\t   case 0x0:\n\t\t   usb_stor_dbg(us, \"Current values\\n\");\n\t\t   break;\n\t   case 0x1:\n\t\t   usb_stor_dbg(us, \"Changeable values\\n\");\n\t\t   break;\n\t   case 0x2:\n\t\t   usb_stor_dbg(us, \"Default values\\n\");\n\t\t   break;\n\t   case 0x3:\n\t\t   usb_stor_dbg(us, \"Saves values\\n\");\n\t\t   break;\n\t}\n\n\tmemset(ptr, 0, 8);\n\tif (sense_6) {\n\t\tptr[2] = 0x00;\t\t\n\t\ti = 4;\n\t} else {\n\t\tptr[3] = 0x00;\t\t\n\t\ti = 8;\n\t}\n\n\tswitch (page_code) {\n\t   case 0x0:\n\t\t\n\t\tinfo->sense_key = 0x05;\n\t\tinfo->sense_asc = 0x24;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t   case 0x1:\n\t\tmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\n\t\ti += sizeof(rw_err_page);\n\t\tbreak;\n\n\t   case 0x8:\n\t\tmemcpy(ptr + i, cache_page, sizeof(cache_page));\n\t\ti += sizeof(cache_page);\n\t\tbreak;\n\n\t   case 0x1B:\n\t\tmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\n\t\ti += sizeof(rbac_page);\n\t\tbreak;\n\n\t   case 0x1C:\n\t\tmemcpy(ptr + i, timer_page, sizeof(timer_page));\n\t\ti += sizeof(timer_page);\n\t\tbreak;\n\n\t   case 0x3F:\n\t\tmemcpy(ptr + i, timer_page, sizeof(timer_page));\n\t\ti += sizeof(timer_page);\n\t\tmemcpy(ptr + i, rbac_page, sizeof(rbac_page));\n\t\ti += sizeof(rbac_page);\n\t\tmemcpy(ptr + i, cache_page, sizeof(cache_page));\n\t\ti += sizeof(cache_page);\n\t\tmemcpy(ptr + i, rw_err_page, sizeof(rw_err_page));\n\t\ti += sizeof(rw_err_page);\n\t\tbreak;\n\t}\n\n\tif (sense_6)\n\t\tptr[0] = i - 1;\n\telse\n\t\t((__be16 *) ptr)[0] = cpu_to_be16(i - 2);\n\tusb_stor_set_xfer_buf(ptr, i, srb);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n\nstatic void jumpshot_info_destructor(void *extra)\n{\n\t\n\t\n}\n\n\n\n\n\nstatic int jumpshot_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstruct jumpshot_info *info;\n\tint rc;\n\tunsigned long block, blocks;\n\tunsigned char *ptr = us->iobuf;\n\tstatic unsigned char inquiry_response[8] = {\n\t\t0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\n\t};\n\n\tif (!us->extra) {\n\t\tus->extra = kzalloc(sizeof(struct jumpshot_info), GFP_NOIO);\n\t\tif (!us->extra)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tus->extra_destructor = jumpshot_info_destructor;\n\t}\n\n\tinfo = (struct jumpshot_info *) (us->extra);\n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tusb_stor_dbg(us, \"INQUIRY - Returning bogus response\\n\");\n\t\tmemcpy(ptr, inquiry_response, sizeof(inquiry_response));\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\t\tinfo->ssize = 0x200;  \n\n\t\trc = jumpshot_get_status(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\trc = jumpshot_id_device(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tusb_stor_dbg(us, \"READ_CAPACITY:  %ld sectors, %ld bytes per sector\\n\",\n\t\t\t     info->sectors, info->ssize);\n\n\t\t\n\t\t\n\t\t((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SELECT_10) {\n\t\tusb_stor_dbg(us, \"Gah! MODE_SELECT_10\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (srb->cmnd[0] == READ_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"READ_10: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn jumpshot_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == READ_12) {\n\t\t\n\t\t\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t\t ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"READ_12: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn jumpshot_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"WRITE_10: write block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn jumpshot_write_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_12) {\n\t\t\n\t\t\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t\t ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"WRITE_12: write block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn jumpshot_write_data(us, info, block, blocks);\n\t}\n\n\n\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\tusb_stor_dbg(us, \"TEST_UNIT_READY\\n\");\n\t\treturn jumpshot_get_status(us);\n\t}\n\n\tif (srb->cmnd[0] == REQUEST_SENSE) {\n\t\tusb_stor_dbg(us, \"REQUEST_SENSE\\n\");\n\n\t\tmemset(ptr, 0, 18);\n\t\tptr[0] = 0xF0;\n\t\tptr[2] = info->sense_key;\n\t\tptr[7] = 11;\n\t\tptr[12] = info->sense_asc;\n\t\tptr[13] = info->sense_ascq;\n\t\tusb_stor_set_xfer_buf(ptr, 18, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE) {\n\t\tusb_stor_dbg(us, \"MODE_SENSE_6 detected\\n\");\n\t\treturn jumpshot_handle_mode_sense(us, srb, 1);\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE_10) {\n\t\tusb_stor_dbg(us, \"MODE_SENSE_10 detected\\n\");\n\t\treturn jumpshot_handle_mode_sense(us, srb, 0);\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\t\t \n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == START_STOP) {\n\t\t \n\t\tusb_stor_dbg(us, \"START_STOP\\n\");\n\t\t \n\t\trc = jumpshot_id_device(us, info);\n\t\tif (rc == USB_STOR_TRANSPORT_GOOD) {\n\t\t\tinfo->sense_key = NO_SENSE;\n\t\t\tsrb->result = SUCCESS;\n\t\t} else {\n\t\t\tinfo->sense_key = UNIT_ATTENTION;\n\t\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\t}\n\t\treturn rc;\n\t}\n\n\tusb_stor_dbg(us, \"Gah! Unknown command: %d (0x%x)\\n\",\n\t\t     srb->cmnd[0], srb->cmnd[0]);\n\tinfo->sense_key = 0x05;\n\tinfo->sense_asc = 0x20;\n\tinfo->sense_ascq = 0x00;\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\nstatic struct scsi_host_template jumpshot_host_template;\n\nstatic int jumpshot_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - jumpshot_usb_ids) + jumpshot_unusual_dev_list,\n\t\t\t&jumpshot_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name  = \"Lexar Jumpshot Control/Bulk\";\n\tus->transport = jumpshot_transport;\n\tus->transport_reset = usb_stor_Bulk_reset;\n\tus->max_lun = 1;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver jumpshot_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tjumpshot_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tjumpshot_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(jumpshot_driver, jumpshot_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}