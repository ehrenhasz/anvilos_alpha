{
  "module_name": "freecom.c",
  "hash_id": "c7e25bf6c4b3ebf1d32415f49d25bb6a60d4d1ed1347dfac9c35575ab1c5ca4a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/freecom.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-freecom\"\n\nMODULE_DESCRIPTION(\"Driver for Freecom USB/IDE adaptor\");\nMODULE_AUTHOR(\"David Brown <usb-storage@davidb.org>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n#ifdef CONFIG_USB_STORAGE_DEBUG\nstatic void pdump(struct us_data *us, void *ibuffer, int length);\n#endif\n\n \n#define ERR_STAT\t\t0x01\n#define DRQ_STAT\t\t0x08\n\n \nstruct freecom_cb_wrap {\n\tu8    Type;\t\t \n\tu8    Timeout;\t\t \n\tu8    Atapi[12];\t \n\tu8    Filler[50];\t \n};\n\nstruct freecom_xfer_wrap {\n\tu8    Type;\t\t \n\tu8    Timeout;\t\t \n\t__le32   Count;\t\t \n\tu8    Pad[58];\n} __attribute__ ((packed));\n\nstruct freecom_ide_out {\n\tu8    Type;\t\t \n\tu8    Pad;\n\t__le16   Value;\t\t \n\tu8    Pad2[60];\n};\n\nstruct freecom_ide_in {\n\tu8    Type;\t\t \n\tu8    Pad[63];\n};\n\nstruct freecom_status {\n\tu8    Status;\n\tu8    Reason;\n\t__le16   Count;\n\tu8    Pad[60];\n};\n\n \n#define FCM_INT_STATUS\t\t0x02  \n#define FCM_STATUS_BUSY\t\t0x80\n\n \n#define FCM_PACKET_ATAPI\t0x21\n#define FCM_PACKET_STATUS\t0x20\n\n \n#define FCM_PACKET_INPUT\t0x81\n\n \n#define FCM_PACKET_OUTPUT\t0x01\n\n \n#define FCM_PACKET_IDE_WRITE\t0x40\n#define FCM_PACKET_IDE_READ\t0xC0\n\n \n#define FCM_PACKET_LENGTH\t\t64\n#define FCM_STATUS_PACKET_LENGTH\t4\n\nstatic int init_freecom(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id freecom_usb_ids[] = {\n#\tinclude \"unusual_freecom.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, freecom_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev freecom_unusual_dev_list[] = {\n#\tinclude \"unusual_freecom.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\nstatic int\nfreecom_readdata (struct scsi_cmnd *srb, struct us_data *us,\n\t\tunsigned int ipipe, unsigned int opipe, int count)\n{\n\tstruct freecom_xfer_wrap *fxfr =\n\t\t(struct freecom_xfer_wrap *) us->iobuf;\n\tint result;\n\n\tfxfr->Type = FCM_PACKET_INPUT | 0x00;\n\tfxfr->Timeout = 0;     \n\tfxfr->Count = cpu_to_le32 (count);\n\tmemset (fxfr->Pad, 0, sizeof (fxfr->Pad));\n\n\tusb_stor_dbg(us, \"Read data Freecom! (c=%d)\\n\", count);\n\n\t \n\tresult = usb_stor_bulk_transfer_buf (us, opipe, fxfr,\n\t\t\tFCM_PACKET_LENGTH, NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Freecom readdata transport error\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tusb_stor_dbg(us, \"Start of read\\n\");\n\tresult = usb_stor_bulk_srb(us, ipipe, srb);\n\tusb_stor_dbg(us, \"freecom_readdata done!\\n\");\n\n\tif (result > USB_STOR_XFER_SHORT)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int\nfreecom_writedata (struct scsi_cmnd *srb, struct us_data *us,\n\t\tint unsigned ipipe, unsigned int opipe, int count)\n{\n\tstruct freecom_xfer_wrap *fxfr =\n\t\t(struct freecom_xfer_wrap *) us->iobuf;\n\tint result;\n\n\tfxfr->Type = FCM_PACKET_OUTPUT | 0x00;\n\tfxfr->Timeout = 0;     \n\tfxfr->Count = cpu_to_le32 (count);\n\tmemset (fxfr->Pad, 0, sizeof (fxfr->Pad));\n\n\tusb_stor_dbg(us, \"Write data Freecom! (c=%d)\\n\", count);\n\n\t \n\tresult = usb_stor_bulk_transfer_buf (us, opipe, fxfr,\n\t\t\tFCM_PACKET_LENGTH, NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Freecom writedata transport error\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tusb_stor_dbg(us, \"Start of write\\n\");\n\tresult = usb_stor_bulk_srb(us, opipe, srb);\n\n\tusb_stor_dbg(us, \"freecom_writedata done!\\n\");\n\tif (result > USB_STOR_XFER_SHORT)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int freecom_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstruct freecom_cb_wrap *fcb;\n\tstruct freecom_status  *fst;\n\tunsigned int ipipe, opipe;\t\t \n\tint result;\n\tunsigned int partial;\n\tint length;\n\n\tfcb = (struct freecom_cb_wrap *) us->iobuf;\n\tfst = (struct freecom_status *) us->iobuf;\n\n\tusb_stor_dbg(us, \"Freecom TRANSPORT STARTED\\n\");\n\n\t \n\topipe = us->send_bulk_pipe;\n\tipipe = us->recv_bulk_pipe;\n\n\t \n\tfcb->Type = FCM_PACKET_ATAPI | 0x00;\n\tfcb->Timeout = 0;\n\tmemcpy (fcb->Atapi, srb->cmnd, 12);\n\tmemset (fcb->Filler, 0, sizeof (fcb->Filler));\n\n\tUS_DEBUG(pdump(us, srb->cmnd, 12));\n\n\t \n\tresult = usb_stor_bulk_transfer_buf (us, opipe, fcb,\n\t\t\tFCM_PACKET_LENGTH, NULL);\n\n\t \n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"freecom transport error\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\n\t\t\tFCM_STATUS_PACKET_LENGTH, &partial);\n\tusb_stor_dbg(us, \"foo Status result %d %u\\n\", result, partial);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tUS_DEBUG(pdump(us, (void *)fst, partial));\n\n\t \n\twhile (fst->Status & FCM_STATUS_BUSY) {\n\t\tusb_stor_dbg(us, \"20 second USB/ATAPI bridge TIMEOUT occurred!\\n\");\n\t\tusb_stor_dbg(us, \"fst->Status is %x\\n\", fst->Status);\n\n\t\t \n\t\tfcb->Type = FCM_PACKET_STATUS;\n\t\tfcb->Timeout = 0;\n\t\tmemset (fcb->Atapi, 0, sizeof(fcb->Atapi));\n\t\tmemset (fcb->Filler, 0, sizeof (fcb->Filler));\n\n\t\t \n\t\tresult = usb_stor_bulk_transfer_buf (us, opipe, fcb,\n\t\t\t\tFCM_PACKET_LENGTH, NULL);\n\n\t\t \n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"freecom transport error\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\n\t\t \n\t\tresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\n\t\t\t\tFCM_STATUS_PACKET_LENGTH, &partial);\n\n\t\tusb_stor_dbg(us, \"bar Status result %d %u\\n\", result, partial);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tUS_DEBUG(pdump(us, (void *)fst, partial));\n\t}\n\n\tif (partial != 4)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\tif ((fst->Status & 1) != 0) {\n\t\tusb_stor_dbg(us, \"operation failed\\n\");\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\t \n\tusb_stor_dbg(us, \"Device indicates that it has %d bytes available\\n\",\n\t\t     le16_to_cpu(fst->Count));\n\tusb_stor_dbg(us, \"SCSI requested %d\\n\", scsi_bufflen(srb));\n\n\t \n\tswitch (srb->cmnd[0]) {\n\tcase INQUIRY:\n\tcase REQUEST_SENSE:\t \n\tcase MODE_SENSE:\n\tcase MODE_SENSE_10:\n\t\tlength = le16_to_cpu(fst->Count);\n\t\tbreak;\n\tdefault:\n\t\tlength = scsi_bufflen(srb);\n\t}\n\n\t \n\tif (length > scsi_bufflen(srb)) {\n\t\tlength = scsi_bufflen(srb);\n\t\tusb_stor_dbg(us, \"Truncating request to match buffer length: %d\\n\",\n\t\t\t     length);\n\t}\n\n\t \n\n\tswitch (us->srb->sc_data_direction) {\n\tcase DMA_FROM_DEVICE:\n\t\t \n\t\tif (!length)\n\t\t\tbreak;\n\t\t \n\t\tif ((fst->Status & DRQ_STAT) == 0 || (fst->Reason & 3) != 2) {\n\t\t\tusb_stor_dbg(us, \"SCSI wants data, drive doesn't have any\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t\tresult = freecom_readdata (srb, us, ipipe, opipe, length);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn result;\n\n\t\tusb_stor_dbg(us, \"Waiting for status\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\n\t\t\t\tFCM_PACKET_LENGTH, &partial);\n\t\tUS_DEBUG(pdump(us, (void *)fst, partial));\n\n\t\tif (partial != 4 || result > USB_STOR_XFER_SHORT)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\tif ((fst->Status & ERR_STAT) != 0) {\n\t\t\tusb_stor_dbg(us, \"operation failed\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t\tif ((fst->Reason & 3) != 3) {\n\t\t\tusb_stor_dbg(us, \"Drive seems still hungry\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t\tusb_stor_dbg(us, \"Transfer happy\\n\");\n\t\tbreak;\n\n\tcase DMA_TO_DEVICE:\n\t\t \n\t\tif (!length)\n\t\t\tbreak;\n\t\t \n\t\t \n\t\tresult = freecom_writedata (srb, us, ipipe, opipe, length);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn result;\n\n\t\tusb_stor_dbg(us, \"Waiting for status\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf (us, ipipe, fst,\n\t\t\t\tFCM_PACKET_LENGTH, &partial);\n\n\t\tif (partial != 4 || result > USB_STOR_XFER_SHORT)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\tif ((fst->Status & ERR_STAT) != 0) {\n\t\t\tusb_stor_dbg(us, \"operation failed\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t\tif ((fst->Reason & 3) != 3) {\n\t\t\tusb_stor_dbg(us, \"Drive seems still hungry\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\n\t\tusb_stor_dbg(us, \"Transfer happy\\n\");\n\t\tbreak;\n\n\n\tcase DMA_NONE:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tusb_stor_dbg(us, \"freecom unimplemented direction: %d\\n\",\n\t\t\t     us->srb->sc_data_direction);\n\t\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int init_freecom(struct us_data *us)\n{\n\tint result;\n\tchar *buffer = us->iobuf;\n\n\t \n\n\tresult = usb_stor_control_msg(us, us->recv_ctrl_pipe,\n\t\t\t0x4c, 0xc0, 0x4346, 0x0, buffer, 0x20, 3*HZ);\n\tbuffer[32] = '\\0';\n\tusb_stor_dbg(us, \"String returned from FC init is: %s\\n\", buffer);\n\n\t \n\n\t \n\tresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\n\t\t\t0x4d, 0x40, 0x24d8, 0x0, NULL, 0x0, 3*HZ);\n\tusb_stor_dbg(us, \"result from activate reset is %d\\n\", result);\n\n\t \n\tmsleep(250);\n\n\t \n\tresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\n\t\t\t0x4d, 0x40, 0x24f8, 0x0, NULL, 0x0, 3*HZ);\n\tusb_stor_dbg(us, \"result from clear reset is %d\\n\", result);\n\n\t \n\tmsleep(3 * 1000);\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\nstatic int usb_stor_freecom_reset(struct us_data *us)\n{\n\tprintk (KERN_CRIT \"freecom reset called\\n\");\n\n\t \n\treturn FAILED;\n}\n\n#ifdef CONFIG_USB_STORAGE_DEBUG\nstatic void pdump(struct us_data *us, void *ibuffer, int length)\n{\n\tstatic char line[80];\n\tint offset = 0;\n\tunsigned char *buffer = (unsigned char *) ibuffer;\n\tint i, j;\n\tint from, base;\n\n\toffset = 0;\n\tfor (i = 0; i < length; i++) {\n\t\tif ((i & 15) == 0) {\n\t\t\tif (i > 0) {\n\t\t\t\toffset += sprintf (line+offset, \" - \");\n\t\t\t\tfor (j = i - 16; j < i; j++) {\n\t\t\t\t\tif (buffer[j] >= 32 && buffer[j] <= 126)\n\t\t\t\t\t\tline[offset++] = buffer[j];\n\t\t\t\t\telse\n\t\t\t\t\t\tline[offset++] = '.';\n\t\t\t\t}\n\t\t\t\tline[offset] = 0;\n\t\t\t\tusb_stor_dbg(us, \"%s\\n\", line);\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t\toffset += sprintf (line+offset, \"%08x:\", i);\n\t\t} else if ((i & 7) == 0) {\n\t\t\toffset += sprintf (line+offset, \" -\");\n\t\t}\n\t\toffset += sprintf (line+offset, \" %02x\", buffer[i] & 0xff);\n\t}\n\n\t \n\tfrom = (length - 1) % 16;\n\tbase = ((length - 1) / 16) * 16;\n\n\tfor (i = from + 1; i < 16; i++)\n\t\toffset += sprintf (line+offset, \"   \");\n\tif (from < 8)\n\t\toffset += sprintf (line+offset, \"  \");\n\toffset += sprintf (line+offset, \" - \");\n\n\tfor (i = 0; i <= from; i++) {\n\t\tif (buffer[base+i] >= 32 && buffer[base+i] <= 126)\n\t\t\tline[offset++] = buffer[base+i];\n\t\telse\n\t\t\tline[offset++] = '.';\n\t}\n\tline[offset] = 0;\n\tusb_stor_dbg(us, \"%s\\n\", line);\n\toffset = 0;\n}\n#endif\n\nstatic struct scsi_host_template freecom_host_template;\n\nstatic int freecom_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - freecom_usb_ids) + freecom_unusual_dev_list,\n\t\t\t&freecom_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name = \"Freecom\";\n\tus->transport = freecom_transport;\n\tus->transport_reset = usb_stor_freecom_reset;\n\tus->max_lun = 0;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver freecom_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tfreecom_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tfreecom_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(freecom_driver, freecom_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}