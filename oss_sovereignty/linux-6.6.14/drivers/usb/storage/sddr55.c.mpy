{
  "module_name": "sddr55.c",
  "hash_id": "45897423aa8ce97a0a2255adca5254ef592fae38f4ea708a1432405a04aac108",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/sddr55.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-sddr55\"\n\nMODULE_DESCRIPTION(\"Driver for SanDisk SDDR-55 SmartMedia reader\");\nMODULE_AUTHOR(\"Simon Munton\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id sddr55_usb_ids[] = {\n#\tinclude \"unusual_sddr55.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, sddr55_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev sddr55_unusual_dev_list[] = {\n#\tinclude \"unusual_sddr55.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n\n#define short_pack(lsb,msb) ( ((u16)(lsb)) | ( ((u16)(msb))<<8 ) )\n#define LSB_of(s) ((s)&0xFF)\n#define MSB_of(s) ((s)>>8)\n#define PAGESIZE  512\n\n#define set_sense_info(sk, asc, ascq)\t\\\n    do {\t\t\t\t\\\n\tinfo->sense_data[2] = sk;\t\\\n\tinfo->sense_data[12] = asc;\t\\\n\tinfo->sense_data[13] = ascq;\t\\\n\t} while (0)\n\n\nstruct sddr55_card_info {\n\tunsigned long\tcapacity;\t \n\tint\t\tmax_log_blks;\t \n\tint\t\tpageshift;\t \n\tint\t\tsmallpageshift;\t \n\tint\t\tblocksize;\t \n\tint\t\tblockshift;\t \n\tint\t\tblockmask;\t \n\tint\t\tread_only;\t \n\tint\t\tforce_read_only;\t \n\tint\t\t*lba_to_pba;\t \n\tint\t\t*pba_to_lba;\t \n\tint\t\tfatal_error;\t \n\tunsigned long \tlast_access;\t \n\tunsigned char   sense_data[18];\n};\n\n\n#define NOT_ALLOCATED\t\t0xffffffff\n#define BAD_BLOCK\t\t0xffff\n#define CIS_BLOCK\t\t0x400\n#define UNUSED_BLOCK\t\t0x3ff\n\nstatic int\nsddr55_bulk_transport(struct us_data *us, int direction,\n\t\t      unsigned char *data, unsigned int len) {\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\tunsigned int pipe = (direction == DMA_FROM_DEVICE) ?\n\t\t\tus->recv_bulk_pipe : us->send_bulk_pipe;\n\n\tif (!len)\n\t\treturn USB_STOR_XFER_GOOD;\n\tinfo->last_access = jiffies;\n\treturn usb_stor_bulk_transfer_buf(us, pipe, data, len, NULL);\n}\n\n \n\nstatic int sddr55_status(struct us_data *us)\n{\n\tint result;\n\tunsigned char *command = us->iobuf;\n\tunsigned char *status = us->iobuf;\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\n\t \n\tmemset(command, 0, 8);\n\tcommand[5] = 0xB0;\n\tcommand[7] = 0x80;\n\tresult = sddr55_bulk_transport(us,\n\t\tDMA_TO_DEVICE, command, 8);\n\n\tusb_stor_dbg(us, \"Result for send_command in status %d\\n\", result);\n\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tset_sense_info (4, 0, 0);\t \n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tresult = sddr55_bulk_transport(us,\n\t\tDMA_FROM_DEVICE, status,\t4);\n\n\t \n\tif (result == USB_STOR_XFER_SHORT || result == USB_STOR_XFER_STALLED) {\n\t\t \n\t\tkfree(info->lba_to_pba);\n\t\tkfree(info->pba_to_lba);\n\t\tinfo->lba_to_pba = NULL;\n\t\tinfo->pba_to_lba = NULL;\n\n\t\tinfo->fatal_error = 0;\n\t\tinfo->force_read_only = 0;\n\n\t\tset_sense_info (2, 0x3a, 0);\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tset_sense_info (4, 0, 0);\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\t\n\t \n\tinfo->read_only = (status[0] & 0x20);\n\n\t \n\tresult = sddr55_bulk_transport(us,\n\t\tDMA_FROM_DEVICE, status,\t2);\n\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tset_sense_info (4, 0, 0);\t \n\t}\n\n\treturn (result == USB_STOR_XFER_GOOD ?\n\t\t\tUSB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_FAILED);\n}\n\n\nstatic int sddr55_read_data(struct us_data *us,\n\t\tunsigned int lba,\n\t\tunsigned int page,\n\t\tunsigned short sectors) {\n\n\tint result = USB_STOR_TRANSPORT_GOOD;\n\tunsigned char *command = us->iobuf;\n\tunsigned char *status = us->iobuf;\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\tunsigned char *buffer;\n\n\tunsigned int pba;\n\tunsigned long address;\n\n\tunsigned short pages;\n\tunsigned int len, offset;\n\tstruct scatterlist *sg;\n\n\t\n\t\n\t\n\n\tlen = min((unsigned int) sectors, (unsigned int) info->blocksize >>\n\t\t\tinfo->smallpageshift) * PAGESIZE;\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;  \n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors>0) {\n\n\t\t \n\t\tif (lba >= info->max_log_blks)\n\t\t\tbreak;\n\n\t\tpba = info->lba_to_pba[lba];\n\n\t\t\n\n\t\tpages = min((unsigned int) sectors << info->smallpageshift,\n\t\t\t\tinfo->blocksize - page);\n\t\tlen = pages << info->pageshift;\n\n\t\tusb_stor_dbg(us, \"Read %02X pages, from PBA %04X (LBA %04X) page %02X\\n\",\n\t\t\t     pages, pba, lba, page);\n\n\t\tif (pba == NOT_ALLOCATED) {\n\t\t\t \n\t\t\tmemset (buffer, 0, len);\n\t\t} else {\n\n\t\t\taddress = (pba << info->blockshift) + page;\n\n\t\t\tcommand[0] = 0;\n\t\t\tcommand[1] = LSB_of(address>>16);\n\t\t\tcommand[2] = LSB_of(address>>8);\n\t\t\tcommand[3] = LSB_of(address);\n\n\t\t\tcommand[4] = 0;\n\t\t\tcommand[5] = 0xB0;\n\t\t\tcommand[6] = LSB_of(pages << (1 - info->smallpageshift));\n\t\t\tcommand[7] = 0x85;\n\n\t\t\t \n\t\t\tresult = sddr55_bulk_transport(us,\n\t\t\t\tDMA_TO_DEVICE, command, 8);\n\n\t\t\tusb_stor_dbg(us, \"Result for send_command in read_data %d\\n\",\n\t\t\t\t     result);\n\n\t\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\t\tgoto leave;\n\t\t\t}\n\n\t\t\t \n\t\t\tresult = sddr55_bulk_transport(us,\n\t\t\t\tDMA_FROM_DEVICE, buffer, len);\n\n\t\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\t\tgoto leave;\n\t\t\t}\n\n\t\t\t \n\t\t\tresult = sddr55_bulk_transport(us,\n\t\t\t\tDMA_FROM_DEVICE, status, 2);\n\n\t\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\t\tresult = USB_STOR_TRANSPORT_ERROR;\n\t\t\t\tgoto leave;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status[0] == 0xff && status[1] == 0x4) {\n\t\t\t\tset_sense_info (3, 0x11, 0);\n\t\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\t\tgoto leave;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, TO_XFER_BUF);\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages >> info->smallpageshift;\n\t}\n\n\tresult = USB_STOR_TRANSPORT_GOOD;\n\nleave:\n\tkfree(buffer);\n\n\treturn result;\n}\n\nstatic int sddr55_write_data(struct us_data *us,\n\t\tunsigned int lba,\n\t\tunsigned int page,\n\t\tunsigned short sectors) {\n\n\tint result = USB_STOR_TRANSPORT_GOOD;\n\tunsigned char *command = us->iobuf;\n\tunsigned char *status = us->iobuf;\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\tunsigned char *buffer;\n\n\tunsigned int pba;\n\tunsigned int new_pba;\n\tunsigned long address;\n\n\tunsigned short pages;\n\tint i;\n\tunsigned int len, offset;\n\tstruct scatterlist *sg;\n\n\t \n\tif (info->read_only || info->force_read_only) {\n\t\tset_sense_info (7, 0x27, 0);\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\t\n\t\n\t\n\n\tlen = min((unsigned int) sectors, (unsigned int) info->blocksize >>\n\t\t\tinfo->smallpageshift) * PAGESIZE;\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\toffset = 0;\n\tsg = NULL;\n\n\twhile (sectors > 0) {\n\n\t\t \n\t\tif (lba >= info->max_log_blks)\n\t\t\tbreak;\n\n\t\tpba = info->lba_to_pba[lba];\n\n\t\t\n\n\t\tpages = min((unsigned int) sectors << info->smallpageshift,\n\t\t\t\tinfo->blocksize - page);\n\t\tlen = pages << info->pageshift;\n\n\t\t\n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t&sg, &offset, FROM_XFER_BUF);\n\n\t\tusb_stor_dbg(us, \"Write %02X pages, to PBA %04X (LBA %04X) page %02X\\n\",\n\t\t\t     pages, pba, lba, page);\n\t\t\t\n\t\tcommand[4] = 0;\n\n\t\tif (pba == NOT_ALLOCATED) {\n\t\t\t \n\n\t\t\tint max_pba = (info->max_log_blks / 250 ) * 256;\n\t\t\tint found_count = 0;\n\t\t\tint found_pba = -1;\n\n\t\t\t \n\t\t\tpba = (lba / 1000) * 1024;\n\n\t\t\tusb_stor_dbg(us, \"No PBA for LBA %04X\\n\", lba);\n\n\t\t\tif (max_pba > 1024)\n\t\t\t\tmax_pba = 1024;\n\n\t\t\t \n\t\t\tfor (i = 0; i < max_pba; i++, pba++) {\n\t\t\t\tif (info->pba_to_lba[pba] == UNUSED_BLOCK) {\n\t\t\t\t\tfound_pba = pba;\n\t\t\t\t\tif (found_count++ > 16)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpba = found_pba;\n\n\t\t\tif (pba == -1) {\n\t\t\t\t \n\t\t\t\tusb_stor_dbg(us, \"Couldn't find unallocated block\\n\");\n\n\t\t\t\tset_sense_info (3, 0x31, 0);\t \n\t\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\t\tgoto leave;\n\t\t\t}\n\n\t\t\tusb_stor_dbg(us, \"Allocating PBA %04X for LBA %04X\\n\",\n\t\t\t\t     pba, lba);\n\n\t\t\t \n\t\t\tcommand[4] = 0x40;\n\t\t}\n\n\t\taddress = (pba << info->blockshift) + page;\n\n\t\tcommand[1] = LSB_of(address>>16);\n\t\tcommand[2] = LSB_of(address>>8); \n\t\tcommand[3] = LSB_of(address);\n\n\t\t \n\t\tcommand[0] = LSB_of(lba % 1000);\n\t\tcommand[6] = MSB_of(lba % 1000);\n\n\t\tcommand[4] |= LSB_of(pages >> info->smallpageshift);\n\t\tcommand[5] = 0xB0;\n\t\tcommand[7] = 0x86;\n\n\t\t \n\t\tresult = sddr55_bulk_transport(us,\n\t\t\tDMA_TO_DEVICE, command, 8);\n\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"Result for send_command in write_data %d\\n\",\n\t\t\t\t     result);\n\n\t\t\t \n\t\t\tset_sense_info (3, 0x3, 0); \n\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t \n\t\tresult = sddr55_bulk_transport(us,\n\t\t\tDMA_TO_DEVICE, buffer, len);\n\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"Result for send_data in write_data %d\\n\",\n\t\t\t\t     result);\n\n\t\t\t \n\t\t\tset_sense_info (3, 0x3, 0); \n\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t \n\t\tresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, status, 6);\n\n\t\tif (result != USB_STOR_XFER_GOOD) {\n\t\t\tusb_stor_dbg(us, \"Result for get_status in write_data %d\\n\",\n\t\t\t\t     result);\n\n\t\t\t \n\t\t\tset_sense_info (3, 0x3, 0); \n\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\tgoto leave;\n\t\t}\n\n\t\tnew_pba = (status[3] + (status[4] << 8) + (status[5] << 16))\n\t\t\t\t\t\t  >> info->blockshift;\n\n\t\t \n\t\tif (status[0] == 0xff && status[1] == 0x4) {\n\t\t\tinfo->pba_to_lba[new_pba] = BAD_BLOCK;\n\n\t\t\tset_sense_info (3, 0x0c, 0);\n\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\tgoto leave;\n\t\t}\n\n\t\tusb_stor_dbg(us, \"Updating maps for LBA %04X: old PBA %04X, new PBA %04X\\n\",\n\t\t\t     lba, pba, new_pba);\n\n\t\t \n\t\tinfo->lba_to_pba[lba] = new_pba;\n\t\tinfo->pba_to_lba[pba] = UNUSED_BLOCK;\n\n\t\t \n\t\tif (info->pba_to_lba[new_pba] != UNUSED_BLOCK) {\n\t\t\tprintk(KERN_ERR \"sddr55 error: new PBA %04X already in use for LBA %04X\\n\",\n\t\t\t\tnew_pba, info->pba_to_lba[new_pba]);\n\t\t\tinfo->fatal_error = 1;\n\t\t\tset_sense_info (3, 0x31, 0);\n\t\t\tresult = USB_STOR_TRANSPORT_FAILED;\n\t\t\tgoto leave;\n\t\t}\n\n\t\t \n\t\tinfo->pba_to_lba[new_pba] = lba % 1000;\n\n\t\tpage = 0;\n\t\tlba++;\n\t\tsectors -= pages >> info->smallpageshift;\n\t}\n\tresult = USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int sddr55_read_deviceID(struct us_data *us,\n\t\tunsigned char *manufacturerID,\n\t\tunsigned char *deviceID) {\n\n\tint result;\n\tunsigned char *command = us->iobuf;\n\tunsigned char *content = us->iobuf;\n\n\tmemset(command, 0, 8);\n\tcommand[5] = 0xB0;\n\tcommand[7] = 0x84;\n\tresult = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);\n\n\tusb_stor_dbg(us, \"Result of send_control for device ID is %d\\n\",\n\t\t     result);\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tresult = sddr55_bulk_transport(us,\n\t\tDMA_FROM_DEVICE, content, 4);\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t*manufacturerID = content[0];\n\t*deviceID = content[1];\n\n\tif (content[0] != 0xff)\t{\n    \t\tresult = sddr55_bulk_transport(us,\n\t\t\tDMA_FROM_DEVICE, content, 2);\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n\nstatic int sddr55_reset(struct us_data *us)\n{\n\treturn 0;\n}\n\n\nstatic unsigned long sddr55_get_capacity(struct us_data *us) {\n\n\tunsigned char manufacturerID;\n\tunsigned char deviceID;\n\tint result;\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)us->extra;\n\n\tusb_stor_dbg(us, \"Reading capacity...\\n\");\n\n\tresult = sddr55_read_deviceID(us,\n\t\t&manufacturerID,\n\t\t&deviceID);\n\n\tusb_stor_dbg(us, \"Result of read_deviceID is %d\\n\", result);\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn 0;\n\n\tusb_stor_dbg(us, \"Device ID = %02X\\n\", deviceID);\n\tusb_stor_dbg(us, \"Manuf  ID = %02X\\n\", manufacturerID);\n\n\tinfo->pageshift = 9;\n\tinfo->smallpageshift = 0;\n\tinfo->blocksize = 16;\n\tinfo->blockshift = 4;\n\tinfo->blockmask = 15;\n\n\tswitch (deviceID) {\n\n\tcase 0x6e:  \n\tcase 0xe8:\n\tcase 0xec:\n\t\tinfo->pageshift = 8;\n\t\tinfo->smallpageshift = 1;\n\t\treturn 0x00100000;\n\n\tcase 0xea:  \n\tcase 0x64:\n\t\tinfo->pageshift = 8;\n\t\tinfo->smallpageshift = 1;\n\t\tfallthrough;\n\tcase 0x5d:  \n\t\treturn 0x00200000;\n\n\tcase 0xe3:  \n\tcase 0xe5:\n\tcase 0x6b:\n\tcase 0xd5:\n\t\treturn 0x00400000;\n\n\tcase 0xe6:  \n\tcase 0xd6:\n\t\treturn 0x00800000;\n\n\tcase 0x73:  \n\t\tinfo->blocksize = 32;\n\t\tinfo->blockshift = 5;\n\t\tinfo->blockmask = 31;\n\t\treturn 0x01000000;\n\n\tcase 0x75:  \n\t\tinfo->blocksize = 32;\n\t\tinfo->blockshift = 5;\n\t\tinfo->blockmask = 31;\n\t\treturn 0x02000000;\n\n\tcase 0x76:  \n\t\tinfo->blocksize = 32;\n\t\tinfo->blockshift = 5;\n\t\tinfo->blockmask = 31;\n\t\treturn 0x04000000;\n\n\tcase 0x79:  \n\t\tinfo->blocksize = 32;\n\t\tinfo->blockshift = 5;\n\t\tinfo->blockmask = 31;\n\t\treturn 0x08000000;\n\n\tdefault:  \n\t\treturn 0;\n\n\t}\n}\n\nstatic int sddr55_read_map(struct us_data *us) {\n\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)(us->extra);\n\tint numblocks;\n\tunsigned char *buffer;\n\tunsigned char *command = us->iobuf;\n\tint i;\n\tunsigned short lba;\n\tunsigned short max_lba;\n\tint result;\n\n\tif (!info->capacity)\n\t\treturn -1;\n\n\tnumblocks = info->capacity >> (info->blockshift + info->pageshift);\n\t\n\tbuffer = kmalloc_array(numblocks, 2, GFP_NOIO );\n\t\n\tif (!buffer)\n\t\treturn -1;\n\n\tmemset(command, 0, 8);\n\tcommand[5] = 0xB0;\n\tcommand[6] = numblocks * 2 / 256;\n\tcommand[7] = 0x8A;\n\n\tresult = sddr55_bulk_transport(us, DMA_TO_DEVICE, command, 8);\n\n\tif ( result != USB_STOR_XFER_GOOD) {\n\t\tkfree (buffer);\n\t\treturn -1;\n\t}\n\n\tresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, buffer, numblocks * 2);\n\n\tif ( result != USB_STOR_XFER_GOOD) {\n\t\tkfree (buffer);\n\t\treturn -1;\n\t}\n\n\tresult = sddr55_bulk_transport(us, DMA_FROM_DEVICE, command, 2);\n\n\tif ( result != USB_STOR_XFER_GOOD) {\n\t\tkfree (buffer);\n\t\treturn -1;\n\t}\n\n\tkfree(info->lba_to_pba);\n\tkfree(info->pba_to_lba);\n\tinfo->lba_to_pba = kmalloc_array(numblocks, sizeof(int), GFP_NOIO);\n\tinfo->pba_to_lba = kmalloc_array(numblocks, sizeof(int), GFP_NOIO);\n\n\tif (info->lba_to_pba == NULL || info->pba_to_lba == NULL) {\n\t\tkfree(info->lba_to_pba);\n\t\tkfree(info->pba_to_lba);\n\t\tinfo->lba_to_pba = NULL;\n\t\tinfo->pba_to_lba = NULL;\n\t\tkfree(buffer);\n\t\treturn -1;\n\t}\n\n\tmemset(info->lba_to_pba, 0xff, numblocks*sizeof(int));\n\tmemset(info->pba_to_lba, 0xff, numblocks*sizeof(int));\n\n\t \n\tmax_lba = info->max_log_blks;\n\tif (max_lba > 1000)\n\t\tmax_lba = 1000;\n\n\t \n\n\tfor (i=0; i<numblocks; i++) {\n\t\tint zone = i / 1024;\n\n\t\tlba = short_pack(buffer[i * 2], buffer[i * 2 + 1]);\n\n\t\t\t \n\n\t\t\t  \n\n\t\tinfo->pba_to_lba[i] = lba;\n\n\t\tif (lba >= max_lba) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif (info->lba_to_pba[lba + zone * 1000] != NOT_ALLOCATED &&\n\t\t    !info->force_read_only) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"sddr55: map inconsistency at LBA %04X\\n\",\n\t\t\t       lba + zone * 1000);\n\t\t\tinfo->force_read_only = 1;\n\t\t}\n\n\t\tif (lba<0x10 || (lba>=0x3E0 && lba<0x3EF))\n\t\t\tusb_stor_dbg(us, \"LBA %04X <-> PBA %04X\\n\", lba, i);\n\n\t\tinfo->lba_to_pba[lba + zone * 1000] = i;\n\t}\n\n\tkfree(buffer);\n\treturn 0;\n}\n\n\nstatic void sddr55_card_info_destructor(void *extra) {\n\tstruct sddr55_card_info *info = (struct sddr55_card_info *)extra;\n\n\tif (!extra)\n\t\treturn;\n\n\tkfree(info->lba_to_pba);\n\tkfree(info->pba_to_lba);\n}\n\n\n \nstatic int sddr55_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint result;\n\tstatic unsigned char inquiry_response[8] = {\n\t\t0x00, 0x80, 0x00, 0x02, 0x1F, 0x00, 0x00, 0x00\n\t};\n \t \n\tstatic unsigned char mode_page_01[20] = {\n\t\t0x0, 0x12, 0x00, 0x80, 0x0, 0x0, 0x0, 0x0,\n\t\t0x01, 0x0A,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tunsigned char *ptr = us->iobuf;\n\tunsigned long capacity;\n\tunsigned int lba;\n\tunsigned int pba;\n\tunsigned int page;\n\tunsigned short pages;\n\tstruct sddr55_card_info *info;\n\n\tif (!us->extra) {\n\t\tus->extra = kzalloc(\n\t\t\tsizeof(struct sddr55_card_info), GFP_NOIO);\n\t\tif (!us->extra)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\tus->extra_destructor = sddr55_card_info_destructor;\n\t}\n\n\tinfo = (struct sddr55_card_info *)(us->extra);\n\n\tif (srb->cmnd[0] == REQUEST_SENSE) {\n\t\tusb_stor_dbg(us, \"request sense %02x/%02x/%02x\\n\",\n\t\t\t     info->sense_data[2],\n\t\t\t     info->sense_data[12],\n\t\t\t     info->sense_data[13]);\n\n\t\tmemcpy (ptr, info->sense_data, sizeof info->sense_data);\n\t\tptr[0] = 0x70;\n\t\tptr[7] = 11;\n\t\tusb_stor_set_xfer_buf (ptr, sizeof info->sense_data, srb);\n\t\tmemset (info->sense_data, 0, sizeof info->sense_data);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tmemset (info->sense_data, 0, sizeof info->sense_data);\n\n\t \n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tmemcpy(ptr, inquiry_response, 8);\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\t \n\tif (info->lba_to_pba == NULL || time_after(jiffies, info->last_access + HZ/2)) {\n\n\t\t \n\t\tresult = sddr55_status (us);\n\t\tif (result) {\n\t\t\tresult = sddr55_status (us);\n\t\t\tif (!result) {\n\t\t\tset_sense_info (6, 0x28, 0);\t \n\t\t\t}\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t}\n\n\t \n\tif (info->fatal_error) {\n\n\t\tset_sense_info (3, 0x31, 0);\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\n\t\tcapacity = sddr55_get_capacity(us);\n\n\t\tif (!capacity) {\n\t\t\tset_sense_info (3, 0x30, 0);  \n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\n\t\tinfo->capacity = capacity;\n\n\t\t \n\t\tinfo->max_log_blks = ((info->capacity >> (info->pageshift + info->blockshift)) / 256) * 250;\n\n\t\t \n\t\tcapacity = (capacity / 256) * 250;\n\n\t\tcapacity /= PAGESIZE;\n\t\tcapacity--;\n\n\t\t((__be32 *) ptr)[0] = cpu_to_be32(capacity);\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(PAGESIZE);\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\n\t\tsddr55_read_map(us);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SENSE_10) {\n\n\t\tmemcpy(ptr, mode_page_01, sizeof mode_page_01);\n\t\tptr[3] = (info->read_only || info->force_read_only) ? 0x80 : 0;\n\t\tusb_stor_set_xfer_buf(ptr, sizeof(mode_page_01), srb);\n\n\t\tif ( (srb->cmnd[2] & 0x3F) == 0x01 ) {\n\t\t\tusb_stor_dbg(us, \"Dummy up request for mode page 1\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\t\t} else if ( (srb->cmnd[2] & 0x3F) == 0x3F ) {\n\t\t\tusb_stor_dbg(us, \"Dummy up request for all mode pages\\n\");\n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t\t}\n\n\t\tset_sense_info (5, 0x24, 0);\t \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\n\t\tusb_stor_dbg(us, \"%s medium removal. Not that I can do anything about it...\\n\",\n\t\t\t     (srb->cmnd[4]&0x03) ? \"Prevent\" : \"Allow\");\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\t}\n\n\tif (srb->cmnd[0] == READ_10 || srb->cmnd[0] == WRITE_10) {\n\n\t\tpage = short_pack(srb->cmnd[3], srb->cmnd[2]);\n\t\tpage <<= 16;\n\t\tpage |= short_pack(srb->cmnd[5], srb->cmnd[4]);\n\t\tpages = short_pack(srb->cmnd[8], srb->cmnd[7]);\n\n\t\tpage <<= info->smallpageshift;\n\n\t\t\n\n\t\tlba = page >> info->blockshift;\n\t\tpage = page & info->blockmask;\n\n\t\t\n\n\t\tif (lba >= info->max_log_blks) {\n\n\t\t\tusb_stor_dbg(us, \"Error: Requested LBA %04X exceeds maximum block %04X\\n\",\n\t\t\t\t     lba, info->max_log_blks - 1);\n\n\t\t\tset_sense_info (5, 0x24, 0);\t \n\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\n\t\tpba = info->lba_to_pba[lba];\n\n\t\tif (srb->cmnd[0] == WRITE_10) {\n\t\t\tusb_stor_dbg(us, \"WRITE_10: write block %04X (LBA %04X) page %01X pages %d\\n\",\n\t\t\t\t     pba, lba, page, pages);\n\n\t\t\treturn sddr55_write_data(us, lba, page, pages);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"READ_10: read block %04X (LBA %04X) page %01X pages %d\\n\",\n\t\t\t\t     pba, lba, page, pages);\n\n\t\t\treturn sddr55_read_data(us, lba, page, pages);\n\t\t}\n\t}\n\n\n\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == START_STOP) {\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tset_sense_info (5, 0x20, 0);\t \n\n\treturn USB_STOR_TRANSPORT_FAILED; \n}\n\nstatic struct scsi_host_template sddr55_host_template;\n\nstatic int sddr55_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - sddr55_usb_ids) + sddr55_unusual_dev_list,\n\t\t\t&sddr55_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->transport_name = \"SDDR55\";\n\tus->transport = sddr55_transport;\n\tus->transport_reset = sddr55_reset;\n\tus->max_lun = 0;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver sddr55_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tsddr55_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tsddr55_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(sddr55_driver, sddr55_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}