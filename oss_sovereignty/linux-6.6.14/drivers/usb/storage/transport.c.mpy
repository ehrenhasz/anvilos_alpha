{
  "module_name": "transport.c",
  "hash_id": "b57498fbbc540c668deeda87097e9ec5bf7b5f2e7d51d2000cacca0dc6fcdc1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/transport.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\n#include <linux/usb/quirks.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_eh.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"scsiglue.h\"\n#include \"debug.h\"\n\n#include <linux/blkdev.h>\n#include \"../../scsi/sd.h\"\n\n\n \n\n \n\n \nstatic void usb_stor_blocking_completion(struct urb *urb)\n{\n\tstruct completion *urb_done_ptr = urb->context;\n\n\tcomplete(urb_done_ptr);\n}\n\n \nstatic int usb_stor_msg_common(struct us_data *us, int timeout)\n{\n\tstruct completion urb_done;\n\tlong timeleft;\n\tint status;\n\n\t \n\tif (test_bit(US_FLIDX_ABORTING, &us->dflags))\n\t\treturn -EIO;\n\n\t \n\tinit_completion(&urb_done);\n\n\t \n\tus->current_urb->context = &urb_done;\n\tus->current_urb->transfer_flags = 0;\n\n\t \n\tif (us->current_urb->transfer_buffer == us->iobuf)\n\t\tus->current_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tus->current_urb->transfer_dma = us->iobuf_dma;\n\n\t \n\tstatus = usb_submit_urb(us->current_urb, GFP_NOIO);\n\tif (status) {\n\t\t \n\t\treturn status;\n\t}\n\n\t \n\tset_bit(US_FLIDX_URB_ACTIVE, &us->dflags);\n\n\t \n\tif (test_bit(US_FLIDX_ABORTING, &us->dflags)) {\n\n\t\t \n\t\tif (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &us->dflags)) {\n\t\t\tusb_stor_dbg(us, \"-- cancelling URB\\n\");\n\t\t\tusb_unlink_urb(us->current_urb);\n\t\t}\n\t}\n \n\t \n\ttimeleft = wait_for_completion_interruptible_timeout(\n\t\t\t&urb_done, timeout ? : MAX_SCHEDULE_TIMEOUT);\n \n\tclear_bit(US_FLIDX_URB_ACTIVE, &us->dflags);\n\n\tif (timeleft <= 0) {\n\t\tusb_stor_dbg(us, \"%s -- cancelling URB\\n\",\n\t\t\t     timeleft == 0 ? \"Timeout\" : \"Signal\");\n\t\tusb_kill_urb(us->current_urb);\n\t}\n\n\t \n\treturn us->current_urb->status;\n}\n\n \nint usb_stor_control_msg(struct us_data *us, unsigned int pipe,\n\t\t u8 request, u8 requesttype, u16 value, u16 index, \n\t\t void *data, u16 size, int timeout)\n{\n\tint status;\n\n\tusb_stor_dbg(us, \"rq=%02x rqtype=%02x value=%04x index=%02x len=%u\\n\",\n\t\t     request, requesttype, value, index, size);\n\n\t \n\tus->cr->bRequestType = requesttype;\n\tus->cr->bRequest = request;\n\tus->cr->wValue = cpu_to_le16(value);\n\tus->cr->wIndex = cpu_to_le16(index);\n\tus->cr->wLength = cpu_to_le16(size);\n\n\t \n\tusb_fill_control_urb(us->current_urb, us->pusb_dev, pipe, \n\t\t\t (unsigned char*) us->cr, data, size, \n\t\t\t usb_stor_blocking_completion, NULL);\n\tstatus = usb_stor_msg_common(us, timeout);\n\n\t \n\tif (status == 0)\n\t\tstatus = us->current_urb->actual_length;\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_stor_control_msg);\n\n \nint usb_stor_clear_halt(struct us_data *us, unsigned int pipe)\n{\n\tint result;\n\tint endp = usb_pipeendpoint(pipe);\n\n\tif (usb_pipein (pipe))\n\t\tendp |= USB_DIR_IN;\n\n\tresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\n\t\tUSB_ENDPOINT_HALT, endp,\n\t\tNULL, 0, 3*HZ);\n\n\tif (result >= 0)\n\t\tusb_reset_endpoint(us->pusb_dev, endp);\n\n\tusb_stor_dbg(us, \"result = %d\\n\", result);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_stor_clear_halt);\n\n\n \nstatic int interpret_urb_result(struct us_data *us, unsigned int pipe,\n\t\tunsigned int length, int result, unsigned int partial)\n{\n\tusb_stor_dbg(us, \"Status code %d; transferred %u/%u\\n\",\n\t\t     result, partial, length);\n\tswitch (result) {\n\n\t \n\tcase 0:\n\t\tif (partial != length) {\n\t\t\tusb_stor_dbg(us, \"-- short transfer\\n\");\n\t\t\treturn USB_STOR_XFER_SHORT;\n\t\t}\n\n\t\tusb_stor_dbg(us, \"-- transfer complete\\n\");\n\t\treturn USB_STOR_XFER_GOOD;\n\n\t \n\tcase -EPIPE:\n\t\t \n\t\tif (usb_pipecontrol(pipe)) {\n\t\t\tusb_stor_dbg(us, \"-- stall on control pipe\\n\");\n\t\t\treturn USB_STOR_XFER_STALLED;\n\t\t}\n\n\t\t \n\t\tusb_stor_dbg(us, \"clearing endpoint halt for pipe 0x%x\\n\",\n\t\t\t     pipe);\n\t\tif (usb_stor_clear_halt(us, pipe) < 0)\n\t\t\treturn USB_STOR_XFER_ERROR;\n\t\treturn USB_STOR_XFER_STALLED;\n\n\t \n\tcase -EOVERFLOW:\n\t\tusb_stor_dbg(us, \"-- babble\\n\");\n\t\treturn USB_STOR_XFER_LONG;\n\n\t \n\tcase -ECONNRESET:\n\t\tusb_stor_dbg(us, \"-- transfer cancelled\\n\");\n\t\treturn USB_STOR_XFER_ERROR;\n\n\t \n\tcase -EREMOTEIO:\n\t\tusb_stor_dbg(us, \"-- short read transfer\\n\");\n\t\treturn USB_STOR_XFER_SHORT;\n\n\t \n\tcase -EIO:\n\t\tusb_stor_dbg(us, \"-- abort or disconnect in progress\\n\");\n\t\treturn USB_STOR_XFER_ERROR;\n\n\t \n\tdefault:\n\t\tusb_stor_dbg(us, \"-- unknown error\\n\");\n\t\treturn USB_STOR_XFER_ERROR;\n\t}\n}\n\n \nint usb_stor_ctrl_transfer(struct us_data *us, unsigned int pipe,\n\t\tu8 request, u8 requesttype, u16 value, u16 index,\n\t\tvoid *data, u16 size)\n{\n\tint result;\n\n\tusb_stor_dbg(us, \"rq=%02x rqtype=%02x value=%04x index=%02x len=%u\\n\",\n\t\t     request, requesttype, value, index, size);\n\n\t \n\tus->cr->bRequestType = requesttype;\n\tus->cr->bRequest = request;\n\tus->cr->wValue = cpu_to_le16(value);\n\tus->cr->wIndex = cpu_to_le16(index);\n\tus->cr->wLength = cpu_to_le16(size);\n\n\t \n\tusb_fill_control_urb(us->current_urb, us->pusb_dev, pipe, \n\t\t\t (unsigned char*) us->cr, data, size, \n\t\t\t usb_stor_blocking_completion, NULL);\n\tresult = usb_stor_msg_common(us, 0);\n\n\treturn interpret_urb_result(us, pipe, size, result,\n\t\t\tus->current_urb->actual_length);\n}\nEXPORT_SYMBOL_GPL(usb_stor_ctrl_transfer);\n\n \nstatic int usb_stor_intr_transfer(struct us_data *us, void *buf,\n\t\t\t\t  unsigned int length)\n{\n\tint result;\n\tunsigned int pipe = us->recv_intr_pipe;\n\tunsigned int maxp;\n\n\tusb_stor_dbg(us, \"xfer %u bytes\\n\", length);\n\n\t \n\tmaxp = usb_maxpacket(us->pusb_dev, pipe);\n\tif (maxp > length)\n\t\tmaxp = length;\n\n\t \n\tusb_fill_int_urb(us->current_urb, us->pusb_dev, pipe, buf,\n\t\t\tmaxp, usb_stor_blocking_completion, NULL,\n\t\t\tus->ep_bInterval);\n\tresult = usb_stor_msg_common(us, 0);\n\n\treturn interpret_urb_result(us, pipe, length, result,\n\t\t\tus->current_urb->actual_length);\n}\n\n \nint usb_stor_bulk_transfer_buf(struct us_data *us, unsigned int pipe,\n\tvoid *buf, unsigned int length, unsigned int *act_len)\n{\n\tint result;\n\n\tusb_stor_dbg(us, \"xfer %u bytes\\n\", length);\n\n\t \n\tusb_fill_bulk_urb(us->current_urb, us->pusb_dev, pipe, buf, length,\n\t\t      usb_stor_blocking_completion, NULL);\n\tresult = usb_stor_msg_common(us, 0);\n\n\t \n\tif (act_len)\n\t\t*act_len = us->current_urb->actual_length;\n\treturn interpret_urb_result(us, pipe, length, result, \n\t\t\tus->current_urb->actual_length);\n}\nEXPORT_SYMBOL_GPL(usb_stor_bulk_transfer_buf);\n\n \nstatic int usb_stor_bulk_transfer_sglist(struct us_data *us, unsigned int pipe,\n\t\tstruct scatterlist *sg, int num_sg, unsigned int length,\n\t\tunsigned int *act_len)\n{\n\tint result;\n\n\t \n\tif (test_bit(US_FLIDX_ABORTING, &us->dflags))\n\t\tgoto usb_stor_xfer_error;\n\n\t \n\tusb_stor_dbg(us, \"xfer %u bytes, %d entries\\n\", length, num_sg);\n\tresult = usb_sg_init(&us->current_sg, us->pusb_dev, pipe, 0,\n\t\t\tsg, num_sg, length, GFP_NOIO);\n\tif (result) {\n\t\tusb_stor_dbg(us, \"usb_sg_init returned %d\\n\", result);\n\t\tgoto usb_stor_xfer_error;\n\t}\n\n\t \n\tset_bit(US_FLIDX_SG_ACTIVE, &us->dflags);\n\n\t \n\tif (test_bit(US_FLIDX_ABORTING, &us->dflags)) {\n\n\t\t \n\t\tif (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &us->dflags)) {\n\t\t\tusb_stor_dbg(us, \"-- cancelling sg request\\n\");\n\t\t\tusb_sg_cancel(&us->current_sg);\n\t\t}\n\t}\n\n\t \n\tusb_sg_wait(&us->current_sg);\n\tclear_bit(US_FLIDX_SG_ACTIVE, &us->dflags);\n\n\tresult = us->current_sg.status;\n\tif (act_len)\n\t\t*act_len = us->current_sg.bytes;\n\treturn interpret_urb_result(us, pipe, length, result,\n\t\t\tus->current_sg.bytes);\n\nusb_stor_xfer_error:\n\tif (act_len)\n\t\t*act_len = 0;\n\treturn USB_STOR_XFER_ERROR;\n}\n\n \nint usb_stor_bulk_srb(struct us_data* us, unsigned int pipe,\n\t\t      struct scsi_cmnd* srb)\n{\n\tunsigned int partial;\n\tint result = usb_stor_bulk_transfer_sglist(us, pipe, scsi_sglist(srb),\n\t\t\t\t      scsi_sg_count(srb), scsi_bufflen(srb),\n\t\t\t\t      &partial);\n\n\tscsi_set_resid(srb, scsi_bufflen(srb) - partial);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_stor_bulk_srb);\n\n \nint usb_stor_bulk_transfer_sg(struct us_data* us, unsigned int pipe,\n\t\tvoid *buf, unsigned int length_left, int use_sg, int *residual)\n{\n\tint result;\n\tunsigned int partial;\n\n\t \n\tif (use_sg) {\n\t\t \n\t\tresult = usb_stor_bulk_transfer_sglist(us, pipe,\n\t\t\t\t(struct scatterlist *) buf, use_sg,\n\t\t\t\tlength_left, &partial);\n\t\tlength_left -= partial;\n\t} else {\n\t\t \n\t\tresult = usb_stor_bulk_transfer_buf(us, pipe, buf, \n\t\t\t\tlength_left, &partial);\n\t\tlength_left -= partial;\n\t}\n\n\t \n\tif (residual)\n\t\t*residual = length_left;\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_stor_bulk_transfer_sg);\n\n \n\n \nstatic void last_sector_hacks(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct gendisk *disk;\n\tstruct scsi_disk *sdkp;\n\tu32 sector;\n\n\t \n\tstatic unsigned char record_not_found[18] = {\n\t\t[0]\t= 0x70,\t\t\t \n\t\t[2]\t= MEDIUM_ERROR,\t\t \n\t\t[7]\t= 0x0a,\t\t\t \n\t\t[12]\t= 0x14\t\t\t \n\t};\n\n\t \n\tif (!us->use_last_sector_hacks)\n\t\treturn;\n\n\t \n\tif (srb->cmnd[0] != READ_10 && srb->cmnd[0] != WRITE_10)\n\t\tgoto done;\n\n\t \n\tsector = (srb->cmnd[2] << 24) | (srb->cmnd[3] << 16) |\n\t\t\t(srb->cmnd[4] << 8) | (srb->cmnd[5]);\n\tdisk = scsi_cmd_to_rq(srb)->q->disk;\n\tif (!disk)\n\t\tgoto done;\n\tsdkp = scsi_disk(disk);\n\tif (!sdkp)\n\t\tgoto done;\n\tif (sector + 1 != sdkp->capacity)\n\t\tgoto done;\n\n\tif (srb->result == SAM_STAT_GOOD && scsi_get_resid(srb) == 0) {\n\n\t\t \n\t\tus->use_last_sector_hacks = 0;\n\n\t} else {\n\t\t \n\t\tif (++us->last_sector_retries < 3)\n\t\t\treturn;\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\tmemcpy(srb->sense_buffer, record_not_found,\n\t\t\t\tsizeof(record_not_found));\n\t}\n\n done:\n\t \n\tif (srb->cmnd[0] != TEST_UNIT_READY)\n\t\tus->last_sector_retries = 0;\n}\n\n \nvoid usb_stor_invoke_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint need_auto_sense;\n\tint result;\n\n\t \n\tscsi_set_resid(srb, 0);\n\tresult = us->transport(srb, us);\n\n\t \n\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"-- command was aborted\\n\");\n\t\tsrb->result = DID_ABORT << 16;\n\t\tgoto Handle_Errors;\n\t}\n\n\t \n\tif (result == USB_STOR_TRANSPORT_ERROR) {\n\t\tusb_stor_dbg(us, \"-- transport indicates error, resetting\\n\");\n\t\tsrb->result = DID_ERROR << 16;\n\t\tgoto Handle_Errors;\n\t}\n\n\t \n\tif (result == USB_STOR_TRANSPORT_NO_SENSE) {\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\tlast_sector_hacks(us, srb);\n\t\treturn;\n\t}\n\n\tsrb->result = SAM_STAT_GOOD;\n\n\t \n\tneed_auto_sense = 0;\n\n\t \n\tif ((us->protocol == USB_PR_CB || us->protocol == USB_PR_DPCM_USB) &&\n\t\t\tsrb->sc_data_direction != DMA_FROM_DEVICE) {\n\t\tusb_stor_dbg(us, \"-- CB transport device requiring auto-sense\\n\");\n\t\tneed_auto_sense = 1;\n\t}\n\n\t \n\tif ((us->fflags & US_FL_SENSE_AFTER_SYNC) &&\n\t\t\tsrb->cmnd[0] == SYNCHRONIZE_CACHE) {\n\t\tusb_stor_dbg(us, \"-- sense after SYNC CACHE\\n\");\n\t\tneed_auto_sense = 1;\n\t}\n\n\t \n\tif (result == USB_STOR_TRANSPORT_FAILED) {\n\t\tusb_stor_dbg(us, \"-- transport indicates command failure\\n\");\n\t\tneed_auto_sense = 1;\n\t}\n\n\t \n\tif (unlikely((srb->cmnd[0] == ATA_16 || srb->cmnd[0] == ATA_12) &&\n\t    result == USB_STOR_TRANSPORT_GOOD &&\n\t    !(us->fflags & US_FL_SANE_SENSE) &&\n\t    !(us->fflags & US_FL_BAD_SENSE) &&\n\t    !(srb->cmnd[2] & 0x20))) {\n\t\tusb_stor_dbg(us, \"-- SAT supported, increasing auto-sense\\n\");\n\t\tus->fflags |= US_FL_SANE_SENSE;\n\t}\n\n\t \n\tif ((scsi_get_resid(srb) > 0) &&\n\t    !((srb->cmnd[0] == REQUEST_SENSE) ||\n\t      (srb->cmnd[0] == INQUIRY) ||\n\t      (srb->cmnd[0] == MODE_SENSE) ||\n\t      (srb->cmnd[0] == LOG_SENSE) ||\n\t      (srb->cmnd[0] == MODE_SENSE_10))) {\n\t\tusb_stor_dbg(us, \"-- unexpectedly short transfer\\n\");\n\t}\n\n\t \n\tif (need_auto_sense) {\n\t\tint temp_result;\n\t\tstruct scsi_eh_save ses;\n\t\tint sense_size = US_SENSE_SIZE;\n\t\tstruct scsi_sense_hdr sshdr;\n\t\tconst u8 *scdd;\n\t\tu8 fm_ili;\n\n\t\t \n\t\tif (us->fflags & US_FL_SANE_SENSE)\n\t\t\tsense_size = ~0;\nRetry_Sense:\n\t\tusb_stor_dbg(us, \"Issuing auto-REQUEST_SENSE\\n\");\n\n\t\tscsi_eh_prep_cmnd(srb, &ses, NULL, 0, sense_size);\n\n\t\t \n\t\tif (us->subclass == USB_SC_RBC || us->subclass == USB_SC_SCSI ||\n\t\t\t\tus->subclass == USB_SC_CYP_ATACB)\n\t\t\tsrb->cmd_len = 6;\n\t\telse\n\t\t\tsrb->cmd_len = 12;\n\n\t\t \n\t\tscsi_set_resid(srb, 0);\n\t\ttemp_result = us->transport(us->srb, us);\n\n\t\t \n\t\tscsi_eh_restore_cmnd(srb, &ses);\n\n\t\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\t\tusb_stor_dbg(us, \"-- auto-sense aborted\\n\");\n\t\t\tsrb->result = DID_ABORT << 16;\n\n\t\t\t \n\t\t\tif (sense_size != US_SENSE_SIZE) {\n\t\t\t\tus->fflags &= ~US_FL_SANE_SENSE;\n\t\t\t\tus->fflags |= US_FL_BAD_SENSE;\n\t\t\t}\n\t\t\tgoto Handle_Errors;\n\t\t}\n\n\t\t \n\t\tif (temp_result == USB_STOR_TRANSPORT_FAILED &&\n\t\t\t\tsense_size != US_SENSE_SIZE) {\n\t\t\tusb_stor_dbg(us, \"-- auto-sense failure, retry small sense\\n\");\n\t\t\tsense_size = US_SENSE_SIZE;\n\t\t\tus->fflags &= ~US_FL_SANE_SENSE;\n\t\t\tus->fflags |= US_FL_BAD_SENSE;\n\t\t\tgoto Retry_Sense;\n\t\t}\n\n\t\t \n\t\tif (temp_result != USB_STOR_TRANSPORT_GOOD) {\n\t\t\tusb_stor_dbg(us, \"-- auto-sense failure\\n\");\n\n\t\t\t \n\t\t\tsrb->result = DID_ERROR << 16;\n\t\t\tif (!(us->fflags & US_FL_SCM_MULT_TARG))\n\t\t\t\tgoto Handle_Errors;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (srb->sense_buffer[7] > (US_SENSE_SIZE - 8) &&\n\t\t    !(us->fflags & US_FL_SANE_SENSE) &&\n\t\t    !(us->fflags & US_FL_BAD_SENSE) &&\n\t\t    (srb->sense_buffer[0] & 0x7C) == 0x70) {\n\t\t\tusb_stor_dbg(us, \"-- SANE_SENSE support enabled\\n\");\n\t\t\tus->fflags |= US_FL_SANE_SENSE;\n\n\t\t\t \n\t\t\tusb_stor_dbg(us, \"-- Sense data truncated to %i from %i\\n\",\n\t\t\t\t     US_SENSE_SIZE,\n\t\t\t\t     srb->sense_buffer[7] + 8);\n\t\t\tsrb->sense_buffer[7] = (US_SENSE_SIZE - 8);\n\t\t}\n\n\t\tscsi_normalize_sense(srb->sense_buffer, SCSI_SENSE_BUFFERSIZE,\n\t\t\t\t     &sshdr);\n\n\t\tusb_stor_dbg(us, \"-- Result from auto-sense is %d\\n\",\n\t\t\t     temp_result);\n\t\tusb_stor_dbg(us, \"-- code: 0x%x, key: 0x%x, ASC: 0x%x, ASCQ: 0x%x\\n\",\n\t\t\t     sshdr.response_code, sshdr.sense_key,\n\t\t\t     sshdr.asc, sshdr.ascq);\n#ifdef CONFIG_USB_STORAGE_DEBUG\n\t\tusb_stor_show_sense(us, sshdr.sense_key, sshdr.asc, sshdr.ascq);\n#endif\n\n\t\t \n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\n\t\tscdd = scsi_sense_desc_find(srb->sense_buffer,\n\t\t\t\t\t    SCSI_SENSE_BUFFERSIZE, 4);\n\t\tfm_ili = (scdd ? scdd[3] : srb->sense_buffer[2]) & 0xA0;\n\n\t\t \n\t\tif (sshdr.sense_key == 0 && sshdr.asc == 0 && sshdr.ascq == 0 &&\n\t\t    fm_ili == 0) {\n\t\t\t \n\t\t\tif (result == USB_STOR_TRANSPORT_GOOD) {\n\t\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\t\tsrb->sense_buffer[0] = 0x0;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (srb->cmnd[0] == ATA_16 ||\n\t\t\t\t\tsrb->cmnd[0] == ATA_12) {\n\t\t\t\t \n\t\t\t}\n\n\t\t\t \n\t\t\telse {\n\t\t\t\tsrb->result = DID_ERROR << 16;\n\t\t\t\tif ((sshdr.response_code & 0x72) == 0x72)\n\t\t\t\t\tsrb->sense_buffer[1] = HARDWARE_ERROR;\n\t\t\t\telse\n\t\t\t\t\tsrb->sense_buffer[2] = HARDWARE_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (unlikely((us->fflags & US_FL_INITIAL_READ10) &&\n\t\t\tsrb->cmnd[0] == READ_10)) {\n\t\tif (srb->result == SAM_STAT_GOOD) {\n\t\t\tset_bit(US_FLIDX_READ10_WORKED, &us->dflags);\n\t\t} else if (test_bit(US_FLIDX_READ10_WORKED, &us->dflags)) {\n\t\t\tclear_bit(US_FLIDX_READ10_WORKED, &us->dflags);\n\t\t\tset_bit(US_FLIDX_REDO_READ10, &us->dflags);\n\t\t}\n\n\t\t \n\t\tif (test_bit(US_FLIDX_REDO_READ10, &us->dflags)) {\n\t\t\tclear_bit(US_FLIDX_REDO_READ10, &us->dflags);\n\t\t\tsrb->result = DID_IMM_RETRY << 16;\n\t\t\tsrb->sense_buffer[0] = 0;\n\t\t}\n\t}\n\n\t \n\tif ((srb->result == SAM_STAT_GOOD || srb->sense_buffer[2] == 0) &&\n\t\t\tscsi_bufflen(srb) - scsi_get_resid(srb) < srb->underflow)\n\t\tsrb->result = DID_ERROR << 16;\n\n\tlast_sector_hacks(us, srb);\n\treturn;\n\n\t \n  Handle_Errors:\n\n\t \n\tscsi_lock(us_to_host(us));\n\tset_bit(US_FLIDX_RESETTING, &us->dflags);\n\tclear_bit(US_FLIDX_ABORTING, &us->dflags);\n\tscsi_unlock(us_to_host(us));\n\n\t \n\tmutex_unlock(&us->dev_mutex);\n\tresult = usb_stor_port_reset(us);\n\tmutex_lock(&us->dev_mutex);\n\n\tif (result < 0) {\n\t\tscsi_lock(us_to_host(us));\n\t\tusb_stor_report_device_reset(us);\n\t\tscsi_unlock(us_to_host(us));\n\t\tus->transport_reset(us);\n\t}\n\tclear_bit(US_FLIDX_RESETTING, &us->dflags);\n\tlast_sector_hacks(us, srb);\n}\n\n \nvoid usb_stor_stop_transport(struct us_data *us)\n{\n\t \n\tif (test_and_clear_bit(US_FLIDX_URB_ACTIVE, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"-- cancelling URB\\n\");\n\t\tusb_unlink_urb(us->current_urb);\n\t}\n\n\t \n\tif (test_and_clear_bit(US_FLIDX_SG_ACTIVE, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"-- cancelling sg request\\n\");\n\t\tusb_sg_cancel(&us->current_sg);\n\t}\n}\n\n \n\nint usb_stor_CB_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tunsigned int transfer_length = scsi_bufflen(srb);\n\tunsigned int pipe = 0;\n\tint result;\n\n\t \n\t \n\t \n\tmemcpy(us->iobuf, srb->cmnd, srb->cmd_len);\n\tresult = usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\t\t\t      US_CBI_ADSC, \n\t\t\t\t      USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0, \n\t\t\t\t      us->ifnum, us->iobuf, srb->cmd_len);\n\n\t \n\tusb_stor_dbg(us, \"Call to usb_stor_ctrl_transfer() returned %d\\n\",\n\t\t     result);\n\n\t \n\tif (result == USB_STOR_XFER_STALLED) {\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\t \n\tif (result != USB_STOR_XFER_GOOD) {\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\t \n\tif (transfer_length) {\n\t\tpipe = srb->sc_data_direction == DMA_FROM_DEVICE ? \n\t\t\t\tus->recv_bulk_pipe : us->send_bulk_pipe;\n\t\tresult = usb_stor_bulk_srb(us, pipe, srb);\n\t\tusb_stor_dbg(us, \"CBI data stage result is 0x%x\\n\", result);\n\n\t\t \n\t\tif (result == USB_STOR_XFER_STALLED)\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\tif (result > USB_STOR_XFER_STALLED)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\n\t \n\tif (us->protocol != USB_PR_CBI)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tresult = usb_stor_intr_transfer(us, us->iobuf, 2);\n\tusb_stor_dbg(us, \"Got interrupt data (0x%x, 0x%x)\\n\",\n\t\t     us->iobuf[0], us->iobuf[1]);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tif (us->subclass == USB_SC_UFI) {\n\t\tif (srb->cmnd[0] == REQUEST_SENSE ||\n\t\t    srb->cmnd[0] == INQUIRY)\n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t\tif (us->iobuf[0])\n\t\t\tgoto Failed;\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\t \n\tif (us->iobuf[0]) {\n\t\tusb_stor_dbg(us, \"CBI IRQ data showed reserved bType 0x%x\\n\",\n\t\t\t     us->iobuf[0]);\n\t\tgoto Failed;\n\n\t}\n\n\t \n\tswitch (us->iobuf[1] & 0x0F) {\n\t\tcase 0x00: \n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t\tcase 0x01: \n\t\t\tgoto Failed;\n\t}\n\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n  Failed:\n\tif (pipe)\n\t\tusb_stor_clear_halt(us, pipe);\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\nEXPORT_SYMBOL_GPL(usb_stor_CB_transport);\n\n \n\n \nint usb_stor_Bulk_max_lun(struct us_data *us)\n{\n\tint result;\n\n\t \n\tus->iobuf[0] = 0;\n\tresult = usb_stor_control_msg(us, us->recv_ctrl_pipe,\n\t\t\t\t US_BULK_GET_MAX_LUN, \n\t\t\t\t USB_DIR_IN | USB_TYPE_CLASS | \n\t\t\t\t USB_RECIP_INTERFACE,\n\t\t\t\t 0, us->ifnum, us->iobuf, 1, 10*HZ);\n\n\tusb_stor_dbg(us, \"GetMaxLUN command result is %d, data is %d\\n\",\n\t\t     result, us->iobuf[0]);\n\n\t \n\tif (result > 0) {\n\t\tif (us->iobuf[0] < 16) {\n\t\t\treturn us->iobuf[0];\n\t\t} else {\n\t\t\tdev_info(&us->pusb_intf->dev,\n\t\t\t\t \"Max LUN %d is not valid, using 0 instead\",\n\t\t\t\t us->iobuf[0]);\n\t\t}\n\t}\n\n\t \n\treturn 0;\n}\n\nint usb_stor_Bulk_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\n\tstruct bulk_cs_wrap *bcs = (struct bulk_cs_wrap *) us->iobuf;\n\tunsigned int transfer_length = scsi_bufflen(srb);\n\tunsigned int residue;\n\tint result;\n\tint fake_sense = 0;\n\tunsigned int cswlen;\n\tunsigned int cbwlen = US_BULK_CB_WRAP_LEN;\n\n\t \n\tif (unlikely(us->fflags & US_FL_BULK32)) {\n\t\tcbwlen = 32;\n\t\tus->iobuf[31] = 0;\n\t}\n\n\t \n\tbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\n\tbcb->DataTransferLength = cpu_to_le32(transfer_length);\n\tbcb->Flags = srb->sc_data_direction == DMA_FROM_DEVICE ?\n\t\tUS_BULK_FLAG_IN : 0;\n\tbcb->Tag = ++us->tag;\n\tbcb->Lun = srb->device->lun;\n\tif (us->fflags & US_FL_SCM_MULT_TARG)\n\t\tbcb->Lun |= srb->device->id << 4;\n\tbcb->Length = srb->cmd_len;\n\n\t \n\tmemset(bcb->CDB, 0, sizeof(bcb->CDB));\n\tmemcpy(bcb->CDB, srb->cmnd, bcb->Length);\n\n\t \n\tusb_stor_dbg(us, \"Bulk Command S 0x%x T 0x%x L %d F %d Trg %d LUN %d CL %d\\n\",\n\t\t     le32_to_cpu(bcb->Signature), bcb->Tag,\n\t\t     le32_to_cpu(bcb->DataTransferLength), bcb->Flags,\n\t\t     (bcb->Lun >> 4), (bcb->Lun & 0x0F),\n\t\t     bcb->Length);\n\tresult = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe,\n\t\t\t\tbcb, cbwlen, NULL);\n\tusb_stor_dbg(us, \"Bulk command transfer result=%d\\n\", result);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\t \n\n\t \n\tif (unlikely(us->fflags & US_FL_GO_SLOW))\n\t\tusleep_range(125, 150);\n\n\tif (transfer_length) {\n\t\tunsigned int pipe = srb->sc_data_direction == DMA_FROM_DEVICE ? \n\t\t\t\tus->recv_bulk_pipe : us->send_bulk_pipe;\n\t\tresult = usb_stor_bulk_srb(us, pipe, srb);\n\t\tusb_stor_dbg(us, \"Bulk data transfer result 0x%x\\n\", result);\n\t\tif (result == USB_STOR_XFER_ERROR)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\t \n\t\tif (result == USB_STOR_XFER_LONG)\n\t\t\tfake_sense = 1;\n\n\t\t \n\t\tif (result == USB_STOR_XFER_SHORT &&\n\t\t\t\tsrb->sc_data_direction == DMA_FROM_DEVICE &&\n\t\t\t\ttransfer_length - scsi_get_resid(srb) ==\n\t\t\t\t\tUS_BULK_CS_WRAP_LEN) {\n\t\t\tstruct scatterlist *sg = NULL;\n\t\t\tunsigned int offset = 0;\n\n\t\t\tif (usb_stor_access_xfer_buf((unsigned char *) bcs,\n\t\t\t\t\tUS_BULK_CS_WRAP_LEN, srb, &sg,\n\t\t\t\t\t&offset, FROM_XFER_BUF) ==\n\t\t\t\t\t\tUS_BULK_CS_WRAP_LEN &&\n\t\t\t\t\tbcs->Signature ==\n\t\t\t\t\t\tcpu_to_le32(US_BULK_CS_SIGN)) {\n\t\t\t\tusb_stor_dbg(us, \"Device skipped data phase\\n\");\n\t\t\t\tscsi_set_resid(srb, transfer_length);\n\t\t\t\tgoto skipped_data_phase;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\t \n\tusb_stor_dbg(us, \"Attempting to get CSW...\\n\");\n\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\tbcs, US_BULK_CS_WRAP_LEN, &cswlen);\n\n\t \n\tif (result == USB_STOR_XFER_SHORT && cswlen == 0) {\n\t\tusb_stor_dbg(us, \"Received 0-length CSW; retrying...\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\tbcs, US_BULK_CS_WRAP_LEN, &cswlen);\n\t}\n\n\t \n\tif (result == USB_STOR_XFER_STALLED) {\n\n\t\t \n\t\tusb_stor_dbg(us, \"Attempting to get CSW (2nd try)...\\n\");\n\t\tresult = usb_stor_bulk_transfer_buf(us, us->recv_bulk_pipe,\n\t\t\t\tbcs, US_BULK_CS_WRAP_LEN, NULL);\n\t}\n\n\t \n\tusb_stor_dbg(us, \"Bulk status result = %d\\n\", result);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n skipped_data_phase:\n\t \n\tresidue = le32_to_cpu(bcs->Residue);\n\tusb_stor_dbg(us, \"Bulk Status S 0x%x T 0x%x R %u Stat 0x%x\\n\",\n\t\t     le32_to_cpu(bcs->Signature), bcs->Tag,\n\t\t     residue, bcs->Status);\n\tif (!(bcs->Tag == us->tag || (us->fflags & US_FL_BULK_IGNORE_TAG)) ||\n\t\tbcs->Status > US_BULK_STAT_PHASE) {\n\t\tusb_stor_dbg(us, \"Bulk logical error\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tif (!us->bcs_signature) {\n\t\tus->bcs_signature = bcs->Signature;\n\t\tif (us->bcs_signature != cpu_to_le32(US_BULK_CS_SIGN))\n\t\t\tusb_stor_dbg(us, \"Learnt BCS signature 0x%08X\\n\",\n\t\t\t\t     le32_to_cpu(us->bcs_signature));\n\t} else if (bcs->Signature != us->bcs_signature) {\n\t\tusb_stor_dbg(us, \"Signature mismatch: got %08X, expecting %08X\\n\",\n\t\t\t     le32_to_cpu(bcs->Signature),\n\t\t\t     le32_to_cpu(us->bcs_signature));\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\tif (residue && !(us->fflags & US_FL_IGNORE_RESIDUE)) {\n\n\t\t \n\t\tif (bcs->Status == US_BULK_STAT_OK &&\n\t\t\t\tscsi_get_resid(srb) == 0 &&\n\t\t\t\t\t((srb->cmnd[0] == INQUIRY &&\n\t\t\t\t\t\ttransfer_length == 36) ||\n\t\t\t\t\t(srb->cmnd[0] == READ_CAPACITY &&\n\t\t\t\t\t\ttransfer_length == 8))) {\n\t\t\tus->fflags |= US_FL_IGNORE_RESIDUE;\n\n\t\t} else {\n\t\t\tresidue = min(residue, transfer_length);\n\t\t\tscsi_set_resid(srb, max(scsi_get_resid(srb), residue));\n\t\t}\n\t}\n\n\t \n\tswitch (bcs->Status) {\n\t\tcase US_BULK_STAT_OK:\n\t\t\t \n\t\t\tif (fake_sense) {\n\t\t\t\tmemcpy(srb->sense_buffer, \n\t\t\t\t       usb_stor_sense_invalidCDB, \n\t\t\t\t       sizeof(usb_stor_sense_invalidCDB));\n\t\t\t\treturn USB_STOR_TRANSPORT_NO_SENSE;\n\t\t\t}\n\n\t\t\t \n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\t\tcase US_BULK_STAT_FAIL:\n\t\t\t \n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t\tcase US_BULK_STAT_PHASE:\n\t\t\t \n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\t \n\treturn USB_STOR_TRANSPORT_ERROR;\n}\nEXPORT_SYMBOL_GPL(usb_stor_Bulk_transport);\n\n \n\n \nstatic int usb_stor_reset_common(struct us_data *us,\n\t\tu8 request, u8 requesttype,\n\t\tu16 value, u16 index, void *data, u16 size)\n{\n\tint result;\n\tint result2;\n\n\tif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"No reset during disconnect\\n\");\n\t\treturn -EIO;\n\t}\n\n\tresult = usb_stor_control_msg(us, us->send_ctrl_pipe,\n\t\t\trequest, requesttype, value, index, data, size,\n\t\t\t5*HZ);\n\tif (result < 0) {\n\t\tusb_stor_dbg(us, \"Soft reset failed: %d\\n\", result);\n\t\treturn result;\n\t}\n\n\t \n\twait_event_interruptible_timeout(us->delay_wait,\n\t\t\ttest_bit(US_FLIDX_DISCONNECTING, &us->dflags),\n\t\t\tHZ*6);\n\tif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"Reset interrupted by disconnect\\n\");\n\t\treturn -EIO;\n\t}\n\n\tusb_stor_dbg(us, \"Soft reset: clearing bulk-in endpoint halt\\n\");\n\tresult = usb_stor_clear_halt(us, us->recv_bulk_pipe);\n\n\tusb_stor_dbg(us, \"Soft reset: clearing bulk-out endpoint halt\\n\");\n\tresult2 = usb_stor_clear_halt(us, us->send_bulk_pipe);\n\n\t \n\tif (result >= 0)\n\t\tresult = result2;\n\tif (result < 0)\n\t\tusb_stor_dbg(us, \"Soft reset failed\\n\");\n\telse\n\t\tusb_stor_dbg(us, \"Soft reset done\\n\");\n\treturn result;\n}\n\n \n#define CB_RESET_CMD_SIZE\t12\n\nint usb_stor_CB_reset(struct us_data *us)\n{\n\tmemset(us->iobuf, 0xFF, CB_RESET_CMD_SIZE);\n\tus->iobuf[0] = SEND_DIAGNOSTIC;\n\tus->iobuf[1] = 4;\n\treturn usb_stor_reset_common(us, US_CBI_ADSC, \n\t\t\t\t USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t 0, us->ifnum, us->iobuf, CB_RESET_CMD_SIZE);\n}\nEXPORT_SYMBOL_GPL(usb_stor_CB_reset);\n\n \nint usb_stor_Bulk_reset(struct us_data *us)\n{\n\treturn usb_stor_reset_common(us, US_BULK_RESET_REQUEST, \n\t\t\t\t USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\t 0, us->ifnum, NULL, 0);\n}\nEXPORT_SYMBOL_GPL(usb_stor_Bulk_reset);\n\n \nint usb_stor_port_reset(struct us_data *us)\n{\n\tint result;\n\n\t \n\tif (us->pusb_dev->quirks & USB_QUIRK_RESET)\n\t\treturn -EPERM;\n\n\tresult = usb_lock_device_for_reset(us->pusb_dev, us->pusb_intf);\n\tif (result < 0)\n\t\tusb_stor_dbg(us, \"unable to lock device for reset: %d\\n\",\n\t\t\t     result);\n\telse {\n\t\t \n\t\tif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\n\t\t\tresult = -EIO;\n\t\t\tusb_stor_dbg(us, \"No reset during disconnect\\n\");\n\t\t} else {\n\t\t\tresult = usb_reset_device(us->pusb_dev);\n\t\t\tusb_stor_dbg(us, \"usb_reset_device returns %d\\n\",\n\t\t\t\t     result);\n\t\t}\n\t\tusb_unlock_device(us->pusb_dev);\n\t}\n\treturn result;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}