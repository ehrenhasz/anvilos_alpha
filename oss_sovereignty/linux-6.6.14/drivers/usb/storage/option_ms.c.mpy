{
  "module_name": "option_ms.c",
  "hash_id": "e0f4654a75522afc80d0e98f65a5cb8b07966d301a8a759df82bf5a6eb0d6543",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/option_ms.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"option_ms.h\"\n#include \"debug.h\"\n\n#define ZCD_FORCE_MODEM\t\t\t0x01\n#define ZCD_ALLOW_MS \t\t\t0x02\n\nstatic unsigned int option_zero_cd = ZCD_FORCE_MODEM;\nmodule_param(option_zero_cd, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(option_zero_cd, \"ZeroCD mode (1=Force Modem (default),\"\n\t\t \" 2=Allow CD-Rom\");\n\n#define RESPONSE_LEN 1024\n\nstatic int option_rezero(struct us_data *us)\n{\n\tstatic const unsigned char rezero_msg[] = {\n\t  0x55, 0x53, 0x42, 0x43, 0x78, 0x56, 0x34, 0x12,\n\t  0x01, 0x00, 0x00, 0x00, 0x80, 0x00, 0x06, 0x01,\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tchar *buffer;\n\tint result;\n\n\tusb_stor_dbg(us, \"Option MS: %s\\n\", \"DEVICE MODE SWITCH\");\n\n\tbuffer = kzalloc(RESPONSE_LEN, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemcpy(buffer, rezero_msg, sizeof(rezero_msg));\n\tresult = usb_stor_bulk_transfer_buf(us,\n\t\t\tus->send_bulk_pipe,\n\t\t\tbuffer, sizeof(rezero_msg), NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tresult = USB_STOR_XFER_ERROR;\n\t\tgoto out;\n\t}\n\n\t \n\tusb_stor_bulk_transfer_buf(us,\n\t\t\tus->recv_bulk_pipe,\n\t\t\tbuffer, RESPONSE_LEN, NULL);\n\n\t \n\tusb_stor_bulk_transfer_buf(us,\n\t\t\tus->recv_bulk_pipe,\n\t\t\tbuffer, 13, NULL);\n\n\tresult = USB_STOR_XFER_GOOD;\n\nout:\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int option_inquiry(struct us_data *us)\n{\n\tstatic const unsigned char inquiry_msg[] = {\n\t  0x55, 0x53, 0x42, 0x43, 0x12, 0x34, 0x56, 0x78,\n\t  0x24, 0x00, 0x00, 0x00, 0x80, 0x00, 0x06, 0x12,\n\t  0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,\n\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n\t};\n\tchar *buffer;\n\tint result;\n\n\tusb_stor_dbg(us, \"Option MS: %s\\n\", \"device inquiry for vendor name\");\n\n\tbuffer = kzalloc(0x24, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tmemcpy(buffer, inquiry_msg, sizeof(inquiry_msg));\n\tresult = usb_stor_bulk_transfer_buf(us,\n\t\t\tus->send_bulk_pipe,\n\t\t\tbuffer, sizeof(inquiry_msg), NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tresult = USB_STOR_XFER_ERROR;\n\t\tgoto out;\n\t}\n\n\tresult = usb_stor_bulk_transfer_buf(us,\n\t\t\tus->recv_bulk_pipe,\n\t\t\tbuffer, 0x24, NULL);\n\tif (result != USB_STOR_XFER_GOOD) {\n\t\tresult = USB_STOR_XFER_ERROR;\n\t\tgoto out;\n\t}\n\n\tresult = memcmp(buffer+8, \"Option\", 6);\n\n\tif (result != 0)\n\t\tresult = memcmp(buffer+8, \"ZCOPTION\", 8);\n\n\t \n\tusb_stor_bulk_transfer_buf(us,\n\t\t\tus->recv_bulk_pipe,\n\t\t\tbuffer, 13, NULL);\n\nout:\n\tkfree(buffer);\n\treturn result;\n}\n\n\nint option_ms_init(struct us_data *us)\n{\n\tint result;\n\n\tusb_stor_dbg(us, \"Option MS: %s\\n\", \"option_ms_init called\");\n\n\t \n\tresult = option_inquiry(us);\n\tif (result != 0) {\n\t\tusb_stor_dbg(us, \"Option MS: %s\\n\",\n\t\t\t     \"vendor is not Option or not determinable, no action taken\");\n\t\treturn 0;\n\t} else\n\t\tusb_stor_dbg(us, \"Option MS: %s\\n\",\n\t\t\t     \"this is a genuine Option device, proceeding\");\n\n\t \n\tif (option_zero_cd == ZCD_FORCE_MODEM) {\n\t\tusb_stor_dbg(us, \"Option MS: %s\\n\", \"Forcing Modem Mode\");\n\t\tresult = option_rezero(us);\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\tusb_stor_dbg(us, \"Option MS: %s\\n\",\n\t\t\t\t     \"Failed to switch to modem mode\");\n\t\treturn -EIO;\n\t} else if (option_zero_cd == ZCD_ALLOW_MS) {\n\t\t \n\t\tusb_stor_dbg(us, \"Option MS: %s\\n\",\n\t\t\t     \"Allowing Mass Storage Mode if device requests it\");\n\t}\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}