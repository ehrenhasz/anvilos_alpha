{
  "module_name": "protocol.c",
  "hash_id": "f71eae558f63ce05a0d84594daab32aa266cab30b74427710f2490b7721e5049",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/protocol.c",
  "human_readable_source": "\n \n\n#include <linux/highmem.h>\n#include <linux/export.h>\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n#include \"transport.h\"\n\n \n\nvoid usb_stor_pad12_command(struct scsi_cmnd *srb, struct us_data *us)\n{\n\t \n\tfor (; srb->cmd_len < 12; srb->cmd_len++)\n\t\tsrb->cmnd[srb->cmd_len] = 0;\n\n\t \n\tusb_stor_invoke_transport(srb, us);\n}\n\nvoid usb_stor_ufi_command(struct scsi_cmnd *srb, struct us_data *us)\n{\n\t \n\n\t \n\tfor (; srb->cmd_len < 12; srb->cmd_len++)\n\t\tsrb->cmnd[srb->cmd_len] = 0;\n\n\t \n\tsrb->cmd_len = 12;\n\n\t \n\n\t \n\tswitch (srb->cmnd[0]) {\n\n\t\t \n\tcase INQUIRY:\n\t\tsrb->cmnd[4] = 36;\n\t\tbreak;\n\n\t\t \n\tcase MODE_SENSE_10:\n\t\tsrb->cmnd[7] = 0;\n\t\tsrb->cmnd[8] = 8;\n\t\tbreak;\n\n\t\t \n\tcase REQUEST_SENSE:\n\t\tsrb->cmnd[4] = 18;\n\t\tbreak;\n\t}  \n\n\t \n\tusb_stor_invoke_transport(srb, us);\n}\n\nvoid usb_stor_transparent_scsi_command(struct scsi_cmnd *srb,\n\t\t\t\t       struct us_data *us)\n{\n\t \n\tusb_stor_invoke_transport(srb, us);\n}\nEXPORT_SYMBOL_GPL(usb_stor_transparent_scsi_command);\n\n \n\n \nunsigned int usb_stor_access_xfer_buf(unsigned char *buffer,\n\tunsigned int buflen, struct scsi_cmnd *srb, struct scatterlist **sgptr,\n\tunsigned int *offset, enum xfer_buf_dir dir)\n{\n\tunsigned int cnt = 0;\n\tstruct scatterlist *sg = *sgptr;\n\tstruct sg_mapping_iter miter;\n\tunsigned int nents = scsi_sg_count(srb);\n\n\tif (sg)\n\t\tnents = sg_nents(sg);\n\telse\n\t\tsg = scsi_sglist(srb);\n\n\tsg_miter_start(&miter, sg, nents, dir == FROM_XFER_BUF ?\n\t\tSG_MITER_FROM_SG: SG_MITER_TO_SG);\n\n\tif (!sg_miter_skip(&miter, *offset))\n\t\treturn cnt;\n\n\twhile (sg_miter_next(&miter) && cnt < buflen) {\n\t\tunsigned int len = min_t(unsigned int, miter.length,\n\t\t\t\tbuflen - cnt);\n\n\t\tif (dir == FROM_XFER_BUF)\n\t\t\tmemcpy(buffer + cnt, miter.addr, len);\n\t\telse\n\t\t\tmemcpy(miter.addr, buffer + cnt, len);\n\n\t\tif (*offset + len < miter.piter.sg->length) {\n\t\t\t*offset += len;\n\t\t\t*sgptr = miter.piter.sg;\n\t\t} else {\n\t\t\t*offset = 0;\n\t\t\t*sgptr = sg_next(miter.piter.sg);\n\t\t}\n\t\tcnt += len;\n\t}\n\tsg_miter_stop(&miter);\n\n\treturn cnt;\n}\nEXPORT_SYMBOL_GPL(usb_stor_access_xfer_buf);\n\n \nvoid usb_stor_set_xfer_buf(unsigned char *buffer,\n\tunsigned int buflen, struct scsi_cmnd *srb)\n{\n\tunsigned int offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\tbuflen = min(buflen, scsi_bufflen(srb));\n\tbuflen = usb_stor_access_xfer_buf(buffer, buflen, srb, &sg, &offset,\n\t\t\tTO_XFER_BUF);\n\tif (buflen < scsi_bufflen(srb))\n\t\tscsi_set_resid(srb, scsi_bufflen(srb) - buflen);\n}\nEXPORT_SYMBOL_GPL(usb_stor_set_xfer_buf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}