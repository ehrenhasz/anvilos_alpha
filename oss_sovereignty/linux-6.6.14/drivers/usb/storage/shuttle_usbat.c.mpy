{
  "module_name": "shuttle_usbat.c",
  "hash_id": "2b16037e256c648eccb354e899a3a9cc4404d6edfe32520de2674d2b8288317c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/shuttle_usbat.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/cdrom.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-usbat\"\n\nMODULE_DESCRIPTION(\"Driver for SCM Microsystems (a.k.a. Shuttle) USB-ATAPI cable\");\nMODULE_AUTHOR(\"Daniel Drake <dsd@gentoo.org>, Robert Baruch <autophile@starband.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\n \n#define USBAT_DEV_HP8200\t0x01\n#define USBAT_DEV_FLASH\t\t0x02\n\n#define USBAT_EPP_PORT\t\t0x10\n#define USBAT_EPP_REGISTER\t0x30\n#define USBAT_ATA\t\t0x40\n#define USBAT_ISA\t\t0x50\n\n \n#define USBAT_CMD_READ_REG\t\t0x00\n#define USBAT_CMD_WRITE_REG\t\t0x01\n#define USBAT_CMD_READ_BLOCK\t0x02\n#define USBAT_CMD_WRITE_BLOCK\t0x03\n#define USBAT_CMD_COND_READ_BLOCK\t0x04\n#define USBAT_CMD_COND_WRITE_BLOCK\t0x05\n#define USBAT_CMD_WRITE_REGS\t0x07\n\n \n#define USBAT_CMD_EXEC_CMD\t0x80\n#define USBAT_CMD_SET_FEAT\t0x81\n#define USBAT_CMD_UIO\t\t0x82\n\n \n#define USBAT_UIO_READ\t1\n#define USBAT_UIO_WRITE\t0\n\n \n#define USBAT_QUAL_FCQ\t0x20\t \n#define USBAT_QUAL_ALQ\t0x10\t \n\n \n#define USBAT_FLASH_MEDIA_NONE\t0\n#define USBAT_FLASH_MEDIA_CF\t1\n\n \n#define USBAT_FLASH_MEDIA_SAME\t0\n#define USBAT_FLASH_MEDIA_CHANGED\t1\n\n \n#define USBAT_ATA_DATA      0x10   \n#define USBAT_ATA_FEATURES  0x11   \n#define USBAT_ATA_ERROR     0x11   \n#define USBAT_ATA_SECCNT    0x12   \n#define USBAT_ATA_SECNUM    0x13   \n#define USBAT_ATA_LBA_ME    0x14   \n#define USBAT_ATA_LBA_HI    0x15   \n#define USBAT_ATA_DEVICE    0x16   \n#define USBAT_ATA_STATUS    0x17   \n#define USBAT_ATA_CMD       0x17   \n#define USBAT_ATA_ALTSTATUS 0x0E   \n\n \n#define USBAT_UIO_EPAD\t\t0x80  \n#define USBAT_UIO_CDT\t\t0x40  \n\t\t\t\t      \n#define USBAT_UIO_1\t\t0x20  \n#define USBAT_UIO_0\t\t0x10  \n#define USBAT_UIO_EPP_ATA\t0x08  \n#define USBAT_UIO_UI1\t\t0x04  \n#define USBAT_UIO_UI0\t\t0x02  \n#define USBAT_UIO_INTR_ACK\t0x01  \n\n \n#define USBAT_UIO_DRVRST\t0x80  \n#define USBAT_UIO_ACKD\t\t0x40  \n#define USBAT_UIO_OE1\t\t0x20  \n\t\t\t\t      \n#define USBAT_UIO_OE0\t\t0x10  \n#define USBAT_UIO_ADPRST\t0x01  \n\n \n#define USBAT_FEAT_ETEN\t0x80\t \n#define USBAT_FEAT_U1\t0x08\n#define USBAT_FEAT_U0\t0x04\n#define USBAT_FEAT_ET1\t0x02\n#define USBAT_FEAT_ET2\t0x01\n\nstruct usbat_info {\n\tint devicetype;\n\n\t \n\tunsigned long sectors;      \n\tunsigned long ssize;        \n\n\tunsigned char sense_key;\n\tunsigned long sense_asc;    \n\tunsigned long sense_ascq;   \n};\n\n#define short_pack(LSB,MSB) ( ((u16)(LSB)) | ( ((u16)(MSB))<<8 ) )\n#define LSB_of(s) ((s)&0xFF)\n#define MSB_of(s) ((s)>>8)\n\nstatic int transferred = 0;\n\nstatic int usbat_flash_transport(struct scsi_cmnd * srb, struct us_data *us);\nstatic int usbat_hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us);\n\nstatic int init_usbat_cd(struct us_data *us);\nstatic int init_usbat_flash(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id usbat_usb_ids[] = {\n#\tinclude \"unusual_usbat.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, usbat_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev usbat_unusual_dev_list[] = {\n#\tinclude \"unusual_usbat.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n \nstatic void usbat_pack_ata_sector_cmd(unsigned char *buf,\n\t\t\t\t\tunsigned char thistime,\n\t\t\t\t\tu32 sector, unsigned char cmd)\n{\n\tbuf[0] = 0;\n\tbuf[1] = thistime;\n\tbuf[2] = sector & 0xFF;\n\tbuf[3] = (sector >>  8) & 0xFF;\n\tbuf[4] = (sector >> 16) & 0xFF;\n\tbuf[5] = 0xE0 | ((sector >> 24) & 0x0F);\n\tbuf[6] = cmd;\n}\n\n \nstatic int usbat_get_device_type(struct us_data *us)\n{\n\treturn ((struct usbat_info*)us->extra)->devicetype;\n}\n\n \nstatic int usbat_read(struct us_data *us,\n\t\t      unsigned char access,\n\t\t      unsigned char reg,\n\t\t      unsigned char *content)\n{\n\treturn usb_stor_ctrl_transfer(us,\n\t\tus->recv_ctrl_pipe,\n\t\taccess | USBAT_CMD_READ_REG,\n\t\t0xC0,\n\t\t(u16)reg,\n\t\t0,\n\t\tcontent,\n\t\t1);\n}\n\n \nstatic int usbat_write(struct us_data *us,\n\t\t       unsigned char access,\n\t\t       unsigned char reg,\n\t\t       unsigned char content)\n{\n\treturn usb_stor_ctrl_transfer(us,\n\t\tus->send_ctrl_pipe,\n\t\taccess | USBAT_CMD_WRITE_REG,\n\t\t0x40,\n\t\tshort_pack(reg, content),\n\t\t0,\n\t\tNULL,\n\t\t0);\n}\n\n \nstatic int usbat_bulk_read(struct us_data *us,\n\t\t\t   void* buf,\n\t\t\t   unsigned int len,\n\t\t\t   int use_sg)\n{\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_sg(us, us->recv_bulk_pipe, buf, len, use_sg, NULL);\n}\n\n \nstatic int usbat_bulk_write(struct us_data *us,\n\t\t\t    void* buf,\n\t\t\t    unsigned int len,\n\t\t\t    int use_sg)\n{\n\tif (len == 0)\n\t\treturn USB_STOR_XFER_GOOD;\n\n\tusb_stor_dbg(us, \"len = %d\\n\", len);\n\treturn usb_stor_bulk_transfer_sg(us, us->send_bulk_pipe, buf, len, use_sg, NULL);\n}\n\n \nstatic int usbat_execute_command(struct us_data *us,\n\t\t\t\t\t\t\t\t unsigned char *commands,\n\t\t\t\t\t\t\t\t unsigned int len)\n{\n\treturn usb_stor_ctrl_transfer(us, us->send_ctrl_pipe,\n\t\t\t\t\t\t\t\t  USBAT_CMD_EXEC_CMD, 0x40, 0, 0,\n\t\t\t\t\t\t\t\t  commands, len);\n}\n\n \nstatic int usbat_get_status(struct us_data *us, unsigned char *status)\n{\n\tint rc;\n\trc = usbat_read(us, USBAT_ATA, USBAT_ATA_STATUS, status);\n\n\tusb_stor_dbg(us, \"0x%02X\\n\", *status);\n\treturn rc;\n}\n\n \nstatic int usbat_check_status(struct us_data *us)\n{\n\tunsigned char *reply = us->iobuf;\n\tint rc;\n\n\trc = usbat_get_status(us, reply);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t \n\tif (*reply & 0x01 && *reply != 0x51)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t \n\tif (*reply & 0x20)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_set_shuttle_features(struct us_data *us,\n\t\t\t\t      unsigned char external_trigger,\n\t\t\t\t      unsigned char epp_control,\n\t\t\t\t      unsigned char mask_byte,\n\t\t\t\t      unsigned char test_pattern,\n\t\t\t\t      unsigned char subcountH,\n\t\t\t\t      unsigned char subcountL)\n{\n\tunsigned char *command = us->iobuf;\n\n\tcommand[0] = 0x40;\n\tcommand[1] = USBAT_CMD_SET_FEAT;\n\n\t \n\tcommand[2] = epp_control;\n\n\t \n\tcommand[3] = external_trigger;\n\n\t \n\tcommand[4] = test_pattern;\n\n\t \n\tcommand[5] = mask_byte;\n\n\t \n\tcommand[6] = subcountL;\n\tcommand[7] = subcountH;\n\n\treturn usbat_execute_command(us, command, 8);\n}\n\n \nstatic int usbat_wait_not_busy(struct us_data *us, int minutes)\n{\n\tint i;\n\tint result;\n\tunsigned char *status = us->iobuf;\n\n\t \n\n\tfor (i=0; i<1200+minutes*60; i++) {\n\n \t\tresult = usbat_get_status(us, status);\n\n\t\tif (result!=USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\tif (*status & 0x01) {  \n\t\t\tresult = usbat_read(us, USBAT_ATA, 0x10, status);\n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t}\n\t\tif (*status & 0x20)  \n\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t\tif ((*status & 0x80)==0x00) {  \n\t\t\tusb_stor_dbg(us, \"Waited not busy for %d steps\\n\", i);\n\t\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t\t}\n\n\t\tif (i<500)\n\t\t\tmsleep(10);  \n\t\telse if (i<700)\n\t\t\tmsleep(50);  \n\t\telse if (i<1200)\n\t\t\tmsleep(100);  \n\t\telse\n\t\t\tmsleep(1000);  \n\t}\n\n\tusb_stor_dbg(us, \"Waited not busy for %d minutes, timing out\\n\",\n\t\t     minutes);\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\n \nstatic int usbat_read_block(struct us_data *us,\n\t\t\t    void* buf,\n\t\t\t    unsigned short len,\n\t\t\t    int use_sg)\n{\n\tint result;\n\tunsigned char *command = us->iobuf;\n\n\tif (!len)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tcommand[0] = 0xC0;\n\tcommand[1] = USBAT_ATA | USBAT_CMD_READ_BLOCK;\n\tcommand[2] = USBAT_ATA_DATA;\n\tcommand[3] = 0;\n\tcommand[4] = 0;\n\tcommand[5] = 0;\n\tcommand[6] = LSB_of(len);\n\tcommand[7] = MSB_of(len);\n\n\tresult = usbat_execute_command(us, command, 8);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tresult = usbat_bulk_read(us, buf, len, use_sg);\n\treturn (result == USB_STOR_XFER_GOOD ?\n\t\t\tUSB_STOR_TRANSPORT_GOOD : USB_STOR_TRANSPORT_ERROR);\n}\n\n \nstatic int usbat_write_block(struct us_data *us,\n\t\t\t     unsigned char access,\n\t\t\t     void* buf,\n\t\t\t     unsigned short len,\n\t\t\t     int minutes,\n\t\t\t     int use_sg)\n{\n\tint result;\n\tunsigned char *command = us->iobuf;\n\n\tif (!len)\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\n\tcommand[0] = 0x40;\n\tcommand[1] = access | USBAT_CMD_WRITE_BLOCK;\n\tcommand[2] = USBAT_ATA_DATA;\n\tcommand[3] = 0;\n\tcommand[4] = 0;\n\tcommand[5] = 0;\n\tcommand[6] = LSB_of(len);\n\tcommand[7] = MSB_of(len);\n\n\tresult = usbat_execute_command(us, command, 8);\n\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tresult = usbat_bulk_write(us, buf, len, use_sg);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn usbat_wait_not_busy(us, minutes);\n}\n\n \nstatic int usbat_hp8200e_rw_block_test(struct us_data *us,\n\t\t\t\t       unsigned char access,\n\t\t\t\t       unsigned char *registers,\n\t\t\t\t       unsigned char *data_out,\n\t\t\t\t       unsigned short num_registers,\n\t\t\t\t       unsigned char data_reg,\n\t\t\t\t       unsigned char status_reg,\n\t\t\t\t       unsigned char timeout,\n\t\t\t\t       unsigned char qualifier,\n\t\t\t\t       int direction,\n\t\t\t\t       void *buf,\n\t\t\t\t       unsigned short len,\n\t\t\t\t       int use_sg,\n\t\t\t\t       int minutes)\n{\n\tint result;\n\tunsigned int pipe = (direction == DMA_FROM_DEVICE) ?\n\t\t\tus->recv_bulk_pipe : us->send_bulk_pipe;\n\n\tunsigned char *command = us->iobuf;\n\tint i, j;\n\tint cmdlen;\n\tunsigned char *data = us->iobuf;\n\tunsigned char *status = us->iobuf;\n\n\tBUG_ON(num_registers > US_IOBUF_SIZE/2);\n\n\tfor (i=0; i<20; i++) {\n\n\t\t \n\n\t\tif (i==0) {\n\t\t\tcmdlen = 16;\n\t\t\t \n\t\t\tcommand[0] = 0x40;\n\t\t\tcommand[1] = access | USBAT_CMD_WRITE_REGS;\n\t\t\tcommand[2] = 0x07;\n\t\t\tcommand[3] = 0x17;\n\t\t\tcommand[4] = 0xFC;\n\t\t\tcommand[5] = 0xE7;\n\t\t\tcommand[6] = LSB_of(num_registers*2);\n\t\t\tcommand[7] = MSB_of(num_registers*2);\n\t\t} else\n\t\t\tcmdlen = 8;\n\n\t\t \n\t\tcommand[cmdlen-8] = (direction==DMA_TO_DEVICE ? 0x40 : 0xC0);\n\t\tcommand[cmdlen-7] = access |\n\t\t\t\t(direction==DMA_TO_DEVICE ?\n\t\t\t\t USBAT_CMD_COND_WRITE_BLOCK : USBAT_CMD_COND_READ_BLOCK);\n\t\tcommand[cmdlen-6] = data_reg;\n\t\tcommand[cmdlen-5] = status_reg;\n\t\tcommand[cmdlen-4] = timeout;\n\t\tcommand[cmdlen-3] = qualifier;\n\t\tcommand[cmdlen-2] = LSB_of(len);\n\t\tcommand[cmdlen-1] = MSB_of(len);\n\n\t\tresult = usbat_execute_command(us, command, cmdlen);\n\n\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (i==0) {\n\n\t\t\tfor (j=0; j<num_registers; j++) {\n\t\t\t\tdata[j<<1] = registers[j];\n\t\t\t\tdata[1+(j<<1)] = data_out[j];\n\t\t\t}\n\n\t\t\tresult = usbat_bulk_write(us, data, num_registers*2, 0);\n\t\t\tif (result != USB_STOR_XFER_GOOD)\n\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\t}\n\n\t\tresult = usb_stor_bulk_transfer_sg(us,\n\t\t\tpipe, buf, len, use_sg, NULL);\n\n\t\t \n\n\t\tif (result == USB_STOR_XFER_SHORT ||\n\t\t\t\tresult == USB_STOR_XFER_STALLED) {\n\n\t\t\t \n\n\t\t\tif (direction==DMA_FROM_DEVICE && i==0) {\n\t\t\t\tif (usb_stor_clear_halt(us,\n\t\t\t\t\t\tus->send_bulk_pipe) < 0)\n\t\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t\t}\n\n\t\t\t \n\n \t\t\tresult = usbat_read(us, USBAT_ATA, \n\t\t\t\tdirection==DMA_TO_DEVICE ?\n\t\t\t\t\tUSBAT_ATA_STATUS : USBAT_ATA_ALTSTATUS,\n\t\t\t\tstatus);\n\n\t\t\tif (result!=USB_STOR_XFER_GOOD)\n\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t\tif (*status & 0x01)  \n\t\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\t\tif (*status & 0x20)  \n\t\t\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\t\t\tusb_stor_dbg(us, \"Redoing %s\\n\",\n\t\t\t\t     direction == DMA_TO_DEVICE\n\t\t\t\t     ? \"write\" : \"read\");\n\n\t\t} else if (result != USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\telse\n\t\t\treturn usbat_wait_not_busy(us, minutes);\n\n\t}\n\n\tusb_stor_dbg(us, \"Bummer! %s bulk data 20 times failed\\n\",\n\t\t     direction == DMA_TO_DEVICE ? \"Writing\" : \"Reading\");\n\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\n \nstatic int usbat_multiple_write(struct us_data *us,\n\t\t\t\tunsigned char *registers,\n\t\t\t\tunsigned char *data_out,\n\t\t\t\tunsigned short num_registers)\n{\n\tint i, result;\n\tunsigned char *data = us->iobuf;\n\tunsigned char *command = us->iobuf;\n\n\tBUG_ON(num_registers > US_IOBUF_SIZE/2);\n\n\t \n\tcommand[0] = 0x40;\n\tcommand[1] = USBAT_ATA | USBAT_CMD_WRITE_REGS;\n\n\t \n\tcommand[2] = 0;\n\tcommand[3] = 0;\n\tcommand[4] = 0;\n\tcommand[5] = 0;\n\n\t \n\tcommand[6] = LSB_of(num_registers*2);\n\tcommand[7] = MSB_of(num_registers*2);\n\n\t \n\tresult = usbat_execute_command(us, command, 8);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tfor (i=0; i<num_registers; i++) {\n\t\tdata[i<<1] = registers[i];\n\t\tdata[1+(i<<1)] = data_out[i];\n\t}\n\n\t \n\tresult = usbat_bulk_write(us, data, num_registers*2, 0);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tif (usbat_get_device_type(us) == USBAT_DEV_HP8200)\n\t\treturn usbat_wait_not_busy(us, 0);\n\telse\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_read_blocks(struct us_data *us,\n\t\t\t     void* buffer,\n\t\t\t     int len,\n\t\t\t     int use_sg)\n{\n\tint result;\n\tunsigned char *command = us->iobuf;\n\n\tcommand[0] = 0xC0;\n\tcommand[1] = USBAT_ATA | USBAT_CMD_COND_READ_BLOCK;\n\tcommand[2] = USBAT_ATA_DATA;\n\tcommand[3] = USBAT_ATA_STATUS;\n\tcommand[4] = 0xFD;  \n\tcommand[5] = USBAT_QUAL_FCQ;\n\tcommand[6] = LSB_of(len);\n\tcommand[7] = MSB_of(len);\n\n\t \n\tresult = usbat_execute_command(us, command, 8);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\n\t \n\tresult = usbat_bulk_read(us, buffer, len, use_sg);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_write_blocks(struct us_data *us,\n\t\t\t      void* buffer,\n\t\t\t      int len,\n\t\t\t      int use_sg)\n{\n\tint result;\n\tunsigned char *command = us->iobuf;\n\n\tcommand[0] = 0x40;\n\tcommand[1] = USBAT_ATA | USBAT_CMD_COND_WRITE_BLOCK;\n\tcommand[2] = USBAT_ATA_DATA;\n\tcommand[3] = USBAT_ATA_STATUS;\n\tcommand[4] = 0xFD;  \n\tcommand[5] = USBAT_QUAL_FCQ;\n\tcommand[6] = LSB_of(len);\n\tcommand[7] = MSB_of(len);\n\n\t \n\tresult = usbat_execute_command(us, command, 8);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t\n\t \n\tresult = usbat_bulk_write(us, buffer, len, use_sg);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_read_user_io(struct us_data *us, unsigned char *data_flags)\n{\n\tint result;\n\n\tresult = usb_stor_ctrl_transfer(us,\n\t\tus->recv_ctrl_pipe,\n\t\tUSBAT_CMD_UIO,\n\t\t0xC0,\n\t\t0,\n\t\t0,\n\t\tdata_flags,\n\t\tUSBAT_UIO_READ);\n\n\tusb_stor_dbg(us, \"UIO register reads %02X\\n\", *data_flags);\n\n\treturn result;\n}\n\n \nstatic int usbat_write_user_io(struct us_data *us,\n\t\t\t       unsigned char enable_flags,\n\t\t\t       unsigned char data_flags)\n{\n\treturn usb_stor_ctrl_transfer(us,\n\t\tus->send_ctrl_pipe,\n\t\tUSBAT_CMD_UIO,\n\t\t0x40,\n\t\tshort_pack(enable_flags, data_flags),\n\t\t0,\n\t\tNULL,\n\t\tUSBAT_UIO_WRITE);\n}\n\n \nstatic int usbat_device_reset(struct us_data *us)\n{\n\tint rc;\n\n\t \n\trc = usbat_write_user_io(us,\n\t\t\t\t\t\t\t USBAT_UIO_DRVRST | USBAT_UIO_OE1 | USBAT_UIO_OE0,\n\t\t\t\t\t\t\t USBAT_UIO_EPAD | USBAT_UIO_1);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t\t\n\t \n\trc = usbat_write_user_io(us,\n\t\t\t\t\t\t\t USBAT_UIO_OE1  | USBAT_UIO_OE0,\n\t\t\t\t\t\t\t USBAT_UIO_EPAD | USBAT_UIO_1);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_device_enable_cdt(struct us_data *us)\n{\n\tint rc;\n\n\t \n\trc = usbat_write_user_io(us,\n\t\t\t\t\t\t\t USBAT_UIO_ACKD | USBAT_UIO_OE1  | USBAT_UIO_OE0,\n\t\t\t\t\t\t\t USBAT_UIO_EPAD | USBAT_UIO_1);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_flash_check_media_present(struct us_data *us,\n\t\t\t\t\t   unsigned char *uio)\n{\n\tif (*uio & USBAT_UIO_UI0) {\n\t\tusb_stor_dbg(us, \"no media detected\\n\");\n\t\treturn USBAT_FLASH_MEDIA_NONE;\n\t}\n\n\treturn USBAT_FLASH_MEDIA_CF;\n}\n\n \nstatic int usbat_flash_check_media_changed(struct us_data *us,\n\t\t\t\t\t   unsigned char *uio)\n{\n\tif (*uio & USBAT_UIO_0) {\n\t\tusb_stor_dbg(us, \"media change detected\\n\");\n\t\treturn USBAT_FLASH_MEDIA_CHANGED;\n\t}\n\n\treturn USBAT_FLASH_MEDIA_SAME;\n}\n\n \nstatic int usbat_flash_check_media(struct us_data *us,\n\t\t\t\t   struct usbat_info *info)\n{\n\tint rc;\n\tunsigned char *uio = us->iobuf;\n\n\trc = usbat_read_user_io(us, uio);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\trc = usbat_flash_check_media_present(us, uio);\n\tif (rc == USBAT_FLASH_MEDIA_NONE) {\n\t\tinfo->sense_key = 0x02;\n\t\tinfo->sense_asc = 0x3A;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\t \n\trc = usbat_flash_check_media_changed(us, uio);\n\tif (rc == USBAT_FLASH_MEDIA_CHANGED) {\n\n\t\t \n\t\trc = usbat_device_reset(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\t\trc = usbat_device_enable_cdt(us);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\tmsleep(50);\n\n\t\trc = usbat_read_user_io(us, uio);\n\t\tif (rc != USB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t\n\t\tinfo->sense_key = UNIT_ATTENTION;\n\t\tinfo->sense_asc = 0x28;\n\t\tinfo->sense_ascq = 0x00;\n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_identify_device(struct us_data *us,\n\t\t\t\t struct usbat_info *info)\n{\n\tint rc;\n\tunsigned char status;\n\n\tif (!us || !info)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\trc = usbat_device_reset(us);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\treturn rc;\n\tmsleep(500);\n\n\t \n\trc = usbat_write(us, USBAT_ATA, USBAT_ATA_CMD, 0xA1);\n \tif (rc != USB_STOR_XFER_GOOD)\n \t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\trc = usbat_get_status(us, &status);\n \tif (rc != USB_STOR_XFER_GOOD)\n \t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\tif (status == 0xA1 || !(status & 0x01)) {\n\t\t \n\t\tusb_stor_dbg(us, \"Detected HP8200 CDRW\\n\");\n\t\tinfo->devicetype = USBAT_DEV_HP8200;\n\t} else {\n\t\t \n\t\tusb_stor_dbg(us, \"Detected Flash reader/writer\\n\");\n\t\tinfo->devicetype = USBAT_DEV_FLASH;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int usbat_set_transport(struct us_data *us,\n\t\t\t       struct usbat_info *info,\n\t\t\t       int devicetype)\n{\n\n\tif (!info->devicetype)\n\t\tinfo->devicetype = devicetype;\n\n\tif (!info->devicetype)\n\t\tusbat_identify_device(us, info);\n\n\tswitch (info->devicetype) {\n\tdefault:\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tcase  USBAT_DEV_HP8200:\n\t\tus->transport = usbat_hp8200e_transport;\n\t\tbreak;\n\n\tcase USBAT_DEV_FLASH:\n\t\tus->transport = usbat_flash_transport;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int usbat_flash_get_sector_count(struct us_data *us,\n\t\t\t\t\tstruct usbat_info *info)\n{\n\tunsigned char registers[3] = {\n\t\tUSBAT_ATA_SECCNT,\n\t\tUSBAT_ATA_DEVICE,\n\t\tUSBAT_ATA_CMD,\n\t};\n\tunsigned char  command[3] = { 0x01, 0xA0, 0xEC };\n\tunsigned char *reply;\n\tunsigned char status;\n\tint rc;\n\n\tif (!us || !info)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\treply = kmalloc(512, GFP_NOIO);\n\tif (!reply)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t \n\trc = usbat_multiple_write(us, registers, command, 3);\n\tif (rc != USB_STOR_XFER_GOOD) {\n\t\tusb_stor_dbg(us, \"Gah! identify_device failed\\n\");\n\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto leave;\n\t}\n\n\t \n\tif (usbat_get_status(us, &status) != USB_STOR_XFER_GOOD) {\n\t\trc = USB_STOR_TRANSPORT_ERROR;\n\t\tgoto leave;\n\t}\n\n\tmsleep(100);\n\n\t \n\trc = usbat_read_block(us, reply, 512, 0);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\tgoto leave;\n\n\tinfo->sectors = ((u32)(reply[117]) << 24) |\n\t\t((u32)(reply[116]) << 16) |\n\t\t((u32)(reply[115]) <<  8) |\n\t\t((u32)(reply[114])      );\n\n\trc = USB_STOR_TRANSPORT_GOOD;\n\n leave:\n\tkfree(reply);\n\treturn rc;\n}\n\n \nstatic int usbat_flash_read_data(struct us_data *us,\n\t\t\t\t\t\t\t\t struct usbat_info *info,\n\t\t\t\t\t\t\t\t u32 sector,\n\t\t\t\t\t\t\t\t u32 sectors)\n{\n\tunsigned char registers[7] = {\n\t\tUSBAT_ATA_FEATURES,\n\t\tUSBAT_ATA_SECCNT,\n\t\tUSBAT_ATA_SECNUM,\n\t\tUSBAT_ATA_LBA_ME,\n\t\tUSBAT_ATA_LBA_HI,\n\t\tUSBAT_ATA_DEVICE,\n\t\tUSBAT_ATA_STATUS,\n\t};\n\tunsigned char command[7];\n\tunsigned char *buffer;\n\tunsigned char  thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\tresult = usbat_flash_check_media(us, info);\n\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\treturn result;\n\n\t \n\n\tif (sector > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\ttotallen = sectors * info->ssize;\n\n\t \n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t \n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n \n\t\t \n\t\tusbat_pack_ata_sector_cmd(command, thistime, sector, 0x20);\n\n\t\t \n\t\tresult = usbat_multiple_write(us, registers, command, 7);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tgoto leave;\n\n\t\t \n\t\tresult = usbat_read_blocks(us, buffer, len, 0);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tgoto leave;\n  \t \n\t\tusb_stor_dbg(us, \"%d bytes\\n\", len);\n\t\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t\t &sg, &sg_offset, TO_XFER_BUF);\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_GOOD;\n\nleave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\n \nstatic int usbat_flash_write_data(struct us_data *us,\n\t\t\t\t\t\t\t\t  struct usbat_info *info,\n\t\t\t\t\t\t\t\t  u32 sector,\n\t\t\t\t\t\t\t\t  u32 sectors)\n{\n\tunsigned char registers[7] = {\n\t\tUSBAT_ATA_FEATURES,\n\t\tUSBAT_ATA_SECCNT,\n\t\tUSBAT_ATA_SECNUM,\n\t\tUSBAT_ATA_LBA_ME,\n\t\tUSBAT_ATA_LBA_HI,\n\t\tUSBAT_ATA_DEVICE,\n\t\tUSBAT_ATA_STATUS,\n\t};\n\tunsigned char command[7];\n\tunsigned char *buffer;\n\tunsigned char  thistime;\n\tunsigned int totallen, alloclen;\n\tint len, result;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\tresult = usbat_flash_check_media(us, info);\n\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\treturn result;\n\n\t \n\n\tif (sector > 0x0FFFFFFF)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\ttotallen = sectors * info->ssize;\n\n\t \n\n\talloclen = min(totallen, 65536u);\n\tbuffer = kmalloc(alloclen, GFP_NOIO);\n\tif (buffer == NULL)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\tdo {\n\t\t \n\t\tlen = min(totallen, alloclen);\n\t\tthistime = (len / info->ssize) & 0xff;\n\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, us->srb,\n\t\t\t\t\t &sg, &sg_offset, FROM_XFER_BUF);\n\n\t\t \n\t\tusbat_pack_ata_sector_cmd(command, thistime, sector, 0x30);\n\n\t\t \n\t\tresult = usbat_multiple_write(us, registers, command, 7);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tgoto leave;\n\n\t\t \n\t\tresult = usbat_write_blocks(us, buffer, len, 0);\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tgoto leave;\n\n\t\tsector += thistime;\n\t\ttotallen -= len;\n\t} while (totallen > 0);\n\n\tkfree(buffer);\n\treturn result;\n\nleave:\n\tkfree(buffer);\n\treturn USB_STOR_TRANSPORT_ERROR;\n}\n\n \nstatic int usbat_hp8200e_handle_read10(struct us_data *us,\n\t\t\t\t       unsigned char *registers,\n\t\t\t\t       unsigned char *data,\n\t\t\t\t       struct scsi_cmnd *srb)\n{\n\tint result = USB_STOR_TRANSPORT_GOOD;\n\tunsigned char *buffer;\n\tunsigned int len;\n\tunsigned int sector;\n\tunsigned int sg_offset = 0;\n\tstruct scatterlist *sg = NULL;\n\n\tusb_stor_dbg(us, \"transfersize %d\\n\", srb->transfersize);\n\n\tif (scsi_bufflen(srb) < 0x10000) {\n\n\t\tresult = usbat_hp8200e_rw_block_test(us, USBAT_ATA, \n\t\t\tregisters, data, 19,\n\t\t\tUSBAT_ATA_DATA, USBAT_ATA_STATUS, 0xFD,\n\t\t\t(USBAT_QUAL_FCQ | USBAT_QUAL_ALQ),\n\t\t\tDMA_FROM_DEVICE,\n\t\t\tscsi_sglist(srb),\n\t\t\tscsi_bufflen(srb), scsi_sg_count(srb), 1);\n\n\t\treturn result;\n\t}\n\n\t \n\n\tif (data[7+0] == GPCMD_READ_CD) {\n\t\tlen = short_pack(data[7+9], data[7+8]);\n\t\tlen <<= 16;\n\t\tlen |= data[7+7];\n\t\tusb_stor_dbg(us, \"GPCMD_READ_CD: len %d\\n\", len);\n\t\tsrb->transfersize = scsi_bufflen(srb)/len;\n\t}\n\n\tif (!srb->transfersize)  {\n\t\tsrb->transfersize = 2048;  \n\t\tusb_stor_dbg(us, \"transfersize 0, forcing %d\\n\",\n\t\t\t     srb->transfersize);\n\t}\n\n\t \n\n\tlen = (65535/srb->transfersize) * srb->transfersize;\n\tusb_stor_dbg(us, \"Max read is %d bytes\\n\", len);\n\tlen = min(len, scsi_bufflen(srb));\n\tbuffer = kmalloc(len, GFP_NOIO);\n\tif (buffer == NULL)  \n\t\treturn USB_STOR_TRANSPORT_FAILED;\n\tsector = short_pack(data[7+3], data[7+2]);\n\tsector <<= 16;\n\tsector |= short_pack(data[7+5], data[7+4]);\n\ttransferred = 0;\n\n\twhile (transferred != scsi_bufflen(srb)) {\n\n\t\tif (len > scsi_bufflen(srb) - transferred)\n\t\t\tlen = scsi_bufflen(srb) - transferred;\n\n\t\tdata[3] = len&0xFF; \t   \n\t\tdata[4] = (len>>8)&0xFF;   \n\n\t\t \n\n\t\tdata[7+2] = MSB_of(sector>>16);  \n\t\tdata[7+3] = LSB_of(sector>>16);\n\t\tdata[7+4] = MSB_of(sector&0xFFFF);\n\t\tdata[7+5] = LSB_of(sector&0xFFFF);\n\t\tif (data[7+0] == GPCMD_READ_CD)\n\t\t\tdata[7+6] = 0;\n\t\tdata[7+7] = MSB_of(len / srb->transfersize);  \n\t\tdata[7+8] = LSB_of(len / srb->transfersize);  \n\n\t\tresult = usbat_hp8200e_rw_block_test(us, USBAT_ATA, \n\t\t\tregisters, data, 19,\n\t\t\tUSBAT_ATA_DATA, USBAT_ATA_STATUS, 0xFD, \n\t\t\t(USBAT_QUAL_FCQ | USBAT_QUAL_ALQ),\n\t\t\tDMA_FROM_DEVICE,\n\t\t\tbuffer,\n\t\t\tlen, 0, 1);\n\n\t\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\t\tbreak;\n\n\t\t \n\t\tusb_stor_access_xfer_buf(buffer, len, srb,\n\t\t\t\t &sg, &sg_offset, TO_XFER_BUF);\n\n\t\t \n\n\t\ttransferred += len;\n\t\tsector += len / srb->transfersize;\n\n\t}  \n\n\tkfree(buffer);\n\treturn result;\n}\n\nstatic int usbat_select_and_test_registers(struct us_data *us)\n{\n\tint selector;\n\tunsigned char *status = us->iobuf;\n\n\t \n\tfor (selector = 0xA0; selector <= 0xB0; selector += 0x10) {\n\t\tif (usbat_write(us, USBAT_ATA, USBAT_ATA_DEVICE, selector) !=\n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_STATUS, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_DEVICE, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_ME, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_HI, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_write(us, USBAT_ATA, USBAT_ATA_LBA_ME, 0x55) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_write(us, USBAT_ATA, USBAT_ATA_LBA_HI, 0xAA) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_ME, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_ME, status) != \n\t\t\t\tUSB_STOR_XFER_GOOD)\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\treturn USB_STOR_TRANSPORT_GOOD;\n}\n\n \nstatic int init_usbat(struct us_data *us, int devicetype)\n{\n\tint rc;\n\tstruct usbat_info *info;\n\tunsigned char subcountH = USBAT_ATA_LBA_HI;\n\tunsigned char subcountL = USBAT_ATA_LBA_ME;\n\tunsigned char *status = us->iobuf;\n\n\tus->extra = kzalloc(sizeof(struct usbat_info), GFP_NOIO);\n\tif (!us->extra)\n\t\treturn -ENOMEM;\n\n\tinfo = (struct usbat_info *) (us->extra);\n\n\t \n\trc = usbat_write_user_io(us,\n\t\t\t\t USBAT_UIO_OE1 | USBAT_UIO_OE0,\n\t\t\t\t USBAT_UIO_EPAD | USBAT_UIO_1);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 1\\n\");\n\n\tmsleep(2000);\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 2\\n\");\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 3\\n\");\n\n\trc = usbat_select_and_test_registers(us);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 4\\n\");\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 5\\n\");\n\n\t \n\trc = usbat_device_enable_cdt(us);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 6\\n\");\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 7\\n\");\n\n\tmsleep(1400);\n\n\trc = usbat_read_user_io(us, status);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 8\\n\");\n\n\trc = usbat_select_and_test_registers(us);\n\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 9\\n\");\n\n\t \n\tif (usbat_set_transport(us, info, devicetype))\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 10\\n\");\n\n\tif (usbat_get_device_type(us) == USBAT_DEV_FLASH) { \n\t\tsubcountH = 0x02;\n\t\tsubcountL = 0x00;\n\t}\n\trc = usbat_set_shuttle_features(us, (USBAT_FEAT_ETEN | USBAT_FEAT_ET2 | USBAT_FEAT_ET1),\n\t\t\t\t\t\t\t\t\t0x00, 0x88, 0x08, subcountH, subcountL);\n\tif (rc != USB_STOR_XFER_GOOD)\n\t\treturn -EIO;\n\n\tusb_stor_dbg(us, \"INIT 11\\n\");\n\n\treturn 0;\n}\n\n \nstatic int usbat_hp8200e_transport(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint result;\n\tunsigned char *status = us->iobuf;\n\tunsigned char registers[32];\n\tunsigned char data[32];\n\tunsigned int len;\n\tint i;\n\n\tlen = scsi_bufflen(srb);\n\n\t \n\n\tregisters[0] = USBAT_ATA_FEATURES;\n\tregisters[1] = USBAT_ATA_SECCNT;\n\tregisters[2] = USBAT_ATA_SECNUM;\n\tregisters[3] = USBAT_ATA_LBA_ME;\n\tregisters[4] = USBAT_ATA_LBA_HI;\n\tregisters[5] = USBAT_ATA_DEVICE;\n\tregisters[6] = USBAT_ATA_CMD;\n\tdata[0] = 0x00;\n\tdata[1] = 0x00;\n\tdata[2] = 0x00;\n\tdata[3] = len&0xFF; \t\t \n\tdata[4] = (len>>8)&0xFF; \t \n\tdata[5] = 0xB0; \t\t \n\tdata[6] = 0xA0; \t\t \n\n\tfor (i=7; i<19; i++) {\n\t\tregisters[i] = 0x10;\n\t\tdata[i] = (i-7 >= srb->cmd_len) ? 0 : srb->cmnd[i-7];\n\t}\n\n\tresult = usbat_get_status(us, status);\n\tusb_stor_dbg(us, \"Status = %02X\\n\", *status);\n\tif (result != USB_STOR_XFER_GOOD)\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\tif (srb->cmnd[0] == TEST_UNIT_READY)\n\t\ttransferred = 0;\n\n\tif (srb->sc_data_direction == DMA_TO_DEVICE) {\n\n\t\tresult = usbat_hp8200e_rw_block_test(us, USBAT_ATA, \n\t\t\tregisters, data, 19,\n\t\t\tUSBAT_ATA_DATA, USBAT_ATA_STATUS, 0xFD,\n\t\t\t(USBAT_QUAL_FCQ | USBAT_QUAL_ALQ),\n\t\t\tDMA_TO_DEVICE,\n\t\t\tscsi_sglist(srb),\n\t\t\tlen, scsi_sg_count(srb), 10);\n\n\t\tif (result == USB_STOR_TRANSPORT_GOOD) {\n\t\t\ttransferred += len;\n\t\t\tusb_stor_dbg(us, \"Wrote %08X bytes\\n\", transferred);\n\t\t}\n\n\t\treturn result;\n\n\t} else if (srb->cmnd[0] == READ_10 ||\n\t\t   srb->cmnd[0] == GPCMD_READ_CD) {\n\n\t\treturn usbat_hp8200e_handle_read10(us, registers, data, srb);\n\n\t}\n\n\tif (len > 0xFFFF) {\n\t\tusb_stor_dbg(us, \"Error: len = %08X... what do I do now?\\n\",\n\t\t\t     len);\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tresult = usbat_multiple_write(us, registers, data, 7);\n\n\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\treturn result;\n\n\t \n\n\tresult = usbat_write_block(us, USBAT_ATA, srb->cmnd, 12,\n\t\t\t\t   srb->cmnd[0] == GPCMD_BLANK ? 75 : 10, 0);\n\n\tif (result != USB_STOR_TRANSPORT_GOOD)\n\t\treturn result;\n\n\t \n\n\tif (len != 0 && (srb->sc_data_direction == DMA_FROM_DEVICE)) {\n\n\t\t \n\n\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_ME, status) != \n\t\t    \tUSB_STOR_XFER_GOOD) {\n\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t}\n\n\t\tif (len > 0xFF) {  \n\t\t\tlen = *status;\n\t\t\tif (usbat_read(us, USBAT_ATA, USBAT_ATA_LBA_HI, status) !=\n\t\t\t\t    USB_STOR_XFER_GOOD) {\n\t\t\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t\t\t}\n\t\t\tlen += ((unsigned int) *status)<<8;\n\t\t}\n\t\telse\n\t\t\tlen = *status;\n\n\n\t\tresult = usbat_read_block(us, scsi_sglist(srb), len,\n\t\t\t                                   scsi_sg_count(srb));\n\t}\n\n\treturn result;\n}\n\n \nstatic int usbat_flash_transport(struct scsi_cmnd * srb, struct us_data *us)\n{\n\tint rc;\n\tstruct usbat_info *info = (struct usbat_info *) (us->extra);\n\tunsigned long block, blocks;\n\tunsigned char *ptr = us->iobuf;\n\tstatic unsigned char inquiry_response[36] = {\n\t\t0x00, 0x80, 0x00, 0x01, 0x1F, 0x00, 0x00, 0x00\n\t};\n\n\tif (srb->cmnd[0] == INQUIRY) {\n\t\tusb_stor_dbg(us, \"INQUIRY - Returning bogus response\\n\");\n\t\tmemcpy(ptr, inquiry_response, sizeof(inquiry_response));\n\t\tfill_inquiry_response(us, ptr, 36);\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == READ_CAPACITY) {\n\t\trc = usbat_flash_check_media(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\trc = usbat_flash_get_sector_count(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\t \n\t\tinfo->ssize = 0x200;\n\t\tusb_stor_dbg(us, \"READ_CAPACITY: %ld sectors, %ld bytes per sector\\n\",\n\t\t\t     info->sectors, info->ssize);\n\n\t\t \n\t\t((__be32 *) ptr)[0] = cpu_to_be32(info->sectors - 1);\n\t\t((__be32 *) ptr)[1] = cpu_to_be32(info->ssize);\n\t\tusb_stor_set_xfer_buf(ptr, 8, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == MODE_SELECT_10) {\n\t\tusb_stor_dbg(us, \"Gah! MODE_SELECT_10\\n\");\n\t\treturn USB_STOR_TRANSPORT_ERROR;\n\t}\n\n\tif (srb->cmnd[0] == READ_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t\t\t((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"READ_10: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn usbat_flash_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == READ_12) {\n\t\t \n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t        ((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t         ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"READ_12: read block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn usbat_flash_read_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_10) {\n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t        ((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[7]) << 8) | ((u32)(srb->cmnd[8]));\n\n\t\tusb_stor_dbg(us, \"WRITE_10: write block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn usbat_flash_write_data(us, info, block, blocks);\n\t}\n\n\tif (srb->cmnd[0] == WRITE_12) {\n\t\t \n\t\tblock = ((u32)(srb->cmnd[2]) << 24) | ((u32)(srb->cmnd[3]) << 16) |\n\t\t        ((u32)(srb->cmnd[4]) <<  8) | ((u32)(srb->cmnd[5]));\n\n\t\tblocks = ((u32)(srb->cmnd[6]) << 24) | ((u32)(srb->cmnd[7]) << 16) |\n\t\t         ((u32)(srb->cmnd[8]) <<  8) | ((u32)(srb->cmnd[9]));\n\n\t\tusb_stor_dbg(us, \"WRITE_12: write block 0x%04lx  count %ld\\n\",\n\t\t\t     block, blocks);\n\t\treturn usbat_flash_write_data(us, info, block, blocks);\n\t}\n\n\n\tif (srb->cmnd[0] == TEST_UNIT_READY) {\n\t\tusb_stor_dbg(us, \"TEST_UNIT_READY\\n\");\n\n\t\trc = usbat_flash_check_media(us, info);\n\t\tif (rc != USB_STOR_TRANSPORT_GOOD)\n\t\t\treturn rc;\n\n\t\treturn usbat_check_status(us);\n\t}\n\n\tif (srb->cmnd[0] == REQUEST_SENSE) {\n\t\tusb_stor_dbg(us, \"REQUEST_SENSE\\n\");\n\n\t\tmemset(ptr, 0, 18);\n\t\tptr[0] = 0xF0;\n\t\tptr[2] = info->sense_key;\n\t\tptr[7] = 11;\n\t\tptr[12] = info->sense_asc;\n\t\tptr[13] = info->sense_ascq;\n\t\tusb_stor_set_xfer_buf(ptr, 18, srb);\n\n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tif (srb->cmnd[0] == ALLOW_MEDIUM_REMOVAL) {\n\t\t \n\t\treturn USB_STOR_TRANSPORT_GOOD;\n\t}\n\n\tusb_stor_dbg(us, \"Gah! Unknown command: %d (0x%x)\\n\",\n\t\t     srb->cmnd[0], srb->cmnd[0]);\n\tinfo->sense_key = 0x05;\n\tinfo->sense_asc = 0x20;\n\tinfo->sense_ascq = 0x00;\n\treturn USB_STOR_TRANSPORT_FAILED;\n}\n\nstatic int init_usbat_cd(struct us_data *us)\n{\n\treturn init_usbat(us, USBAT_DEV_HP8200);\n}\n\nstatic int init_usbat_flash(struct us_data *us)\n{\n\treturn init_usbat(us, USBAT_DEV_FLASH);\n}\n\nstatic struct scsi_host_template usbat_host_template;\n\nstatic int usbat_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - usbat_usb_ids) + usbat_unusual_dev_list,\n\t\t\t&usbat_host_template);\n\tif (result)\n\t\treturn result;\n\n\t \n\tus->transport_name = \"Shuttle USBAT\";\n\tus->transport = usbat_flash_transport;\n\tus->transport_reset = usb_stor_CB_reset;\n\tus->max_lun = 0;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver usbat_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tusbat_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tusbat_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(usbat_driver, usbat_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}