{
  "module_name": "isd200.c",
  "hash_id": "f69399f432522fca2f13917b00e8926dfc68d455b2b8a7d6886933288036f260",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/isd200.c",
  "human_readable_source": "\n \n\n\n \n\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/ata.h>\n#include <linux/hdreg.h>\n#include <linux/scatterlist.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n\n#include \"usb.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n#include \"debug.h\"\n#include \"scsiglue.h\"\n\n#define DRV_NAME \"ums-isd200\"\n\nMODULE_DESCRIPTION(\"Driver for In-System Design, Inc. ISD200 ASIC\");\nMODULE_AUTHOR(\"Bj\u00f6rn Stenberg <bjorn@haxx.se>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_IMPORT_NS(USB_STORAGE);\n\nstatic int isd200_Initialization(struct us_data *us);\n\n\n \n#define UNUSUAL_DEV(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendorName, productName, useProtocol, useTransport, \\\n\t\t    initFunction, flags) \\\n{ USB_DEVICE_VER(id_vendor, id_product, bcdDeviceMin, bcdDeviceMax), \\\n  .driver_info = (flags) }\n\nstatic struct usb_device_id isd200_usb_ids[] = {\n#\tinclude \"unusual_isd200.h\"\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, isd200_usb_ids);\n\n#undef UNUSUAL_DEV\n\n \n#define UNUSUAL_DEV(idVendor, idProduct, bcdDeviceMin, bcdDeviceMax, \\\n\t\t    vendor_name, product_name, use_protocol, use_transport, \\\n\t\t    init_function, Flags) \\\n{ \\\n\t.vendorName = vendor_name,\t\\\n\t.productName = product_name,\t\\\n\t.useProtocol = use_protocol,\t\\\n\t.useTransport = use_transport,\t\\\n\t.initFunction = init_function,\t\\\n}\n\nstatic struct us_unusual_dev isd200_unusual_dev_list[] = {\n#\tinclude \"unusual_isd200.h\"\n\t{ }\t\t \n};\n\n#undef UNUSUAL_DEV\n\n \n\n#define ISD200_ENUM_BSY_TIMEOUT\t\t35\n#define ISD200_ENUM_DETECT_TIMEOUT      30\n#define ISD200_DEFAULT_TIMEOUT\t\t30\n\n \n#define DF_ATA_DEVICE\t\t0x0001\n#define DF_MEDIA_STATUS_ENABLED\t0x0002\n#define DF_REMOVABLE_MEDIA\t0x0004\n\n \n#define CAPABILITY_DMA\t\t0x01\n#define CAPABILITY_LBA\t\t0x02\n\n \n#define COMMANDSET_REMOVABLE\t0x02\n#define COMMANDSET_MEDIA_STATUS 0x10\n\n \n#define ATA_ADDRESS_DEVHEAD_STD      0xa0\n#define ATA_ADDRESS_DEVHEAD_LBA_MODE 0x40    \n#define ATA_ADDRESS_DEVHEAD_SLAVE    0x10\n\n \n#define ACTION_SELECT_0\t     0x01\n#define ACTION_SELECT_1\t     0x02\n#define ACTION_SELECT_2\t     0x04\n#define ACTION_SELECT_3\t     0x08\n#define ACTION_SELECT_4\t     0x10\n#define ACTION_SELECT_5\t     0x20\n#define ACTION_SELECT_6\t     0x40\n#define ACTION_SELECT_7\t     0x80\n\n \n#define REG_ALTERNATE_STATUS\t0x01\n#define REG_DEVICE_CONTROL\t0x01\n#define REG_ERROR\t\t0x02\n#define REG_FEATURES\t\t0x02\n#define REG_SECTOR_COUNT\t0x04\n#define REG_SECTOR_NUMBER\t0x08\n#define REG_CYLINDER_LOW\t0x10\n#define REG_CYLINDER_HIGH\t0x20\n#define REG_DEVICE_HEAD\t\t0x40\n#define REG_STATUS\t\t0x80\n#define REG_COMMAND\t\t0x80\n\n \n#define ATA_REG_ERROR_OFFSET\t\t1\n#define ATA_REG_LCYL_OFFSET\t\t4\n#define ATA_REG_HCYL_OFFSET\t\t5\n#define ATA_REG_STATUS_OFFSET\t\t7\n\n \n#define ATA_ERROR_MEDIA_CHANGE\t\t0x20\n\n \n#define ATA_COMMAND_GET_MEDIA_STATUS\t0xDA\n#define ATA_COMMAND_MEDIA_EJECT\t\t0xED\n\n \n#define ATA_DC_DISABLE_INTERRUPTS\t0x02\n#define ATA_DC_RESET_CONTROLLER\t\t0x04\n#define ATA_DC_REENABLE_CONTROLLER\t0x00\n\n  \n\n#define ISD200_ERROR\t\t-1\n#define ISD200_GOOD\t\t 0\n\n \n\n#define ISD200_TRANSPORT_GOOD       0    \n#define ISD200_TRANSPORT_FAILED     1    \n#define ISD200_TRANSPORT_ERROR      2    \n\n \n#define\tACTION_READ_STATUS\t0\n#define\tACTION_RESET\t\t1\n#define\tACTION_REENABLE\t\t2\n#define\tACTION_SOFT_RESET\t3\n#define\tACTION_ENUM\t\t4\n#define\tACTION_IDENTIFY\t\t5\n\n\n \n\n\nunion ata_cdb {\n\tstruct {\n\t\tunsigned char SignatureByte0;\n\t\tunsigned char SignatureByte1;\n\t\tunsigned char ActionSelect;\n\t\tunsigned char RegisterSelect;\n\t\tunsigned char TransferBlockSize;\n\t\tunsigned char WriteData3F6;\n\t\tunsigned char WriteData1F1;\n\t\tunsigned char WriteData1F2;\n\t\tunsigned char WriteData1F3;\n\t\tunsigned char WriteData1F4;\n\t\tunsigned char WriteData1F5;\n\t\tunsigned char WriteData1F6;\n\t\tunsigned char WriteData1F7;\n\t\tunsigned char Reserved[3];\n\t} generic;\n\n\tstruct {\n\t\tunsigned char SignatureByte0;\n\t\tunsigned char SignatureByte1;\n\t\tunsigned char ActionSelect;\n\t\tunsigned char RegisterSelect;\n\t\tunsigned char TransferBlockSize;\n\t\tunsigned char AlternateStatusByte;\n\t\tunsigned char ErrorByte;\n\t\tunsigned char SectorCountByte;\n\t\tunsigned char SectorNumberByte;\n\t\tunsigned char CylinderLowByte;\n\t\tunsigned char CylinderHighByte;\n\t\tunsigned char DeviceHeadByte;\n\t\tunsigned char StatusByte;\n\t\tunsigned char Reserved[3];\n\t} read;\n\n\tstruct {\n\t\tunsigned char SignatureByte0;\n\t\tunsigned char SignatureByte1;\n\t\tunsigned char ActionSelect;\n\t\tunsigned char RegisterSelect;\n\t\tunsigned char TransferBlockSize;\n\t\tunsigned char DeviceControlByte;\n\t\tunsigned char FeaturesByte;\n\t\tunsigned char SectorCountByte;\n\t\tunsigned char SectorNumberByte;\n\t\tunsigned char CylinderLowByte;\n\t\tunsigned char CylinderHighByte;\n\t\tunsigned char DeviceHeadByte;\n\t\tunsigned char CommandByte;\n\t\tunsigned char Reserved[3];\n\t} write;\n};\n\n\n \n\n \n#define DIRECT_ACCESS_DEVICE\t    0x00     \n#define DEVICE_REMOVABLE\t\t0x80\n\nstruct inquiry_data {\n   \tunsigned char DeviceType;\n\tunsigned char DeviceTypeModifier;\n\tunsigned char Versions;\n\tunsigned char Format; \n\tunsigned char AdditionalLength;\n\tunsigned char Reserved[2];\n\tunsigned char Capability;\n\tunsigned char VendorId[8];\n\tunsigned char ProductId[16];\n\tunsigned char ProductRevisionLevel[4];\n\tunsigned char VendorSpecific[20];\n\tunsigned char Reserved3[40];\n} __attribute__ ((packed));\n\n \n\n#define INQUIRYDATABUFFERSIZE 36\n\n\n \n\n#define ATACFG_TIMING\t  0x0f\n#define ATACFG_ATAPI_RESET     0x10\n#define ATACFG_MASTER\t  0x20\n#define ATACFG_BLOCKSIZE       0xa0\n\n#define ATACFGE_LAST_LUN       0x07\n#define ATACFGE_DESC_OVERRIDE  0x08\n#define ATACFGE_STATE_SUSPEND  0x10\n#define ATACFGE_SKIP_BOOT      0x20\n#define ATACFGE_CONF_DESC2     0x40\n#define ATACFGE_INIT_STATUS    0x80\n\n#define CFG_CAPABILITY_SRST    0x01\n\nstruct isd200_config {\n\tunsigned char EventNotification;\n\tunsigned char ExternalClock;\n\tunsigned char ATAInitTimeout;\n\tunsigned char ATAConfig;\n\tunsigned char ATAMajorCommand;\n\tunsigned char ATAMinorCommand;\n\tunsigned char ATAExtraConfig;\n\tunsigned char Capability;\n}__attribute__ ((packed));\n\n\n \n\nstruct isd200_info {\n\tstruct inquiry_data InquiryData;\n\tu16 *id;\n\tstruct isd200_config ConfigData;\n\tunsigned char *RegsBuf;\n\tunsigned char ATARegs[8];\n\tunsigned char DeviceHead;\n\tunsigned char DeviceFlags;\n\n\t \n\tunsigned char MaxLUNs;\n\tunsigned char cmnd[MAX_COMMAND_SIZE];\n\tstruct scsi_cmnd srb;\n\tstruct scatterlist sg;\n};\n\n\n \n\nstruct read_capacity_data {\n\t__be32 LogicalBlockAddress;\n\t__be32 BytesPerBlock;\n};\n\n \n\nstruct read_block_limits {\n\tunsigned char Reserved;\n\tunsigned char BlockMaximumSize[3];\n\tunsigned char BlockMinimumSize[2];\n};\n\n\n \n\n#define SENSE_ERRCODE\t   0x7f\n#define SENSE_ERRCODE_VALID     0x80\n#define SENSE_FLAG_SENSE_KEY    0x0f\n#define SENSE_FLAG_BAD_LENGTH   0x20\n#define SENSE_FLAG_END_OF_MEDIA 0x40\n#define SENSE_FLAG_FILE_MARK    0x80\nstruct sense_data {\n\tunsigned char ErrorCode;\n\tunsigned char SegmentNumber;\n\tunsigned char Flags;\n\tunsigned char Information[4];\n\tunsigned char AdditionalSenseLength;\n\tunsigned char CommandSpecificInformation[4];\n\tunsigned char AdditionalSenseCode;\n\tunsigned char AdditionalSenseCodeQualifier;\n\tunsigned char FieldReplaceableUnitCode;\n\tunsigned char SenseKeySpecific[3];\n} __attribute__ ((packed));\n\n \n\n#define SENSE_BUFFER_SIZE 18\n\n \n\n \nstatic void isd200_build_sense(struct us_data *us, struct scsi_cmnd *srb)\n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tstruct sense_data *buf = (struct sense_data *) &srb->sense_buffer[0];\n\tunsigned char error = info->ATARegs[ATA_REG_ERROR_OFFSET];\n\n\tif(error & ATA_ERROR_MEDIA_CHANGE) {\n\t\tbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\n\t\tbuf->AdditionalSenseLength = 0xb;\n\t\tbuf->Flags = UNIT_ATTENTION;\n\t\tbuf->AdditionalSenseCode = 0;\n\t\tbuf->AdditionalSenseCodeQualifier = 0;\n\t} else if (error & ATA_MCR) {\n\t\tbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\n\t\tbuf->AdditionalSenseLength = 0xb;\n\t\tbuf->Flags =  UNIT_ATTENTION;\n\t\tbuf->AdditionalSenseCode = 0;\n\t\tbuf->AdditionalSenseCodeQualifier = 0;\n\t} else if (error & ATA_TRK0NF) {\n\t\tbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\n\t\tbuf->AdditionalSenseLength = 0xb;\n\t\tbuf->Flags =  NOT_READY;\n\t\tbuf->AdditionalSenseCode = 0;\n\t\tbuf->AdditionalSenseCodeQualifier = 0;\n\t} else if (error & ATA_UNC) {\n\t\tbuf->ErrorCode = 0x70 | SENSE_ERRCODE_VALID;\n\t\tbuf->AdditionalSenseLength = 0xb;\n\t\tbuf->Flags =  DATA_PROTECT;\n\t\tbuf->AdditionalSenseCode = 0;\n\t\tbuf->AdditionalSenseCodeQualifier = 0;\n\t} else {\n\t\tbuf->ErrorCode = 0;\n\t\tbuf->AdditionalSenseLength = 0;\n\t\tbuf->Flags =  0;\n\t\tbuf->AdditionalSenseCode = 0;\n\t\tbuf->AdditionalSenseCodeQualifier = 0;\n\t}\n}\n\n\n \n\n \nstatic void isd200_set_srb(struct isd200_info *info,\n\tenum dma_data_direction dir, void* buff, unsigned bufflen)\n{\n\tstruct scsi_cmnd *srb = &info->srb;\n\n\tif (buff)\n\t\tsg_init_one(&info->sg, buff, bufflen);\n\n\tsrb->sc_data_direction = dir;\n\tsrb->sdb.table.sgl = buff ? &info->sg : NULL;\n\tsrb->sdb.length = bufflen;\n\tsrb->sdb.table.nents = buff ? 1 : 0;\n}\n\nstatic void isd200_srb_set_bufflen(struct scsi_cmnd *srb, unsigned bufflen)\n{\n\tsrb->sdb.length = bufflen;\n}\n\n\n \nstatic int isd200_action( struct us_data *us, int action, \n\t\t\t  void* pointer, int value )\n{\n\tunion ata_cdb ata;\n\t \n\tstatic struct scsi_device srb_dev;\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tstruct scsi_cmnd *srb = &info->srb;\n\tint status;\n\n\tmemset(&ata, 0, sizeof(ata));\n\tmemcpy(srb->cmnd, info->cmnd, MAX_COMMAND_SIZE);\n\tsrb->device = &srb_dev;\n\n\tata.generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\tata.generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\tata.generic.TransferBlockSize = 1;\n\n\tswitch ( action ) {\n\tcase ACTION_READ_STATUS:\n\t\tusb_stor_dbg(us, \"   isd200_action(READ_STATUS)\\n\");\n\t\tata.generic.ActionSelect = ACTION_SELECT_0|ACTION_SELECT_2;\n\t\tata.generic.RegisterSelect =\n\t\t  REG_CYLINDER_LOW | REG_CYLINDER_HIGH |\n\t\t  REG_STATUS | REG_ERROR;\n\t\tisd200_set_srb(info, DMA_FROM_DEVICE, pointer, value);\n\t\tbreak;\n\n\tcase ACTION_ENUM:\n\t\tusb_stor_dbg(us, \"   isd200_action(ENUM,0x%02x)\\n\", value);\n\t\tata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\n\t\t\t\t\t   ACTION_SELECT_3|ACTION_SELECT_4|\n\t\t\t\t\t   ACTION_SELECT_5;\n\t\tata.generic.RegisterSelect = REG_DEVICE_HEAD;\n\t\tata.write.DeviceHeadByte = value;\n\t\tisd200_set_srb(info, DMA_NONE, NULL, 0);\n\t\tbreak;\n\n\tcase ACTION_RESET:\n\t\tusb_stor_dbg(us, \"   isd200_action(RESET)\\n\");\n\t\tata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\n\t\t\t\t\t   ACTION_SELECT_3|ACTION_SELECT_4;\n\t\tata.generic.RegisterSelect = REG_DEVICE_CONTROL;\n\t\tata.write.DeviceControlByte = ATA_DC_RESET_CONTROLLER;\n\t\tisd200_set_srb(info, DMA_NONE, NULL, 0);\n\t\tbreak;\n\n\tcase ACTION_REENABLE:\n\t\tusb_stor_dbg(us, \"   isd200_action(REENABLE)\\n\");\n\t\tata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_2|\n\t\t\t\t\t   ACTION_SELECT_3|ACTION_SELECT_4;\n\t\tata.generic.RegisterSelect = REG_DEVICE_CONTROL;\n\t\tata.write.DeviceControlByte = ATA_DC_REENABLE_CONTROLLER;\n\t\tisd200_set_srb(info, DMA_NONE, NULL, 0);\n\t\tbreak;\n\n\tcase ACTION_SOFT_RESET:\n\t\tusb_stor_dbg(us, \"   isd200_action(SOFT_RESET)\\n\");\n\t\tata.generic.ActionSelect = ACTION_SELECT_1|ACTION_SELECT_5;\n\t\tata.generic.RegisterSelect = REG_DEVICE_HEAD | REG_COMMAND;\n\t\tata.write.DeviceHeadByte = info->DeviceHead;\n\t\tata.write.CommandByte = ATA_CMD_DEV_RESET;\n\t\tisd200_set_srb(info, DMA_NONE, NULL, 0);\n\t\tbreak;\n\n\tcase ACTION_IDENTIFY:\n\t\tusb_stor_dbg(us, \"   isd200_action(IDENTIFY)\\n\");\n\t\tata.generic.RegisterSelect = REG_COMMAND;\n\t\tata.write.CommandByte = ATA_CMD_ID_ATA;\n\t\tisd200_set_srb(info, DMA_FROM_DEVICE, info->id,\n\t\t\t\tATA_ID_WORDS * 2);\n\t\tbreak;\n\n\tdefault:\n\t\tusb_stor_dbg(us, \"Error: Undefined action %d\\n\", action);\n\t\treturn ISD200_ERROR;\n\t}\n\n\tmemcpy(srb->cmnd, &ata, sizeof(ata.generic));\n\tsrb->cmd_len = sizeof(ata.generic);\n\tstatus = usb_stor_Bulk_transport(srb, us);\n\tif (status == USB_STOR_TRANSPORT_GOOD)\n\t\tstatus = ISD200_GOOD;\n\telse {\n\t\tusb_stor_dbg(us, \"   isd200_action(0x%02x) error: %d\\n\",\n\t\t\t     action, status);\n\t\tstatus = ISD200_ERROR;\n\t\t \n\t}\n\n\treturn status;\n}\n\n \nstatic int isd200_read_regs( struct us_data *us )\n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tint retStatus = ISD200_GOOD;\n\tint transferStatus;\n\n\tusb_stor_dbg(us, \"Entering isd200_IssueATAReadRegs\\n\");\n\n\ttransferStatus = isd200_action( us, ACTION_READ_STATUS,\n\t\t\t\t    info->RegsBuf, sizeof(info->ATARegs) );\n\tif (transferStatus != ISD200_TRANSPORT_GOOD) {\n\t\tusb_stor_dbg(us, \"   Error reading ATA registers\\n\");\n\t\tretStatus = ISD200_ERROR;\n\t} else {\n\t\tmemcpy(info->ATARegs, info->RegsBuf, sizeof(info->ATARegs));\n\t\tusb_stor_dbg(us, \"   Got ATA Register[ATA_REG_ERROR_OFFSET] = 0x%x\\n\",\n\t\t\t     info->ATARegs[ATA_REG_ERROR_OFFSET]);\n\t}\n\n\treturn retStatus;\n}\n\n\n \nstatic void isd200_invoke_transport( struct us_data *us, \n\t\t\t      struct scsi_cmnd *srb, \n\t\t\t      union ata_cdb *ataCdb )\n{\n\tint need_auto_sense = 0;\n\tint transferStatus;\n\tint result;\n\n\t \n\tmemcpy(srb->cmnd, ataCdb, sizeof(ataCdb->generic));\n\tsrb->cmd_len = sizeof(ataCdb->generic);\n\ttransferStatus = usb_stor_Bulk_transport(srb, us);\n\n\t \n\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"-- command was aborted\\n\");\n\t\tgoto Handle_Abort;\n\t}\n\n\tswitch (transferStatus) {\n\n\tcase USB_STOR_TRANSPORT_GOOD:\n\t\t \n\t\tsrb->result = SAM_STAT_GOOD;\n\t\tbreak;\n\n\tcase USB_STOR_TRANSPORT_NO_SENSE:\n\t\tusb_stor_dbg(us, \"-- transport indicates protocol failure\\n\");\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\treturn;\n\n\tcase USB_STOR_TRANSPORT_FAILED:\n\t\tusb_stor_dbg(us, \"-- transport indicates command failure\\n\");\n\t\tneed_auto_sense = 1;\n\t\tbreak;\n\n\tcase USB_STOR_TRANSPORT_ERROR:\n\t\tusb_stor_dbg(us, \"-- transport indicates transport error\\n\");\n\t\tsrb->result = DID_ERROR << 16;\n\t\t \n\t\treturn;\n    \n\tdefault:\n\t\tusb_stor_dbg(us, \"-- transport indicates unknown error\\n\");\n\t\tsrb->result = DID_ERROR << 16;\n\t\t \n\t\treturn;\n\t}\n\n\tif ((scsi_get_resid(srb) > 0) &&\n\t    !((srb->cmnd[0] == REQUEST_SENSE) ||\n\t      (srb->cmnd[0] == INQUIRY) ||\n\t      (srb->cmnd[0] == MODE_SENSE) ||\n\t      (srb->cmnd[0] == LOG_SENSE) ||\n\t      (srb->cmnd[0] == MODE_SENSE_10))) {\n\t\tusb_stor_dbg(us, \"-- unexpectedly short transfer\\n\");\n\t\tneed_auto_sense = 1;\n\t}\n\n\tif (need_auto_sense) {\n\t\tresult = isd200_read_regs(us);\n\t\tif (test_bit(US_FLIDX_TIMED_OUT, &us->dflags)) {\n\t\t\tusb_stor_dbg(us, \"-- auto-sense aborted\\n\");\n\t\t\tgoto Handle_Abort;\n\t\t}\n\t\tif (result == ISD200_GOOD) {\n\t\t\tisd200_build_sense(us, srb);\n\t\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\n\t\t\t \n\t\t\tif ((srb->sense_buffer[2] & 0xf) == 0x0)\n\t\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t} else {\n\t\t\tsrb->result = DID_ERROR << 16;\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif (transferStatus == USB_STOR_TRANSPORT_FAILED)\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\treturn;\n\n\t \n\tHandle_Abort:\n\tsrb->result = DID_ABORT << 16;\n\n\t \n\tclear_bit(US_FLIDX_ABORTING, &us->dflags);\n\t \n}\n\n#ifdef CONFIG_USB_STORAGE_DEBUG\nstatic void isd200_log_config(struct us_data *us, struct isd200_info *info)\n{\n\tusb_stor_dbg(us, \"      Event Notification: 0x%x\\n\",\n\t\t     info->ConfigData.EventNotification);\n\tusb_stor_dbg(us, \"      External Clock: 0x%x\\n\",\n\t\t     info->ConfigData.ExternalClock);\n\tusb_stor_dbg(us, \"      ATA Init Timeout: 0x%x\\n\",\n\t\t     info->ConfigData.ATAInitTimeout);\n\tusb_stor_dbg(us, \"      ATAPI Command Block Size: 0x%x\\n\",\n\t\t     (info->ConfigData.ATAConfig & ATACFG_BLOCKSIZE) >> 6);\n\tusb_stor_dbg(us, \"      Master/Slave Selection: 0x%x\\n\",\n\t\t     info->ConfigData.ATAConfig & ATACFG_MASTER);\n\tusb_stor_dbg(us, \"      ATAPI Reset: 0x%x\\n\",\n\t\t     info->ConfigData.ATAConfig & ATACFG_ATAPI_RESET);\n\tusb_stor_dbg(us, \"      ATA Timing: 0x%x\\n\",\n\t\t     info->ConfigData.ATAConfig & ATACFG_TIMING);\n\tusb_stor_dbg(us, \"      ATA Major Command: 0x%x\\n\",\n\t\t     info->ConfigData.ATAMajorCommand);\n\tusb_stor_dbg(us, \"      ATA Minor Command: 0x%x\\n\",\n\t\t     info->ConfigData.ATAMinorCommand);\n\tusb_stor_dbg(us, \"      Init Status: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_INIT_STATUS);\n\tusb_stor_dbg(us, \"      Config Descriptor 2: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_CONF_DESC2);\n\tusb_stor_dbg(us, \"      Skip Device Boot: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_SKIP_BOOT);\n\tusb_stor_dbg(us, \"      ATA 3 State Suspend: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_STATE_SUSPEND);\n\tusb_stor_dbg(us, \"      Descriptor Override: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_DESC_OVERRIDE);\n\tusb_stor_dbg(us, \"      Last LUN Identifier: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & ATACFGE_LAST_LUN);\n\tusb_stor_dbg(us, \"      SRST Enable: 0x%x\\n\",\n\t\t     info->ConfigData.ATAExtraConfig & CFG_CAPABILITY_SRST);\n}\n#endif\n\n \nstatic int isd200_write_config( struct us_data *us ) \n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tint retStatus = ISD200_GOOD;\n\tint result;\n\n#ifdef CONFIG_USB_STORAGE_DEBUG\n\tusb_stor_dbg(us, \"Entering isd200_write_config\\n\");\n\tusb_stor_dbg(us, \"   Writing the following ISD200 Config Data:\\n\");\n\tisd200_log_config(us, info);\n#endif\n\n\t \n\tresult = usb_stor_ctrl_transfer(\n\t\tus, \n\t\tus->send_ctrl_pipe,\n\t\t0x01, \n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t0x0000, \n\t\t0x0002, \n\t\t(void *) &info->ConfigData, \n\t\tsizeof(info->ConfigData));\n\n\tif (result >= 0) {\n\t\tusb_stor_dbg(us, \"   ISD200 Config Data was written successfully\\n\");\n\t} else {\n\t\tusb_stor_dbg(us, \"   Request to write ISD200 Config Data failed!\\n\");\n\t\tretStatus = ISD200_ERROR;\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_write_config %08X\\n\", retStatus);\n\treturn retStatus;\n}\n\n\n \nstatic int isd200_read_config( struct us_data *us ) \n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tint retStatus = ISD200_GOOD;\n\tint result;\n\n\tusb_stor_dbg(us, \"Entering isd200_read_config\\n\");\n\n\t \n\t \n\n\tresult = usb_stor_ctrl_transfer(\n\t\tus, \n\t\tus->recv_ctrl_pipe,\n\t\t0x02, \n\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t0x0000, \n\t\t0x0002, \n\t\t(void *) &info->ConfigData, \n\t\tsizeof(info->ConfigData));\n\n\n\tif (result >= 0) {\n\t\tusb_stor_dbg(us, \"   Retrieved the following ISD200 Config Data:\\n\");\n#ifdef CONFIG_USB_STORAGE_DEBUG\n\t\tisd200_log_config(us, info);\n#endif\n\t} else {\n\t\tusb_stor_dbg(us, \"   Request to get ISD200 Config Data failed!\\n\");\n\t\tretStatus = ISD200_ERROR;\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_read_config %08X\\n\", retStatus);\n\treturn retStatus;\n}\n\n\n \nstatic int isd200_atapi_soft_reset( struct us_data *us ) \n{\n\tint retStatus = ISD200_GOOD;\n\tint transferStatus;\n\n\tusb_stor_dbg(us, \"Entering isd200_atapi_soft_reset\\n\");\n\n\ttransferStatus = isd200_action( us, ACTION_SOFT_RESET, NULL, 0 );\n\tif (transferStatus != ISD200_TRANSPORT_GOOD) {\n\t\tusb_stor_dbg(us, \"   Error issuing Atapi Soft Reset\\n\");\n\t\tretStatus = ISD200_ERROR;\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_atapi_soft_reset %08X\\n\", retStatus);\n\treturn retStatus;\n}\n\n\n \nstatic int isd200_srst( struct us_data *us ) \n{\n\tint retStatus = ISD200_GOOD;\n\tint transferStatus;\n\n\tusb_stor_dbg(us, \"Entering isd200_SRST\\n\");\n\n\ttransferStatus = isd200_action( us, ACTION_RESET, NULL, 0 );\n\n\t \n\tif (transferStatus != ISD200_TRANSPORT_GOOD) {\n\t\tusb_stor_dbg(us, \"   Error issuing SRST\\n\");\n\t\tretStatus = ISD200_ERROR;\n\t} else {\n\t\t \n\t\tmsleep(10);\n\n\t\ttransferStatus = isd200_action( us, ACTION_REENABLE, NULL, 0 );\n\t\tif (transferStatus != ISD200_TRANSPORT_GOOD) {\n\t\t\tusb_stor_dbg(us, \"   Error taking drive out of reset\\n\");\n\t\t\tretStatus = ISD200_ERROR;\n\t\t} else {\n\t\t\t \n\t\t\tmsleep(50);\n\t\t}\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_srst %08X\\n\", retStatus);\n\treturn retStatus;\n}\n\n\n \nstatic int isd200_try_enum(struct us_data *us, unsigned char master_slave,\n\t\t\t   int detect )\n{\n\tint status = ISD200_GOOD;\n\tunsigned long endTime;\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tunsigned char *regs = info->RegsBuf;\n\tint recheckAsMaster = 0;\n\n\tif ( detect )\n\t\tendTime = jiffies + ISD200_ENUM_DETECT_TIMEOUT * HZ;\n\telse\n\t\tendTime = jiffies + ISD200_ENUM_BSY_TIMEOUT * HZ;\n\n\t \n\twhile(1) {\n\n\t\tstatus = isd200_action( us, ACTION_ENUM, NULL, master_slave );\n\t\tif ( status != ISD200_GOOD )\n\t\t\tbreak;\n\n\t\tstatus = isd200_action( us, ACTION_READ_STATUS, \n\t\t\t\t\tregs, 8 );\n\t\tif ( status != ISD200_GOOD )\n\t\t\tbreak;\n\n\t\tif (!detect) {\n\t\t\tif (regs[ATA_REG_STATUS_OFFSET] & ATA_BUSY) {\n\t\t\t\tusb_stor_dbg(us, \"   %s status is still BSY, try again...\\n\",\n\t\t\t\t\t     master_slave == ATA_ADDRESS_DEVHEAD_STD ?\n\t\t\t\t\t     \"Master\" : \"Slave\");\n\t\t\t} else {\n\t\t\t\tusb_stor_dbg(us, \"   %s status !BSY, continue with next operation\\n\",\n\t\t\t\t\t     master_slave == ATA_ADDRESS_DEVHEAD_STD ?\n\t\t\t\t\t     \"Master\" : \"Slave\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\t \n\t\t \n\t\telse if (regs[ATA_REG_STATUS_OFFSET] &\n\t\t\t (ATA_BUSY | ATA_DF | ATA_ERR)) {\n\t\t\tusb_stor_dbg(us, \"   Status indicates it is not ready, try again...\\n\");\n\t\t}\n\t\t \n\t\telse if (regs[ATA_REG_STATUS_OFFSET] & ATA_DRDY) {\n\t\t\tusb_stor_dbg(us, \"   Identified ATA device\\n\");\n\t\t\tinfo->DeviceFlags |= DF_ATA_DEVICE;\n\t\t\tinfo->DeviceHead = master_slave;\n\t\t\tbreak;\n\t\t} \n\t\t \n\t\telse if (regs[ATA_REG_HCYL_OFFSET] == 0xEB &&\n\t\t\t regs[ATA_REG_LCYL_OFFSET] == 0x14) {\n\t\t\t \n\t\t\tif ((master_slave & ATA_ADDRESS_DEVHEAD_SLAVE) &&\n\t\t\t    !recheckAsMaster) {\n\t\t\t\tusb_stor_dbg(us, \"   Identified ATAPI device as slave.  Rechecking again as master\\n\");\n\t\t\t\trecheckAsMaster = 1;\n\t\t\t\tmaster_slave = ATA_ADDRESS_DEVHEAD_STD;\n\t\t\t} else {\n\t\t\t\tusb_stor_dbg(us, \"   Identified ATAPI device\\n\");\n\t\t\t\tinfo->DeviceHead = master_slave;\n\t\t\t      \n\t\t\t\tstatus = isd200_atapi_soft_reset(us);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"   Not ATA, not ATAPI - Weird\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (time_after_eq(jiffies, endTime)) {\n\t\t\tif (!detect)\n\t\t\t\tusb_stor_dbg(us, \"   BSY check timeout, just continue with next operation...\\n\");\n\t\t\telse\n\t\t\t\tusb_stor_dbg(us, \"   Device detect timeout!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nstatic int isd200_manual_enum(struct us_data *us)\n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tint retStatus = ISD200_GOOD;\n\n\tusb_stor_dbg(us, \"Entering isd200_manual_enum\\n\");\n\n\tretStatus = isd200_read_config(us);\n\tif (retStatus == ISD200_GOOD) {\n\t\tint isslave;\n\t\t \n\t\tretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 0);\n\t\tif (retStatus == ISD200_GOOD)\n\t\t\tretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_SLAVE, 0);\n\n\t\tif (retStatus == ISD200_GOOD) {\n\t\t\tretStatus = isd200_srst(us);\n\t\t\tif (retStatus == ISD200_GOOD)\n\t\t\t\t \n\t\t\t\tretStatus = isd200_try_enum( us, ATA_ADDRESS_DEVHEAD_STD, 1);\n\t\t}\n\n\t\tisslave = (info->DeviceHead & ATA_ADDRESS_DEVHEAD_SLAVE) ? 1 : 0;\n\t\tif (!(info->ConfigData.ATAConfig & ATACFG_MASTER)) {\n\t\t\tusb_stor_dbg(us, \"   Setting Master/Slave selection to %d\\n\",\n\t\t\t\t     isslave);\n\t\t\tinfo->ConfigData.ATAConfig &= 0x3f;\n\t\t\tinfo->ConfigData.ATAConfig |= (isslave<<6);\n\t\t\tretStatus = isd200_write_config(us);\n\t\t}\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_manual_enum %08X\\n\", retStatus);\n\treturn(retStatus);\n}\n\nstatic void isd200_fix_driveid(u16 *id)\n{\n#ifndef __LITTLE_ENDIAN\n# ifdef __BIG_ENDIAN\n\tint i;\n\n\tfor (i = 0; i < ATA_ID_WORDS; i++)\n\t\tid[i] = __le16_to_cpu(id[i]);\n# else\n#  error \"Please fix <asm/byteorder.h>\"\n# endif\n#endif\n}\n\nstatic void isd200_dump_driveid(struct us_data *us, u16 *id)\n{\n\tusb_stor_dbg(us, \"   Identify Data Structure:\\n\");\n\tusb_stor_dbg(us, \"      config = 0x%x\\n\",\tid[ATA_ID_CONFIG]);\n\tusb_stor_dbg(us, \"      cyls = 0x%x\\n\",\t\tid[ATA_ID_CYLS]);\n\tusb_stor_dbg(us, \"      heads = 0x%x\\n\",\tid[ATA_ID_HEADS]);\n\tusb_stor_dbg(us, \"      track_bytes = 0x%x\\n\",\tid[4]);\n\tusb_stor_dbg(us, \"      sector_bytes = 0x%x\\n\", id[5]);\n\tusb_stor_dbg(us, \"      sectors = 0x%x\\n\",\tid[ATA_ID_SECTORS]);\n\tusb_stor_dbg(us, \"      serial_no[0] = 0x%x\\n\", *(char *)&id[ATA_ID_SERNO]);\n\tusb_stor_dbg(us, \"      buf_type = 0x%x\\n\",\tid[20]);\n\tusb_stor_dbg(us, \"      buf_size = 0x%x\\n\",\tid[ATA_ID_BUF_SIZE]);\n\tusb_stor_dbg(us, \"      ecc_bytes = 0x%x\\n\",\tid[22]);\n\tusb_stor_dbg(us, \"      fw_rev[0] = 0x%x\\n\",\t*(char *)&id[ATA_ID_FW_REV]);\n\tusb_stor_dbg(us, \"      model[0] = 0x%x\\n\",\t*(char *)&id[ATA_ID_PROD]);\n\tusb_stor_dbg(us, \"      max_multsect = 0x%x\\n\", id[ATA_ID_MAX_MULTSECT] & 0xff);\n\tusb_stor_dbg(us, \"      dword_io = 0x%x\\n\",\tid[ATA_ID_DWORD_IO]);\n\tusb_stor_dbg(us, \"      capability = 0x%x\\n\",\tid[ATA_ID_CAPABILITY] >> 8);\n\tusb_stor_dbg(us, \"      tPIO = 0x%x\\n\",\t  id[ATA_ID_OLD_PIO_MODES] >> 8);\n\tusb_stor_dbg(us, \"      tDMA = 0x%x\\n\",\t  id[ATA_ID_OLD_DMA_MODES] >> 8);\n\tusb_stor_dbg(us, \"      field_valid = 0x%x\\n\",\tid[ATA_ID_FIELD_VALID]);\n\tusb_stor_dbg(us, \"      cur_cyls = 0x%x\\n\",\tid[ATA_ID_CUR_CYLS]);\n\tusb_stor_dbg(us, \"      cur_heads = 0x%x\\n\",\tid[ATA_ID_CUR_HEADS]);\n\tusb_stor_dbg(us, \"      cur_sectors = 0x%x\\n\",\tid[ATA_ID_CUR_SECTORS]);\n\tusb_stor_dbg(us, \"      cur_capacity = 0x%x\\n\", ata_id_u32(id, 57));\n\tusb_stor_dbg(us, \"      multsect = 0x%x\\n\",\tid[ATA_ID_MULTSECT] & 0xff);\n\tusb_stor_dbg(us, \"      lba_capacity = 0x%x\\n\", ata_id_u32(id, ATA_ID_LBA_CAPACITY));\n\tusb_stor_dbg(us, \"      command_set_1 = 0x%x\\n\", id[ATA_ID_COMMAND_SET_1]);\n\tusb_stor_dbg(us, \"      command_set_2 = 0x%x\\n\", id[ATA_ID_COMMAND_SET_2]);\n}\n\n \nstatic int isd200_get_inquiry_data( struct us_data *us )\n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tint retStatus = ISD200_GOOD;\n\tu16 *id = info->id;\n\n\tusb_stor_dbg(us, \"Entering isd200_get_inquiry_data\\n\");\n\n\t \n\tinfo->DeviceHead = ATA_ADDRESS_DEVHEAD_STD;\n\n\t \n\tretStatus = isd200_manual_enum(us);\n\tif (retStatus == ISD200_GOOD) {\n\t\tint transferStatus;\n\n\t\t \n\t\tif (info->DeviceFlags & DF_ATA_DEVICE) {\n\t\t\t \n\t\t\t \n\t\t\ttransferStatus = isd200_action( us, ACTION_IDENTIFY,\n\t\t\t\t\t\t\tid, ATA_ID_WORDS * 2);\n\t\t\tif (transferStatus != ISD200_TRANSPORT_GOOD) {\n\t\t\t\t \n\t\t\t\tusb_stor_dbg(us, \"   Error issuing ATA Command Identify\\n\");\n\t\t\t\tretStatus = ISD200_ERROR;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tint i;\n\t\t\t\t__be16 *src;\n\t\t\t\t__u16 *dest;\n\n\t\t\t\tisd200_fix_driveid(id);\n\t\t\t\tisd200_dump_driveid(us, id);\n\n\t\t\t\tmemset(&info->InquiryData, 0, sizeof(info->InquiryData));\n\n\t\t\t\t \n\t\t\t\tinfo->InquiryData.DeviceType = DIRECT_ACCESS_DEVICE;\n\n\t\t\t\t \n\t\t\t\tinfo->InquiryData.AdditionalLength = 0x1F;\n\n\t\t\t\tif (id[ATA_ID_COMMAND_SET_1] & COMMANDSET_MEDIA_STATUS) {\n\t\t\t\t\t \n\t\t\t\t\tinfo->InquiryData.DeviceTypeModifier = DEVICE_REMOVABLE;\n\t\t\t\t\tinfo->DeviceFlags |= DF_REMOVABLE_MEDIA;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tsrc = (__be16 *)&id[ATA_ID_PROD];\n\t\t\t\tdest = (__u16*)info->InquiryData.VendorId;\n\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\tdest[i] = be16_to_cpu(src[i]);\n\n\t\t\t\tsrc = (__be16 *)&id[ATA_ID_PROD + 8/2];\n\t\t\t\tdest = (__u16*)info->InquiryData.ProductId;\n\t\t\t\tfor (i=0;i<8;i++)\n\t\t\t\t\tdest[i] = be16_to_cpu(src[i]);\n\n\t\t\t\tsrc = (__be16 *)&id[ATA_ID_FW_REV];\n\t\t\t\tdest = (__u16*)info->InquiryData.ProductRevisionLevel;\n\t\t\t\tfor (i=0;i<2;i++)\n\t\t\t\t\tdest[i] = be16_to_cpu(src[i]);\n\n\t\t\t\t \n\t\t\t\tif (id[ATA_ID_COMMAND_SET_2] & COMMANDSET_MEDIA_STATUS) {\n\t\t\t\t\tusb_stor_dbg(us, \"   Device supports Media Status Notification\\n\");\n\n\t\t\t\t\t \n\t\t\t\t\tinfo->DeviceFlags |= DF_MEDIA_STATUS_ENABLED;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tinfo->DeviceFlags &= ~DF_MEDIA_STATUS_ENABLED;\n\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tus->protocol_name = \"Transparent SCSI\";\n\t\t\tus->proto_handler = usb_stor_transparent_scsi_command;\n\n\t\t\tusb_stor_dbg(us, \"Protocol changed to: %s\\n\",\n\t\t\t\t     us->protocol_name);\n\t    \n\t\t\t \n\t\t\tus->extra_destructor(info);\n\t\t\tkfree(info);\n\t\t\tus->extra = NULL;\n\t\t\tus->extra_destructor = NULL;\n\t\t}\n\t}\n\n\tusb_stor_dbg(us, \"Leaving isd200_get_inquiry_data %08X\\n\", retStatus);\n\n\treturn(retStatus);\n}\n\n \nstatic int isd200_scsi_to_ata(struct scsi_cmnd *srb, struct us_data *us,\n\t\t\t      union ata_cdb * ataCdb)\n{\n\tstruct isd200_info *info = (struct isd200_info *)us->extra;\n\tu16 *id = info->id;\n\tint sendToTransport = 1;\n\tunsigned char sectnum, head;\n\tunsigned short cylinder;\n\tunsigned long lba;\n\tunsigned long blockCount;\n\tunsigned char senseData[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n\tmemset(ataCdb, 0, sizeof(union ata_cdb));\n\n\t \n\tswitch (srb->cmnd[0]) {\n\tcase INQUIRY:\n\t\tusb_stor_dbg(us, \"   ATA OUT - INQUIRY\\n\");\n\n\t\t \n\t\tusb_stor_set_xfer_buf((unsigned char *) &info->InquiryData,\n\t\t\t\tsizeof(info->InquiryData), srb);\n\t\tsrb->result = SAM_STAT_GOOD;\n\t\tsendToTransport = 0;\n\t\tbreak;\n\n\tcase MODE_SENSE:\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_MODE_SENSE\\n\");\n\n\t\t \n\t\tusb_stor_set_xfer_buf(senseData, sizeof(senseData), srb);\n\n\t\tif (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)\n\t\t{\n\t\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\t\tataCdb->generic.TransferBlockSize = 1;\n\t\t\tataCdb->generic.RegisterSelect = REG_COMMAND;\n\t\t\tataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\n\t\t\tisd200_srb_set_bufflen(srb, 0);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"   Media Status not supported, just report okay\\n\");\n\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\tsendToTransport = 0;\n\t\t}\n\t\tbreak;\n\n\tcase TEST_UNIT_READY:\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_TEST_UNIT_READY\\n\");\n\n\t\tif (info->DeviceFlags & DF_MEDIA_STATUS_ENABLED)\n\t\t{\n\t\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\t\tataCdb->generic.TransferBlockSize = 1;\n\t\t\tataCdb->generic.RegisterSelect = REG_COMMAND;\n\t\t\tataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\n\t\t\tisd200_srb_set_bufflen(srb, 0);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"   Media Status not supported, just report okay\\n\");\n\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\tsendToTransport = 0;\n\t\t}\n\t\tbreak;\n\n\tcase READ_CAPACITY:\n\t{\n\t\tunsigned long capacity;\n\t\tstruct read_capacity_data readCapacityData;\n\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_READ_CAPACITY\\n\");\n\n\t\tif (ata_id_has_lba(id))\n\t\t\tcapacity = ata_id_u32(id, ATA_ID_LBA_CAPACITY) - 1;\n\t\telse\n\t\t\tcapacity = (id[ATA_ID_HEADS] * id[ATA_ID_CYLS] *\n\t\t\t\t    id[ATA_ID_SECTORS]) - 1;\n\n\t\treadCapacityData.LogicalBlockAddress = cpu_to_be32(capacity);\n\t\treadCapacityData.BytesPerBlock = cpu_to_be32(0x200);\n\n\t\tusb_stor_set_xfer_buf((unsigned char *) &readCapacityData,\n\t\t\t\tsizeof(readCapacityData), srb);\n\t\tsrb->result = SAM_STAT_GOOD;\n\t\tsendToTransport = 0;\n\t}\n\tbreak;\n\n\tcase READ_10:\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_READ\\n\");\n\n\t\tlba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);\n\t\tblockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];\n\n\t\tif (ata_id_has_lba(id)) {\n\t\t\tsectnum = (unsigned char)(lba);\n\t\t\tcylinder = (unsigned short)(lba>>8);\n\t\t\thead = ATA_ADDRESS_DEVHEAD_LBA_MODE | (unsigned char)(lba>>24 & 0x0F);\n\t\t} else {\n\t\t\tsectnum = (u8)((lba % id[ATA_ID_SECTORS]) + 1);\n\t\t\tcylinder = (u16)(lba / (id[ATA_ID_SECTORS] *\n\t\t\t\t\tid[ATA_ID_HEADS]));\n\t\t\thead = (u8)((lba / id[ATA_ID_SECTORS]) %\n\t\t\t\t\tid[ATA_ID_HEADS]);\n\t\t}\n\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\tataCdb->generic.TransferBlockSize = 1;\n\t\tataCdb->generic.RegisterSelect =\n\t\t  REG_SECTOR_COUNT | REG_SECTOR_NUMBER |\n\t\t  REG_CYLINDER_LOW | REG_CYLINDER_HIGH |\n\t\t  REG_DEVICE_HEAD  | REG_COMMAND;\n\t\tataCdb->write.SectorCountByte = (unsigned char)blockCount;\n\t\tataCdb->write.SectorNumberByte = sectnum;\n\t\tataCdb->write.CylinderHighByte = (unsigned char)(cylinder>>8);\n\t\tataCdb->write.CylinderLowByte = (unsigned char)cylinder;\n\t\tataCdb->write.DeviceHeadByte = (head | ATA_ADDRESS_DEVHEAD_STD);\n\t\tataCdb->write.CommandByte = ATA_CMD_PIO_READ;\n\t\tbreak;\n\n\tcase WRITE_10:\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_WRITE\\n\");\n\n\t\tlba = be32_to_cpu(*(__be32 *)&srb->cmnd[2]);\n\t\tblockCount = (unsigned long)srb->cmnd[7]<<8 | (unsigned long)srb->cmnd[8];\n\n\t\tif (ata_id_has_lba(id)) {\n\t\t\tsectnum = (unsigned char)(lba);\n\t\t\tcylinder = (unsigned short)(lba>>8);\n\t\t\thead = ATA_ADDRESS_DEVHEAD_LBA_MODE | (unsigned char)(lba>>24 & 0x0F);\n\t\t} else {\n\t\t\tsectnum = (u8)((lba % id[ATA_ID_SECTORS]) + 1);\n\t\t\tcylinder = (u16)(lba / (id[ATA_ID_SECTORS] *\n\t\t\t\t\tid[ATA_ID_HEADS]));\n\t\t\thead = (u8)((lba / id[ATA_ID_SECTORS]) %\n\t\t\t\t\tid[ATA_ID_HEADS]);\n\t\t}\n\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\tataCdb->generic.TransferBlockSize = 1;\n\t\tataCdb->generic.RegisterSelect =\n\t\t  REG_SECTOR_COUNT | REG_SECTOR_NUMBER |\n\t\t  REG_CYLINDER_LOW | REG_CYLINDER_HIGH |\n\t\t  REG_DEVICE_HEAD  | REG_COMMAND;\n\t\tataCdb->write.SectorCountByte = (unsigned char)blockCount;\n\t\tataCdb->write.SectorNumberByte = sectnum;\n\t\tataCdb->write.CylinderHighByte = (unsigned char)(cylinder>>8);\n\t\tataCdb->write.CylinderLowByte = (unsigned char)cylinder;\n\t\tataCdb->write.DeviceHeadByte = (head | ATA_ADDRESS_DEVHEAD_STD);\n\t\tataCdb->write.CommandByte = ATA_CMD_PIO_WRITE;\n\t\tbreak;\n\n\tcase ALLOW_MEDIUM_REMOVAL:\n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_MEDIUM_REMOVAL\\n\");\n\n\t\tif (info->DeviceFlags & DF_REMOVABLE_MEDIA) {\n\t\t\tusb_stor_dbg(us, \"   srb->cmnd[4] = 0x%X\\n\",\n\t\t\t\t     srb->cmnd[4]);\n\t    \n\t\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\t\tataCdb->generic.TransferBlockSize = 1;\n\t\t\tataCdb->generic.RegisterSelect = REG_COMMAND;\n\t\t\tataCdb->write.CommandByte = (srb->cmnd[4] & 0x1) ?\n\t\t\t\tATA_CMD_MEDIA_LOCK : ATA_CMD_MEDIA_UNLOCK;\n\t\t\tisd200_srb_set_bufflen(srb, 0);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"   Not removable media, just report okay\\n\");\n\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\tsendToTransport = 0;\n\t\t}\n\t\tbreak;\n\n\tcase START_STOP:    \n\t\tusb_stor_dbg(us, \"   ATA OUT - SCSIOP_START_STOP_UNIT\\n\");\n\t\tusb_stor_dbg(us, \"   srb->cmnd[4] = 0x%X\\n\", srb->cmnd[4]);\n\n\t\tif ((srb->cmnd[4] & 0x3) == 0x2) {\n\t\t\tusb_stor_dbg(us, \"   Media Eject\\n\");\n\t\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\t\tataCdb->generic.TransferBlockSize = 0;\n\t\t\tataCdb->generic.RegisterSelect = REG_COMMAND;\n\t\t\tataCdb->write.CommandByte = ATA_COMMAND_MEDIA_EJECT;\n\t\t} else if ((srb->cmnd[4] & 0x3) == 0x1) {\n\t\t\tusb_stor_dbg(us, \"   Get Media Status\\n\");\n\t\t\tataCdb->generic.SignatureByte0 = info->ConfigData.ATAMajorCommand;\n\t\t\tataCdb->generic.SignatureByte1 = info->ConfigData.ATAMinorCommand;\n\t\t\tataCdb->generic.TransferBlockSize = 1;\n\t\t\tataCdb->generic.RegisterSelect = REG_COMMAND;\n\t\t\tataCdb->write.CommandByte = ATA_COMMAND_GET_MEDIA_STATUS;\n\t\t\tisd200_srb_set_bufflen(srb, 0);\n\t\t} else {\n\t\t\tusb_stor_dbg(us, \"   Nothing to do, just report okay\\n\");\n\t\t\tsrb->result = SAM_STAT_GOOD;\n\t\t\tsendToTransport = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tusb_stor_dbg(us, \"Unsupported SCSI command - 0x%X\\n\",\n\t\t\t     srb->cmnd[0]);\n\t\tsrb->result = DID_ERROR << 16;\n\t\tsendToTransport = 0;\n\t\tbreak;\n\t}\n\n\treturn(sendToTransport);\n}\n\n\n \nstatic void isd200_free_info_ptrs(void *info_)\n{\n\tstruct isd200_info *info = (struct isd200_info *) info_;\n\n\tif (info) {\n\t\tkfree(info->id);\n\t\tkfree(info->RegsBuf);\n\t\tkfree(info->srb.sense_buffer);\n\t}\n}\n\n \nstatic int isd200_init_info(struct us_data *us)\n{\n\tstruct isd200_info *info;\n\n\tinfo = kzalloc(sizeof(struct isd200_info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->id = kzalloc(ATA_ID_WORDS * 2, GFP_KERNEL);\n\tinfo->RegsBuf = kmalloc(sizeof(info->ATARegs), GFP_KERNEL);\n\tinfo->srb.sense_buffer = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_KERNEL);\n\n\tif (!info->id || !info->RegsBuf || !info->srb.sense_buffer) {\n\t\tisd200_free_info_ptrs(info);\n\t\tkfree(info);\n\t\treturn -ENOMEM;\n\t}\n\n\tus->extra = info;\n\tus->extra_destructor = isd200_free_info_ptrs;\n\n\treturn 0;\n}\n\n \n\nstatic int isd200_Initialization(struct us_data *us)\n{\n\tusb_stor_dbg(us, \"ISD200 Initialization...\\n\");\n\n\t \n\n\tif (isd200_init_info(us) == ISD200_ERROR) {\n\t\tusb_stor_dbg(us, \"ERROR Initializing ISD200 Info struct\\n\");\n\t} else {\n\t\t \n\n\t\tif (isd200_get_inquiry_data(us) != ISD200_GOOD)\n\t\t\tusb_stor_dbg(us, \"ISD200 Initialization Failure\\n\");\n\t\telse\n\t\t\tusb_stor_dbg(us, \"ISD200 Initialization complete\\n\");\n\t}\n\n\treturn 0;\n}\n\n\n \n\nstatic void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us)\n{\n\tint sendToTransport, orig_bufflen;\n\tunion ata_cdb ataCdb;\n\n\t \n\n\tif (us->extra == NULL) {\n\t\tusb_stor_dbg(us, \"ERROR Driver not initialized\\n\");\n\t\tsrb->result = DID_ERROR << 16;\n\t\treturn;\n\t}\n\n\tscsi_set_resid(srb, 0);\n\t \n\torig_bufflen = scsi_bufflen(srb);\n\tsendToTransport = isd200_scsi_to_ata(srb, us, &ataCdb);\n\n\t \n\tif (sendToTransport)\n\t\tisd200_invoke_transport(us, srb, &ataCdb);\n\n\tisd200_srb_set_bufflen(srb, orig_bufflen);\n}\n\nstatic struct scsi_host_template isd200_host_template;\n\nstatic int isd200_probe(struct usb_interface *intf,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct us_data *us;\n\tint result;\n\n\tresult = usb_stor_probe1(&us, intf, id,\n\t\t\t(id - isd200_usb_ids) + isd200_unusual_dev_list,\n\t\t\t&isd200_host_template);\n\tif (result)\n\t\treturn result;\n\n\tus->protocol_name = \"ISD200 ATA/ATAPI\";\n\tus->proto_handler = isd200_ata_command;\n\n\tresult = usb_stor_probe2(us);\n\treturn result;\n}\n\nstatic struct usb_driver isd200_driver = {\n\t.name =\t\tDRV_NAME,\n\t.probe =\tisd200_probe,\n\t.disconnect =\tusb_stor_disconnect,\n\t.suspend =\tusb_stor_suspend,\n\t.resume =\tusb_stor_resume,\n\t.reset_resume =\tusb_stor_reset_resume,\n\t.pre_reset =\tusb_stor_pre_reset,\n\t.post_reset =\tusb_stor_post_reset,\n\t.id_table =\tisd200_usb_ids,\n\t.soft_unbind =\t1,\n\t.no_dynamic_id = 1,\n};\n\nmodule_usb_stor_driver(isd200_driver, isd200_host_template, DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}