{
  "module_name": "scsiglue.c",
  "hash_id": "78d9ba544c41cd566d8d3eb987c651357e8b12826ce01f4976191437aaa9bc0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/storage/scsiglue.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_devinfo.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_eh.h>\n\n#include \"usb.h\"\n#include <linux/usb/hcd.h>\n#include \"scsiglue.h\"\n#include \"debug.h\"\n#include \"transport.h\"\n#include \"protocol.h\"\n\n \n#define VENDOR_ID_NOKIA\t\t0x0421\n#define VENDOR_ID_NIKON\t\t0x04b0\n#define VENDOR_ID_PENTAX\t0x0a17\n#define VENDOR_ID_MOTOROLA\t0x22b8\n\n \n\nstatic const char* host_info(struct Scsi_Host *host)\n{\n\tstruct us_data *us = host_to_us(host);\n\treturn us->scsi_name;\n}\n\nstatic int slave_alloc (struct scsi_device *sdev)\n{\n\tstruct us_data *us = host_to_us(sdev->host);\n\n\t \n\tsdev->inquiry_len = 36;\n\n\t \n\tblk_queue_update_dma_alignment(sdev->request_queue, (512 - 1));\n\n\t \n\tif (us->protocol == USB_PR_BULK && us->max_lun > 0)\n\t\tsdev->sdev_bflags |= BLIST_FORCELUN;\n\n\treturn 0;\n}\n\nstatic int slave_configure(struct scsi_device *sdev)\n{\n\tstruct us_data *us = host_to_us(sdev->host);\n\tstruct device *dev = us->pusb_dev->bus->sysdev;\n\n\t \n\tif (us->fflags & (US_FL_MAX_SECTORS_64 | US_FL_MAX_SECTORS_MIN)) {\n\t\tunsigned int max_sectors = 64;\n\n\t\tif (us->fflags & US_FL_MAX_SECTORS_MIN)\n\t\t\tmax_sectors = PAGE_SIZE >> 9;\n\t\tif (queue_max_hw_sectors(sdev->request_queue) > max_sectors)\n\t\t\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\t\t\t\t      max_sectors);\n\t} else if (sdev->type == TYPE_TAPE) {\n\t\t \n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 0x7FFFFF);\n\t} else if (us->pusb_dev->speed >= USB_SPEED_SUPER) {\n\t\t \n\t\tblk_queue_max_hw_sectors(sdev->request_queue, 2048);\n\t}\n\n\t \n\tblk_queue_max_hw_sectors(sdev->request_queue,\n\t\tmin_t(size_t, queue_max_hw_sectors(sdev->request_queue),\n\t\t      dma_max_mapping_size(dev) >> SECTOR_SHIFT));\n\n\t \n\tif (!hcd_uses_dma(bus_to_hcd(us->pusb_dev->bus)) ||\n\t\t\t(bus_to_hcd(us->pusb_dev->bus)->localmem_pool != NULL))\n\t\tblk_queue_bounce_limit(sdev->request_queue, BLK_BOUNCE_HIGH);\n\n\t \n\tif (sdev->type == TYPE_DISK) {\n\n\t\t \n\t\tswitch (le16_to_cpu(us->pusb_dev->descriptor.idVendor)) {\n\t\tcase VENDOR_ID_NOKIA:\n\t\tcase VENDOR_ID_NIKON:\n\t\tcase VENDOR_ID_PENTAX:\n\t\tcase VENDOR_ID_MOTOROLA:\n\t\t\tif (!(us->fflags & (US_FL_FIX_CAPACITY |\n\t\t\t\t\tUS_FL_CAPACITY_OK)))\n\t\t\t\tus->fflags |= US_FL_CAPACITY_HEURISTICS;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (us->subclass != USB_SC_SCSI && us->subclass != USB_SC_CYP_ATACB)\n\t\t\tsdev->use_10_for_ms = 1;\n\n\t\t \n\t\tsdev->use_192_bytes_for_3f = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_NO_WP_DETECT)\n\t\t\tsdev->skip_ms_page_3f = 1;\n\n\t\t \n\t\tsdev->skip_ms_page_8 = 1;\n\n\t\t \n\t\tsdev->skip_vpd_pages = !sdev->try_vpd_pages;\n\n\t\t \n\t\tsdev->no_report_opcodes = 1;\n\n\t\t \n\t\tsdev->no_write_same = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_FIX_CAPACITY)\n\t\t\tsdev->fix_capacity = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_CAPACITY_HEURISTICS)\n\t\t\tsdev->guess_capacity = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_NO_READ_CAPACITY_16)\n\t\t\tsdev->no_read_capacity_16 = 1;\n\n\t\t \n\t\tif (!(us->fflags & US_FL_NEEDS_CAP16))\n\t\t\tsdev->try_rc_10_first = 1;\n\n\t\t \n\t\tif (sdev->scsi_level > SCSI_SPC_2 &&\n\t\t    !(us->fflags & US_FL_BAD_SENSE))\n\t\t\tus->fflags |= US_FL_SANE_SENSE;\n\n\t\t \n\t\tsdev->retry_hwerror = 1;\n\n\t\t \n\t\tsdev->allow_restart = 1;\n\n\t\t \n\t\tsdev->last_sector_bug = 1;\n\n\t\t \n\t\tif (!(us->fflags & (US_FL_FIX_CAPACITY | US_FL_CAPACITY_OK |\n\t\t\t\t\tUS_FL_SCM_MULT_TARG)) &&\n\t\t\t\tus->protocol == USB_PR_BULK)\n\t\t\tus->use_last_sector_hacks = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_WRITE_CACHE)\n\t\t\tsdev->wce_default_on = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_BROKEN_FUA)\n\t\t\tsdev->broken_fua = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_ALWAYS_SYNC) {\n\t\t\t \n\t\t\tsdev->skip_ms_page_8 = 1;\n\t\t\tsdev->skip_ms_page_3f = 1;\n\t\t\t \n\t\t\tsdev->wce_default_on = 1;\n\t\t}\n\t} else {\n\n\t\t \n\t\tsdev->use_10_for_ms = 1;\n\n\t\t \n\t\tif (us->fflags & US_FL_NO_READ_DISC_INFO)\n\t\t\tsdev->no_read_disc_info = 1;\n\t}\n\n\t \n\tif ((us->protocol == USB_PR_CB || us->protocol == USB_PR_CBI) &&\n\t\t\tsdev->scsi_level == SCSI_UNKNOWN)\n\t\tus->max_lun = 0;\n\n\t \n\tif (us->fflags & US_FL_NOT_LOCKABLE)\n\t\tsdev->lockable = 0;\n\n\t \n\treturn 0;\n}\n\nstatic int target_alloc(struct scsi_target *starget)\n{\n\tstruct us_data *us = host_to_us(dev_to_shost(starget->dev.parent));\n\n\t \n\tstarget->no_report_luns = 1;\n\n\t \n\tif (us->subclass == USB_SC_UFI)\n\t\tstarget->pdt_1f_for_no_lun = 1;\n\n\treturn 0;\n}\n\n \n \nstatic int queuecommand_lck(struct scsi_cmnd *srb)\n{\n\tvoid (*done)(struct scsi_cmnd *) = scsi_done;\n\tstruct us_data *us = host_to_us(srb->device->host);\n\n\t \n\tif (us->srb != NULL) {\n\t\tdev_err(&us->pusb_intf->dev,\n\t\t\t\"Error in %s: us->srb = %p\\n\", __func__, us->srb);\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t}\n\n\t \n\tif (test_bit(US_FLIDX_DISCONNECTING, &us->dflags)) {\n\t\tusb_stor_dbg(us, \"Fail command during disconnect\\n\");\n\t\tsrb->result = DID_NO_CONNECT << 16;\n\t\tdone(srb);\n\t\treturn 0;\n\t}\n\n\tif ((us->fflags & US_FL_NO_ATA_1X) &&\n\t\t\t(srb->cmnd[0] == ATA_12 || srb->cmnd[0] == ATA_16)) {\n\t\tmemcpy(srb->sense_buffer, usb_stor_sense_invalidCDB,\n\t\t       sizeof(usb_stor_sense_invalidCDB));\n\t\tsrb->result = SAM_STAT_CHECK_CONDITION;\n\t\tdone(srb);\n\t\treturn 0;\n\t}\n\n\t \n\tus->srb = srb;\n\tcomplete(&us->cmnd_ready);\n\n\treturn 0;\n}\n\nstatic DEF_SCSI_QCMD(queuecommand)\n\n \n\n \nstatic int command_abort_matching(struct us_data *us, struct scsi_cmnd *srb_match)\n{\n\t \n\tscsi_lock(us_to_host(us));\n\n\t \n\tif (!us->srb) {\n\t\tscsi_unlock(us_to_host(us));\n\t\tusb_stor_dbg(us, \"-- nothing to abort\\n\");\n\t\treturn SUCCESS;\n\t}\n\n\t \n\tif (srb_match && us->srb != srb_match) {\n\t\tscsi_unlock(us_to_host(us));\n\t\tusb_stor_dbg(us, \"-- pending command mismatch\\n\");\n\t\treturn FAILED;\n\t}\n\n\t \n\tset_bit(US_FLIDX_TIMED_OUT, &us->dflags);\n\tif (!test_bit(US_FLIDX_RESETTING, &us->dflags)) {\n\t\tset_bit(US_FLIDX_ABORTING, &us->dflags);\n\t\tusb_stor_stop_transport(us);\n\t}\n\tscsi_unlock(us_to_host(us));\n\n\t \n\twait_for_completion(&us->notify);\n\treturn SUCCESS;\n}\n\nstatic int command_abort(struct scsi_cmnd *srb)\n{\n\tstruct us_data *us = host_to_us(srb->device->host);\n\n\tusb_stor_dbg(us, \"%s called\\n\", __func__);\n\treturn command_abort_matching(us, srb);\n}\n\n \nstatic int device_reset(struct scsi_cmnd *srb)\n{\n\tstruct us_data *us = host_to_us(srb->device->host);\n\tint result;\n\n\tusb_stor_dbg(us, \"%s called\\n\", __func__);\n\n\t \n\tcommand_abort_matching(us, NULL);\n\n\t \n\tmutex_lock(&(us->dev_mutex));\n\tresult = us->transport_reset(us);\n\tmutex_unlock(&us->dev_mutex);\n\n\treturn result < 0 ? FAILED : SUCCESS;\n}\n\n \nstatic int bus_reset(struct scsi_cmnd *srb)\n{\n\tstruct us_data *us = host_to_us(srb->device->host);\n\tint result;\n\n\tusb_stor_dbg(us, \"%s called\\n\", __func__);\n\n\tresult = usb_stor_port_reset(us);\n\treturn result < 0 ? FAILED : SUCCESS;\n}\n\n \nvoid usb_stor_report_device_reset(struct us_data *us)\n{\n\tint i;\n\tstruct Scsi_Host *host = us_to_host(us);\n\n\tscsi_report_device_reset(host, 0, 0);\n\tif (us->fflags & US_FL_SCM_MULT_TARG) {\n\t\tfor (i = 1; i < host->max_id; ++i)\n\t\t\tscsi_report_device_reset(host, 0, i);\n\t}\n}\n\n \nvoid usb_stor_report_bus_reset(struct us_data *us)\n{\n\tstruct Scsi_Host *host = us_to_host(us);\n\n\tscsi_lock(host);\n\tscsi_report_bus_reset(host, 0);\n\tscsi_unlock(host);\n}\n\n \n\nstatic int write_info(struct Scsi_Host *host, char *buffer, int length)\n{\n\t \n\treturn length;\n}\n\nstatic int show_info (struct seq_file *m, struct Scsi_Host *host)\n{\n\tstruct us_data *us = host_to_us(host);\n\tconst char *string;\n\n\t \n\tseq_printf(m, \"   Host scsi%d: usb-storage\\n\", host->host_no);\n\n\t \n\tif (us->pusb_dev->manufacturer)\n\t\tstring = us->pusb_dev->manufacturer;\n\telse if (us->unusual_dev->vendorName)\n\t\tstring = us->unusual_dev->vendorName;\n\telse\n\t\tstring = \"Unknown\";\n\tseq_printf(m, \"       Vendor: %s\\n\", string);\n\tif (us->pusb_dev->product)\n\t\tstring = us->pusb_dev->product;\n\telse if (us->unusual_dev->productName)\n\t\tstring = us->unusual_dev->productName;\n\telse\n\t\tstring = \"Unknown\";\n\tseq_printf(m, \"      Product: %s\\n\", string);\n\tif (us->pusb_dev->serial)\n\t\tstring = us->pusb_dev->serial;\n\telse\n\t\tstring = \"None\";\n\tseq_printf(m, \"Serial Number: %s\\n\", string);\n\n\t \n\tseq_printf(m, \"     Protocol: %s\\n\", us->protocol_name);\n\tseq_printf(m, \"    Transport: %s\\n\", us->transport_name);\n\n\t \n\tseq_printf(m, \"       Quirks:\");\n\n#define US_FLAG(name, value) \\\n\tif (us->fflags & value) seq_printf(m, \" \" #name);\nUS_DO_ALL_FLAGS\n#undef US_FLAG\n\tseq_putc(m, '\\n');\n\treturn 0;\n}\n\n \n\n \nstatic ssize_t max_sectors_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\n\treturn sprintf(buf, \"%u\\n\", queue_max_hw_sectors(sdev->request_queue));\n}\n\n \nstatic ssize_t max_sectors_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t\tsize_t count)\n{\n\tstruct scsi_device *sdev = to_scsi_device(dev);\n\tunsigned short ms;\n\n\tif (sscanf(buf, \"%hu\", &ms) > 0) {\n\t\tblk_queue_max_hw_sectors(sdev->request_queue, ms);\n\t\treturn count;\n\t}\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR_RW(max_sectors);\n\nstatic struct attribute *usb_sdev_attrs[] = {\n\t&dev_attr_max_sectors.attr,\n\tNULL,\n};\n\nATTRIBUTE_GROUPS(usb_sdev);\n\n \n\nstatic const struct scsi_host_template usb_stor_host_template = {\n\t \n\t.name =\t\t\t\t\"usb-storage\",\n\t.proc_name =\t\t\t\"usb-storage\",\n\t.show_info =\t\t\tshow_info,\n\t.write_info =\t\t\twrite_info,\n\t.info =\t\t\t\thost_info,\n\n\t \n\t.queuecommand =\t\t\tqueuecommand,\n\n\t \n\t.eh_abort_handler =\t\tcommand_abort,\n\t.eh_device_reset_handler =\tdevice_reset,\n\t.eh_bus_reset_handler =\t\tbus_reset,\n\n\t \n\t.can_queue =\t\t\t1,\n\n\t \n\t.this_id =\t\t\t-1,\n\n\t.slave_alloc =\t\t\tslave_alloc,\n\t.slave_configure =\t\tslave_configure,\n\t.target_alloc =\t\t\ttarget_alloc,\n\n\t \n\t.sg_tablesize =\t\t\tSG_MAX_SEGMENTS,\n\n\n\t \n\t.max_sectors =                  240,\n\n\t \n\t.emulated =\t\t\t1,\n\n\t \n\t.skip_settle_delay =\t\t1,\n\n\t \n\t.sdev_groups =\t\t\tusb_sdev_groups,\n\n\t \n\t.module =\t\t\tTHIS_MODULE\n};\n\nvoid usb_stor_host_template_init(struct scsi_host_template *sht,\n\t\t\t\t const char *name, struct module *owner)\n{\n\t*sht = usb_stor_host_template;\n\tsht->name = name;\n\tsht->proc_name = name;\n\tsht->module = owner;\n}\nEXPORT_SYMBOL_GPL(usb_stor_host_template_init);\n\n \nunsigned char usb_stor_sense_invalidCDB[18] = {\n\t[0]\t= 0x70,\t\t\t     \n\t[2]\t= ILLEGAL_REQUEST,\t     \n\t[7]\t= 0x0a,\t\t\t     \n\t[12]\t= 0x24\t\t\t     \n};\nEXPORT_SYMBOL_GPL(usb_stor_sense_invalidCDB);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}