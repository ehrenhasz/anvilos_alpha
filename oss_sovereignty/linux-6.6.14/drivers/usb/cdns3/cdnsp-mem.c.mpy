{
  "module_name": "cdnsp-mem.c",
  "hash_id": "e45f3e57be5619ab3c8d61d25a13702a6aae843fb862e3c4cbee7d5ba6a9221f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdnsp-mem.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include \"cdnsp-gadget.h\"\n#include \"cdnsp-trace.h\"\n\nstatic void cdnsp_free_stream_info(struct cdnsp_device *pdev,\n\t\t\t\t   struct cdnsp_ep *pep);\n \nstatic struct cdnsp_segment *cdnsp_segment_alloc(struct cdnsp_device *pdev,\n\t\t\t\t\t\t unsigned int cycle_state,\n\t\t\t\t\t\t unsigned int max_packet,\n\t\t\t\t\t\t gfp_t flags)\n{\n\tstruct cdnsp_segment *seg;\n\tdma_addr_t dma;\n\tint i;\n\n\tseg = kzalloc(sizeof(*seg), flags);\n\tif (!seg)\n\t\treturn NULL;\n\n\tseg->trbs = dma_pool_zalloc(pdev->segment_pool, flags, &dma);\n\tif (!seg->trbs) {\n\t\tkfree(seg);\n\t\treturn NULL;\n\t}\n\n\tif (max_packet) {\n\t\tseg->bounce_buf = kzalloc(max_packet, flags | GFP_DMA);\n\t\tif (!seg->bounce_buf)\n\t\t\tgoto free_dma;\n\t}\n\n\t \n\tif (cycle_state == 0) {\n\t\tfor (i = 0; i < TRBS_PER_SEGMENT; i++)\n\t\t\tseg->trbs[i].link.control |= cpu_to_le32(TRB_CYCLE);\n\t}\n\tseg->dma = dma;\n\tseg->next = NULL;\n\n\treturn seg;\n\nfree_dma:\n\tdma_pool_free(pdev->segment_pool, seg->trbs, dma);\n\tkfree(seg);\n\n\treturn NULL;\n}\n\nstatic void cdnsp_segment_free(struct cdnsp_device *pdev,\n\t\t\t       struct cdnsp_segment *seg)\n{\n\tif (seg->trbs)\n\t\tdma_pool_free(pdev->segment_pool, seg->trbs, seg->dma);\n\n\tkfree(seg->bounce_buf);\n\tkfree(seg);\n}\n\nstatic void cdnsp_free_segments_for_ring(struct cdnsp_device *pdev,\n\t\t\t\t\t struct cdnsp_segment *first)\n{\n\tstruct cdnsp_segment *seg;\n\n\tseg = first->next;\n\n\twhile (seg != first) {\n\t\tstruct cdnsp_segment *next = seg->next;\n\n\t\tcdnsp_segment_free(pdev, seg);\n\t\tseg = next;\n\t}\n\n\tcdnsp_segment_free(pdev, first);\n}\n\n \nstatic void cdnsp_link_segments(struct cdnsp_device *pdev,\n\t\t\t\tstruct cdnsp_segment *prev,\n\t\t\t\tstruct cdnsp_segment *next,\n\t\t\t\tenum cdnsp_ring_type type)\n{\n\tstruct cdnsp_link_trb *link;\n\tu32 val;\n\n\tif (!prev || !next)\n\t\treturn;\n\n\tprev->next = next;\n\tif (type != TYPE_EVENT) {\n\t\tlink = &prev->trbs[TRBS_PER_SEGMENT - 1].link;\n\t\tlink->segment_ptr = cpu_to_le64(next->dma);\n\n\t\t \n\t\tval = le32_to_cpu(link->control);\n\t\tval &= ~TRB_TYPE_BITMASK;\n\t\tval |= TRB_TYPE(TRB_LINK);\n\t\tlink->control = cpu_to_le32(val);\n\t}\n}\n\n \nstatic void cdnsp_link_rings(struct cdnsp_device *pdev,\n\t\t\t     struct cdnsp_ring *ring,\n\t\t\t     struct cdnsp_segment *first,\n\t\t\t     struct cdnsp_segment *last,\n\t\t\t     unsigned int num_segs)\n{\n\tstruct cdnsp_segment *next;\n\n\tif (!ring || !first || !last)\n\t\treturn;\n\n\tnext = ring->enq_seg->next;\n\tcdnsp_link_segments(pdev, ring->enq_seg, first, ring->type);\n\tcdnsp_link_segments(pdev, last, next, ring->type);\n\tring->num_segs += num_segs;\n\tring->num_trbs_free += (TRBS_PER_SEGMENT - 1) * num_segs;\n\n\tif (ring->type != TYPE_EVENT && ring->enq_seg == ring->last_seg) {\n\t\tring->last_seg->trbs[TRBS_PER_SEGMENT - 1].link.control &=\n\t\t\t~cpu_to_le32(LINK_TOGGLE);\n\t\tlast->trbs[TRBS_PER_SEGMENT - 1].link.control |=\n\t\t\tcpu_to_le32(LINK_TOGGLE);\n\t\tring->last_seg = last;\n\t}\n}\n\n \nstatic int cdnsp_insert_segment_mapping(struct radix_tree_root *trb_address_map,\n\t\t\t\t\tstruct cdnsp_ring *ring,\n\t\t\t\t\tstruct cdnsp_segment *seg,\n\t\t\t\t\tgfp_t mem_flags)\n{\n\tunsigned long key;\n\tint ret;\n\n\tkey = (unsigned long)(seg->dma >> TRB_SEGMENT_SHIFT);\n\n\t \n\tif (radix_tree_lookup(trb_address_map, key))\n\t\treturn 0;\n\n\tret = radix_tree_maybe_preload(mem_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = radix_tree_insert(trb_address_map, key, ring);\n\tradix_tree_preload_end();\n\n\treturn ret;\n}\n\nstatic void cdnsp_remove_segment_mapping(struct radix_tree_root *trb_address_map,\n\t\t\t\t\t struct cdnsp_segment *seg)\n{\n\tunsigned long key;\n\n\tkey = (unsigned long)(seg->dma >> TRB_SEGMENT_SHIFT);\n\tif (radix_tree_lookup(trb_address_map, key))\n\t\tradix_tree_delete(trb_address_map, key);\n}\n\nstatic int cdnsp_update_stream_segment_mapping(struct radix_tree_root *trb_address_map,\n\t\t\t\t\t       struct cdnsp_ring *ring,\n\t\t\t\t\t       struct cdnsp_segment *first_seg,\n\t\t\t\t\t       struct cdnsp_segment *last_seg,\n\t\t\t\t\t       gfp_t mem_flags)\n{\n\tstruct cdnsp_segment *failed_seg;\n\tstruct cdnsp_segment *seg;\n\tint ret;\n\n\tseg = first_seg;\n\tdo {\n\t\tret = cdnsp_insert_segment_mapping(trb_address_map, ring, seg,\n\t\t\t\t\t\t   mem_flags);\n\t\tif (ret)\n\t\t\tgoto remove_streams;\n\t\tif (seg == last_seg)\n\t\t\treturn 0;\n\t\tseg = seg->next;\n\t} while (seg != first_seg);\n\n\treturn 0;\n\nremove_streams:\n\tfailed_seg = seg;\n\tseg = first_seg;\n\tdo {\n\t\tcdnsp_remove_segment_mapping(trb_address_map, seg);\n\t\tif (seg == failed_seg)\n\t\t\treturn ret;\n\t\tseg = seg->next;\n\t} while (seg != first_seg);\n\n\treturn ret;\n}\n\nstatic void cdnsp_remove_stream_mapping(struct cdnsp_ring *ring)\n{\n\tstruct cdnsp_segment *seg;\n\n\tseg = ring->first_seg;\n\tdo {\n\t\tcdnsp_remove_segment_mapping(ring->trb_address_map, seg);\n\t\tseg = seg->next;\n\t} while (seg != ring->first_seg);\n}\n\nstatic int cdnsp_update_stream_mapping(struct cdnsp_ring *ring)\n{\n\treturn cdnsp_update_stream_segment_mapping(ring->trb_address_map, ring,\n\t\t\tring->first_seg, ring->last_seg, GFP_ATOMIC);\n}\n\nstatic void cdnsp_ring_free(struct cdnsp_device *pdev, struct cdnsp_ring *ring)\n{\n\tif (!ring)\n\t\treturn;\n\n\ttrace_cdnsp_ring_free(ring);\n\n\tif (ring->first_seg) {\n\t\tif (ring->type == TYPE_STREAM)\n\t\t\tcdnsp_remove_stream_mapping(ring);\n\n\t\tcdnsp_free_segments_for_ring(pdev, ring->first_seg);\n\t}\n\n\tkfree(ring);\n}\n\nvoid cdnsp_initialize_ring_info(struct cdnsp_ring *ring)\n{\n\tring->enqueue = ring->first_seg->trbs;\n\tring->enq_seg = ring->first_seg;\n\tring->dequeue = ring->enqueue;\n\tring->deq_seg = ring->first_seg;\n\n\t \n\tring->cycle_state = 1;\n\n\t \n\tring->num_trbs_free = ring->num_segs * (TRBS_PER_SEGMENT - 1) - 1;\n}\n\n \nstatic int cdnsp_alloc_segments_for_ring(struct cdnsp_device *pdev,\n\t\t\t\t\t struct cdnsp_segment **first,\n\t\t\t\t\t struct cdnsp_segment **last,\n\t\t\t\t\t unsigned int num_segs,\n\t\t\t\t\t unsigned int cycle_state,\n\t\t\t\t\t enum cdnsp_ring_type type,\n\t\t\t\t\t unsigned int max_packet,\n\t\t\t\t\t gfp_t flags)\n{\n\tstruct cdnsp_segment *prev;\n\n\t \n\tprev = cdnsp_segment_alloc(pdev, cycle_state, max_packet, flags);\n\tif (!prev)\n\t\treturn -ENOMEM;\n\n\tnum_segs--;\n\t*first = prev;\n\n\t \n\twhile (num_segs > 0) {\n\t\tstruct cdnsp_segment\t*next;\n\n\t\tnext = cdnsp_segment_alloc(pdev, cycle_state,\n\t\t\t\t\t   max_packet, flags);\n\t\tif (!next) {\n\t\t\tcdnsp_free_segments_for_ring(pdev, *first);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcdnsp_link_segments(pdev, prev, next, type);\n\n\t\tprev = next;\n\t\tnum_segs--;\n\t}\n\n\tcdnsp_link_segments(pdev, prev, *first, type);\n\t*last = prev;\n\n\treturn 0;\n}\n\n \nstatic struct cdnsp_ring *cdnsp_ring_alloc(struct cdnsp_device *pdev,\n\t\t\t\t\t   unsigned int num_segs,\n\t\t\t\t\t   enum cdnsp_ring_type type,\n\t\t\t\t\t   unsigned int max_packet,\n\t\t\t\t\t   gfp_t flags)\n{\n\tstruct cdnsp_ring *ring;\n\tint ret;\n\n\tring = kzalloc(sizeof *(ring), flags);\n\tif (!ring)\n\t\treturn NULL;\n\n\tring->num_segs = num_segs;\n\tring->bounce_buf_len = max_packet;\n\tINIT_LIST_HEAD(&ring->td_list);\n\tring->type = type;\n\n\tif (num_segs == 0)\n\t\treturn ring;\n\n\tret = cdnsp_alloc_segments_for_ring(pdev, &ring->first_seg,\n\t\t\t\t\t    &ring->last_seg, num_segs,\n\t\t\t\t\t    1, type, max_packet, flags);\n\tif (ret)\n\t\tgoto fail;\n\n\t \n\tif (type != TYPE_EVENT)\n\t\tring->last_seg->trbs[TRBS_PER_SEGMENT - 1].link.control |=\n\t\t\tcpu_to_le32(LINK_TOGGLE);\n\n\tcdnsp_initialize_ring_info(ring);\n\ttrace_cdnsp_ring_alloc(ring);\n\treturn ring;\nfail:\n\tkfree(ring);\n\treturn NULL;\n}\n\nvoid cdnsp_free_endpoint_rings(struct cdnsp_device *pdev, struct cdnsp_ep *pep)\n{\n\tcdnsp_ring_free(pdev, pep->ring);\n\tpep->ring = NULL;\n\tcdnsp_free_stream_info(pdev, pep);\n}\n\n \nint cdnsp_ring_expansion(struct cdnsp_device *pdev,\n\t\t\t struct cdnsp_ring *ring,\n\t\t\t unsigned int num_trbs,\n\t\t\t gfp_t flags)\n{\n\tunsigned int num_segs_needed;\n\tstruct cdnsp_segment *first;\n\tstruct cdnsp_segment *last;\n\tunsigned int num_segs;\n\tint ret;\n\n\tnum_segs_needed = (num_trbs + (TRBS_PER_SEGMENT - 1) - 1) /\n\t\t\t(TRBS_PER_SEGMENT - 1);\n\n\t \n\tnum_segs = max(ring->num_segs, num_segs_needed);\n\n\tret = cdnsp_alloc_segments_for_ring(pdev, &first, &last, num_segs,\n\t\t\t\t\t    ring->cycle_state, ring->type,\n\t\t\t\t\t    ring->bounce_buf_len, flags);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tif (ring->type == TYPE_STREAM)\n\t\tret = cdnsp_update_stream_segment_mapping(ring->trb_address_map,\n\t\t\t\t\t\t\t  ring, first,\n\t\t\t\t\t\t\t  last, flags);\n\n\tif (ret) {\n\t\tcdnsp_free_segments_for_ring(pdev, first);\n\n\t\treturn ret;\n\t}\n\n\tcdnsp_link_rings(pdev, ring, first, last, num_segs);\n\ttrace_cdnsp_ring_expansion(ring);\n\n\treturn 0;\n}\n\nstatic int cdnsp_init_device_ctx(struct cdnsp_device *pdev)\n{\n\tint size = HCC_64BYTE_CONTEXT(pdev->hcc_params) ? 2048 : 1024;\n\n\tpdev->out_ctx.type = CDNSP_CTX_TYPE_DEVICE;\n\tpdev->out_ctx.size = size;\n\tpdev->out_ctx.ctx_size = CTX_SIZE(pdev->hcc_params);\n\tpdev->out_ctx.bytes = dma_pool_zalloc(pdev->device_pool, GFP_ATOMIC,\n\t\t\t\t\t      &pdev->out_ctx.dma);\n\n\tif (!pdev->out_ctx.bytes)\n\t\treturn -ENOMEM;\n\n\tpdev->in_ctx.type = CDNSP_CTX_TYPE_INPUT;\n\tpdev->in_ctx.ctx_size = pdev->out_ctx.ctx_size;\n\tpdev->in_ctx.size = size + pdev->out_ctx.ctx_size;\n\tpdev->in_ctx.bytes = dma_pool_zalloc(pdev->device_pool, GFP_ATOMIC,\n\t\t\t\t\t     &pdev->in_ctx.dma);\n\n\tif (!pdev->in_ctx.bytes) {\n\t\tdma_pool_free(pdev->device_pool, pdev->out_ctx.bytes,\n\t\t\t      pdev->out_ctx.dma);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstruct cdnsp_input_control_ctx\n\t*cdnsp_get_input_control_ctx(struct cdnsp_container_ctx *ctx)\n{\n\tif (ctx->type != CDNSP_CTX_TYPE_INPUT)\n\t\treturn NULL;\n\n\treturn (struct cdnsp_input_control_ctx *)ctx->bytes;\n}\n\nstruct cdnsp_slot_ctx *cdnsp_get_slot_ctx(struct cdnsp_container_ctx *ctx)\n{\n\tif (ctx->type == CDNSP_CTX_TYPE_DEVICE)\n\t\treturn (struct cdnsp_slot_ctx *)ctx->bytes;\n\n\treturn (struct cdnsp_slot_ctx *)(ctx->bytes + ctx->ctx_size);\n}\n\nstruct cdnsp_ep_ctx *cdnsp_get_ep_ctx(struct cdnsp_container_ctx *ctx,\n\t\t\t\t      unsigned int ep_index)\n{\n\t \n\tep_index++;\n\tif (ctx->type == CDNSP_CTX_TYPE_INPUT)\n\t\tep_index++;\n\n\treturn (struct cdnsp_ep_ctx *)(ctx->bytes + (ep_index * ctx->ctx_size));\n}\n\nstatic void cdnsp_free_stream_ctx(struct cdnsp_device *pdev,\n\t\t\t\t  struct cdnsp_ep *pep)\n{\n\tdma_pool_free(pdev->device_pool, pep->stream_info.stream_ctx_array,\n\t\t      pep->stream_info.ctx_array_dma);\n}\n\n \nstatic struct cdnsp_stream_ctx\n\t*cdnsp_alloc_stream_ctx(struct cdnsp_device *pdev, struct cdnsp_ep *pep)\n{\n\tsize_t size = sizeof(struct cdnsp_stream_ctx) *\n\t\t      pep->stream_info.num_stream_ctxs;\n\n\tif (size > CDNSP_CTX_SIZE)\n\t\treturn NULL;\n\n\t \n\treturn dma_pool_zalloc(pdev->device_pool, GFP_DMA32 | GFP_ATOMIC,\n\t\t\t       &pep->stream_info.ctx_array_dma);\n}\n\nstruct cdnsp_ring *cdnsp_dma_to_transfer_ring(struct cdnsp_ep *pep, u64 address)\n{\n\tif (pep->ep_state & EP_HAS_STREAMS)\n\t\treturn radix_tree_lookup(&pep->stream_info.trb_address_map,\n\t\t\t\t\t address >> TRB_SEGMENT_SHIFT);\n\n\treturn pep->ring;\n}\n\n \nint cdnsp_alloc_stream_info(struct cdnsp_device *pdev,\n\t\t\t    struct cdnsp_ep *pep,\n\t\t\t    unsigned int num_stream_ctxs,\n\t\t\t    unsigned int num_streams)\n{\n\tstruct cdnsp_stream_info *stream_info;\n\tstruct cdnsp_ring *cur_ring;\n\tu32 cur_stream;\n\tu64 addr;\n\tint ret;\n\tint mps;\n\n\tstream_info = &pep->stream_info;\n\tstream_info->num_streams = num_streams;\n\tstream_info->num_stream_ctxs = num_stream_ctxs;\n\n\t \n\tstream_info->stream_rings = kcalloc(num_streams,\n\t\t\t\t\t    sizeof(struct cdnsp_ring *),\n\t\t\t\t\t    GFP_ATOMIC);\n\tif (!stream_info->stream_rings)\n\t\treturn -ENOMEM;\n\n\t \n\tstream_info->stream_ctx_array = cdnsp_alloc_stream_ctx(pdev, pep);\n\tif (!stream_info->stream_ctx_array)\n\t\tgoto cleanup_stream_rings;\n\n\tmemset(stream_info->stream_ctx_array, 0,\n\t       sizeof(struct cdnsp_stream_ctx) * num_stream_ctxs);\n\tINIT_RADIX_TREE(&stream_info->trb_address_map, GFP_ATOMIC);\n\tmps = usb_endpoint_maxp(pep->endpoint.desc);\n\n\t \n\tfor (cur_stream = 1; cur_stream < num_streams; cur_stream++) {\n\t\tcur_ring = cdnsp_ring_alloc(pdev, 2, TYPE_STREAM, mps,\n\t\t\t\t\t    GFP_ATOMIC);\n\t\tstream_info->stream_rings[cur_stream] = cur_ring;\n\n\t\tif (!cur_ring)\n\t\t\tgoto cleanup_rings;\n\n\t\tcur_ring->stream_id = cur_stream;\n\t\tcur_ring->trb_address_map = &stream_info->trb_address_map;\n\n\t\t \n\t\taddr = cur_ring->first_seg->dma | SCT_FOR_CTX(SCT_PRI_TR) |\n\t\t       cur_ring->cycle_state;\n\n\t\tstream_info->stream_ctx_array[cur_stream].stream_ring =\n\t\t\tcpu_to_le64(addr);\n\n\t\ttrace_cdnsp_set_stream_ring(cur_ring);\n\n\t\tret = cdnsp_update_stream_mapping(cur_ring);\n\t\tif (ret)\n\t\t\tgoto cleanup_rings;\n\t}\n\n\treturn 0;\n\ncleanup_rings:\n\tfor (cur_stream = 1; cur_stream < num_streams; cur_stream++) {\n\t\tcur_ring = stream_info->stream_rings[cur_stream];\n\t\tif (cur_ring) {\n\t\t\tcdnsp_ring_free(pdev, cur_ring);\n\t\t\tstream_info->stream_rings[cur_stream] = NULL;\n\t\t}\n\t}\n\ncleanup_stream_rings:\n\tkfree(pep->stream_info.stream_rings);\n\n\treturn -ENOMEM;\n}\n\n \nstatic void cdnsp_free_stream_info(struct cdnsp_device *pdev,\n\t\t\t\t   struct cdnsp_ep *pep)\n{\n\tstruct cdnsp_stream_info *stream_info = &pep->stream_info;\n\tstruct cdnsp_ring *cur_ring;\n\tint cur_stream;\n\n\tif (!(pep->ep_state & EP_HAS_STREAMS))\n\t\treturn;\n\n\tfor (cur_stream = 1; cur_stream < stream_info->num_streams;\n\t     cur_stream++) {\n\t\tcur_ring = stream_info->stream_rings[cur_stream];\n\t\tif (cur_ring) {\n\t\t\tcdnsp_ring_free(pdev, cur_ring);\n\t\t\tstream_info->stream_rings[cur_stream] = NULL;\n\t\t}\n\t}\n\n\tif (stream_info->stream_ctx_array)\n\t\tcdnsp_free_stream_ctx(pdev, pep);\n\n\tkfree(stream_info->stream_rings);\n\tpep->ep_state &= ~EP_HAS_STREAMS;\n}\n\n \nstatic void cdnsp_free_priv_device(struct cdnsp_device *pdev)\n{\n\tpdev->dcbaa->dev_context_ptrs[1] = 0;\n\n\tcdnsp_free_endpoint_rings(pdev, &pdev->eps[0]);\n\n\tif (pdev->in_ctx.bytes)\n\t\tdma_pool_free(pdev->device_pool, pdev->in_ctx.bytes,\n\t\t\t      pdev->in_ctx.dma);\n\n\tif (pdev->out_ctx.bytes)\n\t\tdma_pool_free(pdev->device_pool, pdev->out_ctx.bytes,\n\t\t\t      pdev->out_ctx.dma);\n\n\tpdev->in_ctx.bytes = NULL;\n\tpdev->out_ctx.bytes = NULL;\n}\n\nstatic int cdnsp_alloc_priv_device(struct cdnsp_device *pdev)\n{\n\tint ret;\n\n\tret = cdnsp_init_device_ctx(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpdev->eps[0].ring = cdnsp_ring_alloc(pdev, 2, TYPE_CTRL, 0, GFP_ATOMIC);\n\tif (!pdev->eps[0].ring)\n\t\tgoto fail;\n\n\t \n\tpdev->dcbaa->dev_context_ptrs[1] = cpu_to_le64(pdev->out_ctx.dma);\n\tpdev->cmd.in_ctx = &pdev->in_ctx;\n\n\ttrace_cdnsp_alloc_priv_device(pdev);\n\treturn 0;\nfail:\n\tdma_pool_free(pdev->device_pool, pdev->out_ctx.bytes,\n\t\t      pdev->out_ctx.dma);\n\tdma_pool_free(pdev->device_pool, pdev->in_ctx.bytes,\n\t\t      pdev->in_ctx.dma);\n\n\treturn ret;\n}\n\nvoid cdnsp_copy_ep0_dequeue_into_input_ctx(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_ep_ctx *ep0_ctx = pdev->eps[0].in_ctx;\n\tstruct cdnsp_ring *ep_ring = pdev->eps[0].ring;\n\tdma_addr_t dma;\n\n\tdma = cdnsp_trb_virt_to_dma(ep_ring->enq_seg, ep_ring->enqueue);\n\tep0_ctx->deq = cpu_to_le64(dma | ep_ring->cycle_state);\n}\n\n \nint cdnsp_setup_addressable_priv_dev(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tstruct cdnsp_ep_ctx *ep0_ctx;\n\tu32 max_packets, port;\n\n\tep0_ctx = cdnsp_get_ep_ctx(&pdev->in_ctx, 0);\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->in_ctx);\n\n\t \n\tslot_ctx->dev_info |= cpu_to_le32(LAST_CTX(1));\n\n\tswitch (pdev->gadget.speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tslot_ctx->dev_info |= cpu_to_le32(SLOT_SPEED_SSP);\n\t\tmax_packets = MAX_PACKET(512);\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tslot_ctx->dev_info |= cpu_to_le32(SLOT_SPEED_SS);\n\t\tmax_packets = MAX_PACKET(512);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tslot_ctx->dev_info |= cpu_to_le32(SLOT_SPEED_HS);\n\t\tmax_packets = MAX_PACKET(64);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tslot_ctx->dev_info |= cpu_to_le32(SLOT_SPEED_FS);\n\t\tmax_packets = MAX_PACKET(64);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tport = DEV_PORT(pdev->active_port->port_num);\n\tslot_ctx->dev_port |= cpu_to_le32(port);\n\tslot_ctx->dev_state = cpu_to_le32((pdev->device_address &\n\t\t\t\t\t   DEV_ADDR_MASK));\n\tep0_ctx->tx_info = cpu_to_le32(EP_AVG_TRB_LENGTH(0x8));\n\tep0_ctx->ep_info2 = cpu_to_le32(EP_TYPE(CTRL_EP));\n\tep0_ctx->ep_info2 |= cpu_to_le32(MAX_BURST(0) | ERROR_COUNT(3) |\n\t\t\t\t\t max_packets);\n\n\tep0_ctx->deq = cpu_to_le64(pdev->eps[0].ring->first_seg->dma |\n\t\t\t\t   pdev->eps[0].ring->cycle_state);\n\n\ttrace_cdnsp_setup_addressable_priv_device(pdev);\n\n\treturn 0;\n}\n\n \nstatic unsigned int cdnsp_parse_exponent_interval(struct usb_gadget *g,\n\t\t\t\t\t\t  struct cdnsp_ep *pep)\n{\n\tunsigned int interval;\n\n\tinterval = clamp_val(pep->endpoint.desc->bInterval, 1, 16) - 1;\n\tif (interval != pep->endpoint.desc->bInterval - 1)\n\t\tdev_warn(&g->dev, \"ep %s - rounding interval to %d %sframes\\n\",\n\t\t\t pep->name, 1 << interval,\n\t\t\t g->speed == USB_SPEED_FULL ? \"\" : \"micro\");\n\n\t \n\tif (g->speed == USB_SPEED_FULL)\n\t\tinterval += 3;\t \n\n\t \n\tif (interval > 12)\n\t\tinterval = 12;\n\n\treturn interval;\n}\n\n \nstatic unsigned int cdnsp_microframes_to_exponent(struct usb_gadget *g,\n\t\t\t\t\t\t  struct cdnsp_ep *pep,\n\t\t\t\t\t\t  unsigned int desc_interval,\n\t\t\t\t\t\t  unsigned int min_exponent,\n\t\t\t\t\t\t  unsigned int max_exponent)\n{\n\tunsigned int interval;\n\n\tinterval = fls(desc_interval) - 1;\n\treturn clamp_val(interval, min_exponent, max_exponent);\n}\n\n \nstatic unsigned int cdnsp_get_endpoint_interval(struct usb_gadget *g,\n\t\t\t\t\t\tstruct cdnsp_ep *pep)\n{\n\tunsigned int interval = 0;\n\n\tswitch (g->speed) {\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER_PLUS:\n\tcase USB_SPEED_SUPER:\n\t\tif (usb_endpoint_xfer_int(pep->endpoint.desc) ||\n\t\t    usb_endpoint_xfer_isoc(pep->endpoint.desc))\n\t\t\tinterval = cdnsp_parse_exponent_interval(g, pep);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tif (usb_endpoint_xfer_isoc(pep->endpoint.desc)) {\n\t\t\tinterval = cdnsp_parse_exponent_interval(g, pep);\n\t\t} else if (usb_endpoint_xfer_int(pep->endpoint.desc)) {\n\t\t\tinterval = pep->endpoint.desc->bInterval << 3;\n\t\t\tinterval = cdnsp_microframes_to_exponent(g, pep,\n\t\t\t\t\t\t\t\t interval,\n\t\t\t\t\t\t\t\t 3, 10);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n\n\treturn interval;\n}\n\n \nstatic u32 cdnsp_get_endpoint_mult(struct usb_gadget *g, struct cdnsp_ep *pep)\n{\n\tif (g->speed < USB_SPEED_SUPER ||\n\t    !usb_endpoint_xfer_isoc(pep->endpoint.desc))\n\t\treturn 0;\n\n\treturn pep->endpoint.comp_desc->bmAttributes;\n}\n\nstatic u32 cdnsp_get_endpoint_max_burst(struct usb_gadget *g,\n\t\t\t\t\tstruct cdnsp_ep *pep)\n{\n\t \n\tif (g->speed >= USB_SPEED_SUPER)\n\t\treturn pep->endpoint.comp_desc->bMaxBurst;\n\n\tif (g->speed == USB_SPEED_HIGH &&\n\t    (usb_endpoint_xfer_isoc(pep->endpoint.desc) ||\n\t     usb_endpoint_xfer_int(pep->endpoint.desc)))\n\t\treturn usb_endpoint_maxp_mult(pep->endpoint.desc) - 1;\n\n\treturn 0;\n}\n\nstatic u32 cdnsp_get_endpoint_type(const struct usb_endpoint_descriptor *desc)\n{\n\tint in;\n\n\tin = usb_endpoint_dir_in(desc);\n\n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\treturn CTRL_EP;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\treturn in ? BULK_IN_EP : BULK_OUT_EP;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\treturn in ? ISOC_IN_EP : ISOC_OUT_EP;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\treturn in ? INT_IN_EP : INT_OUT_EP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 cdnsp_get_max_esit_payload(struct usb_gadget *g,\n\t\t\t\t      struct cdnsp_ep *pep)\n{\n\tint max_packet;\n\tint max_burst;\n\n\t \n\tif (usb_endpoint_xfer_control(pep->endpoint.desc) ||\n\t    usb_endpoint_xfer_bulk(pep->endpoint.desc))\n\t\treturn 0;\n\n\t \n\tif (g->speed >= USB_SPEED_SUPER_PLUS &&\n\t    USB_SS_SSP_ISOC_COMP(pep->endpoint.desc->bmAttributes))\n\t\treturn le16_to_cpu(pep->endpoint.comp_desc->wBytesPerInterval);\n\t \n\telse if (g->speed >= USB_SPEED_SUPER)\n\t\treturn le16_to_cpu(pep->endpoint.comp_desc->wBytesPerInterval);\n\n\tmax_packet = usb_endpoint_maxp(pep->endpoint.desc);\n\tmax_burst = usb_endpoint_maxp_mult(pep->endpoint.desc);\n\n\t \n\treturn max_packet * max_burst;\n}\n\nint cdnsp_endpoint_init(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_ep *pep,\n\t\t\tgfp_t mem_flags)\n{\n\tenum cdnsp_ring_type ring_type;\n\tstruct cdnsp_ep_ctx *ep_ctx;\n\tunsigned int err_count = 0;\n\tunsigned int avg_trb_len;\n\tunsigned int max_packet;\n\tunsigned int max_burst;\n\tunsigned int interval;\n\tu32 max_esit_payload;\n\tunsigned int mult;\n\tu32 endpoint_type;\n\tint ret;\n\n\tep_ctx = pep->in_ctx;\n\n\tendpoint_type = cdnsp_get_endpoint_type(pep->endpoint.desc);\n\tif (!endpoint_type)\n\t\treturn -EINVAL;\n\n\tring_type = usb_endpoint_type(pep->endpoint.desc);\n\n\t \n\tmax_esit_payload = cdnsp_get_max_esit_payload(&pdev->gadget, pep);\n\tinterval = cdnsp_get_endpoint_interval(&pdev->gadget, pep);\n\tmult = cdnsp_get_endpoint_mult(&pdev->gadget, pep);\n\tmax_packet = usb_endpoint_maxp(pep->endpoint.desc);\n\tmax_burst = cdnsp_get_endpoint_max_burst(&pdev->gadget, pep);\n\tavg_trb_len = max_esit_payload;\n\n\t \n\tif (!usb_endpoint_xfer_isoc(pep->endpoint.desc))\n\t\terr_count = 3;\n\tif (usb_endpoint_xfer_bulk(pep->endpoint.desc) &&\n\t    pdev->gadget.speed == USB_SPEED_HIGH)\n\t\tmax_packet = 512;\n\t \n\tif (usb_endpoint_xfer_control(pep->endpoint.desc))\n\t\tavg_trb_len = 8;\n\n\t \n\tpep->ring = cdnsp_ring_alloc(pdev, 2, ring_type, max_packet, mem_flags);\n\tif (!pep->ring)\n\t\treturn -ENOMEM;\n\n\tpep->skip = false;\n\n\t \n\tep_ctx->ep_info = cpu_to_le32(EP_MAX_ESIT_PAYLOAD_HI(max_esit_payload) |\n\t\t\t\tEP_INTERVAL(interval) | EP_MULT(mult));\n\tep_ctx->ep_info2 = cpu_to_le32(EP_TYPE(endpoint_type) |\n\t\t\t\tMAX_PACKET(max_packet) | MAX_BURST(max_burst) |\n\t\t\t\tERROR_COUNT(err_count));\n\tep_ctx->deq = cpu_to_le64(pep->ring->first_seg->dma |\n\t\t\t\t  pep->ring->cycle_state);\n\n\tep_ctx->tx_info = cpu_to_le32(EP_MAX_ESIT_PAYLOAD_LO(max_esit_payload) |\n\t\t\t\tEP_AVG_TRB_LENGTH(avg_trb_len));\n\n\tif (usb_endpoint_xfer_bulk(pep->endpoint.desc) &&\n\t    pdev->gadget.speed > USB_SPEED_HIGH) {\n\t\tret = cdnsp_alloc_streams(pdev, pep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid cdnsp_endpoint_zero(struct cdnsp_device *pdev, struct cdnsp_ep *pep)\n{\n\tpep->in_ctx->ep_info = 0;\n\tpep->in_ctx->ep_info2 = 0;\n\tpep->in_ctx->deq = 0;\n\tpep->in_ctx->tx_info = 0;\n}\n\nstatic int cdnsp_alloc_erst(struct cdnsp_device *pdev,\n\t\t\t    struct cdnsp_ring *evt_ring,\n\t\t\t    struct cdnsp_erst *erst)\n{\n\tstruct cdnsp_erst_entry *entry;\n\tstruct cdnsp_segment *seg;\n\tunsigned int val;\n\tsize_t size;\n\n\tsize = sizeof(struct cdnsp_erst_entry) * evt_ring->num_segs;\n\terst->entries = dma_alloc_coherent(pdev->dev, size,\n\t\t\t\t\t   &erst->erst_dma_addr, GFP_KERNEL);\n\tif (!erst->entries)\n\t\treturn -ENOMEM;\n\n\terst->num_entries = evt_ring->num_segs;\n\n\tseg = evt_ring->first_seg;\n\tfor (val = 0; val < evt_ring->num_segs; val++) {\n\t\tentry = &erst->entries[val];\n\t\tentry->seg_addr = cpu_to_le64(seg->dma);\n\t\tentry->seg_size = cpu_to_le32(TRBS_PER_SEGMENT);\n\t\tentry->rsvd = 0;\n\t\tseg = seg->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void cdnsp_free_erst(struct cdnsp_device *pdev, struct cdnsp_erst *erst)\n{\n\tsize_t size = sizeof(struct cdnsp_erst_entry) * (erst->num_entries);\n\tstruct device *dev = pdev->dev;\n\n\tif (erst->entries)\n\t\tdma_free_coherent(dev, size, erst->entries,\n\t\t\t\t  erst->erst_dma_addr);\n\n\terst->entries = NULL;\n}\n\nvoid cdnsp_mem_cleanup(struct cdnsp_device *pdev)\n{\n\tstruct device *dev = pdev->dev;\n\n\tcdnsp_free_priv_device(pdev);\n\tcdnsp_free_erst(pdev, &pdev->erst);\n\n\tif (pdev->event_ring)\n\t\tcdnsp_ring_free(pdev, pdev->event_ring);\n\n\tpdev->event_ring = NULL;\n\n\tif (pdev->cmd_ring)\n\t\tcdnsp_ring_free(pdev, pdev->cmd_ring);\n\n\tpdev->cmd_ring = NULL;\n\n\tdma_pool_destroy(pdev->segment_pool);\n\tpdev->segment_pool = NULL;\n\tdma_pool_destroy(pdev->device_pool);\n\tpdev->device_pool = NULL;\n\n\tdma_free_coherent(dev, sizeof(*pdev->dcbaa),\n\t\t\t  pdev->dcbaa, pdev->dcbaa->dma);\n\n\tpdev->dcbaa = NULL;\n\n\tpdev->usb2_port.exist = 0;\n\tpdev->usb3_port.exist = 0;\n\tpdev->usb2_port.port_num = 0;\n\tpdev->usb3_port.port_num = 0;\n\tpdev->active_port = NULL;\n}\n\nstatic void cdnsp_set_event_deq(struct cdnsp_device *pdev)\n{\n\tdma_addr_t deq;\n\tu64 temp;\n\n\tdeq = cdnsp_trb_virt_to_dma(pdev->event_ring->deq_seg,\n\t\t\t\t    pdev->event_ring->dequeue);\n\n\t \n\ttemp = cdnsp_read_64(&pdev->ir_set->erst_dequeue);\n\ttemp &= ERST_PTR_MASK;\n\n\t \n\ttemp &= ~ERST_EHB;\n\n\tcdnsp_write_64(((u64)deq & (u64)~ERST_PTR_MASK) | temp,\n\t\t       &pdev->ir_set->erst_dequeue);\n}\n\nstatic void cdnsp_add_in_port(struct cdnsp_device *pdev,\n\t\t\t      struct cdnsp_port *port,\n\t\t\t      __le32 __iomem *addr)\n{\n\tu32 temp, port_offset, port_count;\n\n\ttemp = readl(addr);\n\tport->maj_rev = CDNSP_EXT_PORT_MAJOR(temp);\n\tport->min_rev = CDNSP_EXT_PORT_MINOR(temp);\n\n\t \n\ttemp = readl(addr + 2);\n\tport_offset = CDNSP_EXT_PORT_OFF(temp);\n\tport_count = CDNSP_EXT_PORT_COUNT(temp);\n\n\ttrace_cdnsp_port_info(addr, port_offset, port_count, port->maj_rev);\n\n\tport->port_num = port_offset;\n\tport->exist = 1;\n}\n\n \nstatic int cdnsp_setup_port_arrays(struct cdnsp_device *pdev)\n{\n\tvoid __iomem *base;\n\tu32 offset;\n\tint i;\n\n\tbase = &pdev->cap_regs->hc_capbase;\n\toffset = cdnsp_find_next_ext_cap(base, 0,\n\t\t\t\t\t EXT_CAP_CFG_DEV_20PORT_CAP_ID);\n\tpdev->port20_regs = base + offset;\n\n\toffset = cdnsp_find_next_ext_cap(base, 0, D_XEC_CFG_3XPORT_CAP);\n\tpdev->port3x_regs =  base + offset;\n\n\toffset = 0;\n\tbase = &pdev->cap_regs->hc_capbase;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tu32 temp;\n\n\t\toffset = cdnsp_find_next_ext_cap(base, offset,\n\t\t\t\t\t\t EXT_CAPS_PROTOCOL);\n\t\ttemp = readl(base + offset);\n\n\t\tif (CDNSP_EXT_PORT_MAJOR(temp) == 0x03 &&\n\t\t    !pdev->usb3_port.port_num)\n\t\t\tcdnsp_add_in_port(pdev, &pdev->usb3_port,\n\t\t\t\t\t  base + offset);\n\n\t\tif (CDNSP_EXT_PORT_MAJOR(temp) == 0x02 &&\n\t\t    !pdev->usb2_port.port_num)\n\t\t\tcdnsp_add_in_port(pdev, &pdev->usb2_port,\n\t\t\t\t\t  base + offset);\n\t}\n\n\tif (!pdev->usb2_port.exist || !pdev->usb3_port.exist) {\n\t\tdev_err(pdev->dev, \"Error: Only one port detected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\ttrace_cdnsp_init(\"Found USB 2.0 ports and  USB 3.0 ports.\");\n\n\tpdev->usb2_port.regs = (struct cdnsp_port_regs __iomem *)\n\t\t\t       (&pdev->op_regs->port_reg_base + NUM_PORT_REGS *\n\t\t\t\t(pdev->usb2_port.port_num - 1));\n\n\tpdev->usb3_port.regs = (struct cdnsp_port_regs __iomem *)\n\t\t\t       (&pdev->op_regs->port_reg_base + NUM_PORT_REGS *\n\t\t\t\t(pdev->usb3_port.port_num - 1));\n\n\treturn 0;\n}\n\n \nint cdnsp_mem_init(struct cdnsp_device *pdev)\n{\n\tstruct device *dev = pdev->dev;\n\tint ret = -ENOMEM;\n\tunsigned int val;\n\tdma_addr_t dma;\n\tu32 page_size;\n\tu64 val_64;\n\n\t \n\tpage_size = 1 << 12;\n\n\tval = readl(&pdev->op_regs->config_reg);\n\tval |= ((val & ~MAX_DEVS) | CDNSP_DEV_MAX_SLOTS) | CONFIG_U3E;\n\twritel(val, &pdev->op_regs->config_reg);\n\n\t \n\tpdev->dcbaa = dma_alloc_coherent(dev, sizeof(*pdev->dcbaa),\n\t\t\t\t\t &dma, GFP_KERNEL);\n\tif (!pdev->dcbaa)\n\t\treturn -ENOMEM;\n\n\tpdev->dcbaa->dma = dma;\n\n\tcdnsp_write_64(dma, &pdev->op_regs->dcbaa_ptr);\n\n\t \n\tpdev->segment_pool = dma_pool_create(\"CDNSP ring segments\", dev,\n\t\t\t\t\t     TRB_SEGMENT_SIZE, TRB_SEGMENT_SIZE,\n\t\t\t\t\t     page_size);\n\tif (!pdev->segment_pool)\n\t\tgoto release_dcbaa;\n\n\tpdev->device_pool = dma_pool_create(\"CDNSP input/output contexts\", dev,\n\t\t\t\t\t    CDNSP_CTX_SIZE, 64, page_size);\n\tif (!pdev->device_pool)\n\t\tgoto destroy_segment_pool;\n\n\n\t \n\tpdev->cmd_ring = cdnsp_ring_alloc(pdev, 1, TYPE_COMMAND, 0, GFP_KERNEL);\n\tif (!pdev->cmd_ring)\n\t\tgoto destroy_device_pool;\n\n\t \n\tval_64 = cdnsp_read_64(&pdev->op_regs->cmd_ring);\n\tval_64 = (val_64 & (u64)CMD_RING_RSVD_BITS) |\n\t\t (pdev->cmd_ring->first_seg->dma & (u64)~CMD_RING_RSVD_BITS) |\n\t\t pdev->cmd_ring->cycle_state;\n\tcdnsp_write_64(val_64, &pdev->op_regs->cmd_ring);\n\n\tval = readl(&pdev->cap_regs->db_off);\n\tval &= DBOFF_MASK;\n\tpdev->dba = (void __iomem *)pdev->cap_regs + val;\n\n\t \n\tpdev->ir_set = &pdev->run_regs->ir_set[0];\n\n\t \n\tpdev->event_ring = cdnsp_ring_alloc(pdev, ERST_NUM_SEGS, TYPE_EVENT,\n\t\t\t\t\t    0, GFP_KERNEL);\n\tif (!pdev->event_ring)\n\t\tgoto free_cmd_ring;\n\n\tret = cdnsp_alloc_erst(pdev, pdev->event_ring, &pdev->erst);\n\tif (ret)\n\t\tgoto free_event_ring;\n\n\t \n\tval = readl(&pdev->ir_set->erst_size);\n\tval &= ERST_SIZE_MASK;\n\tval |= ERST_NUM_SEGS;\n\twritel(val, &pdev->ir_set->erst_size);\n\n\t \n\tval_64 = cdnsp_read_64(&pdev->ir_set->erst_base);\n\tval_64 &= ERST_PTR_MASK;\n\tval_64 |= (pdev->erst.erst_dma_addr & (u64)~ERST_PTR_MASK);\n\tcdnsp_write_64(val_64, &pdev->ir_set->erst_base);\n\n\t \n\tcdnsp_set_event_deq(pdev);\n\n\tret = cdnsp_setup_port_arrays(pdev);\n\tif (ret)\n\t\tgoto free_erst;\n\n\tret = cdnsp_alloc_priv_device(pdev);\n\tif (ret) {\n\t\tdev_err(pdev->dev,\n\t\t\t\"Could not allocate cdnsp_device data structures\\n\");\n\t\tgoto free_erst;\n\t}\n\n\treturn 0;\n\nfree_erst:\n\tcdnsp_free_erst(pdev, &pdev->erst);\nfree_event_ring:\n\tcdnsp_ring_free(pdev, pdev->event_ring);\nfree_cmd_ring:\n\tcdnsp_ring_free(pdev, pdev->cmd_ring);\ndestroy_device_pool:\n\tdma_pool_destroy(pdev->device_pool);\ndestroy_segment_pool:\n\tdma_pool_destroy(pdev->segment_pool);\nrelease_dcbaa:\n\tdma_free_coherent(dev, sizeof(*pdev->dcbaa), pdev->dcbaa,\n\t\t\t  pdev->dcbaa->dma);\n\n\tcdnsp_reset(pdev);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}