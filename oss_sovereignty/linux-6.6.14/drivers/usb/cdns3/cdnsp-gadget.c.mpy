{
  "module_name": "cdnsp-gadget.c",
  "hash_id": "725f9f76a5c850d1b62dd7fa8d6f8fb8fa5e8a9ad6e08f339c1a874e9b33c026",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdnsp-gadget.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/iopoll.h>\n#include <linux/delay.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n#include <linux/irq.h>\n#include <linux/dmi.h>\n\n#include \"core.h\"\n#include \"gadget-export.h\"\n#include \"drd.h\"\n#include \"cdnsp-gadget.h\"\n#include \"cdnsp-trace.h\"\n\nunsigned int cdnsp_port_speed(unsigned int port_status)\n{\n\t \n\tif (DEV_SUPERSPEEDPLUS(port_status))\n\t\treturn USB_SPEED_SUPER_PLUS;\n\telse if (DEV_SUPERSPEED(port_status))\n\t\treturn USB_SPEED_SUPER;\n\telse if (DEV_HIGHSPEED(port_status))\n\t\treturn USB_SPEED_HIGH;\n\telse if (DEV_FULLSPEED(port_status))\n\t\treturn USB_SPEED_FULL;\n\n\t \n\treturn USB_SPEED_UNKNOWN;\n}\n\n \nu32 cdnsp_port_state_to_neutral(u32 state)\n{\n\t \n\treturn (state & CDNSP_PORT_RO) | (state & CDNSP_PORT_RWS);\n}\n\n \nint cdnsp_find_next_ext_cap(void __iomem *base, u32 start, int id)\n{\n\tu32 offset = start;\n\tu32 next;\n\tu32 val;\n\n\tif (!start || start == HCC_PARAMS_OFFSET) {\n\t\tval = readl(base + HCC_PARAMS_OFFSET);\n\t\tif (val == ~0)\n\t\t\treturn 0;\n\n\t\toffset = HCC_EXT_CAPS(val) << 2;\n\t\tif (!offset)\n\t\t\treturn 0;\n\t}\n\n\tdo {\n\t\tval = readl(base + offset);\n\t\tif (val == ~0)\n\t\t\treturn 0;\n\n\t\tif (EXT_CAPS_ID(val) == id && offset != start)\n\t\t\treturn offset;\n\n\t\tnext = EXT_CAPS_NEXT(val);\n\t\toffset += next << 2;\n\t} while (next);\n\n\treturn 0;\n}\n\nvoid cdnsp_set_link_state(struct cdnsp_device *pdev,\n\t\t\t  __le32 __iomem *port_regs,\n\t\t\t  u32 link_state)\n{\n\tint port_num = 0xFF;\n\tu32 temp;\n\n\ttemp = readl(port_regs);\n\ttemp = cdnsp_port_state_to_neutral(temp);\n\ttemp |= PORT_WKCONN_E | PORT_WKDISC_E;\n\twritel(temp, port_regs);\n\n\ttemp &= ~PORT_PLS_MASK;\n\ttemp |= PORT_LINK_STROBE | link_state;\n\n\tif (pdev->active_port)\n\t\tport_num = pdev->active_port->port_num;\n\n\ttrace_cdnsp_handle_port_status(port_num, readl(port_regs));\n\twritel(temp, port_regs);\n\ttrace_cdnsp_link_state_changed(port_num, readl(port_regs));\n}\n\nstatic void cdnsp_disable_port(struct cdnsp_device *pdev,\n\t\t\t       __le32 __iomem *port_regs)\n{\n\tu32 temp = cdnsp_port_state_to_neutral(readl(port_regs));\n\n\twritel(temp | PORT_PED, port_regs);\n}\n\nstatic void cdnsp_clear_port_change_bit(struct cdnsp_device *pdev,\n\t\t\t\t\t__le32 __iomem *port_regs)\n{\n\tu32 portsc = readl(port_regs);\n\n\twritel(cdnsp_port_state_to_neutral(portsc) |\n\t       (portsc & PORT_CHANGE_BITS), port_regs);\n}\n\nstatic void cdnsp_set_chicken_bits_2(struct cdnsp_device *pdev, u32 bit)\n{\n\t__le32 __iomem *reg;\n\tvoid __iomem *base;\n\tu32 offset = 0;\n\n\tbase = &pdev->cap_regs->hc_capbase;\n\toffset = cdnsp_find_next_ext_cap(base, offset, D_XEC_PRE_REGS_CAP);\n\treg = base + offset + REG_CHICKEN_BITS_2_OFFSET;\n\n\tbit = readl(reg) | bit;\n\twritel(bit, reg);\n}\n\nstatic void cdnsp_clear_chicken_bits_2(struct cdnsp_device *pdev, u32 bit)\n{\n\t__le32 __iomem *reg;\n\tvoid __iomem *base;\n\tu32 offset = 0;\n\n\tbase = &pdev->cap_regs->hc_capbase;\n\toffset = cdnsp_find_next_ext_cap(base, offset, D_XEC_PRE_REGS_CAP);\n\treg = base + offset + REG_CHICKEN_BITS_2_OFFSET;\n\n\tbit = readl(reg) & ~bit;\n\twritel(bit, reg);\n}\n\n \nstatic void cdnsp_quiesce(struct cdnsp_device *pdev)\n{\n\tu32 halted;\n\tu32 mask;\n\tu32 cmd;\n\n\tmask = ~(u32)(CDNSP_IRQS);\n\n\thalted = readl(&pdev->op_regs->status) & STS_HALT;\n\tif (!halted)\n\t\tmask &= ~(CMD_R_S | CMD_DEVEN);\n\n\tcmd = readl(&pdev->op_regs->command);\n\tcmd &= mask;\n\twritel(cmd, &pdev->op_regs->command);\n}\n\n \nint cdnsp_halt(struct cdnsp_device *pdev)\n{\n\tint ret;\n\tu32 val;\n\n\tcdnsp_quiesce(pdev);\n\n\tret = readl_poll_timeout_atomic(&pdev->op_regs->status, val,\n\t\t\t\t\tval & STS_HALT, 1,\n\t\t\t\t\tCDNSP_MAX_HALT_USEC);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"ERROR: Device halt failed\\n\");\n\t\treturn ret;\n\t}\n\n\tpdev->cdnsp_state |= CDNSP_STATE_HALTED;\n\n\treturn 0;\n}\n\n \nvoid cdnsp_died(struct cdnsp_device *pdev)\n{\n\tdev_err(pdev->dev, \"ERROR: CDNSP controller not responding\\n\");\n\tpdev->cdnsp_state |= CDNSP_STATE_DYING;\n\tcdnsp_halt(pdev);\n}\n\n \nstatic int cdnsp_start(struct cdnsp_device *pdev)\n{\n\tu32 temp;\n\tint ret;\n\n\ttemp = readl(&pdev->op_regs->command);\n\ttemp |= (CMD_R_S | CMD_DEVEN);\n\twritel(temp, &pdev->op_regs->command);\n\n\tpdev->cdnsp_state = 0;\n\n\t \n\tret = readl_poll_timeout_atomic(&pdev->op_regs->status, temp,\n\t\t\t\t\t!(temp & STS_HALT), 1,\n\t\t\t\t\tCDNSP_MAX_HALT_USEC);\n\tif (ret) {\n\t\tpdev->cdnsp_state = CDNSP_STATE_DYING;\n\t\tdev_err(pdev->dev, \"ERROR: Controller run failed\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nint cdnsp_reset(struct cdnsp_device *pdev)\n{\n\tu32 command;\n\tu32 temp;\n\tint ret;\n\n\ttemp = readl(&pdev->op_regs->status);\n\n\tif (temp == ~(u32)0) {\n\t\tdev_err(pdev->dev, \"Device not accessible, reset failed.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif ((temp & STS_HALT) == 0) {\n\t\tdev_err(pdev->dev, \"Controller not halted, aborting reset.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcommand = readl(&pdev->op_regs->command);\n\tcommand |= CMD_RESET;\n\twritel(command, &pdev->op_regs->command);\n\n\tret = readl_poll_timeout_atomic(&pdev->op_regs->command, temp,\n\t\t\t\t\t!(temp & CMD_RESET), 1,\n\t\t\t\t\t10 * 1000);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"ERROR: Controller reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = readl_poll_timeout_atomic(&pdev->op_regs->status, temp,\n\t\t\t\t\t!(temp & STS_CNR), 1,\n\t\t\t\t\t10 * 1000);\n\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"ERROR: Controller not ready to work\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(pdev->dev, \"Controller ready to work\");\n\n\treturn ret;\n}\n\n \nstatic unsigned int\n\tcdnsp_get_endpoint_index(const struct usb_endpoint_descriptor *desc)\n{\n\tunsigned int index = (unsigned int)usb_endpoint_num(desc);\n\n\tif (usb_endpoint_xfer_control(desc))\n\t\treturn index * 2;\n\n\treturn (index * 2) + (usb_endpoint_dir_in(desc) ? 1 : 0) - 1;\n}\n\n \nstatic unsigned int\n\tcdnsp_get_endpoint_flag(const struct usb_endpoint_descriptor *desc)\n{\n\treturn 1 << (cdnsp_get_endpoint_index(desc) + 1);\n}\n\nint cdnsp_ep_enqueue(struct cdnsp_ep *pep, struct cdnsp_request *preq)\n{\n\tstruct cdnsp_device *pdev = pep->pdev;\n\tstruct usb_request *request;\n\tint ret;\n\n\tif (preq->epnum == 0 && !list_empty(&pep->pending_list)) {\n\t\ttrace_cdnsp_request_enqueue_busy(preq);\n\t\treturn -EBUSY;\n\t}\n\n\trequest = &preq->request;\n\trequest->actual = 0;\n\trequest->status = -EINPROGRESS;\n\tpreq->direction = pep->direction;\n\tpreq->epnum = pep->number;\n\tpreq->td.drbl = 0;\n\n\tret = usb_gadget_map_request_by_dev(pdev->dev, request, pep->direction);\n\tif (ret) {\n\t\ttrace_cdnsp_request_enqueue_error(preq);\n\t\treturn ret;\n\t}\n\n\tlist_add_tail(&preq->list, &pep->pending_list);\n\n\ttrace_cdnsp_request_enqueue(preq);\n\n\tswitch (usb_endpoint_type(pep->endpoint.desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tret = cdnsp_queue_ctrl_tx(pdev, preq);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tret = cdnsp_queue_bulk_tx(pdev, preq);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tret = cdnsp_queue_isoc_tx(pdev, preq);\n\t}\n\n\tif (ret)\n\t\tgoto unmap;\n\n\treturn 0;\n\nunmap:\n\tusb_gadget_unmap_request_by_dev(pdev->dev, &preq->request,\n\t\t\t\t\tpep->direction);\n\tlist_del(&preq->list);\n\ttrace_cdnsp_request_enqueue_error(preq);\n\n\treturn ret;\n}\n\n \nint cdnsp_ep_dequeue(struct cdnsp_ep *pep, struct cdnsp_request *preq)\n{\n\tstruct cdnsp_device *pdev = pep->pdev;\n\tint ret_stop = 0;\n\tint ret_rem;\n\n\ttrace_cdnsp_request_dequeue(preq);\n\n\tif (GET_EP_CTX_STATE(pep->out_ctx) == EP_STATE_RUNNING)\n\t\tret_stop = cdnsp_cmd_stop_ep(pdev, pep);\n\n\tret_rem = cdnsp_remove_request(pdev, preq, pep);\n\n\treturn ret_rem ? ret_rem : ret_stop;\n}\n\nstatic void cdnsp_zero_in_ctx(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_input_control_ctx *ctrl_ctx;\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tstruct cdnsp_ep_ctx *ep_ctx;\n\tint i;\n\n\tctrl_ctx = cdnsp_get_input_control_ctx(&pdev->in_ctx);\n\n\t \n\tctrl_ctx->drop_flags = 0;\n\tctrl_ctx->add_flags = 0;\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->in_ctx);\n\tslot_ctx->dev_info &= cpu_to_le32(~LAST_CTX_MASK);\n\n\t \n\tslot_ctx->dev_info |= cpu_to_le32(LAST_CTX(1));\n\tfor (i = 1; i < CDNSP_ENDPOINTS_NUM; ++i) {\n\t\tep_ctx = cdnsp_get_ep_ctx(&pdev->in_ctx, i);\n\t\tep_ctx->ep_info = 0;\n\t\tep_ctx->ep_info2 = 0;\n\t\tep_ctx->deq = 0;\n\t\tep_ctx->tx_info = 0;\n\t}\n}\n\n \nstatic int cdnsp_configure_endpoint(struct cdnsp_device *pdev)\n{\n\tint ret;\n\n\tcdnsp_queue_configure_endpoint(pdev, pdev->cmd.in_ctx->dma);\n\tcdnsp_ring_cmd_db(pdev);\n\tret = cdnsp_wait_for_cmd_compl(pdev);\n\tif (ret) {\n\t\tdev_err(pdev->dev,\n\t\t\t\"ERR: unexpected command completion code 0x%x.\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic void cdnsp_invalidate_ep_events(struct cdnsp_device *pdev,\n\t\t\t\t       struct cdnsp_ep *pep)\n{\n\tstruct cdnsp_segment *segment;\n\tunion cdnsp_trb *event;\n\tu32 cycle_state;\n\tu32  data;\n\n\tevent = pdev->event_ring->dequeue;\n\tsegment = pdev->event_ring->deq_seg;\n\tcycle_state = pdev->event_ring->cycle_state;\n\n\twhile (1) {\n\t\tdata = le32_to_cpu(event->trans_event.flags);\n\n\t\t \n\t\tif ((data & TRB_CYCLE) != cycle_state)\n\t\t\tbreak;\n\n\t\tif (TRB_FIELD_TO_TYPE(data) == TRB_TRANSFER &&\n\t\t    TRB_TO_EP_ID(data) == (pep->idx + 1)) {\n\t\t\tdata |= TRB_EVENT_INVALIDATE;\n\t\t\tevent->trans_event.flags = cpu_to_le32(data);\n\t\t}\n\n\t\tif (cdnsp_last_trb_on_seg(segment, event)) {\n\t\t\tcycle_state ^= 1;\n\t\t\tsegment = pdev->event_ring->deq_seg->next;\n\t\t\tevent = segment->trbs;\n\t\t} else {\n\t\t\tevent++;\n\t\t}\n\t}\n}\n\nint cdnsp_wait_for_cmd_compl(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_segment *event_deq_seg;\n\tunion cdnsp_trb *cmd_trb;\n\tdma_addr_t cmd_deq_dma;\n\tunion cdnsp_trb *event;\n\tu32 cycle_state;\n\tint ret, val;\n\tu64 cmd_dma;\n\tu32  flags;\n\n\tcmd_trb = pdev->cmd.command_trb;\n\tpdev->cmd.status = 0;\n\n\ttrace_cdnsp_cmd_wait_for_compl(pdev->cmd_ring, &cmd_trb->generic);\n\n\tret = readl_poll_timeout_atomic(&pdev->op_regs->cmd_ring, val,\n\t\t\t\t\t!CMD_RING_BUSY(val), 1,\n\t\t\t\t\tCDNSP_CMD_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"ERR: Timeout while waiting for command\\n\");\n\t\ttrace_cdnsp_cmd_timeout(pdev->cmd_ring, &cmd_trb->generic);\n\t\tpdev->cdnsp_state = CDNSP_STATE_DYING;\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tevent = pdev->event_ring->dequeue;\n\tevent_deq_seg = pdev->event_ring->deq_seg;\n\tcycle_state = pdev->event_ring->cycle_state;\n\n\tcmd_deq_dma = cdnsp_trb_virt_to_dma(pdev->cmd_ring->deq_seg, cmd_trb);\n\tif (!cmd_deq_dma)\n\t\treturn -EINVAL;\n\n\twhile (1) {\n\t\tflags = le32_to_cpu(event->event_cmd.flags);\n\n\t\t \n\t\tif ((flags & TRB_CYCLE) != cycle_state)\n\t\t\treturn -EINVAL;\n\n\t\tcmd_dma = le64_to_cpu(event->event_cmd.cmd_trb);\n\n\t\t \n\t\tif (TRB_FIELD_TO_TYPE(flags) != TRB_COMPLETION ||\n\t\t    cmd_dma != (u64)cmd_deq_dma) {\n\t\t\tif (!cdnsp_last_trb_on_seg(event_deq_seg, event)) {\n\t\t\t\tevent++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (cdnsp_last_trb_on_ring(pdev->event_ring,\n\t\t\t\t\t\t   event_deq_seg, event))\n\t\t\t\tcycle_state ^= 1;\n\n\t\t\tevent_deq_seg = event_deq_seg->next;\n\t\t\tevent = event_deq_seg->trbs;\n\t\t\tcontinue;\n\t\t}\n\n\t\ttrace_cdnsp_handle_command(pdev->cmd_ring, &cmd_trb->generic);\n\n\t\tpdev->cmd.status = GET_COMP_CODE(le32_to_cpu(event->event_cmd.status));\n\t\tif (pdev->cmd.status == COMP_SUCCESS)\n\t\t\treturn 0;\n\n\t\treturn -pdev->cmd.status;\n\t}\n}\n\nint cdnsp_halt_endpoint(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_ep *pep,\n\t\t\tint value)\n{\n\tint ret;\n\n\ttrace_cdnsp_ep_halt(value ? \"Set\" : \"Clear\");\n\n\tret = cdnsp_cmd_stop_ep(pdev, pep);\n\tif (ret)\n\t\treturn ret;\n\n\tif (value) {\n\t\tif (GET_EP_CTX_STATE(pep->out_ctx) == EP_STATE_STOPPED) {\n\t\t\tcdnsp_queue_halt_endpoint(pdev, pep->idx);\n\t\t\tcdnsp_ring_cmd_db(pdev);\n\t\t\tret = cdnsp_wait_for_cmd_compl(pdev);\n\t\t}\n\n\t\tpep->ep_state |= EP_HALTED;\n\t} else {\n\t\tcdnsp_queue_reset_ep(pdev, pep->idx);\n\t\tcdnsp_ring_cmd_db(pdev);\n\t\tret = cdnsp_wait_for_cmd_compl(pdev);\n\t\ttrace_cdnsp_handle_cmd_reset_ep(pep->out_ctx);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpep->ep_state &= ~EP_HALTED;\n\n\t\tif (pep->idx != 0 && !(pep->ep_state & EP_WEDGE))\n\t\t\tcdnsp_ring_doorbell_for_active_rings(pdev, pep);\n\n\t\tpep->ep_state &= ~EP_WEDGE;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdnsp_update_eps_configuration(struct cdnsp_device *pdev,\n\t\t\t\t\t  struct cdnsp_ep *pep)\n{\n\tstruct cdnsp_input_control_ctx *ctrl_ctx;\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tint ret = 0;\n\tu32 ep_sts;\n\tint i;\n\n\tctrl_ctx = cdnsp_get_input_control_ctx(&pdev->in_ctx);\n\n\t \n\tif (ctrl_ctx->add_flags == 0 && ctrl_ctx->drop_flags == 0)\n\t\treturn 0;\n\n\tctrl_ctx->add_flags |= cpu_to_le32(SLOT_FLAG);\n\tctrl_ctx->add_flags &= cpu_to_le32(~EP0_FLAG);\n\tctrl_ctx->drop_flags &= cpu_to_le32(~(SLOT_FLAG | EP0_FLAG));\n\n\t \n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->in_ctx);\n\tfor (i = CDNSP_ENDPOINTS_NUM; i >= 1; i--) {\n\t\t__le32 le32 = cpu_to_le32(BIT(i));\n\n\t\tif ((pdev->eps[i - 1].ring && !(ctrl_ctx->drop_flags & le32)) ||\n\t\t    (ctrl_ctx->add_flags & le32) || i == 1) {\n\t\t\tslot_ctx->dev_info &= cpu_to_le32(~LAST_CTX_MASK);\n\t\t\tslot_ctx->dev_info |= cpu_to_le32(LAST_CTX(i));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tep_sts = GET_EP_CTX_STATE(pep->out_ctx);\n\n\tif ((ctrl_ctx->add_flags != cpu_to_le32(SLOT_FLAG) &&\n\t     ep_sts == EP_STATE_DISABLED) ||\n\t    (ep_sts != EP_STATE_DISABLED && ctrl_ctx->drop_flags))\n\t\tret = cdnsp_configure_endpoint(pdev);\n\n\ttrace_cdnsp_configure_endpoint(cdnsp_get_slot_ctx(&pdev->out_ctx));\n\ttrace_cdnsp_handle_cmd_config_ep(pep->out_ctx);\n\n\tcdnsp_zero_in_ctx(pdev);\n\n\treturn ret;\n}\n\n \nint cdnsp_reset_device(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tint slot_state;\n\tint ret, i;\n\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->in_ctx);\n\tslot_ctx->dev_info = 0;\n\tpdev->device_address = 0;\n\n\t \n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->out_ctx);\n\tslot_state = GET_SLOT_STATE(le32_to_cpu(slot_ctx->dev_state));\n\ttrace_cdnsp_reset_device(slot_ctx);\n\n\tif (slot_state <= SLOT_STATE_DEFAULT &&\n\t    pdev->eps[0].ep_state & EP_HALTED) {\n\t\tcdnsp_halt_endpoint(pdev, &pdev->eps[0], 0);\n\t}\n\n\t \n\tpdev->eps[0].ep_state &= ~(EP_STOPPED | EP_HALTED);\n\tpdev->eps[0].ep_state |= EP_ENABLED;\n\n\tif (slot_state <= SLOT_STATE_DEFAULT)\n\t\treturn 0;\n\n\tcdnsp_queue_reset_device(pdev);\n\tcdnsp_ring_cmd_db(pdev);\n\tret = cdnsp_wait_for_cmd_compl(pdev);\n\n\t \n\tfor (i = 1; i < CDNSP_ENDPOINTS_NUM; ++i)\n\t\tpdev->eps[i].ep_state |= EP_STOPPED | EP_UNCONFIGURED;\n\n\ttrace_cdnsp_handle_cmd_reset_dev(slot_ctx);\n\n\tif (ret)\n\t\tdev_err(pdev->dev, \"Reset device failed with error code %d\",\n\t\t\tret);\n\n\treturn ret;\n}\n\n \nstatic void cdnsp_setup_streams_ep_input_ctx(struct cdnsp_device *pdev,\n\t\t\t\t\t     struct cdnsp_ep_ctx *ep_ctx,\n\t\t\t\t\t     struct cdnsp_stream_info *stream_info)\n{\n\tu32 max_primary_streams;\n\n\t \n\tmax_primary_streams = fls(stream_info->num_stream_ctxs) - 2;\n\tep_ctx->ep_info &= cpu_to_le32(~EP_MAXPSTREAMS_MASK);\n\tep_ctx->ep_info |= cpu_to_le32(EP_MAXPSTREAMS(max_primary_streams)\n\t\t\t\t       | EP_HAS_LSA);\n\tep_ctx->deq  = cpu_to_le64(stream_info->ctx_array_dma);\n}\n\n \nint cdnsp_alloc_streams(struct cdnsp_device *pdev, struct cdnsp_ep *pep)\n{\n\tunsigned int num_streams = usb_ss_max_streams(pep->endpoint.comp_desc);\n\tunsigned int num_stream_ctxs;\n\tint ret;\n\n\tif (num_streams ==  0)\n\t\treturn 0;\n\n\tif (num_streams > STREAM_NUM_STREAMS)\n\t\treturn -EINVAL;\n\n\t \n\tnum_streams += 2;\n\n\t \n\tnum_stream_ctxs = roundup_pow_of_two(num_streams);\n\n\ttrace_cdnsp_stream_number(pep, num_stream_ctxs, num_streams);\n\n\tret = cdnsp_alloc_stream_info(pdev, pep, num_stream_ctxs, num_streams);\n\tif (ret)\n\t\treturn ret;\n\n\tcdnsp_setup_streams_ep_input_ctx(pdev, pep->in_ctx, &pep->stream_info);\n\n\tpep->ep_state |= EP_HAS_STREAMS;\n\tpep->stream_info.td_count = 0;\n\tpep->stream_info.first_prime_det = 0;\n\n\t \n\treturn num_streams - 1;\n}\n\nint cdnsp_disable_slot(struct cdnsp_device *pdev)\n{\n\tint ret;\n\n\tcdnsp_queue_slot_control(pdev, TRB_DISABLE_SLOT);\n\tcdnsp_ring_cmd_db(pdev);\n\tret = cdnsp_wait_for_cmd_compl(pdev);\n\n\tpdev->slot_id = 0;\n\tpdev->active_port = NULL;\n\n\ttrace_cdnsp_handle_cmd_disable_slot(cdnsp_get_slot_ctx(&pdev->out_ctx));\n\n\tmemset(pdev->in_ctx.bytes, 0, CDNSP_CTX_SIZE);\n\tmemset(pdev->out_ctx.bytes, 0, CDNSP_CTX_SIZE);\n\n\treturn ret;\n}\n\nint cdnsp_enable_slot(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tint slot_state;\n\tint ret;\n\n\t \n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->out_ctx);\n\tslot_state = GET_SLOT_STATE(le32_to_cpu(slot_ctx->dev_state));\n\n\tif (slot_state != SLOT_STATE_DISABLED)\n\t\treturn 0;\n\n\tcdnsp_queue_slot_control(pdev, TRB_ENABLE_SLOT);\n\tcdnsp_ring_cmd_db(pdev);\n\tret = cdnsp_wait_for_cmd_compl(pdev);\n\tif (ret)\n\t\tgoto show_trace;\n\n\tpdev->slot_id = 1;\n\nshow_trace:\n\ttrace_cdnsp_handle_cmd_enable_slot(cdnsp_get_slot_ctx(&pdev->out_ctx));\n\n\treturn ret;\n}\n\n \nint cdnsp_setup_device(struct cdnsp_device *pdev, enum cdnsp_setup_dev setup)\n{\n\tstruct cdnsp_input_control_ctx *ctrl_ctx;\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tint dev_state = 0;\n\tint ret;\n\n\tif (!pdev->slot_id) {\n\t\ttrace_cdnsp_slot_id(\"incorrect\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!pdev->active_port->port_num)\n\t\treturn -EINVAL;\n\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->out_ctx);\n\tdev_state = GET_SLOT_STATE(le32_to_cpu(slot_ctx->dev_state));\n\n\tif (setup == SETUP_CONTEXT_ONLY && dev_state == SLOT_STATE_DEFAULT) {\n\t\ttrace_cdnsp_slot_already_in_default(slot_ctx);\n\t\treturn 0;\n\t}\n\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->in_ctx);\n\tctrl_ctx = cdnsp_get_input_control_ctx(&pdev->in_ctx);\n\n\tif (!slot_ctx->dev_info || dev_state == SLOT_STATE_DEFAULT) {\n\t\tret = cdnsp_setup_addressable_priv_dev(pdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcdnsp_copy_ep0_dequeue_into_input_ctx(pdev);\n\n\tctrl_ctx->add_flags = cpu_to_le32(SLOT_FLAG | EP0_FLAG);\n\tctrl_ctx->drop_flags = 0;\n\n\ttrace_cdnsp_setup_device_slot(slot_ctx);\n\n\tcdnsp_queue_address_device(pdev, pdev->in_ctx.dma, setup);\n\tcdnsp_ring_cmd_db(pdev);\n\tret = cdnsp_wait_for_cmd_compl(pdev);\n\n\ttrace_cdnsp_handle_cmd_addr_dev(cdnsp_get_slot_ctx(&pdev->out_ctx));\n\n\t \n\tctrl_ctx->add_flags = 0;\n\tctrl_ctx->drop_flags = 0;\n\n\treturn ret;\n}\n\nvoid cdnsp_set_usb2_hardware_lpm(struct cdnsp_device *pdev,\n\t\t\t\t struct usb_request *req,\n\t\t\t\t int enable)\n{\n\tif (pdev->active_port != &pdev->usb2_port || !pdev->gadget.lpm_capable)\n\t\treturn;\n\n\ttrace_cdnsp_lpm(enable);\n\n\tif (enable)\n\t\twritel(PORT_BESL(CDNSP_DEFAULT_BESL) | PORT_L1S_NYET | PORT_HLE,\n\t\t       &pdev->active_port->regs->portpmsc);\n\telse\n\t\twritel(PORT_L1S_NYET, &pdev->active_port->regs->portpmsc);\n}\n\nstatic int cdnsp_get_frame(struct cdnsp_device *pdev)\n{\n\treturn readl(&pdev->run_regs->microframe_index) >> 3;\n}\n\nstatic int cdnsp_gadget_ep_enable(struct usb_ep *ep,\n\t\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct cdnsp_input_control_ctx *ctrl_ctx;\n\tstruct cdnsp_device *pdev;\n\tstruct cdnsp_ep *pep;\n\tunsigned long flags;\n\tu32 added_ctxs;\n\tint ret;\n\n\tif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT ||\n\t    !desc->wMaxPacketSize)\n\t\treturn -EINVAL;\n\n\tpep = to_cdnsp_ep(ep);\n\tpdev = pep->pdev;\n\tpep->ep_state &= ~EP_UNCONFIGURED;\n\n\tif (dev_WARN_ONCE(pdev->dev, pep->ep_state & EP_ENABLED,\n\t\t\t  \"%s is already enabled\\n\", pep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tadded_ctxs = cdnsp_get_endpoint_flag(desc);\n\tif (added_ctxs == SLOT_FLAG || added_ctxs == EP0_FLAG) {\n\t\tdev_err(pdev->dev, \"ERROR: Bad endpoint number\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tpep->interval = desc->bInterval ? BIT(desc->bInterval - 1) : 0;\n\n\tif (pdev->gadget.speed == USB_SPEED_FULL) {\n\t\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_INT)\n\t\t\tpep->interval = desc->bInterval << 3;\n\t\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_ISOC)\n\t\t\tpep->interval = BIT(desc->bInterval - 1) << 3;\n\t}\n\n\tif (usb_endpoint_type(desc) == USB_ENDPOINT_XFER_ISOC) {\n\t\tif (pep->interval > BIT(12)) {\n\t\t\tdev_err(pdev->dev, \"bInterval %d not supported\\n\",\n\t\t\t\tdesc->bInterval);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\t\tcdnsp_set_chicken_bits_2(pdev, CHICKEN_XDMA_2_TP_CACHE_DIS);\n\t}\n\n\tret = cdnsp_endpoint_init(pdev, pep, GFP_ATOMIC);\n\tif (ret)\n\t\tgoto unlock;\n\n\tctrl_ctx = cdnsp_get_input_control_ctx(&pdev->in_ctx);\n\tctrl_ctx->add_flags = cpu_to_le32(added_ctxs);\n\tctrl_ctx->drop_flags = 0;\n\n\tret = cdnsp_update_eps_configuration(pdev, pep);\n\tif (ret) {\n\t\tcdnsp_free_endpoint_rings(pdev, pep);\n\t\tgoto unlock;\n\t}\n\n\tpep->ep_state |= EP_ENABLED;\n\tpep->ep_state &= ~EP_STOPPED;\n\nunlock:\n\ttrace_cdnsp_ep_enable_end(pep, 0);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int cdnsp_gadget_ep_disable(struct usb_ep *ep)\n{\n\tstruct cdnsp_input_control_ctx *ctrl_ctx;\n\tstruct cdnsp_request *preq;\n\tstruct cdnsp_device *pdev;\n\tstruct cdnsp_ep *pep;\n\tunsigned long flags;\n\tu32 drop_flag;\n\tint ret = 0;\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tpep = to_cdnsp_ep(ep);\n\tpdev = pep->pdev;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tif (!(pep->ep_state & EP_ENABLED)) {\n\t\tdev_err(pdev->dev, \"%s is already disabled\\n\", pep->name);\n\t\tret = -EINVAL;\n\t\tgoto finish;\n\t}\n\n\tpep->ep_state |= EP_DIS_IN_RROGRESS;\n\n\t \n\tif (!(pep->ep_state & EP_UNCONFIGURED)) {\n\t\tcdnsp_cmd_stop_ep(pdev, pep);\n\t\tcdnsp_cmd_flush_ep(pdev, pep);\n\t}\n\n\t \n\twhile (!list_empty(&pep->pending_list)) {\n\t\tpreq = next_request(&pep->pending_list);\n\t\tcdnsp_ep_dequeue(pep, preq);\n\t}\n\n\tcdnsp_invalidate_ep_events(pdev, pep);\n\n\tpep->ep_state &= ~EP_DIS_IN_RROGRESS;\n\tdrop_flag = cdnsp_get_endpoint_flag(pep->endpoint.desc);\n\tctrl_ctx = cdnsp_get_input_control_ctx(&pdev->in_ctx);\n\tctrl_ctx->drop_flags = cpu_to_le32(drop_flag);\n\tctrl_ctx->add_flags = 0;\n\n\tcdnsp_endpoint_zero(pdev, pep);\n\n\tif (!(pep->ep_state & EP_UNCONFIGURED))\n\t\tret = cdnsp_update_eps_configuration(pdev, pep);\n\n\tcdnsp_free_endpoint_rings(pdev, pep);\n\n\tpep->ep_state &= ~(EP_ENABLED | EP_UNCONFIGURED);\n\tpep->ep_state |= EP_STOPPED;\n\nfinish:\n\ttrace_cdnsp_ep_disable_end(pep, 0);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct usb_request *cdnsp_gadget_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct cdnsp_ep *pep = to_cdnsp_ep(ep);\n\tstruct cdnsp_request *preq;\n\n\tpreq = kzalloc(sizeof(*preq), gfp_flags);\n\tif (!preq)\n\t\treturn NULL;\n\n\tpreq->epnum = pep->number;\n\tpreq->pep = pep;\n\n\ttrace_cdnsp_alloc_request(preq);\n\n\treturn &preq->request;\n}\n\nstatic void cdnsp_gadget_ep_free_request(struct usb_ep *ep,\n\t\t\t\t\t struct usb_request *request)\n{\n\tstruct cdnsp_request *preq = to_cdnsp_request(request);\n\n\ttrace_cdnsp_free_request(preq);\n\tkfree(preq);\n}\n\nstatic int cdnsp_gadget_ep_queue(struct usb_ep *ep,\n\t\t\t\t struct usb_request *request,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct cdnsp_request *preq;\n\tstruct cdnsp_device *pdev;\n\tstruct cdnsp_ep *pep;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!request || !ep)\n\t\treturn -EINVAL;\n\n\tpep = to_cdnsp_ep(ep);\n\tpdev = pep->pdev;\n\n\tif (!(pep->ep_state & EP_ENABLED)) {\n\t\tdev_err(pdev->dev, \"%s: can't queue to disabled endpoint\\n\",\n\t\t\tpep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tpreq = to_cdnsp_request(request);\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tret = cdnsp_ep_enqueue(pep, preq);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int cdnsp_gadget_ep_dequeue(struct usb_ep *ep,\n\t\t\t\t   struct usb_request *request)\n{\n\tstruct cdnsp_ep *pep = to_cdnsp_ep(ep);\n\tstruct cdnsp_device *pdev = pep->pdev;\n\tunsigned long flags;\n\tint ret;\n\n\tif (request->status != -EINPROGRESS)\n\t\treturn 0;\n\n\tif (!pep->endpoint.desc) {\n\t\tdev_err(pdev->dev,\n\t\t\t\"%s: can't dequeue to disabled endpoint\\n\",\n\t\t\tpep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (!(pep->ep_state & EP_ENABLED))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tret = cdnsp_ep_dequeue(pep, to_cdnsp_request(request));\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic int cdnsp_gadget_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct cdnsp_ep *pep = to_cdnsp_ep(ep);\n\tstruct cdnsp_device *pdev = pep->pdev;\n\tstruct cdnsp_request *preq;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tpreq = next_request(&pep->pending_list);\n\tif (value) {\n\t\tif (preq) {\n\t\t\ttrace_cdnsp_ep_busy_try_halt_again(pep, 0);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = cdnsp_halt_endpoint(pdev, pep, value);\n\ndone:\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\treturn ret;\n}\n\nstatic int cdnsp_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct cdnsp_ep *pep = to_cdnsp_ep(ep);\n\tstruct cdnsp_device *pdev = pep->pdev;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tpep->ep_state |= EP_WEDGE;\n\tret = cdnsp_halt_endpoint(pdev, pep, 1);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct usb_ep_ops cdnsp_gadget_ep0_ops = {\n\t.enable\t\t= cdnsp_gadget_ep_enable,\n\t.disable\t= cdnsp_gadget_ep_disable,\n\t.alloc_request\t= cdnsp_gadget_ep_alloc_request,\n\t.free_request\t= cdnsp_gadget_ep_free_request,\n\t.queue\t\t= cdnsp_gadget_ep_queue,\n\t.dequeue\t= cdnsp_gadget_ep_dequeue,\n\t.set_halt\t= cdnsp_gadget_ep_set_halt,\n\t.set_wedge\t= cdnsp_gadget_ep_set_wedge,\n};\n\nstatic const struct usb_ep_ops cdnsp_gadget_ep_ops = {\n\t.enable\t\t= cdnsp_gadget_ep_enable,\n\t.disable\t= cdnsp_gadget_ep_disable,\n\t.alloc_request\t= cdnsp_gadget_ep_alloc_request,\n\t.free_request\t= cdnsp_gadget_ep_free_request,\n\t.queue\t\t= cdnsp_gadget_ep_queue,\n\t.dequeue\t= cdnsp_gadget_ep_dequeue,\n\t.set_halt\t= cdnsp_gadget_ep_set_halt,\n\t.set_wedge\t= cdnsp_gadget_ep_set_wedge,\n};\n\nvoid cdnsp_gadget_giveback(struct cdnsp_ep *pep,\n\t\t\t   struct cdnsp_request *preq,\n\t\t\t   int status)\n{\n\tstruct cdnsp_device *pdev = pep->pdev;\n\n\tlist_del(&preq->list);\n\n\tif (preq->request.status == -EINPROGRESS)\n\t\tpreq->request.status = status;\n\n\tusb_gadget_unmap_request_by_dev(pdev->dev, &preq->request,\n\t\t\t\t\tpreq->direction);\n\n\ttrace_cdnsp_request_giveback(preq);\n\n\tif (preq != &pdev->ep0_preq) {\n\t\tspin_unlock(&pdev->lock);\n\t\tusb_gadget_giveback_request(&pep->endpoint, &preq->request);\n\t\tspin_lock(&pdev->lock);\n\t}\n}\n\nstatic struct usb_endpoint_descriptor cdnsp_gadget_ep0_desc = {\n\t.bLength =\t\tUSB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType =\tUSB_DT_ENDPOINT,\n\t.bmAttributes =\t\tUSB_ENDPOINT_XFER_CONTROL,\n};\n\nstatic int cdnsp_run(struct cdnsp_device *pdev,\n\t\t     enum usb_device_speed speed)\n{\n\tu32 fs_speed = 0;\n\tu32 temp;\n\tint ret;\n\n\ttemp = readl(&pdev->ir_set->irq_control);\n\ttemp &= ~IMOD_INTERVAL_MASK;\n\ttemp |= ((IMOD_DEFAULT_INTERVAL / 250) & IMOD_INTERVAL_MASK);\n\twritel(temp, &pdev->ir_set->irq_control);\n\n\ttemp = readl(&pdev->port3x_regs->mode_addr);\n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\ttemp |= CFG_3XPORT_SSP_SUPPORT;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\ttemp &= ~CFG_3XPORT_SSP_SUPPORT;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tfs_speed = PORT_REG6_FORCE_FS;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdev->dev, \"invalid maximum_speed parameter %d\\n\",\n\t\t\tspeed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tspeed = USB_SPEED_SUPER;\n\t\tbreak;\n\t}\n\n\tif (speed >= USB_SPEED_SUPER) {\n\t\twritel(temp, &pdev->port3x_regs->mode_addr);\n\t\tcdnsp_set_link_state(pdev, &pdev->usb3_port.regs->portsc,\n\t\t\t\t     XDEV_RXDETECT);\n\t} else {\n\t\tcdnsp_disable_port(pdev, &pdev->usb3_port.regs->portsc);\n\t}\n\n\tcdnsp_set_link_state(pdev, &pdev->usb2_port.regs->portsc,\n\t\t\t     XDEV_RXDETECT);\n\n\tcdnsp_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\n\n\twritel(PORT_REG6_L1_L0_HW_EN | fs_speed, &pdev->port20_regs->port_reg6);\n\n\tret = cdnsp_start(pdev);\n\tif (ret) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\ttemp = readl(&pdev->op_regs->command);\n\ttemp |= (CMD_INTE);\n\twritel(temp, &pdev->op_regs->command);\n\n\ttemp = readl(&pdev->ir_set->irq_pending);\n\twritel(IMAN_IE_SET(temp), &pdev->ir_set->irq_pending);\n\n\ttrace_cdnsp_init(\"Controller ready to work\");\n\treturn 0;\nerr:\n\tcdnsp_halt(pdev);\n\treturn ret;\n}\n\nstatic int cdnsp_gadget_udc_start(struct usb_gadget *g,\n\t\t\t\t  struct usb_gadget_driver *driver)\n{\n\tenum usb_device_speed max_speed = driver->max_speed;\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(g);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tpdev->gadget_driver = driver;\n\n\t \n\tmax_speed = min(driver->max_speed, g->max_speed);\n\tret = cdnsp_run(pdev, max_speed);\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\n \nvoid cdnsp_update_erst_dequeue(struct cdnsp_device *pdev,\n\t\t\t       union cdnsp_trb *event_ring_deq,\n\t\t\t       u8 clear_ehb)\n{\n\tu64 temp_64;\n\tdma_addr_t deq;\n\n\ttemp_64 = cdnsp_read_64(&pdev->ir_set->erst_dequeue);\n\n\t \n\tif (event_ring_deq != pdev->event_ring->dequeue) {\n\t\tdeq = cdnsp_trb_virt_to_dma(pdev->event_ring->deq_seg,\n\t\t\t\t\t    pdev->event_ring->dequeue);\n\t\ttemp_64 &= ERST_PTR_MASK;\n\t\ttemp_64 |= ((u64)deq & (u64)~ERST_PTR_MASK);\n\t}\n\n\t \n\tif (clear_ehb)\n\t\ttemp_64 |= ERST_EHB;\n\telse\n\t\ttemp_64 &= ~ERST_EHB;\n\n\tcdnsp_write_64(temp_64, &pdev->ir_set->erst_dequeue);\n}\n\nstatic void cdnsp_clear_cmd_ring(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_segment *seg;\n\tu64 val_64;\n\tint i;\n\n\tcdnsp_initialize_ring_info(pdev->cmd_ring);\n\n\tseg = pdev->cmd_ring->first_seg;\n\tfor (i = 0; i < pdev->cmd_ring->num_segs; i++) {\n\t\tmemset(seg->trbs, 0,\n\t\t       sizeof(union cdnsp_trb) * (TRBS_PER_SEGMENT - 1));\n\t\tseg = seg->next;\n\t}\n\n\t \n\tval_64 = cdnsp_read_64(&pdev->op_regs->cmd_ring);\n\tval_64 = (val_64 & (u64)CMD_RING_RSVD_BITS) |\n\t\t (pdev->cmd_ring->first_seg->dma & (u64)~CMD_RING_RSVD_BITS) |\n\t\t pdev->cmd_ring->cycle_state;\n\tcdnsp_write_64(val_64, &pdev->op_regs->cmd_ring);\n}\n\nstatic void cdnsp_consume_all_events(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_segment *event_deq_seg;\n\tunion cdnsp_trb *event_ring_deq;\n\tunion cdnsp_trb *event;\n\tu32 cycle_bit;\n\n\tevent_ring_deq = pdev->event_ring->dequeue;\n\tevent_deq_seg = pdev->event_ring->deq_seg;\n\tevent = pdev->event_ring->dequeue;\n\n\t \n\twhile (1) {\n\t\tcycle_bit = (le32_to_cpu(event->event_cmd.flags) & TRB_CYCLE);\n\n\t\t \n\t\tif (cycle_bit != pdev->event_ring->cycle_state)\n\t\t\tbreak;\n\n\t\tcdnsp_inc_deq(pdev, pdev->event_ring);\n\n\t\tif (!cdnsp_last_trb_on_seg(event_deq_seg, event)) {\n\t\t\tevent++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (cdnsp_last_trb_on_ring(pdev->event_ring, event_deq_seg,\n\t\t\t\t\t   event))\n\t\t\tcycle_bit ^= 1;\n\n\t\tevent_deq_seg = event_deq_seg->next;\n\t\tevent = event_deq_seg->trbs;\n\t}\n\n\tcdnsp_update_erst_dequeue(pdev,  event_ring_deq, 1);\n}\n\nstatic void cdnsp_stop(struct cdnsp_device *pdev)\n{\n\tu32 temp;\n\n\tcdnsp_cmd_flush_ep(pdev, &pdev->eps[0]);\n\n\t \n\tif (!list_empty(&pdev->eps[0].pending_list)) {\n\t\tstruct cdnsp_request *req;\n\n\t\treq = next_request(&pdev->eps[0].pending_list);\n\t\tif (req == &pdev->ep0_preq)\n\t\t\tcdnsp_ep_dequeue(&pdev->eps[0], req);\n\t}\n\n\tcdnsp_disable_port(pdev, &pdev->usb2_port.regs->portsc);\n\tcdnsp_disable_port(pdev, &pdev->usb3_port.regs->portsc);\n\tcdnsp_disable_slot(pdev);\n\tcdnsp_halt(pdev);\n\n\ttemp = readl(&pdev->op_regs->status);\n\twritel((temp & ~0x1fff) | STS_EINT, &pdev->op_regs->status);\n\ttemp = readl(&pdev->ir_set->irq_pending);\n\twritel(IMAN_IE_CLEAR(temp), &pdev->ir_set->irq_pending);\n\n\tcdnsp_clear_port_change_bit(pdev, &pdev->usb2_port.regs->portsc);\n\tcdnsp_clear_port_change_bit(pdev, &pdev->usb3_port.regs->portsc);\n\n\t \n\ttemp = readl(&pdev->ir_set->irq_pending);\n\ttemp |= IMAN_IP;\n\twritel(temp, &pdev->ir_set->irq_pending);\n\n\tcdnsp_consume_all_events(pdev);\n\tcdnsp_clear_cmd_ring(pdev);\n\n\ttrace_cdnsp_exit(\"Controller stopped.\");\n}\n\n \nstatic int cdnsp_gadget_udc_stop(struct usb_gadget *g)\n{\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(g);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tcdnsp_stop(pdev);\n\tpdev->gadget_driver = NULL;\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdnsp_gadget_get_frame(struct usb_gadget *g)\n{\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(g);\n\n\treturn cdnsp_get_frame(pdev);\n}\n\nstatic void __cdnsp_gadget_wakeup(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_port_regs __iomem *port_regs;\n\tu32 portpm, portsc;\n\n\tport_regs = pdev->active_port->regs;\n\tportsc = readl(&port_regs->portsc) & PORT_PLS_MASK;\n\n\t \n\tif (pdev->gadget.speed < USB_SPEED_SUPER && portsc == XDEV_U2) {\n\t\tportpm = readl(&port_regs->portpmsc);\n\n\t\tif (!(portpm & PORT_RWE))\n\t\t\treturn;\n\t}\n\n\tif (portsc == XDEV_U3 && !pdev->may_wakeup)\n\t\treturn;\n\n\tcdnsp_set_link_state(pdev, &port_regs->portsc, XDEV_U0);\n\n\tpdev->cdnsp_state |= CDNSP_WAKEUP_PENDING;\n}\n\nstatic int cdnsp_gadget_wakeup(struct usb_gadget *g)\n{\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(g);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\t__cdnsp_gadget_wakeup(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdnsp_gadget_set_selfpowered(struct usb_gadget *g,\n\t\t\t\t\tint is_selfpowered)\n{\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(g);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tg->is_selfpowered = !!is_selfpowered;\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdnsp_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct cdnsp_device *pdev = gadget_to_cdnsp(gadget);\n\tstruct cdns *cdns = dev_get_drvdata(pdev->dev);\n\tunsigned long flags;\n\n\ttrace_cdnsp_pullup(is_on);\n\n\t \n\tdisable_irq(cdns->dev_irq);\n\tspin_lock_irqsave(&pdev->lock, flags);\n\n\tif (!is_on) {\n\t\tcdnsp_reset_device(pdev);\n\t\tcdns_clear_vbus(cdns);\n\t} else {\n\t\tcdns_set_vbus(cdns);\n\t}\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\tenable_irq(cdns->dev_irq);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops cdnsp_gadget_ops = {\n\t.get_frame\t\t= cdnsp_gadget_get_frame,\n\t.wakeup\t\t\t= cdnsp_gadget_wakeup,\n\t.set_selfpowered\t= cdnsp_gadget_set_selfpowered,\n\t.pullup\t\t\t= cdnsp_gadget_pullup,\n\t.udc_start\t\t= cdnsp_gadget_udc_start,\n\t.udc_stop\t\t= cdnsp_gadget_udc_stop,\n};\n\nstatic void cdnsp_get_ep_buffering(struct cdnsp_device *pdev,\n\t\t\t\t   struct cdnsp_ep *pep)\n{\n\tvoid __iomem *reg = &pdev->cap_regs->hc_capbase;\n\tint endpoints;\n\n\treg += cdnsp_find_next_ext_cap(reg, 0, XBUF_CAP_ID);\n\n\tif (!pep->direction) {\n\t\tpep->buffering = readl(reg + XBUF_RX_TAG_MASK_0_OFFSET);\n\t\tpep->buffering_period = readl(reg + XBUF_RX_TAG_MASK_1_OFFSET);\n\t\tpep->buffering = (pep->buffering + 1) / 2;\n\t\tpep->buffering_period = (pep->buffering_period + 1) / 2;\n\t\treturn;\n\t}\n\n\tendpoints = HCS_ENDPOINTS(pdev->hcs_params1) / 2;\n\n\t \n\treg += XBUF_TX_CMD_OFFSET + (endpoints * 2 + 2) * sizeof(u32);\n\t \n\treg += pep->number * sizeof(u32) * 2;\n\n\tpep->buffering = (readl(reg) + 1) / 2;\n\tpep->buffering_period = pep->buffering;\n}\n\nstatic int cdnsp_gadget_init_endpoints(struct cdnsp_device *pdev)\n{\n\tint max_streams = HCC_MAX_PSA(pdev->hcc_params);\n\tstruct cdnsp_ep *pep;\n\tint i;\n\n\tINIT_LIST_HEAD(&pdev->gadget.ep_list);\n\n\tif (max_streams < STREAM_LOG_STREAMS) {\n\t\tdev_err(pdev->dev, \"Stream size %d not supported\\n\",\n\t\t\tmax_streams);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_streams = STREAM_LOG_STREAMS;\n\n\tfor (i = 0; i < CDNSP_ENDPOINTS_NUM; i++) {\n\t\tbool direction = !(i & 1);  \n\t\tu8 epnum = ((i + 1) >> 1);\n\n\t\tif (!CDNSP_IF_EP_EXIST(pdev, epnum, direction))\n\t\t\tcontinue;\n\n\t\tpep = &pdev->eps[i];\n\t\tpep->pdev = pdev;\n\t\tpep->number = epnum;\n\t\tpep->direction = direction;  \n\n\t\t \n\t\tif (epnum == 0) {\n\t\t\tsnprintf(pep->name, sizeof(pep->name), \"ep%d%s\",\n\t\t\t\t epnum, \"BiDir\");\n\n\t\t\tpep->idx = 0;\n\t\t\tusb_ep_set_maxpacket_limit(&pep->endpoint, 512);\n\t\t\tpep->endpoint.maxburst = 1;\n\t\t\tpep->endpoint.ops = &cdnsp_gadget_ep0_ops;\n\t\t\tpep->endpoint.desc = &cdnsp_gadget_ep0_desc;\n\t\t\tpep->endpoint.comp_desc = NULL;\n\t\t\tpep->endpoint.caps.type_control = true;\n\t\t\tpep->endpoint.caps.dir_in = true;\n\t\t\tpep->endpoint.caps.dir_out = true;\n\n\t\t\tpdev->ep0_preq.epnum = pep->number;\n\t\t\tpdev->ep0_preq.pep = pep;\n\t\t\tpdev->gadget.ep0 = &pep->endpoint;\n\t\t} else {\n\t\t\tsnprintf(pep->name, sizeof(pep->name), \"ep%d%s\",\n\t\t\t\t epnum, (pep->direction) ? \"in\" : \"out\");\n\n\t\t\tpep->idx =  (epnum * 2 + (direction ? 1 : 0)) - 1;\n\t\t\tusb_ep_set_maxpacket_limit(&pep->endpoint, 1024);\n\n\t\t\tpep->endpoint.max_streams = max_streams;\n\t\t\tpep->endpoint.ops = &cdnsp_gadget_ep_ops;\n\t\t\tlist_add_tail(&pep->endpoint.ep_list,\n\t\t\t\t      &pdev->gadget.ep_list);\n\n\t\t\tpep->endpoint.caps.type_iso = true;\n\t\t\tpep->endpoint.caps.type_bulk = true;\n\t\t\tpep->endpoint.caps.type_int = true;\n\n\t\t\tpep->endpoint.caps.dir_in = direction;\n\t\t\tpep->endpoint.caps.dir_out = !direction;\n\t\t}\n\n\t\tpep->endpoint.name = pep->name;\n\t\tpep->in_ctx = cdnsp_get_ep_ctx(&pdev->in_ctx, pep->idx);\n\t\tpep->out_ctx = cdnsp_get_ep_ctx(&pdev->out_ctx, pep->idx);\n\t\tcdnsp_get_ep_buffering(pdev, pep);\n\n\t\tdev_dbg(pdev->dev, \"Init %s, MPS: %04x SupType: \"\n\t\t\t\"CTRL: %s, INT: %s, BULK: %s, ISOC %s, \"\n\t\t\t\"SupDir IN: %s, OUT: %s\\n\",\n\t\t\tpep->name, 1024,\n\t\t\t(pep->endpoint.caps.type_control) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_int) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_bulk) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.type_iso) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.dir_in) ? \"yes\" : \"no\",\n\t\t\t(pep->endpoint.caps.dir_out) ? \"yes\" : \"no\");\n\n\t\tINIT_LIST_HEAD(&pep->pending_list);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdnsp_gadget_free_endpoints(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_ep *pep;\n\tint i;\n\n\tfor (i = 0; i < CDNSP_ENDPOINTS_NUM; i++) {\n\t\tpep = &pdev->eps[i];\n\t\tif (pep->number != 0 && pep->out_ctx)\n\t\t\tlist_del(&pep->endpoint.ep_list);\n\t}\n}\n\nvoid cdnsp_disconnect_gadget(struct cdnsp_device *pdev)\n{\n\tpdev->cdnsp_state |= CDNSP_STATE_DISCONNECT_PENDING;\n\n\tif (pdev->gadget_driver && pdev->gadget_driver->disconnect) {\n\t\tspin_unlock(&pdev->lock);\n\t\tpdev->gadget_driver->disconnect(&pdev->gadget);\n\t\tspin_lock(&pdev->lock);\n\t}\n\n\tpdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tusb_gadget_set_state(&pdev->gadget, USB_STATE_NOTATTACHED);\n\n\tpdev->cdnsp_state &= ~CDNSP_STATE_DISCONNECT_PENDING;\n}\n\nvoid cdnsp_suspend_gadget(struct cdnsp_device *pdev)\n{\n\tif (pdev->gadget_driver && pdev->gadget_driver->suspend) {\n\t\tspin_unlock(&pdev->lock);\n\t\tpdev->gadget_driver->suspend(&pdev->gadget);\n\t\tspin_lock(&pdev->lock);\n\t}\n}\n\nvoid cdnsp_resume_gadget(struct cdnsp_device *pdev)\n{\n\tif (pdev->gadget_driver && pdev->gadget_driver->resume) {\n\t\tspin_unlock(&pdev->lock);\n\t\tpdev->gadget_driver->resume(&pdev->gadget);\n\t\tspin_lock(&pdev->lock);\n\t}\n}\n\nvoid cdnsp_irq_reset(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_port_regs __iomem *port_regs;\n\n\tcdnsp_reset_device(pdev);\n\n\tport_regs = pdev->active_port->regs;\n\tpdev->gadget.speed = cdnsp_port_speed(readl(port_regs));\n\n\tspin_unlock(&pdev->lock);\n\tusb_gadget_udc_reset(&pdev->gadget, pdev->gadget_driver);\n\tspin_lock(&pdev->lock);\n\n\tswitch (pdev->gadget.speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\tcase USB_SPEED_SUPER:\n\t\tcdnsp_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tpdev->gadget.ep0->maxpacket = 512;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_FULL:\n\t\tcdnsp_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tpdev->gadget.ep0->maxpacket = 64;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_err(pdev->dev, \"Unknown device speed\\n\");\n\t\tbreak;\n\t}\n\n\tcdnsp_clear_chicken_bits_2(pdev, CHICKEN_XDMA_2_TP_CACHE_DIS);\n\tcdnsp_setup_device(pdev, SETUP_CONTEXT_ONLY);\n\tusb_gadget_set_state(&pdev->gadget, USB_STATE_DEFAULT);\n}\n\nstatic void cdnsp_get_rev_cap(struct cdnsp_device *pdev)\n{\n\tvoid __iomem *reg = &pdev->cap_regs->hc_capbase;\n\n\treg += cdnsp_find_next_ext_cap(reg, 0, RTL_REV_CAP);\n\tpdev->rev_cap  = reg;\n\n\tdev_info(pdev->dev, \"Rev: %08x/%08x, eps: %08x, buff: %08x/%08x\\n\",\n\t\t readl(&pdev->rev_cap->ctrl_revision),\n\t\t readl(&pdev->rev_cap->rtl_revision),\n\t\t readl(&pdev->rev_cap->ep_supported),\n\t\t readl(&pdev->rev_cap->rx_buff_size),\n\t\t readl(&pdev->rev_cap->tx_buff_size));\n}\n\nstatic int cdnsp_gen_setup(struct cdnsp_device *pdev)\n{\n\tint ret;\n\tu32 reg;\n\n\tpdev->cap_regs = pdev->regs;\n\tpdev->op_regs = pdev->regs +\n\t\tHC_LENGTH(readl(&pdev->cap_regs->hc_capbase));\n\tpdev->run_regs = pdev->regs +\n\t\t(readl(&pdev->cap_regs->run_regs_off) & RTSOFF_MASK);\n\n\t \n\tpdev->hcs_params1 = readl(&pdev->cap_regs->hcs_params1);\n\tpdev->hcc_params = readl(&pdev->cap_regs->hc_capbase);\n\tpdev->hci_version = HC_VERSION(pdev->hcc_params);\n\tpdev->hcc_params = readl(&pdev->cap_regs->hcc_params);\n\n\tcdnsp_get_rev_cap(pdev);\n\n\t \n\tret = cdnsp_halt(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = cdnsp_reset(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (HCC_64BIT_ADDR(pdev->hcc_params) &&\n\t    !dma_set_mask(pdev->dev, DMA_BIT_MASK(64))) {\n\t\tdev_dbg(pdev->dev, \"Enabling 64-bit DMA addresses.\\n\");\n\t\tdma_set_coherent_mask(pdev->dev, DMA_BIT_MASK(64));\n\t} else {\n\t\t \n\t\tret = dma_set_mask(pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdev_dbg(pdev->dev, \"Enabling 32-bit DMA addresses.\\n\");\n\t\tdma_set_coherent_mask(pdev->dev, DMA_BIT_MASK(32));\n\t}\n\n\tspin_lock_init(&pdev->lock);\n\n\tret = cdnsp_mem_init(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = readl(&pdev->port3x_regs->mode_2);\n\treg &= ~CFG_3XPORT_U1_PIPE_CLK_GATE_EN;\n\twritel(reg, &pdev->port3x_regs->mode_2);\n\n\treturn 0;\n}\n\nstatic int __cdnsp_gadget_init(struct cdns *cdns)\n{\n\tstruct cdnsp_device *pdev;\n\tu32 max_speed;\n\tint ret = -ENOMEM;\n\n\tcdns_drd_gadget_on(cdns);\n\n\tpdev = kzalloc(sizeof(*pdev), GFP_KERNEL);\n\tif (!pdev)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_get_sync(cdns->dev);\n\n\tcdns->gadget_dev = pdev;\n\tpdev->dev = cdns->dev;\n\tpdev->regs = cdns->dev_regs;\n\tmax_speed = usb_get_maximum_speed(cdns->dev);\n\n\tswitch (max_speed) {\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns->dev, \"invalid speed parameter %d\\n\", max_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tmax_speed = USB_SPEED_SUPER_PLUS;\n\t\tbreak;\n\t}\n\n\tpdev->gadget.ops = &cdnsp_gadget_ops;\n\tpdev->gadget.name = \"cdnsp-gadget\";\n\tpdev->gadget.speed = USB_SPEED_UNKNOWN;\n\tpdev->gadget.sg_supported = 1;\n\tpdev->gadget.max_speed = max_speed;\n\tpdev->gadget.lpm_capable = 1;\n\n\tpdev->setup_buf = kzalloc(CDNSP_EP0_SETUP_SIZE, GFP_KERNEL);\n\tif (!pdev->setup_buf)\n\t\tgoto free_pdev;\n\n\t \n\tpdev->gadget.quirk_ep_out_aligned_size = true;\n\n\tret = cdnsp_gen_setup(pdev);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"Generic initialization failed %d\\n\", ret);\n\t\tgoto free_setup;\n\t}\n\n\tret = cdnsp_gadget_init_endpoints(pdev);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"failed to initialize endpoints\\n\");\n\t\tgoto halt_pdev;\n\t}\n\n\tret = usb_add_gadget_udc(pdev->dev, &pdev->gadget);\n\tif (ret) {\n\t\tdev_err(pdev->dev, \"failed to register udc\\n\");\n\t\tgoto free_endpoints;\n\t}\n\n\tret = devm_request_threaded_irq(pdev->dev, cdns->dev_irq,\n\t\t\t\t\tcdnsp_irq_handler,\n\t\t\t\t\tcdnsp_thread_irq_handler, IRQF_SHARED,\n\t\t\t\t\tdev_name(pdev->dev), pdev);\n\tif (ret)\n\t\tgoto del_gadget;\n\n\treturn 0;\n\ndel_gadget:\n\tusb_del_gadget_udc(&pdev->gadget);\nfree_endpoints:\n\tcdnsp_gadget_free_endpoints(pdev);\nhalt_pdev:\n\tcdnsp_halt(pdev);\n\tcdnsp_reset(pdev);\n\tcdnsp_mem_cleanup(pdev);\nfree_setup:\n\tkfree(pdev->setup_buf);\nfree_pdev:\n\tkfree(pdev);\n\n\treturn ret;\n}\n\nstatic void cdnsp_gadget_exit(struct cdns *cdns)\n{\n\tstruct cdnsp_device *pdev = cdns->gadget_dev;\n\n\tdevm_free_irq(pdev->dev, cdns->dev_irq, pdev);\n\tpm_runtime_mark_last_busy(cdns->dev);\n\tpm_runtime_put_autosuspend(cdns->dev);\n\tusb_del_gadget_udc(&pdev->gadget);\n\tcdnsp_gadget_free_endpoints(pdev);\n\tcdnsp_mem_cleanup(pdev);\n\tkfree(pdev);\n\tcdns->gadget_dev = NULL;\n\tcdns_drd_gadget_off(cdns);\n}\n\nstatic int cdnsp_gadget_suspend(struct cdns *cdns, bool do_wakeup)\n{\n\tstruct cdnsp_device *pdev = cdns->gadget_dev;\n\tunsigned long flags;\n\n\tif (pdev->link_state == XDEV_U3)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tcdnsp_disconnect_gadget(pdev);\n\tcdnsp_stop(pdev);\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn 0;\n}\n\nstatic int cdnsp_gadget_resume(struct cdns *cdns, bool hibernated)\n{\n\tstruct cdnsp_device *pdev = cdns->gadget_dev;\n\tenum usb_device_speed max_speed;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!pdev->gadget_driver)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&pdev->lock, flags);\n\tmax_speed = pdev->gadget_driver->max_speed;\n\n\t \n\tmax_speed = min(max_speed, pdev->gadget.max_speed);\n\n\tret = cdnsp_run(pdev, max_speed);\n\n\tif (pdev->link_state == XDEV_U3)\n\t\t__cdnsp_gadget_wakeup(pdev);\n\n\tspin_unlock_irqrestore(&pdev->lock, flags);\n\n\treturn ret;\n}\n\n \nint cdnsp_gadget_init(struct cdns *cdns)\n{\n\tstruct cdns_role_driver *rdrv;\n\n\trdrv = devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start\t= __cdnsp_gadget_init;\n\trdrv->stop\t= cdnsp_gadget_exit;\n\trdrv->suspend\t= cdnsp_gadget_suspend;\n\trdrv->resume\t= cdnsp_gadget_resume;\n\trdrv->state\t= CDNS_ROLE_STATE_INACTIVE;\n\trdrv->name\t= \"gadget\";\n\tcdns->roles[USB_ROLE_DEVICE] = rdrv;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}