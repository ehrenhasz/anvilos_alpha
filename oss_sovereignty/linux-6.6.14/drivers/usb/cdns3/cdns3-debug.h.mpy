{
  "module_name": "cdns3-debug.h",
  "hash_id": "e00cf9be38f37a89a7c91645d8ad5723457f15947c48c8a9801a3d90e2a12351",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-debug.h",
  "human_readable_source": " \n \n#ifndef __LINUX_CDNS3_DEBUG\n#define __LINUX_CDNS3_DEBUG\n\n#include \"core.h\"\n\nstatic inline char *cdns3_decode_usb_irq(char *str,\n\t\t\t\t\t enum usb_device_speed speed,\n\t\t\t\t\t u32 usb_ists)\n{\n\tint ret;\n\n\tret = sprintf(str, \"IRQ %08x = \", usb_ists);\n\n\tif (usb_ists & (USB_ISTS_CON2I | USB_ISTS_CONI)) {\n\t\tret += sprintf(str + ret, \"Connection %s\\n\",\n\t\t\t       usb_speed_string(speed));\n\t}\n\tif (usb_ists & USB_ISTS_DIS2I || usb_ists & USB_ISTS_DISI)\n\t\tret += sprintf(str + ret, \"Disconnection \");\n\tif (usb_ists & USB_ISTS_L2ENTI)\n\t\tret += sprintf(str + ret, \"suspended \");\n\tif (usb_ists & USB_ISTS_L1ENTI)\n\t\tret += sprintf(str + ret, \"L1 enter \");\n\tif (usb_ists & USB_ISTS_L1EXTI)\n\t\tret += sprintf(str + ret, \"L1 exit \");\n\tif (usb_ists & USB_ISTS_L2ENTI)\n\t\tret += sprintf(str + ret, \"L2 enter \");\n\tif (usb_ists & USB_ISTS_L2EXTI)\n\t\tret += sprintf(str + ret, \"L2 exit \");\n\tif (usb_ists & USB_ISTS_U3EXTI)\n\t\tret += sprintf(str + ret, \"U3 exit \");\n\tif (usb_ists & USB_ISTS_UWRESI)\n\t\tret += sprintf(str + ret, \"Warm Reset \");\n\tif (usb_ists & USB_ISTS_UHRESI)\n\t\tret += sprintf(str + ret, \"Hot Reset \");\n\tif (usb_ists & USB_ISTS_U2RESI)\n\t\tret += sprintf(str + ret, \"Reset\");\n\n\treturn str;\n}\n\nstatic inline  char *cdns3_decode_ep_irq(char *str,\n\t\t\t\t\t u32 ep_sts,\n\t\t\t\t\t const char *ep_name)\n{\n\tint ret;\n\n\tret = sprintf(str, \"IRQ for %s: %08x \", ep_name, ep_sts);\n\n\tif (ep_sts & EP_STS_SETUP)\n\t\tret += sprintf(str + ret, \"SETUP \");\n\tif (ep_sts & EP_STS_IOC)\n\t\tret += sprintf(str + ret, \"IOC \");\n\tif (ep_sts & EP_STS_ISP)\n\t\tret += sprintf(str + ret, \"ISP \");\n\tif (ep_sts & EP_STS_DESCMIS)\n\t\tret += sprintf(str + ret, \"DESCMIS \");\n\tif (ep_sts & EP_STS_STREAMR)\n\t\tret += sprintf(str + ret, \"STREAMR \");\n\tif (ep_sts & EP_STS_MD_EXIT)\n\t\tret += sprintf(str + ret, \"MD_EXIT \");\n\tif (ep_sts & EP_STS_TRBERR)\n\t\tret += sprintf(str + ret, \"TRBERR \");\n\tif (ep_sts & EP_STS_NRDY)\n\t\tret += sprintf(str + ret, \"NRDY \");\n\tif (ep_sts & EP_STS_PRIME)\n\t\tret += sprintf(str + ret, \"PRIME \");\n\tif (ep_sts & EP_STS_SIDERR)\n\t\tret += sprintf(str + ret, \"SIDERRT \");\n\tif (ep_sts & EP_STS_OUTSMM)\n\t\tret += sprintf(str + ret, \"OUTSMM \");\n\tif (ep_sts & EP_STS_ISOERR)\n\t\tret += sprintf(str + ret, \"ISOERR \");\n\tif (ep_sts & EP_STS_IOT)\n\t\tret += sprintf(str + ret, \"IOT \");\n\n\treturn str;\n}\n\nstatic inline char *cdns3_decode_epx_irq(char *str,\n\t\t\t\t\t char *ep_name,\n\t\t\t\t\t u32 ep_sts)\n{\n\treturn cdns3_decode_ep_irq(str, ep_sts, ep_name);\n}\n\nstatic inline char *cdns3_decode_ep0_irq(char *str,\n\t\t\t\t\t int dir,\n\t\t\t\t\t u32 ep_sts)\n{\n\treturn cdns3_decode_ep_irq(str, ep_sts,\n\t\t\t\t   dir ? \"ep0IN\" : \"ep0OUT\");\n}\n\n \nstatic inline char *cdns3_dbg_ring(struct cdns3_endpoint *priv_ep, char *str)\n{\n\tdma_addr_t addr = priv_ep->trb_pool_dma;\n\tstruct cdns3_trb *trb;\n\tint trb_per_sector;\n\tint ret = 0;\n\tint i;\n\n\ttrb_per_sector = GET_TRBS_PER_SEGMENT(priv_ep->type);\n\n\ttrb = &priv_ep->trb_pool[priv_ep->dequeue];\n\tret += sprintf(str + ret, \"\\n\\t\\tRing contents for %s:\", priv_ep->name);\n\n\tret += sprintf(str + ret,\n\t\t       \"\\n\\t\\tRing deq index: %d, trb: %p (virt), 0x%llx (dma)\\n\",\n\t\t       priv_ep->dequeue, trb,\n\t\t       (unsigned long long)cdns3_trb_virt_to_dma(priv_ep, trb));\n\n\ttrb = &priv_ep->trb_pool[priv_ep->enqueue];\n\tret += sprintf(str + ret,\n\t\t       \"\\t\\tRing enq index: %d, trb: %p (virt), 0x%llx (dma)\\n\",\n\t\t       priv_ep->enqueue, trb,\n\t\t       (unsigned long long)cdns3_trb_virt_to_dma(priv_ep, trb));\n\n\tret += sprintf(str + ret,\n\t\t       \"\\t\\tfree trbs: %d, CCS=%d, PCS=%d\\n\",\n\t\t       priv_ep->free_trbs, priv_ep->ccs, priv_ep->pcs);\n\n\tif (trb_per_sector > TRBS_PER_SEGMENT) {\n\t\tsprintf(str + ret, \"\\t\\tTransfer ring %d too big\\n\",\n\t\t\ttrb_per_sector);\n\t\treturn str;\n\t}\n\n\tfor (i = 0; i < trb_per_sector; ++i) {\n\t\ttrb = &priv_ep->trb_pool[i];\n\t\tret += sprintf(str + ret,\n\t\t\t\"\\t\\t@%pad %08x %08x %08x\\n\", &addr,\n\t\t\tle32_to_cpu(trb->buffer),\n\t\t\tle32_to_cpu(trb->length),\n\t\t\tle32_to_cpu(trb->control));\n\t\taddr += sizeof(*trb);\n\t}\n\n\treturn str;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}