{
  "module_name": "core.c",
  "hash_id": "4830391407242ee88af25dcc64bb5d7f4c7a48c3a823674d1ce5e897be1b26a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/core.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/pm_runtime.h>\n\n#include \"core.h\"\n#include \"host-export.h\"\n#include \"drd.h\"\n\nstatic int cdns_idle_init(struct cdns *cdns);\n\nstatic int cdns_role_start(struct cdns *cdns, enum usb_role role)\n{\n\tint ret;\n\n\tif (WARN_ON(role > USB_ROLE_DEVICE))\n\t\treturn 0;\n\n\tmutex_lock(&cdns->mutex);\n\tcdns->role = role;\n\tmutex_unlock(&cdns->mutex);\n\n\tif (!cdns->roles[role])\n\t\treturn -ENXIO;\n\n\tif (cdns->roles[role]->state == CDNS_ROLE_STATE_ACTIVE)\n\t\treturn 0;\n\n\tmutex_lock(&cdns->mutex);\n\tret = cdns->roles[role]->start(cdns);\n\tif (!ret)\n\t\tcdns->roles[role]->state = CDNS_ROLE_STATE_ACTIVE;\n\tmutex_unlock(&cdns->mutex);\n\n\treturn ret;\n}\n\nstatic void cdns_role_stop(struct cdns *cdns)\n{\n\tenum usb_role role = cdns->role;\n\n\tif (WARN_ON(role > USB_ROLE_DEVICE))\n\t\treturn;\n\n\tif (cdns->roles[role]->state == CDNS_ROLE_STATE_INACTIVE)\n\t\treturn;\n\n\tmutex_lock(&cdns->mutex);\n\tcdns->roles[role]->stop(cdns);\n\tcdns->roles[role]->state = CDNS_ROLE_STATE_INACTIVE;\n\tmutex_unlock(&cdns->mutex);\n}\n\nstatic void cdns_exit_roles(struct cdns *cdns)\n{\n\tcdns_role_stop(cdns);\n\tcdns_drd_exit(cdns);\n}\n\n \nstatic int cdns_core_init_role(struct cdns *cdns)\n{\n\tstruct device *dev = cdns->dev;\n\tenum usb_dr_mode best_dr_mode;\n\tenum usb_dr_mode dr_mode;\n\tint ret;\n\n\tdr_mode = usb_get_dr_mode(dev);\n\tcdns->role = USB_ROLE_NONE;\n\n\t \n\tif (dr_mode == USB_DR_MODE_UNKNOWN) {\n\t\tif (cdns->version == CDNSP_CONTROLLER_V2) {\n\t\t\tif (IS_ENABLED(CONFIG_USB_CDNSP_HOST) &&\n\t\t\t    IS_ENABLED(CONFIG_USB_CDNSP_GADGET))\n\t\t\t\tdr_mode = USB_DR_MODE_OTG;\n\t\t\telse if (IS_ENABLED(CONFIG_USB_CDNSP_HOST))\n\t\t\t\tdr_mode = USB_DR_MODE_HOST;\n\t\t\telse if (IS_ENABLED(CONFIG_USB_CDNSP_GADGET))\n\t\t\t\tdr_mode = USB_DR_MODE_PERIPHERAL;\n\t\t} else {\n\t\t\tif (IS_ENABLED(CONFIG_USB_CDNS3_HOST) &&\n\t\t\t    IS_ENABLED(CONFIG_USB_CDNS3_GADGET))\n\t\t\t\tdr_mode = USB_DR_MODE_OTG;\n\t\t\telse if (IS_ENABLED(CONFIG_USB_CDNS3_HOST))\n\t\t\t\tdr_mode = USB_DR_MODE_HOST;\n\t\t\telse if (IS_ENABLED(CONFIG_USB_CDNS3_GADGET))\n\t\t\t\tdr_mode = USB_DR_MODE_PERIPHERAL;\n\t\t}\n\t}\n\n\t \n\tbest_dr_mode = cdns->dr_mode;\n\n\tret = cdns_idle_init(cdns);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dr_mode == USB_DR_MODE_OTG) {\n\t\tbest_dr_mode = cdns->dr_mode;\n\t} else if (cdns->dr_mode == USB_DR_MODE_OTG) {\n\t\tbest_dr_mode = dr_mode;\n\t} else if (cdns->dr_mode != dr_mode) {\n\t\tdev_err(dev, \"Incorrect DRD configuration\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdr_mode = best_dr_mode;\n\n\tif (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_HOST) {\n\t\tif ((cdns->version == CDNSP_CONTROLLER_V2 &&\n\t\t     IS_ENABLED(CONFIG_USB_CDNSP_HOST)) ||\n\t\t    (cdns->version < CDNSP_CONTROLLER_V2 &&\n\t\t     IS_ENABLED(CONFIG_USB_CDNS3_HOST)))\n\t\t\tret = cdns_host_init(cdns);\n\t\telse\n\t\t\tret = -ENXIO;\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Host initialization failed with %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\tif (cdns->gadget_init)\n\t\t\tret = cdns->gadget_init(cdns);\n\t\telse\n\t\t\tret = -ENXIO;\n\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Device initialization failed with %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tcdns->dr_mode = dr_mode;\n\n\tret = cdns_drd_update_mode(cdns);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = cdns_role_start(cdns, USB_ROLE_NONE);\n\tif (ret)\n\t\tgoto err;\n\n\tswitch (cdns->dr_mode) {\n\tcase USB_DR_MODE_OTG:\n\t\tret = cdns_hw_role_switch(cdns);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tret = cdns_role_start(cdns, USB_ROLE_DEVICE);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tret = cdns_role_start(cdns, USB_ROLE_HOST);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tcdns_exit_roles(cdns);\n\treturn ret;\n}\n\n \nstatic enum usb_role cdns_hw_role_state_machine(struct cdns *cdns)\n{\n\tenum usb_role role = USB_ROLE_NONE;\n\tint id, vbus;\n\n\tif (cdns->dr_mode != USB_DR_MODE_OTG) {\n\t\tif (cdns_is_host(cdns))\n\t\t\trole = USB_ROLE_HOST;\n\t\tif (cdns_is_device(cdns))\n\t\t\trole = USB_ROLE_DEVICE;\n\n\t\treturn role;\n\t}\n\n\tid = cdns_get_id(cdns);\n\tvbus = cdns_get_vbus(cdns);\n\n\t \n\trole = cdns->role;\n\n\tswitch (role) {\n\tcase USB_ROLE_NONE:\n\t\t \n\t\tif (!id)\n\t\t\trole = USB_ROLE_HOST;\n\t\telse if (vbus)\n\t\t\trole = USB_ROLE_DEVICE;\n\t\tbreak;\n\tcase USB_ROLE_HOST:  \n\t\tif (id)\n\t\t\trole = USB_ROLE_NONE;\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:  \n\t\tif (!vbus)\n\t\t\trole = USB_ROLE_NONE;\n\t\tbreak;\n\t}\n\n\tdev_dbg(cdns->dev, \"role %d -> %d\\n\", cdns->role, role);\n\n\treturn role;\n}\n\nstatic int cdns_idle_role_start(struct cdns *cdns)\n{\n\treturn 0;\n}\n\nstatic void cdns_idle_role_stop(struct cdns *cdns)\n{\n\t \n\tphy_reset(cdns->usb3_phy);\n}\n\nstatic int cdns_idle_init(struct cdns *cdns)\n{\n\tstruct cdns_role_driver *rdrv;\n\n\trdrv = devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start = cdns_idle_role_start;\n\trdrv->stop = cdns_idle_role_stop;\n\trdrv->state = CDNS_ROLE_STATE_INACTIVE;\n\trdrv->suspend = NULL;\n\trdrv->resume = NULL;\n\trdrv->name = \"idle\";\n\n\tcdns->roles[USB_ROLE_NONE] = rdrv;\n\n\treturn 0;\n}\n\n \nint cdns_hw_role_switch(struct cdns *cdns)\n{\n\tenum usb_role real_role, current_role;\n\tint ret = 0;\n\n\t \n\tif (cdns->role_sw)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(cdns->dev);\n\n\tcurrent_role = cdns->role;\n\treal_role = cdns_hw_role_state_machine(cdns);\n\n\t \n\tif (current_role == real_role)\n\t\tgoto exit;\n\n\tcdns_role_stop(cdns);\n\n\tdev_dbg(cdns->dev, \"Switching role %d -> %d\", current_role, real_role);\n\n\tret = cdns_role_start(cdns, real_role);\n\tif (ret) {\n\t\t \n\t\tdev_err(cdns->dev, \"set %d has failed, back to %d\\n\",\n\t\t\treal_role, current_role);\n\t\tret = cdns_role_start(cdns, current_role);\n\t\tif (ret)\n\t\t\tdev_err(cdns->dev, \"back to %d failed too\\n\",\n\t\t\t\tcurrent_role);\n\t}\nexit:\n\tpm_runtime_put_sync(cdns->dev);\n\treturn ret;\n}\n\n \nstatic enum usb_role cdns_role_get(struct usb_role_switch *sw)\n{\n\tstruct cdns *cdns = usb_role_switch_get_drvdata(sw);\n\n\treturn cdns->role;\n}\n\n \nstatic int cdns_role_set(struct usb_role_switch *sw, enum usb_role role)\n{\n\tstruct cdns *cdns = usb_role_switch_get_drvdata(sw);\n\tint ret = 0;\n\n\tpm_runtime_get_sync(cdns->dev);\n\n\tif (cdns->role == role)\n\t\tgoto pm_put;\n\n\tif (cdns->dr_mode == USB_DR_MODE_HOST) {\n\t\tswitch (role) {\n\t\tcase USB_ROLE_NONE:\n\t\tcase USB_ROLE_HOST:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto pm_put;\n\t\t}\n\t}\n\n\tif (cdns->dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\tswitch (role) {\n\t\tcase USB_ROLE_NONE:\n\t\tcase USB_ROLE_DEVICE:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto pm_put;\n\t\t}\n\t}\n\n\tcdns_role_stop(cdns);\n\tret = cdns_role_start(cdns, role);\n\tif (ret)\n\t\tdev_err(cdns->dev, \"set role %d has failed\\n\", role);\n\npm_put:\n\tpm_runtime_put_sync(cdns->dev);\n\treturn ret;\n}\n\n\n \nstatic irqreturn_t cdns_wakeup_irq(int irq, void *data)\n{\n\tstruct cdns *cdns = data;\n\n\tif (cdns->in_lpm) {\n\t\tdisable_irq_nosync(irq);\n\t\tcdns->wakeup_pending = true;\n\t\tif ((cdns->role == USB_ROLE_HOST) && cdns->host_dev)\n\t\t\tpm_request_resume(&cdns->host_dev->dev);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\treturn IRQ_NONE;\n}\n\n \nint cdns_init(struct cdns *cdns)\n{\n\tstruct device *dev = cdns->dev;\n\tint ret;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"error setting dma mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_init(&cdns->mutex);\n\n\tif (device_property_read_bool(dev, \"usb-role-switch\")) {\n\t\tstruct usb_role_switch_desc sw_desc = { };\n\n\t\tsw_desc.set = cdns_role_set;\n\t\tsw_desc.get = cdns_role_get;\n\t\tsw_desc.allow_userspace_control = true;\n\t\tsw_desc.driver_data = cdns;\n\t\tsw_desc.fwnode = dev->fwnode;\n\n\t\tcdns->role_sw = usb_role_switch_register(dev, &sw_desc);\n\t\tif (IS_ERR(cdns->role_sw)) {\n\t\t\tdev_warn(dev, \"Unable to register Role Switch\\n\");\n\t\t\treturn PTR_ERR(cdns->role_sw);\n\t\t}\n\t}\n\n\tif (cdns->wakeup_irq) {\n\t\tret = devm_request_irq(cdns->dev, cdns->wakeup_irq,\n\t\t\t\t\t\tcdns_wakeup_irq,\n\t\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\t\tdev_name(cdns->dev), cdns);\n\n\t\tif (ret) {\n\t\t\tdev_err(cdns->dev, \"couldn't register wakeup irq handler\\n\");\n\t\t\tgoto role_switch_unregister;\n\t\t}\n\t}\n\n\tret = cdns_drd_init(cdns);\n\tif (ret)\n\t\tgoto init_failed;\n\n\tret = cdns_core_init_role(cdns);\n\tif (ret)\n\t\tgoto init_failed;\n\n\tspin_lock_init(&cdns->lock);\n\n\tdev_dbg(dev, \"Cadence USB3 core: probe succeed\\n\");\n\n\treturn 0;\ninit_failed:\n\tcdns_drd_exit(cdns);\nrole_switch_unregister:\n\tif (cdns->role_sw)\n\t\tusb_role_switch_unregister(cdns->role_sw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cdns_init);\n\n \nint cdns_remove(struct cdns *cdns)\n{\n\tcdns_exit_roles(cdns);\n\tusb_role_switch_unregister(cdns->role_sw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdns_remove);\n\n#ifdef CONFIG_PM_SLEEP\nint cdns_suspend(struct cdns *cdns)\n{\n\tstruct device *dev = cdns->dev;\n\tunsigned long flags;\n\n\tif (pm_runtime_status_suspended(dev))\n\t\tpm_runtime_resume(dev);\n\n\tif (cdns->roles[cdns->role]->suspend) {\n\t\tspin_lock_irqsave(&cdns->lock, flags);\n\t\tcdns->roles[cdns->role]->suspend(cdns, false);\n\t\tspin_unlock_irqrestore(&cdns->lock, flags);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdns_suspend);\n\nint cdns_resume(struct cdns *cdns)\n{\n\tenum usb_role real_role;\n\tbool role_changed = false;\n\tint ret = 0;\n\n\tif (cdns_power_is_lost(cdns)) {\n\t\tif (cdns->role_sw) {\n\t\t\tcdns->role = cdns_role_get(cdns->role_sw);\n\t\t} else {\n\t\t\treal_role = cdns_hw_role_state_machine(cdns);\n\t\t\tif (real_role != cdns->role) {\n\t\t\t\tret = cdns_hw_role_switch(cdns);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t\trole_changed = true;\n\t\t\t}\n\t\t}\n\n\t\tif (!role_changed) {\n\t\t\tif (cdns->role == USB_ROLE_HOST)\n\t\t\t\tret = cdns_drd_host_on(cdns);\n\t\t\telse if (cdns->role == USB_ROLE_DEVICE)\n\t\t\t\tret = cdns_drd_gadget_on(cdns);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (cdns->roles[cdns->role]->resume)\n\t\tcdns->roles[cdns->role]->resume(cdns, cdns_power_is_lost(cdns));\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdns_resume);\n\nvoid cdns_set_active(struct cdns *cdns, u8 set_active)\n{\n\tstruct device *dev = cdns->dev;\n\n\tif (set_active) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn;\n}\nEXPORT_SYMBOL_GPL(cdns_set_active);\n#endif  \n\nMODULE_AUTHOR(\"Peter Chen <peter.chen@nxp.com>\");\nMODULE_AUTHOR(\"Pawel Laszczak <pawell@cadence.com>\");\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_DESCRIPTION(\"Cadence USBSS and USBSSP DRD Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}