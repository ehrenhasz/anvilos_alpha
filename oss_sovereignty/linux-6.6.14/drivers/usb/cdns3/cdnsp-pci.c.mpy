{
  "module_name": "cdnsp-pci.c",
  "hash_id": "0bb00cff31576cf6f88313283c207a53e3e6807214672a3fac08784e255c0189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdnsp-pci.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pci.h>\n\n#include \"core.h\"\n#include \"gadget-export.h\"\n\n#define PCI_BAR_HOST\t\t0\n#define PCI_BAR_OTG\t\t0\n#define PCI_BAR_DEV\t\t2\n\n#define PCI_DEV_FN_HOST_DEVICE\t0\n#define PCI_DEV_FN_OTG\t\t1\n\n#define PCI_DRIVER_NAME\t\t\"cdns-pci-usbssp\"\n#define PLAT_DRIVER_NAME\t\"cdns-usbssp\"\n\n#define CDNS_VENDOR_ID\t\t0x17cd\n#define CDNS_DEVICE_ID\t\t0x0200\n#define CDNS_DRD_ID\t\t0x0100\n#define CDNS_DRD_IF\t\t(PCI_CLASS_SERIAL_USB << 8 | 0x80)\n\nstatic struct pci_dev *cdnsp_get_second_fun(struct pci_dev *pdev)\n{\n\t \n\tif (pdev->device == CDNS_DEVICE_ID)\n\t\treturn  pci_get_device(pdev->vendor, CDNS_DRD_ID, NULL);\n\telse if (pdev->device == CDNS_DRD_ID)\n\t\treturn pci_get_device(pdev->vendor, CDNS_DEVICE_ID, NULL);\n\n\treturn NULL;\n}\n\nstatic int cdnsp_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *id)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pci_dev *func;\n\tstruct resource *res;\n\tstruct cdns *cdnsp;\n\tint ret;\n\n\t \n\tif (!id || (pdev->devfn != PCI_DEV_FN_HOST_DEVICE &&\n\t\t    pdev->devfn != PCI_DEV_FN_OTG))\n\t\treturn -EINVAL;\n\n\tfunc = cdnsp_get_second_fun(pdev);\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tif (func->class == PCI_CLASS_SERIAL_USB_XHCI ||\n\t    pdev->class == PCI_CLASS_SERIAL_USB_XHCI) {\n\t\tret = -EINVAL;\n\t\tgoto put_pci;\n\t}\n\n\tret = pcim_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Enabling PCI device has failed %d\\n\", ret);\n\t\tgoto put_pci;\n\t}\n\n\tpci_set_master(pdev);\n\tif (pci_is_enabled(func)) {\n\t\tcdnsp = pci_get_drvdata(func);\n\t} else {\n\t\tcdnsp = kzalloc(sizeof(*cdnsp), GFP_KERNEL);\n\t\tif (!cdnsp) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto disable_pci;\n\t\t}\n\t}\n\n\t \n\tif (pdev->devfn == 0) {\n\t\tresource_size_t rsrc_start, rsrc_len;\n\n\t\t \n\t\tdev_dbg(dev, \"Initialize resources\\n\");\n\t\trsrc_start = pci_resource_start(pdev, PCI_BAR_DEV);\n\t\trsrc_len = pci_resource_len(pdev, PCI_BAR_DEV);\n\t\tres = devm_request_mem_region(dev, rsrc_start, rsrc_len, \"dev\");\n\t\tif (!res) {\n\t\t\tdev_dbg(dev, \"controller already in use\\n\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto free_cdnsp;\n\t\t}\n\n\t\tcdnsp->dev_regs = devm_ioremap(dev, rsrc_start, rsrc_len);\n\t\tif (!cdnsp->dev_regs) {\n\t\t\tdev_dbg(dev, \"error mapping memory\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto free_cdnsp;\n\t\t}\n\n\t\tcdnsp->dev_irq = pdev->irq;\n\t\tdev_dbg(dev, \"USBSS-DEV physical base addr: %pa\\n\",\n\t\t\t&rsrc_start);\n\n\t\tres = &cdnsp->xhci_res[0];\n\t\tres->start = pci_resource_start(pdev, PCI_BAR_HOST);\n\t\tres->end = pci_resource_end(pdev, PCI_BAR_HOST);\n\t\tres->name = \"xhci\";\n\t\tres->flags = IORESOURCE_MEM;\n\t\tdev_dbg(dev, \"USBSS-XHCI physical base addr: %pa\\n\",\n\t\t\t&res->start);\n\n\t\t \n\t\tres = &cdnsp->xhci_res[1];\n\t\tres->start = pdev->irq;\n\t\tres->name = \"host\";\n\t\tres->flags = IORESOURCE_IRQ;\n\t} else {\n\t\tres = &cdnsp->otg_res;\n\t\tres->start = pci_resource_start(pdev, PCI_BAR_OTG);\n\t\tres->end =   pci_resource_end(pdev, PCI_BAR_OTG);\n\t\tres->name = \"otg\";\n\t\tres->flags = IORESOURCE_MEM;\n\t\tdev_dbg(dev, \"CDNSP-DRD physical base addr: %pa\\n\",\n\t\t\t&res->start);\n\n\t\t \n\t\tcdnsp->otg_irq = pdev->irq;\n\t}\n\n\tif (pci_is_enabled(func)) {\n\t\tcdnsp->dev = dev;\n\t\tcdnsp->gadget_init = cdnsp_gadget_init;\n\n\t\tret = cdns_init(cdnsp);\n\t\tif (ret)\n\t\t\tgoto free_cdnsp;\n\t}\n\n\tpci_set_drvdata(pdev, cdnsp);\n\n\tdevice_wakeup_enable(&pdev->dev);\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\treturn 0;\n\nfree_cdnsp:\n\tif (!pci_is_enabled(func))\n\t\tkfree(cdnsp);\n\ndisable_pci:\n\tpci_disable_device(pdev);\n\nput_pci:\n\tpci_dev_put(func);\n\n\treturn ret;\n}\n\nstatic void cdnsp_pci_remove(struct pci_dev *pdev)\n{\n\tstruct cdns *cdnsp;\n\tstruct pci_dev *func;\n\n\tfunc = cdnsp_get_second_fun(pdev);\n\tcdnsp = (struct cdns *)pci_get_drvdata(pdev);\n\n\tif (pci_dev_run_wake(pdev))\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\tif (pci_is_enabled(func)) {\n\t\tcdns_remove(cdnsp);\n\t} else {\n\t\tkfree(cdnsp);\n\t}\n\n\tpci_dev_put(func);\n}\n\nstatic int __maybe_unused cdnsp_pci_suspend(struct device *dev)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\n\treturn cdns_suspend(cdns);\n}\n\nstatic int __maybe_unused cdnsp_pci_resume(struct device *dev)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&cdns->lock, flags);\n\tret = cdns_resume(cdns);\n\tspin_unlock_irqrestore(&cdns->lock, flags);\n\tcdns_set_active(cdns, 1);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops cdnsp_pci_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cdnsp_pci_suspend, cdnsp_pci_resume)\n};\n\nstatic const struct pci_device_id cdnsp_pci_ids[] = {\n\t{ PCI_VENDOR_ID_CDNS, CDNS_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  PCI_CLASS_SERIAL_USB_DEVICE, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_CDNS, CDNS_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  CDNS_DRD_IF, PCI_ANY_ID },\n\t{ PCI_VENDOR_ID_CDNS, CDNS_DRD_ID, PCI_ANY_ID, PCI_ANY_ID,\n\t  CDNS_DRD_IF, PCI_ANY_ID },\n\t{ 0, }\n};\n\nstatic struct pci_driver cdnsp_pci_driver = {\n\t.name = \"cdnsp-pci\",\n\t.id_table = &cdnsp_pci_ids[0],\n\t.probe = cdnsp_pci_probe,\n\t.remove = cdnsp_pci_remove,\n\t.driver = {\n\t\t.pm = &cdnsp_pci_pm_ops,\n\t}\n};\n\nmodule_pci_driver(cdnsp_pci_driver);\nMODULE_DEVICE_TABLE(pci, cdnsp_pci_ids);\n\nMODULE_ALIAS(\"pci:cdnsp\");\nMODULE_AUTHOR(\"Pawel Laszczak <pawell@cadence.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence CDNSP PCI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}