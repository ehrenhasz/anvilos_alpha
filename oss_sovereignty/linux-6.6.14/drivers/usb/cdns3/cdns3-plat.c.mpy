{
  "module_name": "cdns3-plat.c",
  "hash_id": "3c3eb72bc4b0f1a4e8121c4e18b030f14e07aff4297bac1e2cccbd8710172732",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-plat.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n#include \"core.h\"\n#include \"gadget-export.h\"\n#include \"drd.h\"\n\nstatic int set_phy_power_on(struct cdns *cdns)\n{\n\tint ret;\n\n\tret = phy_power_on(cdns->usb2_phy);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_power_on(cdns->usb3_phy);\n\tif (ret)\n\t\tphy_power_off(cdns->usb2_phy);\n\n\treturn ret;\n}\n\nstatic void set_phy_power_off(struct cdns *cdns)\n{\n\tphy_power_off(cdns->usb3_phy);\n\tphy_power_off(cdns->usb2_phy);\n}\n\n \nstatic int cdns3_plat_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource\t*res;\n\tstruct cdns *cdns;\n\tvoid __iomem *regs;\n\tint ret;\n\n\tcdns = devm_kzalloc(dev, sizeof(*cdns), GFP_KERNEL);\n\tif (!cdns)\n\t\treturn -ENOMEM;\n\n\tcdns->dev = dev;\n\tcdns->pdata = dev_get_platdata(dev);\n\n\tplatform_set_drvdata(pdev, cdns);\n\n\tret = platform_get_irq_byname(pdev, \"host\");\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcdns->xhci_res[0].start = ret;\n\tcdns->xhci_res[0].end = ret;\n\tcdns->xhci_res[0].flags = IORESOURCE_IRQ | irq_get_trigger_type(ret);\n\tcdns->xhci_res[0].name = \"host\";\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"xhci\");\n\tif (!res) {\n\t\tdev_err(dev, \"couldn't get xhci resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tcdns->xhci_res[1] = *res;\n\n\tcdns->dev_irq = platform_get_irq_byname(pdev, \"peripheral\");\n\n\tif (cdns->dev_irq < 0)\n\t\treturn cdns->dev_irq;\n\n\tregs = devm_platform_ioremap_resource_byname(pdev, \"dev\");\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\tcdns->dev_regs\t= regs;\n\n\tcdns->otg_irq = platform_get_irq_byname(pdev, \"otg\");\n\tif (cdns->otg_irq < 0)\n\t\treturn cdns->otg_irq;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"otg\");\n\tif (!res) {\n\t\tdev_err(dev, \"couldn't get otg resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tcdns->phyrst_a_enable = device_property_read_bool(dev, \"cdns,phyrst-a-enable\");\n\n\tcdns->otg_res = *res;\n\n\tcdns->wakeup_irq = platform_get_irq_byname_optional(pdev, \"wakeup\");\n\tif (cdns->wakeup_irq == -EPROBE_DEFER)\n\t\treturn cdns->wakeup_irq;\n\n\tif (cdns->wakeup_irq < 0) {\n\t\tdev_dbg(dev, \"couldn't get wakeup irq\\n\");\n\t\tcdns->wakeup_irq = 0x0;\n\t}\n\n\tcdns->usb2_phy = devm_phy_optional_get(dev, \"cdns3,usb2-phy\");\n\tif (IS_ERR(cdns->usb2_phy))\n\t\treturn PTR_ERR(cdns->usb2_phy);\n\n\tret = phy_init(cdns->usb2_phy);\n\tif (ret)\n\t\treturn ret;\n\n\tcdns->usb3_phy = devm_phy_optional_get(dev, \"cdns3,usb3-phy\");\n\tif (IS_ERR(cdns->usb3_phy))\n\t\treturn PTR_ERR(cdns->usb3_phy);\n\n\tret = phy_init(cdns->usb3_phy);\n\tif (ret)\n\t\tgoto err_phy3_init;\n\n\tret = set_phy_power_on(cdns);\n\tif (ret)\n\t\tgoto err_phy_power_on;\n\n\tcdns->gadget_init = cdns3_gadget_init;\n\n\tret = cdns_init(cdns);\n\tif (ret)\n\t\tgoto err_cdns_init;\n\n\tdevice_set_wakeup_capable(dev, true);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\tif (!(cdns->pdata && (cdns->pdata->quirks & CDNS3_DEFAULT_PM_RUNTIME_ALLOW)))\n\t\tpm_runtime_forbid(dev);\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, 20);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_use_autosuspend(dev);\n\n\treturn 0;\n\nerr_cdns_init:\n\tset_phy_power_off(cdns);\nerr_phy_power_on:\n\tphy_exit(cdns->usb3_phy);\nerr_phy3_init:\n\tphy_exit(cdns->usb2_phy);\n\n\treturn ret;\n}\n\n \nstatic void cdns3_plat_remove(struct platform_device *pdev)\n{\n\tstruct cdns *cdns = platform_get_drvdata(pdev);\n\tstruct device *dev = cdns->dev;\n\n\tpm_runtime_get_sync(dev);\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tcdns_remove(cdns);\n\tset_phy_power_off(cdns);\n\tphy_exit(cdns->usb2_phy);\n\tphy_exit(cdns->usb3_phy);\n}\n\n#ifdef CONFIG_PM\n\nstatic int cdns3_set_platform_suspend(struct device *dev,\n\t\t\t\t      bool suspend, bool wakeup)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (cdns->pdata && cdns->pdata->platform_suspend)\n\t\tret = cdns->pdata->platform_suspend(dev, suspend, wakeup);\n\n\treturn ret;\n}\n\nstatic int cdns3_controller_suspend(struct device *dev, pm_message_t msg)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tbool wakeup;\n\tunsigned long flags;\n\n\tif (cdns->in_lpm)\n\t\treturn 0;\n\n\tif (PMSG_IS_AUTO(msg))\n\t\twakeup = true;\n\telse\n\t\twakeup = device_may_wakeup(dev);\n\n\tcdns3_set_platform_suspend(cdns->dev, true, wakeup);\n\tset_phy_power_off(cdns);\n\tspin_lock_irqsave(&cdns->lock, flags);\n\tcdns->in_lpm = true;\n\tspin_unlock_irqrestore(&cdns->lock, flags);\n\tdev_dbg(cdns->dev, \"%s ends\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int cdns3_controller_resume(struct device *dev, pm_message_t msg)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tint ret;\n\tunsigned long flags;\n\n\tif (!cdns->in_lpm)\n\t\treturn 0;\n\n\tif (cdns_power_is_lost(cdns)) {\n\t\tphy_exit(cdns->usb2_phy);\n\t\tret = phy_init(cdns->usb2_phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tphy_exit(cdns->usb3_phy);\n\t\tret = phy_init(cdns->usb3_phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = set_phy_power_on(cdns);\n\tif (ret)\n\t\treturn ret;\n\n\tcdns3_set_platform_suspend(cdns->dev, false, false);\n\n\tspin_lock_irqsave(&cdns->lock, flags);\n\tcdns_resume(cdns);\n\tcdns->in_lpm = false;\n\tspin_unlock_irqrestore(&cdns->lock, flags);\n\tcdns_set_active(cdns, !PMSG_IS_AUTO(msg));\n\tif (cdns->wakeup_pending) {\n\t\tcdns->wakeup_pending = false;\n\t\tenable_irq(cdns->wakeup_irq);\n\t}\n\tdev_dbg(cdns->dev, \"%s ends\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int cdns3_plat_runtime_suspend(struct device *dev)\n{\n\treturn cdns3_controller_suspend(dev, PMSG_AUTO_SUSPEND);\n}\n\nstatic int cdns3_plat_runtime_resume(struct device *dev)\n{\n\treturn cdns3_controller_resume(dev, PMSG_AUTO_RESUME);\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int cdns3_plat_suspend(struct device *dev)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tint ret;\n\n\tcdns_suspend(cdns);\n\n\tret = cdns3_controller_suspend(dev, PMSG_SUSPEND);\n\tif (ret)\n\t\treturn ret;\n\n\tif (device_may_wakeup(dev) && cdns->wakeup_irq)\n\t\tenable_irq_wake(cdns->wakeup_irq);\n\n\treturn ret;\n}\n\nstatic int cdns3_plat_resume(struct device *dev)\n{\n\treturn cdns3_controller_resume(dev, PMSG_RESUME);\n}\n#endif  \n#endif  \n\nstatic const struct dev_pm_ops cdns3_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(cdns3_plat_suspend, cdns3_plat_resume)\n\tSET_RUNTIME_PM_OPS(cdns3_plat_runtime_suspend,\n\t\t\t   cdns3_plat_runtime_resume, NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id of_cdns3_match[] = {\n\t{ .compatible = \"cdns,usb3\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, of_cdns3_match);\n#endif\n\nstatic struct platform_driver cdns3_driver = {\n\t.probe\t\t= cdns3_plat_probe,\n\t.remove_new\t= cdns3_plat_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cdns-usb3\",\n\t\t.of_match_table\t= of_match_ptr(of_cdns3_match),\n\t\t.pm\t= &cdns3_pm_ops,\n\t},\n};\n\nmodule_platform_driver(cdns3_driver);\n\nMODULE_ALIAS(\"platform:cdns3\");\nMODULE_AUTHOR(\"Pawel Laszczak <pawell@cadence.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence USB3 DRD Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}