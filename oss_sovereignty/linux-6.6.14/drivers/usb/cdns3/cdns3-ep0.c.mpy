{
  "module_name": "cdns3-ep0.c",
  "hash_id": "0b7e9f67ca7fa43b3188c9b87c7019cf5c1c5cc686cf588425b313581c255eb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-ep0.c",
  "human_readable_source": "\n \n\n#include <linux/usb/composite.h>\n#include <linux/iopoll.h>\n\n#include \"cdns3-gadget.h\"\n#include \"cdns3-trace.h\"\n\nstatic struct usb_endpoint_descriptor cdns3_gadget_ep0_desc = {\n\t.bLength = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\t.bmAttributes =\tUSB_ENDPOINT_XFER_CONTROL,\n};\n\n \nstatic void cdns3_ep0_run_transfer(struct cdns3_device *priv_dev,\n\t\t\t\t   dma_addr_t dma_addr,\n\t\t\t\t   unsigned int length, int erdy, int zlp)\n{\n\tstruct cdns3_usb_regs __iomem *regs = priv_dev->regs;\n\tstruct cdns3_endpoint *priv_ep = priv_dev->eps[0];\n\n\tpriv_ep->trb_pool[0].buffer = cpu_to_le32(TRB_BUFFER(dma_addr));\n\tpriv_ep->trb_pool[0].length = cpu_to_le32(TRB_LEN(length));\n\n\tif (zlp) {\n\t\tpriv_ep->trb_pool[0].control = cpu_to_le32(TRB_CYCLE | TRB_TYPE(TRB_NORMAL));\n\t\tpriv_ep->trb_pool[1].buffer = cpu_to_le32(TRB_BUFFER(dma_addr));\n\t\tpriv_ep->trb_pool[1].length = cpu_to_le32(TRB_LEN(0));\n\t\tpriv_ep->trb_pool[1].control = cpu_to_le32(TRB_CYCLE | TRB_IOC |\n\t\t    TRB_TYPE(TRB_NORMAL));\n\t} else {\n\t\tpriv_ep->trb_pool[0].control = cpu_to_le32(TRB_CYCLE | TRB_IOC |\n\t\t    TRB_TYPE(TRB_NORMAL));\n\t\tpriv_ep->trb_pool[1].control = 0;\n\t}\n\n\ttrace_cdns3_prepare_trb(priv_ep, priv_ep->trb_pool);\n\n\tcdns3_select_ep(priv_dev, priv_dev->ep0_data_dir);\n\n\twritel(EP_STS_TRBERR, &regs->ep_sts);\n\twritel(EP_TRADDR_TRADDR(priv_ep->trb_pool_dma), &regs->ep_traddr);\n\ttrace_cdns3_doorbell_ep0(priv_dev->ep0_data_dir ? \"ep0in\" : \"ep0out\",\n\t\t\t\t readl(&regs->ep_traddr));\n\n\t \n\twritel(EP_CMD_DRDY, &regs->ep_cmd);\n\n\t \n\t__cdns3_gadget_wakeup(priv_dev);\n\n\tif (erdy)\n\t\twritel(EP_CMD_ERDY, &priv_dev->regs->ep_cmd);\n}\n\n \nstatic int cdns3_ep0_delegate_req(struct cdns3_device *priv_dev,\n\t\t\t\t  struct usb_ctrlrequest *ctrl_req)\n{\n\tint ret;\n\n\tspin_unlock(&priv_dev->lock);\n\tpriv_dev->setup_pending = 1;\n\tret = priv_dev->gadget_driver->setup(&priv_dev->gadget, ctrl_req);\n\tpriv_dev->setup_pending = 0;\n\tspin_lock(&priv_dev->lock);\n\treturn ret;\n}\n\nstatic void cdns3_prepare_setup_packet(struct cdns3_device *priv_dev)\n{\n\tpriv_dev->ep0_data_dir = 0;\n\tpriv_dev->ep0_stage = CDNS3_SETUP_STAGE;\n\tcdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma,\n\t\t\t       sizeof(struct usb_ctrlrequest), 0, 0);\n}\n\nstatic void cdns3_ep0_complete_setup(struct cdns3_device *priv_dev,\n\t\t\t\t     u8 send_stall, u8 send_erdy)\n{\n\tstruct cdns3_endpoint *priv_ep = priv_dev->eps[0];\n\tstruct usb_request *request;\n\n\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\tif (request)\n\t\tlist_del_init(&request->list);\n\n\tif (send_stall) {\n\t\ttrace_cdns3_halt(priv_ep, send_stall, 0);\n\t\t \n\t\tcdns3_select_ep(priv_dev, 0x00);\n\t\twritel(EP_CMD_SSTALL, &priv_dev->regs->ep_cmd);\n\t} else {\n\t\tcdns3_prepare_setup_packet(priv_dev);\n\t}\n\n\tpriv_dev->ep0_stage = CDNS3_SETUP_STAGE;\n\twritel((send_erdy ? EP_CMD_ERDY : 0) | EP_CMD_REQ_CMPL,\n\t       &priv_dev->regs->ep_cmd);\n}\n\n \nstatic int cdns3_req_ep0_set_configuration(struct cdns3_device *priv_dev,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl_req)\n{\n\tenum usb_device_state device_state = priv_dev->gadget.state;\n\tu32 config = le16_to_cpu(ctrl_req->wValue);\n\tint result = 0;\n\n\tswitch (device_state) {\n\tcase USB_STATE_ADDRESS:\n\t\tresult = cdns3_ep0_delegate_req(priv_dev, ctrl_req);\n\n\t\tif (result || !config)\n\t\t\tgoto reset_config;\n\n\t\tbreak;\n\tcase USB_STATE_CONFIGURED:\n\t\tresult = cdns3_ep0_delegate_req(priv_dev, ctrl_req);\n\t\tif (!config && !result)\n\t\t\tgoto reset_config;\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nreset_config:\n\tif (result != USB_GADGET_DELAYED_STATUS)\n\t\tcdns3_hw_reset_eps_config(priv_dev);\n\n\tusb_gadget_set_state(&priv_dev->gadget,\n\t\t\t     USB_STATE_ADDRESS);\n\n\treturn result;\n}\n\n \nstatic int cdns3_req_ep0_set_address(struct cdns3_device *priv_dev,\n\t\t\t\t     struct usb_ctrlrequest *ctrl_req)\n{\n\tenum usb_device_state device_state = priv_dev->gadget.state;\n\tu32 reg;\n\tu32 addr;\n\n\taddr = le16_to_cpu(ctrl_req->wValue);\n\n\tif (addr > USB_DEVICE_MAX_ADDRESS) {\n\t\tdev_err(priv_dev->dev,\n\t\t\t\"Device address (%d) cannot be greater than %d\\n\",\n\t\t\taddr, USB_DEVICE_MAX_ADDRESS);\n\t\treturn -EINVAL;\n\t}\n\n\tif (device_state == USB_STATE_CONFIGURED) {\n\t\tdev_err(priv_dev->dev,\n\t\t\t\"can't set_address from configured state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treg = readl(&priv_dev->regs->usb_cmd);\n\n\twritel(reg | USB_CMD_FADDR(addr) | USB_CMD_SET_ADDR,\n\t       &priv_dev->regs->usb_cmd);\n\n\tusb_gadget_set_state(&priv_dev->gadget,\n\t\t\t     (addr ? USB_STATE_ADDRESS : USB_STATE_DEFAULT));\n\n\treturn 0;\n}\n\n \nstatic int cdns3_req_ep0_get_status(struct cdns3_device *priv_dev,\n\t\t\t\t    struct usb_ctrlrequest *ctrl)\n{\n\tstruct cdns3_endpoint *priv_ep;\n\t__le16 *response_pkt;\n\tu16 usb_status = 0;\n\tu32 recip;\n\tu8 index;\n\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\t \n\t\tif (priv_dev->is_selfpowered)\n\t\t\tusb_status = BIT(USB_DEVICE_SELF_POWERED);\n\n\t\tif (priv_dev->wake_up_flag)\n\t\t\tusb_status |= BIT(USB_DEVICE_REMOTE_WAKEUP);\n\n\t\tif (priv_dev->gadget.speed != USB_SPEED_SUPER)\n\t\t\tbreak;\n\n\t\tif (priv_dev->u1_allowed)\n\t\t\tusb_status |= BIT(USB_DEV_STAT_U1_ENABLED);\n\n\t\tif (priv_dev->u2_allowed)\n\t\t\tusb_status |= BIT(USB_DEV_STAT_U2_ENABLED);\n\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\treturn cdns3_ep0_delegate_req(priv_dev, ctrl);\n\tcase USB_RECIP_ENDPOINT:\n\t\tindex = cdns3_ep_addr_to_index(le16_to_cpu(ctrl->wIndex));\n\t\tpriv_ep = priv_dev->eps[index];\n\n\t\t \n\t\tcdns3_select_ep(priv_dev, le16_to_cpu(ctrl->wIndex));\n\t\tif (EP_STS_STALL(readl(&priv_dev->regs->ep_sts)) ||\n\t\t    (priv_ep->flags & EP_STALL_PENDING))\n\t\t\tusb_status =  BIT(USB_ENDPOINT_HALT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tresponse_pkt = (__le16 *)priv_dev->setup_buf;\n\t*response_pkt = cpu_to_le16(usb_status);\n\n\tcdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma,\n\t\t\t       sizeof(*response_pkt), 1, 0);\n\treturn 0;\n}\n\nstatic int cdns3_ep0_feature_handle_device(struct cdns3_device *priv_dev,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t   int set)\n{\n\tenum usb_device_state state;\n\tenum usb_device_speed speed;\n\tint ret = 0;\n\tu32 wValue;\n\tu16 tmode;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\tstate = priv_dev->gadget.state;\n\tspeed = priv_dev->gadget.speed;\n\n\tswitch (wValue) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tpriv_dev->wake_up_flag = !!set;\n\t\tbreak;\n\tcase USB_DEVICE_U1_ENABLE:\n\t\tif (state != USB_STATE_CONFIGURED || speed != USB_SPEED_SUPER)\n\t\t\treturn -EINVAL;\n\n\t\tpriv_dev->u1_allowed = !!set;\n\t\tbreak;\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tif (state != USB_STATE_CONFIGURED || speed != USB_SPEED_SUPER)\n\t\t\treturn -EINVAL;\n\n\t\tpriv_dev->u2_allowed = !!set;\n\t\tbreak;\n\tcase USB_DEVICE_LTM_ENABLE:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase USB_DEVICE_TEST_MODE:\n\t\tif (state != USB_STATE_CONFIGURED || speed > USB_SPEED_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\ttmode = le16_to_cpu(ctrl->wIndex);\n\n\t\tif (!set || (tmode & 0xff) != 0)\n\t\t\treturn -EINVAL;\n\n\t\ttmode >>= 8;\n\t\tswitch (tmode) {\n\t\tcase USB_TEST_J:\n\t\tcase USB_TEST_K:\n\t\tcase USB_TEST_SE0_NAK:\n\t\tcase USB_TEST_PACKET:\n\t\t\tcdns3_set_register_bit(&priv_dev->regs->usb_cmd,\n\t\t\t\t\t       USB_CMD_STMODE |\n\t\t\t\t\t       USB_STS_TMODE_SEL(tmode - 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns3_ep0_feature_handle_intf(struct cdns3_device *priv_dev,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t int set)\n{\n\tu32 wValue;\n\tint ret = 0;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\n\tswitch (wValue) {\n\tcase USB_INTRF_FUNC_SUSPEND:\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns3_ep0_feature_handle_endpoint(struct cdns3_device *priv_dev,\n\t\t\t\t\t     struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t     int set)\n{\n\tstruct cdns3_endpoint *priv_ep;\n\tint ret = 0;\n\tu8 index;\n\n\tif (le16_to_cpu(ctrl->wValue) != USB_ENDPOINT_HALT)\n\t\treturn -EINVAL;\n\n\tif (!(le16_to_cpu(ctrl->wIndex) & ~USB_DIR_IN))\n\t\treturn 0;\n\n\tindex = cdns3_ep_addr_to_index(le16_to_cpu(ctrl->wIndex));\n\tpriv_ep = priv_dev->eps[index];\n\n\tcdns3_select_ep(priv_dev, le16_to_cpu(ctrl->wIndex));\n\n\tif (set)\n\t\t__cdns3_gadget_ep_set_halt(priv_ep);\n\telse if (!(priv_ep->flags & EP_WEDGE))\n\t\tret = __cdns3_gadget_ep_clear_halt(priv_ep);\n\n\tcdns3_select_ep(priv_dev, 0x00);\n\n\treturn ret;\n}\n\n \nstatic int cdns3_req_ep0_handle_feature(struct cdns3_device *priv_dev,\n\t\t\t\t\tstruct usb_ctrlrequest *ctrl,\n\t\t\t\t\tint set)\n{\n\tint ret = 0;\n\tu32 recip;\n\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tret = cdns3_ep0_feature_handle_device(priv_dev, ctrl, set);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tret = cdns3_ep0_feature_handle_intf(priv_dev, ctrl, set);\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tret = cdns3_ep0_feature_handle_endpoint(priv_dev, ctrl, set);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int cdns3_req_ep0_set_sel(struct cdns3_device *priv_dev,\n\t\t\t\t struct usb_ctrlrequest *ctrl_req)\n{\n\tif (priv_dev->gadget.state < USB_STATE_ADDRESS)\n\t\treturn -EINVAL;\n\n\tif (le16_to_cpu(ctrl_req->wLength) != 6) {\n\t\tdev_err(priv_dev->dev, \"Set SEL should be 6 bytes, got %d\\n\",\n\t\t\tctrl_req->wLength);\n\t\treturn -EINVAL;\n\t}\n\n\tcdns3_ep0_run_transfer(priv_dev, priv_dev->setup_dma, 6, 1, 0);\n\treturn 0;\n}\n\n \nstatic int cdns3_req_ep0_set_isoch_delay(struct cdns3_device *priv_dev,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl_req)\n{\n\tif (ctrl_req->wIndex || ctrl_req->wLength)\n\t\treturn -EINVAL;\n\n\tpriv_dev->isoch_delay = le16_to_cpu(ctrl_req->wValue);\n\n\treturn 0;\n}\n\n \nstatic int cdns3_ep0_standard_request(struct cdns3_device *priv_dev,\n\t\t\t\t      struct usb_ctrlrequest *ctrl_req)\n{\n\tint ret;\n\n\tswitch (ctrl_req->bRequest) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\tret = cdns3_req_ep0_set_address(priv_dev, ctrl_req);\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tret = cdns3_req_ep0_set_configuration(priv_dev, ctrl_req);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tret = cdns3_req_ep0_get_status(priv_dev, ctrl_req);\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tret = cdns3_req_ep0_handle_feature(priv_dev, ctrl_req, 0);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tret = cdns3_req_ep0_handle_feature(priv_dev, ctrl_req, 1);\n\t\tbreak;\n\tcase USB_REQ_SET_SEL:\n\t\tret = cdns3_req_ep0_set_sel(priv_dev, ctrl_req);\n\t\tbreak;\n\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\tret = cdns3_req_ep0_set_isoch_delay(priv_dev, ctrl_req);\n\t\tbreak;\n\tdefault:\n\t\tret = cdns3_ep0_delegate_req(priv_dev, ctrl_req);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void __pending_setup_status_handler(struct cdns3_device *priv_dev)\n{\n\tstruct usb_request *request = priv_dev->pending_status_request;\n\n\tif (priv_dev->status_completion_no_call && request &&\n\t    request->complete) {\n\t\trequest->complete(&priv_dev->eps[0]->endpoint, request);\n\t\tpriv_dev->status_completion_no_call = 0;\n\t}\n}\n\nvoid cdns3_pending_setup_status_handler(struct work_struct *work)\n{\n\tstruct cdns3_device *priv_dev = container_of(work, struct cdns3_device,\n\t\t\tpending_status_wq);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\t__pending_setup_status_handler(priv_dev);\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n}\n\n \nstatic void cdns3_ep0_setup_phase(struct cdns3_device *priv_dev)\n{\n\tstruct usb_ctrlrequest *ctrl = priv_dev->setup_buf;\n\tstruct cdns3_endpoint *priv_ep = priv_dev->eps[0];\n\tint result;\n\n\tpriv_dev->ep0_data_dir = ctrl->bRequestType & USB_DIR_IN;\n\n\ttrace_cdns3_ctrl_req(ctrl);\n\n\tif (!list_empty(&priv_ep->pending_req_list)) {\n\t\tstruct usb_request *request;\n\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\t\tpriv_ep->dir = priv_dev->ep0_data_dir;\n\t\tcdns3_gadget_giveback(priv_ep, to_cdns3_request(request),\n\t\t\t\t      -ECONNRESET);\n\t}\n\n\tif (le16_to_cpu(ctrl->wLength))\n\t\tpriv_dev->ep0_stage = CDNS3_DATA_STAGE;\n\telse\n\t\tpriv_dev->ep0_stage = CDNS3_STATUS_STAGE;\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tresult = cdns3_ep0_standard_request(priv_dev, ctrl);\n\telse\n\t\tresult = cdns3_ep0_delegate_req(priv_dev, ctrl);\n\n\tif (result == USB_GADGET_DELAYED_STATUS)\n\t\treturn;\n\n\tif (result < 0)\n\t\tcdns3_ep0_complete_setup(priv_dev, 1, 1);\n\telse if (priv_dev->ep0_stage == CDNS3_STATUS_STAGE)\n\t\tcdns3_ep0_complete_setup(priv_dev, 0, 1);\n}\n\nstatic void cdns3_transfer_completed(struct cdns3_device *priv_dev)\n{\n\tstruct cdns3_endpoint *priv_ep = priv_dev->eps[0];\n\n\tif (!list_empty(&priv_ep->pending_req_list)) {\n\t\tstruct usb_request *request;\n\n\t\ttrace_cdns3_complete_trb(priv_ep, priv_ep->trb_pool);\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\n\t\trequest->actual =\n\t\t\tTRB_LEN(le32_to_cpu(priv_ep->trb_pool->length));\n\n\t\tpriv_ep->dir = priv_dev->ep0_data_dir;\n\t\tcdns3_gadget_giveback(priv_ep, to_cdns3_request(request), 0);\n\t}\n\n\tcdns3_ep0_complete_setup(priv_dev, 0, 0);\n}\n\n \nstatic bool cdns3_check_new_setup(struct cdns3_device *priv_dev)\n{\n\tu32 ep_sts_reg;\n\n\tcdns3_select_ep(priv_dev, USB_DIR_OUT);\n\tep_sts_reg = readl(&priv_dev->regs->ep_sts);\n\n\treturn !!(ep_sts_reg & (EP_STS_SETUP | EP_STS_STPWAIT));\n}\n\n \nvoid cdns3_check_ep0_interrupt_proceed(struct cdns3_device *priv_dev, int dir)\n{\n\tu32 ep_sts_reg;\n\n\tcdns3_select_ep(priv_dev, dir);\n\n\tep_sts_reg = readl(&priv_dev->regs->ep_sts);\n\twritel(ep_sts_reg, &priv_dev->regs->ep_sts);\n\n\ttrace_cdns3_ep0_irq(priv_dev, ep_sts_reg);\n\n\t__pending_setup_status_handler(priv_dev);\n\n\tif (ep_sts_reg & EP_STS_SETUP)\n\t\tpriv_dev->wait_for_setup = 1;\n\n\tif (priv_dev->wait_for_setup && ep_sts_reg & EP_STS_IOC) {\n\t\tpriv_dev->wait_for_setup = 0;\n\t\tcdns3_ep0_setup_phase(priv_dev);\n\t} else if ((ep_sts_reg & EP_STS_IOC) || (ep_sts_reg & EP_STS_ISP)) {\n\t\tpriv_dev->ep0_data_dir = dir;\n\t\tcdns3_transfer_completed(priv_dev);\n\t}\n\n\tif (ep_sts_reg & EP_STS_DESCMIS) {\n\t\tif (dir == 0 && !priv_dev->setup_pending)\n\t\t\tcdns3_prepare_setup_packet(priv_dev);\n\t}\n}\n\n \nstatic int cdns3_gadget_ep0_enable(struct usb_ep *ep,\n\t\t\t\t   const struct usb_endpoint_descriptor *desc)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int cdns3_gadget_ep0_disable(struct usb_ep *ep)\n{\n\treturn -EINVAL;\n}\n\n \nstatic int cdns3_gadget_ep0_set_halt(struct usb_ep *ep, int value)\n{\n\t \n\treturn 0;\n}\n\n \nstatic int cdns3_gadget_ep0_queue(struct usb_ep *ep,\n\t\t\t\t  struct usb_request *request,\n\t\t\t\t  gfp_t gfp_flags)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tunsigned long flags;\n\tint ret = 0;\n\tu8 zlp = 0;\n\tint i;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\ttrace_cdns3_ep0_queue(priv_dev, request);\n\n\t \n\tif (cdns3_check_new_setup(priv_dev)) {\n\t\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\t\treturn -ECONNRESET;\n\t}\n\n\t \n\tif (priv_dev->ep0_stage == CDNS3_STATUS_STAGE) {\n\t\tu32 val;\n\n\t\tcdns3_select_ep(priv_dev, 0x00);\n\n\t\t \n\t\tfor (i = 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++) {\n\t\t\tpriv_ep = priv_dev->eps[i];\n\t\t\tif (priv_ep && priv_ep->flags & EP_CLAIMED &&\n\t\t\t    !(priv_ep->flags & EP_ENABLED))\n\t\t\t\tcdns3_ep_config(priv_ep, 0);\n\t\t}\n\n\t\tcdns3_set_hw_configuration(priv_dev);\n\t\tcdns3_ep0_complete_setup(priv_dev, 0, 1);\n\t\t \n\t\tret = readl_poll_timeout_atomic(&priv_dev->regs->usb_sts, val,\n\t\t\t\t\t  val & USB_STS_CFGSTS_MASK, 1, 100);\n\t\tif (ret == -ETIMEDOUT)\n\t\t\tdev_warn(priv_dev->dev, \"timeout for waiting configuration set\\n\");\n\n\t\trequest->actual = 0;\n\t\tpriv_dev->status_completion_no_call = true;\n\t\tpriv_dev->pending_status_request = request;\n\t\tusb_gadget_set_state(&priv_dev->gadget, USB_STATE_CONFIGURED);\n\t\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\t\t \n\t\tqueue_work(system_freezable_wq, &priv_dev->pending_status_wq);\n\t\treturn ret;\n\t}\n\n\tif (!list_empty(&priv_ep->pending_req_list)) {\n\t\tdev_err(priv_dev->dev,\n\t\t\t\"can't handle multiple requests for ep0\\n\");\n\t\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tret = usb_gadget_map_request_by_dev(priv_dev->sysdev, request,\n\t\t\t\t\t    priv_dev->ep0_data_dir);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\t\tdev_err(priv_dev->dev, \"failed to map request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trequest->status = -EINPROGRESS;\n\tlist_add_tail(&request->list, &priv_ep->pending_req_list);\n\n\tif (request->zero && request->length &&\n\t    (request->length % ep->maxpacket == 0))\n\t\tzlp = 1;\n\n\tcdns3_ep0_run_transfer(priv_dev, request->dma, request->length, 1, zlp);\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\treturn ret;\n}\n\n \nint cdns3_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tdev_dbg(priv_dev->dev, \"Wedge for %s\\n\", ep->name);\n\tcdns3_gadget_ep_set_halt(ep, 1);\n\tpriv_ep->flags |= EP_WEDGE;\n\n\treturn 0;\n}\n\nstatic const struct usb_ep_ops cdns3_gadget_ep0_ops = {\n\t.enable = cdns3_gadget_ep0_enable,\n\t.disable = cdns3_gadget_ep0_disable,\n\t.alloc_request = cdns3_gadget_ep_alloc_request,\n\t.free_request = cdns3_gadget_ep_free_request,\n\t.queue = cdns3_gadget_ep0_queue,\n\t.dequeue = cdns3_gadget_ep_dequeue,\n\t.set_halt = cdns3_gadget_ep0_set_halt,\n\t.set_wedge = cdns3_gadget_ep_set_wedge,\n};\n\n \nvoid cdns3_ep0_config(struct cdns3_device *priv_dev)\n{\n\tstruct cdns3_usb_regs __iomem *regs;\n\tstruct cdns3_endpoint *priv_ep;\n\tu32 max_packet_size = 64;\n\tu32 ep_cfg;\n\n\tregs = priv_dev->regs;\n\n\tif (priv_dev->gadget.speed == USB_SPEED_SUPER)\n\t\tmax_packet_size = 512;\n\n\tpriv_ep = priv_dev->eps[0];\n\n\tif (!list_empty(&priv_ep->pending_req_list)) {\n\t\tstruct usb_request *request;\n\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\t\tlist_del_init(&request->list);\n\t}\n\n\tpriv_dev->u1_allowed = 0;\n\tpriv_dev->u2_allowed = 0;\n\n\tpriv_dev->gadget.ep0->maxpacket = max_packet_size;\n\tcdns3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(max_packet_size);\n\n\t \n\tcdns3_select_ep(priv_dev, USB_DIR_OUT);\n\n\tif (priv_dev->dev_ver >= DEV_VER_V3) {\n\t\tcdns3_set_register_bit(&priv_dev->regs->dtrans,\n\t\t\t\t       BIT(0) | BIT(16));\n\t\tcdns3_set_register_bit(&priv_dev->regs->tdl_from_trb,\n\t\t\t\t       BIT(0) | BIT(16));\n\t}\n\n\tep_cfg = EP_CFG_ENABLE | EP_CFG_MAXPKTSIZE(max_packet_size);\n\n\tif (!(priv_ep->flags & EP_CONFIGURED))\n\t\twritel(ep_cfg, &regs->ep_cfg);\n\n\twritel(EP_STS_EN_SETUPEN | EP_STS_EN_DESCMISEN | EP_STS_EN_TRBERREN,\n\t       &regs->ep_sts_en);\n\n\t \n\tcdns3_select_ep(priv_dev, USB_DIR_IN);\n\n\tif (!(priv_ep->flags & EP_CONFIGURED))\n\t\twritel(ep_cfg, &regs->ep_cfg);\n\n\tpriv_ep->flags |= EP_CONFIGURED;\n\n\twritel(EP_STS_EN_SETUPEN | EP_STS_EN_TRBERREN, &regs->ep_sts_en);\n\n\tcdns3_set_register_bit(&regs->usb_conf, USB_CONF_U1DS | USB_CONF_U2DS);\n}\n\n \nint cdns3_init_ep0(struct cdns3_device *priv_dev,\n\t\t   struct cdns3_endpoint *priv_ep)\n{\n\tsprintf(priv_ep->name, \"ep0\");\n\n\t \n\tpriv_ep->endpoint.ops = &cdns3_gadget_ep0_ops;\n\tpriv_ep->endpoint.maxburst = 1;\n\tusb_ep_set_maxpacket_limit(&priv_ep->endpoint,\n\t\t\t\t   CDNS3_EP0_MAX_PACKET_LIMIT);\n\tpriv_ep->endpoint.address = 0;\n\tpriv_ep->endpoint.caps.type_control = 1;\n\tpriv_ep->endpoint.caps.dir_in = 1;\n\tpriv_ep->endpoint.caps.dir_out = 1;\n\tpriv_ep->endpoint.name = priv_ep->name;\n\tpriv_ep->endpoint.desc = &cdns3_gadget_ep0_desc;\n\tpriv_dev->gadget.ep0 = &priv_ep->endpoint;\n\tpriv_ep->type = USB_ENDPOINT_XFER_CONTROL;\n\n\treturn cdns3_allocate_trb_pool(priv_ep);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}