{
  "module_name": "cdns3-gadget.c",
  "hash_id": "68cf5b16ab98ec14b8b40187730d9a6125153f70df514c7b2770bebb53c31dc9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-gadget.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/dma-mapping.h>\n#include <linux/usb/gadget.h>\n#include <linux/module.h>\n#include <linux/dmapool.h>\n#include <linux/iopoll.h>\n#include <linux/property.h>\n\n#include \"core.h\"\n#include \"gadget-export.h\"\n#include \"cdns3-gadget.h\"\n#include \"cdns3-trace.h\"\n#include \"drd.h\"\n\nstatic int __cdns3_gadget_ep_queue(struct usb_ep *ep,\n\t\t\t\t   struct usb_request *request,\n\t\t\t\t   gfp_t gfp_flags);\n\nstatic int cdns3_ep_run_transfer(struct cdns3_endpoint *priv_ep,\n\t\t\t\t struct usb_request *request);\n\nstatic int cdns3_ep_run_stream_transfer(struct cdns3_endpoint *priv_ep,\n\t\t\t\t\tstruct usb_request *request);\n\n \nstatic void cdns3_clear_register_bit(void __iomem *ptr, u32 mask)\n{\n\tmask = readl(ptr) & ~mask;\n\twritel(mask, ptr);\n}\n\n \nvoid cdns3_set_register_bit(void __iomem *ptr, u32 mask)\n{\n\tmask = readl(ptr) | mask;\n\twritel(mask, ptr);\n}\n\n \nu8 cdns3_ep_addr_to_index(u8 ep_addr)\n{\n\treturn (((ep_addr & 0x7F)) + ((ep_addr & USB_DIR_IN) ? 16 : 0));\n}\n\nstatic int cdns3_get_dma_pos(struct cdns3_device *priv_dev,\n\t\t\t     struct cdns3_endpoint *priv_ep)\n{\n\tint dma_index;\n\n\tdma_index = readl(&priv_dev->regs->ep_traddr) - priv_ep->trb_pool_dma;\n\n\treturn dma_index / TRB_SIZE;\n}\n\n \nstruct usb_request *cdns3_next_request(struct list_head *list)\n{\n\treturn list_first_entry_or_null(list, struct usb_request, list);\n}\n\n \nstatic struct cdns3_aligned_buf *cdns3_next_align_buf(struct list_head *list)\n{\n\treturn list_first_entry_or_null(list, struct cdns3_aligned_buf, list);\n}\n\n \nstatic struct cdns3_request *cdns3_next_priv_request(struct list_head *list)\n{\n\treturn list_first_entry_or_null(list, struct cdns3_request, list);\n}\n\n \nvoid cdns3_select_ep(struct cdns3_device *priv_dev, u32 ep)\n{\n\tif (priv_dev->selected_ep == ep)\n\t\treturn;\n\n\tpriv_dev->selected_ep = ep;\n\twritel(ep, &priv_dev->regs->ep_sel);\n}\n\n \nstatic int cdns3_get_tdl(struct cdns3_device *priv_dev)\n{\n\tif (priv_dev->dev_ver < DEV_VER_V3)\n\t\treturn EP_CMD_TDL_GET(readl(&priv_dev->regs->ep_cmd));\n\telse\n\t\treturn readl(&priv_dev->regs->ep_tdl);\n}\n\ndma_addr_t cdns3_trb_virt_to_dma(struct cdns3_endpoint *priv_ep,\n\t\t\t\t struct cdns3_trb *trb)\n{\n\tu32 offset = (char *)trb - (char *)priv_ep->trb_pool;\n\n\treturn priv_ep->trb_pool_dma + offset;\n}\n\nstatic void cdns3_free_trb_pool(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tif (priv_ep->trb_pool) {\n\t\tdma_pool_free(priv_dev->eps_dma_pool,\n\t\t\t      priv_ep->trb_pool, priv_ep->trb_pool_dma);\n\t\tpriv_ep->trb_pool = NULL;\n\t}\n}\n\n \nint cdns3_allocate_trb_pool(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tint ring_size = TRB_RING_SIZE;\n\tint num_trbs = ring_size / TRB_SIZE;\n\tstruct cdns3_trb *link_trb;\n\n\tif (priv_ep->trb_pool && priv_ep->alloc_ring_size < ring_size)\n\t\tcdns3_free_trb_pool(priv_ep);\n\n\tif (!priv_ep->trb_pool) {\n\t\tpriv_ep->trb_pool = dma_pool_alloc(priv_dev->eps_dma_pool,\n\t\t\t\t\t\t   GFP_ATOMIC,\n\t\t\t\t\t\t   &priv_ep->trb_pool_dma);\n\n\t\tif (!priv_ep->trb_pool)\n\t\t\treturn -ENOMEM;\n\n\t\tpriv_ep->alloc_ring_size = ring_size;\n\t}\n\n\tmemset(priv_ep->trb_pool, 0, ring_size);\n\n\tpriv_ep->num_trbs = num_trbs;\n\n\tif (!priv_ep->num)\n\t\treturn 0;\n\n\t \n\tlink_trb = (priv_ep->trb_pool + (priv_ep->num_trbs - 1));\n\n\tif (priv_ep->use_streams) {\n\t\t \n\t\tlink_trb->control = 0;\n\t} else {\n\t\tlink_trb->buffer = cpu_to_le32(TRB_BUFFER(priv_ep->trb_pool_dma));\n\t\tlink_trb->control = cpu_to_le32(TRB_CYCLE | TRB_TYPE(TRB_LINK) | TRB_TOGGLE);\n\t}\n\treturn 0;\n}\n\n \nstatic void cdns3_ep_stall_flush(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tint val;\n\n\ttrace_cdns3_halt(priv_ep, 1, 1);\n\n\twritel(EP_CMD_DFLUSH | EP_CMD_ERDY | EP_CMD_SSTALL,\n\t       &priv_dev->regs->ep_cmd);\n\n\t \n\treadl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t  !(val & EP_CMD_DFLUSH), 1, 1000);\n\tpriv_ep->flags |= EP_STALLED;\n\tpriv_ep->flags &= ~EP_STALL_PENDING;\n}\n\n \nvoid cdns3_hw_reset_eps_config(struct cdns3_device *priv_dev)\n{\n\tint i;\n\n\twritel(USB_CONF_CFGRST, &priv_dev->regs->usb_conf);\n\n\tcdns3_allow_enable_l1(priv_dev, 0);\n\tpriv_dev->hw_configured_flag = 0;\n\tpriv_dev->onchip_used_size = 0;\n\tpriv_dev->out_mem_is_allocated = 0;\n\tpriv_dev->wait_for_setup = 0;\n\tpriv_dev->using_streams = 0;\n\n\tfor (i = 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++)\n\t\tif (priv_dev->eps[i])\n\t\t\tpriv_dev->eps[i]->flags &= ~EP_CONFIGURED;\n}\n\n \nstatic void cdns3_ep_inc_trb(int *index, u8 *cs, int trb_in_seg)\n{\n\t(*index)++;\n\tif (*index == (trb_in_seg - 1)) {\n\t\t*index = 0;\n\t\t*cs ^=  1;\n\t}\n}\n\n \nstatic void cdns3_ep_inc_enq(struct cdns3_endpoint *priv_ep)\n{\n\tpriv_ep->free_trbs--;\n\tcdns3_ep_inc_trb(&priv_ep->enqueue, &priv_ep->pcs, priv_ep->num_trbs);\n}\n\n \nstatic void cdns3_ep_inc_deq(struct cdns3_endpoint *priv_ep)\n{\n\tpriv_ep->free_trbs++;\n\tcdns3_ep_inc_trb(&priv_ep->dequeue, &priv_ep->ccs, priv_ep->num_trbs);\n}\n\n \nvoid cdns3_allow_enable_l1(struct cdns3_device *priv_dev, int enable)\n{\n\tif (enable)\n\t\twritel(USB_CONF_L1EN, &priv_dev->regs->usb_conf);\n\telse\n\t\twritel(USB_CONF_L1DS, &priv_dev->regs->usb_conf);\n}\n\nenum usb_device_speed cdns3_get_speed(struct cdns3_device *priv_dev)\n{\n\tu32 reg;\n\n\treg = readl(&priv_dev->regs->usb_sts);\n\n\tif (DEV_SUPERSPEED(reg))\n\t\treturn USB_SPEED_SUPER;\n\telse if (DEV_HIGHSPEED(reg))\n\t\treturn USB_SPEED_HIGH;\n\telse if (DEV_FULLSPEED(reg))\n\t\treturn USB_SPEED_FULL;\n\telse if (DEV_LOWSPEED(reg))\n\t\treturn USB_SPEED_LOW;\n\treturn USB_SPEED_UNKNOWN;\n}\n\n \nstatic int cdns3_start_all_request(struct cdns3_device *priv_dev,\n\t\t\t\t   struct cdns3_endpoint *priv_ep)\n{\n\tstruct usb_request *request;\n\tint ret = 0;\n\tu8 pending_empty = list_empty(&priv_ep->pending_req_list);\n\n\t \n\tif (!pending_empty) {\n\t\tstruct cdns3_request *priv_req;\n\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\t\tpriv_req = to_cdns3_request(request);\n\t\tif ((priv_req->flags & REQUEST_INTERNAL) ||\n\t\t    (priv_ep->flags & EP_TDLCHK_EN) ||\n\t\t\tpriv_ep->use_streams) {\n\t\t\tdev_dbg(priv_dev->dev, \"Blocking external request\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\twhile (!list_empty(&priv_ep->deferred_req_list)) {\n\t\trequest = cdns3_next_request(&priv_ep->deferred_req_list);\n\n\t\tif (!priv_ep->use_streams) {\n\t\t\tret = cdns3_ep_run_transfer(priv_ep, request);\n\t\t} else {\n\t\t\tpriv_ep->stream_sg_idx = 0;\n\t\t\tret = cdns3_ep_run_stream_transfer(priv_ep, request);\n\t\t}\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tlist_move_tail(&request->list, &priv_ep->pending_req_list);\n\t\tif (request->stream_id != 0 || (priv_ep->flags & EP_TDLCHK_EN))\n\t\t\tbreak;\n\t}\n\n\tpriv_ep->flags &= ~EP_RING_FULL;\n\treturn ret;\n}\n\n \n#define cdns3_wa2_enable_detection(priv_dev, priv_ep, reg) do { \\\n\tif (!priv_ep->dir && priv_ep->type != USB_ENDPOINT_XFER_ISOC) { \\\n\t\tpriv_ep->flags |= EP_QUIRK_EXTRA_BUF_DET; \\\n\t\t(reg) |= EP_STS_EN_DESCMISEN; \\\n\t} } while (0)\n\nstatic void __cdns3_descmiss_copy_data(struct usb_request *request,\n\tstruct usb_request *descmiss_req)\n{\n\tint length = request->actual + descmiss_req->actual;\n\tstruct scatterlist *s = request->sg;\n\n\tif (!s) {\n\t\tif (length <= request->length) {\n\t\t\tmemcpy(&((u8 *)request->buf)[request->actual],\n\t\t\t       descmiss_req->buf,\n\t\t\t       descmiss_req->actual);\n\t\t\trequest->actual = length;\n\t\t} else {\n\t\t\t \n\t\t\trequest->status = -ENOMEM;\n\t\t}\n\t} else {\n\t\tif (length <= sg_dma_len(s)) {\n\t\t\tvoid *p = phys_to_virt(sg_dma_address(s));\n\n\t\t\tmemcpy(&((u8 *)p)[request->actual],\n\t\t\t\tdescmiss_req->buf,\n\t\t\t\tdescmiss_req->actual);\n\t\t\trequest->actual = length;\n\t\t} else {\n\t\t\trequest->status = -ENOMEM;\n\t\t}\n\t}\n}\n\n \nstatic void cdns3_wa2_descmiss_copy_data(struct cdns3_endpoint *priv_ep,\n\t\t\t\t\t struct usb_request *request)\n{\n\tstruct usb_request *descmiss_req;\n\tstruct cdns3_request *descmiss_priv_req;\n\n\twhile (!list_empty(&priv_ep->wa2_descmiss_req_list)) {\n\t\tint chunk_end;\n\n\t\tdescmiss_priv_req =\n\t\t\tcdns3_next_priv_request(&priv_ep->wa2_descmiss_req_list);\n\t\tdescmiss_req = &descmiss_priv_req->request;\n\n\t\t \n\t\tif (descmiss_priv_req->flags & REQUEST_PENDING)\n\t\t\tbreak;\n\n\t\tchunk_end = descmiss_priv_req->flags & REQUEST_INTERNAL_CH;\n\t\trequest->status = descmiss_req->status;\n\t\t__cdns3_descmiss_copy_data(request, descmiss_req);\n\t\tlist_del_init(&descmiss_priv_req->list);\n\t\tkfree(descmiss_req->buf);\n\t\tcdns3_gadget_ep_free_request(&priv_ep->endpoint, descmiss_req);\n\t\t--priv_ep->wa2_counter;\n\n\t\tif (!chunk_end)\n\t\t\tbreak;\n\t}\n}\n\nstatic struct usb_request *cdns3_wa2_gadget_giveback(struct cdns3_device *priv_dev,\n\t\t\t\t\t\t     struct cdns3_endpoint *priv_ep,\n\t\t\t\t\t\t     struct cdns3_request *priv_req)\n{\n\tif (priv_ep->flags & EP_QUIRK_EXTRA_BUF_EN &&\n\t    priv_req->flags & REQUEST_INTERNAL) {\n\t\tstruct usb_request *req;\n\n\t\treq = cdns3_next_request(&priv_ep->deferred_req_list);\n\n\t\tpriv_ep->descmis_req = NULL;\n\n\t\tif (!req)\n\t\t\treturn NULL;\n\n\t\t \n\t\tusb_gadget_unmap_request_by_dev(priv_dev->sysdev, req,\n\t\t\t\t\t\tpriv_ep->dir);\n\n\t\tcdns3_wa2_descmiss_copy_data(priv_ep, req);\n\t\tif (!(priv_ep->flags & EP_QUIRK_END_TRANSFER) &&\n\t\t    req->length != req->actual) {\n\t\t\t \n\t\t\t \n\t\t\tusb_gadget_map_request_by_dev(priv_dev->sysdev, req,\n\t\t\t\tusb_endpoint_dir_in(priv_ep->endpoint.desc));\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (req->status == -EINPROGRESS)\n\t\t\treq->status = 0;\n\n\t\tlist_del_init(&req->list);\n\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t\treturn req;\n\t}\n\n\treturn &priv_req->request;\n}\n\nstatic int cdns3_wa2_gadget_ep_queue(struct cdns3_device *priv_dev,\n\t\t\t\t     struct cdns3_endpoint *priv_ep,\n\t\t\t\t     struct cdns3_request *priv_req)\n{\n\tint deferred = 0;\n\n\t \n\tif (priv_ep->flags & EP_QUIRK_EXTRA_BUF_DET) {\n\t\tu32 reg;\n\n\t\tcdns3_select_ep(priv_dev, priv_ep->num | priv_ep->dir);\n\t\tpriv_ep->flags &= ~EP_QUIRK_EXTRA_BUF_DET;\n\t\treg = readl(&priv_dev->regs->ep_sts_en);\n\t\treg &= ~EP_STS_EN_DESCMISEN;\n\t\ttrace_cdns3_wa2(priv_ep, \"workaround disabled\\n\");\n\t\twritel(reg, &priv_dev->regs->ep_sts_en);\n\t}\n\n\tif (priv_ep->flags & EP_QUIRK_EXTRA_BUF_EN) {\n\t\tu8 pending_empty = list_empty(&priv_ep->pending_req_list);\n\t\tu8 descmiss_empty = list_empty(&priv_ep->wa2_descmiss_req_list);\n\n\t\t \n\t\tif (pending_empty && !descmiss_empty &&\n\t\t    !(priv_req->flags & REQUEST_INTERNAL)) {\n\t\t\tcdns3_wa2_descmiss_copy_data(priv_ep,\n\t\t\t\t\t\t     &priv_req->request);\n\n\t\t\ttrace_cdns3_wa2(priv_ep, \"get internal stored data\");\n\n\t\t\tlist_add_tail(&priv_req->request.list,\n\t\t\t\t      &priv_ep->pending_req_list);\n\t\t\tcdns3_gadget_giveback(priv_ep, priv_req,\n\t\t\t\t\t      priv_req->request.status);\n\n\t\t\t \n\t\t\treturn EINPROGRESS;\n\t\t}\n\n\t\t \n\t\tif (!pending_empty && !descmiss_empty) {\n\t\t\ttrace_cdns3_wa2(priv_ep, \"wait for pending transfer\\n\");\n\t\t\tdeferred = 1;\n\t\t}\n\n\t\tif (priv_req->flags & REQUEST_INTERNAL)\n\t\t\tlist_add_tail(&priv_req->list,\n\t\t\t\t      &priv_ep->wa2_descmiss_req_list);\n\t}\n\n\treturn deferred;\n}\n\nstatic void cdns3_wa2_remove_old_request(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_request *priv_req;\n\n\twhile (!list_empty(&priv_ep->wa2_descmiss_req_list)) {\n\t\tu8 chain;\n\n\t\tpriv_req = cdns3_next_priv_request(&priv_ep->wa2_descmiss_req_list);\n\t\tchain = !!(priv_req->flags & REQUEST_INTERNAL_CH);\n\n\t\ttrace_cdns3_wa2(priv_ep, \"removes eldest request\");\n\n\t\tkfree(priv_req->request.buf);\n\t\tlist_del_init(&priv_req->list);\n\t\tcdns3_gadget_ep_free_request(&priv_ep->endpoint,\n\t\t\t\t\t     &priv_req->request);\n\t\t--priv_ep->wa2_counter;\n\n\t\tif (!chain)\n\t\t\tbreak;\n\t}\n}\n\n \nstatic void cdns3_wa2_descmissing_packet(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_request *priv_req;\n\tstruct usb_request *request;\n\tu8 pending_empty = list_empty(&priv_ep->pending_req_list);\n\n\t \n\tif (!pending_empty) {\n\t\ttrace_cdns3_wa2(priv_ep, \"Ignoring Descriptor missing IRQ\\n\");\n\t\treturn;\n\t}\n\n\tif (priv_ep->flags & EP_QUIRK_EXTRA_BUF_DET) {\n\t\tpriv_ep->flags &= ~EP_QUIRK_EXTRA_BUF_DET;\n\t\tpriv_ep->flags |= EP_QUIRK_EXTRA_BUF_EN;\n\t}\n\n\ttrace_cdns3_wa2(priv_ep, \"Description Missing detected\\n\");\n\n\tif (priv_ep->wa2_counter >= CDNS3_WA2_NUM_BUFFERS) {\n\t\ttrace_cdns3_wa2(priv_ep, \"WA2 overflow\\n\");\n\t\tcdns3_wa2_remove_old_request(priv_ep);\n\t}\n\n\trequest = cdns3_gadget_ep_alloc_request(&priv_ep->endpoint,\n\t\t\t\t\t\tGFP_ATOMIC);\n\tif (!request)\n\t\tgoto err;\n\n\tpriv_req = to_cdns3_request(request);\n\tpriv_req->flags |= REQUEST_INTERNAL;\n\n\t \n\tif (priv_ep->descmis_req)\n\t\tpriv_ep->descmis_req->flags |= REQUEST_INTERNAL_CH;\n\n\tpriv_req->request.buf = kzalloc(CDNS3_DESCMIS_BUF_SIZE,\n\t\t\t\t\tGFP_ATOMIC);\n\tpriv_ep->wa2_counter++;\n\n\tif (!priv_req->request.buf) {\n\t\tcdns3_gadget_ep_free_request(&priv_ep->endpoint, request);\n\t\tgoto err;\n\t}\n\n\tpriv_req->request.length = CDNS3_DESCMIS_BUF_SIZE;\n\tpriv_ep->descmis_req = priv_req;\n\n\t__cdns3_gadget_ep_queue(&priv_ep->endpoint,\n\t\t\t\t&priv_ep->descmis_req->request,\n\t\t\t\tGFP_ATOMIC);\n\n\treturn;\n\nerr:\n\tdev_err(priv_ep->cdns3_dev->dev,\n\t\t\"Failed: No sufficient memory for DESCMIS\\n\");\n}\n\nstatic void cdns3_wa2_reset_tdl(struct cdns3_device *priv_dev)\n{\n\tu16 tdl = EP_CMD_TDL_GET(readl(&priv_dev->regs->ep_cmd));\n\n\tif (tdl) {\n\t\tu16 reset_val = EP_CMD_TDL_MAX + 1 - tdl;\n\n\t\twritel(EP_CMD_TDL_SET(reset_val) | EP_CMD_STDL,\n\t\t       &priv_dev->regs->ep_cmd);\n\t}\n}\n\nstatic void cdns3_wa2_check_outq_status(struct cdns3_device *priv_dev)\n{\n\tu32 ep_sts_reg;\n\n\t \n\tcdns3_select_ep(priv_dev, 0);\n\n\tep_sts_reg = readl(&priv_dev->regs->ep_sts);\n\n\tif (EP_STS_OUTQ_VAL(ep_sts_reg)) {\n\t\tu32 outq_ep_num = EP_STS_OUTQ_NO(ep_sts_reg);\n\t\tstruct cdns3_endpoint *outq_ep = priv_dev->eps[outq_ep_num];\n\n\t\tif ((outq_ep->flags & EP_ENABLED) && !(outq_ep->use_streams) &&\n\t\t    outq_ep->type != USB_ENDPOINT_XFER_ISOC && outq_ep_num) {\n\t\t\tu8 pending_empty = list_empty(&outq_ep->pending_req_list);\n\n\t\t\tif ((outq_ep->flags & EP_QUIRK_EXTRA_BUF_DET) ||\n\t\t\t    (outq_ep->flags & EP_QUIRK_EXTRA_BUF_EN) ||\n\t\t\t    !pending_empty) {\n\t\t\t} else {\n\t\t\t\tu32 ep_sts_en_reg;\n\t\t\t\tu32 ep_cmd_reg;\n\n\t\t\t\tcdns3_select_ep(priv_dev, outq_ep->num |\n\t\t\t\t\t\toutq_ep->dir);\n\t\t\t\tep_sts_en_reg = readl(&priv_dev->regs->ep_sts_en);\n\t\t\t\tep_cmd_reg = readl(&priv_dev->regs->ep_cmd);\n\n\t\t\t\toutq_ep->flags |= EP_TDLCHK_EN;\n\t\t\t\tcdns3_set_register_bit(&priv_dev->regs->ep_cfg,\n\t\t\t\t\t\t       EP_CFG_TDL_CHK);\n\n\t\t\t\tcdns3_wa2_enable_detection(priv_dev, outq_ep,\n\t\t\t\t\t\t\t   ep_sts_en_reg);\n\t\t\t\twritel(ep_sts_en_reg,\n\t\t\t\t       &priv_dev->regs->ep_sts_en);\n\t\t\t\t \n\t\t\t\tcdns3_wa2_reset_tdl(priv_dev);\n\t\t\t\t \n\t\t\t\twmb();\n\t\t\t\tif (EP_CMD_DRDY & ep_cmd_reg) {\n\t\t\t\t\ttrace_cdns3_wa2(outq_ep, \"Enabling WA2 skipping doorbell\\n\");\n\n\t\t\t\t} else {\n\t\t\t\t\ttrace_cdns3_wa2(outq_ep, \"Enabling WA2 ringing doorbell\\n\");\n\t\t\t\t\t \n\t\t\t\t\twritel(EP_CMD_DRDY,\n\t\t\t\t\t       &priv_dev->regs->ep_cmd);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nvoid cdns3_gadget_giveback(struct cdns3_endpoint *priv_ep,\n\t\t\t   struct cdns3_request *priv_req,\n\t\t\t   int status)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct usb_request *request = &priv_req->request;\n\n\tlist_del_init(&request->list);\n\n\tif (request->status == -EINPROGRESS)\n\t\trequest->status = status;\n\n\tif (likely(!(priv_req->flags & REQUEST_UNALIGNED)))\n\t\tusb_gadget_unmap_request_by_dev(priv_dev->sysdev, request,\n\t\t\t\t\tpriv_ep->dir);\n\n\tif ((priv_req->flags & REQUEST_UNALIGNED) &&\n\t    priv_ep->dir == USB_DIR_OUT && !request->status) {\n\t\t \n\t\tdma_sync_single_for_cpu(priv_dev->sysdev,\n\t\t\tpriv_req->aligned_buf->dma,\n\t\t\trequest->actual,\n\t\t\tpriv_req->aligned_buf->dir);\n\t\tmemcpy(request->buf, priv_req->aligned_buf->buf,\n\t\t       request->actual);\n\t}\n\n\tpriv_req->flags &= ~(REQUEST_PENDING | REQUEST_UNALIGNED);\n\t \n\tpriv_req->finished_trb = 0;\n\ttrace_cdns3_gadget_giveback(priv_req);\n\n\tif (priv_dev->dev_ver < DEV_VER_V2) {\n\t\trequest = cdns3_wa2_gadget_giveback(priv_dev, priv_ep,\n\t\t\t\t\t\t    priv_req);\n\t\tif (!request)\n\t\t\treturn;\n\t}\n\n\tif (request->complete) {\n\t\tspin_unlock(&priv_dev->lock);\n\t\tusb_gadget_giveback_request(&priv_ep->endpoint,\n\t\t\t\t\t    request);\n\t\tspin_lock(&priv_dev->lock);\n\t}\n\n\tif (request->buf == priv_dev->zlp_buf)\n\t\tcdns3_gadget_ep_free_request(&priv_ep->endpoint, request);\n}\n\nstatic void cdns3_wa1_restore_cycle_bit(struct cdns3_endpoint *priv_ep)\n{\n\t \n\tif (priv_ep->wa1_set) {\n\t\ttrace_cdns3_wa1(priv_ep, \"restore cycle bit\");\n\n\t\tpriv_ep->wa1_set = 0;\n\t\tpriv_ep->wa1_trb_index = 0xFFFF;\n\t\tif (priv_ep->wa1_cycle_bit) {\n\t\t\tpriv_ep->wa1_trb->control =\n\t\t\t\tpriv_ep->wa1_trb->control | cpu_to_le32(0x1);\n\t\t} else {\n\t\t\tpriv_ep->wa1_trb->control =\n\t\t\t\tpriv_ep->wa1_trb->control & cpu_to_le32(~0x1);\n\t\t}\n\t}\n}\n\nstatic void cdns3_free_aligned_request_buf(struct work_struct *work)\n{\n\tstruct cdns3_device *priv_dev = container_of(work, struct cdns3_device,\n\t\t\t\t\taligned_buf_wq);\n\tstruct cdns3_aligned_buf *buf, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\tlist_for_each_entry_safe(buf, tmp, &priv_dev->aligned_buf_list, list) {\n\t\tif (!buf->in_use) {\n\t\t\tlist_del(&buf->list);\n\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\t\t\tdma_free_noncoherent(priv_dev->sysdev, buf->size,\n\t\t\t\t\t  buf->buf, buf->dma, buf->dir);\n\t\t\tkfree(buf);\n\t\t\tspin_lock_irqsave(&priv_dev->lock, flags);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n}\n\nstatic int cdns3_prepare_aligned_request_buf(struct cdns3_request *priv_req)\n{\n\tstruct cdns3_endpoint *priv_ep = priv_req->priv_ep;\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct cdns3_aligned_buf *buf;\n\n\t \n\tif (!((uintptr_t)priv_req->request.buf & 0x7))\n\t\treturn 0;\n\n\tbuf = priv_req->aligned_buf;\n\n\tif (!buf || priv_req->request.length > buf->size) {\n\t\tbuf = kzalloc(sizeof(*buf), GFP_ATOMIC);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\n\t\tbuf->size = priv_req->request.length;\n\t\tbuf->dir = usb_endpoint_dir_in(priv_ep->endpoint.desc) ?\n\t\t\tDMA_TO_DEVICE : DMA_FROM_DEVICE;\n\n\t\tbuf->buf = dma_alloc_noncoherent(priv_dev->sysdev,\n\t\t\t\t\t      buf->size,\n\t\t\t\t\t      &buf->dma,\n\t\t\t\t\t      buf->dir,\n\t\t\t\t\t      GFP_ATOMIC);\n\t\tif (!buf->buf) {\n\t\t\tkfree(buf);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (priv_req->aligned_buf) {\n\t\t\ttrace_cdns3_free_aligned_request(priv_req);\n\t\t\tpriv_req->aligned_buf->in_use = 0;\n\t\t\tqueue_work(system_freezable_wq,\n\t\t\t\t   &priv_dev->aligned_buf_wq);\n\t\t}\n\n\t\tbuf->in_use = 1;\n\t\tpriv_req->aligned_buf = buf;\n\n\t\tlist_add_tail(&buf->list,\n\t\t\t      &priv_dev->aligned_buf_list);\n\t}\n\n\tif (priv_ep->dir == USB_DIR_IN) {\n\t\t \n\t\tdma_sync_single_for_cpu(priv_dev->sysdev,\n\t\t\tbuf->dma, buf->size, buf->dir);\n\t\tmemcpy(buf->buf, priv_req->request.buf,\n\t\t       priv_req->request.length);\n\t}\n\n\t \n\tdma_sync_single_for_device(priv_dev->sysdev,\n\t\t\tbuf->dma, buf->size, buf->dir);\n\n\tpriv_req->flags |= REQUEST_UNALIGNED;\n\ttrace_cdns3_prepare_aligned_request(priv_req);\n\n\treturn 0;\n}\n\nstatic int cdns3_wa1_update_guard(struct cdns3_endpoint *priv_ep,\n\t\t\t\t  struct cdns3_trb *trb)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tif (!priv_ep->wa1_set) {\n\t\tu32 doorbell;\n\n\t\tdoorbell = !!(readl(&priv_dev->regs->ep_cmd) & EP_CMD_DRDY);\n\n\t\tif (doorbell) {\n\t\t\tpriv_ep->wa1_cycle_bit = priv_ep->pcs ? TRB_CYCLE : 0;\n\t\t\tpriv_ep->wa1_set = 1;\n\t\t\tpriv_ep->wa1_trb = trb;\n\t\t\tpriv_ep->wa1_trb_index = priv_ep->enqueue;\n\t\t\ttrace_cdns3_wa1(priv_ep, \"set guard\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic void cdns3_wa1_tray_restore_cycle_bit(struct cdns3_device *priv_dev,\n\t\t\t\t\t     struct cdns3_endpoint *priv_ep)\n{\n\tint dma_index;\n\tu32 doorbell;\n\n\tdoorbell = !!(readl(&priv_dev->regs->ep_cmd) & EP_CMD_DRDY);\n\tdma_index = cdns3_get_dma_pos(priv_dev, priv_ep);\n\n\tif (!doorbell || dma_index != priv_ep->wa1_trb_index)\n\t\tcdns3_wa1_restore_cycle_bit(priv_ep);\n}\n\nstatic int cdns3_ep_run_stream_transfer(struct cdns3_endpoint *priv_ep,\n\t\t\t\t\tstruct usb_request *request)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct cdns3_request *priv_req;\n\tstruct cdns3_trb *trb;\n\tdma_addr_t trb_dma;\n\tint address;\n\tu32 control;\n\tu32 length;\n\tu32 tdl;\n\tunsigned int sg_idx = priv_ep->stream_sg_idx;\n\n\tpriv_req = to_cdns3_request(request);\n\taddress = priv_ep->endpoint.desc->bEndpointAddress;\n\n\tpriv_ep->flags |= EP_PENDING_REQUEST;\n\n\t \n\tif (priv_req->flags & REQUEST_UNALIGNED)\n\t\ttrb_dma = priv_req->aligned_buf->dma;\n\telse\n\t\ttrb_dma = request->dma;\n\n\t \n\ttrb = priv_ep->trb_pool + priv_ep->enqueue;\n\tpriv_req->start_trb = priv_ep->enqueue;\n\tpriv_req->end_trb = priv_req->start_trb;\n\tpriv_req->trb = trb;\n\n\tcdns3_select_ep(priv_ep->cdns3_dev, address);\n\n\tcontrol = TRB_TYPE(TRB_NORMAL) | TRB_CYCLE |\n\t\t  TRB_STREAM_ID(priv_req->request.stream_id) | TRB_ISP;\n\n\tif (!request->num_sgs) {\n\t\ttrb->buffer = cpu_to_le32(TRB_BUFFER(trb_dma));\n\t\tlength = request->length;\n\t} else {\n\t\ttrb->buffer = cpu_to_le32(TRB_BUFFER(request->sg[sg_idx].dma_address));\n\t\tlength = request->sg[sg_idx].length;\n\t}\n\n\ttdl = DIV_ROUND_UP(length, priv_ep->endpoint.maxpacket);\n\n\ttrb->length = cpu_to_le32(TRB_BURST_LEN(16) | TRB_LEN(length));\n\n\t \n\tif (priv_dev->dev_ver >= DEV_VER_V2) {\n\t\tif (priv_dev->gadget.speed == USB_SPEED_SUPER)\n\t\t\ttrb->length |= cpu_to_le32(TRB_TDL_SS_SIZE(tdl));\n\t}\n\tpriv_req->flags |= REQUEST_PENDING;\n\n\ttrb->control = cpu_to_le32(control);\n\n\ttrace_cdns3_prepare_trb(priv_ep, priv_req->trb);\n\n\t \n\twmb();\n\n\t \n\twritel(EP_TRADDR_TRADDR(priv_ep->trb_pool_dma),\n\t       &priv_dev->regs->ep_traddr);\n\n\tif (!(priv_ep->flags & EP_STALLED)) {\n\t\ttrace_cdns3_ring(priv_ep);\n\t\t \n\t\twritel(EP_STS_TRBERR | EP_STS_DESCMIS, &priv_dev->regs->ep_sts);\n\n\t\tpriv_ep->prime_flag = false;\n\n\t\t \n\n\t\tif (priv_dev->dev_ver < DEV_VER_V2)\n\t\t\twritel(EP_CMD_TDL_SET(tdl) | EP_CMD_STDL,\n\t\t\t       &priv_dev->regs->ep_cmd);\n\t\telse if (priv_dev->dev_ver > DEV_VER_V2)\n\t\t\twritel(tdl, &priv_dev->regs->ep_tdl);\n\n\t\tpriv_ep->last_stream_id = priv_req->request.stream_id;\n\t\twritel(EP_CMD_DRDY, &priv_dev->regs->ep_cmd);\n\t\twritel(EP_CMD_ERDY_SID(priv_req->request.stream_id) |\n\t\t       EP_CMD_ERDY, &priv_dev->regs->ep_cmd);\n\n\t\ttrace_cdns3_doorbell_epx(priv_ep->name,\n\t\t\t\t\t readl(&priv_dev->regs->ep_traddr));\n\t}\n\n\t \n\t__cdns3_gadget_wakeup(priv_dev);\n\n\treturn 0;\n}\n\nstatic void cdns3_rearm_drdy_if_needed(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tif (priv_dev->dev_ver < DEV_VER_V3)\n\t\treturn;\n\n\tif (readl(&priv_dev->regs->ep_sts) & EP_STS_TRBERR) {\n\t\twritel(EP_STS_TRBERR, &priv_dev->regs->ep_sts);\n\t\twritel(EP_CMD_DRDY, &priv_dev->regs->ep_cmd);\n\t}\n}\n\n \nstatic int cdns3_ep_run_transfer(struct cdns3_endpoint *priv_ep,\n\t\t\t\t struct usb_request *request)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct cdns3_request *priv_req;\n\tstruct cdns3_trb *trb;\n\tstruct cdns3_trb *link_trb = NULL;\n\tdma_addr_t trb_dma;\n\tu32 togle_pcs = 1;\n\tint sg_iter = 0;\n\tint num_trb_req;\n\tint trb_burst;\n\tint num_trb;\n\tint address;\n\tu32 control;\n\tint pcs;\n\tu16 total_tdl = 0;\n\tstruct scatterlist *s = NULL;\n\tbool sg_supported = !!(request->num_mapped_sgs);\n\n\tnum_trb_req = sg_supported ? request->num_mapped_sgs : 1;\n\n\t \n\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\tnum_trb = priv_ep->interval * num_trb_req;\n\telse\n\t\tnum_trb = num_trb_req;\n\n\tpriv_req = to_cdns3_request(request);\n\taddress = priv_ep->endpoint.desc->bEndpointAddress;\n\n\tpriv_ep->flags |= EP_PENDING_REQUEST;\n\n\t \n\tif (priv_req->flags & REQUEST_UNALIGNED)\n\t\ttrb_dma = priv_req->aligned_buf->dma;\n\telse\n\t\ttrb_dma = request->dma;\n\n\ttrb = priv_ep->trb_pool + priv_ep->enqueue;\n\tpriv_req->start_trb = priv_ep->enqueue;\n\tpriv_req->trb = trb;\n\n\tcdns3_select_ep(priv_ep->cdns3_dev, address);\n\n\t \n\tif ((priv_ep->enqueue + num_trb)  >= (priv_ep->num_trbs - 1)) {\n\t\tint doorbell, dma_index;\n\t\tu32 ch_bit = 0;\n\n\t\tdoorbell = !!(readl(&priv_dev->regs->ep_cmd) & EP_CMD_DRDY);\n\t\tdma_index = cdns3_get_dma_pos(priv_dev, priv_ep);\n\n\t\t \n\t\tif (doorbell && dma_index == priv_ep->num_trbs - 1) {\n\t\t\tpriv_ep->flags |= EP_DEFERRED_DRDY;\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\t \n\t\tlink_trb = priv_ep->trb_pool + (priv_ep->num_trbs - 1);\n\t\t \n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC ||\n\t\t    TRBS_PER_SEGMENT > 2)\n\t\t\tch_bit = TRB_CHAIN;\n\n\t\tlink_trb->control = cpu_to_le32(((priv_ep->pcs) ? TRB_CYCLE : 0) |\n\t\t\t\t    TRB_TYPE(TRB_LINK) | TRB_TOGGLE | ch_bit);\n\n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\t \n\t\t\twhile (priv_ep->enqueue) {\n\t\t\t\t*trb = *link_trb;\n\t\t\t\ttrace_cdns3_prepare_trb(priv_ep, trb);\n\n\t\t\t\tcdns3_ep_inc_enq(priv_ep);\n\t\t\t\ttrb = priv_ep->trb_pool + priv_ep->enqueue;\n\t\t\t\tpriv_req->trb = trb;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (num_trb > priv_ep->free_trbs) {\n\t\tpriv_ep->flags |= EP_RING_FULL;\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (priv_dev->dev_ver <= DEV_VER_V2)\n\t\ttogle_pcs = cdns3_wa1_update_guard(priv_ep, trb);\n\n\t \n\tcontrol = priv_ep->pcs ? 0 : TRB_CYCLE;\n\ttrb->length = 0;\n\tif (priv_dev->dev_ver >= DEV_VER_V2) {\n\t\tu16 td_size;\n\n\t\ttd_size = DIV_ROUND_UP(request->length,\n\t\t\t\t       priv_ep->endpoint.maxpacket);\n\t\tif (priv_dev->gadget.speed == USB_SPEED_SUPER)\n\t\t\ttrb->length = cpu_to_le32(TRB_TDL_SS_SIZE(td_size));\n\t\telse\n\t\t\tcontrol |= TRB_TDL_HS_SIZE(td_size);\n\t}\n\n\tdo {\n\t\tu32 length;\n\n\t\tif (!(sg_iter % num_trb_req) && sg_supported)\n\t\t\ts = request->sg;\n\n\t\t \n\t\tcontrol |= TRB_TYPE(TRB_NORMAL);\n\t\tif (sg_supported) {\n\t\t\ttrb->buffer = cpu_to_le32(TRB_BUFFER(sg_dma_address(s)));\n\t\t\tlength = sg_dma_len(s);\n\t\t} else {\n\t\t\ttrb->buffer = cpu_to_le32(TRB_BUFFER(trb_dma));\n\t\t\tlength = request->length;\n\t\t}\n\n\t\tif (priv_ep->flags & EP_TDLCHK_EN)\n\t\t\ttotal_tdl += DIV_ROUND_UP(length,\n\t\t\t\t\t       priv_ep->endpoint.maxpacket);\n\n\t\ttrb_burst = priv_ep->trb_burst_size;\n\n\t\t \n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC && priv_dev->dev_ver <= DEV_VER_V2)\n\t\t\tif (ALIGN_DOWN(trb->buffer, SZ_4K) !=\n\t\t\t    ALIGN_DOWN(trb->buffer + length, SZ_4K))\n\t\t\t\ttrb_burst = 16;\n\n\t\ttrb->length |= cpu_to_le32(TRB_BURST_LEN(trb_burst) |\n\t\t\t\t\tTRB_LEN(length));\n\t\tpcs = priv_ep->pcs ? TRB_CYCLE : 0;\n\n\t\t \n\t\tif (sg_iter != 0)\n\t\t\tcontrol |= pcs;\n\n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC  && !priv_ep->dir) {\n\t\t\tcontrol |= TRB_IOC | TRB_ISP;\n\t\t} else {\n\t\t\t \n\t\t\tif (sg_iter == (num_trb - 1) && sg_iter != 0)\n\t\t\t\tcontrol |= pcs | TRB_IOC | TRB_ISP;\n\t\t}\n\n\t\tif (sg_iter)\n\t\t\ttrb->control = cpu_to_le32(control);\n\t\telse\n\t\t\tpriv_req->trb->control = cpu_to_le32(control);\n\n\t\tif (sg_supported) {\n\t\t\ttrb->control |= cpu_to_le32(TRB_ISP);\n\t\t\t \n\t\t\tif ((sg_iter % num_trb_req) < num_trb_req - 1)\n\t\t\t\ttrb->control |= cpu_to_le32(TRB_CHAIN);\n\n\t\t\ts = sg_next(s);\n\t\t}\n\n\t\tcontrol = 0;\n\t\t++sg_iter;\n\t\tpriv_req->end_trb = priv_ep->enqueue;\n\t\tcdns3_ep_inc_enq(priv_ep);\n\t\ttrb = priv_ep->trb_pool + priv_ep->enqueue;\n\t\ttrb->length = 0;\n\t} while (sg_iter < num_trb);\n\n\ttrb = priv_req->trb;\n\n\tpriv_req->flags |= REQUEST_PENDING;\n\tpriv_req->num_of_trb = num_trb;\n\n\tif (sg_iter == 1)\n\t\ttrb->control |= cpu_to_le32(TRB_IOC | TRB_ISP);\n\n\tif (priv_dev->dev_ver < DEV_VER_V2 &&\n\t    (priv_ep->flags & EP_TDLCHK_EN)) {\n\t\tu16 tdl = total_tdl;\n\t\tu16 old_tdl = EP_CMD_TDL_GET(readl(&priv_dev->regs->ep_cmd));\n\n\t\tif (tdl > EP_CMD_TDL_MAX) {\n\t\t\ttdl = EP_CMD_TDL_MAX;\n\t\t\tpriv_ep->pending_tdl = total_tdl - EP_CMD_TDL_MAX;\n\t\t}\n\n\t\tif (old_tdl < tdl) {\n\t\t\ttdl -= old_tdl;\n\t\t\twritel(EP_CMD_TDL_SET(tdl) | EP_CMD_STDL,\n\t\t\t       &priv_dev->regs->ep_cmd);\n\t\t}\n\t}\n\n\t \n\twmb();\n\n\t \n\tif (togle_pcs)\n\t\ttrb->control = trb->control ^ cpu_to_le32(1);\n\n\tif (priv_dev->dev_ver <= DEV_VER_V2)\n\t\tcdns3_wa1_tray_restore_cycle_bit(priv_dev, priv_ep);\n\n\tif (num_trb > 1) {\n\t\tint i = 0;\n\n\t\twhile (i < num_trb) {\n\t\t\ttrace_cdns3_prepare_trb(priv_ep, trb + i);\n\t\t\tif (trb + i == link_trb) {\n\t\t\t\ttrb = priv_ep->trb_pool;\n\t\t\t\tnum_trb = num_trb - i;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttrace_cdns3_prepare_trb(priv_ep, priv_req->trb);\n\t}\n\n\t \n\twmb();\n\n\t \n\tif (priv_ep->flags & EP_UPDATE_EP_TRBADDR) {\n\t\t \n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC  && !priv_ep->dir &&\n\t\t    !(priv_ep->flags & EP_QUIRK_ISO_OUT_EN)) {\n\t\t\tpriv_ep->flags |= EP_QUIRK_ISO_OUT_EN;\n\t\t\tcdns3_set_register_bit(&priv_dev->regs->ep_cfg,\n\t\t\t\t\t       EP_CFG_ENABLE);\n\t\t}\n\n\t\twritel(EP_TRADDR_TRADDR(priv_ep->trb_pool_dma +\n\t\t\t\t\tpriv_req->start_trb * TRB_SIZE),\n\t\t\t\t\t&priv_dev->regs->ep_traddr);\n\n\t\tpriv_ep->flags &= ~EP_UPDATE_EP_TRBADDR;\n\t}\n\n\tif (!priv_ep->wa1_set && !(priv_ep->flags & EP_STALLED)) {\n\t\ttrace_cdns3_ring(priv_ep);\n\t\t \n\t\twritel(EP_STS_TRBERR | EP_STS_DESCMIS, &priv_dev->regs->ep_sts);\n\t\twritel(EP_CMD_DRDY, &priv_dev->regs->ep_cmd);\n\t\tcdns3_rearm_drdy_if_needed(priv_ep);\n\t\ttrace_cdns3_doorbell_epx(priv_ep->name,\n\t\t\t\t\t readl(&priv_dev->regs->ep_traddr));\n\t}\n\n\t \n\t__cdns3_gadget_wakeup(priv_dev);\n\n\treturn 0;\n}\n\nvoid cdns3_set_hw_configuration(struct cdns3_device *priv_dev)\n{\n\tstruct cdns3_endpoint *priv_ep;\n\tstruct usb_ep *ep;\n\n\tif (priv_dev->hw_configured_flag)\n\t\treturn;\n\n\twritel(USB_CONF_CFGSET, &priv_dev->regs->usb_conf);\n\n\tcdns3_set_register_bit(&priv_dev->regs->usb_conf,\n\t\t\t       USB_CONF_U1EN | USB_CONF_U2EN);\n\n\tpriv_dev->hw_configured_flag = 1;\n\n\tlist_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {\n\t\tif (ep->enabled) {\n\t\t\tpriv_ep = ep_to_cdns3_ep(ep);\n\t\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t\t}\n\t}\n\n\tcdns3_allow_enable_l1(priv_dev, 1);\n}\n\n \nstatic bool cdns3_trb_handled(struct cdns3_endpoint *priv_ep,\n\t\t\t\t  struct cdns3_request *priv_req)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct cdns3_trb *trb;\n\tint current_index = 0;\n\tint handled = 0;\n\tint doorbell;\n\n\tcurrent_index = cdns3_get_dma_pos(priv_dev, priv_ep);\n\tdoorbell = !!(readl(&priv_dev->regs->ep_cmd) & EP_CMD_DRDY);\n\n\t \n\tif (priv_req->start_trb < priv_req->end_trb) {\n\t\tif (priv_ep->dequeue > priv_req->end_trb)\n\t\t\tgoto finish;\n\n\t\tif (priv_ep->dequeue < priv_req->start_trb)\n\t\t\tgoto finish;\n\t}\n\n\tif ((priv_req->start_trb > priv_req->end_trb) &&\n\t\t(priv_ep->dequeue > priv_req->end_trb) &&\n\t\t(priv_ep->dequeue < priv_req->start_trb))\n\t\tgoto finish;\n\n\tif ((priv_req->start_trb == priv_req->end_trb) &&\n\t\t(priv_ep->dequeue != priv_req->end_trb))\n\t\tgoto finish;\n\n\ttrb = &priv_ep->trb_pool[priv_ep->dequeue];\n\n\tif ((le32_to_cpu(trb->control) & TRB_CYCLE) != priv_ep->ccs)\n\t\tgoto finish;\n\n\tif (doorbell == 1 && current_index == priv_ep->dequeue)\n\t\tgoto finish;\n\n\t \n\tif (TRBS_PER_SEGMENT == 2 && priv_ep->type != USB_ENDPOINT_XFER_ISOC) {\n\t\thandled = 1;\n\t\tgoto finish;\n\t}\n\n\tif (priv_ep->enqueue == priv_ep->dequeue &&\n\t    priv_ep->free_trbs == 0) {\n\t\thandled = 1;\n\t} else if (priv_ep->dequeue < current_index) {\n\t\tif ((current_index == (priv_ep->num_trbs - 1)) &&\n\t\t    !priv_ep->dequeue)\n\t\t\tgoto finish;\n\n\t\thandled = 1;\n\t} else if (priv_ep->dequeue  > current_index) {\n\t\t\thandled = 1;\n\t}\n\nfinish:\n\ttrace_cdns3_request_handled(priv_req, current_index, handled);\n\n\treturn handled;\n}\n\nstatic void cdns3_transfer_completed(struct cdns3_device *priv_dev,\n\t\t\t\t     struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_request *priv_req;\n\tstruct usb_request *request;\n\tstruct cdns3_trb *trb;\n\tbool request_handled = false;\n\tbool transfer_end = false;\n\n\twhile (!list_empty(&priv_ep->pending_req_list)) {\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\t\tpriv_req = to_cdns3_request(request);\n\n\t\ttrb = priv_ep->trb_pool + priv_ep->dequeue;\n\n\t\t \n\t\twhile (TRB_FIELD_TO_TYPE(le32_to_cpu(trb->control)) == TRB_LINK) {\n\n\t\t\t \n\t\t\tif (priv_ep->dequeue == cdns3_get_dma_pos(priv_dev, priv_ep) &&\n\t\t\t    priv_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\tbreak;\n\n\t\t\ttrace_cdns3_complete_trb(priv_ep, trb);\n\t\t\tcdns3_ep_inc_deq(priv_ep);\n\t\t\ttrb = priv_ep->trb_pool + priv_ep->dequeue;\n\t\t}\n\n\t\tif (!request->stream_id) {\n\t\t\t \n\t\t\tcdns3_select_ep(priv_dev, priv_ep->endpoint.address);\n\n\t\t\twhile (cdns3_trb_handled(priv_ep, priv_req)) {\n\t\t\t\tpriv_req->finished_trb++;\n\t\t\t\tif (priv_req->finished_trb >= priv_req->num_of_trb)\n\t\t\t\t\trequest_handled = true;\n\n\t\t\t\ttrb = priv_ep->trb_pool + priv_ep->dequeue;\n\t\t\t\ttrace_cdns3_complete_trb(priv_ep, trb);\n\n\t\t\t\tif (!transfer_end)\n\t\t\t\t\trequest->actual +=\n\t\t\t\t\t\tTRB_LEN(le32_to_cpu(trb->length));\n\n\t\t\t\tif (priv_req->num_of_trb > 1 &&\n\t\t\t\t\tle32_to_cpu(trb->control) & TRB_SMM &&\n\t\t\t\t\tle32_to_cpu(trb->control) & TRB_CHAIN)\n\t\t\t\t\ttransfer_end = true;\n\n\t\t\t\tcdns3_ep_inc_deq(priv_ep);\n\t\t\t}\n\n\t\t\tif (request_handled) {\n\t\t\t\t \n\t\t\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC && priv_ep->dir)\n\t\t\t\t\trequest->actual /= priv_ep->interval;\n\n\t\t\t\tcdns3_gadget_giveback(priv_ep, priv_req, 0);\n\t\t\t\trequest_handled = false;\n\t\t\t\ttransfer_end = false;\n\t\t\t} else {\n\t\t\t\tgoto prepare_next_td;\n\t\t\t}\n\n\t\t\tif (priv_ep->type != USB_ENDPOINT_XFER_ISOC &&\n\t\t\t    TRBS_PER_SEGMENT == 2)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tcdns3_select_ep(priv_dev, priv_ep->endpoint.address);\n\n\t\t\ttrb = priv_ep->trb_pool;\n\t\t\ttrace_cdns3_complete_trb(priv_ep, trb);\n\n\t\t\tif (trb != priv_req->trb)\n\t\t\t\tdev_warn(priv_dev->dev,\n\t\t\t\t\t \"request_trb=0x%p, queue_trb=0x%p\\n\",\n\t\t\t\t\t priv_req->trb, trb);\n\n\t\t\trequest->actual += TRB_LEN(le32_to_cpu(trb->length));\n\n\t\t\tif (!request->num_sgs ||\n\t\t\t    (request->num_sgs == (priv_ep->stream_sg_idx + 1))) {\n\t\t\t\tpriv_ep->stream_sg_idx = 0;\n\t\t\t\tcdns3_gadget_giveback(priv_ep, priv_req, 0);\n\t\t\t} else {\n\t\t\t\tpriv_ep->stream_sg_idx++;\n\t\t\t\tcdns3_ep_run_stream_transfer(priv_ep, request);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tpriv_ep->flags &= ~EP_PENDING_REQUEST;\n\nprepare_next_td:\n\tif (!(priv_ep->flags & EP_STALLED) &&\n\t    !(priv_ep->flags & EP_STALL_PENDING))\n\t\tcdns3_start_all_request(priv_dev, priv_ep);\n}\n\nvoid cdns3_rearm_transfer(struct cdns3_endpoint *priv_ep, u8 rearm)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tcdns3_wa1_restore_cycle_bit(priv_ep);\n\n\tif (rearm) {\n\t\ttrace_cdns3_ring(priv_ep);\n\n\t\t \n\t\twmb();\n\t\twritel(EP_CMD_DRDY, &priv_dev->regs->ep_cmd);\n\n\t\t__cdns3_gadget_wakeup(priv_dev);\n\n\t\ttrace_cdns3_doorbell_epx(priv_ep->name,\n\t\t\t\t\t readl(&priv_dev->regs->ep_traddr));\n\t}\n}\n\nstatic void cdns3_reprogram_tdl(struct cdns3_endpoint *priv_ep)\n{\n\tu16 tdl = priv_ep->pending_tdl;\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\tif (tdl > EP_CMD_TDL_MAX) {\n\t\ttdl = EP_CMD_TDL_MAX;\n\t\tpriv_ep->pending_tdl -= EP_CMD_TDL_MAX;\n\t} else {\n\t\tpriv_ep->pending_tdl = 0;\n\t}\n\n\twritel(EP_CMD_TDL_SET(tdl) | EP_CMD_STDL, &priv_dev->regs->ep_cmd);\n}\n\n \nstatic int cdns3_check_ep_interrupt_proceed(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tu32 ep_sts_reg;\n\tstruct usb_request *deferred_request;\n\tstruct usb_request *pending_request;\n\tu32 tdl = 0;\n\n\tcdns3_select_ep(priv_dev, priv_ep->endpoint.address);\n\n\ttrace_cdns3_epx_irq(priv_dev, priv_ep);\n\n\tep_sts_reg = readl(&priv_dev->regs->ep_sts);\n\twritel(ep_sts_reg, &priv_dev->regs->ep_sts);\n\n\tif ((ep_sts_reg & EP_STS_PRIME) && priv_ep->use_streams) {\n\t\tbool dbusy = !!(ep_sts_reg & EP_STS_DBUSY);\n\n\t\ttdl = cdns3_get_tdl(priv_dev);\n\n\t\t \n\t\tif (tdl && (dbusy || !EP_STS_BUFFEMPTY(ep_sts_reg) ||\n\t\t    EP_STS_HOSTPP(ep_sts_reg))) {\n\t\t\twritel(EP_CMD_ERDY |\n\t\t\t       EP_CMD_ERDY_SID(priv_ep->last_stream_id),\n\t\t\t       &priv_dev->regs->ep_cmd);\n\t\t\tep_sts_reg &= ~(EP_STS_MD_EXIT | EP_STS_IOC);\n\t\t} else {\n\t\t\tpriv_ep->prime_flag = true;\n\n\t\t\tpending_request = cdns3_next_request(&priv_ep->pending_req_list);\n\t\t\tdeferred_request = cdns3_next_request(&priv_ep->deferred_req_list);\n\n\t\t\tif (deferred_request && !pending_request) {\n\t\t\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ep_sts_reg & EP_STS_TRBERR) {\n\t\tif (priv_ep->flags & EP_STALL_PENDING &&\n\t\t    !(ep_sts_reg & EP_STS_DESCMIS &&\n\t\t    priv_dev->dev_ver < DEV_VER_V2)) {\n\t\t\tcdns3_ep_stall_flush(priv_ep);\n\t\t}\n\n\t\t \n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC &&\n\t\t    !priv_ep->wa1_set) {\n\t\t\tif (!priv_ep->dir) {\n\t\t\t\tu32 ep_cfg = readl(&priv_dev->regs->ep_cfg);\n\n\t\t\t\tep_cfg &= ~EP_CFG_ENABLE;\n\t\t\t\twritel(ep_cfg, &priv_dev->regs->ep_cfg);\n\t\t\t\tpriv_ep->flags &= ~EP_QUIRK_ISO_OUT_EN;\n\t\t\t\tpriv_ep->flags |= EP_UPDATE_EP_TRBADDR;\n\t\t\t}\n\t\t\tcdns3_transfer_completed(priv_dev, priv_ep);\n\t\t} else if (!(priv_ep->flags & EP_STALLED) &&\n\t\t\t  !(priv_ep->flags & EP_STALL_PENDING)) {\n\t\t\tif (priv_ep->flags & EP_DEFERRED_DRDY) {\n\t\t\t\tpriv_ep->flags &= ~EP_DEFERRED_DRDY;\n\t\t\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t\t\t} else {\n\t\t\t\tcdns3_rearm_transfer(priv_ep,\n\t\t\t\t\t\t     priv_ep->wa1_set);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((ep_sts_reg & EP_STS_IOC) || (ep_sts_reg & EP_STS_ISP) ||\n\t    (ep_sts_reg & EP_STS_IOT)) {\n\t\tif (priv_ep->flags & EP_QUIRK_EXTRA_BUF_EN) {\n\t\t\tif (ep_sts_reg & EP_STS_ISP)\n\t\t\t\tpriv_ep->flags |= EP_QUIRK_END_TRANSFER;\n\t\t\telse\n\t\t\t\tpriv_ep->flags &= ~EP_QUIRK_END_TRANSFER;\n\t\t}\n\n\t\tif (!priv_ep->use_streams) {\n\t\t\tif ((ep_sts_reg & EP_STS_IOC) ||\n\t\t\t    (ep_sts_reg & EP_STS_ISP)) {\n\t\t\t\tcdns3_transfer_completed(priv_dev, priv_ep);\n\t\t\t} else if ((priv_ep->flags & EP_TDLCHK_EN) &\n\t\t\t\t   priv_ep->pending_tdl) {\n\t\t\t\t \n\t\t\t\tcdns3_reprogram_tdl(priv_ep);\n\t\t\t}\n\t\t} else if (priv_ep->dir == USB_DIR_OUT) {\n\t\t\tpriv_ep->ep_sts_pending |= ep_sts_reg;\n\t\t} else if (ep_sts_reg & EP_STS_IOT) {\n\t\t\tcdns3_transfer_completed(priv_dev, priv_ep);\n\t\t}\n\t}\n\n\t \n\tif (priv_ep->dir == USB_DIR_OUT && (ep_sts_reg & EP_STS_MD_EXIT) &&\n\t    (priv_ep->ep_sts_pending & EP_STS_IOT) && priv_ep->use_streams) {\n\t\tpriv_ep->ep_sts_pending = 0;\n\t\tcdns3_transfer_completed(priv_dev, priv_ep);\n\t}\n\n\t \n\tif (ep_sts_reg & EP_STS_DESCMIS && priv_dev->dev_ver < DEV_VER_V2 &&\n\t    !(priv_ep->flags & EP_STALLED))\n\t\tcdns3_wa2_descmissing_packet(priv_ep);\n\n\treturn 0;\n}\n\nstatic void cdns3_disconnect_gadget(struct cdns3_device *priv_dev)\n{\n\tif (priv_dev->gadget_driver && priv_dev->gadget_driver->disconnect)\n\t\tpriv_dev->gadget_driver->disconnect(&priv_dev->gadget);\n}\n\n \nstatic void cdns3_check_usb_interrupt_proceed(struct cdns3_device *priv_dev,\n\t\t\t\t\t      u32 usb_ists)\n__must_hold(&priv_dev->lock)\n{\n\tint speed = 0;\n\n\ttrace_cdns3_usb_irq(priv_dev, usb_ists);\n\tif (usb_ists & USB_ISTS_L1ENTI) {\n\t\t \n\t\tif (readl(&priv_dev->regs->drbl))\n\t\t\t__cdns3_gadget_wakeup(priv_dev);\n\t}\n\n\t \n\tif (usb_ists & (USB_ISTS_CON2I | USB_ISTS_CONI)) {\n\t\tspeed = cdns3_get_speed(priv_dev);\n\t\tpriv_dev->gadget.speed = speed;\n\t\tusb_gadget_set_state(&priv_dev->gadget, USB_STATE_POWERED);\n\t\tcdns3_ep0_config(priv_dev);\n\t}\n\n\t \n\tif (usb_ists & (USB_ISTS_DIS2I | USB_ISTS_DISI)) {\n\t\tspin_unlock(&priv_dev->lock);\n\t\tcdns3_disconnect_gadget(priv_dev);\n\t\tspin_lock(&priv_dev->lock);\n\t\tpriv_dev->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tusb_gadget_set_state(&priv_dev->gadget, USB_STATE_NOTATTACHED);\n\t\tcdns3_hw_reset_eps_config(priv_dev);\n\t}\n\n\tif (usb_ists & (USB_ISTS_L2ENTI | USB_ISTS_U3ENTI)) {\n\t\tif (priv_dev->gadget_driver &&\n\t\t    priv_dev->gadget_driver->suspend) {\n\t\t\tspin_unlock(&priv_dev->lock);\n\t\t\tpriv_dev->gadget_driver->suspend(&priv_dev->gadget);\n\t\t\tspin_lock(&priv_dev->lock);\n\t\t}\n\t}\n\n\tif (usb_ists & (USB_ISTS_L2EXTI | USB_ISTS_U3EXTI)) {\n\t\tif (priv_dev->gadget_driver &&\n\t\t    priv_dev->gadget_driver->resume) {\n\t\t\tspin_unlock(&priv_dev->lock);\n\t\t\tpriv_dev->gadget_driver->resume(&priv_dev->gadget);\n\t\t\tspin_lock(&priv_dev->lock);\n\t\t}\n\t}\n\n\t \n\tif (usb_ists & (USB_ISTS_UWRESI | USB_ISTS_UHRESI | USB_ISTS_U2RESI)) {\n\t\tif (priv_dev->gadget_driver) {\n\t\t\tspin_unlock(&priv_dev->lock);\n\t\t\tusb_gadget_udc_reset(&priv_dev->gadget,\n\t\t\t\t\t     priv_dev->gadget_driver);\n\t\t\tspin_lock(&priv_dev->lock);\n\n\t\t\t \n\t\t\tspeed = cdns3_get_speed(priv_dev);\n\t\t\tpriv_dev->gadget.speed = speed;\n\t\t\tcdns3_hw_reset_eps_config(priv_dev);\n\t\t\tcdns3_ep0_config(priv_dev);\n\t\t}\n\t}\n}\n\n \nstatic irqreturn_t cdns3_device_irq_handler(int irq, void *data)\n{\n\tstruct cdns3_device *priv_dev = data;\n\tstruct cdns *cdns = dev_get_drvdata(priv_dev->dev);\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 reg;\n\n\tif (cdns->in_lpm)\n\t\treturn ret;\n\n\t \n\treg = readl(&priv_dev->regs->usb_ists);\n\tif (reg) {\n\t\t \n\t\treg = ~reg & readl(&priv_dev->regs->usb_ien);\n\t\t \n\t\twritel(reg, &priv_dev->regs->usb_ien);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\t \n\treg = readl(&priv_dev->regs->ep_ists);\n\tif (reg) {\n\t\twritel(0, &priv_dev->regs->ep_ien);\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\treturn ret;\n}\n\n \nstatic irqreturn_t cdns3_device_thread_irq_handler(int irq, void *data)\n{\n\tstruct cdns3_device *priv_dev = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tunsigned long flags;\n\tunsigned int bit;\n\tunsigned long reg;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\treg = readl(&priv_dev->regs->usb_ists);\n\tif (reg) {\n\t\twritel(reg, &priv_dev->regs->usb_ists);\n\t\twritel(USB_IEN_INIT, &priv_dev->regs->usb_ien);\n\t\tcdns3_check_usb_interrupt_proceed(priv_dev, reg);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treg = readl(&priv_dev->regs->ep_ists);\n\n\t \n\tif (reg & EP_ISTS_EP_OUT0) {\n\t\tcdns3_check_ep0_interrupt_proceed(priv_dev, USB_DIR_OUT);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (reg & EP_ISTS_EP_IN0) {\n\t\tcdns3_check_ep0_interrupt_proceed(priv_dev, USB_DIR_IN);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\treg &= ~(EP_ISTS_EP_OUT0 | EP_ISTS_EP_IN0);\n\tif (!reg)\n\t\tgoto irqend;\n\n\tfor_each_set_bit(bit, &reg,\n\t\t\t sizeof(u32) * BITS_PER_BYTE) {\n\t\tcdns3_check_ep_interrupt_proceed(priv_dev->eps[bit]);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (priv_dev->dev_ver < DEV_VER_V2 && priv_dev->using_streams)\n\t\tcdns3_wa2_check_outq_status(priv_dev);\n\nirqend:\n\twritel(~0, &priv_dev->regs->ep_ien);\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int cdns3_ep_onchip_buffer_reserve(struct cdns3_device *priv_dev,\n\t\t\t\t\t  int size, int is_in)\n{\n\tint remained;\n\n\t \n\tremained = priv_dev->onchip_buffers - priv_dev->onchip_used_size - 2;\n\n\tif (is_in) {\n\t\tif (remained < size)\n\t\t\treturn -EPERM;\n\n\t\tpriv_dev->onchip_used_size += size;\n\t} else {\n\t\tint required;\n\n\t\t \n\t\tif (priv_dev->out_mem_is_allocated >= size)\n\t\t\treturn 0;\n\n\t\trequired = size - priv_dev->out_mem_is_allocated;\n\n\t\tif (required > remained)\n\t\t\treturn -EPERM;\n\n\t\tpriv_dev->out_mem_is_allocated += required;\n\t\tpriv_dev->onchip_used_size += required;\n\t}\n\n\treturn 0;\n}\n\nstatic void cdns3_configure_dmult(struct cdns3_device *priv_dev,\n\t\t\t\t  struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_usb_regs __iomem *regs = priv_dev->regs;\n\n\t \n\tif (priv_dev->dev_ver <= DEV_VER_V2)\n\t\twritel(USB_CONF_DMULT, &regs->usb_conf);\n\n\tif (priv_dev->dev_ver == DEV_VER_V2)\n\t\twritel(USB_CONF2_EN_TDL_TRB, &regs->usb_conf2);\n\n\tif (priv_dev->dev_ver >= DEV_VER_V3 && priv_ep) {\n\t\tu32 mask;\n\n\t\tif (priv_ep->dir)\n\t\t\tmask = BIT(priv_ep->num + 16);\n\t\telse\n\t\t\tmask = BIT(priv_ep->num);\n\n\t\tif (priv_ep->type != USB_ENDPOINT_XFER_ISOC  && !priv_ep->dir) {\n\t\t\tcdns3_set_register_bit(&regs->tdl_from_trb, mask);\n\t\t\tcdns3_set_register_bit(&regs->tdl_beh, mask);\n\t\t\tcdns3_set_register_bit(&regs->tdl_beh2, mask);\n\t\t\tcdns3_set_register_bit(&regs->dma_adv_td, mask);\n\t\t}\n\n\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC && !priv_ep->dir)\n\t\t\tcdns3_set_register_bit(&regs->tdl_from_trb, mask);\n\n\t\tcdns3_set_register_bit(&regs->dtrans, mask);\n\t}\n}\n\n \nint cdns3_ep_config(struct cdns3_endpoint *priv_ep, bool enable)\n{\n\tbool is_iso_ep = (priv_ep->type == USB_ENDPOINT_XFER_ISOC);\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tu32 bEndpointAddress = priv_ep->num | priv_ep->dir;\n\tu32 max_packet_size = priv_ep->wMaxPacketSize;\n\tu8 maxburst = priv_ep->bMaxBurst;\n\tu32 ep_cfg = 0;\n\tu8 buffering;\n\tint ret;\n\n\tbuffering = priv_dev->ep_buf_size - 1;\n\n\tcdns3_configure_dmult(priv_dev, priv_ep);\n\n\tswitch (priv_ep->type) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tep_cfg = EP_CFG_EPTYPE(USB_ENDPOINT_XFER_INT);\n\n\t\tif (priv_dev->dev_ver >= DEV_VER_V2 && !priv_ep->dir)\n\t\t\tep_cfg |= EP_CFG_TDL_CHK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tep_cfg = EP_CFG_EPTYPE(USB_ENDPOINT_XFER_BULK);\n\n\t\tif (priv_dev->dev_ver >= DEV_VER_V2 && !priv_ep->dir)\n\t\t\tep_cfg |= EP_CFG_TDL_CHK;\n\t\tbreak;\n\tdefault:\n\t\tep_cfg = EP_CFG_EPTYPE(USB_ENDPOINT_XFER_ISOC);\n\t\tbuffering = (priv_ep->bMaxBurst + 1) * (priv_ep->mult + 1) - 1;\n\t}\n\n\tswitch (priv_dev->gadget.speed) {\n\tcase USB_SPEED_FULL:\n\t\tmax_packet_size = is_iso_ep ? 1023 : 64;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tmax_packet_size = is_iso_ep ? 1024 : 512;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tif (priv_ep->type != USB_ENDPOINT_XFER_ISOC) {\n\t\t\tmax_packet_size = 1024;\n\t\t\tmaxburst = priv_dev->ep_buf_size - 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (max_packet_size == 1024)\n\t\tpriv_ep->trb_burst_size = 128;\n\telse if (max_packet_size >= 512)\n\t\tpriv_ep->trb_burst_size = 64;\n\telse\n\t\tpriv_ep->trb_burst_size = 16;\n\n\t \n\tif (priv_dev->dev_ver < DEV_VER_V2)\n\t\tpriv_ep->trb_burst_size = 16;\n\n\tbuffering = min_t(u8, buffering, EP_CFG_BUFFERING_MAX);\n\tmaxburst = min_t(u8, maxburst, EP_CFG_MAXBURST_MAX);\n\n\t \n\tif (!priv_dev->hw_configured_flag) {\n\t\tret = cdns3_ep_onchip_buffer_reserve(priv_dev, buffering + 1,\n\t\t\t\t\t\t     !!priv_ep->dir);\n\t\tif (ret) {\n\t\t\tdev_err(priv_dev->dev, \"onchip mem is full, ep is invalid\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (enable)\n\t\tep_cfg |= EP_CFG_ENABLE;\n\n\tif (priv_ep->use_streams && priv_dev->gadget.speed >= USB_SPEED_SUPER) {\n\t\tif (priv_dev->dev_ver >= DEV_VER_V3) {\n\t\t\tu32 mask = BIT(priv_ep->num + (priv_ep->dir ? 16 : 0));\n\n\t\t\t \n\t\t\tcdns3_clear_register_bit(&priv_dev->regs->tdl_from_trb,\n\t\t\t\t\t\t mask);\n\t\t}\n\n\t\t \n\t\tep_cfg |=  EP_CFG_STREAM_EN | EP_CFG_TDL_CHK | EP_CFG_SID_CHK;\n\t}\n\n\tep_cfg |= EP_CFG_MAXPKTSIZE(max_packet_size) |\n\t\t  EP_CFG_MULT(priv_ep->mult) |\t\t\t \n\t\t  EP_CFG_BUFFERING(buffering) |\n\t\t  EP_CFG_MAXBURST(maxburst);\n\n\tcdns3_select_ep(priv_dev, bEndpointAddress);\n\twritel(ep_cfg, &priv_dev->regs->ep_cfg);\n\tpriv_ep->flags |= EP_CONFIGURED;\n\n\tdev_dbg(priv_dev->dev, \"Configure %s: with val %08x\\n\",\n\t\tpriv_ep->name, ep_cfg);\n\n\treturn 0;\n}\n\n \nstatic int cdns3_ep_dir_is_correct(struct usb_endpoint_descriptor *desc,\n\t\t\t\t   struct cdns3_endpoint *priv_ep)\n{\n\treturn (priv_ep->endpoint.caps.dir_in && usb_endpoint_dir_in(desc)) ||\n\t       (priv_ep->endpoint.caps.dir_out && usb_endpoint_dir_out(desc));\n}\n\nstatic struct\ncdns3_endpoint *cdns3_find_available_ep(struct cdns3_device *priv_dev,\n\t\t\t\t\tstruct usb_endpoint_descriptor *desc)\n{\n\tstruct usb_ep *ep;\n\tstruct cdns3_endpoint *priv_ep;\n\n\tlist_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {\n\t\tunsigned long num;\n\t\tint ret;\n\t\t \n\t\tchar c[2] = {ep->name[2], '\\0'};\n\n\t\tret = kstrtoul(c, 10, &num);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\n\t\tpriv_ep = ep_to_cdns3_ep(ep);\n\t\tif (cdns3_ep_dir_is_correct(desc, priv_ep)) {\n\t\t\tif (!(priv_ep->flags & EP_CLAIMED)) {\n\t\t\t\tpriv_ep->num  = num;\n\t\t\t\treturn priv_ep;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ERR_PTR(-ENOENT);\n}\n\n \nstatic struct\nusb_ep *cdns3_gadget_match_ep(struct usb_gadget *gadget,\n\t\t\t      struct usb_endpoint_descriptor *desc,\n\t\t\t      struct usb_ss_ep_comp_descriptor *comp_desc)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tstruct cdns3_endpoint *priv_ep;\n\tunsigned long flags;\n\n\tpriv_ep = cdns3_find_available_ep(priv_dev, desc);\n\tif (IS_ERR(priv_ep)) {\n\t\tdev_err(priv_dev->dev, \"no available ep\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(priv_dev->dev, \"match endpoint: %s\\n\", priv_ep->name);\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\tpriv_ep->endpoint.desc = desc;\n\tpriv_ep->dir  = usb_endpoint_dir_in(desc) ? USB_DIR_IN : USB_DIR_OUT;\n\tpriv_ep->type = usb_endpoint_type(desc);\n\tpriv_ep->flags |= EP_CLAIMED;\n\tpriv_ep->interval = desc->bInterval ? BIT(desc->bInterval - 1) : 0;\n\tpriv_ep->wMaxPacketSize =  usb_endpoint_maxp(desc);\n\tpriv_ep->mult = USB_EP_MAXP_MULT(priv_ep->wMaxPacketSize);\n\tpriv_ep->wMaxPacketSize &= USB_ENDPOINT_MAXP_MASK;\n\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC && comp_desc) {\n\t\tpriv_ep->mult =  USB_SS_MULT(comp_desc->bmAttributes) - 1;\n\t\tpriv_ep->bMaxBurst = comp_desc->bMaxBurst;\n\t}\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn &priv_ep->endpoint;\n}\n\n \nstruct usb_request *cdns3_gadget_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t  gfp_t gfp_flags)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_request *priv_req;\n\n\tpriv_req = kzalloc(sizeof(*priv_req), gfp_flags);\n\tif (!priv_req)\n\t\treturn NULL;\n\n\tpriv_req->priv_ep = priv_ep;\n\n\ttrace_cdns3_alloc_request(priv_req);\n\treturn &priv_req->request;\n}\n\n \nvoid cdns3_gadget_ep_free_request(struct usb_ep *ep,\n\t\t\t\t  struct usb_request *request)\n{\n\tstruct cdns3_request *priv_req = to_cdns3_request(request);\n\n\tif (priv_req->aligned_buf)\n\t\tpriv_req->aligned_buf->in_use = 0;\n\n\ttrace_cdns3_free_request(priv_req);\n\tkfree(priv_req);\n}\n\n \nstatic int cdns3_gadget_ep_enable(struct usb_ep *ep,\n\t\t\t\t  const struct usb_endpoint_descriptor *desc)\n{\n\tstruct cdns3_endpoint *priv_ep;\n\tstruct cdns3_device *priv_dev;\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n\tu32 reg = EP_STS_EN_TRBERREN;\n\tu32 bEndpointAddress;\n\tunsigned long flags;\n\tint enable = 1;\n\tint ret = 0;\n\tint val;\n\n\tif (!ep) {\n\t\tpr_debug(\"usbss: ep not configured?\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv_ep = ep_to_cdns3_ep(ep);\n\tpriv_dev = priv_ep->cdns3_dev;\n\tcomp_desc = priv_ep->endpoint.comp_desc;\n\n\tif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tdev_dbg(priv_dev->dev, \"usbss: invalid parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->wMaxPacketSize) {\n\t\tdev_err(priv_dev->dev, \"usbss: missing wMaxPacketSize\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dev_WARN_ONCE(priv_dev->dev, priv_ep->flags & EP_ENABLED,\n\t\t\t  \"%s is already enabled\\n\", priv_ep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\tpriv_ep->endpoint.desc = desc;\n\tpriv_ep->type = usb_endpoint_type(desc);\n\tpriv_ep->interval = desc->bInterval ? BIT(desc->bInterval - 1) : 0;\n\n\tif (priv_ep->interval > ISO_MAX_INTERVAL &&\n\t    priv_ep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tdev_err(priv_dev->dev, \"Driver is limited to %d period\\n\",\n\t\t\tISO_MAX_INTERVAL);\n\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tbEndpointAddress = priv_ep->num | priv_ep->dir;\n\tcdns3_select_ep(priv_dev, bEndpointAddress);\n\n\t \n\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC  && !priv_ep->dir)\n\t\tenable = 0;\n\n\tif (usb_ss_max_streams(comp_desc) && usb_endpoint_xfer_bulk(desc)) {\n\t\t \n\t\tif (priv_dev->gadget.speed >= USB_SPEED_SUPER) {\n\t\t\treg |= EP_STS_EN_IOTEN | EP_STS_EN_PRIMEEEN |\n\t\t\t\tEP_STS_EN_SIDERREN | EP_STS_EN_MD_EXITEN |\n\t\t\t\tEP_STS_EN_STREAMREN;\n\t\t\tpriv_ep->use_streams = true;\n\t\t\tret = cdns3_ep_config(priv_ep, enable);\n\t\t\tpriv_dev->using_streams |= true;\n\t\t}\n\t} else {\n\t\tret = cdns3_ep_config(priv_ep, enable);\n\t}\n\n\tif (ret)\n\t\tgoto exit;\n\n\tret = cdns3_allocate_trb_pool(priv_ep);\n\tif (ret)\n\t\tgoto exit;\n\n\tbEndpointAddress = priv_ep->num | priv_ep->dir;\n\tcdns3_select_ep(priv_dev, bEndpointAddress);\n\n\ttrace_cdns3_gadget_ep_enable(priv_ep);\n\n\twritel(EP_CMD_EPRST, &priv_dev->regs->ep_cmd);\n\n\tret = readl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t\t!(val & (EP_CMD_CSTALL | EP_CMD_EPRST)),\n\t\t\t\t\t1, 1000);\n\n\tif (unlikely(ret)) {\n\t\tcdns3_free_trb_pool(priv_ep);\n\t\tret =  -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tcdns3_set_register_bit(&priv_dev->regs->ep_ien,\n\t\t\t       BIT(cdns3_ep_addr_to_index(bEndpointAddress)));\n\n\tif (priv_dev->dev_ver < DEV_VER_V2)\n\t\tcdns3_wa2_enable_detection(priv_dev, priv_ep, reg);\n\n\twritel(reg, &priv_dev->regs->ep_sts_en);\n\n\tep->desc = desc;\n\tpriv_ep->flags &= ~(EP_PENDING_REQUEST | EP_STALLED | EP_STALL_PENDING |\n\t\t\t    EP_QUIRK_ISO_OUT_EN | EP_QUIRK_EXTRA_BUF_EN);\n\tpriv_ep->flags |= EP_ENABLED | EP_UPDATE_EP_TRBADDR;\n\tpriv_ep->wa1_set = 0;\n\tpriv_ep->enqueue = 0;\n\tpriv_ep->dequeue = 0;\n\treg = readl(&priv_dev->regs->ep_sts);\n\tpriv_ep->pcs = !!EP_STS_CCS(reg);\n\tpriv_ep->ccs = !!EP_STS_CCS(reg);\n\t \n\tpriv_ep->free_trbs = priv_ep->num_trbs - 1;\nexit:\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int cdns3_gadget_ep_disable(struct usb_ep *ep)\n{\n\tstruct cdns3_endpoint *priv_ep;\n\tstruct cdns3_request *priv_req;\n\tstruct cdns3_device *priv_dev;\n\tstruct usb_request *request;\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 ep_cfg;\n\tint val;\n\n\tif (!ep) {\n\t\tpr_err(\"usbss: invalid parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv_ep = ep_to_cdns3_ep(ep);\n\tpriv_dev = priv_ep->cdns3_dev;\n\n\tif (dev_WARN_ONCE(priv_dev->dev, !(priv_ep->flags & EP_ENABLED),\n\t\t\t  \"%s is already disabled\\n\", priv_ep->name))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\ttrace_cdns3_gadget_ep_disable(priv_ep);\n\n\tcdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);\n\n\tep_cfg = readl(&priv_dev->regs->ep_cfg);\n\tep_cfg &= ~EP_CFG_ENABLE;\n\twritel(ep_cfg, &priv_dev->regs->ep_cfg);\n\n\t \n\treadl_poll_timeout_atomic(&priv_dev->regs->ep_sts, val,\n\t\t\t\t  !(val & EP_STS_DBUSY), 1, 10);\n\twritel(EP_CMD_EPRST, &priv_dev->regs->ep_cmd);\n\n\treadl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t  !(val & (EP_CMD_CSTALL | EP_CMD_EPRST)),\n\t\t\t\t  1, 1000);\n\tif (unlikely(ret))\n\t\tdev_err(priv_dev->dev, \"Timeout: %s resetting failed.\\n\",\n\t\t\tpriv_ep->name);\n\n\twhile (!list_empty(&priv_ep->pending_req_list)) {\n\t\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\n\t\tcdns3_gadget_giveback(priv_ep, to_cdns3_request(request),\n\t\t\t\t      -ESHUTDOWN);\n\t}\n\n\twhile (!list_empty(&priv_ep->wa2_descmiss_req_list)) {\n\t\tpriv_req = cdns3_next_priv_request(&priv_ep->wa2_descmiss_req_list);\n\n\t\tkfree(priv_req->request.buf);\n\t\tcdns3_gadget_ep_free_request(&priv_ep->endpoint,\n\t\t\t\t\t     &priv_req->request);\n\t\tlist_del_init(&priv_req->list);\n\t\t--priv_ep->wa2_counter;\n\t}\n\n\twhile (!list_empty(&priv_ep->deferred_req_list)) {\n\t\trequest = cdns3_next_request(&priv_ep->deferred_req_list);\n\n\t\tcdns3_gadget_giveback(priv_ep, to_cdns3_request(request),\n\t\t\t\t      -ESHUTDOWN);\n\t}\n\n\tpriv_ep->descmis_req = NULL;\n\n\tep->desc = NULL;\n\tpriv_ep->flags &= ~EP_ENABLED;\n\tpriv_ep->use_streams = false;\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int __cdns3_gadget_ep_queue(struct usb_ep *ep,\n\t\t\t\t   struct usb_request *request,\n\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct cdns3_request *priv_req;\n\tint ret = 0;\n\n\trequest->actual = 0;\n\trequest->status = -EINPROGRESS;\n\tpriv_req = to_cdns3_request(request);\n\ttrace_cdns3_ep_queue(priv_req);\n\n\tif (priv_dev->dev_ver < DEV_VER_V2) {\n\t\tret = cdns3_wa2_gadget_ep_queue(priv_dev, priv_ep,\n\t\t\t\t\t\tpriv_req);\n\n\t\tif (ret == EINPROGRESS)\n\t\t\treturn 0;\n\t}\n\n\tret = cdns3_prepare_aligned_request_buf(priv_req);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (likely(!(priv_req->flags & REQUEST_UNALIGNED))) {\n\t\tret = usb_gadget_map_request_by_dev(priv_dev->sysdev, request,\n\t\t\t\t\t    usb_endpoint_dir_in(ep->desc));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlist_add_tail(&request->list, &priv_ep->deferred_req_list);\n\n\t \n\tif (!request->stream_id) {\n\t\tif (priv_dev->hw_configured_flag &&\n\t\t    !(priv_ep->flags & EP_STALLED) &&\n\t\t    !(priv_ep->flags & EP_STALL_PENDING))\n\t\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t} else {\n\t\tif (priv_dev->hw_configured_flag && priv_ep->prime_flag)\n\t\t\tcdns3_start_all_request(priv_dev, priv_ep);\n\t}\n\n\treturn 0;\n}\n\nstatic int cdns3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,\n\t\t\t\t gfp_t gfp_flags)\n{\n\tstruct usb_request *zlp_request;\n\tstruct cdns3_endpoint *priv_ep;\n\tstruct cdns3_device *priv_dev;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!request || !ep)\n\t\treturn -EINVAL;\n\n\tpriv_ep = ep_to_cdns3_ep(ep);\n\tpriv_dev = priv_ep->cdns3_dev;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\tret = __cdns3_gadget_ep_queue(ep, request, gfp_flags);\n\n\tif (ret == 0 && request->zero && request->length &&\n\t    (request->length % ep->maxpacket == 0)) {\n\t\tstruct cdns3_request *priv_req;\n\n\t\tzlp_request = cdns3_gadget_ep_alloc_request(ep, GFP_ATOMIC);\n\t\tzlp_request->buf = priv_dev->zlp_buf;\n\t\tzlp_request->length = 0;\n\n\t\tpriv_req = to_cdns3_request(zlp_request);\n\t\tpriv_req->flags |= REQUEST_ZLP;\n\n\t\tdev_dbg(priv_dev->dev, \"Queuing ZLP for endpoint: %s\\n\",\n\t\t\tpriv_ep->name);\n\t\tret = __cdns3_gadget_ep_queue(ep, zlp_request, gfp_flags);\n\t}\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn ret;\n}\n\n \nint cdns3_gadget_ep_dequeue(struct usb_ep *ep,\n\t\t\t    struct usb_request *request)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_device *priv_dev;\n\tstruct usb_request *req, *req_temp;\n\tstruct cdns3_request *priv_req;\n\tstruct cdns3_trb *link_trb;\n\tu8 req_on_hw_ring = 0;\n\tunsigned long flags;\n\tint ret = 0;\n\tint val;\n\n\tif (!ep || !request || !ep->desc)\n\t\treturn -EINVAL;\n\n\tpriv_dev = priv_ep->cdns3_dev;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\tpriv_req = to_cdns3_request(request);\n\n\ttrace_cdns3_ep_dequeue(priv_req);\n\n\tcdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);\n\n\tlist_for_each_entry_safe(req, req_temp, &priv_ep->pending_req_list,\n\t\t\t\t list) {\n\t\tif (request == req) {\n\t\t\treq_on_hw_ring = 1;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(req, req_temp, &priv_ep->deferred_req_list,\n\t\t\t\t list) {\n\t\tif (request == req)\n\t\t\tgoto found;\n\t}\n\n\tgoto not_found;\n\nfound:\n\tlink_trb = priv_req->trb;\n\n\t \n\tif (req_on_hw_ring && link_trb) {\n\t\t \n\t\twritel(EP_CMD_DFLUSH, &priv_dev->regs->ep_cmd);\n\n\t\t \n\t\treadl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t\t  !(val & EP_CMD_DFLUSH), 1, 1000);\n\n\t\tlink_trb->buffer = cpu_to_le32(TRB_BUFFER(priv_ep->trb_pool_dma +\n\t\t\t((priv_req->end_trb + 1) * TRB_SIZE)));\n\t\tlink_trb->control = cpu_to_le32((le32_to_cpu(link_trb->control) & TRB_CYCLE) |\n\t\t\t\t    TRB_TYPE(TRB_LINK) | TRB_CHAIN);\n\n\t\tif (priv_ep->wa1_trb == priv_req->trb)\n\t\t\tcdns3_wa1_restore_cycle_bit(priv_ep);\n\t}\n\n\tcdns3_gadget_giveback(priv_ep, priv_req, -ECONNRESET);\n\n\treq = cdns3_next_request(&priv_ep->pending_req_list);\n\tif (req)\n\t\tcdns3_rearm_transfer(priv_ep, 1);\n\nnot_found:\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn ret;\n}\n\n \nvoid __cdns3_gadget_ep_set_halt(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\n\ttrace_cdns3_halt(priv_ep, 1, 0);\n\n\tif (!(priv_ep->flags & EP_STALLED)) {\n\t\tu32 ep_sts_reg = readl(&priv_dev->regs->ep_sts);\n\n\t\tif (!(ep_sts_reg & EP_STS_DBUSY))\n\t\t\tcdns3_ep_stall_flush(priv_ep);\n\t\telse\n\t\t\tpriv_ep->flags |= EP_STALL_PENDING;\n\t}\n}\n\n \nint __cdns3_gadget_ep_clear_halt(struct cdns3_endpoint *priv_ep)\n{\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tstruct usb_request *request;\n\tstruct cdns3_request *priv_req;\n\tstruct cdns3_trb *trb = NULL;\n\tstruct cdns3_trb trb_tmp;\n\tint ret;\n\tint val;\n\n\ttrace_cdns3_halt(priv_ep, 0, 0);\n\n\trequest = cdns3_next_request(&priv_ep->pending_req_list);\n\tif (request) {\n\t\tpriv_req = to_cdns3_request(request);\n\t\ttrb = priv_req->trb;\n\t\tif (trb) {\n\t\t\ttrb_tmp = *trb;\n\t\t\ttrb->control = trb->control ^ cpu_to_le32(TRB_CYCLE);\n\t\t}\n\t}\n\n\twritel(EP_CMD_CSTALL | EP_CMD_EPRST, &priv_dev->regs->ep_cmd);\n\n\t \n\tret = readl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t\t!(val & EP_CMD_EPRST), 1, 100);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tpriv_ep->flags &= ~(EP_STALLED | EP_STALL_PENDING);\n\n\tif (request) {\n\t\tif (trb)\n\t\t\t*trb = trb_tmp;\n\n\t\tcdns3_rearm_transfer(priv_ep, 1);\n\t}\n\n\tcdns3_start_all_request(priv_dev, priv_ep);\n\treturn ret;\n}\n\n \nint cdns3_gadget_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct cdns3_endpoint *priv_ep = ep_to_cdns3_ep(ep);\n\tstruct cdns3_device *priv_dev = priv_ep->cdns3_dev;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!(priv_ep->flags & EP_ENABLED))\n\t\treturn -EPERM;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\n\tcdns3_select_ep(priv_dev, ep->desc->bEndpointAddress);\n\n\tif (!value) {\n\t\tpriv_ep->flags &= ~EP_WEDGE;\n\t\tret = __cdns3_gadget_ep_clear_halt(priv_ep);\n\t} else {\n\t\t__cdns3_gadget_ep_set_halt(priv_ep);\n\t}\n\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\n\treturn ret;\n}\n\nextern const struct usb_ep_ops cdns3_gadget_ep0_ops;\n\nstatic const struct usb_ep_ops cdns3_gadget_ep_ops = {\n\t.enable = cdns3_gadget_ep_enable,\n\t.disable = cdns3_gadget_ep_disable,\n\t.alloc_request = cdns3_gadget_ep_alloc_request,\n\t.free_request = cdns3_gadget_ep_free_request,\n\t.queue = cdns3_gadget_ep_queue,\n\t.dequeue = cdns3_gadget_ep_dequeue,\n\t.set_halt = cdns3_gadget_ep_set_halt,\n\t.set_wedge = cdns3_gadget_ep_set_wedge,\n};\n\n \nstatic int cdns3_gadget_get_frame(struct usb_gadget *gadget)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\n\treturn readl(&priv_dev->regs->usb_itpn);\n}\n\nint __cdns3_gadget_wakeup(struct cdns3_device *priv_dev)\n{\n\tenum usb_device_speed speed;\n\n\tspeed = cdns3_get_speed(priv_dev);\n\n\tif (speed >= USB_SPEED_SUPER)\n\t\treturn 0;\n\n\t \n\twritel(USB_CONF_LGO_L0, &priv_dev->regs->usb_conf);\n\n\treturn 0;\n}\n\nstatic int cdns3_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\tret = __cdns3_gadget_wakeup(priv_dev);\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn ret;\n}\n\nstatic int cdns3_gadget_set_selfpowered(struct usb_gadget *gadget,\n\t\t\t\t\tint is_selfpowered)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\tpriv_dev->is_selfpowered = !!is_selfpowered;\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn 0;\n}\n\nstatic int cdns3_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\n\tif (is_on) {\n\t\twritel(USB_CONF_DEVEN, &priv_dev->regs->usb_conf);\n\t} else {\n\t\twritel(~0, &priv_dev->regs->ep_ists);\n\t\twritel(~0, &priv_dev->regs->usb_ists);\n\t\twritel(USB_CONF_DEVDS, &priv_dev->regs->usb_conf);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdns3_gadget_config(struct cdns3_device *priv_dev)\n{\n\tstruct cdns3_usb_regs __iomem *regs = priv_dev->regs;\n\tu32 reg;\n\n\tcdns3_ep0_config(priv_dev);\n\n\t \n\twritel(EP_IEN_EP_OUT0 | EP_IEN_EP_IN0, &regs->ep_ien);\n\n\t \n\tif (priv_dev->dev_ver == DEV_VER_TI_V1) {\n\t\treg = readl(&regs->dbg_link1);\n\n\t\treg &= ~DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_MASK;\n\t\treg |= DBG_LINK1_LFPS_MIN_GEN_U1_EXIT(0x55) |\n\t\t       DBG_LINK1_LFPS_MIN_GEN_U1_EXIT_SET;\n\t\twritel(reg, &regs->dbg_link1);\n\t}\n\n\t \n\treg = readl(&regs->dma_axi_ctrl);\n\treg |= DMA_AXI_CTRL_MARPROT(DMA_AXI_CTRL_NON_SECURE) |\n\t       DMA_AXI_CTRL_MAWPROT(DMA_AXI_CTRL_NON_SECURE);\n\twritel(reg, &regs->dma_axi_ctrl);\n\n\t \n\twritel(USB_IEN_INIT, &regs->usb_ien);\n\twritel(USB_CONF_CLK2OFFDS | USB_CONF_L1DS, &regs->usb_conf);\n\t \n\twritel(PUSB_PWR_FST_REG_ACCESS, &priv_dev->regs->usb_pwr);\n\n\tcdns3_configure_dmult(priv_dev, NULL);\n}\n\n \nstatic int cdns3_gadget_udc_start(struct usb_gadget *gadget,\n\t\t\t\t  struct usb_gadget_driver *driver)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tunsigned long flags;\n\tenum usb_device_speed max_speed = driver->max_speed;\n\n\tspin_lock_irqsave(&priv_dev->lock, flags);\n\tpriv_dev->gadget_driver = driver;\n\n\t \n\tmax_speed = min(driver->max_speed, gadget->max_speed);\n\n\tswitch (max_speed) {\n\tcase USB_SPEED_FULL:\n\t\twritel(USB_CONF_SFORCE_FS, &priv_dev->regs->usb_conf);\n\t\twritel(USB_CONF_USB3DIS, &priv_dev->regs->usb_conf);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\twritel(USB_CONF_USB3DIS, &priv_dev->regs->usb_conf);\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(priv_dev->dev,\n\t\t\t\"invalid maximum_speed parameter %d\\n\",\n\t\t\tmax_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tmax_speed = USB_SPEED_SUPER;\n\t\tbreak;\n\t}\n\n\tcdns3_gadget_config(priv_dev);\n\tspin_unlock_irqrestore(&priv_dev->lock, flags);\n\treturn 0;\n}\n\n \nstatic int cdns3_gadget_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tstruct cdns3_endpoint *priv_ep;\n\tu32 bEndpointAddress;\n\tstruct usb_ep *ep;\n\tint val;\n\n\tpriv_dev->gadget_driver = NULL;\n\n\tpriv_dev->onchip_used_size = 0;\n\tpriv_dev->out_mem_is_allocated = 0;\n\tpriv_dev->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tlist_for_each_entry(ep, &priv_dev->gadget.ep_list, ep_list) {\n\t\tpriv_ep = ep_to_cdns3_ep(ep);\n\t\tbEndpointAddress = priv_ep->num | priv_ep->dir;\n\t\tcdns3_select_ep(priv_dev, bEndpointAddress);\n\t\twritel(EP_CMD_EPRST, &priv_dev->regs->ep_cmd);\n\t\treadl_poll_timeout_atomic(&priv_dev->regs->ep_cmd, val,\n\t\t\t\t\t  !(val & EP_CMD_EPRST), 1, 100);\n\n\t\tpriv_ep->flags &= ~EP_CLAIMED;\n\t}\n\n\t \n\twritel(0, &priv_dev->regs->usb_ien);\n\twritel(0, &priv_dev->regs->usb_pwr);\n\twritel(USB_CONF_DEVDS, &priv_dev->regs->usb_conf);\n\n\treturn 0;\n}\n\n \nstatic int cdns3_gadget_check_config(struct usb_gadget *gadget)\n{\n\tstruct cdns3_device *priv_dev = gadget_to_cdns3_device(gadget);\n\tstruct cdns3_endpoint *priv_ep;\n\tstruct usb_ep *ep;\n\tint n_in = 0;\n\tint iso = 0;\n\tint out = 1;\n\tint total;\n\tint n;\n\n\tlist_for_each_entry(ep, &gadget->ep_list, ep_list) {\n\t\tpriv_ep = ep_to_cdns3_ep(ep);\n\t\tif (!(priv_ep->flags & EP_CLAIMED))\n\t\t\tcontinue;\n\n\t\tn = (priv_ep->mult + 1) * (priv_ep->bMaxBurst + 1);\n\t\tif (ep->address & USB_DIR_IN) {\n\t\t\t \n\t\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\tiso += n;\n\t\t\telse\n\t\t\t\tn_in++;\n\t\t} else {\n\t\t\tif (priv_ep->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\tout = max_t(int, out, n);\n\t\t}\n\t}\n\n\t \n\ttotal = 2 + n_in + out + iso;\n\n\tif (total > priv_dev->onchip_buffers)\n\t\treturn -ENOMEM;\n\n\tpriv_dev->ep_buf_size = (priv_dev->onchip_buffers - 2 - iso) / (n_in + out);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops cdns3_gadget_ops = {\n\t.get_frame = cdns3_gadget_get_frame,\n\t.wakeup = cdns3_gadget_wakeup,\n\t.set_selfpowered = cdns3_gadget_set_selfpowered,\n\t.pullup = cdns3_gadget_pullup,\n\t.udc_start = cdns3_gadget_udc_start,\n\t.udc_stop = cdns3_gadget_udc_stop,\n\t.match_ep = cdns3_gadget_match_ep,\n\t.check_config = cdns3_gadget_check_config,\n};\n\nstatic void cdns3_free_all_eps(struct cdns3_device *priv_dev)\n{\n\tint i;\n\n\t \n\tpriv_dev->eps[16] = NULL;\n\n\tfor (i = 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++)\n\t\tif (priv_dev->eps[i]) {\n\t\t\tcdns3_free_trb_pool(priv_dev->eps[i]);\n\t\t\tdevm_kfree(priv_dev->dev, priv_dev->eps[i]);\n\t\t}\n}\n\n \nstatic int cdns3_init_eps(struct cdns3_device *priv_dev)\n{\n\tu32 ep_enabled_reg, iso_ep_reg;\n\tstruct cdns3_endpoint *priv_ep;\n\tint ep_dir, ep_number;\n\tu32 ep_mask;\n\tint ret = 0;\n\tint i;\n\n\t \n\tep_enabled_reg = readl(&priv_dev->regs->usb_cap3);\n\tiso_ep_reg = readl(&priv_dev->regs->usb_cap4);\n\n\tdev_dbg(priv_dev->dev, \"Initializing non-zero endpoints\\n\");\n\n\tfor (i = 0; i < CDNS3_ENDPOINTS_MAX_COUNT; i++) {\n\t\tep_dir = i >> 4;\t \n\t\tep_number = i & 0xF;\t \n\t\tep_mask = BIT(i);\n\n\t\tif (!(ep_enabled_reg & ep_mask))\n\t\t\tcontinue;\n\n\t\tif (ep_dir && !ep_number) {\n\t\t\tpriv_dev->eps[i] = priv_dev->eps[0];\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv_ep = devm_kzalloc(priv_dev->dev, sizeof(*priv_ep),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!priv_ep)\n\t\t\tgoto err;\n\n\t\t \n\t\tpriv_ep->cdns3_dev = priv_dev;\n\t\tpriv_dev->eps[i] = priv_ep;\n\t\tpriv_ep->num = ep_number;\n\t\tpriv_ep->dir = ep_dir ? USB_DIR_IN : USB_DIR_OUT;\n\n\t\tif (!ep_number) {\n\t\t\tret = cdns3_init_ep0(priv_dev, priv_ep);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv_dev->dev, \"Failed to init ep0\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tsnprintf(priv_ep->name, sizeof(priv_ep->name), \"ep%d%s\",\n\t\t\t\t ep_number, !!ep_dir ? \"in\" : \"out\");\n\t\t\tpriv_ep->endpoint.name = priv_ep->name;\n\n\t\t\tusb_ep_set_maxpacket_limit(&priv_ep->endpoint,\n\t\t\t\t\t\t   CDNS3_EP_MAX_PACKET_LIMIT);\n\t\t\tpriv_ep->endpoint.max_streams = CDNS3_EP_MAX_STREAMS;\n\t\t\tpriv_ep->endpoint.ops = &cdns3_gadget_ep_ops;\n\t\t\tif (ep_dir)\n\t\t\t\tpriv_ep->endpoint.caps.dir_in = 1;\n\t\t\telse\n\t\t\t\tpriv_ep->endpoint.caps.dir_out = 1;\n\n\t\t\tif (iso_ep_reg & ep_mask)\n\t\t\t\tpriv_ep->endpoint.caps.type_iso = 1;\n\n\t\t\tpriv_ep->endpoint.caps.type_bulk = 1;\n\t\t\tpriv_ep->endpoint.caps.type_int = 1;\n\n\t\t\tlist_add_tail(&priv_ep->endpoint.ep_list,\n\t\t\t\t      &priv_dev->gadget.ep_list);\n\t\t}\n\n\t\tpriv_ep->flags = 0;\n\n\t\tdev_dbg(priv_dev->dev, \"Initialized  %s support: %s %s\\n\",\n\t\t\t priv_ep->name,\n\t\t\t priv_ep->endpoint.caps.type_bulk ? \"BULK, INT\" : \"\",\n\t\t\t priv_ep->endpoint.caps.type_iso ? \"ISO\" : \"\");\n\n\t\tINIT_LIST_HEAD(&priv_ep->pending_req_list);\n\t\tINIT_LIST_HEAD(&priv_ep->deferred_req_list);\n\t\tINIT_LIST_HEAD(&priv_ep->wa2_descmiss_req_list);\n\t}\n\n\treturn 0;\nerr:\n\tcdns3_free_all_eps(priv_dev);\n\treturn -ENOMEM;\n}\n\nstatic void cdns3_gadget_release(struct device *dev)\n{\n\tstruct cdns3_device *priv_dev = container_of(dev,\n\t\t\tstruct cdns3_device, gadget.dev);\n\n\tkfree(priv_dev);\n}\n\nstatic void cdns3_gadget_exit(struct cdns *cdns)\n{\n\tstruct cdns3_device *priv_dev;\n\n\tpriv_dev = cdns->gadget_dev;\n\n\n\tpm_runtime_mark_last_busy(cdns->dev);\n\tpm_runtime_put_autosuspend(cdns->dev);\n\n\tusb_del_gadget(&priv_dev->gadget);\n\tdevm_free_irq(cdns->dev, cdns->dev_irq, priv_dev);\n\n\tcdns3_free_all_eps(priv_dev);\n\n\twhile (!list_empty(&priv_dev->aligned_buf_list)) {\n\t\tstruct cdns3_aligned_buf *buf;\n\n\t\tbuf = cdns3_next_align_buf(&priv_dev->aligned_buf_list);\n\t\tdma_free_noncoherent(priv_dev->sysdev, buf->size,\n\t\t\t\t  buf->buf,\n\t\t\t\t  buf->dma,\n\t\t\t\t  buf->dir);\n\n\t\tlist_del(&buf->list);\n\t\tkfree(buf);\n\t}\n\n\tdma_free_coherent(priv_dev->sysdev, 8, priv_dev->setup_buf,\n\t\t\t  priv_dev->setup_dma);\n\tdma_pool_destroy(priv_dev->eps_dma_pool);\n\n\tkfree(priv_dev->zlp_buf);\n\tusb_put_gadget(&priv_dev->gadget);\n\tcdns->gadget_dev = NULL;\n\tcdns_drd_gadget_off(cdns);\n}\n\nstatic int cdns3_gadget_start(struct cdns *cdns)\n{\n\tstruct cdns3_device *priv_dev;\n\tu32 max_speed;\n\tint ret;\n\n\tpriv_dev = kzalloc(sizeof(*priv_dev), GFP_KERNEL);\n\tif (!priv_dev)\n\t\treturn -ENOMEM;\n\n\tusb_initialize_gadget(cdns->dev, &priv_dev->gadget,\n\t\t\tcdns3_gadget_release);\n\tcdns->gadget_dev = priv_dev;\n\tpriv_dev->sysdev = cdns->dev;\n\tpriv_dev->dev = cdns->dev;\n\tpriv_dev->regs = cdns->dev_regs;\n\n\tdevice_property_read_u16(priv_dev->dev, \"cdns,on-chip-buff-size\",\n\t\t\t\t &priv_dev->onchip_buffers);\n\n\tif (priv_dev->onchip_buffers <=  0) {\n\t\tu32 reg = readl(&priv_dev->regs->usb_cap2);\n\n\t\tpriv_dev->onchip_buffers = USB_CAP2_ACTUAL_MEM_SIZE(reg);\n\t}\n\n\tif (!priv_dev->onchip_buffers)\n\t\tpriv_dev->onchip_buffers = 256;\n\n\tmax_speed = usb_get_maximum_speed(cdns->dev);\n\n\t \n\tswitch (max_speed) {\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns->dev, \"invalid maximum_speed parameter %d\\n\",\n\t\t\tmax_speed);\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tmax_speed = USB_SPEED_SUPER;\n\t\tbreak;\n\t}\n\n\t \n\tpriv_dev->gadget.max_speed = max_speed;\n\tpriv_dev->gadget.speed = USB_SPEED_UNKNOWN;\n\tpriv_dev->gadget.ops = &cdns3_gadget_ops;\n\tpriv_dev->gadget.name = \"usb-ss-gadget\";\n\tpriv_dev->gadget.quirk_avoids_skb_reserve = 1;\n\tpriv_dev->gadget.irq = cdns->dev_irq;\n\n\tspin_lock_init(&priv_dev->lock);\n\tINIT_WORK(&priv_dev->pending_status_wq,\n\t\t  cdns3_pending_setup_status_handler);\n\n\tINIT_WORK(&priv_dev->aligned_buf_wq,\n\t\t  cdns3_free_aligned_request_buf);\n\n\t \n\tINIT_LIST_HEAD(&priv_dev->gadget.ep_list);\n\tINIT_LIST_HEAD(&priv_dev->aligned_buf_list);\n\tpriv_dev->eps_dma_pool = dma_pool_create(\"cdns3_eps_dma_pool\",\n\t\t\t\t\t\t priv_dev->sysdev,\n\t\t\t\t\t\t TRB_RING_SIZE, 8, 0);\n\tif (!priv_dev->eps_dma_pool) {\n\t\tdev_err(priv_dev->dev, \"Failed to create TRB dma pool\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tret = cdns3_init_eps(priv_dev);\n\tif (ret) {\n\t\tdev_err(priv_dev->dev, \"Failed to create endpoints\\n\");\n\t\tgoto err1;\n\t}\n\n\t \n\tpriv_dev->setup_buf = dma_alloc_coherent(priv_dev->sysdev, 8,\n\t\t\t\t\t\t &priv_dev->setup_dma, GFP_DMA);\n\tif (!priv_dev->setup_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tpriv_dev->dev_ver = readl(&priv_dev->regs->usb_cap6);\n\n\tdev_dbg(priv_dev->dev, \"Device Controller version: %08x\\n\",\n\t\treadl(&priv_dev->regs->usb_cap6));\n\tdev_dbg(priv_dev->dev, \"USB Capabilities:: %08x\\n\",\n\t\treadl(&priv_dev->regs->usb_cap1));\n\tdev_dbg(priv_dev->dev, \"On-Chip memory configuration: %08x\\n\",\n\t\treadl(&priv_dev->regs->usb_cap2));\n\n\tpriv_dev->dev_ver = GET_DEV_BASE_VERSION(priv_dev->dev_ver);\n\tif (priv_dev->dev_ver >= DEV_VER_V2)\n\t\tpriv_dev->gadget.sg_supported = 1;\n\n\tpriv_dev->zlp_buf = kzalloc(CDNS3_EP_ZLP_BUF_SIZE, GFP_KERNEL);\n\tif (!priv_dev->zlp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err3;\n\t}\n\n\t \n\tret = usb_add_gadget(&priv_dev->gadget);\n\tif (ret < 0) {\n\t\tdev_err(priv_dev->dev, \"Failed to add gadget\\n\");\n\t\tgoto err4;\n\t}\n\n\treturn 0;\nerr4:\n\tkfree(priv_dev->zlp_buf);\nerr3:\n\tdma_free_coherent(priv_dev->sysdev, 8, priv_dev->setup_buf,\n\t\t\t  priv_dev->setup_dma);\nerr2:\n\tcdns3_free_all_eps(priv_dev);\nerr1:\n\tdma_pool_destroy(priv_dev->eps_dma_pool);\n\n\tusb_put_gadget(&priv_dev->gadget);\n\tcdns->gadget_dev = NULL;\n\treturn ret;\n}\n\nstatic int __cdns3_gadget_init(struct cdns *cdns)\n{\n\tint ret = 0;\n\n\t \n\tret = dma_set_mask_and_coherent(cdns->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(cdns->dev, \"Failed to set dma mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcdns_drd_gadget_on(cdns);\n\tpm_runtime_get_sync(cdns->dev);\n\n\tret = cdns3_gadget_start(cdns);\n\tif (ret) {\n\t\tpm_runtime_put_sync(cdns->dev);\n\t\treturn ret;\n\t}\n\n\t \n\tret = devm_request_threaded_irq(cdns->dev, cdns->dev_irq,\n\t\t\t\t\tcdns3_device_irq_handler,\n\t\t\t\t\tcdns3_device_thread_irq_handler,\n\t\t\t\t\tIRQF_SHARED, dev_name(cdns->dev),\n\t\t\t\t\tcdns->gadget_dev);\n\n\tif (ret)\n\t\tgoto err0;\n\n\treturn 0;\nerr0:\n\tcdns3_gadget_exit(cdns);\n\treturn ret;\n}\n\nstatic int cdns3_gadget_suspend(struct cdns *cdns, bool do_wakeup)\n__must_hold(&cdns->lock)\n{\n\tstruct cdns3_device *priv_dev = cdns->gadget_dev;\n\n\tspin_unlock(&cdns->lock);\n\tcdns3_disconnect_gadget(priv_dev);\n\tspin_lock(&cdns->lock);\n\n\tpriv_dev->gadget.speed = USB_SPEED_UNKNOWN;\n\tusb_gadget_set_state(&priv_dev->gadget, USB_STATE_NOTATTACHED);\n\tcdns3_hw_reset_eps_config(priv_dev);\n\n\t \n\twritel(0, &priv_dev->regs->usb_ien);\n\n\treturn 0;\n}\n\nstatic int cdns3_gadget_resume(struct cdns *cdns, bool hibernated)\n{\n\tstruct cdns3_device *priv_dev = cdns->gadget_dev;\n\n\tif (!priv_dev->gadget_driver)\n\t\treturn 0;\n\n\tcdns3_gadget_config(priv_dev);\n\tif (hibernated)\n\t\twritel(USB_CONF_DEVEN, &priv_dev->regs->usb_conf);\n\n\treturn 0;\n}\n\n \nint cdns3_gadget_init(struct cdns *cdns)\n{\n\tstruct cdns_role_driver *rdrv;\n\n\trdrv = devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start\t= __cdns3_gadget_init;\n\trdrv->stop\t= cdns3_gadget_exit;\n\trdrv->suspend\t= cdns3_gadget_suspend;\n\trdrv->resume\t= cdns3_gadget_resume;\n\trdrv->state\t= CDNS_ROLE_STATE_INACTIVE;\n\trdrv->name\t= \"gadget\";\n\tcdns->roles[USB_ROLE_DEVICE] = rdrv;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}