{
  "module_name": "host.c",
  "hash_id": "0956b066a6d00e6637256d42b7323adebd9322d33ddc218c7e9ef95c85cd80eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/host.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include \"core.h\"\n#include \"drd.h\"\n#include \"host-export.h\"\n#include <linux/usb/hcd.h>\n#include \"../host/xhci.h\"\n#include \"../host/xhci-plat.h\"\n\n#define XECP_PORT_CAP_REG\t0x8000\n#define XECP_AUX_CTRL_REG1\t0x8120\n\n#define CFG_RXDET_P3_EN\t\tBIT(15)\n#define LPM_2_STB_SWITCH_EN\tBIT(25)\n\nstatic void xhci_cdns3_plat_start(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tu32 value;\n\n\t \n\tvalue = readl(&xhci->op_regs->command);\n\tvalue |= CMD_PM_INDEX;\n\twritel(value, &xhci->op_regs->command);\n\n\tif (hcd->regs) {\n\t\tvalue = readl(hcd->regs + XECP_AUX_CTRL_REG1);\n\t\tvalue |= CFG_RXDET_P3_EN;\n\t\twritel(value, hcd->regs + XECP_AUX_CTRL_REG1);\n\n\t\tvalue = readl(hcd->regs + XECP_PORT_CAP_REG);\n\t\tvalue |= LPM_2_STB_SWITCH_EN;\n\t\twritel(value, hcd->regs + XECP_PORT_CAP_REG);\n\t}\n}\n\nstatic int xhci_cdns3_resume_quirk(struct usb_hcd *hcd)\n{\n\txhci_cdns3_plat_start(hcd);\n\treturn 0;\n}\n\nstatic const struct xhci_plat_priv xhci_plat_cdns3_xhci = {\n\t.quirks = XHCI_SKIP_PHY_INIT | XHCI_AVOID_BEI,\n\t.plat_start = xhci_cdns3_plat_start,\n\t.resume_quirk = xhci_cdns3_resume_quirk,\n};\n\nstatic int __cdns_host_init(struct cdns *cdns)\n{\n\tstruct platform_device *xhci;\n\tint ret;\n\tstruct usb_hcd *hcd;\n\n\tcdns_drd_host_on(cdns);\n\n\txhci = platform_device_alloc(\"xhci-hcd\", PLATFORM_DEVID_AUTO);\n\tif (!xhci) {\n\t\tdev_err(cdns->dev, \"couldn't allocate xHCI device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\txhci->dev.parent = cdns->dev;\n\tcdns->host_dev = xhci;\n\n\tret = platform_device_add_resources(xhci, cdns->xhci_res,\n\t\t\t\t\t    CDNS_XHCI_RESOURCES_NUM);\n\tif (ret) {\n\t\tdev_err(cdns->dev, \"couldn't add resources to xHCI device\\n\");\n\t\tgoto err1;\n\t}\n\n\tcdns->xhci_plat_data = kmemdup(&xhci_plat_cdns3_xhci,\n\t\t\tsizeof(struct xhci_plat_priv), GFP_KERNEL);\n\tif (!cdns->xhci_plat_data) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\tif (cdns->pdata && (cdns->pdata->quirks & CDNS3_DEFAULT_PM_RUNTIME_ALLOW))\n\t\tcdns->xhci_plat_data->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;\n\n\tret = platform_device_add_data(xhci, cdns->xhci_plat_data,\n\t\t\tsizeof(struct xhci_plat_priv));\n\tif (ret)\n\t\tgoto free_memory;\n\n\tret = platform_device_add(xhci);\n\tif (ret) {\n\t\tdev_err(cdns->dev, \"failed to register xHCI device\\n\");\n\t\tgoto free_memory;\n\t}\n\n\t \n\thcd = platform_get_drvdata(xhci);\n\tif (hcd)\n\t\tcdns->xhci_regs = hcd->regs;\n\n\treturn 0;\n\nfree_memory:\n\tkfree(cdns->xhci_plat_data);\nerr1:\n\tplatform_device_put(xhci);\n\treturn ret;\n}\n\nstatic void cdns_host_exit(struct cdns *cdns)\n{\n\tkfree(cdns->xhci_plat_data);\n\tplatform_device_unregister(cdns->host_dev);\n\tcdns->host_dev = NULL;\n\tcdns_drd_host_off(cdns);\n}\n\nint cdns_host_init(struct cdns *cdns)\n{\n\tstruct cdns_role_driver *rdrv;\n\n\trdrv = devm_kzalloc(cdns->dev, sizeof(*rdrv), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start\t= __cdns_host_init;\n\trdrv->stop\t= cdns_host_exit;\n\trdrv->state\t= CDNS_ROLE_STATE_INACTIVE;\n\trdrv->name\t= \"host\";\n\n\tcdns->roles[USB_ROLE_HOST] = rdrv;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}