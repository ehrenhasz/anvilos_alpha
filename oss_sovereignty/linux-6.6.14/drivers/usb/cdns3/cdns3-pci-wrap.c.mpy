{
  "module_name": "cdns3-pci-wrap.c",
  "hash_id": "09bb4dfa5935542f293fe6d87d0f4476ef271e942ed518a0745f16e2ff49b171",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-pci-wrap.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\nstruct cdns3_wrap {\n\tstruct platform_device *plat_dev;\n\tstruct resource dev_res[6];\n\tint devfn;\n};\n\n#define RES_IRQ_HOST_ID\t\t0\n#define RES_IRQ_PERIPHERAL_ID\t1\n#define RES_IRQ_OTG_ID\t\t2\n#define RES_HOST_ID\t\t3\n#define RES_DEV_ID\t\t4\n#define RES_DRD_ID\t\t5\n\n#define PCI_BAR_HOST\t\t0\n#define PCI_BAR_DEV\t\t2\n#define PCI_BAR_OTG\t\t0\n\n#define PCI_DEV_FN_HOST_DEVICE\t0\n#define PCI_DEV_FN_OTG\t\t1\n\n#define PCI_DRIVER_NAME\t\t\"cdns3-pci-usbss\"\n#define PLAT_DRIVER_NAME\t\"cdns-usb3\"\n\n#define CDNS_VENDOR_ID\t\t0x17cd\n#define CDNS_DEVICE_ID\t\t0x0100\n\nstatic struct pci_dev *cdns3_get_second_fun(struct pci_dev *pdev)\n{\n\tstruct pci_dev *func;\n\n\t \n\tfunc = pci_get_device(pdev->vendor, pdev->device, NULL);\n\tif (unlikely(!func))\n\t\treturn NULL;\n\n\tif (func->devfn == pdev->devfn) {\n\t\tfunc = pci_get_device(pdev->vendor, pdev->device, func);\n\t\tif (unlikely(!func))\n\t\t\treturn NULL;\n\t}\n\n\tif (func->devfn != PCI_DEV_FN_HOST_DEVICE &&\n\t    func->devfn != PCI_DEV_FN_OTG) {\n\t\treturn NULL;\n\t}\n\n\treturn func;\n}\n\nstatic int cdns3_pci_probe(struct pci_dev *pdev,\n\t\t\t   const struct pci_device_id *id)\n{\n\tstruct platform_device_info plat_info;\n\tstruct cdns3_wrap *wrap;\n\tstruct resource *res;\n\tstruct pci_dev *func;\n\tint err;\n\n\t \n\tif (!id || (pdev->devfn != PCI_DEV_FN_HOST_DEVICE &&\n\t\t    pdev->devfn != PCI_DEV_FN_OTG))\n\t\treturn -EINVAL;\n\n\tfunc = cdns3_get_second_fun(pdev);\n\tif (unlikely(!func))\n\t\treturn -EINVAL;\n\n\terr = pcim_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Enabling PCI device has failed %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpci_set_master(pdev);\n\n\tif (pci_is_enabled(func)) {\n\t\twrap = pci_get_drvdata(func);\n\t} else {\n\t\twrap = kzalloc(sizeof(*wrap), GFP_KERNEL);\n\t\tif (!wrap) {\n\t\t\tpci_disable_device(pdev);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tres = wrap->dev_res;\n\n\tif (pdev->devfn == PCI_DEV_FN_HOST_DEVICE) {\n\t\t \n\t\tdev_dbg(&pdev->dev, \"Initialize Device resources\\n\");\n\t\tres[RES_DEV_ID].start = pci_resource_start(pdev, PCI_BAR_DEV);\n\t\tres[RES_DEV_ID].end =   pci_resource_end(pdev, PCI_BAR_DEV);\n\t\tres[RES_DEV_ID].name = \"dev\";\n\t\tres[RES_DEV_ID].flags = IORESOURCE_MEM;\n\t\tdev_dbg(&pdev->dev, \"USBSS-DEV physical base addr: %pa\\n\",\n\t\t\t&res[RES_DEV_ID].start);\n\n\t\tres[RES_HOST_ID].start = pci_resource_start(pdev, PCI_BAR_HOST);\n\t\tres[RES_HOST_ID].end = pci_resource_end(pdev, PCI_BAR_HOST);\n\t\tres[RES_HOST_ID].name = \"xhci\";\n\t\tres[RES_HOST_ID].flags = IORESOURCE_MEM;\n\t\tdev_dbg(&pdev->dev, \"USBSS-XHCI physical base addr: %pa\\n\",\n\t\t\t&res[RES_HOST_ID].start);\n\n\t\t \n\t\twrap->dev_res[RES_IRQ_HOST_ID].start = pdev->irq;\n\t\twrap->dev_res[RES_IRQ_HOST_ID].name = \"host\";\n\t\twrap->dev_res[RES_IRQ_HOST_ID].flags = IORESOURCE_IRQ;\n\n\t\t \n\t\twrap->dev_res[RES_IRQ_PERIPHERAL_ID].start = pdev->irq;\n\t\twrap->dev_res[RES_IRQ_PERIPHERAL_ID].name = \"peripheral\";\n\t\twrap->dev_res[RES_IRQ_PERIPHERAL_ID].flags = IORESOURCE_IRQ;\n\t} else {\n\t\tres[RES_DRD_ID].start = pci_resource_start(pdev, PCI_BAR_OTG);\n\t\tres[RES_DRD_ID].end =   pci_resource_end(pdev, PCI_BAR_OTG);\n\t\tres[RES_DRD_ID].name = \"otg\";\n\t\tres[RES_DRD_ID].flags = IORESOURCE_MEM;\n\t\tdev_dbg(&pdev->dev, \"USBSS-DRD physical base addr: %pa\\n\",\n\t\t\t&res[RES_DRD_ID].start);\n\n\t\t \n\t\twrap->dev_res[RES_IRQ_OTG_ID].start = pdev->irq;\n\t\twrap->dev_res[RES_IRQ_OTG_ID].name = \"otg\";\n\t\twrap->dev_res[RES_IRQ_OTG_ID].flags = IORESOURCE_IRQ;\n\t}\n\n\tif (pci_is_enabled(func)) {\n\t\t \n\t\tmemset(&plat_info, 0, sizeof(plat_info));\n\t\tplat_info.parent = &pdev->dev;\n\t\tplat_info.fwnode = pdev->dev.fwnode;\n\t\tplat_info.name = PLAT_DRIVER_NAME;\n\t\tplat_info.id = pdev->devfn;\n\t\twrap->devfn  = pdev->devfn;\n\t\tplat_info.res = wrap->dev_res;\n\t\tplat_info.num_res = ARRAY_SIZE(wrap->dev_res);\n\t\tplat_info.dma_mask = pdev->dma_mask;\n\t\t \n\t\twrap->plat_dev = platform_device_register_full(&plat_info);\n\t\tif (IS_ERR(wrap->plat_dev)) {\n\t\t\tpci_disable_device(pdev);\n\t\t\terr = PTR_ERR(wrap->plat_dev);\n\t\t\tkfree(wrap);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tpci_set_drvdata(pdev, wrap);\n\treturn err;\n}\n\nstatic void cdns3_pci_remove(struct pci_dev *pdev)\n{\n\tstruct cdns3_wrap *wrap;\n\tstruct pci_dev *func;\n\n\tfunc = cdns3_get_second_fun(pdev);\n\n\twrap = (struct cdns3_wrap *)pci_get_drvdata(pdev);\n\tif (wrap->devfn == pdev->devfn)\n\t\tplatform_device_unregister(wrap->plat_dev);\n\n\tif (!pci_is_enabled(func))\n\t\tkfree(wrap);\n}\n\nstatic const struct pci_device_id cdns3_pci_ids[] = {\n\t{ PCI_DEVICE(CDNS_VENDOR_ID, CDNS_DEVICE_ID), },\n\t{ 0, }\n};\n\nstatic struct pci_driver cdns3_pci_driver = {\n\t.name = PCI_DRIVER_NAME,\n\t.id_table = cdns3_pci_ids,\n\t.probe = cdns3_pci_probe,\n\t.remove = cdns3_pci_remove,\n};\n\nmodule_pci_driver(cdns3_pci_driver);\nMODULE_DEVICE_TABLE(pci, cdns3_pci_ids);\n\nMODULE_AUTHOR(\"Pawel Laszczak <pawell@cadence.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence USBSS PCI wrapper\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}