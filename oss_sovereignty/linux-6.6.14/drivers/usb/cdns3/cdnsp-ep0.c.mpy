{
  "module_name": "cdnsp-ep0.c",
  "hash_id": "3c0a11d132704902e166a2ffd500be6aac3d13eda265f9619d81f6bbb5aa79eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdnsp-ep0.c",
  "human_readable_source": "\n \n\n#include <linux/usb/composite.h>\n#include <linux/usb/gadget.h>\n#include <linux/list.h>\n\n#include \"cdnsp-gadget.h\"\n#include \"cdnsp-trace.h\"\n\nstatic void cdnsp_ep0_stall(struct cdnsp_device *pdev)\n{\n\tstruct cdnsp_request *preq;\n\tstruct cdnsp_ep *pep;\n\n\tpep = &pdev->eps[0];\n\tpreq = next_request(&pep->pending_list);\n\n\tif (pdev->three_stage_setup) {\n\t\tcdnsp_halt_endpoint(pdev, pep, true);\n\n\t\tif (preq)\n\t\t\tcdnsp_gadget_giveback(pep, preq, -ECONNRESET);\n\t} else {\n\t\tpep->ep_state |= EP0_HALTED_STATUS;\n\n\t\tif (preq)\n\t\t\tlist_del(&preq->list);\n\n\t\tcdnsp_status_stage(pdev);\n\t}\n}\n\nstatic int cdnsp_ep0_delegate_req(struct cdnsp_device *pdev,\n\t\t\t\t  struct usb_ctrlrequest *ctrl)\n{\n\tint ret;\n\n\tspin_unlock(&pdev->lock);\n\tret = pdev->gadget_driver->setup(&pdev->gadget, ctrl);\n\tspin_lock(&pdev->lock);\n\n\treturn ret;\n}\n\nstatic int cdnsp_ep0_set_config(struct cdnsp_device *pdev,\n\t\t\t\tstruct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = pdev->gadget.state;\n\tu32 cfg;\n\tint ret;\n\n\tcfg = le16_to_cpu(ctrl->wValue);\n\n\tswitch (state) {\n\tcase USB_STATE_ADDRESS:\n\t\ttrace_cdnsp_ep0_set_config(\"from Address state\");\n\t\tbreak;\n\tcase USB_STATE_CONFIGURED:\n\t\ttrace_cdnsp_ep0_set_config(\"from Configured state\");\n\t\tbreak;\n\tdefault:\n\t\tdev_err(pdev->dev, \"Set Configuration - bad device state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = cdnsp_ep0_delegate_req(pdev, ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!cfg)\n\t\tusb_gadget_set_state(&pdev->gadget, USB_STATE_ADDRESS);\n\n\treturn 0;\n}\n\nstatic int cdnsp_ep0_set_address(struct cdnsp_device *pdev,\n\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = pdev->gadget.state;\n\tstruct cdnsp_slot_ctx *slot_ctx;\n\tunsigned int slot_state;\n\tint ret;\n\tu32 addr;\n\n\taddr = le16_to_cpu(ctrl->wValue);\n\n\tif (addr > 127) {\n\t\tdev_err(pdev->dev, \"Invalid device address %d\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->out_ctx);\n\n\tif (state == USB_STATE_CONFIGURED) {\n\t\tdev_err(pdev->dev, \"Can't Set Address from Configured State\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpdev->device_address = le16_to_cpu(ctrl->wValue);\n\n\tslot_ctx = cdnsp_get_slot_ctx(&pdev->out_ctx);\n\tslot_state = GET_SLOT_STATE(le32_to_cpu(slot_ctx->dev_state));\n\tif (slot_state == SLOT_STATE_ADDRESSED)\n\t\tcdnsp_reset_device(pdev);\n\n\t \n\tret = cdnsp_setup_device(pdev, SETUP_CONTEXT_ADDRESS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (addr)\n\t\tusb_gadget_set_state(&pdev->gadget, USB_STATE_ADDRESS);\n\telse\n\t\tusb_gadget_set_state(&pdev->gadget, USB_STATE_DEFAULT);\n\n\treturn 0;\n}\n\nint cdnsp_status_stage(struct cdnsp_device *pdev)\n{\n\tpdev->ep0_stage = CDNSP_STATUS_STAGE;\n\tpdev->ep0_preq.request.length = 0;\n\n\treturn cdnsp_ep_enqueue(pdev->ep0_preq.pep, &pdev->ep0_preq);\n}\n\nstatic int cdnsp_w_index_to_ep_index(u16 wIndex)\n{\n\tif (!(wIndex & USB_ENDPOINT_NUMBER_MASK))\n\t\treturn 0;\n\n\treturn ((wIndex & USB_ENDPOINT_NUMBER_MASK) * 2) +\n\t\t(wIndex & USB_ENDPOINT_DIR_MASK ? 1 : 0) - 1;\n}\n\nstatic int cdnsp_ep0_handle_status(struct cdnsp_device *pdev,\n\t\t\t\t   struct usb_ctrlrequest *ctrl)\n{\n\tstruct cdnsp_ep *pep;\n\t__le16 *response;\n\tint ep_sts = 0;\n\tu16 status = 0;\n\tu32 recipient;\n\n\trecipient = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recipient) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = pdev->gadget.is_selfpowered;\n\t\tstatus |= pdev->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\n\t\tif (pdev->gadget.speed >= USB_SPEED_SUPER) {\n\t\t\tstatus |= pdev->u1_allowed << USB_DEV_STAT_U1_ENABLED;\n\t\t\tstatus |= pdev->u2_allowed << USB_DEV_STAT_U2_ENABLED;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\t \n\t\treturn cdnsp_ep0_delegate_req(pdev, ctrl);\n\tcase USB_RECIP_ENDPOINT:\n\t\tep_sts = cdnsp_w_index_to_ep_index(le16_to_cpu(ctrl->wIndex));\n\t\tpep = &pdev->eps[ep_sts];\n\t\tep_sts = GET_EP_CTX_STATE(pep->out_ctx);\n\n\t\t \n\t\tif (ep_sts == EP_STATE_HALTED)\n\t\t\tstatus =  BIT(USB_ENDPOINT_HALT);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tresponse = (__le16 *)pdev->setup_buf;\n\t*response = cpu_to_le16(status);\n\n\tpdev->ep0_preq.request.length = sizeof(*response);\n\tpdev->ep0_preq.request.buf = pdev->setup_buf;\n\n\treturn cdnsp_ep_enqueue(pdev->ep0_preq.pep, &pdev->ep0_preq);\n}\n\nstatic void cdnsp_enter_test_mode(struct cdnsp_device *pdev)\n{\n\tu32 temp;\n\n\ttemp = readl(&pdev->active_port->regs->portpmsc) & ~GENMASK(31, 28);\n\ttemp |= PORT_TEST_MODE(pdev->test_mode);\n\twritel(temp, &pdev->active_port->regs->portpmsc);\n}\n\nstatic int cdnsp_ep0_handle_feature_device(struct cdnsp_device *pdev,\n\t\t\t\t\t   struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t   int set)\n{\n\tenum usb_device_state state;\n\tenum usb_device_speed speed;\n\tu16 tmode;\n\n\tstate = pdev->gadget.state;\n\tspeed = pdev->gadget.speed;\n\n\tswitch (le16_to_cpu(ctrl->wValue)) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tpdev->may_wakeup = !!set;\n\t\ttrace_cdnsp_may_wakeup(set);\n\t\tbreak;\n\tcase USB_DEVICE_U1_ENABLE:\n\t\tif (state != USB_STATE_CONFIGURED || speed < USB_SPEED_SUPER)\n\t\t\treturn -EINVAL;\n\n\t\tpdev->u1_allowed = !!set;\n\t\ttrace_cdnsp_u1(set);\n\t\tbreak;\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tif (state != USB_STATE_CONFIGURED || speed < USB_SPEED_SUPER)\n\t\t\treturn -EINVAL;\n\n\t\tpdev->u2_allowed = !!set;\n\t\ttrace_cdnsp_u2(set);\n\t\tbreak;\n\tcase USB_DEVICE_LTM_ENABLE:\n\t\treturn -EINVAL;\n\tcase USB_DEVICE_TEST_MODE:\n\t\tif (state != USB_STATE_CONFIGURED || speed > USB_SPEED_HIGH)\n\t\t\treturn -EINVAL;\n\n\t\ttmode = le16_to_cpu(ctrl->wIndex);\n\n\t\tif (!set || (tmode & 0xff) != 0)\n\t\t\treturn -EINVAL;\n\n\t\ttmode = tmode >> 8;\n\n\t\tif (tmode > USB_TEST_FORCE_ENABLE || tmode < USB_TEST_J)\n\t\t\treturn -EINVAL;\n\n\t\tpdev->test_mode = tmode;\n\n\t\t \n\t\tcdnsp_enter_test_mode(pdev);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdnsp_ep0_handle_feature_intf(struct cdnsp_device *pdev,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t int set)\n{\n\tu16 wValue, wIndex;\n\tint ret;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\twIndex = le16_to_cpu(ctrl->wIndex);\n\n\tswitch (wValue) {\n\tcase USB_INTRF_FUNC_SUSPEND:\n\t\tret = cdnsp_ep0_delegate_req(pdev, ctrl);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (wIndex & USB_INTRF_FUNC_SUSPEND_RW)\n\t\t\tpdev->may_wakeup++;\n\t\telse\n\t\t\tif (pdev->may_wakeup > 0)\n\t\t\t\tpdev->may_wakeup--;\n\n\t\treturn 0;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdnsp_ep0_handle_feature_endpoint(struct cdnsp_device *pdev,\n\t\t\t\t\t     struct usb_ctrlrequest *ctrl,\n\t\t\t\t\t     int set)\n{\n\tstruct cdnsp_ep *pep;\n\tu16 wValue;\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\tpep = &pdev->eps[cdnsp_w_index_to_ep_index(le16_to_cpu(ctrl->wIndex))];\n\n\tswitch (wValue) {\n\tcase USB_ENDPOINT_HALT:\n\t\tif (!set && (pep->ep_state & EP_WEDGE)) {\n\t\t\t \n\t\t\tcdnsp_halt_endpoint(pdev, pep, 0);\n\t\t\tcdnsp_halt_endpoint(pdev, pep, 1);\n\t\t\tbreak;\n\t\t}\n\n\t\treturn cdnsp_halt_endpoint(pdev, pep, set);\n\tdefault:\n\t\tdev_warn(pdev->dev, \"WARN Incorrect wValue %04x\\n\", wValue);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int cdnsp_ep0_handle_feature(struct cdnsp_device *pdev,\n\t\t\t\t    struct usb_ctrlrequest *ctrl,\n\t\t\t\t    int set)\n{\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\treturn cdnsp_ep0_handle_feature_device(pdev, ctrl, set);\n\tcase USB_RECIP_INTERFACE:\n\t\treturn cdnsp_ep0_handle_feature_intf(pdev, ctrl, set);\n\tcase USB_RECIP_ENDPOINT:\n\t\treturn cdnsp_ep0_handle_feature_endpoint(pdev, ctrl, set);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int cdnsp_ep0_set_sel(struct cdnsp_device *pdev,\n\t\t\t     struct usb_ctrlrequest *ctrl)\n{\n\tenum usb_device_state state = pdev->gadget.state;\n\tu16 wLength;\n\n\tif (state == USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\twLength = le16_to_cpu(ctrl->wLength);\n\n\tif (wLength != 6) {\n\t\tdev_err(pdev->dev, \"Set SEL should be 6 bytes, got %d\\n\",\n\t\t\twLength);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpdev->ep0_preq.request.length = 6;\n\tpdev->ep0_preq.request.buf = pdev->setup_buf;\n\n\treturn cdnsp_ep_enqueue(pdev->ep0_preq.pep, &pdev->ep0_preq);\n}\n\nstatic int cdnsp_ep0_set_isoch_delay(struct cdnsp_device *pdev,\n\t\t\t\t     struct usb_ctrlrequest *ctrl)\n{\n\tif (le16_to_cpu(ctrl->wIndex) || le16_to_cpu(ctrl->wLength))\n\t\treturn -EINVAL;\n\n\tpdev->gadget.isoch_delay = le16_to_cpu(ctrl->wValue);\n\n\treturn 0;\n}\n\nstatic int cdnsp_ep0_std_request(struct cdnsp_device *pdev,\n\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tint ret;\n\n\tswitch (ctrl->bRequest) {\n\tcase USB_REQ_GET_STATUS:\n\t\tret = cdnsp_ep0_handle_status(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tret = cdnsp_ep0_handle_feature(pdev, ctrl, 0);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tret = cdnsp_ep0_handle_feature(pdev, ctrl, 1);\n\t\tbreak;\n\tcase USB_REQ_SET_ADDRESS:\n\t\tret = cdnsp_ep0_set_address(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tret = cdnsp_ep0_set_config(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_SEL:\n\t\tret = cdnsp_ep0_set_sel(pdev, ctrl);\n\t\tbreak;\n\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\tret = cdnsp_ep0_set_isoch_delay(pdev, ctrl);\n\t\tbreak;\n\tdefault:\n\t\tret = cdnsp_ep0_delegate_req(pdev, ctrl);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nvoid cdnsp_setup_analyze(struct cdnsp_device *pdev)\n{\n\tstruct usb_ctrlrequest *ctrl = &pdev->setup;\n\tint ret = -EINVAL;\n\tu16 len;\n\n\ttrace_cdnsp_ctrl_req(ctrl);\n\n\tif (!pdev->gadget_driver)\n\t\tgoto out;\n\n\tif (pdev->gadget.state == USB_STATE_NOTATTACHED) {\n\t\tdev_err(pdev->dev, \"ERR: Setup detected in unattached state\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (pdev->eps[0].ep_state & EP_HALTED) {\n\t\ttrace_cdnsp_ep0_halted(\"Restore to normal state\");\n\t\tcdnsp_halt_endpoint(pdev, &pdev->eps[0], 0);\n\t}\n\n\t \n\tif (!list_empty(&pdev->eps[0].pending_list)) {\n\t\tstruct cdnsp_request\t*req;\n\n\t\ttrace_cdnsp_ep0_request(\"Remove previous\");\n\t\treq = next_request(&pdev->eps[0].pending_list);\n\t\tcdnsp_ep_dequeue(&pdev->eps[0], req);\n\t}\n\n\tlen = le16_to_cpu(ctrl->wLength);\n\tif (!len) {\n\t\tpdev->three_stage_setup = false;\n\t\tpdev->ep0_expect_in = false;\n\t} else {\n\t\tpdev->three_stage_setup = true;\n\t\tpdev->ep0_expect_in = !!(ctrl->bRequestType & USB_DIR_IN);\n\t}\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\tret = cdnsp_ep0_std_request(pdev, ctrl);\n\telse\n\t\tret = cdnsp_ep0_delegate_req(pdev, ctrl);\n\n\tif (ret == USB_GADGET_DELAYED_STATUS) {\n\t\ttrace_cdnsp_ep0_status_stage(\"delayed\");\n\t\treturn;\n\t}\nout:\n\tif (ret < 0)\n\t\tcdnsp_ep0_stall(pdev);\n\telse if (!len && pdev->ep0_stage != CDNSP_STATUS_STAGE)\n\t\tcdnsp_status_stage(pdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}