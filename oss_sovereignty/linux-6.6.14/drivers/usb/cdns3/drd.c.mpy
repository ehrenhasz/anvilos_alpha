{
  "module_name": "drd.c",
  "hash_id": "ea7ff9d590aaa37c7dde6dc37d268b328ca2744ef0bb1b3f62e415c9d2b02e0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/drd.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/usb/otg.h>\n\n#include \"drd.h\"\n#include \"core.h\"\n\n \nstatic int cdns_set_mode(struct cdns *cdns, enum usb_dr_mode mode)\n{\n\tvoid __iomem  *override_reg;\n\tu32 reg;\n\n\tswitch (mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tdev_dbg(cdns->dev, \"Set controller to OTG mode\\n\");\n\n\t\tif (cdns->version == CDNSP_CONTROLLER_V2)\n\t\t\toverride_reg = &cdns->otg_cdnsp_regs->override;\n\t\telse if (cdns->version == CDNS3_CONTROLLER_V1)\n\t\t\toverride_reg = &cdns->otg_v1_regs->override;\n\t\telse\n\t\t\toverride_reg = &cdns->otg_v0_regs->ctrl1;\n\n\t\treg = readl(override_reg);\n\n\t\tif (cdns->version != CDNS3_CONTROLLER_V0)\n\t\t\treg |= OVERRIDE_IDPULLUP;\n\t\telse\n\t\t\treg |= OVERRIDE_IDPULLUP_V0;\n\n\t\twritel(reg, override_reg);\n\n\t\tif (cdns->version == CDNS3_CONTROLLER_V1) {\n\t\t\t \n\t\t\tif (cdns->phyrst_a_enable) {\n\t\t\t\treg = readl(&cdns->otg_v1_regs->phyrst_cfg);\n\t\t\t\treg |= PHYRST_CFG_PHYRST_A_ENABLE;\n\t\t\t\twritel(reg, &cdns->otg_v1_regs->phyrst_cfg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tusleep_range(50000, 60000);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns->dev, \"Unsupported mode of operation %d\\n\", mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint cdns_get_id(struct cdns *cdns)\n{\n\tint id;\n\n\tid = readl(&cdns->otg_regs->sts) & OTGSTS_ID_VALUE;\n\tdev_dbg(cdns->dev, \"OTG ID: %d\", id);\n\n\treturn id;\n}\n\nint cdns_get_vbus(struct cdns *cdns)\n{\n\tint vbus;\n\n\tvbus = !!(readl(&cdns->otg_regs->sts) & OTGSTS_VBUS_VALID);\n\tdev_dbg(cdns->dev, \"OTG VBUS: %d\", vbus);\n\n\treturn vbus;\n}\n\nvoid cdns_clear_vbus(struct cdns *cdns)\n{\n\tu32 reg;\n\n\tif (cdns->version != CDNSP_CONTROLLER_V2)\n\t\treturn;\n\n\treg = readl(&cdns->otg_cdnsp_regs->override);\n\treg |= OVERRIDE_SESS_VLD_SEL;\n\twritel(reg, &cdns->otg_cdnsp_regs->override);\n}\nEXPORT_SYMBOL_GPL(cdns_clear_vbus);\n\nvoid cdns_set_vbus(struct cdns *cdns)\n{\n\tu32 reg;\n\n\tif (cdns->version != CDNSP_CONTROLLER_V2)\n\t\treturn;\n\n\treg = readl(&cdns->otg_cdnsp_regs->override);\n\treg &= ~OVERRIDE_SESS_VLD_SEL;\n\twritel(reg, &cdns->otg_cdnsp_regs->override);\n}\nEXPORT_SYMBOL_GPL(cdns_set_vbus);\n\nbool cdns_is_host(struct cdns *cdns)\n{\n\tif (cdns->dr_mode == USB_DR_MODE_HOST)\n\t\treturn true;\n\telse if (cdns_get_id(cdns) == CDNS3_ID_HOST)\n\t\treturn true;\n\n\treturn false;\n}\n\nbool cdns_is_device(struct cdns *cdns)\n{\n\tif (cdns->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\treturn true;\n\telse if (cdns->dr_mode == USB_DR_MODE_OTG)\n\t\tif (cdns_get_id(cdns) == CDNS3_ID_PERIPHERAL)\n\t\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void cdns_otg_disable_irq(struct cdns *cdns)\n{\n\twritel(0, &cdns->otg_irq_regs->ien);\n}\n\n \nstatic void cdns_otg_enable_irq(struct cdns *cdns)\n{\n\twritel(OTGIEN_ID_CHANGE_INT | OTGIEN_VBUSVALID_RISE_INT |\n\t       OTGIEN_VBUSVALID_FALL_INT, &cdns->otg_irq_regs->ien);\n}\n\n \nint cdns_drd_host_on(struct cdns *cdns)\n{\n\tu32 val, ready_bit;\n\tint ret;\n\n\t \n\twritel(OTGCMD_HOST_BUS_REQ | OTGCMD_OTG_DIS,\n\t       &cdns->otg_regs->cmd);\n\n\tif (cdns->version == CDNSP_CONTROLLER_V2)\n\t\tready_bit = OTGSTS_CDNSP_XHCI_READY;\n\telse\n\t\tready_bit = OTGSTS_CDNS3_XHCI_READY;\n\n\tdev_dbg(cdns->dev, \"Waiting till Host mode is turned on\\n\");\n\tret = readl_poll_timeout_atomic(&cdns->otg_regs->sts, val,\n\t\t\t\t\tval & ready_bit, 1, 100000);\n\n\tif (ret)\n\t\tdev_err(cdns->dev, \"timeout waiting for xhci_ready\\n\");\n\n\tphy_set_mode(cdns->usb2_phy, PHY_MODE_USB_HOST);\n\tphy_set_mode(cdns->usb3_phy, PHY_MODE_USB_HOST);\n\treturn ret;\n}\n\n \nvoid cdns_drd_host_off(struct cdns *cdns)\n{\n\tu32 val;\n\n\twritel(OTGCMD_HOST_BUS_DROP | OTGCMD_DEV_BUS_DROP |\n\t       OTGCMD_DEV_POWER_OFF | OTGCMD_HOST_POWER_OFF,\n\t       &cdns->otg_regs->cmd);\n\n\t \n\treadl_poll_timeout_atomic(&cdns->otg_regs->state, val,\n\t\t\t\t  !(val & OTGSTATE_HOST_STATE_MASK),\n\t\t\t\t  1, 2000000);\n\tphy_set_mode(cdns->usb2_phy, PHY_MODE_INVALID);\n\tphy_set_mode(cdns->usb3_phy, PHY_MODE_INVALID);\n}\n\n \nint cdns_drd_gadget_on(struct cdns *cdns)\n{\n\tu32 reg = OTGCMD_OTG_DIS;\n\tu32 ready_bit;\n\tint ret, val;\n\n\t \n\twritel(OTGCMD_DEV_BUS_REQ | reg, &cdns->otg_regs->cmd);\n\n\tdev_dbg(cdns->dev, \"Waiting till Device mode is turned on\\n\");\n\n\tif (cdns->version == CDNSP_CONTROLLER_V2)\n\t\tready_bit = OTGSTS_CDNSP_DEV_READY;\n\telse\n\t\tready_bit = OTGSTS_CDNS3_DEV_READY;\n\n\tret = readl_poll_timeout_atomic(&cdns->otg_regs->sts, val,\n\t\t\t\t\tval & ready_bit, 1, 100000);\n\tif (ret) {\n\t\tdev_err(cdns->dev, \"timeout waiting for dev_ready\\n\");\n\t\treturn ret;\n\t}\n\n\tphy_set_mode(cdns->usb2_phy, PHY_MODE_USB_DEVICE);\n\tphy_set_mode(cdns->usb3_phy, PHY_MODE_USB_DEVICE);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cdns_drd_gadget_on);\n\n \nvoid cdns_drd_gadget_off(struct cdns *cdns)\n{\n\tu32 val;\n\n\t \n\tusleep_range(20, 30);\n\twritel(OTGCMD_HOST_BUS_DROP | OTGCMD_DEV_BUS_DROP |\n\t       OTGCMD_DEV_POWER_OFF | OTGCMD_HOST_POWER_OFF,\n\t       &cdns->otg_regs->cmd);\n\t \n\treadl_poll_timeout_atomic(&cdns->otg_regs->state, val,\n\t\t\t\t  !(val & OTGSTATE_DEV_STATE_MASK),\n\t\t\t\t  1, 2000000);\n\tphy_set_mode(cdns->usb2_phy, PHY_MODE_INVALID);\n\tphy_set_mode(cdns->usb3_phy, PHY_MODE_INVALID);\n}\nEXPORT_SYMBOL_GPL(cdns_drd_gadget_off);\n\n \nstatic int cdns_init_otg_mode(struct cdns *cdns)\n{\n\tint ret;\n\n\tcdns_otg_disable_irq(cdns);\n\t \n\twritel(~0, &cdns->otg_irq_regs->ivect);\n\n\tret = cdns_set_mode(cdns, USB_DR_MODE_OTG);\n\tif (ret)\n\t\treturn ret;\n\n\tcdns_otg_enable_irq(cdns);\n\n\treturn 0;\n}\n\n \nint cdns_drd_update_mode(struct cdns *cdns)\n{\n\tint ret;\n\n\tswitch (cdns->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tret = cdns_set_mode(cdns, USB_DR_MODE_PERIPHERAL);\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tret = cdns_set_mode(cdns, USB_DR_MODE_HOST);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tret = cdns_init_otg_mode(cdns);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cdns->dev, \"Unsupported mode of operation %d\\n\",\n\t\t\tcdns->dr_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic irqreturn_t cdns_drd_thread_irq(int irq, void *data)\n{\n\tstruct cdns *cdns = data;\n\n\tcdns_hw_role_switch(cdns);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t cdns_drd_irq(int irq, void *data)\n{\n\tirqreturn_t ret = IRQ_NONE;\n\tstruct cdns *cdns = data;\n\tu32 reg;\n\n\tif (cdns->dr_mode != USB_DR_MODE_OTG)\n\t\treturn IRQ_NONE;\n\n\tif (cdns->in_lpm)\n\t\treturn ret;\n\n\treg = readl(&cdns->otg_irq_regs->ivect);\n\n\tif (!reg)\n\t\treturn IRQ_NONE;\n\n\tif (reg & OTGIEN_ID_CHANGE_INT) {\n\t\tdev_dbg(cdns->dev, \"OTG IRQ: new ID: %d\\n\",\n\t\t\tcdns_get_id(cdns));\n\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\tif (reg & (OTGIEN_VBUSVALID_RISE_INT | OTGIEN_VBUSVALID_FALL_INT)) {\n\t\tdev_dbg(cdns->dev, \"OTG IRQ: new VBUS: %d\\n\",\n\t\t\tcdns_get_vbus(cdns));\n\n\t\tret = IRQ_WAKE_THREAD;\n\t}\n\n\twritel(~0, &cdns->otg_irq_regs->ivect);\n\treturn ret;\n}\n\nint cdns_drd_init(struct cdns *cdns)\n{\n\tvoid __iomem *regs;\n\tu32 state;\n\tint ret;\n\n\tregs = devm_ioremap_resource(cdns->dev, &cdns->otg_res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\t \n\tcdns->otg_v0_regs = regs;\n\tif (!readl(&cdns->otg_v0_regs->cmd)) {\n\t\tcdns->version  = CDNS3_CONTROLLER_V0;\n\t\tcdns->otg_v1_regs = NULL;\n\t\tcdns->otg_cdnsp_regs = NULL;\n\t\tcdns->otg_regs = regs;\n\t\tcdns->otg_irq_regs = (struct cdns_otg_irq_regs __iomem  *)\n\t\t\t\t     &cdns->otg_v0_regs->ien;\n\t\twritel(1, &cdns->otg_v0_regs->simulate);\n\t\tdev_dbg(cdns->dev, \"DRD version v0 (%08x)\\n\",\n\t\t\t readl(&cdns->otg_v0_regs->version));\n\t} else {\n\t\tcdns->otg_v0_regs = NULL;\n\t\tcdns->otg_v1_regs = regs;\n\t\tcdns->otg_cdnsp_regs = regs;\n\n\t\tcdns->otg_regs = (void __iomem *)&cdns->otg_v1_regs->cmd;\n\n\t\tif (readl(&cdns->otg_cdnsp_regs->did) == OTG_CDNSP_DID) {\n\t\t\tcdns->otg_irq_regs = (struct cdns_otg_irq_regs __iomem *)\n\t\t\t\t\t      &cdns->otg_cdnsp_regs->ien;\n\t\t\tcdns->version  = CDNSP_CONTROLLER_V2;\n\t\t} else {\n\t\t\tcdns->otg_irq_regs = (struct cdns_otg_irq_regs __iomem *)\n\t\t\t\t\t      &cdns->otg_v1_regs->ien;\n\t\t\twritel(1, &cdns->otg_v1_regs->simulate);\n\t\t\tcdns->version  = CDNS3_CONTROLLER_V1;\n\t\t}\n\n\t\tdev_dbg(cdns->dev, \"DRD version v1 (ID: %08x, rev: %08x)\\n\",\n\t\t\t readl(&cdns->otg_v1_regs->did),\n\t\t\t readl(&cdns->otg_v1_regs->rid));\n\t}\n\n\tstate = OTGSTS_STRAP(readl(&cdns->otg_regs->sts));\n\n\t \n\tcdns->dr_mode = USB_DR_MODE_OTG;\n\n\tif ((cdns->version == CDNSP_CONTROLLER_V2 &&\n\t     state == OTGSTS_CDNSP_STRAP_HOST) ||\n\t    (cdns->version != CDNSP_CONTROLLER_V2 &&\n\t     state == OTGSTS_STRAP_HOST)) {\n\t\tdev_dbg(cdns->dev, \"Controller strapped to HOST\\n\");\n\t\tcdns->dr_mode = USB_DR_MODE_HOST;\n\t} else if ((cdns->version == CDNSP_CONTROLLER_V2 &&\n\t\t    state == OTGSTS_CDNSP_STRAP_GADGET) ||\n\t\t   (cdns->version != CDNSP_CONTROLLER_V2 &&\n\t\t    state == OTGSTS_STRAP_GADGET)) {\n\t\tdev_dbg(cdns->dev, \"Controller strapped to PERIPHERAL\\n\");\n\t\tcdns->dr_mode = USB_DR_MODE_PERIPHERAL;\n\t}\n\n\tret = devm_request_threaded_irq(cdns->dev, cdns->otg_irq,\n\t\t\t\t\tcdns_drd_irq,\n\t\t\t\t\tcdns_drd_thread_irq,\n\t\t\t\t\tIRQF_SHARED,\n\t\t\t\t\tdev_name(cdns->dev), cdns);\n\tif (ret) {\n\t\tdev_err(cdns->dev, \"couldn't get otg_irq\\n\");\n\t\treturn ret;\n\t}\n\n\tstate = readl(&cdns->otg_regs->sts);\n\tif (OTGSTS_OTG_NRDY(state)) {\n\t\tdev_err(cdns->dev, \"Cadence USB3 OTG device not ready\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nint cdns_drd_exit(struct cdns *cdns)\n{\n\tcdns_otg_disable_irq(cdns);\n\n\treturn 0;\n}\n\n\n \nbool cdns_power_is_lost(struct cdns *cdns)\n{\n\tif (cdns->version == CDNS3_CONTROLLER_V0) {\n\t\tif (!(readl(&cdns->otg_v0_regs->simulate) & BIT(0)))\n\t\t\treturn true;\n\t} else {\n\t\tif (!(readl(&cdns->otg_v1_regs->simulate) & BIT(0)))\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(cdns_power_is_lost);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}