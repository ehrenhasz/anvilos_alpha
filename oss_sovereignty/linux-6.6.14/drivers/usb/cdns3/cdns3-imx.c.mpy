{
  "module_name": "cdns3-imx.c",
  "hash_id": "5d5a698b016cbdac34f75697fc9aaba98ea994fee858adec33e08d41afeb576d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-imx.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/of_platform.h>\n#include <linux/iopoll.h>\n#include <linux/pm_runtime.h>\n#include \"core.h\"\n\n#define USB3_CORE_CTRL1    0x00\n#define USB3_CORE_CTRL2    0x04\n#define USB3_INT_REG       0x08\n#define USB3_CORE_STATUS   0x0c\n#define XHCI_DEBUG_LINK_ST 0x10\n#define XHCI_DEBUG_BUS     0x14\n#define USB3_SSPHY_CTRL1   0x40\n#define USB3_SSPHY_CTRL2   0x44\n#define USB3_SSPHY_STATUS  0x4c\n#define USB2_PHY_CTRL1     0x50\n#define USB2_PHY_CTRL2     0x54\n#define USB2_PHY_STATUS    0x5c\n\n \n\n \n#define SW_RESET_MASK\tGENMASK(31, 26)\n#define PWR_SW_RESET\tBIT(31)\n#define APB_SW_RESET\tBIT(30)\n#define AXI_SW_RESET\tBIT(29)\n#define RW_SW_RESET\tBIT(28)\n#define PHY_SW_RESET\tBIT(27)\n#define PHYAHB_SW_RESET\tBIT(26)\n#define ALL_SW_RESET\t(PWR_SW_RESET | APB_SW_RESET | AXI_SW_RESET | \\\n\t\tRW_SW_RESET | PHY_SW_RESET | PHYAHB_SW_RESET)\n#define OC_DISABLE\tBIT(9)\n#define MDCTRL_CLK_SEL\tBIT(7)\n#define MODE_STRAP_MASK\t(0x7)\n#define DEV_MODE\t(1 << 2)\n#define HOST_MODE\t(1 << 1)\n#define OTG_MODE\t(1 << 0)\n\n \n#define CLK_125_REQ\tBIT(29)\n#define LPM_CLK_REQ\tBIT(28)\n#define DEVU3_WAEKUP_EN\tBIT(14)\n#define OTG_WAKEUP_EN\tBIT(12)\n#define DEV_INT_EN\t(3 << 8)  \n#define HOST_INT1_EN\t(1 << 0)  \n\n \n#define MDCTRL_CLK_STATUS\tBIT(15)\n#define DEV_POWER_ON_READY\tBIT(13)\n#define HOST_POWER_ON_READY\tBIT(12)\n\n \n#define CLK_VALID_MASK\t\t(0x3f << 26)\n#define CLK_VALID_COMPARE_BITS\t(0xf << 28)\n#define PHY_REFCLK_REQ\t\t(1 << 0)\n\n \n#define OTGSTS\t\t0x4\n \n#define OTG_NRDY\tBIT(11)\n\n \n#define XECP_PM_PMCSR\t\t0x8018\n#define XECP_AUX_CTRL_REG1\t0x8120\n\n \n \n#define CFG_RXDET_P3_EN\t\tBIT(15)\n\n \n#define PS_MASK\t\t\tGENMASK(1, 0)\n#define PS_D0\t\t\t0\n#define PS_D1\t\t\t1\n\nstruct cdns_imx {\n\tstruct device *dev;\n\tvoid __iomem *noncore;\n\tstruct clk_bulk_data *clks;\n\tint num_clks;\n\tstruct platform_device *cdns3_pdev;\n};\n\nstatic inline u32 cdns_imx_readl(struct cdns_imx *data, u32 offset)\n{\n\treturn readl(data->noncore + offset);\n}\n\nstatic inline void cdns_imx_writel(struct cdns_imx *data, u32 offset, u32 value)\n{\n\twritel(value, data->noncore + offset);\n}\n\nstatic const struct clk_bulk_data imx_cdns3_core_clks[] = {\n\t{ .id = \"lpm\" },\n\t{ .id = \"bus\" },\n\t{ .id = \"aclk\" },\n\t{ .id = \"ipg\" },\n\t{ .id = \"core\" },\n};\n\nstatic int cdns_imx_noncore_init(struct cdns_imx *data)\n{\n\tu32 value;\n\tint ret;\n\tstruct device *dev = data->dev;\n\n\tcdns_imx_writel(data, USB3_SSPHY_STATUS, CLK_VALID_MASK);\n\tudelay(1);\n\tret = readl_poll_timeout(data->noncore + USB3_SSPHY_STATUS, value,\n\t\t(value & CLK_VALID_COMPARE_BITS) == CLK_VALID_COMPARE_BITS,\n\t\t10, 100000);\n\tif (ret) {\n\t\tdev_err(dev, \"wait clkvld timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\tvalue |= ALL_SW_RESET;\n\tcdns_imx_writel(data, USB3_CORE_CTRL1, value);\n\tudelay(1);\n\n\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\tvalue = (value & ~MODE_STRAP_MASK) | OTG_MODE | OC_DISABLE;\n\tcdns_imx_writel(data, USB3_CORE_CTRL1, value);\n\n\tvalue = cdns_imx_readl(data, USB3_INT_REG);\n\tvalue |= HOST_INT1_EN | DEV_INT_EN;\n\tcdns_imx_writel(data, USB3_INT_REG, value);\n\n\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\tvalue &= ~ALL_SW_RESET;\n\tcdns_imx_writel(data, USB3_CORE_CTRL1, value);\n\treturn ret;\n}\n\nstatic int cdns_imx_platform_suspend(struct device *dev,\n\tbool suspend, bool wakeup);\nstatic struct cdns3_platform_data cdns_imx_pdata = {\n\t.platform_suspend = cdns_imx_platform_suspend,\n\t.quirks\t\t  = CDNS3_DEFAULT_PM_RUNTIME_ALLOW,\n};\n\nstatic const struct of_dev_auxdata cdns_imx_auxdata[] = {\n\t{\n\t\t.compatible = \"cdns,usb3\",\n\t\t.platform_data = &cdns_imx_pdata,\n\t},\n\t{},\n};\n\nstatic int cdns_imx_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct cdns_imx *data;\n\tint ret;\n\n\tif (!node)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\tdata->dev = dev;\n\tdata->noncore = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->noncore)) {\n\t\tdev_err(dev, \"can't map IOMEM resource\\n\");\n\t\treturn PTR_ERR(data->noncore);\n\t}\n\n\tdata->num_clks = ARRAY_SIZE(imx_cdns3_core_clks);\n\tdata->clks = devm_kmemdup(dev, imx_cdns3_core_clks,\n\t\t\t\tsizeof(imx_cdns3_core_clks), GFP_KERNEL);\n\tif (!data->clks)\n\t\treturn -ENOMEM;\n\n\tret = devm_clk_bulk_get(dev, data->num_clks, data->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(data->num_clks, data->clks);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cdns_imx_noncore_init(data);\n\tif (ret)\n\t\tgoto err;\n\n\tret = of_platform_populate(node, NULL, cdns_imx_auxdata, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to create children: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tdevice_set_wakeup_capable(dev, true);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn ret;\nerr:\n\tclk_bulk_disable_unprepare(data->num_clks, data->clks);\n\treturn ret;\n}\n\nstatic void cdns_imx_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct cdns_imx *data = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tof_platform_depopulate(dev);\n\tclk_bulk_disable_unprepare(data->num_clks, data->clks);\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tplatform_set_drvdata(pdev, NULL);\n}\n\n#ifdef CONFIG_PM\nstatic void cdns3_set_wakeup(struct cdns_imx *data, bool enable)\n{\n\tu32 value;\n\n\tvalue = cdns_imx_readl(data, USB3_INT_REG);\n\tif (enable)\n\t\tvalue |= OTG_WAKEUP_EN | DEVU3_WAEKUP_EN;\n\telse\n\t\tvalue &= ~(OTG_WAKEUP_EN | DEVU3_WAEKUP_EN);\n\n\tcdns_imx_writel(data, USB3_INT_REG, value);\n}\n\nstatic int cdns_imx_platform_suspend(struct device *dev,\n\t\tbool suspend, bool wakeup)\n{\n\tstruct cdns *cdns = dev_get_drvdata(dev);\n\tstruct device *parent = dev->parent;\n\tstruct cdns_imx *data = dev_get_drvdata(parent);\n\tvoid __iomem *otg_regs = (void __iomem *)(cdns->otg_regs);\n\tvoid __iomem *xhci_regs = cdns->xhci_regs;\n\tu32 value;\n\tint ret = 0;\n\n\tif (cdns->role != USB_ROLE_HOST)\n\t\treturn 0;\n\n\tif (suspend) {\n\t\t \n\t\tvalue = readl(xhci_regs + XECP_PM_PMCSR);\n\t\tvalue &= ~PS_MASK;\n\t\tvalue |= PS_D1;\n\t\twritel(value, xhci_regs + XECP_PM_PMCSR);\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\t\tvalue |= MDCTRL_CLK_SEL;\n\t\tcdns_imx_writel(data, USB3_CORE_CTRL1, value);\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_CORE_STATUS);\n\t\tret = readl_poll_timeout(data->noncore + USB3_CORE_STATUS, value,\n\t\t\t(value & MDCTRL_CLK_STATUS) == MDCTRL_CLK_STATUS,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait mdctrl_clk_status timeout\\n\");\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_INT_REG);\n\t\tret = readl_poll_timeout(data->noncore + USB3_INT_REG, value,\n\t\t\t(value & LPM_CLK_REQ) != LPM_CLK_REQ,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait lpm_clk_req timeout\\n\");\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_SSPHY_STATUS);\n\t\tret = readl_poll_timeout(data->noncore + USB3_SSPHY_STATUS, value,\n\t\t\t(value & PHY_REFCLK_REQ) != PHY_REFCLK_REQ,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait phy_refclk_req timeout\\n\");\n\n\t\tcdns3_set_wakeup(data, wakeup);\n\t} else {\n\t\tcdns3_set_wakeup(data, false);\n\n\t\t \n\t\tvalue = readl(xhci_regs + XECP_PM_PMCSR);\n\t\tvalue &= ~PS_MASK;\n\t\tvalue |= PS_D0;\n\t\twritel(value, xhci_regs + XECP_PM_PMCSR);\n\n\t\t \n\t\tvalue = readl(xhci_regs + XECP_AUX_CTRL_REG1);\n\t\tvalue &= ~CFG_RXDET_P3_EN;\n\t\twritel(value, xhci_regs + XECP_AUX_CTRL_REG1);\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\t\tvalue &= ~MDCTRL_CLK_SEL;\n\t\tcdns_imx_writel(data, USB3_CORE_CTRL1, value);\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_INT_REG);\n\t\tret = readl_poll_timeout(data->noncore + USB3_INT_REG, value,\n\t\t\t(value & CLK_125_REQ) == CLK_125_REQ,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait CLK_125_REQ timeout\\n\");\n\n\t\t \n\t\tvalue = cdns_imx_readl(data, USB3_CORE_STATUS);\n\t\tret = readl_poll_timeout(data->noncore + USB3_CORE_STATUS, value,\n\t\t\t(value & MDCTRL_CLK_STATUS) != MDCTRL_CLK_STATUS,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait mdctrl_clk_status cleared timeout\\n\");\n\n\t\t \n\t\tvalue = readl(otg_regs + OTGSTS);\n\t\tret = readl_poll_timeout(otg_regs + OTGSTS, value,\n\t\t\t(value & OTG_NRDY) != OTG_NRDY,\n\t\t\t10, 100000);\n\t\tif (ret)\n\t\t\tdev_warn(parent, \"wait OTG ready timeout\\n\");\n\t}\n\n\treturn ret;\n\n}\n\nstatic int cdns_imx_resume(struct device *dev)\n{\n\tstruct cdns_imx *data = dev_get_drvdata(dev);\n\n\treturn clk_bulk_prepare_enable(data->num_clks, data->clks);\n}\n\nstatic int cdns_imx_suspend(struct device *dev)\n{\n\tstruct cdns_imx *data = dev_get_drvdata(dev);\n\n\tclk_bulk_disable_unprepare(data->num_clks, data->clks);\n\n\treturn 0;\n}\n\n\n \nstatic inline bool cdns_imx_is_power_lost(struct cdns_imx *data)\n{\n\tu32 value;\n\n\tvalue = cdns_imx_readl(data, USB3_CORE_CTRL1);\n\tif ((value & SW_RESET_MASK) == ALL_SW_RESET)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic int __maybe_unused cdns_imx_system_suspend(struct device *dev)\n{\n\tpm_runtime_put_sync(dev);\n\treturn 0;\n}\n\nstatic int __maybe_unused cdns_imx_system_resume(struct device *dev)\n{\n\tstruct cdns_imx *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Could not get runtime PM.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cdns_imx_is_power_lost(data)) {\n\t\tdev_dbg(dev, \"resume from power lost\\n\");\n\t\tret = cdns_imx_noncore_init(data);\n\t\tif (ret)\n\t\t\tcdns_imx_suspend(dev);\n\t}\n\n\treturn ret;\n}\n\n#else\nstatic int cdns_imx_platform_suspend(struct device *dev,\n\tbool suspend, bool wakeup)\n{\n\treturn 0;\n}\n\n#endif  \n\nstatic const struct dev_pm_ops cdns_imx_pm_ops = {\n\tSET_RUNTIME_PM_OPS(cdns_imx_suspend, cdns_imx_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(cdns_imx_system_suspend, cdns_imx_system_resume)\n};\n\nstatic const struct of_device_id cdns_imx_of_match[] = {\n\t{ .compatible = \"fsl,imx8qm-usb3\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cdns_imx_of_match);\n\nstatic struct platform_driver cdns_imx_driver = {\n\t.probe\t\t= cdns_imx_probe,\n\t.remove_new\t= cdns_imx_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cdns3-imx\",\n\t\t.of_match_table\t= cdns_imx_of_match,\n\t\t.pm\t= &cdns_imx_pm_ops,\n\t},\n};\nmodule_platform_driver(cdns_imx_driver);\n\nMODULE_ALIAS(\"platform:cdns3-imx\");\nMODULE_AUTHOR(\"Peter Chen <peter.chen@nxp.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence USB3 i.MX Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}