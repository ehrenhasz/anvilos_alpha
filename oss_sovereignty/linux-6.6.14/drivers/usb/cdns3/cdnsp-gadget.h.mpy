{
  "module_name": "cdnsp-gadget.h",
  "hash_id": "9867295718636db80539d82cb449c86f6634affa43e8e19dcb4ca9689f7e6098",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdnsp-gadget.h",
  "human_readable_source": " \n \n#ifndef __LINUX_CDNSP_GADGET_H\n#define __LINUX_CDNSP_GADGET_H\n\n#include <linux/io-64-nonatomic-lo-hi.h>\n#include <linux/usb/gadget.h>\n#include <linux/irq.h>\n\n \n#define CDNSP_DEV_MAX_SLOTS\t1\n\n#define CDNSP_EP0_SETUP_SIZE\t512\n\n \n#define CDNSP_ENDPOINTS_NUM\t31\n\n \n#define CDNSP_DEFAULT_BESL\t0\n\n \n#define CDNSP_CMD_TIMEOUT\t(15 * 1000)\n\n \n#define CDNSP_MAX_HALT_USEC\t(16 * 1000)\n\n#define CDNSP_CTX_SIZE\t2112\n\n \n\n \nstruct cdnsp_cap_regs {\n\t__le32 hc_capbase;\n\t__le32 hcs_params1;\n\t__le32 hcs_params2;\n\t__le32 hcs_params3;\n\t__le32 hcc_params;\n\t__le32 db_off;\n\t__le32 run_regs_off;\n\t__le32 hcc_params2;\n\t \n};\n\n \n \n#define HC_LENGTH(p)\t\t(((p) >> 00) & GENMASK(7, 0))\n \n#define HC_VERSION(p)\t\t(((p) >> 16) & GENMASK(15, 1))\n\n \n \n#define HCS_ENDPOINTS_MASK\tGENMASK(7, 0)\n#define HCS_ENDPOINTS(p)\t(((p) & HCS_ENDPOINTS_MASK) >> 0)\n\n \n#define HCC_PARAMS_OFFSET\t0x10\n\n \n \n#define HCC_64BIT_ADDR(p)\t((p) & BIT(0))\n \n#define HCC_64BYTE_CONTEXT(p)\t((p) & BIT(2))\n \n#define HCC_MAX_PSA(p)\t\t((((p) >> 12) & 0xf) + 1)\n \n#define HCC_EXT_CAPS(p)\t\t(((p) & GENMASK(31, 16)) >> 16)\n\n#define CTX_SIZE(_hcc)\t\t(HCC_64BYTE_CONTEXT(_hcc) ? 64 : 32)\n\n \n#define DBOFF_MASK\tGENMASK(31, 2)\n\n \n#define RTSOFF_MASK\tGENMASK(31, 5)\n\n \nstruct cdnsp_op_regs {\n\t__le32 command;\n\t__le32 status;\n\t__le32 page_size;\n\t__le32 reserved1;\n\t__le32 reserved2;\n\t__le32 dnctrl;\n\t__le64 cmd_ring;\n\t \n\t__le32 reserved3[4];\n\t__le64 dcbaa_ptr;\n\t__le32 config_reg;\n\t \n\t__le32 reserved4[241];\n\t \n\t__le32 port_reg_base;\n};\n\n \n#define NUM_PORT_REGS\t4\n\n \nstruct cdnsp_port_regs {\n\t__le32 portsc;\n\t__le32 portpmsc;\n\t__le32 portli;\n\t__le32 reserved;\n};\n\n \n#define CDNSP_PORT_RO\t(PORT_CONNECT | DEV_SPEED_MASK)\n\n \n#define CDNSP_PORT_RWS\t(PORT_PLS_MASK | PORT_WKCONN_E | PORT_WKDISC_E)\n\n \n#define CDNSP_PORT_RW1CS (PORT_PED | PORT_CSC | PORT_RC | PORT_PLC)\n\n \n \n#define CMD_R_S\t\tBIT(0)\n \n#define CMD_RESET\tBIT(1)\n \n#define CMD_INTE\tBIT(2)\n \n#define CMD_DSEIE\tBIT(3)\n \n#define CMD_CSS\t\tBIT(8)\n#define CMD_CRS\t\tBIT(9)\n \n#define CMD_EWE\t\tBIT(10)\n \n#define CMD_DEVEN\tBIT(17)\n \n\n \n#define CDNSP_IRQS\t(CMD_INTE | CMD_DSEIE | CMD_EWE)\n\n \n \n#define STS_HALT\tBIT(0)\n \n#define STS_FATAL\tBIT(2)\n \n#define STS_EINT\tBIT(3)\n \n#define STS_PCD\t\tBIT(4)\n \n#define STS_SSS\t\tBIT(8)\n \n#define STS_RSS\t\tBIT(9)\n \n#define STS_SRE\t\tBIT(10)\n \n#define STS_CNR\t\tBIT(11)\n \n#define STS_HCE\t\tBIT(12)\n\n \n \n#define CMD_RING_CS\t\tBIT(0)\n \n#define CMD_RING_ABORT\t\tBIT(2)\n \n#define CMD_RING_BUSY(p)\t((p) & BIT(4))\n \n#define CMD_RING_RUNNING\tBIT(3)\n \n#define CMD_RING_RSVD_BITS\tGENMASK(5, 0)\n\n \n \n#define MAX_DEVS\t\tGENMASK(7, 0)\n \n#define CONFIG_U3E\t\tBIT(8)\n\n \n \n#define PORT_CONNECT\t\tBIT(0)\n \n#define PORT_PED\t\tBIT(1)\n \n#define PORT_RESET\t\tBIT(4)\n \n#define PORT_PLS_MASK\t\tGENMASK(8, 5)\n#define XDEV_U0\t\t\t(0x0 << 5)\n#define XDEV_U1\t\t\t(0x1 << 5)\n#define XDEV_U2\t\t\t(0x2 << 5)\n#define XDEV_U3\t\t\t(0x3 << 5)\n#define XDEV_DISABLED\t\t(0x4 << 5)\n#define XDEV_RXDETECT\t\t(0x5 << 5)\n#define XDEV_INACTIVE\t\t(0x6 << 5)\n#define XDEV_POLLING\t\t(0x7 << 5)\n#define XDEV_RECOVERY\t\t(0x8 << 5)\n#define XDEV_HOT_RESET\t\t(0x9 << 5)\n#define XDEV_COMP_MODE\t\t(0xa << 5)\n#define XDEV_TEST_MODE\t\t(0xb << 5)\n#define XDEV_RESUME\t\t(0xf << 5)\n \n#define PORT_POWER\t\tBIT(9)\n \n#define DEV_SPEED_MASK\t\tGENMASK(13, 10)\n#define XDEV_FS\t\t\t(0x1 << 10)\n#define XDEV_HS\t\t\t(0x3 << 10)\n#define XDEV_SS\t\t\t(0x4 << 10)\n#define XDEV_SSP\t\t(0x5 << 10)\n#define DEV_UNDEFSPEED(p)\t(((p) & DEV_SPEED_MASK) == (0x0 << 10))\n#define DEV_FULLSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_FS)\n#define DEV_HIGHSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_HS)\n#define DEV_SUPERSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_SS)\n#define DEV_SUPERSPEEDPLUS(p)\t(((p) & DEV_SPEED_MASK) == XDEV_SSP)\n#define DEV_SUPERSPEED_ANY(p)\t(((p) & DEV_SPEED_MASK) >= XDEV_SS)\n#define DEV_PORT_SPEED(p)\t(((p) >> 10) & 0x0f)\n \n#define PORT_LINK_STROBE\tBIT(16)\n \n#define PORT_CSC\t\tBIT(17)\n \n#define PORT_WRC\t\tBIT(19)\n \n#define PORT_RC\t\t\tBIT(21)\n \n#define PORT_PLC\t\tBIT(22)\n \n#define PORT_CEC\t\tBIT(23)\n \n#define PORT_WKCONN_E\t\tBIT(25)\n \n#define PORT_WKDISC_E\t\tBIT(26)\n \n#define PORT_WR\t\t\tBIT(31)\n\n#define PORT_CHANGE_BITS (PORT_CSC | PORT_WRC | PORT_RC | PORT_PLC | PORT_CEC)\n\n \n \n#define PORT_U1_TIMEOUT_MASK\tGENMASK(7, 0)\n#define PORT_U1_TIMEOUT(p)\t((p) & PORT_U1_TIMEOUT_MASK)\n \n#define PORT_U2_TIMEOUT_MASK\tGENMASK(14, 8)\n#define PORT_U2_TIMEOUT(p)\t(((p) << 8) & PORT_U2_TIMEOUT_MASK)\n\n \n#define PORT_L1S_MASK\t\tGENMASK(2, 0)\n#define PORT_L1S(p)\t\t((p) & PORT_L1S_MASK)\n#define PORT_L1S_ACK\t\tPORT_L1S(1)\n#define PORT_L1S_NYET\t\tPORT_L1S(2)\n#define PORT_L1S_STALL\t\tPORT_L1S(3)\n#define PORT_L1S_TIMEOUT\tPORT_L1S(4)\n \n#define PORT_RWE\t\tBIT(3)\n \n#define PORT_BESL(p)\t\t(((p) << 4) & GENMASK(7, 4))\n \n#define PORT_HLE\t\tBIT(16)\n \n#define PORT_RRBESL(p)\t\t(((p) & GENMASK(20, 17)) >> 17)\n \n#define PORT_TEST_MODE_MASK\tGENMASK(31, 28)\n#define PORT_TEST_MODE(p)\t(((p) << 28) & PORT_TEST_MODE_MASK)\n\n \nstruct cdnsp_intr_reg {\n\t__le32 irq_pending;\n\t__le32 irq_control;\n\t__le32 erst_size;\n\t__le32 rsvd;\n\t__le64 erst_base;\n\t__le64 erst_dequeue;\n};\n\n \n#define IMAN_IE\t\t\tBIT(1)\n#define IMAN_IP\t\t\tBIT(0)\n \n#define IMAN_IE_SET(p)\t\t((p) | IMAN_IE)\n#define IMAN_IE_CLEAR(p)\t((p) & ~IMAN_IE)\n\n \n \n#define IMOD_INTERVAL_MASK\tGENMASK(15, 0)\n \n#define IMOD_COUNTER_MASK\tGENMASK(31, 16)\n#define IMOD_DEFAULT_INTERVAL\t0\n\n \n \n#define ERST_SIZE_MASK\t\tGENMASK(31, 16)\n\n \n \n#define ERST_DESI_MASK\t\tGENMASK(2, 0)\n \n#define ERST_EHB\t\tBIT(3)\n#define ERST_PTR_MASK\t\tGENMASK(3, 0)\n\n \nstruct cdnsp_run_regs {\n\t__le32 microframe_index;\n\t__le32 rsvd[7];\n\tstruct cdnsp_intr_reg ir_set[128];\n};\n\n \nstruct cdnsp_20port_cap {\n\t__le32 ext_cap;\n\t__le32 port_reg1;\n\t__le32 port_reg2;\n\t__le32 port_reg3;\n\t__le32 port_reg4;\n\t__le32 port_reg5;\n\t__le32 port_reg6;\n};\n\n \n#define EXT_CAPS_ID(p)\t\t\t(((p) >> 0) & GENMASK(7, 0))\n#define EXT_CAPS_NEXT(p)\t\t(((p) >> 8) & GENMASK(7, 0))\n \n#define EXT_CAPS_PROTOCOL\t\t2\n\n \n#define EXT_CAP_CFG_DEV_20PORT_CAP_ID\t0xC1\n \n#define PORT_REG6_L1_L0_HW_EN\t\tBIT(1)\n \n#define PORT_REG6_FORCE_FS\t\tBIT(0)\n\n \nstruct cdnsp_3xport_cap {\n\t__le32 ext_cap;\n\t__le32 mode_addr;\n\t__le32 reserved[52];\n\t__le32 mode_2;\n};\n\n \n#define D_XEC_CFG_3XPORT_CAP\t\t0xC0\n#define CFG_3XPORT_SSP_SUPPORT\t\tBIT(31)\n#define CFG_3XPORT_U1_PIPE_CLK_GATE_EN\tBIT(0)\n\n \n#define RTL_REV_CAP\t\t\t0xC4\n#define RTL_REV_CAP_RX_BUFF_CMD_SIZE\tBITMASK(31, 24)\n#define RTL_REV_CAP_RX_BUFF_SIZE\tBITMASK(15, 0)\n#define RTL_REV_CAP_TX_BUFF_CMD_SIZE\tBITMASK(31, 24)\n#define RTL_REV_CAP_TX_BUFF_SIZE\tBITMASK(15, 0)\n\n#define CDNSP_VER_1 0x00000000\n#define CDNSP_VER_2 0x10000000\n\n#define CDNSP_IF_EP_EXIST(pdev, ep_num, dir) \\\n\t\t\t (readl(&(pdev)->rev_cap->ep_supported) & \\\n\t\t\t (BIT(ep_num) << ((dir) ? 0 : 16)))\n\n \nstruct cdnsp_rev_cap {\n\t__le32 ext_cap;\n\t__le32 rtl_revision;\n\t__le32 rx_buff_size;\n\t__le32 tx_buff_size;\n\t__le32 ep_supported;\n\t__le32 ctrl_revision;\n};\n\n \n#define D_XEC_PRE_REGS_CAP\t\t0xC8\n#define REG_CHICKEN_BITS_2_OFFSET\t0x48\n#define CHICKEN_XDMA_2_TP_CACHE_DIS\tBIT(28)\n\n \n#define XBUF_CAP_ID\t\t\t0xCB\n#define XBUF_RX_TAG_MASK_0_OFFSET\t0x1C\n#define XBUF_RX_TAG_MASK_1_OFFSET\t0x24\n#define XBUF_TX_CMD_OFFSET\t\t0x2C\n\n \nstruct cdnsp_doorbell_array {\n\t__le32 cmd_db;\n\t__le32 ep_db;\n};\n\n#define DB_VALUE(ep, stream)\t\t((((ep) + 1) & 0xff) | ((stream) << 16))\n#define DB_VALUE_EP0_OUT(ep, stream)\t((ep) & 0xff)\n#define DB_VALUE_CMD\t\t\t0x00000000\n\n \nstruct cdnsp_container_ctx {\n\tunsigned int type;\n#define CDNSP_CTX_TYPE_DEVICE\t0x1\n#define CDNSP_CTX_TYPE_INPUT\t0x2\n\tint size;\n\tint ctx_size;\n\tdma_addr_t dma;\n\tu8 *bytes;\n};\n\n \nstruct cdnsp_slot_ctx {\n\t__le32 dev_info;\n\t__le32 dev_port;\n\t__le32 int_target;\n\t__le32 dev_state;\n\t \n\t__le32 reserved[4];\n};\n\n \n#define SLOT_SPEED_FS\t\t(XDEV_FS << 10)\n#define SLOT_SPEED_HS\t\t(XDEV_HS << 10)\n#define SLOT_SPEED_SS\t\t(XDEV_SS << 10)\n#define SLOT_SPEED_SSP\t\t(XDEV_SSP << 10)\n\n \n \n#define DEV_SPEED\t\tGENMASK(23, 20)\n#define GET_DEV_SPEED(n)\t(((n) & DEV_SPEED) >> 20)\n \n#define LAST_CTX_MASK\t\t((unsigned int)GENMASK(31, 27))\n#define LAST_CTX(p)\t\t((p) << 27)\n#define LAST_CTX_TO_EP_NUM(p)\t(((p) >> 27) - 1)\n#define SLOT_FLAG\t\tBIT(0)\n#define EP0_FLAG\t\tBIT(1)\n\n \n \n#define DEV_PORT(p)\t\t(((p) & 0xff) << 16)\n\n \n \n#define DEV_ADDR_MASK\t\tGENMASK(7, 0)\n \n#define SLOT_STATE\t\tGENMASK(31, 27)\n#define GET_SLOT_STATE(p)\t(((p) & SLOT_STATE) >> 27)\n\n#define SLOT_STATE_DISABLED\t0\n#define SLOT_STATE_ENABLED\tSLOT_STATE_DISABLED\n#define SLOT_STATE_DEFAULT\t1\n#define SLOT_STATE_ADDRESSED\t2\n#define SLOT_STATE_CONFIGURED\t3\n\n \nstruct cdnsp_ep_ctx {\n\t__le32 ep_info;\n\t__le32 ep_info2;\n\t__le64 deq;\n\t__le32 tx_info;\n\t \n\t__le32 reserved[3];\n};\n\n \n \n#define EP_STATE_MASK\t\tGENMASK(3, 0)\n#define EP_STATE_DISABLED\t0\n#define EP_STATE_RUNNING\t1\n#define EP_STATE_HALTED\t\t2\n#define EP_STATE_STOPPED\t3\n#define EP_STATE_ERROR\t\t4\n#define GET_EP_CTX_STATE(ctx)\t(le32_to_cpu((ctx)->ep_info) & EP_STATE_MASK)\n\n \n#define EP_MULT(p)\t\t\t(((p) << 8) & GENMASK(9, 8))\n#define CTX_TO_EP_MULT(p)\t\t(((p) & GENMASK(9, 8)) >> 8)\n \n \n \n#define EP_INTERVAL(p)\t\t\t(((p) << 16) & GENMASK(23, 16))\n#define EP_INTERVAL_TO_UFRAMES(p)\t(1 << (((p) & GENMASK(23, 16)) >> 16))\n#define CTX_TO_EP_INTERVAL(p)\t\t(((p) & GENMASK(23, 16)) >> 16)\n#define EP_MAXPSTREAMS_MASK\t\tGENMASK(14, 10)\n#define EP_MAXPSTREAMS(p)\t\t(((p) << 10) & EP_MAXPSTREAMS_MASK)\n#define CTX_TO_EP_MAXPSTREAMS(p)\t(((p) & EP_MAXPSTREAMS_MASK) >> 10)\n \n#define EP_HAS_LSA\t\t\tBIT(15)\n\n \n#define ERROR_COUNT(p)\t\t(((p) & 0x3) << 1)\n#define CTX_TO_EP_TYPE(p)\t(((p) >> 3) & 0x7)\n#define EP_TYPE(p)\t\t((p) << 3)\n#define ISOC_OUT_EP\t\t1\n#define BULK_OUT_EP\t\t2\n#define INT_OUT_EP\t\t3\n#define CTRL_EP\t\t\t4\n#define ISOC_IN_EP\t\t5\n#define BULK_IN_EP\t\t6\n#define INT_IN_EP\t\t7\n \n \n#define MAX_BURST(p)\t\t(((p) << 8) & GENMASK(15, 8))\n#define CTX_TO_MAX_BURST(p)\t(((p) & GENMASK(15, 8)) >> 8)\n#define MAX_PACKET(p)\t\t(((p) << 16) & GENMASK(31, 16))\n#define MAX_PACKET_MASK\t\tGENMASK(31, 16)\n#define MAX_PACKET_DECODED(p)\t(((p) & GENMASK(31, 16)) >> 16)\n\n \n#define EP_AVG_TRB_LENGTH(p)\t\t((p) & GENMASK(15, 0))\n#define EP_MAX_ESIT_PAYLOAD_LO(p)\t(((p) << 16) & GENMASK(31, 16))\n#define EP_MAX_ESIT_PAYLOAD_HI(p)\t((((p) & GENMASK(23, 16)) >> 16) << 24)\n#define CTX_TO_MAX_ESIT_PAYLOAD_LO(p)\t(((p) & GENMASK(31, 16)) >> 16)\n#define CTX_TO_MAX_ESIT_PAYLOAD_HI(p)\t(((p) & GENMASK(31, 24)) >> 24)\n\n \n#define EP_CTX_CYCLE_MASK\t\tBIT(0)\n#define CTX_DEQ_MASK\t\t\t(~0xfL)\n\n \nstruct cdnsp_input_control_ctx {\n\t__le32 drop_flags;\n\t__le32 add_flags;\n\t__le32 rsvd2[6];\n};\n\n \nstruct cdnsp_command {\n\t \n\tstruct cdnsp_container_ctx *in_ctx;\n\tu32 status;\n\tunion cdnsp_trb *command_trb;\n};\n\n \nstruct cdnsp_stream_ctx {\n\t__le64 stream_ring;\n\t__le32 reserved[2];\n};\n\n \n#define SCT_FOR_CTX(p)\t\t(((p) << 1) & GENMASK(3, 1))\n \n#define SCT_SEC_TR\t\t0\n \n#define SCT_PRI_TR\t\t1\n\n \nstruct cdnsp_stream_info {\n\tstruct cdnsp_ring **stream_rings;\n\tunsigned int num_streams;\n\tstruct cdnsp_stream_ctx *stream_ctx_array;\n\tunsigned int num_stream_ctxs;\n\tdma_addr_t ctx_array_dma;\n\tstruct radix_tree_root trb_address_map;\n\tint td_count;\n\tu8 first_prime_det;\n#define STREAM_DRBL_FIFO_DEPTH 2\n\tu8 drbls_count;\n};\n\n#define STREAM_LOG_STREAMS 4\n#define STREAM_NUM_STREAMS BIT(STREAM_LOG_STREAMS)\n\n#if STREAM_LOG_STREAMS > 16 && STREAM_LOG_STREAMS < 1\n#error \"Not suupported stream value\"\n#endif\n\n \nstruct cdnsp_ep {\n\tstruct usb_ep endpoint;\n\tstruct list_head pending_list;\n\tstruct cdnsp_device *pdev;\n\tu8 number;\n\tu8 idx;\n\tu32 interval;\n\tchar name[20];\n\tu8 direction;\n\tu8 buffering;\n\tu8 buffering_period;\n\tstruct cdnsp_ep_ctx *in_ctx;\n\tstruct cdnsp_ep_ctx *out_ctx;\n\tstruct cdnsp_ring *ring;\n\tstruct cdnsp_stream_info stream_info;\n\tunsigned int ep_state;\n#define EP_ENABLED\t\tBIT(0)\n#define EP_DIS_IN_RROGRESS\tBIT(1)\n#define EP_HALTED\t\tBIT(2)\n#define EP_STOPPED\t\tBIT(3)\n#define EP_WEDGE\t\tBIT(4)\n#define EP0_HALTED_STATUS\tBIT(5)\n#define EP_HAS_STREAMS\t\tBIT(6)\n#define EP_UNCONFIGURED\t\tBIT(7)\n\n\tbool skip;\n};\n\n \nstruct cdnsp_device_context_array {\n\t__le64 dev_context_ptrs[CDNSP_DEV_MAX_SLOTS + 1];\n\tdma_addr_t dma;\n};\n\n \nstruct cdnsp_transfer_event {\n\t__le64 buffer;\n\t__le32 transfer_len;\n\t__le32 flags;\n};\n\n \n#define TRB_EVENT_INVALIDATE 8\n\n \n \n#define EVENT_TRB_LEN(p)\t\t\t((p) & GENMASK(23, 0))\n \n#define COMP_CODE_MASK\t\t\t\t(0xff << 24)\n#define GET_COMP_CODE(p)\t\t\t(((p) & COMP_CODE_MASK) >> 24)\n#define COMP_INVALID\t\t\t\t0\n#define COMP_SUCCESS\t\t\t\t1\n#define COMP_DATA_BUFFER_ERROR\t\t\t2\n#define COMP_BABBLE_DETECTED_ERROR\t\t3\n#define COMP_TRB_ERROR\t\t\t\t5\n#define COMP_RESOURCE_ERROR\t\t\t7\n#define COMP_NO_SLOTS_AVAILABLE_ERROR\t\t9\n#define COMP_INVALID_STREAM_TYPE_ERROR\t\t10\n#define COMP_SLOT_NOT_ENABLED_ERROR\t\t11\n#define COMP_ENDPOINT_NOT_ENABLED_ERROR\t\t12\n#define COMP_SHORT_PACKET\t\t\t13\n#define COMP_RING_UNDERRUN\t\t\t14\n#define COMP_RING_OVERRUN\t\t\t15\n#define COMP_VF_EVENT_RING_FULL_ERROR\t\t16\n#define COMP_PARAMETER_ERROR\t\t\t17\n#define COMP_CONTEXT_STATE_ERROR\t\t19\n#define COMP_EVENT_RING_FULL_ERROR\t\t21\n#define COMP_INCOMPATIBLE_DEVICE_ERROR\t\t22\n#define COMP_MISSED_SERVICE_ERROR\t\t23\n#define COMP_COMMAND_RING_STOPPED\t\t24\n#define COMP_COMMAND_ABORTED\t\t\t25\n#define COMP_STOPPED\t\t\t\t26\n#define COMP_STOPPED_LENGTH_INVALID\t\t27\n#define COMP_STOPPED_SHORT_PACKET\t\t28\n#define COMP_MAX_EXIT_LATENCY_TOO_LARGE_ERROR\t29\n#define COMP_ISOCH_BUFFER_OVERRUN\t\t31\n#define COMP_EVENT_LOST_ERROR\t\t\t32\n#define COMP_UNDEFINED_ERROR\t\t\t33\n#define COMP_INVALID_STREAM_ID_ERROR\t\t34\n\n \n#define TRB_TO_DEV_STREAM(p)\t\t\t((p) & GENMASK(16, 0))\n#define TRB_TO_HOST_STREAM(p)\t\t\t((p) & GENMASK(16, 0))\n#define STREAM_PRIME_ACK\t\t\t0xFFFE\n#define STREAM_REJECTED\t\t\t\t0xFFFF\n\n \n#define TRB_TO_EP_ID(p)\t\t\t\t(((p) & GENMASK(20, 16)) >> 16)\n\n \nstruct cdnsp_link_trb {\n\t__le64 segment_ptr;\n\t__le32 intr_target;\n\t__le32 control;\n};\n\n \n#define LINK_TOGGLE\tBIT(1)\n\n \nstruct cdnsp_event_cmd {\n\t__le64 cmd_trb;\n\t__le32 status;\n\t__le32 flags;\n};\n\n \n\n \n#define TRB_BSR\t\tBIT(9)\n\n \n#define TRB_DC\t\tBIT(9)\n\n \n#define TRB_FH_TO_PACKET_TYPE(p)\t((p) & GENMASK(4, 0))\n#define TRB_FH_TR_PACKET\t\t0x4\n#define TRB_FH_TO_DEVICE_ADDRESS(p)\t(((p) << 25) & GENMASK(31, 25))\n#define TRB_FH_TR_PACKET_DEV_NOT\t0x6\n#define TRB_FH_TO_NOT_TYPE(p)\t\t(((p) << 4) & GENMASK(7, 4))\n#define TRB_FH_TR_PACKET_FUNCTION_WAKE\t0x1\n#define TRB_FH_TO_INTERFACE(p)\t\t(((p) << 8) & GENMASK(15, 8))\n\nenum cdnsp_setup_dev {\n\tSETUP_CONTEXT_ONLY,\n\tSETUP_CONTEXT_ADDRESS,\n};\n\n \n#define TRB_TO_SLOT_ID(p)\t\t(((p) & GENMASK(31, 24)) >> 24)\n#define SLOT_ID_FOR_TRB(p)\t\t(((p) << 24) & GENMASK(31, 24))\n\n \n#define TRB_TO_EP_INDEX(p)\t\t(((p) >> 16) & 0x1f)\n\n#define EP_ID_FOR_TRB(p)\t\t((((p) + 1) << 16) & GENMASK(20, 16))\n\n#define SUSPEND_PORT_FOR_TRB(p)\t\t(((p) & 1) << 23)\n#define TRB_TO_SUSPEND_PORT(p)\t\t(((p) >> 23) & 0x1)\n#define LAST_EP_INDEX\t\t\t30\n\n \n#define TRB_TO_STREAM_ID(p)\t\t((((p) & GENMASK(31, 16)) >> 16))\n#define STREAM_ID_FOR_TRB(p)\t\t((((p)) << 16) & GENMASK(31, 16))\n#define SCT_FOR_TRB(p)\t\t\t(((p) << 1) & 0x7)\n\n \n#define TRB_TC\t\t\t\tBIT(1)\n\n \n \n#define GET_PORT_ID(p)\t\t\t(((p) & GENMASK(31, 24)) >> 24)\n#define SET_PORT_ID(p)\t\t\t(((p) << 24) & GENMASK(31, 24))\n#define EVENT_DATA\t\t\tBIT(2)\n\n \n \n#define TRB_LEN(p)\t\t\t((p) & GENMASK(16, 0))\n \n#define TRB_TD_SIZE(p)\t\t\t(min((p), (u32)31) << 17)\n#define GET_TD_SIZE(p)\t\t\t(((p) & GENMASK(21, 17)) >> 17)\n \n#define TRB_TD_SIZE_TBC(p)\t\t(min((p), (u32)31) << 17)\n \n#define TRB_INTR_TARGET(p)\t\t(((p) << 22) & GENMASK(31, 22))\n#define GET_INTR_TARGET(p)\t\t(((p) & GENMASK(31, 22)) >> 22)\n \n#define TRB_TBC(p)\t\t\t(((p) & 0x3) << 7)\n#define TRB_TLBPC(p)\t\t\t(((p) & 0xf) << 16)\n\n \n#define TRB_CYCLE\t\t\tBIT(0)\n \n#define TRB_ENT\t\t\t\tBIT(1)\n \n#define TRB_ISP\t\t\t\tBIT(2)\n \n#define TRB_NO_SNOOP\t\t\tBIT(3)\n \n#define TRB_CHAIN\t\t\tBIT(4)\n \n#define TRB_IOC\t\t\t\tBIT(5)\n \n#define TRB_IDT\t\t\t\tBIT(6)\n \n#define TRB_STAT\t\t\tBIT(7)\n \n#define TRB_BEI\t\t\t\tBIT(9)\n\n \n#define TRB_DIR_IN\t\t\tBIT(16)\n\n \n#define TRB_SETUPID_BITMASK\t\tGENMASK(9, 8)\n#define TRB_SETUPID(p)\t\t\t((p) << 8)\n#define TRB_SETUPID_TO_TYPE(p)\t\t(((p) & TRB_SETUPID_BITMASK) >> 8)\n\n#define TRB_SETUP_SPEEDID_USB3\t\t0x1\n#define TRB_SETUP_SPEEDID_USB2\t\t0x0\n#define TRB_SETUP_SPEEDID(p)\t\t((p) & (1 << 7))\n\n#define TRB_SETUPSTAT_ACK\t\t0x1\n#define TRB_SETUPSTAT_STALL\t\t0x0\n#define TRB_SETUPSTAT(p)\t\t((p) << 6)\n\n \n#define TRB_SIA\t\t\t\tBIT(31)\n#define TRB_FRAME_ID(p)\t\t\t(((p) << 20) & GENMASK(30, 20))\n\nstruct cdnsp_generic_trb {\n\t__le32 field[4];\n};\n\nunion cdnsp_trb {\n\tstruct cdnsp_link_trb link;\n\tstruct cdnsp_transfer_event trans_event;\n\tstruct cdnsp_event_cmd event_cmd;\n\tstruct cdnsp_generic_trb generic;\n};\n\n \n#define TRB_TYPE_BITMASK\tGENMASK(15, 10)\n#define TRB_TYPE(p)\t\t((p) << 10)\n#define TRB_FIELD_TO_TYPE(p)\t(((p) & TRB_TYPE_BITMASK) >> 10)\n\n \n \n#define TRB_NORMAL\t\t1\n \n#define TRB_SETUP\t\t2\n \n#define TRB_DATA\t\t3\n \n#define TRB_STATUS\t\t4\n \n#define TRB_ISOC\t\t5\n \n#define TRB_LINK\t\t6\n#define TRB_EVENT_DATA\t\t7\n \n#define TRB_TR_NOOP\t\t8\n\n \n \n#define TRB_ENABLE_SLOT\t\t9\n \n#define TRB_DISABLE_SLOT\t10\n \n#define TRB_ADDR_DEV\t\t11\n \n#define TRB_CONFIG_EP\t\t12\n \n#define TRB_EVAL_CONTEXT\t13\n \n#define TRB_RESET_EP\t\t14\n \n#define TRB_STOP_RING\t\t15\n \n#define TRB_SET_DEQ\t\t16\n \n#define TRB_RESET_DEV\t\t17\n \n#define TRB_FORCE_EVENT\t\t18\n \n#define TRB_FORCE_HEADER\t22\n \n#define TRB_CMD_NOOP\t\t23\n \n\n \n \n#define TRB_TRANSFER\t\t32\n \n#define TRB_COMPLETION\t\t33\n \n#define TRB_PORT_STATUS\t\t34\n \n#define TRB_HC_EVENT\t\t37\n \n#define TRB_MFINDEX_WRAP\t39\n \n \n#define TRB_ENDPOINT_NRDY\t48\n \n \n#define TRB_HALT_ENDPOINT\t54\n \n#define TRB_DRB_OVERFLOW\t57\n \n#define TRB_FLUSH_ENDPOINT\t58\n\n#define TRB_TYPE_LINK(x)\t(((x) & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK))\n#define TRB_TYPE_LINK_LE32(x)\t(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \\\n\t\t\t\t\tcpu_to_le32(TRB_TYPE(TRB_LINK)))\n#define TRB_TYPE_NOOP_LE32(x)\t(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \\\n\t\t\t\t\tcpu_to_le32(TRB_TYPE(TRB_TR_NOOP)))\n\n \n#define TRBS_PER_SEGMENT\t\t256\n#define TRBS_PER_EVENT_SEGMENT\t\t256\n#define TRBS_PER_EV_DEQ_UPDATE\t\t100\n#define TRB_SEGMENT_SIZE\t\t(TRBS_PER_SEGMENT * 16)\n#define TRB_SEGMENT_SHIFT\t\t(ilog2(TRB_SEGMENT_SIZE))\n \n#define TRB_MAX_BUFF_SHIFT\t\t16\n#define TRB_MAX_BUFF_SIZE\t\tBIT(TRB_MAX_BUFF_SHIFT)\n \n#define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr) (TRB_MAX_BUFF_SIZE - \\\n\t\t\t\t\t((addr) & (TRB_MAX_BUFF_SIZE - 1)))\n\n \nstruct cdnsp_segment {\n\tunion cdnsp_trb *trbs;\n\tstruct cdnsp_segment *next;\n\tdma_addr_t dma;\n\t \n\tdma_addr_t bounce_dma;\n\tvoid *bounce_buf;\n\tunsigned int bounce_offs;\n\tunsigned int bounce_len;\n};\n\n \nstruct cdnsp_td {\n\tstruct list_head td_list;\n\tstruct cdnsp_request *preq;\n\tstruct cdnsp_segment *start_seg;\n\tunion cdnsp_trb *first_trb;\n\tunion cdnsp_trb *last_trb;\n\tstruct cdnsp_segment *bounce_seg;\n\tbool request_length_set;\n\tbool drbl;\n};\n\n \nstruct cdnsp_dequeue_state {\n\tstruct cdnsp_segment *new_deq_seg;\n\tunion cdnsp_trb *new_deq_ptr;\n\tint new_cycle_state;\n\tunsigned int stream_id;\n};\n\nenum cdnsp_ring_type {\n\tTYPE_CTRL = 0,\n\tTYPE_ISOC,\n\tTYPE_BULK,\n\tTYPE_INTR,\n\tTYPE_STREAM,\n\tTYPE_COMMAND,\n\tTYPE_EVENT,\n};\n\n \nstruct cdnsp_ring {\n\tstruct cdnsp_segment *first_seg;\n\tstruct cdnsp_segment *last_seg;\n\tunion cdnsp_trb\t *enqueue;\n\tstruct cdnsp_segment *enq_seg;\n\tunion cdnsp_trb\t *dequeue;\n\tstruct cdnsp_segment *deq_seg;\n\tstruct list_head td_list;\n\tu32 cycle_state;\n\tunsigned int stream_id;\n\tunsigned int stream_active;\n\tunsigned int stream_rejected;\n\tint num_tds;\n\tunsigned int num_segs;\n\tunsigned int num_trbs_free;\n\tunsigned int bounce_buf_len;\n\tenum cdnsp_ring_type type;\n\tbool last_td_was_short;\n\tstruct radix_tree_root *trb_address_map;\n};\n\n \nstruct cdnsp_erst_entry {\n\t__le64 seg_addr;\n\t__le32 seg_size;\n\t \n\t__le32 rsvd;\n};\n\n \nstruct cdnsp_erst {\n\tstruct cdnsp_erst_entry *entries;\n\tunsigned int num_entries;\n\tdma_addr_t erst_dma_addr;\n};\n\n \nstruct cdnsp_request {\n\tstruct\tcdnsp_td td;\n\tstruct usb_request request;\n\tstruct list_head list;\n\tstruct cdnsp_ep\t *pep;\n\tu8 epnum;\n\tunsigned direction:1;\n};\n\n#define\tERST_NUM_SEGS\t1\n\n \nenum cdnsp_ep0_stage {\n\tCDNSP_SETUP_STAGE,\n\tCDNSP_DATA_STAGE,\n\tCDNSP_STATUS_STAGE,\n};\n\n \nstruct cdnsp_port {\n\tstruct cdnsp_port_regs __iomem *regs;\n\tu8 port_num;\n\tu8 exist;\n\tu8 maj_rev;\n\tu8 min_rev;\n};\n\n#define CDNSP_EXT_PORT_MAJOR(x)\t\t(((x) >> 24) & 0xff)\n#define CDNSP_EXT_PORT_MINOR(x)\t\t(((x) >> 16) & 0xff)\n#define CDNSP_EXT_PORT_OFF(x)\t\t((x) & 0xff)\n#define CDNSP_EXT_PORT_COUNT(x)\t\t(((x) >> 8) & 0xff)\n\n \nstruct cdnsp_device {\n\tstruct device *dev;\n\tstruct usb_gadget gadget;\n\tstruct usb_gadget_driver *gadget_driver;\n\tunsigned int irq;\n\tvoid __iomem *regs;\n\n\t \n\tstruct cdnsp_cap_regs __iomem *cap_regs;\n\tstruct cdnsp_op_regs __iomem *op_regs;\n\tstruct cdnsp_run_regs __iomem *run_regs;\n\tstruct cdnsp_doorbell_array __iomem *dba;\n\tstruct\tcdnsp_intr_reg __iomem *ir_set;\n\tstruct cdnsp_20port_cap __iomem *port20_regs;\n\tstruct cdnsp_3xport_cap __iomem *port3x_regs;\n\tstruct cdnsp_rev_cap __iomem *rev_cap;\n\n\t \n\t__u32 hcs_params1;\n\t__u32 hcs_params3;\n\t__u32 hcc_params;\n\t \n\tspinlock_t lock;\n\tstruct usb_ctrlrequest setup;\n\tstruct cdnsp_request ep0_preq;\n\tenum cdnsp_ep0_stage ep0_stage;\n\tu8 three_stage_setup;\n\tu8 ep0_expect_in;\n\tu8 setup_id;\n\tu8 setup_speed;\n\tvoid *setup_buf;\n\tu8 device_address;\n\tint may_wakeup;\n\tu16 hci_version;\n\n\t \n\tstruct cdnsp_device_context_array *dcbaa;\n\tstruct cdnsp_ring *cmd_ring;\n\tstruct cdnsp_command cmd;\n\tstruct cdnsp_ring *event_ring;\n\tstruct cdnsp_erst erst;\n\tint slot_id;\n\n\t \n\tstruct cdnsp_container_ctx out_ctx;\n\tstruct cdnsp_container_ctx in_ctx;\n\tstruct cdnsp_ep eps[CDNSP_ENDPOINTS_NUM];\n\tu8 usb2_hw_lpm_capable:1;\n\tu8 u1_allowed:1;\n\tu8 u2_allowed:1;\n\n\t \n\tstruct dma_pool *device_pool;\n\tstruct dma_pool\t*segment_pool;\n\n#define CDNSP_STATE_HALTED\t\tBIT(1)\n#define CDNSP_STATE_DYING\t\tBIT(2)\n#define CDNSP_STATE_DISCONNECT_PENDING\tBIT(3)\n#define CDNSP_WAKEUP_PENDING\t\tBIT(4)\n\tunsigned int cdnsp_state;\n\tunsigned int link_state;\n\n\tstruct cdnsp_port usb2_port;\n\tstruct cdnsp_port usb3_port;\n\tstruct cdnsp_port *active_port;\n\tu16 test_mode;\n};\n\n \nstatic inline u64 cdnsp_read_64(__le64 __iomem *regs)\n{\n\treturn lo_hi_readq(regs);\n}\n\nstatic inline void cdnsp_write_64(const u64 val, __le64 __iomem *regs)\n{\n\tlo_hi_writeq(val, regs);\n}\n\n \nvoid cdnsp_mem_cleanup(struct cdnsp_device *pdev);\nint cdnsp_mem_init(struct cdnsp_device *pdev);\nint cdnsp_setup_addressable_priv_dev(struct cdnsp_device *pdev);\nvoid cdnsp_copy_ep0_dequeue_into_input_ctx(struct cdnsp_device *pdev);\nvoid cdnsp_endpoint_zero(struct cdnsp_device *pdev, struct cdnsp_ep *ep);\nint cdnsp_endpoint_init(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_ep *pep,\n\t\t\tgfp_t mem_flags);\nint cdnsp_ring_expansion(struct cdnsp_device *pdev,\n\t\t\t struct cdnsp_ring *ring,\n\t\t\t unsigned int num_trbs, gfp_t flags);\nstruct cdnsp_ring *cdnsp_dma_to_transfer_ring(struct cdnsp_ep *ep, u64 address);\nint cdnsp_alloc_stream_info(struct cdnsp_device *pdev,\n\t\t\t    struct cdnsp_ep *pep,\n\t\t\t    unsigned int num_stream_ctxs,\n\t\t\t    unsigned int num_streams);\nint cdnsp_alloc_streams(struct cdnsp_device *pdev, struct cdnsp_ep *pep);\nvoid cdnsp_free_endpoint_rings(struct cdnsp_device *pdev, struct cdnsp_ep *pep);\n\n \nint cdnsp_find_next_ext_cap(void __iomem *base, u32 start, int id);\nint cdnsp_halt(struct cdnsp_device *pdev);\nvoid cdnsp_died(struct cdnsp_device *pdev);\nint cdnsp_reset(struct cdnsp_device *pdev);\nirqreturn_t cdnsp_irq_handler(int irq, void *priv);\nint cdnsp_setup_device(struct cdnsp_device *pdev, enum cdnsp_setup_dev setup);\nvoid cdnsp_set_usb2_hardware_lpm(struct cdnsp_device *usbsssp_data,\n\t\t\t\t struct usb_request *req, int enable);\nirqreturn_t cdnsp_thread_irq_handler(int irq, void *data);\n\n \ndma_addr_t cdnsp_trb_virt_to_dma(struct cdnsp_segment *seg,\n\t\t\t\t union cdnsp_trb *trb);\nbool cdnsp_last_trb_on_seg(struct cdnsp_segment *seg, union cdnsp_trb *trb);\nbool cdnsp_last_trb_on_ring(struct cdnsp_ring *ring,\n\t\t\t    struct cdnsp_segment *seg,\n\t\t\t    union cdnsp_trb *trb);\nint cdnsp_wait_for_cmd_compl(struct cdnsp_device *pdev);\nvoid cdnsp_update_erst_dequeue(struct cdnsp_device *pdev,\n\t\t\t       union cdnsp_trb *event_ring_deq,\n\t\t\t       u8 clear_ehb);\nvoid cdnsp_initialize_ring_info(struct cdnsp_ring *ring);\nvoid cdnsp_ring_cmd_db(struct cdnsp_device *pdev);\nvoid cdnsp_queue_slot_control(struct cdnsp_device *pdev, u32 trb_type);\nvoid cdnsp_queue_address_device(struct cdnsp_device *pdev,\n\t\t\t\tdma_addr_t in_ctx_ptr,\n\t\t\t\tenum cdnsp_setup_dev setup);\nvoid cdnsp_queue_stop_endpoint(struct cdnsp_device *pdev,\n\t\t\t       unsigned int ep_index);\nint cdnsp_queue_ctrl_tx(struct cdnsp_device *pdev, struct cdnsp_request *preq);\nint cdnsp_queue_bulk_tx(struct cdnsp_device *pdev, struct cdnsp_request *preq);\nint cdnsp_queue_isoc_tx(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_request *preq);\nvoid cdnsp_queue_configure_endpoint(struct cdnsp_device *pdev,\n\t\t\t\t    dma_addr_t in_ctx_ptr);\nvoid cdnsp_queue_reset_ep(struct cdnsp_device *pdev, unsigned int ep_index);\nvoid cdnsp_queue_halt_endpoint(struct cdnsp_device *pdev,\n\t\t\t       unsigned int ep_index);\nvoid cdnsp_queue_flush_endpoint(struct cdnsp_device *pdev,\n\t\t\t\tunsigned int ep_index);\nvoid cdnsp_force_header_wakeup(struct cdnsp_device *pdev, int intf_num);\nvoid cdnsp_queue_reset_device(struct cdnsp_device *pdev);\nvoid cdnsp_queue_new_dequeue_state(struct cdnsp_device *pdev,\n\t\t\t\t   struct cdnsp_ep *pep,\n\t\t\t\t   struct cdnsp_dequeue_state *deq_state);\nvoid cdnsp_ring_doorbell_for_active_rings(struct cdnsp_device *pdev,\n\t\t\t\t\t  struct cdnsp_ep *pep);\nvoid cdnsp_inc_deq(struct cdnsp_device *pdev, struct cdnsp_ring *ring);\nvoid cdnsp_set_link_state(struct cdnsp_device *pdev,\n\t\t\t  __le32 __iomem *port_regs, u32 link_state);\nu32 cdnsp_port_state_to_neutral(u32 state);\n\n \nint cdnsp_enable_slot(struct cdnsp_device *pdev);\nint cdnsp_disable_slot(struct cdnsp_device *pdev);\nstruct cdnsp_input_control_ctx\n\t*cdnsp_get_input_control_ctx(struct cdnsp_container_ctx *ctx);\nstruct cdnsp_slot_ctx *cdnsp_get_slot_ctx(struct cdnsp_container_ctx *ctx);\nstruct cdnsp_ep_ctx *cdnsp_get_ep_ctx(struct cdnsp_container_ctx *ctx,\n\t\t\t\t      unsigned int ep_index);\n \nvoid cdnsp_suspend_gadget(struct cdnsp_device *pdev);\nvoid cdnsp_resume_gadget(struct cdnsp_device *pdev);\nvoid cdnsp_disconnect_gadget(struct cdnsp_device *pdev);\nvoid cdnsp_gadget_giveback(struct cdnsp_ep *pep, struct cdnsp_request *preq,\n\t\t\t   int status);\nint cdnsp_ep_enqueue(struct cdnsp_ep *pep, struct cdnsp_request *preq);\nint cdnsp_ep_dequeue(struct cdnsp_ep *pep, struct cdnsp_request *preq);\nunsigned int cdnsp_port_speed(unsigned int port_status);\nvoid cdnsp_irq_reset(struct cdnsp_device *pdev);\nint cdnsp_halt_endpoint(struct cdnsp_device *pdev,\n\t\t\tstruct cdnsp_ep *pep, int value);\nint cdnsp_cmd_stop_ep(struct cdnsp_device *pdev, struct cdnsp_ep *pep);\nint cdnsp_cmd_flush_ep(struct cdnsp_device *pdev, struct cdnsp_ep *pep);\nvoid cdnsp_setup_analyze(struct cdnsp_device *pdev);\nint cdnsp_status_stage(struct cdnsp_device *pdev);\nint cdnsp_reset_device(struct cdnsp_device *pdev);\n\n \nstatic inline struct cdnsp_request *next_request(struct list_head *list)\n{\n\treturn list_first_entry_or_null(list, struct cdnsp_request, list);\n}\n\n#define to_cdnsp_ep(ep) (container_of(ep, struct cdnsp_ep, endpoint))\n#define gadget_to_cdnsp(g) (container_of(g, struct cdnsp_device, gadget))\n#define request_to_cdnsp_request(r) (container_of(r, struct cdnsp_request, \\\n\t\t\t\t     request))\n#define to_cdnsp_request(r) (container_of(r, struct cdnsp_request, request))\nint cdnsp_remove_request(struct cdnsp_device *pdev, struct cdnsp_request *preq,\n\t\t\t struct cdnsp_ep *pep);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}