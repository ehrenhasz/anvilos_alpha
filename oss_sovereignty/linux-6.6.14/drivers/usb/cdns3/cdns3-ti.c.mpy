{
  "module_name": "cdns3-ti.c",
  "hash_id": "10a5ab7e3059836b96f86c073f281ea4c015dcfa2bd4f326da78786a0b874f17",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/cdns3/cdns3-ti.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n\n \n#define USBSS_PID\t\t0x0\n#define\tUSBSS_W1\t\t0x4\n#define USBSS_STATIC_CONFIG\t0x8\n#define USBSS_PHY_TEST\t\t0xc\n#define\tUSBSS_DEBUG_CTRL\t0x10\n#define\tUSBSS_DEBUG_INFO\t0x14\n#define\tUSBSS_DEBUG_LINK_STATE\t0x18\n#define\tUSBSS_DEVICE_CTRL\t0x1c\n\n \n#define USBSS_W1_PWRUP_RST\t\tBIT(0)\n#define USBSS_W1_OVERCURRENT_SEL\tBIT(8)\n#define USBSS_W1_MODESTRAP_SEL\t\tBIT(9)\n#define USBSS_W1_OVERCURRENT\t\tBIT(16)\n#define USBSS_W1_MODESTRAP_MASK\t\tGENMASK(18, 17)\n#define USBSS_W1_MODESTRAP_SHIFT\t17\n#define USBSS_W1_USB2_ONLY\t\tBIT(19)\n\n \n#define USBSS1_STATIC_PLL_REF_SEL_MASK\tGENMASK(8, 5)\n#define USBSS1_STATIC_PLL_REF_SEL_SHIFT\t5\n#define USBSS1_STATIC_LOOPBACK_MODE_MASK\tGENMASK(4, 3)\n#define USBSS1_STATIC_LOOPBACK_MODE_SHIFT\t3\n#define USBSS1_STATIC_VBUS_SEL_MASK\tGENMASK(2, 1)\n#define USBSS1_STATIC_VBUS_SEL_SHIFT\t1\n#define USBSS1_STATIC_LANE_REVERSE\tBIT(0)\n\n \nenum modestrap_mode { USBSS_MODESTRAP_MODE_NONE,\n\t\t      USBSS_MODESTRAP_MODE_HOST,\n\t\t      USBSS_MODESTRAP_MODE_PERIPHERAL};\n\nstruct cdns_ti {\n\tstruct device *dev;\n\tvoid __iomem *usbss;\n\tunsigned usb2_only:1;\n\tunsigned vbus_divider:1;\n\tstruct clk *usb2_refclk;\n\tstruct clk *lpm_clk;\n};\n\nstatic const int cdns_ti_rate_table[] = {\t \n\t9600,\n\t10000,\n\t12000,\n\t19200,\n\t20000,\n\t24000,\n\t25000,\n\t26000,\n\t38400,\n\t40000,\n\t58000,\n\t50000,\n\t52000,\n};\n\nstatic inline u32 cdns_ti_readl(struct cdns_ti *data, u32 offset)\n{\n\treturn readl(data->usbss + offset);\n}\n\nstatic inline void cdns_ti_writel(struct cdns_ti *data, u32 offset, u32 value)\n{\n\twritel(value, data->usbss + offset);\n}\n\nstatic int cdns_ti_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct cdns_ti *data;\n\tint error;\n\tu32 reg;\n\tint rate_code, i;\n\tunsigned long rate;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, data);\n\n\tdata->dev = dev;\n\n\tdata->usbss = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->usbss)) {\n\t\tdev_err(dev, \"can't map IOMEM resource\\n\");\n\t\treturn PTR_ERR(data->usbss);\n\t}\n\n\tdata->usb2_refclk = devm_clk_get(dev, \"ref\");\n\tif (IS_ERR(data->usb2_refclk)) {\n\t\tdev_err(dev, \"can't get usb2_refclk\\n\");\n\t\treturn PTR_ERR(data->usb2_refclk);\n\t}\n\n\tdata->lpm_clk = devm_clk_get(dev, \"lpm\");\n\tif (IS_ERR(data->lpm_clk)) {\n\t\tdev_err(dev, \"can't get lpm_clk\\n\");\n\t\treturn PTR_ERR(data->lpm_clk);\n\t}\n\n\trate = clk_get_rate(data->usb2_refclk);\n\trate /= 1000;\t \n\tfor (i = 0; i < ARRAY_SIZE(cdns_ti_rate_table); i++) {\n\t\tif (cdns_ti_rate_table[i] == rate)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(cdns_ti_rate_table)) {\n\t\tdev_err(dev, \"unsupported usb2_refclk rate: %lu KHz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\trate_code = i;\n\n\tpm_runtime_enable(dev);\n\terror = pm_runtime_get_sync(dev);\n\tif (error < 0) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed: %d\\n\", error);\n\t\tgoto err;\n\t}\n\n\t \n\treg = cdns_ti_readl(data, USBSS_W1);\n\treg &= ~USBSS_W1_PWRUP_RST;\n\tcdns_ti_writel(data, USBSS_W1, reg);\n\n\t \n\treg = cdns_ti_readl(data, USBSS_STATIC_CONFIG);\n\treg &= ~USBSS1_STATIC_PLL_REF_SEL_MASK;\n\treg |= rate_code << USBSS1_STATIC_PLL_REF_SEL_SHIFT;\n\n\treg &= ~USBSS1_STATIC_VBUS_SEL_MASK;\n\tdata->vbus_divider = device_property_read_bool(dev, \"ti,vbus-divider\");\n\tif (data->vbus_divider)\n\t\treg |= 1 << USBSS1_STATIC_VBUS_SEL_SHIFT;\n\n\tcdns_ti_writel(data, USBSS_STATIC_CONFIG, reg);\n\treg = cdns_ti_readl(data, USBSS_STATIC_CONFIG);\n\n\t \n\treg = cdns_ti_readl(data, USBSS_W1);\n\tdata->usb2_only = device_property_read_bool(dev, \"ti,usb2-only\");\n\tif (data->usb2_only)\n\t\treg |= USBSS_W1_USB2_ONLY;\n\n\t \n\treg |= USBSS_W1_MODESTRAP_SEL;\n\treg &= ~USBSS_W1_MODESTRAP_MASK;\n\treg |= USBSS_MODESTRAP_MODE_NONE << USBSS_W1_MODESTRAP_SHIFT;\n\tcdns_ti_writel(data, USBSS_W1, reg);\n\n\t \n\treg |= USBSS_W1_PWRUP_RST;\n\tcdns_ti_writel(data, USBSS_W1, reg);\n\n\terror = of_platform_populate(node, NULL, NULL, dev);\n\tif (error) {\n\t\tdev_err(dev, \"failed to create children: %d\\n\", error);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpm_runtime_put_sync(data->dev);\n\tpm_runtime_disable(data->dev);\n\n\treturn error;\n}\n\nstatic int cdns_ti_remove_core(struct device *dev, void *c)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tplatform_device_unregister(pdev);\n\n\treturn 0;\n}\n\nstatic void cdns_ti_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tdevice_for_each_child(dev, NULL, cdns_ti_remove_core);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic const struct of_device_id cdns_ti_of_match[] = {\n\t{ .compatible = \"ti,j721e-usb\", },\n\t{ .compatible = \"ti,am64-usb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, cdns_ti_of_match);\n\nstatic struct platform_driver cdns_ti_driver = {\n\t.probe\t\t= cdns_ti_probe,\n\t.remove_new\t= cdns_ti_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"cdns3-ti\",\n\t\t.of_match_table\t= cdns_ti_of_match,\n\t},\n};\n\nmodule_platform_driver(cdns_ti_driver);\n\nMODULE_ALIAS(\"platform:cdns3-ti\");\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Cadence USB3 TI Glue Layer\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}