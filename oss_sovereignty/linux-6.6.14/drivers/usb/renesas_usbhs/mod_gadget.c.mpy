{
  "module_name": "mod_gadget.c",
  "hash_id": "0cbf159989f70c5349ec8a7c775c808f66a471ccb80bcc7ee3e7b6e37fca0c05",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/mod_gadget.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include \"common.h\"\n\n \nstruct usbhsg_request {\n\tstruct usb_request\treq;\n\tstruct usbhs_pkt\tpkt;\n};\n\n#define EP_NAME_SIZE 8\nstruct usbhsg_gpriv;\nstruct usbhsg_uep {\n\tstruct usb_ep\t\t ep;\n\tstruct usbhs_pipe\t*pipe;\n\tspinlock_t\t\tlock;\t \n\n\tchar ep_name[EP_NAME_SIZE];\n\n\tstruct usbhsg_gpriv *gpriv;\n};\n\nstruct usbhsg_gpriv {\n\tstruct usb_gadget\t gadget;\n\tstruct usbhs_mod\t mod;\n\n\tstruct usbhsg_uep\t*uep;\n\tint\t\t\t uep_size;\n\n\tstruct usb_gadget_driver\t*driver;\n\tstruct usb_phy\t\t*transceiver;\n\tbool\t\t\t vbus_active;\n\n\tu32\tstatus;\n#define USBHSG_STATUS_STARTED\t\t(1 << 0)\n#define USBHSG_STATUS_REGISTERD\t\t(1 << 1)\n#define USBHSG_STATUS_WEDGE\t\t(1 << 2)\n#define USBHSG_STATUS_SELF_POWERED\t(1 << 3)\n#define USBHSG_STATUS_SOFT_CONNECT\t(1 << 4)\n};\n\nstruct usbhsg_recip_handle {\n\tchar *name;\n\tint (*device)(struct usbhs_priv *priv, struct usbhsg_uep *uep,\n\t\t      struct usb_ctrlrequest *ctrl);\n\tint (*interface)(struct usbhs_priv *priv, struct usbhsg_uep *uep,\n\t\t\t struct usb_ctrlrequest *ctrl);\n\tint (*endpoint)(struct usbhs_priv *priv, struct usbhsg_uep *uep,\n\t\t\tstruct usb_ctrlrequest *ctrl);\n};\n\n \n#define usbhsg_priv_to_gpriv(priv)\t\t\t\\\n\tcontainer_of(\t\t\t\t\t\\\n\t\tusbhs_mod_get(priv, USBHS_GADGET),\t\\\n\t\tstruct usbhsg_gpriv, mod)\n\n#define __usbhsg_for_each_uep(start, pos, g, i)\t\\\n\tfor ((i) = start;\t\t\t\t\t\\\n\t     ((i) < (g)->uep_size) && ((pos) = (g)->uep + (i));\t\\\n\t     (i)++)\n\n#define usbhsg_for_each_uep(pos, gpriv, i)\t\\\n\t__usbhsg_for_each_uep(1, pos, gpriv, i)\n\n#define usbhsg_for_each_uep_with_dcp(pos, gpriv, i)\t\\\n\t__usbhsg_for_each_uep(0, pos, gpriv, i)\n\n#define usbhsg_gadget_to_gpriv(g)\\\n\tcontainer_of(g, struct usbhsg_gpriv, gadget)\n\n#define usbhsg_req_to_ureq(r)\\\n\tcontainer_of(r, struct usbhsg_request, req)\n\n#define usbhsg_ep_to_uep(e)\t\tcontainer_of(e, struct usbhsg_uep, ep)\n#define usbhsg_gpriv_to_dev(gp)\t\tusbhs_priv_to_dev((gp)->mod.priv)\n#define usbhsg_gpriv_to_priv(gp)\t((gp)->mod.priv)\n#define usbhsg_gpriv_to_dcp(gp)\t\t((gp)->uep)\n#define usbhsg_gpriv_to_nth_uep(gp, i)\t((gp)->uep + i)\n#define usbhsg_uep_to_gpriv(u)\t\t((u)->gpriv)\n#define usbhsg_uep_to_pipe(u)\t\t((u)->pipe)\n#define usbhsg_pipe_to_uep(p)\t\t((p)->mod_private)\n#define usbhsg_is_dcp(u)\t\t((u) == usbhsg_gpriv_to_dcp((u)->gpriv))\n\n#define usbhsg_ureq_to_pkt(u)\t\t(&(u)->pkt)\n#define usbhsg_pkt_to_ureq(i)\t\\\n\tcontainer_of(i, struct usbhsg_request, pkt)\n\n#define usbhsg_is_not_connected(gp) ((gp)->gadget.speed == USB_SPEED_UNKNOWN)\n\n \n#define usbhsg_status_init(gp)   do {(gp)->status = 0; } while (0)\n#define usbhsg_status_set(gp, b) (gp->status |=  b)\n#define usbhsg_status_clr(gp, b) (gp->status &= ~b)\n#define usbhsg_status_has(gp, b) (gp->status &   b)\n\n \nstatic void __usbhsg_queue_pop(struct usbhsg_uep *uep,\n\t\t\t       struct usbhsg_request *ureq,\n\t\t\t       int status)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\n\tif (pipe)\n\t\tdev_dbg(dev, \"pipe %d : queue pop\\n\", usbhs_pipe_number(pipe));\n\n\tureq->req.status = status;\n\tspin_unlock(usbhs_priv_to_lock(priv));\n\tusb_gadget_giveback_request(&uep->ep, &ureq->req);\n\tspin_lock(usbhs_priv_to_lock(priv));\n}\n\nstatic void usbhsg_queue_pop(struct usbhsg_uep *uep,\n\t\t\t     struct usbhsg_request *ureq,\n\t\t\t     int status)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tunsigned long flags;\n\n\tusbhs_lock(priv, flags);\n\t__usbhsg_queue_pop(uep, ureq, status);\n\tusbhs_unlock(priv, flags);\n}\n\nstatic void usbhsg_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhsg_uep *uep = usbhsg_pipe_to_uep(pipe);\n\tstruct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);\n\tunsigned long flags;\n\n\tureq->req.actual = pkt->actual;\n\n\tusbhs_lock(priv, flags);\n\tif (uep)\n\t\t__usbhsg_queue_pop(uep, ureq, 0);\n\tusbhs_unlock(priv, flags);\n}\n\nstatic void usbhsg_queue_push(struct usbhsg_uep *uep,\n\t\t\t      struct usbhsg_request *ureq)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\tstruct usbhs_pkt *pkt = usbhsg_ureq_to_pkt(ureq);\n\tstruct usb_request *req = &ureq->req;\n\n\treq->actual = 0;\n\treq->status = -EINPROGRESS;\n\tusbhs_pkt_push(pipe, pkt, usbhsg_queue_done,\n\t\t       req->buf, req->length, req->zero, -1);\n\tusbhs_pkt_start(pipe);\n\n\tdev_dbg(dev, \"pipe %d : queue push (%d)\\n\",\n\t\tusbhs_pipe_number(pipe),\n\t\treq->length);\n}\n\n \nstatic int usbhsg_dma_map_ctrl(struct device *dma_dev, struct usbhs_pkt *pkt,\n\t\t\t       int map)\n{\n\tstruct usbhsg_request *ureq = usbhsg_pkt_to_ureq(pkt);\n\tstruct usb_request *req = &ureq->req;\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tenum dma_data_direction dir;\n\tint ret = 0;\n\n\tdir = usbhs_pipe_is_dir_host(pipe);\n\n\tif (map) {\n\t\t \n\t\tWARN_ON(req->num_sgs);\n\n\t\tret = usb_gadget_map_request_by_dev(dma_dev, req, dir);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tpkt->dma = req->dma;\n\t} else {\n\t\tusb_gadget_unmap_request_by_dev(dma_dev, req, dir);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int usbhsg_recip_handler_std_control_done(struct usbhs_priv *priv,\n\t\t\t\t\t\t struct usbhsg_uep *uep,\n\t\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\n\n\tusbhs_dcp_control_transfer_done(pipe);\n\n\treturn 0;\n}\n\nstatic int usbhsg_recip_handler_std_clear_endpoint(struct usbhs_priv *priv,\n\t\t\t\t\t\t   struct usbhsg_uep *uep,\n\t\t\t\t\t\t   struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\n\tif (!usbhsg_status_has(gpriv, USBHSG_STATUS_WEDGE)) {\n\t\tusbhs_pipe_disable(pipe);\n\t\tusbhs_pipe_sequence_data0(pipe);\n\t\tusbhs_pipe_enable(pipe);\n\t}\n\n\tusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\n\n\tusbhs_pkt_start(pipe);\n\n\treturn 0;\n}\n\nstatic struct usbhsg_recip_handle req_clear_feature = {\n\t.name\t\t= \"clear feature\",\n\t.device\t\t= usbhsg_recip_handler_std_control_done,\n\t.interface\t= usbhsg_recip_handler_std_control_done,\n\t.endpoint\t= usbhsg_recip_handler_std_clear_endpoint,\n};\n\n \nstatic int usbhsg_recip_handler_std_set_device(struct usbhs_priv *priv,\n\t\t\t\t\t\t struct usbhsg_uep *uep,\n\t\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tswitch (le16_to_cpu(ctrl->wValue)) {\n\tcase USB_DEVICE_TEST_MODE:\n\t\tusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\n\t\tudelay(100);\n\t\tusbhs_sys_set_test_mode(priv, le16_to_cpu(ctrl->wIndex) >> 8);\n\t\tbreak;\n\tdefault:\n\t\tusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int usbhsg_recip_handler_std_set_endpoint(struct usbhs_priv *priv,\n\t\t\t\t\t\t struct usbhsg_uep *uep,\n\t\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\n\tusbhs_pipe_stall(pipe);\n\n\tusbhsg_recip_handler_std_control_done(priv, uep, ctrl);\n\n\treturn 0;\n}\n\nstatic struct usbhsg_recip_handle req_set_feature = {\n\t.name\t\t= \"set feature\",\n\t.device\t\t= usbhsg_recip_handler_std_set_device,\n\t.interface\t= usbhsg_recip_handler_std_control_done,\n\t.endpoint\t= usbhsg_recip_handler_std_set_endpoint,\n};\n\n \nstatic void __usbhsg_recip_send_complete(struct usb_ep *ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\n\n\t \n\tkfree(ureq->pkt.buf);\n\tusb_ep_free_request(ep, req);\n}\n\nstatic void __usbhsg_recip_send_status(struct usbhsg_gpriv *gpriv,\n\t\t\t\t       unsigned short status)\n{\n\tstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tstruct usb_request *req;\n\t__le16 *buf;\n\n\t \n\treq = usb_ep_alloc_request(&dcp->ep, GFP_ATOMIC);\n\tif (!req) {\n\t\tdev_err(dev, \"recip request allocation fail\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbuf = kmalloc(sizeof(*buf), GFP_ATOMIC);\n\tif (!buf) {\n\t\tusb_ep_free_request(&dcp->ep, req);\n\t\treturn;\n\t}\n\n\t \n\t*buf = cpu_to_le16(status);\n\n\t \n\treq->complete\t= __usbhsg_recip_send_complete;\n\treq->buf\t= buf;\n\treq->length\t= sizeof(*buf);\n\treq->zero\t= 0;\n\n\t \n\tpipe->handler = &usbhs_fifo_pio_push_handler;\n\tusbhsg_queue_push(dcp, usbhsg_req_to_ureq(req));\n}\n\nstatic int usbhsg_recip_handler_std_get_device(struct usbhs_priv *priv,\n\t\t\t\t\t       struct usbhsg_uep *uep,\n\t\t\t\t\t       struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tunsigned short status = 0;\n\n\tif (usbhsg_status_has(gpriv, USBHSG_STATUS_SELF_POWERED))\n\t\tstatus = 1 << USB_DEVICE_SELF_POWERED;\n\n\t__usbhsg_recip_send_status(gpriv, status);\n\n\treturn 0;\n}\n\nstatic int usbhsg_recip_handler_std_get_interface(struct usbhs_priv *priv,\n\t\t\t\t\t\t  struct usbhsg_uep *uep,\n\t\t\t\t\t\t  struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tunsigned short status = 0;\n\n\t__usbhsg_recip_send_status(gpriv, status);\n\n\treturn 0;\n}\n\nstatic int usbhsg_recip_handler_std_get_endpoint(struct usbhs_priv *priv,\n\t\t\t\t\t\t struct usbhsg_uep *uep,\n\t\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\tunsigned short status = 0;\n\n\tif (usbhs_pipe_is_stall(pipe))\n\t\tstatus = 1 << USB_ENDPOINT_HALT;\n\n\t__usbhsg_recip_send_status(gpriv, status);\n\n\treturn 0;\n}\n\nstatic struct usbhsg_recip_handle req_get_status = {\n\t.name\t\t= \"get status\",\n\t.device\t\t= usbhsg_recip_handler_std_get_device,\n\t.interface\t= usbhsg_recip_handler_std_get_interface,\n\t.endpoint\t= usbhsg_recip_handler_std_get_endpoint,\n};\n\n \nstatic int usbhsg_recip_run_handle(struct usbhs_priv *priv,\n\t\t\t\t   struct usbhsg_recip_handle *handler,\n\t\t\t\t   struct usb_ctrlrequest *ctrl)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tstruct usbhsg_uep *uep;\n\tstruct usbhs_pipe *pipe;\n\tint recip = ctrl->bRequestType & USB_RECIP_MASK;\n\tint nth = le16_to_cpu(ctrl->wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\tint ret = 0;\n\tint (*func)(struct usbhs_priv *priv, struct usbhsg_uep *uep,\n\t\t    struct usb_ctrlrequest *ctrl);\n\tchar *msg;\n\n\tuep = usbhsg_gpriv_to_nth_uep(gpriv, nth);\n\tpipe = usbhsg_uep_to_pipe(uep);\n\tif (!pipe) {\n\t\tdev_err(dev, \"wrong recip request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tmsg\t= \"DEVICE\";\n\t\tfunc\t= handler->device;\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\tmsg\t= \"INTERFACE\";\n\t\tfunc\t= handler->interface;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tmsg\t= \"ENDPOINT\";\n\t\tfunc\t= handler->endpoint;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unsupported RECIP(%d)\\n\", recip);\n\t\tfunc = NULL;\n\t\tret = -EINVAL;\n\t}\n\n\tif (func) {\n\t\tdev_dbg(dev, \"%s (pipe %d :%s)\\n\", handler->name, nth, msg);\n\t\tret = func(priv, uep, ctrl);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int usbhsg_irq_dev_state(struct usbhs_priv *priv,\n\t\t\t\tstruct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tint state = usbhs_status_get_device_state(irq_state);\n\n\tgpriv->gadget.speed = usbhs_bus_get_speed(priv);\n\n\tdev_dbg(dev, \"state = %x : speed : %d\\n\", state, gpriv->gadget.speed);\n\n\tif (gpriv->gadget.speed != USB_SPEED_UNKNOWN &&\n\t    (state & SUSPENDED_STATE)) {\n\t\tif (gpriv->driver && gpriv->driver->suspend)\n\t\t\tgpriv->driver->suspend(&gpriv->gadget);\n\t\tusb_gadget_set_state(&gpriv->gadget, USB_STATE_SUSPENDED);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbhsg_irq_ctrl_stage(struct usbhs_priv *priv,\n\t\t\t\t struct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(dcp);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tstruct usb_ctrlrequest ctrl;\n\tstruct usbhsg_recip_handle *recip_handler = NULL;\n\tint stage = usbhs_status_get_ctrl_stage(irq_state);\n\tint ret = 0;\n\n\tdev_dbg(dev, \"stage = %d\\n\", stage);\n\n\t \n\n\tswitch (stage) {\n\tcase READ_DATA_STAGE:\n\t\tpipe->handler = &usbhs_fifo_pio_push_handler;\n\t\tbreak;\n\tcase WRITE_DATA_STAGE:\n\t\tpipe->handler = &usbhs_fifo_pio_pop_handler;\n\t\tbreak;\n\tcase NODATA_STATUS_STAGE:\n\t\tpipe->handler = &usbhs_ctrl_stage_end_handler;\n\t\tbreak;\n\tcase READ_STATUS_STAGE:\n\tcase WRITE_STATUS_STAGE:\n\t\tusbhs_dcp_control_transfer_done(pipe);\n\t\tfallthrough;\n\tdefault:\n\t\treturn ret;\n\t}\n\n\t \n\tusbhs_usbreq_get_val(priv, &ctrl);\n\n\tswitch (ctrl.bRequestType & USB_TYPE_MASK) {\n\tcase USB_TYPE_STANDARD:\n\t\tswitch (ctrl.bRequest) {\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\t\trecip_handler = &req_clear_feature;\n\t\t\tbreak;\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\trecip_handler = &req_set_feature;\n\t\t\tbreak;\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\trecip_handler = &req_get_status;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (recip_handler)\n\t\tret = usbhsg_recip_run_handle(priv, recip_handler, &ctrl);\n\telse\n\t\tret = gpriv->driver->setup(&gpriv->gadget, &ctrl);\n\n\tif (ret < 0)\n\t\tusbhs_pipe_stall(pipe);\n\n\treturn ret;\n}\n\n \nstatic int usbhsg_pipe_disable(struct usbhsg_uep *uep)\n{\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\tstruct usbhs_pkt *pkt;\n\n\twhile (1) {\n\t\tpkt = usbhs_pkt_pop(pipe, NULL);\n\t\tif (!pkt)\n\t\t\tbreak;\n\n\t\tusbhsg_queue_pop(uep, usbhsg_pkt_to_ureq(pkt), -ESHUTDOWN);\n\t}\n\n\tusbhs_pipe_disable(pipe);\n\n\treturn 0;\n}\n\n \nstatic int usbhsg_ep_enable(struct usb_ep *ep,\n\t\t\t const struct usb_endpoint_descriptor *desc)\n{\n\tstruct usbhsg_uep *uep   = usbhsg_ep_to_uep(ep);\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tstruct usbhs_pipe *pipe;\n\tint ret = -EIO;\n\tunsigned long flags;\n\n\tusbhs_lock(priv, flags);\n\n\t \n\tif (uep->pipe) {\n\t\tusbhs_pipe_clear(uep->pipe);\n\t\tusbhs_pipe_sequence_data0(uep->pipe);\n\t\tret = 0;\n\t\tgoto usbhsg_ep_enable_end;\n\t}\n\n\tpipe = usbhs_pipe_malloc(priv,\n\t\t\t\t usb_endpoint_type(desc),\n\t\t\t\t usb_endpoint_dir_in(desc));\n\tif (pipe) {\n\t\tuep->pipe\t\t= pipe;\n\t\tpipe->mod_private\t= uep;\n\n\t\t \n\t\tusbhs_pipe_config_update(pipe, 0,\n\t\t\t\t\t usb_endpoint_num(desc),\n\t\t\t\t\t usb_endpoint_maxp(desc));\n\n\t\t \n\t\tif (usb_endpoint_dir_in(desc)) {\n\t\t\tpipe->handler = &usbhs_fifo_dma_push_handler;\n\t\t} else {\n\t\t\tpipe->handler = &usbhs_fifo_dma_pop_handler;\n\t\t\tusbhs_xxxsts_clear(priv, BRDYSTS,\n\t\t\t\t\t   usbhs_pipe_number(pipe));\n\t\t}\n\n\t\tret = 0;\n\t}\n\nusbhsg_ep_enable_end:\n\tusbhs_unlock(priv, flags);\n\n\treturn ret;\n}\n\nstatic int usbhsg_ep_disable(struct usb_ep *ep)\n{\n\tstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\n\tstruct usbhs_pipe *pipe;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uep->lock, flags);\n\tpipe = usbhsg_uep_to_pipe(uep);\n\tif (!pipe)\n\t\tgoto out;\n\n\tusbhsg_pipe_disable(uep);\n\tusbhs_pipe_free(pipe);\n\n\tuep->pipe->mod_private\t= NULL;\n\tuep->pipe\t\t= NULL;\n\nout:\n\tspin_unlock_irqrestore(&uep->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_request *usbhsg_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t   gfp_t gfp_flags)\n{\n\tstruct usbhsg_request *ureq;\n\n\tureq = kzalloc(sizeof *ureq, gfp_flags);\n\tif (!ureq)\n\t\treturn NULL;\n\n\tusbhs_pkt_init(usbhsg_ureq_to_pkt(ureq));\n\n\treturn &ureq->req;\n}\n\nstatic void usbhsg_ep_free_request(struct usb_ep *ep,\n\t\t\t\t   struct usb_request *req)\n{\n\tstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\n\n\tWARN_ON(!list_empty(&ureq->pkt.node));\n\tkfree(ureq);\n}\n\nstatic int usbhsg_ep_queue(struct usb_ep *ep, struct usb_request *req,\n\t\t\t  gfp_t gfp_flags)\n{\n\tstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\n\t \n\tif (usbhsg_is_not_connected(gpriv)\t||\n\t    unlikely(!gpriv->driver)\t\t||\n\t    unlikely(!pipe))\n\t\treturn -ESHUTDOWN;\n\n\tusbhsg_queue_push(uep, ureq);\n\n\treturn 0;\n}\n\nstatic int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\n\tstruct usbhsg_request *ureq = usbhsg_req_to_ureq(req);\n\tstruct usbhs_pipe *pipe;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uep->lock, flags);\n\tpipe = usbhsg_uep_to_pipe(uep);\n\tif (pipe)\n\t\tusbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));\n\n\t \n\tusbhsg_queue_pop(uep, ureq, -ECONNRESET);\n\tspin_unlock_irqrestore(&uep->lock, flags);\n\n\treturn 0;\n}\n\nstatic int __usbhsg_ep_set_halt_wedge(struct usb_ep *ep, int halt, int wedge)\n{\n\tstruct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);\n\tstruct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);\n\tstruct usbhsg_gpriv *gpriv = usbhsg_uep_to_gpriv(uep);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tstruct device *dev = usbhsg_gpriv_to_dev(gpriv);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdev_dbg(dev, \"set halt %d (pipe %d)\\n\",\n\t\thalt, usbhs_pipe_number(pipe));\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tif (!usbhs_pipe_is_dir_in(pipe) && (__usbhsf_pkt_get(pipe) ||\n\t    usbhs_pipe_contains_transmittable_data(pipe))) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\tif (halt)\n\t\tusbhs_pipe_stall(pipe);\n\telse\n\t\tusbhs_pipe_disable(pipe);\n\n\tif (halt && wedge)\n\t\tusbhsg_status_set(gpriv, USBHSG_STATUS_WEDGE);\n\telse\n\t\tusbhsg_status_clr(gpriv, USBHSG_STATUS_WEDGE);\n\nout:\n\tusbhs_unlock(priv, flags);\n\t \n\n\treturn ret;\n}\n\nstatic int usbhsg_ep_set_halt(struct usb_ep *ep, int value)\n{\n\treturn __usbhsg_ep_set_halt_wedge(ep, value, 0);\n}\n\nstatic int usbhsg_ep_set_wedge(struct usb_ep *ep)\n{\n\treturn __usbhsg_ep_set_halt_wedge(ep, 1, 1);\n}\n\nstatic const struct usb_ep_ops usbhsg_ep_ops = {\n\t.enable\t\t= usbhsg_ep_enable,\n\t.disable\t= usbhsg_ep_disable,\n\n\t.alloc_request\t= usbhsg_ep_alloc_request,\n\t.free_request\t= usbhsg_ep_free_request,\n\n\t.queue\t\t= usbhsg_ep_queue,\n\t.dequeue\t= usbhsg_ep_dequeue,\n\n\t.set_halt\t= usbhsg_ep_set_halt,\n\t.set_wedge\t= usbhsg_ep_set_wedge,\n};\n\n \nstatic int usbhsg_can_pullup(struct usbhs_priv *priv)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\n\treturn gpriv->driver &&\n\t       usbhsg_status_has(gpriv, USBHSG_STATUS_SOFT_CONNECT);\n}\n\nstatic void usbhsg_update_pullup(struct usbhs_priv *priv)\n{\n\tif (usbhsg_can_pullup(priv))\n\t\tusbhs_sys_function_pullup(priv, 1);\n\telse\n\t\tusbhs_sys_function_pullup(priv, 0);\n}\n\n \nstatic int usbhsg_try_start(struct usbhs_priv *priv, u32 status)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tusbhsg_status_set(gpriv, status);\n\tif (!(usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&\n\t      usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD)))\n\t\tret = -1;  \n\n\tusbhs_unlock(priv, flags);\n\t \n\n\tif (ret < 0)\n\t\treturn 0;  \n\n\t \n\tdev_dbg(dev, \"start gadget\\n\");\n\n\t \n\tusbhs_fifo_init(priv);\n\tusbhs_pipe_init(priv,\n\t\t\tusbhsg_dma_map_ctrl);\n\n\t \n\tdcp->pipe\t\t= usbhs_dcp_malloc(priv);\n\tdcp->pipe->mod_private\t= dcp;\n\tusbhs_pipe_config_update(dcp->pipe, 0, 0, 64);\n\n\t \n\tusbhs_sys_function_ctrl(priv, 1);\n\tusbhsg_update_pullup(priv);\n\n\t \n\tmod->irq_dev_state\t= usbhsg_irq_dev_state;\n\tmod->irq_ctrl_stage\t= usbhsg_irq_ctrl_stage;\n\tusbhs_irq_callback_update(priv, mod);\n\n\treturn 0;\n}\n\nstatic int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct usbhsg_uep *uep;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tunsigned long flags;\n\tint ret = 0, i;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tusbhsg_status_clr(gpriv, status);\n\tif (!usbhsg_status_has(gpriv, USBHSG_STATUS_STARTED) &&\n\t    !usbhsg_status_has(gpriv, USBHSG_STATUS_REGISTERD))\n\t\tret = -1;  \n\n\tusbhs_unlock(priv, flags);\n\t \n\n\tif (ret < 0)\n\t\treturn 0;  \n\n\t \n\tusbhs_fifo_quit(priv);\n\n\t \n\tmod->irq_dev_state\t= NULL;\n\tmod->irq_ctrl_stage\t= NULL;\n\tusbhs_irq_callback_update(priv, mod);\n\n\tgpriv->gadget.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tusbhs_sys_set_test_mode(priv, 0);\n\tusbhs_sys_function_ctrl(priv, 0);\n\n\t \n\tusbhsg_for_each_uep_with_dcp(uep, gpriv, i)\n\t\tusbhsg_ep_disable(&uep->ep);\n\n\tdev_dbg(dev, \"stop gadget\\n\");\n\n\treturn 0;\n}\n\n \nstatic int usbhsm_phy_get_vbus(struct platform_device *pdev)\n{\n\tstruct usbhs_priv *priv = usbhs_pdev_to_priv(pdev);\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\n\treturn  gpriv->vbus_active;\n}\n\nstatic void usbhs_mod_phy_mode(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod_info *info = &priv->mod_info;\n\n\tinfo->irq_vbus = NULL;\n\tinfo->get_vbus = usbhsm_phy_get_vbus;\n\n\tusbhs_irq_callback_update(priv, NULL);\n}\n\n \nstatic int usbhsg_gadget_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\tif (!driver\t\t||\n\t    !driver->setup\t||\n\t    driver->max_speed < USB_SPEED_FULL)\n\t\treturn -EINVAL;\n\n\t \n\tif (!IS_ERR_OR_NULL(gpriv->transceiver)) {\n\t\tret = otg_set_peripheral(gpriv->transceiver->otg,\n\t\t\t\t\t&gpriv->gadget);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"%s: can't bind to transceiver\\n\",\n\t\t\t\tgpriv->gadget.name);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tusbhs_mod_phy_mode(priv);\n\t}\n\n\t \n\tgpriv->driver = driver;\n\n\treturn usbhsg_try_start(priv, USBHSG_STATUS_REGISTERD);\n}\n\nstatic int usbhsg_gadget_stop(struct usb_gadget *gadget)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\n\tusbhsg_try_stop(priv, USBHSG_STATUS_REGISTERD);\n\n\tif (!IS_ERR_OR_NULL(gpriv->transceiver))\n\t\totg_set_peripheral(gpriv->transceiver->otg, NULL);\n\n\tgpriv->driver = NULL;\n\n\treturn 0;\n}\n\n \nstatic int usbhsg_get_frame(struct usb_gadget *gadget)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\n\treturn usbhs_frame_get_num(priv);\n}\n\nstatic int usbhsg_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tunsigned long flags;\n\n\tusbhs_lock(priv, flags);\n\tif (is_on)\n\t\tusbhsg_status_set(gpriv, USBHSG_STATUS_SOFT_CONNECT);\n\telse\n\t\tusbhsg_status_clr(gpriv, USBHSG_STATUS_SOFT_CONNECT);\n\tusbhsg_update_pullup(priv);\n\tusbhs_unlock(priv, flags);\n\n\treturn 0;\n}\n\nstatic int usbhsg_set_selfpowered(struct usb_gadget *gadget, int is_self)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\n\tif (is_self)\n\t\tusbhsg_status_set(gpriv, USBHSG_STATUS_SELF_POWERED);\n\telse\n\t\tusbhsg_status_clr(gpriv, USBHSG_STATUS_SELF_POWERED);\n\n\tgadget->is_selfpowered = (is_self != 0);\n\n\treturn 0;\n}\n\nstatic int usbhsg_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_gadget_to_gpriv(gadget);\n\tstruct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\n\tgpriv->vbus_active = !!is_active;\n\n\tusbhsc_schedule_notify_hotplug(pdev);\n\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops usbhsg_gadget_ops = {\n\t.get_frame\t\t= usbhsg_get_frame,\n\t.set_selfpowered\t= usbhsg_set_selfpowered,\n\t.udc_start\t\t= usbhsg_gadget_start,\n\t.udc_stop\t\t= usbhsg_gadget_stop,\n\t.pullup\t\t\t= usbhsg_pullup,\n\t.vbus_session\t\t= usbhsg_vbus_session,\n};\n\nstatic int usbhsg_start(struct usbhs_priv *priv)\n{\n\treturn usbhsg_try_start(priv, USBHSG_STATUS_STARTED);\n}\n\nstatic int usbhsg_stop(struct usbhs_priv *priv)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\n\t \n\tif (gpriv->driver &&\n\t    gpriv->driver->disconnect)\n\t\tgpriv->driver->disconnect(&gpriv->gadget);\n\n\treturn usbhsg_try_stop(priv, USBHSG_STATUS_STARTED);\n}\n\nint usbhs_mod_gadget_probe(struct usbhs_priv *priv)\n{\n\tstruct usbhsg_gpriv *gpriv;\n\tstruct usbhsg_uep *uep;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct renesas_usbhs_driver_pipe_config *pipe_configs =\n\t\t\t\t\tusbhs_get_dparam(priv, pipe_configs);\n\tint pipe_size = usbhs_get_dparam(priv, pipe_size);\n\tint i;\n\tint ret;\n\n\tgpriv = kzalloc(sizeof(struct usbhsg_gpriv), GFP_KERNEL);\n\tif (!gpriv)\n\t\treturn -ENOMEM;\n\n\tuep = kcalloc(pipe_size, sizeof(struct usbhsg_uep), GFP_KERNEL);\n\tif (!uep) {\n\t\tret = -ENOMEM;\n\t\tgoto usbhs_mod_gadget_probe_err_gpriv;\n\t}\n\n\tgpriv->transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);\n\tdev_info(dev, \"%stransceiver found\\n\",\n\t\t !IS_ERR(gpriv->transceiver) ? \"\" : \"no \");\n\n\t \n\n\t \n\tusbhs_mod_register(priv, &gpriv->mod, USBHS_GADGET);\n\n\t \n\tgpriv->mod.name\t\t= \"gadget\";\n\tgpriv->mod.start\t= usbhsg_start;\n\tgpriv->mod.stop\t\t= usbhsg_stop;\n\tgpriv->uep\t\t= uep;\n\tgpriv->uep_size\t\t= pipe_size;\n\tusbhsg_status_init(gpriv);\n\n\t \n\tgpriv->gadget.dev.parent\t= dev;\n\tgpriv->gadget.name\t\t= \"renesas_usbhs_udc\";\n\tgpriv->gadget.ops\t\t= &usbhsg_gadget_ops;\n\tgpriv->gadget.max_speed\t\t= USB_SPEED_HIGH;\n\tgpriv->gadget.quirk_avoids_skb_reserve = usbhs_get_dparam(priv,\n\t\t\t\t\t\t\t\thas_usb_dmac);\n\n\tINIT_LIST_HEAD(&gpriv->gadget.ep_list);\n\n\t \n\tusbhsg_for_each_uep_with_dcp(uep, gpriv, i) {\n\t\tuep->gpriv\t= gpriv;\n\t\tuep->pipe\t= NULL;\n\t\tsnprintf(uep->ep_name, EP_NAME_SIZE, \"ep%d\", i);\n\n\t\tuep->ep.name\t\t= uep->ep_name;\n\t\tuep->ep.ops\t\t= &usbhsg_ep_ops;\n\t\tINIT_LIST_HEAD(&uep->ep.ep_list);\n\t\tspin_lock_init(&uep->lock);\n\n\t\t \n\t\tif (usbhsg_is_dcp(uep)) {\n\t\t\tgpriv->gadget.ep0 = &uep->ep;\n\t\t\tusb_ep_set_maxpacket_limit(&uep->ep, 64);\n\t\t\tuep->ep.caps.type_control = true;\n\t\t} else {\n\t\t\t \n\t\t\tif (pipe_configs[i].type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t\tuep->ep.caps.type_iso = true;\n\t\t\tif (pipe_configs[i].type == USB_ENDPOINT_XFER_BULK)\n\t\t\t\tuep->ep.caps.type_bulk = true;\n\t\t\tif (pipe_configs[i].type == USB_ENDPOINT_XFER_INT)\n\t\t\t\tuep->ep.caps.type_int = true;\n\t\t\tusb_ep_set_maxpacket_limit(&uep->ep,\n\t\t\t\t\t\t   pipe_configs[i].bufsize);\n\t\t\tlist_add_tail(&uep->ep.ep_list, &gpriv->gadget.ep_list);\n\t\t}\n\t\tuep->ep.caps.dir_in = true;\n\t\tuep->ep.caps.dir_out = true;\n\t}\n\n\tret = usb_add_gadget_udc(dev, &gpriv->gadget);\n\tif (ret)\n\t\tgoto err_add_udc;\n\n\n\tdev_info(dev, \"gadget probed\\n\");\n\n\treturn 0;\n\nerr_add_udc:\n\tkfree(gpriv->uep);\n\nusbhs_mod_gadget_probe_err_gpriv:\n\tkfree(gpriv);\n\n\treturn ret;\n}\n\nvoid usbhs_mod_gadget_remove(struct usbhs_priv *priv)\n{\n\tstruct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);\n\n\tusb_del_gadget_udc(&gpriv->gadget);\n\n\tkfree(gpriv->uep);\n\tkfree(gpriv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}