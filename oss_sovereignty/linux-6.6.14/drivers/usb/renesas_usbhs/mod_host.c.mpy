{
  "module_name": "mod_host.c",
  "hash_id": "c33d47946db9d56661d5ffea71a766bcf7cf65cde0b965cee68f6f23b1688a68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/mod_host.c",
  "human_readable_source": "\n \n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"common.h\"\n\n \n\n\n \n\n\n \nstruct usbhsh_request {\n\tstruct urb\t\t*urb;\n\tstruct usbhs_pkt\tpkt;\n};\n\nstruct usbhsh_device {\n\tstruct usb_device\t*usbv;\n\tstruct list_head\tep_list_head;  \n};\n\nstruct usbhsh_ep {\n\tstruct usbhs_pipe\t*pipe;    \n\tstruct usbhsh_device\t*udev;    \n\tstruct usb_host_endpoint *ep;\n\tstruct list_head\tep_list;  \n\tunsigned int\t\tcounter;  \n};\n\n#define USBHSH_DEVICE_MAX\t10  \n#define USBHSH_PORT_MAX\t\t 7  \nstruct usbhsh_hpriv {\n\tstruct usbhs_mod\tmod;\n\tstruct usbhs_pipe\t*dcp;\n\n\tstruct usbhsh_device\tudev[USBHSH_DEVICE_MAX];\n\n\tu32\tport_stat;\t \n\n\tstruct completion\tsetup_ack_done;\n};\n\n\nstatic const char usbhsh_hcd_name[] = \"renesas_usbhs host\";\n\n \n#define usbhsh_priv_to_hpriv(priv) \\\n\tcontainer_of(usbhs_mod_get(priv, USBHS_HOST), struct usbhsh_hpriv, mod)\n\n#define __usbhsh_for_each_udev(start, pos, h, i)\t\\\n\tfor ((i) = start;\t\t\t\t\t\t\\\n\t     ((i) < USBHSH_DEVICE_MAX) && ((pos) = (h)->udev + (i));\t\\\n\t     (i)++)\n\n#define usbhsh_for_each_udev(pos, hpriv, i)\t\\\n\t__usbhsh_for_each_udev(1, pos, hpriv, i)\n\n#define usbhsh_for_each_udev_with_dev0(pos, hpriv, i)\t\\\n\t__usbhsh_for_each_udev(0, pos, hpriv, i)\n\n#define usbhsh_hcd_to_hpriv(h)\t(struct usbhsh_hpriv *)((h)->hcd_priv)\n#define usbhsh_hcd_to_dev(h)\t((h)->self.controller)\n\n#define usbhsh_hpriv_to_priv(h)\t((h)->mod.priv)\n#define usbhsh_hpriv_to_dcp(h)\t((h)->dcp)\n#define usbhsh_hpriv_to_hcd(h)\t\\\n\tcontainer_of((void *)h, struct usb_hcd, hcd_priv)\n\n#define usbhsh_ep_to_uep(u)\t((u)->hcpriv)\n#define usbhsh_uep_to_pipe(u)\t((u)->pipe)\n#define usbhsh_uep_to_udev(u)\t((u)->udev)\n#define usbhsh_uep_to_ep(u)\t((u)->ep)\n\n#define usbhsh_urb_to_ureq(u)\t((u)->hcpriv)\n#define usbhsh_urb_to_usbv(u)\t((u)->dev)\n\n#define usbhsh_usbv_to_udev(d)\tdev_get_drvdata(&(d)->dev)\n\n#define usbhsh_udev_to_usbv(h)\t((h)->usbv)\n#define usbhsh_udev_is_used(h)\tusbhsh_udev_to_usbv(h)\n\n#define usbhsh_pipe_to_uep(p)\t((p)->mod_private)\n\n#define usbhsh_device_parent(d)\t\t(usbhsh_usbv_to_udev((d)->usbv->parent))\n#define usbhsh_device_hubport(d)\t((d)->usbv->portnum)\n#define usbhsh_device_number(h, d)\t((int)((d) - (h)->udev))\n#define usbhsh_device_nth(h, d)\t\t((h)->udev + d)\n#define usbhsh_device0(h)\t\tusbhsh_device_nth(h, 0)\n\n#define usbhsh_port_stat_init(h)\t((h)->port_stat = 0)\n#define usbhsh_port_stat_set(h, s)\t((h)->port_stat |= (s))\n#define usbhsh_port_stat_clear(h, s)\t((h)->port_stat &= ~(s))\n#define usbhsh_port_stat_get(h)\t\t((h)->port_stat)\n\n#define usbhsh_pkt_to_ureq(p)\t\\\n\tcontainer_of((void *)p, struct usbhsh_request, pkt)\n\n \nstatic struct usbhsh_request *usbhsh_ureq_alloc(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t       struct urb *urb,\n\t\t\t\t\t       gfp_t mem_flags)\n{\n\tstruct usbhsh_request *ureq;\n\n\tureq = kzalloc(sizeof(struct usbhsh_request), mem_flags);\n\tif (!ureq)\n\t\treturn NULL;\n\n\tusbhs_pkt_init(&ureq->pkt);\n\tureq->urb = urb;\n\tusbhsh_urb_to_ureq(urb) = ureq;\n\n\treturn ureq;\n}\n\nstatic void usbhsh_ureq_free(struct usbhsh_hpriv *hpriv,\n\t\t\t    struct usbhsh_request *ureq)\n{\n\tusbhsh_urb_to_ureq(ureq->urb) = NULL;\n\tureq->urb = NULL;\n\n\tkfree(ureq);\n}\n\n \nstatic int usbhsh_is_running(struct usbhsh_hpriv *hpriv)\n{\n\t \n\treturn (hpriv->mod.irq_attch == NULL);\n}\n\n \nstatic void usbhsh_endpoint_sequence_save(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t  struct urb *urb,\n\t\t\t\t\t  struct usbhs_pkt *pkt)\n{\n\tint len = urb->actual_length;\n\tint maxp = usb_endpoint_maxp(&urb->ep->desc);\n\tint t = 0;\n\n\t \n\tif (usb_pipecontrol(urb->pipe))\n\t\treturn;\n\n\t \n\n\t \n\tt = len / maxp;\n\tif (len % maxp)\n\t\tt++;\n\tif (pkt->zero)\n\t\tt++;\n\tt %= 2;\n\n\tif (t)\n\t\tusb_dotoggle(urb->dev,\n\t\t\t     usb_pipeendpoint(urb->pipe),\n\t\t\t     usb_pipeout(urb->pipe));\n}\n\nstatic struct usbhsh_device *usbhsh_device_get(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t       struct urb *urb);\n\nstatic int usbhsh_pipe_attach(struct usbhsh_hpriv *hpriv,\n\t\t\t      struct urb *urb)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\n\tstruct usbhsh_device *udev = usbhsh_device_get(hpriv, urb);\n\tstruct usbhs_pipe *pipe;\n\tstruct usb_endpoint_descriptor *desc = &urb->ep->desc;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tunsigned long flags;\n\tint dir_in_req = !!usb_pipein(urb->pipe);\n\tint is_dcp = usb_endpoint_xfer_control(desc);\n\tint i, dir_in;\n\tint ret = -EBUSY;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tif (usbhsh_uep_to_pipe(uep)) {\n\t\tret = 0;\n\t\tgoto usbhsh_pipe_attach_done;\n\t}\n\n\tusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\n\n\t\t \n\t\tif (!usbhs_pipe_type_is(pipe, usb_endpoint_type(desc)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!is_dcp) {\n\t\t\tdir_in = !!usbhs_pipe_is_dir_in(pipe);\n\t\t\tif (0 != (dir_in - dir_in_req))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (usbhsh_pipe_to_uep(pipe))\n\t\t\tcontinue;\n\n\t\t \n\t\tusbhsh_uep_to_pipe(uep)\t\t= pipe;\n\t\tusbhsh_pipe_to_uep(pipe)\t= uep;\n\n\t\tusbhs_pipe_config_update(pipe,\n\t\t\t\t\t usbhsh_device_number(hpriv, udev),\n\t\t\t\t\t usb_endpoint_num(desc),\n\t\t\t\t\t usb_endpoint_maxp(desc));\n\n\t\tdev_dbg(dev, \"%s [%d-%d(%s:%s)]\\n\", __func__,\n\t\t\tusbhsh_device_number(hpriv, udev),\n\t\t\tusb_endpoint_num(desc),\n\t\t\tusbhs_pipe_name(pipe),\n\t\t\tdir_in_req ? \"in\" : \"out\");\n\n\t\tret = 0;\n\t\tbreak;\n\t}\n\nusbhsh_pipe_attach_done:\n\tif (0 == ret)\n\t\tuep->counter++;\n\n\tusbhs_unlock(priv, flags);\n\t \n\n\treturn ret;\n}\n\nstatic void usbhsh_pipe_detach(struct usbhsh_hpriv *hpriv,\n\t\t\t       struct usbhsh_ep *uep)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct usbhs_pipe *pipe;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tunsigned long flags;\n\n\tif (unlikely(!uep)) {\n\t\tdev_err(dev, \"no uep\\n\");\n\t\treturn;\n\t}\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tpipe = usbhsh_uep_to_pipe(uep);\n\n\tif (unlikely(!pipe)) {\n\t\tdev_err(dev, \"uep doesn't have pipe\\n\");\n\t} else if (1 == uep->counter--) {  \n\t\tstruct usb_host_endpoint *ep = usbhsh_uep_to_ep(uep);\n\t\tstruct usbhsh_device *udev = usbhsh_uep_to_udev(uep);\n\n\t\t \n\t\tusbhsh_uep_to_pipe(uep)\t\t= NULL;\n\t\tusbhsh_pipe_to_uep(pipe)\t= NULL;\n\n\t\tdev_dbg(dev, \"%s [%d-%d(%s)]\\n\", __func__,\n\t\t\tusbhsh_device_number(hpriv, udev),\n\t\t\tusb_endpoint_num(&ep->desc),\n\t\t\tusbhs_pipe_name(pipe));\n\t}\n\n\tusbhs_unlock(priv, flags);\n\t \n}\n\n \nstatic int usbhsh_endpoint_attach(struct usbhsh_hpriv *hpriv,\n\t\t\t\t  struct urb *urb,\n\t\t\t\t  gfp_t mem_flags)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct usbhsh_device *udev = usbhsh_device_get(hpriv, urb);\n\tstruct usb_host_endpoint *ep = urb->ep;\n\tstruct usbhsh_ep *uep;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usb_endpoint_descriptor *desc = &ep->desc;\n\tunsigned long flags;\n\n\tuep = kzalloc(sizeof(struct usbhsh_ep), mem_flags);\n\tif (!uep)\n\t\treturn -ENOMEM;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tuep->counter = 0;\n\tINIT_LIST_HEAD(&uep->ep_list);\n\tlist_add_tail(&uep->ep_list, &udev->ep_list_head);\n\n\tusbhsh_uep_to_udev(uep)\t= udev;\n\tusbhsh_uep_to_ep(uep)\t= ep;\n\tusbhsh_ep_to_uep(ep)\t= uep;\n\n\tusbhs_unlock(priv, flags);\n\t \n\n\tdev_dbg(dev, \"%s [%d-%d]\\n\", __func__,\n\t\tusbhsh_device_number(hpriv, udev),\n\t\tusb_endpoint_num(desc));\n\n\treturn 0;\n}\n\nstatic void usbhsh_endpoint_detach(struct usbhsh_hpriv *hpriv,\n\t\t\t\t   struct usb_host_endpoint *ep)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usbhsh_ep *uep = usbhsh_ep_to_uep(ep);\n\tunsigned long flags;\n\n\tif (!uep)\n\t\treturn;\n\n\tdev_dbg(dev, \"%s [%d-%d]\\n\", __func__,\n\t\tusbhsh_device_number(hpriv, usbhsh_uep_to_udev(uep)),\n\t\tusb_endpoint_num(&ep->desc));\n\n\tif (usbhsh_uep_to_pipe(uep))\n\t\tusbhsh_pipe_detach(hpriv, uep);\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tlist_del_init(&uep->ep_list);\n\n\tusbhsh_uep_to_udev(uep)\t= NULL;\n\tusbhsh_uep_to_ep(uep)\t= NULL;\n\tusbhsh_ep_to_uep(ep)\t= NULL;\n\n\tusbhs_unlock(priv, flags);\n\t \n\n\tkfree(uep);\n}\n\nstatic void usbhsh_endpoint_detach_all(struct usbhsh_hpriv *hpriv,\n\t\t\t\t       struct usbhsh_device *udev)\n{\n\tstruct usbhsh_ep *uep, *next;\n\n\tlist_for_each_entry_safe(uep, next, &udev->ep_list_head, ep_list)\n\t\tusbhsh_endpoint_detach(hpriv, usbhsh_uep_to_ep(uep));\n}\n\n \nstatic int usbhsh_connected_to_rhdev(struct usb_hcd *hcd,\n\t\t\t\t     struct usbhsh_device *udev)\n{\n\tstruct usb_device *usbv = usbhsh_udev_to_usbv(udev);\n\n\treturn hcd->self.root_hub == usbv->parent;\n}\n\nstatic int usbhsh_device_has_endpoint(struct usbhsh_device *udev)\n{\n\treturn !list_empty(&udev->ep_list_head);\n}\n\nstatic struct usbhsh_device *usbhsh_device_get(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t       struct urb *urb)\n{\n\tstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\n\tstruct usbhsh_device *udev = usbhsh_usbv_to_udev(usbv);\n\n\t \n\tif (!udev)\n\t\treturn NULL;\n\n\t \n\tif (0 == usb_pipedevice(urb->pipe))\n\t\treturn usbhsh_device0(hpriv);\n\n\t \n\treturn udev;\n}\n\nstatic struct usbhsh_device *usbhsh_device_attach(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t\t struct urb *urb)\n{\n\tstruct usbhsh_device *udev = NULL;\n\tstruct usbhsh_device *udev0 = usbhsh_device0(hpriv);\n\tstruct usbhsh_device *pos;\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\tstruct device *dev = usbhsh_hcd_to_dev(hcd);\n\tstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tunsigned long flags;\n\tu16 upphub, hubport;\n\tint i;\n\n\t \n\tif (0 != usb_pipedevice(urb->pipe)) {\n\t\tdev_err(dev, \"%s fail: urb isn't pointing device0\\n\", __func__);\n\t\treturn NULL;\n\t}\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tusbhsh_for_each_udev(pos, hpriv, i) {\n\t\tif (usbhsh_udev_is_used(pos))\n\t\t\tcontinue;\n\t\tudev = pos;\n\t\tbreak;\n\t}\n\n\tif (udev) {\n\t\t \n\t\tdev_set_drvdata(&usbv->dev, udev);\n\t\tudev->usbv = usbv;\n\t}\n\n\tusbhs_unlock(priv, flags);\n\t \n\n\tif (!udev) {\n\t\tdev_err(dev, \"no free usbhsh_device\\n\");\n\t\treturn NULL;\n\t}\n\n\tif (usbhsh_device_has_endpoint(udev)) {\n\t\tdev_warn(dev, \"udev have old endpoint\\n\");\n\t\tusbhsh_endpoint_detach_all(hpriv, udev);\n\t}\n\n\tif (usbhsh_device_has_endpoint(udev0)) {\n\t\tdev_warn(dev, \"udev0 have old endpoint\\n\");\n\t\tusbhsh_endpoint_detach_all(hpriv, udev0);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&udev0->ep_list_head);\n\tINIT_LIST_HEAD(&udev->ep_list_head);\n\n\t \n\tusbhs_set_device_config(priv,\n\t\t\t\t0, 0, 0, usbv->speed);\n\n\t \n\tupphub\t= 0;\n\thubport\t= 0;\n\tif (!usbhsh_connected_to_rhdev(hcd, udev)) {\n\t\t \n\t\tstruct usbhsh_device *parent = usbhsh_device_parent(udev);\n\n\t\tupphub\t= usbhsh_device_number(hpriv, parent);\n\t\thubport\t= usbhsh_device_hubport(udev);\n\n\t\tdev_dbg(dev, \"%s connected to Hub [%d:%d](%p)\\n\", __func__,\n\t\t\tupphub, hubport, parent);\n\t}\n\n\tusbhs_set_device_config(priv,\n\t\t\t       usbhsh_device_number(hpriv, udev),\n\t\t\t       upphub, hubport, usbv->speed);\n\n\tdev_dbg(dev, \"%s [%d](%p)\\n\", __func__,\n\t\tusbhsh_device_number(hpriv, udev), udev);\n\n\treturn udev;\n}\n\nstatic void usbhsh_device_detach(struct usbhsh_hpriv *hpriv,\n\t\t\t       struct usbhsh_device *udev)\n{\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhsh_hcd_to_dev(hcd);\n\tstruct usb_device *usbv = usbhsh_udev_to_usbv(udev);\n\tunsigned long flags;\n\n\tdev_dbg(dev, \"%s [%d](%p)\\n\", __func__,\n\t\tusbhsh_device_number(hpriv, udev), udev);\n\n\tif (usbhsh_device_has_endpoint(udev)) {\n\t\tdev_warn(dev, \"udev still have endpoint\\n\");\n\t\tusbhsh_endpoint_detach_all(hpriv, udev);\n\t}\n\n\t \n\tif (0 == usbhsh_device_number(hpriv, udev))\n\t\treturn;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\t \n\tdev_set_drvdata(&usbv->dev, NULL);\n\tudev->usbv = NULL;\n\n\tusbhs_unlock(priv, flags);\n\t \n}\n\n \nstatic void usbhsh_queue_done(struct usbhs_priv *priv, struct usbhs_pkt *pkt)\n{\n\tstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\tstruct urb *urb = ureq->urb;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint status = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tif (!urb) {\n\t\tdev_warn(dev, \"pkt doesn't have urb\\n\");\n\t\treturn;\n\t}\n\n\tif (!usbhsh_is_running(hpriv))\n\t\tstatus = -ESHUTDOWN;\n\n\turb->actual_length = pkt->actual;\n\n\tusbhsh_endpoint_sequence_save(hpriv, urb, pkt);\n\tusbhsh_ureq_free(hpriv, ureq);\n\n\tusbhsh_pipe_detach(hpriv, usbhsh_ep_to_uep(urb->ep));\n\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\tusb_hcd_giveback_urb(hcd, urb, status);\n}\n\nstatic int usbhsh_queue_push(struct usb_hcd *hcd,\n\t\t\t     struct urb *urb,\n\t\t\t     gfp_t mem_flags)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\n\tstruct usbhs_pipe *pipe = usbhsh_uep_to_pipe(uep);\n\tstruct device *dev = usbhsh_hcd_to_dev(hcd);\n\tstruct usbhsh_request *ureq;\n\tvoid *buf;\n\tint len, sequence;\n\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\tdev_err(dev, \"pipe iso is not supported now\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\n\tif (unlikely(!ureq)) {\n\t\tdev_err(dev, \"ureq alloc fail\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (usb_pipein(urb->pipe))\n\t\tpipe->handler = &usbhs_fifo_dma_pop_handler;\n\telse\n\t\tpipe->handler = &usbhs_fifo_dma_push_handler;\n\n\tbuf = (void *)(urb->transfer_buffer + urb->actual_length);\n\tlen = urb->transfer_buffer_length - urb->actual_length;\n\n\tsequence = usb_gettoggle(urb->dev,\n\t\t\t\t usb_pipeendpoint(urb->pipe),\n\t\t\t\t usb_pipeout(urb->pipe));\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tusbhs_pkt_push(pipe, &ureq->pkt, usbhsh_queue_done,\n\t\t       buf, len, (urb->transfer_flags & URB_ZERO_PACKET),\n\t\t       sequence);\n\n\tusbhs_pkt_start(pipe);\n\n\treturn 0;\n}\n\nstatic void usbhsh_queue_force_pop(struct usbhs_priv *priv,\n\t\t\t\t   struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_pkt *pkt;\n\n\twhile (1) {\n\t\tpkt = usbhs_pkt_pop(pipe, NULL);\n\t\tif (!pkt)\n\t\t\tbreak;\n\n\t\t \n\t\tusbhsh_queue_done(priv, pkt);\n\t}\n}\n\nstatic void usbhsh_queue_force_pop_all(struct usbhs_priv *priv)\n{\n\tstruct usbhs_pipe *pos;\n\tint i;\n\n\tusbhs_for_each_pipe_with_dcp(pos, priv, i)\n\t\tusbhsh_queue_force_pop(priv, pos);\n}\n\n \nstatic int usbhsh_is_request_address(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\n\treq = (struct usb_ctrlrequest *)urb->setup_packet;\n\n\tif ((DeviceOutRequest    == req->bRequestType << 8) &&\n\t    (USB_REQ_SET_ADDRESS == req->bRequest))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic void usbhsh_setup_stage_packet_push(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t   struct urb *urb,\n\t\t\t\t\t   struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct usb_ctrlrequest req;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\t \n\tinit_completion(&hpriv->setup_ack_done);\n\n\t \n\tmemcpy(&req, urb->setup_packet, sizeof(struct usb_ctrlrequest));\n\n\t \n\tif (usbhsh_is_request_address(urb)) {\n\t\tstruct usb_device *usbv = usbhsh_urb_to_usbv(urb);\n\t\tstruct usbhsh_device *udev = usbhsh_usbv_to_udev(usbv);\n\n\t\t \n\t\treq.wValue = usbhsh_device_number(hpriv, udev);\n\t\tdev_dbg(dev, \"create new address - %d\\n\", req.wValue);\n\t}\n\n\t \n\tusbhs_usbreq_set_val(priv, &req);\n\n\t \n\twait_for_completion(&hpriv->setup_ack_done);\n\n\tdev_dbg(dev, \"%s done\\n\", __func__);\n}\n\n \nstatic void usbhsh_data_stage_packet_done(struct usbhs_priv *priv,\n\t\t\t\t\t  struct usbhs_pkt *pkt)\n{\n\tstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\n\t \n\n\tusbhsh_ureq_free(hpriv, ureq);\n}\n\nstatic int usbhsh_data_stage_packet_push(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t struct urb *urb,\n\t\t\t\t\t struct usbhs_pipe *pipe,\n\t\t\t\t\t gfp_t mem_flags)\n\n{\n\tstruct usbhsh_request *ureq;\n\n\t \n\tureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\n\tif (unlikely(!ureq))\n\t\treturn -ENOMEM;\n\n\tif (usb_pipein(urb->pipe))\n\t\tpipe->handler = &usbhs_dcp_data_stage_in_handler;\n\telse\n\t\tpipe->handler = &usbhs_dcp_data_stage_out_handler;\n\n\tusbhs_pkt_push(pipe, &ureq->pkt,\n\t\t       usbhsh_data_stage_packet_done,\n\t\t       urb->transfer_buffer,\n\t\t       urb->transfer_buffer_length,\n\t\t       (urb->transfer_flags & URB_ZERO_PACKET),\n\t\t       -1);\n\n\treturn 0;\n}\n\n \nstatic int usbhsh_status_stage_packet_push(struct usbhsh_hpriv *hpriv,\n\t\t\t\t\t    struct urb *urb,\n\t\t\t\t\t    struct usbhs_pipe *pipe,\n\t\t\t\t\t    gfp_t mem_flags)\n{\n\tstruct usbhsh_request *ureq;\n\n\t \n\tureq = usbhsh_ureq_alloc(hpriv, urb, mem_flags);\n\tif (unlikely(!ureq))\n\t\treturn -ENOMEM;\n\n\tif (usb_pipein(urb->pipe))\n\t\tpipe->handler = &usbhs_dcp_status_stage_in_handler;\n\telse\n\t\tpipe->handler = &usbhs_dcp_status_stage_out_handler;\n\n\tusbhs_pkt_push(pipe, &ureq->pkt,\n\t\t       usbhsh_queue_done,\n\t\t       NULL,\n\t\t       urb->transfer_buffer_length,\n\t\t       0, -1);\n\n\treturn 0;\n}\n\nstatic int usbhsh_dcp_queue_push(struct usb_hcd *hcd,\n\t\t\t\t struct urb *urb,\n\t\t\t\t gfp_t mflags)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tstruct usbhsh_ep *uep = usbhsh_ep_to_uep(urb->ep);\n\tstruct usbhs_pipe *pipe = usbhsh_uep_to_pipe(uep);\n\tstruct device *dev = usbhsh_hcd_to_dev(hcd);\n\tint ret;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\t \n\tusbhsh_setup_stage_packet_push(hpriv, urb, pipe);\n\n\t \n\tif (urb->transfer_buffer_length) {\n\t\tret = usbhsh_data_stage_packet_push(hpriv, urb, pipe, mflags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"data stage failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = usbhsh_status_stage_packet_push(hpriv, urb, pipe, mflags);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"status stage failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tusbhs_pkt_start(pipe);\n\n\treturn 0;\n}\n\n \nstatic int usbhsh_dma_map_ctrl(struct device *dma_dev, struct usbhs_pkt *pkt,\n\t\t\t       int map)\n{\n\tif (map) {\n\t\tstruct usbhsh_request *ureq = usbhsh_pkt_to_ureq(pkt);\n\t\tstruct urb *urb = ureq->urb;\n\n\t\t \n\t\tif (urb->num_sgs)\n\t\t\treturn -EINVAL;\n\n\t\tpkt->dma = urb->transfer_dma;\n\t\tif (!pkt->dma)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int usbhsh_host_start(struct usb_hcd *hcd)\n{\n\treturn 0;\n}\n\nstatic void usbhsh_host_stop(struct usb_hcd *hcd)\n{\n}\n\nstatic int usbhsh_urb_enqueue(struct usb_hcd *hcd,\n\t\t\t      struct urb *urb,\n\t\t\t      gfp_t mem_flags)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usb_host_endpoint *ep = urb->ep;\n\tstruct usbhsh_device *new_udev = NULL;\n\tint is_dir_in = usb_pipein(urb->pipe);\n\tint ret;\n\n\tdev_dbg(dev, \"%s (%s)\\n\", __func__, is_dir_in ? \"in\" : \"out\");\n\n\tif (!usbhsh_is_running(hpriv)) {\n\t\tret = -EIO;\n\t\tdev_err(dev, \"host is not running\\n\");\n\t\tgoto usbhsh_urb_enqueue_error_not_linked;\n\t}\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret) {\n\t\tdev_err(dev, \"urb link failed\\n\");\n\t\tgoto usbhsh_urb_enqueue_error_not_linked;\n\t}\n\n\t \n\tif (!usbhsh_device_get(hpriv, urb)) {\n\t\tnew_udev = usbhsh_device_attach(hpriv, urb);\n\t\tif (!new_udev) {\n\t\t\tret = -EIO;\n\t\t\tdev_err(dev, \"device attach failed\\n\");\n\t\t\tgoto usbhsh_urb_enqueue_error_not_linked;\n\t\t}\n\t}\n\n\t \n\tif (!usbhsh_ep_to_uep(ep)) {\n\t\tret = usbhsh_endpoint_attach(hpriv, urb, mem_flags);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"endpoint attach failed\\n\");\n\t\t\tgoto usbhsh_urb_enqueue_error_free_device;\n\t\t}\n\t}\n\n\t \n\tret = usbhsh_pipe_attach(hpriv, urb);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pipe attach failed\\n\");\n\t\tgoto usbhsh_urb_enqueue_error_free_endpoint;\n\t}\n\n\t \n\tif (usb_pipecontrol(urb->pipe))\n\t\tret = usbhsh_dcp_queue_push(hcd, urb, mem_flags);\n\telse\n\t\tret = usbhsh_queue_push(hcd, urb, mem_flags);\n\n\treturn ret;\n\nusbhsh_urb_enqueue_error_free_endpoint:\n\tusbhsh_endpoint_detach(hpriv, ep);\nusbhsh_urb_enqueue_error_free_device:\n\tif (new_udev)\n\t\tusbhsh_device_detach(hpriv, new_udev);\nusbhsh_urb_enqueue_error_not_linked:\n\n\tdev_dbg(dev, \"%s error\\n\", __func__);\n\n\treturn ret;\n}\n\nstatic int usbhsh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tstruct usbhsh_request *ureq = usbhsh_urb_to_ureq(urb);\n\n\tif (ureq) {\n\t\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\t\tstruct usbhs_pkt *pkt = &ureq->pkt;\n\n\t\tusbhs_pkt_pop(pkt->pipe, pkt);\n\t\tusbhsh_queue_done(priv, pkt);\n\t}\n\n\treturn 0;\n}\n\nstatic void usbhsh_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t    struct usb_host_endpoint *ep)\n{\n\tstruct usbhsh_ep *uep = usbhsh_ep_to_uep(ep);\n\tstruct usbhsh_device *udev;\n\tstruct usbhsh_hpriv *hpriv;\n\n\t \n\tif (!uep)\n\t\treturn;\n\n\tudev\t= usbhsh_uep_to_udev(uep);\n\thpriv\t= usbhsh_hcd_to_hpriv(hcd);\n\n\tusbhsh_endpoint_detach(hpriv, ep);\n\n\t \n\tif (!usbhsh_device_has_endpoint(udev))\n\t\tusbhsh_device_detach(hpriv, udev);\n}\n\nstatic int usbhsh_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tint roothub_id = 1;  \n\n\t \n\tif (usbhsh_port_stat_get(hpriv) & 0xFFFF0000)\n\t\t*buf = (1 << roothub_id);\n\telse\n\t\t*buf = 0;\n\n\treturn !!(*buf);\n}\n\nstatic int __usbhsh_hub_hub_feature(struct usbhsh_hpriv *hpriv,\n\t\t\t\t    u16 typeReq, u16 wValue,\n\t\t\t\t    u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tswitch (wValue) {\n\tcase C_HUB_OVER_CURRENT:\n\tcase C_HUB_LOCAL_POWER:\n\t\tdev_dbg(dev, \"%s :: C_HUB_xx\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\treturn -EPIPE;\n}\n\nstatic int __usbhsh_hub_port_feature(struct usbhsh_hpriv *hpriv,\n\t\t\t\t     u16 typeReq, u16 wValue,\n\t\t\t\t     u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint enable = (typeReq == SetPortFeature);\n\tint speed, i, timeout = 128;\n\tint roothub_id = 1;  \n\n\t \n\tif (wIndex > roothub_id || wLength != 0)\n\t\treturn -EPIPE;\n\n\t \n\tswitch (wValue) {\n\tcase USB_PORT_FEAT_POWER:\n\t\tusbhs_vbus_ctrl(priv, enable);\n\t\tdev_dbg(dev, \"%s :: USB_PORT_FEAT_POWER\\n\", __func__);\n\t\tbreak;\n\n\tcase USB_PORT_FEAT_ENABLE:\n\tcase USB_PORT_FEAT_SUSPEND:\n\tcase USB_PORT_FEAT_C_ENABLE:\n\tcase USB_PORT_FEAT_C_SUSPEND:\n\tcase USB_PORT_FEAT_C_CONNECTION:\n\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\tcase USB_PORT_FEAT_C_RESET:\n\t\tdev_dbg(dev, \"%s :: USB_PORT_FEAT_xxx\\n\", __func__);\n\t\tbreak;\n\n\tcase USB_PORT_FEAT_RESET:\n\t\tif (!enable)\n\t\t\tbreak;\n\n\t\tusbhsh_port_stat_clear(hpriv,\n\t\t\t\t       USB_PORT_STAT_HIGH_SPEED |\n\t\t\t\t       USB_PORT_STAT_LOW_SPEED);\n\n\t\tusbhsh_queue_force_pop_all(priv);\n\n\t\tusbhs_bus_send_reset(priv);\n\t\tmsleep(20);\n\t\tusbhs_bus_send_sof_enable(priv);\n\n\t\tfor (i = 0; i < timeout ; i++) {\n\t\t\tswitch (usbhs_bus_get_speed(priv)) {\n\t\t\tcase USB_SPEED_LOW:\n\t\t\t\tspeed = USB_PORT_STAT_LOW_SPEED;\n\t\t\t\tgoto got_usb_bus_speed;\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\tspeed = USB_PORT_STAT_HIGH_SPEED;\n\t\t\t\tgoto got_usb_bus_speed;\n\t\t\tcase USB_SPEED_FULL:\n\t\t\t\tspeed = 0;\n\t\t\t\tgoto got_usb_bus_speed;\n\t\t\t}\n\n\t\t\tmsleep(20);\n\t\t}\n\t\treturn -EPIPE;\n\ngot_usb_bus_speed:\n\t\tusbhsh_port_stat_set(hpriv, speed);\n\t\tusbhsh_port_stat_set(hpriv, USB_PORT_STAT_ENABLE);\n\n\t\tdev_dbg(dev, \"%s :: USB_PORT_FEAT_RESET (speed = %d)\\n\",\n\t\t\t__func__, speed);\n\n\t\t \n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EPIPE;\n\t}\n\n\t \n\tif (enable)\n\t\tusbhsh_port_stat_set(hpriv, (1 << wValue));\n\telse\n\t\tusbhsh_port_stat_clear(hpriv, (1 << wValue));\n\n\treturn 0;\n}\n\nstatic int __usbhsh_hub_get_status(struct usbhsh_hpriv *hpriv,\n\t\t\t\t   u16 typeReq, u16 wValue,\n\t\t\t\t   u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct usb_hub_descriptor *desc = (struct usb_hub_descriptor *)buf;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint roothub_id = 1;  \n\n\tswitch (typeReq) {\n\tcase GetHubStatus:\n\t\tdev_dbg(dev, \"%s :: GetHubStatus\\n\", __func__);\n\n\t\t*buf = 0x00;\n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tif (wIndex != roothub_id)\n\t\t\treturn -EPIPE;\n\n\t\tdev_dbg(dev, \"%s :: GetPortStatus\\n\", __func__);\n\t\t*(__le32 *)buf = cpu_to_le32(usbhsh_port_stat_get(hpriv));\n\t\tbreak;\n\n\tcase GetHubDescriptor:\n\t\tdesc->bDescriptorType\t\t= USB_DT_HUB;\n\t\tdesc->bHubContrCurrent\t\t= 0;\n\t\tdesc->bNbrPorts\t\t\t= roothub_id;\n\t\tdesc->bDescLength\t\t= 9;\n\t\tdesc->bPwrOn2PwrGood\t\t= 0;\n\t\tdesc->wHubCharacteristics\t=\n\t\t\tcpu_to_le16(HUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_NO_OCPM);\n\t\tdesc->u.hs.DeviceRemovable[0]\t= (roothub_id << 1);\n\t\tdesc->u.hs.DeviceRemovable[1]\t= ~0;\n\t\tdev_dbg(dev, \"%s :: GetHubDescriptor\\n\", __func__);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int usbhsh_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t      u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_hcd_to_hpriv(hcd);\n\tstruct usbhs_priv *priv = usbhsh_hpriv_to_priv(hpriv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret = -EPIPE;\n\n\tswitch (typeReq) {\n\n\t \n\tcase ClearHubFeature:\n\tcase SetHubFeature:\n\t\tret = __usbhsh_hub_hub_feature(hpriv, typeReq,\n\t\t\t\t\t       wValue, wIndex, buf, wLength);\n\t\tbreak;\n\n\t \n\tcase SetPortFeature:\n\tcase ClearPortFeature:\n\t\tret = __usbhsh_hub_port_feature(hpriv, typeReq,\n\t\t\t\t\t\twValue, wIndex, buf, wLength);\n\t\tbreak;\n\n\t \n\tcase GetHubStatus:\n\tcase GetPortStatus:\n\tcase GetHubDescriptor:\n\t\tret = __usbhsh_hub_get_status(hpriv, typeReq,\n\t\t\t\t\t      wValue, wIndex, buf, wLength);\n\t\tbreak;\n\t}\n\n\tdev_dbg(dev, \"typeReq = %x, ret = %d, port_stat = %x\\n\",\n\t\ttypeReq, ret, usbhsh_port_stat_get(hpriv));\n\n\treturn ret;\n}\n\nstatic int usbhsh_bus_nop(struct usb_hcd *hcd)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct hc_driver usbhsh_driver = {\n\t.description =\t\tusbhsh_hcd_name,\n\t.hcd_priv_size =\tsizeof(struct usbhsh_hpriv),\n\n\t \n\t.flags =\t\tHCD_DMA | HCD_USB2,\n\n\t.start =\t\tusbhsh_host_start,\n\t.stop =\t\t\tusbhsh_host_stop,\n\n\t \n\t.urb_enqueue =\t\tusbhsh_urb_enqueue,\n\t.urb_dequeue =\t\tusbhsh_urb_dequeue,\n\t.endpoint_disable =\tusbhsh_endpoint_disable,\n\n\t \n\t.hub_status_data =\tusbhsh_hub_status_data,\n\t.hub_control =\t\tusbhsh_hub_control,\n\t.bus_suspend =\t\tusbhsh_bus_nop,\n\t.bus_resume =\t\tusbhsh_bus_nop,\n};\n\n \nstatic int usbhsh_irq_attch(struct usbhs_priv *priv,\n\t\t\t    struct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tdev_dbg(dev, \"device attached\\n\");\n\n\tusbhsh_port_stat_set(hpriv, USB_PORT_STAT_CONNECTION);\n\tusbhsh_port_stat_set(hpriv, USB_PORT_STAT_C_CONNECTION << 16);\n\n\t \n\thpriv->mod.irq_attch = NULL;\n\tusbhs_irq_callback_update(priv, &hpriv->mod);\n\n\treturn 0;\n}\n\nstatic int usbhsh_irq_dtch(struct usbhs_priv *priv,\n\t\t\t   struct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tdev_dbg(dev, \"device detached\\n\");\n\n\tusbhsh_port_stat_clear(hpriv, USB_PORT_STAT_CONNECTION);\n\tusbhsh_port_stat_set(hpriv, USB_PORT_STAT_C_CONNECTION << 16);\n\n\t \n\thpriv->mod.irq_attch = usbhsh_irq_attch;\n\tusbhs_irq_callback_update(priv, &hpriv->mod);\n\n\t \n\tusbhsh_queue_force_pop_all(priv);\n\n\treturn 0;\n}\n\nstatic int usbhsh_irq_setup_ack(struct usbhs_priv *priv,\n\t\t\t\tstruct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tdev_dbg(dev, \"setup packet OK\\n\");\n\n\tcomplete(&hpriv->setup_ack_done);  \n\n\treturn 0;\n}\n\nstatic int usbhsh_irq_setup_err(struct usbhs_priv *priv,\n\t\t\t\tstruct usbhs_irq_state *irq_state)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tdev_dbg(dev, \"setup packet Err\\n\");\n\n\tcomplete(&hpriv->setup_ack_done);  \n\n\treturn 0;\n}\n\n \nstatic void usbhsh_pipe_init_for_host(struct usbhs_priv *priv)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct usbhs_pipe *pipe;\n\tstruct renesas_usbhs_driver_pipe_config *pipe_configs =\n\t\t\t\t\tusbhs_get_dparam(priv, pipe_configs);\n\tint pipe_size = usbhs_get_dparam(priv, pipe_size);\n\tint old_type, dir_in, i;\n\n\t \n\told_type = USB_ENDPOINT_XFER_CONTROL;\n\tfor (i = 0; i < pipe_size; i++) {\n\n\t\t \n\t\tdir_in = (pipe_configs[i].type == old_type);\n\t\told_type = pipe_configs[i].type;\n\n\t\tif (USB_ENDPOINT_XFER_CONTROL == pipe_configs[i].type) {\n\t\t\tpipe = usbhs_dcp_malloc(priv);\n\t\t\tusbhsh_hpriv_to_dcp(hpriv) = pipe;\n\t\t} else {\n\t\t\tpipe = usbhs_pipe_malloc(priv,\n\t\t\t\t\t\t pipe_configs[i].type,\n\t\t\t\t\t\t dir_in);\n\t\t}\n\n\t\tpipe->mod_private = NULL;\n\t}\n}\n\nstatic int usbhsh_start(struct usbhs_priv *priv)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\t \n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\t \n\tusbhs_fifo_init(priv);\n\tusbhs_pipe_init(priv,\n\t\t\tusbhsh_dma_map_ctrl);\n\tusbhsh_pipe_init_for_host(priv);\n\n\t \n\tusbhs_sys_host_ctrl(priv, 1);\n\n\t \n\tmod->irq_attch\t\t= usbhsh_irq_attch;\n\tmod->irq_dtch\t\t= usbhsh_irq_dtch;\n\tmod->irq_sack\t\t= usbhsh_irq_setup_ack;\n\tmod->irq_sign\t\t= usbhsh_irq_setup_err;\n\tusbhs_irq_callback_update(priv, mod);\n\n\tdev_dbg(dev, \"start host\\n\");\n\n\treturn ret;\n}\n\nstatic int usbhsh_stop(struct usbhs_priv *priv)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\t \n\tmod->irq_attch\t= NULL;\n\tmod->irq_dtch\t= NULL;\n\tmod->irq_sack\t= NULL;\n\tmod->irq_sign\t= NULL;\n\tusbhs_irq_callback_update(priv, mod);\n\n\tusb_remove_hcd(hcd);\n\n\t \n\tusbhs_sys_host_ctrl(priv, 0);\n\n\tdev_dbg(dev, \"quit host\\n\");\n\n\treturn 0;\n}\n\nint usbhs_mod_host_probe(struct usbhs_priv *priv)\n{\n\tstruct usbhsh_hpriv *hpriv;\n\tstruct usb_hcd *hcd;\n\tstruct usbhsh_device *udev;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint i;\n\n\t \n\thcd = usb_create_hcd(&usbhsh_driver, dev, usbhsh_hcd_name);\n\tif (!hcd) {\n\t\tdev_err(dev, \"Failed to create hcd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thcd->has_tt = 1;  \n\n\t \n\n\thpriv = usbhsh_hcd_to_hpriv(hcd);\n\n\t \n\tusbhs_mod_register(priv, &hpriv->mod, USBHS_HOST);\n\n\t \n\thpriv->mod.name\t\t= \"host\";\n\thpriv->mod.start\t= usbhsh_start;\n\thpriv->mod.stop\t\t= usbhsh_stop;\n\tusbhsh_port_stat_init(hpriv);\n\n\t \n\tusbhsh_for_each_udev_with_dev0(udev, hpriv, i) {\n\t\tudev->usbv\t= NULL;\n\t\tINIT_LIST_HEAD(&udev->ep_list_head);\n\t}\n\n\tdev_info(dev, \"host probed\\n\");\n\n\treturn 0;\n}\n\nint usbhs_mod_host_remove(struct usbhs_priv *priv)\n{\n\tstruct usbhsh_hpriv *hpriv = usbhsh_priv_to_hpriv(priv);\n\tstruct usb_hcd *hcd = usbhsh_hpriv_to_hcd(hpriv);\n\n\tusb_put_hcd(hcd);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}