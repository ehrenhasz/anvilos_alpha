{
  "module_name": "mod.c",
  "hash_id": "e5f666116d70dcf2512d96325ae528ba37df015effbc58ab2190fe8d49b35604",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/mod.c",
  "human_readable_source": "\n \n#include <linux/interrupt.h>\n\n#include \"common.h\"\n#include \"mod.h\"\n\n \nstatic int usbhsm_autonomy_get_vbus(struct platform_device *pdev)\n{\n\tstruct usbhs_priv *priv = usbhs_pdev_to_priv(pdev);\n\n\treturn  VBSTS & usbhs_read(priv, INTSTS0);\n}\n\nstatic int usbhsm_autonomy_irq_vbus(struct usbhs_priv *priv,\n\t\t\t\t    struct usbhs_irq_state *irq_state)\n{\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\n\tusbhsc_schedule_notify_hotplug(pdev);\n\n\treturn 0;\n}\n\nvoid usbhs_mod_autonomy_mode(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\tinfo->irq_vbus = usbhsm_autonomy_irq_vbus;\n\tinfo->get_vbus = usbhsm_autonomy_get_vbus;\n\n\tusbhs_irq_callback_update(priv, NULL);\n}\n\nvoid usbhs_mod_non_autonomy_mode(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\tinfo->get_vbus = priv->pfunc->get_vbus;\n}\n\n \nvoid usbhs_mod_register(struct usbhs_priv *priv, struct usbhs_mod *mod, int id)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\tinfo->mod[id]\t= mod;\n\tmod->priv\t= priv;\n}\n\nstruct usbhs_mod *usbhs_mod_get(struct usbhs_priv *priv, int id)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\tstruct usbhs_mod *ret = NULL;\n\n\tswitch (id) {\n\tcase USBHS_HOST:\n\tcase USBHS_GADGET:\n\t\tret = info->mod[id];\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nint usbhs_mod_is_host(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\tif (!mod)\n\t\treturn -EINVAL;\n\n\treturn info->mod[USBHS_HOST] == mod;\n}\n\nstruct usbhs_mod *usbhs_mod_get_current(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\treturn info->curt;\n}\n\nint usbhs_mod_change(struct usbhs_priv *priv, int id)\n{\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\tstruct usbhs_mod *mod = NULL;\n\tint ret = 0;\n\n\t \n\tswitch (id) {\n\tcase USBHS_HOST:\n\tcase USBHS_GADGET:\n\t\tmod = info->mod[id];\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tinfo->curt = mod;\n\n\treturn ret;\n}\n\nstatic irqreturn_t usbhs_interrupt(int irq, void *data);\nint usbhs_mod_probe(struct usbhs_priv *priv)\n{\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\t \n\tret = usbhs_mod_host_probe(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usbhs_mod_gadget_probe(priv);\n\tif (ret < 0)\n\t\tgoto mod_init_host_err;\n\n\t \n\tret = devm_request_irq(dev, priv->irq, usbhs_interrupt,\n\t\t\t       0, dev_name(dev), priv);\n\tif (ret) {\n\t\tdev_err(dev, \"irq request err\\n\");\n\t\tgoto mod_init_gadget_err;\n\t}\n\n\treturn ret;\n\nmod_init_gadget_err:\n\tusbhs_mod_gadget_remove(priv);\nmod_init_host_err:\n\tusbhs_mod_host_remove(priv);\n\n\treturn ret;\n}\n\nvoid usbhs_mod_remove(struct usbhs_priv *priv)\n{\n\tusbhs_mod_host_remove(priv);\n\tusbhs_mod_gadget_remove(priv);\n}\n\n \nint usbhs_status_get_device_state(struct usbhs_irq_state *irq_state)\n{\n\treturn (int)irq_state->intsts0 & DVSQ_MASK;\n}\n\nint usbhs_status_get_ctrl_stage(struct usbhs_irq_state *irq_state)\n{\n\t \n\treturn (int)irq_state->intsts0 & CTSQ_MASK;\n}\n\nstatic int usbhs_status_get_each_irq(struct usbhs_priv *priv,\n\t\t\t\t     struct usbhs_irq_state *state)\n{\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tu16 intenb0, intenb1;\n\tunsigned long flags;\n\n\t \n\tusbhs_lock(priv, flags);\n\tstate->intsts0 = usbhs_read(priv, INTSTS0);\n\tintenb0 = usbhs_read(priv, INTENB0);\n\n\tif (usbhs_mod_is_host(priv)) {\n\t\tstate->intsts1 = usbhs_read(priv, INTSTS1);\n\t\tintenb1 = usbhs_read(priv, INTENB1);\n\t} else {\n\t\tstate->intsts1 = intenb1 = 0;\n\t}\n\n\t \n\tif (mod) {\n\t\tstate->brdysts = usbhs_read(priv, BRDYSTS);\n\t\tstate->nrdysts = usbhs_read(priv, NRDYSTS);\n\t\tstate->bempsts = usbhs_read(priv, BEMPSTS);\n\n\t\tstate->bempsts &= mod->irq_bempsts;\n\t\tstate->brdysts &= mod->irq_brdysts;\n\t}\n\tusbhs_unlock(priv, flags);\n\t \n\n\treturn 0;\n}\n\n \n#define INTSTS0_MAGIC 0xF800  \n#define INTSTS1_MAGIC 0xA870  \nstatic irqreturn_t usbhs_interrupt(int irq, void *data)\n{\n\tstruct usbhs_priv *priv = data;\n\tstruct usbhs_irq_state irq_state;\n\n\tif (usbhs_status_get_each_irq(priv, &irq_state) < 0)\n\t\treturn IRQ_NONE;\n\n\t \n\tusbhs_write(priv, INTSTS0, ~irq_state.intsts0 & INTSTS0_MAGIC);\n\tif (usbhs_mod_is_host(priv))\n\t\tusbhs_write(priv, INTSTS1, ~irq_state.intsts1 & INTSTS1_MAGIC);\n\n\t \n\tif (irq_state.intsts0 & BRDY)\n\t\tusbhs_write(priv, BRDYSTS, ~irq_state.brdysts);\n\tusbhs_write(priv, NRDYSTS, ~irq_state.nrdysts);\n\tif (irq_state.intsts0 & BEMP)\n\t\tusbhs_write(priv, BEMPSTS, ~irq_state.bempsts);\n\n\t \n\n\t \n\tif (irq_state.intsts0 & VBINT)\n\t\tusbhs_mod_info_call(priv, irq_vbus, priv, &irq_state);\n\n\tif (irq_state.intsts0 & DVST)\n\t\tusbhs_mod_call(priv, irq_dev_state, priv, &irq_state);\n\n\tif (irq_state.intsts0 & CTRT)\n\t\tusbhs_mod_call(priv, irq_ctrl_stage, priv, &irq_state);\n\n\tif (irq_state.intsts0 & BEMP)\n\t\tusbhs_mod_call(priv, irq_empty, priv, &irq_state);\n\n\tif (irq_state.intsts0 & BRDY)\n\t\tusbhs_mod_call(priv, irq_ready, priv, &irq_state);\n\n\tif (usbhs_mod_is_host(priv)) {\n\t\t \n\t\tif (irq_state.intsts1 & ATTCH)\n\t\t\tusbhs_mod_call(priv, irq_attch, priv, &irq_state);\n\n\t\tif (irq_state.intsts1 & DTCH)\n\t\t\tusbhs_mod_call(priv, irq_dtch, priv, &irq_state);\n\n\t\tif (irq_state.intsts1 & SIGN)\n\t\t\tusbhs_mod_call(priv, irq_sign, priv, &irq_state);\n\n\t\tif (irq_state.intsts1 & SACK)\n\t\t\tusbhs_mod_call(priv, irq_sack, priv, &irq_state);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nvoid usbhs_irq_callback_update(struct usbhs_priv *priv, struct usbhs_mod *mod)\n{\n\tu16 intenb0 = 0;\n\tu16 intenb1 = 0;\n\tstruct usbhs_mod_info *info = usbhs_priv_to_modinfo(priv);\n\n\t \n\tusbhs_write(priv, INTENB0, 0);\n\tif (usbhs_mod_is_host(priv))\n\t\tusbhs_write(priv, INTENB1, 0);\n\n\tusbhs_write(priv, BEMPENB, 0);\n\tusbhs_write(priv, BRDYENB, 0);\n\n\t \n\n\tif (info->irq_vbus)\n\t\tintenb0 |= VBSE;\n\n\tif (mod) {\n\t\t \n\t\tif (mod->irq_ctrl_stage)\n\t\t\tintenb0 |= CTRE;\n\n\t\tif (mod->irq_dev_state)\n\t\t\tintenb0 |= DVSE;\n\n\t\tif (mod->irq_empty && mod->irq_bempsts) {\n\t\t\tusbhs_write(priv, BEMPENB, mod->irq_bempsts);\n\t\t\tintenb0 |= BEMPE;\n\t\t}\n\n\t\tif (mod->irq_ready && mod->irq_brdysts) {\n\t\t\tusbhs_write(priv, BRDYENB, mod->irq_brdysts);\n\t\t\tintenb0 |= BRDYE;\n\t\t}\n\n\t\tif (usbhs_mod_is_host(priv)) {\n\t\t\t \n\t\t\tif (mod->irq_attch)\n\t\t\t\tintenb1 |= ATTCHE;\n\n\t\t\tif (mod->irq_dtch)\n\t\t\t\tintenb1 |= DTCHE;\n\n\t\t\tif (mod->irq_sign)\n\t\t\t\tintenb1 |= SIGNE;\n\n\t\t\tif (mod->irq_sack)\n\t\t\t\tintenb1 |= SACKE;\n\t\t}\n\t}\n\n\tif (intenb0)\n\t\tusbhs_write(priv, INTENB0, intenb0);\n\n\tif (usbhs_mod_is_host(priv) && intenb1)\n\t\tusbhs_write(priv, INTENB1, intenb1);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}