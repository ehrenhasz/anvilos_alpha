{
  "module_name": "fifo.c",
  "hash_id": "88ddd66750554b69299626e5ab7000ab1766db0e39a6799736a7c205dca601e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/fifo.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/scatterlist.h>\n#include \"common.h\"\n#include \"pipe.h\"\n\n#define usbhsf_get_cfifo(p)\t(&((p)->fifo_info.cfifo))\n\n#define usbhsf_fifo_is_busy(f)\t((f)->pipe)  \n\n \nvoid usbhs_pkt_init(struct usbhs_pkt *pkt)\n{\n\tINIT_LIST_HEAD(&pkt->node);\n}\n\n \nstatic int usbhsf_null_handle(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pkt->pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tdev_err(dev, \"null handler\\n\");\n\n\treturn -EINVAL;\n}\n\nstatic const struct usbhs_pkt_handle usbhsf_null_handler = {\n\t.prepare = usbhsf_null_handle,\n\t.try_run = usbhsf_null_handle,\n};\n\nvoid usbhs_pkt_push(struct usbhs_pipe *pipe, struct usbhs_pkt *pkt,\n\t\t    void (*done)(struct usbhs_priv *priv,\n\t\t\t\t struct usbhs_pkt *pkt),\n\t\t    void *buf, int len, int zero, int sequence)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tunsigned long flags;\n\n\tif (!done) {\n\t\tdev_err(dev, \"no done function\\n\");\n\t\treturn;\n\t}\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tif (!pipe->handler) {\n\t\tdev_err(dev, \"no handler function\\n\");\n\t\tpipe->handler = &usbhsf_null_handler;\n\t}\n\n\tlist_move_tail(&pkt->node, &pipe->list);\n\n\t \n\tpkt->pipe\t= pipe;\n\tpkt->buf\t= buf;\n\tpkt->handler\t= pipe->handler;\n\tpkt->length\t= len;\n\tpkt->zero\t= zero;\n\tpkt->actual\t= 0;\n\tpkt->done\t= done;\n\tpkt->sequence\t= sequence;\n\n\tusbhs_unlock(priv, flags);\n\t \n}\n\nstatic void __usbhsf_pkt_del(struct usbhs_pkt *pkt)\n{\n\tlist_del_init(&pkt->node);\n}\n\nstruct usbhs_pkt *__usbhsf_pkt_get(struct usbhs_pipe *pipe)\n{\n\treturn list_first_entry_or_null(&pipe->list, struct usbhs_pkt, node);\n}\n\nstatic void usbhsf_fifo_unselect(struct usbhs_pipe *pipe,\n\t\t\t\t struct usbhs_fifo *fifo);\nstatic struct dma_chan *usbhsf_dma_chan_get(struct usbhs_fifo *fifo,\n\t\t\t\t\t    struct usbhs_pkt *pkt);\n#define usbhsf_dma_map(p)\t__usbhsf_dma_map_ctrl(p, 1)\n#define usbhsf_dma_unmap(p)\t__usbhsf_dma_map_ctrl(p, 0)\nstatic int __usbhsf_dma_map_ctrl(struct usbhs_pkt *pkt, int map);\nstatic void usbhsf_tx_irq_ctrl(struct usbhs_pipe *pipe, int enable);\nstatic void usbhsf_rx_irq_ctrl(struct usbhs_pipe *pipe, int enable);\nstruct usbhs_pkt *usbhs_pkt_pop(struct usbhs_pipe *pipe, struct usbhs_pkt *pkt)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);\n\tunsigned long flags;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tusbhs_pipe_disable(pipe);\n\n\tif (!pkt)\n\t\tpkt = __usbhsf_pkt_get(pipe);\n\n\tif (pkt) {\n\t\tstruct dma_chan *chan = NULL;\n\n\t\tif (fifo)\n\t\t\tchan = usbhsf_dma_chan_get(fifo, pkt);\n\t\tif (chan) {\n\t\t\tdmaengine_terminate_all(chan);\n\t\t\tusbhsf_dma_unmap(pkt);\n\t\t} else {\n\t\t\tif (usbhs_pipe_is_dir_in(pipe))\n\t\t\t\tusbhsf_rx_irq_ctrl(pipe, 0);\n\t\t\telse\n\t\t\t\tusbhsf_tx_irq_ctrl(pipe, 0);\n\t\t}\n\n\t\tusbhs_pipe_clear_without_sequence(pipe, 0, 0);\n\t\tusbhs_pipe_running(pipe, 0);\n\n\t\t__usbhsf_pkt_del(pkt);\n\t}\n\n\tif (fifo)\n\t\tusbhsf_fifo_unselect(pipe, fifo);\n\n\tusbhs_unlock(priv, flags);\n\t \n\n\treturn pkt;\n}\n\nenum {\n\tUSBHSF_PKT_PREPARE,\n\tUSBHSF_PKT_TRY_RUN,\n\tUSBHSF_PKT_DMA_DONE,\n};\n\nstatic int usbhsf_pkt_handler(struct usbhs_pipe *pipe, int type)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_pkt *pkt;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint (*func)(struct usbhs_pkt *pkt, int *is_done);\n\tunsigned long flags;\n\tint ret = 0;\n\tint is_done = 0;\n\n\t \n\tusbhs_lock(priv, flags);\n\n\tpkt = __usbhsf_pkt_get(pipe);\n\tif (!pkt) {\n\t\tret = -EINVAL;\n\t\tgoto __usbhs_pkt_handler_end;\n\t}\n\n\tswitch (type) {\n\tcase USBHSF_PKT_PREPARE:\n\t\tfunc = pkt->handler->prepare;\n\t\tbreak;\n\tcase USBHSF_PKT_TRY_RUN:\n\t\tfunc = pkt->handler->try_run;\n\t\tbreak;\n\tcase USBHSF_PKT_DMA_DONE:\n\t\tfunc = pkt->handler->dma_done;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown pkt handler\\n\");\n\t\tgoto __usbhs_pkt_handler_end;\n\t}\n\n\tif (likely(func))\n\t\tret = func(pkt, &is_done);\n\n\tif (is_done)\n\t\t__usbhsf_pkt_del(pkt);\n\n__usbhs_pkt_handler_end:\n\tusbhs_unlock(priv, flags);\n\t \n\n\tif (is_done) {\n\t\tpkt->done(priv, pkt);\n\t\tusbhs_pkt_start(pipe);\n\t}\n\n\treturn ret;\n}\n\nvoid usbhs_pkt_start(struct usbhs_pipe *pipe)\n{\n\tusbhsf_pkt_handler(pipe, USBHSF_PKT_PREPARE);\n}\n\n \n#define usbhsf_irq_empty_ctrl(p, e) usbhsf_irq_callback_ctrl(p, irq_bempsts, e)\n#define usbhsf_irq_ready_ctrl(p, e) usbhsf_irq_callback_ctrl(p, irq_brdysts, e)\n#define usbhsf_irq_callback_ctrl(pipe, status, enable)\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\t\\\n\t\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\t\\\n\t\tu16 status = (1 << usbhs_pipe_number(pipe));\t\t\\\n\t\tif (!mod)\t\t\t\t\t\t\\\n\t\t\treturn;\t\t\t\t\t\t\\\n\t\tif (enable)\t\t\t\t\t\t\\\n\t\t\tmod->status |= status;\t\t\t\t\\\n\t\telse\t\t\t\t\t\t\t\\\n\t\t\tmod->status &= ~status;\t\t\t\t\\\n\t\tusbhs_irq_callback_update(priv, mod);\t\t\t\\\n\t})\n\nstatic void usbhsf_tx_irq_ctrl(struct usbhs_pipe *pipe, int enable)\n{\n\t \n\tif (usbhs_pipe_is_dcp(pipe))\n\t\tusbhsf_irq_empty_ctrl(pipe, enable);\n\telse\n\t\tusbhsf_irq_ready_ctrl(pipe, enable);\n}\n\nstatic void usbhsf_rx_irq_ctrl(struct usbhs_pipe *pipe, int enable)\n{\n\tusbhsf_irq_ready_ctrl(pipe, enable);\n}\n\n \nstatic void usbhsf_send_terminator(struct usbhs_pipe *pipe,\n\t\t\t\t   struct usbhs_fifo *fifo)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tusbhs_bset(priv, fifo->ctr, BVAL, BVAL);\n}\n\nstatic int usbhsf_fifo_barrier(struct usbhs_priv *priv,\n\t\t\t       struct usbhs_fifo *fifo)\n{\n\t \n\tif (usbhs_read(priv, fifo->ctr) & FRDY)\n\t\treturn 0;\n\n\treturn -EBUSY;\n}\n\nstatic void usbhsf_fifo_clear(struct usbhs_pipe *pipe,\n\t\t\t      struct usbhs_fifo *fifo)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tint ret = 0;\n\n\tif (!usbhs_pipe_is_dcp(pipe)) {\n\t\t \n\t\tif (usbhs_pipe_is_dir_in(pipe))\n\t\t\tret = usbhs_pipe_is_accessible(pipe);\n\t\tif (!ret)\n\t\t\tret = usbhsf_fifo_barrier(priv, fifo);\n\t}\n\n\t \n\tif (!ret)\n\t\tusbhs_write(priv, fifo->ctr, BCLR);\n}\n\nstatic int usbhsf_fifo_rcv_len(struct usbhs_priv *priv,\n\t\t\t       struct usbhs_fifo *fifo)\n{\n\treturn usbhs_read(priv, fifo->ctr) & DTLN_MASK;\n}\n\nstatic void usbhsf_fifo_unselect(struct usbhs_pipe *pipe,\n\t\t\t\t struct usbhs_fifo *fifo)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tusbhs_pipe_select_fifo(pipe, NULL);\n\tusbhs_write(priv, fifo->sel, 0);\n}\n\nstatic int usbhsf_fifo_select(struct usbhs_pipe *pipe,\n\t\t\t      struct usbhs_fifo *fifo,\n\t\t\t      int write)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint timeout = 1024;\n\tu16 mask = ((1 << 5) | 0xF);\t\t \n\tu16 base = usbhs_pipe_number(pipe);\t \n\n\tif (usbhs_pipe_is_busy(pipe) ||\n\t    usbhsf_fifo_is_busy(fifo))\n\t\treturn -EBUSY;\n\n\tif (usbhs_pipe_is_dcp(pipe)) {\n\t\tbase |= (1 == write) << 5;\t \n\n\t\tif (usbhs_mod_is_host(priv))\n\t\t\tusbhs_dcp_dir_for_host(pipe, write);\n\t}\n\n\t \n\tusbhs_write(priv, fifo->sel, base | MBW_32);\n\n\t \n\twhile (timeout--) {\n\t\tif (base == (mask & usbhs_read(priv, fifo->sel))) {\n\t\t\tusbhs_pipe_select_fifo(pipe, fifo);\n\t\t\treturn 0;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tdev_err(dev, \"fifo select error\\n\");\n\n\treturn -EIO;\n}\n\n \nstatic int usbhs_dcp_dir_switch_to_write(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);  \n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\tusbhs_pipe_disable(pipe);\n\n\tret = usbhsf_fifo_select(pipe, fifo, 1);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s() failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tusbhs_pipe_sequence_data1(pipe);  \n\n\tusbhsf_fifo_clear(pipe, fifo);\n\tusbhsf_send_terminator(pipe, fifo);\n\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\tusbhsf_tx_irq_ctrl(pipe, 1);\n\tusbhs_pipe_enable(pipe);\n\n\treturn ret;\n}\n\nstatic int usbhs_dcp_dir_switch_to_read(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);  \n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\tusbhs_pipe_disable(pipe);\n\n\tret = usbhsf_fifo_select(pipe, fifo, 0);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"%s() fail\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tusbhs_pipe_sequence_data1(pipe);  \n\tusbhsf_fifo_clear(pipe, fifo);\n\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\tusbhsf_rx_irq_ctrl(pipe, 1);\n\tusbhs_pipe_enable(pipe);\n\n\treturn ret;\n\n}\n\nstatic int usbhs_dcp_dir_switch_done(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\n\tif (pkt->handler == &usbhs_dcp_status_stage_in_handler)\n\t\tusbhsf_tx_irq_ctrl(pipe, 0);\n\telse\n\t\tusbhsf_rx_irq_ctrl(pipe, 0);\n\n\tpkt->actual = pkt->length;\n\t*is_done = 1;\n\n\treturn 0;\n}\n\nconst struct usbhs_pkt_handle usbhs_dcp_status_stage_in_handler = {\n\t.prepare = usbhs_dcp_dir_switch_to_write,\n\t.try_run = usbhs_dcp_dir_switch_done,\n};\n\nconst struct usbhs_pkt_handle usbhs_dcp_status_stage_out_handler = {\n\t.prepare = usbhs_dcp_dir_switch_to_read,\n\t.try_run = usbhs_dcp_dir_switch_done,\n};\n\n \nstatic int usbhsf_dcp_data_stage_try_push(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\n\tusbhs_pipe_sequence_data1(pipe);  \n\n\t \n\tpkt->handler = &usbhs_fifo_pio_push_handler;\n\n\treturn pkt->handler->prepare(pkt, is_done);\n}\n\nconst struct usbhs_pkt_handle usbhs_dcp_data_stage_out_handler = {\n\t.prepare = usbhsf_dcp_data_stage_try_push,\n};\n\n \nstatic int usbhsf_dcp_data_stage_prepare_pop(struct usbhs_pkt *pkt,\n\t\t\t\t\t     int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\n\n\tif (usbhs_pipe_is_busy(pipe))\n\t\treturn 0;\n\n\t \n\tusbhs_pipe_disable(pipe);\n\n\tusbhs_pipe_sequence_data1(pipe);  \n\n\tusbhsf_fifo_select(pipe, fifo, 0);\n\tusbhsf_fifo_clear(pipe, fifo);\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\t \n\tpkt->handler = &usbhs_fifo_pio_pop_handler;\n\n\treturn pkt->handler->prepare(pkt, is_done);\n}\n\nconst struct usbhs_pkt_handle usbhs_dcp_data_stage_in_handler = {\n\t.prepare = usbhsf_dcp_data_stage_prepare_pop,\n};\n\n \nstatic int usbhsf_pio_try_push(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);  \n\tvoid __iomem *addr = priv->base + fifo->port;\n\tu8 *buf;\n\tint maxp = usbhs_pipe_get_maxpacket(pipe);\n\tint total_len;\n\tint i, ret, len;\n\tint is_short;\n\n\tusbhs_pipe_data_sequence(pipe, pkt->sequence);\n\tpkt->sequence = -1;  \n\n\tusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->length);\n\n\tret = usbhsf_fifo_select(pipe, fifo, 1);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret = usbhs_pipe_is_accessible(pipe);\n\tif (ret < 0) {\n\t\t \n\t\tret = 0;\n\t\tgoto usbhs_fifo_write_busy;\n\t}\n\n\tret = usbhsf_fifo_barrier(priv, fifo);\n\tif (ret < 0)\n\t\tgoto usbhs_fifo_write_busy;\n\n\tbuf\t\t= pkt->buf    + pkt->actual;\n\tlen\t\t= pkt->length - pkt->actual;\n\tlen\t\t= min(len, maxp);\n\ttotal_len\t= len;\n\tis_short\t= total_len < maxp;\n\n\t \n\tif (len >= 4 && !((unsigned long)buf & 0x03)) {\n\t\tiowrite32_rep(addr, buf, len / 4);\n\t\tlen %= 4;\n\t\tbuf += total_len - len;\n\t}\n\n\t \n\tif (usbhs_get_dparam(priv, cfifo_byte_addr)) {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tiowrite8(buf[i], addr + (i & 0x03));\n\t} else {\n\t\tfor (i = 0; i < len; i++)\n\t\t\tiowrite8(buf[i], addr + (0x03 - (i & 0x03)));\n\t}\n\n\t \n\tpkt->actual += total_len;\n\n\tif (pkt->actual < pkt->length)\n\t\t*is_done = 0;\t\t \n\telse if (is_short)\n\t\t*is_done = 1;\t\t \n\telse\n\t\t*is_done = !pkt->zero;\t \n\n\t \n\tif (is_short)\n\t\tusbhsf_send_terminator(pipe, fifo);\n\n\tusbhsf_tx_irq_ctrl(pipe, !*is_done);\n\tusbhs_pipe_running(pipe, !*is_done);\n\tusbhs_pipe_enable(pipe);\n\n\tdev_dbg(dev, \"  send %d (%d/ %d/ %d/ %d)\\n\",\n\t\tusbhs_pipe_number(pipe),\n\t\tpkt->length, pkt->actual, *is_done, pkt->zero);\n\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\treturn 0;\n\nusbhs_fifo_write_busy:\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\t \n\tusbhsf_tx_irq_ctrl(pipe, 1);\n\tusbhs_pipe_running(pipe, 1);\n\n\treturn ret;\n}\n\nstatic int usbhsf_pio_prepare_push(struct usbhs_pkt *pkt, int *is_done)\n{\n\tif (usbhs_pipe_is_running(pkt->pipe))\n\t\treturn 0;\n\n\treturn usbhsf_pio_try_push(pkt, is_done);\n}\n\nconst struct usbhs_pkt_handle usbhs_fifo_pio_push_handler = {\n\t.prepare = usbhsf_pio_prepare_push,\n\t.try_run = usbhsf_pio_try_push,\n};\n\n \nstatic int usbhsf_prepare_pop(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);\n\n\tif (usbhs_pipe_is_busy(pipe))\n\t\treturn 0;\n\n\tif (usbhs_pipe_is_running(pipe))\n\t\treturn 0;\n\n\t \n\tusbhs_pipe_data_sequence(pipe, pkt->sequence);\n\tpkt->sequence = -1;  \n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\tusbhsf_fifo_clear(pipe, fifo);\n\n\tusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->length);\n\tusbhs_pipe_enable(pipe);\n\tusbhs_pipe_running(pipe, 1);\n\tusbhsf_rx_irq_ctrl(pipe, 1);\n\n\treturn 0;\n}\n\nstatic int usbhsf_pio_try_pop(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);  \n\tvoid __iomem *addr = priv->base + fifo->port;\n\tu8 *buf;\n\tu32 data = 0;\n\tint maxp = usbhs_pipe_get_maxpacket(pipe);\n\tint rcv_len, len;\n\tint i, ret;\n\tint total_len = 0;\n\n\tret = usbhsf_fifo_select(pipe, fifo, 0);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tret = usbhsf_fifo_barrier(priv, fifo);\n\tif (ret < 0)\n\t\tgoto usbhs_fifo_read_busy;\n\n\trcv_len = usbhsf_fifo_rcv_len(priv, fifo);\n\n\tbuf\t\t= pkt->buf    + pkt->actual;\n\tlen\t\t= pkt->length - pkt->actual;\n\tlen\t\t= min(len, rcv_len);\n\ttotal_len\t= len;\n\n\t \n\tpkt->actual += total_len;\n\n\tif ((pkt->actual == pkt->length) ||\t \n\t    (total_len < maxp)) {\t\t \n\t\t*is_done = 1;\n\t\tusbhsf_rx_irq_ctrl(pipe, 0);\n\t\tusbhs_pipe_running(pipe, 0);\n\t\t \n\t\tif (!usbhs_mod_is_host(priv) && !usbhs_pipe_is_dcp(pipe))\n\t\t\tusbhs_pipe_disable(pipe);\t \n\t}\n\n\t \n\tif (0 == rcv_len) {\n\t\tpkt->zero = 1;\n\t\tusbhsf_fifo_clear(pipe, fifo);\n\t\tgoto usbhs_fifo_read_end;\n\t}\n\n\t \n\tif (len >= 4 && !((unsigned long)buf & 0x03)) {\n\t\tioread32_rep(addr, buf, len / 4);\n\t\tlen %= 4;\n\t\tbuf += total_len - len;\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tif (!(i & 0x03))\n\t\t\tdata = ioread32(addr);\n\n\t\tbuf[i] = (data >> ((i & 0x03) * 8)) & 0xff;\n\t}\n\nusbhs_fifo_read_end:\n\tdev_dbg(dev, \"  recv %d (%d/ %d/ %d/ %d)\\n\",\n\t\tusbhs_pipe_number(pipe),\n\t\tpkt->length, pkt->actual, *is_done, pkt->zero);\n\nusbhs_fifo_read_busy:\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\treturn ret;\n}\n\nconst struct usbhs_pkt_handle usbhs_fifo_pio_pop_handler = {\n\t.prepare = usbhsf_prepare_pop,\n\t.try_run = usbhsf_pio_try_pop,\n};\n\n \nstatic int usbhsf_ctrl_stage_end(struct usbhs_pkt *pkt, int *is_done)\n{\n\tusbhs_dcp_control_transfer_done(pkt->pipe);\n\n\t*is_done = 1;\n\n\treturn 0;\n}\n\nconst struct usbhs_pkt_handle usbhs_ctrl_stage_end_handler = {\n\t.prepare = usbhsf_ctrl_stage_end,\n\t.try_run = usbhsf_ctrl_stage_end,\n};\n\n \nstatic struct dma_chan *usbhsf_dma_chan_get(struct usbhs_fifo *fifo,\n\t\t\t\t\t    struct usbhs_pkt *pkt)\n{\n\tif (&usbhs_fifo_dma_push_handler == pkt->handler)\n\t\treturn fifo->tx_chan;\n\n\tif (&usbhs_fifo_dma_pop_handler == pkt->handler)\n\t\treturn fifo->rx_chan;\n\n\treturn NULL;\n}\n\nstatic struct usbhs_fifo *usbhsf_get_dma_fifo(struct usbhs_priv *priv,\n\t\t\t\t\t      struct usbhs_pkt *pkt)\n{\n\tstruct usbhs_fifo *fifo;\n\tint i;\n\n\tusbhs_for_each_dfifo(priv, fifo, i) {\n\t\tif (usbhsf_dma_chan_get(fifo, pkt) &&\n\t\t    !usbhsf_fifo_is_busy(fifo))\n\t\t\treturn fifo;\n\t}\n\n\treturn NULL;\n}\n\n#define usbhsf_dma_start(p, f)\t__usbhsf_dma_ctrl(p, f, DREQE)\n#define usbhsf_dma_stop(p, f)\t__usbhsf_dma_ctrl(p, f, 0)\nstatic void __usbhsf_dma_ctrl(struct usbhs_pipe *pipe,\n\t\t\t      struct usbhs_fifo *fifo,\n\t\t\t      u16 dreqe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tusbhs_bset(priv, fifo->sel, DREQE, dreqe);\n}\n\nstatic int __usbhsf_dma_map_ctrl(struct usbhs_pkt *pkt, int map)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\n\tstruct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);\n\tstruct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);\n\n\treturn info->dma_map_ctrl(chan->device->dev, pkt, map);\n}\n\nstatic void usbhsf_dma_complete(void *arg,\n\t\t\t\tconst struct dmaengine_result *result);\nstatic void usbhsf_dma_xfer_preparing(struct usbhs_pkt *pkt)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_fifo *fifo;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan *chan;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tenum dma_transfer_direction dir;\n\tdma_cookie_t cookie;\n\n\tfifo = usbhs_pipe_to_fifo(pipe);\n\tif (!fifo)\n\t\treturn;\n\n\tchan = usbhsf_dma_chan_get(fifo, pkt);\n\tdir = usbhs_pipe_is_dir_in(pipe) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;\n\n\tdesc = dmaengine_prep_slave_single(chan, pkt->dma + pkt->actual,\n\t\t\t\t\tpkt->trans, dir,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc)\n\t\treturn;\n\n\tdesc->callback_result\t= usbhsf_dma_complete;\n\tdesc->callback_param\t= pkt;\n\n\tcookie = dmaengine_submit(desc);\n\tif (cookie < 0) {\n\t\tdev_err(dev, \"Failed to submit dma descriptor\\n\");\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"  %s %d (%d/ %d)\\n\",\n\t\tfifo->name, usbhs_pipe_number(pipe), pkt->length, pkt->zero);\n\n\tusbhs_pipe_running(pipe, 1);\n\tusbhs_pipe_set_trans_count_if_bulk(pipe, pkt->trans);\n\tdma_async_issue_pending(chan);\n\tusbhsf_dma_start(pipe, fifo);\n\tusbhs_pipe_enable(pipe);\n}\n\nstatic void xfer_work(struct work_struct *work)\n{\n\tstruct usbhs_pkt *pkt = container_of(work, struct usbhs_pkt, work);\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tunsigned long flags;\n\n\tusbhs_lock(priv, flags);\n\tusbhsf_dma_xfer_preparing(pkt);\n\tusbhs_unlock(priv, flags);\n}\n\n \nstatic int usbhsf_dma_prepare_push(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo;\n\tint len = pkt->length - pkt->actual;\n\tint ret;\n\tuintptr_t align_mask;\n\n\tif (usbhs_pipe_is_busy(pipe))\n\t\treturn 0;\n\n\t \n\tif ((len < usbhs_get_dparam(priv, pio_dma_border)) ||\n\t    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))\n\t\tgoto usbhsf_pio_prepare_push;\n\n\t \n\tif (!usbhs_get_dparam(priv, has_usb_dmac) && len & 0x7)\n\t\tgoto usbhsf_pio_prepare_push;\n\n\t \n\talign_mask = usbhs_get_dparam(priv, has_usb_dmac) ?\n\t\t\t\t\tUSBHS_USB_DMAC_XFER_SIZE - 1 : 0x7;\n\tif ((uintptr_t)(pkt->buf + pkt->actual) & align_mask)\n\t\tgoto usbhsf_pio_prepare_push;\n\n\t \n\tif (usbhs_pipe_is_running(pipe))\n\t\treturn 0;\n\n\t \n\tfifo = usbhsf_get_dma_fifo(priv, pkt);\n\tif (!fifo)\n\t\tgoto usbhsf_pio_prepare_push;\n\n\tret = usbhsf_fifo_select(pipe, fifo, 0);\n\tif (ret < 0)\n\t\tgoto usbhsf_pio_prepare_push;\n\n\tif (usbhsf_dma_map(pkt) < 0)\n\t\tgoto usbhsf_pio_prepare_push_unselect;\n\n\tpkt->trans = len;\n\n\tusbhsf_tx_irq_ctrl(pipe, 0);\n\t \n\tif (usbhs_get_dparam(priv, has_usb_dmac)) {\n\t\tusbhsf_dma_xfer_preparing(pkt);\n\t} else {\n\t\tINIT_WORK(&pkt->work, xfer_work);\n\t\tschedule_work(&pkt->work);\n\t}\n\n\treturn 0;\n\nusbhsf_pio_prepare_push_unselect:\n\tusbhsf_fifo_unselect(pipe, fifo);\nusbhsf_pio_prepare_push:\n\t \n\tpkt->handler = &usbhs_fifo_pio_push_handler;\n\n\treturn pkt->handler->prepare(pkt, is_done);\n}\n\nstatic int usbhsf_dma_push_done(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tint is_short = pkt->trans % usbhs_pipe_get_maxpacket(pipe);\n\n\tpkt->actual += pkt->trans;\n\n\tif (pkt->actual < pkt->length)\n\t\t*is_done = 0;\t\t \n\telse if (is_short)\n\t\t*is_done = 1;\t\t \n\telse\n\t\t*is_done = !pkt->zero;\t \n\n\tusbhs_pipe_running(pipe, !*is_done);\n\n\tusbhsf_dma_stop(pipe, pipe->fifo);\n\tusbhsf_dma_unmap(pkt);\n\tusbhsf_fifo_unselect(pipe, pipe->fifo);\n\n\tif (!*is_done) {\n\t\t \n\t\tpkt->handler = &usbhs_fifo_pio_push_handler;\n\t\treturn pkt->handler->try_run(pkt, is_done);\n\t}\n\n\treturn 0;\n}\n\nconst struct usbhs_pkt_handle usbhs_fifo_dma_push_handler = {\n\t.prepare\t= usbhsf_dma_prepare_push,\n\t.dma_done\t= usbhsf_dma_push_done,\n};\n\n \n\nstatic int usbhsf_dma_prepare_pop_with_rx_irq(struct usbhs_pkt *pkt,\n\t\t\t\t\t      int *is_done)\n{\n\treturn usbhsf_prepare_pop(pkt, is_done);\n}\n\nstatic int usbhsf_dma_prepare_pop_with_usb_dmac(struct usbhs_pkt *pkt,\n\t\t\t\t\t\tint *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo;\n\tint ret;\n\n\tif (usbhs_pipe_is_busy(pipe))\n\t\treturn 0;\n\n\t \n\tif ((pkt->length < usbhs_get_dparam(priv, pio_dma_border)) ||\n\t    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\tfifo = usbhsf_get_dma_fifo(priv, pkt);\n\tif (!fifo)\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\tif ((uintptr_t)pkt->buf & (USBHS_USB_DMAC_XFER_SIZE - 1))\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\t \n\tif (usbhs_pipe_is_running(pipe))\n\t\treturn 0;\n\n\tusbhs_pipe_config_change_bfre(pipe, 1);\n\n\tret = usbhsf_fifo_select(pipe, fifo, 0);\n\tif (ret < 0)\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\tif (usbhsf_dma_map(pkt) < 0)\n\t\tgoto usbhsf_pio_prepare_pop_unselect;\n\n\t \n\n\t \n\tusbhsf_rx_irq_ctrl(pipe, 0);\n\n\tpkt->trans = pkt->length;\n\n\tusbhsf_dma_xfer_preparing(pkt);\n\n\treturn 0;\n\nusbhsf_pio_prepare_pop_unselect:\n\tusbhsf_fifo_unselect(pipe, fifo);\nusbhsf_pio_prepare_pop:\n\n\t \n\tpkt->handler = &usbhs_fifo_pio_pop_handler;\n\tusbhs_pipe_config_change_bfre(pipe, 0);\n\n\treturn pkt->handler->prepare(pkt, is_done);\n}\n\nstatic int usbhsf_dma_prepare_pop(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pkt->pipe);\n\n\tif (usbhs_get_dparam(priv, has_usb_dmac))\n\t\treturn usbhsf_dma_prepare_pop_with_usb_dmac(pkt, is_done);\n\telse\n\t\treturn usbhsf_dma_prepare_pop_with_rx_irq(pkt, is_done);\n}\n\nstatic int usbhsf_dma_try_pop_with_rx_irq(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo;\n\tint len, ret;\n\n\tif (usbhs_pipe_is_busy(pipe))\n\t\treturn 0;\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\t \n\tfifo = usbhsf_get_dma_fifo(priv, pkt);\n\tif (!fifo)\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\tif ((uintptr_t)(pkt->buf + pkt->actual) & 0x7)  \n\t\tgoto usbhsf_pio_prepare_pop;\n\n\tret = usbhsf_fifo_select(pipe, fifo, 0);\n\tif (ret < 0)\n\t\tgoto usbhsf_pio_prepare_pop;\n\n\t \n\tlen = usbhsf_fifo_rcv_len(priv, fifo);\n\tlen = min(pkt->length - pkt->actual, len);\n\tif (len & 0x7)  \n\t\tgoto usbhsf_pio_prepare_pop_unselect;\n\n\tif (len < usbhs_get_dparam(priv, pio_dma_border))\n\t\tgoto usbhsf_pio_prepare_pop_unselect;\n\n\tret = usbhsf_fifo_barrier(priv, fifo);\n\tif (ret < 0)\n\t\tgoto usbhsf_pio_prepare_pop_unselect;\n\n\tif (usbhsf_dma_map(pkt) < 0)\n\t\tgoto usbhsf_pio_prepare_pop_unselect;\n\n\t \n\n\t \n\tusbhsf_rx_irq_ctrl(pipe, 0);\n\n\tpkt->trans = len;\n\n\tINIT_WORK(&pkt->work, xfer_work);\n\tschedule_work(&pkt->work);\n\n\treturn 0;\n\nusbhsf_pio_prepare_pop_unselect:\n\tusbhsf_fifo_unselect(pipe, fifo);\nusbhsf_pio_prepare_pop:\n\n\t \n\tpkt->handler = &usbhs_fifo_pio_pop_handler;\n\n\treturn pkt->handler->try_run(pkt, is_done);\n}\n\nstatic int usbhsf_dma_try_pop(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pkt->pipe);\n\n\tBUG_ON(usbhs_get_dparam(priv, has_usb_dmac));\n\n\treturn usbhsf_dma_try_pop_with_rx_irq(pkt, is_done);\n}\n\nstatic int usbhsf_dma_pop_done_with_rx_irq(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tint maxp = usbhs_pipe_get_maxpacket(pipe);\n\n\tusbhsf_dma_stop(pipe, pipe->fifo);\n\tusbhsf_dma_unmap(pkt);\n\tusbhsf_fifo_unselect(pipe, pipe->fifo);\n\n\tpkt->actual += pkt->trans;\n\n\tif ((pkt->actual == pkt->length) ||\t \n\t    (pkt->trans < maxp)) {\t\t \n\t\t*is_done = 1;\n\t\tusbhs_pipe_running(pipe, 0);\n\t} else {\n\t\t \n\t\tusbhs_pipe_running(pipe, 0);\n\t\tusbhsf_prepare_pop(pkt, is_done);\n\t}\n\n\treturn 0;\n}\n\nstatic size_t usbhs_dma_calc_received_size(struct usbhs_pkt *pkt,\n\t\t\t\t\t   struct dma_chan *chan, int dtln)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tsize_t received_size;\n\tint maxp = usbhs_pipe_get_maxpacket(pipe);\n\n\treceived_size = pkt->length - pkt->dma_result->residue;\n\n\tif (dtln) {\n\t\treceived_size -= USBHS_USB_DMAC_XFER_SIZE;\n\t\treceived_size &= ~(maxp - 1);\n\t\treceived_size += dtln;\n\t}\n\n\treturn received_size;\n}\n\nstatic int usbhsf_dma_pop_done_with_usb_dmac(struct usbhs_pkt *pkt,\n\t\t\t\t\t     int *is_done)\n{\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);\n\tstruct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);\n\tint rcv_len;\n\n\t \n\tusbhs_xxxsts_clear(priv, BRDYSTS, usbhs_pipe_number(pipe));\n\n\trcv_len = usbhsf_fifo_rcv_len(priv, fifo);\n\tusbhsf_fifo_clear(pipe, fifo);\n\tpkt->actual = usbhs_dma_calc_received_size(pkt, chan, rcv_len);\n\n\tusbhs_pipe_running(pipe, 0);\n\tusbhsf_dma_stop(pipe, fifo);\n\tusbhsf_dma_unmap(pkt);\n\tusbhsf_fifo_unselect(pipe, pipe->fifo);\n\n\t \n\t*is_done = 1;\n\n\treturn 0;\n}\n\nstatic int usbhsf_dma_pop_done(struct usbhs_pkt *pkt, int *is_done)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pkt->pipe);\n\n\tif (usbhs_get_dparam(priv, has_usb_dmac))\n\t\treturn usbhsf_dma_pop_done_with_usb_dmac(pkt, is_done);\n\telse\n\t\treturn usbhsf_dma_pop_done_with_rx_irq(pkt, is_done);\n}\n\nconst struct usbhs_pkt_handle usbhs_fifo_dma_pop_handler = {\n\t.prepare\t= usbhsf_dma_prepare_pop,\n\t.try_run\t= usbhsf_dma_try_pop,\n\t.dma_done\t= usbhsf_dma_pop_done\n};\n\n \nstatic bool usbhsf_dma_filter(struct dma_chan *chan, void *param)\n{\n\tstruct sh_dmae_slave *slave = param;\n\n\t \n\tif (0 == slave->shdma_slave.slave_id)\n\t\treturn false;\n\n\tchan->private = slave;\n\n\treturn true;\n}\n\nstatic void usbhsf_dma_quit(struct usbhs_priv *priv, struct usbhs_fifo *fifo)\n{\n\tif (fifo->tx_chan)\n\t\tdma_release_channel(fifo->tx_chan);\n\tif (fifo->rx_chan)\n\t\tdma_release_channel(fifo->rx_chan);\n\n\tfifo->tx_chan = NULL;\n\tfifo->rx_chan = NULL;\n}\n\nstatic void usbhsf_dma_init_pdev(struct usbhs_fifo *fifo)\n{\n\tdma_cap_mask_t mask;\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tfifo->tx_chan = dma_request_channel(mask, usbhsf_dma_filter,\n\t\t\t\t\t    &fifo->tx_slave);\n\n\tdma_cap_zero(mask);\n\tdma_cap_set(DMA_SLAVE, mask);\n\tfifo->rx_chan = dma_request_channel(mask, usbhsf_dma_filter,\n\t\t\t\t\t    &fifo->rx_slave);\n}\n\nstatic void usbhsf_dma_init_dt(struct device *dev, struct usbhs_fifo *fifo,\n\t\t\t       int channel)\n{\n\tchar name[16];\n\n\t \n\tsnprintf(name, sizeof(name), \"ch%d\", channel);\n\tif (channel & 1) {\n\t\tfifo->tx_chan = dma_request_chan(dev, name);\n\t\tif (IS_ERR(fifo->tx_chan))\n\t\t\tfifo->tx_chan = NULL;\n\t} else {\n\t\tfifo->rx_chan = dma_request_chan(dev, name);\n\t\tif (IS_ERR(fifo->rx_chan))\n\t\t\tfifo->rx_chan = NULL;\n\t}\n}\n\nstatic void usbhsf_dma_init(struct usbhs_priv *priv, struct usbhs_fifo *fifo,\n\t\t\t    int channel)\n{\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tif (dev_of_node(dev))\n\t\tusbhsf_dma_init_dt(dev, fifo, channel);\n\telse\n\t\tusbhsf_dma_init_pdev(fifo);\n\n\tif (fifo->tx_chan || fifo->rx_chan)\n\t\tdev_dbg(dev, \"enable DMAEngine (%s%s%s)\\n\",\n\t\t\t fifo->name,\n\t\t\t fifo->tx_chan ? \"[TX]\" : \"    \",\n\t\t\t fifo->rx_chan ? \"[RX]\" : \"    \");\n}\n\n \nstatic int usbhsf_irq_empty(struct usbhs_priv *priv,\n\t\t\t    struct usbhs_irq_state *irq_state)\n{\n\tstruct usbhs_pipe *pipe;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint i, ret;\n\n\tif (!irq_state->bempsts) {\n\t\tdev_err(dev, \"debug %s !!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"irq empty [0x%04x]\\n\", irq_state->bempsts);\n\n\t \n\tusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\n\t\tif (!(irq_state->bempsts & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = usbhsf_pkt_handler(pipe, USBHSF_PKT_TRY_RUN);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"irq_empty run_error %d : %d\\n\", i, ret);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbhsf_irq_ready(struct usbhs_priv *priv,\n\t\t\t    struct usbhs_irq_state *irq_state)\n{\n\tstruct usbhs_pipe *pipe;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint i, ret;\n\n\tif (!irq_state->brdysts) {\n\t\tdev_err(dev, \"debug %s !!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tdev_dbg(dev, \"irq ready [0x%04x]\\n\", irq_state->brdysts);\n\n\t \n\tusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\n\t\tif (!(irq_state->brdysts & (1 << i)))\n\t\t\tcontinue;\n\n\t\tret = usbhsf_pkt_handler(pipe, USBHSF_PKT_TRY_RUN);\n\t\tif (ret < 0)\n\t\t\tdev_err(dev, \"irq_ready run_error %d : %d\\n\", i, ret);\n\t}\n\n\treturn 0;\n}\n\nstatic void usbhsf_dma_complete(void *arg,\n\t\t\t\tconst struct dmaengine_result *result)\n{\n\tstruct usbhs_pkt *pkt = arg;\n\tstruct usbhs_pipe *pipe = pkt->pipe;\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint ret;\n\n\tpkt->dma_result = result;\n\tret = usbhsf_pkt_handler(pipe, USBHSF_PKT_DMA_DONE);\n\tif (ret < 0)\n\t\tdev_err(dev, \"dma_complete run_error %d : %d\\n\",\n\t\t\tusbhs_pipe_number(pipe), ret);\n}\n\nvoid usbhs_fifo_clear_dcp(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct usbhs_fifo *fifo = usbhsf_get_cfifo(priv);  \n\n\t \n\tif (usbhsf_fifo_select(pipe, fifo, 1) < 0)\n\t\treturn;\n\tusbhsf_fifo_clear(pipe, fifo);\n\tusbhsf_fifo_unselect(pipe, fifo);\n\n\t \n\tif (usbhsf_fifo_select(pipe, fifo, 0) < 0)\n\t\treturn;\n\tusbhsf_fifo_clear(pipe, fifo);\n\tusbhsf_fifo_unselect(pipe, fifo);\n}\n\n \nvoid usbhs_fifo_init(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tstruct usbhs_fifo *cfifo = usbhsf_get_cfifo(priv);\n\tstruct usbhs_fifo *dfifo;\n\tint i;\n\n\tmod->irq_empty\t\t= usbhsf_irq_empty;\n\tmod->irq_ready\t\t= usbhsf_irq_ready;\n\tmod->irq_bempsts\t= 0;\n\tmod->irq_brdysts\t= 0;\n\n\tcfifo->pipe\t= NULL;\n\tusbhs_for_each_dfifo(priv, dfifo, i)\n\t\tdfifo->pipe\t= NULL;\n}\n\nvoid usbhs_fifo_quit(struct usbhs_priv *priv)\n{\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\n\tmod->irq_empty\t\t= NULL;\n\tmod->irq_ready\t\t= NULL;\n\tmod->irq_bempsts\t= 0;\n\tmod->irq_brdysts\t= 0;\n}\n\n#define __USBHS_DFIFO_INIT(priv, fifo, channel, fifo_port)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tfifo = usbhsf_get_dnfifo(priv, channel);\t\t\t\\\n\tfifo->name\t= \"D\"#channel\"FIFO\";\t\t\t\t\\\n\tfifo->port\t= fifo_port;\t\t\t\t\t\\\n\tfifo->sel\t= D##channel##FIFOSEL;\t\t\t\t\\\n\tfifo->ctr\t= D##channel##FIFOCTR;\t\t\t\t\\\n\tfifo->tx_slave.shdma_slave.slave_id =\t\t\t\t\\\n\t\t\tusbhs_get_dparam(priv, d##channel##_tx_id);\t\\\n\tfifo->rx_slave.shdma_slave.slave_id =\t\t\t\t\\\n\t\t\tusbhs_get_dparam(priv, d##channel##_rx_id);\t\\\n\tusbhsf_dma_init(priv, fifo, channel);\t\t\t\t\\\n} while (0)\n\n#define USBHS_DFIFO_INIT(priv, fifo, channel)\t\t\t\t\\\n\t\t__USBHS_DFIFO_INIT(priv, fifo, channel, D##channel##FIFO)\n#define USBHS_DFIFO_INIT_NO_PORT(priv, fifo, channel)\t\t\t\\\n\t\t__USBHS_DFIFO_INIT(priv, fifo, channel, 0)\n\nint usbhs_fifo_probe(struct usbhs_priv *priv)\n{\n\tstruct usbhs_fifo *fifo;\n\n\t \n\tfifo = usbhsf_get_cfifo(priv);\n\tfifo->name\t= \"CFIFO\";\n\tfifo->port\t= CFIFO;\n\tfifo->sel\t= CFIFOSEL;\n\tfifo->ctr\t= CFIFOCTR;\n\n\t \n\tUSBHS_DFIFO_INIT(priv, fifo, 0);\n\tUSBHS_DFIFO_INIT(priv, fifo, 1);\n\tUSBHS_DFIFO_INIT_NO_PORT(priv, fifo, 2);\n\tUSBHS_DFIFO_INIT_NO_PORT(priv, fifo, 3);\n\n\treturn 0;\n}\n\nvoid usbhs_fifo_remove(struct usbhs_priv *priv)\n{\n\tstruct usbhs_fifo *fifo;\n\tint i;\n\n\tusbhs_for_each_dfifo(priv, fifo, i)\n\t\tusbhsf_dma_quit(priv, fifo);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}