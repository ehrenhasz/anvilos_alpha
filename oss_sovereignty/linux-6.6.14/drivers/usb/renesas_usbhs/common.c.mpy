{
  "module_name": "common.c",
  "hash_id": "488a0c5e635794c2c67ff6245a2410c6e033a0b7750adcb8a852a90023248c3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/common.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include \"common.h\"\n#include \"rcar2.h\"\n#include \"rcar3.h\"\n#include \"rza.h\"\n\n \n\n \n#define usbhs_platform_call(priv, func, args...)\\\n\t(!(priv) ? -ENODEV :\t\t\t\\\n\t !((priv)->pfunc->func) ? 0 :\t\t\\\n\t (priv)->pfunc->func(args))\n\n \nu16 usbhs_read(struct usbhs_priv *priv, u32 reg)\n{\n\treturn ioread16(priv->base + reg);\n}\n\nvoid usbhs_write(struct usbhs_priv *priv, u32 reg, u16 data)\n{\n\tiowrite16(data, priv->base + reg);\n}\n\nvoid usbhs_bset(struct usbhs_priv *priv, u32 reg, u16 mask, u16 data)\n{\n\tu16 val = usbhs_read(priv, reg);\n\n\tval &= ~mask;\n\tval |= data & mask;\n\n\tusbhs_write(priv, reg, val);\n}\n\nstruct usbhs_priv *usbhs_pdev_to_priv(struct platform_device *pdev)\n{\n\treturn dev_get_drvdata(&pdev->dev);\n}\n\nint usbhs_get_id_as_gadget(struct platform_device *pdev)\n{\n\treturn USBHS_GADGET;\n}\n\n \nstatic void usbhs_sys_clock_ctrl(struct usbhs_priv *priv, int enable)\n{\n\tusbhs_bset(priv, SYSCFG, SCKE, enable ? SCKE : 0);\n}\n\nvoid usbhs_sys_host_ctrl(struct usbhs_priv *priv, int enable)\n{\n\tu16 mask = DCFM | DRPD | DPRPU | HSE | USBE;\n\tu16 val  = DCFM | DRPD | HSE | USBE;\n\n\t \n\tusbhs_bset(priv, SYSCFG, mask, enable ? val : 0);\n}\n\nvoid usbhs_sys_function_ctrl(struct usbhs_priv *priv, int enable)\n{\n\tu16 mask = DCFM | DRPD | DPRPU | HSE | USBE;\n\tu16 val  = HSE | USBE;\n\n\t \n\tif (usbhs_get_dparam(priv, has_cnen)) {\n\t\tmask |= CNEN;\n\t\tval  |= CNEN;\n\t}\n\n\t \n\tusbhs_bset(priv, SYSCFG, mask, enable ? val : 0);\n}\n\nvoid usbhs_sys_function_pullup(struct usbhs_priv *priv, int enable)\n{\n\tusbhs_bset(priv, SYSCFG, DPRPU, enable ? DPRPU : 0);\n}\n\nvoid usbhs_sys_set_test_mode(struct usbhs_priv *priv, u16 mode)\n{\n\tusbhs_write(priv, TESTMODE, mode);\n}\n\n \nint usbhs_frame_get_num(struct usbhs_priv *priv)\n{\n\treturn usbhs_read(priv, FRMNUM) & FRNM_MASK;\n}\n\n \nvoid usbhs_usbreq_get_val(struct usbhs_priv *priv, struct usb_ctrlrequest *req)\n{\n\tu16 val;\n\n\tval = usbhs_read(priv, USBREQ);\n\treq->bRequest\t\t= (val >> 8) & 0xFF;\n\treq->bRequestType\t= (val >> 0) & 0xFF;\n\n\treq->wValue\t= cpu_to_le16(usbhs_read(priv, USBVAL));\n\treq->wIndex\t= cpu_to_le16(usbhs_read(priv, USBINDX));\n\treq->wLength\t= cpu_to_le16(usbhs_read(priv, USBLENG));\n}\n\nvoid usbhs_usbreq_set_val(struct usbhs_priv *priv, struct usb_ctrlrequest *req)\n{\n\tusbhs_write(priv, USBREQ,  (req->bRequest << 8) | req->bRequestType);\n\tusbhs_write(priv, USBVAL,  le16_to_cpu(req->wValue));\n\tusbhs_write(priv, USBINDX, le16_to_cpu(req->wIndex));\n\tusbhs_write(priv, USBLENG, le16_to_cpu(req->wLength));\n\n\tusbhs_bset(priv, DCPCTR, SUREQ, SUREQ);\n}\n\n \nvoid usbhs_bus_send_sof_enable(struct usbhs_priv *priv)\n{\n\tu16 status = usbhs_read(priv, DVSTCTR) & (USBRST | UACT);\n\n\tif (status != USBRST) {\n\t\tstruct device *dev = usbhs_priv_to_dev(priv);\n\t\tdev_err(dev, \"usbhs should be reset\\n\");\n\t}\n\n\tusbhs_bset(priv, DVSTCTR, (USBRST | UACT), UACT);\n}\n\nvoid usbhs_bus_send_reset(struct usbhs_priv *priv)\n{\n\tusbhs_bset(priv, DVSTCTR, (USBRST | UACT), USBRST);\n}\n\nint usbhs_bus_get_speed(struct usbhs_priv *priv)\n{\n\tu16 dvstctr = usbhs_read(priv, DVSTCTR);\n\n\tswitch (RHST & dvstctr) {\n\tcase RHST_LOW_SPEED:\n\t\treturn USB_SPEED_LOW;\n\tcase RHST_FULL_SPEED:\n\t\treturn USB_SPEED_FULL;\n\tcase RHST_HIGH_SPEED:\n\t\treturn USB_SPEED_HIGH;\n\t}\n\n\treturn USB_SPEED_UNKNOWN;\n}\n\nint usbhs_vbus_ctrl(struct usbhs_priv *priv, int enable)\n{\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\n\treturn usbhs_platform_call(priv, set_vbus, pdev, enable);\n}\n\nstatic void usbhsc_bus_init(struct usbhs_priv *priv)\n{\n\tusbhs_write(priv, DVSTCTR, 0);\n\n\tusbhs_vbus_ctrl(priv, 0);\n}\n\n \nint usbhs_set_device_config(struct usbhs_priv *priv, int devnum,\n\t\t\t   u16 upphub, u16 hubport, u16 speed)\n{\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tu16 usbspd = 0;\n\tu32 reg = DEVADD0 + (2 * devnum);\n\n\tif (devnum > 10) {\n\t\tdev_err(dev, \"cannot set speed to unknown device %d\\n\", devnum);\n\t\treturn -EIO;\n\t}\n\n\tif (upphub > 0xA) {\n\t\tdev_err(dev, \"unsupported hub number %d\\n\", upphub);\n\t\treturn -EIO;\n\t}\n\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\tusbspd = USBSPD_SPEED_LOW;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tusbspd = USBSPD_SPEED_FULL;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tusbspd = USBSPD_SPEED_HIGH;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported speed %d\\n\", speed);\n\t\treturn -EIO;\n\t}\n\n\tusbhs_write(priv, reg,\tUPPHUB(upphub)\t|\n\t\t\t\tHUBPORT(hubport)|\n\t\t\t\tUSBSPD(usbspd));\n\n\treturn 0;\n}\n\n \nvoid usbhs_xxxsts_clear(struct usbhs_priv *priv, u16 sts_reg, u16 bit)\n{\n\tu16 pipe_mask = (u16)GENMASK(usbhs_get_dparam(priv, pipe_size), 0);\n\n\tusbhs_write(priv, sts_reg, ~(1 << bit) & pipe_mask);\n}\n\n \nstatic void usbhsc_set_buswait(struct usbhs_priv *priv)\n{\n\tint wait = usbhs_get_dparam(priv, buswait_bwait);\n\n\t \n\tif (wait)\n\t\tusbhs_bset(priv, BUSWAIT, 0x000F, wait);\n}\n\nstatic bool usbhsc_is_multi_clks(struct usbhs_priv *priv)\n{\n\treturn priv->dparam.multi_clks;\n}\n\nstatic int usbhsc_clk_get(struct device *dev, struct usbhs_priv *priv)\n{\n\tif (!usbhsc_is_multi_clks(priv))\n\t\treturn 0;\n\n\t \n\tpriv->clks[0] = of_clk_get(dev_of_node(dev), 0);\n\tif (IS_ERR(priv->clks[0]))\n\t\treturn PTR_ERR(priv->clks[0]);\n\n\t \n\tpriv->clks[1] = of_clk_get(dev_of_node(dev), 1);\n\tif (PTR_ERR(priv->clks[1]) == -ENOENT)\n\t\tpriv->clks[1] = NULL;\n\telse if (IS_ERR(priv->clks[1]))\n\t\treturn PTR_ERR(priv->clks[1]);\n\n\treturn 0;\n}\n\nstatic void usbhsc_clk_put(struct usbhs_priv *priv)\n{\n\tint i;\n\n\tif (!usbhsc_is_multi_clks(priv))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->clks); i++)\n\t\tclk_put(priv->clks[i]);\n}\n\nstatic int usbhsc_clk_prepare_enable(struct usbhs_priv *priv)\n{\n\tint i, ret;\n\n\tif (!usbhsc_is_multi_clks(priv))\n\t\treturn 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->clks); i++) {\n\t\tret = clk_prepare_enable(priv->clks[i]);\n\t\tif (ret) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tclk_disable_unprepare(priv->clks[i]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void usbhsc_clk_disable_unprepare(struct usbhs_priv *priv)\n{\n\tint i;\n\n\tif (!usbhsc_is_multi_clks(priv))\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(priv->clks); i++)\n\t\tclk_disable_unprepare(priv->clks[i]);\n}\n\n \n\n \nstatic struct renesas_usbhs_driver_pipe_config usbhsc_default_pipe[] = {\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_CONTROL, 64, 0x00, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_ISOC, 1024, 0x08, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_ISOC, 1024, 0x18, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x28, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x38, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x48, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x04, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x05, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x06, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x07, false),\n};\n\n \nstatic struct renesas_usbhs_driver_pipe_config usbhsc_new_pipe[] = {\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_CONTROL, 64, 0x00, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_ISOC, 1024, 0x08, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_ISOC, 1024, 0x28, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x48, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x58, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x68, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x04, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x05, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_INT, 64, 0x06, false),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x78, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x88, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0x98, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0xa8, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0xb8, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0xc8, true),\n\tRENESAS_USBHS_PIPE(USB_ENDPOINT_XFER_BULK, 512, 0xd8, true),\n};\n\n \nstatic void usbhsc_power_ctrl(struct usbhs_priv *priv, int enable)\n{\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\tif (enable) {\n\t\t \n\t\tpm_runtime_get_sync(dev);\n\n\t\t \n\t\tif (usbhsc_clk_prepare_enable(priv))\n\t\t\treturn;\n\n\t\t \n\t\tusbhs_platform_call(priv, power_ctrl, pdev, priv->base, enable);\n\n\t\t \n\t\tusbhs_sys_clock_ctrl(priv, enable);\n\t} else {\n\t\t \n\t\tusbhs_sys_clock_ctrl(priv, enable);\n\n\t\t \n\t\tusbhs_platform_call(priv, power_ctrl, pdev, priv->base, enable);\n\n\t\t \n\t\tusbhsc_clk_disable_unprepare(priv);\n\n\t\t \n\t\tpm_runtime_put_sync(dev);\n\t}\n}\n\n \nstatic void usbhsc_hotplug(struct usbhs_priv *priv)\n{\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\tint id;\n\tint enable;\n\tint cable;\n\tint ret;\n\n\t \n\tenable = usbhs_mod_info_call(priv, get_vbus, pdev);\n\n\t \n\tid = usbhs_platform_call(priv, get_id, pdev);\n\n\tif (enable && !mod) {\n\t\tif (priv->edev) {\n\t\t\tcable = extcon_get_state(priv->edev, EXTCON_USB_HOST);\n\t\t\tif ((cable > 0 && id != USBHS_HOST) ||\n\t\t\t    (!cable && id != USBHS_GADGET)) {\n\t\t\t\tdev_info(&pdev->dev,\n\t\t\t\t\t \"USB cable plugged in doesn't match the selected role!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tret = usbhs_mod_change(priv, id);\n\t\tif (ret < 0)\n\t\t\treturn;\n\n\t\tdev_dbg(&pdev->dev, \"%s enable\\n\", __func__);\n\n\t\t \n\t\tif (usbhs_get_dparam(priv, runtime_pwctrl))\n\t\t\tusbhsc_power_ctrl(priv, enable);\n\n\t\t \n\t\tusbhsc_set_buswait(priv);\n\t\tusbhsc_bus_init(priv);\n\n\t\t \n\t\tusbhs_mod_call(priv, start, priv);\n\n\t} else if (!enable && mod) {\n\t\tdev_dbg(&pdev->dev, \"%s disable\\n\", __func__);\n\n\t\t \n\t\tusbhs_mod_call(priv, stop, priv);\n\n\t\t \n\t\tusbhsc_bus_init(priv);\n\n\t\t \n\t\tif (usbhs_get_dparam(priv, runtime_pwctrl))\n\t\t\tusbhsc_power_ctrl(priv, enable);\n\n\t\tusbhs_mod_change(priv, -1);\n\n\t\t \n\t\tusbhs_platform_call(priv, phy_reset, pdev);\n\t}\n}\n\n \nstatic void usbhsc_notify_hotplug(struct work_struct *work)\n{\n\tstruct usbhs_priv *priv = container_of(work,\n\t\t\t\t\t       struct usbhs_priv,\n\t\t\t\t\t       notify_hotplug_work.work);\n\tusbhsc_hotplug(priv);\n}\n\nint usbhsc_schedule_notify_hotplug(struct platform_device *pdev)\n{\n\tstruct usbhs_priv *priv = usbhs_pdev_to_priv(pdev);\n\tint delay = usbhs_get_dparam(priv, detection_delay);\n\n\t \n\tschedule_delayed_work(&priv->notify_hotplug_work,\n\t\t\t      msecs_to_jiffies(delay));\n\treturn 0;\n}\n\n \nstatic const struct of_device_id usbhs_of_match[] = {\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a774c0\",\n\t\t.data = &usbhs_rcar_gen3_with_pll_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a7790\",\n\t\t.data = &usbhs_rcar_gen2_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a7791\",\n\t\t.data = &usbhs_rcar_gen2_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a7794\",\n\t\t.data = &usbhs_rcar_gen2_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a7795\",\n\t\t.data = &usbhs_rcar_gen3_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a7796\",\n\t\t.data = &usbhs_rcar_gen3_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a77990\",\n\t\t.data = &usbhs_rcar_gen3_with_pll_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,usbhs-r8a77995\",\n\t\t.data = &usbhs_rcar_gen3_with_pll_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen2-usbhs\",\n\t\t.data = &usbhs_rcar_gen2_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,rcar-gen3-usbhs\",\n\t\t.data = &usbhs_rcar_gen3_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,rza1-usbhs\",\n\t\t.data = &usbhs_rza1_plat_info,\n\t},\n\t{\n\t\t.compatible = \"renesas,rza2-usbhs\",\n\t\t.data = &usbhs_rza2_plat_info,\n\t},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, usbhs_of_match);\n\nstatic int usbhs_probe(struct platform_device *pdev)\n{\n\tconst struct renesas_usbhs_platform_info *info;\n\tstruct usbhs_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_desc *gpiod;\n\tint ret;\n\tu32 tmp;\n\tint irq;\n\n\t \n\tif (dev_of_node(dev))\n\t\tinfo = of_device_get_match_data(dev);\n\telse\n\t\tinfo = renesas_usbhs_get_info(pdev);\n\n\t \n\tif (!info) {\n\t\tdev_err(dev, \"no platform information\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv->base))\n\t\treturn PTR_ERR(priv->base);\n\n\tif (of_property_read_bool(dev_of_node(dev), \"extcon\")) {\n\t\tpriv->edev = extcon_get_edev_by_phandle(dev, 0);\n\t\tif (IS_ERR(priv->edev))\n\t\t\treturn PTR_ERR(priv->edev);\n\t}\n\n\tpriv->rsts = devm_reset_control_array_get_optional_shared(dev);\n\tif (IS_ERR(priv->rsts))\n\t\treturn PTR_ERR(priv->rsts);\n\n\t \n\n\tpriv->dparam = info->driver_param;\n\n\tif (!info->platform_callback.get_id) {\n\t\tdev_err(dev, \"no platform callbacks\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpriv->pfunc = &info->platform_callback;\n\n\t \n\tif (usbhs_get_dparam(priv, has_new_pipe_configs)) {\n\t\tpriv->dparam.pipe_configs = usbhsc_new_pipe;\n\t\tpriv->dparam.pipe_size = ARRAY_SIZE(usbhsc_new_pipe);\n\t} else if (!priv->dparam.pipe_configs) {\n\t\tpriv->dparam.pipe_configs = usbhsc_default_pipe;\n\t\tpriv->dparam.pipe_size = ARRAY_SIZE(usbhsc_default_pipe);\n\t}\n\tif (!priv->dparam.pio_dma_border)\n\t\tpriv->dparam.pio_dma_border = 64;  \n\tif (!of_property_read_u32(dev_of_node(dev), \"renesas,buswait\", &tmp))\n\t\tpriv->dparam.buswait_bwait = tmp;\n\tgpiod = devm_gpiod_get_optional(dev, \"renesas,enable\", GPIOD_IN);\n\tif (IS_ERR(gpiod))\n\t\treturn PTR_ERR(gpiod);\n\n\t \n\t \n\tif (priv->pfunc->get_vbus)\n\t\tusbhs_get_dparam(priv, runtime_pwctrl) = 1;\n\n\t \n\tpriv->irq = irq;\n\tpriv->pdev\t= pdev;\n\tINIT_DELAYED_WORK(&priv->notify_hotplug_work, usbhsc_notify_hotplug);\n\tspin_lock_init(usbhs_priv_to_lock(priv));\n\n\t \n\tret = usbhs_pipe_probe(priv);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usbhs_fifo_probe(priv);\n\tif (ret < 0)\n\t\tgoto probe_end_pipe_exit;\n\n\tret = usbhs_mod_probe(priv);\n\tif (ret < 0)\n\t\tgoto probe_end_fifo_exit;\n\n\t \n\tplatform_set_drvdata(pdev, priv);\n\n\tret = reset_control_deassert(priv->rsts);\n\tif (ret)\n\t\tgoto probe_fail_rst;\n\n\tret = usbhsc_clk_get(dev, priv);\n\tif (ret)\n\t\tgoto probe_fail_clks;\n\n\t \n\tusbhs_sys_clock_ctrl(priv, 0);\n\n\t \n\tif (gpiod) {\n\t\tret = !gpiod_get_value(gpiod);\n\t\tif (ret) {\n\t\t\tdev_warn(dev, \"USB function not selected (GPIO)\\n\");\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto probe_end_mod_exit;\n\t\t}\n\t}\n\n\t \n\tret = usbhs_platform_call(priv, hardware_init, pdev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"platform init failed.\\n\");\n\t\tgoto probe_end_mod_exit;\n\t}\n\n\t \n\tusbhs_platform_call(priv, phy_reset, pdev);\n\n\t \n\tpm_runtime_enable(dev);\n\tif (!usbhs_get_dparam(priv, runtime_pwctrl)) {\n\t\tusbhsc_power_ctrl(priv, 1);\n\t\tusbhs_mod_autonomy_mode(priv);\n\t} else {\n\t\tusbhs_mod_non_autonomy_mode(priv);\n\t}\n\n\t \n\tusbhsc_schedule_notify_hotplug(pdev);\n\n\tdev_info(dev, \"probed\\n\");\n\n\treturn ret;\n\nprobe_end_mod_exit:\n\tusbhsc_clk_put(priv);\nprobe_fail_clks:\n\treset_control_assert(priv->rsts);\nprobe_fail_rst:\n\tusbhs_mod_remove(priv);\nprobe_end_fifo_exit:\n\tusbhs_fifo_remove(priv);\nprobe_end_pipe_exit:\n\tusbhs_pipe_remove(priv);\n\n\tdev_info(dev, \"probe failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void usbhs_remove(struct platform_device *pdev)\n{\n\tstruct usbhs_priv *priv = usbhs_pdev_to_priv(pdev);\n\n\tdev_dbg(&pdev->dev, \"usb remove\\n\");\n\n\t \n\tif (!usbhs_get_dparam(priv, runtime_pwctrl))\n\t\tusbhsc_power_ctrl(priv, 0);\n\n\tpm_runtime_disable(&pdev->dev);\n\n\tusbhs_platform_call(priv, hardware_exit, pdev);\n\tusbhsc_clk_put(priv);\n\treset_control_assert(priv->rsts);\n\tusbhs_mod_remove(priv);\n\tusbhs_fifo_remove(priv);\n\tusbhs_pipe_remove(priv);\n}\n\nstatic __maybe_unused int usbhsc_suspend(struct device *dev)\n{\n\tstruct usbhs_priv *priv = dev_get_drvdata(dev);\n\tstruct usbhs_mod *mod = usbhs_mod_get_current(priv);\n\n\tif (mod) {\n\t\tusbhs_mod_call(priv, stop, priv);\n\t\tusbhs_mod_change(priv, -1);\n\t}\n\n\tif (mod || !usbhs_get_dparam(priv, runtime_pwctrl))\n\t\tusbhsc_power_ctrl(priv, 0);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int usbhsc_resume(struct device *dev)\n{\n\tstruct usbhs_priv *priv = dev_get_drvdata(dev);\n\tstruct platform_device *pdev = usbhs_priv_to_pdev(priv);\n\n\tif (!usbhs_get_dparam(priv, runtime_pwctrl)) {\n\t\tusbhsc_power_ctrl(priv, 1);\n\t\tusbhs_mod_autonomy_mode(priv);\n\t}\n\n\tusbhs_platform_call(priv, phy_reset, pdev);\n\n\tusbhsc_schedule_notify_hotplug(pdev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(usbhsc_pm_ops, usbhsc_suspend, usbhsc_resume);\n\nstatic struct platform_driver renesas_usbhs_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"renesas_usbhs\",\n\t\t.pm\t= &usbhsc_pm_ops,\n\t\t.of_match_table = usbhs_of_match,\n\t},\n\t.probe\t\t= usbhs_probe,\n\t.remove_new\t= usbhs_remove,\n};\n\nmodule_platform_driver(renesas_usbhs_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Renesas USB driver\");\nMODULE_AUTHOR(\"Kuninori Morimoto <kuninori.morimoto.gx@renesas.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}