{
  "module_name": "pipe.h",
  "hash_id": "895f8eabf0201581b8a041e63e1ad14f5fc8ed1d0d6babc2f8d6991ac2c0809b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/pipe.h",
  "human_readable_source": " \n \n#ifndef RENESAS_USB_PIPE_H\n#define RENESAS_USB_PIPE_H\n\n#include \"common.h\"\n#include \"fifo.h\"\n\n \nstruct usbhs_pipe {\n\tu32 pipe_type;\t \n\n\tstruct usbhs_priv *priv;\n\tstruct usbhs_fifo *fifo;\n\tstruct list_head list;\n\n\tint maxp;\n\n\tu32 flags;\n#define USBHS_PIPE_FLAGS_IS_USED\t\t(1 << 0)\n#define USBHS_PIPE_FLAGS_IS_DIR_IN\t\t(1 << 1)\n#define USBHS_PIPE_FLAGS_IS_DIR_HOST\t\t(1 << 2)\n#define USBHS_PIPE_FLAGS_IS_RUNNING\t\t(1 << 3)\n\n\tconst struct usbhs_pkt_handle *handler;\n\n\tvoid *mod_private;\n};\n\nstruct usbhs_pipe_info {\n\tstruct usbhs_pipe *pipe;\n\tint size;\t \n\n\tint (*dma_map_ctrl)(struct device *dma_dev, struct usbhs_pkt *pkt,\n\t\t\t    int map);\n};\n\n \n#define __usbhs_for_each_pipe(start, pos, info, i)\t\\\n\tfor ((i) = start;\t\t\t\t\t\t\\\n\t     ((i) < (info)->size) && ((pos) = (info)->pipe + (i));\t\\\n\t     (i)++)\n\n#define usbhs_for_each_pipe(pos, priv, i)\t\t\t\\\n\t__usbhs_for_each_pipe(1, pos, &((priv)->pipe_info), i)\n\n#define usbhs_for_each_pipe_with_dcp(pos, priv, i)\t\t\\\n\t__usbhs_for_each_pipe(0, pos, &((priv)->pipe_info), i)\n\n \n#define usbhs_priv_to_pipeinfo(pr)\t(&(pr)->pipe_info)\n\n \nchar *usbhs_pipe_name(struct usbhs_pipe *pipe);\nstruct usbhs_pipe\n*usbhs_pipe_malloc(struct usbhs_priv *priv, int endpoint_type, int dir_in);\nvoid usbhs_pipe_free(struct usbhs_pipe *pipe);\nint usbhs_pipe_probe(struct usbhs_priv *priv);\nvoid usbhs_pipe_remove(struct usbhs_priv *priv);\nint usbhs_pipe_is_dir_in(struct usbhs_pipe *pipe);\nint usbhs_pipe_is_dir_host(struct usbhs_pipe *pipe);\nint usbhs_pipe_is_running(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_running(struct usbhs_pipe *pipe, int running);\n\nvoid usbhs_pipe_init(struct usbhs_priv *priv,\n\t\t     int (*dma_map_ctrl)(struct device *dma_dev,\n\t\t\t\t\t struct usbhs_pkt *pkt, int map));\nint usbhs_pipe_get_maxpacket(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_clear(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_clear_without_sequence(struct usbhs_pipe *pipe,\n\t\t\t\t       int needs_bfre, int bfre_enable);\nint usbhs_pipe_is_accessible(struct usbhs_pipe *pipe);\nbool usbhs_pipe_contains_transmittable_data(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_enable(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_disable(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_stall(struct usbhs_pipe *pipe);\nint usbhs_pipe_is_stall(struct usbhs_pipe *pipe);\nvoid usbhs_pipe_set_trans_count_if_bulk(struct usbhs_pipe *pipe, int len);\nvoid usbhs_pipe_select_fifo(struct usbhs_pipe *pipe, struct usbhs_fifo *fifo);\nvoid usbhs_pipe_config_update(struct usbhs_pipe *pipe, u16 devsel,\n\t\t\t      u16 epnum, u16 maxp);\nvoid usbhs_pipe_config_change_bfre(struct usbhs_pipe *pipe, int enable);\n\n#define usbhs_pipe_sequence_data0(pipe)\tusbhs_pipe_data_sequence(pipe, 0)\n#define usbhs_pipe_sequence_data1(pipe)\tusbhs_pipe_data_sequence(pipe, 1)\nvoid usbhs_pipe_data_sequence(struct usbhs_pipe *pipe, int data);\n\n#define usbhs_pipe_to_priv(p)\t((p)->priv)\n#define usbhs_pipe_number(p)\t(int)((p) - (p)->priv->pipe_info.pipe)\n#define usbhs_pipe_is_dcp(p)\t((p)->priv->pipe_info.pipe == (p))\n#define usbhs_pipe_to_fifo(p)\t((p)->fifo)\n#define usbhs_pipe_is_busy(p)\tusbhs_pipe_to_fifo(p)\n\n#define usbhs_pipe_type(p)\t\t((p)->pipe_type)\n#define usbhs_pipe_type_is(p, t)\t((p)->pipe_type == t)\n\n \nstruct usbhs_pipe *usbhs_dcp_malloc(struct usbhs_priv *priv);\nvoid usbhs_dcp_control_transfer_done(struct usbhs_pipe *pipe);\nvoid usbhs_dcp_dir_for_host(struct usbhs_pipe *pipe, int dir_out);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}