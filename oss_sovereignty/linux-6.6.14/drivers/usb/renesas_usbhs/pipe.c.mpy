{
  "module_name": "pipe.c",
  "hash_id": "39312427d0d44830005db88cc3d2e05b66e6a54bbe1f989faf9106d2063a121e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/renesas_usbhs/pipe.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/slab.h>\n#include \"common.h\"\n#include \"pipe.h\"\n\n \n#define usbhsp_addr_offset(p)\t((usbhs_pipe_number(p) - 1) * 2)\n\n#define usbhsp_flags_set(p, f)\t((p)->flags |=  USBHS_PIPE_FLAGS_##f)\n#define usbhsp_flags_clr(p, f)\t((p)->flags &= ~USBHS_PIPE_FLAGS_##f)\n#define usbhsp_flags_has(p, f)\t((p)->flags &   USBHS_PIPE_FLAGS_##f)\n#define usbhsp_flags_init(p)\tdo {(p)->flags = 0; } while (0)\n\n \nstatic char *usbhsp_pipe_name[] = {\n\t[USB_ENDPOINT_XFER_CONTROL]\t= \"DCP\",\n\t[USB_ENDPOINT_XFER_BULK]\t= \"BULK\",\n\t[USB_ENDPOINT_XFER_INT]\t\t= \"INT\",\n\t[USB_ENDPOINT_XFER_ISOC]\t= \"ISO\",\n};\n\nchar *usbhs_pipe_name(struct usbhs_pipe *pipe)\n{\n\treturn usbhsp_pipe_name[usbhs_pipe_type(pipe)];\n}\n\nstatic struct renesas_usbhs_driver_pipe_config\n*usbhsp_get_pipe_config(struct usbhs_priv *priv, int pipe_num)\n{\n\tstruct renesas_usbhs_driver_pipe_config *pipe_configs =\n\t\t\t\t\tusbhs_get_dparam(priv, pipe_configs);\n\n\treturn &pipe_configs[pipe_num];\n}\n\n \nstatic void usbhsp_pipectrl_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tint offset = usbhsp_addr_offset(pipe);\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\tusbhs_bset(priv, DCPCTR, mask, val);\n\telse\n\t\tusbhs_bset(priv, PIPEnCTR + offset, mask, val);\n}\n\nstatic u16 usbhsp_pipectrl_get(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tint offset = usbhsp_addr_offset(pipe);\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn usbhs_read(priv, DCPCTR);\n\telse\n\t\treturn usbhs_read(priv, PIPEnCTR + offset);\n}\n\n \nstatic void __usbhsp_pipe_xxx_set(struct usbhs_pipe *pipe,\n\t\t\t\t  u16 dcp_reg, u16 pipe_reg,\n\t\t\t\t  u16 mask, u16 val)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\tusbhs_bset(priv, dcp_reg, mask, val);\n\telse\n\t\tusbhs_bset(priv, pipe_reg, mask, val);\n}\n\nstatic u16 __usbhsp_pipe_xxx_get(struct usbhs_pipe *pipe,\n\t\t\t\t u16 dcp_reg, u16 pipe_reg)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn usbhs_read(priv, dcp_reg);\n\telse\n\t\treturn usbhs_read(priv, pipe_reg);\n}\n\n \nstatic void usbhsp_pipe_cfg_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\t__usbhsp_pipe_xxx_set(pipe, DCPCFG, PIPECFG, mask, val);\n}\n\nstatic u16 usbhsp_pipe_cfg_get(struct usbhs_pipe *pipe)\n{\n\treturn __usbhsp_pipe_xxx_get(pipe, DCPCFG, PIPECFG);\n}\n\n \nstatic void usbhsp_pipe_trn_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint num = usbhs_pipe_number(pipe);\n\tu16 reg;\n\n\t \n#define CASE_PIPExTRN(a)\t\t\\\n\tcase 0x ## a:\t\t\t\\\n\t\treg = PIPE ## a ## TRN;\t\\\n\t\tbreak;\n\n\tswitch (num) {\n\tCASE_PIPExTRN(1);\n\tCASE_PIPExTRN(2);\n\tCASE_PIPExTRN(3);\n\tCASE_PIPExTRN(4);\n\tCASE_PIPExTRN(5);\n\tCASE_PIPExTRN(B);\n\tCASE_PIPExTRN(C);\n\tCASE_PIPExTRN(D);\n\tCASE_PIPExTRN(E);\n\tCASE_PIPExTRN(F);\n\tCASE_PIPExTRN(9);\n\tCASE_PIPExTRN(A);\n\tdefault:\n\t\tdev_err(dev, \"unknown pipe (%d)\\n\", num);\n\t\treturn;\n\t}\n\t__usbhsp_pipe_xxx_set(pipe, 0, reg, mask, val);\n}\n\nstatic void usbhsp_pipe_tre_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint num = usbhs_pipe_number(pipe);\n\tu16 reg;\n\n\t \n#define CASE_PIPExTRE(a)\t\t\t\\\n\tcase 0x ## a:\t\t\t\t\\\n\t\treg = PIPE ## a ## TRE;\t\t\\\n\t\tbreak;\n\n\tswitch (num) {\n\tCASE_PIPExTRE(1);\n\tCASE_PIPExTRE(2);\n\tCASE_PIPExTRE(3);\n\tCASE_PIPExTRE(4);\n\tCASE_PIPExTRE(5);\n\tCASE_PIPExTRE(B);\n\tCASE_PIPExTRE(C);\n\tCASE_PIPExTRE(D);\n\tCASE_PIPExTRE(E);\n\tCASE_PIPExTRE(F);\n\tCASE_PIPExTRE(9);\n\tCASE_PIPExTRE(A);\n\tdefault:\n\t\tdev_err(dev, \"unknown pipe (%d)\\n\", num);\n\t\treturn;\n\t}\n\n\t__usbhsp_pipe_xxx_set(pipe, 0, reg, mask, val);\n}\n\n \nstatic void usbhsp_pipe_buf_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn;\n\n\t__usbhsp_pipe_xxx_set(pipe, 0, PIPEBUF, mask, val);\n}\n\n \nstatic void usbhsp_pipe_maxp_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\n{\n\t__usbhsp_pipe_xxx_set(pipe, DCPMAXP, PIPEMAXP, mask, val);\n}\n\n \nstatic void usbhsp_pipe_select(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\t \n\n\t \n\tusbhs_write(priv, PIPESEL, 0xF & usbhs_pipe_number(pipe));\n}\n\nstatic int usbhsp_pipe_barrier(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tint timeout = 1024;\n\tu16 mask = usbhs_mod_is_host(priv) ? (CSSTS | PID_MASK) : PID_MASK;\n\n\t \n\n\t \n\tusbhs_write(priv, CFIFOSEL, 0);\n\tusbhs_pipe_disable(pipe);\n\n\tdo {\n\t\tif (!(usbhsp_pipectrl_get(pipe) & mask))\n\t\t\treturn 0;\n\n\t\tudelay(10);\n\n\t} while (timeout--);\n\n\treturn -EBUSY;\n}\n\nint usbhs_pipe_is_accessible(struct usbhs_pipe *pipe)\n{\n\tu16 val;\n\n\tval = usbhsp_pipectrl_get(pipe);\n\tif (val & BSTS)\n\t\treturn 0;\n\n\treturn -EBUSY;\n}\n\nbool usbhs_pipe_contains_transmittable_data(struct usbhs_pipe *pipe)\n{\n\tu16 val;\n\n\t \n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn false;\n\n\tval = usbhsp_pipectrl_get(pipe);\n\tif (val & INBUFM)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void __usbhsp_pid_try_nak_if_stall(struct usbhs_pipe *pipe)\n{\n\tu16 pid = usbhsp_pipectrl_get(pipe);\n\n\tpid &= PID_MASK;\n\n\t \n\tswitch (pid) {\n\tcase PID_STALL11:\n\t\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL10);\n\t\tfallthrough;\n\tcase PID_STALL10:\n\t\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_NAK);\n\t}\n}\n\nvoid usbhs_pipe_disable(struct usbhs_pipe *pipe)\n{\n\tint timeout = 1024;\n\tu16 val;\n\n\t \n\t__usbhsp_pid_try_nak_if_stall(pipe);\n\n\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_NAK);\n\n\tdo {\n\t\tval  = usbhsp_pipectrl_get(pipe);\n\t\tval &= PBUSY;\n\t\tif (!val)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t} while (timeout--);\n}\n\nvoid usbhs_pipe_enable(struct usbhs_pipe *pipe)\n{\n\t \n\t__usbhsp_pid_try_nak_if_stall(pipe);\n\n\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_BUF);\n}\n\nvoid usbhs_pipe_stall(struct usbhs_pipe *pipe)\n{\n\tu16 pid = usbhsp_pipectrl_get(pipe);\n\n\tpid &= PID_MASK;\n\n\t \n\tswitch (pid) {\n\tcase PID_NAK:\n\t\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL10);\n\t\tbreak;\n\tcase PID_BUF:\n\t\tusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL11);\n\t\tbreak;\n\t}\n}\n\nint usbhs_pipe_is_stall(struct usbhs_pipe *pipe)\n{\n\tu16 pid = usbhsp_pipectrl_get(pipe) & PID_MASK;\n\n\treturn (int)(pid == PID_STALL10 || pid == PID_STALL11);\n}\n\nvoid usbhs_pipe_set_trans_count_if_bulk(struct usbhs_pipe *pipe, int len)\n{\n\tif (!usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\n\t\treturn;\n\n\t \n\tusbhsp_pipe_tre_set(pipe, TRCLR | TRENB, TRCLR);\n\n\t \n\tif (usbhs_pipe_is_dir_in(pipe)) {\n\t\tint maxp = usbhs_pipe_get_maxpacket(pipe);\n\n\t\tusbhsp_pipe_trn_set(pipe, 0xffff, DIV_ROUND_UP(len, maxp));\n\t\tusbhsp_pipe_tre_set(pipe, TRENB, TRENB);  \n\t}\n}\n\n\n \nstatic int usbhsp_setup_pipecfg(struct usbhs_pipe *pipe, int is_host,\n\t\t\t\tint dir_in, u16 *pipecfg)\n{\n\tu16 type = 0;\n\tu16 bfre = 0;\n\tu16 dblb = 0;\n\tu16 cntmd = 0;\n\tu16 dir = 0;\n\tu16 epnum = 0;\n\tu16 shtnak = 0;\n\tstatic const u16 type_array[] = {\n\t\t[USB_ENDPOINT_XFER_BULK] = TYPE_BULK,\n\t\t[USB_ENDPOINT_XFER_INT]  = TYPE_INT,\n\t\t[USB_ENDPOINT_XFER_ISOC] = TYPE_ISO,\n\t};\n\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn -EINVAL;\n\n\t \n\n\t \n\ttype = type_array[usbhs_pipe_type(pipe)];\n\n\t \n\tif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC) ||\n\t    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\n\t\tbfre = 0;  \n\n\t \n\n\t \n\tif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\n\t\tcntmd = 0;  \n\n\t \n\tif (dir_in)\n\t\tusbhsp_flags_set(pipe, IS_DIR_HOST);\n\n\tif (!!is_host ^ !!dir_in)\n\t\tdir |= DIR_OUT;\n\n\tif (!dir)\n\t\tusbhsp_flags_set(pipe, IS_DIR_IN);\n\n\t \n\tif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK) &&\n\t    !dir)\n\t\tshtnak = SHTNAK;\n\n\t \n\tepnum = 0;  \n\t*pipecfg = type\t\t|\n\t\t   bfre\t\t|\n\t\t   dblb\t\t|\n\t\t   cntmd\t|\n\t\t   dir\t\t|\n\t\t   shtnak\t|\n\t\t   epnum;\n\treturn 0;\n}\n\nstatic u16 usbhsp_setup_pipebuff(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tint pipe_num = usbhs_pipe_number(pipe);\n\tu16 buff_size;\n\tu16 bufnmb;\n\tu16 bufnmb_cnt;\n\tstruct renesas_usbhs_driver_pipe_config *pipe_config =\n\t\t\t\t\tusbhsp_get_pipe_config(priv, pipe_num);\n\n\t \n\tbuff_size = pipe_config->bufsize;\n\tbufnmb = pipe_config->bufnum;\n\n\t \n\tbufnmb_cnt = (buff_size / 64) - 1;\n\n\tdev_dbg(dev, \"pipe : %d : buff_size 0x%x: bufnmb 0x%x\\n\",\n\t\tpipe_num, buff_size, bufnmb);\n\n\treturn\t(0x1f & bufnmb_cnt)\t<< 10 |\n\t\t(0xff & bufnmb)\t\t<<  0;\n}\n\nvoid usbhs_pipe_config_update(struct usbhs_pipe *pipe, u16 devsel,\n\t\t\t      u16 epnum, u16 maxp)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\tint pipe_num = usbhs_pipe_number(pipe);\n\tstruct renesas_usbhs_driver_pipe_config *pipe_config =\n\t\t\t\t\tusbhsp_get_pipe_config(priv, pipe_num);\n\tu16 dblb = pipe_config->double_buf ? DBLB : 0;\n\n\tif (devsel > 0xA) {\n\t\tstruct device *dev = usbhs_priv_to_dev(priv);\n\n\t\tdev_err(dev, \"devsel error %d\\n\", devsel);\n\n\t\tdevsel = 0;\n\t}\n\n\tusbhsp_pipe_barrier(pipe);\n\n\tpipe->maxp = maxp;\n\n\tusbhsp_pipe_select(pipe);\n\tusbhsp_pipe_maxp_set(pipe, 0xFFFF,\n\t\t\t     (devsel << 12) |\n\t\t\t     maxp);\n\n\tif (!usbhs_pipe_is_dcp(pipe))\n\t\tusbhsp_pipe_cfg_set(pipe,  0x000F | DBLB, epnum | dblb);\n}\n\n \nint usbhs_pipe_get_maxpacket(struct usbhs_pipe *pipe)\n{\n\t \n\treturn pipe->maxp;\n}\n\nint usbhs_pipe_is_dir_in(struct usbhs_pipe *pipe)\n{\n\treturn usbhsp_flags_has(pipe, IS_DIR_IN);\n}\n\nint usbhs_pipe_is_dir_host(struct usbhs_pipe *pipe)\n{\n\treturn usbhsp_flags_has(pipe, IS_DIR_HOST);\n}\n\nint usbhs_pipe_is_running(struct usbhs_pipe *pipe)\n{\n\treturn usbhsp_flags_has(pipe, IS_RUNNING);\n}\n\nvoid usbhs_pipe_running(struct usbhs_pipe *pipe, int running)\n{\n\tif (running)\n\t\tusbhsp_flags_set(pipe, IS_RUNNING);\n\telse\n\t\tusbhsp_flags_clr(pipe, IS_RUNNING);\n}\n\nvoid usbhs_pipe_data_sequence(struct usbhs_pipe *pipe, int sequence)\n{\n\tu16 mask = (SQCLR | SQSET);\n\tu16 val;\n\n\t \n\tswitch (sequence) {\n\tcase 0:\n\t\tval = SQCLR;\n\t\tbreak;\n\tcase 1:\n\t\tval = SQSET;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tusbhsp_pipectrl_set(pipe, mask, val);\n}\n\nstatic int usbhs_pipe_get_data_sequence(struct usbhs_pipe *pipe)\n{\n\treturn !!(usbhsp_pipectrl_get(pipe) & SQMON);\n}\n\nvoid usbhs_pipe_clear(struct usbhs_pipe *pipe)\n{\n\tif (usbhs_pipe_is_dcp(pipe)) {\n\t\tusbhs_fifo_clear_dcp(pipe);\n\t} else {\n\t\tusbhsp_pipectrl_set(pipe, ACLRM, ACLRM);\n\t\tusbhsp_pipectrl_set(pipe, ACLRM, 0);\n\t}\n}\n\n \nvoid usbhs_pipe_clear_without_sequence(struct usbhs_pipe *pipe,\n\t\t\t\t       int needs_bfre, int bfre_enable)\n{\n\tint sequence;\n\n\tusbhsp_pipe_select(pipe);\n\tsequence = usbhs_pipe_get_data_sequence(pipe);\n\tif (needs_bfre)\n\t\tusbhsp_pipe_cfg_set(pipe, BFRE, bfre_enable ? BFRE : 0);\n\tusbhs_pipe_clear(pipe);\n\tusbhs_pipe_data_sequence(pipe, sequence);\n}\n\nvoid usbhs_pipe_config_change_bfre(struct usbhs_pipe *pipe, int enable)\n{\n\tif (usbhs_pipe_is_dcp(pipe))\n\t\treturn;\n\n\tusbhsp_pipe_select(pipe);\n\t \n\tif (!(enable ^ !!(usbhsp_pipe_cfg_get(pipe) & BFRE)))\n\t\treturn;\n\n\tusbhs_pipe_clear_without_sequence(pipe, 1, enable);\n}\n\nstatic struct usbhs_pipe *usbhsp_get_pipe(struct usbhs_priv *priv, u32 type)\n{\n\tstruct usbhs_pipe *pos, *pipe;\n\tint i;\n\n\t \n\tpipe = NULL;\n\tusbhs_for_each_pipe_with_dcp(pos, priv, i) {\n\t\tif (!usbhs_pipe_type_is(pos, type))\n\t\t\tcontinue;\n\t\tif (usbhsp_flags_has(pos, IS_USED))\n\t\t\tcontinue;\n\n\t\tpipe = pos;\n\t\tbreak;\n\t}\n\n\tif (!pipe)\n\t\treturn NULL;\n\n\t \n\tusbhsp_flags_init(pipe);\n\tusbhsp_flags_set(pipe, IS_USED);\n\n\treturn pipe;\n}\n\nstatic void usbhsp_put_pipe(struct usbhs_pipe *pipe)\n{\n\tusbhsp_flags_init(pipe);\n}\n\nvoid usbhs_pipe_init(struct usbhs_priv *priv,\n\t\t     int (*dma_map_ctrl)(struct device *dma_dev,\n\t\t\t\t\t struct usbhs_pkt *pkt, int map))\n{\n\tstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\n\tstruct usbhs_pipe *pipe;\n\tint i;\n\n\tusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\n\t\tusbhsp_flags_init(pipe);\n\t\tpipe->fifo = NULL;\n\t\tpipe->mod_private = NULL;\n\t\tINIT_LIST_HEAD(&pipe->list);\n\n\t\t \n\t\tusbhs_pipe_clear(pipe);\n\t}\n\n\tinfo->dma_map_ctrl = dma_map_ctrl;\n}\n\nstruct usbhs_pipe *usbhs_pipe_malloc(struct usbhs_priv *priv,\n\t\t\t\t     int endpoint_type,\n\t\t\t\t     int dir_in)\n{\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct usbhs_pipe *pipe;\n\tint is_host = usbhs_mod_is_host(priv);\n\tint ret;\n\tu16 pipecfg, pipebuf;\n\n\tpipe = usbhsp_get_pipe(priv, endpoint_type);\n\tif (!pipe) {\n\t\tdev_err(dev, \"can't get pipe (%s)\\n\",\n\t\t\tusbhsp_pipe_name[endpoint_type]);\n\t\treturn NULL;\n\t}\n\n\tINIT_LIST_HEAD(&pipe->list);\n\n\tusbhs_pipe_disable(pipe);\n\n\t \n\tret = usbhsp_pipe_barrier(pipe);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"pipe setup failed %d\\n\", usbhs_pipe_number(pipe));\n\t\treturn NULL;\n\t}\n\n\tif (usbhsp_setup_pipecfg(pipe, is_host, dir_in, &pipecfg)) {\n\t\tdev_err(dev, \"can't setup pipe\\n\");\n\t\treturn NULL;\n\t}\n\n\tpipebuf  = usbhsp_setup_pipebuff(pipe);\n\n\tusbhsp_pipe_select(pipe);\n\tusbhsp_pipe_cfg_set(pipe, 0xFFFF, pipecfg);\n\tusbhsp_pipe_buf_set(pipe, 0xFFFF, pipebuf);\n\tusbhs_pipe_clear(pipe);\n\n\tusbhs_pipe_sequence_data0(pipe);\n\n\tdev_dbg(dev, \"enable pipe %d : %s (%s)\\n\",\n\t\tusbhs_pipe_number(pipe),\n\t\tusbhs_pipe_name(pipe),\n\t\tusbhs_pipe_is_dir_in(pipe) ? \"in\" : \"out\");\n\n\t \n\n\treturn pipe;\n}\n\nvoid usbhs_pipe_free(struct usbhs_pipe *pipe)\n{\n\tusbhsp_pipe_select(pipe);\n\tusbhsp_pipe_cfg_set(pipe, 0xFFFF, 0);\n\tusbhsp_put_pipe(pipe);\n}\n\nvoid usbhs_pipe_select_fifo(struct usbhs_pipe *pipe, struct usbhs_fifo *fifo)\n{\n\tif (pipe->fifo)\n\t\tpipe->fifo->pipe = NULL;\n\n\tpipe->fifo = fifo;\n\n\tif (fifo)\n\t\tfifo->pipe = pipe;\n}\n\n\n \nstruct usbhs_pipe *usbhs_dcp_malloc(struct usbhs_priv *priv)\n{\n\tstruct usbhs_pipe *pipe;\n\n\tpipe = usbhsp_get_pipe(priv, USB_ENDPOINT_XFER_CONTROL);\n\tif (!pipe)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&pipe->list);\n\n\t \n\n\treturn pipe;\n}\n\nvoid usbhs_dcp_control_transfer_done(struct usbhs_pipe *pipe)\n{\n\tstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\n\n\tWARN_ON(!usbhs_pipe_is_dcp(pipe));\n\n\tusbhs_pipe_enable(pipe);\n\n\tif (!usbhs_mod_is_host(priv))  \n\t\tusbhsp_pipectrl_set(pipe, CCPL, CCPL);\n}\n\nvoid usbhs_dcp_dir_for_host(struct usbhs_pipe *pipe, int dir_out)\n{\n\tusbhsp_pipe_cfg_set(pipe, DIR_OUT,\n\t\t\t    dir_out ? DIR_OUT : 0);\n}\n\n \nint usbhs_pipe_probe(struct usbhs_priv *priv)\n{\n\tstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\n\tstruct usbhs_pipe *pipe;\n\tstruct device *dev = usbhs_priv_to_dev(priv);\n\tstruct renesas_usbhs_driver_pipe_config *pipe_configs =\n\t\t\t\t\tusbhs_get_dparam(priv, pipe_configs);\n\tint pipe_size = usbhs_get_dparam(priv, pipe_size);\n\tint i;\n\n\t \n\tif (pipe_configs[0].type != USB_ENDPOINT_XFER_CONTROL) {\n\t\tdev_err(dev, \"1st PIPE is not DCP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinfo->pipe = kcalloc(pipe_size, sizeof(struct usbhs_pipe),\n\t\t\t     GFP_KERNEL);\n\tif (!info->pipe)\n\t\treturn -ENOMEM;\n\n\tinfo->size = pipe_size;\n\n\t \n\tusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\n\t\tpipe->priv = priv;\n\n\t\tusbhs_pipe_type(pipe) =\n\t\t\tpipe_configs[i].type & USB_ENDPOINT_XFERTYPE_MASK;\n\n\t\tdev_dbg(dev, \"pipe %x\\t: %s\\n\",\n\t\t\ti, usbhsp_pipe_name[pipe_configs[i].type]);\n\t}\n\n\treturn 0;\n}\n\nvoid usbhs_pipe_remove(struct usbhs_priv *priv)\n{\n\tstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\n\n\tkfree(info->pipe);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}