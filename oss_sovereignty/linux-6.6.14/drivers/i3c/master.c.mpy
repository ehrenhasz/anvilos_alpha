{
  "module_name": "master.c",
  "hash_id": "a2c72981d4a3c9b245df9d35dbb0740e81268b94ffca1c3d9c07f03017e7cdf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include \"internals.h\"\n\nstatic DEFINE_IDR(i3c_bus_idr);\nstatic DEFINE_MUTEX(i3c_core_lock);\nstatic int __i3c_first_dynamic_bus_num;\n\n \nstatic void i3c_bus_maintenance_lock(struct i3c_bus *bus)\n{\n\tdown_write(&bus->lock);\n}\n\n \nstatic void i3c_bus_maintenance_unlock(struct i3c_bus *bus)\n{\n\tup_write(&bus->lock);\n}\n\n \nvoid i3c_bus_normaluse_lock(struct i3c_bus *bus)\n{\n\tdown_read(&bus->lock);\n}\n\n \nvoid i3c_bus_normaluse_unlock(struct i3c_bus *bus)\n{\n\tup_read(&bus->lock);\n}\n\nstatic struct i3c_master_controller *\ni3c_bus_to_i3c_master(struct i3c_bus *i3cbus)\n{\n\treturn container_of(i3cbus, struct i3c_master_controller, bus);\n}\n\nstatic struct i3c_master_controller *dev_to_i3cmaster(struct device *dev)\n{\n\treturn container_of(dev, struct i3c_master_controller, dev);\n}\n\nstatic const struct device_type i3c_device_type;\n\nstatic struct i3c_bus *dev_to_i3cbus(struct device *dev)\n{\n\tstruct i3c_master_controller *master;\n\n\tif (dev->type == &i3c_device_type)\n\t\treturn dev_to_i3cdev(dev)->bus;\n\n\tmaster = dev_to_i3cmaster(dev);\n\n\treturn &master->bus;\n}\n\nstatic struct i3c_dev_desc *dev_to_i3cdesc(struct device *dev)\n{\n\tstruct i3c_master_controller *master;\n\n\tif (dev->type == &i3c_device_type)\n\t\treturn dev_to_i3cdev(dev)->desc;\n\n\tmaster = dev_to_i3cmaster(dev);\n\n\treturn master->this;\n}\n\nstatic ssize_t bcr_show(struct device *dev,\n\t\t\tstruct device_attribute *da,\n\t\t\tchar *buf)\n{\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\tstruct i3c_dev_desc *desc;\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(bus);\n\tdesc = dev_to_i3cdesc(dev);\n\tret = sprintf(buf, \"%x\\n\", desc->info.bcr);\n\ti3c_bus_normaluse_unlock(bus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(bcr);\n\nstatic ssize_t dcr_show(struct device *dev,\n\t\t\tstruct device_attribute *da,\n\t\t\tchar *buf)\n{\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\tstruct i3c_dev_desc *desc;\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(bus);\n\tdesc = dev_to_i3cdesc(dev);\n\tret = sprintf(buf, \"%x\\n\", desc->info.dcr);\n\ti3c_bus_normaluse_unlock(bus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(dcr);\n\nstatic ssize_t pid_show(struct device *dev,\n\t\t\tstruct device_attribute *da,\n\t\t\tchar *buf)\n{\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\tstruct i3c_dev_desc *desc;\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(bus);\n\tdesc = dev_to_i3cdesc(dev);\n\tret = sprintf(buf, \"%llx\\n\", desc->info.pid);\n\ti3c_bus_normaluse_unlock(bus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(pid);\n\nstatic ssize_t dynamic_address_show(struct device *dev,\n\t\t\t\t    struct device_attribute *da,\n\t\t\t\t    char *buf)\n{\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\tstruct i3c_dev_desc *desc;\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(bus);\n\tdesc = dev_to_i3cdesc(dev);\n\tret = sprintf(buf, \"%02x\\n\", desc->info.dyn_addr);\n\ti3c_bus_normaluse_unlock(bus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(dynamic_address);\n\nstatic const char * const hdrcap_strings[] = {\n\t\"hdr-ddr\", \"hdr-tsp\", \"hdr-tsl\",\n};\n\nstatic ssize_t hdrcap_show(struct device *dev,\n\t\t\t   struct device_attribute *da,\n\t\t\t   char *buf)\n{\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\tstruct i3c_dev_desc *desc;\n\tssize_t offset = 0, ret;\n\tunsigned long caps;\n\tint mode;\n\n\ti3c_bus_normaluse_lock(bus);\n\tdesc = dev_to_i3cdesc(dev);\n\tcaps = desc->info.hdr_cap;\n\tfor_each_set_bit(mode, &caps, 8) {\n\t\tif (mode >= ARRAY_SIZE(hdrcap_strings))\n\t\t\tbreak;\n\n\t\tif (!hdrcap_strings[mode])\n\t\t\tcontinue;\n\n\t\tret = sprintf(buf + offset, offset ? \" %s\" : \"%s\",\n\t\t\t      hdrcap_strings[mode]);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\toffset += ret;\n\t}\n\n\tret = sprintf(buf + offset, \"\\n\");\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = offset + ret;\n\nout:\n\ti3c_bus_normaluse_unlock(bus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(hdrcap);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *da, char *buf)\n{\n\tstruct i3c_device *i3c = dev_to_i3cdev(dev);\n\tstruct i3c_device_info devinfo;\n\tu16 manuf, part, ext;\n\n\ti3c_device_get_info(i3c, &devinfo);\n\tmanuf = I3C_PID_MANUF_ID(devinfo.pid);\n\tpart = I3C_PID_PART_ID(devinfo.pid);\n\text = I3C_PID_EXTRA_INFO(devinfo.pid);\n\n\tif (I3C_PID_RND_LOWER_32BITS(devinfo.pid))\n\t\treturn sprintf(buf, \"i3c:dcr%02Xmanuf%04X\", devinfo.dcr,\n\t\t\t       manuf);\n\n\treturn sprintf(buf, \"i3c:dcr%02Xmanuf%04Xpart%04Xext%04X\",\n\t\t       devinfo.dcr, manuf, part, ext);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *i3c_device_attrs[] = {\n\t&dev_attr_bcr.attr,\n\t&dev_attr_dcr.attr,\n\t&dev_attr_pid.attr,\n\t&dev_attr_dynamic_address.attr,\n\t&dev_attr_hdrcap.attr,\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(i3c_device);\n\nstatic int i3c_device_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct i3c_device *i3cdev = dev_to_i3cdev(dev);\n\tstruct i3c_device_info devinfo;\n\tu16 manuf, part, ext;\n\n\ti3c_device_get_info(i3cdev, &devinfo);\n\tmanuf = I3C_PID_MANUF_ID(devinfo.pid);\n\tpart = I3C_PID_PART_ID(devinfo.pid);\n\text = I3C_PID_EXTRA_INFO(devinfo.pid);\n\n\tif (I3C_PID_RND_LOWER_32BITS(devinfo.pid))\n\t\treturn add_uevent_var(env, \"MODALIAS=i3c:dcr%02Xmanuf%04X\",\n\t\t\t\t      devinfo.dcr, manuf);\n\n\treturn add_uevent_var(env,\n\t\t\t      \"MODALIAS=i3c:dcr%02Xmanuf%04Xpart%04Xext%04X\",\n\t\t\t      devinfo.dcr, manuf, part, ext);\n}\n\nstatic const struct device_type i3c_device_type = {\n\t.groups\t= i3c_device_groups,\n\t.uevent = i3c_device_uevent,\n};\n\nstatic int i3c_device_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct i3c_device *i3cdev;\n\tstruct i3c_driver *i3cdrv;\n\n\tif (dev->type != &i3c_device_type)\n\t\treturn 0;\n\n\ti3cdev = dev_to_i3cdev(dev);\n\ti3cdrv = drv_to_i3cdrv(drv);\n\tif (i3c_device_match_id(i3cdev, i3cdrv->id_table))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int i3c_device_probe(struct device *dev)\n{\n\tstruct i3c_device *i3cdev = dev_to_i3cdev(dev);\n\tstruct i3c_driver *driver = drv_to_i3cdrv(dev->driver);\n\n\treturn driver->probe(i3cdev);\n}\n\nstatic void i3c_device_remove(struct device *dev)\n{\n\tstruct i3c_device *i3cdev = dev_to_i3cdev(dev);\n\tstruct i3c_driver *driver = drv_to_i3cdrv(dev->driver);\n\n\tif (driver->remove)\n\t\tdriver->remove(i3cdev);\n\n\ti3c_device_free_ibi(i3cdev);\n}\n\nstruct bus_type i3c_bus_type = {\n\t.name = \"i3c\",\n\t.match = i3c_device_match,\n\t.probe = i3c_device_probe,\n\t.remove = i3c_device_remove,\n};\n\nstatic enum i3c_addr_slot_status\ni3c_bus_get_addr_slot_status(struct i3c_bus *bus, u16 addr)\n{\n\tunsigned long status;\n\tint bitpos = addr * 2;\n\n\tif (addr > I2C_MAX_ADDR)\n\t\treturn I3C_ADDR_SLOT_RSVD;\n\n\tstatus = bus->addrslots[bitpos / BITS_PER_LONG];\n\tstatus >>= bitpos % BITS_PER_LONG;\n\n\treturn status & I3C_ADDR_SLOT_STATUS_MASK;\n}\n\nstatic void i3c_bus_set_addr_slot_status(struct i3c_bus *bus, u16 addr,\n\t\t\t\t\t enum i3c_addr_slot_status status)\n{\n\tint bitpos = addr * 2;\n\tunsigned long *ptr;\n\n\tif (addr > I2C_MAX_ADDR)\n\t\treturn;\n\n\tptr = bus->addrslots + (bitpos / BITS_PER_LONG);\n\t*ptr &= ~((unsigned long)I3C_ADDR_SLOT_STATUS_MASK <<\n\t\t\t\t\t\t(bitpos % BITS_PER_LONG));\n\t*ptr |= (unsigned long)status << (bitpos % BITS_PER_LONG);\n}\n\nstatic bool i3c_bus_dev_addr_is_avail(struct i3c_bus *bus, u8 addr)\n{\n\tenum i3c_addr_slot_status status;\n\n\tstatus = i3c_bus_get_addr_slot_status(bus, addr);\n\n\treturn status == I3C_ADDR_SLOT_FREE;\n}\n\nstatic int i3c_bus_get_free_addr(struct i3c_bus *bus, u8 start_addr)\n{\n\tenum i3c_addr_slot_status status;\n\tu8 addr;\n\n\tfor (addr = start_addr; addr < I3C_MAX_ADDR; addr++) {\n\t\tstatus = i3c_bus_get_addr_slot_status(bus, addr);\n\t\tif (status == I3C_ADDR_SLOT_FREE)\n\t\t\treturn addr;\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic void i3c_bus_init_addrslots(struct i3c_bus *bus)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < 8; i++)\n\t\ti3c_bus_set_addr_slot_status(bus, i, I3C_ADDR_SLOT_RSVD);\n\n\t \n\ti3c_bus_set_addr_slot_status(bus, I3C_BROADCAST_ADDR,\n\t\t\t\t     I3C_ADDR_SLOT_RSVD);\n\tfor (i = 0; i < 7; i++)\n\t\ti3c_bus_set_addr_slot_status(bus, I3C_BROADCAST_ADDR ^ BIT(i),\n\t\t\t\t\t     I3C_ADDR_SLOT_RSVD);\n}\n\nstatic void i3c_bus_cleanup(struct i3c_bus *i3cbus)\n{\n\tmutex_lock(&i3c_core_lock);\n\tidr_remove(&i3c_bus_idr, i3cbus->id);\n\tmutex_unlock(&i3c_core_lock);\n}\n\nstatic int i3c_bus_init(struct i3c_bus *i3cbus, struct device_node *np)\n{\n\tint ret, start, end, id = -1;\n\n\tinit_rwsem(&i3cbus->lock);\n\tINIT_LIST_HEAD(&i3cbus->devs.i2c);\n\tINIT_LIST_HEAD(&i3cbus->devs.i3c);\n\ti3c_bus_init_addrslots(i3cbus);\n\ti3cbus->mode = I3C_BUS_MODE_PURE;\n\n\tif (np)\n\t\tid = of_alias_get_id(np, \"i3c\");\n\n\tmutex_lock(&i3c_core_lock);\n\tif (id >= 0) {\n\t\tstart = id;\n\t\tend = start + 1;\n\t} else {\n\t\tstart = __i3c_first_dynamic_bus_num;\n\t\tend = 0;\n\t}\n\n\tret = idr_alloc(&i3c_bus_idr, i3cbus, start, end, GFP_KERNEL);\n\tmutex_unlock(&i3c_core_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\ti3cbus->id = ret;\n\n\treturn 0;\n}\n\nstatic const char * const i3c_bus_mode_strings[] = {\n\t[I3C_BUS_MODE_PURE] = \"pure\",\n\t[I3C_BUS_MODE_MIXED_FAST] = \"mixed-fast\",\n\t[I3C_BUS_MODE_MIXED_LIMITED] = \"mixed-limited\",\n\t[I3C_BUS_MODE_MIXED_SLOW] = \"mixed-slow\",\n};\n\nstatic ssize_t mode_show(struct device *dev,\n\t\t\t struct device_attribute *da,\n\t\t\t char *buf)\n{\n\tstruct i3c_bus *i3cbus = dev_to_i3cbus(dev);\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(i3cbus);\n\tif (i3cbus->mode < 0 ||\n\t    i3cbus->mode >= ARRAY_SIZE(i3c_bus_mode_strings) ||\n\t    !i3c_bus_mode_strings[i3cbus->mode])\n\t\tret = sprintf(buf, \"unknown\\n\");\n\telse\n\t\tret = sprintf(buf, \"%s\\n\", i3c_bus_mode_strings[i3cbus->mode]);\n\ti3c_bus_normaluse_unlock(i3cbus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(mode);\n\nstatic ssize_t current_master_show(struct device *dev,\n\t\t\t\t   struct device_attribute *da,\n\t\t\t\t   char *buf)\n{\n\tstruct i3c_bus *i3cbus = dev_to_i3cbus(dev);\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(i3cbus);\n\tret = sprintf(buf, \"%d-%llx\\n\", i3cbus->id,\n\t\t      i3cbus->cur_master->info.pid);\n\ti3c_bus_normaluse_unlock(i3cbus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(current_master);\n\nstatic ssize_t i3c_scl_frequency_show(struct device *dev,\n\t\t\t\t      struct device_attribute *da,\n\t\t\t\t      char *buf)\n{\n\tstruct i3c_bus *i3cbus = dev_to_i3cbus(dev);\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(i3cbus);\n\tret = sprintf(buf, \"%ld\\n\", i3cbus->scl_rate.i3c);\n\ti3c_bus_normaluse_unlock(i3cbus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(i3c_scl_frequency);\n\nstatic ssize_t i2c_scl_frequency_show(struct device *dev,\n\t\t\t\t      struct device_attribute *da,\n\t\t\t\t      char *buf)\n{\n\tstruct i3c_bus *i3cbus = dev_to_i3cbus(dev);\n\tssize_t ret;\n\n\ti3c_bus_normaluse_lock(i3cbus);\n\tret = sprintf(buf, \"%ld\\n\", i3cbus->scl_rate.i2c);\n\ti3c_bus_normaluse_unlock(i3cbus);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(i2c_scl_frequency);\n\nstatic struct attribute *i3c_masterdev_attrs[] = {\n\t&dev_attr_mode.attr,\n\t&dev_attr_current_master.attr,\n\t&dev_attr_i3c_scl_frequency.attr,\n\t&dev_attr_i2c_scl_frequency.attr,\n\t&dev_attr_bcr.attr,\n\t&dev_attr_dcr.attr,\n\t&dev_attr_pid.attr,\n\t&dev_attr_dynamic_address.attr,\n\t&dev_attr_hdrcap.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(i3c_masterdev);\n\nstatic void i3c_masterdev_release(struct device *dev)\n{\n\tstruct i3c_master_controller *master = dev_to_i3cmaster(dev);\n\tstruct i3c_bus *bus = dev_to_i3cbus(dev);\n\n\tif (master->wq)\n\t\tdestroy_workqueue(master->wq);\n\n\tWARN_ON(!list_empty(&bus->devs.i2c) || !list_empty(&bus->devs.i3c));\n\ti3c_bus_cleanup(bus);\n\n\tof_node_put(dev->of_node);\n}\n\nstatic const struct device_type i3c_masterdev_type = {\n\t.groups\t= i3c_masterdev_groups,\n};\n\nstatic int i3c_bus_set_mode(struct i3c_bus *i3cbus, enum i3c_bus_mode mode,\n\t\t\t    unsigned long max_i2c_scl_rate)\n{\n\tstruct i3c_master_controller *master = i3c_bus_to_i3c_master(i3cbus);\n\n\ti3cbus->mode = mode;\n\n\tswitch (i3cbus->mode) {\n\tcase I3C_BUS_MODE_PURE:\n\t\tif (!i3cbus->scl_rate.i3c)\n\t\t\ti3cbus->scl_rate.i3c = I3C_BUS_TYP_I3C_SCL_RATE;\n\t\tbreak;\n\tcase I3C_BUS_MODE_MIXED_FAST:\n\tcase I3C_BUS_MODE_MIXED_LIMITED:\n\t\tif (!i3cbus->scl_rate.i3c)\n\t\t\ti3cbus->scl_rate.i3c = I3C_BUS_TYP_I3C_SCL_RATE;\n\t\tif (!i3cbus->scl_rate.i2c)\n\t\t\ti3cbus->scl_rate.i2c = max_i2c_scl_rate;\n\t\tbreak;\n\tcase I3C_BUS_MODE_MIXED_SLOW:\n\t\tif (!i3cbus->scl_rate.i2c)\n\t\t\ti3cbus->scl_rate.i2c = max_i2c_scl_rate;\n\t\tif (!i3cbus->scl_rate.i3c ||\n\t\t    i3cbus->scl_rate.i3c > i3cbus->scl_rate.i2c)\n\t\t\ti3cbus->scl_rate.i3c = i3cbus->scl_rate.i2c;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(&master->dev, \"i2c-scl = %ld Hz i3c-scl = %ld Hz\\n\",\n\t\ti3cbus->scl_rate.i2c, i3cbus->scl_rate.i3c);\n\n\t \n\tif (i3cbus->scl_rate.i3c > I3C_BUS_MAX_I3C_SCL_RATE ||\n\t    i3cbus->scl_rate.i2c > I3C_BUS_I2C_FM_PLUS_SCL_RATE)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct i3c_master_controller *\ni2c_adapter_to_i3c_master(struct i2c_adapter *adap)\n{\n\treturn container_of(adap, struct i3c_master_controller, i2c);\n}\n\nstatic struct i2c_adapter *\ni3c_master_to_i2c_adapter(struct i3c_master_controller *master)\n{\n\treturn &master->i2c;\n}\n\nstatic void i3c_master_free_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tkfree(dev);\n}\n\nstatic struct i2c_dev_desc *\ni3c_master_alloc_i2c_dev(struct i3c_master_controller *master,\n\t\t\t u16 addr, u8 lvr)\n{\n\tstruct i2c_dev_desc *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->common.master = master;\n\tdev->addr = addr;\n\tdev->lvr = lvr;\n\n\treturn dev;\n}\n\nstatic void *i3c_ccc_cmd_dest_init(struct i3c_ccc_cmd_dest *dest, u8 addr,\n\t\t\t\t   u16 payloadlen)\n{\n\tdest->addr = addr;\n\tdest->payload.len = payloadlen;\n\tif (payloadlen)\n\t\tdest->payload.data = kzalloc(payloadlen, GFP_KERNEL);\n\telse\n\t\tdest->payload.data = NULL;\n\n\treturn dest->payload.data;\n}\n\nstatic void i3c_ccc_cmd_dest_cleanup(struct i3c_ccc_cmd_dest *dest)\n{\n\tkfree(dest->payload.data);\n}\n\nstatic void i3c_ccc_cmd_init(struct i3c_ccc_cmd *cmd, bool rnw, u8 id,\n\t\t\t     struct i3c_ccc_cmd_dest *dests,\n\t\t\t     unsigned int ndests)\n{\n\tcmd->rnw = rnw ? 1 : 0;\n\tcmd->id = id;\n\tcmd->dests = dests;\n\tcmd->ndests = ndests;\n\tcmd->err = I3C_ERROR_UNKNOWN;\n}\n\nstatic int i3c_master_send_ccc_cmd_locked(struct i3c_master_controller *master,\n\t\t\t\t\t  struct i3c_ccc_cmd *cmd)\n{\n\tint ret;\n\n\tif (!cmd || !master)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(master->init_done &&\n\t\t    !rwsem_is_locked(&master->bus.lock)))\n\t\treturn -EINVAL;\n\n\tif (!master->ops->send_ccc_cmd)\n\t\treturn -ENOTSUPP;\n\n\tif ((cmd->id & I3C_CCC_DIRECT) && (!cmd->dests || !cmd->ndests))\n\t\treturn -EINVAL;\n\n\tif (master->ops->supports_ccc_cmd &&\n\t    !master->ops->supports_ccc_cmd(master, cmd))\n\t\treturn -ENOTSUPP;\n\n\tret = master->ops->send_ccc_cmd(master, cmd);\n\tif (ret) {\n\t\tif (cmd->err != I3C_ERROR_UNKNOWN)\n\t\t\treturn cmd->err;\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic struct i2c_dev_desc *\ni3c_master_find_i2c_dev_by_addr(const struct i3c_master_controller *master,\n\t\t\t\tu16 addr)\n{\n\tstruct i2c_dev_desc *dev;\n\n\ti3c_bus_for_each_i2cdev(&master->bus, dev) {\n\t\tif (dev->addr == addr)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n \nint i3c_master_get_free_addr(struct i3c_master_controller *master,\n\t\t\t     u8 start_addr)\n{\n\treturn i3c_bus_get_free_addr(&master->bus, start_addr);\n}\nEXPORT_SYMBOL_GPL(i3c_master_get_free_addr);\n\nstatic void i3c_device_release(struct device *dev)\n{\n\tstruct i3c_device *i3cdev = dev_to_i3cdev(dev);\n\n\tWARN_ON(i3cdev->desc);\n\n\tof_node_put(i3cdev->dev.of_node);\n\tkfree(i3cdev);\n}\n\nstatic void i3c_master_free_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tkfree(dev);\n}\n\nstatic struct i3c_dev_desc *\ni3c_master_alloc_i3c_dev(struct i3c_master_controller *master,\n\t\t\t const struct i3c_device_info *info)\n{\n\tstruct i3c_dev_desc *dev;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev->common.master = master;\n\tdev->info = *info;\n\tmutex_init(&dev->ibi_lock);\n\n\treturn dev;\n}\n\nstatic int i3c_master_rstdaa_locked(struct i3c_master_controller *master,\n\t\t\t\t    u8 addr)\n{\n\tenum i3c_addr_slot_status addrstat;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tif (!master)\n\t\treturn -EINVAL;\n\n\taddrstat = i3c_bus_get_addr_slot_status(&master->bus, addr);\n\tif (addr != I3C_BROADCAST_ADDR && addrstat != I3C_ADDR_SLOT_I3C_DEV)\n\t\treturn -EINVAL;\n\n\ti3c_ccc_cmd_dest_init(&dest, addr, 0);\n\ti3c_ccc_cmd_init(&cmd, false,\n\t\t\t I3C_CCC_RSTDAA(addr == I3C_BROADCAST_ADDR),\n\t\t\t &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\n \nint i3c_master_entdaa_locked(struct i3c_master_controller *master)\n{\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\ti3c_ccc_cmd_dest_init(&dest, I3C_BROADCAST_ADDR, 0);\n\ti3c_ccc_cmd_init(&cmd, false, I3C_CCC_ENTDAA, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_master_entdaa_locked);\n\nstatic int i3c_master_enec_disec_locked(struct i3c_master_controller *master,\n\t\t\t\t\tu8 addr, bool enable, u8 evts)\n{\n\tstruct i3c_ccc_events *events;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tevents = i3c_ccc_cmd_dest_init(&dest, addr, sizeof(*events));\n\tif (!events)\n\t\treturn -ENOMEM;\n\n\tevents->events = evts;\n\ti3c_ccc_cmd_init(&cmd, false,\n\t\t\t enable ?\n\t\t\t I3C_CCC_ENEC(addr == I3C_BROADCAST_ADDR) :\n\t\t\t I3C_CCC_DISEC(addr == I3C_BROADCAST_ADDR),\n\t\t\t &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\n \nint i3c_master_disec_locked(struct i3c_master_controller *master, u8 addr,\n\t\t\t    u8 evts)\n{\n\treturn i3c_master_enec_disec_locked(master, addr, false, evts);\n}\nEXPORT_SYMBOL_GPL(i3c_master_disec_locked);\n\n \nint i3c_master_enec_locked(struct i3c_master_controller *master, u8 addr,\n\t\t\t   u8 evts)\n{\n\treturn i3c_master_enec_disec_locked(master, addr, true, evts);\n}\nEXPORT_SYMBOL_GPL(i3c_master_enec_locked);\n\n \nint i3c_master_defslvs_locked(struct i3c_master_controller *master)\n{\n\tstruct i3c_ccc_defslvs *defslvs;\n\tstruct i3c_ccc_dev_desc *desc;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_dev_desc *i3cdev;\n\tstruct i2c_dev_desc *i2cdev;\n\tstruct i3c_ccc_cmd cmd;\n\tstruct i3c_bus *bus;\n\tbool send = false;\n\tint ndevs = 0, ret;\n\n\tif (!master)\n\t\treturn -EINVAL;\n\n\tbus = i3c_master_get_bus(master);\n\ti3c_bus_for_each_i3cdev(bus, i3cdev) {\n\t\tndevs++;\n\n\t\tif (i3cdev == master->this)\n\t\t\tcontinue;\n\n\t\tif (I3C_BCR_DEVICE_ROLE(i3cdev->info.bcr) ==\n\t\t    I3C_BCR_I3C_MASTER)\n\t\t\tsend = true;\n\t}\n\n\t \n\tif (!send)\n\t\treturn 0;\n\n\ti3c_bus_for_each_i2cdev(bus, i2cdev)\n\t\tndevs++;\n\n\tdefslvs = i3c_ccc_cmd_dest_init(&dest, I3C_BROADCAST_ADDR,\n\t\t\t\t\tstruct_size(defslvs, slaves,\n\t\t\t\t\t\t    ndevs - 1));\n\tif (!defslvs)\n\t\treturn -ENOMEM;\n\n\tdefslvs->count = ndevs;\n\tdefslvs->master.bcr = master->this->info.bcr;\n\tdefslvs->master.dcr = master->this->info.dcr;\n\tdefslvs->master.dyn_addr = master->this->info.dyn_addr << 1;\n\tdefslvs->master.static_addr = I3C_BROADCAST_ADDR << 1;\n\n\tdesc = defslvs->slaves;\n\ti3c_bus_for_each_i2cdev(bus, i2cdev) {\n\t\tdesc->lvr = i2cdev->lvr;\n\t\tdesc->static_addr = i2cdev->addr << 1;\n\t\tdesc++;\n\t}\n\n\ti3c_bus_for_each_i3cdev(bus, i3cdev) {\n\t\t \n\t\tif (i3cdev == master->this)\n\t\t\tcontinue;\n\n\t\tdesc->bcr = i3cdev->info.bcr;\n\t\tdesc->dcr = i3cdev->info.dcr;\n\t\tdesc->dyn_addr = i3cdev->info.dyn_addr << 1;\n\t\tdesc->static_addr = i3cdev->info.static_addr << 1;\n\t\tdesc++;\n\t}\n\n\ti3c_ccc_cmd_init(&cmd, false, I3C_CCC_DEFSLVS, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_master_defslvs_locked);\n\nstatic int i3c_master_setda_locked(struct i3c_master_controller *master,\n\t\t\t\t   u8 oldaddr, u8 newaddr, bool setdasa)\n{\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_setda *setda;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tif (!oldaddr || !newaddr)\n\t\treturn -EINVAL;\n\n\tsetda = i3c_ccc_cmd_dest_init(&dest, oldaddr, sizeof(*setda));\n\tif (!setda)\n\t\treturn -ENOMEM;\n\n\tsetda->addr = newaddr << 1;\n\ti3c_ccc_cmd_init(&cmd, false,\n\t\t\t setdasa ? I3C_CCC_SETDASA : I3C_CCC_SETNEWDA,\n\t\t\t &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_setdasa_locked(struct i3c_master_controller *master,\n\t\t\t\t     u8 static_addr, u8 dyn_addr)\n{\n\treturn i3c_master_setda_locked(master, static_addr, dyn_addr, true);\n}\n\nstatic int i3c_master_setnewda_locked(struct i3c_master_controller *master,\n\t\t\t\t      u8 oldaddr, u8 newaddr)\n{\n\treturn i3c_master_setda_locked(master, oldaddr, newaddr, false);\n}\n\nstatic int i3c_master_getmrl_locked(struct i3c_master_controller *master,\n\t\t\t\t    struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_mrl *mrl;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tmrl = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*mrl));\n\tif (!mrl)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!(info->bcr & I3C_BCR_IBI_PAYLOAD))\n\t\tdest.payload.len -= 1;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMRL, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (dest.payload.len) {\n\tcase 3:\n\t\tinfo->max_ibi_len = mrl->ibi_len;\n\t\tfallthrough;\n\tcase 2:\n\t\tinfo->max_read_len = be16_to_cpu(mrl->read_len);\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_getmwl_locked(struct i3c_master_controller *master,\n\t\t\t\t    struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_mwl *mwl;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tmwl = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*mwl));\n\tif (!mwl)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMWL, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tif (dest.payload.len != sizeof(*mwl)) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tinfo->max_write_len = be16_to_cpu(mwl->len);\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_getmxds_locked(struct i3c_master_controller *master,\n\t\t\t\t     struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_getmxds *getmaxds;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tgetmaxds = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr,\n\t\t\t\t\t sizeof(*getmaxds));\n\tif (!getmaxds)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETMXDS, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tif (dest.payload.len != 2 && dest.payload.len != 5) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tinfo->max_read_ds = getmaxds->maxrd;\n\tinfo->max_write_ds = getmaxds->maxwr;\n\tif (dest.payload.len == 5)\n\t\tinfo->max_read_turnaround = getmaxds->maxrdturn[0] |\n\t\t\t\t\t    ((u32)getmaxds->maxrdturn[1] << 8) |\n\t\t\t\t\t    ((u32)getmaxds->maxrdturn[2] << 16);\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_gethdrcap_locked(struct i3c_master_controller *master,\n\t\t\t\t       struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_gethdrcap *gethdrcap;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tgethdrcap = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr,\n\t\t\t\t\t  sizeof(*gethdrcap));\n\tif (!gethdrcap)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETHDRCAP, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tif (dest.payload.len != 1) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tinfo->hdr_cap = gethdrcap->modes;\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_getpid_locked(struct i3c_master_controller *master,\n\t\t\t\t    struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_getpid *getpid;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret, i;\n\n\tgetpid = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*getpid));\n\tif (!getpid)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETPID, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tinfo->pid = 0;\n\tfor (i = 0; i < sizeof(getpid->pid); i++) {\n\t\tint sft = (sizeof(getpid->pid) - i - 1) * 8;\n\n\t\tinfo->pid |= (u64)getpid->pid[i] << sft;\n\t}\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_getbcr_locked(struct i3c_master_controller *master,\n\t\t\t\t    struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_getbcr *getbcr;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tgetbcr = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*getbcr));\n\tif (!getbcr)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETBCR, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tinfo->bcr = getbcr->bcr;\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_getdcr_locked(struct i3c_master_controller *master,\n\t\t\t\t    struct i3c_device_info *info)\n{\n\tstruct i3c_ccc_getdcr *getdcr;\n\tstruct i3c_ccc_cmd_dest dest;\n\tstruct i3c_ccc_cmd cmd;\n\tint ret;\n\n\tgetdcr = i3c_ccc_cmd_dest_init(&dest, info->dyn_addr, sizeof(*getdcr));\n\tif (!getdcr)\n\t\treturn -ENOMEM;\n\n\ti3c_ccc_cmd_init(&cmd, true, I3C_CCC_GETDCR, &dest, 1);\n\tret = i3c_master_send_ccc_cmd_locked(master, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tinfo->dcr = getdcr->dcr;\n\nout:\n\ti3c_ccc_cmd_dest_cleanup(&dest);\n\n\treturn ret;\n}\n\nstatic int i3c_master_retrieve_dev_info(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tenum i3c_addr_slot_status slot_status;\n\tint ret;\n\n\tif (!dev->info.dyn_addr)\n\t\treturn -EINVAL;\n\n\tslot_status = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t   dev->info.dyn_addr);\n\tif (slot_status == I3C_ADDR_SLOT_RSVD ||\n\t    slot_status == I3C_ADDR_SLOT_I2C_DEV)\n\t\treturn -EINVAL;\n\n\tret = i3c_master_getpid_locked(master, &dev->info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i3c_master_getbcr_locked(master, &dev->info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i3c_master_getdcr_locked(master, &dev->info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (dev->info.bcr & I3C_BCR_MAX_DATA_SPEED_LIM) {\n\t\tret = i3c_master_getmxds_locked(master, &dev->info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dev->info.bcr & I3C_BCR_IBI_PAYLOAD)\n\t\tdev->info.max_ibi_len = 1;\n\n\ti3c_master_getmrl_locked(master, &dev->info);\n\ti3c_master_getmwl_locked(master, &dev->info);\n\n\tif (dev->info.bcr & I3C_BCR_HDR_CAP) {\n\t\tret = i3c_master_gethdrcap_locked(master, &dev->info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void i3c_master_put_i3c_addrs(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\n\tif (dev->info.static_addr)\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     dev->info.static_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\n\tif (dev->info.dyn_addr)\n\t\ti3c_bus_set_addr_slot_status(&master->bus, dev->info.dyn_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\n\tif (dev->boardinfo && dev->boardinfo->init_dyn_addr)\n\t\ti3c_bus_set_addr_slot_status(&master->bus, dev->info.dyn_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n}\n\nstatic int i3c_master_get_i3c_addrs(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tenum i3c_addr_slot_status status;\n\n\tif (!dev->info.static_addr && !dev->info.dyn_addr)\n\t\treturn 0;\n\n\tif (dev->info.static_addr) {\n\t\tstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t      dev->info.static_addr);\n\t\t \n\t\tif (status != I3C_ADDR_SLOT_FREE &&\n\t\t    dev->info.static_addr != dev->boardinfo->init_dyn_addr)\n\t\t\treturn -EBUSY;\n\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     dev->info.static_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_I3C_DEV);\n\t}\n\n\t \n\tif (dev->info.dyn_addr &&\n\t    (!dev->boardinfo ||\n\t     dev->boardinfo->init_dyn_addr != dev->info.dyn_addr)) {\n\t\tstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t      dev->info.dyn_addr);\n\t\tif (status != I3C_ADDR_SLOT_FREE)\n\t\t\tgoto err_release_static_addr;\n\n\t\ti3c_bus_set_addr_slot_status(&master->bus, dev->info.dyn_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_I3C_DEV);\n\t}\n\n\treturn 0;\n\nerr_release_static_addr:\n\tif (dev->info.static_addr)\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     dev->info.static_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\n\treturn -EBUSY;\n}\n\nstatic int i3c_master_attach_i3c_dev(struct i3c_master_controller *master,\n\t\t\t\t     struct i3c_dev_desc *dev)\n{\n\tint ret;\n\n\t \n\tif (!dev->info.static_addr && !dev->info.dyn_addr)\n\t\treturn 0;\n\n\tret = i3c_master_get_i3c_addrs(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (master->this != dev && master->ops->attach_i3c_dev) {\n\t\tret = master->ops->attach_i3c_dev(dev);\n\t\tif (ret) {\n\t\t\ti3c_master_put_i3c_addrs(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tlist_add_tail(&dev->common.node, &master->bus.devs.i3c);\n\n\treturn 0;\n}\n\nstatic int i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,\n\t\t\t\t       u8 old_dyn_addr)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tenum i3c_addr_slot_status status;\n\tint ret;\n\n\tif (dev->info.dyn_addr != old_dyn_addr &&\n\t    (!dev->boardinfo ||\n\t     dev->info.dyn_addr != dev->boardinfo->init_dyn_addr)) {\n\t\tstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t      dev->info.dyn_addr);\n\t\tif (status != I3C_ADDR_SLOT_FREE)\n\t\t\treturn -EBUSY;\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     dev->info.dyn_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_I3C_DEV);\n\t\tif (old_dyn_addr)\n\t\t\ti3c_bus_set_addr_slot_status(&master->bus, old_dyn_addr,\n\t\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\t}\n\n\tif (master->ops->reattach_i3c_dev) {\n\t\tret = master->ops->reattach_i3c_dev(dev, old_dyn_addr);\n\t\tif (ret) {\n\t\t\ti3c_master_put_i3c_addrs(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\n\t \n\tif (master->this != dev && master->ops->detach_i3c_dev)\n\t\tmaster->ops->detach_i3c_dev(dev);\n\n\ti3c_master_put_i3c_addrs(dev);\n\tlist_del(&dev->common.node);\n}\n\nstatic int i3c_master_attach_i2c_dev(struct i3c_master_controller *master,\n\t\t\t\t     struct i2c_dev_desc *dev)\n{\n\tint ret;\n\n\tif (master->ops->attach_i2c_dev) {\n\t\tret = master->ops->attach_i2c_dev(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tlist_add_tail(&dev->common.node, &master->bus.devs.i2c);\n\n\treturn 0;\n}\n\nstatic void i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i2c_dev_get_master(dev);\n\n\tlist_del(&dev->common.node);\n\n\tif (master->ops->detach_i2c_dev)\n\t\tmaster->ops->detach_i2c_dev(dev);\n}\n\nstatic int i3c_master_early_i3c_dev_add(struct i3c_master_controller *master,\n\t\t\t\t\t  struct i3c_dev_boardinfo *boardinfo)\n{\n\tstruct i3c_device_info info = {\n\t\t.static_addr = boardinfo->static_addr,\n\t\t.pid = boardinfo->pid,\n\t};\n\tstruct i3c_dev_desc *i3cdev;\n\tint ret;\n\n\ti3cdev = i3c_master_alloc_i3c_dev(master, &info);\n\tif (IS_ERR(i3cdev))\n\t\treturn -ENOMEM;\n\n\ti3cdev->boardinfo = boardinfo;\n\n\tret = i3c_master_attach_i3c_dev(master, i3cdev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tret = i3c_master_setdasa_locked(master, i3cdev->info.static_addr,\n\t\t\t\t\ti3cdev->boardinfo->init_dyn_addr);\n\tif (ret)\n\t\tgoto err_detach_dev;\n\n\ti3cdev->info.dyn_addr = i3cdev->boardinfo->init_dyn_addr;\n\tret = i3c_master_reattach_i3c_dev(i3cdev, 0);\n\tif (ret)\n\t\tgoto err_rstdaa;\n\n\tret = i3c_master_retrieve_dev_info(i3cdev);\n\tif (ret)\n\t\tgoto err_rstdaa;\n\n\treturn 0;\n\nerr_rstdaa:\n\ti3c_master_rstdaa_locked(master, i3cdev->boardinfo->init_dyn_addr);\nerr_detach_dev:\n\ti3c_master_detach_i3c_dev(i3cdev);\nerr_free_dev:\n\ti3c_master_free_i3c_dev(i3cdev);\n\n\treturn ret;\n}\n\nstatic void\ni3c_master_register_new_i3c_devs(struct i3c_master_controller *master)\n{\n\tstruct i3c_dev_desc *desc;\n\tint ret;\n\n\tif (!master->init_done)\n\t\treturn;\n\n\ti3c_bus_for_each_i3cdev(&master->bus, desc) {\n\t\tif (desc->dev || !desc->info.dyn_addr || desc == master->this)\n\t\t\tcontinue;\n\n\t\tdesc->dev = kzalloc(sizeof(*desc->dev), GFP_KERNEL);\n\t\tif (!desc->dev)\n\t\t\tcontinue;\n\n\t\tdesc->dev->bus = &master->bus;\n\t\tdesc->dev->desc = desc;\n\t\tdesc->dev->dev.parent = &master->dev;\n\t\tdesc->dev->dev.type = &i3c_device_type;\n\t\tdesc->dev->dev.bus = &i3c_bus_type;\n\t\tdesc->dev->dev.release = i3c_device_release;\n\t\tdev_set_name(&desc->dev->dev, \"%d-%llx\", master->bus.id,\n\t\t\t     desc->info.pid);\n\n\t\tif (desc->boardinfo)\n\t\t\tdesc->dev->dev.of_node = desc->boardinfo->of_node;\n\n\t\tret = device_register(&desc->dev->dev);\n\t\tif (ret) {\n\t\t\tdev_err(&master->dev,\n\t\t\t\t\"Failed to add I3C device (err = %d)\\n\", ret);\n\t\t\tput_device(&desc->dev->dev);\n\t\t}\n\t}\n}\n\n \nint i3c_master_do_daa(struct i3c_master_controller *master)\n{\n\tint ret;\n\n\ti3c_bus_maintenance_lock(&master->bus);\n\tret = master->ops->do_daa(master);\n\ti3c_bus_maintenance_unlock(&master->bus);\n\n\tif (ret)\n\t\treturn ret;\n\n\ti3c_bus_normaluse_lock(&master->bus);\n\ti3c_master_register_new_i3c_devs(master);\n\ti3c_bus_normaluse_unlock(&master->bus);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(i3c_master_do_daa);\n\n \nint i3c_master_set_info(struct i3c_master_controller *master,\n\t\t\tconst struct i3c_device_info *info)\n{\n\tstruct i3c_dev_desc *i3cdev;\n\tint ret;\n\n\tif (!i3c_bus_dev_addr_is_avail(&master->bus, info->dyn_addr))\n\t\treturn -EINVAL;\n\n\tif (I3C_BCR_DEVICE_ROLE(info->bcr) == I3C_BCR_I3C_MASTER &&\n\t    master->secondary)\n\t\treturn -EINVAL;\n\n\tif (master->this)\n\t\treturn -EINVAL;\n\n\ti3cdev = i3c_master_alloc_i3c_dev(master, info);\n\tif (IS_ERR(i3cdev))\n\t\treturn PTR_ERR(i3cdev);\n\n\tmaster->this = i3cdev;\n\tmaster->bus.cur_master = master->this;\n\n\tret = i3c_master_attach_i3c_dev(master, i3cdev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\treturn 0;\n\nerr_free_dev:\n\ti3c_master_free_i3c_dev(i3cdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_master_set_info);\n\nstatic void i3c_master_detach_free_devs(struct i3c_master_controller *master)\n{\n\tstruct i3c_dev_desc *i3cdev, *i3ctmp;\n\tstruct i2c_dev_desc *i2cdev, *i2ctmp;\n\n\tlist_for_each_entry_safe(i3cdev, i3ctmp, &master->bus.devs.i3c,\n\t\t\t\t common.node) {\n\t\ti3c_master_detach_i3c_dev(i3cdev);\n\n\t\tif (i3cdev->boardinfo && i3cdev->boardinfo->init_dyn_addr)\n\t\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\ti3cdev->boardinfo->init_dyn_addr,\n\t\t\t\t\tI3C_ADDR_SLOT_FREE);\n\n\t\ti3c_master_free_i3c_dev(i3cdev);\n\t}\n\n\tlist_for_each_entry_safe(i2cdev, i2ctmp, &master->bus.devs.i2c,\n\t\t\t\t common.node) {\n\t\ti3c_master_detach_i2c_dev(i2cdev);\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     i2cdev->addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\t\ti3c_master_free_i2c_dev(i2cdev);\n\t}\n}\n\n \nstatic int i3c_master_bus_init(struct i3c_master_controller *master)\n{\n\tenum i3c_addr_slot_status status;\n\tstruct i2c_dev_boardinfo *i2cboardinfo;\n\tstruct i3c_dev_boardinfo *i3cboardinfo;\n\tstruct i2c_dev_desc *i2cdev;\n\tint ret;\n\n\t \n\tlist_for_each_entry(i2cboardinfo, &master->boardinfo.i2c, node) {\n\t\tstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t      i2cboardinfo->base.addr);\n\t\tif (status != I3C_ADDR_SLOT_FREE) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_detach_devs;\n\t\t}\n\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     i2cboardinfo->base.addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_I2C_DEV);\n\n\t\ti2cdev = i3c_master_alloc_i2c_dev(master,\n\t\t\t\t\t\t  i2cboardinfo->base.addr,\n\t\t\t\t\t\t  i2cboardinfo->lvr);\n\t\tif (IS_ERR(i2cdev)) {\n\t\t\tret = PTR_ERR(i2cdev);\n\t\t\tgoto err_detach_devs;\n\t\t}\n\n\t\tret = i3c_master_attach_i2c_dev(master, i2cdev);\n\t\tif (ret) {\n\t\t\ti3c_master_free_i2c_dev(i2cdev);\n\t\t\tgoto err_detach_devs;\n\t\t}\n\t}\n\n\t \n\tret = master->ops->bus_init(master);\n\tif (ret)\n\t\tgoto err_detach_devs;\n\n\t \n\tif (!master->this) {\n\t\tdev_err(&master->dev,\n\t\t\t\"master_set_info() was not called in ->bus_init()\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_bus_cleanup;\n\t}\n\n\t \n\tret = i3c_master_rstdaa_locked(master, I3C_BROADCAST_ADDR);\n\tif (ret && ret != I3C_ERROR_M2)\n\t\tgoto err_bus_cleanup;\n\n\t \n\tret = i3c_master_disec_locked(master, I3C_BROADCAST_ADDR,\n\t\t\t\t      I3C_CCC_EVENT_SIR | I3C_CCC_EVENT_MR |\n\t\t\t\t      I3C_CCC_EVENT_HJ);\n\tif (ret && ret != I3C_ERROR_M2)\n\t\tgoto err_bus_cleanup;\n\n\t \n\tlist_for_each_entry(i3cboardinfo, &master->boardinfo.i3c, node) {\n\n\t\t \n\t\tif (!i3cboardinfo->init_dyn_addr)\n\t\t\tcontinue;\n\n\t\tret = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t   i3cboardinfo->init_dyn_addr);\n\t\tif (ret != I3C_ADDR_SLOT_FREE) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto err_rstdaa;\n\t\t}\n\n\t\ti3c_bus_set_addr_slot_status(&master->bus,\n\t\t\t\t\t     i3cboardinfo->init_dyn_addr,\n\t\t\t\t\t     I3C_ADDR_SLOT_I3C_DEV);\n\n\t\t \n\n\t\tif (i3cboardinfo->static_addr)\n\t\t\ti3c_master_early_i3c_dev_add(master, i3cboardinfo);\n\t}\n\n\tret = i3c_master_do_daa(master);\n\tif (ret)\n\t\tgoto err_rstdaa;\n\n\treturn 0;\n\nerr_rstdaa:\n\ti3c_master_rstdaa_locked(master, I3C_BROADCAST_ADDR);\n\nerr_bus_cleanup:\n\tif (master->ops->bus_cleanup)\n\t\tmaster->ops->bus_cleanup(master);\n\nerr_detach_devs:\n\ti3c_master_detach_free_devs(master);\n\n\treturn ret;\n}\n\nstatic void i3c_master_bus_cleanup(struct i3c_master_controller *master)\n{\n\tif (master->ops->bus_cleanup)\n\t\tmaster->ops->bus_cleanup(master);\n\n\ti3c_master_detach_free_devs(master);\n}\n\nstatic void i3c_master_attach_boardinfo(struct i3c_dev_desc *i3cdev)\n{\n\tstruct i3c_master_controller *master = i3cdev->common.master;\n\tstruct i3c_dev_boardinfo *i3cboardinfo;\n\n\tlist_for_each_entry(i3cboardinfo, &master->boardinfo.i3c, node) {\n\t\tif (i3cdev->info.pid != i3cboardinfo->pid)\n\t\t\tcontinue;\n\n\t\ti3cdev->boardinfo = i3cboardinfo;\n\t\ti3cdev->info.static_addr = i3cboardinfo->static_addr;\n\t\treturn;\n\t}\n}\n\nstatic struct i3c_dev_desc *\ni3c_master_search_i3c_dev_duplicate(struct i3c_dev_desc *refdev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(refdev);\n\tstruct i3c_dev_desc *i3cdev;\n\n\ti3c_bus_for_each_i3cdev(&master->bus, i3cdev) {\n\t\tif (i3cdev != refdev && i3cdev->info.pid == refdev->info.pid)\n\t\t\treturn i3cdev;\n\t}\n\n\treturn NULL;\n}\n\n \nint i3c_master_add_i3c_dev_locked(struct i3c_master_controller *master,\n\t\t\t\t  u8 addr)\n{\n\tstruct i3c_device_info info = { .dyn_addr = addr };\n\tstruct i3c_dev_desc *newdev, *olddev;\n\tu8 old_dyn_addr = addr, expected_dyn_addr;\n\tstruct i3c_ibi_setup ibireq = { };\n\tbool enable_ibi = false;\n\tint ret;\n\n\tif (!master)\n\t\treturn -EINVAL;\n\n\tnewdev = i3c_master_alloc_i3c_dev(master, &info);\n\tif (IS_ERR(newdev))\n\t\treturn PTR_ERR(newdev);\n\n\tret = i3c_master_attach_i3c_dev(master, newdev);\n\tif (ret)\n\t\tgoto err_free_dev;\n\n\tret = i3c_master_retrieve_dev_info(newdev);\n\tif (ret)\n\t\tgoto err_detach_dev;\n\n\ti3c_master_attach_boardinfo(newdev);\n\n\tolddev = i3c_master_search_i3c_dev_duplicate(newdev);\n\tif (olddev) {\n\t\tnewdev->dev = olddev->dev;\n\t\tif (newdev->dev)\n\t\t\tnewdev->dev->desc = newdev;\n\n\t\t \n\t\tmutex_lock(&olddev->ibi_lock);\n\t\tif (olddev->ibi) {\n\t\t\tibireq.handler = olddev->ibi->handler;\n\t\t\tibireq.max_payload_len = olddev->ibi->max_payload_len;\n\t\t\tibireq.num_slots = olddev->ibi->num_slots;\n\n\t\t\tif (olddev->ibi->enabled) {\n\t\t\t\tenable_ibi = true;\n\t\t\t\ti3c_dev_disable_ibi_locked(olddev);\n\t\t\t}\n\n\t\t\ti3c_dev_free_ibi_locked(olddev);\n\t\t}\n\t\tmutex_unlock(&olddev->ibi_lock);\n\n\t\told_dyn_addr = olddev->info.dyn_addr;\n\n\t\ti3c_master_detach_i3c_dev(olddev);\n\t\ti3c_master_free_i3c_dev(olddev);\n\t}\n\n\t \n\tif (old_dyn_addr && old_dyn_addr != newdev->info.dyn_addr)\n\t\texpected_dyn_addr = old_dyn_addr;\n\telse if (newdev->boardinfo && newdev->boardinfo->init_dyn_addr)\n\t\texpected_dyn_addr = newdev->boardinfo->init_dyn_addr;\n\telse\n\t\texpected_dyn_addr = newdev->info.dyn_addr;\n\n\tif (newdev->info.dyn_addr != expected_dyn_addr) {\n\t\t \n\t\tret = i3c_master_setnewda_locked(master,\n\t\t\t\t\t\t newdev->info.dyn_addr,\n\t\t\t\t\t\t expected_dyn_addr);\n\t\tif (!ret) {\n\t\t\told_dyn_addr = newdev->info.dyn_addr;\n\t\t\tnewdev->info.dyn_addr = expected_dyn_addr;\n\t\t\ti3c_master_reattach_i3c_dev(newdev, old_dyn_addr);\n\t\t} else {\n\t\t\tdev_err(&master->dev,\n\t\t\t\t\"Failed to assign reserved/old address to device %d%llx\",\n\t\t\t\tmaster->bus.id, newdev->info.pid);\n\t\t}\n\t}\n\n\t \n\tif (ibireq.handler) {\n\t\tmutex_lock(&newdev->ibi_lock);\n\t\tret = i3c_dev_request_ibi_locked(newdev, &ibireq);\n\t\tif (ret) {\n\t\t\tdev_err(&master->dev,\n\t\t\t\t\"Failed to request IBI on device %d-%llx\",\n\t\t\t\tmaster->bus.id, newdev->info.pid);\n\t\t} else if (enable_ibi) {\n\t\t\tret = i3c_dev_enable_ibi_locked(newdev);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&master->dev,\n\t\t\t\t\t\"Failed to re-enable IBI on device %d-%llx\",\n\t\t\t\t\tmaster->bus.id, newdev->info.pid);\n\t\t}\n\t\tmutex_unlock(&newdev->ibi_lock);\n\t}\n\n\treturn 0;\n\nerr_detach_dev:\n\tif (newdev->dev && newdev->dev->desc)\n\t\tnewdev->dev->desc = NULL;\n\n\ti3c_master_detach_i3c_dev(newdev);\n\nerr_free_dev:\n\ti3c_master_free_i3c_dev(newdev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_master_add_i3c_dev_locked);\n\n#define OF_I3C_REG1_IS_I2C_DEV\t\t\tBIT(31)\n\nstatic int\nof_i3c_master_add_i2c_boardinfo(struct i3c_master_controller *master,\n\t\t\t\tstruct device_node *node, u32 *reg)\n{\n\tstruct i2c_dev_boardinfo *boardinfo;\n\tstruct device *dev = &master->dev;\n\tint ret;\n\n\tboardinfo = devm_kzalloc(dev, sizeof(*boardinfo), GFP_KERNEL);\n\tif (!boardinfo)\n\t\treturn -ENOMEM;\n\n\tret = of_i2c_get_board_info(dev, node, &boardinfo->base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (boardinfo->base.flags & I2C_CLIENT_TEN) {\n\t\tdev_err(dev, \"I2C device with 10 bit address not supported.\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tboardinfo->lvr = reg[2];\n\n\tlist_add_tail(&boardinfo->node, &master->boardinfo.i2c);\n\tof_node_get(node);\n\n\treturn 0;\n}\n\nstatic int\nof_i3c_master_add_i3c_boardinfo(struct i3c_master_controller *master,\n\t\t\t\tstruct device_node *node, u32 *reg)\n{\n\tstruct i3c_dev_boardinfo *boardinfo;\n\tstruct device *dev = &master->dev;\n\tenum i3c_addr_slot_status addrstatus;\n\tu32 init_dyn_addr = 0;\n\n\tboardinfo = devm_kzalloc(dev, sizeof(*boardinfo), GFP_KERNEL);\n\tif (!boardinfo)\n\t\treturn -ENOMEM;\n\n\tif (reg[0]) {\n\t\tif (reg[0] > I3C_MAX_ADDR)\n\t\t\treturn -EINVAL;\n\n\t\taddrstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t\t  reg[0]);\n\t\tif (addrstatus != I3C_ADDR_SLOT_FREE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tboardinfo->static_addr = reg[0];\n\n\tif (!of_property_read_u32(node, \"assigned-address\", &init_dyn_addr)) {\n\t\tif (init_dyn_addr > I3C_MAX_ADDR)\n\t\t\treturn -EINVAL;\n\n\t\taddrstatus = i3c_bus_get_addr_slot_status(&master->bus,\n\t\t\t\t\t\t\t  init_dyn_addr);\n\t\tif (addrstatus != I3C_ADDR_SLOT_FREE)\n\t\t\treturn -EINVAL;\n\t}\n\n\tboardinfo->pid = ((u64)reg[1] << 32) | reg[2];\n\n\tif ((boardinfo->pid & GENMASK_ULL(63, 48)) ||\n\t    I3C_PID_RND_LOWER_32BITS(boardinfo->pid))\n\t\treturn -EINVAL;\n\n\tboardinfo->init_dyn_addr = init_dyn_addr;\n\tboardinfo->of_node = of_node_get(node);\n\tlist_add_tail(&boardinfo->node, &master->boardinfo.i3c);\n\n\treturn 0;\n}\n\nstatic int of_i3c_master_add_dev(struct i3c_master_controller *master,\n\t\t\t\t struct device_node *node)\n{\n\tu32 reg[3];\n\tint ret;\n\n\tif (!master || !node)\n\t\treturn -EINVAL;\n\n\tret = of_property_read_u32_array(node, \"reg\", reg, ARRAY_SIZE(reg));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!reg[1])\n\t\tret = of_i3c_master_add_i2c_boardinfo(master, node, reg);\n\telse\n\t\tret = of_i3c_master_add_i3c_boardinfo(master, node, reg);\n\n\treturn ret;\n}\n\nstatic int of_populate_i3c_bus(struct i3c_master_controller *master)\n{\n\tstruct device *dev = &master->dev;\n\tstruct device_node *i3cbus_np = dev->of_node;\n\tstruct device_node *node;\n\tint ret;\n\tu32 val;\n\n\tif (!i3cbus_np)\n\t\treturn 0;\n\n\tfor_each_available_child_of_node(i3cbus_np, node) {\n\t\tret = of_i3c_master_add_dev(master, node);\n\t\tif (ret) {\n\t\t\tof_node_put(node);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (!of_property_read_u32(i3cbus_np, \"i2c-scl-hz\", &val))\n\t\tmaster->bus.scl_rate.i2c = val;\n\n\tif (!of_property_read_u32(i3cbus_np, \"i3c-scl-hz\", &val))\n\t\tmaster->bus.scl_rate.i3c = val;\n\n\treturn 0;\n}\n\nstatic int i3c_master_i2c_adapter_xfer(struct i2c_adapter *adap,\n\t\t\t\t       struct i2c_msg *xfers, int nxfers)\n{\n\tstruct i3c_master_controller *master = i2c_adapter_to_i3c_master(adap);\n\tstruct i2c_dev_desc *dev;\n\tint i, ret;\n\tu16 addr;\n\n\tif (!xfers || !master || nxfers <= 0)\n\t\treturn -EINVAL;\n\n\tif (!master->ops->i2c_xfers)\n\t\treturn -ENOTSUPP;\n\n\t \n\taddr = xfers[0].addr;\n\tfor (i = 1; i < nxfers; i++) {\n\t\tif (addr != xfers[i].addr)\n\t\t\treturn -ENOTSUPP;\n\t}\n\n\ti3c_bus_normaluse_lock(&master->bus);\n\tdev = i3c_master_find_i2c_dev_by_addr(master, addr);\n\tif (!dev)\n\t\tret = -ENOENT;\n\telse\n\t\tret = master->ops->i2c_xfers(dev, xfers, nxfers);\n\ti3c_bus_normaluse_unlock(&master->bus);\n\n\treturn ret ? ret : nxfers;\n}\n\nstatic u32 i3c_master_i2c_funcs(struct i2c_adapter *adapter)\n{\n\treturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\n}\n\nstatic u8 i3c_master_i2c_get_lvr(struct i2c_client *client)\n{\n\t \n\tu8 lvr = I3C_LVR_I2C_INDEX(2) | I3C_LVR_I2C_FM_MODE;\n\n\tif (client->dev.of_node) {\n\t\tu32 reg[3];\n\n\t\tif (!of_property_read_u32_array(client->dev.of_node, \"reg\",\n\t\t\t\t\t\treg, ARRAY_SIZE(reg)))\n\t\t\tlvr = reg[2];\n\t}\n\n\treturn lvr;\n}\n\nstatic int i3c_master_i2c_attach(struct i2c_adapter *adap, struct i2c_client *client)\n{\n\tstruct i3c_master_controller *master = i2c_adapter_to_i3c_master(adap);\n\tenum i3c_addr_slot_status status;\n\tstruct i2c_dev_desc *i2cdev;\n\tint ret;\n\n\t \n\tif (i3c_master_find_i2c_dev_by_addr(master, client->addr))\n\t\treturn 0;\n\n\tstatus = i3c_bus_get_addr_slot_status(&master->bus, client->addr);\n\tif (status != I3C_ADDR_SLOT_FREE)\n\t\treturn -EBUSY;\n\n\ti3c_bus_set_addr_slot_status(&master->bus, client->addr,\n\t\t\t\t     I3C_ADDR_SLOT_I2C_DEV);\n\n\ti2cdev = i3c_master_alloc_i2c_dev(master, client->addr,\n\t\t\t\t\t  i3c_master_i2c_get_lvr(client));\n\tif (IS_ERR(i2cdev)) {\n\t\tret = PTR_ERR(i2cdev);\n\t\tgoto out_clear_status;\n\t}\n\n\tret = i3c_master_attach_i2c_dev(master, i2cdev);\n\tif (ret)\n\t\tgoto out_free_dev;\n\n\treturn 0;\n\nout_free_dev:\n\ti3c_master_free_i2c_dev(i2cdev);\nout_clear_status:\n\ti3c_bus_set_addr_slot_status(&master->bus, client->addr,\n\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\n\treturn ret;\n}\n\nstatic int i3c_master_i2c_detach(struct i2c_adapter *adap, struct i2c_client *client)\n{\n\tstruct i3c_master_controller *master = i2c_adapter_to_i3c_master(adap);\n\tstruct i2c_dev_desc *dev;\n\n\tdev = i3c_master_find_i2c_dev_by_addr(master, client->addr);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\ti3c_master_detach_i2c_dev(dev);\n\ti3c_bus_set_addr_slot_status(&master->bus, dev->addr,\n\t\t\t\t     I3C_ADDR_SLOT_FREE);\n\ti3c_master_free_i2c_dev(dev);\n\n\treturn 0;\n}\n\nstatic const struct i2c_algorithm i3c_master_i2c_algo = {\n\t.master_xfer = i3c_master_i2c_adapter_xfer,\n\t.functionality = i3c_master_i2c_funcs,\n};\n\nstatic int i3c_i2c_notifier_call(struct notifier_block *nb, unsigned long action,\n\t\t\t\t void *data)\n{\n\tstruct i2c_adapter *adap;\n\tstruct i2c_client *client;\n\tstruct device *dev = data;\n\tstruct i3c_master_controller *master;\n\tint ret;\n\n\tif (dev->type != &i2c_client_type)\n\t\treturn 0;\n\n\tclient = to_i2c_client(dev);\n\tadap = client->adapter;\n\n\tif (adap->algo != &i3c_master_i2c_algo)\n\t\treturn 0;\n\n\tmaster = i2c_adapter_to_i3c_master(adap);\n\n\ti3c_bus_maintenance_lock(&master->bus);\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tret = i3c_master_i2c_attach(adap, client);\n\t\tbreak;\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tret = i3c_master_i2c_detach(adap, client);\n\t\tbreak;\n\t}\n\ti3c_bus_maintenance_unlock(&master->bus);\n\n\treturn ret;\n}\n\nstatic struct notifier_block i2cdev_notifier = {\n\t.notifier_call = i3c_i2c_notifier_call,\n};\n\nstatic int i3c_master_i2c_adapter_init(struct i3c_master_controller *master)\n{\n\tstruct i2c_adapter *adap = i3c_master_to_i2c_adapter(master);\n\tstruct i2c_dev_desc *i2cdev;\n\tstruct i2c_dev_boardinfo *i2cboardinfo;\n\tint ret;\n\n\tadap->dev.parent = master->dev.parent;\n\tadap->owner = master->dev.parent->driver->owner;\n\tadap->algo = &i3c_master_i2c_algo;\n\tstrncpy(adap->name, dev_name(master->dev.parent), sizeof(adap->name));\n\n\t \n\tadap->timeout = 1000;\n\tadap->retries = 3;\n\n\tret = i2c_add_adapter(adap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tlist_for_each_entry(i2cboardinfo, &master->boardinfo.i2c, node) {\n\t\ti2cdev = i3c_master_find_i2c_dev_by_addr(master,\n\t\t\t\t\t\t\t i2cboardinfo->base.addr);\n\t\tif (WARN_ON(!i2cdev))\n\t\t\tcontinue;\n\t\ti2cdev->dev = i2c_new_client_device(adap, &i2cboardinfo->base);\n\t}\n\n\treturn 0;\n}\n\nstatic void i3c_master_i2c_adapter_cleanup(struct i3c_master_controller *master)\n{\n\tstruct i2c_dev_desc *i2cdev;\n\n\ti2c_del_adapter(&master->i2c);\n\n\ti3c_bus_for_each_i2cdev(&master->bus, i2cdev)\n\t\ti2cdev->dev = NULL;\n}\n\nstatic void i3c_master_unregister_i3c_devs(struct i3c_master_controller *master)\n{\n\tstruct i3c_dev_desc *i3cdev;\n\n\ti3c_bus_for_each_i3cdev(&master->bus, i3cdev) {\n\t\tif (!i3cdev->dev)\n\t\t\tcontinue;\n\n\t\ti3cdev->dev->desc = NULL;\n\t\tif (device_is_registered(&i3cdev->dev->dev))\n\t\t\tdevice_unregister(&i3cdev->dev->dev);\n\t\telse\n\t\t\tput_device(&i3cdev->dev->dev);\n\t\ti3cdev->dev = NULL;\n\t}\n}\n\n \nvoid i3c_master_queue_ibi(struct i3c_dev_desc *dev, struct i3c_ibi_slot *slot)\n{\n\tatomic_inc(&dev->ibi->pending_ibis);\n\tqueue_work(dev->common.master->wq, &slot->work);\n}\nEXPORT_SYMBOL_GPL(i3c_master_queue_ibi);\n\nstatic void i3c_master_handle_ibi(struct work_struct *work)\n{\n\tstruct i3c_ibi_slot *slot = container_of(work, struct i3c_ibi_slot,\n\t\t\t\t\t\t work);\n\tstruct i3c_dev_desc *dev = slot->dev;\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tstruct i3c_ibi_payload payload;\n\n\tpayload.data = slot->data;\n\tpayload.len = slot->len;\n\n\tif (dev->dev)\n\t\tdev->ibi->handler(dev->dev, &payload);\n\n\tmaster->ops->recycle_ibi_slot(dev, slot);\n\tif (atomic_dec_and_test(&dev->ibi->pending_ibis))\n\t\tcomplete(&dev->ibi->all_ibis_handled);\n}\n\nstatic void i3c_master_init_ibi_slot(struct i3c_dev_desc *dev,\n\t\t\t\t     struct i3c_ibi_slot *slot)\n{\n\tslot->dev = dev;\n\tINIT_WORK(&slot->work, i3c_master_handle_ibi);\n}\n\nstruct i3c_generic_ibi_slot {\n\tstruct list_head node;\n\tstruct i3c_ibi_slot base;\n};\n\nstruct i3c_generic_ibi_pool {\n\tspinlock_t lock;\n\tunsigned int num_slots;\n\tstruct i3c_generic_ibi_slot *slots;\n\tvoid *payload_buf;\n\tstruct list_head free_slots;\n\tstruct list_head pending;\n};\n\n \nvoid i3c_generic_ibi_free_pool(struct i3c_generic_ibi_pool *pool)\n{\n\tstruct i3c_generic_ibi_slot *slot;\n\tunsigned int nslots = 0;\n\n\twhile (!list_empty(&pool->free_slots)) {\n\t\tslot = list_first_entry(&pool->free_slots,\n\t\t\t\t\tstruct i3c_generic_ibi_slot, node);\n\t\tlist_del(&slot->node);\n\t\tnslots++;\n\t}\n\n\t \n\tWARN_ON(nslots != pool->num_slots);\n\n\tkfree(pool->payload_buf);\n\tkfree(pool->slots);\n\tkfree(pool);\n}\nEXPORT_SYMBOL_GPL(i3c_generic_ibi_free_pool);\n\n \nstruct i3c_generic_ibi_pool *\ni3c_generic_ibi_alloc_pool(struct i3c_dev_desc *dev,\n\t\t\t   const struct i3c_ibi_setup *req)\n{\n\tstruct i3c_generic_ibi_pool *pool;\n\tstruct i3c_generic_ibi_slot *slot;\n\tunsigned int i;\n\tint ret;\n\n\tpool = kzalloc(sizeof(*pool), GFP_KERNEL);\n\tif (!pool)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&pool->lock);\n\tINIT_LIST_HEAD(&pool->free_slots);\n\tINIT_LIST_HEAD(&pool->pending);\n\n\tpool->slots = kcalloc(req->num_slots, sizeof(*slot), GFP_KERNEL);\n\tif (!pool->slots) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pool;\n\t}\n\n\tif (req->max_payload_len) {\n\t\tpool->payload_buf = kcalloc(req->num_slots,\n\t\t\t\t\t    req->max_payload_len, GFP_KERNEL);\n\t\tif (!pool->payload_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_pool;\n\t\t}\n\t}\n\n\tfor (i = 0; i < req->num_slots; i++) {\n\t\tslot = &pool->slots[i];\n\t\ti3c_master_init_ibi_slot(dev, &slot->base);\n\n\t\tif (req->max_payload_len)\n\t\t\tslot->base.data = pool->payload_buf +\n\t\t\t\t\t  (i * req->max_payload_len);\n\n\t\tlist_add_tail(&slot->node, &pool->free_slots);\n\t\tpool->num_slots++;\n\t}\n\n\treturn pool;\n\nerr_free_pool:\n\ti3c_generic_ibi_free_pool(pool);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(i3c_generic_ibi_alloc_pool);\n\n \nstruct i3c_ibi_slot *\ni3c_generic_ibi_get_free_slot(struct i3c_generic_ibi_pool *pool)\n{\n\tstruct i3c_generic_ibi_slot *slot;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pool->lock, flags);\n\tslot = list_first_entry_or_null(&pool->free_slots,\n\t\t\t\t\tstruct i3c_generic_ibi_slot, node);\n\tif (slot)\n\t\tlist_del(&slot->node);\n\tspin_unlock_irqrestore(&pool->lock, flags);\n\n\treturn slot ? &slot->base : NULL;\n}\nEXPORT_SYMBOL_GPL(i3c_generic_ibi_get_free_slot);\n\n \nvoid i3c_generic_ibi_recycle_slot(struct i3c_generic_ibi_pool *pool,\n\t\t\t\t  struct i3c_ibi_slot *s)\n{\n\tstruct i3c_generic_ibi_slot *slot;\n\tunsigned long flags;\n\n\tif (!s)\n\t\treturn;\n\n\tslot = container_of(s, struct i3c_generic_ibi_slot, base);\n\tspin_lock_irqsave(&pool->lock, flags);\n\tlist_add_tail(&slot->node, &pool->free_slots);\n\tspin_unlock_irqrestore(&pool->lock, flags);\n}\nEXPORT_SYMBOL_GPL(i3c_generic_ibi_recycle_slot);\n\nstatic int i3c_master_check_ops(const struct i3c_master_controller_ops *ops)\n{\n\tif (!ops || !ops->bus_init || !ops->priv_xfers ||\n\t    !ops->send_ccc_cmd || !ops->do_daa || !ops->i2c_xfers)\n\t\treturn -EINVAL;\n\n\tif (ops->request_ibi &&\n\t    (!ops->enable_ibi || !ops->disable_ibi || !ops->free_ibi ||\n\t     !ops->recycle_ibi_slot))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nint i3c_master_register(struct i3c_master_controller *master,\n\t\t\tstruct device *parent,\n\t\t\tconst struct i3c_master_controller_ops *ops,\n\t\t\tbool secondary)\n{\n\tunsigned long i2c_scl_rate = I3C_BUS_I2C_FM_PLUS_SCL_RATE;\n\tstruct i3c_bus *i3cbus = i3c_master_get_bus(master);\n\tenum i3c_bus_mode mode = I3C_BUS_MODE_PURE;\n\tstruct i2c_dev_boardinfo *i2cbi;\n\tint ret;\n\n\t \n\tif (secondary)\n\t\treturn -ENOTSUPP;\n\n\tret = i3c_master_check_ops(ops);\n\tif (ret)\n\t\treturn ret;\n\n\tmaster->dev.parent = parent;\n\tmaster->dev.of_node = of_node_get(parent->of_node);\n\tmaster->dev.bus = &i3c_bus_type;\n\tmaster->dev.type = &i3c_masterdev_type;\n\tmaster->dev.release = i3c_masterdev_release;\n\tmaster->ops = ops;\n\tmaster->secondary = secondary;\n\tINIT_LIST_HEAD(&master->boardinfo.i2c);\n\tINIT_LIST_HEAD(&master->boardinfo.i3c);\n\n\tret = i3c_bus_init(i3cbus, master->dev.of_node);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_initialize(&master->dev);\n\tdev_set_name(&master->dev, \"i3c-%d\", i3cbus->id);\n\n\tret = of_populate_i3c_bus(master);\n\tif (ret)\n\t\tgoto err_put_dev;\n\n\tlist_for_each_entry(i2cbi, &master->boardinfo.i2c, node) {\n\t\tswitch (i2cbi->lvr & I3C_LVR_I2C_INDEX_MASK) {\n\t\tcase I3C_LVR_I2C_INDEX(0):\n\t\t\tif (mode < I3C_BUS_MODE_MIXED_FAST)\n\t\t\t\tmode = I3C_BUS_MODE_MIXED_FAST;\n\t\t\tbreak;\n\t\tcase I3C_LVR_I2C_INDEX(1):\n\t\t\tif (mode < I3C_BUS_MODE_MIXED_LIMITED)\n\t\t\t\tmode = I3C_BUS_MODE_MIXED_LIMITED;\n\t\t\tbreak;\n\t\tcase I3C_LVR_I2C_INDEX(2):\n\t\t\tif (mode < I3C_BUS_MODE_MIXED_SLOW)\n\t\t\t\tmode = I3C_BUS_MODE_MIXED_SLOW;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_put_dev;\n\t\t}\n\n\t\tif (i2cbi->lvr & I3C_LVR_I2C_FM_MODE)\n\t\t\ti2c_scl_rate = I3C_BUS_I2C_FM_SCL_RATE;\n\t}\n\n\tret = i3c_bus_set_mode(i3cbus, mode, i2c_scl_rate);\n\tif (ret)\n\t\tgoto err_put_dev;\n\n\tmaster->wq = alloc_workqueue(\"%s\", 0, 0, dev_name(parent));\n\tif (!master->wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_dev;\n\t}\n\n\tret = i3c_master_bus_init(master);\n\tif (ret)\n\t\tgoto err_put_dev;\n\n\tret = device_add(&master->dev);\n\tif (ret)\n\t\tgoto err_cleanup_bus;\n\n\t \n\tret = i3c_master_i2c_adapter_init(master);\n\tif (ret)\n\t\tgoto err_del_dev;\n\n\t \n\tmaster->init_done = true;\n\ti3c_bus_normaluse_lock(&master->bus);\n\ti3c_master_register_new_i3c_devs(master);\n\ti3c_bus_normaluse_unlock(&master->bus);\n\n\treturn 0;\n\nerr_del_dev:\n\tdevice_del(&master->dev);\n\nerr_cleanup_bus:\n\ti3c_master_bus_cleanup(master);\n\nerr_put_dev:\n\tput_device(&master->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_master_register);\n\n \nvoid i3c_master_unregister(struct i3c_master_controller *master)\n{\n\ti3c_master_i2c_adapter_cleanup(master);\n\ti3c_master_unregister_i3c_devs(master);\n\ti3c_master_bus_cleanup(master);\n\tdevice_unregister(&master->dev);\n}\nEXPORT_SYMBOL_GPL(i3c_master_unregister);\n\nint i3c_dev_setdasa_locked(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master;\n\n\tif (!dev)\n\t\treturn -ENOENT;\n\n\tmaster = i3c_dev_get_master(dev);\n\tif (!master)\n\t\treturn -EINVAL;\n\n\tif (!dev->boardinfo || !dev->boardinfo->init_dyn_addr ||\n\t\t!dev->boardinfo->static_addr)\n\t\treturn -EINVAL;\n\n\treturn i3c_master_setdasa_locked(master, dev->info.static_addr,\n\t\t\t\t\t\tdev->boardinfo->init_dyn_addr);\n}\n\nint i3c_dev_do_priv_xfers_locked(struct i3c_dev_desc *dev,\n\t\t\t\t struct i3c_priv_xfer *xfers,\n\t\t\t\t int nxfers)\n{\n\tstruct i3c_master_controller *master;\n\n\tif (!dev)\n\t\treturn -ENOENT;\n\n\tmaster = i3c_dev_get_master(dev);\n\tif (!master || !xfers)\n\t\treturn -EINVAL;\n\n\tif (!master->ops->priv_xfers)\n\t\treturn -ENOTSUPP;\n\n\treturn master->ops->priv_xfers(dev, xfers, nxfers);\n}\n\nint i3c_dev_disable_ibi_locked(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master;\n\tint ret;\n\n\tif (!dev->ibi)\n\t\treturn -EINVAL;\n\n\tmaster = i3c_dev_get_master(dev);\n\tret = master->ops->disable_ibi(dev);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&dev->ibi->all_ibis_handled);\n\tif (atomic_read(&dev->ibi->pending_ibis))\n\t\twait_for_completion(&dev->ibi->all_ibis_handled);\n\n\tdev->ibi->enabled = false;\n\n\treturn 0;\n}\n\nint i3c_dev_enable_ibi_locked(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tint ret;\n\n\tif (!dev->ibi)\n\t\treturn -EINVAL;\n\n\tret = master->ops->enable_ibi(dev);\n\tif (!ret)\n\t\tdev->ibi->enabled = true;\n\n\treturn ret;\n}\n\nint i3c_dev_request_ibi_locked(struct i3c_dev_desc *dev,\n\t\t\t       const struct i3c_ibi_setup *req)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\tstruct i3c_device_ibi_info *ibi;\n\tint ret;\n\n\tif (!master->ops->request_ibi)\n\t\treturn -ENOTSUPP;\n\n\tif (dev->ibi)\n\t\treturn -EBUSY;\n\n\tibi = kzalloc(sizeof(*ibi), GFP_KERNEL);\n\tif (!ibi)\n\t\treturn -ENOMEM;\n\n\tatomic_set(&ibi->pending_ibis, 0);\n\tinit_completion(&ibi->all_ibis_handled);\n\tibi->handler = req->handler;\n\tibi->max_payload_len = req->max_payload_len;\n\tibi->num_slots = req->num_slots;\n\n\tdev->ibi = ibi;\n\tret = master->ops->request_ibi(dev, req);\n\tif (ret) {\n\t\tkfree(ibi);\n\t\tdev->ibi = NULL;\n\t}\n\n\treturn ret;\n}\n\nvoid i3c_dev_free_ibi_locked(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *master = i3c_dev_get_master(dev);\n\n\tif (!dev->ibi)\n\t\treturn;\n\n\tif (WARN_ON(dev->ibi->enabled))\n\t\tWARN_ON(i3c_dev_disable_ibi_locked(dev));\n\n\tmaster->ops->free_ibi(dev);\n\tkfree(dev->ibi);\n\tdev->ibi = NULL;\n}\n\nstatic int __init i3c_init(void)\n{\n\tint res;\n\n\tres = of_alias_get_highest_id(\"i3c\");\n\tif (res >= 0) {\n\t\tmutex_lock(&i3c_core_lock);\n\t\t__i3c_first_dynamic_bus_num = res + 1;\n\t\tmutex_unlock(&i3c_core_lock);\n\t}\n\n\tres = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);\n\tif (res)\n\t\treturn res;\n\n\tres = bus_register(&i3c_bus_type);\n\tif (res)\n\t\tgoto out_unreg_notifier;\n\n\treturn 0;\n\nout_unreg_notifier:\n\tbus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\n\n\treturn res;\n}\nsubsys_initcall(i3c_init);\n\nstatic void __exit i3c_exit(void)\n{\n\tbus_unregister_notifier(&i2c_bus_type, &i2cdev_notifier);\n\tidr_destroy(&i3c_bus_idr);\n\tbus_unregister(&i3c_bus_type);\n}\nmodule_exit(i3c_exit);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@bootlin.com>\");\nMODULE_DESCRIPTION(\"I3C core\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}