{
  "module_name": "device.c",
  "hash_id": "a1955523605649e05f622a4e9dd314e7e244e842541c560a2f2c10d0b4a0f017",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/device.c",
  "human_readable_source": "\n \n\n#include <linux/atomic.h>\n#include <linux/bug.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n\n#include \"internals.h\"\n\n \nint i3c_device_do_priv_xfers(struct i3c_device *dev,\n\t\t\t     struct i3c_priv_xfer *xfers,\n\t\t\t     int nxfers)\n{\n\tint ret, i;\n\n\tif (nxfers < 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (!xfers[i].len || !xfers[i].data.in)\n\t\t\treturn -EINVAL;\n\t}\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tret = i3c_dev_do_priv_xfers_locked(dev->desc, xfers, nxfers);\n\ti3c_bus_normaluse_unlock(dev->bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_device_do_priv_xfers);\n\n \nint i3c_device_do_setdasa(struct i3c_device *dev)\n{\n\tint ret;\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tret = i3c_dev_setdasa_locked(dev->desc);\n\ti3c_bus_normaluse_unlock(dev->bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_device_do_setdasa);\n\n \nvoid i3c_device_get_info(const struct i3c_device *dev,\n\t\t\t struct i3c_device_info *info)\n{\n\tif (!info)\n\t\treturn;\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tif (dev->desc)\n\t\t*info = dev->desc->info;\n\ti3c_bus_normaluse_unlock(dev->bus);\n}\nEXPORT_SYMBOL_GPL(i3c_device_get_info);\n\n \nint i3c_device_disable_ibi(struct i3c_device *dev)\n{\n\tint ret = -ENOENT;\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tif (dev->desc) {\n\t\tmutex_lock(&dev->desc->ibi_lock);\n\t\tret = i3c_dev_disable_ibi_locked(dev->desc);\n\t\tmutex_unlock(&dev->desc->ibi_lock);\n\t}\n\ti3c_bus_normaluse_unlock(dev->bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_device_disable_ibi);\n\n \nint i3c_device_enable_ibi(struct i3c_device *dev)\n{\n\tint ret = -ENOENT;\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tif (dev->desc) {\n\t\tmutex_lock(&dev->desc->ibi_lock);\n\t\tret = i3c_dev_enable_ibi_locked(dev->desc);\n\t\tmutex_unlock(&dev->desc->ibi_lock);\n\t}\n\ti3c_bus_normaluse_unlock(dev->bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_device_enable_ibi);\n\n \nint i3c_device_request_ibi(struct i3c_device *dev,\n\t\t\t   const struct i3c_ibi_setup *req)\n{\n\tint ret = -ENOENT;\n\n\tif (!req->handler || !req->num_slots)\n\t\treturn -EINVAL;\n\n\ti3c_bus_normaluse_lock(dev->bus);\n\tif (dev->desc) {\n\t\tmutex_lock(&dev->desc->ibi_lock);\n\t\tret = i3c_dev_request_ibi_locked(dev->desc, req);\n\t\tmutex_unlock(&dev->desc->ibi_lock);\n\t}\n\ti3c_bus_normaluse_unlock(dev->bus);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(i3c_device_request_ibi);\n\n \nvoid i3c_device_free_ibi(struct i3c_device *dev)\n{\n\ti3c_bus_normaluse_lock(dev->bus);\n\tif (dev->desc) {\n\t\tmutex_lock(&dev->desc->ibi_lock);\n\t\ti3c_dev_free_ibi_locked(dev->desc);\n\t\tmutex_unlock(&dev->desc->ibi_lock);\n\t}\n\ti3c_bus_normaluse_unlock(dev->bus);\n}\nEXPORT_SYMBOL_GPL(i3c_device_free_ibi);\n\n \nstruct device *i3cdev_to_dev(struct i3c_device *i3cdev)\n{\n\treturn &i3cdev->dev;\n}\nEXPORT_SYMBOL_GPL(i3cdev_to_dev);\n\n \nconst struct i3c_device_id *\ni3c_device_match_id(struct i3c_device *i3cdev,\n\t\t    const struct i3c_device_id *id_table)\n{\n\tstruct i3c_device_info devinfo;\n\tconst struct i3c_device_id *id;\n\tu16 manuf, part, ext_info;\n\tbool rndpid;\n\n\ti3c_device_get_info(i3cdev, &devinfo);\n\n\tmanuf = I3C_PID_MANUF_ID(devinfo.pid);\n\tpart = I3C_PID_PART_ID(devinfo.pid);\n\text_info = I3C_PID_EXTRA_INFO(devinfo.pid);\n\trndpid = I3C_PID_RND_LOWER_32BITS(devinfo.pid);\n\n\tfor (id = id_table; id->match_flags != 0; id++) {\n\t\tif ((id->match_flags & I3C_MATCH_DCR) &&\n\t\t    id->dcr != devinfo.dcr)\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & I3C_MATCH_MANUF) &&\n\t\t    id->manuf_id != manuf)\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & I3C_MATCH_PART) &&\n\t\t    (rndpid || id->part_id != part))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & I3C_MATCH_EXTRA_INFO) &&\n\t\t    (rndpid || id->extra_info != ext_info))\n\t\t\tcontinue;\n\n\t\treturn id;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(i3c_device_match_id);\n\n \nint i3c_driver_register_with_owner(struct i3c_driver *drv, struct module *owner)\n{\n\tdrv->driver.owner = owner;\n\tdrv->driver.bus = &i3c_bus_type;\n\n\tif (!drv->probe) {\n\t\tpr_err(\"Trying to register an i3c driver without probe callback\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(i3c_driver_register_with_owner);\n\n \nvoid i3c_driver_unregister(struct i3c_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(i3c_driver_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}