{
  "module_name": "dw-i3c-master.c",
  "hash_id": "130a76e4aafc97b36ee65362b8f208a90ad9412edf4e347c494d7a5ae1b90ed4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/dw-i3c-master.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/interrupt.h>\n#include <linux/ioport.h>\n#include <linux/iopoll.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"dw-i3c-master.h\"\n\n#define DEVICE_CTRL\t\t\t0x0\n#define DEV_CTRL_ENABLE\t\t\tBIT(31)\n#define DEV_CTRL_RESUME\t\t\tBIT(30)\n#define DEV_CTRL_HOT_JOIN_NACK\t\tBIT(8)\n#define DEV_CTRL_I2C_SLAVE_PRESENT\tBIT(7)\n\n#define DEVICE_ADDR\t\t\t0x4\n#define DEV_ADDR_DYNAMIC_ADDR_VALID\tBIT(31)\n#define DEV_ADDR_DYNAMIC(x)\t\t(((x) << 16) & GENMASK(22, 16))\n\n#define HW_CAPABILITY\t\t\t0x8\n#define COMMAND_QUEUE_PORT\t\t0xc\n#define COMMAND_PORT_TOC\t\tBIT(30)\n#define COMMAND_PORT_READ_TRANSFER\tBIT(28)\n#define COMMAND_PORT_SDAP\t\tBIT(27)\n#define COMMAND_PORT_ROC\t\tBIT(26)\n#define COMMAND_PORT_SPEED(x)\t\t(((x) << 21) & GENMASK(23, 21))\n#define COMMAND_PORT_DEV_INDEX(x)\t(((x) << 16) & GENMASK(20, 16))\n#define COMMAND_PORT_CP\t\t\tBIT(15)\n#define COMMAND_PORT_CMD(x)\t\t(((x) << 7) & GENMASK(14, 7))\n#define COMMAND_PORT_TID(x)\t\t(((x) << 3) & GENMASK(6, 3))\n\n#define COMMAND_PORT_ARG_DATA_LEN(x)\t(((x) << 16) & GENMASK(31, 16))\n#define COMMAND_PORT_ARG_DATA_LEN_MAX\t65536\n#define COMMAND_PORT_TRANSFER_ARG\t0x01\n\n#define COMMAND_PORT_SDA_DATA_BYTE_3(x)\t(((x) << 24) & GENMASK(31, 24))\n#define COMMAND_PORT_SDA_DATA_BYTE_2(x)\t(((x) << 16) & GENMASK(23, 16))\n#define COMMAND_PORT_SDA_DATA_BYTE_1(x)\t(((x) << 8) & GENMASK(15, 8))\n#define COMMAND_PORT_SDA_BYTE_STRB_3\tBIT(5)\n#define COMMAND_PORT_SDA_BYTE_STRB_2\tBIT(4)\n#define COMMAND_PORT_SDA_BYTE_STRB_1\tBIT(3)\n#define COMMAND_PORT_SHORT_DATA_ARG\t0x02\n\n#define COMMAND_PORT_DEV_COUNT(x)\t(((x) << 21) & GENMASK(25, 21))\n#define COMMAND_PORT_ADDR_ASSGN_CMD\t0x03\n\n#define RESPONSE_QUEUE_PORT\t\t0x10\n#define RESPONSE_PORT_ERR_STATUS(x)\t(((x) & GENMASK(31, 28)) >> 28)\n#define RESPONSE_NO_ERROR\t\t0\n#define RESPONSE_ERROR_CRC\t\t1\n#define RESPONSE_ERROR_PARITY\t\t2\n#define RESPONSE_ERROR_FRAME\t\t3\n#define RESPONSE_ERROR_IBA_NACK\t\t4\n#define RESPONSE_ERROR_ADDRESS_NACK\t5\n#define RESPONSE_ERROR_OVER_UNDER_FLOW\t6\n#define RESPONSE_ERROR_TRANSF_ABORT\t8\n#define RESPONSE_ERROR_I2C_W_NACK_ERR\t9\n#define RESPONSE_PORT_TID(x)\t\t(((x) & GENMASK(27, 24)) >> 24)\n#define RESPONSE_PORT_DATA_LEN(x)\t((x) & GENMASK(15, 0))\n\n#define RX_TX_DATA_PORT\t\t\t0x14\n#define IBI_QUEUE_STATUS\t\t0x18\n#define IBI_QUEUE_STATUS_IBI_ID(x)\t(((x) & GENMASK(15, 8)) >> 8)\n#define IBI_QUEUE_STATUS_DATA_LEN(x)\t((x) & GENMASK(7, 0))\n#define IBI_QUEUE_IBI_ADDR(x)\t\t(IBI_QUEUE_STATUS_IBI_ID(x) >> 1)\n#define IBI_QUEUE_IBI_RNW(x)\t\t(IBI_QUEUE_STATUS_IBI_ID(x) & BIT(0))\n#define IBI_TYPE_MR(x)                                                         \\\n\t((IBI_QUEUE_IBI_ADDR(x) != I3C_HOT_JOIN_ADDR) && !IBI_QUEUE_IBI_RNW(x))\n#define IBI_TYPE_HJ(x)                                                         \\\n\t((IBI_QUEUE_IBI_ADDR(x) == I3C_HOT_JOIN_ADDR) && !IBI_QUEUE_IBI_RNW(x))\n#define IBI_TYPE_SIRQ(x)                                                        \\\n\t((IBI_QUEUE_IBI_ADDR(x) != I3C_HOT_JOIN_ADDR) && IBI_QUEUE_IBI_RNW(x))\n\n#define QUEUE_THLD_CTRL\t\t\t0x1c\n#define QUEUE_THLD_CTRL_IBI_STAT_MASK\tGENMASK(31, 24)\n#define QUEUE_THLD_CTRL_IBI_STAT(x)\t(((x) - 1) << 24)\n#define QUEUE_THLD_CTRL_IBI_DATA_MASK\tGENMASK(20, 16)\n#define QUEUE_THLD_CTRL_IBI_DATA(x)\t((x) << 16)\n#define QUEUE_THLD_CTRL_RESP_BUF_MASK\tGENMASK(15, 8)\n#define QUEUE_THLD_CTRL_RESP_BUF(x)\t(((x) - 1) << 8)\n\n#define DATA_BUFFER_THLD_CTRL\t\t0x20\n#define DATA_BUFFER_THLD_CTRL_RX_BUF\tGENMASK(11, 8)\n\n#define IBI_QUEUE_CTRL\t\t\t0x24\n#define IBI_MR_REQ_REJECT\t\t0x2C\n#define IBI_SIR_REQ_REJECT\t\t0x30\n#define IBI_REQ_REJECT_ALL\t\tGENMASK(31, 0)\n\n#define RESET_CTRL\t\t\t0x34\n#define RESET_CTRL_IBI_QUEUE\t\tBIT(5)\n#define RESET_CTRL_RX_FIFO\t\tBIT(4)\n#define RESET_CTRL_TX_FIFO\t\tBIT(3)\n#define RESET_CTRL_RESP_QUEUE\t\tBIT(2)\n#define RESET_CTRL_CMD_QUEUE\t\tBIT(1)\n#define RESET_CTRL_SOFT\t\t\tBIT(0)\n\n#define SLV_EVENT_CTRL\t\t\t0x38\n#define INTR_STATUS\t\t\t0x3c\n#define INTR_STATUS_EN\t\t\t0x40\n#define INTR_SIGNAL_EN\t\t\t0x44\n#define INTR_FORCE\t\t\t0x48\n#define INTR_BUSOWNER_UPDATE_STAT\tBIT(13)\n#define INTR_IBI_UPDATED_STAT\t\tBIT(12)\n#define INTR_READ_REQ_RECV_STAT\t\tBIT(11)\n#define INTR_DEFSLV_STAT\t\tBIT(10)\n#define INTR_TRANSFER_ERR_STAT\t\tBIT(9)\n#define INTR_DYN_ADDR_ASSGN_STAT\tBIT(8)\n#define INTR_CCC_UPDATED_STAT\t\tBIT(6)\n#define INTR_TRANSFER_ABORT_STAT\tBIT(5)\n#define INTR_RESP_READY_STAT\t\tBIT(4)\n#define INTR_CMD_QUEUE_READY_STAT\tBIT(3)\n#define INTR_IBI_THLD_STAT\t\tBIT(2)\n#define INTR_RX_THLD_STAT\t\tBIT(1)\n#define INTR_TX_THLD_STAT\t\tBIT(0)\n#define INTR_ALL\t\t\t(INTR_BUSOWNER_UPDATE_STAT |\t\\\n\t\t\t\t\tINTR_IBI_UPDATED_STAT |\t\t\\\n\t\t\t\t\tINTR_READ_REQ_RECV_STAT |\t\\\n\t\t\t\t\tINTR_DEFSLV_STAT |\t\t\\\n\t\t\t\t\tINTR_TRANSFER_ERR_STAT |\t\\\n\t\t\t\t\tINTR_DYN_ADDR_ASSGN_STAT |\t\\\n\t\t\t\t\tINTR_CCC_UPDATED_STAT |\t\t\\\n\t\t\t\t\tINTR_TRANSFER_ABORT_STAT |\t\\\n\t\t\t\t\tINTR_RESP_READY_STAT |\t\t\\\n\t\t\t\t\tINTR_CMD_QUEUE_READY_STAT |\t\\\n\t\t\t\t\tINTR_IBI_THLD_STAT |\t\t\\\n\t\t\t\t\tINTR_TX_THLD_STAT |\t\t\\\n\t\t\t\t\tINTR_RX_THLD_STAT)\n\n#define INTR_MASTER_MASK\t\t(INTR_TRANSFER_ERR_STAT |\t\\\n\t\t\t\t\t INTR_RESP_READY_STAT)\n\n#define QUEUE_STATUS_LEVEL\t\t0x4c\n#define QUEUE_STATUS_IBI_STATUS_CNT(x)\t(((x) & GENMASK(28, 24)) >> 24)\n#define QUEUE_STATUS_IBI_BUF_BLR(x)\t(((x) & GENMASK(23, 16)) >> 16)\n#define QUEUE_STATUS_LEVEL_RESP(x)\t(((x) & GENMASK(15, 8)) >> 8)\n#define QUEUE_STATUS_LEVEL_CMD(x)\t((x) & GENMASK(7, 0))\n\n#define DATA_BUFFER_STATUS_LEVEL\t0x50\n#define DATA_BUFFER_STATUS_LEVEL_TX(x)\t((x) & GENMASK(7, 0))\n\n#define PRESENT_STATE\t\t\t0x54\n#define CCC_DEVICE_STATUS\t\t0x58\n#define DEVICE_ADDR_TABLE_POINTER\t0x5c\n#define DEVICE_ADDR_TABLE_DEPTH(x)\t(((x) & GENMASK(31, 16)) >> 16)\n#define DEVICE_ADDR_TABLE_ADDR(x)\t((x) & GENMASK(7, 0))\n\n#define DEV_CHAR_TABLE_POINTER\t\t0x60\n#define VENDOR_SPECIFIC_REG_POINTER\t0x6c\n#define SLV_PID_VALUE\t\t\t0x74\n#define SLV_CHAR_CTRL\t\t\t0x78\n#define SLV_MAX_LEN\t\t\t0x7c\n#define MAX_READ_TURNAROUND\t\t0x80\n#define MAX_DATA_SPEED\t\t\t0x84\n#define SLV_DEBUG_STATUS\t\t0x88\n#define SLV_INTR_REQ\t\t\t0x8c\n#define DEVICE_CTRL_EXTENDED\t\t0xb0\n#define SCL_I3C_OD_TIMING\t\t0xb4\n#define SCL_I3C_PP_TIMING\t\t0xb8\n#define SCL_I3C_TIMING_HCNT(x)\t\t(((x) << 16) & GENMASK(23, 16))\n#define SCL_I3C_TIMING_LCNT(x)\t\t((x) & GENMASK(7, 0))\n#define SCL_I3C_TIMING_CNT_MIN\t\t5\n\n#define SCL_I2C_FM_TIMING\t\t0xbc\n#define SCL_I2C_FM_TIMING_HCNT(x)\t(((x) << 16) & GENMASK(31, 16))\n#define SCL_I2C_FM_TIMING_LCNT(x)\t((x) & GENMASK(15, 0))\n\n#define SCL_I2C_FMP_TIMING\t\t0xc0\n#define SCL_I2C_FMP_TIMING_HCNT(x)\t(((x) << 16) & GENMASK(23, 16))\n#define SCL_I2C_FMP_TIMING_LCNT(x)\t((x) & GENMASK(15, 0))\n\n#define SCL_EXT_LCNT_TIMING\t\t0xc8\n#define SCL_EXT_LCNT_4(x)\t\t(((x) << 24) & GENMASK(31, 24))\n#define SCL_EXT_LCNT_3(x)\t\t(((x) << 16) & GENMASK(23, 16))\n#define SCL_EXT_LCNT_2(x)\t\t(((x) << 8) & GENMASK(15, 8))\n#define SCL_EXT_LCNT_1(x)\t\t((x) & GENMASK(7, 0))\n\n#define SCL_EXT_TERMN_LCNT_TIMING\t0xcc\n#define BUS_FREE_TIMING\t\t\t0xd4\n#define BUS_I3C_MST_FREE(x)\t\t((x) & GENMASK(15, 0))\n\n#define BUS_IDLE_TIMING\t\t\t0xd8\n#define I3C_VER_ID\t\t\t0xe0\n#define I3C_VER_TYPE\t\t\t0xe4\n#define EXTENDED_CAPABILITY\t\t0xe8\n#define SLAVE_CONFIG\t\t\t0xec\n\n#define DEV_ADDR_TABLE_IBI_MDB\t\tBIT(12)\n#define DEV_ADDR_TABLE_SIR_REJECT\tBIT(13)\n#define DEV_ADDR_TABLE_LEGACY_I2C_DEV\tBIT(31)\n#define DEV_ADDR_TABLE_DYNAMIC_ADDR(x)\t(((x) << 16) & GENMASK(23, 16))\n#define DEV_ADDR_TABLE_STATIC_ADDR(x)\t((x) & GENMASK(6, 0))\n#define DEV_ADDR_TABLE_LOC(start, idx)\t((start) + ((idx) << 2))\n\n#define I3C_BUS_SDR1_SCL_RATE\t\t8000000\n#define I3C_BUS_SDR2_SCL_RATE\t\t6000000\n#define I3C_BUS_SDR3_SCL_RATE\t\t4000000\n#define I3C_BUS_SDR4_SCL_RATE\t\t2000000\n#define I3C_BUS_I2C_FM_TLOW_MIN_NS\t1300\n#define I3C_BUS_I2C_FMP_TLOW_MIN_NS\t500\n#define I3C_BUS_THIGH_MAX_NS\t\t41\n\n#define XFER_TIMEOUT (msecs_to_jiffies(1000))\n\nstruct dw_i3c_cmd {\n\tu32 cmd_lo;\n\tu32 cmd_hi;\n\tu16 tx_len;\n\tconst void *tx_buf;\n\tu16 rx_len;\n\tvoid *rx_buf;\n\tu8 error;\n};\n\nstruct dw_i3c_xfer {\n\tstruct list_head node;\n\tstruct completion comp;\n\tint ret;\n\tunsigned int ncmds;\n\tstruct dw_i3c_cmd cmds[];\n};\n\nstruct dw_i3c_i2c_dev_data {\n\tu8 index;\n\tstruct i3c_generic_ibi_pool *ibi_pool;\n};\n\nstatic u8 even_parity(u8 p)\n{\n\tp ^= p >> 4;\n\tp &= 0xf;\n\n\treturn (0x9669 >> p) & 1;\n}\n\nstatic bool dw_i3c_master_supports_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\t\t   const struct i3c_ccc_cmd *cmd)\n{\n\tif (cmd->ndests > 1)\n\t\treturn false;\n\n\tswitch (cmd->id) {\n\tcase I3C_CCC_ENEC(true):\n\tcase I3C_CCC_ENEC(false):\n\tcase I3C_CCC_DISEC(true):\n\tcase I3C_CCC_DISEC(false):\n\tcase I3C_CCC_ENTAS(0, true):\n\tcase I3C_CCC_ENTAS(0, false):\n\tcase I3C_CCC_RSTDAA(true):\n\tcase I3C_CCC_RSTDAA(false):\n\tcase I3C_CCC_ENTDAA:\n\tcase I3C_CCC_SETMWL(true):\n\tcase I3C_CCC_SETMWL(false):\n\tcase I3C_CCC_SETMRL(true):\n\tcase I3C_CCC_SETMRL(false):\n\tcase I3C_CCC_ENTHDR(0):\n\tcase I3C_CCC_SETDASA:\n\tcase I3C_CCC_SETNEWDA:\n\tcase I3C_CCC_GETMWL:\n\tcase I3C_CCC_GETMRL:\n\tcase I3C_CCC_GETPID:\n\tcase I3C_CCC_GETBCR:\n\tcase I3C_CCC_GETDCR:\n\tcase I3C_CCC_GETSTATUS:\n\tcase I3C_CCC_GETMXDS:\n\tcase I3C_CCC_GETHDRCAP:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic inline struct dw_i3c_master *\nto_dw_i3c_master(struct i3c_master_controller *master)\n{\n\treturn container_of(master, struct dw_i3c_master, base);\n}\n\nstatic void dw_i3c_master_disable(struct dw_i3c_master *master)\n{\n\twritel(readl(master->regs + DEVICE_CTRL) & ~DEV_CTRL_ENABLE,\n\t       master->regs + DEVICE_CTRL);\n}\n\nstatic void dw_i3c_master_enable(struct dw_i3c_master *master)\n{\n\twritel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_ENABLE,\n\t       master->regs + DEVICE_CTRL);\n}\n\nstatic int dw_i3c_master_get_addr_pos(struct dw_i3c_master *master, u8 addr)\n{\n\tint pos;\n\n\tfor (pos = 0; pos < master->maxdevs; pos++) {\n\t\tif (addr == master->devs[pos].addr)\n\t\t\treturn pos;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int dw_i3c_master_get_free_pos(struct dw_i3c_master *master)\n{\n\tif (!(master->free_pos & GENMASK(master->maxdevs - 1, 0)))\n\t\treturn -ENOSPC;\n\n\treturn ffs(master->free_pos) - 1;\n}\n\nstatic void dw_i3c_master_wr_tx_fifo(struct dw_i3c_master *master,\n\t\t\t\t     const u8 *bytes, int nbytes)\n{\n\twritesl(master->regs + RX_TX_DATA_PORT, bytes, nbytes / 4);\n\tif (nbytes & 3) {\n\t\tu32 tmp = 0;\n\n\t\tmemcpy(&tmp, bytes + (nbytes & ~3), nbytes & 3);\n\t\twritesl(master->regs + RX_TX_DATA_PORT, &tmp, 1);\n\t}\n}\n\nstatic void dw_i3c_master_read_fifo(struct dw_i3c_master *master,\n\t\t\t\t    int reg,  u8 *bytes, int nbytes)\n{\n\treadsl(master->regs + reg, bytes, nbytes / 4);\n\tif (nbytes & 3) {\n\t\tu32 tmp;\n\n\t\treadsl(master->regs + reg, &tmp, 1);\n\t\tmemcpy(bytes + (nbytes & ~3), &tmp, nbytes & 3);\n\t}\n}\n\nstatic void dw_i3c_master_read_rx_fifo(struct dw_i3c_master *master,\n\t\t\t\t       u8 *bytes, int nbytes)\n{\n\treturn dw_i3c_master_read_fifo(master, RX_TX_DATA_PORT, bytes, nbytes);\n}\n\nstatic void dw_i3c_master_read_ibi_fifo(struct dw_i3c_master *master,\n\t\t\t\t\tu8 *bytes, int nbytes)\n{\n\treturn dw_i3c_master_read_fifo(master, IBI_QUEUE_STATUS, bytes, nbytes);\n}\n\nstatic struct dw_i3c_xfer *\ndw_i3c_master_alloc_xfer(struct dw_i3c_master *master, unsigned int ncmds)\n{\n\tstruct dw_i3c_xfer *xfer;\n\n\txfer = kzalloc(struct_size(xfer, cmds, ncmds), GFP_KERNEL);\n\tif (!xfer)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&xfer->node);\n\txfer->ncmds = ncmds;\n\txfer->ret = -ETIMEDOUT;\n\n\treturn xfer;\n}\n\nstatic void dw_i3c_master_free_xfer(struct dw_i3c_xfer *xfer)\n{\n\tkfree(xfer);\n}\n\nstatic void dw_i3c_master_start_xfer_locked(struct dw_i3c_master *master)\n{\n\tstruct dw_i3c_xfer *xfer = master->xferqueue.cur;\n\tunsigned int i;\n\tu32 thld_ctrl;\n\n\tif (!xfer)\n\t\treturn;\n\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tstruct dw_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tdw_i3c_master_wr_tx_fifo(master, cmd->tx_buf, cmd->tx_len);\n\t}\n\n\tthld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);\n\tthld_ctrl &= ~QUEUE_THLD_CTRL_RESP_BUF_MASK;\n\tthld_ctrl |= QUEUE_THLD_CTRL_RESP_BUF(xfer->ncmds);\n\twritel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);\n\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tstruct dw_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\twritel(cmd->cmd_hi, master->regs + COMMAND_QUEUE_PORT);\n\t\twritel(cmd->cmd_lo, master->regs + COMMAND_QUEUE_PORT);\n\t}\n}\n\nstatic void dw_i3c_master_enqueue_xfer(struct dw_i3c_master *master,\n\t\t\t\t       struct dw_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\n\tinit_completion(&xfer->comp);\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tif (master->xferqueue.cur) {\n\t\tlist_add_tail(&xfer->node, &master->xferqueue.list);\n\t} else {\n\t\tmaster->xferqueue.cur = xfer;\n\t\tdw_i3c_master_start_xfer_locked(master);\n\t}\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n}\n\nstatic void dw_i3c_master_dequeue_xfer_locked(struct dw_i3c_master *master,\n\t\t\t\t\t      struct dw_i3c_xfer *xfer)\n{\n\tif (master->xferqueue.cur == xfer) {\n\t\tu32 status;\n\n\t\tmaster->xferqueue.cur = NULL;\n\n\t\twritel(RESET_CTRL_RX_FIFO | RESET_CTRL_TX_FIFO |\n\t\t       RESET_CTRL_RESP_QUEUE | RESET_CTRL_CMD_QUEUE,\n\t\t       master->regs + RESET_CTRL);\n\n\t\treadl_poll_timeout_atomic(master->regs + RESET_CTRL, status,\n\t\t\t\t\t  !status, 10, 1000000);\n\t} else {\n\t\tlist_del_init(&xfer->node);\n\t}\n}\n\nstatic void dw_i3c_master_dequeue_xfer(struct dw_i3c_master *master,\n\t\t\t\t       struct dw_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tdw_i3c_master_dequeue_xfer_locked(master, xfer);\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n}\n\nstatic void dw_i3c_master_end_xfer_locked(struct dw_i3c_master *master, u32 isr)\n{\n\tstruct dw_i3c_xfer *xfer = master->xferqueue.cur;\n\tint i, ret = 0;\n\tu32 nresp;\n\n\tif (!xfer)\n\t\treturn;\n\n\tnresp = readl(master->regs + QUEUE_STATUS_LEVEL);\n\tnresp = QUEUE_STATUS_LEVEL_RESP(nresp);\n\n\tfor (i = 0; i < nresp; i++) {\n\t\tstruct dw_i3c_cmd *cmd;\n\t\tu32 resp;\n\n\t\tresp = readl(master->regs + RESPONSE_QUEUE_PORT);\n\n\t\tcmd = &xfer->cmds[RESPONSE_PORT_TID(resp)];\n\t\tcmd->rx_len = RESPONSE_PORT_DATA_LEN(resp);\n\t\tcmd->error = RESPONSE_PORT_ERR_STATUS(resp);\n\t\tif (cmd->rx_len && !cmd->error)\n\t\t\tdw_i3c_master_read_rx_fifo(master, cmd->rx_buf,\n\t\t\t\t\t\t   cmd->rx_len);\n\t}\n\n\tfor (i = 0; i < nresp; i++) {\n\t\tswitch (xfer->cmds[i].error) {\n\t\tcase RESPONSE_NO_ERROR:\n\t\t\tbreak;\n\t\tcase RESPONSE_ERROR_PARITY:\n\t\tcase RESPONSE_ERROR_IBA_NACK:\n\t\tcase RESPONSE_ERROR_TRANSF_ABORT:\n\t\tcase RESPONSE_ERROR_CRC:\n\t\tcase RESPONSE_ERROR_FRAME:\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\tcase RESPONSE_ERROR_OVER_UNDER_FLOW:\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\t\tcase RESPONSE_ERROR_I2C_W_NACK_ERR:\n\t\tcase RESPONSE_ERROR_ADDRESS_NACK:\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txfer->ret = ret;\n\tcomplete(&xfer->comp);\n\n\tif (ret < 0) {\n\t\tdw_i3c_master_dequeue_xfer_locked(master, xfer);\n\t\twritel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_RESUME,\n\t\t       master->regs + DEVICE_CTRL);\n\t}\n\n\txfer = list_first_entry_or_null(&master->xferqueue.list,\n\t\t\t\t\tstruct dw_i3c_xfer,\n\t\t\t\t\tnode);\n\tif (xfer)\n\t\tlist_del_init(&xfer->node);\n\n\tmaster->xferqueue.cur = xfer;\n\tdw_i3c_master_start_xfer_locked(master);\n}\n\nstatic int dw_i3c_clk_cfg(struct dw_i3c_master *master)\n{\n\tunsigned long core_rate, core_period;\n\tu32 scl_timing;\n\tu8 hcnt, lcnt;\n\n\tcore_rate = clk_get_rate(master->core_clk);\n\tif (!core_rate)\n\t\treturn -EINVAL;\n\n\tcore_period = DIV_ROUND_UP(1000000000, core_rate);\n\n\thcnt = DIV_ROUND_UP(I3C_BUS_THIGH_MAX_NS, core_period) - 1;\n\tif (hcnt < SCL_I3C_TIMING_CNT_MIN)\n\t\thcnt = SCL_I3C_TIMING_CNT_MIN;\n\n\tlcnt = DIV_ROUND_UP(core_rate, master->base.bus.scl_rate.i3c) - hcnt;\n\tif (lcnt < SCL_I3C_TIMING_CNT_MIN)\n\t\tlcnt = SCL_I3C_TIMING_CNT_MIN;\n\n\tscl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);\n\twritel(scl_timing, master->regs + SCL_I3C_PP_TIMING);\n\n\t \n\tif (master->base.bus.mode == I3C_BUS_MODE_PURE)\n\t\twritel(BUS_I3C_MST_FREE(lcnt), master->regs + BUS_FREE_TIMING);\n\n\tlcnt = max_t(u8,\n\t\t     DIV_ROUND_UP(I3C_BUS_TLOW_OD_MIN_NS, core_period), lcnt);\n\tscl_timing = SCL_I3C_TIMING_HCNT(hcnt) | SCL_I3C_TIMING_LCNT(lcnt);\n\twritel(scl_timing, master->regs + SCL_I3C_OD_TIMING);\n\n\tlcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR1_SCL_RATE) - hcnt;\n\tscl_timing = SCL_EXT_LCNT_1(lcnt);\n\tlcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR2_SCL_RATE) - hcnt;\n\tscl_timing |= SCL_EXT_LCNT_2(lcnt);\n\tlcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR3_SCL_RATE) - hcnt;\n\tscl_timing |= SCL_EXT_LCNT_3(lcnt);\n\tlcnt = DIV_ROUND_UP(core_rate, I3C_BUS_SDR4_SCL_RATE) - hcnt;\n\tscl_timing |= SCL_EXT_LCNT_4(lcnt);\n\twritel(scl_timing, master->regs + SCL_EXT_LCNT_TIMING);\n\n\treturn 0;\n}\n\nstatic int dw_i2c_clk_cfg(struct dw_i3c_master *master)\n{\n\tunsigned long core_rate, core_period;\n\tu16 hcnt, lcnt;\n\tu32 scl_timing;\n\n\tcore_rate = clk_get_rate(master->core_clk);\n\tif (!core_rate)\n\t\treturn -EINVAL;\n\n\tcore_period = DIV_ROUND_UP(1000000000, core_rate);\n\n\tlcnt = DIV_ROUND_UP(I3C_BUS_I2C_FMP_TLOW_MIN_NS, core_period);\n\thcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_PLUS_SCL_RATE) - lcnt;\n\tscl_timing = SCL_I2C_FMP_TIMING_HCNT(hcnt) |\n\t\t     SCL_I2C_FMP_TIMING_LCNT(lcnt);\n\twritel(scl_timing, master->regs + SCL_I2C_FMP_TIMING);\n\n\tlcnt = DIV_ROUND_UP(I3C_BUS_I2C_FM_TLOW_MIN_NS, core_period);\n\thcnt = DIV_ROUND_UP(core_rate, I3C_BUS_I2C_FM_SCL_RATE) - lcnt;\n\tscl_timing = SCL_I2C_FM_TIMING_HCNT(hcnt) |\n\t\t     SCL_I2C_FM_TIMING_LCNT(lcnt);\n\twritel(scl_timing, master->regs + SCL_I2C_FM_TIMING);\n\n\twritel(BUS_I3C_MST_FREE(lcnt), master->regs + BUS_FREE_TIMING);\n\twritel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_I2C_SLAVE_PRESENT,\n\t       master->regs + DEVICE_CTRL);\n\n\treturn 0;\n}\n\nstatic int dw_i3c_master_bus_init(struct i3c_master_controller *m)\n{\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tstruct i3c_bus *bus = i3c_master_get_bus(m);\n\tstruct i3c_device_info info = { };\n\tu32 thld_ctrl;\n\tint ret;\n\n\tret = master->platform_ops->init(master);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (bus->mode) {\n\tcase I3C_BUS_MODE_MIXED_FAST:\n\tcase I3C_BUS_MODE_MIXED_LIMITED:\n\t\tret = dw_i2c_clk_cfg(master);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tfallthrough;\n\tcase I3C_BUS_MODE_PURE:\n\t\tret = dw_i3c_clk_cfg(master);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tthld_ctrl = readl(master->regs + QUEUE_THLD_CTRL);\n\tthld_ctrl &= ~(QUEUE_THLD_CTRL_RESP_BUF_MASK |\n\t\t       QUEUE_THLD_CTRL_IBI_STAT_MASK |\n\t\t       QUEUE_THLD_CTRL_IBI_STAT_MASK);\n\tthld_ctrl |= QUEUE_THLD_CTRL_IBI_STAT(1) |\n\t\tQUEUE_THLD_CTRL_IBI_DATA(31);\n\twritel(thld_ctrl, master->regs + QUEUE_THLD_CTRL);\n\n\tthld_ctrl = readl(master->regs + DATA_BUFFER_THLD_CTRL);\n\tthld_ctrl &= ~DATA_BUFFER_THLD_CTRL_RX_BUF;\n\twritel(thld_ctrl, master->regs + DATA_BUFFER_THLD_CTRL);\n\n\twritel(INTR_ALL, master->regs + INTR_STATUS);\n\twritel(INTR_MASTER_MASK, master->regs + INTR_STATUS_EN);\n\twritel(INTR_MASTER_MASK, master->regs + INTR_SIGNAL_EN);\n\n\tret = i3c_master_get_free_addr(m, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(DEV_ADDR_DYNAMIC_ADDR_VALID | DEV_ADDR_DYNAMIC(ret),\n\t       master->regs + DEVICE_ADDR);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dyn_addr = ret;\n\n\tret = i3c_master_set_info(&master->base, &info);\n\tif (ret)\n\t\treturn ret;\n\n\twritel(IBI_REQ_REJECT_ALL, master->regs + IBI_SIR_REQ_REJECT);\n\twritel(IBI_REQ_REJECT_ALL, master->regs + IBI_MR_REQ_REJECT);\n\n\t \n\twritel(readl(master->regs + DEVICE_CTRL) | DEV_CTRL_HOT_JOIN_NACK,\n\t       master->regs + DEVICE_CTRL);\n\n\tdw_i3c_master_enable(master);\n\n\treturn 0;\n}\n\nstatic void dw_i3c_master_bus_cleanup(struct i3c_master_controller *m)\n{\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\n\tdw_i3c_master_disable(master);\n}\n\nstatic int dw_i3c_ccc_set(struct dw_i3c_master *master,\n\t\t\t  struct i3c_ccc_cmd *ccc)\n{\n\tstruct dw_i3c_xfer *xfer;\n\tstruct dw_i3c_cmd *cmd;\n\tint ret, pos = 0;\n\n\tif (ccc->id & I3C_CCC_DIRECT) {\n\t\tpos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);\n\t\tif (pos < 0)\n\t\t\treturn pos;\n\t}\n\n\txfer = dw_i3c_master_alloc_xfer(master, 1);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tcmd = xfer->cmds;\n\tcmd->tx_buf = ccc->dests[0].payload.data;\n\tcmd->tx_len = ccc->dests[0].payload.len;\n\n\tcmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(ccc->dests[0].payload.len) |\n\t\t      COMMAND_PORT_TRANSFER_ARG;\n\n\tcmd->cmd_lo = COMMAND_PORT_CP |\n\t\t      COMMAND_PORT_DEV_INDEX(pos) |\n\t\t      COMMAND_PORT_CMD(ccc->id) |\n\t\t      COMMAND_PORT_TOC |\n\t\t      COMMAND_PORT_ROC;\n\n\tdw_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))\n\t\tdw_i3c_master_dequeue_xfer(master, xfer);\n\n\tret = xfer->ret;\n\tif (xfer->cmds[0].error == RESPONSE_ERROR_IBA_NACK)\n\t\tccc->err = I3C_ERROR_M2;\n\n\tdw_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int dw_i3c_ccc_get(struct dw_i3c_master *master, struct i3c_ccc_cmd *ccc)\n{\n\tstruct dw_i3c_xfer *xfer;\n\tstruct dw_i3c_cmd *cmd;\n\tint ret, pos;\n\n\tpos = dw_i3c_master_get_addr_pos(master, ccc->dests[0].addr);\n\tif (pos < 0)\n\t\treturn pos;\n\n\txfer = dw_i3c_master_alloc_xfer(master, 1);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tcmd = xfer->cmds;\n\tcmd->rx_buf = ccc->dests[0].payload.data;\n\tcmd->rx_len = ccc->dests[0].payload.len;\n\n\tcmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(ccc->dests[0].payload.len) |\n\t\t      COMMAND_PORT_TRANSFER_ARG;\n\n\tcmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |\n\t\t      COMMAND_PORT_CP |\n\t\t      COMMAND_PORT_DEV_INDEX(pos) |\n\t\t      COMMAND_PORT_CMD(ccc->id) |\n\t\t      COMMAND_PORT_TOC |\n\t\t      COMMAND_PORT_ROC;\n\n\tdw_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))\n\t\tdw_i3c_master_dequeue_xfer(master, xfer);\n\n\tret = xfer->ret;\n\tif (xfer->cmds[0].error == RESPONSE_ERROR_IBA_NACK)\n\t\tccc->err = I3C_ERROR_M2;\n\tdw_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int dw_i3c_master_send_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\t      struct i3c_ccc_cmd *ccc)\n{\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tint ret = 0;\n\n\tif (ccc->id == I3C_CCC_ENTDAA)\n\t\treturn -EINVAL;\n\n\tif (ccc->rnw)\n\t\tret = dw_i3c_ccc_get(master, ccc);\n\telse\n\t\tret = dw_i3c_ccc_set(master, ccc);\n\n\treturn ret;\n}\n\nstatic int dw_i3c_master_daa(struct i3c_master_controller *m)\n{\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tstruct dw_i3c_xfer *xfer;\n\tstruct dw_i3c_cmd *cmd;\n\tu32 olddevs, newdevs;\n\tu8 p, last_addr = 0;\n\tint ret, pos;\n\n\tolddevs = ~(master->free_pos);\n\n\t \n\tfor (pos = 0; pos < master->maxdevs; pos++) {\n\t\tif (olddevs & BIT(pos))\n\t\t\tcontinue;\n\n\t\tret = i3c_master_get_free_addr(m, last_addr + 1);\n\t\tif (ret < 0)\n\t\t\treturn -ENOSPC;\n\n\t\tmaster->devs[pos].addr = ret;\n\t\tp = even_parity(ret);\n\t\tlast_addr = ret;\n\t\tret |= (p << 7);\n\n\t\twritel(DEV_ADDR_TABLE_DYNAMIC_ADDR(ret),\n\t\t       master->regs +\n\t\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, pos));\n\t}\n\n\txfer = dw_i3c_master_alloc_xfer(master, 1);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tpos = dw_i3c_master_get_free_pos(master);\n\tif (pos < 0) {\n\t\tdw_i3c_master_free_xfer(xfer);\n\t\treturn pos;\n\t}\n\tcmd = &xfer->cmds[0];\n\tcmd->cmd_hi = 0x1;\n\tcmd->cmd_lo = COMMAND_PORT_DEV_COUNT(master->maxdevs - pos) |\n\t\t      COMMAND_PORT_DEV_INDEX(pos) |\n\t\t      COMMAND_PORT_CMD(I3C_CCC_ENTDAA) |\n\t\t      COMMAND_PORT_ADDR_ASSGN_CMD |\n\t\t      COMMAND_PORT_TOC |\n\t\t      COMMAND_PORT_ROC;\n\n\tdw_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))\n\t\tdw_i3c_master_dequeue_xfer(master, xfer);\n\n\tnewdevs = GENMASK(master->maxdevs - cmd->rx_len - 1, 0);\n\tnewdevs &= ~olddevs;\n\n\tfor (pos = 0; pos < master->maxdevs; pos++) {\n\t\tif (newdevs & BIT(pos))\n\t\t\ti3c_master_add_i3c_dev_locked(m, master->devs[pos].addr);\n\t}\n\n\tdw_i3c_master_free_xfer(xfer);\n\n\treturn 0;\n}\n\nstatic int dw_i3c_master_priv_xfers(struct i3c_dev_desc *dev,\n\t\t\t\t    struct i3c_priv_xfer *i3c_xfers,\n\t\t\t\t    int i3c_nxfers)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tunsigned int nrxwords = 0, ntxwords = 0;\n\tstruct dw_i3c_xfer *xfer;\n\tint i, ret = 0;\n\n\tif (!i3c_nxfers)\n\t\treturn 0;\n\n\tif (i3c_nxfers > master->caps.cmdfifodepth)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < i3c_nxfers; i++) {\n\t\tif (i3c_xfers[i].rnw)\n\t\t\tnrxwords += DIV_ROUND_UP(i3c_xfers[i].len, 4);\n\t\telse\n\t\t\tntxwords += DIV_ROUND_UP(i3c_xfers[i].len, 4);\n\t}\n\n\tif (ntxwords > master->caps.datafifodepth ||\n\t    nrxwords > master->caps.datafifodepth)\n\t\treturn -ENOTSUPP;\n\n\txfer = dw_i3c_master_alloc_xfer(master, i3c_nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < i3c_nxfers; i++) {\n\t\tstruct dw_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tcmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i3c_xfers[i].len) |\n\t\t\tCOMMAND_PORT_TRANSFER_ARG;\n\n\t\tif (i3c_xfers[i].rnw) {\n\t\t\tcmd->rx_buf = i3c_xfers[i].data.in;\n\t\t\tcmd->rx_len = i3c_xfers[i].len;\n\t\t\tcmd->cmd_lo = COMMAND_PORT_READ_TRANSFER |\n\t\t\t\t      COMMAND_PORT_SPEED(dev->info.max_read_ds);\n\n\t\t} else {\n\t\t\tcmd->tx_buf = i3c_xfers[i].data.out;\n\t\t\tcmd->tx_len = i3c_xfers[i].len;\n\t\t\tcmd->cmd_lo =\n\t\t\t\tCOMMAND_PORT_SPEED(dev->info.max_write_ds);\n\t\t}\n\n\t\tcmd->cmd_lo |= COMMAND_PORT_TID(i) |\n\t\t\t       COMMAND_PORT_DEV_INDEX(data->index) |\n\t\t\t       COMMAND_PORT_ROC;\n\n\t\tif (i == (i3c_nxfers - 1))\n\t\t\tcmd->cmd_lo |= COMMAND_PORT_TOC;\n\t}\n\n\tdw_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))\n\t\tdw_i3c_master_dequeue_xfer(master, xfer);\n\n\tfor (i = 0; i < i3c_nxfers; i++) {\n\t\tstruct dw_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tif (i3c_xfers[i].rnw)\n\t\t\ti3c_xfers[i].len = cmd->rx_len;\n\t}\n\n\tret = xfer->ret;\n\tdw_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int dw_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,\n\t\t\t\t\t  u8 old_dyn_addr)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tint pos;\n\n\tpos = dw_i3c_master_get_free_pos(master);\n\n\tif (data->index > pos && pos > 0) {\n\t\twritel(0,\n\t\t       master->regs +\n\t\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\t\tmaster->devs[data->index].addr = 0;\n\t\tmaster->free_pos |= BIT(data->index);\n\n\t\tdata->index = pos;\n\t\tmaster->devs[pos].addr = dev->info.dyn_addr;\n\t\tmaster->free_pos &= ~BIT(pos);\n\t}\n\n\twritel(DEV_ADDR_TABLE_DYNAMIC_ADDR(dev->info.dyn_addr),\n\t       master->regs +\n\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\tmaster->devs[data->index].addr = dev->info.dyn_addr;\n\n\treturn 0;\n}\n\nstatic int dw_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tstruct dw_i3c_i2c_dev_data *data;\n\tint pos;\n\n\tpos = dw_i3c_master_get_free_pos(master);\n\tif (pos < 0)\n\t\treturn pos;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->index = pos;\n\tmaster->devs[pos].addr = dev->info.dyn_addr ? : dev->info.static_addr;\n\tmaster->free_pos &= ~BIT(pos);\n\ti3c_dev_set_master_data(dev, data);\n\n\twritel(DEV_ADDR_TABLE_DYNAMIC_ADDR(master->devs[pos].addr),\n\t       master->regs +\n\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\treturn 0;\n}\n\nstatic void dw_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\n\twritel(0,\n\t       master->regs +\n\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\ti3c_dev_set_master_data(dev, NULL);\n\tmaster->devs[data->index].addr = 0;\n\tmaster->free_pos |= BIT(data->index);\n\tkfree(data);\n}\n\nstatic int dw_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,\n\t\t\t\t   const struct i2c_msg *i2c_xfers,\n\t\t\t\t   int i2c_nxfers)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tunsigned int nrxwords = 0, ntxwords = 0;\n\tstruct dw_i3c_xfer *xfer;\n\tint i, ret = 0;\n\n\tif (!i2c_nxfers)\n\t\treturn 0;\n\n\tif (i2c_nxfers > master->caps.cmdfifodepth)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < i2c_nxfers; i++) {\n\t\tif (i2c_xfers[i].flags & I2C_M_RD)\n\t\t\tnrxwords += DIV_ROUND_UP(i2c_xfers[i].len, 4);\n\t\telse\n\t\t\tntxwords += DIV_ROUND_UP(i2c_xfers[i].len, 4);\n\t}\n\n\tif (ntxwords > master->caps.datafifodepth ||\n\t    nrxwords > master->caps.datafifodepth)\n\t\treturn -ENOTSUPP;\n\n\txfer = dw_i3c_master_alloc_xfer(master, i2c_nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < i2c_nxfers; i++) {\n\t\tstruct dw_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tcmd->cmd_hi = COMMAND_PORT_ARG_DATA_LEN(i2c_xfers[i].len) |\n\t\t\tCOMMAND_PORT_TRANSFER_ARG;\n\n\t\tcmd->cmd_lo = COMMAND_PORT_TID(i) |\n\t\t\t      COMMAND_PORT_DEV_INDEX(data->index) |\n\t\t\t      COMMAND_PORT_ROC;\n\n\t\tif (i2c_xfers[i].flags & I2C_M_RD) {\n\t\t\tcmd->cmd_lo |= COMMAND_PORT_READ_TRANSFER;\n\t\t\tcmd->rx_buf = i2c_xfers[i].buf;\n\t\t\tcmd->rx_len = i2c_xfers[i].len;\n\t\t} else {\n\t\t\tcmd->tx_buf = i2c_xfers[i].buf;\n\t\t\tcmd->tx_len = i2c_xfers[i].len;\n\t\t}\n\n\t\tif (i == (i2c_nxfers - 1))\n\t\t\tcmd->cmd_lo |= COMMAND_PORT_TOC;\n\t}\n\n\tdw_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, XFER_TIMEOUT))\n\t\tdw_i3c_master_dequeue_xfer(master, xfer);\n\n\tret = xfer->ret;\n\tdw_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int dw_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tstruct dw_i3c_i2c_dev_data *data;\n\tint pos;\n\n\tpos = dw_i3c_master_get_free_pos(master);\n\tif (pos < 0)\n\t\treturn pos;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->index = pos;\n\tmaster->devs[pos].addr = dev->addr;\n\tmaster->free_pos &= ~BIT(pos);\n\ti2c_dev_set_master_data(dev, data);\n\n\twritel(DEV_ADDR_TABLE_LEGACY_I2C_DEV |\n\t       DEV_ADDR_TABLE_STATIC_ADDR(dev->addr),\n\t       master->regs +\n\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\treturn 0;\n}\n\nstatic void dw_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\n\twritel(0,\n\t       master->regs +\n\t       DEV_ADDR_TABLE_LOC(master->datstartaddr, data->index));\n\n\ti2c_dev_set_master_data(dev, NULL);\n\tmaster->devs[data->index].addr = 0;\n\tmaster->free_pos |= BIT(data->index);\n\tkfree(data);\n}\n\nstatic int dw_i3c_master_request_ibi(struct i3c_dev_desc *dev,\n\t\t\t\t     const struct i3c_ibi_setup *req)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tunsigned long flags;\n\n\tdata->ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);\n\tif (IS_ERR(data->ibi_pool))\n\t\treturn PTR_ERR(data->ibi_pool);\n\n\tspin_lock_irqsave(&master->devs_lock, flags);\n\tmaster->devs[data->index].ibi_dev = dev;\n\tspin_unlock_irqrestore(&master->devs_lock, flags);\n\n\treturn 0;\n}\n\nstatic void dw_i3c_master_free_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->devs_lock, flags);\n\tmaster->devs[data->index].ibi_dev = NULL;\n\tspin_unlock_irqrestore(&master->devs_lock, flags);\n\n\ti3c_generic_ibi_free_pool(data->ibi_pool);\n\tdata->ibi_pool = NULL;\n}\n\nstatic void dw_i3c_master_set_sir_enabled(struct dw_i3c_master *master,\n\t\t\t\t\t  struct i3c_dev_desc *dev,\n\t\t\t\t\t  u8 idx, bool enable)\n{\n\tunsigned long flags;\n\tu32 dat_entry, reg;\n\tbool global;\n\n\tdat_entry = DEV_ADDR_TABLE_LOC(master->datstartaddr, idx);\n\n\tspin_lock_irqsave(&master->devs_lock, flags);\n\treg = readl(master->regs + dat_entry);\n\tif (enable) {\n\t\treg &= ~DEV_ADDR_TABLE_SIR_REJECT;\n\t\tif (dev->info.bcr & I3C_BCR_IBI_PAYLOAD)\n\t\t\treg |= DEV_ADDR_TABLE_IBI_MDB;\n\t} else {\n\t\treg |= DEV_ADDR_TABLE_SIR_REJECT;\n\t}\n\tmaster->platform_ops->set_dat_ibi(master, dev, enable, &reg);\n\twritel(reg, master->regs + dat_entry);\n\n\treg = readl(master->regs + IBI_SIR_REQ_REJECT);\n\tif (enable) {\n\t\tglobal = reg == 0xffffffff;\n\t\treg &= ~BIT(idx);\n\t} else {\n\t\tglobal = reg == 0;\n\t\treg |= BIT(idx);\n\t}\n\twritel(reg, master->regs + IBI_SIR_REQ_REJECT);\n\n\tif (global) {\n\t\treg = readl(master->regs + INTR_STATUS_EN);\n\t\treg &= ~INTR_IBI_THLD_STAT;\n\t\tif (enable)\n\t\t\treg |= INTR_IBI_THLD_STAT;\n\t\twritel(reg, master->regs + INTR_STATUS_EN);\n\n\t\treg = readl(master->regs + INTR_SIGNAL_EN);\n\t\treg &= ~INTR_IBI_THLD_STAT;\n\t\tif (enable)\n\t\t\treg |= INTR_IBI_THLD_STAT;\n\t\twritel(reg, master->regs + INTR_SIGNAL_EN);\n\t}\n\n\tspin_unlock_irqrestore(&master->devs_lock, flags);\n}\n\nstatic int dw_i3c_master_enable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tint rc;\n\n\tdw_i3c_master_set_sir_enabled(master, dev, data->index, true);\n\n\trc = i3c_master_enec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n\n\tif (rc)\n\t\tdw_i3c_master_set_sir_enabled(master, dev, data->index, false);\n\n\treturn rc;\n}\n\nstatic int dw_i3c_master_disable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct dw_i3c_master *master = to_dw_i3c_master(m);\n\tint rc;\n\n\trc = i3c_master_disec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n\tif (rc)\n\t\treturn rc;\n\n\tdw_i3c_master_set_sir_enabled(master, dev, data->index, false);\n\n\treturn 0;\n}\n\nstatic void dw_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev,\n\t\t\t\t\t   struct i3c_ibi_slot *slot)\n{\n\tstruct dw_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\n\ti3c_generic_ibi_recycle_slot(data->ibi_pool, slot);\n}\n\nstatic void dw_i3c_master_drain_ibi_queue(struct dw_i3c_master *master,\n\t\t\t\t\t  int len)\n{\n\tint i;\n\n\tfor (i = 0; i < DIV_ROUND_UP(len, 4); i++)\n\t\treadl(master->regs + IBI_QUEUE_STATUS);\n}\n\nstatic void dw_i3c_master_handle_ibi_sir(struct dw_i3c_master *master,\n\t\t\t\t\t u32 status)\n{\n\tstruct dw_i3c_i2c_dev_data *data;\n\tstruct i3c_ibi_slot *slot;\n\tstruct i3c_dev_desc *dev;\n\tunsigned long flags;\n\tu8 addr, len;\n\tint idx;\n\n\taddr = IBI_QUEUE_IBI_ADDR(status);\n\tlen = IBI_QUEUE_STATUS_DATA_LEN(status);\n\n\t \n\n\tspin_lock_irqsave(&master->devs_lock, flags);\n\tidx = dw_i3c_master_get_addr_pos(master, addr);\n\tif (idx < 0) {\n\t\tdev_dbg_ratelimited(&master->base.dev,\n\t\t\t \"IBI from unknown addr 0x%x\\n\", addr);\n\t\tgoto err_drain;\n\t}\n\n\tdev = master->devs[idx].ibi_dev;\n\tif (!dev || !dev->ibi) {\n\t\tdev_dbg_ratelimited(&master->base.dev,\n\t\t\t \"IBI from non-requested dev idx %d\\n\", idx);\n\t\tgoto err_drain;\n\t}\n\n\tdata = i3c_dev_get_master_data(dev);\n\tslot = i3c_generic_ibi_get_free_slot(data->ibi_pool);\n\tif (!slot) {\n\t\tdev_dbg_ratelimited(&master->base.dev,\n\t\t\t\t    \"No IBI slots available\\n\");\n\t\tgoto err_drain;\n\t}\n\n\tif (dev->ibi->max_payload_len < len) {\n\t\tdev_dbg_ratelimited(&master->base.dev,\n\t\t\t\t    \"IBI payload len %d greater than max %d\\n\",\n\t\t\t\t    len, dev->ibi->max_payload_len);\n\t\tgoto err_drain;\n\t}\n\n\tif (len) {\n\t\tdw_i3c_master_read_ibi_fifo(master, slot->data, len);\n\t\tslot->len = len;\n\t}\n\ti3c_master_queue_ibi(dev, slot);\n\n\tspin_unlock_irqrestore(&master->devs_lock, flags);\n\n\treturn;\n\nerr_drain:\n\tdw_i3c_master_drain_ibi_queue(master, len);\n\n\tspin_unlock_irqrestore(&master->devs_lock, flags);\n}\n\n \nstatic void dw_i3c_master_irq_handle_ibis(struct dw_i3c_master *master)\n{\n\tunsigned int i, len, n_ibis;\n\tu32 reg;\n\n\treg = readl(master->regs + QUEUE_STATUS_LEVEL);\n\tn_ibis = QUEUE_STATUS_IBI_STATUS_CNT(reg);\n\tif (!n_ibis)\n\t\treturn;\n\n\tfor (i = 0; i < n_ibis; i++) {\n\t\treg = readl(master->regs + IBI_QUEUE_STATUS);\n\n\t\tif (IBI_TYPE_SIRQ(reg)) {\n\t\t\tdw_i3c_master_handle_ibi_sir(master, reg);\n\t\t} else {\n\t\t\tlen = IBI_QUEUE_STATUS_DATA_LEN(reg);\n\t\t\tdev_info(&master->base.dev,\n\t\t\t\t \"unsupported IBI type 0x%lx len %d\\n\",\n\t\t\t\t IBI_QUEUE_STATUS_IBI_ID(reg), len);\n\t\t\tdw_i3c_master_drain_ibi_queue(master, len);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t dw_i3c_master_irq_handler(int irq, void *dev_id)\n{\n\tstruct dw_i3c_master *master = dev_id;\n\tu32 status;\n\n\tstatus = readl(master->regs + INTR_STATUS);\n\n\tif (!(status & readl(master->regs + INTR_STATUS_EN))) {\n\t\twritel(INTR_ALL, master->regs + INTR_STATUS);\n\t\treturn IRQ_NONE;\n\t}\n\n\tspin_lock(&master->xferqueue.lock);\n\tdw_i3c_master_end_xfer_locked(master, status);\n\tif (status & INTR_TRANSFER_ERR_STAT)\n\t\twritel(INTR_TRANSFER_ERR_STAT, master->regs + INTR_STATUS);\n\tspin_unlock(&master->xferqueue.lock);\n\n\tif (status & INTR_IBI_THLD_STAT)\n\t\tdw_i3c_master_irq_handle_ibis(master);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct i3c_master_controller_ops dw_mipi_i3c_ops = {\n\t.bus_init = dw_i3c_master_bus_init,\n\t.bus_cleanup = dw_i3c_master_bus_cleanup,\n\t.attach_i3c_dev = dw_i3c_master_attach_i3c_dev,\n\t.reattach_i3c_dev = dw_i3c_master_reattach_i3c_dev,\n\t.detach_i3c_dev = dw_i3c_master_detach_i3c_dev,\n\t.do_daa = dw_i3c_master_daa,\n\t.supports_ccc_cmd = dw_i3c_master_supports_ccc_cmd,\n\t.send_ccc_cmd = dw_i3c_master_send_ccc_cmd,\n\t.priv_xfers = dw_i3c_master_priv_xfers,\n\t.attach_i2c_dev = dw_i3c_master_attach_i2c_dev,\n\t.detach_i2c_dev = dw_i3c_master_detach_i2c_dev,\n\t.i2c_xfers = dw_i3c_master_i2c_xfers,\n};\n\nstatic const struct i3c_master_controller_ops dw_mipi_i3c_ibi_ops = {\n\t.bus_init = dw_i3c_master_bus_init,\n\t.bus_cleanup = dw_i3c_master_bus_cleanup,\n\t.attach_i3c_dev = dw_i3c_master_attach_i3c_dev,\n\t.reattach_i3c_dev = dw_i3c_master_reattach_i3c_dev,\n\t.detach_i3c_dev = dw_i3c_master_detach_i3c_dev,\n\t.do_daa = dw_i3c_master_daa,\n\t.supports_ccc_cmd = dw_i3c_master_supports_ccc_cmd,\n\t.send_ccc_cmd = dw_i3c_master_send_ccc_cmd,\n\t.priv_xfers = dw_i3c_master_priv_xfers,\n\t.attach_i2c_dev = dw_i3c_master_attach_i2c_dev,\n\t.detach_i2c_dev = dw_i3c_master_detach_i2c_dev,\n\t.i2c_xfers = dw_i3c_master_i2c_xfers,\n\t.request_ibi = dw_i3c_master_request_ibi,\n\t.free_ibi = dw_i3c_master_free_ibi,\n\t.enable_ibi = dw_i3c_master_enable_ibi,\n\t.disable_ibi = dw_i3c_master_disable_ibi,\n\t.recycle_ibi_slot = dw_i3c_master_recycle_ibi_slot,\n};\n\n \nstatic int dw_i3c_platform_init_nop(struct dw_i3c_master *i3c)\n{\n\treturn 0;\n}\n\nstatic void dw_i3c_platform_set_dat_ibi_nop(struct dw_i3c_master *i3c,\n\t\t\t\t\tstruct i3c_dev_desc *dev,\n\t\t\t\t\tbool enable, u32 *dat)\n{\n}\n\nstatic const struct dw_i3c_platform_ops dw_i3c_platform_ops_default = {\n\t.init = dw_i3c_platform_init_nop,\n\t.set_dat_ibi = dw_i3c_platform_set_dat_ibi_nop,\n};\n\nint dw_i3c_common_probe(struct dw_i3c_master *master,\n\t\t\tstruct platform_device *pdev)\n{\n\tconst struct i3c_master_controller_ops *ops;\n\tint ret, irq;\n\n\tif (!master->platform_ops)\n\t\tmaster->platform_ops = &dw_i3c_platform_ops_default;\n\n\tmaster->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(master->regs))\n\t\treturn PTR_ERR(master->regs);\n\n\tmaster->core_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(master->core_clk))\n\t\treturn PTR_ERR(master->core_clk);\n\n\tmaster->core_rst = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t    \"core_rst\");\n\tif (IS_ERR(master->core_rst))\n\t\treturn PTR_ERR(master->core_rst);\n\n\tret = clk_prepare_enable(master->core_clk);\n\tif (ret)\n\t\tgoto err_disable_core_clk;\n\n\treset_control_deassert(master->core_rst);\n\n\tspin_lock_init(&master->xferqueue.lock);\n\tINIT_LIST_HEAD(&master->xferqueue.list);\n\n\twritel(INTR_ALL, master->regs + INTR_STATUS);\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq,\n\t\t\t       dw_i3c_master_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), master);\n\tif (ret)\n\t\tgoto err_assert_rst;\n\n\tplatform_set_drvdata(pdev, master);\n\n\t \n\tret = readl(master->regs + QUEUE_STATUS_LEVEL);\n\tmaster->caps.cmdfifodepth = QUEUE_STATUS_LEVEL_CMD(ret);\n\n\tret = readl(master->regs + DATA_BUFFER_STATUS_LEVEL);\n\tmaster->caps.datafifodepth = DATA_BUFFER_STATUS_LEVEL_TX(ret);\n\n\tret = readl(master->regs + DEVICE_ADDR_TABLE_POINTER);\n\tmaster->datstartaddr = ret;\n\tmaster->maxdevs = ret >> 16;\n\tmaster->free_pos = GENMASK(master->maxdevs - 1, 0);\n\n\tops = &dw_mipi_i3c_ops;\n\tif (master->ibi_capable)\n\t\tops = &dw_mipi_i3c_ibi_ops;\n\n\tret = i3c_master_register(&master->base, &pdev->dev, ops, false);\n\tif (ret)\n\t\tgoto err_assert_rst;\n\n\treturn 0;\n\nerr_assert_rst:\n\treset_control_assert(master->core_rst);\n\nerr_disable_core_clk:\n\tclk_disable_unprepare(master->core_clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(dw_i3c_common_probe);\n\nvoid dw_i3c_common_remove(struct dw_i3c_master *master)\n{\n\ti3c_master_unregister(&master->base);\n\n\treset_control_assert(master->core_rst);\n\n\tclk_disable_unprepare(master->core_clk);\n}\nEXPORT_SYMBOL_GPL(dw_i3c_common_remove);\n\n \n\nstatic int dw_i3c_probe(struct platform_device *pdev)\n{\n\tstruct dw_i3c_master *master;\n\n\tmaster = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\treturn dw_i3c_common_probe(master, pdev);\n}\n\nstatic void dw_i3c_remove(struct platform_device *pdev)\n{\n\tstruct dw_i3c_master *master = platform_get_drvdata(pdev);\n\n\tdw_i3c_common_remove(master);\n}\n\nstatic const struct of_device_id dw_i3c_master_of_match[] = {\n\t{ .compatible = \"snps,dw-i3c-master-1.00a\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_i3c_master_of_match);\n\nstatic struct platform_driver dw_i3c_driver = {\n\t.probe = dw_i3c_probe,\n\t.remove_new = dw_i3c_remove,\n\t.driver = {\n\t\t.name = \"dw-i3c-master\",\n\t\t.of_match_table = dw_i3c_master_of_match,\n\t},\n};\nmodule_platform_driver(dw_i3c_driver);\n\nMODULE_AUTHOR(\"Vitor Soares <vitor.soares@synopsys.com>\");\nMODULE_DESCRIPTION(\"DesignWare MIPI I3C driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}