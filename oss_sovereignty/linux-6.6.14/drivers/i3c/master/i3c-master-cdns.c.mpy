{
  "module_name": "i3c-master-cdns.c",
  "hash_id": "0473ab93ec081169729fe3b25c2b6200a88b351530e1f0180fe98e562cd79adf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/i3c-master-cdns.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#define DEV_ID\t\t\t\t0x0\n#define DEV_ID_I3C_MASTER\t\t0x5034\n\n#define CONF_STATUS0\t\t\t0x4\n#define CONF_STATUS0_CMDR_DEPTH(x)\t(4 << (((x) & GENMASK(31, 29)) >> 29))\n#define CONF_STATUS0_ECC_CHK\t\tBIT(28)\n#define CONF_STATUS0_INTEG_CHK\t\tBIT(27)\n#define CONF_STATUS0_CSR_DAP_CHK\tBIT(26)\n#define CONF_STATUS0_TRANS_TOUT_CHK\tBIT(25)\n#define CONF_STATUS0_PROT_FAULTS_CHK\tBIT(24)\n#define CONF_STATUS0_GPO_NUM(x)\t\t(((x) & GENMASK(23, 16)) >> 16)\n#define CONF_STATUS0_GPI_NUM(x)\t\t(((x) & GENMASK(15, 8)) >> 8)\n#define CONF_STATUS0_IBIR_DEPTH(x)\t(4 << (((x) & GENMASK(7, 6)) >> 7))\n#define CONF_STATUS0_SUPPORTS_DDR\tBIT(5)\n#define CONF_STATUS0_SEC_MASTER\t\tBIT(4)\n#define CONF_STATUS0_DEVS_NUM(x)\t((x) & GENMASK(3, 0))\n\n#define CONF_STATUS1\t\t\t0x8\n#define CONF_STATUS1_IBI_HW_RES(x)\t((((x) & GENMASK(31, 28)) >> 28) + 1)\n#define CONF_STATUS1_CMD_DEPTH(x)\t(4 << (((x) & GENMASK(27, 26)) >> 26))\n#define CONF_STATUS1_SLVDDR_RX_DEPTH(x)\t(8 << (((x) & GENMASK(25, 21)) >> 21))\n#define CONF_STATUS1_SLVDDR_TX_DEPTH(x)\t(8 << (((x) & GENMASK(20, 16)) >> 16))\n#define CONF_STATUS1_IBI_DEPTH(x)\t(2 << (((x) & GENMASK(12, 10)) >> 10))\n#define CONF_STATUS1_RX_DEPTH(x)\t(8 << (((x) & GENMASK(9, 5)) >> 5))\n#define CONF_STATUS1_TX_DEPTH(x)\t(8 << ((x) & GENMASK(4, 0)))\n\n#define REV_ID\t\t\t\t0xc\n#define REV_ID_VID(id)\t\t\t(((id) & GENMASK(31, 20)) >> 20)\n#define REV_ID_PID(id)\t\t\t(((id) & GENMASK(19, 8)) >> 8)\n#define REV_ID_REV_MAJOR(id)\t\t(((id) & GENMASK(7, 4)) >> 4)\n#define REV_ID_REV_MINOR(id)\t\t((id) & GENMASK(3, 0))\n\n#define CTRL\t\t\t\t0x10\n#define CTRL_DEV_EN\t\t\tBIT(31)\n#define CTRL_HALT_EN\t\t\tBIT(30)\n#define CTRL_MCS\t\t\tBIT(29)\n#define CTRL_MCS_EN\t\t\tBIT(28)\n#define CTRL_THD_DELAY(x)\t\t(((x) << 24) & GENMASK(25, 24))\n#define CTRL_HJ_DISEC\t\t\tBIT(8)\n#define CTRL_MST_ACK\t\t\tBIT(7)\n#define CTRL_HJ_ACK\t\t\tBIT(6)\n#define CTRL_HJ_INIT\t\t\tBIT(5)\n#define CTRL_MST_INIT\t\t\tBIT(4)\n#define CTRL_AHDR_OPT\t\t\tBIT(3)\n#define CTRL_PURE_BUS_MODE\t\t0\n#define CTRL_MIXED_FAST_BUS_MODE\t2\n#define CTRL_MIXED_SLOW_BUS_MODE\t3\n#define CTRL_BUS_MODE_MASK\t\tGENMASK(1, 0)\n#define THD_DELAY_MAX\t\t\t3\n\n#define PRESCL_CTRL0\t\t\t0x14\n#define PRESCL_CTRL0_I2C(x)\t\t((x) << 16)\n#define PRESCL_CTRL0_I3C(x)\t\t(x)\n#define PRESCL_CTRL0_MAX\t\tGENMASK(9, 0)\n\n#define PRESCL_CTRL1\t\t\t0x18\n#define PRESCL_CTRL1_PP_LOW_MASK\tGENMASK(15, 8)\n#define PRESCL_CTRL1_PP_LOW(x)\t\t((x) << 8)\n#define PRESCL_CTRL1_OD_LOW_MASK\tGENMASK(7, 0)\n#define PRESCL_CTRL1_OD_LOW(x)\t\t(x)\n\n#define MST_IER\t\t\t\t0x20\n#define MST_IDR\t\t\t\t0x24\n#define MST_IMR\t\t\t\t0x28\n#define MST_ICR\t\t\t\t0x2c\n#define MST_ISR\t\t\t\t0x30\n#define MST_INT_HALTED\t\t\tBIT(18)\n#define MST_INT_MR_DONE\t\t\tBIT(17)\n#define MST_INT_IMM_COMP\t\tBIT(16)\n#define MST_INT_TX_THR\t\t\tBIT(15)\n#define MST_INT_TX_OVF\t\t\tBIT(14)\n#define MST_INT_IBID_THR\t\tBIT(12)\n#define MST_INT_IBID_UNF\t\tBIT(11)\n#define MST_INT_IBIR_THR\t\tBIT(10)\n#define MST_INT_IBIR_UNF\t\tBIT(9)\n#define MST_INT_IBIR_OVF\t\tBIT(8)\n#define MST_INT_RX_THR\t\t\tBIT(7)\n#define MST_INT_RX_UNF\t\t\tBIT(6)\n#define MST_INT_CMDD_EMP\t\tBIT(5)\n#define MST_INT_CMDD_THR\t\tBIT(4)\n#define MST_INT_CMDD_OVF\t\tBIT(3)\n#define MST_INT_CMDR_THR\t\tBIT(2)\n#define MST_INT_CMDR_UNF\t\tBIT(1)\n#define MST_INT_CMDR_OVF\t\tBIT(0)\n\n#define MST_STATUS0\t\t\t0x34\n#define MST_STATUS0_IDLE\t\tBIT(18)\n#define MST_STATUS0_HALTED\t\tBIT(17)\n#define MST_STATUS0_MASTER_MODE\t\tBIT(16)\n#define MST_STATUS0_TX_FULL\t\tBIT(13)\n#define MST_STATUS0_IBID_FULL\t\tBIT(12)\n#define MST_STATUS0_IBIR_FULL\t\tBIT(11)\n#define MST_STATUS0_RX_FULL\t\tBIT(10)\n#define MST_STATUS0_CMDD_FULL\t\tBIT(9)\n#define MST_STATUS0_CMDR_FULL\t\tBIT(8)\n#define MST_STATUS0_TX_EMP\t\tBIT(5)\n#define MST_STATUS0_IBID_EMP\t\tBIT(4)\n#define MST_STATUS0_IBIR_EMP\t\tBIT(3)\n#define MST_STATUS0_RX_EMP\t\tBIT(2)\n#define MST_STATUS0_CMDD_EMP\t\tBIT(1)\n#define MST_STATUS0_CMDR_EMP\t\tBIT(0)\n\n#define CMDR\t\t\t\t0x38\n#define CMDR_NO_ERROR\t\t\t0\n#define CMDR_DDR_PREAMBLE_ERROR\t\t1\n#define CMDR_DDR_PARITY_ERROR\t\t2\n#define CMDR_DDR_RX_FIFO_OVF\t\t3\n#define CMDR_DDR_TX_FIFO_UNF\t\t4\n#define CMDR_M0_ERROR\t\t\t5\n#define CMDR_M1_ERROR\t\t\t6\n#define CMDR_M2_ERROR\t\t\t7\n#define CMDR_MST_ABORT\t\t\t8\n#define CMDR_NACK_RESP\t\t\t9\n#define CMDR_INVALID_DA\t\t\t10\n#define CMDR_DDR_DROPPED\t\t11\n#define CMDR_ERROR(x)\t\t\t(((x) & GENMASK(27, 24)) >> 24)\n#define CMDR_XFER_BYTES(x)\t\t(((x) & GENMASK(19, 8)) >> 8)\n#define CMDR_CMDID_HJACK_DISEC\t\t0xfe\n#define CMDR_CMDID_HJACK_ENTDAA\t\t0xff\n#define CMDR_CMDID(x)\t\t\t((x) & GENMASK(7, 0))\n\n#define IBIR\t\t\t\t0x3c\n#define IBIR_ACKED\t\t\tBIT(12)\n#define IBIR_SLVID(x)\t\t\t(((x) & GENMASK(11, 8)) >> 8)\n#define IBIR_ERROR\t\t\tBIT(7)\n#define IBIR_XFER_BYTES(x)\t\t(((x) & GENMASK(6, 2)) >> 2)\n#define IBIR_TYPE_IBI\t\t\t0\n#define IBIR_TYPE_HJ\t\t\t1\n#define IBIR_TYPE_MR\t\t\t2\n#define IBIR_TYPE(x)\t\t\t((x) & GENMASK(1, 0))\n\n#define SLV_IER\t\t\t\t0x40\n#define SLV_IDR\t\t\t\t0x44\n#define SLV_IMR\t\t\t\t0x48\n#define SLV_ICR\t\t\t\t0x4c\n#define SLV_ISR\t\t\t\t0x50\n#define SLV_INT_TM\t\t\tBIT(20)\n#define SLV_INT_ERROR\t\t\tBIT(19)\n#define SLV_INT_EVENT_UP\t\tBIT(18)\n#define SLV_INT_HJ_DONE\t\t\tBIT(17)\n#define SLV_INT_MR_DONE\t\t\tBIT(16)\n#define SLV_INT_DA_UPD\t\t\tBIT(15)\n#define SLV_INT_SDR_FAIL\t\tBIT(14)\n#define SLV_INT_DDR_FAIL\t\tBIT(13)\n#define SLV_INT_M_RD_ABORT\t\tBIT(12)\n#define SLV_INT_DDR_RX_THR\t\tBIT(11)\n#define SLV_INT_DDR_TX_THR\t\tBIT(10)\n#define SLV_INT_SDR_RX_THR\t\tBIT(9)\n#define SLV_INT_SDR_TX_THR\t\tBIT(8)\n#define SLV_INT_DDR_RX_UNF\t\tBIT(7)\n#define SLV_INT_DDR_TX_OVF\t\tBIT(6)\n#define SLV_INT_SDR_RX_UNF\t\tBIT(5)\n#define SLV_INT_SDR_TX_OVF\t\tBIT(4)\n#define SLV_INT_DDR_RD_COMP\t\tBIT(3)\n#define SLV_INT_DDR_WR_COMP\t\tBIT(2)\n#define SLV_INT_SDR_RD_COMP\t\tBIT(1)\n#define SLV_INT_SDR_WR_COMP\t\tBIT(0)\n\n#define SLV_STATUS0\t\t\t0x54\n#define SLV_STATUS0_REG_ADDR(s)\t\t(((s) & GENMASK(23, 16)) >> 16)\n#define SLV_STATUS0_XFRD_BYTES(s)\t((s) & GENMASK(15, 0))\n\n#define SLV_STATUS1\t\t\t0x58\n#define SLV_STATUS1_AS(s)\t\t(((s) & GENMASK(21, 20)) >> 20)\n#define SLV_STATUS1_VEN_TM\t\tBIT(19)\n#define SLV_STATUS1_HJ_DIS\t\tBIT(18)\n#define SLV_STATUS1_MR_DIS\t\tBIT(17)\n#define SLV_STATUS1_PROT_ERR\t\tBIT(16)\n#define SLV_STATUS1_DA(s)\t\t(((s) & GENMASK(15, 9)) >> 9)\n#define SLV_STATUS1_HAS_DA\t\tBIT(8)\n#define SLV_STATUS1_DDR_RX_FULL\t\tBIT(7)\n#define SLV_STATUS1_DDR_TX_FULL\t\tBIT(6)\n#define SLV_STATUS1_DDR_RX_EMPTY\tBIT(5)\n#define SLV_STATUS1_DDR_TX_EMPTY\tBIT(4)\n#define SLV_STATUS1_SDR_RX_FULL\t\tBIT(3)\n#define SLV_STATUS1_SDR_TX_FULL\t\tBIT(2)\n#define SLV_STATUS1_SDR_RX_EMPTY\tBIT(1)\n#define SLV_STATUS1_SDR_TX_EMPTY\tBIT(0)\n\n#define CMD0_FIFO\t\t\t0x60\n#define CMD0_FIFO_IS_DDR\t\tBIT(31)\n#define CMD0_FIFO_IS_CCC\t\tBIT(30)\n#define CMD0_FIFO_BCH\t\t\tBIT(29)\n#define XMIT_BURST_STATIC_SUBADDR\t0\n#define XMIT_SINGLE_INC_SUBADDR\t\t1\n#define XMIT_SINGLE_STATIC_SUBADDR\t2\n#define XMIT_BURST_WITHOUT_SUBADDR\t3\n#define CMD0_FIFO_PRIV_XMIT_MODE(m)\t((m) << 27)\n#define CMD0_FIFO_SBCA\t\t\tBIT(26)\n#define CMD0_FIFO_RSBC\t\t\tBIT(25)\n#define CMD0_FIFO_IS_10B\t\tBIT(24)\n#define CMD0_FIFO_PL_LEN(l)\t\t((l) << 12)\n#define CMD0_FIFO_PL_LEN_MAX\t\t4095\n#define CMD0_FIFO_DEV_ADDR(a)\t\t((a) << 1)\n#define CMD0_FIFO_RNW\t\t\tBIT(0)\n\n#define CMD1_FIFO\t\t\t0x64\n#define CMD1_FIFO_CMDID(id)\t\t((id) << 24)\n#define CMD1_FIFO_CSRADDR(a)\t\t(a)\n#define CMD1_FIFO_CCC(id)\t\t(id)\n\n#define TX_FIFO\t\t\t\t0x68\n\n#define IMD_CMD0\t\t\t0x70\n#define IMD_CMD0_PL_LEN(l)\t\t((l) << 12)\n#define IMD_CMD0_DEV_ADDR(a)\t\t((a) << 1)\n#define IMD_CMD0_RNW\t\t\tBIT(0)\n\n#define IMD_CMD1\t\t\t0x74\n#define IMD_CMD1_CCC(id)\t\t(id)\n\n#define IMD_DATA\t\t\t0x78\n#define RX_FIFO\t\t\t\t0x80\n#define IBI_DATA_FIFO\t\t\t0x84\n#define SLV_DDR_TX_FIFO\t\t\t0x88\n#define SLV_DDR_RX_FIFO\t\t\t0x8c\n\n#define CMD_IBI_THR_CTRL\t\t0x90\n#define IBIR_THR(t)\t\t\t((t) << 24)\n#define CMDR_THR(t)\t\t\t((t) << 16)\n#define IBI_THR(t)\t\t\t((t) << 8)\n#define CMD_THR(t)\t\t\t(t)\n\n#define TX_RX_THR_CTRL\t\t\t0x94\n#define RX_THR(t)\t\t\t((t) << 16)\n#define TX_THR(t)\t\t\t(t)\n\n#define SLV_DDR_TX_RX_THR_CTRL\t\t0x98\n#define SLV_DDR_RX_THR(t)\t\t((t) << 16)\n#define SLV_DDR_TX_THR(t)\t\t(t)\n\n#define FLUSH_CTRL\t\t\t0x9c\n#define FLUSH_IBI_RESP\t\t\tBIT(23)\n#define FLUSH_CMD_RESP\t\t\tBIT(22)\n#define FLUSH_SLV_DDR_RX_FIFO\t\tBIT(22)\n#define FLUSH_SLV_DDR_TX_FIFO\t\tBIT(21)\n#define FLUSH_IMM_FIFO\t\t\tBIT(20)\n#define FLUSH_IBI_FIFO\t\t\tBIT(19)\n#define FLUSH_RX_FIFO\t\t\tBIT(18)\n#define FLUSH_TX_FIFO\t\t\tBIT(17)\n#define FLUSH_CMD_FIFO\t\t\tBIT(16)\n\n#define TTO_PRESCL_CTRL0\t\t0xb0\n#define TTO_PRESCL_CTRL0_DIVB(x)\t((x) << 16)\n#define TTO_PRESCL_CTRL0_DIVA(x)\t(x)\n\n#define TTO_PRESCL_CTRL1\t\t0xb4\n#define TTO_PRESCL_CTRL1_DIVB(x)\t((x) << 16)\n#define TTO_PRESCL_CTRL1_DIVA(x)\t(x)\n\n#define DEVS_CTRL\t\t\t0xb8\n#define DEVS_CTRL_DEV_CLR_SHIFT\t\t16\n#define DEVS_CTRL_DEV_CLR_ALL\t\tGENMASK(31, 16)\n#define DEVS_CTRL_DEV_CLR(dev)\t\tBIT(16 + (dev))\n#define DEVS_CTRL_DEV_ACTIVE(dev)\tBIT(dev)\n#define DEVS_CTRL_DEVS_ACTIVE_MASK\tGENMASK(15, 0)\n#define MAX_DEVS\t\t\t16\n\n#define DEV_ID_RR0(d)\t\t\t(0xc0 + ((d) * 0x10))\n#define DEV_ID_RR0_LVR_EXT_ADDR\t\tBIT(11)\n#define DEV_ID_RR0_HDR_CAP\t\tBIT(10)\n#define DEV_ID_RR0_IS_I3C\t\tBIT(9)\n#define DEV_ID_RR0_DEV_ADDR_MASK\t(GENMASK(6, 0) | GENMASK(15, 13))\n#define DEV_ID_RR0_SET_DEV_ADDR(a)\t(((a) & GENMASK(6, 0)) |\t\\\n\t\t\t\t\t (((a) & GENMASK(9, 7)) << 6))\n#define DEV_ID_RR0_GET_DEV_ADDR(x)\t((((x) >> 1) & GENMASK(6, 0)) |\t\\\n\t\t\t\t\t (((x) >> 6) & GENMASK(9, 7)))\n\n#define DEV_ID_RR1(d)\t\t\t(0xc4 + ((d) * 0x10))\n#define DEV_ID_RR1_PID_MSB(pid)\t\t(pid)\n\n#define DEV_ID_RR2(d)\t\t\t(0xc8 + ((d) * 0x10))\n#define DEV_ID_RR2_PID_LSB(pid)\t\t((pid) << 16)\n#define DEV_ID_RR2_BCR(bcr)\t\t((bcr) << 8)\n#define DEV_ID_RR2_DCR(dcr)\t\t(dcr)\n#define DEV_ID_RR2_LVR(lvr)\t\t(lvr)\n\n#define SIR_MAP(x)\t\t\t(0x180 + ((x) * 4))\n#define SIR_MAP_DEV_REG(d)\t\tSIR_MAP((d) / 2)\n#define SIR_MAP_DEV_SHIFT(d, fs)\t((fs) + (((d) % 2) ? 16 : 0))\n#define SIR_MAP_DEV_CONF_MASK(d)\t(GENMASK(15, 0) << (((d) % 2) ? 16 : 0))\n#define SIR_MAP_DEV_CONF(d, c)\t\t((c) << (((d) % 2) ? 16 : 0))\n#define DEV_ROLE_SLAVE\t\t\t0\n#define DEV_ROLE_MASTER\t\t\t1\n#define SIR_MAP_DEV_ROLE(role)\t\t((role) << 14)\n#define SIR_MAP_DEV_SLOW\t\tBIT(13)\n#define SIR_MAP_DEV_PL(l)\t\t((l) << 8)\n#define SIR_MAP_PL_MAX\t\t\tGENMASK(4, 0)\n#define SIR_MAP_DEV_DA(a)\t\t((a) << 1)\n#define SIR_MAP_DEV_ACK\t\t\tBIT(0)\n\n#define GPIR_WORD(x)\t\t\t(0x200 + ((x) * 4))\n#define GPI_REG(val, id)\t\t\\\n\t(((val) >> (((id) % 4) * 8)) & GENMASK(7, 0))\n\n#define GPOR_WORD(x)\t\t\t(0x220 + ((x) * 4))\n#define GPO_REG(val, id)\t\t\\\n\t(((val) >> (((id) % 4) * 8)) & GENMASK(7, 0))\n\n#define ASF_INT_STATUS\t\t\t0x300\n#define ASF_INT_RAW_STATUS\t\t0x304\n#define ASF_INT_MASK\t\t\t0x308\n#define ASF_INT_TEST\t\t\t0x30c\n#define ASF_INT_FATAL_SELECT\t\t0x310\n#define ASF_INTEGRITY_ERR\t\tBIT(6)\n#define ASF_PROTOCOL_ERR\t\tBIT(5)\n#define ASF_TRANS_TIMEOUT_ERR\t\tBIT(4)\n#define ASF_CSR_ERR\t\t\tBIT(3)\n#define ASF_DAP_ERR\t\t\tBIT(2)\n#define ASF_SRAM_UNCORR_ERR\t\tBIT(1)\n#define ASF_SRAM_CORR_ERR\t\tBIT(0)\n\n#define ASF_SRAM_CORR_FAULT_STATUS\t0x320\n#define ASF_SRAM_UNCORR_FAULT_STATUS\t0x324\n#define ASF_SRAM_CORR_FAULT_INSTANCE(x)\t((x) >> 24)\n#define ASF_SRAM_CORR_FAULT_ADDR(x)\t((x) & GENMASK(23, 0))\n\n#define ASF_SRAM_FAULT_STATS\t\t0x328\n#define ASF_SRAM_FAULT_UNCORR_STATS(x)\t((x) >> 16)\n#define ASF_SRAM_FAULT_CORR_STATS(x)\t((x) & GENMASK(15, 0))\n\n#define ASF_TRANS_TOUT_CTRL\t\t0x330\n#define ASF_TRANS_TOUT_EN\t\tBIT(31)\n#define ASF_TRANS_TOUT_VAL(x)\t(x)\n\n#define ASF_TRANS_TOUT_FAULT_MASK\t0x334\n#define ASF_TRANS_TOUT_FAULT_STATUS\t0x338\n#define ASF_TRANS_TOUT_FAULT_APB\tBIT(3)\n#define ASF_TRANS_TOUT_FAULT_SCL_LOW\tBIT(2)\n#define ASF_TRANS_TOUT_FAULT_SCL_HIGH\tBIT(1)\n#define ASF_TRANS_TOUT_FAULT_FSCL_HIGH\tBIT(0)\n\n#define ASF_PROTO_FAULT_MASK\t\t0x340\n#define ASF_PROTO_FAULT_STATUS\t\t0x344\n#define ASF_PROTO_FAULT_SLVSDR_RD_ABORT\tBIT(31)\n#define ASF_PROTO_FAULT_SLVDDR_FAIL\tBIT(30)\n#define ASF_PROTO_FAULT_S(x)\t\tBIT(16 + (x))\n#define ASF_PROTO_FAULT_MSTSDR_RD_ABORT\tBIT(15)\n#define ASF_PROTO_FAULT_MSTDDR_FAIL\tBIT(14)\n#define ASF_PROTO_FAULT_M(x)\t\tBIT(x)\n\nstruct cdns_i3c_master_caps {\n\tu32 cmdfifodepth;\n\tu32 cmdrfifodepth;\n\tu32 txfifodepth;\n\tu32 rxfifodepth;\n\tu32 ibirfifodepth;\n};\n\nstruct cdns_i3c_cmd {\n\tu32 cmd0;\n\tu32 cmd1;\n\tu32 tx_len;\n\tconst void *tx_buf;\n\tu32 rx_len;\n\tvoid *rx_buf;\n\tu32 error;\n};\n\nstruct cdns_i3c_xfer {\n\tstruct list_head node;\n\tstruct completion comp;\n\tint ret;\n\tunsigned int ncmds;\n\tstruct cdns_i3c_cmd cmds[];\n};\n\nstruct cdns_i3c_data {\n\tu8 thd_delay_ns;\n};\n\nstruct cdns_i3c_master {\n\tstruct work_struct hj_work;\n\tstruct i3c_master_controller base;\n\tu32 free_rr_slots;\n\tunsigned int maxdevs;\n\tstruct {\n\t\tunsigned int num_slots;\n\t\tstruct i3c_dev_desc **slots;\n\t\tspinlock_t lock;\n\t} ibi;\n\tstruct {\n\t\tstruct list_head list;\n\t\tstruct cdns_i3c_xfer *cur;\n\t\tspinlock_t lock;\n\t} xferqueue;\n\tvoid __iomem *regs;\n\tstruct clk *sysclk;\n\tstruct clk *pclk;\n\tstruct cdns_i3c_master_caps caps;\n\tunsigned long i3c_scl_lim;\n\tconst struct cdns_i3c_data *devdata;\n};\n\nstatic inline struct cdns_i3c_master *\nto_cdns_i3c_master(struct i3c_master_controller *master)\n{\n\treturn container_of(master, struct cdns_i3c_master, base);\n}\n\nstatic void cdns_i3c_master_wr_to_tx_fifo(struct cdns_i3c_master *master,\n\t\t\t\t\t  const u8 *bytes, int nbytes)\n{\n\twritesl(master->regs + TX_FIFO, bytes, nbytes / 4);\n\tif (nbytes & 3) {\n\t\tu32 tmp = 0;\n\n\t\tmemcpy(&tmp, bytes + (nbytes & ~3), nbytes & 3);\n\t\twritesl(master->regs + TX_FIFO, &tmp, 1);\n\t}\n}\n\nstatic void cdns_i3c_master_rd_from_rx_fifo(struct cdns_i3c_master *master,\n\t\t\t\t\t    u8 *bytes, int nbytes)\n{\n\treadsl(master->regs + RX_FIFO, bytes, nbytes / 4);\n\tif (nbytes & 3) {\n\t\tu32 tmp;\n\n\t\treadsl(master->regs + RX_FIFO, &tmp, 1);\n\t\tmemcpy(bytes + (nbytes & ~3), &tmp, nbytes & 3);\n\t}\n}\n\nstatic bool cdns_i3c_master_supports_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\t\t     const struct i3c_ccc_cmd *cmd)\n{\n\tif (cmd->ndests > 1)\n\t\treturn false;\n\n\tswitch (cmd->id) {\n\tcase I3C_CCC_ENEC(true):\n\tcase I3C_CCC_ENEC(false):\n\tcase I3C_CCC_DISEC(true):\n\tcase I3C_CCC_DISEC(false):\n\tcase I3C_CCC_ENTAS(0, true):\n\tcase I3C_CCC_ENTAS(0, false):\n\tcase I3C_CCC_RSTDAA(true):\n\tcase I3C_CCC_RSTDAA(false):\n\tcase I3C_CCC_ENTDAA:\n\tcase I3C_CCC_SETMWL(true):\n\tcase I3C_CCC_SETMWL(false):\n\tcase I3C_CCC_SETMRL(true):\n\tcase I3C_CCC_SETMRL(false):\n\tcase I3C_CCC_DEFSLVS:\n\tcase I3C_CCC_ENTHDR(0):\n\tcase I3C_CCC_SETDASA:\n\tcase I3C_CCC_SETNEWDA:\n\tcase I3C_CCC_GETMWL:\n\tcase I3C_CCC_GETMRL:\n\tcase I3C_CCC_GETPID:\n\tcase I3C_CCC_GETBCR:\n\tcase I3C_CCC_GETDCR:\n\tcase I3C_CCC_GETSTATUS:\n\tcase I3C_CCC_GETACCMST:\n\tcase I3C_CCC_GETMXDS:\n\tcase I3C_CCC_GETHDRCAP:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int cdns_i3c_master_disable(struct cdns_i3c_master *master)\n{\n\tu32 status;\n\n\twritel(readl(master->regs + CTRL) & ~CTRL_DEV_EN, master->regs + CTRL);\n\n\treturn readl_poll_timeout(master->regs + MST_STATUS0, status,\n\t\t\t\t  status & MST_STATUS0_IDLE, 10, 1000000);\n}\n\nstatic void cdns_i3c_master_enable(struct cdns_i3c_master *master)\n{\n\twritel(readl(master->regs + CTRL) | CTRL_DEV_EN, master->regs + CTRL);\n}\n\nstatic struct cdns_i3c_xfer *\ncdns_i3c_master_alloc_xfer(struct cdns_i3c_master *master, unsigned int ncmds)\n{\n\tstruct cdns_i3c_xfer *xfer;\n\n\txfer = kzalloc(struct_size(xfer, cmds, ncmds), GFP_KERNEL);\n\tif (!xfer)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&xfer->node);\n\txfer->ncmds = ncmds;\n\txfer->ret = -ETIMEDOUT;\n\n\treturn xfer;\n}\n\nstatic void cdns_i3c_master_free_xfer(struct cdns_i3c_xfer *xfer)\n{\n\tkfree(xfer);\n}\n\nstatic void cdns_i3c_master_start_xfer_locked(struct cdns_i3c_master *master)\n{\n\tstruct cdns_i3c_xfer *xfer = master->xferqueue.cur;\n\tunsigned int i;\n\n\tif (!xfer)\n\t\treturn;\n\n\twritel(MST_INT_CMDD_EMP, master->regs + MST_ICR);\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tstruct cdns_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tcdns_i3c_master_wr_to_tx_fifo(master, cmd->tx_buf,\n\t\t\t\t\t      cmd->tx_len);\n\t}\n\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tstruct cdns_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\twritel(cmd->cmd1 | CMD1_FIFO_CMDID(i),\n\t\t       master->regs + CMD1_FIFO);\n\t\twritel(cmd->cmd0, master->regs + CMD0_FIFO);\n\t}\n\n\twritel(readl(master->regs + CTRL) | CTRL_MCS,\n\t       master->regs + CTRL);\n\twritel(MST_INT_CMDD_EMP, master->regs + MST_IER);\n}\n\nstatic void cdns_i3c_master_end_xfer_locked(struct cdns_i3c_master *master,\n\t\t\t\t\t    u32 isr)\n{\n\tstruct cdns_i3c_xfer *xfer = master->xferqueue.cur;\n\tint i, ret = 0;\n\tu32 status0;\n\n\tif (!xfer)\n\t\treturn;\n\n\tif (!(isr & MST_INT_CMDD_EMP))\n\t\treturn;\n\n\twritel(MST_INT_CMDD_EMP, master->regs + MST_IDR);\n\n\tfor (status0 = readl(master->regs + MST_STATUS0);\n\t     !(status0 & MST_STATUS0_CMDR_EMP);\n\t     status0 = readl(master->regs + MST_STATUS0)) {\n\t\tstruct cdns_i3c_cmd *cmd;\n\t\tu32 cmdr, rx_len, id;\n\n\t\tcmdr = readl(master->regs + CMDR);\n\t\tid = CMDR_CMDID(cmdr);\n\t\tif (id == CMDR_CMDID_HJACK_DISEC ||\n\t\t    id == CMDR_CMDID_HJACK_ENTDAA ||\n\t\t    WARN_ON(id >= xfer->ncmds))\n\t\t\tcontinue;\n\n\t\tcmd = &xfer->cmds[CMDR_CMDID(cmdr)];\n\t\trx_len = min_t(u32, CMDR_XFER_BYTES(cmdr), cmd->rx_len);\n\t\tcdns_i3c_master_rd_from_rx_fifo(master, cmd->rx_buf, rx_len);\n\t\tcmd->error = CMDR_ERROR(cmdr);\n\t}\n\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tswitch (xfer->cmds[i].error) {\n\t\tcase CMDR_NO_ERROR:\n\t\t\tbreak;\n\n\t\tcase CMDR_DDR_PREAMBLE_ERROR:\n\t\tcase CMDR_DDR_PARITY_ERROR:\n\t\tcase CMDR_M0_ERROR:\n\t\tcase CMDR_M1_ERROR:\n\t\tcase CMDR_M2_ERROR:\n\t\tcase CMDR_MST_ABORT:\n\t\tcase CMDR_NACK_RESP:\n\t\tcase CMDR_DDR_DROPPED:\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\n\t\tcase CMDR_DDR_RX_FIFO_OVF:\n\t\tcase CMDR_DDR_TX_FIFO_UNF:\n\t\t\tret = -ENOSPC;\n\t\t\tbreak;\n\n\t\tcase CMDR_INVALID_DA:\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\txfer->ret = ret;\n\tcomplete(&xfer->comp);\n\n\txfer = list_first_entry_or_null(&master->xferqueue.list,\n\t\t\t\t\tstruct cdns_i3c_xfer, node);\n\tif (xfer)\n\t\tlist_del_init(&xfer->node);\n\n\tmaster->xferqueue.cur = xfer;\n\tcdns_i3c_master_start_xfer_locked(master);\n}\n\nstatic void cdns_i3c_master_queue_xfer(struct cdns_i3c_master *master,\n\t\t\t\t       struct cdns_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\n\tinit_completion(&xfer->comp);\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tif (master->xferqueue.cur) {\n\t\tlist_add_tail(&xfer->node, &master->xferqueue.list);\n\t} else {\n\t\tmaster->xferqueue.cur = xfer;\n\t\tcdns_i3c_master_start_xfer_locked(master);\n\t}\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n}\n\nstatic void cdns_i3c_master_unqueue_xfer(struct cdns_i3c_master *master,\n\t\t\t\t\t struct cdns_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tif (master->xferqueue.cur == xfer) {\n\t\tu32 status;\n\n\t\twritel(readl(master->regs + CTRL) & ~CTRL_DEV_EN,\n\t\t       master->regs + CTRL);\n\t\treadl_poll_timeout_atomic(master->regs + MST_STATUS0, status,\n\t\t\t\t\t  status & MST_STATUS0_IDLE, 10,\n\t\t\t\t\t  1000000);\n\t\tmaster->xferqueue.cur = NULL;\n\t\twritel(FLUSH_RX_FIFO | FLUSH_TX_FIFO | FLUSH_CMD_FIFO |\n\t\t       FLUSH_CMD_RESP,\n\t\t       master->regs + FLUSH_CTRL);\n\t\twritel(MST_INT_CMDD_EMP, master->regs + MST_IDR);\n\t\twritel(readl(master->regs + CTRL) | CTRL_DEV_EN,\n\t\t       master->regs + CTRL);\n\t} else {\n\t\tlist_del_init(&xfer->node);\n\t}\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n}\n\nstatic enum i3c_error_code cdns_i3c_cmd_get_err(struct cdns_i3c_cmd *cmd)\n{\n\tswitch (cmd->error) {\n\tcase CMDR_M0_ERROR:\n\t\treturn I3C_ERROR_M0;\n\n\tcase CMDR_M1_ERROR:\n\t\treturn I3C_ERROR_M1;\n\n\tcase CMDR_M2_ERROR:\n\tcase CMDR_NACK_RESP:\n\t\treturn I3C_ERROR_M2;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn I3C_ERROR_UNKNOWN;\n}\n\nstatic int cdns_i3c_master_send_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\t\tstruct i3c_ccc_cmd *cmd)\n{\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_xfer *xfer;\n\tstruct cdns_i3c_cmd *ccmd;\n\tint ret;\n\n\txfer = cdns_i3c_master_alloc_xfer(master, 1);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tccmd = xfer->cmds;\n\tccmd->cmd1 = CMD1_FIFO_CCC(cmd->id);\n\tccmd->cmd0 = CMD0_FIFO_IS_CCC |\n\t\t     CMD0_FIFO_PL_LEN(cmd->dests[0].payload.len);\n\n\tif (cmd->id & I3C_CCC_DIRECT)\n\t\tccmd->cmd0 |= CMD0_FIFO_DEV_ADDR(cmd->dests[0].addr);\n\n\tif (cmd->rnw) {\n\t\tccmd->cmd0 |= CMD0_FIFO_RNW;\n\t\tccmd->rx_buf = cmd->dests[0].payload.data;\n\t\tccmd->rx_len = cmd->dests[0].payload.len;\n\t} else {\n\t\tccmd->tx_buf = cmd->dests[0].payload.data;\n\t\tccmd->tx_len = cmd->dests[0].payload.len;\n\t}\n\n\tcdns_i3c_master_queue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tcdns_i3c_master_unqueue_xfer(master, xfer);\n\n\tret = xfer->ret;\n\tcmd->err = cdns_i3c_cmd_get_err(&xfer->cmds[0]);\n\tcdns_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int cdns_i3c_master_priv_xfers(struct i3c_dev_desc *dev,\n\t\t\t\t      struct i3c_priv_xfer *xfers,\n\t\t\t\t      int nxfers)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tint txslots = 0, rxslots = 0, i, ret;\n\tstruct cdns_i3c_xfer *cdns_xfer;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (xfers[i].len > CMD0_FIFO_PL_LEN_MAX)\n\t\t\treturn -ENOTSUPP;\n\t}\n\n\tif (!nxfers)\n\t\treturn 0;\n\n\tif (nxfers > master->caps.cmdfifodepth ||\n\t    nxfers > master->caps.cmdrfifodepth)\n\t\treturn -ENOTSUPP;\n\n\t \n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (xfers[i].rnw)\n\t\t\trxslots += DIV_ROUND_UP(xfers[i].len, 4);\n\t\telse\n\t\t\ttxslots += DIV_ROUND_UP(xfers[i].len, 4);\n\t}\n\n\tif (rxslots > master->caps.rxfifodepth ||\n\t    txslots > master->caps.txfifodepth)\n\t\treturn -ENOTSUPP;\n\n\tcdns_xfer = cdns_i3c_master_alloc_xfer(master, nxfers);\n\tif (!cdns_xfer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tstruct cdns_i3c_cmd *ccmd = &cdns_xfer->cmds[i];\n\t\tu32 pl_len = xfers[i].len;\n\n\t\tccmd->cmd0 = CMD0_FIFO_DEV_ADDR(dev->info.dyn_addr) |\n\t\t\tCMD0_FIFO_PRIV_XMIT_MODE(XMIT_BURST_WITHOUT_SUBADDR);\n\n\t\tif (xfers[i].rnw) {\n\t\t\tccmd->cmd0 |= CMD0_FIFO_RNW;\n\t\t\tccmd->rx_buf = xfers[i].data.in;\n\t\t\tccmd->rx_len = xfers[i].len;\n\t\t\tpl_len++;\n\t\t} else {\n\t\t\tccmd->tx_buf = xfers[i].data.out;\n\t\t\tccmd->tx_len = xfers[i].len;\n\t\t}\n\n\t\tccmd->cmd0 |= CMD0_FIFO_PL_LEN(pl_len);\n\n\t\tif (i < nxfers - 1)\n\t\t\tccmd->cmd0 |= CMD0_FIFO_RSBC;\n\n\t\tif (!i)\n\t\t\tccmd->cmd0 |= CMD0_FIFO_BCH;\n\t}\n\n\tcdns_i3c_master_queue_xfer(master, cdns_xfer);\n\tif (!wait_for_completion_timeout(&cdns_xfer->comp,\n\t\t\t\t\t msecs_to_jiffies(1000)))\n\t\tcdns_i3c_master_unqueue_xfer(master, cdns_xfer);\n\n\tret = cdns_xfer->ret;\n\n\tfor (i = 0; i < nxfers; i++)\n\t\txfers[i].err = cdns_i3c_cmd_get_err(&cdns_xfer->cmds[i]);\n\n\tcdns_i3c_master_free_xfer(cdns_xfer);\n\n\treturn ret;\n}\n\nstatic int cdns_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,\n\t\t\t\t     const struct i2c_msg *xfers, int nxfers)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tunsigned int nrxwords = 0, ntxwords = 0;\n\tstruct cdns_i3c_xfer *xfer;\n\tint i, ret = 0;\n\n\tif (nxfers > master->caps.cmdfifodepth)\n\t\treturn -ENOTSUPP;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (xfers[i].len > CMD0_FIFO_PL_LEN_MAX)\n\t\t\treturn -ENOTSUPP;\n\n\t\tif (xfers[i].flags & I2C_M_RD)\n\t\t\tnrxwords += DIV_ROUND_UP(xfers[i].len, 4);\n\t\telse\n\t\t\tntxwords += DIV_ROUND_UP(xfers[i].len, 4);\n\t}\n\n\tif (ntxwords > master->caps.txfifodepth ||\n\t    nrxwords > master->caps.rxfifodepth)\n\t\treturn -ENOTSUPP;\n\n\txfer = cdns_i3c_master_alloc_xfer(master, nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tstruct cdns_i3c_cmd *ccmd = &xfer->cmds[i];\n\n\t\tccmd->cmd0 = CMD0_FIFO_DEV_ADDR(xfers[i].addr) |\n\t\t\tCMD0_FIFO_PL_LEN(xfers[i].len) |\n\t\t\tCMD0_FIFO_PRIV_XMIT_MODE(XMIT_BURST_WITHOUT_SUBADDR);\n\n\t\tif (xfers[i].flags & I2C_M_TEN)\n\t\t\tccmd->cmd0 |= CMD0_FIFO_IS_10B;\n\n\t\tif (xfers[i].flags & I2C_M_RD) {\n\t\t\tccmd->cmd0 |= CMD0_FIFO_RNW;\n\t\t\tccmd->rx_buf = xfers[i].buf;\n\t\t\tccmd->rx_len = xfers[i].len;\n\t\t} else {\n\t\t\tccmd->tx_buf = xfers[i].buf;\n\t\t\tccmd->tx_len = xfers[i].len;\n\t\t}\n\t}\n\n\tcdns_i3c_master_queue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tcdns_i3c_master_unqueue_xfer(master, xfer);\n\n\tret = xfer->ret;\n\tcdns_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstruct cdns_i3c_i2c_dev_data {\n\tu16 id;\n\ts16 ibi;\n\tstruct i3c_generic_ibi_pool *ibi_pool;\n};\n\nstatic u32 prepare_rr0_dev_address(u32 addr)\n{\n\tu32 ret = (addr << 1) & 0xff;\n\n\t \n\tret |= (addr & GENMASK(6, 0)) << 1;\n\n\t \n\tret |= (addr & GENMASK(9, 7)) << 6;\n\n\t \n\tif (!(hweight8(addr & 0x7f) & 1))\n\t\tret |= 1;\n\n\treturn ret;\n}\n\nstatic void cdns_i3c_master_upd_i3c_addr(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tu32 rr;\n\n\trr = prepare_rr0_dev_address(dev->info.dyn_addr ?\n\t\t\t\t     dev->info.dyn_addr :\n\t\t\t\t     dev->info.static_addr);\n\twritel(DEV_ID_RR0_IS_I3C | rr, master->regs + DEV_ID_RR0(data->id));\n}\n\nstatic int cdns_i3c_master_get_rr_slot(struct cdns_i3c_master *master,\n\t\t\t\t       u8 dyn_addr)\n{\n\tunsigned long activedevs;\n\tu32 rr;\n\tint i;\n\n\tif (!dyn_addr) {\n\t\tif (!master->free_rr_slots)\n\t\t\treturn -ENOSPC;\n\n\t\treturn ffs(master->free_rr_slots) - 1;\n\t}\n\n\tactivedevs = readl(master->regs + DEVS_CTRL) & DEVS_CTRL_DEVS_ACTIVE_MASK;\n\tactivedevs &= ~BIT(0);\n\n\tfor_each_set_bit(i, &activedevs, master->maxdevs + 1) {\n\t\trr = readl(master->regs + DEV_ID_RR0(i));\n\t\tif (!(rr & DEV_ID_RR0_IS_I3C) ||\n\t\t    DEV_ID_RR0_GET_DEV_ADDR(rr) != dyn_addr)\n\t\t\tcontinue;\n\n\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int cdns_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,\n\t\t\t\t\t    u8 old_dyn_addr)\n{\n\tcdns_i3c_master_upd_i3c_addr(dev);\n\n\treturn 0;\n}\n\nstatic int cdns_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data;\n\tint slot;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tslot = cdns_i3c_master_get_rr_slot(master, dev->info.dyn_addr);\n\tif (slot < 0) {\n\t\tkfree(data);\n\t\treturn slot;\n\t}\n\n\tdata->ibi = -1;\n\tdata->id = slot;\n\ti3c_dev_set_master_data(dev, data);\n\tmaster->free_rr_slots &= ~BIT(slot);\n\n\tif (!dev->info.dyn_addr) {\n\t\tcdns_i3c_master_upd_i3c_addr(dev);\n\t\twritel(readl(master->regs + DEVS_CTRL) |\n\t\t       DEVS_CTRL_DEV_ACTIVE(data->id),\n\t\t       master->regs + DEVS_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic void cdns_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\n\twritel(readl(master->regs + DEVS_CTRL) |\n\t       DEVS_CTRL_DEV_CLR(data->id),\n\t       master->regs + DEVS_CTRL);\n\n\ti3c_dev_set_master_data(dev, NULL);\n\tmaster->free_rr_slots |= BIT(data->id);\n\tkfree(data);\n}\n\nstatic int cdns_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data;\n\tint slot;\n\n\tslot = cdns_i3c_master_get_rr_slot(master, 0);\n\tif (slot < 0)\n\t\treturn slot;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->id = slot;\n\tmaster->free_rr_slots &= ~BIT(slot);\n\ti2c_dev_set_master_data(dev, data);\n\n\twritel(prepare_rr0_dev_address(dev->addr),\n\t       master->regs + DEV_ID_RR0(data->id));\n\twritel(dev->lvr, master->regs + DEV_ID_RR2(data->id));\n\twritel(readl(master->regs + DEVS_CTRL) |\n\t       DEVS_CTRL_DEV_ACTIVE(data->id),\n\t       master->regs + DEVS_CTRL);\n\n\treturn 0;\n}\n\nstatic void cdns_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);\n\n\twritel(readl(master->regs + DEVS_CTRL) |\n\t       DEVS_CTRL_DEV_CLR(data->id),\n\t       master->regs + DEVS_CTRL);\n\tmaster->free_rr_slots |= BIT(data->id);\n\n\ti2c_dev_set_master_data(dev, NULL);\n\tkfree(data);\n}\n\nstatic void cdns_i3c_master_bus_cleanup(struct i3c_master_controller *m)\n{\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\n\tcdns_i3c_master_disable(master);\n}\n\nstatic void cdns_i3c_master_dev_rr_to_info(struct cdns_i3c_master *master,\n\t\t\t\t\t   unsigned int slot,\n\t\t\t\t\t   struct i3c_device_info *info)\n{\n\tu32 rr;\n\n\tmemset(info, 0, sizeof(*info));\n\trr = readl(master->regs + DEV_ID_RR0(slot));\n\tinfo->dyn_addr = DEV_ID_RR0_GET_DEV_ADDR(rr);\n\trr = readl(master->regs + DEV_ID_RR2(slot));\n\tinfo->dcr = rr;\n\tinfo->bcr = rr >> 8;\n\tinfo->pid = rr >> 16;\n\tinfo->pid |= (u64)readl(master->regs + DEV_ID_RR1(slot)) << 16;\n}\n\nstatic void cdns_i3c_master_upd_i3c_scl_lim(struct cdns_i3c_master *master)\n{\n\tstruct i3c_master_controller *m = &master->base;\n\tunsigned long i3c_lim_period, pres_step, ncycles;\n\tstruct i3c_bus *bus = i3c_master_get_bus(m);\n\tunsigned long new_i3c_scl_lim = 0;\n\tstruct i3c_dev_desc *dev;\n\tu32 prescl1, ctrl;\n\n\ti3c_bus_for_each_i3cdev(bus, dev) {\n\t\tunsigned long max_fscl;\n\n\t\tmax_fscl = max(I3C_CCC_MAX_SDR_FSCL(dev->info.max_read_ds),\n\t\t\t       I3C_CCC_MAX_SDR_FSCL(dev->info.max_write_ds));\n\t\tswitch (max_fscl) {\n\t\tcase I3C_SDR1_FSCL_8MHZ:\n\t\t\tmax_fscl = 8000000;\n\t\t\tbreak;\n\t\tcase I3C_SDR2_FSCL_6MHZ:\n\t\t\tmax_fscl = 6000000;\n\t\t\tbreak;\n\t\tcase I3C_SDR3_FSCL_4MHZ:\n\t\t\tmax_fscl = 4000000;\n\t\t\tbreak;\n\t\tcase I3C_SDR4_FSCL_2MHZ:\n\t\t\tmax_fscl = 2000000;\n\t\t\tbreak;\n\t\tcase I3C_SDR0_FSCL_MAX:\n\t\tdefault:\n\t\t\tmax_fscl = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (max_fscl &&\n\t\t    (new_i3c_scl_lim > max_fscl || !new_i3c_scl_lim))\n\t\t\tnew_i3c_scl_lim = max_fscl;\n\t}\n\n\t \n\tif (new_i3c_scl_lim == master->i3c_scl_lim)\n\t\treturn;\n\tmaster->i3c_scl_lim = new_i3c_scl_lim;\n\tif (!new_i3c_scl_lim)\n\t\treturn;\n\tpres_step = 1000000000UL / (bus->scl_rate.i3c * 4);\n\n\t \n\tprescl1 = readl(master->regs + PRESCL_CTRL1) &\n\t\t  ~PRESCL_CTRL1_PP_LOW_MASK;\n\tctrl = readl(master->regs + CTRL);\n\n\ti3c_lim_period = DIV_ROUND_UP(1000000000, master->i3c_scl_lim);\n\tncycles = DIV_ROUND_UP(i3c_lim_period, pres_step);\n\tif (ncycles < 4)\n\t\tncycles = 0;\n\telse\n\t\tncycles -= 4;\n\n\tprescl1 |= PRESCL_CTRL1_PP_LOW(ncycles);\n\n\t \n\tif (ctrl & CTRL_DEV_EN)\n\t\tcdns_i3c_master_disable(master);\n\n\twritel(prescl1, master->regs + PRESCL_CTRL1);\n\n\tif (ctrl & CTRL_DEV_EN)\n\t\tcdns_i3c_master_enable(master);\n}\n\nstatic int cdns_i3c_master_do_daa(struct i3c_master_controller *m)\n{\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tunsigned long olddevs, newdevs;\n\tint ret, slot;\n\tu8 addrs[MAX_DEVS] = { };\n\tu8 last_addr = 0;\n\n\tolddevs = readl(master->regs + DEVS_CTRL) & DEVS_CTRL_DEVS_ACTIVE_MASK;\n\tolddevs |= BIT(0);\n\n\t \n\tfor_each_clear_bit(slot, &olddevs, master->maxdevs + 1) {\n\t\tret = i3c_master_get_free_addr(m, last_addr + 1);\n\t\tif (ret < 0)\n\t\t\treturn -ENOSPC;\n\n\t\tlast_addr = ret;\n\t\taddrs[slot] = last_addr;\n\t\twritel(prepare_rr0_dev_address(last_addr) | DEV_ID_RR0_IS_I3C,\n\t\t       master->regs + DEV_ID_RR0(slot));\n\t\twritel(0, master->regs + DEV_ID_RR1(slot));\n\t\twritel(0, master->regs + DEV_ID_RR2(slot));\n\t}\n\n\tret = i3c_master_entdaa_locked(&master->base);\n\tif (ret && ret != I3C_ERROR_M2)\n\t\treturn ret;\n\n\tnewdevs = readl(master->regs + DEVS_CTRL) & DEVS_CTRL_DEVS_ACTIVE_MASK;\n\tnewdevs &= ~olddevs;\n\n\t \n\tfor_each_set_bit(slot, &newdevs, master->maxdevs + 1)\n\t\ti3c_master_add_i3c_dev_locked(m, addrs[slot]);\n\n\t \n\twritel(readl(master->regs + DEVS_CTRL) |\n\t       master->free_rr_slots << DEVS_CTRL_DEV_CLR_SHIFT,\n\t       master->regs + DEVS_CTRL);\n\n\ti3c_master_defslvs_locked(&master->base);\n\n\tcdns_i3c_master_upd_i3c_scl_lim(master);\n\n\t \n\ti3c_master_enec_locked(m, I3C_BROADCAST_ADDR,\n\t\t\t       I3C_CCC_EVENT_HJ | I3C_CCC_EVENT_MR);\n\n\treturn 0;\n}\n\nstatic u8 cdns_i3c_master_calculate_thd_delay(struct cdns_i3c_master *master)\n{\n\tunsigned long sysclk_rate = clk_get_rate(master->sysclk);\n\tu8 thd_delay = DIV_ROUND_UP(master->devdata->thd_delay_ns,\n\t\t\t\t    (NSEC_PER_SEC / sysclk_rate));\n\n\t \n\tif (thd_delay > THD_DELAY_MAX)\n\t\tthd_delay = THD_DELAY_MAX;\n\n\t \n\treturn (THD_DELAY_MAX - thd_delay);\n}\n\nstatic int cdns_i3c_master_bus_init(struct i3c_master_controller *m)\n{\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tunsigned long pres_step, sysclk_rate, max_i2cfreq;\n\tstruct i3c_bus *bus = i3c_master_get_bus(m);\n\tu32 ctrl, prescl0, prescl1, pres, low;\n\tstruct i3c_device_info info = { };\n\tint ret, ncycles;\n\n\tswitch (bus->mode) {\n\tcase I3C_BUS_MODE_PURE:\n\t\tctrl = CTRL_PURE_BUS_MODE;\n\t\tbreak;\n\n\tcase I3C_BUS_MODE_MIXED_FAST:\n\t\tctrl = CTRL_MIXED_FAST_BUS_MODE;\n\t\tbreak;\n\n\tcase I3C_BUS_MODE_MIXED_SLOW:\n\t\tctrl = CTRL_MIXED_SLOW_BUS_MODE;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsysclk_rate = clk_get_rate(master->sysclk);\n\tif (!sysclk_rate)\n\t\treturn -EINVAL;\n\n\tpres = DIV_ROUND_UP(sysclk_rate, (bus->scl_rate.i3c * 4)) - 1;\n\tif (pres > PRESCL_CTRL0_MAX)\n\t\treturn -ERANGE;\n\n\tbus->scl_rate.i3c = sysclk_rate / ((pres + 1) * 4);\n\n\tprescl0 = PRESCL_CTRL0_I3C(pres);\n\n\tlow = ((I3C_BUS_TLOW_OD_MIN_NS * sysclk_rate) / (pres + 1)) - 2;\n\tprescl1 = PRESCL_CTRL1_OD_LOW(low);\n\n\tmax_i2cfreq = bus->scl_rate.i2c;\n\n\tpres = (sysclk_rate / (max_i2cfreq * 5)) - 1;\n\tif (pres > PRESCL_CTRL0_MAX)\n\t\treturn -ERANGE;\n\n\tbus->scl_rate.i2c = sysclk_rate / ((pres + 1) * 5);\n\n\tprescl0 |= PRESCL_CTRL0_I2C(pres);\n\twritel(prescl0, master->regs + PRESCL_CTRL0);\n\n\t \n\tpres_step = 1000000000 / (bus->scl_rate.i3c * 4);\n\tncycles = DIV_ROUND_UP(I3C_BUS_TLOW_OD_MIN_NS, pres_step) - 2;\n\tif (ncycles < 0)\n\t\tncycles = 0;\n\tprescl1 = PRESCL_CTRL1_OD_LOW(ncycles);\n\twritel(prescl1, master->regs + PRESCL_CTRL1);\n\n\t \n\tret = i3c_master_get_free_addr(m, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel(prepare_rr0_dev_address(ret) | DEV_ID_RR0_IS_I3C,\n\t       master->regs + DEV_ID_RR0(0));\n\n\tcdns_i3c_master_dev_rr_to_info(master, 0, &info);\n\tif (info.bcr & I3C_BCR_HDR_CAP)\n\t\tinfo.hdr_cap = I3C_CCC_HDR_MODE(I3C_HDR_DDR);\n\n\tret = i3c_master_set_info(&master->base, &info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tctrl |= CTRL_HJ_ACK | CTRL_HJ_DISEC | CTRL_HALT_EN | CTRL_MCS_EN;\n\n\t \n\tctrl |= CTRL_THD_DELAY(cdns_i3c_master_calculate_thd_delay(master));\n\twritel(ctrl, master->regs + CTRL);\n\n\tcdns_i3c_master_enable(master);\n\n\treturn 0;\n}\n\nstatic void cdns_i3c_master_handle_ibi(struct cdns_i3c_master *master,\n\t\t\t\t       u32 ibir)\n{\n\tstruct cdns_i3c_i2c_dev_data *data;\n\tbool data_consumed = false;\n\tstruct i3c_ibi_slot *slot;\n\tu32 id = IBIR_SLVID(ibir);\n\tstruct i3c_dev_desc *dev;\n\tsize_t nbytes;\n\tu8 *buf;\n\n\t \n\tif (id >= master->ibi.num_slots || (ibir & IBIR_ERROR))\n\t\tgoto out;\n\n\tdev = master->ibi.slots[id];\n\tspin_lock(&master->ibi.lock);\n\n\tdata = i3c_dev_get_master_data(dev);\n\tslot = i3c_generic_ibi_get_free_slot(data->ibi_pool);\n\tif (!slot)\n\t\tgoto out_unlock;\n\n\tbuf = slot->data;\n\n\tnbytes = IBIR_XFER_BYTES(ibir);\n\treadsl(master->regs + IBI_DATA_FIFO, buf, nbytes / 4);\n\tif (nbytes % 3) {\n\t\tu32 tmp = __raw_readl(master->regs + IBI_DATA_FIFO);\n\n\t\tmemcpy(buf + (nbytes & ~3), &tmp, nbytes & 3);\n\t}\n\n\tslot->len = min_t(unsigned int, IBIR_XFER_BYTES(ibir),\n\t\t\t  dev->ibi->max_payload_len);\n\ti3c_master_queue_ibi(dev, slot);\n\tdata_consumed = true;\n\nout_unlock:\n\tspin_unlock(&master->ibi.lock);\n\nout:\n\t \n\tif (!data_consumed) {\n\t\tint i;\n\n\t\tfor (i = 0; i < IBIR_XFER_BYTES(ibir); i += 4)\n\t\t\treadl(master->regs + IBI_DATA_FIFO);\n\t}\n}\n\nstatic void cnds_i3c_master_demux_ibis(struct cdns_i3c_master *master)\n{\n\tu32 status0;\n\n\twritel(MST_INT_IBIR_THR, master->regs + MST_ICR);\n\n\tfor (status0 = readl(master->regs + MST_STATUS0);\n\t     !(status0 & MST_STATUS0_IBIR_EMP);\n\t     status0 = readl(master->regs + MST_STATUS0)) {\n\t\tu32 ibir = readl(master->regs + IBIR);\n\n\t\tswitch (IBIR_TYPE(ibir)) {\n\t\tcase IBIR_TYPE_IBI:\n\t\t\tcdns_i3c_master_handle_ibi(master, ibir);\n\t\t\tbreak;\n\n\t\tcase IBIR_TYPE_HJ:\n\t\t\tWARN_ON(IBIR_XFER_BYTES(ibir) || (ibir & IBIR_ERROR));\n\t\t\tqueue_work(master->base.wq, &master->hj_work);\n\t\t\tbreak;\n\n\t\tcase IBIR_TYPE_MR:\n\t\t\tWARN_ON(IBIR_XFER_BYTES(ibir) || (ibir & IBIR_ERROR));\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic irqreturn_t cdns_i3c_master_interrupt(int irq, void *data)\n{\n\tstruct cdns_i3c_master *master = data;\n\tu32 status;\n\n\tstatus = readl(master->regs + MST_ISR);\n\tif (!(status & readl(master->regs + MST_IMR)))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&master->xferqueue.lock);\n\tcdns_i3c_master_end_xfer_locked(master, status);\n\tspin_unlock(&master->xferqueue.lock);\n\n\tif (status & MST_INT_IBIR_THR)\n\t\tcnds_i3c_master_demux_ibis(master);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int cdns_i3c_master_disable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\tu32 sirmap;\n\tint ret;\n\n\tret = i3c_master_disec_locked(m, dev->info.dyn_addr,\n\t\t\t\t      I3C_CCC_EVENT_SIR);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tsirmap = readl(master->regs + SIR_MAP_DEV_REG(data->ibi));\n\tsirmap &= ~SIR_MAP_DEV_CONF_MASK(data->ibi);\n\tsirmap |= SIR_MAP_DEV_CONF(data->ibi,\n\t\t\t\t   SIR_MAP_DEV_DA(I3C_BROADCAST_ADDR));\n\twritel(sirmap, master->regs + SIR_MAP_DEV_REG(data->ibi));\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\treturn ret;\n}\n\nstatic int cdns_i3c_master_enable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\tu32 sircfg, sirmap;\n\tint ret;\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tsirmap = readl(master->regs + SIR_MAP_DEV_REG(data->ibi));\n\tsirmap &= ~SIR_MAP_DEV_CONF_MASK(data->ibi);\n\tsircfg = SIR_MAP_DEV_ROLE(dev->info.bcr >> 6) |\n\t\t SIR_MAP_DEV_DA(dev->info.dyn_addr) |\n\t\t SIR_MAP_DEV_PL(dev->info.max_ibi_len) |\n\t\t SIR_MAP_DEV_ACK;\n\n\tif (dev->info.bcr & I3C_BCR_MAX_DATA_SPEED_LIM)\n\t\tsircfg |= SIR_MAP_DEV_SLOW;\n\n\tsirmap |= SIR_MAP_DEV_CONF(data->ibi, sircfg);\n\twritel(sirmap, master->regs + SIR_MAP_DEV_REG(data->ibi));\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\tret = i3c_master_enec_locked(m, dev->info.dyn_addr,\n\t\t\t\t     I3C_CCC_EVENT_SIR);\n\tif (ret) {\n\t\tspin_lock_irqsave(&master->ibi.lock, flags);\n\t\tsirmap = readl(master->regs + SIR_MAP_DEV_REG(data->ibi));\n\t\tsirmap &= ~SIR_MAP_DEV_CONF_MASK(data->ibi);\n\t\tsirmap |= SIR_MAP_DEV_CONF(data->ibi,\n\t\t\t\t\t   SIR_MAP_DEV_DA(I3C_BROADCAST_ADDR));\n\t\twritel(sirmap, master->regs + SIR_MAP_DEV_REG(data->ibi));\n\t\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int cdns_i3c_master_request_ibi(struct i3c_dev_desc *dev,\n\t\t\t\t       const struct i3c_ibi_setup *req)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\tdata->ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);\n\tif (IS_ERR(data->ibi_pool))\n\t\treturn PTR_ERR(data->ibi_pool);\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tfor (i = 0; i < master->ibi.num_slots; i++) {\n\t\tif (!master->ibi.slots[i]) {\n\t\t\tdata->ibi = i;\n\t\t\tmaster->ibi.slots[i] = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\tif (i < master->ibi.num_slots)\n\t\treturn 0;\n\n\ti3c_generic_ibi_free_pool(data->ibi_pool);\n\tdata->ibi_pool = NULL;\n\n\treturn -ENOSPC;\n}\n\nstatic void cdns_i3c_master_free_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct cdns_i3c_master *master = to_cdns_i3c_master(m);\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tmaster->ibi.slots[data->ibi] = NULL;\n\tdata->ibi = -1;\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\ti3c_generic_ibi_free_pool(data->ibi_pool);\n}\n\nstatic void cdns_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev,\n\t\t\t\t\t     struct i3c_ibi_slot *slot)\n{\n\tstruct cdns_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\n\ti3c_generic_ibi_recycle_slot(data->ibi_pool, slot);\n}\n\nstatic const struct i3c_master_controller_ops cdns_i3c_master_ops = {\n\t.bus_init = cdns_i3c_master_bus_init,\n\t.bus_cleanup = cdns_i3c_master_bus_cleanup,\n\t.do_daa = cdns_i3c_master_do_daa,\n\t.attach_i3c_dev = cdns_i3c_master_attach_i3c_dev,\n\t.reattach_i3c_dev = cdns_i3c_master_reattach_i3c_dev,\n\t.detach_i3c_dev = cdns_i3c_master_detach_i3c_dev,\n\t.attach_i2c_dev = cdns_i3c_master_attach_i2c_dev,\n\t.detach_i2c_dev = cdns_i3c_master_detach_i2c_dev,\n\t.supports_ccc_cmd = cdns_i3c_master_supports_ccc_cmd,\n\t.send_ccc_cmd = cdns_i3c_master_send_ccc_cmd,\n\t.priv_xfers = cdns_i3c_master_priv_xfers,\n\t.i2c_xfers = cdns_i3c_master_i2c_xfers,\n\t.enable_ibi = cdns_i3c_master_enable_ibi,\n\t.disable_ibi = cdns_i3c_master_disable_ibi,\n\t.request_ibi = cdns_i3c_master_request_ibi,\n\t.free_ibi = cdns_i3c_master_free_ibi,\n\t.recycle_ibi_slot = cdns_i3c_master_recycle_ibi_slot,\n};\n\nstatic void cdns_i3c_master_hj(struct work_struct *work)\n{\n\tstruct cdns_i3c_master *master = container_of(work,\n\t\t\t\t\t\t      struct cdns_i3c_master,\n\t\t\t\t\t\t      hj_work);\n\n\ti3c_master_do_daa(&master->base);\n}\n\nstatic struct cdns_i3c_data cdns_i3c_devdata = {\n\t.thd_delay_ns = 10,\n};\n\nstatic const struct of_device_id cdns_i3c_master_of_ids[] = {\n\t{ .compatible = \"cdns,i3c-master\", .data = &cdns_i3c_devdata },\n\t{   },\n};\n\nstatic int cdns_i3c_master_probe(struct platform_device *pdev)\n{\n\tstruct cdns_i3c_master *master;\n\tint ret, irq;\n\tu32 val;\n\n\tmaster = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->devdata = of_device_get_match_data(&pdev->dev);\n\tif (!master->devdata)\n\t\treturn -EINVAL;\n\n\tmaster->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(master->regs))\n\t\treturn PTR_ERR(master->regs);\n\n\tmaster->pclk = devm_clk_get(&pdev->dev, \"pclk\");\n\tif (IS_ERR(master->pclk))\n\t\treturn PTR_ERR(master->pclk);\n\n\tmaster->sysclk = devm_clk_get(&pdev->dev, \"sysclk\");\n\tif (IS_ERR(master->sysclk))\n\t\treturn PTR_ERR(master->sysclk);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = clk_prepare_enable(master->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(master->sysclk);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\tif (readl(master->regs + DEV_ID) != DEV_ID_I3C_MASTER) {\n\t\tret = -EINVAL;\n\t\tgoto err_disable_sysclk;\n\t}\n\n\tspin_lock_init(&master->xferqueue.lock);\n\tINIT_LIST_HEAD(&master->xferqueue.list);\n\n\tINIT_WORK(&master->hj_work, cdns_i3c_master_hj);\n\twritel(0xffffffff, master->regs + MST_IDR);\n\twritel(0xffffffff, master->regs + SLV_IDR);\n\tret = devm_request_irq(&pdev->dev, irq, cdns_i3c_master_interrupt, 0,\n\t\t\t       dev_name(&pdev->dev), master);\n\tif (ret)\n\t\tgoto err_disable_sysclk;\n\n\tplatform_set_drvdata(pdev, master);\n\n\tval = readl(master->regs + CONF_STATUS0);\n\n\t \n\tmaster->maxdevs = CONF_STATUS0_DEVS_NUM(val);\n\tmaster->free_rr_slots = GENMASK(master->maxdevs, 1);\n\tmaster->caps.ibirfifodepth = CONF_STATUS0_IBIR_DEPTH(val);\n\tmaster->caps.cmdrfifodepth = CONF_STATUS0_CMDR_DEPTH(val);\n\n\tval = readl(master->regs + CONF_STATUS1);\n\tmaster->caps.cmdfifodepth = CONF_STATUS1_CMD_DEPTH(val);\n\tmaster->caps.rxfifodepth = CONF_STATUS1_RX_DEPTH(val);\n\tmaster->caps.txfifodepth = CONF_STATUS1_TX_DEPTH(val);\n\n\tspin_lock_init(&master->ibi.lock);\n\tmaster->ibi.num_slots = CONF_STATUS1_IBI_HW_RES(val);\n\tmaster->ibi.slots = devm_kcalloc(&pdev->dev, master->ibi.num_slots,\n\t\t\t\t\t sizeof(*master->ibi.slots),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!master->ibi.slots) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_sysclk;\n\t}\n\n\twritel(IBIR_THR(1), master->regs + CMD_IBI_THR_CTRL);\n\twritel(MST_INT_IBIR_THR, master->regs + MST_IER);\n\twritel(DEVS_CTRL_DEV_CLR_ALL, master->regs + DEVS_CTRL);\n\n\tret = i3c_master_register(&master->base, &pdev->dev,\n\t\t\t\t  &cdns_i3c_master_ops, false);\n\tif (ret)\n\t\tgoto err_disable_sysclk;\n\n\treturn 0;\n\nerr_disable_sysclk:\n\tclk_disable_unprepare(master->sysclk);\n\nerr_disable_pclk:\n\tclk_disable_unprepare(master->pclk);\n\n\treturn ret;\n}\n\nstatic void cdns_i3c_master_remove(struct platform_device *pdev)\n{\n\tstruct cdns_i3c_master *master = platform_get_drvdata(pdev);\n\n\ti3c_master_unregister(&master->base);\n\n\tclk_disable_unprepare(master->sysclk);\n\tclk_disable_unprepare(master->pclk);\n}\n\nstatic struct platform_driver cdns_i3c_master = {\n\t.probe = cdns_i3c_master_probe,\n\t.remove_new = cdns_i3c_master_remove,\n\t.driver = {\n\t\t.name = \"cdns-i3c-master\",\n\t\t.of_match_table = cdns_i3c_master_of_ids,\n\t},\n};\nmodule_platform_driver(cdns_i3c_master);\n\nMODULE_AUTHOR(\"Boris Brezillon <boris.brezillon@bootlin.com>\");\nMODULE_DESCRIPTION(\"Cadence I3C master driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:cdns-i3c-master\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}