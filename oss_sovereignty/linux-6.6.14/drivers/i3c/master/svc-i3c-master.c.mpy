{
  "module_name": "svc-i3c-master.c",
  "hash_id": "c1dfe468a5e8831e916803c44651e48816e81519f7f9cc2b8ac1f0252b8c3e70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/svc-i3c-master.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/completion.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n\n \n#define SVC_I3C_MCONFIG      0x000\n#define   SVC_I3C_MCONFIG_MASTER_EN BIT(0)\n#define   SVC_I3C_MCONFIG_DISTO(x) FIELD_PREP(BIT(3), (x))\n#define   SVC_I3C_MCONFIG_HKEEP(x) FIELD_PREP(GENMASK(5, 4), (x))\n#define   SVC_I3C_MCONFIG_ODSTOP(x) FIELD_PREP(BIT(6), (x))\n#define   SVC_I3C_MCONFIG_PPBAUD(x) FIELD_PREP(GENMASK(11, 8), (x))\n#define   SVC_I3C_MCONFIG_PPLOW(x) FIELD_PREP(GENMASK(15, 12), (x))\n#define   SVC_I3C_MCONFIG_ODBAUD(x) FIELD_PREP(GENMASK(23, 16), (x))\n#define   SVC_I3C_MCONFIG_ODHPP(x) FIELD_PREP(BIT(24), (x))\n#define   SVC_I3C_MCONFIG_SKEW(x) FIELD_PREP(GENMASK(27, 25), (x))\n#define   SVC_I3C_MCONFIG_I2CBAUD(x) FIELD_PREP(GENMASK(31, 28), (x))\n\n#define SVC_I3C_MCTRL        0x084\n#define   SVC_I3C_MCTRL_REQUEST_MASK GENMASK(2, 0)\n#define   SVC_I3C_MCTRL_REQUEST_NONE 0\n#define   SVC_I3C_MCTRL_REQUEST_START_ADDR 1\n#define   SVC_I3C_MCTRL_REQUEST_STOP 2\n#define   SVC_I3C_MCTRL_REQUEST_IBI_ACKNACK 3\n#define   SVC_I3C_MCTRL_REQUEST_PROC_DAA 4\n#define   SVC_I3C_MCTRL_REQUEST_AUTO_IBI 7\n#define   SVC_I3C_MCTRL_TYPE_I3C 0\n#define   SVC_I3C_MCTRL_TYPE_I2C BIT(4)\n#define   SVC_I3C_MCTRL_IBIRESP_AUTO 0\n#define   SVC_I3C_MCTRL_IBIRESP_ACK_WITHOUT_BYTE 0\n#define   SVC_I3C_MCTRL_IBIRESP_ACK_WITH_BYTE BIT(7)\n#define   SVC_I3C_MCTRL_IBIRESP_NACK BIT(6)\n#define   SVC_I3C_MCTRL_IBIRESP_MANUAL GENMASK(7, 6)\n#define   SVC_I3C_MCTRL_DIR(x) FIELD_PREP(BIT(8), (x))\n#define   SVC_I3C_MCTRL_DIR_WRITE 0\n#define   SVC_I3C_MCTRL_DIR_READ 1\n#define   SVC_I3C_MCTRL_ADDR(x) FIELD_PREP(GENMASK(15, 9), (x))\n#define   SVC_I3C_MCTRL_RDTERM(x) FIELD_PREP(GENMASK(23, 16), (x))\n\n#define SVC_I3C_MSTATUS      0x088\n#define   SVC_I3C_MSTATUS_STATE(x) FIELD_GET(GENMASK(2, 0), (x))\n#define   SVC_I3C_MSTATUS_STATE_DAA(x) (SVC_I3C_MSTATUS_STATE(x) == 5)\n#define   SVC_I3C_MSTATUS_STATE_IDLE(x) (SVC_I3C_MSTATUS_STATE(x) == 0)\n#define   SVC_I3C_MSTATUS_BETWEEN(x) FIELD_GET(BIT(4), (x))\n#define   SVC_I3C_MSTATUS_NACKED(x) FIELD_GET(BIT(5), (x))\n#define   SVC_I3C_MSTATUS_IBITYPE(x) FIELD_GET(GENMASK(7, 6), (x))\n#define   SVC_I3C_MSTATUS_IBITYPE_IBI 1\n#define   SVC_I3C_MSTATUS_IBITYPE_MASTER_REQUEST 2\n#define   SVC_I3C_MSTATUS_IBITYPE_HOT_JOIN 3\n#define   SVC_I3C_MINT_SLVSTART BIT(8)\n#define   SVC_I3C_MINT_MCTRLDONE BIT(9)\n#define   SVC_I3C_MINT_COMPLETE BIT(10)\n#define   SVC_I3C_MINT_RXPEND BIT(11)\n#define   SVC_I3C_MINT_TXNOTFULL BIT(12)\n#define   SVC_I3C_MINT_IBIWON BIT(13)\n#define   SVC_I3C_MINT_ERRWARN BIT(15)\n#define   SVC_I3C_MSTATUS_SLVSTART(x) FIELD_GET(SVC_I3C_MINT_SLVSTART, (x))\n#define   SVC_I3C_MSTATUS_MCTRLDONE(x) FIELD_GET(SVC_I3C_MINT_MCTRLDONE, (x))\n#define   SVC_I3C_MSTATUS_COMPLETE(x) FIELD_GET(SVC_I3C_MINT_COMPLETE, (x))\n#define   SVC_I3C_MSTATUS_RXPEND(x) FIELD_GET(SVC_I3C_MINT_RXPEND, (x))\n#define   SVC_I3C_MSTATUS_TXNOTFULL(x) FIELD_GET(SVC_I3C_MINT_TXNOTFULL, (x))\n#define   SVC_I3C_MSTATUS_IBIWON(x) FIELD_GET(SVC_I3C_MINT_IBIWON, (x))\n#define   SVC_I3C_MSTATUS_ERRWARN(x) FIELD_GET(SVC_I3C_MINT_ERRWARN, (x))\n#define   SVC_I3C_MSTATUS_IBIADDR(x) FIELD_GET(GENMASK(30, 24), (x))\n\n#define SVC_I3C_IBIRULES     0x08C\n#define   SVC_I3C_IBIRULES_ADDR(slot, addr) FIELD_PREP(GENMASK(29, 0), \\\n\t\t\t\t\t\t       ((addr) & 0x3F) << ((slot) * 6))\n#define   SVC_I3C_IBIRULES_ADDRS 5\n#define   SVC_I3C_IBIRULES_MSB0 BIT(30)\n#define   SVC_I3C_IBIRULES_NOBYTE BIT(31)\n#define   SVC_I3C_IBIRULES_MANDBYTE 0\n#define SVC_I3C_MINTSET      0x090\n#define SVC_I3C_MINTCLR      0x094\n#define SVC_I3C_MINTMASKED   0x098\n#define SVC_I3C_MERRWARN     0x09C\n#define   SVC_I3C_MERRWARN_NACK BIT(2)\n#define   SVC_I3C_MERRWARN_TIMEOUT BIT(20)\n#define SVC_I3C_MDMACTRL     0x0A0\n#define SVC_I3C_MDATACTRL    0x0AC\n#define   SVC_I3C_MDATACTRL_FLUSHTB BIT(0)\n#define   SVC_I3C_MDATACTRL_FLUSHRB BIT(1)\n#define   SVC_I3C_MDATACTRL_UNLOCK_TRIG BIT(3)\n#define   SVC_I3C_MDATACTRL_TXTRIG_FIFO_NOT_FULL GENMASK(5, 4)\n#define   SVC_I3C_MDATACTRL_RXTRIG_FIFO_NOT_EMPTY 0\n#define   SVC_I3C_MDATACTRL_RXCOUNT(x) FIELD_GET(GENMASK(28, 24), (x))\n#define   SVC_I3C_MDATACTRL_TXFULL BIT(30)\n#define   SVC_I3C_MDATACTRL_RXEMPTY BIT(31)\n\n#define SVC_I3C_MWDATAB      0x0B0\n#define   SVC_I3C_MWDATAB_END BIT(8)\n\n#define SVC_I3C_MWDATABE     0x0B4\n#define SVC_I3C_MWDATAH      0x0B8\n#define SVC_I3C_MWDATAHE     0x0BC\n#define SVC_I3C_MRDATAB      0x0C0\n#define SVC_I3C_MRDATAH      0x0C8\n#define SVC_I3C_MWMSG_SDR    0x0D0\n#define SVC_I3C_MRMSG_SDR    0x0D4\n#define SVC_I3C_MWMSG_DDR    0x0D8\n#define SVC_I3C_MRMSG_DDR    0x0DC\n\n#define SVC_I3C_MDYNADDR     0x0E4\n#define   SVC_MDYNADDR_VALID BIT(0)\n#define   SVC_MDYNADDR_ADDR(x) FIELD_PREP(GENMASK(7, 1), (x))\n\n#define SVC_I3C_MAX_DEVS 32\n#define SVC_I3C_PM_TIMEOUT_MS 1000\n\n \n#define SVC_I3C_FIFO_SIZE 16\n\nstruct svc_i3c_cmd {\n\tu8 addr;\n\tbool rnw;\n\tu8 *in;\n\tconst void *out;\n\tunsigned int len;\n\tunsigned int read_len;\n\tbool continued;\n};\n\nstruct svc_i3c_xfer {\n\tstruct list_head node;\n\tstruct completion comp;\n\tint ret;\n\tunsigned int type;\n\tunsigned int ncmds;\n\tstruct svc_i3c_cmd cmds[];\n};\n\nstruct svc_i3c_regs_save {\n\tu32 mconfig;\n\tu32 mdynaddr;\n};\n\n \nstruct svc_i3c_master {\n\tstruct i3c_master_controller base;\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct svc_i3c_regs_save saved_regs;\n\tu32 free_slots;\n\tu8 addrs[SVC_I3C_MAX_DEVS];\n\tstruct i3c_dev_desc *descs[SVC_I3C_MAX_DEVS];\n\tstruct work_struct hj_work;\n\tstruct work_struct ibi_work;\n\tint irq;\n\tstruct clk *pclk;\n\tstruct clk *fclk;\n\tstruct clk *sclk;\n\tstruct {\n\t\tstruct list_head list;\n\t\tstruct svc_i3c_xfer *cur;\n\t\t \n\t\tspinlock_t lock;\n\t} xferqueue;\n\tstruct {\n\t\tunsigned int num_slots;\n\t\tstruct i3c_dev_desc **slots;\n\t\tstruct i3c_ibi_slot *tbq_slot;\n\t\t \n\t\tspinlock_t lock;\n\t} ibi;\n\tstruct mutex lock;\n};\n\n \nstruct svc_i3c_i2c_dev_data {\n\tu8 index;\n\tint ibi;\n\tstruct i3c_generic_ibi_pool *ibi_pool;\n};\n\nstatic bool svc_i3c_master_error(struct svc_i3c_master *master)\n{\n\tu32 mstatus, merrwarn;\n\n\tmstatus = readl(master->regs + SVC_I3C_MSTATUS);\n\tif (SVC_I3C_MSTATUS_ERRWARN(mstatus)) {\n\t\tmerrwarn = readl(master->regs + SVC_I3C_MERRWARN);\n\t\twritel(merrwarn, master->regs + SVC_I3C_MERRWARN);\n\n\t\t \n\t\tif (merrwarn & SVC_I3C_MERRWARN_TIMEOUT) {\n\t\t\tdev_dbg(master->dev, \"Warning condition: MSTATUS 0x%08x, MERRWARN 0x%08x\\n\",\n\t\t\t\tmstatus, merrwarn);\n\t\t\treturn false;\n\t\t}\n\n\t\tdev_err(master->dev,\n\t\t\t\"Error condition: MSTATUS 0x%08x, MERRWARN 0x%08x\\n\",\n\t\t\tmstatus, merrwarn);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void svc_i3c_master_enable_interrupts(struct svc_i3c_master *master, u32 mask)\n{\n\twritel(mask, master->regs + SVC_I3C_MINTSET);\n}\n\nstatic void svc_i3c_master_disable_interrupts(struct svc_i3c_master *master)\n{\n\tu32 mask = readl(master->regs + SVC_I3C_MINTSET);\n\n\twritel(mask, master->regs + SVC_I3C_MINTCLR);\n}\n\nstatic void svc_i3c_master_clear_merrwarn(struct svc_i3c_master *master)\n{\n\t \n\twritel(readl(master->regs + SVC_I3C_MERRWARN),\n\t       master->regs + SVC_I3C_MERRWARN);\n}\n\nstatic void svc_i3c_master_flush_fifo(struct svc_i3c_master *master)\n{\n\t \n\twritel(SVC_I3C_MDATACTRL_FLUSHTB | SVC_I3C_MDATACTRL_FLUSHRB,\n\t       master->regs + SVC_I3C_MDATACTRL);\n}\n\nstatic void svc_i3c_master_reset_fifo_trigger(struct svc_i3c_master *master)\n{\n\tu32 reg;\n\n\t \n\treg = SVC_I3C_MDATACTRL_FLUSHTB |\n\t      SVC_I3C_MDATACTRL_FLUSHRB |\n\t      SVC_I3C_MDATACTRL_UNLOCK_TRIG |\n\t      SVC_I3C_MDATACTRL_TXTRIG_FIFO_NOT_FULL |\n\t      SVC_I3C_MDATACTRL_RXTRIG_FIFO_NOT_EMPTY;\n\twritel(reg, master->regs + SVC_I3C_MDATACTRL);\n}\n\nstatic void svc_i3c_master_reset(struct svc_i3c_master *master)\n{\n\tsvc_i3c_master_clear_merrwarn(master);\n\tsvc_i3c_master_reset_fifo_trigger(master);\n\tsvc_i3c_master_disable_interrupts(master);\n}\n\nstatic inline struct svc_i3c_master *\nto_svc_i3c_master(struct i3c_master_controller *master)\n{\n\treturn container_of(master, struct svc_i3c_master, base);\n}\n\nstatic void svc_i3c_master_hj_work(struct work_struct *work)\n{\n\tstruct svc_i3c_master *master;\n\n\tmaster = container_of(work, struct svc_i3c_master, hj_work);\n\ti3c_master_do_daa(&master->base);\n}\n\nstatic struct i3c_dev_desc *\nsvc_i3c_master_dev_from_addr(struct svc_i3c_master *master,\n\t\t\t     unsigned int ibiaddr)\n{\n\tint i;\n\n\tfor (i = 0; i < SVC_I3C_MAX_DEVS; i++)\n\t\tif (master->addrs[i] == ibiaddr)\n\t\t\tbreak;\n\n\tif (i == SVC_I3C_MAX_DEVS)\n\t\treturn NULL;\n\n\treturn master->descs[i];\n}\n\nstatic void svc_i3c_master_emit_stop(struct svc_i3c_master *master)\n{\n\twritel(SVC_I3C_MCTRL_REQUEST_STOP, master->regs + SVC_I3C_MCTRL);\n\n\t \n\tudelay(1);\n}\n\nstatic int svc_i3c_master_handle_ibi(struct svc_i3c_master *master,\n\t\t\t\t     struct i3c_dev_desc *dev)\n{\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_ibi_slot *slot;\n\tunsigned int count;\n\tu32 mdatactrl;\n\tint ret, val;\n\tu8 *buf;\n\n\tslot = i3c_generic_ibi_get_free_slot(data->ibi_pool);\n\tif (!slot)\n\t\treturn -ENOSPC;\n\n\tslot->len = 0;\n\tbuf = slot->data;\n\n\tret = readl_relaxed_poll_timeout(master->regs + SVC_I3C_MSTATUS, val,\n\t\t\t\t\t\tSVC_I3C_MSTATUS_COMPLETE(val), 0, 1000);\n\tif (ret) {\n\t\tdev_err(master->dev, \"Timeout when polling for COMPLETE\\n\");\n\t\treturn ret;\n\t}\n\n\twhile (SVC_I3C_MSTATUS_RXPEND(readl(master->regs + SVC_I3C_MSTATUS))  &&\n\t       slot->len < SVC_I3C_FIFO_SIZE) {\n\t\tmdatactrl = readl(master->regs + SVC_I3C_MDATACTRL);\n\t\tcount = SVC_I3C_MDATACTRL_RXCOUNT(mdatactrl);\n\t\treadsl(master->regs + SVC_I3C_MRDATAB, buf, count);\n\t\tslot->len += count;\n\t\tbuf += count;\n\t}\n\n\tmaster->ibi.tbq_slot = slot;\n\n\treturn 0;\n}\n\nstatic void svc_i3c_master_ack_ibi(struct svc_i3c_master *master,\n\t\t\t\t   bool mandatory_byte)\n{\n\tunsigned int ibi_ack_nack;\n\n\tibi_ack_nack = SVC_I3C_MCTRL_REQUEST_IBI_ACKNACK;\n\tif (mandatory_byte)\n\t\tibi_ack_nack |= SVC_I3C_MCTRL_IBIRESP_ACK_WITH_BYTE;\n\telse\n\t\tibi_ack_nack |= SVC_I3C_MCTRL_IBIRESP_ACK_WITHOUT_BYTE;\n\n\twritel(ibi_ack_nack, master->regs + SVC_I3C_MCTRL);\n}\n\nstatic void svc_i3c_master_nack_ibi(struct svc_i3c_master *master)\n{\n\twritel(SVC_I3C_MCTRL_REQUEST_IBI_ACKNACK |\n\t       SVC_I3C_MCTRL_IBIRESP_NACK,\n\t       master->regs + SVC_I3C_MCTRL);\n}\n\nstatic void svc_i3c_master_ibi_work(struct work_struct *work)\n{\n\tstruct svc_i3c_master *master = container_of(work, struct svc_i3c_master, ibi_work);\n\tstruct svc_i3c_i2c_dev_data *data;\n\tunsigned int ibitype, ibiaddr;\n\tstruct i3c_dev_desc *dev;\n\tu32 status, val;\n\tint ret;\n\n\tmutex_lock(&master->lock);\n\t \n\twritel(SVC_I3C_MCTRL_REQUEST_AUTO_IBI |\n\t       SVC_I3C_MCTRL_IBIRESP_AUTO,\n\t       master->regs + SVC_I3C_MCTRL);\n\n\t \n\tret = readl_relaxed_poll_timeout(master->regs + SVC_I3C_MSTATUS, val,\n\t\t\t\t\t SVC_I3C_MSTATUS_IBIWON(val), 0, 1000);\n\tif (ret) {\n\t\tdev_err(master->dev, \"Timeout when polling for IBIWON\\n\");\n\t\tsvc_i3c_master_emit_stop(master);\n\t\tgoto reenable_ibis;\n\t}\n\n\t \n\twritel(SVC_I3C_MINT_IBIWON, master->regs + SVC_I3C_MSTATUS);\n\n\tstatus = readl(master->regs + SVC_I3C_MSTATUS);\n\tibitype = SVC_I3C_MSTATUS_IBITYPE(status);\n\tibiaddr = SVC_I3C_MSTATUS_IBIADDR(status);\n\n\t \n\tswitch (ibitype) {\n\tcase SVC_I3C_MSTATUS_IBITYPE_IBI:\n\t\tdev = svc_i3c_master_dev_from_addr(master, ibiaddr);\n\t\tif (!dev)\n\t\t\tsvc_i3c_master_nack_ibi(master);\n\t\telse\n\t\t\tsvc_i3c_master_handle_ibi(master, dev);\n\t\tbreak;\n\tcase SVC_I3C_MSTATUS_IBITYPE_HOT_JOIN:\n\t\tsvc_i3c_master_ack_ibi(master, false);\n\t\tbreak;\n\tcase SVC_I3C_MSTATUS_IBITYPE_MASTER_REQUEST:\n\t\tsvc_i3c_master_nack_ibi(master);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (svc_i3c_master_error(master)) {\n\t\tif (master->ibi.tbq_slot) {\n\t\t\tdata = i3c_dev_get_master_data(dev);\n\t\t\ti3c_generic_ibi_recycle_slot(data->ibi_pool,\n\t\t\t\t\t\t     master->ibi.tbq_slot);\n\t\t\tmaster->ibi.tbq_slot = NULL;\n\t\t}\n\n\t\tsvc_i3c_master_emit_stop(master);\n\n\t\tgoto reenable_ibis;\n\t}\n\n\t \n\tswitch (ibitype) {\n\tcase SVC_I3C_MSTATUS_IBITYPE_IBI:\n\t\tif (dev) {\n\t\t\ti3c_master_queue_ibi(dev, master->ibi.tbq_slot);\n\t\t\tmaster->ibi.tbq_slot = NULL;\n\t\t}\n\t\tsvc_i3c_master_emit_stop(master);\n\t\tbreak;\n\tcase SVC_I3C_MSTATUS_IBITYPE_HOT_JOIN:\n\t\tqueue_work(master->base.wq, &master->hj_work);\n\t\tbreak;\n\tcase SVC_I3C_MSTATUS_IBITYPE_MASTER_REQUEST:\n\tdefault:\n\t\tbreak;\n\t}\n\nreenable_ibis:\n\tsvc_i3c_master_enable_interrupts(master, SVC_I3C_MINT_SLVSTART);\n\tmutex_unlock(&master->lock);\n}\n\nstatic irqreturn_t svc_i3c_master_irq_handler(int irq, void *dev_id)\n{\n\tstruct svc_i3c_master *master = (struct svc_i3c_master *)dev_id;\n\tu32 active = readl(master->regs + SVC_I3C_MSTATUS);\n\n\tif (!SVC_I3C_MSTATUS_SLVSTART(active))\n\t\treturn IRQ_NONE;\n\n\t \n\twritel(SVC_I3C_MINT_SLVSTART, master->regs + SVC_I3C_MSTATUS);\n\n\tsvc_i3c_master_disable_interrupts(master);\n\n\t \n\tqueue_work(master->base.wq, &master->ibi_work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int svc_i3c_master_bus_init(struct i3c_master_controller *m)\n{\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct i3c_bus *bus = i3c_master_get_bus(m);\n\tstruct i3c_device_info info = {};\n\tunsigned long fclk_rate, fclk_period_ns;\n\tunsigned int high_period_ns, od_low_period_ns;\n\tu32 ppbaud, pplow, odhpp, odbaud, odstop, i2cbaud, reg;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(master->dev);\n\tif (ret < 0) {\n\t\tdev_err(master->dev,\n\t\t\t\"<%s> cannot resume i3c bus master, err: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tfclk_rate = clk_get_rate(master->fclk);\n\tif (!fclk_rate) {\n\t\tret = -EINVAL;\n\t\tgoto rpm_out;\n\t}\n\n\tfclk_period_ns = DIV_ROUND_UP(1000000000, fclk_rate);\n\n\t \n\tppbaud = DIV_ROUND_UP(40, fclk_period_ns) - 1;\n\tpplow = 0;\n\n\t \n\todhpp = 1;\n\thigh_period_ns = (ppbaud + 1) * fclk_period_ns;\n\todbaud = DIV_ROUND_UP(240 - high_period_ns, high_period_ns) - 1;\n\tod_low_period_ns = (odbaud + 1) * high_period_ns;\n\n\tswitch (bus->mode) {\n\tcase I3C_BUS_MODE_PURE:\n\t\ti2cbaud = 0;\n\t\todstop = 0;\n\t\tbreak;\n\tcase I3C_BUS_MODE_MIXED_FAST:\n\tcase I3C_BUS_MODE_MIXED_LIMITED:\n\t\t \n\t\ti2cbaud = DIV_ROUND_UP(1000, od_low_period_ns) - 2;\n\t\todstop = 1;\n\t\tbreak;\n\tcase I3C_BUS_MODE_MIXED_SLOW:\n\t\t \n\t\ti2cbaud = DIV_ROUND_UP(2500, od_low_period_ns) - 2;\n\t\todstop = 1;\n\t\tbreak;\n\tdefault:\n\t\tgoto rpm_out;\n\t}\n\n\treg = SVC_I3C_MCONFIG_MASTER_EN |\n\t      SVC_I3C_MCONFIG_DISTO(0) |\n\t      SVC_I3C_MCONFIG_HKEEP(0) |\n\t      SVC_I3C_MCONFIG_ODSTOP(odstop) |\n\t      SVC_I3C_MCONFIG_PPBAUD(ppbaud) |\n\t      SVC_I3C_MCONFIG_PPLOW(pplow) |\n\t      SVC_I3C_MCONFIG_ODBAUD(odbaud) |\n\t      SVC_I3C_MCONFIG_ODHPP(odhpp) |\n\t      SVC_I3C_MCONFIG_SKEW(0) |\n\t      SVC_I3C_MCONFIG_I2CBAUD(i2cbaud);\n\twritel(reg, master->regs + SVC_I3C_MCONFIG);\n\n\t \n\tret = i3c_master_get_free_addr(m, 0);\n\tif (ret < 0)\n\t\tgoto rpm_out;\n\n\tinfo.dyn_addr = ret;\n\n\twritel(SVC_MDYNADDR_VALID | SVC_MDYNADDR_ADDR(info.dyn_addr),\n\t       master->regs + SVC_I3C_MDYNADDR);\n\n\tret = i3c_master_set_info(&master->base, &info);\n\tif (ret)\n\t\tgoto rpm_out;\n\nrpm_out:\n\tpm_runtime_mark_last_busy(master->dev);\n\tpm_runtime_put_autosuspend(master->dev);\n\n\treturn ret;\n}\n\nstatic void svc_i3c_master_bus_cleanup(struct i3c_master_controller *m)\n{\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(master->dev);\n\tif (ret < 0) {\n\t\tdev_err(master->dev, \"<%s> Cannot get runtime PM.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tsvc_i3c_master_disable_interrupts(master);\n\n\t \n\twritel(0, master->regs + SVC_I3C_MCONFIG);\n\n\tpm_runtime_mark_last_busy(master->dev);\n\tpm_runtime_put_autosuspend(master->dev);\n}\n\nstatic int svc_i3c_master_reserve_slot(struct svc_i3c_master *master)\n{\n\tunsigned int slot;\n\n\tif (!(master->free_slots & GENMASK(SVC_I3C_MAX_DEVS - 1, 0)))\n\t\treturn -ENOSPC;\n\n\tslot = ffs(master->free_slots) - 1;\n\n\tmaster->free_slots &= ~BIT(slot);\n\n\treturn slot;\n}\n\nstatic void svc_i3c_master_release_slot(struct svc_i3c_master *master,\n\t\t\t\t\tunsigned int slot)\n{\n\tmaster->free_slots |= BIT(slot);\n}\n\nstatic int svc_i3c_master_attach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data;\n\tint slot;\n\n\tslot = svc_i3c_master_reserve_slot(master);\n\tif (slot < 0)\n\t\treturn slot;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tsvc_i3c_master_release_slot(master, slot);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->ibi = -1;\n\tdata->index = slot;\n\tmaster->addrs[slot] = dev->info.dyn_addr ? dev->info.dyn_addr :\n\t\t\t\t\t\t   dev->info.static_addr;\n\tmaster->descs[slot] = dev;\n\n\ti3c_dev_set_master_data(dev, data);\n\n\treturn 0;\n}\n\nstatic int svc_i3c_master_reattach_i3c_dev(struct i3c_dev_desc *dev,\n\t\t\t\t\t   u8 old_dyn_addr)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\n\tmaster->addrs[data->index] = dev->info.dyn_addr ? dev->info.dyn_addr :\n\t\t\t\t\t\t\t  dev->info.static_addr;\n\n\treturn 0;\n}\n\nstatic void svc_i3c_master_detach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\n\tmaster->addrs[data->index] = 0;\n\tsvc_i3c_master_release_slot(master, data->index);\n\n\tkfree(data);\n}\n\nstatic int svc_i3c_master_attach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data;\n\tint slot;\n\n\tslot = svc_i3c_master_reserve_slot(master);\n\tif (slot < 0)\n\t\treturn slot;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data) {\n\t\tsvc_i3c_master_release_slot(master, slot);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->index = slot;\n\tmaster->addrs[slot] = dev->addr;\n\n\ti2c_dev_set_master_data(dev, data);\n\n\treturn 0;\n}\n\nstatic void svc_i3c_master_detach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct svc_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\n\tsvc_i3c_master_release_slot(master, data->index);\n\n\tkfree(data);\n}\n\nstatic int svc_i3c_master_readb(struct svc_i3c_master *master, u8 *dst,\n\t\t\t\tunsigned int len)\n{\n\tint ret, i;\n\tu32 reg;\n\n\tfor (i = 0; i < len; i++) {\n\t\tret = readl_poll_timeout_atomic(master->regs + SVC_I3C_MSTATUS,\n\t\t\t\t\t\treg,\n\t\t\t\t\t\tSVC_I3C_MSTATUS_RXPEND(reg),\n\t\t\t\t\t\t0, 1000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdst[i] = readl(master->regs + SVC_I3C_MRDATAB);\n\t}\n\n\treturn 0;\n}\n\nstatic int svc_i3c_master_do_daa_locked(struct svc_i3c_master *master,\n\t\t\t\t\tu8 *addrs, unsigned int *count)\n{\n\tu64 prov_id[SVC_I3C_MAX_DEVS] = {}, nacking_prov_id = 0;\n\tunsigned int dev_nb = 0, last_addr = 0;\n\tu32 reg;\n\tint ret, i;\n\n\twhile (true) {\n\t\t \n\t\twritel(SVC_I3C_MCTRL_REQUEST_PROC_DAA |\n\t\t       SVC_I3C_MCTRL_TYPE_I3C |\n\t\t       SVC_I3C_MCTRL_IBIRESP_NACK |\n\t\t       SVC_I3C_MCTRL_DIR(SVC_I3C_MCTRL_DIR_WRITE),\n\t\t       master->regs + SVC_I3C_MCTRL);\n\n\t\t \n\t\tret = readl_poll_timeout_atomic(master->regs + SVC_I3C_MSTATUS,\n\t\t\t\t\t\treg,\n\t\t\t\t\t\tSVC_I3C_MSTATUS_RXPEND(reg) |\n\t\t\t\t\t\tSVC_I3C_MSTATUS_MCTRLDONE(reg),\n\t\t\t\t\t\t1, 1000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (SVC_I3C_MSTATUS_RXPEND(reg)) {\n\t\t\tu8 data[6];\n\n\t\t\t \n\t\t\tret = svc_i3c_master_readb(master, data, 6);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tfor (i = 0; i < 6; i++)\n\t\t\t\tprov_id[dev_nb] |= (u64)(data[i]) << (8 * (5 - i));\n\n\t\t\t \n\t\t\tret = svc_i3c_master_readb(master, data, 2);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (SVC_I3C_MSTATUS_MCTRLDONE(reg)) {\n\t\t\tif (SVC_I3C_MSTATUS_STATE_IDLE(reg) &&\n\t\t\t    SVC_I3C_MSTATUS_COMPLETE(reg)) {\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t} else if (SVC_I3C_MSTATUS_NACKED(reg)) {\n\t\t\t\t \n\t\t\t\tif (dev_nb == 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\t \n\t\t\t\tif (prov_id[dev_nb] == nacking_prov_id)\n\t\t\t\t\treturn -EIO;\n\n\t\t\t\tdev_nb--;\n\t\t\t\tnacking_prov_id = prov_id[dev_nb];\n\t\t\t\tsvc_i3c_master_emit_stop(master);\n\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = readl_poll_timeout_atomic(master->regs + SVC_I3C_MSTATUS,\n\t\t\t\t\t\treg,\n\t\t\t\t\t\tSVC_I3C_MSTATUS_MCTRLDONE(reg) &&\n\t\t\t\t\t\tSVC_I3C_MSTATUS_STATE_DAA(reg) &&\n\t\t\t\t\t\tSVC_I3C_MSTATUS_BETWEEN(reg),\n\t\t\t\t\t\t0, 1000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = i3c_master_get_free_addr(&master->base, last_addr + 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\taddrs[dev_nb] = ret;\n\t\tdev_dbg(master->dev, \"DAA: device %d assigned to 0x%02x\\n\",\n\t\t\tdev_nb, addrs[dev_nb]);\n\n\t\twritel(addrs[dev_nb], master->regs + SVC_I3C_MWDATAB);\n\t\tlast_addr = addrs[dev_nb++];\n\t}\n\n\t*count = dev_nb;\n\n\treturn 0;\n}\n\nstatic int svc_i3c_update_ibirules(struct svc_i3c_master *master)\n{\n\tstruct i3c_dev_desc *dev;\n\tu32 reg_mbyte = 0, reg_nobyte = SVC_I3C_IBIRULES_NOBYTE;\n\tunsigned int mbyte_addr_ok = 0, mbyte_addr_ko = 0, nobyte_addr_ok = 0,\n\t\tnobyte_addr_ko = 0;\n\tbool list_mbyte = false, list_nobyte = false;\n\n\t \n\ti3c_bus_for_each_i3cdev(&master->base.bus, dev) {\n\t\tif (I3C_BCR_DEVICE_ROLE(dev->info.bcr) == I3C_BCR_I3C_MASTER)\n\t\t\tcontinue;\n\n\t\tif (dev->info.bcr & I3C_BCR_IBI_PAYLOAD) {\n\t\t\treg_mbyte |= SVC_I3C_IBIRULES_ADDR(mbyte_addr_ok,\n\t\t\t\t\t\t\t   dev->info.dyn_addr);\n\n\t\t\t \n\t\t\tif (dev->info.dyn_addr & BIT(7))\n\t\t\t\tmbyte_addr_ko++;\n\t\t\telse\n\t\t\t\tmbyte_addr_ok++;\n\t\t} else {\n\t\t\treg_nobyte |= SVC_I3C_IBIRULES_ADDR(nobyte_addr_ok,\n\t\t\t\t\t\t\t    dev->info.dyn_addr);\n\n\t\t\t \n\t\t\tif (dev->info.dyn_addr & BIT(7))\n\t\t\t\tnobyte_addr_ko++;\n\t\t\telse\n\t\t\t\tnobyte_addr_ok++;\n\t\t}\n\t}\n\n\t \n\tif (!mbyte_addr_ko && mbyte_addr_ok <= SVC_I3C_IBIRULES_ADDRS)\n\t\tlist_mbyte = true;\n\n\tif (!nobyte_addr_ko && nobyte_addr_ok <= SVC_I3C_IBIRULES_ADDRS)\n\t\tlist_nobyte = true;\n\n\t \n\tif (!list_mbyte && !list_nobyte)\n\t\treturn -ERANGE;\n\n\t \n\tif (list_mbyte)\n\t\twritel(reg_mbyte, master->regs + SVC_I3C_IBIRULES);\n\telse\n\t\twritel(reg_nobyte, master->regs + SVC_I3C_IBIRULES);\n\n\treturn 0;\n}\n\nstatic int svc_i3c_master_do_daa(struct i3c_master_controller *m)\n{\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tu8 addrs[SVC_I3C_MAX_DEVS];\n\tunsigned long flags;\n\tunsigned int dev_nb;\n\tint ret, i;\n\n\tret = pm_runtime_resume_and_get(master->dev);\n\tif (ret < 0) {\n\t\tdev_err(master->dev, \"<%s> Cannot get runtime PM.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tret = svc_i3c_master_do_daa_locked(master, addrs, &dev_nb);\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n\tif (ret) {\n\t\tsvc_i3c_master_emit_stop(master);\n\t\tsvc_i3c_master_clear_merrwarn(master);\n\t\tgoto rpm_out;\n\t}\n\n\t \n\tfor (i = 0; i < dev_nb; i++) {\n\t\tret = i3c_master_add_i3c_dev_locked(m, addrs[i]);\n\t\tif (ret)\n\t\t\tgoto rpm_out;\n\t}\n\n\t \n\tret = svc_i3c_update_ibirules(master);\n\tif (ret)\n\t\tdev_err(master->dev, \"Cannot handle such a list of devices\");\n\nrpm_out:\n\tpm_runtime_mark_last_busy(master->dev);\n\tpm_runtime_put_autosuspend(master->dev);\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_read(struct svc_i3c_master *master,\n\t\t\t       u8 *in, unsigned int len)\n{\n\tint offset = 0, i;\n\tu32 mdctrl, mstatus;\n\tbool completed = false;\n\tunsigned int count;\n\tunsigned long start = jiffies;\n\n\twhile (!completed) {\n\t\tmstatus = readl(master->regs + SVC_I3C_MSTATUS);\n\t\tif (SVC_I3C_MSTATUS_COMPLETE(mstatus) != 0)\n\t\t\tcompleted = true;\n\n\t\tif (time_after(jiffies, start + msecs_to_jiffies(1000))) {\n\t\t\tdev_dbg(master->dev, \"I3C read timeout\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tmdctrl = readl(master->regs + SVC_I3C_MDATACTRL);\n\t\tcount = SVC_I3C_MDATACTRL_RXCOUNT(mdctrl);\n\t\tif (offset + count > len) {\n\t\t\tdev_err(master->dev, \"I3C receive length too long!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfor (i = 0; i < count; i++)\n\t\t\tin[offset + i] = readl(master->regs + SVC_I3C_MRDATAB);\n\n\t\toffset += count;\n\t}\n\n\treturn offset;\n}\n\nstatic int svc_i3c_master_write(struct svc_i3c_master *master,\n\t\t\t\tconst u8 *out, unsigned int len)\n{\n\tint offset = 0, ret;\n\tu32 mdctrl;\n\n\twhile (offset < len) {\n\t\tret = readl_poll_timeout(master->regs + SVC_I3C_MDATACTRL,\n\t\t\t\t\t mdctrl,\n\t\t\t\t\t !(mdctrl & SVC_I3C_MDATACTRL_TXFULL),\n\t\t\t\t\t 0, 1000);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (likely(offset < (len - 1)))\n\t\t\twritel(out[offset++], master->regs + SVC_I3C_MWDATAB);\n\t\telse\n\t\t\twritel(out[offset++], master->regs + SVC_I3C_MWDATABE);\n\t}\n\n\treturn 0;\n}\n\nstatic int svc_i3c_master_xfer(struct svc_i3c_master *master,\n\t\t\t       bool rnw, unsigned int xfer_type, u8 addr,\n\t\t\t       u8 *in, const u8 *out, unsigned int xfer_len,\n\t\t\t       unsigned int *read_len, bool continued)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\twritel(SVC_I3C_MINT_IBIWON, master->regs + SVC_I3C_MSTATUS);\n\n\twritel(SVC_I3C_MCTRL_REQUEST_START_ADDR |\n\t       xfer_type |\n\t       SVC_I3C_MCTRL_IBIRESP_NACK |\n\t       SVC_I3C_MCTRL_DIR(rnw) |\n\t       SVC_I3C_MCTRL_ADDR(addr) |\n\t       SVC_I3C_MCTRL_RDTERM(*read_len),\n\t       master->regs + SVC_I3C_MCTRL);\n\n\tret = readl_poll_timeout(master->regs + SVC_I3C_MSTATUS, reg,\n\t\t\t\t SVC_I3C_MSTATUS_MCTRLDONE(reg), 0, 1000);\n\tif (ret)\n\t\tgoto emit_stop;\n\n\tif (readl(master->regs + SVC_I3C_MERRWARN) & SVC_I3C_MERRWARN_NACK) {\n\t\tret = -ENXIO;\n\t\tgoto emit_stop;\n\t}\n\n\t \n\tif (SVC_I3C_MSTATUS_IBIWON(reg)) {\n\t\tret = -ENXIO;\n\t\tgoto emit_stop;\n\t}\n\n\tif (rnw)\n\t\tret = svc_i3c_master_read(master, in, xfer_len);\n\telse\n\t\tret = svc_i3c_master_write(master, out, xfer_len);\n\tif (ret < 0)\n\t\tgoto emit_stop;\n\n\tif (rnw)\n\t\t*read_len = ret;\n\n\tret = readl_poll_timeout(master->regs + SVC_I3C_MSTATUS, reg,\n\t\t\t\t SVC_I3C_MSTATUS_COMPLETE(reg), 0, 1000);\n\tif (ret)\n\t\tgoto emit_stop;\n\n\twritel(SVC_I3C_MINT_COMPLETE, master->regs + SVC_I3C_MSTATUS);\n\n\tif (!continued) {\n\t\tsvc_i3c_master_emit_stop(master);\n\n\t\t \n\t\treadl_poll_timeout(master->regs + SVC_I3C_MSTATUS, reg,\n\t\t\t\t   SVC_I3C_MSTATUS_STATE_IDLE(reg), 0, 1000);\n\t}\n\n\treturn 0;\n\nemit_stop:\n\tsvc_i3c_master_emit_stop(master);\n\tsvc_i3c_master_clear_merrwarn(master);\n\n\treturn ret;\n}\n\nstatic struct svc_i3c_xfer *\nsvc_i3c_master_alloc_xfer(struct svc_i3c_master *master, unsigned int ncmds)\n{\n\tstruct svc_i3c_xfer *xfer;\n\n\txfer = kzalloc(struct_size(xfer, cmds, ncmds), GFP_KERNEL);\n\tif (!xfer)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&xfer->node);\n\txfer->ncmds = ncmds;\n\txfer->ret = -ETIMEDOUT;\n\n\treturn xfer;\n}\n\nstatic void svc_i3c_master_free_xfer(struct svc_i3c_xfer *xfer)\n{\n\tkfree(xfer);\n}\n\nstatic void svc_i3c_master_dequeue_xfer_locked(struct svc_i3c_master *master,\n\t\t\t\t\t       struct svc_i3c_xfer *xfer)\n{\n\tif (master->xferqueue.cur == xfer)\n\t\tmaster->xferqueue.cur = NULL;\n\telse\n\t\tlist_del_init(&xfer->node);\n}\n\nstatic void svc_i3c_master_dequeue_xfer(struct svc_i3c_master *master,\n\t\t\t\t\tstruct svc_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tsvc_i3c_master_dequeue_xfer_locked(master, xfer);\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n}\n\nstatic void svc_i3c_master_start_xfer_locked(struct svc_i3c_master *master)\n{\n\tstruct svc_i3c_xfer *xfer = master->xferqueue.cur;\n\tint ret, i;\n\n\tif (!xfer)\n\t\treturn;\n\n\tsvc_i3c_master_clear_merrwarn(master);\n\tsvc_i3c_master_flush_fifo(master);\n\n\tfor (i = 0; i < xfer->ncmds; i++) {\n\t\tstruct svc_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tret = svc_i3c_master_xfer(master, cmd->rnw, xfer->type,\n\t\t\t\t\t  cmd->addr, cmd->in, cmd->out,\n\t\t\t\t\t  cmd->len, &cmd->read_len,\n\t\t\t\t\t  cmd->continued);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\txfer->ret = ret;\n\tcomplete(&xfer->comp);\n\n\tif (ret < 0)\n\t\tsvc_i3c_master_dequeue_xfer_locked(master, xfer);\n\n\txfer = list_first_entry_or_null(&master->xferqueue.list,\n\t\t\t\t\tstruct svc_i3c_xfer,\n\t\t\t\t\tnode);\n\tif (xfer)\n\t\tlist_del_init(&xfer->node);\n\n\tmaster->xferqueue.cur = xfer;\n\tsvc_i3c_master_start_xfer_locked(master);\n}\n\nstatic void svc_i3c_master_enqueue_xfer(struct svc_i3c_master *master,\n\t\t\t\t\tstruct svc_i3c_xfer *xfer)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(master->dev);\n\tif (ret < 0) {\n\t\tdev_err(master->dev, \"<%s> Cannot get runtime PM.\\n\", __func__);\n\t\treturn;\n\t}\n\n\tinit_completion(&xfer->comp);\n\tspin_lock_irqsave(&master->xferqueue.lock, flags);\n\tif (master->xferqueue.cur) {\n\t\tlist_add_tail(&xfer->node, &master->xferqueue.list);\n\t} else {\n\t\tmaster->xferqueue.cur = xfer;\n\t\tsvc_i3c_master_start_xfer_locked(master);\n\t}\n\tspin_unlock_irqrestore(&master->xferqueue.lock, flags);\n\n\tpm_runtime_mark_last_busy(master->dev);\n\tpm_runtime_put_autosuspend(master->dev);\n}\n\nstatic bool\nsvc_i3c_master_supports_ccc_cmd(struct i3c_master_controller *master,\n\t\t\t\tconst struct i3c_ccc_cmd *cmd)\n{\n\t \n\treturn (cmd->ndests == 1);\n}\n\nstatic int svc_i3c_master_send_bdcast_ccc_cmd(struct svc_i3c_master *master,\n\t\t\t\t\t      struct i3c_ccc_cmd *ccc)\n{\n\tunsigned int xfer_len = ccc->dests[0].payload.len + 1;\n\tstruct svc_i3c_xfer *xfer;\n\tstruct svc_i3c_cmd *cmd;\n\tu8 *buf;\n\tint ret;\n\n\txfer = svc_i3c_master_alloc_xfer(master, 1);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(xfer_len, GFP_KERNEL);\n\tif (!buf) {\n\t\tsvc_i3c_master_free_xfer(xfer);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf[0] = ccc->id;\n\tmemcpy(&buf[1], ccc->dests[0].payload.data, ccc->dests[0].payload.len);\n\n\txfer->type = SVC_I3C_MCTRL_TYPE_I3C;\n\n\tcmd = &xfer->cmds[0];\n\tcmd->addr = ccc->dests[0].addr;\n\tcmd->rnw = ccc->rnw;\n\tcmd->in = NULL;\n\tcmd->out = buf;\n\tcmd->len = xfer_len;\n\tcmd->read_len = 0;\n\tcmd->continued = false;\n\n\tmutex_lock(&master->lock);\n\tsvc_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tsvc_i3c_master_dequeue_xfer(master, xfer);\n\tmutex_unlock(&master->lock);\n\n\tret = xfer->ret;\n\tkfree(buf);\n\tsvc_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_send_direct_ccc_cmd(struct svc_i3c_master *master,\n\t\t\t\t\t      struct i3c_ccc_cmd *ccc)\n{\n\tunsigned int xfer_len = ccc->dests[0].payload.len;\n\tunsigned int read_len = ccc->rnw ? xfer_len : 0;\n\tstruct svc_i3c_xfer *xfer;\n\tstruct svc_i3c_cmd *cmd;\n\tint ret;\n\n\txfer = svc_i3c_master_alloc_xfer(master, 2);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\txfer->type = SVC_I3C_MCTRL_TYPE_I3C;\n\n\t \n\tcmd = &xfer->cmds[0];\n\tcmd->addr = I3C_BROADCAST_ADDR;\n\tcmd->rnw = 0;\n\tcmd->in = NULL;\n\tcmd->out = &ccc->id;\n\tcmd->len = 1;\n\tcmd->read_len = 0;\n\tcmd->continued = true;\n\n\t \n\tcmd = &xfer->cmds[1];\n\tcmd->addr = ccc->dests[0].addr;\n\tcmd->rnw = ccc->rnw;\n\tcmd->in = ccc->rnw ? ccc->dests[0].payload.data : NULL;\n\tcmd->out = ccc->rnw ? NULL : ccc->dests[0].payload.data,\n\tcmd->len = xfer_len;\n\tcmd->read_len = read_len;\n\tcmd->continued = false;\n\n\tmutex_lock(&master->lock);\n\tsvc_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tsvc_i3c_master_dequeue_xfer(master, xfer);\n\tmutex_unlock(&master->lock);\n\n\tif (cmd->read_len != xfer_len)\n\t\tccc->dests[0].payload.len = cmd->read_len;\n\n\tret = xfer->ret;\n\tsvc_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_send_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\t       struct i3c_ccc_cmd *cmd)\n{\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tbool broadcast = cmd->id < 0x80;\n\tint ret;\n\n\tif (broadcast)\n\t\tret = svc_i3c_master_send_bdcast_ccc_cmd(master, cmd);\n\telse\n\t\tret = svc_i3c_master_send_direct_ccc_cmd(master, cmd);\n\n\tif (ret)\n\t\tcmd->err = I3C_ERROR_M2;\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_priv_xfers(struct i3c_dev_desc *dev,\n\t\t\t\t     struct i3c_priv_xfer *xfers,\n\t\t\t\t     int nxfers)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tstruct svc_i3c_xfer *xfer;\n\tint ret, i;\n\n\txfer = svc_i3c_master_alloc_xfer(master, nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\txfer->type = SVC_I3C_MCTRL_TYPE_I3C;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tstruct svc_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tcmd->addr = master->addrs[data->index];\n\t\tcmd->rnw = xfers[i].rnw;\n\t\tcmd->in = xfers[i].rnw ? xfers[i].data.in : NULL;\n\t\tcmd->out = xfers[i].rnw ? NULL : xfers[i].data.out;\n\t\tcmd->len = xfers[i].len;\n\t\tcmd->read_len = xfers[i].rnw ? xfers[i].len : 0;\n\t\tcmd->continued = (i + 1) < nxfers;\n\t}\n\n\tmutex_lock(&master->lock);\n\tsvc_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tsvc_i3c_master_dequeue_xfer(master, xfer);\n\tmutex_unlock(&master->lock);\n\n\tret = xfer->ret;\n\tsvc_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_i2c_xfers(struct i2c_dev_desc *dev,\n\t\t\t\t    const struct i2c_msg *xfers,\n\t\t\t\t    int nxfers)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data = i2c_dev_get_master_data(dev);\n\tstruct svc_i3c_xfer *xfer;\n\tint ret, i;\n\n\txfer = svc_i3c_master_alloc_xfer(master, nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\txfer->type = SVC_I3C_MCTRL_TYPE_I2C;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\tstruct svc_i3c_cmd *cmd = &xfer->cmds[i];\n\n\t\tcmd->addr = master->addrs[data->index];\n\t\tcmd->rnw = xfers[i].flags & I2C_M_RD;\n\t\tcmd->in = cmd->rnw ? xfers[i].buf : NULL;\n\t\tcmd->out = cmd->rnw ? NULL : xfers[i].buf;\n\t\tcmd->len = xfers[i].len;\n\t\tcmd->read_len = cmd->rnw ? xfers[i].len : 0;\n\t\tcmd->continued = (i + 1 < nxfers);\n\t}\n\n\tmutex_lock(&master->lock);\n\tsvc_i3c_master_enqueue_xfer(master, xfer);\n\tif (!wait_for_completion_timeout(&xfer->comp, msecs_to_jiffies(1000)))\n\t\tsvc_i3c_master_dequeue_xfer(master, xfer);\n\tmutex_unlock(&master->lock);\n\n\tret = xfer->ret;\n\tsvc_i3c_master_free_xfer(xfer);\n\n\treturn ret;\n}\n\nstatic int svc_i3c_master_request_ibi(struct i3c_dev_desc *dev,\n\t\t\t\t      const struct i3c_ibi_setup *req)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\tunsigned int i;\n\n\tif (dev->ibi->max_payload_len > SVC_I3C_FIFO_SIZE) {\n\t\tdev_err(master->dev, \"IBI max payload %d should be < %d\\n\",\n\t\t\tdev->ibi->max_payload_len, SVC_I3C_FIFO_SIZE);\n\t\treturn -ERANGE;\n\t}\n\n\tdata->ibi_pool = i3c_generic_ibi_alloc_pool(dev, req);\n\tif (IS_ERR(data->ibi_pool))\n\t\treturn PTR_ERR(data->ibi_pool);\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tfor (i = 0; i < master->ibi.num_slots; i++) {\n\t\tif (!master->ibi.slots[i]) {\n\t\t\tdata->ibi = i;\n\t\t\tmaster->ibi.slots[i] = dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\tif (i < master->ibi.num_slots)\n\t\treturn 0;\n\n\ti3c_generic_ibi_free_pool(data->ibi_pool);\n\tdata->ibi_pool = NULL;\n\n\treturn -ENOSPC;\n}\n\nstatic void svc_i3c_master_free_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&master->ibi.lock, flags);\n\tmaster->ibi.slots[data->ibi] = NULL;\n\tdata->ibi = -1;\n\tspin_unlock_irqrestore(&master->ibi.lock, flags);\n\n\ti3c_generic_ibi_free_pool(data->ibi_pool);\n}\n\nstatic int svc_i3c_master_enable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tint ret;\n\n\tret = pm_runtime_resume_and_get(master->dev);\n\tif (ret < 0) {\n\t\tdev_err(master->dev, \"<%s> Cannot get runtime PM.\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsvc_i3c_master_enable_interrupts(master, SVC_I3C_MINT_SLVSTART);\n\n\treturn i3c_master_enec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n}\n\nstatic int svc_i3c_master_disable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct svc_i3c_master *master = to_svc_i3c_master(m);\n\tint ret;\n\n\tsvc_i3c_master_disable_interrupts(master);\n\n\tret = i3c_master_disec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n\n\tpm_runtime_mark_last_busy(master->dev);\n\tpm_runtime_put_autosuspend(master->dev);\n\n\treturn ret;\n}\n\nstatic void svc_i3c_master_recycle_ibi_slot(struct i3c_dev_desc *dev,\n\t\t\t\t\t    struct i3c_ibi_slot *slot)\n{\n\tstruct svc_i3c_i2c_dev_data *data = i3c_dev_get_master_data(dev);\n\n\ti3c_generic_ibi_recycle_slot(data->ibi_pool, slot);\n}\n\nstatic const struct i3c_master_controller_ops svc_i3c_master_ops = {\n\t.bus_init = svc_i3c_master_bus_init,\n\t.bus_cleanup = svc_i3c_master_bus_cleanup,\n\t.attach_i3c_dev = svc_i3c_master_attach_i3c_dev,\n\t.detach_i3c_dev = svc_i3c_master_detach_i3c_dev,\n\t.reattach_i3c_dev = svc_i3c_master_reattach_i3c_dev,\n\t.attach_i2c_dev = svc_i3c_master_attach_i2c_dev,\n\t.detach_i2c_dev = svc_i3c_master_detach_i2c_dev,\n\t.do_daa = svc_i3c_master_do_daa,\n\t.supports_ccc_cmd = svc_i3c_master_supports_ccc_cmd,\n\t.send_ccc_cmd = svc_i3c_master_send_ccc_cmd,\n\t.priv_xfers = svc_i3c_master_priv_xfers,\n\t.i2c_xfers = svc_i3c_master_i2c_xfers,\n\t.request_ibi = svc_i3c_master_request_ibi,\n\t.free_ibi = svc_i3c_master_free_ibi,\n\t.recycle_ibi_slot = svc_i3c_master_recycle_ibi_slot,\n\t.enable_ibi = svc_i3c_master_enable_ibi,\n\t.disable_ibi = svc_i3c_master_disable_ibi,\n};\n\nstatic int svc_i3c_master_prepare_clks(struct svc_i3c_master *master)\n{\n\tint ret = 0;\n\n\tret = clk_prepare_enable(master->pclk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(master->fclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(master->pclk);\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(master->sclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(master->pclk);\n\t\tclk_disable_unprepare(master->fclk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void svc_i3c_master_unprepare_clks(struct svc_i3c_master *master)\n{\n\tclk_disable_unprepare(master->pclk);\n\tclk_disable_unprepare(master->fclk);\n\tclk_disable_unprepare(master->sclk);\n}\n\nstatic int svc_i3c_master_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct svc_i3c_master *master;\n\tint ret;\n\n\tmaster = devm_kzalloc(dev, sizeof(*master), GFP_KERNEL);\n\tif (!master)\n\t\treturn -ENOMEM;\n\n\tmaster->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(master->regs))\n\t\treturn PTR_ERR(master->regs);\n\n\tmaster->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(master->pclk))\n\t\treturn PTR_ERR(master->pclk);\n\n\tmaster->fclk = devm_clk_get(dev, \"fast_clk\");\n\tif (IS_ERR(master->fclk))\n\t\treturn PTR_ERR(master->fclk);\n\n\tmaster->sclk = devm_clk_get(dev, \"slow_clk\");\n\tif (IS_ERR(master->sclk))\n\t\treturn PTR_ERR(master->sclk);\n\n\tmaster->irq = platform_get_irq(pdev, 0);\n\tif (master->irq < 0)\n\t\treturn master->irq;\n\n\tmaster->dev = dev;\n\n\tret = svc_i3c_master_prepare_clks(master);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_WORK(&master->hj_work, svc_i3c_master_hj_work);\n\tINIT_WORK(&master->ibi_work, svc_i3c_master_ibi_work);\n\tmutex_init(&master->lock);\n\n\tret = devm_request_irq(dev, master->irq, svc_i3c_master_irq_handler,\n\t\t\t       IRQF_NO_SUSPEND, \"svc-i3c-irq\", master);\n\tif (ret)\n\t\tgoto err_disable_clks;\n\n\tmaster->free_slots = GENMASK(SVC_I3C_MAX_DEVS - 1, 0);\n\n\tspin_lock_init(&master->xferqueue.lock);\n\tINIT_LIST_HEAD(&master->xferqueue.list);\n\n\tspin_lock_init(&master->ibi.lock);\n\tmaster->ibi.num_slots = SVC_I3C_MAX_DEVS;\n\tmaster->ibi.slots = devm_kcalloc(&pdev->dev, master->ibi.num_slots,\n\t\t\t\t\t sizeof(*master->ibi.slots),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!master->ibi.slots) {\n\t\tret = -ENOMEM;\n\t\tgoto err_disable_clks;\n\t}\n\n\tplatform_set_drvdata(pdev, master);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, SVC_I3C_PM_TIMEOUT_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tsvc_i3c_master_reset(master);\n\n\t \n\tret = i3c_master_register(&master->base, &pdev->dev,\n\t\t\t\t  &svc_i3c_master_ops, false);\n\tif (ret)\n\t\tgoto rpm_disable;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nrpm_disable:\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\nerr_disable_clks:\n\tsvc_i3c_master_unprepare_clks(master);\n\n\treturn ret;\n}\n\nstatic void svc_i3c_master_remove(struct platform_device *pdev)\n{\n\tstruct svc_i3c_master *master = platform_get_drvdata(pdev);\n\n\ti3c_master_unregister(&master->base);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\nstatic void svc_i3c_save_regs(struct svc_i3c_master *master)\n{\n\tmaster->saved_regs.mconfig = readl(master->regs + SVC_I3C_MCONFIG);\n\tmaster->saved_regs.mdynaddr = readl(master->regs + SVC_I3C_MDYNADDR);\n}\n\nstatic void svc_i3c_restore_regs(struct svc_i3c_master *master)\n{\n\tif (readl(master->regs + SVC_I3C_MDYNADDR) !=\n\t    master->saved_regs.mdynaddr) {\n\t\twritel(master->saved_regs.mconfig,\n\t\t       master->regs + SVC_I3C_MCONFIG);\n\t\twritel(master->saved_regs.mdynaddr,\n\t\t       master->regs + SVC_I3C_MDYNADDR);\n\t}\n}\n\nstatic int __maybe_unused svc_i3c_runtime_suspend(struct device *dev)\n{\n\tstruct svc_i3c_master *master = dev_get_drvdata(dev);\n\n\tsvc_i3c_save_regs(master);\n\tsvc_i3c_master_unprepare_clks(master);\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused svc_i3c_runtime_resume(struct device *dev)\n{\n\tstruct svc_i3c_master *master = dev_get_drvdata(dev);\n\n\tpinctrl_pm_select_default_state(dev);\n\tsvc_i3c_master_prepare_clks(master);\n\n\tsvc_i3c_restore_regs(master);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops svc_i3c_pm_ops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\t      pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(svc_i3c_runtime_suspend,\n\t\t\t   svc_i3c_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id svc_i3c_master_of_match_tbl[] = {\n\t{ .compatible = \"silvaco,i3c-master\" },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, svc_i3c_master_of_match_tbl);\n\nstatic struct platform_driver svc_i3c_master = {\n\t.probe = svc_i3c_master_probe,\n\t.remove_new = svc_i3c_master_remove,\n\t.driver = {\n\t\t.name = \"silvaco-i3c-master\",\n\t\t.of_match_table = svc_i3c_master_of_match_tbl,\n\t\t.pm = &svc_i3c_pm_ops,\n\t},\n};\nmodule_platform_driver(svc_i3c_master);\n\nMODULE_AUTHOR(\"Conor Culhane <conor.culhane@silvaco.com>\");\nMODULE_AUTHOR(\"Miquel Raynal <miquel.raynal@bootlin.com>\");\nMODULE_DESCRIPTION(\"Silvaco dual-role I3C master driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}