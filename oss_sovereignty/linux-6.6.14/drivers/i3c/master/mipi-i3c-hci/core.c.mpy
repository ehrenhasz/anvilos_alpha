{
  "module_name": "core.c",
  "hash_id": "0d29fabe7a909a11b23e3a111ab9cd06058a1d1be8669364afb2a66d6c93e510",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/mipi-i3c-hci/core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include \"hci.h\"\n#include \"ext_caps.h\"\n#include \"cmd.h\"\n#include \"dat.h\"\n\n\n \n\n#define reg_read(r)\t\treadl(hci->base_regs + (r))\n#define reg_write(r, v)\t\twritel(v, hci->base_regs + (r))\n#define reg_set(r, v)\t\treg_write(r, reg_read(r) | (v))\n#define reg_clear(r, v)\t\treg_write(r, reg_read(r) & ~(v))\n\n#define HCI_VERSION\t\t\t0x00\t \n\n#define HC_CONTROL\t\t\t0x04\n#define HC_CONTROL_BUS_ENABLE\t\tBIT(31)\n#define HC_CONTROL_RESUME\t\tBIT(30)\n#define HC_CONTROL_ABORT\t\tBIT(29)\n#define HC_CONTROL_HALT_ON_CMD_TIMEOUT\tBIT(12)\n#define HC_CONTROL_HOT_JOIN_CTRL\tBIT(8)\t \n#define HC_CONTROL_I2C_TARGET_PRESENT\tBIT(7)\n#define HC_CONTROL_PIO_MODE\t\tBIT(6)\t \n#define HC_CONTROL_DATA_BIG_ENDIAN\tBIT(4)\n#define HC_CONTROL_IBA_INCLUDE\t\tBIT(0)\t \n\n#define MASTER_DEVICE_ADDR\t\t0x08\t \n#define MASTER_DYNAMIC_ADDR_VALID\tBIT(31)\t \n#define MASTER_DYNAMIC_ADDR(v)\t\tFIELD_PREP(GENMASK(22, 16), v)\n\n#define HC_CAPABILITIES\t\t\t0x0c\n#define HC_CAP_SG_DC_EN\t\t\tBIT(30)\n#define HC_CAP_SG_IBI_EN\t\tBIT(29)\n#define HC_CAP_SG_CR_EN\t\t\tBIT(28)\n#define HC_CAP_MAX_DATA_LENGTH\t\tGENMASK(24, 22)\n#define HC_CAP_CMD_SIZE\t\t\tGENMASK(21, 20)\n#define HC_CAP_DIRECT_COMMANDS_EN\tBIT(18)\n#define HC_CAP_MULTI_LANE_EN\t\tBIT(15)\n#define HC_CAP_CMD_CCC_DEFBYTE\t\tBIT(10)\n#define HC_CAP_HDR_BT_EN\t\tBIT(8)\n#define HC_CAP_HDR_TS_EN\t\tBIT(7)\n#define HC_CAP_HDR_DDR_EN\t\tBIT(6)\n#define HC_CAP_NON_CURRENT_MASTER_CAP\tBIT(5)\t \n#define HC_CAP_DATA_BYTE_CFG_EN\t\tBIT(4)\t \n#define HC_CAP_AUTO_COMMAND\t\tBIT(3)\n#define HC_CAP_COMBO_COMMAND\t\tBIT(2)\n\n#define RESET_CONTROL\t\t\t0x10\n#define BUS_RESET\t\t\tBIT(31)\n#define BUS_RESET_TYPE\t\t\tGENMASK(30, 29)\n#define IBI_QUEUE_RST\t\t\tBIT(5)\n#define RX_FIFO_RST\t\t\tBIT(4)\n#define TX_FIFO_RST\t\t\tBIT(3)\n#define RESP_QUEUE_RST\t\t\tBIT(2)\n#define CMD_QUEUE_RST\t\t\tBIT(1)\n#define SOFT_RST\t\t\tBIT(0)\t \n\n#define PRESENT_STATE\t\t\t0x14\n#define STATE_CURRENT_MASTER\t\tBIT(2)\n\n#define INTR_STATUS\t\t\t0x20\n#define INTR_STATUS_ENABLE\t\t0x24\n#define INTR_SIGNAL_ENABLE\t\t0x28\n#define INTR_FORCE\t\t\t0x2c\n#define INTR_HC_CMD_SEQ_UFLOW_STAT\tBIT(12)\t \n#define INTR_HC_RESET_CANCEL\t\tBIT(11)\t \n#define INTR_HC_INTERNAL_ERR\t\tBIT(10)\t \n#define INTR_HC_PIO\t\t\tBIT(8)\t \n#define INTR_HC_RINGS\t\t\tGENMASK(7, 0)\n\n#define DAT_SECTION\t\t\t0x30\t \n#define DAT_ENTRY_SIZE\t\t\tGENMASK(31, 28)\n#define DAT_TABLE_SIZE\t\t\tGENMASK(18, 12)\n#define DAT_TABLE_OFFSET\t\tGENMASK(11, 0)\n\n#define DCT_SECTION\t\t\t0x34\t \n#define DCT_ENTRY_SIZE\t\t\tGENMASK(31, 28)\n#define DCT_TABLE_INDEX\t\t\tGENMASK(23, 19)\n#define DCT_TABLE_SIZE\t\t\tGENMASK(18, 12)\n#define DCT_TABLE_OFFSET\t\tGENMASK(11, 0)\n\n#define RING_HEADERS_SECTION\t\t0x38\n#define RING_HEADERS_OFFSET\t\tGENMASK(15, 0)\n\n#define PIO_SECTION\t\t\t0x3c\n#define PIO_REGS_OFFSET\t\t\tGENMASK(15, 0)\t \n\n#define EXT_CAPS_SECTION\t\t0x40\n#define EXT_CAPS_OFFSET\t\t\tGENMASK(15, 0)\n\n#define IBI_NOTIFY_CTRL\t\t\t0x58\t \n#define IBI_NOTIFY_SIR_REJECTED\t\tBIT(3)\t \n#define IBI_NOTIFY_MR_REJECTED\t\tBIT(1)\t \n#define IBI_NOTIFY_HJ_REJECTED\t\tBIT(0)\t \n\n#define DEV_CTX_BASE_LO\t\t\t0x60\n#define DEV_CTX_BASE_HI\t\t\t0x64\n\n\nstatic inline struct i3c_hci *to_i3c_hci(struct i3c_master_controller *m)\n{\n\treturn container_of(m, struct i3c_hci, master);\n}\n\nstatic int i3c_hci_bus_init(struct i3c_master_controller *m)\n{\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_device_info info;\n\tint ret;\n\n\tDBG(\"\");\n\n\tif (hci->cmd == &mipi_i3c_hci_cmd_v1) {\n\t\tret = mipi_i3c_hci_dat_v1.init(hci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = i3c_master_get_free_addr(m, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treg_write(MASTER_DEVICE_ADDR,\n\t\t  MASTER_DYNAMIC_ADDR(ret) | MASTER_DYNAMIC_ADDR_VALID);\n\tmemset(&info, 0, sizeof(info));\n\tinfo.dyn_addr = ret;\n\tret = i3c_master_set_info(m, &info);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hci->io->init(hci);\n\tif (ret)\n\t\treturn ret;\n\n\treg_set(HC_CONTROL, HC_CONTROL_BUS_ENABLE);\n\tDBG(\"HC_CONTROL = %#x\", reg_read(HC_CONTROL));\n\n\treturn 0;\n}\n\nstatic void i3c_hci_bus_cleanup(struct i3c_master_controller *m)\n{\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\n\tDBG(\"\");\n\n\treg_clear(HC_CONTROL, HC_CONTROL_BUS_ENABLE);\n\thci->io->cleanup(hci);\n\tif (hci->cmd == &mipi_i3c_hci_cmd_v1)\n\t\tmipi_i3c_hci_dat_v1.cleanup(hci);\n}\n\nvoid mipi_i3c_hci_resume(struct i3c_hci *hci)\n{\n\t \n\treg_write(HC_CONTROL, reg_read(HC_CONTROL));\n}\n\n \nvoid mipi_i3c_hci_pio_reset(struct i3c_hci *hci)\n{\n\treg_write(RESET_CONTROL, RX_FIFO_RST | TX_FIFO_RST | RESP_QUEUE_RST);\n}\n\n \nvoid mipi_i3c_hci_dct_index_reset(struct i3c_hci *hci)\n{\n\treg_write(DCT_SECTION, FIELD_PREP(DCT_TABLE_INDEX, 0));\n}\n\nstatic int i3c_hci_send_ccc_cmd(struct i3c_master_controller *m,\n\t\t\t\tstruct i3c_ccc_cmd *ccc)\n{\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct hci_xfer *xfer;\n\tbool raw = !!(hci->quirks & HCI_QUIRK_RAW_CCC);\n\tbool prefixed = raw && !!(ccc->id & I3C_CCC_DIRECT);\n\tunsigned int nxfers = ccc->ndests + prefixed;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint i, last, ret = 0;\n\n\tDBG(\"cmd=%#x rnw=%d ndests=%d data[0].len=%d\",\n\t    ccc->id, ccc->rnw, ccc->ndests, ccc->dests[0].payload.len);\n\n\txfer = hci_alloc_xfer(nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tif (prefixed) {\n\t\txfer->data = NULL;\n\t\txfer->data_len = 0;\n\t\txfer->rnw = false;\n\t\thci->cmd->prep_ccc(hci, xfer, I3C_BROADCAST_ADDR,\n\t\t\t\t   ccc->id, true);\n\t\txfer++;\n\t}\n\n\tfor (i = 0; i < nxfers - prefixed; i++) {\n\t\txfer[i].data = ccc->dests[i].payload.data;\n\t\txfer[i].data_len = ccc->dests[i].payload.len;\n\t\txfer[i].rnw = ccc->rnw;\n\t\tret = hci->cmd->prep_ccc(hci, &xfer[i], ccc->dests[i].addr,\n\t\t\t\t\t ccc->id, raw);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\txfer[i].cmd_desc[0] |= CMD_0_ROC;\n\t}\n\tlast = i - 1;\n\txfer[last].cmd_desc[0] |= CMD_0_TOC;\n\txfer[last].completion = &done;\n\n\tif (prefixed)\n\t\txfer--;\n\n\tret = hci->io->queue_xfer(hci, xfer, nxfers);\n\tif (ret)\n\t\tgoto out;\n\tif (!wait_for_completion_timeout(&done, HZ) &&\n\t    hci->io->dequeue_xfer(hci, xfer, nxfers)) {\n\t\tret = -ETIME;\n\t\tgoto out;\n\t}\n\tfor (i = prefixed; i < nxfers; i++) {\n\t\tif (ccc->rnw)\n\t\t\tccc->dests[i - prefixed].payload.len =\n\t\t\t\tRESP_DATA_LENGTH(xfer[i].response);\n\t\tif (RESP_STATUS(xfer[i].response) != RESP_SUCCESS) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ccc->rnw)\n\t\tDBG(\"got: %*ph\",\n\t\t    ccc->dests[0].payload.len, ccc->dests[0].payload.data);\n\nout:\n\thci_free_xfer(xfer, nxfers);\n\treturn ret;\n}\n\nstatic int i3c_hci_daa(struct i3c_master_controller *m)\n{\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\n\tDBG(\"\");\n\n\treturn hci->cmd->perform_daa(hci);\n}\n\nstatic int i3c_hci_priv_xfers(struct i3c_dev_desc *dev,\n\t\t\t      struct i3c_priv_xfer *i3c_xfers,\n\t\t\t      int nxfers)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct hci_xfer *xfer;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tunsigned int size_limit;\n\tint i, last, ret = 0;\n\n\tDBG(\"nxfers = %d\", nxfers);\n\n\txfer = hci_alloc_xfer(nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tsize_limit = 1U << (16 + FIELD_GET(HC_CAP_MAX_DATA_LENGTH, hci->caps));\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\txfer[i].data_len = i3c_xfers[i].len;\n\t\tret = -EFBIG;\n\t\tif (xfer[i].data_len >= size_limit)\n\t\t\tgoto out;\n\t\txfer[i].rnw = i3c_xfers[i].rnw;\n\t\tif (i3c_xfers[i].rnw) {\n\t\t\txfer[i].data = i3c_xfers[i].data.in;\n\t\t} else {\n\t\t\t \n\t\t\txfer[i].data = (void *) i3c_xfers[i].data.out;\n\t\t}\n\t\thci->cmd->prep_i3c_xfer(hci, dev, &xfer[i]);\n\t\txfer[i].cmd_desc[0] |= CMD_0_ROC;\n\t}\n\tlast = i - 1;\n\txfer[last].cmd_desc[0] |= CMD_0_TOC;\n\txfer[last].completion = &done;\n\n\tret = hci->io->queue_xfer(hci, xfer, nxfers);\n\tif (ret)\n\t\tgoto out;\n\tif (!wait_for_completion_timeout(&done, HZ) &&\n\t    hci->io->dequeue_xfer(hci, xfer, nxfers)) {\n\t\tret = -ETIME;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (i3c_xfers[i].rnw)\n\t\t\ti3c_xfers[i].len = RESP_DATA_LENGTH(xfer[i].response);\n\t\tif (RESP_STATUS(xfer[i].response) != RESP_SUCCESS) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\thci_free_xfer(xfer, nxfers);\n\treturn ret;\n}\n\nstatic int i3c_hci_i2c_xfers(struct i2c_dev_desc *dev,\n\t\t\t     const struct i2c_msg *i2c_xfers, int nxfers)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct hci_xfer *xfer;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint i, last, ret = 0;\n\n\tDBG(\"nxfers = %d\", nxfers);\n\n\txfer = hci_alloc_xfer(nxfers);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < nxfers; i++) {\n\t\txfer[i].data = i2c_xfers[i].buf;\n\t\txfer[i].data_len = i2c_xfers[i].len;\n\t\txfer[i].rnw = i2c_xfers[i].flags & I2C_M_RD;\n\t\thci->cmd->prep_i2c_xfer(hci, dev, &xfer[i]);\n\t\txfer[i].cmd_desc[0] |= CMD_0_ROC;\n\t}\n\tlast = i - 1;\n\txfer[last].cmd_desc[0] |= CMD_0_TOC;\n\txfer[last].completion = &done;\n\n\tret = hci->io->queue_xfer(hci, xfer, nxfers);\n\tif (ret)\n\t\tgoto out;\n\tif (!wait_for_completion_timeout(&done, HZ) &&\n\t    hci->io->dequeue_xfer(hci, xfer, nxfers)) {\n\t\tret = -ETIME;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < nxfers; i++) {\n\t\tif (RESP_STATUS(xfer[i].response) != RESP_SUCCESS) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\thci_free_xfer(xfer, nxfers);\n\treturn ret;\n}\n\nstatic int i3c_hci_attach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data;\n\tint ret;\n\n\tDBG(\"\");\n\n\tdev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data)\n\t\treturn -ENOMEM;\n\tif (hci->cmd == &mipi_i3c_hci_cmd_v1) {\n\t\tret = mipi_i3c_hci_dat_v1.alloc_entry(hci);\n\t\tif (ret < 0) {\n\t\t\tkfree(dev_data);\n\t\t\treturn ret;\n\t\t}\n\t\tmipi_i3c_hci_dat_v1.set_dynamic_addr(hci, ret, dev->info.dyn_addr);\n\t\tdev_data->dat_idx = ret;\n\t}\n\ti3c_dev_set_master_data(dev, dev_data);\n\treturn 0;\n}\n\nstatic int i3c_hci_reattach_i3c_dev(struct i3c_dev_desc *dev, u8 old_dyn_addr)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\n\tDBG(\"\");\n\n\tif (hci->cmd == &mipi_i3c_hci_cmd_v1)\n\t\tmipi_i3c_hci_dat_v1.set_dynamic_addr(hci, dev_data->dat_idx,\n\t\t\t\t\t     dev->info.dyn_addr);\n\treturn 0;\n}\n\nstatic void i3c_hci_detach_i3c_dev(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\n\tDBG(\"\");\n\n\ti3c_dev_set_master_data(dev, NULL);\n\tif (hci->cmd == &mipi_i3c_hci_cmd_v1)\n\t\tmipi_i3c_hci_dat_v1.free_entry(hci, dev_data->dat_idx);\n\tkfree(dev_data);\n}\n\nstatic int i3c_hci_attach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data;\n\tint ret;\n\n\tDBG(\"\");\n\n\tif (hci->cmd != &mipi_i3c_hci_cmd_v1)\n\t\treturn 0;\n\tdev_data = kzalloc(sizeof(*dev_data), GFP_KERNEL);\n\tif (!dev_data)\n\t\treturn -ENOMEM;\n\tret = mipi_i3c_hci_dat_v1.alloc_entry(hci);\n\tif (ret < 0) {\n\t\tkfree(dev_data);\n\t\treturn ret;\n\t}\n\tmipi_i3c_hci_dat_v1.set_static_addr(hci, ret, dev->addr);\n\tmipi_i3c_hci_dat_v1.set_flags(hci, ret, DAT_0_I2C_DEVICE, 0);\n\tdev_data->dat_idx = ret;\n\ti2c_dev_set_master_data(dev, dev_data);\n\treturn 0;\n}\n\nstatic void i3c_hci_detach_i2c_dev(struct i2c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i2c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i2c_dev_get_master_data(dev);\n\n\tDBG(\"\");\n\n\tif (dev_data) {\n\t\ti2c_dev_set_master_data(dev, NULL);\n\t\tif (hci->cmd == &mipi_i3c_hci_cmd_v1)\n\t\t\tmipi_i3c_hci_dat_v1.free_entry(hci, dev_data->dat_idx);\n\t\tkfree(dev_data);\n\t}\n}\n\nstatic int i3c_hci_request_ibi(struct i3c_dev_desc *dev,\n\t\t\t       const struct i3c_ibi_setup *req)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\tunsigned int dat_idx = dev_data->dat_idx;\n\n\tif (req->max_payload_len != 0)\n\t\tmipi_i3c_hci_dat_v1.set_flags(hci, dat_idx, DAT_0_IBI_PAYLOAD, 0);\n\telse\n\t\tmipi_i3c_hci_dat_v1.clear_flags(hci, dat_idx, DAT_0_IBI_PAYLOAD, 0);\n\treturn hci->io->request_ibi(hci, dev, req);\n}\n\nstatic void i3c_hci_free_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\n\thci->io->free_ibi(hci, dev);\n}\n\nstatic int i3c_hci_enable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\n\tmipi_i3c_hci_dat_v1.clear_flags(hci, dev_data->dat_idx, DAT_0_SIR_REJECT, 0);\n\treturn i3c_master_enec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n}\n\nstatic int i3c_hci_disable_ibi(struct i3c_dev_desc *dev)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\n\tmipi_i3c_hci_dat_v1.set_flags(hci, dev_data->dat_idx, DAT_0_SIR_REJECT, 0);\n\treturn i3c_master_disec_locked(m, dev->info.dyn_addr, I3C_CCC_EVENT_SIR);\n}\n\nstatic void i3c_hci_recycle_ibi_slot(struct i3c_dev_desc *dev,\n\t\t\t\t     struct i3c_ibi_slot *slot)\n{\n\tstruct i3c_master_controller *m = i3c_dev_get_master(dev);\n\tstruct i3c_hci *hci = to_i3c_hci(m);\n\n\thci->io->recycle_ibi_slot(hci, dev, slot);\n}\n\nstatic const struct i3c_master_controller_ops i3c_hci_ops = {\n\t.bus_init\t\t= i3c_hci_bus_init,\n\t.bus_cleanup\t\t= i3c_hci_bus_cleanup,\n\t.do_daa\t\t\t= i3c_hci_daa,\n\t.send_ccc_cmd\t\t= i3c_hci_send_ccc_cmd,\n\t.priv_xfers\t\t= i3c_hci_priv_xfers,\n\t.i2c_xfers\t\t= i3c_hci_i2c_xfers,\n\t.attach_i3c_dev\t\t= i3c_hci_attach_i3c_dev,\n\t.reattach_i3c_dev\t= i3c_hci_reattach_i3c_dev,\n\t.detach_i3c_dev\t\t= i3c_hci_detach_i3c_dev,\n\t.attach_i2c_dev\t\t= i3c_hci_attach_i2c_dev,\n\t.detach_i2c_dev\t\t= i3c_hci_detach_i2c_dev,\n\t.request_ibi\t\t= i3c_hci_request_ibi,\n\t.free_ibi\t\t= i3c_hci_free_ibi,\n\t.enable_ibi\t\t= i3c_hci_enable_ibi,\n\t.disable_ibi\t\t= i3c_hci_disable_ibi,\n\t.recycle_ibi_slot\t= i3c_hci_recycle_ibi_slot,\n};\n\nstatic irqreturn_t i3c_hci_irq_handler(int irq, void *dev_id)\n{\n\tstruct i3c_hci *hci = dev_id;\n\tirqreturn_t result = IRQ_NONE;\n\tu32 val;\n\n\tval = reg_read(INTR_STATUS);\n\tDBG(\"INTR_STATUS = %#x\", val);\n\n\tif (val) {\n\t\treg_write(INTR_STATUS, val);\n\t} else {\n\t\t \n\t\tval |= INTR_HC_PIO;\n\t}\n\n\tif (val & INTR_HC_RESET_CANCEL) {\n\t\tDBG(\"cancelled reset\");\n\t\tval &= ~INTR_HC_RESET_CANCEL;\n\t}\n\tif (val & INTR_HC_INTERNAL_ERR) {\n\t\tdev_err(&hci->master.dev, \"Host Controller Internal Error\\n\");\n\t\tval &= ~INTR_HC_INTERNAL_ERR;\n\t}\n\tif (val & INTR_HC_PIO) {\n\t\thci->io->irq_handler(hci, 0);\n\t\tval &= ~INTR_HC_PIO;\n\t}\n\tif (val & INTR_HC_RINGS) {\n\t\thci->io->irq_handler(hci, val & INTR_HC_RINGS);\n\t\tval &= ~INTR_HC_RINGS;\n\t}\n\tif (val)\n\t\tdev_err(&hci->master.dev, \"unexpected INTR_STATUS %#x\\n\", val);\n\telse\n\t\tresult = IRQ_HANDLED;\n\n\treturn result;\n}\n\nstatic int i3c_hci_init(struct i3c_hci *hci)\n{\n\tu32 regval, offset;\n\tint ret;\n\n\t \n\tregval = reg_read(HCI_VERSION);\n\thci->version_major = (regval >> 8) & 0xf;\n\thci->version_minor = (regval >> 4) & 0xf;\n\thci->revision = regval & 0xf;\n\tdev_notice(&hci->master.dev, \"MIPI I3C HCI v%u.%u r%02u\\n\",\n\t\t   hci->version_major, hci->version_minor, hci->revision);\n\t \n\tswitch (regval & ~0xf) {\n\tcase 0x100:\t \n\tcase 0x110:\t \n\tcase 0x200:\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hci->master.dev, \"unsupported HCI version\\n\");\n\t\treturn -EPROTONOSUPPORT;\n\t}\n\n\thci->caps = reg_read(HC_CAPABILITIES);\n\tDBG(\"caps = %#x\", hci->caps);\n\n\tregval = reg_read(DAT_SECTION);\n\toffset = FIELD_GET(DAT_TABLE_OFFSET, regval);\n\thci->DAT_regs = offset ? hci->base_regs + offset : NULL;\n\thci->DAT_entries = FIELD_GET(DAT_TABLE_SIZE, regval);\n\thci->DAT_entry_size = FIELD_GET(DAT_ENTRY_SIZE, regval);\n\tdev_info(&hci->master.dev, \"DAT: %u %u-bytes entries at offset %#x\\n\",\n\t\t hci->DAT_entries, hci->DAT_entry_size * 4, offset);\n\n\tregval = reg_read(DCT_SECTION);\n\toffset = FIELD_GET(DCT_TABLE_OFFSET, regval);\n\thci->DCT_regs = offset ? hci->base_regs + offset : NULL;\n\thci->DCT_entries = FIELD_GET(DCT_TABLE_SIZE, regval);\n\thci->DCT_entry_size = FIELD_GET(DCT_ENTRY_SIZE, regval);\n\tdev_info(&hci->master.dev, \"DCT: %u %u-bytes entries at offset %#x\\n\",\n\t\t hci->DCT_entries, hci->DCT_entry_size * 4, offset);\n\n\tregval = reg_read(RING_HEADERS_SECTION);\n\toffset = FIELD_GET(RING_HEADERS_OFFSET, regval);\n\thci->RHS_regs = offset ? hci->base_regs + offset : NULL;\n\tdev_info(&hci->master.dev, \"Ring Headers at offset %#x\\n\", offset);\n\n\tregval = reg_read(PIO_SECTION);\n\toffset = FIELD_GET(PIO_REGS_OFFSET, regval);\n\thci->PIO_regs = offset ? hci->base_regs + offset : NULL;\n\tdev_info(&hci->master.dev, \"PIO section at offset %#x\\n\", offset);\n\n\tregval = reg_read(EXT_CAPS_SECTION);\n\toffset = FIELD_GET(EXT_CAPS_OFFSET, regval);\n\thci->EXTCAPS_regs = offset ? hci->base_regs + offset : NULL;\n\tdev_info(&hci->master.dev, \"Extended Caps at offset %#x\\n\", offset);\n\n\tret = i3c_hci_parse_ext_caps(hci);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = readx_poll_timeout(reg_read, RESET_CONTROL, regval,\n\t\t\t\t !(regval & SOFT_RST), 1, 10000);\n\tif (ret)\n\t\treturn -ENXIO;\n\treg_write(RESET_CONTROL, SOFT_RST);\n\tret = readx_poll_timeout(reg_read, RESET_CONTROL, regval,\n\t\t\t\t !(regval & SOFT_RST), 1, 10000);\n\tif (ret)\n\t\treturn -ENXIO;\n\n\t \n\treg_write(INTR_SIGNAL_ENABLE, 0x0);\n\treg_write(INTR_STATUS_ENABLE, 0xffffffff);\n\n\t \n\tregval = reg_read(HC_CONTROL);\n\tif (IS_ENABLED(CONFIG_CPU_BIG_ENDIAN)) {\n\t\tif (!(regval & HC_CONTROL_DATA_BIG_ENDIAN)) {\n\t\t\tregval |= HC_CONTROL_DATA_BIG_ENDIAN;\n\t\t\treg_write(HC_CONTROL, regval);\n\t\t\tregval = reg_read(HC_CONTROL);\n\t\t\tif (!(regval & HC_CONTROL_DATA_BIG_ENDIAN)) {\n\t\t\t\tdev_err(&hci->master.dev, \"cannot set BE mode\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (regval & HC_CONTROL_DATA_BIG_ENDIAN) {\n\t\t\tregval &= ~HC_CONTROL_DATA_BIG_ENDIAN;\n\t\t\treg_write(HC_CONTROL, regval);\n\t\t\tregval = reg_read(HC_CONTROL);\n\t\t\tif (regval & HC_CONTROL_DATA_BIG_ENDIAN) {\n\t\t\t\tdev_err(&hci->master.dev, \"cannot clear BE mode\\n\");\n\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tswitch (FIELD_GET(HC_CAP_CMD_SIZE, hci->caps)) {\n\tcase 0:\n\t\thci->cmd = &mipi_i3c_hci_cmd_v1;\n\t\tbreak;\n\tcase 1:\n\t\thci->cmd = &mipi_i3c_hci_cmd_v2;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&hci->master.dev, \"wrong CMD_SIZE capability value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (hci->RHS_regs) {\n\t\treg_clear(HC_CONTROL, HC_CONTROL_PIO_MODE);\n\t\tif (reg_read(HC_CONTROL) & HC_CONTROL_PIO_MODE) {\n\t\t\tdev_err(&hci->master.dev, \"PIO mode is stuck\\n\");\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\thci->io = &mipi_i3c_hci_dma;\n\t\t\tdev_info(&hci->master.dev, \"Using DMA\\n\");\n\t\t}\n\t}\n\n\t \n\tif (!hci->io && hci->PIO_regs) {\n\t\treg_set(HC_CONTROL, HC_CONTROL_PIO_MODE);\n\t\tif (!(reg_read(HC_CONTROL) & HC_CONTROL_PIO_MODE)) {\n\t\t\tdev_err(&hci->master.dev, \"DMA mode is stuck\\n\");\n\t\t\tret = -EIO;\n\t\t} else {\n\t\t\thci->io = &mipi_i3c_hci_pio;\n\t\t\tdev_info(&hci->master.dev, \"Using PIO\\n\");\n\t\t}\n\t}\n\n\tif (!hci->io) {\n\t\tdev_err(&hci->master.dev, \"neither DMA nor PIO can be used\\n\");\n\t\tif (!ret)\n\t\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int i3c_hci_probe(struct platform_device *pdev)\n{\n\tstruct i3c_hci *hci;\n\tint irq, ret;\n\n\thci = devm_kzalloc(&pdev->dev, sizeof(*hci), GFP_KERNEL);\n\tif (!hci)\n\t\treturn -ENOMEM;\n\thci->base_regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(hci->base_regs))\n\t\treturn PTR_ERR(hci->base_regs);\n\n\tplatform_set_drvdata(pdev, hci);\n\t \n\thci->master.dev.init_name = dev_name(&pdev->dev);\n\n\tret = i3c_hci_init(hci);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tret = devm_request_irq(&pdev->dev, irq, i3c_hci_irq_handler,\n\t\t\t       0, NULL, hci);\n\tif (ret)\n\t\treturn ret;\n\n\tret = i3c_master_register(&hci->master, &pdev->dev,\n\t\t\t\t  &i3c_hci_ops, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void i3c_hci_remove(struct platform_device *pdev)\n{\n\tstruct i3c_hci *hci = platform_get_drvdata(pdev);\n\n\ti3c_master_unregister(&hci->master);\n}\n\nstatic const __maybe_unused struct of_device_id i3c_hci_of_match[] = {\n\t{ .compatible = \"mipi-i3c-hci\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, i3c_hci_of_match);\n\nstatic struct platform_driver i3c_hci_driver = {\n\t.probe = i3c_hci_probe,\n\t.remove_new = i3c_hci_remove,\n\t.driver = {\n\t\t.name = \"mipi-i3c-hci\",\n\t\t.of_match_table = of_match_ptr(i3c_hci_of_match),\n\t},\n};\nmodule_platform_driver(i3c_hci_driver);\n\nMODULE_AUTHOR(\"Nicolas Pitre <npitre@baylibre.com>\");\nMODULE_DESCRIPTION(\"MIPI I3C HCI driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}