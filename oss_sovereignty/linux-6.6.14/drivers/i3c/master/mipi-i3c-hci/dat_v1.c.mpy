{
  "module_name": "dat_v1.c",
  "hash_id": "33473e949256f56af3fa1c376c70ae4c25188ad99dcf8f95616c308442fa4c73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/mipi-i3c-hci/dat_v1.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitmap.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/io.h>\n\n#include \"hci.h\"\n#include \"dat.h\"\n\n\n \n\n#define DAT_1_AUTOCMD_HDR_CODE\t\tW1_MASK(58, 51)\n#define DAT_1_AUTOCMD_MODE\t\tW1_MASK(50, 48)\n#define DAT_1_AUTOCMD_VALUE\t\tW1_MASK(47, 40)\n#define DAT_1_AUTOCMD_MASK\t\tW1_MASK(39, 32)\n \n#define DAT_0_DEV_NACK_RETRY_CNT\tW0_MASK(30, 29)\n#define DAT_0_RING_ID\t\t\tW0_MASK(28, 26)\n#define DAT_0_DYNADDR_PARITY\t\tW0_BIT_(23)\n#define DAT_0_DYNAMIC_ADDRESS\t\tW0_MASK(22, 16)\n#define DAT_0_TS\t\t\tW0_BIT_(15)\n#define DAT_0_MR_REJECT\t\t\tW0_BIT_(14)\n \n \n#define DAT_0_STATIC_ADDRESS\t\tW0_MASK(6, 0)\n\n#define dat_w0_read(i)\t\treadl(hci->DAT_regs + (i) * 8)\n#define dat_w1_read(i)\t\treadl(hci->DAT_regs + (i) * 8 + 4)\n#define dat_w0_write(i, v)\twritel(v, hci->DAT_regs + (i) * 8)\n#define dat_w1_write(i, v)\twritel(v, hci->DAT_regs + (i) * 8 + 4)\n\nstatic inline bool dynaddr_parity(unsigned int addr)\n{\n\taddr |= 1 << 7;\n\taddr += addr >> 4;\n\taddr += addr >> 2;\n\taddr += addr >> 1;\n\treturn (addr & 1);\n}\n\nstatic int hci_dat_v1_init(struct i3c_hci *hci)\n{\n\tunsigned int dat_idx;\n\n\tif (!hci->DAT_regs) {\n\t\tdev_err(&hci->master.dev,\n\t\t\t\"only DAT in register space is supported at the moment\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\tif (hci->DAT_entry_size != 8) {\n\t\tdev_err(&hci->master.dev,\n\t\t\t\"only 8-bytes DAT entries are supported at the moment\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!hci->DAT_data) {\n\t\t \n\t\thci->DAT_data = bitmap_zalloc(hci->DAT_entries, GFP_KERNEL);\n\t\tif (!hci->DAT_data)\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tfor (dat_idx = 0; dat_idx < hci->DAT_entries; dat_idx++) {\n\t\t\tdat_w0_write(dat_idx, 0);\n\t\t\tdat_w1_write(dat_idx, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void hci_dat_v1_cleanup(struct i3c_hci *hci)\n{\n\tbitmap_free(hci->DAT_data);\n\thci->DAT_data = NULL;\n}\n\nstatic int hci_dat_v1_alloc_entry(struct i3c_hci *hci)\n{\n\tunsigned int dat_idx;\n\tint ret;\n\n\tif (!hci->DAT_data) {\n\t\tret = hci_dat_v1_init(hci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdat_idx = find_first_zero_bit(hci->DAT_data, hci->DAT_entries);\n\tif (dat_idx >= hci->DAT_entries)\n\t\treturn -ENOENT;\n\t__set_bit(dat_idx, hci->DAT_data);\n\n\t \n\tdat_w0_write(dat_idx, DAT_0_SIR_REJECT | DAT_0_MR_REJECT);\n\n\treturn dat_idx;\n}\n\nstatic void hci_dat_v1_free_entry(struct i3c_hci *hci, unsigned int dat_idx)\n{\n\tdat_w0_write(dat_idx, 0);\n\tdat_w1_write(dat_idx, 0);\n\tif (hci->DAT_data)\n\t\t__clear_bit(dat_idx, hci->DAT_data);\n}\n\nstatic void hci_dat_v1_set_dynamic_addr(struct i3c_hci *hci,\n\t\t\t\t\tunsigned int dat_idx, u8 address)\n{\n\tu32 dat_w0;\n\n\tdat_w0 = dat_w0_read(dat_idx);\n\tdat_w0 &= ~(DAT_0_DYNAMIC_ADDRESS | DAT_0_DYNADDR_PARITY);\n\tdat_w0 |= FIELD_PREP(DAT_0_DYNAMIC_ADDRESS, address) |\n\t\t  (dynaddr_parity(address) ? DAT_0_DYNADDR_PARITY : 0);\n\tdat_w0_write(dat_idx, dat_w0);\n}\n\nstatic void hci_dat_v1_set_static_addr(struct i3c_hci *hci,\n\t\t\t\t       unsigned int dat_idx, u8 address)\n{\n\tu32 dat_w0;\n\n\tdat_w0 = dat_w0_read(dat_idx);\n\tdat_w0 &= ~DAT_0_STATIC_ADDRESS;\n\tdat_w0 |= FIELD_PREP(DAT_0_STATIC_ADDRESS, address);\n\tdat_w0_write(dat_idx, dat_w0);\n}\n\nstatic void hci_dat_v1_set_flags(struct i3c_hci *hci, unsigned int dat_idx,\n\t\t\t\t u32 w0_flags, u32 w1_flags)\n{\n\tu32 dat_w0, dat_w1;\n\n\tdat_w0 = dat_w0_read(dat_idx);\n\tdat_w1 = dat_w1_read(dat_idx);\n\tdat_w0 |= w0_flags;\n\tdat_w1 |= w1_flags;\n\tdat_w0_write(dat_idx, dat_w0);\n\tdat_w1_write(dat_idx, dat_w1);\n}\n\nstatic void hci_dat_v1_clear_flags(struct i3c_hci *hci, unsigned int dat_idx,\n\t\t\t\t   u32 w0_flags, u32 w1_flags)\n{\n\tu32 dat_w0, dat_w1;\n\n\tdat_w0 = dat_w0_read(dat_idx);\n\tdat_w1 = dat_w1_read(dat_idx);\n\tdat_w0 &= ~w0_flags;\n\tdat_w1 &= ~w1_flags;\n\tdat_w0_write(dat_idx, dat_w0);\n\tdat_w1_write(dat_idx, dat_w1);\n}\n\nstatic int hci_dat_v1_get_index(struct i3c_hci *hci, u8 dev_addr)\n{\n\tunsigned int dat_idx;\n\tu32 dat_w0;\n\n\tfor_each_set_bit(dat_idx, hci->DAT_data, hci->DAT_entries) {\n\t\tdat_w0 = dat_w0_read(dat_idx);\n\t\tif (FIELD_GET(DAT_0_DYNAMIC_ADDRESS, dat_w0) == dev_addr)\n\t\t\treturn dat_idx;\n\t}\n\n\treturn -ENODEV;\n}\n\nconst struct hci_dat_ops mipi_i3c_hci_dat_v1 = {\n\t.init\t\t\t= hci_dat_v1_init,\n\t.cleanup\t\t= hci_dat_v1_cleanup,\n\t.alloc_entry\t\t= hci_dat_v1_alloc_entry,\n\t.free_entry\t\t= hci_dat_v1_free_entry,\n\t.set_dynamic_addr\t= hci_dat_v1_set_dynamic_addr,\n\t.set_static_addr\t= hci_dat_v1_set_static_addr,\n\t.set_flags\t\t= hci_dat_v1_set_flags,\n\t.clear_flags\t\t= hci_dat_v1_clear_flags,\n\t.get_index\t\t= hci_dat_v1_get_index,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}