{
  "module_name": "cmd_v1.c",
  "hash_id": "ee7c0bb27d019ec58a9d47965ac0f511f8755a6187f8b112c478a5a1252699c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/mipi-i3c-hci/cmd_v1.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i3c/master.h>\n\n#include \"hci.h\"\n#include \"cmd.h\"\n#include \"dat.h\"\n#include \"dct.h\"\n\n\n \n\n#define CMD_0_ATTR_A\t\t\tFIELD_PREP(CMD_0_ATTR, 0x2)\n\n#define CMD_A0_TOC\t\t\t\t   W0_BIT_(31)\n#define CMD_A0_ROC\t\t\t\t   W0_BIT_(30)\n#define CMD_A0_DEV_COUNT(v)\t\tFIELD_PREP(W0_MASK(29, 26), v)\n#define CMD_A0_DEV_INDEX(v)\t\tFIELD_PREP(W0_MASK(20, 16), v)\n#define CMD_A0_CMD(v)\t\t\tFIELD_PREP(W0_MASK(14,  7), v)\n#define CMD_A0_TID(v)\t\t\tFIELD_PREP(W0_MASK( 6,  3), v)\n\n \n\n#define CMD_0_ATTR_I\t\t\tFIELD_PREP(CMD_0_ATTR, 0x1)\n\n#define CMD_I1_DATA_BYTE_4(v)\t\tFIELD_PREP(W1_MASK(63, 56), v)\n#define CMD_I1_DATA_BYTE_3(v)\t\tFIELD_PREP(W1_MASK(55, 48), v)\n#define CMD_I1_DATA_BYTE_2(v)\t\tFIELD_PREP(W1_MASK(47, 40), v)\n#define CMD_I1_DATA_BYTE_1(v)\t\tFIELD_PREP(W1_MASK(39, 32), v)\n#define CMD_I1_DEF_BYTE(v)\t\tFIELD_PREP(W1_MASK(39, 32), v)\n#define CMD_I0_TOC\t\t\t\t   W0_BIT_(31)\n#define CMD_I0_ROC\t\t\t\t   W0_BIT_(30)\n#define CMD_I0_RNW\t\t\t\t   W0_BIT_(29)\n#define CMD_I0_MODE(v)\t\t\tFIELD_PREP(W0_MASK(28, 26), v)\n#define CMD_I0_DTT(v)\t\t\tFIELD_PREP(W0_MASK(25, 23), v)\n#define CMD_I0_DEV_INDEX(v)\t\tFIELD_PREP(W0_MASK(20, 16), v)\n#define CMD_I0_CP\t\t\t\t   W0_BIT_(15)\n#define CMD_I0_CMD(v)\t\t\tFIELD_PREP(W0_MASK(14,  7), v)\n#define CMD_I0_TID(v)\t\t\tFIELD_PREP(W0_MASK( 6,  3), v)\n\n \n\n#define CMD_0_ATTR_R\t\t\tFIELD_PREP(CMD_0_ATTR, 0x0)\n\n#define CMD_R1_DATA_LENGTH(v)\t\tFIELD_PREP(W1_MASK(63, 48), v)\n#define CMD_R1_DEF_BYTE(v)\t\tFIELD_PREP(W1_MASK(39, 32), v)\n#define CMD_R0_TOC\t\t\t\t   W0_BIT_(31)\n#define CMD_R0_ROC\t\t\t\t   W0_BIT_(30)\n#define CMD_R0_RNW\t\t\t\t   W0_BIT_(29)\n#define CMD_R0_MODE(v)\t\t\tFIELD_PREP(W0_MASK(28, 26), v)\n#define CMD_R0_DBP\t\t\t\t   W0_BIT_(25)\n#define CMD_R0_DEV_INDEX(v)\t\tFIELD_PREP(W0_MASK(20, 16), v)\n#define CMD_R0_CP\t\t\t\t   W0_BIT_(15)\n#define CMD_R0_CMD(v)\t\t\tFIELD_PREP(W0_MASK(14,  7), v)\n#define CMD_R0_TID(v)\t\t\tFIELD_PREP(W0_MASK( 6,  3), v)\n\n \n\n#define CMD_0_ATTR_C\t\t\tFIELD_PREP(CMD_0_ATTR, 0x3)\n\n#define CMD_C1_DATA_LENGTH(v)\t\tFIELD_PREP(W1_MASK(63, 48), v)\n#define CMD_C1_OFFSET(v)\t\tFIELD_PREP(W1_MASK(47, 32), v)\n#define CMD_C0_TOC\t\t\t\t   W0_BIT_(31)\n#define CMD_C0_ROC\t\t\t\t   W0_BIT_(30)\n#define CMD_C0_RNW\t\t\t\t   W0_BIT_(29)\n#define CMD_C0_MODE(v)\t\t\tFIELD_PREP(W0_MASK(28, 26), v)\n#define CMD_C0_16_BIT_SUBOFFSET\t\t\t   W0_BIT_(25)\n#define CMD_C0_FIRST_PHASE_MODE\t\t\t   W0_BIT_(24)\n#define CMD_C0_DATA_LENGTH_POSITION(v)\tFIELD_PREP(W0_MASK(23, 22), v)\n#define CMD_C0_DEV_INDEX(v)\t\tFIELD_PREP(W0_MASK(20, 16), v)\n#define CMD_C0_CP\t\t\t\t   W0_BIT_(15)\n#define CMD_C0_CMD(v)\t\t\tFIELD_PREP(W0_MASK(14,  7), v)\n#define CMD_C0_TID(v)\t\t\tFIELD_PREP(W0_MASK( 6,  3), v)\n\n \n\n#define CMD_0_ATTR_M\t\t\tFIELD_PREP(CMD_0_ATTR, 0x7)\n\n#define CMD_M1_VENDOR_SPECIFIC\t\t\t   W1_MASK(63, 32)\n#define CMD_M0_MIPI_RESERVED\t\t\t   W0_MASK(31, 12)\n#define CMD_M0_MIPI_CMD\t\t\t\t   W0_MASK(11,  8)\n#define CMD_M0_VENDOR_INFO_PRESENT\t\t   W0_BIT_( 7)\n#define CMD_M0_TID(v)\t\t\tFIELD_PREP(W0_MASK( 6,  3), v)\n\n\n \nenum hci_cmd_mode {\n\tMODE_I3C_SDR0\t\t= 0x0,\n\tMODE_I3C_SDR1\t\t= 0x1,\n\tMODE_I3C_SDR2\t\t= 0x2,\n\tMODE_I3C_SDR3\t\t= 0x3,\n\tMODE_I3C_SDR4\t\t= 0x4,\n\tMODE_I3C_HDR_TSx\t= 0x5,\n\tMODE_I3C_HDR_DDR\t= 0x6,\n\tMODE_I3C_HDR_BT\t\t= 0x7,\n\tMODE_I3C_Fm_FmP\t\t= 0x8,\n\tMODE_I2C_Fm\t\t= 0x0,\n\tMODE_I2C_FmP\t\t= 0x1,\n\tMODE_I2C_UD1\t\t= 0x2,\n\tMODE_I2C_UD2\t\t= 0x3,\n\tMODE_I2C_UD3\t\t= 0x4,\n};\n\nstatic enum hci_cmd_mode get_i3c_mode(struct i3c_hci *hci)\n{\n\tstruct i3c_bus *bus = i3c_master_get_bus(&hci->master);\n\n\tif (bus->scl_rate.i3c >= 12500000)\n\t\treturn MODE_I3C_SDR0;\n\tif (bus->scl_rate.i3c > 8000000)\n\t\treturn MODE_I3C_SDR1;\n\tif (bus->scl_rate.i3c > 6000000)\n\t\treturn MODE_I3C_SDR2;\n\tif (bus->scl_rate.i3c > 4000000)\n\t\treturn MODE_I3C_SDR3;\n\tif (bus->scl_rate.i3c > 2000000)\n\t\treturn MODE_I3C_SDR4;\n\treturn MODE_I3C_Fm_FmP;\n}\n\nstatic enum hci_cmd_mode get_i2c_mode(struct i3c_hci *hci)\n{\n\tstruct i3c_bus *bus = i3c_master_get_bus(&hci->master);\n\n\tif (bus->scl_rate.i2c >= 1000000)\n\t\treturn MODE_I2C_FmP;\n\treturn MODE_I2C_Fm;\n}\n\nstatic void fill_data_bytes(struct hci_xfer *xfer, u8 *data,\n\t\t\t    unsigned int data_len)\n{\n\txfer->cmd_desc[1] = 0;\n\tswitch (data_len) {\n\tcase 4:\n\t\txfer->cmd_desc[1] |= CMD_I1_DATA_BYTE_4(data[3]);\n\t\tfallthrough;\n\tcase 3:\n\t\txfer->cmd_desc[1] |= CMD_I1_DATA_BYTE_3(data[2]);\n\t\tfallthrough;\n\tcase 2:\n\t\txfer->cmd_desc[1] |= CMD_I1_DATA_BYTE_2(data[1]);\n\t\tfallthrough;\n\tcase 1:\n\t\txfer->cmd_desc[1] |= CMD_I1_DATA_BYTE_1(data[0]);\n\t\tfallthrough;\n\tcase 0:\n\t\tbreak;\n\t}\n\t \n\txfer->data = NULL;\n}\n\nstatic int hci_cmd_v1_prep_ccc(struct i3c_hci *hci,\n\t\t\t       struct hci_xfer *xfer,\n\t\t\t       u8 ccc_addr, u8 ccc_cmd, bool raw)\n{\n\tunsigned int dat_idx = 0;\n\tenum hci_cmd_mode mode = get_i3c_mode(hci);\n\tu8 *data = xfer->data;\n\tunsigned int data_len = xfer->data_len;\n\tbool rnw = xfer->rnw;\n\tint ret;\n\n\t \n\tif (WARN_ON(raw))\n\t\treturn -EINVAL;\n\n\tif (ccc_addr != I3C_BROADCAST_ADDR) {\n\t\tret = mipi_i3c_hci_dat_v1.get_index(hci, ccc_addr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdat_idx = ret;\n\t}\n\n\txfer->cmd_tid = hci_get_tid();\n\n\tif (!rnw && data_len <= 4) {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_I |\n\t\t\tCMD_I0_TID(xfer->cmd_tid) |\n\t\t\tCMD_I0_CMD(ccc_cmd) | CMD_I0_CP |\n\t\t\tCMD_I0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_I0_DTT(data_len) |\n\t\t\tCMD_I0_MODE(mode);\n\t\tfill_data_bytes(xfer, data, data_len);\n\t} else {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_R |\n\t\t\tCMD_R0_TID(xfer->cmd_tid) |\n\t\t\tCMD_R0_CMD(ccc_cmd) | CMD_R0_CP |\n\t\t\tCMD_R0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_R0_MODE(mode) |\n\t\t\t(rnw ? CMD_R0_RNW : 0);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_R1_DATA_LENGTH(data_len);\n\t}\n\n\treturn 0;\n}\n\nstatic void hci_cmd_v1_prep_i3c_xfer(struct i3c_hci *hci,\n\t\t\t\t     struct i3c_dev_desc *dev,\n\t\t\t\t     struct hci_xfer *xfer)\n{\n\tstruct i3c_hci_dev_data *dev_data = i3c_dev_get_master_data(dev);\n\tunsigned int dat_idx = dev_data->dat_idx;\n\tenum hci_cmd_mode mode = get_i3c_mode(hci);\n\tu8 *data = xfer->data;\n\tunsigned int data_len = xfer->data_len;\n\tbool rnw = xfer->rnw;\n\n\txfer->cmd_tid = hci_get_tid();\n\n\tif (!rnw && data_len <= 4) {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_I |\n\t\t\tCMD_I0_TID(xfer->cmd_tid) |\n\t\t\tCMD_I0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_I0_DTT(data_len) |\n\t\t\tCMD_I0_MODE(mode);\n\t\tfill_data_bytes(xfer, data, data_len);\n\t} else {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_R |\n\t\t\tCMD_R0_TID(xfer->cmd_tid) |\n\t\t\tCMD_R0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_R0_MODE(mode) |\n\t\t\t(rnw ? CMD_R0_RNW : 0);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_R1_DATA_LENGTH(data_len);\n\t}\n}\n\nstatic void hci_cmd_v1_prep_i2c_xfer(struct i3c_hci *hci,\n\t\t\t\t     struct i2c_dev_desc *dev,\n\t\t\t\t     struct hci_xfer *xfer)\n{\n\tstruct i3c_hci_dev_data *dev_data = i2c_dev_get_master_data(dev);\n\tunsigned int dat_idx = dev_data->dat_idx;\n\tenum hci_cmd_mode mode = get_i2c_mode(hci);\n\tu8 *data = xfer->data;\n\tunsigned int data_len = xfer->data_len;\n\tbool rnw = xfer->rnw;\n\n\txfer->cmd_tid = hci_get_tid();\n\n\tif (!rnw && data_len <= 4) {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_I |\n\t\t\tCMD_I0_TID(xfer->cmd_tid) |\n\t\t\tCMD_I0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_I0_DTT(data_len) |\n\t\t\tCMD_I0_MODE(mode);\n\t\tfill_data_bytes(xfer, data, data_len);\n\t} else {\n\t\t \n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_R |\n\t\t\tCMD_R0_TID(xfer->cmd_tid) |\n\t\t\tCMD_R0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_R0_MODE(mode) |\n\t\t\t(rnw ? CMD_R0_RNW : 0);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_R1_DATA_LENGTH(data_len);\n\t}\n}\n\nstatic int hci_cmd_v1_daa(struct i3c_hci *hci)\n{\n\tstruct hci_xfer *xfer;\n\tint ret, dat_idx = -1;\n\tu8 next_addr = 0;\n\tu64 pid;\n\tunsigned int dcr, bcr;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\txfer = hci_alloc_xfer(2);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (;;) {\n\t\tret = mipi_i3c_hci_dat_v1.alloc_entry(hci);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tdat_idx = ret;\n\t\tret = i3c_master_get_free_addr(&hci->master, next_addr);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tnext_addr = ret;\n\n\t\tDBG(\"next_addr = 0x%02x, DAA using DAT %d\", next_addr, dat_idx);\n\t\tmipi_i3c_hci_dat_v1.set_dynamic_addr(hci, dat_idx, next_addr);\n\t\tmipi_i3c_hci_dct_index_reset(hci);\n\n\t\txfer->cmd_tid = hci_get_tid();\n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_A |\n\t\t\tCMD_A0_TID(xfer->cmd_tid) |\n\t\t\tCMD_A0_CMD(I3C_CCC_ENTDAA) |\n\t\t\tCMD_A0_DEV_INDEX(dat_idx) |\n\t\t\tCMD_A0_DEV_COUNT(1) |\n\t\t\tCMD_A0_ROC | CMD_A0_TOC;\n\t\txfer->cmd_desc[1] = 0;\n\t\thci->io->queue_xfer(hci, xfer, 1);\n\t\tif (!wait_for_completion_timeout(&done, HZ) &&\n\t\t    hci->io->dequeue_xfer(hci, xfer, 1)) {\n\t\t\tret = -ETIME;\n\t\t\tbreak;\n\t\t}\n\t\tif (RESP_STATUS(xfer[0].response) == RESP_ERR_NACK &&\n\t\t    RESP_DATA_LENGTH(xfer->response) == 1) {\n\t\t\tret = 0;   \n\t\t\tbreak;\n\t\t}\n\t\tif (RESP_STATUS(xfer[0].response) != RESP_SUCCESS) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\ti3c_hci_dct_get_val(hci, 0, &pid, &dcr, &bcr);\n\t\tDBG(\"assigned address %#x to device PID=0x%llx DCR=%#x BCR=%#x\",\n\t\t    next_addr, pid, dcr, bcr);\n\n\t\tmipi_i3c_hci_dat_v1.free_entry(hci, dat_idx);\n\t\tdat_idx = -1;\n\n\t\t \n\t\tret = i3c_master_add_i3c_dev_locked(&hci->master, next_addr);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tif (dat_idx >= 0)\n\t\tmipi_i3c_hci_dat_v1.free_entry(hci, dat_idx);\n\thci_free_xfer(xfer, 1);\n\treturn ret;\n}\n\nconst struct hci_cmd_ops mipi_i3c_hci_cmd_v1 = {\n\t.prep_ccc\t\t= hci_cmd_v1_prep_ccc,\n\t.prep_i3c_xfer\t\t= hci_cmd_v1_prep_i3c_xfer,\n\t.prep_i2c_xfer\t\t= hci_cmd_v1_prep_i2c_xfer,\n\t.perform_daa\t\t= hci_cmd_v1_daa,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}