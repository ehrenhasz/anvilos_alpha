{
  "module_name": "cmd_v2.c",
  "hash_id": "50ed5c860145d2cd8da977ce695672ca17c2f1bce3b1d5235c4e77e9b0e90fde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/mipi-i3c-hci/cmd_v2.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i3c/master.h>\n\n#include \"hci.h\"\n#include \"cmd.h\"\n#include \"xfer_mode_rate.h\"\n\n\n \n\n#define CMD_0_ATTR_U\t\t\tFIELD_PREP(CMD_0_ATTR, 0x4)\n\n#define CMD_U3_HDR_TSP_ML_CTRL(v)\tFIELD_PREP(W3_MASK(107, 104), v)\n#define CMD_U3_IDB4(v)\t\t\tFIELD_PREP(W3_MASK(103,  96), v)\n#define CMD_U3_HDR_CMD(v)\t\tFIELD_PREP(W3_MASK(103,  96), v)\n#define CMD_U2_IDB3(v)\t\t\tFIELD_PREP(W2_MASK( 95,  88), v)\n#define CMD_U2_HDR_BT(v)\t\tFIELD_PREP(W2_MASK( 95,  88), v)\n#define CMD_U2_IDB2(v)\t\t\tFIELD_PREP(W2_MASK( 87,  80), v)\n#define CMD_U2_BT_CMD2(v)\t\tFIELD_PREP(W2_MASK( 87,  80), v)\n#define CMD_U2_IDB1(v)\t\t\tFIELD_PREP(W2_MASK( 79,  72), v)\n#define CMD_U2_BT_CMD1(v)\t\tFIELD_PREP(W2_MASK( 79,  72), v)\n#define CMD_U2_IDB0(v)\t\t\tFIELD_PREP(W2_MASK( 71,  64), v)\n#define CMD_U2_BT_CMD0(v)\t\tFIELD_PREP(W2_MASK( 71,  64), v)\n#define CMD_U1_ERR_HANDLING(v)\t\tFIELD_PREP(W1_MASK( 63,  62), v)\n#define CMD_U1_ADD_FUNC(v)\t\tFIELD_PREP(W1_MASK( 61,  56), v)\n#define CMD_U1_COMBO_XFER\t\t\t   W1_BIT_( 55)\n#define CMD_U1_DATA_LENGTH(v)\t\tFIELD_PREP(W1_MASK( 53,  32), v)\n#define CMD_U0_TOC\t\t\t\t   W0_BIT_( 31)\n#define CMD_U0_ROC\t\t\t\t   W0_BIT_( 30)\n#define CMD_U0_MAY_YIELD\t\t\t   W0_BIT_( 29)\n#define CMD_U0_NACK_RCNT(v)\t\tFIELD_PREP(W0_MASK( 28,  27), v)\n#define CMD_U0_IDB_COUNT(v)\t\tFIELD_PREP(W0_MASK( 26,  24), v)\n#define CMD_U0_MODE_INDEX(v)\t\tFIELD_PREP(W0_MASK( 22,  18), v)\n#define CMD_U0_XFER_RATE(v)\t\tFIELD_PREP(W0_MASK( 17,  15), v)\n#define CMD_U0_DEV_ADDRESS(v)\t\tFIELD_PREP(W0_MASK( 14,   8), v)\n#define CMD_U0_RnW\t\t\t\t   W0_BIT_(  7)\n#define CMD_U0_TID(v)\t\t\tFIELD_PREP(W0_MASK(  6,   3), v)\n\n \n\n#define CMD_0_ATTR_A\t\t\tFIELD_PREP(CMD_0_ATTR, 0x2)\n\n#define CMD_A1_DATA_LENGTH(v)\t\tFIELD_PREP(W1_MASK( 53,  32), v)\n#define CMD_A0_TOC\t\t\t\t   W0_BIT_( 31)\n#define CMD_A0_ROC\t\t\t\t   W0_BIT_( 30)\n#define CMD_A0_XFER_RATE(v)\t\tFIELD_PREP(W0_MASK( 17,  15), v)\n#define CMD_A0_ASSIGN_ADDRESS(v)\tFIELD_PREP(W0_MASK( 14,   8), v)\n#define CMD_A0_TID(v)\t\t\tFIELD_PREP(W0_MASK(  6,   3), v)\n\n\nstatic unsigned int get_i3c_rate_idx(struct i3c_hci *hci)\n{\n\tstruct i3c_bus *bus = i3c_master_get_bus(&hci->master);\n\n\tif (bus->scl_rate.i3c >= 12000000)\n\t\treturn XFERRATE_I3C_SDR0;\n\tif (bus->scl_rate.i3c > 8000000)\n\t\treturn XFERRATE_I3C_SDR1;\n\tif (bus->scl_rate.i3c > 6000000)\n\t\treturn XFERRATE_I3C_SDR2;\n\tif (bus->scl_rate.i3c > 4000000)\n\t\treturn XFERRATE_I3C_SDR3;\n\tif (bus->scl_rate.i3c > 2000000)\n\t\treturn XFERRATE_I3C_SDR4;\n\treturn XFERRATE_I3C_SDR_FM_FMP;\n}\n\nstatic unsigned int get_i2c_rate_idx(struct i3c_hci *hci)\n{\n\tstruct i3c_bus *bus = i3c_master_get_bus(&hci->master);\n\n\tif (bus->scl_rate.i2c >= 1000000)\n\t\treturn XFERRATE_I2C_FMP;\n\treturn XFERRATE_I2C_FM;\n}\n\nstatic void hci_cmd_v2_prep_private_xfer(struct i3c_hci *hci,\n\t\t\t\t\t struct hci_xfer *xfer,\n\t\t\t\t\t u8 addr, unsigned int mode,\n\t\t\t\t\t unsigned int rate)\n{\n\tu8 *data = xfer->data;\n\tunsigned int data_len = xfer->data_len;\n\tbool rnw = xfer->rnw;\n\n\txfer->cmd_tid = hci_get_tid();\n\n\tif (!rnw && data_len <= 5) {\n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_U |\n\t\t\tCMD_U0_TID(xfer->cmd_tid) |\n\t\t\tCMD_U0_DEV_ADDRESS(addr) |\n\t\t\tCMD_U0_XFER_RATE(rate) |\n\t\t\tCMD_U0_MODE_INDEX(mode) |\n\t\t\tCMD_U0_IDB_COUNT(data_len);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_U1_DATA_LENGTH(0);\n\t\txfer->cmd_desc[2] = 0;\n\t\txfer->cmd_desc[3] = 0;\n\t\tswitch (data_len) {\n\t\tcase 5:\n\t\t\txfer->cmd_desc[3] |= CMD_U3_IDB4(data[4]);\n\t\t\tfallthrough;\n\t\tcase 4:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB3(data[3]);\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB2(data[2]);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB1(data[1]);\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB0(data[0]);\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\txfer->data = NULL;\n\t} else {\n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_U |\n\t\t\tCMD_U0_TID(xfer->cmd_tid) |\n\t\t\t(rnw ? CMD_U0_RnW : 0) |\n\t\t\tCMD_U0_DEV_ADDRESS(addr) |\n\t\t\tCMD_U0_XFER_RATE(rate) |\n\t\t\tCMD_U0_MODE_INDEX(mode);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_U1_DATA_LENGTH(data_len);\n\t\txfer->cmd_desc[2] = 0;\n\t\txfer->cmd_desc[3] = 0;\n\t}\n}\n\nstatic int hci_cmd_v2_prep_ccc(struct i3c_hci *hci, struct hci_xfer *xfer,\n\t\t\t       u8 ccc_addr, u8 ccc_cmd, bool raw)\n{\n\tunsigned int mode = XFERMODE_IDX_I3C_SDR;\n\tunsigned int rate = get_i3c_rate_idx(hci);\n\tu8 *data = xfer->data;\n\tunsigned int data_len = xfer->data_len;\n\tbool rnw = xfer->rnw;\n\n\tif (raw && ccc_addr != I3C_BROADCAST_ADDR) {\n\t\thci_cmd_v2_prep_private_xfer(hci, xfer, ccc_addr, mode, rate);\n\t\treturn 0;\n\t}\n\n\txfer->cmd_tid = hci_get_tid();\n\n\tif (!rnw && data_len <= 4) {\n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_U |\n\t\t\tCMD_U0_TID(xfer->cmd_tid) |\n\t\t\tCMD_U0_DEV_ADDRESS(ccc_addr) |\n\t\t\tCMD_U0_XFER_RATE(rate) |\n\t\t\tCMD_U0_MODE_INDEX(mode) |\n\t\t\tCMD_U0_IDB_COUNT(data_len + (!raw ? 0 : 1));\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_U1_DATA_LENGTH(0);\n\t\txfer->cmd_desc[2] =\n\t\t\tCMD_U2_IDB0(ccc_cmd);\n\t\txfer->cmd_desc[3] = 0;\n\t\tswitch (data_len) {\n\t\tcase 4:\n\t\t\txfer->cmd_desc[3] |= CMD_U3_IDB4(data[3]);\n\t\t\tfallthrough;\n\t\tcase 3:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB3(data[2]);\n\t\t\tfallthrough;\n\t\tcase 2:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB2(data[1]);\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\t\txfer->cmd_desc[2] |= CMD_U2_IDB1(data[0]);\n\t\t\tfallthrough;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\txfer->data = NULL;\n\t} else {\n\t\txfer->cmd_desc[0] =\n\t\t\tCMD_0_ATTR_U |\n\t\t\tCMD_U0_TID(xfer->cmd_tid) |\n\t\t\t(rnw ? CMD_U0_RnW : 0) |\n\t\t\tCMD_U0_DEV_ADDRESS(ccc_addr) |\n\t\t\tCMD_U0_XFER_RATE(rate) |\n\t\t\tCMD_U0_MODE_INDEX(mode) |\n\t\t\tCMD_U0_IDB_COUNT(!raw ? 0 : 1);\n\t\txfer->cmd_desc[1] =\n\t\t\tCMD_U1_DATA_LENGTH(data_len);\n\t\txfer->cmd_desc[2] =\n\t\t\tCMD_U2_IDB0(ccc_cmd);\n\t\txfer->cmd_desc[3] = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void hci_cmd_v2_prep_i3c_xfer(struct i3c_hci *hci,\n\t\t\t\t     struct i3c_dev_desc *dev,\n\t\t\t\t     struct hci_xfer *xfer)\n{\n\tunsigned int mode = XFERMODE_IDX_I3C_SDR;\n\tunsigned int rate = get_i3c_rate_idx(hci);\n\tu8 addr = dev->info.dyn_addr;\n\n\thci_cmd_v2_prep_private_xfer(hci, xfer, addr, mode, rate);\n}\n\nstatic void hci_cmd_v2_prep_i2c_xfer(struct i3c_hci *hci,\n\t\t\t\t     struct i2c_dev_desc *dev,\n\t\t\t\t     struct hci_xfer *xfer)\n{\n\tunsigned int mode = XFERMODE_IDX_I2C;\n\tunsigned int rate = get_i2c_rate_idx(hci);\n\tu8 addr = dev->addr;\n\n\thci_cmd_v2_prep_private_xfer(hci, xfer, addr, mode, rate);\n}\n\nstatic int hci_cmd_v2_daa(struct i3c_hci *hci)\n{\n\tstruct hci_xfer *xfer;\n\tint ret;\n\tu8 next_addr = 0;\n\tu32 device_id[2];\n\tu64 pid;\n\tunsigned int dcr, bcr;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\txfer = hci_alloc_xfer(2);\n\tif (!xfer)\n\t\treturn -ENOMEM;\n\n\txfer[0].data = &device_id;\n\txfer[0].data_len = 8;\n\txfer[0].rnw = true;\n\txfer[0].cmd_desc[1] = CMD_A1_DATA_LENGTH(8);\n\txfer[1].completion = &done;\n\n\tfor (;;) {\n\t\tret = i3c_master_get_free_addr(&hci->master, next_addr);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tnext_addr = ret;\n\t\tDBG(\"next_addr = 0x%02x\", next_addr);\n\t\txfer[0].cmd_tid = hci_get_tid();\n\t\txfer[0].cmd_desc[0] =\n\t\t\tCMD_0_ATTR_A |\n\t\t\tCMD_A0_TID(xfer[0].cmd_tid) |\n\t\t\tCMD_A0_ROC;\n\t\txfer[1].cmd_tid = hci_get_tid();\n\t\txfer[1].cmd_desc[0] =\n\t\t\tCMD_0_ATTR_A |\n\t\t\tCMD_A0_TID(xfer[1].cmd_tid) |\n\t\t\tCMD_A0_ASSIGN_ADDRESS(next_addr) |\n\t\t\tCMD_A0_ROC |\n\t\t\tCMD_A0_TOC;\n\t\thci->io->queue_xfer(hci, xfer, 2);\n\t\tif (!wait_for_completion_timeout(&done, HZ) &&\n\t\t    hci->io->dequeue_xfer(hci, xfer, 2)) {\n\t\t\tret = -ETIME;\n\t\t\tbreak;\n\t\t}\n\t\tif (RESP_STATUS(xfer[0].response) != RESP_SUCCESS) {\n\t\t\tret = 0;   \n\t\t\tbreak;\n\t\t}\n\t\tif (RESP_STATUS(xfer[1].response) != RESP_SUCCESS) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tpid = FIELD_GET(W1_MASK(47, 32), device_id[1]);\n\t\tpid = (pid << 32) | device_id[0];\n\t\tbcr = FIELD_GET(W1_MASK(55, 48), device_id[1]);\n\t\tdcr = FIELD_GET(W1_MASK(63, 56), device_id[1]);\n\t\tDBG(\"assigned address %#x to device PID=0x%llx DCR=%#x BCR=%#x\",\n\t\t    next_addr, pid, dcr, bcr);\n\t\t \n\t\tret = i3c_master_add_i3c_dev_locked(&hci->master, next_addr);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\thci_free_xfer(xfer, 2);\n\treturn ret;\n}\n\nconst struct hci_cmd_ops mipi_i3c_hci_cmd_v2 = {\n\t.prep_ccc\t\t= hci_cmd_v2_prep_ccc,\n\t.prep_i3c_xfer\t\t= hci_cmd_v2_prep_i3c_xfer,\n\t.prep_i2c_xfer\t\t= hci_cmd_v2_prep_i2c_xfer,\n\t.perform_daa\t\t= hci_cmd_v2_daa,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}