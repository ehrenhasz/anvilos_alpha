{
  "module_name": "ext_caps.c",
  "hash_id": "83dd7420580d510927cd71be3693fafa12eec350f978d16223e35f82660383f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/i3c/master/mipi-i3c-hci/ext_caps.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/i3c/master.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n\n#include \"hci.h\"\n#include \"ext_caps.h\"\n#include \"xfer_mode_rate.h\"\n\n\n \n#define CAP_HEADER_LENGTH\t\tGENMASK(23, 8)\n#define CAP_HEADER_ID\t\t\tGENMASK(7, 0)\n\nstatic int hci_extcap_hardware_id(struct i3c_hci *hci, void __iomem *base)\n{\n\thci->vendor_mipi_id\t= readl(base + 0x04);\n\thci->vendor_version_id\t= readl(base + 0x08);\n\thci->vendor_product_id\t= readl(base + 0x0c);\n\n\tdev_info(&hci->master.dev, \"vendor MIPI ID: %#x\\n\", hci->vendor_mipi_id);\n\tdev_info(&hci->master.dev, \"vendor version ID: %#x\\n\", hci->vendor_version_id);\n\tdev_info(&hci->master.dev, \"vendor product ID: %#x\\n\", hci->vendor_product_id);\n\n\t \n\tswitch (hci->vendor_mipi_id) {\n\tcase MIPI_VENDOR_NXP:\n\t\thci->quirks |= HCI_QUIRK_RAW_CCC;\n\t\tDBG(\"raw CCC quirks set\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_extcap_master_config(struct i3c_hci *hci, void __iomem *base)\n{\n\tu32 master_config = readl(base + 0x04);\n\tunsigned int operation_mode = FIELD_GET(GENMASK(5, 4), master_config);\n\tstatic const char * const functionality[] = {\n\t\t\"(unknown)\", \"master only\", \"target only\",\n\t\t\"primary/secondary master\" };\n\tdev_info(&hci->master.dev, \"operation mode: %s\\n\", functionality[operation_mode]);\n\tif (operation_mode & 0x1)\n\t\treturn 0;\n\tdev_err(&hci->master.dev, \"only master mode is currently supported\\n\");\n\treturn -EOPNOTSUPP;\n}\n\nstatic int hci_extcap_multi_bus(struct i3c_hci *hci, void __iomem *base)\n{\n\tu32 bus_instance = readl(base + 0x04);\n\tunsigned int count = FIELD_GET(GENMASK(3, 0), bus_instance);\n\n\tdev_info(&hci->master.dev, \"%d bus instances\\n\", count);\n\treturn 0;\n}\n\nstatic int hci_extcap_xfer_modes(struct i3c_hci *hci, void __iomem *base)\n{\n\tu32 header = readl(base);\n\tu32 entries = FIELD_GET(CAP_HEADER_LENGTH, header) - 1;\n\tunsigned int index;\n\n\tdev_info(&hci->master.dev, \"transfer mode table has %d entries\\n\",\n\t\t entries);\n\tbase += 4;   \n\tfor (index = 0; index < entries; index++) {\n\t\tu32 mode_entry = readl(base);\n\n\t\tDBG(\"mode %d: 0x%08x\", index, mode_entry);\n\t\t \n\t\tbase += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_extcap_xfer_rates(struct i3c_hci *hci, void __iomem *base)\n{\n\tu32 header = readl(base);\n\tu32 entries = FIELD_GET(CAP_HEADER_LENGTH, header) - 1;\n\tu32 rate_entry;\n\tunsigned int index, rate, rate_id, mode_id;\n\n\tbase += 4;   \n\n\tdev_info(&hci->master.dev, \"available data rates:\\n\");\n\tfor (index = 0; index < entries; index++) {\n\t\trate_entry = readl(base);\n\t\tDBG(\"entry %d: 0x%08x\", index, rate_entry);\n\t\trate = FIELD_GET(XFERRATE_ACTUAL_RATE_KHZ, rate_entry);\n\t\trate_id = FIELD_GET(XFERRATE_RATE_ID, rate_entry);\n\t\tmode_id = FIELD_GET(XFERRATE_MODE_ID, rate_entry);\n\t\tdev_info(&hci->master.dev, \"rate %d for %s = %d kHz\\n\",\n\t\t\t rate_id,\n\t\t\t mode_id == XFERRATE_MODE_I3C ? \"I3C\" :\n\t\t\t mode_id == XFERRATE_MODE_I2C ? \"I2C\" :\n\t\t\t \"unknown mode\",\n\t\t\t rate);\n\t\tbase += 4;\n\t}\n\n\treturn 0;\n}\n\nstatic int hci_extcap_auto_command(struct i3c_hci *hci, void __iomem *base)\n{\n\tu32 autocmd_ext_caps = readl(base + 0x04);\n\tunsigned int max_count = FIELD_GET(GENMASK(3, 0), autocmd_ext_caps);\n\tu32 autocmd_ext_config = readl(base + 0x08);\n\tunsigned int count = FIELD_GET(GENMASK(3, 0), autocmd_ext_config);\n\n\tdev_info(&hci->master.dev, \"%d/%d active auto-command entries\\n\",\n\t\t count, max_count);\n\t \n\thci->AUTOCMD_regs = base;\n\treturn 0;\n}\n\nstatic int hci_extcap_debug(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"debug registers present\\n\");\n\thci->DEBUG_regs = base;\n\treturn 0;\n}\n\nstatic int hci_extcap_scheduled_cmd(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"scheduled commands available\\n\");\n\t \n\treturn 0;\n}\n\nstatic int hci_extcap_non_curr_master(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"Non-Current Master support available\\n\");\n\t \n\treturn 0;\n}\n\nstatic int hci_extcap_ccc_resp_conf(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"CCC Response Configuration available\\n\");\n\treturn 0;\n}\n\nstatic int hci_extcap_global_DAT(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"Global DAT available\\n\");\n\treturn 0;\n}\n\nstatic int hci_extcap_multilane(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"Master Multi-Lane support available\\n\");\n\treturn 0;\n}\n\nstatic int hci_extcap_ncm_multilane(struct i3c_hci *hci, void __iomem *base)\n{\n\tdev_info(&hci->master.dev, \"NCM Multi-Lane support available\\n\");\n\treturn 0;\n}\n\nstruct hci_ext_caps {\n\tu8  id;\n\tu16 min_length;\n\tint (*parser)(struct i3c_hci *hci, void __iomem *base);\n};\n\n#define EXT_CAP(_id, _highest_mandatory_reg_offset, _parser) \\\n\t{ .id = (_id), .parser = (_parser), \\\n\t  .min_length = (_highest_mandatory_reg_offset)/4 + 1 }\n\nstatic const struct hci_ext_caps ext_capabilities[] = {\n\tEXT_CAP(0x01, 0x0c, hci_extcap_hardware_id),\n\tEXT_CAP(0x02, 0x04, hci_extcap_master_config),\n\tEXT_CAP(0x03, 0x04, hci_extcap_multi_bus),\n\tEXT_CAP(0x04, 0x24, hci_extcap_xfer_modes),\n\tEXT_CAP(0x05, 0x08, hci_extcap_auto_command),\n\tEXT_CAP(0x08, 0x40, hci_extcap_xfer_rates),\n\tEXT_CAP(0x0c, 0x10, hci_extcap_debug),\n\tEXT_CAP(0x0d, 0x0c, hci_extcap_scheduled_cmd),\n\tEXT_CAP(0x0e, 0x80, hci_extcap_non_curr_master),  \n\tEXT_CAP(0x0f, 0x04, hci_extcap_ccc_resp_conf),\n\tEXT_CAP(0x10, 0x08, hci_extcap_global_DAT),\n\tEXT_CAP(0x9d, 0x04,\thci_extcap_multilane),\n\tEXT_CAP(0x9e, 0x04, hci_extcap_ncm_multilane),\n};\n\nstatic int hci_extcap_vendor_NXP(struct i3c_hci *hci, void __iomem *base)\n{\n\thci->vendor_data = (__force void *)base;\n\tdev_info(&hci->master.dev, \"Build Date Info = %#x\\n\", readl(base + 1*4));\n\t \n\twritel(0xdeadbeef, base + 1*4);\n\treturn 0;\n}\n\nstruct hci_ext_cap_vendor_specific {\n\tu32 vendor;\n\tu8  cap;\n\tu16 min_length;\n\tint (*parser)(struct i3c_hci *hci, void __iomem *base);\n};\n\n#define EXT_CAP_VENDOR(_vendor, _cap, _highest_mandatory_reg_offset) \\\n\t{ .vendor = (MIPI_VENDOR_##_vendor), .cap = (_cap), \\\n\t  .parser = (hci_extcap_vendor_##_vendor), \\\n\t  .min_length = (_highest_mandatory_reg_offset)/4 + 1 }\n\nstatic const struct hci_ext_cap_vendor_specific vendor_ext_caps[] = {\n\tEXT_CAP_VENDOR(NXP, 0xc0, 0x20),\n};\n\nstatic int hci_extcap_vendor_specific(struct i3c_hci *hci, void __iomem *base,\n\t\t\t\t      u32 cap_id, u32 cap_length)\n{\n\tconst struct hci_ext_cap_vendor_specific *vendor_cap_entry;\n\tint i;\n\n\tvendor_cap_entry = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(vendor_ext_caps); i++) {\n\t\tif (vendor_ext_caps[i].vendor == hci->vendor_mipi_id &&\n\t\t    vendor_ext_caps[i].cap == cap_id) {\n\t\t\tvendor_cap_entry = &vendor_ext_caps[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vendor_cap_entry) {\n\t\tdev_notice(&hci->master.dev,\n\t\t\t   \"unknown ext_cap 0x%02x for vendor 0x%02x\\n\",\n\t\t\t   cap_id, hci->vendor_mipi_id);\n\t\treturn 0;\n\t}\n\tif (cap_length < vendor_cap_entry->min_length) {\n\t\tdev_err(&hci->master.dev,\n\t\t\t\"ext_cap 0x%02x has size %d (expecting >= %d)\\n\",\n\t\t\tcap_id, cap_length, vendor_cap_entry->min_length);\n\t\treturn -EINVAL;\n\t}\n\treturn vendor_cap_entry->parser(hci, base);\n}\n\nint i3c_hci_parse_ext_caps(struct i3c_hci *hci)\n{\n\tvoid __iomem *curr_cap = hci->EXTCAPS_regs;\n\tvoid __iomem *end = curr_cap + 0x1000;  \n\tu32 cap_header, cap_id, cap_length;\n\tconst struct hci_ext_caps *cap_entry;\n\tint i, err = 0;\n\n\tif (!curr_cap)\n\t\treturn 0;\n\n\tfor (; !err && curr_cap < end; curr_cap += cap_length * 4) {\n\t\tcap_header = readl(curr_cap);\n\t\tcap_id = FIELD_GET(CAP_HEADER_ID, cap_header);\n\t\tcap_length = FIELD_GET(CAP_HEADER_LENGTH, cap_header);\n\t\tDBG(\"id=0x%02x length=%d\", cap_id, cap_length);\n\t\tif (!cap_length)\n\t\t\tbreak;\n\t\tif (curr_cap + cap_length * 4 >= end) {\n\t\t\tdev_err(&hci->master.dev,\n\t\t\t\t\"ext_cap 0x%02x has size %d (too big)\\n\",\n\t\t\t\tcap_id, cap_length);\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cap_id >= 0xc0 && cap_id <= 0xcf) {\n\t\t\terr = hci_extcap_vendor_specific(hci, curr_cap,\n\t\t\t\t\t\t\t cap_id, cap_length);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcap_entry = NULL;\n\t\tfor (i = 0; i < ARRAY_SIZE(ext_capabilities); i++) {\n\t\t\tif (ext_capabilities[i].id == cap_id) {\n\t\t\t\tcap_entry = &ext_capabilities[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!cap_entry) {\n\t\t\tdev_notice(&hci->master.dev,\n\t\t\t\t   \"unknown ext_cap 0x%02x\\n\", cap_id);\n\t\t} else if (cap_length < cap_entry->min_length) {\n\t\t\tdev_err(&hci->master.dev,\n\t\t\t\t\"ext_cap 0x%02x has size %d (expecting >= %d)\\n\",\n\t\t\t\tcap_id, cap_length, cap_entry->min_length);\n\t\t\terr = -EINVAL;\n\t\t} else {\n\t\t\terr = cap_entry->parser(hci, curr_cap);\n\t\t}\n\t}\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}