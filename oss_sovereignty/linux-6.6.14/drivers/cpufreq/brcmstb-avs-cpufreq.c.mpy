{
  "module_name": "brcmstb-avs-cpufreq.c",
  "hash_id": "26dd4982af0147ca5a7e9b09764f50d3d5996252ae5538ef13872104063d694b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/brcmstb-avs-cpufreq.c",
  "human_readable_source": " \n\n \n\n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/semaphore.h>\n\n \n#define AVS_MAX_CMD_ARGS\t4\n \n#define AVS_PARAM_MULT(x)\t((x) < AVS_MAX_CMD_ARGS ? (x) : 0)\n\n \n#define AVS_MBOX_COMMAND\t0x00\n#define AVS_MBOX_STATUS\t\t0x04\n#define AVS_MBOX_VOLTAGE0\t0x08\n#define AVS_MBOX_TEMP0\t\t0x0c\n#define AVS_MBOX_PV0\t\t0x10\n#define AVS_MBOX_MV0\t\t0x14\n#define AVS_MBOX_PARAM(x)\t(0x18 + AVS_PARAM_MULT(x) * sizeof(u32))\n#define AVS_MBOX_REVISION\t0x28\n#define AVS_MBOX_PSTATE\t\t0x2c\n#define AVS_MBOX_HEARTBEAT\t0x30\n#define AVS_MBOX_MAGIC\t\t0x34\n#define AVS_MBOX_SIGMA_HVT\t0x38\n#define AVS_MBOX_SIGMA_SVT\t0x3c\n#define AVS_MBOX_VOLTAGE1\t0x40\n#define AVS_MBOX_TEMP1\t\t0x44\n#define AVS_MBOX_PV1\t\t0x48\n#define AVS_MBOX_MV1\t\t0x4c\n#define AVS_MBOX_FREQUENCY\t0x50\n\n \n#define AVS_CMD_AVAILABLE\t0x00\n#define AVS_CMD_DISABLE\t\t0x10\n#define AVS_CMD_ENABLE\t\t0x11\n#define AVS_CMD_S2_ENTER\t0x12\n#define AVS_CMD_S2_EXIT\t\t0x13\n#define AVS_CMD_BBM_ENTER\t0x14\n#define AVS_CMD_BBM_EXIT\t0x15\n#define AVS_CMD_S3_ENTER\t0x16\n#define AVS_CMD_S3_EXIT\t\t0x17\n#define AVS_CMD_BALANCE\t\t0x18\n \n#define AVS_CMD_GET_PMAP\t0x30\n#define AVS_CMD_SET_PMAP\t0x31\n#define AVS_CMD_GET_PSTATE\t0x40\n#define AVS_CMD_SET_PSTATE\t0x41\n\n \n#define AVS_MODE_AVS\t\t0x0\n#define AVS_MODE_DFS\t\t0x1\n#define AVS_MODE_DVS\t\t0x2\n#define AVS_MODE_DVFS\t\t0x3\n\n \n#define NDIV_INT_SHIFT\t\t0\n#define NDIV_INT_MASK\t\t0x3ff\n#define PDIV_SHIFT\t\t10\n#define PDIV_MASK\t\t0xf\n#define MDIV_P0_SHIFT\t\t16\n#define MDIV_P0_MASK\t\t0xff\n \n#define MDIV_P1_SHIFT\t\t0\n#define MDIV_P1_MASK\t\t0xff\n#define MDIV_P2_SHIFT\t\t8\n#define MDIV_P2_MASK\t\t0xff\n#define MDIV_P3_SHIFT\t\t16\n#define MDIV_P3_MASK\t\t0xff\n#define MDIV_P4_SHIFT\t\t24\n#define MDIV_P4_MASK\t\t0xff\n\n \n#define AVS_PSTATE_P0\t\t0x0\n#define AVS_PSTATE_P1\t\t0x1\n#define AVS_PSTATE_P2\t\t0x2\n#define AVS_PSTATE_P3\t\t0x3\n#define AVS_PSTATE_P4\t\t0x4\n#define AVS_PSTATE_MAX\t\tAVS_PSTATE_P4\n\n \n#define AVS_CPU_L2_SET0\t\t0x04\n#define AVS_CPU_L2_INT_MASK\tBIT(31)\n\n \n#define AVS_STATUS_CLEAR\t0x00\n \n#define AVS_STATUS_SUCCESS\t0xf0\n \n#define AVS_STATUS_FAILURE\t0xff\n \n#define AVS_STATUS_INVALID\t0xf1\n \n#define AVS_STATUS_NO_SUPP\t0xf2\n \n#define AVS_STATUS_NO_MAP\t0xf3\n \n#define AVS_STATUS_MAP_SET\t0xf4\n \n#define AVS_STATUS_MAX\t\t0xff\n\n \n#define AVS_LOOP_LIMIT\t\t10000\n#define AVS_TIMEOUT\t\t300  \n#define AVS_FIRMWARE_MAGIC\t0xa11600d1\n\n#define BRCM_AVS_CPUFREQ_PREFIX\t\"brcmstb-avs\"\n#define BRCM_AVS_CPUFREQ_NAME\tBRCM_AVS_CPUFREQ_PREFIX \"-cpufreq\"\n#define BRCM_AVS_CPU_DATA\t\"brcm,avs-cpu-data-mem\"\n#define BRCM_AVS_CPU_INTR\t\"brcm,avs-cpu-l2-intr\"\n#define BRCM_AVS_HOST_INTR\t\"sw_intr\"\n\nstruct pmap {\n\tunsigned int mode;\n\tunsigned int p1;\n\tunsigned int p2;\n\tunsigned int state;\n};\n\nstruct private_data {\n\tvoid __iomem *base;\n\tvoid __iomem *avs_intr_base;\n\tstruct device *dev;\n\tstruct completion done;\n\tstruct semaphore sem;\n\tstruct pmap pmap;\n\tint host_irq;\n};\n\nstatic void __iomem *__map_region(const char *name)\n{\n\tstruct device_node *np;\n\tvoid __iomem *ptr;\n\n\tnp = of_find_compatible_node(NULL, NULL, name);\n\tif (!np)\n\t\treturn NULL;\n\n\tptr = of_iomap(np, 0);\n\tof_node_put(np);\n\n\treturn ptr;\n}\n\nstatic unsigned long wait_for_avs_command(struct private_data *priv,\n\t\t\t\t\t  unsigned long timeout)\n{\n\tunsigned long time_left = 0;\n\tu32 val;\n\n\t \n\tif (priv->host_irq >= 0)\n\t\treturn wait_for_completion_timeout(&priv->done,\n\t\t\t\t\t\t   msecs_to_jiffies(timeout));\n\n\t \n\tdo {\n\t\ttime_left = timeout;\n\t\tval = readl(priv->base + AVS_MBOX_STATUS);\n\t\tif (val)\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 2000);\n\t} while (--timeout);\n\n\treturn time_left;\n}\n\nstatic int __issue_avs_command(struct private_data *priv, unsigned int cmd,\n\t\t\t       unsigned int num_in, unsigned int num_out,\n\t\t\t       u32 args[])\n{\n\tvoid __iomem *base = priv->base;\n\tunsigned long time_left;\n\tunsigned int i;\n\tint ret;\n\tu32 val;\n\n\tret = down_interruptible(&priv->sem);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tfor (i = 0, val = 1; val != 0 && i < AVS_LOOP_LIMIT; i++)\n\t\tval = readl(base + AVS_MBOX_COMMAND);\n\n\t \n\tif (i == AVS_LOOP_LIMIT) {\n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t \n\twritel(AVS_STATUS_CLEAR, base + AVS_MBOX_STATUS);\n\n\t \n\tfor (i = 0; i < num_in; i++)\n\t\twritel(args[i], base + AVS_MBOX_PARAM(i));\n\n\t \n\treinit_completion(&priv->done);\n\n\t \n\twritel(cmd, base + AVS_MBOX_COMMAND);\n\twritel(AVS_CPU_L2_INT_MASK, priv->avs_intr_base + AVS_CPU_L2_SET0);\n\n\t \n\ttime_left = wait_for_avs_command(priv, AVS_TIMEOUT);\n\n\t \n\tval = readl(base + AVS_MBOX_STATUS);\n\tif (time_left == 0 || val == 0 || val > AVS_STATUS_MAX) {\n\t\tdev_err(priv->dev, \"AVS command %#x didn't complete in time\\n\",\n\t\t\tcmd);\n\t\tdev_err(priv->dev, \"    Time left: %u ms, AVS status: %#x\\n\",\n\t\t\tjiffies_to_msecs(time_left), val);\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < num_out; i++)\n\t\targs[i] = readl(base + AVS_MBOX_PARAM(i));\n\n\t \n\twritel(AVS_STATUS_CLEAR, base + AVS_MBOX_STATUS);\n\n\t \n\tswitch (val) {\n\tcase AVS_STATUS_INVALID:\n\t\tret = -EINVAL;\n\t\tbreak;\n\tcase AVS_STATUS_NO_SUPP:\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\tcase AVS_STATUS_NO_MAP:\n\t\tret = -ENOENT;\n\t\tbreak;\n\tcase AVS_STATUS_MAP_SET:\n\t\tret = -EEXIST;\n\t\tbreak;\n\tcase AVS_STATUS_FAILURE:\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\nout:\n\tup(&priv->sem);\n\n\treturn ret;\n}\n\nstatic irqreturn_t irq_handler(int irq, void *data)\n{\n\tstruct private_data *priv = data;\n\n\t \n\tcomplete(&priv->done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic char *brcm_avs_mode_to_string(unsigned int mode)\n{\n\tswitch (mode) {\n\tcase AVS_MODE_AVS:\n\t\treturn \"AVS\";\n\tcase AVS_MODE_DFS:\n\t\treturn \"DFS\";\n\tcase AVS_MODE_DVS:\n\t\treturn \"DVS\";\n\tcase AVS_MODE_DVFS:\n\t\treturn \"DVFS\";\n\t}\n\treturn NULL;\n}\n\nstatic void brcm_avs_parse_p1(u32 p1, unsigned int *mdiv_p0, unsigned int *pdiv,\n\t\t\t      unsigned int *ndiv)\n{\n\t*mdiv_p0 = (p1 >> MDIV_P0_SHIFT) & MDIV_P0_MASK;\n\t*pdiv = (p1 >> PDIV_SHIFT) & PDIV_MASK;\n\t*ndiv = (p1 >> NDIV_INT_SHIFT) & NDIV_INT_MASK;\n}\n\nstatic void brcm_avs_parse_p2(u32 p2, unsigned int *mdiv_p1,\n\t\t\t      unsigned int *mdiv_p2, unsigned int *mdiv_p3,\n\t\t\t      unsigned int *mdiv_p4)\n{\n\t*mdiv_p4 = (p2 >> MDIV_P4_SHIFT) & MDIV_P4_MASK;\n\t*mdiv_p3 = (p2 >> MDIV_P3_SHIFT) & MDIV_P3_MASK;\n\t*mdiv_p2 = (p2 >> MDIV_P2_SHIFT) & MDIV_P2_MASK;\n\t*mdiv_p1 = (p2 >> MDIV_P1_SHIFT) & MDIV_P1_MASK;\n}\n\nstatic int brcm_avs_get_pmap(struct private_data *priv, struct pmap *pmap)\n{\n\tu32 args[AVS_MAX_CMD_ARGS];\n\tint ret;\n\n\tret = __issue_avs_command(priv, AVS_CMD_GET_PMAP, 0, 4, args);\n\tif (ret || !pmap)\n\t\treturn ret;\n\n\tpmap->mode = args[0];\n\tpmap->p1 = args[1];\n\tpmap->p2 = args[2];\n\tpmap->state = args[3];\n\n\treturn 0;\n}\n\nstatic int brcm_avs_set_pmap(struct private_data *priv, struct pmap *pmap)\n{\n\tu32 args[AVS_MAX_CMD_ARGS];\n\n\targs[0] = pmap->mode;\n\targs[1] = pmap->p1;\n\targs[2] = pmap->p2;\n\targs[3] = pmap->state;\n\n\treturn __issue_avs_command(priv, AVS_CMD_SET_PMAP, 4, 0, args);\n}\n\nstatic int brcm_avs_get_pstate(struct private_data *priv, unsigned int *pstate)\n{\n\tu32 args[AVS_MAX_CMD_ARGS];\n\tint ret;\n\n\tret = __issue_avs_command(priv, AVS_CMD_GET_PSTATE, 0, 1, args);\n\tif (ret)\n\t\treturn ret;\n\t*pstate = args[0];\n\n\treturn 0;\n}\n\nstatic int brcm_avs_set_pstate(struct private_data *priv, unsigned int pstate)\n{\n\tu32 args[AVS_MAX_CMD_ARGS];\n\n\targs[0] = pstate;\n\n\treturn __issue_avs_command(priv, AVS_CMD_SET_PSTATE, 1, 0, args);\n\n}\n\nstatic u32 brcm_avs_get_voltage(void __iomem *base)\n{\n\treturn readl(base + AVS_MBOX_VOLTAGE1);\n}\n\nstatic u32 brcm_avs_get_frequency(void __iomem *base)\n{\n\treturn readl(base + AVS_MBOX_FREQUENCY) * 1000;\t \n}\n\n \nstatic struct cpufreq_frequency_table *\nbrcm_avs_get_freq_table(struct device *dev, struct private_data *priv)\n{\n\tstruct cpufreq_frequency_table *table;\n\tunsigned int pstate;\n\tint i, ret;\n\n\t \n\tret = brcm_avs_get_pstate(priv, &pstate);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\ttable = devm_kcalloc(dev, AVS_PSTATE_MAX + 1 + 1, sizeof(*table),\n\t\t\t     GFP_KERNEL);\n\tif (!table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = AVS_PSTATE_P0; i <= AVS_PSTATE_MAX; i++) {\n\t\tret = brcm_avs_set_pstate(priv, i);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t\ttable[i].frequency = brcm_avs_get_frequency(priv->base);\n\t\ttable[i].driver_data = i;\n\t}\n\ttable[i].frequency = CPUFREQ_TABLE_END;\n\n\t \n\tret = brcm_avs_set_pstate(priv, pstate);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn table;\n}\n\n \nstatic bool brcm_avs_is_firmware_loaded(struct private_data *priv)\n{\n\tu32 magic;\n\tint rc;\n\n\trc = brcm_avs_get_pmap(priv, NULL);\n\tmagic = readl(priv->base + AVS_MBOX_MAGIC);\n\n\treturn (magic == AVS_FIRMWARE_MAGIC) && ((rc != -ENOTSUPP) ||\n\t\t(rc != -EINVAL));\n}\n\nstatic unsigned int brcm_avs_cpufreq_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tstruct private_data *priv = policy->driver_data;\n\n\tcpufreq_cpu_put(policy);\n\n\treturn brcm_avs_get_frequency(priv->base);\n}\n\nstatic int brcm_avs_target_index(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int index)\n{\n\treturn brcm_avs_set_pstate(policy->driver_data,\n\t\t\t\t  policy->freq_table[index].driver_data);\n}\n\nstatic int brcm_avs_suspend(struct cpufreq_policy *policy)\n{\n\tstruct private_data *priv = policy->driver_data;\n\tint ret;\n\n\tret = brcm_avs_get_pmap(priv, &priv->pmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = brcm_avs_get_pstate(priv, &priv->pmap.state);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t(void)__issue_avs_command(priv, AVS_CMD_S2_ENTER, 0, 0, NULL);\n\n\treturn 0;\n}\n\nstatic int brcm_avs_resume(struct cpufreq_policy *policy)\n{\n\tstruct private_data *priv = policy->driver_data;\n\tint ret;\n\n\t \n\t(void)__issue_avs_command(priv, AVS_CMD_S2_EXIT, 0, 0, NULL);\n\n\tret = brcm_avs_set_pmap(priv, &priv->pmap);\n\tif (ret == -EEXIST) {\n\t\tstruct platform_device *pdev  = cpufreq_get_driver_data();\n\t\tstruct device *dev = &pdev->dev;\n\n\t\tdev_warn(dev, \"PMAP was already set\\n\");\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int brcm_avs_prepare_init(struct platform_device *pdev)\n{\n\tstruct private_data *priv;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = &pdev->dev;\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\tsema_init(&priv->sem, 1);\n\tinit_completion(&priv->done);\n\tplatform_set_drvdata(pdev, priv);\n\n\tpriv->base = __map_region(BRCM_AVS_CPU_DATA);\n\tif (!priv->base) {\n\t\tdev_err(dev, \"Couldn't find property %s in device tree.\\n\",\n\t\t\tBRCM_AVS_CPU_DATA);\n\t\treturn -ENOENT;\n\t}\n\n\tpriv->avs_intr_base = __map_region(BRCM_AVS_CPU_INTR);\n\tif (!priv->avs_intr_base) {\n\t\tdev_err(dev, \"Couldn't find property %s in device tree.\\n\",\n\t\t\tBRCM_AVS_CPU_INTR);\n\t\tret = -ENOENT;\n\t\tgoto unmap_base;\n\t}\n\n\tpriv->host_irq = platform_get_irq_byname(pdev, BRCM_AVS_HOST_INTR);\n\n\tret = devm_request_irq(dev, priv->host_irq, irq_handler,\n\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t       BRCM_AVS_HOST_INTR, priv);\n\tif (ret && priv->host_irq >= 0) {\n\t\tdev_err(dev, \"IRQ request failed: %s (%d) -- %d\\n\",\n\t\t\tBRCM_AVS_HOST_INTR, priv->host_irq, ret);\n\t\tgoto unmap_intr_base;\n\t}\n\n\tif (brcm_avs_is_firmware_loaded(priv))\n\t\treturn 0;\n\n\tdev_err(dev, \"AVS firmware is not loaded or doesn't support DVFS\\n\");\n\tret = -ENODEV;\n\nunmap_intr_base:\n\tiounmap(priv->avs_intr_base);\nunmap_base:\n\tiounmap(priv->base);\n\n\treturn ret;\n}\n\nstatic void brcm_avs_prepare_uninit(struct platform_device *pdev)\n{\n\tstruct private_data *priv;\n\n\tpriv = platform_get_drvdata(pdev);\n\n\tiounmap(priv->avs_intr_base);\n\tiounmap(priv->base);\n}\n\nstatic int brcm_avs_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *freq_table;\n\tstruct platform_device *pdev;\n\tstruct private_data *priv;\n\tstruct device *dev;\n\tint ret;\n\n\tpdev = cpufreq_get_driver_data();\n\tpriv = platform_get_drvdata(pdev);\n\tpolicy->driver_data = priv;\n\tdev = &pdev->dev;\n\n\tfreq_table = brcm_avs_get_freq_table(dev, priv);\n\tif (IS_ERR(freq_table)) {\n\t\tret = PTR_ERR(freq_table);\n\t\tdev_err(dev, \"Couldn't determine frequency table (%d).\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpolicy->freq_table = freq_table;\n\n\t \n\tcpumask_setall(policy->cpus);\n\n\tret = __issue_avs_command(priv, AVS_CMD_ENABLE, 0, 0, NULL);\n\tif (!ret) {\n\t\tunsigned int pstate;\n\n\t\tret = brcm_avs_get_pstate(priv, &pstate);\n\t\tif (!ret) {\n\t\t\tpolicy->cur = freq_table[pstate].frequency;\n\t\t\tdev_info(dev, \"registered\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(dev, \"couldn't initialize driver (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic ssize_t show_brcm_avs_pstate(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct private_data *priv = policy->driver_data;\n\tunsigned int pstate;\n\n\tif (brcm_avs_get_pstate(priv, &pstate))\n\t\treturn sprintf(buf, \"<unknown>\\n\");\n\n\treturn sprintf(buf, \"%u\\n\", pstate);\n}\n\nstatic ssize_t show_brcm_avs_mode(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct private_data *priv = policy->driver_data;\n\tstruct pmap pmap;\n\n\tif (brcm_avs_get_pmap(priv, &pmap))\n\t\treturn sprintf(buf, \"<unknown>\\n\");\n\n\treturn sprintf(buf, \"%s %u\\n\", brcm_avs_mode_to_string(pmap.mode),\n\t\tpmap.mode);\n}\n\nstatic ssize_t show_brcm_avs_pmap(struct cpufreq_policy *policy, char *buf)\n{\n\tunsigned int mdiv_p0, mdiv_p1, mdiv_p2, mdiv_p3, mdiv_p4;\n\tstruct private_data *priv = policy->driver_data;\n\tunsigned int ndiv, pdiv;\n\tstruct pmap pmap;\n\n\tif (brcm_avs_get_pmap(priv, &pmap))\n\t\treturn sprintf(buf, \"<unknown>\\n\");\n\n\tbrcm_avs_parse_p1(pmap.p1, &mdiv_p0, &pdiv, &ndiv);\n\tbrcm_avs_parse_p2(pmap.p2, &mdiv_p1, &mdiv_p2, &mdiv_p3, &mdiv_p4);\n\n\treturn sprintf(buf, \"0x%08x 0x%08x %u %u %u %u %u %u %u %u %u\\n\",\n\t\tpmap.p1, pmap.p2, ndiv, pdiv, mdiv_p0, mdiv_p1, mdiv_p2,\n\t\tmdiv_p3, mdiv_p4, pmap.mode, pmap.state);\n}\n\nstatic ssize_t show_brcm_avs_voltage(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct private_data *priv = policy->driver_data;\n\n\treturn sprintf(buf, \"0x%08x\\n\", brcm_avs_get_voltage(priv->base));\n}\n\nstatic ssize_t show_brcm_avs_frequency(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct private_data *priv = policy->driver_data;\n\n\treturn sprintf(buf, \"0x%08x\\n\", brcm_avs_get_frequency(priv->base));\n}\n\ncpufreq_freq_attr_ro(brcm_avs_pstate);\ncpufreq_freq_attr_ro(brcm_avs_mode);\ncpufreq_freq_attr_ro(brcm_avs_pmap);\ncpufreq_freq_attr_ro(brcm_avs_voltage);\ncpufreq_freq_attr_ro(brcm_avs_frequency);\n\nstatic struct freq_attr *brcm_avs_cpufreq_attr[] = {\n\t&cpufreq_freq_attr_scaling_available_freqs,\n\t&brcm_avs_pstate,\n\t&brcm_avs_mode,\n\t&brcm_avs_pmap,\n\t&brcm_avs_voltage,\n\t&brcm_avs_frequency,\n\tNULL\n};\n\nstatic struct cpufreq_driver brcm_avs_driver = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= brcm_avs_target_index,\n\t.get\t\t= brcm_avs_cpufreq_get,\n\t.suspend\t= brcm_avs_suspend,\n\t.resume\t\t= brcm_avs_resume,\n\t.init\t\t= brcm_avs_cpufreq_init,\n\t.attr\t\t= brcm_avs_cpufreq_attr,\n\t.name\t\t= BRCM_AVS_CPUFREQ_PREFIX,\n};\n\nstatic int brcm_avs_cpufreq_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tret = brcm_avs_prepare_init(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tbrcm_avs_driver.driver_data = pdev;\n\n\tret = cpufreq_register_driver(&brcm_avs_driver);\n\tif (ret)\n\t\tbrcm_avs_prepare_uninit(pdev);\n\n\treturn ret;\n}\n\nstatic void brcm_avs_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&brcm_avs_driver);\n\n\tbrcm_avs_prepare_uninit(pdev);\n}\n\nstatic const struct of_device_id brcm_avs_cpufreq_match[] = {\n\t{ .compatible = BRCM_AVS_CPU_DATA },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, brcm_avs_cpufreq_match);\n\nstatic struct platform_driver brcm_avs_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= BRCM_AVS_CPUFREQ_NAME,\n\t\t.of_match_table = brcm_avs_cpufreq_match,\n\t},\n\t.probe\t\t= brcm_avs_cpufreq_probe,\n\t.remove_new\t= brcm_avs_cpufreq_remove,\n};\nmodule_platform_driver(brcm_avs_cpufreq_platdrv);\n\nMODULE_AUTHOR(\"Markus Mayer <mmayer@broadcom.com>\");\nMODULE_DESCRIPTION(\"CPUfreq driver for Broadcom STB AVS\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}