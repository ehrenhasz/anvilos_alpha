{
  "module_name": "scmi-cpufreq.c",
  "hash_id": "d52e20ec6f83c763d4080579fb8eec17e7d7f547472a0df02e839f6628c2865c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/scmi-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk-provider.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/energy_model.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/scmi_protocol.h>\n#include <linux/types.h>\n#include <linux/units.h>\n\nstruct scmi_data {\n\tint domain_id;\n\tint nr_opp;\n\tstruct device *cpu_dev;\n\tcpumask_var_t opp_shared_cpus;\n};\n\nstatic struct scmi_protocol_handle *ph;\nstatic const struct scmi_perf_proto_ops *perf_ops;\n\nstatic unsigned int scmi_cpufreq_get_rate(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);\n\tstruct scmi_data *priv = policy->driver_data;\n\tunsigned long rate;\n\tint ret;\n\n\tret = perf_ops->freq_get(ph, priv->domain_id, &rate, false);\n\tif (ret)\n\t\treturn 0;\n\treturn rate / 1000;\n}\n\n \nstatic int\nscmi_cpufreq_set_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tstruct scmi_data *priv = policy->driver_data;\n\tu64 freq = policy->freq_table[index].frequency;\n\n\treturn perf_ops->freq_set(ph, priv->domain_id, freq * 1000, false);\n}\n\nstatic unsigned int scmi_cpufreq_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int target_freq)\n{\n\tstruct scmi_data *priv = policy->driver_data;\n\n\tif (!perf_ops->freq_set(ph, priv->domain_id,\n\t\t\t\ttarget_freq * 1000, true))\n\t\treturn target_freq;\n\n\treturn 0;\n}\n\nstatic int\nscmi_get_sharing_cpus(struct device *cpu_dev, struct cpumask *cpumask)\n{\n\tint cpu, domain, tdomain;\n\tstruct device *tcpu_dev;\n\n\tdomain = perf_ops->device_domain_id(cpu_dev);\n\tif (domain < 0)\n\t\treturn domain;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == cpu_dev->id)\n\t\t\tcontinue;\n\n\t\ttcpu_dev = get_cpu_device(cpu);\n\t\tif (!tcpu_dev)\n\t\t\tcontinue;\n\n\t\ttdomain = perf_ops->device_domain_id(tcpu_dev);\n\t\tif (tdomain == domain)\n\t\t\tcpumask_set_cpu(cpu, cpumask);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused\nscmi_get_cpu_power(struct device *cpu_dev, unsigned long *power,\n\t\t   unsigned long *KHz)\n{\n\tenum scmi_power_scale power_scale = perf_ops->power_scale_get(ph);\n\tunsigned long Hz;\n\tint ret, domain;\n\n\tdomain = perf_ops->device_domain_id(cpu_dev);\n\tif (domain < 0)\n\t\treturn domain;\n\n\t \n\tHz = *KHz * 1000;\n\tret = perf_ops->est_power_get(ph, domain, &Hz, power);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (power_scale == SCMI_POWER_MILLIWATTS)\n\t\t*power *= MICROWATT_PER_MILLIWATT;\n\n\t \n\t*KHz = Hz / 1000;\n\n\treturn 0;\n}\n\nstatic int scmi_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tint ret, nr_opp;\n\tunsigned int latency;\n\tstruct device *cpu_dev;\n\tstruct scmi_data *priv;\n\tstruct cpufreq_frequency_table *freq_table;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"failed to get cpu%d device\\n\", policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&priv->opp_shared_cpus, GFP_KERNEL)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_priv;\n\t}\n\n\t \n\tret = scmi_get_sharing_cpus(cpu_dev, policy->cpus);\n\tif (ret) {\n\t\tdev_warn(cpu_dev, \"failed to get sharing cpumask\\n\");\n\t\tgoto out_free_cpumask;\n\t}\n\n\t \n\tret = dev_pm_opp_of_get_sharing_cpus(cpu_dev, priv->opp_shared_cpus);\n\tif (ret || cpumask_empty(priv->opp_shared_cpus)) {\n\t\t \n\t\tcpumask_copy(priv->opp_shared_cpus, policy->cpus);\n\t}\n\n\t  \n\tnr_opp = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (nr_opp <= 0) {\n\t\tret = perf_ops->device_opps_add(ph, cpu_dev);\n\t\tif (ret) {\n\t\t\tdev_warn(cpu_dev, \"failed to add opps to the device\\n\");\n\t\t\tgoto out_free_cpumask;\n\t\t}\n\n\t\tnr_opp = dev_pm_opp_get_opp_count(cpu_dev);\n\t\tif (nr_opp <= 0) {\n\t\t\tdev_err(cpu_dev, \"%s: No OPPs for this device: %d\\n\",\n\t\t\t\t__func__, nr_opp);\n\n\t\t\tret = -ENODEV;\n\t\t\tgoto out_free_opp;\n\t\t}\n\n\t\tret = dev_pm_opp_set_sharing_cpus(cpu_dev, priv->opp_shared_cpus);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dev, \"%s: failed to mark OPPs as shared: %d\\n\",\n\t\t\t\t__func__, ret);\n\n\t\t\tgoto out_free_opp;\n\t\t}\n\n\t\tpriv->nr_opp = nr_opp;\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed to init cpufreq table: %d\\n\", ret);\n\t\tgoto out_free_opp;\n\t}\n\n\tpriv->cpu_dev = cpu_dev;\n\tpriv->domain_id = perf_ops->device_domain_id(cpu_dev);\n\n\tpolicy->driver_data = priv;\n\tpolicy->freq_table = freq_table;\n\n\t \n\tpolicy->dvfs_possible_from_any_cpu = true;\n\n\tlatency = perf_ops->transition_latency_get(ph, cpu_dev);\n\tif (!latency)\n\t\tlatency = CPUFREQ_ETERNAL;\n\n\tpolicy->cpuinfo.transition_latency = latency;\n\n\tpolicy->fast_switch_possible =\n\t\tperf_ops->fast_switch_possible(ph, cpu_dev);\n\n\treturn 0;\n\nout_free_opp:\n\tdev_pm_opp_remove_all_dynamic(cpu_dev);\n\nout_free_cpumask:\n\tfree_cpumask_var(priv->opp_shared_cpus);\n\nout_free_priv:\n\tkfree(priv);\n\n\treturn ret;\n}\n\nstatic int scmi_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct scmi_data *priv = policy->driver_data;\n\n\tdev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);\n\tdev_pm_opp_remove_all_dynamic(priv->cpu_dev);\n\tfree_cpumask_var(priv->opp_shared_cpus);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic void scmi_cpufreq_register_em(struct cpufreq_policy *policy)\n{\n\tstruct em_data_callback em_cb = EM_DATA_CB(scmi_get_cpu_power);\n\tenum scmi_power_scale power_scale = perf_ops->power_scale_get(ph);\n\tstruct scmi_data *priv = policy->driver_data;\n\tbool em_power_scale = false;\n\n\t \n\tif (!priv->nr_opp)\n\t\treturn;\n\n\tif (power_scale == SCMI_POWER_MILLIWATTS\n\t    || power_scale == SCMI_POWER_MICROWATTS)\n\t\tem_power_scale = true;\n\n\tem_dev_register_perf_domain(get_cpu_device(policy->cpu), priv->nr_opp,\n\t\t\t\t    &em_cb, priv->opp_shared_cpus,\n\t\t\t\t    em_power_scale);\n}\n\nstatic struct cpufreq_driver scmi_cpufreq_driver = {\n\t.name\t= \"scmi\",\n\t.flags\t= CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t  CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t  CPUFREQ_IS_COOLING_DEV,\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.attr\t= cpufreq_generic_attr,\n\t.target_index\t= scmi_cpufreq_set_target,\n\t.fast_switch\t= scmi_cpufreq_fast_switch,\n\t.get\t= scmi_cpufreq_get_rate,\n\t.init\t= scmi_cpufreq_init,\n\t.exit\t= scmi_cpufreq_exit,\n\t.register_em\t= scmi_cpufreq_register_em,\n};\n\nstatic int scmi_cpufreq_probe(struct scmi_device *sdev)\n{\n\tint ret;\n\tstruct device *dev = &sdev->dev;\n\tconst struct scmi_handle *handle;\n\n\thandle = sdev->handle;\n\n\tif (!handle)\n\t\treturn -ENODEV;\n\n\tperf_ops = handle->devm_protocol_get(sdev, SCMI_PROTOCOL_PERF, &ph);\n\tif (IS_ERR(perf_ops))\n\t\treturn PTR_ERR(perf_ops);\n\n#ifdef CONFIG_COMMON_CLK\n\t \n\tif (of_property_present(dev->of_node, \"#clock-cells\")) {\n\t\tret = devm_of_clk_add_hw_provider(dev, of_clk_hw_simple_get, NULL);\n\t\tif (ret)\n\t\t\treturn dev_err_probe(dev, ret, \"%s: registering clock provider failed\\n\", __func__);\n\t}\n#endif\n\n\tret = cpufreq_register_driver(&scmi_cpufreq_driver);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: registering cpufreq failed, err: %d\\n\",\n\t\t\t__func__, ret);\n\t}\n\n\treturn ret;\n}\n\nstatic void scmi_cpufreq_remove(struct scmi_device *sdev)\n{\n\tcpufreq_unregister_driver(&scmi_cpufreq_driver);\n}\n\nstatic const struct scmi_device_id scmi_id_table[] = {\n\t{ SCMI_PROTOCOL_PERF, \"cpufreq\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(scmi, scmi_id_table);\n\nstatic struct scmi_driver scmi_cpufreq_drv = {\n\t.name\t\t= \"scmi-cpufreq\",\n\t.probe\t\t= scmi_cpufreq_probe,\n\t.remove\t\t= scmi_cpufreq_remove,\n\t.id_table\t= scmi_id_table,\n};\nmodule_scmi_driver(scmi_cpufreq_drv);\n\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCMI CPUFreq interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}