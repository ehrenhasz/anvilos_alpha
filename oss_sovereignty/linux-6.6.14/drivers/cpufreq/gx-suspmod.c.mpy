{
  "module_name": "gx-suspmod.c",
  "hash_id": "c9cb62a8ec4d5974f5ddc4e8a434e8764a6ab881688b5c8e8767bfc7ccb28e4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/gx-suspmod.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/cpufreq.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/processor-cyrix.h>\n\n \n#define PCI_PMER1\t0x80\t \n#define PCI_PMER2\t0x81\t \n#define PCI_PMER3\t0x82\t \n#define PCI_IRQTC\t0x8c\t \n#define PCI_VIDTC\t0x8d\t \n#define PCI_MODOFF\t0x94\t \n#define PCI_MODON\t0x95\t \n#define PCI_SUSCFG\t0x96\t \n\n \n#define GPM\t\t(1<<0)\t \n#define GIT\t\t(1<<1)\t \n#define GTR\t\t(1<<2)\t \n#define IRQ_SPDUP\t(1<<3)\t \n#define VID_SPDUP\t(1<<4)\t \n\n \n#define SUSMOD\t\t(1<<0)\t \n \n#define SMISPDUP\t(1<<1)\t \n\t\t\t\t \n#define SUSCFG\t\t(1<<2)\t \n \n#define PWRSVE_ISA\t(1<<3)\t \n#define PWRSVE\t\t(1<<4)\t \n\nstruct gxfreq_params {\n\tu8 on_duration;\n\tu8 off_duration;\n\tu8 pci_suscfg;\n\tu8 pci_pmer1;\n\tu8 pci_pmer2;\n\tstruct pci_dev *cs55x0;\n};\n\nstatic struct gxfreq_params *gx_params;\nstatic int stock_freq;\n\n \nstatic int pci_busclk;\nmodule_param(pci_busclk, int, 0444);\n\n \nstatic int max_duration = 255;\nmodule_param(max_duration, int, 0444);\n\n \n#define POLICY_MIN_DIV 20\n\n\n \nstatic int gx_freq_mult[16] = {\n\t\t4, 10, 4, 6, 9, 5, 7, 8,\n\t\t0, 0, 0, 0, 0, 0, 0, 0\n};\n\n\n \nstatic struct pci_device_id gx_chipset_tbl[] __initdata = {\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5530_LEGACY), },\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5520), },\n\t{ PCI_VDEVICE(CYRIX, PCI_DEVICE_ID_CYRIX_5510), },\n\t{ 0, },\n};\nMODULE_DEVICE_TABLE(pci, gx_chipset_tbl);\n\nstatic void gx_write_byte(int reg, int value)\n{\n\tpci_write_config_byte(gx_params->cs55x0, reg, value);\n}\n\n \nstatic struct pci_dev * __init gx_detect_chipset(void)\n{\n\tstruct pci_dev *gx_pci = NULL;\n\n\t \n\tfor_each_pci_dev(gx_pci) {\n\t\tif ((pci_match_id(gx_chipset_tbl, gx_pci)) != NULL)\n\t\t\treturn gx_pci;\n\t}\n\n\tpr_debug(\"error: no supported chipset found!\\n\");\n\treturn NULL;\n}\n\n \nstatic unsigned int gx_get_cpuspeed(unsigned int cpu)\n{\n\tif ((gx_params->pci_suscfg & SUSMOD) == 0)\n\t\treturn stock_freq;\n\n\treturn (stock_freq * gx_params->off_duration)\n\t\t/ (gx_params->on_duration + gx_params->off_duration);\n}\n\n \n\nstatic unsigned int gx_validate_speed(unsigned int khz, u8 *on_duration,\n\t\tu8 *off_duration)\n{\n\tunsigned int i;\n\tu8 tmp_on, tmp_off;\n\tint old_tmp_freq = stock_freq;\n\tint tmp_freq;\n\n\t*off_duration = 1;\n\t*on_duration = 0;\n\n\tfor (i = max_duration; i > 0; i--) {\n\t\ttmp_off = ((khz * i) / stock_freq) & 0xff;\n\t\ttmp_on = i - tmp_off;\n\t\ttmp_freq = (stock_freq * tmp_off) / i;\n\t\t \n\t\tif (abs(tmp_freq - khz) <= abs(old_tmp_freq - khz)) {\n\t\t\t*on_duration = tmp_on;\n\t\t\t*off_duration = tmp_off;\n\t\t\told_tmp_freq = tmp_freq;\n\t\t}\n\t}\n\n\treturn old_tmp_freq;\n}\n\n\n \n\nstatic void gx_set_cpuspeed(struct cpufreq_policy *policy, unsigned int khz)\n{\n\tu8 suscfg, pmer1;\n\tunsigned int new_khz;\n\tunsigned long flags;\n\tstruct cpufreq_freqs freqs;\n\n\tfreqs.old = gx_get_cpuspeed(0);\n\n\tnew_khz = gx_validate_speed(khz, &gx_params->on_duration,\n\t\t\t&gx_params->off_duration);\n\n\tfreqs.new = new_khz;\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\tlocal_irq_save(flags);\n\n\tif (new_khz != stock_freq) {\n\t\t \n\t\tswitch (gx_params->cs55x0->device) {\n\t\tcase PCI_DEVICE_ID_CYRIX_5530_LEGACY:\n\t\t\tpmer1 = gx_params->pci_pmer1 | IRQ_SPDUP | VID_SPDUP;\n\t\t\t \n\t\t\t \n\t\t\tgx_write_byte(PCI_IRQTC, 4);\n\t\t\t \n\t\t\tgx_write_byte(PCI_VIDTC, 100);\n\t\t\tgx_write_byte(PCI_PMER1, pmer1);\n\n\t\t\tif (gx_params->cs55x0->revision < 0x10) {\n\t\t\t\t \n\t\t\t\tsuscfg = gx_params->pci_suscfg|SUSMOD;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tsuscfg = gx_params->pci_suscfg|SUSMOD|PWRSVE;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_CYRIX_5520:\n\t\tcase PCI_DEVICE_ID_CYRIX_5510:\n\t\t\tsuscfg = gx_params->pci_suscfg | SUSMOD;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlocal_irq_restore(flags);\n\t\t\tpr_debug(\"fatal: try to set unknown chipset.\\n\");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tsuscfg = gx_params->pci_suscfg & ~(SUSMOD);\n\t\tgx_params->off_duration = 0;\n\t\tgx_params->on_duration = 0;\n\t\tpr_debug(\"suspend modulation disabled: cpu runs 100%% speed.\\n\");\n\t}\n\n\tgx_write_byte(PCI_MODOFF, gx_params->off_duration);\n\tgx_write_byte(PCI_MODON, gx_params->on_duration);\n\n\tgx_write_byte(PCI_SUSCFG, suscfg);\n\tpci_read_config_byte(gx_params->cs55x0, PCI_SUSCFG, &suscfg);\n\n\tlocal_irq_restore(flags);\n\n\tgx_params->pci_suscfg = suscfg;\n\n\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\n\tpr_debug(\"suspend modulation w/ duration of ON:%d us, OFF:%d us\\n\",\n\t\tgx_params->on_duration * 32, gx_params->off_duration * 32);\n\tpr_debug(\"suspend modulation w/ clock speed: %d kHz.\\n\", freqs.new);\n}\n\n \n\n \n\nstatic int cpufreq_gx_verify(struct cpufreq_policy_data *policy)\n{\n\tunsigned int tmp_freq = 0;\n\tu8 tmp1, tmp2;\n\n\tif (!stock_freq || !policy)\n\t\treturn -EINVAL;\n\n\tpolicy->cpu = 0;\n\tcpufreq_verify_within_limits(policy, (stock_freq / max_duration),\n\t\t\tstock_freq);\n\n\t \n\ttmp_freq = gx_validate_speed(policy->min, &tmp1, &tmp2);\n\tif (tmp_freq < policy->min)\n\t\ttmp_freq += stock_freq / max_duration;\n\tpolicy->min = tmp_freq;\n\tif (policy->min > policy->max)\n\t\tpolicy->max = tmp_freq;\n\ttmp_freq = gx_validate_speed(policy->max, &tmp1, &tmp2);\n\tif (tmp_freq > policy->max)\n\t\ttmp_freq -= stock_freq / max_duration;\n\tpolicy->max = tmp_freq;\n\tif (policy->max < policy->min)\n\t\tpolicy->max = policy->min;\n\tcpufreq_verify_within_limits(policy, (stock_freq / max_duration),\n\t\t\tstock_freq);\n\n\treturn 0;\n}\n\n \nstatic int cpufreq_gx_target(struct cpufreq_policy *policy,\n\t\t\t     unsigned int target_freq,\n\t\t\t     unsigned int relation)\n{\n\tu8 tmp1, tmp2;\n\tunsigned int tmp_freq;\n\n\tif (!stock_freq || !policy)\n\t\treturn -EINVAL;\n\n\tpolicy->cpu = 0;\n\n\ttmp_freq = gx_validate_speed(target_freq, &tmp1, &tmp2);\n\twhile (tmp_freq < policy->min) {\n\t\ttmp_freq += stock_freq / max_duration;\n\t\ttmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);\n\t}\n\twhile (tmp_freq > policy->max) {\n\t\ttmp_freq -= stock_freq / max_duration;\n\t\ttmp_freq = gx_validate_speed(tmp_freq, &tmp1, &tmp2);\n\t}\n\n\tgx_set_cpuspeed(policy, tmp_freq);\n\n\treturn 0;\n}\n\nstatic int cpufreq_gx_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int maxfreq;\n\n\tif (!policy || policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (pci_busclk)\n\t\tmaxfreq = pci_busclk * gx_freq_mult[getCx86(CX86_DIR1) & 0x0f];\n\telse if (cpu_khz)\n\t\tmaxfreq = cpu_khz;\n\telse\n\t\tmaxfreq = 30000 * gx_freq_mult[getCx86(CX86_DIR1) & 0x0f];\n\n\tstock_freq = maxfreq;\n\n\tpr_debug(\"cpu max frequency is %d.\\n\", maxfreq);\n\n\t \n\tpolicy->cpu = 0;\n\n\tif (max_duration < POLICY_MIN_DIV)\n\t\tpolicy->min = maxfreq / max_duration;\n\telse\n\t\tpolicy->min = maxfreq / POLICY_MIN_DIV;\n\tpolicy->max = maxfreq;\n\tpolicy->cpuinfo.min_freq = maxfreq / max_duration;\n\tpolicy->cpuinfo.max_freq = maxfreq;\n\n\treturn 0;\n}\n\n \nstatic struct cpufreq_driver gx_suspmod_driver = {\n\t.flags\t\t= CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.get\t\t= gx_get_cpuspeed,\n\t.verify\t\t= cpufreq_gx_verify,\n\t.target\t\t= cpufreq_gx_target,\n\t.init\t\t= cpufreq_gx_cpu_init,\n\t.name\t\t= \"gx-suspmod\",\n};\n\nstatic int __init cpufreq_gx_init(void)\n{\n\tint ret;\n\tstruct gxfreq_params *params;\n\tstruct pci_dev *gx_pci;\n\n\t \n\tgx_pci = gx_detect_chipset();\n\tif (gx_pci == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tif (max_duration > 0xff)\n\t\tmax_duration = 0xff;\n\n\tpr_debug(\"geode suspend modulation available.\\n\");\n\n\tparams = kzalloc(sizeof(*params), GFP_KERNEL);\n\tif (params == NULL)\n\t\treturn -ENOMEM;\n\n\tparams->cs55x0 = gx_pci;\n\tgx_params = params;\n\n\t \n\tpci_read_config_byte(params->cs55x0, PCI_SUSCFG, &(params->pci_suscfg));\n\tpci_read_config_byte(params->cs55x0, PCI_PMER1, &(params->pci_pmer1));\n\tpci_read_config_byte(params->cs55x0, PCI_PMER2, &(params->pci_pmer2));\n\tpci_read_config_byte(params->cs55x0, PCI_MODON, &(params->on_duration));\n\tpci_read_config_byte(params->cs55x0, PCI_MODOFF,\n\t\t\t&(params->off_duration));\n\n\tret = cpufreq_register_driver(&gx_suspmod_driver);\n\tif (ret) {\n\t\tkfree(params);\n\t\treturn ret;                    \n\t}\n\n\treturn 0;\n}\n\nstatic void __exit cpufreq_gx_exit(void)\n{\n\tcpufreq_unregister_driver(&gx_suspmod_driver);\n\tpci_dev_put(gx_params->cs55x0);\n\tkfree(gx_params);\n}\n\nMODULE_AUTHOR(\"Hiroshi Miura <miura@da-cha.org>\");\nMODULE_DESCRIPTION(\"Cpufreq driver for Cyrix MediaGX and NatSemi Geode\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(cpufreq_gx_init);\nmodule_exit(cpufreq_gx_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}