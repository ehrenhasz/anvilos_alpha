{
  "module_name": "mediatek-cpufreq-hw.c",
  "hash_id": "14f4a4f1412521705d3988993810ed1c5f6fda01dbe1b4159caa648a6209459a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/mediatek-cpufreq-hw.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/cpufreq.h>\n#include <linux/energy_model.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#define LUT_MAX_ENTRIES\t\t\t32U\n#define LUT_FREQ\t\t\tGENMASK(11, 0)\n#define LUT_ROW_SIZE\t\t\t0x4\n#define CPUFREQ_HW_STATUS\t\tBIT(0)\n#define SVS_HW_STATUS\t\t\tBIT(1)\n#define POLL_USEC\t\t\t1000\n#define TIMEOUT_USEC\t\t\t300000\n\nenum {\n\tREG_FREQ_LUT_TABLE,\n\tREG_FREQ_ENABLE,\n\tREG_FREQ_PERF_STATE,\n\tREG_FREQ_HW_STATE,\n\tREG_EM_POWER_TBL,\n\tREG_FREQ_LATENCY,\n\n\tREG_ARRAY_SIZE,\n};\n\nstruct mtk_cpufreq_data {\n\tstruct cpufreq_frequency_table *table;\n\tvoid __iomem *reg_bases[REG_ARRAY_SIZE];\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tint nr_opp;\n};\n\nstatic const u16 cpufreq_mtk_offsets[REG_ARRAY_SIZE] = {\n\t[REG_FREQ_LUT_TABLE]\t= 0x0,\n\t[REG_FREQ_ENABLE]\t= 0x84,\n\t[REG_FREQ_PERF_STATE]\t= 0x88,\n\t[REG_FREQ_HW_STATE]\t= 0x8c,\n\t[REG_EM_POWER_TBL]\t= 0x90,\n\t[REG_FREQ_LATENCY]\t= 0x110,\n};\n\nstatic int __maybe_unused\nmtk_cpufreq_get_cpu_power(struct device *cpu_dev, unsigned long *uW,\n\t\t\t  unsigned long *KHz)\n{\n\tstruct mtk_cpufreq_data *data;\n\tstruct cpufreq_policy *policy;\n\tint i;\n\n\tpolicy = cpufreq_cpu_get_raw(cpu_dev->id);\n\tif (!policy)\n\t\treturn 0;\n\n\tdata = policy->driver_data;\n\n\tfor (i = 0; i < data->nr_opp; i++) {\n\t\tif (data->table[i].frequency < *KHz)\n\t\t\tbreak;\n\t}\n\ti--;\n\n\t*KHz = data->table[i].frequency;\n\t \n\t*uW = readl_relaxed(data->reg_bases[REG_EM_POWER_TBL] +\n\t\t\t    i * LUT_ROW_SIZE);\n\n\treturn 0;\n}\n\nstatic int mtk_cpufreq_hw_target_index(struct cpufreq_policy *policy,\n\t\t\t\t       unsigned int index)\n{\n\tstruct mtk_cpufreq_data *data = policy->driver_data;\n\n\twritel_relaxed(index, data->reg_bases[REG_FREQ_PERF_STATE]);\n\n\treturn 0;\n}\n\nstatic unsigned int mtk_cpufreq_hw_get(unsigned int cpu)\n{\n\tstruct mtk_cpufreq_data *data;\n\tstruct cpufreq_policy *policy;\n\tunsigned int index;\n\n\tpolicy = cpufreq_cpu_get_raw(cpu);\n\tif (!policy)\n\t\treturn 0;\n\n\tdata = policy->driver_data;\n\n\tindex = readl_relaxed(data->reg_bases[REG_FREQ_PERF_STATE]);\n\tindex = min(index, LUT_MAX_ENTRIES - 1);\n\n\treturn data->table[index].frequency;\n}\n\nstatic unsigned int mtk_cpufreq_hw_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\t       unsigned int target_freq)\n{\n\tstruct mtk_cpufreq_data *data = policy->driver_data;\n\tunsigned int index;\n\n\tindex = cpufreq_table_find_index_dl(policy, target_freq, false);\n\n\twritel_relaxed(index, data->reg_bases[REG_FREQ_PERF_STATE]);\n\n\treturn policy->freq_table[index].frequency;\n}\n\nstatic int mtk_cpu_create_freq_table(struct platform_device *pdev,\n\t\t\t\t     struct mtk_cpufreq_data *data)\n{\n\tstruct device *dev = &pdev->dev;\n\tu32 temp, i, freq, prev_freq = 0;\n\tvoid __iomem *base_table;\n\n\tdata->table = devm_kcalloc(dev, LUT_MAX_ENTRIES + 1,\n\t\t\t\t   sizeof(*data->table), GFP_KERNEL);\n\tif (!data->table)\n\t\treturn -ENOMEM;\n\n\tbase_table = data->reg_bases[REG_FREQ_LUT_TABLE];\n\n\tfor (i = 0; i < LUT_MAX_ENTRIES; i++) {\n\t\ttemp = readl_relaxed(base_table + (i * LUT_ROW_SIZE));\n\t\tfreq = FIELD_GET(LUT_FREQ, temp) * 1000;\n\n\t\tif (freq == prev_freq)\n\t\t\tbreak;\n\n\t\tdata->table[i].frequency = freq;\n\n\t\tdev_dbg(dev, \"index=%d freq=%d\\n\", i, data->table[i].frequency);\n\n\t\tprev_freq = freq;\n\t}\n\n\tdata->table[i].frequency = CPUFREQ_TABLE_END;\n\tdata->nr_opp = i;\n\n\treturn 0;\n}\n\nstatic int mtk_cpu_resources_init(struct platform_device *pdev,\n\t\t\t\t  struct cpufreq_policy *policy,\n\t\t\t\t  const u16 *offsets)\n{\n\tstruct mtk_cpufreq_data *data;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tstruct of_phandle_args args;\n\tvoid __iomem *base;\n\tint ret, i;\n\tint index;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = of_perf_domain_get_sharing_cpumask(policy->cpu, \"performance-domains\",\n\t\t\t\t\t\t \"#performance-domain-cells\",\n\t\t\t\t\t\t policy->cpus, &args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tindex = args.args[0];\n\tof_node_put(args.np);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, index);\n\tif (!res) {\n\t\tdev_err(dev, \"failed to get mem resource %d\\n\", index);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!request_mem_region(res->start, resource_size(res), res->name)) {\n\t\tdev_err(dev, \"failed to request resource %pR\\n\", res);\n\t\treturn -EBUSY;\n\t}\n\n\tbase = ioremap(res->start, resource_size(res));\n\tif (!base) {\n\t\tdev_err(dev, \"failed to map resource %pR\\n\", res);\n\t\tret = -ENOMEM;\n\t\tgoto release_region;\n\t}\n\n\tdata->base = base;\n\tdata->res = res;\n\n\tfor (i = REG_FREQ_LUT_TABLE; i < REG_ARRAY_SIZE; i++)\n\t\tdata->reg_bases[i] = base + offsets[i];\n\n\tret = mtk_cpu_create_freq_table(pdev, data);\n\tif (ret) {\n\t\tdev_info(dev, \"Domain-%d failed to create freq table\\n\", index);\n\t\treturn ret;\n\t}\n\n\tpolicy->freq_table = data->table;\n\tpolicy->driver_data = data;\n\n\treturn 0;\nrelease_region:\n\trelease_mem_region(res->start, resource_size(res));\n\treturn ret;\n}\n\nstatic int mtk_cpufreq_hw_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct platform_device *pdev = cpufreq_get_driver_data();\n\tint sig, pwr_hw = CPUFREQ_HW_STATUS | SVS_HW_STATUS;\n\tstruct mtk_cpufreq_data *data;\n\tunsigned int latency;\n\tint ret;\n\n\t \n\tret = mtk_cpu_resources_init(pdev, policy, platform_get_drvdata(pdev));\n\tif (ret) {\n\t\tdev_info(&pdev->dev, \"CPUFreq resource init failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdata = policy->driver_data;\n\n\tlatency = readl_relaxed(data->reg_bases[REG_FREQ_LATENCY]) * 1000;\n\tif (!latency)\n\t\tlatency = CPUFREQ_ETERNAL;\n\n\tpolicy->cpuinfo.transition_latency = latency;\n\tpolicy->fast_switch_possible = true;\n\n\t \n\twritel_relaxed(0x1, data->reg_bases[REG_FREQ_ENABLE]);\n\tif (readl_poll_timeout(data->reg_bases[REG_FREQ_HW_STATE], sig,\n\t\t\t       (sig & pwr_hw) == pwr_hw, POLL_USEC,\n\t\t\t       TIMEOUT_USEC)) {\n\t\tif (!(sig & CPUFREQ_HW_STATUS)) {\n\t\t\tpr_info(\"cpufreq hardware of CPU%d is not enabled\\n\",\n\t\t\t\tpolicy->cpu);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr_info(\"SVS of CPU%d is not enabled\\n\", policy->cpu);\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_cpufreq_hw_cpu_exit(struct cpufreq_policy *policy)\n{\n\tstruct mtk_cpufreq_data *data = policy->driver_data;\n\tstruct resource *res = data->res;\n\tvoid __iomem *base = data->base;\n\n\t \n\twritel_relaxed(0x0, data->reg_bases[REG_FREQ_ENABLE]);\n\tiounmap(base);\n\trelease_mem_region(res->start, resource_size(res));\n\n\treturn 0;\n}\n\nstatic void mtk_cpufreq_register_em(struct cpufreq_policy *policy)\n{\n\tstruct em_data_callback em_cb = EM_DATA_CB(mtk_cpufreq_get_cpu_power);\n\tstruct mtk_cpufreq_data *data = policy->driver_data;\n\n\tem_dev_register_perf_domain(get_cpu_device(policy->cpu), data->nr_opp,\n\t\t\t\t    &em_cb, policy->cpus, true);\n}\n\nstatic struct cpufreq_driver cpufreq_mtk_hw_driver = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t\t  CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t\t  CPUFREQ_IS_COOLING_DEV,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= mtk_cpufreq_hw_target_index,\n\t.get\t\t= mtk_cpufreq_hw_get,\n\t.init\t\t= mtk_cpufreq_hw_cpu_init,\n\t.exit\t\t= mtk_cpufreq_hw_cpu_exit,\n\t.register_em\t= mtk_cpufreq_register_em,\n\t.fast_switch\t= mtk_cpufreq_hw_fast_switch,\n\t.name\t\t= \"mtk-cpufreq-hw\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic int mtk_cpufreq_hw_driver_probe(struct platform_device *pdev)\n{\n\tconst void *data;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tplatform_set_drvdata(pdev, (void *) data);\n\tcpufreq_mtk_hw_driver.driver_data = pdev;\n\n\tret = cpufreq_register_driver(&cpufreq_mtk_hw_driver);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"CPUFreq HW driver failed to register\\n\");\n\n\treturn ret;\n}\n\nstatic void mtk_cpufreq_hw_driver_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&cpufreq_mtk_hw_driver);\n}\n\nstatic const struct of_device_id mtk_cpufreq_hw_match[] = {\n\t{ .compatible = \"mediatek,cpufreq-hw\", .data = &cpufreq_mtk_offsets },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mtk_cpufreq_hw_match);\n\nstatic struct platform_driver mtk_cpufreq_hw_driver = {\n\t.probe = mtk_cpufreq_hw_driver_probe,\n\t.remove_new = mtk_cpufreq_hw_driver_remove,\n\t.driver = {\n\t\t.name = \"mtk-cpufreq-hw\",\n\t\t.of_match_table = mtk_cpufreq_hw_match,\n\t},\n};\nmodule_platform_driver(mtk_cpufreq_hw_driver);\n\nMODULE_AUTHOR(\"Hector Yuan <hector.yuan@mediatek.com>\");\nMODULE_DESCRIPTION(\"Mediatek cpufreq-hw driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}