{
  "module_name": "scpi-cpufreq.c",
  "hash_id": "d10c0cd07044f875e7aef653007e8fe92031facd7db185a6a04e9b71a93df478",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/scpi-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/scpi_protocol.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct scpi_data {\n\tstruct clk *clk;\n\tstruct device *cpu_dev;\n};\n\nstatic struct scpi_ops *scpi_ops;\n\nstatic unsigned int scpi_cpufreq_get_rate(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);\n\tstruct scpi_data *priv = policy->driver_data;\n\tunsigned long rate = clk_get_rate(priv->clk);\n\n\treturn rate / 1000;\n}\n\nstatic int\nscpi_cpufreq_set_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tu64 rate = policy->freq_table[index].frequency * 1000;\n\tstruct scpi_data *priv = policy->driver_data;\n\tint ret;\n\n\tret = clk_set_rate(priv->clk, rate);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (clk_get_rate(priv->clk) != rate)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int\nscpi_get_sharing_cpus(struct device *cpu_dev, struct cpumask *cpumask)\n{\n\tint cpu, domain, tdomain;\n\tstruct device *tcpu_dev;\n\n\tdomain = scpi_ops->device_domain_id(cpu_dev);\n\tif (domain < 0)\n\t\treturn domain;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == cpu_dev->id)\n\t\t\tcontinue;\n\n\t\ttcpu_dev = get_cpu_device(cpu);\n\t\tif (!tcpu_dev)\n\t\t\tcontinue;\n\n\t\ttdomain = scpi_ops->device_domain_id(tcpu_dev);\n\t\tif (tdomain == domain)\n\t\t\tcpumask_set_cpu(cpu, cpumask);\n\t}\n\n\treturn 0;\n}\n\nstatic int scpi_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tint ret;\n\tunsigned int latency;\n\tstruct device *cpu_dev;\n\tstruct scpi_data *priv;\n\tstruct cpufreq_frequency_table *freq_table;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"failed to get cpu%d device\\n\", policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\tret = scpi_ops->add_opps_to_device(cpu_dev);\n\tif (ret) {\n\t\tdev_warn(cpu_dev, \"failed to add opps to the device\\n\");\n\t\treturn ret;\n\t}\n\n\tret = scpi_get_sharing_cpus(cpu_dev, policy->cpus);\n\tif (ret) {\n\t\tdev_warn(cpu_dev, \"failed to get sharing cpumask\\n\");\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy->cpus);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"%s: failed to mark OPPs as shared: %d\\n\",\n\t\t\t__func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (ret <= 0) {\n\t\tdev_dbg(cpu_dev, \"OPP table is not ready, deferring probe\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_free_opp;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_opp;\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed to init cpufreq table: %d\\n\", ret);\n\t\tgoto out_free_priv;\n\t}\n\n\tpriv->cpu_dev = cpu_dev;\n\tpriv->clk = clk_get(cpu_dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(cpu_dev, \"%s: Failed to get clk for cpu: %d\\n\",\n\t\t\t__func__, cpu_dev->id);\n\t\tret = PTR_ERR(priv->clk);\n\t\tgoto out_free_cpufreq_table;\n\t}\n\n\tpolicy->driver_data = priv;\n\tpolicy->freq_table = freq_table;\n\n\t \n\tpolicy->dvfs_possible_from_any_cpu = true;\n\n\tlatency = scpi_ops->get_transition_latency(cpu_dev);\n\tif (!latency)\n\t\tlatency = CPUFREQ_ETERNAL;\n\n\tpolicy->cpuinfo.transition_latency = latency;\n\n\tpolicy->fast_switch_possible = false;\n\n\treturn 0;\n\nout_free_cpufreq_table:\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\nout_free_priv:\n\tkfree(priv);\nout_free_opp:\n\tdev_pm_opp_remove_all_dynamic(cpu_dev);\n\n\treturn ret;\n}\n\nstatic int scpi_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct scpi_data *priv = policy->driver_data;\n\n\tclk_put(priv->clk);\n\tdev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);\n\tdev_pm_opp_remove_all_dynamic(priv->cpu_dev);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver scpi_cpufreq_driver = {\n\t.name\t= \"scpi-cpufreq\",\n\t.flags\t= CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t  CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t  CPUFREQ_IS_COOLING_DEV,\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.attr\t= cpufreq_generic_attr,\n\t.get\t= scpi_cpufreq_get_rate,\n\t.init\t= scpi_cpufreq_init,\n\t.exit\t= scpi_cpufreq_exit,\n\t.target_index\t= scpi_cpufreq_set_target,\n\t.register_em\t= cpufreq_register_em_with_opp,\n};\n\nstatic int scpi_cpufreq_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\tscpi_ops = get_scpi_ops();\n\tif (!scpi_ops)\n\t\treturn -EIO;\n\n\tret = cpufreq_register_driver(&scpi_cpufreq_driver);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"%s: registering cpufreq failed, err: %d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n}\n\nstatic void scpi_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&scpi_cpufreq_driver);\n\tscpi_ops = NULL;\n}\n\nstatic struct platform_driver scpi_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"scpi-cpufreq\",\n\t},\n\t.probe\t\t= scpi_cpufreq_probe,\n\t.remove_new\t= scpi_cpufreq_remove,\n};\nmodule_platform_driver(scpi_cpufreq_platdrv);\n\nMODULE_ALIAS(\"platform:scpi-cpufreq\");\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"ARM SCPI CPUFreq interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}