{
  "module_name": "imx-cpufreq-dt.c",
  "hash_id": "debf8764be1537f009de863fe5ddbf15bd04974d3cf5192175feb89b4947689b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/imx-cpufreq-dt.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include \"cpufreq-dt.h\"\n\n#define OCOTP_CFG3_SPEED_GRADE_SHIFT\t8\n#define OCOTP_CFG3_SPEED_GRADE_MASK\t(0x3 << 8)\n#define IMX8MN_OCOTP_CFG3_SPEED_GRADE_MASK\t(0xf << 8)\n#define OCOTP_CFG3_MKT_SEGMENT_SHIFT    6\n#define OCOTP_CFG3_MKT_SEGMENT_MASK     (0x3 << 6)\n#define IMX8MP_OCOTP_CFG3_MKT_SEGMENT_SHIFT    5\n#define IMX8MP_OCOTP_CFG3_MKT_SEGMENT_MASK     (0x3 << 5)\n\n#define IMX7ULP_MAX_RUN_FREQ\t528000\n\n \nstatic struct platform_device *cpufreq_dt_pdev;\nstatic struct device *cpu_dev;\nstatic int cpufreq_opp_token;\n\nenum IMX7ULP_CPUFREQ_CLKS {\n\tARM,\n\tCORE,\n\tSCS_SEL,\n\tHSRUN_CORE,\n\tHSRUN_SCS_SEL,\n\tFIRC,\n};\n\nstatic struct clk_bulk_data imx7ulp_clks[] = {\n\t{ .id = \"arm\" },\n\t{ .id = \"core\" },\n\t{ .id = \"scs_sel\" },\n\t{ .id = \"hsrun_core\" },\n\t{ .id = \"hsrun_scs_sel\" },\n\t{ .id = \"firc\" },\n};\n\nstatic unsigned int imx7ulp_get_intermediate(struct cpufreq_policy *policy,\n\t\t\t\t\t     unsigned int index)\n{\n\treturn clk_get_rate(imx7ulp_clks[FIRC].clk);\n}\n\nstatic int imx7ulp_target_intermediate(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int index)\n{\n\tunsigned int newfreq = policy->freq_table[index].frequency;\n\n\tclk_set_parent(imx7ulp_clks[SCS_SEL].clk, imx7ulp_clks[FIRC].clk);\n\tclk_set_parent(imx7ulp_clks[HSRUN_SCS_SEL].clk, imx7ulp_clks[FIRC].clk);\n\n\tif (newfreq > IMX7ULP_MAX_RUN_FREQ)\n\t\tclk_set_parent(imx7ulp_clks[ARM].clk,\n\t\t\t       imx7ulp_clks[HSRUN_CORE].clk);\n\telse\n\t\tclk_set_parent(imx7ulp_clks[ARM].clk, imx7ulp_clks[CORE].clk);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_dt_platform_data imx7ulp_data = {\n\t.target_intermediate = imx7ulp_target_intermediate,\n\t.get_intermediate = imx7ulp_get_intermediate,\n};\n\nstatic int imx_cpufreq_dt_probe(struct platform_device *pdev)\n{\n\tstruct platform_device *dt_pdev;\n\tu32 cell_value, supported_hw[2];\n\tint speed_grade, mkt_segment;\n\tint ret;\n\n\tcpu_dev = get_cpu_device(0);\n\n\tif (!of_property_present(cpu_dev->of_node, \"cpu-supply\"))\n\t\treturn -ENODEV;\n\n\tif (of_machine_is_compatible(\"fsl,imx7ulp\")) {\n\t\tret = clk_bulk_get(cpu_dev, ARRAY_SIZE(imx7ulp_clks),\n\t\t\t\t   imx7ulp_clks);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tdt_pdev = platform_device_register_data(NULL, \"cpufreq-dt\",\n\t\t\t\t\t\t\t-1, &imx7ulp_data,\n\t\t\t\t\t\t\tsizeof(imx7ulp_data));\n\t\tif (IS_ERR(dt_pdev)) {\n\t\t\tclk_bulk_put(ARRAY_SIZE(imx7ulp_clks), imx7ulp_clks);\n\t\t\tret = PTR_ERR(dt_pdev);\n\t\t\tdev_err(&pdev->dev, \"Failed to register cpufreq-dt: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tcpufreq_dt_pdev = dt_pdev;\n\n\t\treturn 0;\n\t}\n\n\tret = nvmem_cell_read_u32(cpu_dev, \"speed_grade\", &cell_value);\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_machine_is_compatible(\"fsl,imx8mn\") ||\n\t    of_machine_is_compatible(\"fsl,imx8mp\"))\n\t\tspeed_grade = (cell_value & IMX8MN_OCOTP_CFG3_SPEED_GRADE_MASK)\n\t\t\t      >> OCOTP_CFG3_SPEED_GRADE_SHIFT;\n\telse\n\t\tspeed_grade = (cell_value & OCOTP_CFG3_SPEED_GRADE_MASK)\n\t\t\t      >> OCOTP_CFG3_SPEED_GRADE_SHIFT;\n\n\tif (of_machine_is_compatible(\"fsl,imx8mp\"))\n\t\tmkt_segment = (cell_value & IMX8MP_OCOTP_CFG3_MKT_SEGMENT_MASK)\n\t\t\t       >> IMX8MP_OCOTP_CFG3_MKT_SEGMENT_SHIFT;\n\telse\n\t\tmkt_segment = (cell_value & OCOTP_CFG3_MKT_SEGMENT_MASK)\n\t\t\t       >> OCOTP_CFG3_MKT_SEGMENT_SHIFT;\n\n\t \n\tif (mkt_segment == 0 && speed_grade == 0) {\n\t\tif (of_machine_is_compatible(\"fsl,imx8mm\") ||\n\t\t    of_machine_is_compatible(\"fsl,imx8mq\"))\n\t\t\tspeed_grade = 1;\n\t\tif (of_machine_is_compatible(\"fsl,imx8mn\") ||\n\t\t    of_machine_is_compatible(\"fsl,imx8mp\"))\n\t\t\tspeed_grade = 0xb;\n\t}\n\n\tsupported_hw[0] = BIT(speed_grade);\n\tsupported_hw[1] = BIT(mkt_segment);\n\tdev_info(&pdev->dev, \"cpu speed grade %d mkt segment %d supported-hw %#x %#x\\n\",\n\t\t\tspeed_grade, mkt_segment, supported_hw[0], supported_hw[1]);\n\n\tcpufreq_opp_token = dev_pm_opp_set_supported_hw(cpu_dev, supported_hw, 2);\n\tif (cpufreq_opp_token < 0) {\n\t\tret = cpufreq_opp_token;\n\t\tdev_err(&pdev->dev, \"Failed to set supported opp: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tcpufreq_dt_pdev = platform_device_register_data(\n\t\t\t&pdev->dev, \"cpufreq-dt\", -1, NULL, 0);\n\tif (IS_ERR(cpufreq_dt_pdev)) {\n\t\tdev_pm_opp_put_supported_hw(cpufreq_opp_token);\n\t\tret = PTR_ERR(cpufreq_dt_pdev);\n\t\tdev_err(&pdev->dev, \"Failed to register cpufreq-dt: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_cpufreq_dt_remove(struct platform_device *pdev)\n{\n\tplatform_device_unregister(cpufreq_dt_pdev);\n\tif (!of_machine_is_compatible(\"fsl,imx7ulp\"))\n\t\tdev_pm_opp_put_supported_hw(cpufreq_opp_token);\n\telse\n\t\tclk_bulk_put(ARRAY_SIZE(imx7ulp_clks), imx7ulp_clks);\n}\n\nstatic struct platform_driver imx_cpufreq_dt_driver = {\n\t.probe = imx_cpufreq_dt_probe,\n\t.remove_new = imx_cpufreq_dt_remove,\n\t.driver = {\n\t\t.name = \"imx-cpufreq-dt\",\n\t},\n};\nmodule_platform_driver(imx_cpufreq_dt_driver);\n\nMODULE_ALIAS(\"platform:imx-cpufreq-dt\");\nMODULE_DESCRIPTION(\"Freescale i.MX cpufreq speed grading driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}