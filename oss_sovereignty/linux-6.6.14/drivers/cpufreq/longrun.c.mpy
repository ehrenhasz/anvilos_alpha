{
  "module_name": "longrun.c",
  "hash_id": "6caab93e48edffb106f37cfc173cd5c0d9ea1b2b9c3ff87deb104ae7e734b66f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/longrun.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/timex.h>\n\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <asm/cpu_device_id.h>\n\nstatic struct cpufreq_driver\tlongrun_driver;\n\n \nstatic unsigned int longrun_low_freq, longrun_high_freq;\n\n\n \nstatic void longrun_get_policy(struct cpufreq_policy *policy)\n{\n\tu32 msr_lo, msr_hi;\n\n\trdmsr(MSR_TMTA_LONGRUN_FLAGS, msr_lo, msr_hi);\n\tpr_debug(\"longrun flags are %x - %x\\n\", msr_lo, msr_hi);\n\tif (msr_lo & 0x01)\n\t\tpolicy->policy = CPUFREQ_POLICY_PERFORMANCE;\n\telse\n\t\tpolicy->policy = CPUFREQ_POLICY_POWERSAVE;\n\n\trdmsr(MSR_TMTA_LONGRUN_CTRL, msr_lo, msr_hi);\n\tpr_debug(\"longrun ctrl is %x - %x\\n\", msr_lo, msr_hi);\n\tmsr_lo &= 0x0000007F;\n\tmsr_hi &= 0x0000007F;\n\n\tif (longrun_high_freq <= longrun_low_freq) {\n\t\t \n\t\tpolicy->min = policy->max = longrun_high_freq;\n\t} else {\n\t\tpolicy->min = longrun_low_freq + msr_lo *\n\t\t\t((longrun_high_freq - longrun_low_freq) / 100);\n\t\tpolicy->max = longrun_low_freq + msr_hi *\n\t\t\t((longrun_high_freq - longrun_low_freq) / 100);\n\t}\n\tpolicy->cpu = 0;\n}\n\n\n \nstatic int longrun_set_policy(struct cpufreq_policy *policy)\n{\n\tu32 msr_lo, msr_hi;\n\tu32 pctg_lo, pctg_hi;\n\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\tif (longrun_high_freq <= longrun_low_freq) {\n\t\t \n\t\tpctg_lo = pctg_hi = 100;\n\t} else {\n\t\tpctg_lo = (policy->min - longrun_low_freq) /\n\t\t\t((longrun_high_freq - longrun_low_freq) / 100);\n\t\tpctg_hi = (policy->max - longrun_low_freq) /\n\t\t\t((longrun_high_freq - longrun_low_freq) / 100);\n\t}\n\n\tif (pctg_hi > 100)\n\t\tpctg_hi = 100;\n\tif (pctg_lo > pctg_hi)\n\t\tpctg_lo = pctg_hi;\n\n\t \n\trdmsr(MSR_TMTA_LONGRUN_FLAGS, msr_lo, msr_hi);\n\tmsr_lo &= 0xFFFFFFFE;\n\tswitch (policy->policy) {\n\tcase CPUFREQ_POLICY_PERFORMANCE:\n\t\tmsr_lo |= 0x00000001;\n\t\tbreak;\n\tcase CPUFREQ_POLICY_POWERSAVE:\n\t\tbreak;\n\t}\n\twrmsr(MSR_TMTA_LONGRUN_FLAGS, msr_lo, msr_hi);\n\n\t \n\trdmsr(MSR_TMTA_LONGRUN_CTRL, msr_lo, msr_hi);\n\tmsr_lo &= 0xFFFFFF80;\n\tmsr_hi &= 0xFFFFFF80;\n\tmsr_lo |= pctg_lo;\n\tmsr_hi |= pctg_hi;\n\twrmsr(MSR_TMTA_LONGRUN_CTRL, msr_lo, msr_hi);\n\n\treturn 0;\n}\n\n\n \nstatic int longrun_verify_policy(struct cpufreq_policy_data *policy)\n{\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\tpolicy->cpu = 0;\n\tcpufreq_verify_within_cpu_limits(policy);\n\n\treturn 0;\n}\n\nstatic unsigned int longrun_get(unsigned int cpu)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\tif (cpu)\n\t\treturn 0;\n\n\tcpuid(0x80860007, &eax, &ebx, &ecx, &edx);\n\tpr_debug(\"cpuid eax is %u\\n\", eax);\n\n\treturn eax * 1000;\n}\n\n \nstatic int longrun_determine_freqs(unsigned int *low_freq,\n\t\t\t\t\t\t      unsigned int *high_freq)\n{\n\tu32 msr_lo, msr_hi;\n\tu32 save_lo, save_hi;\n\tu32 eax, ebx, ecx, edx;\n\tu32 try_hi;\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\n\tif (!low_freq || !high_freq)\n\t\treturn -EINVAL;\n\n\tif (cpu_has(c, X86_FEATURE_LRTI)) {\n\t\t \n\t\t \n\t\trdmsr(MSR_TMTA_LRTI_READOUT, msr_lo, msr_hi);\n\t\twrmsr(MSR_TMTA_LRTI_READOUT, msr_hi, msr_hi);\n\t\trdmsr(MSR_TMTA_LRTI_VOLT_MHZ, msr_lo, msr_hi);\n\t\t*low_freq = msr_lo * 1000;  \n\n\t\t \n\t\twrmsr(MSR_TMTA_LRTI_READOUT, 0, msr_hi);\n\t\trdmsr(MSR_TMTA_LRTI_VOLT_MHZ, msr_lo, msr_hi);\n\t\t*high_freq = msr_lo * 1000;  \n\n\t\tpr_debug(\"longrun table interface told %u - %u kHz\\n\",\n\t\t\t\t*low_freq, *high_freq);\n\n\t\tif (*low_freq > *high_freq)\n\t\t\t*low_freq = *high_freq;\n\t\treturn 0;\n\t}\n\n\t \n\t*high_freq = (cpu_khz / 1000);\n\t*high_freq = *high_freq * 1000;\n\tpr_debug(\"high frequency is %u kHz\\n\", *high_freq);\n\n\t \n\trdmsr(MSR_TMTA_LONGRUN_CTRL, msr_lo, msr_hi);\n\tsave_lo = msr_lo & 0x0000007F;\n\tsave_hi = msr_hi & 0x0000007F;\n\n\t \n\tcpuid(0x80860007, &eax, &ebx, &ecx, &edx);\n\t \n\tfor (try_hi = 80; try_hi > 0 && ecx > 90; try_hi -= 10) {\n\t\t \n\t\tmsr_lo &= 0xFFFFFF80;\n\t\tmsr_hi &= 0xFFFFFF80;\n\t\tmsr_hi |= try_hi;\n\t\twrmsr(MSR_TMTA_LONGRUN_CTRL, msr_lo, msr_hi);\n\n\t\t \n\t\tcpuid(0x80860007, &eax, &ebx, &ecx, &edx);\n\n\t\t \n\t\twrmsr(MSR_TMTA_LONGRUN_CTRL, save_lo, save_hi);\n\t}\n\tpr_debug(\"percentage is %u %%, freq is %u MHz\\n\", ecx, eax);\n\n\t \n\tebx = (((cpu_khz / 1000) * ecx) / 100);  \n\n\tif ((ecx > 95) || (ecx == 0) || (eax < ebx))\n\t\treturn -EIO;\n\n\tedx = ((eax - ebx) * 100) / (100 - ecx);\n\t*low_freq = edx * 1000;  \n\n\tpr_debug(\"low frequency is %u kHz\\n\", *low_freq);\n\n\tif (*low_freq > *high_freq)\n\t\t*low_freq = *high_freq;\n\n\treturn 0;\n}\n\n\nstatic int longrun_cpu_init(struct cpufreq_policy *policy)\n{\n\tint result = 0;\n\n\t \n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\t \n\tresult = longrun_determine_freqs(&longrun_low_freq, &longrun_high_freq);\n\tif (result)\n\t\treturn result;\n\n\t \n\tpolicy->cpuinfo.min_freq = longrun_low_freq;\n\tpolicy->cpuinfo.max_freq = longrun_high_freq;\n\tlongrun_get_policy(policy);\n\n\treturn 0;\n}\n\n\nstatic struct cpufreq_driver longrun_driver = {\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.verify\t\t= longrun_verify_policy,\n\t.setpolicy\t= longrun_set_policy,\n\t.get\t\t= longrun_get,\n\t.init\t\t= longrun_cpu_init,\n\t.name\t\t= \"longrun\",\n};\n\nstatic const struct x86_cpu_id longrun_ids[] = {\n\tX86_MATCH_VENDOR_FEATURE(TRANSMETA, X86_FEATURE_LONGRUN, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, longrun_ids);\n\n \nstatic int __init longrun_init(void)\n{\n\tif (!x86_match_cpu(longrun_ids))\n\t\treturn -ENODEV;\n\treturn cpufreq_register_driver(&longrun_driver);\n}\n\n\n \nstatic void __exit longrun_exit(void)\n{\n\tcpufreq_unregister_driver(&longrun_driver);\n}\n\n\nMODULE_AUTHOR(\"Dominik Brodowski <linux@brodo.de>\");\nMODULE_DESCRIPTION(\"LongRun driver for Transmeta Crusoe and \"\n\t\t\"Efficeon processors.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(longrun_init);\nmodule_exit(longrun_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}