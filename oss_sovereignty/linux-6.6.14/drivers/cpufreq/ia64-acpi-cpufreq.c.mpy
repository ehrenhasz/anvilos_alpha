{
  "module_name": "ia64-acpi-cpufreq.c",
  "hash_id": "b0a42872c59f83409df67420fbeb425e25d42f0c941644a42037533aa4791638",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/ia64-acpi-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/proc_fs.h>\n#include <asm/io.h>\n#include <linux/uaccess.h>\n#include <asm/pal.h>\n\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n\nMODULE_AUTHOR(\"Venkatesh Pallipadi\");\nMODULE_DESCRIPTION(\"ACPI Processor P-States Driver\");\nMODULE_LICENSE(\"GPL\");\n\nstruct cpufreq_acpi_io {\n\tstruct acpi_processor_performance\tacpi_data;\n\tunsigned int\t\t\t\tresume;\n};\n\nstruct cpufreq_acpi_req {\n\tunsigned int\t\tcpu;\n\tunsigned int\t\tstate;\n};\n\nstatic struct cpufreq_acpi_io\t*acpi_io_data[NR_CPUS];\n\nstatic struct cpufreq_driver acpi_cpufreq_driver;\n\n\nstatic int\nprocessor_set_pstate (\n\tu32\tvalue)\n{\n\ts64 retval;\n\n\tpr_debug(\"processor_set_pstate\\n\");\n\n\tretval = ia64_pal_set_pstate((u64)value);\n\n\tif (retval) {\n\t\tpr_debug(\"Failed to set freq to 0x%x, with error 0x%llx\\n\",\n\t\t        value, retval);\n\t\treturn -ENODEV;\n\t}\n\treturn (int)retval;\n}\n\n\nstatic int\nprocessor_get_pstate (\n\tu32\t*value)\n{\n\tu64\tpstate_index = 0;\n\ts64 \tretval;\n\n\tpr_debug(\"processor_get_pstate\\n\");\n\n\tretval = ia64_pal_get_pstate(&pstate_index,\n\t                             PAL_GET_PSTATE_TYPE_INSTANT);\n\t*value = (u32) pstate_index;\n\n\tif (retval)\n\t\tpr_debug(\"Failed to get current freq with \"\n\t\t\t\"error 0x%llx, idx 0x%x\\n\", retval, *value);\n\n\treturn (int)retval;\n}\n\n\n \nstatic unsigned\nextract_clock (\n\tstruct cpufreq_acpi_io *data,\n\tunsigned value)\n{\n\tunsigned long i;\n\n\tpr_debug(\"extract_clock\\n\");\n\n\tfor (i = 0; i < data->acpi_data.state_count; i++) {\n\t\tif (value == data->acpi_data.states[i].status)\n\t\t\treturn data->acpi_data.states[i].core_frequency;\n\t}\n\treturn data->acpi_data.states[i-1].core_frequency;\n}\n\n\nstatic long\nprocessor_get_freq (\n\tvoid *arg)\n{\n\tstruct cpufreq_acpi_req *req = arg;\n\tunsigned int\t\tcpu = req->cpu;\n\tstruct cpufreq_acpi_io\t*data = acpi_io_data[cpu];\n\tu32\t\t\tvalue;\n\tint\t\t\tret;\n\n\tpr_debug(\"processor_get_freq\\n\");\n\tif (smp_processor_id() != cpu)\n\t\treturn -EAGAIN;\n\n\t \n\tret = processor_get_pstate(&value);\n\tif (ret) {\n\t\tpr_warn(\"get performance failed with error %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 1000 * extract_clock(data, value);\n}\n\n\nstatic long\nprocessor_set_freq (\n\tvoid *arg)\n{\n\tstruct cpufreq_acpi_req *req = arg;\n\tunsigned int\t\tcpu = req->cpu;\n\tstruct cpufreq_acpi_io\t*data = acpi_io_data[cpu];\n\tint\t\t\tret, state = req->state;\n\tu32\t\t\tvalue;\n\n\tpr_debug(\"processor_set_freq\\n\");\n\tif (smp_processor_id() != cpu)\n\t\treturn -EAGAIN;\n\n\tif (state == data->acpi_data.state) {\n\t\tif (unlikely(data->resume)) {\n\t\t\tpr_debug(\"Called after resume, resetting to P%d\\n\", state);\n\t\t\tdata->resume = 0;\n\t\t} else {\n\t\t\tpr_debug(\"Already at target state (P%d)\\n\", state);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpr_debug(\"Transitioning from P%d to P%d\\n\",\n\t\tdata->acpi_data.state, state);\n\n\t \n\tvalue = (u32) data->acpi_data.states[state].control;\n\n\tpr_debug(\"Transitioning to state: 0x%08x\\n\", value);\n\n\tret = processor_set_pstate(value);\n\tif (ret) {\n\t\tpr_warn(\"Transition failed with error %d\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\n\tdata->acpi_data.state = state;\n\treturn 0;\n}\n\n\nstatic unsigned int\nacpi_cpufreq_get (\n\tunsigned int\t\tcpu)\n{\n\tstruct cpufreq_acpi_req req;\n\tlong ret;\n\n\treq.cpu = cpu;\n\tret = work_on_cpu(cpu, processor_get_freq, &req);\n\n\treturn ret > 0 ? (unsigned int) ret : 0;\n}\n\n\nstatic int\nacpi_cpufreq_target (\n\tstruct cpufreq_policy   *policy,\n\tunsigned int index)\n{\n\tstruct cpufreq_acpi_req req;\n\n\treq.cpu = policy->cpu;\n\treq.state = index;\n\n\treturn work_on_cpu(req.cpu, processor_set_freq, &req);\n}\n\nstatic int\nacpi_cpufreq_cpu_init (\n\tstruct cpufreq_policy   *policy)\n{\n\tunsigned int\t\ti;\n\tunsigned int\t\tcpu = policy->cpu;\n\tstruct cpufreq_acpi_io\t*data;\n\tunsigned int\t\tresult = 0;\n\tstruct cpufreq_frequency_table *freq_table;\n\n\tpr_debug(\"acpi_cpufreq_cpu_init\\n\");\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn (-ENOMEM);\n\n\tacpi_io_data[cpu] = data;\n\n\tresult = acpi_processor_register_performance(&data->acpi_data, cpu);\n\n\tif (result)\n\t\tgoto err_free;\n\n\t \n\tif (data->acpi_data.state_count <= 1) {\n\t\tpr_debug(\"No P-States\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto err_unreg;\n\t}\n\n\tif ((data->acpi_data.control_register.space_id !=\n\t\t\t\t\tACPI_ADR_SPACE_FIXED_HARDWARE) ||\n\t    (data->acpi_data.status_register.space_id !=\n\t\t\t\t\tACPI_ADR_SPACE_FIXED_HARDWARE)) {\n\t\tpr_debug(\"Unsupported address space [%d, %d]\\n\",\n\t\t\t(u32) (data->acpi_data.control_register.space_id),\n\t\t\t(u32) (data->acpi_data.status_register.space_id));\n\t\tresult = -ENODEV;\n\t\tgoto err_unreg;\n\t}\n\n\t \n\tfreq_table = kcalloc(data->acpi_data.state_count + 1,\n\t                           sizeof(*freq_table),\n\t                           GFP_KERNEL);\n\tif (!freq_table) {\n\t\tresult = -ENOMEM;\n\t\tgoto err_unreg;\n\t}\n\n\t \n\tpolicy->cpuinfo.transition_latency = 0;\n\tfor (i=0; i<data->acpi_data.state_count; i++) {\n\t\tif ((data->acpi_data.states[i].transition_latency * 1000) >\n\t\t    policy->cpuinfo.transition_latency) {\n\t\t\tpolicy->cpuinfo.transition_latency =\n\t\t\t    data->acpi_data.states[i].transition_latency * 1000;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i <= data->acpi_data.state_count; i++)\n\t{\n\t\tif (i < data->acpi_data.state_count) {\n\t\t\tfreq_table[i].frequency =\n\t\t\t      data->acpi_data.states[i].core_frequency * 1000;\n\t\t} else {\n\t\t\tfreq_table[i].frequency = CPUFREQ_TABLE_END;\n\t\t}\n\t}\n\n\tpolicy->freq_table = freq_table;\n\n\t \n\tacpi_processor_notify_smm(THIS_MODULE);\n\n\tpr_info(\"CPU%u - ACPI performance management activated\\n\", cpu);\n\n\tfor (i = 0; i < data->acpi_data.state_count; i++)\n\t\tpr_debug(\"     %cP%d: %d MHz, %d mW, %d uS, %d uS, 0x%x 0x%x\\n\",\n\t\t\t(i == data->acpi_data.state?'*':' '), i,\n\t\t\t(u32) data->acpi_data.states[i].core_frequency,\n\t\t\t(u32) data->acpi_data.states[i].power,\n\t\t\t(u32) data->acpi_data.states[i].transition_latency,\n\t\t\t(u32) data->acpi_data.states[i].bus_master_latency,\n\t\t\t(u32) data->acpi_data.states[i].status,\n\t\t\t(u32) data->acpi_data.states[i].control);\n\n\t \n\tdata->resume = 1;\n\n\treturn (result);\n\n err_unreg:\n\tacpi_processor_unregister_performance(cpu);\n err_free:\n\tkfree(data);\n\tacpi_io_data[cpu] = NULL;\n\n\treturn (result);\n}\n\n\nstatic int\nacpi_cpufreq_cpu_exit (\n\tstruct cpufreq_policy   *policy)\n{\n\tstruct cpufreq_acpi_io *data = acpi_io_data[policy->cpu];\n\n\tpr_debug(\"acpi_cpufreq_cpu_exit\\n\");\n\n\tif (data) {\n\t\tacpi_io_data[policy->cpu] = NULL;\n\t\tacpi_processor_unregister_performance(policy->cpu);\n\t\tkfree(policy->freq_table);\n\t\tkfree(data);\n\t}\n\n\treturn (0);\n}\n\n\nstatic struct cpufreq_driver acpi_cpufreq_driver = {\n\t.verify \t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= acpi_cpufreq_target,\n\t.get \t\t= acpi_cpufreq_get,\n\t.init\t\t= acpi_cpufreq_cpu_init,\n\t.exit\t\t= acpi_cpufreq_cpu_exit,\n\t.name\t\t= \"acpi-cpufreq\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\n\nstatic int __init\nacpi_cpufreq_init (void)\n{\n\tpr_debug(\"acpi_cpufreq_init\\n\");\n\n \treturn cpufreq_register_driver(&acpi_cpufreq_driver);\n}\n\n\nstatic void __exit\nacpi_cpufreq_exit (void)\n{\n\tpr_debug(\"acpi_cpufreq_exit\\n\");\n\n\tcpufreq_unregister_driver(&acpi_cpufreq_driver);\n}\n\nlate_initcall(acpi_cpufreq_init);\nmodule_exit(acpi_cpufreq_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}