{
  "module_name": "mediatek-cpufreq.c",
  "hash_id": "4123149082a6f43c5297c57f62fa9e806812776243cae245be7ed0b2f7f8ff52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/mediatek-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/minmax.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regulator/consumer.h>\n\nstruct mtk_cpufreq_platform_data {\n\tint min_volt_shift;\n\tint max_volt_shift;\n\tint proc_max_volt;\n\tint sram_min_volt;\n\tint sram_max_volt;\n\tbool ccifreq_supported;\n};\n\n \nstruct mtk_cpu_dvfs_info {\n\tstruct cpumask cpus;\n\tstruct device *cpu_dev;\n\tstruct device *cci_dev;\n\tstruct regulator *proc_reg;\n\tstruct regulator *sram_reg;\n\tstruct clk *cpu_clk;\n\tstruct clk *inter_clk;\n\tstruct list_head list_head;\n\tint intermediate_voltage;\n\tbool need_voltage_tracking;\n\tint vproc_on_boot;\n\tint pre_vproc;\n\t \n\tstruct mutex reg_lock;\n\tstruct notifier_block opp_nb;\n\tunsigned int opp_cpu;\n\tunsigned long current_freq;\n\tconst struct mtk_cpufreq_platform_data *soc_data;\n\tint vtrack_max;\n\tbool ccifreq_bound;\n};\n\nstatic struct platform_device *cpufreq_pdev;\n\nstatic LIST_HEAD(dvfs_info_list);\n\nstatic struct mtk_cpu_dvfs_info *mtk_cpu_dvfs_info_lookup(int cpu)\n{\n\tstruct mtk_cpu_dvfs_info *info;\n\n\tlist_for_each_entry(info, &dvfs_info_list, list_head) {\n\t\tif (cpumask_test_cpu(cpu, &info->cpus))\n\t\t\treturn info;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mtk_cpufreq_voltage_tracking(struct mtk_cpu_dvfs_info *info,\n\t\t\t\t\tint new_vproc)\n{\n\tconst struct mtk_cpufreq_platform_data *soc_data = info->soc_data;\n\tstruct regulator *proc_reg = info->proc_reg;\n\tstruct regulator *sram_reg = info->sram_reg;\n\tint pre_vproc, pre_vsram, new_vsram, vsram, vproc, ret;\n\tint retry = info->vtrack_max;\n\n\tpre_vproc = regulator_get_voltage(proc_reg);\n\tif (pre_vproc < 0) {\n\t\tdev_err(info->cpu_dev,\n\t\t\t\"invalid Vproc value: %d\\n\", pre_vproc);\n\t\treturn pre_vproc;\n\t}\n\n\tpre_vsram = regulator_get_voltage(sram_reg);\n\tif (pre_vsram < 0) {\n\t\tdev_err(info->cpu_dev, \"invalid Vsram value: %d\\n\", pre_vsram);\n\t\treturn pre_vsram;\n\t}\n\n\tnew_vsram = clamp(new_vproc + soc_data->min_volt_shift,\n\t\t\t  soc_data->sram_min_volt, soc_data->sram_max_volt);\n\n\tdo {\n\t\tif (pre_vproc <= new_vproc) {\n\t\t\tvsram = clamp(pre_vproc + soc_data->max_volt_shift,\n\t\t\t\t      soc_data->sram_min_volt, new_vsram);\n\t\t\tret = regulator_set_voltage(sram_reg, vsram,\n\t\t\t\t\t\t    soc_data->sram_max_volt);\n\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (vsram == soc_data->sram_max_volt ||\n\t\t\t    new_vsram == soc_data->sram_min_volt)\n\t\t\t\tvproc = new_vproc;\n\t\t\telse\n\t\t\t\tvproc = vsram - soc_data->min_volt_shift;\n\n\t\t\tret = regulator_set_voltage(proc_reg, vproc,\n\t\t\t\t\t\t    soc_data->proc_max_volt);\n\t\t\tif (ret) {\n\t\t\t\tregulator_set_voltage(sram_reg, pre_vsram,\n\t\t\t\t\t\t      soc_data->sram_max_volt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else if (pre_vproc > new_vproc) {\n\t\t\tvproc = max(new_vproc,\n\t\t\t\t    pre_vsram - soc_data->max_volt_shift);\n\t\t\tret = regulator_set_voltage(proc_reg, vproc,\n\t\t\t\t\t\t    soc_data->proc_max_volt);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tif (vproc == new_vproc)\n\t\t\t\tvsram = new_vsram;\n\t\t\telse\n\t\t\t\tvsram = max(new_vsram,\n\t\t\t\t\t    vproc + soc_data->min_volt_shift);\n\n\t\t\tret = regulator_set_voltage(sram_reg, vsram,\n\t\t\t\t\t\t    soc_data->sram_max_volt);\n\t\t\tif (ret) {\n\t\t\t\tregulator_set_voltage(proc_reg, pre_vproc,\n\t\t\t\t\t\t      soc_data->proc_max_volt);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tpre_vproc = vproc;\n\t\tpre_vsram = vsram;\n\n\t\tif (--retry < 0) {\n\t\t\tdev_err(info->cpu_dev,\n\t\t\t\t\"over loop count, failed to set voltage\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (vproc != new_vproc || vsram != new_vsram);\n\n\treturn 0;\n}\n\nstatic int mtk_cpufreq_set_voltage(struct mtk_cpu_dvfs_info *info, int vproc)\n{\n\tconst struct mtk_cpufreq_platform_data *soc_data = info->soc_data;\n\tint ret;\n\n\tif (info->need_voltage_tracking)\n\t\tret = mtk_cpufreq_voltage_tracking(info, vproc);\n\telse\n\t\tret = regulator_set_voltage(info->proc_reg, vproc,\n\t\t\t\t\t    soc_data->proc_max_volt);\n\tif (!ret)\n\t\tinfo->pre_vproc = vproc;\n\n\treturn ret;\n}\n\nstatic bool is_ccifreq_ready(struct mtk_cpu_dvfs_info *info)\n{\n\tstruct device_link *sup_link;\n\n\tif (info->ccifreq_bound)\n\t\treturn true;\n\n\tsup_link = device_link_add(info->cpu_dev, info->cci_dev,\n\t\t\t\t   DL_FLAG_AUTOREMOVE_CONSUMER);\n\tif (!sup_link) {\n\t\tdev_err(info->cpu_dev, \"cpu%d: sup_link is NULL\\n\", info->opp_cpu);\n\t\treturn false;\n\t}\n\n\tif (sup_link->supplier->links.status != DL_DEV_DRIVER_BOUND)\n\t\treturn false;\n\n\tinfo->ccifreq_bound = true;\n\n\treturn true;\n}\n\nstatic int mtk_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t  unsigned int index)\n{\n\tstruct cpufreq_frequency_table *freq_table = policy->freq_table;\n\tstruct clk *cpu_clk = policy->clk;\n\tstruct clk *armpll = clk_get_parent(cpu_clk);\n\tstruct mtk_cpu_dvfs_info *info = policy->driver_data;\n\tstruct device *cpu_dev = info->cpu_dev;\n\tstruct dev_pm_opp *opp;\n\tlong freq_hz, pre_freq_hz;\n\tint vproc, pre_vproc, inter_vproc, target_vproc, ret;\n\n\tinter_vproc = info->intermediate_voltage;\n\n\tpre_freq_hz = clk_get_rate(cpu_clk);\n\n\tmutex_lock(&info->reg_lock);\n\n\tif (unlikely(info->pre_vproc <= 0))\n\t\tpre_vproc = regulator_get_voltage(info->proc_reg);\n\telse\n\t\tpre_vproc = info->pre_vproc;\n\n\tif (pre_vproc < 0) {\n\t\tdev_err(cpu_dev, \"invalid Vproc value: %d\\n\", pre_vproc);\n\t\tret = pre_vproc;\n\t\tgoto out;\n\t}\n\n\tfreq_hz = freq_table[index].frequency * 1000;\n\n\topp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(cpu_dev, \"cpu%d: failed to find OPP for %ld\\n\",\n\t\t\tpolicy->cpu, freq_hz);\n\t\tret = PTR_ERR(opp);\n\t\tgoto out;\n\t}\n\tvproc = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\t \n\tif (info->soc_data->ccifreq_supported && !is_ccifreq_ready(info))\n\t\tvproc = max(vproc, info->vproc_on_boot);\n\n\t \n\ttarget_vproc = max(inter_vproc, vproc);\n\tif (pre_vproc <= target_vproc) {\n\t\tret = mtk_cpufreq_set_voltage(info, target_vproc);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dev,\n\t\t\t\t\"cpu%d: failed to scale up voltage!\\n\", policy->cpu);\n\t\t\tmtk_cpufreq_set_voltage(info, pre_vproc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tret = clk_set_parent(cpu_clk, info->inter_clk);\n\tif (ret) {\n\t\tdev_err(cpu_dev,\n\t\t\t\"cpu%d: failed to re-parent cpu clock!\\n\", policy->cpu);\n\t\tmtk_cpufreq_set_voltage(info, pre_vproc);\n\t\tgoto out;\n\t}\n\n\t \n\tret = clk_set_rate(armpll, freq_hz);\n\tif (ret) {\n\t\tdev_err(cpu_dev,\n\t\t\t\"cpu%d: failed to scale cpu clock rate!\\n\", policy->cpu);\n\t\tclk_set_parent(cpu_clk, armpll);\n\t\tmtk_cpufreq_set_voltage(info, pre_vproc);\n\t\tgoto out;\n\t}\n\n\t \n\tret = clk_set_parent(cpu_clk, armpll);\n\tif (ret) {\n\t\tdev_err(cpu_dev,\n\t\t\t\"cpu%d: failed to re-parent cpu clock!\\n\", policy->cpu);\n\t\tmtk_cpufreq_set_voltage(info, inter_vproc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (vproc < inter_vproc || vproc < pre_vproc) {\n\t\tret = mtk_cpufreq_set_voltage(info, vproc);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dev,\n\t\t\t\t\"cpu%d: failed to scale down voltage!\\n\", policy->cpu);\n\t\t\tclk_set_parent(cpu_clk, info->inter_clk);\n\t\t\tclk_set_rate(armpll, pre_freq_hz);\n\t\t\tclk_set_parent(cpu_clk, armpll);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tinfo->current_freq = freq_hz;\n\nout:\n\tmutex_unlock(&info->reg_lock);\n\n\treturn ret;\n}\n\nstatic int mtk_cpufreq_opp_notifier(struct notifier_block *nb,\n\t\t\t\t    unsigned long event, void *data)\n{\n\tstruct dev_pm_opp *opp = data;\n\tstruct dev_pm_opp *new_opp;\n\tstruct mtk_cpu_dvfs_info *info;\n\tunsigned long freq, volt;\n\tstruct cpufreq_policy *policy;\n\tint ret = 0;\n\n\tinfo = container_of(nb, struct mtk_cpu_dvfs_info, opp_nb);\n\n\tif (event == OPP_EVENT_ADJUST_VOLTAGE) {\n\t\tfreq = dev_pm_opp_get_freq(opp);\n\n\t\tmutex_lock(&info->reg_lock);\n\t\tif (info->current_freq == freq) {\n\t\t\tvolt = dev_pm_opp_get_voltage(opp);\n\t\t\tret = mtk_cpufreq_set_voltage(info, volt);\n\t\t\tif (ret)\n\t\t\t\tdev_err(info->cpu_dev,\n\t\t\t\t\t\"failed to scale voltage: %d\\n\", ret);\n\t\t}\n\t\tmutex_unlock(&info->reg_lock);\n\t} else if (event == OPP_EVENT_DISABLE) {\n\t\tfreq = dev_pm_opp_get_freq(opp);\n\n\t\t \n\t\tif (info->current_freq == freq) {\n\t\t\tfreq = 1;\n\t\t\tnew_opp = dev_pm_opp_find_freq_ceil(info->cpu_dev,\n\t\t\t\t\t\t\t    &freq);\n\t\t\tif (IS_ERR(new_opp)) {\n\t\t\t\tdev_err(info->cpu_dev,\n\t\t\t\t\t\"all opp items are disabled\\n\");\n\t\t\t\tret = PTR_ERR(new_opp);\n\t\t\t\treturn notifier_from_errno(ret);\n\t\t\t}\n\n\t\t\tdev_pm_opp_put(new_opp);\n\t\t\tpolicy = cpufreq_cpu_get(info->opp_cpu);\n\t\t\tif (policy) {\n\t\t\t\tcpufreq_driver_target(policy, freq / 1000,\n\t\t\t\t\t\t      CPUFREQ_RELATION_L);\n\t\t\t\tcpufreq_cpu_put(policy);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn notifier_from_errno(ret);\n}\n\nstatic struct device *of_get_cci(struct device *cpu_dev)\n{\n\tstruct device_node *np;\n\tstruct platform_device *pdev;\n\n\tnp = of_parse_phandle(cpu_dev->of_node, \"mediatek,cci\", 0);\n\tif (!np)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tpdev = of_find_device_by_node(np);\n\tof_node_put(np);\n\tif (!pdev)\n\t\treturn ERR_PTR(-ENODEV);\n\n\treturn &pdev->dev;\n}\n\nstatic int mtk_cpu_dvfs_info_init(struct mtk_cpu_dvfs_info *info, int cpu)\n{\n\tstruct device *cpu_dev;\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate;\n\tint ret;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev) {\n\t\tdev_err(cpu_dev, \"failed to get cpu%d device\\n\", cpu);\n\t\treturn -ENODEV;\n\t}\n\tinfo->cpu_dev = cpu_dev;\n\n\tinfo->ccifreq_bound = false;\n\tif (info->soc_data->ccifreq_supported) {\n\t\tinfo->cci_dev = of_get_cci(info->cpu_dev);\n\t\tif (IS_ERR(info->cci_dev)) {\n\t\t\tret = PTR_ERR(info->cci_dev);\n\t\t\tdev_err(cpu_dev, \"cpu%d: failed to get cci device\\n\", cpu);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tinfo->cpu_clk = clk_get(cpu_dev, \"cpu\");\n\tif (IS_ERR(info->cpu_clk)) {\n\t\tret = PTR_ERR(info->cpu_clk);\n\t\treturn dev_err_probe(cpu_dev, ret,\n\t\t\t\t     \"cpu%d: failed to get cpu clk\\n\", cpu);\n\t}\n\n\tinfo->inter_clk = clk_get(cpu_dev, \"intermediate\");\n\tif (IS_ERR(info->inter_clk)) {\n\t\tret = PTR_ERR(info->inter_clk);\n\t\tdev_err_probe(cpu_dev, ret,\n\t\t\t      \"cpu%d: failed to get intermediate clk\\n\", cpu);\n\t\tgoto out_free_mux_clock;\n\t}\n\n\tinfo->proc_reg = regulator_get_optional(cpu_dev, \"proc\");\n\tif (IS_ERR(info->proc_reg)) {\n\t\tret = PTR_ERR(info->proc_reg);\n\t\tdev_err_probe(cpu_dev, ret,\n\t\t\t      \"cpu%d: failed to get proc regulator\\n\", cpu);\n\t\tgoto out_free_inter_clock;\n\t}\n\n\tret = regulator_enable(info->proc_reg);\n\tif (ret) {\n\t\tdev_warn(cpu_dev, \"cpu%d: failed to enable vproc\\n\", cpu);\n\t\tgoto out_free_proc_reg;\n\t}\n\n\t \n\tinfo->sram_reg = regulator_get_optional(cpu_dev, \"sram\");\n\tif (IS_ERR(info->sram_reg)) {\n\t\tret = PTR_ERR(info->sram_reg);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto out_disable_proc_reg;\n\n\t\tinfo->sram_reg = NULL;\n\t} else {\n\t\tret = regulator_enable(info->sram_reg);\n\t\tif (ret) {\n\t\t\tdev_warn(cpu_dev, \"cpu%d: failed to enable vsram\\n\", cpu);\n\t\t\tgoto out_free_sram_reg;\n\t\t}\n\t}\n\n\t \n\tret = dev_pm_opp_of_get_sharing_cpus(cpu_dev, &info->cpus);\n\tif (ret) {\n\t\tdev_err(cpu_dev,\n\t\t\t\"cpu%d: failed to get OPP-sharing information\\n\", cpu);\n\t\tgoto out_disable_sram_reg;\n\t}\n\n\tret = dev_pm_opp_of_cpumask_add_table(&info->cpus);\n\tif (ret) {\n\t\tdev_warn(cpu_dev, \"cpu%d: no OPP table\\n\", cpu);\n\t\tgoto out_disable_sram_reg;\n\t}\n\n\tret = clk_prepare_enable(info->cpu_clk);\n\tif (ret)\n\t\tgoto out_free_opp_table;\n\n\tret = clk_prepare_enable(info->inter_clk);\n\tif (ret)\n\t\tgoto out_disable_mux_clock;\n\n\tif (info->soc_data->ccifreq_supported) {\n\t\tinfo->vproc_on_boot = regulator_get_voltage(info->proc_reg);\n\t\tif (info->vproc_on_boot < 0) {\n\t\t\tret = info->vproc_on_boot;\n\t\t\tdev_err(info->cpu_dev,\n\t\t\t\t\"invalid Vproc value: %d\\n\", info->vproc_on_boot);\n\t\t\tgoto out_disable_inter_clock;\n\t\t}\n\t}\n\n\t \n\trate = clk_get_rate(info->inter_clk);\n\topp = dev_pm_opp_find_freq_ceil(cpu_dev, &rate);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(cpu_dev, \"cpu%d: failed to get intermediate opp\\n\", cpu);\n\t\tret = PTR_ERR(opp);\n\t\tgoto out_disable_inter_clock;\n\t}\n\tinfo->intermediate_voltage = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tmutex_init(&info->reg_lock);\n\tinfo->current_freq = clk_get_rate(info->cpu_clk);\n\n\tinfo->opp_cpu = cpu;\n\tinfo->opp_nb.notifier_call = mtk_cpufreq_opp_notifier;\n\tret = dev_pm_opp_register_notifier(cpu_dev, &info->opp_nb);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"cpu%d: failed to register opp notifier\\n\", cpu);\n\t\tgoto out_disable_inter_clock;\n\t}\n\n\t \n\tinfo->need_voltage_tracking = (info->sram_reg != NULL);\n\n\t \n\tinfo->vtrack_max = 3 * DIV_ROUND_UP(max(info->soc_data->sram_max_volt,\n\t\t\t\t\t\tinfo->soc_data->proc_max_volt),\n\t\t\t\t\t    info->soc_data->min_volt_shift);\n\n\treturn 0;\n\nout_disable_inter_clock:\n\tclk_disable_unprepare(info->inter_clk);\n\nout_disable_mux_clock:\n\tclk_disable_unprepare(info->cpu_clk);\n\nout_free_opp_table:\n\tdev_pm_opp_of_cpumask_remove_table(&info->cpus);\n\nout_disable_sram_reg:\n\tif (info->sram_reg)\n\t\tregulator_disable(info->sram_reg);\n\nout_free_sram_reg:\n\tif (info->sram_reg)\n\t\tregulator_put(info->sram_reg);\n\nout_disable_proc_reg:\n\tregulator_disable(info->proc_reg);\n\nout_free_proc_reg:\n\tregulator_put(info->proc_reg);\n\nout_free_inter_clock:\n\tclk_put(info->inter_clk);\n\nout_free_mux_clock:\n\tclk_put(info->cpu_clk);\n\n\treturn ret;\n}\n\nstatic void mtk_cpu_dvfs_info_release(struct mtk_cpu_dvfs_info *info)\n{\n\tregulator_disable(info->proc_reg);\n\tregulator_put(info->proc_reg);\n\tif (info->sram_reg) {\n\t\tregulator_disable(info->sram_reg);\n\t\tregulator_put(info->sram_reg);\n\t}\n\tclk_disable_unprepare(info->cpu_clk);\n\tclk_put(info->cpu_clk);\n\tclk_disable_unprepare(info->inter_clk);\n\tclk_put(info->inter_clk);\n\tdev_pm_opp_of_cpumask_remove_table(&info->cpus);\n\tdev_pm_opp_unregister_notifier(info->cpu_dev, &info->opp_nb);\n}\n\nstatic int mtk_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tstruct mtk_cpu_dvfs_info *info;\n\tstruct cpufreq_frequency_table *freq_table;\n\tint ret;\n\n\tinfo = mtk_cpu_dvfs_info_lookup(policy->cpu);\n\tif (!info) {\n\t\tpr_err(\"dvfs info for cpu%d is not initialized.\\n\",\n\t\t\tpolicy->cpu);\n\t\treturn -EINVAL;\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(info->cpu_dev, &freq_table);\n\tif (ret) {\n\t\tdev_err(info->cpu_dev,\n\t\t\t\"failed to init cpufreq table for cpu%d: %d\\n\",\n\t\t\tpolicy->cpu, ret);\n\t\treturn ret;\n\t}\n\n\tcpumask_copy(policy->cpus, &info->cpus);\n\tpolicy->freq_table = freq_table;\n\tpolicy->driver_data = info;\n\tpolicy->clk = info->cpu_clk;\n\n\treturn 0;\n}\n\nstatic int mtk_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct mtk_cpu_dvfs_info *info = policy->driver_data;\n\n\tdev_pm_opp_free_cpufreq_table(info->cpu_dev, &policy->freq_table);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver mtk_cpufreq_driver = {\n\t.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t CPUFREQ_IS_COOLING_DEV,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = mtk_cpufreq_set_target,\n\t.get = cpufreq_generic_get,\n\t.init = mtk_cpufreq_init,\n\t.exit = mtk_cpufreq_exit,\n\t.register_em = cpufreq_register_em_with_opp,\n\t.name = \"mtk-cpufreq\",\n\t.attr = cpufreq_generic_attr,\n};\n\nstatic int mtk_cpufreq_probe(struct platform_device *pdev)\n{\n\tconst struct mtk_cpufreq_platform_data *data;\n\tstruct mtk_cpu_dvfs_info *info, *tmp;\n\tint cpu, ret;\n\n\tdata = dev_get_platdata(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"failed to get mtk cpufreq platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tinfo = mtk_cpu_dvfs_info_lookup(cpu);\n\t\tif (info)\n\t\t\tcontinue;\n\n\t\tinfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto release_dvfs_info_list;\n\t\t}\n\n\t\tinfo->soc_data = data;\n\t\tret = mtk_cpu_dvfs_info_init(info, cpu);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to initialize dvfs info for cpu%d\\n\",\n\t\t\t\tcpu);\n\t\t\tgoto release_dvfs_info_list;\n\t\t}\n\n\t\tlist_add(&info->list_head, &dvfs_info_list);\n\t}\n\n\tret = cpufreq_register_driver(&mtk_cpufreq_driver);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register mtk cpufreq driver\\n\");\n\t\tgoto release_dvfs_info_list;\n\t}\n\n\treturn 0;\n\nrelease_dvfs_info_list:\n\tlist_for_each_entry_safe(info, tmp, &dvfs_info_list, list_head) {\n\t\tmtk_cpu_dvfs_info_release(info);\n\t\tlist_del(&info->list_head);\n\t}\n\n\treturn ret;\n}\n\nstatic struct platform_driver mtk_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"mtk-cpufreq\",\n\t},\n\t.probe\t\t= mtk_cpufreq_probe,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt2701_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1150000,\n\t.sram_min_volt = 0,\n\t.sram_max_volt = 1150000,\n\t.ccifreq_supported = false,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt7622_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1350000,\n\t.sram_min_volt = 0,\n\t.sram_max_volt = 1350000,\n\t.ccifreq_supported = false,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt7623_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1300000,\n\t.ccifreq_supported = false,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt8183_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1150000,\n\t.sram_min_volt = 0,\n\t.sram_max_volt = 1150000,\n\t.ccifreq_supported = true,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt8186_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 250000,\n\t.proc_max_volt = 1118750,\n\t.sram_min_volt = 850000,\n\t.sram_max_volt = 1118750,\n\t.ccifreq_supported = true,\n};\n\nstatic const struct mtk_cpufreq_platform_data mt8516_platform_data = {\n\t.min_volt_shift = 100000,\n\t.max_volt_shift = 200000,\n\t.proc_max_volt = 1310000,\n\t.sram_min_volt = 0,\n\t.sram_max_volt = 1310000,\n\t.ccifreq_supported = false,\n};\n\n \nstatic const struct of_device_id mtk_cpufreq_machines[] __initconst = {\n\t{ .compatible = \"mediatek,mt2701\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt2712\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt7622\", .data = &mt7622_platform_data },\n\t{ .compatible = \"mediatek,mt7623\", .data = &mt7623_platform_data },\n\t{ .compatible = \"mediatek,mt8167\", .data = &mt8516_platform_data },\n\t{ .compatible = \"mediatek,mt817x\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt8173\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt8176\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt8183\", .data = &mt8183_platform_data },\n\t{ .compatible = \"mediatek,mt8186\", .data = &mt8186_platform_data },\n\t{ .compatible = \"mediatek,mt8365\", .data = &mt2701_platform_data },\n\t{ .compatible = \"mediatek,mt8516\", .data = &mt8516_platform_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mtk_cpufreq_machines);\n\nstatic int __init mtk_cpufreq_driver_init(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\tconst struct mtk_cpufreq_platform_data *data;\n\tint err;\n\n\tnp = of_find_node_by_path(\"/\");\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tmatch = of_match_node(mtk_cpufreq_machines, np);\n\tof_node_put(np);\n\tif (!match) {\n\t\tpr_debug(\"Machine is not compatible with mtk-cpufreq\\n\");\n\t\treturn -ENODEV;\n\t}\n\tdata = match->data;\n\n\terr = platform_driver_register(&mtk_cpufreq_platdrv);\n\tif (err)\n\t\treturn err;\n\n\t \n\tcpufreq_pdev = platform_device_register_data(NULL, \"mtk-cpufreq\", -1,\n\t\t\t\t\t\t     data, sizeof(*data));\n\tif (IS_ERR(cpufreq_pdev)) {\n\t\tpr_err(\"failed to register mtk-cpufreq platform device\\n\");\n\t\tplatform_driver_unregister(&mtk_cpufreq_platdrv);\n\t\treturn PTR_ERR(cpufreq_pdev);\n\t}\n\n\treturn 0;\n}\nmodule_init(mtk_cpufreq_driver_init)\n\nstatic void __exit mtk_cpufreq_driver_exit(void)\n{\n\tplatform_device_unregister(cpufreq_pdev);\n\tplatform_driver_unregister(&mtk_cpufreq_platdrv);\n}\nmodule_exit(mtk_cpufreq_driver_exit)\n\nMODULE_DESCRIPTION(\"MediaTek CPUFreq driver\");\nMODULE_AUTHOR(\"Pi-Cheng Chen <pi-cheng.chen@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}