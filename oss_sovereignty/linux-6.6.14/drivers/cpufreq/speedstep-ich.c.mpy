{
  "module_name": "speedstep-ich.c",
  "hash_id": "6c87736eba4c0a24448303ddaac6ebbfa8e3be8023c8c98b4b7d1fbfa33ac8b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/speedstep-ich.c",
  "human_readable_source": "\n \n\n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/pci.h>\n#include <linux/sched.h>\n\n#include <asm/cpu_device_id.h>\n\n#include \"speedstep-lib.h\"\n\n\n \nstatic struct pci_dev *speedstep_chipset_dev;\n\n\n \nstatic enum speedstep_processor speedstep_processor;\n\nstatic u32 pmbase;\n\n \nstatic struct cpufreq_frequency_table speedstep_freqs[] = {\n\t{0, SPEEDSTEP_HIGH,\t0},\n\t{0, SPEEDSTEP_LOW,\t0},\n\t{0, 0,\t\t\tCPUFREQ_TABLE_END},\n};\n\n\n \nstatic int speedstep_find_register(void)\n{\n\tif (!speedstep_chipset_dev)\n\t\treturn -ENODEV;\n\n\t \n\tpci_read_config_dword(speedstep_chipset_dev, 0x40, &pmbase);\n\tif (!(pmbase & 0x01)) {\n\t\tpr_err(\"could not find speedstep register\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpmbase &= 0xFFFFFFFE;\n\tif (!pmbase) {\n\t\tpr_err(\"could not find speedstep register\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"pmbase is 0x%x\\n\", pmbase);\n\treturn 0;\n}\n\n \nstatic void speedstep_set_state(unsigned int state)\n{\n\tu8 pm2_blk;\n\tu8 value;\n\tunsigned long flags;\n\n\tif (state > 0x1)\n\t\treturn;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tvalue = inb(pmbase + 0x50);\n\n\tpr_debug(\"read at pmbase 0x%x + 0x50 returned 0x%x\\n\", pmbase, value);\n\n\t \n\tvalue &= 0xFE;\n\tvalue |= state;\n\n\tpr_debug(\"writing 0x%x to pmbase 0x%x + 0x50\\n\", value, pmbase);\n\n\t \n\tpm2_blk = inb(pmbase + 0x20);\n\tpm2_blk |= 0x01;\n\toutb(pm2_blk, (pmbase + 0x20));\n\n\t \n\toutb(value, (pmbase + 0x50));\n\n\t \n\tpm2_blk &= 0xfe;\n\toutb(pm2_blk, (pmbase + 0x20));\n\n\t \n\tvalue = inb(pmbase + 0x50);\n\n\t \n\tlocal_irq_restore(flags);\n\n\tpr_debug(\"read at pmbase 0x%x + 0x50 returned 0x%x\\n\", pmbase, value);\n\n\tif (state == (value & 0x1))\n\t\tpr_debug(\"change to %u MHz succeeded\\n\",\n\t\t\tspeedstep_get_frequency(speedstep_processor) / 1000);\n\telse\n\t\tpr_err(\"change failed - I/O error\\n\");\n\n\treturn;\n}\n\n \nstatic void _speedstep_set_state(void *_state)\n{\n\tspeedstep_set_state(*(unsigned int *)_state);\n}\n\n \nstatic int speedstep_activate(void)\n{\n\tu16 value = 0;\n\n\tif (!speedstep_chipset_dev)\n\t\treturn -EINVAL;\n\n\tpci_read_config_word(speedstep_chipset_dev, 0x00A0, &value);\n\tif (!(value & 0x08)) {\n\t\tvalue |= 0x08;\n\t\tpr_debug(\"activating SpeedStep (TM) registers\\n\");\n\t\tpci_write_config_word(speedstep_chipset_dev, 0x00A0, value);\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic unsigned int speedstep_detect_chipset(void)\n{\n\tspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t      PCI_DEVICE_ID_INTEL_82801DB_12,\n\t\t\t      PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t      NULL);\n\tif (speedstep_chipset_dev)\n\t\treturn 4;  \n\n\tspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t      PCI_DEVICE_ID_INTEL_82801CA_12,\n\t\t\t      PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t      NULL);\n\tif (speedstep_chipset_dev)\n\t\treturn 3;  \n\n\n\tspeedstep_chipset_dev = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t      PCI_DEVICE_ID_INTEL_82801BA_10,\n\t\t\t      PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t      NULL);\n\tif (speedstep_chipset_dev) {\n\t\t \n\t\tstruct pci_dev *hostbridge;\n\n\t\thostbridge  = pci_get_subsys(PCI_VENDOR_ID_INTEL,\n\t\t\t      PCI_DEVICE_ID_INTEL_82815_MC,\n\t\t\t      PCI_ANY_ID, PCI_ANY_ID,\n\t\t\t      NULL);\n\n\t\tif (!hostbridge)\n\t\t\treturn 2;  \n\n\t\tif (hostbridge->revision < 5) {\n\t\t\tpr_debug(\"hostbridge does not support speedstep\\n\");\n\t\t\tspeedstep_chipset_dev = NULL;\n\t\t\tpci_dev_put(hostbridge);\n\t\t\treturn 0;\n\t\t}\n\n\t\tpci_dev_put(hostbridge);\n\t\treturn 2;  \n\t}\n\n\treturn 0;\n}\n\nstatic void get_freq_data(void *_speed)\n{\n\tunsigned int *speed = _speed;\n\n\t*speed = speedstep_get_frequency(speedstep_processor);\n}\n\nstatic unsigned int speedstep_get(unsigned int cpu)\n{\n\tunsigned int speed;\n\n\t \n\tBUG_ON(smp_call_function_single(cpu, get_freq_data, &speed, 1));\n\n\tpr_debug(\"detected %u kHz as current frequency\\n\", speed);\n\treturn speed;\n}\n\n \nstatic int speedstep_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tunsigned int policy_cpu;\n\n\tpolicy_cpu = cpumask_any_and(policy->cpus, cpu_online_mask);\n\n\tsmp_call_function_single(policy_cpu, _speedstep_set_state, &index,\n\t\t\t\t true);\n\n\treturn 0;\n}\n\n\nstruct get_freqs {\n\tstruct cpufreq_policy *policy;\n\tint ret;\n};\n\nstatic void get_freqs_on_cpu(void *_get_freqs)\n{\n\tstruct get_freqs *get_freqs = _get_freqs;\n\n\tget_freqs->ret =\n\t\tspeedstep_get_freqs(speedstep_processor,\n\t\t\t    &speedstep_freqs[SPEEDSTEP_LOW].frequency,\n\t\t\t    &speedstep_freqs[SPEEDSTEP_HIGH].frequency,\n\t\t\t    &get_freqs->policy->cpuinfo.transition_latency,\n\t\t\t    &speedstep_set_state);\n}\n\nstatic int speedstep_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int policy_cpu;\n\tstruct get_freqs gf;\n\n\t \n#ifdef CONFIG_SMP\n\tcpumask_copy(policy->cpus, topology_sibling_cpumask(policy->cpu));\n#endif\n\tpolicy_cpu = cpumask_any_and(policy->cpus, cpu_online_mask);\n\n\t \n\tgf.policy = policy;\n\tsmp_call_function_single(policy_cpu, get_freqs_on_cpu, &gf, 1);\n\tif (gf.ret)\n\t\treturn gf.ret;\n\n\tpolicy->freq_table = speedstep_freqs;\n\n\treturn 0;\n}\n\n\nstatic struct cpufreq_driver speedstep_driver = {\n\t.name\t= \"speedstep-ich\",\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.target_index = speedstep_target,\n\t.init\t= speedstep_cpu_init,\n\t.get\t= speedstep_get,\n\t.attr\t= cpufreq_generic_attr,\n};\n\nstatic const struct x86_cpu_id ss_smi_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL,  6, 0x8, 0),\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL,  6, 0xb, 0),\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 15, 0x2, 0),\n\t{}\n};\n\n \nstatic int __init speedstep_init(void)\n{\n\tif (!x86_match_cpu(ss_smi_ids))\n\t\treturn -ENODEV;\n\n\t \n\tspeedstep_processor = speedstep_detect_processor();\n\tif (!speedstep_processor) {\n\t\tpr_debug(\"Intel(R) SpeedStep(TM) capable processor \"\n\t\t\t\t\"not found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!speedstep_detect_chipset()) {\n\t\tpr_debug(\"Intel(R) SpeedStep(TM) for this chipset not \"\n\t\t\t\t\"(yet) available.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (speedstep_activate()) {\n\t\tpci_dev_put(speedstep_chipset_dev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (speedstep_find_register())\n\t\treturn -ENODEV;\n\n\treturn cpufreq_register_driver(&speedstep_driver);\n}\n\n\n \nstatic void __exit speedstep_exit(void)\n{\n\tpci_dev_put(speedstep_chipset_dev);\n\tcpufreq_unregister_driver(&speedstep_driver);\n}\n\n\nMODULE_AUTHOR(\"Dave Jones, Dominik Brodowski <linux@brodo.de>\");\nMODULE_DESCRIPTION(\"Speedstep driver for Intel mobile processors on chipsets \"\n\t\t\"with ICH-M southbridges.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(speedstep_init);\nmodule_exit(speedstep_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}