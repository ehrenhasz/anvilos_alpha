{
  "module_name": "speedstep-lib.c",
  "hash_id": "ec8bed6f7850d46c2cf626ff63c3a9150da14f4e6fcfe14752b802bf3edfb8c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/speedstep-lib.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n\n#include <asm/msr.h>\n#include <asm/tsc.h>\n#include \"speedstep-lib.h\"\n\n#define PFX \"speedstep-lib: \"\n\n#ifdef CONFIG_X86_SPEEDSTEP_RELAXED_CAP_CHECK\nstatic int relaxed_check;\n#else\n#define relaxed_check 0\n#endif\n\n \n\nstatic unsigned int pentium3_get_frequency(enum speedstep_processor processor)\n{\n\t \n\tstatic const struct {\n\t\tunsigned int ratio;\t \n\t\tu8 bitmap;\t\t \n\t} msr_decode_mult[] = {\n\t\t{ 30, 0x01 },\n\t\t{ 35, 0x05 },\n\t\t{ 40, 0x02 },\n\t\t{ 45, 0x06 },\n\t\t{ 50, 0x00 },\n\t\t{ 55, 0x04 },\n\t\t{ 60, 0x0b },\n\t\t{ 65, 0x0f },\n\t\t{ 70, 0x09 },\n\t\t{ 75, 0x0d },\n\t\t{ 80, 0x0a },\n\t\t{ 85, 0x26 },\n\t\t{ 90, 0x20 },\n\t\t{ 100, 0x2b },\n\t\t{ 0, 0xff }\t \n\t};\n\n\t \n\tstatic const struct {\n\t\tunsigned int value;\t \n\t\tu8 bitmap;\t\t \n\t} msr_decode_fsb[] = {\n\t\t{  66, 0x0 },\n\t\t{ 100, 0x2 },\n\t\t{ 133, 0x1 },\n\t\t{   0, 0xff}\n\t};\n\n\tu32 msr_lo, msr_tmp;\n\tint i = 0, j = 0;\n\n\t \n\trdmsr(MSR_IA32_EBL_CR_POWERON, msr_lo, msr_tmp);\n\tpr_debug(\"P3 - MSR_IA32_EBL_CR_POWERON: 0x%x 0x%x\\n\", msr_lo, msr_tmp);\n\tmsr_tmp = msr_lo;\n\n\t \n\tmsr_tmp &= 0x00c0000;\n\tmsr_tmp >>= 18;\n\twhile (msr_tmp != msr_decode_fsb[i].bitmap) {\n\t\tif (msr_decode_fsb[i].bitmap == 0xff)\n\t\t\treturn 0;\n\t\ti++;\n\t}\n\n\t \n\tif (processor == SPEEDSTEP_CPU_PIII_C_EARLY) {\n\t\tpr_debug(\"workaround for early PIIIs\\n\");\n\t\tmsr_lo &= 0x03c00000;\n\t} else\n\t\tmsr_lo &= 0x0bc00000;\n\tmsr_lo >>= 22;\n\twhile (msr_lo != msr_decode_mult[j].bitmap) {\n\t\tif (msr_decode_mult[j].bitmap == 0xff)\n\t\t\treturn 0;\n\t\tj++;\n\t}\n\n\tpr_debug(\"speed is %u\\n\",\n\t\t(msr_decode_mult[j].ratio * msr_decode_fsb[i].value * 100));\n\n\treturn msr_decode_mult[j].ratio * msr_decode_fsb[i].value * 100;\n}\n\n\nstatic unsigned int pentiumM_get_frequency(void)\n{\n\tu32 msr_lo, msr_tmp;\n\n\trdmsr(MSR_IA32_EBL_CR_POWERON, msr_lo, msr_tmp);\n\tpr_debug(\"PM - MSR_IA32_EBL_CR_POWERON: 0x%x 0x%x\\n\", msr_lo, msr_tmp);\n\n\t \n\tif (msr_lo & 0x00040000) {\n\t\tprintk(KERN_DEBUG PFX \"PM - invalid FSB: 0x%x 0x%x\\n\",\n\t\t\t\tmsr_lo, msr_tmp);\n\t\treturn 0;\n\t}\n\n\tmsr_tmp = (msr_lo >> 22) & 0x1f;\n\tpr_debug(\"bits 22-26 are 0x%x, speed is %u\\n\",\n\t\t\tmsr_tmp, (msr_tmp * 100 * 1000));\n\n\treturn msr_tmp * 100 * 1000;\n}\n\nstatic unsigned int pentium_core_get_frequency(void)\n{\n\tu32 fsb = 0;\n\tu32 msr_lo, msr_tmp;\n\tint ret;\n\n\trdmsr(MSR_FSB_FREQ, msr_lo, msr_tmp);\n\t \n\tswitch (msr_lo & 0x07) {\n\tcase 5:\n\t\tfsb = 100000;\n\t\tbreak;\n\tcase 1:\n\t\tfsb = 133333;\n\t\tbreak;\n\tcase 3:\n\t\tfsb = 166667;\n\t\tbreak;\n\tcase 2:\n\t\tfsb = 200000;\n\t\tbreak;\n\tcase 0:\n\t\tfsb = 266667;\n\t\tbreak;\n\tcase 4:\n\t\tfsb = 333333;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"PCORE - MSR_FSB_FREQ undefined value\\n\");\n\t}\n\n\trdmsr(MSR_IA32_EBL_CR_POWERON, msr_lo, msr_tmp);\n\tpr_debug(\"PCORE - MSR_IA32_EBL_CR_POWERON: 0x%x 0x%x\\n\",\n\t\t\tmsr_lo, msr_tmp);\n\n\tmsr_tmp = (msr_lo >> 22) & 0x1f;\n\tpr_debug(\"bits 22-26 are 0x%x, speed is %u\\n\",\n\t\t\tmsr_tmp, (msr_tmp * fsb));\n\n\tret = (msr_tmp * fsb);\n\treturn ret;\n}\n\n\nstatic unsigned int pentium4_get_frequency(void)\n{\n\tstruct cpuinfo_x86 *c = &boot_cpu_data;\n\tu32 msr_lo, msr_hi, mult;\n\tunsigned int fsb = 0;\n\tunsigned int ret;\n\tu8 fsb_code;\n\n\t \n\tif (c->x86_model < 2)\n\t\treturn cpu_khz;\n\n\trdmsr(0x2c, msr_lo, msr_hi);\n\n\tpr_debug(\"P4 - MSR_EBC_FREQUENCY_ID: 0x%x 0x%x\\n\", msr_lo, msr_hi);\n\n\t \n\tfsb_code = (msr_lo >> 16) & 0x7;\n\tswitch (fsb_code) {\n\tcase 0:\n\t\tfsb = 100 * 1000;\n\t\tbreak;\n\tcase 1:\n\t\tfsb = 13333 * 10;\n\t\tbreak;\n\tcase 2:\n\t\tfsb = 200 * 1000;\n\t\tbreak;\n\t}\n\n\tif (!fsb)\n\t\tprintk(KERN_DEBUG PFX \"couldn't detect FSB speed. \"\n\t\t\t\t\"Please send an e-mail to <linux@brodo.de>\\n\");\n\n\t \n\tmult = msr_lo >> 24;\n\n\tpr_debug(\"P4 - FSB %u kHz; Multiplier %u; Speed %u kHz\\n\",\n\t\t\tfsb, mult, (fsb * mult));\n\n\tret = (fsb * mult);\n\treturn ret;\n}\n\n\n \nunsigned int speedstep_get_frequency(enum speedstep_processor processor)\n{\n\tswitch (processor) {\n\tcase SPEEDSTEP_CPU_PCORE:\n\t\treturn pentium_core_get_frequency();\n\tcase SPEEDSTEP_CPU_PM:\n\t\treturn pentiumM_get_frequency();\n\tcase SPEEDSTEP_CPU_P4D:\n\tcase SPEEDSTEP_CPU_P4M:\n\t\treturn pentium4_get_frequency();\n\tcase SPEEDSTEP_CPU_PIII_T:\n\tcase SPEEDSTEP_CPU_PIII_C:\n\tcase SPEEDSTEP_CPU_PIII_C_EARLY:\n\t\treturn pentium3_get_frequency(processor);\n\tdefault:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(speedstep_get_frequency);\n\n\n \n\n \nenum speedstep_processor speedstep_detect_processor(void)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tu32 ebx, msr_lo, msr_hi;\n\n\tpr_debug(\"x86: %x, model: %x\\n\", c->x86, c->x86_model);\n\n\tif ((c->x86_vendor != X86_VENDOR_INTEL) ||\n\t    ((c->x86 != 6) && (c->x86 != 0xF)))\n\t\treturn 0;\n\n\tif (c->x86 == 0xF) {\n\t\t \n\t\tif (c->x86_model != 2)\n\t\t\treturn 0;\n\n\t\tebx = cpuid_ebx(0x00000001);\n\t\tebx &= 0x000000FF;\n\n\t\tpr_debug(\"ebx value is %x, x86_stepping is %x\\n\", ebx, c->x86_stepping);\n\n\t\tswitch (c->x86_stepping) {\n\t\tcase 4:\n\t\t\t \n\t\t\tif ((ebx == 0x0e) || (ebx == 0x0f))\n\t\t\t\treturn SPEEDSTEP_CPU_P4M;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\t \n\t\t\tif (ebx == 0x0e)\n\t\t\t\treturn SPEEDSTEP_CPU_P4M;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\t \n\t\t\tif ((ebx == 0x0e) ||\n\t\t\t\t(strstr(c->x86_model_id,\n\t\t\t\t    \"Mobile Intel(R) Pentium(R) 4\") != NULL))\n\t\t\t\treturn SPEEDSTEP_CPU_P4M;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tswitch (c->x86_model) {\n\tcase 0x0B:  \n\t\t \n\t\tebx = cpuid_ebx(0x00000001);\n\t\tpr_debug(\"ebx is %x\\n\", ebx);\n\n\t\tebx &= 0x000000FF;\n\n\t\tif (ebx != 0x06)\n\t\t\treturn 0;\n\n\t\t \n\t\treturn SPEEDSTEP_CPU_PIII_T;\n\n\tcase 0x08:  \n\n\t\t \n\t\trdmsr(MSR_IA32_EBL_CR_POWERON, msr_lo, msr_hi);\n\t\tpr_debug(\"Coppermine: MSR_IA32_EBL_CR_POWERON is 0x%x, 0x%x\\n\",\n\t\t\t\tmsr_lo, msr_hi);\n\t\tmsr_lo &= 0x00c0000;\n\t\tif (msr_lo != 0x0080000)\n\t\t\treturn 0;\n\n\t\t \n\t\trdmsr(MSR_IA32_PLATFORM_ID, msr_lo, msr_hi);\n\t\tpr_debug(\"Coppermine: MSR_IA32_PLATFORM ID is 0x%x, 0x%x\\n\",\n\t\t\t\tmsr_lo, msr_hi);\n\t\tif ((msr_hi & (1<<18)) &&\n\t\t    (relaxed_check ? 1 : (msr_hi & (3<<24)))) {\n\t\t\tif (c->x86_stepping == 0x01) {\n\t\t\t\tpr_debug(\"early PIII version\\n\");\n\t\t\t\treturn SPEEDSTEP_CPU_PIII_C_EARLY;\n\t\t\t} else\n\t\t\t\treturn SPEEDSTEP_CPU_PIII_C;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL_GPL(speedstep_detect_processor);\n\n\n \n\nunsigned int speedstep_get_freqs(enum speedstep_processor processor,\n\t\t\t\t  unsigned int *low_speed,\n\t\t\t\t  unsigned int *high_speed,\n\t\t\t\t  unsigned int *transition_latency,\n\t\t\t\t  void (*set_state) (unsigned int state))\n{\n\tunsigned int prev_speed;\n\tunsigned int ret = 0;\n\tunsigned long flags;\n\tktime_t tv1, tv2;\n\n\tif ((!processor) || (!low_speed) || (!high_speed) || (!set_state))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"trying to determine both speeds\\n\");\n\n\t \n\tprev_speed = speedstep_get_frequency(processor);\n\tif (!prev_speed)\n\t\treturn -EIO;\n\n\tpr_debug(\"previous speed is %u\\n\", prev_speed);\n\n\tpreempt_disable();\n\tlocal_irq_save(flags);\n\n\t \n\tset_state(SPEEDSTEP_LOW);\n\t*low_speed = speedstep_get_frequency(processor);\n\tif (!*low_speed) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"low speed is %u\\n\", *low_speed);\n\n\t \n\tif (transition_latency)\n\t\ttv1 = ktime_get();\n\n\t \n\tset_state(SPEEDSTEP_HIGH);\n\n\t \n\tif (transition_latency)\n\t\ttv2 = ktime_get();\n\n\t*high_speed = speedstep_get_frequency(processor);\n\tif (!*high_speed) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tpr_debug(\"high speed is %u\\n\", *high_speed);\n\n\tif (*low_speed == *high_speed) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (*high_speed != prev_speed)\n\t\tset_state(SPEEDSTEP_LOW);\n\n\tif (transition_latency) {\n\t\t*transition_latency = ktime_to_us(ktime_sub(tv2, tv1));\n\t\tpr_debug(\"transition latency is %u uSec\\n\", *transition_latency);\n\n\t\t \n\t\t*transition_latency *= 1200;\n\n\t\t \n\t\tif (*transition_latency > 10000000 ||\n\t\t    *transition_latency < 50000) {\n\t\t\tpr_warn(\"frequency transition measured seems out of range (%u nSec), falling back to a safe one of %u nSec\\n\",\n\t\t\t\t*transition_latency, 500000);\n\t\t\t*transition_latency = 500000;\n\t\t}\n\t}\n\nout:\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(speedstep_get_freqs);\n\n#ifdef CONFIG_X86_SPEEDSTEP_RELAXED_CAP_CHECK\nmodule_param(relaxed_check, int, 0444);\nMODULE_PARM_DESC(relaxed_check,\n\t\t\"Don't do all checks for speedstep capability.\");\n#endif\n\nMODULE_AUTHOR(\"Dominik Brodowski <linux@brodo.de>\");\nMODULE_DESCRIPTION(\"Library for Intel SpeedStep 1 or 2 cpufreq drivers.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}