{
  "module_name": "e_powersaver.c",
  "hash_id": "6a20a1949e67750e04fd66f755984a34c13cf1b009a3a91d9b64b856db324ade",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/e_powersaver.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/timex.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/msr.h>\n#include <asm/tsc.h>\n\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#endif\n\n#define EPS_BRAND_C7M\t0\n#define EPS_BRAND_C7\t1\n#define EPS_BRAND_EDEN\t2\n#define EPS_BRAND_C3\t3\n#define EPS_BRAND_C7D\t4\n\nstruct eps_cpu_data {\n\tu32 fsb;\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\n\tu32 bios_limit;\n#endif\n\tstruct cpufreq_frequency_table freq_table[];\n};\n\nstatic struct eps_cpu_data *eps_cpu[NR_CPUS];\n\n \nstatic int freq_failsafe_off;\nstatic int voltage_failsafe_off;\nstatic int set_max_voltage;\n\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\nstatic int ignore_acpi_limit;\n\nstatic struct acpi_processor_performance *eps_acpi_cpu_perf;\n\n \nstatic int eps_acpi_init(void)\n{\n\teps_acpi_cpu_perf = kzalloc(sizeof(*eps_acpi_cpu_perf),\n\t\t\t\t      GFP_KERNEL);\n\tif (!eps_acpi_cpu_perf)\n\t\treturn -ENOMEM;\n\n\tif (!zalloc_cpumask_var(&eps_acpi_cpu_perf->shared_cpu_map,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\tkfree(eps_acpi_cpu_perf);\n\t\teps_acpi_cpu_perf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tif (acpi_processor_register_performance(eps_acpi_cpu_perf, 0)) {\n\t\tfree_cpumask_var(eps_acpi_cpu_perf->shared_cpu_map);\n\t\tkfree(eps_acpi_cpu_perf);\n\t\teps_acpi_cpu_perf = NULL;\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int eps_acpi_exit(struct cpufreq_policy *policy)\n{\n\tif (eps_acpi_cpu_perf) {\n\t\tacpi_processor_unregister_performance(0);\n\t\tfree_cpumask_var(eps_acpi_cpu_perf->shared_cpu_map);\n\t\tkfree(eps_acpi_cpu_perf);\n\t\teps_acpi_cpu_perf = NULL;\n\t}\n\treturn 0;\n}\n#endif\n\nstatic unsigned int eps_get(unsigned int cpu)\n{\n\tstruct eps_cpu_data *centaur;\n\tu32 lo, hi;\n\n\tif (cpu)\n\t\treturn 0;\n\tcentaur = eps_cpu[cpu];\n\tif (centaur == NULL)\n\t\treturn 0;\n\n\t \n\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\treturn centaur->fsb * ((lo >> 8) & 0xff);\n}\n\nstatic int eps_set_state(struct eps_cpu_data *centaur,\n\t\t\t struct cpufreq_policy *policy,\n\t\t\t u32 dest_state)\n{\n\tu32 lo, hi;\n\tint i;\n\n\t \n\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\ti = 0;\n\twhile (lo & ((1 << 16) | (1 << 17))) {\n\t\tudelay(16);\n\t\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\t\ti++;\n\t\tif (unlikely(i > 64)) {\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\t \n\twrmsr(MSR_IA32_PERF_CTL, dest_state & 0xffff, 0);\n\t \n\ti = 0;\n\tdo {\n\t\tudelay(16);\n\t\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\t\ti++;\n\t\tif (unlikely(i > 64)) {\n\t\t\treturn -ENODEV;\n\t\t}\n\t} while (lo & ((1 << 16) | (1 << 17)));\n\n#ifdef DEBUG\n\t{\n\tu8 current_multiplier, current_voltage;\n\n\t \n\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\tcurrent_voltage = lo & 0xff;\n\tpr_info(\"Current voltage = %dmV\\n\", current_voltage * 16 + 700);\n\tcurrent_multiplier = (lo >> 8) & 0xff;\n\tpr_info(\"Current multiplier = %d\\n\", current_multiplier);\n\t}\n#endif\n\treturn 0;\n}\n\nstatic int eps_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tstruct eps_cpu_data *centaur;\n\tunsigned int cpu = policy->cpu;\n\tunsigned int dest_state;\n\tint ret;\n\n\tif (unlikely(eps_cpu[cpu] == NULL))\n\t\treturn -ENODEV;\n\tcentaur = eps_cpu[cpu];\n\n\t \n\tdest_state = centaur->freq_table[index].driver_data & 0xffff;\n\tret = eps_set_state(centaur, policy, dest_state);\n\tif (ret)\n\t\tpr_err(\"Timeout!\\n\");\n\treturn ret;\n}\n\nstatic int eps_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int i;\n\tu32 lo, hi;\n\tu64 val;\n\tu8 current_multiplier, current_voltage;\n\tu8 max_multiplier, max_voltage;\n\tu8 min_multiplier, min_voltage;\n\tu8 brand = 0;\n\tu32 fsb;\n\tstruct eps_cpu_data *centaur;\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tstruct cpufreq_frequency_table *f_table;\n\tint k, step, voltage;\n\tint states;\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\n\tunsigned int limit;\n#endif\n\n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\t \n\tpr_info(\"Detected VIA \");\n\n\tswitch (c->x86_model) {\n\tcase 10:\n\t\trdmsr(0x1153, lo, hi);\n\t\tbrand = (((lo >> 2) ^ lo) >> 18) & 3;\n\t\tpr_cont(\"Model A \");\n\t\tbreak;\n\tcase 13:\n\t\trdmsr(0x1154, lo, hi);\n\t\tbrand = (((lo >> 4) ^ (lo >> 2))) & 0x000000ff;\n\t\tpr_cont(\"Model D \");\n\t\tbreak;\n\t}\n\n\tswitch (brand) {\n\tcase EPS_BRAND_C7M:\n\t\tpr_cont(\"C7-M\\n\");\n\t\tbreak;\n\tcase EPS_BRAND_C7:\n\t\tpr_cont(\"C7\\n\");\n\t\tbreak;\n\tcase EPS_BRAND_EDEN:\n\t\tpr_cont(\"Eden\\n\");\n\t\tbreak;\n\tcase EPS_BRAND_C7D:\n\t\tpr_cont(\"C7-D\\n\");\n\t\tbreak;\n\tcase EPS_BRAND_C3:\n\t\tpr_cont(\"C3\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\trdmsrl(MSR_IA32_MISC_ENABLE, val);\n\tif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\n\t\tval |= MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP;\n\t\twrmsrl(MSR_IA32_MISC_ENABLE, val);\n\t\t \n\t\trdmsrl(MSR_IA32_MISC_ENABLE, val);\n\t\tif (!(val & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\n\t\t\tpr_info(\"Can't enable Enhanced PowerSaver\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\trdmsr(MSR_IA32_PERF_STATUS, lo, hi);\n\tcurrent_voltage = lo & 0xff;\n\tpr_info(\"Current voltage = %dmV\\n\", current_voltage * 16 + 700);\n\tcurrent_multiplier = (lo >> 8) & 0xff;\n\tpr_info(\"Current multiplier = %d\\n\", current_multiplier);\n\n\t \n\tmax_voltage = hi & 0xff;\n\tpr_info(\"Highest voltage = %dmV\\n\", max_voltage * 16 + 700);\n\tmax_multiplier = (hi >> 8) & 0xff;\n\tpr_info(\"Highest multiplier = %d\\n\", max_multiplier);\n\tmin_voltage = (hi >> 16) & 0xff;\n\tpr_info(\"Lowest voltage = %dmV\\n\", min_voltage * 16 + 700);\n\tmin_multiplier = (hi >> 24) & 0xff;\n\tpr_info(\"Lowest multiplier = %d\\n\", min_multiplier);\n\n\t \n\tif (current_multiplier == 0 || max_multiplier == 0\n\t    || min_multiplier == 0)\n\t\treturn -EINVAL;\n\tif (current_multiplier > max_multiplier\n\t    || max_multiplier <= min_multiplier)\n\t\treturn -EINVAL;\n\tif (current_voltage > 0x1f || max_voltage > 0x1f)\n\t\treturn -EINVAL;\n\tif (max_voltage < min_voltage\n\t    || current_voltage < min_voltage\n\t    || current_voltage > max_voltage)\n\t\treturn -EINVAL;\n\n\t \n\tif (!freq_failsafe_off && max_multiplier != current_multiplier) {\n\t\tpr_info(\"Your processor is running at different frequency then its maximum. Aborting.\\n\");\n\t\tpr_info(\"You can use freq_failsafe_off option to disable this check.\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (!voltage_failsafe_off && max_voltage != current_voltage) {\n\t\tpr_info(\"Your processor is running at different voltage then its maximum. Aborting.\\n\");\n\t\tpr_info(\"You can use voltage_failsafe_off option to disable this check.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfsb = cpu_khz / current_multiplier;\n\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\n\t \n\tif (!ignore_acpi_limit && !eps_acpi_init()) {\n\t\tif (!acpi_processor_get_bios_limit(policy->cpu, &limit)) {\n\t\t\tpr_info(\"ACPI limit %u.%uGHz\\n\",\n\t\t\t\tlimit/1000000,\n\t\t\t\t(limit%1000000)/10000);\n\t\t\teps_acpi_exit(policy);\n\t\t\t \n\t\t\tif (limit && max_multiplier * fsb > limit) {\n\t\t\t\tpr_info(\"Aborting\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\t \n\tif (brand == EPS_BRAND_C7M && set_max_voltage) {\n\t\tu32 v;\n\n\t\t \n\t\tv = (set_max_voltage - 700) / 16;\n\t\t \n\t\tif (v >= min_voltage && v <= max_voltage) {\n\t\t\tpr_info(\"Setting %dmV as maximum\\n\", v * 16 + 700);\n\t\t\tmax_voltage = v;\n\t\t}\n\t}\n\n\t \n\tif (brand == EPS_BRAND_C7M)\n\t\tstates = max_multiplier - min_multiplier + 1;\n\telse\n\t\tstates = 2;\n\n\t \n\tcentaur = kzalloc(struct_size(centaur, freq_table, states + 1),\n\t\t\t  GFP_KERNEL);\n\tif (!centaur)\n\t\treturn -ENOMEM;\n\teps_cpu[0] = centaur;\n\n\t \n\tcentaur->fsb = fsb;\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\n\tcentaur->bios_limit = limit;\n#endif\n\n\t \n\tf_table = &centaur->freq_table[0];\n\tif (brand != EPS_BRAND_C7M) {\n\t\tf_table[0].frequency = fsb * min_multiplier;\n\t\tf_table[0].driver_data = (min_multiplier << 8) | min_voltage;\n\t\tf_table[1].frequency = fsb * max_multiplier;\n\t\tf_table[1].driver_data = (max_multiplier << 8) | max_voltage;\n\t\tf_table[2].frequency = CPUFREQ_TABLE_END;\n\t} else {\n\t\tk = 0;\n\t\tstep = ((max_voltage - min_voltage) * 256)\n\t\t\t/ (max_multiplier - min_multiplier);\n\t\tfor (i = min_multiplier; i <= max_multiplier; i++) {\n\t\t\tvoltage = (k * step) / 256 + min_voltage;\n\t\t\tf_table[k].frequency = fsb * i;\n\t\t\tf_table[k].driver_data = (i << 8) | voltage;\n\t\t\tk++;\n\t\t}\n\t\tf_table[k].frequency = CPUFREQ_TABLE_END;\n\t}\n\n\tpolicy->cpuinfo.transition_latency = 140000;  \n\tpolicy->freq_table = &centaur->freq_table[0];\n\n\treturn 0;\n}\n\nstatic int eps_cpu_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\n\t \n\tkfree(eps_cpu[cpu]);\n\teps_cpu[cpu] = NULL;\n\treturn 0;\n}\n\nstatic struct cpufreq_driver eps_driver = {\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= eps_target,\n\t.init\t\t= eps_cpu_init,\n\t.exit\t\t= eps_cpu_exit,\n\t.get\t\t= eps_get,\n\t.name\t\t= \"e_powersaver\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\n\n \nstatic const struct x86_cpu_id eps_cpu_id[] = {\n\tX86_MATCH_VENDOR_FAM_FEATURE(CENTAUR, 6, X86_FEATURE_EST, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, eps_cpu_id);\n\nstatic int __init eps_init(void)\n{\n\tif (!x86_match_cpu(eps_cpu_id) || boot_cpu_data.x86_model < 10)\n\t\treturn -ENODEV;\n\tif (cpufreq_register_driver(&eps_driver))\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void __exit eps_exit(void)\n{\n\tcpufreq_unregister_driver(&eps_driver);\n}\n\n \nmodule_param(freq_failsafe_off, int, 0644);\nMODULE_PARM_DESC(freq_failsafe_off, \"Disable current vs max frequency check\");\nmodule_param(voltage_failsafe_off, int, 0644);\nMODULE_PARM_DESC(voltage_failsafe_off, \"Disable current vs max voltage check\");\n#if IS_ENABLED(CONFIG_ACPI_PROCESSOR)\nmodule_param(ignore_acpi_limit, int, 0644);\nMODULE_PARM_DESC(ignore_acpi_limit, \"Don't check ACPI's processor speed limit\");\n#endif\nmodule_param(set_max_voltage, int, 0644);\nMODULE_PARM_DESC(set_max_voltage, \"Set maximum CPU voltage (mV) C7-M only\");\n\nMODULE_AUTHOR(\"Rafal Bilski <rafalbilski@interia.pl>\");\nMODULE_DESCRIPTION(\"Enhanced PowerSaver driver for VIA C7 CPU's.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(eps_init);\nmodule_exit(eps_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}