{
  "module_name": "cpufreq_conservative.c",
  "hash_id": "0be3b2c64dee28253526272f1fc465f10a06ff25294404aa8ced815fe76a61ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq_conservative.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include \"cpufreq_governor.h\"\n\nstruct cs_policy_dbs_info {\n\tstruct policy_dbs_info policy_dbs;\n\tunsigned int down_skip;\n\tunsigned int requested_freq;\n};\n\nstatic inline struct cs_policy_dbs_info *to_dbs_info(struct policy_dbs_info *policy_dbs)\n{\n\treturn container_of(policy_dbs, struct cs_policy_dbs_info, policy_dbs);\n}\n\nstruct cs_dbs_tuners {\n\tunsigned int down_threshold;\n\tunsigned int freq_step;\n};\n\n \n#define DEF_FREQUENCY_UP_THRESHOLD\t\t(80)\n#define DEF_FREQUENCY_DOWN_THRESHOLD\t\t(20)\n#define DEF_FREQUENCY_STEP\t\t\t(5)\n#define DEF_SAMPLING_DOWN_FACTOR\t\t(1)\n#define MAX_SAMPLING_DOWN_FACTOR\t\t(10)\n\nstatic inline unsigned int get_freq_step(struct cs_dbs_tuners *cs_tuners,\n\t\t\t\t\t struct cpufreq_policy *policy)\n{\n\tunsigned int freq_step = (cs_tuners->freq_step * policy->max) / 100;\n\n\t \n\tif (unlikely(freq_step == 0))\n\t\tfreq_step = DEF_FREQUENCY_STEP;\n\n\treturn freq_step;\n}\n\n \nstatic unsigned int cs_dbs_update(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct cs_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\n\tunsigned int requested_freq = dbs_info->requested_freq;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tstruct cs_dbs_tuners *cs_tuners = dbs_data->tuners;\n\tunsigned int load = dbs_update(policy);\n\tunsigned int freq_step;\n\n\t \n\tif (cs_tuners->freq_step == 0)\n\t\tgoto out;\n\n\t \n\tif (requested_freq > policy->max || requested_freq < policy->min) {\n\t\trequested_freq = policy->cur;\n\t\tdbs_info->requested_freq = requested_freq;\n\t}\n\n\tfreq_step = get_freq_step(cs_tuners, policy);\n\n\t \n\tif (policy_dbs->idle_periods < UINT_MAX) {\n\t\tunsigned int freq_steps = policy_dbs->idle_periods * freq_step;\n\n\t\tif (requested_freq > policy->min + freq_steps)\n\t\t\trequested_freq -= freq_steps;\n\t\telse\n\t\t\trequested_freq = policy->min;\n\n\t\tpolicy_dbs->idle_periods = UINT_MAX;\n\t}\n\n\t \n\tif (load > dbs_data->up_threshold) {\n\t\tdbs_info->down_skip = 0;\n\n\t\t \n\t\tif (requested_freq == policy->max)\n\t\t\tgoto out;\n\n\t\trequested_freq += freq_step;\n\t\tif (requested_freq > policy->max)\n\t\t\trequested_freq = policy->max;\n\n\t\t__cpufreq_driver_target(policy, requested_freq,\n\t\t\t\t\tCPUFREQ_RELATION_HE);\n\t\tdbs_info->requested_freq = requested_freq;\n\t\tgoto out;\n\t}\n\n\t \n\tif (++dbs_info->down_skip < dbs_data->sampling_down_factor)\n\t\tgoto out;\n\tdbs_info->down_skip = 0;\n\n\t \n\tif (load < cs_tuners->down_threshold) {\n\t\t \n\t\tif (requested_freq == policy->min)\n\t\t\tgoto out;\n\n\t\tif (requested_freq > freq_step)\n\t\t\trequested_freq -= freq_step;\n\t\telse\n\t\t\trequested_freq = policy->min;\n\n\t\t__cpufreq_driver_target(policy, requested_freq,\n\t\t\t\t\tCPUFREQ_RELATION_LE);\n\t\tdbs_info->requested_freq = requested_freq;\n\t}\n\n out:\n\treturn dbs_data->sampling_rate;\n}\n\n \n\nstatic ssize_t sampling_down_factor_store(struct gov_attr_set *attr_set,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)\n\t\treturn -EINVAL;\n\n\tdbs_data->sampling_down_factor = input;\n\treturn count;\n}\n\nstatic ssize_t up_threshold_store(struct gov_attr_set *attr_set,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct cs_dbs_tuners *cs_tuners = dbs_data->tuners;\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1 || input > 100 || input <= cs_tuners->down_threshold)\n\t\treturn -EINVAL;\n\n\tdbs_data->up_threshold = input;\n\treturn count;\n}\n\nstatic ssize_t down_threshold_store(struct gov_attr_set *attr_set,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct cs_dbs_tuners *cs_tuners = dbs_data->tuners;\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\t \n\tif (ret != 1 || input < 1 || input > 100 ||\n\t\t\tinput >= dbs_data->up_threshold)\n\t\treturn -EINVAL;\n\n\tcs_tuners->down_threshold = input;\n\treturn count;\n}\n\nstatic ssize_t ignore_nice_load_store(struct gov_attr_set *attr_set,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (input > 1)\n\t\tinput = 1;\n\n\tif (input == dbs_data->ignore_nice_load)  \n\t\treturn count;\n\n\tdbs_data->ignore_nice_load = input;\n\n\t \n\tgov_update_cpu_data(dbs_data);\n\n\treturn count;\n}\n\nstatic ssize_t freq_step_store(struct gov_attr_set *attr_set, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct cs_dbs_tuners *cs_tuners = dbs_data->tuners;\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (input > 100)\n\t\tinput = 100;\n\n\t \n\tcs_tuners->freq_step = input;\n\treturn count;\n}\n\ngov_show_one_common(sampling_rate);\ngov_show_one_common(sampling_down_factor);\ngov_show_one_common(up_threshold);\ngov_show_one_common(ignore_nice_load);\ngov_show_one(cs, down_threshold);\ngov_show_one(cs, freq_step);\n\ngov_attr_rw(sampling_rate);\ngov_attr_rw(sampling_down_factor);\ngov_attr_rw(up_threshold);\ngov_attr_rw(ignore_nice_load);\ngov_attr_rw(down_threshold);\ngov_attr_rw(freq_step);\n\nstatic struct attribute *cs_attrs[] = {\n\t&sampling_rate.attr,\n\t&sampling_down_factor.attr,\n\t&up_threshold.attr,\n\t&down_threshold.attr,\n\t&ignore_nice_load.attr,\n\t&freq_step.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(cs);\n\n \n\nstatic struct policy_dbs_info *cs_alloc(void)\n{\n\tstruct cs_policy_dbs_info *dbs_info;\n\n\tdbs_info = kzalloc(sizeof(*dbs_info), GFP_KERNEL);\n\treturn dbs_info ? &dbs_info->policy_dbs : NULL;\n}\n\nstatic void cs_free(struct policy_dbs_info *policy_dbs)\n{\n\tkfree(to_dbs_info(policy_dbs));\n}\n\nstatic int cs_init(struct dbs_data *dbs_data)\n{\n\tstruct cs_dbs_tuners *tuners;\n\n\ttuners = kzalloc(sizeof(*tuners), GFP_KERNEL);\n\tif (!tuners)\n\t\treturn -ENOMEM;\n\n\ttuners->down_threshold = DEF_FREQUENCY_DOWN_THRESHOLD;\n\ttuners->freq_step = DEF_FREQUENCY_STEP;\n\tdbs_data->up_threshold = DEF_FREQUENCY_UP_THRESHOLD;\n\tdbs_data->sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;\n\tdbs_data->ignore_nice_load = 0;\n\tdbs_data->tuners = tuners;\n\n\treturn 0;\n}\n\nstatic void cs_exit(struct dbs_data *dbs_data)\n{\n\tkfree(dbs_data->tuners);\n}\n\nstatic void cs_start(struct cpufreq_policy *policy)\n{\n\tstruct cs_policy_dbs_info *dbs_info = to_dbs_info(policy->governor_data);\n\n\tdbs_info->down_skip = 0;\n\tdbs_info->requested_freq = policy->cur;\n}\n\nstatic struct dbs_governor cs_governor = {\n\t.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(\"conservative\"),\n\t.kobj_type = { .default_groups = cs_groups },\n\t.gov_dbs_update = cs_dbs_update,\n\t.alloc = cs_alloc,\n\t.free = cs_free,\n\t.init = cs_init,\n\t.exit = cs_exit,\n\t.start = cs_start,\n};\n\n#define CPU_FREQ_GOV_CONSERVATIVE\t(cs_governor.gov)\n\nMODULE_AUTHOR(\"Alexander Clouter <alex@digriz.org.uk>\");\nMODULE_DESCRIPTION(\"'cpufreq_conservative' - A dynamic cpufreq governor for \"\n\t\t\"Low Latency Frequency Transition capable processors \"\n\t\t\"optimised for use in a battery environment\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE\nstruct cpufreq_governor *cpufreq_default_governor(void)\n{\n\treturn &CPU_FREQ_GOV_CONSERVATIVE;\n}\n#endif\n\ncpufreq_governor_init(CPU_FREQ_GOV_CONSERVATIVE);\ncpufreq_governor_exit(CPU_FREQ_GOV_CONSERVATIVE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}