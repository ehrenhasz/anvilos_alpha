{
  "module_name": "sti-cpufreq.c",
  "hash_id": "a0b504fdc2ff2f889bde46bdc96a323450e155809803f04df6ec01951e5d11aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/sti-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n\n#define VERSION_ELEMENTS\t3\n#define MAX_PCODE_NAME_LEN\t7\n\n#define VERSION_SHIFT\t\t28\n#define HW_INFO_INDEX\t\t1\n#define MAJOR_ID_INDEX\t\t1\n#define MINOR_ID_INDEX\t\t2\n\n \n#define DEFAULT_VERSION\t\t31\n\nenum {\n\tPCODE = 0,\n\tSUBSTRATE,\n\tDVFS_MAX_REGFIELDS,\n};\n\n \nstatic struct sti_cpufreq_ddata {\n\tstruct device *cpu;\n\tstruct regmap *syscfg_eng;\n\tstruct regmap *syscfg;\n} ddata;\n\nstatic int sti_cpufreq_fetch_major(void) {\n\tstruct device_node *np = ddata.cpu->of_node;\n\tstruct device *dev = ddata.cpu;\n\tunsigned int major_offset;\n\tunsigned int socid;\n\tint ret;\n\n\tret = of_property_read_u32_index(np, \"st,syscfg\",\n\t\t\t\t\t MAJOR_ID_INDEX, &major_offset);\n\tif (ret) {\n\t\tdev_err(dev, \"No major number offset provided in %pOF [%d]\\n\",\n\t\t\tnp, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(ddata.syscfg, major_offset, &socid);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read major number from syscon [%d]\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn ((socid >> VERSION_SHIFT) & 0xf) + 1;\n}\n\nstatic int sti_cpufreq_fetch_minor(void)\n{\n\tstruct device *dev = ddata.cpu;\n\tstruct device_node *np = dev->of_node;\n\tunsigned int minor_offset;\n\tunsigned int minid;\n\tint ret;\n\n\tret = of_property_read_u32_index(np, \"st,syscfg-eng\",\n\t\t\t\t\t MINOR_ID_INDEX, &minor_offset);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"No minor number offset provided %pOF [%d]\\n\",\n\t\t\tnp, ret);\n\t\treturn ret;\n\t}\n\n\tret = regmap_read(ddata.syscfg_eng, minor_offset, &minid);\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to read the minor number from syscon [%d]\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treturn minid & 0xf;\n}\n\nstatic int sti_cpufreq_fetch_regmap_field(const struct reg_field *reg_fields,\n\t\t\t\t\t  int hw_info_offset, int field)\n{\n\tstruct regmap_field *regmap_field;\n\tstruct reg_field reg_field = reg_fields[field];\n\tstruct device *dev = ddata.cpu;\n\tunsigned int value;\n\tint ret;\n\n\treg_field.reg = hw_info_offset;\n\tregmap_field = devm_regmap_field_alloc(dev,\n\t\t\t\t\t       ddata.syscfg_eng,\n\t\t\t\t\t       reg_field);\n\tif (IS_ERR(regmap_field)) {\n\t\tdev_err(dev, \"Failed to allocate reg field\\n\");\n\t\treturn PTR_ERR(regmap_field);\n\t}\n\n\tret = regmap_field_read(regmap_field, &value);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read %s code\\n\",\n\t\t\tfield ? \"SUBSTRATE\" : \"PCODE\");\n\t\treturn ret;\n\t}\n\n\treturn value;\n}\n\nstatic const struct reg_field sti_stih407_dvfs_regfields[DVFS_MAX_REGFIELDS] = {\n\t[PCODE]\t\t= REG_FIELD(0, 16, 19),\n\t[SUBSTRATE]\t= REG_FIELD(0, 0, 2),\n};\n\nstatic const struct reg_field *sti_cpufreq_match(void)\n{\n\tif (of_machine_is_compatible(\"st,stih407\") ||\n\t    of_machine_is_compatible(\"st,stih410\") ||\n\t    of_machine_is_compatible(\"st,stih418\"))\n\t\treturn sti_stih407_dvfs_regfields;\n\n\treturn NULL;\n}\n\nstatic int sti_cpufreq_set_opp_info(void)\n{\n\tstruct device *dev = ddata.cpu;\n\tstruct device_node *np = dev->of_node;\n\tconst struct reg_field *reg_fields;\n\tunsigned int hw_info_offset;\n\tunsigned int version[VERSION_ELEMENTS];\n\tint pcode, substrate, major, minor;\n\tint opp_token, ret;\n\tchar name[MAX_PCODE_NAME_LEN];\n\tstruct dev_pm_opp_config config = {\n\t\t.supported_hw = version,\n\t\t.supported_hw_count = ARRAY_SIZE(version),\n\t\t.prop_name = name,\n\t};\n\n\treg_fields = sti_cpufreq_match();\n\tif (!reg_fields) {\n\t\tdev_err(dev, \"This SoC doesn't support voltage scaling\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32_index(np, \"st,syscfg-eng\",\n\t\t\t\t\t HW_INFO_INDEX, &hw_info_offset);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to read HW info offset from DT\\n\");\n\t\tsubstrate = DEFAULT_VERSION;\n\t\tpcode = 0;\n\t\tgoto use_defaults;\n\t}\n\n\tpcode = sti_cpufreq_fetch_regmap_field(reg_fields,\n\t\t\t\t\t       hw_info_offset,\n\t\t\t\t\t       PCODE);\n\tif (pcode < 0) {\n\t\tdev_warn(dev, \"Failed to obtain process code\\n\");\n\t\t \n\t\tpcode = 0;\n\t}\n\n\tsubstrate = sti_cpufreq_fetch_regmap_field(reg_fields,\n\t\t\t\t\t\t   hw_info_offset,\n\t\t\t\t\t\t   SUBSTRATE);\n\tif (substrate) {\n\t\tdev_warn(dev, \"Failed to obtain substrate code\\n\");\n\t\t \n\t\tsubstrate = DEFAULT_VERSION;\n\t}\n\nuse_defaults:\n\tmajor = sti_cpufreq_fetch_major();\n\tif (major < 0) {\n\t\tdev_err(dev, \"Failed to obtain major version\\n\");\n\t\t \n\t\tmajor = DEFAULT_VERSION;\n\t}\n\n\tminor = sti_cpufreq_fetch_minor();\n\tif (minor < 0) {\n\t\tdev_err(dev, \"Failed to obtain minor version\\n\");\n\t\t \n\t\tminor = DEFAULT_VERSION;\n\t}\n\n\tsnprintf(name, MAX_PCODE_NAME_LEN, \"pcode%d\", pcode);\n\n\tversion[0] = BIT(major);\n\tversion[1] = BIT(minor);\n\tversion[2] = BIT(substrate);\n\n\topp_token = dev_pm_opp_set_config(dev, &config);\n\tif (opp_token < 0) {\n\t\tdev_err(dev, \"Failed to set OPP config\\n\");\n\t\treturn opp_token;\n\t}\n\n\tdev_dbg(dev, \"pcode: %d major: %d minor: %d substrate: %d\\n\",\n\t\tpcode, major, minor, substrate);\n\tdev_dbg(dev, \"version[0]: %x version[1]: %x version[2]: %x\\n\",\n\t\tversion[0], version[1], version[2]);\n\n\treturn 0;\n}\n\nstatic int sti_cpufreq_fetch_syscon_registers(void)\n{\n\tstruct device *dev = ddata.cpu;\n\tstruct device_node *np = dev->of_node;\n\n\tddata.syscfg = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(ddata.syscfg)) {\n\t\tdev_err(dev,  \"\\\"st,syscfg\\\" not supplied\\n\");\n\t\treturn PTR_ERR(ddata.syscfg);\n\t}\n\n\tddata.syscfg_eng = syscon_regmap_lookup_by_phandle(np, \"st,syscfg-eng\");\n\tif (IS_ERR(ddata.syscfg_eng)) {\n\t\tdev_err(dev, \"\\\"st,syscfg-eng\\\" not supplied\\n\");\n\t\treturn PTR_ERR(ddata.syscfg_eng);\n\t}\n\n\treturn 0;\n}\n\nstatic int __init sti_cpufreq_init(void)\n{\n\tint ret;\n\n\tif ((!of_machine_is_compatible(\"st,stih407\")) &&\n\t\t(!of_machine_is_compatible(\"st,stih410\")) &&\n\t\t(!of_machine_is_compatible(\"st,stih418\")))\n\t\treturn -ENODEV;\n\n\tddata.cpu = get_cpu_device(0);\n\tif (!ddata.cpu) {\n\t\tdev_err(ddata.cpu, \"Failed to get device for CPU0\\n\");\n\t\tgoto skip_voltage_scaling;\n\t}\n\n\tif (!of_get_property(ddata.cpu->of_node, \"operating-points-v2\", NULL)) {\n\t\tdev_err(ddata.cpu, \"OPP-v2 not supported\\n\");\n\t\tgoto skip_voltage_scaling;\n\t}\n\n\tret = sti_cpufreq_fetch_syscon_registers();\n\tif (ret)\n\t\tgoto skip_voltage_scaling;\n\n\tret = sti_cpufreq_set_opp_info();\n\tif (!ret)\n\t\tgoto register_cpufreq_dt;\n\nskip_voltage_scaling:\n\tdev_err(ddata.cpu, \"Not doing voltage scaling\\n\");\n\nregister_cpufreq_dt:\n\tplatform_device_register_simple(\"cpufreq-dt\", -1, NULL, 0);\n\n\treturn 0;\n}\nmodule_init(sti_cpufreq_init);\n\nstatic const struct of_device_id __maybe_unused sti_cpufreq_of_match[] = {\n\t{ .compatible = \"st,stih407\" },\n\t{ .compatible = \"st,stih410\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, sti_cpufreq_of_match);\n\nMODULE_DESCRIPTION(\"STMicroelectronics CPUFreq/OPP driver\");\nMODULE_AUTHOR(\"Ajitpal Singh <ajitpal.singh@st.com>\");\nMODULE_AUTHOR(\"Lee Jones <lee.jones@linaro.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}