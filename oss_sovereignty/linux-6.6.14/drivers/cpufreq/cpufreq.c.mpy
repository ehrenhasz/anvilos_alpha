{
  "module_name": "cpufreq.c",
  "hash_id": "507eb16b3f5ff8e7f83e4a28fdcfbed2a867c355b0d652e609e96280f692c45b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpu_cooling.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/init.h>\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/pm_qos.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/tick.h>\n#include <linux/units.h>\n#include <trace/events/power.h>\n\nstatic LIST_HEAD(cpufreq_policy_list);\n\n \n#define for_each_suitable_policy(__policy, __active)\t\t\t \\\n\tlist_for_each_entry(__policy, &cpufreq_policy_list, policy_list) \\\n\t\tif ((__active) == !policy_is_inactive(__policy))\n\n#define for_each_active_policy(__policy)\t\t\\\n\tfor_each_suitable_policy(__policy, true)\n#define for_each_inactive_policy(__policy)\t\t\\\n\tfor_each_suitable_policy(__policy, false)\n\n \nstatic LIST_HEAD(cpufreq_governor_list);\n#define for_each_governor(__governor)\t\t\t\t\\\n\tlist_for_each_entry(__governor, &cpufreq_governor_list, governor_list)\n\nstatic char default_governor[CPUFREQ_NAME_LEN];\n\n \nstatic struct cpufreq_driver *cpufreq_driver;\nstatic DEFINE_PER_CPU(struct cpufreq_policy *, cpufreq_cpu_data);\nstatic DEFINE_RWLOCK(cpufreq_driver_lock);\n\nstatic DEFINE_STATIC_KEY_FALSE(cpufreq_freq_invariance);\nbool cpufreq_supports_freq_invariance(void)\n{\n\treturn static_branch_likely(&cpufreq_freq_invariance);\n}\n\n \nstatic bool cpufreq_suspended;\n\nstatic inline bool has_target(void)\n{\n\treturn cpufreq_driver->target_index || cpufreq_driver->target;\n}\n\nbool has_target_index(void)\n{\n\treturn !!cpufreq_driver->target_index;\n}\n\n \nstatic unsigned int __cpufreq_get(struct cpufreq_policy *policy);\nstatic int cpufreq_init_governor(struct cpufreq_policy *policy);\nstatic void cpufreq_exit_governor(struct cpufreq_policy *policy);\nstatic void cpufreq_governor_limits(struct cpufreq_policy *policy);\nstatic int cpufreq_set_policy(struct cpufreq_policy *policy,\n\t\t\t      struct cpufreq_governor *new_gov,\n\t\t\t      unsigned int new_pol);\nstatic bool cpufreq_boost_supported(void);\n\n \nstatic BLOCKING_NOTIFIER_HEAD(cpufreq_policy_notifier_list);\nSRCU_NOTIFIER_HEAD_STATIC(cpufreq_transition_notifier_list);\n\nstatic int off __read_mostly;\nstatic int cpufreq_disabled(void)\n{\n\treturn off;\n}\nvoid disable_cpufreq(void)\n{\n\toff = 1;\n}\nstatic DEFINE_MUTEX(cpufreq_governor_mutex);\n\nbool have_governor_per_policy(void)\n{\n\treturn !!(cpufreq_driver->flags & CPUFREQ_HAVE_GOVERNOR_PER_POLICY);\n}\nEXPORT_SYMBOL_GPL(have_governor_per_policy);\n\nstatic struct kobject *cpufreq_global_kobject;\n\nstruct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy)\n{\n\tif (have_governor_per_policy())\n\t\treturn &policy->kobj;\n\telse\n\t\treturn cpufreq_global_kobject;\n}\nEXPORT_SYMBOL_GPL(get_governor_parent_kobj);\n\nstatic inline u64 get_cpu_idle_time_jiffy(unsigned int cpu, u64 *wall)\n{\n\tstruct kernel_cpustat kcpustat;\n\tu64 cur_wall_time;\n\tu64 idle_time;\n\tu64 busy_time;\n\n\tcur_wall_time = jiffies64_to_nsecs(get_jiffies_64());\n\n\tkcpustat_cpu_fetch(&kcpustat, cpu);\n\n\tbusy_time = kcpustat.cpustat[CPUTIME_USER];\n\tbusy_time += kcpustat.cpustat[CPUTIME_SYSTEM];\n\tbusy_time += kcpustat.cpustat[CPUTIME_IRQ];\n\tbusy_time += kcpustat.cpustat[CPUTIME_SOFTIRQ];\n\tbusy_time += kcpustat.cpustat[CPUTIME_STEAL];\n\tbusy_time += kcpustat.cpustat[CPUTIME_NICE];\n\n\tidle_time = cur_wall_time - busy_time;\n\tif (wall)\n\t\t*wall = div_u64(cur_wall_time, NSEC_PER_USEC);\n\n\treturn div_u64(idle_time, NSEC_PER_USEC);\n}\n\nu64 get_cpu_idle_time(unsigned int cpu, u64 *wall, int io_busy)\n{\n\tu64 idle_time = get_cpu_idle_time_us(cpu, io_busy ? wall : NULL);\n\n\tif (idle_time == -1ULL)\n\t\treturn get_cpu_idle_time_jiffy(cpu, wall);\n\telse if (!io_busy)\n\t\tidle_time += get_cpu_iowait_time_us(cpu, wall);\n\n\treturn idle_time;\n}\nEXPORT_SYMBOL_GPL(get_cpu_idle_time);\n\n \nvoid cpufreq_generic_init(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_frequency_table *table,\n\t\tunsigned int transition_latency)\n{\n\tpolicy->freq_table = table;\n\tpolicy->cpuinfo.transition_latency = transition_latency;\n\n\t \n\tcpumask_setall(policy->cpus);\n}\nEXPORT_SYMBOL_GPL(cpufreq_generic_init);\n\nstruct cpufreq_policy *cpufreq_cpu_get_raw(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);\n\n\treturn policy && cpumask_test_cpu(cpu, policy->cpus) ? policy : NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_get_raw);\n\nunsigned int cpufreq_generic_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);\n\n\tif (!policy || IS_ERR(policy->clk)) {\n\t\tpr_err(\"%s: No %s associated to cpu: %d\\n\",\n\t\t       __func__, policy ? \"clk\" : \"policy\", cpu);\n\t\treturn 0;\n\t}\n\n\treturn clk_get_rate(policy->clk) / 1000;\n}\nEXPORT_SYMBOL_GPL(cpufreq_generic_get);\n\n \nstruct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = NULL;\n\tunsigned long flags;\n\n\tif (WARN_ON(cpu >= nr_cpu_ids))\n\t\treturn NULL;\n\n\t \n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tif (cpufreq_driver) {\n\t\t \n\t\tpolicy = cpufreq_cpu_get_raw(cpu);\n\t\tif (policy)\n\t\t\tkobject_get(&policy->kobj);\n\t}\n\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\treturn policy;\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_get);\n\n \nvoid cpufreq_cpu_put(struct cpufreq_policy *policy)\n{\n\tkobject_put(&policy->kobj);\n}\nEXPORT_SYMBOL_GPL(cpufreq_cpu_put);\n\n \nvoid cpufreq_cpu_release(struct cpufreq_policy *policy)\n{\n\tif (WARN_ON(!policy))\n\t\treturn;\n\n\tlockdep_assert_held(&policy->rwsem);\n\n\tup_write(&policy->rwsem);\n\n\tcpufreq_cpu_put(policy);\n}\n\n \nstruct cpufreq_policy *cpufreq_cpu_acquire(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\n\tif (!policy)\n\t\treturn NULL;\n\n\tdown_write(&policy->rwsem);\n\n\tif (policy_is_inactive(policy)) {\n\t\tcpufreq_cpu_release(policy);\n\t\treturn NULL;\n\t}\n\n\treturn policy;\n}\n\n \n\n \nstatic void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)\n{\n#ifndef CONFIG_SMP\n\tstatic unsigned long l_p_j_ref;\n\tstatic unsigned int l_p_j_ref_freq;\n\n\tif (ci->flags & CPUFREQ_CONST_LOOPS)\n\t\treturn;\n\n\tif (!l_p_j_ref_freq) {\n\t\tl_p_j_ref = loops_per_jiffy;\n\t\tl_p_j_ref_freq = ci->old;\n\t\tpr_debug(\"saving %lu as reference value for loops_per_jiffy; freq is %u kHz\\n\",\n\t\t\t l_p_j_ref, l_p_j_ref_freq);\n\t}\n\tif (val == CPUFREQ_POSTCHANGE && ci->old != ci->new) {\n\t\tloops_per_jiffy = cpufreq_scale(l_p_j_ref, l_p_j_ref_freq,\n\t\t\t\t\t\t\t\tci->new);\n\t\tpr_debug(\"scaling loops_per_jiffy to %lu for frequency %u kHz\\n\",\n\t\t\t loops_per_jiffy, ci->new);\n\t}\n#endif\n}\n\n \nstatic void cpufreq_notify_transition(struct cpufreq_policy *policy,\n\t\t\t\t      struct cpufreq_freqs *freqs,\n\t\t\t\t      unsigned int state)\n{\n\tint cpu;\n\n\tBUG_ON(irqs_disabled());\n\n\tif (cpufreq_disabled())\n\t\treturn;\n\n\tfreqs->policy = policy;\n\tfreqs->flags = cpufreq_driver->flags;\n\tpr_debug(\"notification %u of frequency transition to %u kHz\\n\",\n\t\t state, freqs->new);\n\n\tswitch (state) {\n\tcase CPUFREQ_PRECHANGE:\n\t\t \n\t\tif (policy->cur && policy->cur != freqs->old) {\n\t\t\tpr_debug(\"Warning: CPU frequency is %u, cpufreq assumed %u kHz\\n\",\n\t\t\t\t freqs->old, policy->cur);\n\t\t\tfreqs->old = policy->cur;\n\t\t}\n\n\t\tsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\n\t\t\t\t\t CPUFREQ_PRECHANGE, freqs);\n\n\t\tadjust_jiffies(CPUFREQ_PRECHANGE, freqs);\n\t\tbreak;\n\n\tcase CPUFREQ_POSTCHANGE:\n\t\tadjust_jiffies(CPUFREQ_POSTCHANGE, freqs);\n\t\tpr_debug(\"FREQ: %u - CPUs: %*pbl\\n\", freqs->new,\n\t\t\t cpumask_pr_args(policy->cpus));\n\n\t\tfor_each_cpu(cpu, policy->cpus)\n\t\t\ttrace_cpu_frequency(freqs->new, cpu);\n\n\t\tsrcu_notifier_call_chain(&cpufreq_transition_notifier_list,\n\t\t\t\t\t CPUFREQ_POSTCHANGE, freqs);\n\n\t\tcpufreq_stats_record_transition(policy, freqs->new);\n\t\tpolicy->cur = freqs->new;\n\t}\n}\n\n \nstatic void cpufreq_notify_post_transition(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed)\n{\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\n\tif (!transition_failed)\n\t\treturn;\n\n\tswap(freqs->old, freqs->new);\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_POSTCHANGE);\n}\n\nvoid cpufreq_freq_transition_begin(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs)\n{\n\n\t \n\tWARN_ON(!(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION)\n\t\t\t\t&& current == policy->transition_task);\n\nwait:\n\twait_event(policy->transition_wait, !policy->transition_ongoing);\n\n\tspin_lock(&policy->transition_lock);\n\n\tif (unlikely(policy->transition_ongoing)) {\n\t\tspin_unlock(&policy->transition_lock);\n\t\tgoto wait;\n\t}\n\n\tpolicy->transition_ongoing = true;\n\tpolicy->transition_task = current;\n\n\tspin_unlock(&policy->transition_lock);\n\n\tcpufreq_notify_transition(policy, freqs, CPUFREQ_PRECHANGE);\n}\nEXPORT_SYMBOL_GPL(cpufreq_freq_transition_begin);\n\nvoid cpufreq_freq_transition_end(struct cpufreq_policy *policy,\n\t\tstruct cpufreq_freqs *freqs, int transition_failed)\n{\n\tif (WARN_ON(!policy->transition_ongoing))\n\t\treturn;\n\n\tcpufreq_notify_post_transition(policy, freqs, transition_failed);\n\n\tarch_set_freq_scale(policy->related_cpus,\n\t\t\t    policy->cur,\n\t\t\t    policy->cpuinfo.max_freq);\n\n\tspin_lock(&policy->transition_lock);\n\tpolicy->transition_ongoing = false;\n\tpolicy->transition_task = NULL;\n\tspin_unlock(&policy->transition_lock);\n\n\twake_up(&policy->transition_wait);\n}\nEXPORT_SYMBOL_GPL(cpufreq_freq_transition_end);\n\n \nstatic int cpufreq_fast_switch_count;\nstatic DEFINE_MUTEX(cpufreq_fast_switch_lock);\n\nstatic void cpufreq_list_transition_notifiers(void)\n{\n\tstruct notifier_block *nb;\n\n\tpr_info(\"Registered transition notifiers:\\n\");\n\n\tmutex_lock(&cpufreq_transition_notifier_list.mutex);\n\n\tfor (nb = cpufreq_transition_notifier_list.head; nb; nb = nb->next)\n\t\tpr_info(\"%pS\\n\", nb->notifier_call);\n\n\tmutex_unlock(&cpufreq_transition_notifier_list.mutex);\n}\n\n \nvoid cpufreq_enable_fast_switch(struct cpufreq_policy *policy)\n{\n\tlockdep_assert_held(&policy->rwsem);\n\n\tif (!policy->fast_switch_possible)\n\t\treturn;\n\n\tmutex_lock(&cpufreq_fast_switch_lock);\n\tif (cpufreq_fast_switch_count >= 0) {\n\t\tcpufreq_fast_switch_count++;\n\t\tpolicy->fast_switch_enabled = true;\n\t} else {\n\t\tpr_warn(\"CPU%u: Fast frequency switching not enabled\\n\",\n\t\t\tpolicy->cpu);\n\t\tcpufreq_list_transition_notifiers();\n\t}\n\tmutex_unlock(&cpufreq_fast_switch_lock);\n}\nEXPORT_SYMBOL_GPL(cpufreq_enable_fast_switch);\n\n \nvoid cpufreq_disable_fast_switch(struct cpufreq_policy *policy)\n{\n\tmutex_lock(&cpufreq_fast_switch_lock);\n\tif (policy->fast_switch_enabled) {\n\t\tpolicy->fast_switch_enabled = false;\n\t\tif (!WARN_ON(cpufreq_fast_switch_count <= 0))\n\t\t\tcpufreq_fast_switch_count--;\n\t}\n\tmutex_unlock(&cpufreq_fast_switch_lock);\n}\nEXPORT_SYMBOL_GPL(cpufreq_disable_fast_switch);\n\nstatic unsigned int __resolve_freq(struct cpufreq_policy *policy,\n\t\tunsigned int target_freq, unsigned int relation)\n{\n\tunsigned int idx;\n\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\n\tif (!policy->freq_table)\n\t\treturn target_freq;\n\n\tidx = cpufreq_frequency_table_target(policy, target_freq, relation);\n\tpolicy->cached_resolved_idx = idx;\n\tpolicy->cached_target_freq = target_freq;\n\treturn policy->freq_table[idx].frequency;\n}\n\n \nunsigned int cpufreq_driver_resolve_freq(struct cpufreq_policy *policy,\n\t\t\t\t\t unsigned int target_freq)\n{\n\treturn __resolve_freq(policy, target_freq, CPUFREQ_RELATION_LE);\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_resolve_freq);\n\nunsigned int cpufreq_policy_transition_delay_us(struct cpufreq_policy *policy)\n{\n\tunsigned int latency;\n\n\tif (policy->transition_delay_us)\n\t\treturn policy->transition_delay_us;\n\n\tlatency = policy->cpuinfo.transition_latency / NSEC_PER_USEC;\n\tif (latency) {\n\t\t \n\t\treturn min(latency * LATENCY_MULTIPLIER, (unsigned int)10000);\n\t}\n\n\treturn LATENCY_MULTIPLIER;\n}\nEXPORT_SYMBOL_GPL(cpufreq_policy_transition_delay_us);\n\n \nstatic ssize_t show_boost(struct kobject *kobj,\n\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", cpufreq_driver->boost_enabled);\n}\n\nstatic ssize_t store_boost(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tint ret, enable;\n\n\tret = sscanf(buf, \"%d\", &enable);\n\tif (ret != 1 || enable < 0 || enable > 1)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_boost_trigger_state(enable)) {\n\t\tpr_err(\"%s: Cannot %s BOOST!\\n\",\n\t\t       __func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"%s: cpufreq BOOST %s\\n\",\n\t\t __func__, enable ? \"enabled\" : \"disabled\");\n\n\treturn count;\n}\ndefine_one_global_rw(boost);\n\nstatic ssize_t show_local_boost(struct cpufreq_policy *policy, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", policy->boost_enabled);\n}\n\nstatic ssize_t store_local_boost(struct cpufreq_policy *policy,\n\t\t\t\t const char *buf, size_t count)\n{\n\tint ret, enable;\n\n\tret = kstrtoint(buf, 10, &enable);\n\tif (ret || enable < 0 || enable > 1)\n\t\treturn -EINVAL;\n\n\tif (!cpufreq_driver->boost_enabled)\n\t\treturn -EINVAL;\n\n\tif (policy->boost_enabled == enable)\n\t\treturn count;\n\n\tcpus_read_lock();\n\tret = cpufreq_driver->set_boost(policy, enable);\n\tcpus_read_unlock();\n\n\tif (ret)\n\t\treturn ret;\n\n\tpolicy->boost_enabled = enable;\n\n\treturn count;\n}\n\nstatic struct freq_attr local_boost = __ATTR(boost, 0644, show_local_boost, store_local_boost);\n\nstatic struct cpufreq_governor *find_governor(const char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tfor_each_governor(t)\n\t\tif (!strncasecmp(str_governor, t->name, CPUFREQ_NAME_LEN))\n\t\t\treturn t;\n\n\treturn NULL;\n}\n\nstatic struct cpufreq_governor *get_governor(const char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tt = find_governor(str_governor);\n\tif (!t)\n\t\tgoto unlock;\n\n\tif (!try_module_get(t->owner))\n\t\tt = NULL;\n\nunlock:\n\tmutex_unlock(&cpufreq_governor_mutex);\n\n\treturn t;\n}\n\nstatic unsigned int cpufreq_parse_policy(char *str_governor)\n{\n\tif (!strncasecmp(str_governor, \"performance\", CPUFREQ_NAME_LEN))\n\t\treturn CPUFREQ_POLICY_PERFORMANCE;\n\n\tif (!strncasecmp(str_governor, \"powersave\", CPUFREQ_NAME_LEN))\n\t\treturn CPUFREQ_POLICY_POWERSAVE;\n\n\treturn CPUFREQ_POLICY_UNKNOWN;\n}\n\n \nstatic struct cpufreq_governor *cpufreq_parse_governor(char *str_governor)\n{\n\tstruct cpufreq_governor *t;\n\n\tt = get_governor(str_governor);\n\tif (t)\n\t\treturn t;\n\n\tif (request_module(\"cpufreq_%s\", str_governor))\n\t\treturn NULL;\n\n\treturn get_governor(str_governor);\n}\n\n \n\n#define show_one(file_name, object)\t\t\t\\\nstatic ssize_t show_##file_name\t\t\t\t\\\n(struct cpufreq_policy *policy, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", policy->object);\t\\\n}\n\nshow_one(cpuinfo_min_freq, cpuinfo.min_freq);\nshow_one(cpuinfo_max_freq, cpuinfo.max_freq);\nshow_one(cpuinfo_transition_latency, cpuinfo.transition_latency);\nshow_one(scaling_min_freq, min);\nshow_one(scaling_max_freq, max);\n\n__weak unsigned int arch_freq_get_on_cpu(int cpu)\n{\n\treturn 0;\n}\n\nstatic ssize_t show_scaling_cur_freq(struct cpufreq_policy *policy, char *buf)\n{\n\tssize_t ret;\n\tunsigned int freq;\n\n\tfreq = arch_freq_get_on_cpu(policy->cpu);\n\tif (freq)\n\t\tret = sprintf(buf, \"%u\\n\", freq);\n\telse if (cpufreq_driver->setpolicy && cpufreq_driver->get)\n\t\tret = sprintf(buf, \"%u\\n\", cpufreq_driver->get(policy->cpu));\n\telse\n\t\tret = sprintf(buf, \"%u\\n\", policy->cur);\n\treturn ret;\n}\n\n \n#define store_one(file_name, object)\t\t\t\\\nstatic ssize_t store_##file_name\t\t\t\t\t\\\n(struct cpufreq_policy *policy, const char *buf, size_t count)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long val;\t\t\t\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = kstrtoul(buf, 0, &val);\t\t\t\t\t\\\n\tif (ret)\t\t\t\t\t\t\t\\\n\t\treturn ret;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = freq_qos_update_request(policy->object##_freq_req, val);\\\n\treturn ret >= 0 ? count : ret;\t\t\t\t\t\\\n}\n\nstore_one(scaling_min_freq, min);\nstore_one(scaling_max_freq, max);\n\n \nstatic ssize_t show_cpuinfo_cur_freq(struct cpufreq_policy *policy,\n\t\t\t\t\tchar *buf)\n{\n\tunsigned int cur_freq = __cpufreq_get(policy);\n\n\tif (cur_freq)\n\t\treturn sprintf(buf, \"%u\\n\", cur_freq);\n\n\treturn sprintf(buf, \"<unknown>\\n\");\n}\n\n \nstatic ssize_t show_scaling_governor(struct cpufreq_policy *policy, char *buf)\n{\n\tif (policy->policy == CPUFREQ_POLICY_POWERSAVE)\n\t\treturn sprintf(buf, \"powersave\\n\");\n\telse if (policy->policy == CPUFREQ_POLICY_PERFORMANCE)\n\t\treturn sprintf(buf, \"performance\\n\");\n\telse if (policy->governor)\n\t\treturn scnprintf(buf, CPUFREQ_NAME_PLEN, \"%s\\n\",\n\t\t\t\tpolicy->governor->name);\n\treturn -EINVAL;\n}\n\n \nstatic ssize_t store_scaling_governor(struct cpufreq_policy *policy,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tchar str_governor[16];\n\tint ret;\n\n\tret = sscanf(buf, \"%15s\", str_governor);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_driver->setpolicy) {\n\t\tunsigned int new_pol;\n\n\t\tnew_pol = cpufreq_parse_policy(str_governor);\n\t\tif (!new_pol)\n\t\t\treturn -EINVAL;\n\n\t\tret = cpufreq_set_policy(policy, NULL, new_pol);\n\t} else {\n\t\tstruct cpufreq_governor *new_gov;\n\n\t\tnew_gov = cpufreq_parse_governor(str_governor);\n\t\tif (!new_gov)\n\t\t\treturn -EINVAL;\n\n\t\tret = cpufreq_set_policy(policy, new_gov,\n\t\t\t\t\t CPUFREQ_POLICY_UNKNOWN);\n\n\t\tmodule_put(new_gov->owner);\n\t}\n\n\treturn ret ? ret : count;\n}\n\n \nstatic ssize_t show_scaling_driver(struct cpufreq_policy *policy, char *buf)\n{\n\treturn scnprintf(buf, CPUFREQ_NAME_PLEN, \"%s\\n\", cpufreq_driver->name);\n}\n\n \nstatic ssize_t show_scaling_available_governors(struct cpufreq_policy *policy,\n\t\t\t\t\t\tchar *buf)\n{\n\tssize_t i = 0;\n\tstruct cpufreq_governor *t;\n\n\tif (!has_target()) {\n\t\ti += sprintf(buf, \"performance powersave\");\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tfor_each_governor(t) {\n\t\tif (i >= (ssize_t) ((PAGE_SIZE / sizeof(char))\n\t\t    - (CPUFREQ_NAME_LEN + 2)))\n\t\t\tbreak;\n\t\ti += scnprintf(&buf[i], CPUFREQ_NAME_PLEN, \"%s \", t->name);\n\t}\n\tmutex_unlock(&cpufreq_governor_mutex);\nout:\n\ti += sprintf(&buf[i], \"\\n\");\n\treturn i;\n}\n\nssize_t cpufreq_show_cpus(const struct cpumask *mask, char *buf)\n{\n\tssize_t i = 0;\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, mask) {\n\t\ti += scnprintf(&buf[i], (PAGE_SIZE - i - 2), \"%u \", cpu);\n\t\tif (i >= (PAGE_SIZE - 5))\n\t\t\tbreak;\n\t}\n\n\t \n\ti--;\n\n\ti += sprintf(&buf[i], \"\\n\");\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(cpufreq_show_cpus);\n\n \nstatic ssize_t show_related_cpus(struct cpufreq_policy *policy, char *buf)\n{\n\treturn cpufreq_show_cpus(policy->related_cpus, buf);\n}\n\n \nstatic ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)\n{\n\treturn cpufreq_show_cpus(policy->cpus, buf);\n}\n\nstatic ssize_t store_scaling_setspeed(struct cpufreq_policy *policy,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tunsigned int freq = 0;\n\tunsigned int ret;\n\n\tif (!policy->governor || !policy->governor->store_setspeed)\n\t\treturn -EINVAL;\n\n\tret = sscanf(buf, \"%u\", &freq);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tpolicy->governor->store_setspeed(policy, freq);\n\n\treturn count;\n}\n\nstatic ssize_t show_scaling_setspeed(struct cpufreq_policy *policy, char *buf)\n{\n\tif (!policy->governor || !policy->governor->show_setspeed)\n\t\treturn sprintf(buf, \"<unsupported>\\n\");\n\n\treturn policy->governor->show_setspeed(policy, buf);\n}\n\n \nstatic ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)\n{\n\tunsigned int limit;\n\tint ret;\n\tret = cpufreq_driver->bios_limit(policy->cpu, &limit);\n\tif (!ret)\n\t\treturn sprintf(buf, \"%u\\n\", limit);\n\treturn sprintf(buf, \"%u\\n\", policy->cpuinfo.max_freq);\n}\n\ncpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);\ncpufreq_freq_attr_ro(cpuinfo_min_freq);\ncpufreq_freq_attr_ro(cpuinfo_max_freq);\ncpufreq_freq_attr_ro(cpuinfo_transition_latency);\ncpufreq_freq_attr_ro(scaling_available_governors);\ncpufreq_freq_attr_ro(scaling_driver);\ncpufreq_freq_attr_ro(scaling_cur_freq);\ncpufreq_freq_attr_ro(bios_limit);\ncpufreq_freq_attr_ro(related_cpus);\ncpufreq_freq_attr_ro(affected_cpus);\ncpufreq_freq_attr_rw(scaling_min_freq);\ncpufreq_freq_attr_rw(scaling_max_freq);\ncpufreq_freq_attr_rw(scaling_governor);\ncpufreq_freq_attr_rw(scaling_setspeed);\n\nstatic struct attribute *cpufreq_attrs[] = {\n\t&cpuinfo_min_freq.attr,\n\t&cpuinfo_max_freq.attr,\n\t&cpuinfo_transition_latency.attr,\n\t&scaling_min_freq.attr,\n\t&scaling_max_freq.attr,\n\t&affected_cpus.attr,\n\t&related_cpus.attr,\n\t&scaling_governor.attr,\n\t&scaling_driver.attr,\n\t&scaling_available_governors.attr,\n\t&scaling_setspeed.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(cpufreq);\n\n#define to_policy(k) container_of(k, struct cpufreq_policy, kobj)\n#define to_attr(a) container_of(a, struct freq_attr, attr)\n\nstatic ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tstruct freq_attr *fattr = to_attr(attr);\n\tssize_t ret = -EBUSY;\n\n\tif (!fattr->show)\n\t\treturn -EIO;\n\n\tdown_read(&policy->rwsem);\n\tif (likely(!policy_is_inactive(policy)))\n\t\tret = fattr->show(policy, buf);\n\tup_read(&policy->rwsem);\n\n\treturn ret;\n}\n\nstatic ssize_t store(struct kobject *kobj, struct attribute *attr,\n\t\t     const char *buf, size_t count)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tstruct freq_attr *fattr = to_attr(attr);\n\tssize_t ret = -EBUSY;\n\n\tif (!fattr->store)\n\t\treturn -EIO;\n\n\tdown_write(&policy->rwsem);\n\tif (likely(!policy_is_inactive(policy)))\n\t\tret = fattr->store(policy, buf, count);\n\tup_write(&policy->rwsem);\n\n\treturn ret;\n}\n\nstatic void cpufreq_sysfs_release(struct kobject *kobj)\n{\n\tstruct cpufreq_policy *policy = to_policy(kobj);\n\tpr_debug(\"last reference is dropped\\n\");\n\tcomplete(&policy->kobj_unregister);\n}\n\nstatic const struct sysfs_ops sysfs_ops = {\n\t.show\t= show,\n\t.store\t= store,\n};\n\nstatic const struct kobj_type ktype_cpufreq = {\n\t.sysfs_ops\t= &sysfs_ops,\n\t.default_groups\t= cpufreq_groups,\n\t.release\t= cpufreq_sysfs_release,\n};\n\nstatic void add_cpu_dev_symlink(struct cpufreq_policy *policy, unsigned int cpu,\n\t\t\t\tstruct device *dev)\n{\n\tif (unlikely(!dev))\n\t\treturn;\n\n\tif (cpumask_test_and_set_cpu(cpu, policy->real_cpus))\n\t\treturn;\n\n\tdev_dbg(dev, \"%s: Adding symlink\\n\", __func__);\n\tif (sysfs_create_link(&dev->kobj, &policy->kobj, \"cpufreq\"))\n\t\tdev_err(dev, \"cpufreq symlink creation failed\\n\");\n}\n\nstatic void remove_cpu_dev_symlink(struct cpufreq_policy *policy, int cpu,\n\t\t\t\t   struct device *dev)\n{\n\tdev_dbg(dev, \"%s: Removing symlink\\n\", __func__);\n\tsysfs_remove_link(&dev->kobj, \"cpufreq\");\n\tcpumask_clear_cpu(cpu, policy->real_cpus);\n}\n\nstatic int cpufreq_add_dev_interface(struct cpufreq_policy *policy)\n{\n\tstruct freq_attr **drv_attr;\n\tint ret = 0;\n\n\t \n\tdrv_attr = cpufreq_driver->attr;\n\twhile (drv_attr && *drv_attr) {\n\t\tret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdrv_attr++;\n\t}\n\tif (cpufreq_driver->get) {\n\t\tret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cpufreq_driver->bios_limit) {\n\t\tret = sysfs_create_file(&policy->kobj, &bios_limit.attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (cpufreq_boost_supported()) {\n\t\tret = sysfs_create_file(&policy->kobj, &local_boost.attr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int cpufreq_init_policy(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_governor *gov = NULL;\n\tunsigned int pol = CPUFREQ_POLICY_UNKNOWN;\n\tint ret;\n\n\tif (has_target()) {\n\t\t \n\t\tgov = get_governor(policy->last_governor);\n\t\tif (gov) {\n\t\t\tpr_debug(\"Restoring governor %s for cpu %d\\n\",\n\t\t\t\t gov->name, policy->cpu);\n\t\t} else {\n\t\t\tgov = get_governor(default_governor);\n\t\t}\n\n\t\tif (!gov) {\n\t\t\tgov = cpufreq_default_governor();\n\t\t\t__module_get(gov->owner);\n\t\t}\n\n\t} else {\n\n\t\t \n\t\tif (policy->last_policy) {\n\t\t\tpol = policy->last_policy;\n\t\t} else {\n\t\t\tpol = cpufreq_parse_policy(default_governor);\n\t\t\t \n\t\t\tif (pol == CPUFREQ_POLICY_UNKNOWN)\n\t\t\t\tpol = policy->policy;\n\t\t}\n\t\tif (pol != CPUFREQ_POLICY_PERFORMANCE &&\n\t\t    pol != CPUFREQ_POLICY_POWERSAVE)\n\t\t\treturn -ENODATA;\n\t}\n\n\tret = cpufreq_set_policy(policy, gov, pol);\n\tif (gov)\n\t\tmodule_put(gov->owner);\n\n\treturn ret;\n}\n\nstatic int cpufreq_add_policy_cpu(struct cpufreq_policy *policy, unsigned int cpu)\n{\n\tint ret = 0;\n\n\t \n\tif (cpumask_test_cpu(cpu, policy->cpus))\n\t\treturn 0;\n\n\tdown_write(&policy->rwsem);\n\tif (has_target())\n\t\tcpufreq_stop_governor(policy);\n\n\tcpumask_set_cpu(cpu, policy->cpus);\n\n\tif (has_target()) {\n\t\tret = cpufreq_start_governor(policy);\n\t\tif (ret)\n\t\t\tpr_err(\"%s: Failed to start governor\\n\", __func__);\n\t}\n\tup_write(&policy->rwsem);\n\treturn ret;\n}\n\nvoid refresh_frequency_limits(struct cpufreq_policy *policy)\n{\n\tif (!policy_is_inactive(policy)) {\n\t\tpr_debug(\"updating policy for CPU %u\\n\", policy->cpu);\n\n\t\tcpufreq_set_policy(policy, policy->governor, policy->policy);\n\t}\n}\nEXPORT_SYMBOL(refresh_frequency_limits);\n\nstatic void handle_update(struct work_struct *work)\n{\n\tstruct cpufreq_policy *policy =\n\t\tcontainer_of(work, struct cpufreq_policy, update);\n\n\tpr_debug(\"handle_update for cpu %u called\\n\", policy->cpu);\n\tdown_write(&policy->rwsem);\n\trefresh_frequency_limits(policy);\n\tup_write(&policy->rwsem);\n}\n\nstatic int cpufreq_notifier_min(struct notifier_block *nb, unsigned long freq,\n\t\t\t\tvoid *data)\n{\n\tstruct cpufreq_policy *policy = container_of(nb, struct cpufreq_policy, nb_min);\n\n\tschedule_work(&policy->update);\n\treturn 0;\n}\n\nstatic int cpufreq_notifier_max(struct notifier_block *nb, unsigned long freq,\n\t\t\t\tvoid *data)\n{\n\tstruct cpufreq_policy *policy = container_of(nb, struct cpufreq_policy, nb_max);\n\n\tschedule_work(&policy->update);\n\treturn 0;\n}\n\nstatic void cpufreq_policy_put_kobj(struct cpufreq_policy *policy)\n{\n\tstruct kobject *kobj;\n\tstruct completion *cmp;\n\n\tdown_write(&policy->rwsem);\n\tcpufreq_stats_free_table(policy);\n\tkobj = &policy->kobj;\n\tcmp = &policy->kobj_unregister;\n\tup_write(&policy->rwsem);\n\tkobject_put(kobj);\n\n\t \n\tpr_debug(\"waiting for dropping of refcount\\n\");\n\twait_for_completion(cmp);\n\tpr_debug(\"wait complete\\n\");\n}\n\nstatic struct cpufreq_policy *cpufreq_policy_alloc(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tstruct device *dev = get_cpu_device(cpu);\n\tint ret;\n\n\tif (!dev)\n\t\treturn NULL;\n\n\tpolicy = kzalloc(sizeof(*policy), GFP_KERNEL);\n\tif (!policy)\n\t\treturn NULL;\n\n\tif (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL))\n\t\tgoto err_free_policy;\n\n\tif (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL))\n\t\tgoto err_free_cpumask;\n\n\tif (!zalloc_cpumask_var(&policy->real_cpus, GFP_KERNEL))\n\t\tgoto err_free_rcpumask;\n\n\tinit_completion(&policy->kobj_unregister);\n\tret = kobject_init_and_add(&policy->kobj, &ktype_cpufreq,\n\t\t\t\t   cpufreq_global_kobject, \"policy%u\", cpu);\n\tif (ret) {\n\t\tdev_err(dev, \"%s: failed to init policy->kobj: %d\\n\", __func__, ret);\n\t\t \n\t\tkobject_put(&policy->kobj);\n\t\tgoto err_free_real_cpus;\n\t}\n\n\tfreq_constraints_init(&policy->constraints);\n\n\tpolicy->nb_min.notifier_call = cpufreq_notifier_min;\n\tpolicy->nb_max.notifier_call = cpufreq_notifier_max;\n\n\tret = freq_qos_add_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t    &policy->nb_min);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register MIN QoS notifier: %d (CPU%u)\\n\",\n\t\t\tret, cpu);\n\t\tgoto err_kobj_remove;\n\t}\n\n\tret = freq_qos_add_notifier(&policy->constraints, FREQ_QOS_MAX,\n\t\t\t\t    &policy->nb_max);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register MAX QoS notifier: %d (CPU%u)\\n\",\n\t\t\tret, cpu);\n\t\tgoto err_min_qos_notifier;\n\t}\n\n\tINIT_LIST_HEAD(&policy->policy_list);\n\tinit_rwsem(&policy->rwsem);\n\tspin_lock_init(&policy->transition_lock);\n\tinit_waitqueue_head(&policy->transition_wait);\n\tINIT_WORK(&policy->update, handle_update);\n\n\tpolicy->cpu = cpu;\n\treturn policy;\n\nerr_min_qos_notifier:\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t &policy->nb_min);\nerr_kobj_remove:\n\tcpufreq_policy_put_kobj(policy);\nerr_free_real_cpus:\n\tfree_cpumask_var(policy->real_cpus);\nerr_free_rcpumask:\n\tfree_cpumask_var(policy->related_cpus);\nerr_free_cpumask:\n\tfree_cpumask_var(policy->cpus);\nerr_free_policy:\n\tkfree(policy);\n\n\treturn NULL;\n}\n\nstatic void cpufreq_policy_free(struct cpufreq_policy *policy)\n{\n\tunsigned long flags;\n\tint cpu;\n\n\t \n\tif (unlikely(!policy_is_inactive(policy)))\n\t\tpr_warn(\"%s: Freeing active policy\\n\", __func__);\n\n\t \n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tlist_del(&policy->policy_list);\n\n\tfor_each_cpu(cpu, policy->related_cpus)\n\t\tper_cpu(cpufreq_cpu_data, cpu) = NULL;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MAX,\n\t\t\t\t &policy->nb_max);\n\tfreq_qos_remove_notifier(&policy->constraints, FREQ_QOS_MIN,\n\t\t\t\t &policy->nb_min);\n\n\t \n\tcancel_work_sync(&policy->update);\n\n\tif (policy->max_freq_req) {\n\t\t \n\t\tblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\n\t\t\t\t\t     CPUFREQ_REMOVE_POLICY, policy);\n\t\tfreq_qos_remove_request(policy->max_freq_req);\n\t}\n\n\tfreq_qos_remove_request(policy->min_freq_req);\n\tkfree(policy->min_freq_req);\n\n\tcpufreq_policy_put_kobj(policy);\n\tfree_cpumask_var(policy->real_cpus);\n\tfree_cpumask_var(policy->related_cpus);\n\tfree_cpumask_var(policy->cpus);\n\tkfree(policy);\n}\n\nstatic int cpufreq_online(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tbool new_policy;\n\tunsigned long flags;\n\tunsigned int j;\n\tint ret;\n\n\tpr_debug(\"%s: bringing CPU%u online\\n\", __func__, cpu);\n\n\t \n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy) {\n\t\tWARN_ON(!cpumask_test_cpu(cpu, policy->related_cpus));\n\t\tif (!policy_is_inactive(policy))\n\t\t\treturn cpufreq_add_policy_cpu(policy, cpu);\n\n\t\t \n\t\tnew_policy = false;\n\t\tdown_write(&policy->rwsem);\n\t\tpolicy->cpu = cpu;\n\t\tpolicy->governor = NULL;\n\t} else {\n\t\tnew_policy = true;\n\t\tpolicy = cpufreq_policy_alloc(cpu);\n\t\tif (!policy)\n\t\t\treturn -ENOMEM;\n\t\tdown_write(&policy->rwsem);\n\t}\n\n\tif (!new_policy && cpufreq_driver->online) {\n\t\t \n\t\tcpumask_copy(policy->cpus, policy->related_cpus);\n\n\t\tret = cpufreq_driver->online(policy);\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: %d: initialization failed\\n\", __func__,\n\t\t\t\t __LINE__);\n\t\t\tgoto out_exit_policy;\n\t\t}\n\t} else {\n\t\tcpumask_copy(policy->cpus, cpumask_of(cpu));\n\n\t\t \n\t\tret = cpufreq_driver->init(policy);\n\t\tif (ret) {\n\t\t\tpr_debug(\"%s: %d: initialization failed\\n\", __func__,\n\t\t\t\t __LINE__);\n\t\t\tgoto out_free_policy;\n\t\t}\n\n\t\t \n\t\tret = cpufreq_table_validate_and_sort(policy);\n\t\tif (ret)\n\t\t\tgoto out_offline_policy;\n\n\t\t \n\t\tcpumask_copy(policy->related_cpus, policy->cpus);\n\t}\n\n\t \n\tcpumask_and(policy->cpus, policy->cpus, cpu_online_mask);\n\n\tif (new_policy) {\n\t\tfor_each_cpu(j, policy->related_cpus) {\n\t\t\tper_cpu(cpufreq_cpu_data, j) = policy;\n\t\t\tadd_cpu_dev_symlink(policy, j, get_cpu_device(j));\n\t\t}\n\n\t\tpolicy->min_freq_req = kzalloc(2 * sizeof(*policy->min_freq_req),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!policy->min_freq_req) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   policy->min_freq_req, FREQ_QOS_MIN,\n\t\t\t\t\t   FREQ_QOS_MIN_DEFAULT_VALUE);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tkfree(policy->min_freq_req);\n\t\t\tpolicy->min_freq_req = NULL;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\t \n\t\tpolicy->max_freq_req = policy->min_freq_req + 1;\n\n\t\tret = freq_qos_add_request(&policy->constraints,\n\t\t\t\t\t   policy->max_freq_req, FREQ_QOS_MAX,\n\t\t\t\t\t   FREQ_QOS_MAX_DEFAULT_VALUE);\n\t\tif (ret < 0) {\n\t\t\tpolicy->max_freq_req = NULL;\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\n\t\tblocking_notifier_call_chain(&cpufreq_policy_notifier_list,\n\t\t\t\tCPUFREQ_CREATE_POLICY, policy);\n\t}\n\n\tif (cpufreq_driver->get && has_target()) {\n\t\tpolicy->cur = cpufreq_driver->get(policy->cpu);\n\t\tif (!policy->cur) {\n\t\t\tret = -EIO;\n\t\t\tpr_err(\"%s: ->get() failed\\n\", __func__);\n\t\t\tgoto out_destroy_policy;\n\t\t}\n\t}\n\n\t \n\tif ((cpufreq_driver->flags & CPUFREQ_NEED_INITIAL_FREQ_CHECK)\n\t    && has_target()) {\n\t\tunsigned int old_freq = policy->cur;\n\n\t\t \n\t\tret = cpufreq_frequency_table_get_index(policy, old_freq);\n\t\tif (ret == -EINVAL) {\n\t\t\tret = __cpufreq_driver_target(policy, old_freq - 1,\n\t\t\t\t\t\t      CPUFREQ_RELATION_L);\n\n\t\t\t \n\t\t\tBUG_ON(ret);\n\t\t\tpr_info(\"%s: CPU%d: Running at unlisted initial frequency: %u KHz, changing to: %u KHz\\n\",\n\t\t\t\t__func__, policy->cpu, old_freq, policy->cur);\n\t\t}\n\t}\n\n\tif (new_policy) {\n\t\tret = cpufreq_add_dev_interface(policy);\n\t\tif (ret)\n\t\t\tgoto out_destroy_policy;\n\n\t\tcpufreq_stats_create_table(policy);\n\n\t\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\t\tlist_add(&policy->policy_list, &cpufreq_policy_list);\n\t\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\t\t \n\t\tif (cpufreq_driver->register_em)\n\t\t\tcpufreq_driver->register_em(policy);\n\t}\n\n\tret = cpufreq_init_policy(policy);\n\tif (ret) {\n\t\tpr_err(\"%s: Failed to initialize policy for cpu: %d (%d)\\n\",\n\t\t       __func__, cpu, ret);\n\t\tgoto out_destroy_policy;\n\t}\n\n\tup_write(&policy->rwsem);\n\n\tkobject_uevent(&policy->kobj, KOBJ_ADD);\n\n\t \n\tif (cpufreq_driver->ready)\n\t\tcpufreq_driver->ready(policy);\n\n\tif (cpufreq_thermal_control_enabled(cpufreq_driver))\n\t\tpolicy->cdev = of_cpufreq_cooling_register(policy);\n\n\tpr_debug(\"initialization complete\\n\");\n\n\treturn 0;\n\nout_destroy_policy:\n\tfor_each_cpu(j, policy->real_cpus)\n\t\tremove_cpu_dev_symlink(policy, j, get_cpu_device(j));\n\nout_offline_policy:\n\tif (cpufreq_driver->offline)\n\t\tcpufreq_driver->offline(policy);\n\nout_exit_policy:\n\tif (cpufreq_driver->exit)\n\t\tcpufreq_driver->exit(policy);\n\nout_free_policy:\n\tcpumask_clear(policy->cpus);\n\tup_write(&policy->rwsem);\n\n\tcpufreq_policy_free(policy);\n\treturn ret;\n}\n\n \nstatic int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned cpu = dev->id;\n\tint ret;\n\n\tdev_dbg(dev, \"%s: adding CPU%u\\n\", __func__, cpu);\n\n\tif (cpu_online(cpu)) {\n\t\tret = cpufreq_online(cpu);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tpolicy = per_cpu(cpufreq_cpu_data, cpu);\n\tif (policy)\n\t\tadd_cpu_dev_symlink(policy, cpu, dev);\n\n\treturn 0;\n}\n\nstatic void __cpufreq_offline(unsigned int cpu, struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (has_target())\n\t\tcpufreq_stop_governor(policy);\n\n\tcpumask_clear_cpu(cpu, policy->cpus);\n\n\tif (!policy_is_inactive(policy)) {\n\t\t \n\t\tif (cpu == policy->cpu)\n\t\t\tpolicy->cpu = cpumask_any(policy->cpus);\n\n\t\t \n\t\tif (has_target()) {\n\t\t\tret = cpufreq_start_governor(policy);\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: Failed to start governor\\n\", __func__);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (has_target())\n\t\tstrncpy(policy->last_governor, policy->governor->name,\n\t\t\tCPUFREQ_NAME_LEN);\n\telse\n\t\tpolicy->last_policy = policy->policy;\n\n\tif (cpufreq_thermal_control_enabled(cpufreq_driver)) {\n\t\tcpufreq_cooling_unregister(policy->cdev);\n\t\tpolicy->cdev = NULL;\n\t}\n\n\tif (has_target())\n\t\tcpufreq_exit_governor(policy);\n\n\t \n\tif (cpufreq_driver->offline) {\n\t\tcpufreq_driver->offline(policy);\n\t} else if (cpufreq_driver->exit) {\n\t\tcpufreq_driver->exit(policy);\n\t\tpolicy->freq_table = NULL;\n\t}\n}\n\nstatic int cpufreq_offline(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\n\tpr_debug(\"%s: unregistering CPU %u\\n\", __func__, cpu);\n\n\tpolicy = cpufreq_cpu_get_raw(cpu);\n\tif (!policy) {\n\t\tpr_debug(\"%s: No cpu_data found\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tdown_write(&policy->rwsem);\n\n\t__cpufreq_offline(cpu, policy);\n\n\tup_write(&policy->rwsem);\n\treturn 0;\n}\n\n \nstatic void cpufreq_remove_dev(struct device *dev, struct subsys_interface *sif)\n{\n\tunsigned int cpu = dev->id;\n\tstruct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);\n\n\tif (!policy)\n\t\treturn;\n\n\tdown_write(&policy->rwsem);\n\n\tif (cpu_online(cpu))\n\t\t__cpufreq_offline(cpu, policy);\n\n\tremove_cpu_dev_symlink(policy, cpu, dev);\n\n\tif (!cpumask_empty(policy->real_cpus)) {\n\t\tup_write(&policy->rwsem);\n\t\treturn;\n\t}\n\n\t \n\tif (cpufreq_driver->offline)\n\t\tcpufreq_driver->exit(policy);\n\n\tup_write(&policy->rwsem);\n\n\tcpufreq_policy_free(policy);\n}\n\n \nstatic void cpufreq_out_of_sync(struct cpufreq_policy *policy,\n\t\t\t\tunsigned int new_freq)\n{\n\tstruct cpufreq_freqs freqs;\n\n\tpr_debug(\"Warning: CPU frequency out of sync: cpufreq and timing core thinks of %u, is %u kHz\\n\",\n\t\t policy->cur, new_freq);\n\n\tfreqs.old = policy->cur;\n\tfreqs.new = new_freq;\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\tcpufreq_freq_transition_end(policy, &freqs, 0);\n}\n\nstatic unsigned int cpufreq_verify_current_freq(struct cpufreq_policy *policy, bool update)\n{\n\tunsigned int new_freq;\n\n\tnew_freq = cpufreq_driver->get(policy->cpu);\n\tif (!new_freq)\n\t\treturn 0;\n\n\t \n\tif (policy->fast_switch_enabled || !has_target())\n\t\treturn new_freq;\n\n\tif (policy->cur != new_freq) {\n\t\t \n\t\tif (abs(policy->cur - new_freq) < KHZ_PER_MHZ)\n\t\t\treturn policy->cur;\n\n\t\tcpufreq_out_of_sync(policy, new_freq);\n\t\tif (update)\n\t\t\tschedule_work(&policy->update);\n\t}\n\n\treturn new_freq;\n}\n\n \nunsigned int cpufreq_quick_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned int ret_freq = 0;\n\tunsigned long flags;\n\n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tif (cpufreq_driver && cpufreq_driver->setpolicy && cpufreq_driver->get) {\n\t\tret_freq = cpufreq_driver->get(cpu);\n\t\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\t\treturn ret_freq;\n\t}\n\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tpolicy = cpufreq_cpu_get(cpu);\n\tif (policy) {\n\t\tret_freq = policy->cur;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_quick_get);\n\n \nunsigned int cpufreq_quick_get_max(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tret_freq = policy->max;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_quick_get_max);\n\n \n__weak unsigned int cpufreq_get_hw_max_freq(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tret_freq = policy->cpuinfo.max_freq;\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_get_hw_max_freq);\n\nstatic unsigned int __cpufreq_get(struct cpufreq_policy *policy)\n{\n\tif (unlikely(policy_is_inactive(policy)))\n\t\treturn 0;\n\n\treturn cpufreq_verify_current_freq(policy, true);\n}\n\n \nunsigned int cpufreq_get(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(cpu);\n\tunsigned int ret_freq = 0;\n\n\tif (policy) {\n\t\tdown_read(&policy->rwsem);\n\t\tif (cpufreq_driver->get)\n\t\t\tret_freq = __cpufreq_get(policy);\n\t\tup_read(&policy->rwsem);\n\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\treturn ret_freq;\n}\nEXPORT_SYMBOL(cpufreq_get);\n\nstatic struct subsys_interface cpufreq_interface = {\n\t.name\t\t= \"cpufreq\",\n\t.subsys\t\t= &cpu_subsys,\n\t.add_dev\t= cpufreq_add_dev,\n\t.remove_dev\t= cpufreq_remove_dev,\n};\n\n \nint cpufreq_generic_suspend(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (!policy->suspend_freq) {\n\t\tpr_debug(\"%s: suspend_freq not defined\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s: Setting suspend-freq: %u\\n\", __func__,\n\t\t\tpolicy->suspend_freq);\n\n\tret = __cpufreq_driver_target(policy, policy->suspend_freq,\n\t\t\tCPUFREQ_RELATION_H);\n\tif (ret)\n\t\tpr_err(\"%s: unable to set suspend-freq: %u. err: %d\\n\",\n\t\t\t\t__func__, policy->suspend_freq, ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_generic_suspend);\n\n \nvoid cpufreq_suspend(void)\n{\n\tstruct cpufreq_policy *policy;\n\n\tif (!cpufreq_driver)\n\t\treturn;\n\n\tif (!has_target() && !cpufreq_driver->suspend)\n\t\tgoto suspend;\n\n\tpr_debug(\"%s: Suspending Governors\\n\", __func__);\n\n\tfor_each_active_policy(policy) {\n\t\tif (has_target()) {\n\t\t\tdown_write(&policy->rwsem);\n\t\t\tcpufreq_stop_governor(policy);\n\t\t\tup_write(&policy->rwsem);\n\t\t}\n\n\t\tif (cpufreq_driver->suspend && cpufreq_driver->suspend(policy))\n\t\t\tpr_err(\"%s: Failed to suspend driver: %s\\n\", __func__,\n\t\t\t\tcpufreq_driver->name);\n\t}\n\nsuspend:\n\tcpufreq_suspended = true;\n}\n\n \nvoid cpufreq_resume(void)\n{\n\tstruct cpufreq_policy *policy;\n\tint ret;\n\n\tif (!cpufreq_driver)\n\t\treturn;\n\n\tif (unlikely(!cpufreq_suspended))\n\t\treturn;\n\n\tcpufreq_suspended = false;\n\n\tif (!has_target() && !cpufreq_driver->resume)\n\t\treturn;\n\n\tpr_debug(\"%s: Resuming Governors\\n\", __func__);\n\n\tfor_each_active_policy(policy) {\n\t\tif (cpufreq_driver->resume && cpufreq_driver->resume(policy)) {\n\t\t\tpr_err(\"%s: Failed to resume driver: %s\\n\", __func__,\n\t\t\t\tcpufreq_driver->name);\n\t\t} else if (has_target()) {\n\t\t\tdown_write(&policy->rwsem);\n\t\t\tret = cpufreq_start_governor(policy);\n\t\t\tup_write(&policy->rwsem);\n\n\t\t\tif (ret)\n\t\t\t\tpr_err(\"%s: Failed to start governor for CPU%u's policy\\n\",\n\t\t\t\t       __func__, policy->cpu);\n\t\t}\n\t}\n}\n\n \nbool cpufreq_driver_test_flags(u16 flags)\n{\n\treturn !!(cpufreq_driver->flags & flags);\n}\n\n \nconst char *cpufreq_get_current_driver(void)\n{\n\tif (cpufreq_driver)\n\t\treturn cpufreq_driver->name;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_get_current_driver);\n\n \nvoid *cpufreq_get_driver_data(void)\n{\n\tif (cpufreq_driver)\n\t\treturn cpufreq_driver->driver_data;\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_get_driver_data);\n\n \n\n \nint cpufreq_register_notifier(struct notifier_block *nb, unsigned int list)\n{\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase CPUFREQ_TRANSITION_NOTIFIER:\n\t\tmutex_lock(&cpufreq_fast_switch_lock);\n\n\t\tif (cpufreq_fast_switch_count > 0) {\n\t\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tret = srcu_notifier_chain_register(\n\t\t\t\t&cpufreq_transition_notifier_list, nb);\n\t\tif (!ret)\n\t\t\tcpufreq_fast_switch_count--;\n\n\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\tbreak;\n\tcase CPUFREQ_POLICY_NOTIFIER:\n\t\tret = blocking_notifier_chain_register(\n\t\t\t\t&cpufreq_policy_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_register_notifier);\n\n \nint cpufreq_unregister_notifier(struct notifier_block *nb, unsigned int list)\n{\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -EINVAL;\n\n\tswitch (list) {\n\tcase CPUFREQ_TRANSITION_NOTIFIER:\n\t\tmutex_lock(&cpufreq_fast_switch_lock);\n\n\t\tret = srcu_notifier_chain_unregister(\n\t\t\t\t&cpufreq_transition_notifier_list, nb);\n\t\tif (!ret && !WARN_ON(cpufreq_fast_switch_count >= 0))\n\t\t\tcpufreq_fast_switch_count++;\n\n\t\tmutex_unlock(&cpufreq_fast_switch_lock);\n\t\tbreak;\n\tcase CPUFREQ_POLICY_NOTIFIER:\n\t\tret = blocking_notifier_chain_unregister(\n\t\t\t\t&cpufreq_policy_notifier_list, nb);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(cpufreq_unregister_notifier);\n\n\n \n\n \nunsigned int cpufreq_driver_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int target_freq)\n{\n\tunsigned int freq;\n\tint cpu;\n\n\ttarget_freq = clamp_val(target_freq, policy->min, policy->max);\n\tfreq = cpufreq_driver->fast_switch(policy, target_freq);\n\n\tif (!freq)\n\t\treturn 0;\n\n\tpolicy->cur = freq;\n\tarch_set_freq_scale(policy->related_cpus, freq,\n\t\t\t    policy->cpuinfo.max_freq);\n\tcpufreq_stats_record_transition(policy, freq);\n\n\tif (trace_cpu_frequency_enabled()) {\n\t\tfor_each_cpu(cpu, policy->cpus)\n\t\t\ttrace_cpu_frequency(freq, cpu);\n\t}\n\n\treturn freq;\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_fast_switch);\n\n \nvoid cpufreq_driver_adjust_perf(unsigned int cpu,\n\t\t\t\t unsigned long min_perf,\n\t\t\t\t unsigned long target_perf,\n\t\t\t\t unsigned long capacity)\n{\n\tcpufreq_driver->adjust_perf(cpu, min_perf, target_perf, capacity);\n}\n\n \nbool cpufreq_driver_has_adjust_perf(void)\n{\n\treturn !!cpufreq_driver->adjust_perf;\n}\n\n \nstatic int __target_intermediate(struct cpufreq_policy *policy,\n\t\t\t\t struct cpufreq_freqs *freqs, int index)\n{\n\tint ret;\n\n\tfreqs->new = cpufreq_driver->get_intermediate(policy, index);\n\n\t \n\tif (!freqs->new)\n\t\treturn 0;\n\n\tpr_debug(\"%s: cpu: %d, switching to intermediate freq: oldfreq: %u, intermediate freq: %u\\n\",\n\t\t __func__, policy->cpu, freqs->old, freqs->new);\n\n\tcpufreq_freq_transition_begin(policy, freqs);\n\tret = cpufreq_driver->target_intermediate(policy, index);\n\tcpufreq_freq_transition_end(policy, freqs, ret);\n\n\tif (ret)\n\t\tpr_err(\"%s: Failed to change to intermediate frequency: %d\\n\",\n\t\t       __func__, ret);\n\n\treturn ret;\n}\n\nstatic int __target_index(struct cpufreq_policy *policy, int index)\n{\n\tstruct cpufreq_freqs freqs = {.old = policy->cur, .flags = 0};\n\tunsigned int restore_freq, intermediate_freq = 0;\n\tunsigned int newfreq = policy->freq_table[index].frequency;\n\tint retval = -EINVAL;\n\tbool notify;\n\n\tif (newfreq == policy->cur)\n\t\treturn 0;\n\n\t \n\trestore_freq = policy->cur;\n\n\tnotify = !(cpufreq_driver->flags & CPUFREQ_ASYNC_NOTIFICATION);\n\tif (notify) {\n\t\t \n\t\tif (cpufreq_driver->get_intermediate) {\n\t\t\tretval = __target_intermediate(policy, &freqs, index);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\n\t\t\tintermediate_freq = freqs.new;\n\t\t\t \n\t\t\tif (intermediate_freq)\n\t\t\t\tfreqs.old = freqs.new;\n\t\t}\n\n\t\tfreqs.new = newfreq;\n\t\tpr_debug(\"%s: cpu: %d, oldfreq: %u, new freq: %u\\n\",\n\t\t\t __func__, policy->cpu, freqs.old, freqs.new);\n\n\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t}\n\n\tretval = cpufreq_driver->target_index(policy, index);\n\tif (retval)\n\t\tpr_err(\"%s: Failed to change cpu frequency: %d\\n\", __func__,\n\t\t       retval);\n\n\tif (notify) {\n\t\tcpufreq_freq_transition_end(policy, &freqs, retval);\n\n\t\t \n\t\tif (unlikely(retval && intermediate_freq)) {\n\t\t\tfreqs.old = intermediate_freq;\n\t\t\tfreqs.new = restore_freq;\n\t\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t\t\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nint __cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t    unsigned int target_freq,\n\t\t\t    unsigned int relation)\n{\n\tunsigned int old_target_freq = target_freq;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\ttarget_freq = __resolve_freq(policy, target_freq, relation);\n\n\tpr_debug(\"target for CPU %u: %u kHz, relation %u, requested %u kHz\\n\",\n\t\t policy->cpu, target_freq, relation, old_target_freq);\n\n\t \n\tif (target_freq == policy->cur &&\n\t    !(cpufreq_driver->flags & CPUFREQ_NEED_UPDATE_LIMITS))\n\t\treturn 0;\n\n\tif (cpufreq_driver->target) {\n\t\t \n\t\tif (!policy->efficiencies_available)\n\t\t\trelation &= ~CPUFREQ_RELATION_E;\n\n\t\treturn cpufreq_driver->target(policy, target_freq, relation);\n\t}\n\n\tif (!cpufreq_driver->target_index)\n\t\treturn -EINVAL;\n\n\treturn __target_index(policy, policy->cached_resolved_idx);\n}\nEXPORT_SYMBOL_GPL(__cpufreq_driver_target);\n\nint cpufreq_driver_target(struct cpufreq_policy *policy,\n\t\t\t  unsigned int target_freq,\n\t\t\t  unsigned int relation)\n{\n\tint ret;\n\n\tdown_write(&policy->rwsem);\n\n\tret = __cpufreq_driver_target(policy, target_freq, relation);\n\n\tup_write(&policy->rwsem);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpufreq_driver_target);\n\n__weak struct cpufreq_governor *cpufreq_fallback_governor(void)\n{\n\treturn NULL;\n}\n\nstatic int cpufreq_init_governor(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\t \n\tif (cpufreq_suspended)\n\t\treturn 0;\n\t \n\tif (!policy->governor)\n\t\treturn -EINVAL;\n\n\t \n\tif (policy->governor->flags & CPUFREQ_GOV_DYNAMIC_SWITCHING &&\n\t    cpufreq_driver->flags & CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING) {\n\t\tstruct cpufreq_governor *gov = cpufreq_fallback_governor();\n\n\t\tif (gov) {\n\t\t\tpr_warn(\"Can't use %s governor as dynamic switching is disallowed. Fallback to %s governor\\n\",\n\t\t\t\tpolicy->governor->name, gov->name);\n\t\t\tpolicy->governor = gov;\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!try_module_get(policy->governor->owner))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->init) {\n\t\tret = policy->governor->init(policy);\n\t\tif (ret) {\n\t\t\tmodule_put(policy->governor->owner);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpolicy->strict_target = !!(policy->governor->flags & CPUFREQ_GOV_STRICT_TARGET);\n\n\treturn 0;\n}\n\nstatic void cpufreq_exit_governor(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->exit)\n\t\tpolicy->governor->exit(policy);\n\n\tmodule_put(policy->governor->owner);\n}\n\nint cpufreq_start_governor(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (cpufreq_suspended)\n\t\treturn 0;\n\n\tif (!policy->governor)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (cpufreq_driver->get)\n\t\tcpufreq_verify_current_freq(policy, false);\n\n\tif (policy->governor->start) {\n\t\tret = policy->governor->start(policy);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (policy->governor->limits)\n\t\tpolicy->governor->limits(policy);\n\n\treturn 0;\n}\n\nvoid cpufreq_stop_governor(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->stop)\n\t\tpolicy->governor->stop(policy);\n}\n\nstatic void cpufreq_governor_limits(struct cpufreq_policy *policy)\n{\n\tif (cpufreq_suspended || !policy->governor)\n\t\treturn;\n\n\tpr_debug(\"%s: for CPU %u\\n\", __func__, policy->cpu);\n\n\tif (policy->governor->limits)\n\t\tpolicy->governor->limits(policy);\n}\n\nint cpufreq_register_governor(struct cpufreq_governor *governor)\n{\n\tint err;\n\n\tif (!governor)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\n\terr = -EBUSY;\n\tif (!find_governor(governor->name)) {\n\t\terr = 0;\n\t\tlist_add(&governor->governor_list, &cpufreq_governor_list);\n\t}\n\n\tmutex_unlock(&cpufreq_governor_mutex);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cpufreq_register_governor);\n\nvoid cpufreq_unregister_governor(struct cpufreq_governor *governor)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned long flags;\n\n\tif (!governor)\n\t\treturn;\n\n\tif (cpufreq_disabled())\n\t\treturn;\n\n\t \n\tread_lock_irqsave(&cpufreq_driver_lock, flags);\n\tfor_each_inactive_policy(policy) {\n\t\tif (!strcmp(policy->last_governor, governor->name)) {\n\t\t\tpolicy->governor = NULL;\n\t\t\tstrcpy(policy->last_governor, \"\\0\");\n\t\t}\n\t}\n\tread_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tmutex_lock(&cpufreq_governor_mutex);\n\tlist_del(&governor->governor_list);\n\tmutex_unlock(&cpufreq_governor_mutex);\n}\nEXPORT_SYMBOL_GPL(cpufreq_unregister_governor);\n\n\n \n\n \nint cpufreq_get_policy(struct cpufreq_policy *policy, unsigned int cpu)\n{\n\tstruct cpufreq_policy *cpu_policy;\n\tif (!policy)\n\t\treturn -EINVAL;\n\n\tcpu_policy = cpufreq_cpu_get(cpu);\n\tif (!cpu_policy)\n\t\treturn -EINVAL;\n\n\tmemcpy(policy, cpu_policy, sizeof(*policy));\n\n\tcpufreq_cpu_put(cpu_policy);\n\treturn 0;\n}\nEXPORT_SYMBOL(cpufreq_get_policy);\n\n \nstatic int cpufreq_set_policy(struct cpufreq_policy *policy,\n\t\t\t      struct cpufreq_governor *new_gov,\n\t\t\t      unsigned int new_pol)\n{\n\tstruct cpufreq_policy_data new_data;\n\tstruct cpufreq_governor *old_gov;\n\tint ret;\n\n\tmemcpy(&new_data.cpuinfo, &policy->cpuinfo, sizeof(policy->cpuinfo));\n\tnew_data.freq_table = policy->freq_table;\n\tnew_data.cpu = policy->cpu;\n\t \n\tnew_data.min = freq_qos_read_value(&policy->constraints, FREQ_QOS_MIN);\n\tnew_data.max = freq_qos_read_value(&policy->constraints, FREQ_QOS_MAX);\n\n\tpr_debug(\"setting new policy for CPU %u: %u - %u kHz\\n\",\n\t\t new_data.cpu, new_data.min, new_data.max);\n\n\t \n\tret = cpufreq_driver->verify(&new_data);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpolicy->min = new_data.min;\n\tpolicy->max = new_data.max;\n\tpolicy->min = __resolve_freq(policy, policy->min, CPUFREQ_RELATION_L);\n\tpolicy->max = __resolve_freq(policy, policy->max, CPUFREQ_RELATION_H);\n\ttrace_cpu_frequency_limits(policy);\n\n\tpolicy->cached_target_freq = UINT_MAX;\n\n\tpr_debug(\"new min and max freqs are %u - %u kHz\\n\",\n\t\t policy->min, policy->max);\n\n\tif (cpufreq_driver->setpolicy) {\n\t\tpolicy->policy = new_pol;\n\t\tpr_debug(\"setting range\\n\");\n\t\treturn cpufreq_driver->setpolicy(policy);\n\t}\n\n\tif (new_gov == policy->governor) {\n\t\tpr_debug(\"governor limits update\\n\");\n\t\tcpufreq_governor_limits(policy);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"governor switch\\n\");\n\n\t \n\told_gov = policy->governor;\n\t \n\tif (old_gov) {\n\t\tcpufreq_stop_governor(policy);\n\t\tcpufreq_exit_governor(policy);\n\t}\n\n\t \n\tpolicy->governor = new_gov;\n\tret = cpufreq_init_governor(policy);\n\tif (!ret) {\n\t\tret = cpufreq_start_governor(policy);\n\t\tif (!ret) {\n\t\t\tpr_debug(\"governor change\\n\");\n\t\t\tsched_cpufreq_governor_change(policy, old_gov);\n\t\t\treturn 0;\n\t\t}\n\t\tcpufreq_exit_governor(policy);\n\t}\n\n\t \n\tpr_debug(\"starting governor %s failed\\n\", policy->governor->name);\n\tif (old_gov) {\n\t\tpolicy->governor = old_gov;\n\t\tif (cpufreq_init_governor(policy))\n\t\t\tpolicy->governor = NULL;\n\t\telse\n\t\t\tcpufreq_start_governor(policy);\n\t}\n\n\treturn ret;\n}\n\n \nvoid cpufreq_update_policy(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_acquire(cpu);\n\n\tif (!policy)\n\t\treturn;\n\n\t \n\tif (cpufreq_driver->get && has_target() &&\n\t    (cpufreq_suspended || WARN_ON(!cpufreq_verify_current_freq(policy, false))))\n\t\tgoto unlock;\n\n\trefresh_frequency_limits(policy);\n\nunlock:\n\tcpufreq_cpu_release(policy);\n}\nEXPORT_SYMBOL(cpufreq_update_policy);\n\n \nvoid cpufreq_update_limits(unsigned int cpu)\n{\n\tif (cpufreq_driver->update_limits)\n\t\tcpufreq_driver->update_limits(cpu);\n\telse\n\t\tcpufreq_update_policy(cpu);\n}\nEXPORT_SYMBOL_GPL(cpufreq_update_limits);\n\n \nstatic int cpufreq_boost_set_sw(struct cpufreq_policy *policy, int state)\n{\n\tint ret;\n\n\tif (!policy->freq_table)\n\t\treturn -ENXIO;\n\n\tret = cpufreq_frequency_table_cpuinfo(policy, policy->freq_table);\n\tif (ret) {\n\t\tpr_err(\"%s: Policy frequency update failed\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = freq_qos_update_request(policy->max_freq_req, policy->max);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint cpufreq_boost_trigger_state(int state)\n{\n\tstruct cpufreq_policy *policy;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (cpufreq_driver->boost_enabled == state)\n\t\treturn 0;\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver->boost_enabled = state;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tcpus_read_lock();\n\tfor_each_active_policy(policy) {\n\t\tret = cpufreq_driver->set_boost(policy, state);\n\t\tif (ret)\n\t\t\tgoto err_reset_state;\n\n\t\tpolicy->boost_enabled = state;\n\t}\n\tcpus_read_unlock();\n\n\treturn 0;\n\nerr_reset_state:\n\tcpus_read_unlock();\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver->boost_enabled = !state;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\tpr_err(\"%s: Cannot %s BOOST\\n\",\n\t       __func__, state ? \"enable\" : \"disable\");\n\n\treturn ret;\n}\n\nstatic bool cpufreq_boost_supported(void)\n{\n\treturn cpufreq_driver->set_boost;\n}\n\nstatic int create_boost_sysfs_file(void)\n{\n\tint ret;\n\n\tret = sysfs_create_file(cpufreq_global_kobject, &boost.attr);\n\tif (ret)\n\t\tpr_err(\"%s: cannot register global BOOST sysfs file\\n\",\n\t\t       __func__);\n\n\treturn ret;\n}\n\nstatic void remove_boost_sysfs_file(void)\n{\n\tif (cpufreq_boost_supported())\n\t\tsysfs_remove_file(cpufreq_global_kobject, &boost.attr);\n}\n\nint cpufreq_enable_boost_support(void)\n{\n\tif (!cpufreq_driver)\n\t\treturn -EINVAL;\n\n\tif (cpufreq_boost_supported())\n\t\treturn 0;\n\n\tcpufreq_driver->set_boost = cpufreq_boost_set_sw;\n\n\t \n\treturn create_boost_sysfs_file();\n}\nEXPORT_SYMBOL_GPL(cpufreq_enable_boost_support);\n\nint cpufreq_boost_enabled(void)\n{\n\treturn cpufreq_driver->boost_enabled;\n}\nEXPORT_SYMBOL_GPL(cpufreq_boost_enabled);\n\n \nstatic enum cpuhp_state hp_online;\n\nstatic int cpuhp_cpufreq_online(unsigned int cpu)\n{\n\tcpufreq_online(cpu);\n\n\treturn 0;\n}\n\nstatic int cpuhp_cpufreq_offline(unsigned int cpu)\n{\n\tcpufreq_offline(cpu);\n\n\treturn 0;\n}\n\n \nint cpufreq_register_driver(struct cpufreq_driver *driver_data)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\t \n\tif (!get_cpu_device(0))\n\t\treturn -EPROBE_DEFER;\n\n\tif (!driver_data || !driver_data->verify || !driver_data->init ||\n\t    !(driver_data->setpolicy || driver_data->target_index ||\n\t\t    driver_data->target) ||\n\t     (driver_data->setpolicy && (driver_data->target_index ||\n\t\t    driver_data->target)) ||\n\t     (!driver_data->get_intermediate != !driver_data->target_intermediate) ||\n\t     (!driver_data->online != !driver_data->offline) ||\n\t\t (driver_data->adjust_perf && !driver_data->fast_switch))\n\t\treturn -EINVAL;\n\n\tpr_debug(\"trying to register driver %s\\n\", driver_data->name);\n\n\t \n\tcpus_read_lock();\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tif (cpufreq_driver) {\n\t\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t}\n\tcpufreq_driver = driver_data;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\n\t \n\tif (!cpufreq_driver->setpolicy) {\n\t\tstatic_branch_enable_cpuslocked(&cpufreq_freq_invariance);\n\t\tpr_debug(\"supports frequency invariance\");\n\t}\n\n\tif (driver_data->setpolicy)\n\t\tdriver_data->flags |= CPUFREQ_CONST_LOOPS;\n\n\tif (cpufreq_boost_supported()) {\n\t\tret = create_boost_sysfs_file();\n\t\tif (ret)\n\t\t\tgoto err_null_driver;\n\t}\n\n\tret = subsys_interface_register(&cpufreq_interface);\n\tif (ret)\n\t\tgoto err_boost_unreg;\n\n\tif (unlikely(list_empty(&cpufreq_policy_list))) {\n\t\t \n\t\tret = -ENODEV;\n\t\tpr_debug(\"%s: No CPU initialized for driver %s\\n\", __func__,\n\t\t\t driver_data->name);\n\t\tgoto err_if_unreg;\n\t}\n\n\tret = cpuhp_setup_state_nocalls_cpuslocked(CPUHP_AP_ONLINE_DYN,\n\t\t\t\t\t\t   \"cpufreq:online\",\n\t\t\t\t\t\t   cpuhp_cpufreq_online,\n\t\t\t\t\t\t   cpuhp_cpufreq_offline);\n\tif (ret < 0)\n\t\tgoto err_if_unreg;\n\thp_online = ret;\n\tret = 0;\n\n\tpr_debug(\"driver %s up and running\\n\", driver_data->name);\n\tgoto out;\n\nerr_if_unreg:\n\tsubsys_interface_unregister(&cpufreq_interface);\nerr_boost_unreg:\n\tremove_boost_sysfs_file();\nerr_null_driver:\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\tcpufreq_driver = NULL;\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\nout:\n\tcpus_read_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpufreq_register_driver);\n\n \nvoid cpufreq_unregister_driver(struct cpufreq_driver *driver)\n{\n\tunsigned long flags;\n\n\tif (WARN_ON(!cpufreq_driver || (driver != cpufreq_driver)))\n\t\treturn;\n\n\tpr_debug(\"unregistering driver %s\\n\", driver->name);\n\n\t \n\tcpus_read_lock();\n\tsubsys_interface_unregister(&cpufreq_interface);\n\tremove_boost_sysfs_file();\n\tstatic_branch_disable_cpuslocked(&cpufreq_freq_invariance);\n\tcpuhp_remove_state_nocalls_cpuslocked(hp_online);\n\n\twrite_lock_irqsave(&cpufreq_driver_lock, flags);\n\n\tcpufreq_driver = NULL;\n\n\twrite_unlock_irqrestore(&cpufreq_driver_lock, flags);\n\tcpus_read_unlock();\n}\nEXPORT_SYMBOL_GPL(cpufreq_unregister_driver);\n\nstatic int __init cpufreq_core_init(void)\n{\n\tstruct cpufreq_governor *gov = cpufreq_default_governor();\n\tstruct device *dev_root;\n\n\tif (cpufreq_disabled())\n\t\treturn -ENODEV;\n\n\tdev_root = bus_get_dev_root(&cpu_subsys);\n\tif (dev_root) {\n\t\tcpufreq_global_kobject = kobject_create_and_add(\"cpufreq\", &dev_root->kobj);\n\t\tput_device(dev_root);\n\t}\n\tBUG_ON(!cpufreq_global_kobject);\n\n\tif (!strlen(default_governor))\n\t\tstrncpy(default_governor, gov->name, CPUFREQ_NAME_LEN);\n\n\treturn 0;\n}\nmodule_param(off, int, 0444);\nmodule_param_string(default_governor, default_governor, CPUFREQ_NAME_LEN, 0444);\ncore_initcall(cpufreq_core_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}