{
  "module_name": "cpufreq_stats.c",
  "hash_id": "e72721075d10dc42f8153ea9406d86edbb63e73bd898db593d58a35ba3ade3f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq_stats.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/module.h>\n#include <linux/sched/clock.h>\n#include <linux/slab.h>\n\nstruct cpufreq_stats {\n\tunsigned int total_trans;\n\tunsigned long long last_time;\n\tunsigned int max_state;\n\tunsigned int state_num;\n\tunsigned int last_index;\n\tu64 *time_in_state;\n\tunsigned int *freq_table;\n\tunsigned int *trans_table;\n\n\t \n\tunsigned int reset_pending;\n\tunsigned long long reset_time;\n};\n\nstatic void cpufreq_stats_update(struct cpufreq_stats *stats,\n\t\t\t\t unsigned long long time)\n{\n\tunsigned long long cur_time = local_clock();\n\n\tstats->time_in_state[stats->last_index] += cur_time - time;\n\tstats->last_time = cur_time;\n}\n\nstatic void cpufreq_stats_reset_table(struct cpufreq_stats *stats)\n{\n\tunsigned int count = stats->max_state;\n\n\tmemset(stats->time_in_state, 0, count * sizeof(u64));\n\tmemset(stats->trans_table, 0, count * count * sizeof(int));\n\tstats->last_time = local_clock();\n\tstats->total_trans = 0;\n\n\t \n\tWRITE_ONCE(stats->reset_pending, 0);\n\t \n\tsmp_rmb();\n\tcpufreq_stats_update(stats, READ_ONCE(stats->reset_time));\n}\n\nstatic ssize_t show_total_trans(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\n\tif (READ_ONCE(stats->reset_pending))\n\t\treturn sprintf(buf, \"%d\\n\", 0);\n\telse\n\t\treturn sprintf(buf, \"%u\\n\", stats->total_trans);\n}\ncpufreq_freq_attr_ro(total_trans);\n\nstatic ssize_t show_time_in_state(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\tbool pending = READ_ONCE(stats->reset_pending);\n\tunsigned long long time;\n\tssize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < stats->state_num; i++) {\n\t\tif (pending) {\n\t\t\tif (i == stats->last_index) {\n\t\t\t\t \n\t\t\t\tsmp_rmb();\n\t\t\t\ttime = local_clock() - READ_ONCE(stats->reset_time);\n\t\t\t} else {\n\t\t\t\ttime = 0;\n\t\t\t}\n\t\t} else {\n\t\t\ttime = stats->time_in_state[i];\n\t\t\tif (i == stats->last_index)\n\t\t\t\ttime += local_clock() - stats->last_time;\n\t\t}\n\n\t\tlen += sprintf(buf + len, \"%u %llu\\n\", stats->freq_table[i],\n\t\t\t       nsec_to_clock_t(time));\n\t}\n\treturn len;\n}\ncpufreq_freq_attr_ro(time_in_state);\n\n \nstatic ssize_t store_reset(struct cpufreq_policy *policy, const char *buf,\n\t\t\t   size_t count)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\n\t \n\tWRITE_ONCE(stats->reset_time, local_clock());\n\t \n\tsmp_wmb();\n\tWRITE_ONCE(stats->reset_pending, 1);\n\n\treturn count;\n}\ncpufreq_freq_attr_wo(reset);\n\nstatic ssize_t show_trans_table(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\tbool pending = READ_ONCE(stats->reset_pending);\n\tssize_t len = 0;\n\tint i, j, count;\n\n\tlen += sysfs_emit_at(buf, len, \"   From  :    To\\n\");\n\tlen += sysfs_emit_at(buf, len, \"         : \");\n\tfor (i = 0; i < stats->state_num; i++) {\n\t\tif (len >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\t\tlen += sysfs_emit_at(buf, len, \"%9u \", stats->freq_table[i]);\n\t}\n\tif (len >= PAGE_SIZE - 1)\n\t\treturn PAGE_SIZE - 1;\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\tfor (i = 0; i < stats->state_num; i++) {\n\t\tif (len >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\n\t\tlen += sysfs_emit_at(buf, len, \"%9u: \", stats->freq_table[i]);\n\n\t\tfor (j = 0; j < stats->state_num; j++) {\n\t\t\tif (len >= PAGE_SIZE - 1)\n\t\t\t\tbreak;\n\n\t\t\tif (pending)\n\t\t\t\tcount = 0;\n\t\t\telse\n\t\t\t\tcount = stats->trans_table[i * stats->max_state + j];\n\n\t\t\tlen += sysfs_emit_at(buf, len, \"%9u \", count);\n\t\t}\n\t\tif (len >= PAGE_SIZE - 1)\n\t\t\tbreak;\n\t\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\t}\n\n\tif (len >= PAGE_SIZE - 1) {\n\t\tpr_warn_once(\"cpufreq transition table exceeds PAGE_SIZE. Disabling\\n\");\n\t\treturn -EFBIG;\n\t}\n\treturn len;\n}\ncpufreq_freq_attr_ro(trans_table);\n\nstatic struct attribute *default_attrs[] = {\n\t&total_trans.attr,\n\t&time_in_state.attr,\n\t&reset.attr,\n\t&trans_table.attr,\n\tNULL\n};\nstatic const struct attribute_group stats_attr_group = {\n\t.attrs = default_attrs,\n\t.name = \"stats\"\n};\n\nstatic int freq_table_get_index(struct cpufreq_stats *stats, unsigned int freq)\n{\n\tint index;\n\tfor (index = 0; index < stats->max_state; index++)\n\t\tif (stats->freq_table[index] == freq)\n\t\t\treturn index;\n\treturn -1;\n}\n\nvoid cpufreq_stats_free_table(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\n\t \n\tif (!stats)\n\t\treturn;\n\n\tpr_debug(\"%s: Free stats table\\n\", __func__);\n\n\tsysfs_remove_group(&policy->kobj, &stats_attr_group);\n\tkfree(stats->time_in_state);\n\tkfree(stats);\n\tpolicy->stats = NULL;\n}\n\nvoid cpufreq_stats_create_table(struct cpufreq_policy *policy)\n{\n\tunsigned int i = 0, count;\n\tstruct cpufreq_stats *stats;\n\tunsigned int alloc_size;\n\tstruct cpufreq_frequency_table *pos;\n\n\tcount = cpufreq_table_count_valid_entries(policy);\n\tif (!count)\n\t\treturn;\n\n\t \n\tif (policy->stats)\n\t\treturn;\n\n\tstats = kzalloc(sizeof(*stats), GFP_KERNEL);\n\tif (!stats)\n\t\treturn;\n\n\talloc_size = count * sizeof(int) + count * sizeof(u64);\n\n\talloc_size += count * count * sizeof(int);\n\n\t \n\tstats->time_in_state = kzalloc(alloc_size, GFP_KERNEL);\n\tif (!stats->time_in_state)\n\t\tgoto free_stat;\n\n\tstats->freq_table = (unsigned int *)(stats->time_in_state + count);\n\n\tstats->trans_table = stats->freq_table + count;\n\n\tstats->max_state = count;\n\n\t \n\tcpufreq_for_each_valid_entry(pos, policy->freq_table)\n\t\tif (policy->freq_table_sorted != CPUFREQ_TABLE_UNSORTED ||\n\t\t    freq_table_get_index(stats, pos->frequency) == -1)\n\t\t\tstats->freq_table[i++] = pos->frequency;\n\n\tstats->state_num = i;\n\tstats->last_time = local_clock();\n\tstats->last_index = freq_table_get_index(stats, policy->cur);\n\n\tpolicy->stats = stats;\n\tif (!sysfs_create_group(&policy->kobj, &stats_attr_group))\n\t\treturn;\n\n\t \n\tpolicy->stats = NULL;\n\tkfree(stats->time_in_state);\nfree_stat:\n\tkfree(stats);\n}\n\nvoid cpufreq_stats_record_transition(struct cpufreq_policy *policy,\n\t\t\t\t     unsigned int new_freq)\n{\n\tstruct cpufreq_stats *stats = policy->stats;\n\tint old_index, new_index;\n\n\tif (unlikely(!stats))\n\t\treturn;\n\n\tif (unlikely(READ_ONCE(stats->reset_pending)))\n\t\tcpufreq_stats_reset_table(stats);\n\n\told_index = stats->last_index;\n\tnew_index = freq_table_get_index(stats, new_freq);\n\n\t \n\tif (unlikely(old_index == -1 || new_index == -1 || old_index == new_index))\n\t\treturn;\n\n\tcpufreq_stats_update(stats, stats->last_time);\n\n\tstats->last_index = new_index;\n\tstats->trans_table[old_index * stats->max_state + new_index]++;\n\tstats->total_trans++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}