{
  "module_name": "cpufreq_governor.c",
  "hash_id": "898ea77eb8b462513efa359f47eb51eee283b329dc6b9dd8b47aab6f7bb997ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq_governor.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n#include <linux/slab.h>\n\n#include \"cpufreq_governor.h\"\n\n#define CPUFREQ_DBS_MIN_SAMPLING_INTERVAL\t(2 * TICK_NSEC / NSEC_PER_USEC)\n\nstatic DEFINE_PER_CPU(struct cpu_dbs_info, cpu_dbs);\n\nstatic DEFINE_MUTEX(gov_dbs_data_mutex);\n\n \n \nssize_t sampling_rate_store(struct gov_attr_set *attr_set, const char *buf,\n\t\t\t    size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct policy_dbs_info *policy_dbs;\n\tunsigned int sampling_interval;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &sampling_interval);\n\tif (ret != 1 || sampling_interval < CPUFREQ_DBS_MIN_SAMPLING_INTERVAL)\n\t\treturn -EINVAL;\n\n\tdbs_data->sampling_rate = sampling_interval;\n\n\t \n\tlist_for_each_entry(policy_dbs, &attr_set->policy_list, list) {\n\t\tmutex_lock(&policy_dbs->update_mutex);\n\t\t \n\t\tgov_update_sample_delay(policy_dbs, 0);\n\t\tmutex_unlock(&policy_dbs->update_mutex);\n\t}\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(sampling_rate_store);\n\n \nvoid gov_update_cpu_data(struct dbs_data *dbs_data)\n{\n\tstruct policy_dbs_info *policy_dbs;\n\n\tlist_for_each_entry(policy_dbs, &dbs_data->attr_set.policy_list, list) {\n\t\tunsigned int j;\n\n\t\tfor_each_cpu(j, policy_dbs->policy->cpus) {\n\t\t\tstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\n\n\t\t\tj_cdbs->prev_cpu_idle = get_cpu_idle_time(j, &j_cdbs->prev_update_time,\n\t\t\t\t\t\t\t\t  dbs_data->io_is_busy);\n\t\t\tif (dbs_data->ignore_nice_load)\n\t\t\t\tj_cdbs->prev_cpu_nice = kcpustat_field(&kcpustat_cpu(j), CPUTIME_NICE, j);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL_GPL(gov_update_cpu_data);\n\nunsigned int dbs_update(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tunsigned int ignore_nice = dbs_data->ignore_nice_load;\n\tunsigned int max_load = 0, idle_periods = UINT_MAX;\n\tunsigned int sampling_rate, io_busy, j;\n\n\t \n\tsampling_rate = dbs_data->sampling_rate * policy_dbs->rate_mult;\n\t \n\tio_busy = dbs_data->io_is_busy;\n\n\t \n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\n\t\tu64 update_time, cur_idle_time;\n\t\tunsigned int idle_time, time_elapsed;\n\t\tunsigned int load;\n\n\t\tcur_idle_time = get_cpu_idle_time(j, &update_time, io_busy);\n\n\t\ttime_elapsed = update_time - j_cdbs->prev_update_time;\n\t\tj_cdbs->prev_update_time = update_time;\n\n\t\tidle_time = cur_idle_time - j_cdbs->prev_cpu_idle;\n\t\tj_cdbs->prev_cpu_idle = cur_idle_time;\n\n\t\tif (ignore_nice) {\n\t\t\tu64 cur_nice = kcpustat_field(&kcpustat_cpu(j), CPUTIME_NICE, j);\n\n\t\t\tidle_time += div_u64(cur_nice - j_cdbs->prev_cpu_nice, NSEC_PER_USEC);\n\t\t\tj_cdbs->prev_cpu_nice = cur_nice;\n\t\t}\n\n\t\tif (unlikely(!time_elapsed)) {\n\t\t\t \n\t\t\tload = j_cdbs->prev_load;\n\t\t} else if (unlikely((int)idle_time > 2 * sampling_rate &&\n\t\t\t\t    j_cdbs->prev_load)) {\n\t\t\t \n\t\t\tload = j_cdbs->prev_load;\n\t\t\tj_cdbs->prev_load = 0;\n\t\t} else {\n\t\t\tif (time_elapsed >= idle_time) {\n\t\t\t\tload = 100 * (time_elapsed - idle_time) / time_elapsed;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tload = (int)idle_time < 0 ? 100 : 0;\n\t\t\t}\n\t\t\tj_cdbs->prev_load = load;\n\t\t}\n\n\t\tif (unlikely((int)idle_time > 2 * sampling_rate)) {\n\t\t\tunsigned int periods = idle_time / sampling_rate;\n\n\t\t\tif (periods < idle_periods)\n\t\t\t\tidle_periods = periods;\n\t\t}\n\n\t\tif (load > max_load)\n\t\t\tmax_load = load;\n\t}\n\n\tpolicy_dbs->idle_periods = idle_periods;\n\n\treturn max_load;\n}\nEXPORT_SYMBOL_GPL(dbs_update);\n\nstatic void dbs_work_handler(struct work_struct *work)\n{\n\tstruct policy_dbs_info *policy_dbs;\n\tstruct cpufreq_policy *policy;\n\tstruct dbs_governor *gov;\n\n\tpolicy_dbs = container_of(work, struct policy_dbs_info, work);\n\tpolicy = policy_dbs->policy;\n\tgov = dbs_governor_of(policy);\n\n\t \n\tmutex_lock(&policy_dbs->update_mutex);\n\tgov_update_sample_delay(policy_dbs, gov->gov_dbs_update(policy));\n\tmutex_unlock(&policy_dbs->update_mutex);\n\n\t \n\tatomic_set(&policy_dbs->work_count, 0);\n\t \n\tsmp_wmb();\n\tpolicy_dbs->work_in_progress = false;\n}\n\nstatic void dbs_irq_work(struct irq_work *irq_work)\n{\n\tstruct policy_dbs_info *policy_dbs;\n\n\tpolicy_dbs = container_of(irq_work, struct policy_dbs_info, irq_work);\n\tschedule_work_on(smp_processor_id(), &policy_dbs->work);\n}\n\nstatic void dbs_update_util_handler(struct update_util_data *data, u64 time,\n\t\t\t\t    unsigned int flags)\n{\n\tstruct cpu_dbs_info *cdbs = container_of(data, struct cpu_dbs_info, update_util);\n\tstruct policy_dbs_info *policy_dbs = cdbs->policy_dbs;\n\tu64 delta_ns, lst;\n\n\tif (!cpufreq_this_cpu_can_update(policy_dbs->policy))\n\t\treturn;\n\n\t \n\tif (policy_dbs->work_in_progress)\n\t\treturn;\n\n\t \n\tsmp_rmb();\n\tlst = READ_ONCE(policy_dbs->last_sample_time);\n\tdelta_ns = time - lst;\n\tif ((s64)delta_ns < policy_dbs->sample_delay_ns)\n\t\treturn;\n\n\t \n\tif (policy_dbs->is_shared) {\n\t\tif (!atomic_add_unless(&policy_dbs->work_count, 1, 1))\n\t\t\treturn;\n\n\t\t \n\t\tif (unlikely(lst != READ_ONCE(policy_dbs->last_sample_time))) {\n\t\t\tatomic_set(&policy_dbs->work_count, 0);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpolicy_dbs->last_sample_time = time;\n\tpolicy_dbs->work_in_progress = true;\n\tirq_work_queue(&policy_dbs->irq_work);\n}\n\nstatic void gov_set_update_util(struct policy_dbs_info *policy_dbs,\n\t\t\t\tunsigned int delay_us)\n{\n\tstruct cpufreq_policy *policy = policy_dbs->policy;\n\tint cpu;\n\n\tgov_update_sample_delay(policy_dbs, delay_us);\n\tpolicy_dbs->last_sample_time = 0;\n\n\tfor_each_cpu(cpu, policy->cpus) {\n\t\tstruct cpu_dbs_info *cdbs = &per_cpu(cpu_dbs, cpu);\n\n\t\tcpufreq_add_update_util_hook(cpu, &cdbs->update_util,\n\t\t\t\t\t     dbs_update_util_handler);\n\t}\n}\n\nstatic inline void gov_clear_update_util(struct cpufreq_policy *policy)\n{\n\tint i;\n\n\tfor_each_cpu(i, policy->cpus)\n\t\tcpufreq_remove_update_util_hook(i);\n\n\tsynchronize_rcu();\n}\n\nstatic struct policy_dbs_info *alloc_policy_dbs_info(struct cpufreq_policy *policy,\n\t\t\t\t\t\t     struct dbs_governor *gov)\n{\n\tstruct policy_dbs_info *policy_dbs;\n\tint j;\n\n\t \n\tpolicy_dbs = gov->alloc();\n\tif (!policy_dbs)\n\t\treturn NULL;\n\n\tpolicy_dbs->policy = policy;\n\tmutex_init(&policy_dbs->update_mutex);\n\tatomic_set(&policy_dbs->work_count, 0);\n\tinit_irq_work(&policy_dbs->irq_work, dbs_irq_work);\n\tINIT_WORK(&policy_dbs->work, dbs_work_handler);\n\n\t \n\tfor_each_cpu(j, policy->related_cpus) {\n\t\tstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\n\n\t\tj_cdbs->policy_dbs = policy_dbs;\n\t}\n\treturn policy_dbs;\n}\n\nstatic void free_policy_dbs_info(struct policy_dbs_info *policy_dbs,\n\t\t\t\t struct dbs_governor *gov)\n{\n\tint j;\n\n\tmutex_destroy(&policy_dbs->update_mutex);\n\n\tfor_each_cpu(j, policy_dbs->policy->related_cpus) {\n\t\tstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\n\n\t\tj_cdbs->policy_dbs = NULL;\n\t\tj_cdbs->update_util.func = NULL;\n\t}\n\tgov->free(policy_dbs);\n}\n\nstatic void cpufreq_dbs_data_release(struct kobject *kobj)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(to_gov_attr_set(kobj));\n\tstruct dbs_governor *gov = dbs_data->gov;\n\n\tgov->exit(dbs_data);\n\tkfree(dbs_data);\n}\n\nint cpufreq_dbs_governor_init(struct cpufreq_policy *policy)\n{\n\tstruct dbs_governor *gov = dbs_governor_of(policy);\n\tstruct dbs_data *dbs_data;\n\tstruct policy_dbs_info *policy_dbs;\n\tint ret = 0;\n\n\t \n\tif (policy->governor_data)\n\t\treturn -EBUSY;\n\n\tpolicy_dbs = alloc_policy_dbs_info(policy, gov);\n\tif (!policy_dbs)\n\t\treturn -ENOMEM;\n\n\t \n\tmutex_lock(&gov_dbs_data_mutex);\n\n\tdbs_data = gov->gdbs_data;\n\tif (dbs_data) {\n\t\tif (WARN_ON(have_governor_per_policy())) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_policy_dbs_info;\n\t\t}\n\t\tpolicy_dbs->dbs_data = dbs_data;\n\t\tpolicy->governor_data = policy_dbs;\n\n\t\tgov_attr_set_get(&dbs_data->attr_set, &policy_dbs->list);\n\t\tgoto out;\n\t}\n\n\tdbs_data = kzalloc(sizeof(*dbs_data), GFP_KERNEL);\n\tif (!dbs_data) {\n\t\tret = -ENOMEM;\n\t\tgoto free_policy_dbs_info;\n\t}\n\n\tdbs_data->gov = gov;\n\tgov_attr_set_init(&dbs_data->attr_set, &policy_dbs->list);\n\n\tret = gov->init(dbs_data);\n\tif (ret)\n\t\tgoto free_dbs_data;\n\n\t \n\tdbs_data->sampling_rate = max_t(unsigned int,\n\t\t\t\t\tCPUFREQ_DBS_MIN_SAMPLING_INTERVAL,\n\t\t\t\t\tcpufreq_policy_transition_delay_us(policy));\n\n\tif (!have_governor_per_policy())\n\t\tgov->gdbs_data = dbs_data;\n\n\tpolicy_dbs->dbs_data = dbs_data;\n\tpolicy->governor_data = policy_dbs;\n\n\tgov->kobj_type.sysfs_ops = &governor_sysfs_ops;\n\tgov->kobj_type.release = cpufreq_dbs_data_release;\n\tret = kobject_init_and_add(&dbs_data->attr_set.kobj, &gov->kobj_type,\n\t\t\t\t   get_governor_parent_kobj(policy),\n\t\t\t\t   \"%s\", gov->gov.name);\n\tif (!ret)\n\t\tgoto out;\n\n\t \n\tpr_err(\"initialization failed (dbs_data kobject init error %d)\\n\", ret);\n\n\tkobject_put(&dbs_data->attr_set.kobj);\n\n\tpolicy->governor_data = NULL;\n\n\tif (!have_governor_per_policy())\n\t\tgov->gdbs_data = NULL;\n\tgov->exit(dbs_data);\n\nfree_dbs_data:\n\tkfree(dbs_data);\n\nfree_policy_dbs_info:\n\tfree_policy_dbs_info(policy_dbs, gov);\n\nout:\n\tmutex_unlock(&gov_dbs_data_mutex);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(cpufreq_dbs_governor_init);\n\nvoid cpufreq_dbs_governor_exit(struct cpufreq_policy *policy)\n{\n\tstruct dbs_governor *gov = dbs_governor_of(policy);\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tunsigned int count;\n\n\t \n\tmutex_lock(&gov_dbs_data_mutex);\n\n\tcount = gov_attr_set_put(&dbs_data->attr_set, &policy_dbs->list);\n\n\tpolicy->governor_data = NULL;\n\n\tif (!count && !have_governor_per_policy())\n\t\tgov->gdbs_data = NULL;\n\n\tfree_policy_dbs_info(policy_dbs, gov);\n\n\tmutex_unlock(&gov_dbs_data_mutex);\n}\nEXPORT_SYMBOL_GPL(cpufreq_dbs_governor_exit);\n\nint cpufreq_dbs_governor_start(struct cpufreq_policy *policy)\n{\n\tstruct dbs_governor *gov = dbs_governor_of(policy);\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tunsigned int sampling_rate, ignore_nice, j;\n\tunsigned int io_busy;\n\n\tif (!policy->cur)\n\t\treturn -EINVAL;\n\n\tpolicy_dbs->is_shared = policy_is_shared(policy);\n\tpolicy_dbs->rate_mult = 1;\n\n\tsampling_rate = dbs_data->sampling_rate;\n\tignore_nice = dbs_data->ignore_nice_load;\n\tio_busy = dbs_data->io_is_busy;\n\n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\n\n\t\tj_cdbs->prev_cpu_idle = get_cpu_idle_time(j, &j_cdbs->prev_update_time, io_busy);\n\t\t \n\t\tj_cdbs->prev_load = 0;\n\n\t\tif (ignore_nice)\n\t\t\tj_cdbs->prev_cpu_nice = kcpustat_field(&kcpustat_cpu(j), CPUTIME_NICE, j);\n\t}\n\n\tgov->start(policy);\n\n\tgov_set_update_util(policy_dbs, sampling_rate);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cpufreq_dbs_governor_start);\n\nvoid cpufreq_dbs_governor_stop(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\n\tgov_clear_update_util(policy_dbs->policy);\n\tirq_work_sync(&policy_dbs->irq_work);\n\tcancel_work_sync(&policy_dbs->work);\n\tatomic_set(&policy_dbs->work_count, 0);\n\tpolicy_dbs->work_in_progress = false;\n}\nEXPORT_SYMBOL_GPL(cpufreq_dbs_governor_stop);\n\nvoid cpufreq_dbs_governor_limits(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs;\n\n\t \n\tmutex_lock(&gov_dbs_data_mutex);\n\tpolicy_dbs = policy->governor_data;\n\tif (!policy_dbs)\n\t\tgoto out;\n\n\tmutex_lock(&policy_dbs->update_mutex);\n\tcpufreq_policy_apply_limits(policy);\n\tgov_update_sample_delay(policy_dbs, 0);\n\tmutex_unlock(&policy_dbs->update_mutex);\n\nout:\n\tmutex_unlock(&gov_dbs_data_mutex);\n}\nEXPORT_SYMBOL_GPL(cpufreq_dbs_governor_limits);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}