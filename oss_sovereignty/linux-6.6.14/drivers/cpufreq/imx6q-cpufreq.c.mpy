{
  "module_name": "imx6q-cpufreq.c",
  "hash_id": "8b7237a0a6592ab74c17727ca5fa6c63513e1ea0196c9bee2766825883304552",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/imx6q-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm_opp.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#define PU_SOC_VOLTAGE_NORMAL\t1250000\n#define PU_SOC_VOLTAGE_HIGH\t1275000\n#define FREQ_1P2_GHZ\t\t1200000000\n\nstatic struct regulator *arm_reg;\nstatic struct regulator *pu_reg;\nstatic struct regulator *soc_reg;\n\nenum IMX6_CPUFREQ_CLKS {\n\tARM,\n\tPLL1_SYS,\n\tSTEP,\n\tPLL1_SW,\n\tPLL2_PFD2_396M,\n\t \n\tPLL2_BUS,\n\tSECONDARY_SEL,\n};\n#define IMX6Q_CPUFREQ_CLK_NUM\t\t5\n#define IMX6UL_CPUFREQ_CLK_NUM\t\t7\n\nstatic int num_clks;\nstatic struct clk_bulk_data clks[] = {\n\t{ .id = \"arm\" },\n\t{ .id = \"pll1_sys\" },\n\t{ .id = \"step\" },\n\t{ .id = \"pll1_sw\" },\n\t{ .id = \"pll2_pfd2_396m\" },\n\t{ .id = \"pll2_bus\" },\n\t{ .id = \"secondary_sel\" },\n};\n\nstatic struct device *cpu_dev;\nstatic struct cpufreq_frequency_table *freq_table;\nstatic unsigned int max_freq;\nstatic unsigned int transition_latency;\n\nstatic u32 *imx6_soc_volt;\nstatic u32 soc_opp_count;\n\nstatic int imx6q_set_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tstruct dev_pm_opp *opp;\n\tunsigned long freq_hz, volt, volt_old;\n\tunsigned int old_freq, new_freq;\n\tbool pll1_sys_temp_enabled = false;\n\tint ret;\n\n\tnew_freq = freq_table[index].frequency;\n\tfreq_hz = new_freq * 1000;\n\told_freq = clk_get_rate(clks[ARM].clk) / 1000;\n\n\topp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);\n\tif (IS_ERR(opp)) {\n\t\tdev_err(cpu_dev, \"failed to find OPP for %ld\\n\", freq_hz);\n\t\treturn PTR_ERR(opp);\n\t}\n\n\tvolt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tvolt_old = regulator_get_voltage(arm_reg);\n\n\tdev_dbg(cpu_dev, \"%u MHz, %ld mV --> %u MHz, %ld mV\\n\",\n\t\told_freq / 1000, volt_old / 1000,\n\t\tnew_freq / 1000, volt / 1000);\n\n\t \n\tif (new_freq > old_freq) {\n\t\tif (!IS_ERR(pu_reg)) {\n\t\t\tret = regulator_set_voltage_tol(pu_reg, imx6_soc_volt[index], 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(cpu_dev, \"failed to scale vddpu up: %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tret = regulator_set_voltage_tol(soc_reg, imx6_soc_volt[index], 0);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dev, \"failed to scale vddsoc up: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = regulator_set_voltage_tol(arm_reg, volt, 0);\n\t\tif (ret) {\n\t\t\tdev_err(cpu_dev,\n\t\t\t\t\"failed to scale vddarm up: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (of_machine_is_compatible(\"fsl,imx6ul\") ||\n\t    of_machine_is_compatible(\"fsl,imx6ull\")) {\n\t\t \n\t\tclk_set_rate(clks[ARM].clk, (old_freq >> 1) * 1000);\n\t\tclk_set_parent(clks[PLL1_SW].clk, clks[PLL1_SYS].clk);\n\t\tif (freq_hz > clk_get_rate(clks[PLL2_PFD2_396M].clk))\n\t\t\tclk_set_parent(clks[SECONDARY_SEL].clk,\n\t\t\t\t       clks[PLL2_BUS].clk);\n\t\telse\n\t\t\tclk_set_parent(clks[SECONDARY_SEL].clk,\n\t\t\t\t       clks[PLL2_PFD2_396M].clk);\n\t\tclk_set_parent(clks[STEP].clk, clks[SECONDARY_SEL].clk);\n\t\tclk_set_parent(clks[PLL1_SW].clk, clks[STEP].clk);\n\t\tif (freq_hz > clk_get_rate(clks[PLL2_BUS].clk)) {\n\t\t\tclk_set_rate(clks[PLL1_SYS].clk, new_freq * 1000);\n\t\t\tclk_set_parent(clks[PLL1_SW].clk, clks[PLL1_SYS].clk);\n\t\t}\n\t} else {\n\t\tclk_set_parent(clks[STEP].clk, clks[PLL2_PFD2_396M].clk);\n\t\tclk_set_parent(clks[PLL1_SW].clk, clks[STEP].clk);\n\t\tif (freq_hz > clk_get_rate(clks[PLL2_PFD2_396M].clk)) {\n\t\t\tclk_set_rate(clks[PLL1_SYS].clk, new_freq * 1000);\n\t\t\tclk_set_parent(clks[PLL1_SW].clk, clks[PLL1_SYS].clk);\n\t\t} else {\n\t\t\t \n\t\t\tpll1_sys_temp_enabled = true;\n\t\t\tclk_prepare_enable(clks[PLL1_SYS].clk);\n\t\t}\n\t}\n\n\t \n\tret = clk_set_rate(clks[ARM].clk, new_freq * 1000);\n\tif (ret) {\n\t\tint ret1;\n\n\t\tdev_err(cpu_dev, \"failed to set clock rate: %d\\n\", ret);\n\t\tret1 = regulator_set_voltage_tol(arm_reg, volt_old, 0);\n\t\tif (ret1)\n\t\t\tdev_warn(cpu_dev,\n\t\t\t\t \"failed to restore vddarm voltage: %d\\n\", ret1);\n\t\treturn ret;\n\t}\n\n\t \n\tif (pll1_sys_temp_enabled)\n\t\tclk_disable_unprepare(clks[PLL1_SYS].clk);\n\n\t \n\tif (new_freq < old_freq) {\n\t\tret = regulator_set_voltage_tol(arm_reg, volt, 0);\n\t\tif (ret)\n\t\t\tdev_warn(cpu_dev,\n\t\t\t\t \"failed to scale vddarm down: %d\\n\", ret);\n\t\tret = regulator_set_voltage_tol(soc_reg, imx6_soc_volt[index], 0);\n\t\tif (ret)\n\t\t\tdev_warn(cpu_dev, \"failed to scale vddsoc down: %d\\n\", ret);\n\t\tif (!IS_ERR(pu_reg)) {\n\t\t\tret = regulator_set_voltage_tol(pu_reg, imx6_soc_volt[index], 0);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(cpu_dev, \"failed to scale vddpu down: %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int imx6q_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tpolicy->clk = clks[ARM].clk;\n\tcpufreq_generic_init(policy, freq_table, transition_latency);\n\tpolicy->suspend_freq = max_freq;\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver imx6q_cpufreq_driver = {\n\t.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t CPUFREQ_IS_COOLING_DEV,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = imx6q_set_target,\n\t.get = cpufreq_generic_get,\n\t.init = imx6q_cpufreq_init,\n\t.register_em = cpufreq_register_em_with_opp,\n\t.name = \"imx6q-cpufreq\",\n\t.attr = cpufreq_generic_attr,\n\t.suspend = cpufreq_generic_suspend,\n};\n\nstatic void imx6x_disable_freq_in_opp(struct device *dev, unsigned long freq)\n{\n\tint ret = dev_pm_opp_disable(dev, freq);\n\n\tif (ret < 0 && ret != -ENODEV)\n\t\tdev_warn(dev, \"failed to disable %ldMHz OPP\\n\", freq / 1000000);\n}\n\n#define OCOTP_CFG3\t\t\t0x440\n#define OCOTP_CFG3_SPEED_SHIFT\t\t16\n#define OCOTP_CFG3_SPEED_1P2GHZ\t\t0x3\n#define OCOTP_CFG3_SPEED_996MHZ\t\t0x2\n#define OCOTP_CFG3_SPEED_852MHZ\t\t0x1\n\nstatic int imx6q_opp_check_speed_grading(struct device *dev)\n{\n\tstruct device_node *np;\n\tvoid __iomem *base;\n\tu32 val;\n\tint ret;\n\n\tif (of_property_present(dev->of_node, \"nvmem-cells\")) {\n\t\tret = nvmem_cell_read_u32(dev, \"speed_grade\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tnp = of_find_compatible_node(NULL, NULL, \"fsl,imx6q-ocotp\");\n\t\tif (!np)\n\t\t\treturn -ENOENT;\n\n\t\tbase = of_iomap(np, 0);\n\t\tof_node_put(np);\n\t\tif (!base) {\n\t\t\tdev_err(dev, \"failed to map ocotp\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t \n\t\tval = readl_relaxed(base + OCOTP_CFG3);\n\t\tiounmap(base);\n\t}\n\n\tval >>= OCOTP_CFG3_SPEED_SHIFT;\n\tval &= 0x3;\n\n\tif (val < OCOTP_CFG3_SPEED_996MHZ)\n\t\timx6x_disable_freq_in_opp(dev, 996000000);\n\n\tif (of_machine_is_compatible(\"fsl,imx6q\") ||\n\t    of_machine_is_compatible(\"fsl,imx6qp\")) {\n\t\tif (val != OCOTP_CFG3_SPEED_852MHZ)\n\t\t\timx6x_disable_freq_in_opp(dev, 852000000);\n\n\t\tif (val != OCOTP_CFG3_SPEED_1P2GHZ)\n\t\t\timx6x_disable_freq_in_opp(dev, 1200000000);\n\t}\n\n\treturn 0;\n}\n\n#define OCOTP_CFG3_6UL_SPEED_696MHZ\t0x2\n#define OCOTP_CFG3_6ULL_SPEED_792MHZ\t0x2\n#define OCOTP_CFG3_6ULL_SPEED_900MHZ\t0x3\n\nstatic int imx6ul_opp_check_speed_grading(struct device *dev)\n{\n\tu32 val;\n\tint ret = 0;\n\n\tif (of_property_present(dev->of_node, \"nvmem-cells\")) {\n\t\tret = nvmem_cell_read_u32(dev, \"speed_grade\", &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tstruct device_node *np;\n\t\tvoid __iomem *base;\n\n\t\tnp = of_find_compatible_node(NULL, NULL, \"fsl,imx6ul-ocotp\");\n\t\tif (!np)\n\t\t\tnp = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t\t     \"fsl,imx6ull-ocotp\");\n\t\tif (!np)\n\t\t\treturn -ENOENT;\n\n\t\tbase = of_iomap(np, 0);\n\t\tof_node_put(np);\n\t\tif (!base) {\n\t\t\tdev_err(dev, \"failed to map ocotp\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tval = readl_relaxed(base + OCOTP_CFG3);\n\t\tiounmap(base);\n\t}\n\n\t \n\tval >>= OCOTP_CFG3_SPEED_SHIFT;\n\tval &= 0x3;\n\n\tif (of_machine_is_compatible(\"fsl,imx6ul\"))\n\t\tif (val != OCOTP_CFG3_6UL_SPEED_696MHZ)\n\t\t\timx6x_disable_freq_in_opp(dev, 696000000);\n\n\tif (of_machine_is_compatible(\"fsl,imx6ull\")) {\n\t\tif (val < OCOTP_CFG3_6ULL_SPEED_792MHZ)\n\t\t\timx6x_disable_freq_in_opp(dev, 792000000);\n\n\t\tif (val != OCOTP_CFG3_6ULL_SPEED_900MHZ)\n\t\t\timx6x_disable_freq_in_opp(dev, 900000000);\n\t}\n\n\treturn ret;\n}\n\nstatic int imx6q_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tstruct dev_pm_opp *opp;\n\tunsigned long min_volt, max_volt;\n\tint num, ret;\n\tconst struct property *prop;\n\tconst __be32 *val;\n\tu32 nr, i, j;\n\n\tcpu_dev = get_cpu_device(0);\n\tif (!cpu_dev) {\n\t\tpr_err(\"failed to get cpu0 device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tnp = of_node_get(cpu_dev->of_node);\n\tif (!np) {\n\t\tdev_err(cpu_dev, \"failed to find cpu0 node\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (of_machine_is_compatible(\"fsl,imx6ul\") ||\n\t    of_machine_is_compatible(\"fsl,imx6ull\"))\n\t\tnum_clks = IMX6UL_CPUFREQ_CLK_NUM;\n\telse\n\t\tnum_clks = IMX6Q_CPUFREQ_CLK_NUM;\n\n\tret = clk_bulk_get(cpu_dev, num_clks, clks);\n\tif (ret)\n\t\tgoto put_node;\n\n\tarm_reg = regulator_get(cpu_dev, \"arm\");\n\tpu_reg = regulator_get_optional(cpu_dev, \"pu\");\n\tsoc_reg = regulator_get(cpu_dev, \"soc\");\n\tif (PTR_ERR(arm_reg) == -EPROBE_DEFER ||\n\t\t\tPTR_ERR(soc_reg) == -EPROBE_DEFER ||\n\t\t\tPTR_ERR(pu_reg) == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tdev_dbg(cpu_dev, \"regulators not ready, defer\\n\");\n\t\tgoto put_reg;\n\t}\n\tif (IS_ERR(arm_reg) || IS_ERR(soc_reg)) {\n\t\tdev_err(cpu_dev, \"failed to get regulators\\n\");\n\t\tret = -ENOENT;\n\t\tgoto put_reg;\n\t}\n\n\tret = dev_pm_opp_of_add_table(cpu_dev);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dev, \"failed to init OPP table: %d\\n\", ret);\n\t\tgoto put_reg;\n\t}\n\n\tif (of_machine_is_compatible(\"fsl,imx6ul\") ||\n\t    of_machine_is_compatible(\"fsl,imx6ull\")) {\n\t\tret = imx6ul_opp_check_speed_grading(cpu_dev);\n\t} else {\n\t\tret = imx6q_opp_check_speed_grading(cpu_dev);\n\t}\n\tif (ret) {\n\t\tdev_err_probe(cpu_dev, ret, \"failed to read ocotp\\n\");\n\t\tgoto out_free_opp;\n\t}\n\n\tnum = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (num < 0) {\n\t\tret = num;\n\t\tdev_err(cpu_dev, \"no OPP table is found: %d\\n\", ret);\n\t\tgoto out_free_opp;\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed to init cpufreq table: %d\\n\", ret);\n\t\tgoto out_free_opp;\n\t}\n\n\t \n\timx6_soc_volt = devm_kcalloc(cpu_dev, num, sizeof(*imx6_soc_volt),\n\t\t\t\t     GFP_KERNEL);\n\tif (imx6_soc_volt == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto free_freq_table;\n\t}\n\n\tprop = of_find_property(np, \"fsl,soc-operating-points\", NULL);\n\tif (!prop || !prop->value)\n\t\tgoto soc_opp_out;\n\n\t \n\tnr = prop->length / sizeof(u32);\n\tif (nr % 2 || (nr / 2) < num)\n\t\tgoto soc_opp_out;\n\n\tfor (j = 0; j < num; j++) {\n\t\tval = prop->value;\n\t\tfor (i = 0; i < nr / 2; i++) {\n\t\t\tunsigned long freq = be32_to_cpup(val++);\n\t\t\tunsigned long volt = be32_to_cpup(val++);\n\t\t\tif (freq_table[j].frequency == freq) {\n\t\t\t\timx6_soc_volt[soc_opp_count++] = volt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nsoc_opp_out:\n\t \n\tif (soc_opp_count != num) {\n\t\tdev_warn(cpu_dev, \"can NOT find valid fsl,soc-operating-points property in dtb, use default value!\\n\");\n\t\tfor (j = 0; j < num; j++)\n\t\t\timx6_soc_volt[j] = PU_SOC_VOLTAGE_NORMAL;\n\t\tif (freq_table[num - 1].frequency * 1000 == FREQ_1P2_GHZ)\n\t\t\timx6_soc_volt[num - 1] = PU_SOC_VOLTAGE_HIGH;\n\t}\n\n\tif (of_property_read_u32(np, \"clock-latency\", &transition_latency))\n\t\ttransition_latency = CPUFREQ_ETERNAL;\n\n\t \n\tret = regulator_set_voltage_time(soc_reg, imx6_soc_volt[0], imx6_soc_volt[num - 1]);\n\tif (ret > 0)\n\t\ttransition_latency += ret * 1000;\n\tif (!IS_ERR(pu_reg)) {\n\t\tret = regulator_set_voltage_time(pu_reg, imx6_soc_volt[0], imx6_soc_volt[num - 1]);\n\t\tif (ret > 0)\n\t\t\ttransition_latency += ret * 1000;\n\t}\n\n\t \n\tmax_freq = freq_table[--num].frequency;\n\topp = dev_pm_opp_find_freq_exact(cpu_dev,\n\t\t\t\t  freq_table[0].frequency * 1000, true);\n\tmin_volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\topp = dev_pm_opp_find_freq_exact(cpu_dev, max_freq * 1000, true);\n\tmax_volt = dev_pm_opp_get_voltage(opp);\n\tdev_pm_opp_put(opp);\n\n\tret = regulator_set_voltage_time(arm_reg, min_volt, max_volt);\n\tif (ret > 0)\n\t\ttransition_latency += ret * 1000;\n\n\tret = cpufreq_register_driver(&imx6q_cpufreq_driver);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed register driver: %d\\n\", ret);\n\t\tgoto free_freq_table;\n\t}\n\n\tof_node_put(np);\n\treturn 0;\n\nfree_freq_table:\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\nout_free_opp:\n\tdev_pm_opp_of_remove_table(cpu_dev);\nput_reg:\n\tif (!IS_ERR(arm_reg))\n\t\tregulator_put(arm_reg);\n\tif (!IS_ERR(pu_reg))\n\t\tregulator_put(pu_reg);\n\tif (!IS_ERR(soc_reg))\n\t\tregulator_put(soc_reg);\n\n\tclk_bulk_put(num_clks, clks);\nput_node:\n\tof_node_put(np);\n\n\treturn ret;\n}\n\nstatic void imx6q_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&imx6q_cpufreq_driver);\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\n\tdev_pm_opp_of_remove_table(cpu_dev);\n\tregulator_put(arm_reg);\n\tif (!IS_ERR(pu_reg))\n\t\tregulator_put(pu_reg);\n\tregulator_put(soc_reg);\n\n\tclk_bulk_put(num_clks, clks);\n}\n\nstatic struct platform_driver imx6q_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"imx6q-cpufreq\",\n\t},\n\t.probe\t\t= imx6q_cpufreq_probe,\n\t.remove_new\t= imx6q_cpufreq_remove,\n};\nmodule_platform_driver(imx6q_cpufreq_platdrv);\n\nMODULE_ALIAS(\"platform:imx6q-cpufreq\");\nMODULE_AUTHOR(\"Shawn Guo <shawn.guo@linaro.org>\");\nMODULE_DESCRIPTION(\"Freescale i.MX6Q cpufreq driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}