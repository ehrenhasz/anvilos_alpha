{
  "module_name": "pasemi-cpufreq.c",
  "hash_id": "dedcbc55bae929e51c895314b5bfec3f63dc7f621f0e6a62adcddc54df4589d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/pasemi-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpufreq.h>\n#include <linux/timer.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n\n#include <asm/hw_irq.h>\n#include <asm/io.h>\n#include <asm/time.h>\n#include <asm/smp.h>\n\n#include <platforms/pasemi/pasemi.h>\n\n#define SDCASR_REG\t\t0x0100\n#define SDCASR_REG_STRIDE\t0x1000\n#define SDCPWR_CFGA0_REG\t0x0100\n#define SDCPWR_PWST0_REG\t0x0000\n#define SDCPWR_GIZTIME_REG\t0x0440\n\n \n#define SDCPWR_GIZTIME_GR\t0x80000000\n#define SDCPWR_GIZTIME_LONGLOCK\t0x000000ff\n\n \n#define SDCASR_OFFSET\t\t0x120000\n\nstatic void __iomem *sdcpwr_mapbase;\nstatic void __iomem *sdcasr_mapbase;\n\n \nstatic int current_astate;\n\n \nstatic struct cpufreq_frequency_table pas_freqs[] = {\n\t{0, 0,\t0},\n\t{0, 1,\t0},\n\t{0, 2,\t0},\n\t{0, 3,\t0},\n\t{0, 4,\t0},\n\t{0, 0,\tCPUFREQ_TABLE_END},\n};\n\n \n\nstatic int get_astate_freq(int astate)\n{\n\tu32 ret;\n\tret = in_le32(sdcpwr_mapbase + SDCPWR_CFGA0_REG + (astate * 0x10));\n\n\treturn ret & 0x3f;\n}\n\nstatic int get_cur_astate(int cpu)\n{\n\tu32 ret;\n\n\tret = in_le32(sdcpwr_mapbase + SDCPWR_PWST0_REG);\n\tret = (ret >> (cpu * 4)) & 0x7;\n\n\treturn ret;\n}\n\nstatic int get_gizmo_latency(void)\n{\n\tu32 giztime, ret;\n\n\tgiztime = in_le32(sdcpwr_mapbase + SDCPWR_GIZTIME_REG);\n\n\t \n\tif (giztime & SDCPWR_GIZTIME_GR)\n\t\tret = (giztime & SDCPWR_GIZTIME_LONGLOCK) * 128000;\n\telse\n\t\tret = (giztime & SDCPWR_GIZTIME_LONGLOCK) * 1000;\n\n\treturn ret;\n}\n\nstatic void set_astate(int cpu, unsigned int astate)\n{\n\tunsigned long flags;\n\n\t \n\tif (unlikely(!sdcasr_mapbase))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tout_le32(sdcasr_mapbase + SDCASR_REG + SDCASR_REG_STRIDE*cpu, astate);\n\n\tlocal_irq_restore(flags);\n}\n\nint check_astate(void)\n{\n\treturn get_cur_astate(hard_smp_processor_id());\n}\n\nvoid restore_astate(int cpu)\n{\n\tset_astate(cpu, current_astate);\n}\n\n \n\nstatic int pas_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tconst u32 *max_freqp;\n\tu32 max_freq;\n\tint cur_astate, idx;\n\tstruct resource res;\n\tstruct device_node *cpu, *dn;\n\tint err = -ENODEV;\n\n\tcpu = of_get_cpu_node(policy->cpu, NULL);\n\tif (!cpu)\n\t\tgoto out;\n\n\tmax_freqp = of_get_property(cpu, \"clock-frequency\", NULL);\n\tof_node_put(cpu);\n\tif (!max_freqp) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tmax_freq = *max_freqp / 1000;\n\n\tdn = of_find_compatible_node(NULL, NULL, \"1682m-sdc\");\n\tif (!dn)\n\t\tdn = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t     \"pasemi,pwrficient-sdc\");\n\tif (!dn)\n\t\tgoto out;\n\terr = of_address_to_resource(dn, 0, &res);\n\tof_node_put(dn);\n\tif (err)\n\t\tgoto out;\n\tsdcasr_mapbase = ioremap(res.start + SDCASR_OFFSET, 0x2000);\n\tif (!sdcasr_mapbase) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdn = of_find_compatible_node(NULL, NULL, \"1682m-gizmo\");\n\tif (!dn)\n\t\tdn = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t     \"pasemi,pwrficient-gizmo\");\n\tif (!dn) {\n\t\terr = -ENODEV;\n\t\tgoto out_unmap_sdcasr;\n\t}\n\terr = of_address_to_resource(dn, 0, &res);\n\tof_node_put(dn);\n\tif (err)\n\t\tgoto out_unmap_sdcasr;\n\tsdcpwr_mapbase = ioremap(res.start, 0x1000);\n\tif (!sdcpwr_mapbase) {\n\t\terr = -EINVAL;\n\t\tgoto out_unmap_sdcasr;\n\t}\n\n\tpr_debug(\"init cpufreq on CPU %d\\n\", policy->cpu);\n\tpr_debug(\"max clock-frequency is at %u kHz\\n\", max_freq);\n\tpr_debug(\"initializing frequency table\\n\");\n\n\t \n\tcpufreq_for_each_entry_idx(pos, pas_freqs, idx) {\n\t\tpos->frequency = get_astate_freq(pos->driver_data) * 100000;\n\t\tpr_debug(\"%d: %d\\n\", idx, pos->frequency);\n\t}\n\n\tcur_astate = get_cur_astate(policy->cpu);\n\tpr_debug(\"current astate is at %d\\n\",cur_astate);\n\n\tpolicy->cur = pas_freqs[cur_astate].frequency;\n\tppc_proc_freq = policy->cur * 1000ul;\n\n\tcpufreq_generic_init(policy, pas_freqs, get_gizmo_latency());\n\treturn 0;\n\nout_unmap_sdcasr:\n\tiounmap(sdcasr_mapbase);\nout:\n\treturn err;\n}\n\nstatic int pas_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\t \n\tif (system_state >= SYSTEM_RUNNING)\n\t\treturn 0;\n\n\tif (sdcasr_mapbase)\n\t\tiounmap(sdcasr_mapbase);\n\tif (sdcpwr_mapbase)\n\t\tiounmap(sdcpwr_mapbase);\n\n\treturn 0;\n}\n\nstatic int pas_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t      unsigned int pas_astate_new)\n{\n\tint i;\n\n\tpr_debug(\"setting frequency for cpu %d to %d kHz, 1/%d of max frequency\\n\",\n\t\t policy->cpu,\n\t\t pas_freqs[pas_astate_new].frequency,\n\t\t pas_freqs[pas_astate_new].driver_data);\n\n\tcurrent_astate = pas_astate_new;\n\n\tfor_each_online_cpu(i)\n\t\tset_astate(i, pas_astate_new);\n\n\tppc_proc_freq = pas_freqs[pas_astate_new].frequency * 1000ul;\n\treturn 0;\n}\n\nstatic struct cpufreq_driver pas_cpufreq_driver = {\n\t.name\t\t= \"pas-cpufreq\",\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.init\t\t= pas_cpufreq_cpu_init,\n\t.exit\t\t= pas_cpufreq_cpu_exit,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= pas_cpufreq_target,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\n \n\nstatic int __init pas_cpufreq_init(void)\n{\n\tif (!of_machine_is_compatible(\"PA6T-1682M\") &&\n\t    !of_machine_is_compatible(\"pasemi,pwrficient\"))\n\t\treturn -ENODEV;\n\n\treturn cpufreq_register_driver(&pas_cpufreq_driver);\n}\n\nstatic void __exit pas_cpufreq_exit(void)\n{\n\tcpufreq_unregister_driver(&pas_cpufreq_driver);\n}\n\nmodule_init(pas_cpufreq_init);\nmodule_exit(pas_cpufreq_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Egor Martovetsky <egor@pasemi.com>, Olof Johansson <olof@lixom.net>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}