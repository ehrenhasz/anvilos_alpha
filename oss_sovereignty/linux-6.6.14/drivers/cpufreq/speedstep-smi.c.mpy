{
  "module_name": "speedstep-smi.c",
  "hash_id": "f8557811af245cb31a501cd145045216947d4fa753e64e93914ef92573294731",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/speedstep-smi.c",
  "human_readable_source": "\n \n\n\n \n\n#define pr_fmt(fmt) \"cpufreq: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <asm/ist.h>\n#include <asm/cpu_device_id.h>\n\n#include \"speedstep-lib.h\"\n\n \nstatic int smi_port;\nstatic int smi_cmd;\nstatic unsigned int smi_sig;\n\n \nstatic enum speedstep_processor speedstep_processor;\n\n \nstatic struct cpufreq_frequency_table speedstep_freqs[] = {\n\t{0, SPEEDSTEP_HIGH,\t0},\n\t{0, SPEEDSTEP_LOW,\t0},\n\t{0, 0,\t\t\tCPUFREQ_TABLE_END},\n};\n\n#define GET_SPEEDSTEP_OWNER 0\n#define GET_SPEEDSTEP_STATE 1\n#define SET_SPEEDSTEP_STATE 2\n#define GET_SPEEDSTEP_FREQS 4\n\n \n#define SMI_TRIES 5\n\n \nstatic int speedstep_smi_ownership(void)\n{\n\tu32 command, result, magic, dummy;\n\tu32 function = GET_SPEEDSTEP_OWNER;\n\tunsigned char magic_data[] = \"Copyright (c) 1999 Intel Corporation\";\n\n\tcommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\n\tmagic = virt_to_phys(magic_data);\n\n\tpr_debug(\"trying to obtain ownership with command %x at port %x\\n\",\n\t\t\tcommand, smi_port);\n\n\t__asm__ __volatile__(\n\t\t\"push %%ebp\\n\"\n\t\t\"out %%al, (%%dx)\\n\"\n\t\t\"pop %%ebp\\n\"\n\t\t: \"=D\" (result),\n\t\t  \"=a\" (dummy), \"=b\" (dummy), \"=c\" (dummy), \"=d\" (dummy),\n\t\t  \"=S\" (dummy)\n\t\t: \"a\" (command), \"b\" (function), \"c\" (0), \"d\" (smi_port),\n\t\t  \"D\" (0), \"S\" (magic)\n\t\t: \"memory\"\n\t);\n\n\tpr_debug(\"result is %x\\n\", result);\n\n\treturn result;\n}\n\n \nstatic int speedstep_smi_get_freqs(unsigned int *low, unsigned int *high)\n{\n\tu32 command, result = 0, edi, high_mhz, low_mhz, dummy;\n\tu32 state = 0;\n\tu32 function = GET_SPEEDSTEP_FREQS;\n\n\tif (!(ist_info.event & 0xFFFF)) {\n\t\tpr_debug(\"bug #1422 -- can't read freqs from BIOS\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\n\n\tpr_debug(\"trying to determine frequencies with command %x at port %x\\n\",\n\t\t\tcommand, smi_port);\n\n\t__asm__ __volatile__(\n\t\t\"push %%ebp\\n\"\n\t\t\"out %%al, (%%dx)\\n\"\n\t\t\"pop %%ebp\"\n\t\t: \"=a\" (result),\n\t\t  \"=b\" (high_mhz),\n\t\t  \"=c\" (low_mhz),\n\t\t  \"=d\" (state), \"=D\" (edi), \"=S\" (dummy)\n\t\t: \"a\" (command),\n\t\t  \"b\" (function),\n\t\t  \"c\" (state),\n\t\t  \"d\" (smi_port), \"S\" (0), \"D\" (0)\n\t);\n\n\tpr_debug(\"result %x, low_freq %u, high_freq %u\\n\",\n\t\t\tresult, low_mhz, high_mhz);\n\n\t \n\tif ((high_mhz + low_mhz) < 600)\n\t\treturn -EINVAL;\n\n\t*high = high_mhz * 1000;\n\t*low  = low_mhz  * 1000;\n\n\treturn result;\n}\n\n \nstatic void speedstep_set_state(unsigned int state)\n{\n\tunsigned int result = 0, command, new_state, dummy;\n\tunsigned long flags;\n\tunsigned int function = SET_SPEEDSTEP_STATE;\n\tunsigned int retry = 0;\n\n\tif (state > 0x1)\n\t\treturn;\n\n\t \n\tpreempt_disable();\n\tlocal_irq_save(flags);\n\n\tcommand = (smi_sig & 0xffffff00) | (smi_cmd & 0xff);\n\n\tpr_debug(\"trying to set frequency to state %u \"\n\t\t\"with command %x at port %x\\n\",\n\t\tstate, command, smi_port);\n\n\tdo {\n\t\tif (retry) {\n\t\t\t \n\t\t\tpr_debug(\"retry %u, previous result %u, waiting...\\n\",\n\t\t\t\t\tretry, result);\n\t\t\tlocal_irq_enable();\n\t\t\tmdelay(retry * 50);\n\t\t\tlocal_irq_disable();\n\t\t}\n\t\tretry++;\n\t\t__asm__ __volatile__(\n\t\t\t\"push %%ebp\\n\"\n\t\t\t\"out %%al, (%%dx)\\n\"\n\t\t\t\"pop %%ebp\"\n\t\t\t: \"=b\" (new_state), \"=D\" (result),\n\t\t\t  \"=c\" (dummy), \"=a\" (dummy),\n\t\t\t  \"=d\" (dummy), \"=S\" (dummy)\n\t\t\t: \"a\" (command), \"b\" (function), \"c\" (state),\n\t\t\t  \"d\" (smi_port), \"S\" (0), \"D\" (0)\n\t\t\t);\n\t} while ((new_state != state) && (retry <= SMI_TRIES));\n\n\t \n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\tif (new_state == state)\n\t\tpr_debug(\"change to %u MHz succeeded after %u tries \"\n\t\t\t\"with result %u\\n\",\n\t\t\t(speedstep_freqs[new_state].frequency / 1000),\n\t\t\tretry, result);\n\telse\n\t\tpr_err(\"change to state %u failed with new_state %u and result %u\\n\",\n\t\t       state, new_state, result);\n\n\treturn;\n}\n\n\n \nstatic int speedstep_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tspeedstep_set_state(index);\n\n\treturn 0;\n}\n\n\nstatic int speedstep_cpu_init(struct cpufreq_policy *policy)\n{\n\tint result;\n\tunsigned int *low, *high;\n\n\t \n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\tresult = speedstep_smi_ownership();\n\tif (result) {\n\t\tpr_debug(\"fails in acquiring ownership of a SMI interface.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlow = &speedstep_freqs[SPEEDSTEP_LOW].frequency;\n\thigh = &speedstep_freqs[SPEEDSTEP_HIGH].frequency;\n\n\tresult = speedstep_smi_get_freqs(low, high);\n\tif (result) {\n\t\t \n\t\tpr_debug(\"could not detect low and high frequencies \"\n\t\t\t\t\"by SMI call.\\n\");\n\t\tresult = speedstep_get_freqs(speedstep_processor,\n\t\t\t\tlow, high,\n\t\t\t\tNULL,\n\t\t\t\t&speedstep_set_state);\n\n\t\tif (result) {\n\t\t\tpr_debug(\"could not detect two different speeds\"\n\t\t\t\t\t\" -- aborting.\\n\");\n\t\t\treturn result;\n\t\t} else\n\t\t\tpr_debug(\"workaround worked.\\n\");\n\t}\n\n\tpolicy->freq_table = speedstep_freqs;\n\n\treturn 0;\n}\n\nstatic unsigned int speedstep_get(unsigned int cpu)\n{\n\tif (cpu)\n\t\treturn -ENODEV;\n\treturn speedstep_get_frequency(speedstep_processor);\n}\n\n\nstatic int speedstep_resume(struct cpufreq_policy *policy)\n{\n\tint result = speedstep_smi_ownership();\n\n\tif (result)\n\t\tpr_debug(\"fails in re-acquiring ownership of a SMI interface.\\n\");\n\n\treturn result;\n}\n\nstatic struct cpufreq_driver speedstep_driver = {\n\t.name\t\t= \"speedstep-smi\",\n\t.flags\t\t= CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= speedstep_target,\n\t.init\t\t= speedstep_cpu_init,\n\t.get\t\t= speedstep_get,\n\t.resume\t\t= speedstep_resume,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic const struct x86_cpu_id ss_smi_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL,  6, 0x8, 0),\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL,  6, 0xb, 0),\n\tX86_MATCH_VENDOR_FAM_MODEL(INTEL, 15, 0x2, 0),\n\t{}\n};\n\n \nstatic int __init speedstep_init(void)\n{\n\tif (!x86_match_cpu(ss_smi_ids))\n\t\treturn -ENODEV;\n\n\tspeedstep_processor = speedstep_detect_processor();\n\n\tswitch (speedstep_processor) {\n\tcase SPEEDSTEP_CPU_PIII_T:\n\tcase SPEEDSTEP_CPU_PIII_C:\n\tcase SPEEDSTEP_CPU_PIII_C_EARLY:\n\t\tbreak;\n\tdefault:\n\t\tspeedstep_processor = 0;\n\t}\n\n\tif (!speedstep_processor) {\n\t\tpr_debug(\"No supported Intel CPU detected.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"signature:0x%.8x, command:0x%.8x, \"\n\t\t\"event:0x%.8x, perf_level:0x%.8x.\\n\",\n\t\tist_info.signature, ist_info.command,\n\t\tist_info.event, ist_info.perf_level);\n\n\t \n\tif ((ist_info.signature !=  0x47534943) && (\n\t    (smi_port == 0) || (smi_cmd == 0)))\n\t\treturn -ENODEV;\n\n\tif (smi_sig == 1)\n\t\tsmi_sig = 0x47534943;\n\telse\n\t\tsmi_sig = ist_info.signature;\n\n\t \n\tif ((smi_port > 0xff) || (smi_port < 0))\n\t\treturn -EINVAL;\n\telse if (smi_port == 0)\n\t\tsmi_port = ist_info.command & 0xff;\n\n\tif ((smi_cmd > 0xff) || (smi_cmd < 0))\n\t\treturn -EINVAL;\n\telse if (smi_cmd == 0)\n\t\tsmi_cmd = (ist_info.command >> 16) & 0xff;\n\n\treturn cpufreq_register_driver(&speedstep_driver);\n}\n\n\n \nstatic void __exit speedstep_exit(void)\n{\n\tcpufreq_unregister_driver(&speedstep_driver);\n}\n\nmodule_param_hw(smi_port, int, ioport, 0444);\nmodule_param(smi_cmd,  int, 0444);\nmodule_param(smi_sig, uint, 0444);\n\nMODULE_PARM_DESC(smi_port, \"Override the BIOS-given IST port with this value \"\n\t\t\"-- Intel's default setting is 0xb2\");\nMODULE_PARM_DESC(smi_cmd, \"Override the BIOS-given IST command with this value \"\n\t\t\"-- Intel's default setting is 0x82\");\nMODULE_PARM_DESC(smi_sig, \"Set to 1 to fake the IST signature when using the \"\n\t\t\"SMI interface.\");\n\nMODULE_AUTHOR(\"Hiroshi Miura\");\nMODULE_DESCRIPTION(\"Speedstep driver for IST applet SMI interface.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(speedstep_init);\nmodule_exit(speedstep_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}