{
  "module_name": "intel_pstate.c",
  "hash_id": "3c8eab9dc0afce6a621b56da66ae7e5f39fd3b3155e0717ec763ababbc79b478",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/intel_pstate.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/kernel_stat.h>\n#include <linux/module.h>\n#include <linux/ktime.h>\n#include <linux/hrtimer.h>\n#include <linux/tick.h>\n#include <linux/slab.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/sysfs.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/acpi.h>\n#include <linux/vmalloc.h>\n#include <linux/pm_qos.h>\n#include <trace/events/power.h>\n\n#include <asm/cpu.h>\n#include <asm/div64.h>\n#include <asm/msr.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpufeature.h>\n#include <asm/intel-family.h>\n#include \"../drivers/thermal/intel/thermal_interrupt.h\"\n\n#define INTEL_PSTATE_SAMPLING_INTERVAL\t(10 * NSEC_PER_MSEC)\n\n#define INTEL_CPUFREQ_TRANSITION_LATENCY\t20000\n#define INTEL_CPUFREQ_TRANSITION_DELAY_HWP\t5000\n#define INTEL_CPUFREQ_TRANSITION_DELAY\t\t500\n\n#ifdef CONFIG_ACPI\n#include <acpi/processor.h>\n#include <acpi/cppc_acpi.h>\n#endif\n\n#define FRAC_BITS 8\n#define int_tofp(X) ((int64_t)(X) << FRAC_BITS)\n#define fp_toint(X) ((X) >> FRAC_BITS)\n\n#define ONE_EIGHTH_FP ((int64_t)1 << (FRAC_BITS - 3))\n\n#define EXT_BITS 6\n#define EXT_FRAC_BITS (EXT_BITS + FRAC_BITS)\n#define fp_ext_toint(X) ((X) >> EXT_FRAC_BITS)\n#define int_ext_tofp(X) ((int64_t)(X) << EXT_FRAC_BITS)\n\nstatic inline int32_t mul_fp(int32_t x, int32_t y)\n{\n\treturn ((int64_t)x * (int64_t)y) >> FRAC_BITS;\n}\n\nstatic inline int32_t div_fp(s64 x, s64 y)\n{\n\treturn div64_s64((int64_t)x << FRAC_BITS, y);\n}\n\nstatic inline int ceiling_fp(int32_t x)\n{\n\tint mask, ret;\n\n\tret = fp_toint(x);\n\tmask = (1 << FRAC_BITS) - 1;\n\tif (x & mask)\n\t\tret += 1;\n\treturn ret;\n}\n\nstatic inline u64 mul_ext_fp(u64 x, u64 y)\n{\n\treturn (x * y) >> EXT_FRAC_BITS;\n}\n\nstatic inline u64 div_ext_fp(u64 x, u64 y)\n{\n\treturn div64_u64(x << EXT_FRAC_BITS, y);\n}\n\n \nstruct sample {\n\tint32_t core_avg_perf;\n\tint32_t busy_scaled;\n\tu64 aperf;\n\tu64 mperf;\n\tu64 tsc;\n\tu64 time;\n};\n\n \nstruct pstate_data {\n\tint\tcurrent_pstate;\n\tint\tmin_pstate;\n\tint\tmax_pstate;\n\tint\tmax_pstate_physical;\n\tint\tperf_ctl_scaling;\n\tint\tscaling;\n\tint\tturbo_pstate;\n\tunsigned int min_freq;\n\tunsigned int max_freq;\n\tunsigned int turbo_freq;\n};\n\n \nstruct vid_data {\n\tint min;\n\tint max;\n\tint turbo;\n\tint32_t ratio;\n};\n\n \nstruct global_params {\n\tbool no_turbo;\n\tbool turbo_disabled;\n\tbool turbo_disabled_mf;\n\tint max_perf_pct;\n\tint min_perf_pct;\n};\n\n \nstruct cpudata {\n\tint cpu;\n\n\tunsigned int policy;\n\tstruct update_util_data update_util;\n\tbool   update_util_set;\n\n\tstruct pstate_data pstate;\n\tstruct vid_data vid;\n\n\tu64\tlast_update;\n\tu64\tlast_sample_time;\n\tu64\taperf_mperf_shift;\n\tu64\tprev_aperf;\n\tu64\tprev_mperf;\n\tu64\tprev_tsc;\n\tu64\tprev_cummulative_iowait;\n\tstruct sample sample;\n\tint32_t\tmin_perf_ratio;\n\tint32_t\tmax_perf_ratio;\n#ifdef CONFIG_ACPI\n\tstruct acpi_processor_performance acpi_perf_data;\n\tbool valid_pss_table;\n#endif\n\tunsigned int iowait_boost;\n\ts16 epp_powersave;\n\ts16 epp_policy;\n\ts16 epp_default;\n\ts16 epp_cached;\n\tu64 hwp_req_cached;\n\tu64 hwp_cap_cached;\n\tu64 last_io_update;\n\tunsigned int sched_flags;\n\tu32 hwp_boost_min;\n\tbool suspended;\n\tstruct delayed_work hwp_notify_work;\n};\n\nstatic struct cpudata **all_cpu_data;\n\n \nstruct pstate_funcs {\n\tint (*get_max)(int cpu);\n\tint (*get_max_physical)(int cpu);\n\tint (*get_min)(int cpu);\n\tint (*get_turbo)(int cpu);\n\tint (*get_scaling)(void);\n\tint (*get_cpu_scaling)(int cpu);\n\tint (*get_aperf_mperf_shift)(void);\n\tu64 (*get_val)(struct cpudata*, int pstate);\n\tvoid (*get_vid)(struct cpudata *);\n};\n\nstatic struct pstate_funcs pstate_funcs __read_mostly;\n\nstatic int hwp_active __read_mostly;\nstatic int hwp_mode_bdw __read_mostly;\nstatic bool per_cpu_limits __read_mostly;\nstatic bool hwp_boost __read_mostly;\nstatic bool hwp_forced __read_mostly;\n\nstatic struct cpufreq_driver *intel_pstate_driver __read_mostly;\n\n#define HYBRID_SCALING_FACTOR\t78741\n\nstatic inline int core_get_scaling(void)\n{\n\treturn 100000;\n}\n\n#ifdef CONFIG_ACPI\nstatic bool acpi_ppc;\n#endif\n\nstatic struct global_params global;\n\nstatic DEFINE_MUTEX(intel_pstate_driver_lock);\nstatic DEFINE_MUTEX(intel_pstate_limits_lock);\n\n#ifdef CONFIG_ACPI\n\nstatic bool intel_pstate_acpi_pm_profile_server(void)\n{\n\tif (acpi_gbl_FADT.preferred_profile == PM_ENTERPRISE_SERVER ||\n\t    acpi_gbl_FADT.preferred_profile == PM_PERFORMANCE_SERVER)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool intel_pstate_get_ppc_enable_status(void)\n{\n\tif (intel_pstate_acpi_pm_profile_server())\n\t\treturn true;\n\n\treturn acpi_ppc;\n}\n\n#ifdef CONFIG_ACPI_CPPC_LIB\n\n \nstatic void intel_pstste_sched_itmt_work_fn(struct work_struct *work)\n{\n\tsched_set_itmt_support();\n}\n\nstatic DECLARE_WORK(sched_itmt_work, intel_pstste_sched_itmt_work_fn);\n\n#define CPPC_MAX_PERF\tU8_MAX\n\nstatic void intel_pstate_set_itmt_prio(int cpu)\n{\n\tstruct cppc_perf_caps cppc_perf;\n\tstatic u32 max_highest_perf = 0, min_highest_perf = U32_MAX;\n\tint ret;\n\n\tret = cppc_get_perf_caps(cpu, &cppc_perf);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (cppc_perf.highest_perf == CPPC_MAX_PERF)\n\t\tcppc_perf.highest_perf = HWP_HIGHEST_PERF(READ_ONCE(all_cpu_data[cpu]->hwp_cap_cached));\n\n\t \n\tsched_set_itmt_core_prio(cppc_perf.highest_perf, cpu);\n\n\tif (max_highest_perf <= min_highest_perf) {\n\t\tif (cppc_perf.highest_perf > max_highest_perf)\n\t\t\tmax_highest_perf = cppc_perf.highest_perf;\n\n\t\tif (cppc_perf.highest_perf < min_highest_perf)\n\t\t\tmin_highest_perf = cppc_perf.highest_perf;\n\n\t\tif (max_highest_perf > min_highest_perf) {\n\t\t\t \n\t\t\tschedule_work(&sched_itmt_work);\n\t\t}\n\t}\n}\n\nstatic int intel_pstate_get_cppc_guaranteed(int cpu)\n{\n\tstruct cppc_perf_caps cppc_perf;\n\tint ret;\n\n\tret = cppc_get_perf_caps(cpu, &cppc_perf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cppc_perf.guaranteed_perf)\n\t\treturn cppc_perf.guaranteed_perf;\n\n\treturn cppc_perf.nominal_perf;\n}\n\nstatic int intel_pstate_cppc_get_scaling(int cpu)\n{\n\tstruct cppc_perf_caps cppc_perf;\n\tint ret;\n\n\tret = cppc_get_perf_caps(cpu, &cppc_perf);\n\n\t \n\tif (!ret && cppc_perf.nominal_perf && cppc_perf.nominal_freq &&\n\t    cppc_perf.nominal_perf * 100 != cppc_perf.nominal_freq)\n\t\treturn HYBRID_SCALING_FACTOR;\n\n\treturn core_get_scaling();\n}\n\n#else  \nstatic inline void intel_pstate_set_itmt_prio(int cpu)\n{\n}\n#endif  \n\nstatic void intel_pstate_init_acpi_perf_limits(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu;\n\tint ret;\n\tint i;\n\n\tif (hwp_active) {\n\t\tintel_pstate_set_itmt_prio(policy->cpu);\n\t\treturn;\n\t}\n\n\tif (!intel_pstate_get_ppc_enable_status())\n\t\treturn;\n\n\tcpu = all_cpu_data[policy->cpu];\n\n\tret = acpi_processor_register_performance(&cpu->acpi_perf_data,\n\t\t\t\t\t\t  policy->cpu);\n\tif (ret)\n\t\treturn;\n\n\t \n\tif (cpu->acpi_perf_data.control_register.space_id !=\n\t\t\t\t\t\tACPI_ADR_SPACE_FIXED_HARDWARE)\n\t\tgoto err;\n\n\t \n\tif (cpu->acpi_perf_data.state_count < 2)\n\t\tgoto err;\n\n\tpr_debug(\"CPU%u - ACPI _PSS perf data\\n\", policy->cpu);\n\tfor (i = 0; i < cpu->acpi_perf_data.state_count; i++) {\n\t\tpr_debug(\"     %cP%d: %u MHz, %u mW, 0x%x\\n\",\n\t\t\t (i == cpu->acpi_perf_data.state ? '*' : ' '), i,\n\t\t\t (u32) cpu->acpi_perf_data.states[i].core_frequency,\n\t\t\t (u32) cpu->acpi_perf_data.states[i].power,\n\t\t\t (u32) cpu->acpi_perf_data.states[i].control);\n\t}\n\n\tcpu->valid_pss_table = true;\n\tpr_debug(\"_PPC limits will be enforced\\n\");\n\n\treturn;\n\n err:\n\tcpu->valid_pss_table = false;\n\tacpi_processor_unregister_performance(policy->cpu);\n}\n\nstatic void intel_pstate_exit_perf_limits(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu;\n\n\tcpu = all_cpu_data[policy->cpu];\n\tif (!cpu->valid_pss_table)\n\t\treturn;\n\n\tacpi_processor_unregister_performance(policy->cpu);\n}\n#else  \nstatic inline void intel_pstate_init_acpi_perf_limits(struct cpufreq_policy *policy)\n{\n}\n\nstatic inline void intel_pstate_exit_perf_limits(struct cpufreq_policy *policy)\n{\n}\n\nstatic inline bool intel_pstate_acpi_pm_profile_server(void)\n{\n\treturn false;\n}\n#endif  \n\n#ifndef CONFIG_ACPI_CPPC_LIB\nstatic inline int intel_pstate_get_cppc_guaranteed(int cpu)\n{\n\treturn -ENOTSUPP;\n}\n\nstatic int intel_pstate_cppc_get_scaling(int cpu)\n{\n\treturn core_get_scaling();\n}\n#endif  \n\n \nstatic void intel_pstate_hybrid_hwp_adjust(struct cpudata *cpu)\n{\n\tint perf_ctl_max_phys = cpu->pstate.max_pstate_physical;\n\tint perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;\n\tint perf_ctl_turbo = pstate_funcs.get_turbo(cpu->cpu);\n\tint scaling = cpu->pstate.scaling;\n\n\tpr_debug(\"CPU%d: perf_ctl_max_phys = %d\\n\", cpu->cpu, perf_ctl_max_phys);\n\tpr_debug(\"CPU%d: perf_ctl_turbo = %d\\n\", cpu->cpu, perf_ctl_turbo);\n\tpr_debug(\"CPU%d: perf_ctl_scaling = %d\\n\", cpu->cpu, perf_ctl_scaling);\n\tpr_debug(\"CPU%d: HWP_CAP guaranteed = %d\\n\", cpu->cpu, cpu->pstate.max_pstate);\n\tpr_debug(\"CPU%d: HWP_CAP highest = %d\\n\", cpu->cpu, cpu->pstate.turbo_pstate);\n\tpr_debug(\"CPU%d: HWP-to-frequency scaling factor: %d\\n\", cpu->cpu, scaling);\n\n\tcpu->pstate.turbo_freq = rounddown(cpu->pstate.turbo_pstate * scaling,\n\t\t\t\t\t   perf_ctl_scaling);\n\tcpu->pstate.max_freq = rounddown(cpu->pstate.max_pstate * scaling,\n\t\t\t\t\t perf_ctl_scaling);\n\n\tcpu->pstate.max_pstate_physical =\n\t\t\tDIV_ROUND_UP(perf_ctl_max_phys * perf_ctl_scaling,\n\t\t\t\t     scaling);\n\n\tcpu->pstate.min_freq = cpu->pstate.min_pstate * perf_ctl_scaling;\n\t \n\tcpu->pstate.min_pstate = DIV_ROUND_UP(cpu->pstate.min_freq, scaling);\n}\n\nstatic inline void update_turbo_state(void)\n{\n\tu64 misc_en;\n\tstruct cpudata *cpu;\n\n\tcpu = all_cpu_data[0];\n\trdmsrl(MSR_IA32_MISC_ENABLE, misc_en);\n\tglobal.turbo_disabled =\n\t\t(misc_en & MSR_IA32_MISC_ENABLE_TURBO_DISABLE ||\n\t\t cpu->pstate.max_pstate == cpu->pstate.turbo_pstate);\n}\n\nstatic int min_perf_pct_min(void)\n{\n\tstruct cpudata *cpu = all_cpu_data[0];\n\tint turbo_pstate = cpu->pstate.turbo_pstate;\n\n\treturn turbo_pstate ?\n\t\t(cpu->pstate.min_pstate * 100 / turbo_pstate) : 0;\n}\n\nstatic s16 intel_pstate_get_epb(struct cpudata *cpu_data)\n{\n\tu64 epb;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_EPB))\n\t\treturn -ENXIO;\n\n\tret = rdmsrl_on_cpu(cpu_data->cpu, MSR_IA32_ENERGY_PERF_BIAS, &epb);\n\tif (ret)\n\t\treturn (s16)ret;\n\n\treturn (s16)(epb & 0x0f);\n}\n\nstatic s16 intel_pstate_get_epp(struct cpudata *cpu_data, u64 hwp_req_data)\n{\n\ts16 epp;\n\n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP)) {\n\t\t \n\t\tif (!hwp_req_data) {\n\t\t\tepp = rdmsrl_on_cpu(cpu_data->cpu, MSR_HWP_REQUEST,\n\t\t\t\t\t    &hwp_req_data);\n\t\t\tif (epp)\n\t\t\t\treturn epp;\n\t\t}\n\t\tepp = (hwp_req_data >> 24) & 0xff;\n\t} else {\n\t\t \n\t\tepp = intel_pstate_get_epb(cpu_data);\n\t}\n\n\treturn epp;\n}\n\nstatic int intel_pstate_set_epb(int cpu, s16 pref)\n{\n\tu64 epb;\n\tint ret;\n\n\tif (!boot_cpu_has(X86_FEATURE_EPB))\n\t\treturn -ENXIO;\n\n\tret = rdmsrl_on_cpu(cpu, MSR_IA32_ENERGY_PERF_BIAS, &epb);\n\tif (ret)\n\t\treturn ret;\n\n\tepb = (epb & ~0x0f) | pref;\n\twrmsrl_on_cpu(cpu, MSR_IA32_ENERGY_PERF_BIAS, epb);\n\n\treturn 0;\n}\n\n \n\nenum energy_perf_value_index {\n\tEPP_INDEX_DEFAULT = 0,\n\tEPP_INDEX_PERFORMANCE,\n\tEPP_INDEX_BALANCE_PERFORMANCE,\n\tEPP_INDEX_BALANCE_POWERSAVE,\n\tEPP_INDEX_POWERSAVE,\n};\n\nstatic const char * const energy_perf_strings[] = {\n\t[EPP_INDEX_DEFAULT] = \"default\",\n\t[EPP_INDEX_PERFORMANCE] = \"performance\",\n\t[EPP_INDEX_BALANCE_PERFORMANCE] = \"balance_performance\",\n\t[EPP_INDEX_BALANCE_POWERSAVE] = \"balance_power\",\n\t[EPP_INDEX_POWERSAVE] = \"power\",\n\tNULL\n};\nstatic unsigned int epp_values[] = {\n\t[EPP_INDEX_DEFAULT] = 0,  \n\t[EPP_INDEX_PERFORMANCE] = HWP_EPP_PERFORMANCE,\n\t[EPP_INDEX_BALANCE_PERFORMANCE] = HWP_EPP_BALANCE_PERFORMANCE,\n\t[EPP_INDEX_BALANCE_POWERSAVE] = HWP_EPP_BALANCE_POWERSAVE,\n\t[EPP_INDEX_POWERSAVE] = HWP_EPP_POWERSAVE,\n};\n\nstatic int intel_pstate_get_energy_pref_index(struct cpudata *cpu_data, int *raw_epp)\n{\n\ts16 epp;\n\tint index = -EINVAL;\n\n\t*raw_epp = 0;\n\tepp = intel_pstate_get_epp(cpu_data, 0);\n\tif (epp < 0)\n\t\treturn epp;\n\n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP)) {\n\t\tif (epp == epp_values[EPP_INDEX_PERFORMANCE])\n\t\t\treturn EPP_INDEX_PERFORMANCE;\n\t\tif (epp == epp_values[EPP_INDEX_BALANCE_PERFORMANCE])\n\t\t\treturn EPP_INDEX_BALANCE_PERFORMANCE;\n\t\tif (epp == epp_values[EPP_INDEX_BALANCE_POWERSAVE])\n\t\t\treturn EPP_INDEX_BALANCE_POWERSAVE;\n\t\tif (epp == epp_values[EPP_INDEX_POWERSAVE])\n\t\t\treturn EPP_INDEX_POWERSAVE;\n\t\t*raw_epp = epp;\n\t\treturn 0;\n\t} else if (boot_cpu_has(X86_FEATURE_EPB)) {\n\t\t \n\t\tindex = (epp >> 2) + 1;\n\t}\n\n\treturn index;\n}\n\nstatic int intel_pstate_set_epp(struct cpudata *cpu, u32 epp)\n{\n\tint ret;\n\n\t \n\tu64 value = READ_ONCE(cpu->hwp_req_cached);\n\n\tvalue &= ~GENMASK_ULL(31, 24);\n\tvalue |= (u64)epp << 24;\n\t \n\tWRITE_ONCE(cpu->hwp_req_cached, value);\n\tret = wrmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, value);\n\tif (!ret)\n\t\tcpu->epp_cached = epp;\n\n\treturn ret;\n}\n\nstatic int intel_pstate_set_energy_pref_index(struct cpudata *cpu_data,\n\t\t\t\t\t      int pref_index, bool use_raw,\n\t\t\t\t\t      u32 raw_epp)\n{\n\tint epp = -EINVAL;\n\tint ret;\n\n\tif (!pref_index)\n\t\tepp = cpu_data->epp_default;\n\n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP)) {\n\t\tif (use_raw)\n\t\t\tepp = raw_epp;\n\t\telse if (epp == -EINVAL)\n\t\t\tepp = epp_values[pref_index];\n\n\t\t \n\t\tif (epp > 0 && cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE)\n\t\t\treturn -EBUSY;\n\n\t\tret = intel_pstate_set_epp(cpu_data, epp);\n\t} else {\n\t\tif (epp == -EINVAL)\n\t\t\tepp = (pref_index - 1) << 2;\n\t\tret = intel_pstate_set_epb(cpu_data->cpu, epp);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t show_energy_performance_available_preferences(\n\t\t\t\tstruct cpufreq_policy *policy, char *buf)\n{\n\tint i = 0;\n\tint ret = 0;\n\n\twhile (energy_perf_strings[i] != NULL)\n\t\tret += sprintf(&buf[ret], \"%s \", energy_perf_strings[i++]);\n\n\tret += sprintf(&buf[ret], \"\\n\");\n\n\treturn ret;\n}\n\ncpufreq_freq_attr_ro(energy_performance_available_preferences);\n\nstatic struct cpufreq_driver intel_pstate;\n\nstatic ssize_t store_energy_performance_preference(\n\t\tstruct cpufreq_policy *policy, const char *buf, size_t count)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\tchar str_preference[21];\n\tbool raw = false;\n\tssize_t ret;\n\tu32 epp = 0;\n\n\tret = sscanf(buf, \"%20s\", str_preference);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tret = match_string(energy_perf_strings, -1, str_preference);\n\tif (ret < 0) {\n\t\tif (!boot_cpu_has(X86_FEATURE_HWP_EPP))\n\t\t\treturn ret;\n\n\t\tret = kstrtouint(buf, 10, &epp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (epp > 255)\n\t\t\treturn -EINVAL;\n\n\t\traw = true;\n\t}\n\n\t \n\tif (!intel_pstate_driver)\n\t\treturn -EAGAIN;\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tif (intel_pstate_driver == &intel_pstate) {\n\t\tret = intel_pstate_set_energy_pref_index(cpu, ret, raw, epp);\n\t} else {\n\t\t \n\t\tif (!raw)\n\t\t\tepp = ret ? epp_values[ret] : cpu->epp_default;\n\n\t\tif (cpu->epp_cached != epp) {\n\t\t\tint err;\n\n\t\t\tcpufreq_stop_governor(policy);\n\t\t\tret = intel_pstate_set_epp(cpu, epp);\n\t\t\terr = cpufreq_start_governor(policy);\n\t\t\tif (!ret)\n\t\t\t\tret = err;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\tmutex_unlock(&intel_pstate_limits_lock);\n\n\treturn ret ?: count;\n}\n\nstatic ssize_t show_energy_performance_preference(\n\t\t\t\tstruct cpufreq_policy *policy, char *buf)\n{\n\tstruct cpudata *cpu_data = all_cpu_data[policy->cpu];\n\tint preference, raw_epp;\n\n\tpreference = intel_pstate_get_energy_pref_index(cpu_data, &raw_epp);\n\tif (preference < 0)\n\t\treturn preference;\n\n\tif (raw_epp)\n\t\treturn  sprintf(buf, \"%d\\n\", raw_epp);\n\telse\n\t\treturn  sprintf(buf, \"%s\\n\", energy_perf_strings[preference]);\n}\n\ncpufreq_freq_attr_rw(energy_performance_preference);\n\nstatic ssize_t show_base_frequency(struct cpufreq_policy *policy, char *buf)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\tint ratio, freq;\n\n\tratio = intel_pstate_get_cppc_guaranteed(policy->cpu);\n\tif (ratio <= 0) {\n\t\tu64 cap;\n\n\t\trdmsrl_on_cpu(policy->cpu, MSR_HWP_CAPABILITIES, &cap);\n\t\tratio = HWP_GUARANTEED_PERF(cap);\n\t}\n\n\tfreq = ratio * cpu->pstate.scaling;\n\tif (cpu->pstate.scaling != cpu->pstate.perf_ctl_scaling)\n\t\tfreq = rounddown(freq, cpu->pstate.perf_ctl_scaling);\n\n\treturn sprintf(buf, \"%d\\n\", freq);\n}\n\ncpufreq_freq_attr_ro(base_frequency);\n\nstatic struct freq_attr *hwp_cpufreq_attrs[] = {\n\t&energy_performance_preference,\n\t&energy_performance_available_preferences,\n\t&base_frequency,\n\tNULL,\n};\n\nstatic void __intel_pstate_get_hwp_cap(struct cpudata *cpu)\n{\n\tu64 cap;\n\n\trdmsrl_on_cpu(cpu->cpu, MSR_HWP_CAPABILITIES, &cap);\n\tWRITE_ONCE(cpu->hwp_cap_cached, cap);\n\tcpu->pstate.max_pstate = HWP_GUARANTEED_PERF(cap);\n\tcpu->pstate.turbo_pstate = HWP_HIGHEST_PERF(cap);\n}\n\nstatic void intel_pstate_get_hwp_cap(struct cpudata *cpu)\n{\n\tint scaling = cpu->pstate.scaling;\n\n\t__intel_pstate_get_hwp_cap(cpu);\n\n\tcpu->pstate.max_freq = cpu->pstate.max_pstate * scaling;\n\tcpu->pstate.turbo_freq = cpu->pstate.turbo_pstate * scaling;\n\tif (scaling != cpu->pstate.perf_ctl_scaling) {\n\t\tint perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;\n\n\t\tcpu->pstate.max_freq = rounddown(cpu->pstate.max_freq,\n\t\t\t\t\t\t perf_ctl_scaling);\n\t\tcpu->pstate.turbo_freq = rounddown(cpu->pstate.turbo_freq,\n\t\t\t\t\t\t   perf_ctl_scaling);\n\t}\n}\n\nstatic void intel_pstate_hwp_set(unsigned int cpu)\n{\n\tstruct cpudata *cpu_data = all_cpu_data[cpu];\n\tint max, min;\n\tu64 value;\n\ts16 epp;\n\n\tmax = cpu_data->max_perf_ratio;\n\tmin = cpu_data->min_perf_ratio;\n\n\tif (cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE)\n\t\tmin = max;\n\n\trdmsrl_on_cpu(cpu, MSR_HWP_REQUEST, &value);\n\n\tvalue &= ~HWP_MIN_PERF(~0L);\n\tvalue |= HWP_MIN_PERF(min);\n\n\tvalue &= ~HWP_MAX_PERF(~0L);\n\tvalue |= HWP_MAX_PERF(max);\n\n\tif (cpu_data->epp_policy == cpu_data->policy)\n\t\tgoto skip_epp;\n\n\tcpu_data->epp_policy = cpu_data->policy;\n\n\tif (cpu_data->policy == CPUFREQ_POLICY_PERFORMANCE) {\n\t\tepp = intel_pstate_get_epp(cpu_data, value);\n\t\tcpu_data->epp_powersave = epp;\n\t\t \n\t\tif (epp < 0)\n\t\t\tgoto skip_epp;\n\n\t\tepp = 0;\n\t} else {\n\t\t \n\t\tif (cpu_data->epp_powersave < 0)\n\t\t\tgoto skip_epp;\n\n\t\t \n\t\tepp = intel_pstate_get_epp(cpu_data, value);\n\t\tif (epp)\n\t\t\tgoto skip_epp;\n\n\t\tepp = cpu_data->epp_powersave;\n\t}\n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP)) {\n\t\tvalue &= ~GENMASK_ULL(31, 24);\n\t\tvalue |= (u64)epp << 24;\n\t} else {\n\t\tintel_pstate_set_epb(cpu, epp);\n\t}\nskip_epp:\n\tWRITE_ONCE(cpu_data->hwp_req_cached, value);\n\twrmsrl_on_cpu(cpu, MSR_HWP_REQUEST, value);\n}\n\nstatic void intel_pstate_disable_hwp_interrupt(struct cpudata *cpudata);\n\nstatic void intel_pstate_hwp_offline(struct cpudata *cpu)\n{\n\tu64 value = READ_ONCE(cpu->hwp_req_cached);\n\tint min_perf;\n\n\tintel_pstate_disable_hwp_interrupt(cpu);\n\n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP)) {\n\t\t \n\t\tvalue &= ~GENMASK_ULL(31, 24);\n\t\tvalue |= HWP_ENERGY_PERF_PREFERENCE(cpu->epp_cached);\n\t\t \n\t\tcpu->epp_policy = CPUFREQ_POLICY_UNKNOWN;\n\t}\n\n\t \n\tvalue &= ~HWP_DESIRED_PERF(~0L);\n\tWRITE_ONCE(cpu->hwp_req_cached, value);\n\n\tvalue &= ~GENMASK_ULL(31, 0);\n\tmin_perf = HWP_LOWEST_PERF(READ_ONCE(cpu->hwp_cap_cached));\n\n\t \n\tvalue |= HWP_MAX_PERF(min_perf);\n\tvalue |= HWP_MIN_PERF(min_perf);\n\n\t \n\tif (boot_cpu_has(X86_FEATURE_HWP_EPP))\n\t\tvalue |= HWP_ENERGY_PERF_PREFERENCE(HWP_EPP_POWERSAVE);\n\n\twrmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, value);\n}\n\n#define POWER_CTL_EE_ENABLE\t1\n#define POWER_CTL_EE_DISABLE\t2\n\nstatic int power_ctl_ee_state;\n\nstatic void set_power_ctl_ee_state(bool input)\n{\n\tu64 power_ctl;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\trdmsrl(MSR_IA32_POWER_CTL, power_ctl);\n\tif (input) {\n\t\tpower_ctl &= ~BIT(MSR_IA32_POWER_CTL_BIT_EE);\n\t\tpower_ctl_ee_state = POWER_CTL_EE_ENABLE;\n\t} else {\n\t\tpower_ctl |= BIT(MSR_IA32_POWER_CTL_BIT_EE);\n\t\tpower_ctl_ee_state = POWER_CTL_EE_DISABLE;\n\t}\n\twrmsrl(MSR_IA32_POWER_CTL, power_ctl);\n\tmutex_unlock(&intel_pstate_driver_lock);\n}\n\nstatic void intel_pstate_hwp_enable(struct cpudata *cpudata);\n\nstatic void intel_pstate_hwp_reenable(struct cpudata *cpu)\n{\n\tintel_pstate_hwp_enable(cpu);\n\twrmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, READ_ONCE(cpu->hwp_req_cached));\n}\n\nstatic int intel_pstate_suspend(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\tpr_debug(\"CPU %d suspending\\n\", cpu->cpu);\n\n\tcpu->suspended = true;\n\n\t \n\tintel_pstate_disable_hwp_interrupt(cpu);\n\n\treturn 0;\n}\n\nstatic int intel_pstate_resume(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\tpr_debug(\"CPU %d resuming\\n\", cpu->cpu);\n\n\t \n\tif (power_ctl_ee_state == POWER_CTL_EE_ENABLE)\n\t\tset_power_ctl_ee_state(true);\n\telse if (power_ctl_ee_state == POWER_CTL_EE_DISABLE)\n\t\tset_power_ctl_ee_state(false);\n\n\tif (cpu->suspended && hwp_active) {\n\t\tmutex_lock(&intel_pstate_limits_lock);\n\n\t\t \n\t\tintel_pstate_hwp_reenable(cpu);\n\n\t\tmutex_unlock(&intel_pstate_limits_lock);\n\t}\n\n\tcpu->suspended = false;\n\n\treturn 0;\n}\n\nstatic void intel_pstate_update_policies(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcpufreq_update_policy(cpu);\n}\n\nstatic void __intel_pstate_update_max_freq(struct cpudata *cpudata,\n\t\t\t\t\t   struct cpufreq_policy *policy)\n{\n\tpolicy->cpuinfo.max_freq = global.turbo_disabled_mf ?\n\t\t\tcpudata->pstate.max_freq : cpudata->pstate.turbo_freq;\n\trefresh_frequency_limits(policy);\n}\n\nstatic void intel_pstate_update_max_freq(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_acquire(cpu);\n\n\tif (!policy)\n\t\treturn;\n\n\t__intel_pstate_update_max_freq(all_cpu_data[cpu], policy);\n\n\tcpufreq_cpu_release(policy);\n}\n\nstatic void intel_pstate_update_limits(unsigned int cpu)\n{\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tupdate_turbo_state();\n\t \n\tif (global.turbo_disabled_mf != global.turbo_disabled) {\n\t\tglobal.turbo_disabled_mf = global.turbo_disabled;\n\t\tarch_set_max_freq_ratio(global.turbo_disabled);\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tintel_pstate_update_max_freq(cpu);\n\t} else {\n\t\tcpufreq_update_policy(cpu);\n\t}\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n}\n\n \n#define show_one(file_name, object)\t\t\t\t\t\\\n\tstatic ssize_t show_##file_name\t\t\t\t\t\\\n\t(struct kobject *kobj, struct kobj_attribute *attr, char *buf)\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\treturn sprintf(buf, \"%u\\n\", global.object);\t\t\\\n\t}\n\nstatic ssize_t intel_pstate_show_status(char *buf);\nstatic int intel_pstate_update_status(const char *buf, size_t size);\n\nstatic ssize_t show_status(struct kobject *kobj,\n\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\tssize_t ret;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\tret = intel_pstate_show_status(buf);\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t store_status(struct kobject *a, struct kobj_attribute *b,\n\t\t\t    const char *buf, size_t count)\n{\n\tchar *p = memchr(buf, '\\n', count);\n\tint ret;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\tret = intel_pstate_update_status(buf, p ? p - buf : count);\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn ret < 0 ? ret : count;\n}\n\nstatic ssize_t show_turbo_pct(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct cpudata *cpu;\n\tint total, no_turbo, turbo_pct;\n\tuint32_t turbo_fp;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tcpu = all_cpu_data[0];\n\n\ttotal = cpu->pstate.turbo_pstate - cpu->pstate.min_pstate + 1;\n\tno_turbo = cpu->pstate.max_pstate - cpu->pstate.min_pstate + 1;\n\tturbo_fp = div_fp(no_turbo, total);\n\tturbo_pct = 100 - fp_toint(mul_fp(turbo_fp, int_tofp(100)));\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn sprintf(buf, \"%u\\n\", turbo_pct);\n}\n\nstatic ssize_t show_num_pstates(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\tstruct cpudata *cpu;\n\tint total;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tcpu = all_cpu_data[0];\n\ttotal = cpu->pstate.turbo_pstate - cpu->pstate.min_pstate + 1;\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn sprintf(buf, \"%u\\n\", total);\n}\n\nstatic ssize_t show_no_turbo(struct kobject *kobj,\n\t\t\t     struct kobj_attribute *attr, char *buf)\n{\n\tssize_t ret;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tupdate_turbo_state();\n\tif (global.turbo_disabled)\n\t\tret = sprintf(buf, \"%u\\n\", global.turbo_disabled);\n\telse\n\t\tret = sprintf(buf, \"%u\\n\", global.no_turbo);\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t store_no_turbo(struct kobject *a, struct kobj_attribute *b,\n\t\t\t      const char *buf, size_t count)\n{\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tupdate_turbo_state();\n\tif (global.turbo_disabled) {\n\t\tpr_notice_once(\"Turbo disabled by BIOS or unavailable on processor\\n\");\n\t\tmutex_unlock(&intel_pstate_limits_lock);\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EPERM;\n\t}\n\n\tglobal.no_turbo = clamp_t(int, input, 0, 1);\n\n\tif (global.no_turbo) {\n\t\tstruct cpudata *cpu = all_cpu_data[0];\n\t\tint pct = cpu->pstate.max_pstate * 100 / cpu->pstate.turbo_pstate;\n\n\t\t \n\t\tif (global.min_perf_pct > pct)\n\t\t\tglobal.min_perf_pct = pct;\n\t}\n\n\tmutex_unlock(&intel_pstate_limits_lock);\n\n\tintel_pstate_update_policies();\n\tarch_set_max_freq_ratio(global.no_turbo);\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn count;\n}\n\nstatic void update_qos_request(enum freq_qos_req_type type)\n{\n\tstruct freq_qos_request *req;\n\tstruct cpufreq_policy *policy;\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct cpudata *cpu = all_cpu_data[i];\n\t\tunsigned int freq, perf_pct;\n\n\t\tpolicy = cpufreq_cpu_get(i);\n\t\tif (!policy)\n\t\t\tcontinue;\n\n\t\treq = policy->driver_data;\n\t\tcpufreq_cpu_put(policy);\n\n\t\tif (!req)\n\t\t\tcontinue;\n\n\t\tif (hwp_active)\n\t\t\tintel_pstate_get_hwp_cap(cpu);\n\n\t\tif (type == FREQ_QOS_MIN) {\n\t\t\tperf_pct = global.min_perf_pct;\n\t\t} else {\n\t\t\treq++;\n\t\t\tperf_pct = global.max_perf_pct;\n\t\t}\n\n\t\tfreq = DIV_ROUND_UP(cpu->pstate.turbo_freq * perf_pct, 100);\n\n\t\tif (freq_qos_update_request(req, freq) < 0)\n\t\t\tpr_warn(\"Failed to update freq constraint: CPU%d\\n\", i);\n\t}\n}\n\nstatic ssize_t store_max_perf_pct(struct kobject *a, struct kobj_attribute *b,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tglobal.max_perf_pct = clamp_t(int, input, global.min_perf_pct, 100);\n\n\tmutex_unlock(&intel_pstate_limits_lock);\n\n\tif (intel_pstate_driver == &intel_pstate)\n\t\tintel_pstate_update_policies();\n\telse\n\t\tupdate_qos_request(FREQ_QOS_MAX);\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn count;\n}\n\nstatic ssize_t store_min_perf_pct(struct kobject *a, struct kobj_attribute *b,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\n\tif (!intel_pstate_driver) {\n\t\tmutex_unlock(&intel_pstate_driver_lock);\n\t\treturn -EAGAIN;\n\t}\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tglobal.min_perf_pct = clamp_t(int, input,\n\t\t\t\t      min_perf_pct_min(), global.max_perf_pct);\n\n\tmutex_unlock(&intel_pstate_limits_lock);\n\n\tif (intel_pstate_driver == &intel_pstate)\n\t\tintel_pstate_update_policies();\n\telse\n\t\tupdate_qos_request(FREQ_QOS_MIN);\n\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_hwp_dynamic_boost(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", hwp_boost);\n}\n\nstatic ssize_t store_hwp_dynamic_boost(struct kobject *a,\n\t\t\t\t       struct kobj_attribute *b,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tunsigned int input;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &input);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\thwp_boost = !!input;\n\tintel_pstate_update_policies();\n\tmutex_unlock(&intel_pstate_driver_lock);\n\n\treturn count;\n}\n\nstatic ssize_t show_energy_efficiency(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tu64 power_ctl;\n\tint enable;\n\n\trdmsrl(MSR_IA32_POWER_CTL, power_ctl);\n\tenable = !!(power_ctl & BIT(MSR_IA32_POWER_CTL_BIT_EE));\n\treturn sprintf(buf, \"%d\\n\", !enable);\n}\n\nstatic ssize_t store_energy_efficiency(struct kobject *a, struct kobj_attribute *b,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tbool input;\n\tint ret;\n\n\tret = kstrtobool(buf, &input);\n\tif (ret)\n\t\treturn ret;\n\n\tset_power_ctl_ee_state(input);\n\n\treturn count;\n}\n\nshow_one(max_perf_pct, max_perf_pct);\nshow_one(min_perf_pct, min_perf_pct);\n\ndefine_one_global_rw(status);\ndefine_one_global_rw(no_turbo);\ndefine_one_global_rw(max_perf_pct);\ndefine_one_global_rw(min_perf_pct);\ndefine_one_global_ro(turbo_pct);\ndefine_one_global_ro(num_pstates);\ndefine_one_global_rw(hwp_dynamic_boost);\ndefine_one_global_rw(energy_efficiency);\n\nstatic struct attribute *intel_pstate_attributes[] = {\n\t&status.attr,\n\t&no_turbo.attr,\n\tNULL\n};\n\nstatic const struct attribute_group intel_pstate_attr_group = {\n\t.attrs = intel_pstate_attributes,\n};\n\nstatic const struct x86_cpu_id intel_pstate_cpu_ee_disable_ids[];\n\nstatic struct kobject *intel_pstate_kobject;\n\nstatic void __init intel_pstate_sysfs_expose_params(void)\n{\n\tstruct device *dev_root = bus_get_dev_root(&cpu_subsys);\n\tint rc;\n\n\tif (dev_root) {\n\t\tintel_pstate_kobject = kobject_create_and_add(\"intel_pstate\", &dev_root->kobj);\n\t\tput_device(dev_root);\n\t}\n\tif (WARN_ON(!intel_pstate_kobject))\n\t\treturn;\n\n\trc = sysfs_create_group(intel_pstate_kobject, &intel_pstate_attr_group);\n\tif (WARN_ON(rc))\n\t\treturn;\n\n\tif (!boot_cpu_has(X86_FEATURE_HYBRID_CPU)) {\n\t\trc = sysfs_create_file(intel_pstate_kobject, &turbo_pct.attr);\n\t\tWARN_ON(rc);\n\n\t\trc = sysfs_create_file(intel_pstate_kobject, &num_pstates.attr);\n\t\tWARN_ON(rc);\n\t}\n\n\t \n\tif (per_cpu_limits)\n\t\treturn;\n\n\trc = sysfs_create_file(intel_pstate_kobject, &max_perf_pct.attr);\n\tWARN_ON(rc);\n\n\trc = sysfs_create_file(intel_pstate_kobject, &min_perf_pct.attr);\n\tWARN_ON(rc);\n\n\tif (x86_match_cpu(intel_pstate_cpu_ee_disable_ids)) {\n\t\trc = sysfs_create_file(intel_pstate_kobject, &energy_efficiency.attr);\n\t\tWARN_ON(rc);\n\t}\n}\n\nstatic void __init intel_pstate_sysfs_remove(void)\n{\n\tif (!intel_pstate_kobject)\n\t\treturn;\n\n\tsysfs_remove_group(intel_pstate_kobject, &intel_pstate_attr_group);\n\n\tif (!boot_cpu_has(X86_FEATURE_HYBRID_CPU)) {\n\t\tsysfs_remove_file(intel_pstate_kobject, &num_pstates.attr);\n\t\tsysfs_remove_file(intel_pstate_kobject, &turbo_pct.attr);\n\t}\n\n\tif (!per_cpu_limits) {\n\t\tsysfs_remove_file(intel_pstate_kobject, &max_perf_pct.attr);\n\t\tsysfs_remove_file(intel_pstate_kobject, &min_perf_pct.attr);\n\n\t\tif (x86_match_cpu(intel_pstate_cpu_ee_disable_ids))\n\t\t\tsysfs_remove_file(intel_pstate_kobject, &energy_efficiency.attr);\n\t}\n\n\tkobject_put(intel_pstate_kobject);\n}\n\nstatic void intel_pstate_sysfs_expose_hwp_dynamic_boost(void)\n{\n\tint rc;\n\n\tif (!hwp_active)\n\t\treturn;\n\n\trc = sysfs_create_file(intel_pstate_kobject, &hwp_dynamic_boost.attr);\n\tWARN_ON_ONCE(rc);\n}\n\nstatic void intel_pstate_sysfs_hide_hwp_dynamic_boost(void)\n{\n\tif (!hwp_active)\n\t\treturn;\n\n\tsysfs_remove_file(intel_pstate_kobject, &hwp_dynamic_boost.attr);\n}\n\n \n\nstatic void intel_pstate_notify_work(struct work_struct *work)\n{\n\tstruct cpudata *cpudata =\n\t\tcontainer_of(to_delayed_work(work), struct cpudata, hwp_notify_work);\n\tstruct cpufreq_policy *policy = cpufreq_cpu_acquire(cpudata->cpu);\n\n\tif (policy) {\n\t\tintel_pstate_get_hwp_cap(cpudata);\n\t\t__intel_pstate_update_max_freq(cpudata, policy);\n\n\t\tcpufreq_cpu_release(policy);\n\t}\n\n\twrmsrl_on_cpu(cpudata->cpu, MSR_HWP_STATUS, 0);\n}\n\nstatic DEFINE_SPINLOCK(hwp_notify_lock);\nstatic cpumask_t hwp_intr_enable_mask;\n\nvoid notify_hwp_interrupt(void)\n{\n\tunsigned int this_cpu = smp_processor_id();\n\tstruct cpudata *cpudata;\n\tunsigned long flags;\n\tu64 value;\n\n\tif (!READ_ONCE(hwp_active) || !boot_cpu_has(X86_FEATURE_HWP_NOTIFY))\n\t\treturn;\n\n\trdmsrl_safe(MSR_HWP_STATUS, &value);\n\tif (!(value & 0x01))\n\t\treturn;\n\n\tspin_lock_irqsave(&hwp_notify_lock, flags);\n\n\tif (!cpumask_test_cpu(this_cpu, &hwp_intr_enable_mask))\n\t\tgoto ack_intr;\n\n\t \n\tif (unlikely(!READ_ONCE(all_cpu_data)))\n\t\tgoto ack_intr;\n\n\t \n\tcpudata = READ_ONCE(all_cpu_data[this_cpu]);\n\tif (unlikely(!cpudata))\n\t\tgoto ack_intr;\n\n\tschedule_delayed_work(&cpudata->hwp_notify_work, msecs_to_jiffies(10));\n\n\tspin_unlock_irqrestore(&hwp_notify_lock, flags);\n\n\treturn;\n\nack_intr:\n\twrmsrl_safe(MSR_HWP_STATUS, 0);\n\tspin_unlock_irqrestore(&hwp_notify_lock, flags);\n}\n\nstatic void intel_pstate_disable_hwp_interrupt(struct cpudata *cpudata)\n{\n\tunsigned long flags;\n\n\tif (!boot_cpu_has(X86_FEATURE_HWP_NOTIFY))\n\t\treturn;\n\n\t \n\twrmsrl_on_cpu(cpudata->cpu, MSR_HWP_INTERRUPT, 0x00);\n\n\tspin_lock_irqsave(&hwp_notify_lock, flags);\n\tif (cpumask_test_and_clear_cpu(cpudata->cpu, &hwp_intr_enable_mask))\n\t\tcancel_delayed_work(&cpudata->hwp_notify_work);\n\tspin_unlock_irqrestore(&hwp_notify_lock, flags);\n}\n\nstatic void intel_pstate_enable_hwp_interrupt(struct cpudata *cpudata)\n{\n\t \n\tif (boot_cpu_has(X86_FEATURE_HWP_NOTIFY)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&hwp_notify_lock, flags);\n\t\tINIT_DELAYED_WORK(&cpudata->hwp_notify_work, intel_pstate_notify_work);\n\t\tcpumask_set_cpu(cpudata->cpu, &hwp_intr_enable_mask);\n\t\tspin_unlock_irqrestore(&hwp_notify_lock, flags);\n\n\t\t \n\t\twrmsrl_on_cpu(cpudata->cpu, MSR_HWP_INTERRUPT, 0x01);\n\t\twrmsrl_on_cpu(cpudata->cpu, MSR_HWP_STATUS, 0);\n\t}\n}\n\nstatic void intel_pstate_update_epp_defaults(struct cpudata *cpudata)\n{\n\tcpudata->epp_default = intel_pstate_get_epp(cpudata, 0);\n\n\t \n\tif (epp_values[EPP_INDEX_BALANCE_PERFORMANCE] == HWP_EPP_BALANCE_PERFORMANCE)\n\t\treturn;\n\n\t \n\tif (hwp_forced && cpudata->epp_default <= HWP_EPP_BALANCE_PERFORMANCE &&\n\t    cpudata->epp_default > HWP_EPP_PERFORMANCE) {\n\t\tepp_values[EPP_INDEX_BALANCE_PERFORMANCE] = cpudata->epp_default;\n\t\treturn;\n\t}\n\n\t \n\tcpudata->epp_default = epp_values[EPP_INDEX_BALANCE_PERFORMANCE];\n\tintel_pstate_set_epp(cpudata, cpudata->epp_default);\n}\n\nstatic void intel_pstate_hwp_enable(struct cpudata *cpudata)\n{\n\t \n\tif (boot_cpu_has(X86_FEATURE_HWP_NOTIFY))\n\t\twrmsrl_on_cpu(cpudata->cpu, MSR_HWP_INTERRUPT, 0x00);\n\n\twrmsrl_on_cpu(cpudata->cpu, MSR_PM_ENABLE, 0x1);\n\n\tintel_pstate_enable_hwp_interrupt(cpudata);\n\n\tif (cpudata->epp_default >= 0)\n\t\treturn;\n\n\tintel_pstate_update_epp_defaults(cpudata);\n}\n\nstatic int atom_get_min_pstate(int not_used)\n{\n\tu64 value;\n\n\trdmsrl(MSR_ATOM_CORE_RATIOS, value);\n\treturn (value >> 8) & 0x7F;\n}\n\nstatic int atom_get_max_pstate(int not_used)\n{\n\tu64 value;\n\n\trdmsrl(MSR_ATOM_CORE_RATIOS, value);\n\treturn (value >> 16) & 0x7F;\n}\n\nstatic int atom_get_turbo_pstate(int not_used)\n{\n\tu64 value;\n\n\trdmsrl(MSR_ATOM_CORE_TURBO_RATIOS, value);\n\treturn value & 0x7F;\n}\n\nstatic u64 atom_get_val(struct cpudata *cpudata, int pstate)\n{\n\tu64 val;\n\tint32_t vid_fp;\n\tu32 vid;\n\n\tval = (u64)pstate << 8;\n\tif (global.no_turbo && !global.turbo_disabled)\n\t\tval |= (u64)1 << 32;\n\n\tvid_fp = cpudata->vid.min + mul_fp(\n\t\tint_tofp(pstate - cpudata->pstate.min_pstate),\n\t\tcpudata->vid.ratio);\n\n\tvid_fp = clamp_t(int32_t, vid_fp, cpudata->vid.min, cpudata->vid.max);\n\tvid = ceiling_fp(vid_fp);\n\n\tif (pstate > cpudata->pstate.max_pstate)\n\t\tvid = cpudata->vid.turbo;\n\n\treturn val | vid;\n}\n\nstatic int silvermont_get_scaling(void)\n{\n\tu64 value;\n\tint i;\n\t \n\tstatic int silvermont_freq_table[] = {\n\t\t83300, 100000, 133300, 116700, 80000};\n\n\trdmsrl(MSR_FSB_FREQ, value);\n\ti = value & 0x7;\n\tWARN_ON(i > 4);\n\n\treturn silvermont_freq_table[i];\n}\n\nstatic int airmont_get_scaling(void)\n{\n\tu64 value;\n\tint i;\n\t \n\tstatic int airmont_freq_table[] = {\n\t\t83300, 100000, 133300, 116700, 80000,\n\t\t93300, 90000, 88900, 87500};\n\n\trdmsrl(MSR_FSB_FREQ, value);\n\ti = value & 0xF;\n\tWARN_ON(i > 8);\n\n\treturn airmont_freq_table[i];\n}\n\nstatic void atom_get_vid(struct cpudata *cpudata)\n{\n\tu64 value;\n\n\trdmsrl(MSR_ATOM_CORE_VIDS, value);\n\tcpudata->vid.min = int_tofp((value >> 8) & 0x7f);\n\tcpudata->vid.max = int_tofp((value >> 16) & 0x7f);\n\tcpudata->vid.ratio = div_fp(\n\t\tcpudata->vid.max - cpudata->vid.min,\n\t\tint_tofp(cpudata->pstate.max_pstate -\n\t\t\tcpudata->pstate.min_pstate));\n\n\trdmsrl(MSR_ATOM_CORE_TURBO_VIDS, value);\n\tcpudata->vid.turbo = value & 0x7f;\n}\n\nstatic int core_get_min_pstate(int cpu)\n{\n\tu64 value;\n\n\trdmsrl_on_cpu(cpu, MSR_PLATFORM_INFO, &value);\n\treturn (value >> 40) & 0xFF;\n}\n\nstatic int core_get_max_pstate_physical(int cpu)\n{\n\tu64 value;\n\n\trdmsrl_on_cpu(cpu, MSR_PLATFORM_INFO, &value);\n\treturn (value >> 8) & 0xFF;\n}\n\nstatic int core_get_tdp_ratio(int cpu, u64 plat_info)\n{\n\t \n\tif (plat_info & 0x600000000) {\n\t\tu64 tdp_ctrl;\n\t\tu64 tdp_ratio;\n\t\tint tdp_msr;\n\t\tint err;\n\n\t\t \n\t\terr = rdmsrl_safe_on_cpu(cpu, MSR_CONFIG_TDP_CONTROL, &tdp_ctrl);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\ttdp_msr = MSR_CONFIG_TDP_NOMINAL + (tdp_ctrl & 0x03);\n\t\terr = rdmsrl_safe_on_cpu(cpu, tdp_msr, &tdp_ratio);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (tdp_ctrl & 0x03)\n\t\t\ttdp_ratio >>= 16;\n\n\t\ttdp_ratio &= 0xff;  \n\t\tpr_debug(\"tdp_ratio %x\\n\", (int)tdp_ratio);\n\n\t\treturn (int)tdp_ratio;\n\t}\n\n\treturn -ENXIO;\n}\n\nstatic int core_get_max_pstate(int cpu)\n{\n\tu64 tar;\n\tu64 plat_info;\n\tint max_pstate;\n\tint tdp_ratio;\n\tint err;\n\n\trdmsrl_on_cpu(cpu, MSR_PLATFORM_INFO, &plat_info);\n\tmax_pstate = (plat_info >> 8) & 0xFF;\n\n\ttdp_ratio = core_get_tdp_ratio(cpu, plat_info);\n\tif (tdp_ratio <= 0)\n\t\treturn max_pstate;\n\n\tif (hwp_active) {\n\t\t \n\t\treturn tdp_ratio;\n\t}\n\n\terr = rdmsrl_safe_on_cpu(cpu, MSR_TURBO_ACTIVATION_RATIO, &tar);\n\tif (!err) {\n\t\tint tar_levels;\n\n\t\t \n\t\ttar_levels = tar & 0xff;\n\t\tif (tdp_ratio - 1 == tar_levels) {\n\t\t\tmax_pstate = tar_levels;\n\t\t\tpr_debug(\"max_pstate=TAC %x\\n\", max_pstate);\n\t\t}\n\t}\n\n\treturn max_pstate;\n}\n\nstatic int core_get_turbo_pstate(int cpu)\n{\n\tu64 value;\n\tint nont, ret;\n\n\trdmsrl_on_cpu(cpu, MSR_TURBO_RATIO_LIMIT, &value);\n\tnont = core_get_max_pstate(cpu);\n\tret = (value) & 255;\n\tif (ret <= nont)\n\t\tret = nont;\n\treturn ret;\n}\n\nstatic u64 core_get_val(struct cpudata *cpudata, int pstate)\n{\n\tu64 val;\n\n\tval = (u64)pstate << 8;\n\tif (global.no_turbo && !global.turbo_disabled)\n\t\tval |= (u64)1 << 32;\n\n\treturn val;\n}\n\nstatic int knl_get_aperf_mperf_shift(void)\n{\n\treturn 10;\n}\n\nstatic int knl_get_turbo_pstate(int cpu)\n{\n\tu64 value;\n\tint nont, ret;\n\n\trdmsrl_on_cpu(cpu, MSR_TURBO_RATIO_LIMIT, &value);\n\tnont = core_get_max_pstate(cpu);\n\tret = (((value) >> 8) & 0xFF);\n\tif (ret <= nont)\n\t\tret = nont;\n\treturn ret;\n}\n\nstatic void hybrid_get_type(void *data)\n{\n\tu8 *cpu_type = data;\n\n\t*cpu_type = get_this_hybrid_cpu_type();\n}\n\nstatic int hwp_get_cpu_scaling(int cpu)\n{\n\tu8 cpu_type = 0;\n\n\tsmp_call_function_single(cpu, hybrid_get_type, &cpu_type, 1);\n\t \n\tif (cpu_type == 0x40)\n\t\treturn HYBRID_SCALING_FACTOR;\n\n\t \n\tif (cpu_type == 0x20)\n\t\treturn core_get_scaling();\n\n\t \n\treturn intel_pstate_cppc_get_scaling(cpu);\n}\n\nstatic void intel_pstate_set_pstate(struct cpudata *cpu, int pstate)\n{\n\ttrace_cpu_frequency(pstate * cpu->pstate.scaling, cpu->cpu);\n\tcpu->pstate.current_pstate = pstate;\n\t \n\twrmsrl_on_cpu(cpu->cpu, MSR_IA32_PERF_CTL,\n\t\t      pstate_funcs.get_val(cpu, pstate));\n}\n\nstatic void intel_pstate_set_min_pstate(struct cpudata *cpu)\n{\n\tintel_pstate_set_pstate(cpu, cpu->pstate.min_pstate);\n}\n\nstatic void intel_pstate_max_within_limits(struct cpudata *cpu)\n{\n\tint pstate = max(cpu->pstate.min_pstate, cpu->max_perf_ratio);\n\n\tupdate_turbo_state();\n\tintel_pstate_set_pstate(cpu, pstate);\n}\n\nstatic void intel_pstate_get_cpu_pstates(struct cpudata *cpu)\n{\n\tint perf_ctl_max_phys = pstate_funcs.get_max_physical(cpu->cpu);\n\tint perf_ctl_scaling = pstate_funcs.get_scaling();\n\n\tcpu->pstate.min_pstate = pstate_funcs.get_min(cpu->cpu);\n\tcpu->pstate.max_pstate_physical = perf_ctl_max_phys;\n\tcpu->pstate.perf_ctl_scaling = perf_ctl_scaling;\n\n\tif (hwp_active && !hwp_mode_bdw) {\n\t\t__intel_pstate_get_hwp_cap(cpu);\n\n\t\tif (pstate_funcs.get_cpu_scaling) {\n\t\t\tcpu->pstate.scaling = pstate_funcs.get_cpu_scaling(cpu->cpu);\n\t\t\tif (cpu->pstate.scaling != perf_ctl_scaling)\n\t\t\t\tintel_pstate_hybrid_hwp_adjust(cpu);\n\t\t} else {\n\t\t\tcpu->pstate.scaling = perf_ctl_scaling;\n\t\t}\n\t} else {\n\t\tcpu->pstate.scaling = perf_ctl_scaling;\n\t\tcpu->pstate.max_pstate = pstate_funcs.get_max(cpu->cpu);\n\t\tcpu->pstate.turbo_pstate = pstate_funcs.get_turbo(cpu->cpu);\n\t}\n\n\tif (cpu->pstate.scaling == perf_ctl_scaling) {\n\t\tcpu->pstate.min_freq = cpu->pstate.min_pstate * perf_ctl_scaling;\n\t\tcpu->pstate.max_freq = cpu->pstate.max_pstate * perf_ctl_scaling;\n\t\tcpu->pstate.turbo_freq = cpu->pstate.turbo_pstate * perf_ctl_scaling;\n\t}\n\n\tif (pstate_funcs.get_aperf_mperf_shift)\n\t\tcpu->aperf_mperf_shift = pstate_funcs.get_aperf_mperf_shift();\n\n\tif (pstate_funcs.get_vid)\n\t\tpstate_funcs.get_vid(cpu);\n\n\tintel_pstate_set_min_pstate(cpu);\n}\n\n \nstatic int hwp_boost_hold_time_ns = 3 * NSEC_PER_MSEC;\n\nstatic inline void intel_pstate_hwp_boost_up(struct cpudata *cpu)\n{\n\tu64 hwp_req = READ_ONCE(cpu->hwp_req_cached);\n\tu64 hwp_cap = READ_ONCE(cpu->hwp_cap_cached);\n\tu32 max_limit = (hwp_req & 0xff00) >> 8;\n\tu32 min_limit = (hwp_req & 0xff);\n\tu32 boost_level1;\n\n\t \n\n\t \n\tif (max_limit == min_limit || cpu->hwp_boost_min >= max_limit)\n\t\treturn;\n\n\tif (!cpu->hwp_boost_min)\n\t\tcpu->hwp_boost_min = min_limit;\n\n\t \n\tboost_level1 = (HWP_GUARANTEED_PERF(hwp_cap) + min_limit) >> 1;\n\n\tif (cpu->hwp_boost_min < boost_level1)\n\t\tcpu->hwp_boost_min = boost_level1;\n\telse if (cpu->hwp_boost_min < HWP_GUARANTEED_PERF(hwp_cap))\n\t\tcpu->hwp_boost_min = HWP_GUARANTEED_PERF(hwp_cap);\n\telse if (cpu->hwp_boost_min == HWP_GUARANTEED_PERF(hwp_cap) &&\n\t\t max_limit != HWP_GUARANTEED_PERF(hwp_cap))\n\t\tcpu->hwp_boost_min = max_limit;\n\telse\n\t\treturn;\n\n\thwp_req = (hwp_req & ~GENMASK_ULL(7, 0)) | cpu->hwp_boost_min;\n\twrmsrl(MSR_HWP_REQUEST, hwp_req);\n\tcpu->last_update = cpu->sample.time;\n}\n\nstatic inline void intel_pstate_hwp_boost_down(struct cpudata *cpu)\n{\n\tif (cpu->hwp_boost_min) {\n\t\tbool expired;\n\n\t\t \n\t\texpired = time_after64(cpu->sample.time, cpu->last_update +\n\t\t\t\t       hwp_boost_hold_time_ns);\n\t\tif (expired) {\n\t\t\twrmsrl(MSR_HWP_REQUEST, cpu->hwp_req_cached);\n\t\t\tcpu->hwp_boost_min = 0;\n\t\t}\n\t}\n\tcpu->last_update = cpu->sample.time;\n}\n\nstatic inline void intel_pstate_update_util_hwp_local(struct cpudata *cpu,\n\t\t\t\t\t\t      u64 time)\n{\n\tcpu->sample.time = time;\n\n\tif (cpu->sched_flags & SCHED_CPUFREQ_IOWAIT) {\n\t\tbool do_io = false;\n\n\t\tcpu->sched_flags = 0;\n\t\t \n\t\tif (time_before64(time, cpu->last_io_update + 2 * TICK_NSEC))\n\t\t\tdo_io = true;\n\n\t\tcpu->last_io_update = time;\n\n\t\tif (do_io)\n\t\t\tintel_pstate_hwp_boost_up(cpu);\n\n\t} else {\n\t\tintel_pstate_hwp_boost_down(cpu);\n\t}\n}\n\nstatic inline void intel_pstate_update_util_hwp(struct update_util_data *data,\n\t\t\t\t\t\tu64 time, unsigned int flags)\n{\n\tstruct cpudata *cpu = container_of(data, struct cpudata, update_util);\n\n\tcpu->sched_flags |= flags;\n\n\tif (smp_processor_id() == cpu->cpu)\n\t\tintel_pstate_update_util_hwp_local(cpu, time);\n}\n\nstatic inline void intel_pstate_calc_avg_perf(struct cpudata *cpu)\n{\n\tstruct sample *sample = &cpu->sample;\n\n\tsample->core_avg_perf = div_ext_fp(sample->aperf, sample->mperf);\n}\n\nstatic inline bool intel_pstate_sample(struct cpudata *cpu, u64 time)\n{\n\tu64 aperf, mperf;\n\tunsigned long flags;\n\tu64 tsc;\n\n\tlocal_irq_save(flags);\n\trdmsrl(MSR_IA32_APERF, aperf);\n\trdmsrl(MSR_IA32_MPERF, mperf);\n\ttsc = rdtsc();\n\tif (cpu->prev_mperf == mperf || cpu->prev_tsc == tsc) {\n\t\tlocal_irq_restore(flags);\n\t\treturn false;\n\t}\n\tlocal_irq_restore(flags);\n\n\tcpu->last_sample_time = cpu->sample.time;\n\tcpu->sample.time = time;\n\tcpu->sample.aperf = aperf;\n\tcpu->sample.mperf = mperf;\n\tcpu->sample.tsc =  tsc;\n\tcpu->sample.aperf -= cpu->prev_aperf;\n\tcpu->sample.mperf -= cpu->prev_mperf;\n\tcpu->sample.tsc -= cpu->prev_tsc;\n\n\tcpu->prev_aperf = aperf;\n\tcpu->prev_mperf = mperf;\n\tcpu->prev_tsc = tsc;\n\t \n\tif (cpu->last_sample_time) {\n\t\tintel_pstate_calc_avg_perf(cpu);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic inline int32_t get_avg_frequency(struct cpudata *cpu)\n{\n\treturn mul_ext_fp(cpu->sample.core_avg_perf, cpu_khz);\n}\n\nstatic inline int32_t get_avg_pstate(struct cpudata *cpu)\n{\n\treturn mul_ext_fp(cpu->pstate.max_pstate_physical,\n\t\t\t  cpu->sample.core_avg_perf);\n}\n\nstatic inline int32_t get_target_pstate(struct cpudata *cpu)\n{\n\tstruct sample *sample = &cpu->sample;\n\tint32_t busy_frac;\n\tint target, avg_pstate;\n\n\tbusy_frac = div_fp(sample->mperf << cpu->aperf_mperf_shift,\n\t\t\t   sample->tsc);\n\n\tif (busy_frac < cpu->iowait_boost)\n\t\tbusy_frac = cpu->iowait_boost;\n\n\tsample->busy_scaled = busy_frac * 100;\n\n\ttarget = global.no_turbo || global.turbo_disabled ?\n\t\t\tcpu->pstate.max_pstate : cpu->pstate.turbo_pstate;\n\ttarget += target >> 2;\n\ttarget = mul_fp(target, busy_frac);\n\tif (target < cpu->pstate.min_pstate)\n\t\ttarget = cpu->pstate.min_pstate;\n\n\t \n\tavg_pstate = get_avg_pstate(cpu);\n\tif (avg_pstate > target)\n\t\ttarget += (avg_pstate - target) >> 1;\n\n\treturn target;\n}\n\nstatic int intel_pstate_prepare_request(struct cpudata *cpu, int pstate)\n{\n\tint min_pstate = max(cpu->pstate.min_pstate, cpu->min_perf_ratio);\n\tint max_pstate = max(min_pstate, cpu->max_perf_ratio);\n\n\treturn clamp_t(int, pstate, min_pstate, max_pstate);\n}\n\nstatic void intel_pstate_update_pstate(struct cpudata *cpu, int pstate)\n{\n\tif (pstate == cpu->pstate.current_pstate)\n\t\treturn;\n\n\tcpu->pstate.current_pstate = pstate;\n\twrmsrl(MSR_IA32_PERF_CTL, pstate_funcs.get_val(cpu, pstate));\n}\n\nstatic void intel_pstate_adjust_pstate(struct cpudata *cpu)\n{\n\tint from = cpu->pstate.current_pstate;\n\tstruct sample *sample;\n\tint target_pstate;\n\n\tupdate_turbo_state();\n\n\ttarget_pstate = get_target_pstate(cpu);\n\ttarget_pstate = intel_pstate_prepare_request(cpu, target_pstate);\n\ttrace_cpu_frequency(target_pstate * cpu->pstate.scaling, cpu->cpu);\n\tintel_pstate_update_pstate(cpu, target_pstate);\n\n\tsample = &cpu->sample;\n\ttrace_pstate_sample(mul_ext_fp(100, sample->core_avg_perf),\n\t\tfp_toint(sample->busy_scaled),\n\t\tfrom,\n\t\tcpu->pstate.current_pstate,\n\t\tsample->mperf,\n\t\tsample->aperf,\n\t\tsample->tsc,\n\t\tget_avg_frequency(cpu),\n\t\tfp_toint(cpu->iowait_boost * 100));\n}\n\nstatic void intel_pstate_update_util(struct update_util_data *data, u64 time,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct cpudata *cpu = container_of(data, struct cpudata, update_util);\n\tu64 delta_ns;\n\n\t \n\tif (smp_processor_id() != cpu->cpu)\n\t\treturn;\n\n\tdelta_ns = time - cpu->last_update;\n\tif (flags & SCHED_CPUFREQ_IOWAIT) {\n\t\t \n\t\tif (delta_ns > TICK_NSEC) {\n\t\t\tcpu->iowait_boost = ONE_EIGHTH_FP;\n\t\t} else if (cpu->iowait_boost >= ONE_EIGHTH_FP) {\n\t\t\tcpu->iowait_boost <<= 1;\n\t\t\tif (cpu->iowait_boost > int_tofp(1))\n\t\t\t\tcpu->iowait_boost = int_tofp(1);\n\t\t} else {\n\t\t\tcpu->iowait_boost = ONE_EIGHTH_FP;\n\t\t}\n\t} else if (cpu->iowait_boost) {\n\t\t \n\t\tif (delta_ns > TICK_NSEC)\n\t\t\tcpu->iowait_boost = 0;\n\t\telse\n\t\t\tcpu->iowait_boost >>= 1;\n\t}\n\tcpu->last_update = time;\n\tdelta_ns = time - cpu->sample.time;\n\tif ((s64)delta_ns < INTEL_PSTATE_SAMPLING_INTERVAL)\n\t\treturn;\n\n\tif (intel_pstate_sample(cpu, time))\n\t\tintel_pstate_adjust_pstate(cpu);\n}\n\nstatic struct pstate_funcs core_funcs = {\n\t.get_max = core_get_max_pstate,\n\t.get_max_physical = core_get_max_pstate_physical,\n\t.get_min = core_get_min_pstate,\n\t.get_turbo = core_get_turbo_pstate,\n\t.get_scaling = core_get_scaling,\n\t.get_val = core_get_val,\n};\n\nstatic const struct pstate_funcs silvermont_funcs = {\n\t.get_max = atom_get_max_pstate,\n\t.get_max_physical = atom_get_max_pstate,\n\t.get_min = atom_get_min_pstate,\n\t.get_turbo = atom_get_turbo_pstate,\n\t.get_val = atom_get_val,\n\t.get_scaling = silvermont_get_scaling,\n\t.get_vid = atom_get_vid,\n};\n\nstatic const struct pstate_funcs airmont_funcs = {\n\t.get_max = atom_get_max_pstate,\n\t.get_max_physical = atom_get_max_pstate,\n\t.get_min = atom_get_min_pstate,\n\t.get_turbo = atom_get_turbo_pstate,\n\t.get_val = atom_get_val,\n\t.get_scaling = airmont_get_scaling,\n\t.get_vid = atom_get_vid,\n};\n\nstatic const struct pstate_funcs knl_funcs = {\n\t.get_max = core_get_max_pstate,\n\t.get_max_physical = core_get_max_pstate_physical,\n\t.get_min = core_get_min_pstate,\n\t.get_turbo = knl_get_turbo_pstate,\n\t.get_aperf_mperf_shift = knl_get_aperf_mperf_shift,\n\t.get_scaling = core_get_scaling,\n\t.get_val = core_get_val,\n};\n\n#define X86_MATCH(model, policy)\t\t\t\t\t \\\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 6, INTEL_FAM6_##model, \\\n\t\t\t\t\t   X86_FEATURE_APERFMPERF, &policy)\n\nstatic const struct x86_cpu_id intel_pstate_cpu_ids[] = {\n\tX86_MATCH(SANDYBRIDGE,\t\tcore_funcs),\n\tX86_MATCH(SANDYBRIDGE_X,\tcore_funcs),\n\tX86_MATCH(ATOM_SILVERMONT,\tsilvermont_funcs),\n\tX86_MATCH(IVYBRIDGE,\t\tcore_funcs),\n\tX86_MATCH(HASWELL,\t\tcore_funcs),\n\tX86_MATCH(BROADWELL,\t\tcore_funcs),\n\tX86_MATCH(IVYBRIDGE_X,\t\tcore_funcs),\n\tX86_MATCH(HASWELL_X,\t\tcore_funcs),\n\tX86_MATCH(HASWELL_L,\t\tcore_funcs),\n\tX86_MATCH(HASWELL_G,\t\tcore_funcs),\n\tX86_MATCH(BROADWELL_G,\t\tcore_funcs),\n\tX86_MATCH(ATOM_AIRMONT,\t\tairmont_funcs),\n\tX86_MATCH(SKYLAKE_L,\t\tcore_funcs),\n\tX86_MATCH(BROADWELL_X,\t\tcore_funcs),\n\tX86_MATCH(SKYLAKE,\t\tcore_funcs),\n\tX86_MATCH(BROADWELL_D,\t\tcore_funcs),\n\tX86_MATCH(XEON_PHI_KNL,\t\tknl_funcs),\n\tX86_MATCH(XEON_PHI_KNM,\t\tknl_funcs),\n\tX86_MATCH(ATOM_GOLDMONT,\tcore_funcs),\n\tX86_MATCH(ATOM_GOLDMONT_PLUS,\tcore_funcs),\n\tX86_MATCH(SKYLAKE_X,\t\tcore_funcs),\n\tX86_MATCH(COMETLAKE,\t\tcore_funcs),\n\tX86_MATCH(ICELAKE_X,\t\tcore_funcs),\n\tX86_MATCH(TIGERLAKE,\t\tcore_funcs),\n\tX86_MATCH(SAPPHIRERAPIDS_X,\tcore_funcs),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, intel_pstate_cpu_ids);\n\nstatic const struct x86_cpu_id intel_pstate_cpu_oob_ids[] __initconst = {\n\tX86_MATCH(BROADWELL_D,\t\tcore_funcs),\n\tX86_MATCH(BROADWELL_X,\t\tcore_funcs),\n\tX86_MATCH(SKYLAKE_X,\t\tcore_funcs),\n\tX86_MATCH(ICELAKE_X,\t\tcore_funcs),\n\tX86_MATCH(SAPPHIRERAPIDS_X,\tcore_funcs),\n\t{}\n};\n\nstatic const struct x86_cpu_id intel_pstate_cpu_ee_disable_ids[] = {\n\tX86_MATCH(KABYLAKE,\t\tcore_funcs),\n\t{}\n};\n\nstatic int intel_pstate_init_cpu(unsigned int cpunum)\n{\n\tstruct cpudata *cpu;\n\n\tcpu = all_cpu_data[cpunum];\n\n\tif (!cpu) {\n\t\tcpu = kzalloc(sizeof(*cpu), GFP_KERNEL);\n\t\tif (!cpu)\n\t\t\treturn -ENOMEM;\n\n\t\tWRITE_ONCE(all_cpu_data[cpunum], cpu);\n\n\t\tcpu->cpu = cpunum;\n\n\t\tcpu->epp_default = -EINVAL;\n\n\t\tif (hwp_active) {\n\t\t\tintel_pstate_hwp_enable(cpu);\n\n\t\t\tif (intel_pstate_acpi_pm_profile_server())\n\t\t\t\thwp_boost = true;\n\t\t}\n\t} else if (hwp_active) {\n\t\t \n\t\tintel_pstate_hwp_reenable(cpu);\n\t}\n\n\tcpu->epp_powersave = -EINVAL;\n\tcpu->epp_policy = 0;\n\n\tintel_pstate_get_cpu_pstates(cpu);\n\n\tpr_debug(\"controlling: cpu %d\\n\", cpunum);\n\n\treturn 0;\n}\n\nstatic void intel_pstate_set_update_util_hook(unsigned int cpu_num)\n{\n\tstruct cpudata *cpu = all_cpu_data[cpu_num];\n\n\tif (hwp_active && !hwp_boost)\n\t\treturn;\n\n\tif (cpu->update_util_set)\n\t\treturn;\n\n\t \n\tcpu->sample.time = 0;\n\tcpufreq_add_update_util_hook(cpu_num, &cpu->update_util,\n\t\t\t\t     (hwp_active ?\n\t\t\t\t      intel_pstate_update_util_hwp :\n\t\t\t\t      intel_pstate_update_util));\n\tcpu->update_util_set = true;\n}\n\nstatic void intel_pstate_clear_update_util_hook(unsigned int cpu)\n{\n\tstruct cpudata *cpu_data = all_cpu_data[cpu];\n\n\tif (!cpu_data->update_util_set)\n\t\treturn;\n\n\tcpufreq_remove_update_util_hook(cpu);\n\tcpu_data->update_util_set = false;\n\tsynchronize_rcu();\n}\n\nstatic int intel_pstate_get_max_freq(struct cpudata *cpu)\n{\n\treturn global.turbo_disabled || global.no_turbo ?\n\t\t\tcpu->pstate.max_freq : cpu->pstate.turbo_freq;\n}\n\nstatic void intel_pstate_update_perf_limits(struct cpudata *cpu,\n\t\t\t\t\t    unsigned int policy_min,\n\t\t\t\t\t    unsigned int policy_max)\n{\n\tint perf_ctl_scaling = cpu->pstate.perf_ctl_scaling;\n\tint32_t max_policy_perf, min_policy_perf;\n\n\tmax_policy_perf = policy_max / perf_ctl_scaling;\n\tif (policy_max == policy_min) {\n\t\tmin_policy_perf = max_policy_perf;\n\t} else {\n\t\tmin_policy_perf = policy_min / perf_ctl_scaling;\n\t\tmin_policy_perf = clamp_t(int32_t, min_policy_perf,\n\t\t\t\t\t  0, max_policy_perf);\n\t}\n\n\t \n\tif (hwp_active && cpu->pstate.scaling != perf_ctl_scaling) {\n\t\tint scaling = cpu->pstate.scaling;\n\t\tint freq;\n\n\t\tfreq = max_policy_perf * perf_ctl_scaling;\n\t\tmax_policy_perf = DIV_ROUND_UP(freq, scaling);\n\t\tfreq = min_policy_perf * perf_ctl_scaling;\n\t\tmin_policy_perf = DIV_ROUND_UP(freq, scaling);\n\t}\n\n\tpr_debug(\"cpu:%d min_policy_perf:%d max_policy_perf:%d\\n\",\n\t\t cpu->cpu, min_policy_perf, max_policy_perf);\n\n\t \n\tif (per_cpu_limits) {\n\t\tcpu->min_perf_ratio = min_policy_perf;\n\t\tcpu->max_perf_ratio = max_policy_perf;\n\t} else {\n\t\tint turbo_max = cpu->pstate.turbo_pstate;\n\t\tint32_t global_min, global_max;\n\n\t\t \n\t\tglobal_max = DIV_ROUND_UP(turbo_max * global.max_perf_pct, 100);\n\t\tglobal_min = DIV_ROUND_UP(turbo_max * global.min_perf_pct, 100);\n\t\tglobal_min = clamp_t(int32_t, global_min, 0, global_max);\n\n\t\tpr_debug(\"cpu:%d global_min:%d global_max:%d\\n\", cpu->cpu,\n\t\t\t global_min, global_max);\n\n\t\tcpu->min_perf_ratio = max(min_policy_perf, global_min);\n\t\tcpu->min_perf_ratio = min(cpu->min_perf_ratio, max_policy_perf);\n\t\tcpu->max_perf_ratio = min(max_policy_perf, global_max);\n\t\tcpu->max_perf_ratio = max(min_policy_perf, cpu->max_perf_ratio);\n\n\t\t \n\t\tcpu->min_perf_ratio = min(cpu->min_perf_ratio,\n\t\t\t\t\t  cpu->max_perf_ratio);\n\n\t}\n\tpr_debug(\"cpu:%d max_perf_ratio:%d min_perf_ratio:%d\\n\", cpu->cpu,\n\t\t cpu->max_perf_ratio,\n\t\t cpu->min_perf_ratio);\n}\n\nstatic int intel_pstate_set_policy(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu;\n\n\tif (!policy->cpuinfo.max_freq)\n\t\treturn -ENODEV;\n\n\tpr_debug(\"set_policy cpuinfo.max %u policy->max %u\\n\",\n\t\t policy->cpuinfo.max_freq, policy->max);\n\n\tcpu = all_cpu_data[policy->cpu];\n\tcpu->policy = policy->policy;\n\n\tmutex_lock(&intel_pstate_limits_lock);\n\n\tintel_pstate_update_perf_limits(cpu, policy->min, policy->max);\n\n\tif (cpu->policy == CPUFREQ_POLICY_PERFORMANCE) {\n\t\t \n\t\tintel_pstate_clear_update_util_hook(policy->cpu);\n\t\tintel_pstate_max_within_limits(cpu);\n\t} else {\n\t\tintel_pstate_set_update_util_hook(policy->cpu);\n\t}\n\n\tif (hwp_active) {\n\t\t \n\t\tif (!hwp_boost)\n\t\t\tintel_pstate_clear_update_util_hook(policy->cpu);\n\t\tintel_pstate_hwp_set(policy->cpu);\n\t}\n\t \n\tpolicy->cur = policy->min;\n\n\tmutex_unlock(&intel_pstate_limits_lock);\n\n\treturn 0;\n}\n\nstatic void intel_pstate_adjust_policy_max(struct cpudata *cpu,\n\t\t\t\t\t   struct cpufreq_policy_data *policy)\n{\n\tif (!hwp_active &&\n\t    cpu->pstate.max_pstate_physical > cpu->pstate.max_pstate &&\n\t    policy->max < policy->cpuinfo.max_freq &&\n\t    policy->max > cpu->pstate.max_freq) {\n\t\tpr_debug(\"policy->max > max non turbo frequency\\n\");\n\t\tpolicy->max = policy->cpuinfo.max_freq;\n\t}\n}\n\nstatic void intel_pstate_verify_cpu_policy(struct cpudata *cpu,\n\t\t\t\t\t   struct cpufreq_policy_data *policy)\n{\n\tint max_freq;\n\n\tupdate_turbo_state();\n\tif (hwp_active) {\n\t\tintel_pstate_get_hwp_cap(cpu);\n\t\tmax_freq = global.no_turbo || global.turbo_disabled ?\n\t\t\t\tcpu->pstate.max_freq : cpu->pstate.turbo_freq;\n\t} else {\n\t\tmax_freq = intel_pstate_get_max_freq(cpu);\n\t}\n\tcpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq, max_freq);\n\n\tintel_pstate_adjust_policy_max(cpu, policy);\n}\n\nstatic int intel_pstate_verify_policy(struct cpufreq_policy_data *policy)\n{\n\tintel_pstate_verify_cpu_policy(all_cpu_data[policy->cpu], policy);\n\n\treturn 0;\n}\n\nstatic int intel_cpufreq_cpu_offline(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\tpr_debug(\"CPU %d going offline\\n\", cpu->cpu);\n\n\tif (cpu->suspended)\n\t\treturn 0;\n\n\t \n\tif (hwp_active)\n\t\tintel_pstate_hwp_offline(cpu);\n\telse\n\t\tintel_pstate_set_min_pstate(cpu);\n\n\tintel_pstate_exit_perf_limits(policy);\n\n\treturn 0;\n}\n\nstatic int intel_pstate_cpu_online(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\tpr_debug(\"CPU %d going online\\n\", cpu->cpu);\n\n\tintel_pstate_init_acpi_perf_limits(policy);\n\n\tif (hwp_active) {\n\t\t \n\t\tintel_pstate_hwp_reenable(cpu);\n\t\tcpu->suspended = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int intel_pstate_cpu_offline(struct cpufreq_policy *policy)\n{\n\tintel_pstate_clear_update_util_hook(policy->cpu);\n\n\treturn intel_cpufreq_cpu_offline(policy);\n}\n\nstatic int intel_pstate_cpu_exit(struct cpufreq_policy *policy)\n{\n\tpr_debug(\"CPU %d exiting\\n\", policy->cpu);\n\n\tpolicy->fast_switch_possible = false;\n\n\treturn 0;\n}\n\nstatic int __intel_pstate_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpudata *cpu;\n\tint rc;\n\n\trc = intel_pstate_init_cpu(policy->cpu);\n\tif (rc)\n\t\treturn rc;\n\n\tcpu = all_cpu_data[policy->cpu];\n\n\tcpu->max_perf_ratio = 0xFF;\n\tcpu->min_perf_ratio = 0;\n\n\t \n\tpolicy->cpuinfo.min_freq = cpu->pstate.min_freq;\n\tupdate_turbo_state();\n\tglobal.turbo_disabled_mf = global.turbo_disabled;\n\tpolicy->cpuinfo.max_freq = global.turbo_disabled ?\n\t\t\tcpu->pstate.max_freq : cpu->pstate.turbo_freq;\n\n\tpolicy->min = policy->cpuinfo.min_freq;\n\tpolicy->max = policy->cpuinfo.max_freq;\n\n\tintel_pstate_init_acpi_perf_limits(policy);\n\n\tpolicy->fast_switch_possible = true;\n\n\treturn 0;\n}\n\nstatic int intel_pstate_cpu_init(struct cpufreq_policy *policy)\n{\n\tint ret = __intel_pstate_cpu_init(policy);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tpolicy->policy = CPUFREQ_POLICY_POWERSAVE;\n\n\tif (hwp_active) {\n\t\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\t\tcpu->epp_cached = intel_pstate_get_epp(cpu, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver intel_pstate = {\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.verify\t\t= intel_pstate_verify_policy,\n\t.setpolicy\t= intel_pstate_set_policy,\n\t.suspend\t= intel_pstate_suspend,\n\t.resume\t\t= intel_pstate_resume,\n\t.init\t\t= intel_pstate_cpu_init,\n\t.exit\t\t= intel_pstate_cpu_exit,\n\t.offline\t= intel_pstate_cpu_offline,\n\t.online\t\t= intel_pstate_cpu_online,\n\t.update_limits\t= intel_pstate_update_limits,\n\t.name\t\t= \"intel_pstate\",\n};\n\nstatic int intel_cpufreq_verify_policy(struct cpufreq_policy_data *policy)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\n\tintel_pstate_verify_cpu_policy(cpu, policy);\n\tintel_pstate_update_perf_limits(cpu, policy->min, policy->max);\n\n\treturn 0;\n}\n\n \n\n#define\tINTEL_PSTATE_TRACE_TARGET 10\n#define\tINTEL_PSTATE_TRACE_FAST_SWITCH 90\n\nstatic void intel_cpufreq_trace(struct cpudata *cpu, unsigned int trace_type, int old_pstate)\n{\n\tstruct sample *sample;\n\n\tif (!trace_pstate_sample_enabled())\n\t\treturn;\n\n\tif (!intel_pstate_sample(cpu, ktime_get()))\n\t\treturn;\n\n\tsample = &cpu->sample;\n\ttrace_pstate_sample(trace_type,\n\t\t0,\n\t\told_pstate,\n\t\tcpu->pstate.current_pstate,\n\t\tsample->mperf,\n\t\tsample->aperf,\n\t\tsample->tsc,\n\t\tget_avg_frequency(cpu),\n\t\tfp_toint(cpu->iowait_boost * 100));\n}\n\nstatic void intel_cpufreq_hwp_update(struct cpudata *cpu, u32 min, u32 max,\n\t\t\t\t     u32 desired, bool fast_switch)\n{\n\tu64 prev = READ_ONCE(cpu->hwp_req_cached), value = prev;\n\n\tvalue &= ~HWP_MIN_PERF(~0L);\n\tvalue |= HWP_MIN_PERF(min);\n\n\tvalue &= ~HWP_MAX_PERF(~0L);\n\tvalue |= HWP_MAX_PERF(max);\n\n\tvalue &= ~HWP_DESIRED_PERF(~0L);\n\tvalue |= HWP_DESIRED_PERF(desired);\n\n\tif (value == prev)\n\t\treturn;\n\n\tWRITE_ONCE(cpu->hwp_req_cached, value);\n\tif (fast_switch)\n\t\twrmsrl(MSR_HWP_REQUEST, value);\n\telse\n\t\twrmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, value);\n}\n\nstatic void intel_cpufreq_perf_ctl_update(struct cpudata *cpu,\n\t\t\t\t\t  u32 target_pstate, bool fast_switch)\n{\n\tif (fast_switch)\n\t\twrmsrl(MSR_IA32_PERF_CTL,\n\t\t       pstate_funcs.get_val(cpu, target_pstate));\n\telse\n\t\twrmsrl_on_cpu(cpu->cpu, MSR_IA32_PERF_CTL,\n\t\t\t      pstate_funcs.get_val(cpu, target_pstate));\n}\n\nstatic int intel_cpufreq_update_pstate(struct cpufreq_policy *policy,\n\t\t\t\t       int target_pstate, bool fast_switch)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\tint old_pstate = cpu->pstate.current_pstate;\n\n\ttarget_pstate = intel_pstate_prepare_request(cpu, target_pstate);\n\tif (hwp_active) {\n\t\tint max_pstate = policy->strict_target ?\n\t\t\t\t\ttarget_pstate : cpu->max_perf_ratio;\n\n\t\tintel_cpufreq_hwp_update(cpu, target_pstate, max_pstate, 0,\n\t\t\t\t\t fast_switch);\n\t} else if (target_pstate != old_pstate) {\n\t\tintel_cpufreq_perf_ctl_update(cpu, target_pstate, fast_switch);\n\t}\n\n\tcpu->pstate.current_pstate = target_pstate;\n\n\tintel_cpufreq_trace(cpu, fast_switch ? INTEL_PSTATE_TRACE_FAST_SWITCH :\n\t\t\t    INTEL_PSTATE_TRACE_TARGET, old_pstate);\n\n\treturn target_pstate;\n}\n\nstatic int intel_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t\tunsigned int target_freq,\n\t\t\t\tunsigned int relation)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\tstruct cpufreq_freqs freqs;\n\tint target_pstate;\n\n\tupdate_turbo_state();\n\n\tfreqs.old = policy->cur;\n\tfreqs.new = target_freq;\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\n\tswitch (relation) {\n\tcase CPUFREQ_RELATION_L:\n\t\ttarget_pstate = DIV_ROUND_UP(freqs.new, cpu->pstate.scaling);\n\t\tbreak;\n\tcase CPUFREQ_RELATION_H:\n\t\ttarget_pstate = freqs.new / cpu->pstate.scaling;\n\t\tbreak;\n\tdefault:\n\t\ttarget_pstate = DIV_ROUND_CLOSEST(freqs.new, cpu->pstate.scaling);\n\t\tbreak;\n\t}\n\n\ttarget_pstate = intel_cpufreq_update_pstate(policy, target_pstate, false);\n\n\tfreqs.new = target_pstate * cpu->pstate.scaling;\n\n\tcpufreq_freq_transition_end(policy, &freqs, false);\n\n\treturn 0;\n}\n\nstatic unsigned int intel_cpufreq_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\t      unsigned int target_freq)\n{\n\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\tint target_pstate;\n\n\tupdate_turbo_state();\n\n\ttarget_pstate = DIV_ROUND_UP(target_freq, cpu->pstate.scaling);\n\n\ttarget_pstate = intel_cpufreq_update_pstate(policy, target_pstate, true);\n\n\treturn target_pstate * cpu->pstate.scaling;\n}\n\nstatic void intel_cpufreq_adjust_perf(unsigned int cpunum,\n\t\t\t\t      unsigned long min_perf,\n\t\t\t\t      unsigned long target_perf,\n\t\t\t\t      unsigned long capacity)\n{\n\tstruct cpudata *cpu = all_cpu_data[cpunum];\n\tu64 hwp_cap = READ_ONCE(cpu->hwp_cap_cached);\n\tint old_pstate = cpu->pstate.current_pstate;\n\tint cap_pstate, min_pstate, max_pstate, target_pstate;\n\n\tupdate_turbo_state();\n\tcap_pstate = global.turbo_disabled ? HWP_GUARANTEED_PERF(hwp_cap) :\n\t\t\t\t\t     HWP_HIGHEST_PERF(hwp_cap);\n\n\t \n\n\ttarget_pstate = cap_pstate;\n\tif (target_perf < capacity)\n\t\ttarget_pstate = DIV_ROUND_UP(cap_pstate * target_perf, capacity);\n\n\tmin_pstate = cap_pstate;\n\tif (min_perf < capacity)\n\t\tmin_pstate = DIV_ROUND_UP(cap_pstate * min_perf, capacity);\n\n\tif (min_pstate < cpu->pstate.min_pstate)\n\t\tmin_pstate = cpu->pstate.min_pstate;\n\n\tif (min_pstate < cpu->min_perf_ratio)\n\t\tmin_pstate = cpu->min_perf_ratio;\n\n\tmax_pstate = min(cap_pstate, cpu->max_perf_ratio);\n\tif (max_pstate < min_pstate)\n\t\tmax_pstate = min_pstate;\n\n\ttarget_pstate = clamp_t(int, target_pstate, min_pstate, max_pstate);\n\n\tintel_cpufreq_hwp_update(cpu, min_pstate, max_pstate, target_pstate, true);\n\n\tcpu->pstate.current_pstate = target_pstate;\n\tintel_cpufreq_trace(cpu, INTEL_PSTATE_TRACE_FAST_SWITCH, old_pstate);\n}\n\nstatic int intel_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct freq_qos_request *req;\n\tstruct cpudata *cpu;\n\tstruct device *dev;\n\tint ret, freq;\n\n\tdev = get_cpu_device(policy->cpu);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tret = __intel_pstate_cpu_init(policy);\n\tif (ret)\n\t\treturn ret;\n\n\tpolicy->cpuinfo.transition_latency = INTEL_CPUFREQ_TRANSITION_LATENCY;\n\t \n\tpolicy->cur = policy->cpuinfo.min_freq;\n\n\treq = kcalloc(2, sizeof(*req), GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto pstate_exit;\n\t}\n\n\tcpu = all_cpu_data[policy->cpu];\n\n\tif (hwp_active) {\n\t\tu64 value;\n\n\t\tpolicy->transition_delay_us = INTEL_CPUFREQ_TRANSITION_DELAY_HWP;\n\n\t\tintel_pstate_get_hwp_cap(cpu);\n\n\t\trdmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, &value);\n\t\tWRITE_ONCE(cpu->hwp_req_cached, value);\n\n\t\tcpu->epp_cached = intel_pstate_get_epp(cpu, value);\n\t} else {\n\t\tpolicy->transition_delay_us = INTEL_CPUFREQ_TRANSITION_DELAY;\n\t}\n\n\tfreq = DIV_ROUND_UP(cpu->pstate.turbo_freq * global.min_perf_pct, 100);\n\n\tret = freq_qos_add_request(&policy->constraints, req, FREQ_QOS_MIN,\n\t\t\t\t   freq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to add min-freq constraint (%d)\\n\", ret);\n\t\tgoto free_req;\n\t}\n\n\tfreq = DIV_ROUND_UP(cpu->pstate.turbo_freq * global.max_perf_pct, 100);\n\n\tret = freq_qos_add_request(&policy->constraints, req + 1, FREQ_QOS_MAX,\n\t\t\t\t   freq);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to add max-freq constraint (%d)\\n\", ret);\n\t\tgoto remove_min_req;\n\t}\n\n\tpolicy->driver_data = req;\n\n\treturn 0;\n\nremove_min_req:\n\tfreq_qos_remove_request(req);\nfree_req:\n\tkfree(req);\npstate_exit:\n\tintel_pstate_exit_perf_limits(policy);\n\n\treturn ret;\n}\n\nstatic int intel_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\tstruct freq_qos_request *req;\n\n\treq = policy->driver_data;\n\n\tfreq_qos_remove_request(req + 1);\n\tfreq_qos_remove_request(req);\n\tkfree(req);\n\n\treturn intel_pstate_cpu_exit(policy);\n}\n\nstatic int intel_cpufreq_suspend(struct cpufreq_policy *policy)\n{\n\tintel_pstate_suspend(policy);\n\n\tif (hwp_active) {\n\t\tstruct cpudata *cpu = all_cpu_data[policy->cpu];\n\t\tu64 value = READ_ONCE(cpu->hwp_req_cached);\n\n\t\t \n\t\tvalue &= ~HWP_DESIRED_PERF(~0L);\n\t\twrmsrl_on_cpu(cpu->cpu, MSR_HWP_REQUEST, value);\n\t\tWRITE_ONCE(cpu->hwp_req_cached, value);\n\t}\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver intel_cpufreq = {\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.verify\t\t= intel_cpufreq_verify_policy,\n\t.target\t\t= intel_cpufreq_target,\n\t.fast_switch\t= intel_cpufreq_fast_switch,\n\t.init\t\t= intel_cpufreq_cpu_init,\n\t.exit\t\t= intel_cpufreq_cpu_exit,\n\t.offline\t= intel_cpufreq_cpu_offline,\n\t.online\t\t= intel_pstate_cpu_online,\n\t.suspend\t= intel_cpufreq_suspend,\n\t.resume\t\t= intel_pstate_resume,\n\t.update_limits\t= intel_pstate_update_limits,\n\t.name\t\t= \"intel_cpufreq\",\n};\n\nstatic struct cpufreq_driver *default_driver;\n\nstatic void intel_pstate_driver_cleanup(void)\n{\n\tunsigned int cpu;\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tif (all_cpu_data[cpu]) {\n\t\t\tif (intel_pstate_driver == &intel_pstate)\n\t\t\t\tintel_pstate_clear_update_util_hook(cpu);\n\n\t\t\tspin_lock(&hwp_notify_lock);\n\t\t\tkfree(all_cpu_data[cpu]);\n\t\t\tWRITE_ONCE(all_cpu_data[cpu], NULL);\n\t\t\tspin_unlock(&hwp_notify_lock);\n\t\t}\n\t}\n\tcpus_read_unlock();\n\n\tintel_pstate_driver = NULL;\n}\n\nstatic int intel_pstate_register_driver(struct cpufreq_driver *driver)\n{\n\tint ret;\n\n\tif (driver == &intel_pstate)\n\t\tintel_pstate_sysfs_expose_hwp_dynamic_boost();\n\n\tmemset(&global, 0, sizeof(global));\n\tglobal.max_perf_pct = 100;\n\n\tintel_pstate_driver = driver;\n\tret = cpufreq_register_driver(intel_pstate_driver);\n\tif (ret) {\n\t\tintel_pstate_driver_cleanup();\n\t\treturn ret;\n\t}\n\n\tglobal.min_perf_pct = min_perf_pct_min();\n\n\treturn 0;\n}\n\nstatic ssize_t intel_pstate_show_status(char *buf)\n{\n\tif (!intel_pstate_driver)\n\t\treturn sprintf(buf, \"off\\n\");\n\n\treturn sprintf(buf, \"%s\\n\", intel_pstate_driver == &intel_pstate ?\n\t\t\t\t\t\"active\" : \"passive\");\n}\n\nstatic int intel_pstate_update_status(const char *buf, size_t size)\n{\n\tif (size == 3 && !strncmp(buf, \"off\", size)) {\n\t\tif (!intel_pstate_driver)\n\t\t\treturn -EINVAL;\n\n\t\tif (hwp_active)\n\t\t\treturn -EBUSY;\n\n\t\tcpufreq_unregister_driver(intel_pstate_driver);\n\t\tintel_pstate_driver_cleanup();\n\t\treturn 0;\n\t}\n\n\tif (size == 6 && !strncmp(buf, \"active\", size)) {\n\t\tif (intel_pstate_driver) {\n\t\t\tif (intel_pstate_driver == &intel_pstate)\n\t\t\t\treturn 0;\n\n\t\t\tcpufreq_unregister_driver(intel_pstate_driver);\n\t\t}\n\n\t\treturn intel_pstate_register_driver(&intel_pstate);\n\t}\n\n\tif (size == 7 && !strncmp(buf, \"passive\", size)) {\n\t\tif (intel_pstate_driver) {\n\t\t\tif (intel_pstate_driver == &intel_cpufreq)\n\t\t\t\treturn 0;\n\n\t\t\tcpufreq_unregister_driver(intel_pstate_driver);\n\t\t\tintel_pstate_sysfs_hide_hwp_dynamic_boost();\n\t\t}\n\n\t\treturn intel_pstate_register_driver(&intel_cpufreq);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int no_load __initdata;\nstatic int no_hwp __initdata;\nstatic int hwp_only __initdata;\nstatic unsigned int force_load __initdata;\n\nstatic int __init intel_pstate_msrs_not_valid(void)\n{\n\tif (!pstate_funcs.get_max(0) ||\n\t    !pstate_funcs.get_min(0) ||\n\t    !pstate_funcs.get_turbo(0))\n\t\treturn -ENODEV;\n\n\treturn 0;\n}\n\nstatic void __init copy_cpu_funcs(struct pstate_funcs *funcs)\n{\n\tpstate_funcs.get_max   = funcs->get_max;\n\tpstate_funcs.get_max_physical = funcs->get_max_physical;\n\tpstate_funcs.get_min   = funcs->get_min;\n\tpstate_funcs.get_turbo = funcs->get_turbo;\n\tpstate_funcs.get_scaling = funcs->get_scaling;\n\tpstate_funcs.get_val   = funcs->get_val;\n\tpstate_funcs.get_vid   = funcs->get_vid;\n\tpstate_funcs.get_aperf_mperf_shift = funcs->get_aperf_mperf_shift;\n}\n\n#ifdef CONFIG_ACPI\n\nstatic bool __init intel_pstate_no_acpi_pss(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tacpi_status status;\n\t\tunion acpi_object *pss;\n\t\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\t\tstruct acpi_processor *pr = per_cpu(processors, i);\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tstatus = acpi_evaluate_object(pr->handle, \"_PSS\", NULL, &buffer);\n\t\tif (ACPI_FAILURE(status))\n\t\t\tcontinue;\n\n\t\tpss = buffer.pointer;\n\t\tif (pss && pss->type == ACPI_TYPE_PACKAGE) {\n\t\t\tkfree(pss);\n\t\t\treturn false;\n\t\t}\n\n\t\tkfree(pss);\n\t}\n\n\tpr_debug(\"ACPI _PSS not found\\n\");\n\treturn true;\n}\n\nstatic bool __init intel_pstate_no_acpi_pcch(void)\n{\n\tacpi_status status;\n\tacpi_handle handle;\n\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\tgoto not_found;\n\n\tif (acpi_has_method(handle, \"PCCH\"))\n\t\treturn false;\n\nnot_found:\n\tpr_debug(\"ACPI PCCH not found\\n\");\n\treturn true;\n}\n\nstatic bool __init intel_pstate_has_acpi_ppc(void)\n{\n\tint i;\n\n\tfor_each_possible_cpu(i) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, i);\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\t\tif (acpi_has_method(pr->handle, \"_PPC\"))\n\t\t\treturn true;\n\t}\n\tpr_debug(\"ACPI _PPC not found\\n\");\n\treturn false;\n}\n\nenum {\n\tPSS,\n\tPPC,\n};\n\n \nstatic struct acpi_platform_list plat_info[] __initdata = {\n\t{\"HP    \", \"ProLiant\", 0, ACPI_SIG_FADT, all_versions, NULL, PSS},\n\t{\"ORACLE\", \"X4-2    \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4-2L   \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4-2B   \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X3-2    \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X3-2L   \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X3-2B   \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4470M2 \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4270M3 \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4270M2 \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4170M2 \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4170 M3\", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X4275 M3\", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"X6-2    \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{\"ORACLE\", \"Sudbury \", 0, ACPI_SIG_FADT, all_versions, NULL, PPC},\n\t{ }  \n};\n\n#define BITMASK_OOB\t(BIT(8) | BIT(18))\n\nstatic bool __init intel_pstate_platform_pwr_mgmt_exists(void)\n{\n\tconst struct x86_cpu_id *id;\n\tu64 misc_pwr;\n\tint idx;\n\n\tid = x86_match_cpu(intel_pstate_cpu_oob_ids);\n\tif (id) {\n\t\trdmsrl(MSR_MISC_PWR_MGMT, misc_pwr);\n\t\tif (misc_pwr & BITMASK_OOB) {\n\t\t\tpr_debug(\"Bit 8 or 18 in the MISC_PWR_MGMT MSR set\\n\");\n\t\t\tpr_debug(\"P states are controlled in Out of Band mode by the firmware/hardware\\n\");\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tidx = acpi_match_platform_list(plat_info);\n\tif (idx < 0)\n\t\treturn false;\n\n\tswitch (plat_info[idx].data) {\n\tcase PSS:\n\t\tif (!intel_pstate_no_acpi_pss())\n\t\t\treturn false;\n\n\t\treturn intel_pstate_no_acpi_pcch();\n\tcase PPC:\n\t\treturn intel_pstate_has_acpi_ppc() && !force_load;\n\t}\n\n\treturn false;\n}\n\nstatic void intel_pstate_request_control_from_smm(void)\n{\n\t \n\tif (acpi_ppc)\n\t\tacpi_processor_pstate_control();\n}\n#else  \nstatic inline bool intel_pstate_platform_pwr_mgmt_exists(void) { return false; }\nstatic inline bool intel_pstate_has_acpi_ppc(void) { return false; }\nstatic inline void intel_pstate_request_control_from_smm(void) {}\n#endif  \n\n#define INTEL_PSTATE_HWP_BROADWELL\t0x01\n\n#define X86_MATCH_HWP(model, hwp_mode)\t\t\t\t\t\\\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 6, INTEL_FAM6_##model, \\\n\t\t\t\t\t   X86_FEATURE_HWP, hwp_mode)\n\nstatic const struct x86_cpu_id hwp_support_ids[] __initconst = {\n\tX86_MATCH_HWP(BROADWELL_X,\tINTEL_PSTATE_HWP_BROADWELL),\n\tX86_MATCH_HWP(BROADWELL_D,\tINTEL_PSTATE_HWP_BROADWELL),\n\tX86_MATCH_HWP(ANY,\t\t0),\n\t{}\n};\n\nstatic bool intel_pstate_hwp_is_enabled(void)\n{\n\tu64 value;\n\n\trdmsrl(MSR_PM_ENABLE, value);\n\treturn !!(value & 0x1);\n}\n\nstatic const struct x86_cpu_id intel_epp_balance_perf[] = {\n\t \n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L, 102),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, 32),\n\t{}\n};\n\nstatic int __init intel_pstate_init(void)\n{\n\tstatic struct cpudata **_all_cpu_data;\n\tconst struct x86_cpu_id *id;\n\tint rc;\n\n\tif (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL)\n\t\treturn -ENODEV;\n\n\tid = x86_match_cpu(hwp_support_ids);\n\tif (id) {\n\t\thwp_forced = intel_pstate_hwp_is_enabled();\n\n\t\tif (hwp_forced)\n\t\t\tpr_info(\"HWP enabled by BIOS\\n\");\n\t\telse if (no_load)\n\t\t\treturn -ENODEV;\n\n\t\tcopy_cpu_funcs(&core_funcs);\n\t\t \n\t\tif ((!no_hwp && boot_cpu_has(X86_FEATURE_HWP_EPP)) || hwp_forced) {\n\t\t\tWRITE_ONCE(hwp_active, 1);\n\t\t\thwp_mode_bdw = id->driver_data;\n\t\t\tintel_pstate.attr = hwp_cpufreq_attrs;\n\t\t\tintel_cpufreq.attr = hwp_cpufreq_attrs;\n\t\t\tintel_cpufreq.flags |= CPUFREQ_NEED_UPDATE_LIMITS;\n\t\t\tintel_cpufreq.adjust_perf = intel_cpufreq_adjust_perf;\n\t\t\tif (!default_driver)\n\t\t\t\tdefault_driver = &intel_pstate;\n\n\t\t\tpstate_funcs.get_cpu_scaling = hwp_get_cpu_scaling;\n\n\t\t\tgoto hwp_cpu_matched;\n\t\t}\n\t\tpr_info(\"HWP not enabled\\n\");\n\t} else {\n\t\tif (no_load)\n\t\t\treturn -ENODEV;\n\n\t\tid = x86_match_cpu(intel_pstate_cpu_ids);\n\t\tif (!id) {\n\t\t\tpr_info(\"CPU model not supported\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tcopy_cpu_funcs((struct pstate_funcs *)id->driver_data);\n\t}\n\n\tif (intel_pstate_msrs_not_valid()) {\n\t\tpr_info(\"Invalid MSRs\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (!default_driver)\n\t\tdefault_driver = &intel_cpufreq;\n\nhwp_cpu_matched:\n\t \n\tif (intel_pstate_platform_pwr_mgmt_exists()) {\n\t\tpr_info(\"P-states controlled by the platform\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!hwp_active && hwp_only)\n\t\treturn -ENOTSUPP;\n\n\tpr_info(\"Intel P-state driver initializing\\n\");\n\n\t_all_cpu_data = vzalloc(array_size(sizeof(void *), num_possible_cpus()));\n\tif (!_all_cpu_data)\n\t\treturn -ENOMEM;\n\n\tWRITE_ONCE(all_cpu_data, _all_cpu_data);\n\n\tintel_pstate_request_control_from_smm();\n\n\tintel_pstate_sysfs_expose_params();\n\n\tif (hwp_active) {\n\t\tconst struct x86_cpu_id *id = x86_match_cpu(intel_epp_balance_perf);\n\n\t\tif (id)\n\t\t\tepp_values[EPP_INDEX_BALANCE_PERFORMANCE] = id->driver_data;\n\t}\n\n\tmutex_lock(&intel_pstate_driver_lock);\n\trc = intel_pstate_register_driver(default_driver);\n\tmutex_unlock(&intel_pstate_driver_lock);\n\tif (rc) {\n\t\tintel_pstate_sysfs_remove();\n\t\treturn rc;\n\t}\n\n\tif (hwp_active) {\n\t\tconst struct x86_cpu_id *id;\n\n\t\tid = x86_match_cpu(intel_pstate_cpu_ee_disable_ids);\n\t\tif (id) {\n\t\t\tset_power_ctl_ee_state(false);\n\t\t\tpr_info(\"Disabling energy efficiency optimization\\n\");\n\t\t}\n\n\t\tpr_info(\"HWP enabled\\n\");\n\t} else if (boot_cpu_has(X86_FEATURE_HYBRID_CPU)) {\n\t\tpr_warn(\"Problematic setup: Hybrid processor with disabled HWP\\n\");\n\t}\n\n\treturn 0;\n}\ndevice_initcall(intel_pstate_init);\n\nstatic int __init intel_pstate_setup(char *str)\n{\n\tif (!str)\n\t\treturn -EINVAL;\n\n\tif (!strcmp(str, \"disable\"))\n\t\tno_load = 1;\n\telse if (!strcmp(str, \"active\"))\n\t\tdefault_driver = &intel_pstate;\n\telse if (!strcmp(str, \"passive\"))\n\t\tdefault_driver = &intel_cpufreq;\n\n\tif (!strcmp(str, \"no_hwp\"))\n\t\tno_hwp = 1;\n\n\tif (!strcmp(str, \"force\"))\n\t\tforce_load = 1;\n\tif (!strcmp(str, \"hwp_only\"))\n\t\thwp_only = 1;\n\tif (!strcmp(str, \"per_cpu_perf_limits\"))\n\t\tper_cpu_limits = true;\n\n#ifdef CONFIG_ACPI\n\tif (!strcmp(str, \"support_acpi_ppc\"))\n\t\tacpi_ppc = true;\n#endif\n\n\treturn 0;\n}\nearly_param(\"intel_pstate\", intel_pstate_setup);\n\nMODULE_AUTHOR(\"Dirk Brandewie <dirk.j.brandewie@intel.com>\");\nMODULE_DESCRIPTION(\"'intel_pstate' - P state driver Intel Core processors\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}