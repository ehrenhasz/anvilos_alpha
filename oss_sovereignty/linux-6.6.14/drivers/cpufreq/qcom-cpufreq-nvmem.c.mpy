{
  "module_name": "qcom-cpufreq-nvmem.c",
  "hash_id": "23a978b2d23ed524451b4e3df628921982b3d1bfb8321fb35f30ac847c7375f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/qcom-cpufreq-nvmem.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/smem.h>\n\n#include <dt-bindings/arm/qcom,ids.h>\n\nstruct qcom_cpufreq_drv;\n\nstruct qcom_cpufreq_match_data {\n\tint (*get_version)(struct device *cpu_dev,\n\t\t\t   struct nvmem_cell *speedbin_nvmem,\n\t\t\t   char **pvs_name,\n\t\t\t   struct qcom_cpufreq_drv *drv);\n\tconst char **genpd_names;\n};\n\nstruct qcom_cpufreq_drv {\n\tint *opp_tokens;\n\tu32 versions;\n\tconst struct qcom_cpufreq_match_data *data;\n};\n\nstatic struct platform_device *cpufreq_dt_pdev, *cpufreq_pdev;\n\nstatic void get_krait_bin_format_a(struct device *cpu_dev,\n\t\t\t\t\t  int *speed, int *pvs, int *pvs_ver,\n\t\t\t\t\t  u8 *buf)\n{\n\tu32 pte_efuse;\n\n\tpte_efuse = *((u32 *)buf);\n\n\t*speed = pte_efuse & 0xf;\n\tif (*speed == 0xf)\n\t\t*speed = (pte_efuse >> 4) & 0xf;\n\n\tif (*speed == 0xf) {\n\t\t*speed = 0;\n\t\tdev_warn(cpu_dev, \"Speed bin: Defaulting to %d\\n\", *speed);\n\t} else {\n\t\tdev_dbg(cpu_dev, \"Speed bin: %d\\n\", *speed);\n\t}\n\n\t*pvs = (pte_efuse >> 10) & 0x7;\n\tif (*pvs == 0x7)\n\t\t*pvs = (pte_efuse >> 13) & 0x7;\n\n\tif (*pvs == 0x7) {\n\t\t*pvs = 0;\n\t\tdev_warn(cpu_dev, \"PVS bin: Defaulting to %d\\n\", *pvs);\n\t} else {\n\t\tdev_dbg(cpu_dev, \"PVS bin: %d\\n\", *pvs);\n\t}\n}\n\nstatic void get_krait_bin_format_b(struct device *cpu_dev,\n\t\t\t\t\t  int *speed, int *pvs, int *pvs_ver,\n\t\t\t\t\t  u8 *buf)\n{\n\tu32 pte_efuse, redundant_sel;\n\n\tpte_efuse = *((u32 *)buf);\n\tredundant_sel = (pte_efuse >> 24) & 0x7;\n\n\t*pvs_ver = (pte_efuse >> 4) & 0x3;\n\n\tswitch (redundant_sel) {\n\tcase 1:\n\t\t*pvs = ((pte_efuse >> 28) & 0x8) | ((pte_efuse >> 6) & 0x7);\n\t\t*speed = (pte_efuse >> 27) & 0xf;\n\t\tbreak;\n\tcase 2:\n\t\t*pvs = (pte_efuse >> 27) & 0xf;\n\t\t*speed = pte_efuse & 0x7;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*pvs = ((pte_efuse >> 28) & 0x8) | ((pte_efuse >> 6) & 0x7);\n\t\t*speed = pte_efuse & 0x7;\n\t}\n\n\t \n\tif (pte_efuse & BIT(3)) {\n\t\tdev_dbg(cpu_dev, \"Speed bin: %d\\n\", *speed);\n\t} else {\n\t\tdev_warn(cpu_dev, \"Speed bin not set. Defaulting to 0!\\n\");\n\t\t*speed = 0;\n\t}\n\n\t \n\tpte_efuse = *(((u32 *)buf) + 1);\n\tpte_efuse &= BIT(21);\n\tif (pte_efuse) {\n\t\tdev_dbg(cpu_dev, \"PVS bin: %d\\n\", *pvs);\n\t} else {\n\t\tdev_warn(cpu_dev, \"PVS bin not set. Defaulting to 0!\\n\");\n\t\t*pvs = 0;\n\t}\n\n\tdev_dbg(cpu_dev, \"PVS version: %d\\n\", *pvs_ver);\n}\n\nstatic int qcom_cpufreq_kryo_name_version(struct device *cpu_dev,\n\t\t\t\t\t  struct nvmem_cell *speedbin_nvmem,\n\t\t\t\t\t  char **pvs_name,\n\t\t\t\t\t  struct qcom_cpufreq_drv *drv)\n{\n\tsize_t len;\n\tu32 msm_id;\n\tu8 *speedbin;\n\tint ret;\n\t*pvs_name = NULL;\n\n\tret = qcom_smem_get_soc_id(&msm_id);\n\tif (ret)\n\t\treturn ret;\n\n\tspeedbin = nvmem_cell_read(speedbin_nvmem, &len);\n\tif (IS_ERR(speedbin))\n\t\treturn PTR_ERR(speedbin);\n\n\tswitch (msm_id) {\n\tcase QCOM_ID_MSM8996:\n\tcase QCOM_ID_APQ8096:\n\t\tdrv->versions = 1 << (unsigned int)(*speedbin);\n\t\tbreak;\n\tcase QCOM_ID_MSM8996SG:\n\tcase QCOM_ID_APQ8096SG:\n\t\tdrv->versions = 1 << ((unsigned int)(*speedbin) + 4);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tkfree(speedbin);\n\treturn 0;\n}\n\nstatic int qcom_cpufreq_krait_name_version(struct device *cpu_dev,\n\t\t\t\t\t   struct nvmem_cell *speedbin_nvmem,\n\t\t\t\t\t   char **pvs_name,\n\t\t\t\t\t   struct qcom_cpufreq_drv *drv)\n{\n\tint speed = 0, pvs = 0, pvs_ver = 0;\n\tu8 *speedbin;\n\tsize_t len;\n\tint ret = 0;\n\n\tspeedbin = nvmem_cell_read(speedbin_nvmem, &len);\n\n\tif (IS_ERR(speedbin))\n\t\treturn PTR_ERR(speedbin);\n\n\tswitch (len) {\n\tcase 4:\n\t\tget_krait_bin_format_a(cpu_dev, &speed, &pvs, &pvs_ver,\n\t\t\t\t       speedbin);\n\t\tbreak;\n\tcase 8:\n\t\tget_krait_bin_format_b(cpu_dev, &speed, &pvs, &pvs_ver,\n\t\t\t\t       speedbin);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(cpu_dev, \"Unable to read nvmem data. Defaulting to 0!\\n\");\n\t\tret = -ENODEV;\n\t\tgoto len_error;\n\t}\n\n\tsnprintf(*pvs_name, sizeof(\"speedXX-pvsXX-vXX\"), \"speed%d-pvs%d-v%d\",\n\t\t speed, pvs, pvs_ver);\n\n\tdrv->versions = (1 << speed);\n\nlen_error:\n\tkfree(speedbin);\n\treturn ret;\n}\n\nstatic const struct qcom_cpufreq_match_data match_data_kryo = {\n\t.get_version = qcom_cpufreq_kryo_name_version,\n};\n\nstatic const struct qcom_cpufreq_match_data match_data_krait = {\n\t.get_version = qcom_cpufreq_krait_name_version,\n};\n\nstatic const char *qcs404_genpd_names[] = { \"cpr\", NULL };\n\nstatic const struct qcom_cpufreq_match_data match_data_qcs404 = {\n\t.genpd_names = qcs404_genpd_names,\n};\n\nstatic int qcom_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct qcom_cpufreq_drv *drv;\n\tstruct nvmem_cell *speedbin_nvmem;\n\tstruct device_node *np;\n\tstruct device *cpu_dev;\n\tchar pvs_name_buffer[] = \"speedXX-pvsXX-vXX\";\n\tchar *pvs_name = pvs_name_buffer;\n\tunsigned cpu;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tcpu_dev = get_cpu_device(0);\n\tif (!cpu_dev)\n\t\treturn -ENODEV;\n\n\tnp = dev_pm_opp_of_get_opp_desc_node(cpu_dev);\n\tif (!np)\n\t\treturn -ENOENT;\n\n\tret = of_device_is_compatible(np, \"operating-points-v2-kryo-cpu\");\n\tif (!ret) {\n\t\tof_node_put(np);\n\t\treturn -ENOENT;\n\t}\n\n\tdrv = kzalloc(sizeof(*drv), GFP_KERNEL);\n\tif (!drv)\n\t\treturn -ENOMEM;\n\n\tmatch = pdev->dev.platform_data;\n\tdrv->data = match->data;\n\tif (!drv->data) {\n\t\tret = -ENODEV;\n\t\tgoto free_drv;\n\t}\n\n\tif (drv->data->get_version) {\n\t\tspeedbin_nvmem = of_nvmem_cell_get(np, NULL);\n\t\tif (IS_ERR(speedbin_nvmem)) {\n\t\t\tret = dev_err_probe(cpu_dev, PTR_ERR(speedbin_nvmem),\n\t\t\t\t\t    \"Could not get nvmem cell\\n\");\n\t\t\tgoto free_drv;\n\t\t}\n\n\t\tret = drv->data->get_version(cpu_dev,\n\t\t\t\t\t\t\tspeedbin_nvmem, &pvs_name, drv);\n\t\tif (ret) {\n\t\t\tnvmem_cell_put(speedbin_nvmem);\n\t\t\tgoto free_drv;\n\t\t}\n\t\tnvmem_cell_put(speedbin_nvmem);\n\t}\n\tof_node_put(np);\n\n\tdrv->opp_tokens = kcalloc(num_possible_cpus(), sizeof(*drv->opp_tokens),\n\t\t\t\t  GFP_KERNEL);\n\tif (!drv->opp_tokens) {\n\t\tret = -ENOMEM;\n\t\tgoto free_drv;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct dev_pm_opp_config config = {\n\t\t\t.supported_hw = NULL,\n\t\t};\n\n\t\tcpu_dev = get_cpu_device(cpu);\n\t\tif (NULL == cpu_dev) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto free_opp;\n\t\t}\n\n\t\tif (drv->data->get_version) {\n\t\t\tconfig.supported_hw = &drv->versions;\n\t\t\tconfig.supported_hw_count = 1;\n\n\t\t\tif (pvs_name)\n\t\t\t\tconfig.prop_name = pvs_name;\n\t\t}\n\n\t\tif (drv->data->genpd_names) {\n\t\t\tconfig.genpd_names = drv->data->genpd_names;\n\t\t\tconfig.virt_devs = NULL;\n\t\t}\n\n\t\tif (config.supported_hw || config.genpd_names) {\n\t\t\tdrv->opp_tokens[cpu] = dev_pm_opp_set_config(cpu_dev, &config);\n\t\t\tif (drv->opp_tokens[cpu] < 0) {\n\t\t\t\tret = drv->opp_tokens[cpu];\n\t\t\t\tdev_err(cpu_dev, \"Failed to set OPP config\\n\");\n\t\t\t\tgoto free_opp;\n\t\t\t}\n\t\t}\n\t}\n\n\tcpufreq_dt_pdev = platform_device_register_simple(\"cpufreq-dt\", -1,\n\t\t\t\t\t\t\t  NULL, 0);\n\tif (!IS_ERR(cpufreq_dt_pdev)) {\n\t\tplatform_set_drvdata(pdev, drv);\n\t\treturn 0;\n\t}\n\n\tret = PTR_ERR(cpufreq_dt_pdev);\n\tdev_err(cpu_dev, \"Failed to register platform device\\n\");\n\nfree_opp:\n\tfor_each_possible_cpu(cpu)\n\t\tdev_pm_opp_clear_config(drv->opp_tokens[cpu]);\n\tkfree(drv->opp_tokens);\nfree_drv:\n\tkfree(drv);\n\n\treturn ret;\n}\n\nstatic void qcom_cpufreq_remove(struct platform_device *pdev)\n{\n\tstruct qcom_cpufreq_drv *drv = platform_get_drvdata(pdev);\n\tunsigned int cpu;\n\n\tplatform_device_unregister(cpufreq_dt_pdev);\n\n\tfor_each_possible_cpu(cpu)\n\t\tdev_pm_opp_clear_config(drv->opp_tokens[cpu]);\n\n\tkfree(drv->opp_tokens);\n\tkfree(drv);\n}\n\nstatic struct platform_driver qcom_cpufreq_driver = {\n\t.probe = qcom_cpufreq_probe,\n\t.remove_new = qcom_cpufreq_remove,\n\t.driver = {\n\t\t.name = \"qcom-cpufreq-nvmem\",\n\t},\n};\n\nstatic const struct of_device_id qcom_cpufreq_match_list[] __initconst = {\n\t{ .compatible = \"qcom,apq8096\", .data = &match_data_kryo },\n\t{ .compatible = \"qcom,msm8996\", .data = &match_data_kryo },\n\t{ .compatible = \"qcom,qcs404\", .data = &match_data_qcs404 },\n\t{ .compatible = \"qcom,ipq8064\", .data = &match_data_krait },\n\t{ .compatible = \"qcom,apq8064\", .data = &match_data_krait },\n\t{ .compatible = \"qcom,msm8974\", .data = &match_data_krait },\n\t{ .compatible = \"qcom,msm8960\", .data = &match_data_krait },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, qcom_cpufreq_match_list);\n\n \nstatic int __init qcom_cpufreq_init(void)\n{\n\tstruct device_node *np = of_find_node_by_path(\"/\");\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tmatch = of_match_node(qcom_cpufreq_match_list, np);\n\tof_node_put(np);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tret = platform_driver_register(&qcom_cpufreq_driver);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tcpufreq_pdev = platform_device_register_data(NULL, \"qcom-cpufreq-nvmem\",\n\t\t\t\t\t\t     -1, match, sizeof(*match));\n\tret = PTR_ERR_OR_ZERO(cpufreq_pdev);\n\tif (0 == ret)\n\t\treturn 0;\n\n\tplatform_driver_unregister(&qcom_cpufreq_driver);\n\treturn ret;\n}\nmodule_init(qcom_cpufreq_init);\n\nstatic void __exit qcom_cpufreq_exit(void)\n{\n\tplatform_device_unregister(cpufreq_pdev);\n\tplatform_driver_unregister(&qcom_cpufreq_driver);\n}\nmodule_exit(qcom_cpufreq_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm Technologies, Inc. CPUfreq driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}