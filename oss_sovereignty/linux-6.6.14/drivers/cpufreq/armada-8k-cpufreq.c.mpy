{
  "module_name": "armada-8k-cpufreq.c",
  "hash_id": "a695462e522f62f83d7493494277bd48d4d685172d8ac8c1cd6f8fea79d07a65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/armada-8k-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n\nstatic const struct of_device_id __maybe_unused armada_8k_cpufreq_of_match[] = {\n\t{ .compatible = \"marvell,ap806-cpu-clock\" },\n\t{ .compatible = \"marvell,ap807-cpu-clock\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, armada_8k_cpufreq_of_match);\n\n \nstatic const int opps_div[] __initconst = {1, 2, 3, 4};\n\nstatic struct platform_device *armada_8k_pdev;\n\nstruct freq_table {\n\tstruct device *cpu_dev;\n\tunsigned int freq[ARRAY_SIZE(opps_div)];\n};\n\n \nstatic void __init armada_8k_get_sharing_cpus(struct clk *cur_clk,\n\t\t\t\t\t      struct cpumask *cpumask)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct device *cpu_dev;\n\t\tstruct clk *clk;\n\n\t\tcpu_dev = get_cpu_device(cpu);\n\t\tif (!cpu_dev) {\n\t\t\tpr_warn(\"Failed to get cpu%d device\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclk = clk_get(cpu_dev, 0);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_warn(\"Cannot get clock for CPU %d\\n\", cpu);\n\t\t} else {\n\t\t\tif (clk_is_match(clk, cur_clk))\n\t\t\t\tcpumask_set_cpu(cpu, cpumask);\n\n\t\t\tclk_put(clk);\n\t\t}\n\t}\n}\n\nstatic int __init armada_8k_add_opp(struct clk *clk, struct device *cpu_dev,\n\t\t\t\t    struct freq_table *freq_tables,\n\t\t\t\t    int opps_index)\n{\n\tunsigned int cur_frequency;\n\tunsigned int freq;\n\tint i, ret;\n\n\t \n\tcur_frequency = clk_get_rate(clk);\n\tif (!cur_frequency) {\n\t\tdev_err(cpu_dev, \"Failed to get clock rate for this CPU\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfreq_tables[opps_index].cpu_dev = cpu_dev;\n\n\tfor (i = 0; i < ARRAY_SIZE(opps_div); i++) {\n\t\tfreq = cur_frequency / opps_div[i];\n\n\t\tret = dev_pm_opp_add(cpu_dev, freq, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfreq_tables[opps_index].freq[i] = freq;\n\t}\n\n\treturn 0;\n}\n\nstatic void armada_8k_cpufreq_free_table(struct freq_table *freq_tables)\n{\n\tint opps_index, nb_cpus = num_possible_cpus();\n\n\tfor (opps_index = 0 ; opps_index <= nb_cpus; opps_index++) {\n\t\tint i;\n\n\t\t \n\t\tif (!freq_tables[opps_index].cpu_dev)\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(opps_div); i++) {\n\t\t\t \n\t\t\tif (freq_tables[opps_index].freq[i] == 0)\n\t\t\t\tbreak;\n\n\t\t\tdev_pm_opp_remove(freq_tables[opps_index].cpu_dev,\n\t\t\t\t\t  freq_tables[opps_index].freq[i]);\n\t\t}\n\t}\n\n\tkfree(freq_tables);\n}\n\nstatic int __init armada_8k_cpufreq_init(void)\n{\n\tint ret = 0, opps_index = 0, cpu, nb_cpus;\n\tstruct freq_table *freq_tables;\n\tstruct device_node *node;\n\tstruct cpumask cpus;\n\n\tnode = of_find_matching_node_and_match(NULL, armada_8k_cpufreq_of_match,\n\t\t\t\t\t       NULL);\n\tif (!node || !of_device_is_available(node)) {\n\t\tof_node_put(node);\n\t\treturn -ENODEV;\n\t}\n\tof_node_put(node);\n\n\tnb_cpus = num_possible_cpus();\n\tfreq_tables = kcalloc(nb_cpus, sizeof(*freq_tables), GFP_KERNEL);\n\tif (!freq_tables)\n\t\treturn -ENOMEM;\n\tcpumask_copy(&cpus, cpu_possible_mask);\n\n\t \n\tfor_each_cpu(cpu, &cpus) {\n\t\tstruct cpumask shared_cpus;\n\t\tstruct device *cpu_dev;\n\t\tstruct clk *clk;\n\n\t\tcpu_dev = get_cpu_device(cpu);\n\n\t\tif (!cpu_dev) {\n\t\t\tpr_err(\"Cannot get CPU %d\\n\", cpu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tclk = clk_get(cpu_dev, 0);\n\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"Cannot get clock for CPU %d\\n\", cpu);\n\t\t\tret = PTR_ERR(clk);\n\t\t\tgoto remove_opp;\n\t\t}\n\n\t\tret = armada_8k_add_opp(clk, cpu_dev, freq_tables, opps_index);\n\t\tif (ret) {\n\t\t\tclk_put(clk);\n\t\t\tgoto remove_opp;\n\t\t}\n\n\t\topps_index++;\n\t\tcpumask_clear(&shared_cpus);\n\t\tarmada_8k_get_sharing_cpus(clk, &shared_cpus);\n\t\tdev_pm_opp_set_sharing_cpus(cpu_dev, &shared_cpus);\n\t\tcpumask_andnot(&cpus, &cpus, &shared_cpus);\n\t\tclk_put(clk);\n\t}\n\n\tarmada_8k_pdev = platform_device_register_simple(\"cpufreq-dt\", -1,\n\t\t\t\t\t\t\t NULL, 0);\n\tret = PTR_ERR_OR_ZERO(armada_8k_pdev);\n\tif (ret)\n\t\tgoto remove_opp;\n\n\tplatform_set_drvdata(armada_8k_pdev, freq_tables);\n\n\treturn 0;\n\nremove_opp:\n\tarmada_8k_cpufreq_free_table(freq_tables);\n\treturn ret;\n}\nmodule_init(armada_8k_cpufreq_init);\n\nstatic void __exit armada_8k_cpufreq_exit(void)\n{\n\tstruct freq_table *freq_tables = platform_get_drvdata(armada_8k_pdev);\n\n\tplatform_device_unregister(armada_8k_pdev);\n\tarmada_8k_cpufreq_free_table(freq_tables);\n}\nmodule_exit(armada_8k_cpufreq_exit);\n\nMODULE_AUTHOR(\"Gregory Clement <gregory.clement@bootlin.com>\");\nMODULE_DESCRIPTION(\"Armada 8K cpufreq driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}