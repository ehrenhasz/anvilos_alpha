{
  "module_name": "tegra194-cpufreq.c",
  "hash_id": "b689d6693d9d8f9cb48dc7feaf5fa425d2a84276db2f702b2f26b212d1b47a9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/tegra194-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/units.h>\n\n#include <asm/smp_plat.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\n#define KHZ                     1000\n#define REF_CLK_MHZ             408  \n#define US_DELAY                500\n#define CPUFREQ_TBL_STEP_HZ     (50 * KHZ * KHZ)\n#define MAX_CNT                 ~0U\n\n#define NDIV_MASK              0x1FF\n\n#define CORE_OFFSET(cpu)\t\t\t(cpu * 8)\n#define CMU_CLKS_BASE\t\t\t\t0x2000\n#define SCRATCH_FREQ_CORE_REG(data, cpu)\t(data->regs + CMU_CLKS_BASE + CORE_OFFSET(cpu))\n\n#define MMCRAB_CLUSTER_BASE(cl)\t\t\t(0x30000 + (cl * 0x10000))\n#define CLUSTER_ACTMON_BASE(data, cl) \\\n\t\t\t(data->regs + (MMCRAB_CLUSTER_BASE(cl) + data->soc->actmon_cntr_base))\n#define CORE_ACTMON_CNTR_REG(data, cl, cpu)\t(CLUSTER_ACTMON_BASE(data, cl) + CORE_OFFSET(cpu))\n\n \n#define TEGRA_CPUFREQ_TRANSITION_LATENCY (300 * 1000)  \n\nstruct tegra_cpu_ctr {\n\tu32 cpu;\n\tu32 coreclk_cnt, last_coreclk_cnt;\n\tu32 refclk_cnt, last_refclk_cnt;\n};\n\nstruct read_counters_work {\n\tstruct work_struct work;\n\tstruct tegra_cpu_ctr c;\n};\n\nstruct tegra_cpufreq_ops {\n\tvoid (*read_counters)(struct tegra_cpu_ctr *c);\n\tvoid (*set_cpu_ndiv)(struct cpufreq_policy *policy, u64 ndiv);\n\tvoid (*get_cpu_cluster_id)(u32 cpu, u32 *cpuid, u32 *clusterid);\n\tint (*get_cpu_ndiv)(u32 cpu, u32 cpuid, u32 clusterid, u64 *ndiv);\n};\n\nstruct tegra_cpufreq_soc {\n\tstruct tegra_cpufreq_ops *ops;\n\tint maxcpus_per_cluster;\n\tunsigned int num_clusters;\n\tphys_addr_t actmon_cntr_base;\n};\n\nstruct tegra194_cpufreq_data {\n\tvoid __iomem *regs;\n\tstruct cpufreq_frequency_table **bpmp_luts;\n\tconst struct tegra_cpufreq_soc *soc;\n\tbool icc_dram_bw_scaling;\n};\n\nstatic struct workqueue_struct *read_counters_wq;\n\nstatic int tegra_cpufreq_set_bw(struct cpufreq_policy *policy, unsigned long freq_khz)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct dev_pm_opp *opp;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = get_cpu_device(policy->cpu);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\topp = dev_pm_opp_find_freq_exact(dev, freq_khz * KHZ, true);\n\tif (IS_ERR(opp))\n\t\treturn PTR_ERR(opp);\n\n\tret = dev_pm_opp_set_opp(dev, opp);\n\tif (ret)\n\t\tdata->icc_dram_bw_scaling = false;\n\n\tdev_pm_opp_put(opp);\n\treturn ret;\n}\n\nstatic void tegra_get_cpu_mpidr(void *mpidr)\n{\n\t*((u64 *)mpidr) = read_cpuid_mpidr() & MPIDR_HWID_BITMASK;\n}\n\nstatic void tegra234_get_cpu_cluster_id(u32 cpu, u32 *cpuid, u32 *clusterid)\n{\n\tu64 mpidr;\n\n\tsmp_call_function_single(cpu, tegra_get_cpu_mpidr, &mpidr, true);\n\n\tif (cpuid)\n\t\t*cpuid = MPIDR_AFFINITY_LEVEL(mpidr, 1);\n\tif (clusterid)\n\t\t*clusterid = MPIDR_AFFINITY_LEVEL(mpidr, 2);\n}\n\nstatic int tegra234_get_cpu_ndiv(u32 cpu, u32 cpuid, u32 clusterid, u64 *ndiv)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tvoid __iomem *freq_core_reg;\n\tu64 mpidr_id;\n\n\t \n\tmpidr_id = (clusterid * data->soc->maxcpus_per_cluster) + cpuid;\n\tfreq_core_reg = SCRATCH_FREQ_CORE_REG(data, mpidr_id);\n\n\t*ndiv = readl(freq_core_reg) & NDIV_MASK;\n\n\treturn 0;\n}\n\nstatic void tegra234_set_cpu_ndiv(struct cpufreq_policy *policy, u64 ndiv)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tvoid __iomem *freq_core_reg;\n\tu32 cpu, cpuid, clusterid;\n\tu64 mpidr_id;\n\n\tfor_each_cpu_and(cpu, policy->cpus, cpu_online_mask) {\n\t\tdata->soc->ops->get_cpu_cluster_id(cpu, &cpuid, &clusterid);\n\n\t\t \n\t\tmpidr_id = (clusterid * data->soc->maxcpus_per_cluster) + cpuid;\n\t\tfreq_core_reg = SCRATCH_FREQ_CORE_REG(data, mpidr_id);\n\n\t\twritel(ndiv, freq_core_reg);\n\t}\n}\n\n \nstatic void tegra234_read_counters(struct tegra_cpu_ctr *c)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tvoid __iomem *actmon_reg;\n\tu32 cpuid, clusterid;\n\tu64 val;\n\n\tdata->soc->ops->get_cpu_cluster_id(c->cpu, &cpuid, &clusterid);\n\tactmon_reg = CORE_ACTMON_CNTR_REG(data, clusterid, cpuid);\n\n\tval = readq(actmon_reg);\n\tc->last_refclk_cnt = upper_32_bits(val);\n\tc->last_coreclk_cnt = lower_32_bits(val);\n\tudelay(US_DELAY);\n\tval = readq(actmon_reg);\n\tc->refclk_cnt = upper_32_bits(val);\n\tc->coreclk_cnt = lower_32_bits(val);\n}\n\nstatic struct tegra_cpufreq_ops tegra234_cpufreq_ops = {\n\t.read_counters = tegra234_read_counters,\n\t.get_cpu_cluster_id = tegra234_get_cpu_cluster_id,\n\t.get_cpu_ndiv = tegra234_get_cpu_ndiv,\n\t.set_cpu_ndiv = tegra234_set_cpu_ndiv,\n};\n\nstatic const struct tegra_cpufreq_soc tegra234_cpufreq_soc = {\n\t.ops = &tegra234_cpufreq_ops,\n\t.actmon_cntr_base = 0x9000,\n\t.maxcpus_per_cluster = 4,\n\t.num_clusters = 3,\n};\n\nstatic const struct tegra_cpufreq_soc tegra239_cpufreq_soc = {\n\t.ops = &tegra234_cpufreq_ops,\n\t.actmon_cntr_base = 0x4000,\n\t.maxcpus_per_cluster = 8,\n\t.num_clusters = 1,\n};\n\nstatic void tegra194_get_cpu_cluster_id(u32 cpu, u32 *cpuid, u32 *clusterid)\n{\n\tu64 mpidr;\n\n\tsmp_call_function_single(cpu, tegra_get_cpu_mpidr, &mpidr, true);\n\n\tif (cpuid)\n\t\t*cpuid = MPIDR_AFFINITY_LEVEL(mpidr, 0);\n\tif (clusterid)\n\t\t*clusterid = MPIDR_AFFINITY_LEVEL(mpidr, 1);\n}\n\n \nstatic u64 read_freq_feedback(void)\n{\n\tu64 val = 0;\n\n\tasm volatile(\"mrs %0, s3_0_c15_c0_5\" : \"=r\" (val) : );\n\n\treturn val;\n}\n\nstatic inline u32 map_ndiv_to_freq(struct mrq_cpu_ndiv_limits_response\n\t\t\t\t   *nltbl, u16 ndiv)\n{\n\treturn nltbl->ref_clk_hz / KHZ * ndiv / (nltbl->pdiv * nltbl->mdiv);\n}\n\nstatic void tegra194_read_counters(struct tegra_cpu_ctr *c)\n{\n\tu64 val;\n\n\tval = read_freq_feedback();\n\tc->last_refclk_cnt = lower_32_bits(val);\n\tc->last_coreclk_cnt = upper_32_bits(val);\n\tudelay(US_DELAY);\n\tval = read_freq_feedback();\n\tc->refclk_cnt = lower_32_bits(val);\n\tc->coreclk_cnt = upper_32_bits(val);\n}\n\nstatic void tegra_read_counters(struct work_struct *work)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct read_counters_work *read_counters_work;\n\tstruct tegra_cpu_ctr *c;\n\n\t \n\tread_counters_work = container_of(work, struct read_counters_work,\n\t\t\t\t\t  work);\n\tc = &read_counters_work->c;\n\n\tdata->soc->ops->read_counters(c);\n}\n\n \nstatic unsigned int tegra194_calculate_speed(u32 cpu)\n{\n\tstruct read_counters_work read_counters_work;\n\tstruct tegra_cpu_ctr c;\n\tu32 delta_refcnt;\n\tu32 delta_ccnt;\n\tu32 rate_mhz;\n\n\t \n\tread_counters_work.c.cpu = cpu;\n\tINIT_WORK_ONSTACK(&read_counters_work.work, tegra_read_counters);\n\tqueue_work_on(cpu, read_counters_wq, &read_counters_work.work);\n\tflush_work(&read_counters_work.work);\n\tc = read_counters_work.c;\n\n\tif (c.coreclk_cnt < c.last_coreclk_cnt)\n\t\tdelta_ccnt = c.coreclk_cnt + (MAX_CNT - c.last_coreclk_cnt);\n\telse\n\t\tdelta_ccnt = c.coreclk_cnt - c.last_coreclk_cnt;\n\tif (!delta_ccnt)\n\t\treturn 0;\n\n\t \n\tif (c.refclk_cnt < c.last_refclk_cnt)\n\t\tdelta_refcnt = c.refclk_cnt + (MAX_CNT - c.last_refclk_cnt);\n\telse\n\t\tdelta_refcnt = c.refclk_cnt - c.last_refclk_cnt;\n\tif (!delta_refcnt) {\n\t\tpr_debug(\"cpufreq: %d is idle, delta_refcnt: 0\\n\", cpu);\n\t\treturn 0;\n\t}\n\trate_mhz = ((unsigned long)(delta_ccnt * REF_CLK_MHZ)) / delta_refcnt;\n\n\treturn (rate_mhz * KHZ);  \n}\n\nstatic void tegra194_get_cpu_ndiv_sysreg(void *ndiv)\n{\n\tu64 ndiv_val;\n\n\tasm volatile(\"mrs %0, s3_0_c15_c0_4\" : \"=r\" (ndiv_val) : );\n\n\t*(u64 *)ndiv = ndiv_val;\n}\n\nstatic int tegra194_get_cpu_ndiv(u32 cpu, u32 cpuid, u32 clusterid, u64 *ndiv)\n{\n\treturn smp_call_function_single(cpu, tegra194_get_cpu_ndiv_sysreg, &ndiv, true);\n}\n\nstatic void tegra194_set_cpu_ndiv_sysreg(void *data)\n{\n\tu64 ndiv_val = *(u64 *)data;\n\n\tasm volatile(\"msr s3_0_c15_c0_4, %0\" : : \"r\" (ndiv_val));\n}\n\nstatic void tegra194_set_cpu_ndiv(struct cpufreq_policy *policy, u64 ndiv)\n{\n\ton_each_cpu_mask(policy->cpus, tegra194_set_cpu_ndiv_sysreg, &ndiv, true);\n}\n\nstatic unsigned int tegra194_get_speed(u32 cpu)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct cpufreq_frequency_table *pos;\n\tu32 cpuid, clusterid;\n\tunsigned int rate;\n\tu64 ndiv;\n\tint ret;\n\n\tdata->soc->ops->get_cpu_cluster_id(cpu, &cpuid, &clusterid);\n\n\t \n\trate = tegra194_calculate_speed(cpu);\n\n\t \n\tret = data->soc->ops->get_cpu_ndiv(cpu, cpuid, clusterid, &ndiv);\n\tif (WARN_ON_ONCE(ret))\n\t\treturn rate;\n\n\t \n\tcpufreq_for_each_valid_entry(pos, data->bpmp_luts[clusterid]) {\n\t\tif (pos->driver_data != ndiv)\n\t\t\tcontinue;\n\n\t\tif (abs(pos->frequency - rate) > 115200) {\n\t\t\tpr_warn(\"cpufreq: cpu%d,cur:%u,set:%u,set ndiv:%llu\\n\",\n\t\t\t\tcpu, rate, pos->frequency, ndiv);\n\t\t} else {\n\t\t\trate = pos->frequency;\n\t\t}\n\t\tbreak;\n\t}\n\treturn rate;\n}\n\nstatic int tegra_cpufreq_init_cpufreq_table(struct cpufreq_policy *policy,\n\t\t\t\t\t    struct cpufreq_frequency_table *bpmp_lut,\n\t\t\t\t\t    struct cpufreq_frequency_table **opp_table)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct cpufreq_frequency_table *freq_table = NULL;\n\tstruct cpufreq_frequency_table *pos;\n\tstruct device *cpu_dev;\n\tstruct dev_pm_opp *opp;\n\tunsigned long rate;\n\tint ret, max_opps;\n\tint j = 0;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"%s: failed to get cpu%d device\\n\", __func__, policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tret = dev_pm_opp_of_add_table_indexed(cpu_dev, 0);\n\tif (!ret) {\n\t\tmax_opps = dev_pm_opp_get_opp_count(cpu_dev);\n\t\tif (max_opps <= 0) {\n\t\t\tdev_err(cpu_dev, \"Failed to add OPPs\\n\");\n\t\t\treturn max_opps;\n\t\t}\n\n\t\t \n\t\tfor (rate = 0; ; rate++) {\n\t\t\topp = dev_pm_opp_find_freq_ceil(cpu_dev, &rate);\n\t\t\tif (IS_ERR(opp))\n\t\t\t\tbreak;\n\n\t\t\tdev_pm_opp_put(opp);\n\t\t\tdev_pm_opp_disable(cpu_dev, rate);\n\t\t}\n\t} else {\n\t\tdev_err(cpu_dev, \"Invalid or empty opp table in device tree\\n\");\n\t\tdata->icc_dram_bw_scaling = false;\n\t\treturn ret;\n\t}\n\n\tfreq_table = kcalloc((max_opps + 1), sizeof(*freq_table), GFP_KERNEL);\n\tif (!freq_table)\n\t\treturn -ENOMEM;\n\n\t \n\tcpufreq_for_each_valid_entry(pos, bpmp_lut) {\n\t\topp = dev_pm_opp_find_freq_exact(cpu_dev, pos->frequency * KHZ, false);\n\t\tif (IS_ERR(opp))\n\t\t\tcontinue;\n\n\t\tdev_pm_opp_put(opp);\n\n\t\tret = dev_pm_opp_enable(cpu_dev, pos->frequency * KHZ);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tfreq_table[j].driver_data = pos->driver_data;\n\t\tfreq_table[j].frequency = pos->frequency;\n\t\tj++;\n\t}\n\n\tfreq_table[j].driver_data = pos->driver_data;\n\tfreq_table[j].frequency = CPUFREQ_TABLE_END;\n\n\t*opp_table = &freq_table[0];\n\n\tdev_pm_opp_set_sharing_cpus(cpu_dev, policy->cpus);\n\n\treturn ret;\n}\n\nstatic int tegra194_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\tint maxcpus_per_cluster = data->soc->maxcpus_per_cluster;\n\tstruct cpufreq_frequency_table *freq_table;\n\tstruct cpufreq_frequency_table *bpmp_lut;\n\tu32 start_cpu, cpu;\n\tu32 clusterid;\n\tint ret;\n\n\tdata->soc->ops->get_cpu_cluster_id(policy->cpu, NULL, &clusterid);\n\tif (clusterid >= data->soc->num_clusters || !data->bpmp_luts[clusterid])\n\t\treturn -EINVAL;\n\n\tstart_cpu = rounddown(policy->cpu, maxcpus_per_cluster);\n\t \n\tfor (cpu = start_cpu; cpu < (start_cpu + maxcpus_per_cluster); cpu++) {\n\t\tif (cpu_possible(cpu))\n\t\t\tcpumask_set_cpu(cpu, policy->cpus);\n\t}\n\tpolicy->cpuinfo.transition_latency = TEGRA_CPUFREQ_TRANSITION_LATENCY;\n\n\tbpmp_lut = data->bpmp_luts[clusterid];\n\n\tif (data->icc_dram_bw_scaling) {\n\t\tret = tegra_cpufreq_init_cpufreq_table(policy, bpmp_lut, &freq_table);\n\t\tif (!ret) {\n\t\t\tpolicy->freq_table = freq_table;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdata->icc_dram_bw_scaling = false;\n\tpolicy->freq_table = bpmp_lut;\n\tpr_info(\"OPP tables missing from DT, EMC frequency scaling disabled\\n\");\n\n\treturn 0;\n}\n\nstatic int tegra194_cpufreq_online(struct cpufreq_policy *policy)\n{\n\t \n\treturn 0;\n}\n\nstatic int tegra194_cpufreq_offline(struct cpufreq_policy *policy)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int tegra194_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct device *cpu_dev = get_cpu_device(policy->cpu);\n\n\tdev_pm_opp_remove_all_dynamic(cpu_dev);\n\tdev_pm_opp_of_cpumask_remove_table(policy->related_cpus);\n\n\treturn 0;\n}\n\nstatic int tegra194_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t       unsigned int index)\n{\n\tstruct cpufreq_frequency_table *tbl = policy->freq_table + index;\n\tstruct tegra194_cpufreq_data *data = cpufreq_get_driver_data();\n\n\t \n\tdata->soc->ops->set_cpu_ndiv(policy, (u64)tbl->driver_data);\n\n\tif (data->icc_dram_bw_scaling)\n\t\ttegra_cpufreq_set_bw(policy, tbl->frequency);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver tegra194_cpufreq_driver = {\n\t.name = \"tegra194\",\n\t.flags = CPUFREQ_CONST_LOOPS | CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t CPUFREQ_IS_COOLING_DEV,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = tegra194_cpufreq_set_target,\n\t.get = tegra194_get_speed,\n\t.init = tegra194_cpufreq_init,\n\t.exit = tegra194_cpufreq_exit,\n\t.online = tegra194_cpufreq_online,\n\t.offline = tegra194_cpufreq_offline,\n\t.attr = cpufreq_generic_attr,\n};\n\nstatic struct tegra_cpufreq_ops tegra194_cpufreq_ops = {\n\t.read_counters = tegra194_read_counters,\n\t.get_cpu_cluster_id = tegra194_get_cpu_cluster_id,\n\t.get_cpu_ndiv = tegra194_get_cpu_ndiv,\n\t.set_cpu_ndiv = tegra194_set_cpu_ndiv,\n};\n\nstatic const struct tegra_cpufreq_soc tegra194_cpufreq_soc = {\n\t.ops = &tegra194_cpufreq_ops,\n\t.maxcpus_per_cluster = 2,\n\t.num_clusters = 4,\n};\n\nstatic void tegra194_cpufreq_free_resources(void)\n{\n\tdestroy_workqueue(read_counters_wq);\n}\n\nstatic struct cpufreq_frequency_table *\ntegra_cpufreq_bpmp_read_lut(struct platform_device *pdev, struct tegra_bpmp *bpmp,\n\t\t\t    unsigned int cluster_id)\n{\n\tstruct cpufreq_frequency_table *freq_table;\n\tstruct mrq_cpu_ndiv_limits_response resp;\n\tunsigned int num_freqs, ndiv, delta_ndiv;\n\tstruct mrq_cpu_ndiv_limits_request req;\n\tstruct tegra_bpmp_message msg;\n\tu16 freq_table_step_size;\n\tint err, index;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.cluster_id = cluster_id;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_CPU_NDIV_LIMITS;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\tmsg.rx.data = &resp;\n\tmsg.rx.size = sizeof(resp);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\tif (msg.rx.ret == -BPMP_EINVAL) {\n\t\t \n\t\treturn NULL;\n\t}\n\tif (msg.rx.ret)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tfreq_table_step_size = resp.mdiv *\n\t\t\tDIV_ROUND_UP(CPUFREQ_TBL_STEP_HZ, resp.ref_clk_hz);\n\n\tdev_dbg(&pdev->dev, \"cluster %d: frequency table step size: %d\\n\",\n\t\tcluster_id, freq_table_step_size);\n\n\tdelta_ndiv = resp.ndiv_max - resp.ndiv_min;\n\n\tif (unlikely(delta_ndiv == 0)) {\n\t\tnum_freqs = 1;\n\t} else {\n\t\t \n\t\tnum_freqs = delta_ndiv / freq_table_step_size + 1;\n\t}\n\n\tnum_freqs += (delta_ndiv % freq_table_step_size) ? 1 : 0;\n\n\tfreq_table = devm_kcalloc(&pdev->dev, num_freqs + 1,\n\t\t\t\t  sizeof(*freq_table), GFP_KERNEL);\n\tif (!freq_table)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (index = 0, ndiv = resp.ndiv_min;\n\t\t\tndiv < resp.ndiv_max;\n\t\t\tindex++, ndiv += freq_table_step_size) {\n\t\tfreq_table[index].driver_data = ndiv;\n\t\tfreq_table[index].frequency = map_ndiv_to_freq(&resp, ndiv);\n\t}\n\n\tfreq_table[index].driver_data = resp.ndiv_max;\n\tfreq_table[index++].frequency = map_ndiv_to_freq(&resp, resp.ndiv_max);\n\tfreq_table[index].frequency = CPUFREQ_TABLE_END;\n\n\treturn freq_table;\n}\n\nstatic int tegra194_cpufreq_probe(struct platform_device *pdev)\n{\n\tconst struct tegra_cpufreq_soc *soc;\n\tstruct tegra194_cpufreq_data *data;\n\tstruct tegra_bpmp *bpmp;\n\tstruct device *cpu_dev;\n\tint err, i;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsoc = of_device_get_match_data(&pdev->dev);\n\n\tif (soc->ops && soc->maxcpus_per_cluster && soc->num_clusters) {\n\t\tdata->soc = soc;\n\t} else {\n\t\tdev_err(&pdev->dev, \"soc data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->bpmp_luts = devm_kcalloc(&pdev->dev, data->soc->num_clusters,\n\t\t\t\t       sizeof(*data->bpmp_luts), GFP_KERNEL);\n\tif (!data->bpmp_luts)\n\t\treturn -ENOMEM;\n\n\tif (soc->actmon_cntr_base) {\n\t\t \n\t\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\t\tif (IS_ERR(data->regs))\n\t\t\treturn PTR_ERR(data->regs);\n\t}\n\n\tplatform_set_drvdata(pdev, data);\n\n\tbpmp = tegra_bpmp_get(&pdev->dev);\n\tif (IS_ERR(bpmp))\n\t\treturn PTR_ERR(bpmp);\n\n\tread_counters_wq = alloc_workqueue(\"read_counters_wq\", __WQ_LEGACY, 1);\n\tif (!read_counters_wq) {\n\t\tdev_err(&pdev->dev, \"fail to create_workqueue\\n\");\n\t\terr = -EINVAL;\n\t\tgoto put_bpmp;\n\t}\n\n\tfor (i = 0; i < data->soc->num_clusters; i++) {\n\t\tdata->bpmp_luts[i] = tegra_cpufreq_bpmp_read_lut(pdev, bpmp, i);\n\t\tif (IS_ERR(data->bpmp_luts[i])) {\n\t\t\terr = PTR_ERR(data->bpmp_luts[i]);\n\t\t\tgoto err_free_res;\n\t\t}\n\t}\n\n\ttegra194_cpufreq_driver.driver_data = data;\n\n\t \n\tcpu_dev = get_cpu_device(0);\n\tif (!cpu_dev) {\n\t\terr = -EPROBE_DEFER;\n\t\tgoto err_free_res;\n\t}\n\n\tif (dev_pm_opp_of_get_opp_desc_node(cpu_dev)) {\n\t\terr = dev_pm_opp_of_find_icc_paths(cpu_dev, NULL);\n\t\tif (!err)\n\t\t\tdata->icc_dram_bw_scaling = true;\n\t}\n\n\terr = cpufreq_register_driver(&tegra194_cpufreq_driver);\n\tif (!err)\n\t\tgoto put_bpmp;\n\nerr_free_res:\n\ttegra194_cpufreq_free_resources();\nput_bpmp:\n\ttegra_bpmp_put(bpmp);\n\treturn err;\n}\n\nstatic void tegra194_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&tegra194_cpufreq_driver);\n\ttegra194_cpufreq_free_resources();\n}\n\nstatic const struct of_device_id tegra194_cpufreq_of_match[] = {\n\t{ .compatible = \"nvidia,tegra194-ccplex\", .data = &tegra194_cpufreq_soc },\n\t{ .compatible = \"nvidia,tegra234-ccplex-cluster\", .data = &tegra234_cpufreq_soc },\n\t{ .compatible = \"nvidia,tegra239-ccplex-cluster\", .data = &tegra239_cpufreq_soc },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, tegra194_cpufreq_of_match);\n\nstatic struct platform_driver tegra194_ccplex_driver = {\n\t.driver = {\n\t\t.name = \"tegra194-cpufreq\",\n\t\t.of_match_table = tegra194_cpufreq_of_match,\n\t},\n\t.probe = tegra194_cpufreq_probe,\n\t.remove_new = tegra194_cpufreq_remove,\n};\nmodule_platform_driver(tegra194_ccplex_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_AUTHOR(\"Sumit Gupta <sumitg@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra194 cpufreq driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}