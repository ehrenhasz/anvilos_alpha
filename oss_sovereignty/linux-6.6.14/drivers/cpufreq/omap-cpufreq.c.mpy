{
  "module_name": "omap-cpufreq.c",
  "hash_id": "9efeb11604db9ad458f3d97a078c0332fef613caf61e7ff71d53900dbf5d8db0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/omap-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/pm_opp.h>\n#include <linux/cpu.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include <asm/smp_plat.h>\n#include <asm/cpu.h>\n\n \n#define\tOPP_TOLERANCE\t4\n\nstatic struct cpufreq_frequency_table *freq_table;\nstatic atomic_t freq_table_users = ATOMIC_INIT(0);\nstatic struct device *mpu_dev;\nstatic struct regulator *mpu_reg;\n\nstatic int omap_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tint r, ret;\n\tstruct dev_pm_opp *opp;\n\tunsigned long freq, volt = 0, volt_old = 0, tol = 0;\n\tunsigned int old_freq, new_freq;\n\n\told_freq = policy->cur;\n\tnew_freq = freq_table[index].frequency;\n\n\tfreq = new_freq * 1000;\n\tret = clk_round_rate(policy->clk, freq);\n\tif (ret < 0) {\n\t\tdev_warn(mpu_dev,\n\t\t\t \"CPUfreq: Cannot find matching frequency for %lu\\n\",\n\t\t\t freq);\n\t\treturn ret;\n\t}\n\tfreq = ret;\n\n\tif (mpu_reg) {\n\t\topp = dev_pm_opp_find_freq_ceil(mpu_dev, &freq);\n\t\tif (IS_ERR(opp)) {\n\t\t\tdev_err(mpu_dev, \"%s: unable to find MPU OPP for %d\\n\",\n\t\t\t\t__func__, new_freq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tvolt = dev_pm_opp_get_voltage(opp);\n\t\tdev_pm_opp_put(opp);\n\t\ttol = volt * OPP_TOLERANCE / 100;\n\t\tvolt_old = regulator_get_voltage(mpu_reg);\n\t}\n\n\tdev_dbg(mpu_dev, \"cpufreq-omap: %u MHz, %ld mV --> %u MHz, %ld mV\\n\", \n\t\told_freq / 1000, volt_old ? volt_old / 1000 : -1,\n\t\tnew_freq / 1000, volt ? volt / 1000 : -1);\n\n\t \n\tif (mpu_reg && (new_freq > old_freq)) {\n\t\tr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\n\t\tif (r < 0) {\n\t\t\tdev_warn(mpu_dev, \"%s: unable to scale voltage up.\\n\",\n\t\t\t\t __func__);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tret = clk_set_rate(policy->clk, new_freq * 1000);\n\n\t \n\tif (mpu_reg && (new_freq < old_freq)) {\n\t\tr = regulator_set_voltage(mpu_reg, volt - tol, volt + tol);\n\t\tif (r < 0) {\n\t\t\tdev_warn(mpu_dev, \"%s: unable to scale voltage down.\\n\",\n\t\t\t\t __func__);\n\t\t\tclk_set_rate(policy->clk, old_freq * 1000);\n\t\t\treturn r;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic inline void freq_table_free(void)\n{\n\tif (atomic_dec_and_test(&freq_table_users))\n\t\tdev_pm_opp_free_cpufreq_table(mpu_dev, &freq_table);\n}\n\nstatic int omap_cpu_init(struct cpufreq_policy *policy)\n{\n\tint result;\n\n\tpolicy->clk = clk_get(NULL, \"cpufreq_ck\");\n\tif (IS_ERR(policy->clk))\n\t\treturn PTR_ERR(policy->clk);\n\n\tif (!freq_table) {\n\t\tresult = dev_pm_opp_init_cpufreq_table(mpu_dev, &freq_table);\n\t\tif (result) {\n\t\t\tdev_err(mpu_dev,\n\t\t\t\t\"%s: cpu%d: failed creating freq table[%d]\\n\",\n\t\t\t\t__func__, policy->cpu, result);\n\t\t\tclk_put(policy->clk);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tatomic_inc_return(&freq_table_users);\n\n\t \n\tcpufreq_generic_init(policy, freq_table, 300 * 1000);\n\n\treturn 0;\n}\n\nstatic int omap_cpu_exit(struct cpufreq_policy *policy)\n{\n\tfreq_table_free();\n\tclk_put(policy->clk);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver omap_driver = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= omap_target,\n\t.get\t\t= cpufreq_generic_get,\n\t.init\t\t= omap_cpu_init,\n\t.exit\t\t= omap_cpu_exit,\n\t.register_em\t= cpufreq_register_em_with_opp,\n\t.name\t\t= \"omap\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic int omap_cpufreq_probe(struct platform_device *pdev)\n{\n\tmpu_dev = get_cpu_device(0);\n\tif (!mpu_dev) {\n\t\tpr_warn(\"%s: unable to get the MPU device\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tmpu_reg = regulator_get(mpu_dev, \"vcc\");\n\tif (IS_ERR(mpu_reg)) {\n\t\tpr_warn(\"%s: unable to get MPU regulator\\n\", __func__);\n\t\tmpu_reg = NULL;\n\t} else {\n\t\t \n\t\tif (regulator_get_voltage(mpu_reg) < 0) {\n\t\t\tpr_warn(\"%s: physical regulator not present for MPU\\n\",\n\t\t\t\t__func__);\n\t\t\tregulator_put(mpu_reg);\n\t\t\tmpu_reg = NULL;\n\t\t}\n\t}\n\n\treturn cpufreq_register_driver(&omap_driver);\n}\n\nstatic void omap_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&omap_driver);\n}\n\nstatic struct platform_driver omap_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"omap-cpufreq\",\n\t},\n\t.probe\t\t= omap_cpufreq_probe,\n\t.remove_new\t= omap_cpufreq_remove,\n};\nmodule_platform_driver(omap_cpufreq_platdrv);\n\nMODULE_DESCRIPTION(\"cpufreq driver for OMAP SoCs\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}