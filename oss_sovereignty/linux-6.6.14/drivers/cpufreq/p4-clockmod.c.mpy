{
  "module_name": "p4-clockmod.c",
  "hash_id": "fe13036472234f6aa281519cec30ff657ea10df4bba77783c7e8be192941630c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/p4-clockmod.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/timex.h>\n\n#include <asm/processor.h>\n#include <asm/msr.h>\n#include <asm/timer.h>\n#include <asm/cpu_device_id.h>\n\n#include \"speedstep-lib.h\"\n\n \nenum {\n\tDC_RESV, DC_DFLT, DC_25PT, DC_38PT, DC_50PT,\n\tDC_64PT, DC_75PT, DC_88PT, DC_DISABLE\n};\n\n#define DC_ENTRIES\t8\n\n\nstatic int has_N44_O17_errata[NR_CPUS];\nstatic unsigned int stock_freq;\nstatic struct cpufreq_driver p4clockmod_driver;\nstatic unsigned int cpufreq_p4_get(unsigned int cpu);\n\nstatic int cpufreq_p4_setdc(unsigned int cpu, unsigned int newstate)\n{\n\tu32 l, h;\n\n\tif ((newstate > DC_DISABLE) || (newstate == DC_RESV))\n\t\treturn -EINVAL;\n\n\trdmsr_on_cpu(cpu, MSR_IA32_THERM_STATUS, &l, &h);\n\n\tif (l & 0x01)\n\t\tpr_debug(\"CPU#%d currently thermal throttled\\n\", cpu);\n\n\tif (has_N44_O17_errata[cpu] &&\n\t    (newstate == DC_25PT || newstate == DC_DFLT))\n\t\tnewstate = DC_38PT;\n\n\trdmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, &l, &h);\n\tif (newstate == DC_DISABLE) {\n\t\tpr_debug(\"CPU#%d disabling modulation\\n\", cpu);\n\t\twrmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, l & ~(1<<4), h);\n\t} else {\n\t\tpr_debug(\"CPU#%d setting duty cycle to %d%%\\n\",\n\t\t\tcpu, ((125 * newstate) / 10));\n\t\t \n\t\tl = (l & ~14);\n\t\tl = l | (1<<4) | ((newstate & 0x7)<<1);\n\t\twrmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, l, h);\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct cpufreq_frequency_table p4clockmod_table[] = {\n\t{0, DC_RESV, CPUFREQ_ENTRY_INVALID},\n\t{0, DC_DFLT, 0},\n\t{0, DC_25PT, 0},\n\t{0, DC_38PT, 0},\n\t{0, DC_50PT, 0},\n\t{0, DC_64PT, 0},\n\t{0, DC_75PT, 0},\n\t{0, DC_88PT, 0},\n\t{0, DC_DISABLE, 0},\n\t{0, DC_RESV, CPUFREQ_TABLE_END},\n};\n\n\nstatic int cpufreq_p4_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tint i;\n\n\t \n\tfor_each_cpu(i, policy->cpus)\n\t\tcpufreq_p4_setdc(i, p4clockmod_table[index].driver_data);\n\n\treturn 0;\n}\n\n\nstatic unsigned int cpufreq_p4_get_frequency(struct cpuinfo_x86 *c)\n{\n\tif (c->x86 == 0x06) {\n\t\tif (cpu_has(c, X86_FEATURE_EST))\n\t\t\tpr_warn_once(\"Warning: EST-capable CPU detected. The acpi-cpufreq module offers voltage scaling in addition to frequency scaling. You should use that instead of p4-clockmod, if possible.\\n\");\n\t\tswitch (c->x86_model) {\n\t\tcase 0x0E:  \n\t\tcase 0x0F:  \n\t\tcase 0x16:  \n\t\tcase 0x1C:  \n\t\t\tp4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\n\t\t\treturn speedstep_get_frequency(SPEEDSTEP_CPU_PCORE);\n\t\tcase 0x0D:  \n\t\t\tp4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\n\t\t\tfallthrough;\n\t\tcase 0x09:  \n\t\t\treturn speedstep_get_frequency(SPEEDSTEP_CPU_PM);\n\t\t}\n\t}\n\n\tif (c->x86 != 0xF)\n\t\treturn 0;\n\n\t \n\tp4clockmod_driver.flags |= CPUFREQ_CONST_LOOPS;\n\n\tif (speedstep_detect_processor() == SPEEDSTEP_CPU_P4M) {\n\t\tpr_warn(\"Warning: Pentium 4-M detected. The speedstep-ich or acpi cpufreq modules offer voltage scaling in addition of frequency scaling. You should use either one instead of p4-clockmod, if possible.\\n\");\n\t\treturn speedstep_get_frequency(SPEEDSTEP_CPU_P4M);\n\t}\n\n\treturn speedstep_get_frequency(SPEEDSTEP_CPU_P4D);\n}\n\n\n\nstatic int cpufreq_p4_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(policy->cpu);\n\tint cpuid = 0;\n\tunsigned int i;\n\n#ifdef CONFIG_SMP\n\tcpumask_copy(policy->cpus, topology_sibling_cpumask(policy->cpu));\n#endif\n\n\t \n\tcpuid = (c->x86 << 8) | (c->x86_model << 4) | c->x86_stepping;\n\tswitch (cpuid) {\n\tcase 0x0f07:\n\tcase 0x0f0a:\n\tcase 0x0f11:\n\tcase 0x0f12:\n\t\thas_N44_O17_errata[policy->cpu] = 1;\n\t\tpr_debug(\"has errata -- disabling low frequencies\\n\");\n\t}\n\n\tif (speedstep_detect_processor() == SPEEDSTEP_CPU_P4D &&\n\t    c->x86_model < 2) {\n\t\t \n\t\tcpufreq_p4_setdc(policy->cpu, DC_DISABLE);\n\t\trecalibrate_cpu_khz();\n\t}\n\t \n\tstock_freq = cpufreq_p4_get_frequency(c);\n\tif (!stock_freq)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 1; (p4clockmod_table[i].frequency != CPUFREQ_TABLE_END); i++) {\n\t\tif ((i < 2) && (has_N44_O17_errata[policy->cpu]))\n\t\t\tp4clockmod_table[i].frequency = CPUFREQ_ENTRY_INVALID;\n\t\telse\n\t\t\tp4clockmod_table[i].frequency = (stock_freq * i)/8;\n\t}\n\n\t \n\n\t \n\tpolicy->cpuinfo.transition_latency = 10000001;\n\tpolicy->freq_table = &p4clockmod_table[0];\n\n\treturn 0;\n}\n\n\nstatic unsigned int cpufreq_p4_get(unsigned int cpu)\n{\n\tu32 l, h;\n\n\trdmsr_on_cpu(cpu, MSR_IA32_THERM_CONTROL, &l, &h);\n\n\tif (l & 0x10) {\n\t\tl = l >> 1;\n\t\tl &= 0x7;\n\t} else\n\t\tl = DC_DISABLE;\n\n\tif (l != DC_DISABLE)\n\t\treturn stock_freq * l / 8;\n\n\treturn stock_freq;\n}\n\nstatic struct cpufreq_driver p4clockmod_driver = {\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= cpufreq_p4_target,\n\t.init\t\t= cpufreq_p4_cpu_init,\n\t.get\t\t= cpufreq_p4_get,\n\t.name\t\t= \"p4-clockmod\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic const struct x86_cpu_id cpufreq_p4_id[] = {\n\tX86_MATCH_VENDOR_FEATURE(INTEL, X86_FEATURE_ACC, NULL),\n\t{}\n};\n\n \n\nstatic int __init cpufreq_p4_init(void)\n{\n\tint ret;\n\n\t \n\tif (!x86_match_cpu(cpufreq_p4_id) || !boot_cpu_has(X86_FEATURE_ACPI))\n\t\treturn -ENODEV;\n\n\tret = cpufreq_register_driver(&p4clockmod_driver);\n\tif (!ret)\n\t\tpr_info(\"P4/Xeon(TM) CPU On-Demand Clock Modulation available\\n\");\n\n\treturn ret;\n}\n\n\nstatic void __exit cpufreq_p4_exit(void)\n{\n\tcpufreq_unregister_driver(&p4clockmod_driver);\n}\n\n\nMODULE_AUTHOR(\"Zwane Mwaikambo <zwane@commfireservices.com>\");\nMODULE_DESCRIPTION(\"cpufreq driver for Pentium(TM) 4/Xeon(TM)\");\nMODULE_LICENSE(\"GPL\");\n\nlate_initcall(cpufreq_p4_init);\nmodule_exit(cpufreq_p4_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}