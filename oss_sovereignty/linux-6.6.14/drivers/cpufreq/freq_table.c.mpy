{
  "module_name": "freq_table.c",
  "hash_id": "1c7221078105fd3de48513ea1a2929385cbc2cf614d2177ee72de460c397df93",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/freq_table.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpufreq.h>\n#include <linux/module.h>\n\n \n\nbool policy_has_boost_freq(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos, *table = policy->freq_table;\n\n\tif (!table)\n\t\treturn false;\n\n\tcpufreq_for_each_valid_entry(pos, table)\n\t\tif (pos->flags & CPUFREQ_BOOST_FREQ)\n\t\t\treturn true;\n\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(policy_has_boost_freq);\n\nint cpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,\n\t\t\t\t    struct cpufreq_frequency_table *table)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int min_freq = ~0;\n\tunsigned int max_freq = 0;\n\tunsigned int freq;\n\n\tcpufreq_for_each_valid_entry(pos, table) {\n\t\tfreq = pos->frequency;\n\n\t\tif (!cpufreq_boost_enabled()\n\t\t    && (pos->flags & CPUFREQ_BOOST_FREQ))\n\t\t\tcontinue;\n\n\t\tpr_debug(\"table entry %u: %u kHz\\n\", (int)(pos - table), freq);\n\t\tif (freq < min_freq)\n\t\t\tmin_freq = freq;\n\t\tif (freq > max_freq)\n\t\t\tmax_freq = freq;\n\t}\n\n\tpolicy->min = policy->cpuinfo.min_freq = min_freq;\n\tpolicy->max = max_freq;\n\t \n\tif (policy->cpuinfo.max_freq < max_freq)\n\t\tpolicy->max = policy->cpuinfo.max_freq = max_freq;\n\n\tif (policy->min == ~0)\n\t\treturn -EINVAL;\n\telse\n\t\treturn 0;\n}\n\nint cpufreq_frequency_table_verify(struct cpufreq_policy_data *policy,\n\t\t\t\t   struct cpufreq_frequency_table *table)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int freq, next_larger = ~0;\n\tbool found = false;\n\n\tpr_debug(\"request for verification of policy (%u - %u kHz) for cpu %u\\n\",\n\t\t\t\t\tpolicy->min, policy->max, policy->cpu);\n\n\tcpufreq_verify_within_cpu_limits(policy);\n\n\tcpufreq_for_each_valid_entry(pos, table) {\n\t\tfreq = pos->frequency;\n\n\t\tif ((freq >= policy->min) && (freq <= policy->max)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((next_larger > freq) && (freq > policy->max))\n\t\t\tnext_larger = freq;\n\t}\n\n\tif (!found) {\n\t\tpolicy->max = next_larger;\n\t\tcpufreq_verify_within_cpu_limits(policy);\n\t}\n\n\tpr_debug(\"verification lead to (%u - %u kHz) for cpu %u\\n\",\n\t\t\t\tpolicy->min, policy->max, policy->cpu);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(cpufreq_frequency_table_verify);\n\n \nint cpufreq_generic_frequency_table_verify(struct cpufreq_policy_data *policy)\n{\n\tif (!policy->freq_table)\n\t\treturn -ENODEV;\n\n\treturn cpufreq_frequency_table_verify(policy, policy->freq_table);\n}\nEXPORT_SYMBOL_GPL(cpufreq_generic_frequency_table_verify);\n\nint cpufreq_table_index_unsorted(struct cpufreq_policy *policy,\n\t\t\t\t unsigned int target_freq,\n\t\t\t\t unsigned int relation)\n{\n\tstruct cpufreq_frequency_table optimal = {\n\t\t.driver_data = ~0,\n\t\t.frequency = 0,\n\t};\n\tstruct cpufreq_frequency_table suboptimal = {\n\t\t.driver_data = ~0,\n\t\t.frequency = 0,\n\t};\n\tstruct cpufreq_frequency_table *pos;\n\tstruct cpufreq_frequency_table *table = policy->freq_table;\n\tunsigned int freq, diff, i = 0;\n\tint index;\n\n\tpr_debug(\"request for target %u kHz (relation: %u) for cpu %u\\n\",\n\t\t\t\t\ttarget_freq, relation, policy->cpu);\n\n\tswitch (relation) {\n\tcase CPUFREQ_RELATION_H:\n\t\tsuboptimal.frequency = ~0;\n\t\tbreak;\n\tcase CPUFREQ_RELATION_L:\n\tcase CPUFREQ_RELATION_C:\n\t\toptimal.frequency = ~0;\n\t\tbreak;\n\t}\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, i) {\n\t\tfreq = pos->frequency;\n\n\t\tif ((freq < policy->min) || (freq > policy->max))\n\t\t\tcontinue;\n\t\tif (freq == target_freq) {\n\t\t\toptimal.driver_data = i;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (relation) {\n\t\tcase CPUFREQ_RELATION_H:\n\t\t\tif (freq < target_freq) {\n\t\t\t\tif (freq >= optimal.frequency) {\n\t\t\t\t\toptimal.frequency = freq;\n\t\t\t\t\toptimal.driver_data = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (freq <= suboptimal.frequency) {\n\t\t\t\t\tsuboptimal.frequency = freq;\n\t\t\t\t\tsuboptimal.driver_data = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CPUFREQ_RELATION_L:\n\t\t\tif (freq > target_freq) {\n\t\t\t\tif (freq <= optimal.frequency) {\n\t\t\t\t\toptimal.frequency = freq;\n\t\t\t\t\toptimal.driver_data = i;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (freq >= suboptimal.frequency) {\n\t\t\t\t\tsuboptimal.frequency = freq;\n\t\t\t\t\tsuboptimal.driver_data = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CPUFREQ_RELATION_C:\n\t\t\tdiff = abs(freq - target_freq);\n\t\t\tif (diff < optimal.frequency ||\n\t\t\t    (diff == optimal.frequency &&\n\t\t\t     freq > table[optimal.driver_data].frequency)) {\n\t\t\t\toptimal.frequency = diff;\n\t\t\t\toptimal.driver_data = i;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (optimal.driver_data > i) {\n\t\tif (suboptimal.driver_data > i) {\n\t\t\tWARN(1, \"Invalid frequency table: %d\\n\", policy->cpu);\n\t\t\treturn 0;\n\t\t}\n\n\t\tindex = suboptimal.driver_data;\n\t} else\n\t\tindex = optimal.driver_data;\n\n\tpr_debug(\"target index is %u, freq is:%u kHz\\n\", index,\n\t\t table[index].frequency);\n\treturn index;\n}\nEXPORT_SYMBOL_GPL(cpufreq_table_index_unsorted);\n\nint cpufreq_frequency_table_get_index(struct cpufreq_policy *policy,\n\t\tunsigned int freq)\n{\n\tstruct cpufreq_frequency_table *pos, *table = policy->freq_table;\n\tint idx;\n\n\tif (unlikely(!table)) {\n\t\tpr_debug(\"%s: Unable to find frequency table\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\n\tcpufreq_for_each_valid_entry_idx(pos, table, idx)\n\t\tif (pos->frequency == freq)\n\t\t\treturn idx;\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL_GPL(cpufreq_frequency_table_get_index);\n\n \nstatic ssize_t show_available_freqs(struct cpufreq_policy *policy, char *buf,\n\t\t\t\t    bool show_boost)\n{\n\tssize_t count = 0;\n\tstruct cpufreq_frequency_table *pos, *table = policy->freq_table;\n\n\tif (!table)\n\t\treturn -ENODEV;\n\n\tcpufreq_for_each_valid_entry(pos, table) {\n\t\t \n\t\tif (show_boost ^ (pos->flags & CPUFREQ_BOOST_FREQ))\n\t\t\tcontinue;\n\n\t\tcount += sprintf(&buf[count], \"%d \", pos->frequency);\n\t}\n\tcount += sprintf(&buf[count], \"\\n\");\n\n\treturn count;\n\n}\n\n#define cpufreq_attr_available_freq(_name)\t  \\\nstruct freq_attr cpufreq_freq_attr_##_name##_freqs =     \\\n__ATTR_RO(_name##_frequencies)\n\n \nstatic ssize_t scaling_available_frequencies_show(struct cpufreq_policy *policy,\n\t\t\t\t\t\t  char *buf)\n{\n\treturn show_available_freqs(policy, buf, false);\n}\ncpufreq_attr_available_freq(scaling_available);\nEXPORT_SYMBOL_GPL(cpufreq_freq_attr_scaling_available_freqs);\n\n \nstatic ssize_t scaling_boost_frequencies_show(struct cpufreq_policy *policy,\n\t\t\t\t\t      char *buf)\n{\n\treturn show_available_freqs(policy, buf, true);\n}\ncpufreq_attr_available_freq(scaling_boost);\nEXPORT_SYMBOL_GPL(cpufreq_freq_attr_scaling_boost_freqs);\n\nstruct freq_attr *cpufreq_generic_attr[] = {\n\t&cpufreq_freq_attr_scaling_available_freqs,\n\tNULL,\n};\nEXPORT_SYMBOL_GPL(cpufreq_generic_attr);\n\nstatic int set_freq_table_sorted(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos, *table = policy->freq_table;\n\tstruct cpufreq_frequency_table *prev = NULL;\n\tint ascending = 0;\n\n\tpolicy->freq_table_sorted = CPUFREQ_TABLE_UNSORTED;\n\n\tcpufreq_for_each_valid_entry(pos, table) {\n\t\tif (!prev) {\n\t\t\tprev = pos;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pos->frequency == prev->frequency) {\n\t\t\tpr_warn(\"Duplicate freq-table entries: %u\\n\",\n\t\t\t\tpos->frequency);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (pos->frequency > prev->frequency) {\n\t\t\t \n\t\t\tif (ascending < 0) {\n\t\t\t\tpr_debug(\"Freq table is unsorted\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tascending++;\n\t\t} else {\n\t\t\t \n\n\t\t\t \n\t\t\tif (ascending > 0) {\n\t\t\t\tpr_debug(\"Freq table is unsorted\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tascending--;\n\t\t}\n\n\t\tprev = pos;\n\t}\n\n\tif (ascending > 0)\n\t\tpolicy->freq_table_sorted = CPUFREQ_TABLE_SORTED_ASCENDING;\n\telse\n\t\tpolicy->freq_table_sorted = CPUFREQ_TABLE_SORTED_DESCENDING;\n\n\tpr_debug(\"Freq table is sorted in %s order\\n\",\n\t\t ascending > 0 ? \"ascending\" : \"descending\");\n\n\treturn 0;\n}\n\nint cpufreq_table_validate_and_sort(struct cpufreq_policy *policy)\n{\n\tint ret;\n\n\tif (!policy->freq_table) {\n\t\t \n\t\tif (has_target_index())\n\t\t\treturn -EINVAL;\n\n\t\treturn 0;\n\t}\n\n\tret = cpufreq_frequency_table_cpuinfo(policy, policy->freq_table);\n\tif (ret)\n\t\treturn ret;\n\n\treturn set_freq_table_sorted(policy);\n}\n\nMODULE_AUTHOR(\"Dominik Brodowski <linux@brodo.de>\");\nMODULE_DESCRIPTION(\"CPUfreq frequency table helpers\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}