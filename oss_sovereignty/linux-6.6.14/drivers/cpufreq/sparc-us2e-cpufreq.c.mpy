{
  "module_name": "sparc-us2e-cpufreq.c",
  "hash_id": "39899dd1311fcc7915d6f50f84c90297497fe6cf20c6d04e58c405886439c7bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/sparc-us2e-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/cpufreq.h>\n#include <linux/threads.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n\n#include <asm/asi.h>\n#include <asm/timer.h>\n\nstruct us2e_freq_percpu_info {\n\tstruct cpufreq_frequency_table table[6];\n};\n\n \nstatic struct us2e_freq_percpu_info *us2e_freq_table;\n\n#define HBIRD_MEM_CNTL0_ADDR\t0x1fe0000f010UL\n#define HBIRD_ESTAR_MODE_ADDR\t0x1fe0000f080UL\n\n \n#define ESTAR_MODE_DIV_1\t0x0000000000000000UL\n#define ESTAR_MODE_DIV_2\t0x0000000000000001UL\n#define ESTAR_MODE_DIV_4\t0x0000000000000003UL\n#define ESTAR_MODE_DIV_6\t0x0000000000000002UL\n#define ESTAR_MODE_DIV_8\t0x0000000000000004UL\n#define ESTAR_MODE_DIV_MASK\t0x0000000000000007UL\n\n#define MCTRL0_SREFRESH_ENAB\t0x0000000000010000UL\n#define MCTRL0_REFR_COUNT_MASK\t0x0000000000007f00UL\n#define MCTRL0_REFR_COUNT_SHIFT\t8\n#define MCTRL0_REFR_INTERVAL\t7800\n#define MCTRL0_REFR_CLKS_P_CNT\t64\n\nstatic unsigned long read_hbreg(unsigned long addr)\n{\n\tunsigned long ret;\n\n\t__asm__ __volatile__(\"ldxa\t[%1] %2, %0\"\n\t\t\t     : \"=&r\" (ret)\n\t\t\t     : \"r\" (addr), \"i\" (ASI_PHYS_BYPASS_EC_E));\n\treturn ret;\n}\n\nstatic void write_hbreg(unsigned long addr, unsigned long val)\n{\n\t__asm__ __volatile__(\"stxa\t%0, [%1] %2\\n\\t\"\n\t\t\t     \"membar\t#Sync\"\n\t\t\t     :  \n\t\t\t     : \"r\" (val), \"r\" (addr), \"i\" (ASI_PHYS_BYPASS_EC_E)\n\t\t\t     : \"memory\");\n\tif (addr == HBIRD_ESTAR_MODE_ADDR) {\n\t\t \n\t\tudelay(1);\n\t}\n}\n\nstatic void self_refresh_ctl(int enable)\n{\n\tunsigned long mctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\n\n\tif (enable)\n\t\tmctrl |= MCTRL0_SREFRESH_ENAB;\n\telse\n\t\tmctrl &= ~MCTRL0_SREFRESH_ENAB;\n\twrite_hbreg(HBIRD_MEM_CNTL0_ADDR, mctrl);\n\t(void) read_hbreg(HBIRD_MEM_CNTL0_ADDR);\n}\n\nstatic void frob_mem_refresh(int cpu_slowing_down,\n\t\t\t     unsigned long clock_tick,\n\t\t\t     unsigned long old_divisor, unsigned long divisor)\n{\n\tunsigned long old_refr_count, refr_count, mctrl;\n\n\trefr_count  = (clock_tick * MCTRL0_REFR_INTERVAL);\n\trefr_count /= (MCTRL0_REFR_CLKS_P_CNT * divisor * 1000000000UL);\n\n\tmctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\n\told_refr_count = (mctrl & MCTRL0_REFR_COUNT_MASK)\n\t\t>> MCTRL0_REFR_COUNT_SHIFT;\n\n\tmctrl &= ~MCTRL0_REFR_COUNT_MASK;\n\tmctrl |= refr_count << MCTRL0_REFR_COUNT_SHIFT;\n\twrite_hbreg(HBIRD_MEM_CNTL0_ADDR, mctrl);\n\tmctrl = read_hbreg(HBIRD_MEM_CNTL0_ADDR);\n\n\tif (cpu_slowing_down && !(mctrl & MCTRL0_SREFRESH_ENAB)) {\n\t\tunsigned long usecs;\n\n\t\t \n\t\tusecs = (MCTRL0_REFR_CLKS_P_CNT *\n\t\t\t (refr_count + old_refr_count) *\n\t\t\t 1000000UL *\n\t\t\t old_divisor) / clock_tick;\n\t\tudelay(usecs + 1UL);\n\t}\n}\n\nstatic void us2e_transition(unsigned long estar, unsigned long new_bits,\n\t\t\t    unsigned long clock_tick,\n\t\t\t    unsigned long old_divisor, unsigned long divisor)\n{\n\testar &= ~ESTAR_MODE_DIV_MASK;\n\n\t \n\tif (old_divisor == 2 && divisor == 1) {\n\t\tself_refresh_ctl(0);\n\t\twrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\n\t\tfrob_mem_refresh(0, clock_tick, old_divisor, divisor);\n\t} else if (old_divisor == 1 && divisor == 2) {\n\t\tfrob_mem_refresh(1, clock_tick, old_divisor, divisor);\n\t\twrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\n\t\tself_refresh_ctl(1);\n\t} else if (old_divisor == 1 && divisor > 2) {\n\t\tus2e_transition(estar, ESTAR_MODE_DIV_2, clock_tick,\n\t\t\t\t1, 2);\n\t\tus2e_transition(estar, new_bits, clock_tick,\n\t\t\t\t2, divisor);\n\t} else if (old_divisor > 2 && divisor == 1) {\n\t\tus2e_transition(estar, ESTAR_MODE_DIV_2, clock_tick,\n\t\t\t\told_divisor, 2);\n\t\tus2e_transition(estar, new_bits, clock_tick,\n\t\t\t\t2, divisor);\n\t} else if (old_divisor < divisor) {\n\t\tfrob_mem_refresh(0, clock_tick, old_divisor, divisor);\n\t\twrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\n\t} else if (old_divisor > divisor) {\n\t\twrite_hbreg(HBIRD_ESTAR_MODE_ADDR, estar | new_bits);\n\t\tfrob_mem_refresh(1, clock_tick, old_divisor, divisor);\n\t} else {\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long index_to_estar_mode(unsigned int index)\n{\n\tswitch (index) {\n\tcase 0:\n\t\treturn ESTAR_MODE_DIV_1;\n\n\tcase 1:\n\t\treturn ESTAR_MODE_DIV_2;\n\n\tcase 2:\n\t\treturn ESTAR_MODE_DIV_4;\n\n\tcase 3:\n\t\treturn ESTAR_MODE_DIV_6;\n\n\tcase 4:\n\t\treturn ESTAR_MODE_DIV_8;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long index_to_divisor(unsigned int index)\n{\n\tswitch (index) {\n\tcase 0:\n\t\treturn 1;\n\n\tcase 1:\n\t\treturn 2;\n\n\tcase 2:\n\t\treturn 4;\n\n\tcase 3:\n\t\treturn 6;\n\n\tcase 4:\n\t\treturn 8;\n\n\tdefault:\n\t\tBUG();\n\t}\n}\n\nstatic unsigned long estar_to_divisor(unsigned long estar)\n{\n\tunsigned long ret;\n\n\tswitch (estar & ESTAR_MODE_DIV_MASK) {\n\tcase ESTAR_MODE_DIV_1:\n\t\tret = 1;\n\t\tbreak;\n\tcase ESTAR_MODE_DIV_2:\n\t\tret = 2;\n\t\tbreak;\n\tcase ESTAR_MODE_DIV_4:\n\t\tret = 4;\n\t\tbreak;\n\tcase ESTAR_MODE_DIV_6:\n\t\tret = 6;\n\t\tbreak;\n\tcase ESTAR_MODE_DIV_8:\n\t\tret = 8;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\treturn ret;\n}\n\nstatic void __us2e_freq_get(void *arg)\n{\n\tunsigned long *estar = arg;\n\n\t*estar = read_hbreg(HBIRD_ESTAR_MODE_ADDR);\n}\n\nstatic unsigned int us2e_freq_get(unsigned int cpu)\n{\n\tunsigned long clock_tick, estar;\n\n\tclock_tick = sparc64_get_clock_tick(cpu) / 1000;\n\tif (smp_call_function_single(cpu, __us2e_freq_get, &estar, 1))\n\t\treturn 0;\n\n\treturn clock_tick / estar_to_divisor(estar);\n}\n\nstatic void __us2e_freq_target(void *arg)\n{\n\tunsigned int cpu = smp_processor_id();\n\tunsigned int *index = arg;\n\tunsigned long new_bits, new_freq;\n\tunsigned long clock_tick, divisor, old_divisor, estar;\n\n\tnew_freq = clock_tick = sparc64_get_clock_tick(cpu) / 1000;\n\tnew_bits = index_to_estar_mode(*index);\n\tdivisor = index_to_divisor(*index);\n\tnew_freq /= divisor;\n\n\testar = read_hbreg(HBIRD_ESTAR_MODE_ADDR);\n\n\told_divisor = estar_to_divisor(estar);\n\n\tif (old_divisor != divisor) {\n\t\tus2e_transition(estar, new_bits, clock_tick * 1000,\n\t\t\t\told_divisor, divisor);\n\t}\n}\n\nstatic int us2e_freq_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tunsigned int cpu = policy->cpu;\n\n\treturn smp_call_function_single(cpu, __us2e_freq_target, &index, 1);\n}\n\nstatic int us2e_freq_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\tunsigned long clock_tick = sparc64_get_clock_tick(cpu) / 1000;\n\tstruct cpufreq_frequency_table *table =\n\t\t&us2e_freq_table[cpu].table[0];\n\n\ttable[0].driver_data = 0;\n\ttable[0].frequency = clock_tick / 1;\n\ttable[1].driver_data = 1;\n\ttable[1].frequency = clock_tick / 2;\n\ttable[2].driver_data = 2;\n\ttable[2].frequency = clock_tick / 4;\n\ttable[2].driver_data = 3;\n\ttable[2].frequency = clock_tick / 6;\n\ttable[2].driver_data = 4;\n\ttable[2].frequency = clock_tick / 8;\n\ttable[2].driver_data = 5;\n\ttable[3].frequency = CPUFREQ_TABLE_END;\n\n\tpolicy->cpuinfo.transition_latency = 0;\n\tpolicy->cur = clock_tick;\n\tpolicy->freq_table = table;\n\n\treturn 0;\n}\n\nstatic int us2e_freq_cpu_exit(struct cpufreq_policy *policy)\n{\n\tus2e_freq_target(policy, 0);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver cpufreq_us2e_driver = {\n\t.name = \"UltraSPARC-IIe\",\n\t.init = us2e_freq_cpu_init,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = us2e_freq_target,\n\t.get = us2e_freq_get,\n\t.exit = us2e_freq_cpu_exit,\n};\n\nstatic int __init us2e_freq_init(void)\n{\n\tunsigned long manuf, impl, ver;\n\tint ret;\n\n\tif (tlb_type != spitfire)\n\t\treturn -ENODEV;\n\n\t__asm__(\"rdpr %%ver, %0\" : \"=r\" (ver));\n\tmanuf = ((ver >> 48) & 0xffff);\n\timpl  = ((ver >> 32) & 0xffff);\n\n\tif (manuf == 0x17 && impl == 0x13) {\n\t\tus2e_freq_table = kzalloc(NR_CPUS * sizeof(*us2e_freq_table),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!us2e_freq_table)\n\t\t\treturn -ENOMEM;\n\n\t\tret = cpufreq_register_driver(&cpufreq_us2e_driver);\n\t\tif (ret)\n\t\t\tkfree(us2e_freq_table);\n\n\t\treturn ret;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic void __exit us2e_freq_exit(void)\n{\n\tcpufreq_unregister_driver(&cpufreq_us2e_driver);\n\tkfree(us2e_freq_table);\n}\n\nMODULE_AUTHOR(\"David S. Miller <davem@redhat.com>\");\nMODULE_DESCRIPTION(\"cpufreq driver for UltraSPARC-IIe\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(us2e_freq_init);\nmodule_exit(us2e_freq_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}