{
  "module_name": "amd-pstate-ut.c",
  "hash_id": "c81cfcae4fb24d95fa3280a56665dbba9bc273260ae78c408b4059cb1d5b8b72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/amd-pstate-ut.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/fs.h>\n#include <linux/amd-pstate.h>\n\n#include <acpi/cppc_acpi.h>\n\n \nenum amd_pstate_ut_result {\n\tAMD_PSTATE_UT_RESULT_PASS,\n\tAMD_PSTATE_UT_RESULT_FAIL,\n};\n\nstruct amd_pstate_ut_struct {\n\tconst char *name;\n\tvoid (*func)(u32 index);\n\tenum amd_pstate_ut_result result;\n};\n\n \nstatic void amd_pstate_ut_acpi_cpc_valid(u32 index);\nstatic void amd_pstate_ut_check_enabled(u32 index);\nstatic void amd_pstate_ut_check_perf(u32 index);\nstatic void amd_pstate_ut_check_freq(u32 index);\n\nstatic struct amd_pstate_ut_struct amd_pstate_ut_cases[] = {\n\t{\"amd_pstate_ut_acpi_cpc_valid\",   amd_pstate_ut_acpi_cpc_valid   },\n\t{\"amd_pstate_ut_check_enabled\",    amd_pstate_ut_check_enabled    },\n\t{\"amd_pstate_ut_check_perf\",       amd_pstate_ut_check_perf       },\n\t{\"amd_pstate_ut_check_freq\",       amd_pstate_ut_check_freq       }\n};\n\nstatic bool get_shared_mem(void)\n{\n\tbool result = false;\n\n\tif (!boot_cpu_has(X86_FEATURE_CPPC))\n\t\tresult = true;\n\n\treturn result;\n}\n\n \nstatic void amd_pstate_ut_acpi_cpc_valid(u32 index)\n{\n\tif (acpi_cpc_valid())\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\telse {\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\tpr_err(\"%s the _CPC object is not present in SBIOS!\\n\", __func__);\n\t}\n}\n\nstatic void amd_pstate_ut_pstate_enable(u32 index)\n{\n\tint ret = 0;\n\tu64 cppc_enable = 0;\n\n\tret = rdmsrl_safe(MSR_AMD_CPPC_ENABLE, &cppc_enable);\n\tif (ret) {\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\tpr_err(\"%s rdmsrl_safe MSR_AMD_CPPC_ENABLE ret=%d error!\\n\", __func__, ret);\n\t\treturn;\n\t}\n\tif (cppc_enable)\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\telse {\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\tpr_err(\"%s amd pstate must be enabled!\\n\", __func__);\n\t}\n}\n\n \nstatic void amd_pstate_ut_check_enabled(u32 index)\n{\n\tif (get_shared_mem())\n\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\telse\n\t\tamd_pstate_ut_pstate_enable(index);\n}\n\n \nstatic void amd_pstate_ut_check_perf(u32 index)\n{\n\tint cpu = 0, ret = 0;\n\tu32 highest_perf = 0, nominal_perf = 0, lowest_nonlinear_perf = 0, lowest_perf = 0;\n\tu64 cap1 = 0;\n\tstruct cppc_perf_caps cppc_perf;\n\tstruct cpufreq_policy *policy = NULL;\n\tstruct amd_cpudata *cpudata = NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\tif (!policy)\n\t\t\tbreak;\n\t\tcpudata = policy->driver_data;\n\n\t\tif (get_shared_mem()) {\n\t\t\tret = cppc_get_perf_caps(cpu, &cppc_perf);\n\t\t\tif (ret) {\n\t\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\t\tpr_err(\"%s cppc_get_perf_caps ret=%d error!\\n\", __func__, ret);\n\t\t\t\tgoto skip_test;\n\t\t\t}\n\n\t\t\thighest_perf = cppc_perf.highest_perf;\n\t\t\tnominal_perf = cppc_perf.nominal_perf;\n\t\t\tlowest_nonlinear_perf = cppc_perf.lowest_nonlinear_perf;\n\t\t\tlowest_perf = cppc_perf.lowest_perf;\n\t\t} else {\n\t\t\tret = rdmsrl_safe_on_cpu(cpu, MSR_AMD_CPPC_CAP1, &cap1);\n\t\t\tif (ret) {\n\t\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\t\tpr_err(\"%s read CPPC_CAP1 ret=%d error!\\n\", __func__, ret);\n\t\t\t\tgoto skip_test;\n\t\t\t}\n\n\t\t\thighest_perf = AMD_CPPC_HIGHEST_PERF(cap1);\n\t\t\tnominal_perf = AMD_CPPC_NOMINAL_PERF(cap1);\n\t\t\tlowest_nonlinear_perf = AMD_CPPC_LOWNONLIN_PERF(cap1);\n\t\t\tlowest_perf = AMD_CPPC_LOWEST_PERF(cap1);\n\t\t}\n\n\t\tif ((highest_perf != READ_ONCE(cpudata->highest_perf)) ||\n\t\t\t(nominal_perf != READ_ONCE(cpudata->nominal_perf)) ||\n\t\t\t(lowest_nonlinear_perf != READ_ONCE(cpudata->lowest_nonlinear_perf)) ||\n\t\t\t(lowest_perf != READ_ONCE(cpudata->lowest_perf))) {\n\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\tpr_err(\"%s cpu%d highest=%d %d nominal=%d %d lowest_nonlinear=%d %d lowest=%d %d, they should be equal!\\n\",\n\t\t\t\t__func__, cpu, highest_perf, cpudata->highest_perf,\n\t\t\t\tnominal_perf, cpudata->nominal_perf,\n\t\t\t\tlowest_nonlinear_perf, cpudata->lowest_nonlinear_perf,\n\t\t\t\tlowest_perf, cpudata->lowest_perf);\n\t\t\tgoto skip_test;\n\t\t}\n\n\t\tif (!((highest_perf >= nominal_perf) &&\n\t\t\t(nominal_perf > lowest_nonlinear_perf) &&\n\t\t\t(lowest_nonlinear_perf > lowest_perf) &&\n\t\t\t(lowest_perf > 0))) {\n\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\tpr_err(\"%s cpu%d highest=%d >= nominal=%d > lowest_nonlinear=%d > lowest=%d > 0, the formula is incorrect!\\n\",\n\t\t\t\t__func__, cpu, highest_perf, nominal_perf,\n\t\t\t\tlowest_nonlinear_perf, lowest_perf);\n\t\t\tgoto skip_test;\n\t\t}\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\treturn;\nskip_test:\n\tcpufreq_cpu_put(policy);\n}\n\n \nstatic void amd_pstate_ut_check_freq(u32 index)\n{\n\tint cpu = 0;\n\tstruct cpufreq_policy *policy = NULL;\n\tstruct amd_cpudata *cpudata = NULL;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tpolicy = cpufreq_cpu_get(cpu);\n\t\tif (!policy)\n\t\t\tbreak;\n\t\tcpudata = policy->driver_data;\n\n\t\tif (!((cpudata->max_freq >= cpudata->nominal_freq) &&\n\t\t\t(cpudata->nominal_freq > cpudata->lowest_nonlinear_freq) &&\n\t\t\t(cpudata->lowest_nonlinear_freq > cpudata->min_freq) &&\n\t\t\t(cpudata->min_freq > 0))) {\n\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\tpr_err(\"%s cpu%d max=%d >= nominal=%d > lowest_nonlinear=%d > min=%d > 0, the formula is incorrect!\\n\",\n\t\t\t\t__func__, cpu, cpudata->max_freq, cpudata->nominal_freq,\n\t\t\t\tcpudata->lowest_nonlinear_freq, cpudata->min_freq);\n\t\t\tgoto skip_test;\n\t\t}\n\n\t\tif (cpudata->min_freq != policy->min) {\n\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\tpr_err(\"%s cpu%d cpudata_min_freq=%d policy_min=%d, they should be equal!\\n\",\n\t\t\t\t__func__, cpu, cpudata->min_freq, policy->min);\n\t\t\tgoto skip_test;\n\t\t}\n\n\t\tif (cpudata->boost_supported) {\n\t\t\tif ((policy->max == cpudata->max_freq) ||\n\t\t\t\t\t(policy->max == cpudata->nominal_freq))\n\t\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\t\t\telse {\n\t\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\t\tpr_err(\"%s cpu%d policy_max=%d should be equal cpu_max=%d or cpu_nominal=%d !\\n\",\n\t\t\t\t\t__func__, cpu, policy->max, cpudata->max_freq,\n\t\t\t\t\tcpudata->nominal_freq);\n\t\t\t\tgoto skip_test;\n\t\t\t}\n\t\t} else {\n\t\t\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_FAIL;\n\t\t\tpr_err(\"%s cpu%d must support boost!\\n\", __func__, cpu);\n\t\t\tgoto skip_test;\n\t\t}\n\t\tcpufreq_cpu_put(policy);\n\t}\n\n\tamd_pstate_ut_cases[index].result = AMD_PSTATE_UT_RESULT_PASS;\n\treturn;\nskip_test:\n\tcpufreq_cpu_put(policy);\n}\n\nstatic int __init amd_pstate_ut_init(void)\n{\n\tu32 i = 0, arr_size = ARRAY_SIZE(amd_pstate_ut_cases);\n\n\tfor (i = 0; i < arr_size; i++) {\n\t\tamd_pstate_ut_cases[i].func(i);\n\t\tswitch (amd_pstate_ut_cases[i].result) {\n\t\tcase AMD_PSTATE_UT_RESULT_PASS:\n\t\t\tpr_info(\"%-4d %-20s\\t success!\\n\", i+1, amd_pstate_ut_cases[i].name);\n\t\t\tbreak;\n\t\tcase AMD_PSTATE_UT_RESULT_FAIL:\n\t\tdefault:\n\t\t\tpr_info(\"%-4d %-20s\\t fail!\\n\", i+1, amd_pstate_ut_cases[i].name);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit amd_pstate_ut_exit(void)\n{\n}\n\nmodule_init(amd_pstate_ut_init);\nmodule_exit(amd_pstate_ut_exit);\n\nMODULE_AUTHOR(\"Meng Li <li.meng@amd.com>\");\nMODULE_DESCRIPTION(\"AMD P-state driver Test module\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}