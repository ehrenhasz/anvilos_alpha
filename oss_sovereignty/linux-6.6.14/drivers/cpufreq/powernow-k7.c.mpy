{
  "module_name": "powernow-k7.c",
  "hash_id": "1966a0e3c6bef3f09c0fa11597f0f6c8fa5220f439b92913b31b7f604d84570a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/powernow-k7.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/dmi.h>\n#include <linux/timex.h>\n#include <linux/io.h>\n\n#include <asm/timer.h>\t\t \n#include <asm/msr.h>\n#include <asm/cpu_device_id.h>\n\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\n#include <linux/acpi.h>\n#include <acpi/processor.h>\n#endif\n\n#include \"powernow-k7.h\"\n\nstruct psb_s {\n\tu8 signature[10];\n\tu8 tableversion;\n\tu8 flags;\n\tu16 settlingtime;\n\tu8 reserved1;\n\tu8 numpst;\n};\n\nstruct pst_s {\n\tu32 cpuid;\n\tu8 fsbspeed;\n\tu8 maxfid;\n\tu8 startvid;\n\tu8 numpstates;\n};\n\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\nunion powernow_acpi_control_t {\n\tstruct {\n\t\tunsigned long fid:5,\n\t\t\tvid:5,\n\t\t\tsgtc:20,\n\t\t\tres1:2;\n\t} bits;\n\tunsigned long val;\n};\n#endif\n\n \nstatic const int mobile_vid_table[32] = {\n    2000, 1950, 1900, 1850, 1800, 1750, 1700, 1650,\n    1600, 1550, 1500, 1450, 1400, 1350, 1300, 0,\n    1275, 1250, 1225, 1200, 1175, 1150, 1125, 1100,\n    1075, 1050, 1025, 1000, 975, 950, 925, 0,\n};\n\n \nstatic const int fid_codes[32] = {\n    110, 115, 120, 125, 50, 55, 60, 65,\n    70, 75, 80, 85, 90, 95, 100, 105,\n    30, 190, 40, 200, 130, 135, 140, 210,\n    150, 225, 160, 165, 170, 180, -1, -1,\n};\n\n \n\nstatic int acpi_force;\n\nstatic struct cpufreq_frequency_table *powernow_table;\n\nstatic unsigned int can_scale_bus;\nstatic unsigned int can_scale_vid;\nstatic unsigned int minimum_speed = -1;\nstatic unsigned int maximum_speed;\nstatic unsigned int number_scales;\nstatic unsigned int fsb;\nstatic unsigned int latency;\nstatic char have_a0;\n\nstatic int check_fsb(unsigned int fsbspeed)\n{\n\tint delta;\n\tunsigned int f = fsb / 1000;\n\n\tdelta = (fsbspeed > f) ? fsbspeed - f : f - fsbspeed;\n\treturn delta < 5;\n}\n\nstatic const struct x86_cpu_id powernow_k7_cpuids[] = {\n\tX86_MATCH_VENDOR_FAM(AMD, 6, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, powernow_k7_cpuids);\n\nstatic int check_powernow(void)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tunsigned int maxei, eax, ebx, ecx, edx;\n\n\tif (!x86_match_cpu(powernow_k7_cpuids))\n\t\treturn 0;\n\n\t \n\tmaxei = cpuid_eax(0x80000000);\n\tif (maxei < 0x80000007) {\t \n#ifdef MODULE\n\t\tpr_info(\"No powernow capabilities detected\\n\");\n#endif\n\t\treturn 0;\n\t}\n\n\tif ((c->x86_model == 6) && (c->x86_stepping == 0)) {\n\t\tpr_info(\"K7 660[A0] core detected, enabling errata workarounds\\n\");\n\t\thave_a0 = 1;\n\t}\n\n\tcpuid(0x80000007, &eax, &ebx, &ecx, &edx);\n\n\t \n\tif (!(edx & (1 << 1 | 1 << 2)))\n\t\treturn 0;\n\n\tpr_info(\"PowerNOW! Technology present. Can scale: \");\n\n\tif (edx & 1 << 1) {\n\t\tpr_cont(\"frequency\");\n\t\tcan_scale_bus = 1;\n\t}\n\n\tif ((edx & (1 << 1 | 1 << 2)) == 0x6)\n\t\tpr_cont(\" and \");\n\n\tif (edx & 1 << 2) {\n\t\tpr_cont(\"voltage\");\n\t\tcan_scale_vid = 1;\n\t}\n\n\tpr_cont(\"\\n\");\n\treturn 1;\n}\n\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\nstatic void invalidate_entry(unsigned int entry)\n{\n\tpowernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;\n}\n#endif\n\nstatic int get_ranges(unsigned char *pst)\n{\n\tunsigned int j;\n\tunsigned int speed;\n\tu8 fid, vid;\n\n\tpowernow_table = kzalloc((sizeof(*powernow_table) *\n\t\t\t\t(number_scales + 1)), GFP_KERNEL);\n\tif (!powernow_table)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0 ; j < number_scales; j++) {\n\t\tfid = *pst++;\n\n\t\tpowernow_table[j].frequency = (fsb * fid_codes[fid]) / 10;\n\t\tpowernow_table[j].driver_data = fid;  \n\n\t\tspeed = powernow_table[j].frequency;\n\n\t\tif ((fid_codes[fid] % 10) == 5) {\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\n\t\t\tif (have_a0 == 1)\n\t\t\t\tinvalidate_entry(j);\n#endif\n\t\t}\n\n\t\tif (speed < minimum_speed)\n\t\t\tminimum_speed = speed;\n\t\tif (speed > maximum_speed)\n\t\t\tmaximum_speed = speed;\n\n\t\tvid = *pst++;\n\t\tpowernow_table[j].driver_data |= (vid << 8);  \n\n\t\tpr_debug(\"   FID: 0x%x (%d.%dx [%dMHz])  \"\n\t\t\t \"VID: 0x%x (%d.%03dV)\\n\", fid, fid_codes[fid] / 10,\n\t\t\t fid_codes[fid] % 10, speed/1000, vid,\n\t\t\t mobile_vid_table[vid]/1000,\n\t\t\t mobile_vid_table[vid]%1000);\n\t}\n\tpowernow_table[number_scales].frequency = CPUFREQ_TABLE_END;\n\tpowernow_table[number_scales].driver_data = 0;\n\n\treturn 0;\n}\n\n\nstatic void change_FID(int fid)\n{\n\tunion msr_fidvidctl fidvidctl;\n\n\trdmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\n\tif (fidvidctl.bits.FID != fid) {\n\t\tfidvidctl.bits.SGTC = latency;\n\t\tfidvidctl.bits.FID = fid;\n\t\tfidvidctl.bits.VIDC = 0;\n\t\tfidvidctl.bits.FIDC = 1;\n\t\twrmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\n\t}\n}\n\n\nstatic void change_VID(int vid)\n{\n\tunion msr_fidvidctl fidvidctl;\n\n\trdmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\n\tif (fidvidctl.bits.VID != vid) {\n\t\tfidvidctl.bits.SGTC = latency;\n\t\tfidvidctl.bits.VID = vid;\n\t\tfidvidctl.bits.FIDC = 0;\n\t\tfidvidctl.bits.VIDC = 1;\n\t\twrmsrl(MSR_K7_FID_VID_CTL, fidvidctl.val);\n\t}\n}\n\n\nstatic int powernow_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tu8 fid, vid;\n\tstruct cpufreq_freqs freqs;\n\tunion msr_fidvidstatus fidvidstatus;\n\tint cfid;\n\n\t \n\n\tfid = powernow_table[index].driver_data & 0xFF;\n\tvid = (powernow_table[index].driver_data & 0xFF00) >> 8;\n\n\trdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\n\tcfid = fidvidstatus.bits.CFID;\n\tfreqs.old = fsb * fid_codes[cfid] / 10;\n\n\tfreqs.new = powernow_table[index].frequency;\n\n\t \n\n\tif (have_a0 == 1)\t \n\t\tlocal_irq_disable();\n\n\tif (freqs.old > freqs.new) {\n\t\t \n\t\tchange_FID(fid);\n\t\tchange_VID(vid);\n\t} else {\n\t\t \n\t\tchange_VID(vid);\n\t\tchange_FID(fid);\n\t}\n\n\n\tif (have_a0 == 1)\n\t\tlocal_irq_enable();\n\n\treturn 0;\n}\n\n\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\n\nstatic struct acpi_processor_performance *acpi_processor_perf;\n\nstatic int powernow_acpi_init(void)\n{\n\tint i;\n\tint retval = 0;\n\tunion powernow_acpi_control_t pc;\n\n\tif (acpi_processor_perf != NULL && powernow_table != NULL) {\n\t\tretval = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\tacpi_processor_perf = kzalloc(sizeof(*acpi_processor_perf), GFP_KERNEL);\n\tif (!acpi_processor_perf) {\n\t\tretval = -ENOMEM;\n\t\tgoto err0;\n\t}\n\n\tif (!zalloc_cpumask_var(&acpi_processor_perf->shared_cpu_map,\n\t\t\t\t\t\t\t\tGFP_KERNEL)) {\n\t\tretval = -ENOMEM;\n\t\tgoto err05;\n\t}\n\n\tif (acpi_processor_register_performance(acpi_processor_perf, 0)) {\n\t\tretval = -EIO;\n\t\tgoto err1;\n\t}\n\n\tif (acpi_processor_perf->control_register.space_id !=\n\t\t\tACPI_ADR_SPACE_FIXED_HARDWARE) {\n\t\tretval = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\tif (acpi_processor_perf->status_register.space_id !=\n\t\t\tACPI_ADR_SPACE_FIXED_HARDWARE) {\n\t\tretval = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\tnumber_scales = acpi_processor_perf->state_count;\n\n\tif (number_scales < 2) {\n\t\tretval = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\tpowernow_table = kzalloc((sizeof(*powernow_table) *\n\t\t\t\t(number_scales + 1)), GFP_KERNEL);\n\tif (!powernow_table) {\n\t\tretval = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tpc.val = (unsigned long) acpi_processor_perf->states[0].control;\n\tfor (i = 0; i < number_scales; i++) {\n\t\tu8 fid, vid;\n\t\tstruct acpi_processor_px *state =\n\t\t\t&acpi_processor_perf->states[i];\n\t\tunsigned int speed, speed_mhz;\n\n\t\tpc.val = (unsigned long) state->control;\n\t\tpr_debug(\"acpi:  P%d: %d MHz %d mW %d uS control %08x SGTC %d\\n\",\n\t\t\t i,\n\t\t\t (u32) state->core_frequency,\n\t\t\t (u32) state->power,\n\t\t\t (u32) state->transition_latency,\n\t\t\t (u32) state->control,\n\t\t\t pc.bits.sgtc);\n\n\t\tvid = pc.bits.vid;\n\t\tfid = pc.bits.fid;\n\n\t\tpowernow_table[i].frequency = fsb * fid_codes[fid] / 10;\n\t\tpowernow_table[i].driver_data = fid;  \n\t\tpowernow_table[i].driver_data |= (vid << 8);  \n\n\t\tspeed = powernow_table[i].frequency;\n\t\tspeed_mhz = speed / 1000;\n\n\t\t \n\t\tif (speed % 1000 > 0)\n\t\t\tspeed_mhz++;\n\n\t\tif ((fid_codes[fid] % 10) == 5) {\n\t\t\tif (have_a0 == 1)\n\t\t\t\tinvalidate_entry(i);\n\t\t}\n\n\t\tpr_debug(\"   FID: 0x%x (%d.%dx [%dMHz])  \"\n\t\t\t \"VID: 0x%x (%d.%03dV)\\n\", fid, fid_codes[fid] / 10,\n\t\t\t fid_codes[fid] % 10, speed_mhz, vid,\n\t\t\t mobile_vid_table[vid]/1000,\n\t\t\t mobile_vid_table[vid]%1000);\n\n\t\tif (state->core_frequency != speed_mhz) {\n\t\t\tstate->core_frequency = speed_mhz;\n\t\t\tpr_debug(\"   Corrected ACPI frequency to %d\\n\",\n\t\t\t\tspeed_mhz);\n\t\t}\n\n\t\tif (latency < pc.bits.sgtc)\n\t\t\tlatency = pc.bits.sgtc;\n\n\t\tif (speed < minimum_speed)\n\t\t\tminimum_speed = speed;\n\t\tif (speed > maximum_speed)\n\t\t\tmaximum_speed = speed;\n\t}\n\n\tpowernow_table[i].frequency = CPUFREQ_TABLE_END;\n\tpowernow_table[i].driver_data = 0;\n\n\t \n\tacpi_processor_notify_smm(THIS_MODULE);\n\n\treturn 0;\n\nerr2:\n\tacpi_processor_unregister_performance(0);\nerr1:\n\tfree_cpumask_var(acpi_processor_perf->shared_cpu_map);\nerr05:\n\tkfree(acpi_processor_perf);\nerr0:\n\tpr_warn(\"ACPI perflib can not be used on this platform\\n\");\n\tacpi_processor_perf = NULL;\n\treturn retval;\n}\n#else\nstatic int powernow_acpi_init(void)\n{\n\tpr_info(\"no support for ACPI processor found - please recompile your kernel with ACPI processor\\n\");\n\treturn -EINVAL;\n}\n#endif\n\nstatic void print_pst_entry(struct pst_s *pst, unsigned int j)\n{\n\tpr_debug(\"PST:%d (@%p)\\n\", j, pst);\n\tpr_debug(\" cpuid: 0x%x  fsb: %d  maxFID: 0x%x  startvid: 0x%x\\n\",\n\t\tpst->cpuid, pst->fsbspeed, pst->maxfid, pst->startvid);\n}\n\nstatic int powernow_decode_bios(int maxfid, int startvid)\n{\n\tstruct psb_s *psb;\n\tstruct pst_s *pst;\n\tunsigned int i, j;\n\tunsigned char *p;\n\tunsigned int etuple;\n\tunsigned int ret;\n\n\tetuple = cpuid_eax(0x80000001);\n\n\tfor (i = 0xC0000; i < 0xffff0 ; i += 16) {\n\n\t\tp = phys_to_virt(i);\n\n\t\tif (memcmp(p, \"AMDK7PNOW!\",  10) == 0) {\n\t\t\tpr_debug(\"Found PSB header at %p\\n\", p);\n\t\t\tpsb = (struct psb_s *) p;\n\t\t\tpr_debug(\"Table version: 0x%x\\n\", psb->tableversion);\n\t\t\tif (psb->tableversion != 0x12) {\n\t\t\t\tpr_info(\"Sorry, only v1.2 tables supported right now\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\n\t\t\tpr_debug(\"Flags: 0x%x\\n\", psb->flags);\n\t\t\tif ((psb->flags & 1) == 0)\n\t\t\t\tpr_debug(\"Mobile voltage regulator\\n\");\n\t\t\telse\n\t\t\t\tpr_debug(\"Desktop voltage regulator\\n\");\n\n\t\t\tlatency = psb->settlingtime;\n\t\t\tif (latency < 100) {\n\t\t\t\tpr_info(\"BIOS set settling time to %d microseconds. Should be at least 100. Correcting.\\n\",\n\t\t\t\t\tlatency);\n\t\t\t\tlatency = 100;\n\t\t\t}\n\t\t\tpr_debug(\"Settling Time: %d microseconds.\\n\",\n\t\t\t\t\tpsb->settlingtime);\n\t\t\tpr_debug(\"Has %d PST tables. (Only dumping ones \"\n\t\t\t\t\t\"relevant to this CPU).\\n\",\n\t\t\t\t\tpsb->numpst);\n\n\t\t\tp += sizeof(*psb);\n\n\t\t\tpst = (struct pst_s *) p;\n\n\t\t\tfor (j = 0; j < psb->numpst; j++) {\n\t\t\t\tpst = (struct pst_s *) p;\n\t\t\t\tnumber_scales = pst->numpstates;\n\n\t\t\t\tif ((etuple == pst->cpuid) &&\n\t\t\t\t    check_fsb(pst->fsbspeed) &&\n\t\t\t\t    (maxfid == pst->maxfid) &&\n\t\t\t\t    (startvid == pst->startvid)) {\n\t\t\t\t\tprint_pst_entry(pst, j);\n\t\t\t\t\tp = (char *)pst + sizeof(*pst);\n\t\t\t\t\tret = get_ranges(p);\n\t\t\t\t\treturn ret;\n\t\t\t\t} else {\n\t\t\t\t\tunsigned int k;\n\t\t\t\t\tp = (char *)pst + sizeof(*pst);\n\t\t\t\t\tfor (k = 0; k < number_scales; k++)\n\t\t\t\t\t\tp += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_info(\"No PST tables match this cpuid (0x%x)\\n\",\n\t\t\t\tetuple);\n\t\t\tpr_info(\"This is indicative of a broken BIOS\\n\");\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tp++;\n\t}\n\n\treturn -ENODEV;\n}\n\n\n \nstatic int fixup_sgtc(void)\n{\n\tunsigned int sgtc;\n\tunsigned int m;\n\n\tm = fsb / 3333;\n\tif ((m % 10) >= 5)\n\t\tm += 5;\n\n\tm /= 10;\n\n\tsgtc = 100 * m * latency;\n\tsgtc = sgtc / 3;\n\tif (sgtc > 0xfffff) {\n\t\tpr_warn(\"SGTC too large %d\\n\", sgtc);\n\t\tsgtc = 0xfffff;\n\t}\n\treturn sgtc;\n}\n\nstatic unsigned int powernow_get(unsigned int cpu)\n{\n\tunion msr_fidvidstatus fidvidstatus;\n\tunsigned int cfid;\n\n\tif (cpu)\n\t\treturn 0;\n\trdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\n\tcfid = fidvidstatus.bits.CFID;\n\n\treturn fsb * fid_codes[cfid] / 10;\n}\n\n\nstatic int acer_cpufreq_pst(const struct dmi_system_id *d)\n{\n\tpr_warn(\"%s laptop with broken PST tables in BIOS detected\\n\",\n\t\td->ident);\n\tpr_warn(\"You need to downgrade to 3A21 (09/09/2002), or try a newer BIOS than 3A71 (01/20/2003)\\n\");\n\tpr_warn(\"cpufreq scaling has been disabled as a result of this\\n\");\n\treturn 0;\n}\n\n \nstatic const struct dmi_system_id powernow_dmi_table[] = {\n\t{\n\t\t.callback = acer_cpufreq_pst,\n\t\t.ident = \"Acer Aspire\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde Software\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"3A71\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int powernow_cpu_init(struct cpufreq_policy *policy)\n{\n\tunion msr_fidvidstatus fidvidstatus;\n\tint result;\n\n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\trdmsrl(MSR_K7_FID_VID_STATUS, fidvidstatus.val);\n\n\trecalibrate_cpu_khz();\n\n\tfsb = (10 * cpu_khz) / fid_codes[fidvidstatus.bits.CFID];\n\tif (!fsb) {\n\t\tpr_warn(\"can not determine bus frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\tpr_debug(\"FSB: %3dMHz\\n\", fsb/1000);\n\n\tif (dmi_check_system(powernow_dmi_table) || acpi_force) {\n\t\tpr_info(\"PSB/PST known to be broken - trying ACPI instead\\n\");\n\t\tresult = powernow_acpi_init();\n\t} else {\n\t\tresult = powernow_decode_bios(fidvidstatus.bits.MFID,\n\t\t\t\tfidvidstatus.bits.SVID);\n\t\tif (result) {\n\t\t\tpr_info(\"Trying ACPI perflib\\n\");\n\t\t\tmaximum_speed = 0;\n\t\t\tminimum_speed = -1;\n\t\t\tlatency = 0;\n\t\t\tresult = powernow_acpi_init();\n\t\t\tif (result) {\n\t\t\t\tpr_info(\"ACPI and legacy methods failed\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tlatency = fixup_sgtc();\n\t\t\tpr_info(\"SGTC: %d\\n\", latency);\n\t\t}\n\t}\n\n\tif (result)\n\t\treturn result;\n\n\tpr_info(\"Minimum speed %d MHz - Maximum speed %d MHz\\n\",\n\t\tminimum_speed/1000, maximum_speed/1000);\n\n\tpolicy->cpuinfo.transition_latency =\n\t\tcpufreq_scale(2000000UL, fsb, latency);\n\tpolicy->freq_table = powernow_table;\n\n\treturn 0;\n}\n\nstatic int powernow_cpu_exit(struct cpufreq_policy *policy)\n{\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\n\tif (acpi_processor_perf) {\n\t\tacpi_processor_unregister_performance(0);\n\t\tfree_cpumask_var(acpi_processor_perf->shared_cpu_map);\n\t\tkfree(acpi_processor_perf);\n\t}\n#endif\n\n\tkfree(powernow_table);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver powernow_driver = {\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= powernow_target,\n\t.get\t\t= powernow_get,\n#ifdef CONFIG_X86_POWERNOW_K7_ACPI\n\t.bios_limit\t= acpi_processor_get_bios_limit,\n#endif\n\t.init\t\t= powernow_cpu_init,\n\t.exit\t\t= powernow_cpu_exit,\n\t.name\t\t= \"powernow-k7\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic int __init powernow_init(void)\n{\n\tif (check_powernow() == 0)\n\t\treturn -ENODEV;\n\treturn cpufreq_register_driver(&powernow_driver);\n}\n\n\nstatic void __exit powernow_exit(void)\n{\n\tcpufreq_unregister_driver(&powernow_driver);\n}\n\nmodule_param(acpi_force,  int, 0444);\nMODULE_PARM_DESC(acpi_force, \"Force ACPI to be used.\");\n\nMODULE_AUTHOR(\"Dave Jones\");\nMODULE_DESCRIPTION(\"Powernow driver for AMD K7 processors.\");\nMODULE_LICENSE(\"GPL\");\n\nlate_initcall(powernow_init);\nmodule_exit(powernow_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}