{
  "module_name": "cpufreq-dt.c",
  "hash_id": "ba7c34286e678728e63f9187ad6a616698251b4d35a290658f9a0552c5d9b9e5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq-dt.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/err.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_opp.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/thermal.h>\n\n#include \"cpufreq-dt.h\"\n\nstruct private_data {\n\tstruct list_head node;\n\n\tcpumask_var_t cpus;\n\tstruct device *cpu_dev;\n\tstruct cpufreq_frequency_table *freq_table;\n\tbool have_static_opps;\n\tint opp_token;\n};\n\nstatic LIST_HEAD(priv_list);\n\nstatic struct freq_attr *cpufreq_dt_attr[] = {\n\t&cpufreq_freq_attr_scaling_available_freqs,\n\tNULL,    \n\tNULL,\n};\n\nstatic struct private_data *cpufreq_dt_find_data(int cpu)\n{\n\tstruct private_data *priv;\n\n\tlist_for_each_entry(priv, &priv_list, node) {\n\t\tif (cpumask_test_cpu(cpu, priv->cpus))\n\t\t\treturn priv;\n\t}\n\n\treturn NULL;\n}\n\nstatic int set_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tstruct private_data *priv = policy->driver_data;\n\tunsigned long freq = policy->freq_table[index].frequency;\n\n\treturn dev_pm_opp_set_rate(priv->cpu_dev, freq * 1000);\n}\n\n \nstatic const char *find_supply_name(struct device *dev)\n{\n\tstruct device_node *np;\n\tstruct property *pp;\n\tint cpu = dev->id;\n\tconst char *name = NULL;\n\n\tnp = of_node_get(dev->of_node);\n\n\t \n\tif (WARN_ON(!np))\n\t\treturn NULL;\n\n\t \n\tif (!cpu) {\n\t\tpp = of_find_property(np, \"cpu0-supply\", NULL);\n\t\tif (pp) {\n\t\t\tname = \"cpu0\";\n\t\t\tgoto node_put;\n\t\t}\n\t}\n\n\tpp = of_find_property(np, \"cpu-supply\", NULL);\n\tif (pp) {\n\t\tname = \"cpu\";\n\t\tgoto node_put;\n\t}\n\n\tdev_dbg(dev, \"no regulator for cpu%d\\n\", cpu);\nnode_put:\n\tof_node_put(np);\n\treturn name;\n}\n\nstatic int cpufreq_init(struct cpufreq_policy *policy)\n{\n\tstruct private_data *priv;\n\tstruct device *cpu_dev;\n\tstruct clk *cpu_clk;\n\tunsigned int transition_latency;\n\tint ret;\n\n\tpriv = cpufreq_dt_find_data(policy->cpu);\n\tif (!priv) {\n\t\tpr_err(\"failed to find data for cpu%d\\n\", policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\tcpu_dev = priv->cpu_dev;\n\n\tcpu_clk = clk_get(cpu_dev, NULL);\n\tif (IS_ERR(cpu_clk)) {\n\t\tret = PTR_ERR(cpu_clk);\n\t\tdev_err(cpu_dev, \"%s: failed to get clk: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\ttransition_latency = dev_pm_opp_get_max_transition_latency(cpu_dev);\n\tif (!transition_latency)\n\t\ttransition_latency = CPUFREQ_ETERNAL;\n\n\tcpumask_copy(policy->cpus, priv->cpus);\n\tpolicy->driver_data = priv;\n\tpolicy->clk = cpu_clk;\n\tpolicy->freq_table = priv->freq_table;\n\tpolicy->suspend_freq = dev_pm_opp_get_suspend_opp_freq(cpu_dev) / 1000;\n\tpolicy->cpuinfo.transition_latency = transition_latency;\n\tpolicy->dvfs_possible_from_any_cpu = true;\n\n\t \n\tif (policy_has_boost_freq(policy)) {\n\t\t \n\t\tret = cpufreq_enable_boost_support();\n\t\tif (ret)\n\t\t\tgoto out_clk_put;\n\t\tcpufreq_dt_attr[1] = &cpufreq_freq_attr_scaling_boost_freqs;\n\t}\n\n\treturn 0;\n\nout_clk_put:\n\tclk_put(cpu_clk);\n\n\treturn ret;\n}\n\nstatic int cpufreq_online(struct cpufreq_policy *policy)\n{\n\t \n\treturn 0;\n}\n\nstatic int cpufreq_offline(struct cpufreq_policy *policy)\n{\n\t \n\treturn 0;\n}\n\nstatic int cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tclk_put(policy->clk);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver dt_cpufreq_driver = {\n\t.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t CPUFREQ_IS_COOLING_DEV,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = set_target,\n\t.get = cpufreq_generic_get,\n\t.init = cpufreq_init,\n\t.exit = cpufreq_exit,\n\t.online = cpufreq_online,\n\t.offline = cpufreq_offline,\n\t.register_em = cpufreq_register_em_with_opp,\n\t.name = \"cpufreq-dt\",\n\t.attr = cpufreq_dt_attr,\n\t.suspend = cpufreq_generic_suspend,\n};\n\nstatic int dt_cpufreq_early_init(struct device *dev, int cpu)\n{\n\tstruct private_data *priv;\n\tstruct device *cpu_dev;\n\tbool fallback = false;\n\tconst char *reg_name[] = { NULL, NULL };\n\tint ret;\n\n\t \n\tif (cpufreq_dt_find_data(cpu))\n\t\treturn 0;\n\n\tcpu_dev = get_cpu_device(cpu);\n\tif (!cpu_dev)\n\t\treturn -EPROBE_DEFER;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (!alloc_cpumask_var(&priv->cpus, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tcpumask_set_cpu(cpu, priv->cpus);\n\tpriv->cpu_dev = cpu_dev;\n\n\t \n\treg_name[0] = find_supply_name(cpu_dev);\n\tif (reg_name[0]) {\n\t\tpriv->opp_token = dev_pm_opp_set_regulators(cpu_dev, reg_name);\n\t\tif (priv->opp_token < 0) {\n\t\t\tret = dev_err_probe(cpu_dev, priv->opp_token,\n\t\t\t\t\t    \"failed to set regulators\\n\");\n\t\t\tgoto free_cpumask;\n\t\t}\n\t}\n\n\t \n\tret = dev_pm_opp_of_get_sharing_cpus(cpu_dev, priv->cpus);\n\tif (ret) {\n\t\tif (ret != -ENOENT)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (dev_pm_opp_get_sharing_cpus(cpu_dev, priv->cpus))\n\t\t\tfallback = true;\n\t}\n\n\t \n\tret = dev_pm_opp_of_cpumask_add_table(priv->cpus);\n\tif (!ret) {\n\t\tpriv->have_static_opps = true;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\tgoto out;\n\t}\n\n\t \n\tret = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (ret <= 0) {\n\t\tdev_err(cpu_dev, \"OPP table can't be empty\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tif (fallback) {\n\t\tcpumask_setall(priv->cpus);\n\t\tret = dev_pm_opp_set_sharing_cpus(cpu_dev, priv->cpus);\n\t\tif (ret)\n\t\t\tdev_err(cpu_dev, \"%s: failed to mark OPPs as shared: %d\\n\",\n\t\t\t\t__func__, ret);\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &priv->freq_table);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed to init cpufreq table: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tlist_add(&priv->node, &priv_list);\n\treturn 0;\n\nout:\n\tif (priv->have_static_opps)\n\t\tdev_pm_opp_of_cpumask_remove_table(priv->cpus);\n\tdev_pm_opp_put_regulators(priv->opp_token);\nfree_cpumask:\n\tfree_cpumask_var(priv->cpus);\n\treturn ret;\n}\n\nstatic void dt_cpufreq_release(void)\n{\n\tstruct private_data *priv, *tmp;\n\n\tlist_for_each_entry_safe(priv, tmp, &priv_list, node) {\n\t\tdev_pm_opp_free_cpufreq_table(priv->cpu_dev, &priv->freq_table);\n\t\tif (priv->have_static_opps)\n\t\t\tdev_pm_opp_of_cpumask_remove_table(priv->cpus);\n\t\tdev_pm_opp_put_regulators(priv->opp_token);\n\t\tfree_cpumask_var(priv->cpus);\n\t\tlist_del(&priv->node);\n\t}\n}\n\nstatic int dt_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct cpufreq_dt_platform_data *data = dev_get_platdata(&pdev->dev);\n\tint ret, cpu;\n\n\t \n\tfor_each_possible_cpu(cpu) {\n\t\tret = dt_cpufreq_early_init(&pdev->dev, cpu);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (data) {\n\t\tif (data->have_governor_per_policy)\n\t\t\tdt_cpufreq_driver.flags |= CPUFREQ_HAVE_GOVERNOR_PER_POLICY;\n\n\t\tdt_cpufreq_driver.resume = data->resume;\n\t\tif (data->suspend)\n\t\t\tdt_cpufreq_driver.suspend = data->suspend;\n\t\tif (data->get_intermediate) {\n\t\t\tdt_cpufreq_driver.target_intermediate = data->target_intermediate;\n\t\t\tdt_cpufreq_driver.get_intermediate = data->get_intermediate;\n\t\t}\n\t}\n\n\tret = cpufreq_register_driver(&dt_cpufreq_driver);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed register driver: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tdt_cpufreq_release();\n\treturn ret;\n}\n\nstatic void dt_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&dt_cpufreq_driver);\n\tdt_cpufreq_release();\n}\n\nstatic struct platform_driver dt_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"cpufreq-dt\",\n\t},\n\t.probe\t\t= dt_cpufreq_probe,\n\t.remove_new\t= dt_cpufreq_remove,\n};\nmodule_platform_driver(dt_cpufreq_platdrv);\n\nMODULE_ALIAS(\"platform:cpufreq-dt\");\nMODULE_AUTHOR(\"Viresh Kumar <viresh.kumar@linaro.org>\");\nMODULE_AUTHOR(\"Shawn Guo <shawn.guo@linaro.org>\");\nMODULE_DESCRIPTION(\"Generic cpufreq driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}