{
  "module_name": "apple-soc-cpufreq.c",
  "hash_id": "aaa829972c4c876e2d7fa605ccf12fe58fbd4c13257a3027f32b5813b0f8dfeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/apple-soc-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n\n#define APPLE_DVFS_CMD\t\t\t0x20\n#define APPLE_DVFS_CMD_BUSY\t\tBIT(31)\n#define APPLE_DVFS_CMD_SET\t\tBIT(25)\n#define APPLE_DVFS_CMD_PS2\t\tGENMASK(16, 12)\n#define APPLE_DVFS_CMD_PS1\t\tGENMASK(4, 0)\n\n \n#define APPLE_DVFS_LAST_CHG_TIME\t0x38\n\n \n#define APPLE_DVFS_STATUS\t\t\t0x50\n#define APPLE_DVFS_STATUS_CUR_PS_T8103\t\tGENMASK(7, 4)\n#define APPLE_DVFS_STATUS_CUR_PS_SHIFT_T8103\t4\n#define APPLE_DVFS_STATUS_TGT_PS_T8103\t\tGENMASK(3, 0)\n#define APPLE_DVFS_STATUS_CUR_PS_T8112\t\tGENMASK(9, 5)\n#define APPLE_DVFS_STATUS_CUR_PS_SHIFT_T8112\t5\n#define APPLE_DVFS_STATUS_TGT_PS_T8112\t\tGENMASK(4, 0)\n\n \n#define APPLE_DVFS_PLL_STATUS\t\t0xc0\n#define APPLE_DVFS_PLL_FACTOR\t\t0xc8\n#define APPLE_DVFS_PLL_FACTOR_MULT\tGENMASK(31, 16)\n#define APPLE_DVFS_PLL_FACTOR_DIV\tGENMASK(15, 0)\n\n#define APPLE_DVFS_TRANSITION_TIMEOUT 100\n\nstruct apple_soc_cpufreq_info {\n\tu64 max_pstate;\n\tu64 cur_pstate_mask;\n\tu64 cur_pstate_shift;\n};\n\nstruct apple_cpu_priv {\n\tstruct device *cpu_dev;\n\tvoid __iomem *reg_base;\n\tconst struct apple_soc_cpufreq_info *info;\n};\n\nstatic struct cpufreq_driver apple_soc_cpufreq_driver;\n\nstatic const struct apple_soc_cpufreq_info soc_t8103_info = {\n\t.max_pstate = 15,\n\t.cur_pstate_mask = APPLE_DVFS_STATUS_CUR_PS_T8103,\n\t.cur_pstate_shift = APPLE_DVFS_STATUS_CUR_PS_SHIFT_T8103,\n};\n\nstatic const struct apple_soc_cpufreq_info soc_t8112_info = {\n\t.max_pstate = 31,\n\t.cur_pstate_mask = APPLE_DVFS_STATUS_CUR_PS_T8112,\n\t.cur_pstate_shift = APPLE_DVFS_STATUS_CUR_PS_SHIFT_T8112,\n};\n\nstatic const struct apple_soc_cpufreq_info soc_default_info = {\n\t.max_pstate = 15,\n\t.cur_pstate_mask = 0,  \n};\n\nstatic const struct of_device_id apple_soc_cpufreq_of_match[] = {\n\t{\n\t\t.compatible = \"apple,t8103-cluster-cpufreq\",\n\t\t.data = &soc_t8103_info,\n\t},\n\t{\n\t\t.compatible = \"apple,t8112-cluster-cpufreq\",\n\t\t.data = &soc_t8112_info,\n\t},\n\t{\n\t\t.compatible = \"apple,cluster-cpufreq\",\n\t\t.data = &soc_default_info,\n\t},\n\t{}\n};\n\nstatic unsigned int apple_soc_cpufreq_get_rate(unsigned int cpu)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get_raw(cpu);\n\tstruct apple_cpu_priv *priv = policy->driver_data;\n\tstruct cpufreq_frequency_table *p;\n\tunsigned int pstate;\n\n\tif (priv->info->cur_pstate_mask) {\n\t\tu64 reg = readq_relaxed(priv->reg_base + APPLE_DVFS_STATUS);\n\n\t\tpstate = (reg & priv->info->cur_pstate_mask) >>  priv->info->cur_pstate_shift;\n\t} else {\n\t\t \n\t\tu64 reg = readq_relaxed(priv->reg_base + APPLE_DVFS_CMD);\n\n\t\tpstate = FIELD_GET(APPLE_DVFS_CMD_PS1, reg);\n\t}\n\n\tcpufreq_for_each_valid_entry(p, policy->freq_table)\n\t\tif (p->driver_data == pstate)\n\t\t\treturn p->frequency;\n\n\tdev_err(priv->cpu_dev, \"could not find frequency for pstate %d\\n\",\n\t\tpstate);\n\treturn 0;\n}\n\nstatic int apple_soc_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int index)\n{\n\tstruct apple_cpu_priv *priv = policy->driver_data;\n\tunsigned int pstate = policy->freq_table[index].driver_data;\n\tu64 reg;\n\n\t \n\tif (index > priv->info->max_pstate)\n\t\tindex = priv->info->max_pstate;\n\n\tif (readq_poll_timeout_atomic(priv->reg_base + APPLE_DVFS_CMD, reg,\n\t\t\t\t      !(reg & APPLE_DVFS_CMD_BUSY), 2,\n\t\t\t\t      APPLE_DVFS_TRANSITION_TIMEOUT)) {\n\t\treturn -EIO;\n\t}\n\n\treg &= ~(APPLE_DVFS_CMD_PS1 | APPLE_DVFS_CMD_PS2);\n\treg |= FIELD_PREP(APPLE_DVFS_CMD_PS1, pstate);\n\treg |= FIELD_PREP(APPLE_DVFS_CMD_PS2, pstate);\n\treg |= APPLE_DVFS_CMD_SET;\n\n\twriteq_relaxed(reg, priv->reg_base + APPLE_DVFS_CMD);\n\n\treturn 0;\n}\n\nstatic unsigned int apple_soc_cpufreq_fast_switch(struct cpufreq_policy *policy,\n\t\t\t\t\t\t  unsigned int target_freq)\n{\n\tif (apple_soc_cpufreq_set_target(policy, policy->cached_resolved_idx) < 0)\n\t\treturn 0;\n\n\treturn policy->freq_table[policy->cached_resolved_idx].frequency;\n}\n\nstatic int apple_soc_cpufreq_find_cluster(struct cpufreq_policy *policy,\n\t\t\t\t\t  void __iomem **reg_base,\n\t\t\t\t\t  const struct apple_soc_cpufreq_info **info)\n{\n\tstruct of_phandle_args args;\n\tconst struct of_device_id *match;\n\tint ret = 0;\n\n\tret = of_perf_domain_get_sharing_cpumask(policy->cpu, \"performance-domains\",\n\t\t\t\t\t\t \"#performance-domain-cells\",\n\t\t\t\t\t\t policy->cpus, &args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmatch = of_match_node(apple_soc_cpufreq_of_match, args.np);\n\tof_node_put(args.np);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\t*info = match->data;\n\n\t*reg_base = of_iomap(args.np, 0);\n\tif (!*reg_base)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic struct freq_attr *apple_soc_cpufreq_hw_attr[] = {\n\t&cpufreq_freq_attr_scaling_available_freqs,\n\tNULL,  \n\tNULL,\n};\n\nstatic int apple_soc_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tint ret, i;\n\tunsigned int transition_latency;\n\tvoid __iomem *reg_base;\n\tstruct device *cpu_dev;\n\tstruct apple_cpu_priv *priv;\n\tconst struct apple_soc_cpufreq_info *info;\n\tstruct cpufreq_frequency_table *freq_table;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"failed to get cpu%d device\\n\", policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\tret = dev_pm_opp_of_add_table(cpu_dev);\n\tif (ret < 0) {\n\t\tdev_err(cpu_dev, \"%s: failed to add OPP table: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = apple_soc_cpufreq_find_cluster(policy, &reg_base, &info);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"%s: failed to get cluster info: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy->cpus);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"%s: failed to mark OPPs as shared: %d\\n\", __func__, ret);\n\t\tgoto out_iounmap;\n\t}\n\n\tret = dev_pm_opp_get_opp_count(cpu_dev);\n\tif (ret <= 0) {\n\t\tdev_dbg(cpu_dev, \"OPP table is not ready, deferring probe\\n\");\n\t\tret = -EPROBE_DEFER;\n\t\tgoto out_free_opp;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_opp;\n\t}\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\n\tif (ret) {\n\t\tdev_err(cpu_dev, \"failed to init cpufreq table: %d\\n\", ret);\n\t\tgoto out_free_priv;\n\t}\n\n\t \n\tfor (i = 0; freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {\n\t\tunsigned long rate = freq_table[i].frequency * 1000 + 999;\n\t\tstruct dev_pm_opp *opp = dev_pm_opp_find_freq_floor(cpu_dev, &rate);\n\n\t\tif (IS_ERR(opp)) {\n\t\t\tret = PTR_ERR(opp);\n\t\t\tgoto out_free_cpufreq_table;\n\t\t}\n\t\tfreq_table[i].driver_data = dev_pm_opp_get_level(opp);\n\t\tdev_pm_opp_put(opp);\n\t}\n\n\tpriv->cpu_dev = cpu_dev;\n\tpriv->reg_base = reg_base;\n\tpriv->info = info;\n\tpolicy->driver_data = priv;\n\tpolicy->freq_table = freq_table;\n\n\ttransition_latency = dev_pm_opp_get_max_transition_latency(cpu_dev);\n\tif (!transition_latency)\n\t\ttransition_latency = CPUFREQ_ETERNAL;\n\n\tpolicy->cpuinfo.transition_latency = transition_latency;\n\tpolicy->dvfs_possible_from_any_cpu = true;\n\tpolicy->fast_switch_possible = true;\n\tpolicy->suspend_freq = freq_table[0].frequency;\n\n\tif (policy_has_boost_freq(policy)) {\n\t\tret = cpufreq_enable_boost_support();\n\t\tif (ret) {\n\t\t\tdev_warn(cpu_dev, \"failed to enable boost: %d\\n\", ret);\n\t\t} else {\n\t\t\tapple_soc_cpufreq_hw_attr[1] = &cpufreq_freq_attr_scaling_boost_freqs;\n\t\t\tapple_soc_cpufreq_driver.boost_enabled = true;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_free_cpufreq_table:\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\nout_free_priv:\n\tkfree(priv);\nout_free_opp:\n\tdev_pm_opp_remove_all_dynamic(cpu_dev);\nout_iounmap:\n\tiounmap(reg_base);\n\treturn ret;\n}\n\nstatic int apple_soc_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct apple_cpu_priv *priv = policy->driver_data;\n\n\tdev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);\n\tdev_pm_opp_remove_all_dynamic(priv->cpu_dev);\n\tiounmap(priv->reg_base);\n\tkfree(priv);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver apple_soc_cpufreq_driver = {\n\t.name\t\t= \"apple-cpufreq\",\n\t.flags\t\t= CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t\t  CPUFREQ_NEED_INITIAL_FREQ_CHECK | CPUFREQ_IS_COOLING_DEV,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.get\t\t= apple_soc_cpufreq_get_rate,\n\t.init\t\t= apple_soc_cpufreq_init,\n\t.exit\t\t= apple_soc_cpufreq_exit,\n\t.target_index\t= apple_soc_cpufreq_set_target,\n\t.fast_switch\t= apple_soc_cpufreq_fast_switch,\n\t.register_em\t= cpufreq_register_em_with_opp,\n\t.attr\t\t= apple_soc_cpufreq_hw_attr,\n\t.suspend\t= cpufreq_generic_suspend,\n};\n\nstatic int __init apple_soc_cpufreq_module_init(void)\n{\n\tif (!of_machine_is_compatible(\"apple,arm-platform\"))\n\t\treturn -ENODEV;\n\n\treturn cpufreq_register_driver(&apple_soc_cpufreq_driver);\n}\nmodule_init(apple_soc_cpufreq_module_init);\n\nstatic void __exit apple_soc_cpufreq_module_exit(void)\n{\n\tcpufreq_unregister_driver(&apple_soc_cpufreq_driver);\n}\nmodule_exit(apple_soc_cpufreq_module_exit);\n\nMODULE_DEVICE_TABLE(of, apple_soc_cpufreq_of_match);\nMODULE_AUTHOR(\"Hector Martin <marcan@marcan.st>\");\nMODULE_DESCRIPTION(\"Apple SoC CPU cluster DVFS driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}