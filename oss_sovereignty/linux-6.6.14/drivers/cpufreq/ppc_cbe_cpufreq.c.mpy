{
  "module_name": "ppc_cbe_cpufreq.c",
  "hash_id": "e0074512a5caa9754bb0a02cca623bbe7787c75db49b92398e70c7de075cdcde",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/ppc_cbe_cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpufreq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/cell-regs.h>\n\n#include \"ppc_cbe_cpufreq.h\"\n\n \nstatic struct cpufreq_frequency_table cbe_freqs[] = {\n\t{0, 1,\t0},\n\t{0, 2,\t0},\n\t{0, 3,\t0},\n\t{0, 4,\t0},\n\t{0, 5,\t0},\n\t{0, 6,\t0},\n\t{0, 8,\t0},\n\t{0, 10,\t0},\n\t{0, 0,\tCPUFREQ_TABLE_END},\n};\n\n \n\nstatic int set_pmode(unsigned int cpu, unsigned int slow_mode)\n{\n\tint rc;\n\n\tif (cbe_cpufreq_has_pmi)\n\t\trc = cbe_cpufreq_set_pmode_pmi(cpu, slow_mode);\n\telse\n\t\trc = cbe_cpufreq_set_pmode(cpu, slow_mode);\n\n\tpr_debug(\"register contains slow mode %d\\n\", cbe_cpufreq_get_pmode(cpu));\n\n\treturn rc;\n}\n\n \n\nstatic int cbe_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tconst u32 *max_freqp;\n\tu32 max_freq;\n\tint cur_pmode;\n\tstruct device_node *cpu;\n\n\tcpu = of_get_cpu_node(policy->cpu, NULL);\n\n\tif (!cpu)\n\t\treturn -ENODEV;\n\n\tpr_debug(\"init cpufreq on CPU %d\\n\", policy->cpu);\n\n\t \n\tif (!cbe_get_cpu_pmd_regs(policy->cpu) ||\n\t    !cbe_get_cpu_mic_tm_regs(policy->cpu)) {\n\t\tpr_info(\"invalid CBE regs pointers for cpufreq\\n\");\n\t\tof_node_put(cpu);\n\t\treturn -EINVAL;\n\t}\n\n\tmax_freqp = of_get_property(cpu, \"clock-frequency\", NULL);\n\n\tof_node_put(cpu);\n\n\tif (!max_freqp)\n\t\treturn -EINVAL;\n\n\t \n\tmax_freq = *max_freqp / 1000;\n\n\tpr_debug(\"max clock-frequency is at %u kHz\\n\", max_freq);\n\tpr_debug(\"initializing frequency table\\n\");\n\n\t \n\tcpufreq_for_each_entry(pos, cbe_freqs) {\n\t\tpos->frequency = max_freq / pos->driver_data;\n\t\tpr_debug(\"%d: %d\\n\", (int)(pos - cbe_freqs), pos->frequency);\n\t}\n\n\t \n\tpolicy->cpuinfo.transition_latency = 25000;\n\n\tcur_pmode = cbe_cpufreq_get_pmode(policy->cpu);\n\tpr_debug(\"current pmode is at %d\\n\",cur_pmode);\n\n\tpolicy->cur = cbe_freqs[cur_pmode].frequency;\n\n#ifdef CONFIG_SMP\n\tcpumask_copy(policy->cpus, cpu_sibling_mask(policy->cpu));\n#endif\n\n\tpolicy->freq_table = cbe_freqs;\n\tcbe_cpufreq_pmi_policy_init(policy);\n\treturn 0;\n}\n\nstatic int cbe_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\tcbe_cpufreq_pmi_policy_exit(policy);\n\treturn 0;\n}\n\nstatic int cbe_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t      unsigned int cbe_pmode_new)\n{\n\tpr_debug(\"setting frequency for cpu %d to %d kHz, \" \\\n\t\t \"1/%d of max frequency\\n\",\n\t\t policy->cpu,\n\t\t cbe_freqs[cbe_pmode_new].frequency,\n\t\t cbe_freqs[cbe_pmode_new].driver_data);\n\n\treturn set_pmode(policy->cpu, cbe_pmode_new);\n}\n\nstatic struct cpufreq_driver cbe_cpufreq_driver = {\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= cbe_cpufreq_target,\n\t.init\t\t= cbe_cpufreq_cpu_init,\n\t.exit\t\t= cbe_cpufreq_cpu_exit,\n\t.name\t\t= \"cbe-cpufreq\",\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n};\n\n \n\nstatic int __init cbe_cpufreq_init(void)\n{\n\tint ret;\n\n\tif (!machine_is(cell))\n\t\treturn -ENODEV;\n\n\tcbe_cpufreq_pmi_init();\n\n\tret = cpufreq_register_driver(&cbe_cpufreq_driver);\n\tif (ret)\n\t\tcbe_cpufreq_pmi_exit();\n\n\treturn ret;\n}\n\nstatic void __exit cbe_cpufreq_exit(void)\n{\n\tcpufreq_unregister_driver(&cbe_cpufreq_driver);\n\tcbe_cpufreq_pmi_exit();\n}\n\nmodule_init(cbe_cpufreq_init);\nmodule_exit(cbe_cpufreq_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Christian Krafft <krafft@de.ibm.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}