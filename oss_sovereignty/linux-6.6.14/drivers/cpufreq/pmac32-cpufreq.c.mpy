{
  "module_name": "pmac32-cpufreq.c",
  "hash_id": "80069577dd7f94736a87647937b1a7d4949559f2968f2e94ba56197ef0b97a5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/pmac32-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/adb.h>\n#include <linux/pmu.h>\n#include <linux/cpufreq.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/hardirq.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/irq.h>\n#include <asm/pmac_feature.h>\n#include <asm/mmu_context.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/mpic.h>\n#include <asm/keylargo.h>\n#include <asm/switch_to.h>\n\n \n#undef DEBUG_FREQ\n\nextern void low_choose_7447a_dfs(int dfs);\nextern void low_choose_750fx_pll(int pll);\nextern void low_sleep_handler(void);\n\n \nstatic unsigned int low_freq;\nstatic unsigned int hi_freq;\nstatic unsigned int cur_freq;\nstatic unsigned int sleep_freq;\nstatic unsigned long transition_latency;\n\n \nstatic int (*set_speed_proc)(int low_speed);\nstatic unsigned int (*get_speed_proc)(void);\n\n \nstatic u32 voltage_gpio;\nstatic u32 frequency_gpio;\nstatic u32 slew_done_gpio;\nstatic int no_schedule;\nstatic int has_cpu_l2lve;\nstatic int is_pmu_based;\n\n \n#define CPUFREQ_HIGH                  0\n#define CPUFREQ_LOW                   1\n\nstatic struct cpufreq_frequency_table pmac_cpu_freqs[] = {\n\t{0, CPUFREQ_HIGH,\t0},\n\t{0, CPUFREQ_LOW,\t0},\n\t{0, 0,\t\t\tCPUFREQ_TABLE_END},\n};\n\nstatic inline void local_delay(unsigned long ms)\n{\n\tif (no_schedule)\n\t\tmdelay(ms);\n\telse\n\t\tmsleep(ms);\n}\n\n#ifdef DEBUG_FREQ\nstatic inline void debug_calc_bogomips(void)\n{\n\t \n\tunsigned long save_lpj = loops_per_jiffy;\n\tcalibrate_delay();\n\tloops_per_jiffy = save_lpj;\n}\n#endif  \n\n \nstatic int cpu_750fx_cpu_speed(int low_speed)\n{\n\tu32 hid2;\n\n\tif (low_speed == 0) {\n\t\t \n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n\t\t \n\t\tlocal_delay(10);\n\n\t\t \n\t\tif (has_cpu_l2lve) {\n\t\t\thid2 = mfspr(SPRN_HID2);\n\t\t\thid2 &= ~0x2000;\n\t\t\tmtspr(SPRN_HID2, hid2);\n\t\t}\n\t}\n#ifdef CONFIG_PPC_BOOK3S_32\n\tlow_choose_750fx_pll(low_speed);\n#endif\n\tif (low_speed == 1) {\n\t\t \n\t\tif (has_cpu_l2lve) {\n\t\t\thid2 = mfspr(SPRN_HID2);\n\t\t\thid2 |= 0x2000;\n\t\t\tmtspr(SPRN_HID2, hid2);\n\t\t}\n\n\t\t \n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n\t\tlocal_delay(10);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int cpu_750fx_get_cpu_speed(void)\n{\n\tif (mfspr(SPRN_HID1) & HID1_PS)\n\t\treturn low_freq;\n\telse\n\t\treturn hi_freq;\n}\n\n \nstatic int dfs_set_cpu_speed(int low_speed)\n{\n\tif (low_speed == 0) {\n\t\t \n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n\t\t \n\t\tlocal_delay(1);\n\t}\n\n\t \n#ifdef CONFIG_PPC_BOOK3S_32\n\tlow_choose_7447a_dfs(low_speed);\n#endif\n\tudelay(100);\n\n\tif (low_speed == 1) {\n\t\t \n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n\t\tlocal_delay(1);\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int dfs_get_cpu_speed(void)\n{\n\tif (mfspr(SPRN_HID1) & HID1_DFS)\n\t\treturn low_freq;\n\telse\n\t\treturn hi_freq;\n}\n\n\n \nstatic int gpios_set_cpu_speed(int low_speed)\n{\n\tint gpio, timeout = 0;\n\n\t \n\tif (low_speed == 0) {\n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x05);\n\t\t \n\t\tlocal_delay(10);\n\t}\n\n\t \n\tgpio = \tpmac_call_feature(PMAC_FTR_READ_GPIO, NULL, frequency_gpio, 0);\n\tif (low_speed == ((gpio & 0x01) == 0))\n\t\tgoto skip;\n\n\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, frequency_gpio,\n\t\t\t  low_speed ? 0x04 : 0x05);\n\tudelay(200);\n\tdo {\n\t\tif (++timeout > 100)\n\t\t\tbreak;\n\t\tlocal_delay(1);\n\t\tgpio = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, slew_done_gpio, 0);\n\t} while((gpio & 0x02) == 0);\n skip:\n\t \n\tif (low_speed == 1) {\n\t\tpmac_call_feature(PMAC_FTR_WRITE_GPIO, NULL, voltage_gpio, 0x04);\n\t\t \n\t\tlocal_delay(10);\n\t}\n\n#ifdef DEBUG_FREQ\n\tdebug_calc_bogomips();\n#endif\n\n\treturn 0;\n}\n\n \nstatic int pmu_set_cpu_speed(int low_speed)\n{\n\tstruct adb_request req;\n\tunsigned long save_l2cr;\n\tunsigned long save_l3cr;\n\tunsigned int pic_prio;\n\tunsigned long flags;\n\n\tpreempt_disable();\n\n#ifdef DEBUG_FREQ\n\tprintk(KERN_DEBUG \"HID1, before: %x\\n\", mfspr(SPRN_HID1));\n#endif\n\tpmu_suspend();\n\n\t \n \tpic_prio = mpic_cpu_get_priority();\n\tmpic_cpu_set_priority(0xf);\n\n\t \n\tasm volatile(\"mtdec %0\" : : \"r\" (0x7fffffff));\n\t \n\tmb();\n\tasm volatile(\"mtdec %0\" : : \"r\" (0x7fffffff));\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\tenable_kernel_fp();\n\n#ifdef CONFIG_ALTIVEC\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tenable_kernel_altivec();\n#endif  \n\n\t \n\tsave_l3cr = _get_L3CR();\t \n\tsave_l2cr = _get_L2CR();\t \n\n\t \n\tpmu_request(&req, NULL, 6, PMU_CPU_SPEED, 'W', 'O', 'O', 'F', low_speed);\n\twhile (!req.complete)\n\t\tpmu_poll();\n\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,1,1);\n\n\t \n\tlow_sleep_handler();\n\n\t \n\tpmac_call_feature(PMAC_FTR_SLEEP_STATE,NULL,1,0);\n\n\t \n\tif (save_l2cr != 0xffffffff && (save_l2cr & L2CR_L2E) != 0)\n \t\t_set_L2CR(save_l2cr);\n\t \n\tif (save_l3cr != 0xffffffff && (save_l3cr & L3CR_L3E) != 0)\n \t\t_set_L3CR(save_l3cr);\n\n\t \n\tswitch_mmu_context(NULL, current->active_mm, NULL);\n\n#ifdef DEBUG_FREQ\n\tprintk(KERN_DEBUG \"HID1, after: %x\\n\", mfspr(SPRN_HID1));\n#endif\n\n\t \n\tpmu_unlock();\n\n\t \n\tset_dec(1);\n\n\t \n \tmpic_cpu_set_priority(pic_prio);\n\n\t \n\tlocal_irq_restore(flags);\n\n#ifdef DEBUG_FREQ\n\tdebug_calc_bogomips();\n#endif\n\n\tpmu_resume();\n\n\tpreempt_enable();\n\n\treturn 0;\n}\n\nstatic int do_set_cpu_speed(struct cpufreq_policy *policy, int speed_mode)\n{\n\tunsigned long l3cr;\n\tstatic unsigned long prev_l3cr;\n\n\tif (speed_mode == CPUFREQ_LOW &&\n\t    cpu_has_feature(CPU_FTR_L3CR)) {\n\t\tl3cr = _get_L3CR();\n\t\tif (l3cr & L3CR_L3E) {\n\t\t\tprev_l3cr = l3cr;\n\t\t\t_set_L3CR(0);\n\t\t}\n\t}\n\tset_speed_proc(speed_mode == CPUFREQ_LOW);\n\tif (speed_mode == CPUFREQ_HIGH &&\n\t    cpu_has_feature(CPU_FTR_L3CR)) {\n\t\tl3cr = _get_L3CR();\n\t\tif ((prev_l3cr & L3CR_L3E) && l3cr != prev_l3cr)\n\t\t\t_set_L3CR(prev_l3cr);\n\t}\n\tcur_freq = (speed_mode == CPUFREQ_HIGH) ? hi_freq : low_freq;\n\n\treturn 0;\n}\n\nstatic unsigned int pmac_cpufreq_get_speed(unsigned int cpu)\n{\n\treturn cur_freq;\n}\n\nstatic int pmac_cpufreq_target(\tstruct cpufreq_policy *policy,\n\t\t\t\t\tunsigned int index)\n{\n\tint\t\trc;\n\n\trc = do_set_cpu_speed(policy, index);\n\n\tppc_proc_freq = cur_freq * 1000ul;\n\treturn rc;\n}\n\nstatic int pmac_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tcpufreq_generic_init(policy, pmac_cpu_freqs, transition_latency);\n\treturn 0;\n}\n\nstatic u32 read_gpio(struct device_node *np)\n{\n\tconst u32 *reg = of_get_property(np, \"reg\", NULL);\n\tu32 offset;\n\n\tif (reg == NULL)\n\t\treturn 0;\n\t \n\toffset = *reg;\n\tif (offset < KEYLARGO_GPIO_LEVELS0)\n\t\toffset += KEYLARGO_GPIO_LEVELS0;\n\treturn offset;\n}\n\nstatic int pmac_cpufreq_suspend(struct cpufreq_policy *policy)\n{\n\t \n\tno_schedule = 1;\n\tsleep_freq = cur_freq;\n\tif (cur_freq == low_freq && !is_pmu_based)\n\t\tdo_set_cpu_speed(policy, CPUFREQ_HIGH);\n\treturn 0;\n}\n\nstatic int pmac_cpufreq_resume(struct cpufreq_policy *policy)\n{\n\t \n\tif (get_speed_proc)\n\t\tcur_freq = get_speed_proc();\n\telse\n\t\tcur_freq = 0;\n\n\t \n\tdo_set_cpu_speed(policy, sleep_freq == low_freq ?\n\t\t\t CPUFREQ_LOW : CPUFREQ_HIGH);\n\n\tppc_proc_freq = cur_freq * 1000ul;\n\n\tno_schedule = 0;\n\treturn 0;\n}\n\nstatic struct cpufreq_driver pmac_cpufreq_driver = {\n\t.verify \t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= pmac_cpufreq_target,\n\t.get\t\t= pmac_cpufreq_get_speed,\n\t.init\t\t= pmac_cpufreq_cpu_init,\n\t.suspend\t= pmac_cpufreq_suspend,\n\t.resume\t\t= pmac_cpufreq_resume,\n\t.flags\t\t= CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.attr\t\t= cpufreq_generic_attr,\n\t.name\t\t= \"powermac\",\n};\n\n\nstatic int pmac_cpufreq_init_MacRISC3(struct device_node *cpunode)\n{\n\tstruct device_node *volt_gpio_np = of_find_node_by_name(NULL,\n\t\t\t\t\t\t\t\t\"voltage-gpio\");\n\tstruct device_node *freq_gpio_np = of_find_node_by_name(NULL,\n\t\t\t\t\t\t\t\t\"frequency-gpio\");\n\tstruct device_node *slew_done_gpio_np = of_find_node_by_name(NULL,\n\t\t\t\t\t\t\t\t     \"slewing-done\");\n\tconst u32 *value;\n\n\t \n\n\tif (volt_gpio_np)\n\t\tvoltage_gpio = read_gpio(volt_gpio_np);\n\tif (freq_gpio_np)\n\t\tfrequency_gpio = read_gpio(freq_gpio_np);\n\tif (slew_done_gpio_np)\n\t\tslew_done_gpio = read_gpio(slew_done_gpio_np);\n\n\tof_node_put(volt_gpio_np);\n\tof_node_put(freq_gpio_np);\n\tof_node_put(slew_done_gpio_np);\n\n\t \n\tif (frequency_gpio && slew_done_gpio) {\n\t\tint lenp, rc;\n\t\tconst u32 *freqs, *ratio;\n\n\t\tfreqs = of_get_property(cpunode, \"bus-frequencies\", &lenp);\n\t\tlenp /= sizeof(u32);\n\t\tif (freqs == NULL || lenp != 2) {\n\t\t\tpr_err(\"bus-frequencies incorrect or missing\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tratio = of_get_property(cpunode, \"processor-to-bus-ratio*2\",\n\t\t\t\t\t\tNULL);\n\t\tif (ratio == NULL) {\n\t\t\tpr_err(\"processor-to-bus-ratio*2 missing\\n\");\n\t\t\treturn 1;\n\t\t}\n\n\t\t \n\t\tlow_freq = min(freqs[0], freqs[1]);\n\t\thi_freq = max(freqs[0], freqs[1]);\n\n\t\t \n\t\tif (low_freq < 98000000)\n\t\t\tlow_freq = 101000000;\n\n\t\t \n\t\tlow_freq = (low_freq * (*ratio)) / 2000;\n\t\thi_freq = (hi_freq * (*ratio)) / 2000;\n\n\t\t \n\t\trc = pmac_call_feature(PMAC_FTR_READ_GPIO, NULL, frequency_gpio, 0);\n\t\tcur_freq = (rc & 0x01) ? hi_freq : low_freq;\n\n\t\tset_speed_proc = gpios_set_cpu_speed;\n\t\treturn 1;\n\t}\n\n\t \n\tvalue = of_get_property(cpunode, \"min-clock-frequency\", NULL);\n\tif (!value)\n\t\treturn 1;\n\tlow_freq = (*value) / 1000;\n\t \n\tif (low_freq < 100000)\n\t\tlow_freq *= 10;\n\n\tvalue = of_get_property(cpunode, \"max-clock-frequency\", NULL);\n\tif (!value)\n\t\treturn 1;\n\thi_freq = (*value) / 1000;\n\tset_speed_proc = pmu_set_cpu_speed;\n\tis_pmu_based = 1;\n\n\treturn 0;\n}\n\nstatic int pmac_cpufreq_init_7447A(struct device_node *cpunode)\n{\n\tstruct device_node *volt_gpio_np;\n\n\tif (!of_property_read_bool(cpunode, \"dynamic-power-step\"))\n\t\treturn 1;\n\n\tvolt_gpio_np = of_find_node_by_name(NULL, \"cpu-vcore-select\");\n\tif (volt_gpio_np)\n\t\tvoltage_gpio = read_gpio(volt_gpio_np);\n\tof_node_put(volt_gpio_np);\n\tif (!voltage_gpio){\n\t\tpr_err(\"missing cpu-vcore-select gpio\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\thi_freq = cur_freq;\n\tlow_freq = cur_freq/2;\n\n\t \n\tcur_freq = dfs_get_cpu_speed();\n\tset_speed_proc = dfs_set_cpu_speed;\n\tget_speed_proc = dfs_get_cpu_speed;\n\n\treturn 0;\n}\n\nstatic int pmac_cpufreq_init_750FX(struct device_node *cpunode)\n{\n\tstruct device_node *volt_gpio_np;\n\tu32 pvr;\n\tconst u32 *value;\n\n\tif (!of_property_read_bool(cpunode, \"dynamic-power-step\"))\n\t\treturn 1;\n\n\thi_freq = cur_freq;\n\tvalue = of_get_property(cpunode, \"reduced-clock-frequency\", NULL);\n\tif (!value)\n\t\treturn 1;\n\tlow_freq = (*value) / 1000;\n\n\tvolt_gpio_np = of_find_node_by_name(NULL, \"cpu-vcore-select\");\n\tif (volt_gpio_np)\n\t\tvoltage_gpio = read_gpio(volt_gpio_np);\n\n\tof_node_put(volt_gpio_np);\n\tpvr = mfspr(SPRN_PVR);\n\thas_cpu_l2lve = !((pvr & 0xf00) == 0x100);\n\n\tset_speed_proc = cpu_750fx_cpu_speed;\n\tget_speed_proc = cpu_750fx_get_cpu_speed;\n\tcur_freq = cpu_750fx_get_cpu_speed();\n\n\treturn 0;\n}\n\n \nstatic int __init pmac_cpufreq_setup(void)\n{\n\tstruct device_node\t*cpunode;\n\tconst u32\t\t*value;\n\n\tif (strstr(boot_command_line, \"nocpufreq\"))\n\t\treturn 0;\n\n\t \n\tcpunode = of_cpu_device_node_get(0);\n\tif (!cpunode)\n\t\tgoto out;\n\n\t \n\tvalue = of_get_property(cpunode, \"clock-frequency\", NULL);\n\tif (!value)\n\t\tgoto out;\n\tcur_freq = (*value) / 1000;\n\n\t \n\tif (of_machine_is_compatible(\"MacRISC3\") &&\n\t    of_property_read_bool(cpunode, \"dynamic-power-step\") &&\n\t    PVR_VER(mfspr(SPRN_PVR)) == 0x8003) {\n\t\tpmac_cpufreq_init_7447A(cpunode);\n\n\t\t \n\t\ttransition_latency = 8000000;\n\t\tpmac_cpufreq_driver.flags &= ~CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING;\n\t \n\t} else if (of_machine_is_compatible(\"PowerBook3,4\") ||\n\t\t   of_machine_is_compatible(\"PowerBook3,5\") ||\n\t\t   of_machine_is_compatible(\"MacRISC3\")) {\n\t\tpmac_cpufreq_init_MacRISC3(cpunode);\n\t \n\t} else if (of_machine_is_compatible(\"PowerBook4,1\")) {\n\t\thi_freq = cur_freq;\n\t\tlow_freq = 400000;\n\t\tset_speed_proc = pmu_set_cpu_speed;\n\t\tis_pmu_based = 1;\n\t}\n\t \n\telse if (of_machine_is_compatible(\"PowerBook3,3\") && cur_freq == 550000) {\n\t\thi_freq = cur_freq;\n\t\tlow_freq = 500000;\n\t\tset_speed_proc = pmu_set_cpu_speed;\n\t\tis_pmu_based = 1;\n\t}\n\t \n\telse if (of_machine_is_compatible(\"PowerBook3,2\")) {\n\t\t \n\t\tif (cur_freq < 350000 || cur_freq > 550000)\n\t\t\tgoto out;\n\t\thi_freq = cur_freq;\n\t\tlow_freq = 300000;\n\t\tset_speed_proc = pmu_set_cpu_speed;\n\t\tis_pmu_based = 1;\n\t}\n\t \n\telse if (PVR_VER(mfspr(SPRN_PVR)) == 0x7000)\n\t\tpmac_cpufreq_init_750FX(cpunode);\nout:\n\tof_node_put(cpunode);\n\tif (set_speed_proc == NULL)\n\t\treturn -ENODEV;\n\n\tpmac_cpu_freqs[CPUFREQ_LOW].frequency = low_freq;\n\tpmac_cpu_freqs[CPUFREQ_HIGH].frequency = hi_freq;\n\tppc_proc_freq = cur_freq * 1000ul;\n\n\tpr_info(\"Registering PowerMac CPU frequency driver\\n\");\n\tpr_info(\"Low: %d Mhz, High: %d Mhz, Boot: %d Mhz\\n\",\n\t\tlow_freq/1000, hi_freq/1000, cur_freq/1000);\n\n\treturn cpufreq_register_driver(&pmac_cpufreq_driver);\n}\n\nmodule_init(pmac_cpufreq_setup);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}