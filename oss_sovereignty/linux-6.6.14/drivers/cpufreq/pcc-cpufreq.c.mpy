{
  "module_name": "pcc-cpufreq.c",
  "hash_id": "d69d2a87009d87056fbecfb3525d745888dbf88e727a52f39071cb9711787940",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/pcc-cpufreq.c",
  "human_readable_source": " \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/cpufreq.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/platform_device.h>\n\n#include <linux/acpi.h>\n#include <linux/io.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n\n#include <acpi/processor.h>\n\n#define PCC_VERSION\t\"1.10.00\"\n#define POLL_LOOPS \t300\n\n#define CMD_COMPLETE \t0x1\n#define CMD_GET_FREQ \t0x0\n#define CMD_SET_FREQ \t0x1\n\n#define BUF_SZ\t\t4\n\nstruct pcc_register_resource {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 bit_width;\n\tu8 bit_offset;\n\tu8 access_size;\n\tu64 address;\n} __attribute__ ((packed));\n\nstruct pcc_memory_resource {\n\tu8 descriptor;\n\tu16 length;\n\tu8 space_id;\n\tu8 resource_usage;\n\tu8 type_specific;\n\tu64 granularity;\n\tu64 minimum;\n\tu64 maximum;\n\tu64 translation_offset;\n\tu64 address_length;\n} __attribute__ ((packed));\n\nstatic struct cpufreq_driver pcc_cpufreq_driver;\n\nstruct pcc_header {\n\tu32 signature;\n\tu16 length;\n\tu8 major;\n\tu8 minor;\n\tu32 features;\n\tu16 command;\n\tu16 status;\n\tu32 latency;\n\tu32 minimum_time;\n\tu32 maximum_time;\n\tu32 nominal;\n\tu32 throttled_frequency;\n\tu32 minimum_frequency;\n};\n\nstatic void __iomem *pcch_virt_addr;\nstatic struct pcc_header __iomem *pcch_hdr;\n\nstatic DEFINE_SPINLOCK(pcc_lock);\n\nstatic struct acpi_generic_address doorbell;\n\nstatic u64 doorbell_preserve;\nstatic u64 doorbell_write;\n\nstatic u8 OSC_UUID[16] = {0x9F, 0x2C, 0x9B, 0x63, 0x91, 0x70, 0x1f, 0x49,\n\t\t\t  0xBB, 0x4F, 0xA5, 0x98, 0x2F, 0xA1, 0xB5, 0x46};\n\nstruct pcc_cpu {\n\tu32 input_offset;\n\tu32 output_offset;\n};\n\nstatic struct pcc_cpu __percpu *pcc_cpu_info;\n\nstatic int pcc_cpufreq_verify(struct cpufreq_policy_data *policy)\n{\n\tcpufreq_verify_within_cpu_limits(policy);\n\treturn 0;\n}\n\nstatic inline void pcc_cmd(void)\n{\n\tu64 doorbell_value;\n\tint i;\n\n\tacpi_read(&doorbell_value, &doorbell);\n\tacpi_write((doorbell_value & doorbell_preserve) | doorbell_write,\n\t\t   &doorbell);\n\n\tfor (i = 0; i < POLL_LOOPS; i++) {\n\t\tif (ioread16(&pcch_hdr->status) & CMD_COMPLETE)\n\t\t\tbreak;\n\t}\n}\n\nstatic inline void pcc_clear_mapping(void)\n{\n\tif (pcch_virt_addr)\n\t\tiounmap(pcch_virt_addr);\n\tpcch_virt_addr = NULL;\n}\n\nstatic unsigned int pcc_get_freq(unsigned int cpu)\n{\n\tstruct pcc_cpu *pcc_cpu_data;\n\tunsigned int curr_freq;\n\tunsigned int freq_limit;\n\tu16 status;\n\tu32 input_buffer;\n\tu32 output_buffer;\n\n\tspin_lock(&pcc_lock);\n\n\tpr_debug(\"get: get_freq for CPU %d\\n\", cpu);\n\tpcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\n\n\tinput_buffer = 0x1;\n\tiowrite32(input_buffer,\n\t\t\t(pcch_virt_addr + pcc_cpu_data->input_offset));\n\tiowrite16(CMD_GET_FREQ, &pcch_hdr->command);\n\n\tpcc_cmd();\n\n\toutput_buffer =\n\t\tioread32(pcch_virt_addr + pcc_cpu_data->output_offset);\n\n\t \n\tmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\n\n\tstatus = ioread16(&pcch_hdr->status);\n\tif (status != CMD_COMPLETE) {\n\t\tpr_debug(\"get: FAILED: for CPU %d, status is %d\\n\",\n\t\t\tcpu, status);\n\t\tgoto cmd_incomplete;\n\t}\n\tiowrite16(0, &pcch_hdr->status);\n\tcurr_freq = (((ioread32(&pcch_hdr->nominal) * (output_buffer & 0xff))\n\t\t\t/ 100) * 1000);\n\n\tpr_debug(\"get: SUCCESS: (virtual) output_offset for cpu %d is \"\n\t\t\"0x%p, contains a value of: 0x%x. Speed is: %d MHz\\n\",\n\t\tcpu, (pcch_virt_addr + pcc_cpu_data->output_offset),\n\t\toutput_buffer, curr_freq);\n\n\tfreq_limit = (output_buffer >> 8) & 0xff;\n\tif (freq_limit != 0xff) {\n\t\tpr_debug(\"get: frequency for cpu %d is being temporarily\"\n\t\t\t\" capped at %d\\n\", cpu, curr_freq);\n\t}\n\n\tspin_unlock(&pcc_lock);\n\treturn curr_freq;\n\ncmd_incomplete:\n\tiowrite16(0, &pcch_hdr->status);\n\tspin_unlock(&pcc_lock);\n\treturn 0;\n}\n\nstatic int pcc_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t      unsigned int target_freq,\n\t\t\t      unsigned int relation)\n{\n\tstruct pcc_cpu *pcc_cpu_data;\n\tstruct cpufreq_freqs freqs;\n\tu16 status;\n\tu32 input_buffer;\n\tint cpu;\n\n\tcpu = policy->cpu;\n\tpcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\n\n\tpr_debug(\"target: CPU %d should go to target freq: %d \"\n\t\t\"(virtual) input_offset is 0x%p\\n\",\n\t\tcpu, target_freq,\n\t\t(pcch_virt_addr + pcc_cpu_data->input_offset));\n\n\tfreqs.old = policy->cur;\n\tfreqs.new = target_freq;\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\tspin_lock(&pcc_lock);\n\n\tinput_buffer = 0x1 | (((target_freq * 100)\n\t\t\t       / (ioread32(&pcch_hdr->nominal) * 1000)) << 8);\n\tiowrite32(input_buffer,\n\t\t\t(pcch_virt_addr + pcc_cpu_data->input_offset));\n\tiowrite16(CMD_SET_FREQ, &pcch_hdr->command);\n\n\tpcc_cmd();\n\n\t \n\tmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\n\n\tstatus = ioread16(&pcch_hdr->status);\n\tiowrite16(0, &pcch_hdr->status);\n\n\tspin_unlock(&pcc_lock);\n\tcpufreq_freq_transition_end(policy, &freqs, status != CMD_COMPLETE);\n\n\tif (status != CMD_COMPLETE) {\n\t\tpr_debug(\"target: FAILED for cpu %d, with status: 0x%x\\n\",\n\t\t\tcpu, status);\n\t\treturn -EINVAL;\n\t}\n\n\tpr_debug(\"target: was SUCCESSFUL for cpu %d\\n\", cpu);\n\n\treturn 0;\n}\n\nstatic int pcc_get_offset(int cpu)\n{\n\tacpi_status status;\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object *pccp, *offset;\n\tstruct pcc_cpu *pcc_cpu_data;\n\tstruct acpi_processor *pr;\n\tint ret = 0;\n\n\tpr = per_cpu(processors, cpu);\n\tpcc_cpu_data = per_cpu_ptr(pcc_cpu_info, cpu);\n\n\tif (!pr)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_evaluate_object(pr->handle, \"PCCP\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tpccp = buffer.pointer;\n\tif (!pccp || pccp->type != ACPI_TYPE_PACKAGE) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\toffset = &(pccp->package.elements[0]);\n\tif (!offset || offset->type != ACPI_TYPE_INTEGER) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tpcc_cpu_data->input_offset = offset->integer.value;\n\n\toffset = &(pccp->package.elements[1]);\n\tif (!offset || offset->type != ACPI_TYPE_INTEGER) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tpcc_cpu_data->output_offset = offset->integer.value;\n\n\tmemset_io((pcch_virt_addr + pcc_cpu_data->input_offset), 0, BUF_SZ);\n\tmemset_io((pcch_virt_addr + pcc_cpu_data->output_offset), 0, BUF_SZ);\n\n\tpr_debug(\"pcc_get_offset: for CPU %d: pcc_cpu_data \"\n\t\t\"input_offset: 0x%x, pcc_cpu_data output_offset: 0x%x\\n\",\n\t\tcpu, pcc_cpu_data->input_offset, pcc_cpu_data->output_offset);\nout_free:\n\tkfree(buffer.pointer);\n\treturn ret;\n}\n\nstatic int __init pcc_cpufreq_do_osc(acpi_handle *handle)\n{\n\tacpi_status status;\n\tstruct acpi_object_list input;\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tunion acpi_object in_params[4];\n\tunion acpi_object *out_obj;\n\tu32 capabilities[2];\n\tu32 errors;\n\tu32 supported;\n\tint ret = 0;\n\n\tinput.count = 4;\n\tinput.pointer = in_params;\n\tin_params[0].type               = ACPI_TYPE_BUFFER;\n\tin_params[0].buffer.length      = 16;\n\tin_params[0].buffer.pointer     = OSC_UUID;\n\tin_params[1].type               = ACPI_TYPE_INTEGER;\n\tin_params[1].integer.value      = 1;\n\tin_params[2].type               = ACPI_TYPE_INTEGER;\n\tin_params[2].integer.value      = 2;\n\tin_params[3].type               = ACPI_TYPE_BUFFER;\n\tin_params[3].buffer.length      = 8;\n\tin_params[3].buffer.pointer     = (u8 *)&capabilities;\n\n\tcapabilities[0] = OSC_QUERY_ENABLE;\n\tcapabilities[1] = 0x1;\n\n\tstatus = acpi_evaluate_object(*handle, \"_OSC\", &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tif (!output.length)\n\t\treturn -ENODEV;\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_BUFFER) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\terrors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);\n\tif (errors) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tsupported = *((u32 *)(out_obj->buffer.pointer + 4));\n\tif (!(supported & 0x1)) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tkfree(output.pointer);\n\tcapabilities[0] = 0x0;\n\tcapabilities[1] = 0x1;\n\n\tstatus = acpi_evaluate_object(*handle, \"_OSC\", &input, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tif (!output.length)\n\t\treturn -ENODEV;\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_BUFFER) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\terrors = *((u32 *)out_obj->buffer.pointer) & ~(1 << 0);\n\tif (errors) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tsupported = *((u32 *)(out_obj->buffer.pointer + 4));\n\tif (!(supported & 0x1)) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(output.pointer);\n\treturn ret;\n}\n\nstatic int __init pcc_cpufreq_evaluate(void)\n{\n\tacpi_status status;\n\tstruct acpi_buffer output = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct pcc_memory_resource *mem_resource;\n\tstruct pcc_register_resource *reg_resource;\n\tunion acpi_object *out_obj, *member;\n\tacpi_handle handle, osc_handle;\n\tint ret = 0;\n\n\tstatus = acpi_get_handle(NULL, \"\\\\_SB\", &handle);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tif (!acpi_has_method(handle, \"PCCH\"))\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_handle(handle, \"_OSC\", &osc_handle);\n\tif (ACPI_SUCCESS(status)) {\n\t\tret = pcc_cpufreq_do_osc(&osc_handle);\n\t\tif (ret)\n\t\t\tpr_debug(\"probe: _OSC evaluation did not succeed\\n\");\n\t\t \n\t\tret = 0;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, \"PCCH\", NULL, &output);\n\tif (ACPI_FAILURE(status))\n\t\treturn -ENODEV;\n\n\tout_obj = output.pointer;\n\tif (out_obj->type != ACPI_TYPE_PACKAGE) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tmember = &out_obj->package.elements[0];\n\tif (member->type != ACPI_TYPE_BUFFER) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tmem_resource = (struct pcc_memory_resource *)member->buffer.pointer;\n\n\tpr_debug(\"probe: mem_resource descriptor: 0x%x,\"\n\t\t\" length: %d, space_id: %d, resource_usage: %d,\"\n\t\t\" type_specific: %d, granularity: 0x%llx,\"\n\t\t\" minimum: 0x%llx, maximum: 0x%llx,\"\n\t\t\" translation_offset: 0x%llx, address_length: 0x%llx\\n\",\n\t\tmem_resource->descriptor, mem_resource->length,\n\t\tmem_resource->space_id, mem_resource->resource_usage,\n\t\tmem_resource->type_specific, mem_resource->granularity,\n\t\tmem_resource->minimum, mem_resource->maximum,\n\t\tmem_resource->translation_offset,\n\t\tmem_resource->address_length);\n\n\tif (mem_resource->space_id != ACPI_ADR_SPACE_SYSTEM_MEMORY) {\n\t\tret = -ENODEV;\n\t\tgoto out_free;\n\t}\n\n\tpcch_virt_addr = ioremap(mem_resource->minimum,\n\t\t\t\t\tmem_resource->address_length);\n\tif (pcch_virt_addr == NULL) {\n\t\tpr_debug(\"probe: could not map shared mem region\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\tpcch_hdr = pcch_virt_addr;\n\n\tpr_debug(\"probe: PCCH header (virtual) addr: 0x%p\\n\", pcch_hdr);\n\tpr_debug(\"probe: PCCH header is at physical address: 0x%llx,\"\n\t\t\" signature: 0x%x, length: %d bytes, major: %d, minor: %d,\"\n\t\t\" supported features: 0x%x, command field: 0x%x,\"\n\t\t\" status field: 0x%x, nominal latency: %d us\\n\",\n\t\tmem_resource->minimum, ioread32(&pcch_hdr->signature),\n\t\tioread16(&pcch_hdr->length), ioread8(&pcch_hdr->major),\n\t\tioread8(&pcch_hdr->minor), ioread32(&pcch_hdr->features),\n\t\tioread16(&pcch_hdr->command), ioread16(&pcch_hdr->status),\n\t\tioread32(&pcch_hdr->latency));\n\n\tpr_debug(\"probe: min time between commands: %d us,\"\n\t\t\" max time between commands: %d us,\"\n\t\t\" nominal CPU frequency: %d MHz,\"\n\t\t\" minimum CPU frequency: %d MHz,\"\n\t\t\" minimum CPU frequency without throttling: %d MHz\\n\",\n\t\tioread32(&pcch_hdr->minimum_time),\n\t\tioread32(&pcch_hdr->maximum_time),\n\t\tioread32(&pcch_hdr->nominal),\n\t\tioread32(&pcch_hdr->throttled_frequency),\n\t\tioread32(&pcch_hdr->minimum_frequency));\n\n\tmember = &out_obj->package.elements[1];\n\tif (member->type != ACPI_TYPE_BUFFER) {\n\t\tret = -ENODEV;\n\t\tgoto pcch_free;\n\t}\n\n\treg_resource = (struct pcc_register_resource *)member->buffer.pointer;\n\n\tdoorbell.space_id = reg_resource->space_id;\n\tdoorbell.bit_width = reg_resource->bit_width;\n\tdoorbell.bit_offset = reg_resource->bit_offset;\n\tdoorbell.access_width = 4;\n\tdoorbell.address = reg_resource->address;\n\n\tpr_debug(\"probe: doorbell: space_id is %d, bit_width is %d, \"\n\t\t\"bit_offset is %d, access_width is %d, address is 0x%llx\\n\",\n\t\tdoorbell.space_id, doorbell.bit_width, doorbell.bit_offset,\n\t\tdoorbell.access_width, reg_resource->address);\n\n\tmember = &out_obj->package.elements[2];\n\tif (member->type != ACPI_TYPE_INTEGER) {\n\t\tret = -ENODEV;\n\t\tgoto pcch_free;\n\t}\n\n\tdoorbell_preserve = member->integer.value;\n\n\tmember = &out_obj->package.elements[3];\n\tif (member->type != ACPI_TYPE_INTEGER) {\n\t\tret = -ENODEV;\n\t\tgoto pcch_free;\n\t}\n\n\tdoorbell_write = member->integer.value;\n\n\tpr_debug(\"probe: doorbell_preserve: 0x%llx,\"\n\t\t\" doorbell_write: 0x%llx\\n\",\n\t\tdoorbell_preserve, doorbell_write);\n\n\tpcc_cpu_info = alloc_percpu(struct pcc_cpu);\n\tif (!pcc_cpu_info) {\n\t\tret = -ENOMEM;\n\t\tgoto pcch_free;\n\t}\n\n\tprintk(KERN_DEBUG \"pcc-cpufreq: (v%s) driver loaded with frequency\"\n\t       \" limits: %d MHz, %d MHz\\n\", PCC_VERSION,\n\t       ioread32(&pcch_hdr->minimum_frequency),\n\t       ioread32(&pcch_hdr->nominal));\n\tkfree(output.pointer);\n\treturn ret;\npcch_free:\n\tpcc_clear_mapping();\nout_free:\n\tkfree(output.pointer);\n\treturn ret;\n}\n\nstatic int pcc_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\tunsigned int result = 0;\n\n\tif (!pcch_virt_addr) {\n\t\tresult = -1;\n\t\tgoto out;\n\t}\n\n\tresult = pcc_get_offset(cpu);\n\tif (result) {\n\t\tpr_debug(\"init: PCCP evaluation failed\\n\");\n\t\tgoto out;\n\t}\n\n\tpolicy->max = policy->cpuinfo.max_freq =\n\t\tioread32(&pcch_hdr->nominal) * 1000;\n\tpolicy->min = policy->cpuinfo.min_freq =\n\t\tioread32(&pcch_hdr->minimum_frequency) * 1000;\n\n\tpr_debug(\"init: policy->max is %d, policy->min is %d\\n\",\n\t\tpolicy->max, policy->min);\nout:\n\treturn result;\n}\n\nstatic int pcc_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\treturn 0;\n}\n\nstatic struct cpufreq_driver pcc_cpufreq_driver = {\n\t.flags = CPUFREQ_CONST_LOOPS,\n\t.get = pcc_get_freq,\n\t.verify = pcc_cpufreq_verify,\n\t.target = pcc_cpufreq_target,\n\t.init = pcc_cpufreq_cpu_init,\n\t.exit = pcc_cpufreq_cpu_exit,\n\t.name = \"pcc-cpufreq\",\n};\n\nstatic int __init pcc_cpufreq_probe(struct platform_device *pdev)\n{\n\tint ret;\n\n\t \n\tif (cpufreq_get_current_driver())\n\t\treturn -ENODEV;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tret = pcc_cpufreq_evaluate();\n\tif (ret) {\n\t\tpr_debug(\"pcc_cpufreq_probe: PCCH evaluation failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (num_present_cpus() > 4) {\n\t\tpcc_cpufreq_driver.flags |= CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING;\n\t\tpr_err(\"%s: Too many CPUs, dynamic performance scaling disabled\\n\",\n\t\t       __func__);\n\t\tpr_err(\"%s: Try to enable another scaling driver through BIOS settings\\n\",\n\t\t       __func__);\n\t\tpr_err(\"%s: and complain to the system vendor\\n\", __func__);\n\t}\n\n\tret = cpufreq_register_driver(&pcc_cpufreq_driver);\n\n\treturn ret;\n}\n\nstatic void pcc_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&pcc_cpufreq_driver);\n\n\tpcc_clear_mapping();\n\n\tfree_percpu(pcc_cpu_info);\n}\n\nstatic struct platform_driver pcc_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"pcc-cpufreq\",\n\t},\n\t.remove_new\t= pcc_cpufreq_remove,\n};\n\nstatic int __init pcc_cpufreq_init(void)\n{\n\treturn platform_driver_probe(&pcc_cpufreq_platdrv, pcc_cpufreq_probe);\n}\n\nstatic void __exit pcc_cpufreq_exit(void)\n{\n\tplatform_driver_unregister(&pcc_cpufreq_platdrv);\n}\n\nMODULE_ALIAS(\"platform:pcc-cpufreq\");\n\nMODULE_AUTHOR(\"Matthew Garrett, Naga Chumbalkar\");\nMODULE_VERSION(PCC_VERSION);\nMODULE_DESCRIPTION(\"Processor Clocking Control interface driver\");\nMODULE_LICENSE(\"GPL\");\n\nlate_initcall(pcc_cpufreq_init);\nmodule_exit(pcc_cpufreq_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}