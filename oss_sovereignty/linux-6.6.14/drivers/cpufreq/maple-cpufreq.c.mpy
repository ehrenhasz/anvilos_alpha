{
  "module_name": "maple-cpufreq.c",
  "hash_id": "11b8a9f788f0e2479f5ea183de06be9c42fb41d3afb552597237f62ba0aad119",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/maple-cpufreq.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/cpufreq.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/of.h>\n\n#define DBG(fmt...) pr_debug(fmt)\n\n \n\n#define SCOM_PCR 0x0aa001\t\t\t \n\n#define PCR_HILO_SELECT\t\t0x80000000U\t \n#define PCR_SPEED_FULL\t\t0x00000000U\t \n#define PCR_SPEED_HALF\t\t0x00020000U\t \n#define PCR_SPEED_QUARTER\t0x00040000U\t \n#define PCR_SPEED_MASK\t\t0x000e0000U\t \n#define PCR_SPEED_SHIFT\t\t17\n#define PCR_FREQ_REQ_VALID\t0x00010000U\t \n#define PCR_VOLT_REQ_VALID\t0x00008000U\t \n#define PCR_TARGET_TIME_MASK\t0x00006000U\t \n#define PCR_STATLAT_MASK\t0x00001f00U\t \n#define PCR_SNOOPLAT_MASK\t0x000000f0U\t \n#define PCR_SNOOPACC_MASK\t0x0000000fU\t \n\n#define SCOM_PSR 0x408001\t\t\t \n \n#define PSR_CMD_RECEIVED\t0x2000000000000000U    \n#define PSR_CMD_COMPLETED\t0x1000000000000000U    \n#define PSR_CUR_SPEED_MASK\t0x0300000000000000U    \n#define PSR_CUR_SPEED_SHIFT\t(56)\n\n \n#define CPUFREQ_HIGH                  0\n#define CPUFREQ_LOW                   1\n\nstatic struct cpufreq_frequency_table maple_cpu_freqs[] = {\n\t{0, CPUFREQ_HIGH,\t\t0},\n\t{0, CPUFREQ_LOW,\t\t0},\n\t{0, 0,\t\t\t\tCPUFREQ_TABLE_END},\n};\n\n \nstatic int maple_pmode_cur;\n\nstatic const u32 *maple_pmode_data;\nstatic int maple_pmode_max;\n\n \nstatic int maple_scom_switch_freq(int speed_mode)\n{\n\tunsigned long flags;\n\tint to;\n\n\tlocal_irq_save(flags);\n\n\t \n\tscom970_write(SCOM_PCR, 0);\n\t \n\tscom970_write(SCOM_PCR, PCR_HILO_SELECT | 0);\n\t \n\tscom970_write(SCOM_PCR, PCR_HILO_SELECT |\n\t\t      maple_pmode_data[speed_mode]);\n\n\t \n\tfor (to = 0; to < 10; to++) {\n\t\tunsigned long psr = scom970_read(SCOM_PSR);\n\n\t\tif ((psr & PSR_CMD_RECEIVED) == 0 &&\n\t\t    (((psr >> PSR_CUR_SPEED_SHIFT) ^\n\t\t      (maple_pmode_data[speed_mode] >> PCR_SPEED_SHIFT)) & 0x3)\n\t\t    == 0)\n\t\t\tbreak;\n\t\tif (psr & PSR_CMD_COMPLETED)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tmaple_pmode_cur = speed_mode;\n\tppc_proc_freq = maple_cpu_freqs[speed_mode].frequency * 1000ul;\n\n\treturn 0;\n}\n\nstatic int maple_scom_query_freq(void)\n{\n\tunsigned long psr = scom970_read(SCOM_PSR);\n\tint i;\n\n\tfor (i = 0; i <= maple_pmode_max; i++)\n\t\tif ((((psr >> PSR_CUR_SPEED_SHIFT) ^\n\t\t      (maple_pmode_data[i] >> PCR_SPEED_SHIFT)) & 0x3) == 0)\n\t\t\tbreak;\n\treturn i;\n}\n\n \n\nstatic int maple_cpufreq_target(struct cpufreq_policy *policy,\n\tunsigned int index)\n{\n\treturn maple_scom_switch_freq(index);\n}\n\nstatic unsigned int maple_cpufreq_get_speed(unsigned int cpu)\n{\n\treturn maple_cpu_freqs[maple_pmode_cur].frequency;\n}\n\nstatic int maple_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tcpufreq_generic_init(policy, maple_cpu_freqs, 12000);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver maple_cpufreq_driver = {\n\t.name\t\t= \"maple\",\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.init\t\t= maple_cpufreq_cpu_init,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= maple_cpufreq_target,\n\t.get\t\t= maple_cpufreq_get_speed,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic int __init maple_cpufreq_init(void)\n{\n\tstruct device_node *cpunode;\n\tunsigned int psize;\n\tunsigned long max_freq;\n\tconst u32 *valp;\n\tu32 pvr_hi;\n\tint rc = -ENODEV;\n\n\t \n\tif (!of_machine_is_compatible(\"Momentum,Maple\") &&\n\t    !of_machine_is_compatible(\"Momentum,Apache\"))\n\t\treturn 0;\n\n\t \n\tcpunode = of_cpu_device_node_get(0);\n\tif (cpunode == NULL) {\n\t\tpr_err(\"Can't find any CPU 0 node\\n\");\n\t\tgoto bail_noprops;\n\t}\n\n\t \n\t \n\tpvr_hi = PVR_VER(mfspr(SPRN_PVR));\n\tif (pvr_hi != 0x3c && pvr_hi != 0x44) {\n\t\tpr_err(\"Unsupported CPU version (%x)\\n\", pvr_hi);\n\t\tgoto bail_noprops;\n\t}\n\n\t \n\t \n\tmaple_pmode_data = of_get_property(cpunode, \"power-mode-data\", &psize);\n\tif (!maple_pmode_data) {\n\t\tDBG(\"No power-mode-data !\\n\");\n\t\tgoto bail_noprops;\n\t}\n\tmaple_pmode_max = psize / sizeof(u32) - 1;\n\n\t \n\tvalp = of_get_property(cpunode, \"clock-frequency\", NULL);\n\tif (!valp)\n\t\tgoto bail_noprops;\n\tmax_freq = (*valp)/1000;\n\tmaple_cpu_freqs[0].frequency = max_freq;\n\tmaple_cpu_freqs[1].frequency = max_freq/2;\n\n\t \n\tmsleep(10);\n\tmaple_pmode_cur = -1;\n\tmaple_scom_switch_freq(maple_scom_query_freq());\n\n\tpr_info(\"Registering Maple CPU frequency driver\\n\");\n\tpr_info(\"Low: %d Mhz, High: %d Mhz, Cur: %d MHz\\n\",\n\t\tmaple_cpu_freqs[1].frequency/1000,\n\t\tmaple_cpu_freqs[0].frequency/1000,\n\t\tmaple_cpu_freqs[maple_pmode_cur].frequency/1000);\n\n\trc = cpufreq_register_driver(&maple_cpufreq_driver);\n\nbail_noprops:\n\tof_node_put(cpunode);\n\n\treturn rc;\n}\n\nmodule_init(maple_cpufreq_init);\n\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}