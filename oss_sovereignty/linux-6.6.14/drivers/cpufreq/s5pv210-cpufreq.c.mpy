{
  "module_name": "s5pv210-cpufreq.c",
  "hash_id": "a120cbfb359661d342569bf1d874a6bbb1bcad35bbbb95e3484d6e889b2f510d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/s5pv210-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/cpufreq.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reboot.h>\n#include <linux/regulator/consumer.h>\n\nstatic void __iomem *clk_base;\nstatic void __iomem *dmc_base[2];\n\n#define S5P_CLKREG(x)\t\t(clk_base + (x))\n\n#define S5P_APLL_LOCK\t\tS5P_CLKREG(0x00)\n#define S5P_APLL_CON\t\tS5P_CLKREG(0x100)\n#define S5P_CLK_SRC0\t\tS5P_CLKREG(0x200)\n#define S5P_CLK_SRC2\t\tS5P_CLKREG(0x208)\n#define S5P_CLK_DIV0\t\tS5P_CLKREG(0x300)\n#define S5P_CLK_DIV2\t\tS5P_CLKREG(0x308)\n#define S5P_CLK_DIV6\t\tS5P_CLKREG(0x318)\n#define S5P_CLKDIV_STAT0\tS5P_CLKREG(0x1000)\n#define S5P_CLKDIV_STAT1\tS5P_CLKREG(0x1004)\n#define S5P_CLKMUX_STAT0\tS5P_CLKREG(0x1100)\n#define S5P_CLKMUX_STAT1\tS5P_CLKREG(0x1104)\n\n#define S5P_ARM_MCS_CON\t\tS5P_CLKREG(0x6100)\n\n \n#define S5P_CLKSRC0_MUX200_SHIFT\t(16)\n#define S5P_CLKSRC0_MUX200_MASK\t\t(0x1 << S5P_CLKSRC0_MUX200_SHIFT)\n#define S5P_CLKSRC0_MUX166_MASK\t\t(0x1<<20)\n#define S5P_CLKSRC0_MUX133_MASK\t\t(0x1<<24)\n\n \n#define S5P_CLKSRC2_G3D_SHIFT           (0)\n#define S5P_CLKSRC2_G3D_MASK            (0x3 << S5P_CLKSRC2_G3D_SHIFT)\n#define S5P_CLKSRC2_MFC_SHIFT           (4)\n#define S5P_CLKSRC2_MFC_MASK            (0x3 << S5P_CLKSRC2_MFC_SHIFT)\n\n \n#define S5P_CLKDIV0_APLL_SHIFT\t\t(0)\n#define S5P_CLKDIV0_APLL_MASK\t\t(0x7 << S5P_CLKDIV0_APLL_SHIFT)\n#define S5P_CLKDIV0_A2M_SHIFT\t\t(4)\n#define S5P_CLKDIV0_A2M_MASK\t\t(0x7 << S5P_CLKDIV0_A2M_SHIFT)\n#define S5P_CLKDIV0_HCLK200_SHIFT\t(8)\n#define S5P_CLKDIV0_HCLK200_MASK\t(0x7 << S5P_CLKDIV0_HCLK200_SHIFT)\n#define S5P_CLKDIV0_PCLK100_SHIFT\t(12)\n#define S5P_CLKDIV0_PCLK100_MASK\t(0x7 << S5P_CLKDIV0_PCLK100_SHIFT)\n#define S5P_CLKDIV0_HCLK166_SHIFT\t(16)\n#define S5P_CLKDIV0_HCLK166_MASK\t(0xF << S5P_CLKDIV0_HCLK166_SHIFT)\n#define S5P_CLKDIV0_PCLK83_SHIFT\t(20)\n#define S5P_CLKDIV0_PCLK83_MASK\t\t(0x7 << S5P_CLKDIV0_PCLK83_SHIFT)\n#define S5P_CLKDIV0_HCLK133_SHIFT\t(24)\n#define S5P_CLKDIV0_HCLK133_MASK\t(0xF << S5P_CLKDIV0_HCLK133_SHIFT)\n#define S5P_CLKDIV0_PCLK66_SHIFT\t(28)\n#define S5P_CLKDIV0_PCLK66_MASK\t\t(0x7 << S5P_CLKDIV0_PCLK66_SHIFT)\n\n \n#define S5P_CLKDIV2_G3D_SHIFT           (0)\n#define S5P_CLKDIV2_G3D_MASK            (0xF << S5P_CLKDIV2_G3D_SHIFT)\n#define S5P_CLKDIV2_MFC_SHIFT           (4)\n#define S5P_CLKDIV2_MFC_MASK            (0xF << S5P_CLKDIV2_MFC_SHIFT)\n\n \n#define S5P_CLKDIV6_ONEDRAM_SHIFT       (28)\n#define S5P_CLKDIV6_ONEDRAM_MASK        (0xF << S5P_CLKDIV6_ONEDRAM_SHIFT)\n\nstatic struct clk *dmc0_clk;\nstatic struct clk *dmc1_clk;\nstatic DEFINE_MUTEX(set_freq_lock);\n\n \n#define APLL_VAL_1000\t((1 << 31) | (125 << 16) | (3 << 8) | 1)\n#define APLL_VAL_800\t((1 << 31) | (100 << 16) | (3 << 8) | 1)\n\n \n#define SLEEP_FREQ\t(800 * 1000)\n\n \nstatic bool no_cpufreq_access;\n\n \nstruct dram_conf {\n\tunsigned long freq;\t \n\tunsigned long refresh;\t \n};\n\n \nstatic struct dram_conf s5pv210_dram_conf[2];\n\nenum perf_level {\n\tL0, L1, L2, L3, L4,\n};\n\nenum s5pv210_mem_type {\n\tLPDDR\t= 0x1,\n\tLPDDR2\t= 0x2,\n\tDDR2\t= 0x4,\n};\n\nenum s5pv210_dmc_port {\n\tDMC0 = 0,\n\tDMC1,\n};\n\nstatic struct cpufreq_frequency_table s5pv210_freq_table[] = {\n\t{0, L0, 1000*1000},\n\t{0, L1, 800*1000},\n\t{0, L2, 400*1000},\n\t{0, L3, 200*1000},\n\t{0, L4, 100*1000},\n\t{0, 0, CPUFREQ_TABLE_END},\n};\n\nstatic struct regulator *arm_regulator;\nstatic struct regulator *int_regulator;\n\nstruct s5pv210_dvs_conf {\n\tint arm_volt;\t \n\tint int_volt;\t \n};\n\nstatic const int arm_volt_max = 1350000;\nstatic const int int_volt_max = 1250000;\n\nstatic struct s5pv210_dvs_conf dvs_conf[] = {\n\t[L0] = {\n\t\t.arm_volt\t= 1250000,\n\t\t.int_volt\t= 1100000,\n\t},\n\t[L1] = {\n\t\t.arm_volt\t= 1200000,\n\t\t.int_volt\t= 1100000,\n\t},\n\t[L2] = {\n\t\t.arm_volt\t= 1050000,\n\t\t.int_volt\t= 1100000,\n\t},\n\t[L3] = {\n\t\t.arm_volt\t= 950000,\n\t\t.int_volt\t= 1100000,\n\t},\n\t[L4] = {\n\t\t.arm_volt\t= 950000,\n\t\t.int_volt\t= 1000000,\n\t},\n};\n\nstatic u32 clkdiv_val[5][11] = {\n\t \n\n\t \n\t{0, 4, 4, 1, 3, 1, 4, 1, 3, 0, 0},\n\n\t \n\t{0, 3, 3, 1, 3, 1, 4, 1, 3, 0, 0},\n\n\t \n\t{1, 3, 1, 1, 3, 1, 4, 1, 3, 0, 0},\n\n\t \n\t{3, 3, 1, 1, 3, 1, 4, 1, 3, 0, 0},\n\n\t \n\t{7, 7, 0, 0, 7, 0, 9, 0, 7, 0, 0},\n};\n\n \nstatic void s5pv210_set_refresh(enum s5pv210_dmc_port ch, unsigned long freq)\n{\n\tunsigned long tmp, tmp1;\n\tvoid __iomem *reg = NULL;\n\n\tif (ch == DMC0) {\n\t\treg = (dmc_base[0] + 0x30);\n\t} else if (ch == DMC1) {\n\t\treg = (dmc_base[1] + 0x30);\n\t} else {\n\t\tpr_err(\"Cannot find DMC port\\n\");\n\t\treturn;\n\t}\n\n\t \n\ttmp = s5pv210_dram_conf[ch].freq;\n\n\ttmp /= freq;\n\n\ttmp1 = s5pv210_dram_conf[ch].refresh;\n\n\ttmp1 /= tmp;\n\n\twritel_relaxed(tmp1, reg);\n}\n\nstatic int s5pv210_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tunsigned long reg;\n\tunsigned int priv_index;\n\tunsigned int pll_changing = 0;\n\tunsigned int bus_speed_changing = 0;\n\tunsigned int old_freq, new_freq;\n\tint arm_volt, int_volt;\n\tint ret = 0;\n\n\tmutex_lock(&set_freq_lock);\n\n\tif (no_cpufreq_access) {\n\t\tpr_err(\"Denied access to %s as it is disabled temporarily\\n\",\n\t\t       __func__);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\told_freq = policy->cur;\n\tnew_freq = s5pv210_freq_table[index].frequency;\n\n\t \n\tpriv_index = cpufreq_table_find_index_h(policy, old_freq, false);\n\n\tarm_volt = dvs_conf[index].arm_volt;\n\tint_volt = dvs_conf[index].int_volt;\n\n\tif (new_freq > old_freq) {\n\t\tret = regulator_set_voltage(arm_regulator,\n\t\t\t\tarm_volt, arm_volt_max);\n\t\tif (ret)\n\t\t\tgoto exit;\n\n\t\tret = regulator_set_voltage(int_regulator,\n\t\t\t\tint_volt, int_volt_max);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\t \n\tif ((index == L0) || (priv_index == L0))\n\t\tpll_changing = 1;\n\n\t \n\tif ((index == L4) || (priv_index == L4))\n\t\tbus_speed_changing = 1;\n\n\tif (bus_speed_changing) {\n\t\t \n\t\tif (pll_changing)\n\t\t\ts5pv210_set_refresh(DMC1, 83000);\n\t\telse\n\t\t\ts5pv210_set_refresh(DMC1, 100000);\n\n\t\ts5pv210_set_refresh(DMC0, 83000);\n\t}\n\n\t \n\tif (pll_changing) {\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_DIV2);\n\t\treg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\n\t\treg |= (3 << S5P_CLKDIV2_G3D_SHIFT) |\n\t\t\t(3 << S5P_CLKDIV2_MFC_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_DIV2);\n\n\t\t \n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKDIV_STAT0);\n\t\t} while (reg & ((1 << 16) | (1 << 17)));\n\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_SRC2);\n\t\treg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\n\t\treg |= (1 << S5P_CLKSRC2_G3D_SHIFT) |\n\t\t\t(1 << S5P_CLKSRC2_MFC_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_SRC2);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKMUX_STAT1);\n\t\t} while (reg & ((1 << 7) | (1 << 3)));\n\n\t\t \n\t\tif (!bus_speed_changing)\n\t\t\ts5pv210_set_refresh(DMC1, 133000);\n\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_SRC0);\n\t\treg &= ~(S5P_CLKSRC0_MUX200_MASK);\n\t\treg |= (0x1 << S5P_CLKSRC0_MUX200_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_SRC0);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKMUX_STAT0);\n\t\t} while (reg & (0x1 << 18));\n\n\t}\n\n\t \n\treg = readl_relaxed(S5P_CLK_DIV0);\n\n\treg &= ~(S5P_CLKDIV0_APLL_MASK | S5P_CLKDIV0_A2M_MASK |\n\t\tS5P_CLKDIV0_HCLK200_MASK | S5P_CLKDIV0_PCLK100_MASK |\n\t\tS5P_CLKDIV0_HCLK166_MASK | S5P_CLKDIV0_PCLK83_MASK |\n\t\tS5P_CLKDIV0_HCLK133_MASK | S5P_CLKDIV0_PCLK66_MASK);\n\n\treg |= ((clkdiv_val[index][0] << S5P_CLKDIV0_APLL_SHIFT) |\n\t\t(clkdiv_val[index][1] << S5P_CLKDIV0_A2M_SHIFT) |\n\t\t(clkdiv_val[index][2] << S5P_CLKDIV0_HCLK200_SHIFT) |\n\t\t(clkdiv_val[index][3] << S5P_CLKDIV0_PCLK100_SHIFT) |\n\t\t(clkdiv_val[index][4] << S5P_CLKDIV0_HCLK166_SHIFT) |\n\t\t(clkdiv_val[index][5] << S5P_CLKDIV0_PCLK83_SHIFT) |\n\t\t(clkdiv_val[index][6] << S5P_CLKDIV0_HCLK133_SHIFT) |\n\t\t(clkdiv_val[index][7] << S5P_CLKDIV0_PCLK66_SHIFT));\n\n\twritel_relaxed(reg, S5P_CLK_DIV0);\n\n\tdo {\n\t\treg = readl_relaxed(S5P_CLKDIV_STAT0);\n\t} while (reg & 0xff);\n\n\t \n\treg = readl_relaxed(S5P_ARM_MCS_CON);\n\treg &= ~0x3;\n\tif (index >= L3)\n\t\treg |= 0x3;\n\telse\n\t\treg |= 0x1;\n\n\twritel_relaxed(reg, S5P_ARM_MCS_CON);\n\n\tif (pll_changing) {\n\t\t \n\t\twritel_relaxed(0x2cf, S5P_APLL_LOCK);\n\n\t\t \n\t\tif (index == L0)\n\t\t\twritel_relaxed(APLL_VAL_1000, S5P_APLL_CON);\n\t\telse\n\t\t\twritel_relaxed(APLL_VAL_800, S5P_APLL_CON);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_APLL_CON);\n\t\t} while (!(reg & (0x1 << 29)));\n\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_SRC2);\n\t\treg &= ~(S5P_CLKSRC2_G3D_MASK | S5P_CLKSRC2_MFC_MASK);\n\t\treg |= (0 << S5P_CLKSRC2_G3D_SHIFT) |\n\t\t\t(0 << S5P_CLKSRC2_MFC_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_SRC2);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKMUX_STAT1);\n\t\t} while (reg & ((1 << 7) | (1 << 3)));\n\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_DIV2);\n\t\treg &= ~(S5P_CLKDIV2_G3D_MASK | S5P_CLKDIV2_MFC_MASK);\n\t\treg |= (clkdiv_val[index][10] << S5P_CLKDIV2_G3D_SHIFT) |\n\t\t\t(clkdiv_val[index][9] << S5P_CLKDIV2_MFC_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_DIV2);\n\n\t\t \n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKDIV_STAT0);\n\t\t} while (reg & ((1 << 16) | (1 << 17)));\n\n\t\t \n\t\treg = readl_relaxed(S5P_CLK_SRC0);\n\t\treg &= ~(S5P_CLKSRC0_MUX200_MASK);\n\t\treg |= (0x0 << S5P_CLKSRC0_MUX200_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_SRC0);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKMUX_STAT0);\n\t\t} while (reg & (0x1 << 18));\n\n\t\t \n\t\tif (!bus_speed_changing)\n\t\t\ts5pv210_set_refresh(DMC1, 200000);\n\t}\n\n\t \n\tif (bus_speed_changing) {\n\t\treg = readl_relaxed(S5P_CLK_DIV6);\n\t\treg &= ~S5P_CLKDIV6_ONEDRAM_MASK;\n\t\treg |= (clkdiv_val[index][8] << S5P_CLKDIV6_ONEDRAM_SHIFT);\n\t\twritel_relaxed(reg, S5P_CLK_DIV6);\n\n\t\tdo {\n\t\t\treg = readl_relaxed(S5P_CLKDIV_STAT1);\n\t\t} while (reg & (1 << 15));\n\n\t\t \n\t\tif (index != L4) {\n\t\t\t \n\t\t\ts5pv210_set_refresh(DMC0, 166000);\n\t\t\ts5pv210_set_refresh(DMC1, 200000);\n\t\t} else {\n\t\t\t \n\t\t\ts5pv210_set_refresh(DMC0, 83000);\n\t\t\ts5pv210_set_refresh(DMC1, 100000);\n\t\t}\n\t}\n\n\tif (new_freq < old_freq) {\n\t\tregulator_set_voltage(int_regulator,\n\t\t\t\tint_volt, int_volt_max);\n\n\t\tregulator_set_voltage(arm_regulator,\n\t\t\t\tarm_volt, arm_volt_max);\n\t}\n\n\tpr_debug(\"Perf changed[L%d]\\n\", index);\n\nexit:\n\tmutex_unlock(&set_freq_lock);\n\treturn ret;\n}\n\nstatic int check_mem_type(void __iomem *dmc_reg)\n{\n\tunsigned long val;\n\n\tval = readl_relaxed(dmc_reg + 0x4);\n\tval = (val & (0xf << 8));\n\n\treturn val >> 8;\n}\n\nstatic int s5pv210_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned long mem_type;\n\tint ret;\n\n\tpolicy->clk = clk_get(NULL, \"armclk\");\n\tif (IS_ERR(policy->clk))\n\t\treturn PTR_ERR(policy->clk);\n\n\tdmc0_clk = clk_get(NULL, \"sclk_dmc0\");\n\tif (IS_ERR(dmc0_clk)) {\n\t\tret = PTR_ERR(dmc0_clk);\n\t\tgoto out_dmc0;\n\t}\n\n\tdmc1_clk = clk_get(NULL, \"hclk_msys\");\n\tif (IS_ERR(dmc1_clk)) {\n\t\tret = PTR_ERR(dmc1_clk);\n\t\tgoto out_dmc1;\n\t}\n\n\tif (policy->cpu != 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_dmc1;\n\t}\n\n\t \n\tmem_type = check_mem_type(dmc_base[0]);\n\n\tif ((mem_type != LPDDR) && (mem_type != LPDDR2)) {\n\t\tpr_err(\"CPUFreq doesn't support this memory type\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_dmc1;\n\t}\n\n\t \n\ts5pv210_dram_conf[0].refresh = (readl_relaxed(dmc_base[0] + 0x30) * 1000);\n\ts5pv210_dram_conf[0].freq = clk_get_rate(dmc0_clk);\n\n\ts5pv210_dram_conf[1].refresh = (readl_relaxed(dmc_base[1] + 0x30) * 1000);\n\ts5pv210_dram_conf[1].freq = clk_get_rate(dmc1_clk);\n\n\tpolicy->suspend_freq = SLEEP_FREQ;\n\tcpufreq_generic_init(policy, s5pv210_freq_table, 40000);\n\treturn 0;\n\nout_dmc1:\n\tclk_put(dmc0_clk);\nout_dmc0:\n\tclk_put(policy->clk);\n\treturn ret;\n}\n\nstatic int s5pv210_cpufreq_reboot_notifier_event(struct notifier_block *this,\n\t\t\t\t\t\t unsigned long event, void *ptr)\n{\n\tint ret;\n\tstruct cpufreq_policy *policy;\n\n\tpolicy = cpufreq_cpu_get(0);\n\tif (!policy) {\n\t\tpr_debug(\"cpufreq: get no policy for cpu0\\n\");\n\t\treturn NOTIFY_BAD;\n\t}\n\n\tret = cpufreq_driver_target(policy, SLEEP_FREQ, 0);\n\tcpufreq_cpu_put(policy);\n\n\tif (ret < 0)\n\t\treturn NOTIFY_BAD;\n\n\tno_cpufreq_access = true;\n\treturn NOTIFY_DONE;\n}\n\nstatic struct cpufreq_driver s5pv210_driver = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= s5pv210_target,\n\t.get\t\t= cpufreq_generic_get,\n\t.init\t\t= s5pv210_cpu_init,\n\t.name\t\t= \"s5pv210\",\n\t.suspend\t= cpufreq_generic_suspend,\n\t.resume\t\t= cpufreq_generic_suspend,  \n};\n\nstatic struct notifier_block s5pv210_cpufreq_reboot_notifier = {\n\t.notifier_call = s5pv210_cpufreq_reboot_notifier_event,\n};\n\nstatic int s5pv210_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np;\n\tint id, result = 0;\n\n\t \n\tarm_regulator = regulator_get(NULL, \"vddarm\");\n\tif (IS_ERR(arm_regulator))\n\t\treturn dev_err_probe(dev, PTR_ERR(arm_regulator),\n\t\t\t\t     \"failed to get regulator vddarm\\n\");\n\n\tint_regulator = regulator_get(NULL, \"vddint\");\n\tif (IS_ERR(int_regulator)) {\n\t\tresult = dev_err_probe(dev, PTR_ERR(int_regulator),\n\t\t\t\t       \"failed to get regulator vddint\\n\");\n\t\tgoto err_int_regulator;\n\t}\n\n\tnp = of_find_compatible_node(NULL, NULL, \"samsung,s5pv210-clock\");\n\tif (!np) {\n\t\tdev_err(dev, \"failed to find clock controller DT node\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto err_clock;\n\t}\n\n\tclk_base = of_iomap(np, 0);\n\tof_node_put(np);\n\tif (!clk_base) {\n\t\tdev_err(dev, \"failed to map clock registers\\n\");\n\t\tresult = -EFAULT;\n\t\tgoto err_clock;\n\t}\n\n\tfor_each_compatible_node(np, NULL, \"samsung,s5pv210-dmc\") {\n\t\tid = of_alias_get_id(np, \"dmc\");\n\t\tif (id < 0 || id >= ARRAY_SIZE(dmc_base)) {\n\t\t\tdev_err(dev, \"failed to get alias of dmc node '%pOFn'\\n\", np);\n\t\t\tof_node_put(np);\n\t\t\tresult = id;\n\t\t\tgoto err_clk_base;\n\t\t}\n\n\t\tdmc_base[id] = of_iomap(np, 0);\n\t\tif (!dmc_base[id]) {\n\t\t\tdev_err(dev, \"failed to map dmc%d registers\\n\", id);\n\t\t\tof_node_put(np);\n\t\t\tresult = -EFAULT;\n\t\t\tgoto err_dmc;\n\t\t}\n\t}\n\n\tfor (id = 0; id < ARRAY_SIZE(dmc_base); ++id) {\n\t\tif (!dmc_base[id]) {\n\t\t\tdev_err(dev, \"failed to find dmc%d node\\n\", id);\n\t\t\tresult = -ENODEV;\n\t\t\tgoto err_dmc;\n\t\t}\n\t}\n\n\tregister_reboot_notifier(&s5pv210_cpufreq_reboot_notifier);\n\n\treturn cpufreq_register_driver(&s5pv210_driver);\n\nerr_dmc:\n\tfor (id = 0; id < ARRAY_SIZE(dmc_base); ++id)\n\t\tif (dmc_base[id]) {\n\t\t\tiounmap(dmc_base[id]);\n\t\t\tdmc_base[id] = NULL;\n\t\t}\n\nerr_clk_base:\n\tiounmap(clk_base);\n\nerr_clock:\n\tregulator_put(int_regulator);\n\nerr_int_regulator:\n\tregulator_put(arm_regulator);\n\n\treturn result;\n}\n\nstatic struct platform_driver s5pv210_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"s5pv210-cpufreq\",\n\t},\n\t.probe = s5pv210_cpufreq_probe,\n};\nbuiltin_platform_driver(s5pv210_cpufreq_platdrv);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}