{
  "module_name": "kirkwood-cpufreq.c",
  "hash_id": "a5443c968f70d458bcaec03d720f771641d279aebe47d7f41d7c0a00574e8fdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/kirkwood-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/cpufreq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <asm/proc-fns.h>\n\n#define CPU_SW_INT_BLK BIT(28)\n\nstatic struct priv\n{\n\tstruct clk *cpu_clk;\n\tstruct clk *ddr_clk;\n\tstruct clk *powersave_clk;\n\tstruct device *dev;\n\tvoid __iomem *base;\n} priv;\n\n#define STATE_CPU_FREQ 0x01\n#define STATE_DDR_FREQ 0x02\n\n \nstatic struct cpufreq_frequency_table kirkwood_freq_table[] = {\n\t{0, STATE_CPU_FREQ,\t0},  \n\t{0, STATE_DDR_FREQ,\t0},  \n\t{0, 0,\t\t\tCPUFREQ_TABLE_END},\n};\n\nstatic unsigned int kirkwood_cpufreq_get_cpu_frequency(unsigned int cpu)\n{\n\treturn clk_get_rate(priv.powersave_clk) / 1000;\n}\n\nstatic int kirkwood_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t    unsigned int index)\n{\n\tunsigned int state = kirkwood_freq_table[index].driver_data;\n\tunsigned long reg;\n\n\tlocal_irq_disable();\n\n\t \n\treg = readl_relaxed(priv.base);\n\treg |= CPU_SW_INT_BLK;\n\twritel_relaxed(reg, priv.base);\n\n\tswitch (state) {\n\tcase STATE_CPU_FREQ:\n\t\tclk_set_parent(priv.powersave_clk, priv.cpu_clk);\n\t\tbreak;\n\tcase STATE_DDR_FREQ:\n\t\tclk_set_parent(priv.powersave_clk, priv.ddr_clk);\n\t\tbreak;\n\t}\n\n\t \n\tcpu_do_idle();\n\n\t \n\treg = readl_relaxed(priv.base);\n\treg &= ~CPU_SW_INT_BLK;\n\twritel_relaxed(reg, priv.base);\n\n\tlocal_irq_enable();\n\n\treturn 0;\n}\n\n \nstatic int kirkwood_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tcpufreq_generic_init(policy, kirkwood_freq_table, 5000);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver kirkwood_cpufreq_driver = {\n\t.flags\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.get\t= kirkwood_cpufreq_get_cpu_frequency,\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.target_index = kirkwood_cpufreq_target,\n\t.init\t= kirkwood_cpufreq_cpu_init,\n\t.name\t= \"kirkwood-cpufreq\",\n\t.attr\t= cpufreq_generic_attr,\n};\n\nstatic int kirkwood_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np;\n\tint err;\n\n\tpriv.dev = &pdev->dev;\n\n\tpriv.base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(priv.base))\n\t\treturn PTR_ERR(priv.base);\n\n\tnp = of_cpu_device_node_get(0);\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"failed to get cpu device node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv.cpu_clk = of_clk_get_by_name(np, \"cpu_clk\");\n\tif (IS_ERR(priv.cpu_clk)) {\n\t\tdev_err(priv.dev, \"Unable to get cpuclk\\n\");\n\t\terr = PTR_ERR(priv.cpu_clk);\n\t\tgoto out_node;\n\t}\n\n\terr = clk_prepare_enable(priv.cpu_clk);\n\tif (err) {\n\t\tdev_err(priv.dev, \"Unable to prepare cpuclk\\n\");\n\t\tgoto out_node;\n\t}\n\n\tkirkwood_freq_table[0].frequency = clk_get_rate(priv.cpu_clk) / 1000;\n\n\tpriv.ddr_clk = of_clk_get_by_name(np, \"ddrclk\");\n\tif (IS_ERR(priv.ddr_clk)) {\n\t\tdev_err(priv.dev, \"Unable to get ddrclk\\n\");\n\t\terr = PTR_ERR(priv.ddr_clk);\n\t\tgoto out_cpu;\n\t}\n\n\terr = clk_prepare_enable(priv.ddr_clk);\n\tif (err) {\n\t\tdev_err(priv.dev, \"Unable to prepare ddrclk\\n\");\n\t\tgoto out_cpu;\n\t}\n\tkirkwood_freq_table[1].frequency = clk_get_rate(priv.ddr_clk) / 1000;\n\n\tpriv.powersave_clk = of_clk_get_by_name(np, \"powersave\");\n\tif (IS_ERR(priv.powersave_clk)) {\n\t\tdev_err(priv.dev, \"Unable to get powersave\\n\");\n\t\terr = PTR_ERR(priv.powersave_clk);\n\t\tgoto out_ddr;\n\t}\n\terr = clk_prepare_enable(priv.powersave_clk);\n\tif (err) {\n\t\tdev_err(priv.dev, \"Unable to prepare powersave clk\\n\");\n\t\tgoto out_ddr;\n\t}\n\n\terr = cpufreq_register_driver(&kirkwood_cpufreq_driver);\n\tif (err) {\n\t\tdev_err(priv.dev, \"Failed to register cpufreq driver\\n\");\n\t\tgoto out_powersave;\n\t}\n\n\tof_node_put(np);\n\treturn 0;\n\nout_powersave:\n\tclk_disable_unprepare(priv.powersave_clk);\nout_ddr:\n\tclk_disable_unprepare(priv.ddr_clk);\nout_cpu:\n\tclk_disable_unprepare(priv.cpu_clk);\nout_node:\n\tof_node_put(np);\n\n\treturn err;\n}\n\nstatic void kirkwood_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&kirkwood_cpufreq_driver);\n\n\tclk_disable_unprepare(priv.powersave_clk);\n\tclk_disable_unprepare(priv.ddr_clk);\n\tclk_disable_unprepare(priv.cpu_clk);\n}\n\nstatic struct platform_driver kirkwood_cpufreq_platform_driver = {\n\t.probe = kirkwood_cpufreq_probe,\n\t.remove_new = kirkwood_cpufreq_remove,\n\t.driver = {\n\t\t.name = \"kirkwood-cpufreq\",\n\t},\n};\n\nmodule_platform_driver(kirkwood_cpufreq_platform_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch\");\nMODULE_DESCRIPTION(\"cpufreq driver for Marvell's kirkwood CPU\");\nMODULE_ALIAS(\"platform:kirkwood-cpufreq\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}