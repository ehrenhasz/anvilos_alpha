{
  "module_name": "cpufreq_ondemand.c",
  "hash_id": "84047906eea9fac32db069bf3f4abdee8048f5b8a1c245431fe5fd3444bc64d0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq_ondemand.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/cpu.h>\n#include <linux/percpu-defs.h>\n#include <linux/slab.h>\n#include <linux/tick.h>\n#include <linux/sched/cpufreq.h>\n\n#include \"cpufreq_ondemand.h\"\n\n \n#define DEF_FREQUENCY_UP_THRESHOLD\t\t(80)\n#define DEF_SAMPLING_DOWN_FACTOR\t\t(1)\n#define MAX_SAMPLING_DOWN_FACTOR\t\t(100000)\n#define MICRO_FREQUENCY_UP_THRESHOLD\t\t(95)\n#define MICRO_FREQUENCY_MIN_SAMPLE_RATE\t\t(10000)\n#define MIN_FREQUENCY_UP_THRESHOLD\t\t(1)\n#define MAX_FREQUENCY_UP_THRESHOLD\t\t(100)\n\nstatic struct od_ops od_ops;\n\nstatic unsigned int default_powersave_bias;\n\n \nstatic int should_io_be_busy(void)\n{\n#if defined(CONFIG_X86)\n\t \n\tif (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&\n\t\t\tboot_cpu_data.x86 == 6 &&\n\t\t\tboot_cpu_data.x86_model >= 15)\n\t\treturn 1;\n#endif\n\treturn 0;\n}\n\n \nstatic unsigned int generic_powersave_bias_target(struct cpufreq_policy *policy,\n\t\tunsigned int freq_next, unsigned int relation)\n{\n\tunsigned int freq_req, freq_reduc, freq_avg;\n\tunsigned int freq_hi, freq_lo;\n\tunsigned int index;\n\tunsigned int delay_hi_us;\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\n\tstruct cpufreq_frequency_table *freq_table = policy->freq_table;\n\n\tif (!freq_table) {\n\t\tdbs_info->freq_lo = 0;\n\t\tdbs_info->freq_lo_delay_us = 0;\n\t\treturn freq_next;\n\t}\n\n\tindex = cpufreq_frequency_table_target(policy, freq_next, relation);\n\tfreq_req = freq_table[index].frequency;\n\tfreq_reduc = freq_req * od_tuners->powersave_bias / 1000;\n\tfreq_avg = freq_req - freq_reduc;\n\n\t \n\tindex = cpufreq_table_find_index_h(policy, freq_avg,\n\t\t\t\t\t   relation & CPUFREQ_RELATION_E);\n\tfreq_lo = freq_table[index].frequency;\n\tindex = cpufreq_table_find_index_l(policy, freq_avg,\n\t\t\t\t\t   relation & CPUFREQ_RELATION_E);\n\tfreq_hi = freq_table[index].frequency;\n\n\t \n\tif (freq_hi == freq_lo) {\n\t\tdbs_info->freq_lo = 0;\n\t\tdbs_info->freq_lo_delay_us = 0;\n\t\treturn freq_lo;\n\t}\n\tdelay_hi_us = (freq_avg - freq_lo) * dbs_data->sampling_rate;\n\tdelay_hi_us += (freq_hi - freq_lo) / 2;\n\tdelay_hi_us /= freq_hi - freq_lo;\n\tdbs_info->freq_hi_delay_us = delay_hi_us;\n\tdbs_info->freq_lo = freq_lo;\n\tdbs_info->freq_lo_delay_us = dbs_data->sampling_rate - delay_hi_us;\n\treturn freq_hi;\n}\n\nstatic void ondemand_powersave_bias_init(struct cpufreq_policy *policy)\n{\n\tstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy->governor_data);\n\n\tdbs_info->freq_lo = 0;\n}\n\nstatic void dbs_freq_increase(struct cpufreq_policy *policy, unsigned int freq)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\n\n\tif (od_tuners->powersave_bias)\n\t\tfreq = od_ops.powersave_bias_target(policy, freq,\n\t\t\t\t\t\t    CPUFREQ_RELATION_HE);\n\telse if (policy->cur == policy->max)\n\t\treturn;\n\n\t__cpufreq_driver_target(policy, freq, od_tuners->powersave_bias ?\n\t\t\tCPUFREQ_RELATION_LE : CPUFREQ_RELATION_HE);\n}\n\n \nstatic void od_update(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\n\tunsigned int load = dbs_update(policy);\n\n\tdbs_info->freq_lo = 0;\n\n\t \n\tif (load > dbs_data->up_threshold) {\n\t\t \n\t\tif (policy->cur < policy->max)\n\t\t\tpolicy_dbs->rate_mult = dbs_data->sampling_down_factor;\n\t\tdbs_freq_increase(policy, policy->max);\n\t} else {\n\t\t \n\t\tunsigned int freq_next, min_f, max_f;\n\n\t\tmin_f = policy->cpuinfo.min_freq;\n\t\tmax_f = policy->cpuinfo.max_freq;\n\t\tfreq_next = min_f + load * (max_f - min_f) / 100;\n\n\t\t \n\t\tpolicy_dbs->rate_mult = 1;\n\n\t\tif (od_tuners->powersave_bias)\n\t\t\tfreq_next = od_ops.powersave_bias_target(policy,\n\t\t\t\t\t\t\t\t freq_next,\n\t\t\t\t\t\t\t\t CPUFREQ_RELATION_LE);\n\n\t\t__cpufreq_driver_target(policy, freq_next, CPUFREQ_RELATION_CE);\n\t}\n}\n\nstatic unsigned int od_dbs_update(struct cpufreq_policy *policy)\n{\n\tstruct policy_dbs_info *policy_dbs = policy->governor_data;\n\tstruct dbs_data *dbs_data = policy_dbs->dbs_data;\n\tstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);\n\tint sample_type = dbs_info->sample_type;\n\n\t \n\tdbs_info->sample_type = OD_NORMAL_SAMPLE;\n\t \n\tif (sample_type == OD_SUB_SAMPLE && policy_dbs->sample_delay_ns > 0) {\n\t\t__cpufreq_driver_target(policy, dbs_info->freq_lo,\n\t\t\t\t\tCPUFREQ_RELATION_HE);\n\t\treturn dbs_info->freq_lo_delay_us;\n\t}\n\n\tod_update(policy);\n\n\tif (dbs_info->freq_lo) {\n\t\t \n\t\tdbs_info->sample_type = OD_SUB_SAMPLE;\n\t\treturn dbs_info->freq_hi_delay_us;\n\t}\n\n\treturn dbs_data->sampling_rate * policy_dbs->rate_mult;\n}\n\n \nstatic struct dbs_governor od_dbs_gov;\n\nstatic ssize_t io_is_busy_store(struct gov_attr_set *attr_set, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\tdbs_data->io_is_busy = !!input;\n\n\t \n\tgov_update_cpu_data(dbs_data);\n\n\treturn count;\n}\n\nstatic ssize_t up_threshold_store(struct gov_attr_set *attr_set,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1 || input > MAX_FREQUENCY_UP_THRESHOLD ||\n\t\t\tinput < MIN_FREQUENCY_UP_THRESHOLD) {\n\t\treturn -EINVAL;\n\t}\n\n\tdbs_data->up_threshold = input;\n\treturn count;\n}\n\nstatic ssize_t sampling_down_factor_store(struct gov_attr_set *attr_set,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct policy_dbs_info *policy_dbs;\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR || input < 1)\n\t\treturn -EINVAL;\n\n\tdbs_data->sampling_down_factor = input;\n\n\t \n\tlist_for_each_entry(policy_dbs, &attr_set->policy_list, list) {\n\t\t \n\t\tmutex_lock(&policy_dbs->update_mutex);\n\t\tpolicy_dbs->rate_mult = 1;\n\t\tmutex_unlock(&policy_dbs->update_mutex);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t ignore_nice_load_store(struct gov_attr_set *attr_set,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tunsigned int input;\n\tint ret;\n\n\tret = sscanf(buf, \"%u\", &input);\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (input > 1)\n\t\tinput = 1;\n\n\tif (input == dbs_data->ignore_nice_load) {  \n\t\treturn count;\n\t}\n\tdbs_data->ignore_nice_load = input;\n\n\t \n\tgov_update_cpu_data(dbs_data);\n\n\treturn count;\n}\n\nstatic ssize_t powersave_bias_store(struct gov_attr_set *attr_set,\n\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct dbs_data *dbs_data = to_dbs_data(attr_set);\n\tstruct od_dbs_tuners *od_tuners = dbs_data->tuners;\n\tstruct policy_dbs_info *policy_dbs;\n\tunsigned int input;\n\tint ret;\n\tret = sscanf(buf, \"%u\", &input);\n\n\tif (ret != 1)\n\t\treturn -EINVAL;\n\n\tif (input > 1000)\n\t\tinput = 1000;\n\n\tod_tuners->powersave_bias = input;\n\n\tlist_for_each_entry(policy_dbs, &attr_set->policy_list, list)\n\t\tondemand_powersave_bias_init(policy_dbs->policy);\n\n\treturn count;\n}\n\ngov_show_one_common(sampling_rate);\ngov_show_one_common(up_threshold);\ngov_show_one_common(sampling_down_factor);\ngov_show_one_common(ignore_nice_load);\ngov_show_one_common(io_is_busy);\ngov_show_one(od, powersave_bias);\n\ngov_attr_rw(sampling_rate);\ngov_attr_rw(io_is_busy);\ngov_attr_rw(up_threshold);\ngov_attr_rw(sampling_down_factor);\ngov_attr_rw(ignore_nice_load);\ngov_attr_rw(powersave_bias);\n\nstatic struct attribute *od_attrs[] = {\n\t&sampling_rate.attr,\n\t&up_threshold.attr,\n\t&sampling_down_factor.attr,\n\t&ignore_nice_load.attr,\n\t&powersave_bias.attr,\n\t&io_is_busy.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(od);\n\n \n\nstatic struct policy_dbs_info *od_alloc(void)\n{\n\tstruct od_policy_dbs_info *dbs_info;\n\n\tdbs_info = kzalloc(sizeof(*dbs_info), GFP_KERNEL);\n\treturn dbs_info ? &dbs_info->policy_dbs : NULL;\n}\n\nstatic void od_free(struct policy_dbs_info *policy_dbs)\n{\n\tkfree(to_dbs_info(policy_dbs));\n}\n\nstatic int od_init(struct dbs_data *dbs_data)\n{\n\tstruct od_dbs_tuners *tuners;\n\tu64 idle_time;\n\tint cpu;\n\n\ttuners = kzalloc(sizeof(*tuners), GFP_KERNEL);\n\tif (!tuners)\n\t\treturn -ENOMEM;\n\n\tcpu = get_cpu();\n\tidle_time = get_cpu_idle_time_us(cpu, NULL);\n\tput_cpu();\n\tif (idle_time != -1ULL) {\n\t\t \n\t\tdbs_data->up_threshold = MICRO_FREQUENCY_UP_THRESHOLD;\n\t} else {\n\t\tdbs_data->up_threshold = DEF_FREQUENCY_UP_THRESHOLD;\n\t}\n\n\tdbs_data->sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;\n\tdbs_data->ignore_nice_load = 0;\n\ttuners->powersave_bias = default_powersave_bias;\n\tdbs_data->io_is_busy = should_io_be_busy();\n\n\tdbs_data->tuners = tuners;\n\treturn 0;\n}\n\nstatic void od_exit(struct dbs_data *dbs_data)\n{\n\tkfree(dbs_data->tuners);\n}\n\nstatic void od_start(struct cpufreq_policy *policy)\n{\n\tstruct od_policy_dbs_info *dbs_info = to_dbs_info(policy->governor_data);\n\n\tdbs_info->sample_type = OD_NORMAL_SAMPLE;\n\tondemand_powersave_bias_init(policy);\n}\n\nstatic struct od_ops od_ops = {\n\t.powersave_bias_target = generic_powersave_bias_target,\n};\n\nstatic struct dbs_governor od_dbs_gov = {\n\t.gov = CPUFREQ_DBS_GOVERNOR_INITIALIZER(\"ondemand\"),\n\t.kobj_type = { .default_groups = od_groups },\n\t.gov_dbs_update = od_dbs_update,\n\t.alloc = od_alloc,\n\t.free = od_free,\n\t.init = od_init,\n\t.exit = od_exit,\n\t.start = od_start,\n};\n\n#define CPU_FREQ_GOV_ONDEMAND\t(od_dbs_gov.gov)\n\nstatic void od_set_powersave_bias(unsigned int powersave_bias)\n{\n\tunsigned int cpu;\n\tcpumask_var_t done;\n\n\tif (!alloc_cpumask_var(&done, GFP_KERNEL))\n\t\treturn;\n\n\tdefault_powersave_bias = powersave_bias;\n\tcpumask_clear(done);\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(cpu) {\n\t\tstruct cpufreq_policy *policy;\n\t\tstruct policy_dbs_info *policy_dbs;\n\t\tstruct dbs_data *dbs_data;\n\t\tstruct od_dbs_tuners *od_tuners;\n\n\t\tif (cpumask_test_cpu(cpu, done))\n\t\t\tcontinue;\n\n\t\tpolicy = cpufreq_cpu_get_raw(cpu);\n\t\tif (!policy || policy->governor != &CPU_FREQ_GOV_ONDEMAND)\n\t\t\tcontinue;\n\n\t\tpolicy_dbs = policy->governor_data;\n\t\tif (!policy_dbs)\n\t\t\tcontinue;\n\n\t\tcpumask_or(done, done, policy->cpus);\n\n\t\tdbs_data = policy_dbs->dbs_data;\n\t\tod_tuners = dbs_data->tuners;\n\t\tod_tuners->powersave_bias = default_powersave_bias;\n\t}\n\tcpus_read_unlock();\n\n\tfree_cpumask_var(done);\n}\n\nvoid od_register_powersave_bias_handler(unsigned int (*f)\n\t\t(struct cpufreq_policy *, unsigned int, unsigned int),\n\t\tunsigned int powersave_bias)\n{\n\tod_ops.powersave_bias_target = f;\n\tod_set_powersave_bias(powersave_bias);\n}\nEXPORT_SYMBOL_GPL(od_register_powersave_bias_handler);\n\nvoid od_unregister_powersave_bias_handler(void)\n{\n\tod_ops.powersave_bias_target = generic_powersave_bias_target;\n\tod_set_powersave_bias(0);\n}\nEXPORT_SYMBOL_GPL(od_unregister_powersave_bias_handler);\n\nMODULE_AUTHOR(\"Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>\");\nMODULE_AUTHOR(\"Alexey Starikovskiy <alexey.y.starikovskiy@intel.com>\");\nMODULE_DESCRIPTION(\"'cpufreq_ondemand' - A dynamic cpufreq governor for \"\n\t\"Low Latency Frequency Transition capable processors\");\nMODULE_LICENSE(\"GPL\");\n\n#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND\nstruct cpufreq_governor *cpufreq_default_governor(void)\n{\n\treturn &CPU_FREQ_GOV_ONDEMAND;\n}\n#endif\n\ncpufreq_governor_init(CPU_FREQ_GOV_ONDEMAND);\ncpufreq_governor_exit(CPU_FREQ_GOV_ONDEMAND);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}