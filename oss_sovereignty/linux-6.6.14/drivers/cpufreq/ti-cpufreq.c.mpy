{
  "module_name": "ti-cpufreq.c",
  "hash_id": "e2ef29089f23e373c9dea2aa4ae2bcf0cd7b0b2186c556518f54e08b7ee39f65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/ti-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpu.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#define REVISION_MASK\t\t\t\t0xF\n#define REVISION_SHIFT\t\t\t\t28\n\n#define AM33XX_800M_ARM_MPU_MAX_FREQ\t\t0x1E2F\n#define AM43XX_600M_ARM_MPU_MAX_FREQ\t\t0xFFA\n\n#define DRA7_EFUSE_HAS_OD_MPU_OPP\t\t11\n#define DRA7_EFUSE_HAS_HIGH_MPU_OPP\t\t15\n#define DRA76_EFUSE_HAS_PLUS_MPU_OPP\t\t18\n#define DRA7_EFUSE_HAS_ALL_MPU_OPP\t\t23\n#define DRA76_EFUSE_HAS_ALL_MPU_OPP\t\t24\n\n#define DRA7_EFUSE_NOM_MPU_OPP\t\t\tBIT(0)\n#define DRA7_EFUSE_OD_MPU_OPP\t\t\tBIT(1)\n#define DRA7_EFUSE_HIGH_MPU_OPP\t\t\tBIT(2)\n#define DRA76_EFUSE_PLUS_MPU_OPP\t\tBIT(3)\n\n#define OMAP3_CONTROL_DEVICE_STATUS\t\t0x4800244C\n#define OMAP3_CONTROL_IDCODE\t\t\t0x4830A204\n#define OMAP34xx_ProdID_SKUID\t\t\t0x4830A20C\n#define OMAP3_SYSCON_BASE\t(0x48000000 + 0x2000 + 0x270)\n\n#define AM625_EFUSE_K_MPU_OPP\t\t\t11\n#define AM625_EFUSE_S_MPU_OPP\t\t\t19\n#define AM625_EFUSE_T_MPU_OPP\t\t\t20\n\n#define AM625_SUPPORT_K_MPU_OPP\t\t\tBIT(0)\n#define AM625_SUPPORT_S_MPU_OPP\t\t\tBIT(1)\n#define AM625_SUPPORT_T_MPU_OPP\t\t\tBIT(2)\n\n#define VERSION_COUNT\t\t\t\t2\n\nstruct ti_cpufreq_data;\n\nstruct ti_cpufreq_soc_data {\n\tconst char * const *reg_names;\n\tunsigned long (*efuse_xlate)(struct ti_cpufreq_data *opp_data,\n\t\t\t\t     unsigned long efuse);\n\tunsigned long efuse_fallback;\n\tunsigned long efuse_offset;\n\tunsigned long efuse_mask;\n\tunsigned long efuse_shift;\n\tunsigned long rev_offset;\n\tbool multi_regulator;\n};\n\nstruct ti_cpufreq_data {\n\tstruct device *cpu_dev;\n\tstruct device_node *opp_node;\n\tstruct regmap *syscon;\n\tconst struct ti_cpufreq_soc_data *soc_data;\n};\n\nstatic unsigned long amx3_efuse_xlate(struct ti_cpufreq_data *opp_data,\n\t\t\t\t      unsigned long efuse)\n{\n\tif (!efuse)\n\t\tefuse = opp_data->soc_data->efuse_fallback;\n\t \n\treturn ~efuse;\n}\n\nstatic unsigned long dra7_efuse_xlate(struct ti_cpufreq_data *opp_data,\n\t\t\t\t      unsigned long efuse)\n{\n\tunsigned long calculated_efuse = DRA7_EFUSE_NOM_MPU_OPP;\n\n\t \n\n\tswitch (efuse) {\n\tcase DRA76_EFUSE_HAS_PLUS_MPU_OPP:\n\tcase DRA76_EFUSE_HAS_ALL_MPU_OPP:\n\t\tcalculated_efuse |= DRA76_EFUSE_PLUS_MPU_OPP;\n\t\tfallthrough;\n\tcase DRA7_EFUSE_HAS_ALL_MPU_OPP:\n\tcase DRA7_EFUSE_HAS_HIGH_MPU_OPP:\n\t\tcalculated_efuse |= DRA7_EFUSE_HIGH_MPU_OPP;\n\t\tfallthrough;\n\tcase DRA7_EFUSE_HAS_OD_MPU_OPP:\n\t\tcalculated_efuse |= DRA7_EFUSE_OD_MPU_OPP;\n\t}\n\n\treturn calculated_efuse;\n}\n\nstatic unsigned long omap3_efuse_xlate(struct ti_cpufreq_data *opp_data,\n\t\t\t\t      unsigned long efuse)\n{\n\t \n\treturn BIT(efuse);\n}\n\nstatic unsigned long am625_efuse_xlate(struct ti_cpufreq_data *opp_data,\n\t\t\t\t       unsigned long efuse)\n{\n\tunsigned long calculated_efuse = AM625_SUPPORT_K_MPU_OPP;\n\n\tswitch (efuse) {\n\tcase AM625_EFUSE_T_MPU_OPP:\n\t\tcalculated_efuse |= AM625_SUPPORT_T_MPU_OPP;\n\t\tfallthrough;\n\tcase AM625_EFUSE_S_MPU_OPP:\n\t\tcalculated_efuse |= AM625_SUPPORT_S_MPU_OPP;\n\t\tfallthrough;\n\tcase AM625_EFUSE_K_MPU_OPP:\n\t\tcalculated_efuse |= AM625_SUPPORT_K_MPU_OPP;\n\t}\n\n\treturn calculated_efuse;\n}\n\nstatic struct ti_cpufreq_soc_data am3x_soc_data = {\n\t.efuse_xlate = amx3_efuse_xlate,\n\t.efuse_fallback = AM33XX_800M_ARM_MPU_MAX_FREQ,\n\t.efuse_offset = 0x07fc,\n\t.efuse_mask = 0x1fff,\n\t.rev_offset = 0x600,\n\t.multi_regulator = false,\n};\n\nstatic struct ti_cpufreq_soc_data am4x_soc_data = {\n\t.efuse_xlate = amx3_efuse_xlate,\n\t.efuse_fallback = AM43XX_600M_ARM_MPU_MAX_FREQ,\n\t.efuse_offset = 0x0610,\n\t.efuse_mask = 0x3f,\n\t.rev_offset = 0x600,\n\t.multi_regulator = false,\n};\n\nstatic struct ti_cpufreq_soc_data dra7_soc_data = {\n\t.efuse_xlate = dra7_efuse_xlate,\n\t.efuse_offset = 0x020c,\n\t.efuse_mask = 0xf80000,\n\t.efuse_shift = 19,\n\t.rev_offset = 0x204,\n\t.multi_regulator = true,\n};\n\n \n\nstatic struct ti_cpufreq_soc_data omap34xx_soc_data = {\n\t.efuse_xlate = omap3_efuse_xlate,\n\t.efuse_offset = OMAP34xx_ProdID_SKUID - OMAP3_SYSCON_BASE,\n\t.efuse_shift = 3,\n\t.efuse_mask = BIT(3),\n\t.rev_offset = OMAP3_CONTROL_IDCODE - OMAP3_SYSCON_BASE,\n\t.multi_regulator = false,\n};\n\n \n\nstatic const char * const omap3_reg_names[] = {\"cpu0\", \"vbb\", NULL};\n\nstatic struct ti_cpufreq_soc_data omap36xx_soc_data = {\n\t.reg_names = omap3_reg_names,\n\t.efuse_xlate = omap3_efuse_xlate,\n\t.efuse_offset = OMAP3_CONTROL_DEVICE_STATUS - OMAP3_SYSCON_BASE,\n\t.efuse_shift = 9,\n\t.efuse_mask = BIT(9),\n\t.rev_offset = OMAP3_CONTROL_IDCODE - OMAP3_SYSCON_BASE,\n\t.multi_regulator = true,\n};\n\n \n\nstatic struct ti_cpufreq_soc_data am3517_soc_data = {\n\t.efuse_xlate = omap3_efuse_xlate,\n\t.efuse_offset = OMAP3_CONTROL_DEVICE_STATUS - OMAP3_SYSCON_BASE,\n\t.efuse_shift = 0,\n\t.efuse_mask = 0,\n\t.rev_offset = OMAP3_CONTROL_IDCODE - OMAP3_SYSCON_BASE,\n\t.multi_regulator = false,\n};\n\nstatic struct ti_cpufreq_soc_data am625_soc_data = {\n\t.efuse_xlate = am625_efuse_xlate,\n\t.efuse_offset = 0x0018,\n\t.efuse_mask = 0x07c0,\n\t.efuse_shift = 0x6,\n\t.rev_offset = 0x0014,\n\t.multi_regulator = false,\n};\n\n \nstatic int ti_cpufreq_get_efuse(struct ti_cpufreq_data *opp_data,\n\t\t\t\tu32 *efuse_value)\n{\n\tstruct device *dev = opp_data->cpu_dev;\n\tu32 efuse;\n\tint ret;\n\n\tret = regmap_read(opp_data->syscon, opp_data->soc_data->efuse_offset,\n\t\t\t  &efuse);\n\tif (ret == -EIO) {\n\t\t \n\t\tvoid __iomem *regs = ioremap(OMAP3_SYSCON_BASE +\n\t\t\t\topp_data->soc_data->efuse_offset, 4);\n\n\t\tif (!regs)\n\t\t\treturn -ENOMEM;\n\t\tefuse = readl(regs);\n\t\tiounmap(regs);\n\t\t}\n\telse if (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to read the efuse value from syscon: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tefuse = (efuse & opp_data->soc_data->efuse_mask);\n\tefuse >>= opp_data->soc_data->efuse_shift;\n\n\t*efuse_value = opp_data->soc_data->efuse_xlate(opp_data, efuse);\n\n\treturn 0;\n}\n\n \nstatic int ti_cpufreq_get_rev(struct ti_cpufreq_data *opp_data,\n\t\t\t      u32 *revision_value)\n{\n\tstruct device *dev = opp_data->cpu_dev;\n\tu32 revision;\n\tint ret;\n\n\tret = regmap_read(opp_data->syscon, opp_data->soc_data->rev_offset,\n\t\t\t  &revision);\n\tif (ret == -EIO) {\n\t\t \n\t\tvoid __iomem *regs = ioremap(OMAP3_SYSCON_BASE +\n\t\t\t\topp_data->soc_data->rev_offset, 4);\n\n\t\tif (!regs)\n\t\t\treturn -ENOMEM;\n\t\trevision = readl(regs);\n\t\tiounmap(regs);\n\t\t}\n\telse if (ret) {\n\t\tdev_err(dev,\n\t\t\t\"Failed to read the revision number from syscon: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t*revision_value = BIT((revision >> REVISION_SHIFT) & REVISION_MASK);\n\n\treturn 0;\n}\n\nstatic int ti_cpufreq_setup_syscon_register(struct ti_cpufreq_data *opp_data)\n{\n\tstruct device *dev = opp_data->cpu_dev;\n\tstruct device_node *np = opp_data->opp_node;\n\n\topp_data->syscon = syscon_regmap_lookup_by_phandle(np,\n\t\t\t\t\t\t\t\"syscon\");\n\tif (IS_ERR(opp_data->syscon)) {\n\t\tdev_err(dev,\n\t\t\t\"\\\"syscon\\\" is missing, cannot use OPPv2 table.\\n\");\n\t\treturn PTR_ERR(opp_data->syscon);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ti_cpufreq_of_match[] = {\n\t{ .compatible = \"ti,am33xx\", .data = &am3x_soc_data, },\n\t{ .compatible = \"ti,am3517\", .data = &am3517_soc_data, },\n\t{ .compatible = \"ti,am43\", .data = &am4x_soc_data, },\n\t{ .compatible = \"ti,dra7\", .data = &dra7_soc_data },\n\t{ .compatible = \"ti,omap34xx\", .data = &omap34xx_soc_data, },\n\t{ .compatible = \"ti,omap36xx\", .data = &omap36xx_soc_data, },\n\t{ .compatible = \"ti,am625\", .data = &am625_soc_data, },\n\t{ .compatible = \"ti,am62a7\", .data = &am625_soc_data, },\n\t \n\t{ .compatible = \"ti,omap3430\", .data = &omap34xx_soc_data, },\n\t{ .compatible = \"ti,omap3630\", .data = &omap36xx_soc_data, },\n\t{},\n};\n\nstatic const struct of_device_id *ti_cpufreq_match_node(void)\n{\n\tstruct device_node *np;\n\tconst struct of_device_id *match;\n\n\tnp = of_find_node_by_path(\"/\");\n\tmatch = of_match_node(ti_cpufreq_of_match, np);\n\tof_node_put(np);\n\n\treturn match;\n}\n\nstatic int ti_cpufreq_probe(struct platform_device *pdev)\n{\n\tu32 version[VERSION_COUNT];\n\tconst struct of_device_id *match;\n\tstruct ti_cpufreq_data *opp_data;\n\tconst char * const default_reg_names[] = {\"vdd\", \"vbb\", NULL};\n\tint ret;\n\tstruct dev_pm_opp_config config = {\n\t\t.supported_hw = version,\n\t\t.supported_hw_count = ARRAY_SIZE(version),\n\t};\n\n\tmatch = dev_get_platdata(&pdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\topp_data = devm_kzalloc(&pdev->dev, sizeof(*opp_data), GFP_KERNEL);\n\tif (!opp_data)\n\t\treturn -ENOMEM;\n\n\topp_data->soc_data = match->data;\n\n\topp_data->cpu_dev = get_cpu_device(0);\n\tif (!opp_data->cpu_dev) {\n\t\tpr_err(\"%s: Failed to get device for CPU0\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\topp_data->opp_node = dev_pm_opp_of_get_opp_desc_node(opp_data->cpu_dev);\n\tif (!opp_data->opp_node) {\n\t\tdev_info(opp_data->cpu_dev,\n\t\t\t \"OPP-v2 not supported, cpufreq-dt will attempt to use legacy tables.\\n\");\n\t\tgoto register_cpufreq_dt;\n\t}\n\n\tret = ti_cpufreq_setup_syscon_register(opp_data);\n\tif (ret)\n\t\tgoto fail_put_node;\n\n\t \n\tret = ti_cpufreq_get_rev(opp_data, &version[0]);\n\tif (ret)\n\t\tgoto fail_put_node;\n\n\tret = ti_cpufreq_get_efuse(opp_data, &version[1]);\n\tif (ret)\n\t\tgoto fail_put_node;\n\n\tif (opp_data->soc_data->multi_regulator) {\n\t\tif (opp_data->soc_data->reg_names)\n\t\t\tconfig.regulator_names = opp_data->soc_data->reg_names;\n\t\telse\n\t\t\tconfig.regulator_names = default_reg_names;\n\t}\n\n\tret = dev_pm_opp_set_config(opp_data->cpu_dev, &config);\n\tif (ret < 0) {\n\t\tdev_err(opp_data->cpu_dev, \"Failed to set OPP config\\n\");\n\t\tgoto fail_put_node;\n\t}\n\n\tof_node_put(opp_data->opp_node);\n\nregister_cpufreq_dt:\n\tplatform_device_register_simple(\"cpufreq-dt\", -1, NULL, 0);\n\n\treturn 0;\n\nfail_put_node:\n\tof_node_put(opp_data->opp_node);\n\n\treturn ret;\n}\n\nstatic int __init ti_cpufreq_init(void)\n{\n\tconst struct of_device_id *match;\n\n\t \n\tmatch = ti_cpufreq_match_node();\n\tif (match)\n\t\tplatform_device_register_data(NULL, \"ti-cpufreq\", -1, match,\n\t\t\t\t\t      sizeof(*match));\n\n\treturn 0;\n}\nmodule_init(ti_cpufreq_init);\n\nstatic struct platform_driver ti_cpufreq_driver = {\n\t.probe = ti_cpufreq_probe,\n\t.driver = {\n\t\t.name = \"ti-cpufreq\",\n\t},\n};\nbuiltin_platform_driver(ti_cpufreq_driver);\n\nMODULE_DESCRIPTION(\"TI CPUFreq/OPP hw-supported driver\");\nMODULE_AUTHOR(\"Dave Gerlach <d-gerlach@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}