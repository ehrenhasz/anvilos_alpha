{
  "module_name": "pmac64-cpufreq.c",
  "hash_id": "218e97a9cb2e6b7bb39fb596e67cd743010e9404b57715388bbe29f8a7d3eeaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/pmac64-cpufreq.c",
  "human_readable_source": "\n \n\n#undef DEBUG\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/cpufreq.h>\n#include <linux/init.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n\n#include <asm/machdep.h>\n#include <asm/irq.h>\n#include <asm/sections.h>\n#include <asm/cputable.h>\n#include <asm/time.h>\n#include <asm/smu.h>\n#include <asm/pmac_pfunc.h>\n\n#define DBG(fmt...) pr_debug(fmt)\n\n \n\n#define SCOM_PCR 0x0aa001\t\t\t \n\n#define PCR_HILO_SELECT\t\t0x80000000U\t \n#define PCR_SPEED_FULL\t\t0x00000000U\t \n#define PCR_SPEED_HALF\t\t0x00020000U\t \n#define PCR_SPEED_QUARTER\t0x00040000U\t \n#define PCR_SPEED_MASK\t\t0x000e0000U\t \n#define PCR_SPEED_SHIFT\t\t17\n#define PCR_FREQ_REQ_VALID\t0x00010000U\t \n#define PCR_VOLT_REQ_VALID\t0x00008000U\t \n#define PCR_TARGET_TIME_MASK\t0x00006000U\t \n#define PCR_STATLAT_MASK\t0x00001f00U\t \n#define PCR_SNOOPLAT_MASK\t0x000000f0U\t \n#define PCR_SNOOPACC_MASK\t0x0000000fU\t \n\n#define SCOM_PSR 0x408001\t\t\t \n \n#define PSR_CMD_RECEIVED\t0x2000000000000000U    \n#define PSR_CMD_COMPLETED\t0x1000000000000000U    \n#define PSR_CUR_SPEED_MASK\t0x0300000000000000U    \n#define PSR_CUR_SPEED_SHIFT\t(56)\n\n \n#define CPUFREQ_HIGH                  0\n#define CPUFREQ_LOW                   1\n\nstatic struct cpufreq_frequency_table g5_cpu_freqs[] = {\n\t{0, CPUFREQ_HIGH,\t0},\n\t{0, CPUFREQ_LOW,\t0},\n\t{0, 0,\t\t\tCPUFREQ_TABLE_END},\n};\n\n \nstatic int g5_pmode_cur;\n\nstatic void (*g5_switch_volt)(int speed_mode);\nstatic int (*g5_switch_freq)(int speed_mode);\nstatic int (*g5_query_freq)(void);\n\nstatic unsigned long transition_latency;\n\n#ifdef CONFIG_PMAC_SMU\n\nstatic const u32 *g5_pmode_data;\nstatic int g5_pmode_max;\n\nstatic struct smu_sdbp_fvt *g5_fvt_table;\t \nstatic int g5_fvt_count;\t\t\t \nstatic int g5_fvt_cur;\t\t\t\t \n\n \n\nstatic void g5_smu_switch_volt(int speed_mode)\n{\n\tstruct smu_simple_cmd\tcmd;\n\n\tDECLARE_COMPLETION_ONSTACK(comp);\n\tsmu_queue_simple(&cmd, SMU_CMD_POWER_COMMAND, 8, smu_done_complete,\n\t\t\t &comp, 'V', 'S', 'L', 'E', 'W',\n\t\t\t 0xff, g5_fvt_cur+1, speed_mode);\n\twait_for_completion(&comp);\n}\n\n \n\nstatic struct pmf_function *pfunc_set_vdnap0;\nstatic struct pmf_function *pfunc_vdnap0_complete;\n\nstatic void g5_vdnap_switch_volt(int speed_mode)\n{\n\tstruct pmf_args args;\n\tu32 slew, done = 0;\n\tunsigned long timeout;\n\n\tslew = (speed_mode == CPUFREQ_LOW) ? 1 : 0;\n\targs.count = 1;\n\targs.u[0].p = &slew;\n\n\tpmf_call_one(pfunc_set_vdnap0, &args);\n\n\t \n\ttimeout = jiffies + HZ/10;\n\twhile(!time_after(jiffies, timeout)) {\n\t\targs.count = 1;\n\t\targs.u[0].p = &done;\n\t\tpmf_call_one(pfunc_vdnap0_complete, &args);\n\t\tif (done)\n\t\t\tbreak;\n\t\tusleep_range(1000, 1000);\n\t}\n\tif (done == 0)\n\t\tpr_warn(\"Timeout in clock slewing !\\n\");\n}\n\n\n \nstatic int g5_scom_switch_freq(int speed_mode)\n{\n\tunsigned long flags;\n\tint to;\n\n\t \n\tif (speed_mode < g5_pmode_cur)\n\t\tg5_switch_volt(speed_mode);\n\n\tlocal_irq_save(flags);\n\n\t \n\tscom970_write(SCOM_PCR, 0);\n\t \n       \tscom970_write(SCOM_PCR, PCR_HILO_SELECT | 0);\n\t \n\tscom970_write(SCOM_PCR, PCR_HILO_SELECT |\n\t\t      g5_pmode_data[speed_mode]);\n\n\t \n\tfor (to = 0; to < 10; to++) {\n\t\tunsigned long psr = scom970_read(SCOM_PSR);\n\n\t\tif ((psr & PSR_CMD_RECEIVED) == 0 &&\n\t\t    (((psr >> PSR_CUR_SPEED_SHIFT) ^\n\t\t      (g5_pmode_data[speed_mode] >> PCR_SPEED_SHIFT)) & 0x3)\n\t\t    == 0)\n\t\t\tbreak;\n\t\tif (psr & PSR_CMD_COMPLETED)\n\t\t\tbreak;\n\t\tudelay(100);\n\t}\n\n\tlocal_irq_restore(flags);\n\n\t \n\tif (speed_mode > g5_pmode_cur)\n\t\tg5_switch_volt(speed_mode);\n\n\tg5_pmode_cur = speed_mode;\n\tppc_proc_freq = g5_cpu_freqs[speed_mode].frequency * 1000ul;\n\n\treturn 0;\n}\n\nstatic int g5_scom_query_freq(void)\n{\n\tunsigned long psr = scom970_read(SCOM_PSR);\n\tint i;\n\n\tfor (i = 0; i <= g5_pmode_max; i++)\n\t\tif ((((psr >> PSR_CUR_SPEED_SHIFT) ^\n\t\t      (g5_pmode_data[i] >> PCR_SPEED_SHIFT)) & 0x3) == 0)\n\t\t\tbreak;\n\treturn i;\n}\n\n \n\nstatic void g5_dummy_switch_volt(int speed_mode)\n{\n}\n\n#endif  \n\n \n\nstatic struct pmf_function *pfunc_cpu0_volt_high;\nstatic struct pmf_function *pfunc_cpu0_volt_low;\nstatic struct pmf_function *pfunc_cpu1_volt_high;\nstatic struct pmf_function *pfunc_cpu1_volt_low;\n\nstatic void g5_pfunc_switch_volt(int speed_mode)\n{\n\tif (speed_mode == CPUFREQ_HIGH) {\n\t\tif (pfunc_cpu0_volt_high)\n\t\t\tpmf_call_one(pfunc_cpu0_volt_high, NULL);\n\t\tif (pfunc_cpu1_volt_high)\n\t\t\tpmf_call_one(pfunc_cpu1_volt_high, NULL);\n\t} else {\n\t\tif (pfunc_cpu0_volt_low)\n\t\t\tpmf_call_one(pfunc_cpu0_volt_low, NULL);\n\t\tif (pfunc_cpu1_volt_low)\n\t\t\tpmf_call_one(pfunc_cpu1_volt_low, NULL);\n\t}\n\tusleep_range(10000, 10000);  \n}\n\n \n\nstatic struct pmf_function *pfunc_cpu_setfreq_high;\nstatic struct pmf_function *pfunc_cpu_setfreq_low;\nstatic struct pmf_function *pfunc_cpu_getfreq;\nstatic struct pmf_function *pfunc_slewing_done;\n\nstatic int g5_pfunc_switch_freq(int speed_mode)\n{\n\tstruct pmf_args args;\n\tu32 done = 0;\n\tunsigned long timeout;\n\tint rc;\n\n\tDBG(\"g5_pfunc_switch_freq(%d)\\n\", speed_mode);\n\n\t \n\tif (speed_mode < g5_pmode_cur)\n\t\tg5_switch_volt(speed_mode);\n\n\t \n\tif (speed_mode == CPUFREQ_HIGH)\n\t\trc = pmf_call_one(pfunc_cpu_setfreq_high, NULL);\n\telse\n\t\trc = pmf_call_one(pfunc_cpu_setfreq_low, NULL);\n\n\tif (rc)\n\t\tpr_warn(\"pfunc switch error %d\\n\", rc);\n\n\t \n\ttimeout = jiffies + HZ/10;\n\twhile(!time_after(jiffies, timeout)) {\n\t\targs.count = 1;\n\t\targs.u[0].p = &done;\n\t\tpmf_call_one(pfunc_slewing_done, &args);\n\t\tif (done)\n\t\t\tbreak;\n\t\tusleep_range(500, 500);\n\t}\n\tif (done == 0)\n\t\tpr_warn(\"Timeout in clock slewing !\\n\");\n\n\t \n\tif (speed_mode > g5_pmode_cur)\n\t\tg5_switch_volt(speed_mode);\n\n\tg5_pmode_cur = speed_mode;\n\tppc_proc_freq = g5_cpu_freqs[speed_mode].frequency * 1000ul;\n\n\treturn 0;\n}\n\nstatic int g5_pfunc_query_freq(void)\n{\n\tstruct pmf_args args;\n\tu32 val = 0;\n\n\targs.count = 1;\n\targs.u[0].p = &val;\n\tpmf_call_one(pfunc_cpu_getfreq, &args);\n\treturn val ? CPUFREQ_HIGH : CPUFREQ_LOW;\n}\n\n\n \n\nstatic int g5_cpufreq_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\treturn g5_switch_freq(index);\n}\n\nstatic unsigned int g5_cpufreq_get_speed(unsigned int cpu)\n{\n\treturn g5_cpu_freqs[g5_pmode_cur].frequency;\n}\n\nstatic int g5_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tcpufreq_generic_init(policy, g5_cpu_freqs, transition_latency);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver g5_cpufreq_driver = {\n\t.name\t\t= \"powermac\",\n\t.flags\t\t= CPUFREQ_CONST_LOOPS,\n\t.init\t\t= g5_cpufreq_cpu_init,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= g5_cpufreq_target,\n\t.get\t\t= g5_cpufreq_get_speed,\n\t.attr \t\t= cpufreq_generic_attr,\n};\n\n\n#ifdef CONFIG_PMAC_SMU\n\nstatic int __init g5_neo2_cpufreq_init(struct device_node *cpunode)\n{\n\tunsigned int psize, ssize;\n\tunsigned long max_freq;\n\tchar *freq_method, *volt_method;\n\tconst u32 *valp;\n\tu32 pvr_hi;\n\tint use_volts_vdnap = 0;\n\tint use_volts_smu = 0;\n\tint rc = -ENODEV;\n\n\t \n\tif (of_machine_is_compatible(\"PowerMac8,1\") ||\n\t    of_machine_is_compatible(\"PowerMac8,2\") ||\n\t    of_machine_is_compatible(\"PowerMac9,1\") ||\n\t    of_machine_is_compatible(\"PowerMac12,1\"))\n\t\tuse_volts_smu = 1;\n\telse if (of_machine_is_compatible(\"PowerMac11,2\"))\n\t\tuse_volts_vdnap = 1;\n\telse\n\t\treturn -ENODEV;\n\n\t \n\tvalp = of_get_property(cpunode, \"cpu-version\", NULL);\n\tif (!valp) {\n\t\tDBG(\"No cpu-version property !\\n\");\n\t\tgoto bail_noprops;\n\t}\n\tpvr_hi = (*valp) >> 16;\n\tif (pvr_hi != 0x3c && pvr_hi != 0x44) {\n\t\tpr_err(\"Unsupported CPU version\\n\");\n\t\tgoto bail_noprops;\n\t}\n\n\t \n\tg5_pmode_data = of_get_property(cpunode, \"power-mode-data\",&psize);\n\tif (!g5_pmode_data) {\n\t\tDBG(\"No power-mode-data !\\n\");\n\t\tgoto bail_noprops;\n\t}\n\tg5_pmode_max = psize / sizeof(u32) - 1;\n\n\tif (use_volts_smu) {\n\t\tconst struct smu_sdbp_header *shdr;\n\n\t\t \n\t\tshdr = smu_get_sdb_partition(SMU_SDB_FVT_ID, NULL);\n\t\tif (!shdr)\n\t\t\tgoto bail_noprops;\n\t\tg5_fvt_table = (struct smu_sdbp_fvt *)&shdr[1];\n\t\tssize = (shdr->len * sizeof(u32)) - sizeof(*shdr);\n\t\tg5_fvt_count = ssize / sizeof(*g5_fvt_table);\n\t\tg5_fvt_cur = 0;\n\n\t\t \n\t\tif (g5_fvt_count < 1 || g5_pmode_max < 1)\n\t\t\tgoto bail_noprops;\n\n\t\tg5_switch_volt = g5_smu_switch_volt;\n\t\tvolt_method = \"SMU\";\n\t} else if (use_volts_vdnap) {\n\t\tstruct device_node *root;\n\n\t\troot = of_find_node_by_path(\"/\");\n\t\tif (root == NULL) {\n\t\t\tpr_err(\"Can't find root of device tree\\n\");\n\t\t\tgoto bail_noprops;\n\t\t}\n\t\tpfunc_set_vdnap0 = pmf_find_function(root, \"set-vdnap0\");\n\t\tpfunc_vdnap0_complete =\n\t\t\tpmf_find_function(root, \"slewing-done\");\n\t\tof_node_put(root);\n\t\tif (pfunc_set_vdnap0 == NULL ||\n\t\t    pfunc_vdnap0_complete == NULL) {\n\t\t\tpr_err(\"Can't find required platform function\\n\");\n\t\t\tgoto bail_noprops;\n\t\t}\n\n\t\tg5_switch_volt = g5_vdnap_switch_volt;\n\t\tvolt_method = \"GPIO\";\n\t} else {\n\t\tg5_switch_volt = g5_dummy_switch_volt;\n\t\tvolt_method = \"none\";\n\t}\n\n\t \n\tvalp = of_get_property(cpunode, \"clock-frequency\", NULL);\n\tif (!valp)\n\t\treturn -ENODEV;\n\tmax_freq = (*valp)/1000;\n\tg5_cpu_freqs[0].frequency = max_freq;\n\tg5_cpu_freqs[1].frequency = max_freq/2;\n\n\t \n\ttransition_latency = 12000;\n\tg5_switch_freq = g5_scom_switch_freq;\n\tg5_query_freq = g5_scom_query_freq;\n\tfreq_method = \"SCOM\";\n\n\t \n\tg5_switch_volt(CPUFREQ_HIGH);\n\tmsleep(10);\n\tg5_pmode_cur = -1;\n\tg5_switch_freq(g5_query_freq());\n\n\tpr_info(\"Registering G5 CPU frequency driver\\n\");\n\tpr_info(\"Frequency method: %s, Voltage method: %s\\n\",\n\t\tfreq_method, volt_method);\n\tpr_info(\"Low: %d Mhz, High: %d Mhz, Cur: %d MHz\\n\",\n\t\tg5_cpu_freqs[1].frequency/1000,\n\t\tg5_cpu_freqs[0].frequency/1000,\n\t\tg5_cpu_freqs[g5_pmode_cur].frequency/1000);\n\n\trc = cpufreq_register_driver(&g5_cpufreq_driver);\n\n\t \n\treturn rc;\n\n bail_noprops:\n\tof_node_put(cpunode);\n\n\treturn rc;\n}\n\n#endif  \n\n\nstatic int __init g5_pm72_cpufreq_init(struct device_node *cpunode)\n{\n\tstruct device_node *cpuid = NULL, *hwclock = NULL;\n\tconst u8 *eeprom = NULL;\n\tconst u32 *valp;\n\tu64 max_freq, min_freq, ih, il;\n\tint has_volt = 1, rc = 0;\n\n\tDBG(\"cpufreq: Initializing for PowerMac7,2, PowerMac7,3 and\"\n\t    \" RackMac3,1...\\n\");\n\n\t \n        cpuid = of_find_node_by_path(\"/u3@0,f8000000/i2c@f8001000/cpuid@a0\");\n\tif (cpuid != NULL)\n\t\teeprom = of_get_property(cpuid, \"cpuid\", NULL);\n\tif (eeprom == NULL) {\n\t\tpr_err(\"Can't find cpuid EEPROM !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\t \n\tfor_each_node_by_name(hwclock, \"i2c-hwclock\") {\n\t\tconst char *loc = of_get_property(hwclock,\n\t\t\t\t\"hwctrl-location\", NULL);\n\t\tif (loc == NULL)\n\t\t\tcontinue;\n\t\tif (strcmp(loc, \"CPU CLOCK\"))\n\t\t\tcontinue;\n\t\tif (!of_get_property(hwclock, \"platform-get-frequency\", NULL))\n\t\t\tcontinue;\n\t\tbreak;\n\t}\n\tif (hwclock == NULL) {\n\t\tpr_err(\"Can't find i2c clock chip !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tDBG(\"cpufreq: i2c clock chip found: %pOF\\n\", hwclock);\n\n\t \n\tpfunc_cpu_getfreq =\n\t\tpmf_find_function(hwclock, \"get-frequency\");\n\tpfunc_cpu_setfreq_high =\n\t\tpmf_find_function(hwclock, \"set-frequency-high\");\n\tpfunc_cpu_setfreq_low =\n\t\tpmf_find_function(hwclock, \"set-frequency-low\");\n\tpfunc_slewing_done =\n\t\tpmf_find_function(hwclock, \"slewing-done\");\n\tpfunc_cpu0_volt_high =\n\t\tpmf_find_function(hwclock, \"set-voltage-high-0\");\n\tpfunc_cpu0_volt_low =\n\t\tpmf_find_function(hwclock, \"set-voltage-low-0\");\n\tpfunc_cpu1_volt_high =\n\t\tpmf_find_function(hwclock, \"set-voltage-high-1\");\n\tpfunc_cpu1_volt_low =\n\t\tpmf_find_function(hwclock, \"set-voltage-low-1\");\n\n\t \n\tif (pfunc_cpu_getfreq == NULL || pfunc_cpu_setfreq_high == NULL ||\n\t    pfunc_cpu_setfreq_low == NULL || pfunc_slewing_done == NULL) {\n\t\tpr_err(\"Can't find platform functions !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (pfunc_cpu0_volt_high == NULL || pfunc_cpu0_volt_low == NULL) {\n\t\tpmf_put_function(pfunc_cpu0_volt_high);\n\t\tpmf_put_function(pfunc_cpu0_volt_low);\n\t\tpfunc_cpu0_volt_high = pfunc_cpu0_volt_low = NULL;\n\t\thas_volt = 0;\n\t}\n\tif (!has_volt ||\n\t    pfunc_cpu1_volt_high == NULL || pfunc_cpu1_volt_low == NULL) {\n\t\tpmf_put_function(pfunc_cpu1_volt_high);\n\t\tpmf_put_function(pfunc_cpu1_volt_low);\n\t\tpfunc_cpu1_volt_high = pfunc_cpu1_volt_low = NULL;\n\t}\n\n\t \n\n\t \n\tvalp = of_get_property(cpunode, \"clock-frequency\", NULL);\n\tif (!valp) {\n\t\tpr_err(\"Can't find CPU frequency !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tmax_freq = (*valp)/1000;\n\n\t \n\tih = *((u32 *)(eeprom + 0x10));\n\til = *((u32 *)(eeprom + 0x20));\n\n\t \n\tif (il == ih) {\n\t\tpr_warn(\"No low frequency mode available on this model !\\n\");\n\t\trc = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tmin_freq = 0;\n\tif (ih != 0 && il != 0)\n\t\tmin_freq = (max_freq * il) / ih;\n\n\t \n\tif (min_freq >= max_freq || min_freq < 1000) {\n\t\tpr_err(\"Can't calculate low frequency !\\n\");\n\t\trc = -ENXIO;\n\t\tgoto bail;\n\t}\n\tg5_cpu_freqs[0].frequency = max_freq;\n\tg5_cpu_freqs[1].frequency = min_freq;\n\n\t \n\ttransition_latency = 10 * NSEC_PER_MSEC;\n\n\t \n\tg5_switch_volt = g5_pfunc_switch_volt;\n\tg5_switch_freq = g5_pfunc_switch_freq;\n\tg5_query_freq = g5_pfunc_query_freq;\n\n\t \n\tg5_switch_volt(CPUFREQ_HIGH);\n\tmsleep(10);\n\tg5_pmode_cur = -1;\n\tg5_switch_freq(g5_query_freq());\n\n\tpr_info(\"Registering G5 CPU frequency driver\\n\");\n\tpr_info(\"Frequency method: i2c/pfunc, Voltage method: %s\\n\",\n\t\thas_volt ? \"i2c/pfunc\" : \"none\");\n\tpr_info(\"Low: %d Mhz, High: %d Mhz, Cur: %d MHz\\n\",\n\t\tg5_cpu_freqs[1].frequency/1000,\n\t\tg5_cpu_freqs[0].frequency/1000,\n\t\tg5_cpu_freqs[g5_pmode_cur].frequency/1000);\n\n\trc = cpufreq_register_driver(&g5_cpufreq_driver);\n bail:\n\tif (rc != 0) {\n\t\tpmf_put_function(pfunc_cpu_getfreq);\n\t\tpmf_put_function(pfunc_cpu_setfreq_high);\n\t\tpmf_put_function(pfunc_cpu_setfreq_low);\n\t\tpmf_put_function(pfunc_slewing_done);\n\t\tpmf_put_function(pfunc_cpu0_volt_high);\n\t\tpmf_put_function(pfunc_cpu0_volt_low);\n\t\tpmf_put_function(pfunc_cpu1_volt_high);\n\t\tpmf_put_function(pfunc_cpu1_volt_low);\n\t}\n\tof_node_put(hwclock);\n\tof_node_put(cpuid);\n\tof_node_put(cpunode);\n\n\treturn rc;\n}\n\nstatic int __init g5_cpufreq_init(void)\n{\n\tstruct device_node *cpunode;\n\tint rc = 0;\n\n\t \n\tcpunode = of_cpu_device_node_get(0);\n\tif (cpunode == NULL) {\n\t\tpr_err(\"Can't find any CPU node\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (of_machine_is_compatible(\"PowerMac7,2\") ||\n\t    of_machine_is_compatible(\"PowerMac7,3\") ||\n\t    of_machine_is_compatible(\"RackMac3,1\"))\n\t\trc = g5_pm72_cpufreq_init(cpunode);\n#ifdef CONFIG_PMAC_SMU\n\telse\n\t\trc = g5_neo2_cpufreq_init(cpunode);\n#endif  \n\n\treturn rc;\n}\n\nmodule_init(g5_cpufreq_init);\n\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}