{
  "module_name": "tegra186-cpufreq.c",
  "hash_id": "6990b15a6a9cd114a4ae0111350bf7b6dc61691f0064722d816214438b641e68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/tegra186-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/cpufreq.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n\n#include <soc/tegra/bpmp.h>\n#include <soc/tegra/bpmp-abi.h>\n\n#define TEGRA186_NUM_CLUSTERS\t\t2\n#define EDVD_OFFSET_A57(core)\t\t((SZ_64K * 6) + (0x20 + (core) * 0x4))\n#define EDVD_OFFSET_DENVER(core)\t((SZ_64K * 7) + (0x20 + (core) * 0x4))\n#define EDVD_CORE_VOLT_FREQ_F_SHIFT\t0\n#define EDVD_CORE_VOLT_FREQ_F_MASK\t0xffff\n#define EDVD_CORE_VOLT_FREQ_V_SHIFT\t16\n\nstruct tegra186_cpufreq_cpu {\n\tunsigned int bpmp_cluster_id;\n\tunsigned int edvd_offset;\n};\n\nstatic const struct tegra186_cpufreq_cpu tegra186_cpus[] = {\n\t \n\t{\n\t\t.bpmp_cluster_id = 1,\n\t\t.edvd_offset = EDVD_OFFSET_A57(0)\n\t},\n\t \n\t{\n\t\t.bpmp_cluster_id = 0,\n\t\t.edvd_offset = EDVD_OFFSET_DENVER(0)\n\t},\n\t \n\t{\n\t\t.bpmp_cluster_id = 0,\n\t\t.edvd_offset = EDVD_OFFSET_DENVER(1)\n\t},\n\t \n\t{\n\t\t.bpmp_cluster_id = 1,\n\t\t.edvd_offset = EDVD_OFFSET_A57(1)\n\t},\n\t \n\t{\n\t\t.bpmp_cluster_id = 1,\n\t\t.edvd_offset = EDVD_OFFSET_A57(2)\n\t},\n\t \n\t{\n\t\t.bpmp_cluster_id = 1,\n\t\t.edvd_offset = EDVD_OFFSET_A57(3)\n\t},\n};\n\nstruct tegra186_cpufreq_cluster {\n\tstruct cpufreq_frequency_table *table;\n\tu32 ref_clk_khz;\n\tu32 div;\n};\n\nstruct tegra186_cpufreq_data {\n\tvoid __iomem *regs;\n\tconst struct tegra186_cpufreq_cpu *cpus;\n\tstruct tegra186_cpufreq_cluster clusters[];\n};\n\nstatic int tegra186_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tstruct tegra186_cpufreq_data *data = cpufreq_get_driver_data();\n\tunsigned int cluster = data->cpus[policy->cpu].bpmp_cluster_id;\n\n\tpolicy->freq_table = data->clusters[cluster].table;\n\tpolicy->cpuinfo.transition_latency = 300 * 1000;\n\tpolicy->driver_data = NULL;\n\n\treturn 0;\n}\n\nstatic int tegra186_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t       unsigned int index)\n{\n\tstruct tegra186_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct cpufreq_frequency_table *tbl = policy->freq_table + index;\n\tunsigned int edvd_offset = data->cpus[policy->cpu].edvd_offset;\n\tu32 edvd_val = tbl->driver_data;\n\n\twritel(edvd_val, data->regs + edvd_offset);\n\n\treturn 0;\n}\n\nstatic unsigned int tegra186_cpufreq_get(unsigned int cpu)\n{\n\tstruct tegra186_cpufreq_data *data = cpufreq_get_driver_data();\n\tstruct tegra186_cpufreq_cluster *cluster;\n\tstruct cpufreq_policy *policy;\n\tunsigned int edvd_offset, cluster_id;\n\tu32 ndiv;\n\n\tpolicy = cpufreq_cpu_get(cpu);\n\tif (!policy)\n\t\treturn 0;\n\n\tedvd_offset = data->cpus[policy->cpu].edvd_offset;\n\tndiv = readl(data->regs + edvd_offset) & EDVD_CORE_VOLT_FREQ_F_MASK;\n\tcluster_id = data->cpus[policy->cpu].bpmp_cluster_id;\n\tcluster = &data->clusters[cluster_id];\n\tcpufreq_cpu_put(policy);\n\n\treturn (cluster->ref_clk_khz * ndiv) / cluster->div;\n}\n\nstatic struct cpufreq_driver tegra186_cpufreq_driver = {\n\t.name = \"tegra186\",\n\t.flags = CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t\tCPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.get = tegra186_cpufreq_get,\n\t.verify = cpufreq_generic_frequency_table_verify,\n\t.target_index = tegra186_cpufreq_set_target,\n\t.init = tegra186_cpufreq_init,\n\t.attr = cpufreq_generic_attr,\n};\n\nstatic struct cpufreq_frequency_table *init_vhint_table(\n\tstruct platform_device *pdev, struct tegra_bpmp *bpmp,\n\tstruct tegra186_cpufreq_cluster *cluster, unsigned int cluster_id)\n{\n\tstruct cpufreq_frequency_table *table;\n\tstruct mrq_cpu_vhint_request req;\n\tstruct tegra_bpmp_message msg;\n\tstruct cpu_vhint_data *data;\n\tint err, i, j, num_rates = 0;\n\tdma_addr_t phys;\n\tvoid *virt;\n\n\tvirt = dma_alloc_coherent(bpmp->dev, sizeof(*data), &phys,\n\t\t\t\t  GFP_KERNEL);\n\tif (!virt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdata = (struct cpu_vhint_data *)virt;\n\n\tmemset(&req, 0, sizeof(req));\n\treq.addr = phys;\n\treq.cluster_id = cluster_id;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.mrq = MRQ_CPU_VHINT;\n\tmsg.tx.data = &req;\n\tmsg.tx.size = sizeof(req);\n\n\terr = tegra_bpmp_transfer(bpmp, &msg);\n\tif (err) {\n\t\ttable = ERR_PTR(err);\n\t\tgoto free;\n\t}\n\tif (msg.rx.ret) {\n\t\ttable = ERR_PTR(-EINVAL);\n\t\tgoto free;\n\t}\n\n\tfor (i = data->vfloor; i <= data->vceil; i++) {\n\t\tu16 ndiv = data->ndiv[i];\n\n\t\tif (ndiv < data->ndiv_min || ndiv > data->ndiv_max)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i > 0 && ndiv == data->ndiv[i - 1])\n\t\t\tcontinue;\n\n\t\tnum_rates++;\n\t}\n\n\ttable = devm_kcalloc(&pdev->dev, num_rates + 1, sizeof(*table),\n\t\t\t     GFP_KERNEL);\n\tif (!table) {\n\t\ttable = ERR_PTR(-ENOMEM);\n\t\tgoto free;\n\t}\n\n\tcluster->ref_clk_khz = data->ref_clk_hz / 1000;\n\tcluster->div = data->pdiv * data->mdiv;\n\n\tfor (i = data->vfloor, j = 0; i <= data->vceil; i++) {\n\t\tstruct cpufreq_frequency_table *point;\n\t\tu16 ndiv = data->ndiv[i];\n\t\tu32 edvd_val = 0;\n\n\t\tif (ndiv < data->ndiv_min || ndiv > data->ndiv_max)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (i > 0 && ndiv == data->ndiv[i - 1])\n\t\t\tcontinue;\n\n\t\tedvd_val |= i << EDVD_CORE_VOLT_FREQ_V_SHIFT;\n\t\tedvd_val |= ndiv << EDVD_CORE_VOLT_FREQ_F_SHIFT;\n\n\t\tpoint = &table[j++];\n\t\tpoint->driver_data = edvd_val;\n\t\tpoint->frequency = (cluster->ref_clk_khz * ndiv) / cluster->div;\n\t}\n\n\ttable[j].frequency = CPUFREQ_TABLE_END;\n\nfree:\n\tdma_free_coherent(bpmp->dev, sizeof(*data), virt, phys);\n\n\treturn table;\n}\n\nstatic int tegra186_cpufreq_probe(struct platform_device *pdev)\n{\n\tstruct tegra186_cpufreq_data *data;\n\tstruct tegra_bpmp *bpmp;\n\tunsigned int i = 0, err;\n\n\tdata = devm_kzalloc(&pdev->dev,\n\t\t\t    struct_size(data, clusters, TEGRA186_NUM_CLUSTERS),\n\t\t\t    GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->cpus = tegra186_cpus;\n\n\tbpmp = tegra_bpmp_get(&pdev->dev);\n\tif (IS_ERR(bpmp))\n\t\treturn PTR_ERR(bpmp);\n\n\tdata->regs = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->regs)) {\n\t\terr = PTR_ERR(data->regs);\n\t\tgoto put_bpmp;\n\t}\n\n\tfor (i = 0; i < TEGRA186_NUM_CLUSTERS; i++) {\n\t\tstruct tegra186_cpufreq_cluster *cluster = &data->clusters[i];\n\n\t\tcluster->table = init_vhint_table(pdev, bpmp, cluster, i);\n\t\tif (IS_ERR(cluster->table)) {\n\t\t\terr = PTR_ERR(cluster->table);\n\t\t\tgoto put_bpmp;\n\t\t}\n\t}\n\n\ttegra186_cpufreq_driver.driver_data = data;\n\n\terr = cpufreq_register_driver(&tegra186_cpufreq_driver);\n\nput_bpmp:\n\ttegra_bpmp_put(bpmp);\n\n\treturn err;\n}\n\nstatic void tegra186_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&tegra186_cpufreq_driver);\n}\n\nstatic const struct of_device_id tegra186_cpufreq_of_match[] = {\n\t{ .compatible = \"nvidia,tegra186-ccplex-cluster\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, tegra186_cpufreq_of_match);\n\nstatic struct platform_driver tegra186_cpufreq_platform_driver = {\n\t.driver = {\n\t\t.name = \"tegra186-cpufreq\",\n\t\t.of_match_table = tegra186_cpufreq_of_match,\n\t},\n\t.probe = tegra186_cpufreq_probe,\n\t.remove_new = tegra186_cpufreq_remove,\n};\nmodule_platform_driver(tegra186_cpufreq_platform_driver);\n\nMODULE_AUTHOR(\"Mikko Perttunen <mperttunen@nvidia.com>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra186 cpufreq driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}