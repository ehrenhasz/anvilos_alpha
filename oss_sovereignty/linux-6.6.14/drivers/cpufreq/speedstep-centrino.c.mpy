{
  "module_name": "speedstep-centrino.c",
  "hash_id": "a7b32226694a9bb738e119f2b54370eeea00329d8d042d220a2c81f70105c741",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/speedstep-centrino.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/sched.h>\t \n#include <linux/delay.h>\n#include <linux/compiler.h>\n#include <linux/gfp.h>\n\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <asm/cpufeature.h>\n#include <asm/cpu_device_id.h>\n\n#define MAINTAINER\t\"linux-pm@vger.kernel.org\"\n\n#define INTEL_MSR_RANGE\t(0xffff)\n\nstruct cpu_id\n{\n\t__u8\tx86;             \n\t__u8\tx86_model;\t \n\t__u8\tx86_stepping;\t \n};\n\nenum {\n\tCPU_BANIAS,\n\tCPU_DOTHAN_A1,\n\tCPU_DOTHAN_A2,\n\tCPU_DOTHAN_B0,\n\tCPU_MP4HT_D0,\n\tCPU_MP4HT_E0,\n};\n\nstatic const struct cpu_id cpu_ids[] = {\n\t[CPU_BANIAS]\t= { 6,  9, 5 },\n\t[CPU_DOTHAN_A1]\t= { 6, 13, 1 },\n\t[CPU_DOTHAN_A2]\t= { 6, 13, 2 },\n\t[CPU_DOTHAN_B0]\t= { 6, 13, 6 },\n\t[CPU_MP4HT_D0]\t= {15,  3, 4 },\n\t[CPU_MP4HT_E0]\t= {15,  4, 1 },\n};\n#define N_IDS\tARRAY_SIZE(cpu_ids)\n\nstruct cpu_model\n{\n\tconst struct cpu_id *cpu_id;\n\tconst char\t*model_name;\n\tunsigned\tmax_freq;  \n\n\tstruct cpufreq_frequency_table *op_points;  \n};\nstatic int centrino_verify_cpu_id(const struct cpuinfo_x86 *c,\n\t\t\t\t  const struct cpu_id *x);\n\n \nstatic DEFINE_PER_CPU(struct cpu_model *, centrino_model);\nstatic DEFINE_PER_CPU(const struct cpu_id *, centrino_cpu);\n\nstatic struct cpufreq_driver centrino_driver;\n\n#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_TABLE\n\n \n#define OP(mhz, mv)\t\t\t\t\t\t\t\\\n\t{\t\t\t\t\t\t\t\t\\\n\t\t.frequency = (mhz) * 1000,\t\t\t\t\\\n\t\t.driver_data = (((mhz)/100) << 8) | ((mv - 700) / 16)\t\t\\\n\t}\n\n \n\n \nstatic struct cpufreq_frequency_table banias_900[] =\n{\n\tOP(600,  844),\n\tOP(800,  988),\n\tOP(900, 1004),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1000[] =\n{\n\tOP(600,   844),\n\tOP(800,   972),\n\tOP(900,   988),\n\tOP(1000, 1004),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1100[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1020),\n\tOP( 900, 1100),\n\tOP(1000, 1164),\n\tOP(1100, 1180),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n\n \nstatic struct cpufreq_frequency_table banias_1200[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1004),\n\tOP( 900, 1020),\n\tOP(1000, 1100),\n\tOP(1100, 1164),\n\tOP(1200, 1180),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1300[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1260),\n\tOP(1000, 1292),\n\tOP(1200, 1356),\n\tOP(1300, 1388),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1400[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1180),\n\tOP(1000, 1308),\n\tOP(1200, 1436),\n\tOP(1400, 1484),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1500[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1116),\n\tOP(1000, 1228),\n\tOP(1200, 1356),\n\tOP(1400, 1452),\n\tOP(1500, 1484),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1600[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1036),\n\tOP(1000, 1164),\n\tOP(1200, 1276),\n\tOP(1400, 1420),\n\tOP(1600, 1484),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n\n \nstatic struct cpufreq_frequency_table banias_1700[] =\n{\n\tOP( 600,  956),\n\tOP( 800, 1004),\n\tOP(1000, 1116),\n\tOP(1200, 1228),\n\tOP(1400, 1308),\n\tOP(1700, 1484),\n\t{ .frequency = CPUFREQ_TABLE_END }\n};\n#undef OP\n\n#define _BANIAS(cpuid, max, name)\t\\\n{\t.cpu_id\t\t= cpuid,\t\\\n\t.model_name\t= \"Intel(R) Pentium(R) M processor \" name \"MHz\", \\\n\t.max_freq\t= (max)*1000,\t\\\n\t.op_points\t= banias_##max,\t\\\n}\n#define BANIAS(max)\t_BANIAS(&cpu_ids[CPU_BANIAS], max, #max)\n\n \nstatic struct cpu_model models[] =\n{\n\t_BANIAS(&cpu_ids[CPU_BANIAS], 900, \" 900\"),\n\tBANIAS(1000),\n\tBANIAS(1100),\n\tBANIAS(1200),\n\tBANIAS(1300),\n\tBANIAS(1400),\n\tBANIAS(1500),\n\tBANIAS(1600),\n\tBANIAS(1700),\n\n\t \n\t{ &cpu_ids[CPU_DOTHAN_A1], NULL, 0, NULL },\n\t{ &cpu_ids[CPU_DOTHAN_A2], NULL, 0, NULL },\n\t{ &cpu_ids[CPU_DOTHAN_B0], NULL, 0, NULL },\n\t{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL },\n\t{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL },\n\n\t{ NULL, }\n};\n#undef _BANIAS\n#undef BANIAS\n\nstatic int centrino_cpu_init_table(struct cpufreq_policy *policy)\n{\n\tstruct cpuinfo_x86 *cpu = &cpu_data(policy->cpu);\n\tstruct cpu_model *model;\n\n\tfor(model = models; model->cpu_id != NULL; model++)\n\t\tif (centrino_verify_cpu_id(cpu, model->cpu_id) &&\n\t\t    (model->model_name == NULL ||\n\t\t     strcmp(cpu->x86_model_id, model->model_name) == 0))\n\t\t\tbreak;\n\n\tif (model->cpu_id == NULL) {\n\t\t \n\t\tpr_debug(\"no support for CPU model \\\"%s\\\": \"\n\t\t       \"send /proc/cpuinfo to \" MAINTAINER \"\\n\",\n\t\t       cpu->x86_model_id);\n\t\treturn -ENOENT;\n\t}\n\n\tif (model->op_points == NULL) {\n\t\t \n\t\tpr_debug(\"no table support for CPU model \\\"%s\\\"\\n\",\n\t\t       cpu->x86_model_id);\n\t\tpr_debug(\"try using the acpi-cpufreq driver\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tper_cpu(centrino_model, policy->cpu) = model;\n\n\tpr_debug(\"found \\\"%s\\\": max frequency: %dkHz\\n\",\n\t       model->model_name, model->max_freq);\n\n\treturn 0;\n}\n\n#else\nstatic inline int centrino_cpu_init_table(struct cpufreq_policy *policy)\n{\n\treturn -ENODEV;\n}\n#endif  \n\nstatic int centrino_verify_cpu_id(const struct cpuinfo_x86 *c,\n\t\t\t\t  const struct cpu_id *x)\n{\n\tif ((c->x86 == x->x86) &&\n\t    (c->x86_model == x->x86_model) &&\n\t    (c->x86_stepping == x->x86_stepping))\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic unsigned extract_clock(unsigned msr, unsigned int cpu, int failsafe)\n{\n\tint i;\n\n\t \n\tif ((per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_BANIAS]) ||\n\t    (per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_DOTHAN_A1]) ||\n\t    (per_cpu(centrino_cpu, cpu) == &cpu_ids[CPU_DOTHAN_B0])) {\n\t\tmsr = (msr >> 8) & 0xff;\n\t\treturn msr * 100000;\n\t}\n\n\tif ((!per_cpu(centrino_model, cpu)) ||\n\t    (!per_cpu(centrino_model, cpu)->op_points))\n\t\treturn 0;\n\n\tmsr &= 0xffff;\n\tfor (i = 0;\n\t\tper_cpu(centrino_model, cpu)->op_points[i].frequency\n\t\t\t\t\t\t\t!= CPUFREQ_TABLE_END;\n\t     i++) {\n\t\tif (msr == per_cpu(centrino_model, cpu)->op_points[i].driver_data)\n\t\t\treturn per_cpu(centrino_model, cpu)->\n\t\t\t\t\t\t\top_points[i].frequency;\n\t}\n\tif (failsafe)\n\t\treturn per_cpu(centrino_model, cpu)->op_points[i-1].frequency;\n\telse\n\t\treturn 0;\n}\n\n \nstatic unsigned int get_cur_freq(unsigned int cpu)\n{\n\tunsigned l, h;\n\tunsigned clock_freq;\n\n\trdmsr_on_cpu(cpu, MSR_IA32_PERF_STATUS, &l, &h);\n\tclock_freq = extract_clock(l, cpu, 0);\n\n\tif (unlikely(clock_freq == 0)) {\n\t\t \n\t\trdmsr_on_cpu(cpu, MSR_IA32_PERF_CTL, &l, &h);\n\t\tclock_freq = extract_clock(l, cpu, 1);\n\t}\n\treturn clock_freq;\n}\n\n\nstatic int centrino_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpuinfo_x86 *cpu = &cpu_data(policy->cpu);\n\tunsigned l, h;\n\tint i;\n\n\t \n\tif (cpu->x86_vendor != X86_VENDOR_INTEL ||\n\t    !cpu_has(cpu, X86_FEATURE_EST))\n\t\treturn -ENODEV;\n\n\tif (cpu_has(cpu, X86_FEATURE_CONSTANT_TSC))\n\t\tcentrino_driver.flags |= CPUFREQ_CONST_LOOPS;\n\n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < N_IDS; i++)\n\t\tif (centrino_verify_cpu_id(cpu, &cpu_ids[i]))\n\t\t\tbreak;\n\n\tif (i != N_IDS)\n\t\tper_cpu(centrino_cpu, policy->cpu) = &cpu_ids[i];\n\n\tif (!per_cpu(centrino_cpu, policy->cpu)) {\n\t\tpr_debug(\"found unsupported CPU with \"\n\t\t\"Enhanced SpeedStep: send /proc/cpuinfo to \"\n\t\tMAINTAINER \"\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (centrino_cpu_init_table(policy))\n\t\treturn -ENODEV;\n\n\t \n\trdmsr(MSR_IA32_MISC_ENABLE, l, h);\n\n\tif (!(l & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\n\t\tl |= MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP;\n\t\tpr_debug(\"trying to enable Enhanced SpeedStep (%x)\\n\", l);\n\t\twrmsr(MSR_IA32_MISC_ENABLE, l, h);\n\n\t\t \n\t\trdmsr(MSR_IA32_MISC_ENABLE, l, h);\n\t\tif (!(l & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP)) {\n\t\t\tpr_info(\"couldn't enable Enhanced SpeedStep\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tpolicy->cpuinfo.transition_latency = 10000;\n\t\t\t\t\t\t \n\tpolicy->freq_table = per_cpu(centrino_model, policy->cpu)->op_points;\n\n\treturn 0;\n}\n\nstatic int centrino_cpu_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\n\tif (!per_cpu(centrino_model, cpu))\n\t\treturn -ENODEV;\n\n\tper_cpu(centrino_model, cpu) = NULL;\n\n\treturn 0;\n}\n\n \nstatic int centrino_target(struct cpufreq_policy *policy, unsigned int index)\n{\n\tunsigned int\tmsr, oldmsr = 0, h = 0, cpu = policy->cpu;\n\tint\t\t\tretval = 0;\n\tunsigned int\t\tj, first_cpu;\n\tstruct cpufreq_frequency_table *op_points;\n\tcpumask_var_t covered_cpus;\n\n\tif (unlikely(!zalloc_cpumask_var(&covered_cpus, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\tif (unlikely(per_cpu(centrino_model, cpu) == NULL)) {\n\t\tretval = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tfirst_cpu = 1;\n\top_points = &per_cpu(centrino_model, cpu)->op_points[index];\n\tfor_each_cpu(j, policy->cpus) {\n\t\tint good_cpu;\n\n\t\t \n\t\tif (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)\n\t\t\tgood_cpu = cpumask_any_and(policy->cpus,\n\t\t\t\t\t\t   cpu_online_mask);\n\t\telse\n\t\t\tgood_cpu = j;\n\n\t\tif (good_cpu >= nr_cpu_ids) {\n\t\t\tpr_debug(\"couldn't limit to CPUs in this domain\\n\");\n\t\t\tretval = -EAGAIN;\n\t\t\tif (first_cpu) {\n\t\t\t\t \n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmsr = op_points->driver_data;\n\n\t\tif (first_cpu) {\n\t\t\trdmsr_on_cpu(good_cpu, MSR_IA32_PERF_CTL, &oldmsr, &h);\n\t\t\tif (msr == (oldmsr & 0xffff)) {\n\t\t\t\tpr_debug(\"no change needed - msr was and needs \"\n\t\t\t\t\t\"to be %x\\n\", oldmsr);\n\t\t\t\tretval = 0;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tfirst_cpu = 0;\n\t\t\t \n\t\t\toldmsr &= ~0xffff;\n\t\t\tmsr &= 0xffff;\n\t\t\toldmsr |= msr;\n\t\t}\n\n\t\twrmsr_on_cpu(good_cpu, MSR_IA32_PERF_CTL, oldmsr, h);\n\t\tif (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)\n\t\t\tbreak;\n\n\t\tcpumask_set_cpu(j, covered_cpus);\n\t}\n\n\tif (unlikely(retval)) {\n\t\t \n\n\t\tfor_each_cpu(j, covered_cpus)\n\t\t\twrmsr_on_cpu(j, MSR_IA32_PERF_CTL, oldmsr, h);\n\t}\n\tretval = 0;\n\nout:\n\tfree_cpumask_var(covered_cpus);\n\treturn retval;\n}\n\nstatic struct cpufreq_driver centrino_driver = {\n\t.name\t\t= \"centrino\",  \n\t.init\t\t= centrino_cpu_init,\n\t.exit\t\t= centrino_cpu_exit,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= centrino_target,\n\t.get\t\t= get_cur_freq,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\n \nstatic const struct x86_cpu_id centrino_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL,  6,  9, X86_FEATURE_EST, NULL),\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL,  6, 13, X86_FEATURE_EST, NULL),\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 15,  3, X86_FEATURE_EST, NULL),\n\tX86_MATCH_VENDOR_FAM_MODEL_FEATURE(INTEL, 15,  4, X86_FEATURE_EST, NULL),\n\t{}\n};\n\n \nstatic int __init centrino_init(void)\n{\n\tif (!x86_match_cpu(centrino_ids))\n\t\treturn -ENODEV;\n\treturn cpufreq_register_driver(&centrino_driver);\n}\n\nstatic void __exit centrino_exit(void)\n{\n\tcpufreq_unregister_driver(&centrino_driver);\n}\n\nMODULE_AUTHOR (\"Jeremy Fitzhardinge <jeremy@goop.org>\");\nMODULE_DESCRIPTION (\"Enhanced SpeedStep driver for Intel Pentium M processors.\");\nMODULE_LICENSE (\"GPL\");\n\nlate_initcall(centrino_init);\nmodule_exit(centrino_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}