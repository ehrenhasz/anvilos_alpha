{
  "module_name": "qoriq-cpufreq.c",
  "hash_id": "75ae064fb8548f67e49e7a2b8e5725ad50e1727309c7490e4f4157195bcc0d09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/qoriq-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/cpufreq.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/smp.h>\n#include <linux/platform_device.h>\n\n \nstruct cpu_data {\n\tstruct clk **pclk;\n\tstruct cpufreq_frequency_table *table;\n};\n\n \nstruct soc_data {\n\tu32 flags;\n};\n\nstatic u32 get_bus_freq(void)\n{\n\tstruct device_node *soc;\n\tu32 sysfreq;\n\tstruct clk *pltclk;\n\tint ret;\n\n\t \n\tsoc = of_find_node_by_type(NULL, \"soc\");\n\tif (soc) {\n\t\tret = of_property_read_u32(soc, \"bus-frequency\", &sysfreq);\n\t\tof_node_put(soc);\n\t\tif (!ret)\n\t\t\treturn sysfreq;\n\t}\n\n\t \n\tpltclk = clk_get(NULL, \"cg-pll0-div1\");\n\tif (IS_ERR(pltclk)) {\n\t\tpr_err(\"%s: can't get bus frequency %ld\\n\",\n\t\t       __func__, PTR_ERR(pltclk));\n\t\treturn PTR_ERR(pltclk);\n\t}\n\n\treturn clk_get_rate(pltclk);\n}\n\nstatic struct clk *cpu_to_clk(int cpu)\n{\n\tstruct device_node *np;\n\tstruct clk *clk;\n\n\tif (!cpu_present(cpu))\n\t\treturn NULL;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn NULL;\n\n\tclk = of_clk_get(np, 0);\n\tof_node_put(np);\n\treturn clk;\n}\n\n \nstatic void set_affected_cpus(struct cpufreq_policy *policy)\n{\n\tstruct cpumask *dstp = policy->cpus;\n\tstruct clk *clk;\n\tint i;\n\n\tfor_each_present_cpu(i) {\n\t\tclk = cpu_to_clk(i);\n\t\tif (IS_ERR(clk)) {\n\t\t\tpr_err(\"%s: no clock for cpu %d\\n\", __func__, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (clk_is_match(policy->clk, clk))\n\t\t\tcpumask_set_cpu(i, dstp);\n\t}\n}\n\n \nstatic void freq_table_redup(struct cpufreq_frequency_table *freq_table,\n\t\tint count)\n{\n\tint i, j;\n\n\tfor (i = 1; i < count; i++) {\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tif (freq_table[j].frequency == CPUFREQ_ENTRY_INVALID ||\n\t\t\t\t\tfreq_table[j].frequency !=\n\t\t\t\t\tfreq_table[i].frequency)\n\t\t\t\tcontinue;\n\n\t\t\tfreq_table[i].frequency = CPUFREQ_ENTRY_INVALID;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void freq_table_sort(struct cpufreq_frequency_table *freq_table,\n\t\tint count)\n{\n\tint i, j, ind;\n\tunsigned int freq, max_freq;\n\tstruct cpufreq_frequency_table table;\n\n\tfor (i = 0; i < count - 1; i++) {\n\t\tmax_freq = freq_table[i].frequency;\n\t\tind = i;\n\t\tfor (j = i + 1; j < count; j++) {\n\t\t\tfreq = freq_table[j].frequency;\n\t\t\tif (freq == CPUFREQ_ENTRY_INVALID ||\n\t\t\t\t\tfreq <= max_freq)\n\t\t\t\tcontinue;\n\t\t\tind = j;\n\t\t\tmax_freq = freq;\n\t\t}\n\n\t\tif (ind != i) {\n\t\t\t \n\t\t\ttable.driver_data = freq_table[i].driver_data;\n\t\t\ttable.frequency = freq_table[i].frequency;\n\t\t\tfreq_table[i].driver_data = freq_table[ind].driver_data;\n\t\t\tfreq_table[i].frequency = freq_table[ind].frequency;\n\t\t\tfreq_table[ind].driver_data = table.driver_data;\n\t\t\tfreq_table[ind].frequency = table.frequency;\n\t\t}\n\t}\n}\n\nstatic int qoriq_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct device_node *np;\n\tint i, count;\n\tu32 freq;\n\tstruct clk *clk;\n\tconst struct clk_hw *hwclk;\n\tstruct cpufreq_frequency_table *table;\n\tstruct cpu_data *data;\n\tunsigned int cpu = policy->cpu;\n\tu64 u64temp;\n\n\tnp = of_get_cpu_node(cpu, NULL);\n\tif (!np)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\tgoto err_np;\n\n\tpolicy->clk = of_clk_get(np, 0);\n\tif (IS_ERR(policy->clk)) {\n\t\tpr_err(\"%s: no clock information\\n\", __func__);\n\t\tgoto err_nomem2;\n\t}\n\n\thwclk = __clk_get_hw(policy->clk);\n\tcount = clk_hw_get_num_parents(hwclk);\n\n\tdata->pclk = kcalloc(count, sizeof(struct clk *), GFP_KERNEL);\n\tif (!data->pclk)\n\t\tgoto err_nomem2;\n\n\ttable = kcalloc(count + 1, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto err_pclk;\n\n\tfor (i = 0; i < count; i++) {\n\t\tclk = clk_hw_get_parent_by_index(hwclk, i)->clk;\n\t\tdata->pclk[i] = clk;\n\t\tfreq = clk_get_rate(clk);\n\t\ttable[i].frequency = freq / 1000;\n\t\ttable[i].driver_data = i;\n\t}\n\tfreq_table_redup(table, count);\n\tfreq_table_sort(table, count);\n\ttable[i].frequency = CPUFREQ_TABLE_END;\n\tpolicy->freq_table = table;\n\tdata->table = table;\n\n\t \n\tset_affected_cpus(policy);\n\tpolicy->driver_data = data;\n\n\t \n\tu64temp = 12ULL * NSEC_PER_SEC;\n\tdo_div(u64temp, get_bus_freq());\n\tpolicy->cpuinfo.transition_latency = u64temp + 1;\n\n\tof_node_put(np);\n\n\treturn 0;\n\nerr_pclk:\n\tkfree(data->pclk);\nerr_nomem2:\n\tkfree(data);\nerr_np:\n\tof_node_put(np);\n\n\treturn -ENODEV;\n}\n\nstatic int qoriq_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\tstruct cpu_data *data = policy->driver_data;\n\n\tkfree(data->pclk);\n\tkfree(data->table);\n\tkfree(data);\n\tpolicy->driver_data = NULL;\n\n\treturn 0;\n}\n\nstatic int qoriq_cpufreq_target(struct cpufreq_policy *policy,\n\t\tunsigned int index)\n{\n\tstruct clk *parent;\n\tstruct cpu_data *data = policy->driver_data;\n\n\tparent = data->pclk[data->table[index].driver_data];\n\treturn clk_set_parent(policy->clk, parent);\n}\n\nstatic struct cpufreq_driver qoriq_cpufreq_driver = {\n\t.name\t\t= \"qoriq_cpufreq\",\n\t.flags\t\t= CPUFREQ_CONST_LOOPS |\n\t\t\t  CPUFREQ_IS_COOLING_DEV,\n\t.init\t\t= qoriq_cpufreq_cpu_init,\n\t.exit\t\t= qoriq_cpufreq_cpu_exit,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= qoriq_cpufreq_target,\n\t.get\t\t= cpufreq_generic_get,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic const struct of_device_id qoriq_cpufreq_blacklist[] = {\n\t \n\t{ .compatible = \"fsl,b4420-clockgen\", },\n\t{ .compatible = \"fsl,b4860-clockgen\", },\n\t{ .compatible = \"fsl,t2080-clockgen\", },\n\t{ .compatible = \"fsl,t4240-clockgen\", },\n\t{}\n};\n\nstatic int qoriq_cpufreq_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device_node *np;\n\n\tnp = of_find_matching_node(NULL, qoriq_cpufreq_blacklist);\n\tif (np) {\n\t\tof_node_put(np);\n\t\tdev_info(&pdev->dev, \"Disabling due to erratum A-008083\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = cpufreq_register_driver(&qoriq_cpufreq_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(&pdev->dev, \"Freescale QorIQ CPU frequency scaling driver\\n\");\n\treturn 0;\n}\n\nstatic void qoriq_cpufreq_remove(struct platform_device *pdev)\n{\n\tcpufreq_unregister_driver(&qoriq_cpufreq_driver);\n}\n\nstatic struct platform_driver qoriq_cpufreq_platform_driver = {\n\t.driver = {\n\t\t.name = \"qoriq-cpufreq\",\n\t},\n\t.probe = qoriq_cpufreq_probe,\n\t.remove_new = qoriq_cpufreq_remove,\n};\nmodule_platform_driver(qoriq_cpufreq_platform_driver);\n\nMODULE_ALIAS(\"platform:qoriq-cpufreq\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Tang Yuantian <Yuantian.Tang@freescale.com>\");\nMODULE_DESCRIPTION(\"cpufreq driver for Freescale QorIQ series SoCs\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}