{
  "module_name": "pxa2xx-cpufreq.c",
  "hash_id": "18b4a38bdd3b3242bb231f44a421e4259aaf3ff888c109f077e10a5eb910df52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/pxa2xx-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/err.h>\n#include <linux/regulator/consumer.h>\n#include <linux/soc/pxa/cpu.h>\n#include <linux/io.h>\n\n#ifdef DEBUG\nstatic unsigned int freq_debug;\nmodule_param(freq_debug, uint, 0);\nMODULE_PARM_DESC(freq_debug, \"Set the debug messages to on=1/off=0\");\n#else\n#define freq_debug  0\n#endif\n\nstatic struct regulator *vcc_core;\n\nstatic unsigned int pxa27x_maxfreq;\nmodule_param(pxa27x_maxfreq, uint, 0);\nMODULE_PARM_DESC(pxa27x_maxfreq, \"Set the pxa27x maxfreq in MHz\"\n\t\t \"(typically 624=>pxa270, 416=>pxa271, 520=>pxa272)\");\n\nstruct pxa_cpufreq_data {\n\tstruct clk *clk_core;\n};\nstatic struct pxa_cpufreq_data  pxa_cpufreq_data;\n\nstruct pxa_freqs {\n\tunsigned int khz;\n\tint vmin;\n\tint vmax;\n};\n\n \nstatic const struct pxa_freqs pxa255_run_freqs[] =\n{\n\t \n\t{ 99500, -1, -1},\t \n\t{132700, -1, -1},\t \n\t{199100, -1, -1},\t \n\t{265400, -1, -1},\t \n\t{331800, -1, -1},\t \n\t{398100, -1, -1},\t \n};\n\n \nstatic const struct pxa_freqs pxa255_turbo_freqs[] =\n{\n\t \n\t{ 99500, -1, -1},\t \n\t{199100, -1, -1},\t \n\t{298500, -1, -1},\t \n\t{298600, -1, -1},\t \n\t{398100, -1, -1},\t \n};\n\n#define NUM_PXA25x_RUN_FREQS ARRAY_SIZE(pxa255_run_freqs)\n#define NUM_PXA25x_TURBO_FREQS ARRAY_SIZE(pxa255_turbo_freqs)\n\nstatic struct cpufreq_frequency_table\n\tpxa255_run_freq_table[NUM_PXA25x_RUN_FREQS+1];\nstatic struct cpufreq_frequency_table\n\tpxa255_turbo_freq_table[NUM_PXA25x_TURBO_FREQS+1];\n\nstatic unsigned int pxa255_turbo_table;\nmodule_param(pxa255_turbo_table, uint, 0);\nMODULE_PARM_DESC(pxa255_turbo_table, \"Selects the frequency table (0 = run table, !0 = turbo table)\");\n\nstatic struct pxa_freqs pxa27x_freqs[] = {\n\t{104000,  900000, 1705000 },\n\t{156000, 1000000, 1705000 },\n\t{208000, 1180000, 1705000 },\n\t{312000, 1250000, 1705000 },\n\t{416000, 1350000, 1705000 },\n\t{520000, 1450000, 1705000 },\n\t{624000, 1550000, 1705000 }\n};\n\n#define NUM_PXA27x_FREQS ARRAY_SIZE(pxa27x_freqs)\nstatic struct cpufreq_frequency_table\n\tpxa27x_freq_table[NUM_PXA27x_FREQS+1];\n\n#ifdef CONFIG_REGULATOR\n\nstatic int pxa_cpufreq_change_voltage(const struct pxa_freqs *pxa_freq)\n{\n\tint ret = 0;\n\tint vmin, vmax;\n\n\tif (!cpu_is_pxa27x())\n\t\treturn 0;\n\n\tvmin = pxa_freq->vmin;\n\tvmax = pxa_freq->vmax;\n\tif ((vmin == -1) || (vmax == -1))\n\t\treturn 0;\n\n\tret = regulator_set_voltage(vcc_core, vmin, vmax);\n\tif (ret)\n\t\tpr_err(\"Failed to set vcc_core in [%dmV..%dmV]\\n\", vmin, vmax);\n\treturn ret;\n}\n\nstatic void pxa_cpufreq_init_voltages(void)\n{\n\tvcc_core = regulator_get(NULL, \"vcc_core\");\n\tif (IS_ERR(vcc_core)) {\n\t\tpr_info(\"Didn't find vcc_core regulator\\n\");\n\t\tvcc_core = NULL;\n\t} else {\n\t\tpr_info(\"Found vcc_core regulator\\n\");\n\t}\n}\n#else\nstatic int pxa_cpufreq_change_voltage(const struct pxa_freqs *pxa_freq)\n{\n\treturn 0;\n}\n\nstatic void pxa_cpufreq_init_voltages(void) { }\n#endif\n\nstatic void find_freq_tables(struct cpufreq_frequency_table **freq_table,\n\t\t\t     const struct pxa_freqs **pxa_freqs)\n{\n\tif (cpu_is_pxa25x()) {\n\t\tif (!pxa255_turbo_table) {\n\t\t\t*pxa_freqs = pxa255_run_freqs;\n\t\t\t*freq_table = pxa255_run_freq_table;\n\t\t} else {\n\t\t\t*pxa_freqs = pxa255_turbo_freqs;\n\t\t\t*freq_table = pxa255_turbo_freq_table;\n\t\t}\n\t} else if (cpu_is_pxa27x()) {\n\t\t*pxa_freqs = pxa27x_freqs;\n\t\t*freq_table = pxa27x_freq_table;\n\t} else {\n\t\tBUG();\n\t}\n}\n\nstatic void pxa27x_guess_max_freq(void)\n{\n\tif (!pxa27x_maxfreq) {\n\t\tpxa27x_maxfreq = 416000;\n\t\tpr_info(\"PXA CPU 27x max frequency not defined (pxa27x_maxfreq), assuming pxa271 with %dkHz maxfreq\\n\",\n\t\t\tpxa27x_maxfreq);\n\t} else {\n\t\tpxa27x_maxfreq *= 1000;\n\t}\n}\n\nstatic unsigned int pxa_cpufreq_get(unsigned int cpu)\n{\n\tstruct pxa_cpufreq_data *data = cpufreq_get_driver_data();\n\n\treturn (unsigned int) clk_get_rate(data->clk_core) / 1000;\n}\n\nstatic int pxa_set_target(struct cpufreq_policy *policy, unsigned int idx)\n{\n\tstruct cpufreq_frequency_table *pxa_freqs_table;\n\tconst struct pxa_freqs *pxa_freq_settings;\n\tstruct pxa_cpufreq_data *data = cpufreq_get_driver_data();\n\tunsigned int new_freq_cpu;\n\tint ret = 0;\n\n\t \n\tfind_freq_tables(&pxa_freqs_table, &pxa_freq_settings);\n\n\tnew_freq_cpu = pxa_freq_settings[idx].khz;\n\n\tif (freq_debug)\n\t\tpr_debug(\"Changing CPU frequency from %d Mhz to %d Mhz\\n\",\n\t\t\t policy->cur / 1000,  new_freq_cpu / 1000);\n\n\tif (vcc_core && new_freq_cpu > policy->cur) {\n\t\tret = pxa_cpufreq_change_voltage(&pxa_freq_settings[idx]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tclk_set_rate(data->clk_core, new_freq_cpu * 1000);\n\n\t \n\tif (vcc_core && new_freq_cpu < policy->cur)\n\t\tret = pxa_cpufreq_change_voltage(&pxa_freq_settings[idx]);\n\n\treturn 0;\n}\n\nstatic int pxa_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tint i;\n\tunsigned int freq;\n\tstruct cpufreq_frequency_table *pxa255_freq_table;\n\tconst struct pxa_freqs *pxa255_freqs;\n\n\t \n\tif (cpu_is_pxa27x())\n\t\tpxa27x_guess_max_freq();\n\n\tpxa_cpufreq_init_voltages();\n\n\t \n\tpolicy->cpuinfo.transition_latency = 1000;  \n\n\t \n\tfor (i = 0; i < NUM_PXA25x_RUN_FREQS; i++) {\n\t\tpxa255_run_freq_table[i].frequency = pxa255_run_freqs[i].khz;\n\t\tpxa255_run_freq_table[i].driver_data = i;\n\t}\n\tpxa255_run_freq_table[i].frequency = CPUFREQ_TABLE_END;\n\n\t \n\tfor (i = 0; i < NUM_PXA25x_TURBO_FREQS; i++) {\n\t\tpxa255_turbo_freq_table[i].frequency =\n\t\t\tpxa255_turbo_freqs[i].khz;\n\t\tpxa255_turbo_freq_table[i].driver_data = i;\n\t}\n\tpxa255_turbo_freq_table[i].frequency = CPUFREQ_TABLE_END;\n\n\tpxa255_turbo_table = !!pxa255_turbo_table;\n\n\t \n\tfor (i = 0; i < NUM_PXA27x_FREQS; i++) {\n\t\tfreq = pxa27x_freqs[i].khz;\n\t\tif (freq > pxa27x_maxfreq)\n\t\t\tbreak;\n\t\tpxa27x_freq_table[i].frequency = freq;\n\t\tpxa27x_freq_table[i].driver_data = i;\n\t}\n\tpxa27x_freq_table[i].driver_data = i;\n\tpxa27x_freq_table[i].frequency = CPUFREQ_TABLE_END;\n\n\t \n\tif (cpu_is_pxa25x()) {\n\t\tfind_freq_tables(&pxa255_freq_table, &pxa255_freqs);\n\t\tpr_info(\"using %s frequency table\\n\",\n\t\t\tpxa255_turbo_table ? \"turbo\" : \"run\");\n\n\t\tpolicy->freq_table = pxa255_freq_table;\n\t}\n\telse if (cpu_is_pxa27x()) {\n\t\tpolicy->freq_table = pxa27x_freq_table;\n\t}\n\n\tpr_info(\"frequency change support initialized\\n\");\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver pxa_cpufreq_driver = {\n\t.flags\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.target_index = pxa_set_target,\n\t.init\t= pxa_cpufreq_init,\n\t.get\t= pxa_cpufreq_get,\n\t.name\t= \"PXA2xx\",\n\t.driver_data = &pxa_cpufreq_data,\n};\n\nstatic int __init pxa_cpu_init(void)\n{\n\tint ret = -ENODEV;\n\n\tpxa_cpufreq_data.clk_core = clk_get_sys(NULL, \"core\");\n\tif (IS_ERR(pxa_cpufreq_data.clk_core))\n\t\treturn PTR_ERR(pxa_cpufreq_data.clk_core);\n\n\tif (cpu_is_pxa25x() || cpu_is_pxa27x())\n\t\tret = cpufreq_register_driver(&pxa_cpufreq_driver);\n\treturn ret;\n}\n\nstatic void __exit pxa_cpu_exit(void)\n{\n\tcpufreq_unregister_driver(&pxa_cpufreq_driver);\n}\n\n\nMODULE_AUTHOR(\"Intrinsyc Software Inc.\");\nMODULE_DESCRIPTION(\"CPU frequency changing driver for the PXA architecture\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(pxa_cpu_init);\nmodule_exit(pxa_cpu_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}