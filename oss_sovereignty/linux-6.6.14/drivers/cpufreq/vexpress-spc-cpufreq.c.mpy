{
  "module_name": "vexpress-spc-cpufreq.c",
  "hash_id": "461234441cc5c937b7d55da5a5cc0f73a7a32e838be0d2a77b821a83b2699eb8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/vexpress-spc-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/cpumask.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/topology.h>\n#include <linux/types.h>\n\n \n#define A15_CLUSTER\t0\n#define A7_CLUSTER\t1\n#define MAX_CLUSTERS\t2\n\n#ifdef CONFIG_BL_SWITCHER\n#include <asm/bL_switcher.h>\nstatic bool bL_switching_enabled;\n#define is_bL_switching_enabled()\tbL_switching_enabled\n#define set_switching_enabled(x)\t(bL_switching_enabled = (x))\n#else\n#define is_bL_switching_enabled()\tfalse\n#define set_switching_enabled(x)\tdo { } while (0)\n#define bL_switch_request(...)\t\tdo { } while (0)\n#define bL_switcher_put_enabled()\tdo { } while (0)\n#define bL_switcher_get_enabled()\tdo { } while (0)\n#endif\n\n#define ACTUAL_FREQ(cluster, freq)  ((cluster == A7_CLUSTER) ? freq << 1 : freq)\n#define VIRT_FREQ(cluster, freq)    ((cluster == A7_CLUSTER) ? freq >> 1 : freq)\n\nstatic struct clk *clk[MAX_CLUSTERS];\nstatic struct cpufreq_frequency_table *freq_table[MAX_CLUSTERS + 1];\nstatic atomic_t cluster_usage[MAX_CLUSTERS + 1];\n\nstatic unsigned int clk_big_min;\t \nstatic unsigned int clk_little_max;\t \n\nstatic DEFINE_PER_CPU(unsigned int, physical_cluster);\nstatic DEFINE_PER_CPU(unsigned int, cpu_last_req_freq);\n\nstatic struct mutex cluster_lock[MAX_CLUSTERS];\n\nstatic inline int raw_cpu_to_cluster(int cpu)\n{\n\treturn topology_physical_package_id(cpu);\n}\n\nstatic inline int cpu_to_cluster(int cpu)\n{\n\treturn is_bL_switching_enabled() ?\n\t\tMAX_CLUSTERS : raw_cpu_to_cluster(cpu);\n}\n\nstatic unsigned int find_cluster_maxfreq(int cluster)\n{\n\tint j;\n\tu32 max_freq = 0, cpu_freq;\n\n\tfor_each_online_cpu(j) {\n\t\tcpu_freq = per_cpu(cpu_last_req_freq, j);\n\n\t\tif (cluster == per_cpu(physical_cluster, j) &&\n\t\t    max_freq < cpu_freq)\n\t\t\tmax_freq = cpu_freq;\n\t}\n\n\treturn max_freq;\n}\n\nstatic unsigned int clk_get_cpu_rate(unsigned int cpu)\n{\n\tu32 cur_cluster = per_cpu(physical_cluster, cpu);\n\tu32 rate = clk_get_rate(clk[cur_cluster]) / 1000;\n\n\t \n\tif (is_bL_switching_enabled())\n\t\trate = VIRT_FREQ(cur_cluster, rate);\n\n\treturn rate;\n}\n\nstatic unsigned int ve_spc_cpufreq_get_rate(unsigned int cpu)\n{\n\tif (is_bL_switching_enabled())\n\t\treturn per_cpu(cpu_last_req_freq, cpu);\n\telse\n\t\treturn clk_get_cpu_rate(cpu);\n}\n\nstatic unsigned int\nve_spc_cpufreq_set_rate(u32 cpu, u32 old_cluster, u32 new_cluster, u32 rate)\n{\n\tu32 new_rate, prev_rate;\n\tint ret;\n\tbool bLs = is_bL_switching_enabled();\n\n\tmutex_lock(&cluster_lock[new_cluster]);\n\n\tif (bLs) {\n\t\tprev_rate = per_cpu(cpu_last_req_freq, cpu);\n\t\tper_cpu(cpu_last_req_freq, cpu) = rate;\n\t\tper_cpu(physical_cluster, cpu) = new_cluster;\n\n\t\tnew_rate = find_cluster_maxfreq(new_cluster);\n\t\tnew_rate = ACTUAL_FREQ(new_cluster, new_rate);\n\t} else {\n\t\tnew_rate = rate;\n\t}\n\n\tret = clk_set_rate(clk[new_cluster], new_rate * 1000);\n\tif (!ret) {\n\t\t \n\t\tif (clk_get_rate(clk[new_cluster]) != new_rate * 1000)\n\t\t\tret = -EIO;\n\t}\n\n\tif (WARN_ON(ret)) {\n\t\tif (bLs) {\n\t\t\tper_cpu(cpu_last_req_freq, cpu) = prev_rate;\n\t\t\tper_cpu(physical_cluster, cpu) = old_cluster;\n\t\t}\n\n\t\tmutex_unlock(&cluster_lock[new_cluster]);\n\n\t\treturn ret;\n\t}\n\n\tmutex_unlock(&cluster_lock[new_cluster]);\n\n\t \n\tif (old_cluster != new_cluster) {\n\t\t \n\t\tbL_switch_request(cpu, new_cluster);\n\n\t\tmutex_lock(&cluster_lock[old_cluster]);\n\n\t\t \n\t\tnew_rate = find_cluster_maxfreq(old_cluster);\n\t\tnew_rate = ACTUAL_FREQ(old_cluster, new_rate);\n\n\t\tif (new_rate &&\n\t\t    clk_set_rate(clk[old_cluster], new_rate * 1000)) {\n\t\t\tpr_err(\"%s: clk_set_rate failed: %d, old cluster: %d\\n\",\n\t\t\t       __func__, ret, old_cluster);\n\t\t}\n\t\tmutex_unlock(&cluster_lock[old_cluster]);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ve_spc_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t     unsigned int index)\n{\n\tu32 cpu = policy->cpu, cur_cluster, new_cluster, actual_cluster;\n\tunsigned int freqs_new;\n\n\tcur_cluster = cpu_to_cluster(cpu);\n\tnew_cluster = actual_cluster = per_cpu(physical_cluster, cpu);\n\n\tfreqs_new = freq_table[cur_cluster][index].frequency;\n\n\tif (is_bL_switching_enabled()) {\n\t\tif (actual_cluster == A15_CLUSTER && freqs_new < clk_big_min)\n\t\t\tnew_cluster = A7_CLUSTER;\n\t\telse if (actual_cluster == A7_CLUSTER &&\n\t\t\t freqs_new > clk_little_max)\n\t\t\tnew_cluster = A15_CLUSTER;\n\t}\n\n\treturn ve_spc_cpufreq_set_rate(cpu, actual_cluster, new_cluster,\n\t\t\t\t       freqs_new);\n}\n\nstatic inline u32 get_table_count(struct cpufreq_frequency_table *table)\n{\n\tint count;\n\n\tfor (count = 0; table[count].frequency != CPUFREQ_TABLE_END; count++)\n\t\t;\n\n\treturn count;\n}\n\n \nstatic inline u32 get_table_min(struct cpufreq_frequency_table *table)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tu32 min_freq = ~0;\n\n\tcpufreq_for_each_entry(pos, table)\n\t\tif (pos->frequency < min_freq)\n\t\t\tmin_freq = pos->frequency;\n\treturn min_freq;\n}\n\n \nstatic inline u32 get_table_max(struct cpufreq_frequency_table *table)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tu32 max_freq = 0;\n\n\tcpufreq_for_each_entry(pos, table)\n\t\tif (pos->frequency > max_freq)\n\t\t\tmax_freq = pos->frequency;\n\treturn max_freq;\n}\n\nstatic bool search_frequency(struct cpufreq_frequency_table *table, int size,\n\t\t\t     unsigned int freq)\n{\n\tint count;\n\n\tfor (count = 0; count < size; count++) {\n\t\tif (table[count].frequency == freq)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int merge_cluster_tables(void)\n{\n\tint i, j, k = 0, count = 1;\n\tstruct cpufreq_frequency_table *table;\n\n\tfor (i = 0; i < MAX_CLUSTERS; i++)\n\t\tcount += get_table_count(freq_table[i]);\n\n\ttable = kcalloc(count, sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\treturn -ENOMEM;\n\n\tfreq_table[MAX_CLUSTERS] = table;\n\n\t \n\tfor (i = MAX_CLUSTERS - 1; i >= 0; i--, count = k) {\n\t\tfor (j = 0; freq_table[i][j].frequency != CPUFREQ_TABLE_END;\n\t\t     j++) {\n\t\t\tif (i == A15_CLUSTER &&\n\t\t\t    search_frequency(table, count, freq_table[i][j].frequency))\n\t\t\t\tcontinue;  \n\t\t\ttable[k++].frequency =\n\t\t\t\tVIRT_FREQ(i, freq_table[i][j].frequency);\n\t\t}\n\t}\n\n\ttable[k].driver_data = k;\n\ttable[k].frequency = CPUFREQ_TABLE_END;\n\n\treturn 0;\n}\n\nstatic void _put_cluster_clk_and_freq_table(struct device *cpu_dev,\n\t\t\t\t\t    const struct cpumask *cpumask)\n{\n\tu32 cluster = raw_cpu_to_cluster(cpu_dev->id);\n\n\tif (!freq_table[cluster])\n\t\treturn;\n\n\tclk_put(clk[cluster]);\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);\n}\n\nstatic void put_cluster_clk_and_freq_table(struct device *cpu_dev,\n\t\t\t\t\t   const struct cpumask *cpumask)\n{\n\tu32 cluster = cpu_to_cluster(cpu_dev->id);\n\tint i;\n\n\tif (atomic_dec_return(&cluster_usage[cluster]))\n\t\treturn;\n\n\tif (cluster < MAX_CLUSTERS)\n\t\treturn _put_cluster_clk_and_freq_table(cpu_dev, cpumask);\n\n\tfor_each_present_cpu(i) {\n\t\tstruct device *cdev = get_cpu_device(i);\n\n\t\tif (!cdev)\n\t\t\treturn;\n\n\t\t_put_cluster_clk_and_freq_table(cdev, cpumask);\n\t}\n\n\t \n\tkfree(freq_table[cluster]);\n}\n\nstatic int _get_cluster_clk_and_freq_table(struct device *cpu_dev,\n\t\t\t\t\t   const struct cpumask *cpumask)\n{\n\tu32 cluster = raw_cpu_to_cluster(cpu_dev->id);\n\tint ret;\n\n\tif (freq_table[cluster])\n\t\treturn 0;\n\n\t \n\tret = dev_pm_opp_get_opp_count(cpu_dev) <= 0;\n\tif (ret)\n\t\tgoto out;\n\n\tret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table[cluster]);\n\tif (ret)\n\t\tgoto out;\n\n\tclk[cluster] = clk_get(cpu_dev, NULL);\n\tif (!IS_ERR(clk[cluster]))\n\t\treturn 0;\n\n\tdev_err(cpu_dev, \"%s: Failed to get clk for cpu: %d, cluster: %d\\n\",\n\t\t__func__, cpu_dev->id, cluster);\n\tret = PTR_ERR(clk[cluster]);\n\tdev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table[cluster]);\n\nout:\n\tdev_err(cpu_dev, \"%s: Failed to get data for cluster: %d\\n\", __func__,\n\t\tcluster);\n\treturn ret;\n}\n\nstatic int get_cluster_clk_and_freq_table(struct device *cpu_dev,\n\t\t\t\t\t  const struct cpumask *cpumask)\n{\n\tu32 cluster = cpu_to_cluster(cpu_dev->id);\n\tint i, ret;\n\n\tif (atomic_inc_return(&cluster_usage[cluster]) != 1)\n\t\treturn 0;\n\n\tif (cluster < MAX_CLUSTERS) {\n\t\tret = _get_cluster_clk_and_freq_table(cpu_dev, cpumask);\n\t\tif (ret)\n\t\t\tatomic_dec(&cluster_usage[cluster]);\n\t\treturn ret;\n\t}\n\n\t \n\tfor_each_present_cpu(i) {\n\t\tstruct device *cdev = get_cpu_device(i);\n\n\t\tif (!cdev)\n\t\t\treturn -ENODEV;\n\n\t\tret = _get_cluster_clk_and_freq_table(cdev, cpumask);\n\t\tif (ret)\n\t\t\tgoto put_clusters;\n\t}\n\n\tret = merge_cluster_tables();\n\tif (ret)\n\t\tgoto put_clusters;\n\n\t \n\tclk_big_min = get_table_min(freq_table[A15_CLUSTER]);\n\tclk_little_max = VIRT_FREQ(A7_CLUSTER,\n\t\t\t\t   get_table_max(freq_table[A7_CLUSTER]));\n\n\treturn 0;\n\nput_clusters:\n\tfor_each_present_cpu(i) {\n\t\tstruct device *cdev = get_cpu_device(i);\n\n\t\tif (!cdev)\n\t\t\treturn -ENODEV;\n\n\t\t_put_cluster_clk_and_freq_table(cdev, cpumask);\n\t}\n\n\tatomic_dec(&cluster_usage[cluster]);\n\n\treturn ret;\n}\n\n \nstatic int ve_spc_cpufreq_init(struct cpufreq_policy *policy)\n{\n\tu32 cur_cluster = cpu_to_cluster(policy->cpu);\n\tstruct device *cpu_dev;\n\tint ret;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"%s: failed to get cpu%d device\\n\", __func__,\n\t\t       policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\tif (cur_cluster < MAX_CLUSTERS) {\n\t\tint cpu;\n\n\t\tdev_pm_opp_get_sharing_cpus(cpu_dev, policy->cpus);\n\n\t\tfor_each_cpu(cpu, policy->cpus)\n\t\t\tper_cpu(physical_cluster, cpu) = cur_cluster;\n\t} else {\n\t\t \n\t\tper_cpu(physical_cluster, policy->cpu) = A15_CLUSTER;\n\t}\n\n\tret = get_cluster_clk_and_freq_table(cpu_dev, policy->cpus);\n\tif (ret)\n\t\treturn ret;\n\n\tpolicy->freq_table = freq_table[cur_cluster];\n\tpolicy->cpuinfo.transition_latency = 1000000;  \n\n\tif (is_bL_switching_enabled())\n\t\tper_cpu(cpu_last_req_freq, policy->cpu) =\n\t\t\t\t\t\tclk_get_cpu_rate(policy->cpu);\n\n\tdev_info(cpu_dev, \"%s: CPU %d initialized\\n\", __func__, policy->cpu);\n\treturn 0;\n}\n\nstatic int ve_spc_cpufreq_exit(struct cpufreq_policy *policy)\n{\n\tstruct device *cpu_dev;\n\n\tcpu_dev = get_cpu_device(policy->cpu);\n\tif (!cpu_dev) {\n\t\tpr_err(\"%s: failed to get cpu%d device\\n\", __func__,\n\t\t       policy->cpu);\n\t\treturn -ENODEV;\n\t}\n\n\tput_cluster_clk_and_freq_table(cpu_dev, policy->related_cpus);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver ve_spc_cpufreq_driver = {\n\t.name\t\t\t= \"vexpress-spc\",\n\t.flags\t\t\t= CPUFREQ_HAVE_GOVERNOR_PER_POLICY |\n\t\t\t\t\tCPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t\t= ve_spc_cpufreq_set_target,\n\t.get\t\t\t= ve_spc_cpufreq_get_rate,\n\t.init\t\t\t= ve_spc_cpufreq_init,\n\t.exit\t\t\t= ve_spc_cpufreq_exit,\n\t.register_em\t\t= cpufreq_register_em_with_opp,\n\t.attr\t\t\t= cpufreq_generic_attr,\n};\n\n#ifdef CONFIG_BL_SWITCHER\nstatic int bL_cpufreq_switcher_notifier(struct notifier_block *nfb,\n\t\t\t\t\tunsigned long action, void *_arg)\n{\n\tpr_debug(\"%s: action: %ld\\n\", __func__, action);\n\n\tswitch (action) {\n\tcase BL_NOTIFY_PRE_ENABLE:\n\tcase BL_NOTIFY_PRE_DISABLE:\n\t\tcpufreq_unregister_driver(&ve_spc_cpufreq_driver);\n\t\tbreak;\n\n\tcase BL_NOTIFY_POST_ENABLE:\n\t\tset_switching_enabled(true);\n\t\tcpufreq_register_driver(&ve_spc_cpufreq_driver);\n\t\tbreak;\n\n\tcase BL_NOTIFY_POST_DISABLE:\n\t\tset_switching_enabled(false);\n\t\tcpufreq_register_driver(&ve_spc_cpufreq_driver);\n\t\tbreak;\n\n\tdefault:\n\t\treturn NOTIFY_DONE;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block bL_switcher_notifier = {\n\t.notifier_call = bL_cpufreq_switcher_notifier,\n};\n\nstatic int __bLs_register_notifier(void)\n{\n\treturn bL_switcher_register_notifier(&bL_switcher_notifier);\n}\n\nstatic int __bLs_unregister_notifier(void)\n{\n\treturn bL_switcher_unregister_notifier(&bL_switcher_notifier);\n}\n#else\nstatic int __bLs_register_notifier(void) { return 0; }\nstatic int __bLs_unregister_notifier(void) { return 0; }\n#endif\n\nstatic int ve_spc_cpufreq_probe(struct platform_device *pdev)\n{\n\tint ret, i;\n\n\tset_switching_enabled(bL_switcher_get_enabled());\n\n\tfor (i = 0; i < MAX_CLUSTERS; i++)\n\t\tmutex_init(&cluster_lock[i]);\n\n\tif (!is_bL_switching_enabled())\n\t\tve_spc_cpufreq_driver.flags |= CPUFREQ_IS_COOLING_DEV;\n\n\tret = cpufreq_register_driver(&ve_spc_cpufreq_driver);\n\tif (ret) {\n\t\tpr_info(\"%s: Failed registering platform driver: %s, err: %d\\n\",\n\t\t\t__func__, ve_spc_cpufreq_driver.name, ret);\n\t} else {\n\t\tret = __bLs_register_notifier();\n\t\tif (ret)\n\t\t\tcpufreq_unregister_driver(&ve_spc_cpufreq_driver);\n\t\telse\n\t\t\tpr_info(\"%s: Registered platform driver: %s\\n\",\n\t\t\t\t__func__, ve_spc_cpufreq_driver.name);\n\t}\n\n\tbL_switcher_put_enabled();\n\treturn ret;\n}\n\nstatic void ve_spc_cpufreq_remove(struct platform_device *pdev)\n{\n\tbL_switcher_get_enabled();\n\t__bLs_unregister_notifier();\n\tcpufreq_unregister_driver(&ve_spc_cpufreq_driver);\n\tbL_switcher_put_enabled();\n\tpr_info(\"%s: Un-registered platform driver: %s\\n\", __func__,\n\t\tve_spc_cpufreq_driver.name);\n}\n\nstatic struct platform_driver ve_spc_cpufreq_platdrv = {\n\t.driver = {\n\t\t.name\t= \"vexpress-spc-cpufreq\",\n\t},\n\t.probe\t\t= ve_spc_cpufreq_probe,\n\t.remove_new\t= ve_spc_cpufreq_remove,\n};\nmodule_platform_driver(ve_spc_cpufreq_platdrv);\n\nMODULE_ALIAS(\"platform:vexpress-spc-cpufreq\");\nMODULE_AUTHOR(\"Viresh Kumar <viresh.kumar@linaro.org>\");\nMODULE_AUTHOR(\"Sudeep Holla <sudeep.holla@arm.com>\");\nMODULE_DESCRIPTION(\"Vexpress SPC ARM big LITTLE cpufreq driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}