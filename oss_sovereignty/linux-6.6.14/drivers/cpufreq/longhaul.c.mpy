{
  "module_name": "longhaul.c",
  "hash_id": "eaa51561cd8ed5e81698a11aa7ff7fa9f9615b88e0f9d0cc8b6faf0d5d4ca8dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/longhaul.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/timex.h>\n#include <linux/io.h>\n#include <linux/acpi.h>\n\n#include <asm/msr.h>\n#include <asm/cpu_device_id.h>\n#include <acpi/processor.h>\n\n#include \"longhaul.h\"\n\n#define TYPE_LONGHAUL_V1\t1\n#define TYPE_LONGHAUL_V2\t2\n#define TYPE_POWERSAVER\t\t3\n\n#define\tCPU_SAMUEL\t1\n#define\tCPU_SAMUEL2\t2\n#define\tCPU_EZRA\t3\n#define\tCPU_EZRA_T\t4\n#define\tCPU_NEHEMIAH\t5\n#define\tCPU_NEHEMIAH_C\t6\n\n \n#define USE_ACPI_C3\t\t(1 << 1)\n#define USE_NORTHBRIDGE\t\t(1 << 2)\n\nstatic int cpu_model;\nstatic unsigned int numscales = 16;\nstatic unsigned int fsb;\n\nstatic const struct mV_pos *vrm_mV_table;\nstatic const unsigned char *mV_vrm_table;\n\nstatic unsigned int highest_speed, lowest_speed;  \nstatic unsigned int minmult, maxmult;\nstatic int can_scale_voltage;\nstatic struct acpi_processor *pr;\nstatic struct acpi_processor_cx *cx;\nstatic u32 acpi_regs_addr;\nstatic u8 longhaul_flags;\nstatic unsigned int longhaul_index;\n\n \nstatic int scale_voltage;\nstatic int disable_acpi_c3;\nstatic int revid_errata;\nstatic int enable;\n\n \nstatic int mults[32];\nstatic int eblcr[32];\nstatic int longhaul_version;\nstatic struct cpufreq_frequency_table *longhaul_table;\n\nstatic char speedbuffer[8];\n\nstatic char *print_speed(int speed)\n{\n\tif (speed < 1000) {\n\t\tsnprintf(speedbuffer, sizeof(speedbuffer), \"%dMHz\", speed);\n\t\treturn speedbuffer;\n\t}\n\n\tif (speed%1000 == 0)\n\t\tsnprintf(speedbuffer, sizeof(speedbuffer),\n\t\t\t\"%dGHz\", speed/1000);\n\telse\n\t\tsnprintf(speedbuffer, sizeof(speedbuffer),\n\t\t\t\"%d.%dGHz\", speed/1000, (speed%1000)/100);\n\n\treturn speedbuffer;\n}\n\n\nstatic unsigned int calc_speed(int mult)\n{\n\tint khz;\n\tkhz = (mult/10)*fsb;\n\tif (mult%10)\n\t\tkhz += fsb/2;\n\tkhz *= 1000;\n\treturn khz;\n}\n\n\nstatic int longhaul_get_cpu_mult(void)\n{\n\tunsigned long invalue = 0, lo, hi;\n\n\trdmsr(MSR_IA32_EBL_CR_POWERON, lo, hi);\n\tinvalue = (lo & (1<<22|1<<23|1<<24|1<<25))>>22;\n\tif (longhaul_version == TYPE_LONGHAUL_V2 ||\n\t    longhaul_version == TYPE_POWERSAVER) {\n\t\tif (lo & (1<<27))\n\t\t\tinvalue += 16;\n\t}\n\treturn eblcr[invalue];\n}\n\n \n\nstatic void do_longhaul1(unsigned int mults_index)\n{\n\tunion msr_bcr2 bcr2;\n\n\trdmsrl(MSR_VIA_BCR2, bcr2.val);\n\t \n\tbcr2.bits.ESOFTBF = 1;\n\tbcr2.bits.CLOCKMUL = mults_index & 0xff;\n\n\t \n\tsafe_halt();\n\t \n\twrmsrl(MSR_VIA_BCR2, bcr2.val);\n\t \n\tACPI_FLUSH_CPU_CACHE();\n\thalt();\n\n\t \n\tlocal_irq_disable();\n\trdmsrl(MSR_VIA_BCR2, bcr2.val);\n\tbcr2.bits.ESOFTBF = 0;\n\twrmsrl(MSR_VIA_BCR2, bcr2.val);\n}\n\n \n\nstatic void do_powersaver(int cx_address, unsigned int mults_index,\n\t\t\t  unsigned int dir)\n{\n\tunion msr_longhaul longhaul;\n\tu32 t;\n\n\trdmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\t \n\tif (!revid_errata)\n\t\tlonghaul.bits.RevisionKey = longhaul.bits.RevisionID;\n\telse\n\t\tlonghaul.bits.RevisionKey = 0;\n\tlonghaul.bits.SoftBusRatio = mults_index & 0xf;\n\tlonghaul.bits.SoftBusRatio4 = (mults_index & 0x10) >> 4;\n\t \n\tif (can_scale_voltage)\n\t\tlonghaul.bits.SoftVID = (mults_index >> 8) & 0x1f;\n\t \n\tsafe_halt();\n\t \n\tif (can_scale_voltage && dir) {\n\t\tlonghaul.bits.EnableSoftVID = 1;\n\t\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\t\t \n\t\tif (!cx_address) {\n\t\t\tACPI_FLUSH_CPU_CACHE();\n\t\t\thalt();\n\t\t} else {\n\t\t\tACPI_FLUSH_CPU_CACHE();\n\t\t\t \n\t\t\tinb(cx_address);\n\t\t\t \n\t\t\tt = inl(acpi_gbl_FADT.xpm_timer_block.address);\n\t\t}\n\t\tlonghaul.bits.EnableSoftVID = 0;\n\t\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\t}\n\n\t \n\tlonghaul.bits.EnableSoftBusRatio = 1;\n\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\tif (!cx_address) {\n\t\tACPI_FLUSH_CPU_CACHE();\n\t\thalt();\n\t} else {\n\t\tACPI_FLUSH_CPU_CACHE();\n\t\t \n\t\tinb(cx_address);\n\t\t \n\t\tt = inl(acpi_gbl_FADT.xpm_timer_block.address);\n\t}\n\t \n\tlonghaul.bits.EnableSoftBusRatio = 0;\n\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\n\t \n\tif (can_scale_voltage && !dir) {\n\t\tlonghaul.bits.EnableSoftVID = 1;\n\t\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\t\t \n\t\tif (!cx_address) {\n\t\t\tACPI_FLUSH_CPU_CACHE();\n\t\t\thalt();\n\t\t} else {\n\t\t\tACPI_FLUSH_CPU_CACHE();\n\t\t\t \n\t\t\tinb(cx_address);\n\t\t\t \n\t\t\tt = inl(acpi_gbl_FADT.xpm_timer_block.address);\n\t\t}\n\t\tlonghaul.bits.EnableSoftVID = 0;\n\t\twrmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\t}\n}\n\n \n\nstatic int longhaul_setstate(struct cpufreq_policy *policy,\n\t\tunsigned int table_index)\n{\n\tunsigned int mults_index;\n\tint speed, mult;\n\tstruct cpufreq_freqs freqs;\n\tunsigned long flags;\n\tunsigned int pic1_mask, pic2_mask;\n\tu16 bm_status = 0;\n\tu32 bm_timeout = 1000;\n\tunsigned int dir = 0;\n\n\tmults_index = longhaul_table[table_index].driver_data;\n\t \n\tmult = mults[mults_index & 0x1f];\n\tif (mult == -1)\n\t\treturn -EINVAL;\n\n\tspeed = calc_speed(mult);\n\tif ((speed > highest_speed) || (speed < lowest_speed))\n\t\treturn -EINVAL;\n\n\t \n\tif (can_scale_voltage && longhaul_index < table_index)\n\t\tdir = 1;\n\n\tfreqs.old = calc_speed(longhaul_get_cpu_mult());\n\tfreqs.new = speed;\n\n\tpr_debug(\"Setting to FSB:%dMHz Mult:%d.%dx (%s)\\n\",\n\t\t\tfsb, mult/10, mult%10, print_speed(speed/1000));\nretry_loop:\n\tpreempt_disable();\n\tlocal_irq_save(flags);\n\n\tpic2_mask = inb(0xA1);\n\tpic1_mask = inb(0x21);\t \n\toutb(0xFF, 0xA1);\t \n\toutb(0xFE, 0x21);\t \n\n\t \n\tif (acpi_regs_addr && (longhaul_flags & USE_NORTHBRIDGE\n\t    || ((pr != NULL) && pr->flags.bm_control))) {\n\t\tbm_status = inw(acpi_regs_addr);\n\t\tbm_status &= 1 << 4;\n\t\twhile (bm_status && bm_timeout) {\n\t\t\toutw(1 << 4, acpi_regs_addr);\n\t\t\tbm_timeout--;\n\t\t\tbm_status = inw(acpi_regs_addr);\n\t\t\tbm_status &= 1 << 4;\n\t\t}\n\t}\n\n\tif (longhaul_flags & USE_NORTHBRIDGE) {\n\t\t \n\t\toutb(3, 0x22);\n\t} else if ((pr != NULL) && pr->flags.bm_control) {\n\t\t \n\t\tacpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 1);\n\t}\n\tswitch (longhaul_version) {\n\n\t \n\tcase TYPE_LONGHAUL_V1:\n\t\tdo_longhaul1(mults_index);\n\t\tbreak;\n\n\t \n\tcase TYPE_LONGHAUL_V2:\n\tcase TYPE_POWERSAVER:\n\t\tif (longhaul_flags & USE_ACPI_C3) {\n\t\t\t \n\t\t\tacpi_write_bit_register(ACPI_BITREG_BUS_MASTER_RLD, 0);\n\t\t\tdo_powersaver(cx->address, mults_index, dir);\n\t\t} else {\n\t\t\tdo_powersaver(0, mults_index, dir);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (longhaul_flags & USE_NORTHBRIDGE) {\n\t\t \n\t\toutb(0, 0x22);\n\t} else if ((pr != NULL) && pr->flags.bm_control) {\n\t\t \n\t\tacpi_write_bit_register(ACPI_BITREG_ARB_DISABLE, 0);\n\t}\n\toutb(pic2_mask, 0xA1);\t \n\toutb(pic1_mask, 0x21);\n\n\tlocal_irq_restore(flags);\n\tpreempt_enable();\n\n\tfreqs.new = calc_speed(longhaul_get_cpu_mult());\n\t \n\tif (unlikely(freqs.new != speed)) {\n\t\tpr_info(\"Failed to set requested frequency!\\n\");\n\t\t \n\t\tif (!revid_errata) {\n\t\t\tpr_info(\"Enabling \\\"Ignore Revision ID\\\" option\\n\");\n\t\t\trevid_errata = 1;\n\t\t\tmsleep(200);\n\t\t\tgoto retry_loop;\n\t\t}\n\t\t \n\t\tif (longhaul_flags & USE_ACPI_C3) {\n\t\t\tpr_info(\"Disabling ACPI C3 support\\n\");\n\t\t\tlonghaul_flags &= ~USE_ACPI_C3;\n\t\t\tif (revid_errata) {\n\t\t\t\tpr_info(\"Disabling \\\"Ignore Revision ID\\\" option\\n\");\n\t\t\t\trevid_errata = 0;\n\t\t\t}\n\t\t\tmsleep(200);\n\t\t\tgoto retry_loop;\n\t\t}\n\t\t \n\t\tif (longhaul_version == TYPE_LONGHAUL_V2) {\n\t\t\tpr_info(\"Switching to Longhaul ver. 1\\n\");\n\t\t\tlonghaul_version = TYPE_LONGHAUL_V1;\n\t\t\tmsleep(200);\n\t\t\tgoto retry_loop;\n\t\t}\n\t}\n\n\tif (!bm_timeout) {\n\t\tpr_info(\"Warning: Timeout while waiting for idle PCI bus\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \n\n#define ROUNDING\t0xf\n\nstatic int guess_fsb(int mult)\n{\n\tint speed = cpu_khz / 1000;\n\tint i;\n\tstatic const int speeds[] = { 666, 1000, 1333, 2000 };\n\tint f_max, f_min;\n\n\tfor (i = 0; i < ARRAY_SIZE(speeds); i++) {\n\t\tf_max = ((speeds[i] * mult) + 50) / 100;\n\t\tf_max += (ROUNDING / 2);\n\t\tf_min = f_max - ROUNDING;\n\t\tif ((speed <= f_max) && (speed >= f_min))\n\t\t\treturn speeds[i] / 10;\n\t}\n\treturn 0;\n}\n\n\nstatic int longhaul_get_ranges(void)\n{\n\tunsigned int i, j, k = 0;\n\tunsigned int ratio;\n\tint mult;\n\n\t \n\tmult = longhaul_get_cpu_mult();\n\tif (mult == -1) {\n\t\tpr_info(\"Invalid (reserved) multiplier!\\n\");\n\t\treturn -EINVAL;\n\t}\n\tfsb = guess_fsb(mult);\n\tif (fsb == 0) {\n\t\tpr_info(\"Invalid (reserved) FSB!\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\tmaxmult = mult;\n\t \n\tswitch (cpu_model) {\n\tcase CPU_NEHEMIAH:\n\t\tminmult = 50;\n\t\tbreak;\n\tcase CPU_NEHEMIAH_C:\n\t\tminmult = 40;\n\t\tbreak;\n\tdefault:\n\t\tminmult = 30;\n\t\tbreak;\n\t}\n\n\tpr_debug(\"MinMult:%d.%dx MaxMult:%d.%dx\\n\",\n\t\t minmult/10, minmult%10, maxmult/10, maxmult%10);\n\n\thighest_speed = calc_speed(maxmult);\n\tlowest_speed = calc_speed(minmult);\n\tpr_debug(\"FSB:%dMHz  Lowest speed: %s   Highest speed:%s\\n\", fsb,\n\t\t print_speed(lowest_speed/1000),\n\t\t print_speed(highest_speed/1000));\n\n\tif (lowest_speed == highest_speed) {\n\t\tpr_info(\"highestspeed == lowest, aborting\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (lowest_speed > highest_speed) {\n\t\tpr_info(\"nonsense! lowest (%d > %d) !\\n\",\n\t\t\tlowest_speed, highest_speed);\n\t\treturn -EINVAL;\n\t}\n\n\tlonghaul_table = kcalloc(numscales + 1, sizeof(*longhaul_table),\n\t\t\t\t GFP_KERNEL);\n\tif (!longhaul_table)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < numscales; j++) {\n\t\tratio = mults[j];\n\t\tif (ratio == -1)\n\t\t\tcontinue;\n\t\tif (ratio > maxmult || ratio < minmult)\n\t\t\tcontinue;\n\t\tlonghaul_table[k].frequency = calc_speed(ratio);\n\t\tlonghaul_table[k].driver_data\t= j;\n\t\tk++;\n\t}\n\tif (k <= 1) {\n\t\tkfree(longhaul_table);\n\t\treturn -ENODEV;\n\t}\n\t \n\tfor (j = 0; j < k - 1; j++) {\n\t\tunsigned int min_f, min_i;\n\t\tmin_f = longhaul_table[j].frequency;\n\t\tmin_i = j;\n\t\tfor (i = j + 1; i < k; i++) {\n\t\t\tif (longhaul_table[i].frequency < min_f) {\n\t\t\t\tmin_f = longhaul_table[i].frequency;\n\t\t\t\tmin_i = i;\n\t\t\t}\n\t\t}\n\t\tif (min_i != j) {\n\t\t\tswap(longhaul_table[j].frequency,\n\t\t\t     longhaul_table[min_i].frequency);\n\t\t\tswap(longhaul_table[j].driver_data,\n\t\t\t     longhaul_table[min_i].driver_data);\n\t\t}\n\t}\n\n\tlonghaul_table[k].frequency = CPUFREQ_TABLE_END;\n\n\t \n\tfor (j = 0; j < k; j++) {\n\t\tif (mults[longhaul_table[j].driver_data & 0x1f] == mult) {\n\t\t\tlonghaul_index = j;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic void longhaul_setup_voltagescaling(void)\n{\n\tstruct cpufreq_frequency_table *freq_pos;\n\tunion msr_longhaul longhaul;\n\tstruct mV_pos minvid, maxvid, vid;\n\tunsigned int j, speed, pos, kHz_step, numvscales;\n\tint min_vid_speed;\n\n\trdmsrl(MSR_VIA_LONGHAUL, longhaul.val);\n\tif (!(longhaul.bits.RevisionID & 1)) {\n\t\tpr_info(\"Voltage scaling not supported by CPU\\n\");\n\t\treturn;\n\t}\n\n\tif (!longhaul.bits.VRMRev) {\n\t\tpr_info(\"VRM 8.5\\n\");\n\t\tvrm_mV_table = &vrm85_mV[0];\n\t\tmV_vrm_table = &mV_vrm85[0];\n\t} else {\n\t\tpr_info(\"Mobile VRM\\n\");\n\t\tif (cpu_model < CPU_NEHEMIAH)\n\t\t\treturn;\n\t\tvrm_mV_table = &mobilevrm_mV[0];\n\t\tmV_vrm_table = &mV_mobilevrm[0];\n\t}\n\n\tminvid = vrm_mV_table[longhaul.bits.MinimumVID];\n\tmaxvid = vrm_mV_table[longhaul.bits.MaximumVID];\n\n\tif (minvid.mV == 0 || maxvid.mV == 0 || minvid.mV > maxvid.mV) {\n\t\tpr_info(\"Bogus values Min:%d.%03d Max:%d.%03d - Voltage scaling disabled\\n\",\n\t\t\tminvid.mV/1000, minvid.mV%1000,\n\t\t\tmaxvid.mV/1000, maxvid.mV%1000);\n\t\treturn;\n\t}\n\n\tif (minvid.mV == maxvid.mV) {\n\t\tpr_info(\"Claims to support voltage scaling but min & max are both %d.%03d - Voltage scaling disabled\\n\",\n\t\t\tmaxvid.mV/1000, maxvid.mV%1000);\n\t\treturn;\n\t}\n\n\t \n\tnumvscales = maxvid.pos - minvid.pos + 1;\n\tpr_info(\"Max VID=%d.%03d  Min VID=%d.%03d, %d possible voltage scales\\n\",\n\t\tmaxvid.mV/1000, maxvid.mV%1000,\n\t\tminvid.mV/1000, minvid.mV%1000,\n\t\tnumvscales);\n\n\t \n\tj = longhaul.bits.MinMHzBR;\n\tif (longhaul.bits.MinMHzBR4)\n\t\tj += 16;\n\tmin_vid_speed = eblcr[j];\n\tif (min_vid_speed == -1)\n\t\treturn;\n\tswitch (longhaul.bits.MinMHzFSB) {\n\tcase 0:\n\t\tmin_vid_speed *= 13333;\n\t\tbreak;\n\tcase 1:\n\t\tmin_vid_speed *= 10000;\n\t\tbreak;\n\tcase 3:\n\t\tmin_vid_speed *= 6666;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tif (min_vid_speed >= highest_speed)\n\t\treturn;\n\t \n\tkHz_step = (highest_speed - min_vid_speed) / numvscales;\n\n\tcpufreq_for_each_entry_idx(freq_pos, longhaul_table, j) {\n\t\tspeed = freq_pos->frequency;\n\t\tif (speed > min_vid_speed)\n\t\t\tpos = (speed - min_vid_speed) / kHz_step + minvid.pos;\n\t\telse\n\t\t\tpos = minvid.pos;\n\t\tfreq_pos->driver_data |= mV_vrm_table[pos] << 8;\n\t\tvid = vrm_mV_table[mV_vrm_table[pos]];\n\t\tpr_info(\"f: %d kHz, index: %d, vid: %d mV\\n\",\n\t\t\tspeed, j, vid.mV);\n\t}\n\n\tcan_scale_voltage = 1;\n\tpr_info(\"Voltage scaling enabled\\n\");\n}\n\n\nstatic int longhaul_target(struct cpufreq_policy *policy,\n\t\t\t    unsigned int table_index)\n{\n\tunsigned int i;\n\tunsigned int dir = 0;\n\tu8 vid, current_vid;\n\tint retval = 0;\n\n\tif (!can_scale_voltage)\n\t\tretval = longhaul_setstate(policy, table_index);\n\telse {\n\t\t \n\t\ti = longhaul_index;\n\t\tcurrent_vid = (longhaul_table[longhaul_index].driver_data >> 8);\n\t\tcurrent_vid &= 0x1f;\n\t\tif (table_index > longhaul_index)\n\t\t\tdir = 1;\n\t\twhile (i != table_index) {\n\t\t\tvid = (longhaul_table[i].driver_data >> 8) & 0x1f;\n\t\t\tif (vid != current_vid) {\n\t\t\t\tretval = longhaul_setstate(policy, i);\n\t\t\t\tcurrent_vid = vid;\n\t\t\t\tmsleep(200);\n\t\t\t}\n\t\t\tif (dir)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t\ti--;\n\t\t}\n\t\tretval = longhaul_setstate(policy, table_index);\n\t}\n\n\tlonghaul_index = table_index;\n\treturn retval;\n}\n\n\nstatic unsigned int longhaul_get(unsigned int cpu)\n{\n\tif (cpu)\n\t\treturn 0;\n\treturn calc_speed(longhaul_get_cpu_mult());\n}\n\nstatic acpi_status longhaul_walk_callback(acpi_handle obj_handle,\n\t\t\t\t\t  u32 nesting_level,\n\t\t\t\t\t  void *context, void **return_value)\n{\n\tstruct acpi_device *d = acpi_fetch_acpi_dev(obj_handle);\n\n\tif (!d)\n\t\treturn 0;\n\n\t*return_value = acpi_driver_data(d);\n\treturn 1;\n}\n\n \nstatic int enable_arbiter_disable(void)\n{\n\tstruct pci_dev *dev;\n\tint status = 1;\n\tint reg;\n\tu8 pci_cmd;\n\n\t \n\treg = 0x78;\n\tdev = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8601_0,\n\t\t\t     NULL);\n\t \n\tif (dev == NULL)\n\t\tdev = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\t     PCI_DEVICE_ID_VIA_8605_0, NULL);\n\t \n\tif (dev == NULL) {\n\t\treg = 0x76;\n\t\tdev = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\t     PCI_DEVICE_ID_VIA_862X_0, NULL);\n\t\t \n\t\tif (dev == NULL)\n\t\t\tdev = pci_get_device(PCI_VENDOR_ID_VIA, 0x7259, NULL);\n\t}\n\tif (dev != NULL) {\n\t\t \n\t\tpci_read_config_byte(dev, reg, &pci_cmd);\n\t\tif (!(pci_cmd & 1<<7)) {\n\t\t\tpci_cmd |= 1<<7;\n\t\t\tpci_write_config_byte(dev, reg, pci_cmd);\n\t\t\tpci_read_config_byte(dev, reg, &pci_cmd);\n\t\t\tif (!(pci_cmd & 1<<7)) {\n\t\t\t\tpr_err(\"Can't enable access to port 0x22\\n\");\n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t}\n\t\tpci_dev_put(dev);\n\t\treturn status;\n\t}\n\treturn 0;\n}\n\nstatic int longhaul_setup_southbridge(void)\n{\n\tstruct pci_dev *dev;\n\tu8 pci_cmd;\n\n\t \n\tdev = pci_get_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8235, NULL);\n\tif (dev == NULL)\n\t\t \n\t\tdev = pci_get_device(PCI_VENDOR_ID_VIA,\n\t\t\t\t     PCI_DEVICE_ID_VIA_8237, NULL);\n\tif (dev != NULL) {\n\t\t \n\t\tpci_read_config_byte(dev, 0xec, &pci_cmd);\n\t\tpci_cmd &= ~(1 << 2);\n\t\tpci_write_config_byte(dev, 0xec, pci_cmd);\n\t\tpci_read_config_byte(dev, 0xe4, &pci_cmd);\n\t\tpci_cmd &= ~(1 << 7);\n\t\tpci_write_config_byte(dev, 0xe4, pci_cmd);\n\t\tpci_read_config_byte(dev, 0xe5, &pci_cmd);\n\t\tpci_cmd |= 1 << 7;\n\t\tpci_write_config_byte(dev, 0xe5, pci_cmd);\n\t\t \n\t\tpci_read_config_byte(dev, 0x81, &pci_cmd);\n\t\tif (pci_cmd & 1 << 7) {\n\t\t\tpci_read_config_dword(dev, 0x88, &acpi_regs_addr);\n\t\t\tacpi_regs_addr &= 0xff00;\n\t\t\tpr_info(\"ACPI I/O at 0x%x\\n\", acpi_regs_addr);\n\t\t}\n\n\t\tpci_dev_put(dev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int longhaul_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\tchar *cpuname = NULL;\n\tint ret;\n\tu32 lo, hi;\n\n\t \n\tswitch (c->x86_model) {\n\tcase 6:\n\t\tcpu_model = CPU_SAMUEL;\n\t\tcpuname = \"C3 'Samuel' [C5A]\";\n\t\tlonghaul_version = TYPE_LONGHAUL_V1;\n\t\tmemcpy(mults, samuel1_mults, sizeof(samuel1_mults));\n\t\tmemcpy(eblcr, samuel1_eblcr, sizeof(samuel1_eblcr));\n\t\tbreak;\n\n\tcase 7:\n\t\tswitch (c->x86_stepping) {\n\t\tcase 0:\n\t\t\tlonghaul_version = TYPE_LONGHAUL_V1;\n\t\t\tcpu_model = CPU_SAMUEL2;\n\t\t\tcpuname = \"C3 'Samuel 2' [C5B]\";\n\t\t\t \n\t\t\tmemcpy(mults, samuel1_mults, sizeof(samuel1_mults));\n\t\t\tmemcpy(eblcr, samuel2_eblcr, sizeof(samuel2_eblcr));\n\t\t\tbreak;\n\t\tcase 1 ... 15:\n\t\t\tlonghaul_version = TYPE_LONGHAUL_V2;\n\t\t\tif (c->x86_stepping < 8) {\n\t\t\t\tcpu_model = CPU_SAMUEL2;\n\t\t\t\tcpuname = \"C3 'Samuel 2' [C5B]\";\n\t\t\t} else {\n\t\t\t\tcpu_model = CPU_EZRA;\n\t\t\t\tcpuname = \"C3 'Ezra' [C5C]\";\n\t\t\t}\n\t\t\tmemcpy(mults, ezra_mults, sizeof(ezra_mults));\n\t\t\tmemcpy(eblcr, ezra_eblcr, sizeof(ezra_eblcr));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 8:\n\t\tcpu_model = CPU_EZRA_T;\n\t\tcpuname = \"C3 'Ezra-T' [C5M]\";\n\t\tlonghaul_version = TYPE_POWERSAVER;\n\t\tnumscales = 32;\n\t\tmemcpy(mults, ezrat_mults, sizeof(ezrat_mults));\n\t\tmemcpy(eblcr, ezrat_eblcr, sizeof(ezrat_eblcr));\n\t\tbreak;\n\n\tcase 9:\n\t\tlonghaul_version = TYPE_POWERSAVER;\n\t\tnumscales = 32;\n\t\tmemcpy(mults, nehemiah_mults, sizeof(nehemiah_mults));\n\t\tmemcpy(eblcr, nehemiah_eblcr, sizeof(nehemiah_eblcr));\n\t\tswitch (c->x86_stepping) {\n\t\tcase 0 ... 1:\n\t\t\tcpu_model = CPU_NEHEMIAH;\n\t\t\tcpuname = \"C3 'Nehemiah A' [C5XLOE]\";\n\t\t\tbreak;\n\t\tcase 2 ... 4:\n\t\t\tcpu_model = CPU_NEHEMIAH;\n\t\t\tcpuname = \"C3 'Nehemiah B' [C5XLOH]\";\n\t\t\tbreak;\n\t\tcase 5 ... 15:\n\t\t\tcpu_model = CPU_NEHEMIAH_C;\n\t\t\tcpuname = \"C3 'Nehemiah C' [C5P]\";\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tcpuname = \"Unknown\";\n\t\tbreak;\n\t}\n\t \n\tif (longhaul_version == TYPE_LONGHAUL_V2) {\n\t\trdmsr(MSR_VIA_LONGHAUL, lo, hi);\n\t\tif (lo == 0 && hi == 0)\n\t\t\t \n\t\t\tlonghaul_version = TYPE_LONGHAUL_V1;\n\t}\n\n\tpr_info(\"VIA %s CPU detected.  \", cpuname);\n\tswitch (longhaul_version) {\n\tcase TYPE_LONGHAUL_V1:\n\tcase TYPE_LONGHAUL_V2:\n\t\tpr_cont(\"Longhaul v%d supported\\n\", longhaul_version);\n\t\tbreak;\n\tcase TYPE_POWERSAVER:\n\t\tpr_cont(\"Powersaver supported\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tlonghaul_setup_southbridge();\n\n\t \n\tacpi_walk_namespace(ACPI_TYPE_PROCESSOR, ACPI_ROOT_OBJECT,\n\t\t\t\tACPI_UINT32_MAX, &longhaul_walk_callback, NULL,\n\t\t\t\tNULL, (void *)&pr);\n\n\t \n\tif (pr != NULL && longhaul_version == TYPE_POWERSAVER) {\n\t\tcx = &pr->power.states[ACPI_STATE_C3];\n\t\tif (cx->address > 0 && cx->latency <= 1000)\n\t\t\tlonghaul_flags |= USE_ACPI_C3;\n\t}\n\t \n\tif (disable_acpi_c3)\n\t\tlonghaul_flags &= ~USE_ACPI_C3;\n\t \n\tif (enable_arbiter_disable())\n\t\tlonghaul_flags |= USE_NORTHBRIDGE;\n\n\t \n\tif (!(longhaul_flags & USE_ACPI_C3\n\t     || longhaul_flags & USE_NORTHBRIDGE)\n\t    && ((pr == NULL) || !(pr->flags.bm_control))) {\n\t\tpr_err(\"No ACPI support: Unsupported northbridge\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (longhaul_flags & USE_NORTHBRIDGE)\n\t\tpr_info(\"Using northbridge support\\n\");\n\tif (longhaul_flags & USE_ACPI_C3)\n\t\tpr_info(\"Using ACPI support\\n\");\n\n\tret = longhaul_get_ranges();\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif ((longhaul_version != TYPE_LONGHAUL_V1) && (scale_voltage != 0))\n\t\tlonghaul_setup_voltagescaling();\n\n\tpolicy->transition_delay_us = 200000;\t \n\tpolicy->freq_table = longhaul_table;\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver longhaul_driver = {\n\t.verify\t= cpufreq_generic_frequency_table_verify,\n\t.target_index = longhaul_target,\n\t.get\t= longhaul_get,\n\t.init\t= longhaul_cpu_init,\n\t.name\t= \"longhaul\",\n\t.attr\t= cpufreq_generic_attr,\n};\n\nstatic const struct x86_cpu_id longhaul_id[] = {\n\tX86_MATCH_VENDOR_FAM(CENTAUR, 6, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, longhaul_id);\n\nstatic int __init longhaul_init(void)\n{\n\tstruct cpuinfo_x86 *c = &cpu_data(0);\n\n\tif (!x86_match_cpu(longhaul_id))\n\t\treturn -ENODEV;\n\n\tif (!enable) {\n\t\tpr_err(\"Option \\\"enable\\\" not set - Aborting\\n\");\n\t\treturn -ENODEV;\n\t}\n#ifdef CONFIG_SMP\n\tif (num_online_cpus() > 1) {\n\t\tpr_err(\"More than 1 CPU detected, longhaul disabled\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n#ifdef CONFIG_X86_IO_APIC\n\tif (boot_cpu_has(X86_FEATURE_APIC)) {\n\t\tpr_err(\"APIC detected. Longhaul is currently broken in this configuration.\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\tswitch (c->x86_model) {\n\tcase 6 ... 9:\n\t\treturn cpufreq_register_driver(&longhaul_driver);\n\tcase 10:\n\t\tpr_err(\"Use acpi-cpufreq driver for VIA C7\\n\");\n\t}\n\n\treturn -ENODEV;\n}\n\n\nstatic void __exit longhaul_exit(void)\n{\n\tstruct cpufreq_policy *policy = cpufreq_cpu_get(0);\n\tint i;\n\n\tfor (i = 0; i < numscales; i++) {\n\t\tif (mults[i] == maxmult) {\n\t\t\tstruct cpufreq_freqs freqs;\n\n\t\t\tfreqs.old = policy->cur;\n\t\t\tfreqs.new = longhaul_table[i].frequency;\n\t\t\tfreqs.flags = 0;\n\n\t\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t\t\tlonghaul_setstate(policy, i);\n\t\t\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcpufreq_cpu_put(policy);\n\tcpufreq_unregister_driver(&longhaul_driver);\n\tkfree(longhaul_table);\n}\n\n \nmodule_param(disable_acpi_c3, int, 0644);\nMODULE_PARM_DESC(disable_acpi_c3, \"Don't use ACPI C3 support\");\n \nmodule_param(scale_voltage, int, 0644);\nMODULE_PARM_DESC(scale_voltage, \"Scale voltage of processor\");\n \nmodule_param(revid_errata, int, 0644);\nMODULE_PARM_DESC(revid_errata, \"Ignore CPU Revision ID\");\n \nmodule_param(enable, int, 0644);\nMODULE_PARM_DESC(enable, \"Enable driver\");\n\nMODULE_AUTHOR(\"Dave Jones\");\nMODULE_DESCRIPTION(\"Longhaul driver for VIA Cyrix processors.\");\nMODULE_LICENSE(\"GPL\");\n\nlate_initcall(longhaul_init);\nmodule_exit(longhaul_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}