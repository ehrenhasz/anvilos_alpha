{
  "module_name": "s3c64xx-cpufreq.c",
  "hash_id": "68c101a9f99f32abc7ed908bb837e72923ab6b4ef5cda2837bd1e4f46b425d9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/s3c64xx-cpufreq.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"cpufreq: \" fmt\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n\nstatic struct regulator *vddarm;\nstatic unsigned long regulator_latency;\n\nstruct s3c64xx_dvfs {\n\tunsigned int vddarm_min;\n\tunsigned int vddarm_max;\n};\n\nstatic struct s3c64xx_dvfs s3c64xx_dvfs_table[] = {\n\t[0] = { 1000000, 1150000 },\n\t[1] = { 1050000, 1150000 },\n\t[2] = { 1100000, 1150000 },\n\t[3] = { 1200000, 1350000 },\n\t[4] = { 1300000, 1350000 },\n};\n\nstatic struct cpufreq_frequency_table s3c64xx_freq_table[] = {\n\t{ 0, 0,  66000 },\n\t{ 0, 0, 100000 },\n\t{ 0, 0, 133000 },\n\t{ 0, 1, 200000 },\n\t{ 0, 1, 222000 },\n\t{ 0, 1, 266000 },\n\t{ 0, 2, 333000 },\n\t{ 0, 2, 400000 },\n\t{ 0, 2, 532000 },\n\t{ 0, 2, 533000 },\n\t{ 0, 3, 667000 },\n\t{ 0, 4, 800000 },\n\t{ 0, 0, CPUFREQ_TABLE_END },\n};\n\nstatic int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,\n\t\t\t\t      unsigned int index)\n{\n\tstruct s3c64xx_dvfs *dvfs;\n\tunsigned int old_freq, new_freq;\n\tint ret;\n\n\told_freq = clk_get_rate(policy->clk) / 1000;\n\tnew_freq = s3c64xx_freq_table[index].frequency;\n\tdvfs = &s3c64xx_dvfs_table[s3c64xx_freq_table[index].driver_data];\n\n#ifdef CONFIG_REGULATOR\n\tif (vddarm && new_freq > old_freq) {\n\t\tret = regulator_set_voltage(vddarm,\n\t\t\t\t\t    dvfs->vddarm_min,\n\t\t\t\t\t    dvfs->vddarm_max);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"Failed to set VDDARM for %dkHz: %d\\n\",\n\t\t\t       new_freq, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\n\tret = clk_set_rate(policy->clk, new_freq * 1000);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to set rate %dkHz: %d\\n\",\n\t\t       new_freq, ret);\n\t\treturn ret;\n\t}\n\n#ifdef CONFIG_REGULATOR\n\tif (vddarm && new_freq < old_freq) {\n\t\tret = regulator_set_voltage(vddarm,\n\t\t\t\t\t    dvfs->vddarm_min,\n\t\t\t\t\t    dvfs->vddarm_max);\n\t\tif (ret != 0) {\n\t\t\tpr_err(\"Failed to set VDDARM for %dkHz: %d\\n\",\n\t\t\t       new_freq, ret);\n\t\t\tif (clk_set_rate(policy->clk, old_freq * 1000) < 0)\n\t\t\t\tpr_err(\"Failed to restore original clock rate\\n\");\n\n\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\n\tpr_debug(\"Set actual frequency %lukHz\\n\",\n\t\t clk_get_rate(policy->clk) / 1000);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_REGULATOR\nstatic void s3c64xx_cpufreq_config_regulator(void)\n{\n\tint count, v, i, found;\n\tstruct cpufreq_frequency_table *freq;\n\tstruct s3c64xx_dvfs *dvfs;\n\n\tcount = regulator_count_voltages(vddarm);\n\tif (count < 0) {\n\t\tpr_err(\"Unable to check supported voltages\\n\");\n\t}\n\n\tif (!count)\n\t\tgoto out;\n\n\tcpufreq_for_each_valid_entry(freq, s3c64xx_freq_table) {\n\t\tdvfs = &s3c64xx_dvfs_table[freq->driver_data];\n\t\tfound = 0;\n\n\t\tfor (i = 0; i < count; i++) {\n\t\t\tv = regulator_list_voltage(vddarm, i);\n\t\t\tif (v >= dvfs->vddarm_min && v <= dvfs->vddarm_max)\n\t\t\t\tfound = 1;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tpr_debug(\"%dkHz unsupported by regulator\\n\",\n\t\t\t\t freq->frequency);\n\t\t\tfreq->frequency = CPUFREQ_ENTRY_INVALID;\n\t\t}\n\t}\n\nout:\n\t \n\tregulator_latency = 1 * 1000 * 1000;\n}\n#endif\n\nstatic int s3c64xx_cpufreq_driver_init(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *freq;\n\n\tif (policy->cpu != 0)\n\t\treturn -EINVAL;\n\n\tpolicy->clk = clk_get(NULL, \"armclk\");\n\tif (IS_ERR(policy->clk)) {\n\t\tpr_err(\"Unable to obtain ARMCLK: %ld\\n\",\n\t\t       PTR_ERR(policy->clk));\n\t\treturn PTR_ERR(policy->clk);\n\t}\n\n#ifdef CONFIG_REGULATOR\n\tvddarm = regulator_get(NULL, \"vddarm\");\n\tif (IS_ERR(vddarm)) {\n\t\tpr_err(\"Failed to obtain VDDARM: %ld\\n\", PTR_ERR(vddarm));\n\t\tpr_err(\"Only frequency scaling available\\n\");\n\t\tvddarm = NULL;\n\t} else {\n\t\ts3c64xx_cpufreq_config_regulator();\n\t}\n#endif\n\n\tcpufreq_for_each_entry(freq, s3c64xx_freq_table) {\n\t\tunsigned long r;\n\n\t\t \n\t\tr = clk_round_rate(policy->clk, freq->frequency * 1000);\n\t\tr /= 1000;\n\t\tif (r != freq->frequency) {\n\t\t\tpr_debug(\"%dkHz unsupported by clock\\n\",\n\t\t\t\t freq->frequency);\n\t\t\tfreq->frequency = CPUFREQ_ENTRY_INVALID;\n\t\t}\n\n\t\t \n\t\tif (!vddarm && freq->frequency > clk_get_rate(policy->clk) / 1000)\n\t\t\tfreq->frequency = CPUFREQ_ENTRY_INVALID;\n\t}\n\n\t \n\tcpufreq_generic_init(policy, s3c64xx_freq_table,\n\t\t\t(500 * 1000) + regulator_latency);\n\treturn 0;\n}\n\nstatic struct cpufreq_driver s3c64xx_cpufreq_driver = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= s3c64xx_cpufreq_set_target,\n\t.get\t\t= cpufreq_generic_get,\n\t.init\t\t= s3c64xx_cpufreq_driver_init,\n\t.name\t\t= \"s3c\",\n};\n\nstatic int __init s3c64xx_cpufreq_init(void)\n{\n\treturn cpufreq_register_driver(&s3c64xx_cpufreq_driver);\n}\nmodule_init(s3c64xx_cpufreq_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}