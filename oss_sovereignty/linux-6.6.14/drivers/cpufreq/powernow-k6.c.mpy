{
  "module_name": "powernow-k6.c",
  "hash_id": "4ca6890c7d3f0b90426d4fa8b09f53e9f21619c754e4338a9480531d1a6af251",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/powernow-k6.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/ioport.h>\n#include <linux/timex.h>\n#include <linux/io.h>\n\n#include <asm/cpu_device_id.h>\n#include <asm/msr.h>\n\n#define POWERNOW_IOPORT 0xfff0           \n\nstatic unsigned int                     busfreq;    \nstatic unsigned int                     max_multiplier;\n\nstatic unsigned int\t\t\tparam_busfreq = 0;\nstatic unsigned int\t\t\tparam_max_multiplier = 0;\n\nmodule_param_named(max_multiplier, param_max_multiplier, uint, S_IRUGO);\nMODULE_PARM_DESC(max_multiplier, \"Maximum multiplier (allowed values: 20 30 35 40 45 50 55 60)\");\n\nmodule_param_named(bus_frequency, param_busfreq, uint, S_IRUGO);\nMODULE_PARM_DESC(bus_frequency, \"Bus frequency in kHz\");\n\n \nstatic struct cpufreq_frequency_table clock_ratio[] = {\n\t{0, 60,    0},\n\t{0, 55,    0},\n\t{0, 50,    0},\n\t{0, 45,    0},\n\t{0, 40,    0},\n\t{0, 35,    0},\n\t{0, 30,    0},\n\t{0, 20,    0},\n\t{0, 0, CPUFREQ_TABLE_END}\n};\n\nstatic const u8 index_to_register[8] = { 6, 3, 1, 0, 2, 7, 5, 4 };\nstatic const u8 register_to_index[8] = { 3, 2, 4, 1, 7, 6, 0, 5 };\n\nstatic const struct {\n\tunsigned freq;\n\tunsigned mult;\n} usual_frequency_table[] = {\n\t{ 350000, 35 },\t \n\t{ 400000, 40 },\t \n\t{ 450000, 45 },  \n\t{ 475000, 50 },  \n\t{ 500000, 50 },  \n\t{ 506250, 45 },  \n\t{ 533500, 55 },  \n\t{ 550000, 55 },  \n\t{ 562500, 50 },  \n\t{ 570000, 60 },  \n\t{ 600000, 60 },  \n\t{ 618750, 55 },  \n\t{ 660000, 55 },  \n\t{ 675000, 60 },  \n\t{ 720000, 60 },  \n};\n\n#define FREQ_RANGE\t\t3000\n\n \nstatic int powernow_k6_get_cpu_multiplier(void)\n{\n\tunsigned long invalue = 0;\n\tu32 msrval;\n\n\tlocal_irq_disable();\n\n\tmsrval = POWERNOW_IOPORT + 0x1;\n\twrmsr(MSR_K6_EPMR, msrval, 0);  \n\tinvalue = inl(POWERNOW_IOPORT + 0x8);\n\tmsrval = POWERNOW_IOPORT + 0x0;\n\twrmsr(MSR_K6_EPMR, msrval, 0);  \n\n\tlocal_irq_enable();\n\n\treturn clock_ratio[register_to_index[(invalue >> 5)&7]].driver_data;\n}\n\nstatic void powernow_k6_set_cpu_multiplier(unsigned int best_i)\n{\n\tunsigned long outvalue, invalue;\n\tunsigned long msrval;\n\tunsigned long cr0;\n\n\t \n\n\t \n\tlocal_irq_disable();\n\tcr0 = read_cr0();\n\twrite_cr0(cr0 | X86_CR0_CD);\n\twbinvd();\n\n\toutvalue = (1<<12) | (1<<10) | (1<<9) | (index_to_register[best_i]<<5);\n\n\tmsrval = POWERNOW_IOPORT + 0x1;\n\twrmsr(MSR_K6_EPMR, msrval, 0);  \n\tinvalue = inl(POWERNOW_IOPORT + 0x8);\n\tinvalue = invalue & 0x1f;\n\toutvalue = outvalue | invalue;\n\toutl(outvalue, (POWERNOW_IOPORT + 0x8));\n\tmsrval = POWERNOW_IOPORT + 0x0;\n\twrmsr(MSR_K6_EPMR, msrval, 0);  \n\n\twrite_cr0(cr0);\n\tlocal_irq_enable();\n}\n\n \nstatic int powernow_k6_target(struct cpufreq_policy *policy,\n\t\tunsigned int best_i)\n{\n\n\tif (clock_ratio[best_i].driver_data > max_multiplier) {\n\t\tpr_err(\"invalid target frequency\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpowernow_k6_set_cpu_multiplier(best_i);\n\n\treturn 0;\n}\n\nstatic int powernow_k6_cpu_init(struct cpufreq_policy *policy)\n{\n\tstruct cpufreq_frequency_table *pos;\n\tunsigned int i, f;\n\tunsigned khz;\n\n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\tmax_multiplier = 0;\n\tkhz = cpu_khz;\n\tfor (i = 0; i < ARRAY_SIZE(usual_frequency_table); i++) {\n\t\tif (khz >= usual_frequency_table[i].freq - FREQ_RANGE &&\n\t\t    khz <= usual_frequency_table[i].freq + FREQ_RANGE) {\n\t\t\tkhz = usual_frequency_table[i].freq;\n\t\t\tmax_multiplier = usual_frequency_table[i].mult;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (param_max_multiplier) {\n\t\tcpufreq_for_each_entry(pos, clock_ratio)\n\t\t\tif (pos->driver_data == param_max_multiplier) {\n\t\t\t\tmax_multiplier = param_max_multiplier;\n\t\t\t\tgoto have_max_multiplier;\n\t\t\t}\n\t\tpr_err(\"invalid max_multiplier parameter, valid parameters 20, 30, 35, 40, 45, 50, 55, 60\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!max_multiplier) {\n\t\tpr_warn(\"unknown frequency %u, cannot determine current multiplier\\n\",\n\t\t\tkhz);\n\t\tpr_warn(\"use module parameters max_multiplier and bus_frequency\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\nhave_max_multiplier:\n\tparam_max_multiplier = max_multiplier;\n\n\tif (param_busfreq) {\n\t\tif (param_busfreq >= 50000 && param_busfreq <= 150000) {\n\t\t\tbusfreq = param_busfreq / 10;\n\t\t\tgoto have_busfreq;\n\t\t}\n\t\tpr_err(\"invalid bus_frequency parameter, allowed range 50000 - 150000 kHz\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbusfreq = khz / max_multiplier;\nhave_busfreq:\n\tparam_busfreq = busfreq * 10;\n\n\t \n\tcpufreq_for_each_entry(pos, clock_ratio) {\n\t\tf = pos->driver_data;\n\t\tif (f > max_multiplier)\n\t\t\tpos->frequency = CPUFREQ_ENTRY_INVALID;\n\t\telse\n\t\t\tpos->frequency = busfreq * f;\n\t}\n\n\t \n\tpolicy->cpuinfo.transition_latency = 500000;\n\tpolicy->freq_table = clock_ratio;\n\n\treturn 0;\n}\n\n\nstatic int powernow_k6_cpu_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int i;\n\n\tfor (i = 0; (clock_ratio[i].frequency != CPUFREQ_TABLE_END); i++) {\n\t\tif (clock_ratio[i].driver_data == max_multiplier) {\n\t\t\tstruct cpufreq_freqs freqs;\n\n\t\t\tfreqs.old = policy->cur;\n\t\t\tfreqs.new = clock_ratio[i].frequency;\n\t\t\tfreqs.flags = 0;\n\n\t\t\tcpufreq_freq_transition_begin(policy, &freqs);\n\t\t\tpowernow_k6_target(policy, i);\n\t\t\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic unsigned int powernow_k6_get(unsigned int cpu)\n{\n\tunsigned int ret;\n\tret = (busfreq * powernow_k6_get_cpu_multiplier());\n\treturn ret;\n}\n\nstatic struct cpufreq_driver powernow_k6_driver = {\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= powernow_k6_target,\n\t.init\t\t= powernow_k6_cpu_init,\n\t.exit\t\t= powernow_k6_cpu_exit,\n\t.get\t\t= powernow_k6_get,\n\t.name\t\t= \"powernow-k6\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic const struct x86_cpu_id powernow_k6_ids[] = {\n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 5, 12, NULL),\n\tX86_MATCH_VENDOR_FAM_MODEL(AMD, 5, 13, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, powernow_k6_ids);\n\n \nstatic int __init powernow_k6_init(void)\n{\n\tif (!x86_match_cpu(powernow_k6_ids))\n\t\treturn -ENODEV;\n\n\tif (!request_region(POWERNOW_IOPORT, 16, \"PowerNow!\")) {\n\t\tpr_info(\"PowerNow IOPORT region already used\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (cpufreq_register_driver(&powernow_k6_driver)) {\n\t\trelease_region(POWERNOW_IOPORT, 16);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\n \nstatic void __exit powernow_k6_exit(void)\n{\n\tcpufreq_unregister_driver(&powernow_k6_driver);\n\trelease_region(POWERNOW_IOPORT, 16);\n}\n\n\nMODULE_AUTHOR(\"Arjan van de Ven, Dave Jones, \"\n\t\t\"Dominik Brodowski <linux@brodo.de>\");\nMODULE_DESCRIPTION(\"PowerNow! driver for AMD K6-2+ / K6-3+ processors.\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_init(powernow_k6_init);\nmodule_exit(powernow_k6_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}