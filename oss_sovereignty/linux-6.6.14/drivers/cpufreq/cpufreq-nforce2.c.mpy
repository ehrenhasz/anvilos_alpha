{
  "module_name": "cpufreq-nforce2.c",
  "hash_id": "cfbea5e5a40e6094027dfe9bad70f7b9769c14caf85cb7f8bac8af844fb3e15f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/cpufreq-nforce2.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#define NFORCE2_XTAL 25\n#define NFORCE2_BOOTFSB 0x48\n#define NFORCE2_PLLENABLE 0xa8\n#define NFORCE2_PLLREG 0xa4\n#define NFORCE2_PLLADR 0xa0\n#define NFORCE2_PLL(mul, div) (0x100000 | (mul << 8) | div)\n\n#define NFORCE2_MIN_FSB 50\n#define NFORCE2_SAFE_DISTANCE 50\n\n \n \n\n \nstatic struct pci_dev *nforce2_dev;\n\n \nstatic int fid;\n\n \nstatic int min_fsb;\nstatic int max_fsb;\n\nMODULE_AUTHOR(\"Sebastian Witt <se.witt@gmx.net>\");\nMODULE_DESCRIPTION(\"nForce2 FSB changing cpufreq driver\");\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(fid, int, 0444);\nmodule_param(min_fsb, int, 0444);\n\nMODULE_PARM_DESC(fid, \"CPU multiplier to use (11.5 = 115)\");\nMODULE_PARM_DESC(min_fsb,\n\t\t\"Minimum FSB to use, if not defined: current FSB - 50\");\n\n \nstatic int nforce2_calc_fsb(int pll)\n{\n\tunsigned char mul, div;\n\n\tmul = (pll >> 8) & 0xff;\n\tdiv = pll & 0xff;\n\n\tif (div > 0)\n\t\treturn NFORCE2_XTAL * mul / div;\n\n\treturn 0;\n}\n\n \nstatic int nforce2_calc_pll(unsigned int fsb)\n{\n\tunsigned char xmul, xdiv;\n\tunsigned char mul = 0, div = 0;\n\tint tried = 0;\n\n\t \n\twhile (((mul == 0) || (div == 0)) && (tried <= 3)) {\n\t\tfor (xdiv = 2; xdiv <= 0x80; xdiv++)\n\t\t\tfor (xmul = 1; xmul <= 0xfe; xmul++)\n\t\t\t\tif (nforce2_calc_fsb(NFORCE2_PLL(xmul, xdiv)) ==\n\t\t\t\t    fsb + tried) {\n\t\t\t\t\tmul = xmul;\n\t\t\t\t\tdiv = xdiv;\n\t\t\t\t}\n\t\ttried++;\n\t}\n\n\tif ((mul == 0) || (div == 0))\n\t\treturn -1;\n\n\treturn NFORCE2_PLL(mul, div);\n}\n\n \nstatic void nforce2_write_pll(int pll)\n{\n\tint temp;\n\n\t \n\tpci_write_config_dword(nforce2_dev, NFORCE2_PLLADR, 0);\n\n\t \n\tfor (temp = 0; temp <= 0x3f; temp++)\n\t\tpci_write_config_dword(nforce2_dev, NFORCE2_PLLREG, pll);\n}\n\n \nstatic unsigned int nforce2_fsb_read(int bootfsb)\n{\n\tstruct pci_dev *nforce2_sub5;\n\tu32 fsb, temp = 0;\n\n\t \n\tnforce2_sub5 = pci_get_subsys(PCI_VENDOR_ID_NVIDIA, 0x01EF,\n\t\t\t\tPCI_ANY_ID, PCI_ANY_ID, NULL);\n\tif (!nforce2_sub5)\n\t\treturn 0;\n\n\tpci_read_config_dword(nforce2_sub5, NFORCE2_BOOTFSB, &fsb);\n\tfsb /= 1000000;\n\n\t \n\tpci_read_config_byte(nforce2_dev, NFORCE2_PLLENABLE, (u8 *)&temp);\n\n\tif (bootfsb || !temp)\n\t\treturn fsb;\n\n\t \n\tpci_read_config_dword(nforce2_dev, NFORCE2_PLLREG, &temp);\n\tfsb = nforce2_calc_fsb(temp);\n\n\treturn fsb;\n}\n\n \nstatic int nforce2_set_fsb(unsigned int fsb)\n{\n\tu32 temp = 0;\n\tunsigned int tfsb;\n\tint diff;\n\tint pll = 0;\n\n\tif ((fsb > max_fsb) || (fsb < NFORCE2_MIN_FSB)) {\n\t\tpr_err(\"FSB %d is out of range!\\n\", fsb);\n\t\treturn -EINVAL;\n\t}\n\n\ttfsb = nforce2_fsb_read(0);\n\tif (!tfsb) {\n\t\tpr_err(\"Error while reading the FSB\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpci_read_config_byte(nforce2_dev, NFORCE2_PLLENABLE, (u8 *)&temp);\n\tif (!temp) {\n\t\tpll = nforce2_calc_pll(tfsb);\n\n\t\tif (pll < 0)\n\t\t\treturn -EINVAL;\n\n\t\tnforce2_write_pll(pll);\n\t}\n\n\t \n\ttemp = 0x01;\n\tpci_write_config_byte(nforce2_dev, NFORCE2_PLLENABLE, (u8)temp);\n\n\tdiff = tfsb - fsb;\n\n\tif (!diff)\n\t\treturn 0;\n\n\twhile ((tfsb != fsb) && (tfsb <= max_fsb) && (tfsb >= min_fsb)) {\n\t\tif (diff < 0)\n\t\t\ttfsb++;\n\t\telse\n\t\t\ttfsb--;\n\n\t\t \n\t\tpll = nforce2_calc_pll(tfsb);\n\t\tif (pll == -1)\n\t\t\treturn -EINVAL;\n\n\t\tnforce2_write_pll(pll);\n#ifdef NFORCE2_DELAY\n\t\tmdelay(NFORCE2_DELAY);\n#endif\n\t}\n\n\ttemp = 0x40;\n\tpci_write_config_byte(nforce2_dev, NFORCE2_PLLADR, (u8)temp);\n\n\treturn 0;\n}\n\n \nstatic unsigned int nforce2_get(unsigned int cpu)\n{\n\tif (cpu)\n\t\treturn 0;\n\treturn nforce2_fsb_read(0) * fid * 100;\n}\n\n \nstatic int nforce2_target(struct cpufreq_policy *policy,\n\t\t\t  unsigned int target_freq, unsigned int relation)\n{\n \n\tstruct cpufreq_freqs freqs;\n\tunsigned int target_fsb;\n\n\tif ((target_freq > policy->max) || (target_freq < policy->min))\n\t\treturn -EINVAL;\n\n\ttarget_fsb = target_freq / (fid * 100);\n\n\tfreqs.old = nforce2_get(policy->cpu);\n\tfreqs.new = target_fsb * fid * 100;\n\n\tif (freqs.old == freqs.new)\n\t\treturn 0;\n\n\tpr_debug(\"Old CPU frequency %d kHz, new %d kHz\\n\",\n\t       freqs.old, freqs.new);\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\n\t \n\t \n\n\tif (nforce2_set_fsb(target_fsb) < 0)\n\t\tpr_err(\"Changing FSB to %d failed\\n\", target_fsb);\n\telse\n\t\tpr_debug(\"Changed FSB successfully to %d\\n\",\n\t\t\ttarget_fsb);\n\n\t \n\t \n\n\tcpufreq_freq_transition_end(policy, &freqs, 0);\n\n\treturn 0;\n}\n\n \nstatic int nforce2_verify(struct cpufreq_policy_data *policy)\n{\n\tunsigned int fsb_pol_max;\n\n\tfsb_pol_max = policy->max / (fid * 100);\n\n\tif (policy->min < (fsb_pol_max * fid * 100))\n\t\tpolicy->max = (fsb_pol_max + 1) * fid * 100;\n\n\tcpufreq_verify_within_cpu_limits(policy);\n\treturn 0;\n}\n\nstatic int nforce2_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int fsb;\n\tunsigned int rfid;\n\n\t \n\tif (policy->cpu != 0)\n\t\treturn -ENODEV;\n\n\t \n\tfsb = nforce2_fsb_read(0);\n\n\tif (!fsb)\n\t\treturn -EIO;\n\n\t \n\tif (!fid) {\n\t\tif (!cpu_khz) {\n\t\t\tpr_warn(\"cpu_khz not set, can't calculate multiplier!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tfid = cpu_khz / (fsb * 100);\n\t\trfid = fid % 5;\n\n\t\tif (rfid) {\n\t\t\tif (rfid > 2)\n\t\t\t\tfid += 5 - rfid;\n\t\t\telse\n\t\t\t\tfid -= rfid;\n\t\t}\n\t}\n\n\tpr_info(\"FSB currently at %i MHz, FID %d.%d\\n\",\n\t\tfsb, fid / 10, fid % 10);\n\n\t \n\tmax_fsb = nforce2_fsb_read(1);\n\n\tif (!max_fsb)\n\t\treturn -EIO;\n\n\tif (!min_fsb)\n\t\tmin_fsb = max_fsb - NFORCE2_SAFE_DISTANCE;\n\n\tif (min_fsb < NFORCE2_MIN_FSB)\n\t\tmin_fsb = NFORCE2_MIN_FSB;\n\n\t \n\tpolicy->min = policy->cpuinfo.min_freq = min_fsb * fid * 100;\n\tpolicy->max = policy->cpuinfo.max_freq = max_fsb * fid * 100;\n\n\treturn 0;\n}\n\nstatic int nforce2_cpu_exit(struct cpufreq_policy *policy)\n{\n\treturn 0;\n}\n\nstatic struct cpufreq_driver nforce2_driver = {\n\t.name = \"nforce2\",\n\t.flags = CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.verify = nforce2_verify,\n\t.target = nforce2_target,\n\t.get = nforce2_get,\n\t.init = nforce2_cpu_init,\n\t.exit = nforce2_cpu_exit,\n};\n\n#ifdef MODULE\nstatic const struct pci_device_id nforce2_ids[] = {\n\t{ PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2 },\n\t{}\n};\nMODULE_DEVICE_TABLE(pci, nforce2_ids);\n#endif\n\n \nstatic int nforce2_detect_chipset(void)\n{\n\tnforce2_dev = pci_get_subsys(PCI_VENDOR_ID_NVIDIA,\n\t\t\t\t\tPCI_DEVICE_ID_NVIDIA_NFORCE2,\n\t\t\t\t\tPCI_ANY_ID, PCI_ANY_ID, NULL);\n\n\tif (nforce2_dev == NULL)\n\t\treturn -ENODEV;\n\n\tpr_info(\"Detected nForce2 chipset revision %X\\n\",\n\t\tnforce2_dev->revision);\n\tpr_info(\"FSB changing is maybe unstable and can lead to crashes and data loss\\n\");\n\n\treturn 0;\n}\n\n \nstatic int __init nforce2_init(void)\n{\n\t \n\n\t \n\tif (nforce2_detect_chipset()) {\n\t\tpr_info(\"No nForce2 chipset\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn cpufreq_register_driver(&nforce2_driver);\n}\n\n \nstatic void __exit nforce2_exit(void)\n{\n\tcpufreq_unregister_driver(&nforce2_driver);\n}\n\nmodule_init(nforce2_init);\nmodule_exit(nforce2_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}