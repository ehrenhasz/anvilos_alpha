{
  "module_name": "armada-37xx-cpufreq.c",
  "hash_id": "425e0d7e0b68d842958b8f9b076d5d910039af2aa70f32abb67904e19fb8faf9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/armada-37xx-cpufreq.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/cpu.h>\n#include <linux/cpufreq.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n\n#include \"cpufreq-dt.h\"\n\n \n#define ARMADA_37XX_CLK_TBG_SEL\t\t0\n#define ARMADA_37XX_CLK_TBG_SEL_CPU_OFF\t22\n\n \n#define ARMADA_37XX_NB_L0L1\t0x18\n#define ARMADA_37XX_NB_L2L3\t0x1C\n#define  ARMADA_37XX_NB_TBG_DIV_OFF\t13\n#define  ARMADA_37XX_NB_TBG_DIV_MASK\t0x7\n#define  ARMADA_37XX_NB_CLK_SEL_OFF\t11\n#define  ARMADA_37XX_NB_CLK_SEL_MASK\t0x1\n#define  ARMADA_37XX_NB_CLK_SEL_TBG\t0x1\n#define  ARMADA_37XX_NB_TBG_SEL_OFF\t9\n#define  ARMADA_37XX_NB_TBG_SEL_MASK\t0x3\n#define  ARMADA_37XX_NB_VDD_SEL_OFF\t6\n#define  ARMADA_37XX_NB_VDD_SEL_MASK\t0x3\n#define  ARMADA_37XX_NB_CONFIG_SHIFT\t16\n#define ARMADA_37XX_NB_DYN_MOD\t0x24\n#define  ARMADA_37XX_NB_CLK_SEL_EN\tBIT(26)\n#define  ARMADA_37XX_NB_TBG_EN\t\tBIT(28)\n#define  ARMADA_37XX_NB_DIV_EN\t\tBIT(29)\n#define  ARMADA_37XX_NB_VDD_EN\t\tBIT(30)\n#define  ARMADA_37XX_NB_DFS_EN\t\tBIT(31)\n#define ARMADA_37XX_NB_CPU_LOAD 0x30\n#define  ARMADA_37XX_NB_CPU_LOAD_MASK\t0x3\n#define  ARMADA_37XX_DVFS_LOAD_0\t0\n#define  ARMADA_37XX_DVFS_LOAD_1\t1\n#define  ARMADA_37XX_DVFS_LOAD_2\t2\n#define  ARMADA_37XX_DVFS_LOAD_3\t3\n\n \n#define ARMADA_37XX_AVS_CTL0\t\t0x0\n#define\t ARMADA_37XX_AVS_ENABLE\t\tBIT(30)\n#define\t ARMADA_37XX_AVS_HIGH_VDD_LIMIT\t16\n#define\t ARMADA_37XX_AVS_LOW_VDD_LIMIT\t22\n#define\t ARMADA_37XX_AVS_VDD_MASK\t0x3F\n#define ARMADA_37XX_AVS_CTL2\t\t0x8\n#define\t ARMADA_37XX_AVS_LOW_VDD_EN\tBIT(6)\n#define ARMADA_37XX_AVS_VSET(x)\t    (0x1C + 4 * (x))\n\n \n#define LOAD_LEVEL_NR\t4\n\n#define MIN_VOLT_MV 1000\n#define MIN_VOLT_MV_FOR_L1_1000MHZ 1108\n#define MIN_VOLT_MV_FOR_L1_1200MHZ 1155\n\n \nstatic int avs_map[] = {\n\t747, 758, 770, 782, 793, 805, 817, 828, 840, 852, 863, 875, 887, 898,\n\t910, 922, 933, 945, 957, 968, 980, 992, 1003, 1015, 1027, 1038, 1050,\n\t1062, 1073, 1085, 1097, 1108, 1120, 1132, 1143, 1155, 1167, 1178, 1190,\n\t1202, 1213, 1225, 1237, 1248, 1260, 1272, 1283, 1295, 1307, 1318, 1330,\n\t1342\n};\n\nstruct armada37xx_cpufreq_state {\n\tstruct platform_device *pdev;\n\tstruct device *cpu_dev;\n\tstruct regmap *regmap;\n\tu32 nb_l0l1;\n\tu32 nb_l2l3;\n\tu32 nb_dyn_mod;\n\tu32 nb_cpu_load;\n};\n\nstatic struct armada37xx_cpufreq_state *armada37xx_cpufreq_state;\n\nstruct armada_37xx_dvfs {\n\tu32 cpu_freq_max;\n\tu8 divider[LOAD_LEVEL_NR];\n\tu32 avs[LOAD_LEVEL_NR];\n};\n\nstatic struct armada_37xx_dvfs armada_37xx_dvfs[] = {\n\t \n\t \n\t{.cpu_freq_max = 1000*1000*1000, .divider = {1, 2, 4, 5} },\n\t{.cpu_freq_max = 800*1000*1000,  .divider = {1, 2, 3, 4} },\n\t{.cpu_freq_max = 600*1000*1000,  .divider = {2, 4, 5, 6} },\n};\n\nstatic struct armada_37xx_dvfs *armada_37xx_cpu_freq_info_get(u32 freq)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(armada_37xx_dvfs); i++) {\n\t\tif (freq == armada_37xx_dvfs[i].cpu_freq_max)\n\t\t\treturn &armada_37xx_dvfs[i];\n\t}\n\n\tpr_err(\"Unsupported CPU frequency %d MHz\\n\", freq/1000000);\n\treturn NULL;\n}\n\n \nstatic void __init armada37xx_cpufreq_dvfs_setup(struct regmap *base,\n\t\t\t\t\t\t struct regmap *clk_base, u8 *divider)\n{\n\tu32 cpu_tbg_sel;\n\tint load_lvl;\n\n\t \n\tregmap_read(clk_base, ARMADA_37XX_CLK_TBG_SEL, &cpu_tbg_sel);\n\tcpu_tbg_sel >>= ARMADA_37XX_CLK_TBG_SEL_CPU_OFF;\n\tcpu_tbg_sel &= ARMADA_37XX_NB_TBG_SEL_MASK;\n\n\tfor (load_lvl = 0; load_lvl < LOAD_LEVEL_NR; load_lvl++) {\n\t\tunsigned int reg, mask, val, offset = 0;\n\n\t\tif (load_lvl <= ARMADA_37XX_DVFS_LOAD_1)\n\t\t\treg = ARMADA_37XX_NB_L0L1;\n\t\telse\n\t\t\treg = ARMADA_37XX_NB_L2L3;\n\n\t\tif (load_lvl == ARMADA_37XX_DVFS_LOAD_0 ||\n\t\t    load_lvl == ARMADA_37XX_DVFS_LOAD_2)\n\t\t\toffset += ARMADA_37XX_NB_CONFIG_SHIFT;\n\n\t\t \n\t\tval = ARMADA_37XX_NB_CLK_SEL_TBG << ARMADA_37XX_NB_CLK_SEL_OFF;\n\t\tmask = (ARMADA_37XX_NB_CLK_SEL_MASK\n\t\t\t<< ARMADA_37XX_NB_CLK_SEL_OFF);\n\n\t\t \n\t\tval = cpu_tbg_sel << ARMADA_37XX_NB_TBG_SEL_OFF;\n\t\tmask = (ARMADA_37XX_NB_TBG_SEL_MASK\n\t\t\t<< ARMADA_37XX_NB_TBG_SEL_OFF);\n\n\t\t \n\t\tval |= divider[load_lvl] << ARMADA_37XX_NB_TBG_DIV_OFF;\n\t\tmask |= (ARMADA_37XX_NB_TBG_DIV_MASK\n\t\t\t<< ARMADA_37XX_NB_TBG_DIV_OFF);\n\n\t\t \n\t\tval |= load_lvl << ARMADA_37XX_NB_VDD_SEL_OFF;\n\t\tmask |= (ARMADA_37XX_NB_VDD_SEL_MASK\n\t\t\t<< ARMADA_37XX_NB_VDD_SEL_OFF);\n\n\t\tval <<= offset;\n\t\tmask <<= offset;\n\n\t\tregmap_update_bits(base, reg, mask, val);\n\t}\n}\n\n \nstatic u32 armada_37xx_avs_val_match(int target_vm)\n{\n\tu32 avs;\n\n\t \n\tfor (avs = 0; avs < ARRAY_SIZE(avs_map); avs++)\n\t\tif (avs_map[avs] >= target_vm)\n\t\t\tbreak;\n\n\t \n\tif (avs == ARRAY_SIZE(avs_map))\n\t\tavs = ARRAY_SIZE(avs_map) - 1;\n\n\treturn avs;\n}\n\n \nstatic void __init armada37xx_cpufreq_avs_configure(struct regmap *base,\n\t\t\t\t\t\tstruct armada_37xx_dvfs *dvfs)\n{\n\tunsigned int target_vm;\n\tint load_level = 0;\n\tu32 l0_vdd_min;\n\n\tif (base == NULL)\n\t\treturn;\n\n\t \n\tregmap_read(base, ARMADA_37XX_AVS_CTL0, &l0_vdd_min);\n\tl0_vdd_min = (l0_vdd_min >> ARMADA_37XX_AVS_LOW_VDD_LIMIT) &\n\t\tARMADA_37XX_AVS_VDD_MASK;\n\tif (l0_vdd_min >= ARRAY_SIZE(avs_map))  {\n\t\tpr_err(\"L0 VDD MIN %d is not correct.\\n\", l0_vdd_min);\n\t\treturn;\n\t}\n\tdvfs->avs[0] = l0_vdd_min;\n\n\tif (avs_map[l0_vdd_min] <= MIN_VOLT_MV) {\n\t\t \n\t\tu32 avs_min = armada_37xx_avs_val_match(MIN_VOLT_MV);\n\n\t\tfor (load_level = 1; load_level < LOAD_LEVEL_NR; load_level++)\n\t\t\tdvfs->avs[load_level] = avs_min;\n\n\t\t \n\t\tif (dvfs->cpu_freq_max >= 1000*1000*1000) {\n\t\t\tif (dvfs->cpu_freq_max >= 1200*1000*1000)\n\t\t\t\tavs_min = armada_37xx_avs_val_match(MIN_VOLT_MV_FOR_L1_1200MHZ);\n\t\t\telse\n\t\t\t\tavs_min = armada_37xx_avs_val_match(MIN_VOLT_MV_FOR_L1_1000MHZ);\n\t\t\tdvfs->avs[0] = dvfs->avs[1] = avs_min;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\n\ttarget_vm = avs_map[l0_vdd_min] - 100;\n\ttarget_vm = target_vm > MIN_VOLT_MV ? target_vm : MIN_VOLT_MV;\n\tdvfs->avs[1] = armada_37xx_avs_val_match(target_vm);\n\n\t \n\ttarget_vm = avs_map[l0_vdd_min] - 150;\n\ttarget_vm = target_vm > MIN_VOLT_MV ? target_vm : MIN_VOLT_MV;\n\tdvfs->avs[2] = dvfs->avs[3] = armada_37xx_avs_val_match(target_vm);\n\n\t \n\tif (dvfs->cpu_freq_max >= 1000*1000*1000) {\n\t\tu32 avs_min_l1;\n\n\t\tif (dvfs->cpu_freq_max >= 1200*1000*1000)\n\t\t\tavs_min_l1 = armada_37xx_avs_val_match(MIN_VOLT_MV_FOR_L1_1200MHZ);\n\t\telse\n\t\t\tavs_min_l1 = armada_37xx_avs_val_match(MIN_VOLT_MV_FOR_L1_1000MHZ);\n\n\t\tif (avs_min_l1 > dvfs->avs[0])\n\t\t\tavs_min_l1 = dvfs->avs[0];\n\n\t\tif (dvfs->avs[1] < avs_min_l1)\n\t\t\tdvfs->avs[1] = avs_min_l1;\n\t}\n}\n\nstatic void __init armada37xx_cpufreq_avs_setup(struct regmap *base,\n\t\t\t\t\t\tstruct armada_37xx_dvfs *dvfs)\n{\n\tunsigned int avs_val = 0;\n\tint load_level = 0;\n\n\tif (base == NULL)\n\t\treturn;\n\n\t \n\tregmap_update_bits(base, ARMADA_37XX_AVS_CTL0,\n\t\t\t   ARMADA_37XX_AVS_ENABLE, 0);\n\n\n\t \n\tregmap_update_bits(base, ARMADA_37XX_AVS_CTL2,\n\t\t\t   ARMADA_37XX_AVS_LOW_VDD_EN,\n\t\t\t   ARMADA_37XX_AVS_LOW_VDD_EN);\n\n\n\tfor (load_level = 1; load_level < LOAD_LEVEL_NR; load_level++) {\n\t\tavs_val = dvfs->avs[load_level];\n\t\tregmap_update_bits(base, ARMADA_37XX_AVS_VSET(load_level-1),\n\t\t    ARMADA_37XX_AVS_VDD_MASK << ARMADA_37XX_AVS_HIGH_VDD_LIMIT |\n\t\t    ARMADA_37XX_AVS_VDD_MASK << ARMADA_37XX_AVS_LOW_VDD_LIMIT,\n\t\t    avs_val << ARMADA_37XX_AVS_HIGH_VDD_LIMIT |\n\t\t    avs_val << ARMADA_37XX_AVS_LOW_VDD_LIMIT);\n\t}\n\n\t \n\tregmap_update_bits(base, ARMADA_37XX_AVS_CTL0,\n\t\t\t   ARMADA_37XX_AVS_ENABLE,\n\t\t\t   ARMADA_37XX_AVS_ENABLE);\n\n}\n\nstatic void armada37xx_cpufreq_disable_dvfs(struct regmap *base)\n{\n\tunsigned int reg = ARMADA_37XX_NB_DYN_MOD,\n\t\tmask = ARMADA_37XX_NB_DFS_EN;\n\n\tregmap_update_bits(base, reg, mask, 0);\n}\n\nstatic void __init armada37xx_cpufreq_enable_dvfs(struct regmap *base)\n{\n\tunsigned int val, reg = ARMADA_37XX_NB_CPU_LOAD,\n\t\tmask = ARMADA_37XX_NB_CPU_LOAD_MASK;\n\n\t \n\tval = ARMADA_37XX_DVFS_LOAD_0;\n\tregmap_update_bits(base, reg, mask, val);\n\n\t \n\treg = ARMADA_37XX_NB_DYN_MOD;\n\tmask =\tARMADA_37XX_NB_CLK_SEL_EN | ARMADA_37XX_NB_TBG_EN |\n\t\tARMADA_37XX_NB_DIV_EN | ARMADA_37XX_NB_VDD_EN |\n\t\tARMADA_37XX_NB_DFS_EN;\n\n\tregmap_update_bits(base, reg, mask, mask);\n}\n\nstatic int armada37xx_cpufreq_suspend(struct cpufreq_policy *policy)\n{\n\tstruct armada37xx_cpufreq_state *state = armada37xx_cpufreq_state;\n\n\tregmap_read(state->regmap, ARMADA_37XX_NB_L0L1, &state->nb_l0l1);\n\tregmap_read(state->regmap, ARMADA_37XX_NB_L2L3, &state->nb_l2l3);\n\tregmap_read(state->regmap, ARMADA_37XX_NB_CPU_LOAD,\n\t\t    &state->nb_cpu_load);\n\tregmap_read(state->regmap, ARMADA_37XX_NB_DYN_MOD, &state->nb_dyn_mod);\n\n\treturn 0;\n}\n\nstatic int armada37xx_cpufreq_resume(struct cpufreq_policy *policy)\n{\n\tstruct armada37xx_cpufreq_state *state = armada37xx_cpufreq_state;\n\n\t \n\tarmada37xx_cpufreq_disable_dvfs(state->regmap);\n\n\tregmap_write(state->regmap, ARMADA_37XX_NB_L0L1, state->nb_l0l1);\n\tregmap_write(state->regmap, ARMADA_37XX_NB_L2L3, state->nb_l2l3);\n\tregmap_write(state->regmap, ARMADA_37XX_NB_CPU_LOAD,\n\t\t     state->nb_cpu_load);\n\n\t \n\tregmap_write(state->regmap, ARMADA_37XX_NB_DYN_MOD, state->nb_dyn_mod);\n\n\treturn 0;\n}\n\nstatic int __init armada37xx_cpufreq_driver_init(void)\n{\n\tstruct cpufreq_dt_platform_data pdata;\n\tstruct armada_37xx_dvfs *dvfs;\n\tstruct platform_device *pdev;\n\tunsigned long freq;\n\tunsigned int base_frequency;\n\tstruct regmap *nb_clk_base, *nb_pm_base, *avs_base;\n\tstruct device *cpu_dev;\n\tint load_lvl, ret;\n\tstruct clk *clk, *parent;\n\n\tnb_clk_base =\n\t\tsyscon_regmap_lookup_by_compatible(\"marvell,armada-3700-periph-clock-nb\");\n\tif (IS_ERR(nb_clk_base))\n\t\treturn -ENODEV;\n\n\tnb_pm_base =\n\t\tsyscon_regmap_lookup_by_compatible(\"marvell,armada-3700-nb-pm\");\n\n\tif (IS_ERR(nb_pm_base))\n\t\treturn -ENODEV;\n\n\tavs_base =\n\t\tsyscon_regmap_lookup_by_compatible(\"marvell,armada-3700-avs\");\n\n\t \n\tif (IS_ERR(avs_base)) {\n\t\tpr_info(\"Syscon failed for Adapting Voltage Scaling: skip it\\n\");\n\t\tavs_base = NULL;\n\t}\n\t \n\tarmada37xx_cpufreq_disable_dvfs(nb_pm_base);\n\n\t \n\tcpu_dev = get_cpu_device(0);\n\tif (!cpu_dev) {\n\t\tdev_err(cpu_dev, \"Cannot get CPU\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tclk = clk_get(cpu_dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tdev_err(cpu_dev, \"Cannot get clock for CPU0\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\tparent = clk_get_parent(clk);\n\tif (IS_ERR(parent)) {\n\t\tdev_err(cpu_dev, \"Cannot get parent clock for CPU0\\n\");\n\t\tclk_put(clk);\n\t\treturn PTR_ERR(parent);\n\t}\n\n\t \n\tbase_frequency =  clk_get_rate(parent);\n\n\tif (!base_frequency) {\n\t\tdev_err(cpu_dev, \"Failed to get parent clock rate for CPU\\n\");\n\t\tclk_put(clk);\n\t\treturn -EINVAL;\n\t}\n\n\tdvfs = armada_37xx_cpu_freq_info_get(base_frequency);\n\tif (!dvfs) {\n\t\tclk_put(clk);\n\t\treturn -EINVAL;\n\t}\n\n\tarmada37xx_cpufreq_state = kmalloc(sizeof(*armada37xx_cpufreq_state),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!armada37xx_cpufreq_state) {\n\t\tclk_put(clk);\n\t\treturn -ENOMEM;\n\t}\n\n\tarmada37xx_cpufreq_state->regmap = nb_pm_base;\n\n\tarmada37xx_cpufreq_avs_configure(avs_base, dvfs);\n\tarmada37xx_cpufreq_avs_setup(avs_base, dvfs);\n\n\tarmada37xx_cpufreq_dvfs_setup(nb_pm_base, nb_clk_base, dvfs->divider);\n\tclk_put(clk);\n\n\tfor (load_lvl = ARMADA_37XX_DVFS_LOAD_0; load_lvl < LOAD_LEVEL_NR;\n\t     load_lvl++) {\n\t\tunsigned long u_volt = avs_map[dvfs->avs[load_lvl]] * 1000;\n\t\tfreq = base_frequency / dvfs->divider[load_lvl];\n\t\tret = dev_pm_opp_add(cpu_dev, freq, u_volt);\n\t\tif (ret)\n\t\t\tgoto remove_opp;\n\n\n\t}\n\n\t \n\tarmada37xx_cpufreq_enable_dvfs(nb_pm_base);\n\n\tmemset(&pdata, 0, sizeof(pdata));\n\tpdata.suspend = armada37xx_cpufreq_suspend;\n\tpdata.resume = armada37xx_cpufreq_resume;\n\n\tpdev = platform_device_register_data(NULL, \"cpufreq-dt\", -1, &pdata,\n\t\t\t\t\t     sizeof(pdata));\n\tret = PTR_ERR_OR_ZERO(pdev);\n\tif (ret)\n\t\tgoto disable_dvfs;\n\n\tarmada37xx_cpufreq_state->cpu_dev = cpu_dev;\n\tarmada37xx_cpufreq_state->pdev = pdev;\n\tplatform_set_drvdata(pdev, dvfs);\n\treturn 0;\n\ndisable_dvfs:\n\tarmada37xx_cpufreq_disable_dvfs(nb_pm_base);\nremove_opp:\n\t \n\twhile (load_lvl-- > ARMADA_37XX_DVFS_LOAD_0) {\n\t\tfreq = base_frequency / dvfs->divider[load_lvl];\n\t\tdev_pm_opp_remove(cpu_dev, freq);\n\t}\n\n\tkfree(armada37xx_cpufreq_state);\n\n\treturn ret;\n}\n \nlate_initcall(armada37xx_cpufreq_driver_init);\n\nstatic void __exit armada37xx_cpufreq_driver_exit(void)\n{\n\tstruct platform_device *pdev = armada37xx_cpufreq_state->pdev;\n\tstruct armada_37xx_dvfs *dvfs = platform_get_drvdata(pdev);\n\tunsigned long freq;\n\tint load_lvl;\n\n\tplatform_device_unregister(pdev);\n\n\tarmada37xx_cpufreq_disable_dvfs(armada37xx_cpufreq_state->regmap);\n\n\tfor (load_lvl = ARMADA_37XX_DVFS_LOAD_0; load_lvl < LOAD_LEVEL_NR; load_lvl++) {\n\t\tfreq = dvfs->cpu_freq_max / dvfs->divider[load_lvl];\n\t\tdev_pm_opp_remove(armada37xx_cpufreq_state->cpu_dev, freq);\n\t}\n\n\tkfree(armada37xx_cpufreq_state);\n}\nmodule_exit(armada37xx_cpufreq_driver_exit);\n\nstatic const struct of_device_id __maybe_unused armada37xx_cpufreq_of_match[] = {\n\t{ .compatible = \"marvell,armada-3700-nb-pm\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, armada37xx_cpufreq_of_match);\n\nMODULE_AUTHOR(\"Gregory CLEMENT <gregory.clement@free-electrons.com>\");\nMODULE_DESCRIPTION(\"Armada 37xx cpufreq driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}