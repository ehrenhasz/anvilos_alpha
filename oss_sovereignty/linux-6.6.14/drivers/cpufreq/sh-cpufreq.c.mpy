{
  "module_name": "sh-cpufreq.c",
  "hash_id": "9f11e10eb9c07941c3b504e35ec42aa35e607a8e20f296dbb2a5bce68e1a2e64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/sh-cpufreq.c",
  "human_readable_source": " \n#define pr_fmt(fmt) \"cpufreq: \" fmt\n\n#include <linux/types.h>\n#include <linux/cpufreq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/err.h>\n#include <linux/cpumask.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n#include <linux/clk.h>\n#include <linux/percpu.h>\n#include <linux/sh_clk.h>\n\nstatic DEFINE_PER_CPU(struct clk, sh_cpuclk);\n\nstruct cpufreq_target {\n\tstruct cpufreq_policy\t*policy;\n\tunsigned int\t\tfreq;\n};\n\nstatic unsigned int sh_cpufreq_get(unsigned int cpu)\n{\n\treturn (clk_get_rate(&per_cpu(sh_cpuclk, cpu)) + 500) / 1000;\n}\n\nstatic long __sh_cpufreq_target(void *arg)\n{\n\tstruct cpufreq_target *target = arg;\n\tstruct cpufreq_policy *policy = target->policy;\n\tint cpu = policy->cpu;\n\tstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\n\tstruct cpufreq_freqs freqs;\n\tstruct device *dev;\n\tlong freq;\n\n\tif (smp_processor_id() != cpu)\n\t\treturn -ENODEV;\n\n\tdev = get_cpu_device(cpu);\n\n\t \n\tfreq = clk_round_rate(cpuclk, target->freq * 1000);\n\n\tif (freq < (policy->min * 1000) || freq > (policy->max * 1000))\n\t\treturn -EINVAL;\n\n\tdev_dbg(dev, \"requested frequency %u Hz\\n\", target->freq * 1000);\n\n\tfreqs.old\t= sh_cpufreq_get(cpu);\n\tfreqs.new\t= (freq + 500) / 1000;\n\tfreqs.flags\t= 0;\n\n\tcpufreq_freq_transition_begin(target->policy, &freqs);\n\tclk_set_rate(cpuclk, freq);\n\tcpufreq_freq_transition_end(target->policy, &freqs, 0);\n\n\tdev_dbg(dev, \"set frequency %lu Hz\\n\", freq);\n\treturn 0;\n}\n\n \nstatic int sh_cpufreq_target(struct cpufreq_policy *policy,\n\t\t\t     unsigned int target_freq,\n\t\t\t     unsigned int relation)\n{\n\tstruct cpufreq_target data = { .policy = policy, .freq = target_freq };\n\n\treturn work_on_cpu(policy->cpu, __sh_cpufreq_target, &data);\n}\n\nstatic int sh_cpufreq_verify(struct cpufreq_policy_data *policy)\n{\n\tstruct clk *cpuclk = &per_cpu(sh_cpuclk, policy->cpu);\n\tstruct cpufreq_frequency_table *freq_table;\n\n\tfreq_table = cpuclk->nr_freqs ? cpuclk->freq_table : NULL;\n\tif (freq_table)\n\t\treturn cpufreq_frequency_table_verify(policy, freq_table);\n\n\tcpufreq_verify_within_cpu_limits(policy);\n\n\tpolicy->min = (clk_round_rate(cpuclk, 1) + 500) / 1000;\n\tpolicy->max = (clk_round_rate(cpuclk, ~0UL) + 500) / 1000;\n\n\tcpufreq_verify_within_cpu_limits(policy);\n\treturn 0;\n}\n\nstatic int sh_cpufreq_cpu_init(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\tstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\n\tstruct cpufreq_frequency_table *freq_table;\n\tstruct device *dev;\n\n\tdev = get_cpu_device(cpu);\n\n\tcpuclk = clk_get(dev, \"cpu_clk\");\n\tif (IS_ERR(cpuclk)) {\n\t\tdev_err(dev, \"couldn't get CPU clk\\n\");\n\t\treturn PTR_ERR(cpuclk);\n\t}\n\n\tfreq_table = cpuclk->nr_freqs ? cpuclk->freq_table : NULL;\n\tif (freq_table) {\n\t\tpolicy->freq_table = freq_table;\n\t} else {\n\t\tdev_notice(dev, \"no frequency table found, falling back \"\n\t\t\t   \"to rate rounding.\\n\");\n\n\t\tpolicy->min = policy->cpuinfo.min_freq =\n\t\t\t(clk_round_rate(cpuclk, 1) + 500) / 1000;\n\t\tpolicy->max = policy->cpuinfo.max_freq =\n\t\t\t(clk_round_rate(cpuclk, ~0UL) + 500) / 1000;\n\t}\n\n\treturn 0;\n}\n\nstatic int sh_cpufreq_cpu_exit(struct cpufreq_policy *policy)\n{\n\tunsigned int cpu = policy->cpu;\n\tstruct clk *cpuclk = &per_cpu(sh_cpuclk, cpu);\n\n\tclk_put(cpuclk);\n\n\treturn 0;\n}\n\nstatic struct cpufreq_driver sh_cpufreq_driver = {\n\t.name\t\t= \"sh\",\n\t.flags\t\t= CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.get\t\t= sh_cpufreq_get,\n\t.target\t\t= sh_cpufreq_target,\n\t.verify\t\t= sh_cpufreq_verify,\n\t.init\t\t= sh_cpufreq_cpu_init,\n\t.exit\t\t= sh_cpufreq_cpu_exit,\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic int __init sh_cpufreq_module_init(void)\n{\n\tpr_notice(\"SuperH CPU frequency driver.\\n\");\n\treturn cpufreq_register_driver(&sh_cpufreq_driver);\n}\n\nstatic void __exit sh_cpufreq_module_exit(void)\n{\n\tcpufreq_unregister_driver(&sh_cpufreq_driver);\n}\n\nmodule_init(sh_cpufreq_module_init);\nmodule_exit(sh_cpufreq_module_exit);\n\nMODULE_AUTHOR(\"Paul Mundt <lethal@linux-sh.org>\");\nMODULE_DESCRIPTION(\"cpufreq driver for SuperH\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}