{
  "module_name": "powernow-k8.c",
  "hash_id": "e8aba90ab25be53597eca30025e64e1de4096c7b2b5f1fcac006d4cba18ea8b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/powernow-k8.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/cpufreq.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/cpumask.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n\n#include <asm/msr.h>\n#include <asm/cpu_device_id.h>\n\n#include <linux/acpi.h>\n#include <linux/mutex.h>\n#include <acpi/processor.h>\n\n#define VERSION \"version 2.20.00\"\n#include \"powernow-k8.h\"\n\n \nstatic DEFINE_MUTEX(fidvid_mutex);\n\nstatic DEFINE_PER_CPU(struct powernow_k8_data *, powernow_data);\n\nstatic struct cpufreq_driver cpufreq_amd64_driver;\n\n \nstatic u32 find_freq_from_fid(u32 fid)\n{\n\treturn 800 + (fid * 100);\n}\n\n \nstatic u32 find_khz_freq_from_fid(u32 fid)\n{\n\treturn 1000 * find_freq_from_fid(fid);\n}\n\n \nstatic u32 convert_fid_to_vco_fid(u32 fid)\n{\n\tif (fid < HI_FID_TABLE_BOTTOM)\n\t\treturn 8 + (2 * fid);\n\telse\n\t\treturn fid;\n}\n\n \nstatic int pending_bit_stuck(void)\n{\n\tu32 lo, hi __always_unused;\n\n\trdmsr(MSR_FIDVID_STATUS, lo, hi);\n\treturn lo & MSR_S_LO_CHANGE_PENDING ? 1 : 0;\n}\n\n \nstatic int query_current_values_with_pending_wait(struct powernow_k8_data *data)\n{\n\tu32 lo, hi;\n\tu32 i = 0;\n\n\tdo {\n\t\tif (i++ > 10000) {\n\t\t\tpr_debug(\"detected change pending stuck\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\trdmsr(MSR_FIDVID_STATUS, lo, hi);\n\t} while (lo & MSR_S_LO_CHANGE_PENDING);\n\n\tdata->currvid = hi & MSR_S_HI_CURRENT_VID;\n\tdata->currfid = lo & MSR_S_LO_CURRENT_FID;\n\n\treturn 0;\n}\n\n \nstatic void count_off_irt(struct powernow_k8_data *data)\n{\n\tudelay((1 << data->irt) * 10);\n}\n\n \nstatic void count_off_vst(struct powernow_k8_data *data)\n{\n\tudelay(data->vstable * VST_UNITS_20US);\n}\n\n \nstatic void fidvid_msr_init(void)\n{\n\tu32 lo, hi;\n\tu8 fid, vid;\n\n\trdmsr(MSR_FIDVID_STATUS, lo, hi);\n\tvid = hi & MSR_S_HI_CURRENT_VID;\n\tfid = lo & MSR_S_LO_CURRENT_FID;\n\tlo = fid | (vid << MSR_C_LO_VID_SHIFT);\n\thi = MSR_C_HI_STP_GNT_BENIGN;\n\tpr_debug(\"cpu%d, init lo 0x%x, hi 0x%x\\n\", smp_processor_id(), lo, hi);\n\twrmsr(MSR_FIDVID_CTL, lo, hi);\n}\n\n \nstatic int write_new_fid(struct powernow_k8_data *data, u32 fid)\n{\n\tu32 lo;\n\tu32 savevid = data->currvid;\n\tu32 i = 0;\n\n\tif ((fid & INVALID_FID_MASK) || (data->currvid & INVALID_VID_MASK)) {\n\t\tpr_err(\"internal error - overflow on fid write\\n\");\n\t\treturn 1;\n\t}\n\n\tlo = fid;\n\tlo |= (data->currvid << MSR_C_LO_VID_SHIFT);\n\tlo |= MSR_C_LO_INIT_FID_VID;\n\n\tpr_debug(\"writing fid 0x%x, lo 0x%x, hi 0x%x\\n\",\n\t\tfid, lo, data->plllock * PLL_LOCK_CONVERSION);\n\n\tdo {\n\t\twrmsr(MSR_FIDVID_CTL, lo, data->plllock * PLL_LOCK_CONVERSION);\n\t\tif (i++ > 100) {\n\t\t\tpr_err(\"Hardware error - pending bit very stuck - no further pstate changes possible\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} while (query_current_values_with_pending_wait(data));\n\n\tcount_off_irt(data);\n\n\tif (savevid != data->currvid) {\n\t\tpr_err(\"vid change on fid trans, old 0x%x, new 0x%x\\n\",\n\t\t       savevid, data->currvid);\n\t\treturn 1;\n\t}\n\n\tif (fid != data->currfid) {\n\t\tpr_err(\"fid trans failed, fid 0x%x, curr 0x%x\\n\", fid,\n\t\t\tdata->currfid);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int write_new_vid(struct powernow_k8_data *data, u32 vid)\n{\n\tu32 lo;\n\tu32 savefid = data->currfid;\n\tint i = 0;\n\n\tif ((data->currfid & INVALID_FID_MASK) || (vid & INVALID_VID_MASK)) {\n\t\tpr_err(\"internal error - overflow on vid write\\n\");\n\t\treturn 1;\n\t}\n\n\tlo = data->currfid;\n\tlo |= (vid << MSR_C_LO_VID_SHIFT);\n\tlo |= MSR_C_LO_INIT_FID_VID;\n\n\tpr_debug(\"writing vid 0x%x, lo 0x%x, hi 0x%x\\n\",\n\t\tvid, lo, STOP_GRANT_5NS);\n\n\tdo {\n\t\twrmsr(MSR_FIDVID_CTL, lo, STOP_GRANT_5NS);\n\t\tif (i++ > 100) {\n\t\t\tpr_err(\"internal error - pending bit very stuck - no further pstate changes possible\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} while (query_current_values_with_pending_wait(data));\n\n\tif (savefid != data->currfid) {\n\t\tpr_err(\"fid changed on vid trans, old 0x%x new 0x%x\\n\",\n\t\t\tsavefid, data->currfid);\n\t\treturn 1;\n\t}\n\n\tif (vid != data->currvid) {\n\t\tpr_err(\"vid trans failed, vid 0x%x, curr 0x%x\\n\",\n\t\t\t\tvid, data->currvid);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int decrease_vid_code_by_step(struct powernow_k8_data *data,\n\t\tu32 reqvid, u32 step)\n{\n\tif ((data->currvid - reqvid) > step)\n\t\treqvid = data->currvid - step;\n\n\tif (write_new_vid(data, reqvid))\n\t\treturn 1;\n\n\tcount_off_vst(data);\n\n\treturn 0;\n}\n\n \nstatic int transition_fid_vid(struct powernow_k8_data *data,\n\t\tu32 reqfid, u32 reqvid)\n{\n\tif (core_voltage_pre_transition(data, reqvid, reqfid))\n\t\treturn 1;\n\n\tif (core_frequency_transition(data, reqfid))\n\t\treturn 1;\n\n\tif (core_voltage_post_transition(data, reqvid))\n\t\treturn 1;\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn 1;\n\n\tif ((reqfid != data->currfid) || (reqvid != data->currvid)) {\n\t\tpr_err(\"failed (cpu%d): req 0x%x 0x%x, curr 0x%x 0x%x\\n\",\n\t\t\t\tsmp_processor_id(),\n\t\t\t\treqfid, reqvid, data->currfid, data->currvid);\n\t\treturn 1;\n\t}\n\n\tpr_debug(\"transitioned (cpu%d): new fid 0x%x, vid 0x%x\\n\",\n\t\tsmp_processor_id(), data->currfid, data->currvid);\n\n\treturn 0;\n}\n\n \nstatic int core_voltage_pre_transition(struct powernow_k8_data *data,\n\t\tu32 reqvid, u32 reqfid)\n{\n\tu32 rvosteps = data->rvo;\n\tu32 savefid = data->currfid;\n\tu32 maxvid, lo __always_unused, rvomult = 1;\n\n\tpr_debug(\"ph1 (cpu%d): start, currfid 0x%x, currvid 0x%x, reqvid 0x%x, rvo 0x%x\\n\",\n\t\tsmp_processor_id(),\n\t\tdata->currfid, data->currvid, reqvid, data->rvo);\n\n\tif ((savefid < LO_FID_TABLE_TOP) && (reqfid < LO_FID_TABLE_TOP))\n\t\trvomult = 2;\n\trvosteps *= rvomult;\n\trdmsr(MSR_FIDVID_STATUS, lo, maxvid);\n\tmaxvid = 0x1f & (maxvid >> 16);\n\tpr_debug(\"ph1 maxvid=0x%x\\n\", maxvid);\n\tif (reqvid < maxvid)  \n\t\treqvid = maxvid;\n\n\twhile (data->currvid > reqvid) {\n\t\tpr_debug(\"ph1: curr 0x%x, req vid 0x%x\\n\",\n\t\t\tdata->currvid, reqvid);\n\t\tif (decrease_vid_code_by_step(data, reqvid, data->vidmvs))\n\t\t\treturn 1;\n\t}\n\n\twhile ((rvosteps > 0) &&\n\t\t\t((rvomult * data->rvo + data->currvid) > reqvid)) {\n\t\tif (data->currvid == maxvid) {\n\t\t\trvosteps = 0;\n\t\t} else {\n\t\t\tpr_debug(\"ph1: changing vid for rvo, req 0x%x\\n\",\n\t\t\t\tdata->currvid - 1);\n\t\t\tif (decrease_vid_code_by_step(data, data->currvid-1, 1))\n\t\t\t\treturn 1;\n\t\t\trvosteps--;\n\t\t}\n\t}\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn 1;\n\n\tif (savefid != data->currfid) {\n\t\tpr_err(\"ph1 err, currfid changed 0x%x\\n\", data->currfid);\n\t\treturn 1;\n\t}\n\n\tpr_debug(\"ph1 complete, currfid 0x%x, currvid 0x%x\\n\",\n\t\tdata->currfid, data->currvid);\n\n\treturn 0;\n}\n\n \nstatic int core_frequency_transition(struct powernow_k8_data *data, u32 reqfid)\n{\n\tu32 vcoreqfid, vcocurrfid, vcofiddiff;\n\tu32 fid_interval, savevid = data->currvid;\n\n\tif (data->currfid == reqfid) {\n\t\tpr_err(\"ph2 null fid transition 0x%x\\n\", data->currfid);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"ph2 (cpu%d): starting, currfid 0x%x, currvid 0x%x, reqfid 0x%x\\n\",\n\t\tsmp_processor_id(),\n\t\tdata->currfid, data->currvid, reqfid);\n\n\tvcoreqfid = convert_fid_to_vco_fid(reqfid);\n\tvcocurrfid = convert_fid_to_vco_fid(data->currfid);\n\tvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\n\t    : vcoreqfid - vcocurrfid;\n\n\tif ((reqfid <= LO_FID_TABLE_TOP) && (data->currfid <= LO_FID_TABLE_TOP))\n\t\tvcofiddiff = 0;\n\n\twhile (vcofiddiff > 2) {\n\t\t(data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);\n\n\t\tif (reqfid > data->currfid) {\n\t\t\tif (data->currfid > LO_FID_TABLE_TOP) {\n\t\t\t\tif (write_new_fid(data,\n\t\t\t\t\t\tdata->currfid + fid_interval))\n\t\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tif (write_new_fid\n\t\t\t\t    (data,\n\t\t\t\t     2 + convert_fid_to_vco_fid(data->currfid)))\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (write_new_fid(data, data->currfid - fid_interval))\n\t\t\t\treturn 1;\n\t\t}\n\n\t\tvcocurrfid = convert_fid_to_vco_fid(data->currfid);\n\t\tvcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid\n\t\t    : vcoreqfid - vcocurrfid;\n\t}\n\n\tif (write_new_fid(data, reqfid))\n\t\treturn 1;\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn 1;\n\n\tif (data->currfid != reqfid) {\n\t\tpr_err(\"ph2: mismatch, failed fid transition, curr 0x%x, req 0x%x\\n\",\n\t\t\tdata->currfid, reqfid);\n\t\treturn 1;\n\t}\n\n\tif (savevid != data->currvid) {\n\t\tpr_err(\"ph2: vid changed, save 0x%x, curr 0x%x\\n\",\n\t\t\tsavevid, data->currvid);\n\t\treturn 1;\n\t}\n\n\tpr_debug(\"ph2 complete, currfid 0x%x, currvid 0x%x\\n\",\n\t\tdata->currfid, data->currvid);\n\n\treturn 0;\n}\n\n \nstatic int core_voltage_post_transition(struct powernow_k8_data *data,\n\t\tu32 reqvid)\n{\n\tu32 savefid = data->currfid;\n\tu32 savereqvid = reqvid;\n\n\tpr_debug(\"ph3 (cpu%d): starting, currfid 0x%x, currvid 0x%x\\n\",\n\t\tsmp_processor_id(),\n\t\tdata->currfid, data->currvid);\n\n\tif (reqvid != data->currvid) {\n\t\tif (write_new_vid(data, reqvid))\n\t\t\treturn 1;\n\n\t\tif (savefid != data->currfid) {\n\t\t\tpr_err(\"ph3: bad fid change, save 0x%x, curr 0x%x\\n\",\n\t\t\t\tsavefid, data->currfid);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (data->currvid != reqvid) {\n\t\t\tpr_err(\"ph3: failed vid transition\\n, req 0x%x, curr 0x%x\",\n\t\t\t\treqvid, data->currvid);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn 1;\n\n\tif (savereqvid != data->currvid) {\n\t\tpr_debug(\"ph3 failed, currvid 0x%x\\n\", data->currvid);\n\t\treturn 1;\n\t}\n\n\tif (savefid != data->currfid) {\n\t\tpr_debug(\"ph3 failed, currfid changed 0x%x\\n\",\n\t\t\tdata->currfid);\n\t\treturn 1;\n\t}\n\n\tpr_debug(\"ph3 complete, currfid 0x%x, currvid 0x%x\\n\",\n\t\tdata->currfid, data->currvid);\n\n\treturn 0;\n}\n\nstatic const struct x86_cpu_id powernow_k8_ids[] = {\n\t \n\tX86_MATCH_VENDOR_FAM(AMD, 0xf, NULL),\n\t{}\n};\nMODULE_DEVICE_TABLE(x86cpu, powernow_k8_ids);\n\nstatic void check_supported_cpu(void *_rc)\n{\n\tu32 eax, ebx, ecx, edx;\n\tint *rc = _rc;\n\n\t*rc = -ENODEV;\n\n\teax = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\n\n\tif ((eax & CPUID_XFAM) == CPUID_XFAM_K8) {\n\t\tif (((eax & CPUID_USE_XFAM_XMOD) != CPUID_USE_XFAM_XMOD) ||\n\t\t    ((eax & CPUID_XMOD) > CPUID_XMOD_REV_MASK)) {\n\t\t\tpr_info(\"Processor cpuid %x not supported\\n\", eax);\n\t\t\treturn;\n\t\t}\n\n\t\teax = cpuid_eax(CPUID_GET_MAX_CAPABILITIES);\n\t\tif (eax < CPUID_FREQ_VOLT_CAPABILITIES) {\n\t\t\tpr_info(\"No frequency change capabilities detected\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tcpuid(CPUID_FREQ_VOLT_CAPABILITIES, &eax, &ebx, &ecx, &edx);\n\t\tif ((edx & P_STATE_TRANSITION_CAPABLE)\n\t\t\t!= P_STATE_TRANSITION_CAPABLE) {\n\t\t\tpr_info(\"Power state transitions not supported\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*rc = 0;\n\t}\n}\n\nstatic int check_pst_table(struct powernow_k8_data *data, struct pst_s *pst,\n\t\tu8 maxvid)\n{\n\tunsigned int j;\n\tu8 lastfid = 0xff;\n\n\tfor (j = 0; j < data->numps; j++) {\n\t\tif (pst[j].vid > LEAST_VID) {\n\t\t\tpr_err(FW_BUG \"vid %d invalid : 0x%x\\n\", j,\n\t\t\t\tpst[j].vid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pst[j].vid < data->rvo) {\n\t\t\t \n\t\t\tpr_err(FW_BUG \"0 vid exceeded with pstate %d\\n\", j);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (pst[j].vid < maxvid + data->rvo) {\n\t\t\t \n\t\t\tpr_err(FW_BUG \"maxvid exceeded with pstate %d\\n\", j);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (pst[j].fid > MAX_FID) {\n\t\t\tpr_err(FW_BUG \"maxfid exceeded with pstate %d\\n\", j);\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (j && (pst[j].fid < HI_FID_TABLE_BOTTOM)) {\n\t\t\t \n\t\t\tpr_err(FW_BUG \"two low fids - %d : 0x%x\\n\", j,\n\t\t\t\tpst[j].fid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (pst[j].fid < lastfid)\n\t\t\tlastfid = pst[j].fid;\n\t}\n\tif (lastfid & 1) {\n\t\tpr_err(FW_BUG \"lastfid invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (lastfid > LO_FID_TABLE_TOP)\n\t\tpr_info(FW_BUG \"first fid not from lo freq table\\n\");\n\n\treturn 0;\n}\n\nstatic void invalidate_entry(struct cpufreq_frequency_table *powernow_table,\n\t\tunsigned int entry)\n{\n\tpowernow_table[entry].frequency = CPUFREQ_ENTRY_INVALID;\n}\n\nstatic void print_basics(struct powernow_k8_data *data)\n{\n\tint j;\n\tfor (j = 0; j < data->numps; j++) {\n\t\tif (data->powernow_table[j].frequency !=\n\t\t\t\tCPUFREQ_ENTRY_INVALID) {\n\t\t\tpr_info(\"fid 0x%x (%d MHz), vid 0x%x\\n\",\n\t\t\t\tdata->powernow_table[j].driver_data & 0xff,\n\t\t\t\tdata->powernow_table[j].frequency/1000,\n\t\t\t\tdata->powernow_table[j].driver_data >> 8);\n\t\t}\n\t}\n\tif (data->batps)\n\t\tpr_info(\"Only %d pstates on battery\\n\", data->batps);\n}\n\nstatic int fill_powernow_table(struct powernow_k8_data *data,\n\t\tstruct pst_s *pst, u8 maxvid)\n{\n\tstruct cpufreq_frequency_table *powernow_table;\n\tunsigned int j;\n\n\tif (data->batps) {\n\t\t \n\t\tpr_warn(\"Only %d pstates usable (use ACPI driver for full range\\n\",\n\t\t\tdata->batps);\n\t\tdata->numps = data->batps;\n\t}\n\n\tfor (j = 1; j < data->numps; j++) {\n\t\tif (pst[j-1].fid >= pst[j].fid) {\n\t\t\tpr_err(\"PST out of sequence\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (data->numps < 2) {\n\t\tpr_err(\"no p states to transition\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (check_pst_table(data, pst, maxvid))\n\t\treturn -EINVAL;\n\n\tpowernow_table = kzalloc((sizeof(*powernow_table)\n\t\t* (data->numps + 1)), GFP_KERNEL);\n\tif (!powernow_table)\n\t\treturn -ENOMEM;\n\n\tfor (j = 0; j < data->numps; j++) {\n\t\tint freq;\n\t\tpowernow_table[j].driver_data = pst[j].fid;  \n\t\tpowernow_table[j].driver_data |= (pst[j].vid << 8);  \n\t\tfreq = find_khz_freq_from_fid(pst[j].fid);\n\t\tpowernow_table[j].frequency = freq;\n\t}\n\tpowernow_table[data->numps].frequency = CPUFREQ_TABLE_END;\n\tpowernow_table[data->numps].driver_data = 0;\n\n\tif (query_current_values_with_pending_wait(data)) {\n\t\tkfree(powernow_table);\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"cfid 0x%x, cvid 0x%x\\n\", data->currfid, data->currvid);\n\tdata->powernow_table = powernow_table;\n\tif (cpumask_first(topology_core_cpumask(data->cpu)) == data->cpu)\n\t\tprint_basics(data);\n\n\tfor (j = 0; j < data->numps; j++)\n\t\tif ((pst[j].fid == data->currfid) &&\n\t\t    (pst[j].vid == data->currvid))\n\t\t\treturn 0;\n\n\tpr_debug(\"currfid/vid do not match PST, ignoring\\n\");\n\treturn 0;\n}\n\n \nstatic int find_psb_table(struct powernow_k8_data *data)\n{\n\tstruct psb_s *psb;\n\tunsigned int i;\n\tu32 mvs;\n\tu8 maxvid;\n\tu32 cpst = 0;\n\tu32 thiscpuid;\n\n\tfor (i = 0xc0000; i < 0xffff0; i += 0x10) {\n\t\t \n\t\t \n\n\t\tpsb = phys_to_virt(i);\n\t\tif (memcmp(psb, PSB_ID_STRING, PSB_ID_STRING_LEN) != 0)\n\t\t\tcontinue;\n\n\t\tpr_debug(\"found PSB header at 0x%p\\n\", psb);\n\n\t\tpr_debug(\"table vers: 0x%x\\n\", psb->tableversion);\n\t\tif (psb->tableversion != PSB_VERSION_1_4) {\n\t\t\tpr_err(FW_BUG \"PSB table is not v1.4\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tpr_debug(\"flags: 0x%x\\n\", psb->flags1);\n\t\tif (psb->flags1) {\n\t\t\tpr_err(FW_BUG \"unknown flags\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdata->vstable = psb->vstable;\n\t\tpr_debug(\"voltage stabilization time: %d(*20us)\\n\",\n\t\t\t\tdata->vstable);\n\n\t\tpr_debug(\"flags2: 0x%x\\n\", psb->flags2);\n\t\tdata->rvo = psb->flags2 & 3;\n\t\tdata->irt = ((psb->flags2) >> 2) & 3;\n\t\tmvs = ((psb->flags2) >> 4) & 3;\n\t\tdata->vidmvs = 1 << mvs;\n\t\tdata->batps = ((psb->flags2) >> 6) & 3;\n\n\t\tpr_debug(\"ramp voltage offset: %d\\n\", data->rvo);\n\t\tpr_debug(\"isochronous relief time: %d\\n\", data->irt);\n\t\tpr_debug(\"maximum voltage step: %d - 0x%x\\n\", mvs, data->vidmvs);\n\n\t\tpr_debug(\"numpst: 0x%x\\n\", psb->num_tables);\n\t\tcpst = psb->num_tables;\n\t\tif ((psb->cpuid == 0x00000fc0) ||\n\t\t    (psb->cpuid == 0x00000fe0)) {\n\t\t\tthiscpuid = cpuid_eax(CPUID_PROCESSOR_SIGNATURE);\n\t\t\tif ((thiscpuid == 0x00000fc0) ||\n\t\t\t    (thiscpuid == 0x00000fe0))\n\t\t\t\tcpst = 1;\n\t\t}\n\t\tif (cpst != 1) {\n\t\t\tpr_err(FW_BUG \"numpst must be 1\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tdata->plllock = psb->plllocktime;\n\t\tpr_debug(\"plllocktime: 0x%x (units 1us)\\n\", psb->plllocktime);\n\t\tpr_debug(\"maxfid: 0x%x\\n\", psb->maxfid);\n\t\tpr_debug(\"maxvid: 0x%x\\n\", psb->maxvid);\n\t\tmaxvid = psb->maxvid;\n\n\t\tdata->numps = psb->numps;\n\t\tpr_debug(\"numpstates: 0x%x\\n\", data->numps);\n\t\treturn fill_powernow_table(data,\n\t\t\t\t(struct pst_s *)(psb+1), maxvid);\n\t}\n\t \n\tpr_err(FW_BUG \"No PSB or ACPI _PSS objects\\n\");\n\tpr_err(\"Make sure that your BIOS is up to date and Cool'N'Quiet support is enabled in BIOS setup\\n\");\n\treturn -ENODEV;\n}\n\nstatic void powernow_k8_acpi_pst_values(struct powernow_k8_data *data,\n\t\tunsigned int index)\n{\n\tu64 control;\n\n\tif (!data->acpi_data.state_count)\n\t\treturn;\n\n\tcontrol = data->acpi_data.states[index].control;\n\tdata->irt = (control >> IRT_SHIFT) & IRT_MASK;\n\tdata->rvo = (control >> RVO_SHIFT) & RVO_MASK;\n\tdata->exttype = (control >> EXT_TYPE_SHIFT) & EXT_TYPE_MASK;\n\tdata->plllock = (control >> PLL_L_SHIFT) & PLL_L_MASK;\n\tdata->vidmvs = 1 << ((control >> MVS_SHIFT) & MVS_MASK);\n\tdata->vstable = (control >> VST_SHIFT) & VST_MASK;\n}\n\nstatic int powernow_k8_cpu_init_acpi(struct powernow_k8_data *data)\n{\n\tstruct cpufreq_frequency_table *powernow_table;\n\tint ret_val = -ENODEV;\n\tu64 control, status;\n\n\tif (acpi_processor_register_performance(&data->acpi_data, data->cpu)) {\n\t\tpr_debug(\"register performance failed: bad ACPI data\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (data->acpi_data.state_count <= 1) {\n\t\tpr_debug(\"No ACPI P-States\\n\");\n\t\tgoto err_out;\n\t}\n\n\tcontrol = data->acpi_data.control_register.space_id;\n\tstatus = data->acpi_data.status_register.space_id;\n\n\tif ((control != ACPI_ADR_SPACE_FIXED_HARDWARE) ||\n\t    (status != ACPI_ADR_SPACE_FIXED_HARDWARE)) {\n\t\tpr_debug(\"Invalid control/status registers (%llx - %llx)\\n\",\n\t\t\tcontrol, status);\n\t\tgoto err_out;\n\t}\n\n\t \n\tpowernow_table = kzalloc((sizeof(*powernow_table)\n\t\t* (data->acpi_data.state_count + 1)), GFP_KERNEL);\n\tif (!powernow_table)\n\t\tgoto err_out;\n\n\t \n\tdata->numps = data->acpi_data.state_count;\n\tpowernow_k8_acpi_pst_values(data, 0);\n\n\tret_val = fill_powernow_table_fidvid(data, powernow_table);\n\tif (ret_val)\n\t\tgoto err_out_mem;\n\n\tpowernow_table[data->acpi_data.state_count].frequency =\n\t\tCPUFREQ_TABLE_END;\n\tdata->powernow_table = powernow_table;\n\n\tif (cpumask_first(topology_core_cpumask(data->cpu)) == data->cpu)\n\t\tprint_basics(data);\n\n\t \n\tacpi_processor_notify_smm(THIS_MODULE);\n\n\tif (!zalloc_cpumask_var(&data->acpi_data.shared_cpu_map, GFP_KERNEL)) {\n\t\tpr_err(\"unable to alloc powernow_k8_data cpumask\\n\");\n\t\tret_val = -ENOMEM;\n\t\tgoto err_out_mem;\n\t}\n\n\treturn 0;\n\nerr_out_mem:\n\tkfree(powernow_table);\n\nerr_out:\n\tacpi_processor_unregister_performance(data->cpu);\n\n\t \n\tdata->acpi_data.state_count = 0;\n\n\treturn ret_val;\n}\n\nstatic int fill_powernow_table_fidvid(struct powernow_k8_data *data,\n\t\tstruct cpufreq_frequency_table *powernow_table)\n{\n\tint i;\n\n\tfor (i = 0; i < data->acpi_data.state_count; i++) {\n\t\tu32 fid;\n\t\tu32 vid;\n\t\tu32 freq, index;\n\t\tu64 status, control;\n\n\t\tif (data->exttype) {\n\t\t\tstatus =  data->acpi_data.states[i].status;\n\t\t\tfid = status & EXT_FID_MASK;\n\t\t\tvid = (status >> VID_SHIFT) & EXT_VID_MASK;\n\t\t} else {\n\t\t\tcontrol =  data->acpi_data.states[i].control;\n\t\t\tfid = control & FID_MASK;\n\t\t\tvid = (control >> VID_SHIFT) & VID_MASK;\n\t\t}\n\n\t\tpr_debug(\"   %d : fid 0x%x, vid 0x%x\\n\", i, fid, vid);\n\n\t\tindex = fid | (vid<<8);\n\t\tpowernow_table[i].driver_data = index;\n\n\t\tfreq = find_khz_freq_from_fid(fid);\n\t\tpowernow_table[i].frequency = freq;\n\n\t\t \n\t\tif ((freq > (MAX_FREQ * 1000)) || (freq < (MIN_FREQ * 1000))) {\n\t\t\tpr_debug(\"invalid freq %u kHz, ignoring\\n\", freq);\n\t\t\tinvalidate_entry(powernow_table, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (vid == VID_OFF) {\n\t\t\tpr_debug(\"invalid vid %u, ignoring\\n\", vid);\n\t\t\tinvalidate_entry(powernow_table, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (freq != (data->acpi_data.states[i].core_frequency * 1000)) {\n\t\t\tpr_info(\"invalid freq entries %u kHz vs. %u kHz\\n\",\n\t\t\t\tfreq, (unsigned int)\n\t\t\t\t(data->acpi_data.states[i].core_frequency\n\t\t\t\t * 1000));\n\t\t\tinvalidate_entry(powernow_table, i);\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void powernow_k8_cpu_exit_acpi(struct powernow_k8_data *data)\n{\n\tif (data->acpi_data.state_count)\n\t\tacpi_processor_unregister_performance(data->cpu);\n\tfree_cpumask_var(data->acpi_data.shared_cpu_map);\n}\n\nstatic int get_transition_latency(struct powernow_k8_data *data)\n{\n\tint max_latency = 0;\n\tint i;\n\tfor (i = 0; i < data->acpi_data.state_count; i++) {\n\t\tint cur_latency = data->acpi_data.states[i].transition_latency\n\t\t\t+ data->acpi_data.states[i].bus_master_latency;\n\t\tif (cur_latency > max_latency)\n\t\t\tmax_latency = cur_latency;\n\t}\n\tif (max_latency == 0) {\n\t\tpr_err(FW_WARN \"Invalid zero transition latency\\n\");\n\t\tmax_latency = 1;\n\t}\n\t \n\treturn 1000 * max_latency;\n}\n\n \nstatic int transition_frequency_fidvid(struct powernow_k8_data *data,\n\t\tunsigned int index,\n\t\tstruct cpufreq_policy *policy)\n{\n\tu32 fid = 0;\n\tu32 vid = 0;\n\tint res;\n\tstruct cpufreq_freqs freqs;\n\n\tpr_debug(\"cpu %d transition to index %u\\n\", smp_processor_id(), index);\n\n\t \n\t \n\tfid = data->powernow_table[index].driver_data & 0xFF;\n\tvid = (data->powernow_table[index].driver_data & 0xFF00) >> 8;\n\n\tpr_debug(\"table matched fid 0x%x, giving vid 0x%x\\n\", fid, vid);\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn 1;\n\n\tif ((data->currvid == vid) && (data->currfid == fid)) {\n\t\tpr_debug(\"target matches current values (fid 0x%x, vid 0x%x)\\n\",\n\t\t\tfid, vid);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"cpu %d, changing to fid 0x%x, vid 0x%x\\n\",\n\t\tsmp_processor_id(), fid, vid);\n\tfreqs.old = find_khz_freq_from_fid(data->currfid);\n\tfreqs.new = find_khz_freq_from_fid(fid);\n\n\tcpufreq_freq_transition_begin(policy, &freqs);\n\tres = transition_fid_vid(data, fid, vid);\n\tcpufreq_freq_transition_end(policy, &freqs, res);\n\n\treturn res;\n}\n\nstruct powernowk8_target_arg {\n\tstruct cpufreq_policy\t\t*pol;\n\tunsigned\t\t\tnewstate;\n};\n\nstatic long powernowk8_target_fn(void *arg)\n{\n\tstruct powernowk8_target_arg *pta = arg;\n\tstruct cpufreq_policy *pol = pta->pol;\n\tunsigned newstate = pta->newstate;\n\tstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\n\tu32 checkfid;\n\tu32 checkvid;\n\tint ret;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tcheckfid = data->currfid;\n\tcheckvid = data->currvid;\n\n\tif (pending_bit_stuck()) {\n\t\tpr_err(\"failing targ, change pending bit set\\n\");\n\t\treturn -EIO;\n\t}\n\n\tpr_debug(\"targ: cpu %d, %d kHz, min %d, max %d\\n\",\n\t\tpol->cpu, data->powernow_table[newstate].frequency, pol->min,\n\t\tpol->max);\n\n\tif (query_current_values_with_pending_wait(data))\n\t\treturn -EIO;\n\n\tpr_debug(\"targ: curr fid 0x%x, vid 0x%x\\n\",\n\t\tdata->currfid, data->currvid);\n\n\tif ((checkvid != data->currvid) ||\n\t    (checkfid != data->currfid)) {\n\t\tpr_info(\"error - out of sync, fix 0x%x 0x%x, vid 0x%x 0x%x\\n\",\n\t\t       checkfid, data->currfid,\n\t\t       checkvid, data->currvid);\n\t}\n\n\tmutex_lock(&fidvid_mutex);\n\n\tpowernow_k8_acpi_pst_values(data, newstate);\n\n\tret = transition_frequency_fidvid(data, newstate, pol);\n\n\tif (ret) {\n\t\tpr_err(\"transition frequency failed\\n\");\n\t\tmutex_unlock(&fidvid_mutex);\n\t\treturn 1;\n\t}\n\tmutex_unlock(&fidvid_mutex);\n\n\tpol->cur = find_khz_freq_from_fid(data->currfid);\n\n\treturn 0;\n}\n\n \nstatic int powernowk8_target(struct cpufreq_policy *pol, unsigned index)\n{\n\tstruct powernowk8_target_arg pta = { .pol = pol, .newstate = index };\n\n\treturn work_on_cpu(pol->cpu, powernowk8_target_fn, &pta);\n}\n\nstruct init_on_cpu {\n\tstruct powernow_k8_data *data;\n\tint rc;\n};\n\nstatic void powernowk8_cpu_init_on_cpu(void *_init_on_cpu)\n{\n\tstruct init_on_cpu *init_on_cpu = _init_on_cpu;\n\n\tif (pending_bit_stuck()) {\n\t\tpr_err(\"failing init, change pending bit set\\n\");\n\t\tinit_on_cpu->rc = -ENODEV;\n\t\treturn;\n\t}\n\n\tif (query_current_values_with_pending_wait(init_on_cpu->data)) {\n\t\tinit_on_cpu->rc = -ENODEV;\n\t\treturn;\n\t}\n\n\tfidvid_msr_init();\n\n\tinit_on_cpu->rc = 0;\n}\n\n#define MISSING_PSS_MSG \\\n\tFW_BUG \"No compatible ACPI _PSS objects found.\\n\" \\\n\tFW_BUG \"First, make sure Cool'N'Quiet is enabled in the BIOS.\\n\" \\\n\tFW_BUG \"If that doesn't help, try upgrading your BIOS.\\n\"\n\n \nstatic int powernowk8_cpu_init(struct cpufreq_policy *pol)\n{\n\tstruct powernow_k8_data *data;\n\tstruct init_on_cpu init_on_cpu;\n\tint rc, cpu;\n\n\tsmp_call_function_single(pol->cpu, check_supported_cpu, &rc, 1);\n\tif (rc)\n\t\treturn -ENODEV;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->cpu = pol->cpu;\n\n\tif (powernow_k8_cpu_init_acpi(data)) {\n\t\t \n\t\tif (num_online_cpus() != 1) {\n\t\t\tpr_err_once(MISSING_PSS_MSG);\n\t\t\tgoto err_out;\n\t\t}\n\t\tif (pol->cpu != 0) {\n\t\t\tpr_err(FW_BUG \"No ACPI _PSS objects for CPU other than CPU0. Complain to your BIOS vendor.\\n\");\n\t\t\tgoto err_out;\n\t\t}\n\t\trc = find_psb_table(data);\n\t\tif (rc)\n\t\t\tgoto err_out;\n\n\t\t \n\t\tpol->cpuinfo.transition_latency = (\n\t\t\t ((data->rvo + 8) * data->vstable * VST_UNITS_20US) +\n\t\t\t ((1 << data->irt) * 30)) * 1000;\n\t} else  \n\t\tpol->cpuinfo.transition_latency = get_transition_latency(data);\n\n\t \n\tinit_on_cpu.data = data;\n\tsmp_call_function_single(data->cpu, powernowk8_cpu_init_on_cpu,\n\t\t\t\t &init_on_cpu, 1);\n\trc = init_on_cpu.rc;\n\tif (rc != 0)\n\t\tgoto err_out_exit_acpi;\n\n\tcpumask_copy(pol->cpus, topology_core_cpumask(pol->cpu));\n\tdata->available_cores = pol->cpus;\n\tpol->freq_table = data->powernow_table;\n\n\tpr_debug(\"cpu_init done, current fid 0x%x, vid 0x%x\\n\",\n\t\tdata->currfid, data->currvid);\n\n\t \n\tfor_each_cpu(cpu, pol->cpus)\n\t\tper_cpu(powernow_data, cpu) = data;\n\n\treturn 0;\n\nerr_out_exit_acpi:\n\tpowernow_k8_cpu_exit_acpi(data);\n\nerr_out:\n\tkfree(data);\n\treturn -ENODEV;\n}\n\nstatic int powernowk8_cpu_exit(struct cpufreq_policy *pol)\n{\n\tstruct powernow_k8_data *data = per_cpu(powernow_data, pol->cpu);\n\tint cpu;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tpowernow_k8_cpu_exit_acpi(data);\n\n\tkfree(data->powernow_table);\n\tkfree(data);\n\t \n\tfor_each_cpu(cpu, pol->related_cpus)\n\t\tper_cpu(powernow_data, cpu) = NULL;\n\n\treturn 0;\n}\n\nstatic void query_values_on_cpu(void *_err)\n{\n\tint *err = _err;\n\tstruct powernow_k8_data *data = __this_cpu_read(powernow_data);\n\n\t*err = query_current_values_with_pending_wait(data);\n}\n\nstatic unsigned int powernowk8_get(unsigned int cpu)\n{\n\tstruct powernow_k8_data *data = per_cpu(powernow_data, cpu);\n\tunsigned int khz = 0;\n\tint err;\n\n\tif (!data)\n\t\treturn 0;\n\n\tsmp_call_function_single(cpu, query_values_on_cpu, &err, true);\n\tif (err)\n\t\tgoto out;\n\n\tkhz = find_khz_freq_from_fid(data->currfid);\n\n\nout:\n\treturn khz;\n}\n\nstatic struct cpufreq_driver cpufreq_amd64_driver = {\n\t.flags\t\t= CPUFREQ_ASYNC_NOTIFICATION,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= powernowk8_target,\n\t.bios_limit\t= acpi_processor_get_bios_limit,\n\t.init\t\t= powernowk8_cpu_init,\n\t.exit\t\t= powernowk8_cpu_exit,\n\t.get\t\t= powernowk8_get,\n\t.name\t\t= \"powernow-k8\",\n\t.attr\t\t= cpufreq_generic_attr,\n};\n\nstatic void __request_acpi_cpufreq(void)\n{\n\tconst char drv[] = \"acpi-cpufreq\";\n\tconst char *cur_drv;\n\n\tcur_drv = cpufreq_get_current_driver();\n\tif (!cur_drv)\n\t\tgoto request;\n\n\tif (strncmp(cur_drv, drv, min_t(size_t, strlen(cur_drv), strlen(drv))))\n\t\tpr_warn(\"WTF driver: %s\\n\", cur_drv);\n\n\treturn;\n\n request:\n\tpr_warn(\"This CPU is not supported anymore, using acpi-cpufreq instead.\\n\");\n\trequest_module(drv);\n}\n\n \nstatic int powernowk8_init(void)\n{\n\tunsigned int i, supported_cpus = 0;\n\tint ret;\n\n\tif (!x86_match_cpu(powernow_k8_ids))\n\t\treturn -ENODEV;\n\n\tif (boot_cpu_has(X86_FEATURE_HW_PSTATE)) {\n\t\t__request_acpi_cpufreq();\n\t\treturn -ENODEV;\n\t}\n\n\tcpus_read_lock();\n\tfor_each_online_cpu(i) {\n\t\tsmp_call_function_single(i, check_supported_cpu, &ret, 1);\n\t\tif (!ret)\n\t\t\tsupported_cpus++;\n\t}\n\n\tif (supported_cpus != num_online_cpus()) {\n\t\tcpus_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\tcpus_read_unlock();\n\n\tret = cpufreq_register_driver(&cpufreq_amd64_driver);\n\tif (ret)\n\t\treturn ret;\n\n\tpr_info(\"Found %d %s (%d cpu cores) (\" VERSION \")\\n\",\n\t\tnum_online_nodes(), boot_cpu_data.x86_model_id, supported_cpus);\n\n\treturn ret;\n}\n\n \nstatic void __exit powernowk8_exit(void)\n{\n\tpr_debug(\"exit\\n\");\n\n\tcpufreq_unregister_driver(&cpufreq_amd64_driver);\n}\n\nMODULE_AUTHOR(\"Paul Devriendt <paul.devriendt@amd.com>\");\nMODULE_AUTHOR(\"Mark Langsdorf <mark.langsdorf@amd.com>\");\nMODULE_DESCRIPTION(\"AMD Athlon 64 and Opteron processor frequency driver.\");\nMODULE_LICENSE(\"GPL\");\n\nlate_initcall(powernowk8_init);\nmodule_exit(powernowk8_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}