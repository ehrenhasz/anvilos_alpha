{
  "module_name": "sa1110-cpufreq.c",
  "hash_id": "0a3147b999f586f84135367406bd12b00d008835047dd330d5272bd8bd8799a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/cpufreq/sa1110-cpufreq.c",
  "human_readable_source": "\n \n#include <linux/cpufreq.h>\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/types.h>\n\n#include <asm/cputype.h>\n#include <asm/mach-types.h>\n\n#include <mach/generic.h>\n#include <mach/hardware.h>\n\n#undef DEBUG\n\nstruct sdram_params {\n\tconst char name[20];\n\tu_char  rows;\t\t \n\tu_char  cas_latency;\t \n\tu_char  tck;\t\t \n\tu_char  trcd;\t\t \n\tu_char  trp;\t\t \n\tu_char  twr;\t\t \n\tu_short refresh;\t \n};\n\nstruct sdram_info {\n\tu_int\tmdcnfg;\n\tu_int\tmdrefr;\n\tu_int\tmdcas[3];\n};\n\nstatic struct sdram_params sdram_tbl[] __initdata = {\n\t{\t \n\t\t.name\t\t= \"TC59SM716-CL2\",\n\t\t.rows\t\t= 12,\n\t\t.tck\t\t= 10,\n\t\t.trcd\t\t= 20,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 10,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 2,\n\t}, {\t \n\t\t.name\t\t= \"TC59SM716-CL3\",\n\t\t.rows\t\t= 12,\n\t\t.tck\t\t= 8,\n\t\t.trcd\t\t= 20,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 8,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t}, {\t \n\t\t.name\t\t= \"K4S641632D\",\n\t\t.rows\t\t= 14,\n\t\t.tck\t\t= 9,\n\t\t.trcd\t\t= 27,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 9,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t}, {\t \n\t\t.name           = \"K4S281632B-1H\",\n\t\t.rows\t\t= 12,\n\t\t.tck\t\t= 10,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 10,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t}, {\t \n\t\t.name\t\t= \"KM416S4030CT\",\n\t\t.rows\t\t= 13,\n\t\t.tck\t\t= 8,\n\t\t.trcd\t\t= 24,\t \n\t\t.trp\t\t= 24,\t \n\t\t.twr\t\t= 16,\t \n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t}, {\t \n\t\t.name\t\t= \"W982516AH75L\",\n\t\t.rows\t\t= 16,\n\t\t.tck\t\t= 8,\n\t\t.trcd\t\t= 20,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 8,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t}, {\t \n\t\t.name\t\t= \"MT48LC8M16A2TG-75\",\n\t\t.rows\t\t= 12,\n\t\t.tck\t\t= 8,\n\t\t.trcd\t\t= 20,\n\t\t.trp\t\t= 20,\n\t\t.twr\t\t= 8,\n\t\t.refresh\t= 64000,\n\t\t.cas_latency\t= 3,\n\t},\n};\n\nstatic struct sdram_params sdram_params;\n\n \nstatic inline u_int ns_to_cycles(u_int ns, u_int khz)\n{\n\treturn (ns * khz + 999999) / 1000000;\n}\n\n \nstatic inline void set_mdcas(u_int *mdcas, int delayed, u_int rcd)\n{\n\tu_int shift;\n\n\trcd = 2 * rcd - 1;\n\tshift = delayed + 1 + rcd;\n\n\tmdcas[0]  = (1 << rcd) - 1;\n\tmdcas[0] |= 0x55555555 << shift;\n\tmdcas[1]  = mdcas[2] = 0x55555555 << (shift & 1);\n}\n\nstatic void\nsdram_calculate_timing(struct sdram_info *sd, u_int cpu_khz,\n\t\t       struct sdram_params *sdram)\n{\n\tu_int mem_khz, sd_khz, trp, twr;\n\n\tmem_khz = cpu_khz / 2;\n\tsd_khz = mem_khz;\n\n\t \n\tif ((ns_to_cycles(sdram->tck, sd_khz) > 1) ||\n\t    (read_cpuid_revision() < ARM_CPU_REV_SA1110_B2 && sd_khz < 62000))\n\t\tsd_khz /= 2;\n\n\tsd->mdcnfg = MDCNFG & 0x007f007f;\n\n\ttwr = ns_to_cycles(sdram->twr, mem_khz);\n\n\t \n\ttrp = ns_to_cycles(sdram->trp, mem_khz) - 1;\n\tif (trp < 1)\n\t\ttrp = 1;\n\n\tsd->mdcnfg |= trp << 8;\n\tsd->mdcnfg |= trp << 24;\n\tsd->mdcnfg |= sdram->cas_latency << 12;\n\tsd->mdcnfg |= sdram->cas_latency << 28;\n\tsd->mdcnfg |= twr << 14;\n\tsd->mdcnfg |= twr << 30;\n\n\tsd->mdrefr = MDREFR & 0xffbffff0;\n\tsd->mdrefr |= 7;\n\n\tif (sd_khz != mem_khz)\n\t\tsd->mdrefr |= MDREFR_K1DB2;\n\n\t \n\tset_mdcas(sd->mdcas, sd_khz >= 62000,\n\t\tns_to_cycles(sdram->trcd, mem_khz));\n\n#ifdef DEBUG\n\tprintk(KERN_DEBUG \"MDCNFG: %08x MDREFR: %08x MDCAS0: %08x MDCAS1: %08x MDCAS2: %08x\\n\",\n\t\tsd->mdcnfg, sd->mdrefr, sd->mdcas[0], sd->mdcas[1],\n\t\tsd->mdcas[2]);\n#endif\n}\n\n \nstatic inline void sdram_set_refresh(u_int dri)\n{\n\tMDREFR = (MDREFR & 0xffff000f) | (dri << 4);\n\t(void) MDREFR;\n}\n\n \nstatic void\nsdram_update_refresh(u_int cpu_khz, struct sdram_params *sdram)\n{\n\tu_int ns_row = (sdram->refresh * 1000) >> sdram->rows;\n\tu_int dri = ns_to_cycles(ns_row, cpu_khz / 2) / 32;\n\n#ifdef DEBUG\n\tmdelay(250);\n\tprintk(KERN_DEBUG \"new dri value = %d\\n\", dri);\n#endif\n\n\tsdram_set_refresh(dri);\n}\n\n \nstatic int sa1110_target(struct cpufreq_policy *policy, unsigned int ppcr)\n{\n\tstruct sdram_params *sdram = &sdram_params;\n\tstruct sdram_info sd;\n\tunsigned long flags;\n\tunsigned int unused;\n\n\tsdram_calculate_timing(&sd, sa11x0_freq_table[ppcr].frequency, sdram);\n\n#if 0\n\t \n\tif (policy->max < 147500) {\n\t\tsd.mdrefr |= MDREFR_K1DB2;\n\t\tsd.mdcas[0] = 0xaaaaaa7f;\n\t} else {\n\t\tsd.mdrefr &= ~MDREFR_K1DB2;\n\t\tsd.mdcas[0] = 0xaaaaaa9f;\n\t}\n\tsd.mdcas[1] = 0xaaaaaaaa;\n\tsd.mdcas[2] = 0xaaaaaaaa;\n#endif\n\n\t \n\tsdram_set_refresh(2);\n\tif (!irqs_disabled())\n\t\tmsleep(20);\n\telse\n\t\tmdelay(20);\n\n\t \n\tlocal_irq_save(flags);\n\tasm(\"mcr p15, 0, %0, c7, c10, 4\" : : \"r\" (0));\n\tudelay(10);\n\t__asm__ __volatile__(\"\\n\\\n\t\tb\t2f\t\t\t\t\t\\n\\\n\t\t.align\t5\t\t\t\t\t\\n\\\n1:\t\tstr\t%3, [%1, #0]\t\t@ MDCNFG\t\\n\\\n\t\tstr\t%4, [%1, #28]\t\t@ MDREFR\t\\n\\\n\t\tstr\t%5, [%1, #4]\t\t@ MDCAS0\t\\n\\\n\t\tstr\t%6, [%1, #8]\t\t@ MDCAS1\t\\n\\\n\t\tstr\t%7, [%1, #12]\t\t@ MDCAS2\t\\n\\\n\t\tstr\t%8, [%2, #0]\t\t@ PPCR\t\t\\n\\\n\t\tldr\t%0, [%1, #0]\t\t\t\t\\n\\\n\t\tb\t3f\t\t\t\t\t\\n\\\n2:\t\tb\t1b\t\t\t\t\t\\n\\\n3:\t\tnop\t\t\t\t\t\t\\n\\\n\t\tnop\"\n\t\t: \"=&r\" (unused)\n\t\t: \"r\" (&MDCNFG), \"r\" (&PPCR), \"0\" (sd.mdcnfg),\n\t\t  \"r\" (sd.mdrefr), \"r\" (sd.mdcas[0]),\n\t\t  \"r\" (sd.mdcas[1]), \"r\" (sd.mdcas[2]), \"r\" (ppcr));\n\tlocal_irq_restore(flags);\n\n\t/*\n\t * Now, return the SDRAM refresh back to normal.\n\t */\n\tsdram_update_refresh(sa11x0_freq_table[ppcr].frequency, sdram);\n\n\treturn 0;\n}\n\nstatic int __init sa1110_cpu_init(struct cpufreq_policy *policy)\n{\n\tcpufreq_generic_init(policy, sa11x0_freq_table, 0);\n\treturn 0;\n}\n\n/* sa1110_driver needs __refdata because it must remain after init registers\n * it with cpufreq_register_driver() */\nstatic struct cpufreq_driver sa1110_driver __refdata = {\n\t.flags\t\t= CPUFREQ_NEED_INITIAL_FREQ_CHECK |\n\t\t\t  CPUFREQ_NO_AUTO_DYNAMIC_SWITCHING,\n\t.verify\t\t= cpufreq_generic_frequency_table_verify,\n\t.target_index\t= sa1110_target,\n\t.get\t\t= sa11x0_getspeed,\n\t.init\t\t= sa1110_cpu_init,\n\t.name\t\t= \"sa1110\",\n};\n\nstatic struct sdram_params *sa1110_find_sdram(const char *name)\n{\n\tstruct sdram_params *sdram;\n\n\tfor (sdram = sdram_tbl; sdram < sdram_tbl + ARRAY_SIZE(sdram_tbl);\n\t     sdram++)\n\t\tif (strcmp(name, sdram->name) == 0)\n\t\t\treturn sdram;\n\n\treturn NULL;\n}\n\nstatic char sdram_name[16];\n\nstatic int __init sa1110_clk_init(void)\n{\n\tstruct sdram_params *sdram;\n\tconst char *name = sdram_name;\n\n\tif (!cpu_is_sa1110())\n\t\treturn -ENODEV;\n\n\tif (!name[0]) {\n\t\tif (machine_is_assabet())\n\t\t\tname = \"TC59SM716-CL3\";\n\t\tif (machine_is_jornada720() || machine_is_h3600())\n\t\t\tname = \"K4S281632B-1H\";\n\t}\n\n\tsdram = sa1110_find_sdram(name);\n\tif (sdram) {\n\t\tprintk(KERN_DEBUG \"SDRAM: tck: %d trcd: %d trp: %d\"\n\t\t\t\" twr: %d refresh: %d cas_latency: %d\\n\",\n\t\t\tsdram->tck, sdram->trcd, sdram->trp,\n\t\t\tsdram->twr, sdram->refresh, sdram->cas_latency);\n\n\t\tmemcpy(&sdram_params, sdram, sizeof(sdram_params));\n\n\t\treturn cpufreq_register_driver(&sa1110_driver);\n\t}\n\n\treturn 0;\n}\n\nmodule_param_string(sdram, sdram_name, sizeof(sdram_name), 0);\narch_initcall(sa1110_clk_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}