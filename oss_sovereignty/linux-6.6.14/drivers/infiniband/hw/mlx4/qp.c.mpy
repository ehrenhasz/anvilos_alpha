{
  "module_name": "qp.c",
  "hash_id": "d5f939c0a5b3af27aca2c2f7c13ada6e2fdab0015f5c90c1c3df056324d241b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx4/qp.c",
  "human_readable_source": " \n\n#include <linux/log2.h>\n#include <linux/etherdevice.h>\n#include <net/ip.h>\n#include <linux/slab.h>\n#include <linux/netdevice.h>\n\n#include <rdma/ib_cache.h>\n#include <rdma/ib_pack.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_mad.h>\n#include <rdma/uverbs_ioctl.h>\n\n#include <linux/mlx4/driver.h>\n#include <linux/mlx4/qp.h>\n\n#include \"mlx4_ib.h\"\n#include <rdma/mlx4-abi.h>\n\nstatic void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq,\n\t\t\t     struct mlx4_ib_cq *recv_cq);\nstatic void mlx4_ib_unlock_cqs(struct mlx4_ib_cq *send_cq,\n\t\t\t       struct mlx4_ib_cq *recv_cq);\nstatic int _mlx4_ib_modify_wq(struct ib_wq *ibwq, enum ib_wq_state new_state,\n\t\t\t      struct ib_udata *udata);\n\nenum {\n\tMLX4_IB_ACK_REQ_FREQ\t= 8,\n};\n\nenum {\n\tMLX4_IB_DEFAULT_SCHED_QUEUE\t= 0x83,\n\tMLX4_IB_DEFAULT_QP0_SCHED_QUEUE\t= 0x3f,\n\tMLX4_IB_LINK_TYPE_IB\t\t= 0,\n\tMLX4_IB_LINK_TYPE_ETH\t\t= 1\n};\n\nenum {\n\tMLX4_IB_MIN_SQ_STRIDE\t= 6,\n\tMLX4_IB_CACHE_LINE_SIZE\t= 64,\n};\n\nenum {\n\tMLX4_RAW_QP_MTU\t\t= 7,\n\tMLX4_RAW_QP_MSGMAX\t= 31,\n};\n\n#ifndef ETH_ALEN\n#define ETH_ALEN        6\n#endif\n\nstatic const __be32 mlx4_ib_opcode[] = {\n\t[IB_WR_SEND]\t\t\t\t= cpu_to_be32(MLX4_OPCODE_SEND),\n\t[IB_WR_LSO]\t\t\t\t= cpu_to_be32(MLX4_OPCODE_LSO),\n\t[IB_WR_SEND_WITH_IMM]\t\t\t= cpu_to_be32(MLX4_OPCODE_SEND_IMM),\n\t[IB_WR_RDMA_WRITE]\t\t\t= cpu_to_be32(MLX4_OPCODE_RDMA_WRITE),\n\t[IB_WR_RDMA_WRITE_WITH_IMM]\t\t= cpu_to_be32(MLX4_OPCODE_RDMA_WRITE_IMM),\n\t[IB_WR_RDMA_READ]\t\t\t= cpu_to_be32(MLX4_OPCODE_RDMA_READ),\n\t[IB_WR_ATOMIC_CMP_AND_SWP]\t\t= cpu_to_be32(MLX4_OPCODE_ATOMIC_CS),\n\t[IB_WR_ATOMIC_FETCH_AND_ADD]\t\t= cpu_to_be32(MLX4_OPCODE_ATOMIC_FA),\n\t[IB_WR_SEND_WITH_INV]\t\t\t= cpu_to_be32(MLX4_OPCODE_SEND_INVAL),\n\t[IB_WR_LOCAL_INV]\t\t\t= cpu_to_be32(MLX4_OPCODE_LOCAL_INVAL),\n\t[IB_WR_REG_MR]\t\t\t\t= cpu_to_be32(MLX4_OPCODE_FMR),\n\t[IB_WR_MASKED_ATOMIC_CMP_AND_SWP]\t= cpu_to_be32(MLX4_OPCODE_MASKED_ATOMIC_CS),\n\t[IB_WR_MASKED_ATOMIC_FETCH_AND_ADD]\t= cpu_to_be32(MLX4_OPCODE_MASKED_ATOMIC_FA),\n};\n\nenum mlx4_ib_source_type {\n\tMLX4_IB_QP_SRC\t= 0,\n\tMLX4_IB_RWQ_SRC\t= 1,\n};\n\nstruct mlx4_ib_qp_event_work {\n\tstruct work_struct work;\n\tstruct mlx4_qp *qp;\n\tenum mlx4_event type;\n};\n\nstatic struct workqueue_struct *mlx4_ib_qp_event_wq;\n\nstatic int is_tunnel_qp(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tif (!mlx4_is_master(dev->dev))\n\t\treturn 0;\n\n\treturn qp->mqp.qpn >= dev->dev->phys_caps.base_tunnel_sqpn &&\n\t       qp->mqp.qpn < dev->dev->phys_caps.base_tunnel_sqpn +\n\t\t8 * MLX4_MFUNC_MAX;\n}\n\nstatic int is_sqp(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tint proxy_sqp = 0;\n\tint real_sqp = 0;\n\tint i;\n\t \n\treal_sqp = ((mlx4_is_master(dev->dev) || !mlx4_is_mfunc(dev->dev)) &&\n\t\t    qp->mqp.qpn >= dev->dev->phys_caps.base_sqpn &&\n\t\t    qp->mqp.qpn <= dev->dev->phys_caps.base_sqpn + 3);\n\tif (real_sqp)\n\t\treturn 1;\n\t \n\tif (mlx4_is_mfunc(dev->dev)) {\n\t\tfor (i = 0; i < dev->dev->caps.num_ports; i++) {\n\t\t\tif (qp->mqp.qpn == dev->dev->caps.spec_qps[i].qp0_proxy ||\n\t\t\t    qp->mqp.qpn == dev->dev->caps.spec_qps[i].qp1_proxy) {\n\t\t\t\tproxy_sqp = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (proxy_sqp)\n\t\treturn 1;\n\n\treturn !!(qp->flags & MLX4_IB_ROCE_V2_GSI_QP);\n}\n\n \nstatic int is_qp0(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tint proxy_qp0 = 0;\n\tint real_qp0 = 0;\n\tint i;\n\t \n\treal_qp0 = ((mlx4_is_master(dev->dev) || !mlx4_is_mfunc(dev->dev)) &&\n\t\t    qp->mqp.qpn >= dev->dev->phys_caps.base_sqpn &&\n\t\t    qp->mqp.qpn <= dev->dev->phys_caps.base_sqpn + 1);\n\tif (real_qp0)\n\t\treturn 1;\n\t \n\tif (mlx4_is_mfunc(dev->dev)) {\n\t\tfor (i = 0; i < dev->dev->caps.num_ports; i++) {\n\t\t\tif (qp->mqp.qpn == dev->dev->caps.spec_qps[i].qp0_proxy) {\n\t\t\t\tproxy_qp0 = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn proxy_qp0;\n}\n\nstatic void *get_wqe(struct mlx4_ib_qp *qp, int offset)\n{\n\treturn mlx4_buf_offset(&qp->buf, offset);\n}\n\nstatic void *get_recv_wqe(struct mlx4_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->rq.offset + (n << qp->rq.wqe_shift));\n}\n\nstatic void *get_send_wqe(struct mlx4_ib_qp *qp, int n)\n{\n\treturn get_wqe(qp, qp->sq.offset + (n << qp->sq.wqe_shift));\n}\n\n \nstatic void stamp_send_wqe(struct mlx4_ib_qp *qp, int n)\n{\n\t__be32 *wqe;\n\tint i;\n\tint s;\n\tvoid *buf;\n\tstruct mlx4_wqe_ctrl_seg *ctrl;\n\n\tbuf = get_send_wqe(qp, n & (qp->sq.wqe_cnt - 1));\n\tctrl = (struct mlx4_wqe_ctrl_seg *)buf;\n\ts = (ctrl->qpn_vlan.fence_size & 0x3f) << 4;\n\tfor (i = 64; i < s; i += 64) {\n\t\twqe = buf + i;\n\t\t*wqe = cpu_to_be32(0xffffffff);\n\t}\n}\n\nstatic void mlx4_ib_handle_qp_event(struct work_struct *_work)\n{\n\tstruct mlx4_ib_qp_event_work *qpe_work =\n\t\tcontainer_of(_work, struct mlx4_ib_qp_event_work, work);\n\tstruct ib_qp *ibqp = &to_mibqp(qpe_work->qp)->ibqp;\n\tstruct ib_event event = {};\n\n\tevent.device = ibqp->device;\n\tevent.element.qp = ibqp;\n\n\tswitch (qpe_work->type) {\n\tcase MLX4_EVENT_TYPE_PATH_MIG:\n\t\tevent.event = IB_EVENT_PATH_MIG;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_COMM_EST:\n\t\tevent.event = IB_EVENT_COMM_EST;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_SQ_DRAINED:\n\t\tevent.event = IB_EVENT_SQ_DRAINED;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE:\n\t\tevent.event = IB_EVENT_QP_LAST_WQE_REACHED;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\tevent.event = IB_EVENT_QP_FATAL;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_PATH_MIG_FAILED:\n\t\tevent.event = IB_EVENT_PATH_MIG_ERR;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\tevent.event = IB_EVENT_QP_REQ_ERR;\n\t\tbreak;\n\tcase MLX4_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\tevent.event = IB_EVENT_QP_ACCESS_ERR;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unexpected event type %d on QP %06x\\n\",\n\t\t\tqpe_work->type, qpe_work->qp->qpn);\n\t\tgoto out;\n\t}\n\n\tibqp->event_handler(&event, ibqp->qp_context);\n\nout:\n\tmlx4_put_qp(qpe_work->qp);\n\tkfree(qpe_work);\n}\n\nstatic void mlx4_ib_qp_event(struct mlx4_qp *qp, enum mlx4_event type)\n{\n\tstruct ib_qp *ibqp = &to_mibqp(qp)->ibqp;\n\tstruct mlx4_ib_qp_event_work *qpe_work;\n\n\tif (type == MLX4_EVENT_TYPE_PATH_MIG)\n\t\tto_mibqp(qp)->port = to_mibqp(qp)->alt_port;\n\n\tif (!ibqp->event_handler)\n\t\tgoto out_no_handler;\n\n\tqpe_work = kzalloc(sizeof(*qpe_work), GFP_ATOMIC);\n\tif (!qpe_work)\n\t\tgoto out_no_handler;\n\n\tqpe_work->qp = qp;\n\tqpe_work->type = type;\n\tINIT_WORK(&qpe_work->work, mlx4_ib_handle_qp_event);\n\tqueue_work(mlx4_ib_qp_event_wq, &qpe_work->work);\n\treturn;\n\nout_no_handler:\n\tmlx4_put_qp(qp);\n}\n\nstatic void mlx4_ib_wq_event(struct mlx4_qp *qp, enum mlx4_event type)\n{\n\tpr_warn_ratelimited(\"Unexpected event type %d on WQ 0x%06x. Events are not supported for WQs\\n\",\n\t\t\t    type, qp->qpn);\n}\n\nstatic int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)\n{\n\t \n\tswitch (type) {\n\tcase MLX4_IB_QPT_UD:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tsizeof (struct mlx4_wqe_datagram_seg) +\n\t\t\t((flags & MLX4_IB_QP_LSO) ? MLX4_IB_LSO_HEADER_SPARE : 0);\n\tcase MLX4_IB_QPT_PROXY_SMI_OWNER:\n\tcase MLX4_IB_QPT_PROXY_SMI:\n\tcase MLX4_IB_QPT_PROXY_GSI:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tsizeof (struct mlx4_wqe_datagram_seg) + 64;\n\tcase MLX4_IB_QPT_TUN_SMI_OWNER:\n\tcase MLX4_IB_QPT_TUN_GSI:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tsizeof (struct mlx4_wqe_datagram_seg);\n\n\tcase MLX4_IB_QPT_UC:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tsizeof (struct mlx4_wqe_raddr_seg);\n\tcase MLX4_IB_QPT_RC:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tsizeof (struct mlx4_wqe_masked_atomic_seg) +\n\t\t\tsizeof (struct mlx4_wqe_raddr_seg);\n\tcase MLX4_IB_QPT_SMI:\n\tcase MLX4_IB_QPT_GSI:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg) +\n\t\t\tALIGN(MLX4_IB_UD_HEADER_SIZE +\n\t\t\t      DIV_ROUND_UP(MLX4_IB_UD_HEADER_SIZE,\n\t\t\t\t\t   MLX4_INLINE_ALIGN) *\n\t\t\t      sizeof (struct mlx4_wqe_inline_seg),\n\t\t\t      sizeof (struct mlx4_wqe_data_seg)) +\n\t\t\tALIGN(4 +\n\t\t\t      sizeof (struct mlx4_wqe_inline_seg),\n\t\t\t      sizeof (struct mlx4_wqe_data_seg));\n\tdefault:\n\t\treturn sizeof (struct mlx4_wqe_ctrl_seg);\n\t}\n}\n\nstatic int set_rq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,\n\t\t       bool is_user, bool has_rq, struct mlx4_ib_qp *qp,\n\t\t       u32 inl_recv_sz)\n{\n\t \n\tif (cap->max_recv_wr > dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE ||\n\t    cap->max_recv_sge > min(dev->dev->caps.max_sq_sg, dev->dev->caps.max_rq_sg))\n\t\treturn -EINVAL;\n\n\tif (!has_rq) {\n\t\tif (cap->max_recv_wr || inl_recv_sz)\n\t\t\treturn -EINVAL;\n\n\t\tqp->rq.wqe_cnt = qp->rq.max_gs = 0;\n\t} else {\n\t\tu32 max_inl_recv_sz = dev->dev->caps.max_rq_sg *\n\t\t\tsizeof(struct mlx4_wqe_data_seg);\n\t\tu32 wqe_size;\n\n\t\t \n\t\tif (is_user && (!cap->max_recv_wr || !cap->max_recv_sge ||\n\t\t\t\tinl_recv_sz > max_inl_recv_sz))\n\t\t\treturn -EINVAL;\n\n\t\tqp->rq.wqe_cnt\t = roundup_pow_of_two(max(1U, cap->max_recv_wr));\n\t\tqp->rq.max_gs\t = roundup_pow_of_two(max(1U, cap->max_recv_sge));\n\t\twqe_size = qp->rq.max_gs * sizeof(struct mlx4_wqe_data_seg);\n\t\tqp->rq.wqe_shift = ilog2(max_t(u32, wqe_size, inl_recv_sz));\n\t}\n\n\t \n\tif (is_user) {\n\t\tcap->max_recv_wr  = qp->rq.max_post = qp->rq.wqe_cnt;\n\t\tcap->max_recv_sge = qp->rq.max_gs;\n\t} else {\n\t\tcap->max_recv_wr  = qp->rq.max_post =\n\t\t\tmin(dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE, qp->rq.wqe_cnt);\n\t\tcap->max_recv_sge = min(qp->rq.max_gs,\n\t\t\t\t\tmin(dev->dev->caps.max_sq_sg,\n\t\t\t\t\t    dev->dev->caps.max_rq_sg));\n\t}\n\n\treturn 0;\n}\n\nstatic int set_kernel_sq_size(struct mlx4_ib_dev *dev, struct ib_qp_cap *cap,\n\t\t\t      enum mlx4_ib_qp_type type, struct mlx4_ib_qp *qp)\n{\n\tint s;\n\n\t \n\tif (cap->max_send_wr  > (dev->dev->caps.max_wqes - MLX4_IB_SQ_MAX_SPARE) ||\n\t    cap->max_send_sge > min(dev->dev->caps.max_sq_sg, dev->dev->caps.max_rq_sg) ||\n\t    cap->max_inline_data + send_wqe_overhead(type, qp->flags) +\n\t    sizeof (struct mlx4_wqe_inline_seg) > dev->dev->caps.max_sq_desc_sz)\n\t\treturn -EINVAL;\n\n\t \n\tif ((type == MLX4_IB_QPT_SMI || type == MLX4_IB_QPT_GSI ||\n\t     type & (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER)) &&\n\t    cap->max_send_sge + 2 > dev->dev->caps.max_sq_sg)\n\t\treturn -EINVAL;\n\n\ts = max(cap->max_send_sge * sizeof (struct mlx4_wqe_data_seg),\n\t\tcap->max_inline_data + sizeof (struct mlx4_wqe_inline_seg)) +\n\t\tsend_wqe_overhead(type, qp->flags);\n\n\tif (s > dev->dev->caps.max_sq_desc_sz)\n\t\treturn -EINVAL;\n\n\tqp->sq.wqe_shift = ilog2(roundup_pow_of_two(s));\n\n\t \n\tqp->sq_spare_wqes = MLX4_IB_SQ_HEADROOM(qp->sq.wqe_shift);\n\tqp->sq.wqe_cnt = roundup_pow_of_two(cap->max_send_wr +\n\t\t\t\t\t    qp->sq_spare_wqes);\n\n\tqp->sq.max_gs =\n\t\t(min(dev->dev->caps.max_sq_desc_sz,\n\t\t     (1 << qp->sq.wqe_shift)) -\n\t\t send_wqe_overhead(type, qp->flags)) /\n\t\tsizeof (struct mlx4_wqe_data_seg);\n\n\tqp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t(qp->sq.wqe_cnt << qp->sq.wqe_shift);\n\tif (qp->rq.wqe_shift > qp->sq.wqe_shift) {\n\t\tqp->rq.offset = 0;\n\t\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t} else {\n\t\tqp->rq.offset = qp->sq.wqe_cnt << qp->sq.wqe_shift;\n\t\tqp->sq.offset = 0;\n\t}\n\n\tcap->max_send_wr  = qp->sq.max_post =\n\t\tqp->sq.wqe_cnt - qp->sq_spare_wqes;\n\tcap->max_send_sge = min(qp->sq.max_gs,\n\t\t\t\tmin(dev->dev->caps.max_sq_sg,\n\t\t\t\t    dev->dev->caps.max_rq_sg));\n\t \n\tcap->max_inline_data = 0;\n\n\treturn 0;\n}\n\nstatic int set_user_sq_size(struct mlx4_ib_dev *dev,\n\t\t\t    struct mlx4_ib_qp *qp,\n\t\t\t    struct mlx4_ib_create_qp *ucmd)\n{\n\tu32 cnt;\n\n\t \n\tif (check_shl_overflow(1, ucmd->log_sq_bb_count, &cnt) ||\n\t    cnt > dev->dev->caps.max_wqes)\n\t\treturn -EINVAL;\n\tif (ucmd->log_sq_stride >\n\t\tilog2(roundup_pow_of_two(dev->dev->caps.max_sq_desc_sz)) ||\n\t    ucmd->log_sq_stride < MLX4_IB_MIN_SQ_STRIDE)\n\t\treturn -EINVAL;\n\n\tqp->sq.wqe_cnt   = 1 << ucmd->log_sq_bb_count;\n\tqp->sq.wqe_shift = ucmd->log_sq_stride;\n\n\tqp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t(qp->sq.wqe_cnt << qp->sq.wqe_shift);\n\n\treturn 0;\n}\n\nstatic int alloc_proxy_bufs(struct ib_device *dev, struct mlx4_ib_qp *qp)\n{\n\tint i;\n\n\tqp->sqp_proxy_rcv =\n\t\tkmalloc_array(qp->rq.wqe_cnt, sizeof(struct mlx4_ib_buf),\n\t\t\t      GFP_KERNEL);\n\tif (!qp->sqp_proxy_rcv)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < qp->rq.wqe_cnt; i++) {\n\t\tqp->sqp_proxy_rcv[i].addr =\n\t\t\tkmalloc(sizeof (struct mlx4_ib_proxy_sqp_hdr),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qp->sqp_proxy_rcv[i].addr)\n\t\t\tgoto err;\n\t\tqp->sqp_proxy_rcv[i].map =\n\t\t\tib_dma_map_single(dev, qp->sqp_proxy_rcv[i].addr,\n\t\t\t\t\t  sizeof (struct mlx4_ib_proxy_sqp_hdr),\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\t\tif (ib_dma_mapping_error(dev, qp->sqp_proxy_rcv[i].map)) {\n\t\t\tkfree(qp->sqp_proxy_rcv[i].addr);\n\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\n\nerr:\n\twhile (i > 0) {\n\t\t--i;\n\t\tib_dma_unmap_single(dev, qp->sqp_proxy_rcv[i].map,\n\t\t\t\t    sizeof (struct mlx4_ib_proxy_sqp_hdr),\n\t\t\t\t    DMA_FROM_DEVICE);\n\t\tkfree(qp->sqp_proxy_rcv[i].addr);\n\t}\n\tkfree(qp->sqp_proxy_rcv);\n\tqp->sqp_proxy_rcv = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void free_proxy_bufs(struct ib_device *dev, struct mlx4_ib_qp *qp)\n{\n\tint i;\n\n\tfor (i = 0; i < qp->rq.wqe_cnt; i++) {\n\t\tib_dma_unmap_single(dev, qp->sqp_proxy_rcv[i].map,\n\t\t\t\t    sizeof (struct mlx4_ib_proxy_sqp_hdr),\n\t\t\t\t    DMA_FROM_DEVICE);\n\t\tkfree(qp->sqp_proxy_rcv[i].addr);\n\t}\n\tkfree(qp->sqp_proxy_rcv);\n}\n\nstatic bool qp_has_rq(struct ib_qp_init_attr *attr)\n{\n\tif (attr->qp_type == IB_QPT_XRC_INI || attr->qp_type == IB_QPT_XRC_TGT)\n\t\treturn false;\n\n\treturn !attr->srq;\n}\n\nstatic int qp0_enabled_vf(struct mlx4_dev *dev, int qpn)\n{\n\tint i;\n\tfor (i = 0; i < dev->caps.num_ports; i++) {\n\t\tif (qpn == dev->caps.spec_qps[i].qp0_proxy)\n\t\t\treturn !!dev->caps.spec_qps[i].qp0_qkey;\n\t}\n\treturn 0;\n}\n\nstatic void mlx4_ib_free_qp_counter(struct mlx4_ib_dev *dev,\n\t\t\t\t    struct mlx4_ib_qp *qp)\n{\n\tmutex_lock(&dev->counters_table[qp->port - 1].mutex);\n\tmlx4_counter_free(dev->dev, qp->counter_index->index);\n\tlist_del(&qp->counter_index->list);\n\tmutex_unlock(&dev->counters_table[qp->port - 1].mutex);\n\n\tkfree(qp->counter_index);\n\tqp->counter_index = NULL;\n}\n\nstatic int set_qp_rss(struct mlx4_ib_dev *dev, struct mlx4_ib_rss *rss_ctx,\n\t\t      struct ib_qp_init_attr *init_attr,\n\t\t      struct mlx4_ib_create_qp_rss *ucmd)\n{\n\trss_ctx->base_qpn_tbl_sz = init_attr->rwq_ind_tbl->ind_tbl[0]->wq_num |\n\t\t(init_attr->rwq_ind_tbl->log_ind_tbl_size << 24);\n\n\tif ((ucmd->rx_hash_function == MLX4_IB_RX_HASH_FUNC_TOEPLITZ) &&\n\t    (dev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_RSS_TOP)) {\n\t\tmemcpy(rss_ctx->rss_key, ucmd->rx_hash_key,\n\t\t       MLX4_EN_RSS_KEY_SIZE);\n\t} else {\n\t\tpr_debug(\"RX Hash function is not supported\\n\");\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif (ucmd->rx_hash_fields_mask & ~(u64)(MLX4_IB_RX_HASH_SRC_IPV4\t|\n\t\t\t\t\t       MLX4_IB_RX_HASH_DST_IPV4\t|\n\t\t\t\t\t       MLX4_IB_RX_HASH_SRC_IPV6\t|\n\t\t\t\t\t       MLX4_IB_RX_HASH_DST_IPV6\t|\n\t\t\t\t\t       MLX4_IB_RX_HASH_SRC_PORT_TCP |\n\t\t\t\t\t       MLX4_IB_RX_HASH_DST_PORT_TCP |\n\t\t\t\t\t       MLX4_IB_RX_HASH_SRC_PORT_UDP |\n\t\t\t\t\t       MLX4_IB_RX_HASH_DST_PORT_UDP |\n\t\t\t\t\t       MLX4_IB_RX_HASH_INNER)) {\n\t\tpr_debug(\"RX Hash fields_mask has unsupported mask (0x%llx)\\n\",\n\t\t\t ucmd->rx_hash_fields_mask);\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_IPV4) &&\n\t    (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_IPV4)) {\n\t\trss_ctx->flags = MLX4_RSS_IPV4;\n\t} else if ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_IPV4) ||\n\t\t   (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_IPV4)) {\n\t\tpr_debug(\"RX Hash fields_mask is not supported - both IPv4 SRC and DST must be set\\n\");\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_IPV6) &&\n\t    (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_IPV6)) {\n\t\trss_ctx->flags |= MLX4_RSS_IPV6;\n\t} else if ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_IPV6) ||\n\t\t   (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_IPV6)) {\n\t\tpr_debug(\"RX Hash fields_mask is not supported - both IPv6 SRC and DST must be set\\n\");\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_PORT_UDP) &&\n\t    (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_PORT_UDP)) {\n\t\tif (!(dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_UDP_RSS)) {\n\t\t\tpr_debug(\"RX Hash fields_mask for UDP is not supported\\n\");\n\t\t\treturn (-EOPNOTSUPP);\n\t\t}\n\n\t\tif (rss_ctx->flags & MLX4_RSS_IPV4)\n\t\t\trss_ctx->flags |= MLX4_RSS_UDP_IPV4;\n\t\tif (rss_ctx->flags & MLX4_RSS_IPV6)\n\t\t\trss_ctx->flags |= MLX4_RSS_UDP_IPV6;\n\t\tif (!(rss_ctx->flags & (MLX4_RSS_IPV6 | MLX4_RSS_IPV4))) {\n\t\t\tpr_debug(\"RX Hash fields_mask is not supported - UDP must be set with IPv4 or IPv6\\n\");\n\t\t\treturn (-EOPNOTSUPP);\n\t\t}\n\t} else if ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_PORT_UDP) ||\n\t\t   (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_PORT_UDP)) {\n\t\tpr_debug(\"RX Hash fields_mask is not supported - both UDP SRC and DST must be set\\n\");\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_PORT_TCP) &&\n\t    (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_PORT_TCP)) {\n\t\tif (rss_ctx->flags & MLX4_RSS_IPV4)\n\t\t\trss_ctx->flags |= MLX4_RSS_TCP_IPV4;\n\t\tif (rss_ctx->flags & MLX4_RSS_IPV6)\n\t\t\trss_ctx->flags |= MLX4_RSS_TCP_IPV6;\n\t\tif (!(rss_ctx->flags & (MLX4_RSS_IPV6 | MLX4_RSS_IPV4))) {\n\t\t\tpr_debug(\"RX Hash fields_mask is not supported - TCP must be set with IPv4 or IPv6\\n\");\n\t\t\treturn (-EOPNOTSUPP);\n\t\t}\n\t} else if ((ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_SRC_PORT_TCP) ||\n\t\t   (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_DST_PORT_TCP)) {\n\t\tpr_debug(\"RX Hash fields_mask is not supported - both TCP SRC and DST must be set\\n\");\n\t\treturn (-EOPNOTSUPP);\n\t}\n\n\tif (ucmd->rx_hash_fields_mask & MLX4_IB_RX_HASH_INNER) {\n\t\tif (dev->dev->caps.tunnel_offload_mode ==\n\t\t    MLX4_TUNNEL_OFFLOAD_MODE_VXLAN) {\n\t\t\t \n\t\t\trss_ctx->flags |= MLX4_RSS_BY_INNER_HEADERS_IPONLY;\n\t\t} else {\n\t\t\tpr_debug(\"RSS Hash for inner headers isn't supported\\n\");\n\t\t\treturn (-EOPNOTSUPP);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int create_qp_rss(struct mlx4_ib_dev *dev,\n\t\t\t struct ib_qp_init_attr *init_attr,\n\t\t\t struct mlx4_ib_create_qp_rss *ucmd,\n\t\t\t struct mlx4_ib_qp *qp)\n{\n\tint qpn;\n\tint err;\n\n\tqp->mqp.usage = MLX4_RES_USAGE_USER_VERBS;\n\n\terr = mlx4_qp_reserve_range(dev->dev, 1, 1, &qpn, 0, qp->mqp.usage);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx4_qp_alloc(dev->dev, qpn, &qp->mqp);\n\tif (err)\n\t\tgoto err_qpn;\n\n\tINIT_LIST_HEAD(&qp->gid_list);\n\tINIT_LIST_HEAD(&qp->steering_rules);\n\n\tqp->mlx4_ib_qp_type = MLX4_IB_QPT_RAW_PACKET;\n\tqp->state = IB_QPS_RESET;\n\n\t \n\tqp->sq_no_prefetch = 1;\n\tqp->sq.wqe_cnt = 1;\n\tqp->sq.wqe_shift = MLX4_IB_MIN_SQ_STRIDE;\n\tqp->buf_size = qp->sq.wqe_cnt << MLX4_IB_MIN_SQ_STRIDE;\n\tqp->mtt = (to_mqp(\n\t\t   (struct ib_qp *)init_attr->rwq_ind_tbl->ind_tbl[0]))->mtt;\n\n\tqp->rss_ctx = kzalloc(sizeof(*qp->rss_ctx), GFP_KERNEL);\n\tif (!qp->rss_ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto err_qp_alloc;\n\t}\n\n\terr = set_qp_rss(dev, qp->rss_ctx, init_attr, ucmd);\n\tif (err)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tkfree(qp->rss_ctx);\n\nerr_qp_alloc:\n\tmlx4_qp_remove(dev->dev, &qp->mqp);\n\tmlx4_qp_free(dev->dev, &qp->mqp);\n\nerr_qpn:\n\tmlx4_qp_release_range(dev->dev, qpn, 1);\n\treturn err;\n}\n\nstatic int _mlx4_ib_create_qp_rss(struct ib_pd *pd, struct mlx4_ib_qp *qp,\n\t\t\t\t  struct ib_qp_init_attr *init_attr,\n\t\t\t\t  struct ib_udata *udata)\n{\n\tstruct mlx4_ib_create_qp_rss ucmd = {};\n\tsize_t required_cmd_sz;\n\tint err;\n\n\tif (!udata) {\n\t\tpr_debug(\"RSS QP with NULL udata\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->outlen)\n\t\treturn -EOPNOTSUPP;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), reserved1) +\n\t\t\t\t\tsizeof(ucmd.reserved1);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tpr_debug(\"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tpr_debug(\"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (memchr_inv(ucmd.reserved, 0, sizeof(ucmd.reserved)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ucmd.comp_mask || ucmd.reserved1)\n\t\treturn -EOPNOTSUPP;\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tpr_debug(\"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\tpr_debug(\"RSS QP with unsupported QP type %d\\n\",\n\t\t\t init_attr->qp_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (init_attr->create_flags) {\n\t\tpr_debug(\"RSS QP doesn't support create flags\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (init_attr->send_cq || init_attr->cap.max_send_wr) {\n\t\tpr_debug(\"RSS QP with unsupported send attributes\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tqp->pri.vid = 0xFFFF;\n\tqp->alt.vid = 0xFFFF;\n\n\terr = create_qp_rss(to_mdev(pd->device), init_attr, &ucmd, qp);\n\tif (err)\n\t\treturn err;\n\n\tqp->ibqp.qp_num = qp->mqp.qpn;\n\treturn 0;\n}\n\n \nstatic int mlx4_ib_alloc_wqn(struct mlx4_ib_ucontext *context,\n\t\t\t     struct mlx4_ib_qp *qp, int range_size, int *wqn)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(context->ibucontext.device);\n\tstruct mlx4_wqn_range *range;\n\tint err = 0;\n\n\tmutex_lock(&context->wqn_ranges_mutex);\n\n\trange = list_first_entry_or_null(&context->wqn_ranges_list,\n\t\t\t\t\t struct mlx4_wqn_range, list);\n\n\tif (!range || (range->refcount == range->size) || range->dirty) {\n\t\trange = kzalloc(sizeof(*range), GFP_KERNEL);\n\t\tif (!range) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = mlx4_qp_reserve_range(dev->dev, range_size,\n\t\t\t\t\t    range_size, &range->base_wqn, 0,\n\t\t\t\t\t    qp->mqp.usage);\n\t\tif (err) {\n\t\t\tkfree(range);\n\t\t\tgoto out;\n\t\t}\n\n\t\trange->size = range_size;\n\t\tlist_add(&range->list, &context->wqn_ranges_list);\n\t} else if (range_size != 1) {\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tqp->wqn_range = range;\n\n\t*wqn = range->base_wqn + range->refcount;\n\n\trange->refcount++;\n\nout:\n\tmutex_unlock(&context->wqn_ranges_mutex);\n\n\treturn err;\n}\n\nstatic void mlx4_ib_release_wqn(struct mlx4_ib_ucontext *context,\n\t\t\t\tstruct mlx4_ib_qp *qp, bool dirty_release)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(context->ibucontext.device);\n\tstruct mlx4_wqn_range *range;\n\n\tmutex_lock(&context->wqn_ranges_mutex);\n\n\trange = qp->wqn_range;\n\n\trange->refcount--;\n\tif (!range->refcount) {\n\t\tmlx4_qp_release_range(dev->dev, range->base_wqn,\n\t\t\t\t      range->size);\n\t\tlist_del(&range->list);\n\t\tkfree(range);\n\t} else if (dirty_release) {\n\t \n\t\trange->dirty = true;\n\t}\n\n\tmutex_unlock(&context->wqn_ranges_mutex);\n}\n\nstatic int create_rq(struct ib_pd *pd, struct ib_qp_init_attr *init_attr,\n\t\t     struct ib_udata *udata, struct mlx4_ib_qp *qp)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(pd->device);\n\tint qpn;\n\tint err;\n\tstruct mlx4_ib_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mlx4_ib_ucontext, ibucontext);\n\tstruct mlx4_ib_cq *mcq;\n\tunsigned long flags;\n\tint range_size;\n\tstruct mlx4_ib_create_wq wq;\n\tsize_t copy_len;\n\tint shift;\n\tint n;\n\n\tqp->mlx4_ib_qp_type = MLX4_IB_QPT_RAW_PACKET;\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\tINIT_LIST_HEAD(&qp->gid_list);\n\tINIT_LIST_HEAD(&qp->steering_rules);\n\n\tqp->state = IB_QPS_RESET;\n\n\tcopy_len = min(sizeof(struct mlx4_ib_create_wq), udata->inlen);\n\n\tif (ib_copy_from_udata(&wq, udata, copy_len)) {\n\t\terr = -EFAULT;\n\t\tgoto err;\n\t}\n\n\tif (wq.comp_mask || wq.reserved[0] || wq.reserved[1] ||\n\t    wq.reserved[2]) {\n\t\tpr_debug(\"user command isn't supported\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (wq.log_range_size > ilog2(dev->dev->caps.max_rss_tbl_sz)) {\n\t\tpr_debug(\"WQN range size must be equal or smaller than %d\\n\",\n\t\t\t dev->dev->caps.max_rss_tbl_sz);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\trange_size = 1 << wq.log_range_size;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS)\n\t\tqp->flags |= MLX4_IB_QP_SCATTER_FCS;\n\n\terr = set_rq_size(dev, &init_attr->cap, true, true, qp, qp->inl_recv_sz);\n\tif (err)\n\t\tgoto err;\n\n\tqp->sq_no_prefetch = 1;\n\tqp->sq.wqe_cnt = 1;\n\tqp->sq.wqe_shift = MLX4_IB_MIN_SQ_STRIDE;\n\tqp->buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t       (qp->sq.wqe_cnt << qp->sq.wqe_shift);\n\n\tqp->umem = ib_umem_get(pd->device, wq.buf_addr, qp->buf_size, 0);\n\tif (IS_ERR(qp->umem)) {\n\t\terr = PTR_ERR(qp->umem);\n\t\tgoto err;\n\t}\n\n\tshift = mlx4_ib_umem_calc_optimal_mtt_size(qp->umem, 0, &n);\n\terr = mlx4_mtt_init(dev->dev, n, shift, &qp->mtt);\n\n\tif (err)\n\t\tgoto err_buf;\n\n\terr = mlx4_ib_umem_write_mtt(dev, &qp->mtt, qp->umem);\n\tif (err)\n\t\tgoto err_mtt;\n\n\terr = mlx4_ib_db_map_user(udata, wq.db_addr, &qp->db);\n\tif (err)\n\t\tgoto err_mtt;\n\tqp->mqp.usage = MLX4_RES_USAGE_USER_VERBS;\n\n\terr = mlx4_ib_alloc_wqn(context, qp, range_size, &qpn);\n\tif (err)\n\t\tgoto err_wrid;\n\n\terr = mlx4_qp_alloc(dev->dev, qpn, &qp->mqp);\n\tif (err)\n\t\tgoto err_qpn;\n\n\t \n\tqp->doorbell_qpn = swab32(qp->mqp.qpn << 8);\n\n\tqp->mqp.event = mlx4_ib_wq_event;\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx4_ib_lock_cqs(to_mcq(init_attr->send_cq),\n\t\t\t to_mcq(init_attr->recv_cq));\n\t \n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t \n\tmcq = to_mcq(init_attr->send_cq);\n\tlist_add_tail(&qp->cq_send_list, &mcq->send_qp_list);\n\tmcq = to_mcq(init_attr->recv_cq);\n\tlist_add_tail(&qp->cq_recv_list, &mcq->recv_qp_list);\n\tmlx4_ib_unlock_cqs(to_mcq(init_attr->send_cq),\n\t\t\t   to_mcq(init_attr->recv_cq));\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\treturn 0;\n\nerr_qpn:\n\tmlx4_ib_release_wqn(context, qp, 0);\nerr_wrid:\n\tmlx4_ib_db_unmap_user(context, &qp->db);\n\nerr_mtt:\n\tmlx4_mtt_cleanup(dev->dev, &qp->mtt);\nerr_buf:\n\tib_umem_release(qp->umem);\nerr:\n\treturn err;\n}\n\nstatic int create_qp_common(struct ib_pd *pd, struct ib_qp_init_attr *init_attr,\n\t\t\t    struct ib_udata *udata, int sqpn,\n\t\t\t    struct mlx4_ib_qp *qp)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(pd->device);\n\tint qpn;\n\tint err;\n\tstruct mlx4_ib_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mlx4_ib_ucontext, ibucontext);\n\tenum mlx4_ib_qp_type qp_type = (enum mlx4_ib_qp_type) init_attr->qp_type;\n\tstruct mlx4_ib_cq *mcq;\n\tunsigned long flags;\n\n\t \n\tif (sqpn) {\n\t\tif (mlx4_is_mfunc(dev->dev) &&\n\t\t    (!mlx4_is_master(dev->dev) ||\n\t\t     !(init_attr->create_flags & MLX4_IB_SRIOV_SQP))) {\n\t\t\tif (init_attr->qp_type == IB_QPT_GSI)\n\t\t\t\tqp_type = MLX4_IB_QPT_PROXY_GSI;\n\t\t\telse {\n\t\t\t\tif (mlx4_is_master(dev->dev) ||\n\t\t\t\t    qp0_enabled_vf(dev->dev, sqpn))\n\t\t\t\t\tqp_type = MLX4_IB_QPT_PROXY_SMI_OWNER;\n\t\t\t\telse\n\t\t\t\t\tqp_type = MLX4_IB_QPT_PROXY_SMI;\n\t\t\t}\n\t\t}\n\t\tqpn = sqpn;\n\t\t \n\t\tinit_attr->cap.max_recv_sge++;\n\t} else if (init_attr->create_flags & MLX4_IB_SRIOV_TUNNEL_QP) {\n\t\tstruct mlx4_ib_qp_tunnel_init_attr *tnl_init =\n\t\t\tcontainer_of(init_attr,\n\t\t\t\t     struct mlx4_ib_qp_tunnel_init_attr, init_attr);\n\t\tif ((tnl_init->proxy_qp_type != IB_QPT_SMI &&\n\t\t     tnl_init->proxy_qp_type != IB_QPT_GSI)   ||\n\t\t    !mlx4_is_master(dev->dev))\n\t\t\treturn -EINVAL;\n\t\tif (tnl_init->proxy_qp_type == IB_QPT_GSI)\n\t\t\tqp_type = MLX4_IB_QPT_TUN_GSI;\n\t\telse if (tnl_init->slave == mlx4_master_func_num(dev->dev) ||\n\t\t\t mlx4_vf_smi_enabled(dev->dev, tnl_init->slave,\n\t\t\t\t\t     tnl_init->port))\n\t\t\tqp_type = MLX4_IB_QPT_TUN_SMI_OWNER;\n\t\telse\n\t\t\tqp_type = MLX4_IB_QPT_TUN_SMI;\n\t\t \n\t\tqpn = dev->dev->phys_caps.base_tunnel_sqpn + 8 * tnl_init->slave\n\t\t\t+ tnl_init->proxy_qp_type * 2 + tnl_init->port - 1;\n\t\tsqpn = qpn;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_SMI ||\n\t    init_attr->qp_type == IB_QPT_GSI || qp_type == MLX4_IB_QPT_SMI ||\n\t    qp_type == MLX4_IB_QPT_GSI ||\n\t    (qp_type & (MLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_SMI_OWNER |\n\t\t\tMLX4_IB_QPT_PROXY_GSI | MLX4_IB_QPT_TUN_SMI_OWNER))) {\n\t\tqp->sqp = kzalloc(sizeof(struct mlx4_ib_sqp), GFP_KERNEL);\n\t\tif (!qp->sqp)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tqp->mlx4_ib_qp_type = qp_type;\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\tINIT_LIST_HEAD(&qp->gid_list);\n\tINIT_LIST_HEAD(&qp->steering_rules);\n\n\tqp->state = IB_QPS_RESET;\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\n\n\tif (udata) {\n\t\tstruct mlx4_ib_create_qp ucmd;\n\t\tsize_t copy_len;\n\t\tint shift;\n\t\tint n;\n\n\t\tcopy_len = sizeof(struct mlx4_ib_create_qp);\n\n\t\tif (ib_copy_from_udata(&ucmd, udata, copy_len)) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tqp->inl_recv_sz = ucmd.inl_recv_sz;\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_SCATTER_FCS) {\n\t\t\tif (!(dev->dev->caps.flags &\n\t\t\t      MLX4_DEV_CAP_FLAG_FCS_KEEP)) {\n\t\t\t\tpr_debug(\"scatter FCS is unsupported\\n\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tqp->flags |= MLX4_IB_QP_SCATTER_FCS;\n\t\t}\n\n\t\terr = set_rq_size(dev, &init_attr->cap, udata,\n\t\t\t\t  qp_has_rq(init_attr), qp, qp->inl_recv_sz);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tqp->sq_no_prefetch = ucmd.sq_no_prefetch;\n\n\t\terr = set_user_sq_size(dev, qp, &ucmd);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tqp->umem =\n\t\t\tib_umem_get(pd->device, ucmd.buf_addr, qp->buf_size, 0);\n\t\tif (IS_ERR(qp->umem)) {\n\t\t\terr = PTR_ERR(qp->umem);\n\t\t\tgoto err;\n\t\t}\n\n\t\tshift = mlx4_ib_umem_calc_optimal_mtt_size(qp->umem, 0, &n);\n\t\terr = mlx4_mtt_init(dev->dev, n, shift, &qp->mtt);\n\n\t\tif (err)\n\t\t\tgoto err_buf;\n\n\t\terr = mlx4_ib_umem_write_mtt(dev, &qp->mtt, qp->umem);\n\t\tif (err)\n\t\t\tgoto err_mtt;\n\n\t\tif (qp_has_rq(init_attr)) {\n\t\t\terr = mlx4_ib_db_map_user(udata, ucmd.db_addr, &qp->db);\n\t\t\tif (err)\n\t\t\t\tgoto err_mtt;\n\t\t}\n\t\tqp->mqp.usage = MLX4_RES_USAGE_USER_VERBS;\n\t} else {\n\t\terr = set_rq_size(dev, &init_attr->cap, udata,\n\t\t\t\t  qp_has_rq(init_attr), qp, 0);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tqp->sq_no_prefetch = 0;\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)\n\t\t\tqp->flags |= MLX4_IB_QP_LSO;\n\n\t\tif (init_attr->create_flags & IB_QP_CREATE_NETIF_QP) {\n\t\t\tif (dev->steering_support ==\n\t\t\t    MLX4_STEERING_MODE_DEVICE_MANAGED)\n\t\t\t\tqp->flags |= MLX4_IB_QP_NETIF;\n\t\t\telse {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\terr = set_kernel_sq_size(dev, &init_attr->cap, qp_type, qp);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (qp_has_rq(init_attr)) {\n\t\t\terr = mlx4_db_alloc(dev->dev, &qp->db, 0);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\t*qp->db.db = 0;\n\t\t}\n\n\t\tif (mlx4_buf_alloc(dev->dev, qp->buf_size,  PAGE_SIZE * 2,\n\t\t\t\t   &qp->buf)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_db;\n\t\t}\n\n\t\terr = mlx4_mtt_init(dev->dev, qp->buf.npages, qp->buf.page_shift,\n\t\t\t\t    &qp->mtt);\n\t\tif (err)\n\t\t\tgoto err_buf;\n\n\t\terr = mlx4_buf_write_mtt(dev->dev, &qp->mtt, &qp->buf);\n\t\tif (err)\n\t\t\tgoto err_mtt;\n\n\t\tqp->sq.wrid = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\t     sizeof(u64), GFP_KERNEL);\n\t\tqp->rq.wrid = kvmalloc_array(qp->rq.wqe_cnt,\n\t\t\t\t\t     sizeof(u64), GFP_KERNEL);\n\t\tif (!qp->sq.wrid || !qp->rq.wrid) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_wrid;\n\t\t}\n\t\tqp->mqp.usage = MLX4_RES_USAGE_DRIVER;\n\t}\n\n\tif (sqpn) {\n\t\tif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\n\t\t    MLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI)) {\n\t\t\tif (alloc_proxy_bufs(pd->device, qp)) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_wrid;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (init_attr->qp_type == IB_QPT_RAW_PACKET)\n\t\t\terr = mlx4_qp_reserve_range(dev->dev, 1, 1, &qpn,\n\t\t\t\t\t\t    (init_attr->cap.max_send_wr ?\n\t\t\t\t\t\t     MLX4_RESERVE_ETH_BF_QP : 0) |\n\t\t\t\t\t\t    (init_attr->cap.max_recv_wr ?\n\t\t\t\t\t\t     MLX4_RESERVE_A0_QP : 0),\n\t\t\t\t\t\t    qp->mqp.usage);\n\t\telse\n\t\t\tif (qp->flags & MLX4_IB_QP_NETIF)\n\t\t\t\terr = mlx4_ib_steer_qp_alloc(dev, 1, &qpn);\n\t\t\telse\n\t\t\t\terr = mlx4_qp_reserve_range(dev->dev, 1, 1,\n\t\t\t\t\t\t\t    &qpn, 0, qp->mqp.usage);\n\t\tif (err)\n\t\t\tgoto err_proxy;\n\t}\n\n\tif (init_attr->create_flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)\n\t\tqp->flags |= MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\n\terr = mlx4_qp_alloc(dev->dev, qpn, &qp->mqp);\n\tif (err)\n\t\tgoto err_qpn;\n\n\tif (init_attr->qp_type == IB_QPT_XRC_TGT)\n\t\tqp->mqp.qpn |= (1 << 23);\n\n\t \n\tqp->doorbell_qpn = swab32(qp->mqp.qpn << 8);\n\n\tqp->mqp.event = mlx4_ib_qp_event;\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx4_ib_lock_cqs(to_mcq(init_attr->send_cq),\n\t\t\t to_mcq(init_attr->recv_cq));\n\t \n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t \n\tmcq = to_mcq(init_attr->send_cq);\n\tlist_add_tail(&qp->cq_send_list, &mcq->send_qp_list);\n\tmcq = to_mcq(init_attr->recv_cq);\n\tlist_add_tail(&qp->cq_recv_list, &mcq->recv_qp_list);\n\tmlx4_ib_unlock_cqs(to_mcq(init_attr->send_cq),\n\t\t\t   to_mcq(init_attr->recv_cq));\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\treturn 0;\n\nerr_qpn:\n\tif (!sqpn) {\n\t\tif (qp->flags & MLX4_IB_QP_NETIF)\n\t\t\tmlx4_ib_steer_qp_free(dev, qpn, 1);\n\t\telse\n\t\t\tmlx4_qp_release_range(dev->dev, qpn, 1);\n\t}\nerr_proxy:\n\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI)\n\t\tfree_proxy_bufs(pd->device, qp);\nerr_wrid:\n\tif (udata) {\n\t\tif (qp_has_rq(init_attr))\n\t\t\tmlx4_ib_db_unmap_user(context, &qp->db);\n\t} else {\n\t\tkvfree(qp->sq.wrid);\n\t\tkvfree(qp->rq.wrid);\n\t}\n\nerr_mtt:\n\tmlx4_mtt_cleanup(dev->dev, &qp->mtt);\n\nerr_buf:\n\tif (!qp->umem)\n\t\tmlx4_buf_free(dev->dev, qp->buf_size, &qp->buf);\n\tib_umem_release(qp->umem);\n\nerr_db:\n\tif (!udata && qp_has_rq(init_attr))\n\t\tmlx4_db_free(dev->dev, &qp->db);\n\nerr:\n\tkfree(qp->sqp);\n\treturn err;\n}\n\nstatic enum mlx4_qp_state to_mlx4_state(enum ib_qp_state state)\n{\n\tswitch (state) {\n\tcase IB_QPS_RESET:\treturn MLX4_QP_STATE_RST;\n\tcase IB_QPS_INIT:\treturn MLX4_QP_STATE_INIT;\n\tcase IB_QPS_RTR:\treturn MLX4_QP_STATE_RTR;\n\tcase IB_QPS_RTS:\treturn MLX4_QP_STATE_RTS;\n\tcase IB_QPS_SQD:\treturn MLX4_QP_STATE_SQD;\n\tcase IB_QPS_SQE:\treturn MLX4_QP_STATE_SQER;\n\tcase IB_QPS_ERR:\treturn MLX4_QP_STATE_ERR;\n\tdefault:\t\treturn -1;\n\t}\n}\n\nstatic void mlx4_ib_lock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)\n\t__acquires(&send_cq->lock) __acquires(&recv_cq->lock)\n{\n\tif (send_cq == recv_cq) {\n\t\tspin_lock(&send_cq->lock);\n\t\t__acquire(&recv_cq->lock);\n\t} else if (send_cq->mcq.cqn < recv_cq->mcq.cqn) {\n\t\tspin_lock(&send_cq->lock);\n\t\tspin_lock_nested(&recv_cq->lock, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tspin_lock(&recv_cq->lock);\n\t\tspin_lock_nested(&send_cq->lock, SINGLE_DEPTH_NESTING);\n\t}\n}\n\nstatic void mlx4_ib_unlock_cqs(struct mlx4_ib_cq *send_cq, struct mlx4_ib_cq *recv_cq)\n\t__releases(&send_cq->lock) __releases(&recv_cq->lock)\n{\n\tif (send_cq == recv_cq) {\n\t\t__release(&recv_cq->lock);\n\t\tspin_unlock(&send_cq->lock);\n\t} else if (send_cq->mcq.cqn < recv_cq->mcq.cqn) {\n\t\tspin_unlock(&recv_cq->lock);\n\t\tspin_unlock(&send_cq->lock);\n\t} else {\n\t\tspin_unlock(&send_cq->lock);\n\t\tspin_unlock(&recv_cq->lock);\n\t}\n}\n\nstatic void del_gid_entries(struct mlx4_ib_qp *qp)\n{\n\tstruct mlx4_ib_gid_entry *ge, *tmp;\n\n\tlist_for_each_entry_safe(ge, tmp, &qp->gid_list, list) {\n\t\tlist_del(&ge->list);\n\t\tkfree(ge);\n\t}\n}\n\nstatic struct mlx4_ib_pd *get_pd(struct mlx4_ib_qp *qp)\n{\n\tif (qp->ibqp.qp_type == IB_QPT_XRC_TGT)\n\t\treturn to_mpd(to_mxrcd(qp->ibqp.xrcd)->pd);\n\telse\n\t\treturn to_mpd(qp->ibqp.pd);\n}\n\nstatic void get_cqs(struct mlx4_ib_qp *qp, enum mlx4_ib_source_type src,\n\t\t    struct mlx4_ib_cq **send_cq, struct mlx4_ib_cq **recv_cq)\n{\n\tswitch (qp->ibqp.qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\t*send_cq = to_mcq(to_mxrcd(qp->ibqp.xrcd)->cq);\n\t\t*recv_cq = *send_cq;\n\t\tbreak;\n\tcase IB_QPT_XRC_INI:\n\t\t*send_cq = to_mcq(qp->ibqp.send_cq);\n\t\t*recv_cq = *send_cq;\n\t\tbreak;\n\tdefault:\n\t\t*recv_cq = (src == MLX4_IB_QP_SRC) ? to_mcq(qp->ibqp.recv_cq) :\n\t\t\t\t\t\t     to_mcq(qp->ibwq.cq);\n\t\t*send_cq = (src == MLX4_IB_QP_SRC) ? to_mcq(qp->ibqp.send_cq) :\n\t\t\t\t\t\t     *recv_cq;\n\t\tbreak;\n\t}\n}\n\nstatic void destroy_qp_rss(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tif (qp->state != IB_QPS_RESET) {\n\t\tint i;\n\n\t\tfor (i = 0; i < (1 << qp->ibqp.rwq_ind_tbl->log_ind_tbl_size);\n\t\t     i++) {\n\t\t\tstruct ib_wq *ibwq = qp->ibqp.rwq_ind_tbl->ind_tbl[i];\n\t\t\tstruct mlx4_ib_qp *wq =\tto_mqp((struct ib_qp *)ibwq);\n\n\t\t\tmutex_lock(&wq->mutex);\n\n\t\t\twq->rss_usecnt--;\n\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\n\t\tif (mlx4_qp_modify(dev->dev, NULL, to_mlx4_state(qp->state),\n\t\t\t\t   MLX4_QP_STATE_RST, NULL, 0, 0, &qp->mqp))\n\t\t\tpr_warn(\"modify QP %06x to RESET failed.\\n\",\n\t\t\t\tqp->mqp.qpn);\n\t}\n\n\tmlx4_qp_remove(dev->dev, &qp->mqp);\n\tmlx4_qp_free(dev->dev, &qp->mqp);\n\tmlx4_qp_release_range(dev->dev, qp->mqp.qpn, 1);\n\tdel_gid_entries(qp);\n}\n\nstatic void destroy_qp_common(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp,\n\t\t\t      enum mlx4_ib_source_type src,\n\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx4_ib_cq *send_cq, *recv_cq;\n\tunsigned long flags;\n\n\tif (qp->state != IB_QPS_RESET) {\n\t\tif (mlx4_qp_modify(dev->dev, NULL, to_mlx4_state(qp->state),\n\t\t\t\t   MLX4_QP_STATE_RST, NULL, 0, 0, &qp->mqp))\n\t\t\tpr_warn(\"modify QP %06x to RESET failed.\\n\",\n\t\t\t       qp->mqp.qpn);\n\t\tif (qp->pri.smac || (!qp->pri.smac && qp->pri.smac_port)) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->pri.smac_port, qp->pri.smac);\n\t\t\tqp->pri.smac = 0;\n\t\t\tqp->pri.smac_port = 0;\n\t\t}\n\t\tif (qp->alt.smac) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->alt.smac_port, qp->alt.smac);\n\t\t\tqp->alt.smac = 0;\n\t\t}\n\t\tif (qp->pri.vid < 0x1000) {\n\t\t\tmlx4_unregister_vlan(dev->dev, qp->pri.vlan_port, qp->pri.vid);\n\t\t\tqp->pri.vid = 0xFFFF;\n\t\t\tqp->pri.candidate_vid = 0xFFFF;\n\t\t\tqp->pri.update_vid = 0;\n\t\t}\n\t\tif (qp->alt.vid < 0x1000) {\n\t\t\tmlx4_unregister_vlan(dev->dev, qp->alt.vlan_port, qp->alt.vid);\n\t\t\tqp->alt.vid = 0xFFFF;\n\t\t\tqp->alt.candidate_vid = 0xFFFF;\n\t\t\tqp->alt.update_vid = 0;\n\t\t}\n\t}\n\n\tget_cqs(qp, src, &send_cq, &recv_cq);\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx4_ib_lock_cqs(send_cq, recv_cq);\n\n\t \n\tlist_del(&qp->qps_list);\n\tlist_del(&qp->cq_send_list);\n\tlist_del(&qp->cq_recv_list);\n\tif (!udata) {\n\t\t__mlx4_ib_cq_clean(recv_cq, qp->mqp.qpn,\n\t\t\t\t qp->ibqp.srq ? to_msrq(qp->ibqp.srq): NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\t__mlx4_ib_cq_clean(send_cq, qp->mqp.qpn, NULL);\n\t}\n\n\tmlx4_qp_remove(dev->dev, &qp->mqp);\n\n\tmlx4_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\tmlx4_qp_free(dev->dev, &qp->mqp);\n\n\tif (!is_sqp(dev, qp) && !is_tunnel_qp(dev, qp)) {\n\t\tif (qp->flags & MLX4_IB_QP_NETIF)\n\t\t\tmlx4_ib_steer_qp_free(dev, qp->mqp.qpn, 1);\n\t\telse if (src == MLX4_IB_RWQ_SRC)\n\t\t\tmlx4_ib_release_wqn(\n\t\t\t\trdma_udata_to_drv_context(\n\t\t\t\t\tudata,\n\t\t\t\t\tstruct mlx4_ib_ucontext,\n\t\t\t\t\tibucontext),\n\t\t\t\tqp, 1);\n\t\telse\n\t\t\tmlx4_qp_release_range(dev->dev, qp->mqp.qpn, 1);\n\t}\n\n\tmlx4_mtt_cleanup(dev->dev, &qp->mtt);\n\n\tif (udata) {\n\t\tif (qp->rq.wqe_cnt) {\n\t\t\tstruct mlx4_ib_ucontext *mcontext =\n\t\t\t\trdma_udata_to_drv_context(\n\t\t\t\t\tudata,\n\t\t\t\t\tstruct mlx4_ib_ucontext,\n\t\t\t\t\tibucontext);\n\n\t\t\tmlx4_ib_db_unmap_user(mcontext, &qp->db);\n\t\t}\n\t} else {\n\t\tkvfree(qp->sq.wrid);\n\t\tkvfree(qp->rq.wrid);\n\t\tif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\n\t\t    MLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI))\n\t\t\tfree_proxy_bufs(&dev->ib_dev, qp);\n\t\tmlx4_buf_free(dev->dev, qp->buf_size, &qp->buf);\n\t\tif (qp->rq.wqe_cnt)\n\t\t\tmlx4_db_free(dev->dev, &qp->db);\n\t}\n\tib_umem_release(qp->umem);\n\n\tdel_gid_entries(qp);\n}\n\nstatic u32 get_sqp_num(struct mlx4_ib_dev *dev, struct ib_qp_init_attr *attr)\n{\n\t \n\tif (!mlx4_is_mfunc(dev->dev) ||\n\t    (mlx4_is_master(dev->dev) &&\n\t     attr->create_flags & MLX4_IB_SRIOV_SQP)) {\n\t\treturn  dev->dev->phys_caps.base_sqpn +\n\t\t\t(attr->qp_type == IB_QPT_SMI ? 0 : 2) +\n\t\t\tattr->port_num - 1;\n\t}\n\t \n\tif (attr->qp_type == IB_QPT_SMI)\n\t\treturn dev->dev->caps.spec_qps[attr->port_num - 1].qp0_proxy;\n\telse\n\t\treturn dev->dev->caps.spec_qps[attr->port_num - 1].qp1_proxy;\n}\n\nstatic int _mlx4_ib_create_qp(struct ib_pd *pd, struct mlx4_ib_qp *qp,\n\t\t\t      struct ib_qp_init_attr *init_attr,\n\t\t\t      struct ib_udata *udata)\n{\n\tint err;\n\tint sup_u_create_flags = MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK;\n\tu16 xrcdn = 0;\n\n\tif (init_attr->rwq_ind_tbl)\n\t\treturn _mlx4_ib_create_qp_rss(pd, qp, init_attr, udata);\n\n\t \n\tif (init_attr->create_flags & ~(MLX4_IB_QP_LSO |\n\t\t\t\t\tMLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK |\n\t\t\t\t\tMLX4_IB_SRIOV_TUNNEL_QP |\n\t\t\t\t\tMLX4_IB_SRIOV_SQP |\n\t\t\t\t\tMLX4_IB_QP_NETIF |\n\t\t\t\t\tMLX4_IB_QP_CREATE_ROCE_V2_GSI))\n\t\treturn -EOPNOTSUPP;\n\n\tif (init_attr->create_flags & IB_QP_CREATE_NETIF_QP) {\n\t\tif (init_attr->qp_type != IB_QPT_UD)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (init_attr->create_flags) {\n\t\tif (udata && init_attr->create_flags & ~(sup_u_create_flags))\n\t\t\treturn -EINVAL;\n\n\t\tif ((init_attr->create_flags & ~(MLX4_IB_SRIOV_SQP |\n\t\t\t\t\t\t MLX4_IB_QP_CREATE_ROCE_V2_GSI  |\n\t\t\t\t\t\t MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK) &&\n\t\t     init_attr->qp_type != IB_QPT_UD) ||\n\t\t    (init_attr->create_flags & MLX4_IB_SRIOV_SQP &&\n\t\t     init_attr->qp_type > IB_QPT_GSI) ||\n\t\t    (init_attr->create_flags & MLX4_IB_QP_CREATE_ROCE_V2_GSI &&\n\t\t     init_attr->qp_type != IB_QPT_GSI))\n\t\t\treturn -EINVAL;\n\t}\n\n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\tpd = to_mxrcd(init_attr->xrcd)->pd;\n\t\txrcdn = to_mxrcd(init_attr->xrcd)->xrcdn;\n\t\tinit_attr->send_cq = to_mxrcd(init_attr->xrcd)->cq;\n\t\tfallthrough;\n\tcase IB_QPT_XRC_INI:\n\t\tif (!(to_mdev(pd->device)->dev->caps.flags & MLX4_DEV_CAP_FLAG_XRC))\n\t\t\treturn -ENOSYS;\n\t\tinit_attr->recv_cq = init_attr->send_cq;\n\t\tfallthrough;\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_UD:\n\t\tqp->pri.vid = 0xFFFF;\n\t\tqp->alt.vid = 0xFFFF;\n\t\terr = create_qp_common(pd, init_attr, udata, 0, qp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tqp->ibqp.qp_num = qp->mqp.qpn;\n\t\tqp->xrcdn = xrcdn;\n\t\tbreak;\n\tcase IB_QPT_SMI:\n\tcase IB_QPT_GSI:\n\t{\n\t\tint sqpn;\n\n\t\tif (init_attr->create_flags & MLX4_IB_QP_CREATE_ROCE_V2_GSI) {\n\t\t\tint res = mlx4_qp_reserve_range(to_mdev(pd->device)->dev,\n\t\t\t\t\t\t\t1, 1, &sqpn, 0,\n\t\t\t\t\t\t\tMLX4_RES_USAGE_DRIVER);\n\n\t\t\tif (res)\n\t\t\t\treturn res;\n\t\t} else {\n\t\t\tsqpn = get_sqp_num(to_mdev(pd->device), init_attr);\n\t\t}\n\n\t\tqp->pri.vid = 0xFFFF;\n\t\tqp->alt.vid = 0xFFFF;\n\t\terr = create_qp_common(pd, init_attr, udata, sqpn, qp);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (init_attr->create_flags &\n\t\t    (MLX4_IB_SRIOV_SQP | MLX4_IB_SRIOV_TUNNEL_QP))\n\t\t\t \n\t\t\trdma_restrack_no_track(&qp->ibqp.res);\n\n\t\tqp->port\t= init_attr->port_num;\n\t\tqp->ibqp.qp_num = init_attr->qp_type == IB_QPT_SMI ? 0 :\n\t\t\tinit_attr->create_flags & MLX4_IB_QP_CREATE_ROCE_V2_GSI ? sqpn : 1;\n\t\tbreak;\n\t}\n\tdefault:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nint mlx4_ib_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *init_attr,\n\t\t      struct ib_udata *udata)\n{\n\tstruct ib_device *device = ibqp->device;\n\tstruct mlx4_ib_dev *dev = to_mdev(device);\n\tstruct mlx4_ib_qp *qp = to_mqp(ibqp);\n\tstruct ib_pd *pd = ibqp->pd;\n\tint ret;\n\n\tmutex_init(&qp->mutex);\n\tret = _mlx4_ib_create_qp(pd, qp, init_attr, udata);\n\tif (ret)\n\t\treturn ret;\n\n\tif (init_attr->qp_type == IB_QPT_GSI &&\n\t    !(init_attr->create_flags & MLX4_IB_QP_CREATE_ROCE_V2_GSI)) {\n\t\tstruct mlx4_ib_sqp *sqp = qp->sqp;\n\t\tint is_eth = rdma_cap_eth_ah(&dev->ib_dev, init_attr->port_num);\n\n\t\tif (is_eth &&\n\t\t    dev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_ROCE_V1_V2) {\n\t\t\tinit_attr->create_flags |= MLX4_IB_QP_CREATE_ROCE_V2_GSI;\n\t\t\tsqp->roce_v2_gsi = ib_create_qp(pd, init_attr);\n\n\t\t\tif (IS_ERR(sqp->roce_v2_gsi)) {\n\t\t\t\tpr_err(\"Failed to create GSI QP for RoCEv2 (%ld)\\n\", PTR_ERR(sqp->roce_v2_gsi));\n\t\t\t\tsqp->roce_v2_gsi = NULL;\n\t\t\t} else {\n\t\t\t\tto_mqp(sqp->roce_v2_gsi)->flags |=\n\t\t\t\t\tMLX4_IB_ROCE_V2_GSI_QP;\n\t\t\t}\n\n\t\t\tinit_attr->create_flags &= ~MLX4_IB_QP_CREATE_ROCE_V2_GSI;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int _mlx4_ib_destroy_qp(struct ib_qp *qp, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx4_ib_qp *mqp = to_mqp(qp);\n\n\tif (is_qp0(dev, mqp))\n\t\tmlx4_CLOSE_PORT(dev->dev, mqp->port);\n\n\tif (mqp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI &&\n\t    dev->qp1_proxy[mqp->port - 1] == mqp) {\n\t\tmutex_lock(&dev->qp1_proxy_lock[mqp->port - 1]);\n\t\tdev->qp1_proxy[mqp->port - 1] = NULL;\n\t\tmutex_unlock(&dev->qp1_proxy_lock[mqp->port - 1]);\n\t}\n\n\tif (mqp->counter_index)\n\t\tmlx4_ib_free_qp_counter(dev, mqp);\n\n\tif (qp->rwq_ind_tbl) {\n\t\tdestroy_qp_rss(dev, mqp);\n\t} else {\n\t\tdestroy_qp_common(dev, mqp, MLX4_IB_QP_SRC, udata);\n\t}\n\n\tkfree(mqp->sqp);\n\treturn 0;\n}\n\nint mlx4_ib_destroy_qp(struct ib_qp *qp, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_qp *mqp = to_mqp(qp);\n\n\tif (mqp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI) {\n\t\tstruct mlx4_ib_sqp *sqp = mqp->sqp;\n\n\t\tif (sqp->roce_v2_gsi)\n\t\t\tib_destroy_qp(sqp->roce_v2_gsi);\n\t}\n\n\treturn _mlx4_ib_destroy_qp(qp, udata);\n}\n\nstatic int to_mlx4_st(struct mlx4_ib_dev *dev, enum mlx4_ib_qp_type type)\n{\n\tswitch (type) {\n\tcase MLX4_IB_QPT_RC:\t\treturn MLX4_QP_ST_RC;\n\tcase MLX4_IB_QPT_UC:\t\treturn MLX4_QP_ST_UC;\n\tcase MLX4_IB_QPT_UD:\t\treturn MLX4_QP_ST_UD;\n\tcase MLX4_IB_QPT_XRC_INI:\n\tcase MLX4_IB_QPT_XRC_TGT:\treturn MLX4_QP_ST_XRC;\n\tcase MLX4_IB_QPT_SMI:\n\tcase MLX4_IB_QPT_GSI:\n\tcase MLX4_IB_QPT_RAW_PACKET:\treturn MLX4_QP_ST_MLX;\n\n\tcase MLX4_IB_QPT_PROXY_SMI_OWNER:\n\tcase MLX4_IB_QPT_TUN_SMI_OWNER:\treturn (mlx4_is_mfunc(dev->dev) ?\n\t\t\t\t\t\tMLX4_QP_ST_MLX : -1);\n\tcase MLX4_IB_QPT_PROXY_SMI:\n\tcase MLX4_IB_QPT_TUN_SMI:\n\tcase MLX4_IB_QPT_PROXY_GSI:\n\tcase MLX4_IB_QPT_TUN_GSI:\treturn (mlx4_is_mfunc(dev->dev) ?\n\t\t\t\t\t\tMLX4_QP_ST_UD : -1);\n\tdefault:\t\t\treturn -1;\n\t}\n}\n\nstatic __be32 to_mlx4_access_flags(struct mlx4_ib_qp *qp, const struct ib_qp_attr *attr,\n\t\t\t\t   int attr_mask)\n{\n\tu8 dest_rd_atomic;\n\tu32 access_flags;\n\tu32 hw_access_flags = 0;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tdest_rd_atomic = attr->max_dest_rd_atomic;\n\telse\n\t\tdest_rd_atomic = qp->resp_depth;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\taccess_flags = attr->qp_access_flags;\n\telse\n\t\taccess_flags = qp->atomic_rd_en;\n\n\tif (!dest_rd_atomic)\n\t\taccess_flags &= IB_ACCESS_REMOTE_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_READ)\n\t\thw_access_flags |= MLX4_QP_BIT_RRE;\n\tif (access_flags & IB_ACCESS_REMOTE_ATOMIC)\n\t\thw_access_flags |= MLX4_QP_BIT_RAE;\n\tif (access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\thw_access_flags |= MLX4_QP_BIT_RWE;\n\n\treturn cpu_to_be32(hw_access_flags);\n}\n\nstatic void store_sqp_attrs(struct mlx4_ib_sqp *sqp, const struct ib_qp_attr *attr,\n\t\t\t    int attr_mask)\n{\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tsqp->pkey_index = attr->pkey_index;\n\tif (attr_mask & IB_QP_QKEY)\n\t\tsqp->qkey = attr->qkey;\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tsqp->send_psn = attr->sq_psn;\n}\n\nstatic void mlx4_set_sched(struct mlx4_qp_path *path, u8 port)\n{\n\tpath->sched_queue = (path->sched_queue & 0xbf) | ((port - 1) << 6);\n}\n\nstatic int _mlx4_set_path(struct mlx4_ib_dev *dev,\n\t\t\t  const struct rdma_ah_attr *ah,\n\t\t\t  u64 smac, u16 vlan_tag, struct mlx4_qp_path *path,\n\t\t\t  struct mlx4_roce_smac_vlan_info *smac_info, u8 port)\n{\n\tint vidx;\n\tint smac_index;\n\tint err;\n\n\tpath->grh_mylmc = rdma_ah_get_path_bits(ah) & 0x7f;\n\tpath->rlid = cpu_to_be16(rdma_ah_get_dlid(ah));\n\tif (rdma_ah_get_static_rate(ah)) {\n\t\tpath->static_rate = rdma_ah_get_static_rate(ah) +\n\t\t\t\t    MLX4_STAT_RATE_OFFSET;\n\t\twhile (path->static_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\n\t\t       !(1 << path->static_rate & dev->dev->caps.stat_rate_support))\n\t\t\t--path->static_rate;\n\t} else\n\t\tpath->static_rate = 0;\n\n\tif (rdma_ah_get_ah_flags(ah) & IB_AH_GRH) {\n\t\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah);\n\t\tint real_sgid_index =\n\t\t\tmlx4_ib_gid_index_to_real_index(dev, grh->sgid_attr);\n\n\t\tif (real_sgid_index < 0)\n\t\t\treturn real_sgid_index;\n\t\tif (real_sgid_index >= dev->dev->caps.gid_table_len[port]) {\n\t\t\tpr_err(\"sgid_index (%u) too large. max is %d\\n\",\n\t\t\t       real_sgid_index, dev->dev->caps.gid_table_len[port] - 1);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpath->grh_mylmc |= 1 << 7;\n\t\tpath->mgid_index = real_sgid_index;\n\t\tpath->hop_limit  = grh->hop_limit;\n\t\tpath->tclass_flowlabel =\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    (grh->flow_label));\n\t\tmemcpy(path->rgid, grh->dgid.raw, 16);\n\t}\n\n\tif (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (!(rdma_ah_get_ah_flags(ah) & IB_AH_GRH))\n\t\t\treturn -1;\n\n\t\tpath->sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE |\n\t\t\t((port - 1) << 6) | ((rdma_ah_get_sl(ah) & 7) << 3);\n\n\t\tpath->feup |= MLX4_FEUP_FORCE_ETH_UP;\n\t\tif (vlan_tag < 0x1000) {\n\t\t\tif (smac_info->vid < 0x1000) {\n\t\t\t\t \n\t\t\t\tif (smac_info->vid != vlan_tag) {\n\t\t\t\t\t \n\t\t\t\t\terr = mlx4_register_vlan(dev->dev, port, vlan_tag, &vidx);\n\t\t\t\t\tif (err)\n\t\t\t\t\t\treturn err;\n\t\t\t\t\tsmac_info->candidate_vid = vlan_tag;\n\t\t\t\t\tsmac_info->candidate_vlan_index = vidx;\n\t\t\t\t\tsmac_info->candidate_vlan_port = port;\n\t\t\t\t\tsmac_info->update_vid = 1;\n\t\t\t\t\tpath->vlan_index = vidx;\n\t\t\t\t} else {\n\t\t\t\t\tpath->vlan_index = smac_info->vlan_index;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\terr = mlx4_register_vlan(dev->dev, port, vlan_tag, &vidx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tsmac_info->candidate_vid = vlan_tag;\n\t\t\t\tsmac_info->candidate_vlan_index = vidx;\n\t\t\t\tsmac_info->candidate_vlan_port = port;\n\t\t\t\tsmac_info->update_vid = 1;\n\t\t\t\tpath->vlan_index = vidx;\n\t\t\t}\n\t\t\tpath->feup |= MLX4_FVL_FORCE_ETH_VLAN;\n\t\t\tpath->fl = 1 << 6;\n\t\t} else {\n\t\t\t \n\t\t\tif (smac_info->vid < 0x1000) {\n\t\t\t\tsmac_info->candidate_vid = 0xFFFF;\n\t\t\t\tsmac_info->update_vid = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((!smac_info->smac && !smac_info->smac_port) ||\n\t\t    smac_info->smac != smac) {\n\t\t\t \n\t\t\tsmac_index = mlx4_register_mac(dev->dev, port, smac);\n\t\t\tif (smac_index >= 0) {\n\t\t\t\tsmac_info->candidate_smac_index = smac_index;\n\t\t\t\tsmac_info->candidate_smac = smac;\n\t\t\t\tsmac_info->candidate_smac_port = port;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else {\n\t\t\tsmac_index = smac_info->smac_index;\n\t\t}\n\t\tmemcpy(path->dmac, ah->roce.dmac, 6);\n\t\tpath->ackto = MLX4_IB_LINK_TYPE_ETH;\n\t\t \n\t\tpath->grh_mylmc = (u8) (smac_index) | 0x80;\n\t} else {\n\t\tpath->sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE |\n\t\t\t((port - 1) << 6) | ((rdma_ah_get_sl(ah) & 0xf) << 2);\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx4_set_path(struct mlx4_ib_dev *dev, const struct ib_qp_attr *qp,\n\t\t\t enum ib_qp_attr_mask qp_attr_mask,\n\t\t\t struct mlx4_ib_qp *mqp,\n\t\t\t struct mlx4_qp_path *path, u8 port,\n\t\t\t u16 vlan_id, u8 *smac)\n{\n\treturn _mlx4_set_path(dev, &qp->ah_attr,\n\t\t\t      ether_addr_to_u64(smac),\n\t\t\t      vlan_id,\n\t\t\t      path, &mqp->pri, port);\n}\n\nstatic int mlx4_set_alt_path(struct mlx4_ib_dev *dev,\n\t\t\t     const struct ib_qp_attr *qp,\n\t\t\t     enum ib_qp_attr_mask qp_attr_mask,\n\t\t\t     struct mlx4_ib_qp *mqp,\n\t\t\t     struct mlx4_qp_path *path, u8 port)\n{\n\treturn _mlx4_set_path(dev, &qp->alt_ah_attr,\n\t\t\t      0,\n\t\t\t      0xffff,\n\t\t\t      path, &mqp->alt, port);\n}\n\nstatic void update_mcg_macs(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tstruct mlx4_ib_gid_entry *ge, *tmp;\n\n\tlist_for_each_entry_safe(ge, tmp, &qp->gid_list, list) {\n\t\tif (!ge->added && mlx4_ib_add_mc(dev, qp, &ge->gid)) {\n\t\t\tge->added = 1;\n\t\t\tge->port = qp->port;\n\t\t}\n\t}\n}\n\nstatic int handle_eth_ud_smac_index(struct mlx4_ib_dev *dev,\n\t\t\t\t    struct mlx4_ib_qp *qp,\n\t\t\t\t    struct mlx4_qp_context *context)\n{\n\tu64 u64_mac;\n\tint smac_index;\n\n\tu64_mac = atomic64_read(&dev->iboe.mac[qp->port - 1]);\n\n\tcontext->pri_path.sched_queue = MLX4_IB_DEFAULT_SCHED_QUEUE | ((qp->port - 1) << 6);\n\tif (!qp->pri.smac && !qp->pri.smac_port) {\n\t\tsmac_index = mlx4_register_mac(dev->dev, qp->port, u64_mac);\n\t\tif (smac_index >= 0) {\n\t\t\tqp->pri.candidate_smac_index = smac_index;\n\t\t\tqp->pri.candidate_smac = u64_mac;\n\t\t\tqp->pri.candidate_smac_port = qp->port;\n\t\t\tcontext->pri_path.grh_mylmc = 0x80 | (u8) smac_index;\n\t\t} else {\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int create_qp_lb_counter(struct mlx4_ib_dev *dev, struct mlx4_ib_qp *qp)\n{\n\tstruct counter_index *new_counter_index;\n\tint err;\n\tu32 tmp_idx;\n\n\tif (rdma_port_get_link_layer(&dev->ib_dev, qp->port) !=\n\t    IB_LINK_LAYER_ETHERNET ||\n\t    !(qp->flags & MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK) ||\n\t    !(dev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_LB_SRC_CHK))\n\t\treturn 0;\n\n\terr = mlx4_counter_alloc(dev->dev, &tmp_idx, MLX4_RES_USAGE_DRIVER);\n\tif (err)\n\t\treturn err;\n\n\tnew_counter_index = kmalloc(sizeof(*new_counter_index), GFP_KERNEL);\n\tif (!new_counter_index) {\n\t\tmlx4_counter_free(dev->dev, tmp_idx);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_counter_index->index = tmp_idx;\n\tnew_counter_index->allocated = 1;\n\tqp->counter_index = new_counter_index;\n\n\tmutex_lock(&dev->counters_table[qp->port - 1].mutex);\n\tlist_add_tail(&new_counter_index->list,\n\t\t      &dev->counters_table[qp->port - 1].counters_list);\n\tmutex_unlock(&dev->counters_table[qp->port - 1].mutex);\n\n\treturn 0;\n}\n\nenum {\n\tMLX4_QPC_ROCE_MODE_1 = 0,\n\tMLX4_QPC_ROCE_MODE_2 = 2,\n\tMLX4_QPC_ROCE_MODE_UNDEFINED = 0xff\n};\n\nstatic u8 gid_type_to_qpc(enum ib_gid_type gid_type)\n{\n\tswitch (gid_type) {\n\tcase IB_GID_TYPE_ROCE:\n\t\treturn MLX4_QPC_ROCE_MODE_1;\n\tcase IB_GID_TYPE_ROCE_UDP_ENCAP:\n\t\treturn MLX4_QPC_ROCE_MODE_2;\n\tdefault:\n\t\treturn MLX4_QPC_ROCE_MODE_UNDEFINED;\n\t}\n}\n\n \nstatic int bringup_rss_rwqs(struct ib_rwq_ind_table *ind_tbl, u8 port_num,\n\t\t\t    struct ib_udata *udata)\n{\n\tint err = 0;\n\tint i;\n\n\tfor (i = 0; i < (1 << ind_tbl->log_ind_tbl_size); i++) {\n\t\tstruct ib_wq *ibwq = ind_tbl->ind_tbl[i];\n\t\tstruct mlx4_ib_qp *wq = to_mqp((struct ib_qp *)ibwq);\n\n\t\tmutex_lock(&wq->mutex);\n\n\t\t \n\t\tif ((wq->rss_usecnt > 0) && (wq->port != port_num)) {\n\t\t\terr = -EINVAL;\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tbreak;\n\t\t}\n\t\twq->port = port_num;\n\t\tif ((wq->rss_usecnt == 0) && (ibwq->state == IB_WQS_RDY)) {\n\t\t\terr = _mlx4_ib_modify_wq(ibwq, IB_WQS_RDY, udata);\n\t\t\tif (err) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twq->rss_usecnt++;\n\n\t\tmutex_unlock(&wq->mutex);\n\t}\n\n\tif (i && err) {\n\t\tint j;\n\n\t\tfor (j = (i - 1); j >= 0; j--) {\n\t\t\tstruct ib_wq *ibwq = ind_tbl->ind_tbl[j];\n\t\t\tstruct mlx4_ib_qp *wq = to_mqp((struct ib_qp *)ibwq);\n\n\t\t\tmutex_lock(&wq->mutex);\n\n\t\t\tif ((wq->rss_usecnt == 1) &&\n\t\t\t    (ibwq->state == IB_WQS_RDY))\n\t\t\t\tif (_mlx4_ib_modify_wq(ibwq, IB_WQS_RESET,\n\t\t\t\t\t\t       udata))\n\t\t\t\t\tpr_warn(\"failed to reverse WQN=0x%06x\\n\",\n\t\t\t\t\t\tibwq->wq_num);\n\t\t\twq->rss_usecnt--;\n\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void bring_down_rss_rwqs(struct ib_rwq_ind_table *ind_tbl,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tint i;\n\n\tfor (i = 0; i < (1 << ind_tbl->log_ind_tbl_size); i++) {\n\t\tstruct ib_wq *ibwq = ind_tbl->ind_tbl[i];\n\t\tstruct mlx4_ib_qp *wq = to_mqp((struct ib_qp *)ibwq);\n\n\t\tmutex_lock(&wq->mutex);\n\n\t\tif ((wq->rss_usecnt == 1) && (ibwq->state == IB_WQS_RDY))\n\t\t\tif (_mlx4_ib_modify_wq(ibwq, IB_WQS_RESET, udata))\n\t\t\t\tpr_warn(\"failed to reverse WQN=%x\\n\",\n\t\t\t\t\tibwq->wq_num);\n\t\twq->rss_usecnt--;\n\n\t\tmutex_unlock(&wq->mutex);\n\t}\n}\n\nstatic void fill_qp_rss_context(struct mlx4_qp_context *context,\n\t\t\t\tstruct mlx4_ib_qp *qp)\n{\n\tstruct mlx4_rss_context *rss_context;\n\n\trss_context = (void *)context + offsetof(struct mlx4_qp_context,\n\t\t\tpri_path) + MLX4_RSS_OFFSET_IN_QPC_PRI_PATH;\n\n\trss_context->base_qpn = cpu_to_be32(qp->rss_ctx->base_qpn_tbl_sz);\n\trss_context->default_qpn =\n\t\tcpu_to_be32(qp->rss_ctx->base_qpn_tbl_sz & 0xffffff);\n\tif (qp->rss_ctx->flags & (MLX4_RSS_UDP_IPV4 | MLX4_RSS_UDP_IPV6))\n\t\trss_context->base_qpn_udp = rss_context->default_qpn;\n\trss_context->flags = qp->rss_ctx->flags;\n\t \n\trss_context->hash_fn = MLX4_RSS_HASH_TOP;\n\n\tmemcpy(rss_context->rss_key, qp->rss_ctx->rss_key,\n\t       MLX4_EN_RSS_KEY_SIZE);\n}\n\nstatic int __mlx4_ib_modify_qp(void *src, enum mlx4_ib_source_type src_type,\n\t\t\t       const struct ib_qp_attr *attr, int attr_mask,\n\t\t\t       enum ib_qp_state cur_state,\n\t\t\t       enum ib_qp_state new_state,\n\t\t\t       struct ib_udata *udata)\n{\n\tstruct ib_srq  *ibsrq;\n\tconst struct ib_gid_attr *gid_attr = NULL;\n\tstruct ib_rwq_ind_table *rwq_ind_tbl;\n\tenum ib_qp_type qp_type;\n\tstruct mlx4_ib_dev *dev;\n\tstruct mlx4_ib_qp *qp;\n\tstruct mlx4_ib_pd *pd;\n\tstruct mlx4_ib_cq *send_cq, *recv_cq;\n\tstruct mlx4_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx4_ib_ucontext, ibucontext);\n\tstruct mlx4_qp_context *context;\n\tenum mlx4_qp_optpar optpar = 0;\n\tint sqd_event;\n\tint steer_qp = 0;\n\tint err = -EINVAL;\n\tint counter_index;\n\n\tif (src_type == MLX4_IB_RWQ_SRC) {\n\t\tstruct ib_wq *ibwq;\n\n\t\tibwq\t    = (struct ib_wq *)src;\n\t\tibsrq\t    = NULL;\n\t\trwq_ind_tbl = NULL;\n\t\tqp_type     = IB_QPT_RAW_PACKET;\n\t\tqp\t    = to_mqp((struct ib_qp *)ibwq);\n\t\tdev\t    = to_mdev(ibwq->device);\n\t\tpd\t    = to_mpd(ibwq->pd);\n\t} else {\n\t\tstruct ib_qp *ibqp;\n\n\t\tibqp\t    = (struct ib_qp *)src;\n\t\tibsrq\t    = ibqp->srq;\n\t\trwq_ind_tbl = ibqp->rwq_ind_tbl;\n\t\tqp_type     = ibqp->qp_type;\n\t\tqp\t    = to_mqp(ibqp);\n\t\tdev\t    = to_mdev(ibqp->device);\n\t\tpd\t    = get_pd(qp);\n\t}\n\n\t \n\tif (attr_mask & IB_QP_ALT_PATH &&\n\t    rdma_port_get_link_layer(&dev->ib_dev, qp->port) ==\n\t    IB_LINK_LAYER_ETHERNET)\n\t\treturn -ENOTSUPP;\n\n\tcontext = kzalloc(sizeof *context, GFP_KERNEL);\n\tif (!context)\n\t\treturn -ENOMEM;\n\n\tcontext->flags = cpu_to_be32((to_mlx4_state(new_state) << 28) |\n\t\t\t\t     (to_mlx4_st(dev, qp->mlx4_ib_qp_type) << 16));\n\n\tif (!(attr_mask & IB_QP_PATH_MIG_STATE))\n\t\tcontext->flags |= cpu_to_be32(MLX4_QP_PM_MIGRATED << 11);\n\telse {\n\t\toptpar |= MLX4_QP_OPTPAR_PM_STATE;\n\t\tswitch (attr->path_mig_state) {\n\t\tcase IB_MIG_MIGRATED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX4_QP_PM_MIGRATED << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_REARM:\n\t\t\tcontext->flags |= cpu_to_be32(MLX4_QP_PM_REARM << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_ARMED:\n\t\t\tcontext->flags |= cpu_to_be32(MLX4_QP_PM_ARMED << 11);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (qp->inl_recv_sz)\n\t\tcontext->param3 |= cpu_to_be32(1 << 25);\n\n\tif (qp->flags & MLX4_IB_QP_SCATTER_FCS)\n\t\tcontext->param3 |= cpu_to_be32(1 << 29);\n\n\tif (qp_type == IB_QPT_GSI || qp_type == IB_QPT_SMI)\n\t\tcontext->mtu_msgmax = (IB_MTU_4096 << 5) | 11;\n\telse if (qp_type == IB_QPT_RAW_PACKET)\n\t\tcontext->mtu_msgmax = (MLX4_RAW_QP_MTU << 5) | MLX4_RAW_QP_MSGMAX;\n\telse if (qp_type == IB_QPT_UD) {\n\t\tif (qp->flags & MLX4_IB_QP_LSO)\n\t\t\tcontext->mtu_msgmax = (IB_MTU_4096 << 5) |\n\t\t\t\t\t      ilog2(dev->dev->caps.max_gso_sz);\n\t\telse\n\t\t\tcontext->mtu_msgmax = (IB_MTU_4096 << 5) | 13;\n\t} else if (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attr->path_mtu < IB_MTU_256 || attr->path_mtu > IB_MTU_4096) {\n\t\t\tpr_err(\"path MTU (%u) is invalid\\n\",\n\t\t\t       attr->path_mtu);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->mtu_msgmax = (attr->path_mtu << 5) |\n\t\t\tilog2(dev->dev->caps.max_msg_sz);\n\t}\n\n\tif (!rwq_ind_tbl) {  \n\t\tif (qp->rq.wqe_cnt)\n\t\t\tcontext->rq_size_stride = ilog2(qp->rq.wqe_cnt) << 3;\n\t\tcontext->rq_size_stride |= qp->rq.wqe_shift - 4;\n\t}\n\n\tif (qp->sq.wqe_cnt)\n\t\tcontext->sq_size_stride = ilog2(qp->sq.wqe_cnt) << 3;\n\tcontext->sq_size_stride |= qp->sq.wqe_shift - 4;\n\n\tif (new_state == IB_QPS_RESET && qp->counter_index)\n\t\tmlx4_ib_free_qp_counter(dev, qp);\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\tcontext->sq_size_stride |= !!qp->sq_no_prefetch << 7;\n\t\tcontext->xrcd = cpu_to_be32((u32) qp->xrcdn);\n\t\tif (qp_type == IB_QPT_RAW_PACKET)\n\t\t\tcontext->param3 |= cpu_to_be32(1 << 30);\n\t}\n\n\tif (ucontext)\n\t\tcontext->usr_page = cpu_to_be32(\n\t\t\tmlx4_to_hw_uar_index(dev->dev, ucontext->uar.index));\n\telse\n\t\tcontext->usr_page = cpu_to_be32(\n\t\t\tmlx4_to_hw_uar_index(dev->dev, dev->priv_uar.index));\n\n\tif (attr_mask & IB_QP_DEST_QPN)\n\t\tcontext->remote_qpn = cpu_to_be32(attr->dest_qp_num);\n\n\tif (attr_mask & IB_QP_PORT) {\n\t\tif (cur_state == IB_QPS_SQD && new_state == IB_QPS_SQD &&\n\t\t    !(attr_mask & IB_QP_AV)) {\n\t\t\tmlx4_set_sched(&context->pri_path, attr->port_num);\n\t\t\toptpar |= MLX4_QP_OPTPAR_SCHED_QUEUE;\n\t\t}\n\t}\n\n\tif (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\terr = create_qp_lb_counter(dev, qp);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tcounter_index =\n\t\t\tdev->counters_table[qp->port - 1].default_counter;\n\t\tif (qp->counter_index)\n\t\t\tcounter_index = qp->counter_index->index;\n\n\t\tif (counter_index != -1) {\n\t\t\tcontext->pri_path.counter_index = counter_index;\n\t\t\toptpar |= MLX4_QP_OPTPAR_COUNTER_INDEX;\n\t\t\tif (qp->counter_index) {\n\t\t\t\tcontext->pri_path.fl |=\n\t\t\t\t\tMLX4_FL_ETH_SRC_CHECK_MC_LB;\n\t\t\t\tcontext->pri_path.vlan_control |=\n\t\t\t\t\tMLX4_CTRL_ETH_SRC_CHECK_IF_COUNTER;\n\t\t\t}\n\t\t} else\n\t\t\tcontext->pri_path.counter_index =\n\t\t\t\tMLX4_SINK_COUNTER_INDEX(dev->dev);\n\n\t\tif (qp->flags & MLX4_IB_QP_NETIF) {\n\t\t\tmlx4_ib_steer_qp_reg(dev, qp, 1);\n\t\t\tsteer_qp = 1;\n\t\t}\n\n\t\tif (qp_type == IB_QPT_GSI) {\n\t\t\tenum ib_gid_type gid_type = qp->flags & MLX4_IB_ROCE_V2_GSI_QP ?\n\t\t\t\tIB_GID_TYPE_ROCE_UDP_ENCAP : IB_GID_TYPE_ROCE;\n\t\t\tu8 qpc_roce_mode = gid_type_to_qpc(gid_type);\n\n\t\t\tcontext->rlkey_roce_mode |= (qpc_roce_mode << 6);\n\t\t}\n\t}\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tif (qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV)\n\t\t\tcontext->pri_path.disable_pkey_check = 0x40;\n\t\tcontext->pri_path.pkey_index = attr->pkey_index;\n\t\toptpar |= MLX4_QP_OPTPAR_PKEY_INDEX;\n\t}\n\n\tif (attr_mask & IB_QP_AV) {\n\t\tu8 port_num = mlx4_is_bonded(dev->dev) ? 1 :\n\t\t\tattr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tu16 vlan = 0xffff;\n\t\tu8 smac[ETH_ALEN];\n\t\tint is_eth =\n\t\t\trdma_cap_eth_ah(&dev->ib_dev, port_num) &&\n\t\t\trdma_ah_get_ah_flags(&attr->ah_attr) & IB_AH_GRH;\n\n\t\tif (is_eth) {\n\t\t\tgid_attr = attr->ah_attr.grh.sgid_attr;\n\t\t\terr = rdma_read_gid_l2_fields(gid_attr, &vlan,\n\t\t\t\t\t\t      &smac[0]);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (mlx4_set_path(dev, attr, attr_mask, qp, &context->pri_path,\n\t\t\t\t  port_num, vlan, smac))\n\t\t\tgoto out;\n\n\t\toptpar |= (MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH |\n\t\t\t   MLX4_QP_OPTPAR_SCHED_QUEUE);\n\n\t\tif (is_eth &&\n\t\t    (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR)) {\n\t\t\tu8 qpc_roce_mode = gid_type_to_qpc(gid_attr->gid_type);\n\n\t\t\tif (qpc_roce_mode == MLX4_QPC_ROCE_MODE_UNDEFINED) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontext->rlkey_roce_mode |= (qpc_roce_mode << 6);\n\t\t}\n\n\t}\n\n\tif (attr_mask & IB_QP_TIMEOUT) {\n\t\tcontext->pri_path.ackto |= attr->timeout << 3;\n\t\toptpar |= MLX4_QP_OPTPAR_ACK_TIMEOUT;\n\t}\n\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\tif (attr->alt_port_num == 0 ||\n\t\t    attr->alt_port_num > dev->dev->caps.num_ports)\n\t\t\tgoto out;\n\n\t\tif (attr->alt_pkey_index >=\n\t\t    dev->dev->caps.pkey_table_len[attr->alt_port_num])\n\t\t\tgoto out;\n\n\t\tif (mlx4_set_alt_path(dev, attr, attr_mask, qp,\n\t\t\t\t      &context->alt_path,\n\t\t\t\t      attr->alt_port_num))\n\t\t\tgoto out;\n\n\t\tcontext->alt_path.pkey_index = attr->alt_pkey_index;\n\t\tcontext->alt_path.ackto = attr->alt_timeout << 3;\n\t\toptpar |= MLX4_QP_OPTPAR_ALT_ADDR_PATH;\n\t}\n\n\tcontext->pd = cpu_to_be32(pd->pdn);\n\n\tif (!rwq_ind_tbl) {\n\t\tcontext->params1 = cpu_to_be32(MLX4_IB_ACK_REQ_FREQ << 28);\n\t\tget_cqs(qp, src_type, &send_cq, &recv_cq);\n\t} else {  \n\t\tsend_cq = to_mcq(rwq_ind_tbl->ind_tbl[0]->cq);\n\t\trecv_cq = send_cq;\n\t}\n\tcontext->cqn_send = cpu_to_be32(send_cq->mcq.cqn);\n\tcontext->cqn_recv = cpu_to_be32(recv_cq->mcq.cqn);\n\n\t \n\tif (!ucontext)\n\t\tcontext->params1 |= cpu_to_be32(1 << 11);\n\n\tif (attr_mask & IB_QP_RNR_RETRY) {\n\t\tcontext->params1 |= cpu_to_be32(attr->rnr_retry << 13);\n\t\toptpar |= MLX4_QP_OPTPAR_RNR_RETRY;\n\t}\n\n\tif (attr_mask & IB_QP_RETRY_CNT) {\n\t\tcontext->params1 |= cpu_to_be32(attr->retry_cnt << 16);\n\t\toptpar |= MLX4_QP_OPTPAR_RETRY_COUNT;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attr->max_rd_atomic)\n\t\t\tcontext->params1 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_rd_atomic - 1) << 21);\n\t\toptpar |= MLX4_QP_OPTPAR_SRA_MAX;\n\t}\n\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tcontext->next_send_psn = cpu_to_be32(attr->sq_psn);\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attr->max_dest_rd_atomic)\n\t\t\tcontext->params2 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_dest_rd_atomic - 1) << 21);\n\t\toptpar |= MLX4_QP_OPTPAR_RRA_MAX;\n\t}\n\n\tif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC)) {\n\t\tcontext->params2 |= to_mlx4_access_flags(qp, attr, attr_mask);\n\t\toptpar |= MLX4_QP_OPTPAR_RWE | MLX4_QP_OPTPAR_RRE | MLX4_QP_OPTPAR_RAE;\n\t}\n\n\tif (ibsrq)\n\t\tcontext->params2 |= cpu_to_be32(MLX4_QP_BIT_RIC);\n\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER) {\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->min_rnr_timer << 24);\n\t\toptpar |= MLX4_QP_OPTPAR_RNR_TIMEOUT;\n\t}\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tcontext->rnr_nextrecvpsn |= cpu_to_be32(attr->rq_psn);\n\n\t \n\tif (attr_mask & IB_QP_QKEY) {\n\t\tif (qp->mlx4_ib_qp_type &\n\t\t    (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER))\n\t\t\tcontext->qkey = cpu_to_be32(IB_QP_SET_QKEY);\n\t\telse {\n\t\t\tif (mlx4_is_mfunc(dev->dev) &&\n\t\t\t    !(qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV) &&\n\t\t\t    (attr->qkey & MLX4_RESERVED_QKEY_MASK) ==\n\t\t\t    MLX4_RESERVED_QKEY_BASE) {\n\t\t\t\tpr_err(\"Cannot use reserved QKEY\"\n\t\t\t\t       \" 0x%x (range 0xffff0000..0xffffffff\"\n\t\t\t\t       \" is reserved)\\n\", attr->qkey);\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontext->qkey = cpu_to_be32(attr->qkey);\n\t\t}\n\t\toptpar |= MLX4_QP_OPTPAR_Q_KEY;\n\t}\n\n\tif (ibsrq)\n\t\tcontext->srqn = cpu_to_be32(1 << 24 |\n\t\t\t\t\t    to_msrq(ibsrq)->msrq.srqn);\n\n\tif (qp->rq.wqe_cnt &&\n\t    cur_state == IB_QPS_RESET &&\n\t    new_state == IB_QPS_INIT)\n\t\tcontext->db_rec_addr = cpu_to_be64(qp->db.dma);\n\n\tif (cur_state == IB_QPS_INIT &&\n\t    new_state == IB_QPS_RTR  &&\n\t    (qp_type == IB_QPT_GSI || qp_type == IB_QPT_SMI ||\n\t     qp_type == IB_QPT_UD || qp_type == IB_QPT_RAW_PACKET)) {\n\t\tcontext->pri_path.sched_queue = (qp->port - 1) << 6;\n\t\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_SMI ||\n\t\t    qp->mlx4_ib_qp_type &\n\t\t    (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER)) {\n\t\t\tcontext->pri_path.sched_queue |= MLX4_IB_DEFAULT_QP0_SCHED_QUEUE;\n\t\t\tif (qp->mlx4_ib_qp_type != MLX4_IB_QPT_SMI)\n\t\t\t\tcontext->pri_path.fl = 0x80;\n\t\t} else {\n\t\t\tif (qp->mlx4_ib_qp_type & MLX4_IB_QPT_ANY_SRIOV)\n\t\t\t\tcontext->pri_path.fl = 0x80;\n\t\t\tcontext->pri_path.sched_queue |= MLX4_IB_DEFAULT_SCHED_QUEUE;\n\t\t}\n\t\tif (rdma_port_get_link_layer(&dev->ib_dev, qp->port) ==\n\t\t    IB_LINK_LAYER_ETHERNET) {\n\t\t\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_TUN_GSI ||\n\t\t\t    qp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI)\n\t\t\t\tcontext->pri_path.feup = 1 << 7;  \n\t\t\t \n\t\t\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_UD ||\n\t\t\t    qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI ||\n\t\t\t    qp->mlx4_ib_qp_type == MLX4_IB_QPT_TUN_GSI) {\n\t\t\t\terr = handle_eth_ud_smac_index(dev, qp, context);\n\t\t\t\tif (err) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI)\n\t\t\t\t\tdev->qp1_proxy[qp->port - 1] = qp;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (qp_type == IB_QPT_RAW_PACKET) {\n\t\tcontext->pri_path.ackto = (context->pri_path.ackto & 0xf8) |\n\t\t\t\t\tMLX4_IB_LINK_TYPE_ETH;\n\t\tif (dev->dev->caps.tunnel_offload_mode ==  MLX4_TUNNEL_OFFLOAD_MODE_VXLAN) {\n\t\t\t \n\t\t\tif (!rwq_ind_tbl)\n\t\t\t\tcontext->srqn = cpu_to_be32(7 << 28);\n\t\t}\n\t}\n\n\tif (qp_type == IB_QPT_UD && (new_state == IB_QPS_RTR)) {\n\t\tint is_eth = rdma_port_get_link_layer(\n\t\t\t\t&dev->ib_dev, qp->port) ==\n\t\t\t\tIB_LINK_LAYER_ETHERNET;\n\t\tif (is_eth) {\n\t\t\tcontext->pri_path.ackto = MLX4_IB_LINK_TYPE_ETH;\n\t\t\toptpar |= MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH;\n\t\t}\n\t}\n\n\tif (cur_state == IB_QPS_RTS && new_state == IB_QPS_SQD\t&&\n\t    attr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY && attr->en_sqd_async_notify)\n\t\tsqd_event = 1;\n\telse\n\t\tsqd_event = 0;\n\n\tif (!ucontext &&\n\t    cur_state == IB_QPS_RESET &&\n\t    new_state == IB_QPS_INIT)\n\t\tcontext->rlkey_roce_mode |= (1 << 4);\n\n\t \n\tif (!ucontext &&\n\t    cur_state == IB_QPS_RESET &&\n\t    new_state == IB_QPS_INIT) {\n\t\tstruct mlx4_wqe_ctrl_seg *ctrl;\n\t\tint i;\n\n\t\tfor (i = 0; i < qp->sq.wqe_cnt; ++i) {\n\t\t\tctrl = get_send_wqe(qp, i);\n\t\t\tctrl->owner_opcode = cpu_to_be32(1 << 31);\n\t\t\tctrl->qpn_vlan.fence_size =\n\t\t\t\t1 << (qp->sq.wqe_shift - 4);\n\t\t\tstamp_send_wqe(qp, i);\n\t\t}\n\t}\n\n\tif (rwq_ind_tbl\t&&\n\t    cur_state == IB_QPS_RESET &&\n\t    new_state == IB_QPS_INIT) {\n\t\tfill_qp_rss_context(context, qp);\n\t\tcontext->flags |= cpu_to_be32(1 << MLX4_RSS_QPC_FLAG_OFFSET);\n\t}\n\n\terr = mlx4_qp_modify(dev->dev, &qp->mtt, to_mlx4_state(cur_state),\n\t\t\t     to_mlx4_state(new_state), context, optpar,\n\t\t\t     sqd_event, &qp->mqp);\n\tif (err)\n\t\tgoto out;\n\n\tqp->state = new_state;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->atomic_rd_en = attr->qp_access_flags;\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tqp->resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT) {\n\t\tqp->port = attr->port_num;\n\t\tupdate_mcg_macs(dev, qp);\n\t}\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->alt_port = attr->alt_port_num;\n\n\tif (is_sqp(dev, qp))\n\t\tstore_sqp_attrs(qp->sqp, attr, attr_mask);\n\n\t \n\tif (is_qp0(dev, qp)) {\n\t\tif (cur_state != IB_QPS_RTR && new_state == IB_QPS_RTR)\n\t\t\tif (mlx4_INIT_PORT(dev->dev, qp->port))\n\t\t\t\tpr_warn(\"INIT_PORT failed for port %d\\n\",\n\t\t\t\t       qp->port);\n\n\t\tif (cur_state != IB_QPS_RESET && cur_state != IB_QPS_ERR &&\n\t\t    (new_state == IB_QPS_RESET || new_state == IB_QPS_ERR))\n\t\t\tmlx4_CLOSE_PORT(dev->dev, qp->port);\n\t}\n\n\t \n\tif (new_state == IB_QPS_RESET) {\n\t\tif (!ucontext) {\n\t\t\tmlx4_ib_cq_clean(recv_cq, qp->mqp.qpn,\n\t\t\t\t\t ibsrq ? to_msrq(ibsrq) : NULL);\n\t\t\tif (send_cq != recv_cq)\n\t\t\t\tmlx4_ib_cq_clean(send_cq, qp->mqp.qpn, NULL);\n\n\t\t\tqp->rq.head = 0;\n\t\t\tqp->rq.tail = 0;\n\t\t\tqp->sq.head = 0;\n\t\t\tqp->sq.tail = 0;\n\t\t\tqp->sq_next_wqe = 0;\n\t\t\tif (qp->rq.wqe_cnt)\n\t\t\t\t*qp->db.db  = 0;\n\n\t\t\tif (qp->flags & MLX4_IB_QP_NETIF)\n\t\t\t\tmlx4_ib_steer_qp_reg(dev, qp, 0);\n\t\t}\n\t\tif (qp->pri.smac || (!qp->pri.smac && qp->pri.smac_port)) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->pri.smac_port, qp->pri.smac);\n\t\t\tqp->pri.smac = 0;\n\t\t\tqp->pri.smac_port = 0;\n\t\t}\n\t\tif (qp->alt.smac) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->alt.smac_port, qp->alt.smac);\n\t\t\tqp->alt.smac = 0;\n\t\t}\n\t\tif (qp->pri.vid < 0x1000) {\n\t\t\tmlx4_unregister_vlan(dev->dev, qp->pri.vlan_port, qp->pri.vid);\n\t\t\tqp->pri.vid = 0xFFFF;\n\t\t\tqp->pri.candidate_vid = 0xFFFF;\n\t\t\tqp->pri.update_vid = 0;\n\t\t}\n\n\t\tif (qp->alt.vid < 0x1000) {\n\t\t\tmlx4_unregister_vlan(dev->dev, qp->alt.vlan_port, qp->alt.vid);\n\t\t\tqp->alt.vid = 0xFFFF;\n\t\t\tqp->alt.candidate_vid = 0xFFFF;\n\t\t\tqp->alt.update_vid = 0;\n\t\t}\n\t}\nout:\n\tif (err && qp->counter_index)\n\t\tmlx4_ib_free_qp_counter(dev, qp);\n\tif (err && steer_qp)\n\t\tmlx4_ib_steer_qp_reg(dev, qp, 0);\n\tkfree(context);\n\tif (qp->pri.candidate_smac ||\n\t    (!qp->pri.candidate_smac && qp->pri.candidate_smac_port)) {\n\t\tif (err) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->pri.candidate_smac_port, qp->pri.candidate_smac);\n\t\t} else {\n\t\t\tif (qp->pri.smac || (!qp->pri.smac && qp->pri.smac_port))\n\t\t\t\tmlx4_unregister_mac(dev->dev, qp->pri.smac_port, qp->pri.smac);\n\t\t\tqp->pri.smac = qp->pri.candidate_smac;\n\t\t\tqp->pri.smac_index = qp->pri.candidate_smac_index;\n\t\t\tqp->pri.smac_port = qp->pri.candidate_smac_port;\n\t\t}\n\t\tqp->pri.candidate_smac = 0;\n\t\tqp->pri.candidate_smac_index = 0;\n\t\tqp->pri.candidate_smac_port = 0;\n\t}\n\tif (qp->alt.candidate_smac) {\n\t\tif (err) {\n\t\t\tmlx4_unregister_mac(dev->dev, qp->alt.candidate_smac_port, qp->alt.candidate_smac);\n\t\t} else {\n\t\t\tif (qp->alt.smac)\n\t\t\t\tmlx4_unregister_mac(dev->dev, qp->alt.smac_port, qp->alt.smac);\n\t\t\tqp->alt.smac = qp->alt.candidate_smac;\n\t\t\tqp->alt.smac_index = qp->alt.candidate_smac_index;\n\t\t\tqp->alt.smac_port = qp->alt.candidate_smac_port;\n\t\t}\n\t\tqp->alt.candidate_smac = 0;\n\t\tqp->alt.candidate_smac_index = 0;\n\t\tqp->alt.candidate_smac_port = 0;\n\t}\n\n\tif (qp->pri.update_vid) {\n\t\tif (err) {\n\t\t\tif (qp->pri.candidate_vid < 0x1000)\n\t\t\t\tmlx4_unregister_vlan(dev->dev, qp->pri.candidate_vlan_port,\n\t\t\t\t\t\t     qp->pri.candidate_vid);\n\t\t} else {\n\t\t\tif (qp->pri.vid < 0x1000)\n\t\t\t\tmlx4_unregister_vlan(dev->dev, qp->pri.vlan_port,\n\t\t\t\t\t\t     qp->pri.vid);\n\t\t\tqp->pri.vid = qp->pri.candidate_vid;\n\t\t\tqp->pri.vlan_port = qp->pri.candidate_vlan_port;\n\t\t\tqp->pri.vlan_index =  qp->pri.candidate_vlan_index;\n\t\t}\n\t\tqp->pri.candidate_vid = 0xFFFF;\n\t\tqp->pri.update_vid = 0;\n\t}\n\n\tif (qp->alt.update_vid) {\n\t\tif (err) {\n\t\t\tif (qp->alt.candidate_vid < 0x1000)\n\t\t\t\tmlx4_unregister_vlan(dev->dev, qp->alt.candidate_vlan_port,\n\t\t\t\t\t\t     qp->alt.candidate_vid);\n\t\t} else {\n\t\t\tif (qp->alt.vid < 0x1000)\n\t\t\t\tmlx4_unregister_vlan(dev->dev, qp->alt.vlan_port,\n\t\t\t\t\t\t     qp->alt.vid);\n\t\t\tqp->alt.vid = qp->alt.candidate_vid;\n\t\t\tqp->alt.vlan_port = qp->alt.candidate_vlan_port;\n\t\t\tqp->alt.vlan_index =  qp->alt.candidate_vlan_index;\n\t\t}\n\t\tqp->alt.candidate_vid = 0xFFFF;\n\t\tqp->alt.update_vid = 0;\n\t}\n\n\treturn err;\n}\n\nenum {\n\tMLX4_IB_MODIFY_QP_RSS_SUP_ATTR_MSK = (IB_QP_STATE\t|\n\t\t\t\t\t      IB_QP_PORT),\n};\n\nstatic int _mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx4_ib_qp *qp = to_mqp(ibqp);\n\tenum ib_qp_state cur_state, new_state;\n\tint err = -EINVAL;\n\tmutex_lock(&qp->mutex);\n\n\tcur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;\n\tnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\n\n\tif (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type,\n\t\t\t\tattr_mask)) {\n\t\tpr_debug(\"qpn 0x%x: invalid attribute mask specified \"\n\t\t\t \"for transition %d to %d. qp_type %d,\"\n\t\t\t \" attr_mask 0x%x\\n\",\n\t\t\t ibqp->qp_num, cur_state, new_state,\n\t\t\t ibqp->qp_type, attr_mask);\n\t\tgoto out;\n\t}\n\n\tif (ibqp->rwq_ind_tbl) {\n\t\tif (!(((cur_state == IB_QPS_RESET) &&\n\t\t       (new_state == IB_QPS_INIT)) ||\n\t\t      ((cur_state == IB_QPS_INIT)  &&\n\t\t       (new_state == IB_QPS_RTR)))) {\n\t\t\tpr_debug(\"qpn 0x%x: RSS QP unsupported transition %d to %d\\n\",\n\t\t\t\t ibqp->qp_num, cur_state, new_state);\n\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (attr_mask & ~MLX4_IB_MODIFY_QP_RSS_SUP_ATTR_MSK) {\n\t\t\tpr_debug(\"qpn 0x%x: RSS QP unsupported attribute mask 0x%x for transition %d to %d\\n\",\n\t\t\t\t ibqp->qp_num, attr_mask, cur_state, new_state);\n\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (mlx4_is_bonded(dev->dev) && (attr_mask & IB_QP_PORT)) {\n\t\tif ((cur_state == IB_QPS_RESET) && (new_state == IB_QPS_INIT)) {\n\t\t\tif ((ibqp->qp_type == IB_QPT_RC) ||\n\t\t\t    (ibqp->qp_type == IB_QPT_UD) ||\n\t\t\t    (ibqp->qp_type == IB_QPT_UC) ||\n\t\t\t    (ibqp->qp_type == IB_QPT_RAW_PACKET) ||\n\t\t\t    (ibqp->qp_type == IB_QPT_XRC_INI)) {\n\t\t\t\tattr->port_num = mlx4_ib_bond_next_port(dev);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tattr_mask &= ~IB_QP_PORT;\n\t\t}\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) &&\n\t    (attr->port_num == 0 || attr->port_num > dev->num_ports)) {\n\t\tpr_debug(\"qpn 0x%x: invalid port number (%d) specified \"\n\t\t\t \"for transition %d to %d. qp_type %d\\n\",\n\t\t\t ibqp->qp_num, attr->port_num, cur_state,\n\t\t\t new_state, ibqp->qp_type);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) && (ibqp->qp_type == IB_QPT_RAW_PACKET) &&\n\t    (rdma_port_get_link_layer(&dev->ib_dev, attr->port_num) !=\n\t     IB_LINK_LAYER_ETHERNET))\n\t\tgoto out;\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tint p = attr_mask & IB_QP_PORT ? attr->port_num : qp->port;\n\t\tif (attr->pkey_index >= dev->dev->caps.pkey_table_len[p]) {\n\t\t\tpr_debug(\"qpn 0x%x: invalid pkey index (%d) specified \"\n\t\t\t\t \"for transition %d to %d. qp_type %d\\n\",\n\t\t\t\t ibqp->qp_num, attr->pkey_index, cur_state,\n\t\t\t\t new_state, ibqp->qp_type);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\n\t    attr->max_rd_atomic > dev->dev->caps.max_qp_init_rdma) {\n\t\tpr_debug(\"qpn 0x%x: max_rd_atomic (%d) too large. \"\n\t\t\t \"Transition %d to %d. qp_type %d\\n\",\n\t\t\t ibqp->qp_num, attr->max_rd_atomic, cur_state,\n\t\t\t new_state, ibqp->qp_type);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\n\t    attr->max_dest_rd_atomic > dev->dev->caps.max_qp_dest_rdma) {\n\t\tpr_debug(\"qpn 0x%x: max_dest_rd_atomic (%d) too large. \"\n\t\t\t \"Transition %d to %d. qp_type %d\\n\",\n\t\t\t ibqp->qp_num, attr->max_dest_rd_atomic, cur_state,\n\t\t\t new_state, ibqp->qp_type);\n\t\tgoto out;\n\t}\n\n\tif (cur_state == new_state && cur_state == IB_QPS_RESET) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\tif (ibqp->rwq_ind_tbl && (new_state == IB_QPS_INIT)) {\n\t\terr = bringup_rss_rwqs(ibqp->rwq_ind_tbl, attr->port_num,\n\t\t\t\t       udata);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = __mlx4_ib_modify_qp(ibqp, MLX4_IB_QP_SRC, attr, attr_mask,\n\t\t\t\t  cur_state, new_state, udata);\n\n\tif (ibqp->rwq_ind_tbl && err)\n\t\tbring_down_rss_rwqs(ibqp->rwq_ind_tbl, udata);\n\n\tif (mlx4_is_bonded(dev->dev) && (attr_mask & IB_QP_PORT))\n\t\tattr->port_num = 1;\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nint mlx4_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_qp *mqp = to_mqp(ibqp);\n\tint ret;\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tret = _mlx4_ib_modify_qp(ibqp, attr, attr_mask, udata);\n\n\tif (mqp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI) {\n\t\tstruct mlx4_ib_sqp *sqp = mqp->sqp;\n\t\tint err = 0;\n\n\t\tif (sqp->roce_v2_gsi)\n\t\t\terr = ib_modify_qp(sqp->roce_v2_gsi, attr, attr_mask);\n\t\tif (err)\n\t\t\tpr_err(\"Failed to modify GSI QP for RoCEv2 (%d)\\n\",\n\t\t\t       err);\n\t}\n\treturn ret;\n}\n\nstatic int vf_get_qp0_qkey(struct mlx4_dev *dev, int qpn, u32 *qkey)\n{\n\tint i;\n\tfor (i = 0; i < dev->caps.num_ports; i++) {\n\t\tif (qpn == dev->caps.spec_qps[i].qp0_proxy ||\n\t\t    qpn == dev->caps.spec_qps[i].qp0_tunnel) {\n\t\t\t*qkey = dev->caps.spec_qps[i].qp0_qkey;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\nstatic int build_sriov_qp0_header(struct mlx4_ib_qp *qp,\n\t\t\t\t  const struct ib_ud_wr *wr,\n\t\t\t\t  void *wqe, unsigned *mlx_seg_len)\n{\n\tstruct mlx4_ib_dev *mdev = to_mdev(qp->ibqp.device);\n\tstruct mlx4_ib_sqp *sqp = qp->sqp;\n\tstruct ib_device *ib_dev = qp->ibqp.device;\n\tstruct mlx4_wqe_mlx_seg *mlx = wqe;\n\tstruct mlx4_wqe_inline_seg *inl = wqe + sizeof *mlx;\n\tstruct mlx4_ib_ah *ah = to_mah(wr->ah);\n\tu16 pkey;\n\tu32 qkey;\n\tint send_size;\n\tint header_size;\n\tint spc;\n\tint err;\n\tint i;\n\n\tif (wr->wr.opcode != IB_WR_SEND)\n\t\treturn -EINVAL;\n\n\tsend_size = 0;\n\n\tfor (i = 0; i < wr->wr.num_sge; ++i)\n\t\tsend_size += wr->wr.sg_list[i].length;\n\n\t \n\t \n\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_SMI_OWNER)\n\t\tsend_size += sizeof (struct mlx4_ib_tunnel_header);\n\n\tib_ud_header_init(send_size, 1, 0, 0, 0, 0, 0, 0, &sqp->ud_header);\n\n\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_SMI_OWNER) {\n\t\tsqp->ud_header.lrh.service_level =\n\t\t\tbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;\n\t\tsqp->ud_header.lrh.destination_lid =\n\t\t\tcpu_to_be16(ah->av.ib.g_slid & 0x7f);\n\t\tsqp->ud_header.lrh.source_lid =\n\t\t\tcpu_to_be16(ah->av.ib.g_slid & 0x7f);\n\t}\n\n\tmlx->flags &= cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\n\n\t \n\tmlx->flags |= cpu_to_be32(MLX4_WQE_MLX_VL15 | 0x1 | MLX4_WQE_MLX_SLR);\n\tmlx->rlid = sqp->ud_header.lrh.destination_lid;\n\n\tsqp->ud_header.lrh.virtual_lane    = 0;\n\tsqp->ud_header.bth.solicited_event = !!(wr->wr.send_flags & IB_SEND_SOLICITED);\n\terr = ib_get_cached_pkey(ib_dev, qp->port, 0, &pkey);\n\tif (err)\n\t\treturn err;\n\tsqp->ud_header.bth.pkey = cpu_to_be16(pkey);\n\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_TUN_SMI_OWNER)\n\t\tsqp->ud_header.bth.destination_qpn = cpu_to_be32(wr->remote_qpn);\n\telse\n\t\tsqp->ud_header.bth.destination_qpn =\n\t\t\tcpu_to_be32(mdev->dev->caps.spec_qps[qp->port - 1].qp0_tunnel);\n\n\tsqp->ud_header.bth.psn = cpu_to_be32((sqp->send_psn++) & ((1 << 24) - 1));\n\tif (mlx4_is_master(mdev->dev)) {\n\t\tif (mlx4_get_parav_qkey(mdev->dev, qp->mqp.qpn, &qkey))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (vf_get_qp0_qkey(mdev->dev, qp->mqp.qpn, &qkey))\n\t\t\treturn -EINVAL;\n\t}\n\tsqp->ud_header.deth.qkey = cpu_to_be32(qkey);\n\tsqp->ud_header.deth.source_qpn = cpu_to_be32(qp->mqp.qpn);\n\n\tsqp->ud_header.bth.opcode        = IB_OPCODE_UD_SEND_ONLY;\n\tsqp->ud_header.immediate_present = 0;\n\n\theader_size = ib_ud_header_pack(&sqp->ud_header, sqp->header_buf);\n\n\t \n\tspc = MLX4_INLINE_ALIGN -\n\t      ((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\n\tif (header_size <= spc) {\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | header_size);\n\t\tmemcpy(inl + 1, sqp->header_buf, header_size);\n\t\ti = 1;\n\t} else {\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | spc);\n\t\tmemcpy(inl + 1, sqp->header_buf, spc);\n\n\t\tinl = (void *) (inl + 1) + spc;\n\t\tmemcpy(inl + 1, sqp->header_buf + spc, header_size - spc);\n\t\t \n\t\twmb();\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | (header_size - spc));\n\t\ti = 2;\n\t}\n\n\t*mlx_seg_len =\n\tALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + header_size, 16);\n\treturn 0;\n}\n\nstatic u8 sl_to_vl(struct mlx4_ib_dev *dev, u8 sl, int port_num)\n{\n\tunion sl2vl_tbl_to_u64 tmp_vltab;\n\tu8 vl;\n\n\tif (sl > 15)\n\t\treturn 0xf;\n\ttmp_vltab.sl64 = atomic64_read(&dev->sl2vl[port_num - 1]);\n\tvl = tmp_vltab.sl8[sl >> 1];\n\tif (sl & 1)\n\t\tvl &= 0x0f;\n\telse\n\t\tvl >>= 4;\n\treturn vl;\n}\n\nstatic int fill_gid_by_hw_index(struct mlx4_ib_dev *ibdev, u8 port_num,\n\t\t\t\tint index, union ib_gid *gid,\n\t\t\t\tenum ib_gid_type *gid_type)\n{\n\tstruct mlx4_ib_iboe *iboe = &ibdev->iboe;\n\tstruct mlx4_port_gid_table *port_gid_table;\n\tunsigned long flags;\n\n\tport_gid_table = &iboe->gids[port_num - 1];\n\tspin_lock_irqsave(&iboe->lock, flags);\n\tmemcpy(gid, &port_gid_table->gids[index].gid, sizeof(*gid));\n\t*gid_type = port_gid_table->gids[index].gid_type;\n\tspin_unlock_irqrestore(&iboe->lock, flags);\n\tif (rdma_is_zero_gid(gid))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\n#define MLX4_ROCEV2_QP1_SPORT 0xC000\nstatic int build_mlx_header(struct mlx4_ib_qp *qp, const struct ib_ud_wr *wr,\n\t\t\t    void *wqe, unsigned *mlx_seg_len)\n{\n\tstruct mlx4_ib_sqp *sqp = qp->sqp;\n\tstruct ib_device *ib_dev = qp->ibqp.device;\n\tstruct mlx4_ib_dev *ibdev = to_mdev(ib_dev);\n\tstruct mlx4_wqe_mlx_seg *mlx = wqe;\n\tstruct mlx4_wqe_ctrl_seg *ctrl = wqe;\n\tstruct mlx4_wqe_inline_seg *inl = wqe + sizeof *mlx;\n\tstruct mlx4_ib_ah *ah = to_mah(wr->ah);\n\tunion ib_gid sgid;\n\tu16 pkey;\n\tint send_size;\n\tint header_size;\n\tint spc;\n\tint i;\n\tint err = 0;\n\tu16 vlan = 0xffff;\n\tbool is_eth;\n\tbool is_vlan = false;\n\tbool is_grh;\n\tbool is_udp = false;\n\tint ip_version = 0;\n\n\tsend_size = 0;\n\tfor (i = 0; i < wr->wr.num_sge; ++i)\n\t\tsend_size += wr->wr.sg_list[i].length;\n\n\tis_eth = rdma_port_get_link_layer(qp->ibqp.device, qp->port) == IB_LINK_LAYER_ETHERNET;\n\tis_grh = mlx4_ib_ah_grh_present(ah);\n\tif (is_eth) {\n\t\tenum ib_gid_type gid_type;\n\t\tif (mlx4_is_mfunc(to_mdev(ib_dev)->dev)) {\n\t\t\t \n\t\t\terr = mlx4_get_roce_gid_from_slave(to_mdev(ib_dev)->dev,\n\t\t\t\t\t\t\t   be32_to_cpu(ah->av.ib.port_pd) >> 24,\n\t\t\t\t\t\t\t   ah->av.ib.gid_index, &sgid.raw[0]);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else  {\n\t\t\terr = fill_gid_by_hw_index(ibdev, qp->port,\n\t\t\t\t\t\t   ah->av.ib.gid_index, &sgid,\n\t\t\t\t\t\t   &gid_type);\n\t\t\tif (!err) {\n\t\t\t\tis_udp = gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP;\n\t\t\t\tif (is_udp) {\n\t\t\t\t\tif (ipv6_addr_v4mapped((struct in6_addr *)&sgid))\n\t\t\t\t\t\tip_version = 4;\n\t\t\t\t\telse\n\t\t\t\t\t\tip_version = 6;\n\t\t\t\t\tis_grh = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tif (ah->av.eth.vlan != cpu_to_be16(0xffff)) {\n\t\t\tvlan = be16_to_cpu(ah->av.eth.vlan) & 0x0fff;\n\t\t\tis_vlan = true;\n\t\t}\n\t}\n\terr = ib_ud_header_init(send_size, !is_eth, is_eth, is_vlan, is_grh,\n\t\t\t  ip_version, is_udp, 0, &sqp->ud_header);\n\tif (err)\n\t\treturn err;\n\n\tif (!is_eth) {\n\t\tsqp->ud_header.lrh.service_level =\n\t\t\tbe32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 28;\n\t\tsqp->ud_header.lrh.destination_lid = ah->av.ib.dlid;\n\t\tsqp->ud_header.lrh.source_lid = cpu_to_be16(ah->av.ib.g_slid & 0x7f);\n\t}\n\n\tif (is_grh || (ip_version == 6)) {\n\t\tsqp->ud_header.grh.traffic_class =\n\t\t\t(be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 20) & 0xff;\n\t\tsqp->ud_header.grh.flow_label    =\n\t\t\tah->av.ib.sl_tclass_flowlabel & cpu_to_be32(0xfffff);\n\t\tsqp->ud_header.grh.hop_limit     = ah->av.ib.hop_limit;\n\t\tif (is_eth) {\n\t\t\tmemcpy(sqp->ud_header.grh.source_gid.raw, sgid.raw, 16);\n\t\t} else {\n\t\t\tif (mlx4_is_mfunc(to_mdev(ib_dev)->dev)) {\n\t\t\t\t \n\t\t\t\tsqp->ud_header.grh.source_gid.global\n\t\t\t\t\t.subnet_prefix =\n\t\t\t\t\tcpu_to_be64(atomic64_read(\n\t\t\t\t\t\t&(to_mdev(ib_dev)\n\t\t\t\t\t\t\t  ->sriov\n\t\t\t\t\t\t\t  .demux[qp->port - 1]\n\t\t\t\t\t\t\t  .subnet_prefix)));\n\t\t\t\tsqp->ud_header.grh.source_gid.global\n\t\t\t\t\t.interface_id =\n\t\t\t\t\tto_mdev(ib_dev)\n\t\t\t\t\t\t->sriov.demux[qp->port - 1]\n\t\t\t\t\t\t.guid_cache[ah->av.ib.gid_index];\n\t\t\t} else {\n\t\t\t\tsqp->ud_header.grh.source_gid =\n\t\t\t\t\tah->ibah.sgid_attr->gid;\n\t\t\t}\n\t\t}\n\t\tmemcpy(sqp->ud_header.grh.destination_gid.raw,\n\t\t       ah->av.ib.dgid, 16);\n\t}\n\n\tif (ip_version == 4) {\n\t\tsqp->ud_header.ip4.tos =\n\t\t\t(be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 20) & 0xff;\n\t\tsqp->ud_header.ip4.id = 0;\n\t\tsqp->ud_header.ip4.frag_off = htons(IP_DF);\n\t\tsqp->ud_header.ip4.ttl = ah->av.eth.hop_limit;\n\n\t\tmemcpy(&sqp->ud_header.ip4.saddr,\n\t\t       sgid.raw + 12, 4);\n\t\tmemcpy(&sqp->ud_header.ip4.daddr, ah->av.ib.dgid + 12, 4);\n\t\tsqp->ud_header.ip4.check = ib_ud_ip4_csum(&sqp->ud_header);\n\t}\n\n\tif (is_udp) {\n\t\tsqp->ud_header.udp.dport = htons(ROCE_V2_UDP_DPORT);\n\t\tsqp->ud_header.udp.sport = htons(MLX4_ROCEV2_QP1_SPORT);\n\t\tsqp->ud_header.udp.csum = 0;\n\t}\n\n\tmlx->flags &= cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE);\n\n\tif (!is_eth) {\n\t\tmlx->flags |=\n\t\t\tcpu_to_be32((!qp->ibqp.qp_num ? MLX4_WQE_MLX_VL15 : 0) |\n\t\t\t\t    (sqp->ud_header.lrh.destination_lid ==\n\t\t\t\t\t\t     IB_LID_PERMISSIVE ?\n\t\t\t\t\t     MLX4_WQE_MLX_SLR :\n\t\t\t\t\t     0) |\n\t\t\t\t    (sqp->ud_header.lrh.service_level << 8));\n\t\tif (ah->av.ib.port_pd & cpu_to_be32(0x80000000))\n\t\t\tmlx->flags |= cpu_to_be32(0x1);  \n\t\tmlx->rlid = sqp->ud_header.lrh.destination_lid;\n\t}\n\n\tswitch (wr->wr.opcode) {\n\tcase IB_WR_SEND:\n\t\tsqp->ud_header.bth.opcode\t = IB_OPCODE_UD_SEND_ONLY;\n\t\tsqp->ud_header.immediate_present = 0;\n\t\tbreak;\n\tcase IB_WR_SEND_WITH_IMM:\n\t\tsqp->ud_header.bth.opcode\t = IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE;\n\t\tsqp->ud_header.immediate_present = 1;\n\t\tsqp->ud_header.immediate_data    = wr->wr.ex.imm_data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (is_eth) {\n\t\tu16 ether_type;\n\t\tu16 pcp = (be32_to_cpu(ah->av.ib.sl_tclass_flowlabel) >> 29) << 13;\n\n\t\tether_type = (!is_udp) ? ETH_P_IBOE:\n\t\t\t(ip_version == 4 ? ETH_P_IP : ETH_P_IPV6);\n\n\t\tmlx->sched_prio = cpu_to_be16(pcp);\n\n\t\tether_addr_copy(sqp->ud_header.eth.smac_h, ah->av.eth.s_mac);\n\t\tether_addr_copy(sqp->ud_header.eth.dmac_h, ah->av.eth.mac);\n\t\tmemcpy(&ctrl->srcrb_flags16[0], ah->av.eth.mac, 2);\n\t\tmemcpy(&ctrl->imm, ah->av.eth.mac + 2, 4);\n\n\t\tif (!memcmp(sqp->ud_header.eth.smac_h, sqp->ud_header.eth.dmac_h, 6))\n\t\t\tmlx->flags |= cpu_to_be32(MLX4_WQE_CTRL_FORCE_LOOPBACK);\n\t\tif (!is_vlan) {\n\t\t\tsqp->ud_header.eth.type = cpu_to_be16(ether_type);\n\t\t} else {\n\t\t\tsqp->ud_header.vlan.type = cpu_to_be16(ether_type);\n\t\t\tsqp->ud_header.vlan.tag = cpu_to_be16(vlan | pcp);\n\t\t}\n\t} else {\n\t\tsqp->ud_header.lrh.virtual_lane =\n\t\t\t!qp->ibqp.qp_num ?\n\t\t\t\t15 :\n\t\t\t\tsl_to_vl(to_mdev(ib_dev),\n\t\t\t\t\t sqp->ud_header.lrh.service_level,\n\t\t\t\t\t qp->port);\n\t\tif (qp->ibqp.qp_num && sqp->ud_header.lrh.virtual_lane == 15)\n\t\t\treturn -EINVAL;\n\t\tif (sqp->ud_header.lrh.destination_lid == IB_LID_PERMISSIVE)\n\t\t\tsqp->ud_header.lrh.source_lid = IB_LID_PERMISSIVE;\n\t}\n\tsqp->ud_header.bth.solicited_event = !!(wr->wr.send_flags & IB_SEND_SOLICITED);\n\tif (!qp->ibqp.qp_num)\n\t\terr = ib_get_cached_pkey(ib_dev, qp->port, sqp->pkey_index,\n\t\t\t\t\t &pkey);\n\telse\n\t\terr = ib_get_cached_pkey(ib_dev, qp->port, wr->pkey_index,\n\t\t\t\t\t &pkey);\n\tif (err)\n\t\treturn err;\n\n\tsqp->ud_header.bth.pkey = cpu_to_be16(pkey);\n\tsqp->ud_header.bth.destination_qpn = cpu_to_be32(wr->remote_qpn);\n\tsqp->ud_header.bth.psn = cpu_to_be32((sqp->send_psn++) & ((1 << 24) - 1));\n\tsqp->ud_header.deth.qkey = cpu_to_be32(wr->remote_qkey & 0x80000000 ?\n\t\t\t\t\t       sqp->qkey : wr->remote_qkey);\n\tsqp->ud_header.deth.source_qpn = cpu_to_be32(qp->ibqp.qp_num);\n\n\theader_size = ib_ud_header_pack(&sqp->ud_header, sqp->header_buf);\n\n\tif (0) {\n\t\tpr_err(\"built UD header of size %d:\\n\", header_size);\n\t\tfor (i = 0; i < header_size / 4; ++i) {\n\t\t\tif (i % 8 == 0)\n\t\t\t\tpr_err(\"  [%02x] \", i * 4);\n\t\t\tpr_cont(\" %08x\",\n\t\t\t\tbe32_to_cpu(((__be32 *) sqp->header_buf)[i]));\n\t\t\tif ((i + 1) % 8 == 0)\n\t\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\tpr_err(\"\\n\");\n\t}\n\n\t \n\tspc = MLX4_INLINE_ALIGN -\n\t\t((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\n\tif (header_size <= spc) {\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | header_size);\n\t\tmemcpy(inl + 1, sqp->header_buf, header_size);\n\t\ti = 1;\n\t} else {\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | spc);\n\t\tmemcpy(inl + 1, sqp->header_buf, spc);\n\n\t\tinl = (void *) (inl + 1) + spc;\n\t\tmemcpy(inl + 1, sqp->header_buf + spc, header_size - spc);\n\t\t \n\t\twmb();\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | (header_size - spc));\n\t\ti = 2;\n\t}\n\n\t*mlx_seg_len =\n\t\tALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + header_size, 16);\n\treturn 0;\n}\n\nstatic int mlx4_wq_overflow(struct mlx4_ib_wq *wq, int nreq, struct ib_cq *ib_cq)\n{\n\tunsigned cur;\n\tstruct mlx4_ib_cq *cq;\n\n\tcur = wq->head - wq->tail;\n\tif (likely(cur + nreq < wq->max_post))\n\t\treturn 0;\n\n\tcq = to_mcq(ib_cq);\n\tspin_lock(&cq->lock);\n\tcur = wq->head - wq->tail;\n\tspin_unlock(&cq->lock);\n\n\treturn cur + nreq >= wq->max_post;\n}\n\nstatic __be32 convert_access(int acc)\n{\n\treturn (acc & IB_ACCESS_REMOTE_ATOMIC ?\n\t\tcpu_to_be32(MLX4_WQE_FMR_AND_BIND_PERM_ATOMIC)       : 0) |\n\t       (acc & IB_ACCESS_REMOTE_WRITE  ?\n\t\tcpu_to_be32(MLX4_WQE_FMR_AND_BIND_PERM_REMOTE_WRITE) : 0) |\n\t       (acc & IB_ACCESS_REMOTE_READ   ?\n\t\tcpu_to_be32(MLX4_WQE_FMR_AND_BIND_PERM_REMOTE_READ)  : 0) |\n\t       (acc & IB_ACCESS_LOCAL_WRITE   ? cpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_WRITE)  : 0) |\n\t\tcpu_to_be32(MLX4_WQE_FMR_PERM_LOCAL_READ);\n}\n\nstatic void set_reg_seg(struct mlx4_wqe_fmr_seg *fseg,\n\t\t\tconst struct ib_reg_wr *wr)\n{\n\tstruct mlx4_ib_mr *mr = to_mmr(wr->mr);\n\n\tfseg->flags\t\t= convert_access(wr->access);\n\tfseg->mem_key\t\t= cpu_to_be32(wr->key);\n\tfseg->buf_list\t\t= cpu_to_be64(mr->page_map);\n\tfseg->start_addr\t= cpu_to_be64(mr->ibmr.iova);\n\tfseg->reg_len\t\t= cpu_to_be64(mr->ibmr.length);\n\tfseg->offset\t\t= 0;  \n\tfseg->page_size\t\t= cpu_to_be32(ilog2(mr->ibmr.page_size));\n\tfseg->reserved[0]\t= 0;\n\tfseg->reserved[1]\t= 0;\n}\n\nstatic void set_local_inv_seg(struct mlx4_wqe_local_inval_seg *iseg, u32 rkey)\n{\n\tmemset(iseg, 0, sizeof(*iseg));\n\tiseg->mem_key = cpu_to_be32(rkey);\n}\n\nstatic __always_inline void set_raddr_seg(struct mlx4_wqe_raddr_seg *rseg,\n\t\t\t\t\t  u64 remote_addr, u32 rkey)\n{\n\trseg->raddr    = cpu_to_be64(remote_addr);\n\trseg->rkey     = cpu_to_be32(rkey);\n\trseg->reserved = 0;\n}\n\nstatic void set_atomic_seg(struct mlx4_wqe_atomic_seg *aseg,\n\t\t\t   const struct ib_atomic_wr *wr)\n{\n\tif (wr->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP) {\n\t\taseg->swap_add = cpu_to_be64(wr->swap);\n\t\taseg->compare  = cpu_to_be64(wr->compare_add);\n\t} else if (wr->wr.opcode == IB_WR_MASKED_ATOMIC_FETCH_AND_ADD) {\n\t\taseg->swap_add = cpu_to_be64(wr->compare_add);\n\t\taseg->compare  = cpu_to_be64(wr->compare_add_mask);\n\t} else {\n\t\taseg->swap_add = cpu_to_be64(wr->compare_add);\n\t\taseg->compare  = 0;\n\t}\n\n}\n\nstatic void set_masked_atomic_seg(struct mlx4_wqe_masked_atomic_seg *aseg,\n\t\t\t\t  const struct ib_atomic_wr *wr)\n{\n\taseg->swap_add\t\t= cpu_to_be64(wr->swap);\n\taseg->swap_add_mask\t= cpu_to_be64(wr->swap_mask);\n\taseg->compare\t\t= cpu_to_be64(wr->compare_add);\n\taseg->compare_mask\t= cpu_to_be64(wr->compare_add_mask);\n}\n\nstatic void set_datagram_seg(struct mlx4_wqe_datagram_seg *dseg,\n\t\t\t     const struct ib_ud_wr *wr)\n{\n\tmemcpy(dseg->av, &to_mah(wr->ah)->av, sizeof (struct mlx4_av));\n\tdseg->dqpn = cpu_to_be32(wr->remote_qpn);\n\tdseg->qkey = cpu_to_be32(wr->remote_qkey);\n\tdseg->vlan = to_mah(wr->ah)->av.eth.vlan;\n\tmemcpy(dseg->mac, to_mah(wr->ah)->av.eth.mac, 6);\n}\n\nstatic void set_tunnel_datagram_seg(struct mlx4_ib_dev *dev,\n\t\t\t\t    struct mlx4_wqe_datagram_seg *dseg,\n\t\t\t\t    const struct ib_ud_wr *wr,\n\t\t\t\t    enum mlx4_ib_qp_type qpt)\n{\n\tunion mlx4_ext_av *av = &to_mah(wr->ah)->av;\n\tstruct mlx4_av sqp_av = {0};\n\tint port = *((u8 *) &av->ib.port_pd) & 0x3;\n\n\t \n\tsqp_av.port_pd = av->ib.port_pd | cpu_to_be32(0x80000000);\n\tsqp_av.g_slid = av->ib.g_slid & 0x7f;  \n\tsqp_av.sl_tclass_flowlabel = av->ib.sl_tclass_flowlabel &\n\t\t\tcpu_to_be32(0xf0000000);\n\n\tmemcpy(dseg->av, &sqp_av, sizeof (struct mlx4_av));\n\tif (qpt == MLX4_IB_QPT_PROXY_GSI)\n\t\tdseg->dqpn = cpu_to_be32(dev->dev->caps.spec_qps[port - 1].qp1_tunnel);\n\telse\n\t\tdseg->dqpn = cpu_to_be32(dev->dev->caps.spec_qps[port - 1].qp0_tunnel);\n\t \n\tdseg->qkey = cpu_to_be32(IB_QP_SET_QKEY);\n}\n\nstatic void build_tunnel_header(const struct ib_ud_wr *wr, void *wqe,\n\t\t\t\tunsigned *mlx_seg_len)\n{\n\tstruct mlx4_wqe_inline_seg *inl = wqe;\n\tstruct mlx4_ib_tunnel_header hdr;\n\tstruct mlx4_ib_ah *ah = to_mah(wr->ah);\n\tint spc;\n\tint i;\n\n\tmemcpy(&hdr.av, &ah->av, sizeof hdr.av);\n\thdr.remote_qpn = cpu_to_be32(wr->remote_qpn);\n\thdr.pkey_index = cpu_to_be16(wr->pkey_index);\n\thdr.qkey = cpu_to_be32(wr->remote_qkey);\n\tmemcpy(hdr.mac, ah->av.eth.mac, 6);\n\thdr.vlan = ah->av.eth.vlan;\n\n\tspc = MLX4_INLINE_ALIGN -\n\t\t((unsigned long) (inl + 1) & (MLX4_INLINE_ALIGN - 1));\n\tif (sizeof (hdr) <= spc) {\n\t\tmemcpy(inl + 1, &hdr, sizeof (hdr));\n\t\twmb();\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | sizeof (hdr));\n\t\ti = 1;\n\t} else {\n\t\tmemcpy(inl + 1, &hdr, spc);\n\t\twmb();\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | spc);\n\n\t\tinl = (void *) (inl + 1) + spc;\n\t\tmemcpy(inl + 1, (void *) &hdr + spc, sizeof (hdr) - spc);\n\t\twmb();\n\t\tinl->byte_count = cpu_to_be32(1 << 31 | (sizeof (hdr) - spc));\n\t\ti = 2;\n\t}\n\n\t*mlx_seg_len =\n\t\tALIGN(i * sizeof (struct mlx4_wqe_inline_seg) + sizeof (hdr), 16);\n}\n\nstatic void set_mlx_icrc_seg(void *dseg)\n{\n\tu32 *t = dseg;\n\tstruct mlx4_wqe_inline_seg *iseg = dseg;\n\n\tt[1] = 0;\n\n\t \n\twmb();\n\n\tiseg->byte_count = cpu_to_be32((1 << 31) | 4);\n}\n\nstatic void set_data_seg(struct mlx4_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n\n\t \n\twmb();\n\n\tdseg->byte_count = cpu_to_be32(sg->length);\n}\n\nstatic void __set_data_seg(struct mlx4_wqe_data_seg *dseg, struct ib_sge *sg)\n{\n\tdseg->byte_count = cpu_to_be32(sg->length);\n\tdseg->lkey       = cpu_to_be32(sg->lkey);\n\tdseg->addr       = cpu_to_be64(sg->addr);\n}\n\nstatic int build_lso_seg(struct mlx4_wqe_lso_seg *wqe,\n\t\t\t const struct ib_ud_wr *wr, struct mlx4_ib_qp *qp,\n\t\t\t unsigned *lso_seg_len, __be32 *lso_hdr_sz, __be32 *blh)\n{\n\tunsigned halign = ALIGN(sizeof *wqe + wr->hlen, 16);\n\n\tif (unlikely(halign > MLX4_IB_CACHE_LINE_SIZE))\n\t\t*blh = cpu_to_be32(1 << 6);\n\n\tif (unlikely(!(qp->flags & MLX4_IB_QP_LSO) &&\n\t\t     wr->wr.num_sge > qp->sq.max_gs - (halign >> 4)))\n\t\treturn -EINVAL;\n\n\tmemcpy(wqe->header, wr->header, wr->hlen);\n\n\t*lso_hdr_sz  = cpu_to_be32(wr->mss << 16 | wr->hlen);\n\t*lso_seg_len = halign;\n\treturn 0;\n}\n\nstatic __be32 send_ieth(const struct ib_send_wr *wr)\n{\n\tswitch (wr->opcode) {\n\tcase IB_WR_SEND_WITH_IMM:\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\treturn wr->ex.imm_data;\n\n\tcase IB_WR_SEND_WITH_INV:\n\t\treturn cpu_to_be32(wr->ex.invalidate_rkey);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void add_zero_len_inline(void *wqe)\n{\n\tstruct mlx4_wqe_inline_seg *inl = wqe;\n\tmemset(wqe, 0, 16);\n\tinl->byte_count = cpu_to_be32(1 << 31);\n}\n\nstatic int _mlx4_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t\t      const struct ib_send_wr **bad_wr, bool drain)\n{\n\tstruct mlx4_ib_qp *qp = to_mqp(ibqp);\n\tvoid *wqe;\n\tstruct mlx4_wqe_ctrl_seg *ctrl;\n\tstruct mlx4_wqe_data_seg *dseg;\n\tunsigned long flags;\n\tint nreq;\n\tint err = 0;\n\tunsigned ind;\n\tint size;\n\tunsigned seglen;\n\t__be32 dummy;\n\t__be32 *lso_wqe;\n\t__be32 lso_hdr_sz;\n\t__be32 blh;\n\tint i;\n\tstruct mlx4_ib_dev *mdev = to_mdev(ibqp->device);\n\n\tif (qp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI) {\n\t\tstruct mlx4_ib_sqp *sqp = qp->sqp;\n\n\t\tif (sqp->roce_v2_gsi) {\n\t\t\tstruct mlx4_ib_ah *ah = to_mah(ud_wr(wr)->ah);\n\t\t\tenum ib_gid_type gid_type;\n\t\t\tunion ib_gid gid;\n\n\t\t\tif (!fill_gid_by_hw_index(mdev, qp->port,\n\t\t\t\t\t   ah->av.ib.gid_index,\n\t\t\t\t\t   &gid, &gid_type))\n\t\t\t\tqp = (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP) ?\n\t\t\t\t\t\tto_mqp(sqp->roce_v2_gsi) : qp;\n\t\t\telse\n\t\t\t\tpr_err(\"Failed to get gid at index %d. RoCEv2 will not work properly\\n\",\n\t\t\t\t       ah->av.ib.gid_index);\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\tif (mdev->dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR &&\n\t    !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tind = qp->sq_next_wqe;\n\n\tfor (nreq = 0; wr; ++nreq, wr = wr->next) {\n\t\tlso_wqe = &dummy;\n\t\tblh = 0;\n\n\t\tif (mlx4_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)) {\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (unlikely(wr->num_sge > qp->sq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tctrl = wqe = get_send_wqe(qp, ind & (qp->sq.wqe_cnt - 1));\n\t\tqp->sq.wrid[(qp->sq.head + nreq) & (qp->sq.wqe_cnt - 1)] = wr->wr_id;\n\n\t\tctrl->srcrb_flags =\n\t\t\t(wr->send_flags & IB_SEND_SIGNALED ?\n\t\t\t cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE) : 0) |\n\t\t\t(wr->send_flags & IB_SEND_SOLICITED ?\n\t\t\t cpu_to_be32(MLX4_WQE_CTRL_SOLICITED) : 0) |\n\t\t\t((wr->send_flags & IB_SEND_IP_CSUM) ?\n\t\t\t cpu_to_be32(MLX4_WQE_CTRL_IP_CSUM |\n\t\t\t\t     MLX4_WQE_CTRL_TCP_UDP_CSUM) : 0) |\n\t\t\tqp->sq_signal_bits;\n\n\t\tctrl->imm = send_ieth(wr);\n\n\t\twqe += sizeof *ctrl;\n\t\tsize = sizeof *ctrl / 16;\n\n\t\tswitch (qp->mlx4_ib_qp_type) {\n\t\tcase MLX4_IB_QPT_RC:\n\t\tcase MLX4_IB_QPT_UC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\tcase IB_WR_MASKED_ATOMIC_FETCH_AND_ADD:\n\t\t\t\tset_raddr_seg(wqe, atomic_wr(wr)->remote_addr,\n\t\t\t\t\t      atomic_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_raddr_seg);\n\n\t\t\t\tset_atomic_seg(wqe, atomic_wr(wr));\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_atomic_seg);\n\n\t\t\t\tsize += (sizeof (struct mlx4_wqe_raddr_seg) +\n\t\t\t\t\t sizeof (struct mlx4_wqe_atomic_seg)) / 16;\n\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_MASKED_ATOMIC_CMP_AND_SWP:\n\t\t\t\tset_raddr_seg(wqe, atomic_wr(wr)->remote_addr,\n\t\t\t\t\t      atomic_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_raddr_seg);\n\n\t\t\t\tset_masked_atomic_seg(wqe, atomic_wr(wr));\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_masked_atomic_seg);\n\n\t\t\t\tsize += (sizeof (struct mlx4_wqe_raddr_seg) +\n\t\t\t\t\t sizeof (struct mlx4_wqe_masked_atomic_seg)) / 16;\n\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_RDMA_READ:\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(wqe, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_raddr_seg);\n\t\t\t\tsize += sizeof (struct mlx4_wqe_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_LOCAL_INV:\n\t\t\t\tctrl->srcrb_flags |=\n\t\t\t\t\tcpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);\n\t\t\t\tset_local_inv_seg(wqe, wr->ex.invalidate_rkey);\n\t\t\t\twqe  += sizeof (struct mlx4_wqe_local_inval_seg);\n\t\t\t\tsize += sizeof (struct mlx4_wqe_local_inval_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_REG_MR:\n\t\t\t\tctrl->srcrb_flags |=\n\t\t\t\t\tcpu_to_be32(MLX4_WQE_CTRL_STRONG_ORDER);\n\t\t\t\tset_reg_seg(wqe, reg_wr(wr));\n\t\t\t\twqe  += sizeof(struct mlx4_wqe_fmr_seg);\n\t\t\t\tsize += sizeof(struct mlx4_wqe_fmr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MLX4_IB_QPT_TUN_SMI_OWNER:\n\t\t\terr = build_sriov_qp0_header(qp, ud_wr(wr), ctrl,\n\t\t\t\t\t\t     &seglen);\n\t\t\tif (unlikely(err)) {\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twqe  += seglen;\n\t\t\tsize += seglen / 16;\n\t\t\tbreak;\n\t\tcase MLX4_IB_QPT_TUN_SMI:\n\t\tcase MLX4_IB_QPT_TUN_GSI:\n\t\t\t \n\t\t\tset_datagram_seg(wqe, ud_wr(wr));\n\t\t\t \n\t\t\t*(__be32 *) wqe |= cpu_to_be32(0x80000000);\n\t\t\twqe  += sizeof (struct mlx4_wqe_datagram_seg);\n\t\t\tsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\n\t\t\tbreak;\n\t\tcase MLX4_IB_QPT_UD:\n\t\t\tset_datagram_seg(wqe, ud_wr(wr));\n\t\t\twqe  += sizeof (struct mlx4_wqe_datagram_seg);\n\t\t\tsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\n\n\t\t\tif (wr->opcode == IB_WR_LSO) {\n\t\t\t\terr = build_lso_seg(wqe, ud_wr(wr), qp, &seglen,\n\t\t\t\t\t\t&lso_hdr_sz, &blh);\n\t\t\t\tif (unlikely(err)) {\n\t\t\t\t\t*bad_wr = wr;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tlso_wqe = (__be32 *) wqe;\n\t\t\t\twqe  += seglen;\n\t\t\t\tsize += seglen / 16;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase MLX4_IB_QPT_PROXY_SMI_OWNER:\n\t\t\terr = build_sriov_qp0_header(qp, ud_wr(wr), ctrl,\n\t\t\t\t\t\t     &seglen);\n\t\t\tif (unlikely(err)) {\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twqe  += seglen;\n\t\t\tsize += seglen / 16;\n\t\t\t \n\t\t\tadd_zero_len_inline(wqe);\n\t\t\twqe += 16;\n\t\t\tsize++;\n\t\t\tbuild_tunnel_header(ud_wr(wr), wqe, &seglen);\n\t\t\twqe  += seglen;\n\t\t\tsize += seglen / 16;\n\t\t\tbreak;\n\t\tcase MLX4_IB_QPT_PROXY_SMI:\n\t\tcase MLX4_IB_QPT_PROXY_GSI:\n\t\t\t \n\t\t\tset_tunnel_datagram_seg(to_mdev(ibqp->device), wqe,\n\t\t\t\t\t\tud_wr(wr),\n\t\t\t\t\t\tqp->mlx4_ib_qp_type);\n\t\t\twqe  += sizeof (struct mlx4_wqe_datagram_seg);\n\t\t\tsize += sizeof (struct mlx4_wqe_datagram_seg) / 16;\n\t\t\tbuild_tunnel_header(ud_wr(wr), wqe, &seglen);\n\t\t\twqe  += seglen;\n\t\t\tsize += seglen / 16;\n\t\t\tbreak;\n\n\t\tcase MLX4_IB_QPT_SMI:\n\t\tcase MLX4_IB_QPT_GSI:\n\t\t\terr = build_mlx_header(qp, ud_wr(wr), ctrl, &seglen);\n\t\t\tif (unlikely(err)) {\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twqe  += seglen;\n\t\t\tsize += seglen / 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\n\t\tdseg = wqe;\n\t\tdseg += wr->num_sge - 1;\n\t\tsize += wr->num_sge * (sizeof (struct mlx4_wqe_data_seg) / 16);\n\n\t\t \n\t\tif (unlikely(qp->mlx4_ib_qp_type == MLX4_IB_QPT_SMI ||\n\t\t\t     qp->mlx4_ib_qp_type == MLX4_IB_QPT_GSI ||\n\t\t\t     qp->mlx4_ib_qp_type &\n\t\t\t     (MLX4_IB_QPT_PROXY_SMI_OWNER | MLX4_IB_QPT_TUN_SMI_OWNER))) {\n\t\t\tset_mlx_icrc_seg(dseg + 1);\n\t\t\tsize += sizeof (struct mlx4_wqe_data_seg) / 16;\n\t\t}\n\n\t\tfor (i = wr->num_sge - 1; i >= 0; --i, --dseg)\n\t\t\tset_data_seg(dseg, wr->sg_list + i);\n\n\t\t \n\t\twmb();\n\t\t*lso_wqe = lso_hdr_sz;\n\n\t\tctrl->qpn_vlan.fence_size = (wr->send_flags & IB_SEND_FENCE ?\n\t\t\t\t\t     MLX4_WQE_CTRL_FENCE : 0) | size;\n\n\t\t \n\t\twmb();\n\n\t\tif (wr->opcode < 0 || wr->opcode >= ARRAY_SIZE(mlx4_ib_opcode)) {\n\t\t\t*bad_wr = wr;\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tctrl->owner_opcode = mlx4_ib_opcode[wr->opcode] |\n\t\t\t(ind & qp->sq.wqe_cnt ? cpu_to_be32(1 << 31) : 0) | blh;\n\n\t\t \n\t\tif (wr->next)\n\t\t\tstamp_send_wqe(qp, ind + qp->sq_spare_wqes);\n\t\tind++;\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->sq.head += nreq;\n\n\t\t \n\t\twmb();\n\n\t\twritel_relaxed(qp->doorbell_qpn,\n\t\t\tto_mdev(ibqp->device)->uar_map + MLX4_SEND_DOORBELL);\n\n\t\tstamp_send_wqe(qp, ind + qp->sq_spare_wqes - 1);\n\n\t\tqp->sq_next_wqe = ind;\n\t}\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\n\treturn err;\n}\n\nint mlx4_ib_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t      const struct ib_send_wr **bad_wr)\n{\n\treturn _mlx4_ib_post_send(ibqp, wr, bad_wr, false);\n}\n\nstatic int _mlx4_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t\t      const struct ib_recv_wr **bad_wr, bool drain)\n{\n\tstruct mlx4_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx4_wqe_data_seg *scat;\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint ind;\n\tint max_gs;\n\tint i;\n\tstruct mlx4_ib_dev *mdev = to_mdev(ibqp->device);\n\n\tmax_gs = qp->rq.max_gs;\n\tspin_lock_irqsave(&qp->rq.lock, flags);\n\n\tif (mdev->dev->persist->state & MLX4_DEVICE_STATE_INTERNAL_ERROR &&\n\t    !drain) {\n\t\terr = -EIO;\n\t\t*bad_wr = wr;\n\t\tnreq = 0;\n\t\tgoto out;\n\t}\n\n\tind = qp->rq.head & (qp->rq.wqe_cnt - 1);\n\n\tfor (nreq = 0; wr; ++nreq, wr = wr->next) {\n\t\tif (mlx4_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (unlikely(wr->num_sge > qp->rq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tscat = get_recv_wqe(qp, ind);\n\n\t\tif (qp->mlx4_ib_qp_type & (MLX4_IB_QPT_PROXY_SMI_OWNER |\n\t\t    MLX4_IB_QPT_PROXY_SMI | MLX4_IB_QPT_PROXY_GSI)) {\n\t\t\tib_dma_sync_single_for_device(ibqp->device,\n\t\t\t\t\t\t      qp->sqp_proxy_rcv[ind].map,\n\t\t\t\t\t\t      sizeof (struct mlx4_ib_proxy_sqp_hdr),\n\t\t\t\t\t\t      DMA_FROM_DEVICE);\n\t\t\tscat->byte_count =\n\t\t\t\tcpu_to_be32(sizeof (struct mlx4_ib_proxy_sqp_hdr));\n\t\t\t \n\t\t\tscat->lkey = cpu_to_be32(wr->sg_list->lkey);\n\t\t\tscat->addr = cpu_to_be64(qp->sqp_proxy_rcv[ind].map);\n\t\t\tscat++;\n\t\t\tmax_gs--;\n\t\t}\n\n\t\tfor (i = 0; i < wr->num_sge; ++i)\n\t\t\t__set_data_seg(scat + i, wr->sg_list + i);\n\n\t\tif (i < max_gs) {\n\t\t\tscat[i].byte_count = 0;\n\t\t\tscat[i].lkey       = cpu_to_be32(MLX4_INVALID_LKEY);\n\t\t\tscat[i].addr       = 0;\n\t\t}\n\n\t\tqp->rq.wrid[ind] = wr->wr_id;\n\n\t\tind = (ind + 1) & (qp->rq.wqe_cnt - 1);\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tqp->rq.head += nreq;\n\n\t\t \n\t\twmb();\n\n\t\t*qp->db.db = cpu_to_be32(qp->rq.head & 0xffff);\n\t}\n\n\tspin_unlock_irqrestore(&qp->rq.lock, flags);\n\n\treturn err;\n}\n\nint mlx4_ib_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t      const struct ib_recv_wr **bad_wr)\n{\n\treturn _mlx4_ib_post_recv(ibqp, wr, bad_wr, false);\n}\n\nstatic inline enum ib_qp_state to_ib_qp_state(enum mlx4_qp_state mlx4_state)\n{\n\tswitch (mlx4_state) {\n\tcase MLX4_QP_STATE_RST:      return IB_QPS_RESET;\n\tcase MLX4_QP_STATE_INIT:     return IB_QPS_INIT;\n\tcase MLX4_QP_STATE_RTR:      return IB_QPS_RTR;\n\tcase MLX4_QP_STATE_RTS:      return IB_QPS_RTS;\n\tcase MLX4_QP_STATE_SQ_DRAINING:\n\tcase MLX4_QP_STATE_SQD:      return IB_QPS_SQD;\n\tcase MLX4_QP_STATE_SQER:     return IB_QPS_SQE;\n\tcase MLX4_QP_STATE_ERR:      return IB_QPS_ERR;\n\tdefault:\t\t     return -1;\n\t}\n}\n\nstatic inline enum ib_mig_state to_ib_mig_state(int mlx4_mig_state)\n{\n\tswitch (mlx4_mig_state) {\n\tcase MLX4_QP_PM_ARMED:\t\treturn IB_MIG_ARMED;\n\tcase MLX4_QP_PM_REARM:\t\treturn IB_MIG_REARM;\n\tcase MLX4_QP_PM_MIGRATED:\treturn IB_MIG_MIGRATED;\n\tdefault: return -1;\n\t}\n}\n\nstatic int to_ib_qp_access_flags(int mlx4_flags)\n{\n\tint ib_flags = 0;\n\n\tif (mlx4_flags & MLX4_QP_BIT_RRE)\n\t\tib_flags |= IB_ACCESS_REMOTE_READ;\n\tif (mlx4_flags & MLX4_QP_BIT_RWE)\n\t\tib_flags |= IB_ACCESS_REMOTE_WRITE;\n\tif (mlx4_flags & MLX4_QP_BIT_RAE)\n\t\tib_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\n\treturn ib_flags;\n}\n\nstatic void to_rdma_ah_attr(struct mlx4_ib_dev *ibdev,\n\t\t\t    struct rdma_ah_attr *ah_attr,\n\t\t\t    struct mlx4_qp_path *path)\n{\n\tstruct mlx4_dev *dev = ibdev->dev;\n\tu8 port_num = path->sched_queue & 0x40 ? 2 : 1;\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\tif (port_num == 0 || port_num > dev->caps.num_ports)\n\t\treturn;\n\tah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, port_num);\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE)\n\t\trdma_ah_set_sl(ah_attr, ((path->sched_queue >> 3) & 0x7) |\n\t\t\t       ((path->sched_queue & 4) << 1));\n\telse\n\t\trdma_ah_set_sl(ah_attr, (path->sched_queue >> 2) & 0xf);\n\trdma_ah_set_port_num(ah_attr, port_num);\n\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));\n\trdma_ah_set_path_bits(ah_attr, path->grh_mylmc & 0x7f);\n\trdma_ah_set_static_rate(ah_attr,\n\t\t\t\tpath->static_rate ? path->static_rate - 5 : 0);\n\tif (path->grh_mylmc & (1 << 7)) {\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\tbe32_to_cpu(path->tclass_flowlabel) & 0xfffff,\n\t\t\t\tpath->mgid_index,\n\t\t\t\tpath->hop_limit,\n\t\t\t\t(be32_to_cpu(path->tclass_flowlabel)\n\t\t\t\t >> 20) & 0xff);\n\t\trdma_ah_set_dgid_raw(ah_attr, path->rgid);\n\t}\n}\n\nint mlx4_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr_mask,\n\t\t     struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx4_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx4_qp_context context;\n\tint mlx4_state;\n\tint err = 0;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&qp->mutex);\n\n\tif (qp->state == IB_QPS_RESET) {\n\t\tqp_attr->qp_state = IB_QPS_RESET;\n\t\tgoto done;\n\t}\n\n\terr = mlx4_qp_query(dev->dev, &qp->mqp, &context);\n\tif (err) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmlx4_state = be32_to_cpu(context.flags) >> 28;\n\n\tqp->state\t\t     = to_ib_qp_state(mlx4_state);\n\tqp_attr->qp_state\t     = qp->state;\n\tqp_attr->path_mtu\t     = context.mtu_msgmax >> 5;\n\tqp_attr->path_mig_state\t     =\n\t\tto_ib_mig_state((be32_to_cpu(context.flags) >> 11) & 0x3);\n\tqp_attr->qkey\t\t     = be32_to_cpu(context.qkey);\n\tqp_attr->rq_psn\t\t     = be32_to_cpu(context.rnr_nextrecvpsn) & 0xffffff;\n\tqp_attr->sq_psn\t\t     = be32_to_cpu(context.next_send_psn) & 0xffffff;\n\tqp_attr->dest_qp_num\t     = be32_to_cpu(context.remote_qpn) & 0xffffff;\n\tqp_attr->qp_access_flags     =\n\t\tto_ib_qp_access_flags(be32_to_cpu(context.params2));\n\n\tif (qp->ibqp.qp_type == IB_QPT_RC || qp->ibqp.qp_type == IB_QPT_UC ||\n\t    qp->ibqp.qp_type == IB_QPT_XRC_INI ||\n\t    qp->ibqp.qp_type == IB_QPT_XRC_TGT) {\n\t\tto_rdma_ah_attr(dev, &qp_attr->ah_attr, &context.pri_path);\n\t\tto_rdma_ah_attr(dev, &qp_attr->alt_ah_attr, &context.alt_path);\n\t\tqp_attr->alt_pkey_index = context.alt_path.pkey_index & 0x7f;\n\t\tqp_attr->alt_port_num\t=\n\t\t\trdma_ah_get_port_num(&qp_attr->alt_ah_attr);\n\t}\n\n\tqp_attr->pkey_index = context.pri_path.pkey_index & 0x7f;\n\tif (qp_attr->qp_state == IB_QPS_INIT)\n\t\tqp_attr->port_num = qp->port;\n\telse\n\t\tqp_attr->port_num = context.pri_path.sched_queue & 0x40 ? 2 : 1;\n\n\t \n\tqp_attr->sq_draining = mlx4_state == MLX4_QP_STATE_SQ_DRAINING;\n\n\tqp_attr->max_rd_atomic = 1 << ((be32_to_cpu(context.params1) >> 21) & 0x7);\n\n\tqp_attr->max_dest_rd_atomic =\n\t\t1 << ((be32_to_cpu(context.params2) >> 21) & 0x7);\n\tqp_attr->min_rnr_timer\t    =\n\t\t(be32_to_cpu(context.rnr_nextrecvpsn) >> 24) & 0x1f;\n\tqp_attr->timeout\t    = context.pri_path.ackto >> 3;\n\tqp_attr->retry_cnt\t    = (be32_to_cpu(context.params1) >> 16) & 0x7;\n\tqp_attr->rnr_retry\t    = (be32_to_cpu(context.params1) >> 13) & 0x7;\n\tqp_attr->alt_timeout\t    = context.alt_path.ackto >> 3;\n\ndone:\n\tqp_attr->cur_qp_state\t     = qp_attr->qp_state;\n\tqp_attr->cap.max_recv_wr     = qp->rq.wqe_cnt;\n\tqp_attr->cap.max_recv_sge    = qp->rq.max_gs;\n\n\tif (!ibqp->uobject) {\n\t\tqp_attr->cap.max_send_wr  = qp->sq.wqe_cnt;\n\t\tqp_attr->cap.max_send_sge = qp->sq.max_gs;\n\t} else {\n\t\tqp_attr->cap.max_send_wr  = 0;\n\t\tqp_attr->cap.max_send_sge = 0;\n\t}\n\n\t \n\tqp_attr->cap.max_inline_data = 0;\n\n\tqp_init_attr->cap\t     = qp_attr->cap;\n\n\tqp_init_attr->create_flags = 0;\n\tif (qp->flags & MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK;\n\n\tif (qp->flags & MLX4_IB_QP_LSO)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_IPOIB_UD_LSO;\n\n\tif (qp->flags & MLX4_IB_QP_NETIF)\n\t\tqp_init_attr->create_flags |= IB_QP_CREATE_NETIF_QP;\n\n\tqp_init_attr->sq_sig_type =\n\t\tqp->sq_signal_bits == cpu_to_be32(MLX4_WQE_CTRL_CQ_UPDATE) ?\n\t\tIB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstruct ib_wq *mlx4_ib_create_wq(struct ib_pd *pd,\n\t\t\t\tstruct ib_wq_init_attr *init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx4_dev *dev = to_mdev(pd->device)->dev;\n\tstruct ib_qp_init_attr ib_qp_init_attr = {};\n\tstruct mlx4_ib_qp *qp;\n\tstruct mlx4_ib_create_wq ucmd;\n\tint err, required_cmd_sz;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-EINVAL);\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), comp_mask) +\n\t\t\t  sizeof(ucmd.comp_mask);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tpr_debug(\"invalid inlen\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tpr_debug(\"inlen is not supported\\n\");\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tif (udata->outlen)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (init_attr->wq_type != IB_WQT_RQ) {\n\t\tpr_debug(\"unsupported wq type %d\\n\", init_attr->wq_type);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tif (init_attr->create_flags & ~IB_WQ_FLAGS_SCATTER_FCS ||\n\t    !(dev->caps.flags & MLX4_DEV_CAP_FLAG_FCS_KEEP)) {\n\t\tpr_debug(\"unsupported create_flags %u\\n\",\n\t\t\t init_attr->create_flags);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tqp = kzalloc(sizeof(*qp), GFP_KERNEL);\n\tif (!qp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&qp->mutex);\n\tqp->pri.vid = 0xFFFF;\n\tqp->alt.vid = 0xFFFF;\n\n\tib_qp_init_attr.qp_context = init_attr->wq_context;\n\tib_qp_init_attr.qp_type = IB_QPT_RAW_PACKET;\n\tib_qp_init_attr.cap.max_recv_wr = init_attr->max_wr;\n\tib_qp_init_attr.cap.max_recv_sge = init_attr->max_sge;\n\tib_qp_init_attr.recv_cq = init_attr->cq;\n\tib_qp_init_attr.send_cq = ib_qp_init_attr.recv_cq;  \n\n\tif (init_attr->create_flags & IB_WQ_FLAGS_SCATTER_FCS)\n\t\tib_qp_init_attr.create_flags |= IB_QP_CREATE_SCATTER_FCS;\n\n\terr = create_rq(pd, &ib_qp_init_attr, udata, qp);\n\tif (err) {\n\t\tkfree(qp);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tqp->ibwq.event_handler = init_attr->event_handler;\n\tqp->ibwq.wq_num = qp->mqp.qpn;\n\tqp->ibwq.state = IB_WQS_RESET;\n\n\treturn &qp->ibwq;\n}\n\nstatic int ib_wq2qp_state(enum ib_wq_state state)\n{\n\tswitch (state) {\n\tcase IB_WQS_RESET:\n\t\treturn IB_QPS_RESET;\n\tcase IB_WQS_RDY:\n\t\treturn IB_QPS_RTR;\n\tdefault:\n\t\treturn IB_QPS_ERR;\n\t}\n}\n\nstatic int _mlx4_ib_modify_wq(struct ib_wq *ibwq, enum ib_wq_state new_state,\n\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx4_ib_qp *qp = to_mqp((struct ib_qp *)ibwq);\n\tenum ib_qp_state qp_cur_state;\n\tenum ib_qp_state qp_new_state;\n\tint attr_mask;\n\tint err;\n\n\t \n\tqp_cur_state = qp->state;\n\tqp_new_state = ib_wq2qp_state(new_state);\n\n\tif (ib_wq2qp_state(new_state) == qp_cur_state)\n\t\treturn 0;\n\n\tif (new_state == IB_WQS_RDY) {\n\t\tstruct ib_qp_attr attr = {};\n\n\t\tattr.port_num = qp->port;\n\t\tattr_mask = IB_QP_PORT;\n\n\t\terr = __mlx4_ib_modify_qp(ibwq, MLX4_IB_RWQ_SRC, &attr,\n\t\t\t\t\t  attr_mask, IB_QPS_RESET, IB_QPS_INIT,\n\t\t\t\t\t  udata);\n\t\tif (err) {\n\t\t\tpr_debug(\"WQN=0x%06x failed to apply RST->INIT on the HW QP\\n\",\n\t\t\t\t ibwq->wq_num);\n\t\t\treturn err;\n\t\t}\n\n\t\tqp_cur_state = IB_QPS_INIT;\n\t}\n\n\tattr_mask = 0;\n\terr = __mlx4_ib_modify_qp(ibwq, MLX4_IB_RWQ_SRC, NULL, attr_mask,\n\t\t\t\t  qp_cur_state,  qp_new_state, udata);\n\n\tif (err && (qp_cur_state == IB_QPS_INIT)) {\n\t\tqp_new_state = IB_QPS_RESET;\n\t\tif (__mlx4_ib_modify_qp(ibwq, MLX4_IB_RWQ_SRC, NULL,\n\t\t\t\t\tattr_mask, IB_QPS_INIT, IB_QPS_RESET,\n\t\t\t\t\tudata)) {\n\t\t\tpr_warn(\"WQN=0x%06x failed with reverting HW's resources failure\\n\",\n\t\t\t\tibwq->wq_num);\n\t\t\tqp_new_state = IB_QPS_INIT;\n\t\t}\n\t}\n\n\tqp->state = qp_new_state;\n\n\treturn err;\n}\n\nint mlx4_ib_modify_wq(struct ib_wq *ibwq, struct ib_wq_attr *wq_attr,\n\t\t      u32 wq_attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_qp *qp = to_mqp((struct ib_qp *)ibwq);\n\tstruct mlx4_ib_modify_wq ucmd = {};\n\tsize_t required_cmd_sz;\n\tenum ib_wq_state cur_state, new_state;\n\tint err = 0;\n\n\trequired_cmd_sz = offsetof(typeof(ucmd), reserved) +\n\t\t\t\t   sizeof(ucmd.reserved);\n\tif (udata->inlen < required_cmd_sz)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen)))\n\t\treturn -EFAULT;\n\n\tif (ucmd.comp_mask || ucmd.reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tif (wq_attr_mask & IB_WQ_FLAGS)\n\t\treturn -EOPNOTSUPP;\n\n\tcur_state = wq_attr->curr_wq_state;\n\tnew_state = wq_attr->wq_state;\n\n\tif ((new_state == IB_WQS_RDY) && (cur_state == IB_WQS_ERR))\n\t\treturn -EINVAL;\n\n\tif ((new_state == IB_WQS_ERR) && (cur_state == IB_WQS_RESET))\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&qp->mutex);\n\n\t \n\tif (qp->rss_usecnt)\n\t\terr = _mlx4_ib_modify_wq(ibwq, new_state, udata);\n\n\tif (!err)\n\t\tibwq->state = new_state;\n\n\tmutex_unlock(&qp->mutex);\n\n\treturn err;\n}\n\nint mlx4_ib_destroy_wq(struct ib_wq *ibwq, struct ib_udata *udata)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibwq->device);\n\tstruct mlx4_ib_qp *qp = to_mqp((struct ib_qp *)ibwq);\n\n\tif (qp->counter_index)\n\t\tmlx4_ib_free_qp_counter(dev, qp);\n\n\tdestroy_qp_common(dev, qp, MLX4_IB_RWQ_SRC, udata);\n\n\tkfree(qp);\n\treturn 0;\n}\n\nint mlx4_ib_create_rwq_ind_table(struct ib_rwq_ind_table *rwq_ind_table,\n\t\t\t\t struct ib_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t struct ib_udata *udata)\n{\n\tstruct mlx4_ib_create_rwq_ind_tbl_resp resp = {};\n\tunsigned int ind_tbl_size = 1 << init_attr->log_ind_tbl_size;\n\tstruct ib_device *device = rwq_ind_table->device;\n\tunsigned int base_wqn;\n\tsize_t min_resp_len;\n\tint i, err = 0;\n\n\tif (udata->inlen > 0 &&\n\t    !ib_is_udata_cleared(udata, 0,\n\t\t\t\t udata->inlen))\n\t\treturn -EOPNOTSUPP;\n\n\tmin_resp_len = offsetof(typeof(resp), reserved) + sizeof(resp.reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn -EINVAL;\n\n\tif (ind_tbl_size >\n\t    device->attrs.rss_caps.max_rwq_indirection_table_size) {\n\t\tpr_debug(\"log_ind_tbl_size = %d is bigger than supported = %d\\n\",\n\t\t\t ind_tbl_size,\n\t\t\t device->attrs.rss_caps.max_rwq_indirection_table_size);\n\t\treturn -EINVAL;\n\t}\n\n\tbase_wqn = init_attr->ind_tbl[0]->wq_num;\n\n\tif (base_wqn % ind_tbl_size) {\n\t\tpr_debug(\"WQN=0x%x isn't aligned with indirection table size\\n\",\n\t\t\t base_wqn);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 1; i < ind_tbl_size; i++) {\n\t\tif (++base_wqn != init_attr->ind_tbl[i]->wq_num) {\n\t\t\tpr_debug(\"indirection table's WQNs aren't consecutive\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetof(typeof(resp), response_length) +\n\t\t\t\t\tsizeof(resp.response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t}\n\n\treturn err;\n}\n\nstruct mlx4_ib_drain_cqe {\n\tstruct ib_cqe cqe;\n\tstruct completion done;\n};\n\nstatic void mlx4_ib_drain_qp_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct mlx4_ib_drain_cqe *cqe = container_of(wc->wr_cqe,\n\t\t\t\t\t\t     struct mlx4_ib_drain_cqe,\n\t\t\t\t\t\t     cqe);\n\n\tcomplete(&cqe->done);\n}\n\n \nstatic void handle_drain_completion(struct ib_cq *cq,\n\t\t\t\t    struct mlx4_ib_drain_cqe *sdrain,\n\t\t\t\t    struct mlx4_ib_dev *dev)\n{\n\tstruct mlx4_dev *mdev = dev->dev;\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT) {\n\t\twhile (wait_for_completion_timeout(&sdrain->done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\t\treturn;\n\t}\n\n\tif (mdev->persist->state == MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tstruct mlx4_ib_cq *mcq = to_mcq(cq);\n\t\tbool triggered = false;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\t\t \n\t\tif (!mcq->mcq.reset_notify_added)\n\t\t\tmcq->mcq.reset_notify_added = 1;\n\t\telse\n\t\t\ttriggered = true;\n\t\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\t\tif (triggered) {\n\t\t\t \n\t\t\tswitch (cq->poll_ctx) {\n\t\t\tcase IB_POLL_SOFTIRQ:\n\t\t\t\tirq_poll_disable(&cq->iop);\n\t\t\t\tirq_poll_enable(&cq->iop);\n\t\t\t\tbreak;\n\t\t\tcase IB_POLL_WORKQUEUE:\n\t\t\t\tcancel_work_sync(&cq->work);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmcq->mcq.comp(&mcq->mcq);\n\t}\n\n\twait_for_completion(&sdrain->done);\n}\n\nvoid mlx4_ib_drain_sq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->send_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx4_ib_drain_cqe sdrain;\n\tconst struct ib_send_wr *bad_swr;\n\tstruct ib_rdma_wr swr = {\n\t\t.wr = {\n\t\t\t.next = NULL,\n\t\t\t{ .wr_cqe\t= &sdrain.cqe, },\n\t\t\t.opcode\t= IB_WR_RDMA_WRITE,\n\t\t},\n\t};\n\tint ret;\n\tstruct mlx4_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx4_dev *mdev = dev->dev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->persist->state != MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tsdrain.cqe.done = mlx4_ib_drain_qp_done;\n\tinit_completion(&sdrain.done);\n\n\tret = _mlx4_ib_post_send(qp, &swr.wr, &bad_swr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &sdrain, dev);\n}\n\nvoid mlx4_ib_drain_rq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->recv_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx4_ib_drain_cqe rdrain;\n\tstruct ib_recv_wr rwr = {};\n\tconst struct ib_recv_wr *bad_rwr;\n\tint ret;\n\tstruct mlx4_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx4_dev *mdev = dev->dev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->persist->state != MLX4_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trwr.wr_cqe = &rdrain.cqe;\n\trdrain.cqe.done = mlx4_ib_drain_qp_done;\n\tinit_completion(&rdrain.done);\n\n\tret = _mlx4_ib_post_recv(qp, &rwr, &bad_rwr, true);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &rdrain, dev);\n}\n\nint mlx4_ib_qp_event_init(void)\n{\n\tmlx4_ib_qp_event_wq = alloc_ordered_workqueue(\"mlx4_ib_qp_event_wq\", 0);\n\tif (!mlx4_ib_qp_event_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mlx4_ib_qp_event_cleanup(void)\n{\n\tdestroy_workqueue(mlx4_ib_qp_event_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}