{
  "module_name": "mad.c",
  "hash_id": "0197db5b6dc4929b78f279909fff314e0d12701072432e4e9f5114060d9749b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx4/mad.c",
  "human_readable_source": " \n\n#include <rdma/ib_mad.h>\n#include <rdma/ib_smi.h>\n#include <rdma/ib_sa.h>\n#include <rdma/ib_cache.h>\n\n#include <linux/random.h>\n#include <linux/mlx4/cmd.h>\n#include <linux/gfp.h>\n#include <rdma/ib_pma.h>\n#include <linux/ip.h>\n#include <net/ipv6.h>\n\n#include <linux/mlx4/driver.h>\n#include \"mlx4_ib.h\"\n\nenum {\n\tMLX4_IB_VENDOR_CLASS1 = 0x9,\n\tMLX4_IB_VENDOR_CLASS2 = 0xa\n};\n\n#define MLX4_TUN_SEND_WRID_SHIFT 34\n#define MLX4_TUN_QPN_SHIFT 32\n#define MLX4_TUN_WRID_RECV (((u64) 1) << MLX4_TUN_SEND_WRID_SHIFT)\n#define MLX4_TUN_SET_WRID_QPN(a) (((u64) ((a) & 0x3)) << MLX4_TUN_QPN_SHIFT)\n\n#define MLX4_TUN_IS_RECV(a)  (((a) >>  MLX4_TUN_SEND_WRID_SHIFT) & 0x1)\n#define MLX4_TUN_WRID_QPN(a) (((a) >> MLX4_TUN_QPN_SHIFT) & 0x3)\n\n  \n\n#define GET_BLK_PTR_FROM_EQE(eqe) be32_to_cpu(eqe->event.port_mgmt_change.params.tbl_change_info.block_ptr)\n#define GET_MASK_FROM_EQE(eqe) be32_to_cpu(eqe->event.port_mgmt_change.params.tbl_change_info.tbl_entries_mask)\n#define NUM_IDX_IN_PKEY_TBL_BLK 32\n#define GUID_TBL_ENTRY_SIZE 8\t    \n#define GUID_TBL_BLK_NUM_ENTRIES 8\n#define GUID_TBL_BLK_SIZE (GUID_TBL_ENTRY_SIZE * GUID_TBL_BLK_NUM_ENTRIES)\n\nstruct mlx4_mad_rcv_buf {\n\tstruct ib_grh grh;\n\tu8 payload[256];\n} __packed;\n\nstruct mlx4_mad_snd_buf {\n\tu8 payload[256];\n} __packed;\n\nstruct mlx4_tunnel_mad {\n\tstruct ib_grh grh;\n\tstruct mlx4_ib_tunnel_header hdr;\n\tstruct ib_mad mad;\n} __packed;\n\nstruct mlx4_rcv_tunnel_mad {\n\tstruct mlx4_rcv_tunnel_hdr hdr;\n\tstruct ib_grh grh;\n\tstruct ib_mad mad;\n} __packed;\n\nstatic void handle_client_rereg_event(struct mlx4_ib_dev *dev, u32 port_num);\nstatic void handle_lid_change_event(struct mlx4_ib_dev *dev, u32 port_num);\nstatic void __propagate_pkey_ev(struct mlx4_ib_dev *dev, int port_num,\n\t\t\t\tint block, u32 change_bitmap);\n\n__be64 mlx4_ib_gen_node_guid(void)\n{\n#define NODE_GUID_HI\t((u64) (((u64)IB_OPENIB_OUI) << 40))\n\treturn cpu_to_be64(NODE_GUID_HI | get_random_u32());\n}\n\n__be64 mlx4_ib_get_new_demux_tid(struct mlx4_ib_demux_ctx *ctx)\n{\n\treturn cpu_to_be64(atomic_inc_return(&ctx->tid)) |\n\t\tcpu_to_be64(0xff00000000000000LL);\n}\n\nint mlx4_MAD_IFC(struct mlx4_ib_dev *dev, int mad_ifc_flags,\n\t\t int port, const struct ib_wc *in_wc,\n\t\t const struct ib_grh *in_grh,\n\t\t const void *in_mad, void *response_mad)\n{\n\tstruct mlx4_cmd_mailbox *inmailbox, *outmailbox;\n\tvoid *inbox;\n\tint err;\n\tu32 in_modifier = port;\n\tu8 op_modifier = 0;\n\n\tinmailbox = mlx4_alloc_cmd_mailbox(dev->dev);\n\tif (IS_ERR(inmailbox))\n\t\treturn PTR_ERR(inmailbox);\n\tinbox = inmailbox->buf;\n\n\toutmailbox = mlx4_alloc_cmd_mailbox(dev->dev);\n\tif (IS_ERR(outmailbox)) {\n\t\tmlx4_free_cmd_mailbox(dev->dev, inmailbox);\n\t\treturn PTR_ERR(outmailbox);\n\t}\n\n\tmemcpy(inbox, in_mad, 256);\n\n\t \n\tif ((mad_ifc_flags & MLX4_MAD_IFC_IGNORE_MKEY) || !in_wc)\n\t\top_modifier |= 0x1;\n\tif ((mad_ifc_flags & MLX4_MAD_IFC_IGNORE_BKEY) || !in_wc)\n\t\top_modifier |= 0x2;\n\tif (mlx4_is_mfunc(dev->dev) &&\n\t    (mad_ifc_flags & MLX4_MAD_IFC_NET_VIEW || in_wc))\n\t\top_modifier |= 0x8;\n\n\tif (in_wc) {\n\t\tstruct {\n\t\t\t__be32\t\tmy_qpn;\n\t\t\tu32\t\treserved1;\n\t\t\t__be32\t\trqpn;\n\t\t\tu8\t\tsl;\n\t\t\tu8\t\tg_path;\n\t\t\tu16\t\treserved2[2];\n\t\t\t__be16\t\tpkey;\n\t\t\tu32\t\treserved3[11];\n\t\t\tu8\t\tgrh[40];\n\t\t} *ext_info;\n\n\t\tmemset(inbox + 256, 0, 256);\n\t\text_info = inbox + 256;\n\n\t\text_info->my_qpn = cpu_to_be32(in_wc->qp->qp_num);\n\t\text_info->rqpn   = cpu_to_be32(in_wc->src_qp);\n\t\text_info->sl     = in_wc->sl << 4;\n\t\text_info->g_path = in_wc->dlid_path_bits |\n\t\t\t(in_wc->wc_flags & IB_WC_GRH ? 0x80 : 0);\n\t\text_info->pkey   = cpu_to_be16(in_wc->pkey_index);\n\n\t\tif (in_grh)\n\t\t\tmemcpy(ext_info->grh, in_grh, 40);\n\n\t\top_modifier |= 0x4;\n\n\t\tin_modifier |= ib_lid_cpu16(in_wc->slid) << 16;\n\t}\n\n\terr = mlx4_cmd_box(dev->dev, inmailbox->dma, outmailbox->dma, in_modifier,\n\t\t\t   mlx4_is_master(dev->dev) ? (op_modifier & ~0x8) : op_modifier,\n\t\t\t   MLX4_CMD_MAD_IFC, MLX4_CMD_TIME_CLASS_C,\n\t\t\t   (op_modifier & 0x8) ? MLX4_CMD_NATIVE : MLX4_CMD_WRAPPED);\n\n\tif (!err)\n\t\tmemcpy(response_mad, outmailbox->buf, 256);\n\n\tmlx4_free_cmd_mailbox(dev->dev, inmailbox);\n\tmlx4_free_cmd_mailbox(dev->dev, outmailbox);\n\n\treturn err;\n}\n\nstatic void update_sm_ah(struct mlx4_ib_dev *dev, u32 port_num, u16 lid, u8 sl)\n{\n\tstruct ib_ah *new_ah;\n\tstruct rdma_ah_attr ah_attr;\n\tunsigned long flags;\n\n\tif (!dev->send_agent[port_num - 1][0])\n\t\treturn;\n\n\tmemset(&ah_attr, 0, sizeof ah_attr);\n\tah_attr.type = rdma_ah_find_type(&dev->ib_dev, port_num);\n\trdma_ah_set_dlid(&ah_attr, lid);\n\trdma_ah_set_sl(&ah_attr, sl);\n\trdma_ah_set_port_num(&ah_attr, port_num);\n\n\tnew_ah = rdma_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,\n\t\t\t\t&ah_attr, 0);\n\tif (IS_ERR(new_ah))\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->sm_lock, flags);\n\tif (dev->sm_ah[port_num - 1])\n\t\trdma_destroy_ah(dev->sm_ah[port_num - 1], 0);\n\tdev->sm_ah[port_num - 1] = new_ah;\n\tspin_unlock_irqrestore(&dev->sm_lock, flags);\n}\n\n \nstatic void smp_snoop(struct ib_device *ibdev, u32 port_num,\n\t\t      const struct ib_mad *mad, u16 prev_lid)\n{\n\tstruct ib_port_info *pinfo;\n\tu16 lid;\n\t__be16 *base;\n\tu32 bn, pkey_change_bitmap;\n\tint i;\n\n\n\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tif ((mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    mad->mad_hdr.method == IB_MGMT_METHOD_SET)\n\t\tswitch (mad->mad_hdr.attr_id) {\n\t\tcase IB_SMP_ATTR_PORT_INFO:\n\t\t\tif (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV)\n\t\t\t\treturn;\n\t\t\tpinfo = (struct ib_port_info *) ((struct ib_smp *) mad)->data;\n\t\t\tlid = be16_to_cpu(pinfo->lid);\n\n\t\t\tupdate_sm_ah(dev, port_num,\n\t\t\t\t     be16_to_cpu(pinfo->sm_lid),\n\t\t\t\t     pinfo->neighbormtu_mastersmsl & 0xf);\n\n\t\t\tif (pinfo->clientrereg_resv_subnetto & 0x80)\n\t\t\t\thandle_client_rereg_event(dev, port_num);\n\n\t\t\tif (prev_lid != lid)\n\t\t\t\thandle_lid_change_event(dev, port_num);\n\t\t\tbreak;\n\n\t\tcase IB_SMP_ATTR_PKEY_TABLE:\n\t\t\tif (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV)\n\t\t\t\treturn;\n\t\t\tif (!mlx4_is_mfunc(dev->dev)) {\n\t\t\t\tmlx4_ib_dispatch_event(dev, port_num,\n\t\t\t\t\t\t       IB_EVENT_PKEY_CHANGE);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tbn  = be32_to_cpu(((struct ib_smp *)mad)->attr_mod) & 0xFFFF;\n\t\t\tbase = (__be16 *) &(((struct ib_smp *)mad)->data[0]);\n\t\t\tpkey_change_bitmap = 0;\n\t\t\tfor (i = 0; i < 32; i++) {\n\t\t\t\tpr_debug(\"PKEY[%d] = x%x\\n\",\n\t\t\t\t\t i + bn*32, be16_to_cpu(base[i]));\n\t\t\t\tif (be16_to_cpu(base[i]) !=\n\t\t\t\t    dev->pkeys.phys_pkey_cache[port_num - 1][i + bn*32]) {\n\t\t\t\t\tpkey_change_bitmap |= (1 << i);\n\t\t\t\t\tdev->pkeys.phys_pkey_cache[port_num - 1][i + bn*32] =\n\t\t\t\t\t\tbe16_to_cpu(base[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr_debug(\"PKEY Change event: port=%u, \"\n\t\t\t\t \"block=0x%x, change_bitmap=0x%x\\n\",\n\t\t\t\t port_num, bn, pkey_change_bitmap);\n\n\t\t\tif (pkey_change_bitmap) {\n\t\t\t\tmlx4_ib_dispatch_event(dev, port_num,\n\t\t\t\t\t\t       IB_EVENT_PKEY_CHANGE);\n\t\t\t\tif (!dev->sriov.is_going_down)\n\t\t\t\t\t__propagate_pkey_ev(dev, port_num, bn,\n\t\t\t\t\t\t\t    pkey_change_bitmap);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_SMP_ATTR_GUID_INFO:\n\t\t\tif (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV)\n\t\t\t\treturn;\n\t\t\t \n\t\t\tif (!mlx4_is_master(dev->dev))\n\t\t\t\tmlx4_ib_dispatch_event(dev, port_num,\n\t\t\t\t\t\t       IB_EVENT_GID_CHANGE);\n\t\t\t \n\t\t\tif (mlx4_is_master(dev->dev) &&\n\t\t\t    !dev->sriov.is_going_down) {\n\t\t\t\tbn = be32_to_cpu(((struct ib_smp *)mad)->attr_mod);\n\t\t\t\tmlx4_ib_update_cache_on_guid_change(dev, bn, port_num,\n\t\t\t\t\t\t\t\t    (u8 *)(&((struct ib_smp *)mad)->data));\n\t\t\t\tmlx4_ib_notify_slaves_on_guid_change(dev, bn, port_num,\n\t\t\t\t\t\t\t\t     (u8 *)(&((struct ib_smp *)mad)->data));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_SMP_ATTR_SL_TO_VL_TABLE:\n\t\t\t \n\t\t\tif (dev->dev->caps.flags & MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV &&\n\t\t\t    dev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT)\n\t\t\t\treturn;\n\t\t\tif (!mlx4_is_slave(dev->dev)) {\n\t\t\t\tunion sl2vl_tbl_to_u64 sl2vl64;\n\t\t\t\tint jj;\n\n\t\t\t\tfor (jj = 0; jj < 8; jj++) {\n\t\t\t\t\tsl2vl64.sl8[jj] = ((struct ib_smp *)mad)->data[jj];\n\t\t\t\t\tpr_debug(\"port %u, sl2vl[%d] = %02x\\n\",\n\t\t\t\t\t\t port_num, jj, sl2vl64.sl8[jj]);\n\t\t\t\t}\n\t\t\t\tatomic64_set(&dev->sl2vl[port_num - 1], sl2vl64.sl64);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void __propagate_pkey_ev(struct mlx4_ib_dev *dev, int port_num,\n\t\t\t\tint block, u32 change_bitmap)\n{\n\tint i, ix, slave, err;\n\tint have_event = 0;\n\n\tfor (slave = 0; slave < dev->dev->caps.sqp_demux; slave++) {\n\t\tif (slave == mlx4_master_func_num(dev->dev))\n\t\t\tcontinue;\n\t\tif (!mlx4_is_slave_active(dev->dev, slave))\n\t\t\tcontinue;\n\n\t\thave_event = 0;\n\t\tfor (i = 0; i < 32; i++) {\n\t\t\tif (!(change_bitmap & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tfor (ix = 0;\n\t\t\t     ix < dev->dev->caps.pkey_table_len[port_num]; ix++) {\n\t\t\t\tif (dev->pkeys.virt2phys_pkey[slave][port_num - 1]\n\t\t\t\t    [ix] == i + 32 * block) {\n\t\t\t\t\terr = mlx4_gen_pkey_eqe(dev->dev, slave, port_num);\n\t\t\t\t\tpr_debug(\"propagate_pkey_ev: slave %d,\"\n\t\t\t\t\t\t \" port %d, ix %d (%d)\\n\",\n\t\t\t\t\t\t slave, port_num, ix, err);\n\t\t\t\t\thave_event = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (have_event)\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void node_desc_override(struct ib_device *dev,\n\t\t\t       struct ib_mad *mad)\n{\n\tunsigned long flags;\n\n\tif ((mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    mad->mad_hdr.method == IB_MGMT_METHOD_GET_RESP &&\n\t    mad->mad_hdr.attr_id == IB_SMP_ATTR_NODE_DESC) {\n\t\tspin_lock_irqsave(&to_mdev(dev)->sm_lock, flags);\n\t\tmemcpy(((struct ib_smp *) mad)->data, dev->node_desc,\n\t\t       IB_DEVICE_NODE_DESC_MAX);\n\t\tspin_unlock_irqrestore(&to_mdev(dev)->sm_lock, flags);\n\t}\n}\n\nstatic void forward_trap(struct mlx4_ib_dev *dev, u32 port_num,\n\t\t\t const struct ib_mad *mad)\n{\n\tint qpn = mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_SUBN_LID_ROUTED;\n\tstruct ib_mad_send_buf *send_buf;\n\tstruct ib_mad_agent *agent = dev->send_agent[port_num - 1][qpn];\n\tint ret;\n\tunsigned long flags;\n\n\tif (agent) {\n\t\tsend_buf = ib_create_send_mad(agent, qpn, 0, 0, IB_MGMT_MAD_HDR,\n\t\t\t\t\t      IB_MGMT_MAD_DATA, GFP_ATOMIC,\n\t\t\t\t\t      IB_MGMT_BASE_VERSION);\n\t\tif (IS_ERR(send_buf))\n\t\t\treturn;\n\t\t \n\t\tspin_lock_irqsave(&dev->sm_lock, flags);\n\t\tmemcpy(send_buf->mad, mad, sizeof *mad);\n\t\tif ((send_buf->ah = dev->sm_ah[port_num - 1]))\n\t\t\tret = ib_post_send_mad(send_buf, NULL);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tspin_unlock_irqrestore(&dev->sm_lock, flags);\n\n\t\tif (ret)\n\t\t\tib_free_send_mad(send_buf);\n\t}\n}\n\nstatic int mlx4_ib_demux_sa_handler(struct ib_device *ibdev, int port, int slave,\n\t\t\t\t\t\t\t     struct ib_sa_mad *sa_mad)\n{\n\tint ret = 0;\n\n\t \n\tswitch (be16_to_cpu(sa_mad->mad_hdr.attr_id)) {\n\tcase IB_SA_ATTR_MC_MEMBER_REC:\n\t\tret = mlx4_ib_mcg_demux_handler(ibdev, port, slave, sa_mad);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint mlx4_ib_find_real_gid(struct ib_device *ibdev, u32 port, __be64 guid)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tint i;\n\n\tfor (i = 0; i < dev->dev->caps.sqp_demux; i++) {\n\t\tif (dev->sriov.demux[port - 1].guid_cache[i] == guid)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n\nstatic int find_slave_port_pkey_ix(struct mlx4_ib_dev *dev, int slave,\n\t\t\t\t   u32 port, u16 pkey, u16 *ix)\n{\n\tint i, ret;\n\tu8 unassigned_pkey_ix, pkey_ix, partial_ix = 0xFF;\n\tu16 slot_pkey;\n\n\tif (slave == mlx4_master_func_num(dev->dev))\n\t\treturn ib_find_cached_pkey(&dev->ib_dev, port, pkey, ix);\n\n\tunassigned_pkey_ix = dev->dev->phys_caps.pkey_phys_table_len[port] - 1;\n\n\tfor (i = 0; i < dev->dev->caps.pkey_table_len[port]; i++) {\n\t\tif (dev->pkeys.virt2phys_pkey[slave][port - 1][i] == unassigned_pkey_ix)\n\t\t\tcontinue;\n\n\t\tpkey_ix = dev->pkeys.virt2phys_pkey[slave][port - 1][i];\n\n\t\tret = ib_get_cached_pkey(&dev->ib_dev, port, pkey_ix, &slot_pkey);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif ((slot_pkey & 0x7FFF) == (pkey & 0x7FFF)) {\n\t\t\tif (slot_pkey & 0x8000) {\n\t\t\t\t*ix = (u16) pkey_ix;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (partial_ix == 0xFF)\n\t\t\t\t\tpartial_ix = pkey_ix;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (partial_ix < 0xFF) {\n\t\t*ix = (u16) partial_ix;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int get_gids_from_l3_hdr(struct ib_grh *grh, union ib_gid *sgid,\n\t\t\t\tunion ib_gid *dgid)\n{\n\tint version = ib_get_rdma_header_version((const union rdma_network_hdr *)grh);\n\tenum rdma_network_type net_type;\n\n\tif (version == 4)\n\t\tnet_type = RDMA_NETWORK_IPV4;\n\telse if (version == 6)\n\t\tnet_type = RDMA_NETWORK_IPV6;\n\telse\n\t\treturn -EINVAL;\n\n\treturn ib_get_gids_from_rdma_hdr((union rdma_network_hdr *)grh, net_type,\n\t\t\t\t\t sgid, dgid);\n}\n\nstatic int is_proxy_qp0(struct mlx4_ib_dev *dev, int qpn, int slave)\n{\n\tint proxy_start = dev->dev->phys_caps.base_proxy_sqpn + 8 * slave;\n\n\treturn (qpn >= proxy_start && qpn <= proxy_start + 1);\n}\n\nint mlx4_ib_send_to_slave(struct mlx4_ib_dev *dev, int slave, u32 port,\n\t\t\t  enum ib_qp_type dest_qpt, struct ib_wc *wc,\n\t\t\t  struct ib_grh *grh, struct ib_mad *mad)\n{\n\tstruct ib_sge list;\n\tstruct ib_ud_wr wr;\n\tconst struct ib_send_wr *bad_wr;\n\tstruct mlx4_ib_demux_pv_ctx *tun_ctx;\n\tstruct mlx4_ib_demux_pv_qp *tun_qp;\n\tstruct mlx4_rcv_tunnel_mad *tun_mad;\n\tstruct rdma_ah_attr attr;\n\tstruct ib_ah *ah;\n\tstruct ib_qp *src_qp = NULL;\n\tunsigned tun_tx_ix = 0;\n\tint dqpn;\n\tint ret = 0;\n\tu16 tun_pkey_ix;\n\tu16 cached_pkey;\n\tu8 is_eth = dev->dev->caps.port_type[port] == MLX4_PORT_TYPE_ETH;\n\n\tif (dest_qpt > IB_QPT_GSI) {\n\t\tpr_debug(\"dest_qpt (%d) > IB_QPT_GSI\\n\", dest_qpt);\n\t\treturn -EINVAL;\n\t}\n\n\ttun_ctx = dev->sriov.demux[port-1].tun[slave];\n\n\t \n\tif (!tun_ctx || tun_ctx->state != DEMUX_PV_STATE_ACTIVE)\n\t\treturn -EAGAIN;\n\n\tif (!dest_qpt)\n\t\ttun_qp = &tun_ctx->qp[0];\n\telse\n\t\ttun_qp = &tun_ctx->qp[1];\n\n\t \n\tif (dest_qpt) {\n\t\tu16 pkey_ix;\n\t\tret = ib_get_cached_pkey(&dev->ib_dev, port, wc->pkey_index, &cached_pkey);\n\t\tif (ret) {\n\t\t\tpr_debug(\"unable to get %s cached pkey for index %d, ret %d\\n\",\n\t\t\t\t is_proxy_qp0(dev, wc->src_qp, slave) ? \"SMI\" : \"GSI\",\n\t\t\t\t wc->pkey_index, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = find_slave_port_pkey_ix(dev, slave, port, cached_pkey, &pkey_ix);\n\t\tif (ret) {\n\t\t\tpr_debug(\"unable to get %s pkey ix for pkey 0x%x, ret %d\\n\",\n\t\t\t\t is_proxy_qp0(dev, wc->src_qp, slave) ? \"SMI\" : \"GSI\",\n\t\t\t\t cached_pkey, ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttun_pkey_ix = pkey_ix;\n\t} else\n\t\ttun_pkey_ix = dev->pkeys.virt2phys_pkey[slave][port - 1][0];\n\n\tdqpn = dev->dev->phys_caps.base_proxy_sqpn + 8 * slave + port + (dest_qpt * 2) - 1;\n\n\t \n\tsrc_qp = tun_qp->qp;\n\n\t \n\tmemset(&attr, 0, sizeof attr);\n\tattr.type = rdma_ah_find_type(&dev->ib_dev, port);\n\n\trdma_ah_set_port_num(&attr, port);\n\tif (is_eth) {\n\t\tunion ib_gid sgid;\n\t\tunion ib_gid dgid;\n\n\t\tif (get_gids_from_l3_hdr(grh, &sgid, &dgid))\n\t\t\treturn -EINVAL;\n\t\trdma_ah_set_grh(&attr, &dgid, 0, 0, 0, 0);\n\t}\n\tah = rdma_create_ah(tun_ctx->pd, &attr, 0);\n\tif (IS_ERR(ah))\n\t\treturn -ENOMEM;\n\n\t \n\tspin_lock(&tun_qp->tx_lock);\n\tif (tun_qp->tx_ix_head - tun_qp->tx_ix_tail >=\n\t    (MLX4_NUM_TUNNEL_BUFS - 1))\n\t\tret = -EAGAIN;\n\telse\n\t\ttun_tx_ix = (++tun_qp->tx_ix_head) & (MLX4_NUM_TUNNEL_BUFS - 1);\n\tspin_unlock(&tun_qp->tx_lock);\n\tif (ret)\n\t\tgoto end;\n\n\ttun_mad = (struct mlx4_rcv_tunnel_mad *) (tun_qp->tx_ring[tun_tx_ix].buf.addr);\n\tif (tun_qp->tx_ring[tun_tx_ix].ah)\n\t\trdma_destroy_ah(tun_qp->tx_ring[tun_tx_ix].ah, 0);\n\ttun_qp->tx_ring[tun_tx_ix].ah = ah;\n\tib_dma_sync_single_for_cpu(&dev->ib_dev,\n\t\t\t\t   tun_qp->tx_ring[tun_tx_ix].buf.map,\n\t\t\t\t   sizeof (struct mlx4_rcv_tunnel_mad),\n\t\t\t\t   DMA_TO_DEVICE);\n\n\t \n\tif (grh)\n\t\tmemcpy(&tun_mad->grh, grh, sizeof *grh);\n\tmemcpy(&tun_mad->mad, mad, sizeof *mad);\n\n\t \n\ttun_mad->hdr.pkey_index = cpu_to_be16(tun_pkey_ix);\n\ttun_mad->hdr.flags_src_qp = cpu_to_be32(wc->src_qp & 0xFFFFFF);\n\ttun_mad->hdr.g_ml_path = (grh && (wc->wc_flags & IB_WC_GRH)) ? 0x80 : 0;\n\n\tif (is_eth) {\n\t\tu16 vlan = 0;\n\t\tif (mlx4_get_slave_default_vlan(dev->dev, port, slave, &vlan,\n\t\t\t\t\t\tNULL)) {\n\t\t\t \n\t\t\tif (vlan != wc->vlan_id)\n\t\t\t\t \n\t\t\t\tgoto out;\n\t\t\t else\n\t\t\t\t \n\t\t\t\tvlan = 0xffff;\n\t\t} else {\n\t\t\tvlan = wc->vlan_id;\n\t\t}\n\n\t\ttun_mad->hdr.sl_vid = cpu_to_be16(vlan);\n\t\tmemcpy((char *)&tun_mad->hdr.mac_31_0, &(wc->smac[0]), 4);\n\t\tmemcpy((char *)&tun_mad->hdr.slid_mac_47_32, &(wc->smac[4]), 2);\n\t} else {\n\t\ttun_mad->hdr.sl_vid = cpu_to_be16(((u16)(wc->sl)) << 12);\n\t\ttun_mad->hdr.slid_mac_47_32 = ib_lid_be16(wc->slid);\n\t}\n\n\tib_dma_sync_single_for_device(&dev->ib_dev,\n\t\t\t\t      tun_qp->tx_ring[tun_tx_ix].buf.map,\n\t\t\t\t      sizeof (struct mlx4_rcv_tunnel_mad),\n\t\t\t\t      DMA_TO_DEVICE);\n\n\tlist.addr = tun_qp->tx_ring[tun_tx_ix].buf.map;\n\tlist.length = sizeof (struct mlx4_rcv_tunnel_mad);\n\tlist.lkey = tun_ctx->pd->local_dma_lkey;\n\n\twr.ah = ah;\n\twr.port_num = port;\n\twr.remote_qkey = IB_QP_SET_QKEY;\n\twr.remote_qpn = dqpn;\n\twr.wr.next = NULL;\n\twr.wr.wr_id = ((u64) tun_tx_ix) | MLX4_TUN_SET_WRID_QPN(dest_qpt);\n\twr.wr.sg_list = &list;\n\twr.wr.num_sge = 1;\n\twr.wr.opcode = IB_WR_SEND;\n\twr.wr.send_flags = IB_SEND_SIGNALED;\n\n\tret = ib_post_send(src_qp, &wr.wr, &bad_wr);\n\tif (!ret)\n\t\treturn 0;\n out:\n\tspin_lock(&tun_qp->tx_lock);\n\ttun_qp->tx_ix_tail++;\n\tspin_unlock(&tun_qp->tx_lock);\n\ttun_qp->tx_ring[tun_tx_ix].ah = NULL;\nend:\n\trdma_destroy_ah(ah, 0);\n\treturn ret;\n}\n\nstatic int mlx4_ib_demux_mad(struct ib_device *ibdev, u32 port,\n\t\t\tstruct ib_wc *wc, struct ib_grh *grh,\n\t\t\tstruct ib_mad *mad)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tint err, other_port;\n\tint slave = -1;\n\tu8 *slave_id;\n\tint is_eth = 0;\n\n\tif (rdma_port_get_link_layer(ibdev, port) == IB_LINK_LAYER_INFINIBAND)\n\t\tis_eth = 0;\n\telse\n\t\tis_eth = 1;\n\n\tif (is_eth) {\n\t\tunion ib_gid dgid;\n\t\tunion ib_gid sgid;\n\n\t\tif (get_gids_from_l3_hdr(grh, &sgid, &dgid))\n\t\t\treturn -EINVAL;\n\t\tif (!(wc->wc_flags & IB_WC_GRH)) {\n\t\t\tmlx4_ib_warn(ibdev, \"RoCE grh not present.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_CM) {\n\t\t\tmlx4_ib_warn(ibdev, \"RoCE mgmt class is not CM\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\terr = mlx4_get_slave_from_roce_gid(dev->dev, port, dgid.raw, &slave);\n\t\tif (err && mlx4_is_mf_bonded(dev->dev)) {\n\t\t\tother_port = (port == 1) ? 2 : 1;\n\t\t\terr = mlx4_get_slave_from_roce_gid(dev->dev, other_port, dgid.raw, &slave);\n\t\t\tif (!err) {\n\t\t\t\tport = other_port;\n\t\t\t\tpr_debug(\"resolved slave %d from gid %pI6 wire port %d other %d\\n\",\n\t\t\t\t\t slave, grh->dgid.raw, port, other_port);\n\t\t\t}\n\t\t}\n\t\tif (err) {\n\t\t\tmlx4_ib_warn(ibdev, \"failed matching grh\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tif (slave >= dev->dev->caps.sqp_demux) {\n\t\t\tmlx4_ib_warn(ibdev, \"slave id: %d is bigger than allowed:%d\\n\",\n\t\t\t\t     slave, dev->dev->caps.sqp_demux);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tif (mlx4_ib_demux_cm_handler(ibdev, port, NULL, mad))\n\t\t\treturn 0;\n\n\t\terr = mlx4_ib_send_to_slave(dev, slave, port, wc->qp->qp_type, wc, grh, mad);\n\t\tif (err)\n\t\t\tpr_debug(\"failed sending %s to slave %d via tunnel qp (%d)\\n\",\n\t\t\t\t is_proxy_qp0(dev, wc->src_qp, slave) ? \"SMI\" : \"GSI\",\n\t\t\t\t slave, err);\n\t\treturn 0;\n\t}\n\n\t \n\tslave = mlx4_master_func_num(dev->dev);\n\n\t \n\tif (mad->mad_hdr.method & 0x80) {\n\t\tslave_id = (u8 *) &mad->mad_hdr.tid;\n\t\tslave = *slave_id;\n\t\tif (slave != 255)  \n\t\t\t*slave_id = 0;  \n\t}\n\n\t \n\tif (wc->wc_flags & IB_WC_GRH) {\n\t\tif (grh->dgid.global.interface_id ==\n\t\t\tcpu_to_be64(IB_SA_WELL_KNOWN_GUID) &&\n\t\t    grh->dgid.global.subnet_prefix == cpu_to_be64(\n\t\t\tatomic64_read(&dev->sriov.demux[port - 1].subnet_prefix))) {\n\t\t\tslave = 0;\n\t\t} else {\n\t\t\tslave = mlx4_ib_find_real_gid(ibdev, port,\n\t\t\t\t\t\t      grh->dgid.global.interface_id);\n\t\t\tif (slave < 0) {\n\t\t\t\tmlx4_ib_warn(ibdev, \"failed matching grh\\n\");\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tswitch (mad->mad_hdr.mgmt_class) {\n\tcase IB_MGMT_CLASS_SUBN_LID_ROUTED:\n\tcase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\n\t\t \n\t\tif (slave != 255 && slave != mlx4_master_func_num(dev->dev)) {\n\t\t\tif (!mlx4_vf_smi_enabled(dev->dev, slave, port))\n\t\t\t\treturn -EPERM;\n\t\t\t \n\t\t\tif (!(mad->mad_hdr.method & IB_MGMT_METHOD_RESP)) {\n\t\t\t\tmlx4_ib_warn(ibdev, \"demux QP0. rejecting unsolicited mad for slave %d class 0x%x, method 0x%x\\n\",\n\t\t\t\t\t     slave, mad->mad_hdr.mgmt_class,\n\t\t\t\t\t     mad->mad_hdr.method);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IB_MGMT_CLASS_SUBN_ADM:\n\t\tif (mlx4_ib_demux_sa_handler(ibdev, port, slave,\n\t\t\t\t\t     (struct ib_sa_mad *) mad))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_CM:\n\t\tif (mlx4_ib_demux_cm_handler(ibdev, port, &slave, mad))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_DEVICE_MGMT:\n\t\tif (mad->mad_hdr.method != IB_MGMT_METHOD_GET_RESP)\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (slave != mlx4_master_func_num(dev->dev)) {\n\t\t\tpr_debug(\"dropping unsupported ingress mad from class:%d \"\n\t\t\t\t \"for slave:%d\\n\", mad->mad_hdr.mgmt_class, slave);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t \n\tif (slave >= dev->dev->caps.sqp_demux) {\n\t\tmlx4_ib_warn(ibdev, \"slave id: %d is bigger than allowed:%d\\n\",\n\t\t\t     slave, dev->dev->caps.sqp_demux);\n\t\treturn -ENOENT;\n\t}\n\n\terr = mlx4_ib_send_to_slave(dev, slave, port, wc->qp->qp_type, wc, grh, mad);\n\tif (err)\n\t\tpr_debug(\"failed sending %s to slave %d via tunnel qp (%d)\\n\",\n\t\t\t is_proxy_qp0(dev, wc->src_qp, slave) ? \"SMI\" : \"GSI\",\n\t\t\t slave, err);\n\treturn 0;\n}\n\nstatic int ib_process_mad(struct ib_device *ibdev, int mad_flags, u32 port_num,\n\t\t\tconst struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t\tconst struct ib_mad *in_mad, struct ib_mad *out_mad)\n{\n\tu16 slid, prev_lid = 0;\n\tint err;\n\tstruct ib_port_attr pattr;\n\n\tslid = in_wc ? ib_lid_cpu16(in_wc->slid) : be16_to_cpu(IB_LID_PERMISSIVE);\n\n\tif (in_mad->mad_hdr.method == IB_MGMT_METHOD_TRAP && slid == 0) {\n\t\tforward_trap(to_mdev(ibdev), port_num, in_mad);\n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\t}\n\n\tif (in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t    in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) {\n\t\tif (in_mad->mad_hdr.method   != IB_MGMT_METHOD_GET &&\n\t\t    in_mad->mad_hdr.method   != IB_MGMT_METHOD_SET &&\n\t\t    in_mad->mad_hdr.method   != IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\n\t\t \n\t\tif (in_mad->mad_hdr.attr_id == IB_SMP_ATTR_SM_INFO)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} else if (in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_PERF_MGMT ||\n\t\t   in_mad->mad_hdr.mgmt_class == MLX4_IB_VENDOR_CLASS1   ||\n\t\t   in_mad->mad_hdr.mgmt_class == MLX4_IB_VENDOR_CLASS2   ||\n\t\t   in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_CONG_MGMT) {\n\t\tif (in_mad->mad_hdr.method  != IB_MGMT_METHOD_GET &&\n\t\t    in_mad->mad_hdr.method  != IB_MGMT_METHOD_SET)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} else\n\t\treturn IB_MAD_RESULT_SUCCESS;\n\n\tif ((in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    in_mad->mad_hdr.method == IB_MGMT_METHOD_SET &&\n\t    in_mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&\n\t    !ib_query_port(ibdev, port_num, &pattr))\n\t\tprev_lid = ib_lid_cpu16(pattr.lid);\n\n\terr = mlx4_MAD_IFC(to_mdev(ibdev),\n\t\t\t   (mad_flags & IB_MAD_IGNORE_MKEY ? MLX4_MAD_IFC_IGNORE_MKEY : 0) |\n\t\t\t   (mad_flags & IB_MAD_IGNORE_BKEY ? MLX4_MAD_IFC_IGNORE_BKEY : 0) |\n\t\t\t   MLX4_MAD_IFC_NET_VIEW,\n\t\t\t   port_num, in_wc, in_grh, in_mad, out_mad);\n\tif (err)\n\t\treturn IB_MAD_RESULT_FAILURE;\n\n\tif (!out_mad->mad_hdr.status) {\n\t\tsmp_snoop(ibdev, port_num, in_mad, prev_lid);\n\t\t \n\t\tif (!mlx4_is_slave(to_mdev(ibdev)->dev))\n\t\t\tnode_desc_override(ibdev, out_mad);\n\t}\n\n\t \n\tif (in_mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\tout_mad->mad_hdr.status |= cpu_to_be16(1 << 15);\n\n\tif (in_mad->mad_hdr.method == IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t \n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n}\n\nstatic void edit_counter(struct mlx4_counter *cnt, void *counters,\n\t\t\t __be16 attr_id)\n{\n\tswitch (attr_id) {\n\tcase IB_PMA_PORT_COUNTERS:\n\t{\n\t\tstruct ib_pma_portcounters *pma_cnt =\n\t\t\t(struct ib_pma_portcounters *)counters;\n\n\t\tASSIGN_32BIT_COUNTER(pma_cnt->port_xmit_data,\n\t\t\t\t     (be64_to_cpu(cnt->tx_bytes) >> 2));\n\t\tASSIGN_32BIT_COUNTER(pma_cnt->port_rcv_data,\n\t\t\t\t     (be64_to_cpu(cnt->rx_bytes) >> 2));\n\t\tASSIGN_32BIT_COUNTER(pma_cnt->port_xmit_packets,\n\t\t\t\t     be64_to_cpu(cnt->tx_frames));\n\t\tASSIGN_32BIT_COUNTER(pma_cnt->port_rcv_packets,\n\t\t\t\t     be64_to_cpu(cnt->rx_frames));\n\t\tbreak;\n\t}\n\tcase IB_PMA_PORT_COUNTERS_EXT:\n\t{\n\t\tstruct ib_pma_portcounters_ext *pma_cnt_ext =\n\t\t\t(struct ib_pma_portcounters_ext *)counters;\n\n\t\tpma_cnt_ext->port_xmit_data =\n\t\t\tcpu_to_be64(be64_to_cpu(cnt->tx_bytes) >> 2);\n\t\tpma_cnt_ext->port_rcv_data =\n\t\t\tcpu_to_be64(be64_to_cpu(cnt->rx_bytes) >> 2);\n\t\tpma_cnt_ext->port_xmit_packets = cnt->tx_frames;\n\t\tpma_cnt_ext->port_rcv_packets = cnt->rx_frames;\n\t\tbreak;\n\t}\n\t}\n}\n\nstatic int iboe_process_mad_port_info(void *out_mad)\n{\n\tstruct ib_class_port_info cpi = {};\n\n\tcpi.capability_mask = IB_PMA_CLASS_CAP_EXT_WIDTH;\n\tmemcpy(out_mad, &cpi, sizeof(cpi));\n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n}\n\nstatic int iboe_process_mad(struct ib_device *ibdev, int mad_flags,\n\t\t\t    u32 port_num, const struct ib_wc *in_wc,\n\t\t\t    const struct ib_grh *in_grh,\n\t\t\t    const struct ib_mad *in_mad, struct ib_mad *out_mad)\n{\n\tstruct mlx4_counter counter_stats;\n\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tstruct counter_index *tmp_counter;\n\tint err = IB_MAD_RESULT_FAILURE, stats_avail = 0;\n\n\tif (in_mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_PERF_MGMT)\n\t\treturn -EINVAL;\n\n\tif (in_mad->mad_hdr.attr_id == IB_PMA_CLASS_PORT_INFO)\n\t\treturn iboe_process_mad_port_info((void *)(out_mad->data + 40));\n\n\tmemset(&counter_stats, 0, sizeof(counter_stats));\n\tmutex_lock(&dev->counters_table[port_num - 1].mutex);\n\tlist_for_each_entry(tmp_counter,\n\t\t\t    &dev->counters_table[port_num - 1].counters_list,\n\t\t\t    list) {\n\t\terr = mlx4_get_counter_stats(dev->dev,\n\t\t\t\t\t     tmp_counter->index,\n\t\t\t\t\t     &counter_stats, 0);\n\t\tif (err) {\n\t\t\terr = IB_MAD_RESULT_FAILURE;\n\t\t\tstats_avail = 0;\n\t\t\tbreak;\n\t\t}\n\t\tstats_avail = 1;\n\t}\n\tmutex_unlock(&dev->counters_table[port_num - 1].mutex);\n\tif (stats_avail) {\n\t\tswitch (counter_stats.counter_mode & 0xf) {\n\t\tcase 0:\n\t\t\tedit_counter(&counter_stats,\n\t\t\t\t     (void *)(out_mad->data + 40),\n\t\t\t\t     in_mad->mad_hdr.attr_id);\n\t\t\terr = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = IB_MAD_RESULT_FAILURE;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint mlx4_ib_process_mad(struct ib_device *ibdev, int mad_flags, u32 port_num,\n\t\t\tconst struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t\tconst struct ib_mad *in, struct ib_mad *out,\n\t\t\tsize_t *out_mad_size, u16 *out_mad_pkey_index)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ibdev);\n\tenum rdma_link_layer link = rdma_port_get_link_layer(ibdev, port_num);\n\n\t \n\tif (link == IB_LINK_LAYER_INFINIBAND) {\n\t\tif (mlx4_is_slave(dev->dev) &&\n\t\t    (in->mad_hdr.mgmt_class == IB_MGMT_CLASS_PERF_MGMT &&\n\t\t     (in->mad_hdr.attr_id == IB_PMA_PORT_COUNTERS ||\n\t\t      in->mad_hdr.attr_id == IB_PMA_PORT_COUNTERS_EXT ||\n\t\t      in->mad_hdr.attr_id == IB_PMA_CLASS_PORT_INFO)))\n\t\t\treturn iboe_process_mad(ibdev, mad_flags, port_num,\n\t\t\t\t\t\tin_wc, in_grh, in, out);\n\n\t\treturn ib_process_mad(ibdev, mad_flags, port_num, in_wc, in_grh,\n\t\t\t\t      in, out);\n\t}\n\n\tif (link == IB_LINK_LAYER_ETHERNET)\n\t\treturn iboe_process_mad(ibdev, mad_flags, port_num, in_wc,\n\t\t\t\t\tin_grh, in, out);\n\n\treturn -EINVAL;\n}\n\nstatic void send_handler(struct ib_mad_agent *agent,\n\t\t\t struct ib_mad_send_wc *mad_send_wc)\n{\n\tif (mad_send_wc->send_buf->context[0])\n\t\trdma_destroy_ah(mad_send_wc->send_buf->context[0], 0);\n\tib_free_send_mad(mad_send_wc->send_buf);\n}\n\nint mlx4_ib_mad_init(struct mlx4_ib_dev *dev)\n{\n\tstruct ib_mad_agent *agent;\n\tint p, q;\n\tint ret;\n\tenum rdma_link_layer ll;\n\n\tfor (p = 0; p < dev->num_ports; ++p) {\n\t\tll = rdma_port_get_link_layer(&dev->ib_dev, p + 1);\n\t\tfor (q = 0; q <= 1; ++q) {\n\t\t\tif (ll == IB_LINK_LAYER_INFINIBAND) {\n\t\t\t\tagent = ib_register_mad_agent(&dev->ib_dev, p + 1,\n\t\t\t\t\t\t\t      q ? IB_QPT_GSI : IB_QPT_SMI,\n\t\t\t\t\t\t\t      NULL, 0, send_handler,\n\t\t\t\t\t\t\t      NULL, NULL, 0);\n\t\t\t\tif (IS_ERR(agent)) {\n\t\t\t\t\tret = PTR_ERR(agent);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tdev->send_agent[p][q] = agent;\n\t\t\t} else\n\t\t\t\tdev->send_agent[p][q] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (p = 0; p < dev->num_ports; ++p)\n\t\tfor (q = 0; q <= 1; ++q)\n\t\t\tif (dev->send_agent[p][q])\n\t\t\t\tib_unregister_mad_agent(dev->send_agent[p][q]);\n\n\treturn ret;\n}\n\nvoid mlx4_ib_mad_cleanup(struct mlx4_ib_dev *dev)\n{\n\tstruct ib_mad_agent *agent;\n\tint p, q;\n\n\tfor (p = 0; p < dev->num_ports; ++p) {\n\t\tfor (q = 0; q <= 1; ++q) {\n\t\t\tagent = dev->send_agent[p][q];\n\t\t\tif (agent) {\n\t\t\t\tdev->send_agent[p][q] = NULL;\n\t\t\t\tib_unregister_mad_agent(agent);\n\t\t\t}\n\t\t}\n\n\t\tif (dev->sm_ah[p])\n\t\t\trdma_destroy_ah(dev->sm_ah[p], 0);\n\t}\n}\n\nstatic void handle_lid_change_event(struct mlx4_ib_dev *dev, u32 port_num)\n{\n\tmlx4_ib_dispatch_event(dev, port_num, IB_EVENT_LID_CHANGE);\n\n\tif (mlx4_is_master(dev->dev) && !dev->sriov.is_going_down)\n\t\tmlx4_gen_slaves_port_mgt_ev(dev->dev, port_num,\n\t\t\t\t\t    MLX4_EQ_PORT_INFO_LID_CHANGE_MASK);\n}\n\nstatic void handle_client_rereg_event(struct mlx4_ib_dev *dev, u32 port_num)\n{\n\t \n\tif (mlx4_is_master(dev->dev)) {\n\t\tmlx4_ib_invalidate_all_guid_record(dev, port_num);\n\n\t\tif (!dev->sriov.is_going_down) {\n\t\t\tmlx4_ib_mcg_port_cleanup(&dev->sriov.demux[port_num - 1], 0);\n\t\t\tmlx4_gen_slaves_port_mgt_ev(dev->dev, port_num,\n\t\t\t\t\t\t    MLX4_EQ_PORT_INFO_CLIENT_REREG_MASK);\n\t\t}\n\t}\n\n\t \n\tif (!mlx4_is_slave(dev->dev) &&\n\t    dev->dev->flags & MLX4_FLAG_SECURE_HOST &&\n\t    !(dev->dev->caps.flags2 & MLX4_DEV_CAP_FLAG2_SL_TO_VL_CHANGE_EVENT)) {\n\t\tif (mlx4_is_master(dev->dev))\n\t\t\t \n\t\t\tmlx4_ib_sl2vl_update(dev, port_num);\n\t\telse\n\t\t\tmlx4_sched_ib_sl2vl_update_work(dev, port_num);\n\t}\n\tmlx4_ib_dispatch_event(dev, port_num, IB_EVENT_CLIENT_REREGISTER);\n}\n\nstatic void propagate_pkey_ev(struct mlx4_ib_dev *dev, int port_num,\n\t\t\t      struct mlx4_eqe *eqe)\n{\n\t__propagate_pkey_ev(dev, port_num, GET_BLK_PTR_FROM_EQE(eqe),\n\t\t\t    GET_MASK_FROM_EQE(eqe));\n}\n\nstatic void handle_slaves_guid_change(struct mlx4_ib_dev *dev, u32 port_num,\n\t\t\t\t      u32 guid_tbl_blk_num, u32 change_bitmap)\n{\n\tstruct ib_smp *in_mad  = NULL;\n\tstruct ib_smp *out_mad  = NULL;\n\tu16 i;\n\n\tif (!mlx4_is_mfunc(dev->dev) || !mlx4_is_master(dev->dev))\n\t\treturn;\n\n\tin_mad  = kmalloc(sizeof *in_mad, GFP_KERNEL);\n\tout_mad = kmalloc(sizeof *out_mad, GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tguid_tbl_blk_num  *= 4;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (change_bitmap && (!((change_bitmap >> (8 * i)) & 0xff)))\n\t\t\tcontinue;\n\t\tmemset(in_mad, 0, sizeof *in_mad);\n\t\tmemset(out_mad, 0, sizeof *out_mad);\n\n\t\tin_mad->base_version  = 1;\n\t\tin_mad->mgmt_class    = IB_MGMT_CLASS_SUBN_LID_ROUTED;\n\t\tin_mad->class_version = 1;\n\t\tin_mad->method        = IB_MGMT_METHOD_GET;\n\t\tin_mad->attr_id       = IB_SMP_ATTR_GUID_INFO;\n\t\tin_mad->attr_mod      = cpu_to_be32(guid_tbl_blk_num + i);\n\n\t\tif (mlx4_MAD_IFC(dev,\n\t\t\t\t MLX4_MAD_IFC_IGNORE_KEYS | MLX4_MAD_IFC_NET_VIEW,\n\t\t\t\t port_num, NULL, NULL, in_mad, out_mad)) {\n\t\t\tmlx4_ib_warn(&dev->ib_dev, \"Failed in get GUID INFO MAD_IFC\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tmlx4_ib_update_cache_on_guid_change(dev, guid_tbl_blk_num + i,\n\t\t\t\t\t\t    port_num,\n\t\t\t\t\t\t    (u8 *)(&((struct ib_smp *)out_mad)->data));\n\t\tmlx4_ib_notify_slaves_on_guid_change(dev, guid_tbl_blk_num + i,\n\t\t\t\t\t\t     port_num,\n\t\t\t\t\t\t     (u8 *)(&((struct ib_smp *)out_mad)->data));\n\t}\n\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn;\n}\n\nvoid handle_port_mgmt_change_event(struct work_struct *work)\n{\n\tstruct ib_event_work *ew = container_of(work, struct ib_event_work, work);\n\tstruct mlx4_ib_dev *dev = ew->ib_dev;\n\tstruct mlx4_eqe *eqe = &(ew->ib_eqe);\n\tu32 port = eqe->event.port_mgmt_change.port;\n\tu32 changed_attr;\n\tu32 tbl_block;\n\tu32 change_bitmap;\n\n\tswitch (eqe->subtype) {\n\tcase MLX4_DEV_PMC_SUBTYPE_PORT_INFO:\n\t\tchanged_attr = be32_to_cpu(eqe->event.port_mgmt_change.params.port_info.changed_attr);\n\n\t\t \n\t\tif (changed_attr & MSTR_SM_CHANGE_MASK) {\n\t\t\tu16 lid = be16_to_cpu(eqe->event.port_mgmt_change.params.port_info.mstr_sm_lid);\n\t\t\tu8 sl = eqe->event.port_mgmt_change.params.port_info.mstr_sm_sl & 0xf;\n\t\t\tupdate_sm_ah(dev, port, lid, sl);\n\t\t}\n\n\t\t \n\t\tif (changed_attr & MLX4_EQ_PORT_INFO_LID_CHANGE_MASK)\n\t\t\thandle_lid_change_event(dev, port);\n\n\t\t \n\t\tif (changed_attr & MLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK) {\n\t\t\tif (mlx4_is_master(dev->dev)) {\n\t\t\t\tunion ib_gid gid;\n\t\t\t\tint err = 0;\n\n\t\t\t\tif (!eqe->event.port_mgmt_change.params.port_info.gid_prefix)\n\t\t\t\t\terr = __mlx4_ib_query_gid(&dev->ib_dev, port, 0, &gid, 1);\n\t\t\t\telse\n\t\t\t\t\tgid.global.subnet_prefix =\n\t\t\t\t\t\teqe->event.port_mgmt_change.params.port_info.gid_prefix;\n\t\t\t\tif (err) {\n\t\t\t\t\tpr_warn(\"Could not change QP1 subnet prefix for port %d: query_gid error (%d)\\n\",\n\t\t\t\t\t\tport, err);\n\t\t\t\t} else {\n\t\t\t\t\tpr_debug(\"Changing QP1 subnet prefix for port %d. old=0x%llx. new=0x%llx\\n\",\n\t\t\t\t\t\t port,\n\t\t\t\t\t\t (u64)atomic64_read(&dev->sriov.demux[port - 1].subnet_prefix),\n\t\t\t\t\t\t be64_to_cpu(gid.global.subnet_prefix));\n\t\t\t\t\tatomic64_set(&dev->sriov.demux[port - 1].subnet_prefix,\n\t\t\t\t\t\t     be64_to_cpu(gid.global.subnet_prefix));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmlx4_ib_dispatch_event(dev, port, IB_EVENT_GID_CHANGE);\n\t\t\t \n\t\t\tif (mlx4_is_master(dev->dev))\n\t\t\t\tmlx4_gen_slaves_port_mgt_ev(dev->dev, port,\n\t\t\t\t\t\t\t    MLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK);\n\t\t}\n\n\t\tif (changed_attr & MLX4_EQ_PORT_INFO_CLIENT_REREG_MASK)\n\t\t\thandle_client_rereg_event(dev, port);\n\t\tbreak;\n\n\tcase MLX4_DEV_PMC_SUBTYPE_PKEY_TABLE:\n\t\tmlx4_ib_dispatch_event(dev, port, IB_EVENT_PKEY_CHANGE);\n\t\tif (mlx4_is_master(dev->dev) && !dev->sriov.is_going_down)\n\t\t\tpropagate_pkey_ev(dev, port, eqe);\n\t\tbreak;\n\tcase MLX4_DEV_PMC_SUBTYPE_GUID_INFO:\n\t\t \n\t\tif (!mlx4_is_master(dev->dev))\n\t\t\tmlx4_ib_dispatch_event(dev, port, IB_EVENT_GID_CHANGE);\n\t\t \n\t\telse if (!dev->sriov.is_going_down) {\n\t\t\ttbl_block = GET_BLK_PTR_FROM_EQE(eqe);\n\t\t\tchange_bitmap = GET_MASK_FROM_EQE(eqe);\n\t\t\thandle_slaves_guid_change(dev, port, tbl_block, change_bitmap);\n\t\t}\n\t\tbreak;\n\n\tcase MLX4_DEV_PMC_SUBTYPE_SL_TO_VL_MAP:\n\t\t \n\t\tif (!mlx4_is_slave(dev->dev)) {\n\t\t\tunion sl2vl_tbl_to_u64 sl2vl64;\n\t\t\tint jj;\n\n\t\t\tfor (jj = 0; jj < 8; jj++) {\n\t\t\t\tsl2vl64.sl8[jj] =\n\t\t\t\t\teqe->event.port_mgmt_change.params.sl2vl_tbl_change_info.sl2vl_table[jj];\n\t\t\t\tpr_debug(\"port %u, sl2vl[%d] = %02x\\n\",\n\t\t\t\t\t port, jj, sl2vl64.sl8[jj]);\n\t\t\t}\n\t\t\tatomic64_set(&dev->sl2vl[port - 1], sl2vl64.sl64);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"Unsupported subtype 0x%x for \"\n\t\t\t\"Port Management Change event\\n\", eqe->subtype);\n\t}\n\n\tkfree(ew);\n}\n\nvoid mlx4_ib_dispatch_event(struct mlx4_ib_dev *dev, u32 port_num,\n\t\t\t    enum ib_event_type type)\n{\n\tstruct ib_event event;\n\n\tevent.device\t\t= &dev->ib_dev;\n\tevent.element.port_num\t= port_num;\n\tevent.event\t\t= type;\n\n\tib_dispatch_event(&event);\n}\n\nstatic void mlx4_ib_tunnel_comp_handler(struct ib_cq *cq, void *arg)\n{\n\tunsigned long flags;\n\tstruct mlx4_ib_demux_pv_ctx *ctx = cq->cq_context;\n\tstruct mlx4_ib_dev *dev = to_mdev(ctx->ib_dev);\n\tspin_lock_irqsave(&dev->sriov.going_down_lock, flags);\n\tif (!dev->sriov.is_going_down && ctx->state == DEMUX_PV_STATE_ACTIVE)\n\t\tqueue_work(ctx->wq, &ctx->work);\n\tspin_unlock_irqrestore(&dev->sriov.going_down_lock, flags);\n}\n\nstatic void mlx4_ib_wire_comp_handler(struct ib_cq *cq, void *arg)\n{\n\tunsigned long flags;\n\tstruct mlx4_ib_demux_pv_ctx *ctx = cq->cq_context;\n\tstruct mlx4_ib_dev *dev = to_mdev(ctx->ib_dev);\n\n\tspin_lock_irqsave(&dev->sriov.going_down_lock, flags);\n\tif (!dev->sriov.is_going_down && ctx->state == DEMUX_PV_STATE_ACTIVE)\n\t\tqueue_work(ctx->wi_wq, &ctx->work);\n\tspin_unlock_irqrestore(&dev->sriov.going_down_lock, flags);\n}\n\nstatic int mlx4_ib_post_pv_qp_buf(struct mlx4_ib_demux_pv_ctx *ctx,\n\t\t\t\t  struct mlx4_ib_demux_pv_qp *tun_qp,\n\t\t\t\t  int index)\n{\n\tstruct ib_sge sg_list;\n\tstruct ib_recv_wr recv_wr;\n\tconst struct ib_recv_wr *bad_recv_wr;\n\tint size;\n\n\tsize = (tun_qp->qp->qp_type == IB_QPT_UD) ?\n\t\tsizeof (struct mlx4_tunnel_mad) : sizeof (struct mlx4_mad_rcv_buf);\n\n\tsg_list.addr = tun_qp->ring[index].map;\n\tsg_list.length = size;\n\tsg_list.lkey = ctx->pd->local_dma_lkey;\n\n\trecv_wr.next = NULL;\n\trecv_wr.sg_list = &sg_list;\n\trecv_wr.num_sge = 1;\n\trecv_wr.wr_id = (u64) index | MLX4_TUN_WRID_RECV |\n\t\tMLX4_TUN_SET_WRID_QPN(tun_qp->proxy_qpt);\n\tib_dma_sync_single_for_device(ctx->ib_dev, tun_qp->ring[index].map,\n\t\t\t\t      size, DMA_FROM_DEVICE);\n\treturn ib_post_recv(tun_qp->qp, &recv_wr, &bad_recv_wr);\n}\n\nstatic int mlx4_ib_multiplex_sa_handler(struct ib_device *ibdev, int port,\n\t\tint slave, struct ib_sa_mad *sa_mad)\n{\n\tint ret = 0;\n\n\t \n\tswitch (be16_to_cpu(sa_mad->mad_hdr.attr_id)) {\n\tcase IB_SA_ATTR_MC_MEMBER_REC:\n\t\tret = mlx4_ib_mcg_multiplex_handler(ibdev, port, slave, sa_mad);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u32 port,\n\t\t\t enum ib_qp_type dest_qpt, u16 pkey_index,\n\t\t\t u32 remote_qpn, u32 qkey, struct rdma_ah_attr *attr,\n\t\t\t u8 *s_mac, u16 vlan_id, struct ib_mad *mad)\n{\n\tstruct ib_sge list;\n\tstruct ib_ud_wr wr;\n\tconst struct ib_send_wr *bad_wr;\n\tstruct mlx4_ib_demux_pv_ctx *sqp_ctx;\n\tstruct mlx4_ib_demux_pv_qp *sqp;\n\tstruct mlx4_mad_snd_buf *sqp_mad;\n\tstruct ib_ah *ah;\n\tstruct ib_qp *send_qp = NULL;\n\tunsigned wire_tx_ix = 0;\n\tu16 wire_pkey_ix;\n\tint src_qpnum;\n\tint ret;\n\n\tsqp_ctx = dev->sriov.sqps[port-1];\n\n\t \n\tif (!sqp_ctx || sqp_ctx->state != DEMUX_PV_STATE_ACTIVE)\n\t\treturn -EAGAIN;\n\n\tif (dest_qpt == IB_QPT_SMI) {\n\t\tsrc_qpnum = 0;\n\t\tsqp = &sqp_ctx->qp[0];\n\t\twire_pkey_ix = dev->pkeys.virt2phys_pkey[slave][port - 1][0];\n\t} else {\n\t\tsrc_qpnum = 1;\n\t\tsqp = &sqp_ctx->qp[1];\n\t\twire_pkey_ix = dev->pkeys.virt2phys_pkey[slave][port - 1][pkey_index];\n\t}\n\n\tsend_qp = sqp->qp;\n\n\tah = rdma_zalloc_drv_obj(sqp_ctx->pd->device, ib_ah);\n\tif (!ah)\n\t\treturn -ENOMEM;\n\n\tah->device = sqp_ctx->pd->device;\n\tah->pd = sqp_ctx->pd;\n\n\t \n\tret = mlx4_ib_create_ah_slave(ah, attr,\n\t\t\t\t      rdma_ah_retrieve_grh(attr)->sgid_index,\n\t\t\t\t      s_mac, vlan_id);\n\tif (ret)\n\t\tgoto out;\n\n\tspin_lock(&sqp->tx_lock);\n\tif (sqp->tx_ix_head - sqp->tx_ix_tail >=\n\t    (MLX4_NUM_WIRE_BUFS - 1))\n\t\tret = -EAGAIN;\n\telse\n\t\twire_tx_ix = (++sqp->tx_ix_head) & (MLX4_NUM_WIRE_BUFS - 1);\n\tspin_unlock(&sqp->tx_lock);\n\tif (ret)\n\t\tgoto out;\n\n\tsqp_mad = (struct mlx4_mad_snd_buf *) (sqp->tx_ring[wire_tx_ix].buf.addr);\n\tkfree(sqp->tx_ring[wire_tx_ix].ah);\n\tsqp->tx_ring[wire_tx_ix].ah = ah;\n\tib_dma_sync_single_for_cpu(&dev->ib_dev,\n\t\t\t\t   sqp->tx_ring[wire_tx_ix].buf.map,\n\t\t\t\t   sizeof (struct mlx4_mad_snd_buf),\n\t\t\t\t   DMA_TO_DEVICE);\n\n\tmemcpy(&sqp_mad->payload, mad, sizeof *mad);\n\n\tib_dma_sync_single_for_device(&dev->ib_dev,\n\t\t\t\t      sqp->tx_ring[wire_tx_ix].buf.map,\n\t\t\t\t      sizeof (struct mlx4_mad_snd_buf),\n\t\t\t\t      DMA_TO_DEVICE);\n\n\tlist.addr = sqp->tx_ring[wire_tx_ix].buf.map;\n\tlist.length = sizeof (struct mlx4_mad_snd_buf);\n\tlist.lkey = sqp_ctx->pd->local_dma_lkey;\n\n\twr.ah = ah;\n\twr.port_num = port;\n\twr.pkey_index = wire_pkey_ix;\n\twr.remote_qkey = qkey;\n\twr.remote_qpn = remote_qpn;\n\twr.wr.next = NULL;\n\twr.wr.wr_id = ((u64) wire_tx_ix) | MLX4_TUN_SET_WRID_QPN(src_qpnum);\n\twr.wr.sg_list = &list;\n\twr.wr.num_sge = 1;\n\twr.wr.opcode = IB_WR_SEND;\n\twr.wr.send_flags = IB_SEND_SIGNALED;\n\n\tret = ib_post_send(send_qp, &wr.wr, &bad_wr);\n\tif (!ret)\n\t\treturn 0;\n\n\tspin_lock(&sqp->tx_lock);\n\tsqp->tx_ix_tail++;\n\tspin_unlock(&sqp->tx_lock);\n\tsqp->tx_ring[wire_tx_ix].ah = NULL;\nout:\n\tkfree(ah);\n\treturn ret;\n}\n\nstatic int get_slave_base_gid_ix(struct mlx4_ib_dev *dev, int slave, int port)\n{\n\tif (rdma_port_get_link_layer(&dev->ib_dev, port) == IB_LINK_LAYER_INFINIBAND)\n\t\treturn slave;\n\treturn mlx4_get_base_gid_ix(dev->dev, slave, port);\n}\n\nstatic void fill_in_real_sgid_index(struct mlx4_ib_dev *dev, int slave, int port,\n\t\t\t\t    struct rdma_ah_attr *ah_attr)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(ah_attr);\n\tif (rdma_port_get_link_layer(&dev->ib_dev, port) == IB_LINK_LAYER_INFINIBAND)\n\t\tgrh->sgid_index = slave;\n\telse\n\t\tgrh->sgid_index += get_slave_base_gid_ix(dev, slave, port);\n}\n\nstatic void mlx4_ib_multiplex_mad(struct mlx4_ib_demux_pv_ctx *ctx, struct ib_wc *wc)\n{\n\tstruct mlx4_ib_dev *dev = to_mdev(ctx->ib_dev);\n\tstruct mlx4_ib_demux_pv_qp *tun_qp = &ctx->qp[MLX4_TUN_WRID_QPN(wc->wr_id)];\n\tint wr_ix = wc->wr_id & (MLX4_NUM_TUNNEL_BUFS - 1);\n\tstruct mlx4_tunnel_mad *tunnel = tun_qp->ring[wr_ix].addr;\n\tstruct mlx4_ib_ah ah;\n\tstruct rdma_ah_attr ah_attr;\n\tu8 *slave_id;\n\tint slave;\n\tint port;\n\tu16 vlan_id;\n\tu8 qos;\n\tu8 *dmac;\n\tint sts;\n\n\t \n\tif (wc->src_qp < dev->dev->phys_caps.base_proxy_sqpn ||\n\t    wc->src_qp >= dev->dev->phys_caps.base_proxy_sqpn + 8 * MLX4_MFUNC_MAX ||\n\t    (wc->src_qp & 0x1) != ctx->port - 1 ||\n\t    wc->src_qp & 0x4) {\n\t\tmlx4_ib_warn(ctx->ib_dev, \"can't multiplex bad sqp:%d\\n\", wc->src_qp);\n\t\treturn;\n\t}\n\tslave = ((wc->src_qp & ~0x7) - dev->dev->phys_caps.base_proxy_sqpn) / 8;\n\tif (slave != ctx->slave) {\n\t\tmlx4_ib_warn(ctx->ib_dev, \"can't multiplex bad sqp:%d: \"\n\t\t\t     \"belongs to another slave\\n\", wc->src_qp);\n\t\treturn;\n\t}\n\n\t \n\tib_dma_sync_single_for_cpu(ctx->ib_dev, tun_qp->ring[wr_ix].map,\n\t\t\t\t   sizeof (struct mlx4_tunnel_mad),\n\t\t\t\t   DMA_FROM_DEVICE);\n\tswitch (tunnel->mad.mad_hdr.method) {\n\tcase IB_MGMT_METHOD_SET:\n\tcase IB_MGMT_METHOD_GET:\n\tcase IB_MGMT_METHOD_REPORT:\n\tcase IB_SA_METHOD_GET_TABLE:\n\tcase IB_SA_METHOD_DELETE:\n\tcase IB_SA_METHOD_GET_MULTI:\n\tcase IB_SA_METHOD_GET_TRACE_TBL:\n\t\tslave_id = (u8 *) &tunnel->mad.mad_hdr.tid;\n\t\tif (*slave_id) {\n\t\t\tmlx4_ib_warn(ctx->ib_dev, \"egress mad has non-null tid msb:%d \"\n\t\t\t\t     \"class:%d slave:%d\\n\", *slave_id,\n\t\t\t\t     tunnel->mad.mad_hdr.mgmt_class, slave);\n\t\t\treturn;\n\t\t} else\n\t\t\t*slave_id = slave;\n\t\tbreak;\n\tdefault:\n\t\t ;\n\t}\n\n\t \n\tswitch (tunnel->mad.mad_hdr.mgmt_class) {\n\tcase IB_MGMT_CLASS_SUBN_LID_ROUTED:\n\tcase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\n\t\tif (slave != mlx4_master_func_num(dev->dev) &&\n\t\t    !mlx4_vf_smi_enabled(dev->dev, slave, ctx->port))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_SUBN_ADM:\n\t\tif (mlx4_ib_multiplex_sa_handler(ctx->ib_dev, ctx->port, slave,\n\t\t\t      (struct ib_sa_mad *) &tunnel->mad))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_CM:\n\t\tif (mlx4_ib_multiplex_cm_handler(ctx->ib_dev, ctx->port, slave,\n\t\t\t      (struct ib_mad *) &tunnel->mad))\n\t\t\treturn;\n\t\tbreak;\n\tcase IB_MGMT_CLASS_DEVICE_MGMT:\n\t\tif (tunnel->mad.mad_hdr.method != IB_MGMT_METHOD_GET &&\n\t\t    tunnel->mad.mad_hdr.method != IB_MGMT_METHOD_SET)\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (slave != mlx4_master_func_num(dev->dev)) {\n\t\t\tmlx4_ib_warn(ctx->ib_dev, \"dropping unsupported egress mad from class:%d \"\n\t\t\t\t     \"for slave:%d\\n\", tunnel->mad.mad_hdr.mgmt_class, slave);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tmemcpy(&ah.av, &tunnel->hdr.av, sizeof (struct mlx4_av));\n\tah.ibah.device = ctx->ib_dev;\n\n\tport = be32_to_cpu(ah.av.ib.port_pd) >> 24;\n\tport = mlx4_slave_convert_port(dev->dev, slave, port);\n\tif (port < 0)\n\t\treturn;\n\tah.av.ib.port_pd = cpu_to_be32(port << 24 | (be32_to_cpu(ah.av.ib.port_pd) & 0xffffff));\n\tah.ibah.type = rdma_ah_find_type(&dev->ib_dev, port);\n\n\tmlx4_ib_query_ah(&ah.ibah, &ah_attr);\n\tif (rdma_ah_get_ah_flags(&ah_attr) & IB_AH_GRH)\n\t\tfill_in_real_sgid_index(dev, slave, ctx->port, &ah_attr);\n\tdmac = rdma_ah_retrieve_dmac(&ah_attr);\n\tif (dmac)\n\t\tmemcpy(dmac, tunnel->hdr.mac, ETH_ALEN);\n\tvlan_id = be16_to_cpu(tunnel->hdr.vlan);\n\t \n\tif (mlx4_get_slave_default_vlan(dev->dev, ctx->port, slave,\n\t\t\t\t\t&vlan_id, &qos))\n\t\trdma_ah_set_sl(&ah_attr, qos);\n\n\tsts = mlx4_ib_send_to_wire(dev, slave, ctx->port,\n\t\t\t\t   is_proxy_qp0(dev, wc->src_qp, slave) ?\n\t\t\t\t   IB_QPT_SMI : IB_QPT_GSI,\n\t\t\t\t   be16_to_cpu(tunnel->hdr.pkey_index),\n\t\t\t\t   be32_to_cpu(tunnel->hdr.remote_qpn),\n\t\t\t\t   be32_to_cpu(tunnel->hdr.qkey),\n\t\t\t\t   &ah_attr, wc->smac, vlan_id, &tunnel->mad);\n\tif (sts)\n\t\tpr_debug(\"failed sending %s to wire on behalf of slave %d (%d)\\n\",\n\t\t\t is_proxy_qp0(dev, wc->src_qp, slave) ? \"SMI\" : \"GSI\",\n\t\t\t slave, sts);\n}\n\nstatic int mlx4_ib_alloc_pv_bufs(struct mlx4_ib_demux_pv_ctx *ctx,\n\t\t\t\t enum ib_qp_type qp_type, int is_tun)\n{\n\tint i;\n\tstruct mlx4_ib_demux_pv_qp *tun_qp;\n\tint rx_buf_size, tx_buf_size;\n\tconst int nmbr_bufs = is_tun ? MLX4_NUM_TUNNEL_BUFS : MLX4_NUM_WIRE_BUFS;\n\n\tif (qp_type > IB_QPT_GSI)\n\t\treturn -EINVAL;\n\n\ttun_qp = &ctx->qp[qp_type];\n\n\ttun_qp->ring = kcalloc(nmbr_bufs,\n\t\t\t       sizeof(struct mlx4_ib_buf),\n\t\t\t       GFP_KERNEL);\n\tif (!tun_qp->ring)\n\t\treturn -ENOMEM;\n\n\ttun_qp->tx_ring = kcalloc(nmbr_bufs,\n\t\t\t\t  sizeof (struct mlx4_ib_tun_tx_buf),\n\t\t\t\t  GFP_KERNEL);\n\tif (!tun_qp->tx_ring) {\n\t\tkfree(tun_qp->ring);\n\t\ttun_qp->ring = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tif (is_tun) {\n\t\trx_buf_size = sizeof (struct mlx4_tunnel_mad);\n\t\ttx_buf_size = sizeof (struct mlx4_rcv_tunnel_mad);\n\t} else {\n\t\trx_buf_size = sizeof (struct mlx4_mad_rcv_buf);\n\t\ttx_buf_size = sizeof (struct mlx4_mad_snd_buf);\n\t}\n\n\tfor (i = 0; i < nmbr_bufs; i++) {\n\t\ttun_qp->ring[i].addr = kmalloc(rx_buf_size, GFP_KERNEL);\n\t\tif (!tun_qp->ring[i].addr)\n\t\t\tgoto err;\n\t\ttun_qp->ring[i].map = ib_dma_map_single(ctx->ib_dev,\n\t\t\t\t\t\t\ttun_qp->ring[i].addr,\n\t\t\t\t\t\t\trx_buf_size,\n\t\t\t\t\t\t\tDMA_FROM_DEVICE);\n\t\tif (ib_dma_mapping_error(ctx->ib_dev, tun_qp->ring[i].map)) {\n\t\t\tkfree(tun_qp->ring[i].addr);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (i = 0; i < nmbr_bufs; i++) {\n\t\ttun_qp->tx_ring[i].buf.addr =\n\t\t\tkmalloc(tx_buf_size, GFP_KERNEL);\n\t\tif (!tun_qp->tx_ring[i].buf.addr)\n\t\t\tgoto tx_err;\n\t\ttun_qp->tx_ring[i].buf.map =\n\t\t\tib_dma_map_single(ctx->ib_dev,\n\t\t\t\t\t  tun_qp->tx_ring[i].buf.addr,\n\t\t\t\t\t  tx_buf_size,\n\t\t\t\t\t  DMA_TO_DEVICE);\n\t\tif (ib_dma_mapping_error(ctx->ib_dev,\n\t\t\t\t\t tun_qp->tx_ring[i].buf.map)) {\n\t\t\tkfree(tun_qp->tx_ring[i].buf.addr);\n\t\t\tgoto tx_err;\n\t\t}\n\t\ttun_qp->tx_ring[i].ah = NULL;\n\t}\n\tspin_lock_init(&tun_qp->tx_lock);\n\ttun_qp->tx_ix_head = 0;\n\ttun_qp->tx_ix_tail = 0;\n\ttun_qp->proxy_qpt = qp_type;\n\n\treturn 0;\n\ntx_err:\n\twhile (i > 0) {\n\t\t--i;\n\t\tib_dma_unmap_single(ctx->ib_dev, tun_qp->tx_ring[i].buf.map,\n\t\t\t\t    tx_buf_size, DMA_TO_DEVICE);\n\t\tkfree(tun_qp->tx_ring[i].buf.addr);\n\t}\n\ti = nmbr_bufs;\nerr:\n\twhile (i > 0) {\n\t\t--i;\n\t\tib_dma_unmap_single(ctx->ib_dev, tun_qp->ring[i].map,\n\t\t\t\t    rx_buf_size, DMA_FROM_DEVICE);\n\t\tkfree(tun_qp->ring[i].addr);\n\t}\n\tkfree(tun_qp->tx_ring);\n\ttun_qp->tx_ring = NULL;\n\tkfree(tun_qp->ring);\n\ttun_qp->ring = NULL;\n\treturn -ENOMEM;\n}\n\nstatic void mlx4_ib_free_pv_qp_bufs(struct mlx4_ib_demux_pv_ctx *ctx,\n\t\t\t\t     enum ib_qp_type qp_type, int is_tun)\n{\n\tint i;\n\tstruct mlx4_ib_demux_pv_qp *tun_qp;\n\tint rx_buf_size, tx_buf_size;\n\tconst int nmbr_bufs = is_tun ? MLX4_NUM_TUNNEL_BUFS : MLX4_NUM_WIRE_BUFS;\n\n\tif (qp_type > IB_QPT_GSI)\n\t\treturn;\n\n\ttun_qp = &ctx->qp[qp_type];\n\tif (is_tun) {\n\t\trx_buf_size = sizeof (struct mlx4_tunnel_mad);\n\t\ttx_buf_size = sizeof (struct mlx4_rcv_tunnel_mad);\n\t} else {\n\t\trx_buf_size = sizeof (struct mlx4_mad_rcv_buf);\n\t\ttx_buf_size = sizeof (struct mlx4_mad_snd_buf);\n\t}\n\n\n\tfor (i = 0; i < nmbr_bufs; i++) {\n\t\tib_dma_unmap_single(ctx->ib_dev, tun_qp->ring[i].map,\n\t\t\t\t    rx_buf_size, DMA_FROM_DEVICE);\n\t\tkfree(tun_qp->ring[i].addr);\n\t}\n\n\tfor (i = 0; i < nmbr_bufs; i++) {\n\t\tib_dma_unmap_single(ctx->ib_dev, tun_qp->tx_ring[i].buf.map,\n\t\t\t\t    tx_buf_size, DMA_TO_DEVICE);\n\t\tkfree(tun_qp->tx_ring[i].buf.addr);\n\t\tif (tun_qp->tx_ring[i].ah)\n\t\t\trdma_destroy_ah(tun_qp->tx_ring[i].ah, 0);\n\t}\n\tkfree(tun_qp->tx_ring);\n\tkfree(tun_qp->ring);\n}\n\nstatic void mlx4_ib_tunnel_comp_worker(struct work_struct *work)\n{\n\tstruct mlx4_ib_demux_pv_ctx *ctx;\n\tstruct mlx4_ib_demux_pv_qp *tun_qp;\n\tstruct ib_wc wc;\n\tint ret;\n\tctx = container_of(work, struct mlx4_ib_demux_pv_ctx, work);\n\tib_req_notify_cq(ctx->cq, IB_CQ_NEXT_COMP);\n\n\twhile (ib_poll_cq(ctx->cq, 1, &wc) == 1) {\n\t\ttun_qp = &ctx->qp[MLX4_TUN_WRID_QPN(wc.wr_id)];\n\t\tif (wc.status == IB_WC_SUCCESS) {\n\t\t\tswitch (wc.opcode) {\n\t\t\tcase IB_WC_RECV:\n\t\t\t\tmlx4_ib_multiplex_mad(ctx, &wc);\n\t\t\t\tret = mlx4_ib_post_pv_qp_buf(ctx, tun_qp,\n\t\t\t\t\t\t\t     wc.wr_id &\n\t\t\t\t\t\t\t     (MLX4_NUM_TUNNEL_BUFS - 1));\n\t\t\t\tif (ret)\n\t\t\t\t\tpr_err(\"Failed reposting tunnel \"\n\t\t\t\t\t       \"buf:%lld\\n\", wc.wr_id);\n\t\t\t\tbreak;\n\t\t\tcase IB_WC_SEND:\n\t\t\t\trdma_destroy_ah(tun_qp->tx_ring[wc.wr_id &\n\t\t\t\t\t      (MLX4_NUM_TUNNEL_BUFS - 1)].ah, 0);\n\t\t\t\ttun_qp->tx_ring[wc.wr_id & (MLX4_NUM_TUNNEL_BUFS - 1)].ah\n\t\t\t\t\t= NULL;\n\t\t\t\tspin_lock(&tun_qp->tx_lock);\n\t\t\t\ttun_qp->tx_ix_tail++;\n\t\t\t\tspin_unlock(&tun_qp->tx_lock);\n\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else  {\n\t\t\tpr_debug(\"mlx4_ib: completion error in tunnel: %d.\"\n\t\t\t\t \" status = %d, wrid = 0x%llx\\n\",\n\t\t\t\t ctx->slave, wc.status, wc.wr_id);\n\t\t\tif (!MLX4_TUN_IS_RECV(wc.wr_id)) {\n\t\t\t\trdma_destroy_ah(tun_qp->tx_ring[wc.wr_id &\n\t\t\t\t\t      (MLX4_NUM_TUNNEL_BUFS - 1)].ah, 0);\n\t\t\t\ttun_qp->tx_ring[wc.wr_id & (MLX4_NUM_TUNNEL_BUFS - 1)].ah\n\t\t\t\t\t= NULL;\n\t\t\t\tspin_lock(&tun_qp->tx_lock);\n\t\t\t\ttun_qp->tx_ix_tail++;\n\t\t\t\tspin_unlock(&tun_qp->tx_lock);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void pv_qp_event_handler(struct ib_event *event, void *qp_context)\n{\n\tstruct mlx4_ib_demux_pv_ctx *sqp = qp_context;\n\n\t \n\tpr_err(\"Fatal error (%d) on a MAD QP on port %d\\n\",\n\t       event->event, sqp->port);\n}\n\nstatic int create_pv_sqp(struct mlx4_ib_demux_pv_ctx *ctx,\n\t\t\t    enum ib_qp_type qp_type, int create_tun)\n{\n\tint i, ret;\n\tstruct mlx4_ib_demux_pv_qp *tun_qp;\n\tstruct mlx4_ib_qp_tunnel_init_attr qp_init_attr;\n\tstruct ib_qp_attr attr;\n\tint qp_attr_mask_INIT;\n\tconst int nmbr_bufs = create_tun ? MLX4_NUM_TUNNEL_BUFS : MLX4_NUM_WIRE_BUFS;\n\n\tif (qp_type > IB_QPT_GSI)\n\t\treturn -EINVAL;\n\n\ttun_qp = &ctx->qp[qp_type];\n\n\tmemset(&qp_init_attr, 0, sizeof qp_init_attr);\n\tqp_init_attr.init_attr.send_cq = ctx->cq;\n\tqp_init_attr.init_attr.recv_cq = ctx->cq;\n\tqp_init_attr.init_attr.sq_sig_type = IB_SIGNAL_ALL_WR;\n\tqp_init_attr.init_attr.cap.max_send_wr = nmbr_bufs;\n\tqp_init_attr.init_attr.cap.max_recv_wr = nmbr_bufs;\n\tqp_init_attr.init_attr.cap.max_send_sge = 1;\n\tqp_init_attr.init_attr.cap.max_recv_sge = 1;\n\tif (create_tun) {\n\t\tqp_init_attr.init_attr.qp_type = IB_QPT_UD;\n\t\tqp_init_attr.init_attr.create_flags = MLX4_IB_SRIOV_TUNNEL_QP;\n\t\tqp_init_attr.port = ctx->port;\n\t\tqp_init_attr.slave = ctx->slave;\n\t\tqp_init_attr.proxy_qp_type = qp_type;\n\t\tqp_attr_mask_INIT = IB_QP_STATE | IB_QP_PKEY_INDEX |\n\t\t\t   IB_QP_QKEY | IB_QP_PORT;\n\t} else {\n\t\tqp_init_attr.init_attr.qp_type = qp_type;\n\t\tqp_init_attr.init_attr.create_flags = MLX4_IB_SRIOV_SQP;\n\t\tqp_attr_mask_INIT = IB_QP_STATE | IB_QP_PKEY_INDEX | IB_QP_QKEY;\n\t}\n\tqp_init_attr.init_attr.port_num = ctx->port;\n\tqp_init_attr.init_attr.qp_context = ctx;\n\tqp_init_attr.init_attr.event_handler = pv_qp_event_handler;\n\ttun_qp->qp = ib_create_qp(ctx->pd, &qp_init_attr.init_attr);\n\tif (IS_ERR(tun_qp->qp)) {\n\t\tret = PTR_ERR(tun_qp->qp);\n\t\ttun_qp->qp = NULL;\n\t\tpr_err(\"Couldn't create %s QP (%d)\\n\",\n\t\t       create_tun ? \"tunnel\" : \"special\", ret);\n\t\treturn ret;\n\t}\n\n\tmemset(&attr, 0, sizeof attr);\n\tattr.qp_state = IB_QPS_INIT;\n\tret = 0;\n\tif (create_tun)\n\t\tret = find_slave_port_pkey_ix(to_mdev(ctx->ib_dev), ctx->slave,\n\t\t\t\t\t      ctx->port, IB_DEFAULT_PKEY_FULL,\n\t\t\t\t\t      &attr.pkey_index);\n\tif (ret || !create_tun)\n\t\tattr.pkey_index =\n\t\t\tto_mdev(ctx->ib_dev)->pkeys.virt2phys_pkey[ctx->slave][ctx->port - 1][0];\n\tattr.qkey = IB_QP1_QKEY;\n\tattr.port_num = ctx->port;\n\tret = ib_modify_qp(tun_qp->qp, &attr, qp_attr_mask_INIT);\n\tif (ret) {\n\t\tpr_err(\"Couldn't change %s qp state to INIT (%d)\\n\",\n\t\t       create_tun ? \"tunnel\" : \"special\", ret);\n\t\tgoto err_qp;\n\t}\n\tattr.qp_state = IB_QPS_RTR;\n\tret = ib_modify_qp(tun_qp->qp, &attr, IB_QP_STATE);\n\tif (ret) {\n\t\tpr_err(\"Couldn't change %s qp state to RTR (%d)\\n\",\n\t\t       create_tun ? \"tunnel\" : \"special\", ret);\n\t\tgoto err_qp;\n\t}\n\tattr.qp_state = IB_QPS_RTS;\n\tattr.sq_psn = 0;\n\tret = ib_modify_qp(tun_qp->qp, &attr, IB_QP_STATE | IB_QP_SQ_PSN);\n\tif (ret) {\n\t\tpr_err(\"Couldn't change %s qp state to RTS (%d)\\n\",\n\t\t       create_tun ? \"tunnel\" : \"special\", ret);\n\t\tgoto err_qp;\n\t}\n\n\tfor (i = 0; i < nmbr_bufs; i++) {\n\t\tret = mlx4_ib_post_pv_qp_buf(ctx, tun_qp, i);\n\t\tif (ret) {\n\t\t\tpr_err(\" mlx4_ib_post_pv_buf error\"\n\t\t\t       \" (err = %d, i = %d)\\n\", ret, i);\n\t\t\tgoto err_qp;\n\t\t}\n\t}\n\treturn 0;\n\nerr_qp:\n\tib_destroy_qp(tun_qp->qp);\n\ttun_qp->qp = NULL;\n\treturn ret;\n}\n\n \nstatic void mlx4_ib_sqp_comp_worker(struct work_struct *work)\n{\n\tstruct mlx4_ib_demux_pv_ctx *ctx;\n\tstruct mlx4_ib_demux_pv_qp *sqp;\n\tstruct ib_wc wc;\n\tstruct ib_grh *grh;\n\tstruct ib_mad *mad;\n\n\tctx = container_of(work, struct mlx4_ib_demux_pv_ctx, work);\n\tib_req_notify_cq(ctx->cq, IB_CQ_NEXT_COMP);\n\n\twhile (mlx4_ib_poll_cq(ctx->cq, 1, &wc) == 1) {\n\t\tsqp = &ctx->qp[MLX4_TUN_WRID_QPN(wc.wr_id)];\n\t\tif (wc.status == IB_WC_SUCCESS) {\n\t\t\tswitch (wc.opcode) {\n\t\t\tcase IB_WC_SEND:\n\t\t\t\tkfree(sqp->tx_ring[wc.wr_id &\n\t\t\t\t      (MLX4_NUM_WIRE_BUFS - 1)].ah);\n\t\t\t\tsqp->tx_ring[wc.wr_id & (MLX4_NUM_WIRE_BUFS - 1)].ah\n\t\t\t\t\t= NULL;\n\t\t\t\tspin_lock(&sqp->tx_lock);\n\t\t\t\tsqp->tx_ix_tail++;\n\t\t\t\tspin_unlock(&sqp->tx_lock);\n\t\t\t\tbreak;\n\t\t\tcase IB_WC_RECV:\n\t\t\t\tmad = (struct ib_mad *) &(((struct mlx4_mad_rcv_buf *)\n\t\t\t\t\t\t(sqp->ring[wc.wr_id &\n\t\t\t\t\t\t(MLX4_NUM_WIRE_BUFS - 1)].addr))->payload);\n\t\t\t\tgrh = &(((struct mlx4_mad_rcv_buf *)\n\t\t\t\t\t\t(sqp->ring[wc.wr_id &\n\t\t\t\t\t\t(MLX4_NUM_WIRE_BUFS - 1)].addr))->grh);\n\t\t\t\tmlx4_ib_demux_mad(ctx->ib_dev, ctx->port, &wc, grh, mad);\n\t\t\t\tif (mlx4_ib_post_pv_qp_buf(ctx, sqp, wc.wr_id &\n\t\t\t\t\t\t\t   (MLX4_NUM_WIRE_BUFS - 1)))\n\t\t\t\t\tpr_err(\"Failed reposting SQP \"\n\t\t\t\t\t       \"buf:%lld\\n\", wc.wr_id);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else  {\n\t\t\tpr_debug(\"mlx4_ib: completion error in tunnel: %d.\"\n\t\t\t\t \" status = %d, wrid = 0x%llx\\n\",\n\t\t\t\t ctx->slave, wc.status, wc.wr_id);\n\t\t\tif (!MLX4_TUN_IS_RECV(wc.wr_id)) {\n\t\t\t\tkfree(sqp->tx_ring[wc.wr_id &\n\t\t\t\t      (MLX4_NUM_WIRE_BUFS - 1)].ah);\n\t\t\t\tsqp->tx_ring[wc.wr_id & (MLX4_NUM_WIRE_BUFS - 1)].ah\n\t\t\t\t\t= NULL;\n\t\t\t\tspin_lock(&sqp->tx_lock);\n\t\t\t\tsqp->tx_ix_tail++;\n\t\t\t\tspin_unlock(&sqp->tx_lock);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int alloc_pv_object(struct mlx4_ib_dev *dev, int slave, int port,\n\t\t\t       struct mlx4_ib_demux_pv_ctx **ret_ctx)\n{\n\tstruct mlx4_ib_demux_pv_ctx *ctx;\n\n\t*ret_ctx = NULL;\n\tctx = kzalloc(sizeof (struct mlx4_ib_demux_pv_ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ib_dev = &dev->ib_dev;\n\tctx->port = port;\n\tctx->slave = slave;\n\t*ret_ctx = ctx;\n\treturn 0;\n}\n\nstatic void free_pv_object(struct mlx4_ib_dev *dev, int slave, int port)\n{\n\tif (dev->sriov.demux[port - 1].tun[slave]) {\n\t\tkfree(dev->sriov.demux[port - 1].tun[slave]);\n\t\tdev->sriov.demux[port - 1].tun[slave] = NULL;\n\t}\n}\n\nstatic int create_pv_resources(struct ib_device *ibdev, int slave, int port,\n\t\t\t       int create_tun, struct mlx4_ib_demux_pv_ctx *ctx)\n{\n\tint ret, cq_size;\n\tstruct ib_cq_init_attr cq_attr = {};\n\tconst int nmbr_bufs = create_tun ? MLX4_NUM_TUNNEL_BUFS : MLX4_NUM_WIRE_BUFS;\n\n\tif (ctx->state != DEMUX_PV_STATE_DOWN)\n\t\treturn -EEXIST;\n\n\tctx->state = DEMUX_PV_STATE_STARTING;\n\t \n\tif (rdma_port_get_link_layer(ibdev, ctx->port) ==\n\t    IB_LINK_LAYER_INFINIBAND)\n\t\tctx->has_smi = 1;\n\n\tif (ctx->has_smi) {\n\t\tret = mlx4_ib_alloc_pv_bufs(ctx, IB_QPT_SMI, create_tun);\n\t\tif (ret) {\n\t\t\tpr_err(\"Failed allocating qp0 tunnel bufs (%d)\\n\", ret);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tret = mlx4_ib_alloc_pv_bufs(ctx, IB_QPT_GSI, create_tun);\n\tif (ret) {\n\t\tpr_err(\"Failed allocating qp1 tunnel bufs (%d)\\n\", ret);\n\t\tgoto err_out_qp0;\n\t}\n\n\tcq_size = 2 * nmbr_bufs;\n\tif (ctx->has_smi)\n\t\tcq_size *= 2;\n\n\tcq_attr.cqe = cq_size;\n\tctx->cq = ib_create_cq(ctx->ib_dev,\n\t\t\t       create_tun ? mlx4_ib_tunnel_comp_handler : mlx4_ib_wire_comp_handler,\n\t\t\t       NULL, ctx, &cq_attr);\n\tif (IS_ERR(ctx->cq)) {\n\t\tret = PTR_ERR(ctx->cq);\n\t\tpr_err(\"Couldn't create tunnel CQ (%d)\\n\", ret);\n\t\tgoto err_buf;\n\t}\n\n\tctx->pd = ib_alloc_pd(ctx->ib_dev, 0);\n\tif (IS_ERR(ctx->pd)) {\n\t\tret = PTR_ERR(ctx->pd);\n\t\tpr_err(\"Couldn't create tunnel PD (%d)\\n\", ret);\n\t\tgoto err_cq;\n\t}\n\n\tif (ctx->has_smi) {\n\t\tret = create_pv_sqp(ctx, IB_QPT_SMI, create_tun);\n\t\tif (ret) {\n\t\t\tpr_err(\"Couldn't create %s QP0 (%d)\\n\",\n\t\t\t       create_tun ? \"tunnel for\" : \"\",  ret);\n\t\t\tgoto err_pd;\n\t\t}\n\t}\n\n\tret = create_pv_sqp(ctx, IB_QPT_GSI, create_tun);\n\tif (ret) {\n\t\tpr_err(\"Couldn't create %s QP1 (%d)\\n\",\n\t\t       create_tun ? \"tunnel for\" : \"\",  ret);\n\t\tgoto err_qp0;\n\t}\n\n\tif (create_tun)\n\t\tINIT_WORK(&ctx->work, mlx4_ib_tunnel_comp_worker);\n\telse\n\t\tINIT_WORK(&ctx->work, mlx4_ib_sqp_comp_worker);\n\n\tctx->wq = to_mdev(ibdev)->sriov.demux[port - 1].wq;\n\tctx->wi_wq = to_mdev(ibdev)->sriov.demux[port - 1].wi_wq;\n\n\tret = ib_req_notify_cq(ctx->cq, IB_CQ_NEXT_COMP);\n\tif (ret) {\n\t\tpr_err(\"Couldn't arm tunnel cq (%d)\\n\", ret);\n\t\tgoto err_wq;\n\t}\n\tctx->state = DEMUX_PV_STATE_ACTIVE;\n\treturn 0;\n\nerr_wq:\n\tctx->wq = NULL;\n\tib_destroy_qp(ctx->qp[1].qp);\n\tctx->qp[1].qp = NULL;\n\n\nerr_qp0:\n\tif (ctx->has_smi)\n\t\tib_destroy_qp(ctx->qp[0].qp);\n\tctx->qp[0].qp = NULL;\n\nerr_pd:\n\tib_dealloc_pd(ctx->pd);\n\tctx->pd = NULL;\n\nerr_cq:\n\tib_destroy_cq(ctx->cq);\n\tctx->cq = NULL;\n\nerr_buf:\n\tmlx4_ib_free_pv_qp_bufs(ctx, IB_QPT_GSI, create_tun);\n\nerr_out_qp0:\n\tif (ctx->has_smi)\n\t\tmlx4_ib_free_pv_qp_bufs(ctx, IB_QPT_SMI, create_tun);\nerr_out:\n\tctx->state = DEMUX_PV_STATE_DOWN;\n\treturn ret;\n}\n\nstatic void destroy_pv_resources(struct mlx4_ib_dev *dev, int slave, int port,\n\t\t\t\t struct mlx4_ib_demux_pv_ctx *ctx, int flush)\n{\n\tif (!ctx)\n\t\treturn;\n\tif (ctx->state > DEMUX_PV_STATE_DOWN) {\n\t\tctx->state = DEMUX_PV_STATE_DOWNING;\n\t\tif (flush)\n\t\t\tflush_workqueue(ctx->wq);\n\t\tif (ctx->has_smi) {\n\t\t\tib_destroy_qp(ctx->qp[0].qp);\n\t\t\tctx->qp[0].qp = NULL;\n\t\t\tmlx4_ib_free_pv_qp_bufs(ctx, IB_QPT_SMI, 1);\n\t\t}\n\t\tib_destroy_qp(ctx->qp[1].qp);\n\t\tctx->qp[1].qp = NULL;\n\t\tmlx4_ib_free_pv_qp_bufs(ctx, IB_QPT_GSI, 1);\n\t\tib_dealloc_pd(ctx->pd);\n\t\tctx->pd = NULL;\n\t\tib_destroy_cq(ctx->cq);\n\t\tctx->cq = NULL;\n\t\tctx->state = DEMUX_PV_STATE_DOWN;\n\t}\n}\n\nstatic int mlx4_ib_tunnels_update(struct mlx4_ib_dev *dev, int slave,\n\t\t\t\t  int port, int do_init)\n{\n\tint ret = 0;\n\n\tif (!do_init) {\n\t\tclean_vf_mcast(&dev->sriov.demux[port - 1], slave);\n\t\t \n\t\tif (slave == mlx4_master_func_num(dev->dev))\n\t\t\tdestroy_pv_resources(dev, slave, port,\n\t\t\t\t\t     dev->sriov.sqps[port - 1], 1);\n\t\t \n\t\tdestroy_pv_resources(dev, slave, port,\n\t\t\t\t     dev->sriov.demux[port - 1].tun[slave], 1);\n\t\treturn 0;\n\t}\n\n\t \n\tret = create_pv_resources(&dev->ib_dev, slave, port, 1,\n\t\t\t\t  dev->sriov.demux[port - 1].tun[slave]);\n\n\t \n\tif (!ret && slave == mlx4_master_func_num(dev->dev))\n\t\tret = create_pv_resources(&dev->ib_dev, slave, port, 0,\n\t\t\t\t\t  dev->sriov.sqps[port - 1]);\n\treturn ret;\n}\n\nvoid mlx4_ib_tunnels_update_work(struct work_struct *work)\n{\n\tstruct mlx4_ib_demux_work *dmxw;\n\n\tdmxw = container_of(work, struct mlx4_ib_demux_work, work);\n\tmlx4_ib_tunnels_update(dmxw->dev, dmxw->slave, (int) dmxw->port,\n\t\t\t       dmxw->do_init);\n\tkfree(dmxw);\n\treturn;\n}\n\nstatic int mlx4_ib_alloc_demux_ctx(struct mlx4_ib_dev *dev,\n\t\t\t\t       struct mlx4_ib_demux_ctx *ctx,\n\t\t\t\t       int port)\n{\n\tchar name[12];\n\tint ret = 0;\n\tint i;\n\n\tctx->tun = kcalloc(dev->dev->caps.sqp_demux,\n\t\t\t   sizeof (struct mlx4_ib_demux_pv_ctx *), GFP_KERNEL);\n\tif (!ctx->tun)\n\t\treturn -ENOMEM;\n\n\tctx->dev = dev;\n\tctx->port = port;\n\tctx->ib_dev = &dev->ib_dev;\n\n\tfor (i = 0;\n\t     i < min(dev->dev->caps.sqp_demux,\n\t     (u16)(dev->dev->persist->num_vfs + 1));\n\t     i++) {\n\t\tstruct mlx4_active_ports actv_ports =\n\t\t\tmlx4_get_active_ports(dev->dev, i);\n\n\t\tif (!test_bit(port - 1, actv_ports.ports))\n\t\t\tcontinue;\n\n\t\tret = alloc_pv_object(dev, i, port, &ctx->tun[i]);\n\t\tif (ret) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_mcg;\n\t\t}\n\t}\n\n\tret = mlx4_ib_mcg_port_init(ctx);\n\tif (ret) {\n\t\tpr_err(\"Failed initializing mcg para-virt (%d)\\n\", ret);\n\t\tgoto err_mcg;\n\t}\n\n\tsnprintf(name, sizeof(name), \"mlx4_ibt%d\", port);\n\tctx->wq = alloc_ordered_workqueue(name, WQ_MEM_RECLAIM);\n\tif (!ctx->wq) {\n\t\tpr_err(\"Failed to create tunnelling WQ for port %d\\n\", port);\n\t\tret = -ENOMEM;\n\t\tgoto err_wq;\n\t}\n\n\tsnprintf(name, sizeof(name), \"mlx4_ibwi%d\", port);\n\tctx->wi_wq = alloc_ordered_workqueue(name, WQ_MEM_RECLAIM);\n\tif (!ctx->wi_wq) {\n\t\tpr_err(\"Failed to create wire WQ for port %d\\n\", port);\n\t\tret = -ENOMEM;\n\t\tgoto err_wiwq;\n\t}\n\n\tsnprintf(name, sizeof(name), \"mlx4_ibud%d\", port);\n\tctx->ud_wq = alloc_ordered_workqueue(name, WQ_MEM_RECLAIM);\n\tif (!ctx->ud_wq) {\n\t\tpr_err(\"Failed to create up/down WQ for port %d\\n\", port);\n\t\tret = -ENOMEM;\n\t\tgoto err_udwq;\n\t}\n\n\treturn 0;\n\nerr_udwq:\n\tdestroy_workqueue(ctx->wi_wq);\n\tctx->wi_wq = NULL;\n\nerr_wiwq:\n\tdestroy_workqueue(ctx->wq);\n\tctx->wq = NULL;\n\nerr_wq:\n\tmlx4_ib_mcg_port_cleanup(ctx, 1);\nerr_mcg:\n\tfor (i = 0; i < dev->dev->caps.sqp_demux; i++)\n\t\tfree_pv_object(dev, i, port);\n\tkfree(ctx->tun);\n\tctx->tun = NULL;\n\treturn ret;\n}\n\nstatic void mlx4_ib_free_sqp_ctx(struct mlx4_ib_demux_pv_ctx *sqp_ctx)\n{\n\tif (sqp_ctx->state > DEMUX_PV_STATE_DOWN) {\n\t\tsqp_ctx->state = DEMUX_PV_STATE_DOWNING;\n\t\tflush_workqueue(sqp_ctx->wq);\n\t\tif (sqp_ctx->has_smi) {\n\t\t\tib_destroy_qp(sqp_ctx->qp[0].qp);\n\t\t\tsqp_ctx->qp[0].qp = NULL;\n\t\t\tmlx4_ib_free_pv_qp_bufs(sqp_ctx, IB_QPT_SMI, 0);\n\t\t}\n\t\tib_destroy_qp(sqp_ctx->qp[1].qp);\n\t\tsqp_ctx->qp[1].qp = NULL;\n\t\tmlx4_ib_free_pv_qp_bufs(sqp_ctx, IB_QPT_GSI, 0);\n\t\tib_dealloc_pd(sqp_ctx->pd);\n\t\tsqp_ctx->pd = NULL;\n\t\tib_destroy_cq(sqp_ctx->cq);\n\t\tsqp_ctx->cq = NULL;\n\t\tsqp_ctx->state = DEMUX_PV_STATE_DOWN;\n\t}\n}\n\nstatic void mlx4_ib_free_demux_ctx(struct mlx4_ib_demux_ctx *ctx)\n{\n\tint i;\n\tif (ctx) {\n\t\tstruct mlx4_ib_dev *dev = to_mdev(ctx->ib_dev);\n\t\tmlx4_ib_mcg_port_cleanup(ctx, 1);\n\t\tfor (i = 0; i < dev->dev->caps.sqp_demux; i++) {\n\t\t\tif (!ctx->tun[i])\n\t\t\t\tcontinue;\n\t\t\tif (ctx->tun[i]->state > DEMUX_PV_STATE_DOWN)\n\t\t\t\tctx->tun[i]->state = DEMUX_PV_STATE_DOWNING;\n\t\t}\n\t\tflush_workqueue(ctx->wq);\n\t\tflush_workqueue(ctx->wi_wq);\n\t\tfor (i = 0; i < dev->dev->caps.sqp_demux; i++) {\n\t\t\tdestroy_pv_resources(dev, i, ctx->port, ctx->tun[i], 0);\n\t\t\tfree_pv_object(dev, i, ctx->port);\n\t\t}\n\t\tkfree(ctx->tun);\n\t\tdestroy_workqueue(ctx->ud_wq);\n\t\tdestroy_workqueue(ctx->wi_wq);\n\t\tdestroy_workqueue(ctx->wq);\n\t}\n}\n\nstatic void mlx4_ib_master_tunnels(struct mlx4_ib_dev *dev, int do_init)\n{\n\tint i;\n\n\tif (!mlx4_is_master(dev->dev))\n\t\treturn;\n\t \n\tfor (i = 0; i < dev->dev->caps.num_ports; i++)\n\t\tmlx4_ib_tunnels_update(dev, mlx4_master_func_num(dev->dev), i + 1, do_init);\n\treturn;\n}\n\nint mlx4_ib_init_sriov(struct mlx4_ib_dev *dev)\n{\n\tint i = 0;\n\tint err;\n\n\tif (!mlx4_is_mfunc(dev->dev))\n\t\treturn 0;\n\n\tdev->sriov.is_going_down = 0;\n\tspin_lock_init(&dev->sriov.going_down_lock);\n\tmlx4_ib_cm_paravirt_init(dev);\n\n\tmlx4_ib_warn(&dev->ib_dev, \"multi-function enabled\\n\");\n\n\tif (mlx4_is_slave(dev->dev)) {\n\t\tmlx4_ib_warn(&dev->ib_dev, \"operating in qp1 tunnel mode\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < dev->dev->caps.sqp_demux; i++) {\n\t\tif (i == mlx4_master_func_num(dev->dev))\n\t\t\tmlx4_put_slave_node_guid(dev->dev, i, dev->ib_dev.node_guid);\n\t\telse\n\t\t\tmlx4_put_slave_node_guid(dev->dev, i, mlx4_ib_gen_node_guid());\n\t}\n\n\terr = mlx4_ib_init_alias_guid_service(dev);\n\tif (err) {\n\t\tmlx4_ib_warn(&dev->ib_dev, \"Failed init alias guid process.\\n\");\n\t\tgoto paravirt_err;\n\t}\n\terr = mlx4_ib_device_register_sysfs(dev);\n\tif (err) {\n\t\tmlx4_ib_warn(&dev->ib_dev, \"Failed to register sysfs\\n\");\n\t\tgoto sysfs_err;\n\t}\n\n\tmlx4_ib_warn(&dev->ib_dev, \"initializing demux service for %d qp1 clients\\n\",\n\t\t     dev->dev->caps.sqp_demux);\n\tfor (i = 0; i < dev->num_ports; i++) {\n\t\tunion ib_gid gid;\n\t\terr = __mlx4_ib_query_gid(&dev->ib_dev, i + 1, 0, &gid, 1);\n\t\tif (err)\n\t\t\tgoto demux_err;\n\t\tdev->sriov.demux[i].guid_cache[0] = gid.global.interface_id;\n\t\tatomic64_set(&dev->sriov.demux[i].subnet_prefix,\n\t\t\t     be64_to_cpu(gid.global.subnet_prefix));\n\t\terr = alloc_pv_object(dev, mlx4_master_func_num(dev->dev), i + 1,\n\t\t\t\t      &dev->sriov.sqps[i]);\n\t\tif (err)\n\t\t\tgoto demux_err;\n\t\terr = mlx4_ib_alloc_demux_ctx(dev, &dev->sriov.demux[i], i + 1);\n\t\tif (err)\n\t\t\tgoto free_pv;\n\t}\n\tmlx4_ib_master_tunnels(dev, 1);\n\treturn 0;\n\nfree_pv:\n\tfree_pv_object(dev, mlx4_master_func_num(dev->dev), i + 1);\ndemux_err:\n\twhile (--i >= 0) {\n\t\tfree_pv_object(dev, mlx4_master_func_num(dev->dev), i + 1);\n\t\tmlx4_ib_free_demux_ctx(&dev->sriov.demux[i]);\n\t}\n\tmlx4_ib_device_unregister_sysfs(dev);\n\nsysfs_err:\n\tmlx4_ib_destroy_alias_guid_service(dev);\n\nparavirt_err:\n\tmlx4_ib_cm_paravirt_clean(dev, -1);\n\n\treturn err;\n}\n\nvoid mlx4_ib_close_sriov(struct mlx4_ib_dev *dev)\n{\n\tint i;\n\tunsigned long flags;\n\n\tif (!mlx4_is_mfunc(dev->dev))\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->sriov.going_down_lock, flags);\n\tdev->sriov.is_going_down = 1;\n\tspin_unlock_irqrestore(&dev->sriov.going_down_lock, flags);\n\tif (mlx4_is_master(dev->dev)) {\n\t\tfor (i = 0; i < dev->num_ports; i++) {\n\t\t\tflush_workqueue(dev->sriov.demux[i].ud_wq);\n\t\t\tmlx4_ib_free_sqp_ctx(dev->sriov.sqps[i]);\n\t\t\tkfree(dev->sriov.sqps[i]);\n\t\t\tdev->sriov.sqps[i] = NULL;\n\t\t\tmlx4_ib_free_demux_ctx(&dev->sriov.demux[i]);\n\t\t}\n\n\t\tmlx4_ib_cm_paravirt_clean(dev, -1);\n\t\tmlx4_ib_destroy_alias_guid_service(dev);\n\t\tmlx4_ib_device_unregister_sysfs(dev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}