{
  "module_name": "ah.c",
  "hash_id": "ece55ce7705ad88db1a92085dd81b6ec89c9b7c3ec9c71ac93f1157cab975004",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx4/ah.c",
  "human_readable_source": " \n\n#include <rdma/ib_addr.h>\n#include <rdma/ib_cache.h>\n\n#include <linux/slab.h>\n#include <linux/inet.h>\n#include <linux/string.h>\n#include <linux/mlx4/driver.h>\n\n#include \"mlx4_ib.h\"\n\nstatic void create_ib_ah(struct ib_ah *ib_ah, struct rdma_ah_attr *ah_attr)\n{\n\tstruct mlx4_ib_ah *ah = to_mah(ib_ah);\n\tstruct mlx4_dev *dev = to_mdev(ib_ah->device)->dev;\n\n\tah->av.ib.port_pd = cpu_to_be32(to_mpd(ib_ah->pd)->pdn |\n\t\t\t    (rdma_ah_get_port_num(ah_attr) << 24));\n\tah->av.ib.g_slid  = rdma_ah_get_path_bits(ah_attr);\n\tah->av.ib.sl_tclass_flowlabel =\n\t\t\tcpu_to_be32(rdma_ah_get_sl(ah_attr) << 28);\n\tif (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) {\n\t\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\n\t\tah->av.ib.g_slid   |= 0x80;\n\t\tah->av.ib.gid_index = grh->sgid_index;\n\t\tah->av.ib.hop_limit = grh->hop_limit;\n\t\tah->av.ib.sl_tclass_flowlabel |=\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    grh->flow_label);\n\t\tmemcpy(ah->av.ib.dgid, grh->dgid.raw, 16);\n\t}\n\n\tah->av.ib.dlid = cpu_to_be16(rdma_ah_get_dlid(ah_attr));\n\tif (rdma_ah_get_static_rate(ah_attr)) {\n\t\tu8 static_rate = rdma_ah_get_static_rate(ah_attr) +\n\t\t\t\t\tMLX4_STAT_RATE_OFFSET;\n\n\t\twhile (static_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\n\t\t       !(1 << static_rate & dev->caps.stat_rate_support))\n\t\t\t--static_rate;\n\t\tah->av.ib.stat_rate = static_rate;\n\t}\n}\n\nstatic int create_iboe_ah(struct ib_ah *ib_ah, struct rdma_ah_attr *ah_attr)\n{\n\tstruct mlx4_ib_dev *ibdev = to_mdev(ib_ah->device);\n\tstruct mlx4_ib_ah *ah = to_mah(ib_ah);\n\tconst struct ib_gid_attr *gid_attr;\n\tstruct mlx4_dev *dev = ibdev->dev;\n\tint is_mcast = 0;\n\tstruct in6_addr in6;\n\tu16 vlan_tag = 0xffff;\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\tint ret;\n\n\tmemcpy(&in6, grh->dgid.raw, sizeof(in6));\n\tif (rdma_is_multicast_addr(&in6))\n\t\tis_mcast = 1;\n\n\tmemcpy(ah->av.eth.mac, ah_attr->roce.dmac, ETH_ALEN);\n\teth_zero_addr(ah->av.eth.s_mac);\n\n\t \n\tgid_attr = ah_attr->grh.sgid_attr;\n\tif (gid_attr) {\n\t\tret = rdma_read_gid_l2_fields(gid_attr, &vlan_tag,\n\t\t\t\t\t      &ah->av.eth.s_mac[0]);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mlx4_ib_gid_index_to_real_index(ibdev, gid_attr);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tah->av.eth.gid_index = ret;\n\t} else {\n\t\t \n\t\tah->av.eth.gid_index = ah_attr->grh.sgid_index;\n\t}\n\n\tif (vlan_tag < 0x1000)\n\t\tvlan_tag |= (rdma_ah_get_sl(ah_attr) & 7) << 13;\n\tah->av.eth.port_pd = cpu_to_be32(to_mpd(ib_ah->pd)->pdn |\n\t\t\t\t\t (rdma_ah_get_port_num(ah_attr) << 24));\n\tah->av.eth.vlan = cpu_to_be16(vlan_tag);\n\tah->av.eth.hop_limit = grh->hop_limit;\n\tif (rdma_ah_get_static_rate(ah_attr)) {\n\t\tah->av.eth.stat_rate = rdma_ah_get_static_rate(ah_attr) +\n\t\t\t\t\tMLX4_STAT_RATE_OFFSET;\n\t\twhile (ah->av.eth.stat_rate > IB_RATE_2_5_GBPS + MLX4_STAT_RATE_OFFSET &&\n\t\t       !(1 << ah->av.eth.stat_rate & dev->caps.stat_rate_support))\n\t\t\t--ah->av.eth.stat_rate;\n\t}\n\tah->av.eth.sl_tclass_flowlabel |=\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    grh->flow_label);\n\t \n\tif (is_mcast)\n\t\tah->av.ib.dlid = cpu_to_be16(0xc000);\n\n\tmemcpy(ah->av.eth.dgid, grh->dgid.raw, 16);\n\tah->av.eth.sl_tclass_flowlabel |= cpu_to_be32(rdma_ah_get_sl(ah_attr)\n\t\t\t\t\t\t      << 29);\n\treturn 0;\n}\n\nint mlx4_ib_create_ah(struct ib_ah *ib_ah, struct rdma_ah_init_attr *init_attr,\n\t\t      struct ib_udata *udata)\n{\n\tstruct rdma_ah_attr *ah_attr = init_attr->ah_attr;\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (!(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))\n\t\t\treturn -EINVAL;\n\t\t \n\t\treturn create_iboe_ah(ib_ah, ah_attr);\n\t}\n\n\tcreate_ib_ah(ib_ah, ah_attr);\n\treturn 0;\n}\n\nint mlx4_ib_create_ah_slave(struct ib_ah *ah, struct rdma_ah_attr *ah_attr,\n\t\t\t    int slave_sgid_index, u8 *s_mac, u16 vlan_tag)\n{\n\tstruct rdma_ah_attr slave_attr = *ah_attr;\n\tstruct rdma_ah_init_attr init_attr = {};\n\tstruct mlx4_ib_ah *mah = to_mah(ah);\n\tint ret;\n\n\tslave_attr.grh.sgid_attr = NULL;\n\tslave_attr.grh.sgid_index = slave_sgid_index;\n\tinit_attr.ah_attr = &slave_attr;\n\tret = mlx4_ib_create_ah(ah, &init_attr, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tah->type = ah_attr->type;\n\n\t \n\tmah->av.ib.port_pd &= cpu_to_be32(0x7FFFFFFF);\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE)\n\t\tmemcpy(mah->av.eth.s_mac, s_mac, 6);\n\n\tif (vlan_tag < 0x1000)\n\t\tvlan_tag |= (rdma_ah_get_sl(ah_attr) & 7) << 13;\n\tmah->av.eth.vlan = cpu_to_be16(vlan_tag);\n\n\treturn 0;\n}\n\nint mlx4_ib_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr)\n{\n\tstruct mlx4_ib_ah *ah = to_mah(ibah);\n\tint port_num = be32_to_cpu(ah->av.ib.port_pd) >> 24;\n\n\tmemset(ah_attr, 0, sizeof *ah_attr);\n\tah_attr->type = ibah->type;\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\trdma_ah_set_dlid(ah_attr, 0);\n\t\trdma_ah_set_sl(ah_attr,\n\t\t\t       be32_to_cpu(ah->av.eth.sl_tclass_flowlabel)\n\t\t\t       >> 29);\n\t} else {\n\t\trdma_ah_set_dlid(ah_attr, be16_to_cpu(ah->av.ib.dlid));\n\t\trdma_ah_set_sl(ah_attr,\n\t\t\t       be32_to_cpu(ah->av.ib.sl_tclass_flowlabel)\n\t\t\t       >> 28);\n\t}\n\n\trdma_ah_set_port_num(ah_attr, port_num);\n\tif (ah->av.ib.stat_rate)\n\t\trdma_ah_set_static_rate(ah_attr,\n\t\t\t\t\tah->av.ib.stat_rate -\n\t\t\t\t\tMLX4_STAT_RATE_OFFSET);\n\trdma_ah_set_path_bits(ah_attr, ah->av.ib.g_slid & 0x7F);\n\tif (mlx4_ib_ah_grh_present(ah)) {\n\t\tu32 tc_fl = be32_to_cpu(ah->av.ib.sl_tclass_flowlabel);\n\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\ttc_fl & 0xfffff, ah->av.ib.gid_index,\n\t\t\t\tah->av.ib.hop_limit,\n\t\t\t\ttc_fl >> 20);\n\t\trdma_ah_set_dgid_raw(ah_attr, ah->av.ib.dgid);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}