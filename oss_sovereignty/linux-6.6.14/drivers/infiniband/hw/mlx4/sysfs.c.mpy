{
  "module_name": "sysfs.c",
  "hash_id": "213bb331ed6fe5fabdc40f1fb79b510a613ae3c30c8d839ac47fc990dab74261",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx4/sysfs.c",
  "human_readable_source": " \n\n \n#include \"mlx4_ib.h\"\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n\n#include <rdma/ib_mad.h>\n \nstatic ssize_t show_admin_alias_guid(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct mlx4_ib_iov_sysfs_attr *mlx4_ib_iov_dentry =\n\t\tcontainer_of(attr, struct mlx4_ib_iov_sysfs_attr, dentry);\n\tstruct mlx4_ib_iov_port *port = mlx4_ib_iov_dentry->ctx;\n\tstruct mlx4_ib_dev *mdev = port->dev;\n\t__be64 sysadmin_ag_val;\n\n\tsysadmin_ag_val = mlx4_get_admin_guid(mdev->dev,\n\t\t\t\t\t      mlx4_ib_iov_dentry->entry_num,\n\t\t\t\t\t      port->num);\n\n\treturn sysfs_emit(buf, \"%llx\\n\", be64_to_cpu(sysadmin_ag_val));\n}\n\n \nstatic ssize_t store_admin_alias_guid(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tint record_num; \n\tint guid_index_in_rec;  \n\tstruct mlx4_ib_iov_sysfs_attr *mlx4_ib_iov_dentry =\n\t\tcontainer_of(attr, struct mlx4_ib_iov_sysfs_attr, dentry);\n\tstruct mlx4_ib_iov_port *port = mlx4_ib_iov_dentry->ctx;\n\tstruct mlx4_ib_dev *mdev = port->dev;\n\tu64 sysadmin_ag_val;\n\tunsigned long flags;\n\n\trecord_num = mlx4_ib_iov_dentry->entry_num / 8;\n\tguid_index_in_rec = mlx4_ib_iov_dentry->entry_num % 8;\n\tif (0 == record_num && 0 == guid_index_in_rec) {\n\t\tpr_err(\"GUID 0 block 0 is RO\\n\");\n\t\treturn count;\n\t}\n\tspin_lock_irqsave(&mdev->sriov.alias_guid.ag_work_lock, flags);\n\tsscanf(buf, \"%llx\", &sysadmin_ag_val);\n\t*(__be64 *)&mdev->sriov.alias_guid.ports_guid[port->num - 1].\n\t\tall_rec_per_port[record_num].\n\t\tall_recs[GUID_REC_SIZE * guid_index_in_rec] =\n\t\t\tcpu_to_be64(sysadmin_ag_val);\n\n\t \n\tmdev->sriov.alias_guid.ports_guid[port->num - 1].all_rec_per_port[record_num].status\n\t\t= MLX4_GUID_INFO_STATUS_IDLE ;\n\tmlx4_set_admin_guid(mdev->dev, cpu_to_be64(sysadmin_ag_val),\n\t\t\t    mlx4_ib_iov_dentry->entry_num,\n\t\t\t    port->num);\n\n\t \n\tmdev->sriov.alias_guid.ports_guid[port->num - 1].all_rec_per_port[record_num].guid_indexes\n\t\t|= mlx4_ib_get_aguid_comp_mask_from_ix(guid_index_in_rec);\n\n\tspin_unlock_irqrestore(&mdev->sriov.alias_guid.ag_work_lock, flags);\n\tmlx4_ib_init_alias_guid_work(mdev, port->num - 1);\n\n\treturn count;\n}\n\nstatic ssize_t show_port_gid(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct mlx4_ib_iov_sysfs_attr *mlx4_ib_iov_dentry =\n\t\tcontainer_of(attr, struct mlx4_ib_iov_sysfs_attr, dentry);\n\tstruct mlx4_ib_iov_port *port = mlx4_ib_iov_dentry->ctx;\n\tstruct mlx4_ib_dev *mdev = port->dev;\n\tunion ib_gid gid;\n\tint ret;\n\t__be16 *raw;\n\n\tret = __mlx4_ib_query_gid(&mdev->ib_dev, port->num,\n\t\t\t\t  mlx4_ib_iov_dentry->entry_num, &gid, 1);\n\tif (ret)\n\t\treturn ret;\n\n\traw = (__be16 *)gid.raw;\n\treturn sysfs_emit(buf, \"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\\n\",\n\t\t\t  be16_to_cpu(raw[0]),\n\t\t\t  be16_to_cpu(raw[1]),\n\t\t\t  be16_to_cpu(raw[2]),\n\t\t\t  be16_to_cpu(raw[3]),\n\t\t\t  be16_to_cpu(raw[4]),\n\t\t\t  be16_to_cpu(raw[5]),\n\t\t\t  be16_to_cpu(raw[6]),\n\t\t\t  be16_to_cpu(raw[7]));\n}\n\nstatic ssize_t show_phys_port_pkey(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct mlx4_ib_iov_sysfs_attr *mlx4_ib_iov_dentry =\n\t\tcontainer_of(attr, struct mlx4_ib_iov_sysfs_attr, dentry);\n\tstruct mlx4_ib_iov_port *port = mlx4_ib_iov_dentry->ctx;\n\tstruct mlx4_ib_dev *mdev = port->dev;\n\tu16 pkey;\n\tssize_t ret;\n\n\tret = __mlx4_ib_query_pkey(&mdev->ib_dev, port->num,\n\t\t\t\t   mlx4_ib_iov_dentry->entry_num, &pkey, 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%04x\\n\", pkey);\n}\n\n#define DENTRY_REMOVE(_dentry)\t\t\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tsysfs_remove_file((_dentry)->kobj, &(_dentry)->dentry.attr);\t\\\n} while (0);\n\nstatic int create_sysfs_entry(void *_ctx, struct mlx4_ib_iov_sysfs_attr *_dentry,\n\t\t\t      char *_name, struct kobject *_kobj,\n\t\t\t      ssize_t (*show)(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf),\n\t\t\t      ssize_t (*store)(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t count)\n\t\t\t      )\n{\n\tint ret = 0;\n\tstruct mlx4_ib_iov_sysfs_attr *vdentry = _dentry;\n\n\tvdentry->ctx = _ctx;\n\tvdentry->dentry.show = show;\n\tvdentry->dentry.store = store;\n\tsysfs_attr_init(&vdentry->dentry.attr);\n\tvdentry->dentry.attr.name = vdentry->name;\n\tvdentry->dentry.attr.mode = 0;\n\tvdentry->kobj = _kobj;\n\tsnprintf(vdentry->name, 15, \"%s\", _name);\n\n\tif (vdentry->dentry.store)\n\t\tvdentry->dentry.attr.mode |= S_IWUSR;\n\n\tif (vdentry->dentry.show)\n\t\tvdentry->dentry.attr.mode |= S_IRUGO;\n\n\tret = sysfs_create_file(vdentry->kobj, &vdentry->dentry.attr);\n\tif (ret) {\n\t\tpr_err(\"failed to create %s\\n\", vdentry->dentry.attr.name);\n\t\tvdentry->ctx = NULL;\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint add_sysfs_port_mcg_attr(struct mlx4_ib_dev *device, int port_num,\n\t\tstruct attribute *attr)\n{\n\tstruct mlx4_ib_iov_port *port = &device->iov_ports[port_num - 1];\n\tint ret;\n\n\tret = sysfs_create_file(port->mcgs_parent, attr);\n\tif (ret)\n\t\tpr_err(\"failed to create %s\\n\", attr->name);\n\n\treturn ret;\n}\n\nvoid del_sysfs_port_mcg_attr(struct mlx4_ib_dev *device, int port_num,\n\t\tstruct attribute *attr)\n{\n\tstruct mlx4_ib_iov_port *port = &device->iov_ports[port_num - 1];\n\n\tsysfs_remove_file(port->mcgs_parent, attr);\n}\n\nstatic int add_port_entries(struct mlx4_ib_dev *device, int port_num)\n{\n\tint i;\n\tchar buff[12];\n\tstruct mlx4_ib_iov_port *port = NULL;\n\tint ret = 0 ;\n\tstruct ib_port_attr attr;\n\n\tmemset(&attr, 0, sizeof(attr));\n\t \n\tret = __mlx4_ib_query_port(&device->ib_dev, port_num, &attr, 1);\n\tif (ret)\n\t\tgoto err;\n\n\tport = &device->iov_ports[port_num - 1];\n\tport->dev = device;\n\tport->num = port_num;\n\t \n\tport->dentr_ar = kzalloc(sizeof (struct mlx4_ib_iov_sysfs_attr_ar),\n\t\t\t\t GFP_KERNEL);\n\tif (!port->dentr_ar) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tsprintf(buff, \"%d\", port_num);\n\tport->cur_port = kobject_create_and_add(buff,\n\t\t\t\t kobject_get(device->ports_parent));\n\tif (!port->cur_port) {\n\t\tret = -ENOMEM;\n\t\tgoto kobj_create_err;\n\t}\n\t \n\tport->admin_alias_parent = kobject_create_and_add(\"admin_guids\",\n\t\t\t\t\t\t  kobject_get(port->cur_port));\n\tif (!port->admin_alias_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err_admin_guids;\n\t}\n\tfor (i = 0 ; i < attr.gid_tbl_len; i++) {\n\t\tsprintf(buff, \"%d\", i);\n\t\tport->dentr_ar->dentries[i].entry_num = i;\n\t\tret = create_sysfs_entry(port, &port->dentr_ar->dentries[i],\n\t\t\t\t\t  buff, port->admin_alias_parent,\n\t\t\t\t\t  show_admin_alias_guid, store_admin_alias_guid);\n\t\tif (ret)\n\t\t\tgoto err_admin_alias_parent;\n\t}\n\n\t \n\tport->gids_parent = kobject_create_and_add(\"gids\",\n\t\t\t\t\t\t  kobject_get(port->cur_port));\n\tif (!port->gids_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err_gids;\n\t}\n\n\tfor (i = 0 ; i < attr.gid_tbl_len; i++) {\n\t\tsprintf(buff, \"%d\", i);\n\t\tport->dentr_ar->dentries[attr.gid_tbl_len + i].entry_num = i;\n\t\tret = create_sysfs_entry(port,\n\t\t\t\t\t &port->dentr_ar->dentries[attr.gid_tbl_len + i],\n\t\t\t\t\t buff,\n\t\t\t\t\t port->gids_parent, show_port_gid, NULL);\n\t\tif (ret)\n\t\t\tgoto err_gids_parent;\n\t}\n\n\t \n\tport->pkeys_parent =\n\t\tkobject_create_and_add(\"pkeys\", kobject_get(port->cur_port));\n\tif (!port->pkeys_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pkeys;\n\t}\n\n\tfor (i = 0 ; i < attr.pkey_tbl_len; i++) {\n\t\tsprintf(buff, \"%d\", i);\n\t\tport->dentr_ar->dentries[2 * attr.gid_tbl_len + i].entry_num = i;\n\t\tret = create_sysfs_entry(port,\n\t\t\t\t\t &port->dentr_ar->dentries[2 * attr.gid_tbl_len + i],\n\t\t\t\t\t buff, port->pkeys_parent,\n\t\t\t\t\t show_phys_port_pkey, NULL);\n\t\tif (ret)\n\t\t\tgoto err_pkeys_parent;\n\t}\n\n\t \n\tport->mcgs_parent =\n\t\tkobject_create_and_add(\"mcgs\", kobject_get(port->cur_port));\n\tif (!port->mcgs_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err_mcgs;\n\t}\n\treturn 0;\n\nerr_mcgs:\n\tkobject_put(port->cur_port);\n\nerr_pkeys_parent:\n\tkobject_put(port->pkeys_parent);\n\nerr_pkeys:\n\tkobject_put(port->cur_port);\n\nerr_gids_parent:\n\tkobject_put(port->gids_parent);\n\nerr_gids:\n\tkobject_put(port->cur_port);\n\nerr_admin_alias_parent:\n\tkobject_put(port->admin_alias_parent);\n\nerr_admin_guids:\n\tkobject_put(port->cur_port);\n\tkobject_put(port->cur_port);  \n\nkobj_create_err:\n\tkobject_put(device->ports_parent);\n\tkfree(port->dentr_ar);\n\nerr:\n\tpr_err(\"add_port_entries FAILED: for port:%d, error: %d\\n\",\n\t       port_num, ret);\n\treturn ret;\n}\n\nstatic void get_name(struct mlx4_ib_dev *dev, char *name, int i, int max)\n{\n\t \n\tsnprintf(name, max, \"%.8s%.2d.%d\", pci_name(dev->dev->persist->pdev),\n\t\t i / 8, i % 8);\n}\n\nstruct mlx4_port {\n\tstruct kobject         kobj;\n\tstruct mlx4_ib_dev    *dev;\n\tstruct attribute_group pkey_group;\n\tstruct attribute_group gid_group;\n\tstruct device_attribute\tenable_smi_admin;\n\tstruct device_attribute\tsmi_enabled;\n\tint\t\t       slave;\n\tu8                     port_num;\n};\n\n\nstatic void mlx4_port_release(struct kobject *kobj)\n{\n\tstruct mlx4_port *p = container_of(kobj, struct mlx4_port, kobj);\n\tstruct attribute *a;\n\tint i;\n\n\tfor (i = 0; (a = p->pkey_group.attrs[i]); ++i)\n\t\tkfree(a);\n\tkfree(p->pkey_group.attrs);\n\tfor (i = 0; (a = p->gid_group.attrs[i]); ++i)\n\t\tkfree(a);\n\tkfree(p->gid_group.attrs);\n\tkfree(p);\n}\n\nstruct port_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct mlx4_port *, struct port_attribute *, char *buf);\n\tssize_t (*store)(struct mlx4_port *, struct port_attribute *,\n\t\t\t const char *buf, size_t count);\n};\n\nstatic ssize_t port_attr_show(struct kobject *kobj,\n\t\t\t      struct attribute *attr, char *buf)\n{\n\tstruct port_attribute *port_attr =\n\t\tcontainer_of(attr, struct port_attribute, attr);\n\tstruct mlx4_port *p = container_of(kobj, struct mlx4_port, kobj);\n\n\tif (!port_attr->show)\n\t\treturn -EIO;\n\treturn port_attr->show(p, port_attr, buf);\n}\n\nstatic ssize_t port_attr_store(struct kobject *kobj,\n\t\t\t       struct attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tstruct port_attribute *port_attr =\n\t\tcontainer_of(attr, struct port_attribute, attr);\n\tstruct mlx4_port *p = container_of(kobj, struct mlx4_port, kobj);\n\n\tif (!port_attr->store)\n\t\treturn -EIO;\n\treturn port_attr->store(p, port_attr, buf, size);\n}\n\nstatic const struct sysfs_ops port_sysfs_ops = {\n\t.show = port_attr_show,\n\t.store = port_attr_store,\n};\n\nstatic struct kobj_type port_type = {\n\t.release    = mlx4_port_release,\n\t.sysfs_ops  = &port_sysfs_ops,\n};\n\nstruct port_table_attribute {\n\tstruct port_attribute\tattr;\n\tchar\t\t\tname[8];\n\tint\t\t\tindex;\n};\n\nstatic ssize_t show_port_pkey(struct mlx4_port *p, struct port_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tstruct pkey_mgt *m = &p->dev->pkeys;\n\tu8 key = m->virt2phys_pkey[p->slave][p->port_num - 1][tab_attr->index];\n\n\tif (key >= p->dev->dev->caps.pkey_table_len[p->port_num])\n\t\treturn sysfs_emit(buf, \"none\\n\");\n\treturn sysfs_emit(buf, \"%d\\n\", key);\n}\n\nstatic ssize_t store_port_pkey(struct mlx4_port *p, struct port_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct port_table_attribute *tab_attr =\n\t\tcontainer_of(attr, struct port_table_attribute, attr);\n\tint idx;\n\tint err;\n\n\t \n\tif (p->slave == mlx4_master_func_num(p->dev->dev))\n\t\treturn -EINVAL;\n\n\tif (!strncasecmp(buf, \"no\", 2))\n\t\tidx = p->dev->dev->phys_caps.pkey_phys_table_len[p->port_num] - 1;\n\telse if (sscanf(buf, \"%i\", &idx) != 1 ||\n\t\t idx >= p->dev->dev->caps.pkey_table_len[p->port_num] ||\n\t\t idx < 0)\n\t\treturn -EINVAL;\n\n\tp->dev->pkeys.virt2phys_pkey[p->slave][p->port_num - 1]\n\t\t\t\t    [tab_attr->index] = idx;\n\tmlx4_sync_pkey_table(p->dev->dev, p->slave, p->port_num,\n\t\t\t     tab_attr->index, idx);\n\terr = mlx4_gen_pkey_eqe(p->dev->dev, p->slave, p->port_num);\n\tif (err) {\n\t\tpr_err(\"mlx4_gen_pkey_eqe failed for slave %d,\"\n\t\t       \" port %d, index %d\\n\", p->slave, p->port_num, idx);\n\t\treturn err;\n\t}\n\treturn count;\n}\n\nstatic ssize_t show_port_gid_idx(struct mlx4_port *p,\n\t\t\t\t struct port_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", p->slave);\n}\n\nstatic struct attribute **\nalloc_group_attrs(ssize_t (*show)(struct mlx4_port *,\n\t\t\t\t  struct port_attribute *, char *buf),\n\t\t  ssize_t (*store)(struct mlx4_port *, struct port_attribute *,\n\t\t\t\t   const char *buf, size_t count),\n\t\t  int len)\n{\n\tstruct attribute **tab_attr;\n\tstruct port_table_attribute *element;\n\tint i;\n\n\ttab_attr = kcalloc(1 + len, sizeof (struct attribute *), GFP_KERNEL);\n\tif (!tab_attr)\n\t\treturn NULL;\n\n\tfor (i = 0; i < len; i++) {\n\t\telement = kzalloc(sizeof (struct port_table_attribute),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!element)\n\t\t\tgoto err;\n\t\tif (snprintf(element->name, sizeof (element->name),\n\t\t\t     \"%d\", i) >= sizeof (element->name)) {\n\t\t\tkfree(element);\n\t\t\tgoto err;\n\t\t}\n\t\tsysfs_attr_init(&element->attr.attr);\n\t\telement->attr.attr.name  = element->name;\n\t\tif (store) {\n\t\t\telement->attr.attr.mode  = S_IWUSR | S_IRUGO;\n\t\t\telement->attr.store\t = store;\n\t\t} else\n\t\t\telement->attr.attr.mode  = S_IRUGO;\n\n\t\telement->attr.show       = show;\n\t\telement->index\t\t = i;\n\t\ttab_attr[i] = &element->attr.attr;\n\t}\n\treturn tab_attr;\n\nerr:\n\twhile (--i >= 0)\n\t\tkfree(tab_attr[i]);\n\tkfree(tab_attr);\n\treturn NULL;\n}\n\nstatic ssize_t sysfs_show_smi_enabled(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct mlx4_port *p =\n\t\tcontainer_of(attr, struct mlx4_port, smi_enabled);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!mlx4_vf_smi_enabled(p->dev->dev, p->slave,\n\t\t\t\t\t\tp->port_num));\n}\n\nstatic ssize_t sysfs_show_enable_smi_admin(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t\t   char *buf)\n{\n\tstruct mlx4_port *p =\n\t\tcontainer_of(attr, struct mlx4_port, enable_smi_admin);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  !!mlx4_vf_get_enable_smi_admin(p->dev->dev, p->slave,\n\t\t\t\t\t\t\t p->port_num));\n}\n\nstatic ssize_t sysfs_store_enable_smi_admin(struct device *dev,\n\t\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t\t    const char *buf, size_t count)\n{\n\tstruct mlx4_port *p =\n\t\tcontainer_of(attr, struct mlx4_port, enable_smi_admin);\n\tint enable;\n\n\tif (sscanf(buf, \"%i\", &enable) != 1 ||\n\t    enable < 0 || enable > 1)\n\t\treturn -EINVAL;\n\n\tif (mlx4_vf_set_enable_smi_admin(p->dev->dev, p->slave, p->port_num, enable))\n\t\treturn -EINVAL;\n\treturn count;\n}\n\nstatic int add_vf_smi_entries(struct mlx4_port *p)\n{\n\tint is_eth = rdma_port_get_link_layer(&p->dev->ib_dev, p->port_num) ==\n\t\t\tIB_LINK_LAYER_ETHERNET;\n\tint ret;\n\n\t \n\tif (is_eth || p->slave == mlx4_master_func_num(p->dev->dev))\n\t\treturn 0;\n\n\tsysfs_attr_init(&p->smi_enabled.attr);\n\tp->smi_enabled.show = sysfs_show_smi_enabled;\n\tp->smi_enabled.store = NULL;\n\tp->smi_enabled.attr.name = \"smi_enabled\";\n\tp->smi_enabled.attr.mode = 0444;\n\tret = sysfs_create_file(&p->kobj, &p->smi_enabled.attr);\n\tif (ret) {\n\t\tpr_err(\"failed to create smi_enabled\\n\");\n\t\treturn ret;\n\t}\n\n\tsysfs_attr_init(&p->enable_smi_admin.attr);\n\tp->enable_smi_admin.show = sysfs_show_enable_smi_admin;\n\tp->enable_smi_admin.store = sysfs_store_enable_smi_admin;\n\tp->enable_smi_admin.attr.name = \"enable_smi_admin\";\n\tp->enable_smi_admin.attr.mode = 0644;\n\tret = sysfs_create_file(&p->kobj, &p->enable_smi_admin.attr);\n\tif (ret) {\n\t\tpr_err(\"failed to create enable_smi_admin\\n\");\n\t\tsysfs_remove_file(&p->kobj, &p->smi_enabled.attr);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void remove_vf_smi_entries(struct mlx4_port *p)\n{\n\tint is_eth = rdma_port_get_link_layer(&p->dev->ib_dev, p->port_num) ==\n\t\t\tIB_LINK_LAYER_ETHERNET;\n\n\tif (is_eth || p->slave == mlx4_master_func_num(p->dev->dev))\n\t\treturn;\n\n\tsysfs_remove_file(&p->kobj, &p->smi_enabled.attr);\n\tsysfs_remove_file(&p->kobj, &p->enable_smi_admin.attr);\n}\n\nstatic int add_port(struct mlx4_ib_dev *dev, int port_num, int slave)\n{\n\tstruct mlx4_port *p;\n\tint i;\n\tint ret;\n\tint is_eth = rdma_port_get_link_layer(&dev->ib_dev, port_num) ==\n\t\t\tIB_LINK_LAYER_ETHERNET;\n\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->dev = dev;\n\tp->port_num = port_num;\n\tp->slave = slave;\n\n\tret = kobject_init_and_add(&p->kobj, &port_type,\n\t\t\t\t   kobject_get(dev->dev_ports_parent[slave]),\n\t\t\t\t   \"%d\", port_num);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\tp->pkey_group.name  = \"pkey_idx\";\n\tp->pkey_group.attrs =\n\t\talloc_group_attrs(show_port_pkey,\n\t\t\t\t  is_eth ? NULL : store_port_pkey,\n\t\t\t\t  dev->dev->caps.pkey_table_len[port_num]);\n\tif (!p->pkey_group.attrs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tret = sysfs_create_group(&p->kobj, &p->pkey_group);\n\tif (ret)\n\t\tgoto err_free_pkey;\n\n\tp->gid_group.name  = \"gid_idx\";\n\tp->gid_group.attrs = alloc_group_attrs(show_port_gid_idx, NULL, 1);\n\tif (!p->gid_group.attrs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_pkey;\n\t}\n\n\tret = sysfs_create_group(&p->kobj, &p->gid_group);\n\tif (ret)\n\t\tgoto err_free_gid;\n\n\tret = add_vf_smi_entries(p);\n\tif (ret)\n\t\tgoto err_free_gid;\n\n\tlist_add_tail(&p->kobj.entry, &dev->pkeys.pkey_port_list[slave]);\n\treturn 0;\n\nerr_free_gid:\n\tkfree(p->gid_group.attrs[0]);\n\tkfree(p->gid_group.attrs);\n\nerr_free_pkey:\n\tfor (i = 0; i < dev->dev->caps.pkey_table_len[port_num]; ++i)\n\t\tkfree(p->pkey_group.attrs[i]);\n\tkfree(p->pkey_group.attrs);\n\nerr_alloc:\n\tkobject_put(dev->dev_ports_parent[slave]);\n\tkfree(p);\n\treturn ret;\n}\n\nstatic int register_one_pkey_tree(struct mlx4_ib_dev *dev, int slave)\n{\n\tchar name[32];\n\tint err;\n\tint port;\n\tstruct kobject *p, *t;\n\tstruct mlx4_port *mport;\n\tstruct mlx4_active_ports actv_ports;\n\n\tget_name(dev, name, slave, sizeof name);\n\n\tdev->pkeys.device_parent[slave] =\n\t\tkobject_create_and_add(name, kobject_get(dev->iov_parent));\n\n\tif (!dev->pkeys.device_parent[slave]) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_dev;\n\t}\n\n\tINIT_LIST_HEAD(&dev->pkeys.pkey_port_list[slave]);\n\n\tdev->dev_ports_parent[slave] =\n\t\tkobject_create_and_add(\"ports\",\n\t\t\t\t       kobject_get(dev->pkeys.device_parent[slave]));\n\n\tif (!dev->dev_ports_parent[slave]) {\n\t\terr = -ENOMEM;\n\t\tgoto err_ports;\n\t}\n\n\tactv_ports = mlx4_get_active_ports(dev->dev, slave);\n\n\tfor (port = 1; port <= dev->dev->caps.num_ports; ++port) {\n\t\tif (!test_bit(port - 1, actv_ports.ports))\n\t\t\tcontinue;\n\t\terr = add_port(dev, port, slave);\n\t\tif (err)\n\t\t\tgoto err_add;\n\t}\n\treturn 0;\n\nerr_add:\n\tlist_for_each_entry_safe(p, t,\n\t\t\t\t &dev->pkeys.pkey_port_list[slave],\n\t\t\t\t entry) {\n\t\tlist_del(&p->entry);\n\t\tmport = container_of(p, struct mlx4_port, kobj);\n\t\tsysfs_remove_group(p, &mport->pkey_group);\n\t\tsysfs_remove_group(p, &mport->gid_group);\n\t\tremove_vf_smi_entries(mport);\n\t\tkobject_put(p);\n\t}\n\tkobject_put(dev->dev_ports_parent[slave]);\n\nerr_ports:\n\tkobject_put(dev->pkeys.device_parent[slave]);\n\t \n\tkobject_put(dev->pkeys.device_parent[slave]);\n\nfail_dev:\n\tkobject_put(dev->iov_parent);\n\treturn err;\n}\n\nstatic int register_pkey_tree(struct mlx4_ib_dev *device)\n{\n\tint i;\n\n\tif (!mlx4_is_master(device->dev))\n\t\treturn 0;\n\n\tfor (i = 0; i <= device->dev->persist->num_vfs; ++i)\n\t\tregister_one_pkey_tree(device, i);\n\n\treturn 0;\n}\n\nstatic void unregister_pkey_tree(struct mlx4_ib_dev *device)\n{\n\tint slave;\n\tstruct kobject *p, *t;\n\tstruct mlx4_port *port;\n\n\tif (!mlx4_is_master(device->dev))\n\t\treturn;\n\n\tfor (slave = device->dev->persist->num_vfs; slave >= 0; --slave) {\n\t\tlist_for_each_entry_safe(p, t,\n\t\t\t\t\t &device->pkeys.pkey_port_list[slave],\n\t\t\t\t\t entry) {\n\t\t\tlist_del(&p->entry);\n\t\t\tport = container_of(p, struct mlx4_port, kobj);\n\t\t\tsysfs_remove_group(p, &port->pkey_group);\n\t\t\tsysfs_remove_group(p, &port->gid_group);\n\t\t\tremove_vf_smi_entries(port);\n\t\t\tkobject_put(p);\n\t\t\tkobject_put(device->dev_ports_parent[slave]);\n\t\t}\n\t\tkobject_put(device->dev_ports_parent[slave]);\n\t\tkobject_put(device->pkeys.device_parent[slave]);\n\t\tkobject_put(device->pkeys.device_parent[slave]);\n\t\tkobject_put(device->iov_parent);\n\t}\n}\n\nint mlx4_ib_device_register_sysfs(struct mlx4_ib_dev *dev)\n{\n\tunsigned int i;\n\tint ret = 0;\n\n\tif (!mlx4_is_master(dev->dev))\n\t\treturn 0;\n\n\tdev->iov_parent = kobject_create_and_add(\"iov\", &dev->ib_dev.dev.kobj);\n\tif (!dev->iov_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->ports_parent =\n\t\tkobject_create_and_add(\"ports\",\n\t\t\t\t       kobject_get(dev->iov_parent));\n\tif (!dev->ports_parent) {\n\t\tret = -ENOMEM;\n\t\tgoto err_ports;\n\t}\n\n\trdma_for_each_port(&dev->ib_dev, i) {\n\t\tret = add_port_entries(dev, i);\n\t\tif (ret)\n\t\t\tgoto err_add_entries;\n\t}\n\n\tret = register_pkey_tree(dev);\n\tif (ret)\n\t\tgoto err_add_entries;\n\treturn 0;\n\nerr_add_entries:\n\tkobject_put(dev->ports_parent);\n\nerr_ports:\n\tkobject_put(dev->iov_parent);\nerr:\n\tpr_err(\"mlx4_ib_device_register_sysfs error (%d)\\n\", ret);\n\treturn ret;\n}\n\nstatic void unregister_alias_guid_tree(struct mlx4_ib_dev *device)\n{\n\tstruct mlx4_ib_iov_port *p;\n\tint i;\n\n\tif (!mlx4_is_master(device->dev))\n\t\treturn;\n\n\tfor (i = 0; i < device->dev->caps.num_ports; i++) {\n\t\tp = &device->iov_ports[i];\n\t\tkobject_put(p->admin_alias_parent);\n\t\tkobject_put(p->gids_parent);\n\t\tkobject_put(p->pkeys_parent);\n\t\tkobject_put(p->mcgs_parent);\n\t\tkobject_put(p->cur_port);\n\t\tkobject_put(p->cur_port);\n\t\tkobject_put(p->cur_port);\n\t\tkobject_put(p->cur_port);\n\t\tkobject_put(p->cur_port);\n\t\tkobject_put(p->dev->ports_parent);\n\t\tkfree(p->dentr_ar);\n\t}\n}\n\nvoid mlx4_ib_device_unregister_sysfs(struct mlx4_ib_dev *device)\n{\n\tunregister_alias_guid_tree(device);\n\tunregister_pkey_tree(device);\n\tkobject_put(device->ports_parent);\n\tkobject_put(device->iov_parent);\n\tkobject_put(device->iov_parent);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}