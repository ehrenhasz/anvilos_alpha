{
  "module_name": "restrack.c",
  "hash_id": "d8f2f9b9c2cda29c69fceedfd4851ebce40520ac9600e1797b6d4ab00c7f0931",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/cxgb4/restrack.c",
  "human_readable_source": " \n\n#include <rdma/rdma_cm.h>\n\n#include \"iw_cxgb4.h\"\n#include <rdma/restrack.h>\n#include <uapi/rdma/rdma_netlink.h>\n\nstatic int fill_sq(struct sk_buff *msg, struct t4_wq *wq)\n{\n\t \n\tif (rdma_nl_put_driver_u32(msg, \"sqid\", wq->sq.qid))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"flushed\", wq->flushed))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"memsize\", wq->sq.memsize))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"cidx\", wq->sq.cidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"pidx\", wq->sq.pidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"wq_pidx\", wq->sq.wq_pidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"flush_cidx\", wq->sq.flush_cidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"in_use\", wq->sq.in_use))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"size\", wq->sq.size))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"flags\", wq->sq.flags))\n\t\tgoto err;\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_rq(struct sk_buff *msg, struct t4_wq *wq)\n{\n\t \n\tif (rdma_nl_put_driver_u32(msg, \"rqid\", wq->rq.qid))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"memsize\", wq->rq.memsize))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"cidx\", wq->rq.cidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"pidx\", wq->rq.pidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"wq_pidx\", wq->rq.wq_pidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"msn\", wq->rq.msn))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"rqt_hwaddr\", wq->rq.rqt_hwaddr))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"rqt_size\", wq->rq.rqt_size))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"in_use\", wq->rq.in_use))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"size\", wq->rq.size))\n\t\tgoto err;\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_swsqe(struct sk_buff *msg, struct t4_sq *sq, u16 idx,\n\t\t      struct t4_swsqe *sqe)\n{\n\tif (rdma_nl_put_driver_u32(msg, \"idx\", idx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"opcode\", sqe->opcode))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"complete\", sqe->complete))\n\t\tgoto err;\n\tif (sqe->complete &&\n\t    rdma_nl_put_driver_u32(msg, \"cqe_status\", CQE_STATUS(&sqe->cqe)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"signaled\", sqe->signaled))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"flushed\", sqe->flushed))\n\t\tgoto err;\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\n \nstatic int fill_swsqes(struct sk_buff *msg, struct t4_sq *sq,\n\t\t       u16 first_idx, struct t4_swsqe *first_sqe,\n\t\t       u16 last_idx, struct t4_swsqe *last_sqe)\n{\n\tif (!first_sqe)\n\t\tgoto out;\n\tif (fill_swsqe(msg, sq, first_idx, first_sqe))\n\t\tgoto err;\n\tif (!last_sqe)\n\t\tgoto out;\n\tif (fill_swsqe(msg, sq, last_idx, last_sqe))\n\t\tgoto err;\nout:\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\nint c4iw_fill_res_qp_entry(struct sk_buff *msg, struct ib_qp *ibqp)\n{\n\tstruct t4_swsqe *fsp = NULL, *lsp = NULL;\n\tstruct c4iw_qp *qhp = to_c4iw_qp(ibqp);\n\tu16 first_sq_idx = 0, last_sq_idx = 0;\n\tstruct t4_swsqe first_sqe, last_sqe;\n\tstruct nlattr *table_attr;\n\tstruct t4_wq wq;\n\n\t \n\tif (qhp->ucontext)\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start_noflag(msg, RDMA_NLDEV_ATTR_DRIVER);\n\tif (!table_attr)\n\t\tgoto err;\n\n\t \n\tspin_lock_irq(&qhp->lock);\n\twq = qhp->wq;\n\n\t \n\tif (wq.sq.cidx != wq.sq.pidx) {\n\t\tfirst_sq_idx = wq.sq.cidx;\n\t\tfirst_sqe = qhp->wq.sq.sw_sq[first_sq_idx];\n\t\tfsp = &first_sqe;\n\t\tlast_sq_idx = wq.sq.pidx;\n\t\tif (last_sq_idx-- == 0)\n\t\t\tlast_sq_idx = wq.sq.size - 1;\n\t\tif (last_sq_idx != first_sq_idx) {\n\t\t\tlast_sqe = qhp->wq.sq.sw_sq[last_sq_idx];\n\t\t\tlsp = &last_sqe;\n\t\t}\n\t}\n\tspin_unlock_irq(&qhp->lock);\n\n\tif (fill_sq(msg, &wq))\n\t\tgoto err_cancel_table;\n\n\tif (fill_swsqes(msg, &wq.sq, first_sq_idx, fsp, last_sq_idx, lsp))\n\t\tgoto err_cancel_table;\n\n\tif (fill_rq(msg, &wq))\n\t\tgoto err_cancel_table;\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr_cancel_table:\n\tnla_nest_cancel(msg, table_attr);\nerr:\n\treturn -EMSGSIZE;\n}\n\nunion union_ep {\n\tstruct c4iw_listen_ep lep;\n\tstruct c4iw_ep ep;\n};\n\nint c4iw_fill_res_cm_id_entry(struct sk_buff *msg,\n\t\t\t      struct rdma_cm_id *cm_id)\n{\n\tstruct nlattr *table_attr;\n\tstruct c4iw_ep_common *epcp;\n\tstruct c4iw_listen_ep *listen_ep = NULL;\n\tstruct c4iw_ep *ep = NULL;\n\tstruct iw_cm_id *iw_cm_id;\n\tunion union_ep *uep;\n\n\tiw_cm_id = rdma_iw_cm_id(cm_id);\n\tif (!iw_cm_id)\n\t\treturn 0;\n\tepcp = (struct c4iw_ep_common *)iw_cm_id->provider_data;\n\tif (!epcp)\n\t\treturn 0;\n\tuep = kzalloc(sizeof(*uep), GFP_KERNEL);\n\tif (!uep)\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start_noflag(msg, RDMA_NLDEV_ATTR_DRIVER);\n\tif (!table_attr)\n\t\tgoto err_free_uep;\n\n\t \n\tmutex_lock(&epcp->mutex);\n\tif (epcp->state == LISTEN) {\n\t\tuep->lep = *(struct c4iw_listen_ep *)epcp;\n\t\tmutex_unlock(&epcp->mutex);\n\t\tlisten_ep = &uep->lep;\n\t\tepcp = &listen_ep->com;\n\t} else {\n\t\tuep->ep = *(struct c4iw_ep *)epcp;\n\t\tmutex_unlock(&epcp->mutex);\n\t\tep = &uep->ep;\n\t\tepcp = &ep->com;\n\t}\n\n\tif (rdma_nl_put_driver_u32(msg, \"state\", epcp->state))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u64_hex(msg, \"flags\", epcp->flags))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u64_hex(msg, \"history\", epcp->history))\n\t\tgoto err_cancel_table;\n\n\tif (listen_ep) {\n\t\tif (rdma_nl_put_driver_u32(msg, \"stid\", listen_ep->stid))\n\t\t\tgoto err_cancel_table;\n\t\tif (rdma_nl_put_driver_u32(msg, \"backlog\", listen_ep->backlog))\n\t\t\tgoto err_cancel_table;\n\t} else {\n\t\tif (rdma_nl_put_driver_u32(msg, \"hwtid\", ep->hwtid))\n\t\t\tgoto err_cancel_table;\n\t\tif (rdma_nl_put_driver_u32(msg, \"ord\", ep->ord))\n\t\t\tgoto err_cancel_table;\n\t\tif (rdma_nl_put_driver_u32(msg, \"ird\", ep->ird))\n\t\t\tgoto err_cancel_table;\n\t\tif (rdma_nl_put_driver_u32(msg, \"emss\", ep->emss))\n\t\t\tgoto err_cancel_table;\n\n\t\tif (!ep->parent_ep && rdma_nl_put_driver_u32(msg, \"atid\",\n\t\t\t\t\t\t\t     ep->atid))\n\t\t\tgoto err_cancel_table;\n\t}\n\tnla_nest_end(msg, table_attr);\n\tkfree(uep);\n\treturn 0;\n\nerr_cancel_table:\n\tnla_nest_cancel(msg, table_attr);\nerr_free_uep:\n\tkfree(uep);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_cq(struct sk_buff *msg, struct t4_cq *cq)\n{\n\tif (rdma_nl_put_driver_u32(msg, \"cqid\", cq->cqid))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"memsize\", cq->memsize))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"size\", cq->size))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"cidx\", cq->cidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"cidx_inc\", cq->cidx_inc))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"sw_cidx\", cq->sw_cidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"sw_pidx\", cq->sw_pidx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"sw_in_use\", cq->sw_in_use))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"vector\", cq->vector))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"gen\", cq->gen))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"error\", cq->error))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u64_hex(msg, \"bits_type_ts\",\n\t\t\t\t\t be64_to_cpu(cq->bits_type_ts)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u64_hex(msg, \"flags\", cq->flags))\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_cqe(struct sk_buff *msg, struct t4_cqe *cqe, u16 idx,\n\t\t    const char *qstr)\n{\n\tif (rdma_nl_put_driver_u32(msg, qstr, idx))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"header\",\n\t\t\t\t\t be32_to_cpu(cqe->header)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32(msg, \"len\", be32_to_cpu(cqe->len)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"wrid_hi\",\n\t\t\t\t\t be32_to_cpu(cqe->u.gen.wrid_hi)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"wrid_low\",\n\t\t\t\t\t be32_to_cpu(cqe->u.gen.wrid_low)))\n\t\tgoto err;\n\tif (rdma_nl_put_driver_u64_hex(msg, \"bits_type_ts\",\n\t\t\t\t\t be64_to_cpu(cqe->bits_type_ts)))\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_hwcqes(struct sk_buff *msg, struct t4_cq *cq,\n\t\t       struct t4_cqe *cqes)\n{\n\tu16 idx;\n\n\tidx = (cq->cidx > 0) ? cq->cidx - 1 : cq->size - 1;\n\tif (fill_cqe(msg, cqes, idx, \"hwcq_idx\"))\n\t\tgoto err;\n\tidx = cq->cidx;\n\tif (fill_cqe(msg, cqes + 1, idx, \"hwcq_idx\"))\n\t\tgoto err;\n\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_swcqes(struct sk_buff *msg, struct t4_cq *cq,\n\t\t       struct t4_cqe *cqes)\n{\n\tu16 idx;\n\n\tif (!cq->sw_in_use)\n\t\treturn 0;\n\n\tidx = cq->sw_cidx;\n\tif (fill_cqe(msg, cqes, idx, \"swcq_idx\"))\n\t\tgoto err;\n\tif (cq->sw_in_use == 1)\n\t\tgoto out;\n\tidx = (cq->sw_pidx > 0) ? cq->sw_pidx - 1 : cq->size - 1;\n\tif (fill_cqe(msg, cqes + 1, idx, \"swcq_idx\"))\n\t\tgoto err;\nout:\n\treturn 0;\nerr:\n\treturn -EMSGSIZE;\n}\n\nint c4iw_fill_res_cq_entry(struct sk_buff *msg, struct ib_cq *ibcq)\n{\n\tstruct c4iw_cq *chp = to_c4iw_cq(ibcq);\n\tstruct nlattr *table_attr;\n\tstruct t4_cqe hwcqes[2];\n\tstruct t4_cqe swcqes[2];\n\tstruct t4_cq cq;\n\tu16 idx;\n\n\t \n\tif (ibcq->uobject)\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start_noflag(msg, RDMA_NLDEV_ATTR_DRIVER);\n\tif (!table_attr)\n\t\tgoto err;\n\n\t \n\tspin_lock_irq(&chp->lock);\n\n\t \n\tcq = chp->cq;\n\n\t \n\tidx = (cq.cidx > 0) ? cq.cidx - 1 : cq.size - 1;\n\thwcqes[0] = chp->cq.queue[idx];\n\n\tidx = cq.cidx;\n\thwcqes[1] = chp->cq.queue[idx];\n\n\t \n\tif (cq.sw_in_use) {\n\t\tswcqes[0] = chp->cq.sw_queue[cq.sw_cidx];\n\t\tif (cq.sw_in_use > 1) {\n\t\t\tidx = (cq.sw_pidx > 0) ? cq.sw_pidx - 1 : cq.size - 1;\n\t\t\tswcqes[1] = chp->cq.sw_queue[idx];\n\t\t}\n\t}\n\n\tspin_unlock_irq(&chp->lock);\n\n\tif (fill_cq(msg, &cq))\n\t\tgoto err_cancel_table;\n\n\tif (fill_swcqes(msg, &cq, swcqes))\n\t\tgoto err_cancel_table;\n\n\tif (fill_hwcqes(msg, &cq, hwcqes))\n\t\tgoto err_cancel_table;\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr_cancel_table:\n\tnla_nest_cancel(msg, table_attr);\nerr:\n\treturn -EMSGSIZE;\n}\n\nint c4iw_fill_res_mr_entry(struct sk_buff *msg, struct ib_mr *ibmr)\n{\n\tstruct c4iw_mr *mhp = to_c4iw_mr(ibmr);\n\tstruct c4iw_dev *dev = mhp->rhp;\n\tu32 stag = mhp->attr.stag;\n\tstruct nlattr *table_attr;\n\tstruct fw_ri_tpte tpte;\n\tint ret;\n\n\tif (!stag)\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start_noflag(msg, RDMA_NLDEV_ATTR_DRIVER);\n\tif (!table_attr)\n\t\tgoto err;\n\n\tret = cxgb4_read_tpte(dev->rdev.lldi.ports[0], stag, (__be32 *)&tpte);\n\tif (ret) {\n\t\tdev_err(&dev->rdev.lldi.pdev->dev,\n\t\t\t\"%s cxgb4_read_tpte err %d\\n\", __func__, ret);\n\t\treturn 0;\n\t}\n\n\tif (rdma_nl_put_driver_u32_hex(msg, \"idx\", stag >> 8))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32(msg, \"valid\",\n\t\t\tFW_RI_TPTE_VALID_G(ntohl(tpte.valid_to_pdid))))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"key\", stag & 0xff))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32(msg, \"state\",\n\t\t\tFW_RI_TPTE_STAGSTATE_G(ntohl(tpte.valid_to_pdid))))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32(msg, \"pdid\",\n\t\t\tFW_RI_TPTE_PDID_G(ntohl(tpte.valid_to_pdid))))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"perm\",\n\t\t\tFW_RI_TPTE_PERM_G(ntohl(tpte.locread_to_qpid))))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32(msg, \"ps\",\n\t\t\tFW_RI_TPTE_PS_G(ntohl(tpte.locread_to_qpid))))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u64(msg, \"len\",\n\t\t      ((u64)ntohl(tpte.len_hi) << 32) | ntohl(tpte.len_lo)))\n\t\tgoto err_cancel_table;\n\tif (rdma_nl_put_driver_u32_hex(msg, \"pbl_addr\",\n\t\t\tFW_RI_TPTE_PBLADDR_G(ntohl(tpte.nosnoop_pbladdr))))\n\t\tgoto err_cancel_table;\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr_cancel_table:\n\tnla_nest_cancel(msg, table_attr);\nerr:\n\treturn -EMSGSIZE;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}