{
  "module_name": "ev.c",
  "hash_id": "4890ba2b2054c81ab4cf545209ed49cd07c424d39e411ace777dd270d2f53d43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/cxgb4/ev.c",
  "human_readable_source": " \n#include <linux/slab.h>\n#include <linux/mman.h>\n#include <net/sock.h>\n\n#include \"iw_cxgb4.h\"\n\nstatic void print_tpte(struct c4iw_dev *dev, u32 stag)\n{\n\tint ret;\n\tstruct fw_ri_tpte tpte;\n\n\tret = cxgb4_read_tpte(dev->rdev.lldi.ports[0], stag,\n\t\t\t      (__be32 *)&tpte);\n\tif (ret) {\n\t\tdev_err(&dev->rdev.lldi.pdev->dev,\n\t\t\t\"%s cxgb4_read_tpte err %d\\n\", __func__, ret);\n\t\treturn;\n\t}\n\tpr_debug(\"stag idx 0x%x valid %d key 0x%x state %d pdid %d perm 0x%x ps %d len 0x%llx va 0x%llx\\n\",\n\t\t stag & 0xffffff00,\n\t\t FW_RI_TPTE_VALID_G(ntohl(tpte.valid_to_pdid)),\n\t\t FW_RI_TPTE_STAGKEY_G(ntohl(tpte.valid_to_pdid)),\n\t\t FW_RI_TPTE_STAGSTATE_G(ntohl(tpte.valid_to_pdid)),\n\t\t FW_RI_TPTE_PDID_G(ntohl(tpte.valid_to_pdid)),\n\t\t FW_RI_TPTE_PERM_G(ntohl(tpte.locread_to_qpid)),\n\t\t FW_RI_TPTE_PS_G(ntohl(tpte.locread_to_qpid)),\n\t\t ((u64)ntohl(tpte.len_hi) << 32) | ntohl(tpte.len_lo),\n\t\t ((u64)ntohl(tpte.va_hi) << 32) | ntohl(tpte.va_lo_fbo));\n}\n\nstatic void dump_err_cqe(struct c4iw_dev *dev, struct t4_cqe *err_cqe)\n{\n\t__be64 *p = (void *)err_cqe;\n\n\tdev_err(&dev->rdev.lldi.pdev->dev,\n\t\t\"AE qpid %d opcode %d status 0x%x \"\n\t\t\"type %d len 0x%x wrid.hi 0x%x wrid.lo 0x%x\\n\",\n\t\tCQE_QPID(err_cqe), CQE_OPCODE(err_cqe),\n\t\tCQE_STATUS(err_cqe), CQE_TYPE(err_cqe), ntohl(err_cqe->len),\n\t\tCQE_WRID_HI(err_cqe), CQE_WRID_LOW(err_cqe));\n\n\tpr_debug(\"%016llx %016llx %016llx %016llx - %016llx %016llx %016llx %016llx\\n\",\n\t\t be64_to_cpu(p[0]), be64_to_cpu(p[1]), be64_to_cpu(p[2]),\n\t\t be64_to_cpu(p[3]), be64_to_cpu(p[4]), be64_to_cpu(p[5]),\n\t\t be64_to_cpu(p[6]), be64_to_cpu(p[7]));\n\n\t \n\tif (RQ_TYPE(err_cqe) && (CQE_OPCODE(err_cqe) == FW_RI_RDMA_WRITE ||\n\t\t\t\t CQE_OPCODE(err_cqe) == FW_RI_READ_RESP))\n\t\tprint_tpte(dev, CQE_WRID_STAG(err_cqe));\n}\n\nstatic void post_qp_event(struct c4iw_dev *dev, struct c4iw_cq *chp,\n\t\t\t  struct c4iw_qp *qhp,\n\t\t\t  struct t4_cqe *err_cqe,\n\t\t\t  enum ib_event_type ib_event)\n{\n\tstruct ib_event event;\n\tstruct c4iw_qp_attributes attrs;\n\tunsigned long flag;\n\n\tdump_err_cqe(dev, err_cqe);\n\n\tif (qhp->attr.state == C4IW_QP_STATE_RTS) {\n\t\tattrs.next_state = C4IW_QP_STATE_TERMINATE;\n\t\tc4iw_modify_qp(qhp->rhp, qhp, C4IW_QP_ATTR_NEXT_STATE,\n\t\t\t       &attrs, 0);\n\t}\n\n\tevent.event = ib_event;\n\tevent.device = chp->ibcq.device;\n\tif (ib_event == IB_EVENT_CQ_ERR)\n\t\tevent.element.cq = &chp->ibcq;\n\telse\n\t\tevent.element.qp = &qhp->ibqp;\n\tif (qhp->ibqp.event_handler)\n\t\t(*qhp->ibqp.event_handler)(&event, qhp->ibqp.qp_context);\n\n\tif (t4_clear_cq_armed(&chp->cq)) {\n\t\tspin_lock_irqsave(&chp->comp_handler_lock, flag);\n\t\t(*chp->ibcq.comp_handler)(&chp->ibcq, chp->ibcq.cq_context);\n\t\tspin_unlock_irqrestore(&chp->comp_handler_lock, flag);\n\t}\n}\n\nvoid c4iw_ev_dispatch(struct c4iw_dev *dev, struct t4_cqe *err_cqe)\n{\n\tstruct c4iw_cq *chp;\n\tstruct c4iw_qp *qhp;\n\tu32 cqid;\n\n\txa_lock_irq(&dev->qps);\n\tqhp = xa_load(&dev->qps, CQE_QPID(err_cqe));\n\tif (!qhp) {\n\t\tpr_err(\"BAD AE qpid 0x%x opcode %d status 0x%x type %d wrid.hi 0x%x wrid.lo 0x%x\\n\",\n\t\t       CQE_QPID(err_cqe),\n\t\t       CQE_OPCODE(err_cqe), CQE_STATUS(err_cqe),\n\t\t       CQE_TYPE(err_cqe), CQE_WRID_HI(err_cqe),\n\t\t       CQE_WRID_LOW(err_cqe));\n\t\txa_unlock_irq(&dev->qps);\n\t\tgoto out;\n\t}\n\n\tif (SQ_TYPE(err_cqe))\n\t\tcqid = qhp->attr.scq;\n\telse\n\t\tcqid = qhp->attr.rcq;\n\tchp = get_chp(dev, cqid);\n\tif (!chp) {\n\t\tpr_err(\"BAD AE cqid 0x%x qpid 0x%x opcode %d status 0x%x type %d wrid.hi 0x%x wrid.lo 0x%x\\n\",\n\t\t       cqid, CQE_QPID(err_cqe),\n\t\t       CQE_OPCODE(err_cqe), CQE_STATUS(err_cqe),\n\t\t       CQE_TYPE(err_cqe), CQE_WRID_HI(err_cqe),\n\t\t       CQE_WRID_LOW(err_cqe));\n\t\txa_unlock_irq(&dev->qps);\n\t\tgoto out;\n\t}\n\n\tc4iw_qp_add_ref(&qhp->ibqp);\n\trefcount_inc(&chp->refcnt);\n\txa_unlock_irq(&dev->qps);\n\n\t \n\tif (RQ_TYPE(err_cqe) &&\n\t    (CQE_OPCODE(err_cqe) == FW_RI_RDMA_WRITE)) {\n\t\tpost_qp_event(dev, chp, qhp, err_cqe, IB_EVENT_QP_REQ_ERR);\n\t\tgoto done;\n\t}\n\n\tswitch (CQE_STATUS(err_cqe)) {\n\n\t \n\tcase T4_ERR_SUCCESS:\n\t\tpr_err(\"AE with status 0!\\n\");\n\t\tbreak;\n\n\tcase T4_ERR_STAG:\n\tcase T4_ERR_PDID:\n\tcase T4_ERR_QPID:\n\tcase T4_ERR_ACCESS:\n\tcase T4_ERR_WRAP:\n\tcase T4_ERR_BOUND:\n\tcase T4_ERR_INVALIDATE_SHARED_MR:\n\tcase T4_ERR_INVALIDATE_MR_WITH_MW_BOUND:\n\t\tpost_qp_event(dev, chp, qhp, err_cqe, IB_EVENT_QP_ACCESS_ERR);\n\t\tbreak;\n\n\t \n\tcase T4_ERR_ECC:\n\tcase T4_ERR_ECC_PSTAG:\n\tcase T4_ERR_INTERNAL_ERR:\n\t\tpost_qp_event(dev, chp, qhp, err_cqe, IB_EVENT_DEVICE_FATAL);\n\t\tbreak;\n\n\t \n\tcase T4_ERR_OUT_OF_RQE:\n\tcase T4_ERR_PBL_ADDR_BOUND:\n\tcase T4_ERR_CRC:\n\tcase T4_ERR_MARKER:\n\tcase T4_ERR_PDU_LEN_ERR:\n\tcase T4_ERR_DDP_VERSION:\n\tcase T4_ERR_RDMA_VERSION:\n\tcase T4_ERR_OPCODE:\n\tcase T4_ERR_DDP_QUEUE_NUM:\n\tcase T4_ERR_MSN:\n\tcase T4_ERR_TBIT:\n\tcase T4_ERR_MO:\n\tcase T4_ERR_MSN_GAP:\n\tcase T4_ERR_MSN_RANGE:\n\tcase T4_ERR_RQE_ADDR_BOUND:\n\tcase T4_ERR_IRD_OVERFLOW:\n\t\tpost_qp_event(dev, chp, qhp, err_cqe, IB_EVENT_QP_FATAL);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unknown T4 status 0x%x QPID 0x%x\\n\",\n\t\t       CQE_STATUS(err_cqe), qhp->wq.sq.qid);\n\t\tpost_qp_event(dev, chp, qhp, err_cqe, IB_EVENT_QP_FATAL);\n\t\tbreak;\n\t}\ndone:\n\tc4iw_cq_rem_ref(chp);\n\tc4iw_qp_rem_ref(&qhp->ibqp);\nout:\n\treturn;\n}\n\nint c4iw_ev_handler(struct c4iw_dev *dev, u32 qid)\n{\n\tstruct c4iw_cq *chp;\n\tunsigned long flag;\n\n\txa_lock_irqsave(&dev->cqs, flag);\n\tchp = xa_load(&dev->cqs, qid);\n\tif (chp) {\n\t\trefcount_inc(&chp->refcnt);\n\t\txa_unlock_irqrestore(&dev->cqs, flag);\n\t\tt4_clear_cq_armed(&chp->cq);\n\t\tspin_lock_irqsave(&chp->comp_handler_lock, flag);\n\t\t(*chp->ibcq.comp_handler)(&chp->ibcq, chp->ibcq.cq_context);\n\t\tspin_unlock_irqrestore(&chp->comp_handler_lock, flag);\n\t\tc4iw_cq_rem_ref(chp);\n\t} else {\n\t\tpr_debug(\"unknown cqid 0x%x\\n\", qid);\n\t\txa_unlock_irqrestore(&dev->cqs, flag);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}