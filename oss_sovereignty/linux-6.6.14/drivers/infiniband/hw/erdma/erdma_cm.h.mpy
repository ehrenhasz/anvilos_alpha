{
  "module_name": "erdma_cm.h",
  "hash_id": "57462ef19e810cb598426214fbe8d960cf1e6166a11c4a9361c0fd0d6ba17c67",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma_cm.h",
  "human_readable_source": " \n\n \n \n \n\n \n \n \n \n\n#ifndef __ERDMA_CM_H__\n#define __ERDMA_CM_H__\n\n#include <linux/tcp.h>\n#include <net/sock.h>\n#include <rdma/iw_cm.h>\n\n \n#define MPA_REVISION_EXT_1 129\n#define MPA_MAX_PRIVDATA RDMA_MAX_PRIVATE_DATA\n#define MPA_KEY_REQ \"MPA ID Req Frame\"\n#define MPA_KEY_REP \"MPA ID Rep Frame\"\n#define MPA_KEY_SIZE 16\n#define MPA_DEFAULT_HDR_LEN 28\n\nstruct mpa_rr_params {\n\t__be16 bits;\n\t__be16 pd_len;\n};\n\n \nenum {\n\tMPA_RR_FLAG_MARKERS = cpu_to_be16(0x8000),\n\tMPA_RR_FLAG_CRC = cpu_to_be16(0x4000),\n\tMPA_RR_FLAG_REJECT = cpu_to_be16(0x2000),\n\tMPA_RR_RESERVED = cpu_to_be16(0x1f00),\n\tMPA_RR_MASK_REVISION = cpu_to_be16(0x00ff)\n};\n\n \nstruct mpa_rr {\n\tu8 key[16];\n\tstruct mpa_rr_params params;\n};\n\nstruct erdma_mpa_ext {\n\t__be32 cookie;\n\t__be32 bits;\n};\n\nenum {\n\tMPA_EXT_FLAG_CC = cpu_to_be32(0x0000000f),\n};\n\nstruct erdma_mpa_info {\n\tstruct mpa_rr hdr;  \n\tstruct erdma_mpa_ext ext_data;\n\tchar *pdata;\n\tint bytes_rcvd;\n};\n\nstruct erdma_sk_upcalls {\n\tvoid (*sk_state_change)(struct sock *sk);\n\tvoid (*sk_data_ready)(struct sock *sk, int bytes);\n\tvoid (*sk_error_report)(struct sock *sk);\n};\n\nstruct erdma_dev;\n\nenum erdma_cep_state {\n\tERDMA_EPSTATE_IDLE = 1,\n\tERDMA_EPSTATE_LISTENING,\n\tERDMA_EPSTATE_CONNECTING,\n\tERDMA_EPSTATE_AWAIT_MPAREQ,\n\tERDMA_EPSTATE_RECVD_MPAREQ,\n\tERDMA_EPSTATE_AWAIT_MPAREP,\n\tERDMA_EPSTATE_RDMA_MODE,\n\tERDMA_EPSTATE_CLOSED\n};\n\nstruct erdma_cep {\n\tstruct iw_cm_id *cm_id;\n\tstruct erdma_dev *dev;\n\tstruct list_head devq;\n\tspinlock_t lock;\n\tstruct kref ref;\n\tint in_use;\n\twait_queue_head_t waitq;\n\tenum erdma_cep_state state;\n\n\tstruct list_head listenq;\n\tstruct erdma_cep *listen_cep;\n\n\tstruct erdma_qp *qp;\n\tstruct socket *sock;\n\n\tstruct erdma_cm_work *mpa_timer;\n\tstruct list_head work_freelist;\n\n\tstruct erdma_mpa_info mpa;\n\tint ord;\n\tint ird;\n\n\tint pd_len;\n\t \n\tvoid *private_data;\n\n\t \n\tvoid (*sk_state_change)(struct sock *sk);\n\tvoid (*sk_data_ready)(struct sock *sk);\n\tvoid (*sk_error_report)(struct sock *sk);\n};\n\n#define MPAREQ_TIMEOUT (HZ * 20)\n#define MPAREP_TIMEOUT (HZ * 10)\n#define CONNECT_TIMEOUT (HZ * 10)\n\nenum erdma_work_type {\n\tERDMA_CM_WORK_ACCEPT = 1,\n\tERDMA_CM_WORK_READ_MPAHDR,\n\tERDMA_CM_WORK_CLOSE_LLP,  \n\tERDMA_CM_WORK_PEER_CLOSE,  \n\tERDMA_CM_WORK_MPATIMEOUT,\n\tERDMA_CM_WORK_CONNECTED,\n\tERDMA_CM_WORK_CONNECTTIMEOUT\n};\n\nstruct erdma_cm_work {\n\tstruct delayed_work work;\n\tstruct list_head list;\n\tenum erdma_work_type type;\n\tstruct erdma_cep *cep;\n};\n\n#define to_sockaddr_in(a) (*(struct sockaddr_in *)(&(a)))\n\nstatic inline int getname_peer(struct socket *s, struct sockaddr_storage *a)\n{\n\treturn s->ops->getname(s, (struct sockaddr *)a, 1);\n}\n\nstatic inline int getname_local(struct socket *s, struct sockaddr_storage *a)\n{\n\treturn s->ops->getname(s, (struct sockaddr *)a, 0);\n}\n\nint erdma_connect(struct iw_cm_id *id, struct iw_cm_conn_param *param);\nint erdma_accept(struct iw_cm_id *id, struct iw_cm_conn_param *param);\nint erdma_reject(struct iw_cm_id *id, const void *pdata, u8 plen);\nint erdma_create_listen(struct iw_cm_id *id, int backlog);\nint erdma_destroy_listen(struct iw_cm_id *id);\n\nvoid erdma_cep_get(struct erdma_cep *ceq);\nvoid erdma_cep_put(struct erdma_cep *ceq);\nint erdma_cm_queue_work(struct erdma_cep *ceq, enum erdma_work_type type);\n\nint erdma_cm_init(void);\nvoid erdma_cm_exit(void);\n\n#define sk_to_cep(sk) ((struct erdma_cep *)((sk)->sk_user_data))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}