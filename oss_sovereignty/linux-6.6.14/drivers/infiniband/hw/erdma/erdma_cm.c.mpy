{
  "module_name": "erdma_cm.c",
  "hash_id": "4a41a5a99e96847cd2a954a2a5c265d1d746ef1ff86d07ac782098bd2ad1e9d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma_cm.c",
  "human_readable_source": "\n\n \n \n \n\n \n \n \n \n \n\n#include <linux/workqueue.h>\n#include <trace/events/sock.h>\n\n#include \"erdma.h\"\n#include \"erdma_cm.h\"\n#include \"erdma_verbs.h\"\n\nstatic struct workqueue_struct *erdma_cm_wq;\n\nstatic void erdma_cm_llp_state_change(struct sock *sk);\nstatic void erdma_cm_llp_data_ready(struct sock *sk);\nstatic void erdma_cm_llp_error_report(struct sock *sk);\n\nstatic void erdma_sk_assign_cm_upcalls(struct sock *sk)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_state_change = erdma_cm_llp_state_change;\n\tsk->sk_data_ready = erdma_cm_llp_data_ready;\n\tsk->sk_error_report = erdma_cm_llp_error_report;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void erdma_sk_save_upcalls(struct sock *sk)\n{\n\tstruct erdma_cep *cep = sk_to_cep(sk);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tcep->sk_state_change = sk->sk_state_change;\n\tcep->sk_data_ready = sk->sk_data_ready;\n\tcep->sk_error_report = sk->sk_error_report;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void erdma_sk_restore_upcalls(struct sock *sk, struct erdma_cep *cep)\n{\n\tsk->sk_state_change = cep->sk_state_change;\n\tsk->sk_data_ready = cep->sk_data_ready;\n\tsk->sk_error_report = cep->sk_error_report;\n\tsk->sk_user_data = NULL;\n}\n\nstatic void erdma_socket_disassoc(struct socket *s)\n{\n\tstruct sock *sk = s->sk;\n\tstruct erdma_cep *cep;\n\n\tif (sk) {\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tcep = sk_to_cep(sk);\n\t\tif (cep) {\n\t\t\terdma_sk_restore_upcalls(sk, cep);\n\t\t\terdma_cep_put(cep);\n\t\t} else {\n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t} else {\n\t\tWARN_ON_ONCE(1);\n\t}\n}\n\nstatic void erdma_cep_socket_assoc(struct erdma_cep *cep, struct socket *s)\n{\n\tcep->sock = s;\n\terdma_cep_get(cep);\n\ts->sk->sk_user_data = cep;\n\n\terdma_sk_save_upcalls(s->sk);\n\terdma_sk_assign_cm_upcalls(s->sk);\n}\n\nstatic void erdma_disassoc_listen_cep(struct erdma_cep *cep)\n{\n\tif (cep->listen_cep) {\n\t\terdma_cep_put(cep->listen_cep);\n\t\tcep->listen_cep = NULL;\n\t}\n}\n\nstatic struct erdma_cep *erdma_cep_alloc(struct erdma_dev *dev)\n{\n\tstruct erdma_cep *cep = kzalloc(sizeof(*cep), GFP_KERNEL);\n\tunsigned long flags;\n\n\tif (!cep)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&cep->listenq);\n\tINIT_LIST_HEAD(&cep->devq);\n\tINIT_LIST_HEAD(&cep->work_freelist);\n\n\tkref_init(&cep->ref);\n\tcep->state = ERDMA_EPSTATE_IDLE;\n\tinit_waitqueue_head(&cep->waitq);\n\tspin_lock_init(&cep->lock);\n\tcep->dev = dev;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlist_add_tail(&cep->devq, &dev->cep_list);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn cep;\n}\n\nstatic void erdma_cm_free_work(struct erdma_cep *cep)\n{\n\tstruct list_head *w, *tmp;\n\tstruct erdma_cm_work *work;\n\n\tlist_for_each_safe(w, tmp, &cep->work_freelist) {\n\t\twork = list_entry(w, struct erdma_cm_work, list);\n\t\tlist_del(&work->list);\n\t\tkfree(work);\n\t}\n}\n\nstatic void erdma_cancel_mpatimer(struct erdma_cep *cep)\n{\n\tspin_lock_bh(&cep->lock);\n\tif (cep->mpa_timer) {\n\t\tif (cancel_delayed_work(&cep->mpa_timer->work)) {\n\t\t\terdma_cep_put(cep);\n\t\t\tkfree(cep->mpa_timer);\n\t\t}\n\t\tcep->mpa_timer = NULL;\n\t}\n\tspin_unlock_bh(&cep->lock);\n}\n\nstatic void erdma_put_work(struct erdma_cm_work *work)\n{\n\tINIT_LIST_HEAD(&work->list);\n\tspin_lock_bh(&work->cep->lock);\n\tlist_add(&work->list, &work->cep->work_freelist);\n\tspin_unlock_bh(&work->cep->lock);\n}\n\nstatic void erdma_cep_set_inuse(struct erdma_cep *cep)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cep->lock, flags);\n\twhile (cep->in_use) {\n\t\tspin_unlock_irqrestore(&cep->lock, flags);\n\t\twait_event_interruptible(cep->waitq, !cep->in_use);\n\t\tif (signal_pending(current))\n\t\t\tflush_signals(current);\n\n\t\tspin_lock_irqsave(&cep->lock, flags);\n\t}\n\n\tcep->in_use = 1;\n\tspin_unlock_irqrestore(&cep->lock, flags);\n}\n\nstatic void erdma_cep_set_free(struct erdma_cep *cep)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cep->lock, flags);\n\tcep->in_use = 0;\n\tspin_unlock_irqrestore(&cep->lock, flags);\n\n\twake_up(&cep->waitq);\n}\n\nstatic void __erdma_cep_dealloc(struct kref *ref)\n{\n\tstruct erdma_cep *cep = container_of(ref, struct erdma_cep, ref);\n\tstruct erdma_dev *dev = cep->dev;\n\tunsigned long flags;\n\n\tWARN_ON(cep->listen_cep);\n\n\tkfree(cep->private_data);\n\tkfree(cep->mpa.pdata);\n\tspin_lock_bh(&cep->lock);\n\tif (!list_empty(&cep->work_freelist))\n\t\terdma_cm_free_work(cep);\n\tspin_unlock_bh(&cep->lock);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlist_del(&cep->devq);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tkfree(cep);\n}\n\nstatic struct erdma_cm_work *erdma_get_work(struct erdma_cep *cep)\n{\n\tstruct erdma_cm_work *work = NULL;\n\n\tspin_lock_bh(&cep->lock);\n\tif (!list_empty(&cep->work_freelist)) {\n\t\twork = list_entry(cep->work_freelist.next, struct erdma_cm_work,\n\t\t\t\t  list);\n\t\tlist_del_init(&work->list);\n\t}\n\n\tspin_unlock_bh(&cep->lock);\n\treturn work;\n}\n\nstatic int erdma_cm_alloc_work(struct erdma_cep *cep, int num)\n{\n\tstruct erdma_cm_work *work;\n\n\twhile (num--) {\n\t\twork = kmalloc(sizeof(*work), GFP_KERNEL);\n\t\tif (!work) {\n\t\t\tif (!(list_empty(&cep->work_freelist)))\n\t\t\t\terdma_cm_free_work(cep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twork->cep = cep;\n\t\tINIT_LIST_HEAD(&work->list);\n\t\tlist_add(&work->list, &cep->work_freelist);\n\t}\n\n\treturn 0;\n}\n\nstatic int erdma_cm_upcall(struct erdma_cep *cep, enum iw_cm_event_type reason,\n\t\t\t   int status)\n{\n\tstruct iw_cm_event event;\n\tstruct iw_cm_id *cm_id;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.status = status;\n\tevent.event = reason;\n\n\tif (reason == IW_CM_EVENT_CONNECT_REQUEST) {\n\t\tevent.provider_data = cep;\n\t\tcm_id = cep->listen_cep->cm_id;\n\n\t\tevent.ird = cep->dev->attrs.max_ird;\n\t\tevent.ord = cep->dev->attrs.max_ord;\n\t} else {\n\t\tcm_id = cep->cm_id;\n\t}\n\n\tif (reason == IW_CM_EVENT_CONNECT_REQUEST ||\n\t    reason == IW_CM_EVENT_CONNECT_REPLY) {\n\t\tu16 pd_len = be16_to_cpu(cep->mpa.hdr.params.pd_len);\n\n\t\tif (pd_len && cep->mpa.pdata) {\n\t\t\tevent.private_data_len = pd_len;\n\t\t\tevent.private_data = cep->mpa.pdata;\n\t\t}\n\n\t\tgetname_local(cep->sock, &event.local_addr);\n\t\tgetname_peer(cep->sock, &event.remote_addr);\n\t}\n\n\treturn cm_id->event_handler(cm_id, &event);\n}\n\nvoid erdma_qp_cm_drop(struct erdma_qp *qp)\n{\n\tstruct erdma_cep *cep = qp->cep;\n\n\tif (!qp->cep)\n\t\treturn;\n\n\terdma_cep_set_inuse(cep);\n\n\t \n\tif (cep->state == ERDMA_EPSTATE_CLOSED)\n\t\tgoto out;\n\n\tif (cep->cm_id) {\n\t\tswitch (cep->state) {\n\t\tcase ERDMA_EPSTATE_AWAIT_MPAREP:\n\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t-EINVAL);\n\t\t\tbreak;\n\t\tcase ERDMA_EPSTATE_RDMA_MODE:\n\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\t\t\tbreak;\n\t\tcase ERDMA_EPSTATE_IDLE:\n\t\tcase ERDMA_EPSTATE_LISTENING:\n\t\tcase ERDMA_EPSTATE_CONNECTING:\n\t\tcase ERDMA_EPSTATE_AWAIT_MPAREQ:\n\t\tcase ERDMA_EPSTATE_RECVD_MPAREQ:\n\t\tcase ERDMA_EPSTATE_CLOSED:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\tcep->cm_id = NULL;\n\t\terdma_cep_put(cep);\n\t}\n\tcep->state = ERDMA_EPSTATE_CLOSED;\n\n\tif (cep->sock) {\n\t\terdma_socket_disassoc(cep->sock);\n\t\tsock_release(cep->sock);\n\t\tcep->sock = NULL;\n\t}\n\n\tif (cep->qp) {\n\t\tcep->qp = NULL;\n\t\terdma_qp_put(qp);\n\t}\nout:\n\terdma_cep_set_free(cep);\n}\n\nvoid erdma_cep_put(struct erdma_cep *cep)\n{\n\tWARN_ON(kref_read(&cep->ref) < 1);\n\tkref_put(&cep->ref, __erdma_cep_dealloc);\n}\n\nvoid erdma_cep_get(struct erdma_cep *cep)\n{\n\tkref_get(&cep->ref);\n}\n\nstatic int erdma_send_mpareqrep(struct erdma_cep *cep, const void *pdata,\n\t\t\t\tu8 pd_len)\n{\n\tstruct socket *s = cep->sock;\n\tstruct mpa_rr *rr = &cep->mpa.hdr;\n\tstruct kvec iov[3];\n\tstruct msghdr msg;\n\tint iovec_num = 0;\n\tint ret;\n\tint mpa_len;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\trr->params.pd_len = cpu_to_be16(pd_len);\n\n\tiov[iovec_num].iov_base = rr;\n\tiov[iovec_num].iov_len = sizeof(*rr);\n\tiovec_num++;\n\tmpa_len = sizeof(*rr);\n\n\tiov[iovec_num].iov_base = &cep->mpa.ext_data;\n\tiov[iovec_num].iov_len = sizeof(cep->mpa.ext_data);\n\tiovec_num++;\n\tmpa_len += sizeof(cep->mpa.ext_data);\n\n\tif (pd_len) {\n\t\tiov[iovec_num].iov_base = (char *)pdata;\n\t\tiov[iovec_num].iov_len = pd_len;\n\t\tmpa_len += pd_len;\n\t\tiovec_num++;\n\t}\n\n\tret = kernel_sendmsg(s, &msg, iov, iovec_num, mpa_len);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic inline int ksock_recv(struct socket *sock, char *buf, size_t size,\n\t\t\t     int flags)\n{\n\tstruct kvec iov = { buf, size };\n\tstruct msghdr msg = { .msg_name = NULL, .msg_flags = flags };\n\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}\n\nstatic int __recv_mpa_hdr(struct erdma_cep *cep, int hdr_rcvd, char *hdr,\n\t\t\t  int hdr_size, int *rcvd_out)\n{\n\tstruct socket *s = cep->sock;\n\tint rcvd;\n\n\t*rcvd_out = 0;\n\tif (hdr_rcvd < hdr_size) {\n\t\trcvd = ksock_recv(s, hdr + hdr_rcvd, hdr_size - hdr_rcvd,\n\t\t\t\t  MSG_DONTWAIT);\n\t\tif (rcvd == -EAGAIN)\n\t\t\treturn -EAGAIN;\n\n\t\tif (rcvd <= 0)\n\t\t\treturn -ECONNABORTED;\n\n\t\thdr_rcvd += rcvd;\n\t\t*rcvd_out = rcvd;\n\n\t\tif (hdr_rcvd < hdr_size)\n\t\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic void __mpa_rr_set_revision(__be16 *bits, u8 rev)\n{\n\t*bits = (*bits & ~MPA_RR_MASK_REVISION) |\n\t\t(cpu_to_be16(rev) & MPA_RR_MASK_REVISION);\n}\n\nstatic u8 __mpa_rr_revision(__be16 mpa_rr_bits)\n{\n\t__be16 rev = mpa_rr_bits & MPA_RR_MASK_REVISION;\n\n\treturn (u8)be16_to_cpu(rev);\n}\n\nstatic void __mpa_ext_set_cc(__be32 *bits, u32 cc)\n{\n\t*bits = (*bits & ~MPA_EXT_FLAG_CC) |\n\t\t(cpu_to_be32(cc) & MPA_EXT_FLAG_CC);\n}\n\nstatic u8 __mpa_ext_cc(__be32 mpa_ext_bits)\n{\n\t__be32 cc = mpa_ext_bits & MPA_EXT_FLAG_CC;\n\n\treturn (u8)be32_to_cpu(cc);\n}\n\n \nstatic int erdma_recv_mpa_rr(struct erdma_cep *cep)\n{\n\tstruct mpa_rr *hdr = &cep->mpa.hdr;\n\tstruct socket *s = cep->sock;\n\tu16 pd_len;\n\tint rcvd, to_rcv, ret, pd_rcvd;\n\n\tif (cep->mpa.bytes_rcvd < sizeof(struct mpa_rr)) {\n\t\tret = __recv_mpa_hdr(cep, cep->mpa.bytes_rcvd,\n\t\t\t\t     (char *)&cep->mpa.hdr,\n\t\t\t\t     sizeof(struct mpa_rr), &rcvd);\n\t\tcep->mpa.bytes_rcvd += rcvd;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (be16_to_cpu(hdr->params.pd_len) > MPA_MAX_PRIVDATA ||\n\t    __mpa_rr_revision(hdr->params.bits) != MPA_REVISION_EXT_1)\n\t\treturn -EPROTO;\n\n\tif (cep->mpa.bytes_rcvd - sizeof(struct mpa_rr) <\n\t    sizeof(struct erdma_mpa_ext)) {\n\t\tret = __recv_mpa_hdr(\n\t\t\tcep, cep->mpa.bytes_rcvd - sizeof(struct mpa_rr),\n\t\t\t(char *)&cep->mpa.ext_data,\n\t\t\tsizeof(struct erdma_mpa_ext), &rcvd);\n\t\tcep->mpa.bytes_rcvd += rcvd;\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tpd_len = be16_to_cpu(hdr->params.pd_len);\n\tpd_rcvd = cep->mpa.bytes_rcvd - sizeof(struct mpa_rr) -\n\t\t  sizeof(struct erdma_mpa_ext);\n\tto_rcv = pd_len - pd_rcvd;\n\n\tif (!to_rcv) {\n\t\t \n\t\tu32 word;\n\n\t\tret = __recv_mpa_hdr(cep, 0, (char *)&word, sizeof(word),\n\t\t\t\t     &rcvd);\n\t\tif (ret == -EAGAIN && rcvd == 0)\n\t\t\treturn 0;\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (!cep->mpa.pdata) {\n\t\tcep->mpa.pdata = kmalloc(pd_len + 4, GFP_KERNEL);\n\t\tif (!cep->mpa.pdata)\n\t\t\treturn -ENOMEM;\n\t}\n\n\trcvd = ksock_recv(s, cep->mpa.pdata + pd_rcvd, to_rcv + 4,\n\t\t\t  MSG_DONTWAIT);\n\tif (rcvd < 0)\n\t\treturn rcvd;\n\n\tif (rcvd > to_rcv)\n\t\treturn -EPROTO;\n\n\tcep->mpa.bytes_rcvd += rcvd;\n\n\tif (to_rcv == rcvd)\n\t\treturn 0;\n\n\treturn -EAGAIN;\n}\n\n \nstatic int erdma_proc_mpareq(struct erdma_cep *cep)\n{\n\tstruct mpa_rr *req;\n\tint ret;\n\n\tret = erdma_recv_mpa_rr(cep);\n\tif (ret)\n\t\treturn ret;\n\n\treq = &cep->mpa.hdr;\n\n\tif (memcmp(req->key, MPA_KEY_REQ, MPA_KEY_SIZE))\n\t\treturn -EPROTO;\n\n\tmemcpy(req->key, MPA_KEY_REP, MPA_KEY_SIZE);\n\n\t \n\tif (req->params.bits & MPA_RR_FLAG_MARKERS ||\n\t    req->params.bits & MPA_RR_FLAG_CRC)\n\t\tgoto reject_conn;\n\n\tcep->state = ERDMA_EPSTATE_RECVD_MPAREQ;\n\n\t \n\terdma_cep_get(cep);\n\tret = erdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REQUEST, 0);\n\tif (ret)\n\t\terdma_cep_put(cep);\n\n\treturn ret;\n\nreject_conn:\n\treq->params.bits &= ~MPA_RR_FLAG_MARKERS;\n\treq->params.bits |= MPA_RR_FLAG_REJECT;\n\treq->params.bits &= ~MPA_RR_FLAG_CRC;\n\n\tkfree(cep->mpa.pdata);\n\tcep->mpa.pdata = NULL;\n\terdma_send_mpareqrep(cep, NULL, 0);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int erdma_proc_mpareply(struct erdma_cep *cep)\n{\n\tstruct erdma_qp_attrs qp_attrs;\n\tstruct erdma_qp *qp = cep->qp;\n\tstruct mpa_rr *rep;\n\tint ret;\n\n\tret = erdma_recv_mpa_rr(cep);\n\tif (ret)\n\t\tgoto out_err;\n\n\terdma_cancel_mpatimer(cep);\n\n\trep = &cep->mpa.hdr;\n\n\tif (memcmp(rep->key, MPA_KEY_REP, MPA_KEY_SIZE)) {\n\t\tret = -EPROTO;\n\t\tgoto out_err;\n\t}\n\n\tif (rep->params.bits & MPA_RR_FLAG_REJECT) {\n\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -ECONNRESET);\n\t\treturn -ECONNRESET;\n\t}\n\n\t \n\tif ((rep->params.bits & MPA_RR_FLAG_MARKERS) ||\n\t    (rep->params.bits & MPA_RR_FLAG_CRC)) {\n\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -ECONNREFUSED);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&qp_attrs, 0, sizeof(qp_attrs));\n\tqp_attrs.irq_size = cep->ird;\n\tqp_attrs.orq_size = cep->ord;\n\tqp_attrs.state = ERDMA_QP_STATE_RTS;\n\n\tdown_write(&qp->state_lock);\n\tif (qp->attrs.state > ERDMA_QP_STATE_RTR) {\n\t\tret = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto out_err;\n\t}\n\n\tqp->attrs.qp_type = ERDMA_QP_ACTIVE;\n\tif (__mpa_ext_cc(cep->mpa.ext_data.bits) != qp->attrs.cc)\n\t\tqp->attrs.cc = COMPROMISE_CC;\n\n\tret = erdma_modify_qp_internal(qp, &qp_attrs,\n\t\t\t\t       ERDMA_QP_ATTR_STATE |\n\t\t\t\t       ERDMA_QP_ATTR_LLP_HANDLE |\n\t\t\t\t       ERDMA_QP_ATTR_MPA);\n\n\tup_write(&qp->state_lock);\n\n\tif (!ret) {\n\t\tret = erdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, 0);\n\t\tif (!ret)\n\t\t\tcep->state = ERDMA_EPSTATE_RDMA_MODE;\n\n\t\treturn 0;\n\t}\n\nout_err:\n\tif (ret != -EAGAIN)\n\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -EINVAL);\n\n\treturn ret;\n}\n\nstatic void erdma_accept_newconn(struct erdma_cep *cep)\n{\n\tstruct socket *s = cep->sock;\n\tstruct socket *new_s = NULL;\n\tstruct erdma_cep *new_cep = NULL;\n\tint ret = 0;\n\n\tif (cep->state != ERDMA_EPSTATE_LISTENING)\n\t\tgoto error;\n\n\tnew_cep = erdma_cep_alloc(cep->dev);\n\tif (!new_cep)\n\t\tgoto error;\n\n\t \n\tif (erdma_cm_alloc_work(new_cep, 4) != 0)\n\t\tgoto error;\n\n\t \n\tnew_cep->sk_state_change = cep->sk_state_change;\n\tnew_cep->sk_data_ready = cep->sk_data_ready;\n\tnew_cep->sk_error_report = cep->sk_error_report;\n\n\tret = kernel_accept(s, &new_s, O_NONBLOCK);\n\tif (ret != 0)\n\t\tgoto error;\n\n\tnew_cep->sock = new_s;\n\terdma_cep_get(new_cep);\n\tnew_s->sk->sk_user_data = new_cep;\n\n\ttcp_sock_set_nodelay(new_s->sk);\n\tnew_cep->state = ERDMA_EPSTATE_AWAIT_MPAREQ;\n\n\tret = erdma_cm_queue_work(new_cep, ERDMA_CM_WORK_MPATIMEOUT);\n\tif (ret)\n\t\tgoto error;\n\n\tnew_cep->listen_cep = cep;\n\terdma_cep_get(cep);\n\n\tif (atomic_read(&new_s->sk->sk_rmem_alloc)) {\n\t\t \n\t\terdma_cep_set_inuse(new_cep);\n\t\tret = erdma_proc_mpareq(new_cep);\n\t\tif (ret != -EAGAIN) {\n\t\t\terdma_cep_put(cep);\n\t\t\tnew_cep->listen_cep = NULL;\n\t\t\tif (ret) {\n\t\t\t\terdma_cep_set_free(new_cep);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\terdma_cep_set_free(new_cep);\n\t}\n\treturn;\n\nerror:\n\tif (new_cep) {\n\t\tnew_cep->state = ERDMA_EPSTATE_CLOSED;\n\t\terdma_cancel_mpatimer(new_cep);\n\n\t\terdma_cep_put(new_cep);\n\t\tnew_cep->sock = NULL;\n\t}\n\n\tif (new_s) {\n\t\terdma_socket_disassoc(new_s);\n\t\tsock_release(new_s);\n\t}\n}\n\nstatic int erdma_newconn_connected(struct erdma_cep *cep)\n{\n\tint ret = 0;\n\n\tcep->mpa.hdr.params.bits = 0;\n\t__mpa_rr_set_revision(&cep->mpa.hdr.params.bits, MPA_REVISION_EXT_1);\n\n\tmemcpy(cep->mpa.hdr.key, MPA_KEY_REQ, MPA_KEY_SIZE);\n\tcep->mpa.ext_data.cookie = cpu_to_be32(cep->qp->attrs.cookie);\n\t__mpa_ext_set_cc(&cep->mpa.ext_data.bits, cep->qp->attrs.cc);\n\n\tret = erdma_send_mpareqrep(cep, cep->private_data, cep->pd_len);\n\tcep->state = ERDMA_EPSTATE_AWAIT_MPAREP;\n\tcep->mpa.hdr.params.pd_len = 0;\n\n\tif (ret >= 0)\n\t\tret = erdma_cm_queue_work(cep, ERDMA_CM_WORK_MPATIMEOUT);\n\n\treturn ret;\n}\n\nstatic void erdma_cm_work_handler(struct work_struct *w)\n{\n\tstruct erdma_cm_work *work;\n\tstruct erdma_cep *cep;\n\tint release_cep = 0, ret = 0;\n\n\twork = container_of(w, struct erdma_cm_work, work.work);\n\tcep = work->cep;\n\n\terdma_cep_set_inuse(cep);\n\n\tswitch (work->type) {\n\tcase ERDMA_CM_WORK_CONNECTED:\n\t\terdma_cancel_mpatimer(cep);\n\t\tif (cep->state == ERDMA_EPSTATE_CONNECTING) {\n\t\t\tret = erdma_newconn_connected(cep);\n\t\t\tif (ret) {\n\t\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t\t-EIO);\n\t\t\t\trelease_cep = 1;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ERDMA_CM_WORK_CONNECTTIMEOUT:\n\t\tif (cep->state == ERDMA_EPSTATE_CONNECTING) {\n\t\t\tcep->mpa_timer = NULL;\n\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t-ETIMEDOUT);\n\t\t\trelease_cep = 1;\n\t\t}\n\t\tbreak;\n\tcase ERDMA_CM_WORK_ACCEPT:\n\t\terdma_accept_newconn(cep);\n\t\tbreak;\n\tcase ERDMA_CM_WORK_READ_MPAHDR:\n\t\tif (cep->state == ERDMA_EPSTATE_AWAIT_MPAREQ) {\n\t\t\tif (cep->listen_cep) {\n\t\t\t\terdma_cep_set_inuse(cep->listen_cep);\n\n\t\t\t\tif (cep->listen_cep->state ==\n\t\t\t\t    ERDMA_EPSTATE_LISTENING)\n\t\t\t\t\tret = erdma_proc_mpareq(cep);\n\t\t\t\telse\n\t\t\t\t\tret = -EFAULT;\n\n\t\t\t\terdma_cep_set_free(cep->listen_cep);\n\n\t\t\t\tif (ret != -EAGAIN) {\n\t\t\t\t\terdma_cep_put(cep->listen_cep);\n\t\t\t\t\tcep->listen_cep = NULL;\n\t\t\t\t\tif (ret)\n\t\t\t\t\t\terdma_cep_put(cep);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cep->state == ERDMA_EPSTATE_AWAIT_MPAREP) {\n\t\t\tret = erdma_proc_mpareply(cep);\n\t\t}\n\n\t\tif (ret && ret != -EAGAIN)\n\t\t\trelease_cep = 1;\n\t\tbreak;\n\tcase ERDMA_CM_WORK_CLOSE_LLP:\n\t\tif (cep->cm_id)\n\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\t\trelease_cep = 1;\n\t\tbreak;\n\tcase ERDMA_CM_WORK_PEER_CLOSE:\n\t\tif (cep->cm_id) {\n\t\t\tif (cep->state == ERDMA_EPSTATE_CONNECTING ||\n\t\t\t    cep->state == ERDMA_EPSTATE_AWAIT_MPAREP) {\n\t\t\t\t \n\t\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t\t-ECONNRESET);\n\t\t\t} else if (cep->state == ERDMA_EPSTATE_RDMA_MODE) {\n\t\t\t\t \n\t\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_DISCONNECT, 0);\n\t\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\t\t\t}\n\t\t} else if (cep->state == ERDMA_EPSTATE_AWAIT_MPAREQ) {\n\t\t\t \n\t\t\terdma_disassoc_listen_cep(cep);\n\t\t\terdma_cep_put(cep);\n\t\t}\n\t\trelease_cep = 1;\n\t\tbreak;\n\tcase ERDMA_CM_WORK_MPATIMEOUT:\n\t\tcep->mpa_timer = NULL;\n\t\tif (cep->state == ERDMA_EPSTATE_AWAIT_MPAREP) {\n\t\t\t \n\t\t\tcep->mpa.hdr.params.pd_len = 0;\n\n\t\t\tif (cep->cm_id)\n\t\t\t\terdma_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t\t-ETIMEDOUT);\n\t\t\trelease_cep = 1;\n\t\t} else if (cep->state == ERDMA_EPSTATE_AWAIT_MPAREQ) {\n\t\t\t \n\t\t\terdma_disassoc_listen_cep(cep);\n\n\t\t\terdma_cep_put(cep);\n\t\t\trelease_cep = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Undefined CM work type: %d\\n\", work->type);\n\t}\n\n\tif (release_cep) {\n\t\terdma_cancel_mpatimer(cep);\n\t\tcep->state = ERDMA_EPSTATE_CLOSED;\n\t\tif (cep->qp) {\n\t\t\tstruct erdma_qp *qp = cep->qp;\n\t\t\t \n\t\t\terdma_qp_get(qp);\n\t\t\terdma_cep_set_free(cep);\n\n\t\t\terdma_qp_llp_close(qp);\n\t\t\terdma_qp_put(qp);\n\n\t\t\terdma_cep_set_inuse(cep);\n\t\t\tcep->qp = NULL;\n\t\t\terdma_qp_put(qp);\n\t\t}\n\n\t\tif (cep->sock) {\n\t\t\terdma_socket_disassoc(cep->sock);\n\t\t\tsock_release(cep->sock);\n\t\t\tcep->sock = NULL;\n\t\t}\n\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t\tif (cep->state != ERDMA_EPSTATE_LISTENING)\n\t\t\t\terdma_cep_put(cep);\n\t\t}\n\t}\n\terdma_cep_set_free(cep);\n\terdma_put_work(work);\n\terdma_cep_put(cep);\n}\n\nint erdma_cm_queue_work(struct erdma_cep *cep, enum erdma_work_type type)\n{\n\tstruct erdma_cm_work *work = erdma_get_work(cep);\n\tunsigned long delay = 0;\n\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\twork->type = type;\n\twork->cep = cep;\n\n\terdma_cep_get(cep);\n\n\tINIT_DELAYED_WORK(&work->work, erdma_cm_work_handler);\n\n\tif (type == ERDMA_CM_WORK_MPATIMEOUT) {\n\t\tcep->mpa_timer = work;\n\n\t\tif (cep->state == ERDMA_EPSTATE_AWAIT_MPAREP)\n\t\t\tdelay = MPAREP_TIMEOUT;\n\t\telse\n\t\t\tdelay = MPAREQ_TIMEOUT;\n\t} else if (type == ERDMA_CM_WORK_CONNECTTIMEOUT) {\n\t\tcep->mpa_timer = work;\n\n\t\tdelay = CONNECT_TIMEOUT;\n\t}\n\n\tqueue_delayed_work(erdma_cm_wq, &work->work, delay);\n\n\treturn 0;\n}\n\nstatic void erdma_cm_llp_data_ready(struct sock *sk)\n{\n\tstruct erdma_cep *cep;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\n\tcep = sk_to_cep(sk);\n\tif (!cep)\n\t\tgoto out;\n\n\tif (cep->state == ERDMA_EPSTATE_AWAIT_MPAREQ ||\n\t    cep->state == ERDMA_EPSTATE_AWAIT_MPAREP)\n\t\terdma_cm_queue_work(cep, ERDMA_CM_WORK_READ_MPAHDR);\n\nout:\n\tread_unlock(&sk->sk_callback_lock);\n}\n\nstatic void erdma_cm_llp_error_report(struct sock *sk)\n{\n\tstruct erdma_cep *cep = sk_to_cep(sk);\n\n\tif (cep)\n\t\tcep->sk_error_report(sk);\n}\n\nstatic void erdma_cm_llp_state_change(struct sock *sk)\n{\n\tstruct erdma_cep *cep;\n\tvoid (*orig_state_change)(struct sock *sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\n\tcep = sk_to_cep(sk);\n\tif (!cep) {\n\t\tread_unlock(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\torig_state_change = cep->sk_state_change;\n\n\tswitch (sk->sk_state) {\n\tcase TCP_ESTABLISHED:\n\t\tif (cep->state == ERDMA_EPSTATE_CONNECTING)\n\t\t\terdma_cm_queue_work(cep, ERDMA_CM_WORK_CONNECTED);\n\t\telse\n\t\t\terdma_cm_queue_work(cep, ERDMA_CM_WORK_ACCEPT);\n\t\tbreak;\n\tcase TCP_CLOSE:\n\tcase TCP_CLOSE_WAIT:\n\t\tif (cep->state != ERDMA_EPSTATE_LISTENING)\n\t\t\terdma_cm_queue_work(cep, ERDMA_CM_WORK_PEER_CLOSE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tread_unlock(&sk->sk_callback_lock);\n\torig_state_change(sk);\n}\n\nstatic int kernel_bindconnect(struct socket *s, struct sockaddr *laddr,\n\t\t\t      int laddrlen, struct sockaddr *raddr,\n\t\t\t      int raddrlen, int flags)\n{\n\tint ret;\n\n\tsock_set_reuseaddr(s->sk);\n\tret = s->ops->bind(s, laddr, laddrlen);\n\tif (ret)\n\t\treturn ret;\n\tret = s->ops->connect(s, raddr, raddrlen, flags);\n\treturn ret < 0 ? ret : 0;\n}\n\nint erdma_connect(struct iw_cm_id *id, struct iw_cm_conn_param *params)\n{\n\tstruct erdma_dev *dev = to_edev(id->device);\n\tstruct erdma_qp *qp;\n\tstruct erdma_cep *cep = NULL;\n\tstruct socket *s = NULL;\n\tstruct sockaddr *laddr = (struct sockaddr *)&id->m_local_addr;\n\tstruct sockaddr *raddr = (struct sockaddr *)&id->m_remote_addr;\n\tu16 pd_len = params->private_data_len;\n\tint ret;\n\n\tif (pd_len > MPA_MAX_PRIVDATA)\n\t\treturn -EINVAL;\n\n\tif (params->ird > dev->attrs.max_ird ||\n\t    params->ord > dev->attrs.max_ord)\n\t\treturn -EINVAL;\n\n\tif (laddr->sa_family != AF_INET || raddr->sa_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tqp = find_qp_by_qpn(dev, params->qpn);\n\tif (!qp)\n\t\treturn -ENOENT;\n\terdma_qp_get(qp);\n\n\tret = sock_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, &s);\n\tif (ret < 0)\n\t\tgoto error_put_qp;\n\n\tcep = erdma_cep_alloc(dev);\n\tif (!cep) {\n\t\tret = -ENOMEM;\n\t\tgoto error_release_sock;\n\t}\n\n\terdma_cep_set_inuse(cep);\n\n\t \n\terdma_cep_get(cep);\n\tqp->cep = cep;\n\tcep->qp = qp;\n\n\t \n\tid->add_ref(id);\n\tcep->cm_id = id;\n\n\t \n\tret = erdma_cm_alloc_work(cep, 6);\n\tif (ret != 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error_release_cep;\n\t}\n\n\tcep->ird = params->ird;\n\tcep->ord = params->ord;\n\tcep->state = ERDMA_EPSTATE_CONNECTING;\n\n\terdma_cep_socket_assoc(cep, s);\n\n\tif (pd_len) {\n\t\tcep->pd_len = pd_len;\n\t\tcep->private_data = kmalloc(pd_len, GFP_KERNEL);\n\t\tif (!cep->private_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_disassoc;\n\t\t}\n\n\t\tmemcpy(cep->private_data, params->private_data,\n\t\t       params->private_data_len);\n\t}\n\n\tret = kernel_bindconnect(s, laddr, sizeof(*laddr), raddr,\n\t\t\t\t sizeof(*raddr), O_NONBLOCK);\n\tif (ret != -EINPROGRESS && ret != 0) {\n\t\tgoto error_disassoc;\n\t} else if (ret == 0) {\n\t\tret = erdma_cm_queue_work(cep, ERDMA_CM_WORK_CONNECTED);\n\t\tif (ret)\n\t\t\tgoto error_disassoc;\n\t} else {\n\t\tret = erdma_cm_queue_work(cep, ERDMA_CM_WORK_CONNECTTIMEOUT);\n\t\tif (ret)\n\t\t\tgoto error_disassoc;\n\t}\n\n\terdma_cep_set_free(cep);\n\treturn 0;\n\nerror_disassoc:\n\tkfree(cep->private_data);\n\tcep->private_data = NULL;\n\tcep->pd_len = 0;\n\n\terdma_socket_disassoc(s);\n\nerror_release_cep:\n\t \n\tcep->cm_id = NULL;\n\tid->rem_ref(id);\n\n\t \n\tqp->cep = NULL;\n\terdma_cep_put(cep);\n\tcep->qp = NULL;\n\n\tcep->state = ERDMA_EPSTATE_CLOSED;\n\n\terdma_cep_set_free(cep);\n\n\t \n\terdma_cep_put(cep);\n\nerror_release_sock:\n\tif (s)\n\t\tsock_release(s);\nerror_put_qp:\n\terdma_qp_put(qp);\n\n\treturn ret;\n}\n\nint erdma_accept(struct iw_cm_id *id, struct iw_cm_conn_param *params)\n{\n\tstruct erdma_dev *dev = to_edev(id->device);\n\tstruct erdma_cep *cep = (struct erdma_cep *)id->provider_data;\n\tstruct erdma_qp *qp;\n\tstruct erdma_qp_attrs qp_attrs;\n\tint ret;\n\n\terdma_cep_set_inuse(cep);\n\terdma_cep_put(cep);\n\n\t \n\tif (cep->mpa.hdr.params.pd_len) {\n\t\tcep->mpa.hdr.params.pd_len = 0;\n\t\tkfree(cep->mpa.pdata);\n\t\tcep->mpa.pdata = NULL;\n\t}\n\terdma_cancel_mpatimer(cep);\n\n\tif (cep->state != ERDMA_EPSTATE_RECVD_MPAREQ) {\n\t\terdma_cep_set_free(cep);\n\t\terdma_cep_put(cep);\n\n\t\treturn -ECONNRESET;\n\t}\n\n\tqp = find_qp_by_qpn(dev, params->qpn);\n\tif (!qp)\n\t\treturn -ENOENT;\n\terdma_qp_get(qp);\n\n\tdown_write(&qp->state_lock);\n\tif (qp->attrs.state > ERDMA_QP_STATE_RTR) {\n\t\tret = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\n\tif (params->ord > dev->attrs.max_ord ||\n\t    params->ird > dev->attrs.max_ord) {\n\t\tret = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\n\tif (params->private_data_len > MPA_MAX_PRIVDATA) {\n\t\tret = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\n\tcep->ird = params->ird;\n\tcep->ord = params->ord;\n\n\tcep->cm_id = id;\n\tid->add_ref(id);\n\n\tmemset(&qp_attrs, 0, sizeof(qp_attrs));\n\tqp_attrs.orq_size = params->ord;\n\tqp_attrs.irq_size = params->ird;\n\n\tqp_attrs.state = ERDMA_QP_STATE_RTS;\n\n\t \n\terdma_cep_get(cep);\n\tqp->cep = cep;\n\tcep->qp = qp;\n\n\tcep->state = ERDMA_EPSTATE_RDMA_MODE;\n\n\tqp->attrs.qp_type = ERDMA_QP_PASSIVE;\n\tqp->attrs.pd_len = params->private_data_len;\n\n\tif (qp->attrs.cc != __mpa_ext_cc(cep->mpa.ext_data.bits))\n\t\tqp->attrs.cc = COMPROMISE_CC;\n\n\t \n\tret = erdma_modify_qp_internal(qp, &qp_attrs,\n\t\t\t\t       ERDMA_QP_ATTR_STATE |\n\t\t\t\t       ERDMA_QP_ATTR_ORD |\n\t\t\t\t       ERDMA_QP_ATTR_LLP_HANDLE |\n\t\t\t\t       ERDMA_QP_ATTR_IRD |\n\t\t\t\t       ERDMA_QP_ATTR_MPA);\n\tup_write(&qp->state_lock);\n\n\tif (ret)\n\t\tgoto error;\n\n\tcep->mpa.ext_data.bits = 0;\n\t__mpa_ext_set_cc(&cep->mpa.ext_data.bits, qp->attrs.cc);\n\tcep->mpa.ext_data.cookie = cpu_to_be32(cep->qp->attrs.cookie);\n\n\tret = erdma_send_mpareqrep(cep, params->private_data,\n\t\t\t\t   params->private_data_len);\n\tif (!ret) {\n\t\tret = erdma_cm_upcall(cep, IW_CM_EVENT_ESTABLISHED, 0);\n\t\tif (ret)\n\t\t\tgoto error;\n\n\t\terdma_cep_set_free(cep);\n\n\t\treturn 0;\n\t}\n\nerror:\n\terdma_socket_disassoc(cep->sock);\n\tsock_release(cep->sock);\n\tcep->sock = NULL;\n\n\tcep->state = ERDMA_EPSTATE_CLOSED;\n\n\tif (cep->cm_id) {\n\t\tcep->cm_id->rem_ref(id);\n\t\tcep->cm_id = NULL;\n\t}\n\n\tif (qp->cep) {\n\t\terdma_cep_put(cep);\n\t\tqp->cep = NULL;\n\t}\n\n\tcep->qp = NULL;\n\terdma_qp_put(qp);\n\n\terdma_cep_set_free(cep);\n\terdma_cep_put(cep);\n\n\treturn ret;\n}\n\nint erdma_reject(struct iw_cm_id *id, const void *pdata, u8 plen)\n{\n\tstruct erdma_cep *cep = (struct erdma_cep *)id->provider_data;\n\n\terdma_cep_set_inuse(cep);\n\terdma_cep_put(cep);\n\n\terdma_cancel_mpatimer(cep);\n\n\tif (cep->state != ERDMA_EPSTATE_RECVD_MPAREQ) {\n\t\terdma_cep_set_free(cep);\n\t\terdma_cep_put(cep);\n\n\t\treturn -ECONNRESET;\n\t}\n\n\tif (__mpa_rr_revision(cep->mpa.hdr.params.bits) == MPA_REVISION_EXT_1) {\n\t\tcep->mpa.hdr.params.bits |= MPA_RR_FLAG_REJECT;  \n\t\terdma_send_mpareqrep(cep, pdata, plen);\n\t}\n\n\terdma_socket_disassoc(cep->sock);\n\tsock_release(cep->sock);\n\tcep->sock = NULL;\n\n\tcep->state = ERDMA_EPSTATE_CLOSED;\n\n\terdma_cep_set_free(cep);\n\terdma_cep_put(cep);\n\n\treturn 0;\n}\n\nint erdma_create_listen(struct iw_cm_id *id, int backlog)\n{\n\tstruct socket *s;\n\tstruct erdma_cep *cep = NULL;\n\tint ret = 0;\n\tstruct erdma_dev *dev = to_edev(id->device);\n\tint addr_family = id->local_addr.ss_family;\n\tstruct sockaddr_in *laddr = &to_sockaddr_in(id->local_addr);\n\n\tif (addr_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\tret = sock_create(addr_family, SOCK_STREAM, IPPROTO_TCP, &s);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsock_set_reuseaddr(s->sk);\n\n\t \n\tif (ipv4_is_zeronet(laddr->sin_addr.s_addr))\n\t\ts->sk->sk_bound_dev_if = dev->netdev->ifindex;\n\n\tret = s->ops->bind(s, (struct sockaddr *)laddr,\n\t\t\t   sizeof(struct sockaddr_in));\n\tif (ret)\n\t\tgoto error;\n\n\tcep = erdma_cep_alloc(dev);\n\tif (!cep) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\terdma_cep_socket_assoc(cep, s);\n\n\tret = erdma_cm_alloc_work(cep, backlog);\n\tif (ret)\n\t\tgoto error;\n\n\tret = s->ops->listen(s, backlog);\n\tif (ret)\n\t\tgoto error;\n\n\tcep->cm_id = id;\n\tid->add_ref(id);\n\n\tif (!id->provider_data) {\n\t\tid->provider_data =\n\t\t\tkmalloc(sizeof(struct list_head), GFP_KERNEL);\n\t\tif (!id->provider_data) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tINIT_LIST_HEAD((struct list_head *)id->provider_data);\n\t}\n\n\tlist_add_tail(&cep->listenq, (struct list_head *)id->provider_data);\n\tcep->state = ERDMA_EPSTATE_LISTENING;\n\n\treturn 0;\n\nerror:\n\tif (cep) {\n\t\terdma_cep_set_inuse(cep);\n\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t}\n\t\tcep->sock = NULL;\n\t\terdma_socket_disassoc(s);\n\t\tcep->state = ERDMA_EPSTATE_CLOSED;\n\n\t\terdma_cep_set_free(cep);\n\t\terdma_cep_put(cep);\n\t}\n\tsock_release(s);\n\n\treturn ret;\n}\n\nstatic void erdma_drop_listeners(struct iw_cm_id *id)\n{\n\tstruct list_head *p, *tmp;\n\t \n\tlist_for_each_safe(p, tmp, (struct list_head *)id->provider_data) {\n\t\tstruct erdma_cep *cep =\n\t\t\tlist_entry(p, struct erdma_cep, listenq);\n\n\t\tlist_del(p);\n\n\t\terdma_cep_set_inuse(cep);\n\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t}\n\t\tif (cep->sock) {\n\t\t\terdma_socket_disassoc(cep->sock);\n\t\t\tsock_release(cep->sock);\n\t\t\tcep->sock = NULL;\n\t\t}\n\t\tcep->state = ERDMA_EPSTATE_CLOSED;\n\t\terdma_cep_set_free(cep);\n\t\terdma_cep_put(cep);\n\t}\n}\n\nint erdma_destroy_listen(struct iw_cm_id *id)\n{\n\tif (!id->provider_data)\n\t\treturn 0;\n\n\terdma_drop_listeners(id);\n\tkfree(id->provider_data);\n\tid->provider_data = NULL;\n\n\treturn 0;\n}\n\nint erdma_cm_init(void)\n{\n\terdma_cm_wq = create_singlethread_workqueue(\"erdma_cm_wq\");\n\tif (!erdma_cm_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid erdma_cm_exit(void)\n{\n\tif (erdma_cm_wq)\n\t\tdestroy_workqueue(erdma_cm_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}