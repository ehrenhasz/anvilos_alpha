{
  "module_name": "erdma_cmdq.c",
  "hash_id": "07b9ab9c8b82c0931bcac429584103ab6b3521d5a43bb0bd7b060544cbb3701a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma_cmdq.c",
  "human_readable_source": "\n\n \n \n \n\n#include \"erdma.h\"\n\nstatic void arm_cmdq_cq(struct erdma_cmdq *cmdq)\n{\n\tstruct erdma_dev *dev = container_of(cmdq, struct erdma_dev, cmdq);\n\tu64 db_data = FIELD_PREP(ERDMA_CQDB_CI_MASK, cmdq->cq.ci) |\n\t\t      FIELD_PREP(ERDMA_CQDB_ARM_MASK, 1) |\n\t\t      FIELD_PREP(ERDMA_CQDB_CMDSN_MASK, cmdq->cq.cmdsn) |\n\t\t      FIELD_PREP(ERDMA_CQDB_IDX_MASK, cmdq->cq.cmdsn);\n\n\t*cmdq->cq.db_record = db_data;\n\twriteq(db_data, dev->func_bar + ERDMA_CMDQ_CQDB_REG);\n\n\tatomic64_inc(&cmdq->cq.armed_num);\n}\n\nstatic void kick_cmdq_db(struct erdma_cmdq *cmdq)\n{\n\tstruct erdma_dev *dev = container_of(cmdq, struct erdma_dev, cmdq);\n\tu64 db_data = FIELD_PREP(ERDMA_CMD_HDR_WQEBB_INDEX_MASK, cmdq->sq.pi);\n\n\t*cmdq->sq.db_record = db_data;\n\twriteq(db_data, dev->func_bar + ERDMA_CMDQ_SQDB_REG);\n}\n\nstatic struct erdma_comp_wait *get_comp_wait(struct erdma_cmdq *cmdq)\n{\n\tint comp_idx;\n\n\tspin_lock(&cmdq->lock);\n\tcomp_idx = find_first_zero_bit(cmdq->comp_wait_bitmap,\n\t\t\t\t       cmdq->max_outstandings);\n\tif (comp_idx == cmdq->max_outstandings) {\n\t\tspin_unlock(&cmdq->lock);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t__set_bit(comp_idx, cmdq->comp_wait_bitmap);\n\tspin_unlock(&cmdq->lock);\n\n\treturn &cmdq->wait_pool[comp_idx];\n}\n\nstatic void put_comp_wait(struct erdma_cmdq *cmdq,\n\t\t\t  struct erdma_comp_wait *comp_wait)\n{\n\tint used;\n\n\tcmdq->wait_pool[comp_wait->ctx_id].cmd_status = ERDMA_CMD_STATUS_INIT;\n\tspin_lock(&cmdq->lock);\n\tused = __test_and_clear_bit(comp_wait->ctx_id, cmdq->comp_wait_bitmap);\n\tspin_unlock(&cmdq->lock);\n\n\tWARN_ON(!used);\n}\n\nstatic int erdma_cmdq_wait_res_init(struct erdma_dev *dev,\n\t\t\t\t    struct erdma_cmdq *cmdq)\n{\n\tint i;\n\n\tcmdq->wait_pool =\n\t\tdevm_kcalloc(&dev->pdev->dev, cmdq->max_outstandings,\n\t\t\t     sizeof(struct erdma_comp_wait), GFP_KERNEL);\n\tif (!cmdq->wait_pool)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&cmdq->lock);\n\tcmdq->comp_wait_bitmap = devm_bitmap_zalloc(\n\t\t&dev->pdev->dev, cmdq->max_outstandings, GFP_KERNEL);\n\tif (!cmdq->comp_wait_bitmap)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cmdq->max_outstandings; i++) {\n\t\tinit_completion(&cmdq->wait_pool[i].wait_event);\n\t\tcmdq->wait_pool[i].ctx_id = i;\n\t}\n\n\treturn 0;\n}\n\nstatic int erdma_cmdq_sq_init(struct erdma_dev *dev)\n{\n\tstruct erdma_cmdq *cmdq = &dev->cmdq;\n\tstruct erdma_cmdq_sq *sq = &cmdq->sq;\n\tu32 buf_size;\n\n\tsq->wqebb_cnt = SQEBB_COUNT(ERDMA_CMDQ_SQE_SIZE);\n\tsq->depth = cmdq->max_outstandings * sq->wqebb_cnt;\n\n\tbuf_size = sq->depth << SQEBB_SHIFT;\n\n\tsq->qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size),\n\t\t\t\t   &sq->qbuf_dma_addr, GFP_KERNEL);\n\tif (!sq->qbuf)\n\t\treturn -ENOMEM;\n\n\tsq->db_record = (u64 *)(sq->qbuf + buf_size);\n\n\tspin_lock_init(&sq->lock);\n\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_SQ_ADDR_H_REG,\n\t\t\t  upper_32_bits(sq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_SQ_ADDR_L_REG,\n\t\t\t  lower_32_bits(sq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_DEPTH_REG, sq->depth);\n\terdma_reg_write64(dev, ERDMA_CMDQ_SQ_DB_HOST_ADDR_REG,\n\t\t\t  sq->qbuf_dma_addr + buf_size);\n\n\treturn 0;\n}\n\nstatic int erdma_cmdq_cq_init(struct erdma_dev *dev)\n{\n\tstruct erdma_cmdq *cmdq = &dev->cmdq;\n\tstruct erdma_cmdq_cq *cq = &cmdq->cq;\n\tu32 buf_size;\n\n\tcq->depth = cmdq->sq.depth;\n\tbuf_size = cq->depth << CQE_SHIFT;\n\n\tcq->qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size),\n\t\t\t\t   &cq->qbuf_dma_addr, GFP_KERNEL | __GFP_ZERO);\n\tif (!cq->qbuf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&cq->lock);\n\n\tcq->db_record = (u64 *)(cq->qbuf + buf_size);\n\n\tatomic64_set(&cq->armed_num, 0);\n\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_CQ_ADDR_H_REG,\n\t\t\t  upper_32_bits(cq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_CQ_ADDR_L_REG,\n\t\t\t  lower_32_bits(cq->qbuf_dma_addr));\n\terdma_reg_write64(dev, ERDMA_CMDQ_CQ_DB_HOST_ADDR_REG,\n\t\t\t  cq->qbuf_dma_addr + buf_size);\n\n\treturn 0;\n}\n\nstatic int erdma_cmdq_eq_init(struct erdma_dev *dev)\n{\n\tstruct erdma_cmdq *cmdq = &dev->cmdq;\n\tstruct erdma_eq *eq = &cmdq->eq;\n\tu32 buf_size;\n\n\teq->depth = cmdq->max_outstandings;\n\tbuf_size = eq->depth << EQE_SHIFT;\n\n\teq->qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size),\n\t\t\t\t   &eq->qbuf_dma_addr, GFP_KERNEL | __GFP_ZERO);\n\tif (!eq->qbuf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&eq->lock);\n\tatomic64_set(&eq->event_num, 0);\n\n\teq->db = dev->func_bar + ERDMA_REGS_CEQ_DB_BASE_REG;\n\teq->db_record = (u64 *)(eq->qbuf + buf_size);\n\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_EQ_ADDR_H_REG,\n\t\t\t  upper_32_bits(eq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_EQ_ADDR_L_REG,\n\t\t\t  lower_32_bits(eq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_CMDQ_EQ_DEPTH_REG, eq->depth);\n\terdma_reg_write64(dev, ERDMA_CMDQ_EQ_DB_HOST_ADDR_REG,\n\t\t\t  eq->qbuf_dma_addr + buf_size);\n\n\treturn 0;\n}\n\nint erdma_cmdq_init(struct erdma_dev *dev)\n{\n\tstruct erdma_cmdq *cmdq = &dev->cmdq;\n\tint err;\n\n\tcmdq->max_outstandings = ERDMA_CMDQ_MAX_OUTSTANDING;\n\tcmdq->use_event = false;\n\n\tsema_init(&cmdq->credits, cmdq->max_outstandings);\n\n\terr = erdma_cmdq_wait_res_init(dev, cmdq);\n\tif (err)\n\t\treturn err;\n\n\terr = erdma_cmdq_sq_init(dev);\n\tif (err)\n\t\treturn err;\n\n\terr = erdma_cmdq_cq_init(dev);\n\tif (err)\n\t\tgoto err_destroy_sq;\n\n\terr = erdma_cmdq_eq_init(dev);\n\tif (err)\n\t\tgoto err_destroy_cq;\n\n\tset_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state);\n\n\treturn 0;\n\nerr_destroy_cq:\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  (cmdq->cq.depth << CQE_SHIFT) +\n\t\t\t\t  ERDMA_EXTRA_BUFFER_SIZE,\n\t\t\t  cmdq->cq.qbuf, cmdq->cq.qbuf_dma_addr);\n\nerr_destroy_sq:\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  (cmdq->sq.depth << SQEBB_SHIFT) +\n\t\t\t\t  ERDMA_EXTRA_BUFFER_SIZE,\n\t\t\t  cmdq->sq.qbuf, cmdq->sq.qbuf_dma_addr);\n\n\treturn err;\n}\n\nvoid erdma_finish_cmdq_init(struct erdma_dev *dev)\n{\n\t \n\tdev->cmdq.use_event = true;\n\tarm_cmdq_cq(&dev->cmdq);\n}\n\nvoid erdma_cmdq_destroy(struct erdma_dev *dev)\n{\n\tstruct erdma_cmdq *cmdq = &dev->cmdq;\n\n\tclear_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state);\n\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  (cmdq->eq.depth << EQE_SHIFT) +\n\t\t\t\t  ERDMA_EXTRA_BUFFER_SIZE,\n\t\t\t  cmdq->eq.qbuf, cmdq->eq.qbuf_dma_addr);\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  (cmdq->sq.depth << SQEBB_SHIFT) +\n\t\t\t\t  ERDMA_EXTRA_BUFFER_SIZE,\n\t\t\t  cmdq->sq.qbuf, cmdq->sq.qbuf_dma_addr);\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  (cmdq->cq.depth << CQE_SHIFT) +\n\t\t\t\t  ERDMA_EXTRA_BUFFER_SIZE,\n\t\t\t  cmdq->cq.qbuf, cmdq->cq.qbuf_dma_addr);\n}\n\nstatic void *get_next_valid_cmdq_cqe(struct erdma_cmdq *cmdq)\n{\n\t__be32 *cqe = get_queue_entry(cmdq->cq.qbuf, cmdq->cq.ci,\n\t\t\t\t      cmdq->cq.depth, CQE_SHIFT);\n\tu32 owner = FIELD_GET(ERDMA_CQE_HDR_OWNER_MASK,\n\t\t\t      be32_to_cpu(READ_ONCE(*cqe)));\n\n\treturn owner ^ !!(cmdq->cq.ci & cmdq->cq.depth) ? cqe : NULL;\n}\n\nstatic void push_cmdq_sqe(struct erdma_cmdq *cmdq, u64 *req, size_t req_len,\n\t\t\t  struct erdma_comp_wait *comp_wait)\n{\n\t__le64 *wqe;\n\tu64 hdr = *req;\n\n\tcomp_wait->cmd_status = ERDMA_CMD_STATUS_ISSUED;\n\treinit_completion(&comp_wait->wait_event);\n\tcomp_wait->sq_pi = cmdq->sq.pi;\n\n\twqe = get_queue_entry(cmdq->sq.qbuf, cmdq->sq.pi, cmdq->sq.depth,\n\t\t\t      SQEBB_SHIFT);\n\tmemcpy(wqe, req, req_len);\n\n\tcmdq->sq.pi += cmdq->sq.wqebb_cnt;\n\thdr |= FIELD_PREP(ERDMA_CMD_HDR_WQEBB_INDEX_MASK, cmdq->sq.pi) |\n\t       FIELD_PREP(ERDMA_CMD_HDR_CONTEXT_COOKIE_MASK,\n\t\t\t  comp_wait->ctx_id) |\n\t       FIELD_PREP(ERDMA_CMD_HDR_WQEBB_CNT_MASK, cmdq->sq.wqebb_cnt - 1);\n\t*wqe = cpu_to_le64(hdr);\n\n\tkick_cmdq_db(cmdq);\n}\n\nstatic int erdma_poll_single_cmd_completion(struct erdma_cmdq *cmdq)\n{\n\tstruct erdma_comp_wait *comp_wait;\n\tu32 hdr0, sqe_idx;\n\t__be32 *cqe;\n\tu16 ctx_id;\n\tu64 *sqe;\n\n\tcqe = get_next_valid_cmdq_cqe(cmdq);\n\tif (!cqe)\n\t\treturn -EAGAIN;\n\n\tcmdq->cq.ci++;\n\n\tdma_rmb();\n\thdr0 = be32_to_cpu(*cqe);\n\tsqe_idx = be32_to_cpu(*(cqe + 1));\n\n\tsqe = get_queue_entry(cmdq->sq.qbuf, sqe_idx, cmdq->sq.depth,\n\t\t\t      SQEBB_SHIFT);\n\tctx_id = FIELD_GET(ERDMA_CMD_HDR_CONTEXT_COOKIE_MASK, *sqe);\n\tcomp_wait = &cmdq->wait_pool[ctx_id];\n\tif (comp_wait->cmd_status != ERDMA_CMD_STATUS_ISSUED)\n\t\treturn -EIO;\n\n\tcomp_wait->cmd_status = ERDMA_CMD_STATUS_FINISHED;\n\tcomp_wait->comp_status = FIELD_GET(ERDMA_CQE_HDR_SYNDROME_MASK, hdr0);\n\tcmdq->sq.ci += cmdq->sq.wqebb_cnt;\n\t \n\tbe32_to_cpu_array(comp_wait->comp_data, cqe + 2, 4);\n\n\tif (cmdq->use_event)\n\t\tcomplete(&comp_wait->wait_event);\n\n\treturn 0;\n}\n\nstatic void erdma_polling_cmd_completions(struct erdma_cmdq *cmdq)\n{\n\tunsigned long flags;\n\tu16 comp_num;\n\n\tspin_lock_irqsave(&cmdq->cq.lock, flags);\n\n\t \n\tfor (comp_num = 0; comp_num < cmdq->max_outstandings; comp_num++)\n\t\tif (erdma_poll_single_cmd_completion(cmdq))\n\t\t\tbreak;\n\n\tif (comp_num && cmdq->use_event)\n\t\tarm_cmdq_cq(cmdq);\n\n\tspin_unlock_irqrestore(&cmdq->cq.lock, flags);\n}\n\nvoid erdma_cmdq_completion_handler(struct erdma_cmdq *cmdq)\n{\n\tint got_event = 0;\n\n\tif (!test_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state) ||\n\t    !cmdq->use_event)\n\t\treturn;\n\n\twhile (get_next_valid_eqe(&cmdq->eq)) {\n\t\tcmdq->eq.ci++;\n\t\tgot_event++;\n\t}\n\n\tif (got_event) {\n\t\tcmdq->cq.cmdsn++;\n\t\terdma_polling_cmd_completions(cmdq);\n\t}\n\n\tnotify_eq(&cmdq->eq);\n}\n\nstatic int erdma_poll_cmd_completion(struct erdma_comp_wait *comp_ctx,\n\t\t\t\t     struct erdma_cmdq *cmdq, u32 timeout)\n{\n\tunsigned long comp_timeout = jiffies + msecs_to_jiffies(timeout);\n\n\twhile (1) {\n\t\terdma_polling_cmd_completions(cmdq);\n\t\tif (comp_ctx->cmd_status != ERDMA_CMD_STATUS_ISSUED)\n\t\t\tbreak;\n\n\t\tif (time_is_before_jiffies(comp_timeout))\n\t\t\treturn -ETIME;\n\n\t\tmsleep(20);\n\t}\n\n\treturn 0;\n}\n\nstatic int erdma_wait_cmd_completion(struct erdma_comp_wait *comp_ctx,\n\t\t\t\t     struct erdma_cmdq *cmdq, u32 timeout)\n{\n\tunsigned long flags = 0;\n\n\twait_for_completion_timeout(&comp_ctx->wait_event,\n\t\t\t\t    msecs_to_jiffies(timeout));\n\n\tif (unlikely(comp_ctx->cmd_status != ERDMA_CMD_STATUS_FINISHED)) {\n\t\tspin_lock_irqsave(&cmdq->cq.lock, flags);\n\t\tcomp_ctx->cmd_status = ERDMA_CMD_STATUS_TIMEOUT;\n\t\tspin_unlock_irqrestore(&cmdq->cq.lock, flags);\n\t\treturn -ETIME;\n\t}\n\n\treturn 0;\n}\n\nvoid erdma_cmdq_build_reqhdr(u64 *hdr, u32 mod, u32 op)\n{\n\t*hdr = FIELD_PREP(ERDMA_CMD_HDR_SUB_MOD_MASK, mod) |\n\t       FIELD_PREP(ERDMA_CMD_HDR_OPCODE_MASK, op);\n}\n\nint erdma_post_cmd_wait(struct erdma_cmdq *cmdq, void *req, u32 req_size,\n\t\t\tu64 *resp0, u64 *resp1)\n{\n\tstruct erdma_comp_wait *comp_wait;\n\tint ret;\n\n\tif (!test_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state))\n\t\treturn -ENODEV;\n\n\tdown(&cmdq->credits);\n\n\tcomp_wait = get_comp_wait(cmdq);\n\tif (IS_ERR(comp_wait)) {\n\t\tclear_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state);\n\t\tset_bit(ERDMA_CMDQ_STATE_CTX_ERR_BIT, &cmdq->state);\n\t\tup(&cmdq->credits);\n\t\treturn PTR_ERR(comp_wait);\n\t}\n\n\tspin_lock(&cmdq->sq.lock);\n\tpush_cmdq_sqe(cmdq, req, req_size, comp_wait);\n\tspin_unlock(&cmdq->sq.lock);\n\n\tif (cmdq->use_event)\n\t\tret = erdma_wait_cmd_completion(comp_wait, cmdq,\n\t\t\t\t\t\tERDMA_CMDQ_TIMEOUT_MS);\n\telse\n\t\tret = erdma_poll_cmd_completion(comp_wait, cmdq,\n\t\t\t\t\t\tERDMA_CMDQ_TIMEOUT_MS);\n\n\tif (ret) {\n\t\tset_bit(ERDMA_CMDQ_STATE_TIMEOUT_BIT, &cmdq->state);\n\t\tclear_bit(ERDMA_CMDQ_STATE_OK_BIT, &cmdq->state);\n\t\tgoto out;\n\t}\n\n\tif (comp_wait->comp_status)\n\t\tret = -EIO;\n\n\tif (resp0 && resp1) {\n\t\t*resp0 = *((u64 *)&comp_wait->comp_data[0]);\n\t\t*resp1 = *((u64 *)&comp_wait->comp_data[2]);\n\t}\n\tput_comp_wait(cmdq, comp_wait);\n\nout:\n\tup(&cmdq->credits);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}