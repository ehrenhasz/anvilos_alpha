{
  "module_name": "erdma.h",
  "hash_id": "fb091256b1658a9bec393ef8cf95ab1c07067c2534a91b3739cfd7f21a28141e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma.h",
  "human_readable_source": " \n\n \n \n \n\n#ifndef __ERDMA_H__\n#define __ERDMA_H__\n\n#include <linux/bitfield.h>\n#include <linux/netdevice.h>\n#include <linux/pci.h>\n#include <linux/xarray.h>\n#include <rdma/ib_verbs.h>\n\n#include \"erdma_hw.h\"\n\n#define DRV_MODULE_NAME \"erdma\"\n#define ERDMA_NODE_DESC \"Elastic RDMA(iWARP) stack\"\n\nstruct erdma_eq {\n\tvoid *qbuf;\n\tdma_addr_t qbuf_dma_addr;\n\n\tspinlock_t lock;\n\n\tu32 depth;\n\n\tu16 ci;\n\tu16 rsvd;\n\n\tatomic64_t event_num;\n\tatomic64_t notify_num;\n\n\tvoid __iomem *db;\n\tu64 *db_record;\n};\n\nstruct erdma_cmdq_sq {\n\tvoid *qbuf;\n\tdma_addr_t qbuf_dma_addr;\n\n\tspinlock_t lock;\n\n\tu32 depth;\n\tu16 ci;\n\tu16 pi;\n\n\tu16 wqebb_cnt;\n\n\tu64 *db_record;\n};\n\nstruct erdma_cmdq_cq {\n\tvoid *qbuf;\n\tdma_addr_t qbuf_dma_addr;\n\n\tspinlock_t lock;\n\n\tu32 depth;\n\tu32 ci;\n\tu32 cmdsn;\n\n\tu64 *db_record;\n\n\tatomic64_t armed_num;\n};\n\nenum {\n\tERDMA_CMD_STATUS_INIT,\n\tERDMA_CMD_STATUS_ISSUED,\n\tERDMA_CMD_STATUS_FINISHED,\n\tERDMA_CMD_STATUS_TIMEOUT\n};\n\nstruct erdma_comp_wait {\n\tstruct completion wait_event;\n\tu32 cmd_status;\n\tu32 ctx_id;\n\tu16 sq_pi;\n\tu8 comp_status;\n\tu8 rsvd;\n\tu32 comp_data[4];\n};\n\nenum {\n\tERDMA_CMDQ_STATE_OK_BIT = 0,\n\tERDMA_CMDQ_STATE_TIMEOUT_BIT = 1,\n\tERDMA_CMDQ_STATE_CTX_ERR_BIT = 2,\n};\n\n#define ERDMA_CMDQ_TIMEOUT_MS 15000\n#define ERDMA_REG_ACCESS_WAIT_MS 20\n#define ERDMA_WAIT_DEV_DONE_CNT 500\n\nstruct erdma_cmdq {\n\tunsigned long *comp_wait_bitmap;\n\tstruct erdma_comp_wait *wait_pool;\n\tspinlock_t lock;\n\n\tbool use_event;\n\n\tstruct erdma_cmdq_sq sq;\n\tstruct erdma_cmdq_cq cq;\n\tstruct erdma_eq eq;\n\n\tunsigned long state;\n\n\tstruct semaphore credits;\n\tu16 max_outstandings;\n};\n\n#define COMPROMISE_CC ERDMA_CC_CUBIC\nenum erdma_cc_alg {\n\tERDMA_CC_NEWRENO = 0,\n\tERDMA_CC_CUBIC,\n\tERDMA_CC_HPCC_RTT,\n\tERDMA_CC_HPCC_ECN,\n\tERDMA_CC_HPCC_INT,\n\tERDMA_CC_METHODS_NUM\n};\n\nstruct erdma_devattr {\n\tu32 fw_version;\n\n\tunsigned char peer_addr[ETH_ALEN];\n\tunsigned long cap_flags;\n\n\tint numa_node;\n\tenum erdma_cc_alg cc;\n\tu32 irq_num;\n\n\tu32 max_qp;\n\tu32 max_send_wr;\n\tu32 max_recv_wr;\n\tu32 max_ord;\n\tu32 max_ird;\n\n\tu32 max_send_sge;\n\tu32 max_recv_sge;\n\tu32 max_sge_rd;\n\tu32 max_cq;\n\tu32 max_cqe;\n\tu64 max_mr_size;\n\tu32 max_mr;\n\tu32 max_pd;\n\tu32 max_mw;\n\tu32 local_dma_key;\n};\n\n#define ERDMA_IRQNAME_SIZE 50\n\nstruct erdma_irq {\n\tchar name[ERDMA_IRQNAME_SIZE];\n\tu32 msix_vector;\n\tcpumask_t affinity_hint_mask;\n};\n\nstruct erdma_eq_cb {\n\tbool ready;\n\tvoid *dev;  \n\tstruct erdma_irq irq;\n\tstruct erdma_eq eq;\n\tstruct tasklet_struct tasklet;\n};\n\nstruct erdma_resource_cb {\n\tunsigned long *bitmap;\n\tspinlock_t lock;\n\tu32 next_alloc_idx;\n\tu32 max_cap;\n};\n\nenum {\n\tERDMA_RES_TYPE_PD = 0,\n\tERDMA_RES_TYPE_STAG_IDX = 1,\n\tERDMA_RES_CNT = 2,\n};\n\n#define ERDMA_EXTRA_BUFFER_SIZE ERDMA_DB_SIZE\n#define WARPPED_BUFSIZE(size) ((size) + ERDMA_EXTRA_BUFFER_SIZE)\n\nstruct erdma_dev {\n\tstruct ib_device ibdev;\n\tstruct net_device *netdev;\n\tstruct pci_dev *pdev;\n\tstruct notifier_block netdev_nb;\n\tstruct workqueue_struct *reflush_wq;\n\n\tresource_size_t func_bar_addr;\n\tresource_size_t func_bar_len;\n\tu8 __iomem *func_bar;\n\n\tstruct erdma_devattr attrs;\n\t \n\tenum ib_port_state state;\n\tu32 mtu;\n\n\t \n\tstruct erdma_irq comm_irq;\n\tstruct erdma_cmdq cmdq;\n\tstruct erdma_eq aeq;\n\tstruct erdma_eq_cb ceqs[ERDMA_NUM_MSIX_VEC - 1];\n\n\tspinlock_t lock;\n\tstruct erdma_resource_cb res_cb[ERDMA_RES_CNT];\n\tstruct xarray qp_xa;\n\tstruct xarray cq_xa;\n\n\tu32 next_alloc_qpn;\n\tu32 next_alloc_cqn;\n\n\tatomic_t num_ctx;\n\tstruct list_head cep_list;\n};\n\nstatic inline void *get_queue_entry(void *qbuf, u32 idx, u32 depth, u32 shift)\n{\n\tidx &= (depth - 1);\n\n\treturn qbuf + (idx << shift);\n}\n\nstatic inline struct erdma_dev *to_edev(struct ib_device *ibdev)\n{\n\treturn container_of(ibdev, struct erdma_dev, ibdev);\n}\n\nstatic inline u32 erdma_reg_read32(struct erdma_dev *dev, u32 reg)\n{\n\treturn readl(dev->func_bar + reg);\n}\n\nstatic inline u64 erdma_reg_read64(struct erdma_dev *dev, u32 reg)\n{\n\treturn readq(dev->func_bar + reg);\n}\n\nstatic inline void erdma_reg_write32(struct erdma_dev *dev, u32 reg, u32 value)\n{\n\twritel(value, dev->func_bar + reg);\n}\n\nstatic inline void erdma_reg_write64(struct erdma_dev *dev, u32 reg, u64 value)\n{\n\twriteq(value, dev->func_bar + reg);\n}\n\nstatic inline u32 erdma_reg_read32_filed(struct erdma_dev *dev, u32 reg,\n\t\t\t\t\t u32 filed_mask)\n{\n\tu32 val = erdma_reg_read32(dev, reg);\n\n\treturn FIELD_GET(filed_mask, val);\n}\n\n#define ERDMA_GET(val, name) FIELD_GET(ERDMA_CMD_##name##_MASK, val)\n\nint erdma_cmdq_init(struct erdma_dev *dev);\nvoid erdma_finish_cmdq_init(struct erdma_dev *dev);\nvoid erdma_cmdq_destroy(struct erdma_dev *dev);\n\nvoid erdma_cmdq_build_reqhdr(u64 *hdr, u32 mod, u32 op);\nint erdma_post_cmd_wait(struct erdma_cmdq *cmdq, void *req, u32 req_size,\n\t\t\tu64 *resp0, u64 *resp1);\nvoid erdma_cmdq_completion_handler(struct erdma_cmdq *cmdq);\n\nint erdma_ceqs_init(struct erdma_dev *dev);\nvoid erdma_ceqs_uninit(struct erdma_dev *dev);\nvoid notify_eq(struct erdma_eq *eq);\nvoid *get_next_valid_eqe(struct erdma_eq *eq);\n\nint erdma_aeq_init(struct erdma_dev *dev);\nvoid erdma_aeq_destroy(struct erdma_dev *dev);\n\nvoid erdma_aeq_event_handler(struct erdma_dev *dev);\nvoid erdma_ceq_completion_handler(struct erdma_eq_cb *ceq_cb);\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}