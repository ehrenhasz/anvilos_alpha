{
  "module_name": "erdma_eq.c",
  "hash_id": "ba5bce6799878f0bd90b6b328f188b29c4352fa9c80dc523d9069213e80b9171",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma_eq.c",
  "human_readable_source": "\n\n \n \n \n\n#include \"erdma_verbs.h\"\n\n#define MAX_POLL_CHUNK_SIZE 16\n\nvoid notify_eq(struct erdma_eq *eq)\n{\n\tu64 db_data = FIELD_PREP(ERDMA_EQDB_CI_MASK, eq->ci) |\n\t\t      FIELD_PREP(ERDMA_EQDB_ARM_MASK, 1);\n\n\t*eq->db_record = db_data;\n\twriteq(db_data, eq->db);\n\n\tatomic64_inc(&eq->notify_num);\n}\n\nvoid *get_next_valid_eqe(struct erdma_eq *eq)\n{\n\tu64 *eqe = get_queue_entry(eq->qbuf, eq->ci, eq->depth, EQE_SHIFT);\n\tu32 owner = FIELD_GET(ERDMA_CEQE_HDR_O_MASK, READ_ONCE(*eqe));\n\n\treturn owner ^ !!(eq->ci & eq->depth) ? eqe : NULL;\n}\n\nvoid erdma_aeq_event_handler(struct erdma_dev *dev)\n{\n\tstruct erdma_aeqe *aeqe;\n\tu32 cqn, qpn;\n\tstruct erdma_qp *qp;\n\tstruct erdma_cq *cq;\n\tstruct ib_event event;\n\tu32 poll_cnt = 0;\n\n\tmemset(&event, 0, sizeof(event));\n\n\twhile (poll_cnt < MAX_POLL_CHUNK_SIZE) {\n\t\taeqe = get_next_valid_eqe(&dev->aeq);\n\t\tif (!aeqe)\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\n\t\tdev->aeq.ci++;\n\t\tatomic64_inc(&dev->aeq.event_num);\n\t\tpoll_cnt++;\n\n\t\tif (FIELD_GET(ERDMA_AEQE_HDR_TYPE_MASK,\n\t\t\t      le32_to_cpu(aeqe->hdr)) == ERDMA_AE_TYPE_CQ_ERR) {\n\t\t\tcqn = le32_to_cpu(aeqe->event_data0);\n\t\t\tcq = find_cq_by_cqn(dev, cqn);\n\t\t\tif (!cq)\n\t\t\t\tcontinue;\n\n\t\t\tevent.device = cq->ibcq.device;\n\t\t\tevent.element.cq = &cq->ibcq;\n\t\t\tevent.event = IB_EVENT_CQ_ERR;\n\t\t\tif (cq->ibcq.event_handler)\n\t\t\t\tcq->ibcq.event_handler(&event,\n\t\t\t\t\t\t       cq->ibcq.cq_context);\n\t\t} else {\n\t\t\tqpn = le32_to_cpu(aeqe->event_data0);\n\t\t\tqp = find_qp_by_qpn(dev, qpn);\n\t\t\tif (!qp)\n\t\t\t\tcontinue;\n\n\t\t\tevent.device = qp->ibqp.device;\n\t\t\tevent.element.qp = &qp->ibqp;\n\t\t\tevent.event = IB_EVENT_QP_FATAL;\n\t\t\tif (qp->ibqp.event_handler)\n\t\t\t\tqp->ibqp.event_handler(&event,\n\t\t\t\t\t\t       qp->ibqp.qp_context);\n\t\t}\n\t}\n\n\tnotify_eq(&dev->aeq);\n}\n\nint erdma_aeq_init(struct erdma_dev *dev)\n{\n\tstruct erdma_eq *eq = &dev->aeq;\n\tu32 buf_size;\n\n\teq->depth = ERDMA_DEFAULT_EQ_DEPTH;\n\tbuf_size = eq->depth << EQE_SHIFT;\n\n\teq->qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size),\n\t\t\t\t   &eq->qbuf_dma_addr, GFP_KERNEL | __GFP_ZERO);\n\tif (!eq->qbuf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&eq->lock);\n\tatomic64_set(&eq->event_num, 0);\n\tatomic64_set(&eq->notify_num, 0);\n\n\teq->db = dev->func_bar + ERDMA_REGS_AEQ_DB_REG;\n\teq->db_record = (u64 *)(eq->qbuf + buf_size);\n\n\terdma_reg_write32(dev, ERDMA_REGS_AEQ_ADDR_H_REG,\n\t\t\t  upper_32_bits(eq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_AEQ_ADDR_L_REG,\n\t\t\t  lower_32_bits(eq->qbuf_dma_addr));\n\terdma_reg_write32(dev, ERDMA_REGS_AEQ_DEPTH_REG, eq->depth);\n\terdma_reg_write64(dev, ERDMA_AEQ_DB_HOST_ADDR_REG,\n\t\t\t  eq->qbuf_dma_addr + buf_size);\n\n\treturn 0;\n}\n\nvoid erdma_aeq_destroy(struct erdma_dev *dev)\n{\n\tstruct erdma_eq *eq = &dev->aeq;\n\n\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t  WARPPED_BUFSIZE(eq->depth << EQE_SHIFT), eq->qbuf,\n\t\t\t  eq->qbuf_dma_addr);\n}\n\nvoid erdma_ceq_completion_handler(struct erdma_eq_cb *ceq_cb)\n{\n\tstruct erdma_dev *dev = ceq_cb->dev;\n\tstruct erdma_cq *cq;\n\tu32 poll_cnt = 0;\n\tu64 *ceqe;\n\tint cqn;\n\n\tif (!ceq_cb->ready)\n\t\treturn;\n\n\twhile (poll_cnt < MAX_POLL_CHUNK_SIZE) {\n\t\tceqe = get_next_valid_eqe(&ceq_cb->eq);\n\t\tif (!ceqe)\n\t\t\tbreak;\n\n\t\tdma_rmb();\n\t\tceq_cb->eq.ci++;\n\t\tpoll_cnt++;\n\t\tcqn = FIELD_GET(ERDMA_CEQE_HDR_CQN_MASK, READ_ONCE(*ceqe));\n\n\t\tcq = find_cq_by_cqn(dev, cqn);\n\t\tif (!cq)\n\t\t\tcontinue;\n\n\t\tif (rdma_is_kernel_res(&cq->ibcq.res))\n\t\t\tcq->kern_cq.cmdsn++;\n\n\t\tif (cq->ibcq.comp_handler)\n\t\t\tcq->ibcq.comp_handler(&cq->ibcq, cq->ibcq.cq_context);\n\t}\n\n\tnotify_eq(&ceq_cb->eq);\n}\n\nstatic irqreturn_t erdma_intr_ceq_handler(int irq, void *data)\n{\n\tstruct erdma_eq_cb *ceq_cb = data;\n\n\ttasklet_schedule(&ceq_cb->tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void erdma_intr_ceq_task(unsigned long data)\n{\n\terdma_ceq_completion_handler((struct erdma_eq_cb *)data);\n}\n\nstatic int erdma_set_ceq_irq(struct erdma_dev *dev, u16 ceqn)\n{\n\tstruct erdma_eq_cb *eqc = &dev->ceqs[ceqn];\n\tint err;\n\n\tsnprintf(eqc->irq.name, ERDMA_IRQNAME_SIZE, \"erdma-ceq%u@pci:%s\", ceqn,\n\t\t pci_name(dev->pdev));\n\teqc->irq.msix_vector = pci_irq_vector(dev->pdev, ceqn + 1);\n\n\ttasklet_init(&dev->ceqs[ceqn].tasklet, erdma_intr_ceq_task,\n\t\t     (unsigned long)&dev->ceqs[ceqn]);\n\n\tcpumask_set_cpu(cpumask_local_spread(ceqn + 1, dev->attrs.numa_node),\n\t\t\t&eqc->irq.affinity_hint_mask);\n\n\terr = request_irq(eqc->irq.msix_vector, erdma_intr_ceq_handler, 0,\n\t\t\t  eqc->irq.name, eqc);\n\tif (err) {\n\t\tdev_err(&dev->pdev->dev, \"failed to request_irq(%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tirq_set_affinity_hint(eqc->irq.msix_vector,\n\t\t\t      &eqc->irq.affinity_hint_mask);\n\n\treturn 0;\n}\n\nstatic void erdma_free_ceq_irq(struct erdma_dev *dev, u16 ceqn)\n{\n\tstruct erdma_eq_cb *eqc = &dev->ceqs[ceqn];\n\n\tirq_set_affinity_hint(eqc->irq.msix_vector, NULL);\n\tfree_irq(eqc->irq.msix_vector, eqc);\n}\n\nstatic int create_eq_cmd(struct erdma_dev *dev, u32 eqn, struct erdma_eq *eq)\n{\n\tstruct erdma_cmdq_create_eq_req req;\n\tdma_addr_t db_info_dma_addr;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_COMMON,\n\t\t\t\tCMDQ_OPCODE_CREATE_EQ);\n\treq.eqn = eqn;\n\treq.depth = ilog2(eq->depth);\n\treq.qbuf_addr = eq->qbuf_dma_addr;\n\treq.qtype = ERDMA_EQ_TYPE_CEQ;\n\t \n\treq.vector_idx = eqn;\n\tdb_info_dma_addr = eq->qbuf_dma_addr + (eq->depth << EQE_SHIFT);\n\treq.db_dma_addr_l = lower_32_bits(db_info_dma_addr);\n\treq.db_dma_addr_h = upper_32_bits(db_info_dma_addr);\n\n\treturn erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n}\n\nstatic int erdma_ceq_init_one(struct erdma_dev *dev, u16 ceqn)\n{\n\tstruct erdma_eq *eq = &dev->ceqs[ceqn].eq;\n\tu32 buf_size = ERDMA_DEFAULT_EQ_DEPTH << EQE_SHIFT;\n\tint ret;\n\n\teq->qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size),\n\t\t\t\t   &eq->qbuf_dma_addr, GFP_KERNEL | __GFP_ZERO);\n\tif (!eq->qbuf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&eq->lock);\n\tatomic64_set(&eq->event_num, 0);\n\tatomic64_set(&eq->notify_num, 0);\n\n\teq->depth = ERDMA_DEFAULT_EQ_DEPTH;\n\teq->db = dev->func_bar + ERDMA_REGS_CEQ_DB_BASE_REG +\n\t\t (ceqn + 1) * ERDMA_DB_SIZE;\n\teq->db_record = (u64 *)(eq->qbuf + buf_size);\n\teq->ci = 0;\n\tdev->ceqs[ceqn].dev = dev;\n\n\t \n\tret = create_eq_cmd(dev, ceqn + 1, eq);\n\tdev->ceqs[ceqn].ready = ret ? false : true;\n\n\treturn ret;\n}\n\nstatic void erdma_ceq_uninit_one(struct erdma_dev *dev, u16 ceqn)\n{\n\tstruct erdma_eq *eq = &dev->ceqs[ceqn].eq;\n\tu32 buf_size = ERDMA_DEFAULT_EQ_DEPTH << EQE_SHIFT;\n\tstruct erdma_cmdq_destroy_eq_req req;\n\tint err;\n\n\tdev->ceqs[ceqn].ready = 0;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_COMMON,\n\t\t\t\tCMDQ_OPCODE_DESTROY_EQ);\n\t \n\treq.eqn = ceqn + 1;\n\treq.qtype = ERDMA_EQ_TYPE_CEQ;\n\treq.vector_idx = ceqn + 1;\n\n\terr = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n\tif (err)\n\t\treturn;\n\n\tdma_free_coherent(&dev->pdev->dev, WARPPED_BUFSIZE(buf_size), eq->qbuf,\n\t\t\t  eq->qbuf_dma_addr);\n}\n\nint erdma_ceqs_init(struct erdma_dev *dev)\n{\n\tu32 i, j;\n\tint err;\n\n\tfor (i = 0; i < dev->attrs.irq_num - 1; i++) {\n\t\terr = erdma_ceq_init_one(dev, i);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\terr = erdma_set_ceq_irq(dev, i);\n\t\tif (err) {\n\t\t\terdma_ceq_uninit_one(dev, i);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\tfor (j = 0; j < i; j++) {\n\t\terdma_free_ceq_irq(dev, j);\n\t\terdma_ceq_uninit_one(dev, j);\n\t}\n\n\treturn err;\n}\n\nvoid erdma_ceqs_uninit(struct erdma_dev *dev)\n{\n\tu32 i;\n\n\tfor (i = 0; i < dev->attrs.irq_num - 1; i++) {\n\t\terdma_free_ceq_irq(dev, i);\n\t\terdma_ceq_uninit_one(dev, i);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}