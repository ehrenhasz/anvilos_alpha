{
  "module_name": "erdma_verbs.c",
  "hash_id": "d684756dbbe6a363da9eb8b994790bbf5923b64055b3cf2f1e115aa08038382e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/erdma/erdma_verbs.c",
  "human_readable_source": "\n\n \n \n \n\n \n \n\n \n\n#include <linux/vmalloc.h>\n#include <net/addrconf.h>\n#include <rdma/erdma-abi.h>\n#include <rdma/ib_umem.h>\n#include <rdma/uverbs_ioctl.h>\n\n#include \"erdma.h\"\n#include \"erdma_cm.h\"\n#include \"erdma_verbs.h\"\n\nstatic void assemble_qbuf_mtt_for_cmd(struct erdma_mem *mem, u32 *cfg,\n\t\t\t\t      u64 *addr0, u64 *addr1)\n{\n\tstruct erdma_mtt *mtt = mem->mtt;\n\n\tif (mem->mtt_nents > ERDMA_MAX_INLINE_MTT_ENTRIES) {\n\t\t*addr0 = mtt->buf_dma;\n\t\t*cfg |= FIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_LEVEL_MASK,\n\t\t\t\t   ERDMA_MR_MTT_1LEVEL);\n\t} else {\n\t\t*addr0 = mtt->buf[0];\n\t\tmemcpy(addr1, mtt->buf + 1, MTT_SIZE(mem->mtt_nents - 1));\n\t\t*cfg |= FIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_LEVEL_MASK,\n\t\t\t\t   ERDMA_MR_MTT_0LEVEL);\n\t}\n}\n\nstatic int create_qp_cmd(struct erdma_ucontext *uctx, struct erdma_qp *qp)\n{\n\tstruct erdma_dev *dev = to_edev(qp->ibqp.device);\n\tstruct erdma_pd *pd = to_epd(qp->ibqp.pd);\n\tstruct erdma_cmdq_create_qp_req req;\n\tstruct erdma_uqp *user_qp;\n\tu64 resp0, resp1;\n\tint err;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_CREATE_QP);\n\n\treq.cfg0 = FIELD_PREP(ERDMA_CMD_CREATE_QP_SQ_DEPTH_MASK,\n\t\t\t      ilog2(qp->attrs.sq_size)) |\n\t\t   FIELD_PREP(ERDMA_CMD_CREATE_QP_QPN_MASK, QP_ID(qp));\n\treq.cfg1 = FIELD_PREP(ERDMA_CMD_CREATE_QP_RQ_DEPTH_MASK,\n\t\t\t      ilog2(qp->attrs.rq_size)) |\n\t\t   FIELD_PREP(ERDMA_CMD_CREATE_QP_PD_MASK, pd->pdn);\n\n\tif (rdma_is_kernel_res(&qp->ibqp.res)) {\n\t\tu32 pgsz_range = ilog2(SZ_1M) - ERDMA_HW_PAGE_SHIFT;\n\n\t\treq.sq_cqn_mtt_cfg =\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_PAGE_SIZE_MASK,\n\t\t\t\t   pgsz_range) |\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_CQN_MASK, qp->scq->cqn);\n\t\treq.rq_cqn_mtt_cfg =\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_PAGE_SIZE_MASK,\n\t\t\t\t   pgsz_range) |\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_CQN_MASK, qp->rcq->cqn);\n\n\t\treq.sq_mtt_cfg =\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_PAGE_OFFSET_MASK, 0) |\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_CNT_MASK, 1) |\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_LEVEL_MASK,\n\t\t\t\t   ERDMA_MR_MTT_0LEVEL);\n\t\treq.rq_mtt_cfg = req.sq_mtt_cfg;\n\n\t\treq.rq_buf_addr = qp->kern_qp.rq_buf_dma_addr;\n\t\treq.sq_buf_addr = qp->kern_qp.sq_buf_dma_addr;\n\t\treq.sq_db_info_dma_addr = qp->kern_qp.sq_buf_dma_addr +\n\t\t\t\t\t  (qp->attrs.sq_size << SQEBB_SHIFT);\n\t\treq.rq_db_info_dma_addr = qp->kern_qp.rq_buf_dma_addr +\n\t\t\t\t\t  (qp->attrs.rq_size << RQE_SHIFT);\n\t} else {\n\t\tuser_qp = &qp->user_qp;\n\t\treq.sq_cqn_mtt_cfg = FIELD_PREP(\n\t\t\tERDMA_CMD_CREATE_QP_PAGE_SIZE_MASK,\n\t\t\tilog2(user_qp->sq_mem.page_size) - ERDMA_HW_PAGE_SHIFT);\n\t\treq.sq_cqn_mtt_cfg |=\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_CQN_MASK, qp->scq->cqn);\n\n\t\treq.rq_cqn_mtt_cfg = FIELD_PREP(\n\t\t\tERDMA_CMD_CREATE_QP_PAGE_SIZE_MASK,\n\t\t\tilog2(user_qp->rq_mem.page_size) - ERDMA_HW_PAGE_SHIFT);\n\t\treq.rq_cqn_mtt_cfg |=\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_CQN_MASK, qp->rcq->cqn);\n\n\t\treq.sq_mtt_cfg = user_qp->sq_mem.page_offset;\n\t\treq.sq_mtt_cfg |= FIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_CNT_MASK,\n\t\t\t\t\t     user_qp->sq_mem.mtt_nents);\n\n\t\treq.rq_mtt_cfg = user_qp->rq_mem.page_offset;\n\t\treq.rq_mtt_cfg |= FIELD_PREP(ERDMA_CMD_CREATE_QP_MTT_CNT_MASK,\n\t\t\t\t\t     user_qp->rq_mem.mtt_nents);\n\n\t\tassemble_qbuf_mtt_for_cmd(&user_qp->sq_mem, &req.sq_mtt_cfg,\n\t\t\t\t\t  &req.sq_buf_addr, req.sq_mtt_entry);\n\t\tassemble_qbuf_mtt_for_cmd(&user_qp->rq_mem, &req.rq_mtt_cfg,\n\t\t\t\t\t  &req.rq_buf_addr, req.rq_mtt_entry);\n\n\t\treq.sq_db_info_dma_addr = user_qp->sq_db_info_dma_addr;\n\t\treq.rq_db_info_dma_addr = user_qp->rq_db_info_dma_addr;\n\n\t\tif (uctx->ext_db.enable) {\n\t\t\treq.sq_cqn_mtt_cfg |=\n\t\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_DB_CFG_MASK, 1);\n\t\t\treq.db_cfg =\n\t\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_SQDB_CFG_MASK,\n\t\t\t\t\t   uctx->ext_db.sdb_off) |\n\t\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_QP_RQDB_CFG_MASK,\n\t\t\t\t\t   uctx->ext_db.rdb_off);\n\t\t}\n\t}\n\n\terr = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), &resp0,\n\t\t\t\t  &resp1);\n\tif (!err)\n\t\tqp->attrs.cookie =\n\t\t\tFIELD_GET(ERDMA_CMDQ_CREATE_QP_RESP_COOKIE_MASK, resp0);\n\n\treturn err;\n}\n\nstatic int regmr_cmd(struct erdma_dev *dev, struct erdma_mr *mr)\n{\n\tstruct erdma_pd *pd = to_epd(mr->ibmr.pd);\n\tu32 mtt_level = ERDMA_MR_MTT_0LEVEL;\n\tstruct erdma_cmdq_reg_mr_req req;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA, CMDQ_OPCODE_REG_MR);\n\n\tif (mr->type == ERDMA_MR_TYPE_FRMR ||\n\t    mr->mem.page_cnt > ERDMA_MAX_INLINE_MTT_ENTRIES) {\n\t\tif (mr->mem.mtt->continuous) {\n\t\t\treq.phy_addr[0] = mr->mem.mtt->buf_dma;\n\t\t\tmtt_level = ERDMA_MR_MTT_1LEVEL;\n\t\t} else {\n\t\t\treq.phy_addr[0] = sg_dma_address(mr->mem.mtt->sglist);\n\t\t\tmtt_level = mr->mem.mtt->level;\n\t\t}\n\t} else if (mr->type != ERDMA_MR_TYPE_DMA) {\n\t\tmemcpy(req.phy_addr, mr->mem.mtt->buf,\n\t\t       MTT_SIZE(mr->mem.page_cnt));\n\t}\n\n\treq.cfg0 = FIELD_PREP(ERDMA_CMD_MR_VALID_MASK, mr->valid) |\n\t\t   FIELD_PREP(ERDMA_CMD_MR_KEY_MASK, mr->ibmr.lkey & 0xFF) |\n\t\t   FIELD_PREP(ERDMA_CMD_MR_MPT_IDX_MASK, mr->ibmr.lkey >> 8);\n\treq.cfg1 = FIELD_PREP(ERDMA_CMD_REGMR_PD_MASK, pd->pdn) |\n\t\t   FIELD_PREP(ERDMA_CMD_REGMR_TYPE_MASK, mr->type) |\n\t\t   FIELD_PREP(ERDMA_CMD_REGMR_RIGHT_MASK, mr->access);\n\treq.cfg2 = FIELD_PREP(ERDMA_CMD_REGMR_PAGESIZE_MASK,\n\t\t\t      ilog2(mr->mem.page_size)) |\n\t\t   FIELD_PREP(ERDMA_CMD_REGMR_MTT_LEVEL_MASK, mtt_level) |\n\t\t   FIELD_PREP(ERDMA_CMD_REGMR_MTT_CNT_MASK, mr->mem.page_cnt);\n\n\tif (mr->type == ERDMA_MR_TYPE_DMA)\n\t\tgoto post_cmd;\n\n\tif (mr->type == ERDMA_MR_TYPE_NORMAL) {\n\t\treq.start_va = mr->mem.va;\n\t\treq.size = mr->mem.len;\n\t}\n\n\tif (!mr->mem.mtt->continuous && mr->mem.mtt->level > 1) {\n\t\treq.cfg0 |= FIELD_PREP(ERDMA_CMD_MR_VERSION_MASK, 1);\n\t\treq.cfg2 |= FIELD_PREP(ERDMA_CMD_REGMR_MTT_PAGESIZE_MASK,\n\t\t\t\t       PAGE_SHIFT - ERDMA_HW_PAGE_SHIFT);\n\t\treq.size_h = upper_32_bits(mr->mem.len);\n\t\treq.mtt_cnt_h = mr->mem.page_cnt >> 20;\n\t}\n\npost_cmd:\n\treturn erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n}\n\nstatic int create_cq_cmd(struct erdma_ucontext *uctx, struct erdma_cq *cq)\n{\n\tstruct erdma_dev *dev = to_edev(cq->ibcq.device);\n\tstruct erdma_cmdq_create_cq_req req;\n\tstruct erdma_mem *mem;\n\tu32 page_size;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_CREATE_CQ);\n\n\treq.cfg0 = FIELD_PREP(ERDMA_CMD_CREATE_CQ_CQN_MASK, cq->cqn) |\n\t\t   FIELD_PREP(ERDMA_CMD_CREATE_CQ_DEPTH_MASK, ilog2(cq->depth));\n\treq.cfg1 = FIELD_PREP(ERDMA_CMD_CREATE_CQ_EQN_MASK, cq->assoc_eqn);\n\n\tif (rdma_is_kernel_res(&cq->ibcq.res)) {\n\t\tpage_size = SZ_32M;\n\t\treq.cfg0 |= FIELD_PREP(ERDMA_CMD_CREATE_CQ_PAGESIZE_MASK,\n\t\t\t\t       ilog2(page_size) - ERDMA_HW_PAGE_SHIFT);\n\t\treq.qbuf_addr_l = lower_32_bits(cq->kern_cq.qbuf_dma_addr);\n\t\treq.qbuf_addr_h = upper_32_bits(cq->kern_cq.qbuf_dma_addr);\n\n\t\treq.cfg1 |= FIELD_PREP(ERDMA_CMD_CREATE_CQ_MTT_CNT_MASK, 1) |\n\t\t\t    FIELD_PREP(ERDMA_CMD_CREATE_CQ_MTT_LEVEL_MASK,\n\t\t\t\t       ERDMA_MR_MTT_0LEVEL);\n\n\t\treq.first_page_offset = 0;\n\t\treq.cq_db_info_addr =\n\t\t\tcq->kern_cq.qbuf_dma_addr + (cq->depth << CQE_SHIFT);\n\t} else {\n\t\tmem = &cq->user_cq.qbuf_mem;\n\t\treq.cfg0 |=\n\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_CQ_PAGESIZE_MASK,\n\t\t\t\t   ilog2(mem->page_size) - ERDMA_HW_PAGE_SHIFT);\n\t\tif (mem->mtt_nents == 1) {\n\t\t\treq.qbuf_addr_l = lower_32_bits(mem->mtt->buf[0]);\n\t\t\treq.qbuf_addr_h = upper_32_bits(mem->mtt->buf[0]);\n\t\t\treq.cfg1 |=\n\t\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_CQ_MTT_LEVEL_MASK,\n\t\t\t\t\t   ERDMA_MR_MTT_0LEVEL);\n\t\t} else {\n\t\t\treq.qbuf_addr_l = lower_32_bits(mem->mtt->buf_dma);\n\t\t\treq.qbuf_addr_h = upper_32_bits(mem->mtt->buf_dma);\n\t\t\treq.cfg1 |=\n\t\t\t\tFIELD_PREP(ERDMA_CMD_CREATE_CQ_MTT_LEVEL_MASK,\n\t\t\t\t\t   ERDMA_MR_MTT_1LEVEL);\n\t\t}\n\t\treq.cfg1 |= FIELD_PREP(ERDMA_CMD_CREATE_CQ_MTT_CNT_MASK,\n\t\t\t\t       mem->mtt_nents);\n\n\t\treq.first_page_offset = mem->page_offset;\n\t\treq.cq_db_info_addr = cq->user_cq.db_info_dma_addr;\n\n\t\tif (uctx->ext_db.enable) {\n\t\t\treq.cfg1 |= FIELD_PREP(\n\t\t\t\tERDMA_CMD_CREATE_CQ_MTT_DB_CFG_MASK, 1);\n\t\t\treq.cfg2 = FIELD_PREP(ERDMA_CMD_CREATE_CQ_DB_CFG_MASK,\n\t\t\t\t\t      uctx->ext_db.cdb_off);\n\t\t}\n\t}\n\n\treturn erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n}\n\nstatic int erdma_alloc_idx(struct erdma_resource_cb *res_cb)\n{\n\tint idx;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&res_cb->lock, flags);\n\tidx = find_next_zero_bit(res_cb->bitmap, res_cb->max_cap,\n\t\t\t\t res_cb->next_alloc_idx);\n\tif (idx == res_cb->max_cap) {\n\t\tidx = find_first_zero_bit(res_cb->bitmap, res_cb->max_cap);\n\t\tif (idx == res_cb->max_cap) {\n\t\t\tres_cb->next_alloc_idx = 1;\n\t\t\tspin_unlock_irqrestore(&res_cb->lock, flags);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t}\n\n\tset_bit(idx, res_cb->bitmap);\n\tres_cb->next_alloc_idx = idx + 1;\n\tspin_unlock_irqrestore(&res_cb->lock, flags);\n\n\treturn idx;\n}\n\nstatic inline void erdma_free_idx(struct erdma_resource_cb *res_cb, u32 idx)\n{\n\tunsigned long flags;\n\tu32 used;\n\n\tspin_lock_irqsave(&res_cb->lock, flags);\n\tused = __test_and_clear_bit(idx, res_cb->bitmap);\n\tspin_unlock_irqrestore(&res_cb->lock, flags);\n\tWARN_ON(!used);\n}\n\nstatic struct rdma_user_mmap_entry *\nerdma_user_mmap_entry_insert(struct erdma_ucontext *uctx, void *address,\n\t\t\t     u32 size, u8 mmap_flag, u64 *mmap_offset)\n{\n\tstruct erdma_user_mmap_entry *entry =\n\t\tkzalloc(sizeof(*entry), GFP_KERNEL);\n\tint ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->address = (u64)address;\n\tentry->mmap_flag = mmap_flag;\n\n\tsize = PAGE_ALIGN(size);\n\n\tret = rdma_user_mmap_entry_insert(&uctx->ibucontext, &entry->rdma_entry,\n\t\t\t\t\t  size);\n\tif (ret) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\n\t*mmap_offset = rdma_user_mmap_get_offset(&entry->rdma_entry);\n\n\treturn &entry->rdma_entry;\n}\n\nint erdma_query_device(struct ib_device *ibdev, struct ib_device_attr *attr,\n\t\t       struct ib_udata *unused)\n{\n\tstruct erdma_dev *dev = to_edev(ibdev);\n\n\tmemset(attr, 0, sizeof(*attr));\n\n\tattr->max_mr_size = dev->attrs.max_mr_size;\n\tattr->vendor_id = PCI_VENDOR_ID_ALIBABA;\n\tattr->vendor_part_id = dev->pdev->device;\n\tattr->hw_ver = dev->pdev->revision;\n\tattr->max_qp = dev->attrs.max_qp - 1;\n\tattr->max_qp_wr = min(dev->attrs.max_send_wr, dev->attrs.max_recv_wr);\n\tattr->max_qp_rd_atom = dev->attrs.max_ord;\n\tattr->max_qp_init_rd_atom = dev->attrs.max_ird;\n\tattr->max_res_rd_atom = dev->attrs.max_qp * dev->attrs.max_ird;\n\tattr->device_cap_flags = IB_DEVICE_MEM_MGT_EXTENSIONS;\n\tattr->kernel_cap_flags = IBK_LOCAL_DMA_LKEY;\n\tibdev->local_dma_lkey = dev->attrs.local_dma_key;\n\tattr->max_send_sge = dev->attrs.max_send_sge;\n\tattr->max_recv_sge = dev->attrs.max_recv_sge;\n\tattr->max_sge_rd = dev->attrs.max_sge_rd;\n\tattr->max_cq = dev->attrs.max_cq - 1;\n\tattr->max_cqe = dev->attrs.max_cqe;\n\tattr->max_mr = dev->attrs.max_mr;\n\tattr->max_pd = dev->attrs.max_pd;\n\tattr->max_mw = dev->attrs.max_mw;\n\tattr->max_fast_reg_page_list_len = ERDMA_MAX_FRMR_PA;\n\tattr->page_size_cap = ERDMA_PAGE_SIZE_SUPPORT;\n\n\tif (dev->attrs.cap_flags & ERDMA_DEV_CAP_FLAGS_ATOMIC)\n\t\tattr->atomic_cap = IB_ATOMIC_GLOB;\n\n\tattr->fw_ver = dev->attrs.fw_version;\n\n\tif (dev->netdev)\n\t\taddrconf_addr_eui48((u8 *)&attr->sys_image_guid,\n\t\t\t\t    dev->netdev->dev_addr);\n\n\treturn 0;\n}\n\nint erdma_query_gid(struct ib_device *ibdev, u32 port, int idx,\n\t\t    union ib_gid *gid)\n{\n\tstruct erdma_dev *dev = to_edev(ibdev);\n\n\tmemset(gid, 0, sizeof(*gid));\n\tether_addr_copy(gid->raw, dev->attrs.peer_addr);\n\n\treturn 0;\n}\n\nint erdma_query_port(struct ib_device *ibdev, u32 port,\n\t\t     struct ib_port_attr *attr)\n{\n\tstruct erdma_dev *dev = to_edev(ibdev);\n\tstruct net_device *ndev = dev->netdev;\n\n\tmemset(attr, 0, sizeof(*attr));\n\n\tattr->gid_tbl_len = 1;\n\tattr->port_cap_flags = IB_PORT_CM_SUP | IB_PORT_DEVICE_MGMT_SUP;\n\tattr->max_msg_sz = -1;\n\n\tif (!ndev)\n\t\tgoto out;\n\n\tib_get_eth_speed(ibdev, port, &attr->active_speed, &attr->active_width);\n\tattr->max_mtu = ib_mtu_int_to_enum(ndev->mtu);\n\tattr->active_mtu = ib_mtu_int_to_enum(ndev->mtu);\n\tif (netif_running(ndev) && netif_carrier_ok(ndev))\n\t\tdev->state = IB_PORT_ACTIVE;\n\telse\n\t\tdev->state = IB_PORT_DOWN;\n\tattr->state = dev->state;\n\nout:\n\tif (dev->state == IB_PORT_ACTIVE)\n\t\tattr->phys_state = IB_PORT_PHYS_STATE_LINK_UP;\n\telse\n\t\tattr->phys_state = IB_PORT_PHYS_STATE_DISABLED;\n\n\treturn 0;\n}\n\nint erdma_get_port_immutable(struct ib_device *ibdev, u32 port,\n\t\t\t     struct ib_port_immutable *port_immutable)\n{\n\tport_immutable->gid_tbl_len = 1;\n\tport_immutable->core_cap_flags = RDMA_CORE_PORT_IWARP;\n\n\treturn 0;\n}\n\nint erdma_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)\n{\n\tstruct erdma_pd *pd = to_epd(ibpd);\n\tstruct erdma_dev *dev = to_edev(ibpd->device);\n\tint pdn;\n\n\tpdn = erdma_alloc_idx(&dev->res_cb[ERDMA_RES_TYPE_PD]);\n\tif (pdn < 0)\n\t\treturn pdn;\n\n\tpd->pdn = pdn;\n\n\treturn 0;\n}\n\nint erdma_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)\n{\n\tstruct erdma_pd *pd = to_epd(ibpd);\n\tstruct erdma_dev *dev = to_edev(ibpd->device);\n\n\terdma_free_idx(&dev->res_cb[ERDMA_RES_TYPE_PD], pd->pdn);\n\n\treturn 0;\n}\n\nstatic void erdma_flush_worker(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct erdma_qp *qp =\n\t\tcontainer_of(dwork, struct erdma_qp, reflush_dwork);\n\tstruct erdma_cmdq_reflush_req req;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_REFLUSH);\n\treq.qpn = QP_ID(qp);\n\treq.sq_pi = qp->kern_qp.sq_pi;\n\treq.rq_pi = qp->kern_qp.rq_pi;\n\terdma_post_cmd_wait(&qp->dev->cmdq, &req, sizeof(req), NULL, NULL);\n}\n\nstatic int erdma_qp_validate_cap(struct erdma_dev *dev,\n\t\t\t\t struct ib_qp_init_attr *attrs)\n{\n\tif ((attrs->cap.max_send_wr > dev->attrs.max_send_wr) ||\n\t    (attrs->cap.max_recv_wr > dev->attrs.max_recv_wr) ||\n\t    (attrs->cap.max_send_sge > dev->attrs.max_send_sge) ||\n\t    (attrs->cap.max_recv_sge > dev->attrs.max_recv_sge) ||\n\t    (attrs->cap.max_inline_data > ERDMA_MAX_INLINE) ||\n\t    !attrs->cap.max_send_wr || !attrs->cap.max_recv_wr) {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int erdma_qp_validate_attr(struct erdma_dev *dev,\n\t\t\t\t  struct ib_qp_init_attr *attrs)\n{\n\tif (attrs->qp_type != IB_QPT_RC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (attrs->srq)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!attrs->send_cq || !attrs->recv_cq)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic void free_kernel_qp(struct erdma_qp *qp)\n{\n\tstruct erdma_dev *dev = qp->dev;\n\n\tvfree(qp->kern_qp.swr_tbl);\n\tvfree(qp->kern_qp.rwr_tbl);\n\n\tif (qp->kern_qp.sq_buf)\n\t\tdma_free_coherent(\n\t\t\t&dev->pdev->dev,\n\t\t\tWARPPED_BUFSIZE(qp->attrs.sq_size << SQEBB_SHIFT),\n\t\t\tqp->kern_qp.sq_buf, qp->kern_qp.sq_buf_dma_addr);\n\n\tif (qp->kern_qp.rq_buf)\n\t\tdma_free_coherent(\n\t\t\t&dev->pdev->dev,\n\t\t\tWARPPED_BUFSIZE(qp->attrs.rq_size << RQE_SHIFT),\n\t\t\tqp->kern_qp.rq_buf, qp->kern_qp.rq_buf_dma_addr);\n}\n\nstatic int init_kernel_qp(struct erdma_dev *dev, struct erdma_qp *qp,\n\t\t\t  struct ib_qp_init_attr *attrs)\n{\n\tstruct erdma_kqp *kqp = &qp->kern_qp;\n\tint size;\n\n\tif (attrs->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tkqp->sig_all = 1;\n\n\tkqp->sq_pi = 0;\n\tkqp->sq_ci = 0;\n\tkqp->rq_pi = 0;\n\tkqp->rq_ci = 0;\n\tkqp->hw_sq_db =\n\t\tdev->func_bar + (ERDMA_SDB_SHARED_PAGE_INDEX << PAGE_SHIFT);\n\tkqp->hw_rq_db = dev->func_bar + ERDMA_BAR_RQDB_SPACE_OFFSET;\n\n\tkqp->swr_tbl = vmalloc_array(qp->attrs.sq_size, sizeof(u64));\n\tkqp->rwr_tbl = vmalloc_array(qp->attrs.rq_size, sizeof(u64));\n\tif (!kqp->swr_tbl || !kqp->rwr_tbl)\n\t\tgoto err_out;\n\n\tsize = (qp->attrs.sq_size << SQEBB_SHIFT) + ERDMA_EXTRA_BUFFER_SIZE;\n\tkqp->sq_buf = dma_alloc_coherent(&dev->pdev->dev, size,\n\t\t\t\t\t &kqp->sq_buf_dma_addr, GFP_KERNEL);\n\tif (!kqp->sq_buf)\n\t\tgoto err_out;\n\n\tsize = (qp->attrs.rq_size << RQE_SHIFT) + ERDMA_EXTRA_BUFFER_SIZE;\n\tkqp->rq_buf = dma_alloc_coherent(&dev->pdev->dev, size,\n\t\t\t\t\t &kqp->rq_buf_dma_addr, GFP_KERNEL);\n\tif (!kqp->rq_buf)\n\t\tgoto err_out;\n\n\tkqp->sq_db_info = kqp->sq_buf + (qp->attrs.sq_size << SQEBB_SHIFT);\n\tkqp->rq_db_info = kqp->rq_buf + (qp->attrs.rq_size << RQE_SHIFT);\n\n\treturn 0;\n\nerr_out:\n\tfree_kernel_qp(qp);\n\treturn -ENOMEM;\n}\n\nstatic void erdma_fill_bottom_mtt(struct erdma_dev *dev, struct erdma_mem *mem)\n{\n\tstruct erdma_mtt *mtt = mem->mtt;\n\tstruct ib_block_iter biter;\n\tu32 idx = 0;\n\n\twhile (mtt->low_level)\n\t\tmtt = mtt->low_level;\n\n\trdma_umem_for_each_dma_block(mem->umem, &biter, mem->page_size)\n\t\tmtt->buf[idx++] = rdma_block_iter_dma_address(&biter);\n}\n\nstatic struct erdma_mtt *erdma_create_cont_mtt(struct erdma_dev *dev,\n\t\t\t\t\t       size_t size)\n{\n\tstruct erdma_mtt *mtt;\n\n\tmtt = kzalloc(sizeof(*mtt), GFP_KERNEL);\n\tif (!mtt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmtt->size = size;\n\tmtt->buf = kzalloc(mtt->size, GFP_KERNEL);\n\tif (!mtt->buf)\n\t\tgoto err_free_mtt;\n\n\tmtt->continuous = true;\n\tmtt->buf_dma = dma_map_single(&dev->pdev->dev, mtt->buf, mtt->size,\n\t\t\t\t      DMA_TO_DEVICE);\n\tif (dma_mapping_error(&dev->pdev->dev, mtt->buf_dma))\n\t\tgoto err_free_mtt_buf;\n\n\treturn mtt;\n\nerr_free_mtt_buf:\n\tkfree(mtt->buf);\n\nerr_free_mtt:\n\tkfree(mtt);\n\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic void erdma_destroy_mtt_buf_sg(struct erdma_dev *dev,\n\t\t\t\t     struct erdma_mtt *mtt)\n{\n\tdma_unmap_sg(&dev->pdev->dev, mtt->sglist, mtt->nsg, DMA_TO_DEVICE);\n\tvfree(mtt->sglist);\n}\n\nstatic void erdma_destroy_scatter_mtt(struct erdma_dev *dev,\n\t\t\t\t      struct erdma_mtt *mtt)\n{\n\terdma_destroy_mtt_buf_sg(dev, mtt);\n\tvfree(mtt->buf);\n\tkfree(mtt);\n}\n\nstatic void erdma_init_middle_mtt(struct erdma_mtt *mtt,\n\t\t\t\t  struct erdma_mtt *low_mtt)\n{\n\tstruct scatterlist *sg;\n\tu32 idx = 0, i;\n\n\tfor_each_sg(low_mtt->sglist, sg, low_mtt->nsg, i)\n\t\tmtt->buf[idx++] = sg_dma_address(sg);\n}\n\nstatic int erdma_create_mtt_buf_sg(struct erdma_dev *dev, struct erdma_mtt *mtt)\n{\n\tstruct scatterlist *sglist;\n\tvoid *buf = mtt->buf;\n\tu32 npages, i, nsg;\n\tstruct page *pg;\n\n\t \n\tif ((uintptr_t)buf & ~PAGE_MASK)\n\t\treturn -EINVAL;\n\n\tnpages = DIV_ROUND_UP(mtt->size, PAGE_SIZE);\n\tsglist = vzalloc(npages * sizeof(*sglist));\n\tif (!sglist)\n\t\treturn -ENOMEM;\n\n\tsg_init_table(sglist, npages);\n\tfor (i = 0; i < npages; i++) {\n\t\tpg = vmalloc_to_page(buf);\n\t\tif (!pg)\n\t\t\tgoto err;\n\t\tsg_set_page(&sglist[i], pg, PAGE_SIZE, 0);\n\t\tbuf += PAGE_SIZE;\n\t}\n\n\tnsg = dma_map_sg(&dev->pdev->dev, sglist, npages, DMA_TO_DEVICE);\n\tif (!nsg)\n\t\tgoto err;\n\n\tmtt->sglist = sglist;\n\tmtt->nsg = nsg;\n\n\treturn 0;\nerr:\n\tvfree(sglist);\n\n\treturn -ENOMEM;\n}\n\nstatic struct erdma_mtt *erdma_create_scatter_mtt(struct erdma_dev *dev,\n\t\t\t\t\t\t  size_t size)\n{\n\tstruct erdma_mtt *mtt;\n\tint ret = -ENOMEM;\n\n\tmtt = kzalloc(sizeof(*mtt), GFP_KERNEL);\n\tif (!mtt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmtt->size = ALIGN(size, PAGE_SIZE);\n\tmtt->buf = vzalloc(mtt->size);\n\tmtt->continuous = false;\n\tif (!mtt->buf)\n\t\tgoto err_free_mtt;\n\n\tret = erdma_create_mtt_buf_sg(dev, mtt);\n\tif (ret)\n\t\tgoto err_free_mtt_buf;\n\n\tibdev_dbg(&dev->ibdev, \"create scatter mtt, size:%lu, nsg:%u\\n\",\n\t\t  mtt->size, mtt->nsg);\n\n\treturn mtt;\n\nerr_free_mtt_buf:\n\tvfree(mtt->buf);\n\nerr_free_mtt:\n\tkfree(mtt);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic struct erdma_mtt *erdma_create_mtt(struct erdma_dev *dev, size_t size,\n\t\t\t\t\t  bool force_continuous)\n{\n\tstruct erdma_mtt *mtt, *tmp_mtt;\n\tint ret, level = 0;\n\n\tibdev_dbg(&dev->ibdev, \"create_mtt, size:%lu, force cont:%d\\n\", size,\n\t\t  force_continuous);\n\n\tif (!(dev->attrs.cap_flags & ERDMA_DEV_CAP_FLAGS_MTT_VA))\n\t\tforce_continuous = true;\n\n\tif (force_continuous)\n\t\treturn erdma_create_cont_mtt(dev, size);\n\n\tmtt = erdma_create_scatter_mtt(dev, size);\n\tif (IS_ERR(mtt))\n\t\treturn mtt;\n\tlevel = 1;\n\n\t \n\twhile (mtt->nsg != 1 && level <= 3) {\n\t\ttmp_mtt = erdma_create_scatter_mtt(dev, MTT_SIZE(mtt->nsg));\n\t\tif (IS_ERR(tmp_mtt)) {\n\t\t\tret = PTR_ERR(tmp_mtt);\n\t\t\tgoto err_free_mtt;\n\t\t}\n\t\terdma_init_middle_mtt(tmp_mtt, mtt);\n\t\ttmp_mtt->low_level = mtt;\n\t\tmtt = tmp_mtt;\n\t\tlevel++;\n\t}\n\n\tif (level > 3) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_mtt;\n\t}\n\n\tmtt->level = level;\n\tibdev_dbg(&dev->ibdev, \"top mtt: level:%d, dma_addr 0x%llx\\n\",\n\t\t  mtt->level, mtt->sglist[0].dma_address);\n\n\treturn mtt;\nerr_free_mtt:\n\twhile (mtt) {\n\t\ttmp_mtt = mtt->low_level;\n\t\terdma_destroy_scatter_mtt(dev, mtt);\n\t\tmtt = tmp_mtt;\n\t}\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void erdma_destroy_mtt(struct erdma_dev *dev, struct erdma_mtt *mtt)\n{\n\tstruct erdma_mtt *tmp_mtt;\n\n\tif (mtt->continuous) {\n\t\tdma_unmap_single(&dev->pdev->dev, mtt->buf_dma, mtt->size,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tkfree(mtt->buf);\n\t\tkfree(mtt);\n\t} else {\n\t\twhile (mtt) {\n\t\t\ttmp_mtt = mtt->low_level;\n\t\t\terdma_destroy_scatter_mtt(dev, mtt);\n\t\t\tmtt = tmp_mtt;\n\t\t}\n\t}\n}\n\nstatic int get_mtt_entries(struct erdma_dev *dev, struct erdma_mem *mem,\n\t\t\t   u64 start, u64 len, int access, u64 virt,\n\t\t\t   unsigned long req_page_size, bool force_continuous)\n{\n\tint ret = 0;\n\n\tmem->umem = ib_umem_get(&dev->ibdev, start, len, access);\n\tif (IS_ERR(mem->umem)) {\n\t\tret = PTR_ERR(mem->umem);\n\t\tmem->umem = NULL;\n\t\treturn ret;\n\t}\n\n\tmem->va = virt;\n\tmem->len = len;\n\tmem->page_size = ib_umem_find_best_pgsz(mem->umem, req_page_size, virt);\n\tmem->page_offset = start & (mem->page_size - 1);\n\tmem->mtt_nents = ib_umem_num_dma_blocks(mem->umem, mem->page_size);\n\tmem->page_cnt = mem->mtt_nents;\n\tmem->mtt = erdma_create_mtt(dev, MTT_SIZE(mem->page_cnt),\n\t\t\t\t    force_continuous);\n\tif (IS_ERR(mem->mtt)) {\n\t\tret = PTR_ERR(mem->mtt);\n\t\tgoto error_ret;\n\t}\n\n\terdma_fill_bottom_mtt(dev, mem);\n\n\treturn 0;\n\nerror_ret:\n\tif (mem->umem) {\n\t\tib_umem_release(mem->umem);\n\t\tmem->umem = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic void put_mtt_entries(struct erdma_dev *dev, struct erdma_mem *mem)\n{\n\tif (mem->mtt)\n\t\terdma_destroy_mtt(dev, mem->mtt);\n\n\tif (mem->umem) {\n\t\tib_umem_release(mem->umem);\n\t\tmem->umem = NULL;\n\t}\n}\n\nstatic int erdma_map_user_dbrecords(struct erdma_ucontext *ctx,\n\t\t\t\t    u64 dbrecords_va,\n\t\t\t\t    struct erdma_user_dbrecords_page **dbr_page,\n\t\t\t\t    dma_addr_t *dma_addr)\n{\n\tstruct erdma_user_dbrecords_page *page = NULL;\n\tint rv = 0;\n\n\tmutex_lock(&ctx->dbrecords_page_mutex);\n\n\tlist_for_each_entry(page, &ctx->dbrecords_page_list, list)\n\t\tif (page->va == (dbrecords_va & PAGE_MASK))\n\t\t\tgoto found;\n\n\tpage = kmalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page) {\n\t\trv = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage->va = (dbrecords_va & PAGE_MASK);\n\tpage->refcnt = 0;\n\n\tpage->umem = ib_umem_get(ctx->ibucontext.device,\n\t\t\t\t dbrecords_va & PAGE_MASK, PAGE_SIZE, 0);\n\tif (IS_ERR(page->umem)) {\n\t\trv = PTR_ERR(page->umem);\n\t\tkfree(page);\n\t\tgoto out;\n\t}\n\n\tlist_add(&page->list, &ctx->dbrecords_page_list);\n\nfound:\n\t*dma_addr = sg_dma_address(page->umem->sgt_append.sgt.sgl) +\n\t\t    (dbrecords_va & ~PAGE_MASK);\n\t*dbr_page = page;\n\tpage->refcnt++;\n\nout:\n\tmutex_unlock(&ctx->dbrecords_page_mutex);\n\treturn rv;\n}\n\nstatic void\nerdma_unmap_user_dbrecords(struct erdma_ucontext *ctx,\n\t\t\t   struct erdma_user_dbrecords_page **dbr_page)\n{\n\tif (!ctx || !(*dbr_page))\n\t\treturn;\n\n\tmutex_lock(&ctx->dbrecords_page_mutex);\n\tif (--(*dbr_page)->refcnt == 0) {\n\t\tlist_del(&(*dbr_page)->list);\n\t\tib_umem_release((*dbr_page)->umem);\n\t\tkfree(*dbr_page);\n\t}\n\n\t*dbr_page = NULL;\n\tmutex_unlock(&ctx->dbrecords_page_mutex);\n}\n\nstatic int init_user_qp(struct erdma_qp *qp, struct erdma_ucontext *uctx,\n\t\t\tu64 va, u32 len, u64 db_info_va)\n{\n\tdma_addr_t db_info_dma_addr;\n\tu32 rq_offset;\n\tint ret;\n\n\tif (len < (ALIGN(qp->attrs.sq_size * SQEBB_SIZE, ERDMA_HW_PAGE_SIZE) +\n\t\t   qp->attrs.rq_size * RQE_SIZE))\n\t\treturn -EINVAL;\n\n\tret = get_mtt_entries(qp->dev, &qp->user_qp.sq_mem, va,\n\t\t\t      qp->attrs.sq_size << SQEBB_SHIFT, 0, va,\n\t\t\t      (SZ_1M - SZ_4K), true);\n\tif (ret)\n\t\treturn ret;\n\n\trq_offset = ALIGN(qp->attrs.sq_size << SQEBB_SHIFT, ERDMA_HW_PAGE_SIZE);\n\tqp->user_qp.rq_offset = rq_offset;\n\n\tret = get_mtt_entries(qp->dev, &qp->user_qp.rq_mem, va + rq_offset,\n\t\t\t      qp->attrs.rq_size << RQE_SHIFT, 0, va + rq_offset,\n\t\t\t      (SZ_1M - SZ_4K), true);\n\tif (ret)\n\t\tgoto put_sq_mtt;\n\n\tret = erdma_map_user_dbrecords(uctx, db_info_va,\n\t\t\t\t       &qp->user_qp.user_dbr_page,\n\t\t\t\t       &db_info_dma_addr);\n\tif (ret)\n\t\tgoto put_rq_mtt;\n\n\tqp->user_qp.sq_db_info_dma_addr = db_info_dma_addr;\n\tqp->user_qp.rq_db_info_dma_addr = db_info_dma_addr + ERDMA_DB_SIZE;\n\n\treturn 0;\n\nput_rq_mtt:\n\tput_mtt_entries(qp->dev, &qp->user_qp.rq_mem);\n\nput_sq_mtt:\n\tput_mtt_entries(qp->dev, &qp->user_qp.sq_mem);\n\n\treturn ret;\n}\n\nstatic void free_user_qp(struct erdma_qp *qp, struct erdma_ucontext *uctx)\n{\n\tput_mtt_entries(qp->dev, &qp->user_qp.sq_mem);\n\tput_mtt_entries(qp->dev, &qp->user_qp.rq_mem);\n\terdma_unmap_user_dbrecords(uctx, &qp->user_qp.user_dbr_page);\n}\n\nint erdma_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *attrs,\n\t\t    struct ib_udata *udata)\n{\n\tstruct erdma_qp *qp = to_eqp(ibqp);\n\tstruct erdma_dev *dev = to_edev(ibqp->device);\n\tstruct erdma_ucontext *uctx = rdma_udata_to_drv_context(\n\t\tudata, struct erdma_ucontext, ibucontext);\n\tstruct erdma_ureq_create_qp ureq;\n\tstruct erdma_uresp_create_qp uresp;\n\tint ret;\n\n\tret = erdma_qp_validate_cap(dev, attrs);\n\tif (ret)\n\t\tgoto err_out;\n\n\tret = erdma_qp_validate_attr(dev, attrs);\n\tif (ret)\n\t\tgoto err_out;\n\n\tqp->scq = to_ecq(attrs->send_cq);\n\tqp->rcq = to_ecq(attrs->recv_cq);\n\tqp->dev = dev;\n\tqp->attrs.cc = dev->attrs.cc;\n\n\tinit_rwsem(&qp->state_lock);\n\tkref_init(&qp->ref);\n\tinit_completion(&qp->safe_free);\n\n\tret = xa_alloc_cyclic(&dev->qp_xa, &qp->ibqp.qp_num, qp,\n\t\t\t      XA_LIMIT(1, dev->attrs.max_qp - 1),\n\t\t\t      &dev->next_alloc_qpn, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tqp->attrs.sq_size = roundup_pow_of_two(attrs->cap.max_send_wr *\n\t\t\t\t\t       ERDMA_MAX_WQEBB_PER_SQE);\n\tqp->attrs.rq_size = roundup_pow_of_two(attrs->cap.max_recv_wr);\n\n\tif (uctx) {\n\t\tret = ib_copy_from_udata(&ureq, udata,\n\t\t\t\t\t min(sizeof(ureq), udata->inlen));\n\t\tif (ret)\n\t\t\tgoto err_out_xa;\n\n\t\tret = init_user_qp(qp, uctx, ureq.qbuf_va, ureq.qbuf_len,\n\t\t\t\t   ureq.db_record_va);\n\t\tif (ret)\n\t\t\tgoto err_out_xa;\n\n\t\tmemset(&uresp, 0, sizeof(uresp));\n\n\t\turesp.num_sqe = qp->attrs.sq_size;\n\t\turesp.num_rqe = qp->attrs.rq_size;\n\t\turesp.qp_id = QP_ID(qp);\n\t\turesp.rq_offset = qp->user_qp.rq_offset;\n\n\t\tret = ib_copy_to_udata(udata, &uresp, sizeof(uresp));\n\t\tif (ret)\n\t\t\tgoto err_out_cmd;\n\t} else {\n\t\tinit_kernel_qp(dev, qp, attrs);\n\t}\n\n\tqp->attrs.max_send_sge = attrs->cap.max_send_sge;\n\tqp->attrs.max_recv_sge = attrs->cap.max_recv_sge;\n\tqp->attrs.state = ERDMA_QP_STATE_IDLE;\n\tINIT_DELAYED_WORK(&qp->reflush_dwork, erdma_flush_worker);\n\n\tret = create_qp_cmd(uctx, qp);\n\tif (ret)\n\t\tgoto err_out_cmd;\n\n\tspin_lock_init(&qp->lock);\n\n\treturn 0;\n\nerr_out_cmd:\n\tif (uctx)\n\t\tfree_user_qp(qp, uctx);\n\telse\n\t\tfree_kernel_qp(qp);\nerr_out_xa:\n\txa_erase(&dev->qp_xa, QP_ID(qp));\nerr_out:\n\treturn ret;\n}\n\nstatic int erdma_create_stag(struct erdma_dev *dev, u32 *stag)\n{\n\tint stag_idx;\n\n\tstag_idx = erdma_alloc_idx(&dev->res_cb[ERDMA_RES_TYPE_STAG_IDX]);\n\tif (stag_idx < 0)\n\t\treturn stag_idx;\n\n\t \n\t*stag = (stag_idx << 8);\n\n\treturn 0;\n}\n\nstruct ib_mr *erdma_get_dma_mr(struct ib_pd *ibpd, int acc)\n{\n\tstruct erdma_dev *dev = to_edev(ibpd->device);\n\tstruct erdma_mr *mr;\n\tu32 stag;\n\tint ret;\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = erdma_create_stag(dev, &stag);\n\tif (ret)\n\t\tgoto out_free;\n\n\tmr->type = ERDMA_MR_TYPE_DMA;\n\n\tmr->ibmr.lkey = stag;\n\tmr->ibmr.rkey = stag;\n\tmr->ibmr.pd = ibpd;\n\tmr->access = ERDMA_MR_ACC_LR | to_erdma_access_flags(acc);\n\tret = regmr_cmd(dev, mr);\n\tif (ret)\n\t\tgoto out_remove_stag;\n\n\treturn &mr->ibmr;\n\nout_remove_stag:\n\terdma_free_idx(&dev->res_cb[ERDMA_RES_TYPE_STAG_IDX],\n\t\t       mr->ibmr.lkey >> 8);\n\nout_free:\n\tkfree(mr);\n\n\treturn ERR_PTR(ret);\n}\n\nstruct ib_mr *erdma_ib_alloc_mr(struct ib_pd *ibpd, enum ib_mr_type mr_type,\n\t\t\t\tu32 max_num_sg)\n{\n\tstruct erdma_mr *mr;\n\tstruct erdma_dev *dev = to_edev(ibpd->device);\n\tint ret;\n\tu32 stag;\n\n\tif (mr_type != IB_MR_TYPE_MEM_REG)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (max_num_sg > ERDMA_MR_MAX_MTT_CNT)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = erdma_create_stag(dev, &stag);\n\tif (ret)\n\t\tgoto out_free;\n\n\tmr->type = ERDMA_MR_TYPE_FRMR;\n\n\tmr->ibmr.lkey = stag;\n\tmr->ibmr.rkey = stag;\n\tmr->ibmr.pd = ibpd;\n\t \n\tmr->access = ERDMA_MR_ACC_LR | ERDMA_MR_ACC_LW | ERDMA_MR_ACC_RR |\n\t\t     ERDMA_MR_ACC_RW;\n\n\tmr->mem.page_size = PAGE_SIZE;  \n\tmr->mem.page_cnt = max_num_sg;\n\tmr->mem.mtt = erdma_create_mtt(dev, MTT_SIZE(max_num_sg), true);\n\tif (IS_ERR(mr->mem.mtt)) {\n\t\tret = PTR_ERR(mr->mem.mtt);\n\t\tgoto out_remove_stag;\n\t}\n\n\tret = regmr_cmd(dev, mr);\n\tif (ret)\n\t\tgoto out_destroy_mtt;\n\n\treturn &mr->ibmr;\n\nout_destroy_mtt:\n\terdma_destroy_mtt(dev, mr->mem.mtt);\n\nout_remove_stag:\n\terdma_free_idx(&dev->res_cb[ERDMA_RES_TYPE_STAG_IDX],\n\t\t       mr->ibmr.lkey >> 8);\n\nout_free:\n\tkfree(mr);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic int erdma_set_page(struct ib_mr *ibmr, u64 addr)\n{\n\tstruct erdma_mr *mr = to_emr(ibmr);\n\n\tif (mr->mem.mtt_nents >= mr->mem.page_cnt)\n\t\treturn -1;\n\n\tmr->mem.mtt->buf[mr->mem.mtt_nents] = addr;\n\tmr->mem.mtt_nents++;\n\n\treturn 0;\n}\n\nint erdma_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg, int sg_nents,\n\t\t    unsigned int *sg_offset)\n{\n\tstruct erdma_mr *mr = to_emr(ibmr);\n\tint num;\n\n\tmr->mem.mtt_nents = 0;\n\n\tnum = ib_sg_to_pages(&mr->ibmr, sg, sg_nents, sg_offset,\n\t\t\t     erdma_set_page);\n\n\treturn num;\n}\n\nstruct ib_mr *erdma_reg_user_mr(struct ib_pd *ibpd, u64 start, u64 len,\n\t\t\t\tu64 virt, int access, struct ib_udata *udata)\n{\n\tstruct erdma_mr *mr = NULL;\n\tstruct erdma_dev *dev = to_edev(ibpd->device);\n\tu32 stag;\n\tint ret;\n\n\tif (!len || len > dev->attrs.max_mr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = get_mtt_entries(dev, &mr->mem, start, len, access, virt,\n\t\t\t      SZ_2G - SZ_4K, false);\n\tif (ret)\n\t\tgoto err_out_free;\n\n\tret = erdma_create_stag(dev, &stag);\n\tif (ret)\n\t\tgoto err_out_put_mtt;\n\n\tmr->ibmr.lkey = mr->ibmr.rkey = stag;\n\tmr->ibmr.pd = ibpd;\n\tmr->mem.va = virt;\n\tmr->mem.len = len;\n\tmr->access = ERDMA_MR_ACC_LR | to_erdma_access_flags(access);\n\tmr->valid = 1;\n\tmr->type = ERDMA_MR_TYPE_NORMAL;\n\n\tret = regmr_cmd(dev, mr);\n\tif (ret)\n\t\tgoto err_out_mr;\n\n\treturn &mr->ibmr;\n\nerr_out_mr:\n\terdma_free_idx(&dev->res_cb[ERDMA_RES_TYPE_STAG_IDX],\n\t\t       mr->ibmr.lkey >> 8);\n\nerr_out_put_mtt:\n\tput_mtt_entries(dev, &mr->mem);\n\nerr_out_free:\n\tkfree(mr);\n\n\treturn ERR_PTR(ret);\n}\n\nint erdma_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)\n{\n\tstruct erdma_mr *mr;\n\tstruct erdma_dev *dev = to_edev(ibmr->device);\n\tstruct erdma_cmdq_dereg_mr_req req;\n\tint ret;\n\n\tmr = to_emr(ibmr);\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_DEREG_MR);\n\n\treq.cfg = FIELD_PREP(ERDMA_CMD_MR_MPT_IDX_MASK, ibmr->lkey >> 8) |\n\t\t  FIELD_PREP(ERDMA_CMD_MR_KEY_MASK, ibmr->lkey & 0xFF);\n\n\tret = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\terdma_free_idx(&dev->res_cb[ERDMA_RES_TYPE_STAG_IDX], ibmr->lkey >> 8);\n\n\tput_mtt_entries(dev, &mr->mem);\n\n\tkfree(mr);\n\treturn 0;\n}\n\nint erdma_destroy_cq(struct ib_cq *ibcq, struct ib_udata *udata)\n{\n\tstruct erdma_cq *cq = to_ecq(ibcq);\n\tstruct erdma_dev *dev = to_edev(ibcq->device);\n\tstruct erdma_ucontext *ctx = rdma_udata_to_drv_context(\n\t\tudata, struct erdma_ucontext, ibucontext);\n\tint err;\n\tstruct erdma_cmdq_destroy_cq_req req;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_DESTROY_CQ);\n\treq.cqn = cq->cqn;\n\n\terr = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\tif (rdma_is_kernel_res(&cq->ibcq.res)) {\n\t\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t\t  WARPPED_BUFSIZE(cq->depth << CQE_SHIFT),\n\t\t\t\t  cq->kern_cq.qbuf, cq->kern_cq.qbuf_dma_addr);\n\t} else {\n\t\terdma_unmap_user_dbrecords(ctx, &cq->user_cq.user_dbr_page);\n\t\tput_mtt_entries(dev, &cq->user_cq.qbuf_mem);\n\t}\n\n\txa_erase(&dev->cq_xa, cq->cqn);\n\n\treturn 0;\n}\n\nint erdma_destroy_qp(struct ib_qp *ibqp, struct ib_udata *udata)\n{\n\tstruct erdma_qp *qp = to_eqp(ibqp);\n\tstruct erdma_dev *dev = to_edev(ibqp->device);\n\tstruct erdma_ucontext *ctx = rdma_udata_to_drv_context(\n\t\tudata, struct erdma_ucontext, ibucontext);\n\tstruct erdma_qp_attrs qp_attrs;\n\tint err;\n\tstruct erdma_cmdq_destroy_qp_req req;\n\n\tdown_write(&qp->state_lock);\n\tqp_attrs.state = ERDMA_QP_STATE_ERROR;\n\terdma_modify_qp_internal(qp, &qp_attrs, ERDMA_QP_ATTR_STATE);\n\tup_write(&qp->state_lock);\n\n\tcancel_delayed_work_sync(&qp->reflush_dwork);\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_RDMA,\n\t\t\t\tCMDQ_OPCODE_DESTROY_QP);\n\treq.qpn = QP_ID(qp);\n\n\terr = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n\tif (err)\n\t\treturn err;\n\n\terdma_qp_put(qp);\n\twait_for_completion(&qp->safe_free);\n\n\tif (rdma_is_kernel_res(&qp->ibqp.res)) {\n\t\tvfree(qp->kern_qp.swr_tbl);\n\t\tvfree(qp->kern_qp.rwr_tbl);\n\t\tdma_free_coherent(\n\t\t\t&dev->pdev->dev,\n\t\t\tWARPPED_BUFSIZE(qp->attrs.rq_size << RQE_SHIFT),\n\t\t\tqp->kern_qp.rq_buf, qp->kern_qp.rq_buf_dma_addr);\n\t\tdma_free_coherent(\n\t\t\t&dev->pdev->dev,\n\t\t\tWARPPED_BUFSIZE(qp->attrs.sq_size << SQEBB_SHIFT),\n\t\t\tqp->kern_qp.sq_buf, qp->kern_qp.sq_buf_dma_addr);\n\t} else {\n\t\tput_mtt_entries(dev, &qp->user_qp.sq_mem);\n\t\tput_mtt_entries(dev, &qp->user_qp.rq_mem);\n\t\terdma_unmap_user_dbrecords(ctx, &qp->user_qp.user_dbr_page);\n\t}\n\n\tif (qp->cep)\n\t\terdma_cep_put(qp->cep);\n\txa_erase(&dev->qp_xa, QP_ID(qp));\n\n\treturn 0;\n}\n\nvoid erdma_qp_get_ref(struct ib_qp *ibqp)\n{\n\terdma_qp_get(to_eqp(ibqp));\n}\n\nvoid erdma_qp_put_ref(struct ib_qp *ibqp)\n{\n\terdma_qp_put(to_eqp(ibqp));\n}\n\nint erdma_mmap(struct ib_ucontext *ctx, struct vm_area_struct *vma)\n{\n\tstruct rdma_user_mmap_entry *rdma_entry;\n\tstruct erdma_user_mmap_entry *entry;\n\tpgprot_t prot;\n\tint err;\n\n\trdma_entry = rdma_user_mmap_entry_get(ctx, vma);\n\tif (!rdma_entry)\n\t\treturn -EINVAL;\n\n\tentry = to_emmap(rdma_entry);\n\n\tswitch (entry->mmap_flag) {\n\tcase ERDMA_MMAP_IO_NC:\n\t\t \n\t\tprot = pgprot_device(vma->vm_page_prot);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto put_entry;\n\t}\n\n\terr = rdma_user_mmap_io(ctx, vma, PFN_DOWN(entry->address), PAGE_SIZE,\n\t\t\t\tprot, rdma_entry);\n\nput_entry:\n\trdma_user_mmap_entry_put(rdma_entry);\n\treturn err;\n}\n\nvoid erdma_mmap_free(struct rdma_user_mmap_entry *rdma_entry)\n{\n\tstruct erdma_user_mmap_entry *entry = to_emmap(rdma_entry);\n\n\tkfree(entry);\n}\n\nstatic int alloc_db_resources(struct erdma_dev *dev, struct erdma_ucontext *ctx,\n\t\t\t      bool ext_db_en)\n{\n\tstruct erdma_cmdq_ext_db_req req = {};\n\tu64 val0, val1;\n\tint ret;\n\n\t \n\tif (!ext_db_en && !capable(CAP_SYS_RAWIO))\n\t\treturn -EPERM;\n\n\tif (!ext_db_en) {\n\t\tctx->sdb = dev->func_bar_addr + ERDMA_BAR_SQDB_SPACE_OFFSET;\n\t\tctx->rdb = dev->func_bar_addr + ERDMA_BAR_RQDB_SPACE_OFFSET;\n\t\tctx->cdb = dev->func_bar_addr + ERDMA_BAR_CQDB_SPACE_OFFSET;\n\t\treturn 0;\n\t}\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_COMMON,\n\t\t\t\tCMDQ_OPCODE_ALLOC_DB);\n\n\treq.cfg = FIELD_PREP(ERDMA_CMD_EXT_DB_CQ_EN_MASK, 1) |\n\t\t  FIELD_PREP(ERDMA_CMD_EXT_DB_RQ_EN_MASK, 1) |\n\t\t  FIELD_PREP(ERDMA_CMD_EXT_DB_SQ_EN_MASK, 1);\n\n\tret = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), &val0, &val1);\n\tif (ret)\n\t\treturn ret;\n\n\tctx->ext_db.enable = true;\n\tctx->ext_db.sdb_off = ERDMA_GET(val0, ALLOC_DB_RESP_SDB);\n\tctx->ext_db.rdb_off = ERDMA_GET(val0, ALLOC_DB_RESP_RDB);\n\tctx->ext_db.cdb_off = ERDMA_GET(val0, ALLOC_DB_RESP_CDB);\n\n\tctx->sdb = dev->func_bar_addr + (ctx->ext_db.sdb_off << PAGE_SHIFT);\n\tctx->cdb = dev->func_bar_addr + (ctx->ext_db.rdb_off << PAGE_SHIFT);\n\tctx->rdb = dev->func_bar_addr + (ctx->ext_db.cdb_off << PAGE_SHIFT);\n\n\treturn 0;\n}\n\nstatic void free_db_resources(struct erdma_dev *dev, struct erdma_ucontext *ctx)\n{\n\tstruct erdma_cmdq_ext_db_req req = {};\n\tint ret;\n\n\tif (!ctx->ext_db.enable)\n\t\treturn;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_COMMON,\n\t\t\t\tCMDQ_OPCODE_FREE_DB);\n\n\treq.cfg = FIELD_PREP(ERDMA_CMD_EXT_DB_CQ_EN_MASK, 1) |\n\t\t  FIELD_PREP(ERDMA_CMD_EXT_DB_RQ_EN_MASK, 1) |\n\t\t  FIELD_PREP(ERDMA_CMD_EXT_DB_SQ_EN_MASK, 1);\n\n\treq.sdb_off = ctx->ext_db.sdb_off;\n\treq.rdb_off = ctx->ext_db.rdb_off;\n\treq.cdb_off = ctx->ext_db.cdb_off;\n\n\tret = erdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n\tif (ret)\n\t\tibdev_err_ratelimited(&dev->ibdev,\n\t\t\t\t      \"free db resources failed %d\", ret);\n}\n\nstatic void erdma_uctx_user_mmap_entries_remove(struct erdma_ucontext *uctx)\n{\n\trdma_user_mmap_entry_remove(uctx->sq_db_mmap_entry);\n\trdma_user_mmap_entry_remove(uctx->rq_db_mmap_entry);\n\trdma_user_mmap_entry_remove(uctx->cq_db_mmap_entry);\n}\n\nint erdma_alloc_ucontext(struct ib_ucontext *ibctx, struct ib_udata *udata)\n{\n\tstruct erdma_ucontext *ctx = to_ectx(ibctx);\n\tstruct erdma_dev *dev = to_edev(ibctx->device);\n\tint ret;\n\tstruct erdma_uresp_alloc_ctx uresp = {};\n\n\tif (atomic_inc_return(&dev->num_ctx) > ERDMA_MAX_CONTEXT) {\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tif (udata->outlen < sizeof(uresp)) {\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tINIT_LIST_HEAD(&ctx->dbrecords_page_list);\n\tmutex_init(&ctx->dbrecords_page_mutex);\n\n\tret = alloc_db_resources(dev, ctx,\n\t\t\t\t !!(dev->attrs.cap_flags &\n\t\t\t\t    ERDMA_DEV_CAP_FLAGS_EXTEND_DB));\n\tif (ret)\n\t\tgoto err_out;\n\n\tctx->sq_db_mmap_entry = erdma_user_mmap_entry_insert(\n\t\tctx, (void *)ctx->sdb, PAGE_SIZE, ERDMA_MMAP_IO_NC, &uresp.sdb);\n\tif (!ctx->sq_db_mmap_entry) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_ext_db;\n\t}\n\n\tctx->rq_db_mmap_entry = erdma_user_mmap_entry_insert(\n\t\tctx, (void *)ctx->rdb, PAGE_SIZE, ERDMA_MMAP_IO_NC, &uresp.rdb);\n\tif (!ctx->rq_db_mmap_entry) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_mmap_entries;\n\t}\n\n\tctx->cq_db_mmap_entry = erdma_user_mmap_entry_insert(\n\t\tctx, (void *)ctx->cdb, PAGE_SIZE, ERDMA_MMAP_IO_NC, &uresp.cdb);\n\tif (!ctx->cq_db_mmap_entry) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_mmap_entries;\n\t}\n\n\turesp.dev_id = dev->pdev->device;\n\n\tret = ib_copy_to_udata(udata, &uresp, sizeof(uresp));\n\tif (ret)\n\t\tgoto err_put_mmap_entries;\n\n\treturn 0;\n\nerr_put_mmap_entries:\n\terdma_uctx_user_mmap_entries_remove(ctx);\n\nerr_free_ext_db:\n\tfree_db_resources(dev, ctx);\n\nerr_out:\n\tatomic_dec(&dev->num_ctx);\n\treturn ret;\n}\n\nvoid erdma_dealloc_ucontext(struct ib_ucontext *ibctx)\n{\n\tstruct erdma_dev *dev = to_edev(ibctx->device);\n\tstruct erdma_ucontext *ctx = to_ectx(ibctx);\n\n\terdma_uctx_user_mmap_entries_remove(ctx);\n\tfree_db_resources(dev, ctx);\n\tatomic_dec(&dev->num_ctx);\n}\n\nstatic int ib_qp_state_to_erdma_qp_state[IB_QPS_ERR + 1] = {\n\t[IB_QPS_RESET] = ERDMA_QP_STATE_IDLE,\n\t[IB_QPS_INIT] = ERDMA_QP_STATE_IDLE,\n\t[IB_QPS_RTR] = ERDMA_QP_STATE_RTR,\n\t[IB_QPS_RTS] = ERDMA_QP_STATE_RTS,\n\t[IB_QPS_SQD] = ERDMA_QP_STATE_CLOSING,\n\t[IB_QPS_SQE] = ERDMA_QP_STATE_TERMINATE,\n\t[IB_QPS_ERR] = ERDMA_QP_STATE_ERROR\n};\n\nint erdma_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,\n\t\t    struct ib_udata *udata)\n{\n\tstruct erdma_qp_attrs new_attrs;\n\tenum erdma_qp_attr_mask erdma_attr_mask = 0;\n\tstruct erdma_qp *qp = to_eqp(ibqp);\n\tint ret = 0;\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&new_attrs, 0, sizeof(new_attrs));\n\n\tif (attr_mask & IB_QP_STATE) {\n\t\tnew_attrs.state = ib_qp_state_to_erdma_qp_state[attr->qp_state];\n\n\t\terdma_attr_mask |= ERDMA_QP_ATTR_STATE;\n\t}\n\n\tdown_write(&qp->state_lock);\n\n\tret = erdma_modify_qp_internal(qp, &new_attrs, erdma_attr_mask);\n\n\tup_write(&qp->state_lock);\n\n\treturn ret;\n}\n\nint erdma_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t   int qp_attr_mask, struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct erdma_qp *qp;\n\tstruct erdma_dev *dev;\n\n\tif (ibqp && qp_attr && qp_init_attr) {\n\t\tqp = to_eqp(ibqp);\n\t\tdev = to_edev(ibqp->device);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tqp_attr->cap.max_inline_data = ERDMA_MAX_INLINE;\n\tqp_init_attr->cap.max_inline_data = ERDMA_MAX_INLINE;\n\n\tqp_attr->cap.max_send_wr = qp->attrs.sq_size;\n\tqp_attr->cap.max_recv_wr = qp->attrs.rq_size;\n\tqp_attr->cap.max_send_sge = qp->attrs.max_send_sge;\n\tqp_attr->cap.max_recv_sge = qp->attrs.max_recv_sge;\n\n\tqp_attr->path_mtu = ib_mtu_int_to_enum(dev->netdev->mtu);\n\tqp_attr->max_rd_atomic = qp->attrs.irq_size;\n\tqp_attr->max_dest_rd_atomic = qp->attrs.orq_size;\n\n\tqp_attr->qp_access_flags = IB_ACCESS_LOCAL_WRITE |\n\t\t\t\t   IB_ACCESS_REMOTE_WRITE |\n\t\t\t\t   IB_ACCESS_REMOTE_READ;\n\n\tqp_init_attr->cap = qp_attr->cap;\n\n\treturn 0;\n}\n\nstatic int erdma_init_user_cq(struct erdma_ucontext *ctx, struct erdma_cq *cq,\n\t\t\t      struct erdma_ureq_create_cq *ureq)\n{\n\tint ret;\n\tstruct erdma_dev *dev = to_edev(cq->ibcq.device);\n\n\tret = get_mtt_entries(dev, &cq->user_cq.qbuf_mem, ureq->qbuf_va,\n\t\t\t      ureq->qbuf_len, 0, ureq->qbuf_va, SZ_64M - SZ_4K,\n\t\t\t      true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = erdma_map_user_dbrecords(ctx, ureq->db_record_va,\n\t\t\t\t       &cq->user_cq.user_dbr_page,\n\t\t\t\t       &cq->user_cq.db_info_dma_addr);\n\tif (ret)\n\t\tput_mtt_entries(dev, &cq->user_cq.qbuf_mem);\n\n\treturn ret;\n}\n\nstatic int erdma_init_kernel_cq(struct erdma_cq *cq)\n{\n\tstruct erdma_dev *dev = to_edev(cq->ibcq.device);\n\n\tcq->kern_cq.qbuf =\n\t\tdma_alloc_coherent(&dev->pdev->dev,\n\t\t\t\t   WARPPED_BUFSIZE(cq->depth << CQE_SHIFT),\n\t\t\t\t   &cq->kern_cq.qbuf_dma_addr, GFP_KERNEL);\n\tif (!cq->kern_cq.qbuf)\n\t\treturn -ENOMEM;\n\n\tcq->kern_cq.db_record =\n\t\t(u64 *)(cq->kern_cq.qbuf + (cq->depth << CQE_SHIFT));\n\tspin_lock_init(&cq->kern_cq.lock);\n\t \n\tcq->kern_cq.db = dev->func_bar + ERDMA_BAR_CQDB_SPACE_OFFSET;\n\n\treturn 0;\n}\n\nint erdma_create_cq(struct ib_cq *ibcq, const struct ib_cq_init_attr *attr,\n\t\t    struct ib_udata *udata)\n{\n\tstruct erdma_cq *cq = to_ecq(ibcq);\n\tstruct erdma_dev *dev = to_edev(ibcq->device);\n\tunsigned int depth = attr->cqe;\n\tint ret;\n\tstruct erdma_ucontext *ctx = rdma_udata_to_drv_context(\n\t\tudata, struct erdma_ucontext, ibucontext);\n\n\tif (depth > dev->attrs.max_cqe)\n\t\treturn -EINVAL;\n\n\tdepth = roundup_pow_of_two(depth);\n\tcq->ibcq.cqe = depth;\n\tcq->depth = depth;\n\tcq->assoc_eqn = attr->comp_vector + 1;\n\n\tret = xa_alloc_cyclic(&dev->cq_xa, &cq->cqn, cq,\n\t\t\t      XA_LIMIT(1, dev->attrs.max_cq - 1),\n\t\t\t      &dev->next_alloc_cqn, GFP_KERNEL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!rdma_is_kernel_res(&ibcq->res)) {\n\t\tstruct erdma_ureq_create_cq ureq;\n\t\tstruct erdma_uresp_create_cq uresp;\n\n\t\tret = ib_copy_from_udata(&ureq, udata,\n\t\t\t\t\t min(udata->inlen, sizeof(ureq)));\n\t\tif (ret)\n\t\t\tgoto err_out_xa;\n\n\t\tret = erdma_init_user_cq(ctx, cq, &ureq);\n\t\tif (ret)\n\t\t\tgoto err_out_xa;\n\n\t\turesp.cq_id = cq->cqn;\n\t\turesp.num_cqe = depth;\n\n\t\tret = ib_copy_to_udata(udata, &uresp,\n\t\t\t\t       min(sizeof(uresp), udata->outlen));\n\t\tif (ret)\n\t\t\tgoto err_free_res;\n\t} else {\n\t\tret = erdma_init_kernel_cq(cq);\n\t\tif (ret)\n\t\t\tgoto err_out_xa;\n\t}\n\n\tret = create_cq_cmd(ctx, cq);\n\tif (ret)\n\t\tgoto err_free_res;\n\n\treturn 0;\n\nerr_free_res:\n\tif (!rdma_is_kernel_res(&ibcq->res)) {\n\t\terdma_unmap_user_dbrecords(ctx, &cq->user_cq.user_dbr_page);\n\t\tput_mtt_entries(dev, &cq->user_cq.qbuf_mem);\n\t} else {\n\t\tdma_free_coherent(&dev->pdev->dev,\n\t\t\t\t  WARPPED_BUFSIZE(depth << CQE_SHIFT),\n\t\t\t\t  cq->kern_cq.qbuf, cq->kern_cq.qbuf_dma_addr);\n\t}\n\nerr_out_xa:\n\txa_erase(&dev->cq_xa, cq->cqn);\n\n\treturn ret;\n}\n\nvoid erdma_set_mtu(struct erdma_dev *dev, u32 mtu)\n{\n\tstruct erdma_cmdq_config_mtu_req req;\n\n\terdma_cmdq_build_reqhdr(&req.hdr, CMDQ_SUBMOD_COMMON,\n\t\t\t\tCMDQ_OPCODE_CONF_MTU);\n\treq.mtu = mtu;\n\n\terdma_post_cmd_wait(&dev->cmdq, &req, sizeof(req), NULL, NULL);\n}\n\nvoid erdma_port_event(struct erdma_dev *dev, enum ib_event_type reason)\n{\n\tstruct ib_event event;\n\n\tevent.device = &dev->ibdev;\n\tevent.element.port_num = 1;\n\tevent.event = reason;\n\n\tib_dispatch_event(&event);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}