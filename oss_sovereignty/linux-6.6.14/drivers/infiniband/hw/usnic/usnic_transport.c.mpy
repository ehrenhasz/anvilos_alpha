{
  "module_name": "usnic_transport.c",
  "hash_id": "ca229fec0b9488ea0a2e56e744f743f53e568461f4ff278ad793be0d1e42352f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_transport.c",
  "human_readable_source": " \n#include <linux/bitmap.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <net/inet_sock.h>\n\n#include \"usnic_transport.h\"\n#include \"usnic_log.h\"\n\n \nstatic unsigned long *roce_bitmap;\nstatic u16 roce_next_port = 1;\n#define ROCE_BITMAP_SZ ((1 << (8   * sizeof(u16)))/8  )\nstatic DEFINE_SPINLOCK(roce_bitmap_lock);\n\nconst char *usnic_transport_to_str(enum usnic_transport_type type)\n{\n\tswitch (type) {\n\tcase USNIC_TRANSPORT_UNKNOWN:\n\t\treturn \"Unknown\";\n\tcase USNIC_TRANSPORT_ROCE_CUSTOM:\n\t\treturn \"roce custom\";\n\tcase USNIC_TRANSPORT_IPV4_UDP:\n\t\treturn \"IPv4 UDP\";\n\tcase USNIC_TRANSPORT_MAX:\n\t\treturn \"Max?\";\n\tdefault:\n\t\treturn \"Not known\";\n\t}\n}\n\nint usnic_transport_sock_to_str(char *buf, int buf_sz,\n\t\t\t\t\tstruct socket *sock)\n{\n\tint err;\n\tuint32_t addr;\n\tuint16_t port;\n\tint proto;\n\n\tmemset(buf, 0, buf_sz);\n\terr = usnic_transport_sock_get_addr(sock, &proto, &addr, &port);\n\tif (err)\n\t\treturn 0;\n\n\treturn scnprintf(buf, buf_sz, \"Proto:%u Addr:%pI4h Port:%hu\",\n\t\t\tproto, &addr, port);\n}\n\n \nu16 usnic_transport_rsrv_port(enum usnic_transport_type type, u16 port_num)\n{\n\tif (type == USNIC_TRANSPORT_ROCE_CUSTOM) {\n\t\tspin_lock(&roce_bitmap_lock);\n\t\tif (!port_num) {\n\t\t\tport_num = bitmap_find_next_zero_area(roce_bitmap,\n\t\t\t\t\t\tROCE_BITMAP_SZ,\n\t\t\t\t\t\troce_next_port  ,\n\t\t\t\t\t\t1  ,\n\t\t\t\t\t\t0  );\n\t\t\troce_next_port = (port_num & 4095) + 1;\n\t\t} else if (test_bit(port_num, roce_bitmap)) {\n\t\t\tusnic_err(\"Failed to allocate port for %s\\n\",\n\t\t\t\t\tusnic_transport_to_str(type));\n\t\t\tspin_unlock(&roce_bitmap_lock);\n\t\t\tgoto out_fail;\n\t\t}\n\t\tbitmap_set(roce_bitmap, port_num, 1);\n\t\tspin_unlock(&roce_bitmap_lock);\n\t} else {\n\t\tusnic_err(\"Failed to allocate port - transport %s unsupported\\n\",\n\t\t\t\tusnic_transport_to_str(type));\n\t\tgoto out_fail;\n\t}\n\n\tusnic_dbg(\"Allocating port %hu for %s\\n\", port_num,\n\t\t\tusnic_transport_to_str(type));\n\treturn port_num;\n\nout_fail:\n\treturn 0;\n}\n\nvoid usnic_transport_unrsrv_port(enum usnic_transport_type type, u16 port_num)\n{\n\tif (type == USNIC_TRANSPORT_ROCE_CUSTOM) {\n\t\tspin_lock(&roce_bitmap_lock);\n\t\tif (!port_num) {\n\t\t\tusnic_err(\"Unreserved invalid port num 0 for %s\\n\",\n\t\t\t\t\tusnic_transport_to_str(type));\n\t\t\tgoto out_roce_custom;\n\t\t}\n\n\t\tif (!test_bit(port_num, roce_bitmap)) {\n\t\t\tusnic_err(\"Unreserving invalid %hu for %s\\n\",\n\t\t\t\t\tport_num,\n\t\t\t\t\tusnic_transport_to_str(type));\n\t\t\tgoto out_roce_custom;\n\t\t}\n\t\tbitmap_clear(roce_bitmap, port_num, 1);\n\t\tusnic_dbg(\"Freeing port %hu for %s\\n\", port_num,\n\t\t\t\tusnic_transport_to_str(type));\nout_roce_custom:\n\t\tspin_unlock(&roce_bitmap_lock);\n\t} else {\n\t\tusnic_err(\"Freeing invalid port %hu for %d\\n\", port_num, type);\n\t}\n}\n\nstruct socket *usnic_transport_get_socket(int sock_fd)\n{\n\tstruct socket *sock;\n\tint err;\n\tchar buf[25];\n\n\t \n\tsock = sockfd_lookup(sock_fd, &err);\n\tif (!sock) {\n\t\tusnic_err(\"Unable to lookup socket for fd %d with err %d\\n\",\n\t\t\t\tsock_fd, err);\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tusnic_transport_sock_to_str(buf, sizeof(buf), sock);\n\tusnic_dbg(\"Get sock %s\\n\", buf);\n\n\treturn sock;\n}\n\nvoid usnic_transport_put_socket(struct socket *sock)\n{\n\tchar buf[100];\n\n\tusnic_transport_sock_to_str(buf, sizeof(buf), sock);\n\tusnic_dbg(\"Put sock %s\\n\", buf);\n\tsockfd_put(sock);\n}\n\nint usnic_transport_sock_get_addr(struct socket *sock, int *proto,\n\t\t\t\t\tuint32_t *addr, uint16_t *port)\n{\n\tint err;\n\tstruct sockaddr_in sock_addr;\n\n\terr = sock->ops->getname(sock,\n\t\t\t\t(struct sockaddr *)&sock_addr,\n\t\t\t\t0);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (sock_addr.sin_family != AF_INET)\n\t\treturn -EINVAL;\n\n\tif (proto)\n\t\t*proto = sock->sk->sk_protocol;\n\tif (port)\n\t\t*port = ntohs(((struct sockaddr_in *)&sock_addr)->sin_port);\n\tif (addr)\n\t\t*addr = ntohl(((struct sockaddr_in *)\n\t\t\t\t\t&sock_addr)->sin_addr.s_addr);\n\n\treturn 0;\n}\n\nint usnic_transport_init(void)\n{\n\troce_bitmap = kzalloc(ROCE_BITMAP_SZ, GFP_KERNEL);\n\tif (!roce_bitmap)\n\t\treturn -ENOMEM;\n\n\t \n\tbitmap_set(roce_bitmap, 0, 1);\n\treturn 0;\n}\n\nvoid usnic_transport_fini(void)\n{\n\tkfree(roce_bitmap);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}