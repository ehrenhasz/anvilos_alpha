{
  "module_name": "usnic_ib_sysfs.c",
  "hash_id": "54ead5ff25584136f082c217b21359d292e0ef86667cd19ca3bce4b07c06c79c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_ib_sysfs.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/errno.h>\n\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_addr.h>\n\n#include \"usnic_common_util.h\"\n#include \"usnic_ib.h\"\n#include \"usnic_ib_qp_grp.h\"\n#include \"usnic_vnic.h\"\n#include \"usnic_ib_verbs.h\"\n#include \"usnic_ib_sysfs.h\"\n#include \"usnic_log.h\"\n\nstatic ssize_t board_id_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\tunsigned short subsystem_device_id;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tsubsystem_device_id = us_ibdev->pdev->subsystem_device;\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn sysfs_emit(buf, \"%u\\n\", subsystem_device_id);\n}\nstatic DEVICE_ATTR_RO(board_id);\n\n \nstatic ssize_t\nconfig_show(struct device *device, struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\tenum usnic_vnic_res_type res_type;\n\tint len;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tif (kref_read(&us_ibdev->vf_cnt) > 0) {\n\t\tchar *busname;\n\t\tchar *sep = \"\";\n\t\t \n\t\tbusname = us_ibdev->pdev->bus->name;\n\t\tif (strncmp(busname, \"PCI Bus \", 8) == 0)\n\t\t\tbusname += 8;\n\n\t\tlen = sysfs_emit(buf, \"%s: %s:%d.%d, %s, %pM, %u VFs\\n\",\n\t\t\t\t dev_name(&us_ibdev->ib_dev.dev),\n\t\t\t\t busname,\n\t\t\t\t PCI_SLOT(us_ibdev->pdev->devfn),\n\t\t\t\t PCI_FUNC(us_ibdev->pdev->devfn),\n\t\t\t\t netdev_name(us_ibdev->netdev),\n\t\t\t\t us_ibdev->ufdev->mac,\n\t\t\t\t kref_read(&us_ibdev->vf_cnt));\n\n\t\tlen += sysfs_emit_at(buf, len, \" Per VF:\");\n\t\tfor (res_type = USNIC_VNIC_RES_TYPE_EOL;\n\t\t     res_type < USNIC_VNIC_RES_TYPE_MAX; res_type++) {\n\t\t\tif (us_ibdev->vf_res_cnt[res_type] == 0)\n\t\t\t\tcontinue;\n\t\t\tlen += sysfs_emit_at(buf, len, \"%s %d %s\",\n\t\t\t\t\t     sep,\n\t\t\t\t\t     us_ibdev->vf_res_cnt[res_type],\n\t\t\t\t\t     usnic_vnic_res_type_to_str(res_type));\n\t\t\tsep = \",\";\n\t\t}\n\t\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\t} else {\n\t\tlen = sysfs_emit(buf, \"%s: no VFs\\n\",\n\t\t\t\t dev_name(&us_ibdev->ib_dev.dev));\n\t}\n\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn len;\n}\nstatic DEVICE_ATTR_RO(config);\n\nstatic ssize_t\niface_show(struct device *device, struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", netdev_name(us_ibdev->netdev));\n}\nstatic DEVICE_ATTR_RO(iface);\n\nstatic ssize_t\nmax_vf_show(struct device *device, struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", kref_read(&us_ibdev->vf_cnt));\n}\nstatic DEVICE_ATTR_RO(max_vf);\n\nstatic ssize_t\nqp_per_vf_show(struct device *device, struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\tint qp_per_vf;\n\n\tqp_per_vf = max(us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_WQ],\n\t\t\tus_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_RQ]);\n\n\treturn sysfs_emit(buf, \"%d\\n\", qp_per_vf);\n}\nstatic DEVICE_ATTR_RO(qp_per_vf);\n\nstatic ssize_t\ncq_per_vf_show(struct device *device, struct device_attribute *attr, char *buf)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\trdma_device_to_drv_device(device, struct usnic_ib_dev, ib_dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\",\n\t\t\t  us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_CQ]);\n}\nstatic DEVICE_ATTR_RO(cq_per_vf);\n\nstatic struct attribute *usnic_class_attributes[] = {\n\t&dev_attr_board_id.attr,\n\t&dev_attr_config.attr,\n\t&dev_attr_iface.attr,\n\t&dev_attr_max_vf.attr,\n\t&dev_attr_qp_per_vf.attr,\n\t&dev_attr_cq_per_vf.attr,\n\tNULL\n};\n\nconst struct attribute_group usnic_attr_group = {\n\t.attrs = usnic_class_attributes,\n};\n\nstruct qpn_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct usnic_ib_qp_grp *, char *buf);\n};\n\n \nstatic ssize_t\nusnic_ib_qpn_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tstruct qpn_attribute *qpn_attr;\n\n\tqp_grp = container_of(kobj, struct usnic_ib_qp_grp, kobj);\n\tqpn_attr = container_of(attr, struct qpn_attribute, attr);\n\n\treturn qpn_attr->show(qp_grp, buf);\n}\n\nstatic const struct sysfs_ops usnic_ib_qpn_sysfs_ops = {\n\t.show = usnic_ib_qpn_attr_show\n};\n\n#define QPN_ATTR_RO(NAME) \\\nstruct qpn_attribute qpn_attr_##NAME = __ATTR_RO(NAME)\n\nstatic ssize_t context_show(struct usnic_ib_qp_grp *qp_grp, char *buf)\n{\n\treturn sysfs_emit(buf, \"0x%p\\n\", qp_grp->ctx);\n}\n\nstatic ssize_t summary_show(struct usnic_ib_qp_grp *qp_grp, char *buf)\n{\n\tint i, j;\n\tstruct usnic_vnic_res_chunk *res_chunk;\n\tstruct usnic_vnic_res *vnic_res;\n\tint len;\n\n\tlen = sysfs_emit(buf, \"QPN: %d State: (%s) PID: %u VF Idx: %hu\",\n\t\t\t qp_grp->ibqp.qp_num,\n\t\t\t usnic_ib_qp_grp_state_to_string(qp_grp->state),\n\t\t\t qp_grp->owner_pid,\n\t\t\t usnic_vnic_get_index(qp_grp->vf->vnic));\n\n\tfor (i = 0; qp_grp->res_chunk_list[i]; i++) {\n\t\tres_chunk = qp_grp->res_chunk_list[i];\n\t\tfor (j = 0; j < res_chunk->cnt; j++) {\n\t\t\tvnic_res = res_chunk->res[j];\n\t\t\tlen += sysfs_emit_at(buf, len, \" %s[%d]\",\n\t\t\t\tusnic_vnic_res_type_to_str(vnic_res->type),\n\t\t\t\tvnic_res->vnic_idx);\n\t\t}\n\t}\n\n\tlen += sysfs_emit_at(buf, len, \"\\n\");\n\n\treturn len;\n}\n\nstatic QPN_ATTR_RO(context);\nstatic QPN_ATTR_RO(summary);\n\nstatic struct attribute *usnic_ib_qpn_default_attrs[] = {\n\t&qpn_attr_context.attr,\n\t&qpn_attr_summary.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(usnic_ib_qpn_default);\n\nstatic struct kobj_type usnic_ib_qpn_type = {\n\t.sysfs_ops = &usnic_ib_qpn_sysfs_ops,\n\t.default_groups = usnic_ib_qpn_default_groups,\n};\n\nint usnic_ib_sysfs_register_usdev(struct usnic_ib_dev *us_ibdev)\n{\n\t \n\tkobject_get(&us_ibdev->ib_dev.dev.kobj);\n\tus_ibdev->qpn_kobj = kobject_create_and_add(\"qpn\",\n\t\t\t&us_ibdev->ib_dev.dev.kobj);\n\tif (us_ibdev->qpn_kobj == NULL) {\n\t\tkobject_put(&us_ibdev->ib_dev.dev.kobj);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid usnic_ib_sysfs_unregister_usdev(struct usnic_ib_dev *us_ibdev)\n{\n\tkobject_put(us_ibdev->qpn_kobj);\n}\n\nvoid usnic_ib_sysfs_qpn_add(struct usnic_ib_qp_grp *qp_grp)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tint err;\n\n\tus_ibdev = qp_grp->vf->pf;\n\n\terr = kobject_init_and_add(&qp_grp->kobj, &usnic_ib_qpn_type,\n\t\t\tkobject_get(us_ibdev->qpn_kobj),\n\t\t\t\"%d\", qp_grp->grp_id);\n\tif (err) {\n\t\tkobject_put(us_ibdev->qpn_kobj);\n\t\treturn;\n\t}\n}\n\nvoid usnic_ib_sysfs_qpn_remove(struct usnic_ib_qp_grp *qp_grp)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\n\tus_ibdev = qp_grp->vf->pf;\n\n\tkobject_put(&qp_grp->kobj);\n\tkobject_put(us_ibdev->qpn_kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}