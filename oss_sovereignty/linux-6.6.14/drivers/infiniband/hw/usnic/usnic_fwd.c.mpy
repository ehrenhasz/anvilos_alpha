{
  "module_name": "usnic_fwd.c",
  "hash_id": "66dd2cb7338f0c0e8b3bc5146c48d877363d83ab659c93aa3ea831e9a1b441b8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_fwd.c",
  "human_readable_source": " \n#include <linux/netdevice.h>\n#include <linux/pci.h>\n\n#include \"enic_api.h\"\n#include \"usnic_common_pkt_hdr.h\"\n#include \"usnic_fwd.h\"\n#include \"usnic_log.h\"\n\nstatic int usnic_fwd_devcmd_locked(struct usnic_fwd_dev *ufdev, int vnic_idx,\n\t\t\t\t\tenum vnic_devcmd_cmd cmd, u64 *a0,\n\t\t\t\t\tu64 *a1)\n{\n\tint status;\n\tstruct net_device *netdev = ufdev->netdev;\n\n\tlockdep_assert_held(&ufdev->lock);\n\n\tstatus = enic_api_devcmd_proxy_by_index(netdev,\n\t\t\tvnic_idx,\n\t\t\tcmd,\n\t\t\ta0, a1,\n\t\t\t1000);\n\tif (status) {\n\t\tif (status == ERR_EINVAL && cmd == CMD_DEL_FILTER) {\n\t\t\tusnic_dbg(\"Dev %s vnic idx %u cmd %u already deleted\",\n\t\t\t\t\tufdev->name, vnic_idx, cmd);\n\t\t} else {\n\t\t\tusnic_err(\"Dev %s vnic idx %u cmd %u failed with status %d\\n\",\n\t\t\t\t\tufdev->name, vnic_idx, cmd,\n\t\t\t\t\tstatus);\n\t\t}\n\t} else {\n\t\tusnic_dbg(\"Dev %s vnic idx %u cmd %u success\",\n\t\t\t\tufdev->name, vnic_idx, cmd);\n\t}\n\n\treturn status;\n}\n\nstatic int usnic_fwd_devcmd(struct usnic_fwd_dev *ufdev, int vnic_idx,\n\t\t\t\tenum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1)\n{\n\tint status;\n\n\tspin_lock(&ufdev->lock);\n\tstatus = usnic_fwd_devcmd_locked(ufdev, vnic_idx, cmd, a0, a1);\n\tspin_unlock(&ufdev->lock);\n\n\treturn status;\n}\n\nstruct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev)\n{\n\tstruct usnic_fwd_dev *ufdev;\n\n\tufdev = kzalloc(sizeof(*ufdev), GFP_KERNEL);\n\tif (!ufdev)\n\t\treturn NULL;\n\n\tufdev->pdev = pdev;\n\tufdev->netdev = pci_get_drvdata(pdev);\n\tspin_lock_init(&ufdev->lock);\n\tBUILD_BUG_ON(sizeof(ufdev->name) != sizeof(ufdev->netdev->name));\n\tstrcpy(ufdev->name, ufdev->netdev->name);\n\n\treturn ufdev;\n}\n\nvoid usnic_fwd_dev_free(struct usnic_fwd_dev *ufdev)\n{\n\tkfree(ufdev);\n}\n\nvoid usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, const char mac[ETH_ALEN])\n{\n\tspin_lock(&ufdev->lock);\n\tmemcpy(&ufdev->mac, mac, sizeof(ufdev->mac));\n\tspin_unlock(&ufdev->lock);\n}\n\nvoid usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)\n{\n\tspin_lock(&ufdev->lock);\n\tif (!ufdev->inaddr)\n\t\tufdev->inaddr = inaddr;\n\tspin_unlock(&ufdev->lock);\n}\n\nvoid usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev)\n{\n\tspin_lock(&ufdev->lock);\n\tufdev->inaddr = 0;\n\tspin_unlock(&ufdev->lock);\n}\n\nvoid usnic_fwd_carrier_up(struct usnic_fwd_dev *ufdev)\n{\n\tspin_lock(&ufdev->lock);\n\tufdev->link_up = 1;\n\tspin_unlock(&ufdev->lock);\n}\n\nvoid usnic_fwd_carrier_down(struct usnic_fwd_dev *ufdev)\n{\n\tspin_lock(&ufdev->lock);\n\tufdev->link_up = 0;\n\tspin_unlock(&ufdev->lock);\n}\n\nvoid usnic_fwd_set_mtu(struct usnic_fwd_dev *ufdev, unsigned int mtu)\n{\n\tspin_lock(&ufdev->lock);\n\tufdev->mtu = mtu;\n\tspin_unlock(&ufdev->lock);\n}\n\nstatic int usnic_fwd_dev_ready_locked(struct usnic_fwd_dev *ufdev)\n{\n\tlockdep_assert_held(&ufdev->lock);\n\n\tif (!ufdev->link_up)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int validate_filter_locked(struct usnic_fwd_dev *ufdev,\n\t\t\t\t\tstruct filter *filter)\n{\n\n\tlockdep_assert_held(&ufdev->lock);\n\n\tif (filter->type == FILTER_IPV4_5TUPLE) {\n\t\tif (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_AD))\n\t\t\treturn -EACCES;\n\t\tif (!(filter->u.ipv4.flags & FILTER_FIELD_5TUP_DST_PT))\n\t\t\treturn -EBUSY;\n\t\telse if (ufdev->inaddr == 0)\n\t\t\treturn -EINVAL;\n\t\telse if (filter->u.ipv4.dst_port == 0)\n\t\t\treturn -ERANGE;\n\t\telse if (ntohl(ufdev->inaddr) != filter->u.ipv4.dst_addr)\n\t\t\treturn -EFAULT;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void fill_tlv(struct filter_tlv *tlv, struct filter *filter,\n\t\tstruct filter_action *action)\n{\n\ttlv->type = CLSF_TLV_FILTER;\n\ttlv->length = sizeof(struct filter);\n\t*((struct filter *)&tlv->val) = *filter;\n\n\ttlv = (struct filter_tlv *)((char *)tlv + sizeof(struct filter_tlv) +\n\t\t\tsizeof(struct filter));\n\ttlv->type = CLSF_TLV_ACTION;\n\ttlv->length = sizeof(struct filter_action);\n\t*((struct filter_action *)&tlv->val) = *action;\n}\n\nstruct usnic_fwd_flow*\nusnic_fwd_alloc_flow(struct usnic_fwd_dev *ufdev, struct filter *filter,\n\t\t\t\tstruct usnic_filter_action *uaction)\n{\n\tstruct filter_tlv *tlv;\n\tstruct pci_dev *pdev;\n\tstruct usnic_fwd_flow *flow;\n\tuint64_t a0, a1;\n\tuint64_t tlv_size;\n\tdma_addr_t tlv_pa;\n\tint status;\n\n\tpdev = ufdev->pdev;\n\ttlv_size = (2*sizeof(struct filter_tlv) + sizeof(struct filter) +\n\t\t\tsizeof(struct filter_action));\n\n\tflow = kzalloc(sizeof(*flow), GFP_ATOMIC);\n\tif (!flow)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = dma_alloc_coherent(&pdev->dev, tlv_size, &tlv_pa, GFP_ATOMIC);\n\tif (!tlv) {\n\t\tusnic_err(\"Failed to allocate memory\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto out_free_flow;\n\t}\n\n\tfill_tlv(tlv, filter, &uaction->action);\n\n\tspin_lock(&ufdev->lock);\n\tstatus = usnic_fwd_dev_ready_locked(ufdev);\n\tif (status) {\n\t\tusnic_err(\"Forwarding dev %s not ready with status %d\\n\",\n\t\t\t\tufdev->name, status);\n\t\tgoto out_free_tlv;\n\t}\n\n\tstatus = validate_filter_locked(ufdev, filter);\n\tif (status) {\n\t\tusnic_err(\"Failed to validate filter with status %d\\n\",\n\t\t\t\tstatus);\n\t\tgoto out_free_tlv;\n\t}\n\n\t \n\ta0 = tlv_pa;\n\ta1 = tlv_size;\n\tstatus = usnic_fwd_devcmd_locked(ufdev, uaction->vnic_idx,\n\t\t\t\t\t\tCMD_ADD_FILTER, &a0, &a1);\n\tif (status) {\n\t\tusnic_err(\"VF %s Filter add failed with status:%d\",\n\t\t\t\tufdev->name, status);\n\t\tstatus = -EFAULT;\n\t\tgoto out_free_tlv;\n\t} else {\n\t\tusnic_dbg(\"VF %s FILTER ID:%llu\", ufdev->name, a0);\n\t}\n\n\tflow->flow_id = (uint32_t) a0;\n\tflow->vnic_idx = uaction->vnic_idx;\n\tflow->ufdev = ufdev;\n\nout_free_tlv:\n\tspin_unlock(&ufdev->lock);\n\tdma_free_coherent(&pdev->dev, tlv_size, tlv, tlv_pa);\n\tif (!status)\n\t\treturn flow;\nout_free_flow:\n\tkfree(flow);\n\treturn ERR_PTR(status);\n}\n\nint usnic_fwd_dealloc_flow(struct usnic_fwd_flow *flow)\n{\n\tint status;\n\tu64 a0, a1;\n\n\ta0 = flow->flow_id;\n\n\tstatus = usnic_fwd_devcmd(flow->ufdev, flow->vnic_idx,\n\t\t\t\t\tCMD_DEL_FILTER, &a0, &a1);\n\tif (status) {\n\t\tif (status == ERR_EINVAL) {\n\t\t\tusnic_dbg(\"Filter %u already deleted for VF Idx %u pf: %s status: %d\",\n\t\t\t\t\tflow->flow_id, flow->vnic_idx,\n\t\t\t\t\tflow->ufdev->name, status);\n\t\t} else {\n\t\t\tusnic_err(\"PF %s VF Idx %u Filter: %u FILTER DELETE failed with status %d\",\n\t\t\t\t\tflow->ufdev->name, flow->vnic_idx,\n\t\t\t\t\tflow->flow_id, status);\n\t\t}\n\t\tstatus = 0;\n\t\t \n\t} else {\n\t\tusnic_dbg(\"PF %s VF Idx %u Filter: %u FILTER DELETED\",\n\t\t\t\tflow->ufdev->name, flow->vnic_idx,\n\t\t\t\tflow->flow_id);\n\t}\n\n\tkfree(flow);\n\treturn status;\n}\n\nint usnic_fwd_enable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)\n{\n\tint status;\n\tstruct net_device *pf_netdev;\n\tu64 a0, a1;\n\n\tpf_netdev = ufdev->netdev;\n\ta0 = qp_idx;\n\ta1 = CMD_QP_RQWQ;\n\n\tstatus = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_ENABLE,\n\t\t\t\t\t\t&a0, &a1);\n\tif (status) {\n\t\tusnic_err(\"PF %s VNIC Index %u RQ Index: %u ENABLE Failed with status %d\",\n\t\t\t\tnetdev_name(pf_netdev),\n\t\t\t\tvnic_idx,\n\t\t\t\tqp_idx,\n\t\t\t\tstatus);\n\t} else {\n\t\tusnic_dbg(\"PF %s VNIC Index %u RQ Index: %u ENABLED\",\n\t\t\t\tnetdev_name(pf_netdev),\n\t\t\t\tvnic_idx, qp_idx);\n\t}\n\n\treturn status;\n}\n\nint usnic_fwd_disable_qp(struct usnic_fwd_dev *ufdev, int vnic_idx, int qp_idx)\n{\n\tint status;\n\tu64 a0, a1;\n\tstruct net_device *pf_netdev;\n\n\tpf_netdev = ufdev->netdev;\n\ta0 = qp_idx;\n\ta1 = CMD_QP_RQWQ;\n\n\tstatus = usnic_fwd_devcmd(ufdev, vnic_idx, CMD_QP_DISABLE,\n\t\t\t&a0, &a1);\n\tif (status) {\n\t\tusnic_err(\"PF %s VNIC Index %u RQ Index: %u DISABLE Failed with status %d\",\n\t\t\t\tnetdev_name(pf_netdev),\n\t\t\t\tvnic_idx,\n\t\t\t\tqp_idx,\n\t\t\t\tstatus);\n\t} else {\n\t\tusnic_dbg(\"PF %s VNIC Index %u RQ Index: %u DISABLED\",\n\t\t\t\tnetdev_name(pf_netdev),\n\t\t\t\tvnic_idx,\n\t\t\t\tqp_idx);\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}