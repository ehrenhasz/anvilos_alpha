{
  "module_name": "usnic_ib_verbs.c",
  "hash_id": "2aad07884b2bd064fe29b46157d9532656959ec07d949f0a969afa5c9b53197e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_ib_verbs.c",
  "human_readable_source": " \n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_addr.h>\n#include <rdma/uverbs_ioctl.h>\n\n#include \"usnic_abi.h\"\n#include \"usnic_ib.h\"\n#include \"usnic_common_util.h\"\n#include \"usnic_ib_qp_grp.h\"\n#include \"usnic_ib_verbs.h\"\n#include \"usnic_fwd.h\"\n#include \"usnic_log.h\"\n#include \"usnic_uiom.h\"\n#include \"usnic_transport.h\"\n\n#define USNIC_DEFAULT_TRANSPORT USNIC_TRANSPORT_ROCE_CUSTOM\n\nconst struct usnic_vnic_res_spec min_transport_spec[USNIC_TRANSPORT_MAX] = {\n\t{  \n\t\t.resources = {\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_EOL,\t.cnt = 0,},\n\t\t},\n\t},\n\t{  \n\t\t.resources = {\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_WQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_RQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_CQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_EOL,\t.cnt = 0,},\n\t\t},\n\t},\n\t{  \n\t\t.resources = {\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_WQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_RQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_CQ,\t.cnt = 1,},\n\t\t\t{.type = USNIC_VNIC_RES_TYPE_EOL,\t.cnt = 0,},\n\t\t},\n\t},\n};\n\nstatic void usnic_ib_fw_string_to_u64(char *fw_ver_str, u64 *fw_ver)\n{\n\t*fw_ver = *((u64 *)fw_ver_str);\n}\n\nstatic int usnic_ib_fill_create_qp_resp(struct usnic_ib_qp_grp *qp_grp,\n\t\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct usnic_ib_create_qp_resp resp;\n\tstruct pci_dev *pdev;\n\tstruct vnic_dev_bar *bar;\n\tstruct usnic_vnic_res_chunk *chunk;\n\tstruct usnic_ib_qp_grp_flow *default_flow;\n\tint i, err;\n\n\tmemset(&resp, 0, sizeof(resp));\n\n\tus_ibdev = qp_grp->vf->pf;\n\tpdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);\n\tif (!pdev) {\n\t\tusnic_err(\"Failed to get pdev of qp_grp %d\\n\",\n\t\t\t\tqp_grp->grp_id);\n\t\treturn -EFAULT;\n\t}\n\n\tbar = usnic_vnic_get_bar(qp_grp->vf->vnic, 0);\n\tif (!bar) {\n\t\tusnic_err(\"Failed to get bar0 of qp_grp %d vf %s\",\n\t\t\t\tqp_grp->grp_id, pci_name(pdev));\n\t\treturn -EFAULT;\n\t}\n\n\tresp.vfid = usnic_vnic_get_index(qp_grp->vf->vnic);\n\tresp.bar_bus_addr = bar->bus_addr;\n\tresp.bar_len = bar->len;\n\n\tchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\n\tif (IS_ERR(chunk)) {\n\t\tusnic_err(\"Failed to get chunk %s for qp_grp %d with err %ld\\n\",\n\t\t\tusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),\n\t\t\tqp_grp->grp_id,\n\t\t\tPTR_ERR(chunk));\n\t\treturn PTR_ERR(chunk);\n\t}\n\n\tWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_RQ);\n\tresp.rq_cnt = chunk->cnt;\n\tfor (i = 0; i < chunk->cnt; i++)\n\t\tresp.rq_idx[i] = chunk->res[i]->vnic_idx;\n\n\tchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_WQ);\n\tif (IS_ERR(chunk)) {\n\t\tusnic_err(\"Failed to get chunk %s for qp_grp %d with err %ld\\n\",\n\t\t\tusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_WQ),\n\t\t\tqp_grp->grp_id,\n\t\t\tPTR_ERR(chunk));\n\t\treturn PTR_ERR(chunk);\n\t}\n\n\tWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_WQ);\n\tresp.wq_cnt = chunk->cnt;\n\tfor (i = 0; i < chunk->cnt; i++)\n\t\tresp.wq_idx[i] = chunk->res[i]->vnic_idx;\n\n\tchunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_CQ);\n\tif (IS_ERR(chunk)) {\n\t\tusnic_err(\"Failed to get chunk %s for qp_grp %d with err %ld\\n\",\n\t\t\tusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_CQ),\n\t\t\tqp_grp->grp_id,\n\t\t\tPTR_ERR(chunk));\n\t\treturn PTR_ERR(chunk);\n\t}\n\n\tWARN_ON(chunk->type != USNIC_VNIC_RES_TYPE_CQ);\n\tresp.cq_cnt = chunk->cnt;\n\tfor (i = 0; i < chunk->cnt; i++)\n\t\tresp.cq_idx[i] = chunk->res[i]->vnic_idx;\n\n\tdefault_flow = list_first_entry(&qp_grp->flows_lst,\n\t\t\t\t\tstruct usnic_ib_qp_grp_flow, link);\n\tresp.transport = default_flow->trans_type;\n\n\terr = ib_copy_to_udata(udata, &resp, sizeof(resp));\n\tif (err) {\n\t\tusnic_err(\"Failed to copy udata for %s\",\n\t\t\t  dev_name(&us_ibdev->ib_dev.dev));\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfind_free_vf_and_create_qp_grp(struct ib_qp *qp,\n\t\t\t       struct usnic_transport_spec *trans_spec,\n\t\t\t       struct usnic_vnic_res_spec *res_spec)\n{\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(qp->device);\n\tstruct usnic_ib_pd *pd = to_upd(qp->pd);\n\tstruct usnic_ib_vf *vf;\n\tstruct usnic_vnic *vnic;\n\tstruct usnic_ib_qp_grp *qp_grp = to_uqp_grp(qp);\n\tstruct device *dev, **dev_list;\n\tint i, ret;\n\n\tBUG_ON(!mutex_is_locked(&us_ibdev->usdev_lock));\n\n\tif (list_empty(&us_ibdev->vf_dev_list)) {\n\t\tusnic_info(\"No vfs to allocate\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (usnic_ib_share_vf) {\n\t\t \n\t\tdev_list = usnic_uiom_get_dev_list(pd->umem_pd);\n\t\tif (IS_ERR(dev_list))\n\t\t\treturn PTR_ERR(dev_list);\n\t\tfor (i = 0; dev_list[i]; i++) {\n\t\t\tdev = dev_list[i];\n\t\t\tvf = dev_get_drvdata(dev);\n\t\t\tmutex_lock(&vf->lock);\n\t\t\tvnic = vf->vnic;\n\t\t\tif (!usnic_vnic_check_room(vnic, res_spec)) {\n\t\t\t\tusnic_dbg(\"Found used vnic %s from %s\\n\",\n\t\t\t\t\t\tdev_name(&us_ibdev->ib_dev.dev),\n\t\t\t\t\t\tpci_name(usnic_vnic_get_pdev(\n\t\t\t\t\t\t\t\t\tvnic)));\n\t\t\t\tret = usnic_ib_qp_grp_create(qp_grp,\n\t\t\t\t\t\t\t     us_ibdev->ufdev,\n\t\t\t\t\t\t\t     vf, pd, res_spec,\n\t\t\t\t\t\t\t     trans_spec);\n\n\t\t\t\tmutex_unlock(&vf->lock);\n\t\t\t\tgoto qp_grp_check;\n\t\t\t}\n\t\t\tmutex_unlock(&vf->lock);\n\n\t\t}\n\t\tusnic_uiom_free_dev_list(dev_list);\n\t\tdev_list = NULL;\n\t}\n\n\t \n\tlist_for_each_entry(vf, &us_ibdev->vf_dev_list, link) {\n\t\tmutex_lock(&vf->lock);\n\t\tvnic = vf->vnic;\n\t\tif (vf->qp_grp_ref_cnt == 0 &&\n\t\t    usnic_vnic_check_room(vnic, res_spec) == 0) {\n\t\t\tret = usnic_ib_qp_grp_create(qp_grp, us_ibdev->ufdev,\n\t\t\t\t\t\t     vf, pd, res_spec,\n\t\t\t\t\t\t     trans_spec);\n\n\t\t\tmutex_unlock(&vf->lock);\n\t\t\tgoto qp_grp_check;\n\t\t}\n\t\tmutex_unlock(&vf->lock);\n\t}\n\n\tusnic_info(\"No free qp grp found on %s\\n\",\n\t\t   dev_name(&us_ibdev->ib_dev.dev));\n\treturn -ENOMEM;\n\nqp_grp_check:\n\tif (ret) {\n\t\tusnic_err(\"Failed to allocate qp_grp\\n\");\n\t\tif (usnic_ib_share_vf)\n\t\t\tusnic_uiom_free_dev_list(dev_list);\n\t}\n\treturn ret;\n}\n\nstatic void qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)\n{\n\tstruct usnic_ib_vf *vf = qp_grp->vf;\n\n\tWARN_ON(qp_grp->state != IB_QPS_RESET);\n\n\tmutex_lock(&vf->lock);\n\tusnic_ib_qp_grp_destroy(qp_grp);\n\tmutex_unlock(&vf->lock);\n}\n\nstatic int create_qp_validate_user_data(struct usnic_ib_create_qp_cmd cmd)\n{\n\tif (cmd.spec.trans_type <= USNIC_TRANSPORT_UNKNOWN ||\n\t\t\tcmd.spec.trans_type >= USNIC_TRANSPORT_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \n\nenum rdma_link_layer usnic_ib_port_link_layer(struct ib_device *device,\n\t\t\t\t\t      u32 port_num)\n{\n\treturn IB_LINK_LAYER_ETHERNET;\n}\n\nint usnic_ib_query_device(struct ib_device *ibdev,\n\t\t\t  struct ib_device_attr *props,\n\t\t\t  struct ib_udata *uhw)\n{\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\n\tunion ib_gid gid;\n\tstruct ethtool_drvinfo info;\n\tint qp_per_vf;\n\n\tusnic_dbg(\"\\n\");\n\tif (uhw->inlen || uhw->outlen)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tus_ibdev->netdev->ethtool_ops->get_drvinfo(us_ibdev->netdev, &info);\n\tmemset(props, 0, sizeof(*props));\n\tusnic_mac_ip_to_gid(us_ibdev->ufdev->mac, us_ibdev->ufdev->inaddr,\n\t\t\t&gid.raw[0]);\n\tmemcpy(&props->sys_image_guid, &gid.global.interface_id,\n\t\tsizeof(gid.global.interface_id));\n\tusnic_ib_fw_string_to_u64(&info.fw_version[0], &props->fw_ver);\n\tprops->max_mr_size = USNIC_UIOM_MAX_MR_SIZE;\n\tprops->page_size_cap = USNIC_UIOM_PAGE_SIZE;\n\tprops->vendor_id = PCI_VENDOR_ID_CISCO;\n\tprops->vendor_part_id = PCI_DEVICE_ID_CISCO_VIC_USPACE_NIC;\n\tprops->hw_ver = us_ibdev->pdev->subsystem_device;\n\tqp_per_vf = max(us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_WQ],\n\t\t\tus_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_RQ]);\n\tprops->max_qp = qp_per_vf *\n\t\tkref_read(&us_ibdev->vf_cnt);\n\tprops->device_cap_flags = IB_DEVICE_PORT_ACTIVE_EVENT |\n\t\tIB_DEVICE_SYS_IMAGE_GUID;\n\tprops->kernel_cap_flags = IBK_BLOCK_MULTICAST_LOOPBACK;\n\tprops->max_cq = us_ibdev->vf_res_cnt[USNIC_VNIC_RES_TYPE_CQ] *\n\t\tkref_read(&us_ibdev->vf_cnt);\n\tprops->max_pd = USNIC_UIOM_MAX_PD_CNT;\n\tprops->max_mr = USNIC_UIOM_MAX_MR_CNT;\n\tprops->local_ca_ack_delay = 0;\n\tprops->max_pkeys = 0;\n\tprops->atomic_cap = IB_ATOMIC_NONE;\n\tprops->masked_atomic_cap = props->atomic_cap;\n\tprops->max_qp_rd_atom = 0;\n\tprops->max_qp_init_rd_atom = 0;\n\tprops->max_res_rd_atom = 0;\n\tprops->max_srq = 0;\n\tprops->max_srq_wr = 0;\n\tprops->max_srq_sge = 0;\n\tprops->max_fast_reg_page_list_len = 0;\n\tprops->max_mcast_grp = 0;\n\tprops->max_mcast_qp_attach = 0;\n\tprops->max_total_mcast_qp_attach = 0;\n\t \n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn 0;\n}\n\nint usnic_ib_query_port(struct ib_device *ibdev, u32 port,\n\t\t\t\tstruct ib_port_attr *props)\n{\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\n\n\tusnic_dbg(\"\\n\");\n\n\tif (ib_get_eth_speed(ibdev, port, &props->active_speed,\n\t\t\t     &props->active_width))\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&us_ibdev->usdev_lock);\n\t \n\n\tprops->lid = 0;\n\tprops->lmc = 1;\n\tprops->sm_lid = 0;\n\tprops->sm_sl = 0;\n\n\tif (!us_ibdev->ufdev->link_up) {\n\t\tprops->state = IB_PORT_DOWN;\n\t\tprops->phys_state = IB_PORT_PHYS_STATE_DISABLED;\n\t} else if (!us_ibdev->ufdev->inaddr) {\n\t\tprops->state = IB_PORT_INIT;\n\t\tprops->phys_state =\n\t\t\tIB_PORT_PHYS_STATE_PORT_CONFIGURATION_TRAINING;\n\t} else {\n\t\tprops->state = IB_PORT_ACTIVE;\n\t\tprops->phys_state = IB_PORT_PHYS_STATE_LINK_UP;\n\t}\n\n\tprops->port_cap_flags = 0;\n\tprops->gid_tbl_len = 1;\n\tprops->bad_pkey_cntr = 0;\n\tprops->qkey_viol_cntr = 0;\n\tprops->max_mtu = IB_MTU_4096;\n\tprops->active_mtu = iboe_get_mtu(us_ibdev->ufdev->mtu);\n\t \n\tprops->max_msg_sz = us_ibdev->ufdev->mtu;\n\tprops->max_vl_num = 1;\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn 0;\n}\n\nint usnic_ib_query_qp(struct ib_qp *qp, struct ib_qp_attr *qp_attr,\n\t\t\t\tint qp_attr_mask,\n\t\t\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tstruct usnic_ib_vf *vf;\n\tint err;\n\n\tusnic_dbg(\"\\n\");\n\n\tmemset(qp_attr, 0, sizeof(*qp_attr));\n\tmemset(qp_init_attr, 0, sizeof(*qp_init_attr));\n\n\tqp_grp = to_uqp_grp(qp);\n\tvf = qp_grp->vf;\n\tmutex_lock(&vf->pf->usdev_lock);\n\tusnic_dbg(\"\\n\");\n\tqp_attr->qp_state = qp_grp->state;\n\tqp_attr->cur_qp_state = qp_grp->state;\n\n\tswitch (qp_grp->ibqp.qp_type) {\n\tcase IB_QPT_UD:\n\t\tqp_attr->qkey = 0;\n\t\tbreak;\n\tdefault:\n\t\tusnic_err(\"Unexpected qp_type %d\\n\", qp_grp->ibqp.qp_type);\n\t\terr = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tmutex_unlock(&vf->pf->usdev_lock);\n\treturn 0;\n\nerr_out:\n\tmutex_unlock(&vf->pf->usdev_lock);\n\treturn err;\n}\n\nint usnic_ib_query_gid(struct ib_device *ibdev, u32 port, int index,\n\t\t\t\tunion ib_gid *gid)\n{\n\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\n\tusnic_dbg(\"\\n\");\n\n\tif (index > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tmemset(&(gid->raw[0]), 0, sizeof(gid->raw));\n\tusnic_mac_ip_to_gid(us_ibdev->ufdev->mac, us_ibdev->ufdev->inaddr,\n\t\t\t&gid->raw[0]);\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn 0;\n}\n\nint usnic_ib_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)\n{\n\tstruct usnic_ib_pd *pd = to_upd(ibpd);\n\n\tpd->umem_pd = usnic_uiom_alloc_pd(ibpd->device->dev.parent);\n\tif (IS_ERR(pd->umem_pd))\n\t\treturn PTR_ERR(pd->umem_pd);\n\n\treturn 0;\n}\n\nint usnic_ib_dealloc_pd(struct ib_pd *pd, struct ib_udata *udata)\n{\n\tusnic_uiom_dealloc_pd((to_upd(pd))->umem_pd);\n\treturn 0;\n}\n\nint usnic_ib_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *init_attr,\n\t\t       struct ib_udata *udata)\n{\n\tint err;\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct usnic_ib_qp_grp *qp_grp = to_uqp_grp(ibqp);\n\tstruct usnic_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct usnic_ib_ucontext, ibucontext);\n\tint cq_cnt;\n\tstruct usnic_vnic_res_spec res_spec;\n\tstruct usnic_ib_create_qp_cmd cmd;\n\tstruct usnic_transport_spec trans_spec;\n\n\tusnic_dbg(\"\\n\");\n\n\tus_ibdev = to_usdev(ibqp->device);\n\n\tif (init_attr->create_flags)\n\t\treturn -EOPNOTSUPP;\n\n\terr = ib_copy_from_udata(&cmd, udata, sizeof(cmd));\n\tif (err) {\n\t\tusnic_err(\"%s: cannot copy udata for create_qp\\n\",\n\t\t\t  dev_name(&us_ibdev->ib_dev.dev));\n\t\treturn -EINVAL;\n\t}\n\n\terr = create_qp_validate_user_data(cmd);\n\tif (err) {\n\t\tusnic_err(\"%s: Failed to validate user data\\n\",\n\t\t\t  dev_name(&us_ibdev->ib_dev.dev));\n\t\treturn -EINVAL;\n\t}\n\n\tif (init_attr->qp_type != IB_QPT_UD) {\n\t\tusnic_err(\"%s asked to make a non-UD QP: %d\\n\",\n\t\t\t  dev_name(&us_ibdev->ib_dev.dev), init_attr->qp_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\ttrans_spec = cmd.spec;\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tcq_cnt = (init_attr->send_cq == init_attr->recv_cq) ? 1 : 2;\n\tres_spec = min_transport_spec[trans_spec.trans_type];\n\tusnic_vnic_res_spec_update(&res_spec, USNIC_VNIC_RES_TYPE_CQ, cq_cnt);\n\terr = find_free_vf_and_create_qp_grp(ibqp, &trans_spec, &res_spec);\n\tif (err)\n\t\tgoto out_release_mutex;\n\n\terr = usnic_ib_fill_create_qp_resp(qp_grp, udata);\n\tif (err) {\n\t\terr = -EBUSY;\n\t\tgoto out_release_qp_grp;\n\t}\n\n\tqp_grp->ctx = ucontext;\n\tlist_add_tail(&qp_grp->link, &ucontext->qp_grp_list);\n\tusnic_ib_log_vf(qp_grp->vf);\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\treturn 0;\n\nout_release_qp_grp:\n\tqp_grp_destroy(qp_grp);\nout_release_mutex:\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\treturn err;\n}\n\nint usnic_ib_destroy_qp(struct ib_qp *qp, struct ib_udata *udata)\n{\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tstruct usnic_ib_vf *vf;\n\n\tusnic_dbg(\"\\n\");\n\n\tqp_grp = to_uqp_grp(qp);\n\tvf = qp_grp->vf;\n\tmutex_lock(&vf->pf->usdev_lock);\n\tif (usnic_ib_qp_grp_modify(qp_grp, IB_QPS_RESET, NULL)) {\n\t\tusnic_err(\"Failed to move qp grp %u to reset\\n\",\n\t\t\t\tqp_grp->grp_id);\n\t}\n\n\tlist_del(&qp_grp->link);\n\tqp_grp_destroy(qp_grp);\n\tmutex_unlock(&vf->pf->usdev_lock);\n\n\treturn 0;\n}\n\nint usnic_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t\tint attr_mask, struct ib_udata *udata)\n{\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tint status;\n\tusnic_dbg(\"\\n\");\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tqp_grp = to_uqp_grp(ibqp);\n\n\tmutex_lock(&qp_grp->vf->pf->usdev_lock);\n\tif ((attr_mask & IB_QP_PORT) && attr->port_num != 1) {\n\t\t \n\t\tstatus = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tif (attr_mask & IB_QP_STATE) {\n\t\tstatus = usnic_ib_qp_grp_modify(qp_grp, attr->qp_state, NULL);\n\t} else {\n\t\tusnic_err(\"Unhandled request, attr_mask=0x%x\\n\", attr_mask);\n\t\tstatus = -EINVAL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&qp_grp->vf->pf->usdev_lock);\n\treturn status;\n}\n\nint usnic_ib_create_cq(struct ib_cq *ibcq, const struct ib_cq_init_attr *attr,\n\t\t       struct ib_udata *udata)\n{\n\tif (attr->flags)\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nint usnic_ib_destroy_cq(struct ib_cq *cq, struct ib_udata *udata)\n{\n\treturn 0;\n}\n\nstruct ib_mr *usnic_ib_reg_mr(struct ib_pd *pd, u64 start, u64 length,\n\t\t\t\t\tu64 virt_addr, int access_flags,\n\t\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct usnic_ib_mr *mr;\n\tint err;\n\n\tusnic_dbg(\"start 0x%llx va 0x%llx length 0x%llx\\n\", start,\n\t\t\tvirt_addr, length);\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmr->umem = usnic_uiom_reg_get(to_upd(pd)->umem_pd, start, length,\n\t\t\t\t\taccess_flags, 0);\n\tif (IS_ERR_OR_NULL(mr->umem)) {\n\t\terr = mr->umem ? PTR_ERR(mr->umem) : -EFAULT;\n\t\tgoto err_free;\n\t}\n\n\tmr->ibmr.lkey = mr->ibmr.rkey = 0;\n\treturn &mr->ibmr;\n\nerr_free:\n\tkfree(mr);\n\treturn ERR_PTR(err);\n}\n\nint usnic_ib_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)\n{\n\tstruct usnic_ib_mr *mr = to_umr(ibmr);\n\n\tusnic_dbg(\"va 0x%lx length 0x%zx\\n\", mr->umem->va, mr->umem->length);\n\n\tusnic_uiom_reg_release(mr->umem);\n\tkfree(mr);\n\treturn 0;\n}\n\nint usnic_ib_alloc_ucontext(struct ib_ucontext *uctx, struct ib_udata *udata)\n{\n\tstruct ib_device *ibdev = uctx->device;\n\tstruct usnic_ib_ucontext *context = to_ucontext(uctx);\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(ibdev);\n\tusnic_dbg(\"\\n\");\n\n\tINIT_LIST_HEAD(&context->qp_grp_list);\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tlist_add_tail(&context->link, &us_ibdev->ctx_list);\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn 0;\n}\n\nvoid usnic_ib_dealloc_ucontext(struct ib_ucontext *ibcontext)\n{\n\tstruct usnic_ib_ucontext *context = to_uucontext(ibcontext);\n\tstruct usnic_ib_dev *us_ibdev = to_usdev(ibcontext->device);\n\tusnic_dbg(\"\\n\");\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tWARN_ON_ONCE(!list_empty(&context->qp_grp_list));\n\tlist_del(&context->link);\n\tmutex_unlock(&us_ibdev->usdev_lock);\n}\n\nint usnic_ib_mmap(struct ib_ucontext *context,\n\t\t\t\tstruct vm_area_struct *vma)\n{\n\tstruct usnic_ib_ucontext *uctx = to_ucontext(context);\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tstruct usnic_ib_vf *vf;\n\tstruct vnic_dev_bar *bar;\n\tdma_addr_t bus_addr;\n\tunsigned int len;\n\tunsigned int vfid;\n\n\tusnic_dbg(\"\\n\");\n\n\tus_ibdev = to_usdev(context->device);\n\tvm_flags_set(vma, VM_IO);\n\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\tvfid = vma->vm_pgoff;\n\tusnic_dbg(\"Page Offset %lu PAGE_SHIFT %u VFID %u\\n\",\n\t\t\tvma->vm_pgoff, PAGE_SHIFT, vfid);\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tlist_for_each_entry(qp_grp, &uctx->qp_grp_list, link) {\n\t\tvf = qp_grp->vf;\n\t\tif (usnic_vnic_get_index(vf->vnic) == vfid) {\n\t\t\tbar = usnic_vnic_get_bar(vf->vnic, 0);\n\t\t\tif ((vma->vm_end - vma->vm_start) != bar->len) {\n\t\t\t\tusnic_err(\"Bar0 Len %lu - Request map %lu\\n\",\n\t\t\t\t\t\tbar->len,\n\t\t\t\t\t\tvma->vm_end - vma->vm_start);\n\t\t\t\tmutex_unlock(&us_ibdev->usdev_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbus_addr = bar->bus_addr;\n\t\t\tlen = bar->len;\n\t\t\tusnic_dbg(\"bus: %pa vaddr: %p size: %ld\\n\",\n\t\t\t\t\t&bus_addr, bar->vaddr, bar->len);\n\t\t\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\t\t\treturn remap_pfn_range(vma,\n\t\t\t\t\t\tvma->vm_start,\n\t\t\t\t\t\tbus_addr >> PAGE_SHIFT,\n\t\t\t\t\t\tlen, vma->vm_page_prot);\n\t\t}\n\t}\n\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\tusnic_err(\"No VF %u found\\n\", vfid);\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}