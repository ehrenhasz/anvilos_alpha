{
  "module_name": "usnic_ib_main.c",
  "hash_id": "bf2eb87ec33d7e2d233395fc5fbf5dc12d6f9e69295598e6f89097af063a8d72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_ib_main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/netdevice.h>\n\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_addr.h>\n\n#include \"usnic_abi.h\"\n#include \"usnic_common_util.h\"\n#include \"usnic_ib.h\"\n#include \"usnic_ib_qp_grp.h\"\n#include \"usnic_log.h\"\n#include \"usnic_fwd.h\"\n#include \"usnic_debugfs.h\"\n#include \"usnic_ib_verbs.h\"\n#include \"usnic_transport.h\"\n#include \"usnic_uiom.h\"\n#include \"usnic_ib_sysfs.h\"\n\nunsigned int usnic_log_lvl = USNIC_LOG_LVL_ERR;\nunsigned int usnic_ib_share_vf = 1;\n\nstatic const char usnic_version[] =\n\tDRV_NAME \": Cisco VIC (USNIC) Verbs Driver v\"\n\tDRV_VERSION \" (\" DRV_RELDATE \")\\n\";\n\nstatic DEFINE_MUTEX(usnic_ib_ibdev_list_lock);\nstatic LIST_HEAD(usnic_ib_ibdev_list);\n\n \nstatic int usnic_ib_dump_vf_hdr(void *obj, char *buf, int buf_sz)\n{\n\tstruct usnic_ib_vf *vf = obj;\n\treturn scnprintf(buf, buf_sz, \"PF: %s \", dev_name(&vf->pf->ib_dev.dev));\n}\n \n\nstatic void usnic_ib_dump_vf(struct usnic_ib_vf *vf, char *buf, int buf_sz)\n{\n\tusnic_vnic_dump(vf->vnic, buf, buf_sz, vf,\n\t\t\tusnic_ib_dump_vf_hdr,\n\t\t\tusnic_ib_qp_grp_dump_hdr, usnic_ib_qp_grp_dump_rows);\n}\n\nvoid usnic_ib_log_vf(struct usnic_ib_vf *vf)\n{\n\tchar *buf = kzalloc(1000, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn;\n\n\tusnic_ib_dump_vf(vf, buf, 1000);\n\tusnic_dbg(\"%s\\n\", buf);\n\n\tkfree(buf);\n}\n\n \nstatic void usnic_ib_qp_grp_modify_active_to_err(struct usnic_ib_dev *us_ibdev)\n{\n\tstruct usnic_ib_ucontext *ctx;\n\tstruct usnic_ib_qp_grp *qp_grp;\n\tenum ib_qp_state cur_state;\n\tint status;\n\n\tBUG_ON(!mutex_is_locked(&us_ibdev->usdev_lock));\n\n\tlist_for_each_entry(ctx, &us_ibdev->ctx_list, link) {\n\t\tlist_for_each_entry(qp_grp, &ctx->qp_grp_list, link) {\n\t\t\tcur_state = qp_grp->state;\n\t\t\tif (cur_state == IB_QPS_INIT ||\n\t\t\t\tcur_state == IB_QPS_RTR ||\n\t\t\t\tcur_state == IB_QPS_RTS) {\n\t\t\t\tstatus = usnic_ib_qp_grp_modify(qp_grp,\n\t\t\t\t\t\t\t\tIB_QPS_ERR,\n\t\t\t\t\t\t\t\tNULL);\n\t\t\t\tif (status) {\n\t\t\t\t\tusnic_err(\"Failed to transition qp grp %u from %s to %s\\n\",\n\t\t\t\t\t\tqp_grp->grp_id,\n\t\t\t\t\t\tusnic_ib_qp_grp_state_to_string\n\t\t\t\t\t\t(cur_state),\n\t\t\t\t\t\tusnic_ib_qp_grp_state_to_string\n\t\t\t\t\t\t(IB_QPS_ERR));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void usnic_ib_handle_usdev_event(struct usnic_ib_dev *us_ibdev,\n\t\t\t\t\tunsigned long event)\n{\n\tstruct net_device *netdev;\n\tstruct ib_event ib_event;\n\n\tmemset(&ib_event, 0, sizeof(ib_event));\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tnetdev = us_ibdev->netdev;\n\tswitch (event) {\n\tcase NETDEV_REBOOT:\n\t\tusnic_info(\"PF Reset on %s\\n\", dev_name(&us_ibdev->ib_dev.dev));\n\t\tusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\n\t\tib_event.event = IB_EVENT_PORT_ERR;\n\t\tib_event.device = &us_ibdev->ib_dev;\n\t\tib_event.element.port_num = 1;\n\t\tib_dispatch_event(&ib_event);\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_DOWN:\n\tcase NETDEV_CHANGE:\n\t\tif (!us_ibdev->ufdev->link_up &&\n\t\t\t\tnetif_carrier_ok(netdev)) {\n\t\t\tusnic_fwd_carrier_up(us_ibdev->ufdev);\n\t\t\tusnic_info(\"Link UP on %s\\n\",\n\t\t\t\t   dev_name(&us_ibdev->ib_dev.dev));\n\t\t\tib_event.event = IB_EVENT_PORT_ACTIVE;\n\t\t\tib_event.device = &us_ibdev->ib_dev;\n\t\t\tib_event.element.port_num = 1;\n\t\t\tib_dispatch_event(&ib_event);\n\t\t} else if (us_ibdev->ufdev->link_up &&\n\t\t\t\t!netif_carrier_ok(netdev)) {\n\t\t\tusnic_fwd_carrier_down(us_ibdev->ufdev);\n\t\t\tusnic_info(\"Link DOWN on %s\\n\",\n\t\t\t\t   dev_name(&us_ibdev->ib_dev.dev));\n\t\t\tusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\n\t\t\tib_event.event = IB_EVENT_PORT_ERR;\n\t\t\tib_event.device = &us_ibdev->ib_dev;\n\t\t\tib_event.element.port_num = 1;\n\t\t\tib_dispatch_event(&ib_event);\n\t\t} else {\n\t\t\tusnic_dbg(\"Ignoring %s on %s\\n\",\n\t\t\t\t\tnetdev_cmd_to_name(event),\n\t\t\t\t\tdev_name(&us_ibdev->ib_dev.dev));\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGEADDR:\n\t\tif (!memcmp(us_ibdev->ufdev->mac, netdev->dev_addr,\n\t\t\t\tsizeof(us_ibdev->ufdev->mac))) {\n\t\t\tusnic_dbg(\"Ignoring addr change on %s\\n\",\n\t\t\t\t  dev_name(&us_ibdev->ib_dev.dev));\n\t\t} else {\n\t\t\tusnic_info(\" %s old mac: %pM new mac: %pM\\n\",\n\t\t\t\t\tdev_name(&us_ibdev->ib_dev.dev),\n\t\t\t\t\tus_ibdev->ufdev->mac,\n\t\t\t\t\tnetdev->dev_addr);\n\t\t\tusnic_fwd_set_mac(us_ibdev->ufdev, netdev->dev_addr);\n\t\t\tusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\n\t\t\tib_event.event = IB_EVENT_GID_CHANGE;\n\t\t\tib_event.device = &us_ibdev->ib_dev;\n\t\t\tib_event.element.port_num = 1;\n\t\t\tib_dispatch_event(&ib_event);\n\t\t}\n\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\tif (us_ibdev->ufdev->mtu != netdev->mtu) {\n\t\t\tusnic_info(\"MTU Change on %s old: %u new: %u\\n\",\n\t\t\t\t\tdev_name(&us_ibdev->ib_dev.dev),\n\t\t\t\t\tus_ibdev->ufdev->mtu, netdev->mtu);\n\t\t\tusnic_fwd_set_mtu(us_ibdev->ufdev, netdev->mtu);\n\t\t\tusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\n\t\t} else {\n\t\t\tusnic_dbg(\"Ignoring MTU change on %s\\n\",\n\t\t\t\t  dev_name(&us_ibdev->ib_dev.dev));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tusnic_dbg(\"Ignoring event %s on %s\",\n\t\t\t\tnetdev_cmd_to_name(event),\n\t\t\t\tdev_name(&us_ibdev->ib_dev.dev));\n\t}\n\tmutex_unlock(&us_ibdev->usdev_lock);\n}\n\nstatic int usnic_ib_netdevice_event(struct notifier_block *notifier,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct ib_device *ibdev;\n\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\n\tibdev = ib_device_get_by_netdev(netdev, RDMA_DRIVER_USNIC);\n\tif (!ibdev)\n\t\treturn NOTIFY_DONE;\n\n\tus_ibdev = container_of(ibdev, struct usnic_ib_dev, ib_dev);\n\tusnic_ib_handle_usdev_event(us_ibdev, event);\n\tib_device_put(ibdev);\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block usnic_ib_netdevice_notifier = {\n\t.notifier_call = usnic_ib_netdevice_event\n};\n \n\n \nstatic int usnic_ib_handle_inet_event(struct usnic_ib_dev *us_ibdev,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct ib_event ib_event;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\t\tusnic_info(\"%s via ip notifiers\",\n\t\t\t\tnetdev_cmd_to_name(event));\n\t\tusnic_fwd_del_ipaddr(us_ibdev->ufdev);\n\t\tusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\n\t\tib_event.event = IB_EVENT_GID_CHANGE;\n\t\tib_event.device = &us_ibdev->ib_dev;\n\t\tib_event.element.port_num = 1;\n\t\tib_dispatch_event(&ib_event);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\tusnic_fwd_add_ipaddr(us_ibdev->ufdev, ifa->ifa_address);\n\t\tusnic_info(\"%s via ip notifiers: ip %pI4\",\n\t\t\t\tnetdev_cmd_to_name(event),\n\t\t\t\t&us_ibdev->ufdev->inaddr);\n\t\tib_event.event = IB_EVENT_GID_CHANGE;\n\t\tib_event.device = &us_ibdev->ib_dev;\n\t\tib_event.element.port_num = 1;\n\t\tib_dispatch_event(&ib_event);\n\t\tbreak;\n\tdefault:\n\t\tusnic_info(\"Ignoring event %s on %s\",\n\t\t\t\tnetdev_cmd_to_name(event),\n\t\t\t\tdev_name(&us_ibdev->ib_dev.dev));\n\t}\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int usnic_ib_inetaddr_event(struct notifier_block *notifier,\n\t\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *netdev = ifa->ifa_dev->dev;\n\tstruct ib_device *ibdev;\n\n\tibdev = ib_device_get_by_netdev(netdev, RDMA_DRIVER_USNIC);\n\tif (!ibdev)\n\t\treturn NOTIFY_DONE;\n\n\tus_ibdev = container_of(ibdev, struct usnic_ib_dev, ib_dev);\n\tusnic_ib_handle_inet_event(us_ibdev, event, ptr);\n\tib_device_put(ibdev);\n\treturn NOTIFY_DONE;\n}\nstatic struct notifier_block usnic_ib_inetaddr_notifier = {\n\t.notifier_call = usnic_ib_inetaddr_event\n};\n \n\nstatic int usnic_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t        struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tint err;\n\n\timmutable->core_cap_flags = RDMA_CORE_PORT_USNIC;\n\n\terr = ib_query_port(ibdev, port_num, &attr);\n\tif (err)\n\t\treturn err;\n\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\n\treturn 0;\n}\n\nstatic void usnic_get_dev_fw_str(struct ib_device *device, char *str)\n{\n\tstruct usnic_ib_dev *us_ibdev =\n\t\tcontainer_of(device, struct usnic_ib_dev, ib_dev);\n\tstruct ethtool_drvinfo info;\n\n\tmutex_lock(&us_ibdev->usdev_lock);\n\tus_ibdev->netdev->ethtool_ops->get_drvinfo(us_ibdev->netdev, &info);\n\tmutex_unlock(&us_ibdev->usdev_lock);\n\n\tsnprintf(str, IB_FW_VERSION_NAME_MAX, \"%s\", info.fw_version);\n}\n\nstatic const struct ib_device_ops usnic_dev_ops = {\n\t.owner = THIS_MODULE,\n\t.driver_id = RDMA_DRIVER_USNIC,\n\t.uverbs_abi_ver = USNIC_UVERBS_ABI_VERSION,\n\n\t.alloc_pd = usnic_ib_alloc_pd,\n\t.alloc_ucontext = usnic_ib_alloc_ucontext,\n\t.create_cq = usnic_ib_create_cq,\n\t.create_qp = usnic_ib_create_qp,\n\t.dealloc_pd = usnic_ib_dealloc_pd,\n\t.dealloc_ucontext = usnic_ib_dealloc_ucontext,\n\t.dereg_mr = usnic_ib_dereg_mr,\n\t.destroy_cq = usnic_ib_destroy_cq,\n\t.destroy_qp = usnic_ib_destroy_qp,\n\t.device_group = &usnic_attr_group,\n\t.get_dev_fw_str = usnic_get_dev_fw_str,\n\t.get_link_layer = usnic_ib_port_link_layer,\n\t.get_port_immutable = usnic_port_immutable,\n\t.mmap = usnic_ib_mmap,\n\t.modify_qp = usnic_ib_modify_qp,\n\t.query_device = usnic_ib_query_device,\n\t.query_gid = usnic_ib_query_gid,\n\t.query_port = usnic_ib_query_port,\n\t.query_qp = usnic_ib_query_qp,\n\t.reg_user_mr = usnic_ib_reg_mr,\n\tINIT_RDMA_OBJ_SIZE(ib_pd, usnic_ib_pd, ibpd),\n\tINIT_RDMA_OBJ_SIZE(ib_cq, usnic_ib_cq, ibcq),\n\tINIT_RDMA_OBJ_SIZE(ib_qp, usnic_ib_qp_grp, ibqp),\n\tINIT_RDMA_OBJ_SIZE(ib_ucontext, usnic_ib_ucontext, ibucontext),\n};\n\n \nstatic void *usnic_ib_device_add(struct pci_dev *dev)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tunion ib_gid gid;\n\tstruct in_device *ind;\n\tstruct net_device *netdev;\n\tint ret;\n\n\tusnic_dbg(\"\\n\");\n\tnetdev = pci_get_drvdata(dev);\n\n\tus_ibdev = ib_alloc_device(usnic_ib_dev, ib_dev);\n\tif (!us_ibdev) {\n\t\tusnic_err(\"Device %s context alloc failed\\n\",\n\t\t\t\tnetdev_name(pci_get_drvdata(dev)));\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\tus_ibdev->ufdev = usnic_fwd_dev_alloc(dev);\n\tif (!us_ibdev->ufdev) {\n\t\tusnic_err(\"Failed to alloc ufdev for %s\\n\", pci_name(dev));\n\t\tgoto err_dealloc;\n\t}\n\n\tmutex_init(&us_ibdev->usdev_lock);\n\tINIT_LIST_HEAD(&us_ibdev->vf_dev_list);\n\tINIT_LIST_HEAD(&us_ibdev->ctx_list);\n\n\tus_ibdev->pdev = dev;\n\tus_ibdev->netdev = pci_get_drvdata(dev);\n\tus_ibdev->ib_dev.node_type = RDMA_NODE_USNIC_UDP;\n\tus_ibdev->ib_dev.phys_port_cnt = USNIC_IB_PORT_CNT;\n\tus_ibdev->ib_dev.num_comp_vectors = USNIC_IB_NUM_COMP_VECTORS;\n\tus_ibdev->ib_dev.dev.parent = &dev->dev;\n\n\tib_set_device_ops(&us_ibdev->ib_dev, &usnic_dev_ops);\n\n\tret = ib_device_set_netdev(&us_ibdev->ib_dev, us_ibdev->netdev, 1);\n\tif (ret)\n\t\tgoto err_fwd_dealloc;\n\n\tdma_set_max_seg_size(&dev->dev, SZ_2G);\n\tif (ib_register_device(&us_ibdev->ib_dev, \"usnic_%d\", &dev->dev))\n\t\tgoto err_fwd_dealloc;\n\n\tusnic_fwd_set_mtu(us_ibdev->ufdev, us_ibdev->netdev->mtu);\n\tusnic_fwd_set_mac(us_ibdev->ufdev, us_ibdev->netdev->dev_addr);\n\tif (netif_carrier_ok(us_ibdev->netdev))\n\t\tusnic_fwd_carrier_up(us_ibdev->ufdev);\n\n\trcu_read_lock();\n\tind = __in_dev_get_rcu(netdev);\n\tif (ind) {\n\t\tconst struct in_ifaddr *ifa;\n\n\t\tifa = rcu_dereference(ind->ifa_list);\n\t\tif (ifa)\n\t\t\tusnic_fwd_add_ipaddr(us_ibdev->ufdev, ifa->ifa_address);\n\t}\n\trcu_read_unlock();\n\n\tusnic_mac_ip_to_gid(us_ibdev->netdev->perm_addr,\n\t\t\t\tus_ibdev->ufdev->inaddr, &gid.raw[0]);\n\tmemcpy(&us_ibdev->ib_dev.node_guid, &gid.global.interface_id,\n\t\tsizeof(gid.global.interface_id));\n\tkref_init(&us_ibdev->vf_cnt);\n\n\tusnic_info(\"Added ibdev: %s netdev: %s with mac %pM Link: %u MTU: %u\\n\",\n\t\t   dev_name(&us_ibdev->ib_dev.dev),\n\t\t   netdev_name(us_ibdev->netdev), us_ibdev->ufdev->mac,\n\t\t   us_ibdev->ufdev->link_up, us_ibdev->ufdev->mtu);\n\treturn us_ibdev;\n\nerr_fwd_dealloc:\n\tusnic_fwd_dev_free(us_ibdev->ufdev);\nerr_dealloc:\n\tusnic_err(\"failed -- deallocing device\\n\");\n\tib_dealloc_device(&us_ibdev->ib_dev);\n\treturn NULL;\n}\n\nstatic void usnic_ib_device_remove(struct usnic_ib_dev *us_ibdev)\n{\n\tusnic_info(\"Unregistering %s\\n\", dev_name(&us_ibdev->ib_dev.dev));\n\tusnic_ib_sysfs_unregister_usdev(us_ibdev);\n\tusnic_fwd_dev_free(us_ibdev->ufdev);\n\tib_unregister_device(&us_ibdev->ib_dev);\n\tib_dealloc_device(&us_ibdev->ib_dev);\n}\n\nstatic void usnic_ib_undiscover_pf(struct kref *kref)\n{\n\tstruct usnic_ib_dev *us_ibdev, *tmp;\n\tstruct pci_dev *dev;\n\tbool found = false;\n\n\tdev = container_of(kref, struct usnic_ib_dev, vf_cnt)->pdev;\n\tmutex_lock(&usnic_ib_ibdev_list_lock);\n\tlist_for_each_entry_safe(us_ibdev, tmp,\n\t\t\t\t&usnic_ib_ibdev_list, ib_dev_link) {\n\t\tif (us_ibdev->pdev == dev) {\n\t\t\tlist_del(&us_ibdev->ib_dev_link);\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\tmutex_unlock(&usnic_ib_ibdev_list_lock);\n\tif (found)\n\t\tusnic_ib_device_remove(us_ibdev);\n\telse\n\t\tWARN(1, \"Failed to remove PF %s\\n\", pci_name(dev));\n}\n\nstatic struct usnic_ib_dev *usnic_ib_discover_pf(struct usnic_vnic *vnic)\n{\n\tstruct usnic_ib_dev *us_ibdev;\n\tstruct pci_dev *parent_pci, *vf_pci;\n\tint err;\n\n\tvf_pci = usnic_vnic_get_pdev(vnic);\n\tparent_pci = pci_physfn(vf_pci);\n\n\tBUG_ON(!parent_pci);\n\n\tmutex_lock(&usnic_ib_ibdev_list_lock);\n\tlist_for_each_entry(us_ibdev, &usnic_ib_ibdev_list, ib_dev_link) {\n\t\tif (us_ibdev->pdev == parent_pci) {\n\t\t\tkref_get(&us_ibdev->vf_cnt);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tus_ibdev = usnic_ib_device_add(parent_pci);\n\tif (IS_ERR_OR_NULL(us_ibdev)) {\n\t\tus_ibdev = us_ibdev ? us_ibdev : ERR_PTR(-EFAULT);\n\t\tgoto out;\n\t}\n\n\terr = usnic_ib_sysfs_register_usdev(us_ibdev);\n\tif (err) {\n\t\tusnic_ib_device_remove(us_ibdev);\n\t\tus_ibdev = ERR_PTR(err);\n\t\tgoto out;\n\t}\n\n\tlist_add(&us_ibdev->ib_dev_link, &usnic_ib_ibdev_list);\nout:\n\tmutex_unlock(&usnic_ib_ibdev_list_lock);\n\treturn us_ibdev;\n}\n \n\n \n\nstatic const struct pci_device_id usnic_ib_pci_ids[] = {\n\t{PCI_DEVICE(PCI_VENDOR_ID_CISCO, PCI_DEVICE_ID_CISCO_VIC_USPACE_NIC)},\n\t{0,}\n};\n\nstatic int usnic_ib_pci_probe(struct pci_dev *pdev,\n\t\t\t\tconst struct pci_device_id *id)\n{\n\tint err;\n\tstruct usnic_ib_dev *pf;\n\tstruct usnic_ib_vf *vf;\n\tenum usnic_vnic_res_type res_type;\n\n\tif (!device_iommu_mapped(&pdev->dev)) {\n\t\tusnic_err(\"IOMMU required but not present or enabled.  USNIC QPs will not function w/o enabling IOMMU\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tvf = kzalloc(sizeof(*vf), GFP_KERNEL);\n\tif (!vf)\n\t\treturn -ENOMEM;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tusnic_err(\"Failed to enable %s with err %d\\n\",\n\t\t\t\tpci_name(pdev), err);\n\t\tgoto out_clean_vf;\n\t}\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tusnic_err(\"Failed to request region for %s with err %d\\n\",\n\t\t\t\tpci_name(pdev), err);\n\t\tgoto out_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, vf);\n\n\tvf->vnic = usnic_vnic_alloc(pdev);\n\tif (IS_ERR_OR_NULL(vf->vnic)) {\n\t\terr = vf->vnic ? PTR_ERR(vf->vnic) : -ENOMEM;\n\t\tusnic_err(\"Failed to alloc vnic for %s with err %d\\n\",\n\t\t\t\tpci_name(pdev), err);\n\t\tgoto out_release_regions;\n\t}\n\n\tpf = usnic_ib_discover_pf(vf->vnic);\n\tif (IS_ERR_OR_NULL(pf)) {\n\t\tusnic_err(\"Failed to discover pf of vnic %s with err%ld\\n\",\n\t\t\t\tpci_name(pdev), PTR_ERR(pf));\n\t\terr = pf ? PTR_ERR(pf) : -EFAULT;\n\t\tgoto out_clean_vnic;\n\t}\n\n\tvf->pf = pf;\n\tmutex_init(&vf->lock);\n\tmutex_lock(&pf->usdev_lock);\n\tlist_add_tail(&vf->link, &pf->vf_dev_list);\n\t \n\tfor (res_type = USNIC_VNIC_RES_TYPE_EOL+1;\n\t\t\tres_type < USNIC_VNIC_RES_TYPE_MAX;\n\t\t\tres_type++) {\n\t\tpf->vf_res_cnt[res_type] = usnic_vnic_res_cnt(vf->vnic,\n\t\t\t\t\t\t\t\tres_type);\n\t}\n\n\tmutex_unlock(&pf->usdev_lock);\n\n\tusnic_info(\"Registering usnic VF %s into PF %s\\n\", pci_name(pdev),\n\t\t   dev_name(&pf->ib_dev.dev));\n\tusnic_ib_log_vf(vf);\n\treturn 0;\n\nout_clean_vnic:\n\tusnic_vnic_free(vf->vnic);\nout_release_regions:\n\tpci_set_drvdata(pdev, NULL);\n\tpci_release_regions(pdev);\nout_disable_device:\n\tpci_disable_device(pdev);\nout_clean_vf:\n\tkfree(vf);\n\treturn err;\n}\n\nstatic void usnic_ib_pci_remove(struct pci_dev *pdev)\n{\n\tstruct usnic_ib_vf *vf = pci_get_drvdata(pdev);\n\tstruct usnic_ib_dev *pf = vf->pf;\n\n\tmutex_lock(&pf->usdev_lock);\n\tlist_del(&vf->link);\n\tmutex_unlock(&pf->usdev_lock);\n\n\tkref_put(&pf->vf_cnt, usnic_ib_undiscover_pf);\n\tusnic_vnic_free(vf->vnic);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tkfree(vf);\n\n\tusnic_info(\"Removed VF %s\\n\", pci_name(pdev));\n}\n\n \nstatic struct pci_driver usnic_ib_pci_driver = {\n\t.name = DRV_NAME,\n\t.id_table = usnic_ib_pci_ids,\n\t.probe = usnic_ib_pci_probe,\n\t.remove = usnic_ib_pci_remove,\n};\n \n\n \nstatic int __init usnic_ib_init(void)\n{\n\tint err;\n\n\tprintk_once(KERN_INFO \"%s\", usnic_version);\n\n\terr = pci_register_driver(&usnic_ib_pci_driver);\n\tif (err) {\n\t\tusnic_err(\"Unable to register with PCI\\n\");\n\t\tgoto out_umem_fini;\n\t}\n\n\terr = register_netdevice_notifier(&usnic_ib_netdevice_notifier);\n\tif (err) {\n\t\tusnic_err(\"Failed to register netdev notifier\\n\");\n\t\tgoto out_pci_unreg;\n\t}\n\n\terr = register_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\n\tif (err) {\n\t\tusnic_err(\"Failed to register inet addr notifier\\n\");\n\t\tgoto out_unreg_netdev_notifier;\n\t}\n\n\terr = usnic_transport_init();\n\tif (err) {\n\t\tusnic_err(\"Failed to initialize transport\\n\");\n\t\tgoto out_unreg_inetaddr_notifier;\n\t}\n\n\tusnic_debugfs_init();\n\n\treturn 0;\n\nout_unreg_inetaddr_notifier:\n\tunregister_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\nout_unreg_netdev_notifier:\n\tunregister_netdevice_notifier(&usnic_ib_netdevice_notifier);\nout_pci_unreg:\n\tpci_unregister_driver(&usnic_ib_pci_driver);\nout_umem_fini:\n\n\treturn err;\n}\n\nstatic void __exit usnic_ib_destroy(void)\n{\n\tusnic_dbg(\"\\n\");\n\tusnic_debugfs_exit();\n\tusnic_transport_fini();\n\tunregister_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\n\tunregister_netdevice_notifier(&usnic_ib_netdevice_notifier);\n\tpci_unregister_driver(&usnic_ib_pci_driver);\n}\n\nMODULE_DESCRIPTION(\"Cisco VIC (usNIC) Verbs Driver\");\nMODULE_AUTHOR(\"Upinder Malhi <umalhi@cisco.com>\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nmodule_param(usnic_log_lvl, uint, S_IRUGO | S_IWUSR);\nmodule_param(usnic_ib_share_vf, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(usnic_log_lvl, \" Off=0, Err=1, Info=2, Debug=3\");\nMODULE_PARM_DESC(usnic_ib_share_vf, \"Off=0, On=1 VF sharing amongst QPs\");\nMODULE_DEVICE_TABLE(pci, usnic_ib_pci_ids);\n\nmodule_init(usnic_ib_init);\nmodule_exit(usnic_ib_destroy);\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}