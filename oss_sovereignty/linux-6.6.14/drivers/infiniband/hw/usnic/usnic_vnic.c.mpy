{
  "module_name": "usnic_vnic.c",
  "hash_id": "972535474e702ea2655d30014f8b367ad6d2cd38f76abeba1d8b1f28a4f696a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_vnic.c",
  "human_readable_source": " \n#include <linux/errno.h>\n#include <linux/pci.h>\n\n#include \"usnic_ib.h\"\n#include \"vnic_resource.h\"\n#include \"usnic_log.h\"\n#include \"usnic_vnic.h\"\n\nstruct usnic_vnic {\n\tstruct vnic_dev\t\t\t*vdev;\n\tstruct vnic_dev_bar\t\tbar[PCI_NUM_RESOURCES];\n\tstruct usnic_vnic_res_chunk\tchunks[USNIC_VNIC_RES_TYPE_MAX];\n\tspinlock_t\t\t\tres_lock;\n};\n\nstatic enum vnic_res_type _to_vnic_res_type(enum usnic_vnic_res_type res_type)\n{\n#define DEFINE_USNIC_VNIC_RES_AT(usnic_vnic_res_t, vnic_res_type, desc, val) \\\n\t\tvnic_res_type,\n#define DEFINE_USNIC_VNIC_RES(usnic_vnic_res_t, vnic_res_type, desc) \\\n\t\tvnic_res_type,\n\tstatic enum vnic_res_type usnic_vnic_type_2_vnic_type[] = {\n\t\t\t\t\t\tUSNIC_VNIC_RES_TYPES};\n#undef DEFINE_USNIC_VNIC_RES\n#undef DEFINE_USNIC_VNIC_RES_AT\n\n\tif (res_type >= USNIC_VNIC_RES_TYPE_MAX)\n\t\treturn RES_TYPE_MAX;\n\n\treturn usnic_vnic_type_2_vnic_type[res_type];\n}\n\nconst char *usnic_vnic_res_type_to_str(enum usnic_vnic_res_type res_type)\n{\n#define DEFINE_USNIC_VNIC_RES_AT(usnic_vnic_res_t, vnic_res_type, desc, val) \\\n\t\tdesc,\n#define DEFINE_USNIC_VNIC_RES(usnic_vnic_res_t, vnic_res_type, desc) \\\n\t\tdesc,\n\tstatic const char * const usnic_vnic_res_type_desc[] = {\n\t\t\t\t\t\tUSNIC_VNIC_RES_TYPES};\n#undef DEFINE_USNIC_VNIC_RES\n#undef DEFINE_USNIC_VNIC_RES_AT\n\n\tif (res_type >= USNIC_VNIC_RES_TYPE_MAX)\n\t\treturn \"unknown\";\n\n\treturn usnic_vnic_res_type_desc[res_type];\n\n}\n\nconst char *usnic_vnic_pci_name(struct usnic_vnic *vnic)\n{\n\treturn pci_name(usnic_vnic_get_pdev(vnic));\n}\n\nint usnic_vnic_dump(struct usnic_vnic *vnic, char *buf,\n\t\t\tint buf_sz,\n\t\t\tvoid *hdr_obj,\n\t\t\tint (*printtitle)(void *, char*, int),\n\t\t\tint (*printcols)(char *, int),\n\t\t\tint (*printrow)(void *, char *, int))\n{\n\tstruct usnic_vnic_res_chunk *chunk;\n\tstruct usnic_vnic_res *res;\n\tstruct vnic_dev_bar *bar0;\n\tint i, j, offset;\n\n\toffset = 0;\n\tbar0 = usnic_vnic_get_bar(vnic, 0);\n\toffset += scnprintf(buf + offset, buf_sz - offset,\n\t\t\t\"VF:%hu BAR0 bus_addr=%pa vaddr=0x%p size=%ld \",\n\t\t\tusnic_vnic_get_index(vnic),\n\t\t\t&bar0->bus_addr,\n\t\t\tbar0->vaddr, bar0->len);\n\tif (printtitle)\n\t\toffset += printtitle(hdr_obj, buf + offset, buf_sz - offset);\n\toffset += scnprintf(buf + offset, buf_sz - offset, \"\\n\");\n\toffset += scnprintf(buf + offset, buf_sz - offset,\n\t\t\t\"|RES\\t|CTRL_PIN\\t\\t|IN_USE\\t\");\n\tif (printcols)\n\t\toffset += printcols(buf + offset, buf_sz - offset);\n\toffset += scnprintf(buf + offset, buf_sz - offset, \"\\n\");\n\n\tspin_lock(&vnic->res_lock);\n\tfor (i = 0; i < ARRAY_SIZE(vnic->chunks); i++) {\n\t\tchunk = &vnic->chunks[i];\n\t\tfor (j = 0; j < chunk->cnt; j++) {\n\t\t\tres = chunk->res[j];\n\t\t\toffset += scnprintf(buf + offset, buf_sz - offset,\n\t\t\t\t\t\"|%s[%u]\\t|0x%p\\t|%u\\t\",\n\t\t\t\t\tusnic_vnic_res_type_to_str(res->type),\n\t\t\t\t\tres->vnic_idx, res->ctrl, !!res->owner);\n\t\t\tif (printrow) {\n\t\t\t\toffset += printrow(res->owner, buf + offset,\n\t\t\t\t\t\t\tbuf_sz - offset);\n\t\t\t}\n\t\t\toffset += scnprintf(buf + offset, buf_sz - offset,\n\t\t\t\t\t\t\"\\n\");\n\t\t}\n\t}\n\tspin_unlock(&vnic->res_lock);\n\treturn offset;\n}\n\nvoid usnic_vnic_res_spec_update(struct usnic_vnic_res_spec *spec,\n\t\t\t\tenum usnic_vnic_res_type trgt_type,\n\t\t\t\tu16 cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\n\t\tif (spec->resources[i].type == trgt_type) {\n\t\t\tspec->resources[i].cnt = cnt;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tWARN_ON(1);\n}\n\nint usnic_vnic_res_spec_satisfied(const struct usnic_vnic_res_spec *min_spec,\n\t\t\t\t\tstruct usnic_vnic_res_spec *res_spec)\n{\n\tint found, i, j;\n\n\tfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\n\t\tfound = 0;\n\n\t\tfor (j = 0; j < USNIC_VNIC_RES_TYPE_MAX; j++) {\n\t\t\tif (res_spec->resources[i].type !=\n\t\t\t\tmin_spec->resources[i].type)\n\t\t\t\tcontinue;\n\t\t\tfound = 1;\n\t\t\tif (min_spec->resources[i].cnt >\n\t\t\t\t\tres_spec->resources[i].cnt)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found)\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint usnic_vnic_spec_dump(char *buf, int buf_sz,\n\t\t\t\tstruct usnic_vnic_res_spec *res_spec)\n{\n\tenum usnic_vnic_res_type res_type;\n\tint res_cnt;\n\tint i;\n\tint offset = 0;\n\n\tfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\n\t\tres_type = res_spec->resources[i].type;\n\t\tres_cnt = res_spec->resources[i].cnt;\n\t\toffset += scnprintf(buf + offset, buf_sz - offset,\n\t\t\t\t\"Res: %s Cnt: %d \",\n\t\t\t\tusnic_vnic_res_type_to_str(res_type),\n\t\t\t\tres_cnt);\n\t}\n\n\treturn offset;\n}\n\nint usnic_vnic_check_room(struct usnic_vnic *vnic,\n\t\t\t\tstruct usnic_vnic_res_spec *res_spec)\n{\n\tint i;\n\tenum usnic_vnic_res_type res_type;\n\tint res_cnt;\n\n\tfor (i = 0; i < USNIC_VNIC_RES_TYPE_MAX; i++) {\n\t\tres_type = res_spec->resources[i].type;\n\t\tres_cnt = res_spec->resources[i].cnt;\n\n\t\tif (res_type == USNIC_VNIC_RES_TYPE_EOL)\n\t\t\tbreak;\n\n\t\tif (res_cnt > usnic_vnic_res_free_cnt(vnic, res_type))\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nint usnic_vnic_res_cnt(struct usnic_vnic *vnic,\n\t\t\t\tenum usnic_vnic_res_type type)\n{\n\treturn vnic->chunks[type].cnt;\n}\n\nint usnic_vnic_res_free_cnt(struct usnic_vnic *vnic,\n\t\t\t\tenum usnic_vnic_res_type type)\n{\n\treturn vnic->chunks[type].free_cnt;\n}\n\nstruct usnic_vnic_res_chunk *\nusnic_vnic_get_resources(struct usnic_vnic *vnic, enum usnic_vnic_res_type type,\n\t\t\t\tint cnt, void *owner)\n{\n\tstruct usnic_vnic_res_chunk *src, *ret;\n\tstruct usnic_vnic_res *res;\n\tint i;\n\n\tif (usnic_vnic_res_free_cnt(vnic, type) < cnt || cnt < 0 || !owner)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tret = kzalloc(sizeof(*ret), GFP_ATOMIC);\n\tif (!ret)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (cnt > 0) {\n\t\tret->res = kcalloc(cnt, sizeof(*(ret->res)), GFP_ATOMIC);\n\t\tif (!ret->res) {\n\t\t\tkfree(ret);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\n\t\tspin_lock(&vnic->res_lock);\n\t\tsrc = &vnic->chunks[type];\n\t\tfor (i = 0; i < src->cnt && ret->cnt < cnt; i++) {\n\t\t\tres = src->res[i];\n\t\t\tif (!res->owner) {\n\t\t\t\tsrc->free_cnt--;\n\t\t\t\tres->owner = owner;\n\t\t\t\tret->res[ret->cnt++] = res;\n\t\t\t}\n\t\t}\n\n\t\tspin_unlock(&vnic->res_lock);\n\t}\n\tret->type = type;\n\tret->vnic = vnic;\n\tWARN_ON(ret->cnt != cnt);\n\n\treturn ret;\n}\n\nvoid usnic_vnic_put_resources(struct usnic_vnic_res_chunk *chunk)\n{\n\n\tstruct usnic_vnic_res *res;\n\tint i;\n\tstruct usnic_vnic *vnic = chunk->vnic;\n\n\tif (chunk->cnt > 0) {\n\t\tspin_lock(&vnic->res_lock);\n\t\twhile ((i = --chunk->cnt) >= 0) {\n\t\t\tres = chunk->res[i];\n\t\t\tchunk->res[i] = NULL;\n\t\t\tres->owner = NULL;\n\t\t\tvnic->chunks[res->type].free_cnt++;\n\t\t}\n\t\tspin_unlock(&vnic->res_lock);\n\t}\n\n\tkfree(chunk->res);\n\tkfree(chunk);\n}\n\nu16 usnic_vnic_get_index(struct usnic_vnic *vnic)\n{\n\treturn usnic_vnic_get_pdev(vnic)->devfn - 1;\n}\n\nstatic int usnic_vnic_alloc_res_chunk(struct usnic_vnic *vnic,\n\t\t\t\t\tenum usnic_vnic_res_type type,\n\t\t\t\t\tstruct usnic_vnic_res_chunk *chunk)\n{\n\tint cnt, err, i;\n\tstruct usnic_vnic_res *res;\n\n\tcnt = vnic_dev_get_res_count(vnic->vdev, _to_vnic_res_type(type));\n\tif (cnt < 1) {\n\t\tusnic_err(\"Wrong res count with cnt %d\\n\", cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tchunk->cnt = chunk->free_cnt = cnt;\n\tchunk->res = kcalloc(cnt, sizeof(*(chunk->res)), GFP_KERNEL);\n\tif (!chunk->res)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tres = kzalloc(sizeof(*res), GFP_KERNEL);\n\t\tif (!res) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tres->type = type;\n\t\tres->vnic_idx = i;\n\t\tres->vnic = vnic;\n\t\tres->ctrl = vnic_dev_get_res(vnic->vdev,\n\t\t\t\t\t\t_to_vnic_res_type(type), i);\n\t\tchunk->res[i] = res;\n\t}\n\n\tchunk->vnic = vnic;\n\treturn 0;\nfail:\n\tfor (i--; i >= 0; i--)\n\t\tkfree(chunk->res[i]);\n\tkfree(chunk->res);\n\treturn err;\n}\n\nstatic void usnic_vnic_free_res_chunk(struct usnic_vnic_res_chunk *chunk)\n{\n\tint i;\n\tfor (i = 0; i < chunk->cnt; i++)\n\t\tkfree(chunk->res[i]);\n\tkfree(chunk->res);\n}\n\nstatic int usnic_vnic_discover_resources(struct pci_dev *pdev,\n\t\t\t\t\t\tstruct usnic_vnic *vnic)\n{\n\tenum usnic_vnic_res_type res_type;\n\tint i;\n\tint err = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\n\t\tif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tvnic->bar[i].len = pci_resource_len(pdev, i);\n\t\tvnic->bar[i].vaddr = pci_iomap(pdev, i, vnic->bar[i].len);\n\t\tif (!vnic->bar[i].vaddr) {\n\t\t\tusnic_err(\"Cannot memory-map BAR %d, aborting\\n\",\n\t\t\t\t\ti);\n\t\t\terr = -ENODEV;\n\t\t\tgoto out_clean_bar;\n\t\t}\n\t\tvnic->bar[i].bus_addr = pci_resource_start(pdev, i);\n\t}\n\n\tvnic->vdev = vnic_dev_register(NULL, pdev, pdev, vnic->bar,\n\t\t\tARRAY_SIZE(vnic->bar));\n\tif (!vnic->vdev) {\n\t\tusnic_err(\"Failed to register device %s\\n\",\n\t\t\t\tpci_name(pdev));\n\t\terr = -EINVAL;\n\t\tgoto out_clean_bar;\n\t}\n\n\tfor (res_type = USNIC_VNIC_RES_TYPE_EOL + 1;\n\t\t\tres_type < USNIC_VNIC_RES_TYPE_MAX; res_type++) {\n\t\terr = usnic_vnic_alloc_res_chunk(vnic, res_type,\n\t\t\t\t\t\t&vnic->chunks[res_type]);\n\t\tif (err)\n\t\t\tgoto out_clean_chunks;\n\t}\n\n\treturn 0;\n\nout_clean_chunks:\n\tfor (res_type--; res_type > USNIC_VNIC_RES_TYPE_EOL; res_type--)\n\t\tusnic_vnic_free_res_chunk(&vnic->chunks[res_type]);\n\tvnic_dev_unregister(vnic->vdev);\nout_clean_bar:\n\tfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\n\t\tif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tif (!vnic->bar[i].vaddr)\n\t\t\tbreak;\n\n\t\tiounmap(vnic->bar[i].vaddr);\n\t}\n\n\treturn err;\n}\n\nstruct pci_dev *usnic_vnic_get_pdev(struct usnic_vnic *vnic)\n{\n\treturn vnic_dev_get_pdev(vnic->vdev);\n}\n\nstruct vnic_dev_bar *usnic_vnic_get_bar(struct usnic_vnic *vnic,\n\t\t\t\tint bar_num)\n{\n\treturn (bar_num < ARRAY_SIZE(vnic->bar)) ? &vnic->bar[bar_num] : NULL;\n}\n\nstatic void usnic_vnic_release_resources(struct usnic_vnic *vnic)\n{\n\tint i;\n\tstruct pci_dev *pdev;\n\tenum usnic_vnic_res_type res_type;\n\n\tpdev = usnic_vnic_get_pdev(vnic);\n\n\tfor (res_type = USNIC_VNIC_RES_TYPE_EOL + 1;\n\t\t\tres_type < USNIC_VNIC_RES_TYPE_MAX; res_type++)\n\t\tusnic_vnic_free_res_chunk(&vnic->chunks[res_type]);\n\n\tvnic_dev_unregister(vnic->vdev);\n\n\tfor (i = 0; i < ARRAY_SIZE(vnic->bar); i++) {\n\t\tif (!(pci_resource_flags(pdev, i) & IORESOURCE_MEM))\n\t\t\tcontinue;\n\t\tiounmap(vnic->bar[i].vaddr);\n\t}\n}\n\nstruct usnic_vnic *usnic_vnic_alloc(struct pci_dev *pdev)\n{\n\tstruct usnic_vnic *vnic;\n\tint err = 0;\n\n\tif (!pci_is_enabled(pdev)) {\n\t\tusnic_err(\"PCI dev %s is disabled\\n\", pci_name(pdev));\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tvnic = kzalloc(sizeof(*vnic), GFP_KERNEL);\n\tif (!vnic)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tspin_lock_init(&vnic->res_lock);\n\n\terr = usnic_vnic_discover_resources(pdev, vnic);\n\tif (err) {\n\t\tusnic_err(\"Failed to discover %s resources with err %d\\n\",\n\t\t\t\tpci_name(pdev), err);\n\t\tgoto out_free_vnic;\n\t}\n\n\tusnic_dbg(\"Allocated vnic for %s\\n\", usnic_vnic_pci_name(vnic));\n\n\treturn vnic;\n\nout_free_vnic:\n\tkfree(vnic);\n\n\treturn ERR_PTR(err);\n}\n\nvoid usnic_vnic_free(struct usnic_vnic *vnic)\n{\n\tusnic_vnic_release_resources(vnic);\n\tkfree(vnic);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}