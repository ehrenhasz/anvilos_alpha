{
  "module_name": "usnic_uiom_interval_tree.c",
  "hash_id": "8c584e68d23b8a7f9ce831067459d24cdefd14cf3f5c65d6892f62ec1a56e3c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_uiom_interval_tree.c",
  "human_readable_source": " \n\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/list_sort.h>\n\n#include <linux/interval_tree_generic.h>\n#include \"usnic_uiom_interval_tree.h\"\n\n#define START(node) ((node)->start)\n#define LAST(node) ((node)->last)\n\n#define MAKE_NODE(node, start, end, ref_cnt, flags, err, err_out)\t\\\n\t\tdo {\t\t\t\t\t\t\t\\\n\t\t\tnode = usnic_uiom_interval_node_alloc(start,\t\\\n\t\t\t\t\tend, ref_cnt, flags);\t\t\\\n\t\t\t\tif (!node) {\t\t\t\t\\\n\t\t\t\t\terr = -ENOMEM;\t\t\t\\\n\t\t\t\t\tgoto err_out;\t\t\t\\\n\t\t\t\t}\t\t\t\t\t\\\n\t\t} while (0)\n\n#define MARK_FOR_ADD(node, list) (list_add_tail(&node->link, list))\n\n#define MAKE_NODE_AND_APPEND(node, start, end, ref_cnt, flags, err,\t\\\n\t\t\t\terr_out, list)\t\t\t\t\\\n\t\t\t\tdo {\t\t\t\t\t\\\n\t\t\t\t\tMAKE_NODE(node, start, end,\t\\\n\t\t\t\t\t\tref_cnt, flags, err,\t\\\n\t\t\t\t\t\terr_out);\t\t\\\n\t\t\t\t\tMARK_FOR_ADD(node, list);\t\\\n\t\t\t\t} while (0)\n\n#define FLAGS_EQUAL(flags1, flags2, mask)\t\t\t\t\\\n\t\t\t(((flags1) & (mask)) == ((flags2) & (mask)))\n\nstatic struct usnic_uiom_interval_node*\nusnic_uiom_interval_node_alloc(long int start, long int last, int ref_cnt,\n\t\t\t\tint flags)\n{\n\tstruct usnic_uiom_interval_node *interval = kzalloc(sizeof(*interval),\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\n\tif (!interval)\n\t\treturn NULL;\n\n\tinterval->start = start;\n\tinterval->last = last;\n\tinterval->flags = flags;\n\tinterval->ref_cnt = ref_cnt;\n\n\treturn interval;\n}\n\nstatic int interval_cmp(void *priv, const struct list_head *a,\n\t\t\tconst struct list_head *b)\n{\n\tstruct usnic_uiom_interval_node *node_a, *node_b;\n\n\tnode_a = list_entry(a, struct usnic_uiom_interval_node, link);\n\tnode_b = list_entry(b, struct usnic_uiom_interval_node, link);\n\n\t \n\tif (node_a->start < node_b->start)\n\t\treturn -1;\n\telse if (node_a->start > node_b->start)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void\nfind_intervals_intersection_sorted(struct rb_root_cached *root,\n\t\t\t\t   unsigned long start, unsigned long last,\n\t\t\t\t   struct list_head *list)\n{\n\tstruct usnic_uiom_interval_node *node;\n\n\tINIT_LIST_HEAD(list);\n\n\tfor (node = usnic_uiom_interval_tree_iter_first(root, start, last);\n\t\tnode;\n\t\tnode = usnic_uiom_interval_tree_iter_next(node, start, last))\n\t\tlist_add_tail(&node->link, list);\n\n\tlist_sort(NULL, list, interval_cmp);\n}\n\nint usnic_uiom_get_intervals_diff(unsigned long start, unsigned long last,\n\t\t\t\t\tint flags, int flag_mask,\n\t\t\t\t\tstruct rb_root_cached *root,\n\t\t\t\t\tstruct list_head *diff_set)\n{\n\tstruct usnic_uiom_interval_node *interval, *tmp;\n\tint err = 0;\n\tlong int pivot = start;\n\tLIST_HEAD(intersection_set);\n\n\tINIT_LIST_HEAD(diff_set);\n\n\tfind_intervals_intersection_sorted(root, start, last,\n\t\t\t\t\t\t&intersection_set);\n\n\tlist_for_each_entry(interval, &intersection_set, link) {\n\t\tif (pivot < interval->start) {\n\t\t\tMAKE_NODE_AND_APPEND(tmp, pivot, interval->start - 1,\n\t\t\t\t\t\t1, flags, err, err_out,\n\t\t\t\t\t\tdiff_set);\n\t\t\tpivot = interval->start;\n\t\t}\n\n\t\t \n\n\t\tif (pivot > interval->last) {\n\t\t\tcontinue;\n\t\t} else if (pivot <= interval->last &&\n\t\t\t\tFLAGS_EQUAL(interval->flags, flags,\n\t\t\t\tflag_mask)) {\n\t\t\tpivot = interval->last + 1;\n\t\t}\n\t}\n\n\tif (pivot <= last)\n\t\tMAKE_NODE_AND_APPEND(tmp, pivot, last, 1, flags, err, err_out,\n\t\t\t\t\tdiff_set);\n\n\treturn 0;\n\nerr_out:\n\tlist_for_each_entry_safe(interval, tmp, diff_set, link) {\n\t\tlist_del(&interval->link);\n\t\tkfree(interval);\n\t}\n\n\treturn err;\n}\n\nvoid usnic_uiom_put_interval_set(struct list_head *intervals)\n{\n\tstruct usnic_uiom_interval_node *interval, *tmp;\n\tlist_for_each_entry_safe(interval, tmp, intervals, link)\n\t\tkfree(interval);\n}\n\nint usnic_uiom_insert_interval(struct rb_root_cached *root, unsigned long start,\n\t\t\t\tunsigned long last, int flags)\n{\n\tstruct usnic_uiom_interval_node *interval, *tmp;\n\tunsigned long istart, ilast;\n\tint iref_cnt, iflags;\n\tunsigned long lpivot = start;\n\tint err = 0;\n\tLIST_HEAD(to_add);\n\tLIST_HEAD(intersection_set);\n\n\tfind_intervals_intersection_sorted(root, start, last,\n\t\t\t\t\t\t&intersection_set);\n\n\tlist_for_each_entry(interval, &intersection_set, link) {\n\t\t \n\t\tistart = interval->start;\n\t\tilast = interval->last;\n\t\tiref_cnt = interval->ref_cnt;\n\t\tiflags = interval->flags;\n\n\t\tif (istart < lpivot) {\n\t\t\tMAKE_NODE_AND_APPEND(tmp, istart, lpivot - 1, iref_cnt,\n\t\t\t\t\t\tiflags, err, err_out, &to_add);\n\t\t} else if (istart > lpivot) {\n\t\t\tMAKE_NODE_AND_APPEND(tmp, lpivot, istart - 1, 1, flags,\n\t\t\t\t\t\terr, err_out, &to_add);\n\t\t\tlpivot = istart;\n\t\t} else {\n\t\t\tlpivot = istart;\n\t\t}\n\n\t\tif (ilast > last) {\n\t\t\tMAKE_NODE_AND_APPEND(tmp, lpivot, last, iref_cnt + 1,\n\t\t\t\t\t\tiflags | flags, err, err_out,\n\t\t\t\t\t\t&to_add);\n\t\t\tMAKE_NODE_AND_APPEND(tmp, last + 1, ilast, iref_cnt,\n\t\t\t\t\t\tiflags, err, err_out, &to_add);\n\t\t} else {\n\t\t\tMAKE_NODE_AND_APPEND(tmp, lpivot, ilast, iref_cnt + 1,\n\t\t\t\t\t\tiflags | flags, err, err_out,\n\t\t\t\t\t\t&to_add);\n\t\t}\n\n\t\tlpivot = ilast + 1;\n\t}\n\n\tif (lpivot <= last)\n\t\tMAKE_NODE_AND_APPEND(tmp, lpivot, last, 1, flags, err, err_out,\n\t\t\t\t\t&to_add);\n\n\tlist_for_each_entry_safe(interval, tmp, &intersection_set, link) {\n\t\tusnic_uiom_interval_tree_remove(interval, root);\n\t\tkfree(interval);\n\t}\n\n\tlist_for_each_entry(interval, &to_add, link)\n\t\tusnic_uiom_interval_tree_insert(interval, root);\n\n\treturn 0;\n\nerr_out:\n\tlist_for_each_entry_safe(interval, tmp, &to_add, link)\n\t\tkfree(interval);\n\n\treturn err;\n}\n\nvoid usnic_uiom_remove_interval(struct rb_root_cached *root,\n\t\t\t\tunsigned long start, unsigned long last,\n\t\t\t\tstruct list_head *removed)\n{\n\tstruct usnic_uiom_interval_node *interval;\n\n\tfor (interval = usnic_uiom_interval_tree_iter_first(root, start, last);\n\t\t\tinterval;\n\t\t\tinterval = usnic_uiom_interval_tree_iter_next(interval,\n\t\t\t\t\t\t\t\t\tstart,\n\t\t\t\t\t\t\t\t\tlast)) {\n\t\tif (--interval->ref_cnt == 0)\n\t\t\tlist_add_tail(&interval->link, removed);\n\t}\n\n\tlist_for_each_entry(interval, removed, link)\n\t\tusnic_uiom_interval_tree_remove(interval, root);\n}\n\nINTERVAL_TREE_DEFINE(struct usnic_uiom_interval_node, rb,\n\t\t\tunsigned long, __subtree_last,\n\t\t\tSTART, LAST, , usnic_uiom_interval_tree)\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}