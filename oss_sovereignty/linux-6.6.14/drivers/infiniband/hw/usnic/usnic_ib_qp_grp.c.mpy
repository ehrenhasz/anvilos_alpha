{
  "module_name": "usnic_ib_qp_grp.c",
  "hash_id": "cfe03a7d2ad07ba33e274a6e5c8544737341309764e906f17b81354037b5c034",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_ib_qp_grp.c",
  "human_readable_source": " \n#include <linux/bug.h>\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n\n#include \"usnic_log.h\"\n#include \"usnic_vnic.h\"\n#include \"usnic_fwd.h\"\n#include \"usnic_uiom.h\"\n#include \"usnic_debugfs.h\"\n#include \"usnic_ib_qp_grp.h\"\n#include \"usnic_ib_sysfs.h\"\n#include \"usnic_transport.h\"\n\n#define DFLT_RQ_IDX\t0\n\nconst char *usnic_ib_qp_grp_state_to_string(enum ib_qp_state state)\n{\n\tswitch (state) {\n\tcase IB_QPS_RESET:\n\t\treturn \"Rst\";\n\tcase IB_QPS_INIT:\n\t\treturn \"Init\";\n\tcase IB_QPS_RTR:\n\t\treturn \"RTR\";\n\tcase IB_QPS_RTS:\n\t\treturn \"RTS\";\n\tcase IB_QPS_SQD:\n\t\treturn \"SQD\";\n\tcase IB_QPS_SQE:\n\t\treturn \"SQE\";\n\tcase IB_QPS_ERR:\n\t\treturn \"ERR\";\n\tdefault:\n\t\treturn \"UNKNOWN STATE\";\n\n\t}\n}\n\nint usnic_ib_qp_grp_dump_hdr(char *buf, int buf_sz)\n{\n\treturn scnprintf(buf, buf_sz, \"|QPN\\t|State\\t|PID\\t|VF Idx\\t|Fil ID\");\n}\n\nint usnic_ib_qp_grp_dump_rows(void *obj, char *buf, int buf_sz)\n{\n\tstruct usnic_ib_qp_grp *qp_grp = obj;\n\tstruct usnic_ib_qp_grp_flow *default_flow;\n\tif (obj) {\n\t\tdefault_flow = list_first_entry(&qp_grp->flows_lst,\n\t\t\t\t\tstruct usnic_ib_qp_grp_flow, link);\n\t\treturn scnprintf(buf, buf_sz, \"|%d\\t|%s\\t|%d\\t|%hu\\t|%d\",\n\t\t\t\t\tqp_grp->ibqp.qp_num,\n\t\t\t\t\tusnic_ib_qp_grp_state_to_string(\n\t\t\t\t\t\t\tqp_grp->state),\n\t\t\t\t\tqp_grp->owner_pid,\n\t\t\t\t\tusnic_vnic_get_index(qp_grp->vf->vnic),\n\t\t\t\t\tdefault_flow->flow->flow_id);\n\t} else {\n\t\treturn scnprintf(buf, buf_sz, \"|N/A\\t|N/A\\t|N/A\\t|N/A\\t|N/A\");\n\t}\n}\n\nstatic struct usnic_vnic_res_chunk *\nget_qp_res_chunk(struct usnic_ib_qp_grp *qp_grp)\n{\n\tlockdep_assert_held(&qp_grp->lock);\n\t \n\treturn usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\n}\n\nstatic int enable_qp_grp(struct usnic_ib_qp_grp *qp_grp)\n{\n\n\tint status;\n\tint i, vnic_idx;\n\tstruct usnic_vnic_res_chunk *res_chunk;\n\tstruct usnic_vnic_res *res;\n\n\tlockdep_assert_held(&qp_grp->lock);\n\n\tvnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\n\n\tres_chunk = get_qp_res_chunk(qp_grp);\n\tif (IS_ERR(res_chunk)) {\n\t\tusnic_err(\"Unable to get qp res with err %ld\\n\",\n\t\t\t\tPTR_ERR(res_chunk));\n\t\treturn PTR_ERR(res_chunk);\n\t}\n\n\tfor (i = 0; i < res_chunk->cnt; i++) {\n\t\tres = res_chunk->res[i];\n\t\tstatus = usnic_fwd_enable_qp(qp_grp->ufdev, vnic_idx,\n\t\t\t\t\t\tres->vnic_idx);\n\t\tif (status) {\n\t\t\tusnic_err(\"Failed to enable qp %d of %s:%d\\n with err %d\\n\",\n\t\t\t\t\tres->vnic_idx, qp_grp->ufdev->name,\n\t\t\t\t\tvnic_idx, status);\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\treturn 0;\n\nout_err:\n\tfor (i--; i >= 0; i--) {\n\t\tres = res_chunk->res[i];\n\t\tusnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,\n\t\t\t\t\tres->vnic_idx);\n\t}\n\n\treturn status;\n}\n\nstatic int disable_qp_grp(struct usnic_ib_qp_grp *qp_grp)\n{\n\tint i, vnic_idx;\n\tstruct usnic_vnic_res_chunk *res_chunk;\n\tstruct usnic_vnic_res *res;\n\tint status = 0;\n\n\tlockdep_assert_held(&qp_grp->lock);\n\tvnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\n\n\tres_chunk = get_qp_res_chunk(qp_grp);\n\tif (IS_ERR(res_chunk)) {\n\t\tusnic_err(\"Unable to get qp res with err %ld\\n\",\n\t\t\tPTR_ERR(res_chunk));\n\t\treturn PTR_ERR(res_chunk);\n\t}\n\n\tfor (i = 0; i < res_chunk->cnt; i++) {\n\t\tres = res_chunk->res[i];\n\t\tstatus = usnic_fwd_disable_qp(qp_grp->ufdev, vnic_idx,\n\t\t\t\t\t\tres->vnic_idx);\n\t\tif (status) {\n\t\t\tusnic_err(\"Failed to disable rq %d of %s:%d\\n with err %d\\n\",\n\t\t\t\t\tres->vnic_idx,\n\t\t\t\t\tqp_grp->ufdev->name,\n\t\t\t\t\tvnic_idx, status);\n\t\t}\n\t}\n\n\treturn status;\n\n}\n\nstatic int init_filter_action(struct usnic_ib_qp_grp *qp_grp,\n\t\t\t\tstruct usnic_filter_action *uaction)\n{\n\tstruct usnic_vnic_res_chunk *res_chunk;\n\n\tres_chunk = usnic_ib_qp_grp_get_chunk(qp_grp, USNIC_VNIC_RES_TYPE_RQ);\n\tif (IS_ERR(res_chunk)) {\n\t\tusnic_err(\"Unable to get %s with err %ld\\n\",\n\t\t\tusnic_vnic_res_type_to_str(USNIC_VNIC_RES_TYPE_RQ),\n\t\t\tPTR_ERR(res_chunk));\n\t\treturn PTR_ERR(res_chunk);\n\t}\n\n\tuaction->vnic_idx = usnic_vnic_get_index(qp_grp->vf->vnic);\n\tuaction->action.type = FILTER_ACTION_RQ_STEERING;\n\tuaction->action.u.rq_idx = res_chunk->res[DFLT_RQ_IDX]->vnic_idx;\n\n\treturn 0;\n}\n\nstatic struct usnic_ib_qp_grp_flow*\ncreate_roce_custom_flow(struct usnic_ib_qp_grp *qp_grp,\n\t\t\tstruct usnic_transport_spec *trans_spec)\n{\n\tuint16_t port_num;\n\tint err;\n\tstruct filter filter;\n\tstruct usnic_filter_action uaction;\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\tstruct usnic_fwd_flow *flow;\n\tenum usnic_transport_type trans_type;\n\n\ttrans_type = trans_spec->trans_type;\n\tport_num = trans_spec->usnic_roce.port_num;\n\n\t \n\tport_num = usnic_transport_rsrv_port(trans_type, port_num);\n\tif (port_num == 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\t \n\tusnic_fwd_init_usnic_filter(&filter, port_num);\n\terr = init_filter_action(qp_grp, &uaction);\n\tif (err)\n\t\tgoto out_unreserve_port;\n\n\tflow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);\n\tif (IS_ERR_OR_NULL(flow)) {\n\t\terr = flow ? PTR_ERR(flow) : -EFAULT;\n\t\tgoto out_unreserve_port;\n\t}\n\n\t \n\tqp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);\n\tif (!qp_flow) {\n\t\terr = -ENOMEM;\n\t\tgoto out_dealloc_flow;\n\t}\n\tqp_flow->flow = flow;\n\tqp_flow->trans_type = trans_type;\n\tqp_flow->usnic_roce.port_num = port_num;\n\tqp_flow->qp_grp = qp_grp;\n\treturn qp_flow;\n\nout_dealloc_flow:\n\tusnic_fwd_dealloc_flow(flow);\nout_unreserve_port:\n\tusnic_transport_unrsrv_port(trans_type, port_num);\n\treturn ERR_PTR(err);\n}\n\nstatic void release_roce_custom_flow(struct usnic_ib_qp_grp_flow *qp_flow)\n{\n\tusnic_fwd_dealloc_flow(qp_flow->flow);\n\tusnic_transport_unrsrv_port(qp_flow->trans_type,\n\t\t\t\t\tqp_flow->usnic_roce.port_num);\n\tkfree(qp_flow);\n}\n\nstatic struct usnic_ib_qp_grp_flow*\ncreate_udp_flow(struct usnic_ib_qp_grp *qp_grp,\n\t\tstruct usnic_transport_spec *trans_spec)\n{\n\tstruct socket *sock;\n\tint sock_fd;\n\tint err;\n\tstruct filter filter;\n\tstruct usnic_filter_action uaction;\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\tstruct usnic_fwd_flow *flow;\n\tenum usnic_transport_type trans_type;\n\tuint32_t addr;\n\tuint16_t port_num;\n\tint proto;\n\n\ttrans_type = trans_spec->trans_type;\n\tsock_fd = trans_spec->udp.sock_fd;\n\n\t \n\tsock = usnic_transport_get_socket(sock_fd);\n\tif (IS_ERR_OR_NULL(sock))\n\t\treturn ERR_CAST(sock);\n\n\terr = usnic_transport_sock_get_addr(sock, &proto, &addr, &port_num);\n\tif (err)\n\t\tgoto out_put_sock;\n\n\tif (proto != IPPROTO_UDP) {\n\t\tusnic_err(\"Protocol for fd %d is not UDP\", sock_fd);\n\t\terr = -EPERM;\n\t\tgoto out_put_sock;\n\t}\n\n\t \n\tusnic_fwd_init_udp_filter(&filter, addr, port_num);\n\terr = init_filter_action(qp_grp, &uaction);\n\tif (err)\n\t\tgoto out_put_sock;\n\n\tflow = usnic_fwd_alloc_flow(qp_grp->ufdev, &filter, &uaction);\n\tif (IS_ERR_OR_NULL(flow)) {\n\t\terr = flow ? PTR_ERR(flow) : -EFAULT;\n\t\tgoto out_put_sock;\n\t}\n\n\t \n\tqp_flow = kzalloc(sizeof(*qp_flow), GFP_ATOMIC);\n\tif (!qp_flow) {\n\t\terr = -ENOMEM;\n\t\tgoto out_dealloc_flow;\n\t}\n\tqp_flow->flow = flow;\n\tqp_flow->trans_type = trans_type;\n\tqp_flow->udp.sock = sock;\n\tqp_flow->qp_grp = qp_grp;\n\treturn qp_flow;\n\nout_dealloc_flow:\n\tusnic_fwd_dealloc_flow(flow);\nout_put_sock:\n\tusnic_transport_put_socket(sock);\n\treturn ERR_PTR(err);\n}\n\nstatic void release_udp_flow(struct usnic_ib_qp_grp_flow *qp_flow)\n{\n\tusnic_fwd_dealloc_flow(qp_flow->flow);\n\tusnic_transport_put_socket(qp_flow->udp.sock);\n\tkfree(qp_flow);\n}\n\nstatic struct usnic_ib_qp_grp_flow*\ncreate_and_add_flow(struct usnic_ib_qp_grp *qp_grp,\n\t\t\tstruct usnic_transport_spec *trans_spec)\n{\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\tenum usnic_transport_type trans_type;\n\n\ttrans_type = trans_spec->trans_type;\n\tswitch (trans_type) {\n\tcase USNIC_TRANSPORT_ROCE_CUSTOM:\n\t\tqp_flow = create_roce_custom_flow(qp_grp, trans_spec);\n\t\tbreak;\n\tcase USNIC_TRANSPORT_IPV4_UDP:\n\t\tqp_flow = create_udp_flow(qp_grp, trans_spec);\n\t\tbreak;\n\tdefault:\n\t\tusnic_err(\"Unsupported transport %u\\n\",\n\t\t\t\ttrans_spec->trans_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!IS_ERR_OR_NULL(qp_flow)) {\n\t\tlist_add_tail(&qp_flow->link, &qp_grp->flows_lst);\n\t\tusnic_debugfs_flow_add(qp_flow);\n\t}\n\n\n\treturn qp_flow;\n}\n\nstatic void release_and_remove_flow(struct usnic_ib_qp_grp_flow *qp_flow)\n{\n\tusnic_debugfs_flow_remove(qp_flow);\n\tlist_del(&qp_flow->link);\n\n\tswitch (qp_flow->trans_type) {\n\tcase USNIC_TRANSPORT_ROCE_CUSTOM:\n\t\trelease_roce_custom_flow(qp_flow);\n\t\tbreak;\n\tcase USNIC_TRANSPORT_IPV4_UDP:\n\t\trelease_udp_flow(qp_flow);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unsupported transport %u\\n\",\n\t\t\t\tqp_flow->trans_type);\n\t\tbreak;\n\t}\n}\n\nstatic void release_and_remove_all_flows(struct usnic_ib_qp_grp *qp_grp)\n{\n\tstruct usnic_ib_qp_grp_flow *qp_flow, *tmp;\n\tlist_for_each_entry_safe(qp_flow, tmp, &qp_grp->flows_lst, link)\n\t\trelease_and_remove_flow(qp_flow);\n}\n\nint usnic_ib_qp_grp_modify(struct usnic_ib_qp_grp *qp_grp,\n\t\t\t\tenum ib_qp_state new_state,\n\t\t\t\tvoid *data)\n{\n\tint status = 0;\n\tstruct ib_event ib_event;\n\tenum ib_qp_state old_state;\n\tstruct usnic_transport_spec *trans_spec;\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\n\told_state = qp_grp->state;\n\ttrans_spec = (struct usnic_transport_spec *) data;\n\n\tspin_lock(&qp_grp->lock);\n\tswitch (new_state) {\n\tcase IB_QPS_RESET:\n\t\tswitch (old_state) {\n\t\tcase IB_QPS_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tcase IB_QPS_INIT:\n\t\t\trelease_and_remove_all_flows(qp_grp);\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\tcase IB_QPS_RTR:\n\t\tcase IB_QPS_RTS:\n\t\tcase IB_QPS_ERR:\n\t\t\tstatus = disable_qp_grp(qp_grp);\n\t\t\trelease_and_remove_all_flows(qp_grp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IB_QPS_INIT:\n\t\tswitch (old_state) {\n\t\tcase IB_QPS_RESET:\n\t\t\tif (trans_spec) {\n\t\t\t\tqp_flow = create_and_add_flow(qp_grp,\n\t\t\t\t\t\t\t\ttrans_spec);\n\t\t\t\tif (IS_ERR_OR_NULL(qp_flow)) {\n\t\t\t\t\tstatus = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstatus = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IB_QPS_INIT:\n\t\t\tif (trans_spec) {\n\t\t\t\tqp_flow = create_and_add_flow(qp_grp,\n\t\t\t\t\t\t\t\ttrans_spec);\n\t\t\t\tif (IS_ERR_OR_NULL(qp_flow)) {\n\t\t\t\t\tstatus = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstatus = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IB_QPS_RTR:\n\t\t\tstatus = disable_qp_grp(qp_grp);\n\t\t\tbreak;\n\t\tcase IB_QPS_RTS:\n\t\t\tstatus = disable_qp_grp(qp_grp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IB_QPS_RTR:\n\t\tswitch (old_state) {\n\t\tcase IB_QPS_INIT:\n\t\t\tstatus = enable_qp_grp(qp_grp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IB_QPS_RTS:\n\t\tswitch (old_state) {\n\t\tcase IB_QPS_RTR:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase IB_QPS_ERR:\n\t\tib_event.device = &qp_grp->vf->pf->ib_dev;\n\t\tib_event.element.qp = &qp_grp->ibqp;\n\t\tib_event.event = IB_EVENT_QP_FATAL;\n\n\t\tswitch (old_state) {\n\t\tcase IB_QPS_RESET:\n\t\t\tqp_grp->ibqp.event_handler(&ib_event,\n\t\t\t\t\tqp_grp->ibqp.qp_context);\n\t\t\tbreak;\n\t\tcase IB_QPS_INIT:\n\t\t\trelease_and_remove_all_flows(qp_grp);\n\t\t\tqp_grp->ibqp.event_handler(&ib_event,\n\t\t\t\t\tqp_grp->ibqp.qp_context);\n\t\t\tbreak;\n\t\tcase IB_QPS_RTR:\n\t\tcase IB_QPS_RTS:\n\t\t\tstatus = disable_qp_grp(qp_grp);\n\t\t\trelease_and_remove_all_flows(qp_grp);\n\t\t\tqp_grp->ibqp.event_handler(&ib_event,\n\t\t\t\t\tqp_grp->ibqp.qp_context);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstatus = -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EINVAL;\n\t}\n\tspin_unlock(&qp_grp->lock);\n\n\tif (!status) {\n\t\tqp_grp->state = new_state;\n\t\tusnic_info(\"Transitioned %u from %s to %s\",\n\t\tqp_grp->grp_id,\n\t\tusnic_ib_qp_grp_state_to_string(old_state),\n\t\tusnic_ib_qp_grp_state_to_string(new_state));\n\t} else {\n\t\tusnic_err(\"Failed to transition %u from %s to %s\",\n\t\tqp_grp->grp_id,\n\t\tusnic_ib_qp_grp_state_to_string(old_state),\n\t\tusnic_ib_qp_grp_state_to_string(new_state));\n\t}\n\n\treturn status;\n}\n\nstatic struct usnic_vnic_res_chunk**\nalloc_res_chunk_list(struct usnic_vnic *vnic,\n\t\t\tstruct usnic_vnic_res_spec *res_spec, void *owner_obj)\n{\n\tenum usnic_vnic_res_type res_type;\n\tstruct usnic_vnic_res_chunk **res_chunk_list;\n\tint err, i, res_cnt, res_lst_sz;\n\n\tfor (res_lst_sz = 0;\n\t\tres_spec->resources[res_lst_sz].type != USNIC_VNIC_RES_TYPE_EOL;\n\t\tres_lst_sz++) {\n\t\t \n\t}\n\n\tres_chunk_list = kcalloc(res_lst_sz + 1, sizeof(*res_chunk_list),\n\t\t\t\t\tGFP_ATOMIC);\n\tif (!res_chunk_list)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; res_spec->resources[i].type != USNIC_VNIC_RES_TYPE_EOL;\n\t\ti++) {\n\t\tres_type = res_spec->resources[i].type;\n\t\tres_cnt = res_spec->resources[i].cnt;\n\n\t\tres_chunk_list[i] = usnic_vnic_get_resources(vnic, res_type,\n\t\t\t\t\tres_cnt, owner_obj);\n\t\tif (IS_ERR_OR_NULL(res_chunk_list[i])) {\n\t\t\terr = res_chunk_list[i] ?\n\t\t\t\t\tPTR_ERR(res_chunk_list[i]) : -ENOMEM;\n\t\t\tusnic_err(\"Failed to get %s from %s with err %d\\n\",\n\t\t\t\tusnic_vnic_res_type_to_str(res_type),\n\t\t\t\tusnic_vnic_pci_name(vnic),\n\t\t\t\terr);\n\t\t\tgoto out_free_res;\n\t\t}\n\t}\n\n\treturn res_chunk_list;\n\nout_free_res:\n\tfor (i--; i >= 0; i--)\n\t\tusnic_vnic_put_resources(res_chunk_list[i]);\n\tkfree(res_chunk_list);\n\treturn ERR_PTR(err);\n}\n\nstatic void free_qp_grp_res(struct usnic_vnic_res_chunk **res_chunk_list)\n{\n\tint i;\n\tfor (i = 0; res_chunk_list[i]; i++)\n\t\tusnic_vnic_put_resources(res_chunk_list[i]);\n\tkfree(res_chunk_list);\n}\n\nstatic int qp_grp_and_vf_bind(struct usnic_ib_vf *vf,\n\t\t\t\tstruct usnic_ib_pd *pd,\n\t\t\t\tstruct usnic_ib_qp_grp *qp_grp)\n{\n\tint err;\n\tstruct pci_dev *pdev;\n\n\tlockdep_assert_held(&vf->lock);\n\n\tpdev = usnic_vnic_get_pdev(vf->vnic);\n\tif (vf->qp_grp_ref_cnt == 0) {\n\t\terr = usnic_uiom_attach_dev_to_pd(pd->umem_pd, &pdev->dev);\n\t\tif (err) {\n\t\t\tusnic_err(\"Failed to attach %s to domain\\n\",\n\t\t\t\t\tpci_name(pdev));\n\t\t\treturn err;\n\t\t}\n\t\tvf->pd = pd;\n\t}\n\tvf->qp_grp_ref_cnt++;\n\n\tWARN_ON(vf->pd != pd);\n\tqp_grp->vf = vf;\n\n\treturn 0;\n}\n\nstatic void qp_grp_and_vf_unbind(struct usnic_ib_qp_grp *qp_grp)\n{\n\tstruct pci_dev *pdev;\n\tstruct usnic_ib_pd *pd;\n\n\tlockdep_assert_held(&qp_grp->vf->lock);\n\n\tpd = qp_grp->vf->pd;\n\tpdev = usnic_vnic_get_pdev(qp_grp->vf->vnic);\n\tif (--qp_grp->vf->qp_grp_ref_cnt == 0) {\n\t\tqp_grp->vf->pd = NULL;\n\t\tusnic_uiom_detach_dev_from_pd(pd->umem_pd, &pdev->dev);\n\t}\n\tqp_grp->vf = NULL;\n}\n\nstatic void log_spec(struct usnic_vnic_res_spec *res_spec)\n{\n\tchar buf[512];\n\tusnic_vnic_spec_dump(buf, sizeof(buf), res_spec);\n\tusnic_dbg(\"%s\\n\", buf);\n}\n\nstatic int qp_grp_id_from_flow(struct usnic_ib_qp_grp_flow *qp_flow,\n\t\t\t\tuint32_t *id)\n{\n\tenum usnic_transport_type trans_type = qp_flow->trans_type;\n\tint err;\n\tuint16_t port_num = 0;\n\n\tswitch (trans_type) {\n\tcase USNIC_TRANSPORT_ROCE_CUSTOM:\n\t\t*id = qp_flow->usnic_roce.port_num;\n\t\tbreak;\n\tcase USNIC_TRANSPORT_IPV4_UDP:\n\t\terr = usnic_transport_sock_get_addr(qp_flow->udp.sock,\n\t\t\t\t\t\t\tNULL, NULL,\n\t\t\t\t\t\t\t&port_num);\n\t\tif (err)\n\t\t\treturn err;\n\t\t \n\t\t*id = port_num;\n\t\tbreak;\n\tdefault:\n\t\tusnic_err(\"Unsupported transport %u\\n\", trans_type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint usnic_ib_qp_grp_create(struct usnic_ib_qp_grp *qp_grp,\n\t\t\t   struct usnic_fwd_dev *ufdev, struct usnic_ib_vf *vf,\n\t\t\t   struct usnic_ib_pd *pd,\n\t\t\t   struct usnic_vnic_res_spec *res_spec,\n\t\t\t   struct usnic_transport_spec *transport_spec)\n{\n\tint err;\n\tenum usnic_transport_type transport = transport_spec->trans_type;\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\n\tlockdep_assert_held(&vf->lock);\n\n\terr = usnic_vnic_res_spec_satisfied(&min_transport_spec[transport],\n\t\t\t\t\t\tres_spec);\n\tif (err) {\n\t\tusnic_err(\"Spec does not meet minimum req for transport %d\\n\",\n\t\t\t\ttransport);\n\t\tlog_spec(res_spec);\n\t\treturn err;\n\t}\n\n\tqp_grp->res_chunk_list = alloc_res_chunk_list(vf->vnic, res_spec,\n\t\t\t\t\t\t\tqp_grp);\n\tif (IS_ERR_OR_NULL(qp_grp->res_chunk_list))\n\t\treturn qp_grp->res_chunk_list ?\n\t\t\t\t     PTR_ERR(qp_grp->res_chunk_list) :\n\t\t\t\t     -ENOMEM;\n\n\terr = qp_grp_and_vf_bind(vf, pd, qp_grp);\n\tif (err)\n\t\tgoto out_free_res;\n\n\tINIT_LIST_HEAD(&qp_grp->flows_lst);\n\tspin_lock_init(&qp_grp->lock);\n\tqp_grp->ufdev = ufdev;\n\tqp_grp->state = IB_QPS_RESET;\n\tqp_grp->owner_pid = current->pid;\n\n\tqp_flow = create_and_add_flow(qp_grp, transport_spec);\n\tif (IS_ERR_OR_NULL(qp_flow)) {\n\t\tusnic_err(\"Unable to create and add flow with err %ld\\n\",\n\t\t\t\tPTR_ERR(qp_flow));\n\t\terr = qp_flow ? PTR_ERR(qp_flow) : -EFAULT;\n\t\tgoto out_qp_grp_vf_unbind;\n\t}\n\n\terr = qp_grp_id_from_flow(qp_flow, &qp_grp->grp_id);\n\tif (err)\n\t\tgoto out_release_flow;\n\tqp_grp->ibqp.qp_num = qp_grp->grp_id;\n\n\tusnic_ib_sysfs_qpn_add(qp_grp);\n\n\treturn 0;\n\nout_release_flow:\n\trelease_and_remove_flow(qp_flow);\nout_qp_grp_vf_unbind:\n\tqp_grp_and_vf_unbind(qp_grp);\nout_free_res:\n\tfree_qp_grp_res(qp_grp->res_chunk_list);\n\treturn err;\n}\n\nvoid usnic_ib_qp_grp_destroy(struct usnic_ib_qp_grp *qp_grp)\n{\n\n\tWARN_ON(qp_grp->state != IB_QPS_RESET);\n\tlockdep_assert_held(&qp_grp->vf->lock);\n\n\trelease_and_remove_all_flows(qp_grp);\n\tusnic_ib_sysfs_qpn_remove(qp_grp);\n\tqp_grp_and_vf_unbind(qp_grp);\n\tfree_qp_grp_res(qp_grp->res_chunk_list);\n}\n\nstruct usnic_vnic_res_chunk*\nusnic_ib_qp_grp_get_chunk(struct usnic_ib_qp_grp *qp_grp,\n\t\t\t\tenum usnic_vnic_res_type res_type)\n{\n\tint i;\n\n\tfor (i = 0; qp_grp->res_chunk_list[i]; i++) {\n\t\tif (qp_grp->res_chunk_list[i]->type == res_type)\n\t\t\treturn qp_grp->res_chunk_list[i];\n\t}\n\n\treturn ERR_PTR(-EINVAL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}