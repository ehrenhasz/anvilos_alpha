{
  "module_name": "usnic_debugfs.c",
  "hash_id": "023dab77b8de43c38364a0f6df7455ab8b9f297a90df68f2e353bc1aa8ae87aa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/usnic/usnic_debugfs.c",
  "human_readable_source": " \n\n#include <linux/debugfs.h>\n\n#include \"usnic.h\"\n#include \"usnic_log.h\"\n#include \"usnic_debugfs.h\"\n#include \"usnic_ib_qp_grp.h\"\n#include \"usnic_transport.h\"\n\nstatic struct dentry *debugfs_root;\nstatic struct dentry *flows_dentry;\n\nstatic ssize_t usnic_debugfs_buildinfo_read(struct file *f, char __user *data,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar buf[500];\n\tint res;\n\n\tif (*ppos > 0)\n\t\treturn 0;\n\n\tres = scnprintf(buf, sizeof(buf),\n\t\t\t\"version:       %s\\n\"\n\t\t\t\"build date:    %s\\n\",\n\t\t\tDRV_VERSION, DRV_RELDATE);\n\n\treturn simple_read_from_buffer(data, count, ppos, buf, res);\n}\n\nstatic const struct file_operations usnic_debugfs_buildinfo_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = usnic_debugfs_buildinfo_read\n};\n\nstatic ssize_t flowinfo_read(struct file *f, char __user *data,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct usnic_ib_qp_grp_flow *qp_flow;\n\tint n;\n\tint left;\n\tchar *ptr;\n\tchar buf[512];\n\n\tqp_flow = f->private_data;\n\tptr = buf;\n\tleft = count;\n\n\tif (*ppos > 0)\n\t\treturn 0;\n\n\tspin_lock(&qp_flow->qp_grp->lock);\n\tn = scnprintf(ptr, left,\n\t\t\t\"QP Grp ID: %d Transport: %s \",\n\t\t\tqp_flow->qp_grp->grp_id,\n\t\t\tusnic_transport_to_str(qp_flow->trans_type));\n\tUPDATE_PTR_LEFT(n, ptr, left);\n\tif (qp_flow->trans_type == USNIC_TRANSPORT_ROCE_CUSTOM) {\n\t\tn = scnprintf(ptr, left, \"Port_Num:%hu\\n\",\n\t\t\t\t\tqp_flow->usnic_roce.port_num);\n\t\tUPDATE_PTR_LEFT(n, ptr, left);\n\t} else if (qp_flow->trans_type == USNIC_TRANSPORT_IPV4_UDP) {\n\t\tn = usnic_transport_sock_to_str(ptr, left,\n\t\t\t\tqp_flow->udp.sock);\n\t\tUPDATE_PTR_LEFT(n, ptr, left);\n\t\tn = scnprintf(ptr, left, \"\\n\");\n\t\tUPDATE_PTR_LEFT(n, ptr, left);\n\t}\n\tspin_unlock(&qp_flow->qp_grp->lock);\n\n\treturn simple_read_from_buffer(data, count, ppos, buf, ptr - buf);\n}\n\nstatic const struct file_operations flowinfo_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = flowinfo_read,\n};\n\nvoid usnic_debugfs_init(void)\n{\n\tdebugfs_root = debugfs_create_dir(DRV_NAME, NULL);\n\n\tflows_dentry = debugfs_create_dir(\"flows\", debugfs_root);\n\n\tdebugfs_create_file(\"build-info\", S_IRUGO, debugfs_root,\n\t\t\t\tNULL, &usnic_debugfs_buildinfo_ops);\n}\n\nvoid usnic_debugfs_exit(void)\n{\n\tdebugfs_remove_recursive(debugfs_root);\n\tdebugfs_root = NULL;\n}\n\nvoid usnic_debugfs_flow_add(struct usnic_ib_qp_grp_flow *qp_flow)\n{\n\tscnprintf(qp_flow->dentry_name, sizeof(qp_flow->dentry_name),\n\t\t\t\"%u\", qp_flow->flow->flow_id);\n\tqp_flow->dbgfs_dentry = debugfs_create_file(qp_flow->dentry_name,\n\t\t\t\t\t\t\tS_IRUGO,\n\t\t\t\t\t\t\tflows_dentry,\n\t\t\t\t\t\t\tqp_flow,\n\t\t\t\t\t\t\t&flowinfo_ops);\n}\n\nvoid usnic_debugfs_flow_remove(struct usnic_ib_qp_grp_flow *qp_flow)\n{\n\tdebugfs_remove(qp_flow->dbgfs_dentry);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}