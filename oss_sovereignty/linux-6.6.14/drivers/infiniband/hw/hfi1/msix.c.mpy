{
  "module_name": "msix.c",
  "hash_id": "d6dca4c544c1e95796928c105c3b2e47cad1bc970a569f7fd338c5815a229600",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/msix.c",
  "human_readable_source": "\n \n\n#include \"hfi.h\"\n#include \"affinity.h\"\n#include \"sdma.h\"\n#include \"netdev.h\"\n\n \nint msix_initialize(struct hfi1_devdata *dd)\n{\n\tu32 total;\n\tint ret;\n\tstruct hfi1_msix_entry *entries;\n\n\t \n\ttotal = 1 + dd->num_sdma + dd->n_krcv_queues + dd->num_netdev_contexts;\n\n\tif (total >= CCE_NUM_MSIX_VECTORS)\n\t\treturn -EINVAL;\n\n\tret = pci_alloc_irq_vectors(dd->pcidev, total, total, PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tdd_dev_err(dd, \"pci_alloc_irq_vectors() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tentries = kcalloc(total, sizeof(*dd->msix_info.msix_entries),\n\t\t\t  GFP_KERNEL);\n\tif (!entries) {\n\t\tpci_free_irq_vectors(dd->pcidev);\n\t\treturn -ENOMEM;\n\t}\n\n\tdd->msix_info.msix_entries = entries;\n\tspin_lock_init(&dd->msix_info.msix_lock);\n\tbitmap_zero(dd->msix_info.in_use_msix, total);\n\tdd->msix_info.max_requested = total;\n\tdd_dev_info(dd, \"%u MSI-X interrupts allocated\\n\", total);\n\n\treturn 0;\n}\n\n \nstatic int msix_request_irq(struct hfi1_devdata *dd, void *arg,\n\t\t\t    irq_handler_t handler, irq_handler_t thread,\n\t\t\t    enum irq_type type, const char *name)\n{\n\tunsigned long nr;\n\tint irq;\n\tint ret;\n\tstruct hfi1_msix_entry *me;\n\n\t \n\tspin_lock(&dd->msix_info.msix_lock);\n\tnr = find_first_zero_bit(dd->msix_info.in_use_msix,\n\t\t\t\t dd->msix_info.max_requested);\n\tif (nr < dd->msix_info.max_requested)\n\t\t__set_bit(nr, dd->msix_info.in_use_msix);\n\tspin_unlock(&dd->msix_info.msix_lock);\n\n\tif (nr == dd->msix_info.max_requested)\n\t\treturn -ENOSPC;\n\n\tif (type < IRQ_SDMA || type >= IRQ_OTHER)\n\t\treturn -EINVAL;\n\n\tirq = pci_irq_vector(dd->pcidev, nr);\n\tret = pci_request_irq(dd->pcidev, nr, handler, thread, arg, name);\n\tif (ret) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"%s: request for IRQ %d failed, MSIx %lx, err %d\\n\",\n\t\t\t   name, irq, nr, ret);\n\t\tspin_lock(&dd->msix_info.msix_lock);\n\t\t__clear_bit(nr, dd->msix_info.in_use_msix);\n\t\tspin_unlock(&dd->msix_info.msix_lock);\n\t\treturn ret;\n\t}\n\n\t \n\tme = &dd->msix_info.msix_entries[nr];\n\tme->irq = irq;\n\tme->arg = arg;\n\tme->type = type;\n\n\t \n\tret = hfi1_get_irq_affinity(dd, me);\n\tif (ret)\n\t\tdd_dev_err(dd, \"%s: unable to pin IRQ %d\\n\", name, ret);\n\n\treturn nr;\n}\n\nstatic int msix_request_rcd_irq_common(struct hfi1_ctxtdata *rcd,\n\t\t\t\t       irq_handler_t handler,\n\t\t\t\t       irq_handler_t thread,\n\t\t\t\t       const char *name)\n{\n\tint nr = msix_request_irq(rcd->dd, rcd, handler, thread,\n\t\t\t\t  rcd->is_vnic ? IRQ_NETDEVCTXT : IRQ_RCVCTXT,\n\t\t\t\t  name);\n\tif (nr < 0)\n\t\treturn nr;\n\n\t \n\trcd->ireg = (IS_RCVAVAIL_START + rcd->ctxt) / 64;\n\trcd->imask = ((u64)1) << ((IS_RCVAVAIL_START + rcd->ctxt) % 64);\n\trcd->msix_intr = nr;\n\tremap_intr(rcd->dd, IS_RCVAVAIL_START + rcd->ctxt, nr);\n\n\treturn 0;\n}\n\n \nint msix_request_rcd_irq(struct hfi1_ctxtdata *rcd)\n{\n\tchar name[MAX_NAME_SIZE];\n\n\tsnprintf(name, sizeof(name), DRIVER_NAME \"_%d kctxt%d\",\n\t\t rcd->dd->unit, rcd->ctxt);\n\n\treturn msix_request_rcd_irq_common(rcd, receive_context_interrupt,\n\t\t\t\t\t   receive_context_thread, name);\n}\n\n \nint msix_netdev_request_rcd_irq(struct hfi1_ctxtdata *rcd)\n{\n\tchar name[MAX_NAME_SIZE];\n\n\tsnprintf(name, sizeof(name), DRIVER_NAME \"_%d nd kctxt%d\",\n\t\t rcd->dd->unit, rcd->ctxt);\n\treturn msix_request_rcd_irq_common(rcd, receive_context_interrupt_napi,\n\t\t\t\t\t   NULL, name);\n}\n\n \nint msix_request_sdma_irq(struct sdma_engine *sde)\n{\n\tint nr;\n\tchar name[MAX_NAME_SIZE];\n\n\tsnprintf(name, sizeof(name), DRIVER_NAME \"_%d sdma%d\",\n\t\t sde->dd->unit, sde->this_idx);\n\tnr = msix_request_irq(sde->dd, sde, sdma_interrupt, NULL,\n\t\t\t      IRQ_SDMA, name);\n\tif (nr < 0)\n\t\treturn nr;\n\tsde->msix_intr = nr;\n\tremap_sdma_interrupts(sde->dd, sde->this_idx, nr);\n\n\treturn 0;\n}\n\n \nint msix_request_general_irq(struct hfi1_devdata *dd)\n{\n\tint nr;\n\tchar name[MAX_NAME_SIZE];\n\n\tsnprintf(name, sizeof(name), DRIVER_NAME \"_%d\", dd->unit);\n\tnr = msix_request_irq(dd, dd, general_interrupt, NULL, IRQ_GENERAL,\n\t\t\t      name);\n\tif (nr < 0)\n\t\treturn nr;\n\n\t \n\tif (nr) {\n\t\tmsix_free_irq(dd, (u8)nr);\n\t\tdd_dev_err(dd, \"Invalid index %d for GENERAL IRQ\\n\", nr);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void enable_sdma_srcs(struct hfi1_devdata *dd, int i)\n{\n\tset_intr_bits(dd, IS_SDMA_START + i, IS_SDMA_START + i, true);\n\tset_intr_bits(dd, IS_SDMA_PROGRESS_START + i,\n\t\t      IS_SDMA_PROGRESS_START + i, true);\n\tset_intr_bits(dd, IS_SDMA_IDLE_START + i, IS_SDMA_IDLE_START + i, true);\n\tset_intr_bits(dd, IS_SDMAENG_ERR_START + i, IS_SDMAENG_ERR_START + i,\n\t\t      true);\n}\n\n \nint msix_request_irqs(struct hfi1_devdata *dd)\n{\n\tint i;\n\tint ret = msix_request_general_irq(dd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < dd->num_sdma; i++) {\n\t\tstruct sdma_engine *sde = &dd->per_sdma[i];\n\n\t\tret = msix_request_sdma_irq(sde);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tenable_sdma_srcs(sde->dd, i);\n\t}\n\n\tfor (i = 0; i < dd->n_krcv_queues; i++) {\n\t\tstruct hfi1_ctxtdata *rcd = hfi1_rcd_get_by_index_safe(dd, i);\n\n\t\tif (rcd)\n\t\t\tret = msix_request_rcd_irq(rcd);\n\t\thfi1_rcd_put(rcd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nvoid msix_free_irq(struct hfi1_devdata *dd, u8 msix_intr)\n{\n\tstruct hfi1_msix_entry *me;\n\n\tif (msix_intr >= dd->msix_info.max_requested)\n\t\treturn;\n\n\tme = &dd->msix_info.msix_entries[msix_intr];\n\n\tif (!me->arg)  \n\t\treturn;\n\n\thfi1_put_irq_affinity(dd, me);\n\tpci_free_irq(dd->pcidev, msix_intr, me->arg);\n\n\tme->arg = NULL;\n\n\tspin_lock(&dd->msix_info.msix_lock);\n\t__clear_bit(msix_intr, dd->msix_info.in_use_msix);\n\tspin_unlock(&dd->msix_info.msix_lock);\n}\n\n \nvoid msix_clean_up_interrupts(struct hfi1_devdata *dd)\n{\n\tint i;\n\tstruct hfi1_msix_entry *me = dd->msix_info.msix_entries;\n\n\t \n\tfor (i = 0; i < dd->msix_info.max_requested; i++, me++)\n\t\tmsix_free_irq(dd, i);\n\n\t \n\tkfree(dd->msix_info.msix_entries);\n\tdd->msix_info.msix_entries = NULL;\n\tdd->msix_info.max_requested = 0;\n\n\tpci_free_irq_vectors(dd->pcidev);\n}\n\n \nvoid msix_netdev_synchronize_irq(struct hfi1_devdata *dd)\n{\n\tint i;\n\tint ctxt_count = hfi1_netdev_ctxt_count(dd);\n\n\tfor (i = 0; i < ctxt_count; i++) {\n\t\tstruct hfi1_ctxtdata *rcd = hfi1_netdev_get_ctxt(dd, i);\n\t\tstruct hfi1_msix_entry *me;\n\n\t\tme = &dd->msix_info.msix_entries[rcd->msix_intr];\n\n\t\tsynchronize_irq(me->irq);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}