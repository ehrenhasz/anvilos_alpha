{
  "module_name": "user_pages.c",
  "hash_id": "a6b1768c40d0d5a709b7a30af3c1c3fc54aa2767a6ab57ff7843667a9078a0a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/user_pages.c",
  "human_readable_source": "\n \n\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/device.h>\n#include <linux/module.h>\n\n#include \"hfi.h\"\n\nstatic unsigned long cache_size = 256;\nmodule_param(cache_size, ulong, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(cache_size, \"Send and receive side cache size limit (in MB)\");\n\n \nbool hfi1_can_pin_pages(struct hfi1_devdata *dd, struct mm_struct *mm,\n\t\t\tu32 nlocked, u32 npages)\n{\n\tunsigned long ulimit_pages;\n\tunsigned long cache_limit_pages;\n\tunsigned int usr_ctxts;\n\n\t \n\tif (!capable(CAP_IPC_LOCK)) {\n\t\tulimit_pages =\n\t\t\tDIV_ROUND_DOWN_ULL(rlimit(RLIMIT_MEMLOCK), PAGE_SIZE);\n\n\t\t \n\t\tif (atomic64_read(&mm->pinned_vm) + npages > ulimit_pages)\n\t\t\treturn false;\n\n\t\t \n\t\tusr_ctxts = dd->num_rcv_contexts - dd->first_dyn_alloc_ctxt;\n\t\tif (nlocked + npages > (ulimit_pages / usr_ctxts / 4))\n\t\t\treturn false;\n\t}\n\n\t \n\tcache_limit_pages = cache_size * (1024 * 1024) / PAGE_SIZE;\n\tif (nlocked + npages > cache_limit_pages)\n\t\treturn false;\n\n\treturn true;\n}\n\nint hfi1_acquire_user_pages(struct mm_struct *mm, unsigned long vaddr, size_t npages,\n\t\t\t    bool writable, struct page **pages)\n{\n\tint ret;\n\tunsigned int gup_flags = FOLL_LONGTERM | (writable ? FOLL_WRITE : 0);\n\n\tret = pin_user_pages_fast(vaddr, npages, gup_flags, pages);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tatomic64_add(ret, &mm->pinned_vm);\n\n\treturn ret;\n}\n\nvoid hfi1_release_user_pages(struct mm_struct *mm, struct page **p,\n\t\t\t     size_t npages, bool dirty)\n{\n\tunpin_user_pages_dirty_lock(p, npages, dirty);\n\n\tif (mm) {  \n\t\tatomic64_sub(npages, &mm->pinned_vm);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}