{
  "module_name": "platform.c",
  "hash_id": "674f7f325efacde2491ebcd82baacf205daeacef13249d50fc694a20ceaad01f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/platform.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n\n#include \"hfi.h\"\n#include \"efivar.h\"\n#include \"eprom.h\"\n\n#define DEFAULT_PLATFORM_CONFIG_NAME \"hfi1_platform.dat\"\n\nstatic int validate_scratch_checksum(struct hfi1_devdata *dd)\n{\n\tu64 checksum = 0, temp_scratch = 0;\n\tint i, j, version;\n\n\ttemp_scratch = read_csr(dd, ASIC_CFG_SCRATCH);\n\tversion = (temp_scratch & BITMAP_VERSION_SMASK) >> BITMAP_VERSION_SHIFT;\n\n\t \n\tif (!version) {\n\t\tdd_dev_err(dd, \"%s: Config bitmap uninitialized\\n\", __func__);\n\t\tdd_dev_err(dd,\n\t\t\t   \"%s: Please update your BIOS to support active channels\\n\",\n\t\t\t   __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tchecksum += version;\n\tfor (i = 1; i < ASIC_NUM_SCRATCH; i++) {\n\t\ttemp_scratch = read_csr(dd, ASIC_CFG_SCRATCH + (8 * i));\n\t\tfor (j = sizeof(u64); j != 0; j -= 2) {\n\t\t\tchecksum += (temp_scratch & 0xFFFF);\n\t\t\ttemp_scratch >>= 16;\n\t\t}\n\t}\n\n\twhile (checksum >> 16)\n\t\tchecksum = (checksum & CHECKSUM_MASK) + (checksum >> 16);\n\n\ttemp_scratch = read_csr(dd, ASIC_CFG_SCRATCH);\n\ttemp_scratch &= CHECKSUM_SMASK;\n\ttemp_scratch >>= CHECKSUM_SHIFT;\n\n\tif (checksum + temp_scratch == 0xFFFF)\n\t\treturn 1;\n\n\tdd_dev_err(dd, \"%s: Configuration bitmap corrupted\\n\", __func__);\n\treturn 0;\n}\n\nstatic void save_platform_config_fields(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_pportdata *ppd = dd->pport;\n\tu64 temp_scratch = 0, temp_dest = 0;\n\n\ttemp_scratch = read_csr(dd, ASIC_CFG_SCRATCH_1);\n\n\ttemp_dest = temp_scratch &\n\t\t    (dd->hfi1_id ? PORT1_PORT_TYPE_SMASK :\n\t\t     PORT0_PORT_TYPE_SMASK);\n\tppd->port_type = temp_dest >>\n\t\t\t (dd->hfi1_id ? PORT1_PORT_TYPE_SHIFT :\n\t\t\t  PORT0_PORT_TYPE_SHIFT);\n\n\ttemp_dest = temp_scratch &\n\t\t    (dd->hfi1_id ? PORT1_LOCAL_ATTEN_SMASK :\n\t\t     PORT0_LOCAL_ATTEN_SMASK);\n\tppd->local_atten = temp_dest >>\n\t\t\t   (dd->hfi1_id ? PORT1_LOCAL_ATTEN_SHIFT :\n\t\t\t    PORT0_LOCAL_ATTEN_SHIFT);\n\n\ttemp_dest = temp_scratch &\n\t\t    (dd->hfi1_id ? PORT1_REMOTE_ATTEN_SMASK :\n\t\t     PORT0_REMOTE_ATTEN_SMASK);\n\tppd->remote_atten = temp_dest >>\n\t\t\t    (dd->hfi1_id ? PORT1_REMOTE_ATTEN_SHIFT :\n\t\t\t     PORT0_REMOTE_ATTEN_SHIFT);\n\n\ttemp_dest = temp_scratch &\n\t\t    (dd->hfi1_id ? PORT1_DEFAULT_ATTEN_SMASK :\n\t\t     PORT0_DEFAULT_ATTEN_SMASK);\n\tppd->default_atten = temp_dest >>\n\t\t\t     (dd->hfi1_id ? PORT1_DEFAULT_ATTEN_SHIFT :\n\t\t\t      PORT0_DEFAULT_ATTEN_SHIFT);\n\n\ttemp_scratch = read_csr(dd, dd->hfi1_id ? ASIC_CFG_SCRATCH_3 :\n\t\t\t\tASIC_CFG_SCRATCH_2);\n\n\tppd->tx_preset_eq = (temp_scratch & TX_EQ_SMASK) >> TX_EQ_SHIFT;\n\tppd->tx_preset_noeq = (temp_scratch & TX_NO_EQ_SMASK) >> TX_NO_EQ_SHIFT;\n\tppd->rx_preset = (temp_scratch & RX_SMASK) >> RX_SHIFT;\n\n\tppd->max_power_class = (temp_scratch & QSFP_MAX_POWER_SMASK) >>\n\t\t\t\tQSFP_MAX_POWER_SHIFT;\n\n\tppd->config_from_scratch = true;\n}\n\nvoid get_platform_config(struct hfi1_devdata *dd)\n{\n\tint ret = 0;\n\tu8 *temp_platform_config = NULL;\n\tu32 esize;\n\tconst struct firmware *platform_config_file = NULL;\n\n\tif (is_integrated(dd)) {\n\t\tif (validate_scratch_checksum(dd)) {\n\t\t\tsave_platform_config_fields(dd);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tret = eprom_read_platform_config(dd,\n\t\t\t\t\t\t (void **)&temp_platform_config,\n\t\t\t\t\t\t &esize);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tdd->platform_config.data = temp_platform_config;\n\t\t\tdd->platform_config.size = esize;\n\t\t\treturn;\n\t\t}\n\t}\n\tdd_dev_err(dd,\n\t\t   \"%s: Failed to get platform config, falling back to sub-optimal default file\\n\",\n\t\t   __func__);\n\n\tret = request_firmware(&platform_config_file,\n\t\t\t       DEFAULT_PLATFORM_CONFIG_NAME,\n\t\t\t       &dd->pcidev->dev);\n\tif (ret) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"%s: No default platform config file found\\n\",\n\t\t\t   __func__);\n\t\treturn;\n\t}\n\n\t \n\tdd->platform_config.data = kmemdup(platform_config_file->data,\n\t\t\t\t\t   platform_config_file->size,\n\t\t\t\t\t   GFP_KERNEL);\n\tdd->platform_config.size = platform_config_file->size;\n\trelease_firmware(platform_config_file);\n}\n\nvoid free_platform_config(struct hfi1_devdata *dd)\n{\n\t \n\tkfree(dd->platform_config.data);\n\tdd->platform_config.data = NULL;\n}\n\nvoid get_port_type(struct hfi1_pportdata *ppd)\n{\n\tint ret;\n\tu32 temp;\n\n\tret = get_platform_config_field(ppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\t\t\tPORT_TABLE_PORT_TYPE, &temp,\n\t\t\t\t\t4);\n\tif (ret) {\n\t\tppd->port_type = PORT_TYPE_UNKNOWN;\n\t\treturn;\n\t}\n\tppd->port_type = temp;\n}\n\nint set_qsfp_tx(struct hfi1_pportdata *ppd, int on)\n{\n\tu8 tx_ctrl_byte = on ? 0x0 : 0xF;\n\tint ret = 0;\n\n\tret = qsfp_write(ppd, ppd->dd->hfi1_id, QSFP_TX_CTRL_BYTE_OFFS,\n\t\t\t &tx_ctrl_byte, 1);\n\t \n\tif (ret == 0)\n\t\tret = -EIO;\n\telse if (ret == 1)\n\t\tret = 0;\n\treturn ret;\n}\n\nstatic int qual_power(struct hfi1_pportdata *ppd)\n{\n\tu32 cable_power_class = 0, power_class_max = 0;\n\tu8 *cache = ppd->qsfp_info.cache;\n\tint ret = 0;\n\n\tret = get_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_SYSTEM_TABLE, 0,\n\t\tSYSTEM_TABLE_QSFP_POWER_CLASS_MAX, &power_class_max, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tcable_power_class = get_qsfp_power_class(cache[QSFP_MOD_PWR_OFFS]);\n\n\tif (cable_power_class > power_class_max)\n\t\tppd->offline_disabled_reason =\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_POWER_POLICY);\n\n\tif (ppd->offline_disabled_reason ==\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_POWER_POLICY)) {\n\t\tdd_dev_err(\n\t\t\tppd->dd,\n\t\t\t\"%s: Port disabled due to system power restrictions\\n\",\n\t\t\t__func__);\n\t\tret = -EPERM;\n\t}\n\treturn ret;\n}\n\nstatic int qual_bitrate(struct hfi1_pportdata *ppd)\n{\n\tu16 lss = ppd->link_speed_supported, lse = ppd->link_speed_enabled;\n\tu8 *cache = ppd->qsfp_info.cache;\n\n\tif ((lss & OPA_LINK_SPEED_25G) && (lse & OPA_LINK_SPEED_25G) &&\n\t    cache[QSFP_NOM_BIT_RATE_250_OFFS] < 0x64)\n\t\tppd->offline_disabled_reason =\n\t\t\t   HFI1_ODR_MASK(OPA_LINKDOWN_REASON_LINKSPEED_POLICY);\n\n\tif ((lss & OPA_LINK_SPEED_12_5G) && (lse & OPA_LINK_SPEED_12_5G) &&\n\t    cache[QSFP_NOM_BIT_RATE_100_OFFS] < 0x7D)\n\t\tppd->offline_disabled_reason =\n\t\t\t   HFI1_ODR_MASK(OPA_LINKDOWN_REASON_LINKSPEED_POLICY);\n\n\tif (ppd->offline_disabled_reason ==\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_LINKSPEED_POLICY)) {\n\t\tdd_dev_err(\n\t\t\tppd->dd,\n\t\t\t\"%s: Cable failed bitrate check, disabling port\\n\",\n\t\t\t__func__);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}\n\nstatic int set_qsfp_high_power(struct hfi1_pportdata *ppd)\n{\n\tu8 cable_power_class = 0, power_ctrl_byte = 0;\n\tu8 *cache = ppd->qsfp_info.cache;\n\tint ret;\n\n\tcable_power_class = get_qsfp_power_class(cache[QSFP_MOD_PWR_OFFS]);\n\n\tif (cable_power_class > QSFP_POWER_CLASS_1) {\n\t\tpower_ctrl_byte = cache[QSFP_PWR_CTRL_BYTE_OFFS];\n\n\t\tpower_ctrl_byte |= 1;\n\t\tpower_ctrl_byte &= ~(0x2);\n\n\t\tret = qsfp_write(ppd, ppd->dd->hfi1_id,\n\t\t\t\t QSFP_PWR_CTRL_BYTE_OFFS,\n\t\t\t\t &power_ctrl_byte, 1);\n\t\tif (ret != 1)\n\t\t\treturn -EIO;\n\n\t\tif (cable_power_class > QSFP_POWER_CLASS_4) {\n\t\t\tpower_ctrl_byte |= (1 << 2);\n\t\t\tret = qsfp_write(ppd, ppd->dd->hfi1_id,\n\t\t\t\t\t QSFP_PWR_CTRL_BYTE_OFFS,\n\t\t\t\t\t &power_ctrl_byte, 1);\n\t\t\tif (ret != 1)\n\t\t\t\treturn -EIO;\n\t\t}\n\n\t\t \n\t\tmsleep(300);\n\t}\n\treturn 0;\n}\n\nstatic void apply_rx_cdr(struct hfi1_pportdata *ppd,\n\t\t\t u32 rx_preset_index,\n\t\t\t u8 *cdr_ctrl_byte)\n{\n\tu32 rx_preset;\n\tu8 *cache = ppd->qsfp_info.cache;\n\tint cable_power_class;\n\n\tif (!((cache[QSFP_MOD_PWR_OFFS] & 0x4) &&\n\t      (cache[QSFP_CDR_INFO_OFFS] & 0x40)))\n\t\treturn;\n\n\t \n\tcable_power_class = get_qsfp_power_class(cache[QSFP_MOD_PWR_OFFS]);\n\n\tif (cable_power_class <= QSFP_POWER_CLASS_3) {\n\t\t \n\t\t*cdr_ctrl_byte |= 0xF;\n\t\treturn;\n\t}\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\trx_preset_index, RX_PRESET_TABLE_QSFP_RX_CDR_APPLY,\n\t\t&rx_preset, 4);\n\n\tif (!rx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: RX_CDR_APPLY is set to disabled\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\trx_preset_index, RX_PRESET_TABLE_QSFP_RX_CDR,\n\t\t&rx_preset, 4);\n\n\t \n\trx_preset = (rx_preset | (rx_preset << 1) |\n\t\t\t(rx_preset << 2) | (rx_preset << 3));\n\n\tif (rx_preset) {\n\t\t*cdr_ctrl_byte |= rx_preset;\n\t} else {\n\t\t*cdr_ctrl_byte &= rx_preset;\n\t\t \n\t\t*cdr_ctrl_byte |= (cache[QSFP_CDR_CTRL_BYTE_OFFS] & 0xF0);\n\t}\n}\n\nstatic void apply_tx_cdr(struct hfi1_pportdata *ppd,\n\t\t\t u32 tx_preset_index,\n\t\t\t u8 *cdr_ctrl_byte)\n{\n\tu32 tx_preset;\n\tu8 *cache = ppd->qsfp_info.cache;\n\tint cable_power_class;\n\n\tif (!((cache[QSFP_MOD_PWR_OFFS] & 0x8) &&\n\t      (cache[QSFP_CDR_INFO_OFFS] & 0x80)))\n\t\treturn;\n\n\t \n\tcable_power_class = get_qsfp_power_class(cache[QSFP_MOD_PWR_OFFS]);\n\n\tif (cable_power_class <= QSFP_POWER_CLASS_3) {\n\t\t \n\t\t*cdr_ctrl_byte |= 0xF0;\n\t\treturn;\n\t}\n\n\tget_platform_config_field(\n\t\tppd->dd,\n\t\tPLATFORM_CONFIG_TX_PRESET_TABLE, tx_preset_index,\n\t\tTX_PRESET_TABLE_QSFP_TX_CDR_APPLY, &tx_preset, 4);\n\n\tif (!tx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: TX_CDR_APPLY is set to disabled\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tget_platform_config_field(\n\t\tppd->dd,\n\t\tPLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index,\n\t\tTX_PRESET_TABLE_QSFP_TX_CDR, &tx_preset, 4);\n\n\t \n\ttx_preset = (tx_preset | (tx_preset << 1) |\n\t\t\t(tx_preset << 2) | (tx_preset << 3));\n\n\tif (tx_preset)\n\t\t*cdr_ctrl_byte |= (tx_preset << 4);\n\telse\n\t\t \n\t\t*cdr_ctrl_byte &= ((tx_preset << 4) | 0xF);\n}\n\nstatic void apply_cdr_settings(\n\t\tstruct hfi1_pportdata *ppd, u32 rx_preset_index,\n\t\tu32 tx_preset_index)\n{\n\tu8 *cache = ppd->qsfp_info.cache;\n\tu8 cdr_ctrl_byte = cache[QSFP_CDR_CTRL_BYTE_OFFS];\n\n\tapply_rx_cdr(ppd, rx_preset_index, &cdr_ctrl_byte);\n\n\tapply_tx_cdr(ppd, tx_preset_index, &cdr_ctrl_byte);\n\n\tqsfp_write(ppd, ppd->dd->hfi1_id, QSFP_CDR_CTRL_BYTE_OFFS,\n\t\t   &cdr_ctrl_byte, 1);\n}\n\nstatic void apply_tx_eq_auto(struct hfi1_pportdata *ppd)\n{\n\tu8 *cache = ppd->qsfp_info.cache;\n\tu8 tx_eq;\n\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x8))\n\t\treturn;\n\t \n\ttx_eq = cache[(128 * 3) + 241];\n\ttx_eq &= 0xF0;\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 241, &tx_eq, 1);\n}\n\nstatic void apply_tx_eq_prog(struct hfi1_pportdata *ppd, u32 tx_preset_index)\n{\n\tu8 *cache = ppd->qsfp_info.cache;\n\tu32 tx_preset;\n\tu8 tx_eq;\n\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x4))\n\t\treturn;\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index, TX_PRESET_TABLE_QSFP_TX_EQ_APPLY,\n\t\t&tx_preset, 4);\n\tif (!tx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: TX_EQ_APPLY is set to disabled\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\t\ttx_preset_index, TX_PRESET_TABLE_QSFP_TX_EQ,\n\t\t\t&tx_preset, 4);\n\n\tif (((cache[(128 * 3) + 224] & 0xF0) >> 4) < tx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: TX EQ %x unsupported\\n\",\n\t\t\t__func__, tx_preset);\n\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: Applying EQ %x\\n\",\n\t\t\t__func__, cache[608] & 0xF0);\n\n\t\ttx_preset = (cache[608] & 0xF0) >> 4;\n\t}\n\n\ttx_eq = tx_preset | (tx_preset << 4);\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 234, &tx_eq, 1);\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 235, &tx_eq, 1);\n}\n\nstatic void apply_rx_eq_emp(struct hfi1_pportdata *ppd, u32 rx_preset_index)\n{\n\tu32 rx_preset;\n\tu8 rx_eq, *cache = ppd->qsfp_info.cache;\n\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x2))\n\t\treturn;\n\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\t\trx_preset_index, RX_PRESET_TABLE_QSFP_RX_EMP_APPLY,\n\t\t\t&rx_preset, 4);\n\n\tif (!rx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: RX_EMP_APPLY is set to disabled\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\trx_preset_index, RX_PRESET_TABLE_QSFP_RX_EMP,\n\t\t&rx_preset, 4);\n\n\tif ((cache[(128 * 3) + 224] & 0xF) < rx_preset) {\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: Requested RX EMP %x\\n\",\n\t\t\t__func__, rx_preset);\n\n\t\tdd_dev_info(\n\t\t\tppd->dd,\n\t\t\t\"%s: Applying supported EMP %x\\n\",\n\t\t\t__func__, cache[608] & 0xF);\n\n\t\trx_preset = cache[608] & 0xF;\n\t}\n\n\trx_eq = rx_preset | (rx_preset << 4);\n\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 236, &rx_eq, 1);\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 237, &rx_eq, 1);\n}\n\nstatic void apply_eq_settings(struct hfi1_pportdata *ppd,\n\t\t\t      u32 rx_preset_index, u32 tx_preset_index)\n{\n\tu8 *cache = ppd->qsfp_info.cache;\n\n\t \n\tif (cache[2] & 4) {\n\t\tdd_dev_info(ppd->dd,\n\t\t\t    \"%s: Upper page 03 not present\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tapply_tx_eq_auto(ppd);\n\n\tapply_tx_eq_prog(ppd, tx_preset_index);\n\n\tapply_rx_eq_emp(ppd, rx_preset_index);\n}\n\nstatic void apply_rx_amplitude_settings(\n\t\tstruct hfi1_pportdata *ppd, u32 rx_preset_index,\n\t\tu32 tx_preset_index)\n{\n\tu32 rx_preset;\n\tu8 rx_amp = 0, i = 0, preferred = 0, *cache = ppd->qsfp_info.cache;\n\n\t \n\tif (cache[2] & 4) {\n\t\tdd_dev_info(ppd->dd,\n\t\t\t    \"%s: Upper page 03 not present\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\tif (!(cache[QSFP_EQ_INFO_OFFS] & 0x1)) {\n\t\tdd_dev_info(ppd->dd,\n\t\t\t    \"%s: RX_AMP_APPLY is set to disabled\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tget_platform_config_field(ppd->dd,\n\t\t\t\t  PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\t\t\t  rx_preset_index,\n\t\t\t\t  RX_PRESET_TABLE_QSFP_RX_AMP_APPLY,\n\t\t\t\t  &rx_preset, 4);\n\n\tif (!rx_preset) {\n\t\tdd_dev_info(ppd->dd,\n\t\t\t    \"%s: RX_AMP_APPLY is set to disabled\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\tget_platform_config_field(ppd->dd,\n\t\t\t\t  PLATFORM_CONFIG_RX_PRESET_TABLE,\n\t\t\t\t  rx_preset_index,\n\t\t\t\t  RX_PRESET_TABLE_QSFP_RX_AMP,\n\t\t\t\t  &rx_preset, 4);\n\n\tdd_dev_info(ppd->dd,\n\t\t    \"%s: Requested RX AMP %x\\n\",\n\t\t    __func__,\n\t\t    rx_preset);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tif (cache[(128 * 3) + 225] & (1 << i)) {\n\t\t\tpreferred = i;\n\t\t\tif (preferred == rx_preset)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (!preferred && !(cache[(128 * 3) + 225] & 0x1)) {\n\t\tdd_dev_info(ppd->dd, \"No supported RX AMP, not applying\\n\");\n\t\treturn;\n\t}\n\n\tdd_dev_info(ppd->dd,\n\t\t    \"%s: Applying RX AMP %x\\n\", __func__, preferred);\n\n\trx_amp = preferred | (preferred << 4);\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 238, &rx_amp, 1);\n\tqsfp_write(ppd, ppd->dd->hfi1_id, (256 * 3) + 239, &rx_amp, 1);\n}\n\n#define OPA_INVALID_INDEX 0xFFF\n\nstatic void apply_tx_lanes(struct hfi1_pportdata *ppd, u8 field_id,\n\t\t\t   u32 config_data, const char *message)\n{\n\tu8 i;\n\tint ret;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tret = load_8051_config(ppd->dd, field_id, i, config_data);\n\t\tif (ret != HCMD_SUCCESS) {\n\t\t\tdd_dev_err(\n\t\t\t\tppd->dd,\n\t\t\t\t\"%s: %s for lane %u failed\\n\",\n\t\t\t\tmessage, __func__, i);\n\t\t}\n\t}\n}\n\n \nstatic u8 aoc_low_power_setting(struct hfi1_pportdata *ppd)\n{\n\tu8 *cache = ppd->qsfp_info.cache;\n\tint power_class;\n\n\t \n\tif (ppd->port_type != PORT_TYPE_QSFP)\n\t\treturn 0;  \n\n\t \n\tswitch ((cache[QSFP_MOD_TECH_OFFS] & 0xF0) >> 4) {\n\tcase 0x0 ... 0x9: fallthrough;\n\tcase 0xC: fallthrough;\n\tcase 0xE:\n\t\t \n\t\tpower_class = get_qsfp_power_class(cache[QSFP_MOD_PWR_OFFS]);\n\t\tif (power_class < QSFP_POWER_CLASS_4)\n\t\t\treturn 0xe;\n\t}\n\treturn 0;  \n}\n\nstatic void apply_tunings(\n\t\tstruct hfi1_pportdata *ppd, u32 tx_preset_index,\n\t\tu8 tuning_method, u32 total_atten, u8 limiting_active)\n{\n\tint ret = 0;\n\tu32 config_data = 0, tx_preset = 0;\n\tu8 precur = 0, attn = 0, postcur = 0, external_device_config = 0;\n\tu8 *cache = ppd->qsfp_info.cache;\n\n\t \n\tread_8051_config(ppd->dd, LINK_TUNING_PARAMETERS, GENERAL_CONFIG,\n\t\t\t &config_data);\n\tconfig_data &= ~(0xff << TUNING_METHOD_SHIFT);\n\tconfig_data |= ((u32)tuning_method << TUNING_METHOD_SHIFT);\n\tret = load_8051_config(ppd->dd, LINK_TUNING_PARAMETERS, GENERAL_CONFIG,\n\t\t\t       config_data);\n\tif (ret != HCMD_SUCCESS)\n\t\tdd_dev_err(ppd->dd, \"%s: Failed to set tuning method\\n\",\n\t\t\t   __func__);\n\n\t \n\tconfig_data = 0 | (total_atten << 16) | (total_atten << 24);\n\tapply_tx_lanes(ppd, CHANNEL_LOSS_SETTINGS, config_data,\n\t\t       \"Setting channel loss\");\n\n\t \n\tif (ppd->qsfp_info.cache_valid) {\n\t\texternal_device_config =\n\t\t\t((cache[QSFP_MOD_PWR_OFFS] & 0x4) << 3) |\n\t\t\t((cache[QSFP_MOD_PWR_OFFS] & 0x8) << 2) |\n\t\t\t((cache[QSFP_EQ_INFO_OFFS] & 0x2) << 1) |\n\t\t\t(cache[QSFP_EQ_INFO_OFFS] & 0x4);\n\t\tret = read_8051_config(ppd->dd, DC_HOST_COMM_SETTINGS,\n\t\t\t\t       GENERAL_CONFIG, &config_data);\n\t\t \n\t\tconfig_data &= ~(u32)0xFF;\n\t\tconfig_data |= external_device_config;\n\t\tret = load_8051_config(ppd->dd, DC_HOST_COMM_SETTINGS,\n\t\t\t\t       GENERAL_CONFIG, config_data);\n\t\tif (ret != HCMD_SUCCESS)\n\t\t\tdd_dev_err(ppd->dd,\n\t\t\t\t   \"%s: Failed set ext device config params\\n\",\n\t\t\t\t   __func__);\n\t}\n\n\tif (tx_preset_index == OPA_INVALID_INDEX) {\n\t\tif (ppd->port_type == PORT_TYPE_QSFP && limiting_active)\n\t\t\tdd_dev_err(ppd->dd, \"%s: Invalid Tx preset index\\n\",\n\t\t\t\t   __func__);\n\t\treturn;\n\t}\n\n\t \n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE, tx_preset_index,\n\t\tTX_PRESET_TABLE_PRECUR, &tx_preset, 4);\n\tprecur = tx_preset;\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index, TX_PRESET_TABLE_ATTN, &tx_preset, 4);\n\tattn = tx_preset;\n\n\tget_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_TX_PRESET_TABLE,\n\t\ttx_preset_index, TX_PRESET_TABLE_POSTCUR, &tx_preset, 4);\n\tpostcur = tx_preset;\n\n\t \n\tconfig_data = precur | (attn << 8) | (postcur << 16) |\n\t\t\t(aoc_low_power_setting(ppd) << 24);\n\n\tapply_tx_lanes(ppd, TX_EQ_SETTINGS, config_data,\n\t\t       \"Applying TX settings\");\n}\n\n \nstatic int tune_active_qsfp(struct hfi1_pportdata *ppd, u32 *ptr_tx_preset,\n\t\t\t    u32 *ptr_rx_preset, u32 *ptr_total_atten)\n{\n\tint ret;\n\tu16 lss = ppd->link_speed_supported, lse = ppd->link_speed_enabled;\n\tu8 *cache = ppd->qsfp_info.cache;\n\n\tppd->qsfp_info.limiting_active = 1;\n\n\tret = set_qsfp_tx(ppd, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qual_power(ppd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qual_bitrate(ppd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (ppd->qsfp_info.reset_needed) {\n\t\tret = reset_qsfp(ppd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trefresh_qsfp_cache(ppd, &ppd->qsfp_info);\n\t} else {\n\t\tppd->qsfp_info.reset_needed = 1;\n\t}\n\n\tret = set_qsfp_high_power(ppd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cache[QSFP_EQ_INFO_OFFS] & 0x4) {\n\t\tret = get_platform_config_field(\n\t\t\tppd->dd,\n\t\t\tPLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_TX_PRESET_IDX_ACTIVE_EQ,\n\t\t\tptr_tx_preset, 4);\n\t\tif (ret) {\n\t\t\t*ptr_tx_preset = OPA_INVALID_INDEX;\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = get_platform_config_field(\n\t\t\tppd->dd,\n\t\t\tPLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_TX_PRESET_IDX_ACTIVE_NO_EQ,\n\t\t\tptr_tx_preset, 4);\n\t\tif (ret) {\n\t\t\t*ptr_tx_preset = OPA_INVALID_INDEX;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = get_platform_config_field(\n\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\tPORT_TABLE_RX_PRESET_IDX, ptr_rx_preset, 4);\n\tif (ret) {\n\t\t*ptr_rx_preset = OPA_INVALID_INDEX;\n\t\treturn ret;\n\t}\n\n\tif ((lss & OPA_LINK_SPEED_25G) && (lse & OPA_LINK_SPEED_25G))\n\t\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_LOCAL_ATTEN_25G, ptr_total_atten, 4);\n\telse if ((lss & OPA_LINK_SPEED_12_5G) && (lse & OPA_LINK_SPEED_12_5G))\n\t\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_LOCAL_ATTEN_12G, ptr_total_atten, 4);\n\n\tapply_cdr_settings(ppd, *ptr_rx_preset, *ptr_tx_preset);\n\n\tapply_eq_settings(ppd, *ptr_rx_preset, *ptr_tx_preset);\n\n\tapply_rx_amplitude_settings(ppd, *ptr_rx_preset, *ptr_tx_preset);\n\n\tret = set_qsfp_tx(ppd, 1);\n\n\treturn ret;\n}\n\nstatic int tune_qsfp(struct hfi1_pportdata *ppd,\n\t\t     u32 *ptr_tx_preset, u32 *ptr_rx_preset,\n\t\t     u8 *ptr_tuning_method, u32 *ptr_total_atten)\n{\n\tu32 cable_atten = 0, remote_atten = 0, platform_atten = 0;\n\tu16 lss = ppd->link_speed_supported, lse = ppd->link_speed_enabled;\n\tint ret = 0;\n\tu8 *cache = ppd->qsfp_info.cache;\n\n\tswitch ((cache[QSFP_MOD_TECH_OFFS] & 0xF0) >> 4) {\n\tcase 0xA ... 0xB:\n\t\tret = get_platform_config_field(\n\t\t\tppd->dd,\n\t\t\tPLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_LOCAL_ATTEN_25G,\n\t\t\t&platform_atten, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((lss & OPA_LINK_SPEED_25G) && (lse & OPA_LINK_SPEED_25G))\n\t\t\tcable_atten = cache[QSFP_CU_ATTEN_12G_OFFS];\n\t\telse if ((lss & OPA_LINK_SPEED_12_5G) &&\n\t\t\t (lse & OPA_LINK_SPEED_12_5G))\n\t\t\tcable_atten = cache[QSFP_CU_ATTEN_7G_OFFS];\n\n\t\t \n\t\tif (cable_atten == 0 || cable_atten > 36) {\n\t\t\tret = get_platform_config_field(\n\t\t\t\tppd->dd,\n\t\t\t\tPLATFORM_CONFIG_SYSTEM_TABLE, 0,\n\t\t\t\tSYSTEM_TABLE_QSFP_ATTENUATION_DEFAULT_25G,\n\t\t\t\t&cable_atten, 4);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tret = get_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_REMOTE_ATTEN_25G, &remote_atten, 4);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*ptr_total_atten = platform_atten + cable_atten + remote_atten;\n\n\t\t*ptr_tuning_method = OPA_PASSIVE_TUNING;\n\t\tbreak;\n\tcase 0x0 ... 0x9: fallthrough;\n\tcase 0xC: fallthrough;\n\tcase 0xE:\n\t\tret = tune_active_qsfp(ppd, ptr_tx_preset, ptr_rx_preset,\n\t\t\t\t       ptr_total_atten);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t*ptr_tuning_method = OPA_ACTIVE_TUNING;\n\t\tbreak;\n\tcase 0xD: fallthrough;\n\tcase 0xF:\n\tdefault:\n\t\tdd_dev_warn(ppd->dd, \"%s: Unknown/unsupported cable\\n\",\n\t\t\t    __func__);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nvoid tune_serdes(struct hfi1_pportdata *ppd)\n{\n\tint ret = 0;\n\tu32 total_atten = 0;\n\tu32 remote_atten = 0, platform_atten = 0;\n\tu32 rx_preset_index, tx_preset_index;\n\tu8 tuning_method = 0, limiting_active = 0;\n\tstruct hfi1_devdata *dd = ppd->dd;\n\n\trx_preset_index = OPA_INVALID_INDEX;\n\ttx_preset_index = OPA_INVALID_INDEX;\n\n\t \n\tppd->link_enabled = 1;\n\t \n\tppd->driver_link_ready = 0;\n\tppd->offline_disabled_reason = HFI1_ODR_MASK(OPA_LINKDOWN_REASON_NONE);\n\n\t \n\tif (loopback != LOOPBACK_NONE ||\n\t    ppd->dd->icode == ICODE_FUNCTIONAL_SIMULATOR) {\n\t\tppd->driver_link_ready = 1;\n\n\t\tif (qsfp_mod_present(ppd)) {\n\t\t\tret = acquire_chip_resource(ppd->dd,\n\t\t\t\t\t\t    qsfp_resource(ppd->dd),\n\t\t\t\t\t\t    QSFP_WAIT);\n\t\t\tif (ret) {\n\t\t\t\tdd_dev_err(ppd->dd, \"%s: hfi%d: cannot lock i2c chain\\n\",\n\t\t\t\t\t   __func__, (int)ppd->dd->hfi1_id);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\trefresh_qsfp_cache(ppd, &ppd->qsfp_info);\n\t\t\trelease_chip_resource(ppd->dd, qsfp_resource(ppd->dd));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tswitch (ppd->port_type) {\n\tcase PORT_TYPE_DISCONNECTED:\n\t\tppd->offline_disabled_reason =\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_DISCONNECTED);\n\t\tdd_dev_warn(dd, \"%s: Port disconnected, disabling port\\n\",\n\t\t\t    __func__);\n\t\tgoto bail;\n\tcase PORT_TYPE_FIXED:\n\t\t \n\t\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_LOCAL_ATTEN_25G, &platform_atten, 4);\n\n\t\tget_platform_config_field(\n\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\tPORT_TABLE_REMOTE_ATTEN_25G, &remote_atten, 4);\n\n\t\ttotal_atten = platform_atten + remote_atten;\n\n\t\ttuning_method = OPA_PASSIVE_TUNING;\n\t\tbreak;\n\tcase PORT_TYPE_VARIABLE:\n\t\tif (qsfp_mod_present(ppd)) {\n\t\t\t \n\t\t\tget_platform_config_field(\n\t\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\t\tPORT_TABLE_LOCAL_ATTEN_25G,\n\t\t\t\t&platform_atten, 4);\n\n\t\t\tget_platform_config_field(\n\t\t\t\tppd->dd, PLATFORM_CONFIG_PORT_TABLE, 0,\n\t\t\t\tPORT_TABLE_REMOTE_ATTEN_25G,\n\t\t\t\t&remote_atten, 4);\n\n\t\t\ttotal_atten = platform_atten + remote_atten;\n\n\t\t\ttuning_method = OPA_PASSIVE_TUNING;\n\t\t} else {\n\t\t\tppd->offline_disabled_reason =\n\t\t\t     HFI1_ODR_MASK(OPA_LINKDOWN_REASON_CHASSIS_CONFIG);\n\t\t\tgoto bail;\n\t\t}\n\t\tbreak;\n\tcase PORT_TYPE_QSFP:\n\t\tif (qsfp_mod_present(ppd)) {\n\t\t\tret = acquire_chip_resource(ppd->dd,\n\t\t\t\t\t\t    qsfp_resource(ppd->dd),\n\t\t\t\t\t\t    QSFP_WAIT);\n\t\t\tif (ret) {\n\t\t\t\tdd_dev_err(ppd->dd, \"%s: hfi%d: cannot lock i2c chain\\n\",\n\t\t\t\t\t   __func__, (int)ppd->dd->hfi1_id);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\trefresh_qsfp_cache(ppd, &ppd->qsfp_info);\n\n\t\t\tif (ppd->qsfp_info.cache_valid) {\n\t\t\t\tret = tune_qsfp(ppd,\n\t\t\t\t\t\t&tx_preset_index,\n\t\t\t\t\t\t&rx_preset_index,\n\t\t\t\t\t\t&tuning_method,\n\t\t\t\t\t\t&total_atten);\n\n\t\t\t\t \n\t\t\t\trefresh_qsfp_cache(ppd, &ppd->qsfp_info);\n\t\t\t\tlimiting_active =\n\t\t\t\t\t\tppd->qsfp_info.limiting_active;\n\t\t\t} else {\n\t\t\t\tdd_dev_err(dd,\n\t\t\t\t\t   \"%s: Reading QSFP memory failed\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t\tret = -EINVAL;  \n\t\t\t}\n\t\t\trelease_chip_resource(ppd->dd, qsfp_resource(ppd->dd));\n\t\t\tif (ret)\n\t\t\t\tgoto bail;\n\t\t} else {\n\t\t\tppd->offline_disabled_reason =\n\t\t\t   HFI1_ODR_MASK(\n\t\t\t\tOPA_LINKDOWN_REASON_LOCAL_MEDIA_NOT_INSTALLED);\n\t\t\tgoto bail;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdd_dev_warn(ppd->dd, \"%s: Unknown port type\\n\", __func__);\n\t\tppd->port_type = PORT_TYPE_UNKNOWN;\n\t\ttuning_method = OPA_UNKNOWN_TUNING;\n\t\ttotal_atten = 0;\n\t\tlimiting_active = 0;\n\t\ttx_preset_index = OPA_INVALID_INDEX;\n\t\tbreak;\n\t}\n\n\tif (ppd->offline_disabled_reason ==\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_NONE))\n\t\tapply_tunings(ppd, tx_preset_index, tuning_method,\n\t\t\t      total_atten, limiting_active);\n\n\tif (!ret)\n\t\tppd->driver_link_ready = 1;\n\n\treturn;\nbail:\n\tppd->driver_link_ready = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}