{
  "module_name": "verbs.c",
  "hash_id": "cf528fd7f0fa58a14a10cd4fdae341d3c17b1f86eaf238e98124dea2dabacc66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/verbs.c",
  "human_readable_source": "\n \n\n#include <rdma/ib_mad.h>\n#include <rdma/ib_user_verbs.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/utsname.h>\n#include <linux/rculist.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <rdma/opa_addr.h>\n#include <linux/nospec.h>\n\n#include \"hfi.h\"\n#include \"common.h\"\n#include \"device.h\"\n#include \"trace.h\"\n#include \"qp.h\"\n#include \"verbs_txreq.h\"\n#include \"debugfs.h\"\n#include \"vnic.h\"\n#include \"fault.h\"\n#include \"affinity.h\"\n#include \"ipoib.h\"\n\nstatic unsigned int hfi1_lkey_table_size = 16;\nmodule_param_named(lkey_table_size, hfi1_lkey_table_size, uint,\n\t\t   S_IRUGO);\nMODULE_PARM_DESC(lkey_table_size,\n\t\t \"LKEY table size in bits (2^n, 1 <= n <= 23)\");\n\nstatic unsigned int hfi1_max_pds = 0xFFFF;\nmodule_param_named(max_pds, hfi1_max_pds, uint, S_IRUGO);\nMODULE_PARM_DESC(max_pds,\n\t\t \"Maximum number of protection domains to support\");\n\nstatic unsigned int hfi1_max_ahs = 0xFFFF;\nmodule_param_named(max_ahs, hfi1_max_ahs, uint, S_IRUGO);\nMODULE_PARM_DESC(max_ahs, \"Maximum number of address handles to support\");\n\nunsigned int hfi1_max_cqes = 0x2FFFFF;\nmodule_param_named(max_cqes, hfi1_max_cqes, uint, S_IRUGO);\nMODULE_PARM_DESC(max_cqes,\n\t\t \"Maximum number of completion queue entries to support\");\n\nunsigned int hfi1_max_cqs = 0x1FFFF;\nmodule_param_named(max_cqs, hfi1_max_cqs, uint, S_IRUGO);\nMODULE_PARM_DESC(max_cqs, \"Maximum number of completion queues to support\");\n\nunsigned int hfi1_max_qp_wrs = 0x3FFF;\nmodule_param_named(max_qp_wrs, hfi1_max_qp_wrs, uint, S_IRUGO);\nMODULE_PARM_DESC(max_qp_wrs, \"Maximum number of QP WRs to support\");\n\nunsigned int hfi1_max_qps = 32768;\nmodule_param_named(max_qps, hfi1_max_qps, uint, S_IRUGO);\nMODULE_PARM_DESC(max_qps, \"Maximum number of QPs to support\");\n\nunsigned int hfi1_max_sges = 0x60;\nmodule_param_named(max_sges, hfi1_max_sges, uint, S_IRUGO);\nMODULE_PARM_DESC(max_sges, \"Maximum number of SGEs to support\");\n\nunsigned int hfi1_max_mcast_grps = 16384;\nmodule_param_named(max_mcast_grps, hfi1_max_mcast_grps, uint, S_IRUGO);\nMODULE_PARM_DESC(max_mcast_grps,\n\t\t \"Maximum number of multicast groups to support\");\n\nunsigned int hfi1_max_mcast_qp_attached = 16;\nmodule_param_named(max_mcast_qp_attached, hfi1_max_mcast_qp_attached,\n\t\t   uint, S_IRUGO);\nMODULE_PARM_DESC(max_mcast_qp_attached,\n\t\t \"Maximum number of attached QPs to support\");\n\nunsigned int hfi1_max_srqs = 1024;\nmodule_param_named(max_srqs, hfi1_max_srqs, uint, S_IRUGO);\nMODULE_PARM_DESC(max_srqs, \"Maximum number of SRQs to support\");\n\nunsigned int hfi1_max_srq_sges = 128;\nmodule_param_named(max_srq_sges, hfi1_max_srq_sges, uint, S_IRUGO);\nMODULE_PARM_DESC(max_srq_sges, \"Maximum number of SRQ SGEs to support\");\n\nunsigned int hfi1_max_srq_wrs = 0x1FFFF;\nmodule_param_named(max_srq_wrs, hfi1_max_srq_wrs, uint, S_IRUGO);\nMODULE_PARM_DESC(max_srq_wrs, \"Maximum number of SRQ WRs support\");\n\nunsigned short piothreshold = 256;\nmodule_param(piothreshold, ushort, S_IRUGO);\nMODULE_PARM_DESC(piothreshold, \"size used to determine sdma vs. pio\");\n\nstatic unsigned int sge_copy_mode;\nmodule_param(sge_copy_mode, uint, S_IRUGO);\nMODULE_PARM_DESC(sge_copy_mode,\n\t\t \"Verbs copy mode: 0 use memcpy, 1 use cacheless copy, 2 adapt based on WSS\");\n\nstatic void verbs_sdma_complete(\n\tstruct sdma_txreq *cookie,\n\tint status);\n\nstatic int pio_wait(struct rvt_qp *qp,\n\t\t    struct send_context *sc,\n\t\t    struct hfi1_pkt_state *ps,\n\t\t    u32 flag);\n\n \n#define TXREQ_NAME_LEN 24\n\nstatic uint wss_threshold = 80;\nmodule_param(wss_threshold, uint, S_IRUGO);\nMODULE_PARM_DESC(wss_threshold, \"Percentage (1-100) of LLC to use as a threshold for a cacheless copy\");\nstatic uint wss_clean_period = 256;\nmodule_param(wss_clean_period, uint, S_IRUGO);\nMODULE_PARM_DESC(wss_clean_period, \"Count of verbs copies before an entry in the page copy table is cleaned\");\n\n \nconst enum ib_wc_opcode ib_hfi1_wc_opcode[] = {\n\t[IB_WR_RDMA_WRITE] = IB_WC_RDMA_WRITE,\n\t[IB_WR_TID_RDMA_WRITE] = IB_WC_RDMA_WRITE,\n\t[IB_WR_RDMA_WRITE_WITH_IMM] = IB_WC_RDMA_WRITE,\n\t[IB_WR_SEND] = IB_WC_SEND,\n\t[IB_WR_SEND_WITH_IMM] = IB_WC_SEND,\n\t[IB_WR_RDMA_READ] = IB_WC_RDMA_READ,\n\t[IB_WR_TID_RDMA_READ] = IB_WC_RDMA_READ,\n\t[IB_WR_ATOMIC_CMP_AND_SWP] = IB_WC_COMP_SWAP,\n\t[IB_WR_ATOMIC_FETCH_AND_ADD] = IB_WC_FETCH_ADD,\n\t[IB_WR_SEND_WITH_INV] = IB_WC_SEND,\n\t[IB_WR_LOCAL_INV] = IB_WC_LOCAL_INV,\n\t[IB_WR_REG_MR] = IB_WC_REG_MR\n};\n\n \nconst u8 hdr_len_by_opcode[256] = {\n\t \n\t[IB_OPCODE_RC_SEND_FIRST]                     = 12 + 8,\n\t[IB_OPCODE_RC_SEND_MIDDLE]                    = 12 + 8,\n\t[IB_OPCODE_RC_SEND_LAST]                      = 12 + 8,\n\t[IB_OPCODE_RC_SEND_LAST_WITH_IMMEDIATE]       = 12 + 8 + 4,\n\t[IB_OPCODE_RC_SEND_ONLY]                      = 12 + 8,\n\t[IB_OPCODE_RC_SEND_ONLY_WITH_IMMEDIATE]       = 12 + 8 + 4,\n\t[IB_OPCODE_RC_RDMA_WRITE_FIRST]               = 12 + 8 + 16,\n\t[IB_OPCODE_RC_RDMA_WRITE_MIDDLE]              = 12 + 8,\n\t[IB_OPCODE_RC_RDMA_WRITE_LAST]                = 12 + 8,\n\t[IB_OPCODE_RC_RDMA_WRITE_LAST_WITH_IMMEDIATE] = 12 + 8 + 4,\n\t[IB_OPCODE_RC_RDMA_WRITE_ONLY]                = 12 + 8 + 16,\n\t[IB_OPCODE_RC_RDMA_WRITE_ONLY_WITH_IMMEDIATE] = 12 + 8 + 20,\n\t[IB_OPCODE_RC_RDMA_READ_REQUEST]              = 12 + 8 + 16,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST]       = 12 + 8 + 4,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE]      = 12 + 8,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_LAST]        = 12 + 8 + 4,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_ONLY]        = 12 + 8 + 4,\n\t[IB_OPCODE_RC_ACKNOWLEDGE]                    = 12 + 8 + 4,\n\t[IB_OPCODE_RC_ATOMIC_ACKNOWLEDGE]             = 12 + 8 + 4 + 8,\n\t[IB_OPCODE_RC_COMPARE_SWAP]                   = 12 + 8 + 28,\n\t[IB_OPCODE_RC_FETCH_ADD]                      = 12 + 8 + 28,\n\t[IB_OPCODE_RC_SEND_LAST_WITH_INVALIDATE]      = 12 + 8 + 4,\n\t[IB_OPCODE_RC_SEND_ONLY_WITH_INVALIDATE]      = 12 + 8 + 4,\n\t[IB_OPCODE_TID_RDMA_READ_REQ]                 = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_READ_RESP]                = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_WRITE_REQ]                = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_WRITE_RESP]               = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_WRITE_DATA]               = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_WRITE_DATA_LAST]          = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_ACK]                      = 12 + 8 + 36,\n\t[IB_OPCODE_TID_RDMA_RESYNC]                   = 12 + 8 + 36,\n\t \n\t[IB_OPCODE_UC_SEND_FIRST]                     = 12 + 8,\n\t[IB_OPCODE_UC_SEND_MIDDLE]                    = 12 + 8,\n\t[IB_OPCODE_UC_SEND_LAST]                      = 12 + 8,\n\t[IB_OPCODE_UC_SEND_LAST_WITH_IMMEDIATE]       = 12 + 8 + 4,\n\t[IB_OPCODE_UC_SEND_ONLY]                      = 12 + 8,\n\t[IB_OPCODE_UC_SEND_ONLY_WITH_IMMEDIATE]       = 12 + 8 + 4,\n\t[IB_OPCODE_UC_RDMA_WRITE_FIRST]               = 12 + 8 + 16,\n\t[IB_OPCODE_UC_RDMA_WRITE_MIDDLE]              = 12 + 8,\n\t[IB_OPCODE_UC_RDMA_WRITE_LAST]                = 12 + 8,\n\t[IB_OPCODE_UC_RDMA_WRITE_LAST_WITH_IMMEDIATE] = 12 + 8 + 4,\n\t[IB_OPCODE_UC_RDMA_WRITE_ONLY]                = 12 + 8 + 16,\n\t[IB_OPCODE_UC_RDMA_WRITE_ONLY_WITH_IMMEDIATE] = 12 + 8 + 20,\n\t \n\t[IB_OPCODE_UD_SEND_ONLY]                      = 12 + 8 + 8,\n\t[IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE]       = 12 + 8 + 12\n};\n\nstatic const opcode_handler opcode_handler_tbl[256] = {\n\t \n\t[IB_OPCODE_RC_SEND_FIRST]                     = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_MIDDLE]                    = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_LAST]                      = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_LAST_WITH_IMMEDIATE]       = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_ONLY]                      = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_ONLY_WITH_IMMEDIATE]       = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_FIRST]               = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_MIDDLE]              = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_LAST]                = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_LAST_WITH_IMMEDIATE] = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_ONLY]                = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_WRITE_ONLY_WITH_IMMEDIATE] = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_READ_REQUEST]              = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST]       = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE]      = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_LAST]        = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_RDMA_READ_RESPONSE_ONLY]        = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_ACKNOWLEDGE]                    = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_ATOMIC_ACKNOWLEDGE]             = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_COMPARE_SWAP]                   = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_FETCH_ADD]                      = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_LAST_WITH_INVALIDATE]      = &hfi1_rc_rcv,\n\t[IB_OPCODE_RC_SEND_ONLY_WITH_INVALIDATE]      = &hfi1_rc_rcv,\n\n\t \n\t[IB_OPCODE_TID_RDMA_WRITE_REQ]       = &hfi1_rc_rcv_tid_rdma_write_req,\n\t[IB_OPCODE_TID_RDMA_WRITE_RESP]      = &hfi1_rc_rcv_tid_rdma_write_resp,\n\t[IB_OPCODE_TID_RDMA_WRITE_DATA]      = &hfi1_rc_rcv_tid_rdma_write_data,\n\t[IB_OPCODE_TID_RDMA_WRITE_DATA_LAST] = &hfi1_rc_rcv_tid_rdma_write_data,\n\t[IB_OPCODE_TID_RDMA_READ_REQ]        = &hfi1_rc_rcv_tid_rdma_read_req,\n\t[IB_OPCODE_TID_RDMA_READ_RESP]       = &hfi1_rc_rcv_tid_rdma_read_resp,\n\t[IB_OPCODE_TID_RDMA_RESYNC]          = &hfi1_rc_rcv_tid_rdma_resync,\n\t[IB_OPCODE_TID_RDMA_ACK]             = &hfi1_rc_rcv_tid_rdma_ack,\n\n\t \n\t[IB_OPCODE_UC_SEND_FIRST]                     = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_SEND_MIDDLE]                    = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_SEND_LAST]                      = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_SEND_LAST_WITH_IMMEDIATE]       = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_SEND_ONLY]                      = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_SEND_ONLY_WITH_IMMEDIATE]       = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_FIRST]               = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_MIDDLE]              = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_LAST]                = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_LAST_WITH_IMMEDIATE] = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_ONLY]                = &hfi1_uc_rcv,\n\t[IB_OPCODE_UC_RDMA_WRITE_ONLY_WITH_IMMEDIATE] = &hfi1_uc_rcv,\n\t \n\t[IB_OPCODE_UD_SEND_ONLY]                      = &hfi1_ud_rcv,\n\t[IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE]       = &hfi1_ud_rcv,\n\t \n\t[IB_OPCODE_CNP]\t\t\t\t      = &hfi1_cnp_rcv\n};\n\n#define OPMASK 0x1f\n\nstatic const u32 pio_opmask[BIT(3)] = {\n\t \n\t[IB_OPCODE_RC >> 5] =\n\t\tBIT(RC_OP(SEND_ONLY) & OPMASK) |\n\t\tBIT(RC_OP(SEND_ONLY_WITH_IMMEDIATE) & OPMASK) |\n\t\tBIT(RC_OP(RDMA_WRITE_ONLY) & OPMASK) |\n\t\tBIT(RC_OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE) & OPMASK) |\n\t\tBIT(RC_OP(RDMA_READ_REQUEST) & OPMASK) |\n\t\tBIT(RC_OP(ACKNOWLEDGE) & OPMASK) |\n\t\tBIT(RC_OP(ATOMIC_ACKNOWLEDGE) & OPMASK) |\n\t\tBIT(RC_OP(COMPARE_SWAP) & OPMASK) |\n\t\tBIT(RC_OP(FETCH_ADD) & OPMASK),\n\t \n\t[IB_OPCODE_UC >> 5] =\n\t\tBIT(UC_OP(SEND_ONLY) & OPMASK) |\n\t\tBIT(UC_OP(SEND_ONLY_WITH_IMMEDIATE) & OPMASK) |\n\t\tBIT(UC_OP(RDMA_WRITE_ONLY) & OPMASK) |\n\t\tBIT(UC_OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE) & OPMASK),\n};\n\n \n__be64 ib_hfi1_sys_image_guid;\n\n \nstatic inline opcode_handler qp_ok(struct hfi1_packet *packet)\n{\n\tif (!(ib_rvt_state_ops[packet->qp->state] & RVT_PROCESS_RECV_OK))\n\t\treturn NULL;\n\tif (((packet->opcode & RVT_OPCODE_QP_MASK) ==\n\t     packet->qp->allowed_ops) ||\n\t    (packet->opcode == IB_OPCODE_CNP))\n\t\treturn opcode_handler_tbl[packet->opcode];\n\n\treturn NULL;\n}\n\nstatic u64 hfi1_fault_tx(struct rvt_qp *qp, u8 opcode, u64 pbc)\n{\n#ifdef CONFIG_FAULT_INJECTION\n\tif ((opcode & IB_OPCODE_MSP) == IB_OPCODE_MSP) {\n\t\t \n\t\tpbc &= ~PBC_INSERT_HCRC_SMASK;\n\t\tpbc |= (u64)PBC_IHCRC_NONE << PBC_INSERT_HCRC_SHIFT;\n\t} else {\n\t\t \n\t\tpbc |= PBC_TEST_EBP;\n\t}\n#endif\n\treturn pbc;\n}\n\nstatic opcode_handler tid_qp_ok(int opcode, struct hfi1_packet *packet)\n{\n\tif (packet->qp->ibqp.qp_type != IB_QPT_RC ||\n\t    !(ib_rvt_state_ops[packet->qp->state] & RVT_PROCESS_RECV_OK))\n\t\treturn NULL;\n\tif ((opcode & RVT_OPCODE_QP_MASK) == IB_OPCODE_TID_RDMA)\n\t\treturn opcode_handler_tbl[opcode];\n\treturn NULL;\n}\n\nvoid hfi1_kdeth_eager_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tstruct ib_header *hdr = packet->hdr;\n\tu32 tlen = packet->tlen;\n\tstruct hfi1_pportdata *ppd = rcd->ppd;\n\tstruct hfi1_ibport *ibp = &ppd->ibport_data;\n\tstruct rvt_dev_info *rdi = &ppd->dd->verbs_dev.rdi;\n\topcode_handler opcode_handler;\n\tunsigned long flags;\n\tu32 qp_num;\n\tint lnh;\n\tu8 opcode;\n\n\t \n\tif (unlikely(tlen < 15 * sizeof(u32)))\n\t\tgoto drop;\n\n\tlnh = be16_to_cpu(hdr->lrh[0]) & 3;\n\tif (lnh != HFI1_LRH_BTH)\n\t\tgoto drop;\n\n\tpacket->ohdr = &hdr->u.oth;\n\ttrace_input_ibhdr(rcd->dd, packet, !!(rhf_dc_info(packet->rhf)));\n\n\topcode = (be32_to_cpu(packet->ohdr->bth[0]) >> 24);\n\tinc_opstats(tlen, &rcd->opstats->stats[opcode]);\n\n\t \n\tqp_num = be32_to_cpu(packet->ohdr->u.tid_rdma.r_req.verbs_qp) &\n\t\tRVT_QPN_MASK;\n\n\trcu_read_lock();\n\tpacket->qp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);\n\tif (!packet->qp)\n\t\tgoto drop_rcu;\n\tspin_lock_irqsave(&packet->qp->r_lock, flags);\n\topcode_handler = tid_qp_ok(opcode, packet);\n\tif (likely(opcode_handler))\n\t\topcode_handler(packet);\n\telse\n\t\tgoto drop_unlock;\n\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\n\trcu_read_unlock();\n\n\treturn;\ndrop_unlock:\n\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\ndrop_rcu:\n\trcu_read_unlock();\ndrop:\n\tibp->rvp.n_pkt_drops++;\n}\n\nvoid hfi1_kdeth_expected_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tstruct ib_header *hdr = packet->hdr;\n\tu32 tlen = packet->tlen;\n\tstruct hfi1_pportdata *ppd = rcd->ppd;\n\tstruct hfi1_ibport *ibp = &ppd->ibport_data;\n\tstruct rvt_dev_info *rdi = &ppd->dd->verbs_dev.rdi;\n\topcode_handler opcode_handler;\n\tunsigned long flags;\n\tu32 qp_num;\n\tint lnh;\n\tu8 opcode;\n\n\t \n\tif (unlikely(tlen < 15 * sizeof(u32)))\n\t\tgoto drop;\n\n\tlnh = be16_to_cpu(hdr->lrh[0]) & 3;\n\tif (lnh != HFI1_LRH_BTH)\n\t\tgoto drop;\n\n\tpacket->ohdr = &hdr->u.oth;\n\ttrace_input_ibhdr(rcd->dd, packet, !!(rhf_dc_info(packet->rhf)));\n\n\topcode = (be32_to_cpu(packet->ohdr->bth[0]) >> 24);\n\tinc_opstats(tlen, &rcd->opstats->stats[opcode]);\n\n\t \n\tqp_num = be32_to_cpu(packet->ohdr->u.tid_rdma.r_rsp.verbs_qp) &\n\t\tRVT_QPN_MASK;\n\n\trcu_read_lock();\n\tpacket->qp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);\n\tif (!packet->qp)\n\t\tgoto drop_rcu;\n\tspin_lock_irqsave(&packet->qp->r_lock, flags);\n\topcode_handler = tid_qp_ok(opcode, packet);\n\tif (likely(opcode_handler))\n\t\topcode_handler(packet);\n\telse\n\t\tgoto drop_unlock;\n\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\n\trcu_read_unlock();\n\n\treturn;\ndrop_unlock:\n\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\ndrop_rcu:\n\trcu_read_unlock();\ndrop:\n\tibp->rvp.n_pkt_drops++;\n}\n\nstatic int hfi1_do_pkey_check(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tstruct hfi1_pportdata *ppd = rcd->ppd;\n\tstruct hfi1_16b_header *hdr = packet->hdr;\n\tu16 pkey;\n\n\t \n\tif (packet->etype != RHF_RCV_TYPE_BYPASS)\n\t\treturn 0;\n\n\t \n\tpkey = hfi1_16B_get_pkey(hdr);\n\treturn ingress_pkey_check(ppd, pkey, packet->sc,\n\t\t\t\t  packet->qp->s_pkey_index,\n\t\t\t\t  packet->slid, true);\n}\n\nstatic inline void hfi1_handle_packet(struct hfi1_packet *packet,\n\t\t\t\t      bool is_mcast)\n{\n\tu32 qp_num;\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tstruct hfi1_pportdata *ppd = rcd->ppd;\n\tstruct hfi1_ibport *ibp = rcd_to_iport(rcd);\n\tstruct rvt_dev_info *rdi = &ppd->dd->verbs_dev.rdi;\n\topcode_handler packet_handler;\n\tunsigned long flags;\n\n\tinc_opstats(packet->tlen, &rcd->opstats->stats[packet->opcode]);\n\n\tif (unlikely(is_mcast)) {\n\t\tstruct rvt_mcast *mcast;\n\t\tstruct rvt_mcast_qp *p;\n\n\t\tif (!packet->grh)\n\t\t\tgoto drop;\n\t\tmcast = rvt_mcast_find(&ibp->rvp,\n\t\t\t\t       &packet->grh->dgid,\n\t\t\t\t       opa_get_lid(packet->dlid, 9B));\n\t\tif (!mcast)\n\t\t\tgoto drop;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(p, &mcast->qp_list, list) {\n\t\t\tpacket->qp = p->qp;\n\t\t\tif (hfi1_do_pkey_check(packet))\n\t\t\t\tgoto unlock_drop;\n\t\t\tspin_lock_irqsave(&packet->qp->r_lock, flags);\n\t\t\tpacket_handler = qp_ok(packet);\n\t\t\tif (likely(packet_handler))\n\t\t\t\tpacket_handler(packet);\n\t\t\telse\n\t\t\t\tibp->rvp.n_pkt_drops++;\n\t\t\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\n\t\t}\n\t\trcu_read_unlock();\n\t\t \n\t\tif (atomic_dec_return(&mcast->refcount) <= 1)\n\t\t\twake_up(&mcast->wait);\n\t} else {\n\t\t \n\t\tif (packet->etype == RHF_RCV_TYPE_BYPASS &&\n\t\t    hfi1_16B_get_l4(packet->hdr) == OPA_16B_L4_FM)\n\t\t\tqp_num = hfi1_16B_get_dest_qpn(packet->mgmt);\n\t\telse\n\t\t\tqp_num = ib_bth_get_qpn(packet->ohdr);\n\n\t\trcu_read_lock();\n\t\tpacket->qp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);\n\t\tif (!packet->qp)\n\t\t\tgoto unlock_drop;\n\n\t\tif (hfi1_do_pkey_check(packet))\n\t\t\tgoto unlock_drop;\n\n\t\tspin_lock_irqsave(&packet->qp->r_lock, flags);\n\t\tpacket_handler = qp_ok(packet);\n\t\tif (likely(packet_handler))\n\t\t\tpacket_handler(packet);\n\t\telse\n\t\t\tibp->rvp.n_pkt_drops++;\n\t\tspin_unlock_irqrestore(&packet->qp->r_lock, flags);\n\t\trcu_read_unlock();\n\t}\n\treturn;\nunlock_drop:\n\trcu_read_unlock();\ndrop:\n\tibp->rvp.n_pkt_drops++;\n}\n\n \nvoid hfi1_ib_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\n\ttrace_input_ibhdr(rcd->dd, packet, !!(rhf_dc_info(packet->rhf)));\n\thfi1_handle_packet(packet, hfi1_check_mcast(packet->dlid));\n}\n\nvoid hfi1_16B_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\n\ttrace_input_ibhdr(rcd->dd, packet, false);\n\thfi1_handle_packet(packet, hfi1_check_mcast(packet->dlid));\n}\n\n \nstatic void mem_timer(struct timer_list *t)\n{\n\tstruct hfi1_ibdev *dev = from_timer(dev, t, mem_timer);\n\tstruct list_head *list = &dev->memwait;\n\tstruct rvt_qp *qp = NULL;\n\tstruct iowait *wait;\n\tunsigned long flags;\n\tstruct hfi1_qp_priv *priv;\n\n\twrite_seqlock_irqsave(&dev->iowait_lock, flags);\n\tif (!list_empty(list)) {\n\t\twait = list_first_entry(list, struct iowait, list);\n\t\tqp = iowait_to_qp(wait);\n\t\tpriv = qp->priv;\n\t\tlist_del_init(&priv->s_iowait.list);\n\t\tpriv->s_iowait.lock = NULL;\n\t\t \n\t\tif (!list_empty(list))\n\t\t\tmod_timer(&dev->mem_timer, jiffies + 1);\n\t}\n\twrite_sequnlock_irqrestore(&dev->iowait_lock, flags);\n\n\tif (qp)\n\t\thfi1_qp_wakeup(qp, RVT_S_WAIT_KMEM);\n}\n\n \n \nstatic void verbs_sdma_complete(\n\tstruct sdma_txreq *cookie,\n\tint status)\n{\n\tstruct verbs_txreq *tx =\n\t\tcontainer_of(cookie, struct verbs_txreq, txreq);\n\tstruct rvt_qp *qp = tx->qp;\n\n\tspin_lock(&qp->s_lock);\n\tif (tx->wqe) {\n\t\trvt_send_complete(qp, tx->wqe, IB_WC_SUCCESS);\n\t} else if (qp->ibqp.qp_type == IB_QPT_RC) {\n\t\tstruct hfi1_opa_header *hdr;\n\n\t\thdr = &tx->phdr.hdr;\n\t\tif (unlikely(status == SDMA_TXREQ_S_ABORTED))\n\t\t\thfi1_rc_verbs_aborted(qp, hdr);\n\t\thfi1_rc_send_complete(qp, hdr);\n\t}\n\tspin_unlock(&qp->s_lock);\n\n\thfi1_put_txreq(tx);\n}\n\nvoid hfi1_wait_kmem(struct rvt_qp *qp)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct ib_qp *ibqp = &qp->ibqp;\n\tstruct ib_device *ibdev = ibqp->device;\n\tstruct hfi1_ibdev *dev = to_idev(ibdev);\n\n\tif (list_empty(&priv->s_iowait.list)) {\n\t\tif (list_empty(&dev->memwait))\n\t\t\tmod_timer(&dev->mem_timer, jiffies + 1);\n\t\tqp->s_flags |= RVT_S_WAIT_KMEM;\n\t\tlist_add_tail(&priv->s_iowait.list, &dev->memwait);\n\t\tpriv->s_iowait.lock = &dev->iowait_lock;\n\t\ttrace_hfi1_qpsleep(qp, RVT_S_WAIT_KMEM);\n\t\trvt_get_qp(qp);\n\t}\n}\n\nstatic int wait_kmem(struct hfi1_ibdev *dev,\n\t\t     struct rvt_qp *qp,\n\t\t     struct hfi1_pkt_state *ps)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\tif (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK) {\n\t\twrite_seqlock(&dev->iowait_lock);\n\t\tlist_add_tail(&ps->s_txreq->txreq.list,\n\t\t\t      &ps->wait->tx_head);\n\t\thfi1_wait_kmem(qp);\n\t\twrite_sequnlock(&dev->iowait_lock);\n\t\thfi1_qp_unbusy(qp, ps->wait);\n\t\tret = -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic noinline int build_verbs_ulp_payload(\n\tstruct sdma_engine *sde,\n\tu32 length,\n\tstruct verbs_txreq *tx)\n{\n\tstruct rvt_sge_state *ss = tx->ss;\n\tstruct rvt_sge *sg_list = ss->sg_list;\n\tstruct rvt_sge sge = ss->sge;\n\tu8 num_sge = ss->num_sge;\n\tu32 len;\n\tint ret = 0;\n\n\twhile (length) {\n\t\tlen = rvt_get_sge_length(&ss->sge, length);\n\t\tWARN_ON_ONCE(len == 0);\n\t\tret = sdma_txadd_kvaddr(\n\t\t\tsde->dd,\n\t\t\t&tx->txreq,\n\t\t\tss->sge.vaddr,\n\t\t\tlen);\n\t\tif (ret)\n\t\t\tgoto bail_txadd;\n\t\trvt_update_sge(ss, len, false);\n\t\tlength -= len;\n\t}\n\treturn ret;\nbail_txadd:\n\t \n\tss->sge = sge;\n\tss->num_sge = num_sge;\n\tss->sg_list = sg_list;\n\treturn ret;\n}\n\n \nstatic void update_tx_opstats(struct rvt_qp *qp, struct hfi1_pkt_state *ps,\n\t\t\t      u32 plen)\n{\n#ifdef CONFIG_DEBUG_FS\n\tstruct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);\n\tstruct hfi1_opcode_stats_perctx *s = get_cpu_ptr(dd->tx_opstats);\n\n\tinc_opstats(plen * 4, &s->stats[ps->opcode]);\n\tput_cpu_ptr(s);\n#endif\n}\n\n \n \nstatic int build_verbs_tx_desc(\n\tstruct sdma_engine *sde,\n\tu32 length,\n\tstruct verbs_txreq *tx,\n\tstruct hfi1_ahg_info *ahg_info,\n\tu64 pbc)\n{\n\tint ret = 0;\n\tstruct hfi1_sdma_header *phdr = &tx->phdr;\n\tu16 hdrbytes = (tx->hdr_dwords + sizeof(pbc) / 4) << 2;\n\tu8 extra_bytes = 0;\n\n\tif (tx->phdr.hdr.hdr_type) {\n\t\t \n\t\textra_bytes = hfi1_get_16b_padding(hdrbytes - 8, length) +\n\t\t\t      (SIZE_OF_CRC << 2) + SIZE_OF_LT;\n\t}\n\tif (!ahg_info->ahgcount) {\n\t\tret = sdma_txinit_ahg(\n\t\t\t&tx->txreq,\n\t\t\tahg_info->tx_flags,\n\t\t\thdrbytes + length +\n\t\t\textra_bytes,\n\t\t\tahg_info->ahgidx,\n\t\t\t0,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tverbs_sdma_complete);\n\t\tif (ret)\n\t\t\tgoto bail_txadd;\n\t\tphdr->pbc = cpu_to_le64(pbc);\n\t\tret = sdma_txadd_kvaddr(\n\t\t\tsde->dd,\n\t\t\t&tx->txreq,\n\t\t\tphdr,\n\t\t\thdrbytes);\n\t\tif (ret)\n\t\t\tgoto bail_txadd;\n\t} else {\n\t\tret = sdma_txinit_ahg(\n\t\t\t&tx->txreq,\n\t\t\tahg_info->tx_flags,\n\t\t\tlength,\n\t\t\tahg_info->ahgidx,\n\t\t\tahg_info->ahgcount,\n\t\t\tahg_info->ahgdesc,\n\t\t\thdrbytes,\n\t\t\tverbs_sdma_complete);\n\t\tif (ret)\n\t\t\tgoto bail_txadd;\n\t}\n\t \n\tif (tx->ss) {\n\t\tret = build_verbs_ulp_payload(sde, length, tx);\n\t\tif (ret)\n\t\t\tgoto bail_txadd;\n\t}\n\n\t \n\tif (extra_bytes)\n\t\tret = sdma_txadd_daddr(sde->dd, &tx->txreq, sde->dd->sdma_pad_phys,\n\t\t\t\t       extra_bytes);\n\nbail_txadd:\n\treturn ret;\n}\n\nstatic u64 update_hcrc(u8 opcode, u64 pbc)\n{\n\tif ((opcode & IB_OPCODE_TID_RDMA) == IB_OPCODE_TID_RDMA) {\n\t\tpbc &= ~PBC_INSERT_HCRC_SMASK;\n\t\tpbc |= (u64)PBC_IHCRC_LKDETH << PBC_INSERT_HCRC_SHIFT;\n\t}\n\treturn pbc;\n}\n\nint hfi1_verbs_send_dma(struct rvt_qp *qp, struct hfi1_pkt_state *ps,\n\t\t\tu64 pbc)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_ahg_info *ahg_info = priv->s_ahg;\n\tu32 hdrwords = ps->s_txreq->hdr_dwords;\n\tu32 len = ps->s_txreq->s_cur_size;\n\tu32 plen;\n\tstruct hfi1_ibdev *dev = ps->dev;\n\tstruct hfi1_pportdata *ppd = ps->ppd;\n\tstruct verbs_txreq *tx;\n\tu8 sc5 = priv->s_sc;\n\tint ret;\n\tu32 dwords;\n\n\tif (ps->s_txreq->phdr.hdr.hdr_type) {\n\t\tu8 extra_bytes = hfi1_get_16b_padding((hdrwords << 2), len);\n\n\t\tdwords = (len + extra_bytes + (SIZE_OF_CRC << 2) +\n\t\t\t  SIZE_OF_LT) >> 2;\n\t} else {\n\t\tdwords = (len + 3) >> 2;\n\t}\n\tplen = hdrwords + dwords + sizeof(pbc) / 4;\n\n\ttx = ps->s_txreq;\n\tif (!sdma_txreq_built(&tx->txreq)) {\n\t\tif (likely(pbc == 0)) {\n\t\t\tu32 vl = sc_to_vlt(dd_from_ibdev(qp->ibqp.device), sc5);\n\n\t\t\t \n\t\t\t \n\t\t\tif (ps->s_txreq->phdr.hdr.hdr_type)\n\t\t\t\tpbc |= PBC_PACKET_BYPASS |\n\t\t\t\t       PBC_INSERT_BYPASS_ICRC;\n\t\t\telse\n\t\t\t\tpbc |= (ib_is_sc5(sc5) << PBC_DC_INFO_SHIFT);\n\n\t\t\tpbc = create_pbc(ppd,\n\t\t\t\t\t pbc,\n\t\t\t\t\t qp->srate_mbps,\n\t\t\t\t\t vl,\n\t\t\t\t\t plen);\n\n\t\t\tif (unlikely(hfi1_dbg_should_fault_tx(qp, ps->opcode)))\n\t\t\t\tpbc = hfi1_fault_tx(qp, ps->opcode, pbc);\n\t\t\telse\n\t\t\t\t \n\t\t\t\tpbc = update_hcrc(ps->opcode, pbc);\n\t\t}\n\t\ttx->wqe = qp->s_wqe;\n\t\tret = build_verbs_tx_desc(tx->sde, len, tx, ahg_info, pbc);\n\t\tif (unlikely(ret))\n\t\t\tgoto bail_build;\n\t}\n\tret =  sdma_send_txreq(tx->sde, ps->wait, &tx->txreq, ps->pkts_sent);\n\tif (unlikely(ret < 0)) {\n\t\tif (ret == -ECOMM)\n\t\t\tgoto bail_ecomm;\n\t\treturn ret;\n\t}\n\n\tupdate_tx_opstats(qp, ps, plen);\n\ttrace_sdma_output_ibhdr(dd_from_ibdev(qp->ibqp.device),\n\t\t\t\t&ps->s_txreq->phdr.hdr, ib_is_sc5(sc5));\n\treturn ret;\n\nbail_ecomm:\n\t \n\treturn 0;\nbail_build:\n\tret = wait_kmem(dev, qp, ps);\n\tif (!ret) {\n\t\t \n\t\thfi1_put_txreq(ps->s_txreq);\n\t\tps->s_txreq = NULL;\n\t}\n\treturn ret;\n}\n\n \nstatic int pio_wait(struct rvt_qp *qp,\n\t\t    struct send_context *sc,\n\t\t    struct hfi1_pkt_state *ps,\n\t\t    u32 flag)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_devdata *dd = sc->dd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tspin_lock_irqsave(&qp->s_lock, flags);\n\tif (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK) {\n\t\twrite_seqlock(&sc->waitlock);\n\t\tlist_add_tail(&ps->s_txreq->txreq.list,\n\t\t\t      &ps->wait->tx_head);\n\t\tif (list_empty(&priv->s_iowait.list)) {\n\t\t\tstruct hfi1_ibdev *dev = &dd->verbs_dev;\n\t\t\tint was_empty;\n\n\t\t\tdev->n_piowait += !!(flag & RVT_S_WAIT_PIO);\n\t\t\tdev->n_piodrain += !!(flag & HFI1_S_WAIT_PIO_DRAIN);\n\t\t\tqp->s_flags |= flag;\n\t\t\twas_empty = list_empty(&sc->piowait);\n\t\t\tiowait_get_priority(&priv->s_iowait);\n\t\t\tiowait_queue(ps->pkts_sent, &priv->s_iowait,\n\t\t\t\t     &sc->piowait);\n\t\t\tpriv->s_iowait.lock = &sc->waitlock;\n\t\t\ttrace_hfi1_qpsleep(qp, RVT_S_WAIT_PIO);\n\t\t\trvt_get_qp(qp);\n\t\t\t \n\t\t\tif (was_empty)\n\t\t\t\thfi1_sc_wantpiobuf_intr(sc, 1);\n\t\t}\n\t\twrite_sequnlock(&sc->waitlock);\n\t\thfi1_qp_unbusy(qp, ps->wait);\n\t\tret = -EBUSY;\n\t}\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\treturn ret;\n}\n\nstatic void verbs_pio_complete(void *arg, int code)\n{\n\tstruct rvt_qp *qp = (struct rvt_qp *)arg;\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\tif (iowait_pio_dec(&priv->s_iowait))\n\t\tiowait_drain_wakeup(&priv->s_iowait);\n}\n\nint hfi1_verbs_send_pio(struct rvt_qp *qp, struct hfi1_pkt_state *ps,\n\t\t\tu64 pbc)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tu32 hdrwords = ps->s_txreq->hdr_dwords;\n\tstruct rvt_sge_state *ss = ps->s_txreq->ss;\n\tu32 len = ps->s_txreq->s_cur_size;\n\tu32 dwords;\n\tu32 plen;\n\tstruct hfi1_pportdata *ppd = ps->ppd;\n\tu32 *hdr;\n\tu8 sc5;\n\tunsigned long flags = 0;\n\tstruct send_context *sc;\n\tstruct pio_buf *pbuf;\n\tint wc_status = IB_WC_SUCCESS;\n\tint ret = 0;\n\tpio_release_cb cb = NULL;\n\tu8 extra_bytes = 0;\n\n\tif (ps->s_txreq->phdr.hdr.hdr_type) {\n\t\tu8 pad_size = hfi1_get_16b_padding((hdrwords << 2), len);\n\n\t\textra_bytes = pad_size + (SIZE_OF_CRC << 2) + SIZE_OF_LT;\n\t\tdwords = (len + extra_bytes) >> 2;\n\t\thdr = (u32 *)&ps->s_txreq->phdr.hdr.opah;\n\t} else {\n\t\tdwords = (len + 3) >> 2;\n\t\thdr = (u32 *)&ps->s_txreq->phdr.hdr.ibh;\n\t}\n\tplen = hdrwords + dwords + sizeof(pbc) / 4;\n\n\t \n\tswitch (qp->ibqp.qp_type) {\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\t\tcb = verbs_pio_complete;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tsc5 = priv->s_sc;\n\tsc = ps->s_txreq->psc;\n\n\tif (likely(pbc == 0)) {\n\t\tu8 vl = sc_to_vlt(dd_from_ibdev(qp->ibqp.device), sc5);\n\n\t\t \n\t\tif (ps->s_txreq->phdr.hdr.hdr_type)\n\t\t\tpbc |= PBC_PACKET_BYPASS | PBC_INSERT_BYPASS_ICRC;\n\t\telse\n\t\t\tpbc |= (ib_is_sc5(sc5) << PBC_DC_INFO_SHIFT);\n\n\t\tpbc = create_pbc(ppd, pbc, qp->srate_mbps, vl, plen);\n\t\tif (unlikely(hfi1_dbg_should_fault_tx(qp, ps->opcode)))\n\t\t\tpbc = hfi1_fault_tx(qp, ps->opcode, pbc);\n\t\telse\n\t\t\t \n\t\t\tpbc = update_hcrc(ps->opcode, pbc);\n\t}\n\tif (cb)\n\t\tiowait_pio_inc(&priv->s_iowait);\n\tpbuf = sc_buffer_alloc(sc, plen, cb, qp);\n\tif (IS_ERR_OR_NULL(pbuf)) {\n\t\tif (cb)\n\t\t\tverbs_pio_complete(qp, 0);\n\t\tif (IS_ERR(pbuf)) {\n\t\t\t \n\t\t\thfi1_cdbg(\n\t\t\t\tPIO,\n\t\t\t\t\"alloc failed. state not active, completing\");\n\t\t\twc_status = IB_WC_GENERAL_ERR;\n\t\t\tgoto pio_bail;\n\t\t} else {\n\t\t\t \n\t\t\thfi1_cdbg(PIO, \"alloc failed. state active, queuing\");\n\t\t\tret = pio_wait(qp, sc, ps, RVT_S_WAIT_PIO);\n\t\t\tif (!ret)\n\t\t\t\t \n\t\t\t\tgoto bail;\n\t\t\t \n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (dwords == 0) {\n\t\tpio_copy(ppd->dd, pbuf, pbc, hdr, hdrwords);\n\t} else {\n\t\tseg_pio_copy_start(pbuf, pbc,\n\t\t\t\t   hdr, hdrwords * 4);\n\t\tif (ss) {\n\t\t\twhile (len) {\n\t\t\t\tvoid *addr = ss->sge.vaddr;\n\t\t\t\tu32 slen = rvt_get_sge_length(&ss->sge, len);\n\n\t\t\t\trvt_update_sge(ss, slen, false);\n\t\t\t\tseg_pio_copy_mid(pbuf, addr, slen);\n\t\t\t\tlen -= slen;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (extra_bytes)\n\t\t\tseg_pio_copy_mid(pbuf, ppd->dd->sdma_pad_dma,\n\t\t\t\t\t extra_bytes);\n\n\t\tseg_pio_copy_end(pbuf);\n\t}\n\n\tupdate_tx_opstats(qp, ps, plen);\n\ttrace_pio_output_ibhdr(dd_from_ibdev(qp->ibqp.device),\n\t\t\t       &ps->s_txreq->phdr.hdr, ib_is_sc5(sc5));\n\npio_bail:\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\tif (qp->s_wqe) {\n\t\trvt_send_complete(qp, qp->s_wqe, wc_status);\n\t} else if (qp->ibqp.qp_type == IB_QPT_RC) {\n\t\tif (unlikely(wc_status == IB_WC_GENERAL_ERR))\n\t\t\thfi1_rc_verbs_aborted(qp, &ps->s_txreq->phdr.hdr);\n\t\thfi1_rc_send_complete(qp, &ps->s_txreq->phdr.hdr);\n\t}\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\n\tret = 0;\n\nbail:\n\thfi1_put_txreq(ps->s_txreq);\n\treturn ret;\n}\n\n \nstatic inline int egress_pkey_matches_entry(u16 pkey, u16 ent)\n{\n\tu16 mkey = pkey & PKEY_LOW_15_MASK;\n\tu16 mentry = ent & PKEY_LOW_15_MASK;\n\n\tif (mkey == mentry) {\n\t\t \n\t\tif (pkey & PKEY_MEMBER_MASK)\n\t\t\treturn !!(ent & PKEY_MEMBER_MASK);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n \nint egress_pkey_check(struct hfi1_pportdata *ppd, u32 slid, u16 pkey,\n\t\t      u8 sc5, int8_t s_pkey_index)\n{\n\tstruct hfi1_devdata *dd;\n\tint i;\n\tint is_user_ctxt_mechanism = (s_pkey_index < 0);\n\n\tif (!(ppd->part_enforce & HFI1_PART_ENFORCE_OUT))\n\t\treturn 0;\n\n\t \n\tif ((sc5 == 0xf) && ((pkey & PKEY_LOW_15_MASK) != PKEY_LOW_15_MASK))\n\t\tgoto bad;\n\n\t \n\tif ((pkey & PKEY_LOW_15_MASK) == 0)\n\t\tgoto bad;\n\n\t \n\tif (!is_user_ctxt_mechanism &&\n\t    egress_pkey_matches_entry(pkey, ppd->pkeys[s_pkey_index])) {\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < MAX_PKEY_VALUES; i++) {\n\t\tif (egress_pkey_matches_entry(pkey, ppd->pkeys[i]))\n\t\t\treturn 0;\n\t}\nbad:\n\t \n\tif (!is_user_ctxt_mechanism) {\n\t\tincr_cntr64(&ppd->port_xmit_constraint_errors);\n\t\tdd = ppd->dd;\n\t\tif (!(dd->err_info_xmit_constraint.status &\n\t\t      OPA_EI_STATUS_SMASK)) {\n\t\t\tdd->err_info_xmit_constraint.status |=\n\t\t\t\tOPA_EI_STATUS_SMASK;\n\t\t\tdd->err_info_xmit_constraint.slid = slid;\n\t\t\tdd->err_info_xmit_constraint.pkey = pkey;\n\t\t}\n\t}\n\treturn 1;\n}\n\n \nstatic inline send_routine get_send_routine(struct rvt_qp *qp,\n\t\t\t\t\t    struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct verbs_txreq *tx = ps->s_txreq;\n\n\tif (unlikely(!(dd->flags & HFI1_HAS_SEND_DMA)))\n\t\treturn dd->process_pio_send;\n\tswitch (qp->ibqp.qp_type) {\n\tcase IB_QPT_SMI:\n\t\treturn dd->process_pio_send;\n\tcase IB_QPT_GSI:\n\tcase IB_QPT_UD:\n\t\tbreak;\n\tcase IB_QPT_UC:\n\tcase IB_QPT_RC:\n\t\tpriv->s_running_pkt_size =\n\t\t\t(tx->s_cur_size + priv->s_running_pkt_size) / 2;\n\t\tif (piothreshold &&\n\t\t    priv->s_running_pkt_size <= min(piothreshold, qp->pmtu) &&\n\t\t    (BIT(ps->opcode & OPMASK) & pio_opmask[ps->opcode >> 5]) &&\n\t\t    iowait_sdma_pending(&priv->s_iowait) == 0 &&\n\t\t    !sdma_txreq_built(&tx->txreq))\n\t\t\treturn dd->process_pio_send;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn dd->process_dma_send;\n}\n\n \nint hfi1_verbs_send(struct rvt_qp *qp, struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(qp->ibqp.device);\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct ib_other_headers *ohdr = NULL;\n\tsend_routine sr;\n\tint ret;\n\tu16 pkey;\n\tu32 slid;\n\tu8 l4 = 0;\n\n\t \n\tif (ps->s_txreq->phdr.hdr.hdr_type) {\n\t\tstruct hfi1_16b_header *hdr = &ps->s_txreq->phdr.hdr.opah;\n\n\t\tl4 = hfi1_16B_get_l4(hdr);\n\t\tif (l4 == OPA_16B_L4_IB_LOCAL)\n\t\t\tohdr = &hdr->u.oth;\n\t\telse if (l4 == OPA_16B_L4_IB_GLOBAL)\n\t\t\tohdr = &hdr->u.l.oth;\n\n\t\tslid = hfi1_16B_get_slid(hdr);\n\t\tpkey = hfi1_16B_get_pkey(hdr);\n\t} else {\n\t\tstruct ib_header *hdr = &ps->s_txreq->phdr.hdr.ibh;\n\t\tu8 lnh = ib_get_lnh(hdr);\n\n\t\tif (lnh == HFI1_LRH_GRH)\n\t\t\tohdr = &hdr->u.l.oth;\n\t\telse\n\t\t\tohdr = &hdr->u.oth;\n\t\tslid = ib_get_slid(hdr);\n\t\tpkey = ib_bth_get_pkey(ohdr);\n\t}\n\n\tif (likely(l4 != OPA_16B_L4_FM))\n\t\tps->opcode = ib_bth_get_opcode(ohdr);\n\telse\n\t\tps->opcode = IB_OPCODE_UD_SEND_ONLY;\n\n\tsr = get_send_routine(qp, ps);\n\tret = egress_pkey_check(dd->pport, slid, pkey,\n\t\t\t\tpriv->s_sc, qp->s_pkey_index);\n\tif (unlikely(ret)) {\n\t\t \n\t\tif (sr == dd->process_pio_send) {\n\t\t\tunsigned long flags;\n\n\t\t\thfi1_cdbg(PIO, \"%s() Failed. Completing with err\",\n\t\t\t\t  __func__);\n\t\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\t\trvt_send_complete(qp, qp->s_wqe, IB_WC_GENERAL_ERR);\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tif (sr == dd->process_dma_send && iowait_pio_pending(&priv->s_iowait))\n\t\treturn pio_wait(qp,\n\t\t\t\tps->s_txreq->psc,\n\t\t\t\tps,\n\t\t\t\tHFI1_S_WAIT_PIO_DRAIN);\n\treturn sr(qp, ps, 0);\n}\n\n \nstatic void hfi1_fill_device_attr(struct hfi1_devdata *dd)\n{\n\tstruct rvt_dev_info *rdi = &dd->verbs_dev.rdi;\n\tu32 ver = dd->dc8051_ver;\n\n\tmemset(&rdi->dparms.props, 0, sizeof(rdi->dparms.props));\n\n\trdi->dparms.props.fw_ver = ((u64)(dc8051_ver_maj(ver)) << 32) |\n\t\t((u64)(dc8051_ver_min(ver)) << 16) |\n\t\t(u64)dc8051_ver_patch(ver);\n\n\trdi->dparms.props.device_cap_flags = IB_DEVICE_BAD_PKEY_CNTR |\n\t\t\tIB_DEVICE_BAD_QKEY_CNTR | IB_DEVICE_SHUTDOWN_PORT |\n\t\t\tIB_DEVICE_SYS_IMAGE_GUID | IB_DEVICE_RC_RNR_NAK_GEN |\n\t\t\tIB_DEVICE_PORT_ACTIVE_EVENT | IB_DEVICE_SRQ_RESIZE |\n\t\t\tIB_DEVICE_MEM_MGT_EXTENSIONS;\n\trdi->dparms.props.kernel_cap_flags = IBK_RDMA_NETDEV_OPA;\n\trdi->dparms.props.page_size_cap = PAGE_SIZE;\n\trdi->dparms.props.vendor_id = dd->oui1 << 16 | dd->oui2 << 8 | dd->oui3;\n\trdi->dparms.props.vendor_part_id = dd->pcidev->device;\n\trdi->dparms.props.hw_ver = dd->minrev;\n\trdi->dparms.props.sys_image_guid = ib_hfi1_sys_image_guid;\n\trdi->dparms.props.max_mr_size = U64_MAX;\n\trdi->dparms.props.max_fast_reg_page_list_len = UINT_MAX;\n\trdi->dparms.props.max_qp = hfi1_max_qps;\n\trdi->dparms.props.max_qp_wr =\n\t\t(hfi1_max_qp_wrs >= HFI1_QP_WQE_INVALID ?\n\t\t HFI1_QP_WQE_INVALID - 1 : hfi1_max_qp_wrs);\n\trdi->dparms.props.max_send_sge = hfi1_max_sges;\n\trdi->dparms.props.max_recv_sge = hfi1_max_sges;\n\trdi->dparms.props.max_sge_rd = hfi1_max_sges;\n\trdi->dparms.props.max_cq = hfi1_max_cqs;\n\trdi->dparms.props.max_ah = hfi1_max_ahs;\n\trdi->dparms.props.max_cqe = hfi1_max_cqes;\n\trdi->dparms.props.max_pd = hfi1_max_pds;\n\trdi->dparms.props.max_qp_rd_atom = HFI1_MAX_RDMA_ATOMIC;\n\trdi->dparms.props.max_qp_init_rd_atom = 255;\n\trdi->dparms.props.max_srq = hfi1_max_srqs;\n\trdi->dparms.props.max_srq_wr = hfi1_max_srq_wrs;\n\trdi->dparms.props.max_srq_sge = hfi1_max_srq_sges;\n\trdi->dparms.props.atomic_cap = IB_ATOMIC_GLOB;\n\trdi->dparms.props.max_pkeys = hfi1_get_npkeys(dd);\n\trdi->dparms.props.max_mcast_grp = hfi1_max_mcast_grps;\n\trdi->dparms.props.max_mcast_qp_attach = hfi1_max_mcast_qp_attached;\n\trdi->dparms.props.max_total_mcast_qp_attach =\n\t\t\t\t\trdi->dparms.props.max_mcast_qp_attach *\n\t\t\t\t\trdi->dparms.props.max_mcast_grp;\n}\n\nstatic inline u16 opa_speed_to_ib(u16 in)\n{\n\tu16 out = 0;\n\n\tif (in & OPA_LINK_SPEED_25G)\n\t\tout |= IB_SPEED_EDR;\n\tif (in & OPA_LINK_SPEED_12_5G)\n\t\tout |= IB_SPEED_FDR;\n\n\treturn out;\n}\n\n \nstatic inline u16 opa_width_to_ib(u16 in)\n{\n\tswitch (in) {\n\tcase OPA_LINK_WIDTH_1X:\n\t \n\tcase OPA_LINK_WIDTH_2X:\n\tcase OPA_LINK_WIDTH_3X:\n\t\treturn IB_WIDTH_1X;\n\tdefault:  \n\tcase OPA_LINK_WIDTH_4X:\n\t\treturn IB_WIDTH_4X;\n\t}\n}\n\nstatic int query_port(struct rvt_dev_info *rdi, u32 port_num,\n\t\t      struct ib_port_attr *props)\n{\n\tstruct hfi1_ibdev *verbs_dev = dev_from_rdi(rdi);\n\tstruct hfi1_devdata *dd = dd_from_dev(verbs_dev);\n\tstruct hfi1_pportdata *ppd = &dd->pport[port_num - 1];\n\tu32 lid = ppd->lid;\n\n\t \n\tprops->lid = lid ? lid : 0;\n\tprops->lmc = ppd->lmc;\n\t \n\tprops->state = driver_lstate(ppd);\n\tprops->phys_state = driver_pstate(ppd);\n\tprops->gid_tbl_len = HFI1_GUIDS_PER_PORT;\n\tprops->active_width = (u8)opa_width_to_ib(ppd->link_width_active);\n\t \n\tprops->active_speed = opa_speed_to_ib(ppd->link_speed_active);\n\tprops->max_vl_num = ppd->vls_supported;\n\n\t \n\tprops->max_mtu = mtu_to_enum((!valid_ib_mtu(hfi1_max_mtu) ?\n\t\t\t\t      4096 : hfi1_max_mtu), IB_MTU_4096);\n\tprops->active_mtu = !valid_ib_mtu(ppd->ibmtu) ? props->max_mtu :\n\t\tmtu_to_enum(ppd->ibmtu, IB_MTU_4096);\n\tprops->phys_mtu = hfi1_max_mtu;\n\n\treturn 0;\n}\n\nstatic int modify_device(struct ib_device *device,\n\t\t\t int device_modify_mask,\n\t\t\t struct ib_device_modify *device_modify)\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(device);\n\tunsigned i;\n\tint ret;\n\n\tif (device_modify_mask & ~(IB_DEVICE_MODIFY_SYS_IMAGE_GUID |\n\t\t\t\t   IB_DEVICE_MODIFY_NODE_DESC)) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto bail;\n\t}\n\n\tif (device_modify_mask & IB_DEVICE_MODIFY_NODE_DESC) {\n\t\tmemcpy(device->node_desc, device_modify->node_desc,\n\t\t       IB_DEVICE_NODE_DESC_MAX);\n\t\tfor (i = 0; i < dd->num_pports; i++) {\n\t\t\tstruct hfi1_ibport *ibp = &dd->pport[i].ibport_data;\n\n\t\t\thfi1_node_desc_chg(ibp);\n\t\t}\n\t}\n\n\tif (device_modify_mask & IB_DEVICE_MODIFY_SYS_IMAGE_GUID) {\n\t\tib_hfi1_sys_image_guid =\n\t\t\tcpu_to_be64(device_modify->sys_image_guid);\n\t\tfor (i = 0; i < dd->num_pports; i++) {\n\t\t\tstruct hfi1_ibport *ibp = &dd->pport[i].ibport_data;\n\n\t\t\thfi1_sys_guid_chg(ibp);\n\t\t}\n\t}\n\n\tret = 0;\n\nbail:\n\treturn ret;\n}\n\nstatic int shut_down_port(struct rvt_dev_info *rdi, u32 port_num)\n{\n\tstruct hfi1_ibdev *verbs_dev = dev_from_rdi(rdi);\n\tstruct hfi1_devdata *dd = dd_from_dev(verbs_dev);\n\tstruct hfi1_pportdata *ppd = &dd->pport[port_num - 1];\n\n\tset_link_down_reason(ppd, OPA_LINKDOWN_REASON_UNKNOWN, 0,\n\t\t\t     OPA_LINKDOWN_REASON_UNKNOWN);\n\treturn set_link_state(ppd, HLS_DN_DOWNDEF);\n}\n\nstatic int hfi1_get_guid_be(struct rvt_dev_info *rdi, struct rvt_ibport *rvp,\n\t\t\t    int guid_index, __be64 *guid)\n{\n\tstruct hfi1_ibport *ibp = container_of(rvp, struct hfi1_ibport, rvp);\n\n\tif (guid_index >= HFI1_GUIDS_PER_PORT)\n\t\treturn -EINVAL;\n\n\t*guid = get_sguid(ibp, guid_index);\n\treturn 0;\n}\n\n \nu8 ah_to_sc(struct ib_device *ibdev, struct rdma_ah_attr *ah)\n{\n\tstruct hfi1_ibport *ibp = to_iport(ibdev, rdma_ah_get_port_num(ah));\n\n\treturn ibp->sl_to_sc[rdma_ah_get_sl(ah)];\n}\n\nstatic int hfi1_check_ah(struct ib_device *ibdev, struct rdma_ah_attr *ah_attr)\n{\n\tstruct hfi1_ibport *ibp;\n\tstruct hfi1_pportdata *ppd;\n\tstruct hfi1_devdata *dd;\n\tu8 sc5;\n\tu8 sl;\n\n\tif (hfi1_check_mcast(rdma_ah_get_dlid(ah_attr)) &&\n\t    !(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))\n\t\treturn -EINVAL;\n\n\t \n\tibp = to_iport(ibdev, rdma_ah_get_port_num(ah_attr));\n\tppd = ppd_from_ibp(ibp);\n\tdd = dd_from_ppd(ppd);\n\n\tsl = rdma_ah_get_sl(ah_attr);\n\tif (sl >= ARRAY_SIZE(ibp->sl_to_sc))\n\t\treturn -EINVAL;\n\tsl = array_index_nospec(sl, ARRAY_SIZE(ibp->sl_to_sc));\n\n\tsc5 = ibp->sl_to_sc[sl];\n\tif (sc_to_vlt(dd, sc5) > num_vls && sc_to_vlt(dd, sc5) != 0xf)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic void hfi1_notify_new_ah(struct ib_device *ibdev,\n\t\t\t       struct rdma_ah_attr *ah_attr,\n\t\t\t       struct rvt_ah *ah)\n{\n\tstruct hfi1_ibport *ibp;\n\tstruct hfi1_pportdata *ppd;\n\tstruct hfi1_devdata *dd;\n\tu8 sc5;\n\tstruct rdma_ah_attr *attr = &ah->attr;\n\n\t \n\n\tibp = to_iport(ibdev, rdma_ah_get_port_num(ah_attr));\n\tppd = ppd_from_ibp(ibp);\n\tsc5 = ibp->sl_to_sc[rdma_ah_get_sl(&ah->attr)];\n\thfi1_update_ah_attr(ibdev, attr);\n\thfi1_make_opa_lid(attr);\n\tdd = dd_from_ppd(ppd);\n\tah->vl = sc_to_vlt(dd, sc5);\n\tif (ah->vl < num_vls || ah->vl == 15)\n\t\tah->log_pmtu = ilog2(dd->vld[ah->vl].mtu);\n}\n\n \nunsigned hfi1_get_npkeys(struct hfi1_devdata *dd)\n{\n\treturn ARRAY_SIZE(dd->pport[0].pkeys);\n}\n\nstatic void init_ibport(struct hfi1_pportdata *ppd)\n{\n\tstruct hfi1_ibport *ibp = &ppd->ibport_data;\n\tsize_t sz = ARRAY_SIZE(ibp->sl_to_sc);\n\tint i;\n\n\tfor (i = 0; i < sz; i++) {\n\t\tibp->sl_to_sc[i] = i;\n\t\tibp->sc_to_sl[i] = i;\n\t}\n\n\tfor (i = 0; i < RVT_MAX_TRAP_LISTS ; i++)\n\t\tINIT_LIST_HEAD(&ibp->rvp.trap_lists[i].list);\n\ttimer_setup(&ibp->rvp.trap_timer, hfi1_handle_trap_timer, 0);\n\n\tspin_lock_init(&ibp->rvp.lock);\n\t \n\tibp->rvp.gid_prefix = IB_DEFAULT_GID_PREFIX;\n\tibp->rvp.sm_lid = 0;\n\t \n\tibp->rvp.port_cap_flags = IB_PORT_AUTO_MIGR_SUP |\n\t\tIB_PORT_CAP_MASK_NOTICE_SUP;\n\tibp->rvp.port_cap3_flags = OPA_CAP_MASK3_IsSharedSpaceSupported;\n\tibp->rvp.pma_counter_select[0] = IB_PMA_PORT_XMIT_DATA;\n\tibp->rvp.pma_counter_select[1] = IB_PMA_PORT_RCV_DATA;\n\tibp->rvp.pma_counter_select[2] = IB_PMA_PORT_XMIT_PKTS;\n\tibp->rvp.pma_counter_select[3] = IB_PMA_PORT_RCV_PKTS;\n\tibp->rvp.pma_counter_select[4] = IB_PMA_PORT_XMIT_WAIT;\n\n\tRCU_INIT_POINTER(ibp->rvp.qp[0], NULL);\n\tRCU_INIT_POINTER(ibp->rvp.qp[1], NULL);\n}\n\nstatic void hfi1_get_dev_fw_str(struct ib_device *ibdev, char *str)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\tstruct hfi1_ibdev *dev = dev_from_rdi(rdi);\n\tu32 ver = dd_from_dev(dev)->dc8051_ver;\n\n\tsnprintf(str, IB_FW_VERSION_NAME_MAX, \"%u.%u.%u\", dc8051_ver_maj(ver),\n\t\t dc8051_ver_min(ver), dc8051_ver_patch(ver));\n}\n\nstatic const char * const driver_cntr_names[] = {\n\t \n\t\"DRIVER_KernIntr\",\n\t\"DRIVER_ErrorIntr\",\n\t\"DRIVER_Tx_Errs\",\n\t\"DRIVER_Rcv_Errs\",\n\t\"DRIVER_HW_Errs\",\n\t\"DRIVER_NoPIOBufs\",\n\t\"DRIVER_CtxtsOpen\",\n\t\"DRIVER_RcvLen_Errs\",\n\t\"DRIVER_EgrBufFull\",\n\t\"DRIVER_EgrHdrFull\"\n};\n\nstatic struct rdma_stat_desc *dev_cntr_descs;\nstatic struct rdma_stat_desc *port_cntr_descs;\nint num_driver_cntrs = ARRAY_SIZE(driver_cntr_names);\nstatic int num_dev_cntrs;\nstatic int num_port_cntrs;\n\n \nstatic int init_cntr_names(const char *names_in, const size_t names_len,\n\t\t\t   int num_extra_names, int *num_cntrs,\n\t\t\t   struct rdma_stat_desc **cntr_descs)\n{\n\tstruct rdma_stat_desc *names_out;\n\tchar *p;\n\tint i, n;\n\n\tn = 0;\n\tfor (i = 0; i < names_len; i++)\n\t\tif (names_in[i] == '\\n')\n\t\t\tn++;\n\n\tnames_out = kzalloc((n + num_extra_names) * sizeof(*names_out)\n\t\t\t\t+ names_len,\n\t\t\t    GFP_KERNEL);\n\tif (!names_out) {\n\t\t*num_cntrs = 0;\n\t\t*cntr_descs = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tp = (char *)&names_out[n + num_extra_names];\n\tmemcpy(p, names_in, names_len);\n\n\tfor (i = 0; i < n; i++) {\n\t\tnames_out[i].name = p;\n\t\tp = strchr(p, '\\n');\n\t\t*p++ = '\\0';\n\t}\n\n\t*num_cntrs = n;\n\t*cntr_descs = names_out;\n\treturn 0;\n}\n\nstatic struct rdma_hw_stats *hfi1_alloc_hw_device_stats(struct ib_device *ibdev)\n{\n\tif (!dev_cntr_descs) {\n\t\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\t\tint i, err;\n\n\t\terr = init_cntr_names(dd->cntrnames, dd->cntrnameslen,\n\t\t\t\t      num_driver_cntrs,\n\t\t\t\t      &num_dev_cntrs, &dev_cntr_descs);\n\t\tif (err)\n\t\t\treturn NULL;\n\n\t\tfor (i = 0; i < num_driver_cntrs; i++)\n\t\t\tdev_cntr_descs[num_dev_cntrs + i].name =\n\t\t\t\t\t\t\tdriver_cntr_names[i];\n\t}\n\treturn rdma_alloc_hw_stats_struct(dev_cntr_descs,\n\t\t\t\t\t  num_dev_cntrs + num_driver_cntrs,\n\t\t\t\t\t  RDMA_HW_STATS_DEFAULT_LIFESPAN);\n}\n\nstatic struct rdma_hw_stats *hfi_alloc_hw_port_stats(struct ib_device *ibdev,\n\t\t\t\t\t\t     u32 port_num)\n{\n\tif (!port_cntr_descs) {\n\t\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\t\tint err;\n\n\t\terr = init_cntr_names(dd->portcntrnames, dd->portcntrnameslen,\n\t\t\t\t      0,\n\t\t\t\t      &num_port_cntrs, &port_cntr_descs);\n\t\tif (err)\n\t\t\treturn NULL;\n\t}\n\treturn rdma_alloc_hw_stats_struct(port_cntr_descs, num_port_cntrs,\n\t\t\t\t\t  RDMA_HW_STATS_DEFAULT_LIFESPAN);\n}\n\nstatic u64 hfi1_sps_ints(void)\n{\n\tunsigned long index, flags;\n\tstruct hfi1_devdata *dd;\n\tu64 sps_ints = 0;\n\n\txa_lock_irqsave(&hfi1_dev_table, flags);\n\txa_for_each(&hfi1_dev_table, index, dd) {\n\t\tsps_ints += get_all_cpu_total(dd->int_counter);\n\t}\n\txa_unlock_irqrestore(&hfi1_dev_table, flags);\n\treturn sps_ints;\n}\n\nstatic int get_hw_stats(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t\tu32 port, int index)\n{\n\tu64 *values;\n\tint count;\n\n\tif (!port) {\n\t\tu64 *stats = (u64 *)&hfi1_stats;\n\t\tint i;\n\n\t\thfi1_read_cntrs(dd_from_ibdev(ibdev), NULL, &values);\n\t\tvalues[num_dev_cntrs] = hfi1_sps_ints();\n\t\tfor (i = 1; i < num_driver_cntrs; i++)\n\t\t\tvalues[num_dev_cntrs + i] = stats[i];\n\t\tcount = num_dev_cntrs + num_driver_cntrs;\n\t} else {\n\t\tstruct hfi1_ibport *ibp = to_iport(ibdev, port);\n\n\t\thfi1_read_portcntrs(ppd_from_ibp(ibp), NULL, &values);\n\t\tcount = num_port_cntrs;\n\t}\n\n\tmemcpy(stats->value, values, count * sizeof(u64));\n\treturn count;\n}\n\nstatic const struct ib_device_ops hfi1_dev_ops = {\n\t.owner = THIS_MODULE,\n\t.driver_id = RDMA_DRIVER_HFI1,\n\n\t.alloc_hw_device_stats = hfi1_alloc_hw_device_stats,\n\t.alloc_hw_port_stats = hfi_alloc_hw_port_stats,\n\t.alloc_rdma_netdev = hfi1_vnic_alloc_rn,\n\t.device_group = &ib_hfi1_attr_group,\n\t.get_dev_fw_str = hfi1_get_dev_fw_str,\n\t.get_hw_stats = get_hw_stats,\n\t.modify_device = modify_device,\n\t.port_groups = hfi1_attr_port_groups,\n\t \n\t.process_mad = hfi1_process_mad,\n\t.rdma_netdev_get_params = hfi1_ipoib_rn_get_params,\n};\n\n \nint hfi1_register_ib_device(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_ibdev *dev = &dd->verbs_dev;\n\tstruct ib_device *ibdev = &dev->rdi.ibdev;\n\tstruct hfi1_pportdata *ppd = dd->pport;\n\tstruct hfi1_ibport *ibp = &ppd->ibport_data;\n\tunsigned i;\n\tint ret;\n\n\tfor (i = 0; i < dd->num_pports; i++)\n\t\tinit_ibport(ppd + i);\n\n\t \n\n\ttimer_setup(&dev->mem_timer, mem_timer, 0);\n\n\tseqlock_init(&dev->iowait_lock);\n\tseqlock_init(&dev->txwait_lock);\n\tINIT_LIST_HEAD(&dev->txwait);\n\tINIT_LIST_HEAD(&dev->memwait);\n\n\tret = verbs_txreq_init(dev);\n\tif (ret)\n\t\tgoto err_verbs_txreq;\n\n\t \n\tibdev->node_guid = get_sguid(ibp, HFI1_PORT_GUID_INDEX);\n\n\t \n\tif (!ib_hfi1_sys_image_guid)\n\t\tib_hfi1_sys_image_guid = ibdev->node_guid;\n\tibdev->phys_port_cnt = dd->num_pports;\n\tibdev->dev.parent = &dd->pcidev->dev;\n\n\tib_set_device_ops(ibdev, &hfi1_dev_ops);\n\n\tstrscpy(ibdev->node_desc, init_utsname()->nodename,\n\t\tsizeof(ibdev->node_desc));\n\n\t \n\tdd->verbs_dev.rdi.driver_f.get_pci_dev = get_pci_dev;\n\tdd->verbs_dev.rdi.driver_f.check_ah = hfi1_check_ah;\n\tdd->verbs_dev.rdi.driver_f.notify_new_ah = hfi1_notify_new_ah;\n\tdd->verbs_dev.rdi.driver_f.get_guid_be = hfi1_get_guid_be;\n\tdd->verbs_dev.rdi.driver_f.query_port_state = query_port;\n\tdd->verbs_dev.rdi.driver_f.shut_down_port = shut_down_port;\n\tdd->verbs_dev.rdi.driver_f.cap_mask_chg = hfi1_cap_mask_chg;\n\t \n\thfi1_fill_device_attr(dd);\n\n\t \n\tdd->verbs_dev.rdi.dparms.qp_table_size = hfi1_qp_table_size;\n\tdd->verbs_dev.rdi.dparms.qpn_start = 0;\n\tdd->verbs_dev.rdi.dparms.qpn_inc = 1;\n\tdd->verbs_dev.rdi.dparms.qos_shift = dd->qos_shift;\n\tdd->verbs_dev.rdi.dparms.qpn_res_start = RVT_KDETH_QP_BASE;\n\tdd->verbs_dev.rdi.dparms.qpn_res_end = RVT_AIP_QP_MAX;\n\tdd->verbs_dev.rdi.dparms.max_rdma_atomic = HFI1_MAX_RDMA_ATOMIC;\n\tdd->verbs_dev.rdi.dparms.psn_mask = PSN_MASK;\n\tdd->verbs_dev.rdi.dparms.psn_shift = PSN_SHIFT;\n\tdd->verbs_dev.rdi.dparms.psn_modify_mask = PSN_MODIFY_MASK;\n\tdd->verbs_dev.rdi.dparms.core_cap_flags = RDMA_CORE_PORT_INTEL_OPA |\n\t\t\t\t\t\tRDMA_CORE_CAP_OPA_AH;\n\tdd->verbs_dev.rdi.dparms.max_mad_size = OPA_MGMT_MAD_SIZE;\n\n\tdd->verbs_dev.rdi.driver_f.qp_priv_alloc = qp_priv_alloc;\n\tdd->verbs_dev.rdi.driver_f.qp_priv_init = hfi1_qp_priv_init;\n\tdd->verbs_dev.rdi.driver_f.qp_priv_free = qp_priv_free;\n\tdd->verbs_dev.rdi.driver_f.free_all_qps = free_all_qps;\n\tdd->verbs_dev.rdi.driver_f.notify_qp_reset = notify_qp_reset;\n\tdd->verbs_dev.rdi.driver_f.do_send = hfi1_do_send_from_rvt;\n\tdd->verbs_dev.rdi.driver_f.schedule_send = hfi1_schedule_send;\n\tdd->verbs_dev.rdi.driver_f.schedule_send_no_lock = _hfi1_schedule_send;\n\tdd->verbs_dev.rdi.driver_f.get_pmtu_from_attr = get_pmtu_from_attr;\n\tdd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;\n\tdd->verbs_dev.rdi.driver_f.flush_qp_waiters = flush_qp_waiters;\n\tdd->verbs_dev.rdi.driver_f.stop_send_queue = stop_send_queue;\n\tdd->verbs_dev.rdi.driver_f.quiesce_qp = quiesce_qp;\n\tdd->verbs_dev.rdi.driver_f.notify_error_qp = notify_error_qp;\n\tdd->verbs_dev.rdi.driver_f.mtu_from_qp = mtu_from_qp;\n\tdd->verbs_dev.rdi.driver_f.mtu_to_path_mtu = mtu_to_path_mtu;\n\tdd->verbs_dev.rdi.driver_f.check_modify_qp = hfi1_check_modify_qp;\n\tdd->verbs_dev.rdi.driver_f.modify_qp = hfi1_modify_qp;\n\tdd->verbs_dev.rdi.driver_f.notify_restart_rc = hfi1_restart_rc;\n\tdd->verbs_dev.rdi.driver_f.setup_wqe = hfi1_setup_wqe;\n\tdd->verbs_dev.rdi.driver_f.comp_vect_cpu_lookup =\n\t\t\t\t\t\thfi1_comp_vect_mappings_lookup;\n\n\t \n\tdd->verbs_dev.rdi.ibdev.num_comp_vectors = dd->comp_vect_possible_cpus;\n\tdd->verbs_dev.rdi.dparms.node = dd->node;\n\n\t \n\tdd->verbs_dev.rdi.flags = 0;  \n\tdd->verbs_dev.rdi.dparms.lkey_table_size = hfi1_lkey_table_size;\n\tdd->verbs_dev.rdi.dparms.nports = dd->num_pports;\n\tdd->verbs_dev.rdi.dparms.npkeys = hfi1_get_npkeys(dd);\n\tdd->verbs_dev.rdi.dparms.sge_copy_mode = sge_copy_mode;\n\tdd->verbs_dev.rdi.dparms.wss_threshold = wss_threshold;\n\tdd->verbs_dev.rdi.dparms.wss_clean_period = wss_clean_period;\n\tdd->verbs_dev.rdi.dparms.reserved_operations = 1;\n\tdd->verbs_dev.rdi.dparms.extra_rdma_atomic = HFI1_TID_RDMA_WRITE_CNT;\n\n\t \n\tdd->verbs_dev.rdi.post_parms = hfi1_post_parms;\n\n\t \n\tdd->verbs_dev.rdi.wc_opcode = ib_hfi1_wc_opcode;\n\n\tppd = dd->pport;\n\tfor (i = 0; i < dd->num_pports; i++, ppd++)\n\t\trvt_init_port(&dd->verbs_dev.rdi,\n\t\t\t      &ppd->ibport_data.rvp,\n\t\t\t      i,\n\t\t\t      ppd->pkeys);\n\n\tret = rvt_register_device(&dd->verbs_dev.rdi);\n\tif (ret)\n\t\tgoto err_verbs_txreq;\n\n\tret = hfi1_verbs_register_sysfs(dd);\n\tif (ret)\n\t\tgoto err_class;\n\n\treturn ret;\n\nerr_class:\n\trvt_unregister_device(&dd->verbs_dev.rdi);\nerr_verbs_txreq:\n\tverbs_txreq_exit(dev);\n\tdd_dev_err(dd, \"cannot register verbs: %d!\\n\", -ret);\n\treturn ret;\n}\n\nvoid hfi1_unregister_ib_device(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_ibdev *dev = &dd->verbs_dev;\n\n\thfi1_verbs_unregister_sysfs(dd);\n\n\trvt_unregister_device(&dd->verbs_dev.rdi);\n\n\tif (!list_empty(&dev->txwait))\n\t\tdd_dev_err(dd, \"txwait list not empty!\\n\");\n\tif (!list_empty(&dev->memwait))\n\t\tdd_dev_err(dd, \"memwait list not empty!\\n\");\n\n\tdel_timer_sync(&dev->mem_timer);\n\tverbs_txreq_exit(dev);\n\n\tkfree(dev_cntr_descs);\n\tkfree(port_cntr_descs);\n\tdev_cntr_descs = NULL;\n\tport_cntr_descs = NULL;\n}\n\nvoid hfi1_cnp_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ibport *ibp = rcd_to_iport(packet->rcd);\n\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct ib_header *hdr = packet->hdr;\n\tstruct rvt_qp *qp = packet->qp;\n\tu32 lqpn, rqpn = 0;\n\tu16 rlid = 0;\n\tu8 sl, sc5, svc_type;\n\n\tswitch (packet->qp->ibqp.qp_type) {\n\tcase IB_QPT_UC:\n\t\trlid = rdma_ah_get_dlid(&qp->remote_ah_attr);\n\t\trqpn = qp->remote_qpn;\n\t\tsvc_type = IB_CC_SVCTYPE_UC;\n\t\tbreak;\n\tcase IB_QPT_RC:\n\t\trlid = rdma_ah_get_dlid(&qp->remote_ah_attr);\n\t\trqpn = qp->remote_qpn;\n\t\tsvc_type = IB_CC_SVCTYPE_RC;\n\t\tbreak;\n\tcase IB_QPT_SMI:\n\tcase IB_QPT_GSI:\n\tcase IB_QPT_UD:\n\t\tsvc_type = IB_CC_SVCTYPE_UD;\n\t\tbreak;\n\tdefault:\n\t\tibp->rvp.n_pkt_drops++;\n\t\treturn;\n\t}\n\n\tsc5 = hfi1_9B_get_sc5(hdr, packet->rhf);\n\tsl = ibp->sc_to_sl[sc5];\n\tlqpn = qp->ibqp.qp_num;\n\n\tprocess_becn(ppd, sl, rlid, lqpn, rqpn, svc_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}