{
  "module_name": "device.c",
  "hash_id": "be6e6e4af26deb5bb1ee49083929827fb651052e233f6e7ebe9b11682df80bea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/device.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n\n#include \"hfi.h\"\n#include \"device.h\"\n\nstatic char *hfi1_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0600;\n\treturn kasprintf(GFP_KERNEL, \"%s\", dev_name(dev));\n}\n\nstatic const struct class class = {\n\t.name = \"hfi1\",\n\t.devnode = hfi1_devnode,\n};\n\nstatic char *hfi1_user_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0666;\n\treturn kasprintf(GFP_KERNEL, \"%s\", dev_name(dev));\n}\n\nstatic const struct class user_class = {\n\t.name = \"hfi1_user\",\n\t.devnode = hfi1_user_devnode,\n};\nstatic dev_t hfi1_dev;\n\nint hfi1_cdev_init(int minor, const char *name,\n\t\t   const struct file_operations *fops,\n\t\t   struct cdev *cdev, struct device **devp,\n\t\t   bool user_accessible,\n\t\t   struct kobject *parent)\n{\n\tconst dev_t dev = MKDEV(MAJOR(hfi1_dev), minor);\n\tstruct device *device = NULL;\n\tint ret;\n\n\tcdev_init(cdev, fops);\n\tcdev->owner = THIS_MODULE;\n\tcdev_set_parent(cdev, parent);\n\tkobject_set_name(&cdev->kobj, name);\n\n\tret = cdev_add(cdev, dev, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not add cdev for minor %d, %s (err %d)\\n\",\n\t\t       minor, name, -ret);\n\t\tgoto done;\n\t}\n\n\tif (user_accessible)\n\t\tdevice = device_create(&user_class, NULL, dev, NULL, \"%s\", name);\n\telse\n\t\tdevice = device_create(&class, NULL, dev, NULL, \"%s\", name);\n\n\tif (IS_ERR(device)) {\n\t\tret = PTR_ERR(device);\n\t\tdevice = NULL;\n\t\tpr_err(\"Could not create device for minor %d, %s (err %d)\\n\",\n\t\t\tminor, name, -ret);\n\t\tcdev_del(cdev);\n\t}\ndone:\n\t*devp = device;\n\treturn ret;\n}\n\nvoid hfi1_cdev_cleanup(struct cdev *cdev, struct device **devp)\n{\n\tstruct device *device = *devp;\n\n\tif (device) {\n\t\tdevice_unregister(device);\n\t\t*devp = NULL;\n\n\t\tcdev_del(cdev);\n\t}\n}\n\nstatic const char *hfi1_class_name = \"hfi1\";\n\nconst char *class_name(void)\n{\n\treturn hfi1_class_name;\n}\n\nint __init dev_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&hfi1_dev, 0, HFI1_NMINORS, DRIVER_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Could not allocate chrdev region (err %d)\\n\", -ret);\n\t\tgoto done;\n\t}\n\n\tret = class_register(&class);\n\tif (ret) {\n\t\tpr_err(\"Could not create device class (err %d)\\n\", -ret);\n\t\tunregister_chrdev_region(hfi1_dev, HFI1_NMINORS);\n\t\tgoto done;\n\t}\n\n\tret = class_register(&user_class);\n\tif (ret) {\n\t\tpr_err(\"Could not create device class for user accessible files (err %d)\\n\",\n\t\t       -ret);\n\t\tclass_unregister(&class);\n\t\tunregister_chrdev_region(hfi1_dev, HFI1_NMINORS);\n\t\tgoto done;\n\t}\n\ndone:\n\treturn ret;\n}\n\nvoid dev_cleanup(void)\n{\n\tclass_unregister(&class);\n\tclass_unregister(&user_class);\n\n\tunregister_chrdev_region(hfi1_dev, HFI1_NMINORS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}