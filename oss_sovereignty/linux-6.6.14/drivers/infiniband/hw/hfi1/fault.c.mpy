{
  "module_name": "fault.c",
  "hash_id": "242d9603706856f35f611360a7c00bc1e12a52bc9bcd6648624f5a8858924877",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/fault.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/bitmap.h>\n\n#include \"debugfs.h\"\n#include \"fault.h\"\n#include \"trace.h\"\n\n#define HFI1_FAULT_DIR_TX   BIT(0)\n#define HFI1_FAULT_DIR_RX   BIT(1)\n#define HFI1_FAULT_DIR_TXRX (HFI1_FAULT_DIR_TX | HFI1_FAULT_DIR_RX)\n\nstatic void *_fault_stats_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_opcode_stats_perctx *opstats;\n\n\tif (*pos >= ARRAY_SIZE(opstats->stats))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_fault_stats_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_opcode_stats_perctx *opstats;\n\n\t++*pos;\n\tif (*pos >= ARRAY_SIZE(opstats->stats))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _fault_stats_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _fault_stats_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos = v;\n\tloff_t i = *spos, j;\n\tu64 n_packets = 0, n_bytes = 0;\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_ctxtdata *rcd;\n\n\tfor (j = 0; j < dd->first_dyn_alloc_ctxt; j++) {\n\t\trcd = hfi1_rcd_get_by_index(dd, j);\n\t\tif (rcd) {\n\t\t\tn_packets += rcd->opstats->stats[i].n_packets;\n\t\t\tn_bytes += rcd->opstats->stats[i].n_bytes;\n\t\t}\n\t\thfi1_rcd_put(rcd);\n\t}\n\tfor_each_possible_cpu(j) {\n\t\tstruct hfi1_opcode_stats_perctx *sp =\n\t\t\tper_cpu_ptr(dd->tx_opstats, j);\n\n\t\tn_packets += sp->stats[i].n_packets;\n\t\tn_bytes += sp->stats[i].n_bytes;\n\t}\n\tif (!n_packets && !n_bytes)\n\t\treturn SEQ_SKIP;\n\tif (!ibd->fault->n_rxfaults[i] && !ibd->fault->n_txfaults[i])\n\t\treturn SEQ_SKIP;\n\tseq_printf(s, \"%02llx %llu/%llu (faults rx:%llu faults: tx:%llu)\\n\", i,\n\t\t   (unsigned long long)n_packets,\n\t\t   (unsigned long long)n_bytes,\n\t\t   (unsigned long long)ibd->fault->n_rxfaults[i],\n\t\t   (unsigned long long)ibd->fault->n_txfaults[i]);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(fault_stats);\nDEBUGFS_SEQ_FILE_OPEN(fault_stats);\nDEBUGFS_FILE_OPS(fault_stats);\n\nstatic int fault_opcodes_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = inode->i_private;\n\treturn nonseekable_open(inode, file);\n}\n\nstatic ssize_t fault_opcodes_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t len, loff_t *pos)\n{\n\tssize_t ret = 0;\n\t \n\tsize_t copy, datalen = 1280;\n\tchar *data, *token, *ptr, *end;\n\tstruct fault *fault = file->private_data;\n\n\tdata = kcalloc(datalen, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tcopy = min(len, datalen - 1);\n\tif (copy_from_user(data, buf, copy)) {\n\t\tret = -EFAULT;\n\t\tgoto free_data;\n\t}\n\n\tret = debugfs_file_get(file->f_path.dentry);\n\tif (unlikely(ret))\n\t\tgoto free_data;\n\tptr = data;\n\ttoken = ptr;\n\tfor (ptr = data; *ptr; ptr = end + 1, token = ptr) {\n\t\tchar *dash;\n\t\tunsigned long range_start, range_end, i;\n\t\tbool remove = false;\n\t\tunsigned long bound = 1U << BITS_PER_BYTE;\n\n\t\tend = strchr(ptr, ',');\n\t\tif (end)\n\t\t\t*end = '\\0';\n\t\tif (token[0] == '-') {\n\t\t\tremove = true;\n\t\t\ttoken++;\n\t\t}\n\t\tdash = strchr(token, '-');\n\t\tif (dash)\n\t\t\t*dash = '\\0';\n\t\tif (kstrtoul(token, 0, &range_start))\n\t\t\tbreak;\n\t\tif (dash) {\n\t\t\ttoken = dash + 1;\n\t\t\tif (kstrtoul(token, 0, &range_end))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\trange_end = range_start;\n\t\t}\n\t\tif (range_start == range_end && range_start == -1UL) {\n\t\t\tbitmap_zero(fault->opcodes, sizeof(fault->opcodes) *\n\t\t\t\t    BITS_PER_BYTE);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (range_start >= bound || range_end >= bound)\n\t\t\tbreak;\n\n\t\tfor (i = range_start; i <= range_end; i++) {\n\t\t\tif (remove)\n\t\t\t\tclear_bit(i, fault->opcodes);\n\t\t\telse\n\t\t\t\tset_bit(i, fault->opcodes);\n\t\t}\n\t\tif (!end)\n\t\t\tbreak;\n\t}\n\tret = len;\n\n\tdebugfs_file_put(file->f_path.dentry);\nfree_data:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic ssize_t fault_opcodes_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t len, loff_t *pos)\n{\n\tssize_t ret = 0;\n\tchar *data;\n\tsize_t datalen = 1280, size = 0;  \n\tunsigned long bit = 0, zero = 0;\n\tstruct fault *fault = file->private_data;\n\tsize_t bitsize = sizeof(fault->opcodes) * BITS_PER_BYTE;\n\n\tdata = kcalloc(datalen, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tret = debugfs_file_get(file->f_path.dentry);\n\tif (unlikely(ret))\n\t\tgoto free_data;\n\tbit = find_first_bit(fault->opcodes, bitsize);\n\twhile (bit < bitsize) {\n\t\tzero = find_next_zero_bit(fault->opcodes, bitsize, bit);\n\t\tif (zero - 1 != bit)\n\t\t\tsize += scnprintf(data + size,\n\t\t\t\t\t datalen - size - 1,\n\t\t\t\t\t \"0x%lx-0x%lx,\", bit, zero - 1);\n\t\telse\n\t\t\tsize += scnprintf(data + size,\n\t\t\t\t\t datalen - size - 1, \"0x%lx,\",\n\t\t\t\t\t bit);\n\t\tbit = find_next_bit(fault->opcodes, bitsize, zero);\n\t}\n\tdebugfs_file_put(file->f_path.dentry);\n\tdata[size - 1] = '\\n';\n\tdata[size] = '\\0';\n\tret = simple_read_from_buffer(buf, len, pos, data, size);\nfree_data:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic const struct file_operations __fault_opcodes_fops = {\n\t.owner = THIS_MODULE,\n\t.open = fault_opcodes_open,\n\t.read = fault_opcodes_read,\n\t.write = fault_opcodes_write,\n\t.llseek = no_llseek\n};\n\nvoid hfi1_fault_exit_debugfs(struct hfi1_ibdev *ibd)\n{\n\tif (ibd->fault)\n\t\tdebugfs_remove_recursive(ibd->fault->dir);\n\tkfree(ibd->fault);\n\tibd->fault = NULL;\n}\n\nint hfi1_fault_init_debugfs(struct hfi1_ibdev *ibd)\n{\n\tstruct dentry *parent = ibd->hfi1_ibdev_dbg;\n\tstruct dentry *fault_dir;\n\n\tibd->fault = kzalloc(sizeof(*ibd->fault), GFP_KERNEL);\n\tif (!ibd->fault)\n\t\treturn -ENOMEM;\n\n\tibd->fault->attr.interval = 1;\n\tibd->fault->attr.require_end = ULONG_MAX;\n\tibd->fault->attr.stacktrace_depth = 32;\n\tibd->fault->attr.dname = NULL;\n\tibd->fault->attr.verbose = 0;\n\tibd->fault->enable = false;\n\tibd->fault->opcode = false;\n\tibd->fault->fault_skip = 0;\n\tibd->fault->skip = 0;\n\tibd->fault->direction = HFI1_FAULT_DIR_TXRX;\n\tibd->fault->suppress_err = false;\n\tbitmap_zero(ibd->fault->opcodes,\n\t\t    sizeof(ibd->fault->opcodes) * BITS_PER_BYTE);\n\n\tfault_dir =\n\t\tfault_create_debugfs_attr(\"fault\", parent, &ibd->fault->attr);\n\tif (IS_ERR(fault_dir)) {\n\t\tkfree(ibd->fault);\n\t\tibd->fault = NULL;\n\t\treturn -ENOENT;\n\t}\n\tibd->fault->dir = fault_dir;\n\n\tdebugfs_create_file(\"fault_stats\", 0444, fault_dir, ibd,\n\t\t\t    &_fault_stats_file_ops);\n\tdebugfs_create_bool(\"enable\", 0600, fault_dir, &ibd->fault->enable);\n\tdebugfs_create_bool(\"suppress_err\", 0600, fault_dir,\n\t\t\t    &ibd->fault->suppress_err);\n\tdebugfs_create_bool(\"opcode_mode\", 0600, fault_dir,\n\t\t\t    &ibd->fault->opcode);\n\tdebugfs_create_file(\"opcodes\", 0600, fault_dir, ibd->fault,\n\t\t\t    &__fault_opcodes_fops);\n\tdebugfs_create_u64(\"skip_pkts\", 0600, fault_dir,\n\t\t\t   &ibd->fault->fault_skip);\n\tdebugfs_create_u64(\"skip_usec\", 0600, fault_dir,\n\t\t\t   &ibd->fault->fault_skip_usec);\n\tdebugfs_create_u8(\"direction\", 0600, fault_dir, &ibd->fault->direction);\n\n\treturn 0;\n}\n\nbool hfi1_dbg_fault_suppress_err(struct hfi1_ibdev *ibd)\n{\n\tif (ibd->fault)\n\t\treturn ibd->fault->suppress_err;\n\treturn false;\n}\n\nstatic bool __hfi1_should_fault(struct hfi1_ibdev *ibd, u32 opcode,\n\t\t\t\tu8 direction)\n{\n\tbool ret = false;\n\n\tif (!ibd->fault || !ibd->fault->enable)\n\t\treturn false;\n\tif (!(ibd->fault->direction & direction))\n\t\treturn false;\n\tif (ibd->fault->opcode) {\n\t\tif (bitmap_empty(ibd->fault->opcodes,\n\t\t\t\t (sizeof(ibd->fault->opcodes) *\n\t\t\t\t  BITS_PER_BYTE)))\n\t\t\treturn false;\n\t\tif (!(test_bit(opcode, ibd->fault->opcodes)))\n\t\t\treturn false;\n\t}\n\tif (ibd->fault->fault_skip_usec &&\n\t    time_before(jiffies, ibd->fault->skip_usec))\n\t\treturn false;\n\tif (ibd->fault->fault_skip && ibd->fault->skip) {\n\t\tibd->fault->skip--;\n\t\treturn false;\n\t}\n\tret = should_fail(&ibd->fault->attr, 1);\n\tif (ret) {\n\t\tibd->fault->skip = ibd->fault->fault_skip;\n\t\tibd->fault->skip_usec = jiffies +\n\t\t\tusecs_to_jiffies(ibd->fault->fault_skip_usec);\n\t}\n\treturn ret;\n}\n\nbool hfi1_dbg_should_fault_tx(struct rvt_qp *qp, u32 opcode)\n{\n\tstruct hfi1_ibdev *ibd = to_idev(qp->ibqp.device);\n\n\tif (__hfi1_should_fault(ibd, opcode, HFI1_FAULT_DIR_TX)) {\n\t\ttrace_hfi1_fault_opcode(qp, opcode);\n\t\tibd->fault->n_txfaults[opcode]++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nbool hfi1_dbg_should_fault_rx(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ibdev *ibd = &packet->rcd->dd->verbs_dev;\n\n\tif (__hfi1_should_fault(ibd, packet->opcode, HFI1_FAULT_DIR_RX)) {\n\t\ttrace_hfi1_fault_packet(packet);\n\t\tibd->fault->n_rxfaults[packet->opcode]++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}