{
  "module_name": "rc.c",
  "hash_id": "cd05b1203ca3cb245f2b57d365358346823f287a7c2d85d692adc28ab952722b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/rc.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <rdma/rdma_vt.h>\n#include <rdma/rdmavt_qp.h>\n\n#include \"hfi.h\"\n#include \"qp.h\"\n#include \"rc.h\"\n#include \"verbs_txreq.h\"\n#include \"trace.h\"\n\nstruct rvt_ack_entry *find_prev_entry(struct rvt_qp *qp, u32 psn, u8 *prev,\n\t\t\t\t      u8 *prev_ack, bool *scheduled)\n\t__must_hold(&qp->s_lock)\n{\n\tstruct rvt_ack_entry *e = NULL;\n\tu8 i, p;\n\tbool s = true;\n\n\tfor (i = qp->r_head_ack_queue; ; i = p) {\n\t\tif (i == qp->s_tail_ack_queue)\n\t\t\ts = false;\n\t\tif (i)\n\t\t\tp = i - 1;\n\t\telse\n\t\t\tp = rvt_size_atomic(ib_to_rvt(qp->ibqp.device));\n\t\tif (p == qp->r_head_ack_queue) {\n\t\t\te = NULL;\n\t\t\tbreak;\n\t\t}\n\t\te = &qp->s_ack_queue[p];\n\t\tif (!e->opcode) {\n\t\t\te = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (cmp_psn(psn, e->psn) >= 0) {\n\t\t\tif (p == qp->s_tail_ack_queue &&\n\t\t\t    cmp_psn(psn, e->lpsn) <= 0)\n\t\t\t\ts = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (prev)\n\t\t*prev = p;\n\tif (prev_ack)\n\t\t*prev_ack = i;\n\tif (scheduled)\n\t\t*scheduled = s;\n\treturn e;\n}\n\n \nstatic int make_rc_ack(struct hfi1_ibdev *dev, struct rvt_qp *qp,\n\t\t       struct ib_other_headers *ohdr,\n\t\t       struct hfi1_pkt_state *ps)\n{\n\tstruct rvt_ack_entry *e;\n\tu32 hwords, hdrlen;\n\tu32 len = 0;\n\tu32 bth0 = 0, bth2 = 0;\n\tu32 bth1 = qp->remote_qpn | (HFI1_CAP_IS_KSET(OPFN) << IB_BTHE_E_SHIFT);\n\tint middle = 0;\n\tu32 pmtu = qp->pmtu;\n\tstruct hfi1_qp_priv *qpriv = qp->priv;\n\tbool last_pkt;\n\tu32 delta;\n\tu8 next = qp->s_tail_ack_queue;\n\tstruct tid_rdma_request *req;\n\n\ttrace_hfi1_rsp_make_rc_ack(qp, 0);\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto bail;\n\n\tif (qpriv->hdr_type == HFI1_PKT_TYPE_9B)\n\t\t \n\t\thwords = 5;\n\telse\n\t\t \n\t\thwords = 7;\n\n\tswitch (qp->s_ack_state) {\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\tcase OP(RDMA_READ_RESPONSE_ONLY):\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\trelease_rdma_sge_mr(e);\n\t\tfallthrough;\n\tcase OP(ATOMIC_ACKNOWLEDGE):\n\t\t \n\t\tif (++next > rvt_size_atomic(&dev->rdi))\n\t\t\tnext = 0;\n\t\t \n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\tif (e->opcode != TID_OP(WRITE_REQ) &&\n\t\t    qp->s_acked_ack_queue == qp->s_tail_ack_queue)\n\t\t\tqp->s_acked_ack_queue = next;\n\t\tqp->s_tail_ack_queue = next;\n\t\ttrace_hfi1_rsp_make_rc_ack(qp, e->psn);\n\t\tfallthrough;\n\tcase OP(SEND_ONLY):\n\tcase OP(ACKNOWLEDGE):\n\t\t \n\t\tif (qp->r_head_ack_queue == qp->s_tail_ack_queue) {\n\t\t\tif (qp->s_flags & RVT_S_ACK_PENDING)\n\t\t\t\tgoto normal;\n\t\t\tgoto bail;\n\t\t}\n\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\t \n\t\tif ((qpriv->s_flags & HFI1_R_TID_WAIT_INTERLCK) ||\n\t\t    hfi1_tid_rdma_ack_interlock(qp, e)) {\n\t\t\tiowait_set_flag(&qpriv->s_iowait, IOWAIT_PENDING_IB);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (e->opcode == OP(RDMA_READ_REQUEST)) {\n\t\t\t \n\t\t\tlen = e->rdma_sge.sge_length;\n\t\t\tif (len && !e->rdma_sge.mr) {\n\t\t\t\tif (qp->s_acked_ack_queue ==\n\t\t\t\t    qp->s_tail_ack_queue)\n\t\t\t\t\tqp->s_acked_ack_queue =\n\t\t\t\t\t\tqp->r_head_ack_queue;\n\t\t\t\tqp->s_tail_ack_queue = qp->r_head_ack_queue;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tps->s_txreq->mr = e->rdma_sge.mr;\n\t\t\tif (ps->s_txreq->mr)\n\t\t\t\trvt_get_mr(ps->s_txreq->mr);\n\t\t\tqp->s_ack_rdma_sge.sge = e->rdma_sge;\n\t\t\tqp->s_ack_rdma_sge.num_sge = 1;\n\t\t\tps->s_txreq->ss = &qp->s_ack_rdma_sge;\n\t\t\tif (len > pmtu) {\n\t\t\t\tlen = pmtu;\n\t\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_FIRST);\n\t\t\t} else {\n\t\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_ONLY);\n\t\t\t\te->sent = 1;\n\t\t\t}\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\t\thwords++;\n\t\t\tqp->s_ack_rdma_psn = e->psn;\n\t\t\tbth2 = mask_psn(qp->s_ack_rdma_psn++);\n\t\t} else if (e->opcode == TID_OP(WRITE_REQ)) {\n\t\t\t \n\t\t\treq = ack_to_tid_req(e);\n\t\t\tif (req->state == TID_REQUEST_RESEND ||\n\t\t\t    req->state == TID_REQUEST_INIT_RESEND)\n\t\t\t\tgoto bail;\n\t\t\tqp->s_ack_state = TID_OP(WRITE_RESP);\n\t\t\tqp->s_ack_rdma_psn = mask_psn(e->psn + req->cur_seg);\n\t\t\tgoto write_resp;\n\t\t} else if (e->opcode == TID_OP(READ_REQ)) {\n\t\t\t \n\t\t\tlen = e->rdma_sge.sge_length;\n\t\t\tif (len && !e->rdma_sge.mr) {\n\t\t\t\tif (qp->s_acked_ack_queue ==\n\t\t\t\t    qp->s_tail_ack_queue)\n\t\t\t\t\tqp->s_acked_ack_queue =\n\t\t\t\t\t\tqp->r_head_ack_queue;\n\t\t\t\tqp->s_tail_ack_queue = qp->r_head_ack_queue;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tps->s_txreq->mr = e->rdma_sge.mr;\n\t\t\tif (ps->s_txreq->mr)\n\t\t\t\trvt_get_mr(ps->s_txreq->mr);\n\t\t\tqp->s_ack_rdma_sge.sge = e->rdma_sge;\n\t\t\tqp->s_ack_rdma_sge.num_sge = 1;\n\t\t\tqp->s_ack_state = TID_OP(READ_RESP);\n\t\t\tgoto read_resp;\n\t\t} else {\n\t\t\t \n\t\t\tps->s_txreq->ss = NULL;\n\t\t\tlen = 0;\n\t\t\tqp->s_ack_state = OP(ATOMIC_ACKNOWLEDGE);\n\t\t\tohdr->u.at.aeth = rvt_compute_aeth(qp);\n\t\t\tib_u64_put(e->atomic_data, &ohdr->u.at.atomic_ack_eth);\n\t\t\thwords += sizeof(ohdr->u.at) / sizeof(u32);\n\t\t\tbth2 = mask_psn(e->psn);\n\t\t\te->sent = 1;\n\t\t}\n\t\ttrace_hfi1_tid_write_rsp_make_rc_ack(qp);\n\t\tbth0 = qp->s_ack_state << 24;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_MIDDLE);\n\t\tfallthrough;\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\tps->s_txreq->ss = &qp->s_ack_rdma_sge;\n\t\tps->s_txreq->mr = qp->s_ack_rdma_sge.sge.mr;\n\t\tif (ps->s_txreq->mr)\n\t\t\trvt_get_mr(ps->s_txreq->mr);\n\t\tlen = qp->s_ack_rdma_sge.sge.sge_length;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\n\t\t} else {\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\t\thwords++;\n\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_LAST);\n\t\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\t\te->sent = 1;\n\t\t}\n\t\tbth0 = qp->s_ack_state << 24;\n\t\tbth2 = mask_psn(qp->s_ack_rdma_psn++);\n\t\tbreak;\n\n\tcase TID_OP(WRITE_RESP):\nwrite_resp:\n\t\t \n\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\treq = ack_to_tid_req(e);\n\n\t\t \n\t\tif (qpriv->rnr_nak_state == TID_RNR_NAK_SEND &&\n\t\t    qp->s_tail_ack_queue == qpriv->r_tid_alloc &&\n\t\t    req->cur_seg == req->alloc_seg) {\n\t\t\tqpriv->rnr_nak_state = TID_RNR_NAK_SENT;\n\t\t\tgoto normal_no_state;\n\t\t}\n\n\t\tbth2 = mask_psn(qp->s_ack_rdma_psn);\n\t\thdrlen = hfi1_build_tid_rdma_write_resp(qp, e, ohdr, &bth1,\n\t\t\t\t\t\t\tbth2, &len,\n\t\t\t\t\t\t\t&ps->s_txreq->ss);\n\t\tif (!hdrlen)\n\t\t\treturn 0;\n\n\t\thwords += hdrlen;\n\t\tbth0 = qp->s_ack_state << 24;\n\t\tqp->s_ack_rdma_psn++;\n\t\ttrace_hfi1_tid_req_make_rc_ack_write(qp, 0, e->opcode, e->psn,\n\t\t\t\t\t\t     e->lpsn, req);\n\t\tif (req->cur_seg != req->total_segs)\n\t\t\tbreak;\n\n\t\te->sent = 1;\n\t\t \n\t\tqp->s_ack_state = OP(ATOMIC_ACKNOWLEDGE);\n\t\tbreak;\n\n\tcase TID_OP(READ_RESP):\nread_resp:\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\tps->s_txreq->ss = &qp->s_ack_rdma_sge;\n\t\tdelta = hfi1_build_tid_rdma_read_resp(qp, e, ohdr, &bth0,\n\t\t\t\t\t\t      &bth1, &bth2, &len,\n\t\t\t\t\t\t      &last_pkt);\n\t\tif (delta == 0)\n\t\t\tgoto error_qp;\n\t\thwords += delta;\n\t\tif (last_pkt) {\n\t\t\te->sent = 1;\n\t\t\t \n\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_LAST);\n\t\t}\n\t\tbreak;\n\tcase TID_OP(READ_REQ):\n\t\tgoto bail;\n\n\tdefault:\nnormal:\n\t\t \n\t\tqp->s_ack_state = OP(SEND_ONLY);\nnormal_no_state:\n\t\tif (qp->s_nak_state)\n\t\t\tohdr->u.aeth =\n\t\t\t\tcpu_to_be32((qp->r_msn & IB_MSN_MASK) |\n\t\t\t\t\t    (qp->s_nak_state <<\n\t\t\t\t\t     IB_AETH_CREDIT_SHIFT));\n\t\telse\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\thwords++;\n\t\tlen = 0;\n\t\tbth0 = OP(ACKNOWLEDGE) << 24;\n\t\tbth2 = mask_psn(qp->s_ack_psn);\n\t\tqp->s_flags &= ~RVT_S_ACK_PENDING;\n\t\tps->s_txreq->txreq.flags |= SDMA_TXREQ_F_VIP;\n\t\tps->s_txreq->ss = NULL;\n\t}\n\tqp->s_rdma_ack_cnt++;\n\tps->s_txreq->sde = qpriv->s_sde;\n\tps->s_txreq->s_cur_size = len;\n\tps->s_txreq->hdr_dwords = hwords;\n\thfi1_make_ruc_header(qp, ohdr, bth0, bth1, bth2, middle, ps);\n\treturn 1;\nerror_qp:\n\tspin_unlock_irqrestore(&qp->s_lock, ps->flags);\n\tspin_lock_irqsave(&qp->r_lock, ps->flags);\n\tspin_lock(&qp->s_lock);\n\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\tspin_unlock(&qp->s_lock);\n\tspin_unlock_irqrestore(&qp->r_lock, ps->flags);\n\tspin_lock_irqsave(&qp->s_lock, ps->flags);\nbail:\n\tqp->s_ack_state = OP(ACKNOWLEDGE);\n\t \n\tsmp_wmb();\n\tqp->s_flags &= ~(RVT_S_RESP_PENDING\n\t\t\t\t| RVT_S_ACK_PENDING\n\t\t\t\t| HFI1_S_AHG_VALID);\n\treturn 0;\n}\n\n \nint hfi1_make_rc_req(struct rvt_qp *qp, struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_ibdev *dev = to_idev(qp->ibqp.device);\n\tstruct ib_other_headers *ohdr;\n\tstruct rvt_sge_state *ss = NULL;\n\tstruct rvt_swqe *wqe;\n\tstruct hfi1_swqe_priv *wpriv;\n\tstruct tid_rdma_request *req = NULL;\n\t \n\tu32 hwords = 5;\n\tu32 len = 0;\n\tu32 bth0 = 0, bth2 = 0;\n\tu32 bth1 = qp->remote_qpn | (HFI1_CAP_IS_KSET(OPFN) << IB_BTHE_E_SHIFT);\n\tu32 pmtu = qp->pmtu;\n\tchar newreq;\n\tint middle = 0;\n\tint delta;\n\tstruct tid_rdma_flow *flow = NULL;\n\tstruct tid_rdma_params *remote;\n\n\ttrace_hfi1_sender_make_rc_req(qp);\n\tlockdep_assert_held(&qp->s_lock);\n\tps->s_txreq = get_txreq(ps->dev, qp);\n\tif (!ps->s_txreq)\n\t\tgoto bail_no_tx;\n\n\tif (priv->hdr_type == HFI1_PKT_TYPE_9B) {\n\t\t \n\t\thwords = 5;\n\t\tif (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.ibh.u.oth;\n\t} else {\n\t\t \n\t\thwords = 7;\n\t\tif ((rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&\n\t\t    (hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))))\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.l.oth;\n\t\telse\n\t\t\tohdr = &ps->s_txreq->phdr.hdr.opah.u.oth;\n\t}\n\n\t \n\tif ((qp->s_flags & RVT_S_RESP_PENDING) &&\n\t    make_rc_ack(dev, qp, ohdr, ps))\n\t\treturn 1;\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_SEND_OK)) {\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))\n\t\t\tgoto bail;\n\t\t \n\t\tif (qp->s_last == READ_ONCE(qp->s_head))\n\t\t\tgoto bail;\n\t\t \n\t\tif (iowait_sdma_pending(&priv->s_iowait)) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_DMA;\n\t\t\tgoto bail;\n\t\t}\n\t\tclear_ahg(qp);\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\thfi1_trdma_send_complete(qp, wqe, qp->s_last != qp->s_acked ?\n\t\t\t\t\t IB_WC_SUCCESS : IB_WC_WR_FLUSH_ERR);\n\t\t \n\t\tgoto done_free_tx;\n\t}\n\n\tif (qp->s_flags & (RVT_S_WAIT_RNR | RVT_S_WAIT_ACK | HFI1_S_WAIT_HALT))\n\t\tgoto bail;\n\n\tif (cmp_psn(qp->s_psn, qp->s_sending_hpsn) <= 0) {\n\t\tif (cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) <= 0) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_PSN;\n\t\t\tgoto bail;\n\t\t}\n\t\tqp->s_sending_psn = qp->s_psn;\n\t\tqp->s_sending_hpsn = qp->s_psn - 1;\n\t}\n\n\t \n\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\ncheck_s_state:\n\tswitch (qp->s_state) {\n\tdefault:\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_NEXT_SEND_OK))\n\t\t\tgoto bail;\n\t\t \n\t\tnewreq = 0;\n\t\tif (qp->s_cur == qp->s_tail) {\n\t\t\t \n\t\t\tif (qp->s_tail == READ_ONCE(qp->s_head)) {\n\t\t\t\tclear_ahg(qp);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tif ((wqe->wr.send_flags & IB_SEND_FENCE) &&\n\t\t\t    qp->s_num_rd_atomic &&\n\t\t\t    (wqe->wr.opcode != IB_WR_TID_RDMA_READ ||\n\t\t\t     priv->pending_tid_r_segs < qp->s_num_rd_atomic)) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_FENCE;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tif (wqe->wr.opcode == IB_WR_REG_MR ||\n\t\t\t    wqe->wr.opcode == IB_WR_LOCAL_INV) {\n\t\t\t\tint local_ops = 0;\n\t\t\t\tint err = 0;\n\n\t\t\t\tif (qp->s_last != qp->s_cur)\n\t\t\t\t\tgoto bail;\n\t\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\t\tqp->s_cur = 0;\n\t\t\t\tif (++qp->s_tail == qp->s_size)\n\t\t\t\t\tqp->s_tail = 0;\n\t\t\t\tif (!(wqe->wr.send_flags &\n\t\t\t\t      RVT_SEND_COMPLETION_ONLY)) {\n\t\t\t\t\terr = rvt_invalidate_rkey(\n\t\t\t\t\t\tqp,\n\t\t\t\t\t\twqe->wr.ex.invalidate_rkey);\n\t\t\t\t\tlocal_ops = 1;\n\t\t\t\t}\n\t\t\t\trvt_send_complete(qp, wqe,\n\t\t\t\t\t\t  err ? IB_WC_LOC_PROT_ERR\n\t\t\t\t\t\t      : IB_WC_SUCCESS);\n\t\t\t\tif (local_ops)\n\t\t\t\t\tatomic_dec(&qp->local_ops_pending);\n\t\t\t\tgoto done_free_tx;\n\t\t\t}\n\n\t\t\tnewreq = 1;\n\t\t\tqp->s_psn = wqe->psn;\n\t\t}\n\t\t \n\t\tlen = wqe->length;\n\t\tss = &qp->s_sge;\n\t\tbth2 = mask_psn(qp->s_psn);\n\n\t\t \n\t\tif ((priv->s_flags & HFI1_S_TID_WAIT_INTERLCK) ||\n\t\t    hfi1_tid_rdma_wqe_interlock(qp, wqe))\n\t\t\tgoto bail;\n\n\t\tswitch (wqe->wr.opcode) {\n\t\tcase IB_WR_SEND:\n\t\tcase IB_WR_SEND_WITH_IMM:\n\t\tcase IB_WR_SEND_WITH_INV:\n\t\t\t \n\t\t\tif (!rvt_rc_credit_avail(qp, wqe))\n\t\t\t\tgoto bail;\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(SEND_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->wr.opcode == IB_WR_SEND) {\n\t\t\t\tqp->s_state = OP(SEND_ONLY);\n\t\t\t} else if (wqe->wr.opcode == IB_WR_SEND_WITH_IMM) {\n\t\t\t\tqp->s_state = OP(SEND_ONLY_WITH_IMMEDIATE);\n\t\t\t\t \n\t\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t} else {\n\t\t\t\tqp->s_state = OP(SEND_ONLY_WITH_INVALIDATE);\n\t\t\t\t \n\t\t\t\tohdr->u.ieth = cpu_to_be32(\n\t\t\t\t\t\twqe->wr.ex.invalidate_rkey);\n\t\t\t\thwords += 1;\n\t\t\t}\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tif (newreq && !(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\tqp->s_lsn++;\n\t\t\tgoto no_flow_control;\n\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t \n\t\t\tif (!rvt_rc_credit_avail(qp, wqe))\n\t\t\t\tgoto bail;\nno_flow_control:\n\t\t\tput_ib_reth_vaddr(\n\t\t\t\twqe->rdma_wr.remote_addr,\n\t\t\t\t&ohdr->u.rc.reth);\n\t\t\tohdr->u.rc.reth.rkey =\n\t\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\t\tohdr->u.rc.reth.length = cpu_to_be32(len);\n\t\t\thwords += sizeof(struct ib_reth) / sizeof(u32);\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_ONLY);\n\t\t\t} else {\n\t\t\t\tqp->s_state =\n\t\t\t\t\tOP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);\n\t\t\t\t \n\t\t\t\tohdr->u.rc.imm_data = wqe->wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\t}\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_TID_RDMA_WRITE:\n\t\t\tif (newreq) {\n\t\t\t\t \n\t\t\t\tif (atomic_read(&priv->n_tid_requests) >=\n\t\t\t\t    HFI1_TID_RDMA_WRITE_CNT)\n\t\t\t\t\tgoto bail;\n\n\t\t\t\tif (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\t\tqp->s_lsn++;\n\t\t\t}\n\n\t\t\thwords += hfi1_build_tid_rdma_write_req(qp, wqe, ohdr,\n\t\t\t\t\t\t\t\t&bth1, &bth2,\n\t\t\t\t\t\t\t\t&len);\n\t\t\tss = NULL;\n\t\t\tif (priv->s_tid_cur == HFI1_QP_WQE_INVALID) {\n\t\t\t\tpriv->s_tid_cur = qp->s_cur;\n\t\t\t\tif (priv->s_tid_tail == HFI1_QP_WQE_INVALID) {\n\t\t\t\t\tpriv->s_tid_tail = qp->s_cur;\n\t\t\t\t\tpriv->s_state = TID_OP(WRITE_RESP);\n\t\t\t\t}\n\t\t\t} else if (priv->s_tid_cur == priv->s_tid_head) {\n\t\t\t\tstruct rvt_swqe *__w;\n\t\t\t\tstruct tid_rdma_request *__r;\n\n\t\t\t\t__w = rvt_get_swqe_ptr(qp, priv->s_tid_cur);\n\t\t\t\t__r = wqe_to_tid_req(__w);\n\n\t\t\t\t \n\t\t\t\tif (__w->wr.opcode != IB_WR_TID_RDMA_WRITE ||\n\t\t\t\t    __r->state == TID_REQUEST_INACTIVE ||\n\t\t\t\t    __r->state == TID_REQUEST_COMPLETE ||\n\t\t\t\t    ((__r->state == TID_REQUEST_ACTIVE ||\n\t\t\t\t      __r->state == TID_REQUEST_SYNC) &&\n\t\t\t\t     __r->comp_seg == __r->total_segs)) {\n\t\t\t\t\tif (priv->s_tid_tail ==\n\t\t\t\t\t    priv->s_tid_cur &&\n\t\t\t\t\t    priv->s_state ==\n\t\t\t\t\t    TID_OP(WRITE_DATA_LAST)) {\n\t\t\t\t\t\tpriv->s_tid_tail = qp->s_cur;\n\t\t\t\t\t\tpriv->s_state =\n\t\t\t\t\t\t\tTID_OP(WRITE_RESP);\n\t\t\t\t\t}\n\t\t\t\t\tpriv->s_tid_cur = qp->s_cur;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (priv->s_tid_tail == qp->s_cur &&\n\t\t\t\t    priv->s_state == TID_OP(WRITE_DATA_LAST))\n\t\t\t\t\tpriv->s_state = TID_OP(WRITE_RESP);\n\t\t\t}\n\t\t\treq = wqe_to_tid_req(wqe);\n\t\t\tif (newreq) {\n\t\t\t\tpriv->s_tid_head = qp->s_cur;\n\t\t\t\tpriv->pending_tid_w_resp += req->total_segs;\n\t\t\t\tatomic_inc(&priv->n_tid_requests);\n\t\t\t\tatomic_dec(&priv->n_requests);\n\t\t\t} else {\n\t\t\t\treq->state = TID_REQUEST_RESEND;\n\t\t\t\treq->comp_seg = delta_psn(bth2, wqe->psn);\n\t\t\t\t \n\t\t\t\treq->setup_head = req->clear_tail;\n\t\t\t\tpriv->pending_tid_w_resp +=\n\t\t\t\t\tdelta_psn(wqe->lpsn, bth2) + 1;\n\t\t\t}\n\n\t\t\ttrace_hfi1_tid_write_sender_make_req(qp, newreq);\n\t\t\ttrace_hfi1_tid_req_make_req_write(qp, newreq,\n\t\t\t\t\t\t\t  wqe->wr.opcode,\n\t\t\t\t\t\t\t  wqe->psn, wqe->lpsn,\n\t\t\t\t\t\t\t  req);\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_RDMA_READ:\n\t\t\t \n\t\t\tif (qp->s_num_rd_atomic >=\n\t\t\t    qp->s_max_rd_atomic) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tqp->s_num_rd_atomic++;\n\t\t\tif (newreq && !(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\tqp->s_lsn++;\n\t\t\tput_ib_reth_vaddr(\n\t\t\t\twqe->rdma_wr.remote_addr,\n\t\t\t\t&ohdr->u.rc.reth);\n\t\t\tohdr->u.rc.reth.rkey =\n\t\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\t\tohdr->u.rc.reth.length = cpu_to_be32(len);\n\t\t\tqp->s_state = OP(RDMA_READ_REQUEST);\n\t\t\thwords += sizeof(ohdr->u.rc.reth) / sizeof(u32);\n\t\t\tss = NULL;\n\t\t\tlen = 0;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_TID_RDMA_READ:\n\t\t\ttrace_hfi1_tid_read_sender_make_req(qp, newreq);\n\t\t\twpriv = wqe->priv;\n\t\t\treq = wqe_to_tid_req(wqe);\n\t\t\ttrace_hfi1_tid_req_make_req_read(qp, newreq,\n\t\t\t\t\t\t\t wqe->wr.opcode,\n\t\t\t\t\t\t\t wqe->psn, wqe->lpsn,\n\t\t\t\t\t\t\t req);\n\t\t\tdelta = cmp_psn(qp->s_psn, wqe->psn);\n\n\t\t\t \n\t\t\tif (qp->s_num_rd_atomic >= qp->s_max_rd_atomic) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (newreq) {\n\t\t\t\tstruct tid_rdma_flow *flow =\n\t\t\t\t\t&req->flows[req->setup_head];\n\n\t\t\t\t \n\t\t\t\tif (!flow->npagesets) {\n\t\t\t\t\tqp->s_sge.sge = wqe->sg_list[0];\n\t\t\t\t\tqp->s_sge.sg_list = wqe->sg_list + 1;\n\t\t\t\t\tqp->s_sge.num_sge = wqe->wr.num_sge;\n\t\t\t\t\tqp->s_sge.total_len = wqe->length;\n\t\t\t\t\tqp->s_len = wqe->length;\n\t\t\t\t\treq->isge = 0;\n\t\t\t\t\treq->clear_tail = req->setup_head;\n\t\t\t\t\treq->flow_idx = req->setup_head;\n\t\t\t\t\treq->state = TID_REQUEST_ACTIVE;\n\t\t\t\t}\n\t\t\t} else if (delta == 0) {\n\t\t\t\t \n\t\t\t\treq->cur_seg = 0;\n\t\t\t\treq->comp_seg = 0;\n\t\t\t\treq->ack_pending = 0;\n\t\t\t\treq->flow_idx = req->clear_tail;\n\t\t\t\treq->state = TID_REQUEST_RESEND;\n\t\t\t}\n\t\t\treq->s_next_psn = qp->s_psn;\n\t\t\t \n\t\t\tlen = min_t(u32, req->seg_len,\n\t\t\t\t    wqe->length - req->seg_len * req->cur_seg);\n\t\t\tdelta = hfi1_build_tid_rdma_read_req(qp, wqe, ohdr,\n\t\t\t\t\t\t\t     &bth1, &bth2,\n\t\t\t\t\t\t\t     &len);\n\t\t\tif (delta <= 0) {\n\t\t\t\t \n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (newreq && !(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\tqp->s_lsn++;\n\t\t\thwords += delta;\n\t\t\tss = &wpriv->ss;\n\t\t\t \n\t\t\tif (req->cur_seg >= req->total_segs &&\n\t\t\t    ++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\t \n\t\t\tif (qp->s_num_rd_atomic >=\n\t\t\t    qp->s_max_rd_atomic) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tqp->s_num_rd_atomic++;\n\t\t\tfallthrough;\n\t\tcase IB_WR_OPFN:\n\t\t\tif (newreq && !(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\tqp->s_lsn++;\n\t\t\tif (wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t\t    wqe->wr.opcode == IB_WR_OPFN) {\n\t\t\t\tqp->s_state = OP(COMPARE_SWAP);\n\t\t\t\tput_ib_ateth_swap(wqe->atomic_wr.swap,\n\t\t\t\t\t\t  &ohdr->u.atomic_eth);\n\t\t\t\tput_ib_ateth_compare(wqe->atomic_wr.compare_add,\n\t\t\t\t\t\t     &ohdr->u.atomic_eth);\n\t\t\t} else {\n\t\t\t\tqp->s_state = OP(FETCH_ADD);\n\t\t\t\tput_ib_ateth_swap(wqe->atomic_wr.compare_add,\n\t\t\t\t\t\t  &ohdr->u.atomic_eth);\n\t\t\t\tput_ib_ateth_compare(0, &ohdr->u.atomic_eth);\n\t\t\t}\n\t\t\tput_ib_ateth_vaddr(wqe->atomic_wr.remote_addr,\n\t\t\t\t\t   &ohdr->u.atomic_eth);\n\t\t\tohdr->u.atomic_eth.rkey = cpu_to_be32(\n\t\t\t\twqe->atomic_wr.rkey);\n\t\t\thwords += sizeof(struct ib_atomic_eth) / sizeof(u32);\n\t\t\tss = NULL;\n\t\t\tlen = 0;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto bail;\n\t\t}\n\t\tif (wqe->wr.opcode != IB_WR_TID_RDMA_READ) {\n\t\t\tqp->s_sge.sge = wqe->sg_list[0];\n\t\t\tqp->s_sge.sg_list = wqe->sg_list + 1;\n\t\t\tqp->s_sge.num_sge = wqe->wr.num_sge;\n\t\t\tqp->s_sge.total_len = wqe->length;\n\t\t\tqp->s_len = wqe->length;\n\t\t}\n\t\tif (newreq) {\n\t\t\tqp->s_tail++;\n\t\t\tif (qp->s_tail >= qp->s_size)\n\t\t\t\tqp->s_tail = 0;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t    wqe->wr.opcode == IB_WR_TID_RDMA_WRITE)\n\t\t\tqp->s_psn = wqe->lpsn + 1;\n\t\telse if (wqe->wr.opcode == IB_WR_TID_RDMA_READ)\n\t\t\tqp->s_psn = req->s_next_psn;\n\t\telse\n\t\t\tqp->s_psn++;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\t \n\t\tqp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);\n\t\tfallthrough;\n\tcase OP(SEND_FIRST):\n\t\tqp->s_state = OP(SEND_MIDDLE);\n\t\tfallthrough;\n\tcase OP(SEND_MIDDLE):\n\t\tbth2 = mask_psn(qp->s_psn++);\n\t\tss = &qp->s_sge;\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_SEND) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t} else if (wqe->wr.opcode == IB_WR_SEND_WITH_IMM) {\n\t\t\tqp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);\n\t\t\t \n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t} else {\n\t\t\tqp->s_state = OP(SEND_LAST_WITH_INVALIDATE);\n\t\t\t \n\t\t\tohdr->u.ieth = cpu_to_be32(wqe->wr.ex.invalidate_rkey);\n\t\t\thwords += 1;\n\t\t}\n\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\t\t \n\t\tqp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);\n\t\tfallthrough;\n\tcase OP(RDMA_WRITE_FIRST):\n\t\tqp->s_state = OP(RDMA_WRITE_MIDDLE);\n\t\tfallthrough;\n\tcase OP(RDMA_WRITE_MIDDLE):\n\t\tbth2 = mask_psn(qp->s_psn++);\n\t\tss = &qp->s_sge;\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tmiddle = HFI1_CAP_IS_KSET(SDMA_AHG);\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE) {\n\t\t\tqp->s_state = OP(RDMA_WRITE_LAST);\n\t\t} else {\n\t\t\tqp->s_state = OP(RDMA_WRITE_LAST_WITH_IMMEDIATE);\n\t\t\t \n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t}\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\t \n\t\tlen = (delta_psn(qp->s_psn, wqe->psn)) * pmtu;\n\t\tput_ib_reth_vaddr(\n\t\t\twqe->rdma_wr.remote_addr + len,\n\t\t\t&ohdr->u.rc.reth);\n\t\tohdr->u.rc.reth.rkey =\n\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\tohdr->u.rc.reth.length = cpu_to_be32(wqe->length - len);\n\t\tqp->s_state = OP(RDMA_READ_REQUEST);\n\t\thwords += sizeof(ohdr->u.rc.reth) / sizeof(u32);\n\t\tbth2 = mask_psn(qp->s_psn) | IB_BTH_REQ_ACK;\n\t\tqp->s_psn = wqe->lpsn + 1;\n\t\tss = NULL;\n\t\tlen = 0;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur == qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase TID_OP(WRITE_RESP):\n\t\t \n\t\treq = wqe_to_tid_req(wqe);\n\t\treq->state = TID_REQUEST_RESEND;\n\t\trcu_read_lock();\n\t\tremote = rcu_dereference(priv->tid_rdma.remote);\n\t\treq->comp_seg = delta_psn(qp->s_psn, wqe->psn);\n\t\tlen = wqe->length - (req->comp_seg * remote->max_len);\n\t\trcu_read_unlock();\n\n\t\tbth2 = mask_psn(qp->s_psn);\n\t\thwords += hfi1_build_tid_rdma_write_req(qp, wqe, ohdr, &bth1,\n\t\t\t\t\t\t\t&bth2, &len);\n\t\tqp->s_psn = wqe->lpsn + 1;\n\t\tss = NULL;\n\t\tqp->s_state = TID_OP(WRITE_REQ);\n\t\tpriv->pending_tid_w_resp += delta_psn(wqe->lpsn, bth2) + 1;\n\t\tpriv->s_tid_cur = qp->s_cur;\n\t\tif (++qp->s_cur == qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\ttrace_hfi1_tid_req_make_req_write(qp, 0, wqe->wr.opcode,\n\t\t\t\t\t\t  wqe->psn, wqe->lpsn, req);\n\t\tbreak;\n\n\tcase TID_OP(READ_RESP):\n\t\tif (wqe->wr.opcode != IB_WR_TID_RDMA_READ)\n\t\t\tgoto bail;\n\t\t \n\t\treq = wqe_to_tid_req(wqe);\n\t\twpriv = wqe->priv;\n\t\t \n\t\treq->cur_seg = delta_psn(qp->s_psn, wqe->psn) / priv->pkts_ps;\n\n\t\t \n\t\treq->state = TID_REQUEST_RESEND;\n\t\thfi1_tid_rdma_restart_req(qp, wqe, &bth2);\n\t\tif (req->state != TID_REQUEST_ACTIVE) {\n\t\t\t \n\t\t\thfi1_kern_exp_rcv_clear_all(req);\n\t\t\thfi1_kern_clear_hw_flow(priv->rcd, qp);\n\n\t\t\thfi1_trdma_send_complete(qp, wqe, IB_WC_LOC_QP_OP_ERR);\n\t\t\tgoto bail;\n\t\t}\n\t\treq->state = TID_REQUEST_RESEND;\n\t\tlen = min_t(u32, req->seg_len,\n\t\t\t    wqe->length - req->seg_len * req->cur_seg);\n\t\tflow = &req->flows[req->flow_idx];\n\t\tlen -= flow->sent;\n\t\treq->s_next_psn = flow->flow_state.ib_lpsn + 1;\n\t\tdelta = hfi1_build_tid_rdma_read_packet(wqe, ohdr, &bth1,\n\t\t\t\t\t\t\t&bth2, &len);\n\t\tif (delta <= 0) {\n\t\t\t \n\t\t\tgoto bail;\n\t\t}\n\t\thwords += delta;\n\t\tss = &wpriv->ss;\n\t\t \n\t\tif (req->cur_seg >= req->total_segs &&\n\t\t    ++qp->s_cur == qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tqp->s_psn = req->s_next_psn;\n\t\ttrace_hfi1_tid_req_make_req_read(qp, 0, wqe->wr.opcode,\n\t\t\t\t\t\t wqe->psn, wqe->lpsn, req);\n\t\tbreak;\n\tcase TID_OP(READ_REQ):\n\t\treq = wqe_to_tid_req(wqe);\n\t\tdelta = cmp_psn(qp->s_psn, wqe->psn);\n\t\t \n\t\tif (wqe->wr.opcode != IB_WR_TID_RDMA_READ || delta == 0 ||\n\t\t    qp->s_cur == qp->s_tail) {\n\t\t\tqp->s_state = OP(RDMA_READ_REQUEST);\n\t\t\tif (delta == 0 || qp->s_cur == qp->s_tail)\n\t\t\t\tgoto check_s_state;\n\t\t\telse\n\t\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tif (qp->s_num_rd_atomic >= qp->s_max_rd_atomic) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\tgoto bail;\n\t\t}\n\n\t\twpriv = wqe->priv;\n\t\t \n\t\tlen = min_t(u32, req->seg_len,\n\t\t\t    wqe->length - req->seg_len * req->cur_seg);\n\t\tdelta = hfi1_build_tid_rdma_read_req(qp, wqe, ohdr, &bth1,\n\t\t\t\t\t\t     &bth2, &len);\n\t\tif (delta <= 0) {\n\t\t\t \n\t\t\tgoto bail;\n\t\t}\n\t\thwords += delta;\n\t\tss = &wpriv->ss;\n\t\t \n\t\tif (req->cur_seg >= req->total_segs &&\n\t\t    ++qp->s_cur == qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tqp->s_psn = req->s_next_psn;\n\t\ttrace_hfi1_tid_req_make_req_read(qp, 0, wqe->wr.opcode,\n\t\t\t\t\t\t wqe->psn, wqe->lpsn, req);\n\t\tbreak;\n\t}\n\tqp->s_sending_hpsn = bth2;\n\tdelta = delta_psn(bth2, wqe->psn);\n\tif (delta && delta % HFI1_PSN_CREDIT == 0 &&\n\t    wqe->wr.opcode != IB_WR_TID_RDMA_WRITE)\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\tif (qp->s_flags & RVT_S_SEND_ONE) {\n\t\tqp->s_flags &= ~RVT_S_SEND_ONE;\n\t\tqp->s_flags |= RVT_S_WAIT_ACK;\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t}\n\tqp->s_len -= len;\n\tps->s_txreq->hdr_dwords = hwords;\n\tps->s_txreq->sde = priv->s_sde;\n\tps->s_txreq->ss = ss;\n\tps->s_txreq->s_cur_size = len;\n\thfi1_make_ruc_header(\n\t\tqp,\n\t\tohdr,\n\t\tbth0 | (qp->s_state << 24),\n\t\tbth1,\n\t\tbth2,\n\t\tmiddle,\n\t\tps);\n\treturn 1;\n\ndone_free_tx:\n\thfi1_put_txreq(ps->s_txreq);\n\tps->s_txreq = NULL;\n\treturn 1;\n\nbail:\n\thfi1_put_txreq(ps->s_txreq);\n\nbail_no_tx:\n\tps->s_txreq = NULL;\n\tqp->s_flags &= ~RVT_S_BUSY;\n\t \n\tiowait_set_flag(&priv->s_iowait, IOWAIT_PENDING_IB);\n\treturn 0;\n}\n\nstatic inline void hfi1_make_bth_aeth(struct rvt_qp *qp,\n\t\t\t\t      struct ib_other_headers *ohdr,\n\t\t\t\t      u32 bth0, u32 bth1)\n{\n\tif (qp->r_nak_state)\n\t\tohdr->u.aeth = cpu_to_be32((qp->r_msn & IB_MSN_MASK) |\n\t\t\t\t\t    (qp->r_nak_state <<\n\t\t\t\t\t     IB_AETH_CREDIT_SHIFT));\n\telse\n\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\n\tohdr->bth[0] = cpu_to_be32(bth0);\n\tohdr->bth[1] = cpu_to_be32(bth1 | qp->remote_qpn);\n\tohdr->bth[2] = cpu_to_be32(mask_psn(qp->r_ack_psn));\n}\n\nstatic inline void hfi1_queue_rc_ack(struct hfi1_packet *packet, bool is_fecn)\n{\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_ibport *ibp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto unlock;\n\tibp = rcd_to_iport(packet->rcd);\n\tthis_cpu_inc(*ibp->rvp.rc_qacks);\n\tqp->s_flags |= RVT_S_ACK_PENDING | RVT_S_RESP_PENDING;\n\tqp->s_nak_state = qp->r_nak_state;\n\tqp->s_ack_psn = qp->r_ack_psn;\n\tif (is_fecn)\n\t\tqp->s_flags |= RVT_S_ECN;\n\n\t \n\thfi1_schedule_send(qp);\nunlock:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n}\n\nstatic inline void hfi1_make_rc_ack_9B(struct hfi1_packet *packet,\n\t\t\t\t       struct hfi1_opa_header *opa_hdr,\n\t\t\t\t       u8 sc5, bool is_fecn,\n\t\t\t\t       u64 *pbc_flags, u32 *hwords,\n\t\t\t\t       u32 *nwords)\n{\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_ibport *ibp = rcd_to_iport(packet->rcd);\n\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct ib_header *hdr = &opa_hdr->ibh;\n\tstruct ib_other_headers *ohdr;\n\tu16 lrh0 = HFI1_LRH_BTH;\n\tu16 pkey;\n\tu32 bth0, bth1;\n\n\topa_hdr->hdr_type = HFI1_PKT_TYPE_9B;\n\tohdr = &hdr->u.oth;\n\t \n\t*hwords = 6;\n\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {\n\t\t*hwords += hfi1_make_grh(ibp, &hdr->u.l.grh,\n\t\t\t\t\t rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t\t *hwords - 2, SIZE_OF_CRC);\n\t\tohdr = &hdr->u.l.oth;\n\t\tlrh0 = HFI1_LRH_GRH;\n\t}\n\t \n\t*pbc_flags |= ((!!(sc5 & 0x10)) << PBC_DC_INFO_SHIFT);\n\n\t \n\tpkey = hfi1_get_pkey(ibp, qp->s_pkey_index);\n\n\tlrh0 |= (sc5 & IB_SC_MASK) << IB_SC_SHIFT |\n\t\t(rdma_ah_get_sl(&qp->remote_ah_attr) & IB_SL_MASK) <<\n\t\t\tIB_SL_SHIFT;\n\n\thfi1_make_ib_hdr(hdr, lrh0, *hwords + SIZE_OF_CRC,\n\t\t\t opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr), 9B),\n\t\t\t ppd->lid | rdma_ah_get_path_bits(&qp->remote_ah_attr));\n\n\tbth0 = pkey | (OP(ACKNOWLEDGE) << 24);\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth0 |= IB_BTH_MIG_REQ;\n\tbth1 = (!!is_fecn) << IB_BECN_SHIFT;\n\t \n\tbth1 |= HFI1_CAP_IS_KSET(OPFN) << IB_BTHE_E_SHIFT;\n\thfi1_make_bth_aeth(qp, ohdr, bth0, bth1);\n}\n\nstatic inline void hfi1_make_rc_ack_16B(struct hfi1_packet *packet,\n\t\t\t\t\tstruct hfi1_opa_header *opa_hdr,\n\t\t\t\t\tu8 sc5, bool is_fecn,\n\t\t\t\t\tu64 *pbc_flags, u32 *hwords,\n\t\t\t\t\tu32 *nwords)\n{\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_ibport *ibp = rcd_to_iport(packet->rcd);\n\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct hfi1_16b_header *hdr = &opa_hdr->opah;\n\tstruct ib_other_headers *ohdr;\n\tu32 bth0, bth1 = 0;\n\tu16 len, pkey;\n\tbool becn = is_fecn;\n\tu8 l4 = OPA_16B_L4_IB_LOCAL;\n\tu8 extra_bytes;\n\n\topa_hdr->hdr_type = HFI1_PKT_TYPE_16B;\n\tohdr = &hdr->u.oth;\n\t \n\t*hwords = 8;\n\textra_bytes = hfi1_get_16b_padding(*hwords << 2, 0);\n\t*nwords = SIZE_OF_CRC + ((extra_bytes + SIZE_OF_LT) >> 2);\n\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&\n\t    hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))) {\n\t\t*hwords += hfi1_make_grh(ibp, &hdr->u.l.grh,\n\t\t\t\t\t rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t\t *hwords - 4, *nwords);\n\t\tohdr = &hdr->u.l.oth;\n\t\tl4 = OPA_16B_L4_IB_GLOBAL;\n\t}\n\t*pbc_flags |= PBC_PACKET_BYPASS | PBC_INSERT_BYPASS_ICRC;\n\n\t \n\tpkey = hfi1_get_pkey(ibp, qp->s_pkey_index);\n\n\t \n\tlen = (*hwords + *nwords) >> 1;\n\n\thfi1_make_16b_hdr(hdr, ppd->lid |\n\t\t\t  (rdma_ah_get_path_bits(&qp->remote_ah_attr) &\n\t\t\t  ((1 << ppd->lmc) - 1)),\n\t\t\t  opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr),\n\t\t\t\t      16B), len, pkey, becn, 0, l4, sc5);\n\n\tbth0 = pkey | (OP(ACKNOWLEDGE) << 24);\n\tbth0 |= extra_bytes << 20;\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth1 = OPA_BTH_MIG_REQ;\n\thfi1_make_bth_aeth(qp, ohdr, bth0, bth1);\n}\n\ntypedef void (*hfi1_make_rc_ack)(struct hfi1_packet *packet,\n\t\t\t\t struct hfi1_opa_header *opa_hdr,\n\t\t\t\t u8 sc5, bool is_fecn,\n\t\t\t\t u64 *pbc_flags, u32 *hwords,\n\t\t\t\t u32 *nwords);\n\n \nstatic const hfi1_make_rc_ack hfi1_make_rc_ack_tbl[2] = {\n\t[HFI1_PKT_TYPE_9B] = &hfi1_make_rc_ack_9B,\n\t[HFI1_PKT_TYPE_16B] = &hfi1_make_rc_ack_16B\n};\n\n \nvoid hfi1_send_rc_ack(struct hfi1_packet *packet, bool is_fecn)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_ibport *ibp = rcd_to_iport(rcd);\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\tu8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];\n\tu64 pbc, pbc_flags = 0;\n\tu32 hwords = 0;\n\tu32 nwords = 0;\n\tu32 plen;\n\tstruct pio_buf *pbuf;\n\tstruct hfi1_opa_header opa_hdr;\n\n\t \n\tqp->r_adefered = 0;\n\n\t \n\tif (qp->s_flags & RVT_S_RESP_PENDING) {\n\t\thfi1_queue_rc_ack(packet, is_fecn);\n\t\treturn;\n\t}\n\n\t \n\tif (qp->s_rdma_ack_cnt) {\n\t\thfi1_queue_rc_ack(packet, is_fecn);\n\t\treturn;\n\t}\n\n\t \n\tif (driver_lstate(ppd) != IB_PORT_ACTIVE)\n\t\treturn;\n\n\t \n\thfi1_make_rc_ack_tbl[priv->hdr_type](packet, &opa_hdr, sc5, is_fecn,\n\t\t\t\t\t     &pbc_flags, &hwords, &nwords);\n\n\tplen = 2   + hwords + nwords;\n\tpbc = create_pbc(ppd, pbc_flags, qp->srate_mbps,\n\t\t\t sc_to_vlt(ppd->dd, sc5), plen);\n\tpbuf = sc_buffer_alloc(rcd->sc, plen, NULL, NULL);\n\tif (IS_ERR_OR_NULL(pbuf)) {\n\t\t \n\t\thfi1_queue_rc_ack(packet, is_fecn);\n\t\treturn;\n\t}\n\ttrace_ack_output_ibhdr(dd_from_ibdev(qp->ibqp.device),\n\t\t\t       &opa_hdr, ib_is_sc5(sc5));\n\n\t \n\tppd->dd->pio_inline_send(ppd->dd, pbuf, pbc,\n\t\t\t\t (priv->hdr_type == HFI1_PKT_TYPE_9B ?\n\t\t\t\t (void *)&opa_hdr.ibh :\n\t\t\t\t (void *)&opa_hdr.opah), hwords);\n\treturn;\n}\n\n \nstatic void update_num_rd_atomic(struct rvt_qp *qp, u32 psn,\n\t\t\t\t struct rvt_swqe *wqe)\n{\n\tu32 opcode = wqe->wr.opcode;\n\n\tif (opcode == IB_WR_RDMA_READ ||\n\t    opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t    opcode == IB_WR_ATOMIC_FETCH_AND_ADD) {\n\t\tqp->s_num_rd_atomic++;\n\t} else if (opcode == IB_WR_TID_RDMA_READ) {\n\t\tstruct tid_rdma_request *req = wqe_to_tid_req(wqe);\n\t\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\t\tif (cmp_psn(psn, wqe->lpsn) <= 0) {\n\t\t\tu32 cur_seg;\n\n\t\t\tcur_seg = (psn - wqe->psn) / priv->pkts_ps;\n\t\t\treq->ack_pending = cur_seg - req->comp_seg;\n\t\t\tpriv->pending_tid_r_segs += req->ack_pending;\n\t\t\tqp->s_num_rd_atomic += req->ack_pending;\n\t\t\ttrace_hfi1_tid_req_update_num_rd_atomic(qp, 0,\n\t\t\t\t\t\t\t\twqe->wr.opcode,\n\t\t\t\t\t\t\t\twqe->psn,\n\t\t\t\t\t\t\t\twqe->lpsn,\n\t\t\t\t\t\t\t\treq);\n\t\t} else {\n\t\t\tpriv->pending_tid_r_segs += req->total_segs;\n\t\t\tqp->s_num_rd_atomic += req->total_segs;\n\t\t}\n\t}\n}\n\n \nstatic void reset_psn(struct rvt_qp *qp, u32 psn)\n{\n\tu32 n = qp->s_acked;\n\tstruct rvt_swqe *wqe = rvt_get_swqe_ptr(qp, n);\n\tu32 opcode;\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\tlockdep_assert_held(&qp->s_lock);\n\tqp->s_cur = n;\n\tpriv->pending_tid_r_segs = 0;\n\tpriv->pending_tid_w_resp = 0;\n\tqp->s_num_rd_atomic = 0;\n\n\t \n\tif (cmp_psn(psn, wqe->psn) <= 0) {\n\t\tqp->s_state = OP(SEND_LAST);\n\t\tgoto done;\n\t}\n\tupdate_num_rd_atomic(qp, psn, wqe);\n\n\t \n\tfor (;;) {\n\t\tint diff;\n\n\t\tif (++n == qp->s_size)\n\t\t\tn = 0;\n\t\tif (n == qp->s_tail)\n\t\t\tbreak;\n\t\twqe = rvt_get_swqe_ptr(qp, n);\n\t\tdiff = cmp_psn(psn, wqe->psn);\n\t\tif (diff < 0) {\n\t\t\t \n\t\t\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\t\t\tbreak;\n\t\t}\n\t\tqp->s_cur = n;\n\t\t \n\t\tif (diff == 0) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\tgoto done;\n\t\t}\n\n\t\tupdate_num_rd_atomic(qp, psn, wqe);\n\t}\n\topcode = wqe->wr.opcode;\n\n\t \n\tswitch (opcode) {\n\tcase IB_WR_SEND:\n\tcase IB_WR_SEND_WITH_IMM:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_FIRST);\n\t\tbreak;\n\n\tcase IB_WR_RDMA_WRITE:\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_LAST);\n\t\tbreak;\n\n\tcase IB_WR_TID_RDMA_WRITE:\n\t\tqp->s_state = TID_OP(WRITE_RESP);\n\t\tbreak;\n\n\tcase IB_WR_RDMA_READ:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_MIDDLE);\n\t\tbreak;\n\n\tcase IB_WR_TID_RDMA_READ:\n\t\tqp->s_state = TID_OP(READ_RESP);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tqp->s_state = OP(SEND_LAST);\n\t}\ndone:\n\tpriv->s_flags &= ~HFI1_S_TID_WAIT_INTERLCK;\n\tqp->s_psn = psn;\n\t \n\tif ((cmp_psn(qp->s_psn, qp->s_sending_hpsn) <= 0) &&\n\t    (cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) <= 0))\n\t\tqp->s_flags |= RVT_S_WAIT_PSN;\n\tqp->s_flags &= ~HFI1_S_AHG_VALID;\n\ttrace_hfi1_sender_reset_psn(qp);\n}\n\n \nvoid hfi1_restart_rc(struct rvt_qp *qp, u32 psn, int wait)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct rvt_swqe *wqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tstruct hfi1_ibport *ibp;\n\n\tlockdep_assert_held(&qp->r_lock);\n\tlockdep_assert_held(&qp->s_lock);\n\ttrace_hfi1_sender_restart_rc(qp);\n\tif (qp->s_retry == 0) {\n\t\tif (qp->s_mig_state == IB_MIG_ARMED) {\n\t\t\thfi1_migrate_qp(qp);\n\t\t\tqp->s_retry = qp->s_retry_cnt;\n\t\t} else if (qp->s_last == qp->s_acked) {\n\t\t\t \n\t\t\tif (wqe->wr.opcode == IB_WR_OPFN) {\n\t\t\t\tstruct hfi1_ibport *ibp =\n\t\t\t\t\tto_iport(qp->ibqp.device, qp->port_num);\n\t\t\t\t \n\t\t\t\topfn_conn_reply(qp, priv->opfn.curr);\n\t\t\t\twqe = do_rc_completion(qp, wqe, ibp);\n\t\t\t\tqp->s_flags &= ~RVT_S_WAIT_ACK;\n\t\t\t} else {\n\t\t\t\ttrace_hfi1_tid_write_sender_restart_rc(qp, 0);\n\t\t\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_READ) {\n\t\t\t\t\tstruct tid_rdma_request *req;\n\n\t\t\t\t\treq = wqe_to_tid_req(wqe);\n\t\t\t\t\thfi1_kern_exp_rcv_clear_all(req);\n\t\t\t\t\thfi1_kern_clear_hw_flow(priv->rcd, qp);\n\t\t\t\t}\n\n\t\t\t\thfi1_trdma_send_complete(qp, wqe,\n\t\t\t\t\t\t\t IB_WC_RETRY_EXC_ERR);\n\t\t\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {  \n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tqp->s_retry--;\n\t}\n\n\tibp = to_iport(qp->ibqp.device, qp->port_num);\n\tif (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t    wqe->wr.opcode == IB_WR_TID_RDMA_READ)\n\t\tibp->rvp.n_rc_resends++;\n\telse\n\t\tibp->rvp.n_rc_resends += delta_psn(qp->s_psn, psn);\n\n\tqp->s_flags &= ~(RVT_S_WAIT_FENCE | RVT_S_WAIT_RDMAR |\n\t\t\t RVT_S_WAIT_SSN_CREDIT | RVT_S_WAIT_PSN |\n\t\t\t RVT_S_WAIT_ACK | HFI1_S_WAIT_TID_RESP);\n\tif (wait)\n\t\tqp->s_flags |= RVT_S_SEND_ONE;\n\treset_psn(qp, psn);\n}\n\n \nstatic void reset_sending_psn(struct rvt_qp *qp, u32 psn)\n{\n\tstruct rvt_swqe *wqe;\n\tu32 n = qp->s_last;\n\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\tfor (;;) {\n\t\twqe = rvt_get_swqe_ptr(qp, n);\n\t\tif (cmp_psn(psn, wqe->lpsn) <= 0) {\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t\t    wqe->wr.opcode == IB_WR_TID_RDMA_READ ||\n\t\t\t    wqe->wr.opcode == IB_WR_TID_RDMA_WRITE)\n\t\t\t\tqp->s_sending_psn = wqe->lpsn + 1;\n\t\t\telse\n\t\t\t\tqp->s_sending_psn = psn + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (++n == qp->s_size)\n\t\t\tn = 0;\n\t\tif (n == qp->s_tail)\n\t\t\tbreak;\n\t}\n}\n\n \nvoid hfi1_rc_verbs_aborted(struct rvt_qp *qp, struct hfi1_opa_header *opah)\n{\n\tstruct ib_other_headers *ohdr = hfi1_get_rc_ohdr(opah);\n\tu8 opcode = ib_bth_get_opcode(ohdr);\n\tu32 psn;\n\n\t \n\tif ((opcode >= OP(RDMA_READ_RESPONSE_FIRST) &&\n\t     opcode <= OP(ATOMIC_ACKNOWLEDGE)) ||\n\t    opcode == TID_OP(READ_RESP) ||\n\t    opcode == TID_OP(WRITE_RESP))\n\t\treturn;\n\n\tpsn = ib_bth_get_psn(ohdr) | IB_BTH_REQ_ACK;\n\tohdr->bth[2] = cpu_to_be32(psn);\n\tqp->s_flags |= RVT_S_SEND_ONE;\n}\n\n \nvoid hfi1_rc_send_complete(struct rvt_qp *qp, struct hfi1_opa_header *opah)\n{\n\tstruct ib_other_headers *ohdr;\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct rvt_swqe *wqe;\n\tu32 opcode, head, tail;\n\tu32 psn;\n\tstruct tid_rdma_request *req;\n\n\tlockdep_assert_held(&qp->s_lock);\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_SEND_OR_FLUSH_OR_RECV_OK))\n\t\treturn;\n\n\tohdr = hfi1_get_rc_ohdr(opah);\n\topcode = ib_bth_get_opcode(ohdr);\n\tif ((opcode >= OP(RDMA_READ_RESPONSE_FIRST) &&\n\t     opcode <= OP(ATOMIC_ACKNOWLEDGE)) ||\n\t    opcode == TID_OP(READ_RESP) ||\n\t    opcode == TID_OP(WRITE_RESP)) {\n\t\tWARN_ON(!qp->s_rdma_ack_cnt);\n\t\tqp->s_rdma_ack_cnt--;\n\t\treturn;\n\t}\n\n\tpsn = ib_bth_get_psn(ohdr);\n\t \n\tif (opcode != TID_OP(WRITE_DATA) &&\n\t    opcode != TID_OP(WRITE_DATA_LAST) &&\n\t    opcode != TID_OP(ACK) && opcode != TID_OP(RESYNC))\n\t\treset_sending_psn(qp, psn);\n\n\t \n\tif (opcode >= TID_OP(WRITE_REQ) &&\n\t    opcode <= TID_OP(WRITE_DATA_LAST)) {\n\t\thead = priv->s_tid_head;\n\t\ttail = priv->s_tid_cur;\n\t\t \n\t\twqe = rvt_get_swqe_ptr(qp, tail);\n\t\treq = wqe_to_tid_req(wqe);\n\t\tif (head == tail && req->comp_seg < req->total_segs) {\n\t\t\tif (tail == 0)\n\t\t\t\ttail = qp->s_size - 1;\n\t\t\telse\n\t\t\t\ttail -= 1;\n\t\t}\n\t} else {\n\t\thead = qp->s_tail;\n\t\ttail = qp->s_acked;\n\t}\n\n\t \n\tif ((psn & IB_BTH_REQ_ACK) && tail != head &&\n\t    opcode != TID_OP(WRITE_DATA) && opcode != TID_OP(WRITE_DATA_LAST) &&\n\t    opcode != TID_OP(RESYNC) &&\n\t    !(qp->s_flags &\n\t      (RVT_S_TIMER | RVT_S_WAIT_RNR | RVT_S_WAIT_PSN)) &&\n\t    (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK)) {\n\t\tif (opcode == TID_OP(READ_REQ))\n\t\t\trvt_add_retry_timer_ext(qp, priv->timeout_shift);\n\t\telse\n\t\t\trvt_add_retry_timer(qp);\n\t}\n\n\t \n\tif ((opcode == TID_OP(WRITE_DATA) ||\n\t     opcode == TID_OP(WRITE_DATA_LAST) ||\n\t     opcode == TID_OP(RESYNC)) &&\n\t    (psn & IB_BTH_REQ_ACK) &&\n\t    !(priv->s_flags & HFI1_S_TID_RETRY_TIMER) &&\n\t    (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK)) {\n\t\t \n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t\treq = wqe_to_tid_req(wqe);\n\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_WRITE &&\n\t\t    req->ack_seg < req->cur_seg)\n\t\t\thfi1_add_tid_retry_timer(qp);\n\t}\n\n\twhile (qp->s_last != qp->s_acked) {\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\tif (cmp_psn(wqe->lpsn, qp->s_sending_psn) >= 0 &&\n\t\t    cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) <= 0)\n\t\t\tbreak;\n\t\ttrdma_clean_swqe(qp, wqe);\n\t\ttrace_hfi1_qp_send_completion(qp, wqe, qp->s_last);\n\t\trvt_qp_complete_swqe(qp,\n\t\t\t\t     wqe,\n\t\t\t\t     ib_hfi1_wc_opcode[wqe->wr.opcode],\n\t\t\t\t     IB_WC_SUCCESS);\n\t}\n\t \n\ttrace_hfi1_sendcomplete(qp, psn);\n\tif (qp->s_flags & RVT_S_WAIT_PSN &&\n\t    cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) > 0) {\n\t\tqp->s_flags &= ~RVT_S_WAIT_PSN;\n\t\tqp->s_sending_psn = qp->s_psn;\n\t\tqp->s_sending_hpsn = qp->s_psn - 1;\n\t\thfi1_schedule_send(qp);\n\t}\n}\n\nstatic inline void update_last_psn(struct rvt_qp *qp, u32 psn)\n{\n\tqp->s_last_psn = psn;\n}\n\n \nstruct rvt_swqe *do_rc_completion(struct rvt_qp *qp,\n\t\t\t\t  struct rvt_swqe *wqe,\n\t\t\t\t  struct hfi1_ibport *ibp)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\ttrace_hfi1_rc_completion(qp, wqe->lpsn);\n\tif (cmp_psn(wqe->lpsn, qp->s_sending_psn) < 0 ||\n\t    cmp_psn(qp->s_sending_psn, qp->s_sending_hpsn) > 0) {\n\t\ttrdma_clean_swqe(qp, wqe);\n\t\ttrace_hfi1_qp_send_completion(qp, wqe, qp->s_last);\n\t\trvt_qp_complete_swqe(qp,\n\t\t\t\t     wqe,\n\t\t\t\t     ib_hfi1_wc_opcode[wqe->wr.opcode],\n\t\t\t\t     IB_WC_SUCCESS);\n\t} else {\n\t\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\n\t\tthis_cpu_inc(*ibp->rvp.rc_delayed_comp);\n\t\t \n\t\tif (ppd->dd->flags & HFI1_HAS_SEND_DMA) {\n\t\t\tstruct sdma_engine *engine;\n\t\t\tu8 sl = rdma_ah_get_sl(&qp->remote_ah_attr);\n\t\t\tu8 sc5;\n\n\t\t\t \n\t\t\tsc5 = ibp->sl_to_sc[sl];\n\t\t\tengine = qp_to_sdma_engine(qp, sc5);\n\t\t\tsdma_engine_progress_schedule(engine);\n\t\t}\n\t}\n\n\tqp->s_retry = qp->s_retry_cnt;\n\t \n\tif (wqe->wr.opcode != IB_WR_TID_RDMA_WRITE)\n\t\tupdate_last_psn(qp, wqe->lpsn);\n\n\t \n\tif (qp->s_acked == qp->s_cur) {\n\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tqp->s_acked = qp->s_cur;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\t\tif (qp->s_acked != qp->s_tail) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\tqp->s_psn = wqe->psn;\n\t\t}\n\t} else {\n\t\tif (++qp->s_acked >= qp->s_size)\n\t\t\tqp->s_acked = 0;\n\t\tif (qp->state == IB_QPS_SQD && qp->s_acked == qp->s_cur)\n\t\t\tqp->s_draining = 0;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t}\n\tif (priv->s_flags & HFI1_S_TID_WAIT_INTERLCK) {\n\t\tpriv->s_flags &= ~HFI1_S_TID_WAIT_INTERLCK;\n\t\thfi1_schedule_send(qp);\n\t}\n\treturn wqe;\n}\n\nstatic void set_restart_qp(struct rvt_qp *qp, struct hfi1_ctxtdata *rcd)\n{\n\t \n\tif (!(qp->r_flags & RVT_R_RDMAR_SEQ)) {\n\t\tqp->r_flags |= RVT_R_RDMAR_SEQ;\n\t\thfi1_restart_rc(qp, qp->s_last_psn + 1, 0);\n\t\tif (list_empty(&qp->rspwait)) {\n\t\t\tqp->r_flags |= RVT_R_RSP_SEND;\n\t\t\trvt_get_qp(qp);\n\t\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t\t}\n\t}\n}\n\n \nstatic void update_qp_retry_state(struct rvt_qp *qp, u32 psn, u32 spsn,\n\t\t\t\t  u32 lpsn)\n{\n\tstruct hfi1_qp_priv *qpriv = qp->priv;\n\n\tqp->s_psn = psn + 1;\n\t \n\tif (cmp_psn(psn, lpsn) >= 0) {\n\t\tqp->s_cur = qpriv->s_tid_cur + 1;\n\t\tif (qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tqp->s_state = TID_OP(WRITE_REQ);\n\t} else  if (!cmp_psn(psn, spsn)) {\n\t\tqp->s_cur = qpriv->s_tid_cur;\n\t\tqp->s_state = TID_OP(WRITE_RESP);\n\t}\n}\n\n \nint do_rc_ack(struct rvt_qp *qp, u32 aeth, u32 psn, int opcode,\n\t      u64 val, struct hfi1_ctxtdata *rcd)\n{\n\tstruct hfi1_ibport *ibp;\n\tenum ib_wc_status status;\n\tstruct hfi1_qp_priv *qpriv = qp->priv;\n\tstruct rvt_swqe *wqe;\n\tint ret = 0;\n\tu32 ack_psn;\n\tint diff;\n\tstruct rvt_dev_info *rdi;\n\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\tack_psn = psn;\n\tif (aeth >> IB_AETH_NAK_SHIFT)\n\t\tack_psn--;\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tibp = rcd_to_iport(rcd);\n\n\t \n\twhile ((diff = delta_psn(ack_psn, wqe->lpsn)) >= 0) {\n\t\t \n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ &&\n\t\t    opcode == OP(RDMA_READ_RESPONSE_ONLY) &&\n\t\t    diff == 0) {\n\t\t\tret = 1;\n\t\t\tgoto bail_stop;\n\t\t}\n\t\t \n\t\tif ((wqe->wr.opcode == IB_WR_RDMA_READ &&\n\t\t     (opcode != OP(RDMA_READ_RESPONSE_LAST) || diff != 0)) ||\n\t\t    (wqe->wr.opcode == IB_WR_TID_RDMA_READ &&\n\t\t     (opcode != TID_OP(READ_RESP) || diff != 0)) ||\n\t\t    ((wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t      wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD) &&\n\t\t     (opcode != OP(ATOMIC_ACKNOWLEDGE) || diff != 0)) ||\n\t\t    (wqe->wr.opcode == IB_WR_TID_RDMA_WRITE &&\n\t\t     (delta_psn(psn, qp->s_last_psn) != 1))) {\n\t\t\tset_restart_qp(qp, rcd);\n\t\t\t \n\t\t\tgoto bail_stop;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD) {\n\t\t\tu64 *vaddr = wqe->sg_list[0].vaddr;\n\t\t\t*vaddr = val;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_OPFN)\n\t\t\topfn_conn_reply(qp, val);\n\n\t\tif (qp->s_num_rd_atomic &&\n\t\t    (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t     wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t     wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD)) {\n\t\t\tqp->s_num_rd_atomic--;\n\t\t\t \n\t\t\tif ((qp->s_flags & RVT_S_WAIT_FENCE) &&\n\t\t\t    !qp->s_num_rd_atomic) {\n\t\t\t\tqp->s_flags &= ~(RVT_S_WAIT_FENCE |\n\t\t\t\t\t\t RVT_S_WAIT_ACK);\n\t\t\t\thfi1_schedule_send(qp);\n\t\t\t} else if (qp->s_flags & RVT_S_WAIT_RDMAR) {\n\t\t\t\tqp->s_flags &= ~(RVT_S_WAIT_RDMAR |\n\t\t\t\t\t\t RVT_S_WAIT_ACK);\n\t\t\t\thfi1_schedule_send(qp);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_WRITE)\n\t\t\tbreak;\n\n\t\twqe = do_rc_completion(qp, wqe, ibp);\n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tbreak;\n\t}\n\n\ttrace_hfi1_rc_ack_do(qp, aeth, psn, wqe);\n\ttrace_hfi1_sender_do_rc_ack(qp);\n\tswitch (aeth >> IB_AETH_NAK_SHIFT) {\n\tcase 0:          \n\t\tthis_cpu_inc(*ibp->rvp.rc_acks);\n\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_READ) {\n\t\t\tif (wqe_to_tid_req(wqe)->ack_pending)\n\t\t\t\trvt_mod_retry_timer_ext(qp,\n\t\t\t\t\t\t\tqpriv->timeout_shift);\n\t\t\telse\n\t\t\t\trvt_stop_rc_timers(qp);\n\t\t} else if (qp->s_acked != qp->s_tail) {\n\t\t\tstruct rvt_swqe *__w = NULL;\n\n\t\t\tif (qpriv->s_tid_cur != HFI1_QP_WQE_INVALID)\n\t\t\t\t__w = rvt_get_swqe_ptr(qp, qpriv->s_tid_cur);\n\n\t\t\t \n\t\t\tif (__w && __w->wr.opcode == IB_WR_TID_RDMA_WRITE &&\n\t\t\t    opcode == TID_OP(WRITE_RESP)) {\n\t\t\t\t \n\t\t\t\tif (cmp_psn(psn, qp->s_last_psn + 1)) {\n\t\t\t\t\tset_restart_qp(qp, rcd);\n\t\t\t\t\tgoto bail_stop;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (qp->s_cur != qp->s_tail &&\n\t\t\t\t    cmp_psn(qp->s_psn, psn) <= 0)\n\t\t\t\t\tupdate_qp_retry_state(qp, psn,\n\t\t\t\t\t\t\t      __w->psn,\n\t\t\t\t\t\t\t      __w->lpsn);\n\t\t\t\telse if (--qpriv->pending_tid_w_resp)\n\t\t\t\t\trvt_mod_retry_timer(qp);\n\t\t\t\telse\n\t\t\t\t\trvt_stop_rc_timers(qp);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trvt_mod_retry_timer(qp);\n\t\t\t\t \n\t\t\t\tif (cmp_psn(qp->s_psn, psn) <= 0)\n\t\t\t\t\treset_psn(qp, psn + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\trvt_stop_rc_timers(qp);\n\t\t\tif (cmp_psn(qp->s_psn, psn) <= 0) {\n\t\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\t\tqp->s_psn = psn + 1;\n\t\t\t}\n\t\t}\n\t\tif (qp->s_flags & RVT_S_WAIT_ACK) {\n\t\t\tqp->s_flags &= ~RVT_S_WAIT_ACK;\n\t\t\thfi1_schedule_send(qp);\n\t\t}\n\t\trvt_get_credit(qp, aeth);\n\t\tqp->s_rnr_retry = qp->s_rnr_retry_cnt;\n\t\tqp->s_retry = qp->s_retry_cnt;\n\t\t \n\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_WRITE &&\n\t\t    opcode != TID_OP(WRITE_RESP) &&\n\t\t    cmp_psn(psn, wqe->psn) >= 0)\n\t\t\treturn 1;\n\t\tupdate_last_psn(qp, psn);\n\t\treturn 1;\n\n\tcase 1:          \n\t\tibp->rvp.n_rnr_naks++;\n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tgoto bail_stop;\n\t\tif (qp->s_flags & RVT_S_WAIT_RNR)\n\t\t\tgoto bail_stop;\n\t\trdi = ib_to_rvt(qp->ibqp.device);\n\t\tif (!(rdi->post_parms[wqe->wr.opcode].flags &\n\t\t       RVT_OPERATION_IGN_RNR_CNT)) {\n\t\t\tif (qp->s_rnr_retry == 0) {\n\t\t\t\tstatus = IB_WC_RNR_RETRY_EXC_ERR;\n\t\t\t\tgoto class_b;\n\t\t\t}\n\t\t\tif (qp->s_rnr_retry_cnt < 7 && qp->s_rnr_retry_cnt > 0)\n\t\t\t\tqp->s_rnr_retry--;\n\t\t}\n\n\t\t \n\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_WRITE) {\n\t\t\treset_psn(qp, qp->s_last_psn + 1);\n\t\t} else {\n\t\t\tupdate_last_psn(qp, psn - 1);\n\t\t\treset_psn(qp, psn);\n\t\t}\n\n\t\tibp->rvp.n_rc_resends += delta_psn(qp->s_psn, psn);\n\t\tqp->s_flags &= ~(RVT_S_WAIT_SSN_CREDIT | RVT_S_WAIT_ACK);\n\t\trvt_stop_rc_timers(qp);\n\t\trvt_add_rnr_timer(qp, aeth);\n\t\treturn 0;\n\n\tcase 3:          \n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tgoto bail_stop;\n\t\t \n\t\tupdate_last_psn(qp, psn - 1);\n\t\tswitch ((aeth >> IB_AETH_CREDIT_SHIFT) &\n\t\t\tIB_AETH_CREDIT_MASK) {\n\t\tcase 0:  \n\t\t\tibp->rvp.n_seq_naks++;\n\t\t\t \n\t\t\thfi1_restart_rc(qp, psn, 0);\n\t\t\thfi1_schedule_send(qp);\n\t\t\tbreak;\n\n\t\tcase 1:  \n\t\t\tstatus = IB_WC_REM_INV_REQ_ERR;\n\t\t\tibp->rvp.n_other_naks++;\n\t\t\tgoto class_b;\n\n\t\tcase 2:  \n\t\t\tstatus = IB_WC_REM_ACCESS_ERR;\n\t\t\tibp->rvp.n_other_naks++;\n\t\t\tgoto class_b;\n\n\t\tcase 3:  \n\t\t\tstatus = IB_WC_REM_OP_ERR;\n\t\t\tibp->rvp.n_other_naks++;\nclass_b:\n\t\t\tif (qp->s_last == qp->s_acked) {\n\t\t\t\tif (wqe->wr.opcode == IB_WR_TID_RDMA_READ)\n\t\t\t\t\thfi1_kern_read_tid_flow_free(qp);\n\n\t\t\t\thfi1_trdma_send_complete(qp, wqe, status);\n\t\t\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tgoto reserved;\n\t\t}\n\t\tqp->s_retry = qp->s_retry_cnt;\n\t\tqp->s_rnr_retry = qp->s_rnr_retry_cnt;\n\t\tgoto bail_stop;\n\n\tdefault:                 \nreserved:\n\t\t \n\t\tgoto bail_stop;\n\t}\n\t \nbail_stop:\n\trvt_stop_rc_timers(qp);\n\treturn ret;\n}\n\n \nstatic void rdma_seq_err(struct rvt_qp *qp, struct hfi1_ibport *ibp, u32 psn,\n\t\t\t struct hfi1_ctxtdata *rcd)\n{\n\tstruct rvt_swqe *wqe;\n\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\trvt_stop_rc_timers(qp);\n\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\n\twhile (cmp_psn(psn, wqe->lpsn) > 0) {\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t    wqe->wr.opcode == IB_WR_TID_RDMA_READ ||\n\t\t    wqe->wr.opcode == IB_WR_TID_RDMA_WRITE ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD)\n\t\t\tbreak;\n\t\twqe = do_rc_completion(qp, wqe, ibp);\n\t}\n\n\tibp->rvp.n_rdma_seq++;\n\tqp->r_flags |= RVT_R_RDMAR_SEQ;\n\thfi1_restart_rc(qp, qp->s_last_psn + 1, 0);\n\tif (list_empty(&qp->rspwait)) {\n\t\tqp->r_flags |= RVT_R_RSP_SEND;\n\t\trvt_get_qp(qp);\n\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t}\n}\n\n \nstatic void rc_rcv_resp(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tvoid *data = packet->payload;\n\tu32 tlen = packet->tlen;\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_ibport *ibp;\n\tstruct ib_other_headers *ohdr = packet->ohdr;\n\tstruct rvt_swqe *wqe;\n\tenum ib_wc_status status;\n\tunsigned long flags;\n\tint diff;\n\tu64 val;\n\tu32 aeth;\n\tu32 psn = ib_bth_get_psn(packet->ohdr);\n\tu32 pmtu = qp->pmtu;\n\tu16 hdrsize = packet->hlen;\n\tu8 opcode = packet->opcode;\n\tu8 pad = packet->pad;\n\tu8 extra_bytes = pad + packet->extra_byte + (SIZE_OF_CRC << 2);\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\ttrace_hfi1_ack(qp, psn);\n\n\t \n\tif (cmp_psn(psn, READ_ONCE(qp->s_next_psn)) >= 0)\n\t\tgoto ack_done;\n\n\t \n\tdiff = cmp_psn(psn, qp->s_last_psn);\n\tif (unlikely(diff <= 0)) {\n\t\t \n\t\tif (diff == 0 && opcode == OP(ACKNOWLEDGE)) {\n\t\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\t\tif ((aeth >> IB_AETH_NAK_SHIFT) == 0)\n\t\t\t\trvt_get_credit(qp, aeth);\n\t\t}\n\t\tgoto ack_done;\n\t}\n\n\t \n\tif (qp->r_flags & RVT_R_RDMAR_SEQ) {\n\t\tif (cmp_psn(psn, qp->s_last_psn + 1) != 0)\n\t\t\tgoto ack_done;\n\t\tqp->r_flags &= ~RVT_R_RDMAR_SEQ;\n\t}\n\n\tif (unlikely(qp->s_acked == qp->s_tail))\n\t\tgoto ack_done;\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tstatus = IB_WC_SUCCESS;\n\n\tswitch (opcode) {\n\tcase OP(ACKNOWLEDGE):\n\tcase OP(ATOMIC_ACKNOWLEDGE):\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\tif (opcode == OP(ATOMIC_ACKNOWLEDGE))\n\t\t\tval = ib_u64_get(&ohdr->u.at.atomic_ack_eth);\n\t\telse\n\t\t\tval = 0;\n\t\tif (!do_rc_ack(qp, aeth, psn, opcode, val, rcd) ||\n\t\t    opcode != OP(RDMA_READ_RESPONSE_FIRST))\n\t\t\tgoto ack_done;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\n\t\t \n\t\tqp->s_rdma_read_len = restart_sge(&qp->s_rdma_read_sge,\n\t\t\t\t\t\t  wqe, psn, pmtu);\n\t\tgoto read_middle;\n\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\t \n\t\tif (unlikely(cmp_psn(psn, qp->s_last_psn + 1)))\n\t\t\tgoto ack_seq_err;\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\nread_middle:\n\t\tif (unlikely(tlen != (hdrsize + pmtu + extra_bytes)))\n\t\t\tgoto ack_len_err;\n\t\tif (unlikely(pmtu >= qp->s_rdma_read_len))\n\t\t\tgoto ack_len_err;\n\n\t\t \n\t\trvt_mod_retry_timer(qp);\n\t\tif (qp->s_flags & RVT_S_WAIT_ACK) {\n\t\t\tqp->s_flags &= ~RVT_S_WAIT_ACK;\n\t\t\thfi1_schedule_send(qp);\n\t\t}\n\n\t\tif (opcode == OP(RDMA_READ_RESPONSE_MIDDLE))\n\t\t\tqp->s_retry = qp->s_retry_cnt;\n\n\t\t \n\t\tqp->s_rdma_read_len -= pmtu;\n\t\tupdate_last_psn(qp, psn);\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\trvt_copy_sge(qp, &qp->s_rdma_read_sge,\n\t\t\t     data, pmtu, false, false);\n\t\tgoto bail;\n\n\tcase OP(RDMA_READ_RESPONSE_ONLY):\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\tif (!do_rc_ack(qp, aeth, psn, opcode, 0, rcd))\n\t\t\tgoto ack_done;\n\t\t \n\t\tif (unlikely(tlen < (hdrsize + extra_bytes)))\n\t\t\tgoto ack_len_err;\n\t\t \n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t\tqp->s_rdma_read_len = restart_sge(&qp->s_rdma_read_sge,\n\t\t\t\t\t\t  wqe, psn, pmtu);\n\t\tgoto read_last;\n\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\t\t \n\t\tif (unlikely(cmp_psn(psn, qp->s_last_psn + 1)))\n\t\t\tgoto ack_seq_err;\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\n\t\t \n\t\tif (unlikely(tlen <= (hdrsize + extra_bytes)))\n\t\t\tgoto ack_len_err;\nread_last:\n\t\ttlen -= hdrsize + extra_bytes;\n\t\tif (unlikely(tlen != qp->s_rdma_read_len))\n\t\t\tgoto ack_len_err;\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\trvt_copy_sge(qp, &qp->s_rdma_read_sge,\n\t\t\t     data, tlen, false, false);\n\t\tWARN_ON(qp->s_rdma_read_sge.num_sge);\n\t\t(void)do_rc_ack(qp, aeth, psn,\n\t\t\t\t OP(RDMA_READ_RESPONSE_LAST), 0, rcd);\n\t\tgoto ack_done;\n\t}\n\nack_op_err:\n\tstatus = IB_WC_LOC_QP_OP_ERR;\n\tgoto ack_err;\n\nack_seq_err:\n\tibp = rcd_to_iport(rcd);\n\trdma_seq_err(qp, ibp, psn, rcd);\n\tgoto ack_done;\n\nack_len_err:\n\tstatus = IB_WC_LOC_LEN_ERR;\nack_err:\n\tif (qp->s_last == qp->s_acked) {\n\t\trvt_send_complete(qp, wqe, status);\n\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t}\nack_done:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nbail:\n\treturn;\n}\n\nstatic inline void rc_cancel_ack(struct rvt_qp *qp)\n{\n\tqp->r_adefered = 0;\n\tif (list_empty(&qp->rspwait))\n\t\treturn;\n\tlist_del_init(&qp->rspwait);\n\tqp->r_flags &= ~RVT_R_RSP_NAK;\n\trvt_put_qp(qp);\n}\n\n \nstatic noinline int rc_rcv_error(struct ib_other_headers *ohdr, void *data,\n\t\t\t\t struct rvt_qp *qp, u32 opcode, u32 psn,\n\t\t\t\t int diff, struct hfi1_ctxtdata *rcd)\n{\n\tstruct hfi1_ibport *ibp = rcd_to_iport(rcd);\n\tstruct rvt_ack_entry *e;\n\tunsigned long flags;\n\tu8 prev;\n\tu8 mra;  \n\tbool old_req;\n\n\ttrace_hfi1_rcv_error(qp, psn);\n\tif (diff > 0) {\n\t\t \n\t\tif (!qp->r_nak_state) {\n\t\t\tibp->rvp.n_rc_seqnak++;\n\t\t\tqp->r_nak_state = IB_NAK_PSN_ERROR;\n\t\t\t \n\t\t\tqp->r_ack_psn = qp->r_psn;\n\t\t\t \n\t\t\trc_defered_ack(rcd, qp);\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\te = NULL;\n\told_req = true;\n\tibp->rvp.n_rc_dupreq++;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\n\te = find_prev_entry(qp, psn, &prev, &mra, &old_req);\n\n\tswitch (opcode) {\n\tcase OP(RDMA_READ_REQUEST): {\n\t\tstruct ib_reth *reth;\n\t\tu32 offset;\n\t\tu32 len;\n\n\t\t \n\t\tif (!e || e->opcode != OP(RDMA_READ_REQUEST))\n\t\t\tgoto unlock_done;\n\t\t \n\t\treth = &ohdr->u.rc.reth;\n\t\t \n\t\toffset = delta_psn(psn, e->psn) * qp->pmtu;\n\t\tlen = be32_to_cpu(reth->length);\n\t\tif (unlikely(offset + len != e->rdma_sge.sge_length))\n\t\t\tgoto unlock_done;\n\t\trelease_rdma_sge_mr(e);\n\t\tif (len != 0) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = get_ib_reth_vaddr(reth);\n\t\t\tint ok;\n\n\t\t\tok = rvt_rkey_ok(qp, &e->rdma_sge, len, vaddr, rkey,\n\t\t\t\t\t IB_ACCESS_REMOTE_READ);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto unlock_done;\n\t\t} else {\n\t\t\te->rdma_sge.vaddr = NULL;\n\t\t\te->rdma_sge.length = 0;\n\t\t\te->rdma_sge.sge_length = 0;\n\t\t}\n\t\te->psn = psn;\n\t\tif (old_req)\n\t\t\tgoto unlock_done;\n\t\tif (qp->s_acked_ack_queue == qp->s_tail_ack_queue)\n\t\t\tqp->s_acked_ack_queue = prev;\n\t\tqp->s_tail_ack_queue = prev;\n\t\tbreak;\n\t}\n\n\tcase OP(COMPARE_SWAP):\n\tcase OP(FETCH_ADD): {\n\t\t \n\t\tif (!e || e->opcode != (u8)opcode || old_req)\n\t\t\tgoto unlock_done;\n\t\tif (qp->s_tail_ack_queue == qp->s_acked_ack_queue)\n\t\t\tqp->s_acked_ack_queue = prev;\n\t\tqp->s_tail_ack_queue = prev;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\tif (!(psn & IB_BTH_REQ_ACK) || old_req)\n\t\t\tgoto unlock_done;\n\t\t \n\t\tif (mra == qp->r_head_ack_queue) {\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t\tqp->r_nak_state = 0;\n\t\t\tqp->r_ack_psn = qp->r_psn - 1;\n\t\t\tgoto send_ack;\n\t\t}\n\n\t\t \n\t\tif (qp->s_tail_ack_queue == qp->s_acked_ack_queue)\n\t\t\tqp->s_acked_ack_queue = mra;\n\t\tqp->s_tail_ack_queue = mra;\n\t\tbreak;\n\t}\n\tqp->s_ack_state = OP(ACKNOWLEDGE);\n\tqp->s_flags |= RVT_S_RESP_PENDING;\n\tqp->r_nak_state = 0;\n\thfi1_schedule_send(qp);\n\nunlock_done:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\ndone:\n\treturn 1;\n\nsend_ack:\n\treturn 0;\n}\n\nstatic void log_cca_event(struct hfi1_pportdata *ppd, u8 sl, u32 rlid,\n\t\t\t  u32 lqpn, u32 rqpn, u8 svc_type)\n{\n\tstruct opa_hfi1_cong_log_event_internal *cc_event;\n\tunsigned long flags;\n\n\tif (sl >= OPA_MAX_SLS)\n\t\treturn;\n\n\tspin_lock_irqsave(&ppd->cc_log_lock, flags);\n\n\tppd->threshold_cong_event_map[sl / 8] |= 1 << (sl % 8);\n\tppd->threshold_event_counter++;\n\n\tcc_event = &ppd->cc_events[ppd->cc_log_idx++];\n\tif (ppd->cc_log_idx == OPA_CONG_LOG_ELEMS)\n\t\tppd->cc_log_idx = 0;\n\tcc_event->lqpn = lqpn & RVT_QPN_MASK;\n\tcc_event->rqpn = rqpn & RVT_QPN_MASK;\n\tcc_event->sl = sl;\n\tcc_event->svc_type = svc_type;\n\tcc_event->rlid = rlid;\n\t \n\tcc_event->timestamp = ktime_get_ns() / 1024;\n\n\tspin_unlock_irqrestore(&ppd->cc_log_lock, flags);\n}\n\nvoid process_becn(struct hfi1_pportdata *ppd, u8 sl, u32 rlid, u32 lqpn,\n\t\t  u32 rqpn, u8 svc_type)\n{\n\tstruct cca_timer *cca_timer;\n\tu16 ccti, ccti_incr, ccti_timer, ccti_limit;\n\tu8 trigger_threshold;\n\tstruct cc_state *cc_state;\n\tunsigned long flags;\n\n\tif (sl >= OPA_MAX_SLS)\n\t\treturn;\n\n\tcc_state = get_cc_state(ppd);\n\n\tif (!cc_state)\n\t\treturn;\n\n\t \n\tccti_limit = cc_state->cct.ccti_limit;\n\tccti_incr = cc_state->cong_setting.entries[sl].ccti_increase;\n\tccti_timer = cc_state->cong_setting.entries[sl].ccti_timer;\n\ttrigger_threshold =\n\t\tcc_state->cong_setting.entries[sl].trigger_threshold;\n\n\tspin_lock_irqsave(&ppd->cca_timer_lock, flags);\n\n\tcca_timer = &ppd->cca_timer[sl];\n\tif (cca_timer->ccti < ccti_limit) {\n\t\tif (cca_timer->ccti + ccti_incr <= ccti_limit)\n\t\t\tcca_timer->ccti += ccti_incr;\n\t\telse\n\t\t\tcca_timer->ccti = ccti_limit;\n\t\tset_link_ipg(ppd);\n\t}\n\n\tccti = cca_timer->ccti;\n\n\tif (!hrtimer_active(&cca_timer->hrtimer)) {\n\t\t \n\t\tunsigned long nsec = 1024 * ccti_timer;\n\n\t\thrtimer_start(&cca_timer->hrtimer, ns_to_ktime(nsec),\n\t\t\t      HRTIMER_MODE_REL_PINNED);\n\t}\n\n\tspin_unlock_irqrestore(&ppd->cca_timer_lock, flags);\n\n\tif ((trigger_threshold != 0) && (ccti >= trigger_threshold))\n\t\tlog_cca_event(ppd, sl, rlid, lqpn, rqpn, svc_type);\n}\n\n \nvoid hfi1_rc_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_ctxtdata *rcd = packet->rcd;\n\tvoid *data = packet->payload;\n\tu32 tlen = packet->tlen;\n\tstruct rvt_qp *qp = packet->qp;\n\tstruct hfi1_qp_priv *qpriv = qp->priv;\n\tstruct hfi1_ibport *ibp = rcd_to_iport(rcd);\n\tstruct ib_other_headers *ohdr = packet->ohdr;\n\tu32 opcode = packet->opcode;\n\tu32 hdrsize = packet->hlen;\n\tu32 psn = ib_bth_get_psn(packet->ohdr);\n\tu32 pad = packet->pad;\n\tstruct ib_wc wc;\n\tu32 pmtu = qp->pmtu;\n\tint diff;\n\tstruct ib_reth *reth;\n\tunsigned long flags;\n\tint ret;\n\tbool copy_last = false, fecn;\n\tu32 rkey;\n\tu8 extra_bytes = pad + packet->extra_byte + (SIZE_OF_CRC << 2);\n\n\tlockdep_assert_held(&qp->r_lock);\n\n\tif (hfi1_ruc_check_hdr(ibp, packet))\n\t\treturn;\n\n\tfecn = process_ecn(qp, packet);\n\topfn_trigger_conn_request(qp, be32_to_cpu(ohdr->bth[1]));\n\n\t \n\tif (opcode >= OP(RDMA_READ_RESPONSE_FIRST) &&\n\t    opcode <= OP(ATOMIC_ACKNOWLEDGE)) {\n\t\trc_rcv_resp(packet);\n\t\treturn;\n\t}\n\n\t \n\tdiff = delta_psn(psn, qp->r_psn);\n\tif (unlikely(diff)) {\n\t\tif (rc_rcv_error(ohdr, data, qp, opcode, psn, diff, rcd))\n\t\t\treturn;\n\t\tgoto send_ack;\n\t}\n\n\t \n\tswitch (qp->r_state) {\n\tcase OP(SEND_FIRST):\n\tcase OP(SEND_MIDDLE):\n\t\tif (opcode == OP(SEND_MIDDLE) ||\n\t\t    opcode == OP(SEND_LAST) ||\n\t\t    opcode == OP(SEND_LAST_WITH_IMMEDIATE) ||\n\t\t    opcode == OP(SEND_LAST_WITH_INVALIDATE))\n\t\t\tbreak;\n\t\tgoto nack_inv;\n\n\tcase OP(RDMA_WRITE_FIRST):\n\tcase OP(RDMA_WRITE_MIDDLE):\n\t\tif (opcode == OP(RDMA_WRITE_MIDDLE) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\n\t\t\tbreak;\n\t\tgoto nack_inv;\n\n\tdefault:\n\t\tif (opcode == OP(SEND_MIDDLE) ||\n\t\t    opcode == OP(SEND_LAST) ||\n\t\t    opcode == OP(SEND_LAST_WITH_IMMEDIATE) ||\n\t\t    opcode == OP(SEND_LAST_WITH_INVALIDATE) ||\n\t\t    opcode == OP(RDMA_WRITE_MIDDLE) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\n\t\t\tgoto nack_inv;\n\t\t \n\t\tbreak;\n\t}\n\n\tif (qp->state == IB_QPS_RTR && !(qp->r_flags & RVT_R_COMM_EST))\n\t\trvt_comm_est(qp);\n\n\t \n\tswitch (opcode) {\n\tcase OP(SEND_FIRST):\n\t\tret = rvt_get_rwqe(qp, false);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tqp->r_rcv_len = 0;\n\t\tfallthrough;\n\tcase OP(SEND_MIDDLE):\n\tcase OP(RDMA_WRITE_MIDDLE):\nsend_middle:\n\t\t \n\t\t \n\t\tif (unlikely(tlen != (hdrsize + pmtu + extra_bytes)))\n\t\t\tgoto nack_inv;\n\t\tqp->r_rcv_len += pmtu;\n\t\tif (unlikely(qp->r_rcv_len > qp->r_len))\n\t\t\tgoto nack_inv;\n\t\trvt_copy_sge(qp, &qp->r_sge, data, pmtu, true, false);\n\t\tbreak;\n\n\tcase OP(RDMA_WRITE_LAST_WITH_IMMEDIATE):\n\t\t \n\t\tret = rvt_get_rwqe(qp, true);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tgoto send_last_imm;\n\n\tcase OP(SEND_ONLY):\n\tcase OP(SEND_ONLY_WITH_IMMEDIATE):\n\tcase OP(SEND_ONLY_WITH_INVALIDATE):\n\t\tret = rvt_get_rwqe(qp, false);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tqp->r_rcv_len = 0;\n\t\tif (opcode == OP(SEND_ONLY))\n\t\t\tgoto no_immediate_data;\n\t\tif (opcode == OP(SEND_ONLY_WITH_INVALIDATE))\n\t\t\tgoto send_last_inv;\n\t\tfallthrough;\t \n\tcase OP(SEND_LAST_WITH_IMMEDIATE):\nsend_last_imm:\n\t\twc.ex.imm_data = ohdr->u.imm_data;\n\t\twc.wc_flags = IB_WC_WITH_IMM;\n\t\tgoto send_last;\n\tcase OP(SEND_LAST_WITH_INVALIDATE):\nsend_last_inv:\n\t\trkey = be32_to_cpu(ohdr->u.ieth);\n\t\tif (rvt_invalidate_rkey(qp, rkey))\n\t\t\tgoto no_immediate_data;\n\t\twc.ex.invalidate_rkey = rkey;\n\t\twc.wc_flags = IB_WC_WITH_INVALIDATE;\n\t\tgoto send_last;\n\tcase OP(RDMA_WRITE_LAST):\n\t\tcopy_last = rvt_is_user_qp(qp);\n\t\tfallthrough;\n\tcase OP(SEND_LAST):\nno_immediate_data:\n\t\twc.wc_flags = 0;\n\t\twc.ex.imm_data = 0;\nsend_last:\n\t\t \n\t\t \n\t\tif (unlikely(tlen < (hdrsize + extra_bytes)))\n\t\t\tgoto nack_inv;\n\t\t \n\t\ttlen -= (hdrsize + extra_bytes);\n\t\twc.byte_len = tlen + qp->r_rcv_len;\n\t\tif (unlikely(wc.byte_len > qp->r_len))\n\t\t\tgoto nack_inv;\n\t\trvt_copy_sge(qp, &qp->r_sge, data, tlen, true, copy_last);\n\t\trvt_put_ss(&qp->r_sge);\n\t\tqp->r_msn++;\n\t\tif (!__test_and_clear_bit(RVT_R_WRID_VALID, &qp->r_aflags))\n\t\t\tbreak;\n\t\twc.wr_id = qp->r_wr_id;\n\t\twc.status = IB_WC_SUCCESS;\n\t\tif (opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE) ||\n\t\t    opcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE))\n\t\t\twc.opcode = IB_WC_RECV_RDMA_WITH_IMM;\n\t\telse\n\t\t\twc.opcode = IB_WC_RECV;\n\t\twc.qp = &qp->ibqp;\n\t\twc.src_qp = qp->remote_qpn;\n\t\twc.slid = rdma_ah_get_dlid(&qp->remote_ah_attr) & U16_MAX;\n\t\t \n\t\twc.sl = rdma_ah_get_sl(&qp->remote_ah_attr);\n\t\t \n\t\twc.vendor_err = 0;\n\t\twc.pkey_index = 0;\n\t\twc.dlid_path_bits = 0;\n\t\twc.port_num = 0;\n\t\t \n\t\trvt_recv_cq(qp, &wc, ib_bth_is_solicited(ohdr));\n\t\tbreak;\n\n\tcase OP(RDMA_WRITE_ONLY):\n\t\tcopy_last = rvt_is_user_qp(qp);\n\t\tfallthrough;\n\tcase OP(RDMA_WRITE_FIRST):\n\tcase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_WRITE)))\n\t\t\tgoto nack_inv;\n\t\t \n\t\treth = &ohdr->u.rc.reth;\n\t\tqp->r_len = be32_to_cpu(reth->length);\n\t\tqp->r_rcv_len = 0;\n\t\tqp->r_sge.sg_list = NULL;\n\t\tif (qp->r_len != 0) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = get_ib_reth_vaddr(reth);\n\t\t\tint ok;\n\n\t\t\t \n\t\t\tok = rvt_rkey_ok(qp, &qp->r_sge.sge, qp->r_len, vaddr,\n\t\t\t\t\t rkey, IB_ACCESS_REMOTE_WRITE);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto nack_acc;\n\t\t\tqp->r_sge.num_sge = 1;\n\t\t} else {\n\t\t\tqp->r_sge.num_sge = 0;\n\t\t\tqp->r_sge.sge.mr = NULL;\n\t\t\tqp->r_sge.sge.vaddr = NULL;\n\t\t\tqp->r_sge.sge.length = 0;\n\t\t\tqp->r_sge.sge.sge_length = 0;\n\t\t}\n\t\tif (opcode == OP(RDMA_WRITE_FIRST))\n\t\t\tgoto send_middle;\n\t\telse if (opcode == OP(RDMA_WRITE_ONLY))\n\t\t\tgoto no_immediate_data;\n\t\tret = rvt_get_rwqe(qp, true);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret) {\n\t\t\t \n\t\t\trvt_put_ss(&qp->r_sge);\n\t\t\tgoto rnr_nak;\n\t\t}\n\t\twc.ex.imm_data = ohdr->u.rc.imm_data;\n\t\twc.wc_flags = IB_WC_WITH_IMM;\n\t\tgoto send_last;\n\n\tcase OP(RDMA_READ_REQUEST): {\n\t\tstruct rvt_ack_entry *e;\n\t\tu32 len;\n\t\tu8 next;\n\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_READ)))\n\t\t\tgoto nack_inv;\n\t\tnext = qp->r_head_ack_queue + 1;\n\t\t \n\t\tif (next > rvt_size_atomic(ib_to_rvt(qp->ibqp.device)))\n\t\t\tnext = 0;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tif (unlikely(next == qp->s_acked_ack_queue)) {\n\t\t\tif (!qp->s_ack_queue[next].sent)\n\t\t\t\tgoto nack_inv_unlck;\n\t\t\tupdate_ack_queue(qp, next);\n\t\t}\n\t\te = &qp->s_ack_queue[qp->r_head_ack_queue];\n\t\trelease_rdma_sge_mr(e);\n\t\treth = &ohdr->u.rc.reth;\n\t\tlen = be32_to_cpu(reth->length);\n\t\tif (len) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = get_ib_reth_vaddr(reth);\n\t\t\tint ok;\n\n\t\t\t \n\t\t\tok = rvt_rkey_ok(qp, &e->rdma_sge, len, vaddr,\n\t\t\t\t\t rkey, IB_ACCESS_REMOTE_READ);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto nack_acc_unlck;\n\t\t\t \n\t\t\tqp->r_psn += rvt_div_mtu(qp, len - 1);\n\t\t} else {\n\t\t\te->rdma_sge.mr = NULL;\n\t\t\te->rdma_sge.vaddr = NULL;\n\t\t\te->rdma_sge.length = 0;\n\t\t\te->rdma_sge.sge_length = 0;\n\t\t}\n\t\te->opcode = opcode;\n\t\te->sent = 0;\n\t\te->psn = psn;\n\t\te->lpsn = qp->r_psn;\n\t\t \n\t\tqp->r_msn++;\n\t\tqp->r_psn++;\n\t\tqp->r_state = opcode;\n\t\tqp->r_nak_state = 0;\n\t\tqp->r_head_ack_queue = next;\n\t\tqpriv->r_tid_alloc = qp->r_head_ack_queue;\n\n\t\t \n\t\tqp->s_flags |= RVT_S_RESP_PENDING;\n\t\tif (fecn)\n\t\t\tqp->s_flags |= RVT_S_ECN;\n\t\thfi1_schedule_send(qp);\n\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\treturn;\n\t}\n\n\tcase OP(COMPARE_SWAP):\n\tcase OP(FETCH_ADD): {\n\t\tstruct ib_atomic_eth *ateth = &ohdr->u.atomic_eth;\n\t\tu64 vaddr = get_ib_ateth_vaddr(ateth);\n\t\tbool opfn = opcode == OP(COMPARE_SWAP) &&\n\t\t\tvaddr == HFI1_VERBS_E_ATOMIC_VADDR;\n\t\tstruct rvt_ack_entry *e;\n\t\tatomic64_t *maddr;\n\t\tu64 sdata;\n\t\tu32 rkey;\n\t\tu8 next;\n\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC) &&\n\t\t\t     !opfn))\n\t\t\tgoto nack_inv;\n\t\tnext = qp->r_head_ack_queue + 1;\n\t\tif (next > rvt_size_atomic(ib_to_rvt(qp->ibqp.device)))\n\t\t\tnext = 0;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tif (unlikely(next == qp->s_acked_ack_queue)) {\n\t\t\tif (!qp->s_ack_queue[next].sent)\n\t\t\t\tgoto nack_inv_unlck;\n\t\t\tupdate_ack_queue(qp, next);\n\t\t}\n\t\te = &qp->s_ack_queue[qp->r_head_ack_queue];\n\t\trelease_rdma_sge_mr(e);\n\t\t \n\t\tif (opfn) {\n\t\t\topfn_conn_response(qp, e, ateth);\n\t\t\tgoto ack;\n\t\t}\n\t\tif (unlikely(vaddr & (sizeof(u64) - 1)))\n\t\t\tgoto nack_inv_unlck;\n\t\trkey = be32_to_cpu(ateth->rkey);\n\t\t \n\t\tif (unlikely(!rvt_rkey_ok(qp, &qp->r_sge.sge, sizeof(u64),\n\t\t\t\t\t  vaddr, rkey,\n\t\t\t\t\t  IB_ACCESS_REMOTE_ATOMIC)))\n\t\t\tgoto nack_acc_unlck;\n\t\t \n\t\tmaddr = (atomic64_t *)qp->r_sge.sge.vaddr;\n\t\tsdata = get_ib_ateth_swap(ateth);\n\t\te->atomic_data = (opcode == OP(FETCH_ADD)) ?\n\t\t\t(u64)atomic64_add_return(sdata, maddr) - sdata :\n\t\t\t(u64)cmpxchg((u64 *)qp->r_sge.sge.vaddr,\n\t\t\t\t      get_ib_ateth_compare(ateth),\n\t\t\t\t      sdata);\n\t\trvt_put_mr(qp->r_sge.sge.mr);\n\t\tqp->r_sge.num_sge = 0;\nack:\n\t\te->opcode = opcode;\n\t\te->sent = 0;\n\t\te->psn = psn;\n\t\te->lpsn = psn;\n\t\tqp->r_msn++;\n\t\tqp->r_psn++;\n\t\tqp->r_state = opcode;\n\t\tqp->r_nak_state = 0;\n\t\tqp->r_head_ack_queue = next;\n\t\tqpriv->r_tid_alloc = qp->r_head_ack_queue;\n\n\t\t \n\t\tqp->s_flags |= RVT_S_RESP_PENDING;\n\t\tif (fecn)\n\t\t\tqp->s_flags |= RVT_S_ECN;\n\t\thfi1_schedule_send(qp);\n\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\treturn;\n\t}\n\n\tdefault:\n\t\t \n\t\tgoto nack_inv;\n\t}\n\tqp->r_psn++;\n\tqp->r_state = opcode;\n\tqp->r_ack_psn = psn;\n\tqp->r_nak_state = 0;\n\t \n\tif (psn & IB_BTH_REQ_ACK || fecn) {\n\t\tif (packet->numpkt == 0 || fecn ||\n\t\t    qp->r_adefered >= HFI1_PSN_CREDIT) {\n\t\t\trc_cancel_ack(qp);\n\t\t\tgoto send_ack;\n\t\t}\n\t\tqp->r_adefered++;\n\t\trc_defered_ack(rcd, qp);\n\t}\n\treturn;\n\nrnr_nak:\n\tqp->r_nak_state = qp->r_min_rnr_timer | IB_RNR_NAK;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\trc_defered_ack(rcd, qp);\n\treturn;\n\nnack_op_err:\n\trvt_rc_error(qp, IB_WC_LOC_QP_OP_ERR);\n\tqp->r_nak_state = IB_NAK_REMOTE_OPERATIONAL_ERROR;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\trc_defered_ack(rcd, qp);\n\treturn;\n\nnack_inv_unlck:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nnack_inv:\n\trvt_rc_error(qp, IB_WC_LOC_QP_OP_ERR);\n\tqp->r_nak_state = IB_NAK_INVALID_REQUEST;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\trc_defered_ack(rcd, qp);\n\treturn;\n\nnack_acc_unlck:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nnack_acc:\n\trvt_rc_error(qp, IB_WC_LOC_PROT_ERR);\n\tqp->r_nak_state = IB_NAK_REMOTE_ACCESS_ERROR;\n\tqp->r_ack_psn = qp->r_psn;\nsend_ack:\n\thfi1_send_rc_ack(packet, fecn);\n}\n\nvoid hfi1_rc_hdrerr(\n\tstruct hfi1_ctxtdata *rcd,\n\tstruct hfi1_packet *packet,\n\tstruct rvt_qp *qp)\n{\n\tstruct hfi1_ibport *ibp = rcd_to_iport(rcd);\n\tint diff;\n\tu32 opcode;\n\tu32 psn;\n\n\tif (hfi1_ruc_check_hdr(ibp, packet))\n\t\treturn;\n\n\tpsn = ib_bth_get_psn(packet->ohdr);\n\topcode = ib_bth_get_opcode(packet->ohdr);\n\n\t \n\tif (opcode < IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST) {\n\t\tdiff = delta_psn(psn, qp->r_psn);\n\t\tif (!qp->r_nak_state && diff >= 0) {\n\t\t\tibp->rvp.n_rc_seqnak++;\n\t\t\tqp->r_nak_state = IB_NAK_PSN_ERROR;\n\t\t\t \n\t\t\tqp->r_ack_psn = qp->r_psn;\n\t\t\t \n\t\t\trc_defered_ack(rcd, qp);\n\t\t}  \n\t}  \n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}