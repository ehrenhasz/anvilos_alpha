{
  "module_name": "vnic_main.c",
  "hash_id": "ebed3db7ce9de5c312478e989720554f2b39ed8583f2bdbda8b2966c00470d53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/vnic_main.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/io.h>\n#include <linux/if_vlan.h>\n\n#include \"vnic.h\"\n#include \"netdev.h\"\n\n#define HFI_TX_TIMEOUT_MS 1000\n\n#define HFI1_VNIC_RCV_Q_SIZE   1024\n\n#define HFI1_VNIC_UP 0\n\nstatic DEFINE_SPINLOCK(vport_cntr_lock);\n\n#define SUM_GRP_COUNTERS(stats, qstats, x_grp) do {            \\\n\t\tu64 *src64, *dst64;                            \\\n\t\tfor (src64 = &qstats->x_grp.unicast,           \\\n\t\t\tdst64 = &stats->x_grp.unicast;         \\\n\t\t\tdst64 <= &stats->x_grp.s_1519_max;) {  \\\n\t\t\t*dst64++ += *src64++;                  \\\n\t\t}                                              \\\n\t} while (0)\n\n#define VNIC_MASK (0xFF)\n#define VNIC_ID(val) ((1ull << 24) | ((val) & VNIC_MASK))\n\n \nstatic void hfi1_vnic_update_stats(struct hfi1_vnic_vport_info *vinfo,\n\t\t\t\t   struct opa_vnic_stats *stats)\n{\n\tstruct net_device *netdev = vinfo->netdev;\n\tu8 i;\n\n\t \n\tfor (i = 0; i < vinfo->num_tx_q; i++) {\n\t\tstruct opa_vnic_stats *qstats = &vinfo->stats[i];\n\t\tstruct rtnl_link_stats64 *qnstats = &vinfo->stats[i].netstats;\n\n\t\tstats->netstats.tx_fifo_errors += qnstats->tx_fifo_errors;\n\t\tstats->netstats.tx_carrier_errors += qnstats->tx_carrier_errors;\n\t\tstats->tx_drop_state += qstats->tx_drop_state;\n\t\tstats->tx_dlid_zero += qstats->tx_dlid_zero;\n\n\t\tSUM_GRP_COUNTERS(stats, qstats, tx_grp);\n\t\tstats->netstats.tx_packets += qnstats->tx_packets;\n\t\tstats->netstats.tx_bytes += qnstats->tx_bytes;\n\t}\n\n\t \n\tfor (i = 0; i < vinfo->num_rx_q; i++) {\n\t\tstruct opa_vnic_stats *qstats = &vinfo->stats[i];\n\t\tstruct rtnl_link_stats64 *qnstats = &vinfo->stats[i].netstats;\n\n\t\tstats->netstats.rx_fifo_errors += qnstats->rx_fifo_errors;\n\t\tstats->netstats.rx_nohandler += qnstats->rx_nohandler;\n\t\tstats->rx_drop_state += qstats->rx_drop_state;\n\t\tstats->rx_oversize += qstats->rx_oversize;\n\t\tstats->rx_runt += qstats->rx_runt;\n\n\t\tSUM_GRP_COUNTERS(stats, qstats, rx_grp);\n\t\tstats->netstats.rx_packets += qnstats->rx_packets;\n\t\tstats->netstats.rx_bytes += qnstats->rx_bytes;\n\t}\n\n\tstats->netstats.tx_errors = stats->netstats.tx_fifo_errors +\n\t\t\t\t    stats->netstats.tx_carrier_errors +\n\t\t\t\t    stats->tx_drop_state + stats->tx_dlid_zero;\n\tstats->netstats.tx_dropped = stats->netstats.tx_errors;\n\n\tstats->netstats.rx_errors = stats->netstats.rx_fifo_errors +\n\t\t\t\t    stats->netstats.rx_nohandler +\n\t\t\t\t    stats->rx_drop_state + stats->rx_oversize +\n\t\t\t\t    stats->rx_runt;\n\tstats->netstats.rx_dropped = stats->netstats.rx_errors;\n\n\tnetdev->stats.tx_packets = stats->netstats.tx_packets;\n\tnetdev->stats.tx_bytes = stats->netstats.tx_bytes;\n\tnetdev->stats.tx_fifo_errors = stats->netstats.tx_fifo_errors;\n\tnetdev->stats.tx_carrier_errors = stats->netstats.tx_carrier_errors;\n\tnetdev->stats.tx_errors = stats->netstats.tx_errors;\n\tnetdev->stats.tx_dropped = stats->netstats.tx_dropped;\n\n\tnetdev->stats.rx_packets = stats->netstats.rx_packets;\n\tnetdev->stats.rx_bytes = stats->netstats.rx_bytes;\n\tnetdev->stats.rx_fifo_errors = stats->netstats.rx_fifo_errors;\n\tnetdev->stats.multicast = stats->rx_grp.mcastbcast;\n\tnetdev->stats.rx_length_errors = stats->rx_oversize + stats->rx_runt;\n\tnetdev->stats.rx_errors = stats->netstats.rx_errors;\n\tnetdev->stats.rx_dropped = stats->netstats.rx_dropped;\n}\n\n \nstatic inline void update_len_counters(struct opa_vnic_grp_stats *grp,\n\t\t\t\t       int len)\n{\n\t \n\tif (len >= 1515)\n\t\tgrp->s_1519_max++;\n\telse if (len >= 1020)\n\t\tgrp->s_1024_1518++;\n\telse if (len >= 508)\n\t\tgrp->s_512_1023++;\n\telse if (len >= 252)\n\t\tgrp->s_256_511++;\n\telse if (len >= 124)\n\t\tgrp->s_128_255++;\n\telse if (len >= 61)\n\t\tgrp->s_65_127++;\n\telse\n\t\tgrp->s_64++;\n}\n\n \nstatic void hfi1_vnic_update_tx_counters(struct hfi1_vnic_vport_info *vinfo,\n\t\t\t\t\t u8 q_idx, struct sk_buff *skb, int err)\n{\n\tstruct ethhdr *mac_hdr = (struct ethhdr *)skb_mac_header(skb);\n\tstruct opa_vnic_stats *stats = &vinfo->stats[q_idx];\n\tstruct opa_vnic_grp_stats *tx_grp = &stats->tx_grp;\n\tu16 vlan_tci;\n\n\tstats->netstats.tx_packets++;\n\tstats->netstats.tx_bytes += skb->len + ETH_FCS_LEN;\n\n\tupdate_len_counters(tx_grp, skb->len);\n\n\t \n\tif (unlikely(err))\n\t\treturn;\n\n\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\ttx_grp->mcastbcast++;\n\telse\n\t\ttx_grp->unicast++;\n\n\tif (!__vlan_get_tag(skb, &vlan_tci))\n\t\ttx_grp->vlan++;\n\telse\n\t\ttx_grp->untagged++;\n}\n\n \nstatic void hfi1_vnic_update_rx_counters(struct hfi1_vnic_vport_info *vinfo,\n\t\t\t\t\t u8 q_idx, struct sk_buff *skb, int err)\n{\n\tstruct ethhdr *mac_hdr = (struct ethhdr *)skb->data;\n\tstruct opa_vnic_stats *stats = &vinfo->stats[q_idx];\n\tstruct opa_vnic_grp_stats *rx_grp = &stats->rx_grp;\n\tu16 vlan_tci;\n\n\tstats->netstats.rx_packets++;\n\tstats->netstats.rx_bytes += skb->len + ETH_FCS_LEN;\n\n\tupdate_len_counters(rx_grp, skb->len);\n\n\t \n\tif (unlikely(err))\n\t\treturn;\n\n\tif (is_multicast_ether_addr(mac_hdr->h_dest))\n\t\trx_grp->mcastbcast++;\n\telse\n\t\trx_grp->unicast++;\n\n\tif (!__vlan_get_tag(skb, &vlan_tci))\n\t\trx_grp->vlan++;\n\telse\n\t\trx_grp->untagged++;\n}\n\n \nstatic void hfi1_vnic_get_stats64(struct net_device *netdev,\n\t\t\t\t  struct rtnl_link_stats64 *stats)\n{\n\tstruct opa_vnic_stats *vstats = (struct opa_vnic_stats *)stats;\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\n\thfi1_vnic_update_stats(vinfo, vstats);\n}\n\nstatic u64 create_bypass_pbc(u32 vl, u32 dw_len)\n{\n\tu64 pbc;\n\n\tpbc = ((u64)PBC_IHCRC_NONE << PBC_INSERT_HCRC_SHIFT)\n\t\t| PBC_INSERT_BYPASS_ICRC | PBC_CREDIT_RETURN\n\t\t| PBC_PACKET_BYPASS\n\t\t| ((vl & PBC_VL_MASK) << PBC_VL_SHIFT)\n\t\t| (dw_len & PBC_LENGTH_DWS_MASK) << PBC_LENGTH_DWS_SHIFT;\n\n\treturn pbc;\n}\n\n \nstatic void hfi1_vnic_maybe_stop_tx(struct hfi1_vnic_vport_info *vinfo,\n\t\t\t\t    u8 q_idx)\n{\n\tnetif_stop_subqueue(vinfo->netdev, q_idx);\n\tif (!hfi1_vnic_sdma_write_avail(vinfo, q_idx))\n\t\treturn;\n\n\tnetif_start_subqueue(vinfo->netdev, q_idx);\n}\n\nstatic netdev_tx_t hfi1_netdev_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t  struct net_device *netdev)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\tu8 pad_len, q_idx = skb->queue_mapping;\n\tstruct hfi1_devdata *dd = vinfo->dd;\n\tstruct opa_vnic_skb_mdata *mdata;\n\tu32 pkt_len, total_len;\n\tint err = -EINVAL;\n\tu64 pbc;\n\n\tv_dbg(\"xmit: queue %d skb len %d\\n\", q_idx, skb->len);\n\tif (unlikely(!netif_oper_up(netdev))) {\n\t\tvinfo->stats[q_idx].tx_drop_state++;\n\t\tgoto tx_finish;\n\t}\n\n\t \n\tmdata = (struct opa_vnic_skb_mdata *)skb->data;\n\tskb_pull(skb, sizeof(*mdata));\n\tif (unlikely(mdata->flags & OPA_VNIC_SKB_MDATA_ENCAP_ERR)) {\n\t\tvinfo->stats[q_idx].tx_dlid_zero++;\n\t\tgoto tx_finish;\n\t}\n\n\t \n\tpad_len = -(skb->len + OPA_VNIC_ICRC_TAIL_LEN) & 0x7;\n\tpad_len += OPA_VNIC_ICRC_TAIL_LEN;\n\n\t \n\tpkt_len = (skb->len + pad_len) >> 2;\n\ttotal_len = pkt_len + 2;  \n\n\tpbc = create_bypass_pbc(mdata->vl, total_len);\n\n\tskb_get(skb);\n\tv_dbg(\"pbc 0x%016llX len %d pad_len %d\\n\", pbc, skb->len, pad_len);\n\terr = dd->process_vnic_dma_send(dd, q_idx, vinfo, skb, pbc, pad_len);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOMEM)\n\t\t\tvinfo->stats[q_idx].netstats.tx_fifo_errors++;\n\t\telse if (err != -EBUSY)\n\t\t\tvinfo->stats[q_idx].netstats.tx_carrier_errors++;\n\t}\n\t \n\tskb_pull(skb, OPA_VNIC_HDR_LEN);\n\n\tif (unlikely(err == -EBUSY)) {\n\t\thfi1_vnic_maybe_stop_tx(vinfo, q_idx);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\ntx_finish:\n\t \n\thfi1_vnic_update_tx_counters(vinfo, q_idx, skb, err);\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic u16 hfi1_vnic_select_queue(struct net_device *netdev,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct net_device *sb_dev)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\tstruct opa_vnic_skb_mdata *mdata;\n\tstruct sdma_engine *sde;\n\n\tmdata = (struct opa_vnic_skb_mdata *)skb->data;\n\tsde = sdma_select_engine_vl(vinfo->dd, mdata->entropy, mdata->vl);\n\treturn sde->this_idx;\n}\n\n \nstatic inline int hfi1_vnic_decap_skb(struct hfi1_vnic_rx_queue *rxq,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = rxq->vinfo;\n\tint max_len = vinfo->netdev->mtu + VLAN_ETH_HLEN;\n\tint rc = -EFAULT;\n\n\tskb_pull(skb, OPA_VNIC_HDR_LEN);\n\n\t \n\tif (unlikely(skb->len > max_len))\n\t\tvinfo->stats[rxq->idx].rx_oversize++;\n\telse if (unlikely(skb->len < ETH_ZLEN))\n\t\tvinfo->stats[rxq->idx].rx_runt++;\n\telse\n\t\trc = 0;\n\treturn rc;\n}\n\nstatic struct hfi1_vnic_vport_info *get_vnic_port(struct hfi1_devdata *dd,\n\t\t\t\t\t\t  int vesw_id)\n{\n\tint vnic_id = VNIC_ID(vesw_id);\n\n\treturn hfi1_netdev_get_data(dd, vnic_id);\n}\n\nstatic struct hfi1_vnic_vport_info *get_first_vnic_port(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_vnic_vport_info *vinfo;\n\tint next_id = VNIC_ID(0);\n\n\tvinfo = hfi1_netdev_get_first_data(dd, &next_id);\n\n\tif (next_id > VNIC_ID(VNIC_MASK))\n\t\treturn NULL;\n\n\treturn vinfo;\n}\n\nvoid hfi1_vnic_bypass_rcv(struct hfi1_packet *packet)\n{\n\tstruct hfi1_devdata *dd = packet->rcd->dd;\n\tstruct hfi1_vnic_vport_info *vinfo = NULL;\n\tstruct hfi1_vnic_rx_queue *rxq;\n\tstruct sk_buff *skb;\n\tint l4_type, vesw_id = -1, rc;\n\tu8 q_idx;\n\tunsigned char *pad_info;\n\n\tl4_type = hfi1_16B_get_l4(packet->ebuf);\n\tif (likely(l4_type == OPA_16B_L4_ETHR)) {\n\t\tvesw_id = HFI1_VNIC_GET_VESWID(packet->ebuf);\n\t\tvinfo = get_vnic_port(dd, vesw_id);\n\n\t\t \n\t\tif (unlikely(!vinfo)) {\n\t\t\tstruct hfi1_vnic_vport_info *vinfo_tmp;\n\n\t\t\tvinfo_tmp = get_first_vnic_port(dd);\n\t\t\tif (vinfo_tmp) {\n\t\t\t\tspin_lock(&vport_cntr_lock);\n\t\t\t\tvinfo_tmp->stats[0].netstats.rx_nohandler++;\n\t\t\t\tspin_unlock(&vport_cntr_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(!vinfo)) {\n\t\tdd_dev_warn(dd, \"vnic rcv err: l4 %d vesw id %d ctx %d\\n\",\n\t\t\t    l4_type, vesw_id, packet->rcd->ctxt);\n\t\treturn;\n\t}\n\n\tq_idx = packet->rcd->vnic_q_idx;\n\trxq = &vinfo->rxq[q_idx];\n\tif (unlikely(!netif_oper_up(vinfo->netdev))) {\n\t\tvinfo->stats[q_idx].rx_drop_state++;\n\t\treturn;\n\t}\n\n\tskb = netdev_alloc_skb(vinfo->netdev, packet->tlen);\n\tif (unlikely(!skb)) {\n\t\tvinfo->stats[q_idx].netstats.rx_fifo_errors++;\n\t\treturn;\n\t}\n\n\tmemcpy(skb->data, packet->ebuf, packet->tlen);\n\tskb_put(skb, packet->tlen);\n\n\tpad_info = skb->data + skb->len - 1;\n\tskb_trim(skb, (skb->len - OPA_VNIC_ICRC_TAIL_LEN -\n\t\t       ((*pad_info) & 0x7)));\n\n\trc = hfi1_vnic_decap_skb(rxq, skb);\n\n\t \n\thfi1_vnic_update_rx_counters(vinfo, rxq->idx, skb, rc);\n\tif (unlikely(rc)) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tskb_checksum_none_assert(skb);\n\tskb->protocol = eth_type_trans(skb, rxq->netdev);\n\n\tnapi_gro_receive(&rxq->napi, skb);\n}\n\nstatic int hfi1_vnic_up(struct hfi1_vnic_vport_info *vinfo)\n{\n\tstruct hfi1_devdata *dd = vinfo->dd;\n\tstruct net_device *netdev = vinfo->netdev;\n\tint rc;\n\n\t \n\tif (!vinfo->vesw_id)\n\t\treturn -EINVAL;\n\n\trc = hfi1_netdev_add_data(dd, VNIC_ID(vinfo->vesw_id), vinfo);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = hfi1_netdev_rx_init(dd);\n\tif (rc)\n\t\tgoto err_remove;\n\n\tnetif_carrier_on(netdev);\n\tnetif_tx_start_all_queues(netdev);\n\tset_bit(HFI1_VNIC_UP, &vinfo->flags);\n\n\treturn 0;\n\nerr_remove:\n\thfi1_netdev_remove_data(dd, VNIC_ID(vinfo->vesw_id));\n\treturn rc;\n}\n\nstatic void hfi1_vnic_down(struct hfi1_vnic_vport_info *vinfo)\n{\n\tstruct hfi1_devdata *dd = vinfo->dd;\n\n\tclear_bit(HFI1_VNIC_UP, &vinfo->flags);\n\tnetif_carrier_off(vinfo->netdev);\n\tnetif_tx_disable(vinfo->netdev);\n\thfi1_netdev_remove_data(dd, VNIC_ID(vinfo->vesw_id));\n\n\thfi1_netdev_rx_destroy(dd);\n}\n\nstatic int hfi1_netdev_open(struct net_device *netdev)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\tint rc;\n\n\tmutex_lock(&vinfo->lock);\n\trc = hfi1_vnic_up(vinfo);\n\tmutex_unlock(&vinfo->lock);\n\treturn rc;\n}\n\nstatic int hfi1_netdev_close(struct net_device *netdev)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\n\tmutex_lock(&vinfo->lock);\n\tif (test_bit(HFI1_VNIC_UP, &vinfo->flags))\n\t\thfi1_vnic_down(vinfo);\n\tmutex_unlock(&vinfo->lock);\n\treturn 0;\n}\n\nstatic int hfi1_vnic_init(struct hfi1_vnic_vport_info *vinfo)\n{\n\tstruct hfi1_devdata *dd = vinfo->dd;\n\tint rc = 0;\n\n\tmutex_lock(&hfi1_mutex);\n\tif (!dd->vnic_num_vports) {\n\t\trc = hfi1_vnic_txreq_init(dd);\n\t\tif (rc)\n\t\t\tgoto txreq_fail;\n\t}\n\n\trc = hfi1_netdev_rx_init(dd);\n\tif (rc) {\n\t\tdd_dev_err(dd, \"Unable to initialize netdev contexts\\n\");\n\t\tgoto alloc_fail;\n\t}\n\n\thfi1_init_vnic_rsm(dd);\n\n\tdd->vnic_num_vports++;\n\thfi1_vnic_sdma_init(vinfo);\n\nalloc_fail:\n\tif (!dd->vnic_num_vports)\n\t\thfi1_vnic_txreq_deinit(dd);\ntxreq_fail:\n\tmutex_unlock(&hfi1_mutex);\n\treturn rc;\n}\n\nstatic void hfi1_vnic_deinit(struct hfi1_vnic_vport_info *vinfo)\n{\n\tstruct hfi1_devdata *dd = vinfo->dd;\n\n\tmutex_lock(&hfi1_mutex);\n\tif (--dd->vnic_num_vports == 0) {\n\t\thfi1_deinit_vnic_rsm(dd);\n\t\thfi1_vnic_txreq_deinit(dd);\n\t}\n\tmutex_unlock(&hfi1_mutex);\n\thfi1_netdev_rx_destroy(dd);\n}\n\nstatic void hfi1_vnic_set_vesw_id(struct net_device *netdev, int id)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\tbool reopen = false;\n\n\t \n\tif (id != vinfo->vesw_id) {\n\t\tmutex_lock(&vinfo->lock);\n\t\tif (test_bit(HFI1_VNIC_UP, &vinfo->flags)) {\n\t\t\thfi1_vnic_down(vinfo);\n\t\t\treopen = true;\n\t\t}\n\n\t\tvinfo->vesw_id = id;\n\t\tif (reopen)\n\t\t\thfi1_vnic_up(vinfo);\n\n\t\tmutex_unlock(&vinfo->lock);\n\t}\n}\n\n \nstatic const struct net_device_ops hfi1_netdev_ops = {\n\t.ndo_open = hfi1_netdev_open,\n\t.ndo_stop = hfi1_netdev_close,\n\t.ndo_start_xmit = hfi1_netdev_start_xmit,\n\t.ndo_select_queue = hfi1_vnic_select_queue,\n\t.ndo_get_stats64 = hfi1_vnic_get_stats64,\n};\n\nstatic void hfi1_vnic_free_rn(struct net_device *netdev)\n{\n\tstruct hfi1_vnic_vport_info *vinfo = opa_vnic_dev_priv(netdev);\n\n\thfi1_vnic_deinit(vinfo);\n\tmutex_destroy(&vinfo->lock);\n\tfree_netdev(netdev);\n}\n\nstruct net_device *hfi1_vnic_alloc_rn(struct ib_device *device,\n\t\t\t\t      u32 port_num,\n\t\t\t\t      enum rdma_netdev_t type,\n\t\t\t\t      const char *name,\n\t\t\t\t      unsigned char name_assign_type,\n\t\t\t\t      void (*setup)(struct net_device *))\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(device);\n\tstruct hfi1_vnic_vport_info *vinfo;\n\tstruct net_device *netdev;\n\tstruct rdma_netdev *rn;\n\tint i, size, rc;\n\n\tif (!dd->num_netdev_contexts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (!port_num || (port_num > dd->num_pports))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (type != RDMA_NETDEV_OPA_VNIC)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tsize = sizeof(struct opa_vnic_rdma_netdev) + sizeof(*vinfo);\n\tnetdev = alloc_netdev_mqs(size, name, name_assign_type, setup,\n\t\t\t\t  chip_sdma_engines(dd),\n\t\t\t\t  dd->num_netdev_contexts);\n\tif (!netdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trn = netdev_priv(netdev);\n\tvinfo = opa_vnic_dev_priv(netdev);\n\tvinfo->dd = dd;\n\tvinfo->num_tx_q = chip_sdma_engines(dd);\n\tvinfo->num_rx_q = dd->num_netdev_contexts;\n\tvinfo->netdev = netdev;\n\trn->free_rdma_netdev = hfi1_vnic_free_rn;\n\trn->set_id = hfi1_vnic_set_vesw_id;\n\n\tnetdev->features = NETIF_F_HIGHDMA | NETIF_F_SG;\n\tnetdev->hw_features = netdev->features;\n\tnetdev->vlan_features = netdev->features;\n\tnetdev->watchdog_timeo = msecs_to_jiffies(HFI_TX_TIMEOUT_MS);\n\tnetdev->netdev_ops = &hfi1_netdev_ops;\n\tmutex_init(&vinfo->lock);\n\n\tfor (i = 0; i < vinfo->num_rx_q; i++) {\n\t\tstruct hfi1_vnic_rx_queue *rxq = &vinfo->rxq[i];\n\n\t\trxq->idx = i;\n\t\trxq->vinfo = vinfo;\n\t\trxq->netdev = netdev;\n\t}\n\n\trc = hfi1_vnic_init(vinfo);\n\tif (rc)\n\t\tgoto init_fail;\n\n\treturn netdev;\ninit_fail:\n\tmutex_destroy(&vinfo->lock);\n\tfree_netdev(netdev);\n\treturn ERR_PTR(rc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}