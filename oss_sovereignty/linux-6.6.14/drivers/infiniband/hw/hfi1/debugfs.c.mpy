{
  "module_name": "debugfs.c",
  "hash_id": "721a5cf799c3681cf8a0820bfaca8d0f1b2824c82eb660eefb198d88f0aa6aef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ratelimit.h>\n#include <linux/fault-inject.h>\n\n#include \"hfi.h\"\n#include \"trace.h\"\n#include \"debugfs.h\"\n#include \"device.h\"\n#include \"qp.h\"\n#include \"sdma.h\"\n#include \"fault.h\"\n\nstatic struct dentry *hfi1_dbg_root;\n\n \nssize_t hfi1_seq_read(struct file *file, char __user *buf, size_t size,\n\t\t      loff_t *ppos)\n{\n\tstruct dentry *d = file->f_path.dentry;\n\tssize_t r;\n\n\tr = debugfs_file_get(d);\n\tif (unlikely(r))\n\t\treturn r;\n\tr = seq_read(file, buf, size, ppos);\n\tdebugfs_file_put(d);\n\treturn r;\n}\n\nloff_t hfi1_seq_lseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct dentry *d = file->f_path.dentry;\n\tloff_t r;\n\n\tr = debugfs_file_get(d);\n\tif (unlikely(r))\n\t\treturn r;\n\tr = seq_lseek(file, offset, whence);\n\tdebugfs_file_put(d);\n\treturn r;\n}\n\n#define private2dd(file) (file_inode(file)->i_private)\n#define private2ppd(file) (file_inode(file)->i_private)\n\nstatic void *_opcode_stats_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_opcode_stats_perctx *opstats;\n\n\tif (*pos >= ARRAY_SIZE(opstats->stats))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_opcode_stats_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_opcode_stats_perctx *opstats;\n\n\t++*pos;\n\tif (*pos >= ARRAY_SIZE(opstats->stats))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _opcode_stats_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int opcode_stats_show(struct seq_file *s, u8 i, u64 packets, u64 bytes)\n{\n\tif (!packets && !bytes)\n\t\treturn SEQ_SKIP;\n\tseq_printf(s, \"%02x %llu/%llu\\n\", i,\n\t\t   (unsigned long long)packets,\n\t\t   (unsigned long long)bytes);\n\n\treturn 0;\n}\n\nstatic int _opcode_stats_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos = v;\n\tloff_t i = *spos, j;\n\tu64 n_packets = 0, n_bytes = 0;\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_ctxtdata *rcd;\n\n\tfor (j = 0; j < dd->first_dyn_alloc_ctxt; j++) {\n\t\trcd = hfi1_rcd_get_by_index(dd, j);\n\t\tif (rcd) {\n\t\t\tn_packets += rcd->opstats->stats[i].n_packets;\n\t\t\tn_bytes += rcd->opstats->stats[i].n_bytes;\n\t\t}\n\t\thfi1_rcd_put(rcd);\n\t}\n\treturn opcode_stats_show(s, i, n_packets, n_bytes);\n}\n\nDEBUGFS_SEQ_FILE_OPS(opcode_stats);\nDEBUGFS_SEQ_FILE_OPEN(opcode_stats)\nDEBUGFS_FILE_OPS(opcode_stats);\n\nstatic void *_tx_opcode_stats_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn _opcode_stats_seq_start(s, pos);\n}\n\nstatic void *_tx_opcode_stats_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn _opcode_stats_seq_next(s, v, pos);\n}\n\nstatic void _tx_opcode_stats_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _tx_opcode_stats_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos = v;\n\tloff_t i = *spos;\n\tint j;\n\tu64 n_packets = 0, n_bytes = 0;\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\tfor_each_possible_cpu(j) {\n\t\tstruct hfi1_opcode_stats_perctx *s =\n\t\t\tper_cpu_ptr(dd->tx_opstats, j);\n\t\tn_packets += s->stats[i].n_packets;\n\t\tn_bytes += s->stats[i].n_bytes;\n\t}\n\treturn opcode_stats_show(s, i, n_packets, n_bytes);\n}\n\nDEBUGFS_SEQ_FILE_OPS(tx_opcode_stats);\nDEBUGFS_SEQ_FILE_OPEN(tx_opcode_stats)\nDEBUGFS_FILE_OPS(tx_opcode_stats);\n\nstatic void *_ctx_stats_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\tif (!*pos)\n\t\treturn SEQ_START_TOKEN;\n\tif (*pos >= dd->first_dyn_alloc_ctxt)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_ctx_stats_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\tif (v == SEQ_START_TOKEN)\n\t\treturn pos;\n\n\t++*pos;\n\tif (*pos >= dd->first_dyn_alloc_ctxt)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _ctx_stats_seq_stop(struct seq_file *s, void *v)\n{\n\t \n}\n\nstatic int _ctx_stats_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos;\n\tloff_t i, j;\n\tu64 n_packets = 0;\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_ctxtdata *rcd;\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_puts(s, \"Ctx:npkts\\n\");\n\t\treturn 0;\n\t}\n\n\tspos = v;\n\ti = *spos;\n\n\trcd = hfi1_rcd_get_by_index_safe(dd, i);\n\tif (!rcd)\n\t\treturn SEQ_SKIP;\n\n\tfor (j = 0; j < ARRAY_SIZE(rcd->opstats->stats); j++)\n\t\tn_packets += rcd->opstats->stats[j].n_packets;\n\n\thfi1_rcd_put(rcd);\n\n\tif (!n_packets)\n\t\treturn SEQ_SKIP;\n\n\tseq_printf(s, \"  %llu:%llu\\n\", i, n_packets);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(ctx_stats);\nDEBUGFS_SEQ_FILE_OPEN(ctx_stats)\nDEBUGFS_FILE_OPS(ctx_stats);\n\nstatic void *_qp_stats_seq_start(struct seq_file *s, loff_t *pos)\n\t__acquires(RCU)\n{\n\tstruct rvt_qp_iter *iter;\n\tloff_t n = *pos;\n\n\titer = rvt_qp_iter_init(s->private, 0, NULL);\n\n\t \n\trcu_read_lock();\n\n\tif (!iter)\n\t\treturn NULL;\n\n\tdo {\n\t\tif (rvt_qp_iter_next(iter)) {\n\t\t\tkfree(iter);\n\t\t\treturn NULL;\n\t\t}\n\t} while (n--);\n\n\treturn iter;\n}\n\nstatic void *_qp_stats_seq_next(struct seq_file *s, void *iter_ptr,\n\t\t\t\tloff_t *pos)\n\t__must_hold(RCU)\n{\n\tstruct rvt_qp_iter *iter = iter_ptr;\n\n\t(*pos)++;\n\n\tif (rvt_qp_iter_next(iter)) {\n\t\tkfree(iter);\n\t\treturn NULL;\n\t}\n\n\treturn iter;\n}\n\nstatic void _qp_stats_seq_stop(struct seq_file *s, void *iter_ptr)\n\t__releases(RCU)\n{\n\trcu_read_unlock();\n}\n\nstatic int _qp_stats_seq_show(struct seq_file *s, void *iter_ptr)\n{\n\tstruct rvt_qp_iter *iter = iter_ptr;\n\n\tif (!iter)\n\t\treturn 0;\n\n\tqp_iter_print(s, iter);\n\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(qp_stats);\nDEBUGFS_SEQ_FILE_OPEN(qp_stats)\nDEBUGFS_FILE_OPS(qp_stats);\n\nstatic void *_sdes_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd;\n\tstruct hfi1_devdata *dd;\n\n\tibd = (struct hfi1_ibdev *)s->private;\n\tdd = dd_from_dev(ibd);\n\tif (!dd->per_sdma || *pos >= dd->num_sdma)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_sdes_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\t++*pos;\n\tif (!dd->per_sdma || *pos >= dd->num_sdma)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _sdes_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _sdes_seq_show(struct seq_file *s, void *v)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tloff_t *spos = v;\n\tloff_t i = *spos;\n\n\tsdma_seqfile_dump_sde(s, &dd->per_sdma[i]);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(sdes);\nDEBUGFS_SEQ_FILE_OPEN(sdes)\nDEBUGFS_FILE_OPS(sdes);\n\nstatic void *_rcds_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd;\n\tstruct hfi1_devdata *dd;\n\n\tibd = (struct hfi1_ibdev *)s->private;\n\tdd = dd_from_dev(ibd);\n\tif (!dd->rcd || *pos >= dd->n_krcv_queues)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_rcds_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\t++*pos;\n\tif (!dd->rcd || *pos >= dd->num_rcv_contexts)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _rcds_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _rcds_seq_show(struct seq_file *s, void *v)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_ctxtdata *rcd;\n\tloff_t *spos = v;\n\tloff_t i = *spos;\n\n\trcd = hfi1_rcd_get_by_index_safe(dd, i);\n\tif (rcd)\n\t\tseqfile_dump_rcd(s, rcd);\n\thfi1_rcd_put(rcd);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(rcds);\nDEBUGFS_SEQ_FILE_OPEN(rcds)\nDEBUGFS_FILE_OPS(rcds);\n\nstatic void *_pios_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd;\n\tstruct hfi1_devdata *dd;\n\n\tibd = (struct hfi1_ibdev *)s->private;\n\tdd = dd_from_dev(ibd);\n\tif (!dd->send_contexts || *pos >= dd->num_send_contexts)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_pios_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\n\t++*pos;\n\tif (!dd->send_contexts || *pos >= dd->num_send_contexts)\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _pios_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _pios_seq_show(struct seq_file *s, void *v)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct send_context_info *sci;\n\tloff_t *spos = v;\n\tloff_t i = *spos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->sc_lock, flags);\n\tsci = &dd->send_contexts[i];\n\tif (sci && sci->type != SC_USER && sci->allocated && sci->sc)\n\t\tseqfile_dump_sci(s, i, sci);\n\tspin_unlock_irqrestore(&dd->sc_lock, flags);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(pios);\nDEBUGFS_SEQ_FILE_OPEN(pios)\nDEBUGFS_FILE_OPS(pios);\n\n \nstatic ssize_t dev_counters_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tu64 *counters;\n\tsize_t avail;\n\tstruct hfi1_devdata *dd;\n\tssize_t rval;\n\n\tdd = private2dd(file);\n\tavail = hfi1_read_cntrs(dd, NULL, &counters);\n\trval =  simple_read_from_buffer(buf, count, ppos, counters, avail);\n\treturn rval;\n}\n\n \nstatic ssize_t dev_names_read(struct file *file, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *names;\n\tsize_t avail;\n\tstruct hfi1_devdata *dd;\n\tssize_t rval;\n\n\tdd = private2dd(file);\n\tavail = hfi1_read_cntrs(dd, &names, NULL);\n\trval =  simple_read_from_buffer(buf, count, ppos, names, avail);\n\treturn rval;\n}\n\nstruct counter_info {\n\tchar *name;\n\tconst struct file_operations ops;\n};\n\n \n\n \nstatic ssize_t portnames_read(struct file *file, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *names;\n\tsize_t avail;\n\tstruct hfi1_devdata *dd;\n\tssize_t rval;\n\n\tdd = private2dd(file);\n\tavail = hfi1_read_portcntrs(dd->pport, &names, NULL);\n\trval = simple_read_from_buffer(buf, count, ppos, names, avail);\n\treturn rval;\n}\n\n \nstatic ssize_t portcntrs_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tu64 *counters;\n\tsize_t avail;\n\tstruct hfi1_pportdata *ppd;\n\tssize_t rval;\n\n\tppd = private2ppd(file);\n\tavail = hfi1_read_portcntrs(ppd, NULL, &counters);\n\trval = simple_read_from_buffer(buf, count, ppos, counters, avail);\n\treturn rval;\n}\n\nstatic void check_dyn_flag(u64 scratch0, char *p, int size, int *used,\n\t\t\t   int this_hfi, int hfi, u32 flag, const char *what)\n{\n\tu32 mask;\n\n\tmask = flag << (hfi ? CR_DYN_SHIFT : 0);\n\tif (scratch0 & mask) {\n\t\t*used += scnprintf(p + *used, size - *used,\n\t\t\t\t   \"  0x%08x - HFI%d %s in use, %s device\\n\",\n\t\t\t\t   mask, hfi, what,\n\t\t\t\t   this_hfi == hfi ? \"this\" : \"other\");\n\t}\n}\n\nstatic ssize_t asic_flags_read(struct file *file, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd;\n\tstruct hfi1_devdata *dd;\n\tu64 scratch0;\n\tchar *tmp;\n\tint ret = 0;\n\tint size;\n\tint used;\n\tint i;\n\n\tppd = private2ppd(file);\n\tdd = ppd->dd;\n\tsize = PAGE_SIZE;\n\tused = 0;\n\ttmp = kmalloc(size, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tused += scnprintf(tmp + used, size - used,\n\t\t\t  \"Resource flags: 0x%016llx\\n\", scratch0);\n\n\t \n\tif (scratch0 & CR_THERM_INIT) {\n\t\tused += scnprintf(tmp + used, size - used,\n\t\t\t\t  \"  0x%08x - thermal monitoring initialized\\n\",\n\t\t\t\t  (u32)CR_THERM_INIT);\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\tcheck_dyn_flag(scratch0, tmp, size, &used, dd->hfi1_id, i,\n\t\t\t       CR_SBUS, \"SBus\");\n\t\tcheck_dyn_flag(scratch0, tmp, size, &used, dd->hfi1_id, i,\n\t\t\t       CR_EPROM, \"EPROM\");\n\t\tcheck_dyn_flag(scratch0, tmp, size, &used, dd->hfi1_id, i,\n\t\t\t       CR_I2C1, \"i2c chain 1\");\n\t\tcheck_dyn_flag(scratch0, tmp, size, &used, dd->hfi1_id, i,\n\t\t\t       CR_I2C2, \"i2c chain 2\");\n\t}\n\tused += scnprintf(tmp + used, size - used, \"Write bits to clear\\n\");\n\n\tret = simple_read_from_buffer(buf, count, ppos, tmp, used);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic ssize_t asic_flags_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd;\n\tstruct hfi1_devdata *dd;\n\tchar *buff;\n\tint ret;\n\tunsigned long long value;\n\tu64 scratch0;\n\tu64 clear;\n\n\tppd = private2ppd(file);\n\tdd = ppd->dd;\n\n\t \n\tbuff = memdup_user_nul(buf, count);\n\tif (IS_ERR(buff))\n\t\treturn PTR_ERR(buff);\n\n\tret = kstrtoull(buff, 0, &value);\n\tif (ret)\n\t\tgoto do_free;\n\tclear = value;\n\n\t \n\tmutex_lock(&dd->asic_data->asic_resource_mutex);\n\tacquire_hw_mutex(dd);\n\n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tscratch0 &= ~clear;\n\twrite_csr(dd, ASIC_CFG_SCRATCH, scratch0);\n\t \n\t(void)read_csr(dd, ASIC_CFG_SCRATCH);\n\n\trelease_hw_mutex(dd);\n\tmutex_unlock(&dd->asic_data->asic_resource_mutex);\n\n\t \n\tret = count;\n\n do_free:\n\tkfree(buff);\n\treturn ret;\n}\n\n \nstatic ssize_t dc8051_memory_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd = private2ppd(file);\n\tssize_t rval;\n\tvoid *tmp;\n\tloff_t start, end;\n\n\t \n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\n\ttmp = kzalloc(DC8051_DATA_MEM_SIZE, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\tstart = *ppos & ~0x7;\t \n\tif (start < DC8051_DATA_MEM_SIZE) {\n\t\tend = (*ppos + count + 7) & ~0x7;  \n\t\tif (end > DC8051_DATA_MEM_SIZE)\n\t\t\tend = DC8051_DATA_MEM_SIZE;\n\t\trval = read_8051_data(ppd->dd, start, end - start,\n\t\t\t\t      (u64 *)(tmp + start));\n\t\tif (rval)\n\t\t\tgoto done;\n\t}\n\n\trval = simple_read_from_buffer(buf, count, ppos, tmp,\n\t\t\t\t       DC8051_DATA_MEM_SIZE);\ndone:\n\tkfree(tmp);\n\treturn rval;\n}\n\nstatic ssize_t debugfs_lcb_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd = private2ppd(file);\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tunsigned long total, csr_off;\n\tu64 data;\n\n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\t \n\tif ((count % 8) != 0)\n\t\treturn -EINVAL;\n\t \n\tif ((*ppos % 8) != 0)\n\t\treturn -EINVAL;\n\t \n\tif (*ppos >= (LCB_END - LCB_START) || !count)\n\t\treturn 0;\n\t \n\tif (*ppos + count > LCB_END - LCB_START)\n\t\tcount = (LCB_END - LCB_START) - *ppos;\n\n\tcsr_off = LCB_START + *ppos;\n\tfor (total = 0; total < count; total += 8, csr_off += 8) {\n\t\tif (read_lcb_csr(dd, csr_off, (u64 *)&data))\n\t\t\tbreak;  \n\t\tif (put_user(data, (unsigned long __user *)(buf + total)))\n\t\t\tbreak;\n\t}\n\t*ppos += total;\n\treturn total;\n}\n\nstatic ssize_t debugfs_lcb_write(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd = private2ppd(file);\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tunsigned long total, csr_off, data;\n\n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\t \n\tif ((count % 8) != 0)\n\t\treturn -EINVAL;\n\t \n\tif ((*ppos % 8) != 0)\n\t\treturn -EINVAL;\n\t \n\tif (*ppos >= (LCB_END - LCB_START) || !count)\n\t\treturn 0;\n\t \n\tif (*ppos + count > LCB_END - LCB_START)\n\t\tcount = (LCB_END - LCB_START) - *ppos;\n\n\tcsr_off = LCB_START + *ppos;\n\tfor (total = 0; total < count; total += 8, csr_off += 8) {\n\t\tif (get_user(data, (unsigned long __user *)(buf + total)))\n\t\t\tbreak;\n\t\tif (write_lcb_csr(dd, csr_off, data))\n\t\t\tbreak;  \n\t}\n\t*ppos += total;\n\treturn total;\n}\n\n \nstatic ssize_t qsfp_debugfs_dump(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd;\n\tchar *tmp;\n\tint ret;\n\n\tppd = private2ppd(file);\n\ttmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = qsfp_dump(ppd, tmp, PAGE_SIZE);\n\tif (ret > 0)\n\t\tret = simple_read_from_buffer(buf, count, ppos, tmp, ret);\n\tkfree(tmp);\n\treturn ret;\n}\n\n \nstatic ssize_t __i2c_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\tchar *buff;\n\tint ret;\n\tint i2c_addr;\n\tint offset;\n\tint total_written;\n\n\tppd = private2ppd(file);\n\n\t \n\ti2c_addr = (*ppos >> 16) & 0xffff;\n\toffset = *ppos & 0xffff;\n\n\t \n\tif (i2c_addr == 0)\n\t\treturn -EINVAL;\n\n\tbuff = memdup_user(buf, count);\n\tif (IS_ERR(buff))\n\t\treturn PTR_ERR(buff);\n\n\ttotal_written = i2c_write(ppd, target, i2c_addr, offset, buff, count);\n\tif (total_written < 0) {\n\t\tret = total_written;\n\t\tgoto _free;\n\t}\n\n\t*ppos += total_written;\n\n\tret = total_written;\n\n _free:\n\tkfree(buff);\n\treturn ret;\n}\n\n \nstatic ssize_t i2c1_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn __i2c_debugfs_write(file, buf, count, ppos, 0);\n}\n\n \nstatic ssize_t i2c2_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn __i2c_debugfs_write(file, buf, count, ppos, 1);\n}\n\n \nstatic ssize_t __i2c_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\tchar *buff;\n\tint ret;\n\tint i2c_addr;\n\tint offset;\n\tint total_read;\n\n\tppd = private2ppd(file);\n\n\t \n\ti2c_addr = (*ppos >> 16) & 0xffff;\n\toffset = *ppos & 0xffff;\n\n\t \n\tif (i2c_addr == 0)\n\t\treturn -EINVAL;\n\n\tbuff = kmalloc(count, GFP_KERNEL);\n\tif (!buff)\n\t\treturn -ENOMEM;\n\n\ttotal_read = i2c_read(ppd, target, i2c_addr, offset, buff, count);\n\tif (total_read < 0) {\n\t\tret = total_read;\n\t\tgoto _free;\n\t}\n\n\t*ppos += total_read;\n\n\tret = copy_to_user(buf, buff, total_read);\n\tif (ret > 0) {\n\t\tret = -EFAULT;\n\t\tgoto _free;\n\t}\n\n\tret = total_read;\n\n _free:\n\tkfree(buff);\n\treturn ret;\n}\n\n \nstatic ssize_t i2c1_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn __i2c_debugfs_read(file, buf, count, ppos, 0);\n}\n\n \nstatic ssize_t i2c2_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn __i2c_debugfs_read(file, buf, count, ppos, 1);\n}\n\n \nstatic ssize_t __qsfp_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t count, loff_t *ppos, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\tchar *buff;\n\tint ret;\n\tint total_written;\n\n\tif (*ppos + count > QSFP_PAGESIZE * 4)  \n\t\treturn -EINVAL;\n\n\tppd = private2ppd(file);\n\n\tbuff = memdup_user(buf, count);\n\tif (IS_ERR(buff))\n\t\treturn PTR_ERR(buff);\n\n\ttotal_written = qsfp_write(ppd, target, *ppos, buff, count);\n\tif (total_written < 0) {\n\t\tret = total_written;\n\t\tgoto _free;\n\t}\n\n\t*ppos += total_written;\n\n\tret = total_written;\n\n _free:\n\tkfree(buff);\n\treturn ret;\n}\n\n \nstatic ssize_t qsfp1_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn __qsfp_debugfs_write(file, buf, count, ppos, 0);\n}\n\n \nstatic ssize_t qsfp2_debugfs_write(struct file *file, const char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn __qsfp_debugfs_write(file, buf, count, ppos, 1);\n}\n\n \nstatic ssize_t __qsfp_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t   size_t count, loff_t *ppos, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\tchar *buff;\n\tint ret;\n\tint total_read;\n\n\tif (*ppos + count > QSFP_PAGESIZE * 4) {  \n\t\tret = -EINVAL;\n\t\tgoto _return;\n\t}\n\n\tppd = private2ppd(file);\n\n\tbuff = kmalloc(count, GFP_KERNEL);\n\tif (!buff) {\n\t\tret = -ENOMEM;\n\t\tgoto _return;\n\t}\n\n\ttotal_read = qsfp_read(ppd, target, *ppos, buff, count);\n\tif (total_read < 0) {\n\t\tret = total_read;\n\t\tgoto _free;\n\t}\n\n\t*ppos += total_read;\n\n\tret = copy_to_user(buf, buff, total_read);\n\tif (ret > 0) {\n\t\tret = -EFAULT;\n\t\tgoto _free;\n\t}\n\n\tret = total_read;\n\n _free:\n\tkfree(buff);\n _return:\n\treturn ret;\n}\n\n \nstatic ssize_t qsfp1_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn __qsfp_debugfs_read(file, buf, count, ppos, 0);\n}\n\n \nstatic ssize_t qsfp2_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn __qsfp_debugfs_read(file, buf, count, ppos, 1);\n}\n\nstatic int __i2c_debugfs_open(struct inode *in, struct file *fp, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\n\tppd = private2ppd(fp);\n\n\treturn acquire_chip_resource(ppd->dd, i2c_target(target), 0);\n}\n\nstatic int i2c1_debugfs_open(struct inode *in, struct file *fp)\n{\n\treturn __i2c_debugfs_open(in, fp, 0);\n}\n\nstatic int i2c2_debugfs_open(struct inode *in, struct file *fp)\n{\n\treturn __i2c_debugfs_open(in, fp, 1);\n}\n\nstatic int __i2c_debugfs_release(struct inode *in, struct file *fp, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\n\tppd = private2ppd(fp);\n\n\trelease_chip_resource(ppd->dd, i2c_target(target));\n\n\treturn 0;\n}\n\nstatic int i2c1_debugfs_release(struct inode *in, struct file *fp)\n{\n\treturn __i2c_debugfs_release(in, fp, 0);\n}\n\nstatic int i2c2_debugfs_release(struct inode *in, struct file *fp)\n{\n\treturn __i2c_debugfs_release(in, fp, 1);\n}\n\nstatic int __qsfp_debugfs_open(struct inode *in, struct file *fp, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\n\tppd = private2ppd(fp);\n\n\treturn acquire_chip_resource(ppd->dd, i2c_target(target), 0);\n}\n\nstatic int qsfp1_debugfs_open(struct inode *in, struct file *fp)\n{\n\treturn __qsfp_debugfs_open(in, fp, 0);\n}\n\nstatic int qsfp2_debugfs_open(struct inode *in, struct file *fp)\n{\n\treturn __qsfp_debugfs_open(in, fp, 1);\n}\n\nstatic int __qsfp_debugfs_release(struct inode *in, struct file *fp, u32 target)\n{\n\tstruct hfi1_pportdata *ppd;\n\n\tppd = private2ppd(fp);\n\n\trelease_chip_resource(ppd->dd, i2c_target(target));\n\n\treturn 0;\n}\n\nstatic int qsfp1_debugfs_release(struct inode *in, struct file *fp)\n{\n\treturn __qsfp_debugfs_release(in, fp, 0);\n}\n\nstatic int qsfp2_debugfs_release(struct inode *in, struct file *fp)\n{\n\treturn __qsfp_debugfs_release(in, fp, 1);\n}\n\n#define EXPROM_WRITE_ENABLE BIT_ULL(14)\n\nstatic bool exprom_wp_disabled;\n\nstatic int exprom_wp_set(struct hfi1_devdata *dd, bool disable)\n{\n\tu64 gpio_val = 0;\n\n\tif (disable) {\n\t\tgpio_val = EXPROM_WRITE_ENABLE;\n\t\texprom_wp_disabled = true;\n\t\tdd_dev_info(dd, \"Disable Expansion ROM Write Protection\\n\");\n\t} else {\n\t\texprom_wp_disabled = false;\n\t\tdd_dev_info(dd, \"Enable Expansion ROM Write Protection\\n\");\n\t}\n\n\twrite_csr(dd, ASIC_GPIO_OUT, gpio_val);\n\twrite_csr(dd, ASIC_GPIO_OE, gpio_val);\n\n\treturn 0;\n}\n\nstatic ssize_t exprom_wp_debugfs_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\treturn 0;\n}\n\nstatic ssize_t exprom_wp_debugfs_write(struct file *file,\n\t\t\t\t       const char __user *buf, size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tstruct hfi1_pportdata *ppd = private2ppd(file);\n\tchar cdata;\n\n\tif (count != 1)\n\t\treturn -EINVAL;\n\tif (get_user(cdata, buf))\n\t\treturn -EFAULT;\n\tif (cdata == '0')\n\t\texprom_wp_set(ppd->dd, false);\n\telse if (cdata == '1')\n\t\texprom_wp_set(ppd->dd, true);\n\telse\n\t\treturn -EINVAL;\n\n\treturn 1;\n}\n\nstatic unsigned long exprom_in_use;\n\nstatic int exprom_wp_debugfs_open(struct inode *in, struct file *fp)\n{\n\tif (test_and_set_bit(0, &exprom_in_use))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int exprom_wp_debugfs_release(struct inode *in, struct file *fp)\n{\n\tstruct hfi1_pportdata *ppd = private2ppd(fp);\n\n\tif (exprom_wp_disabled)\n\t\texprom_wp_set(ppd->dd, false);\n\tclear_bit(0, &exprom_in_use);\n\n\treturn 0;\n}\n\n#define DEBUGFS_OPS(nm, readroutine, writeroutine)\t\\\n{ \\\n\t.name = nm, \\\n\t.ops = { \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.read = readroutine, \\\n\t\t.write = writeroutine, \\\n\t\t.llseek = generic_file_llseek, \\\n\t}, \\\n}\n\n#define DEBUGFS_XOPS(nm, readf, writef, openf, releasef) \\\n{ \\\n\t.name = nm, \\\n\t.ops = { \\\n\t\t.owner = THIS_MODULE, \\\n\t\t.read = readf, \\\n\t\t.write = writef, \\\n\t\t.llseek = generic_file_llseek, \\\n\t\t.open = openf, \\\n\t\t.release = releasef \\\n\t}, \\\n}\n\nstatic const struct counter_info cntr_ops[] = {\n\tDEBUGFS_OPS(\"counter_names\", dev_names_read, NULL),\n\tDEBUGFS_OPS(\"counters\", dev_counters_read, NULL),\n\tDEBUGFS_OPS(\"portcounter_names\", portnames_read, NULL),\n};\n\nstatic const struct counter_info port_cntr_ops[] = {\n\tDEBUGFS_OPS(\"port%dcounters\", portcntrs_debugfs_read, NULL),\n\tDEBUGFS_XOPS(\"i2c1\", i2c1_debugfs_read, i2c1_debugfs_write,\n\t\t     i2c1_debugfs_open, i2c1_debugfs_release),\n\tDEBUGFS_XOPS(\"i2c2\", i2c2_debugfs_read, i2c2_debugfs_write,\n\t\t     i2c2_debugfs_open, i2c2_debugfs_release),\n\tDEBUGFS_OPS(\"qsfp_dump%d\", qsfp_debugfs_dump, NULL),\n\tDEBUGFS_XOPS(\"qsfp1\", qsfp1_debugfs_read, qsfp1_debugfs_write,\n\t\t     qsfp1_debugfs_open, qsfp1_debugfs_release),\n\tDEBUGFS_XOPS(\"qsfp2\", qsfp2_debugfs_read, qsfp2_debugfs_write,\n\t\t     qsfp2_debugfs_open, qsfp2_debugfs_release),\n\tDEBUGFS_XOPS(\"exprom_wp\", exprom_wp_debugfs_read,\n\t\t     exprom_wp_debugfs_write, exprom_wp_debugfs_open,\n\t\t     exprom_wp_debugfs_release),\n\tDEBUGFS_OPS(\"asic_flags\", asic_flags_read, asic_flags_write),\n\tDEBUGFS_OPS(\"dc8051_memory\", dc8051_memory_read, NULL),\n\tDEBUGFS_OPS(\"lcb\", debugfs_lcb_read, debugfs_lcb_write),\n};\n\nstatic void *_sdma_cpu_list_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tif (*pos >= num_online_cpus())\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void *_sdma_cpu_list_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\t++*pos;\n\tif (*pos >= num_online_cpus())\n\t\treturn NULL;\n\n\treturn pos;\n}\n\nstatic void _sdma_cpu_list_seq_stop(struct seq_file *s, void *v)\n{\n\t \n}\n\nstatic int _sdma_cpu_list_seq_show(struct seq_file *s, void *v)\n{\n\tstruct hfi1_ibdev *ibd = (struct hfi1_ibdev *)s->private;\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tloff_t *spos = v;\n\tloff_t i = *spos;\n\n\tsdma_seqfile_dump_cpu_list(s, dd, (unsigned long)i);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(sdma_cpu_list);\nDEBUGFS_SEQ_FILE_OPEN(sdma_cpu_list)\nDEBUGFS_FILE_OPS(sdma_cpu_list);\n\nvoid hfi1_dbg_ibdev_init(struct hfi1_ibdev *ibd)\n{\n\tchar name[sizeof(\"port0counters\") + 1];\n\tchar link[10];\n\tstruct hfi1_devdata *dd = dd_from_dev(ibd);\n\tstruct hfi1_pportdata *ppd;\n\tstruct dentry *root;\n\tint unit = dd->unit;\n\tint i, j;\n\n\tif (!hfi1_dbg_root)\n\t\treturn;\n\tsnprintf(name, sizeof(name), \"%s_%d\", class_name(), unit);\n\tsnprintf(link, sizeof(link), \"%d\", unit);\n\troot = debugfs_create_dir(name, hfi1_dbg_root);\n\tibd->hfi1_ibdev_dbg = root;\n\n\tibd->hfi1_ibdev_link =\n\t\tdebugfs_create_symlink(link, hfi1_dbg_root, name);\n\n\tdebugfs_create_file(\"opcode_stats\", 0444, root, ibd,\n\t\t\t    &_opcode_stats_file_ops);\n\tdebugfs_create_file(\"tx_opcode_stats\", 0444, root, ibd,\n\t\t\t    &_tx_opcode_stats_file_ops);\n\tdebugfs_create_file(\"ctx_stats\", 0444, root, ibd, &_ctx_stats_file_ops);\n\tdebugfs_create_file(\"qp_stats\", 0444, root, ibd, &_qp_stats_file_ops);\n\tdebugfs_create_file(\"sdes\", 0444, root, ibd, &_sdes_file_ops);\n\tdebugfs_create_file(\"rcds\", 0444, root, ibd, &_rcds_file_ops);\n\tdebugfs_create_file(\"pios\", 0444, root, ibd, &_pios_file_ops);\n\tdebugfs_create_file(\"sdma_cpu_list\", 0444, root, ibd,\n\t\t\t    &_sdma_cpu_list_file_ops);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(cntr_ops); i++)\n\t\tdebugfs_create_file(cntr_ops[i].name, 0444, root, dd,\n\t\t\t\t    &cntr_ops[i].ops);\n\n\t \n\tfor (ppd = dd->pport, j = 0; j < dd->num_pports; j++, ppd++)\n\t\tfor (i = 0; i < ARRAY_SIZE(port_cntr_ops); i++) {\n\t\t\tsnprintf(name,\n\t\t\t\t sizeof(name),\n\t\t\t\t port_cntr_ops[i].name,\n\t\t\t\t j + 1);\n\t\t\tdebugfs_create_file(name,\n\t\t\t\t\t    !port_cntr_ops[i].ops.write ?\n\t\t\t\t\t\t    S_IRUGO :\n\t\t\t\t\t\t    S_IRUGO | S_IWUSR,\n\t\t\t\t\t    root, ppd, &port_cntr_ops[i].ops);\n\t\t}\n\n\thfi1_fault_init_debugfs(ibd);\n}\n\nvoid hfi1_dbg_ibdev_exit(struct hfi1_ibdev *ibd)\n{\n\tif (!hfi1_dbg_root)\n\t\tgoto out;\n\thfi1_fault_exit_debugfs(ibd);\n\tdebugfs_remove(ibd->hfi1_ibdev_link);\n\tdebugfs_remove_recursive(ibd->hfi1_ibdev_dbg);\nout:\n\tibd->hfi1_ibdev_dbg = NULL;\n}\n\n \nstatic const char * const hfi1_statnames[] = {\n\t \n\t\"KernIntr\",\n\t\"ErrorIntr\",\n\t\"Tx_Errs\",\n\t\"Rcv_Errs\",\n\t\"H/W_Errs\",\n\t\"NoPIOBufs\",\n\t\"CtxtsOpen\",\n\t\"RcvLen_Errs\",\n\t\"EgrBufFull\",\n\t\"EgrHdrFull\"\n};\n\nstatic void *_driver_stats_names_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tif (*pos >= ARRAY_SIZE(hfi1_statnames))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_driver_stats_names_seq_next(\n\tstruct seq_file *s,\n\tvoid *v,\n\tloff_t *pos)\n{\n\t++*pos;\n\tif (*pos >= ARRAY_SIZE(hfi1_statnames))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _driver_stats_names_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic int _driver_stats_names_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos = v;\n\n\tseq_printf(s, \"%s\\n\", hfi1_statnames[*spos]);\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(driver_stats_names);\nDEBUGFS_SEQ_FILE_OPEN(driver_stats_names)\nDEBUGFS_FILE_OPS(driver_stats_names);\n\nstatic void *_driver_stats_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tif (*pos >= ARRAY_SIZE(hfi1_statnames))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void *_driver_stats_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\t++*pos;\n\tif (*pos >= ARRAY_SIZE(hfi1_statnames))\n\t\treturn NULL;\n\treturn pos;\n}\n\nstatic void _driver_stats_seq_stop(struct seq_file *s, void *v)\n{\n}\n\nstatic void hfi1_sps_show_ints(struct seq_file *s)\n{\n\tunsigned long index, flags;\n\tstruct hfi1_devdata *dd;\n\tu64 sps_ints = 0;\n\n\txa_lock_irqsave(&hfi1_dev_table, flags);\n\txa_for_each(&hfi1_dev_table, index, dd) {\n\t\tsps_ints += get_all_cpu_total(dd->int_counter);\n\t}\n\txa_unlock_irqrestore(&hfi1_dev_table, flags);\n\tseq_write(s, &sps_ints, sizeof(u64));\n}\n\nstatic int _driver_stats_seq_show(struct seq_file *s, void *v)\n{\n\tloff_t *spos = v;\n\tu64 *stats = (u64 *)&hfi1_stats;\n\n\t \n\tif (*spos == 0)\n\t\thfi1_sps_show_ints(s);\n\telse\n\t\tseq_write(s, stats + *spos, sizeof(u64));\n\treturn 0;\n}\n\nDEBUGFS_SEQ_FILE_OPS(driver_stats);\nDEBUGFS_SEQ_FILE_OPEN(driver_stats)\nDEBUGFS_FILE_OPS(driver_stats);\n\nvoid hfi1_dbg_init(void)\n{\n\thfi1_dbg_root  = debugfs_create_dir(DRIVER_NAME, NULL);\n\tdebugfs_create_file(\"driver_stats_names\", 0444, hfi1_dbg_root, NULL,\n\t\t\t    &_driver_stats_names_file_ops);\n\tdebugfs_create_file(\"driver_stats\", 0444, hfi1_dbg_root, NULL,\n\t\t\t    &_driver_stats_file_ops);\n}\n\nvoid hfi1_dbg_exit(void)\n{\n\tdebugfs_remove_recursive(hfi1_dbg_root);\n\thfi1_dbg_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}