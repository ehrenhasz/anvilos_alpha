{
  "module_name": "intr.c",
  "hash_id": "d589bb56a7110047cbdead9e1375df95fe6b0a571fddb5034c8f0c17aa12312e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/intr.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/bitmap.h>\n\n#include \"hfi.h\"\n#include \"common.h\"\n#include \"sdma.h\"\n\n#define LINK_UP_DELAY  500   \n\nstatic void set_mgmt_allowed(struct hfi1_pportdata *ppd)\n{\n\tu32 frame;\n\tstruct hfi1_devdata *dd = ppd->dd;\n\n\tif (ppd->neighbor_type == NEIGHBOR_TYPE_HFI) {\n\t\tppd->mgmt_allowed = 1;\n\t} else {\n\t\tread_8051_config(dd, REMOTE_LNI_INFO, GENERAL_CONFIG, &frame);\n\t\tppd->mgmt_allowed = (frame >> MGMT_ALLOWED_SHIFT)\n\t\t& MGMT_ALLOWED_MASK;\n\t}\n}\n\n \nstatic void add_full_mgmt_pkey(struct hfi1_pportdata *ppd)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\n\t \n\tif (!((ppd->pkeys[2] == 0) || (ppd->pkeys[2] == FULL_MGMT_P_KEY)))\n\t\tdd_dev_warn(dd, \"%s pkey[2] already set to 0x%x, resetting it to 0x%x\\n\",\n\t\t\t    __func__, ppd->pkeys[2], FULL_MGMT_P_KEY);\n\tppd->pkeys[2] = FULL_MGMT_P_KEY;\n\t(void)hfi1_set_ib_cfg(ppd, HFI1_IB_CFG_PKEYS, 0);\n\thfi1_event_pkey_change(ppd->dd, ppd->port);\n}\n\n \nstatic void format_hwmsg(char *msg, size_t msgl, const char *hwmsg)\n{\n\tstrlcat(msg, \"[\", msgl);\n\tstrlcat(msg, hwmsg, msgl);\n\tstrlcat(msg, \"]\", msgl);\n}\n\n \nvoid hfi1_format_hwerrors(u64 hwerrs, const struct hfi1_hwerror_msgs *hwerrmsgs,\n\t\t\t  size_t nhwerrmsgs, char *msg, size_t msgl)\n{\n\tint i;\n\n\tfor (i = 0; i < nhwerrmsgs; i++)\n\t\tif (hwerrs & hwerrmsgs[i].mask)\n\t\t\tformat_hwmsg(msg, msgl, hwerrmsgs[i].msg);\n}\n\nstatic void signal_ib_event(struct hfi1_pportdata *ppd, enum ib_event_type ev)\n{\n\tstruct ib_event event;\n\tstruct hfi1_devdata *dd = ppd->dd;\n\n\t \n\tif (!(dd->flags & HFI1_INITTED))\n\t\treturn;\n\tevent.device = &dd->verbs_dev.rdi.ibdev;\n\tevent.element.port_num = ppd->port;\n\tevent.event = ev;\n\tib_dispatch_event(&event);\n}\n\n \nvoid handle_linkup_change(struct hfi1_devdata *dd, u32 linkup)\n{\n\tstruct hfi1_pportdata *ppd = &dd->pport[0];\n\tenum ib_event_type ev;\n\n\tif (!(ppd->linkup ^ !!linkup))\n\t\treturn;\t \n\n\tif (linkup) {\n\t\t \n\t\tif (quick_linkup || dd->icode == ICODE_FUNCTIONAL_SIMULATOR) {\n\t\t\tset_up_vau(dd, dd->vau);\n\t\t\tset_up_vl15(dd, dd->vl15_init);\n\t\t\tassign_remote_cm_au_table(dd, dd->vcu);\n\t\t}\n\n\t\tppd->neighbor_guid =\n\t\t\tread_csr(dd, DC_DC8051_STS_REMOTE_GUID);\n\t\tppd->neighbor_type =\n\t\t\tread_csr(dd, DC_DC8051_STS_REMOTE_NODE_TYPE) &\n\t\t\t\t DC_DC8051_STS_REMOTE_NODE_TYPE_VAL_MASK;\n\t\tppd->neighbor_port_number =\n\t\t\tread_csr(dd, DC_DC8051_STS_REMOTE_PORT_NO) &\n\t\t\t\t DC_DC8051_STS_REMOTE_PORT_NO_VAL_SMASK;\n\t\tppd->neighbor_fm_security =\n\t\t\tread_csr(dd, DC_DC8051_STS_REMOTE_FM_SECURITY) &\n\t\t\t\t DC_DC8051_STS_LOCAL_FM_SECURITY_DISABLED_MASK;\n\t\tdd_dev_info(dd,\n\t\t\t    \"Neighbor Guid %llx, Type %d, Port Num %d\\n\",\n\t\t\t    ppd->neighbor_guid, ppd->neighbor_type,\n\t\t\t    ppd->neighbor_port_number);\n\n\t\t \n\t\tudelay(LINK_UP_DELAY);\n\n\t\t \n\t\tset_mgmt_allowed(ppd);\n\n\t\tif (ppd->mgmt_allowed)\n\t\t\tadd_full_mgmt_pkey(ppd);\n\n\t\t \n\t\tppd->linkup = 1;\n\t\tppd->offline_disabled_reason =\n\t\t\tHFI1_ODR_MASK(OPA_LINKDOWN_REASON_NONE);\n\n\t\t \n\t\tget_linkup_link_widths(ppd);\n\n\t} else {\n\t\t \n\t\tppd->linkup = 0;\n\n\t\t \n\t\tppd->actual_vls_operational = 0;\n\t\treset_link_credits(dd);\n\n\t\t \n\t\tstart_freeze_handling(ppd, FREEZE_SELF | FREEZE_LINK_DOWN);\n\n\t\tev = IB_EVENT_PORT_ERR;\n\n\t\thfi1_set_uevent_bits(ppd, _HFI1_EVENT_LINKDOWN_BIT);\n\n\t\t \n\t\tppd->neighbor_normal = 0;\n\n\t\t \n\t\tsignal_ib_event(ppd, ev);\n\t}\n}\n\n \nvoid handle_user_interrupt(struct hfi1_ctxtdata *rcd)\n{\n\tstruct hfi1_devdata *dd = rcd->dd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\tif (bitmap_empty(rcd->in_use_ctxts, HFI1_MAX_SHARED_CTXTS))\n\t\tgoto done;\n\n\tif (test_and_clear_bit(HFI1_CTXT_WAITING_RCV, &rcd->event_flags)) {\n\t\twake_up_interruptible(&rcd->wait);\n\t\thfi1_rcvctrl(dd, HFI1_RCVCTRL_INTRAVAIL_DIS, rcd);\n\t} else if (test_and_clear_bit(HFI1_CTXT_WAITING_URG,\n\t\t\t\t\t\t\t&rcd->event_flags)) {\n\t\trcd->urgent++;\n\t\twake_up_interruptible(&rcd->wait);\n\t}\ndone:\n\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}