{
  "module_name": "sysfs.c",
  "hash_id": "da3d7ff9009f886d2082af5a67eb5e7a1eaf3bcdf111b6a94081d4f19a2c4c5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/ctype.h>\n#include <rdma/ib_sysfs.h>\n\n#include \"hfi.h\"\n#include \"mad.h\"\n#include \"trace.h\"\n\nstatic struct hfi1_pportdata *hfi1_get_pportdata_kobj(struct kobject *kobj)\n{\n\tu32 port_num;\n\tstruct ib_device *ibdev = ib_port_sysfs_get_ibdev_kobj(kobj, &port_num);\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\n\treturn &dd->pport[port_num - 1];\n}\n\n \n\n \nstatic ssize_t cc_table_bin_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t loff_t pos, size_t count)\n{\n\tint ret;\n\tstruct hfi1_pportdata *ppd = hfi1_get_pportdata_kobj(kobj);\n\tstruct cc_state *cc_state;\n\n\tret = ppd->total_cct_entry * sizeof(struct ib_cc_table_entry_shadow)\n\t\t + sizeof(__be16);\n\n\tif (pos > ret)\n\t\treturn -EINVAL;\n\n\tif (count > ret - pos)\n\t\tcount = ret - pos;\n\n\tif (!count)\n\t\treturn count;\n\n\trcu_read_lock();\n\tcc_state = get_cc_state(ppd);\n\tif (!cc_state) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf, (void *)&cc_state->cct + pos, count);\n\trcu_read_unlock();\n\n\treturn count;\n}\nstatic BIN_ATTR_RO(cc_table_bin, PAGE_SIZE);\n\n \nstatic ssize_t cc_setting_bin_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr,\n\t\t\t\t   char *buf, loff_t pos, size_t count)\n{\n\tstruct hfi1_pportdata *ppd = hfi1_get_pportdata_kobj(kobj);\n\tint ret;\n\tstruct cc_state *cc_state;\n\n\tret = sizeof(struct opa_congestion_setting_attr_shadow);\n\n\tif (pos > ret)\n\t\treturn -EINVAL;\n\tif (count > ret - pos)\n\t\tcount = ret - pos;\n\n\tif (!count)\n\t\treturn count;\n\n\trcu_read_lock();\n\tcc_state = get_cc_state(ppd);\n\tif (!cc_state) {\n\t\trcu_read_unlock();\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(buf, (void *)&cc_state->cong_setting + pos, count);\n\trcu_read_unlock();\n\n\treturn count;\n}\nstatic BIN_ATTR_RO(cc_setting_bin, PAGE_SIZE);\n\nstatic struct bin_attribute *port_cc_bin_attributes[] = {\n\t&bin_attr_cc_setting_bin,\n\t&bin_attr_cc_table_bin,\n\tNULL\n};\n\nstatic ssize_t cc_prescan_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct hfi1_pportdata *ppd = &dd->pport[port_num - 1];\n\n\treturn sysfs_emit(buf, \"%s\\n\", ppd->cc_prescan ? \"on\" : \"off\");\n}\n\nstatic ssize_t cc_prescan_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\tstruct ib_port_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct hfi1_pportdata *ppd = &dd->pport[port_num - 1];\n\n\tif (!memcmp(buf, \"on\", 2))\n\t\tppd->cc_prescan = true;\n\telse if (!memcmp(buf, \"off\", 3))\n\t\tppd->cc_prescan = false;\n\n\treturn count;\n}\nstatic IB_PORT_ATTR_ADMIN_RW(cc_prescan);\n\nstatic struct attribute *port_cc_attributes[] = {\n\t&ib_port_attr_cc_prescan.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_cc_group = {\n\t.name = \"CCMgtA\",\n\t.attrs = port_cc_attributes,\n\t.bin_attrs = port_cc_bin_attributes,\n};\n\n \nstruct hfi1_sc2vl_attr {\n\tstruct ib_port_attribute attr;\n\tint sc;\n};\n\nstatic ssize_t sc2vl_attr_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct hfi1_sc2vl_attr *sattr =\n\t\tcontainer_of(attr, struct hfi1_sc2vl_attr, attr);\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", *((u8 *)dd->sc2vl + sattr->sc));\n}\n\n#define HFI1_SC2VL_ATTR(N)                                                     \\\n\tstatic struct hfi1_sc2vl_attr hfi1_sc2vl_attr_##N = {                  \\\n\t\t.attr = __ATTR(N, 0444, sc2vl_attr_show, NULL),                \\\n\t\t.sc = N,                                                       \\\n\t}\n\nHFI1_SC2VL_ATTR(0);\nHFI1_SC2VL_ATTR(1);\nHFI1_SC2VL_ATTR(2);\nHFI1_SC2VL_ATTR(3);\nHFI1_SC2VL_ATTR(4);\nHFI1_SC2VL_ATTR(5);\nHFI1_SC2VL_ATTR(6);\nHFI1_SC2VL_ATTR(7);\nHFI1_SC2VL_ATTR(8);\nHFI1_SC2VL_ATTR(9);\nHFI1_SC2VL_ATTR(10);\nHFI1_SC2VL_ATTR(11);\nHFI1_SC2VL_ATTR(12);\nHFI1_SC2VL_ATTR(13);\nHFI1_SC2VL_ATTR(14);\nHFI1_SC2VL_ATTR(15);\nHFI1_SC2VL_ATTR(16);\nHFI1_SC2VL_ATTR(17);\nHFI1_SC2VL_ATTR(18);\nHFI1_SC2VL_ATTR(19);\nHFI1_SC2VL_ATTR(20);\nHFI1_SC2VL_ATTR(21);\nHFI1_SC2VL_ATTR(22);\nHFI1_SC2VL_ATTR(23);\nHFI1_SC2VL_ATTR(24);\nHFI1_SC2VL_ATTR(25);\nHFI1_SC2VL_ATTR(26);\nHFI1_SC2VL_ATTR(27);\nHFI1_SC2VL_ATTR(28);\nHFI1_SC2VL_ATTR(29);\nHFI1_SC2VL_ATTR(30);\nHFI1_SC2VL_ATTR(31);\n\nstatic struct attribute *port_sc2vl_attributes[] = {\n\t&hfi1_sc2vl_attr_0.attr.attr,\n\t&hfi1_sc2vl_attr_1.attr.attr,\n\t&hfi1_sc2vl_attr_2.attr.attr,\n\t&hfi1_sc2vl_attr_3.attr.attr,\n\t&hfi1_sc2vl_attr_4.attr.attr,\n\t&hfi1_sc2vl_attr_5.attr.attr,\n\t&hfi1_sc2vl_attr_6.attr.attr,\n\t&hfi1_sc2vl_attr_7.attr.attr,\n\t&hfi1_sc2vl_attr_8.attr.attr,\n\t&hfi1_sc2vl_attr_9.attr.attr,\n\t&hfi1_sc2vl_attr_10.attr.attr,\n\t&hfi1_sc2vl_attr_11.attr.attr,\n\t&hfi1_sc2vl_attr_12.attr.attr,\n\t&hfi1_sc2vl_attr_13.attr.attr,\n\t&hfi1_sc2vl_attr_14.attr.attr,\n\t&hfi1_sc2vl_attr_15.attr.attr,\n\t&hfi1_sc2vl_attr_16.attr.attr,\n\t&hfi1_sc2vl_attr_17.attr.attr,\n\t&hfi1_sc2vl_attr_18.attr.attr,\n\t&hfi1_sc2vl_attr_19.attr.attr,\n\t&hfi1_sc2vl_attr_20.attr.attr,\n\t&hfi1_sc2vl_attr_21.attr.attr,\n\t&hfi1_sc2vl_attr_22.attr.attr,\n\t&hfi1_sc2vl_attr_23.attr.attr,\n\t&hfi1_sc2vl_attr_24.attr.attr,\n\t&hfi1_sc2vl_attr_25.attr.attr,\n\t&hfi1_sc2vl_attr_26.attr.attr,\n\t&hfi1_sc2vl_attr_27.attr.attr,\n\t&hfi1_sc2vl_attr_28.attr.attr,\n\t&hfi1_sc2vl_attr_29.attr.attr,\n\t&hfi1_sc2vl_attr_30.attr.attr,\n\t&hfi1_sc2vl_attr_31.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_sc2vl_group = {\n\t.name = \"sc2vl\",\n\t.attrs = port_sc2vl_attributes,\n};\n \n\n \nstruct hfi1_sl2sc_attr {\n\tstruct ib_port_attribute attr;\n\tint sl;\n};\n\nstatic ssize_t sl2sc_attr_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct hfi1_sl2sc_attr *sattr =\n\t\tcontainer_of(attr, struct hfi1_sl2sc_attr, attr);\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct hfi1_ibport *ibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%u\\n\", ibp->sl_to_sc[sattr->sl]);\n}\n\n#define HFI1_SL2SC_ATTR(N)                                                     \\\n\tstatic struct hfi1_sl2sc_attr hfi1_sl2sc_attr_##N = {                  \\\n\t\t.attr = __ATTR(N, 0444, sl2sc_attr_show, NULL), .sl = N        \\\n\t}\n\nHFI1_SL2SC_ATTR(0);\nHFI1_SL2SC_ATTR(1);\nHFI1_SL2SC_ATTR(2);\nHFI1_SL2SC_ATTR(3);\nHFI1_SL2SC_ATTR(4);\nHFI1_SL2SC_ATTR(5);\nHFI1_SL2SC_ATTR(6);\nHFI1_SL2SC_ATTR(7);\nHFI1_SL2SC_ATTR(8);\nHFI1_SL2SC_ATTR(9);\nHFI1_SL2SC_ATTR(10);\nHFI1_SL2SC_ATTR(11);\nHFI1_SL2SC_ATTR(12);\nHFI1_SL2SC_ATTR(13);\nHFI1_SL2SC_ATTR(14);\nHFI1_SL2SC_ATTR(15);\nHFI1_SL2SC_ATTR(16);\nHFI1_SL2SC_ATTR(17);\nHFI1_SL2SC_ATTR(18);\nHFI1_SL2SC_ATTR(19);\nHFI1_SL2SC_ATTR(20);\nHFI1_SL2SC_ATTR(21);\nHFI1_SL2SC_ATTR(22);\nHFI1_SL2SC_ATTR(23);\nHFI1_SL2SC_ATTR(24);\nHFI1_SL2SC_ATTR(25);\nHFI1_SL2SC_ATTR(26);\nHFI1_SL2SC_ATTR(27);\nHFI1_SL2SC_ATTR(28);\nHFI1_SL2SC_ATTR(29);\nHFI1_SL2SC_ATTR(30);\nHFI1_SL2SC_ATTR(31);\n\nstatic struct attribute *port_sl2sc_attributes[] = {\n\t&hfi1_sl2sc_attr_0.attr.attr,\n\t&hfi1_sl2sc_attr_1.attr.attr,\n\t&hfi1_sl2sc_attr_2.attr.attr,\n\t&hfi1_sl2sc_attr_3.attr.attr,\n\t&hfi1_sl2sc_attr_4.attr.attr,\n\t&hfi1_sl2sc_attr_5.attr.attr,\n\t&hfi1_sl2sc_attr_6.attr.attr,\n\t&hfi1_sl2sc_attr_7.attr.attr,\n\t&hfi1_sl2sc_attr_8.attr.attr,\n\t&hfi1_sl2sc_attr_9.attr.attr,\n\t&hfi1_sl2sc_attr_10.attr.attr,\n\t&hfi1_sl2sc_attr_11.attr.attr,\n\t&hfi1_sl2sc_attr_12.attr.attr,\n\t&hfi1_sl2sc_attr_13.attr.attr,\n\t&hfi1_sl2sc_attr_14.attr.attr,\n\t&hfi1_sl2sc_attr_15.attr.attr,\n\t&hfi1_sl2sc_attr_16.attr.attr,\n\t&hfi1_sl2sc_attr_17.attr.attr,\n\t&hfi1_sl2sc_attr_18.attr.attr,\n\t&hfi1_sl2sc_attr_19.attr.attr,\n\t&hfi1_sl2sc_attr_20.attr.attr,\n\t&hfi1_sl2sc_attr_21.attr.attr,\n\t&hfi1_sl2sc_attr_22.attr.attr,\n\t&hfi1_sl2sc_attr_23.attr.attr,\n\t&hfi1_sl2sc_attr_24.attr.attr,\n\t&hfi1_sl2sc_attr_25.attr.attr,\n\t&hfi1_sl2sc_attr_26.attr.attr,\n\t&hfi1_sl2sc_attr_27.attr.attr,\n\t&hfi1_sl2sc_attr_28.attr.attr,\n\t&hfi1_sl2sc_attr_29.attr.attr,\n\t&hfi1_sl2sc_attr_30.attr.attr,\n\t&hfi1_sl2sc_attr_31.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_sl2sc_group = {\n\t.name = \"sl2sc\",\n\t.attrs = port_sl2sc_attributes,\n};\n\n \n\n \n\nstruct hfi1_vl2mtu_attr {\n\tstruct ib_port_attribute attr;\n\tint vl;\n};\n\nstatic ssize_t vl2mtu_attr_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t\tstruct ib_port_attribute *attr, char *buf)\n{\n\tstruct hfi1_vl2mtu_attr *vlattr =\n\t\tcontainer_of(attr, struct hfi1_vl2mtu_attr, attr);\n\tstruct hfi1_devdata *dd = dd_from_ibdev(ibdev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", dd->vld[vlattr->vl].mtu);\n}\n\n#define HFI1_VL2MTU_ATTR(N)                                                    \\\n\tstatic struct hfi1_vl2mtu_attr hfi1_vl2mtu_attr_##N = {                \\\n\t\t.attr = __ATTR(N, 0444, vl2mtu_attr_show, NULL),               \\\n\t\t.vl = N,                                                       \\\n\t}\n\nHFI1_VL2MTU_ATTR(0);\nHFI1_VL2MTU_ATTR(1);\nHFI1_VL2MTU_ATTR(2);\nHFI1_VL2MTU_ATTR(3);\nHFI1_VL2MTU_ATTR(4);\nHFI1_VL2MTU_ATTR(5);\nHFI1_VL2MTU_ATTR(6);\nHFI1_VL2MTU_ATTR(7);\nHFI1_VL2MTU_ATTR(8);\nHFI1_VL2MTU_ATTR(9);\nHFI1_VL2MTU_ATTR(10);\nHFI1_VL2MTU_ATTR(11);\nHFI1_VL2MTU_ATTR(12);\nHFI1_VL2MTU_ATTR(13);\nHFI1_VL2MTU_ATTR(14);\nHFI1_VL2MTU_ATTR(15);\n\nstatic struct attribute *port_vl2mtu_attributes[] = {\n\t&hfi1_vl2mtu_attr_0.attr.attr,\n\t&hfi1_vl2mtu_attr_1.attr.attr,\n\t&hfi1_vl2mtu_attr_2.attr.attr,\n\t&hfi1_vl2mtu_attr_3.attr.attr,\n\t&hfi1_vl2mtu_attr_4.attr.attr,\n\t&hfi1_vl2mtu_attr_5.attr.attr,\n\t&hfi1_vl2mtu_attr_6.attr.attr,\n\t&hfi1_vl2mtu_attr_7.attr.attr,\n\t&hfi1_vl2mtu_attr_8.attr.attr,\n\t&hfi1_vl2mtu_attr_9.attr.attr,\n\t&hfi1_vl2mtu_attr_10.attr.attr,\n\t&hfi1_vl2mtu_attr_11.attr.attr,\n\t&hfi1_vl2mtu_attr_12.attr.attr,\n\t&hfi1_vl2mtu_attr_13.attr.attr,\n\t&hfi1_vl2mtu_attr_14.attr.attr,\n\t&hfi1_vl2mtu_attr_15.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_vl2mtu_group = {\n\t.name = \"vl2mtu\",\n\t.attrs = port_vl2mtu_attributes,\n};\n\n \n\n \nstatic ssize_t hw_rev_show(struct device *device, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", dd_from_dev(dev)->minrev);\n}\nstatic DEVICE_ATTR_RO(hw_rev);\n\nstatic ssize_t board_id_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\n\tif (!dd->boardname)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"%s\\n\", dd->boardname);\n}\nstatic DEVICE_ATTR_RO(board_id);\n\nstatic ssize_t boardversion_show(struct device *device,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%s\", dd->boardversion);\n}\nstatic DEVICE_ATTR_RO(boardversion);\n\nstatic ssize_t nctxts_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  min(dd->num_user_contexts,\n\t\t\t      (u32)dd->sc_sizes[SC_USER].count));\n}\nstatic DEVICE_ATTR_RO(nctxts);\n\nstatic ssize_t nfreectxts_show(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%u\\n\", dd->freectxts);\n}\nstatic DEVICE_ATTR_RO(nfreectxts);\n\nstatic ssize_t serial_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%s\", dd->serial);\n}\nstatic DEVICE_ATTR_RO(serial);\n\nstatic ssize_t chip_reset_store(struct device *device,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\tint ret;\n\n\tif (count < 5 || memcmp(buf, \"reset\", 5) || !dd->diag_client) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tret = hfi1_reset_device(dd->unit);\nbail:\n\treturn ret < 0 ? ret : count;\n}\nstatic DEVICE_ATTR_WO(chip_reset);\n\n \n#define temp_d(t) ((t) >> 2)\n#define temp_f(t) (((t)&0x3) * 25u)\n\n \nstatic ssize_t tempsense_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct hfi1_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct hfi1_ibdev, rdi.ibdev);\n\tstruct hfi1_devdata *dd = dd_from_dev(dev);\n\tstruct hfi1_temp temp;\n\tint ret;\n\n\tret = hfi1_tempsense_rd(dd, &temp);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%u.%02u %u.%02u %u.%02u %u.%02u %u %u %u\\n\",\n\t\t\t  temp_d(temp.curr), temp_f(temp.curr),\n\t\t\t  temp_d(temp.lo_lim), temp_f(temp.lo_lim),\n\t\t\t  temp_d(temp.hi_lim), temp_f(temp.hi_lim),\n\t\t\t  temp_d(temp.crit_lim), temp_f(temp.crit_lim),\n\t\t\t  temp.triggers & 0x1,\n\t\t\t  temp.triggers & 0x2,\n\t\t\t  temp.triggers & 0x4);\n}\nstatic DEVICE_ATTR_RO(tempsense);\n\n \n\n \nstatic struct attribute *hfi1_attributes[] = {\n\t&dev_attr_hw_rev.attr,\n\t&dev_attr_board_id.attr,\n\t&dev_attr_nctxts.attr,\n\t&dev_attr_nfreectxts.attr,\n\t&dev_attr_serial.attr,\n\t&dev_attr_boardversion.attr,\n\t&dev_attr_tempsense.attr,\n\t&dev_attr_chip_reset.attr,\n\tNULL,\n};\n\nconst struct attribute_group ib_hfi1_attr_group = {\n\t.attrs = hfi1_attributes,\n};\n\nconst struct attribute_group *hfi1_attr_port_groups[] = {\n\t&port_cc_group,\n\t&port_sc2vl_group,\n\t&port_sl2sc_group,\n\t&port_vl2mtu_group,\n\tNULL,\n};\n\nstruct sde_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct sdma_engine *sde, char *buf);\n\tssize_t (*store)(struct sdma_engine *sde, const char *buf, size_t cnt);\n};\n\nstatic ssize_t sde_show(struct kobject *kobj, struct attribute *attr, char *buf)\n{\n\tstruct sde_attribute *sde_attr =\n\t\tcontainer_of(attr, struct sde_attribute, attr);\n\tstruct sdma_engine *sde =\n\t\tcontainer_of(kobj, struct sdma_engine, kobj);\n\n\tif (!sde_attr->show)\n\t\treturn -EINVAL;\n\n\treturn sde_attr->show(sde, buf);\n}\n\nstatic ssize_t sde_store(struct kobject *kobj, struct attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct sde_attribute *sde_attr =\n\t\tcontainer_of(attr, struct sde_attribute, attr);\n\tstruct sdma_engine *sde =\n\t\tcontainer_of(kobj, struct sdma_engine, kobj);\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (!sde_attr->store)\n\t\treturn -EINVAL;\n\n\treturn sde_attr->store(sde, buf, count);\n}\n\nstatic const struct sysfs_ops sde_sysfs_ops = {\n\t.show = sde_show,\n\t.store = sde_store,\n};\n\nstatic struct kobj_type sde_ktype = {\n\t.sysfs_ops = &sde_sysfs_ops,\n};\n\n#define SDE_ATTR(_name, _mode, _show, _store) \\\n\tstruct sde_attribute sde_attr_##_name = \\\n\t\t__ATTR(_name, _mode, _show, _store)\n\nstatic ssize_t sde_show_cpu_to_sde_map(struct sdma_engine *sde, char *buf)\n{\n\treturn sdma_get_cpu_to_sde_map(sde, buf);\n}\n\nstatic ssize_t sde_store_cpu_to_sde_map(struct sdma_engine *sde,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\treturn sdma_set_cpu_to_sde_map(sde, buf, count);\n}\n\nstatic ssize_t sde_show_vl(struct sdma_engine *sde, char *buf)\n{\n\tint vl;\n\n\tvl = sdma_engine_get_vl(sde);\n\tif (vl < 0)\n\t\treturn vl;\n\n\treturn sysfs_emit(buf, \"%d\\n\", vl);\n}\n\nstatic SDE_ATTR(cpu_list, S_IWUSR | S_IRUGO,\n\t\tsde_show_cpu_to_sde_map,\n\t\tsde_store_cpu_to_sde_map);\nstatic SDE_ATTR(vl, S_IRUGO, sde_show_vl, NULL);\n\nstatic struct sde_attribute *sde_attribs[] = {\n\t&sde_attr_cpu_list,\n\t&sde_attr_vl\n};\n\n \nint hfi1_verbs_register_sysfs(struct hfi1_devdata *dd)\n{\n\tstruct ib_device *dev = &dd->verbs_dev.rdi.ibdev;\n\tstruct device *class_dev = &dev->dev;\n\tint i, j, ret;\n\n\tfor (i = 0; i < dd->num_sdma; i++) {\n\t\tret = kobject_init_and_add(&dd->per_sdma[i].kobj,\n\t\t\t\t\t   &sde_ktype, &class_dev->kobj,\n\t\t\t\t\t   \"sdma%d\", i);\n\t\tif (ret)\n\t\t\tgoto bail;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(sde_attribs); j++) {\n\t\t\tret = sysfs_create_file(&dd->per_sdma[i].kobj,\n\t\t\t\t\t\t&sde_attribs[j]->attr);\n\t\t\tif (ret)\n\t\t\t\tgoto bail;\n\t\t}\n\t}\n\n\treturn 0;\nbail:\n\t \n\tfor (; i >= 0; i--)\n\t\tkobject_put(&dd->per_sdma[i].kobj);\n\n\treturn ret;\n}\n\n \nvoid hfi1_verbs_unregister_sysfs(struct hfi1_devdata *dd)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < dd->num_sdma; i++)\n\t\tkobject_put(&dd->per_sdma[i].kobj);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}