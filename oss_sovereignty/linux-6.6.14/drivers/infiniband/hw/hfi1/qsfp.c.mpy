{
  "module_name": "qsfp.c",
  "hash_id": "e72f7106d7a8c49637daa360135b0461af58849297c40ee27be635071fbaae5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/qsfp.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include \"hfi.h\"\n\n \nstatic inline u32 i2c_in_csr(u32 bus_num)\n{\n\treturn bus_num ? ASIC_QSFP2_IN : ASIC_QSFP1_IN;\n}\n\n \nstatic inline u32 i2c_oe_csr(u32 bus_num)\n{\n\treturn bus_num ? ASIC_QSFP2_OE : ASIC_QSFP1_OE;\n}\n\nstatic void hfi1_setsda(void *data, int state)\n{\n\tstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\n\tstruct hfi1_devdata *dd = bus->controlling_dd;\n\tu64 reg;\n\tu32 target_oe;\n\n\ttarget_oe = i2c_oe_csr(bus->num);\n\treg = read_csr(dd, target_oe);\n\t \n\tif (state)\n\t\treg &= ~QSFP_HFI0_I2CDAT;\n\telse\n\t\treg |= QSFP_HFI0_I2CDAT;\n\twrite_csr(dd, target_oe, reg);\n\t \n\t(void)read_csr(dd, target_oe);\n}\n\nstatic void hfi1_setscl(void *data, int state)\n{\n\tstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\n\tstruct hfi1_devdata *dd = bus->controlling_dd;\n\tu64 reg;\n\tu32 target_oe;\n\n\ttarget_oe = i2c_oe_csr(bus->num);\n\treg = read_csr(dd, target_oe);\n\t \n\tif (state)\n\t\treg &= ~QSFP_HFI0_I2CCLK;\n\telse\n\t\treg |= QSFP_HFI0_I2CCLK;\n\twrite_csr(dd, target_oe, reg);\n\t \n\t(void)read_csr(dd, target_oe);\n}\n\nstatic int hfi1_getsda(void *data)\n{\n\tstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\n\tu64 reg;\n\tu32 target_in;\n\n\thfi1_setsda(data, 1);\t \n\tudelay(2);\t\t \n\n\ttarget_in = i2c_in_csr(bus->num);\n\treg = read_csr(bus->controlling_dd, target_in);\n\treturn !!(reg & QSFP_HFI0_I2CDAT);\n}\n\nstatic int hfi1_getscl(void *data)\n{\n\tstruct hfi1_i2c_bus *bus = (struct hfi1_i2c_bus *)data;\n\tu64 reg;\n\tu32 target_in;\n\n\thfi1_setscl(data, 1);\t \n\tudelay(2);\t\t \n\n\ttarget_in = i2c_in_csr(bus->num);\n\treg = read_csr(bus->controlling_dd, target_in);\n\treturn !!(reg & QSFP_HFI0_I2CCLK);\n}\n\n \nstatic struct hfi1_i2c_bus *init_i2c_bus(struct hfi1_devdata *dd,\n\t\t\t\t\t struct hfi1_asic_data *ad, int num)\n{\n\tstruct hfi1_i2c_bus *bus;\n\tint ret;\n\n\tbus = kzalloc(sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn NULL;\n\n\tbus->controlling_dd = dd;\n\tbus->num = num;\t \n\n\tbus->algo.setsda = hfi1_setsda;\n\tbus->algo.setscl = hfi1_setscl;\n\tbus->algo.getsda = hfi1_getsda;\n\tbus->algo.getscl = hfi1_getscl;\n\tbus->algo.udelay = 5;\n\tbus->algo.timeout = usecs_to_jiffies(100000);\n\tbus->algo.data = bus;\n\n\tbus->adapter.owner = THIS_MODULE;\n\tbus->adapter.algo_data = &bus->algo;\n\tbus->adapter.dev.parent = &dd->pcidev->dev;\n\tsnprintf(bus->adapter.name, sizeof(bus->adapter.name),\n\t\t \"hfi1_i2c%d\", num);\n\n\tret = i2c_bit_add_bus(&bus->adapter);\n\tif (ret) {\n\t\tdd_dev_info(dd, \"%s: unable to add i2c bus %d, err %d\\n\",\n\t\t\t    __func__, num, ret);\n\t\tkfree(bus);\n\t\treturn NULL;\n\t}\n\n\treturn bus;\n}\n\n \nint set_up_i2c(struct hfi1_devdata *dd, struct hfi1_asic_data *ad)\n{\n\tad->i2c_bus0 = init_i2c_bus(dd, ad, 0);\n\tad->i2c_bus1 = init_i2c_bus(dd, ad, 1);\n\tif (!ad->i2c_bus0 || !ad->i2c_bus1)\n\t\treturn -ENOMEM;\n\treturn 0;\n};\n\nstatic void clean_i2c_bus(struct hfi1_i2c_bus *bus)\n{\n\tif (bus) {\n\t\ti2c_del_adapter(&bus->adapter);\n\t\tkfree(bus);\n\t}\n}\n\nvoid clean_up_i2c(struct hfi1_devdata *dd, struct hfi1_asic_data *ad)\n{\n\tif (!ad)\n\t\treturn;\n\tclean_i2c_bus(ad->i2c_bus0);\n\tad->i2c_bus0 = NULL;\n\tclean_i2c_bus(ad->i2c_bus1);\n\tad->i2c_bus1 = NULL;\n}\n\nstatic int i2c_bus_write(struct hfi1_devdata *dd, struct hfi1_i2c_bus *i2c,\n\t\t\t u8 slave_addr, int offset, int offset_size,\n\t\t\t u8 *data, u16 len)\n{\n\tint ret;\n\tint num_msgs;\n\tu8 offset_bytes[2];\n\tstruct i2c_msg msgs[2];\n\n\tswitch (offset_size) {\n\tcase 0:\n\t\tnum_msgs = 1;\n\t\tmsgs[0].addr = slave_addr;\n\t\tmsgs[0].flags = 0;\n\t\tmsgs[0].len = len;\n\t\tmsgs[0].buf = data;\n\t\tbreak;\n\tcase 2:\n\t\toffset_bytes[1] = (offset >> 8) & 0xff;\n\t\tfallthrough;\n\tcase 1:\n\t\tnum_msgs = 2;\n\t\toffset_bytes[0] = offset & 0xff;\n\n\t\tmsgs[0].addr = slave_addr;\n\t\tmsgs[0].flags = 0;\n\t\tmsgs[0].len = offset_size;\n\t\tmsgs[0].buf = offset_bytes;\n\n\t\tmsgs[1].addr = slave_addr;\n\t\tmsgs[1].flags = I2C_M_NOSTART;\n\t\tmsgs[1].len = len;\n\t\tmsgs[1].buf = data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ti2c->controlling_dd = dd;\n\tret = i2c_transfer(&i2c->adapter, msgs, num_msgs);\n\tif (ret != num_msgs) {\n\t\tdd_dev_err(dd, \"%s: bus %d, i2c slave 0x%x, offset 0x%x, len 0x%x; write failed, ret %d\\n\",\n\t\t\t   __func__, i2c->num, slave_addr, offset, len, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int i2c_bus_read(struct hfi1_devdata *dd, struct hfi1_i2c_bus *bus,\n\t\t\tu8 slave_addr, int offset, int offset_size,\n\t\t\tu8 *data, u16 len)\n{\n\tint ret;\n\tint num_msgs;\n\tu8 offset_bytes[2];\n\tstruct i2c_msg msgs[2];\n\n\tswitch (offset_size) {\n\tcase 0:\n\t\tnum_msgs = 1;\n\t\tmsgs[0].addr = slave_addr;\n\t\tmsgs[0].flags = I2C_M_RD;\n\t\tmsgs[0].len = len;\n\t\tmsgs[0].buf = data;\n\t\tbreak;\n\tcase 2:\n\t\toffset_bytes[1] = (offset >> 8) & 0xff;\n\t\tfallthrough;\n\tcase 1:\n\t\tnum_msgs = 2;\n\t\toffset_bytes[0] = offset & 0xff;\n\n\t\tmsgs[0].addr = slave_addr;\n\t\tmsgs[0].flags = 0;\n\t\tmsgs[0].len = offset_size;\n\t\tmsgs[0].buf = offset_bytes;\n\n\t\tmsgs[1].addr = slave_addr;\n\t\tmsgs[1].flags = I2C_M_RD;\n\t\tmsgs[1].len = len;\n\t\tmsgs[1].buf = data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tbus->controlling_dd = dd;\n\tret = i2c_transfer(&bus->adapter, msgs, num_msgs);\n\tif (ret != num_msgs) {\n\t\tdd_dev_err(dd, \"%s: bus %d, i2c slave 0x%x, offset 0x%x, len 0x%x; read failed, ret %d\\n\",\n\t\t\t   __func__, bus->num, slave_addr, offset, len, ret);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\treturn 0;\n}\n\n \nstatic int __i2c_write(struct hfi1_pportdata *ppd, u32 target, int i2c_addr,\n\t\t       int offset, void *bp, int len)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tstruct hfi1_i2c_bus *bus;\n\tu8 slave_addr;\n\tint offset_size;\n\n\tbus = target ? dd->asic_data->i2c_bus1 : dd->asic_data->i2c_bus0;\n\tslave_addr = (i2c_addr & 0xff) >> 1;  \n\toffset_size = (i2c_addr >> 8) & 0x3;\n\treturn i2c_bus_write(dd, bus, slave_addr, offset, offset_size, bp, len);\n}\n\n \nint i2c_write(struct hfi1_pportdata *ppd, u32 target, int i2c_addr, int offset,\n\t      void *bp, int len)\n{\n\tint ret;\n\n\tif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\n\t\treturn -EACCES;\n\n\tret = __i2c_write(ppd, target, i2c_addr, offset, bp, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n \nstatic int __i2c_read(struct hfi1_pportdata *ppd, u32 target, int i2c_addr,\n\t\t      int offset, void *bp, int len)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tstruct hfi1_i2c_bus *bus;\n\tu8 slave_addr;\n\tint offset_size;\n\n\tbus = target ? dd->asic_data->i2c_bus1 : dd->asic_data->i2c_bus0;\n\tslave_addr = (i2c_addr & 0xff) >> 1;  \n\toffset_size = (i2c_addr >> 8) & 0x3;\n\treturn i2c_bus_read(dd, bus, slave_addr, offset, offset_size, bp, len);\n}\n\n \nint i2c_read(struct hfi1_pportdata *ppd, u32 target, int i2c_addr, int offset,\n\t     void *bp, int len)\n{\n\tint ret;\n\n\tif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\n\t\treturn -EACCES;\n\n\tret = __i2c_read(ppd, target, i2c_addr, offset, bp, len);\n\tif (ret)\n\t\treturn ret;\n\n\treturn len;\n}\n\n \nint qsfp_write(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\n\t       int len)\n{\n\tint count = 0;\n\tint offset;\n\tint nwrite;\n\tint ret = 0;\n\tu8 page;\n\n\tif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\n\t\treturn -EACCES;\n\n\twhile (count < len) {\n\t\t \n\t\tpage = (u8)(addr / QSFP_PAGESIZE);\n\n\t\tret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\n\t\t\t\t  QSFP_PAGE_SELECT_BYTE_OFFS, &page, 1);\n\t\t \n\t\tmdelay(5);\n\t\tif (ret) {\n\t\t\thfi1_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\t \"QSFP chain %d can't write QSFP_PAGE_SELECT_BYTE: %d\\n\",\n\t\t\t\t\t target, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = addr % QSFP_PAGESIZE;\n\t\tnwrite = len - count;\n\t\t \n\t\tif (((addr % QSFP_RW_BOUNDARY) + nwrite) > QSFP_RW_BOUNDARY)\n\t\t\tnwrite = QSFP_RW_BOUNDARY - (addr % QSFP_RW_BOUNDARY);\n\n\t\tret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\n\t\t\t\t  offset, bp + count, nwrite);\n\t\t \n\t\tmdelay(5);\n\t\tif (ret)\t \n\t\t\tbreak;\n\n\t\tcount += nwrite;\n\t\taddr += nwrite;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nint one_qsfp_write(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\n\t\t   int len)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tu32 resource = qsfp_resource(dd);\n\tint ret;\n\n\tret = acquire_chip_resource(dd, resource, QSFP_WAIT);\n\tif (ret)\n\t\treturn ret;\n\tret = qsfp_write(ppd, target, addr, bp, len);\n\trelease_chip_resource(dd, resource);\n\n\treturn ret;\n}\n\n \nint qsfp_read(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\n\t      int len)\n{\n\tint count = 0;\n\tint offset;\n\tint nread;\n\tint ret = 0;\n\tu8 page;\n\n\tif (!check_chip_resource(ppd->dd, i2c_target(target), __func__))\n\t\treturn -EACCES;\n\n\twhile (count < len) {\n\t\t \n\t\tpage = (u8)(addr / QSFP_PAGESIZE);\n\t\tret = __i2c_write(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\n\t\t\t\t  QSFP_PAGE_SELECT_BYTE_OFFS, &page, 1);\n\t\t \n\t\tmdelay(5);\n\t\tif (ret) {\n\t\t\thfi1_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\t \"QSFP chain %d can't write QSFP_PAGE_SELECT_BYTE: %d\\n\",\n\t\t\t\t\t target, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\toffset = addr % QSFP_PAGESIZE;\n\t\tnread = len - count;\n\t\t \n\t\tif (((addr % QSFP_RW_BOUNDARY) + nread) > QSFP_RW_BOUNDARY)\n\t\t\tnread = QSFP_RW_BOUNDARY - (addr % QSFP_RW_BOUNDARY);\n\n\t\tret = __i2c_read(ppd, target, QSFP_DEV | QSFP_OFFSET_SIZE,\n\t\t\t\t offset, bp + count, nread);\n\t\tif (ret)\t \n\t\t\tbreak;\n\n\t\tcount += nread;\n\t\taddr += nread;\n\t}\n\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\n \nint one_qsfp_read(struct hfi1_pportdata *ppd, u32 target, int addr, void *bp,\n\t\t  int len)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tu32 resource = qsfp_resource(dd);\n\tint ret;\n\n\tret = acquire_chip_resource(dd, resource, QSFP_WAIT);\n\tif (ret)\n\t\treturn ret;\n\tret = qsfp_read(ppd, target, addr, bp, len);\n\trelease_chip_resource(dd, resource);\n\n\treturn ret;\n}\n\n \nint refresh_qsfp_cache(struct hfi1_pportdata *ppd, struct qsfp_data *cp)\n{\n\tu32 target = ppd->dd->hfi1_id;\n\tint ret;\n\tunsigned long flags;\n\tu8 *cache = &cp->cache[0];\n\n\t \n\tmemset(cache, 0, (QSFP_MAX_NUM_PAGES * 128));\n\tspin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);\n\tppd->qsfp_info.cache_valid = 0;\n\tspin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock, flags);\n\n\tif (!qsfp_mod_present(ppd)) {\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tret = qsfp_read(ppd, target, 0, cache, QSFP_PAGESIZE);\n\tif (ret != QSFP_PAGESIZE) {\n\t\tdd_dev_info(ppd->dd,\n\t\t\t    \"%s: Page 0 read failed, expected %d, got %d\\n\",\n\t\t\t    __func__, QSFP_PAGESIZE, ret);\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!(cache[2] & 4)) {\n\t\t \n\t\tif ((cache[195] & 0xC0) == 0xC0) {\n\t\t\t \n\t\t\tret = qsfp_read(ppd, target, 384, cache + 256, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tret = qsfp_read(ppd, target, 640, cache + 384, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tret = qsfp_read(ppd, target, 896, cache + 512, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else if ((cache[195] & 0x80) == 0x80) {\n\t\t\t \n\t\t\tret = qsfp_read(ppd, target, 640, cache + 384, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tret = qsfp_read(ppd, target, 896, cache + 512, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else if ((cache[195] & 0x40) == 0x40) {\n\t\t\t \n\t\t\tret = qsfp_read(ppd, target, 384, cache + 256, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tret = qsfp_read(ppd, target, 896, cache + 512, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tret = qsfp_read(ppd, target, 896, cache + 512, 128);\n\t\t\tif (ret <= 0 || ret != 128) {\n\t\t\t\tdd_dev_info(ppd->dd, \"%s failed\\n\", __func__);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&ppd->qsfp_info.qsfp_lock, flags);\n\tppd->qsfp_info.cache_valid = 1;\n\tppd->qsfp_info.cache_refresh_required = 0;\n\tspin_unlock_irqrestore(&ppd->qsfp_info.qsfp_lock, flags);\n\n\treturn 0;\n\nbail:\n\tmemset(cache, 0, (QSFP_MAX_NUM_PAGES * 128));\n\treturn ret;\n}\n\nconst char * const hfi1_qsfp_devtech[16] = {\n\t\"850nm VCSEL\", \"1310nm VCSEL\", \"1550nm VCSEL\", \"1310nm FP\",\n\t\"1310nm DFB\", \"1550nm DFB\", \"1310nm EML\", \"1550nm EML\",\n\t\"Cu Misc\", \"1490nm DFB\", \"Cu NoEq\", \"Cu Eq\",\n\t\"Undef\", \"Cu Active BothEq\", \"Cu FarEq\", \"Cu NearEq\"\n};\n\n#define QSFP_DUMP_CHUNK 16  \n#define QSFP_DEFAULT_HDR_CNT 224\n\n#define QSFP_PWR(pbyte) (((pbyte) >> 6) & 3)\n#define QSFP_HIGH_PWR(pbyte) ((pbyte) & 3)\n \n#define QSFP_HIGH_PWR_UNUSED\t0  \n\n \nint get_qsfp_power_class(u8 power_byte)\n{\n\tif (QSFP_HIGH_PWR(power_byte) == QSFP_HIGH_PWR_UNUSED)\n\t\t \n\t\treturn (QSFP_PWR(power_byte) + 1);\n\t \n\treturn (QSFP_HIGH_PWR(power_byte) + 4);\n}\n\nint qsfp_mod_present(struct hfi1_pportdata *ppd)\n{\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tu64 reg;\n\n\treg = read_csr(dd, dd->hfi1_id ? ASIC_QSFP2_IN : ASIC_QSFP1_IN);\n\treturn !(reg & QSFP_HFI0_MODPRST_N);\n}\n\n \nint get_cable_info(struct hfi1_devdata *dd, u32 port_num, u32 addr, u32 len,\n\t\t   u8 *data)\n{\n\tstruct hfi1_pportdata *ppd;\n\tu32 excess_len = len;\n\tint ret = 0, offset = 0;\n\n\tif (port_num > dd->num_pports || port_num < 1) {\n\t\tdd_dev_info(dd, \"%s: Invalid port number %d\\n\",\n\t\t\t    __func__, port_num);\n\t\tret = -EINVAL;\n\t\tgoto set_zeroes;\n\t}\n\n\tppd = dd->pport + (port_num - 1);\n\tif (!qsfp_mod_present(ppd)) {\n\t\tret = -ENODEV;\n\t\tgoto set_zeroes;\n\t}\n\n\tif (!ppd->qsfp_info.cache_valid) {\n\t\tret = -EINVAL;\n\t\tgoto set_zeroes;\n\t}\n\n\tif (addr >= (QSFP_MAX_NUM_PAGES * 128)) {\n\t\tret = -ERANGE;\n\t\tgoto set_zeroes;\n\t}\n\n\tif ((addr + len) > (QSFP_MAX_NUM_PAGES * 128)) {\n\t\texcess_len = (addr + len) - (QSFP_MAX_NUM_PAGES * 128);\n\t\tmemcpy(data, &ppd->qsfp_info.cache[addr], (len - excess_len));\n\t\tdata += (len - excess_len);\n\t\tgoto set_zeroes;\n\t}\n\n\tmemcpy(data, &ppd->qsfp_info.cache[addr], len);\n\n\tif (addr <= QSFP_MONITOR_VAL_END &&\n\t    (addr + len) >= QSFP_MONITOR_VAL_START) {\n\t\t \n\t\tif (addr < QSFP_MONITOR_VAL_START) {\n\t\t\tif (addr + len <= QSFP_MONITOR_VAL_END)\n\t\t\t\tlen = addr + len - QSFP_MONITOR_VAL_START;\n\t\t\telse\n\t\t\t\tlen = QSFP_MONITOR_RANGE;\n\t\t\toffset = QSFP_MONITOR_VAL_START - addr;\n\t\t\taddr = QSFP_MONITOR_VAL_START;\n\t\t} else if (addr == QSFP_MONITOR_VAL_START) {\n\t\t\toffset = 0;\n\t\t\tif (addr + len > QSFP_MONITOR_VAL_END)\n\t\t\t\tlen = QSFP_MONITOR_RANGE;\n\t\t} else {\n\t\t\toffset = 0;\n\t\t\tif (addr + len > QSFP_MONITOR_VAL_END)\n\t\t\t\tlen = QSFP_MONITOR_VAL_END - addr + 1;\n\t\t}\n\t\t \n\t\tret = one_qsfp_read(ppd, dd->hfi1_id, addr, data + offset, len);\n\t\tif (ret != len) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto set_zeroes;\n\t\t}\n\t}\n\n\treturn 0;\n\nset_zeroes:\n\tmemset(data, 0, excess_len);\n\treturn ret;\n}\n\nstatic const char *pwr_codes[8] = {\"N/AW\",\n\t\t\t\t  \"1.5W\",\n\t\t\t\t  \"2.0W\",\n\t\t\t\t  \"2.5W\",\n\t\t\t\t  \"3.5W\",\n\t\t\t\t  \"4.0W\",\n\t\t\t\t  \"4.5W\",\n\t\t\t\t  \"5.0W\"\n\t\t\t\t };\n\nint qsfp_dump(struct hfi1_pportdata *ppd, char *buf, int len)\n{\n\tu8 *cache = &ppd->qsfp_info.cache[0];\n\tu8 bin_buff[QSFP_DUMP_CHUNK];\n\tchar lenstr[6];\n\tint sofar;\n\tint bidx = 0;\n\tu8 *atten = &cache[QSFP_ATTEN_OFFS];\n\tu8 *vendor_oui = &cache[QSFP_VOUI_OFFS];\n\tu8 power_byte = 0;\n\n\tsofar = 0;\n\tlenstr[0] = ' ';\n\tlenstr[1] = '\\0';\n\n\tif (ppd->qsfp_info.cache_valid) {\n\t\tif (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))\n\t\t\tsnprintf(lenstr, sizeof(lenstr), \"%dM \",\n\t\t\t\t cache[QSFP_MOD_LEN_OFFS]);\n\n\t\tpower_byte = cache[QSFP_MOD_PWR_OFFS];\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"PWR:%.3sW\\n\",\n\t\t\t\tpwr_codes[get_qsfp_power_class(power_byte)]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"TECH:%s%s\\n\",\n\t\t\t\tlenstr,\n\t\t\thfi1_qsfp_devtech[(cache[QSFP_MOD_TECH_OFFS]) >> 4]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Vendor:%.*s\\n\",\n\t\t\t\t   QSFP_VEND_LEN, &cache[QSFP_VEND_OFFS]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"OUI:%06X\\n\",\n\t\t\t\t   QSFP_OUI(vendor_oui));\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Part#:%.*s\\n\",\n\t\t\t\t   QSFP_PN_LEN, &cache[QSFP_PN_OFFS]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Rev:%.*s\\n\",\n\t\t\t\t   QSFP_REV_LEN, &cache[QSFP_REV_OFFS]);\n\n\t\tif (QSFP_IS_CU(cache[QSFP_MOD_TECH_OFFS]))\n\t\t\tsofar += scnprintf(buf + sofar, len - sofar,\n\t\t\t\t\"Atten:%d, %d\\n\",\n\t\t\t\tQSFP_ATTEN_SDR(atten),\n\t\t\t\tQSFP_ATTEN_DDR(atten));\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Serial:%.*s\\n\",\n\t\t\t\t   QSFP_SN_LEN, &cache[QSFP_SN_OFFS]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Date:%.*s\\n\",\n\t\t\t\t   QSFP_DATE_LEN, &cache[QSFP_DATE_OFFS]);\n\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Lot:%.*s\\n\",\n\t\t\t\t   QSFP_LOT_LEN, &cache[QSFP_LOT_OFFS]);\n\n\t\twhile (bidx < QSFP_DEFAULT_HDR_CNT) {\n\t\t\tint iidx;\n\n\t\t\tmemcpy(bin_buff, &cache[bidx], QSFP_DUMP_CHUNK);\n\t\t\tfor (iidx = 0; iidx < QSFP_DUMP_CHUNK; ++iidx) {\n\t\t\t\tsofar += scnprintf(buf + sofar, len - sofar,\n\t\t\t\t\t\" %02X\", bin_buff[iidx]);\n\t\t\t}\n\t\t\tsofar += scnprintf(buf + sofar, len - sofar, \"\\n\");\n\t\t\tbidx += QSFP_DUMP_CHUNK;\n\t\t}\n\t}\n\treturn sofar;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}