{
  "module_name": "user_exp_rcv.c",
  "hash_id": "6047d697ad0ab36445dcf3ebe6e8116a788a7d1cc8fc487e3dbf0a4a17c5dfdc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/user_exp_rcv.c",
  "human_readable_source": "\n \n#include <asm/page.h>\n#include <linux/string.h>\n\n#include \"mmu_rb.h\"\n#include \"user_exp_rcv.h\"\n#include \"trace.h\"\n\nstatic void unlock_exp_tids(struct hfi1_ctxtdata *uctxt,\n\t\t\t    struct exp_tid_set *set,\n\t\t\t    struct hfi1_filedata *fd);\nstatic u32 find_phys_blocks(struct tid_user_buf *tidbuf, unsigned int npages);\nstatic int set_rcvarray_entry(struct hfi1_filedata *fd,\n\t\t\t      struct tid_user_buf *tbuf,\n\t\t\t      u32 rcventry, struct tid_group *grp,\n\t\t\t      u16 pageidx, unsigned int npages);\nstatic void cacheless_tid_rb_remove(struct hfi1_filedata *fdata,\n\t\t\t\t    struct tid_rb_node *tnode);\nstatic bool tid_rb_invalidate(struct mmu_interval_notifier *mni,\n\t\t\t      const struct mmu_notifier_range *range,\n\t\t\t      unsigned long cur_seq);\nstatic bool tid_cover_invalidate(struct mmu_interval_notifier *mni,\n\t\t\t         const struct mmu_notifier_range *range,\n\t\t\t         unsigned long cur_seq);\nstatic int program_rcvarray(struct hfi1_filedata *fd, struct tid_user_buf *,\n\t\t\t    struct tid_group *grp, u16 count,\n\t\t\t    u32 *tidlist, unsigned int *tididx,\n\t\t\t    unsigned int *pmapped);\nstatic int unprogram_rcvarray(struct hfi1_filedata *fd, u32 tidinfo);\nstatic void __clear_tid_node(struct hfi1_filedata *fd,\n\t\t\t     struct tid_rb_node *node);\nstatic void clear_tid_node(struct hfi1_filedata *fd, struct tid_rb_node *node);\n\nstatic const struct mmu_interval_notifier_ops tid_mn_ops = {\n\t.invalidate = tid_rb_invalidate,\n};\nstatic const struct mmu_interval_notifier_ops tid_cover_ops = {\n\t.invalidate = tid_cover_invalidate,\n};\n\n \nint hfi1_user_exp_rcv_init(struct hfi1_filedata *fd,\n\t\t\t   struct hfi1_ctxtdata *uctxt)\n{\n\tint ret = 0;\n\n\tfd->entry_to_rb = kcalloc(uctxt->expected_count,\n\t\t\t\t  sizeof(struct rb_node *),\n\t\t\t\t  GFP_KERNEL);\n\tif (!fd->entry_to_rb)\n\t\treturn -ENOMEM;\n\n\tif (!HFI1_CAP_UGET_MASK(uctxt->flags, TID_UNMAP)) {\n\t\tfd->invalid_tid_idx = 0;\n\t\tfd->invalid_tids = kcalloc(uctxt->expected_count,\n\t\t\t\t\t   sizeof(*fd->invalid_tids),\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!fd->invalid_tids) {\n\t\t\tkfree(fd->entry_to_rb);\n\t\t\tfd->entry_to_rb = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tfd->use_mn = true;\n\t}\n\n\t \n\tspin_lock(&fd->tid_lock);\n\tif (uctxt->subctxt_cnt && fd->use_mn) {\n\t\tu16 remainder;\n\n\t\tfd->tid_limit = uctxt->expected_count / uctxt->subctxt_cnt;\n\t\tremainder = uctxt->expected_count % uctxt->subctxt_cnt;\n\t\tif (remainder && fd->subctxt < remainder)\n\t\t\tfd->tid_limit++;\n\t} else {\n\t\tfd->tid_limit = uctxt->expected_count;\n\t}\n\tspin_unlock(&fd->tid_lock);\n\n\treturn ret;\n}\n\nvoid hfi1_user_exp_rcv_free(struct hfi1_filedata *fd)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\n\tmutex_lock(&uctxt->exp_mutex);\n\tif (!EXP_TID_SET_EMPTY(uctxt->tid_full_list))\n\t\tunlock_exp_tids(uctxt, &uctxt->tid_full_list, fd);\n\tif (!EXP_TID_SET_EMPTY(uctxt->tid_used_list))\n\t\tunlock_exp_tids(uctxt, &uctxt->tid_used_list, fd);\n\tmutex_unlock(&uctxt->exp_mutex);\n\n\tkfree(fd->invalid_tids);\n\tfd->invalid_tids = NULL;\n\n\tkfree(fd->entry_to_rb);\n\tfd->entry_to_rb = NULL;\n}\n\n \nstatic void unpin_rcv_pages(struct hfi1_filedata *fd,\n\t\t\t    struct tid_user_buf *tidbuf,\n\t\t\t    struct tid_rb_node *node,\n\t\t\t    unsigned int idx,\n\t\t\t    unsigned int npages,\n\t\t\t    bool mapped)\n{\n\tstruct page **pages;\n\tstruct hfi1_devdata *dd = fd->uctxt->dd;\n\tstruct mm_struct *mm;\n\n\tif (mapped) {\n\t\tdma_unmap_single(&dd->pcidev->dev, node->dma_addr,\n\t\t\t\t node->npages * PAGE_SIZE, DMA_FROM_DEVICE);\n\t\tpages = &node->pages[idx];\n\t\tmm = mm_from_tid_node(node);\n\t} else {\n\t\tpages = &tidbuf->pages[idx];\n\t\tmm = current->mm;\n\t}\n\thfi1_release_user_pages(mm, pages, npages, mapped);\n\tfd->tid_n_pinned -= npages;\n}\n\n \nstatic int pin_rcv_pages(struct hfi1_filedata *fd, struct tid_user_buf *tidbuf)\n{\n\tint pinned;\n\tunsigned int npages = tidbuf->npages;\n\tunsigned long vaddr = tidbuf->vaddr;\n\tstruct page **pages = NULL;\n\tstruct hfi1_devdata *dd = fd->uctxt->dd;\n\n\tif (npages > fd->uctxt->expected_count) {\n\t\tdd_dev_err(dd, \"Expected buffer too big\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tpages = kcalloc(npages, sizeof(*pages), GFP_KERNEL);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!hfi1_can_pin_pages(dd, current->mm, fd->tid_n_pinned, npages)) {\n\t\tkfree(pages);\n\t\treturn -ENOMEM;\n\t}\n\n\tpinned = hfi1_acquire_user_pages(current->mm, vaddr, npages, true, pages);\n\tif (pinned <= 0) {\n\t\tkfree(pages);\n\t\treturn pinned;\n\t}\n\ttidbuf->pages = pages;\n\tfd->tid_n_pinned += pinned;\n\treturn pinned;\n}\n\n \nint hfi1_user_exp_rcv_setup(struct hfi1_filedata *fd,\n\t\t\t    struct hfi1_tid_info *tinfo)\n{\n\tint ret = 0, need_group = 0, pinned;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tunsigned int ngroups, pageset_count,\n\t\ttididx = 0, mapped, mapped_pages = 0;\n\tu32 *tidlist = NULL;\n\tstruct tid_user_buf *tidbuf;\n\tunsigned long mmu_seq = 0;\n\n\tif (!PAGE_ALIGNED(tinfo->vaddr))\n\t\treturn -EINVAL;\n\tif (tinfo->length == 0)\n\t\treturn -EINVAL;\n\n\ttidbuf = kzalloc(sizeof(*tidbuf), GFP_KERNEL);\n\tif (!tidbuf)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tidbuf->cover_mutex);\n\ttidbuf->vaddr = tinfo->vaddr;\n\ttidbuf->length = tinfo->length;\n\ttidbuf->npages = num_user_pages(tidbuf->vaddr, tidbuf->length);\n\ttidbuf->psets = kcalloc(uctxt->expected_count, sizeof(*tidbuf->psets),\n\t\t\t\tGFP_KERNEL);\n\tif (!tidbuf->psets) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_release_mem;\n\t}\n\n\tif (fd->use_mn) {\n\t\tret = mmu_interval_notifier_insert(\n\t\t\t&tidbuf->notifier, current->mm,\n\t\t\ttidbuf->vaddr, tidbuf->npages * PAGE_SIZE,\n\t\t\t&tid_cover_ops);\n\t\tif (ret)\n\t\t\tgoto fail_release_mem;\n\t\tmmu_seq = mmu_interval_read_begin(&tidbuf->notifier);\n\t}\n\n\tpinned = pin_rcv_pages(fd, tidbuf);\n\tif (pinned <= 0) {\n\t\tret = (pinned < 0) ? pinned : -ENOSPC;\n\t\tgoto fail_unpin;\n\t}\n\n\t \n\ttidbuf->n_psets = find_phys_blocks(tidbuf, pinned);\n\n\t \n\tspin_lock(&fd->tid_lock);\n\tif (fd->tid_used + tidbuf->n_psets > fd->tid_limit)\n\t\tpageset_count = fd->tid_limit - fd->tid_used;\n\telse\n\t\tpageset_count = tidbuf->n_psets;\n\tfd->tid_used += pageset_count;\n\tspin_unlock(&fd->tid_lock);\n\n\tif (!pageset_count) {\n\t\tret = -ENOSPC;\n\t\tgoto fail_unreserve;\n\t}\n\n\tngroups = pageset_count / dd->rcv_entries.group_size;\n\ttidlist = kcalloc(pageset_count, sizeof(*tidlist), GFP_KERNEL);\n\tif (!tidlist) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_unreserve;\n\t}\n\n\ttididx = 0;\n\n\t \n\tmutex_lock(&uctxt->exp_mutex);\n\t \n\twhile (ngroups && uctxt->tid_group_list.count) {\n\t\tstruct tid_group *grp =\n\t\t\ttid_group_pop(&uctxt->tid_group_list);\n\n\t\tret = program_rcvarray(fd, tidbuf, grp,\n\t\t\t\t       dd->rcv_entries.group_size,\n\t\t\t\t       tidlist, &tididx, &mapped);\n\t\t \n\t\tif (ret <= 0) {\n\t\t\ttid_group_add_tail(grp, &uctxt->tid_group_list);\n\t\t\thfi1_cdbg(TID,\n\t\t\t\t  \"Failed to program RcvArray group %d\", ret);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\ttid_group_add_tail(grp, &uctxt->tid_full_list);\n\t\tngroups--;\n\t\tmapped_pages += mapped;\n\t}\n\n\twhile (tididx < pageset_count) {\n\t\tstruct tid_group *grp, *ptr;\n\t\t \n\t\tif (!uctxt->tid_used_list.count || need_group) {\n\t\t\tif (!uctxt->tid_group_list.count)\n\t\t\t\tgoto unlock;\n\n\t\t\tgrp = tid_group_pop(&uctxt->tid_group_list);\n\t\t\ttid_group_add_tail(grp, &uctxt->tid_used_list);\n\t\t\tneed_group = 0;\n\t\t}\n\t\t \n\t\tlist_for_each_entry_safe(grp, ptr, &uctxt->tid_used_list.list,\n\t\t\t\t\t list) {\n\t\t\tunsigned use = min_t(unsigned, pageset_count - tididx,\n\t\t\t\t\t     grp->size - grp->used);\n\n\t\t\tret = program_rcvarray(fd, tidbuf, grp,\n\t\t\t\t\t       use, tidlist,\n\t\t\t\t\t       &tididx, &mapped);\n\t\t\tif (ret < 0) {\n\t\t\t\thfi1_cdbg(TID,\n\t\t\t\t\t  \"Failed to program RcvArray entries %d\",\n\t\t\t\t\t  ret);\n\t\t\t\tgoto unlock;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tif (grp->used == grp->size)\n\t\t\t\t\ttid_group_move(grp,\n\t\t\t\t\t\t       &uctxt->tid_used_list,\n\t\t\t\t\t\t       &uctxt->tid_full_list);\n\t\t\t\tmapped_pages += mapped;\n\t\t\t\tneed_group = 0;\n\t\t\t\t \n\t\t\t\tif (tididx >= pageset_count)\n\t\t\t\t\tbreak;\n\t\t\t} else if (WARN_ON(ret == 0)) {\n\t\t\t\t \n\t\t\t\tneed_group = 1;\n\t\t\t}\n\t\t}\n\t}\nunlock:\n\tmutex_unlock(&uctxt->exp_mutex);\n\thfi1_cdbg(TID, \"total mapped: tidpairs:%u pages:%u (%d)\", tididx,\n\t\t  mapped_pages, ret);\n\n\t \n\tif (tididx == 0) {\n\t\tif (ret >= 0)\n\t\t\tret = -ENOSPC;\n\t\tgoto fail_unreserve;\n\t}\n\n\t \n\tspin_lock(&fd->tid_lock);\n\tfd->tid_used -= pageset_count - tididx;\n\tspin_unlock(&fd->tid_lock);\n\n\t \n\tunpin_rcv_pages(fd, tidbuf, NULL, mapped_pages, pinned - mapped_pages,\n\t\t\tfalse);\n\n\tif (fd->use_mn) {\n\t\t \n\t\tbool fail = false;\n\n\t\tmutex_lock(&tidbuf->cover_mutex);\n\t\tfail = mmu_interval_read_retry(&tidbuf->notifier, mmu_seq);\n\t\tmutex_unlock(&tidbuf->cover_mutex);\n\n\t\tif (fail) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto fail_unprogram;\n\t\t}\n\t}\n\n\ttinfo->tidcnt = tididx;\n\ttinfo->length = mapped_pages * PAGE_SIZE;\n\n\tif (copy_to_user(u64_to_user_ptr(tinfo->tidlist),\n\t\t\t tidlist, sizeof(tidlist[0]) * tididx)) {\n\t\tret = -EFAULT;\n\t\tgoto fail_unprogram;\n\t}\n\n\tif (fd->use_mn)\n\t\tmmu_interval_notifier_remove(&tidbuf->notifier);\n\tkfree(tidbuf->pages);\n\tkfree(tidbuf->psets);\n\tkfree(tidbuf);\n\tkfree(tidlist);\n\treturn 0;\n\nfail_unprogram:\n\t \n\ttinfo->tidlist = (unsigned long)tidlist;\n\thfi1_user_exp_rcv_clear(fd, tinfo);\n\ttinfo->tidlist = 0;\n\tpinned = 0;\t\t \n\tpageset_count = 0;\t \nfail_unreserve:\n\tspin_lock(&fd->tid_lock);\n\tfd->tid_used -= pageset_count;\n\tspin_unlock(&fd->tid_lock);\nfail_unpin:\n\tif (fd->use_mn)\n\t\tmmu_interval_notifier_remove(&tidbuf->notifier);\n\tif (pinned > 0)\n\t\tunpin_rcv_pages(fd, tidbuf, NULL, 0, pinned, false);\nfail_release_mem:\n\tkfree(tidbuf->pages);\n\tkfree(tidbuf->psets);\n\tkfree(tidbuf);\n\tkfree(tidlist);\n\treturn ret;\n}\n\nint hfi1_user_exp_rcv_clear(struct hfi1_filedata *fd,\n\t\t\t    struct hfi1_tid_info *tinfo)\n{\n\tint ret = 0;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tu32 *tidinfo;\n\tunsigned tididx;\n\n\tif (unlikely(tinfo->tidcnt > fd->tid_used))\n\t\treturn -EINVAL;\n\n\ttidinfo = memdup_user(u64_to_user_ptr(tinfo->tidlist),\n\t\t\t      sizeof(tidinfo[0]) * tinfo->tidcnt);\n\tif (IS_ERR(tidinfo))\n\t\treturn PTR_ERR(tidinfo);\n\n\tmutex_lock(&uctxt->exp_mutex);\n\tfor (tididx = 0; tididx < tinfo->tidcnt; tididx++) {\n\t\tret = unprogram_rcvarray(fd, tidinfo[tididx]);\n\t\tif (ret) {\n\t\t\thfi1_cdbg(TID, \"Failed to unprogram rcv array %d\",\n\t\t\t\t  ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_lock(&fd->tid_lock);\n\tfd->tid_used -= tididx;\n\tspin_unlock(&fd->tid_lock);\n\ttinfo->tidcnt = tididx;\n\tmutex_unlock(&uctxt->exp_mutex);\n\n\tkfree(tidinfo);\n\treturn ret;\n}\n\nint hfi1_user_exp_rcv_invalid(struct hfi1_filedata *fd,\n\t\t\t      struct hfi1_tid_info *tinfo)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tunsigned long *ev = uctxt->dd->events +\n\t\t(uctxt_offset(uctxt) + fd->subctxt);\n\tu32 *array;\n\tint ret = 0;\n\n\t \n\tarray = kcalloc(uctxt->expected_count, sizeof(*array), GFP_KERNEL);\n\tif (!array)\n\t\treturn -EFAULT;\n\n\tspin_lock(&fd->invalid_lock);\n\tif (fd->invalid_tid_idx) {\n\t\tmemcpy(array, fd->invalid_tids, sizeof(*array) *\n\t\t       fd->invalid_tid_idx);\n\t\tmemset(fd->invalid_tids, 0, sizeof(*fd->invalid_tids) *\n\t\t       fd->invalid_tid_idx);\n\t\ttinfo->tidcnt = fd->invalid_tid_idx;\n\t\tfd->invalid_tid_idx = 0;\n\t\t \n\t\tclear_bit(_HFI1_EVENT_TID_MMU_NOTIFY_BIT, ev);\n\t} else {\n\t\ttinfo->tidcnt = 0;\n\t}\n\tspin_unlock(&fd->invalid_lock);\n\n\tif (tinfo->tidcnt) {\n\t\tif (copy_to_user((void __user *)tinfo->tidlist,\n\t\t\t\t array, sizeof(*array) * tinfo->tidcnt))\n\t\t\tret = -EFAULT;\n\t}\n\tkfree(array);\n\n\treturn ret;\n}\n\nstatic u32 find_phys_blocks(struct tid_user_buf *tidbuf, unsigned int npages)\n{\n\tunsigned pagecount, pageidx, setcount = 0, i;\n\tunsigned long pfn, this_pfn;\n\tstruct page **pages = tidbuf->pages;\n\tstruct tid_pageset *list = tidbuf->psets;\n\n\tif (!npages)\n\t\treturn 0;\n\n\t \n\tpfn = page_to_pfn(pages[0]);\n\tfor (pageidx = 0, pagecount = 1, i = 1; i <= npages; i++) {\n\t\tthis_pfn = i < npages ? page_to_pfn(pages[i]) : 0;\n\n\t\t \n\t\tif (this_pfn != ++pfn) {\n\t\t\t \n\t\t\twhile (pagecount) {\n\t\t\t\tint maxpages = pagecount;\n\t\t\t\tu32 bufsize = pagecount * PAGE_SIZE;\n\n\t\t\t\tif (bufsize > MAX_EXPECTED_BUFFER)\n\t\t\t\t\tmaxpages =\n\t\t\t\t\t\tMAX_EXPECTED_BUFFER >>\n\t\t\t\t\t\tPAGE_SHIFT;\n\t\t\t\telse if (!is_power_of_2(bufsize))\n\t\t\t\t\tmaxpages =\n\t\t\t\t\t\trounddown_pow_of_two(bufsize) >>\n\t\t\t\t\t\tPAGE_SHIFT;\n\n\t\t\t\tlist[setcount].idx = pageidx;\n\t\t\t\tlist[setcount].count = maxpages;\n\t\t\t\tpagecount -= maxpages;\n\t\t\t\tpageidx += maxpages;\n\t\t\t\tsetcount++;\n\t\t\t}\n\t\t\tpageidx = i;\n\t\t\tpagecount = 1;\n\t\t\tpfn = this_pfn;\n\t\t} else {\n\t\t\tpagecount++;\n\t\t}\n\t}\n\treturn setcount;\n}\n\n \nstatic int program_rcvarray(struct hfi1_filedata *fd, struct tid_user_buf *tbuf,\n\t\t\t    struct tid_group *grp, u16 count,\n\t\t\t    u32 *tidlist, unsigned int *tididx,\n\t\t\t    unsigned int *pmapped)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tu16 idx;\n\tunsigned int start = *tididx;\n\tu32 tidinfo = 0, rcventry, useidx = 0;\n\tint mapped = 0;\n\n\t \n\tif (count > grp->size)\n\t\treturn -EINVAL;\n\n\t \n\tfor (idx = 0; idx < grp->size; idx++) {\n\t\tif (!(grp->map & (1 << idx))) {\n\t\t\tuseidx = idx;\n\t\t\tbreak;\n\t\t}\n\t\trcv_array_wc_fill(dd, grp->base + idx);\n\t}\n\n\tidx = 0;\n\twhile (idx < count) {\n\t\tu16 npages, pageidx, setidx = start + idx;\n\t\tint ret = 0;\n\n\t\t \n\t\tif (useidx >= grp->size) {\n\t\t\tbreak;\n\t\t} else if (grp->map & (1 << useidx)) {\n\t\t\trcv_array_wc_fill(dd, grp->base + useidx);\n\t\t\tuseidx++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trcventry = grp->base + useidx;\n\t\tnpages = tbuf->psets[setidx].count;\n\t\tpageidx = tbuf->psets[setidx].idx;\n\n\t\tret = set_rcvarray_entry(fd, tbuf,\n\t\t\t\t\t rcventry, grp, pageidx,\n\t\t\t\t\t npages);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmapped += npages;\n\n\t\ttidinfo = create_tid(rcventry - uctxt->expected_base, npages);\n\t\ttidlist[(*tididx)++] = tidinfo;\n\t\tgrp->used++;\n\t\tgrp->map |= 1 << useidx++;\n\t\tidx++;\n\t}\n\n\t \n\tfor (; useidx < grp->size; useidx++)\n\t\trcv_array_wc_fill(dd, grp->base + useidx);\n\t*pmapped = mapped;\n\treturn idx;\n}\n\nstatic int set_rcvarray_entry(struct hfi1_filedata *fd,\n\t\t\t      struct tid_user_buf *tbuf,\n\t\t\t      u32 rcventry, struct tid_group *grp,\n\t\t\t      u16 pageidx, unsigned int npages)\n{\n\tint ret;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct tid_rb_node *node;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tdma_addr_t phys;\n\tstruct page **pages = tbuf->pages + pageidx;\n\n\t \n\tnode = kzalloc(struct_size(node, pages, npages), GFP_KERNEL);\n\tif (!node)\n\t\treturn -ENOMEM;\n\n\tphys = dma_map_single(&dd->pcidev->dev, __va(page_to_phys(pages[0])),\n\t\t\t      npages * PAGE_SIZE, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&dd->pcidev->dev, phys)) {\n\t\tdd_dev_err(dd, \"Failed to DMA map Exp Rcv pages 0x%llx\\n\",\n\t\t\t   phys);\n\t\tkfree(node);\n\t\treturn -EFAULT;\n\t}\n\n\tnode->fdata = fd;\n\tmutex_init(&node->invalidate_mutex);\n\tnode->phys = page_to_phys(pages[0]);\n\tnode->npages = npages;\n\tnode->rcventry = rcventry;\n\tnode->dma_addr = phys;\n\tnode->grp = grp;\n\tnode->freed = false;\n\tmemcpy(node->pages, pages, flex_array_size(node, pages, npages));\n\n\tif (fd->use_mn) {\n\t\tret = mmu_interval_notifier_insert(\n\t\t\t&node->notifier, current->mm,\n\t\t\ttbuf->vaddr + (pageidx * PAGE_SIZE), npages * PAGE_SIZE,\n\t\t\t&tid_mn_ops);\n\t\tif (ret)\n\t\t\tgoto out_unmap;\n\t}\n\tfd->entry_to_rb[node->rcventry - uctxt->expected_base] = node;\n\n\thfi1_put_tid(dd, rcventry, PT_EXPECTED, phys, ilog2(npages) + 1);\n\ttrace_hfi1_exp_tid_reg(uctxt->ctxt, fd->subctxt, rcventry, npages,\n\t\t\t       node->notifier.interval_tree.start, node->phys,\n\t\t\t       phys);\n\treturn 0;\n\nout_unmap:\n\thfi1_cdbg(TID, \"Failed to insert RB node %u 0x%lx, 0x%lx %d\",\n\t\t  node->rcventry, node->notifier.interval_tree.start,\n\t\t  node->phys, ret);\n\tdma_unmap_single(&dd->pcidev->dev, phys, npages * PAGE_SIZE,\n\t\t\t DMA_FROM_DEVICE);\n\tkfree(node);\n\treturn -EFAULT;\n}\n\nstatic int unprogram_rcvarray(struct hfi1_filedata *fd, u32 tidinfo)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tstruct tid_rb_node *node;\n\tu32 tidctrl = EXP_TID_GET(tidinfo, CTRL);\n\tu32 tididx = EXP_TID_GET(tidinfo, IDX) << 1, rcventry;\n\n\tif (tidctrl == 0x3 || tidctrl == 0x0)\n\t\treturn -EINVAL;\n\n\trcventry = tididx + (tidctrl - 1);\n\n\tif (rcventry >= uctxt->expected_count) {\n\t\tdd_dev_err(dd, \"Invalid RcvArray entry (%u) index for ctxt %u\\n\",\n\t\t\t   rcventry, uctxt->ctxt);\n\t\treturn -EINVAL;\n\t}\n\n\tnode = fd->entry_to_rb[rcventry];\n\tif (!node || node->rcventry != (uctxt->expected_base + rcventry))\n\t\treturn -EBADF;\n\n\tif (fd->use_mn)\n\t\tmmu_interval_notifier_remove(&node->notifier);\n\tcacheless_tid_rb_remove(fd, node);\n\n\treturn 0;\n}\n\nstatic void __clear_tid_node(struct hfi1_filedata *fd, struct tid_rb_node *node)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\n\tmutex_lock(&node->invalidate_mutex);\n\tif (node->freed)\n\t\tgoto done;\n\tnode->freed = true;\n\n\ttrace_hfi1_exp_tid_unreg(uctxt->ctxt, fd->subctxt, node->rcventry,\n\t\t\t\t node->npages,\n\t\t\t\t node->notifier.interval_tree.start, node->phys,\n\t\t\t\t node->dma_addr);\n\n\t \n\thfi1_put_tid(dd, node->rcventry, PT_INVALID_FLUSH, 0, 0);\n\n\tunpin_rcv_pages(fd, NULL, node, 0, node->npages, true);\ndone:\n\tmutex_unlock(&node->invalidate_mutex);\n}\n\nstatic void clear_tid_node(struct hfi1_filedata *fd, struct tid_rb_node *node)\n{\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\n\t__clear_tid_node(fd, node);\n\n\tnode->grp->used--;\n\tnode->grp->map &= ~(1 << (node->rcventry - node->grp->base));\n\n\tif (node->grp->used == node->grp->size - 1)\n\t\ttid_group_move(node->grp, &uctxt->tid_full_list,\n\t\t\t       &uctxt->tid_used_list);\n\telse if (!node->grp->used)\n\t\ttid_group_move(node->grp, &uctxt->tid_used_list,\n\t\t\t       &uctxt->tid_group_list);\n\tkfree(node);\n}\n\n \nstatic void unlock_exp_tids(struct hfi1_ctxtdata *uctxt,\n\t\t\t    struct exp_tid_set *set,\n\t\t\t    struct hfi1_filedata *fd)\n{\n\tstruct tid_group *grp, *ptr;\n\tint i;\n\n\tlist_for_each_entry_safe(grp, ptr, &set->list, list) {\n\t\tlist_del_init(&grp->list);\n\n\t\tfor (i = 0; i < grp->size; i++) {\n\t\t\tif (grp->map & (1 << i)) {\n\t\t\t\tu16 rcventry = grp->base + i;\n\t\t\t\tstruct tid_rb_node *node;\n\n\t\t\t\tnode = fd->entry_to_rb[rcventry -\n\t\t\t\t\t\t\t  uctxt->expected_base];\n\t\t\t\tif (!node || node->rcventry != rcventry)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (fd->use_mn)\n\t\t\t\t\tmmu_interval_notifier_remove(\n\t\t\t\t\t\t&node->notifier);\n\t\t\t\tcacheless_tid_rb_remove(fd, node);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool tid_rb_invalidate(struct mmu_interval_notifier *mni,\n\t\t\t      const struct mmu_notifier_range *range,\n\t\t\t      unsigned long cur_seq)\n{\n\tstruct tid_rb_node *node =\n\t\tcontainer_of(mni, struct tid_rb_node, notifier);\n\tstruct hfi1_filedata *fdata = node->fdata;\n\tstruct hfi1_ctxtdata *uctxt = fdata->uctxt;\n\n\tif (node->freed)\n\t\treturn true;\n\n\t \n\tif (range->event != MMU_NOTIFY_UNMAP)\n\t\treturn true;\n\n\ttrace_hfi1_exp_tid_inval(uctxt->ctxt, fdata->subctxt,\n\t\t\t\t node->notifier.interval_tree.start,\n\t\t\t\t node->rcventry, node->npages, node->dma_addr);\n\n\t \n\t__clear_tid_node(fdata, node);\n\n\tspin_lock(&fdata->invalid_lock);\n\tif (fdata->invalid_tid_idx < uctxt->expected_count) {\n\t\tfdata->invalid_tids[fdata->invalid_tid_idx] =\n\t\t\tcreate_tid(node->rcventry - uctxt->expected_base,\n\t\t\t\t   node->npages);\n\t\tif (!fdata->invalid_tid_idx) {\n\t\t\tunsigned long *ev;\n\n\t\t\t \n\t\t\tev = uctxt->dd->events +\n\t\t\t\t(uctxt_offset(uctxt) + fdata->subctxt);\n\t\t\tset_bit(_HFI1_EVENT_TID_MMU_NOTIFY_BIT, ev);\n\t\t}\n\t\tfdata->invalid_tid_idx++;\n\t}\n\tspin_unlock(&fdata->invalid_lock);\n\treturn true;\n}\n\nstatic bool tid_cover_invalidate(struct mmu_interval_notifier *mni,\n\t\t\t         const struct mmu_notifier_range *range,\n\t\t\t         unsigned long cur_seq)\n{\n\tstruct tid_user_buf *tidbuf =\n\t\tcontainer_of(mni, struct tid_user_buf, notifier);\n\n\t \n\tif (range->event == MMU_NOTIFY_UNMAP) {\n\t\tmutex_lock(&tidbuf->cover_mutex);\n\t\tmmu_interval_set_seq(mni, cur_seq);\n\t\tmutex_unlock(&tidbuf->cover_mutex);\n\t}\n\n\treturn true;\n}\n\nstatic void cacheless_tid_rb_remove(struct hfi1_filedata *fdata,\n\t\t\t\t    struct tid_rb_node *tnode)\n{\n\tu32 base = fdata->uctxt->expected_base;\n\n\tfdata->entry_to_rb[tnode->rcventry - base] = NULL;\n\tclear_tid_node(fdata, tnode);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}