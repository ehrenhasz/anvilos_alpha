{
  "module_name": "aspm.c",
  "hash_id": "1bc143b5009fca49a1d1975c4d68b3e1c8451dfd3ee277b307e118fdb7a8f7b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/aspm.c",
  "human_readable_source": "\n \n\n#include \"aspm.h\"\n\n \n#define ASPM_TIMER_MS 1000\n \n#define ASPM_RESCHED_TIMER_MS (ASPM_TIMER_MS / 2)\n \n#define ASPM_TRIGGER_MS 1\n#define ASPM_TRIGGER_NS (ASPM_TRIGGER_MS * 1000 * 1000ull)\n#define ASPM_L1_SUPPORTED(reg) \\\n\t((((reg) & PCI_EXP_LNKCAP_ASPMS) >> 10) & 0x2)\n\nuint aspm_mode = ASPM_MODE_DISABLED;\nmodule_param_named(aspm, aspm_mode, uint, 0444);\nMODULE_PARM_DESC(aspm, \"PCIe ASPM: 0: disable, 1: enable, 2: dynamic\");\n\nstatic bool aspm_hw_l1_supported(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *parent = dd->pcidev->bus->self;\n\tu32 up, dn;\n\n\t \n\tif (!parent)\n\t\treturn false;\n\n\tpcie_capability_read_dword(dd->pcidev, PCI_EXP_LNKCAP, &dn);\n\tdn = ASPM_L1_SUPPORTED(dn);\n\n\tpcie_capability_read_dword(parent, PCI_EXP_LNKCAP, &up);\n\tup = ASPM_L1_SUPPORTED(up);\n\n\t \n\treturn (!!dn || is_ax(dd)) && !!up;\n}\n\n \nstatic void aspm_hw_set_l1_ent_latency(struct hfi1_devdata *dd)\n{\n\tu32 l1_ent_lat = 0x4u;\n\tu32 reg32;\n\n\tpci_read_config_dword(dd->pcidev, PCIE_CFG_REG_PL3, &reg32);\n\treg32 &= ~PCIE_CFG_REG_PL3_L1_ENT_LATENCY_SMASK;\n\treg32 |= l1_ent_lat << PCIE_CFG_REG_PL3_L1_ENT_LATENCY_SHIFT;\n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_REG_PL3, reg32);\n}\n\nstatic void aspm_hw_enable_l1(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *parent = dd->pcidev->bus->self;\n\n\t \n\tif (!parent)\n\t\treturn;\n\n\t \n\tpcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPM_L1);\n\tpcie_capability_clear_and_set_word(dd->pcidev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPM_L1);\n}\n\nvoid aspm_hw_disable_l1(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *parent = dd->pcidev->bus->self;\n\n\t \n\tpcie_capability_clear_and_set_word(dd->pcidev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC, 0x0);\n\tif (parent)\n\t\tpcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC, 0x0);\n}\n\nstatic  void aspm_enable(struct hfi1_devdata *dd)\n{\n\tif (dd->aspm_enabled || aspm_mode == ASPM_MODE_DISABLED ||\n\t    !dd->aspm_supported)\n\t\treturn;\n\n\taspm_hw_enable_l1(dd);\n\tdd->aspm_enabled = true;\n}\n\nstatic  void aspm_disable(struct hfi1_devdata *dd)\n{\n\tif (!dd->aspm_enabled || aspm_mode == ASPM_MODE_ENABLED)\n\t\treturn;\n\n\taspm_hw_disable_l1(dd);\n\tdd->aspm_enabled = false;\n}\n\nstatic  void aspm_disable_inc(struct hfi1_devdata *dd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->aspm_lock, flags);\n\taspm_disable(dd);\n\tatomic_inc(&dd->aspm_disabled_cnt);\n\tspin_unlock_irqrestore(&dd->aspm_lock, flags);\n}\n\nstatic  void aspm_enable_dec(struct hfi1_devdata *dd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->aspm_lock, flags);\n\tif (atomic_dec_and_test(&dd->aspm_disabled_cnt))\n\t\taspm_enable(dd);\n\tspin_unlock_irqrestore(&dd->aspm_lock, flags);\n}\n\n \nvoid __aspm_ctx_disable(struct hfi1_ctxtdata *rcd)\n{\n\tbool restart_timer;\n\tbool close_interrupts;\n\tunsigned long flags;\n\tktime_t now, prev;\n\n\tspin_lock_irqsave(&rcd->aspm_lock, flags);\n\t \n\tif (!rcd->aspm_intr_enable)\n\t\tgoto unlock;\n\n\tprev = rcd->aspm_ts_last_intr;\n\tnow = ktime_get();\n\trcd->aspm_ts_last_intr = now;\n\n\t \n\tclose_interrupts = ktime_to_ns(ktime_sub(now, prev)) < ASPM_TRIGGER_NS;\n\n\t \n\trestart_timer = ktime_to_ns(ktime_sub(now, rcd->aspm_ts_timer_sched)) >\n\t\t\t\t    ASPM_RESCHED_TIMER_MS * NSEC_PER_MSEC;\n\trestart_timer = restart_timer && close_interrupts;\n\n\t \n\tif (rcd->aspm_enabled && close_interrupts) {\n\t\taspm_disable_inc(rcd->dd);\n\t\trcd->aspm_enabled = false;\n\t\trestart_timer = true;\n\t}\n\n\tif (restart_timer) {\n\t\tmod_timer(&rcd->aspm_timer,\n\t\t\t  jiffies + msecs_to_jiffies(ASPM_TIMER_MS));\n\t\trcd->aspm_ts_timer_sched = now;\n\t}\nunlock:\n\tspin_unlock_irqrestore(&rcd->aspm_lock, flags);\n}\n\n \nstatic  void aspm_ctx_timer_function(struct timer_list *t)\n{\n\tstruct hfi1_ctxtdata *rcd = from_timer(rcd, t, aspm_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rcd->aspm_lock, flags);\n\taspm_enable_dec(rcd->dd);\n\trcd->aspm_enabled = true;\n\tspin_unlock_irqrestore(&rcd->aspm_lock, flags);\n}\n\n \nvoid aspm_disable_all(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_ctxtdata *rcd;\n\tunsigned long flags;\n\tu16 i;\n\n\tfor (i = 0; i < dd->first_dyn_alloc_ctxt; i++) {\n\t\trcd = hfi1_rcd_get_by_index(dd, i);\n\t\tif (rcd) {\n\t\t\tdel_timer_sync(&rcd->aspm_timer);\n\t\t\tspin_lock_irqsave(&rcd->aspm_lock, flags);\n\t\t\trcd->aspm_intr_enable = false;\n\t\t\tspin_unlock_irqrestore(&rcd->aspm_lock, flags);\n\t\t\thfi1_rcd_put(rcd);\n\t\t}\n\t}\n\n\taspm_disable(dd);\n\tatomic_set(&dd->aspm_disabled_cnt, 0);\n}\n\n \nvoid aspm_enable_all(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_ctxtdata *rcd;\n\tunsigned long flags;\n\tu16 i;\n\n\taspm_enable(dd);\n\n\tif (aspm_mode != ASPM_MODE_DYNAMIC)\n\t\treturn;\n\n\tfor (i = 0; i < dd->first_dyn_alloc_ctxt; i++) {\n\t\trcd = hfi1_rcd_get_by_index(dd, i);\n\t\tif (rcd) {\n\t\t\tspin_lock_irqsave(&rcd->aspm_lock, flags);\n\t\t\trcd->aspm_intr_enable = true;\n\t\t\trcd->aspm_enabled = true;\n\t\t\tspin_unlock_irqrestore(&rcd->aspm_lock, flags);\n\t\t\thfi1_rcd_put(rcd);\n\t\t}\n\t}\n}\n\nstatic  void aspm_ctx_init(struct hfi1_ctxtdata *rcd)\n{\n\tspin_lock_init(&rcd->aspm_lock);\n\ttimer_setup(&rcd->aspm_timer, aspm_ctx_timer_function, 0);\n\trcd->aspm_intr_supported = rcd->dd->aspm_supported &&\n\t\taspm_mode == ASPM_MODE_DYNAMIC &&\n\t\trcd->ctxt < rcd->dd->first_dyn_alloc_ctxt;\n}\n\nvoid aspm_init(struct hfi1_devdata *dd)\n{\n\tstruct hfi1_ctxtdata *rcd;\n\tu16 i;\n\n\tspin_lock_init(&dd->aspm_lock);\n\tdd->aspm_supported = aspm_hw_l1_supported(dd);\n\n\tfor (i = 0; i < dd->first_dyn_alloc_ctxt; i++) {\n\t\trcd = hfi1_rcd_get_by_index(dd, i);\n\t\tif (rcd)\n\t\t\taspm_ctx_init(rcd);\n\t\thfi1_rcd_put(rcd);\n\t}\n\n\t \n\taspm_hw_set_l1_ent_latency(dd);\n\tdd->aspm_enabled = false;\n\taspm_hw_disable_l1(dd);\n\n\t \n\taspm_enable_all(dd);\n}\n\nvoid aspm_exit(struct hfi1_devdata *dd)\n{\n\taspm_disable_all(dd);\n\n\t \n\taspm_enable(dd);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}