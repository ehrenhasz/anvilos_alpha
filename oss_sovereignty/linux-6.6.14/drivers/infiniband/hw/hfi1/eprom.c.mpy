{
  "module_name": "eprom.c",
  "hash_id": "19e972e10f4d61d8a56c2739019915f08d5ab2e30cafc85f0964aaac788c921f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/eprom.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include \"hfi.h\"\n#include \"common.h\"\n#include \"eprom.h\"\n\n \n#define P0_SIZE (128 * 1024)\n#define P1_SIZE   (4 * 1024)\n#define P1_START P0_SIZE\n#define P2_START (P0_SIZE + P1_SIZE)\n\n \n#define EP_PAGE_SIZE 256\n#define EP_PAGE_MASK (EP_PAGE_SIZE - 1)\n#define EP_PAGE_DWORDS (EP_PAGE_SIZE / sizeof(u32))\n\n \n#define CMD_SHIFT 24\n#define CMD_NOP\t\t\t    (0)\n#define CMD_READ_DATA(addr)\t    ((0x03 << CMD_SHIFT) | addr)\n#define CMD_RELEASE_POWERDOWN_NOID  ((0xab << CMD_SHIFT))\n\n \n#define EP_SPEED_FULL 0x2\t \n\n \n#define EPROM_TIMEOUT 80000  \n\n \nstatic void read_page(struct hfi1_devdata *dd, u32 offset, u32 *result)\n{\n\tint i;\n\n\twrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_READ_DATA(offset));\n\tfor (i = 0; i < EP_PAGE_DWORDS; i++)\n\t\tresult[i] = (u32)read_csr(dd, ASIC_EEP_DATA);\n\twrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_NOP);  \n}\n\n \nstatic int read_length(struct hfi1_devdata *dd, u32 start, u32 len, void *dest)\n{\n\tu32 buffer[EP_PAGE_DWORDS];\n\tu32 end;\n\tu32 start_offset;\n\tu32 read_start;\n\tu32 bytes;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tend = start + len;\n\n\t \n\tif (end > (1 << CMD_SHIFT))\n\t\treturn -EINVAL;\n\n\t \n\tstart_offset = start & EP_PAGE_MASK;\n\tif (start_offset) {\n\t\t \n\n\t\t \n\t\tread_start = start & ~EP_PAGE_MASK;\n\t\tread_page(dd, read_start, buffer);\n\n\t\t \n\t\tbytes = EP_PAGE_SIZE - start_offset;\n\n\t\tif (len <= bytes) {\n\t\t\t \n\t\t\tmemcpy(dest, (u8 *)buffer + start_offset, len);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmemcpy(dest, (u8 *)buffer + start_offset, bytes);\n\n\t\tstart += bytes;\n\t\tlen -= bytes;\n\t\tdest += bytes;\n\t}\n\t \n\n\t \n\twhile (len >= EP_PAGE_SIZE) {\n\t\tread_page(dd, start, buffer);\n\t\tmemcpy(dest, buffer, EP_PAGE_SIZE);\n\n\t\tstart += EP_PAGE_SIZE;\n\t\tlen -= EP_PAGE_SIZE;\n\t\tdest += EP_PAGE_SIZE;\n\t}\n\n\t \n\tif (len) {\n\t\tread_page(dd, start, buffer);\n\t\tmemcpy(dest, buffer, len);\n\t}\n\n\treturn 0;\n}\n\n \nint eprom_init(struct hfi1_devdata *dd)\n{\n\tint ret = 0;\n\n\t \n\tif (dd->pcidev->device != PCI_DEVICE_ID_INTEL0)\n\t\treturn 0;\n\n\t \n\tret = acquire_chip_resource(dd, CR_EPROM, EPROM_TIMEOUT);\n\tif (ret) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"%s: unable to acquire EPROM resource, no EPROM support\\n\",\n\t\t\t   __func__);\n\t\tgoto done_asic;\n\t}\n\n\t \n\n\t \n\twrite_csr(dd, ASIC_EEP_CTL_STAT, ASIC_EEP_CTL_STAT_EP_RESET_SMASK);\n\t \n\twrite_csr(dd, ASIC_EEP_CTL_STAT,\n\t\t  EP_SPEED_FULL << ASIC_EEP_CTL_STAT_RATE_SPI_SHIFT);\n\n\t \n\twrite_csr(dd, ASIC_EEP_ADDR_CMD, CMD_RELEASE_POWERDOWN_NOID);\n\n\tdd->eprom_available = true;\n\trelease_chip_resource(dd, CR_EPROM);\ndone_asic:\n\treturn ret;\n}\n\n \n#define IMAGE_START_MAGIC \"APO=\"\n\n \n#define IMAGE_TRAIL_MAGIC \"egamiAPO\"\n\n \n#define HFI1_EFT_PLATFORM_CONFIG 2\n\n \n#define SEG_SIZE (128 * 1024)\n\nstruct hfi1_eprom_footer {\n\tu32 oprom_size;\t\t \n\tu16 num_table_entries;\n\tu16 version;\t\t \n\tu32 magic;\t\t \n};\n\nstruct hfi1_eprom_table_entry {\n\tu32 type;\t\t \n\tu32 offset;\t\t \n\tu32 size;\t\t \n};\n\n \n#define MAX_TABLE_ENTRIES(dir_size) \\\n\t(((dir_size) - sizeof(struct hfi1_eprom_footer)) / \\\n\t\tsizeof(struct hfi1_eprom_table_entry))\n\n#define DIRECTORY_SIZE(n) (sizeof(struct hfi1_eprom_footer) + \\\n\t(sizeof(struct hfi1_eprom_table_entry) * (n)))\n\n#define MAGIC4(a, b, c, d) ((d) << 24 | (c) << 16 | (b) << 8 | (a))\n#define FOOTER_MAGIC MAGIC4('e', 'p', 'r', 'm')\n#define FOOTER_VERSION 1\n\n \nstatic int read_partition_platform_config(struct hfi1_devdata *dd, void **data,\n\t\t\t\t\t  u32 *size)\n{\n\tvoid *buffer;\n\tvoid *p;\n\tu32 length;\n\tint ret;\n\n\tbuffer = kmalloc(P1_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tret = read_length(dd, P1_START, P1_SIZE, buffer);\n\tif (ret) {\n\t\tkfree(buffer);\n\t\treturn ret;\n\t}\n\n\t \n\tif (memcmp(buffer, IMAGE_START_MAGIC, strlen(IMAGE_START_MAGIC))) {\n\t\tkfree(buffer);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tp = strnstr(buffer, IMAGE_TRAIL_MAGIC, P1_SIZE);\n\tif (p)\n\t\tlength = p - buffer;\n\telse\n\t\tlength = P1_SIZE;\n\n\t*data = buffer;\n\t*size = length;\n\treturn 0;\n}\n\n \nstatic int read_segment_platform_config(struct hfi1_devdata *dd,\n\t\t\t\t\tvoid *directory, void **data, u32 *size)\n{\n\tstruct hfi1_eprom_footer *footer;\n\tstruct hfi1_eprom_table_entry *table;\n\tstruct hfi1_eprom_table_entry *entry;\n\tvoid *buffer = NULL;\n\tvoid *table_buffer = NULL;\n\tint ret, i;\n\tu32 directory_size;\n\tu32 seg_base, seg_offset;\n\tu32 bytes_available, ncopied, to_copy;\n\n\t \n\tfooter = (struct hfi1_eprom_footer *)\n\t\t\t(directory + EP_PAGE_SIZE - sizeof(*footer));\n\n\t \n\tif (footer->version != FOOTER_VERSION)\n\t\treturn -EINVAL;\n\n\t \n\tif (footer->oprom_size >= SEG_SIZE)\n\t\treturn -EINVAL;\n\n\t \n\tif (footer->num_table_entries >\n\t\t\tMAX_TABLE_ENTRIES(SEG_SIZE - footer->oprom_size))\n\t\treturn -EINVAL;\n\n\t \n\tdirectory_size = DIRECTORY_SIZE(footer->num_table_entries);\n\tif (directory_size <= EP_PAGE_SIZE) {\n\t\t \n\t\ttable = (struct hfi1_eprom_table_entry *)\n\t\t\t\t(directory + EP_PAGE_SIZE - directory_size);\n\t} else {\n\t\t \n\t\ttable_buffer = kmalloc(directory_size, GFP_KERNEL);\n\t\tif (!table_buffer)\n\t\t\treturn -ENOMEM;\n\t\tret = read_length(dd, SEG_SIZE - directory_size,\n\t\t\t\t  directory_size, table_buffer);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\ttable = table_buffer;\n\t}\n\n\t \n\tfor (entry = NULL, i = 0; i < footer->num_table_entries; i++) {\n\t\tif (table[i].type == HFI1_EFT_PLATFORM_CONFIG) {\n\t\t\tentry = &table[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!entry) {\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\t \n\tif (entry->size > (4 * 1024)) {\n\t\tdd_dev_err(dd, \"Bad configuration file size 0x%x\\n\",\n\t\t\t   entry->size);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tif (entry->offset + entry->size < entry->offset) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"Bad configuration file start + size 0x%x+0x%x\\n\",\n\t\t\t   entry->offset, entry->size);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tbuffer = kmalloc(entry->size, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tseg_offset = entry->offset % SEG_SIZE;\n\tseg_base = entry->offset - seg_offset;\n\tncopied = 0;\n\twhile (ncopied < entry->size) {\n\t\t \n\n\t\t \n\t\tbytes_available = SEG_SIZE - seg_offset;\n\t\t \n\t\tif (seg_base == 0) {\n\t\t\t \n\t\t\tif (bytes_available <= directory_size) {\n\t\t\t\tdd_dev_err(dd,\n\t\t\t\t\t   \"Bad configuration file - offset 0x%x within footer+table\\n\",\n\t\t\t\t\t   entry->offset);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbytes_available -= directory_size;\n\t\t}\n\n\t\t \n\t\tto_copy = entry->size - ncopied;\n\n\t\t \n\t\tif (to_copy > bytes_available)\n\t\t\tto_copy = bytes_available;\n\n\t\t \n\t\tret = read_length(dd, seg_base + seg_offset, to_copy,\n\t\t\t\t  buffer + ncopied);\n\t\tif (ret)\n\t\t\tgoto done;\n\n\t\tncopied += to_copy;\n\n\t\t \n\t\tseg_offset = footer->oprom_size;\n\t\tseg_base += SEG_SIZE;\n\t}\n\n\t \n\tret = 0;\n\t*data = buffer;\n\t*size = entry->size;\n\ndone:\n\tkfree(table_buffer);\n\tif (ret)\n\t\tkfree(buffer);\n\treturn ret;\n}\n\n \nint eprom_read_platform_config(struct hfi1_devdata *dd, void **data, u32 *size)\n{\n\tu32 directory[EP_PAGE_DWORDS];  \n\tint ret;\n\n\tif (!dd->eprom_available)\n\t\treturn -ENXIO;\n\n\tret = acquire_chip_resource(dd, CR_EPROM, EPROM_TIMEOUT);\n\tif (ret)\n\t\treturn -EBUSY;\n\n\t \n\tret = read_length(dd, SEG_SIZE - EP_PAGE_SIZE, EP_PAGE_SIZE, directory);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tif (directory[EP_PAGE_DWORDS - 1] == FOOTER_MAGIC) {\n\t\t \n\t\tret = read_segment_platform_config(dd, directory, data, size);\n\t} else {\n\t\t \n\t\tret = read_partition_platform_config(dd, data, size);\n\t}\n\ndone:\n\trelease_chip_resource(dd, CR_EPROM);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}