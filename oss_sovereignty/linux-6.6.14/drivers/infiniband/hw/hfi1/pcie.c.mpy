{
  "module_name": "pcie.c",
  "hash_id": "88732febbebfe246bdf5211dca85a5a5def2598d4499ca1fc010fb4580f935be",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/pcie.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#include \"hfi.h\"\n#include \"chip_registers.h\"\n#include \"aspm.h\"\n\n \n\n \nint hfi1_pcie_init(struct hfi1_devdata *dd)\n{\n\tint ret;\n\tstruct pci_dev *pdev = dd->pcidev;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\t \n\t\tdd_dev_err(dd, \"pci enable failed: error %d\\n\", -ret);\n\t\treturn ret;\n\t}\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"pci_request_regions fails: err %d\\n\", -ret);\n\t\tgoto bail;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\t \n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tdd_dev_err(dd, \"Unable to set DMA mask: %d\\n\", ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\treturn 0;\n\nbail:\n\thfi1_pcie_cleanup(pdev);\n\treturn ret;\n}\n\n \nvoid hfi1_pcie_cleanup(struct pci_dev *pdev)\n{\n\tpci_disable_device(pdev);\n\t \n\tpci_release_regions(pdev);\n}\n\n \nint hfi1_pcie_ddinit(struct hfi1_devdata *dd, struct pci_dev *pdev)\n{\n\tunsigned long len;\n\tresource_size_t addr;\n\tint ret = 0;\n\tu32 rcv_array_count;\n\n\taddr = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\n\t \n\n\t \n\tif (len != TXE_PIO_SEND + TXE_PIO_SIZE) {\n\t\tdd_dev_err(dd, \"chip PIO range does not match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdd->kregbase1 = ioremap(addr, RCV_ARRAY);\n\tif (!dd->kregbase1) {\n\t\tdd_dev_err(dd, \"UC mapping of kregbase1 failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdd_dev_info(dd, \"UC base1: %p for %x\\n\", dd->kregbase1, RCV_ARRAY);\n\n\t \n\tdd->revision = readq(dd->kregbase1 + CCE_REVISION);\n\tif (dd->revision == ~(u64)0) {\n\t\tdd_dev_err(dd, \"Cannot read chip CSRs\\n\");\n\t\tgoto nomem;\n\t}\n\n\trcv_array_count = readq(dd->kregbase1 + RCV_ARRAY_CNT);\n\tdd_dev_info(dd, \"RcvArray count: %u\\n\", rcv_array_count);\n\tdd->base2_start  = RCV_ARRAY + rcv_array_count * 8;\n\n\tdd->kregbase2 = ioremap(\n\t\taddr + dd->base2_start,\n\t\tTXE_PIO_SEND - dd->base2_start);\n\tif (!dd->kregbase2) {\n\t\tdd_dev_err(dd, \"UC mapping of kregbase2 failed\\n\");\n\t\tgoto nomem;\n\t}\n\tdd_dev_info(dd, \"UC base2: %p for %x\\n\", dd->kregbase2,\n\t\t    TXE_PIO_SEND - dd->base2_start);\n\n\tdd->piobase = ioremap_wc(addr + TXE_PIO_SEND, TXE_PIO_SIZE);\n\tif (!dd->piobase) {\n\t\tdd_dev_err(dd, \"WC mapping of send buffers failed\\n\");\n\t\tgoto nomem;\n\t}\n\tdd_dev_info(dd, \"WC piobase: %p for %x\\n\", dd->piobase, TXE_PIO_SIZE);\n\n\tdd->physaddr = addr;         \n\n\t \n\tdd->rcvarray_wc = ioremap_wc(addr + RCV_ARRAY,\n\t\t\t\t     rcv_array_count * 8);\n\tif (!dd->rcvarray_wc) {\n\t\tdd_dev_err(dd, \"WC mapping of receive array failed\\n\");\n\t\tgoto nomem;\n\t}\n\tdd_dev_info(dd, \"WC RcvArray: %p for %x\\n\",\n\t\t    dd->rcvarray_wc, rcv_array_count * 8);\n\n\tdd->flags |= HFI1_PRESENT;\t \n\treturn 0;\nnomem:\n\tret = -ENOMEM;\n\thfi1_pcie_ddcleanup(dd);\n\treturn ret;\n}\n\n \nvoid hfi1_pcie_ddcleanup(struct hfi1_devdata *dd)\n{\n\tdd->flags &= ~HFI1_PRESENT;\n\tif (dd->kregbase1)\n\t\tiounmap(dd->kregbase1);\n\tdd->kregbase1 = NULL;\n\tif (dd->kregbase2)\n\t\tiounmap(dd->kregbase2);\n\tdd->kregbase2 = NULL;\n\tif (dd->rcvarray_wc)\n\t\tiounmap(dd->rcvarray_wc);\n\tdd->rcvarray_wc = NULL;\n\tif (dd->piobase)\n\t\tiounmap(dd->piobase);\n\tdd->piobase = NULL;\n}\n\n \nstatic u32 extract_speed(u16 linkstat)\n{\n\tu32 speed;\n\n\tswitch (linkstat & PCI_EXP_LNKSTA_CLS) {\n\tdefault:  \n\tcase PCI_EXP_LNKSTA_CLS_2_5GB:\n\t\tspeed = 2500;  \n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_CLS_5_0GB:\n\t\tspeed = 5000;  \n\t\tbreak;\n\tcase PCI_EXP_LNKSTA_CLS_8_0GB:\n\t\tspeed = 8000;  \n\t\tbreak;\n\t}\n\treturn speed;\n}\n\n \nstatic void update_lbus_info(struct hfi1_devdata *dd)\n{\n\tu16 linkstat;\n\tint ret;\n\n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKSTA, &linkstat);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\treturn;\n\t}\n\n\tdd->lbus_width = FIELD_GET(PCI_EXP_LNKSTA_NLW, linkstat);\n\tdd->lbus_speed = extract_speed(linkstat);\n\tsnprintf(dd->lbus_info, sizeof(dd->lbus_info),\n\t\t \"PCIe,%uMHz,x%u\", dd->lbus_speed, dd->lbus_width);\n}\n\n \nint pcie_speeds(struct hfi1_devdata *dd)\n{\n\tu32 linkcap;\n\tstruct pci_dev *parent = dd->pcidev->bus->self;\n\tint ret;\n\n\tif (!pci_is_pcie(dd->pcidev)) {\n\t\tdd_dev_err(dd, \"Can't find PCI Express capability!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdd->link_gen3_capable = 1;\n\n\tret = pcie_capability_read_dword(dd->pcidev, PCI_EXP_LNKCAP, &linkcap);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\treturn pcibios_err_to_errno(ret);\n\t}\n\n\tif ((linkcap & PCI_EXP_LNKCAP_SLS) != PCI_EXP_LNKCAP_SLS_8_0GB) {\n\t\tdd_dev_info(dd,\n\t\t\t    \"This HFI is not Gen3 capable, max speed 0x%x, need 0x3\\n\",\n\t\t\t    linkcap & PCI_EXP_LNKCAP_SLS);\n\t\tdd->link_gen3_capable = 0;\n\t}\n\n\t \n\tif (parent &&\n\t    (dd->pcidev->bus->max_bus_speed == PCIE_SPEED_2_5GT ||\n\t     dd->pcidev->bus->max_bus_speed == PCIE_SPEED_5_0GT)) {\n\t\tdd_dev_info(dd, \"Parent PCIe bridge does not support Gen3\\n\");\n\t\tdd->link_gen3_capable = 0;\n\t}\n\n\t \n\tupdate_lbus_info(dd);\n\n\tdd_dev_info(dd, \"%s\\n\", dd->lbus_info);\n\n\treturn 0;\n}\n\n \nint restore_pci_variables(struct hfi1_devdata *dd)\n{\n\tint ret;\n\n\tret = pci_write_config_word(dd->pcidev, PCI_COMMAND, dd->pci_command);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,\n\t\t\t\t     dd->pcibar0);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,\n\t\t\t\t     dd->pcibar1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_write_config_dword(dd->pcidev, PCI_ROM_ADDRESS, dd->pci_rom);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL,\n\t\t\t\t\t dd->pcie_devctl);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL,\n\t\t\t\t\t dd->pcie_lnkctl);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_write_word(dd->pcidev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t dd->pcie_devctl2);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_write_config_dword(dd->pcidev, PCI_CFG_MSIX0, dd->pci_msix0);\n\tif (ret)\n\t\tgoto error;\n\n\tif (pci_find_ext_capability(dd->pcidev, PCI_EXT_CAP_ID_TPH)) {\n\t\tret = pci_write_config_dword(dd->pcidev, PCIE_CFG_TPH2,\n\t\t\t\t\t     dd->pci_tph2);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tdd_dev_err(dd, \"Unable to write to PCI config\\n\");\n\treturn pcibios_err_to_errno(ret);\n}\n\n \nint save_pci_variables(struct hfi1_devdata *dd)\n{\n\tint ret;\n\n\tret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,\n\t\t\t\t    &dd->pcibar0);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_read_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,\n\t\t\t\t    &dd->pcibar1);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_read_config_dword(dd->pcidev, PCI_ROM_ADDRESS, &dd->pci_rom);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_read_config_word(dd->pcidev, PCI_COMMAND, &dd->pci_command);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL,\n\t\t\t\t\t&dd->pcie_devctl);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKCTL,\n\t\t\t\t\t&dd->pcie_lnkctl);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t&dd->pcie_devctl2);\n\tif (ret)\n\t\tgoto error;\n\n\tret = pci_read_config_dword(dd->pcidev, PCI_CFG_MSIX0, &dd->pci_msix0);\n\tif (ret)\n\t\tgoto error;\n\n\tif (pci_find_ext_capability(dd->pcidev, PCI_EXT_CAP_ID_TPH)) {\n\t\tret = pci_read_config_dword(dd->pcidev, PCIE_CFG_TPH2,\n\t\t\t\t\t    &dd->pci_tph2);\n\t\tif (ret)\n\t\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\treturn pcibios_err_to_errno(ret);\n}\n\n \nstatic int hfi1_pcie_caps;\nmodule_param_named(pcie_caps, hfi1_pcie_caps, int, 0444);\nMODULE_PARM_DESC(pcie_caps, \"Max PCIe tuning: Payload (0..3), ReadReq (4..7)\");\n\n \nvoid tune_pcie_caps(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *parent;\n\tu16 rc_mpss, rc_mps, ep_mpss, ep_mps;\n\tu16 rc_mrrs, ep_mrrs, max_mrrs, ectl;\n\tint ret;\n\n\t \n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_DEVCTL, &ectl);\n\tif ((!ret) && !(ectl & PCI_EXP_DEVCTL_EXT_TAG)) {\n\t\tdd_dev_info(dd, \"Enabling PCIe extended tags\\n\");\n\t\tectl |= PCI_EXP_DEVCTL_EXT_TAG;\n\t\tret = pcie_capability_write_word(dd->pcidev,\n\t\t\t\t\t\t PCI_EXP_DEVCTL, ectl);\n\t\tif (ret)\n\t\t\tdd_dev_info(dd, \"Unable to write to PCI config\\n\");\n\t}\n\t \n\tparent = dd->pcidev->bus->self;\n\t \n\tif (!parent) {\n\t\tdd_dev_info(dd, \"Parent not found\\n\");\n\t\treturn;\n\t}\n\tif (!pci_is_root_bus(parent->bus)) {\n\t\tdd_dev_info(dd, \"Parent not root\\n\");\n\t\treturn;\n\t}\n\tif (!pci_is_pcie(parent)) {\n\t\tdd_dev_info(dd, \"Parent is not PCI Express capable\\n\");\n\t\treturn;\n\t}\n\tif (!pci_is_pcie(dd->pcidev)) {\n\t\tdd_dev_info(dd, \"PCI device is not PCI Express capable\\n\");\n\t\treturn;\n\t}\n\trc_mpss = parent->pcie_mpss;\n\trc_mps = ffs(pcie_get_mps(parent)) - 8;\n\t \n\tep_mpss = dd->pcidev->pcie_mpss;\n\tep_mps = ffs(pcie_get_mps(dd->pcidev)) - 8;\n\n\t \n\tif (rc_mpss > ep_mpss)\n\t\trc_mpss = ep_mpss;\n\n\t \n\tif (rc_mpss > (hfi1_pcie_caps & 7))\n\t\trc_mpss = hfi1_pcie_caps & 7;\n\t \n\tif (rc_mpss > rc_mps) {\n\t\trc_mps = rc_mpss;\n\t\tpcie_set_mps(parent, 128 << rc_mps);\n\t}\n\t \n\tif (rc_mpss > ep_mps) {\n\t\tep_mps = rc_mpss;\n\t\tpcie_set_mps(dd->pcidev, 128 << ep_mps);\n\t}\n\n\t \n\tmax_mrrs = 5;\n\tif (max_mrrs > ((hfi1_pcie_caps >> 4) & 7))\n\t\tmax_mrrs = (hfi1_pcie_caps >> 4) & 7;\n\n\tmax_mrrs = 128 << max_mrrs;\n\trc_mrrs = pcie_get_readrq(parent);\n\tep_mrrs = pcie_get_readrq(dd->pcidev);\n\n\tif (max_mrrs > rc_mrrs) {\n\t\trc_mrrs = max_mrrs;\n\t\tpcie_set_readrq(parent, rc_mrrs);\n\t}\n\tif (max_mrrs > ep_mrrs) {\n\t\tep_mrrs = max_mrrs;\n\t\tpcie_set_readrq(dd->pcidev, ep_mrrs);\n\t}\n}\n\n \n\n \nstatic pci_ers_result_t\npci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct hfi1_devdata *dd = pci_get_drvdata(pdev);\n\tpci_ers_result_t ret = PCI_ERS_RESULT_RECOVERED;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tdd_dev_info(dd, \"State Normal, ignoring\\n\");\n\t\tbreak;\n\n\tcase pci_channel_io_frozen:\n\t\tdd_dev_info(dd, \"State Frozen, requesting reset\\n\");\n\t\tpci_disable_device(pdev);\n\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\n\tcase pci_channel_io_perm_failure:\n\t\tif (dd) {\n\t\t\tdd_dev_info(dd, \"State Permanent Failure, disabling\\n\");\n\t\t\t \n\t\t\tdd->flags &= ~HFI1_PRESENT;\n\t\t\thfi1_disable_after_error(dd);\n\t\t}\n\t\t  \n\t\tret =  PCI_ERS_RESULT_DISCONNECT;\n\t\tbreak;\n\n\tdefault:  \n\t\tdd_dev_info(dd, \"HFI1 PCI errors detected (state %d)\\n\",\n\t\t\t    state);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic pci_ers_result_t\npci_mmio_enabled(struct pci_dev *pdev)\n{\n\tu64 words = 0U;\n\tstruct hfi1_devdata *dd = pci_get_drvdata(pdev);\n\tpci_ers_result_t ret = PCI_ERS_RESULT_RECOVERED;\n\n\tif (dd && dd->pport) {\n\t\twords = read_port_cntr(dd->pport, C_RX_WORDS, CNTR_INVALID_VL);\n\t\tif (words == ~0ULL)\n\t\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t\tdd_dev_info(dd,\n\t\t\t    \"HFI1 mmio_enabled function called, read wordscntr %llx, returning %d\\n\",\n\t\t\t    words, ret);\n\t}\n\treturn  ret;\n}\n\nstatic pci_ers_result_t\npci_slot_reset(struct pci_dev *pdev)\n{\n\tstruct hfi1_devdata *dd = pci_get_drvdata(pdev);\n\n\tdd_dev_info(dd, \"HFI1 slot_reset function called, ignored\\n\");\n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\nstatic void\npci_resume(struct pci_dev *pdev)\n{\n\tstruct hfi1_devdata *dd = pci_get_drvdata(pdev);\n\n\tdd_dev_info(dd, \"HFI1 resume function called\\n\");\n\t \n\thfi1_init(dd, 1);  \n}\n\nconst struct pci_error_handlers hfi1_pci_err_handler = {\n\t.error_detected = pci_error_detected,\n\t.mmio_enabled = pci_mmio_enabled,\n\t.slot_reset = pci_slot_reset,\n\t.resume = pci_resume,\n};\n\n \n \n\n \n\n \n#define DL_STATUS_HFI0 0x1\t \n#define DL_STATUS_HFI1 0x2\t \n#define DL_STATUS_BOTH 0x3\t \n\n \n#define DL_ERR_NONE\t\t0x0\t \n#define DL_ERR_SWAP_PARITY\t0x1\t \n\t\t\t\t\t \n#define DL_ERR_DISABLED\t0x2\t \n#define DL_ERR_SECURITY\t0x3\t \n#define DL_ERR_SBUS\t\t0x4\t \n#define DL_ERR_XFR_PARITY\t0x5\t \n\n \n#define SBR_DELAY_US 200000\t \n\nstatic uint pcie_target = 3;\nmodule_param(pcie_target, uint, S_IRUGO);\nMODULE_PARM_DESC(pcie_target, \"PCIe target speed (0 skip, 1-3 Gen1-3)\");\n\nstatic uint pcie_force;\nmodule_param(pcie_force, uint, S_IRUGO);\nMODULE_PARM_DESC(pcie_force, \"Force driver to do a PCIe firmware download even if already at target speed\");\n\nstatic uint pcie_retry = 5;\nmodule_param(pcie_retry, uint, S_IRUGO);\nMODULE_PARM_DESC(pcie_retry, \"Driver will try this many times to reach requested speed\");\n\n#define UNSET_PSET 255\n#define DEFAULT_DISCRETE_PSET 2\t \n#define DEFAULT_MCP_PSET 6\t \nstatic uint pcie_pset = UNSET_PSET;\nmodule_param(pcie_pset, uint, S_IRUGO);\nMODULE_PARM_DESC(pcie_pset, \"PCIe Eq Pset value to use, range is 0-10\");\n\nstatic uint pcie_ctle = 3;  \nmodule_param(pcie_ctle, uint, S_IRUGO);\nMODULE_PARM_DESC(pcie_ctle, \"PCIe static CTLE mode, bit 0 - discrete on/off, bit 1 - integrated on/off\");\n\n \n#define PREC 0\n#define ATTN 1\n#define POST 2\n\n \nstatic const u8 discrete_preliminary_eq[11][3] = {\n\t \n\t{  0x00,  0x00,  0x12 },\t \n\t{  0x00,  0x00,  0x0c },\t \n\t{  0x00,  0x00,  0x0f },\t \n\t{  0x00,  0x00,  0x09 },\t \n\t{  0x00,  0x00,  0x00 },\t \n\t{  0x06,  0x00,  0x00 },\t \n\t{  0x09,  0x00,  0x00 },\t \n\t{  0x06,  0x00,  0x0f },\t \n\t{  0x09,  0x00,  0x09 },\t \n\t{  0x0c,  0x00,  0x00 },\t \n\t{  0x00,  0x00,  0x18 },\t \n};\n\n \nstatic const u8 integrated_preliminary_eq[11][3] = {\n\t \n\t{  0x00,  0x1e,  0x07 },\t \n\t{  0x00,  0x1e,  0x05 },\t \n\t{  0x00,  0x1e,  0x06 },\t \n\t{  0x00,  0x1e,  0x04 },\t \n\t{  0x00,  0x1e,  0x00 },\t \n\t{  0x03,  0x1e,  0x00 },\t \n\t{  0x04,  0x1e,  0x00 },\t \n\t{  0x03,  0x1e,  0x06 },\t \n\t{  0x03,  0x1e,  0x04 },\t \n\t{  0x05,  0x1e,  0x00 },\t \n\t{  0x00,  0x1e,  0x0a },\t \n};\n\nstatic const u8 discrete_ctle_tunings[11][4] = {\n\t \n\t{  0x48,  0x0b,  0x04,  0x04 },\t \n\t{  0x60,  0x05,  0x0f,  0x0a },\t \n\t{  0x50,  0x09,  0x06,  0x06 },\t \n\t{  0x68,  0x05,  0x0f,  0x0a },\t \n\t{  0x80,  0x05,  0x0f,  0x0a },\t \n\t{  0x70,  0x05,  0x0f,  0x0a },\t \n\t{  0x68,  0x05,  0x0f,  0x0a },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x48,  0x09,  0x06,  0x06 },\t \n\t{  0x60,  0x05,  0x0f,  0x0a },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n};\n\nstatic const u8 integrated_ctle_tunings[11][4] = {\n\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x58,  0x0a,  0x05,  0x05 },\t \n\t{  0x48,  0x0a,  0x05,  0x05 },\t \n\t{  0x40,  0x0a,  0x05,  0x05 },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x38,  0x0f,  0x00,  0x00 },\t \n\t{  0x38,  0x09,  0x06,  0x06 },\t \n\t{  0x38,  0x0e,  0x01,  0x01 },\t \n};\n\n \n#define eq_value(pre, curr, post) \\\n\t((((u32)(pre)) << \\\n\t\t\tPCIE_CFG_REG_PL102_GEN3_EQ_PRE_CURSOR_PSET_SHIFT) \\\n\t| (((u32)(curr)) << PCIE_CFG_REG_PL102_GEN3_EQ_CURSOR_PSET_SHIFT) \\\n\t| (((u32)(post)) << \\\n\t\tPCIE_CFG_REG_PL102_GEN3_EQ_POST_CURSOR_PSET_SHIFT))\n\n \nstatic int load_eq_table(struct hfi1_devdata *dd, const u8 eq[11][3], u8 fs,\n\t\t\t u8 div)\n{\n\tstruct pci_dev *pdev = dd->pcidev;\n\tu32 hit_error = 0;\n\tu32 violation;\n\tu32 i;\n\tu8 c_minus1, c0, c_plus1;\n\tint ret;\n\n\tfor (i = 0; i < 11; i++) {\n\t\t \n\t\tpci_write_config_dword(pdev, PCIE_CFG_REG_PL103, i);\n\t\t \n\t\tc_minus1 = eq[i][PREC] / div;\n\t\tc0 = fs - (eq[i][PREC] / div) - (eq[i][POST] / div);\n\t\tc_plus1 = eq[i][POST] / div;\n\t\tpci_write_config_dword(pdev, PCIE_CFG_REG_PL102,\n\t\t\t\t       eq_value(c_minus1, c0, c_plus1));\n\t\t \n\t\tret = pci_read_config_dword(dd->pcidev,\n\t\t\t\t\t    PCIE_CFG_REG_PL105, &violation);\n\t\tif (ret) {\n\t\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\t\thit_error = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (violation\n\t\t    & PCIE_CFG_REG_PL105_GEN3_EQ_VIOLATE_COEF_RULES_SMASK){\n\t\t\tif (hit_error == 0) {\n\t\t\t\tdd_dev_err(dd,\n\t\t\t\t\t   \"Gen3 EQ Table Coefficient rule violations\\n\");\n\t\t\t\tdd_dev_err(dd, \"         prec   attn   post\\n\");\n\t\t\t}\n\t\t\tdd_dev_err(dd, \"   p%02d:   %02x     %02x     %02x\\n\",\n\t\t\t\t   i, (u32)eq[i][0], (u32)eq[i][1],\n\t\t\t\t   (u32)eq[i][2]);\n\t\t\tdd_dev_err(dd, \"            %02x     %02x     %02x\\n\",\n\t\t\t\t   (u32)c_minus1, (u32)c0, (u32)c_plus1);\n\t\t\thit_error = 1;\n\t\t}\n\t}\n\tif (hit_error)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n \nstatic void pcie_post_steps(struct hfi1_devdata *dd)\n{\n\tint i;\n\n\tset_sbus_fast_mode(dd);\n\t \n\tfor (i = 0; i < NUM_PCIE_SERDES; i++) {\n\t\tsbus_request(dd, pcie_pcs_addrs[dd->hfi1_id][i],\n\t\t\t     0x03, WRITE_SBUS_RECEIVER, 0x00022132);\n\t}\n\n\tclear_sbus_fast_mode(dd);\n}\n\n \nstatic int trigger_sbr(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *dev = dd->pcidev;\n\tstruct pci_dev *pdev;\n\n\t \n\tif (!dev->bus->self) {\n\t\tdd_dev_err(dd, \"%s: no parent device\\n\", __func__);\n\t\treturn -ENOTTY;\n\t}\n\n\t \n\tlist_for_each_entry(pdev, &dev->bus->devices, bus_list)\n\t\tif (pdev != dev) {\n\t\t\tdd_dev_err(dd,\n\t\t\t\t   \"%s: another device is on the same bus\\n\",\n\t\t\t\t   __func__);\n\t\t\treturn -ENOTTY;\n\t\t}\n\n\t \n\treturn pci_bridge_secondary_bus_reset(dev->bus->self);\n}\n\n \nstatic void write_gasket_interrupt(struct hfi1_devdata *dd, int index,\n\t\t\t\t   u16 code, u16 data)\n{\n\twrite_csr(dd, ASIC_PCIE_SD_INTRPT_LIST + (index * 8),\n\t\t  (((u64)code << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_CODE_SHIFT) |\n\t\t   ((u64)data << ASIC_PCIE_SD_INTRPT_LIST_INTRPT_DATA_SHIFT)));\n}\n\n \nstatic void arm_gasket_logic(struct hfi1_devdata *dd)\n{\n\tu64 reg;\n\n\treg = (((u64)1 << dd->hfi1_id) <<\n\t       ASIC_PCIE_SD_HOST_CMD_INTRPT_CMD_SHIFT) |\n\t      ((u64)pcie_serdes_broadcast[dd->hfi1_id] <<\n\t       ASIC_PCIE_SD_HOST_CMD_SBUS_RCVR_ADDR_SHIFT |\n\t       ASIC_PCIE_SD_HOST_CMD_SBR_MODE_SMASK |\n\t       ((u64)SBR_DELAY_US & ASIC_PCIE_SD_HOST_CMD_TIMER_MASK) <<\n\t       ASIC_PCIE_SD_HOST_CMD_TIMER_SHIFT);\n\twrite_csr(dd, ASIC_PCIE_SD_HOST_CMD, reg);\n\t \n\tread_csr(dd, ASIC_PCIE_SD_HOST_CMD);\n}\n\n \n#define LANE_BUNDLE_MASK              CCE_PCIE_CTRL_PCIE_LANE_BUNDLE_MASK\n#define LANE_BUNDLE_SHIFT             CCE_PCIE_CTRL_PCIE_LANE_BUNDLE_SHIFT\n#define LANE_DELAY_MASK               CCE_PCIE_CTRL_PCIE_LANE_DELAY_MASK\n#define LANE_DELAY_SHIFT              CCE_PCIE_CTRL_PCIE_LANE_DELAY_SHIFT\n#define MARGIN_OVERWRITE_ENABLE_SHIFT CCE_PCIE_CTRL_XMT_MARGIN_OVERWRITE_ENABLE_SHIFT\n#define MARGIN_SHIFT                  CCE_PCIE_CTRL_XMT_MARGIN_SHIFT\n#define MARGIN_G1_G2_OVERWRITE_MASK   CCE_PCIE_CTRL_XMT_MARGIN_GEN1_GEN2_OVERWRITE_ENABLE_MASK\n#define MARGIN_G1_G2_OVERWRITE_SHIFT  CCE_PCIE_CTRL_XMT_MARGIN_GEN1_GEN2_OVERWRITE_ENABLE_SHIFT\n#define MARGIN_GEN1_GEN2_MASK         CCE_PCIE_CTRL_XMT_MARGIN_GEN1_GEN2_MASK\n#define MARGIN_GEN1_GEN2_SHIFT        CCE_PCIE_CTRL_XMT_MARGIN_GEN1_GEN2_SHIFT\n\n  \nstatic void write_xmt_margin(struct hfi1_devdata *dd, const char *fname)\n{\n\tu64 pcie_ctrl;\n\tu64 xmt_margin;\n\tu64 xmt_margin_oe;\n\tu64 lane_delay;\n\tu64 lane_bundle;\n\n\tpcie_ctrl = read_csr(dd, CCE_PCIE_CTRL);\n\n\t \n\tif (dd->pcidev->device == PCI_DEVICE_ID_INTEL1) {  \n\t\t \n\t\txmt_margin = (pcie_ctrl >> MARGIN_GEN1_GEN2_SHIFT)\n\t\t\t      & MARGIN_GEN1_GEN2_MASK;\n\t\txmt_margin_oe = (pcie_ctrl >> MARGIN_G1_G2_OVERWRITE_SHIFT)\n\t\t\t\t & MARGIN_G1_G2_OVERWRITE_MASK;\n\t\tlane_delay = (pcie_ctrl >> LANE_DELAY_SHIFT) & LANE_DELAY_MASK;\n\t\tlane_bundle = (pcie_ctrl >> LANE_BUNDLE_SHIFT)\n\t\t\t       & LANE_BUNDLE_MASK;\n\n\t\t \n\t\tif (is_ax(dd)) {\n\t\t\t \n\t\t\txmt_margin = 0x5;\n\t\t\txmt_margin_oe = 0x1;\n\t\t\tlane_delay = 0xF;  \n\t\t\tlane_bundle = 0x0;  \n\t\t}\n\n\t\t \n\t\tpcie_ctrl = (xmt_margin << MARGIN_GEN1_GEN2_SHIFT)\n\t\t\t| (xmt_margin_oe << MARGIN_G1_G2_OVERWRITE_SHIFT)\n\t\t\t| (xmt_margin << MARGIN_SHIFT)\n\t\t\t| (xmt_margin_oe << MARGIN_OVERWRITE_ENABLE_SHIFT)\n\t\t\t| (lane_delay << LANE_DELAY_SHIFT)\n\t\t\t| (lane_bundle << LANE_BUNDLE_SHIFT);\n\n\t\twrite_csr(dd, CCE_PCIE_CTRL, pcie_ctrl);\n\t}\n\n\tdd_dev_dbg(dd, \"%s: program XMT margin, CcePcieCtrl 0x%llx\\n\",\n\t\t   fname, pcie_ctrl);\n}\n\n \nint do_pcie_gen3_transition(struct hfi1_devdata *dd)\n{\n\tstruct pci_dev *parent = dd->pcidev->bus->self;\n\tu64 fw_ctrl;\n\tu64 reg, therm;\n\tu32 reg32, fs, lf;\n\tu32 status, err;\n\tint ret;\n\tint do_retry, retry_count = 0;\n\tint intnum = 0;\n\tuint default_pset;\n\tuint pset = pcie_pset;\n\tu16 target_vector, target_speed;\n\tu16 lnkctl2, vendor;\n\tu8 div;\n\tconst u8 (*eq)[3];\n\tconst u8 (*ctle_tunings)[4];\n\tuint static_ctle_mode;\n\tint return_error = 0;\n\tu32 target_width;\n\n\t \n\tif (dd->icode != ICODE_RTL_SILICON)\n\t\treturn 0;\n\n\tif (pcie_target == 1) {\t\t\t \n\t\ttarget_vector = PCI_EXP_LNKCTL2_TLS_2_5GT;\n\t\ttarget_speed = 2500;\n\t} else if (pcie_target == 2) {\t\t \n\t\ttarget_vector = PCI_EXP_LNKCTL2_TLS_5_0GT;\n\t\ttarget_speed = 5000;\n\t} else if (pcie_target == 3) {\t\t \n\t\ttarget_vector = PCI_EXP_LNKCTL2_TLS_8_0GT;\n\t\ttarget_speed = 8000;\n\t} else {\n\t\t \n\t\tdd_dev_info(dd, \"%s: Skipping PCIe transition\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\t \n\tif (dd->lbus_speed == target_speed) {\n\t\tdd_dev_info(dd, \"%s: PCIe already at gen%d, %s\\n\", __func__,\n\t\t\t    pcie_target,\n\t\t\t    pcie_force ? \"re-doing anyway\" : \"skipping\");\n\t\tif (!pcie_force)\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!parent) {\n\t\tdd_dev_info(dd, \"%s: No upstream, Can't do gen3 transition\\n\",\n\t\t\t    __func__);\n\t\treturn 0;\n\t}\n\n\t \n\ttarget_width = dd->lbus_width;\n\n\t \n\n\t \n\n\t \n\tif (pcie_target == 3 && !dd->link_gen3_capable) {\n\t\tdd_dev_err(dd, \"The PCIe link is not Gen3 capable\\n\");\n\t\tret = -ENOSYS;\n\t\tgoto done_no_mutex;\n\t}\n\n\t \n\tret = acquire_chip_resource(dd, CR_SBUS, SBUS_TIMEOUT);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"%s: unable to acquire SBus resource\\n\",\n\t\t\t   __func__);\n\t\treturn ret;\n\t}\n\n\t \n\ttherm = read_csr(dd, ASIC_CFG_THERM_POLL_EN);\n\tif (therm) {\n\t\twrite_csr(dd, ASIC_CFG_THERM_POLL_EN, 0x0);\n\t\tmsleep(100);\n\t\tdd_dev_info(dd, \"%s: Disabled therm polling\\n\",\n\t\t\t    __func__);\n\t}\n\nretry:\n\t \n\n\t \n\t \n\tdd_dev_info(dd, \"%s: downloading firmware\\n\", __func__);\n\tret = load_pcie_firmware(dd);\n\tif (ret) {\n\t\t \n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\t \n\tdd_dev_info(dd, \"%s: setting PCIe registers\\n\", __func__);\n\n\t \n\n\t \n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_SPCIE2, 0xffff);\n\n\t \n\n\t \n\treg32 = 0x10ul << PCIE_CFG_REG_PL2_LOW_PWR_ENT_CNT_SHIFT;\n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_REG_PL2, reg32);\n\n\t \n\treg32 = PCIE_CFG_REG_PL100_EQ_EIEOS_CNT_SMASK;\n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_REG_PL100, reg32);\n\n\t \n\tif (dd->pcidev->device == PCI_DEVICE_ID_INTEL0) {  \n\t\t \n\t\tfs = 24;\n\t\tlf = 8;\n\t\tdiv = 3;\n\t\teq = discrete_preliminary_eq;\n\t\tdefault_pset = DEFAULT_DISCRETE_PSET;\n\t\tctle_tunings = discrete_ctle_tunings;\n\t\t \n\t\tstatic_ctle_mode = pcie_ctle & 0x1;\n\t} else {\n\t\t \n\t\tfs = 29;\n\t\tlf = 9;\n\t\tdiv = 1;\n\t\teq = integrated_preliminary_eq;\n\t\tdefault_pset = DEFAULT_MCP_PSET;\n\t\tctle_tunings = integrated_ctle_tunings;\n\t\t \n\t\tstatic_ctle_mode = (pcie_ctle >> 1) & 0x1;\n\t}\n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_REG_PL101,\n\t\t\t       (fs <<\n\t\t\t\tPCIE_CFG_REG_PL101_GEN3_EQ_LOCAL_FS_SHIFT) |\n\t\t\t       (lf <<\n\t\t\t\tPCIE_CFG_REG_PL101_GEN3_EQ_LOCAL_LF_SHIFT));\n\tret = load_eq_table(dd, eq, fs, div);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tif (pset == UNSET_PSET)\n\t\tpset = default_pset;\n\tif (pset > 10) {\t \n\t\tdd_dev_err(dd, \"%s: Invalid Eq Pset %u, setting to %d\\n\",\n\t\t\t   __func__, pset, default_pset);\n\t\tpset = default_pset;\n\t}\n\tdd_dev_info(dd, \"%s: using EQ Pset %u\\n\", __func__, pset);\n\tpci_write_config_dword(dd->pcidev, PCIE_CFG_REG_PL106,\n\t\t\t       ((1 << pset) <<\n\t\t\tPCIE_CFG_REG_PL106_GEN3_EQ_PSET_REQ_VEC_SHIFT) |\n\t\t\tPCIE_CFG_REG_PL106_GEN3_EQ_EVAL2MS_DISABLE_SMASK |\n\t\t\tPCIE_CFG_REG_PL106_GEN3_EQ_PHASE23_EXIT_MODE_SMASK);\n\n\t \n\tdd_dev_info(dd, \"%s: doing pcie post steps\\n\", __func__);\n\tpcie_post_steps(dd);\n\n\t \n\t \n\twrite_gasket_interrupt(dd, intnum++, 0x0006, 0x0050);\n\t \n\t \n\twrite_gasket_interrupt(dd, intnum++, 0x0026,\n\t\t\t       0x5b01 | (static_ctle_mode << 3));\n\t \n\twrite_gasket_interrupt(dd, intnum++, 0x0026, 0x5202);\n\n\tif (static_ctle_mode) {\n\t\t \n\t\tu8 pcie_dc, pcie_lf, pcie_hf, pcie_bw;\n\n\t\tpcie_dc = ctle_tunings[pset][0];\n\t\tpcie_lf = ctle_tunings[pset][1];\n\t\tpcie_hf = ctle_tunings[pset][2];\n\t\tpcie_bw = ctle_tunings[pset][3];\n\t\twrite_gasket_interrupt(dd, intnum++, 0x0026, 0x0200 | pcie_dc);\n\t\twrite_gasket_interrupt(dd, intnum++, 0x0026, 0x0100 | pcie_lf);\n\t\twrite_gasket_interrupt(dd, intnum++, 0x0026, 0x0000 | pcie_hf);\n\t\twrite_gasket_interrupt(dd, intnum++, 0x0026, 0x5500 | pcie_bw);\n\t}\n\n\t \n\twrite_gasket_interrupt(dd, intnum++, 0x0000, 0x0000);\n\n\t \n\twrite_xmt_margin(dd, __func__);\n\n\t \n\tdd_dev_info(dd, \"%s: clearing ASPM\\n\", __func__);\n\taspm_hw_disable_l1(dd);\n\n\t \n\n\t \n\t \n\tdd_dev_info(dd, \"%s: setting parent target link speed\\n\", __func__);\n\tret = pcie_capability_read_word(parent, PCI_EXP_LNKCTL2, &lnkctl2);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\tdd_dev_info(dd, \"%s: ..old link control2: 0x%x\\n\", __func__,\n\t\t    (u32)lnkctl2);\n\t \n\tif ((lnkctl2 & PCI_EXP_LNKCTL2_TLS) < target_vector) {\n\t\tlnkctl2 &= ~PCI_EXP_LNKCTL2_TLS;\n\t\tlnkctl2 |= target_vector;\n\t\tdd_dev_info(dd, \"%s: ..new link control2: 0x%x\\n\", __func__,\n\t\t\t    (u32)lnkctl2);\n\t\tret = pcie_capability_write_word(parent,\n\t\t\t\t\t\t PCI_EXP_LNKCTL2, lnkctl2);\n\t\tif (ret) {\n\t\t\tdd_dev_err(dd, \"Unable to write to PCI config\\n\");\n\t\t\treturn_error = 1;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tdd_dev_info(dd, \"%s: ..target speed is OK\\n\", __func__);\n\t}\n\n\tdd_dev_info(dd, \"%s: setting target link speed\\n\", __func__);\n\tret = pcie_capability_read_word(dd->pcidev, PCI_EXP_LNKCTL2, &lnkctl2);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\tdd_dev_info(dd, \"%s: ..old link control2: 0x%x\\n\", __func__,\n\t\t    (u32)lnkctl2);\n\tlnkctl2 &= ~PCI_EXP_LNKCTL2_TLS;\n\tlnkctl2 |= target_vector;\n\tdd_dev_info(dd, \"%s: ..new link control2: 0x%x\\n\", __func__,\n\t\t    (u32)lnkctl2);\n\tret = pcie_capability_write_word(dd->pcidev, PCI_EXP_LNKCTL2, lnkctl2);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to write to PCI config\\n\");\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\t \n\t \n\twrite_csr(dd, CCE_DC_CTRL, CCE_DC_CTRL_DC_RESET_SMASK);\n\t(void)read_csr(dd, CCE_DC_CTRL);  \n\t \n\tfw_ctrl = read_csr(dd, MISC_CFG_FW_CTRL);\n\n\tdd_dev_info(dd, \"%s: arming gasket logic\\n\", __func__);\n\tarm_gasket_logic(dd);\n\n\t \n\n\t \n\tdd_dev_info(dd, \"%s: calling trigger_sbr\\n\", __func__);\n\tret = trigger_sbr(dd);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\n\t \n\tret = pci_read_config_word(dd->pcidev, PCI_VENDOR_ID, &vendor);\n\tif (ret) {\n\t\tdd_dev_info(dd,\n\t\t\t    \"%s: read of VendorID failed after SBR, err %d\\n\",\n\t\t\t    __func__, ret);\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\tif (vendor == 0xffff) {\n\t\tdd_dev_info(dd, \"%s: VendorID is all 1s after SBR\\n\", __func__);\n\t\treturn_error = 1;\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tdd_dev_info(dd, \"%s: calling restore_pci_variables\\n\", __func__);\n\tret = restore_pci_variables(dd);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"%s: Could not restore PCI variables\\n\",\n\t\t\t   __func__);\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\t \n\twrite_csr(dd, MISC_CFG_FW_CTRL, fw_ctrl);\n\n\t \n\treg = read_csr(dd, ASIC_PCIE_SD_HOST_STATUS);\n\tdd_dev_info(dd, \"%s: gasket block status: 0x%llx\\n\", __func__, reg);\n\tif (reg == ~0ull) {\t \n\t\tdd_dev_err(dd, \"SBR failed - unable to read from device\\n\");\n\t\treturn_error = 1;\n\t\tret = -ENOSYS;\n\t\tgoto done;\n\t}\n\n\t \n\twrite_csr(dd, CCE_DC_CTRL, 0);\n\n\t \n\tsetextled(dd, 0);\n\n\t \n\tret = pci_read_config_dword(dd->pcidev, PCIE_CFG_SPCIE2, &reg32);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to read from PCI config\\n\");\n\t\treturn_error = 1;\n\t\tgoto done;\n\t}\n\n\tdd_dev_info(dd, \"%s: per-lane errors: 0x%x\\n\", __func__, reg32);\n\n\t \n\tstatus = (reg >> ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_STS_SHIFT)\n\t\t\t& ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_STS_MASK;\n\tif ((status & (1 << dd->hfi1_id)) == 0) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"%s: gasket status 0x%x, expecting 0x%x\\n\",\n\t\t\t   __func__, status, 1 << dd->hfi1_id);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\terr = (reg >> ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_ERR_SHIFT)\n\t\t& ASIC_PCIE_SD_HOST_STATUS_FW_DNLD_ERR_MASK;\n\tif (err) {\n\t\tdd_dev_err(dd, \"%s: gasket error %d\\n\", __func__, err);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\t \n\tupdate_lbus_info(dd);\n\tdd_dev_info(dd, \"%s: new speed and width: %s\\n\", __func__,\n\t\t    dd->lbus_info);\n\n\tif (dd->lbus_speed != target_speed ||\n\t    dd->lbus_width < target_width) {  \n\t\t \n\t\tdo_retry = retry_count < pcie_retry;\n\t\tdd_dev_err(dd, \"PCIe link speed or width did not match target%s\\n\",\n\t\t\t   do_retry ? \", retrying\" : \"\");\n\t\tretry_count++;\n\t\tif (do_retry) {\n\t\t\tmsleep(100);  \n\t\t\tgoto retry;\n\t\t}\n\t\tret = -EIO;\n\t}\n\ndone:\n\tif (therm) {\n\t\twrite_csr(dd, ASIC_CFG_THERM_POLL_EN, 0x1);\n\t\tmsleep(100);\n\t\tdd_dev_info(dd, \"%s: Re-enable therm polling\\n\",\n\t\t\t    __func__);\n\t}\n\trelease_chip_resource(dd, CR_SBUS);\ndone_no_mutex:\n\t \n\tif (ret && !return_error) {\n\t\tdd_dev_err(dd, \"Proceeding at current speed PCIe speed\\n\");\n\t\tret = 0;\n\t}\n\n\tdd_dev_info(dd, \"%s: done\\n\", __func__);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}