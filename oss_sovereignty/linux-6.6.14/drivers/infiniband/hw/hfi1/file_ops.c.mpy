{
  "module_name": "file_ops.c",
  "hash_id": "2e0ed7e9947dc83ffbcdec06d21d5e780ad7bec8d5afd9a0e004e40e5340f70a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/file_ops.c",
  "human_readable_source": "\n \n\n#include <linux/poll.h>\n#include <linux/cdev.h>\n#include <linux/vmalloc.h>\n#include <linux/io.h>\n#include <linux/sched/mm.h>\n#include <linux/bitmap.h>\n\n#include <rdma/ib.h>\n\n#include \"hfi.h\"\n#include \"pio.h\"\n#include \"device.h\"\n#include \"common.h\"\n#include \"trace.h\"\n#include \"mmu_rb.h\"\n#include \"user_sdma.h\"\n#include \"user_exp_rcv.h\"\n#include \"aspm.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) DRIVER_NAME \": \" fmt\n\n#define SEND_CTXT_HALT_TIMEOUT 1000  \n\n \nstatic int hfi1_file_open(struct inode *inode, struct file *fp);\nstatic int hfi1_file_close(struct inode *inode, struct file *fp);\nstatic ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from);\nstatic __poll_t hfi1_poll(struct file *fp, struct poll_table_struct *pt);\nstatic int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma);\n\nstatic u64 kvirt_to_phys(void *addr);\nstatic int assign_ctxt(struct hfi1_filedata *fd, unsigned long arg, u32 len);\nstatic void init_subctxts(struct hfi1_ctxtdata *uctxt,\n\t\t\t  const struct hfi1_user_info *uinfo);\nstatic int init_user_ctxt(struct hfi1_filedata *fd,\n\t\t\t  struct hfi1_ctxtdata *uctxt);\nstatic void user_init(struct hfi1_ctxtdata *uctxt);\nstatic int get_ctxt_info(struct hfi1_filedata *fd, unsigned long arg, u32 len);\nstatic int get_base_info(struct hfi1_filedata *fd, unsigned long arg, u32 len);\nstatic int user_exp_rcv_setup(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t      u32 len);\nstatic int user_exp_rcv_clear(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t      u32 len);\nstatic int user_exp_rcv_invalid(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t\tu32 len);\nstatic int setup_base_ctxt(struct hfi1_filedata *fd,\n\t\t\t   struct hfi1_ctxtdata *uctxt);\nstatic int setup_subctxt(struct hfi1_ctxtdata *uctxt);\n\nstatic int find_sub_ctxt(struct hfi1_filedata *fd,\n\t\t\t const struct hfi1_user_info *uinfo);\nstatic int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,\n\t\t\t struct hfi1_user_info *uinfo,\n\t\t\t struct hfi1_ctxtdata **cd);\nstatic void deallocate_ctxt(struct hfi1_ctxtdata *uctxt);\nstatic __poll_t poll_urgent(struct file *fp, struct poll_table_struct *pt);\nstatic __poll_t poll_next(struct file *fp, struct poll_table_struct *pt);\nstatic int user_event_ack(struct hfi1_ctxtdata *uctxt, u16 subctxt,\n\t\t\t  unsigned long arg);\nstatic int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned long arg);\nstatic int ctxt_reset(struct hfi1_ctxtdata *uctxt);\nstatic int manage_rcvq(struct hfi1_ctxtdata *uctxt, u16 subctxt,\n\t\t       unsigned long arg);\nstatic vm_fault_t vma_fault(struct vm_fault *vmf);\nstatic long hfi1_file_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t    unsigned long arg);\n\nstatic const struct file_operations hfi1_file_ops = {\n\t.owner = THIS_MODULE,\n\t.write_iter = hfi1_write_iter,\n\t.open = hfi1_file_open,\n\t.release = hfi1_file_close,\n\t.unlocked_ioctl = hfi1_file_ioctl,\n\t.poll = hfi1_poll,\n\t.mmap = hfi1_file_mmap,\n\t.llseek = noop_llseek,\n};\n\nstatic const struct vm_operations_struct vm_ops = {\n\t.fault = vma_fault,\n};\n\n \nenum mmap_types {\n\tPIO_BUFS = 1,\n\tPIO_BUFS_SOP,\n\tPIO_CRED,\n\tRCV_HDRQ,\n\tRCV_EGRBUF,\n\tUREGS,\n\tEVENTS,\n\tSTATUS,\n\tRTAIL,\n\tSUBCTXT_UREGS,\n\tSUBCTXT_RCV_HDRQ,\n\tSUBCTXT_EGRBUF,\n\tSDMA_COMP\n};\n\n \n#define HFI1_MMAP_OFFSET_MASK   0xfffULL\n#define HFI1_MMAP_OFFSET_SHIFT  0\n#define HFI1_MMAP_SUBCTXT_MASK  0xfULL\n#define HFI1_MMAP_SUBCTXT_SHIFT 12\n#define HFI1_MMAP_CTXT_MASK     0xffULL\n#define HFI1_MMAP_CTXT_SHIFT    16\n#define HFI1_MMAP_TYPE_MASK     0xfULL\n#define HFI1_MMAP_TYPE_SHIFT    24\n#define HFI1_MMAP_MAGIC_MASK    0xffffffffULL\n#define HFI1_MMAP_MAGIC_SHIFT   32\n\n#define HFI1_MMAP_MAGIC         0xdabbad00\n\n#define HFI1_MMAP_TOKEN_SET(field, val)\t\\\n\t(((val) & HFI1_MMAP_##field##_MASK) << HFI1_MMAP_##field##_SHIFT)\n#define HFI1_MMAP_TOKEN_GET(field, token) \\\n\t(((token) >> HFI1_MMAP_##field##_SHIFT) & HFI1_MMAP_##field##_MASK)\n#define HFI1_MMAP_TOKEN(type, ctxt, subctxt, addr)   \\\n\t(HFI1_MMAP_TOKEN_SET(MAGIC, HFI1_MMAP_MAGIC) | \\\n\tHFI1_MMAP_TOKEN_SET(TYPE, type) | \\\n\tHFI1_MMAP_TOKEN_SET(CTXT, ctxt) | \\\n\tHFI1_MMAP_TOKEN_SET(SUBCTXT, subctxt) | \\\n\tHFI1_MMAP_TOKEN_SET(OFFSET, (offset_in_page(addr))))\n\n#define dbg(fmt, ...)\t\t\t\t\\\n\tpr_info(fmt, ##__VA_ARGS__)\n\nstatic inline int is_valid_mmap(u64 token)\n{\n\treturn (HFI1_MMAP_TOKEN_GET(MAGIC, token) == HFI1_MMAP_MAGIC);\n}\n\nstatic int hfi1_file_open(struct inode *inode, struct file *fp)\n{\n\tstruct hfi1_filedata *fd;\n\tstruct hfi1_devdata *dd = container_of(inode->i_cdev,\n\t\t\t\t\t       struct hfi1_devdata,\n\t\t\t\t\t       user_cdev);\n\n\tif (!((dd->flags & HFI1_PRESENT) && dd->kregbase1))\n\t\treturn -EINVAL;\n\n\tif (!refcount_inc_not_zero(&dd->user_refcount))\n\t\treturn -ENXIO;\n\n\t \n\n\tfd = kzalloc(sizeof(*fd), GFP_KERNEL);\n\n\tif (!fd || init_srcu_struct(&fd->pq_srcu))\n\t\tgoto nomem;\n\tspin_lock_init(&fd->pq_rcu_lock);\n\tspin_lock_init(&fd->tid_lock);\n\tspin_lock_init(&fd->invalid_lock);\n\tfd->rec_cpu_num = -1;  \n\tfd->dd = dd;\n\tfp->private_data = fd;\n\treturn 0;\nnomem:\n\tkfree(fd);\n\tfp->private_data = NULL;\n\tif (refcount_dec_and_test(&dd->user_refcount))\n\t\tcomplete(&dd->user_comp);\n\treturn -ENOMEM;\n}\n\nstatic long hfi1_file_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t    unsigned long arg)\n{\n\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tint ret = 0;\n\tint uval = 0;\n\n\thfi1_cdbg(IOCTL, \"IOCTL recv: 0x%x\", cmd);\n\tif (cmd != HFI1_IOCTL_ASSIGN_CTXT &&\n\t    cmd != HFI1_IOCTL_GET_VERS &&\n\t    !uctxt)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\tcase HFI1_IOCTL_ASSIGN_CTXT:\n\t\tret = assign_ctxt(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_CTXT_INFO:\n\t\tret = get_ctxt_info(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_USER_INFO:\n\t\tret = get_base_info(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_CREDIT_UPD:\n\t\tif (uctxt)\n\t\t\tsc_return_credits(uctxt->sc);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_TID_UPDATE:\n\t\tret = user_exp_rcv_setup(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_TID_FREE:\n\t\tret = user_exp_rcv_clear(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_TID_INVAL_READ:\n\t\tret = user_exp_rcv_invalid(fd, arg, _IOC_SIZE(cmd));\n\t\tbreak;\n\n\tcase HFI1_IOCTL_RECV_CTRL:\n\t\tret = manage_rcvq(uctxt, fd->subctxt, arg);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_POLL_TYPE:\n\t\tif (get_user(uval, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\tuctxt->poll_type = (typeof(uctxt->poll_type))uval;\n\t\tbreak;\n\n\tcase HFI1_IOCTL_ACK_EVENT:\n\t\tret = user_event_ack(uctxt, fd->subctxt, arg);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_SET_PKEY:\n\t\tret = set_ctxt_pkey(uctxt, arg);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_CTXT_RESET:\n\t\tret = ctxt_reset(uctxt);\n\t\tbreak;\n\n\tcase HFI1_IOCTL_GET_VERS:\n\t\tuval = HFI1_USER_SWVERSION;\n\t\tif (put_user(uval, (int __user *)arg))\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t hfi1_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct hfi1_filedata *fd = kiocb->ki_filp->private_data;\n\tstruct hfi1_user_sdma_pkt_q *pq;\n\tstruct hfi1_user_sdma_comp_q *cq = fd->cq;\n\tint done = 0, reqs = 0;\n\tunsigned long dim = from->nr_segs;\n\tint idx;\n\n\tif (!HFI1_CAP_IS_KSET(SDMA))\n\t\treturn -EINVAL;\n\tif (!from->user_backed)\n\t\treturn -EINVAL;\n\tidx = srcu_read_lock(&fd->pq_srcu);\n\tpq = srcu_dereference(fd->pq, &fd->pq_srcu);\n\tif (!cq || !pq) {\n\t\tsrcu_read_unlock(&fd->pq_srcu, idx);\n\t\treturn -EIO;\n\t}\n\n\ttrace_hfi1_sdma_request(fd->dd, fd->uctxt->ctxt, fd->subctxt, dim);\n\n\tif (atomic_read(&pq->n_reqs) == pq->n_max_reqs) {\n\t\tsrcu_read_unlock(&fd->pq_srcu, idx);\n\t\treturn -ENOSPC;\n\t}\n\n\twhile (dim) {\n\t\tconst struct iovec *iov = iter_iov(from);\n\t\tint ret;\n\t\tunsigned long count = 0;\n\n\t\tret = hfi1_user_sdma_process_request(\n\t\t\tfd, (struct iovec *)(iov + done),\n\t\t\tdim, &count);\n\t\tif (ret) {\n\t\t\treqs = ret;\n\t\t\tbreak;\n\t\t}\n\t\tdim -= count;\n\t\tdone += count;\n\t\treqs++;\n\t}\n\n\tsrcu_read_unlock(&fd->pq_srcu, idx);\n\treturn reqs;\n}\n\nstatic inline void mmap_cdbg(u16 ctxt, u8 subctxt, u8 type, u8 mapio, u8 vmf,\n\t\t\t     u64 memaddr, void *memvirt, dma_addr_t memdma,\n\t\t\t     ssize_t memlen, struct vm_area_struct *vma)\n{\n\thfi1_cdbg(PROC,\n\t\t  \"%u:%u type:%u io/vf/dma:%d/%d/%d, addr:0x%llx, len:%lu(%lu), flags:0x%lx\",\n\t\t  ctxt, subctxt, type, mapio, vmf, !!memdma,\n\t\t  memaddr ?: (u64)memvirt, memlen,\n\t\t  vma->vm_end - vma->vm_start, vma->vm_flags);\n}\n\nstatic int hfi1_file_mmap(struct file *fp, struct vm_area_struct *vma)\n{\n\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd;\n\tunsigned long flags;\n\tu64 token = vma->vm_pgoff << PAGE_SHIFT,\n\t\tmemaddr = 0;\n\tvoid *memvirt = NULL;\n\tdma_addr_t memdma = 0;\n\tu8 subctxt, mapio = 0, vmf = 0, type;\n\tssize_t memlen = 0;\n\tint ret = 0;\n\tu16 ctxt;\n\n\tif (!is_valid_mmap(token) || !uctxt ||\n\t    !(vma->vm_flags & VM_SHARED)) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tdd = uctxt->dd;\n\tctxt = HFI1_MMAP_TOKEN_GET(CTXT, token);\n\tsubctxt = HFI1_MMAP_TOKEN_GET(SUBCTXT, token);\n\ttype = HFI1_MMAP_TOKEN_GET(TYPE, token);\n\tif (ctxt != uctxt->ctxt || subctxt != fd->subctxt) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t  \n\tvma->vm_pgoff = 0;\n\tflags = vma->vm_flags;\n\n\tswitch (type) {\n\tcase PIO_BUFS:\n\tcase PIO_BUFS_SOP:\n\t\tmemaddr = ((dd->physaddr + TXE_PIO_SEND) +\n\t\t\t\t \n\t\t\t   (uctxt->sc->hw_context * BIT(16))) +\n\t\t\t\t \n\t\t\t(type == PIO_BUFS_SOP ?\n\t\t\t\t(TXE_PIO_SIZE / 2) : 0);  \n\t\t \n\t\tmemlen = PAGE_ALIGN(uctxt->sc->credits * PIO_BLOCK_SIZE);\n\t\tflags &= ~VM_MAYREAD;\n\t\tflags |= VM_DONTCOPY | VM_DONTEXPAND;\n\t\tvma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);\n\t\tmapio = 1;\n\t\tbreak;\n\tcase PIO_CRED: {\n\t\tu64 cr_page_offset;\n\t\tif (flags & VM_WRITE) {\n\t\t\tret = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tcr_page_offset = ((u64)uctxt->sc->hw_free -\n\t\t\t  \t     (u64)dd->cr_base[uctxt->numa_id].va) &\n\t\t\t\t   PAGE_MASK;\n\t\tmemvirt = dd->cr_base[uctxt->numa_id].va + cr_page_offset;\n\t\tmemdma = dd->cr_base[uctxt->numa_id].dma + cr_page_offset;\n\t\tmemlen = PAGE_SIZE;\n\t\tflags &= ~VM_MAYWRITE;\n\t\tflags |= VM_DONTCOPY | VM_DONTEXPAND;\n\t\t \n\t\t \n\t\tbreak;\n\t}\n\tcase RCV_HDRQ:\n\t\tmemlen = rcvhdrq_size(uctxt);\n\t\tmemvirt = uctxt->rcvhdrq;\n\t\tmemdma = uctxt->rcvhdrq_dma;\n\t\tbreak;\n\tcase RCV_EGRBUF: {\n\t\tunsigned long vm_start_save;\n\t\tunsigned long vm_end_save;\n\t\tint i;\n\t\t \n\t\tmemlen = uctxt->egrbufs.size;\n\t\tif ((vma->vm_end - vma->vm_start) != memlen) {\n\t\t\tdd_dev_err(dd, \"Eager buffer map size invalid (%lu != %lu)\\n\",\n\t\t\t\t   (vma->vm_end - vma->vm_start), memlen);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tif (vma->vm_flags & VM_WRITE) {\n\t\t\tret = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tvm_flags_clear(vma, VM_MAYWRITE);\n\t\t \n\t\tvm_start_save = vma->vm_start;\n\t\tvm_end_save = vma->vm_end;\n\t\tvma->vm_end = vma->vm_start;\n\t\tfor (i = 0 ; i < uctxt->egrbufs.numbufs; i++) {\n\t\t\tmemlen = uctxt->egrbufs.buffers[i].len;\n\t\t\tmemvirt = uctxt->egrbufs.buffers[i].addr;\n\t\t\tmemdma = uctxt->egrbufs.buffers[i].dma;\n\t\t\tvma->vm_end += memlen;\n\t\t\tmmap_cdbg(ctxt, subctxt, type, mapio, vmf, memaddr,\n\t\t\t\t  memvirt, memdma, memlen, vma);\n\t\t\tret = dma_mmap_coherent(&dd->pcidev->dev, vma,\n\t\t\t\t\t\tmemvirt, memdma, memlen);\n\t\t\tif (ret < 0) {\n\t\t\t\tvma->vm_start = vm_start_save;\n\t\t\t\tvma->vm_end = vm_end_save;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tvma->vm_start += memlen;\n\t\t}\n\t\tvma->vm_start = vm_start_save;\n\t\tvma->vm_end = vm_end_save;\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tcase UREGS:\n\t\t \n\t\tmemaddr = (unsigned long)\n\t\t\t(dd->physaddr + RXE_PER_CONTEXT_USER)\n\t\t\t+ (uctxt->ctxt * RXE_PER_CONTEXT_SIZE);\n\t\t \n\t\tmemlen = PAGE_SIZE;\n\t\tflags |= VM_DONTCOPY | VM_DONTEXPAND;\n\t\tvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n\t\tmapio = 1;\n\t\tbreak;\n\tcase EVENTS:\n\t\t \n\t\tmemaddr = (unsigned long)\n\t\t\t(dd->events + uctxt_offset(uctxt)) & PAGE_MASK;\n\t\tmemlen = PAGE_SIZE;\n\t\t \n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tvmf = 1;\n\t\tbreak;\n\tcase STATUS:\n\t\tif (flags & VM_WRITE) {\n\t\t\tret = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tmemaddr = kvirt_to_phys((void *)dd->status);\n\t\tmemlen = PAGE_SIZE;\n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tbreak;\n\tcase RTAIL:\n\t\tif (!HFI1_CAP_IS_USET(DMA_RTAIL)) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tif ((flags & VM_WRITE) || !hfi1_rcvhdrtail_kvaddr(uctxt)) {\n\t\t\tret = -EPERM;\n\t\t\tgoto done;\n\t\t}\n\t\tmemlen = PAGE_SIZE;\n\t\tmemvirt = (void *)hfi1_rcvhdrtail_kvaddr(uctxt);\n\t\tmemdma = uctxt->rcvhdrqtailaddr_dma;\n\t\tflags &= ~VM_MAYWRITE;\n\t\tbreak;\n\tcase SUBCTXT_UREGS:\n\t\tmemaddr = (u64)uctxt->subctxt_uregbase;\n\t\tmemlen = PAGE_SIZE;\n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tvmf = 1;\n\t\tbreak;\n\tcase SUBCTXT_RCV_HDRQ:\n\t\tmemaddr = (u64)uctxt->subctxt_rcvhdr_base;\n\t\tmemlen = rcvhdrq_size(uctxt) * uctxt->subctxt_cnt;\n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tvmf = 1;\n\t\tbreak;\n\tcase SUBCTXT_EGRBUF:\n\t\tmemaddr = (u64)uctxt->subctxt_rcvegrbuf;\n\t\tmemlen = uctxt->egrbufs.size * uctxt->subctxt_cnt;\n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tflags &= ~VM_MAYWRITE;\n\t\tvmf = 1;\n\t\tbreak;\n\tcase SDMA_COMP: {\n\t\tstruct hfi1_user_sdma_comp_q *cq = fd->cq;\n\n\t\tif (!cq) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto done;\n\t\t}\n\t\tmemaddr = (u64)cq->comps;\n\t\tmemlen = PAGE_ALIGN(sizeof(*cq->comps) * cq->nentries);\n\t\tflags |= VM_IO | VM_DONTEXPAND;\n\t\tvmf = 1;\n\t\tbreak;\n\t}\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif ((vma->vm_end - vma->vm_start) != memlen) {\n\t\thfi1_cdbg(PROC, \"%u:%u Memory size mismatch %lu:%lu\",\n\t\t\t  uctxt->ctxt, fd->subctxt,\n\t\t\t  (vma->vm_end - vma->vm_start), memlen);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tvm_flags_reset(vma, flags);\n\tmmap_cdbg(ctxt, subctxt, type, mapio, vmf, memaddr, memvirt, memdma, \n\t\t  memlen, vma);\n\tif (vmf) {\n\t\tvma->vm_pgoff = PFN_DOWN(memaddr);\n\t\tvma->vm_ops = &vm_ops;\n\t\tret = 0;\n\t} else if (memdma) {\n\t\tret = dma_mmap_coherent(&dd->pcidev->dev, vma,\n\t\t\t\t\tmemvirt, memdma, memlen);\n\t} else if (mapio) {\n\t\tret = io_remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t\t PFN_DOWN(memaddr),\n\t\t\t\t\t memlen,\n\t\t\t\t\t vma->vm_page_prot);\n\t} else if (memvirt) {\n\t\tret = remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t      PFN_DOWN(__pa(memvirt)),\n\t\t\t\t      memlen,\n\t\t\t\t      vma->vm_page_prot);\n\t} else {\n\t\tret = remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t      PFN_DOWN(memaddr),\n\t\t\t\t      memlen,\n\t\t\t\t      vma->vm_page_prot);\n\t}\ndone:\n\treturn ret;\n}\n\n \nstatic vm_fault_t vma_fault(struct vm_fault *vmf)\n{\n\tstruct page *page;\n\n\tpage = vmalloc_to_page((void *)(vmf->pgoff << PAGE_SHIFT));\n\tif (!page)\n\t\treturn VM_FAULT_SIGBUS;\n\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}\n\nstatic __poll_t hfi1_poll(struct file *fp, struct poll_table_struct *pt)\n{\n\tstruct hfi1_ctxtdata *uctxt;\n\t__poll_t pollflag;\n\n\tuctxt = ((struct hfi1_filedata *)fp->private_data)->uctxt;\n\tif (!uctxt)\n\t\tpollflag = EPOLLERR;\n\telse if (uctxt->poll_type == HFI1_POLL_TYPE_URGENT)\n\t\tpollflag = poll_urgent(fp, pt);\n\telse  if (uctxt->poll_type == HFI1_POLL_TYPE_ANYRCV)\n\t\tpollflag = poll_next(fp, pt);\n\telse  \n\t\tpollflag = EPOLLERR;\n\n\treturn pollflag;\n}\n\nstatic int hfi1_file_close(struct inode *inode, struct file *fp)\n{\n\tstruct hfi1_filedata *fdata = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fdata->uctxt;\n\tstruct hfi1_devdata *dd = container_of(inode->i_cdev,\n\t\t\t\t\t       struct hfi1_devdata,\n\t\t\t\t\t       user_cdev);\n\tunsigned long flags, *ev;\n\n\tfp->private_data = NULL;\n\n\tif (!uctxt)\n\t\tgoto done;\n\n\thfi1_cdbg(PROC, \"closing ctxt %u:%u\", uctxt->ctxt, fdata->subctxt);\n\n\tflush_wc();\n\t \n\thfi1_user_sdma_free_queues(fdata, uctxt);\n\n\t \n\thfi1_put_proc_affinity(fdata->rec_cpu_num);\n\n\t \n\thfi1_user_exp_rcv_free(fdata);\n\n\t \n\tfdata->uctxt = NULL;\n\thfi1_rcd_put(uctxt);\n\n\t \n\tev = dd->events + uctxt_offset(uctxt) + fdata->subctxt;\n\t*ev = 0;\n\n\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\t__clear_bit(fdata->subctxt, uctxt->in_use_ctxts);\n\tif (!bitmap_empty(uctxt->in_use_ctxts, HFI1_MAX_SHARED_CTXTS)) {\n\t\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\t\tgoto done;\n\t}\n\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\n\t \n\thfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_DIS |\n\t\t     HFI1_RCVCTRL_TIDFLOW_DIS |\n\t\t     HFI1_RCVCTRL_INTRAVAIL_DIS |\n\t\t     HFI1_RCVCTRL_TAILUPD_DIS |\n\t\t     HFI1_RCVCTRL_ONE_PKT_EGR_DIS |\n\t\t     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |\n\t\t     HFI1_RCVCTRL_NO_EGR_DROP_DIS |\n\t\t     HFI1_RCVCTRL_URGENT_DIS, uctxt);\n\t \n\thfi1_clear_ctxt_jkey(dd, uctxt);\n\t \n\tif (uctxt->sc) {\n\t\tsc_disable(uctxt->sc);\n\t\tset_pio_integrity(uctxt->sc);\n\t}\n\n\thfi1_free_ctxt_rcv_groups(uctxt);\n\thfi1_clear_ctxt_pkey(dd, uctxt);\n\n\tuctxt->event_flags = 0;\n\n\tdeallocate_ctxt(uctxt);\ndone:\n\n\tif (refcount_dec_and_test(&dd->user_refcount))\n\t\tcomplete(&dd->user_comp);\n\n\tcleanup_srcu_struct(&fdata->pq_srcu);\n\tkfree(fdata);\n\treturn 0;\n}\n\n \nstatic u64 kvirt_to_phys(void *addr)\n{\n\tstruct page *page;\n\tu64 paddr = 0;\n\n\tpage = vmalloc_to_page(addr);\n\tif (page)\n\t\tpaddr = page_to_pfn(page) << PAGE_SHIFT;\n\n\treturn paddr;\n}\n\n \nstatic int complete_subctxt(struct hfi1_filedata *fd)\n{\n\tint ret;\n\tunsigned long flags;\n\n\t \n\tret = wait_event_interruptible(\n\t\tfd->uctxt->wait,\n\t\t!test_bit(HFI1_CTXT_BASE_UNINIT, &fd->uctxt->event_flags));\n\n\tif (test_bit(HFI1_CTXT_BASE_FAILED, &fd->uctxt->event_flags))\n\t\tret = -ENOMEM;\n\n\t \n\tif (!ret) {\n\t\tfd->rec_cpu_num = hfi1_get_proc_affinity(fd->uctxt->numa_id);\n\t\tret = init_user_ctxt(fd, fd->uctxt);\n\t}\n\n\tif (ret) {\n\t\tspin_lock_irqsave(&fd->dd->uctxt_lock, flags);\n\t\t__clear_bit(fd->subctxt, fd->uctxt->in_use_ctxts);\n\t\tspin_unlock_irqrestore(&fd->dd->uctxt_lock, flags);\n\t\thfi1_rcd_put(fd->uctxt);\n\t\tfd->uctxt = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int assign_ctxt(struct hfi1_filedata *fd, unsigned long arg, u32 len)\n{\n\tint ret;\n\tunsigned int swmajor;\n\tstruct hfi1_ctxtdata *uctxt = NULL;\n\tstruct hfi1_user_info uinfo;\n\n\tif (fd->uctxt)\n\t\treturn -EINVAL;\n\n\tif (sizeof(uinfo) != len)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&uinfo, (void __user *)arg, sizeof(uinfo)))\n\t\treturn -EFAULT;\n\n\tswmajor = uinfo.userversion >> 16;\n\tif (swmajor != HFI1_USER_SWMAJOR)\n\t\treturn -ENODEV;\n\n\tif (uinfo.subctxt_cnt > HFI1_MAX_SHARED_CTXTS)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&hfi1_mutex);\n\t \n\tret = find_sub_ctxt(fd, &uinfo);\n\n\t \n\tif (!ret)\n\t\tret = allocate_ctxt(fd, fd->dd, &uinfo, &uctxt);\n\n\tmutex_unlock(&hfi1_mutex);\n\n\t \n\tswitch (ret) {\n\tcase 0:\n\t\tret = setup_base_ctxt(fd, uctxt);\n\t\tif (ret)\n\t\t\tdeallocate_ctxt(uctxt);\n\t\tbreak;\n\tcase 1:\n\t\tret = complete_subctxt(fd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int match_ctxt(struct hfi1_filedata *fd,\n\t\t      const struct hfi1_user_info *uinfo,\n\t\t      struct hfi1_ctxtdata *uctxt)\n{\n\tstruct hfi1_devdata *dd = fd->dd;\n\tunsigned long flags;\n\tu16 subctxt;\n\n\t \n\tif (uctxt->sc && (uctxt->sc->type == SC_KERNEL))\n\t\treturn 0;\n\n\t \n\tif (memcmp(uctxt->uuid, uinfo->uuid, sizeof(uctxt->uuid)) ||\n\t    uctxt->jkey != generate_jkey(current_uid()) ||\n\t    uctxt->subctxt_id != uinfo->subctxt_id ||\n\t    uctxt->subctxt_cnt != uinfo->subctxt_cnt)\n\t\treturn 0;\n\n\t \n\tif (uctxt->userversion != uinfo->userversion)\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\tif (bitmap_empty(uctxt->in_use_ctxts, HFI1_MAX_SHARED_CTXTS)) {\n\t\t \n\t\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\t\treturn 0;\n\t}\n\n\tsubctxt = find_first_zero_bit(uctxt->in_use_ctxts,\n\t\t\t\t      HFI1_MAX_SHARED_CTXTS);\n\tif (subctxt >= uctxt->subctxt_cnt) {\n\t\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tfd->subctxt = subctxt;\n\t__set_bit(fd->subctxt, uctxt->in_use_ctxts);\n\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\n\tfd->uctxt = uctxt;\n\thfi1_rcd_get(uctxt);\n\n\treturn 1;\n}\n\n \nstatic int find_sub_ctxt(struct hfi1_filedata *fd,\n\t\t\t const struct hfi1_user_info *uinfo)\n{\n\tstruct hfi1_ctxtdata *uctxt;\n\tstruct hfi1_devdata *dd = fd->dd;\n\tu16 i;\n\tint ret;\n\n\tif (!uinfo->subctxt_cnt)\n\t\treturn 0;\n\n\tfor (i = dd->first_dyn_alloc_ctxt; i < dd->num_rcv_contexts; i++) {\n\t\tuctxt = hfi1_rcd_get_by_index(dd, i);\n\t\tif (uctxt) {\n\t\t\tret = match_ctxt(fd, uinfo, uctxt);\n\t\t\thfi1_rcd_put(uctxt);\n\t\t\t \n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int allocate_ctxt(struct hfi1_filedata *fd, struct hfi1_devdata *dd,\n\t\t\t struct hfi1_user_info *uinfo,\n\t\t\t struct hfi1_ctxtdata **rcd)\n{\n\tstruct hfi1_ctxtdata *uctxt;\n\tint ret, numa;\n\n\tif (dd->flags & HFI1_FROZEN) {\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tif (!dd->freectxts)\n\t\treturn -EBUSY;\n\n\t \n\tfd->rec_cpu_num = hfi1_get_proc_affinity(dd->node);\n\tif (fd->rec_cpu_num != -1)\n\t\tnuma = cpu_to_node(fd->rec_cpu_num);\n\telse\n\t\tnuma = numa_node_id();\n\tret = hfi1_create_ctxtdata(dd->pport, numa, &uctxt);\n\tif (ret < 0) {\n\t\tdd_dev_err(dd, \"user ctxtdata allocation failed\\n\");\n\t\treturn ret;\n\t}\n\thfi1_cdbg(PROC, \"[%u:%u] pid %u assigned to CPU %d (NUMA %u)\",\n\t\t  uctxt->ctxt, fd->subctxt, current->pid, fd->rec_cpu_num,\n\t\t  uctxt->numa_id);\n\n\t \n\tuctxt->sc = sc_alloc(dd, SC_USER, uctxt->rcvhdrqentsize, dd->node);\n\tif (!uctxt->sc) {\n\t\tret = -ENOMEM;\n\t\tgoto ctxdata_free;\n\t}\n\thfi1_cdbg(PROC, \"allocated send context %u(%u)\", uctxt->sc->sw_index,\n\t\t  uctxt->sc->hw_context);\n\tret = sc_enable(uctxt->sc);\n\tif (ret)\n\t\tgoto ctxdata_free;\n\n\t \n\t__set_bit(0, uctxt->in_use_ctxts);\n\tif (uinfo->subctxt_cnt)\n\t\tinit_subctxts(uctxt, uinfo);\n\tuctxt->userversion = uinfo->userversion;\n\tuctxt->flags = hfi1_cap_mask;  \n\tinit_waitqueue_head(&uctxt->wait);\n\tstrscpy(uctxt->comm, current->comm, sizeof(uctxt->comm));\n\tmemcpy(uctxt->uuid, uinfo->uuid, sizeof(uctxt->uuid));\n\tuctxt->jkey = generate_jkey(current_uid());\n\thfi1_stats.sps_ctxts++;\n\t \n\tif (dd->freectxts-- == dd->num_user_contexts)\n\t\taspm_disable_all(dd);\n\n\t*rcd = uctxt;\n\n\treturn 0;\n\nctxdata_free:\n\thfi1_free_ctxt(uctxt);\n\treturn ret;\n}\n\nstatic void deallocate_ctxt(struct hfi1_ctxtdata *uctxt)\n{\n\tmutex_lock(&hfi1_mutex);\n\thfi1_stats.sps_ctxts--;\n\tif (++uctxt->dd->freectxts == uctxt->dd->num_user_contexts)\n\t\taspm_enable_all(uctxt->dd);\n\tmutex_unlock(&hfi1_mutex);\n\n\thfi1_free_ctxt(uctxt);\n}\n\nstatic void init_subctxts(struct hfi1_ctxtdata *uctxt,\n\t\t\t  const struct hfi1_user_info *uinfo)\n{\n\tuctxt->subctxt_cnt = uinfo->subctxt_cnt;\n\tuctxt->subctxt_id = uinfo->subctxt_id;\n\tset_bit(HFI1_CTXT_BASE_UNINIT, &uctxt->event_flags);\n}\n\nstatic int setup_subctxt(struct hfi1_ctxtdata *uctxt)\n{\n\tint ret = 0;\n\tu16 num_subctxts = uctxt->subctxt_cnt;\n\n\tuctxt->subctxt_uregbase = vmalloc_user(PAGE_SIZE);\n\tif (!uctxt->subctxt_uregbase)\n\t\treturn -ENOMEM;\n\n\t \n\tuctxt->subctxt_rcvhdr_base = vmalloc_user(rcvhdrq_size(uctxt) *\n\t\t\t\t\t\t  num_subctxts);\n\tif (!uctxt->subctxt_rcvhdr_base) {\n\t\tret = -ENOMEM;\n\t\tgoto bail_ureg;\n\t}\n\n\tuctxt->subctxt_rcvegrbuf = vmalloc_user(uctxt->egrbufs.size *\n\t\t\t\t\t\tnum_subctxts);\n\tif (!uctxt->subctxt_rcvegrbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto bail_rhdr;\n\t}\n\n\treturn 0;\n\nbail_rhdr:\n\tvfree(uctxt->subctxt_rcvhdr_base);\n\tuctxt->subctxt_rcvhdr_base = NULL;\nbail_ureg:\n\tvfree(uctxt->subctxt_uregbase);\n\tuctxt->subctxt_uregbase = NULL;\n\n\treturn ret;\n}\n\nstatic void user_init(struct hfi1_ctxtdata *uctxt)\n{\n\tunsigned int rcvctrl_ops = 0;\n\n\t \n\tuctxt->urgent = 0;\n\tuctxt->urgent_poll = 0;\n\n\t \n\tif (hfi1_rcvhdrtail_kvaddr(uctxt))\n\t\tclear_rcvhdrtail(uctxt);\n\n\t \n\thfi1_set_ctxt_jkey(uctxt->dd, uctxt, uctxt->jkey);\n\n\trcvctrl_ops = HFI1_RCVCTRL_CTXT_ENB;\n\trcvctrl_ops |= HFI1_RCVCTRL_URGENT_ENB;\n\tif (HFI1_CAP_UGET_MASK(uctxt->flags, HDRSUPP))\n\t\trcvctrl_ops |= HFI1_RCVCTRL_TIDFLOW_ENB;\n\t \n\tif (!HFI1_CAP_UGET_MASK(uctxt->flags, MULTI_PKT_EGR))\n\t\trcvctrl_ops |= HFI1_RCVCTRL_ONE_PKT_EGR_ENB;\n\tif (HFI1_CAP_UGET_MASK(uctxt->flags, NODROP_EGR_FULL))\n\t\trcvctrl_ops |= HFI1_RCVCTRL_NO_EGR_DROP_ENB;\n\tif (HFI1_CAP_UGET_MASK(uctxt->flags, NODROP_RHQ_FULL))\n\t\trcvctrl_ops |= HFI1_RCVCTRL_NO_RHQ_DROP_ENB;\n\t \n\tif (HFI1_CAP_UGET_MASK(uctxt->flags, DMA_RTAIL))\n\t\trcvctrl_ops |= HFI1_RCVCTRL_TAILUPD_ENB;\n\telse\n\t\trcvctrl_ops |= HFI1_RCVCTRL_TAILUPD_DIS;\n\thfi1_rcvctrl(uctxt->dd, rcvctrl_ops, uctxt);\n}\n\nstatic int get_ctxt_info(struct hfi1_filedata *fd, unsigned long arg, u32 len)\n{\n\tstruct hfi1_ctxt_info cinfo;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\n\tif (sizeof(cinfo) != len)\n\t\treturn -EINVAL;\n\n\tmemset(&cinfo, 0, sizeof(cinfo));\n\tcinfo.runtime_flags = (((uctxt->flags >> HFI1_CAP_MISC_SHIFT) &\n\t\t\t\tHFI1_CAP_MISC_MASK) << HFI1_CAP_USER_SHIFT) |\n\t\t\tHFI1_CAP_UGET_MASK(uctxt->flags, MASK) |\n\t\t\tHFI1_CAP_KGET_MASK(uctxt->flags, K2U);\n\t \n\tif (!fd->use_mn)\n\t\tcinfo.runtime_flags |= HFI1_CAP_TID_UNMAP;  \n\n\tcinfo.num_active = hfi1_count_active_units();\n\tcinfo.unit = uctxt->dd->unit;\n\tcinfo.ctxt = uctxt->ctxt;\n\tcinfo.subctxt = fd->subctxt;\n\tcinfo.rcvtids = roundup(uctxt->egrbufs.alloced,\n\t\t\t\tuctxt->dd->rcv_entries.group_size) +\n\t\tuctxt->expected_count;\n\tcinfo.credits = uctxt->sc->credits;\n\tcinfo.numa_node = uctxt->numa_id;\n\tcinfo.rec_cpu = fd->rec_cpu_num;\n\tcinfo.send_ctxt = uctxt->sc->hw_context;\n\n\tcinfo.egrtids = uctxt->egrbufs.alloced;\n\tcinfo.rcvhdrq_cnt = get_hdrq_cnt(uctxt);\n\tcinfo.rcvhdrq_entsize = get_hdrqentsize(uctxt) << 2;\n\tcinfo.sdma_ring_size = fd->cq->nentries;\n\tcinfo.rcvegr_size = uctxt->egrbufs.rcvtid_size;\n\n\ttrace_hfi1_ctxt_info(uctxt->dd, uctxt->ctxt, fd->subctxt, &cinfo);\n\tif (copy_to_user((void __user *)arg, &cinfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int init_user_ctxt(struct hfi1_filedata *fd,\n\t\t\t  struct hfi1_ctxtdata *uctxt)\n{\n\tint ret;\n\n\tret = hfi1_user_sdma_alloc_queues(uctxt, fd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hfi1_user_exp_rcv_init(fd, uctxt);\n\tif (ret)\n\t\thfi1_user_sdma_free_queues(fd, uctxt);\n\n\treturn ret;\n}\n\nstatic int setup_base_ctxt(struct hfi1_filedata *fd,\n\t\t\t   struct hfi1_ctxtdata *uctxt)\n{\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tint ret = 0;\n\n\thfi1_init_ctxt(uctxt->sc);\n\n\t \n\tret = hfi1_create_rcvhdrq(dd, uctxt);\n\tif (ret)\n\t\tgoto done;\n\n\tret = hfi1_setup_eagerbufs(uctxt);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tif (uctxt->subctxt_cnt)\n\t\tret = setup_subctxt(uctxt);\n\tif (ret)\n\t\tgoto done;\n\n\tret = hfi1_alloc_ctxt_rcv_groups(uctxt);\n\tif (ret)\n\t\tgoto done;\n\n\tret = init_user_ctxt(fd, uctxt);\n\tif (ret) {\n\t\thfi1_free_ctxt_rcv_groups(uctxt);\n\t\tgoto done;\n\t}\n\n\tuser_init(uctxt);\n\n\t \n\tfd->uctxt = uctxt;\n\thfi1_rcd_get(uctxt);\n\ndone:\n\tif (uctxt->subctxt_cnt) {\n\t\t \n\t\tif (ret)\n\t\t\tset_bit(HFI1_CTXT_BASE_FAILED, &uctxt->event_flags);\n\n\t\t \n\t\tclear_bit(HFI1_CTXT_BASE_UNINIT, &uctxt->event_flags);\n\t\twake_up(&uctxt->wait);\n\t}\n\n\treturn ret;\n}\n\nstatic int get_base_info(struct hfi1_filedata *fd, unsigned long arg, u32 len)\n{\n\tstruct hfi1_base_info binfo;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tunsigned offset;\n\n\ttrace_hfi1_uctxtdata(uctxt->dd, uctxt, fd->subctxt);\n\n\tif (sizeof(binfo) != len)\n\t\treturn -EINVAL;\n\n\tmemset(&binfo, 0, sizeof(binfo));\n\tbinfo.hw_version = dd->revision;\n\tbinfo.sw_version = HFI1_USER_SWVERSION;\n\tbinfo.bthqp = RVT_KDETH_QP_PREFIX;\n\tbinfo.jkey = uctxt->jkey;\n\t \n\toffset = ((u64)uctxt->sc->hw_free -\n\t\t  (u64)dd->cr_base[uctxt->numa_id].va) % PAGE_SIZE;\n\tbinfo.sc_credits_addr = HFI1_MMAP_TOKEN(PIO_CRED, uctxt->ctxt,\n\t\t\t\t\t\tfd->subctxt, offset);\n\tbinfo.pio_bufbase = HFI1_MMAP_TOKEN(PIO_BUFS, uctxt->ctxt,\n\t\t\t\t\t    fd->subctxt,\n\t\t\t\t\t    uctxt->sc->base_addr);\n\tbinfo.pio_bufbase_sop = HFI1_MMAP_TOKEN(PIO_BUFS_SOP,\n\t\t\t\t\t\tuctxt->ctxt,\n\t\t\t\t\t\tfd->subctxt,\n\t\t\t\t\t\tuctxt->sc->base_addr);\n\tbinfo.rcvhdr_bufbase = HFI1_MMAP_TOKEN(RCV_HDRQ, uctxt->ctxt,\n\t\t\t\t\t       fd->subctxt,\n\t\t\t\t\t       uctxt->rcvhdrq);\n\tbinfo.rcvegr_bufbase = HFI1_MMAP_TOKEN(RCV_EGRBUF, uctxt->ctxt,\n\t\t\t\t\t       fd->subctxt,\n\t\t\t\t\t       uctxt->egrbufs.rcvtids[0].dma);\n\tbinfo.sdma_comp_bufbase = HFI1_MMAP_TOKEN(SDMA_COMP, uctxt->ctxt,\n\t\t\t\t\t\t  fd->subctxt, 0);\n\t \n\tbinfo.user_regbase = HFI1_MMAP_TOKEN(UREGS, uctxt->ctxt,\n\t\t\t\t\t     fd->subctxt, 0);\n\toffset = offset_in_page((uctxt_offset(uctxt) + fd->subctxt) *\n\t\t\t\tsizeof(*dd->events));\n\tbinfo.events_bufbase = HFI1_MMAP_TOKEN(EVENTS, uctxt->ctxt,\n\t\t\t\t\t       fd->subctxt,\n\t\t\t\t\t       offset);\n\tbinfo.status_bufbase = HFI1_MMAP_TOKEN(STATUS, uctxt->ctxt,\n\t\t\t\t\t       fd->subctxt,\n\t\t\t\t\t       dd->status);\n\tif (HFI1_CAP_IS_USET(DMA_RTAIL))\n\t\tbinfo.rcvhdrtail_base = HFI1_MMAP_TOKEN(RTAIL, uctxt->ctxt,\n\t\t\t\t\t\t\tfd->subctxt, 0);\n\tif (uctxt->subctxt_cnt) {\n\t\tbinfo.subctxt_uregbase = HFI1_MMAP_TOKEN(SUBCTXT_UREGS,\n\t\t\t\t\t\t\t uctxt->ctxt,\n\t\t\t\t\t\t\t fd->subctxt, 0);\n\t\tbinfo.subctxt_rcvhdrbuf = HFI1_MMAP_TOKEN(SUBCTXT_RCV_HDRQ,\n\t\t\t\t\t\t\t  uctxt->ctxt,\n\t\t\t\t\t\t\t  fd->subctxt, 0);\n\t\tbinfo.subctxt_rcvegrbuf = HFI1_MMAP_TOKEN(SUBCTXT_EGRBUF,\n\t\t\t\t\t\t\t  uctxt->ctxt,\n\t\t\t\t\t\t\t  fd->subctxt, 0);\n\t}\n\n\tif (copy_to_user((void __user *)arg, &binfo, len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\n \nstatic int user_exp_rcv_setup(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t      u32 len)\n{\n\tint ret;\n\tunsigned long addr;\n\tstruct hfi1_tid_info tinfo;\n\n\tif (sizeof(tinfo) != len)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tinfo, (void __user *)arg, (sizeof(tinfo))))\n\t\treturn -EFAULT;\n\n\tret = hfi1_user_exp_rcv_setup(fd, &tinfo);\n\tif (!ret) {\n\t\t \n\t\taddr = arg + offsetof(struct hfi1_tid_info, tidcnt);\n\t\tif (copy_to_user((void __user *)addr, &tinfo.tidcnt,\n\t\t\t\t sizeof(tinfo.tidcnt)))\n\t\t\tret = -EFAULT;\n\n\t\taddr = arg + offsetof(struct hfi1_tid_info, length);\n\t\tif (!ret && copy_to_user((void __user *)addr, &tinfo.length,\n\t\t\t\t sizeof(tinfo.length)))\n\t\t\tret = -EFAULT;\n\n\t\tif (ret)\n\t\t\thfi1_user_exp_rcv_invalid(fd, &tinfo);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int user_exp_rcv_clear(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t      u32 len)\n{\n\tint ret;\n\tunsigned long addr;\n\tstruct hfi1_tid_info tinfo;\n\n\tif (sizeof(tinfo) != len)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tinfo, (void __user *)arg, (sizeof(tinfo))))\n\t\treturn -EFAULT;\n\n\tret = hfi1_user_exp_rcv_clear(fd, &tinfo);\n\tif (!ret) {\n\t\taddr = arg + offsetof(struct hfi1_tid_info, tidcnt);\n\t\tif (copy_to_user((void __user *)addr, &tinfo.tidcnt,\n\t\t\t\t sizeof(tinfo.tidcnt)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int user_exp_rcv_invalid(struct hfi1_filedata *fd, unsigned long arg,\n\t\t\t\tu32 len)\n{\n\tint ret;\n\tunsigned long addr;\n\tstruct hfi1_tid_info tinfo;\n\n\tif (sizeof(tinfo) != len)\n\t\treturn -EINVAL;\n\n\tif (!fd->invalid_tids)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&tinfo, (void __user *)arg, (sizeof(tinfo))))\n\t\treturn -EFAULT;\n\n\tret = hfi1_user_exp_rcv_invalid(fd, &tinfo);\n\tif (ret)\n\t\treturn ret;\n\n\taddr = arg + offsetof(struct hfi1_tid_info, tidcnt);\n\tif (copy_to_user((void __user *)addr, &tinfo.tidcnt,\n\t\t\t sizeof(tinfo.tidcnt)))\n\t\tret = -EFAULT;\n\n\treturn ret;\n}\n\nstatic __poll_t poll_urgent(struct file *fp,\n\t\t\t\tstruct poll_table_struct *pt)\n{\n\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\t__poll_t pollflag;\n\n\tpoll_wait(fp, &uctxt->wait, pt);\n\n\tspin_lock_irq(&dd->uctxt_lock);\n\tif (uctxt->urgent != uctxt->urgent_poll) {\n\t\tpollflag = EPOLLIN | EPOLLRDNORM;\n\t\tuctxt->urgent_poll = uctxt->urgent;\n\t} else {\n\t\tpollflag = 0;\n\t\tset_bit(HFI1_CTXT_WAITING_URG, &uctxt->event_flags);\n\t}\n\tspin_unlock_irq(&dd->uctxt_lock);\n\n\treturn pollflag;\n}\n\nstatic __poll_t poll_next(struct file *fp,\n\t\t\t      struct poll_table_struct *pt)\n{\n\tstruct hfi1_filedata *fd = fp->private_data;\n\tstruct hfi1_ctxtdata *uctxt = fd->uctxt;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\t__poll_t pollflag;\n\n\tpoll_wait(fp, &uctxt->wait, pt);\n\n\tspin_lock_irq(&dd->uctxt_lock);\n\tif (hdrqempty(uctxt)) {\n\t\tset_bit(HFI1_CTXT_WAITING_RCV, &uctxt->event_flags);\n\t\thfi1_rcvctrl(dd, HFI1_RCVCTRL_INTRAVAIL_ENB, uctxt);\n\t\tpollflag = 0;\n\t} else {\n\t\tpollflag = EPOLLIN | EPOLLRDNORM;\n\t}\n\tspin_unlock_irq(&dd->uctxt_lock);\n\n\treturn pollflag;\n}\n\n \nint hfi1_set_uevent_bits(struct hfi1_pportdata *ppd, const int evtbit)\n{\n\tstruct hfi1_ctxtdata *uctxt;\n\tstruct hfi1_devdata *dd = ppd->dd;\n\tu16 ctxt;\n\n\tif (!dd->events)\n\t\treturn -EINVAL;\n\n\tfor (ctxt = dd->first_dyn_alloc_ctxt; ctxt < dd->num_rcv_contexts;\n\t     ctxt++) {\n\t\tuctxt = hfi1_rcd_get_by_index(dd, ctxt);\n\t\tif (uctxt) {\n\t\t\tunsigned long *evs;\n\t\t\tint i;\n\t\t\t \n\t\t\tevs = dd->events + uctxt_offset(uctxt);\n\t\t\tset_bit(evtbit, evs);\n\t\t\tfor (i = 1; i < uctxt->subctxt_cnt; i++)\n\t\t\t\tset_bit(evtbit, evs + i);\n\t\t\thfi1_rcd_put(uctxt);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int manage_rcvq(struct hfi1_ctxtdata *uctxt, u16 subctxt,\n\t\t       unsigned long arg)\n{\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tunsigned int rcvctrl_op;\n\tint start_stop;\n\n\tif (subctxt)\n\t\treturn 0;\n\n\tif (get_user(start_stop, (int __user *)arg))\n\t\treturn -EFAULT;\n\n\t \n\tif (start_stop) {\n\t\t \n\t\tif (hfi1_rcvhdrtail_kvaddr(uctxt))\n\t\t\tclear_rcvhdrtail(uctxt);\n\t\trcvctrl_op = HFI1_RCVCTRL_CTXT_ENB;\n\t} else {\n\t\trcvctrl_op = HFI1_RCVCTRL_CTXT_DIS;\n\t}\n\thfi1_rcvctrl(dd, rcvctrl_op, uctxt);\n\t \n\n\treturn 0;\n}\n\n \nstatic int user_event_ack(struct hfi1_ctxtdata *uctxt, u16 subctxt,\n\t\t\t  unsigned long arg)\n{\n\tint i;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tunsigned long *evs;\n\tunsigned long events;\n\n\tif (!dd->events)\n\t\treturn 0;\n\n\tif (get_user(events, (unsigned long __user *)arg))\n\t\treturn -EFAULT;\n\n\tevs = dd->events + uctxt_offset(uctxt) + subctxt;\n\n\tfor (i = 0; i <= _HFI1_MAX_EVENT_BIT; i++) {\n\t\tif (!test_bit(i, &events))\n\t\t\tcontinue;\n\t\tclear_bit(i, evs);\n\t}\n\treturn 0;\n}\n\nstatic int set_ctxt_pkey(struct hfi1_ctxtdata *uctxt, unsigned long arg)\n{\n\tint i;\n\tstruct hfi1_pportdata *ppd = uctxt->ppd;\n\tstruct hfi1_devdata *dd = uctxt->dd;\n\tu16 pkey;\n\n\tif (!HFI1_CAP_IS_USET(PKEY_CHECK))\n\t\treturn -EPERM;\n\n\tif (get_user(pkey, (u16 __user *)arg))\n\t\treturn -EFAULT;\n\n\tif (pkey == LIM_MGMT_P_KEY || pkey == FULL_MGMT_P_KEY)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++)\n\t\tif (pkey == ppd->pkeys[i])\n\t\t\treturn hfi1_set_ctxt_pkey(dd, uctxt, pkey);\n\n\treturn -ENOENT;\n}\n\n \nstatic int ctxt_reset(struct hfi1_ctxtdata *uctxt)\n{\n\tstruct send_context *sc;\n\tstruct hfi1_devdata *dd;\n\tint ret = 0;\n\n\tif (!uctxt || !uctxt->dd || !uctxt->sc)\n\t\treturn -EINVAL;\n\n\t \n\tdd = uctxt->dd;\n\tsc = uctxt->sc;\n\n\t \n\twait_event_interruptible_timeout(\n\t\tsc->halt_wait, (sc->flags & SCF_HALTED),\n\t\tmsecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT));\n\tif (!(sc->flags & SCF_HALTED))\n\t\treturn -ENOLCK;\n\n\t \n\tif (sc->flags & SCF_FROZEN) {\n\t\twait_event_interruptible_timeout(\n\t\t\tdd->event_queue,\n\t\t\t!(READ_ONCE(dd->flags) & HFI1_FROZEN),\n\t\t\tmsecs_to_jiffies(SEND_CTXT_HALT_TIMEOUT));\n\t\tif (dd->flags & HFI1_FROZEN)\n\t\t\treturn -ENOLCK;\n\n\t\tif (dd->flags & HFI1_FORCED_FREEZE)\n\t\t\t \n\t\t\treturn -ENODEV;\n\n\t\tsc_disable(sc);\n\t\tret = sc_enable(sc);\n\t\thfi1_rcvctrl(dd, HFI1_RCVCTRL_CTXT_ENB, uctxt);\n\t} else {\n\t\tret = sc_restart(sc);\n\t}\n\tif (!ret)\n\t\tsc_return_credits(sc);\n\n\treturn ret;\n}\n\nstatic void user_remove(struct hfi1_devdata *dd)\n{\n\n\thfi1_cdev_cleanup(&dd->user_cdev, &dd->user_device);\n}\n\nstatic int user_add(struct hfi1_devdata *dd)\n{\n\tchar name[10];\n\tint ret;\n\n\tsnprintf(name, sizeof(name), \"%s_%d\", class_name(), dd->unit);\n\tret = hfi1_cdev_init(dd->unit, name, &hfi1_file_ops,\n\t\t\t     &dd->user_cdev, &dd->user_device,\n\t\t\t     true, &dd->verbs_dev.rdi.ibdev.dev.kobj);\n\tif (ret)\n\t\tuser_remove(dd);\n\n\treturn ret;\n}\n\n \nint hfi1_device_create(struct hfi1_devdata *dd)\n{\n\treturn user_add(dd);\n}\n\n \nvoid hfi1_device_remove(struct hfi1_devdata *dd)\n{\n\tuser_remove(dd);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}