{
  "module_name": "opfn.c",
  "hash_id": "17b8d39cb4d548290dd9ffab9076a1e326b0fc655d5c6f6d49da325680a26123",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/opfn.c",
  "human_readable_source": "\n \n#include \"hfi.h\"\n#include \"trace.h\"\n#include \"qp.h\"\n#include \"opfn.h\"\n\n#define IB_BTHE_E                 BIT(IB_BTHE_E_SHIFT)\n\n#define OPFN_CODE(code) BIT((code) - 1)\n#define OPFN_MASK(code) OPFN_CODE(STL_VERBS_EXTD_##code)\n\nstruct hfi1_opfn_type {\n\tbool (*request)(struct rvt_qp *qp, u64 *data);\n\tbool (*response)(struct rvt_qp *qp, u64 *data);\n\tbool (*reply)(struct rvt_qp *qp, u64 data);\n\tvoid (*error)(struct rvt_qp *qp);\n};\n\nstatic struct hfi1_opfn_type hfi1_opfn_handlers[STL_VERBS_EXTD_MAX] = {\n\t[STL_VERBS_EXTD_TID_RDMA] = {\n\t\t.request = tid_rdma_conn_req,\n\t\t.response = tid_rdma_conn_resp,\n\t\t.reply = tid_rdma_conn_reply,\n\t\t.error = tid_rdma_conn_error,\n\t},\n};\n\nstatic struct workqueue_struct *opfn_wq;\n\nstatic void opfn_schedule_conn_request(struct rvt_qp *qp);\n\nstatic bool hfi1_opfn_extended(u32 bth1)\n{\n\treturn !!(bth1 & IB_BTHE_E);\n}\n\nstatic void opfn_conn_request(struct rvt_qp *qp)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct ib_atomic_wr wr;\n\tu16 mask, capcode;\n\tstruct hfi1_opfn_type *extd;\n\tu64 data;\n\tunsigned long flags;\n\tint ret = 0;\n\n\ttrace_hfi1_opfn_state_conn_request(qp);\n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\t \n\tif (!priv->opfn.extended || !priv->opfn.requested ||\n\t    priv->opfn.requested == priv->opfn.completed || priv->opfn.curr)\n\t\tgoto done;\n\n\tmask = priv->opfn.requested & ~priv->opfn.completed;\n\tcapcode = ilog2(mask & ~(mask - 1)) + 1;\n\tif (capcode >= STL_VERBS_EXTD_MAX) {\n\t\tpriv->opfn.completed |= OPFN_CODE(capcode);\n\t\tgoto done;\n\t}\n\n\textd = &hfi1_opfn_handlers[capcode];\n\tif (!extd || !extd->request || !extd->request(qp, &data)) {\n\t\t \n\t\tpriv->opfn.completed |= OPFN_CODE(capcode);\n\t\tgoto done;\n\t}\n\n\ttrace_hfi1_opfn_data_conn_request(qp, capcode, data);\n\tdata = (data & ~0xf) | capcode;\n\n\tmemset(&wr, 0, sizeof(wr));\n\twr.wr.opcode = IB_WR_OPFN;\n\twr.remote_addr = HFI1_VERBS_E_ATOMIC_VADDR;\n\twr.compare_add = data;\n\n\tpriv->opfn.curr = capcode;\t \n\t \n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n\n\tret = ib_post_send(&qp->ibqp, &wr.wr, NULL);\n\tif (ret)\n\t\tgoto err;\n\ttrace_hfi1_opfn_state_conn_request(qp);\n\treturn;\nerr:\n\ttrace_hfi1_msg_opfn_conn_request(qp, \"ib_ost_send failed: ret = \",\n\t\t\t\t\t (u64)ret);\n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\t \n\tpriv->opfn.curr = STL_VERBS_EXTD_NONE;\n\topfn_schedule_conn_request(qp);\ndone:\n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n}\n\nvoid opfn_send_conn_request(struct work_struct *work)\n{\n\tstruct hfi1_opfn_data *od;\n\tstruct hfi1_qp_priv *qpriv;\n\n\tod = container_of(work, struct hfi1_opfn_data, opfn_work);\n\tqpriv = container_of(od, struct hfi1_qp_priv, opfn);\n\n\topfn_conn_request(qpriv->owner);\n}\n\n \nstatic void opfn_schedule_conn_request(struct rvt_qp *qp)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\ttrace_hfi1_opfn_state_sched_conn_request(qp);\n\tqueue_work(opfn_wq, &priv->opfn.opfn_work);\n}\n\nvoid opfn_conn_response(struct rvt_qp *qp, struct rvt_ack_entry *e,\n\t\t\tstruct ib_atomic_eth *ateth)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tu64 data = be64_to_cpu(ateth->compare_data);\n\tstruct hfi1_opfn_type *extd;\n\tu8 capcode;\n\tunsigned long flags;\n\n\ttrace_hfi1_opfn_state_conn_response(qp);\n\tcapcode = data & 0xf;\n\ttrace_hfi1_opfn_data_conn_response(qp, capcode, data);\n\tif (!capcode || capcode >= STL_VERBS_EXTD_MAX)\n\t\treturn;\n\n\textd = &hfi1_opfn_handlers[capcode];\n\n\tif (!extd || !extd->response) {\n\t\te->atomic_data = capcode;\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\tif (priv->opfn.completed & OPFN_CODE(capcode)) {\n\t\t \n\t\tpriv->opfn.completed &= ~OPFN_CODE(capcode);\n\t\tif (extd->error)\n\t\t\textd->error(qp);\n\t}\n\n\tif (extd->response(qp, &data))\n\t\tpriv->opfn.completed |= OPFN_CODE(capcode);\n\te->atomic_data = (data & ~0xf) | capcode;\n\ttrace_hfi1_opfn_state_conn_response(qp);\n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n}\n\nvoid opfn_conn_reply(struct rvt_qp *qp, u64 data)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_opfn_type *extd;\n\tu8 capcode;\n\tunsigned long flags;\n\n\ttrace_hfi1_opfn_state_conn_reply(qp);\n\tcapcode = data & 0xf;\n\ttrace_hfi1_opfn_data_conn_reply(qp, capcode, data);\n\tif (!capcode || capcode >= STL_VERBS_EXTD_MAX)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\t \n\tif (!priv->opfn.curr || capcode != priv->opfn.curr)\n\t\tgoto done;\n\n\textd = &hfi1_opfn_handlers[capcode];\n\n\tif (!extd || !extd->reply)\n\t\tgoto clear;\n\n\tif (extd->reply(qp, data))\n\t\tpriv->opfn.completed |= OPFN_CODE(capcode);\nclear:\n\t \n\tpriv->opfn.curr = STL_VERBS_EXTD_NONE;\n\ttrace_hfi1_opfn_state_conn_reply(qp);\ndone:\n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n}\n\nvoid opfn_conn_error(struct rvt_qp *qp)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_opfn_type *extd = NULL;\n\tunsigned long flags;\n\tu16 capcode;\n\n\ttrace_hfi1_opfn_state_conn_error(qp);\n\ttrace_hfi1_msg_opfn_conn_error(qp, \"error. qp state \", (u64)qp->state);\n\t \n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\twhile (priv->opfn.completed) {\n\t\tcapcode = priv->opfn.completed & ~(priv->opfn.completed - 1);\n\t\textd = &hfi1_opfn_handlers[ilog2(capcode) + 1];\n\t\tif (extd->error)\n\t\t\textd->error(qp);\n\t\tpriv->opfn.completed &= ~OPFN_CODE(capcode);\n\t}\n\tpriv->opfn.extended = 0;\n\tpriv->opfn.requested = 0;\n\tpriv->opfn.curr = STL_VERBS_EXTD_NONE;\n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n}\n\nvoid opfn_qp_init(struct rvt_qp *qp, struct ib_qp_attr *attr, int attr_mask)\n{\n\tstruct ib_qp *ibqp = &qp->ibqp;\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tunsigned long flags;\n\n\tif (attr_mask & IB_QP_RETRY_CNT)\n\t\tpriv->s_retry = attr->retry_cnt;\n\n\tspin_lock_irqsave(&priv->opfn.lock, flags);\n\tif (ibqp->qp_type == IB_QPT_RC && HFI1_CAP_IS_KSET(TID_RDMA)) {\n\t\tstruct tid_rdma_params *local = &priv->tid_rdma.local;\n\n\t\tif (attr_mask & IB_QP_TIMEOUT)\n\t\t\tpriv->tid_retry_timeout_jiffies = qp->timeout_jiffies;\n\t\tif (qp->pmtu == enum_to_mtu(OPA_MTU_4096) ||\n\t\t    qp->pmtu == enum_to_mtu(OPA_MTU_8192)) {\n\t\t\ttid_rdma_opfn_init(qp, local);\n\t\t\t \n\t\t\tif (attr_mask & IB_QP_STATE &&\n\t\t\t    attr->qp_state == IB_QPS_RTS) {\n\t\t\t\tpriv->opfn.requested |= OPFN_MASK(TID_RDMA);\n\t\t\t\t \n\t\t\t\tif (priv->opfn.completed &\n\t\t\t\t    OPFN_MASK(TID_RDMA)) {\n\t\t\t\t\tpriv->opfn.completed &=\n\t\t\t\t\t\t~OPFN_MASK(TID_RDMA);\n\t\t\t\t\t \n\t\t\t\t\topfn_schedule_conn_request(qp);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmemset(local, 0, sizeof(*local));\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->opfn.lock, flags);\n}\n\nvoid opfn_trigger_conn_request(struct rvt_qp *qp, u32 bth1)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\tif (!priv->opfn.extended && hfi1_opfn_extended(bth1) &&\n\t    HFI1_CAP_IS_KSET(OPFN)) {\n\t\tpriv->opfn.extended = 1;\n\t\tif (qp->state == IB_QPS_RTS)\n\t\t\topfn_conn_request(qp);\n\t}\n}\n\nint opfn_init(void)\n{\n\topfn_wq = alloc_workqueue(\"hfi_opfn\",\n\t\t\t\t  WQ_SYSFS | WQ_HIGHPRI | WQ_CPU_INTENSIVE |\n\t\t\t\t  WQ_MEM_RECLAIM,\n\t\t\t\t  HFI1_MAX_ACTIVE_WORKQUEUE_ENTRIES);\n\tif (!opfn_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid opfn_exit(void)\n{\n\tif (opfn_wq) {\n\t\tdestroy_workqueue(opfn_wq);\n\t\topfn_wq = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}