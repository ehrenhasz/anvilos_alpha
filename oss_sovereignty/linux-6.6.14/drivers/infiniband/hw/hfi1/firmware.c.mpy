{
  "module_name": "firmware.c",
  "hash_id": "ec859eeb2bdcdce896c8287c4395bb16f2d52ca8f11ee900d984e6632ed54a6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/firmware.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/crc32.h>\n\n#include \"hfi.h\"\n#include \"trace.h\"\n\n \n#define DEFAULT_FW_8051_NAME_FPGA \"hfi_dc8051.bin\"\n#define DEFAULT_FW_8051_NAME_ASIC \"hfi1_dc8051.fw\"\n#define DEFAULT_FW_FABRIC_NAME \"hfi1_fabric.fw\"\n#define DEFAULT_FW_SBUS_NAME \"hfi1_sbus.fw\"\n#define DEFAULT_FW_PCIE_NAME \"hfi1_pcie.fw\"\n#define ALT_FW_8051_NAME_ASIC \"hfi1_dc8051_d.fw\"\n#define ALT_FW_FABRIC_NAME \"hfi1_fabric_d.fw\"\n#define ALT_FW_SBUS_NAME \"hfi1_sbus_d.fw\"\n#define ALT_FW_PCIE_NAME \"hfi1_pcie_d.fw\"\n\nMODULE_FIRMWARE(DEFAULT_FW_8051_NAME_ASIC);\nMODULE_FIRMWARE(DEFAULT_FW_FABRIC_NAME);\nMODULE_FIRMWARE(DEFAULT_FW_SBUS_NAME);\nMODULE_FIRMWARE(DEFAULT_FW_PCIE_NAME);\n\nstatic uint fw_8051_load = 1;\nstatic uint fw_fabric_serdes_load = 1;\nstatic uint fw_pcie_serdes_load = 1;\nstatic uint fw_sbus_load = 1;\n\n \nstatic char *fw_8051_name;\nstatic char *fw_fabric_serdes_name;\nstatic char *fw_sbus_name;\nstatic char *fw_pcie_serdes_name;\n\n#define SBUS_MAX_POLL_COUNT 100\n#define SBUS_COUNTER(reg, name) \\\n\t(((reg) >> ASIC_STS_SBUS_COUNTERS_##name##_CNT_SHIFT) & \\\n\t ASIC_STS_SBUS_COUNTERS_##name##_CNT_MASK)\n\n \nstruct css_header {\n\tu32 module_type;\n\tu32 header_len;\n\tu32 header_version;\n\tu32 module_id;\n\tu32 module_vendor;\n\tu32 date;\t\t \n\tu32 size;\t\t \n\tu32 key_size;\t\t \n\tu32 modulus_size;\t \n\tu32 exponent_size;\t \n\tu32 reserved[22];\n};\n\n \n#define CSS_MODULE_TYPE\t   0x00000006\n#define CSS_HEADER_LEN\t   0x000000a1\n#define CSS_HEADER_VERSION 0x00010000\n#define CSS_MODULE_VENDOR  0x00008086\n\n#define KEY_SIZE      256\n#define MU_SIZE\t\t8\n#define EXPONENT_SIZE\t4\n\n \n#define MAX_PLATFORM_CONFIG_FILE_SIZE 4096\n\n \n#define PLATFORM_CONFIG_FORMAT_4_FILE_SIZE 528\n\n \nstruct firmware_file {\n\tstruct css_header css_header;\n\tu8 modulus[KEY_SIZE];\n\tu8 exponent[EXPONENT_SIZE];\n\tu8 signature[KEY_SIZE];\n\tu8 firmware[];\n};\n\nstruct augmented_firmware_file {\n\tstruct css_header css_header;\n\tu8 modulus[KEY_SIZE];\n\tu8 exponent[EXPONENT_SIZE];\n\tu8 signature[KEY_SIZE];\n\tu8 r2[KEY_SIZE];\n\tu8 mu[MU_SIZE];\n\tu8 firmware[];\n};\n\n \n#define AUGMENT_SIZE (sizeof(struct augmented_firmware_file) - \\\n\t\t\t\t\t\tsizeof(struct firmware_file))\n\nstruct firmware_details {\n\t \n\tconst struct firmware *fw;\n\n\tstruct css_header *css_header;\n\tu8 *firmware_ptr;\t\t \n\tu32 firmware_len;\t\t \n\tu8 *modulus;\t\t\t \n\tu8 *exponent;\t\t\t \n\tu8 *signature;\t\t\t \n\tu8 *r2;\t\t\t\t \n\tu8 *mu;\t\t\t\t \n\tstruct augmented_firmware_file dummy_header;\n};\n\n \nstatic DEFINE_MUTEX(fw_mutex);\nenum fw_state {\n\tFW_EMPTY,\n\tFW_TRY,\n\tFW_FINAL,\n\tFW_ERR\n};\n\nstatic enum fw_state fw_state = FW_EMPTY;\nstatic int fw_err;\nstatic struct firmware_details fw_8051;\nstatic struct firmware_details fw_fabric;\nstatic struct firmware_details fw_pcie;\nstatic struct firmware_details fw_sbus;\n\n \n#define SPICO_SBUS   0x1\n#define SPICO_FABRIC 0x2\n#define ENABLE_SPICO_SMASK 0x1\n\n \n#define RSA_CMD_INIT  0x1\n#define RSA_CMD_START 0x2\n\n \n#define RSA_STATUS_IDLE   0x0\n#define RSA_STATUS_ACTIVE 0x1\n#define RSA_STATUS_DONE   0x2\n#define RSA_STATUS_FAILED 0x3\n\n \n#define RSA_ENGINE_TIMEOUT 100  \n\n \n#define HM_TIMEOUT 10  \n\n \n#define DC8051_ACCESS_TIMEOUT 100  \n\n \n#define NUM_FABRIC_SERDES 4\n\n \n#define SBUS_READ_COMPLETE 0x4\n\n \nstatic const u8 fabric_serdes_addrs[2][NUM_FABRIC_SERDES] = {\n\t{ 0x01, 0x02, 0x03, 0x04 },\n\t{ 0x28, 0x29, 0x2a, 0x2b }\n};\n\n \nstatic const u8 pcie_serdes_addrs[2][NUM_PCIE_SERDES] = {\n\t{ 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16,\n\t  0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26 },\n\t{ 0x2f, 0x31, 0x33, 0x35, 0x37, 0x39, 0x3b, 0x3d,\n\t  0x3f, 0x41, 0x43, 0x45, 0x47, 0x49, 0x4b, 0x4d }\n};\n\n \nconst u8 pcie_pcs_addrs[2][NUM_PCIE_SERDES] = {\n\t{ 0x09, 0x0b, 0x0d, 0x0f, 0x11, 0x13, 0x15, 0x17,\n\t  0x19, 0x1b, 0x1d, 0x1f, 0x21, 0x23, 0x25, 0x27 },\n\t{ 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,\n\t  0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e }\n};\n\n \nstatic const u8 fabric_serdes_broadcast[2] = { 0xe4, 0xe5 };\nstatic const u8 all_fabric_serdes_broadcast = 0xe1;\n\n \nconst u8 pcie_serdes_broadcast[2] = { 0xe2, 0xe3 };\nstatic const u8 all_pcie_serdes_broadcast = 0xe0;\n\nstatic const u32 platform_config_table_limits[PLATFORM_CONFIG_TABLE_MAX] = {\n\t0,\n\tSYSTEM_TABLE_MAX,\n\tPORT_TABLE_MAX,\n\tRX_PRESET_TABLE_MAX,\n\tTX_PRESET_TABLE_MAX,\n\tQSFP_ATTEN_TABLE_MAX,\n\tVARIABLE_SETTINGS_TABLE_MAX\n};\n\n \nstatic void dispose_one_firmware(struct firmware_details *fdet);\nstatic int load_fabric_serdes_firmware(struct hfi1_devdata *dd,\n\t\t\t\t       struct firmware_details *fdet);\nstatic void dump_fw_version(struct hfi1_devdata *dd);\n\n \nstatic int __read_8051_data(struct hfi1_devdata *dd, u32 addr, u64 *result)\n{\n\tu64 reg;\n\tint count;\n\n\t \n\treg = (addr & DC_DC8051_CFG_RAM_ACCESS_CTRL_ADDRESS_MASK)\n\t\t\t<< DC_DC8051_CFG_RAM_ACCESS_CTRL_ADDRESS_SHIFT;\n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_CTRL, reg);\n\t \n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_CTRL,\n\t\t  reg | DC_DC8051_CFG_RAM_ACCESS_CTRL_READ_ENA_SMASK);\n\n\t \n\tcount = 0;\n\twhile ((read_csr(dd, DC_DC8051_CFG_RAM_ACCESS_STATUS)\n\t\t    & DC_DC8051_CFG_RAM_ACCESS_STATUS_ACCESS_COMPLETED_SMASK)\n\t\t    == 0) {\n\t\tcount++;\n\t\tif (count > DC8051_ACCESS_TIMEOUT) {\n\t\t\tdd_dev_err(dd, \"timeout reading 8051 data\\n\");\n\t\t\treturn -ENXIO;\n\t\t}\n\t\tndelay(10);\n\t}\n\n\t \n\t*result = read_csr(dd, DC_DC8051_CFG_RAM_ACCESS_RD_DATA);\n\n\treturn 0;\n}\n\n \nint read_8051_data(struct hfi1_devdata *dd, u32 addr, u32 len, u64 *result)\n{\n\tunsigned long flags;\n\tu32 done;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&dd->dc8051_memlock, flags);\n\n\t \n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_SETUP, 0);\n\n\tfor (done = 0; done < len; addr += 8, done += 8, result++) {\n\t\tret = __read_8051_data(dd, addr, result);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t \n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_CTRL, 0);\n\n\tspin_unlock_irqrestore(&dd->dc8051_memlock, flags);\n\n\treturn ret;\n}\n\n \nstatic int write_8051(struct hfi1_devdata *dd, int code, u32 start,\n\t\t      const u8 *data, u32 len)\n{\n\tu64 reg;\n\tu32 offset;\n\tint aligned, count;\n\n\t \n\taligned = ((unsigned long)data & 0x7) == 0;\n\n\t \n\treg = (code ? DC_DC8051_CFG_RAM_ACCESS_SETUP_RAM_SEL_SMASK : 0ull)\n\t\t| DC_DC8051_CFG_RAM_ACCESS_SETUP_AUTO_INCR_ADDR_SMASK;\n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_SETUP, reg);\n\n\treg = ((start & DC_DC8051_CFG_RAM_ACCESS_CTRL_ADDRESS_MASK)\n\t\t\t<< DC_DC8051_CFG_RAM_ACCESS_CTRL_ADDRESS_SHIFT)\n\t\t| DC_DC8051_CFG_RAM_ACCESS_CTRL_WRITE_ENA_SMASK;\n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_CTRL, reg);\n\n\t \n\tfor (offset = 0; offset < len; offset += 8) {\n\t\tint bytes = len - offset;\n\n\t\tif (bytes < 8) {\n\t\t\treg = 0;\n\t\t\tmemcpy(&reg, &data[offset], bytes);\n\t\t} else if (aligned) {\n\t\t\treg = *(u64 *)&data[offset];\n\t\t} else {\n\t\t\tmemcpy(&reg, &data[offset], 8);\n\t\t}\n\t\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_WR_DATA, reg);\n\n\t\t \n\t\tcount = 0;\n\t\twhile ((read_csr(dd, DC_DC8051_CFG_RAM_ACCESS_STATUS)\n\t\t    & DC_DC8051_CFG_RAM_ACCESS_STATUS_ACCESS_COMPLETED_SMASK)\n\t\t    == 0) {\n\t\t\tcount++;\n\t\t\tif (count > DC8051_ACCESS_TIMEOUT) {\n\t\t\t\tdd_dev_err(dd, \"timeout writing 8051 data\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\t \n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_CTRL, 0);\n\twrite_csr(dd, DC_DC8051_CFG_RAM_ACCESS_SETUP, 0);\n\n\treturn 0;\n}\n\n \nstatic int invalid_header(struct hfi1_devdata *dd, const char *what,\n\t\t\t  u32 actual, u32 expected)\n{\n\tif (actual == expected)\n\t\treturn 0;\n\n\tdd_dev_err(dd,\n\t\t   \"invalid firmware header field %s: expected 0x%x, actual 0x%x\\n\",\n\t\t   what, expected, actual);\n\treturn 1;\n}\n\n \nstatic int verify_css_header(struct hfi1_devdata *dd, struct css_header *css)\n{\n\t \n\tif (invalid_header(dd, \"module_type\", css->module_type,\n\t\t\t   CSS_MODULE_TYPE) ||\n\t    invalid_header(dd, \"header_len\", css->header_len,\n\t\t\t   (sizeof(struct firmware_file) / 4)) ||\n\t    invalid_header(dd, \"header_version\", css->header_version,\n\t\t\t   CSS_HEADER_VERSION) ||\n\t    invalid_header(dd, \"module_vendor\", css->module_vendor,\n\t\t\t   CSS_MODULE_VENDOR) ||\n\t    invalid_header(dd, \"key_size\", css->key_size, KEY_SIZE / 4) ||\n\t    invalid_header(dd, \"modulus_size\", css->modulus_size,\n\t\t\t   KEY_SIZE / 4) ||\n\t    invalid_header(dd, \"exponent_size\", css->exponent_size,\n\t\t\t   EXPONENT_SIZE / 4)) {\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int payload_check(struct hfi1_devdata *dd, const char *name,\n\t\t\t long file_size, long prefix_size)\n{\n\t \n\tif (prefix_size >= file_size) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"firmware \\\"%s\\\", size %ld, must be larger than %ld bytes\\n\",\n\t\t\t   name, file_size, prefix_size);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int obtain_one_firmware(struct hfi1_devdata *dd, const char *name,\n\t\t\t       struct firmware_details *fdet)\n{\n\tstruct css_header *css;\n\tint ret;\n\n\tmemset(fdet, 0, sizeof(*fdet));\n\n\tret = request_firmware(&fdet->fw, name, &dd->pcidev->dev);\n\tif (ret) {\n\t\tdd_dev_warn(dd, \"cannot find firmware \\\"%s\\\", err %d\\n\",\n\t\t\t    name, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (fdet->fw->size < sizeof(struct css_header)) {\n\t\tdd_dev_err(dd, \"firmware \\\"%s\\\" is too small\\n\", name);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tcss = (struct css_header *)fdet->fw->data;\n\n\thfi1_cdbg(FIRMWARE, \"Firmware %s details:\", name);\n\thfi1_cdbg(FIRMWARE, \"file size: 0x%lx bytes\", fdet->fw->size);\n\thfi1_cdbg(FIRMWARE, \"CSS structure:\");\n\thfi1_cdbg(FIRMWARE, \"  module_type    0x%x\", css->module_type);\n\thfi1_cdbg(FIRMWARE, \"  header_len     0x%03x (0x%03x bytes)\",\n\t\t  css->header_len, 4 * css->header_len);\n\thfi1_cdbg(FIRMWARE, \"  header_version 0x%x\", css->header_version);\n\thfi1_cdbg(FIRMWARE, \"  module_id      0x%x\", css->module_id);\n\thfi1_cdbg(FIRMWARE, \"  module_vendor  0x%x\", css->module_vendor);\n\thfi1_cdbg(FIRMWARE, \"  date           0x%x\", css->date);\n\thfi1_cdbg(FIRMWARE, \"  size           0x%03x (0x%03x bytes)\",\n\t\t  css->size, 4 * css->size);\n\thfi1_cdbg(FIRMWARE, \"  key_size       0x%03x (0x%03x bytes)\",\n\t\t  css->key_size, 4 * css->key_size);\n\thfi1_cdbg(FIRMWARE, \"  modulus_size   0x%03x (0x%03x bytes)\",\n\t\t  css->modulus_size, 4 * css->modulus_size);\n\thfi1_cdbg(FIRMWARE, \"  exponent_size  0x%03x (0x%03x bytes)\",\n\t\t  css->exponent_size, 4 * css->exponent_size);\n\thfi1_cdbg(FIRMWARE, \"firmware size: 0x%lx bytes\",\n\t\t  fdet->fw->size - sizeof(struct firmware_file));\n\n\t \n\tret = verify_css_header(dd, css);\n\tif (ret) {\n\t\tdd_dev_info(dd, \"Invalid CSS header for \\\"%s\\\"\\n\", name);\n\t} else if ((css->size * 4) == fdet->fw->size) {\n\t\t \n\t\tstruct firmware_file *ff = (struct firmware_file *)\n\t\t\t\t\t\t\tfdet->fw->data;\n\n\t\t \n\t\tret = payload_check(dd, name, fdet->fw->size,\n\t\t\t\t    sizeof(struct firmware_file));\n\t\tif (ret == 0) {\n\t\t\tfdet->css_header = css;\n\t\t\tfdet->modulus = ff->modulus;\n\t\t\tfdet->exponent = ff->exponent;\n\t\t\tfdet->signature = ff->signature;\n\t\t\tfdet->r2 = fdet->dummy_header.r2;  \n\t\t\tfdet->mu = fdet->dummy_header.mu;  \n\t\t\tfdet->firmware_ptr = ff->firmware;\n\t\t\tfdet->firmware_len = fdet->fw->size -\n\t\t\t\t\t\tsizeof(struct firmware_file);\n\t\t\t \n\t\t\tdd_dev_err(dd, \"driver is unable to validate firmware without r2 and mu (not in firmware file)\\n\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if ((css->size * 4) + AUGMENT_SIZE == fdet->fw->size) {\n\t\t \n\t\tstruct augmented_firmware_file *aff =\n\t\t\t(struct augmented_firmware_file *)fdet->fw->data;\n\n\t\t \n\t\tret = payload_check(dd, name, fdet->fw->size,\n\t\t\t\t    sizeof(struct augmented_firmware_file));\n\t\tif (ret == 0) {\n\t\t\tfdet->css_header = css;\n\t\t\tfdet->modulus = aff->modulus;\n\t\t\tfdet->exponent = aff->exponent;\n\t\t\tfdet->signature = aff->signature;\n\t\t\tfdet->r2 = aff->r2;\n\t\t\tfdet->mu = aff->mu;\n\t\t\tfdet->firmware_ptr = aff->firmware;\n\t\t\tfdet->firmware_len = fdet->fw->size -\n\t\t\t\t\tsizeof(struct augmented_firmware_file);\n\t\t}\n\t} else {\n\t\t \n\t\tdd_dev_err(dd,\n\t\t\t   \"invalid firmware header field size: expected 0x%lx or 0x%lx, actual 0x%x\\n\",\n\t\t\t   fdet->fw->size / 4,\n\t\t\t   (fdet->fw->size - AUGMENT_SIZE) / 4,\n\t\t\t   css->size);\n\n\t\tret = -EINVAL;\n\t}\n\ndone:\n\t \n\tif (ret)\n\t\tdispose_one_firmware(fdet);\n\treturn ret;\n}\n\nstatic void dispose_one_firmware(struct firmware_details *fdet)\n{\n\trelease_firmware(fdet->fw);\n\t \n\tmemset(fdet, 0, sizeof(*fdet));\n}\n\n \nstatic void __obtain_firmware(struct hfi1_devdata *dd)\n{\n\tint err = 0;\n\n\tif (fw_state == FW_FINAL)\t \n\t\treturn;\n\tif (fw_state == FW_ERR)\t\t \n\t\treturn;\n\n\t \nretry:\n\tif (fw_state == FW_TRY) {\n\t\t \n\t\tdd_dev_warn(dd, \"using alternate firmware names\\n\");\n\t\t \n\t\tcond_resched();\n\t\tif (fw_8051_load)\n\t\t\tdispose_one_firmware(&fw_8051);\n\t\tif (fw_fabric_serdes_load)\n\t\t\tdispose_one_firmware(&fw_fabric);\n\t\tif (fw_sbus_load)\n\t\t\tdispose_one_firmware(&fw_sbus);\n\t\tif (fw_pcie_serdes_load)\n\t\t\tdispose_one_firmware(&fw_pcie);\n\t\tfw_8051_name = ALT_FW_8051_NAME_ASIC;\n\t\tfw_fabric_serdes_name = ALT_FW_FABRIC_NAME;\n\t\tfw_sbus_name = ALT_FW_SBUS_NAME;\n\t\tfw_pcie_serdes_name = ALT_FW_PCIE_NAME;\n\n\t\t \n\t\tusleep_range(100, 120);\n\t}\n\n\tif (fw_sbus_load) {\n\t\terr = obtain_one_firmware(dd, fw_sbus_name, &fw_sbus);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (fw_pcie_serdes_load) {\n\t\terr = obtain_one_firmware(dd, fw_pcie_serdes_name, &fw_pcie);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (fw_fabric_serdes_load) {\n\t\terr = obtain_one_firmware(dd, fw_fabric_serdes_name,\n\t\t\t\t\t  &fw_fabric);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\n\tif (fw_8051_load) {\n\t\terr = obtain_one_firmware(dd, fw_8051_name, &fw_8051);\n\t\tif (err)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (err) {\n\t\t \n\t\tif (fw_state == FW_EMPTY && dd->icode == ICODE_RTL_SILICON) {\n\t\t\t \n\t\t\tfw_state = FW_TRY;\n\t\t\tgoto retry;\n\t\t}\n\t\tdd_dev_err(dd, \"unable to obtain working firmware\\n\");\n\t\tfw_state = FW_ERR;\n\t\tfw_err = -ENOENT;\n\t} else {\n\t\t \n\t\tif (fw_state == FW_EMPTY &&\n\t\t    dd->icode != ICODE_FUNCTIONAL_SIMULATOR)\n\t\t\tfw_state = FW_TRY;\t \n\t\telse\n\t\t\tfw_state = FW_FINAL;\t \n\t}\n}\n\n \nstatic int obtain_firmware(struct hfi1_devdata *dd)\n{\n\tunsigned long timeout;\n\n\tmutex_lock(&fw_mutex);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(40000);\n\twhile (fw_state == FW_TRY) {\n\t\t \n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tdd_dev_err(dd, \"Timeout waiting for firmware try\");\n\t\t\tfw_state = FW_ERR;\n\t\t\tfw_err = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&fw_mutex);\n\t\tmsleep(20);\t \n\t\tmutex_lock(&fw_mutex);\n\t}\n\t \n\n\t \n\tif (fw_state == FW_EMPTY)\n\t\t__obtain_firmware(dd);\n\n\tmutex_unlock(&fw_mutex);\n\treturn fw_err;\n}\n\n \nvoid dispose_firmware(void)\n{\n\tdispose_one_firmware(&fw_8051);\n\tdispose_one_firmware(&fw_fabric);\n\tdispose_one_firmware(&fw_pcie);\n\tdispose_one_firmware(&fw_sbus);\n\n\t \n\tif (fw_state != FW_ERR)\n\t\tfw_state = FW_EMPTY;\n}\n\n \nstatic int retry_firmware(struct hfi1_devdata *dd, int load_result)\n{\n\tint retry;\n\n\tmutex_lock(&fw_mutex);\n\n\tif (load_result == 0) {\n\t\t \n\t\tif (fw_state == FW_TRY)\n\t\t\tfw_state = FW_FINAL;\n\t\tretry = 0;\t \n\t} else if (fw_state == FW_TRY) {\n\t\t \n\t\t__obtain_firmware(dd);\n\t\tretry = (fw_state == FW_FINAL);\n\t} else {\n\t\t \n\t\tretry = 0;\n\t}\n\n\tmutex_unlock(&fw_mutex);\n\treturn retry;\n}\n\n \nstatic void write_rsa_data(struct hfi1_devdata *dd, int what,\n\t\t\t   const u8 *data, int nbytes)\n{\n\tint qw_size = nbytes / 8;\n\tint i;\n\n\tif (((unsigned long)data & 0x7) == 0) {\n\t\t \n\t\tu64 *ptr = (u64 *)data;\n\n\t\tfor (i = 0; i < qw_size; i++, ptr++)\n\t\t\twrite_csr(dd, what + (8 * i), *ptr);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < qw_size; i++, data += 8) {\n\t\t\tu64 value;\n\n\t\t\tmemcpy(&value, data, 8);\n\t\t\twrite_csr(dd, what + (8 * i), value);\n\t\t}\n\t}\n}\n\n \nstatic void write_streamed_rsa_data(struct hfi1_devdata *dd, int what,\n\t\t\t\t    const u8 *data, int nbytes)\n{\n\tu64 *ptr = (u64 *)data;\n\tint qw_size = nbytes / 8;\n\n\tfor (; qw_size > 0; qw_size--, ptr++)\n\t\twrite_csr(dd, what, *ptr);\n}\n\n \nstatic int run_rsa(struct hfi1_devdata *dd, const char *who,\n\t\t   const u8 *signature)\n{\n\tunsigned long timeout;\n\tu64 reg;\n\tu32 status;\n\tint ret = 0;\n\n\t \n\twrite_rsa_data(dd, MISC_CFG_RSA_SIGNATURE, signature, KEY_SIZE);\n\n\t \n\twrite_csr(dd, MISC_CFG_RSA_CMD, RSA_CMD_INIT);\n\n\t \n\tstatus = (read_csr(dd, MISC_CFG_FW_CTRL)\n\t\t\t   & MISC_CFG_FW_CTRL_RSA_STATUS_SMASK)\n\t\t\t     >> MISC_CFG_FW_CTRL_RSA_STATUS_SHIFT;\n\tif (status != RSA_STATUS_IDLE) {\n\t\tdd_dev_err(dd, \"%s security engine not idle - giving up\\n\",\n\t\t\t   who);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\twrite_csr(dd, MISC_CFG_RSA_CMD, RSA_CMD_START);\n\n\t \n\ttimeout = msecs_to_jiffies(RSA_ENGINE_TIMEOUT) + jiffies;\n\twhile (1) {\n\t\tstatus = (read_csr(dd, MISC_CFG_FW_CTRL)\n\t\t\t   & MISC_CFG_FW_CTRL_RSA_STATUS_SMASK)\n\t\t\t     >> MISC_CFG_FW_CTRL_RSA_STATUS_SHIFT;\n\n\t\tif (status == RSA_STATUS_IDLE) {\n\t\t\t \n\t\t\tdd_dev_err(dd, \"%s firmware security bad idle state\\n\",\n\t\t\t\t   who);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t} else if (status == RSA_STATUS_DONE) {\n\t\t\t \n\t\t\tbreak;\n\t\t} else if (status == RSA_STATUS_FAILED) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\t \n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\t \n\t\t\tdd_dev_err(dd, \"%s firmware security time out\\n\", who);\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(20);\n\t}\n\n\t \n\twrite_csr(dd, MISC_ERR_CLEAR,\n\t\t  MISC_ERR_STATUS_MISC_FW_AUTH_FAILED_ERR_SMASK |\n\t\t  MISC_ERR_STATUS_MISC_KEY_MISMATCH_ERR_SMASK);\n\t \n\treg = read_csr(dd, MISC_ERR_STATUS);\n\tif (ret) {\n\t\tif (reg & MISC_ERR_STATUS_MISC_FW_AUTH_FAILED_ERR_SMASK)\n\t\t\tdd_dev_warn(dd, \"%s firmware authorization failed\\n\",\n\t\t\t\t    who);\n\t\tif (reg & MISC_ERR_STATUS_MISC_KEY_MISMATCH_ERR_SMASK)\n\t\t\tdd_dev_warn(dd, \"%s firmware key mismatch\\n\", who);\n\t}\n\n\treturn ret;\n}\n\nstatic void load_security_variables(struct hfi1_devdata *dd,\n\t\t\t\t    struct firmware_details *fdet)\n{\n\t \n\twrite_rsa_data(dd, MISC_CFG_RSA_MODULUS, fdet->modulus, KEY_SIZE);\n\t \n\twrite_rsa_data(dd, MISC_CFG_RSA_R2, fdet->r2, KEY_SIZE);\n\t \n\twrite_rsa_data(dd, MISC_CFG_RSA_MU, fdet->mu, MU_SIZE);\n\t \n\twrite_streamed_rsa_data(dd, MISC_CFG_SHA_PRELOAD,\n\t\t\t\t(u8 *)fdet->css_header,\n\t\t\t\tsizeof(struct css_header));\n}\n\n \nstatic inline u32 get_firmware_state(struct hfi1_devdata *dd)\n{\n\tu64 reg = read_csr(dd, DC_DC8051_STS_CUR_STATE);\n\n\treturn (reg >> DC_DC8051_STS_CUR_STATE_FIRMWARE_SHIFT)\n\t\t\t\t& DC_DC8051_STS_CUR_STATE_FIRMWARE_MASK;\n}\n\n \nint wait_fm_ready(struct hfi1_devdata *dd, u32 mstimeout)\n{\n\tunsigned long timeout;\n\n\t \n\tif (dd->icode == ICODE_FUNCTIONAL_SIMULATOR)\n\t\treturn 0;\n\n\ttimeout = msecs_to_jiffies(mstimeout) + jiffies;\n\twhile (1) {\n\t\tif (get_firmware_state(dd) == 0xa0)\t \n\t\t\treturn 0;\n\t\tif (time_after(jiffies, timeout))\t \n\t\t\treturn -ETIMEDOUT;\n\t\tusleep_range(1950, 2050);  \n\t}\n}\n\n \nstatic int load_8051_firmware(struct hfi1_devdata *dd,\n\t\t\t      struct firmware_details *fdet)\n{\n\tu64 reg;\n\tint ret;\n\tu8 ver_major;\n\tu8 ver_minor;\n\tu8 ver_patch;\n\n\t \n\t \n\treg = DC_DC8051_CFG_RST_M8051W_SMASK\n\t\t| DC_DC8051_CFG_RST_CRAM_SMASK\n\t\t| DC_DC8051_CFG_RST_DRAM_SMASK\n\t\t| DC_DC8051_CFG_RST_IRAM_SMASK\n\t\t| DC_DC8051_CFG_RST_SFR_SMASK;\n\twrite_csr(dd, DC_DC8051_CFG_RST, reg);\n\n\t \n\n\t \n\t \n\treg = DC_DC8051_CFG_RST_M8051W_SMASK;\n\twrite_csr(dd, DC_DC8051_CFG_RST, reg);\n\n\t \n\tload_security_variables(dd, fdet);\n\n\t \n\twrite_csr(dd, MISC_CFG_FW_CTRL, 0);\n\n\t \n\tret = write_8051(dd, 1 , 0, fdet->firmware_ptr,\n\t\t\t fdet->firmware_len);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t \n\twrite_csr(dd, MISC_CFG_FW_CTRL, MISC_CFG_FW_CTRL_FW_8051_LOADED_SMASK);\n\n\t \n\tret = run_rsa(dd, \"8051\", fdet->signature);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twrite_csr(dd, DC_DC8051_CFG_RST, 0ull);\n\n\t \n\tret = wait_fm_ready(dd, TIMEOUT_8051_START);\n\tif (ret) {  \n\t\tdd_dev_err(dd, \"8051 start timeout, current state 0x%x\\n\",\n\t\t\t   get_firmware_state(dd));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tread_misc_status(dd, &ver_major, &ver_minor, &ver_patch);\n\tdd_dev_info(dd, \"8051 firmware version %d.%d.%d\\n\",\n\t\t    (int)ver_major, (int)ver_minor, (int)ver_patch);\n\tdd->dc8051_ver = dc8051_ver(ver_major, ver_minor, ver_patch);\n\tret = write_host_interface_version(dd, HOST_INTERFACE_VERSION);\n\tif (ret != HCMD_SUCCESS) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"Failed to set host interface version, return 0x%x\\n\",\n\t\t\t   ret);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\n \nvoid sbus_request(struct hfi1_devdata *dd,\n\t\t  u8 receiver_addr, u8 data_addr, u8 command, u32 data_in)\n{\n\twrite_csr(dd, ASIC_CFG_SBUS_REQUEST,\n\t\t  ((u64)data_in << ASIC_CFG_SBUS_REQUEST_DATA_IN_SHIFT) |\n\t\t  ((u64)command << ASIC_CFG_SBUS_REQUEST_COMMAND_SHIFT) |\n\t\t  ((u64)data_addr << ASIC_CFG_SBUS_REQUEST_DATA_ADDR_SHIFT) |\n\t\t  ((u64)receiver_addr <<\n\t\t   ASIC_CFG_SBUS_REQUEST_RECEIVER_ADDR_SHIFT));\n}\n\n \nstatic u32 sbus_read(struct hfi1_devdata *dd, u8 receiver_addr, u8 data_addr,\n\t\t     u32 data_in)\n{\n\tu64 reg;\n\tint retries;\n\tint success = 0;\n\tu32 result = 0;\n\tu32 result_code = 0;\n\n\tsbus_request(dd, receiver_addr, data_addr, READ_SBUS_RECEIVER, data_in);\n\n\tfor (retries = 0; retries < 100; retries++) {\n\t\tusleep_range(1000, 1200);  \n\t\treg = read_csr(dd, ASIC_STS_SBUS_RESULT);\n\t\tresult_code = (reg >> ASIC_STS_SBUS_RESULT_RESULT_CODE_SHIFT)\n\t\t\t\t& ASIC_STS_SBUS_RESULT_RESULT_CODE_MASK;\n\t\tif (result_code != SBUS_READ_COMPLETE)\n\t\t\tcontinue;\n\n\t\tsuccess = 1;\n\t\tresult = (reg >> ASIC_STS_SBUS_RESULT_DATA_OUT_SHIFT)\n\t\t\t   & ASIC_STS_SBUS_RESULT_DATA_OUT_MASK;\n\t\tbreak;\n\t}\n\n\tif (!success) {\n\t\tdd_dev_err(dd, \"%s: read failed, result code 0x%x\\n\", __func__,\n\t\t\t   result_code);\n\t}\n\n\treturn result;\n}\n\n \nstatic void turn_off_spicos(struct hfi1_devdata *dd, int flags)\n{\n\t \n\tif (!is_ax(dd))\n\t\treturn;\n\n\tdd_dev_info(dd, \"Turning off spicos:%s%s\\n\",\n\t\t    flags & SPICO_SBUS ? \" SBus\" : \"\",\n\t\t    flags & SPICO_FABRIC ? \" fabric\" : \"\");\n\n\twrite_csr(dd, MISC_CFG_FW_CTRL, ENABLE_SPICO_SMASK);\n\t \n\tif (flags & SPICO_SBUS)\n\t\tsbus_request(dd, SBUS_MASTER_BROADCAST, 0x01,\n\t\t\t     WRITE_SBUS_RECEIVER, 0x00000040);\n\n\t \n\tif (flags & SPICO_FABRIC)\n\t\tsbus_request(dd, fabric_serdes_broadcast[dd->hfi1_id],\n\t\t\t     0x07, WRITE_SBUS_RECEIVER, 0x00000000);\n\twrite_csr(dd, MISC_CFG_FW_CTRL, 0);\n}\n\n \nvoid fabric_serdes_reset(struct hfi1_devdata *dd)\n{\n\tint ret;\n\n\tif (!fw_fabric_serdes_load)\n\t\treturn;\n\n\tret = acquire_chip_resource(dd, CR_SBUS, SBUS_TIMEOUT);\n\tif (ret) {\n\t\tdd_dev_err(dd,\n\t\t\t   \"Cannot acquire SBus resource to reset fabric SerDes - perhaps you should reboot\\n\");\n\t\treturn;\n\t}\n\tset_sbus_fast_mode(dd);\n\n\tif (is_ax(dd)) {\n\t\t \n\t\tu8 ra = fabric_serdes_broadcast[dd->hfi1_id];\n\n\t\t \n\t\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000011);\n\t\t \n\t\tudelay(1);\n\t\t \n\t\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000010);\n\t\t \n\t\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000002);\n\t} else {\n\t\tturn_off_spicos(dd, SPICO_FABRIC);\n\t\t \n\t\t(void)load_fabric_serdes_firmware(dd, &fw_fabric);\n\t}\n\n\tclear_sbus_fast_mode(dd);\n\trelease_chip_resource(dd, CR_SBUS);\n}\n\n \nint sbus_request_slow(struct hfi1_devdata *dd,\n\t\t      u8 receiver_addr, u8 data_addr, u8 command, u32 data_in)\n{\n\tu64 reg, count = 0;\n\n\t \n\tclear_sbus_fast_mode(dd);\n\n\tsbus_request(dd, receiver_addr, data_addr, command, data_in);\n\twrite_csr(dd, ASIC_CFG_SBUS_EXECUTE,\n\t\t  ASIC_CFG_SBUS_EXECUTE_EXECUTE_SMASK);\n\t \n\treg = read_csr(dd, ASIC_STS_SBUS_RESULT);\n\twhile (!((reg & ASIC_STS_SBUS_RESULT_DONE_SMASK) &&\n\t\t (reg & ASIC_STS_SBUS_RESULT_RCV_DATA_VALID_SMASK))) {\n\t\tif (count++ >= SBUS_MAX_POLL_COUNT) {\n\t\t\tu64 counts = read_csr(dd, ASIC_STS_SBUS_COUNTERS);\n\t\t\t \n\t\t\tif ((reg & ASIC_STS_SBUS_RESULT_DONE_SMASK) &&\n\t\t\t    (SBUS_COUNTER(counts, RCV_DATA_VALID) ==\n\t\t\t     SBUS_COUNTER(counts, EXECUTE)))\n\t\t\t\tbreak;\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t\treg = read_csr(dd, ASIC_STS_SBUS_RESULT);\n\t}\n\tcount = 0;\n\twrite_csr(dd, ASIC_CFG_SBUS_EXECUTE, 0);\n\t \n\treg = read_csr(dd, ASIC_STS_SBUS_RESULT);\n\twhile (reg & ASIC_STS_SBUS_RESULT_DONE_SMASK) {\n\t\tif (count++ >= SBUS_MAX_POLL_COUNT)\n\t\t\treturn -ETIME;\n\t\tudelay(1);\n\t\treg = read_csr(dd, ASIC_STS_SBUS_RESULT);\n\t}\n\treturn 0;\n}\n\nstatic int load_fabric_serdes_firmware(struct hfi1_devdata *dd,\n\t\t\t\t       struct firmware_details *fdet)\n{\n\tint i, err;\n\tconst u8 ra = fabric_serdes_broadcast[dd->hfi1_id];  \n\n\tdd_dev_info(dd, \"Downloading fabric firmware\\n\");\n\n\t \n\tload_security_variables(dd, fdet);\n\t \n\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000011);\n\t \n\tudelay(1);\n\t \n\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000010);\n\t \n\tsbus_request(dd, ra, 0x00, WRITE_SBUS_RECEIVER, 0x40000000);\n\t \n\tfor (i = 0; i < fdet->firmware_len; i += 4) {\n\t\tsbus_request(dd, ra, 0x0a, WRITE_SBUS_RECEIVER,\n\t\t\t     *(u32 *)&fdet->firmware_ptr[i]);\n\t}\n\t \n\tsbus_request(dd, ra, 0x00, WRITE_SBUS_RECEIVER, 0x00000000);\n\t \n\tsbus_request(dd, ra, 0x0b, WRITE_SBUS_RECEIVER, 0x000c0000);\n\n\t \n\terr = run_rsa(dd, \"fabric serdes\", fdet->signature);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsbus_request(dd, ra, 0x07, WRITE_SBUS_RECEIVER, 0x00000002);\n\t \n\tsbus_request(dd, ra, 0x08, WRITE_SBUS_RECEIVER, 0x00000000);\n\n\treturn 0;\n}\n\nstatic int load_sbus_firmware(struct hfi1_devdata *dd,\n\t\t\t      struct firmware_details *fdet)\n{\n\tint i, err;\n\tconst u8 ra = SBUS_MASTER_BROADCAST;  \n\n\tdd_dev_info(dd, \"Downloading SBus firmware\\n\");\n\n\t \n\tload_security_variables(dd, fdet);\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x000000c0);\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000240);\n\t \n\tsbus_request(dd, ra, 0x03, WRITE_SBUS_RECEIVER, 0x80000000);\n\t \n\tfor (i = 0; i < fdet->firmware_len; i += 4) {\n\t\tsbus_request(dd, ra, 0x14, WRITE_SBUS_RECEIVER,\n\t\t\t     *(u32 *)&fdet->firmware_ptr[i]);\n\t}\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000040);\n\t \n\tsbus_request(dd, ra, 0x16, WRITE_SBUS_RECEIVER, 0x000c0000);\n\n\t \n\terr = run_rsa(dd, \"SBus\", fdet->signature);\n\tif (err)\n\t\treturn err;\n\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000140);\n\n\treturn 0;\n}\n\nstatic int load_pcie_serdes_firmware(struct hfi1_devdata *dd,\n\t\t\t\t     struct firmware_details *fdet)\n{\n\tint i;\n\tconst u8 ra = SBUS_MASTER_BROADCAST;  \n\n\tdd_dev_info(dd, \"Downloading PCIe firmware\\n\");\n\n\t \n\tload_security_variables(dd, fdet);\n\t \n\tsbus_request(dd, ra, 0x05, WRITE_SBUS_RECEIVER, 0x00000001);\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000d40);\n\t \n\t \n\tfor (i = 0; i < fdet->firmware_len; i += 4) {\n\t\tsbus_request(dd, ra, 0x04, WRITE_SBUS_RECEIVER,\n\t\t\t     *(u32 *)&fdet->firmware_ptr[i]);\n\t}\n\t \n\tsbus_request(dd, ra, 0x01, WRITE_SBUS_RECEIVER, 0x00000140);\n\t \n\tsbus_request(dd, ra, 0x05, WRITE_SBUS_RECEIVER, 0x00000000);\n\n\t \n\treturn run_rsa(dd, \"PCIe serdes\", fdet->signature);\n}\n\n \nstatic void set_serdes_broadcast(struct hfi1_devdata *dd, u8 bg1, u8 bg2,\n\t\t\t\t const u8 *addrs, int count)\n{\n\twhile (--count >= 0) {\n\t\t \n\t\tsbus_request(dd, addrs[count], 0xfd, WRITE_SBUS_RECEIVER,\n\t\t\t     (u32)bg1 << 4 | (u32)bg2 << 16);\n\t}\n}\n\nint acquire_hw_mutex(struct hfi1_devdata *dd)\n{\n\tunsigned long timeout;\n\tint try = 0;\n\tu8 mask = 1 << dd->hfi1_id;\n\tu8 user = (u8)read_csr(dd, ASIC_CFG_MUTEX);\n\n\tif (user == mask) {\n\t\tdd_dev_info(dd,\n\t\t\t    \"Hardware mutex already acquired, mutex mask %u\\n\",\n\t\t\t    (u32)mask);\n\t\treturn 0;\n\t}\n\nretry:\n\ttimeout = msecs_to_jiffies(HM_TIMEOUT) + jiffies;\n\twhile (1) {\n\t\twrite_csr(dd, ASIC_CFG_MUTEX, mask);\n\t\tuser = (u8)read_csr(dd, ASIC_CFG_MUTEX);\n\t\tif (user == mask)\n\t\t\treturn 0;  \n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;  \n\t\tmsleep(20);\n\t}\n\n\t \n\tdd_dev_err(dd,\n\t\t   \"Unable to acquire hardware mutex, mutex mask %u, my mask %u (%s)\\n\",\n\t\t   (u32)user, (u32)mask, (try == 0) ? \"retrying\" : \"giving up\");\n\n\tif (try == 0) {\n\t\t \n\t\twrite_csr(dd, ASIC_CFG_MUTEX, 0);\n\t\ttry++;\n\t\tgoto retry;\n\t}\n\n\treturn -EBUSY;\n}\n\nvoid release_hw_mutex(struct hfi1_devdata *dd)\n{\n\tu8 mask = 1 << dd->hfi1_id;\n\tu8 user = (u8)read_csr(dd, ASIC_CFG_MUTEX);\n\n\tif (user != mask)\n\t\tdd_dev_warn(dd,\n\t\t\t    \"Unable to release hardware mutex, mutex mask %u, my mask %u\\n\",\n\t\t\t    (u32)user, (u32)mask);\n\telse\n\t\twrite_csr(dd, ASIC_CFG_MUTEX, 0);\n}\n\n \nstatic inline u64 resource_mask(u32 hfi1_id, u32 resource)\n{\n\treturn ((u64)resource) << (hfi1_id ? CR_DYN_SHIFT : 0);\n}\n\nstatic void fail_mutex_acquire_message(struct hfi1_devdata *dd,\n\t\t\t\t       const char *func)\n{\n\tdd_dev_err(dd,\n\t\t   \"%s: hardware mutex stuck - suggest rebooting the machine\\n\",\n\t\t   func);\n}\n\n \nstatic int __acquire_chip_resource(struct hfi1_devdata *dd, u32 resource)\n{\n\tu64 scratch0, all_bits, my_bit;\n\tint ret;\n\n\tif (resource & CR_DYN_MASK) {\n\t\t \n\t\tif (dd->pcidev->device == PCI_DEVICE_ID_INTEL0 &&\n\t\t    (resource & (CR_I2C1 | CR_I2C2))) {\n\t\t\t \n\t\t\tall_bits = resource_mask(0, CR_I2C1 | CR_I2C2) |\n\t\t\t\t\tresource_mask(1, CR_I2C1 | CR_I2C2);\n\t\t} else {\n\t\t\tall_bits = resource_mask(0, resource) |\n\t\t\t\t\t\tresource_mask(1, resource);\n\t\t}\n\t\tmy_bit = resource_mask(dd->hfi1_id, resource);\n\t} else {\n\t\t \n\t\tall_bits = resource;\n\t\tmy_bit = resource;\n\t}\n\n\t \n\tmutex_lock(&dd->asic_data->asic_resource_mutex);\n\n\tret = acquire_hw_mutex(dd);\n\tif (ret) {\n\t\tfail_mutex_acquire_message(dd, __func__);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tif (scratch0 & all_bits) {\n\t\tret = -EBUSY;\n\t} else {\n\t\twrite_csr(dd, ASIC_CFG_SCRATCH, scratch0 | my_bit);\n\t\t \n\t\t(void)read_csr(dd, ASIC_CFG_SCRATCH);\n\t}\n\n\trelease_hw_mutex(dd);\n\ndone:\n\tmutex_unlock(&dd->asic_data->asic_resource_mutex);\n\treturn ret;\n}\n\n \nint acquire_chip_resource(struct hfi1_devdata *dd, u32 resource, u32 mswait)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\ttimeout = jiffies + msecs_to_jiffies(mswait);\n\twhile (1) {\n\t\tret = __acquire_chip_resource(dd, resource);\n\t\tif (ret != -EBUSY)\n\t\t\treturn ret;\n\t\t \n\t\tif (time_after_eq(jiffies, timeout))\n\t\t\treturn -EBUSY;\n\t\tusleep_range(80, 120);\t \n\t}\n}\n\n \nvoid release_chip_resource(struct hfi1_devdata *dd, u32 resource)\n{\n\tu64 scratch0, bit;\n\n\t \n\tif (!(resource & CR_DYN_MASK)) {\n\t\tdd_dev_err(dd, \"%s: invalid resource 0x%x\\n\", __func__,\n\t\t\t   resource);\n\t\treturn;\n\t}\n\tbit = resource_mask(dd->hfi1_id, resource);\n\n\t \n\tmutex_lock(&dd->asic_data->asic_resource_mutex);\n\n\tif (acquire_hw_mutex(dd)) {\n\t\tfail_mutex_acquire_message(dd, __func__);\n\t\tgoto done;\n\t}\n\n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tif ((scratch0 & bit) != 0) {\n\t\tscratch0 &= ~bit;\n\t\twrite_csr(dd, ASIC_CFG_SCRATCH, scratch0);\n\t\t \n\t\t(void)read_csr(dd, ASIC_CFG_SCRATCH);\n\t} else {\n\t\tdd_dev_warn(dd, \"%s: id %d, resource 0x%x: bit not set\\n\",\n\t\t\t    __func__, dd->hfi1_id, resource);\n\t}\n\n\trelease_hw_mutex(dd);\n\ndone:\n\tmutex_unlock(&dd->asic_data->asic_resource_mutex);\n}\n\n \nbool check_chip_resource(struct hfi1_devdata *dd, u32 resource,\n\t\t\t const char *func)\n{\n\tu64 scratch0, bit;\n\n\tif (resource & CR_DYN_MASK)\n\t\tbit = resource_mask(dd->hfi1_id, resource);\n\telse\n\t\tbit = resource;\n\n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tif ((scratch0 & bit) == 0) {\n\t\tif (func)\n\t\t\tdd_dev_warn(dd,\n\t\t\t\t    \"%s: id %d, resource 0x%x, not acquired!\\n\",\n\t\t\t\t    func, dd->hfi1_id, resource);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void clear_chip_resources(struct hfi1_devdata *dd, const char *func)\n{\n\tu64 scratch0;\n\n\t \n\tmutex_lock(&dd->asic_data->asic_resource_mutex);\n\n\tif (acquire_hw_mutex(dd)) {\n\t\tfail_mutex_acquire_message(dd, func);\n\t\tgoto done;\n\t}\n\n\t \n\tscratch0 = read_csr(dd, ASIC_CFG_SCRATCH);\n\tscratch0 &= ~resource_mask(dd->hfi1_id, CR_DYN_MASK);\n\twrite_csr(dd, ASIC_CFG_SCRATCH, scratch0);\n\t \n\t(void)read_csr(dd, ASIC_CFG_SCRATCH);\n\n\trelease_hw_mutex(dd);\n\ndone:\n\tmutex_unlock(&dd->asic_data->asic_resource_mutex);\n}\n\nvoid init_chip_resources(struct hfi1_devdata *dd)\n{\n\t \n\tclear_chip_resources(dd, __func__);\n}\n\nvoid finish_chip_resources(struct hfi1_devdata *dd)\n{\n\t \n\tclear_chip_resources(dd, __func__);\n}\n\nvoid set_sbus_fast_mode(struct hfi1_devdata *dd)\n{\n\twrite_csr(dd, ASIC_CFG_SBUS_EXECUTE,\n\t\t  ASIC_CFG_SBUS_EXECUTE_FAST_MODE_SMASK);\n}\n\nvoid clear_sbus_fast_mode(struct hfi1_devdata *dd)\n{\n\tu64 reg, count = 0;\n\n\treg = read_csr(dd, ASIC_STS_SBUS_COUNTERS);\n\twhile (SBUS_COUNTER(reg, EXECUTE) !=\n\t       SBUS_COUNTER(reg, RCV_DATA_VALID)) {\n\t\tif (count++ >= SBUS_MAX_POLL_COUNT)\n\t\t\tbreak;\n\t\tudelay(1);\n\t\treg = read_csr(dd, ASIC_STS_SBUS_COUNTERS);\n\t}\n\twrite_csr(dd, ASIC_CFG_SBUS_EXECUTE, 0);\n}\n\nint load_firmware(struct hfi1_devdata *dd)\n{\n\tint ret;\n\n\tif (fw_fabric_serdes_load) {\n\t\tret = acquire_chip_resource(dd, CR_SBUS, SBUS_TIMEOUT);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tset_sbus_fast_mode(dd);\n\n\t\tset_serdes_broadcast(dd, all_fabric_serdes_broadcast,\n\t\t\t\t     fabric_serdes_broadcast[dd->hfi1_id],\n\t\t\t\t     fabric_serdes_addrs[dd->hfi1_id],\n\t\t\t\t     NUM_FABRIC_SERDES);\n\t\tturn_off_spicos(dd, SPICO_FABRIC);\n\t\tdo {\n\t\t\tret = load_fabric_serdes_firmware(dd, &fw_fabric);\n\t\t} while (retry_firmware(dd, ret));\n\n\t\tclear_sbus_fast_mode(dd);\n\t\trelease_chip_resource(dd, CR_SBUS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (fw_8051_load) {\n\t\tdo {\n\t\t\tret = load_8051_firmware(dd, &fw_8051);\n\t\t} while (retry_firmware(dd, ret));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdump_fw_version(dd);\n\treturn 0;\n}\n\nint hfi1_firmware_init(struct hfi1_devdata *dd)\n{\n\t \n\tif (dd->icode != ICODE_RTL_SILICON) {\n\t\tfw_fabric_serdes_load = 0;\n\t\tfw_pcie_serdes_load = 0;\n\t\tfw_sbus_load = 0;\n\t}\n\n\t \n\tif (dd->icode == ICODE_FUNCTIONAL_SIMULATOR)\n\t\tfw_8051_load = 0;\n\n\tif (!fw_8051_name) {\n\t\tif (dd->icode == ICODE_RTL_SILICON)\n\t\t\tfw_8051_name = DEFAULT_FW_8051_NAME_ASIC;\n\t\telse\n\t\t\tfw_8051_name = DEFAULT_FW_8051_NAME_FPGA;\n\t}\n\tif (!fw_fabric_serdes_name)\n\t\tfw_fabric_serdes_name = DEFAULT_FW_FABRIC_NAME;\n\tif (!fw_sbus_name)\n\t\tfw_sbus_name = DEFAULT_FW_SBUS_NAME;\n\tif (!fw_pcie_serdes_name)\n\t\tfw_pcie_serdes_name = DEFAULT_FW_PCIE_NAME;\n\n\treturn obtain_firmware(dd);\n}\n\n \nstatic int check_meta_version(struct hfi1_devdata *dd, u32 *system_table)\n{\n\tu32 meta_ver, meta_ver_meta, ver_start, ver_len, mask;\n\tstruct platform_config_cache *pcfgcache = &dd->pcfg_cache;\n\n\tif (!system_table)\n\t\treturn -EINVAL;\n\n\tmeta_ver_meta =\n\t*(pcfgcache->config_tables[PLATFORM_CONFIG_SYSTEM_TABLE].table_metadata\n\t+ SYSTEM_TABLE_META_VERSION);\n\n\tmask = ((1 << METADATA_TABLE_FIELD_START_LEN_BITS) - 1);\n\tver_start = meta_ver_meta & mask;\n\n\tmeta_ver_meta >>= METADATA_TABLE_FIELD_LEN_SHIFT;\n\n\tmask = ((1 << METADATA_TABLE_FIELD_LEN_LEN_BITS) - 1);\n\tver_len = meta_ver_meta & mask;\n\n\tver_start /= 8;\n\tmeta_ver = *((u8 *)system_table + ver_start) & ((1 << ver_len) - 1);\n\n\tif (meta_ver < 4) {\n\t\tdd_dev_info(\n\t\t\tdd, \"%s:Please update platform config\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nint parse_platform_config(struct hfi1_devdata *dd)\n{\n\tstruct platform_config_cache *pcfgcache = &dd->pcfg_cache;\n\tstruct hfi1_pportdata *ppd = dd->pport;\n\tu32 *ptr = NULL;\n\tu32 header1 = 0, header2 = 0, magic_num = 0, crc = 0, file_length = 0;\n\tu32 record_idx = 0, table_type = 0, table_length_dwords = 0;\n\tint ret = -EINVAL;  \n\n\t \n\tif (ppd->config_from_scratch)\n\t\treturn 0;\n\n\tif (!dd->platform_config.data) {\n\t\tdd_dev_err(dd, \"%s: Missing config file\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tptr = (u32 *)dd->platform_config.data;\n\n\tmagic_num = *ptr;\n\tptr++;\n\tif (magic_num != PLATFORM_CONFIG_MAGIC_NUM) {\n\t\tdd_dev_err(dd, \"%s: Bad config file\\n\", __func__);\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tfile_length = (*ptr) * 4;\n\n\t \n\tif (file_length > MAX_PLATFORM_CONFIG_FILE_SIZE) {\n\t\tdd_dev_info(dd,\n\t\t\t    \"%s:File length out of bounds, using alternative format\\n\",\n\t\t\t    __func__);\n\t\tfile_length = PLATFORM_CONFIG_FORMAT_4_FILE_SIZE;\n\t} else {\n\t\tptr++;\n\t}\n\n\tif (file_length > dd->platform_config.size) {\n\t\tdd_dev_info(dd, \"%s:File claims to be larger than read size\\n\",\n\t\t\t    __func__);\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t} else if (file_length < dd->platform_config.size) {\n\t\tdd_dev_info(dd,\n\t\t\t    \"%s:File claims to be smaller than read size, continuing\\n\",\n\t\t\t    __func__);\n\t}\n\t \n\n\t \n\twhile (ptr < (u32 *)(dd->platform_config.data + file_length)) {\n\t\theader1 = *ptr;\n\t\theader2 = *(ptr + 1);\n\t\tif (header1 != ~header2) {\n\t\t\tdd_dev_err(dd, \"%s: Failed validation at offset %ld\\n\",\n\t\t\t\t   __func__, (ptr - (u32 *)\n\t\t\t\t\t      dd->platform_config.data));\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\trecord_idx = *ptr &\n\t\t\t((1 << PLATFORM_CONFIG_HEADER_RECORD_IDX_LEN_BITS) - 1);\n\n\t\ttable_length_dwords = (*ptr >>\n\t\t\t\tPLATFORM_CONFIG_HEADER_TABLE_LENGTH_SHIFT) &\n\t\t      ((1 << PLATFORM_CONFIG_HEADER_TABLE_LENGTH_LEN_BITS) - 1);\n\n\t\ttable_type = (*ptr >> PLATFORM_CONFIG_HEADER_TABLE_TYPE_SHIFT) &\n\t\t\t((1 << PLATFORM_CONFIG_HEADER_TABLE_TYPE_LEN_BITS) - 1);\n\n\t\t \n\t\tptr += 2;\n\n\t\tif (record_idx) {\n\t\t\t \n\t\t\tswitch (table_type) {\n\t\t\tcase PLATFORM_CONFIG_SYSTEM_TABLE:\n\t\t\t\tpcfgcache->config_tables[table_type].num_table =\n\t\t\t\t\t\t\t\t\t1;\n\t\t\t\tret = check_meta_version(dd, ptr);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto bail;\n\t\t\t\tbreak;\n\t\t\tcase PLATFORM_CONFIG_PORT_TABLE:\n\t\t\t\tpcfgcache->config_tables[table_type].num_table =\n\t\t\t\t\t\t\t\t\t2;\n\t\t\t\tbreak;\n\t\t\tcase PLATFORM_CONFIG_RX_PRESET_TABLE:\n\t\t\tcase PLATFORM_CONFIG_TX_PRESET_TABLE:\n\t\t\tcase PLATFORM_CONFIG_QSFP_ATTEN_TABLE:\n\t\t\tcase PLATFORM_CONFIG_VARIABLE_SETTINGS_TABLE:\n\t\t\t\tpcfgcache->config_tables[table_type].num_table =\n\t\t\t\t\t\t\ttable_length_dwords;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdd_dev_err(dd,\n\t\t\t\t\t   \"%s: Unknown data table %d, offset %ld\\n\",\n\t\t\t\t\t   __func__, table_type,\n\t\t\t\t\t   (ptr - (u32 *)\n\t\t\t\t\t    dd->platform_config.data));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto bail;  \n\t\t\t}\n\t\t\tpcfgcache->config_tables[table_type].table = ptr;\n\t\t} else {\n\t\t\t \n\t\t\tswitch (table_type) {\n\t\t\tcase PLATFORM_CONFIG_SYSTEM_TABLE:\n\t\t\tcase PLATFORM_CONFIG_PORT_TABLE:\n\t\t\tcase PLATFORM_CONFIG_RX_PRESET_TABLE:\n\t\t\tcase PLATFORM_CONFIG_TX_PRESET_TABLE:\n\t\t\tcase PLATFORM_CONFIG_QSFP_ATTEN_TABLE:\n\t\t\tcase PLATFORM_CONFIG_VARIABLE_SETTINGS_TABLE:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdd_dev_err(dd,\n\t\t\t\t\t   \"%s: Unknown meta table %d, offset %ld\\n\",\n\t\t\t\t\t   __func__, table_type,\n\t\t\t\t\t   (ptr -\n\t\t\t\t\t    (u32 *)dd->platform_config.data));\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto bail;  \n\t\t\t}\n\t\t\tpcfgcache->config_tables[table_type].table_metadata =\n\t\t\t\t\t\t\t\t\tptr;\n\t\t}\n\n\t\t \n\t\tcrc = crc32_le(~(u32)0, (unsigned char const *)ptr,\n\t\t\t       (table_length_dwords * 4));\n\t\tcrc ^= ~(u32)0;\n\n\t\t \n\t\tptr += table_length_dwords;\n\t\tif (crc != *ptr) {\n\t\t\tdd_dev_err(dd, \"%s: Failed CRC check at offset %ld\\n\",\n\t\t\t\t   __func__, (ptr -\n\t\t\t\t   (u32 *)dd->platform_config.data));\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tptr++;\n\t}\n\n\tpcfgcache->cache_valid = 1;\n\treturn 0;\nbail:\n\tmemset(pcfgcache, 0, sizeof(struct platform_config_cache));\n\treturn ret;\n}\n\nstatic void get_integrated_platform_config_field(\n\t\tstruct hfi1_devdata *dd,\n\t\tenum platform_config_table_type_encoding table_type,\n\t\tint field_index, u32 *data)\n{\n\tstruct hfi1_pportdata *ppd = dd->pport;\n\tu8 *cache = ppd->qsfp_info.cache;\n\tu32 tx_preset = 0;\n\n\tswitch (table_type) {\n\tcase PLATFORM_CONFIG_SYSTEM_TABLE:\n\t\tif (field_index == SYSTEM_TABLE_QSFP_POWER_CLASS_MAX)\n\t\t\t*data = ppd->max_power_class;\n\t\telse if (field_index == SYSTEM_TABLE_QSFP_ATTENUATION_DEFAULT_25G)\n\t\t\t*data = ppd->default_atten;\n\t\tbreak;\n\tcase PLATFORM_CONFIG_PORT_TABLE:\n\t\tif (field_index == PORT_TABLE_PORT_TYPE)\n\t\t\t*data = ppd->port_type;\n\t\telse if (field_index == PORT_TABLE_LOCAL_ATTEN_25G)\n\t\t\t*data = ppd->local_atten;\n\t\telse if (field_index == PORT_TABLE_REMOTE_ATTEN_25G)\n\t\t\t*data = ppd->remote_atten;\n\t\tbreak;\n\tcase PLATFORM_CONFIG_RX_PRESET_TABLE:\n\t\tif (field_index == RX_PRESET_TABLE_QSFP_RX_CDR_APPLY)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_CDR_APPLY_SMASK) >>\n\t\t\t\tQSFP_RX_CDR_APPLY_SHIFT;\n\t\telse if (field_index == RX_PRESET_TABLE_QSFP_RX_EMP_APPLY)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_EMP_APPLY_SMASK) >>\n\t\t\t\tQSFP_RX_EMP_APPLY_SHIFT;\n\t\telse if (field_index == RX_PRESET_TABLE_QSFP_RX_AMP_APPLY)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_AMP_APPLY_SMASK) >>\n\t\t\t\tQSFP_RX_AMP_APPLY_SHIFT;\n\t\telse if (field_index == RX_PRESET_TABLE_QSFP_RX_CDR)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_CDR_SMASK) >>\n\t\t\t\tQSFP_RX_CDR_SHIFT;\n\t\telse if (field_index == RX_PRESET_TABLE_QSFP_RX_EMP)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_EMP_SMASK) >>\n\t\t\t\tQSFP_RX_EMP_SHIFT;\n\t\telse if (field_index == RX_PRESET_TABLE_QSFP_RX_AMP)\n\t\t\t*data = (ppd->rx_preset & QSFP_RX_AMP_SMASK) >>\n\t\t\t\tQSFP_RX_AMP_SHIFT;\n\t\tbreak;\n\tcase PLATFORM_CONFIG_TX_PRESET_TABLE:\n\t\tif (cache[QSFP_EQ_INFO_OFFS] & 0x4)\n\t\t\ttx_preset = ppd->tx_preset_eq;\n\t\telse\n\t\t\ttx_preset = ppd->tx_preset_noeq;\n\t\tif (field_index == TX_PRESET_TABLE_PRECUR)\n\t\t\t*data = (tx_preset & TX_PRECUR_SMASK) >>\n\t\t\t\tTX_PRECUR_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_ATTN)\n\t\t\t*data = (tx_preset & TX_ATTN_SMASK) >>\n\t\t\t\tTX_ATTN_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_POSTCUR)\n\t\t\t*data = (tx_preset & TX_POSTCUR_SMASK) >>\n\t\t\t\tTX_POSTCUR_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_QSFP_TX_CDR_APPLY)\n\t\t\t*data = (tx_preset & QSFP_TX_CDR_APPLY_SMASK) >>\n\t\t\t\tQSFP_TX_CDR_APPLY_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_QSFP_TX_EQ_APPLY)\n\t\t\t*data = (tx_preset & QSFP_TX_EQ_APPLY_SMASK) >>\n\t\t\t\tQSFP_TX_EQ_APPLY_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_QSFP_TX_CDR)\n\t\t\t*data = (tx_preset & QSFP_TX_CDR_SMASK) >>\n\t\t\t\tQSFP_TX_CDR_SHIFT;\n\t\telse if (field_index == TX_PRESET_TABLE_QSFP_TX_EQ)\n\t\t\t*data = (tx_preset & QSFP_TX_EQ_SMASK) >>\n\t\t\t\tQSFP_TX_EQ_SHIFT;\n\t\tbreak;\n\tcase PLATFORM_CONFIG_QSFP_ATTEN_TABLE:\n\tcase PLATFORM_CONFIG_VARIABLE_SETTINGS_TABLE:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int get_platform_fw_field_metadata(struct hfi1_devdata *dd, int table,\n\t\t\t\t\t  int field, u32 *field_len_bits,\n\t\t\t\t\t  u32 *field_start_bits)\n{\n\tstruct platform_config_cache *pcfgcache = &dd->pcfg_cache;\n\tu32 *src_ptr = NULL;\n\n\tif (!pcfgcache->cache_valid)\n\t\treturn -EINVAL;\n\n\tswitch (table) {\n\tcase PLATFORM_CONFIG_SYSTEM_TABLE:\n\tcase PLATFORM_CONFIG_PORT_TABLE:\n\tcase PLATFORM_CONFIG_RX_PRESET_TABLE:\n\tcase PLATFORM_CONFIG_TX_PRESET_TABLE:\n\tcase PLATFORM_CONFIG_QSFP_ATTEN_TABLE:\n\tcase PLATFORM_CONFIG_VARIABLE_SETTINGS_TABLE:\n\t\tif (field && field < platform_config_table_limits[table])\n\t\t\tsrc_ptr =\n\t\t\tpcfgcache->config_tables[table].table_metadata + field;\n\t\tbreak;\n\tdefault:\n\t\tdd_dev_info(dd, \"%s: Unknown table\\n\", __func__);\n\t\tbreak;\n\t}\n\n\tif (!src_ptr)\n\t\treturn -EINVAL;\n\n\tif (field_start_bits)\n\t\t*field_start_bits = *src_ptr &\n\t\t      ((1 << METADATA_TABLE_FIELD_START_LEN_BITS) - 1);\n\n\tif (field_len_bits)\n\t\t*field_len_bits = (*src_ptr >> METADATA_TABLE_FIELD_LEN_SHIFT)\n\t\t       & ((1 << METADATA_TABLE_FIELD_LEN_LEN_BITS) - 1);\n\n\treturn 0;\n}\n\n \nint get_platform_config_field(struct hfi1_devdata *dd,\n\t\t\t      enum platform_config_table_type_encoding\n\t\t\t      table_type, int table_index, int field_index,\n\t\t\t      u32 *data, u32 len)\n{\n\tint ret = 0, wlen = 0, seek = 0;\n\tu32 field_len_bits = 0, field_start_bits = 0, *src_ptr = NULL;\n\tstruct platform_config_cache *pcfgcache = &dd->pcfg_cache;\n\tstruct hfi1_pportdata *ppd = dd->pport;\n\n\tif (data)\n\t\tmemset(data, 0, len);\n\telse\n\t\treturn -EINVAL;\n\n\tif (ppd->config_from_scratch) {\n\t\t \n\t\tget_integrated_platform_config_field(dd, table_type,\n\t\t\t\t\t\t     field_index, data);\n\t\treturn 0;\n\t}\n\n\tret = get_platform_fw_field_metadata(dd, table_type, field_index,\n\t\t\t\t\t     &field_len_bits,\n\t\t\t\t\t     &field_start_bits);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tlen *= 8;\n\n\t \n\tswitch (table_type) {\n\tcase PLATFORM_CONFIG_SYSTEM_TABLE:\n\t\tsrc_ptr = pcfgcache->config_tables[table_type].table;\n\n\t\tif (field_index != SYSTEM_TABLE_QSFP_POWER_CLASS_MAX) {\n\t\t\tif (len < field_len_bits)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tseek = field_start_bits / 8;\n\t\t\twlen = field_len_bits / 8;\n\n\t\t\tsrc_ptr = (u32 *)((u8 *)src_ptr + seek);\n\n\t\t\t \n\t\t\tmemcpy(data, src_ptr, wlen);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase PLATFORM_CONFIG_PORT_TABLE:\n\t\t \n\t\tsrc_ptr = dd->hfi1_id ?\n\t\t\tpcfgcache->config_tables[table_type].table + 4 :\n\t\t\tpcfgcache->config_tables[table_type].table;\n\t\tbreak;\n\tcase PLATFORM_CONFIG_RX_PRESET_TABLE:\n\tcase PLATFORM_CONFIG_TX_PRESET_TABLE:\n\tcase PLATFORM_CONFIG_QSFP_ATTEN_TABLE:\n\tcase PLATFORM_CONFIG_VARIABLE_SETTINGS_TABLE:\n\t\tsrc_ptr = pcfgcache->config_tables[table_type].table;\n\n\t\tif (table_index <\n\t\t\tpcfgcache->config_tables[table_type].num_table)\n\t\t\tsrc_ptr += table_index;\n\t\telse\n\t\t\tsrc_ptr = NULL;\n\t\tbreak;\n\tdefault:\n\t\tdd_dev_info(dd, \"%s: Unknown table\\n\", __func__);\n\t\tbreak;\n\t}\n\n\tif (!src_ptr || len < field_len_bits)\n\t\treturn -EINVAL;\n\n\tsrc_ptr += (field_start_bits / 32);\n\t*data = (*src_ptr >> (field_start_bits % 32)) &\n\t\t\t((1 << field_len_bits) - 1);\n\n\treturn 0;\n}\n\n \nint load_pcie_firmware(struct hfi1_devdata *dd)\n{\n\tint ret = 0;\n\n\t \n\tset_sbus_fast_mode(dd);\n\n\tif (fw_sbus_load) {\n\t\tturn_off_spicos(dd, SPICO_SBUS);\n\t\tdo {\n\t\t\tret = load_sbus_firmware(dd, &fw_sbus);\n\t\t} while (retry_firmware(dd, ret));\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tif (fw_pcie_serdes_load) {\n\t\tdd_dev_info(dd, \"Setting PCIe SerDes broadcast\\n\");\n\t\tset_serdes_broadcast(dd, all_pcie_serdes_broadcast,\n\t\t\t\t     pcie_serdes_broadcast[dd->hfi1_id],\n\t\t\t\t     pcie_serdes_addrs[dd->hfi1_id],\n\t\t\t\t     NUM_PCIE_SERDES);\n\t\tdo {\n\t\t\tret = load_pcie_serdes_firmware(dd, &fw_pcie);\n\t\t} while (retry_firmware(dd, ret));\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tclear_sbus_fast_mode(dd);\n\n\treturn ret;\n}\n\n \nvoid read_guid(struct hfi1_devdata *dd)\n{\n\t \n\twrite_csr(dd, CCE_DC_CTRL, 0);\n\t(void)read_csr(dd, CCE_DC_CTRL);\n\n\tdd->base_guid = read_csr(dd, DC_DC8051_CFG_LOCAL_GUID);\n\tdd_dev_info(dd, \"GUID %llx\",\n\t\t    (unsigned long long)dd->base_guid);\n}\n\n \nstatic void dump_fw_version(struct hfi1_devdata *dd)\n{\n\tu32 pcie_vers[NUM_PCIE_SERDES];\n\tu32 fabric_vers[NUM_FABRIC_SERDES];\n\tu32 sbus_vers;\n\tint i;\n\tint all_same;\n\tint ret;\n\tu8 rcv_addr;\n\n\tret = acquire_chip_resource(dd, CR_SBUS, SBUS_TIMEOUT);\n\tif (ret) {\n\t\tdd_dev_err(dd, \"Unable to acquire SBus to read firmware versions\\n\");\n\t\treturn;\n\t}\n\n\t \n\tset_sbus_fast_mode(dd);\n\n\t \n\tsbus_request(dd, SBUS_MASTER_BROADCAST, 0x02, WRITE_SBUS_RECEIVER, 0);\n\tsbus_request(dd, SBUS_MASTER_BROADCAST, 0x07, WRITE_SBUS_RECEIVER, 0x1);\n\t \n\tusleep_range(10000, 11000);\n\tsbus_vers = sbus_read(dd, SBUS_MASTER_BROADCAST, 0x08, 0x1);\n\tdd_dev_info(dd, \"SBus Master firmware version 0x%08x\\n\", sbus_vers);\n\n\t \n\tall_same = 1;\n\tpcie_vers[0] = 0;\n\tfor (i = 0; i < NUM_PCIE_SERDES; i++) {\n\t\trcv_addr = pcie_serdes_addrs[dd->hfi1_id][i];\n\t\tsbus_request(dd, rcv_addr, 0x03, WRITE_SBUS_RECEIVER, 0);\n\t\t \n\t\tusleep_range(10000, 11000);\n\t\tpcie_vers[i] = sbus_read(dd, rcv_addr, 0x04, 0x0);\n\t\tif (i > 0 && pcie_vers[0] != pcie_vers[i])\n\t\t\tall_same = 0;\n\t}\n\n\tif (all_same) {\n\t\tdd_dev_info(dd, \"PCIe SerDes firmware version 0x%x\\n\",\n\t\t\t    pcie_vers[0]);\n\t} else {\n\t\tdd_dev_warn(dd, \"PCIe SerDes do not have the same firmware version\\n\");\n\t\tfor (i = 0; i < NUM_PCIE_SERDES; i++) {\n\t\t\tdd_dev_info(dd,\n\t\t\t\t    \"PCIe SerDes lane %d firmware version 0x%x\\n\",\n\t\t\t\t    i, pcie_vers[i]);\n\t\t}\n\t}\n\n\t \n\tall_same = 1;\n\tfabric_vers[0] = 0;\n\tfor (i = 0; i < NUM_FABRIC_SERDES; i++) {\n\t\trcv_addr = fabric_serdes_addrs[dd->hfi1_id][i];\n\t\tsbus_request(dd, rcv_addr, 0x03, WRITE_SBUS_RECEIVER, 0);\n\t\t \n\t\tusleep_range(10000, 11000);\n\t\tfabric_vers[i] = sbus_read(dd, rcv_addr, 0x04, 0x0);\n\t\tif (i > 0 && fabric_vers[0] != fabric_vers[i])\n\t\t\tall_same = 0;\n\t}\n\n\tif (all_same) {\n\t\tdd_dev_info(dd, \"Fabric SerDes firmware version 0x%x\\n\",\n\t\t\t    fabric_vers[0]);\n\t} else {\n\t\tdd_dev_warn(dd, \"Fabric SerDes do not have the same firmware version\\n\");\n\t\tfor (i = 0; i < NUM_FABRIC_SERDES; i++) {\n\t\t\tdd_dev_info(dd,\n\t\t\t\t    \"Fabric SerDes lane %d firmware version 0x%x\\n\",\n\t\t\t\t    i, fabric_vers[i]);\n\t\t}\n\t}\n\n\tclear_sbus_fast_mode(dd);\n\trelease_chip_resource(dd, CR_SBUS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}