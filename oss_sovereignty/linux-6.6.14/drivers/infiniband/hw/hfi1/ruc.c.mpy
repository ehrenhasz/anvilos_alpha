{
  "module_name": "ruc.c",
  "hash_id": "8f41f0e37b1ccbdc843adf4d176f1789be49a2c6077704cb475a8691e1c406ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hfi1/ruc.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n\n#include \"hfi.h\"\n#include \"mad.h\"\n#include \"qp.h\"\n#include \"verbs_txreq.h\"\n#include \"trace.h\"\n\nstatic int gid_ok(union ib_gid *gid, __be64 gid_prefix, __be64 id)\n{\n\treturn (gid->global.interface_id == id &&\n\t\t(gid->global.subnet_prefix == gid_prefix ||\n\t\t gid->global.subnet_prefix == IB_DEFAULT_GID_PREFIX));\n}\n\n \nint hfi1_ruc_check_hdr(struct hfi1_ibport *ibp, struct hfi1_packet *packet)\n{\n\t__be64 guid;\n\tunsigned long flags;\n\tstruct rvt_qp *qp = packet->qp;\n\tu8 sc5 = ibp->sl_to_sc[rdma_ah_get_sl(&qp->remote_ah_attr)];\n\tu32 dlid = packet->dlid;\n\tu32 slid = packet->slid;\n\tu32 sl = packet->sl;\n\tbool migrated = packet->migrated;\n\tu16 pkey = packet->pkey;\n\n\tif (qp->s_mig_state == IB_MIG_ARMED && migrated) {\n\t\tif (!packet->grh) {\n\t\t\tif ((rdma_ah_get_ah_flags(&qp->alt_ah_attr) &\n\t\t\t     IB_AH_GRH) &&\n\t\t\t    (packet->etype != RHF_RCV_TYPE_BYPASS))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tconst struct ib_global_route *grh;\n\n\t\t\tif (!(rdma_ah_get_ah_flags(&qp->alt_ah_attr) &\n\t\t\t      IB_AH_GRH))\n\t\t\t\treturn 1;\n\t\t\tgrh = rdma_ah_read_grh(&qp->alt_ah_attr);\n\t\t\tguid = get_sguid(ibp, grh->sgid_index);\n\t\t\tif (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,\n\t\t\t\t    guid))\n\t\t\t\treturn 1;\n\t\t\tif (!gid_ok(\n\t\t\t\t&packet->grh->sgid,\n\t\t\t\tgrh->dgid.global.subnet_prefix,\n\t\t\t\tgrh->dgid.global.interface_id))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), pkey,\n\t\t\t\t\t    sc5, slid))) {\n\t\t\thfi1_bad_pkey(ibp, pkey, sl, 0, qp->ibqp.qp_num,\n\t\t\t\t      slid, dlid);\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tif (slid != rdma_ah_get_dlid(&qp->alt_ah_attr) ||\n\t\t    ppd_from_ibp(ibp)->port !=\n\t\t\trdma_ah_get_port_num(&qp->alt_ah_attr))\n\t\t\treturn 1;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\thfi1_migrate_qp(qp);\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t} else {\n\t\tif (!packet->grh) {\n\t\t\tif ((rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t\t     IB_AH_GRH) &&\n\t\t\t    (packet->etype != RHF_RCV_TYPE_BYPASS))\n\t\t\t\treturn 1;\n\t\t} else {\n\t\t\tconst struct ib_global_route *grh;\n\n\t\t\tif (!(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t\t\t\t\t   IB_AH_GRH))\n\t\t\t\treturn 1;\n\t\t\tgrh = rdma_ah_read_grh(&qp->remote_ah_attr);\n\t\t\tguid = get_sguid(ibp, grh->sgid_index);\n\t\t\tif (!gid_ok(&packet->grh->dgid, ibp->rvp.gid_prefix,\n\t\t\t\t    guid))\n\t\t\t\treturn 1;\n\t\t\tif (!gid_ok(\n\t\t\t     &packet->grh->sgid,\n\t\t\t     grh->dgid.global.subnet_prefix,\n\t\t\t     grh->dgid.global.interface_id))\n\t\t\t\treturn 1;\n\t\t}\n\t\tif (unlikely(rcv_pkey_check(ppd_from_ibp(ibp), pkey,\n\t\t\t\t\t    sc5, slid))) {\n\t\t\thfi1_bad_pkey(ibp, pkey, sl, 0, qp->ibqp.qp_num,\n\t\t\t\t      slid, dlid);\n\t\t\treturn 1;\n\t\t}\n\t\t \n\t\tif ((slid != rdma_ah_get_dlid(&qp->remote_ah_attr)) ||\n\t\t    ppd_from_ibp(ibp)->port != qp->port_num)\n\t\t\treturn 1;\n\t\tif (qp->s_mig_state == IB_MIG_REARM && !migrated)\n\t\t\tqp->s_mig_state = IB_MIG_ARMED;\n\t}\n\n\treturn 0;\n}\n\n \nu32 hfi1_make_grh(struct hfi1_ibport *ibp, struct ib_grh *hdr,\n\t\t  const struct ib_global_route *grh, u32 hwords, u32 nwords)\n{\n\thdr->version_tclass_flow =\n\t\tcpu_to_be32((IB_GRH_VERSION << IB_GRH_VERSION_SHIFT) |\n\t\t\t    (grh->traffic_class << IB_GRH_TCLASS_SHIFT) |\n\t\t\t    (grh->flow_label << IB_GRH_FLOW_SHIFT));\n\thdr->paylen = cpu_to_be16((hwords + nwords) << 2);\n\t \n\thdr->next_hdr = IB_GRH_NEXT_HDR;\n\thdr->hop_limit = grh->hop_limit;\n\t \n\thdr->sgid.global.subnet_prefix = ibp->rvp.gid_prefix;\n\thdr->sgid.global.interface_id =\n\t\tgrh->sgid_index < HFI1_GUIDS_PER_PORT ?\n\t\tget_sguid(ibp, grh->sgid_index) :\n\t\tget_sguid(ibp, HFI1_PORT_GUID_INDEX);\n\thdr->dgid = grh->dgid;\n\n\t \n\treturn sizeof(struct ib_grh) / sizeof(u32);\n}\n\n#define BTH2_OFFSET (offsetof(struct hfi1_sdma_header, \\\n\t\t\t      hdr.ibh.u.oth.bth[2]) / 4)\n\n \nstatic inline void build_ahg(struct rvt_qp *qp, u32 npsn)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\tif (unlikely(qp->s_flags & HFI1_S_AHG_CLEAR))\n\t\tclear_ahg(qp);\n\tif (!(qp->s_flags & HFI1_S_AHG_VALID)) {\n\t\t \n\t\tif (qp->s_ahgidx < 0)\n\t\t\tqp->s_ahgidx = sdma_ahg_alloc(priv->s_sde);\n\t\tif (qp->s_ahgidx >= 0) {\n\t\t\tqp->s_ahgpsn = npsn;\n\t\t\tpriv->s_ahg->tx_flags |= SDMA_TXREQ_F_AHG_COPY;\n\t\t\t \n\t\t\tpriv->s_ahg->ahgidx = qp->s_ahgidx;\n\t\t\tqp->s_flags |= HFI1_S_AHG_VALID;\n\t\t}\n\t} else {\n\t\t \n\t\tif (qp->s_ahgidx >= 0) {\n\t\t\tpriv->s_ahg->tx_flags |= SDMA_TXREQ_F_USE_AHG;\n\t\t\tpriv->s_ahg->ahgidx = qp->s_ahgidx;\n\t\t\tpriv->s_ahg->ahgcount++;\n\t\t\tpriv->s_ahg->ahgdesc[0] =\n\t\t\t\tsdma_build_ahg_descriptor(\n\t\t\t\t\t(__force u16)cpu_to_be16((u16)npsn),\n\t\t\t\t\tBTH2_OFFSET,\n\t\t\t\t\t16,\n\t\t\t\t\t16);\n\t\t\tif ((npsn & 0xffff0000) !=\n\t\t\t\t\t(qp->s_ahgpsn & 0xffff0000)) {\n\t\t\t\tpriv->s_ahg->ahgcount++;\n\t\t\t\tpriv->s_ahg->ahgdesc[1] =\n\t\t\t\t\tsdma_build_ahg_descriptor(\n\t\t\t\t\t\t(__force u16)cpu_to_be16(\n\t\t\t\t\t\t\t(u16)(npsn >> 16)),\n\t\t\t\t\t\tBTH2_OFFSET,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t16);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic inline void hfi1_make_ruc_bth(struct rvt_qp *qp,\n\t\t\t\t     struct ib_other_headers *ohdr,\n\t\t\t\t     u32 bth0, u32 bth1, u32 bth2)\n{\n\tohdr->bth[0] = cpu_to_be32(bth0);\n\tohdr->bth[1] = cpu_to_be32(bth1);\n\tohdr->bth[2] = cpu_to_be32(bth2);\n}\n\n \nstatic inline void hfi1_make_ruc_header_16B(struct rvt_qp *qp,\n\t\t\t\t\t    struct ib_other_headers *ohdr,\n\t\t\t\t\t    u32 bth0, u32 bth1, u32 bth2,\n\t\t\t\t\t    int middle,\n\t\t\t\t\t    struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_ibport *ibp = ps->ibp;\n\tstruct hfi1_pportdata *ppd = ppd_from_ibp(ibp);\n\tu32 slid;\n\tu16 pkey = hfi1_get_pkey(ibp, qp->s_pkey_index);\n\tu8 l4 = OPA_16B_L4_IB_LOCAL;\n\tu8 extra_bytes = hfi1_get_16b_padding(\n\t\t\t\t(ps->s_txreq->hdr_dwords << 2),\n\t\t\t\tps->s_txreq->s_cur_size);\n\tu32 nwords = SIZE_OF_CRC + ((ps->s_txreq->s_cur_size +\n\t\t\t\t extra_bytes + SIZE_OF_LT) >> 2);\n\tbool becn = false;\n\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH) &&\n\t    hfi1_check_mcast(rdma_ah_get_dlid(&qp->remote_ah_attr))) {\n\t\tstruct ib_grh *grh;\n\t\tstruct ib_global_route *grd =\n\t\t\trdma_ah_retrieve_grh(&qp->remote_ah_attr);\n\t\t \n\t\tif (grd->sgid_index == OPA_GID_INDEX)\n\t\t\tgrd->sgid_index = 0;\n\t\tgrh = &ps->s_txreq->phdr.hdr.opah.u.l.grh;\n\t\tl4 = OPA_16B_L4_IB_GLOBAL;\n\t\tps->s_txreq->hdr_dwords +=\n\t\t\thfi1_make_grh(ibp, grh, grd,\n\t\t\t\t      ps->s_txreq->hdr_dwords - LRH_16B_DWORDS,\n\t\t\t\t      nwords);\n\t\tmiddle = 0;\n\t}\n\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth1 |= OPA_BTH_MIG_REQ;\n\telse\n\t\tmiddle = 0;\n\n\tif (qp->s_flags & RVT_S_ECN) {\n\t\tqp->s_flags &= ~RVT_S_ECN;\n\t\t \n\t\tbecn = true;\n\t\tmiddle = 0;\n\t}\n\tif (middle)\n\t\tbuild_ahg(qp, bth2);\n\telse\n\t\tqp->s_flags &= ~HFI1_S_AHG_VALID;\n\n\tbth0 |= pkey;\n\tbth0 |= extra_bytes << 20;\n\thfi1_make_ruc_bth(qp, ohdr, bth0, bth1, bth2);\n\n\tif (!ppd->lid)\n\t\tslid = be32_to_cpu(OPA_LID_PERMISSIVE);\n\telse\n\t\tslid = ppd->lid |\n\t\t\t(rdma_ah_get_path_bits(&qp->remote_ah_attr) &\n\t\t\t((1 << ppd->lmc) - 1));\n\n\thfi1_make_16b_hdr(&ps->s_txreq->phdr.hdr.opah,\n\t\t\t  slid,\n\t\t\t  opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr),\n\t\t\t\t      16B),\n\t\t\t  (ps->s_txreq->hdr_dwords + nwords) >> 1,\n\t\t\t  pkey, becn, 0, l4, priv->s_sc);\n}\n\n \nstatic inline void hfi1_make_ruc_header_9B(struct rvt_qp *qp,\n\t\t\t\t\t   struct ib_other_headers *ohdr,\n\t\t\t\t\t   u32 bth0, u32 bth1, u32 bth2,\n\t\t\t\t\t   int middle,\n\t\t\t\t\t   struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tstruct hfi1_ibport *ibp = ps->ibp;\n\tu16 pkey = hfi1_get_pkey(ibp, qp->s_pkey_index);\n\tu16 lrh0 = HFI1_LRH_BTH;\n\tu8 extra_bytes = -ps->s_txreq->s_cur_size & 3;\n\tu32 nwords = SIZE_OF_CRC + ((ps->s_txreq->s_cur_size +\n\t\t\t\t\t extra_bytes) >> 2);\n\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {\n\t\tstruct ib_grh *grh = &ps->s_txreq->phdr.hdr.ibh.u.l.grh;\n\n\t\tlrh0 = HFI1_LRH_GRH;\n\t\tps->s_txreq->hdr_dwords +=\n\t\t\thfi1_make_grh(ibp, grh,\n\t\t\t\t      rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t      ps->s_txreq->hdr_dwords - LRH_9B_DWORDS,\n\t\t\t\t      nwords);\n\t\tmiddle = 0;\n\t}\n\tlrh0 |= (priv->s_sc & 0xf) << 12 |\n\t\t(rdma_ah_get_sl(&qp->remote_ah_attr) & 0xf) << 4;\n\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth0 |= IB_BTH_MIG_REQ;\n\telse\n\t\tmiddle = 0;\n\n\tif (qp->s_flags & RVT_S_ECN) {\n\t\tqp->s_flags &= ~RVT_S_ECN;\n\t\t \n\t\tbth1 |= (IB_BECN_MASK << IB_BECN_SHIFT);\n\t\tmiddle = 0;\n\t}\n\tif (middle)\n\t\tbuild_ahg(qp, bth2);\n\telse\n\t\tqp->s_flags &= ~HFI1_S_AHG_VALID;\n\n\tbth0 |= pkey;\n\tbth0 |= extra_bytes << 20;\n\thfi1_make_ruc_bth(qp, ohdr, bth0, bth1, bth2);\n\thfi1_make_ib_hdr(&ps->s_txreq->phdr.hdr.ibh,\n\t\t\t lrh0,\n\t\t\t ps->s_txreq->hdr_dwords + nwords,\n\t\t\t opa_get_lid(rdma_ah_get_dlid(&qp->remote_ah_attr), 9B),\n\t\t\t ppd_from_ibp(ibp)->lid |\n\t\t\t\trdma_ah_get_path_bits(&qp->remote_ah_attr));\n}\n\ntypedef void (*hfi1_make_ruc_hdr)(struct rvt_qp *qp,\n\t\t\t\t  struct ib_other_headers *ohdr,\n\t\t\t\t  u32 bth0, u32 bth1, u32 bth2, int middle,\n\t\t\t\t  struct hfi1_pkt_state *ps);\n\n \nstatic const hfi1_make_ruc_hdr hfi1_ruc_header_tbl[2] = {\n\t[HFI1_PKT_TYPE_9B] = &hfi1_make_ruc_header_9B,\n\t[HFI1_PKT_TYPE_16B] = &hfi1_make_ruc_header_16B\n};\n\nvoid hfi1_make_ruc_header(struct rvt_qp *qp, struct ib_other_headers *ohdr,\n\t\t\t  u32 bth0, u32 bth1, u32 bth2, int middle,\n\t\t\t  struct hfi1_pkt_state *ps)\n{\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\t \n\tpriv->s_ahg->tx_flags = 0;\n\tpriv->s_ahg->ahgcount = 0;\n\tpriv->s_ahg->ahgidx = 0;\n\n\t \n\thfi1_ruc_header_tbl[priv->hdr_type](qp, ohdr, bth0, bth1, bth2, middle,\n\t\t\t\t\t    ps);\n}\n\n \n#define SEND_RESCHED_TIMEOUT (5 * HZ)   \n\n \nbool hfi1_schedule_send_yield(struct rvt_qp *qp, struct hfi1_pkt_state *ps,\n\t\t\t      bool tid)\n{\n\tps->pkts_sent = true;\n\n\tif (unlikely(time_after(jiffies, ps->timeout))) {\n\t\tif (!ps->in_thread ||\n\t\t    workqueue_congested(ps->cpu, ps->ppd->hfi1_wq)) {\n\t\t\tspin_lock_irqsave(&qp->s_lock, ps->flags);\n\t\t\tif (!tid) {\n\t\t\t\tqp->s_flags &= ~RVT_S_BUSY;\n\t\t\t\thfi1_schedule_send(qp);\n\t\t\t} else {\n\t\t\t\tstruct hfi1_qp_priv *priv = qp->priv;\n\n\t\t\t\tif (priv->s_flags &\n\t\t\t\t    HFI1_S_TID_BUSY_SET) {\n\t\t\t\t\tqp->s_flags &= ~RVT_S_BUSY;\n\t\t\t\t\tpriv->s_flags &=\n\t\t\t\t\t\t~(HFI1_S_TID_BUSY_SET |\n\t\t\t\t\t\t  RVT_S_BUSY);\n\t\t\t\t} else {\n\t\t\t\t\tpriv->s_flags &= ~RVT_S_BUSY;\n\t\t\t\t}\n\t\t\t\thfi1_schedule_tid_send(qp);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, ps->flags);\n\t\t\tthis_cpu_inc(*ps->ppd->dd->send_schedule);\n\t\t\ttrace_hfi1_rc_expired_time_slice(qp, true);\n\t\t\treturn true;\n\t\t}\n\n\t\tcond_resched();\n\t\tthis_cpu_inc(*ps->ppd->dd->send_schedule);\n\t\tps->timeout = jiffies + ps->timeout_int;\n\t}\n\n\ttrace_hfi1_rc_expired_time_slice(qp, false);\n\treturn false;\n}\n\nvoid hfi1_do_send_from_rvt(struct rvt_qp *qp)\n{\n\thfi1_do_send(qp, false);\n}\n\nvoid _hfi1_do_send(struct work_struct *work)\n{\n\tstruct iowait_work *w = container_of(work, struct iowait_work, iowork);\n\tstruct rvt_qp *qp = iowait_to_qp(w->iow);\n\n\thfi1_do_send(qp, true);\n}\n\n \nvoid hfi1_do_send(struct rvt_qp *qp, bool in_thread)\n{\n\tstruct hfi1_pkt_state ps;\n\tstruct hfi1_qp_priv *priv = qp->priv;\n\tint (*make_req)(struct rvt_qp *qp, struct hfi1_pkt_state *ps);\n\n\tps.dev = to_idev(qp->ibqp.device);\n\tps.ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tps.ppd = ppd_from_ibp(ps.ibp);\n\tps.in_thread = in_thread;\n\tps.wait = iowait_get_ib_work(&priv->s_iowait);\n\n\ttrace_hfi1_rc_do_send(qp, in_thread);\n\n\tswitch (qp->ibqp.qp_type) {\n\tcase IB_QPT_RC:\n\t\tif (!loopback && ((rdma_ah_get_dlid(&qp->remote_ah_attr) &\n\t\t\t\t   ~((1 << ps.ppd->lmc) - 1)) ==\n\t\t\t\t  ps.ppd->lid)) {\n\t\t\trvt_ruc_loopback(qp);\n\t\t\treturn;\n\t\t}\n\t\tmake_req = hfi1_make_rc_req;\n\t\tps.timeout_int = qp->timeout_jiffies;\n\t\tbreak;\n\tcase IB_QPT_UC:\n\t\tif (!loopback && ((rdma_ah_get_dlid(&qp->remote_ah_attr) &\n\t\t\t\t   ~((1 << ps.ppd->lmc) - 1)) ==\n\t\t\t\t  ps.ppd->lid)) {\n\t\t\trvt_ruc_loopback(qp);\n\t\t\treturn;\n\t\t}\n\t\tmake_req = hfi1_make_uc_req;\n\t\tps.timeout_int = SEND_RESCHED_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tmake_req = hfi1_make_ud_req;\n\t\tps.timeout_int = SEND_RESCHED_TIMEOUT;\n\t}\n\n\tspin_lock_irqsave(&qp->s_lock, ps.flags);\n\n\t \n\tif (!hfi1_send_ok(qp)) {\n\t\tif (qp->s_flags & HFI1_S_ANY_WAIT_IO)\n\t\t\tiowait_set_flag(&priv->s_iowait, IOWAIT_PENDING_IB);\n\t\tspin_unlock_irqrestore(&qp->s_lock, ps.flags);\n\t\treturn;\n\t}\n\n\tqp->s_flags |= RVT_S_BUSY;\n\n\tps.timeout_int = ps.timeout_int / 8;\n\tps.timeout = jiffies + ps.timeout_int;\n\tps.cpu = priv->s_sde ? priv->s_sde->cpu :\n\t\t\tcpumask_first(cpumask_of_node(ps.ppd->dd->node));\n\tps.pkts_sent = false;\n\n\t \n\tps.s_txreq = get_waiting_verbs_txreq(ps.wait);\n\tdo {\n\t\t \n\t\tif (ps.s_txreq) {\n\t\t\tif (priv->s_flags & HFI1_S_TID_BUSY_SET)\n\t\t\t\tqp->s_flags |= RVT_S_BUSY;\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, ps.flags);\n\t\t\t \n\t\t\tif (hfi1_verbs_send(qp, &ps))\n\t\t\t\treturn;\n\n\t\t\t \n\t\t\tif (hfi1_schedule_send_yield(qp, &ps, false))\n\t\t\t\treturn;\n\n\t\t\tspin_lock_irqsave(&qp->s_lock, ps.flags);\n\t\t}\n\t} while (make_req(qp, &ps));\n\tiowait_starve_clear(ps.pkts_sent, &priv->s_iowait);\n\tspin_unlock_irqrestore(&qp->s_lock, ps.flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}