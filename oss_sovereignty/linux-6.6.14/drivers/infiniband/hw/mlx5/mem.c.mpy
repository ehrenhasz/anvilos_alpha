{
  "module_name": "mem.c",
  "hash_id": "f1ec7f7d4ae054d26f535301c25fcd038d58619792ff52e2f8c0d266dbe982ac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/mem.c",
  "human_readable_source": " \n\n#include <rdma/ib_umem_odp.h>\n#include \"mlx5_ib.h\"\n#include <linux/jiffies.h>\n\n \nvoid mlx5_ib_populate_pas(struct ib_umem *umem, size_t page_size, __be64 *pas,\n\t\t\t  u64 access_flags)\n{\n\tstruct ib_block_iter biter;\n\n\trdma_umem_for_each_dma_block (umem, &biter, page_size) {\n\t\t*pas = cpu_to_be64(rdma_block_iter_dma_address(&biter) |\n\t\t\t\t   access_flags);\n\t\tpas++;\n\t}\n}\n\n \nunsigned long __mlx5_umem_find_best_quantized_pgoff(\n\tstruct ib_umem *umem, unsigned long pgsz_bitmap,\n\tunsigned int page_offset_bits, u64 pgoff_bitmask, unsigned int scale,\n\tunsigned int *page_offset_quantized)\n{\n\tconst u64 page_offset_mask = (1UL << page_offset_bits) - 1;\n\tunsigned long page_size;\n\tu64 page_offset;\n\n\tpage_size = ib_umem_find_best_pgoff(umem, pgsz_bitmap, pgoff_bitmask);\n\tif (!page_size)\n\t\treturn 0;\n\n\t \n\tpage_offset = ib_umem_dma_offset(umem, page_size);\n\twhile (page_offset & ~(u64)(page_offset_mask * (page_size / scale))) {\n\t\tpage_size /= 2;\n\t\tpage_offset = ib_umem_dma_offset(umem, page_size);\n\t}\n\n\t \n\tif (!(pgsz_bitmap & page_size))\n\t\treturn 0;\n\n\t*page_offset_quantized =\n\t\t(unsigned long)page_offset / (page_size / scale);\n\tif (WARN_ON(*page_offset_quantized > page_offset_mask))\n\t\treturn 0;\n\treturn page_size;\n}\n\n#define WR_ID_BF 0xBF\n#define WR_ID_END 0xBAD\n#define TEST_WC_NUM_WQES 255\n#define TEST_WC_POLLING_MAX_TIME_JIFFIES msecs_to_jiffies(100)\nstatic int post_send_nop(struct mlx5_ib_dev *dev, struct ib_qp *ibqp, u64 wr_id,\n\t\t\t bool signaled)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tstruct mlx5_bf *bf = &qp->bf;\n\t__be32 mmio_wqe[16] = {};\n\tunsigned long flags;\n\tunsigned int idx;\n\tint i;\n\n\tif (unlikely(dev->mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR))\n\t\treturn -EIO;\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\n\tidx = qp->sq.cur_post & (qp->sq.wqe_cnt - 1);\n\tctrl = mlx5_frag_buf_get_wqe(&qp->sq.fbc, idx);\n\n\tmemset(ctrl, 0, sizeof(struct mlx5_wqe_ctrl_seg));\n\tctrl->fm_ce_se = signaled ? MLX5_WQE_CTRL_CQ_UPDATE : 0;\n\tctrl->opmod_idx_opcode =\n\t\tcpu_to_be32(((u32)(qp->sq.cur_post) << 8) | MLX5_OPCODE_NOP);\n\tctrl->qpn_ds = cpu_to_be32((sizeof(struct mlx5_wqe_ctrl_seg) / 16) |\n\t\t\t\t   (qp->trans_qp.base.mqp.qpn << 8));\n\n\tqp->sq.wrid[idx] = wr_id;\n\tqp->sq.w_list[idx].opcode = MLX5_OPCODE_NOP;\n\tqp->sq.wqe_head[idx] = qp->sq.head + 1;\n\tqp->sq.cur_post += DIV_ROUND_UP(sizeof(struct mlx5_wqe_ctrl_seg),\n\t\t\t\t\tMLX5_SEND_WQE_BB);\n\tqp->sq.w_list[idx].next = qp->sq.cur_post;\n\tqp->sq.head++;\n\n\tmemcpy(mmio_wqe, ctrl, sizeof(*ctrl));\n\t((struct mlx5_wqe_ctrl_seg *)&mmio_wqe)->fm_ce_se |=\n\t\tMLX5_WQE_CTRL_CQ_UPDATE;\n\n\t \n\twmb();\n\n\tqp->db.db[MLX5_SND_DBR] = cpu_to_be32(qp->sq.cur_post);\n\n\t \n\twmb();\n\tfor (i = 0; i < 8; i++)\n\t\tmlx5_write64(&mmio_wqe[i * 2],\n\t\t\t     bf->bfreg->map + bf->offset + i * 8);\n\tio_stop_wc();\n\n\tbf->offset ^= bf->buf_size;\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\n\treturn 0;\n}\n\nstatic int test_wc_poll_cq_result(struct mlx5_ib_dev *dev, struct ib_cq *cq)\n{\n\tint ret;\n\tstruct ib_wc wc = {};\n\tunsigned long end = jiffies + TEST_WC_POLLING_MAX_TIME_JIFFIES;\n\n\tdo {\n\t\tret = ib_poll_cq(cq, 1, &wc);\n\t\tif (ret < 0 || wc.status)\n\t\t\treturn ret < 0 ? ret : -EINVAL;\n\t\tif (ret)\n\t\t\tbreak;\n\t} while (!time_after(jiffies, end));\n\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\tif (wc.wr_id != WR_ID_BF)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int test_wc_do_send(struct mlx5_ib_dev *dev, struct ib_qp *qp)\n{\n\tint err, i;\n\n\tfor (i = 0; i < TEST_WC_NUM_WQES; i++) {\n\t\terr = post_send_nop(dev, qp, WR_ID_BF, false);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn post_send_nop(dev, qp, WR_ID_END, true);\n}\n\nint mlx5_ib_test_wc(struct mlx5_ib_dev *dev)\n{\n\tstruct ib_cq_init_attr cq_attr = { .cqe = TEST_WC_NUM_WQES + 1 };\n\tint port_type_cap = MLX5_CAP_GEN(dev->mdev, port_type);\n\tstruct ib_qp_init_attr qp_init_attr = {\n\t\t.cap = { .max_send_wr = TEST_WC_NUM_WQES },\n\t\t.qp_type = IB_QPT_UD,\n\t\t.sq_sig_type = IB_SIGNAL_REQ_WR,\n\t\t.create_flags = MLX5_IB_QP_CREATE_WC_TEST,\n\t};\n\tstruct ib_qp_attr qp_attr = { .port_num = 1 };\n\tstruct ib_device *ibdev = &dev->ib_dev;\n\tstruct ib_qp *qp;\n\tstruct ib_cq *cq;\n\tstruct ib_pd *pd;\n\tint ret;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, bf))\n\t\treturn 0;\n\n\tif (!dev->mdev->roce.roce_en &&\n\t    port_type_cap == MLX5_CAP_PORT_TYPE_ETH) {\n\t\tif (mlx5_core_is_pf(dev->mdev))\n\t\t\tdev->wc_support = arch_can_pci_mmap_wc();\n\t\treturn 0;\n\t}\n\n\tret = mlx5_alloc_bfreg(dev->mdev, &dev->wc_bfreg, true, false);\n\tif (ret)\n\t\tgoto print_err;\n\n\tif (!dev->wc_bfreg.wc)\n\t\tgoto out1;\n\n\tpd = ib_alloc_pd(ibdev, 0);\n\tif (IS_ERR(pd)) {\n\t\tret = PTR_ERR(pd);\n\t\tgoto out1;\n\t}\n\n\tcq = ib_create_cq(ibdev, NULL, NULL, NULL, &cq_attr);\n\tif (IS_ERR(cq)) {\n\t\tret = PTR_ERR(cq);\n\t\tgoto out2;\n\t}\n\n\tqp_init_attr.recv_cq = cq;\n\tqp_init_attr.send_cq = cq;\n\tqp = ib_create_qp(pd, &qp_init_attr);\n\tif (IS_ERR(qp)) {\n\t\tret = PTR_ERR(qp);\n\t\tgoto out3;\n\t}\n\n\tqp_attr.qp_state = IB_QPS_INIT;\n\tret = ib_modify_qp(qp, &qp_attr,\n\t\t\t   IB_QP_STATE | IB_QP_PORT | IB_QP_PKEY_INDEX |\n\t\t\t\t   IB_QP_QKEY);\n\tif (ret)\n\t\tgoto out4;\n\n\tqp_attr.qp_state = IB_QPS_RTR;\n\tret = ib_modify_qp(qp, &qp_attr, IB_QP_STATE);\n\tif (ret)\n\t\tgoto out4;\n\n\tqp_attr.qp_state = IB_QPS_RTS;\n\tret = ib_modify_qp(qp, &qp_attr, IB_QP_STATE | IB_QP_SQ_PSN);\n\tif (ret)\n\t\tgoto out4;\n\n\tret = test_wc_do_send(dev, qp);\n\tif (ret < 0)\n\t\tgoto out4;\n\n\tret = test_wc_poll_cq_result(dev, cq);\n\tif (ret > 0) {\n\t\tdev->wc_support = true;\n\t\tret = 0;\n\t}\n\nout4:\n\tib_destroy_qp(qp);\nout3:\n\tib_destroy_cq(cq);\nout2:\n\tib_dealloc_pd(pd);\nout1:\n\tmlx5_free_bfreg(dev->mdev, &dev->wc_bfreg);\nprint_err:\n\tif (ret)\n\t\tmlx5_ib_err(\n\t\t\tdev,\n\t\t\t\"Error %d while trying to test write-combining support\\n\",\n\t\t\tret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}