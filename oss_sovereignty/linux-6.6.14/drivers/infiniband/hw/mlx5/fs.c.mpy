{
  "module_name": "fs.c",
  "hash_id": "9e1c80e8293c1a24f1ce21de96d811c8489237cf4402b9cff291155dab3c94e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/fs.c",
  "human_readable_source": "\n \n\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/uverbs_types.h>\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/uverbs_std_types.h>\n#include <rdma/mlx5_user_ioctl_cmds.h>\n#include <rdma/mlx5_user_ioctl_verbs.h>\n#include <rdma/ib_hdrs.h>\n#include <rdma/ib_umem.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/fs.h>\n#include <linux/mlx5/fs_helpers.h>\n#include <linux/mlx5/eswitch.h>\n#include <net/inet_ecn.h>\n#include \"mlx5_ib.h\"\n#include \"counters.h\"\n#include \"devx.h\"\n#include \"fs.h\"\n\n#define UVERBS_MODULE_NAME mlx5_ib\n#include <rdma/uverbs_named_ioctl.h>\n\nenum {\n\tMATCH_CRITERIA_ENABLE_OUTER_BIT,\n\tMATCH_CRITERIA_ENABLE_MISC_BIT,\n\tMATCH_CRITERIA_ENABLE_INNER_BIT,\n\tMATCH_CRITERIA_ENABLE_MISC2_BIT\n};\n\n#define HEADER_IS_ZERO(match_criteria, headers)\t\t\t           \\\n\t!(memchr_inv(MLX5_ADDR_OF(fte_match_param, match_criteria, headers), \\\n\t\t    0, MLX5_FLD_SZ_BYTES(fte_match_param, headers)))       \\\n\nstatic u8 get_match_criteria_enable(u32 *match_criteria)\n{\n\tu8 match_criteria_enable;\n\n\tmatch_criteria_enable =\n\t\t(!HEADER_IS_ZERO(match_criteria, outer_headers)) <<\n\t\tMATCH_CRITERIA_ENABLE_OUTER_BIT;\n\tmatch_criteria_enable |=\n\t\t(!HEADER_IS_ZERO(match_criteria, misc_parameters)) <<\n\t\tMATCH_CRITERIA_ENABLE_MISC_BIT;\n\tmatch_criteria_enable |=\n\t\t(!HEADER_IS_ZERO(match_criteria, inner_headers)) <<\n\t\tMATCH_CRITERIA_ENABLE_INNER_BIT;\n\tmatch_criteria_enable |=\n\t\t(!HEADER_IS_ZERO(match_criteria, misc_parameters_2)) <<\n\t\tMATCH_CRITERIA_ENABLE_MISC2_BIT;\n\n\treturn match_criteria_enable;\n}\n\nstatic int set_proto(void *outer_c, void *outer_v, u8 mask, u8 val)\n{\n\tu8 entry_mask;\n\tu8 entry_val;\n\tint err = 0;\n\n\tif (!mask)\n\t\tgoto out;\n\n\tentry_mask = MLX5_GET(fte_match_set_lyr_2_4, outer_c,\n\t\t\t      ip_protocol);\n\tentry_val = MLX5_GET(fte_match_set_lyr_2_4, outer_v,\n\t\t\t     ip_protocol);\n\tif (!entry_mask) {\n\t\tMLX5_SET(fte_match_set_lyr_2_4, outer_c, ip_protocol, mask);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, outer_v, ip_protocol, val);\n\t\tgoto out;\n\t}\n\t \n\tif (mask != entry_mask || val != entry_val)\n\t\terr = -EINVAL;\nout:\n\treturn err;\n}\n\nstatic void set_flow_label(void *misc_c, void *misc_v, u32 mask, u32 val,\n\t\t\t   bool inner)\n{\n\tif (inner) {\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_c, inner_ipv6_flow_label, mask);\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_v, inner_ipv6_flow_label, val);\n\t} else {\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_c, outer_ipv6_flow_label, mask);\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_v, outer_ipv6_flow_label, val);\n\t}\n}\n\nstatic void set_tos(void *outer_c, void *outer_v, u8 mask, u8 val)\n{\n\tMLX5_SET(fte_match_set_lyr_2_4, outer_c, ip_ecn, mask);\n\tMLX5_SET(fte_match_set_lyr_2_4, outer_v, ip_ecn, val);\n\tMLX5_SET(fte_match_set_lyr_2_4, outer_c, ip_dscp, mask >> 2);\n\tMLX5_SET(fte_match_set_lyr_2_4, outer_v, ip_dscp, val >> 2);\n}\n\nstatic int check_mpls_supp_fields(u32 field_support, const __be32 *set_mask)\n{\n\tif (MLX5_GET(fte_match_mpls, set_mask, mpls_label) &&\n\t    !(field_support & MLX5_FIELD_SUPPORT_MPLS_LABEL))\n\t\treturn -EOPNOTSUPP;\n\n\tif (MLX5_GET(fte_match_mpls, set_mask, mpls_exp) &&\n\t    !(field_support & MLX5_FIELD_SUPPORT_MPLS_EXP))\n\t\treturn -EOPNOTSUPP;\n\n\tif (MLX5_GET(fte_match_mpls, set_mask, mpls_s_bos) &&\n\t    !(field_support & MLX5_FIELD_SUPPORT_MPLS_S_BOS))\n\t\treturn -EOPNOTSUPP;\n\n\tif (MLX5_GET(fte_match_mpls, set_mask, mpls_ttl) &&\n\t    !(field_support & MLX5_FIELD_SUPPORT_MPLS_TTL))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\n#define LAST_ETH_FIELD vlan_tag\n#define LAST_IPV4_FIELD tos\n#define LAST_IPV6_FIELD traffic_class\n#define LAST_TCP_UDP_FIELD src_port\n#define LAST_TUNNEL_FIELD tunnel_id\n#define LAST_FLOW_TAG_FIELD tag_id\n#define LAST_DROP_FIELD size\n#define LAST_COUNTERS_FIELD counters\n\n \n#define FIELDS_NOT_SUPPORTED(filter, field)                                    \\\n\tmemchr_inv((void *)&filter.field + sizeof(filter.field), 0,            \\\n\t\t   sizeof(filter) - offsetofend(typeof(filter), field))\n\nint parse_flow_flow_action(struct mlx5_ib_flow_action *maction,\n\t\t\t   bool is_egress,\n\t\t\t   struct mlx5_flow_act *action)\n{\n\n\tswitch (maction->ib_action.type) {\n\tcase IB_FLOW_ACTION_UNSPECIFIED:\n\t\tif (maction->flow_action_raw.sub_type ==\n\t\t    MLX5_IB_FLOW_ACTION_MODIFY_HEADER) {\n\t\t\tif (action->action & MLX5_FLOW_CONTEXT_ACTION_MOD_HDR)\n\t\t\t\treturn -EINVAL;\n\t\t\taction->action |= MLX5_FLOW_CONTEXT_ACTION_MOD_HDR;\n\t\t\taction->modify_hdr =\n\t\t\t\tmaction->flow_action_raw.modify_hdr;\n\t\t\treturn 0;\n\t\t}\n\t\tif (maction->flow_action_raw.sub_type ==\n\t\t    MLX5_IB_FLOW_ACTION_DECAP) {\n\t\t\tif (action->action & MLX5_FLOW_CONTEXT_ACTION_DECAP)\n\t\t\t\treturn -EINVAL;\n\t\t\taction->action |= MLX5_FLOW_CONTEXT_ACTION_DECAP;\n\t\t\treturn 0;\n\t\t}\n\t\tif (maction->flow_action_raw.sub_type ==\n\t\t    MLX5_IB_FLOW_ACTION_PACKET_REFORMAT) {\n\t\t\tif (action->action &\n\t\t\t    MLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT)\n\t\t\t\treturn -EINVAL;\n\t\t\taction->action |=\n\t\t\t\tMLX5_FLOW_CONTEXT_ACTION_PACKET_REFORMAT;\n\t\t\taction->pkt_reformat =\n\t\t\t\tmaction->flow_action_raw.pkt_reformat;\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic int parse_flow_attr(struct mlx5_core_dev *mdev,\n\t\t\t   struct mlx5_flow_spec *spec,\n\t\t\t   const union ib_flow_spec *ib_spec,\n\t\t\t   const struct ib_flow_attr *flow_attr,\n\t\t\t   struct mlx5_flow_act *action, u32 prev_type)\n{\n\tstruct mlx5_flow_context *flow_context = &spec->flow_context;\n\tu32 *match_c = spec->match_criteria;\n\tu32 *match_v = spec->match_value;\n\tvoid *misc_params_c = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t   misc_parameters);\n\tvoid *misc_params_v = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t   misc_parameters);\n\tvoid *misc_params2_c = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t    misc_parameters_2);\n\tvoid *misc_params2_v = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t    misc_parameters_2);\n\tvoid *headers_c;\n\tvoid *headers_v;\n\tint match_ipv;\n\tint ret;\n\n\tif (ib_spec->type & IB_FLOW_SPEC_INNER) {\n\t\theaders_c = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t inner_headers);\n\t\theaders_v = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t inner_headers);\n\t\tmatch_ipv = MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\tft_field_support.inner_ip_version);\n\t} else {\n\t\theaders_c = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t outer_headers);\n\t\theaders_v = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t outer_headers);\n\t\tmatch_ipv = MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\tft_field_support.outer_ip_version);\n\t}\n\n\tswitch (ib_spec->type & ~IB_FLOW_SPEC_INNER) {\n\tcase IB_FLOW_SPEC_ETH:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->eth.mask, LAST_ETH_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t     dmac_47_16),\n\t\t\t\tib_spec->eth.mask.dst_mac);\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t     dmac_47_16),\n\t\t\t\tib_spec->eth.val.dst_mac);\n\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t\t     smac_47_16),\n\t\t\t\tib_spec->eth.mask.src_mac);\n\t\tether_addr_copy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t\t     smac_47_16),\n\t\t\t\tib_spec->eth.val.src_mac);\n\n\t\tif (ib_spec->eth.mask.vlan_tag) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t cvlan_tag, 1);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t cvlan_tag, 1);\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t first_vid, ntohs(ib_spec->eth.mask.vlan_tag));\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t first_vid, ntohs(ib_spec->eth.val.vlan_tag));\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t first_cfi,\n\t\t\t\t ntohs(ib_spec->eth.mask.vlan_tag) >> 12);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t first_cfi,\n\t\t\t\t ntohs(ib_spec->eth.val.vlan_tag) >> 12);\n\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t first_prio,\n\t\t\t\t ntohs(ib_spec->eth.mask.vlan_tag) >> 13);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t first_prio,\n\t\t\t\t ntohs(ib_spec->eth.val.vlan_tag) >> 13);\n\t\t}\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t ethertype, ntohs(ib_spec->eth.mask.ether_type));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t ethertype, ntohs(ib_spec->eth.val.ether_type));\n\t\tbreak;\n\tcase IB_FLOW_SPEC_IPV4:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->ipv4.mask, LAST_IPV4_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (match_ipv) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t ip_version, 0xf);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t ip_version, MLX5_FS_IPV4_VERSION);\n\t\t} else {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t ethertype, 0xffff);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t ethertype, ETH_P_IP);\n\t\t}\n\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &ib_spec->ipv4.mask.src_ip,\n\t\t       sizeof(ib_spec->ipv4.mask.src_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    src_ipv4_src_ipv6.ipv4_layout.ipv4),\n\t\t       &ib_spec->ipv4.val.src_ip,\n\t\t       sizeof(ib_spec->ipv4.val.src_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &ib_spec->ipv4.mask.dst_ip,\n\t\t       sizeof(ib_spec->ipv4.mask.dst_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv4_layout.ipv4),\n\t\t       &ib_spec->ipv4.val.dst_ip,\n\t\t       sizeof(ib_spec->ipv4.val.dst_ip));\n\n\t\tset_tos(headers_c, headers_v,\n\t\t\tib_spec->ipv4.mask.tos, ib_spec->ipv4.val.tos);\n\n\t\tif (set_proto(headers_c, headers_v,\n\t\t\t      ib_spec->ipv4.mask.proto,\n\t\t\t      ib_spec->ipv4.val.proto))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_IPV6:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->ipv6.mask, LAST_IPV6_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (match_ipv) {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t ip_version, 0xf);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t ip_version, MLX5_FS_IPV6_VERSION);\n\t\t} else {\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t ethertype, 0xffff);\n\t\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t ethertype, ETH_P_IPV6);\n\t\t}\n\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &ib_spec->ipv6.mask.src_ip,\n\t\t       sizeof(ib_spec->ipv6.mask.src_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    src_ipv4_src_ipv6.ipv6_layout.ipv6),\n\t\t       &ib_spec->ipv6.val.src_ip,\n\t\t       sizeof(ib_spec->ipv6.val.src_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_c,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &ib_spec->ipv6.mask.dst_ip,\n\t\t       sizeof(ib_spec->ipv6.mask.dst_ip));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_lyr_2_4, headers_v,\n\t\t\t\t    dst_ipv4_dst_ipv6.ipv6_layout.ipv6),\n\t\t       &ib_spec->ipv6.val.dst_ip,\n\t\t       sizeof(ib_spec->ipv6.val.dst_ip));\n\n\t\tset_tos(headers_c, headers_v,\n\t\t\tib_spec->ipv6.mask.traffic_class,\n\t\t\tib_spec->ipv6.val.traffic_class);\n\n\t\tif (set_proto(headers_c, headers_v,\n\t\t\t      ib_spec->ipv6.mask.next_hdr,\n\t\t\t      ib_spec->ipv6.val.next_hdr))\n\t\t\treturn -EINVAL;\n\n\t\tset_flow_label(misc_params_c, misc_params_v,\n\t\t\t       ntohl(ib_spec->ipv6.mask.flow_label),\n\t\t\t       ntohl(ib_spec->ipv6.val.flow_label),\n\t\t\t       ib_spec->type & IB_FLOW_SPEC_INNER);\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ESP:\n\t\treturn -EOPNOTSUPP;\n\tcase IB_FLOW_SPEC_TCP:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->tcp_udp.mask,\n\t\t\t\t\t LAST_TCP_UDP_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (set_proto(headers_c, headers_v, 0xff, IPPROTO_TCP))\n\t\t\treturn -EINVAL;\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, tcp_sport,\n\t\t\t ntohs(ib_spec->tcp_udp.mask.src_port));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, tcp_sport,\n\t\t\t ntohs(ib_spec->tcp_udp.val.src_port));\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, tcp_dport,\n\t\t\t ntohs(ib_spec->tcp_udp.mask.dst_port));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, tcp_dport,\n\t\t\t ntohs(ib_spec->tcp_udp.val.dst_port));\n\t\tbreak;\n\tcase IB_FLOW_SPEC_UDP:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->tcp_udp.mask,\n\t\t\t\t\t LAST_TCP_UDP_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (set_proto(headers_c, headers_v, 0xff, IPPROTO_UDP))\n\t\t\treturn -EINVAL;\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, udp_sport,\n\t\t\t ntohs(ib_spec->tcp_udp.mask.src_port));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, udp_sport,\n\t\t\t ntohs(ib_spec->tcp_udp.val.src_port));\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, udp_dport,\n\t\t\t ntohs(ib_spec->tcp_udp.mask.dst_port));\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, udp_dport,\n\t\t\t ntohs(ib_spec->tcp_udp.val.dst_port));\n\t\tbreak;\n\tcase IB_FLOW_SPEC_GRE:\n\t\tif (ib_spec->gre.mask.c_ks_res0_ver)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (set_proto(headers_c, headers_v, 0xff, IPPROTO_GRE))\n\t\t\treturn -EINVAL;\n\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_c, ip_protocol,\n\t\t\t 0xff);\n\t\tMLX5_SET(fte_match_set_lyr_2_4, headers_v, ip_protocol,\n\t\t\t IPPROTO_GRE);\n\n\t\tMLX5_SET(fte_match_set_misc, misc_params_c, gre_protocol,\n\t\t\t ntohs(ib_spec->gre.mask.protocol));\n\t\tMLX5_SET(fte_match_set_misc, misc_params_v, gre_protocol,\n\t\t\t ntohs(ib_spec->gre.val.protocol));\n\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc, misc_params_c,\n\t\t\t\t    gre_key.nvgre.hi),\n\t\t       &ib_spec->gre.mask.key,\n\t\t       sizeof(ib_spec->gre.mask.key));\n\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc, misc_params_v,\n\t\t\t\t    gre_key.nvgre.hi),\n\t\t       &ib_spec->gre.val.key,\n\t\t       sizeof(ib_spec->gre.val.key));\n\t\tbreak;\n\tcase IB_FLOW_SPEC_MPLS:\n\t\tswitch (prev_type) {\n\t\tcase IB_FLOW_SPEC_UDP:\n\t\t\tif (check_mpls_supp_fields(MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t\t   ft_field_support.outer_first_mpls_over_udp),\n\t\t\t\t\t\t   &ib_spec->mpls.mask.tag))\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_v,\n\t\t\t\t\t    outer_first_mpls_over_udp),\n\t\t\t       &ib_spec->mpls.val.tag,\n\t\t\t       sizeof(ib_spec->mpls.val.tag));\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_c,\n\t\t\t\t\t    outer_first_mpls_over_udp),\n\t\t\t       &ib_spec->mpls.mask.tag,\n\t\t\t       sizeof(ib_spec->mpls.mask.tag));\n\t\t\tbreak;\n\t\tcase IB_FLOW_SPEC_GRE:\n\t\t\tif (check_mpls_supp_fields(MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t\t   ft_field_support.outer_first_mpls_over_gre),\n\t\t\t\t\t\t   &ib_spec->mpls.mask.tag))\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_v,\n\t\t\t\t\t    outer_first_mpls_over_gre),\n\t\t\t       &ib_spec->mpls.val.tag,\n\t\t\t       sizeof(ib_spec->mpls.val.tag));\n\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_c,\n\t\t\t\t\t    outer_first_mpls_over_gre),\n\t\t\t       &ib_spec->mpls.mask.tag,\n\t\t\t       sizeof(ib_spec->mpls.mask.tag));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ib_spec->type & IB_FLOW_SPEC_INNER) {\n\t\t\t\tif (check_mpls_supp_fields(MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t\t\t   ft_field_support.inner_first_mpls),\n\t\t\t\t\t\t\t   &ib_spec->mpls.mask.tag))\n\t\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_v,\n\t\t\t\t\t\t    inner_first_mpls),\n\t\t\t\t       &ib_spec->mpls.val.tag,\n\t\t\t\t       sizeof(ib_spec->mpls.val.tag));\n\t\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_c,\n\t\t\t\t\t\t    inner_first_mpls),\n\t\t\t\t       &ib_spec->mpls.mask.tag,\n\t\t\t\t       sizeof(ib_spec->mpls.mask.tag));\n\t\t\t} else {\n\t\t\t\tif (check_mpls_supp_fields(MLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\t\t\t   ft_field_support.outer_first_mpls),\n\t\t\t\t\t\t\t   &ib_spec->mpls.mask.tag))\n\t\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_v,\n\t\t\t\t\t\t    outer_first_mpls),\n\t\t\t\t       &ib_spec->mpls.val.tag,\n\t\t\t\t       sizeof(ib_spec->mpls.val.tag));\n\t\t\t\tmemcpy(MLX5_ADDR_OF(fte_match_set_misc2, misc_params2_c,\n\t\t\t\t\t\t    outer_first_mpls),\n\t\t\t\t       &ib_spec->mpls.mask.tag,\n\t\t\t\t       sizeof(ib_spec->mpls.mask.tag));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IB_FLOW_SPEC_VXLAN_TUNNEL:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->tunnel.mask,\n\t\t\t\t\t LAST_TUNNEL_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tMLX5_SET(fte_match_set_misc, misc_params_c, vxlan_vni,\n\t\t\t ntohl(ib_spec->tunnel.mask.tunnel_id));\n\t\tMLX5_SET(fte_match_set_misc, misc_params_v, vxlan_vni,\n\t\t\t ntohl(ib_spec->tunnel.val.tunnel_id));\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_TAG:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->flow_tag,\n\t\t\t\t\t LAST_FLOW_TAG_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\t\tif (ib_spec->flow_tag.tag_id >= BIT(24))\n\t\t\treturn -EINVAL;\n\n\t\tflow_context->flow_tag = ib_spec->flow_tag.tag_id;\n\t\tflow_context->flags |= FLOW_CONTEXT_HAS_TAG;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_DROP:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->drop,\n\t\t\t\t\t LAST_DROP_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\t\taction->action |= MLX5_FLOW_CONTEXT_ACTION_DROP;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_HANDLE:\n\t\tret = parse_flow_flow_action(to_mflow_act(ib_spec->action.act),\n\t\t\tflow_attr->flags & IB_FLOW_ATTR_FLAGS_EGRESS, action);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IB_FLOW_SPEC_ACTION_COUNT:\n\t\tif (FIELDS_NOT_SUPPORTED(ib_spec->flow_count,\n\t\t\t\t\t LAST_COUNTERS_FIELD))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\t \n\t\tif (action->action & MLX5_FLOW_CONTEXT_ACTION_COUNT)\n\t\t\treturn -EINVAL;\n\n\t\taction->counters = ib_spec->flow_count.counters;\n\t\taction->action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool flow_is_multicast_only(const struct ib_flow_attr *ib_attr)\n{\n\tunion ib_flow_spec *flow_spec;\n\n\tif (ib_attr->type != IB_FLOW_ATTR_NORMAL ||\n\t    ib_attr->num_of_specs < 1)\n\t\treturn false;\n\n\tflow_spec = (union ib_flow_spec *)(ib_attr + 1);\n\tif (flow_spec->type == IB_FLOW_SPEC_IPV4) {\n\t\tstruct ib_flow_spec_ipv4 *ipv4_spec;\n\n\t\tipv4_spec = (struct ib_flow_spec_ipv4 *)flow_spec;\n\t\tif (ipv4_is_multicast(ipv4_spec->val.dst_ip))\n\t\t\treturn true;\n\n\t\treturn false;\n\t}\n\n\tif (flow_spec->type == IB_FLOW_SPEC_ETH) {\n\t\tstruct ib_flow_spec_eth *eth_spec;\n\n\t\teth_spec = (struct ib_flow_spec_eth *)flow_spec;\n\t\treturn is_multicast_ether_addr(eth_spec->mask.dst_mac) &&\n\t\t       is_multicast_ether_addr(eth_spec->val.dst_mac);\n\t}\n\n\treturn false;\n}\n\nstatic bool is_valid_ethertype(struct mlx5_core_dev *mdev,\n\t\t\t       const struct ib_flow_attr *flow_attr,\n\t\t\t       bool check_inner)\n{\n\tunion ib_flow_spec *ib_spec = (union ib_flow_spec *)(flow_attr + 1);\n\tint match_ipv = check_inner ?\n\t\t\tMLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\tft_field_support.inner_ip_version) :\n\t\t\tMLX5_CAP_FLOWTABLE_NIC_RX(mdev,\n\t\t\t\t\tft_field_support.outer_ip_version);\n\tint inner_bit = check_inner ? IB_FLOW_SPEC_INNER : 0;\n\tbool ipv4_spec_valid, ipv6_spec_valid;\n\tunsigned int ip_spec_type = 0;\n\tbool has_ethertype = false;\n\tunsigned int spec_index;\n\tbool mask_valid = true;\n\tu16 eth_type = 0;\n\tbool type_valid;\n\n\t \n\tfor (spec_index = 0; spec_index < flow_attr->num_of_specs; spec_index++) {\n\t\tif ((ib_spec->type == (IB_FLOW_SPEC_ETH | inner_bit)) &&\n\t\t    ib_spec->eth.mask.ether_type) {\n\t\t\tmask_valid = (ib_spec->eth.mask.ether_type ==\n\t\t\t\t      htons(0xffff));\n\t\t\thas_ethertype = true;\n\t\t\teth_type = ntohs(ib_spec->eth.val.ether_type);\n\t\t} else if ((ib_spec->type == (IB_FLOW_SPEC_IPV4 | inner_bit)) ||\n\t\t\t   (ib_spec->type == (IB_FLOW_SPEC_IPV6 | inner_bit))) {\n\t\t\tip_spec_type = ib_spec->type;\n\t\t}\n\t\tib_spec = (void *)ib_spec + ib_spec->size;\n\t}\n\n\ttype_valid = (!has_ethertype) || (!ip_spec_type);\n\tif (!type_valid && mask_valid) {\n\t\tipv4_spec_valid = (eth_type == ETH_P_IP) &&\n\t\t\t(ip_spec_type == (IB_FLOW_SPEC_IPV4 | inner_bit));\n\t\tipv6_spec_valid = (eth_type == ETH_P_IPV6) &&\n\t\t\t(ip_spec_type == (IB_FLOW_SPEC_IPV6 | inner_bit));\n\n\t\ttype_valid = (ipv4_spec_valid) || (ipv6_spec_valid) ||\n\t\t\t     (((eth_type == ETH_P_MPLS_UC) ||\n\t\t\t       (eth_type == ETH_P_MPLS_MC)) && match_ipv);\n\t}\n\n\treturn type_valid;\n}\n\nstatic bool is_valid_attr(struct mlx5_core_dev *mdev,\n\t\t\t  const struct ib_flow_attr *flow_attr)\n{\n\treturn is_valid_ethertype(mdev, flow_attr, false) &&\n\t       is_valid_ethertype(mdev, flow_attr, true);\n}\n\nstatic void put_flow_table(struct mlx5_ib_dev *dev,\n\t\t\t   struct mlx5_ib_flow_prio *prio, bool ft_added)\n{\n\tprio->refcount -= !!ft_added;\n\tif (!prio->refcount) {\n\t\tmlx5_destroy_flow_table(prio->flow_table);\n\t\tprio->flow_table = NULL;\n\t}\n}\n\nstatic int mlx5_ib_destroy_flow(struct ib_flow *flow_id)\n{\n\tstruct mlx5_ib_flow_handler *handler = container_of(flow_id,\n\t\t\t\t\t\t\t  struct mlx5_ib_flow_handler,\n\t\t\t\t\t\t\t  ibflow);\n\tstruct mlx5_ib_flow_handler *iter, *tmp;\n\tstruct mlx5_ib_dev *dev = handler->dev;\n\n\tmutex_lock(&dev->flow_db->lock);\n\n\tlist_for_each_entry_safe(iter, tmp, &handler->list, list) {\n\t\tmlx5_del_flow_rules(iter->rule);\n\t\tput_flow_table(dev, iter->prio, true);\n\t\tlist_del(&iter->list);\n\t\tkfree(iter);\n\t}\n\n\tmlx5_del_flow_rules(handler->rule);\n\tput_flow_table(dev, handler->prio, true);\n\tmlx5_ib_counters_clear_description(handler->ibcounters);\n\tmutex_unlock(&dev->flow_db->lock);\n\tif (handler->flow_matcher)\n\t\tatomic_dec(&handler->flow_matcher->usecnt);\n\tkfree(handler);\n\n\treturn 0;\n}\n\nstatic int ib_prio_to_core_prio(unsigned int priority, bool dont_trap)\n{\n\tpriority *= 2;\n\tif (!dont_trap)\n\t\tpriority++;\n\treturn priority;\n}\n\nenum flow_table_type {\n\tMLX5_IB_FT_RX,\n\tMLX5_IB_FT_TX\n};\n\n#define MLX5_FS_MAX_TYPES\t 6\n#define MLX5_FS_MAX_ENTRIES\t BIT(16)\n\nstatic bool mlx5_ib_shared_ft_allowed(struct ib_device *device)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\n\treturn MLX5_CAP_GEN(dev->mdev, shared_object_to_user_object_allowed);\n}\n\nstatic struct mlx5_ib_flow_prio *_get_prio(struct mlx5_ib_dev *dev,\n\t\t\t\t\t   struct mlx5_flow_namespace *ns,\n\t\t\t\t\t   struct mlx5_ib_flow_prio *prio,\n\t\t\t\t\t   int priority,\n\t\t\t\t\t   int num_entries, int num_groups,\n\t\t\t\t\t   u32 flags)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_table *ft;\n\n\tft_attr.prio = priority;\n\tft_attr.max_fte = num_entries;\n\tft_attr.flags = flags;\n\tft_attr.autogroup.max_num_groups = num_groups;\n\tft = mlx5_create_auto_grouped_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft))\n\t\treturn ERR_CAST(ft);\n\n\tprio->flow_table = ft;\n\tprio->refcount = 0;\n\treturn prio;\n}\n\nstatic struct mlx5_ib_flow_prio *get_flow_table(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\tstruct ib_flow_attr *flow_attr,\n\t\t\t\t\t\tenum flow_table_type ft_type)\n{\n\tbool dont_trap = flow_attr->flags & IB_FLOW_ATTR_FLAGS_DONT_TRAP;\n\tstruct mlx5_flow_namespace *ns = NULL;\n\tenum mlx5_flow_namespace_type fn_type;\n\tstruct mlx5_ib_flow_prio *prio;\n\tstruct mlx5_flow_table *ft;\n\tint max_table_size;\n\tint num_entries;\n\tint num_groups;\n\tbool esw_encap;\n\tu32 flags = 0;\n\tint priority;\n\n\tmax_table_size = BIT(MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev,\n\t\t\t\t\t\t       log_max_ft_size));\n\tesw_encap = mlx5_eswitch_get_encap_mode(dev->mdev) !=\n\t\tDEVLINK_ESWITCH_ENCAP_MODE_NONE;\n\tswitch (flow_attr->type) {\n\tcase IB_FLOW_ATTR_NORMAL:\n\t\tif (flow_is_multicast_only(flow_attr) && !dont_trap)\n\t\t\tpriority = MLX5_IB_FLOW_MCAST_PRIO;\n\t\telse\n\t\t\tpriority = ib_prio_to_core_prio(flow_attr->priority,\n\t\t\t\t\t\t\tdont_trap);\n\t\tif (ft_type == MLX5_IB_FT_RX) {\n\t\t\tfn_type = MLX5_FLOW_NAMESPACE_BYPASS;\n\t\t\tprio = &dev->flow_db->prios[priority];\n\t\t\tif (!dev->is_rep && !esw_encap &&\n\t\t\t    MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, decap))\n\t\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_DECAP;\n\t\t\tif (!dev->is_rep && !esw_encap &&\n\t\t\t    MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev,\n\t\t\t\t\t\t      reformat_l3_tunnel_to_l2))\n\t\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\t\t} else {\n\t\t\tmax_table_size = BIT(MLX5_CAP_FLOWTABLE_NIC_TX(\n\t\t\t\tdev->mdev, log_max_ft_size));\n\t\t\tfn_type = MLX5_FLOW_NAMESPACE_EGRESS;\n\t\t\tprio = &dev->flow_db->egress_prios[priority];\n\t\t\tif (!dev->is_rep && !esw_encap &&\n\t\t\t    MLX5_CAP_FLOWTABLE_NIC_TX(dev->mdev, reformat))\n\t\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\t\t}\n\t\tns = mlx5_get_flow_namespace(dev->mdev, fn_type);\n\t\tnum_entries = MLX5_FS_MAX_ENTRIES;\n\t\tnum_groups = MLX5_FS_MAX_TYPES;\n\t\tbreak;\n\tcase IB_FLOW_ATTR_ALL_DEFAULT:\n\tcase IB_FLOW_ATTR_MC_DEFAULT:\n\t\tns = mlx5_get_flow_namespace(dev->mdev,\n\t\t\t\t\t     MLX5_FLOW_NAMESPACE_LEFTOVERS);\n\t\tbuild_leftovers_ft_param(&priority, &num_entries, &num_groups);\n\t\tprio = &dev->flow_db->prios[MLX5_IB_FLOW_LEFTOVERS_PRIO];\n\t\tbreak;\n\tcase IB_FLOW_ATTR_SNIFFER:\n\t\tif (!MLX5_CAP_FLOWTABLE(dev->mdev,\n\t\t\t\t\tallow_sniffer_and_nic_rx_shared_tir))\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\t\tns = mlx5_get_flow_namespace(\n\t\t\tdev->mdev, ft_type == MLX5_IB_FT_RX ?\n\t\t\t\t\t   MLX5_FLOW_NAMESPACE_SNIFFER_RX :\n\t\t\t\t\t   MLX5_FLOW_NAMESPACE_SNIFFER_TX);\n\n\t\tprio = &dev->flow_db->sniffer[ft_type];\n\t\tpriority = 0;\n\t\tnum_entries = 1;\n\t\tnum_groups = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!ns)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tmax_table_size = min_t(int, num_entries, max_table_size);\n\n\tft = prio->flow_table;\n\tif (!ft)\n\t\treturn _get_prio(dev, ns, prio, priority, max_table_size,\n\t\t\t\t num_groups, flags);\n\n\treturn prio;\n}\n\nenum {\n\tRDMA_RX_ECN_OPCOUNTER_PRIO,\n\tRDMA_RX_CNP_OPCOUNTER_PRIO,\n};\n\nenum {\n\tRDMA_TX_CNP_OPCOUNTER_PRIO,\n};\n\nstatic int set_vhca_port_spec(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t      struct mlx5_flow_spec *spec)\n{\n\tif (!MLX5_CAP_FLOWTABLE_RDMA_RX(dev->mdev,\n\t\t\t\t\tft_field_support.source_vhca_port) ||\n\t    !MLX5_CAP_FLOWTABLE_RDMA_TX(dev->mdev,\n\t\t\t\t\tft_field_support.source_vhca_port))\n\t\treturn -EOPNOTSUPP;\n\n\tMLX5_SET_TO_ONES(fte_match_param, &spec->match_criteria,\n\t\t\t misc_parameters.source_vhca_port);\n\tMLX5_SET(fte_match_param, &spec->match_value,\n\t\t misc_parameters.source_vhca_port, port_num);\n\n\treturn 0;\n}\n\nstatic int set_ecn_ce_spec(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t   struct mlx5_flow_spec *spec, int ipv)\n{\n\tif (!MLX5_CAP_FLOWTABLE_RDMA_RX(dev->mdev,\n\t\t\t\t\tft_field_support.outer_ip_version))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mlx5_core_mp_enabled(dev->mdev) &&\n\t    set_vhca_port_spec(dev, port_num, spec))\n\t\treturn -EOPNOTSUPP;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.ip_ecn);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_ecn,\n\t\t INET_ECN_CE);\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t outer_headers.ip_version);\n\tMLX5_SET(fte_match_param, spec->match_value, outer_headers.ip_version,\n\t\t ipv);\n\n\tspec->match_criteria_enable =\n\t\tget_match_criteria_enable(spec->match_criteria);\n\n\treturn 0;\n}\n\nstatic int set_cnp_spec(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\tstruct mlx5_flow_spec *spec)\n{\n\tif (mlx5_core_mp_enabled(dev->mdev) &&\n\t    set_vhca_port_spec(dev, port_num, spec))\n\t\treturn -EOPNOTSUPP;\n\n\tMLX5_SET_TO_ONES(fte_match_param, spec->match_criteria,\n\t\t\t misc_parameters.bth_opcode);\n\tMLX5_SET(fte_match_param, spec->match_value, misc_parameters.bth_opcode,\n\t\t IB_BTH_OPCODE_CNP);\n\n\tspec->match_criteria_enable =\n\t\tget_match_criteria_enable(spec->match_criteria);\n\n\treturn 0;\n}\n\nint mlx5_ib_fs_add_op_fc(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t struct mlx5_ib_op_fc *opfc,\n\t\t\t enum mlx5_ib_optional_counter_type type)\n{\n\tenum mlx5_flow_namespace_type fn_type;\n\tint priority, i, err, spec_num;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_destination dst;\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_ib_flow_prio *prio;\n\tstruct mlx5_flow_spec *spec;\n\n\tspec = kcalloc(MAX_OPFC_RULES, sizeof(*spec), GFP_KERNEL);\n\tif (!spec)\n\t\treturn -ENOMEM;\n\n\tswitch (type) {\n\tcase MLX5_IB_OPCOUNTER_CC_RX_CE_PKTS:\n\t\tif (set_ecn_ce_spec(dev, port_num, &spec[0],\n\t\t\t\t    MLX5_FS_IPV4_VERSION) ||\n\t\t    set_ecn_ce_spec(dev, port_num, &spec[1],\n\t\t\t\t    MLX5_FS_IPV6_VERSION)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free;\n\t\t}\n\t\tspec_num = 2;\n\t\tfn_type = MLX5_FLOW_NAMESPACE_RDMA_RX_COUNTERS;\n\t\tpriority = RDMA_RX_ECN_OPCOUNTER_PRIO;\n\t\tbreak;\n\n\tcase MLX5_IB_OPCOUNTER_CC_RX_CNP_PKTS:\n\t\tif (!MLX5_CAP_FLOWTABLE(dev->mdev,\n\t\t\t\t\tft_field_support_2_nic_receive_rdma.bth_opcode) ||\n\t\t    set_cnp_spec(dev, port_num, &spec[0])) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free;\n\t\t}\n\t\tspec_num = 1;\n\t\tfn_type = MLX5_FLOW_NAMESPACE_RDMA_RX_COUNTERS;\n\t\tpriority = RDMA_RX_CNP_OPCOUNTER_PRIO;\n\t\tbreak;\n\n\tcase MLX5_IB_OPCOUNTER_CC_TX_CNP_PKTS:\n\t\tif (!MLX5_CAP_FLOWTABLE(dev->mdev,\n\t\t\t\t\tft_field_support_2_nic_transmit_rdma.bth_opcode) ||\n\t\t    set_cnp_spec(dev, port_num, &spec[0])) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto free;\n\t\t}\n\t\tspec_num = 1;\n\t\tfn_type = MLX5_FLOW_NAMESPACE_RDMA_TX_COUNTERS;\n\t\tpriority = RDMA_TX_CNP_OPCOUNTER_PRIO;\n\t\tbreak;\n\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\tns = mlx5_get_flow_namespace(dev->mdev, fn_type);\n\tif (!ns) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto free;\n\t}\n\n\tprio = &dev->flow_db->opfcs[type];\n\tif (!prio->flow_table) {\n\t\tprio = _get_prio(dev, ns, prio, priority,\n\t\t\t\t dev->num_ports * MAX_OPFC_RULES, 1, 0);\n\t\tif (IS_ERR(prio)) {\n\t\t\terr = PTR_ERR(prio);\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tdst.type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\tdst.counter_id = mlx5_fc_id(opfc->fc);\n\n\tflow_act.action =\n\t\tMLX5_FLOW_CONTEXT_ACTION_COUNT | MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\n\tfor (i = 0; i < spec_num; i++) {\n\t\topfc->rule[i] = mlx5_add_flow_rules(prio->flow_table, &spec[i],\n\t\t\t\t\t\t    &flow_act, &dst, 1);\n\t\tif (IS_ERR(opfc->rule[i])) {\n\t\t\terr = PTR_ERR(opfc->rule[i]);\n\t\t\tgoto del_rules;\n\t\t}\n\t}\n\tprio->refcount += spec_num;\n\tkfree(spec);\n\n\treturn 0;\n\ndel_rules:\n\tfor (i -= 1; i >= 0; i--)\n\t\tmlx5_del_flow_rules(opfc->rule[i]);\n\tput_flow_table(dev, prio, false);\nfree:\n\tkfree(spec);\n\treturn err;\n}\n\nvoid mlx5_ib_fs_remove_op_fc(struct mlx5_ib_dev *dev,\n\t\t\t     struct mlx5_ib_op_fc *opfc,\n\t\t\t     enum mlx5_ib_optional_counter_type type)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_OPFC_RULES && opfc->rule[i]; i++) {\n\t\tmlx5_del_flow_rules(opfc->rule[i]);\n\t\tput_flow_table(dev, &dev->flow_db->opfcs[type], true);\n\t}\n}\n\nstatic void set_underlay_qp(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_flow_spec *spec,\n\t\t\t    u32 underlay_qpn)\n{\n\tvoid *misc_params_c = MLX5_ADDR_OF(fte_match_param,\n\t\t\t\t\t   spec->match_criteria,\n\t\t\t\t\t   misc_parameters);\n\tvoid *misc_params_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t\t   misc_parameters);\n\n\tif (underlay_qpn &&\n\t    MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev,\n\t\t\t\t      ft_field_support.bth_dst_qp)) {\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_params_v, bth_dst_qp, underlay_qpn);\n\t\tMLX5_SET(fte_match_set_misc,\n\t\t\t misc_params_c, bth_dst_qp, 0xffffff);\n\t}\n}\n\nstatic void mlx5_ib_set_rule_source_port(struct mlx5_ib_dev *dev,\n\t\t\t\t\t struct mlx5_flow_spec *spec,\n\t\t\t\t\t struct mlx5_eswitch_rep *rep)\n{\n\tstruct mlx5_eswitch *esw = dev->mdev->priv.eswitch;\n\tvoid *misc;\n\n\tif (mlx5_eswitch_vport_match_metadata_enabled(esw)) {\n\t\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    misc_parameters_2);\n\n\t\tMLX5_SET(fte_match_set_misc2, misc, metadata_reg_c_0,\n\t\t\t mlx5_eswitch_get_vport_metadata_for_match(rep->esw,\n\t\t\t\t\t\t\t\t   rep->vport));\n\t\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    misc_parameters_2);\n\n\t\tMLX5_SET(fte_match_set_misc2, misc, metadata_reg_c_0,\n\t\t\t mlx5_eswitch_get_vport_metadata_mask());\n\t} else {\n\t\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_value,\n\t\t\t\t    misc_parameters);\n\n\t\tMLX5_SET(fte_match_set_misc, misc, source_port, rep->vport);\n\n\t\tmisc = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,\n\t\t\t\t    misc_parameters);\n\n\t\tMLX5_SET_TO_ONES(fte_match_set_misc, misc, source_port);\n\t}\n}\n\nstatic struct mlx5_ib_flow_handler *_create_flow_rule(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t      struct mlx5_ib_flow_prio *ft_prio,\n\t\t\t\t\t\t      const struct ib_flow_attr *flow_attr,\n\t\t\t\t\t\t      struct mlx5_flow_destination *dst,\n\t\t\t\t\t\t      u32 underlay_qpn,\n\t\t\t\t\t\t      struct mlx5_ib_create_flow *ucmd)\n{\n\tstruct mlx5_flow_table\t*ft = ft_prio->flow_table;\n\tstruct mlx5_ib_flow_handler *handler;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_destination dest_arr[2] = {};\n\tstruct mlx5_flow_destination *rule_dst = dest_arr;\n\tconst void *ib_flow = (const void *)flow_attr + sizeof(*flow_attr);\n\tunsigned int spec_index;\n\tu32 prev_type = 0;\n\tint err = 0;\n\tint dest_num = 0;\n\tbool is_egress = flow_attr->flags & IB_FLOW_ATTR_FLAGS_EGRESS;\n\n\tif (!is_valid_attr(dev->mdev, flow_attr))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (dev->is_rep && is_egress)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\thandler = kzalloc(sizeof(*handler), GFP_KERNEL);\n\tif (!handler || !spec) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tINIT_LIST_HEAD(&handler->list);\n\n\tfor (spec_index = 0; spec_index < flow_attr->num_of_specs; spec_index++) {\n\t\terr = parse_flow_attr(dev->mdev, spec,\n\t\t\t\t      ib_flow, flow_attr, &flow_act,\n\t\t\t\t      prev_type);\n\t\tif (err < 0)\n\t\t\tgoto free;\n\n\t\tprev_type = ((union ib_flow_spec *)ib_flow)->type;\n\t\tib_flow += ((union ib_flow_spec *)ib_flow)->size;\n\t}\n\n\tif (dst && !(flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DROP)) {\n\t\tmemcpy(&dest_arr[0], dst, sizeof(*dst));\n\t\tdest_num++;\n\t}\n\n\tif (!flow_is_multicast_only(flow_attr))\n\t\tset_underlay_qp(dev, spec, underlay_qpn);\n\n\tif (dev->is_rep && flow_attr->type != IB_FLOW_ATTR_SNIFFER) {\n\t\tstruct mlx5_eswitch_rep *rep;\n\n\t\trep = dev->port[flow_attr->port - 1].rep;\n\t\tif (!rep) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tmlx5_ib_set_rule_source_port(dev, spec, rep);\n\t}\n\n\tspec->match_criteria_enable = get_match_criteria_enable(spec->match_criteria);\n\n\tif (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tstruct mlx5_ib_mcounters *mcounters;\n\n\t\terr = mlx5_ib_flow_counters_set_data(flow_act.counters, ucmd);\n\t\tif (err)\n\t\t\tgoto free;\n\n\t\tmcounters = to_mcounters(flow_act.counters);\n\t\thandler->ibcounters = flow_act.counters;\n\t\tdest_arr[dest_num].type =\n\t\t\tMLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdest_arr[dest_num].counter_id =\n\t\t\tmlx5_fc_id(mcounters->hw_cntrs_hndl);\n\t\tdest_num++;\n\t}\n\n\tif (flow_act.action & MLX5_FLOW_CONTEXT_ACTION_DROP) {\n\t\tif (!dest_num)\n\t\t\trule_dst = NULL;\n\t} else {\n\t\tif (flow_attr->flags & IB_FLOW_ATTR_FLAGS_DONT_TRAP)\n\t\t\tflow_act.action |=\n\t\t\t\tMLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_PRIO;\n\t\tif (is_egress)\n\t\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\t\telse if (dest_num)\n\t\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t}\n\n\tif ((spec->flow_context.flags & FLOW_CONTEXT_HAS_TAG)  &&\n\t    (flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT ||\n\t     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT)) {\n\t\tmlx5_ib_warn(dev, \"Flow tag %u and attribute type %x isn't allowed in leftovers\\n\",\n\t\t\t     spec->flow_context.flow_tag, flow_attr->type);\n\t\terr = -EINVAL;\n\t\tgoto free;\n\t}\n\thandler->rule = mlx5_add_flow_rules(ft, spec,\n\t\t\t\t\t    &flow_act,\n\t\t\t\t\t    rule_dst, dest_num);\n\n\tif (IS_ERR(handler->rule)) {\n\t\terr = PTR_ERR(handler->rule);\n\t\tgoto free;\n\t}\n\n\tft_prio->refcount++;\n\thandler->prio = ft_prio;\n\thandler->dev = dev;\n\n\tft_prio->flow_table = ft;\nfree:\n\tif (err && handler) {\n\t\tmlx5_ib_counters_clear_description(handler->ibcounters);\n\t\tkfree(handler);\n\t}\n\tkvfree(spec);\n\treturn err ? ERR_PTR(err) : handler;\n}\n\nstatic struct mlx5_ib_flow_handler *create_flow_rule(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t     struct mlx5_ib_flow_prio *ft_prio,\n\t\t\t\t\t\t     const struct ib_flow_attr *flow_attr,\n\t\t\t\t\t\t     struct mlx5_flow_destination *dst)\n{\n\treturn _create_flow_rule(dev, ft_prio, flow_attr, dst, 0, NULL);\n}\n\nenum {\n\tLEFTOVERS_MC,\n\tLEFTOVERS_UC,\n};\n\nstatic struct mlx5_ib_flow_handler *create_leftovers_rule(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t\t  struct mlx5_ib_flow_prio *ft_prio,\n\t\t\t\t\t\t\t  struct ib_flow_attr *flow_attr,\n\t\t\t\t\t\t\t  struct mlx5_flow_destination *dst)\n{\n\tstruct mlx5_ib_flow_handler *handler_ucast = NULL;\n\tstruct mlx5_ib_flow_handler *handler = NULL;\n\n\tstatic struct {\n\t\tstruct ib_flow_attr\tflow_attr;\n\t\tstruct ib_flow_spec_eth eth_flow;\n\t} leftovers_specs[] = {\n\t\t[LEFTOVERS_MC] = {\n\t\t\t.flow_attr = {\n\t\t\t\t.num_of_specs = 1,\n\t\t\t\t.size = sizeof(leftovers_specs[0])\n\t\t\t},\n\t\t\t.eth_flow = {\n\t\t\t\t.type = IB_FLOW_SPEC_ETH,\n\t\t\t\t.size = sizeof(struct ib_flow_spec_eth),\n\t\t\t\t.mask = {.dst_mac = {0x1} },\n\t\t\t\t.val =  {.dst_mac = {0x1} }\n\t\t\t}\n\t\t},\n\t\t[LEFTOVERS_UC] = {\n\t\t\t.flow_attr = {\n\t\t\t\t.num_of_specs = 1,\n\t\t\t\t.size = sizeof(leftovers_specs[0])\n\t\t\t},\n\t\t\t.eth_flow = {\n\t\t\t\t.type = IB_FLOW_SPEC_ETH,\n\t\t\t\t.size = sizeof(struct ib_flow_spec_eth),\n\t\t\t\t.mask = {.dst_mac = {0x1} },\n\t\t\t\t.val = {.dst_mac = {} }\n\t\t\t}\n\t\t}\n\t};\n\n\thandler = create_flow_rule(dev, ft_prio,\n\t\t\t\t   &leftovers_specs[LEFTOVERS_MC].flow_attr,\n\t\t\t\t   dst);\n\tif (!IS_ERR(handler) &&\n\t    flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT) {\n\t\thandler_ucast = create_flow_rule(dev, ft_prio,\n\t\t\t\t\t\t &leftovers_specs[LEFTOVERS_UC].flow_attr,\n\t\t\t\t\t\t dst);\n\t\tif (IS_ERR(handler_ucast)) {\n\t\t\tmlx5_del_flow_rules(handler->rule);\n\t\t\tft_prio->refcount--;\n\t\t\tkfree(handler);\n\t\t\thandler = handler_ucast;\n\t\t} else {\n\t\t\tlist_add(&handler_ucast->list, &handler->list);\n\t\t}\n\t}\n\n\treturn handler;\n}\n\nstatic struct mlx5_ib_flow_handler *create_sniffer_rule(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t\tstruct mlx5_ib_flow_prio *ft_rx,\n\t\t\t\t\t\t\tstruct mlx5_ib_flow_prio *ft_tx,\n\t\t\t\t\t\t\tstruct mlx5_flow_destination *dst)\n{\n\tstruct mlx5_ib_flow_handler *handler_rx;\n\tstruct mlx5_ib_flow_handler *handler_tx;\n\tint err;\n\tstatic const struct ib_flow_attr flow_attr  = {\n\t\t.num_of_specs = 0,\n\t\t.type = IB_FLOW_ATTR_SNIFFER,\n\t\t.size = sizeof(flow_attr)\n\t};\n\n\thandler_rx = create_flow_rule(dev, ft_rx, &flow_attr, dst);\n\tif (IS_ERR(handler_rx)) {\n\t\terr = PTR_ERR(handler_rx);\n\t\tgoto err;\n\t}\n\n\thandler_tx = create_flow_rule(dev, ft_tx, &flow_attr, dst);\n\tif (IS_ERR(handler_tx)) {\n\t\terr = PTR_ERR(handler_tx);\n\t\tgoto err_tx;\n\t}\n\n\tlist_add(&handler_tx->list, &handler_rx->list);\n\n\treturn handler_rx;\n\nerr_tx:\n\tmlx5_del_flow_rules(handler_rx->rule);\n\tft_rx->refcount--;\n\tkfree(handler_rx);\nerr:\n\treturn ERR_PTR(err);\n}\n\nstatic struct ib_flow *mlx5_ib_create_flow(struct ib_qp *qp,\n\t\t\t\t\t   struct ib_flow_attr *flow_attr,\n\t\t\t\t\t   struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_flow_handler *handler = NULL;\n\tstruct mlx5_flow_destination *dst = NULL;\n\tstruct mlx5_ib_flow_prio *ft_prio_tx = NULL;\n\tstruct mlx5_ib_flow_prio *ft_prio;\n\tbool is_egress = flow_attr->flags & IB_FLOW_ATTR_FLAGS_EGRESS;\n\tstruct mlx5_ib_create_flow *ucmd = NULL, ucmd_hdr;\n\tsize_t min_ucmd_sz, required_ucmd_sz;\n\tint err;\n\tint underlay_qpn;\n\n\tif (udata && udata->inlen) {\n\t\tmin_ucmd_sz = offsetofend(struct mlx5_ib_create_flow, reserved);\n\t\tif (udata->inlen < min_ucmd_sz)\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\t\terr = ib_copy_from_udata(&ucmd_hdr, udata, min_ucmd_sz);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\n\t\t \n\t\tif (ucmd_hdr.ncounters_data > 1)\n\t\t\treturn ERR_PTR(-EINVAL);\n\n\t\trequired_ucmd_sz = min_ucmd_sz +\n\t\t\tsizeof(struct mlx5_ib_flow_counters_data) *\n\t\t\tucmd_hdr.ncounters_data;\n\t\tif (udata->inlen > required_ucmd_sz &&\n\t\t    !ib_is_udata_cleared(udata, required_ucmd_sz,\n\t\t\t\t\t udata->inlen - required_ucmd_sz))\n\t\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\t\tucmd = kzalloc(required_ucmd_sz, GFP_KERNEL);\n\t\tif (!ucmd)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\terr = ib_copy_from_udata(ucmd, udata, required_ucmd_sz);\n\t\tif (err)\n\t\t\tgoto free_ucmd;\n\t}\n\n\tif (flow_attr->priority > MLX5_IB_FLOW_LAST_PRIO) {\n\t\terr = -ENOMEM;\n\t\tgoto free_ucmd;\n\t}\n\n\tif (flow_attr->flags &\n\t    ~(IB_FLOW_ATTR_FLAGS_DONT_TRAP | IB_FLOW_ATTR_FLAGS_EGRESS)) {\n\t\terr = -EINVAL;\n\t\tgoto free_ucmd;\n\t}\n\n\tif (is_egress &&\n\t    (flow_attr->type == IB_FLOW_ATTR_ALL_DEFAULT ||\n\t     flow_attr->type == IB_FLOW_ATTR_MC_DEFAULT)) {\n\t\terr = -EINVAL;\n\t\tgoto free_ucmd;\n\t}\n\n\tdst = kzalloc(sizeof(*dst), GFP_KERNEL);\n\tif (!dst) {\n\t\terr = -ENOMEM;\n\t\tgoto free_ucmd;\n\t}\n\n\tmutex_lock(&dev->flow_db->lock);\n\n\tft_prio = get_flow_table(dev, flow_attr,\n\t\t\t\t is_egress ? MLX5_IB_FT_TX : MLX5_IB_FT_RX);\n\tif (IS_ERR(ft_prio)) {\n\t\terr = PTR_ERR(ft_prio);\n\t\tgoto unlock;\n\t}\n\tif (flow_attr->type == IB_FLOW_ATTR_SNIFFER) {\n\t\tft_prio_tx = get_flow_table(dev, flow_attr, MLX5_IB_FT_TX);\n\t\tif (IS_ERR(ft_prio_tx)) {\n\t\t\terr = PTR_ERR(ft_prio_tx);\n\t\t\tft_prio_tx = NULL;\n\t\t\tgoto destroy_ft;\n\t\t}\n\t}\n\n\tif (is_egress) {\n\t\tdst->type = MLX5_FLOW_DESTINATION_TYPE_PORT;\n\t} else {\n\t\tdst->type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t\tif (mqp->is_rss)\n\t\t\tdst->tir_num = mqp->rss_qp.tirn;\n\t\telse\n\t\t\tdst->tir_num = mqp->raw_packet_qp.rq.tirn;\n\t}\n\n\tswitch (flow_attr->type) {\n\tcase IB_FLOW_ATTR_NORMAL:\n\t\tunderlay_qpn = (mqp->flags & IB_QP_CREATE_SOURCE_QPN) ?\n\t\t\t\t       mqp->underlay_qpn :\n\t\t\t\t       0;\n\t\thandler = _create_flow_rule(dev, ft_prio, flow_attr, dst,\n\t\t\t\t\t    underlay_qpn, ucmd);\n\t\tbreak;\n\tcase IB_FLOW_ATTR_ALL_DEFAULT:\n\tcase IB_FLOW_ATTR_MC_DEFAULT:\n\t\thandler = create_leftovers_rule(dev, ft_prio, flow_attr, dst);\n\t\tbreak;\n\tcase IB_FLOW_ATTR_SNIFFER:\n\t\thandler = create_sniffer_rule(dev, ft_prio, ft_prio_tx, dst);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto destroy_ft;\n\t}\n\n\tif (IS_ERR(handler)) {\n\t\terr = PTR_ERR(handler);\n\t\thandler = NULL;\n\t\tgoto destroy_ft;\n\t}\n\n\tmutex_unlock(&dev->flow_db->lock);\n\tkfree(dst);\n\tkfree(ucmd);\n\n\treturn &handler->ibflow;\n\ndestroy_ft:\n\tput_flow_table(dev, ft_prio, false);\n\tif (ft_prio_tx)\n\t\tput_flow_table(dev, ft_prio_tx, false);\nunlock:\n\tmutex_unlock(&dev->flow_db->lock);\n\tkfree(dst);\nfree_ucmd:\n\tkfree(ucmd);\n\treturn ERR_PTR(err);\n}\n\nstatic struct mlx5_ib_flow_prio *\n_get_flow_table(struct mlx5_ib_dev *dev, u16 user_priority,\n\t\tenum mlx5_flow_namespace_type ns_type,\n\t\tbool mcast)\n{\n\tstruct mlx5_flow_namespace *ns = NULL;\n\tstruct mlx5_ib_flow_prio *prio = NULL;\n\tint max_table_size = 0;\n\tbool esw_encap;\n\tu32 flags = 0;\n\tint priority;\n\n\tif (mcast)\n\t\tpriority = MLX5_IB_FLOW_MCAST_PRIO;\n\telse\n\t\tpriority = ib_prio_to_core_prio(user_priority, false);\n\n\tesw_encap = mlx5_eswitch_get_encap_mode(dev->mdev) !=\n\t\tDEVLINK_ESWITCH_ENCAP_MODE_NONE;\n\tswitch (ns_type) {\n\tcase MLX5_FLOW_NAMESPACE_BYPASS:\n\t\tmax_table_size = BIT(\n\t\t\tMLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, log_max_ft_size));\n\t\tif (MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, decap) && !esw_encap)\n\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_DECAP;\n\t\tif (MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev,\n\t\t\t\t\t      reformat_l3_tunnel_to_l2) &&\n\t\t    !esw_encap)\n\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_EGRESS:\n\t\tmax_table_size = BIT(\n\t\t\tMLX5_CAP_FLOWTABLE_NIC_TX(dev->mdev, log_max_ft_size));\n\t\tif (MLX5_CAP_FLOWTABLE_NIC_TX(dev->mdev, reformat) &&\n\t\t    !esw_encap)\n\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_FDB_BYPASS:\n\t\tmax_table_size = BIT(\n\t\t\tMLX5_CAP_ESW_FLOWTABLE_FDB(dev->mdev, log_max_ft_size));\n\t\tif (MLX5_CAP_ESW_FLOWTABLE_FDB(dev->mdev, decap) && esw_encap)\n\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_DECAP;\n\t\tif (MLX5_CAP_ESW_FLOWTABLE_FDB(dev->mdev,\n\t\t\t\t\t       reformat_l3_tunnel_to_l2) &&\n\t\t    esw_encap)\n\t\t\tflags |= MLX5_FLOW_TABLE_TUNNEL_EN_REFORMAT;\n\t\tpriority = user_priority;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_RDMA_RX:\n\t\tmax_table_size = BIT(\n\t\t\tMLX5_CAP_FLOWTABLE_RDMA_RX(dev->mdev, log_max_ft_size));\n\t\tpriority = user_priority;\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_RDMA_TX:\n\t\tmax_table_size = BIT(\n\t\t\tMLX5_CAP_FLOWTABLE_RDMA_TX(dev->mdev, log_max_ft_size));\n\t\tpriority = user_priority;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmax_table_size = min_t(int, max_table_size, MLX5_FS_MAX_ENTRIES);\n\n\tns = mlx5_get_flow_namespace(dev->mdev, ns_type);\n\tif (!ns)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tswitch (ns_type) {\n\tcase MLX5_FLOW_NAMESPACE_BYPASS:\n\t\tprio = &dev->flow_db->prios[priority];\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_EGRESS:\n\t\tprio = &dev->flow_db->egress_prios[priority];\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_FDB_BYPASS:\n\t\tprio = &dev->flow_db->fdb[priority];\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_RDMA_RX:\n\t\tprio = &dev->flow_db->rdma_rx[priority];\n\t\tbreak;\n\tcase MLX5_FLOW_NAMESPACE_RDMA_TX:\n\t\tprio = &dev->flow_db->rdma_tx[priority];\n\t\tbreak;\n\tdefault: return ERR_PTR(-EINVAL);\n\t}\n\n\tif (!prio)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (prio->flow_table)\n\t\treturn prio;\n\n\treturn _get_prio(dev, ns, prio, priority, max_table_size,\n\t\t\t MLX5_FS_MAX_TYPES, flags);\n}\n\nstatic struct mlx5_ib_flow_handler *\n_create_raw_flow_rule(struct mlx5_ib_dev *dev,\n\t\t      struct mlx5_ib_flow_prio *ft_prio,\n\t\t      struct mlx5_flow_destination *dst,\n\t\t      struct mlx5_ib_flow_matcher  *fs_matcher,\n\t\t      struct mlx5_flow_context *flow_context,\n\t\t      struct mlx5_flow_act *flow_act,\n\t\t      void *cmd_in, int inlen,\n\t\t      int dst_num)\n{\n\tstruct mlx5_ib_flow_handler *handler;\n\tstruct mlx5_flow_spec *spec;\n\tstruct mlx5_flow_table *ft = ft_prio->flow_table;\n\tint err = 0;\n\n\tspec = kvzalloc(sizeof(*spec), GFP_KERNEL);\n\thandler = kzalloc(sizeof(*handler), GFP_KERNEL);\n\tif (!handler || !spec) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tINIT_LIST_HEAD(&handler->list);\n\n\tmemcpy(spec->match_value, cmd_in, inlen);\n\tmemcpy(spec->match_criteria, fs_matcher->matcher_mask.match_params,\n\t       fs_matcher->mask_len);\n\tspec->match_criteria_enable = fs_matcher->match_criteria_enable;\n\tspec->flow_context = *flow_context;\n\n\thandler->rule = mlx5_add_flow_rules(ft, spec,\n\t\t\t\t\t    flow_act, dst, dst_num);\n\n\tif (IS_ERR(handler->rule)) {\n\t\terr = PTR_ERR(handler->rule);\n\t\tgoto free;\n\t}\n\n\tft_prio->refcount++;\n\thandler->prio = ft_prio;\n\thandler->dev = dev;\n\tft_prio->flow_table = ft;\n\nfree:\n\tif (err)\n\t\tkfree(handler);\n\tkvfree(spec);\n\treturn err ? ERR_PTR(err) : handler;\n}\n\nstatic bool raw_fs_is_multicast(struct mlx5_ib_flow_matcher *fs_matcher,\n\t\t\t\tvoid *match_v)\n{\n\tvoid *match_c;\n\tvoid *match_v_set_lyr_2_4, *match_c_set_lyr_2_4;\n\tvoid *dmac, *dmac_mask;\n\tvoid *ipv4, *ipv4_mask;\n\n\tif (!(fs_matcher->match_criteria_enable &\n\t      (1 << MATCH_CRITERIA_ENABLE_OUTER_BIT)))\n\t\treturn false;\n\n\tmatch_c = fs_matcher->matcher_mask.match_params;\n\tmatch_v_set_lyr_2_4 = MLX5_ADDR_OF(fte_match_param, match_v,\n\t\t\t\t\t   outer_headers);\n\tmatch_c_set_lyr_2_4 = MLX5_ADDR_OF(fte_match_param, match_c,\n\t\t\t\t\t   outer_headers);\n\n\tdmac = MLX5_ADDR_OF(fte_match_set_lyr_2_4, match_v_set_lyr_2_4,\n\t\t\t    dmac_47_16);\n\tdmac_mask = MLX5_ADDR_OF(fte_match_set_lyr_2_4, match_c_set_lyr_2_4,\n\t\t\t\t dmac_47_16);\n\n\tif (is_multicast_ether_addr(dmac) &&\n\t    is_multicast_ether_addr(dmac_mask))\n\t\treturn true;\n\n\tipv4 = MLX5_ADDR_OF(fte_match_set_lyr_2_4, match_v_set_lyr_2_4,\n\t\t\t    dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\n\tipv4_mask = MLX5_ADDR_OF(fte_match_set_lyr_2_4, match_c_set_lyr_2_4,\n\t\t\t\t dst_ipv4_dst_ipv6.ipv4_layout.ipv4);\n\n\tif (ipv4_is_multicast(*(__be32 *)(ipv4)) &&\n\t    ipv4_is_multicast(*(__be32 *)(ipv4_mask)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic struct mlx5_ib_flow_handler *raw_fs_rule_add(\n\tstruct mlx5_ib_dev *dev, struct mlx5_ib_flow_matcher *fs_matcher,\n\tstruct mlx5_flow_context *flow_context, struct mlx5_flow_act *flow_act,\n\tu32 counter_id, void *cmd_in, int inlen, int dest_id, int dest_type)\n{\n\tstruct mlx5_flow_destination *dst;\n\tstruct mlx5_ib_flow_prio *ft_prio;\n\tstruct mlx5_ib_flow_handler *handler;\n\tint dst_num = 0;\n\tbool mcast;\n\tint err;\n\n\tif (fs_matcher->flow_type != MLX5_IB_FLOW_TYPE_NORMAL)\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tif (fs_matcher->priority > MLX5_IB_FLOW_LAST_PRIO)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdst = kcalloc(2, sizeof(*dst), GFP_KERNEL);\n\tif (!dst)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmcast = raw_fs_is_multicast(fs_matcher, cmd_in);\n\tmutex_lock(&dev->flow_db->lock);\n\n\tft_prio = _get_flow_table(dev, fs_matcher->priority,\n\t\t\t\t  fs_matcher->ns_type, mcast);\n\tif (IS_ERR(ft_prio)) {\n\t\terr = PTR_ERR(ft_prio);\n\t\tgoto unlock;\n\t}\n\n\tswitch (dest_type) {\n\tcase MLX5_FLOW_DESTINATION_TYPE_TIR:\n\t\tdst[dst_num].type = dest_type;\n\t\tdst[dst_num++].tir_num = dest_id;\n\t\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\tbreak;\n\tcase MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE:\n\t\tdst[dst_num].type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE_NUM;\n\t\tdst[dst_num++].ft_num = dest_id;\n\t\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\t\tbreak;\n\tcase MLX5_FLOW_DESTINATION_TYPE_PORT:\n\t\tdst[dst_num++].type = MLX5_FLOW_DESTINATION_TYPE_PORT;\n\t\tflow_act->action |= MLX5_FLOW_CONTEXT_ACTION_ALLOW;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (flow_act->action & MLX5_FLOW_CONTEXT_ACTION_COUNT) {\n\t\tdst[dst_num].type = MLX5_FLOW_DESTINATION_TYPE_COUNTER;\n\t\tdst[dst_num].counter_id = counter_id;\n\t\tdst_num++;\n\t}\n\n\thandler = _create_raw_flow_rule(dev, ft_prio, dst_num ? dst : NULL,\n\t\t\t\t\tfs_matcher, flow_context, flow_act,\n\t\t\t\t\tcmd_in, inlen, dst_num);\n\n\tif (IS_ERR(handler)) {\n\t\terr = PTR_ERR(handler);\n\t\tgoto destroy_ft;\n\t}\n\n\tmutex_unlock(&dev->flow_db->lock);\n\tatomic_inc(&fs_matcher->usecnt);\n\thandler->flow_matcher = fs_matcher;\n\n\tkfree(dst);\n\n\treturn handler;\n\ndestroy_ft:\n\tput_flow_table(dev, ft_prio, false);\nunlock:\n\tmutex_unlock(&dev->flow_db->lock);\n\tkfree(dst);\n\n\treturn ERR_PTR(err);\n}\n\nstatic void destroy_flow_action_raw(struct mlx5_ib_flow_action *maction)\n{\n\tswitch (maction->flow_action_raw.sub_type) {\n\tcase MLX5_IB_FLOW_ACTION_MODIFY_HEADER:\n\t\tmlx5_modify_header_dealloc(maction->flow_action_raw.dev->mdev,\n\t\t\t\t\t   maction->flow_action_raw.modify_hdr);\n\t\tbreak;\n\tcase MLX5_IB_FLOW_ACTION_PACKET_REFORMAT:\n\t\tmlx5_packet_reformat_dealloc(maction->flow_action_raw.dev->mdev,\n\t\t\t\t\t     maction->flow_action_raw.pkt_reformat);\n\t\tbreak;\n\tcase MLX5_IB_FLOW_ACTION_DECAP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int mlx5_ib_destroy_flow_action(struct ib_flow_action *action)\n{\n\tstruct mlx5_ib_flow_action *maction = to_mflow_act(action);\n\n\tswitch (action->type) {\n\tcase IB_FLOW_ACTION_UNSPECIFIED:\n\t\tdestroy_flow_action_raw(maction);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(true);\n\t\tbreak;\n\t}\n\n\tkfree(maction);\n\treturn 0;\n}\n\nstatic int\nmlx5_ib_ft_type_to_namespace(enum mlx5_ib_uapi_flow_table_type table_type,\n\t\t\t     enum mlx5_flow_namespace_type *namespace)\n{\n\tswitch (table_type) {\n\tcase MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_RX:\n\t\t*namespace = MLX5_FLOW_NAMESPACE_BYPASS;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_TX:\n\t\t*namespace = MLX5_FLOW_NAMESPACE_EGRESS;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_TABLE_TYPE_FDB:\n\t\t*namespace = MLX5_FLOW_NAMESPACE_FDB_BYPASS;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_RX:\n\t\t*namespace = MLX5_FLOW_NAMESPACE_RDMA_RX;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_TABLE_TYPE_RDMA_TX:\n\t\t*namespace = MLX5_FLOW_NAMESPACE_RDMA_TX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct uverbs_attr_spec mlx5_ib_flow_type[] = {\n\t[MLX5_IB_FLOW_TYPE_NORMAL] = {\n\t\t.type = UVERBS_ATTR_TYPE_PTR_IN,\n\t\t.u.ptr = {\n\t\t\t.len = sizeof(u16),  \n\t\t\t.min_len = sizeof(u16),\n\t\t}\n\t},\n\t[MLX5_IB_FLOW_TYPE_SNIFFER] = {\n\t\t.type = UVERBS_ATTR_TYPE_PTR_IN,\n\t\tUVERBS_ATTR_NO_DATA(),\n\t},\n\t[MLX5_IB_FLOW_TYPE_ALL_DEFAULT] = {\n\t\t.type = UVERBS_ATTR_TYPE_PTR_IN,\n\t\tUVERBS_ATTR_NO_DATA(),\n\t},\n\t[MLX5_IB_FLOW_TYPE_MC_DEFAULT] = {\n\t\t.type = UVERBS_ATTR_TYPE_PTR_IN,\n\t\tUVERBS_ATTR_NO_DATA(),\n\t},\n};\n\nstatic bool is_flow_dest(void *obj, int *dest_id, int *dest_type)\n{\n\tstruct devx_obj *devx_obj = obj;\n\tu16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);\n\n\tswitch (opcode) {\n\tcase MLX5_CMD_OP_DESTROY_TIR:\n\t\t*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t\t*dest_id = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox,\n\t\t\t\t    obj_id);\n\t\treturn true;\n\n\tcase MLX5_CMD_OP_DESTROY_FLOW_TABLE:\n\t\t*dest_type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\t\t*dest_id = MLX5_GET(destroy_flow_table_in, devx_obj->dinbox,\n\t\t\t\t    table_id);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int get_dests(struct uverbs_attr_bundle *attrs,\n\t\t     struct mlx5_ib_flow_matcher *fs_matcher, int *dest_id,\n\t\t     int *dest_type, struct ib_qp **qp, u32 *flags)\n{\n\tbool dest_devx, dest_qp;\n\tvoid *devx_obj;\n\tint err;\n\n\tdest_devx = uverbs_attr_is_valid(attrs,\n\t\t\t\t\t MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);\n\tdest_qp = uverbs_attr_is_valid(attrs,\n\t\t\t\t       MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);\n\n\t*flags = 0;\n\terr = uverbs_get_flags32(flags, attrs, MLX5_IB_ATTR_CREATE_FLOW_FLAGS,\n\t\t\t\t MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS |\n\t\t\t\t\t MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (*flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS &&\n\t    *flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)\n\t\treturn -EINVAL;\n\n\tif (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_BYPASS) {\n\t\tif (dest_devx && (dest_qp || *flags))\n\t\t\treturn -EINVAL;\n\t\telse if (dest_qp && *flags)\n\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_FDB_BYPASS &&\n\t    !(dest_devx || (*flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)))\n\t\treturn -EINVAL;\n\n\t \n\tif ((fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_RDMA_RX) &&\n\t    ((!dest_devx && !dest_qp) || (dest_devx && dest_qp)))\n\t\treturn -EINVAL;\n\n\t*qp = NULL;\n\tif (dest_devx) {\n\t\tdevx_obj =\n\t\t\tuverbs_attr_get_obj(attrs,\n\t\t\t\t\t    MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX);\n\n\t\t \n\t\tif (!is_flow_dest(devx_obj, dest_id, dest_type))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif ((fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_FDB_BYPASS ||\n\t\t     fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_RDMA_RX) &&\n\t\t    *dest_type != MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE)\n\t\t\treturn -EINVAL;\n\t} else if (dest_qp) {\n\t\tstruct mlx5_ib_qp *mqp;\n\n\t\t*qp = uverbs_attr_get_obj(attrs,\n\t\t\t\t\t  MLX5_IB_ATTR_CREATE_FLOW_DEST_QP);\n\t\tif (IS_ERR(*qp))\n\t\t\treturn PTR_ERR(*qp);\n\n\t\tif ((*qp)->qp_type != IB_QPT_RAW_PACKET)\n\t\t\treturn -EINVAL;\n\n\t\tmqp = to_mqp(*qp);\n\t\tif (mqp->is_rss)\n\t\t\t*dest_id = mqp->rss_qp.tirn;\n\t\telse\n\t\t\t*dest_id = mqp->raw_packet_qp.rq.tirn;\n\t\t*dest_type = MLX5_FLOW_DESTINATION_TYPE_TIR;\n\t} else if ((fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS ||\n\t\t    fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_RDMA_TX) &&\n\t\t   !(*flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)) {\n\t\t*dest_type = MLX5_FLOW_DESTINATION_TYPE_PORT;\n\t}\n\n\tif (*dest_type == MLX5_FLOW_DESTINATION_TYPE_TIR &&\n\t    (fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_EGRESS ||\n\t     fs_matcher->ns_type == MLX5_FLOW_NAMESPACE_RDMA_TX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic bool is_flow_counter(void *obj, u32 offset, u32 *counter_id)\n{\n\tstruct devx_obj *devx_obj = obj;\n\tu16 opcode = MLX5_GET(general_obj_in_cmd_hdr, devx_obj->dinbox, opcode);\n\n\tif (opcode == MLX5_CMD_OP_DEALLOC_FLOW_COUNTER) {\n\n\t\tif (offset && offset >= devx_obj->flow_counter_bulk_size)\n\t\t\treturn false;\n\n\t\t*counter_id = MLX5_GET(dealloc_flow_counter_in,\n\t\t\t\t       devx_obj->dinbox,\n\t\t\t\t       flow_counter_id);\n\t\t*counter_id += offset;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n#define MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS 2\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_CREATE_FLOW)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct mlx5_flow_context flow_context = {.flow_tag =\n\t\tMLX5_FS_DEFAULT_FLOW_TAG};\n\tu32 *offset_attr, offset = 0, counter_id = 0;\n\tint dest_id, dest_type = -1, inlen, len, ret, i;\n\tstruct mlx5_ib_flow_handler *flow_handler;\n\tstruct mlx5_ib_flow_matcher *fs_matcher;\n\tstruct ib_uobject **arr_flow_actions;\n\tstruct ib_uflow_resources *uflow_res;\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct ib_qp *qp = NULL;\n\tvoid *devx_obj, *cmd_in;\n\tstruct ib_uobject *uobj;\n\tstruct mlx5_ib_dev *dev;\n\tu32 flags;\n\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tfs_matcher = uverbs_attr_get_obj(attrs,\n\t\t\t\t\t MLX5_IB_ATTR_CREATE_FLOW_MATCHER);\n\tuobj =  uverbs_attr_get_uobject(attrs, MLX5_IB_ATTR_CREATE_FLOW_HANDLE);\n\tdev = mlx5_udata_to_mdev(&attrs->driver_udata);\n\n\tif (get_dests(attrs, fs_matcher, &dest_id, &dest_type, &qp, &flags))\n\t\treturn -EINVAL;\n\n\tif (flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DEFAULT_MISS)\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_FWD_NEXT_NS;\n\n\tif (flags & MLX5_IB_ATTR_CREATE_FLOW_FLAGS_DROP)\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_DROP;\n\n\tlen = uverbs_attr_get_uobjs_arr(attrs,\n\t\tMLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX, &arr_flow_actions);\n\tif (len) {\n\t\tdevx_obj = arr_flow_actions[0]->object;\n\n\t\tif (uverbs_attr_is_valid(attrs,\n\t\t\t\t\t MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX_OFFSET)) {\n\n\t\t\tint num_offsets = uverbs_attr_ptr_get_array_size(\n\t\t\t\tattrs,\n\t\t\t\tMLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX_OFFSET,\n\t\t\t\tsizeof(u32));\n\n\t\t\tif (num_offsets != 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\toffset_attr = uverbs_attr_get_alloced_ptr(\n\t\t\t\tattrs,\n\t\t\t\tMLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX_OFFSET);\n\t\t\toffset = *offset_attr;\n\t\t}\n\n\t\tif (!is_flow_counter(devx_obj, offset, &counter_id))\n\t\t\treturn -EINVAL;\n\n\t\tflow_act.action |= MLX5_FLOW_CONTEXT_ACTION_COUNT;\n\t}\n\n\tcmd_in = uverbs_attr_get_alloced_ptr(\n\t\tattrs, MLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE);\n\tinlen = uverbs_attr_get_len(attrs,\n\t\t\t\t    MLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE);\n\n\tuflow_res = flow_resources_alloc(MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS);\n\tif (!uflow_res)\n\t\treturn -ENOMEM;\n\n\tlen = uverbs_attr_get_uobjs_arr(attrs,\n\t\tMLX5_IB_ATTR_CREATE_FLOW_ARR_FLOW_ACTIONS, &arr_flow_actions);\n\tfor (i = 0; i < len; i++) {\n\t\tstruct mlx5_ib_flow_action *maction =\n\t\t\tto_mflow_act(arr_flow_actions[i]->object);\n\n\t\tret = parse_flow_flow_action(maction, false, &flow_act);\n\t\tif (ret)\n\t\t\tgoto err_out;\n\t\tflow_resources_add(uflow_res, IB_FLOW_SPEC_ACTION_HANDLE,\n\t\t\t\t   arr_flow_actions[i]->object);\n\t}\n\n\tret = uverbs_copy_from(&flow_context.flow_tag, attrs,\n\t\t\t       MLX5_IB_ATTR_CREATE_FLOW_TAG);\n\tif (!ret) {\n\t\tif (flow_context.flow_tag >= BIT(24)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tflow_context.flags |= FLOW_CONTEXT_HAS_TAG;\n\t}\n\n\tflow_handler =\n\t\traw_fs_rule_add(dev, fs_matcher, &flow_context, &flow_act,\n\t\t\t\tcounter_id, cmd_in, inlen, dest_id, dest_type);\n\tif (IS_ERR(flow_handler)) {\n\t\tret = PTR_ERR(flow_handler);\n\t\tgoto err_out;\n\t}\n\n\tib_set_flow(uobj, &flow_handler->ibflow, qp, &dev->ib_dev, uflow_res);\n\n\treturn 0;\nerr_out:\n\tib_uverbs_flow_resources_free(uflow_res);\n\treturn ret;\n}\n\nstatic int flow_matcher_cleanup(struct ib_uobject *uobject,\n\t\t\t\tenum rdma_remove_reason why,\n\t\t\t\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct mlx5_ib_flow_matcher *obj = uobject->object;\n\n\tif (atomic_read(&obj->usecnt))\n\t\treturn -EBUSY;\n\n\tkfree(obj);\n\treturn 0;\n}\n\nstatic int steering_anchor_create_ft(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_flow_prio *ft_prio,\n\t\t\t\t     enum mlx5_flow_namespace_type ns_type)\n{\n\tstruct mlx5_flow_table_attr ft_attr = {};\n\tstruct mlx5_flow_namespace *ns;\n\tstruct mlx5_flow_table *ft;\n\n\tif (ft_prio->anchor.ft)\n\t\treturn 0;\n\n\tns = mlx5_get_flow_namespace(dev->mdev, ns_type);\n\tif (!ns)\n\t\treturn -EOPNOTSUPP;\n\n\tft_attr.flags = MLX5_FLOW_TABLE_UNMANAGED;\n\tft_attr.uid = MLX5_SHARED_RESOURCE_UID;\n\tft_attr.prio = 0;\n\tft_attr.max_fte = 2;\n\tft_attr.level = 1;\n\n\tft = mlx5_create_flow_table(ns, &ft_attr);\n\tif (IS_ERR(ft))\n\t\treturn PTR_ERR(ft);\n\n\tft_prio->anchor.ft = ft;\n\n\treturn 0;\n}\n\nstatic void steering_anchor_destroy_ft(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tif (ft_prio->anchor.ft) {\n\t\tmlx5_destroy_flow_table(ft_prio->anchor.ft);\n\t\tft_prio->anchor.ft = NULL;\n\t}\n}\n\nstatic int\nsteering_anchor_create_fg_drop(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tvoid *flow_group_in;\n\tint err = 0;\n\n\tif (ft_prio->anchor.fg_drop)\n\t\treturn 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_flow_group_in, flow_group_in, start_flow_index, 1);\n\tMLX5_SET(create_flow_group_in, flow_group_in, end_flow_index, 1);\n\n\tfg = mlx5_create_flow_group(ft_prio->anchor.ft, flow_group_in);\n\tif (IS_ERR(fg)) {\n\t\terr = PTR_ERR(fg);\n\t\tgoto out;\n\t}\n\n\tft_prio->anchor.fg_drop = fg;\n\nout:\n\tkvfree(flow_group_in);\n\n\treturn err;\n}\n\nstatic void\nsteering_anchor_destroy_fg_drop(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tif (ft_prio->anchor.fg_drop) {\n\t\tmlx5_destroy_flow_group(ft_prio->anchor.fg_drop);\n\t\tft_prio->anchor.fg_drop = NULL;\n\t}\n}\n\nstatic int\nsteering_anchor_create_fg_goto_table(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tint inlen = MLX5_ST_SZ_BYTES(create_flow_group_in);\n\tstruct mlx5_flow_group *fg;\n\tvoid *flow_group_in;\n\tint err = 0;\n\n\tif (ft_prio->anchor.fg_goto_table)\n\t\treturn 0;\n\n\tflow_group_in = kvzalloc(inlen, GFP_KERNEL);\n\tif (!flow_group_in)\n\t\treturn -ENOMEM;\n\n\tfg = mlx5_create_flow_group(ft_prio->anchor.ft, flow_group_in);\n\tif (IS_ERR(fg)) {\n\t\terr = PTR_ERR(fg);\n\t\tgoto out;\n\t}\n\tft_prio->anchor.fg_goto_table = fg;\n\nout:\n\tkvfree(flow_group_in);\n\n\treturn err;\n}\n\nstatic void\nsteering_anchor_destroy_fg_goto_table(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tif (ft_prio->anchor.fg_goto_table) {\n\t\tmlx5_destroy_flow_group(ft_prio->anchor.fg_goto_table);\n\t\tft_prio->anchor.fg_goto_table = NULL;\n\t}\n}\n\nstatic int\nsteering_anchor_create_rule_drop(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *handle;\n\n\tif (ft_prio->anchor.rule_drop)\n\t\treturn 0;\n\n\tflow_act.fg = ft_prio->anchor.fg_drop;\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_DROP;\n\n\thandle = mlx5_add_flow_rules(ft_prio->anchor.ft, NULL, &flow_act,\n\t\t\t\t     NULL, 0);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tft_prio->anchor.rule_drop = handle;\n\n\treturn 0;\n}\n\nstatic void steering_anchor_destroy_rule_drop(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tif (ft_prio->anchor.rule_drop) {\n\t\tmlx5_del_flow_rules(ft_prio->anchor.rule_drop);\n\t\tft_prio->anchor.rule_drop = NULL;\n\t}\n}\n\nstatic int\nsteering_anchor_create_rule_goto_table(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tstruct mlx5_flow_destination dest = {};\n\tstruct mlx5_flow_act flow_act = {};\n\tstruct mlx5_flow_handle *handle;\n\n\tif (ft_prio->anchor.rule_goto_table)\n\t\treturn 0;\n\n\tflow_act.action = MLX5_FLOW_CONTEXT_ACTION_FWD_DEST;\n\tflow_act.flags |= FLOW_ACT_IGNORE_FLOW_LEVEL;\n\tflow_act.fg = ft_prio->anchor.fg_goto_table;\n\n\tdest.type = MLX5_FLOW_DESTINATION_TYPE_FLOW_TABLE;\n\tdest.ft = ft_prio->flow_table;\n\n\thandle = mlx5_add_flow_rules(ft_prio->anchor.ft, NULL, &flow_act,\n\t\t\t\t     &dest, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tft_prio->anchor.rule_goto_table = handle;\n\n\treturn 0;\n}\n\nstatic void\nsteering_anchor_destroy_rule_goto_table(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tif (ft_prio->anchor.rule_goto_table) {\n\t\tmlx5_del_flow_rules(ft_prio->anchor.rule_goto_table);\n\t\tft_prio->anchor.rule_goto_table = NULL;\n\t}\n}\n\nstatic int steering_anchor_create_res(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_flow_prio *ft_prio,\n\t\t\t\t      enum mlx5_flow_namespace_type ns_type)\n{\n\tint err;\n\n\terr = steering_anchor_create_ft(dev, ft_prio, ns_type);\n\tif (err)\n\t\treturn err;\n\n\terr = steering_anchor_create_fg_drop(ft_prio);\n\tif (err)\n\t\tgoto destroy_ft;\n\n\terr = steering_anchor_create_fg_goto_table(ft_prio);\n\tif (err)\n\t\tgoto destroy_fg_drop;\n\n\terr = steering_anchor_create_rule_drop(ft_prio);\n\tif (err)\n\t\tgoto destroy_fg_goto_table;\n\n\terr = steering_anchor_create_rule_goto_table(ft_prio);\n\tif (err)\n\t\tgoto destroy_rule_drop;\n\n\treturn 0;\n\ndestroy_rule_drop:\n\tsteering_anchor_destroy_rule_drop(ft_prio);\ndestroy_fg_goto_table:\n\tsteering_anchor_destroy_fg_goto_table(ft_prio);\ndestroy_fg_drop:\n\tsteering_anchor_destroy_fg_drop(ft_prio);\ndestroy_ft:\n\tsteering_anchor_destroy_ft(ft_prio);\n\n\treturn err;\n}\n\nstatic void mlx5_steering_anchor_destroy_res(struct mlx5_ib_flow_prio *ft_prio)\n{\n\tsteering_anchor_destroy_rule_goto_table(ft_prio);\n\tsteering_anchor_destroy_rule_drop(ft_prio);\n\tsteering_anchor_destroy_fg_goto_table(ft_prio);\n\tsteering_anchor_destroy_fg_drop(ft_prio);\n\tsteering_anchor_destroy_ft(ft_prio);\n}\n\nstatic int steering_anchor_cleanup(struct ib_uobject *uobject,\n\t\t\t\t   enum rdma_remove_reason why,\n\t\t\t\t   struct uverbs_attr_bundle *attrs)\n{\n\tstruct mlx5_ib_steering_anchor *obj = uobject->object;\n\n\tif (atomic_read(&obj->usecnt))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&obj->dev->flow_db->lock);\n\tif (!--obj->ft_prio->anchor.rule_goto_table_ref)\n\t\tsteering_anchor_destroy_rule_goto_table(obj->ft_prio);\n\n\tput_flow_table(obj->dev, obj->ft_prio, true);\n\tmutex_unlock(&obj->dev->flow_db->lock);\n\n\tkfree(obj);\n\treturn 0;\n}\n\nstatic void fs_cleanup_anchor(struct mlx5_ib_flow_prio *prio,\n\t\t\t      int count)\n{\n\twhile (count--)\n\t\tmlx5_steering_anchor_destroy_res(&prio[count]);\n}\n\nvoid mlx5_ib_fs_cleanup_anchor(struct mlx5_ib_dev *dev)\n{\n\tfs_cleanup_anchor(dev->flow_db->prios, MLX5_IB_NUM_FLOW_FT);\n\tfs_cleanup_anchor(dev->flow_db->egress_prios, MLX5_IB_NUM_FLOW_FT);\n\tfs_cleanup_anchor(dev->flow_db->sniffer, MLX5_IB_NUM_SNIFFER_FTS);\n\tfs_cleanup_anchor(dev->flow_db->egress, MLX5_IB_NUM_EGRESS_FTS);\n\tfs_cleanup_anchor(dev->flow_db->fdb, MLX5_IB_NUM_FDB_FTS);\n\tfs_cleanup_anchor(dev->flow_db->rdma_rx, MLX5_IB_NUM_FLOW_FT);\n\tfs_cleanup_anchor(dev->flow_db->rdma_tx, MLX5_IB_NUM_FLOW_FT);\n}\n\nstatic int mlx5_ib_matcher_ns(struct uverbs_attr_bundle *attrs,\n\t\t\t      struct mlx5_ib_flow_matcher *obj)\n{\n\tenum mlx5_ib_uapi_flow_table_type ft_type =\n\t\tMLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_RX;\n\tu32 flags;\n\tint err;\n\n\t \n\tif (uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_FLOW_MATCHER_FT_TYPE) &&\n\t    uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_FLOW_MATCHER_FLOW_FLAGS))\n\t\treturn -EINVAL;\n\n\tif (uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_FLOW_MATCHER_FT_TYPE)) {\n\t\terr = uverbs_get_const(&ft_type, attrs,\n\t\t\t\t       MLX5_IB_ATTR_FLOW_MATCHER_FT_TYPE);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mlx5_ib_ft_type_to_namespace(ft_type, &obj->ns_type);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\treturn 0;\n\t}\n\n\tif (uverbs_attr_is_valid(attrs, MLX5_IB_ATTR_FLOW_MATCHER_FLOW_FLAGS)) {\n\t\terr = uverbs_get_flags32(&flags, attrs,\n\t\t\t\t\t MLX5_IB_ATTR_FLOW_MATCHER_FLOW_FLAGS,\n\t\t\t\t\t IB_FLOW_ATTR_FLAGS_EGRESS);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (flags)\n\t\t\treturn mlx5_ib_ft_type_to_namespace(\n\t\t\t\tMLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_TX,\n\t\t\t\t&obj->ns_type);\n\t}\n\n\tobj->ns_type = MLX5_FLOW_NAMESPACE_BYPASS;\n\n\treturn 0;\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_FLOW_MATCHER_CREATE)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(\n\t\tattrs, MLX5_IB_ATTR_FLOW_MATCHER_CREATE_HANDLE);\n\tstruct mlx5_ib_dev *dev = mlx5_udata_to_mdev(&attrs->driver_udata);\n\tstruct mlx5_ib_flow_matcher *obj;\n\tint err;\n\n\tobj = kzalloc(sizeof(struct mlx5_ib_flow_matcher), GFP_KERNEL);\n\tif (!obj)\n\t\treturn -ENOMEM;\n\n\tobj->mask_len = uverbs_attr_get_len(\n\t\tattrs, MLX5_IB_ATTR_FLOW_MATCHER_MATCH_MASK);\n\terr = uverbs_copy_from(&obj->matcher_mask,\n\t\t\t       attrs,\n\t\t\t       MLX5_IB_ATTR_FLOW_MATCHER_MATCH_MASK);\n\tif (err)\n\t\tgoto end;\n\n\tobj->flow_type = uverbs_attr_get_enum_id(\n\t\tattrs, MLX5_IB_ATTR_FLOW_MATCHER_FLOW_TYPE);\n\n\tif (obj->flow_type == MLX5_IB_FLOW_TYPE_NORMAL) {\n\t\terr = uverbs_copy_from(&obj->priority,\n\t\t\t\t       attrs,\n\t\t\t\t       MLX5_IB_ATTR_FLOW_MATCHER_FLOW_TYPE);\n\t\tif (err)\n\t\t\tgoto end;\n\t}\n\n\terr = uverbs_copy_from(&obj->match_criteria_enable,\n\t\t\t       attrs,\n\t\t\t       MLX5_IB_ATTR_FLOW_MATCHER_MATCH_CRITERIA);\n\tif (err)\n\t\tgoto end;\n\n\terr = mlx5_ib_matcher_ns(attrs, obj);\n\tif (err)\n\t\tgoto end;\n\n\tif (obj->ns_type == MLX5_FLOW_NAMESPACE_FDB_BYPASS &&\n\t    mlx5_eswitch_mode(dev->mdev) != MLX5_ESWITCH_OFFLOADS) {\n\t\terr = -EINVAL;\n\t\tgoto end;\n\t}\n\n\tuobj->object = obj;\n\tobj->mdev = dev->mdev;\n\tatomic_set(&obj->usecnt, 0);\n\treturn 0;\n\nend:\n\tkfree(obj);\n\treturn err;\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_STEERING_ANCHOR_CREATE)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(\n\t\tattrs, MLX5_IB_ATTR_STEERING_ANCHOR_CREATE_HANDLE);\n\tstruct mlx5_ib_dev *dev = mlx5_udata_to_mdev(&attrs->driver_udata);\n\tenum mlx5_ib_uapi_flow_table_type ib_uapi_ft_type;\n\tenum mlx5_flow_namespace_type ns_type;\n\tstruct mlx5_ib_steering_anchor *obj;\n\tstruct mlx5_ib_flow_prio *ft_prio;\n\tu16 priority;\n\tu32 ft_id;\n\tint err;\n\n\tif (!capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\terr = uverbs_get_const(&ib_uapi_ft_type, attrs,\n\t\t\t       MLX5_IB_ATTR_STEERING_ANCHOR_FT_TYPE);\n\tif (err)\n\t\treturn err;\n\n\terr = mlx5_ib_ft_type_to_namespace(ib_uapi_ft_type, &ns_type);\n\tif (err)\n\t\treturn err;\n\n\terr = uverbs_copy_from(&priority, attrs,\n\t\t\t       MLX5_IB_ATTR_STEERING_ANCHOR_PRIORITY);\n\tif (err)\n\t\treturn err;\n\n\tobj = kzalloc(sizeof(*obj), GFP_KERNEL);\n\tif (!obj)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->flow_db->lock);\n\n\tft_prio = _get_flow_table(dev, priority, ns_type, 0);\n\tif (IS_ERR(ft_prio)) {\n\t\terr = PTR_ERR(ft_prio);\n\t\tgoto free_obj;\n\t}\n\n\tft_prio->refcount++;\n\n\tif (!ft_prio->anchor.rule_goto_table_ref) {\n\t\terr = steering_anchor_create_res(dev, ft_prio, ns_type);\n\t\tif (err)\n\t\t\tgoto put_flow_table;\n\t}\n\n\tft_prio->anchor.rule_goto_table_ref++;\n\n\tft_id = mlx5_flow_table_id(ft_prio->anchor.ft);\n\n\terr = uverbs_copy_to(attrs, MLX5_IB_ATTR_STEERING_ANCHOR_FT_ID,\n\t\t\t     &ft_id, sizeof(ft_id));\n\tif (err)\n\t\tgoto destroy_res;\n\n\tmutex_unlock(&dev->flow_db->lock);\n\n\tuobj->object = obj;\n\tobj->dev = dev;\n\tobj->ft_prio = ft_prio;\n\tatomic_set(&obj->usecnt, 0);\n\n\treturn 0;\n\ndestroy_res:\n\t--ft_prio->anchor.rule_goto_table_ref;\n\tmlx5_steering_anchor_destroy_res(ft_prio);\nput_flow_table:\n\tput_flow_table(dev, ft_prio, true);\nfree_obj:\n\tmutex_unlock(&dev->flow_db->lock);\n\tkfree(obj);\n\n\treturn err;\n}\n\nstatic struct ib_flow_action *\nmlx5_ib_create_modify_header(struct mlx5_ib_dev *dev,\n\t\t\t     enum mlx5_ib_uapi_flow_table_type ft_type,\n\t\t\t     u8 num_actions, void *in)\n{\n\tenum mlx5_flow_namespace_type namespace;\n\tstruct mlx5_ib_flow_action *maction;\n\tint ret;\n\n\tret = mlx5_ib_ft_type_to_namespace(ft_type, &namespace);\n\tif (ret)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmaction = kzalloc(sizeof(*maction), GFP_KERNEL);\n\tif (!maction)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmaction->flow_action_raw.modify_hdr =\n\t\tmlx5_modify_header_alloc(dev->mdev, namespace, num_actions, in);\n\n\tif (IS_ERR(maction->flow_action_raw.modify_hdr)) {\n\t\tret = PTR_ERR(maction->flow_action_raw.modify_hdr);\n\t\tkfree(maction);\n\t\treturn ERR_PTR(ret);\n\t}\n\tmaction->flow_action_raw.sub_type =\n\t\tMLX5_IB_FLOW_ACTION_MODIFY_HEADER;\n\tmaction->flow_action_raw.dev = dev;\n\n\treturn &maction->ib_action;\n}\n\nstatic bool mlx5_ib_modify_header_supported(struct mlx5_ib_dev *dev)\n{\n\treturn MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev,\n\t\t\t\t\t max_modify_header_actions) ||\n\t       MLX5_CAP_FLOWTABLE_NIC_TX(dev->mdev,\n\t\t\t\t\t max_modify_header_actions) ||\n\t       MLX5_CAP_FLOWTABLE_RDMA_TX(dev->mdev,\n\t\t\t\t\t max_modify_header_actions);\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_FLOW_ACTION_CREATE_MODIFY_HEADER)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(\n\t\tattrs, MLX5_IB_ATTR_CREATE_MODIFY_HEADER_HANDLE);\n\tstruct mlx5_ib_dev *mdev = mlx5_udata_to_mdev(&attrs->driver_udata);\n\tenum mlx5_ib_uapi_flow_table_type ft_type;\n\tstruct ib_flow_action *action;\n\tint num_actions;\n\tvoid *in;\n\tint ret;\n\n\tif (!mlx5_ib_modify_header_supported(mdev))\n\t\treturn -EOPNOTSUPP;\n\n\tin = uverbs_attr_get_alloced_ptr(attrs,\n\t\tMLX5_IB_ATTR_CREATE_MODIFY_HEADER_ACTIONS_PRM);\n\n\tnum_actions = uverbs_attr_ptr_get_array_size(\n\t\tattrs, MLX5_IB_ATTR_CREATE_MODIFY_HEADER_ACTIONS_PRM,\n\t\tMLX5_UN_SZ_BYTES(set_add_copy_action_in_auto));\n\tif (num_actions < 0)\n\t\treturn num_actions;\n\n\tret = uverbs_get_const(&ft_type, attrs,\n\t\t\t       MLX5_IB_ATTR_CREATE_MODIFY_HEADER_FT_TYPE);\n\tif (ret)\n\t\treturn ret;\n\taction = mlx5_ib_create_modify_header(mdev, ft_type, num_actions, in);\n\tif (IS_ERR(action))\n\t\treturn PTR_ERR(action);\n\n\tuverbs_flow_action_fill_action(action, uobj, &mdev->ib_dev,\n\t\t\t\t       IB_FLOW_ACTION_UNSPECIFIED);\n\n\treturn 0;\n}\n\nstatic bool mlx5_ib_flow_action_packet_reformat_valid(struct mlx5_ib_dev *ibdev,\n\t\t\t\t\t\t      u8 packet_reformat_type,\n\t\t\t\t\t\t      u8 ft_type)\n{\n\tswitch (packet_reformat_type) {\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L2_TUNNEL:\n\t\tif (ft_type == MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_TX)\n\t\t\treturn MLX5_CAP_FLOWTABLE(ibdev->mdev,\n\t\t\t\t\t\t  encap_general_header);\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L3_TUNNEL:\n\t\tif (ft_type == MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_TX)\n\t\t\treturn MLX5_CAP_FLOWTABLE_NIC_TX(ibdev->mdev,\n\t\t\t\treformat_l2_to_l3_tunnel);\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L3_TUNNEL_TO_L2:\n\t\tif (ft_type == MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_RX)\n\t\t\treturn MLX5_CAP_FLOWTABLE_NIC_RX(ibdev->mdev,\n\t\t\t\treformat_l3_tunnel_to_l2);\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TUNNEL_TO_L2:\n\t\tif (ft_type == MLX5_IB_UAPI_FLOW_TABLE_TYPE_NIC_RX)\n\t\t\treturn MLX5_CAP_FLOWTABLE_NIC_RX(ibdev->mdev, decap);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic int mlx5_ib_dv_to_prm_packet_reforamt_type(u8 dv_prt, u8 *prm_prt)\n{\n\tswitch (dv_prt) {\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L2_TUNNEL:\n\t\t*prm_prt = MLX5_REFORMAT_TYPE_L2_TO_L2_TUNNEL;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L3_TUNNEL_TO_L2:\n\t\t*prm_prt = MLX5_REFORMAT_TYPE_L3_TUNNEL_TO_L2;\n\t\tbreak;\n\tcase MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TO_L3_TUNNEL:\n\t\t*prm_prt = MLX5_REFORMAT_TYPE_L2_TO_L3_TUNNEL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mlx5_ib_flow_action_create_packet_reformat_ctx(\n\tstruct mlx5_ib_dev *dev,\n\tstruct mlx5_ib_flow_action *maction,\n\tu8 ft_type, u8 dv_prt,\n\tvoid *in, size_t len)\n{\n\tstruct mlx5_pkt_reformat_params reformat_params;\n\tenum mlx5_flow_namespace_type namespace;\n\tu8 prm_prt;\n\tint ret;\n\n\tret = mlx5_ib_ft_type_to_namespace(ft_type, &namespace);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mlx5_ib_dv_to_prm_packet_reforamt_type(dv_prt, &prm_prt);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&reformat_params, 0, sizeof(reformat_params));\n\treformat_params.type = prm_prt;\n\treformat_params.size = len;\n\treformat_params.data = in;\n\tmaction->flow_action_raw.pkt_reformat =\n\t\tmlx5_packet_reformat_alloc(dev->mdev, &reformat_params,\n\t\t\t\t\t   namespace);\n\tif (IS_ERR(maction->flow_action_raw.pkt_reformat)) {\n\t\tret = PTR_ERR(maction->flow_action_raw.pkt_reformat);\n\t\treturn ret;\n\t}\n\n\tmaction->flow_action_raw.sub_type =\n\t\tMLX5_IB_FLOW_ACTION_PACKET_REFORMAT;\n\tmaction->flow_action_raw.dev = dev;\n\n\treturn 0;\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_FLOW_ACTION_CREATE_PACKET_REFORMAT)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,\n\t\tMLX5_IB_ATTR_CREATE_PACKET_REFORMAT_HANDLE);\n\tstruct mlx5_ib_dev *mdev = mlx5_udata_to_mdev(&attrs->driver_udata);\n\tenum mlx5_ib_uapi_flow_action_packet_reformat_type dv_prt;\n\tenum mlx5_ib_uapi_flow_table_type ft_type;\n\tstruct mlx5_ib_flow_action *maction;\n\tint ret;\n\n\tret = uverbs_get_const(&ft_type, attrs,\n\t\t\t       MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_FT_TYPE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = uverbs_get_const(&dv_prt, attrs,\n\t\t\t       MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_TYPE);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!mlx5_ib_flow_action_packet_reformat_valid(mdev, dv_prt, ft_type))\n\t\treturn -EOPNOTSUPP;\n\n\tmaction = kzalloc(sizeof(*maction), GFP_KERNEL);\n\tif (!maction)\n\t\treturn -ENOMEM;\n\n\tif (dv_prt ==\n\t    MLX5_IB_UAPI_FLOW_ACTION_PACKET_REFORMAT_TYPE_L2_TUNNEL_TO_L2) {\n\t\tmaction->flow_action_raw.sub_type =\n\t\t\tMLX5_IB_FLOW_ACTION_DECAP;\n\t\tmaction->flow_action_raw.dev = mdev;\n\t} else {\n\t\tvoid *in;\n\t\tint len;\n\n\t\tin = uverbs_attr_get_alloced_ptr(attrs,\n\t\t\tMLX5_IB_ATTR_CREATE_PACKET_REFORMAT_DATA_BUF);\n\t\tif (IS_ERR(in)) {\n\t\t\tret = PTR_ERR(in);\n\t\t\tgoto free_maction;\n\t\t}\n\n\t\tlen = uverbs_attr_get_len(attrs,\n\t\t\tMLX5_IB_ATTR_CREATE_PACKET_REFORMAT_DATA_BUF);\n\n\t\tret = mlx5_ib_flow_action_create_packet_reformat_ctx(mdev,\n\t\t\tmaction, ft_type, dv_prt, in, len);\n\t\tif (ret)\n\t\t\tgoto free_maction;\n\t}\n\n\tuverbs_flow_action_fill_action(&maction->ib_action, uobj, &mdev->ib_dev,\n\t\t\t\t       IB_FLOW_ACTION_UNSPECIFIED);\n\treturn 0;\n\nfree_maction:\n\tkfree(maction);\n\treturn ret;\n}\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_CREATE_FLOW,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_FLOW_HANDLE,\n\t\t\tUVERBS_OBJECT_FLOW,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(\n\t\tMLX5_IB_ATTR_CREATE_FLOW_MATCH_VALUE,\n\t\tUVERBS_ATTR_SIZE(1, sizeof(struct mlx5_ib_match_params)),\n\t\tUA_MANDATORY,\n\t\tUA_ALLOC_AND_COPY),\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_FLOW_MATCHER,\n\t\t\tMLX5_IB_OBJECT_FLOW_MATCHER,\n\t\t\tUVERBS_ACCESS_READ,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_FLOW_DEST_QP,\n\t\t\tUVERBS_OBJECT_QP,\n\t\t\tUVERBS_ACCESS_READ),\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_FLOW_DEST_DEVX,\n\t\t\tMLX5_IB_OBJECT_DEVX_OBJ,\n\t\t\tUVERBS_ACCESS_READ),\n\tUVERBS_ATTR_IDRS_ARR(MLX5_IB_ATTR_CREATE_FLOW_ARR_FLOW_ACTIONS,\n\t\t\t     UVERBS_OBJECT_FLOW_ACTION,\n\t\t\t     UVERBS_ACCESS_READ, 1,\n\t\t\t     MLX5_IB_CREATE_FLOW_MAX_FLOW_ACTIONS,\n\t\t\t     UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_TAG,\n\t\t\t   UVERBS_ATTR_TYPE(u32),\n\t\t\t   UA_OPTIONAL),\n\tUVERBS_ATTR_IDRS_ARR(MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX,\n\t\t\t     MLX5_IB_OBJECT_DEVX_OBJ,\n\t\t\t     UVERBS_ACCESS_READ, 1, 1,\n\t\t\t     UA_OPTIONAL),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_FLOW_ARR_COUNTERS_DEVX_OFFSET,\n\t\t\t   UVERBS_ATTR_MIN_SIZE(sizeof(u32)),\n\t\t\t   UA_OPTIONAL,\n\t\t\t   UA_ALLOC_AND_COPY),\n\tUVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_CREATE_FLOW_FLAGS,\n\t\t\t     enum mlx5_ib_create_flow_flags,\n\t\t\t     UA_OPTIONAL));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tMLX5_IB_METHOD_DESTROY_FLOW,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_FLOW_HANDLE,\n\t\t\tUVERBS_OBJECT_FLOW,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nADD_UVERBS_METHODS(mlx5_ib_fs,\n\t\t   UVERBS_OBJECT_FLOW,\n\t\t   &UVERBS_METHOD(MLX5_IB_METHOD_CREATE_FLOW),\n\t\t   &UVERBS_METHOD(MLX5_IB_METHOD_DESTROY_FLOW));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_FLOW_ACTION_CREATE_MODIFY_HEADER,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_MODIFY_HEADER_HANDLE,\n\t\t\tUVERBS_OBJECT_FLOW_ACTION,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_MODIFY_HEADER_ACTIONS_PRM,\n\t\t\t   UVERBS_ATTR_MIN_SIZE(MLX5_UN_SZ_BYTES(\n\t\t\t\t   set_add_copy_action_in_auto)),\n\t\t\t   UA_MANDATORY,\n\t\t\t   UA_ALLOC_AND_COPY),\n\tUVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_CREATE_MODIFY_HEADER_FT_TYPE,\n\t\t\t     enum mlx5_ib_uapi_flow_table_type,\n\t\t\t     UA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_FLOW_ACTION_CREATE_PACKET_REFORMAT,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_HANDLE,\n\t\t\tUVERBS_OBJECT_FLOW_ACTION,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_DATA_BUF,\n\t\t\t   UVERBS_ATTR_MIN_SIZE(1),\n\t\t\t   UA_ALLOC_AND_COPY,\n\t\t\t   UA_OPTIONAL),\n\tUVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_TYPE,\n\t\t\t     enum mlx5_ib_uapi_flow_action_packet_reformat_type,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_CREATE_PACKET_REFORMAT_FT_TYPE,\n\t\t\t     enum mlx5_ib_uapi_flow_table_type,\n\t\t\t     UA_MANDATORY));\n\nADD_UVERBS_METHODS(\n\tmlx5_ib_flow_actions,\n\tUVERBS_OBJECT_FLOW_ACTION,\n\t&UVERBS_METHOD(MLX5_IB_METHOD_FLOW_ACTION_CREATE_MODIFY_HEADER),\n\t&UVERBS_METHOD(MLX5_IB_METHOD_FLOW_ACTION_CREATE_PACKET_REFORMAT));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_FLOW_MATCHER_CREATE,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_FLOW_MATCHER_CREATE_HANDLE,\n\t\t\tMLX5_IB_OBJECT_FLOW_MATCHER,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(\n\t\tMLX5_IB_ATTR_FLOW_MATCHER_MATCH_MASK,\n\t\tUVERBS_ATTR_SIZE(1, sizeof(struct mlx5_ib_match_params)),\n\t\tUA_MANDATORY),\n\tUVERBS_ATTR_ENUM_IN(MLX5_IB_ATTR_FLOW_MATCHER_FLOW_TYPE,\n\t\t\t    mlx5_ib_flow_type,\n\t\t\t    UA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_FLOW_MATCHER_MATCH_CRITERIA,\n\t\t\t   UVERBS_ATTR_TYPE(u8),\n\t\t\t   UA_MANDATORY),\n\tUVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_FLOW_MATCHER_FLOW_FLAGS,\n\t\t\t     enum ib_flow_flags,\n\t\t\t     UA_OPTIONAL),\n\tUVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_FLOW_MATCHER_FT_TYPE,\n\t\t\t     enum mlx5_ib_uapi_flow_table_type,\n\t\t\t     UA_OPTIONAL));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tMLX5_IB_METHOD_FLOW_MATCHER_DESTROY,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_FLOW_MATCHER_DESTROY_HANDLE,\n\t\t\tMLX5_IB_OBJECT_FLOW_MATCHER,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_FLOW_MATCHER,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(flow_matcher_cleanup),\n\t\t\t    &UVERBS_METHOD(MLX5_IB_METHOD_FLOW_MATCHER_CREATE),\n\t\t\t    &UVERBS_METHOD(MLX5_IB_METHOD_FLOW_MATCHER_DESTROY));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_STEERING_ANCHOR_CREATE,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_STEERING_ANCHOR_CREATE_HANDLE,\n\t\t\tMLX5_IB_OBJECT_STEERING_ANCHOR,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_CONST_IN(MLX5_IB_ATTR_STEERING_ANCHOR_FT_TYPE,\n\t\t\t     enum mlx5_ib_uapi_flow_table_type,\n\t\t\t     UA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_STEERING_ANCHOR_PRIORITY,\n\t\t\t   UVERBS_ATTR_TYPE(u16),\n\t\t\t   UA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_STEERING_ANCHOR_FT_ID,\n\t\t\t   UVERBS_ATTR_TYPE(u32),\n\t\t\t   UA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tMLX5_IB_METHOD_STEERING_ANCHOR_DESTROY,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_STEERING_ANCHOR_DESTROY_HANDLE,\n\t\t\tMLX5_IB_OBJECT_STEERING_ANCHOR,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(\n\tMLX5_IB_OBJECT_STEERING_ANCHOR,\n\tUVERBS_TYPE_ALLOC_IDR(steering_anchor_cleanup),\n\t&UVERBS_METHOD(MLX5_IB_METHOD_STEERING_ANCHOR_CREATE),\n\t&UVERBS_METHOD(MLX5_IB_METHOD_STEERING_ANCHOR_DESTROY));\n\nconst struct uapi_definition mlx5_ib_flow_defs[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(\n\t\tMLX5_IB_OBJECT_FLOW_MATCHER),\n\tUAPI_DEF_CHAIN_OBJ_TREE(\n\t\tUVERBS_OBJECT_FLOW,\n\t\t&mlx5_ib_fs),\n\tUAPI_DEF_CHAIN_OBJ_TREE(UVERBS_OBJECT_FLOW_ACTION,\n\t\t\t\t&mlx5_ib_flow_actions),\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(\n\t\tMLX5_IB_OBJECT_STEERING_ANCHOR,\n\t\tUAPI_DEF_IS_OBJ_SUPPORTED(mlx5_ib_shared_ft_allowed)),\n\t{},\n};\n\nstatic const struct ib_device_ops flow_ops = {\n\t.create_flow = mlx5_ib_create_flow,\n\t.destroy_flow = mlx5_ib_destroy_flow,\n\t.destroy_flow_action = mlx5_ib_destroy_flow_action,\n};\n\nint mlx5_ib_fs_init(struct mlx5_ib_dev *dev)\n{\n\tdev->flow_db = kzalloc(sizeof(*dev->flow_db), GFP_KERNEL);\n\n\tif (!dev->flow_db)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->flow_db->lock);\n\n\tib_set_device_ops(&dev->ib_dev, &flow_ops);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}