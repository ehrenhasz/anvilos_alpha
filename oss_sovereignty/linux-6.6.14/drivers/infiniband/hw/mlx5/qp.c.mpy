{
  "module_name": "qp.c",
  "hash_id": "8af9492e99d3dfcc427f093bb84c73f2c70e6858b8bff45ec3cd33d23a361724",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/qp.c",
  "human_readable_source": " \n\n#include <linux/etherdevice.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/rdma_counter.h>\n#include <linux/mlx5/fs.h>\n#include \"mlx5_ib.h\"\n#include \"ib_rep.h\"\n#include \"counters.h\"\n#include \"cmd.h\"\n#include \"umr.h\"\n#include \"qp.h\"\n#include \"wr.h\"\n\nenum {\n\tMLX5_IB_ACK_REQ_FREQ\t= 8,\n};\n\nenum {\n\tMLX5_IB_DEFAULT_SCHED_QUEUE\t= 0x83,\n\tMLX5_IB_DEFAULT_QP0_SCHED_QUEUE\t= 0x3f,\n\tMLX5_IB_LINK_TYPE_IB\t\t= 0,\n\tMLX5_IB_LINK_TYPE_ETH\t\t= 1\n};\n\nenum raw_qp_set_mask_map {\n\tMLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID\t\t= 1UL << 0,\n\tMLX5_RAW_QP_RATE_LIMIT\t\t\t= 1UL << 1,\n};\n\nenum {\n\tMLX5_QP_RM_GO_BACK_N\t\t\t= 0x1,\n};\n\nstruct mlx5_modify_raw_qp_param {\n\tu16 operation;\n\n\tu32 set_mask;  \n\n\tstruct mlx5_rate_limit rl;\n\n\tu8 rq_q_ctr_id;\n\tu32 port;\n};\n\nstruct mlx5_ib_qp_event_work {\n\tstruct work_struct work;\n\tstruct mlx5_core_qp *qp;\n\tint type;\n};\n\nstatic struct workqueue_struct *mlx5_ib_qp_event_wq;\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq);\n\nstatic int is_qp0(enum ib_qp_type qp_type)\n{\n\treturn qp_type == IB_QPT_SMI;\n}\n\nstatic int is_sqp(enum ib_qp_type qp_type)\n{\n\treturn is_qp0(qp_type) || is_qp1(qp_type);\n}\n\n \nstatic int mlx5_ib_read_user_wqe_common(struct ib_umem *umem, void *buffer,\n\t\t\t\t\tsize_t buflen, int wqe_index,\n\t\t\t\t\tint wq_offset, int wq_wqe_cnt,\n\t\t\t\t\tint wq_wqe_shift, int bcnt,\n\t\t\t\t\tsize_t *bytes_copied)\n{\n\tsize_t offset = wq_offset + ((wqe_index % wq_wqe_cnt) << wq_wqe_shift);\n\tsize_t wq_end = wq_offset + (wq_wqe_cnt << wq_wqe_shift);\n\tsize_t copy_length;\n\tint ret;\n\n\t \n\tcopy_length = min_t(u32, buflen, wq_end - offset);\n\tcopy_length = min_t(u32, copy_length, bcnt);\n\n\tret = ib_umem_copy_from(buffer, umem, offset, copy_length);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ret && bytes_copied)\n\t\t*bytes_copied = copy_length;\n\n\treturn 0;\n}\n\nstatic int mlx5_ib_read_kernel_wqe_sq(struct mlx5_ib_qp *qp, int wqe_index,\n\t\t\t\t      void *buffer, size_t buflen, size_t *bc)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tsize_t bytes_copied = 0;\n\tsize_t wqe_length;\n\tvoid *p;\n\tint ds;\n\n\twqe_index = wqe_index & qp->sq.fbc.sz_m1;\n\n\t \n\tp = mlx5_frag_buf_get_wqe(&qp->sq.fbc, wqe_index);\n\tctrl = p;\n\tds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\n\twqe_length = ds * MLX5_WQE_DS_UNITS;\n\n\t \n\twhile (bytes_copied < wqe_length) {\n\t\tsize_t copy_length =\n\t\t\tmin_t(size_t, buflen - bytes_copied, MLX5_SEND_WQE_BB);\n\n\t\tif (!copy_length)\n\t\t\tbreak;\n\n\t\tmemcpy(buffer + bytes_copied, p, copy_length);\n\t\tbytes_copied += copy_length;\n\n\t\twqe_index = (wqe_index + 1) & qp->sq.fbc.sz_m1;\n\t\tp = mlx5_frag_buf_get_wqe(&qp->sq.fbc, wqe_index);\n\t}\n\t*bc = bytes_copied;\n\treturn 0;\n}\n\nstatic int mlx5_ib_read_user_wqe_sq(struct mlx5_ib_qp *qp, int wqe_index,\n\t\t\t\t    void *buffer, size_t buflen, size_t *bc)\n{\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\tstruct mlx5_ib_wq *wq = &qp->sq;\n\tstruct mlx5_wqe_ctrl_seg *ctrl;\n\tsize_t bytes_copied;\n\tsize_t bytes_copied2;\n\tsize_t wqe_length;\n\tint ret;\n\tint ds;\n\n\t \n\tret = mlx5_ib_read_user_wqe_common(umem, buffer, buflen, wqe_index,\n\t\t\t\t\t   wq->offset, wq->wqe_cnt,\n\t\t\t\t\t   wq->wqe_shift, buflen,\n\t\t\t\t\t   &bytes_copied);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (bytes_copied < sizeof(*ctrl))\n\t\treturn -EINVAL;\n\n\tctrl = buffer;\n\tds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\n\twqe_length = ds * MLX5_WQE_DS_UNITS;\n\n\t \n\tif (bytes_copied >= wqe_length) {\n\t\t*bc = bytes_copied;\n\t\treturn 0;\n\t}\n\n\t \n\tret = mlx5_ib_read_user_wqe_common(umem, buffer + bytes_copied,\n\t\t\t\t\t   buflen - bytes_copied, 0, wq->offset,\n\t\t\t\t\t   wq->wqe_cnt, wq->wqe_shift,\n\t\t\t\t\t   wqe_length - bytes_copied,\n\t\t\t\t\t   &bytes_copied2);\n\n\tif (ret)\n\t\treturn ret;\n\t*bc = bytes_copied + bytes_copied2;\n\treturn 0;\n}\n\nint mlx5_ib_read_wqe_sq(struct mlx5_ib_qp *qp, int wqe_index, void *buffer,\n\t\t\tsize_t buflen, size_t *bc)\n{\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\n\tif (buflen < sizeof(struct mlx5_wqe_ctrl_seg))\n\t\treturn -EINVAL;\n\n\tif (!umem)\n\t\treturn mlx5_ib_read_kernel_wqe_sq(qp, wqe_index, buffer,\n\t\t\t\t\t\t  buflen, bc);\n\n\treturn mlx5_ib_read_user_wqe_sq(qp, wqe_index, buffer, buflen, bc);\n}\n\nstatic int mlx5_ib_read_user_wqe_rq(struct mlx5_ib_qp *qp, int wqe_index,\n\t\t\t\t    void *buffer, size_t buflen, size_t *bc)\n{\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\tstruct mlx5_ib_wq *wq = &qp->rq;\n\tsize_t bytes_copied;\n\tint ret;\n\n\tret = mlx5_ib_read_user_wqe_common(umem, buffer, buflen, wqe_index,\n\t\t\t\t\t   wq->offset, wq->wqe_cnt,\n\t\t\t\t\t   wq->wqe_shift, buflen,\n\t\t\t\t\t   &bytes_copied);\n\n\tif (ret)\n\t\treturn ret;\n\t*bc = bytes_copied;\n\treturn 0;\n}\n\nint mlx5_ib_read_wqe_rq(struct mlx5_ib_qp *qp, int wqe_index, void *buffer,\n\t\t\tsize_t buflen, size_t *bc)\n{\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct ib_umem *umem = base->ubuffer.umem;\n\tstruct mlx5_ib_wq *wq = &qp->rq;\n\tsize_t wqe_size = 1 << wq->wqe_shift;\n\n\tif (buflen < wqe_size)\n\t\treturn -EINVAL;\n\n\tif (!umem)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_ib_read_user_wqe_rq(qp, wqe_index, buffer, buflen, bc);\n}\n\nstatic int mlx5_ib_read_user_wqe_srq(struct mlx5_ib_srq *srq, int wqe_index,\n\t\t\t\t     void *buffer, size_t buflen, size_t *bc)\n{\n\tstruct ib_umem *umem = srq->umem;\n\tsize_t bytes_copied;\n\tint ret;\n\n\tret = mlx5_ib_read_user_wqe_common(umem, buffer, buflen, wqe_index, 0,\n\t\t\t\t\t   srq->msrq.max, srq->msrq.wqe_shift,\n\t\t\t\t\t   buflen, &bytes_copied);\n\n\tif (ret)\n\t\treturn ret;\n\t*bc = bytes_copied;\n\treturn 0;\n}\n\nint mlx5_ib_read_wqe_srq(struct mlx5_ib_srq *srq, int wqe_index, void *buffer,\n\t\t\t size_t buflen, size_t *bc)\n{\n\tstruct ib_umem *umem = srq->umem;\n\tsize_t wqe_size = 1 << srq->msrq.wqe_shift;\n\n\tif (buflen < wqe_size)\n\t\treturn -EINVAL;\n\n\tif (!umem)\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_ib_read_user_wqe_srq(srq, wqe_index, buffer, buflen, bc);\n}\n\nstatic void mlx5_ib_qp_err_syndrome(struct ib_qp *ibqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tint outlen = MLX5_ST_SZ_BYTES(query_qp_out);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tvoid *pas_ext_union, *err_syn;\n\tu32 *outb;\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, qpc_extension) ||\n\t    !MLX5_CAP_GEN(dev->mdev, qp_error_syndrome))\n\t\treturn;\n\n\toutb = kzalloc(outlen, GFP_KERNEL);\n\tif (!outb)\n\t\treturn;\n\n\terr = mlx5_core_qp_query(dev, &qp->trans_qp.base.mqp, outb, outlen,\n\t\t\t\t true);\n\tif (err)\n\t\tgoto out;\n\n\tpas_ext_union =\n\t\tMLX5_ADDR_OF(query_qp_out, outb, qp_pas_or_qpc_ext_and_pas);\n\terr_syn = MLX5_ADDR_OF(qpc_extension_and_pas_list_in, pas_ext_union,\n\t\t\t       qpc_data_extension.error_syndrome);\n\n\tpr_err(\"%s/%d: QP %d error: %s (0x%x 0x%x 0x%x)\\n\",\n\t       ibqp->device->name, ibqp->port, ibqp->qp_num,\n\t       ib_wc_status_msg(\n\t\t       MLX5_GET(cqe_error_syndrome, err_syn, syndrome)),\n\t       MLX5_GET(cqe_error_syndrome, err_syn, vendor_error_syndrome),\n\t       MLX5_GET(cqe_error_syndrome, err_syn, hw_syndrome_type),\n\t       MLX5_GET(cqe_error_syndrome, err_syn, hw_error_syndrome));\nout:\n\tkfree(outb);\n}\n\nstatic void mlx5_ib_handle_qp_event(struct work_struct *_work)\n{\n\tstruct mlx5_ib_qp_event_work *qpe_work =\n\t\tcontainer_of(_work, struct mlx5_ib_qp_event_work, work);\n\tstruct ib_qp *ibqp = &to_mibqp(qpe_work->qp)->ibqp;\n\tstruct ib_event event = {};\n\n\tevent.device = ibqp->device;\n\tevent.element.qp = ibqp;\n\tswitch (qpe_work->type) {\n\tcase MLX5_EVENT_TYPE_PATH_MIG:\n\t\tevent.event = IB_EVENT_PATH_MIG;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_COMM_EST:\n\t\tevent.event = IB_EVENT_COMM_EST;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_SQ_DRAINED:\n\t\tevent.event = IB_EVENT_SQ_DRAINED;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_SRQ_LAST_WQE:\n\t\tevent.event = IB_EVENT_QP_LAST_WQE_REACHED;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\tevent.event = IB_EVENT_QP_FATAL;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_PATH_MIG_FAILED:\n\t\tevent.event = IB_EVENT_PATH_MIG_ERR;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_WQ_INVAL_REQ_ERROR:\n\t\tevent.event = IB_EVENT_QP_REQ_ERR;\n\t\tbreak;\n\tcase MLX5_EVENT_TYPE_WQ_ACCESS_ERROR:\n\t\tevent.event = IB_EVENT_QP_ACCESS_ERR;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"mlx5_ib: Unexpected event type %d on QP %06x\\n\",\n\t\t\tqpe_work->type, qpe_work->qp->qpn);\n\t\tgoto out;\n\t}\n\n\tif ((event.event == IB_EVENT_QP_FATAL) ||\n\t    (event.event == IB_EVENT_QP_ACCESS_ERR))\n\t\tmlx5_ib_qp_err_syndrome(ibqp);\n\n\tibqp->event_handler(&event, ibqp->qp_context);\n\nout:\n\tmlx5_core_res_put(&qpe_work->qp->common);\n\tkfree(qpe_work);\n}\n\nstatic void mlx5_ib_qp_event(struct mlx5_core_qp *qp, int type)\n{\n\tstruct ib_qp *ibqp = &to_mibqp(qp)->ibqp;\n\tstruct mlx5_ib_qp_event_work *qpe_work;\n\n\tif (type == MLX5_EVENT_TYPE_PATH_MIG) {\n\t\t \n\t\tto_mibqp(qp)->port = to_mibqp(qp)->trans_qp.alt_port;\n\t}\n\n\tif (!ibqp->event_handler)\n\t\tgoto out_no_handler;\n\n\tqpe_work = kzalloc(sizeof(*qpe_work), GFP_ATOMIC);\n\tif (!qpe_work)\n\t\tgoto out_no_handler;\n\n\tqpe_work->qp = qp;\n\tqpe_work->type = type;\n\tINIT_WORK(&qpe_work->work, mlx5_ib_handle_qp_event);\n\tqueue_work(mlx5_ib_qp_event_wq, &qpe_work->work);\n\treturn;\n\nout_no_handler:\n\tmlx5_core_res_put(&qp->common);\n}\n\nstatic int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,\n\t\t       int has_rq, struct mlx5_ib_qp *qp, struct mlx5_ib_create_qp *ucmd)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\t \n\tif (cap->max_recv_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz)))\n\t\treturn -EINVAL;\n\n\tif (!has_rq) {\n\t\tqp->rq.max_gs = 0;\n\t\tqp->rq.wqe_cnt = 0;\n\t\tqp->rq.wqe_shift = 0;\n\t\tcap->max_recv_wr = 0;\n\t\tcap->max_recv_sge = 0;\n\t} else {\n\t\tint wq_sig = !!(qp->flags_en & MLX5_QP_FLAG_SIGNATURE);\n\n\t\tif (ucmd) {\n\t\t\tqp->rq.wqe_cnt = ucmd->rq_wqe_count;\n\t\t\tif (ucmd->rq_wqe_shift > BITS_PER_BYTE * sizeof(ucmd->rq_wqe_shift))\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.wqe_shift = ucmd->rq_wqe_shift;\n\t\t\tif ((1 << qp->rq.wqe_shift) /\n\t\t\t\t    sizeof(struct mlx5_wqe_data_seg) <\n\t\t\t    wq_sig)\n\t\t\t\treturn -EINVAL;\n\t\t\tqp->rq.max_gs =\n\t\t\t\t(1 << qp->rq.wqe_shift) /\n\t\t\t\t\tsizeof(struct mlx5_wqe_data_seg) -\n\t\t\t\twq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t} else {\n\t\t\twqe_size =\n\t\t\t\twq_sig ? sizeof(struct mlx5_wqe_signature_seg) :\n\t\t\t\t\t 0;\n\t\t\twqe_size += cap->max_recv_sge * sizeof(struct mlx5_wqe_data_seg);\n\t\t\twqe_size = roundup_pow_of_two(wqe_size);\n\t\t\twq_size = roundup_pow_of_two(cap->max_recv_wr) * wqe_size;\n\t\t\twq_size = max_t(int, wq_size, MLX5_SEND_WQE_BB);\n\t\t\tqp->rq.wqe_cnt = wq_size / wqe_size;\n\t\t\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_rq)) {\n\t\t\t\tmlx5_ib_dbg(dev, \"wqe_size %d, max %d\\n\",\n\t\t\t\t\t    wqe_size,\n\t\t\t\t\t    MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t\t max_wqe_sz_rq));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tqp->rq.wqe_shift = ilog2(wqe_size);\n\t\t\tqp->rq.max_gs =\n\t\t\t\t(1 << qp->rq.wqe_shift) /\n\t\t\t\t\tsizeof(struct mlx5_wqe_data_seg) -\n\t\t\t\twq_sig;\n\t\t\tqp->rq.max_post = qp->rq.wqe_cnt;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sq_overhead(struct ib_qp_init_attr *attr)\n{\n\tint size = 0;\n\n\tswitch (attr->qp_type) {\n\tcase IB_QPT_XRC_INI:\n\t\tsize += sizeof(struct mlx5_wqe_xrc_seg);\n\t\tfallthrough;\n\tcase IB_QPT_RC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_atomic_seg) +\n\t\t\t    sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg) +\n\t\t\t    MLX5_IB_SQ_UMR_INLINE_THRESHOLD /\n\t\t\t    MLX5_IB_UMR_OCTOWORD);\n\t\tbreak;\n\n\tcase IB_QPT_XRC_TGT:\n\t\treturn 0;\n\n\tcase IB_QPT_UC:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tmax(sizeof(struct mlx5_wqe_raddr_seg),\n\t\t\t    sizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\t    sizeof(struct mlx5_mkey_seg));\n\t\tbreak;\n\n\tcase IB_QPT_UD:\n\t\tif (attr->create_flags & IB_QP_CREATE_IPOIB_UD_LSO)\n\t\t\tsize += sizeof(struct mlx5_wqe_eth_pad) +\n\t\t\t\tsizeof(struct mlx5_wqe_eth_seg);\n\t\tfallthrough;\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_datagram_seg);\n\t\tbreak;\n\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\tsize += sizeof(struct mlx5_wqe_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_wqe_umr_ctrl_seg) +\n\t\t\tsizeof(struct mlx5_mkey_seg);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn size;\n}\n\nstatic int calc_send_wqe(struct ib_qp_init_attr *attr)\n{\n\tint inl_size = 0;\n\tint size;\n\n\tsize = sq_overhead(attr);\n\tif (size < 0)\n\t\treturn size;\n\n\tif (attr->cap.max_inline_data) {\n\t\tinl_size = size + sizeof(struct mlx5_wqe_inline_seg) +\n\t\t\tattr->cap.max_inline_data;\n\t}\n\n\tsize += attr->cap.max_send_sge * sizeof(struct mlx5_wqe_data_seg);\n\tif (attr->create_flags & IB_QP_CREATE_INTEGRITY_EN &&\n\t    ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB) < MLX5_SIG_WQE_SIZE)\n\t\treturn MLX5_SIG_WQE_SIZE;\n\telse\n\t\treturn ALIGN(max_t(int, inl_size, size), MLX5_SEND_WQE_BB);\n}\n\nstatic int get_send_sge(struct ib_qp_init_attr *attr, int wqe_size)\n{\n\tint max_sge;\n\n\tif (attr->qp_type == IB_QPT_RC)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse if (attr->qp_type == IB_QPT_XRC_INI)\n\t\tmax_sge = (min_t(int, wqe_size, 512) -\n\t\t\t   sizeof(struct mlx5_wqe_ctrl_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_xrc_seg) -\n\t\t\t   sizeof(struct mlx5_wqe_raddr_seg)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\telse\n\t\tmax_sge = (wqe_size - sq_overhead(attr)) /\n\t\t\tsizeof(struct mlx5_wqe_data_seg);\n\n\treturn min_t(int, max_sge, wqe_size - sq_overhead(attr) /\n\t\t     sizeof(struct mlx5_wqe_data_seg));\n}\n\nstatic int calc_sq_size(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,\n\t\t\tstruct mlx5_ib_qp *qp)\n{\n\tint wqe_size;\n\tint wq_size;\n\n\tif (!attr->cap.max_send_wr)\n\t\treturn 0;\n\n\twqe_size = calc_send_wqe(attr);\n\tmlx5_ib_dbg(dev, \"wqe_size %d\\n\", wqe_size);\n\tif (wqe_size < 0)\n\t\treturn wqe_size;\n\n\tif (wqe_size > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_dbg(dev, \"wqe_size(%d) > max_sq_desc_sz(%d)\\n\",\n\t\t\t    wqe_size, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tqp->max_inline_data = wqe_size - sq_overhead(attr) -\n\t\t\t      sizeof(struct mlx5_wqe_inline_seg);\n\tattr->cap.max_inline_data = qp->max_inline_data;\n\n\twq_size = roundup_pow_of_two(attr->cap.max_send_wr * wqe_size);\n\tqp->sq.wqe_cnt = wq_size / MLX5_SEND_WQE_BB;\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_dbg(dev, \"send queue size (%d * %d / %d -> %d) exceeds limits(%d)\\n\",\n\t\t\t    attr->cap.max_send_wr, wqe_size, MLX5_SEND_WQE_BB,\n\t\t\t    qp->sq.wqe_cnt,\n\t\t\t    1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -ENOMEM;\n\t}\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.max_gs = get_send_sge(attr, wqe_size);\n\tif (qp->sq.max_gs < attr->cap.max_send_sge)\n\t\treturn -ENOMEM;\n\n\tattr->cap.max_send_sge = qp->sq.max_gs;\n\tqp->sq.max_post = wq_size / wqe_size;\n\tattr->cap.max_send_wr = qp->sq.max_post;\n\n\treturn wq_size;\n}\n\nstatic int set_user_buf_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_ib_create_qp *ucmd,\n\t\t\t    struct mlx5_ib_qp_base *base,\n\t\t\t    struct ib_qp_init_attr *attr)\n{\n\tint desc_sz = 1 << qp->sq.wqe_shift;\n\n\tif (desc_sz > MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq)) {\n\t\tmlx5_ib_warn(dev, \"desc_sz %d, max_sq_desc_sz %d\\n\",\n\t\t\t     desc_sz, MLX5_CAP_GEN(dev->mdev, max_wqe_sz_sq));\n\t\treturn -EINVAL;\n\t}\n\n\tif (ucmd->sq_wqe_count && !is_power_of_2(ucmd->sq_wqe_count)) {\n\t\tmlx5_ib_warn(dev, \"sq_wqe_count %d is not a power of two\\n\",\n\t\t\t     ucmd->sq_wqe_count);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->sq.wqe_cnt = ucmd->sq_wqe_count;\n\n\tif (qp->sq.wqe_cnt > (1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz))) {\n\t\tmlx5_ib_warn(dev, \"wqe_cnt %d, max_wqes %d\\n\",\n\t\t\t     qp->sq.wqe_cnt,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_qp_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tbase->ubuffer.buf_size = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_size = qp->sq.wqe_cnt << 6;\n\t} else {\n\t\tbase->ubuffer.buf_size = (qp->rq.wqe_cnt << qp->rq.wqe_shift) +\n\t\t\t\t\t (qp->sq.wqe_cnt << 6);\n\t}\n\n\treturn 0;\n}\n\nstatic int qp_has_rq(struct ib_qp_init_attr *attr)\n{\n\tif (attr->qp_type == IB_QPT_XRC_INI ||\n\t    attr->qp_type == IB_QPT_XRC_TGT || attr->srq ||\n\t    attr->qp_type == MLX5_IB_QPT_REG_UMR ||\n\t    !attr->cap.max_recv_wr)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nenum {\n\t \n\tNUM_NON_BLUE_FLAME_BFREGS = 1,\n};\n\nstatic int max_bfregs(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi)\n{\n\treturn get_uars_per_sys_page(dev, bfregi->lib_uar_4k) *\n\t       bfregi->num_static_sys_pages * MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int num_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint n;\n\n\tn = max_bfregs(dev, bfregi) - bfregi->num_low_latency_bfregs -\n\t    NUM_NON_BLUE_FLAME_BFREGS;\n\n\treturn n >= 0 ? n : 0;\n}\n\nstatic int first_med_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t   struct mlx5_bfreg_info *bfregi)\n{\n\treturn num_med_bfreg(dev, bfregi) ? 1 : -ENOMEM;\n}\n\nstatic int first_hi_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint med;\n\n\tmed = num_med_bfreg(dev, bfregi);\n\treturn ++med;\n}\n\nstatic int alloc_high_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_bfreg_info *bfregi)\n{\n\tint i;\n\n\tfor (i = first_hi_bfreg(dev, bfregi); i < max_bfregs(dev, bfregi); i++) {\n\t\tif (!bfregi->count[i]) {\n\t\t\tbfregi->count[i]++;\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstatic int alloc_med_class_bfreg(struct mlx5_ib_dev *dev,\n\t\t\t\t struct mlx5_bfreg_info *bfregi)\n{\n\tint minidx = first_med_bfreg(dev, bfregi);\n\tint i;\n\n\tif (minidx < 0)\n\t\treturn minidx;\n\n\tfor (i = minidx; i < first_hi_bfreg(dev, bfregi); i++) {\n\t\tif (bfregi->count[i] < bfregi->count[minidx])\n\t\t\tminidx = i;\n\t\tif (!bfregi->count[minidx])\n\t\t\tbreak;\n\t}\n\n\tbfregi->count[minidx]++;\n\treturn minidx;\n}\n\nstatic int alloc_bfreg(struct mlx5_ib_dev *dev,\n\t\t       struct mlx5_bfreg_info *bfregi)\n{\n\tint bfregn = -ENOMEM;\n\n\tif (bfregi->lib_uar_dyn)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&bfregi->lock);\n\tif (bfregi->ver >= 2) {\n\t\tbfregn = alloc_high_class_bfreg(dev, bfregi);\n\t\tif (bfregn < 0)\n\t\t\tbfregn = alloc_med_class_bfreg(dev, bfregi);\n\t}\n\n\tif (bfregn < 0) {\n\t\tBUILD_BUG_ON(NUM_NON_BLUE_FLAME_BFREGS != 1);\n\t\tbfregn = 0;\n\t\tbfregi->count[bfregn]++;\n\t}\n\tmutex_unlock(&bfregi->lock);\n\n\treturn bfregn;\n}\n\nvoid mlx5_ib_free_bfreg(struct mlx5_ib_dev *dev, struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\tmutex_lock(&bfregi->lock);\n\tbfregi->count[bfregn]--;\n\tmutex_unlock(&bfregi->lock);\n}\n\nstatic enum mlx5_qp_state to_mlx5_state(enum ib_qp_state state)\n{\n\tswitch (state) {\n\tcase IB_QPS_RESET:\treturn MLX5_QP_STATE_RST;\n\tcase IB_QPS_INIT:\treturn MLX5_QP_STATE_INIT;\n\tcase IB_QPS_RTR:\treturn MLX5_QP_STATE_RTR;\n\tcase IB_QPS_RTS:\treturn MLX5_QP_STATE_RTS;\n\tcase IB_QPS_SQD:\treturn MLX5_QP_STATE_SQD;\n\tcase IB_QPS_SQE:\treturn MLX5_QP_STATE_SQER;\n\tcase IB_QPS_ERR:\treturn MLX5_QP_STATE_ERR;\n\tdefault:\t\treturn -1;\n\t}\n}\n\nstatic int to_mlx5_st(enum ib_qp_type type)\n{\n\tswitch (type) {\n\tcase IB_QPT_RC:\t\t\treturn MLX5_QP_ST_RC;\n\tcase IB_QPT_UC:\t\t\treturn MLX5_QP_ST_UC;\n\tcase IB_QPT_UD:\t\t\treturn MLX5_QP_ST_UD;\n\tcase MLX5_IB_QPT_REG_UMR:\treturn MLX5_QP_ST_REG_UMR;\n\tcase IB_QPT_XRC_INI:\n\tcase IB_QPT_XRC_TGT:\t\treturn MLX5_QP_ST_XRC;\n\tcase IB_QPT_SMI:\t\treturn MLX5_QP_ST_QP0;\n\tcase MLX5_IB_QPT_HW_GSI:\treturn MLX5_QP_ST_QP1;\n\tcase MLX5_IB_QPT_DCI:\t\treturn MLX5_QP_ST_DCI;\n\tcase IB_QPT_RAW_PACKET:\t\treturn MLX5_QP_ST_RAW_ETHERTYPE;\n\tdefault:\t\treturn -EINVAL;\n\t}\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t     struct mlx5_ib_cq *recv_cq);\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq,\n\t\t\t       struct mlx5_ib_cq *recv_cq);\n\nint bfregn_to_uar_index(struct mlx5_ib_dev *dev,\n\t\t\tstruct mlx5_bfreg_info *bfregi, u32 bfregn,\n\t\t\tbool dyn_bfreg)\n{\n\tunsigned int bfregs_per_sys_page;\n\tu32 index_of_sys_page;\n\tu32 offset;\n\n\tif (bfregi->lib_uar_dyn)\n\t\treturn -EINVAL;\n\n\tbfregs_per_sys_page = get_uars_per_sys_page(dev, bfregi->lib_uar_4k) *\n\t\t\t\tMLX5_NON_FP_BFREGS_PER_UAR;\n\tindex_of_sys_page = bfregn / bfregs_per_sys_page;\n\n\tif (dyn_bfreg) {\n\t\tindex_of_sys_page += bfregi->num_static_sys_pages;\n\n\t\tif (index_of_sys_page >= bfregi->num_sys_pages)\n\t\t\treturn -EINVAL;\n\n\t\tif (bfregn > bfregi->num_dyn_bfregs ||\n\t\t    bfregi->sys_pages[index_of_sys_page] == MLX5_IB_INVALID_UAR_INDEX) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid dynamic uar index\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\toffset = bfregn % bfregs_per_sys_page / MLX5_NON_FP_BFREGS_PER_UAR;\n\treturn bfregi->sys_pages[index_of_sys_page] + offset;\n}\n\nstatic void destroy_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_rwq *rwq, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *context =\n\t\trdma_udata_to_drv_context(\n\t\t\tudata,\n\t\t\tstruct mlx5_ib_ucontext,\n\t\t\tibucontext);\n\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_DELAY_DROP)\n\t\tatomic_dec(&dev->delay_drop.rqs_cnt);\n\n\tmlx5_ib_db_unmap_user(context, &rwq->db);\n\tib_umem_release(rwq->umem);\n}\n\nstatic int create_user_rq(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct ib_udata *udata, struct mlx5_ib_rwq *rwq,\n\t\t\t  struct mlx5_ib_create_wq *ucmd)\n{\n\tstruct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\tunsigned long page_size = 0;\n\tu32 offset = 0;\n\tint err;\n\n\tif (!ucmd->buf_addr)\n\t\treturn -EINVAL;\n\n\trwq->umem = ib_umem_get(&dev->ib_dev, ucmd->buf_addr, rwq->buf_size, 0);\n\tif (IS_ERR(rwq->umem)) {\n\t\tmlx5_ib_dbg(dev, \"umem_get failed\\n\");\n\t\terr = PTR_ERR(rwq->umem);\n\t\treturn err;\n\t}\n\n\tpage_size = mlx5_umem_find_best_quantized_pgoff(\n\t\trwq->umem, wq, log_wq_pg_sz, MLX5_ADAPTER_PAGE_SHIFT,\n\t\tpage_offset, 64, &rwq->rq_page_offset);\n\tif (!page_size) {\n\t\tmlx5_ib_warn(dev, \"bad offset\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_umem;\n\t}\n\n\trwq->rq_num_pas = ib_umem_num_dma_blocks(rwq->umem, page_size);\n\trwq->page_shift = order_base_2(page_size);\n\trwq->log_page_size =  rwq->page_shift - MLX5_ADAPTER_PAGE_SHIFT;\n\trwq->wq_sig = !!(ucmd->flags & MLX5_WQ_FLAG_SIGNATURE);\n\n\tmlx5_ib_dbg(\n\t\tdev,\n\t\t\"addr 0x%llx, size %zd, npages %zu, page_size %ld, ncont %d, offset %d\\n\",\n\t\t(unsigned long long)ucmd->buf_addr, rwq->buf_size,\n\t\tib_umem_num_pages(rwq->umem), page_size, rwq->rq_num_pas,\n\t\toffset);\n\n\terr = mlx5_ib_db_map_user(ucontext, ucmd->db_addr, &rwq->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_umem;\n\t}\n\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(rwq->umem);\n\treturn err;\n}\n\nstatic int adjust_bfregn(struct mlx5_ib_dev *dev,\n\t\t\t struct mlx5_bfreg_info *bfregi, int bfregn)\n{\n\treturn bfregn / MLX5_NON_FP_BFREGS_PER_UAR * MLX5_BFREGS_PER_UAR +\n\t\t\t\tbfregn % MLX5_NON_FP_BFREGS_PER_UAR;\n}\n\nstatic int _create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t   struct mlx5_ib_qp *qp, struct ib_udata *udata,\n\t\t\t   struct ib_qp_init_attr *attr, u32 **in,\n\t\t\t   struct mlx5_ib_create_qp_resp *resp, int *inlen,\n\t\t\t   struct mlx5_ib_qp_base *base,\n\t\t\t   struct mlx5_ib_create_qp *ucmd)\n{\n\tstruct mlx5_ib_ucontext *context;\n\tstruct mlx5_ib_ubuffer *ubuffer = &base->ubuffer;\n\tunsigned int page_offset_quantized = 0;\n\tunsigned long page_size = 0;\n\tint uar_index = 0;\n\tint bfregn;\n\tint ncont = 0;\n\t__be64 *pas;\n\tvoid *qpc;\n\tint err;\n\tu16 uid;\n\tu32 uar_flags;\n\n\tcontext = rdma_udata_to_drv_context(udata, struct mlx5_ib_ucontext,\n\t\t\t\t\t    ibucontext);\n\tuar_flags = qp->flags_en &\n\t\t    (MLX5_QP_FLAG_UAR_PAGE_INDEX | MLX5_QP_FLAG_BFREG_INDEX);\n\tswitch (uar_flags) {\n\tcase MLX5_QP_FLAG_UAR_PAGE_INDEX:\n\t\tuar_index = ucmd->bfreg_index;\n\t\tbfregn = MLX5_IB_INVALID_BFREG;\n\t\tbreak;\n\tcase MLX5_QP_FLAG_BFREG_INDEX:\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi,\n\t\t\t\t\t\tucmd->bfreg_index, true);\n\t\tif (uar_index < 0)\n\t\t\treturn uar_index;\n\t\tbfregn = MLX5_IB_INVALID_BFREG;\n\t\tbreak;\n\tcase 0:\n\t\tif (qp->flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\t\treturn -EINVAL;\n\t\tbfregn = alloc_bfreg(dev, &context->bfregi);\n\t\tif (bfregn < 0)\n\t\t\treturn bfregn;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmlx5_ib_dbg(dev, \"bfregn 0x%x, uar_index 0x%x\\n\", bfregn, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tuar_index = bfregn_to_uar_index(dev, &context->bfregi, bfregn,\n\t\t\t\t\t\tfalse);\n\n\tqp->rq.offset = 0;\n\tqp->sq.wqe_shift = ilog2(MLX5_SEND_WQE_BB);\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\n\terr = set_user_buf_size(dev, qp, ucmd, base, attr);\n\tif (err)\n\t\tgoto err_bfreg;\n\n\tif (ucmd->buf_addr && ubuffer->buf_size) {\n\t\tubuffer->buf_addr = ucmd->buf_addr;\n\t\tubuffer->umem = ib_umem_get(&dev->ib_dev, ubuffer->buf_addr,\n\t\t\t\t\t    ubuffer->buf_size, 0);\n\t\tif (IS_ERR(ubuffer->umem)) {\n\t\t\terr = PTR_ERR(ubuffer->umem);\n\t\t\tgoto err_bfreg;\n\t\t}\n\t\tpage_size = mlx5_umem_find_best_quantized_pgoff(\n\t\t\tubuffer->umem, qpc, log_page_size,\n\t\t\tMLX5_ADAPTER_PAGE_SHIFT, page_offset, 64,\n\t\t\t&page_offset_quantized);\n\t\tif (!page_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_umem;\n\t\t}\n\t\tncont = ib_umem_num_dma_blocks(ubuffer->umem, page_size);\n\t} else {\n\t\tubuffer->umem = NULL;\n\t}\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * ncont;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tuid = (attr->qp_type != IB_QPT_XRC_INI) ? to_mpd(pd)->uid : 0;\n\tMLX5_SET(create_qp_in, *in, uid, uid);\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\tpas = (__be64 *)MLX5_ADDR_OF(create_qp_in, *in, pas);\n\tif (ubuffer->umem) {\n\t\tmlx5_ib_populate_pas(ubuffer->umem, page_size, pas, 0);\n\t\tMLX5_SET(qpc, qpc, log_page_size,\n\t\t\t order_base_2(page_size) - MLX5_ADAPTER_PAGE_SHIFT);\n\t\tMLX5_SET(qpc, qpc, page_offset, page_offset_quantized);\n\t}\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tresp->bfreg_index = adjust_bfregn(dev, &context->bfregi, bfregn);\n\telse\n\t\tresp->bfreg_index = MLX5_IB_INVALID_BFREG;\n\tqp->bfregn = bfregn;\n\n\terr = mlx5_ib_db_map_user(context, ucmd->db_addr, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"map failed\\n\");\n\t\tgoto err_free;\n\t}\n\n\treturn 0;\n\nerr_free:\n\tkvfree(*in);\n\nerr_umem:\n\tib_umem_release(ubuffer->umem);\n\nerr_bfreg:\n\tif (bfregn != MLX5_IB_INVALID_BFREG)\n\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, bfregn);\n\treturn err;\n}\n\nstatic void destroy_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t       struct mlx5_ib_qp_base *base, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\n\tif (udata) {\n\t\t \n\t\tmlx5_ib_db_unmap_user(context, &qp->db);\n\t\tib_umem_release(base->ubuffer.umem);\n\n\t\t \n\t\tif (qp->bfregn != MLX5_IB_INVALID_BFREG)\n\t\t\tmlx5_ib_free_bfreg(dev, &context->bfregi, qp->bfregn);\n\t\treturn;\n\t}\n\n\t \n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tif (qp->db.db)\n\t\tmlx5_db_free(dev->mdev, &qp->db);\n\tif (qp->buf.frags)\n\t\tmlx5_frag_buf_free(dev->mdev, &qp->buf);\n}\n\nstatic int _create_kernel_qp(struct mlx5_ib_dev *dev,\n\t\t\t     struct ib_qp_init_attr *init_attr,\n\t\t\t     struct mlx5_ib_qp *qp, u32 **in, int *inlen,\n\t\t\t     struct mlx5_ib_qp_base *base)\n{\n\tint uar_index;\n\tvoid *qpc;\n\tint err;\n\n\tif (init_attr->qp_type == MLX5_IB_QPT_REG_UMR)\n\t\tqp->bf.bfreg = &dev->fp_bfreg;\n\telse if (qp->flags & MLX5_IB_QP_CREATE_WC_TEST)\n\t\tqp->bf.bfreg = &dev->wc_bfreg;\n\telse\n\t\tqp->bf.bfreg = &dev->bfreg;\n\n\t \n\tqp->bf.buf_size = (1 << MLX5_CAP_GEN(dev->mdev, log_bf_reg_size)) / 2;\n\tuar_index = qp->bf.bfreg->index;\n\n\terr = calc_sq_size(dev, init_attr, qp);\n\tif (err < 0) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tqp->rq.offset = 0;\n\tqp->sq.offset = qp->rq.wqe_cnt << qp->rq.wqe_shift;\n\tbase->ubuffer.buf_size = err + (qp->rq.wqe_cnt << qp->rq.wqe_shift);\n\n\terr = mlx5_frag_buf_alloc_node(dev->mdev, base->ubuffer.buf_size,\n\t\t\t\t       &qp->buf, dev->mdev->priv.numa_node);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt)\n\t\tmlx5_init_fbc(qp->buf.frags, qp->rq.wqe_shift,\n\t\t\t      ilog2(qp->rq.wqe_cnt), &qp->rq.fbc);\n\n\tif (qp->sq.wqe_cnt) {\n\t\tint sq_strides_offset = (qp->sq.offset  & (PAGE_SIZE - 1)) /\n\t\t\t\t\tMLX5_SEND_WQE_BB;\n\t\tmlx5_init_fbc_offset(qp->buf.frags +\n\t\t\t\t     (qp->sq.offset / PAGE_SIZE),\n\t\t\t\t     ilog2(MLX5_SEND_WQE_BB),\n\t\t\t\t     ilog2(qp->sq.wqe_cnt),\n\t\t\t\t     sq_strides_offset, &qp->sq.fbc);\n\n\t\tqp->sq.cur_edge = get_sq_edge(&qp->sq, 0);\n\t}\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_qp_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_qp_in, pas[0]) * qp->buf.npages;\n\t*in = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_buf;\n\t}\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, *in, qpc);\n\tMLX5_SET(qpc, qpc, uar_page, uar_index);\n\tMLX5_SET(qpc, qpc, ts_format, mlx5_get_qp_default_ts(dev->mdev));\n\tMLX5_SET(qpc, qpc, log_page_size, qp->buf.page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\n\t \n\tMLX5_SET(qpc, qpc, fre, 1);\n\tMLX5_SET(qpc, qpc, rlky, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CREATE_SQPN_QP1)\n\t\tMLX5_SET(qpc, qpc, deth_sqpn, 1);\n\n\tmlx5_fill_page_frag_array(&qp->buf,\n\t\t\t\t  (__be64 *)MLX5_ADDR_OF(create_qp_in,\n\t\t\t\t\t\t\t *in, pas));\n\n\terr = mlx5_db_alloc(dev->mdev, &qp->db);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\tgoto err_free;\n\t}\n\n\tqp->sq.wrid = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->sq.wrid), GFP_KERNEL);\n\tqp->sq.wr_data = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\tsizeof(*qp->sq.wr_data), GFP_KERNEL);\n\tqp->rq.wrid = kvmalloc_array(qp->rq.wqe_cnt,\n\t\t\t\t     sizeof(*qp->rq.wrid), GFP_KERNEL);\n\tqp->sq.w_list = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t       sizeof(*qp->sq.w_list), GFP_KERNEL);\n\tqp->sq.wqe_head = kvmalloc_array(qp->sq.wqe_cnt,\n\t\t\t\t\t sizeof(*qp->sq.wqe_head), GFP_KERNEL);\n\n\tif (!qp->sq.wrid || !qp->sq.wr_data || !qp->rq.wrid ||\n\t    !qp->sq.w_list || !qp->sq.wqe_head) {\n\t\terr = -ENOMEM;\n\t\tgoto err_wrid;\n\t}\n\n\treturn 0;\n\nerr_wrid:\n\tkvfree(qp->sq.wqe_head);\n\tkvfree(qp->sq.w_list);\n\tkvfree(qp->sq.wrid);\n\tkvfree(qp->sq.wr_data);\n\tkvfree(qp->rq.wrid);\n\tmlx5_db_free(dev->mdev, &qp->db);\n\nerr_free:\n\tkvfree(*in);\n\nerr_buf:\n\tmlx5_frag_buf_free(dev->mdev, &qp->buf);\n\treturn err;\n}\n\nstatic u32 get_rx_type(struct mlx5_ib_qp *qp, struct ib_qp_init_attr *attr)\n{\n\tif (attr->srq || (qp->type == IB_QPT_XRC_TGT) ||\n\t    (qp->type == MLX5_IB_QPT_DCI) || (qp->type == IB_QPT_XRC_INI))\n\t\treturn MLX5_SRQ_RQ;\n\telse if (!qp->has_rq)\n\t\treturn MLX5_ZERO_LEN_RQ;\n\n\treturn MLX5_NON_ZERO_RQ;\n}\n\nstatic int create_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_sq *sq, u32 tdn,\n\t\t\t\t    struct ib_pd *pd)\n{\n\tu32 in[MLX5_ST_SZ_DW(create_tis_in)] = {};\n\tvoid *tisc = MLX5_ADDR_OF(create_tis_in, in, ctx);\n\n\tMLX5_SET(create_tis_in, in, uid, to_mpd(pd)->uid);\n\tMLX5_SET(tisc, tisc, transport_domain, tdn);\n\tif (!mlx5_ib_lag_should_assign_affinity(dev) &&\n\t    mlx5_lag_is_lacp_owner(dev->mdev))\n\t\tMLX5_SET(tisc, tisc, strict_lag_tx_port_affinity, 1);\n\tif (qp->flags & IB_QP_CREATE_SOURCE_QPN)\n\t\tMLX5_SET(tisc, tisc, underlay_qpn, qp->underlay_qpn);\n\n\treturn mlx5_core_create_tis(dev->mdev, in, &sq->tisn);\n}\n\nstatic void destroy_raw_packet_qp_tis(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq, struct ib_pd *pd)\n{\n\tmlx5_cmd_destroy_tis(dev->mdev, sq->tisn, to_mpd(pd)->uid);\n}\n\nstatic void destroy_flow_rule_vport_sq(struct mlx5_ib_sq *sq)\n{\n\tif (sq->flow_rule)\n\t\tmlx5_del_flow_rules(sq->flow_rule);\n\tsq->flow_rule = NULL;\n}\n\nstatic bool fr_supported(int ts_cap)\n{\n\treturn ts_cap == MLX5_TIMESTAMP_FORMAT_CAP_FREE_RUNNING ||\n\t       ts_cap == MLX5_TIMESTAMP_FORMAT_CAP_FREE_RUNNING_AND_REAL_TIME;\n}\n\nstatic int get_ts_format(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,\n\t\t\t bool fr_sup, bool rt_sup)\n{\n\tif (cq->private_flags & MLX5_IB_CQ_PR_FLAGS_REAL_TIME_TS) {\n\t\tif (!rt_sup) {\n\t\t\tmlx5_ib_dbg(dev,\n\t\t\t\t    \"Real time TS format is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn MLX5_TIMESTAMP_FORMAT_REAL_TIME;\n\t}\n\tif (cq->create_flags & IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION) {\n\t\tif (!fr_sup) {\n\t\t\tmlx5_ib_dbg(dev,\n\t\t\t\t    \"Free running TS format is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\treturn MLX5_TIMESTAMP_FORMAT_FREE_RUNNING;\n\t}\n\treturn fr_sup ? MLX5_TIMESTAMP_FORMAT_FREE_RUNNING :\n\t\t\tMLX5_TIMESTAMP_FORMAT_DEFAULT;\n}\n\nstatic int get_rq_ts_format(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *recv_cq)\n{\n\tu8 ts_cap = MLX5_CAP_GEN(dev->mdev, rq_ts_format);\n\n\treturn get_ts_format(dev, recv_cq, fr_supported(ts_cap),\n\t\t\t     rt_supported(ts_cap));\n}\n\nstatic int get_sq_ts_format(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *send_cq)\n{\n\tu8 ts_cap = MLX5_CAP_GEN(dev->mdev, sq_ts_format);\n\n\treturn get_ts_format(dev, send_cq, fr_supported(ts_cap),\n\t\t\t     rt_supported(ts_cap));\n}\n\nstatic int get_qp_ts_format(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *send_cq,\n\t\t\t    struct mlx5_ib_cq *recv_cq)\n{\n\tu8 ts_cap = MLX5_CAP_ROCE(dev->mdev, qp_ts_format);\n\tbool fr_sup = fr_supported(ts_cap);\n\tbool rt_sup = rt_supported(ts_cap);\n\tu8 default_ts = fr_sup ? MLX5_TIMESTAMP_FORMAT_FREE_RUNNING :\n\t\t\t\t MLX5_TIMESTAMP_FORMAT_DEFAULT;\n\tint send_ts_format =\n\t\tsend_cq ? get_ts_format(dev, send_cq, fr_sup, rt_sup) :\n\t\t\t  default_ts;\n\tint recv_ts_format =\n\t\trecv_cq ? get_ts_format(dev, recv_cq, fr_sup, rt_sup) :\n\t\t\t  default_ts;\n\n\tif (send_ts_format < 0 || recv_ts_format < 0)\n\t\treturn -EOPNOTSUPP;\n\n\tif (send_ts_format != MLX5_TIMESTAMP_FORMAT_DEFAULT &&\n\t    recv_ts_format != MLX5_TIMESTAMP_FORMAT_DEFAULT &&\n\t    send_ts_format != recv_ts_format) {\n\t\tmlx5_ib_dbg(\n\t\t\tdev,\n\t\t\t\"The send ts_format does not match the receive ts_format\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn send_ts_format == default_ts ? recv_ts_format : send_ts_format;\n}\n\nstatic int create_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct ib_udata *udata,\n\t\t\t\t   struct mlx5_ib_sq *sq, void *qpin,\n\t\t\t\t   struct ib_pd *pd, struct mlx5_ib_cq *cq)\n{\n\tstruct mlx5_ib_ubuffer *ubuffer = &sq->ubuffer;\n\t__be64 *pas;\n\tvoid *in;\n\tvoid *sqc;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\tunsigned int page_offset_quantized;\n\tunsigned long page_size;\n\tint ts_format;\n\n\tts_format = get_sq_ts_format(dev, cq);\n\tif (ts_format < 0)\n\t\treturn ts_format;\n\n\tsq->ubuffer.umem = ib_umem_get(&dev->ib_dev, ubuffer->buf_addr,\n\t\t\t\t       ubuffer->buf_size, 0);\n\tif (IS_ERR(sq->ubuffer.umem))\n\t\treturn PTR_ERR(sq->ubuffer.umem);\n\tpage_size = mlx5_umem_find_best_quantized_pgoff(\n\t\tubuffer->umem, wq, log_wq_pg_sz, MLX5_ADAPTER_PAGE_SHIFT,\n\t\tpage_offset, 64, &page_offset_quantized);\n\tif (!page_size) {\n\t\terr = -EINVAL;\n\t\tgoto err_umem;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(create_sq_in) +\n\t\tsizeof(u64) *\n\t\t\tib_umem_num_dma_blocks(sq->ubuffer.umem, page_size);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tMLX5_SET(create_sq_in, in, uid, to_mpd(pd)->uid);\n\tsqc = MLX5_ADDR_OF(create_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, flush_in_error_en, 1);\n\tif (MLX5_CAP_ETH(dev->mdev, multi_pkt_send_wqe))\n\t\tMLX5_SET(sqc, sqc, allow_multi_pkt_send_wqe, 1);\n\tMLX5_SET(sqc, sqc, state, MLX5_SQC_STATE_RST);\n\tMLX5_SET(sqc, sqc, ts_format, ts_format);\n\tMLX5_SET(sqc, sqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(sqc, sqc, cqn, MLX5_GET(qpc, qpc, cqn_snd));\n\tMLX5_SET(sqc, sqc, tis_lst_sz, 1);\n\tMLX5_SET(sqc, sqc, tis_num_0, sq->tisn);\n\tif (MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t    MLX5_CAP_ETH(dev->mdev, swp))\n\t\tMLX5_SET(sqc, sqc, allow_swp, 1);\n\n\twq = MLX5_ADDR_OF(sqc, sqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET(wq, wq, uar_page, MLX5_GET(qpc, qpc, uar_page));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, ilog2(MLX5_SEND_WQE_BB));\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_sq_size));\n\tMLX5_SET(wq, wq, log_wq_pg_sz,\n\t\t order_base_2(page_size) - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(wq, wq, page_offset, page_offset_quantized);\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(sq->ubuffer.umem, page_size, pas, 0);\n\n\terr = mlx5_core_create_sq_tracked(dev, in, inlen, &sq->base.mqp);\n\n\tkvfree(in);\n\n\tif (err)\n\t\tgoto err_umem;\n\n\treturn 0;\n\nerr_umem:\n\tib_umem_release(sq->ubuffer.umem);\n\tsq->ubuffer.umem = NULL;\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_sq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_sq *sq)\n{\n\tdestroy_flow_rule_vport_sq(sq);\n\tmlx5_core_destroy_sq_tracked(dev, &sq->base.mqp);\n\tib_umem_release(sq->ubuffer.umem);\n}\n\nstatic int create_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_ib_rq *rq, void *qpin,\n\t\t\t\t   struct ib_pd *pd, struct mlx5_ib_cq *cq)\n{\n\tstruct mlx5_ib_qp *mqp = rq->base.container_mibqp;\n\t__be64 *pas;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tvoid *qpc = MLX5_ADDR_OF(create_qp_in, qpin, qpc);\n\tstruct ib_umem *umem = rq->base.ubuffer.umem;\n\tunsigned int page_offset_quantized;\n\tunsigned long page_size = 0;\n\tint ts_format;\n\tsize_t inlen;\n\tint err;\n\n\tts_format = get_rq_ts_format(dev, cq);\n\tif (ts_format < 0)\n\t\treturn ts_format;\n\n\tpage_size = mlx5_umem_find_best_quantized_pgoff(umem, wq, log_wq_pg_sz,\n\t\t\t\t\t\t\tMLX5_ADAPTER_PAGE_SHIFT,\n\t\t\t\t\t\t\tpage_offset, 64,\n\t\t\t\t\t\t\t&page_offset_quantized);\n\tif (!page_size)\n\t\treturn -EINVAL;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) +\n\t\tsizeof(u64) * ib_umem_num_dma_blocks(umem, page_size);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_rq_in, in, uid, to_mpd(pd)->uid);\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tif (!(rq->flags & MLX5_IB_RQ_CVLAN_STRIPPING))\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\tMLX5_SET(rqc, rqc, mem_rq_type, MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc, rqc, ts_format, ts_format);\n\tMLX5_SET(rqc, rqc, flush_in_error_en, 1);\n\tMLX5_SET(rqc, rqc, user_index, MLX5_GET(qpc, qpc, user_index));\n\tMLX5_SET(rqc, rqc, cqn, MLX5_GET(qpc, qpc, cqn_rcv));\n\n\tif (mqp->flags & IB_QP_CREATE_SCATTER_FCS)\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_CYCLIC);\n\tif (rq->flags & MLX5_IB_RQ_PCI_WRITE_END_PADDING)\n\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\tMLX5_SET(wq, wq, page_offset, page_offset_quantized);\n\tMLX5_SET(wq, wq, pd, MLX5_GET(qpc, qpc, pd));\n\tMLX5_SET64(wq, wq, dbr_addr, MLX5_GET64(qpc, qpc, dbr_addr));\n\tMLX5_SET(wq, wq, log_wq_stride, MLX5_GET(qpc, qpc, log_rq_stride) + 4);\n\tMLX5_SET(wq, wq, log_wq_pg_sz,\n\t\t order_base_2(page_size) - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(wq, wq, log_wq_sz, MLX5_GET(qpc, qpc, log_rq_size));\n\n\tpas = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(umem, page_size, pas, 0);\n\n\terr = mlx5_core_create_rq_tracked(dev, in, inlen, &rq->base.mqp);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_rq *rq)\n{\n\tmlx5_core_destroy_rq_tracked(dev, &rq->base.mqp);\n}\n\nstatic void destroy_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_rq *rq,\n\t\t\t\t      u32 qp_flags_en,\n\t\t\t\t      struct ib_pd *pd)\n{\n\tif (qp_flags_en & (MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC |\n\t\t\t   MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC))\n\t\tmlx5_ib_disable_lb(dev, false, true);\n\tmlx5_cmd_destroy_tir(dev->mdev, rq->tirn, to_mpd(pd)->uid);\n}\n\nstatic int create_raw_packet_qp_tir(struct mlx5_ib_dev *dev,\n\t\t\t\t    struct mlx5_ib_rq *rq, u32 tdn,\n\t\t\t\t    u32 *qp_flags_en, struct ib_pd *pd,\n\t\t\t\t    u32 *out)\n{\n\tu8 lb_flag = 0;\n\tu32 *in;\n\tvoid *tirc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_tir_in, in, uid, to_mpd(pd)->uid);\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type, MLX5_TIRC_DISP_TYPE_DIRECT);\n\tMLX5_SET(tirc, tirc, inline_rqn, rq->base.mqp.qpn);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\tif (*qp_flags_en & MLX5_QP_FLAG_TUNNEL_OFFLOADS)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tif (*qp_flags_en & MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC)\n\t\tlb_flag |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST;\n\n\tif (*qp_flags_en & MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC)\n\t\tlb_flag |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_MULTICAST;\n\n\tif (dev->is_rep) {\n\t\tlb_flag |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST;\n\t\t*qp_flags_en |= MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC;\n\t}\n\n\tMLX5_SET(tirc, tirc, self_lb_block, lb_flag);\n\tMLX5_SET(create_tir_in, in, opcode, MLX5_CMD_OP_CREATE_TIR);\n\terr = mlx5_cmd_exec_inout(dev->mdev, create_tir, in, out);\n\trq->tirn = MLX5_GET(create_tir_out, out, tirn);\n\tif (!err && MLX5_GET(tirc, tirc, self_lb_block)) {\n\t\terr = mlx5_ib_enable_lb(dev, false, true);\n\n\t\tif (err)\n\t\t\tdestroy_raw_packet_qp_tir(dev, rq, 0, pd);\n\t}\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int create_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tu32 *in, size_t inlen, struct ib_pd *pd,\n\t\t\t\tstruct ib_udata *udata,\n\t\t\t\tstruct mlx5_ib_create_qp_resp *resp,\n\t\t\t\tstruct ib_qp_init_attr *init_attr)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct mlx5_ib_ucontext *mucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\tint err;\n\tu32 tdn = mucontext->tdn;\n\tu16 uid = to_mpd(pd)->uid;\n\tu32 out[MLX5_ST_SZ_DW(create_tir_out)] = {};\n\n\tif (!qp->sq.wqe_cnt && !qp->rq.wqe_cnt)\n\t\treturn -EINVAL;\n\tif (qp->sq.wqe_cnt) {\n\t\terr = create_raw_packet_qp_tis(dev, qp, sq, tdn, pd);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = create_raw_packet_qp_sq(dev, udata, sq, in, pd,\n\t\t\t\t\t      to_mcq(init_attr->send_cq));\n\t\tif (err)\n\t\t\tgoto err_destroy_tis;\n\n\t\tif (uid) {\n\t\t\tresp->tisn = sq->tisn;\n\t\t\tresp->comp_mask |= MLX5_IB_CREATE_QP_RESP_MASK_TISN;\n\t\t\tresp->sqn = sq->base.mqp.qpn;\n\t\t\tresp->comp_mask |= MLX5_IB_CREATE_QP_RESP_MASK_SQN;\n\t\t}\n\n\t\tsq->base.container_mibqp = qp;\n\t\tsq->base.mqp.event = mlx5_ib_qp_event;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\trq->base.container_mibqp = qp;\n\n\t\tif (qp->flags & IB_QP_CREATE_CVLAN_STRIPPING)\n\t\t\trq->flags |= MLX5_IB_RQ_CVLAN_STRIPPING;\n\t\tif (qp->flags & IB_QP_CREATE_PCI_WRITE_END_PADDING)\n\t\t\trq->flags |= MLX5_IB_RQ_PCI_WRITE_END_PADDING;\n\t\terr = create_raw_packet_qp_rq(dev, rq, in, pd,\n\t\t\t\t\t      to_mcq(init_attr->recv_cq));\n\t\tif (err)\n\t\t\tgoto err_destroy_sq;\n\n\t\terr = create_raw_packet_qp_tir(dev, rq, tdn, &qp->flags_en, pd,\n\t\t\t\t\t       out);\n\t\tif (err)\n\t\t\tgoto err_destroy_rq;\n\n\t\tif (uid) {\n\t\t\tresp->rqn = rq->base.mqp.qpn;\n\t\t\tresp->comp_mask |= MLX5_IB_CREATE_QP_RESP_MASK_RQN;\n\t\t\tresp->tirn = rq->tirn;\n\t\t\tresp->comp_mask |= MLX5_IB_CREATE_QP_RESP_MASK_TIRN;\n\t\t\tif (MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, sw_owner) ||\n\t\t\t    MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, sw_owner_v2)) {\n\t\t\t\tresp->tir_icm_addr = MLX5_GET(\n\t\t\t\t\tcreate_tir_out, out, icm_address_31_0);\n\t\t\t\tresp->tir_icm_addr |=\n\t\t\t\t\t(u64)MLX5_GET(create_tir_out, out,\n\t\t\t\t\t\t      icm_address_39_32)\n\t\t\t\t\t<< 32;\n\t\t\t\tresp->tir_icm_addr |=\n\t\t\t\t\t(u64)MLX5_GET(create_tir_out, out,\n\t\t\t\t\t\t      icm_address_63_40)\n\t\t\t\t\t<< 40;\n\t\t\t\tresp->comp_mask |=\n\t\t\t\t\tMLX5_IB_CREATE_QP_RESP_MASK_TIR_ICM_ADDR;\n\t\t\t}\n\t\t}\n\t}\n\n\tqp->trans_qp.base.mqp.qpn = qp->sq.wqe_cnt ? sq->base.mqp.qpn :\n\t\t\t\t\t\t     rq->base.mqp.qpn;\n\treturn 0;\n\nerr_destroy_rq:\n\tdestroy_raw_packet_qp_rq(dev, rq);\nerr_destroy_sq:\n\tif (!qp->sq.wqe_cnt)\n\t\treturn err;\n\tdestroy_raw_packet_qp_sq(dev, sq);\nerr_destroy_tis:\n\tdestroy_raw_packet_qp_tis(dev, sq, pd);\n\n\treturn err;\n}\n\nstatic void destroy_raw_packet_qp(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_ib_qp *qp)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tif (qp->rq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_tir(dev, rq, qp->flags_en, qp->ibqp.pd);\n\t\tdestroy_raw_packet_qp_rq(dev, rq);\n\t}\n\n\tif (qp->sq.wqe_cnt) {\n\t\tdestroy_raw_packet_qp_sq(dev, sq);\n\t\tdestroy_raw_packet_qp_tis(dev, sq, qp->ibqp.pd);\n\t}\n}\n\nstatic void raw_packet_qp_copy_info(struct mlx5_ib_qp *qp,\n\t\t\t\t    struct mlx5_ib_raw_packet_qp *raw_packet_qp)\n{\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\n\tsq->sq = &qp->sq;\n\trq->rq = &qp->rq;\n\tsq->doorbell = &qp->db;\n\trq->doorbell = &qp->db;\n}\n\nstatic void destroy_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp)\n{\n\tif (qp->flags_en & (MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC |\n\t\t\t    MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC))\n\t\tmlx5_ib_disable_lb(dev, false, true);\n\tmlx5_cmd_destroy_tir(dev->mdev, qp->rss_qp.tirn,\n\t\t\t     to_mpd(qp->ibqp.pd)->uid);\n}\n\nstruct mlx5_create_qp_params {\n\tstruct ib_udata *udata;\n\tsize_t inlen;\n\tsize_t outlen;\n\tsize_t ucmd_size;\n\tvoid *ucmd;\n\tu8 is_rss_raw : 1;\n\tstruct ib_qp_init_attr *attr;\n\tu32 uidx;\n\tstruct mlx5_ib_create_qp_resp resp;\n};\n\nstatic int create_rss_raw_qp_tir(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t\t struct mlx5_ib_qp *qp,\n\t\t\t\t struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *init_attr = params->attr;\n\tstruct mlx5_ib_create_qp_rss *ucmd = params->ucmd;\n\tstruct ib_udata *udata = params->udata;\n\tstruct mlx5_ib_ucontext *mucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\tint inlen;\n\tint outlen;\n\tint err;\n\tu32 *in;\n\tu32 *out;\n\tvoid *tirc;\n\tvoid *hfso;\n\tu32 selected_fields = 0;\n\tu32 outer_l4;\n\tu32 tdn = mucontext->tdn;\n\tu8 lb_flag = 0;\n\n\tif (ucmd->comp_mask) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_INNER &&\n\t    !(ucmd->flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)) {\n\t\tmlx5_ib_dbg(dev, \"Tunnel offloads must be set for inner RSS\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (dev->is_rep)\n\t\tqp->flags_en |= MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC;\n\n\tif (qp->flags_en & MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC)\n\t\tlb_flag |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_UNICAST;\n\n\tif (qp->flags_en & MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC)\n\t\tlb_flag |= MLX5_TIRC_SELF_LB_BLOCK_BLOCK_MULTICAST;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_tir_in);\n\toutlen = MLX5_ST_SZ_BYTES(create_tir_out);\n\tin = kvzalloc(inlen + outlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tout = in + MLX5_ST_SZ_DW(create_tir_in);\n\tMLX5_SET(create_tir_in, in, uid, to_mpd(pd)->uid);\n\ttirc = MLX5_ADDR_OF(create_tir_in, in, ctx);\n\tMLX5_SET(tirc, tirc, disp_type,\n\t\t MLX5_TIRC_DISP_TYPE_INDIRECT);\n\tMLX5_SET(tirc, tirc, indirect_table,\n\t\t init_attr->rwq_ind_tbl->ind_tbl_num);\n\tMLX5_SET(tirc, tirc, transport_domain, tdn);\n\n\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tif (ucmd->flags & MLX5_QP_FLAG_TUNNEL_OFFLOADS)\n\t\tMLX5_SET(tirc, tirc, tunneled_offload_en, 1);\n\n\tMLX5_SET(tirc, tirc, self_lb_block, lb_flag);\n\n\tif (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_INNER)\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_inner);\n\telse\n\t\thfso = MLX5_ADDR_OF(tirc, tirc, rx_hash_field_selector_outer);\n\n\tswitch (ucmd->rx_hash_function) {\n\tcase MLX5_RX_HASH_FUNC_TOEPLITZ:\n\t{\n\t\tvoid *rss_key = MLX5_ADDR_OF(tirc, tirc, rx_hash_toeplitz_key);\n\t\tsize_t len = MLX5_FLD_SZ_BYTES(tirc, rx_hash_toeplitz_key);\n\n\t\tif (len != ucmd->rx_key_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tMLX5_SET(tirc, tirc, rx_hash_fn, MLX5_RX_HASH_FN_TOEPLITZ);\n\t\tmemcpy(rss_key, ucmd->rx_hash_key, len);\n\t\tbreak;\n\t}\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!ucmd->rx_hash_fields_mask) {\n\t\t \n\t\tif (!init_attr->rwq_ind_tbl->log_ind_tbl_size)\n\t\t\tgoto create_tir;\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t     (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4)) &&\n\t     ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t     (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV4);\n\telse if ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6) ||\n\t\t (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l3_prot_type,\n\t\t\t MLX5_L3_PROT_TYPE_IPV6);\n\n\touter_l4 = ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP))\n\t\t\t   << 0 |\n\t\t   ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\t\t   << 1 |\n\t\t   (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI) << 2;\n\n\t \n\tif (outer_l4 & (outer_l4 - 1)) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_TCP);\n\telse if ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP) ||\n\t\t (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tMLX5_SET(rx_hash_field_select, hfso, l4_prot_type,\n\t\t\t MLX5_L4_PROT_TYPE_UDP);\n\n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV4) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_SRC_IP;\n\n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV4) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_IPV6))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_DST_IP;\n\n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_TCP) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_SRC_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_SPORT;\n\n\tif ((ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_TCP) ||\n\t    (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_DST_PORT_UDP))\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_L4_DPORT;\n\n\tif (ucmd->rx_hash_fields_mask & MLX5_RX_HASH_IPSEC_SPI)\n\t\tselected_fields |= MLX5_HASH_FIELD_SEL_IPSEC_SPI;\n\n\tMLX5_SET(rx_hash_field_select, hfso, selected_fields, selected_fields);\n\ncreate_tir:\n\tMLX5_SET(create_tir_in, in, opcode, MLX5_CMD_OP_CREATE_TIR);\n\terr = mlx5_cmd_exec_inout(dev->mdev, create_tir, in, out);\n\n\tqp->rss_qp.tirn = MLX5_GET(create_tir_out, out, tirn);\n\tif (!err && MLX5_GET(tirc, tirc, self_lb_block)) {\n\t\terr = mlx5_ib_enable_lb(dev, false, true);\n\n\t\tif (err)\n\t\t\tmlx5_cmd_destroy_tir(dev->mdev, qp->rss_qp.tirn,\n\t\t\t\t\t     to_mpd(pd)->uid);\n\t}\n\n\tif (err)\n\t\tgoto err;\n\n\tif (mucontext->devx_uid) {\n\t\tparams->resp.comp_mask |= MLX5_IB_CREATE_QP_RESP_MASK_TIRN;\n\t\tparams->resp.tirn = qp->rss_qp.tirn;\n\t\tif (MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, sw_owner) ||\n\t\t    MLX5_CAP_FLOWTABLE_NIC_RX(dev->mdev, sw_owner_v2)) {\n\t\t\tparams->resp.tir_icm_addr =\n\t\t\t\tMLX5_GET(create_tir_out, out, icm_address_31_0);\n\t\t\tparams->resp.tir_icm_addr |=\n\t\t\t\t(u64)MLX5_GET(create_tir_out, out,\n\t\t\t\t\t      icm_address_39_32)\n\t\t\t\t<< 32;\n\t\t\tparams->resp.tir_icm_addr |=\n\t\t\t\t(u64)MLX5_GET(create_tir_out, out,\n\t\t\t\t\t      icm_address_63_40)\n\t\t\t\t<< 40;\n\t\t\tparams->resp.comp_mask |=\n\t\t\t\tMLX5_IB_CREATE_QP_RESP_MASK_TIR_ICM_ADDR;\n\t\t}\n\t}\n\n\tkvfree(in);\n\t \n\tqp->trans_qp.base.mqp.qpn = 0;\n\tqp->is_rss = true;\n\treturn 0;\n\nerr:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic void configure_requester_scat_cqe(struct mlx5_ib_dev *dev,\n\t\t\t\t\t struct mlx5_ib_qp *qp,\n\t\t\t\t\t struct ib_qp_init_attr *init_attr,\n\t\t\t\t\t void *qpc)\n{\n\tint scqe_sz;\n\tbool allow_scat_cqe = false;\n\n\tallow_scat_cqe = qp->flags_en & MLX5_QP_FLAG_ALLOW_SCATTER_CQE;\n\n\tif (!allow_scat_cqe && init_attr->sq_sig_type != IB_SIGNAL_ALL_WR)\n\t\treturn;\n\n\tscqe_sz = mlx5_ib_get_cqe_size(init_attr->send_cq);\n\tif (scqe_sz == 128) {\n\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA64_CQE);\n\t\treturn;\n\t}\n\n\tif (init_attr->qp_type != MLX5_IB_QPT_DCI ||\n\t    MLX5_CAP_GEN(dev->mdev, dc_req_scat_data_cqe))\n\t\tMLX5_SET(qpc, qpc, cs_req, MLX5_REQ_SCAT_DATA32_CQE);\n}\n\nstatic int atomic_size_to_mode(int size_mask)\n{\n\t \n\tint supported_size_mask = size_mask & 0x1ff;\n\tint log_max_size;\n\n\tif (!supported_size_mask)\n\t\treturn -EOPNOTSUPP;\n\n\tlog_max_size = __fls(supported_size_mask);\n\n\tif (log_max_size > 3)\n\t\treturn log_max_size;\n\n\treturn MLX5_ATOMIC_MODE_8B;\n}\n\nstatic int get_atomic_mode(struct mlx5_ib_dev *dev,\n\t\t\t   enum ib_qp_type qp_type)\n{\n\tu8 atomic_operations = MLX5_CAP_ATOMIC(dev->mdev, atomic_operations);\n\tu8 atomic = MLX5_CAP_GEN(dev->mdev, atomic);\n\tint atomic_mode = -EOPNOTSUPP;\n\tint atomic_size_mask;\n\n\tif (!atomic)\n\t\treturn -EOPNOTSUPP;\n\n\tif (qp_type == MLX5_IB_QPT_DCT)\n\t\tatomic_size_mask = MLX5_CAP_ATOMIC(dev->mdev, atomic_size_dc);\n\telse\n\t\tatomic_size_mask = MLX5_CAP_ATOMIC(dev->mdev, atomic_size_qp);\n\n\tif ((atomic_operations & MLX5_ATOMIC_OPS_EXTENDED_CMP_SWAP) ||\n\t    (atomic_operations & MLX5_ATOMIC_OPS_EXTENDED_FETCH_ADD))\n\t\tatomic_mode = atomic_size_to_mode(atomic_size_mask);\n\n\tif (atomic_mode <= 0 &&\n\t    (atomic_operations & MLX5_ATOMIC_OPS_CMP_SWAP &&\n\t     atomic_operations & MLX5_ATOMIC_OPS_FETCH_ADD))\n\t\tatomic_mode = MLX5_ATOMIC_MODE_IB_COMP;\n\n\treturn atomic_mode;\n}\n\nstatic int create_xrc_tgt_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t     struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *attr = params->attr;\n\tu32 uidx = params->uidx;\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_qp_base *base;\n\tunsigned long flags;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tif (attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, MLX5_QP_ST_XRC);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, to_mpd(devr->p0)->pdn);\n\n\tif (qp->flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\tif (qp->flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & IB_QP_CREATE_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & IB_QP_CREATE_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\n\tMLX5_SET(qpc, qpc, ts_format, mlx5_get_qp_default_ts(dev->mdev));\n\tMLX5_SET(qpc, qpc, rq_type, MLX5_SRQ_RQ);\n\tMLX5_SET(qpc, qpc, no_sq, 1);\n\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(devr->c0)->mcq.cqn);\n\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\tMLX5_SET(qpc, qpc, xrcd, to_mxrcd(attr->xrcd)->xrcdn);\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t \n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\tif (qp->flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t \n\t\tqp->flags &= ~IB_QP_CREATE_PCI_WRITE_END_PADDING;\n\t}\n\n\tbase = &qp->trans_qp.base;\n\terr = mlx5_qpc_create_qp(dev, &base->mqp, in, inlen, out);\n\tkvfree(in);\n\tif (err)\n\t\treturn err;\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\tif (MLX5_CAP_GEN(mdev, ece_support))\n\t\tparams->resp.ece_options = MLX5_GET(create_qp_out, out, ece);\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\tqp->trans_qp.xrcdn = to_mxrcd(attr->xrcd)->xrcdn;\n\treturn 0;\n}\n\nstatic int create_dci(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t      struct mlx5_ib_qp *qp,\n\t\t      struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *init_attr = params->attr;\n\tstruct mlx5_ib_create_qp *ucmd = params->ucmd;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tstruct ib_udata *udata = params->udata;\n\tu32 uidx = params->uidx;\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tstruct mlx5_ib_qp_base *base;\n\tint ts_format;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(qp->type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tbase = &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq, qp, ucmd);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ucmd->rq_wqe_shift != qp->rq.wqe_shift ||\n\t    ucmd->rq_wqe_count != qp->rq.wqe_cnt)\n\t\treturn -EINVAL;\n\n\tif (ucmd->sq_wqe_count > (1 << MLX5_CAP_GEN(mdev, log_max_qp_sz)))\n\t\treturn -EINVAL;\n\n\tts_format = get_qp_ts_format(dev, to_mcq(init_attr->send_cq),\n\t\t\t\t     to_mcq(init_attr->recv_cq));\n\n\tif (ts_format < 0)\n\t\treturn ts_format;\n\n\terr = _create_user_qp(dev, pd, qp, udata, init_attr, &in, &params->resp,\n\t\t\t      &inlen, base, ucmd);\n\tif (err)\n\t\treturn err;\n\n\tif (MLX5_CAP_GEN(mdev, ece_support))\n\t\tMLX5_SET(create_qp_in, in, ece, ucmd->ece_options);\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, to_mpd(pd)->pdn);\n\n\tif (qp->flags_en & MLX5_QP_FLAG_SIGNATURE)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & IB_QP_CREATE_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags_en & MLX5_QP_FLAG_SCATTER_CQE)\n\t\tconfigure_requester_scat_cqe(dev, qp, init_attr, qpc);\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tif (qp->flags_en & MLX5_QP_FLAG_DCI_STREAM) {\n\t\tMLX5_SET(qpc, qpc, log_num_dci_stream_channels,\n\t\t\t ucmd->dci_streams.log_num_concurent);\n\t\tMLX5_SET(qpc, qpc, log_num_dci_errored_streams,\n\t\t\t ucmd->dci_streams.log_num_errored);\n\t}\n\n\tMLX5_SET(qpc, qpc, ts_format, ts_format);\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\n\t \n\tif (init_attr->srq) {\n\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn0);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn,\n\t\t\t to_msrq(init_attr->srq)->msrq.srqn);\n\t} else {\n\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn1);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn,\n\t\t\t to_msrq(devr->s1)->msrq.srqn);\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd,\n\t\t\t to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv,\n\t\t\t to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t \n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\tif (qp->flags & IB_QP_CREATE_PCI_WRITE_END_PADDING) {\n\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t \n\t\tqp->flags &= ~IB_QP_CREATE_PCI_WRITE_END_PADDING;\n\t}\n\n\terr = mlx5_qpc_create_qp(dev, &base->mqp, in, inlen, out);\n\n\tkvfree(in);\n\tif (err)\n\t\tgoto err_create;\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\tif (MLX5_CAP_GEN(mdev, ece_support))\n\t\tparams->resp.ece_options = MLX5_GET(create_qp_out, out, ece);\n\n\tget_cqs(qp->type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t \n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t \n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tdestroy_qp(dev, qp, base, udata);\n\treturn err;\n}\n\nstatic int create_user_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t  struct mlx5_ib_qp *qp,\n\t\t\t  struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *init_attr = params->attr;\n\tstruct mlx5_ib_create_qp *ucmd = params->ucmd;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tstruct ib_udata *udata = params->udata;\n\tu32 uidx = params->uidx;\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tstruct mlx5_ib_qp_base *base;\n\tint ts_format;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(qp->type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (init_attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tif (qp->flags & IB_QP_CREATE_SOURCE_QPN)\n\t\tqp->underlay_qpn = init_attr->source_qpn;\n\n\tbase = (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & IB_QP_CREATE_SOURCE_QPN) ?\n\t       &qp->raw_packet_qp.rq.base :\n\t       &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(init_attr);\n\terr = set_rq_size(dev, &init_attr->cap, qp->has_rq, qp, ucmd);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (ucmd->rq_wqe_shift != qp->rq.wqe_shift ||\n\t    ucmd->rq_wqe_count != qp->rq.wqe_cnt)\n\t\treturn -EINVAL;\n\n\tif (ucmd->sq_wqe_count > (1 << MLX5_CAP_GEN(mdev, log_max_qp_sz)))\n\t\treturn -EINVAL;\n\n\tif (init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\tts_format = get_qp_ts_format(dev, to_mcq(init_attr->send_cq),\n\t\t\t\t\t     to_mcq(init_attr->recv_cq));\n\t\tif (ts_format < 0)\n\t\t\treturn ts_format;\n\t}\n\n\terr = _create_user_qp(dev, pd, qp, udata, init_attr, &in, &params->resp,\n\t\t\t      &inlen, base, ucmd);\n\tif (err)\n\t\treturn err;\n\n\tif (is_sqp(init_attr->qp_type))\n\t\tqp->port = init_attr->port_num;\n\n\tif (MLX5_CAP_GEN(mdev, ece_support))\n\t\tMLX5_SET(create_qp_in, in, ece, ucmd->ece_options);\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\tMLX5_SET(qpc, qpc, pd, to_mpd(pd)->pdn);\n\n\tif (qp->flags_en & MLX5_QP_FLAG_SIGNATURE)\n\t\tMLX5_SET(qpc, qpc, wq_signature, 1);\n\n\tif (qp->flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->flags & IB_QP_CREATE_CROSS_CHANNEL)\n\t\tMLX5_SET(qpc, qpc, cd_master, 1);\n\tif (qp->flags & IB_QP_CREATE_MANAGED_SEND)\n\t\tMLX5_SET(qpc, qpc, cd_slave_send, 1);\n\tif (qp->flags & IB_QP_CREATE_MANAGED_RECV)\n\t\tMLX5_SET(qpc, qpc, cd_slave_receive, 1);\n\tif (qp->flags_en & MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE)\n\t\tMLX5_SET(qpc, qpc, req_e2e_credit_mode, 1);\n\tif ((qp->flags_en & MLX5_QP_FLAG_SCATTER_CQE) &&\n\t    (init_attr->qp_type == IB_QPT_RC ||\n\t     init_attr->qp_type == IB_QPT_UC)) {\n\t\tint rcqe_sz = mlx5_ib_get_cqe_size(init_attr->recv_cq);\n\n\t\tMLX5_SET(qpc, qpc, cs_res,\n\t\t\t rcqe_sz == 128 ? MLX5_RES_SCAT_DATA64_CQE :\n\t\t\t\t\t  MLX5_RES_SCAT_DATA32_CQE);\n\t}\n\tif ((qp->flags_en & MLX5_QP_FLAG_SCATTER_CQE) &&\n\t    (qp->type == MLX5_IB_QPT_DCI || qp->type == IB_QPT_RC))\n\t\tconfigure_requester_scat_cqe(dev, qp, init_attr, qpc);\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tif (init_attr->qp_type != IB_QPT_RAW_PACKET)\n\t\tMLX5_SET(qpc, qpc, ts_format, ts_format);\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, init_attr));\n\n\tif (qp->sq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\t} else {\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\t\tif (init_attr->srq &&\n\t\t    init_attr->srq->srq_type == IB_SRQT_TM)\n\t\t\tMLX5_SET(qpc, qpc, offload_type,\n\t\t\t\t MLX5_QPC_OFFLOAD_TYPE_RNDV);\n\t}\n\n\t \n\tswitch (init_attr->qp_type) {\n\tcase IB_QPT_XRC_INI:\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(devr->c0)->mcq.cqn);\n\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn1);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s0)->msrq.srqn);\n\t\tbreak;\n\tdefault:\n\t\tif (init_attr->srq) {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn0);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(init_attr->srq)->msrq.srqn);\n\t\t} else {\n\t\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn1);\n\t\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn, to_msrq(devr->s1)->msrq.srqn);\n\t\t}\n\t}\n\n\tif (init_attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(init_attr->send_cq)->mcq.cqn);\n\n\tif (init_attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(init_attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t \n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\tif (qp->flags & IB_QP_CREATE_PCI_WRITE_END_PADDING &&\n\t    init_attr->qp_type != IB_QPT_RAW_PACKET) {\n\t\tMLX5_SET(qpc, qpc, end_padding_mode,\n\t\t\t MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t \n\t\tqp->flags &= ~IB_QP_CREATE_PCI_WRITE_END_PADDING;\n\t}\n\n\tif (init_attr->qp_type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tqp->raw_packet_qp.sq.ubuffer.buf_addr = ucmd->sq_buf_addr;\n\t\traw_packet_qp_copy_info(qp, &qp->raw_packet_qp);\n\t\terr = create_raw_packet_qp(dev, qp, in, inlen, pd, udata,\n\t\t\t\t\t   &params->resp, init_attr);\n\t} else\n\t\terr = mlx5_qpc_create_qp(dev, &base->mqp, in, inlen, out);\n\n\tkvfree(in);\n\tif (err)\n\t\tgoto err_create;\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\tif (MLX5_CAP_GEN(mdev, ece_support))\n\t\tparams->resp.ece_options = MLX5_GET(create_qp_out, out, ece);\n\n\tget_cqs(qp->type, init_attr->send_cq, init_attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t \n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t \n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tdestroy_qp(dev, qp, base, udata);\n\treturn err;\n}\n\nstatic int create_kernel_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct mlx5_ib_qp *qp,\n\t\t\t    struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *attr = params->attr;\n\tu32 uidx = params->uidx;\n\tstruct mlx5_ib_resources *devr = &dev->devr;\n\tu32 out[MLX5_ST_SZ_DW(create_qp_out)] = {};\n\tint inlen = MLX5_ST_SZ_BYTES(create_qp_in);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_ib_cq *send_cq;\n\tstruct mlx5_ib_cq *recv_cq;\n\tunsigned long flags;\n\tstruct mlx5_ib_qp_base *base;\n\tint mlx5_st;\n\tvoid *qpc;\n\tu32 *in;\n\tint err;\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tmlx5_st = to_mlx5_st(qp->type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tif (attr->sq_sig_type == IB_SIGNAL_ALL_WR)\n\t\tqp->sq_signal_bits = MLX5_WQE_CTRL_CQ_UPDATE;\n\n\tbase = &qp->trans_qp.base;\n\n\tqp->has_rq = qp_has_rq(attr);\n\terr = set_rq_size(dev, &attr->cap, qp->has_rq, qp, NULL);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = _create_kernel_qp(dev, attr, qp, &in, &inlen, base);\n\tif (err)\n\t\treturn err;\n\n\tif (is_sqp(attr->qp_type))\n\t\tqp->port = attr->port_num;\n\n\tqpc = MLX5_ADDR_OF(create_qp_in, in, qpc);\n\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\n\tif (attr->qp_type != MLX5_IB_QPT_REG_UMR)\n\t\tMLX5_SET(qpc, qpc, pd, to_mpd(pd ? pd : devr->p0)->pdn);\n\telse\n\t\tMLX5_SET(qpc, qpc, latency_sensitive, 1);\n\n\n\tif (qp->flags & IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK)\n\t\tMLX5_SET(qpc, qpc, block_lb_mc, 1);\n\n\tif (qp->rq.wqe_cnt) {\n\t\tMLX5_SET(qpc, qpc, log_rq_stride, qp->rq.wqe_shift - 4);\n\t\tMLX5_SET(qpc, qpc, log_rq_size, ilog2(qp->rq.wqe_cnt));\n\t}\n\n\tMLX5_SET(qpc, qpc, rq_type, get_rx_type(qp, attr));\n\n\tif (qp->sq.wqe_cnt)\n\t\tMLX5_SET(qpc, qpc, log_sq_size, ilog2(qp->sq.wqe_cnt));\n\telse\n\t\tMLX5_SET(qpc, qpc, no_sq, 1);\n\n\tif (attr->srq) {\n\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn0);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn,\n\t\t\t to_msrq(attr->srq)->msrq.srqn);\n\t} else {\n\t\tMLX5_SET(qpc, qpc, xrcd, devr->xrcdn1);\n\t\tMLX5_SET(qpc, qpc, srqn_rmpn_xrqn,\n\t\t\t to_msrq(devr->s1)->msrq.srqn);\n\t}\n\n\tif (attr->send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, to_mcq(attr->send_cq)->mcq.cqn);\n\n\tif (attr->recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, to_mcq(attr->recv_cq)->mcq.cqn);\n\n\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\t \n\tif (MLX5_CAP_GEN(mdev, cqe_version) == MLX5_CQE_VERSION_V1)\n\t\tMLX5_SET(qpc, qpc, user_index, uidx);\n\n\t \n\tif (qp->flags & IB_QP_CREATE_IPOIB_UD_LSO)\n\t\tMLX5_SET(qpc, qpc, ulp_stateless_offload_mode, 1);\n\n\tif (qp->flags & IB_QP_CREATE_INTEGRITY_EN &&\n\t    MLX5_CAP_GEN(mdev, go_back_n))\n\t\tMLX5_SET(qpc, qpc, retry_mode, MLX5_QP_RM_GO_BACK_N);\n\n\terr = mlx5_qpc_create_qp(dev, &base->mqp, in, inlen, out);\n\tkvfree(in);\n\tif (err)\n\t\tgoto err_create;\n\n\tbase->container_mibqp = qp;\n\tbase->mqp.event = mlx5_ib_qp_event;\n\n\tget_cqs(qp->type, attr->send_cq, attr->recv_cq,\n\t\t&send_cq, &recv_cq);\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t \n\tlist_add_tail(&qp->qps_list, &dev->qp_list);\n\t \n\tif (send_cq)\n\t\tlist_add_tail(&qp->cq_send_list, &send_cq->list_send_qp);\n\tif (recv_cq)\n\t\tlist_add_tail(&qp->cq_recv_list, &recv_cq->list_recv_qp);\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\treturn 0;\n\nerr_create:\n\tdestroy_qp(dev, qp, base, NULL);\n\treturn err;\n}\n\nstatic void mlx5_ib_lock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__acquires(&send_cq->lock) __acquires(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\tspin_lock_nested(&recv_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\tspin_lock(&send_cq->lock);\n\t\t\t\t__acquire(&recv_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_lock(&recv_cq->lock);\n\t\t\t\tspin_lock_nested(&send_cq->lock,\n\t\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock(&send_cq->lock);\n\t\t\t__acquire(&recv_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\tspin_lock(&recv_cq->lock);\n\t\t__acquire(&send_cq->lock);\n\t} else {\n\t\t__acquire(&send_cq->lock);\n\t\t__acquire(&recv_cq->lock);\n\t}\n}\n\nstatic void mlx5_ib_unlock_cqs(struct mlx5_ib_cq *send_cq, struct mlx5_ib_cq *recv_cq)\n\t__releases(&send_cq->lock) __releases(&recv_cq->lock)\n{\n\tif (send_cq) {\n\t\tif (recv_cq) {\n\t\t\tif (send_cq->mcq.cqn < recv_cq->mcq.cqn)  {\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else if (send_cq->mcq.cqn == recv_cq->mcq.cqn) {\n\t\t\t\t__release(&recv_cq->lock);\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&send_cq->lock);\n\t\t\t\tspin_unlock(&recv_cq->lock);\n\t\t\t}\n\t\t} else {\n\t\t\t__release(&recv_cq->lock);\n\t\t\tspin_unlock(&send_cq->lock);\n\t\t}\n\t} else if (recv_cq) {\n\t\t__release(&send_cq->lock);\n\t\tspin_unlock(&recv_cq->lock);\n\t} else {\n\t\t__release(&recv_cq->lock);\n\t\t__release(&send_cq->lock);\n\t}\n}\n\nstatic void get_cqs(enum ib_qp_type qp_type,\n\t\t    struct ib_cq *ib_send_cq, struct ib_cq *ib_recv_cq,\n\t\t    struct mlx5_ib_cq **send_cq, struct mlx5_ib_cq **recv_cq)\n{\n\tswitch (qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\tcase MLX5_IB_QPT_REG_UMR:\n\tcase IB_QPT_XRC_INI:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_UD:\n\tcase IB_QPT_RAW_PACKET:\n\t\t*send_cq = ib_send_cq ? to_mcq(ib_send_cq) : NULL;\n\t\t*recv_cq = ib_recv_cq ? to_mcq(ib_recv_cq) : NULL;\n\t\tbreak;\n\tdefault:\n\t\t*send_cq = NULL;\n\t\t*recv_cq = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 lag_tx_affinity);\n\nstatic void destroy_qp_common(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_ib_qp_base *base;\n\tunsigned long flags;\n\tint err;\n\n\tif (qp->is_rss) {\n\t\tdestroy_rss_raw_qp_tir(dev, qp);\n\t\treturn;\n\t}\n\n\tbase = (qp->type == IB_QPT_RAW_PACKET ||\n\t\tqp->flags & IB_QP_CREATE_SOURCE_QPN) ?\n\t\t       &qp->raw_packet_qp.rq.base :\n\t\t       &qp->trans_qp.base;\n\n\tif (qp->state != IB_QPS_RESET) {\n\t\tif (qp->type != IB_QPT_RAW_PACKET &&\n\t\t    !(qp->flags & IB_QP_CREATE_SOURCE_QPN)) {\n\t\t\terr = mlx5_core_qp_modify(dev, MLX5_CMD_OP_2RST_QP, 0,\n\t\t\t\t\t\t  NULL, &base->mqp, NULL);\n\t\t} else {\n\t\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {\n\t\t\t\t.operation = MLX5_CMD_OP_2RST_QP\n\t\t\t};\n\n\t\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, 0);\n\t\t}\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"mlx5_ib: modify QP 0x%06x to RESET failed\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tget_cqs(qp->type, qp->ibqp.send_cq, qp->ibqp.recv_cq, &send_cq,\n\t\t&recv_cq);\n\n\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\tmlx5_ib_lock_cqs(send_cq, recv_cq);\n\t \n\tlist_del(&qp->qps_list);\n\tif (send_cq)\n\t\tlist_del(&qp->cq_send_list);\n\n\tif (recv_cq)\n\t\tlist_del(&qp->cq_recv_list);\n\n\tif (!udata) {\n\t\t__mlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t   qp->ibqp.srq ? to_msrq(qp->ibqp.srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\t__mlx5_ib_cq_clean(send_cq, base->mqp.qpn,\n\t\t\t\t\t   NULL);\n\t}\n\tmlx5_ib_unlock_cqs(send_cq, recv_cq);\n\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\tif (qp->type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tdestroy_raw_packet_qp(dev, qp);\n\t} else {\n\t\terr = mlx5_core_destroy_qp(dev, &base->mqp);\n\t\tif (err)\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy QP 0x%x\\n\",\n\t\t\t\t     base->mqp.qpn);\n\t}\n\n\tdestroy_qp(dev, qp, base, udata);\n}\n\nstatic int create_dct(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t      struct mlx5_ib_qp *qp,\n\t\t      struct mlx5_create_qp_params *params)\n{\n\tstruct ib_qp_init_attr *attr = params->attr;\n\tstruct mlx5_ib_create_qp *ucmd = params->ucmd;\n\tu32 uidx = params->uidx;\n\tvoid *dctc;\n\n\tif (mlx5_lag_is_active(dev->mdev) && !MLX5_CAP_GEN(dev->mdev, lag_dct))\n\t\treturn -EOPNOTSUPP;\n\n\tqp->dct.in = kzalloc(MLX5_ST_SZ_BYTES(create_dct_in), GFP_KERNEL);\n\tif (!qp->dct.in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_dct_in, qp->dct.in, uid, to_mpd(pd)->uid);\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tMLX5_SET(dctc, dctc, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(dctc, dctc, srqn_xrqn, to_msrq(attr->srq)->msrq.srqn);\n\tMLX5_SET(dctc, dctc, cqn, to_mcq(attr->recv_cq)->mcq.cqn);\n\tMLX5_SET64(dctc, dctc, dc_access_key, ucmd->access_key);\n\tMLX5_SET(dctc, dctc, user_index, uidx);\n\tif (MLX5_CAP_GEN(dev->mdev, ece_support))\n\t\tMLX5_SET(dctc, dctc, ece, ucmd->ece_options);\n\n\tif (qp->flags_en & MLX5_QP_FLAG_SCATTER_CQE) {\n\t\tint rcqe_sz = mlx5_ib_get_cqe_size(attr->recv_cq);\n\n\t\tif (rcqe_sz == 128)\n\t\t\tMLX5_SET(dctc, dctc, cs_res, MLX5_RES_SCAT_DATA64_CQE);\n\t}\n\n\tqp->state = IB_QPS_RESET;\n\treturn 0;\n}\n\nstatic int check_qp_type(struct mlx5_ib_dev *dev, struct ib_qp_init_attr *attr,\n\t\t\t enum ib_qp_type *type)\n{\n\tif (attr->qp_type == IB_QPT_DRIVER && !MLX5_CAP_GEN(dev->mdev, dct))\n\t\tgoto out;\n\n\tswitch (attr->qp_type) {\n\tcase IB_QPT_XRC_TGT:\n\tcase IB_QPT_XRC_INI:\n\t\tif (!MLX5_CAP_GEN(dev->mdev, xrc))\n\t\t\tgoto out;\n\t\tfallthrough;\n\tcase IB_QPT_RC:\n\tcase IB_QPT_UC:\n\tcase IB_QPT_SMI:\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase IB_QPT_DRIVER:\n\tcase IB_QPT_GSI:\n\tcase IB_QPT_RAW_PACKET:\n\tcase IB_QPT_UD:\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\tbreak;\n\tdefault:\n\t\tgoto out;\n\t}\n\n\t*type = attr->qp_type;\n\treturn 0;\n\nout:\n\tmlx5_ib_dbg(dev, \"Unsupported QP type %d\\n\", attr->qp_type);\n\treturn -EOPNOTSUPP;\n}\n\nstatic int check_valid_flow(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t\t    struct ib_qp_init_attr *attr,\n\t\t\t    struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\n\tif (!udata) {\n\t\t \n\t\tif (attr->rwq_ind_tbl)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tswitch (attr->qp_type) {\n\t\tcase IB_QPT_RAW_PACKET:\n\t\tcase IB_QPT_DRIVER:\n\t\t\treturn -EOPNOTSUPP;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (attr->qp_type == IB_QPT_RAW_PACKET && !ucontext->cqe_version) {\n\t\tmlx5_ib_dbg(dev,\n\t\t\t\"Raw Packet QP is only supported for CQE version > 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->qp_type != IB_QPT_RAW_PACKET && attr->rwq_ind_tbl) {\n\t\tmlx5_ib_dbg(dev,\n\t\t\t    \"Wrong QP type %d for the RWQ indirect table\\n\",\n\t\t\t    attr->qp_type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tWARN_ONCE(!pd && attr->qp_type != IB_QPT_XRC_TGT,\n\t\t  \"There is a missing PD pointer assignment\\n\");\n\treturn 0;\n}\n\nstatic void process_vendor_flag(struct mlx5_ib_dev *dev, int *flags, int flag,\n\t\t\t\tbool cond, struct mlx5_ib_qp *qp)\n{\n\tif (!(*flags & flag))\n\t\treturn;\n\n\tif (cond) {\n\t\tqp->flags_en |= flag;\n\t\t*flags &= ~flag;\n\t\treturn;\n\t}\n\n\tswitch (flag) {\n\tcase MLX5_QP_FLAG_SCATTER_CQE:\n\tcase MLX5_QP_FLAG_ALLOW_SCATTER_CQE:\n\t\t \n\t\t*flags &= ~(MLX5_QP_FLAG_SCATTER_CQE |\n\t\t\t    MLX5_QP_FLAG_ALLOW_SCATTER_CQE);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\tmlx5_ib_dbg(dev, \"Vendor create QP flag 0x%X is not supported\\n\", flag);\n}\n\nstatic int process_vendor_flags(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tvoid *ucmd, struct ib_qp_init_attr *attr)\n{\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tbool cond;\n\tint flags;\n\n\tif (attr->rwq_ind_tbl)\n\t\tflags = ((struct mlx5_ib_create_qp_rss *)ucmd)->flags;\n\telse\n\t\tflags = ((struct mlx5_ib_create_qp *)ucmd)->flags;\n\n\tswitch (flags & (MLX5_QP_FLAG_TYPE_DCT | MLX5_QP_FLAG_TYPE_DCI)) {\n\tcase MLX5_QP_FLAG_TYPE_DCI:\n\t\tqp->type = MLX5_IB_QPT_DCI;\n\t\tbreak;\n\tcase MLX5_QP_FLAG_TYPE_DCT:\n\t\tqp->type = MLX5_IB_QPT_DCT;\n\t\tbreak;\n\tdefault:\n\t\tif (qp->type != IB_QPT_DRIVER)\n\t\t\tbreak;\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_TYPE_DCI, true, qp);\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_TYPE_DCT, true, qp);\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_DCI_STREAM,\n\t\t\t    MLX5_CAP_GEN(mdev, log_max_dci_stream_channels),\n\t\t\t    qp);\n\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_SIGNATURE, true, qp);\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_SCATTER_CQE,\n\t\t\t    MLX5_CAP_GEN(mdev, sctr_data_cqe), qp);\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_ALLOW_SCATTER_CQE,\n\t\t\t    MLX5_CAP_GEN(mdev, sctr_data_cqe), qp);\n\n\tif (qp->type == IB_QPT_RAW_PACKET) {\n\t\tcond = MLX5_CAP_ETH(mdev, tunnel_stateless_vxlan) ||\n\t\t       MLX5_CAP_ETH(mdev, tunnel_stateless_gre) ||\n\t\t       MLX5_CAP_ETH(mdev, tunnel_stateless_geneve_rx);\n\t\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_TUNNEL_OFFLOADS,\n\t\t\t\t    cond, qp);\n\t\tprocess_vendor_flag(dev, &flags,\n\t\t\t\t    MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC, true,\n\t\t\t\t    qp);\n\t\tprocess_vendor_flag(dev, &flags,\n\t\t\t\t    MLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC, true,\n\t\t\t\t    qp);\n\t}\n\n\tif (qp->type == IB_QPT_RC)\n\t\tprocess_vendor_flag(dev, &flags,\n\t\t\t\t    MLX5_QP_FLAG_PACKET_BASED_CREDIT_MODE,\n\t\t\t\t    MLX5_CAP_GEN(mdev, qp_packet_based), qp);\n\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_BFREG_INDEX, true, qp);\n\tprocess_vendor_flag(dev, &flags, MLX5_QP_FLAG_UAR_PAGE_INDEX, true, qp);\n\n\tcond = qp->flags_en & ~(MLX5_QP_FLAG_TUNNEL_OFFLOADS |\n\t\t\t\tMLX5_QP_FLAG_TIR_ALLOW_SELF_LB_UC |\n\t\t\t\tMLX5_QP_FLAG_TIR_ALLOW_SELF_LB_MC);\n\tif (attr->rwq_ind_tbl && cond) {\n\t\tmlx5_ib_dbg(dev, \"RSS RAW QP has unsupported flags 0x%X\\n\",\n\t\t\t    cond);\n\t\treturn -EINVAL;\n\t}\n\n\tif (flags)\n\t\tmlx5_ib_dbg(dev, \"udata has unsupported flags 0x%X\\n\", flags);\n\n\treturn (flags) ? -EINVAL : 0;\n\t}\n\nstatic void process_create_flag(struct mlx5_ib_dev *dev, int *flags, int flag,\n\t\t\t\tbool cond, struct mlx5_ib_qp *qp)\n{\n\tif (!(*flags & flag))\n\t\treturn;\n\n\tif (cond) {\n\t\tqp->flags |= flag;\n\t\t*flags &= ~flag;\n\t\treturn;\n\t}\n\n\tif (flag == MLX5_IB_QP_CREATE_WC_TEST) {\n\t\t \n\t\t*flags &= ~MLX5_IB_QP_CREATE_WC_TEST;\n\t\treturn;\n\t}\n\tmlx5_ib_dbg(dev, \"Verbs create QP flag 0x%X is not supported\\n\", flag);\n}\n\nstatic int process_create_flags(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tstruct ib_qp_init_attr *attr)\n{\n\tenum ib_qp_type qp_type = qp->type;\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tint create_flags = attr->create_flags;\n\tbool cond;\n\n\tif (qp_type == MLX5_IB_QPT_DCT)\n\t\treturn (create_flags) ? -EINVAL : 0;\n\n\tif (qp_type == IB_QPT_RAW_PACKET && attr->rwq_ind_tbl)\n\t\treturn (create_flags) ? -EINVAL : 0;\n\n\tprocess_create_flag(dev, &create_flags, IB_QP_CREATE_NETIF_QP,\n\t\t\t    mlx5_get_flow_namespace(dev->mdev,\n\t\t\t\t\t\t    MLX5_FLOW_NAMESPACE_BYPASS),\n\t\t\t    qp);\n\tprocess_create_flag(dev, &create_flags,\n\t\t\t    IB_QP_CREATE_INTEGRITY_EN,\n\t\t\t    MLX5_CAP_GEN(mdev, sho), qp);\n\tprocess_create_flag(dev, &create_flags,\n\t\t\t    IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK,\n\t\t\t    MLX5_CAP_GEN(mdev, block_lb_mc), qp);\n\tprocess_create_flag(dev, &create_flags, IB_QP_CREATE_CROSS_CHANNEL,\n\t\t\t    MLX5_CAP_GEN(mdev, cd), qp);\n\tprocess_create_flag(dev, &create_flags, IB_QP_CREATE_MANAGED_SEND,\n\t\t\t    MLX5_CAP_GEN(mdev, cd), qp);\n\tprocess_create_flag(dev, &create_flags, IB_QP_CREATE_MANAGED_RECV,\n\t\t\t    MLX5_CAP_GEN(mdev, cd), qp);\n\n\tif (qp_type == IB_QPT_UD) {\n\t\tprocess_create_flag(dev, &create_flags,\n\t\t\t\t    IB_QP_CREATE_IPOIB_UD_LSO,\n\t\t\t\t    MLX5_CAP_GEN(mdev, ipoib_basic_offloads),\n\t\t\t\t    qp);\n\t\tcond = MLX5_CAP_GEN(mdev, port_type) == MLX5_CAP_PORT_TYPE_IB;\n\t\tprocess_create_flag(dev, &create_flags, IB_QP_CREATE_SOURCE_QPN,\n\t\t\t\t    cond, qp);\n\t}\n\n\tif (qp_type == IB_QPT_RAW_PACKET) {\n\t\tcond = MLX5_CAP_GEN(mdev, eth_net_offloads) &&\n\t\t       MLX5_CAP_ETH(mdev, scatter_fcs);\n\t\tprocess_create_flag(dev, &create_flags,\n\t\t\t\t    IB_QP_CREATE_SCATTER_FCS, cond, qp);\n\n\t\tcond = MLX5_CAP_GEN(mdev, eth_net_offloads) &&\n\t\t       MLX5_CAP_ETH(mdev, vlan_cap);\n\t\tprocess_create_flag(dev, &create_flags,\n\t\t\t\t    IB_QP_CREATE_CVLAN_STRIPPING, cond, qp);\n\t}\n\n\tprocess_create_flag(dev, &create_flags,\n\t\t\t    IB_QP_CREATE_PCI_WRITE_END_PADDING,\n\t\t\t    MLX5_CAP_GEN(mdev, end_pad), qp);\n\n\tprocess_create_flag(dev, &create_flags, MLX5_IB_QP_CREATE_WC_TEST,\n\t\t\t    qp_type != MLX5_IB_QPT_REG_UMR, qp);\n\tprocess_create_flag(dev, &create_flags, MLX5_IB_QP_CREATE_SQPN_QP1,\n\t\t\t    true, qp);\n\n\tif (create_flags) {\n\t\tmlx5_ib_dbg(dev, \"Create QP has unsupported flags 0x%X\\n\",\n\t\t\t    create_flags);\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic int process_udata_size(struct mlx5_ib_dev *dev,\n\t\t\t      struct mlx5_create_qp_params *params)\n{\n\tsize_t ucmd = sizeof(struct mlx5_ib_create_qp);\n\tstruct ib_udata *udata = params->udata;\n\tsize_t outlen = udata->outlen;\n\tsize_t inlen = udata->inlen;\n\n\tparams->outlen = min(outlen, sizeof(struct mlx5_ib_create_qp_resp));\n\tparams->ucmd_size = ucmd;\n\tif (!params->is_rss_raw) {\n\t\t \n\t\tsize_t min_inlen =\n\t\t\toffsetof(struct mlx5_ib_create_qp, ece_options);\n\n\t\t \n\t\tparams->inlen = (inlen < min_inlen) ? 0 : min(inlen, ucmd);\n\t\tgoto out;\n\t}\n\n\t \n\tif (inlen < offsetofend(struct mlx5_ib_create_qp_rss, flags))\n\t\treturn -EINVAL;\n\n\tif (outlen < offsetofend(struct mlx5_ib_create_qp_resp, bfreg_index))\n\t\treturn -EINVAL;\n\n\tucmd = sizeof(struct mlx5_ib_create_qp_rss);\n\tparams->ucmd_size = ucmd;\n\tif (inlen > ucmd && !ib_is_udata_cleared(udata, ucmd, inlen - ucmd))\n\t\treturn -EINVAL;\n\n\tparams->inlen = min(ucmd, inlen);\nout:\n\tif (!params->inlen)\n\t\tmlx5_ib_dbg(dev, \"udata is too small\\n\");\n\n\treturn (params->inlen) ? 0 : -EINVAL;\n}\n\nstatic int create_qp(struct mlx5_ib_dev *dev, struct ib_pd *pd,\n\t\t     struct mlx5_ib_qp *qp,\n\t\t     struct mlx5_create_qp_params *params)\n{\n\tint err;\n\n\tif (params->is_rss_raw) {\n\t\terr = create_rss_raw_qp_tir(dev, pd, qp, params);\n\t\tgoto out;\n\t}\n\n\tswitch (qp->type) {\n\tcase MLX5_IB_QPT_DCT:\n\t\terr = create_dct(dev, pd, qp, params);\n\t\trdma_restrack_no_track(&qp->ibqp.res);\n\t\tbreak;\n\tcase MLX5_IB_QPT_DCI:\n\t\terr = create_dci(dev, pd, qp, params);\n\t\tbreak;\n\tcase IB_QPT_XRC_TGT:\n\t\terr = create_xrc_tgt_qp(dev, qp, params);\n\t\tbreak;\n\tcase IB_QPT_GSI:\n\t\terr = mlx5_ib_create_gsi(pd, qp, params->attr);\n\t\tbreak;\n\tcase MLX5_IB_QPT_HW_GSI:\n\tcase MLX5_IB_QPT_REG_UMR:\n\t\trdma_restrack_no_track(&qp->ibqp.res);\n\t\tfallthrough;\n\tdefault:\n\t\tif (params->udata)\n\t\t\terr = create_user_qp(dev, pd, qp, params);\n\t\telse\n\t\t\terr = create_kernel_qp(dev, pd, qp, params);\n\t}\n\nout:\n\tif (err) {\n\t\tmlx5_ib_err(dev, \"Create QP type %d failed\\n\", qp->type);\n\t\treturn err;\n\t}\n\n\tif (is_qp0(qp->type))\n\t\tqp->ibqp.qp_num = 0;\n\telse if (is_qp1(qp->type))\n\t\tqp->ibqp.qp_num = 1;\n\telse\n\t\tqp->ibqp.qp_num = qp->trans_qp.base.mqp.qpn;\n\n\tmlx5_ib_dbg(dev,\n\t\t\"QP type %d, ib qpn 0x%X, mlx qpn 0x%x, rcqn 0x%x, scqn 0x%x, ece 0x%x\\n\",\n\t\tqp->type, qp->ibqp.qp_num, qp->trans_qp.base.mqp.qpn,\n\t\tparams->attr->recv_cq ? to_mcq(params->attr->recv_cq)->mcq.cqn :\n\t\t\t\t\t-1,\n\t\tparams->attr->send_cq ? to_mcq(params->attr->send_cq)->mcq.cqn :\n\t\t\t\t\t-1,\n\t\tparams->resp.ece_options);\n\n\treturn 0;\n}\n\nstatic int check_qp_attr(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t struct ib_qp_init_attr *attr)\n{\n\tint ret = 0;\n\n\tswitch (qp->type) {\n\tcase MLX5_IB_QPT_DCT:\n\t\tret = (!attr->srq || !attr->recv_cq) ? -EINVAL : 0;\n\t\tbreak;\n\tcase MLX5_IB_QPT_DCI:\n\t\tret = (attr->cap.max_recv_wr || attr->cap.max_recv_sge) ?\n\t\t\t      -EINVAL :\n\t\t\t      0;\n\t\tbreak;\n\tcase IB_QPT_RAW_PACKET:\n\t\tret = (attr->rwq_ind_tbl && attr->send_cq) ? -EINVAL : 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tmlx5_ib_dbg(dev, \"QP type %d has wrong attributes\\n\", qp->type);\n\n\treturn ret;\n}\n\nstatic int get_qp_uidx(struct mlx5_ib_qp *qp,\n\t\t       struct mlx5_create_qp_params *params)\n{\n\tstruct mlx5_ib_create_qp *ucmd = params->ucmd;\n\tstruct ib_udata *udata = params->udata;\n\tstruct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\n\tif (params->is_rss_raw)\n\t\treturn 0;\n\n\treturn get_qp_user_index(ucontext, ucmd, sizeof(*ucmd), &params->uidx);\n}\n\nstatic int mlx5_ib_destroy_dct(struct mlx5_ib_qp *mqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(mqp->ibqp.device);\n\n\tif (mqp->state == IB_QPS_RTR) {\n\t\tint err;\n\n\t\terr = mlx5_core_destroy_dct(dev, &mqp->dct.mdct);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"failed to destroy DCT %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tkfree(mqp->dct.in);\n\treturn 0;\n}\n\nstatic int check_ucmd_data(struct mlx5_ib_dev *dev,\n\t\t\t   struct mlx5_create_qp_params *params)\n{\n\tstruct ib_udata *udata = params->udata;\n\tsize_t size, last;\n\tint ret;\n\n\tif (params->is_rss_raw)\n\t\t \n\t\tlast = sizeof(struct mlx5_ib_create_qp_rss);\n\telse\n\t\tlast = offsetof(struct mlx5_ib_create_qp, reserved);\n\n\tif (udata->inlen <= last)\n\t\treturn 0;\n\n\t \n\tsize = udata->inlen - last;\n\tret = ib_is_udata_cleared(params->udata, last, size);\n\tif (!ret)\n\t\tmlx5_ib_dbg(\n\t\t\tdev,\n\t\t\t\"udata is not cleared, inlen = %zu, ucmd = %zu, last = %zu, size = %zu\\n\",\n\t\t\tudata->inlen, params->ucmd_size, last, size);\n\treturn ret ? 0 : -EINVAL;\n}\n\nint mlx5_ib_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *attr,\n\t\t      struct ib_udata *udata)\n{\n\tstruct mlx5_create_qp_params params = {};\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct ib_pd *pd = ibqp->pd;\n\tenum ib_qp_type type;\n\tint err;\n\n\terr = check_qp_type(dev, attr, &type);\n\tif (err)\n\t\treturn err;\n\n\terr = check_valid_flow(dev, pd, attr, udata);\n\tif (err)\n\t\treturn err;\n\n\tparams.udata = udata;\n\tparams.uidx = MLX5_IB_DEFAULT_UIDX;\n\tparams.attr = attr;\n\tparams.is_rss_raw = !!attr->rwq_ind_tbl;\n\n\tif (udata) {\n\t\terr = process_udata_size(dev, &params);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = check_ucmd_data(dev, &params);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tparams.ucmd = kzalloc(params.ucmd_size, GFP_KERNEL);\n\t\tif (!params.ucmd)\n\t\t\treturn -ENOMEM;\n\n\t\terr = ib_copy_from_udata(params.ucmd, udata, params.inlen);\n\t\tif (err)\n\t\t\tgoto free_ucmd;\n\t}\n\n\tmutex_init(&qp->mutex);\n\tqp->type = type;\n\tif (udata) {\n\t\terr = process_vendor_flags(dev, qp, params.ucmd, attr);\n\t\tif (err)\n\t\t\tgoto free_ucmd;\n\n\t\terr = get_qp_uidx(qp, &params);\n\t\tif (err)\n\t\t\tgoto free_ucmd;\n\t}\n\terr = process_create_flags(dev, qp, attr);\n\tif (err)\n\t\tgoto free_ucmd;\n\n\terr = check_qp_attr(dev, qp, attr);\n\tif (err)\n\t\tgoto free_ucmd;\n\n\terr = create_qp(dev, pd, qp, &params);\n\tif (err)\n\t\tgoto free_ucmd;\n\n\tkfree(params.ucmd);\n\tparams.ucmd = NULL;\n\n\tif (udata)\n\t\t \n\t\terr = ib_copy_to_udata(udata, &params.resp, params.outlen);\n\tif (err)\n\t\tgoto destroy_qp;\n\n\treturn 0;\n\ndestroy_qp:\n\tswitch (qp->type) {\n\tcase MLX5_IB_QPT_DCT:\n\t\tmlx5_ib_destroy_dct(qp);\n\t\tbreak;\n\tcase IB_QPT_GSI:\n\t\tmlx5_ib_destroy_gsi(qp);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_qp_common(dev, qp, udata);\n\t}\n\nfree_ucmd:\n\tkfree(params.ucmd);\n\treturn err;\n}\n\nint mlx5_ib_destroy_qp(struct ib_qp *qp, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\n\tif (mqp->type == IB_QPT_GSI)\n\t\treturn mlx5_ib_destroy_gsi(mqp);\n\n\tif (mqp->type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_destroy_dct(mqp);\n\n\tdestroy_qp_common(dev, mqp, udata);\n\treturn 0;\n}\n\nstatic int set_qpc_atomic_flags(struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct ib_qp_attr *attr, int attr_mask,\n\t\t\t\tvoid *qpc)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.device);\n\tu8 dest_rd_atomic;\n\tu32 access_flags;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tdest_rd_atomic = attr->max_dest_rd_atomic;\n\telse\n\t\tdest_rd_atomic = qp->trans_qp.resp_depth;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\taccess_flags = attr->qp_access_flags;\n\telse\n\t\taccess_flags = qp->trans_qp.atomic_rd_en;\n\n\tif (!dest_rd_atomic)\n\t\taccess_flags &= IB_ACCESS_REMOTE_WRITE;\n\n\tMLX5_SET(qpc, qpc, rre, !!(access_flags & IB_ACCESS_REMOTE_READ));\n\n\tif (access_flags & IB_ACCESS_REMOTE_ATOMIC) {\n\t\tint atomic_mode;\n\n\t\tatomic_mode = get_atomic_mode(dev, qp->type);\n\t\tif (atomic_mode < 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tMLX5_SET(qpc, qpc, rae, 1);\n\t\tMLX5_SET(qpc, qpc, atomic_mode, atomic_mode);\n\t}\n\n\tMLX5_SET(qpc, qpc, rwe, !!(access_flags & IB_ACCESS_REMOTE_WRITE));\n\treturn 0;\n}\n\nenum {\n\tMLX5_PATH_FLAG_FL\t= 1 << 0,\n\tMLX5_PATH_FLAG_FREE_AR\t= 1 << 1,\n\tMLX5_PATH_FLAG_COUNTER\t= 1 << 2,\n};\n\nstatic int mlx5_to_ib_rate_map(u8 rate)\n{\n\tstatic const int rates[] = { IB_RATE_PORT_CURRENT, IB_RATE_56_GBPS,\n\t\t\t\t     IB_RATE_25_GBPS,\t   IB_RATE_100_GBPS,\n\t\t\t\t     IB_RATE_200_GBPS,\t   IB_RATE_50_GBPS,\n\t\t\t\t     IB_RATE_400_GBPS };\n\n\tif (rate < ARRAY_SIZE(rates))\n\t\treturn rates[rate];\n\n\treturn rate - MLX5_STAT_RATE_OFFSET;\n}\n\nstatic int ib_to_mlx5_rate_map(u8 rate)\n{\n\tswitch (rate) {\n\tcase IB_RATE_PORT_CURRENT:\n\t\treturn 0;\n\tcase IB_RATE_56_GBPS:\n\t\treturn 1;\n\tcase IB_RATE_25_GBPS:\n\t\treturn 2;\n\tcase IB_RATE_100_GBPS:\n\t\treturn 3;\n\tcase IB_RATE_200_GBPS:\n\t\treturn 4;\n\tcase IB_RATE_50_GBPS:\n\t\treturn 5;\n\tcase IB_RATE_400_GBPS:\n\t\treturn 6;\n\tdefault:\n\t\treturn rate + MLX5_STAT_RATE_OFFSET;\n\t}\n\n\treturn 0;\n}\n\nstatic int ib_rate_to_mlx5(struct mlx5_ib_dev *dev, u8 rate)\n{\n\tu32 stat_rate_support;\n\n\tif (rate == IB_RATE_PORT_CURRENT)\n\t\treturn 0;\n\n\tif (rate < IB_RATE_2_5_GBPS || rate > IB_RATE_600_GBPS)\n\t\treturn -EINVAL;\n\n\tstat_rate_support = MLX5_CAP_GEN(dev->mdev, stat_rate_support);\n\twhile (rate != IB_RATE_PORT_CURRENT &&\n\t       !(1 << ib_to_mlx5_rate_map(rate) & stat_rate_support))\n\t\t--rate;\n\n\treturn ib_to_mlx5_rate_map(rate);\n}\n\nstatic int modify_raw_packet_eth_prio(struct mlx5_core_dev *dev,\n\t\t\t\t      struct mlx5_ib_sq *sq, u8 sl,\n\t\t\t\t      struct ib_pd *pd)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.prio, 1);\n\tMLX5_SET(modify_tis_in, in, uid, to_mpd(pd)->uid);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, prio, ((sl & 0x7) << 1));\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic int modify_raw_packet_tx_affinity(struct mlx5_core_dev *dev,\n\t\t\t\t\t struct mlx5_ib_sq *sq, u8 tx_affinity,\n\t\t\t\t\t struct ib_pd *pd)\n{\n\tvoid *in;\n\tvoid *tisc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_tis_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_tis_in, in, bitmask.lag_tx_port_affinity, 1);\n\tMLX5_SET(modify_tis_in, in, uid, to_mpd(pd)->uid);\n\n\ttisc = MLX5_ADDR_OF(modify_tis_in, in, ctx);\n\tMLX5_SET(tisc, tisc, lag_tx_port_affinity, tx_affinity);\n\n\terr = mlx5_core_modify_tis(dev, sq->tisn, in);\n\n\tkvfree(in);\n\n\treturn err;\n}\n\nstatic void mlx5_set_path_udp_sport(void *path, const struct rdma_ah_attr *ah,\n\t\t\t\t    u32 lqpn, u32 rqpn)\n\n{\n\tu32 fl = ah->grh.flow_label;\n\n\tif (!fl)\n\t\tfl = rdma_calc_flow_label(lqpn, rqpn);\n\n\tMLX5_SET(ads, path, udp_sport, rdma_flow_label_to_udp_sport(fl));\n}\n\nstatic int mlx5_set_path(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t const struct rdma_ah_attr *ah, void *path, u8 port,\n\t\t\t int attr_mask, u32 path_flags,\n\t\t\t const struct ib_qp_attr *attr, bool alt)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah);\n\tint err;\n\tenum ib_gid_type gid_type;\n\tu8 ah_flags = rdma_ah_get_ah_flags(ah);\n\tu8 sl = rdma_ah_get_sl(ah);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tMLX5_SET(ads, path, pkey_index,\n\t\t\t alt ? attr->alt_pkey_index : attr->pkey_index);\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tconst struct ib_port_immutable *immutable;\n\n\t\timmutable = ib_port_immutable_read(&dev->ib_dev, port);\n\t\tif (grh->sgid_index >= immutable->gid_tbl_len) {\n\t\t\tpr_err(\"sgid_index (%u) too large. max is %d\\n\",\n\t\t\t       grh->sgid_index,\n\t\t\t       immutable->gid_tbl_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (ah->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (!(ah_flags & IB_AH_GRH))\n\t\t\treturn -EINVAL;\n\n\t\tether_addr_copy(MLX5_ADDR_OF(ads, path, rmac_47_32),\n\t\t\t\tah->roce.dmac);\n\t\tif ((qp->type == IB_QPT_RC ||\n\t\t     qp->type == IB_QPT_UC ||\n\t\t     qp->type == IB_QPT_XRC_INI ||\n\t\t     qp->type == IB_QPT_XRC_TGT) &&\n\t\t    (grh->sgid_attr->gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP) &&\n\t\t    (attr_mask & IB_QP_DEST_QPN))\n\t\t\tmlx5_set_path_udp_sport(path, ah,\n\t\t\t\t\t\tqp->ibqp.qp_num,\n\t\t\t\t\t\tattr->dest_qp_num);\n\t\tMLX5_SET(ads, path, eth_prio, sl & 0x7);\n\t\tgid_type = ah->grh.sgid_attr->gid_type;\n\t\tif (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)\n\t\t\tMLX5_SET(ads, path, dscp, grh->traffic_class >> 2);\n\t} else {\n\t\tMLX5_SET(ads, path, fl, !!(path_flags & MLX5_PATH_FLAG_FL));\n\t\tMLX5_SET(ads, path, free_ar,\n\t\t\t !!(path_flags & MLX5_PATH_FLAG_FREE_AR));\n\t\tMLX5_SET(ads, path, rlid, rdma_ah_get_dlid(ah));\n\t\tMLX5_SET(ads, path, mlid, rdma_ah_get_path_bits(ah));\n\t\tMLX5_SET(ads, path, grh, !!(ah_flags & IB_AH_GRH));\n\t\tMLX5_SET(ads, path, sl, sl);\n\t}\n\n\tif (ah_flags & IB_AH_GRH) {\n\t\tMLX5_SET(ads, path, src_addr_index, grh->sgid_index);\n\t\tMLX5_SET(ads, path, hop_limit, grh->hop_limit);\n\t\tMLX5_SET(ads, path, tclass, grh->traffic_class);\n\t\tMLX5_SET(ads, path, flow_label, grh->flow_label);\n\t\tmemcpy(MLX5_ADDR_OF(ads, path, rgid_rip), grh->dgid.raw,\n\t\t       sizeof(grh->dgid.raw));\n\t}\n\n\terr = ib_rate_to_mlx5(dev, rdma_ah_get_static_rate(ah));\n\tif (err < 0)\n\t\treturn err;\n\tMLX5_SET(ads, path, stat_rate, err);\n\tMLX5_SET(ads, path, vhca_port_num, port);\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tMLX5_SET(ads, path, ack_timeout,\n\t\t\t alt ? attr->alt_timeout : attr->timeout);\n\n\tif ((qp->type == IB_QPT_RAW_PACKET) && qp->sq.wqe_cnt)\n\t\treturn modify_raw_packet_eth_prio(dev->mdev,\n\t\t\t\t\t\t  &qp->raw_packet_qp.sq,\n\t\t\t\t\t\t  sl & 0xf, qp->ibqp.pd);\n\n\treturn 0;\n}\n\nstatic enum mlx5_qp_optpar opt_mask[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE][MLX5_QP_ST_MAX] = {\n\t[MLX5_QP_STATE_INIT] = {\n\t\t[MLX5_QP_STATE_INIT] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PRI_PORT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH  |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_PKEY_INDEX     |\n\t\t\t\t\t  MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE            |\n\t\t\t\t\t  MLX5_QP_OPTPAR_PKEY_INDEX\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_LAG_TX_AFF,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTR] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_ALT_ADDR_PATH\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_RTS] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_SRQN\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_CQN_RCV,\n\t\t\t[MLX5_QP_ST_XRC] = MLX5_QP_OPTPAR_RRE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_PM_STATE\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_ALT_ADDR_PATH,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_SQER] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_UD]\t = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_UC]\t = MLX5_QP_OPTPAR_RWE,\n\t\t\t[MLX5_QP_ST_RC]\t = MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RRE,\n\t\t\t[MLX5_QP_ST_XRC]  = MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t   MLX5_QP_OPTPAR_RRE,\n\t\t},\n\t},\n\t[MLX5_QP_STATE_SQD] = {\n\t\t[MLX5_QP_STATE_RTS] = {\n\t\t\t[MLX5_QP_ST_UD] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_MLX] = MLX5_QP_OPTPAR_Q_KEY,\n\t\t\t[MLX5_QP_ST_UC] = MLX5_QP_OPTPAR_RWE,\n\t\t\t[MLX5_QP_ST_RC] = MLX5_QP_OPTPAR_RNR_TIMEOUT\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RWE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RAE\t\t|\n\t\t\t\t\t  MLX5_QP_OPTPAR_RRE,\n\t\t},\n\t},\n};\n\nstatic int ib_nr_to_mlx5_nr(int ib_mask)\n{\n\tswitch (ib_mask) {\n\tcase IB_QP_STATE:\n\t\treturn 0;\n\tcase IB_QP_CUR_STATE:\n\t\treturn 0;\n\tcase IB_QP_EN_SQD_ASYNC_NOTIFY:\n\t\treturn 0;\n\tcase IB_QP_ACCESS_FLAGS:\n\t\treturn MLX5_QP_OPTPAR_RWE | MLX5_QP_OPTPAR_RRE |\n\t\t\tMLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PKEY_INDEX:\n\t\treturn MLX5_QP_OPTPAR_PKEY_INDEX;\n\tcase IB_QP_PORT:\n\t\treturn MLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_QKEY:\n\t\treturn MLX5_QP_OPTPAR_Q_KEY;\n\tcase IB_QP_AV:\n\t\treturn MLX5_QP_OPTPAR_PRIMARY_ADDR_PATH |\n\t\t\tMLX5_QP_OPTPAR_PRI_PORT;\n\tcase IB_QP_PATH_MTU:\n\t\treturn 0;\n\tcase IB_QP_TIMEOUT:\n\t\treturn MLX5_QP_OPTPAR_ACK_TIMEOUT;\n\tcase IB_QP_RETRY_CNT:\n\t\treturn MLX5_QP_OPTPAR_RETRY_COUNT;\n\tcase IB_QP_RNR_RETRY:\n\t\treturn MLX5_QP_OPTPAR_RNR_RETRY;\n\tcase IB_QP_RQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_QP_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_SRA_MAX;\n\tcase IB_QP_ALT_PATH:\n\t\treturn MLX5_QP_OPTPAR_ALT_ADDR_PATH;\n\tcase IB_QP_MIN_RNR_TIMER:\n\t\treturn MLX5_QP_OPTPAR_RNR_TIMEOUT;\n\tcase IB_QP_SQ_PSN:\n\t\treturn 0;\n\tcase IB_QP_MAX_DEST_RD_ATOMIC:\n\t\treturn MLX5_QP_OPTPAR_RRA_MAX | MLX5_QP_OPTPAR_RWE |\n\t\t\tMLX5_QP_OPTPAR_RRE | MLX5_QP_OPTPAR_RAE;\n\tcase IB_QP_PATH_MIG_STATE:\n\t\treturn MLX5_QP_OPTPAR_PM_STATE;\n\tcase IB_QP_CAP:\n\t\treturn 0;\n\tcase IB_QP_DEST_QPN:\n\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nstatic int ib_mask_to_mlx5_opt(int ib_mask)\n{\n\tint result = 0;\n\tint i;\n\n\tfor (i = 0; i < 8 * sizeof(int); i++) {\n\t\tif ((1 << i) & ib_mask)\n\t\t\tresult |= ib_nr_to_mlx5_nr(1 << i);\n\t}\n\n\treturn result;\n}\n\nstatic int modify_raw_packet_qp_rq(\n\tstruct mlx5_ib_dev *dev, struct mlx5_ib_rq *rq, int new_state,\n\tconst struct mlx5_modify_raw_qp_param *raw_qp_param, struct ib_pd *pd)\n{\n\tvoid *in;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_rq_in, in, rq_state, rq->state);\n\tMLX5_SET(modify_rq_in, in, uid, to_mpd(pd)->uid);\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\tMLX5_SET(rqc, rqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID) {\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id, raw_qp_param->rq_q_ctr_id);\n\t\t} else\n\t\t\tdev_info_once(\n\t\t\t\t&dev->ib_dev.dev,\n\t\t\t\t\"RAW PACKET QP counters are not supported on current FW\\n\");\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rq->base.mqp.qpn, in);\n\tif (err)\n\t\tgoto out;\n\n\trq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp_sq(\n\tstruct mlx5_core_dev *dev, struct mlx5_ib_sq *sq, int new_state,\n\tconst struct mlx5_modify_raw_qp_param *raw_qp_param, struct ib_pd *pd)\n{\n\tstruct mlx5_ib_qp *ibqp = sq->base.container_mibqp;\n\tstruct mlx5_rate_limit old_rl = ibqp->rl;\n\tstruct mlx5_rate_limit new_rl = old_rl;\n\tbool new_rate_added = false;\n\tu16 rl_index = 0;\n\tvoid *in;\n\tvoid *sqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_sq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(modify_sq_in, in, uid, to_mpd(pd)->uid);\n\tMLX5_SET(modify_sq_in, in, sq_state, sq->state);\n\n\tsqc = MLX5_ADDR_OF(modify_sq_in, in, ctx);\n\tMLX5_SET(sqc, sqc, state, new_state);\n\n\tif (raw_qp_param->set_mask & MLX5_RAW_QP_RATE_LIMIT) {\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tpr_warn(\"%s: Rate limit can only be changed when SQ is moving to RDY\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tnew_rl = raw_qp_param->rl;\n\t}\n\n\tif (!mlx5_rl_are_equal(&old_rl, &new_rl)) {\n\t\tif (new_rl.rate) {\n\t\t\terr = mlx5_rl_add_rate(dev, &rl_index, &new_rl);\n\t\t\tif (err) {\n\t\t\t\tpr_err(\"Failed configuring rate limit(err %d): \\\n\t\t\t\t       rate %u, max_burst_sz %u, typical_pkt_sz %u\\n\",\n\t\t\t\t       err, new_rl.rate, new_rl.max_burst_sz,\n\t\t\t\t       new_rl.typical_pkt_sz);\n\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnew_rate_added = true;\n\t\t}\n\n\t\tMLX5_SET64(modify_sq_in, in, modify_bitmask, 1);\n\t\t/* index 0 means no limit */\n\t\tMLX5_SET(sqc, sqc, packet_pacing_rate_limit_index, rl_index);\n\t}\n\n\terr = mlx5_core_modify_sq(dev, sq->base.mqp.qpn, in);\n\tif (err) {\n\t\t/* Remove new rate from table if failed */\n\t\tif (new_rate_added)\n\t\t\tmlx5_rl_remove_rate(dev, &new_rl);\n\t\tgoto out;\n\t}\n\n\t/* Only remove the old rate after new rate was set */\n\tif ((old_rl.rate && !mlx5_rl_are_equal(&old_rl, &new_rl)) ||\n\t    (new_state != MLX5_SQC_STATE_RDY)) {\n\t\tmlx5_rl_remove_rate(dev, &old_rl);\n\t\tif (new_state != MLX5_SQC_STATE_RDY)\n\t\t\tmemset(&new_rl, 0, sizeof(new_rl));\n\t}\n\n\tibqp->rl = new_rl;\n\tsq->state = new_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int modify_raw_packet_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t\tconst struct mlx5_modify_raw_qp_param *raw_qp_param,\n\t\t\t\tu8 tx_affinity)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tint modify_rq = !!qp->rq.wqe_cnt;\n\tint modify_sq = !!qp->sq.wqe_cnt;\n\tint rq_state;\n\tint sq_state;\n\tint err;\n\n\tswitch (raw_qp_param->operation) {\n\tcase MLX5_CMD_OP_RST2INIT_QP:\n\t\trq_state = MLX5_RQC_STATE_RDY;\n\t\tsq_state = MLX5_SQC_STATE_RST;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2ERR_QP:\n\t\trq_state = MLX5_RQC_STATE_ERR;\n\t\tsq_state = MLX5_SQC_STATE_ERR;\n\t\tbreak;\n\tcase MLX5_CMD_OP_2RST_QP:\n\t\trq_state = MLX5_RQC_STATE_RST;\n\t\tsq_state = MLX5_SQC_STATE_RST;\n\t\tbreak;\n\tcase MLX5_CMD_OP_RTR2RTS_QP:\n\tcase MLX5_CMD_OP_RTS2RTS_QP:\n\t\tif (raw_qp_param->set_mask & ~MLX5_RAW_QP_RATE_LIMIT)\n\t\t\treturn -EINVAL;\n\n\t\tmodify_rq = 0;\n\t\tsq_state = MLX5_SQC_STATE_RDY;\n\t\tbreak;\n\tcase MLX5_CMD_OP_INIT2INIT_QP:\n\tcase MLX5_CMD_OP_INIT2RTR_QP:\n\t\tif (raw_qp_param->set_mask)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn 0;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (modify_rq) {\n\t\terr =  modify_raw_packet_qp_rq(dev, rq, rq_state, raw_qp_param,\n\t\t\t\t\t       qp->ibqp.pd);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (modify_sq) {\n\t\tstruct mlx5_flow_handle *flow_rule;\n\n\t\tif (tx_affinity) {\n\t\t\terr = modify_raw_packet_tx_affinity(dev->mdev, sq,\n\t\t\t\t\t\t\t    tx_affinity,\n\t\t\t\t\t\t\t    qp->ibqp.pd);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\tflow_rule = create_flow_rule_vport_sq(dev, sq,\n\t\t\t\t\t\t      raw_qp_param->port);\n\t\tif (IS_ERR(flow_rule))\n\t\t\treturn PTR_ERR(flow_rule);\n\n\t\terr = modify_raw_packet_qp_sq(dev->mdev, sq, sq_state,\n\t\t\t\t\t      raw_qp_param, qp->ibqp.pd);\n\t\tif (err) {\n\t\t\tif (flow_rule)\n\t\t\t\tmlx5_del_flow_rules(flow_rule);\n\t\t\treturn err;\n\t\t}\n\n\t\tif (flow_rule) {\n\t\t\tdestroy_flow_rule_vport_sq(sq);\n\t\t\tsq->flow_rule = flow_rule;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned int get_tx_affinity_rr(struct mlx5_ib_dev *dev,\n\t\t\t\t       struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\tu8 port_num = mlx5_core_native_port_num(dev->mdev) - 1;\n\tatomic_t *tx_port_affinity;\n\n\tif (ucontext)\n\t\ttx_port_affinity = &ucontext->tx_port_affinity;\n\telse\n\t\ttx_port_affinity = &dev->port[port_num].roce.tx_port_affinity;\n\n\treturn (unsigned int)atomic_add_return(1, tx_port_affinity) %\n\t\t(dev->lag_active ? dev->lag_ports : MLX5_CAP_GEN(dev->mdev, num_lag_ports)) + 1;\n}\n\nstatic bool qp_supports_affinity(struct mlx5_ib_qp *qp)\n{\n\tif ((qp->type == IB_QPT_RC) || (qp->type == IB_QPT_UD) ||\n\t    (qp->type == IB_QPT_UC) || (qp->type == IB_QPT_RAW_PACKET) ||\n\t    (qp->type == IB_QPT_XRC_INI) || (qp->type == IB_QPT_XRC_TGT) ||\n\t    (qp->type == MLX5_IB_QPT_DCI))\n\t\treturn true;\n\treturn false;\n}\n\nstatic unsigned int get_tx_affinity(struct ib_qp *qp,\n\t\t\t\t    const struct ib_qp_attr *attr,\n\t\t\t\t    int attr_mask, u8 init,\n\t\t\t\t    struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *ucontext = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_qp_base *qp_base;\n\tunsigned int tx_affinity;\n\n\tif (!(mlx5_ib_lag_should_assign_affinity(dev) &&\n\t      qp_supports_affinity(mqp)))\n\t\treturn 0;\n\n\tif (mqp->flags & MLX5_IB_QP_CREATE_SQPN_QP1)\n\t\ttx_affinity = mqp->gsi_lag_port;\n\telse if (init)\n\t\ttx_affinity = get_tx_affinity_rr(dev, udata);\n\telse if ((attr_mask & IB_QP_AV) && attr->xmit_slave)\n\t\ttx_affinity =\n\t\t\tmlx5_lag_get_slave_port(dev->mdev, attr->xmit_slave);\n\telse\n\t\treturn 0;\n\n\tqp_base = &mqp->trans_qp.base;\n\tif (ucontext)\n\t\tmlx5_ib_dbg(dev, \"Set tx affinity 0x%x to qpn 0x%x ucontext %p\\n\",\n\t\t\t    tx_affinity, qp_base->mqp.qpn, ucontext);\n\telse\n\t\tmlx5_ib_dbg(dev, \"Set tx affinity 0x%x to qpn 0x%x\\n\",\n\t\t\t    tx_affinity, qp_base->mqp.qpn);\n\treturn tx_affinity;\n}\n\nstatic int __mlx5_ib_qp_set_raw_qp_counter(struct mlx5_ib_qp *qp, u32 set_id,\n\t\t\t\t\t   struct mlx5_core_dev *mdev)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tu32 in[MLX5_ST_SZ_DW(modify_rq_in)] = {};\n\tvoid *rqc;\n\n\tif (!qp->rq.wqe_cnt)\n\t\treturn 0;\n\n\tMLX5_SET(modify_rq_in, in, rq_state, rq->state);\n\tMLX5_SET(modify_rq_in, in, uid, to_mpd(qp->ibqp.pd)->uid);\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\tMLX5_SET(rqc, rqc, state, MLX5_RQC_STATE_RDY);\n\n\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\tMLX5_SET(rqc, rqc, counter_set_id, set_id);\n\n\treturn mlx5_core_modify_rq(mdev, rq->base.mqp.qpn, in);\n}\n\nstatic int __mlx5_ib_qp_set_counter(struct ib_qp *qp,\n\t\t\t\t    struct rdma_counter *counter)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tu32 in[MLX5_ST_SZ_DW(rts2rts_qp_in)] = {};\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_qp_base *base;\n\tu32 set_id;\n\tu32 *qpc;\n\n\tif (counter)\n\t\tset_id = counter->id;\n\telse\n\t\tset_id = mlx5_ib_get_counters_id(dev, mqp->port - 1);\n\n\tif (mqp->type == IB_QPT_RAW_PACKET)\n\t\treturn __mlx5_ib_qp_set_raw_qp_counter(mqp, set_id, dev->mdev);\n\n\tbase = &mqp->trans_qp.base;\n\tMLX5_SET(rts2rts_qp_in, in, opcode, MLX5_CMD_OP_RTS2RTS_QP);\n\tMLX5_SET(rts2rts_qp_in, in, qpn, base->mqp.qpn);\n\tMLX5_SET(rts2rts_qp_in, in, uid, base->mqp.uid);\n\tMLX5_SET(rts2rts_qp_in, in, opt_param_mask,\n\t\t MLX5_QP_OPTPAR_COUNTER_SET_ID);\n\n\tqpc = MLX5_ADDR_OF(rts2rts_qp_in, in, qpc);\n\tMLX5_SET(qpc, qpc, counter_set_id, set_id);\n\treturn mlx5_cmd_exec_in(dev->mdev, rts2rts_qp, in);\n}\n\nstatic int __mlx5_ib_modify_qp(struct ib_qp *ibqp,\n\t\t\t       const struct ib_qp_attr *attr, int attr_mask,\n\t\t\t       enum ib_qp_state cur_state,\n\t\t\t       enum ib_qp_state new_state,\n\t\t\t       const struct mlx5_ib_modify_qp *ucmd,\n\t\t\t       struct mlx5_ib_modify_qp_resp *resp,\n\t\t\t       struct ib_udata *udata)\n{\n\tstatic const u16 optab[MLX5_QP_NUM_STATE][MLX5_QP_NUM_STATE] = {\n\t\t[MLX5_QP_STATE_RST] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_RST2INIT_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_INIT]  = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_INIT]\t= MLX5_CMD_OP_INIT2INIT_QP,\n\t\t\t[MLX5_QP_STATE_RTR]\t= MLX5_CMD_OP_INIT2RTR_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTR]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_RTS]   = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_RTS2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQD] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_SQD_RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_SQER] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t\t[MLX5_QP_STATE_RTS]\t= MLX5_CMD_OP_SQERR2RTS_QP,\n\t\t},\n\t\t[MLX5_QP_STATE_ERR] = {\n\t\t\t[MLX5_QP_STATE_RST]\t= MLX5_CMD_OP_2RST_QP,\n\t\t\t[MLX5_QP_STATE_ERR]\t= MLX5_CMD_OP_2ERR_QP,\n\t\t}\n\t};\n\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_qp_base *base = &qp->trans_qp.base;\n\tstruct mlx5_ib_cq *send_cq, *recv_cq;\n\tstruct mlx5_ib_pd *pd;\n\tenum mlx5_qp_state mlx5_cur, mlx5_new;\n\tvoid *qpc, *pri_path, *alt_path;\n\tenum mlx5_qp_optpar optpar = 0;\n\tu32 set_id = 0;\n\tint mlx5_st;\n\tint err;\n\tu16 op;\n\tu8 tx_affinity = 0;\n\n\tmlx5_st = to_mlx5_st(qp->type);\n\tif (mlx5_st < 0)\n\t\treturn -EINVAL;\n\n\tqpc = kzalloc(MLX5_ST_SZ_BYTES(qpc), GFP_KERNEL);\n\tif (!qpc)\n\t\treturn -ENOMEM;\n\n\tpd = to_mpd(qp->ibqp.pd);\n\tMLX5_SET(qpc, qpc, st, mlx5_st);\n\n\tif (!(attr_mask & IB_QP_PATH_MIG_STATE)) {\n\t\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\t} else {\n\t\tswitch (attr->path_mig_state) {\n\t\tcase IB_MIG_MIGRATED:\n\t\t\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_MIGRATED);\n\t\t\tbreak;\n\t\tcase IB_MIG_REARM:\n\t\t\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_REARM);\n\t\t\tbreak;\n\t\tcase IB_MIG_ARMED:\n\t\t\tMLX5_SET(qpc, qpc, pm_state, MLX5_QP_PM_ARMED);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\ttx_affinity = get_tx_affinity(ibqp, attr, attr_mask,\n\t\t\t\t      cur_state == IB_QPS_RESET &&\n\t\t\t\t      new_state == IB_QPS_INIT, udata);\n\n\tMLX5_SET(qpc, qpc, lag_tx_port_affinity, tx_affinity);\n\tif (tx_affinity && new_state == IB_QPS_RTR &&\n\t    MLX5_CAP_GEN(dev->mdev, init2_lag_tx_port_affinity))\n\t\toptpar |= MLX5_QP_OPTPAR_LAG_TX_AFF;\n\n\tif (is_sqp(qp->type)) {\n\t\tMLX5_SET(qpc, qpc, mtu, IB_MTU_256);\n\t\tMLX5_SET(qpc, qpc, log_msg_max, 8);\n\t} else if ((qp->type == IB_QPT_UD &&\n\t\t    !(qp->flags & IB_QP_CREATE_SOURCE_QPN)) ||\n\t\t   qp->type == MLX5_IB_QPT_REG_UMR) {\n\t\tMLX5_SET(qpc, qpc, mtu, IB_MTU_4096);\n\t\tMLX5_SET(qpc, qpc, log_msg_max, 12);\n\t} else if (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attr->path_mtu < IB_MTU_256 ||\n\t\t    attr->path_mtu > IB_MTU_4096) {\n\t\t\tmlx5_ib_warn(dev, \"invalid mtu %d\\n\", attr->path_mtu);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(qpc, qpc, mtu, attr->path_mtu);\n\t\tMLX5_SET(qpc, qpc, log_msg_max,\n\t\t\t MLX5_CAP_GEN(dev->mdev, log_max_msg));\n\t}\n\n\tif (attr_mask & IB_QP_DEST_QPN)\n\t\tMLX5_SET(qpc, qpc, remote_qpn, attr->dest_qp_num);\n\n\tpri_path = MLX5_ADDR_OF(qpc, qpc, primary_address_path);\n\talt_path = MLX5_ADDR_OF(qpc, qpc, secondary_address_path);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tMLX5_SET(ads, pri_path, pkey_index, attr->pkey_index);\n\n\t/* todo implement counter_index functionality */\n\n\tif (is_sqp(qp->type))\n\t\tMLX5_SET(ads, pri_path, vhca_port_num, qp->port);\n\n\tif (attr_mask & IB_QP_PORT)\n\t\tMLX5_SET(ads, pri_path, vhca_port_num, attr->port_num);\n\n\tif (attr_mask & IB_QP_AV) {\n\t\terr = mlx5_set_path(dev, qp, &attr->ah_attr, pri_path,\n\t\t\t\t    attr_mask & IB_QP_PORT ? attr->port_num :\n\t\t\t\t\t\t\t     qp->port,\n\t\t\t\t    attr_mask, 0, attr, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_TIMEOUT)\n\t\tMLX5_SET(ads, pri_path, ack_timeout, attr->timeout);\n\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\terr = mlx5_set_path(dev, qp, &attr->alt_ah_attr, alt_path,\n\t\t\t\t    attr->alt_port_num,\n\t\t\t\t    attr_mask | IB_QP_PKEY_INDEX |\n\t\t\t\t\t    IB_QP_TIMEOUT,\n\t\t\t\t    0, attr, true);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tget_cqs(qp->type, qp->ibqp.send_cq, qp->ibqp.recv_cq,\n\t\t&send_cq, &recv_cq);\n\n\tMLX5_SET(qpc, qpc, pd, pd ? pd->pdn : to_mpd(dev->devr.p0)->pdn);\n\tif (send_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_snd, send_cq->mcq.cqn);\n\tif (recv_cq)\n\t\tMLX5_SET(qpc, qpc, cqn_rcv, recv_cq->mcq.cqn);\n\n\tMLX5_SET(qpc, qpc, log_ack_req_freq, MLX5_IB_ACK_REQ_FREQ);\n\n\tif (attr_mask & IB_QP_RNR_RETRY)\n\t\tMLX5_SET(qpc, qpc, rnr_retry, attr->rnr_retry);\n\n\tif (attr_mask & IB_QP_RETRY_CNT)\n\t\tMLX5_SET(qpc, qpc, retry_count, attr->retry_cnt);\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC && attr->max_rd_atomic)\n\t\tMLX5_SET(qpc, qpc, log_sra_max, ilog2(attr->max_rd_atomic));\n\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tMLX5_SET(qpc, qpc, next_send_psn, attr->sq_psn);\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC && attr->max_dest_rd_atomic)\n\t\tMLX5_SET(qpc, qpc, log_rra_max,\n\t\t\t ilog2(attr->max_dest_rd_atomic));\n\n\tif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC)) {\n\t\terr = set_qpc_atomic_flags(qp, attr, attr_mask, qpc);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tMLX5_SET(qpc, qpc, min_rnr_nak, attr->min_rnr_timer);\n\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tMLX5_SET(qpc, qpc, next_rcv_psn, attr->rq_psn);\n\n\tif (attr_mask & IB_QP_QKEY)\n\t\tMLX5_SET(qpc, qpc, q_key, attr->qkey);\n\n\tif (qp->rq.wqe_cnt && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tMLX5_SET64(qpc, qpc, dbr_addr, qp->db.dma);\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\tu8 port_num = (attr_mask & IB_QP_PORT ? attr->port_num :\n\t\t\t       qp->port) - 1;\n\n\t\t/* Underlay port should be used - index 0 function per port */\n\t\tif (qp->flags & IB_QP_CREATE_SOURCE_QPN)\n\t\t\tport_num = 0;\n\n\t\tif (ibqp->counter)\n\t\t\tset_id = ibqp->counter->id;\n\t\telse\n\t\t\tset_id = mlx5_ib_get_counters_id(dev, port_num);\n\t\tMLX5_SET(qpc, qpc, counter_set_id, set_id);\n\t}\n\n\tif (!ibqp->uobject && cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT)\n\t\tMLX5_SET(qpc, qpc, rlky, 1);\n\n\tif (qp->flags & MLX5_IB_QP_CREATE_SQPN_QP1)\n\t\tMLX5_SET(qpc, qpc, deth_sqpn, 1);\n\n\tmlx5_cur = to_mlx5_state(cur_state);\n\tmlx5_new = to_mlx5_state(new_state);\n\n\tif (mlx5_cur >= MLX5_QP_NUM_STATE || mlx5_new >= MLX5_QP_NUM_STATE ||\n\t    !optab[mlx5_cur][mlx5_new]) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\top = optab[mlx5_cur][mlx5_new];\n\toptpar |= ib_mask_to_mlx5_opt(attr_mask);\n\toptpar &= opt_mask[mlx5_cur][mlx5_new][mlx5_st];\n\n\tif (qp->type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tstruct mlx5_modify_raw_qp_param raw_qp_param = {};\n\n\t\traw_qp_param.operation = op;\n\t\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\t\traw_qp_param.rq_q_ctr_id = set_id;\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_MOD_SET_RQ_Q_CTR_ID;\n\t\t}\n\n\t\tif (attr_mask & IB_QP_PORT)\n\t\t\traw_qp_param.port = attr->port_num;\n\n\t\tif (attr_mask & IB_QP_RATE_LIMIT) {\n\t\t\traw_qp_param.rl.rate = attr->rate_limit;\n\n\t\t\tif (ucmd->burst_info.max_burst_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_burst_bound)) {\n\t\t\t\t\traw_qp_param.rl.max_burst_sz =\n\t\t\t\t\t\tucmd->burst_info.max_burst_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ucmd->burst_info.typical_pkt_sz) {\n\t\t\t\tif (attr->rate_limit &&\n\t\t\t\t    MLX5_CAP_QOS(dev->mdev, packet_pacing_typical_size)) {\n\t\t\t\t\traw_qp_param.rl.typical_pkt_sz =\n\t\t\t\t\t\tucmd->burst_info.typical_pkt_sz;\n\t\t\t\t} else {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\traw_qp_param.set_mask |= MLX5_RAW_QP_RATE_LIMIT;\n\t\t}\n\n\t\terr = modify_raw_packet_qp(dev, qp, &raw_qp_param, tx_affinity);\n\t} else {\n\t\tif (udata) {\n\t\t\t/* For the kernel flows, the resp will stay zero */\n\t\t\tresp->ece_options =\n\t\t\t\tMLX5_CAP_GEN(dev->mdev, ece_support) ?\n\t\t\t\t\tucmd->ece_options : 0;\n\t\t\tresp->response_length = sizeof(*resp);\n\t\t}\n\t\terr = mlx5_core_qp_modify(dev, op, optpar, qpc, &base->mqp,\n\t\t\t\t\t  &resp->ece_options);\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\tqp->state = new_state;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->trans_qp.atomic_rd_en = attr->qp_access_flags;\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tqp->trans_qp.resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT)\n\t\tqp->port = attr->port_num;\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->trans_qp.alt_port = attr->alt_port_num;\n\n\t/*\n\t * If we moved a kernel QP to RESET, clean up all old CQ\n\t * entries and reinitialize the QP.\n\t */\n\tif (new_state == IB_QPS_RESET &&\n\t    !ibqp->uobject && qp->type != IB_QPT_XRC_TGT) {\n\t\tmlx5_ib_cq_clean(recv_cq, base->mqp.qpn,\n\t\t\t\t ibqp->srq ? to_msrq(ibqp->srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\tmlx5_ib_cq_clean(send_cq, base->mqp.qpn, NULL);\n\n\t\tqp->rq.head = 0;\n\t\tqp->rq.tail = 0;\n\t\tqp->sq.head = 0;\n\t\tqp->sq.tail = 0;\n\t\tqp->sq.cur_post = 0;\n\t\tif (qp->sq.wqe_cnt)\n\t\t\tqp->sq.cur_edge = get_sq_edge(&qp->sq, 0);\n\t\tqp->sq.last_poll = 0;\n\t\tqp->db.db[MLX5_RCV_DBR] = 0;\n\t\tqp->db.db[MLX5_SND_DBR] = 0;\n\t}\n\n\tif ((new_state == IB_QPS_RTS) && qp->counter_pending) {\n\t\terr = __mlx5_ib_qp_set_counter(ibqp, ibqp->counter);\n\t\tif (!err)\n\t\t\tqp->counter_pending = 0;\n\t}\n\nout:\n\tkfree(qpc);\n\treturn err;\n}\n\nstatic inline bool is_valid_mask(int mask, int req, int opt)\n{\n\tif ((mask & req) != req)\n\t\treturn false;\n\n\tif (mask & ~(req | opt))\n\t\treturn false;\n\n\treturn true;\n}\n\n/* check valid transition for driver QP types\n * for now the only QP type that this function supports is DCI\n */\nstatic bool modify_dci_qp_is_ok(enum ib_qp_state cur_state, enum ib_qp_state new_state,\n\t\t\t\tenum ib_qp_attr_mask attr_mask)\n{\n\tint req = IB_QP_STATE;\n\tint opt = 0;\n\n\tif (new_state == IB_QPS_RESET) {\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\treq |= IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_INIT) {\n\t\topt = IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\treq |= IB_QP_PATH_MTU;\n\t\topt = IB_QP_PKEY_INDEX | IB_QP_AV;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTR && new_state == IB_QPS_RTS) {\n\t\treq |= IB_QP_TIMEOUT | IB_QP_RETRY_CNT | IB_QP_RNR_RETRY |\n\t\t       IB_QP_MAX_QP_RD_ATOMIC | IB_QP_SQ_PSN;\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state == IB_QPS_RTS && new_state == IB_QPS_RTS) {\n\t\topt = IB_QP_MIN_RNR_TIMER;\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t} else if (cur_state != IB_QPS_RESET && new_state == IB_QPS_ERR) {\n\t\treturn is_valid_mask(attr_mask, req, opt);\n\t}\n\treturn false;\n}\n\n/* mlx5_ib_modify_dct: modify a DCT QP\n * valid transitions are:\n * RESET to INIT: must set access_flags, pkey_index and port\n * INIT  to RTR : must set min_rnr_timer, tclass, flow_label,\n *\t\t\t   mtu, gid_index and hop_limit\n * Other transitions and attributes are illegal\n */\nstatic int mlx5_ib_modify_dct(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t      int attr_mask, struct mlx5_ib_modify_qp *ucmd,\n\t\t\t      struct ib_udata *udata)\n{\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tenum ib_qp_state cur_state, new_state;\n\tint required = IB_QP_STATE;\n\tvoid *dctc;\n\tint err;\n\n\tif (!(attr_mask & IB_QP_STATE))\n\t\treturn -EINVAL;\n\n\tcur_state = qp->state;\n\tnew_state = attr->qp_state;\n\n\tdctc = MLX5_ADDR_OF(create_dct_in, qp->dct.in, dct_context_entry);\n\tif (MLX5_CAP_GEN(dev->mdev, ece_support) && ucmd->ece_options)\n\t\t/*\n\t\t * DCT doesn't initialize QP till modify command is executed,\n\t\t * so we need to overwrite previously set ECE field if user\n\t\t * provided any value except zero, which means not set/not\n\t\t * valid.\n\t\t */\n\t\tMLX5_SET(dctc, dctc, ece, ucmd->ece_options);\n\n\tif (cur_state == IB_QPS_RESET && new_state == IB_QPS_INIT) {\n\t\tu16 set_id;\n\n\t\trequired |= IB_QP_ACCESS_FLAGS | IB_QP_PKEY_INDEX | IB_QP_PORT;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (attr->port_num == 0 ||\n\t\t    attr->port_num > dev->num_ports) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t\t    attr->port_num, dev->num_ports);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\n\t\t\tMLX5_SET(dctc, dctc, rre, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\t\tMLX5_SET(dctc, dctc, rwe, 1);\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC) {\n\t\t\tint atomic_mode;\n\n\t\t\tatomic_mode = get_atomic_mode(dev, MLX5_IB_QPT_DCT);\n\t\t\tif (atomic_mode < 0)\n\t\t\t\treturn -EOPNOTSUPP;\n\n\t\t\tMLX5_SET(dctc, dctc, atomic_mode, atomic_mode);\n\t\t\tMLX5_SET(dctc, dctc, rae, 1);\n\t\t}\n\t\tMLX5_SET(dctc, dctc, pkey_index, attr->pkey_index);\n\t\tif (mlx5_lag_is_active(dev->mdev))\n\t\t\tMLX5_SET(dctc, dctc, port,\n\t\t\t\t get_tx_affinity_rr(dev, udata));\n\t\telse\n\t\t\tMLX5_SET(dctc, dctc, port, attr->port_num);\n\n\t\tset_id = mlx5_ib_get_counters_id(dev, attr->port_num - 1);\n\t\tMLX5_SET(dctc, dctc, counter_set_id, set_id);\n\t} else if (cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\tstruct mlx5_ib_modify_qp_resp resp = {};\n\t\tu32 out[MLX5_ST_SZ_DW(create_dct_out)] = {};\n\t\tu32 min_resp_len = offsetofend(typeof(resp), dctn);\n\n\t\tif (udata->outlen < min_resp_len)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * If we don't have enough space for the ECE options,\n\t\t * simply indicate it with resp.response_length.\n\t\t */\n\t\tresp.response_length = (udata->outlen < sizeof(resp)) ?\n\t\t\t\t\t       min_resp_len :\n\t\t\t\t\t       sizeof(resp);\n\n\t\trequired |= IB_QP_MIN_RNR_TIMER | IB_QP_AV | IB_QP_PATH_MTU;\n\t\tif (!is_valid_mask(attr_mask, required, 0))\n\t\t\treturn -EINVAL;\n\t\tMLX5_SET(dctc, dctc, min_rnr_nak, attr->min_rnr_timer);\n\t\tMLX5_SET(dctc, dctc, tclass, attr->ah_attr.grh.traffic_class);\n\t\tMLX5_SET(dctc, dctc, flow_label, attr->ah_attr.grh.flow_label);\n\t\tMLX5_SET(dctc, dctc, mtu, attr->path_mtu);\n\t\tMLX5_SET(dctc, dctc, my_addr_index, attr->ah_attr.grh.sgid_index);\n\t\tMLX5_SET(dctc, dctc, hop_limit, attr->ah_attr.grh.hop_limit);\n\t\tif (attr->ah_attr.type == RDMA_AH_ATTR_TYPE_ROCE)\n\t\t\tMLX5_SET(dctc, dctc, eth_prio, attr->ah_attr.sl & 0x7);\n\n\t\terr = mlx5_core_create_dct(dev, &qp->dct.mdct, qp->dct.in,\n\t\t\t\t\t   MLX5_ST_SZ_BYTES(create_dct_in), out,\n\t\t\t\t\t   sizeof(out));\n\t\terr = mlx5_cmd_check(dev->mdev, err, qp->dct.in, out);\n\t\tif (err)\n\t\t\treturn err;\n\t\tresp.dctn = qp->dct.mdct.mqp.qpn;\n\t\tif (MLX5_CAP_GEN(dev->mdev, ece_support))\n\t\t\tresp.ece_options = MLX5_GET(create_dct_out, out, ece);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err) {\n\t\t\tmlx5_core_destroy_dct(dev, &qp->dct.mdct);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tmlx5_ib_warn(dev, \"Modify DCT: Invalid transition from %d to %d\\n\", cur_state, new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tqp->state = new_state;\n\treturn 0;\n}\n\nstatic bool mlx5_ib_modify_qp_allowed(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_ib_qp *qp)\n{\n\tif (dev->profile != &raw_eth_profile)\n\t\treturn true;\n\n\tif (qp->type == IB_QPT_RAW_PACKET || qp->type == MLX5_IB_QPT_REG_UMR)\n\t\treturn true;\n\n\t/* Internal QP used for wc testing, with NOPs in wq */\n\tif (qp->flags & MLX5_IB_QP_CREATE_WC_TEST)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int validate_rd_atomic(struct mlx5_ib_dev *dev, struct ib_qp_attr *attr,\n\t\t\t      int attr_mask, enum ib_qp_type qp_type)\n{\n\tint log_max_ra_res;\n\tint log_max_ra_req;\n\n\tif (qp_type == MLX5_IB_QPT_DCI) {\n\t\tlog_max_ra_res = 1 << MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t   log_max_ra_res_dc);\n\t\tlog_max_ra_req = 1 << MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t   log_max_ra_req_dc);\n\t} else {\n\t\tlog_max_ra_res = 1 << MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t   log_max_ra_res_qp);\n\t\tlog_max_ra_req = 1 << MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t\t\t   log_max_ra_req_qp);\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\n\t    attr->max_rd_atomic > log_max_ra_res) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_rd_atomic value %d\\n\",\n\t\t\t    attr->max_rd_atomic);\n\t\treturn false;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\n\t    attr->max_dest_rd_atomic > log_max_ra_req) {\n\t\tmlx5_ib_dbg(dev, \"invalid max_dest_rd_atomic value %d\\n\",\n\t\t\t    attr->max_dest_rd_atomic);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint mlx5_ib_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t      int attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_modify_qp_resp resp = {};\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tstruct mlx5_ib_modify_qp ucmd = {};\n\tenum ib_qp_type qp_type;\n\tenum ib_qp_state cur_state, new_state;\n\tint err = -EINVAL;\n\n\tif (!mlx5_ib_modify_qp_allowed(dev, qp))\n\t\treturn -EOPNOTSUPP;\n\n\tif (attr_mask & ~(IB_QP_ATTR_STANDARD_BITS | IB_QP_RATE_LIMIT))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (udata && udata->inlen) {\n\t\tif (udata->inlen < offsetofend(typeof(ucmd), ece_options))\n\t\t\treturn -EINVAL;\n\n\t\tif (udata->inlen > sizeof(ucmd) &&\n\t\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (ib_copy_from_udata(&ucmd, udata,\n\t\t\t\t       min(udata->inlen, sizeof(ucmd))))\n\t\t\treturn -EFAULT;\n\n\t\tif (ucmd.comp_mask ||\n\t\t    memchr_inv(&ucmd.burst_info.reserved, 0,\n\t\t\t       sizeof(ucmd.burst_info.reserved)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t}\n\n\tif (qp->type == IB_QPT_GSI)\n\t\treturn mlx5_ib_gsi_modify_qp(ibqp, attr, attr_mask);\n\n\tqp_type = (qp->type == MLX5_IB_QPT_HW_GSI) ? IB_QPT_GSI : qp->type;\n\n\tif (qp_type == MLX5_IB_QPT_DCT)\n\t\treturn mlx5_ib_modify_dct(ibqp, attr, attr_mask, &ucmd, udata);\n\n\tmutex_lock(&qp->mutex);\n\n\tcur_state = attr_mask & IB_QP_CUR_STATE ? attr->cur_qp_state : qp->state;\n\tnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\n\n\tif (qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\tif (attr_mask & ~(IB_QP_STATE | IB_QP_CUR_STATE)) {\n\t\t\tmlx5_ib_dbg(dev, \"invalid attr_mask 0x%x when underlay QP is used\\n\",\n\t\t\t\t    attr_mask);\n\t\t\tgoto out;\n\t\t}\n\t} else if (qp_type != MLX5_IB_QPT_REG_UMR &&\n\t\t   qp_type != MLX5_IB_QPT_DCI &&\n\t\t   !ib_modify_qp_is_ok(cur_state, new_state, qp_type,\n\t\t\t\t       attr_mask)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, qp->type, attr_mask);\n\t\tgoto out;\n\t} else if (qp_type == MLX5_IB_QPT_DCI &&\n\t\t   !modify_dci_qp_is_ok(cur_state, new_state, attr_mask)) {\n\t\tmlx5_ib_dbg(dev, \"invalid QP state transition from %d to %d, qp_type %d, attr_mask 0x%x\\n\",\n\t\t\t    cur_state, new_state, qp_type, attr_mask);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) &&\n\t    (attr->port_num == 0 ||\n\t     attr->port_num > dev->num_ports)) {\n\t\tmlx5_ib_dbg(dev, \"invalid port number %d. number of ports is %d\\n\",\n\t\t\t    attr->port_num, dev->num_ports);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PKEY_INDEX) &&\n\t    attr->pkey_index >= dev->pkey_table_len) {\n\t\tmlx5_ib_dbg(dev, \"invalid pkey index %d\\n\", attr->pkey_index);\n\t\tgoto out;\n\t}\n\n\tif (!validate_rd_atomic(dev, attr, attr_mask, qp_type))\n\t\tgoto out;\n\n\tif (cur_state == new_state && cur_state == IB_QPS_RESET) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = __mlx5_ib_modify_qp(ibqp, attr, attr_mask, cur_state,\n\t\t\t\t  new_state, &ucmd, &resp, udata);\n\n\t/* resp.response_length is set in ECE supported flows only */\n\tif (!err && resp.response_length &&\n\t    udata->outlen >= resp.response_length)\n\t\t/* Return -EFAULT to the user and expect him to destroy QP. */\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstatic inline enum ib_qp_state to_ib_qp_state(enum mlx5_qp_state mlx5_state)\n{\n\tswitch (mlx5_state) {\n\tcase MLX5_QP_STATE_RST:      return IB_QPS_RESET;\n\tcase MLX5_QP_STATE_INIT:     return IB_QPS_INIT;\n\tcase MLX5_QP_STATE_RTR:      return IB_QPS_RTR;\n\tcase MLX5_QP_STATE_RTS:      return IB_QPS_RTS;\n\tcase MLX5_QP_STATE_SQ_DRAINING:\n\tcase MLX5_QP_STATE_SQD:      return IB_QPS_SQD;\n\tcase MLX5_QP_STATE_SQER:     return IB_QPS_SQE;\n\tcase MLX5_QP_STATE_ERR:      return IB_QPS_ERR;\n\tdefault:\t\t     return -1;\n\t}\n}\n\nstatic inline enum ib_mig_state to_ib_mig_state(int mlx5_mig_state)\n{\n\tswitch (mlx5_mig_state) {\n\tcase MLX5_QP_PM_ARMED:\t\treturn IB_MIG_ARMED;\n\tcase MLX5_QP_PM_REARM:\t\treturn IB_MIG_REARM;\n\tcase MLX5_QP_PM_MIGRATED:\treturn IB_MIG_MIGRATED;\n\tdefault: return -1;\n\t}\n}\n\nstatic void to_rdma_ah_attr(struct mlx5_ib_dev *ibdev,\n\t\t\t    struct rdma_ah_attr *ah_attr, void *path)\n{\n\tint port = MLX5_GET(ads, path, vhca_port_num);\n\tint static_rate;\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\n\tif (!port || port > ibdev->num_ports)\n\t\treturn;\n\n\tah_attr->type = rdma_ah_find_type(&ibdev->ib_dev, port);\n\n\trdma_ah_set_port_num(ah_attr, port);\n\trdma_ah_set_sl(ah_attr, MLX5_GET(ads, path, sl));\n\n\trdma_ah_set_dlid(ah_attr, MLX5_GET(ads, path, rlid));\n\trdma_ah_set_path_bits(ah_attr, MLX5_GET(ads, path, mlid));\n\n\tstatic_rate = MLX5_GET(ads, path, stat_rate);\n\trdma_ah_set_static_rate(ah_attr, mlx5_to_ib_rate_map(static_rate));\n\tif (MLX5_GET(ads, path, grh) ||\n\t    ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\trdma_ah_set_grh(ah_attr, NULL, MLX5_GET(ads, path, flow_label),\n\t\t\t\tMLX5_GET(ads, path, src_addr_index),\n\t\t\t\tMLX5_GET(ads, path, hop_limit),\n\t\t\t\tMLX5_GET(ads, path, tclass));\n\t\trdma_ah_set_dgid_raw(ah_attr, MLX5_ADDR_OF(ads, path, rgid_rip));\n\t}\n}\n\nstatic int query_raw_packet_qp_sq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_sq *sq,\n\t\t\t\t\tu8 *sq_state)\n{\n\tint err;\n\n\terr = mlx5_core_query_sq_state(dev->mdev, sq->base.mqp.qpn, sq_state);\n\tif (err)\n\t\tgoto out;\n\tsq->state = *sq_state;\n\nout:\n\treturn err;\n}\n\nstatic int query_raw_packet_qp_rq_state(struct mlx5_ib_dev *dev,\n\t\t\t\t\tstruct mlx5_ib_rq *rq,\n\t\t\t\t\tu8 *rq_state)\n{\n\tvoid *out;\n\tvoid *rqc;\n\tint inlen;\n\tint err;\n\n\tinlen = MLX5_ST_SZ_BYTES(query_rq_out);\n\tout = kvzalloc(inlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_query_rq(dev->mdev, rq->base.mqp.qpn, out);\n\tif (err)\n\t\tgoto out;\n\n\trqc = MLX5_ADDR_OF(query_rq_out, out, rq_context);\n\t*rq_state = MLX5_GET(rqc, rqc, state);\n\trq->state = *rq_state;\n\nout:\n\tkvfree(out);\n\treturn err;\n}\n\nstatic int sqrq_state_to_qp_state(u8 sq_state, u8 rq_state,\n\t\t\t\t  struct mlx5_ib_qp *qp, u8 *qp_state)\n{\n\tstatic const u8 sqrq_trans[MLX5_RQ_NUM_STATE][MLX5_SQ_NUM_STATE] = {\n\t\t[MLX5_RQC_STATE_RST] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= IB_QPS_RESET,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_RESET,\n\t\t},\n\t\t[MLX5_RQC_STATE_RDY] = {\n\t\t\t[MLX5_SQC_STATE_RST]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_SQE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE,\n\t\t},\n\t\t[MLX5_RQC_STATE_ERR] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE_BAD,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= IB_QPS_ERR,\n\t\t\t[MLX5_SQ_STATE_NA]\t= IB_QPS_ERR,\n\t\t},\n\t\t[MLX5_RQ_STATE_NA] = {\n\t\t\t[MLX5_SQC_STATE_RST]    = MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_RDY]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQC_STATE_ERR]\t= MLX5_QP_STATE,\n\t\t\t[MLX5_SQ_STATE_NA]\t= MLX5_QP_STATE_BAD,\n\t\t},\n\t};\n\n\t*qp_state = sqrq_trans[rq_state][sq_state];\n\n\tif (*qp_state == MLX5_QP_STATE_BAD) {\n\t\tWARN(1, \"Buggy Raw Packet QP state, SQ 0x%x state: 0x%x, RQ 0x%x state: 0x%x\",\n\t\t     qp->raw_packet_qp.sq.base.mqp.qpn, sq_state,\n\t\t     qp->raw_packet_qp.rq.base.mqp.qpn, rq_state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*qp_state == MLX5_QP_STATE)\n\t\t*qp_state = qp->state;\n\n\treturn 0;\n}\n\nstatic int query_raw_packet_qp_state(struct mlx5_ib_dev *dev,\n\t\t\t\t     struct mlx5_ib_qp *qp,\n\t\t\t\t     u8 *raw_packet_qp_state)\n{\n\tstruct mlx5_ib_raw_packet_qp *raw_packet_qp = &qp->raw_packet_qp;\n\tstruct mlx5_ib_sq *sq = &raw_packet_qp->sq;\n\tstruct mlx5_ib_rq *rq = &raw_packet_qp->rq;\n\tint err;\n\tu8 sq_state = MLX5_SQ_STATE_NA;\n\tu8 rq_state = MLX5_RQ_STATE_NA;\n\n\tif (qp->sq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_sq_state(dev, sq, &sq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (qp->rq.wqe_cnt) {\n\t\terr = query_raw_packet_qp_rq_state(dev, rq, &rq_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn sqrq_state_to_qp_state(sq_state, rq_state, qp,\n\t\t\t\t      raw_packet_qp_state);\n}\n\nstatic int query_qp_attr(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *qp,\n\t\t\t struct ib_qp_attr *qp_attr)\n{\n\tint outlen = MLX5_ST_SZ_BYTES(query_qp_out);\n\tvoid *qpc, *pri_path, *alt_path;\n\tu32 *outb;\n\tint err;\n\n\toutb = kzalloc(outlen, GFP_KERNEL);\n\tif (!outb)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_qp_query(dev, &qp->trans_qp.base.mqp, outb, outlen,\n\t\t\t\t false);\n\tif (err)\n\t\tgoto out;\n\n\tqpc = MLX5_ADDR_OF(query_qp_out, outb, qpc);\n\n\tqp->state = to_ib_qp_state(MLX5_GET(qpc, qpc, state));\n\tif (MLX5_GET(qpc, qpc, state) == MLX5_QP_STATE_SQ_DRAINING)\n\t\tqp_attr->sq_draining = 1;\n\n\tqp_attr->path_mtu = MLX5_GET(qpc, qpc, mtu);\n\tqp_attr->path_mig_state = to_ib_mig_state(MLX5_GET(qpc, qpc, pm_state));\n\tqp_attr->qkey = MLX5_GET(qpc, qpc, q_key);\n\tqp_attr->rq_psn = MLX5_GET(qpc, qpc, next_rcv_psn);\n\tqp_attr->sq_psn = MLX5_GET(qpc, qpc, next_send_psn);\n\tqp_attr->dest_qp_num = MLX5_GET(qpc, qpc, remote_qpn);\n\n\tif (MLX5_GET(qpc, qpc, rre))\n\t\tqp_attr->qp_access_flags |= IB_ACCESS_REMOTE_READ;\n\tif (MLX5_GET(qpc, qpc, rwe))\n\t\tqp_attr->qp_access_flags |= IB_ACCESS_REMOTE_WRITE;\n\tif (MLX5_GET(qpc, qpc, rae))\n\t\tqp_attr->qp_access_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\n\tqp_attr->max_rd_atomic = 1 << MLX5_GET(qpc, qpc, log_sra_max);\n\tqp_attr->max_dest_rd_atomic = 1 << MLX5_GET(qpc, qpc, log_rra_max);\n\tqp_attr->min_rnr_timer = MLX5_GET(qpc, qpc, min_rnr_nak);\n\tqp_attr->retry_cnt = MLX5_GET(qpc, qpc, retry_count);\n\tqp_attr->rnr_retry = MLX5_GET(qpc, qpc, rnr_retry);\n\n\tpri_path = MLX5_ADDR_OF(qpc, qpc, primary_address_path);\n\talt_path = MLX5_ADDR_OF(qpc, qpc, secondary_address_path);\n\n\tif (qp->type == IB_QPT_RC || qp->type == IB_QPT_UC ||\n\t    qp->type == IB_QPT_XRC_INI || qp->type == IB_QPT_XRC_TGT) {\n\t\tto_rdma_ah_attr(dev, &qp_attr->ah_attr, pri_path);\n\t\tto_rdma_ah_attr(dev, &qp_attr->alt_ah_attr, alt_path);\n\t\tqp_attr->alt_pkey_index = MLX5_GET(ads, alt_path, pkey_index);\n\t\tqp_attr->alt_port_num = MLX5_GET(ads, alt_path, vhca_port_num);\n\t}\n\n\tqp_attr->pkey_index = MLX5_GET(ads, pri_path, pkey_index);\n\tqp_attr->port_num = MLX5_GET(ads, pri_path, vhca_port_num);\n\tqp_attr->timeout = MLX5_GET(ads, pri_path, ack_timeout);\n\tqp_attr->alt_timeout = MLX5_GET(ads, alt_path, ack_timeout);\n\nout:\n\tkfree(outb);\n\treturn err;\n}\n\nstatic int mlx5_ib_dct_query_qp(struct mlx5_ib_dev *dev, struct mlx5_ib_qp *mqp,\n\t\t\t\tstruct ib_qp_attr *qp_attr, int qp_attr_mask,\n\t\t\t\tstruct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_core_dct\t*dct = &mqp->dct.mdct;\n\tu32 *out;\n\tu32 access_flags = 0;\n\tint outlen = MLX5_ST_SZ_BYTES(query_dct_out);\n\tvoid *dctc;\n\tint err;\n\tint supported_mask = IB_QP_STATE |\n\t\t\t     IB_QP_ACCESS_FLAGS |\n\t\t\t     IB_QP_PORT |\n\t\t\t     IB_QP_MIN_RNR_TIMER |\n\t\t\t     IB_QP_AV |\n\t\t\t     IB_QP_PATH_MTU |\n\t\t\t     IB_QP_PKEY_INDEX;\n\n\tif (qp_attr_mask & ~supported_mask)\n\t\treturn -EINVAL;\n\tif (mqp->state != IB_QPS_RTR)\n\t\treturn -EINVAL;\n\n\tout = kzalloc(outlen, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_dct_query(dev, dct, out, outlen);\n\tif (err)\n\t\tgoto out;\n\n\tdctc = MLX5_ADDR_OF(query_dct_out, out, dct_context_entry);\n\n\tif (qp_attr_mask & IB_QP_STATE)\n\t\tqp_attr->qp_state = IB_QPS_RTR;\n\n\tif (qp_attr_mask & IB_QP_ACCESS_FLAGS) {\n\t\tif (MLX5_GET(dctc, dctc, rre))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_READ;\n\t\tif (MLX5_GET(dctc, dctc, rwe))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_WRITE;\n\t\tif (MLX5_GET(dctc, dctc, rae))\n\t\t\taccess_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\t\tqp_attr->qp_access_flags = access_flags;\n\t}\n\n\tif (qp_attr_mask & IB_QP_PORT)\n\t\tqp_attr->port_num = MLX5_GET(dctc, dctc, port);\n\tif (qp_attr_mask & IB_QP_MIN_RNR_TIMER)\n\t\tqp_attr->min_rnr_timer = MLX5_GET(dctc, dctc, min_rnr_nak);\n\tif (qp_attr_mask & IB_QP_AV) {\n\t\tqp_attr->ah_attr.grh.traffic_class = MLX5_GET(dctc, dctc, tclass);\n\t\tqp_attr->ah_attr.grh.flow_label = MLX5_GET(dctc, dctc, flow_label);\n\t\tqp_attr->ah_attr.grh.sgid_index = MLX5_GET(dctc, dctc, my_addr_index);\n\t\tqp_attr->ah_attr.grh.hop_limit = MLX5_GET(dctc, dctc, hop_limit);\n\t}\n\tif (qp_attr_mask & IB_QP_PATH_MTU)\n\t\tqp_attr->path_mtu = MLX5_GET(dctc, dctc, mtu);\n\tif (qp_attr_mask & IB_QP_PKEY_INDEX)\n\t\tqp_attr->pkey_index = MLX5_GET(dctc, dctc, pkey_index);\nout:\n\tkfree(out);\n\treturn err;\n}\n\nint mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t     int qp_attr_mask, struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\tstruct mlx5_ib_qp *qp = to_mqp(ibqp);\n\tint err = 0;\n\tu8 raw_packet_qp_state;\n\n\tif (ibqp->rwq_ind_tbl)\n\t\treturn -ENOSYS;\n\n\tif (qp->type == IB_QPT_GSI)\n\t\treturn mlx5_ib_gsi_query_qp(ibqp, qp_attr, qp_attr_mask,\n\t\t\t\t\t    qp_init_attr);\n\n\t/* Not all of output fields are applicable, make sure to zero them */\n\tmemset(qp_init_attr, 0, sizeof(*qp_init_attr));\n\tmemset(qp_attr, 0, sizeof(*qp_attr));\n\n\tif (unlikely(qp->type == MLX5_IB_QPT_DCT))\n\t\treturn mlx5_ib_dct_query_qp(dev, qp, qp_attr,\n\t\t\t\t\t    qp_attr_mask, qp_init_attr);\n\n\tmutex_lock(&qp->mutex);\n\n\tif (qp->type == IB_QPT_RAW_PACKET ||\n\t    qp->flags & IB_QP_CREATE_SOURCE_QPN) {\n\t\terr = query_raw_packet_qp_state(dev, qp, &raw_packet_qp_state);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tqp->state = raw_packet_qp_state;\n\t\tqp_attr->port_num = 1;\n\t} else {\n\t\terr = query_qp_attr(dev, qp, qp_attr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tqp_attr->qp_state\t     = qp->state;\n\tqp_attr->cur_qp_state\t     = qp_attr->qp_state;\n\tqp_attr->cap.max_recv_wr     = qp->rq.wqe_cnt;\n\tqp_attr->cap.max_recv_sge    = qp->rq.max_gs;\n\n\tif (!ibqp->uobject) {\n\t\tqp_attr->cap.max_send_wr  = qp->sq.max_post;\n\t\tqp_attr->cap.max_send_sge = qp->sq.max_gs;\n\t\tqp_init_attr->qp_context = ibqp->qp_context;\n\t} else {\n\t\tqp_attr->cap.max_send_wr  = 0;\n\t\tqp_attr->cap.max_send_sge = 0;\n\t}\n\n\tqp_init_attr->qp_type = qp->type;\n\tqp_init_attr->recv_cq = ibqp->recv_cq;\n\tqp_init_attr->send_cq = ibqp->send_cq;\n\tqp_init_attr->srq = ibqp->srq;\n\tqp_attr->cap.max_inline_data = qp->max_inline_data;\n\n\tqp_init_attr->cap\t     = qp_attr->cap;\n\n\tqp_init_attr->create_flags = qp->flags;\n\n\tqp_init_attr->sq_sig_type = qp->sq_signal_bits & MLX5_WQE_CTRL_CQ_UPDATE ?\n\t\tIB_SIGNAL_ALL_WR : IB_SIGNAL_REQ_WR;\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nint mlx5_ib_alloc_xrcd(struct ib_xrcd *ibxrcd, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibxrcd->device);\n\tstruct mlx5_ib_xrcd *xrcd = to_mxrcd(ibxrcd);\n\n\tif (!MLX5_CAP_GEN(dev->mdev, xrc))\n\t\treturn -EOPNOTSUPP;\n\n\treturn mlx5_cmd_xrcd_alloc(dev->mdev, &xrcd->xrcdn, 0);\n}\n\nint mlx5_ib_dealloc_xrcd(struct ib_xrcd *xrcd, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(xrcd->device);\n\tu32 xrcdn = to_mxrcd(xrcd)->xrcdn;\n\n\treturn mlx5_cmd_xrcd_dealloc(dev->mdev, xrcdn, 0);\n}\n\nstatic void mlx5_ib_wq_event(struct mlx5_core_qp *core_qp, int type)\n{\n\tstruct mlx5_ib_rwq *rwq = to_mibrwq(core_qp);\n\tstruct mlx5_ib_dev *dev = to_mdev(rwq->ibwq.device);\n\tstruct ib_event event;\n\n\tif (rwq->ibwq.event_handler) {\n\t\tevent.device     = rwq->ibwq.device;\n\t\tevent.element.wq = &rwq->ibwq;\n\t\tswitch (type) {\n\t\tcase MLX5_EVENT_TYPE_WQ_CATAS_ERROR:\n\t\t\tevent.event = IB_EVENT_WQ_FATAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmlx5_ib_warn(dev, \"Unexpected event type %d on WQ %06x\\n\", type, core_qp->qpn);\n\t\t\treturn;\n\t\t}\n\n\t\trwq->ibwq.event_handler(&event, rwq->ibwq.wq_context);\n\t}\n}\n\nstatic int set_delay_drop(struct mlx5_ib_dev *dev)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->delay_drop.lock);\n\tif (dev->delay_drop.activate)\n\t\tgoto out;\n\n\terr = mlx5_core_set_delay_drop(dev, dev->delay_drop.timeout);\n\tif (err)\n\t\tgoto out;\n\n\tdev->delay_drop.activate = true;\nout:\n\tmutex_unlock(&dev->delay_drop.lock);\n\n\tif (!err)\n\t\tatomic_inc(&dev->delay_drop.rqs_cnt);\n\treturn err;\n}\n\nstatic int  create_rq(struct mlx5_ib_rwq *rwq, struct ib_pd *pd,\n\t\t      struct ib_wq_init_attr *init_attr)\n{\n\tstruct mlx5_ib_dev *dev;\n\tint has_net_offloads;\n\t__be64 *rq_pas0;\n\tint ts_format;\n\tvoid *in;\n\tvoid *rqc;\n\tvoid *wq;\n\tint inlen;\n\tint err;\n\n\tdev = to_mdev(pd->device);\n\n\tts_format = get_rq_ts_format(dev, to_mcq(init_attr->cq));\n\tif (ts_format < 0)\n\t\treturn ts_format;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rq_in) + sizeof(u64) * rwq->rq_num_pas;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(create_rq_in, in, uid, to_mpd(pd)->uid);\n\trqc = MLX5_ADDR_OF(create_rq_in, in, ctx);\n\tMLX5_SET(rqc,  rqc, mem_rq_type,\n\t\t MLX5_RQC_MEM_RQ_TYPE_MEMORY_RQ_INLINE);\n\tMLX5_SET(rqc, rqc, ts_format, ts_format);\n\tMLX5_SET(rqc, rqc, user_index, rwq->user_index);\n\tMLX5_SET(rqc,  rqc, cqn, to_mcq(init_attr->cq)->mcq.cqn);\n\tMLX5_SET(rqc,  rqc, state, MLX5_RQC_STATE_RST);\n\tMLX5_SET(rqc,  rqc, flush_in_error_en, 1);\n\twq = MLX5_ADDR_OF(rqc, rqc, wq);\n\tMLX5_SET(wq, wq, wq_type,\n\t\t rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ ?\n\t\t MLX5_WQ_TYPE_CYCLIC_STRIDING_RQ : MLX5_WQ_TYPE_CYCLIC);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, end_pad)) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tMLX5_SET(wq, wq, end_padding_mode, MLX5_WQ_END_PAD_MODE_ALIGN);\n\t\t}\n\t}\n\tMLX5_SET(wq, wq, log_wq_stride, rwq->log_rq_stride);\n\tif (rwq->create_flags & MLX5_IB_WQ_FLAGS_STRIDING_RQ) {\n\t\t/*\n\t\t * In Firmware number of strides in each WQE is:\n\t\t *   \"512 * 2^single_wqe_log_num_of_strides\"\n\t\t * Values 3 to 8 are accepted as 10 to 15, 9 to 18 are\n\t\t * accepted as 0 to 9\n\t\t */\n\t\tstatic const u8 fw_map[] = { 10, 11, 12, 13, 14, 15, 0, 1,\n\t\t\t\t\t     2,  3,  4,  5,  6,  7,  8, 9 };\n\t\tMLX5_SET(wq, wq, two_byte_shift_en, rwq->two_byte_shift_en);\n\t\tMLX5_SET(wq, wq, log_wqe_stride_size,\n\t\t\t rwq->single_stride_log_num_of_bytes -\n\t\t\t MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\tMLX5_SET(wq, wq, log_wqe_num_of_strides,\n\t\t\t fw_map[rwq->log_num_strides -\n\t\t\t\tMLX5_EXT_MIN_SINGLE_WQE_LOG_NUM_STRIDES]);\n\t}\n\tMLX5_SET(wq, wq, log_wq_sz, rwq->log_rq_size);\n\tMLX5_SET(wq, wq, pd, to_mpd(pd)->pdn);\n\tMLX5_SET(wq, wq, page_offset, rwq->rq_page_offset);\n\tMLX5_SET(wq, wq, log_wq_pg_sz, rwq->log_page_size);\n\tMLX5_SET(wq, wq, wq_signature, rwq->wq_sig);\n\tMLX5_SET64(wq, wq, dbr_addr, rwq->db.dma);\n\thas_net_offloads = MLX5_CAP_GEN(dev->mdev, eth_net_offloads);\n\tif (init_attr->create_flags & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tMLX5_SET(rqc, rqc, vsd, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_SCATTER_FCS) {\n\t\tif (!(has_net_offloads && MLX5_CAP_ETH(dev->mdev, scatter_fcs))) {\n\t\t\tmlx5_ib_dbg(dev, \"Scatter FCS is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, scatter_fcs, 1);\n\t}\n\tif (init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\tif (!(dev->ib_dev.attrs.raw_packet_caps &\n\t\t      IB_RAW_PACKET_CAP_DELAY_DROP)) {\n\t\t\tmlx5_ib_dbg(dev, \"Delay drop is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tMLX5_SET(rqc, rqc, delay_drop_en, 1);\n\t}\n\trq_pas0 = (__be64 *)MLX5_ADDR_OF(wq, wq, pas);\n\tmlx5_ib_populate_pas(rwq->umem, 1UL << rwq->page_shift, rq_pas0, 0);\n\terr = mlx5_core_create_rq_tracked(dev, in, inlen, &rwq->core_qp);\n\tif (!err && init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP) {\n\t\terr = set_delay_drop(dev);\n\t\tif (err) {\n\t\t\tmlx5_ib_warn(dev, \"Failed to enable delay drop err=%d\\n\",\n\t\t\t\t     err);\n\t\t\tmlx5_core_destroy_rq_tracked(dev, &rwq->core_qp);\n\t\t} else {\n\t\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_DELAY_DROP;\n\t\t}\n\t}\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int set_user_rq_size(struct mlx5_ib_dev *dev,\n\t\t\t    struct ib_wq_init_attr *wq_init_attr,\n\t\t\t    struct mlx5_ib_create_wq *ucmd,\n\t\t\t    struct mlx5_ib_rwq *rwq)\n{\n\t/* Sanity check RQ size before proceeding */\n\tif (wq_init_attr->max_wr > (1 << MLX5_CAP_GEN(dev->mdev, log_max_wq_sz)))\n\t\treturn -EINVAL;\n\n\tif (!ucmd->rq_wqe_count)\n\t\treturn -EINVAL;\n\n\trwq->wqe_count = ucmd->rq_wqe_count;\n\trwq->wqe_shift = ucmd->rq_wqe_shift;\n\tif (check_shl_overflow(rwq->wqe_count, rwq->wqe_shift, &rwq->buf_size))\n\t\treturn -EINVAL;\n\n\trwq->log_rq_stride = rwq->wqe_shift;\n\trwq->log_rq_size = ilog2(rwq->wqe_count);\n\treturn 0;\n}\n\nstatic bool log_of_strides_valid(struct mlx5_ib_dev *dev, u32 log_num_strides)\n{\n\tif ((log_num_strides > MLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES) ||\n\t    (log_num_strides < MLX5_EXT_MIN_SINGLE_WQE_LOG_NUM_STRIDES))\n\t\treturn false;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, ext_stride_num_range) &&\n\t    (log_num_strides < MLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int prepare_user_rq(struct ib_pd *pd,\n\t\t\t   struct ib_wq_init_attr *init_attr,\n\t\t\t   struct ib_udata *udata,\n\t\t\t   struct mlx5_ib_rwq *rwq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_create_wq ucmd = {};\n\tint err;\n\tsize_t required_cmd_sz;\n\n\trequired_cmd_sz = offsetofend(struct mlx5_ib_create_wq,\n\t\t\t\t      single_stride_log_num_of_bytes);\n\tif (udata->inlen < required_cmd_sz) {\n\t\tmlx5_ib_dbg(dev, \"invalid inlen\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd))) {\n\t\tmlx5_ib_dbg(dev, \"inlen is not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen))) {\n\t\tmlx5_ib_dbg(dev, \"copy failed\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (ucmd.comp_mask & (~MLX5_IB_CREATE_WQ_STRIDING_RQ)) {\n\t\tmlx5_ib_dbg(dev, \"invalid comp mask\\n\");\n\t\treturn -EOPNOTSUPP;\n\t} else if (ucmd.comp_mask & MLX5_IB_CREATE_WQ_STRIDING_RQ) {\n\t\tif (!MLX5_CAP_GEN(dev->mdev, striding_rq)) {\n\t\t\tmlx5_ib_dbg(dev, \"Striding RQ is not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t\tif ((ucmd.single_stride_log_num_of_bytes <\n\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES) ||\n\t\t    (ucmd.single_stride_log_num_of_bytes >\n\t\t     MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES)) {\n\t\t\tmlx5_ib_dbg(dev, \"Invalid log stride size (%u. Range is %u - %u)\\n\",\n\t\t\t\t    ucmd.single_stride_log_num_of_bytes,\n\t\t\t\t    MLX5_MIN_SINGLE_STRIDE_LOG_NUM_BYTES,\n\t\t\t\t    MLX5_MAX_SINGLE_STRIDE_LOG_NUM_BYTES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!log_of_strides_valid(dev,\n\t\t\t\t\t  ucmd.single_wqe_log_num_of_strides)) {\n\t\t\tmlx5_ib_dbg(\n\t\t\t\tdev,\n\t\t\t\t\"Invalid log num strides (%u. Range is %u - %u)\\n\",\n\t\t\t\tucmd.single_wqe_log_num_of_strides,\n\t\t\t\tMLX5_CAP_GEN(dev->mdev, ext_stride_num_range) ?\n\t\t\t\t\tMLX5_EXT_MIN_SINGLE_WQE_LOG_NUM_STRIDES :\n\t\t\t\t\tMLX5_MIN_SINGLE_WQE_LOG_NUM_STRIDES,\n\t\t\t\tMLX5_MAX_SINGLE_WQE_LOG_NUM_STRIDES);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trwq->single_stride_log_num_of_bytes =\n\t\t\tucmd.single_stride_log_num_of_bytes;\n\t\trwq->log_num_strides = ucmd.single_wqe_log_num_of_strides;\n\t\trwq->two_byte_shift_en = !!ucmd.two_byte_shift_en;\n\t\trwq->create_flags |= MLX5_IB_WQ_FLAGS_STRIDING_RQ;\n\t}\n\n\terr = set_user_rq_size(dev, init_attr, &ucmd, rwq);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = create_user_rq(dev, pd, udata, rwq, &ucmd);\n\tif (err) {\n\t\tmlx5_ib_dbg(dev, \"err %d\\n\", err);\n\t\treturn err;\n\t}\n\n\trwq->user_index = ucmd.user_index;\n\treturn 0;\n}\n\nstruct ib_wq *mlx5_ib_create_wq(struct ib_pd *pd,\n\t\t\t\tstruct ib_wq_init_attr *init_attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_rwq *rwq;\n\tstruct mlx5_ib_create_wq_resp resp = {};\n\tsize_t min_resp_len;\n\tint err;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-ENOSYS);\n\n\tmin_resp_len = offsetofend(struct mlx5_ib_create_wq_resp, reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!capable(CAP_SYS_RAWIO) &&\n\t    init_attr->create_flags & IB_WQ_FLAGS_DELAY_DROP)\n\t\treturn ERR_PTR(-EPERM);\n\n\tdev = to_mdev(pd->device);\n\tswitch (init_attr->wq_type) {\n\tcase IB_WQT_RQ:\n\t\trwq = kzalloc(sizeof(*rwq), GFP_KERNEL);\n\t\tif (!rwq)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\terr = prepare_user_rq(pd, init_attr, udata, rwq);\n\t\tif (err)\n\t\t\tgoto err;\n\t\terr = create_rq(rwq, pd, init_attr);\n\t\tif (err)\n\t\t\tgoto err_user_rq;\n\t\tbreak;\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"unsupported wq type %d\\n\",\n\t\t\t    init_attr->wq_type);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trwq->ibwq.wq_num = rwq->core_qp.qpn;\n\trwq->ibwq.state = IB_WQS_RESET;\n\tif (udata->outlen) {\n\t\tresp.response_length = offsetofend(\n\t\t\tstruct mlx5_ib_create_wq_resp, response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\trwq->core_qp.event = mlx5_ib_wq_event;\n\trwq->ibwq.event_handler = init_attr->event_handler;\n\treturn &rwq->ibwq;\n\nerr_copy:\n\tmlx5_core_destroy_rq_tracked(dev, &rwq->core_qp);\nerr_user_rq:\n\tdestroy_user_rq(dev, pd, rwq, udata);\nerr:\n\tkfree(rwq);\n\treturn ERR_PTR(err);\n}\n\nint mlx5_ib_destroy_wq(struct ib_wq *wq, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\tint ret;\n\n\tret = mlx5_core_destroy_rq_tracked(dev, &rwq->core_qp);\n\tif (ret)\n\t\treturn ret;\n\tdestroy_user_rq(dev, wq->pd, rwq, udata);\n\tkfree(rwq);\n\treturn 0;\n}\n\nint mlx5_ib_create_rwq_ind_table(struct ib_rwq_ind_table *ib_rwq_ind_table,\n\t\t\t\t struct ib_rwq_ind_table_init_attr *init_attr,\n\t\t\t\t struct ib_udata *udata)\n{\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl =\n\t\tto_mrwq_ind_table(ib_rwq_ind_table);\n\tstruct mlx5_ib_dev *dev = to_mdev(ib_rwq_ind_table->device);\n\tint sz = 1 << init_attr->log_ind_tbl_size;\n\tstruct mlx5_ib_create_rwq_ind_tbl_resp resp = {};\n\tsize_t min_resp_len;\n\tint inlen;\n\tint err;\n\tint i;\n\tu32 *in;\n\tvoid *rqtc;\n\n\tif (udata->inlen > 0 &&\n\t    !ib_is_udata_cleared(udata, 0,\n\t\t\t\t udata->inlen))\n\t\treturn -EOPNOTSUPP;\n\n\tif (init_attr->log_ind_tbl_size >\n\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size)) {\n\t\tmlx5_ib_dbg(dev, \"log_ind_tbl_size = %d is bigger than supported = %d\\n\",\n\t\t\t    init_attr->log_ind_tbl_size,\n\t\t\t    MLX5_CAP_GEN(dev->mdev, log_max_rqt_size));\n\t\treturn -EINVAL;\n\t}\n\n\tmin_resp_len =\n\t\toffsetofend(struct mlx5_ib_create_rwq_ind_tbl_resp, reserved);\n\tif (udata->outlen && udata->outlen < min_resp_len)\n\t\treturn -EINVAL;\n\n\tinlen = MLX5_ST_SZ_BYTES(create_rqt_in) + sizeof(u32) * sz;\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqtc = MLX5_ADDR_OF(create_rqt_in, in, rqt_context);\n\n\tMLX5_SET(rqtc, rqtc, rqt_actual_size, sz);\n\tMLX5_SET(rqtc, rqtc, rqt_max_size, sz);\n\n\tfor (i = 0; i < sz; i++)\n\t\tMLX5_SET(rqtc, rqtc, rq_num[i], init_attr->ind_tbl[i]->wq_num);\n\n\trwq_ind_tbl->uid = to_mpd(init_attr->ind_tbl[0]->pd)->uid;\n\tMLX5_SET(create_rqt_in, in, uid, rwq_ind_tbl->uid);\n\n\terr = mlx5_core_create_rqt(dev->mdev, in, inlen, &rwq_ind_tbl->rqtn);\n\tkvfree(in);\n\tif (err)\n\t\treturn err;\n\n\trwq_ind_tbl->ib_rwq_ind_tbl.ind_tbl_num = rwq_ind_tbl->rqtn;\n\tif (udata->outlen) {\n\t\tresp.response_length =\n\t\t\toffsetofend(struct mlx5_ib_create_rwq_ind_tbl_resp,\n\t\t\t\t    response_length);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\tgoto err_copy;\n\t}\n\n\treturn 0;\n\nerr_copy:\n\tmlx5_cmd_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn, rwq_ind_tbl->uid);\n\treturn err;\n}\n\nint mlx5_ib_destroy_rwq_ind_table(struct ib_rwq_ind_table *ib_rwq_ind_tbl)\n{\n\tstruct mlx5_ib_rwq_ind_table *rwq_ind_tbl = to_mrwq_ind_table(ib_rwq_ind_tbl);\n\tstruct mlx5_ib_dev *dev = to_mdev(ib_rwq_ind_tbl->device);\n\n\treturn mlx5_cmd_destroy_rqt(dev->mdev, rwq_ind_tbl->rqtn, rwq_ind_tbl->uid);\n}\n\nint mlx5_ib_modify_wq(struct ib_wq *wq, struct ib_wq_attr *wq_attr,\n\t\t      u32 wq_attr_mask, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(wq->device);\n\tstruct mlx5_ib_rwq *rwq = to_mrwq(wq);\n\tstruct mlx5_ib_modify_wq ucmd = {};\n\tsize_t required_cmd_sz;\n\tint curr_wq_state;\n\tint wq_state;\n\tint inlen;\n\tint err;\n\tvoid *rqc;\n\tvoid *in;\n\n\trequired_cmd_sz = offsetofend(struct mlx5_ib_modify_wq, reserved);\n\tif (udata->inlen < required_cmd_sz)\n\t\treturn -EINVAL;\n\n\tif (udata->inlen > sizeof(ucmd) &&\n\t    !ib_is_udata_cleared(udata, sizeof(ucmd),\n\t\t\t\t udata->inlen - sizeof(ucmd)))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ib_copy_from_udata(&ucmd, udata, min(sizeof(ucmd), udata->inlen)))\n\t\treturn -EFAULT;\n\n\tif (ucmd.comp_mask || ucmd.reserved)\n\t\treturn -EOPNOTSUPP;\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_rq_in);\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\trqc = MLX5_ADDR_OF(modify_rq_in, in, ctx);\n\n\tcurr_wq_state = wq_attr->curr_wq_state;\n\twq_state = wq_attr->wq_state;\n\tif (curr_wq_state == IB_WQS_ERR)\n\t\tcurr_wq_state = MLX5_RQC_STATE_ERR;\n\tif (wq_state == IB_WQS_ERR)\n\t\twq_state = MLX5_RQC_STATE_ERR;\n\tMLX5_SET(modify_rq_in, in, rq_state, curr_wq_state);\n\tMLX5_SET(modify_rq_in, in, uid, to_mpd(wq->pd)->uid);\n\tMLX5_SET(rqc, rqc, state, wq_state);\n\n\tif (wq_attr_mask & IB_WQ_FLAGS) {\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_CVLAN_STRIPPING) {\n\t\t\tif (!(MLX5_CAP_GEN(dev->mdev, eth_net_offloads) &&\n\t\t\t      MLX5_CAP_ETH(dev->mdev, vlan_cap))) {\n\t\t\t\tmlx5_ib_dbg(dev, \"VLAN offloads are not supported\\n\");\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_VSD);\n\t\t\tMLX5_SET(rqc, rqc, vsd,\n\t\t\t\t (wq_attr->flags & IB_WQ_FLAGS_CVLAN_STRIPPING) ? 0 : 1);\n\t\t}\n\n\t\tif (wq_attr->flags_mask & IB_WQ_FLAGS_PCI_WRITE_END_PADDING) {\n\t\t\tmlx5_ib_dbg(dev, \"Modifying scatter end padding is not supported\\n\");\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (curr_wq_state == IB_WQS_RESET && wq_state == IB_WQS_RDY) {\n\t\tu16 set_id;\n\n\t\tset_id = mlx5_ib_get_counters_id(dev, 0);\n\t\tif (MLX5_CAP_GEN(dev->mdev, modify_rq_counter_set_id)) {\n\t\t\tMLX5_SET64(modify_rq_in, in, modify_bitmask,\n\t\t\t\t   MLX5_MODIFY_RQ_IN_MODIFY_BITMASK_RQ_COUNTER_SET_ID);\n\t\t\tMLX5_SET(rqc, rqc, counter_set_id, set_id);\n\t\t} else\n\t\t\tdev_info_once(\n\t\t\t\t&dev->ib_dev.dev,\n\t\t\t\t\"Receive WQ counters are not supported on current FW\\n\");\n\t}\n\n\terr = mlx5_core_modify_rq(dev->mdev, rwq->core_qp.qpn, in);\n\tif (!err)\n\t\trwq->ibwq.state = (wq_state == MLX5_RQC_STATE_ERR) ? IB_WQS_ERR : wq_state;\n\nout:\n\tkvfree(in);\n\treturn err;\n}\n\nstruct mlx5_ib_drain_cqe {\n\tstruct ib_cqe cqe;\n\tstruct completion done;\n};\n\nstatic void mlx5_ib_drain_qp_done(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_drain_cqe *cqe = container_of(wc->wr_cqe,\n\t\t\t\t\t\t     struct mlx5_ib_drain_cqe,\n\t\t\t\t\t\t     cqe);\n\n\tcomplete(&cqe->done);\n}\n\n/* This function returns only once the drained WR was completed */\nstatic void handle_drain_completion(struct ib_cq *cq,\n\t\t\t\t    struct mlx5_ib_drain_cqe *sdrain,\n\t\t\t\t    struct mlx5_ib_dev *dev)\n{\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tif (cq->poll_ctx == IB_POLL_DIRECT) {\n\t\twhile (wait_for_completion_timeout(&sdrain->done, HZ / 10) <= 0)\n\t\t\tib_process_cq_direct(cq, -1);\n\t\treturn;\n\t}\n\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tstruct mlx5_ib_cq *mcq = to_mcq(cq);\n\t\tbool triggered = false;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&dev->reset_flow_resource_lock, flags);\n\t\t/* Make sure that the CQ handler won't run if wasn't run yet */\n\t\tif (!mcq->mcq.reset_notify_added)\n\t\t\tmcq->mcq.reset_notify_added = 1;\n\t\telse\n\t\t\ttriggered = true;\n\t\tspin_unlock_irqrestore(&dev->reset_flow_resource_lock, flags);\n\n\t\tif (triggered) {\n\t\t\t/* Wait for any scheduled/running task to be ended */\n\t\t\tswitch (cq->poll_ctx) {\n\t\t\tcase IB_POLL_SOFTIRQ:\n\t\t\t\tirq_poll_disable(&cq->iop);\n\t\t\t\tirq_poll_enable(&cq->iop);\n\t\t\t\tbreak;\n\t\t\tcase IB_POLL_WORKQUEUE:\n\t\t\t\tcancel_work_sync(&cq->work);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t}\n\t\t}\n\n\t\t/* Run the CQ handler - this makes sure that the drain WR will\n\t\t * be processed if wasn't processed yet.\n\t\t */\n\t\tmcq->mcq.comp(&mcq->mcq, NULL);\n\t}\n\n\twait_for_completion(&sdrain->done);\n}\n\nvoid mlx5_ib_drain_sq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->send_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe sdrain;\n\tconst struct ib_send_wr *bad_swr;\n\tstruct ib_rdma_wr swr = {\n\t\t.wr = {\n\t\t\t.next = NULL,\n\t\t\t{ .wr_cqe\t= &sdrain.cqe, },\n\t\t\t.opcode\t= IB_WR_RDMA_WRITE,\n\t\t},\n\t};\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tsdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&sdrain.done);\n\n\tret = mlx5_ib_post_send_drain(qp, &swr.wr, &bad_swr);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain send queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &sdrain, dev);\n}\n\nvoid mlx5_ib_drain_rq(struct ib_qp *qp)\n{\n\tstruct ib_cq *cq = qp->recv_cq;\n\tstruct ib_qp_attr attr = { .qp_state = IB_QPS_ERR };\n\tstruct mlx5_ib_drain_cqe rdrain;\n\tstruct ib_recv_wr rwr = {};\n\tconst struct ib_recv_wr *bad_rwr;\n\tint ret;\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret && mdev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trwr.wr_cqe = &rdrain.cqe;\n\trdrain.cqe.done = mlx5_ib_drain_qp_done;\n\tinit_completion(&rdrain.done);\n\n\tret = mlx5_ib_post_recv_drain(qp, &rwr, &bad_rwr);\n\tif (ret) {\n\t\tWARN_ONCE(ret, \"failed to drain recv queue: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\thandle_drain_completion(cq, &rdrain, dev);\n}\n\n/*\n * Bind a qp to a counter. If @counter is NULL then bind the qp to\n * the default counter\n */\nint mlx5_ib_qp_set_counter(struct ib_qp *qp, struct rdma_counter *counter)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tint err = 0;\n\n\tmutex_lock(&mqp->mutex);\n\tif (mqp->state == IB_QPS_RESET) {\n\t\tqp->counter = counter;\n\t\tgoto out;\n\t}\n\n\tif (!MLX5_CAP_GEN(dev->mdev, rts2rts_qp_counters_set_id)) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (mqp->state == IB_QPS_RTS) {\n\t\terr = __mlx5_ib_qp_set_counter(qp, counter);\n\t\tif (!err)\n\t\t\tqp->counter = counter;\n\n\t\tgoto out;\n\t}\n\n\tmqp->counter_pending = 1;\n\tqp->counter = counter;\n\nout:\n\tmutex_unlock(&mqp->mutex);\n\treturn err;\n}\n\nint mlx5_ib_qp_event_init(void)\n{\n\tmlx5_ib_qp_event_wq = alloc_ordered_workqueue(\"mlx5_ib_qp_event_wq\", 0);\n\tif (!mlx5_ib_qp_event_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mlx5_ib_qp_event_cleanup(void)\n{\n\tdestroy_workqueue(mlx5_ib_qp_event_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}