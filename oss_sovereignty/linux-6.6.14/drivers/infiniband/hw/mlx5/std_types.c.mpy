{
  "module_name": "std_types.c",
  "hash_id": "f4463e1dd2fea054dbd9221236fd300b4c80120b7870750a6f083e23ddf2155a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/std_types.c",
  "human_readable_source": "\n \n\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/mlx5_user_ioctl_cmds.h>\n#include <rdma/mlx5_user_ioctl_verbs.h>\n#include <linux/mlx5/driver.h>\n#include <linux/mlx5/eswitch.h>\n#include <linux/mlx5/vport.h>\n#include \"mlx5_ib.h\"\n\n#define UVERBS_MODULE_NAME mlx5_ib\n#include <rdma/uverbs_named_ioctl.h>\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_PD_QUERY)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct ib_pd *pd =\n\t\tuverbs_attr_get_obj(attrs, MLX5_IB_ATTR_QUERY_PD_HANDLE);\n\tstruct mlx5_ib_pd *mpd = to_mpd(pd);\n\n\treturn uverbs_copy_to(attrs, MLX5_IB_ATTR_QUERY_PD_RESP_PDN,\n\t\t\t      &mpd->pdn, sizeof(mpd->pdn));\n}\n\nstatic int fill_vport_icm_addr(struct mlx5_core_dev *mdev, u16 vport,\n\t\t\t       struct mlx5_ib_uapi_query_port *info)\n{\n\tu32 out[MLX5_ST_SZ_DW(query_esw_vport_context_out)] = {};\n\tu32 in[MLX5_ST_SZ_DW(query_esw_vport_context_in)] = {};\n\tbool sw_owner_supp;\n\tu64 icm_rx;\n\tu64 icm_tx;\n\tint err;\n\n\tsw_owner_supp = MLX5_CAP_ESW_FLOWTABLE_FDB(mdev, sw_owner) ||\n\t\t\tMLX5_CAP_ESW_FLOWTABLE_FDB(mdev, sw_owner_v2);\n\n\tif (vport == MLX5_VPORT_UPLINK) {\n\t\ticm_rx = MLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\tsw_steering_uplink_icm_address_rx);\n\t\ticm_tx = MLX5_CAP64_ESW_FLOWTABLE(mdev,\n\t\t\tsw_steering_uplink_icm_address_tx);\n\t} else {\n\t\tMLX5_SET(query_esw_vport_context_in, in, opcode,\n\t\t\t MLX5_CMD_OP_QUERY_ESW_VPORT_CONTEXT);\n\t\tMLX5_SET(query_esw_vport_context_in, in, vport_number, vport);\n\t\tMLX5_SET(query_esw_vport_context_in, in, other_vport, true);\n\n\t\terr = mlx5_cmd_exec_inout(mdev, query_esw_vport_context, in,\n\t\t\t\t\t  out);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ticm_rx = MLX5_GET64(\n\t\t\tquery_esw_vport_context_out, out,\n\t\t\tesw_vport_context.sw_steering_vport_icm_address_rx);\n\n\t\ticm_tx = MLX5_GET64(\n\t\t\tquery_esw_vport_context_out, out,\n\t\t\tesw_vport_context.sw_steering_vport_icm_address_tx);\n\t}\n\n\tif (sw_owner_supp && icm_rx) {\n\t\tinfo->vport_steering_icm_rx = icm_rx;\n\t\tinfo->flags |=\n\t\t\tMLX5_IB_UAPI_QUERY_PORT_VPORT_STEERING_ICM_RX;\n\t}\n\n\tif (sw_owner_supp && icm_tx) {\n\t\tinfo->vport_steering_icm_tx = icm_tx;\n\t\tinfo->flags |=\n\t\t\tMLX5_IB_UAPI_QUERY_PORT_VPORT_STEERING_ICM_TX;\n\t}\n\n\treturn 0;\n}\n\nstatic int fill_vport_vhca_id(struct mlx5_core_dev *mdev, u16 vport,\n\t\t\t      struct mlx5_ib_uapi_query_port *info)\n{\n\tsize_t out_sz = MLX5_ST_SZ_BYTES(query_hca_cap_out);\n\tu32 in[MLX5_ST_SZ_DW(query_hca_cap_in)] = {};\n\tvoid *out;\n\tint err;\n\n\tout = kzalloc(out_sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\tMLX5_SET(query_hca_cap_in, in, opcode, MLX5_CMD_OP_QUERY_HCA_CAP);\n\tMLX5_SET(query_hca_cap_in, in, other_function, true);\n\tMLX5_SET(query_hca_cap_in, in, function_id, vport);\n\tMLX5_SET(query_hca_cap_in, in, op_mod,\n\t\t MLX5_SET_HCA_CAP_OP_MOD_GENERAL_DEVICE |\n\t\t HCA_CAP_OPMOD_GET_CUR);\n\n\terr = mlx5_cmd_exec(mdev, in, sizeof(in), out, out_sz);\n\tif (err)\n\t\tgoto out;\n\n\tinfo->vport_vhca_id = MLX5_GET(query_hca_cap_out, out,\n\t\t\t\t       capability.cmd_hca_cap.vhca_id);\n\n\tinfo->flags |= MLX5_IB_UAPI_QUERY_PORT_VPORT_VHCA_ID;\nout:\n\tkfree(out);\n\treturn err;\n}\n\nstatic int fill_switchdev_info(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t       struct mlx5_ib_uapi_query_port *info)\n{\n\tstruct mlx5_eswitch_rep *rep;\n\tstruct mlx5_core_dev *mdev;\n\tint err;\n\n\trep = dev->port[port_num - 1].rep;\n\tif (!rep)\n\t\treturn -EOPNOTSUPP;\n\n\tmdev = mlx5_eswitch_get_core_dev(rep->esw);\n\tif (!mdev)\n\t\treturn -EINVAL;\n\n\tinfo->vport = rep->vport;\n\tinfo->flags |= MLX5_IB_UAPI_QUERY_PORT_VPORT;\n\n\tif (rep->vport != MLX5_VPORT_UPLINK) {\n\t\terr = fill_vport_vhca_id(mdev, rep->vport, info);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tinfo->esw_owner_vhca_id = MLX5_CAP_GEN(mdev, vhca_id);\n\tinfo->flags |= MLX5_IB_UAPI_QUERY_PORT_ESW_OWNER_VHCA_ID;\n\n\terr = fill_vport_icm_addr(mdev, rep->vport, info);\n\tif (err)\n\t\treturn err;\n\n\tif (mlx5_eswitch_vport_match_metadata_enabled(rep->esw)) {\n\t\tinfo->reg_c0.value = mlx5_eswitch_get_vport_metadata_for_match(\n\t\t\trep->esw, rep->vport);\n\t\tinfo->reg_c0.mask = mlx5_eswitch_get_vport_metadata_mask();\n\t\tinfo->flags |= MLX5_IB_UAPI_QUERY_PORT_VPORT_REG_C0;\n\t}\n\n\treturn 0;\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_QUERY_PORT)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tstruct mlx5_ib_uapi_query_port info = {};\n\tstruct mlx5_ib_ucontext *c;\n\tstruct mlx5_ib_dev *dev;\n\tu32 port_num;\n\tint ret;\n\n\tif (uverbs_copy_from(&port_num, attrs,\n\t\t\t     MLX5_IB_ATTR_QUERY_PORT_PORT_NUM))\n\t\treturn -EFAULT;\n\n\tc = to_mucontext(ib_uverbs_get_ucontext(attrs));\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\tdev = to_mdev(c->ibucontext.device);\n\n\tif (!rdma_is_port_valid(&dev->ib_dev, port_num))\n\t\treturn -EINVAL;\n\n\tif (mlx5_eswitch_mode(dev->mdev) == MLX5_ESWITCH_OFFLOADS) {\n\t\tret = fill_switchdev_info(dev, port_num, &info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn uverbs_copy_to_struct_or_zero(attrs, MLX5_IB_ATTR_QUERY_PORT, &info,\n\t\t\t\t\t     sizeof(info));\n}\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_QUERY_PORT,\n\tUVERBS_ATTR_PTR_IN(MLX5_IB_ATTR_QUERY_PORT_PORT_NUM,\n\t\t\t   UVERBS_ATTR_TYPE(u32), UA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(\n\t\tMLX5_IB_ATTR_QUERY_PORT,\n\t\tUVERBS_ATTR_STRUCT(struct mlx5_ib_uapi_query_port,\n\t\t\t\t   reg_c0),\n\t\tUA_MANDATORY));\n\nADD_UVERBS_METHODS(mlx5_ib_device,\n\t\t   UVERBS_OBJECT_DEVICE,\n\t\t   &UVERBS_METHOD(MLX5_IB_METHOD_QUERY_PORT));\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_PD_QUERY,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_QUERY_PD_HANDLE,\n\t\t\tUVERBS_OBJECT_PD,\n\t\t\tUVERBS_ACCESS_READ,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_QUERY_PD_RESP_PDN,\n\t\t\t   UVERBS_ATTR_TYPE(u32),\n\t\t\t   UA_MANDATORY));\n\nADD_UVERBS_METHODS(mlx5_ib_pd,\n\t\t   UVERBS_OBJECT_PD,\n\t\t   &UVERBS_METHOD(MLX5_IB_METHOD_PD_QUERY));\n\nconst struct uapi_definition mlx5_ib_std_types_defs[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE(\n\t\tUVERBS_OBJECT_PD,\n\t\t&mlx5_ib_pd),\n\tUAPI_DEF_CHAIN_OBJ_TREE(\n\t\tUVERBS_OBJECT_DEVICE,\n\t\t&mlx5_ib_device),\n\t{},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}