{
  "module_name": "doorbell.c",
  "hash_id": "bb56670a1bf6f6ce21b77bd14b82567a822e712d4c5ace835703e0a510bf0514",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/doorbell.c",
  "human_readable_source": " \n\n#include <linux/kref.h>\n#include <linux/slab.h>\n#include <linux/sched/mm.h>\n#include <rdma/ib_umem.h>\n\n#include \"mlx5_ib.h\"\n\nstruct mlx5_ib_user_db_page {\n\tstruct list_head\tlist;\n\tstruct ib_umem\t       *umem;\n\tunsigned long\t\tuser_virt;\n\tint\t\t\trefcnt;\n\tstruct mm_struct\t*mm;\n};\n\nint mlx5_ib_db_map_user(struct mlx5_ib_ucontext *context, unsigned long virt,\n\t\t\tstruct mlx5_db *db)\n{\n\tstruct mlx5_ib_user_db_page *page;\n\tint err = 0;\n\n\tmutex_lock(&context->db_page_mutex);\n\n\tlist_for_each_entry(page, &context->db_page_list, list)\n\t\tif ((current->mm == page->mm) &&\n\t\t    (page->user_virt == (virt & PAGE_MASK)))\n\t\t\tgoto found;\n\n\tpage = kmalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpage->user_virt = (virt & PAGE_MASK);\n\tpage->refcnt    = 0;\n\tpage->umem = ib_umem_get(context->ibucontext.device, virt & PAGE_MASK,\n\t\t\t\t PAGE_SIZE, 0);\n\tif (IS_ERR(page->umem)) {\n\t\terr = PTR_ERR(page->umem);\n\t\tkfree(page);\n\t\tgoto out;\n\t}\n\tmmgrab(current->mm);\n\tpage->mm = current->mm;\n\n\tlist_add(&page->list, &context->db_page_list);\n\nfound:\n\tdb->dma = sg_dma_address(page->umem->sgt_append.sgt.sgl) +\n\t\t  (virt & ~PAGE_MASK);\n\tdb->u.user_page = page;\n\t++page->refcnt;\n\nout:\n\tmutex_unlock(&context->db_page_mutex);\n\n\treturn err;\n}\n\nvoid mlx5_ib_db_unmap_user(struct mlx5_ib_ucontext *context, struct mlx5_db *db)\n{\n\tmutex_lock(&context->db_page_mutex);\n\n\tif (!--db->u.user_page->refcnt) {\n\t\tlist_del(&db->u.user_page->list);\n\t\tmmdrop(db->u.user_page->mm);\n\t\tib_umem_release(db->u.user_page->umem);\n\t\tkfree(db->u.user_page);\n\t}\n\n\tmutex_unlock(&context->db_page_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}