{
  "module_name": "mad.c",
  "hash_id": "8092cdfc5280bbd92d4f24c4588d1136357bb90d8da1b0e2b9a4ef0db023c3af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/mad.c",
  "human_readable_source": " \n\n#include <linux/mlx5/vport.h>\n#include <rdma/ib_mad.h>\n#include <rdma/ib_smi.h>\n#include <rdma/ib_pma.h>\n#include \"mlx5_ib.h\"\n#include \"cmd.h\"\n\nenum {\n\tMLX5_IB_VENDOR_CLASS1 = 0x9,\n\tMLX5_IB_VENDOR_CLASS2 = 0xa\n};\n\nstatic bool can_do_mad_ifc(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t   struct ib_mad *in_mad)\n{\n\tif (in_mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_SUBN_LID_ROUTED &&\n\t    in_mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\treturn true;\n\treturn dev->port_caps[port_num - 1].has_smi;\n}\n\nstatic int mlx5_MAD_IFC(struct mlx5_ib_dev *dev, int ignore_mkey,\n\t\t\tint ignore_bkey, u32 port, const struct ib_wc *in_wc,\n\t\t\tconst struct ib_grh *in_grh, const void *in_mad,\n\t\t\tvoid *response_mad)\n{\n\tu8 op_modifier = 0;\n\n\tif (!can_do_mad_ifc(dev, port, (struct ib_mad *)in_mad))\n\t\treturn -EPERM;\n\n\t \n\tif (ignore_mkey || !in_wc)\n\t\top_modifier |= 0x1;\n\tif (ignore_bkey || !in_wc)\n\t\top_modifier |= 0x2;\n\n\treturn mlx5_cmd_mad_ifc(dev->mdev, in_mad, response_mad, op_modifier,\n\t\t\t\tport);\n}\n\nstatic void pma_cnt_ext_assign(struct ib_pma_portcounters_ext *pma_cnt_ext,\n\t\t\t       void *out)\n{\n#define MLX5_SUM_CNT(p, cntr1, cntr2)\t\\\n\t(MLX5_GET64(query_vport_counter_out, p, cntr1) + \\\n\tMLX5_GET64(query_vport_counter_out, p, cntr2))\n\n\tpma_cnt_ext->port_xmit_data =\n\t\tcpu_to_be64(MLX5_SUM_CNT(out, transmitted_ib_unicast.octets,\n\t\t\t\t\t transmitted_ib_multicast.octets) >> 2);\n\tpma_cnt_ext->port_rcv_data =\n\t\tcpu_to_be64(MLX5_SUM_CNT(out, received_ib_unicast.octets,\n\t\t\t\t\t received_ib_multicast.octets) >> 2);\n\tpma_cnt_ext->port_xmit_packets =\n\t\tcpu_to_be64(MLX5_SUM_CNT(out, transmitted_ib_unicast.packets,\n\t\t\t\t\t transmitted_ib_multicast.packets));\n\tpma_cnt_ext->port_rcv_packets =\n\t\tcpu_to_be64(MLX5_SUM_CNT(out, received_ib_unicast.packets,\n\t\t\t\t\t received_ib_multicast.packets));\n\tpma_cnt_ext->port_unicast_xmit_packets =\n\t\tMLX5_GET64_BE(query_vport_counter_out,\n\t\t\t      out, transmitted_ib_unicast.packets);\n\tpma_cnt_ext->port_unicast_rcv_packets =\n\t\tMLX5_GET64_BE(query_vport_counter_out,\n\t\t\t      out, received_ib_unicast.packets);\n\tpma_cnt_ext->port_multicast_xmit_packets =\n\t\tMLX5_GET64_BE(query_vport_counter_out,\n\t\t\t      out, transmitted_ib_multicast.packets);\n\tpma_cnt_ext->port_multicast_rcv_packets =\n\t\tMLX5_GET64_BE(query_vport_counter_out,\n\t\t\t      out, received_ib_multicast.packets);\n}\n\nstatic void pma_cnt_assign(struct ib_pma_portcounters *pma_cnt,\n\t\t\t   void *out)\n{\n\t \n\tvoid *out_pma = MLX5_ADDR_OF(ppcnt_reg, out,\n\t\t\t\t     counter_set);\n\n#define MLX5_ASSIGN_PMA_CNTR(counter_var, counter_name)\t{\t\t\\\n\tcounter_var = MLX5_GET_BE(typeof(counter_var),\t\t\t\\\n\t\t\t\t  ib_port_cntrs_grp_data_layout,\t\\\n\t\t\t\t  out_pma, counter_name);\t\t\\\n\t}\n\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->symbol_error_counter,\n\t\t\t     symbol_error_counter);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->link_error_recovery_counter,\n\t\t\t     link_error_recovery_counter);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->link_downed_counter,\n\t\t\t     link_downed_counter);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_rcv_errors,\n\t\t\t     port_rcv_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_rcv_remphys_errors,\n\t\t\t     port_rcv_remote_physical_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_rcv_switch_relay_errors,\n\t\t\t     port_rcv_switch_relay_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_xmit_discards,\n\t\t\t     port_xmit_discards);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_xmit_constraint_errors,\n\t\t\t     port_xmit_constraint_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_xmit_wait,\n\t\t\t     port_xmit_wait);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->port_rcv_constraint_errors,\n\t\t\t     port_rcv_constraint_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->link_overrun_errors,\n\t\t\t     link_overrun_errors);\n\tMLX5_ASSIGN_PMA_CNTR(pma_cnt->vl15_dropped,\n\t\t\t     vl_15_dropped);\n}\n\nstatic int query_ib_ppcnt(struct mlx5_core_dev *dev, u8 port_num, void *out,\n\t\t\t  size_t sz)\n{\n\tu32 *in;\n\tint err;\n\n\tin  = kvzalloc(sz, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\treturn err;\n\t}\n\n\tMLX5_SET(ppcnt_reg, in, local_port, port_num);\n\n\tMLX5_SET(ppcnt_reg, in, grp, MLX5_INFINIBAND_PORT_COUNTERS_GROUP);\n\terr = mlx5_core_access_reg(dev, in, sz, out,\n\t\t\t\t   sz, MLX5_REG_PPCNT, 0, 0);\n\n\tkvfree(in);\n\treturn err;\n}\n\nstatic int process_pma_cmd(struct mlx5_ib_dev *dev, u32 port_num,\n\t\t\t   const struct ib_mad *in_mad, struct ib_mad *out_mad)\n{\n\tstruct mlx5_core_dev *mdev;\n\tbool native_port = true;\n\tu32 mdev_port_num;\n\tvoid *out_cnt;\n\tint err;\n\n\tmdev = mlx5_ib_get_native_port_mdev(dev, port_num, &mdev_port_num);\n\tif (!mdev) {\n\t\t \n\t\tnative_port = false;\n\t\tmdev = dev->mdev;\n\t\tmdev_port_num = 1;\n\t}\n\tif (MLX5_CAP_GEN(dev->mdev, num_ports) == 1) {\n\t\t \n\t\tmdev = dev->mdev;\n\t\tmdev_port_num = 1;\n\t}\n\n\t \n\tif (in_mad->mad_hdr.attr_id == IB_PMA_CLASS_PORT_INFO) {\n\t\tstruct ib_class_port_info cpi = {};\n\n\t\tcpi.capability_mask = IB_PMA_CLASS_CAP_EXT_WIDTH;\n\t\tmemcpy((out_mad->data + 40), &cpi, sizeof(cpi));\n\t\terr = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n\t\tgoto done;\n\t}\n\n\tif (in_mad->mad_hdr.attr_id == IB_PMA_PORT_COUNTERS_EXT) {\n\t\tstruct ib_pma_portcounters_ext *pma_cnt_ext =\n\t\t\t(struct ib_pma_portcounters_ext *)(out_mad->data + 40);\n\t\tint sz = MLX5_ST_SZ_BYTES(query_vport_counter_out);\n\n\t\tout_cnt = kvzalloc(sz, GFP_KERNEL);\n\t\tif (!out_cnt) {\n\t\t\terr = IB_MAD_RESULT_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\terr = mlx5_core_query_vport_counter(mdev, 0, 0, mdev_port_num,\n\t\t\t\t\t\t    out_cnt);\n\t\tif (!err)\n\t\t\tpma_cnt_ext_assign(pma_cnt_ext, out_cnt);\n\t} else {\n\t\tstruct ib_pma_portcounters *pma_cnt =\n\t\t\t(struct ib_pma_portcounters *)(out_mad->data + 40);\n\t\tint sz = MLX5_ST_SZ_BYTES(ppcnt_reg);\n\n\t\tout_cnt = kvzalloc(sz, GFP_KERNEL);\n\t\tif (!out_cnt) {\n\t\t\terr = IB_MAD_RESULT_FAILURE;\n\t\t\tgoto done;\n\t\t}\n\n\t\terr = query_ib_ppcnt(mdev, mdev_port_num, out_cnt, sz);\n\t\tif (!err)\n\t\t\tpma_cnt_assign(pma_cnt, out_cnt);\n\t}\n\tkvfree(out_cnt);\n\terr = err ? IB_MAD_RESULT_FAILURE :\n\t\t    IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\ndone:\n\tif (native_port)\n\t\tmlx5_ib_put_native_port_mdev(dev, port_num);\n\treturn err;\n}\n\nint mlx5_ib_process_mad(struct ib_device *ibdev, int mad_flags, u32 port_num,\n\t\t\tconst struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t\tconst struct ib_mad *in, struct ib_mad *out,\n\t\t\tsize_t *out_mad_size, u16 *out_mad_pkey_index)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tu8 mgmt_class = in->mad_hdr.mgmt_class;\n\tu8 method = in->mad_hdr.method;\n\tu16 slid;\n\tint err;\n\n\tslid = in_wc ? ib_lid_cpu16(in_wc->slid) :\n\t\t       be16_to_cpu(IB_LID_PERMISSIVE);\n\n\tif (method == IB_MGMT_METHOD_TRAP && !slid)\n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\n\tswitch (mgmt_class) {\n\tcase IB_MGMT_CLASS_SUBN_LID_ROUTED:\n\tcase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE: {\n\t\tif (method != IB_MGMT_METHOD_GET &&\n\t\t    method != IB_MGMT_METHOD_SET &&\n\t\t    method != IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\n\t\t \n\t\tif (in->mad_hdr.attr_id == IB_SMP_ATTR_SM_INFO)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} break;\n\tcase IB_MGMT_CLASS_PERF_MGMT:\n\t\tif (MLX5_CAP_GEN(dev->mdev, vport_counters) &&\n\t\t    method == IB_MGMT_METHOD_GET)\n\t\t\treturn process_pma_cmd(dev, port_num, in, out);\n\t\tfallthrough;\n\tcase MLX5_IB_VENDOR_CLASS1:\n\tcase MLX5_IB_VENDOR_CLASS2:\n\tcase IB_MGMT_CLASS_CONG_MGMT: {\n\t\tif (method != IB_MGMT_METHOD_GET &&\n\t\t    method != IB_MGMT_METHOD_SET)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} break;\n\tdefault:\n\t\treturn IB_MAD_RESULT_SUCCESS;\n\t}\n\n\terr = mlx5_MAD_IFC(to_mdev(ibdev), mad_flags & IB_MAD_IGNORE_MKEY,\n\t\t\t   mad_flags & IB_MAD_IGNORE_BKEY, port_num, in_wc,\n\t\t\t   in_grh, in, out);\n\tif (err)\n\t\treturn IB_MAD_RESULT_FAILURE;\n\n\t \n\tif (mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\tout->mad_hdr.status |= cpu_to_be16(1 << 15);\n\n\tif (method == IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t \n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n}\n\nint mlx5_query_ext_port_caps(struct mlx5_ib_dev *dev, unsigned int port)\n{\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint err = -ENOMEM;\n\tu16 packet_error;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id = MLX5_ATTR_EXTENDED_PORT_INFO;\n\tin_mad->attr_mod = cpu_to_be32(port);\n\n\terr = mlx5_MAD_IFC(dev, 1, 1, 1, NULL, NULL, in_mad, out_mad);\n\n\tpacket_error = be16_to_cpu(out_mad->status);\n\n\tdev->port_caps[port - 1].ext_port_cap = (!err && !packet_error) ?\n\t\tMLX_EXT_PORT_CAP_FLAG_EXTENDED_PORT_INFO : 0;\n\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn err;\n}\n\nstatic int mlx5_query_mad_ifc_smp_attr_node_info(struct ib_device *ibdev,\n\t\t\t\t\t\t struct ib_smp *out_mad)\n{\n\tstruct ib_smp *in_mad;\n\tint err;\n\n\tin_mad = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tif (!in_mad)\n\t\treturn -ENOMEM;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id = IB_SMP_ATTR_NODE_INFO;\n\n\terr = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, 1, NULL, NULL, in_mad,\n\t\t\t   out_mad);\n\n\tkfree(in_mad);\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_system_image_guid(struct ib_device *ibdev,\n\t\t\t\t\t __be64 *sys_image_guid)\n{\n\tstruct ib_smp *out_mad;\n\tint err;\n\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!out_mad)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(sys_image_guid, out_mad->data + 4, 8);\n\nout:\n\tkfree(out_mad);\n\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_max_pkeys(struct ib_device *ibdev,\n\t\t\t\t u16 *max_pkeys)\n{\n\tstruct ib_smp *out_mad;\n\tint err;\n\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!out_mad)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);\n\tif (err)\n\t\tgoto out;\n\n\t*max_pkeys = be16_to_cpup((__be16 *)(out_mad->data + 28));\n\nout:\n\tkfree(out_mad);\n\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_vendor_id(struct ib_device *ibdev,\n\t\t\t\t u32 *vendor_id)\n{\n\tstruct ib_smp *out_mad;\n\tint err;\n\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!out_mad)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_mad_ifc_smp_attr_node_info(ibdev, out_mad);\n\tif (err)\n\t\tgoto out;\n\n\t*vendor_id = be32_to_cpup((__be32 *)(out_mad->data + 36)) & 0xffff;\n\nout:\n\tkfree(out_mad);\n\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_node_desc(struct mlx5_ib_dev *dev, char *node_desc)\n{\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint err = -ENOMEM;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id = IB_SMP_ATTR_NODE_DESC;\n\n\terr = mlx5_MAD_IFC(dev, 1, 1, 1, NULL, NULL, in_mad, out_mad);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(node_desc, out_mad->data, IB_DEVICE_NODE_DESC_MAX);\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_node_guid(struct mlx5_ib_dev *dev, __be64 *node_guid)\n{\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint err = -ENOMEM;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id = IB_SMP_ATTR_NODE_INFO;\n\n\terr = mlx5_MAD_IFC(dev, 1, 1, 1, NULL, NULL, in_mad, out_mad);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(node_guid, out_mad->data + 12, 8);\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_pkey(struct ib_device *ibdev, u32 port, u16 index,\n\t\t\t    u16 *pkey)\n{\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint err = -ENOMEM;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id  = IB_SMP_ATTR_PKEY_TABLE;\n\tin_mad->attr_mod = cpu_to_be32(index / 32);\n\n\terr = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,\n\t\t\t   out_mad);\n\tif (err)\n\t\tgoto out;\n\n\t*pkey = be16_to_cpu(((__be16 *)out_mad->data)[index % 32]);\n\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_gids(struct ib_device *ibdev, u32 port, int index,\n\t\t\t    union ib_gid *gid)\n{\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint err = -ENOMEM;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id  = IB_SMP_ATTR_PORT_INFO;\n\tin_mad->attr_mod = cpu_to_be32(port);\n\n\terr = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,\n\t\t\t   out_mad);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(gid->raw, out_mad->data + 8, 8);\n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id  = IB_SMP_ATTR_GUID_INFO;\n\tin_mad->attr_mod = cpu_to_be32(index / 8);\n\n\terr = mlx5_MAD_IFC(to_mdev(ibdev), 1, 1, port, NULL, NULL, in_mad,\n\t\t\t   out_mad);\n\tif (err)\n\t\tgoto out;\n\n\tmemcpy(gid->raw + 8, out_mad->data + (index % 8) * 8, 8);\n\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\treturn err;\n}\n\nint mlx5_query_mad_ifc_port(struct ib_device *ibdev, u32 port,\n\t\t\t    struct ib_port_attr *props)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct ib_smp *in_mad;\n\tstruct ib_smp *out_mad;\n\tint ext_active_speed;\n\tint err = -ENOMEM;\n\n\tin_mad  = kzalloc(sizeof(*in_mad), GFP_KERNEL);\n\tout_mad = kmalloc(sizeof(*out_mad), GFP_KERNEL);\n\tif (!in_mad || !out_mad)\n\t\tgoto out;\n\n\t \n\n\tib_init_query_mad(in_mad);\n\tin_mad->attr_id  = IB_SMP_ATTR_PORT_INFO;\n\tin_mad->attr_mod = cpu_to_be32(port);\n\n\terr = mlx5_MAD_IFC(dev, 1, 1, port, NULL, NULL, in_mad, out_mad);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"err %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tprops->lid\t\t= be16_to_cpup((__be16 *)(out_mad->data + 16));\n\tprops->lmc\t\t= out_mad->data[34] & 0x7;\n\tprops->sm_lid\t\t= be16_to_cpup((__be16 *)(out_mad->data + 18));\n\tprops->sm_sl\t\t= out_mad->data[36] & 0xf;\n\tprops->state\t\t= out_mad->data[32] & 0xf;\n\tprops->phys_state\t= out_mad->data[33] >> 4;\n\tprops->port_cap_flags\t= be32_to_cpup((__be32 *)(out_mad->data + 20));\n\tprops->gid_tbl_len\t= out_mad->data[50];\n\tprops->max_msg_sz\t= 1 << MLX5_CAP_GEN(mdev, log_max_msg);\n\tprops->pkey_tbl_len\t= dev->pkey_table_len;\n\tprops->bad_pkey_cntr\t= be16_to_cpup((__be16 *)(out_mad->data + 46));\n\tprops->qkey_viol_cntr\t= be16_to_cpup((__be16 *)(out_mad->data + 48));\n\tprops->active_width\t= out_mad->data[31] & 0xf;\n\tprops->active_speed\t= out_mad->data[35] >> 4;\n\tprops->max_mtu\t\t= out_mad->data[41] & 0xf;\n\tprops->active_mtu\t= out_mad->data[36] >> 4;\n\tprops->subnet_timeout\t= out_mad->data[51] & 0x1f;\n\tprops->max_vl_num\t= out_mad->data[37] >> 4;\n\tprops->init_type_reply\t= out_mad->data[41] >> 4;\n\n\tif (props->port_cap_flags & IB_PORT_CAP_MASK2_SUP) {\n\t\tprops->port_cap_flags2 =\n\t\t\tbe16_to_cpup((__be16 *)(out_mad->data + 60));\n\n\t\tif (props->port_cap_flags2 & IB_PORT_LINK_WIDTH_2X_SUP)\n\t\t\tprops->active_width = out_mad->data[31] & 0x1f;\n\t}\n\n\t \n\tif (props->port_cap_flags & IB_PORT_EXTENDED_SPEEDS_SUP) {\n\t\text_active_speed = out_mad->data[62] >> 4;\n\n\t\tswitch (ext_active_speed) {\n\t\tcase 1:\n\t\t\tprops->active_speed = 16;  \n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprops->active_speed = 32;  \n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (props->port_cap_flags & IB_PORT_CAP_MASK2_SUP &&\n\t\t\t    props->port_cap_flags2 & IB_PORT_LINK_SPEED_HDR_SUP)\n\t\t\t\tprops->active_speed = IB_SPEED_HDR;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (props->port_cap_flags & IB_PORT_CAP_MASK2_SUP &&\n\t\t\t    props->port_cap_flags2 & IB_PORT_LINK_SPEED_NDR_SUP)\n\t\t\t\tprops->active_speed = IB_SPEED_NDR;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (props->active_speed == 4) {\n\t\tif (dev->port_caps[port - 1].ext_port_cap &\n\t\t    MLX_EXT_PORT_CAP_FLAG_EXTENDED_PORT_INFO) {\n\t\t\tib_init_query_mad(in_mad);\n\t\t\tin_mad->attr_id = MLX5_ATTR_EXTENDED_PORT_INFO;\n\t\t\tin_mad->attr_mod = cpu_to_be32(port);\n\n\t\t\terr = mlx5_MAD_IFC(dev, 1, 1, port,\n\t\t\t\t\t   NULL, NULL, in_mad, out_mad);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tif (out_mad->data[15] & 0x1)\n\t\t\t\tprops->active_speed = 8;\n\t\t}\n\t}\n\nout:\n\tkfree(in_mad);\n\tkfree(out_mad);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}