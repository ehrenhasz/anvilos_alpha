{
  "module_name": "restrack.c",
  "hash_id": "1b9a427485d847f63aab0cf7b95706665afeca18741027d0ffcb72fbbe3018e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/restrack.c",
  "human_readable_source": "\n \n\n#include <uapi/rdma/rdma_netlink.h>\n#include <linux/mlx5/rsc_dump.h>\n#include <rdma/ib_umem_odp.h>\n#include <rdma/restrack.h>\n#include \"mlx5_ib.h\"\n#include \"restrack.h\"\n\n#define MAX_DUMP_SIZE 1024\n\nstatic int dump_rsc(struct mlx5_core_dev *dev, enum mlx5_sgmt_type type,\n\t\t    int index, void *data, int *data_len)\n{\n\tstruct mlx5_core_dev *mdev = dev;\n\tstruct mlx5_rsc_dump_cmd *cmd;\n\tstruct mlx5_rsc_key key = {};\n\tstruct page *page;\n\tint offset = 0;\n\tint err = 0;\n\tint cmd_err;\n\tint size;\n\n\tpage = alloc_page(GFP_KERNEL);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tkey.size = PAGE_SIZE;\n\tkey.rsc = type;\n\tkey.index1 = index;\n\tkey.num_of_obj1 = 1;\n\n\tcmd = mlx5_rsc_dump_cmd_create(mdev, &key);\n\tif (IS_ERR(cmd)) {\n\t\terr = PTR_ERR(cmd);\n\t\tgoto free_page;\n\t}\n\n\tdo {\n\t\tcmd_err = mlx5_rsc_dump_next(mdev, cmd, page, &size);\n\t\tif (cmd_err < 0 || size + offset > MAX_DUMP_SIZE) {\n\t\t\terr = cmd_err;\n\t\t\tgoto destroy_cmd;\n\t\t}\n\t\tmemcpy(data + offset, page_address(page), size);\n\t\toffset += size;\n\t} while (cmd_err > 0);\n\t*data_len = offset;\n\ndestroy_cmd:\n\tmlx5_rsc_dump_cmd_destroy(cmd);\nfree_page:\n\t__free_page(page);\n\treturn err;\n}\n\nstatic int fill_res_raw(struct sk_buff *msg, struct mlx5_ib_dev *dev,\n\t\t\tenum mlx5_sgmt_type type, u32 key)\n{\n\tint len = 0;\n\tvoid *data;\n\tint err;\n\n\tdata = kzalloc(MAX_DUMP_SIZE, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\terr = dump_rsc(dev->mdev, type, key, data, &len);\n\tif (err)\n\t\tgoto out;\n\n\terr = nla_put(msg, RDMA_NLDEV_ATTR_RES_RAW, len, data);\nout:\n\tkfree(data);\n\treturn err;\n}\n\nstatic int fill_stat_mr_entry(struct sk_buff *msg, struct ib_mr *ibmr)\n{\n\tstruct mlx5_ib_mr *mr = to_mmr(ibmr);\n\tstruct nlattr *table_attr;\n\n\tif (!(mr->access_flags & IB_ACCESS_ON_DEMAND))\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start(msg,\n\t\t\t\t    RDMA_NLDEV_ATTR_STAT_HWCOUNTERS);\n\n\tif (!table_attr)\n\t\tgoto err;\n\n\tif (rdma_nl_stat_hwcounter_entry(msg, \"page_faults\",\n\t\t\t\t\t atomic64_read(&mr->odp_stats.faults)))\n\t\tgoto err_table;\n\tif (rdma_nl_stat_hwcounter_entry(\n\t\t    msg, \"page_invalidations\",\n\t\t    atomic64_read(&mr->odp_stats.invalidations)))\n\t\tgoto err_table;\n\tif (rdma_nl_stat_hwcounter_entry(msg, \"page_prefetch\",\n\t\t\t\t\t atomic64_read(&mr->odp_stats.prefetch)))\n\t\tgoto err_table;\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr_table:\n\tnla_nest_cancel(msg, table_attr);\nerr:\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_mr_entry_raw(struct sk_buff *msg, struct ib_mr *ibmr)\n{\n\tstruct mlx5_ib_mr *mr = to_mmr(ibmr);\n\n\treturn fill_res_raw(msg, mr_to_mdev(mr), MLX5_SGMT_TYPE_PRM_QUERY_MKEY,\n\t\t\t    mlx5_mkey_to_idx(mr->mmkey.key));\n}\n\nstatic int fill_res_mr_entry(struct sk_buff *msg, struct ib_mr *ibmr)\n{\n\tstruct mlx5_ib_mr *mr = to_mmr(ibmr);\n\tstruct nlattr *table_attr;\n\n\tif (!(mr->access_flags & IB_ACCESS_ON_DEMAND))\n\t\treturn 0;\n\n\ttable_attr = nla_nest_start(msg, RDMA_NLDEV_ATTR_DRIVER);\n\tif (!table_attr)\n\t\tgoto err;\n\n\tif (mr->is_odp_implicit) {\n\t\tif (rdma_nl_put_driver_string(msg, \"odp\", \"implicit\"))\n\t\t\tgoto err;\n\t} else {\n\t\tif (rdma_nl_put_driver_string(msg, \"odp\", \"explicit\"))\n\t\t\tgoto err;\n\t}\n\n\tnla_nest_end(msg, table_attr);\n\treturn 0;\n\nerr:\n\tnla_nest_cancel(msg, table_attr);\n\treturn -EMSGSIZE;\n}\n\nstatic int fill_res_cq_entry_raw(struct sk_buff *msg, struct ib_cq *ibcq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibcq->device);\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\n\treturn fill_res_raw(msg, dev, MLX5_SGMT_TYPE_PRM_QUERY_CQ, cq->mcq.cqn);\n}\n\nstatic int fill_res_qp_entry_raw(struct sk_buff *msg, struct ib_qp *ibqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibqp->device);\n\n\treturn fill_res_raw(msg, dev, MLX5_SGMT_TYPE_PRM_QUERY_QP,\n\t\t\t    ibqp->qp_num);\n}\n\nstatic const struct ib_device_ops restrack_ops = {\n\t.fill_res_cq_entry_raw = fill_res_cq_entry_raw,\n\t.fill_res_mr_entry = fill_res_mr_entry,\n\t.fill_res_mr_entry_raw = fill_res_mr_entry_raw,\n\t.fill_res_qp_entry_raw = fill_res_qp_entry_raw,\n\t.fill_stat_mr_entry = fill_stat_mr_entry,\n};\n\nint mlx5_ib_restrack_init(struct mlx5_ib_dev *dev)\n{\n\tib_set_device_ops(&dev->ib_dev, &restrack_ops);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}