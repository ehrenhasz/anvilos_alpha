{
  "module_name": "macsec.c",
  "hash_id": "c3a810aa6a171d0613590a9a259145ec3ea6e1b5ef2cc5a5aa670264a77c0735",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/macsec.c",
  "human_readable_source": "\n \n\n#include \"macsec.h\"\n#include <linux/mlx5/macsec.h>\n\nstruct mlx5_reserved_gids {\n\tint macsec_index;\n\tconst struct ib_gid_attr *physical_gid;\n};\n\nstruct mlx5_roce_gids {\n\tstruct list_head roce_gid_list_entry;\n\tu16 gid_idx;\n\tunion {\n\t\tstruct sockaddr_in  sockaddr_in;\n\t\tstruct sockaddr_in6 sockaddr_in6;\n\t} addr;\n};\n\nstruct mlx5_macsec_device {\n\tstruct list_head macsec_devices_list_entry;\n\tvoid *macdev;\n\tstruct list_head macsec_roce_gids;\n\tstruct list_head tx_rules_list;\n\tstruct list_head rx_rules_list;\n};\n\nstatic void cleanup_macsec_device(struct mlx5_macsec_device *macsec_device)\n{\n\tif (!list_empty(&macsec_device->tx_rules_list) ||\n\t    !list_empty(&macsec_device->rx_rules_list) ||\n\t    !list_empty(&macsec_device->macsec_roce_gids))\n\t\treturn;\n\n\tlist_del(&macsec_device->macsec_devices_list_entry);\n\tkfree(macsec_device);\n}\n\nstatic struct mlx5_macsec_device *get_macsec_device(void *macdev,\n\t\t\t\t\t\t    struct list_head *macsec_devices_list)\n{\n\tstruct mlx5_macsec_device *iter, *macsec_device = NULL;\n\n\tlist_for_each_entry(iter, macsec_devices_list, macsec_devices_list_entry) {\n\t\tif (iter->macdev == macdev) {\n\t\t\tmacsec_device = iter;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (macsec_device)\n\t\treturn macsec_device;\n\n\tmacsec_device = kzalloc(sizeof(*macsec_device), GFP_KERNEL);\n\tif (!macsec_device)\n\t\treturn NULL;\n\n\tmacsec_device->macdev = macdev;\n\tINIT_LIST_HEAD(&macsec_device->tx_rules_list);\n\tINIT_LIST_HEAD(&macsec_device->rx_rules_list);\n\tINIT_LIST_HEAD(&macsec_device->macsec_roce_gids);\n\tlist_add(&macsec_device->macsec_devices_list_entry, macsec_devices_list);\n\n\treturn macsec_device;\n}\n\nstatic void mlx5_macsec_del_roce_gid(struct mlx5_macsec_device *macsec_device, u16 gid_idx)\n{\n\tstruct mlx5_roce_gids *current_gid, *next_gid;\n\n\tlist_for_each_entry_safe(current_gid, next_gid, &macsec_device->macsec_roce_gids,\n\t\t\t\t roce_gid_list_entry)\n\t\tif (current_gid->gid_idx == gid_idx) {\n\t\t\tlist_del(&current_gid->roce_gid_list_entry);\n\t\t\tkfree(current_gid);\n\t\t}\n}\n\nstatic void mlx5_macsec_save_roce_gid(struct mlx5_macsec_device *macsec_device,\n\t\t\t\t      const struct sockaddr *addr, u16 gid_idx)\n{\n\tstruct mlx5_roce_gids *roce_gids;\n\n\troce_gids = kzalloc(sizeof(*roce_gids), GFP_KERNEL);\n\tif (!roce_gids)\n\t\treturn;\n\n\troce_gids->gid_idx = gid_idx;\n\tif (addr->sa_family == AF_INET)\n\t\tmemcpy(&roce_gids->addr.sockaddr_in, addr, sizeof(roce_gids->addr.sockaddr_in));\n\telse\n\t\tmemcpy(&roce_gids->addr.sockaddr_in6, addr, sizeof(roce_gids->addr.sockaddr_in6));\n\n\tlist_add_tail(&roce_gids->roce_gid_list_entry, &macsec_device->macsec_roce_gids);\n}\n\nstatic void handle_macsec_gids(struct list_head *macsec_devices_list,\n\t\t\t       struct mlx5_macsec_event_data *data)\n{\n\tstruct mlx5_macsec_device *macsec_device;\n\tstruct mlx5_roce_gids *gid;\n\n\tmacsec_device = get_macsec_device(data->macdev, macsec_devices_list);\n\tif (!macsec_device)\n\t\treturn;\n\n\tlist_for_each_entry(gid, &macsec_device->macsec_roce_gids, roce_gid_list_entry) {\n\t\tmlx5_macsec_add_roce_sa_rules(data->fs_id, (struct sockaddr *)&gid->addr,\n\t\t\t\t\t      gid->gid_idx, &macsec_device->tx_rules_list,\n\t\t\t\t\t      &macsec_device->rx_rules_list, data->macsec_fs,\n\t\t\t\t\t      data->is_tx);\n\t}\n}\n\nstatic void del_sa_roce_rule(struct list_head *macsec_devices_list,\n\t\t\t     struct mlx5_macsec_event_data *data)\n{\n\tstruct mlx5_macsec_device *macsec_device;\n\n\tmacsec_device = get_macsec_device(data->macdev, macsec_devices_list);\n\tWARN_ON(!macsec_device);\n\n\tmlx5_macsec_del_roce_sa_rules(data->fs_id, data->macsec_fs,\n\t\t\t\t      &macsec_device->tx_rules_list,\n\t\t\t\t      &macsec_device->rx_rules_list, data->is_tx);\n}\n\nstatic int macsec_event(struct notifier_block *nb, unsigned long event, void *data)\n{\n\tstruct mlx5_macsec *macsec = container_of(nb, struct mlx5_macsec, blocking_events_nb);\n\n\tmutex_lock(&macsec->lock);\n\tswitch (event) {\n\tcase MLX5_DRIVER_EVENT_MACSEC_SA_ADDED:\n\t\thandle_macsec_gids(&macsec->macsec_devices_list, data);\n\t\tbreak;\n\tcase MLX5_DRIVER_EVENT_MACSEC_SA_DELETED:\n\t\tdel_sa_roce_rule(&macsec->macsec_devices_list, data);\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&macsec->lock);\n\t\treturn NOTIFY_DONE;\n\t}\n\tmutex_unlock(&macsec->lock);\n\treturn NOTIFY_OK;\n}\n\nvoid mlx5r_macsec_event_register(struct mlx5_ib_dev *dev)\n{\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\t\treturn;\n\t}\n\n\tdev->macsec.blocking_events_nb.notifier_call = macsec_event;\n\tblocking_notifier_chain_register(&dev->mdev->macsec_nh,\n\t\t\t\t\t &dev->macsec.blocking_events_nb);\n}\n\nvoid mlx5r_macsec_event_unregister(struct mlx5_ib_dev *dev)\n{\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\t\treturn;\n\t}\n\n\tblocking_notifier_chain_unregister(&dev->mdev->macsec_nh,\n\t\t\t\t\t   &dev->macsec.blocking_events_nb);\n}\n\nint mlx5r_macsec_init_gids_and_devlist(struct mlx5_ib_dev *dev)\n{\n\tint i, j, max_gids;\n\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\t\treturn 0;\n\t}\n\n\tmax_gids = MLX5_CAP_ROCE(dev->mdev, roce_address_table_size);\n\tfor (i = 0; i < dev->num_ports; i++) {\n\t\tdev->port[i].reserved_gids = kcalloc(max_gids,\n\t\t\t\t\t\t     sizeof(*dev->port[i].reserved_gids),\n\t\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!dev->port[i].reserved_gids)\n\t\t\tgoto err;\n\n\t\tfor (j = 0; j < max_gids; j++)\n\t\t\tdev->port[i].reserved_gids[j].macsec_index = -1;\n\t}\n\n\tINIT_LIST_HEAD(&dev->macsec.macsec_devices_list);\n\tmutex_init(&dev->macsec.lock);\n\n\treturn 0;\nerr:\n\twhile (i >= 0) {\n\t\tkfree(dev->port[i].reserved_gids);\n\t\ti--;\n\t}\n\treturn -ENOMEM;\n}\n\nvoid mlx5r_macsec_dealloc_gids(struct mlx5_ib_dev *dev)\n{\n\tint i;\n\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev))\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\n\tfor (i = 0; i < dev->num_ports; i++)\n\t\tkfree(dev->port[i].reserved_gids);\n\n\tmutex_destroy(&dev->macsec.lock);\n}\n\nint mlx5r_add_gid_macsec_operations(const struct ib_gid_attr *attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(attr->device);\n\tstruct mlx5_macsec_device *macsec_device;\n\tconst struct ib_gid_attr *physical_gid;\n\tstruct mlx5_reserved_gids *mgids;\n\tstruct net_device *ndev;\n\tint ret = 0;\n\tunion {\n\t\tstruct sockaddr_in  sockaddr_in;\n\t\tstruct sockaddr_in6 sockaddr_in6;\n\t} addr;\n\n\tif (attr->gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)\n\t\treturn 0;\n\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\tndev = rcu_dereference(attr->ndev);\n\tif (!ndev) {\n\t\trcu_read_unlock();\n\t\treturn -ENODEV;\n\t}\n\n\tif (!netif_is_macsec(ndev) || !macsec_netdev_is_offloaded(ndev)) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\tdev_hold(ndev);\n\trcu_read_unlock();\n\n\tmutex_lock(&dev->macsec.lock);\n\tmacsec_device = get_macsec_device(ndev, &dev->macsec.macsec_devices_list);\n\tif (!macsec_device) {\n\t\tret = -ENOMEM;\n\t\tgoto dev_err;\n\t}\n\n\tphysical_gid = rdma_find_gid(attr->device, &attr->gid,\n\t\t\t\t     attr->gid_type, NULL);\n\tif (!IS_ERR(physical_gid)) {\n\t\tret = set_roce_addr(to_mdev(physical_gid->device),\n\t\t\t\t    physical_gid->port_num,\n\t\t\t\t    physical_gid->index, NULL,\n\t\t\t\t    physical_gid);\n\t\tif (ret)\n\t\t\tgoto gid_err;\n\n\t\tmgids = &dev->port[attr->port_num - 1].reserved_gids[physical_gid->index];\n\t\tmgids->macsec_index = attr->index;\n\t\tmgids->physical_gid = physical_gid;\n\t}\n\n\t \n\trdma_gid2ip((struct sockaddr *)&addr, &attr->gid);\n\tret = mlx5_macsec_add_roce_rule(ndev, (struct sockaddr *)&addr, attr->index,\n\t\t\t\t\t&macsec_device->tx_rules_list,\n\t\t\t\t\t&macsec_device->rx_rules_list, dev->mdev->macsec_fs);\n\tif (ret && !IS_ERR(physical_gid))\n\t\tgoto rule_err;\n\n\tmlx5_macsec_save_roce_gid(macsec_device, (struct sockaddr *)&addr, attr->index);\n\n\tdev_put(ndev);\n\tmutex_unlock(&dev->macsec.lock);\n\treturn ret;\n\nrule_err:\n\tset_roce_addr(to_mdev(physical_gid->device), physical_gid->port_num,\n\t\t      physical_gid->index, &physical_gid->gid, physical_gid);\n\tmgids->macsec_index = -1;\ngid_err:\n\trdma_put_gid_attr(physical_gid);\n\tcleanup_macsec_device(macsec_device);\ndev_err:\n\tdev_put(ndev);\n\tmutex_unlock(&dev->macsec.lock);\n\treturn ret;\n}\n\nvoid mlx5r_del_gid_macsec_operations(const struct ib_gid_attr *attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(attr->device);\n\tstruct mlx5_macsec_device *macsec_device;\n\tstruct mlx5_reserved_gids *mgids;\n\tstruct net_device *ndev;\n\tint i, max_gids;\n\n\tif (attr->gid_type != IB_GID_TYPE_ROCE_UDP_ENCAP)\n\t\treturn;\n\n\tif (!mlx5_is_macsec_roce_supported(dev->mdev)) {\n\t\tmlx5_ib_dbg(dev, \"RoCE MACsec not supported due to capabilities\\n\");\n\t\treturn;\n\t}\n\n\tmgids = &dev->port[attr->port_num - 1].reserved_gids[attr->index];\n\tif (mgids->macsec_index != -1) {  \n\t\trdma_put_gid_attr(mgids->physical_gid);\n\t\tmgids->macsec_index = -1;\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tndev = rcu_dereference(attr->ndev);\n\tif (!ndev) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (!netif_is_macsec(ndev) || !macsec_netdev_is_offloaded(ndev)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tdev_hold(ndev);\n\trcu_read_unlock();\n\n\tmutex_lock(&dev->macsec.lock);\n\tmax_gids = MLX5_CAP_ROCE(dev->mdev, roce_address_table_size);\n\tfor (i = 0; i < max_gids; i++) {  \n\t\tmgids = &dev->port[attr->port_num - 1].reserved_gids[i];\n\t\tif (mgids->macsec_index == attr->index) {\n\t\t\tconst struct ib_gid_attr *physical_gid = mgids->physical_gid;\n\n\t\t\tset_roce_addr(to_mdev(physical_gid->device),\n\t\t\t\t      physical_gid->port_num,\n\t\t\t\t      physical_gid->index,\n\t\t\t\t      &physical_gid->gid, physical_gid);\n\n\t\t\trdma_put_gid_attr(physical_gid);\n\t\t\tmgids->macsec_index = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmacsec_device = get_macsec_device(ndev, &dev->macsec.macsec_devices_list);\n\tmlx5_macsec_del_roce_rule(attr->index, dev->mdev->macsec_fs,\n\t\t\t\t  &macsec_device->tx_rules_list, &macsec_device->rx_rules_list);\n\tmlx5_macsec_del_roce_gid(macsec_device, attr->index);\n\tcleanup_macsec_device(macsec_device);\n\n\tdev_put(ndev);\n\tmutex_unlock(&dev->macsec.lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}