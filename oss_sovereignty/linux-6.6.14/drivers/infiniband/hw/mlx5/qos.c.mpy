{
  "module_name": "qos.c",
  "hash_id": "c796a66b233713cc9ea2f7125c9fc04bd578befa8bcddc3f92694d8751ad2b27",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/qos.c",
  "human_readable_source": "\n \n\n#include <rdma/uverbs_ioctl.h>\n#include <rdma/mlx5_user_ioctl_cmds.h>\n#include <rdma/mlx5_user_ioctl_verbs.h>\n#include <linux/mlx5/driver.h>\n#include \"mlx5_ib.h\"\n\n#define UVERBS_MODULE_NAME mlx5_ib\n#include <rdma/uverbs_named_ioctl.h>\n\nstatic bool pp_is_supported(struct ib_device *device)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\n\treturn (MLX5_CAP_GEN(dev->mdev, qos) &&\n\t\tMLX5_CAP_QOS(dev->mdev, packet_pacing) &&\n\t\tMLX5_CAP_QOS(dev->mdev, packet_pacing_uid));\n}\n\nstatic int UVERBS_HANDLER(MLX5_IB_METHOD_PP_OBJ_ALLOC)(\n\tstruct uverbs_attr_bundle *attrs)\n{\n\tu8 rl_raw[MLX5_ST_SZ_BYTES(set_pp_rate_limit_context)] = {};\n\tstruct ib_uobject *uobj = uverbs_attr_get_uobject(attrs,\n\t\tMLX5_IB_ATTR_PP_OBJ_ALLOC_HANDLE);\n\tstruct mlx5_ib_dev *dev;\n\tstruct mlx5_ib_ucontext *c;\n\tstruct mlx5_ib_pp *pp_entry;\n\tvoid *in_ctx;\n\tu16 uid;\n\tint inlen;\n\tu32 flags;\n\tint err;\n\n\tc = to_mucontext(ib_uverbs_get_ucontext(attrs));\n\tif (IS_ERR(c))\n\t\treturn PTR_ERR(c);\n\n\t \n\tif (!c->devx_uid)\n\t\treturn -EINVAL;\n\n\tdev = to_mdev(c->ibucontext.device);\n\tpp_entry = kzalloc(sizeof(*pp_entry), GFP_KERNEL);\n\tif (!pp_entry)\n\t\treturn -ENOMEM;\n\n\tin_ctx = uverbs_attr_get_alloced_ptr(attrs,\n\t\t\t\t\t     MLX5_IB_ATTR_PP_OBJ_ALLOC_CTX);\n\tinlen = uverbs_attr_get_len(attrs,\n\t\t\t\t    MLX5_IB_ATTR_PP_OBJ_ALLOC_CTX);\n\tmemcpy(rl_raw, in_ctx, inlen);\n\terr = uverbs_get_flags32(&flags, attrs,\n\t\tMLX5_IB_ATTR_PP_OBJ_ALLOC_FLAGS,\n\t\tMLX5_IB_UAPI_PP_ALLOC_FLAGS_DEDICATED_INDEX);\n\tif (err)\n\t\tgoto err;\n\n\tuid = (flags & MLX5_IB_UAPI_PP_ALLOC_FLAGS_DEDICATED_INDEX) ?\n\t\tc->devx_uid : MLX5_SHARED_RESOURCE_UID;\n\n\terr = mlx5_rl_add_rate_raw(dev->mdev, rl_raw, uid,\n\t\t\t(flags & MLX5_IB_UAPI_PP_ALLOC_FLAGS_DEDICATED_INDEX),\n\t\t\t&pp_entry->index);\n\tif (err)\n\t\tgoto err;\n\n\tpp_entry->mdev = dev->mdev;\n\tuobj->object = pp_entry;\n\tuverbs_finalize_uobj_create(attrs, MLX5_IB_ATTR_PP_OBJ_ALLOC_HANDLE);\n\n\terr = uverbs_copy_to(attrs, MLX5_IB_ATTR_PP_OBJ_ALLOC_INDEX,\n\t\t\t     &pp_entry->index, sizeof(pp_entry->index));\n\treturn err;\n\nerr:\n\tkfree(pp_entry);\n\treturn err;\n}\n\nstatic int pp_obj_cleanup(struct ib_uobject *uobject,\n\t\t\t  enum rdma_remove_reason why,\n\t\t\t  struct uverbs_attr_bundle *attrs)\n{\n\tstruct mlx5_ib_pp *pp_entry = uobject->object;\n\n\tmlx5_rl_remove_rate_raw(pp_entry->mdev, pp_entry->index);\n\tkfree(pp_entry);\n\treturn 0;\n}\n\nDECLARE_UVERBS_NAMED_METHOD(\n\tMLX5_IB_METHOD_PP_OBJ_ALLOC,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_PP_OBJ_ALLOC_HANDLE,\n\t\t\tMLX5_IB_OBJECT_PP,\n\t\t\tUVERBS_ACCESS_NEW,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_IN(\n\t\tMLX5_IB_ATTR_PP_OBJ_ALLOC_CTX,\n\t\tUVERBS_ATTR_SIZE(1,\n\t\t\tMLX5_ST_SZ_BYTES(set_pp_rate_limit_context)),\n\t\tUA_MANDATORY,\n\t\tUA_ALLOC_AND_COPY),\n\tUVERBS_ATTR_FLAGS_IN(MLX5_IB_ATTR_PP_OBJ_ALLOC_FLAGS,\n\t\t\tenum mlx5_ib_uapi_pp_alloc_flags,\n\t\t\tUA_MANDATORY),\n\tUVERBS_ATTR_PTR_OUT(MLX5_IB_ATTR_PP_OBJ_ALLOC_INDEX,\n\t\t\t   UVERBS_ATTR_TYPE(u16),\n\t\t\t   UA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_METHOD_DESTROY(\n\tMLX5_IB_METHOD_PP_OBJ_DESTROY,\n\tUVERBS_ATTR_IDR(MLX5_IB_ATTR_PP_OBJ_DESTROY_HANDLE,\n\t\t\tMLX5_IB_OBJECT_PP,\n\t\t\tUVERBS_ACCESS_DESTROY,\n\t\t\tUA_MANDATORY));\n\nDECLARE_UVERBS_NAMED_OBJECT(MLX5_IB_OBJECT_PP,\n\t\t\t    UVERBS_TYPE_ALLOC_IDR(pp_obj_cleanup),\n\t\t\t    &UVERBS_METHOD(MLX5_IB_METHOD_PP_OBJ_ALLOC),\n\t\t\t    &UVERBS_METHOD(MLX5_IB_METHOD_PP_OBJ_DESTROY));\n\n\nconst struct uapi_definition mlx5_ib_qos_defs[] = {\n\tUAPI_DEF_CHAIN_OBJ_TREE_NAMED(\n\t\tMLX5_IB_OBJECT_PP,\n\t\tUAPI_DEF_IS_OBJ_SUPPORTED(pp_is_supported)),\n\t{},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}