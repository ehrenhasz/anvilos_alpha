{
  "module_name": "cq.c",
  "hash_id": "01860c52a2d8b750b83f6eaf65bd3e52ce26fabfecbda924a098f6f4a3c443d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/cq.c",
  "human_readable_source": " \n\n#include <linux/kref.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_cache.h>\n#include \"mlx5_ib.h\"\n#include \"srq.h\"\n#include \"qp.h\"\n\nstatic void mlx5_ib_cq_comp(struct mlx5_core_cq *cq, struct mlx5_eqe *eqe)\n{\n\tstruct ib_cq *ibcq = &to_mibcq(cq)->ibcq;\n\n\tibcq->comp_handler(ibcq, ibcq->cq_context);\n}\n\nstatic void mlx5_ib_cq_event(struct mlx5_core_cq *mcq, enum mlx5_event type)\n{\n\tstruct mlx5_ib_cq *cq = container_of(mcq, struct mlx5_ib_cq, mcq);\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);\n\tstruct ib_cq *ibcq = &cq->ibcq;\n\tstruct ib_event event;\n\n\tif (type != MLX5_EVENT_TYPE_CQ_ERROR) {\n\t\tmlx5_ib_warn(dev, \"Unexpected event type %d on CQ %06x\\n\",\n\t\t\t     type, mcq->cqn);\n\t\treturn;\n\t}\n\n\tif (ibcq->event_handler) {\n\t\tevent.device     = &dev->ib_dev;\n\t\tevent.event      = IB_EVENT_CQ_ERR;\n\t\tevent.element.cq = ibcq;\n\t\tibcq->event_handler(&event, ibcq->cq_context);\n\t}\n}\n\nstatic void *get_cqe(struct mlx5_ib_cq *cq, int n)\n{\n\treturn mlx5_frag_buf_get_wqe(&cq->buf.fbc, n);\n}\n\nstatic u8 sw_ownership_bit(int n, int nent)\n{\n\treturn (n & nent) ? 1 : 0;\n}\n\nstatic void *get_sw_cqe(struct mlx5_ib_cq *cq, int n)\n{\n\tvoid *cqe = get_cqe(cq, n & cq->ibcq.cqe);\n\tstruct mlx5_cqe64 *cqe64;\n\n\tcqe64 = (cq->mcq.cqe_sz == 64) ? cqe : cqe + 64;\n\n\tif (likely(get_cqe_opcode(cqe64) != MLX5_CQE_INVALID) &&\n\t    !((cqe64->op_own & MLX5_CQE_OWNER_MASK) ^ !!(n & (cq->ibcq.cqe + 1)))) {\n\t\treturn cqe;\n\t} else {\n\t\treturn NULL;\n\t}\n}\n\nstatic void *next_cqe_sw(struct mlx5_ib_cq *cq)\n{\n\treturn get_sw_cqe(cq, cq->mcq.cons_index);\n}\n\nstatic enum ib_wc_opcode get_umr_comp(struct mlx5_ib_wq *wq, int idx)\n{\n\tswitch (wq->wr_data[idx]) {\n\tcase MLX5_IB_WR_UMR:\n\t\treturn 0;\n\n\tcase IB_WR_LOCAL_INV:\n\t\treturn IB_WC_LOCAL_INV;\n\n\tcase IB_WR_REG_MR:\n\t\treturn IB_WC_REG_MR;\n\n\tdefault:\n\t\tpr_warn(\"unknown completion status\\n\");\n\t\treturn 0;\n\t}\n}\n\nstatic void handle_good_req(struct ib_wc *wc, struct mlx5_cqe64 *cqe,\n\t\t\t    struct mlx5_ib_wq *wq, int idx)\n{\n\twc->wc_flags = 0;\n\tswitch (be32_to_cpu(cqe->sop_drop_qpn) >> 24) {\n\tcase MLX5_OPCODE_RDMA_WRITE_IMM:\n\t\twc->wc_flags |= IB_WC_WITH_IMM;\n\t\tfallthrough;\n\tcase MLX5_OPCODE_RDMA_WRITE:\n\t\twc->opcode    = IB_WC_RDMA_WRITE;\n\t\tbreak;\n\tcase MLX5_OPCODE_SEND_IMM:\n\t\twc->wc_flags |= IB_WC_WITH_IMM;\n\t\tfallthrough;\n\tcase MLX5_OPCODE_SEND:\n\tcase MLX5_OPCODE_SEND_INVAL:\n\t\twc->opcode    = IB_WC_SEND;\n\t\tbreak;\n\tcase MLX5_OPCODE_RDMA_READ:\n\t\twc->opcode    = IB_WC_RDMA_READ;\n\t\twc->byte_len  = be32_to_cpu(cqe->byte_cnt);\n\t\tbreak;\n\tcase MLX5_OPCODE_ATOMIC_CS:\n\t\twc->opcode    = IB_WC_COMP_SWAP;\n\t\twc->byte_len  = 8;\n\t\tbreak;\n\tcase MLX5_OPCODE_ATOMIC_FA:\n\t\twc->opcode    = IB_WC_FETCH_ADD;\n\t\twc->byte_len  = 8;\n\t\tbreak;\n\tcase MLX5_OPCODE_ATOMIC_MASKED_CS:\n\t\twc->opcode    = IB_WC_MASKED_COMP_SWAP;\n\t\twc->byte_len  = 8;\n\t\tbreak;\n\tcase MLX5_OPCODE_ATOMIC_MASKED_FA:\n\t\twc->opcode    = IB_WC_MASKED_FETCH_ADD;\n\t\twc->byte_len  = 8;\n\t\tbreak;\n\tcase MLX5_OPCODE_UMR:\n\t\twc->opcode = get_umr_comp(wq, idx);\n\t\tbreak;\n\t}\n}\n\nenum {\n\tMLX5_GRH_IN_BUFFER = 1,\n\tMLX5_GRH_IN_CQE\t   = 2,\n};\n\nstatic void handle_responder(struct ib_wc *wc, struct mlx5_cqe64 *cqe,\n\t\t\t     struct mlx5_ib_qp *qp)\n{\n\tenum rdma_link_layer ll = rdma_port_get_link_layer(qp->ibqp.device, 1);\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->ibqp.device);\n\tstruct mlx5_ib_srq *srq = NULL;\n\tstruct mlx5_ib_wq *wq;\n\tu16 wqe_ctr;\n\tu8  roce_packet_type;\n\tbool vlan_present;\n\tu8 g;\n\n\tif (qp->ibqp.srq || qp->ibqp.xrcd) {\n\t\tstruct mlx5_core_srq *msrq = NULL;\n\n\t\tif (qp->ibqp.xrcd) {\n\t\t\tmsrq = mlx5_cmd_get_srq(dev, be32_to_cpu(cqe->srqn));\n\t\t\tif (msrq)\n\t\t\t\tsrq = to_mibsrq(msrq);\n\t\t} else {\n\t\t\tsrq = to_msrq(qp->ibqp.srq);\n\t\t}\n\t\tif (srq) {\n\t\t\twqe_ctr = be16_to_cpu(cqe->wqe_counter);\n\t\t\twc->wr_id = srq->wrid[wqe_ctr];\n\t\t\tmlx5_ib_free_srq_wqe(srq, wqe_ctr);\n\t\t\tif (msrq)\n\t\t\t\tmlx5_core_res_put(&msrq->common);\n\t\t}\n\t} else {\n\t\twq\t  = &qp->rq;\n\t\twc->wr_id = wq->wrid[wq->tail & (wq->wqe_cnt - 1)];\n\t\t++wq->tail;\n\t}\n\twc->byte_len = be32_to_cpu(cqe->byte_cnt);\n\n\tswitch (get_cqe_opcode(cqe)) {\n\tcase MLX5_CQE_RESP_WR_IMM:\n\t\twc->opcode\t= IB_WC_RECV_RDMA_WITH_IMM;\n\t\twc->wc_flags\t= IB_WC_WITH_IMM;\n\t\twc->ex.imm_data = cqe->immediate;\n\t\tbreak;\n\tcase MLX5_CQE_RESP_SEND:\n\t\twc->opcode   = IB_WC_RECV;\n\t\twc->wc_flags = IB_WC_IP_CSUM_OK;\n\t\tif (unlikely(!((cqe->hds_ip_ext & CQE_L3_OK) &&\n\t\t\t       (cqe->hds_ip_ext & CQE_L4_OK))))\n\t\t\twc->wc_flags = 0;\n\t\tbreak;\n\tcase MLX5_CQE_RESP_SEND_IMM:\n\t\twc->opcode\t= IB_WC_RECV;\n\t\twc->wc_flags\t= IB_WC_WITH_IMM;\n\t\twc->ex.imm_data = cqe->immediate;\n\t\tbreak;\n\tcase MLX5_CQE_RESP_SEND_INV:\n\t\twc->opcode\t= IB_WC_RECV;\n\t\twc->wc_flags\t= IB_WC_WITH_INVALIDATE;\n\t\twc->ex.invalidate_rkey = be32_to_cpu(cqe->inval_rkey);\n\t\tbreak;\n\t}\n\twc->src_qp\t   = be32_to_cpu(cqe->flags_rqpn) & 0xffffff;\n\twc->dlid_path_bits = cqe->ml_path;\n\tg = (be32_to_cpu(cqe->flags_rqpn) >> 28) & 3;\n\twc->wc_flags |= g ? IB_WC_GRH : 0;\n\tif (is_qp1(qp->type)) {\n\t\tu16 pkey = be32_to_cpu(cqe->pkey) & 0xffff;\n\n\t\tib_find_cached_pkey(&dev->ib_dev, qp->port, pkey,\n\t\t\t\t    &wc->pkey_index);\n\t} else {\n\t\twc->pkey_index = 0;\n\t}\n\n\tif (ll != IB_LINK_LAYER_ETHERNET) {\n\t\twc->slid = be16_to_cpu(cqe->slid);\n\t\twc->sl = (be32_to_cpu(cqe->flags_rqpn) >> 24) & 0xf;\n\t\treturn;\n\t}\n\n\twc->slid = 0;\n\tvlan_present = cqe->l4_l3_hdr_type & 0x1;\n\troce_packet_type   = (be32_to_cpu(cqe->flags_rqpn) >> 24) & 0x3;\n\tif (vlan_present) {\n\t\twc->vlan_id = (be16_to_cpu(cqe->vlan_info)) & 0xfff;\n\t\twc->sl = (be16_to_cpu(cqe->vlan_info) >> 13) & 0x7;\n\t\twc->wc_flags |= IB_WC_WITH_VLAN;\n\t} else {\n\t\twc->sl = 0;\n\t}\n\n\tswitch (roce_packet_type) {\n\tcase MLX5_CQE_ROCE_L3_HEADER_TYPE_GRH:\n\t\twc->network_hdr_type = RDMA_NETWORK_ROCE_V1;\n\t\tbreak;\n\tcase MLX5_CQE_ROCE_L3_HEADER_TYPE_IPV6:\n\t\twc->network_hdr_type = RDMA_NETWORK_IPV6;\n\t\tbreak;\n\tcase MLX5_CQE_ROCE_L3_HEADER_TYPE_IPV4:\n\t\twc->network_hdr_type = RDMA_NETWORK_IPV4;\n\t\tbreak;\n\t}\n\twc->wc_flags |= IB_WC_WITH_NETWORK_HDR_TYPE;\n}\n\nstatic void dump_cqe(struct mlx5_ib_dev *dev, struct mlx5_err_cqe *cqe,\n\t\t     struct ib_wc *wc, const char *level)\n{\n\tmlx5_ib_log(level, dev, \"WC error: %d, Message: %s\\n\", wc->status,\n\t\t    ib_wc_status_msg(wc->status));\n\tprint_hex_dump(level, \"cqe_dump: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t       cqe, sizeof(*cqe), false);\n}\n\nstatic void mlx5_handle_error_cqe(struct mlx5_ib_dev *dev,\n\t\t\t\t  struct mlx5_err_cqe *cqe,\n\t\t\t\t  struct ib_wc *wc)\n{\n\tconst char *dump = KERN_WARNING;\n\n\tswitch (cqe->syndrome) {\n\tcase MLX5_CQE_SYNDROME_LOCAL_LENGTH_ERR:\n\t\twc->status = IB_WC_LOC_LEN_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_LOCAL_QP_OP_ERR:\n\t\twc->status = IB_WC_LOC_QP_OP_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_LOCAL_PROT_ERR:\n\t\tdump = KERN_DEBUG;\n\t\twc->status = IB_WC_LOC_PROT_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_WR_FLUSH_ERR:\n\t\tdump = NULL;\n\t\twc->status = IB_WC_WR_FLUSH_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_MW_BIND_ERR:\n\t\twc->status = IB_WC_MW_BIND_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_BAD_RESP_ERR:\n\t\twc->status = IB_WC_BAD_RESP_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_LOCAL_ACCESS_ERR:\n\t\twc->status = IB_WC_LOC_ACCESS_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_REMOTE_INVAL_REQ_ERR:\n\t\twc->status = IB_WC_REM_INV_REQ_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_REMOTE_ACCESS_ERR:\n\t\tdump = KERN_DEBUG;\n\t\twc->status = IB_WC_REM_ACCESS_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_REMOTE_OP_ERR:\n\t\tdump = KERN_DEBUG;\n\t\twc->status = IB_WC_REM_OP_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_TRANSPORT_RETRY_EXC_ERR:\n\t\tdump = NULL;\n\t\twc->status = IB_WC_RETRY_EXC_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_RNR_RETRY_EXC_ERR:\n\t\tdump = NULL;\n\t\twc->status = IB_WC_RNR_RETRY_EXC_ERR;\n\t\tbreak;\n\tcase MLX5_CQE_SYNDROME_REMOTE_ABORTED_ERR:\n\t\twc->status = IB_WC_REM_ABORT_ERR;\n\t\tbreak;\n\tdefault:\n\t\twc->status = IB_WC_GENERAL_ERR;\n\t\tbreak;\n\t}\n\n\twc->vendor_err = cqe->vendor_err_synd;\n\tif (dump)\n\t\tdump_cqe(dev, cqe, wc, dump);\n}\n\nstatic void handle_atomics(struct mlx5_ib_qp *qp, struct mlx5_cqe64 *cqe64,\n\t\t\t   u16 tail, u16 head)\n{\n\tu16 idx;\n\n\tdo {\n\t\tidx = tail & (qp->sq.wqe_cnt - 1);\n\t\tif (idx == head)\n\t\t\tbreak;\n\n\t\ttail = qp->sq.w_list[idx].next;\n\t} while (1);\n\ttail = qp->sq.w_list[idx].next;\n\tqp->sq.last_poll = tail;\n}\n\nstatic void free_cq_buf(struct mlx5_ib_dev *dev, struct mlx5_ib_cq_buf *buf)\n{\n\tmlx5_frag_buf_free(dev->mdev, &buf->frag_buf);\n}\n\nstatic void get_sig_err_item(struct mlx5_sig_err_cqe *cqe,\n\t\t\t     struct ib_sig_err *item)\n{\n\tu16 syndrome = be16_to_cpu(cqe->syndrome);\n\n#define GUARD_ERR   (1 << 13)\n#define APPTAG_ERR  (1 << 12)\n#define REFTAG_ERR  (1 << 11)\n\n\tif (syndrome & GUARD_ERR) {\n\t\titem->err_type = IB_SIG_BAD_GUARD;\n\t\titem->expected = be32_to_cpu(cqe->expected_trans_sig) >> 16;\n\t\titem->actual = be32_to_cpu(cqe->actual_trans_sig) >> 16;\n\t} else\n\tif (syndrome & REFTAG_ERR) {\n\t\titem->err_type = IB_SIG_BAD_REFTAG;\n\t\titem->expected = be32_to_cpu(cqe->expected_reftag);\n\t\titem->actual = be32_to_cpu(cqe->actual_reftag);\n\t} else\n\tif (syndrome & APPTAG_ERR) {\n\t\titem->err_type = IB_SIG_BAD_APPTAG;\n\t\titem->expected = be32_to_cpu(cqe->expected_trans_sig) & 0xffff;\n\t\titem->actual = be32_to_cpu(cqe->actual_trans_sig) & 0xffff;\n\t} else {\n\t\tpr_err(\"Got signature completion error with bad syndrome %04x\\n\",\n\t\t       syndrome);\n\t}\n\n\titem->sig_err_offset = be64_to_cpu(cqe->err_offset);\n\titem->key = be32_to_cpu(cqe->mkey);\n}\n\nstatic void sw_comp(struct mlx5_ib_qp *qp, int num_entries, struct ib_wc *wc,\n\t\t    int *npolled, bool is_send)\n{\n\tstruct mlx5_ib_wq *wq;\n\tunsigned int cur;\n\tint np;\n\tint i;\n\n\twq = (is_send) ? &qp->sq : &qp->rq;\n\tcur = wq->head - wq->tail;\n\tnp = *npolled;\n\n\tif (cur == 0)\n\t\treturn;\n\n\tfor (i = 0;  i < cur && np < num_entries; i++) {\n\t\tunsigned int idx;\n\n\t\tidx = (is_send) ? wq->last_poll : wq->tail;\n\t\tidx &= (wq->wqe_cnt - 1);\n\t\twc->wr_id = wq->wrid[idx];\n\t\twc->status = IB_WC_WR_FLUSH_ERR;\n\t\twc->vendor_err = MLX5_CQE_SYNDROME_WR_FLUSH_ERR;\n\t\twq->tail++;\n\t\tif (is_send)\n\t\t\twq->last_poll = wq->w_list[idx].next;\n\t\tnp++;\n\t\twc->qp = &qp->ibqp;\n\t\twc++;\n\t}\n\t*npolled = np;\n}\n\nstatic void mlx5_ib_poll_sw_comp(struct mlx5_ib_cq *cq, int num_entries,\n\t\t\t\t struct ib_wc *wc, int *npolled)\n{\n\tstruct mlx5_ib_qp *qp;\n\n\t*npolled = 0;\n\t \n\tlist_for_each_entry(qp, &cq->list_send_qp, cq_send_list) {\n\t\tsw_comp(qp, num_entries, wc + *npolled, npolled, true);\n\t\tif (*npolled >= num_entries)\n\t\t\treturn;\n\t}\n\n\tlist_for_each_entry(qp, &cq->list_recv_qp, cq_recv_list) {\n\t\tsw_comp(qp, num_entries, wc + *npolled, npolled, false);\n\t\tif (*npolled >= num_entries)\n\t\t\treturn;\n\t}\n}\n\nstatic int mlx5_poll_one(struct mlx5_ib_cq *cq,\n\t\t\t struct mlx5_ib_qp **cur_qp,\n\t\t\t struct ib_wc *wc)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);\n\tstruct mlx5_err_cqe *err_cqe;\n\tstruct mlx5_cqe64 *cqe64;\n\tstruct mlx5_core_qp *mqp;\n\tstruct mlx5_ib_wq *wq;\n\tuint8_t opcode;\n\tuint32_t qpn;\n\tu16 wqe_ctr;\n\tvoid *cqe;\n\tint idx;\n\nrepoll:\n\tcqe = next_cqe_sw(cq);\n\tif (!cqe)\n\t\treturn -EAGAIN;\n\n\tcqe64 = (cq->mcq.cqe_sz == 64) ? cqe : cqe + 64;\n\n\t++cq->mcq.cons_index;\n\n\t \n\trmb();\n\n\topcode = get_cqe_opcode(cqe64);\n\tif (unlikely(opcode == MLX5_CQE_RESIZE_CQ)) {\n\t\tif (likely(cq->resize_buf)) {\n\t\t\tfree_cq_buf(dev, &cq->buf);\n\t\t\tcq->buf = *cq->resize_buf;\n\t\t\tkfree(cq->resize_buf);\n\t\t\tcq->resize_buf = NULL;\n\t\t\tgoto repoll;\n\t\t} else {\n\t\t\tmlx5_ib_warn(dev, \"unexpected resize cqe\\n\");\n\t\t}\n\t}\n\n\tqpn = ntohl(cqe64->sop_drop_qpn) & 0xffffff;\n\tif (!*cur_qp || (qpn != (*cur_qp)->ibqp.qp_num)) {\n\t\t \n\t\tmqp = radix_tree_lookup(&dev->qp_table.tree, qpn);\n\t\t*cur_qp = to_mibqp(mqp);\n\t}\n\n\twc->qp  = &(*cur_qp)->ibqp;\n\tswitch (opcode) {\n\tcase MLX5_CQE_REQ:\n\t\twq = &(*cur_qp)->sq;\n\t\twqe_ctr = be16_to_cpu(cqe64->wqe_counter);\n\t\tidx = wqe_ctr & (wq->wqe_cnt - 1);\n\t\thandle_good_req(wc, cqe64, wq, idx);\n\t\thandle_atomics(*cur_qp, cqe64, wq->last_poll, idx);\n\t\twc->wr_id = wq->wrid[idx];\n\t\twq->tail = wq->wqe_head[idx] + 1;\n\t\twc->status = IB_WC_SUCCESS;\n\t\tbreak;\n\tcase MLX5_CQE_RESP_WR_IMM:\n\tcase MLX5_CQE_RESP_SEND:\n\tcase MLX5_CQE_RESP_SEND_IMM:\n\tcase MLX5_CQE_RESP_SEND_INV:\n\t\thandle_responder(wc, cqe64, *cur_qp);\n\t\twc->status = IB_WC_SUCCESS;\n\t\tbreak;\n\tcase MLX5_CQE_RESIZE_CQ:\n\t\tbreak;\n\tcase MLX5_CQE_REQ_ERR:\n\tcase MLX5_CQE_RESP_ERR:\n\t\terr_cqe = (struct mlx5_err_cqe *)cqe64;\n\t\tmlx5_handle_error_cqe(dev, err_cqe, wc);\n\t\tmlx5_ib_dbg(dev, \"%s error cqe on cqn 0x%x:\\n\",\n\t\t\t    opcode == MLX5_CQE_REQ_ERR ?\n\t\t\t    \"Requestor\" : \"Responder\", cq->mcq.cqn);\n\t\tmlx5_ib_dbg(dev, \"syndrome 0x%x, vendor syndrome 0x%x\\n\",\n\t\t\t    err_cqe->syndrome, err_cqe->vendor_err_synd);\n\t\tif (wc->status != IB_WC_WR_FLUSH_ERR &&\n\t\t    (*cur_qp)->type == MLX5_IB_QPT_REG_UMR)\n\t\t\tdev->umrc.state = MLX5_UMR_STATE_RECOVER;\n\n\t\tif (opcode == MLX5_CQE_REQ_ERR) {\n\t\t\twq = &(*cur_qp)->sq;\n\t\t\twqe_ctr = be16_to_cpu(cqe64->wqe_counter);\n\t\t\tidx = wqe_ctr & (wq->wqe_cnt - 1);\n\t\t\twc->wr_id = wq->wrid[idx];\n\t\t\twq->tail = wq->wqe_head[idx] + 1;\n\t\t} else {\n\t\t\tstruct mlx5_ib_srq *srq;\n\n\t\t\tif ((*cur_qp)->ibqp.srq) {\n\t\t\t\tsrq = to_msrq((*cur_qp)->ibqp.srq);\n\t\t\t\twqe_ctr = be16_to_cpu(cqe64->wqe_counter);\n\t\t\t\twc->wr_id = srq->wrid[wqe_ctr];\n\t\t\t\tmlx5_ib_free_srq_wqe(srq, wqe_ctr);\n\t\t\t} else {\n\t\t\t\twq = &(*cur_qp)->rq;\n\t\t\t\twc->wr_id = wq->wrid[wq->tail & (wq->wqe_cnt - 1)];\n\t\t\t\t++wq->tail;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MLX5_CQE_SIG_ERR: {\n\t\tstruct mlx5_sig_err_cqe *sig_err_cqe =\n\t\t\t(struct mlx5_sig_err_cqe *)cqe64;\n\t\tstruct mlx5_core_sig_ctx *sig;\n\n\t\txa_lock(&dev->sig_mrs);\n\t\tsig = xa_load(&dev->sig_mrs,\n\t\t\t\tmlx5_base_mkey(be32_to_cpu(sig_err_cqe->mkey)));\n\t\tget_sig_err_item(sig_err_cqe, &sig->err_item);\n\t\tsig->sig_err_exists = true;\n\t\tsig->sigerr_count++;\n\n\t\tmlx5_ib_warn(dev, \"CQN: 0x%x Got SIGERR on key: 0x%x err_type %x err_offset %llx expected %x actual %x\\n\",\n\t\t\t     cq->mcq.cqn, sig->err_item.key,\n\t\t\t     sig->err_item.err_type,\n\t\t\t     sig->err_item.sig_err_offset,\n\t\t\t     sig->err_item.expected,\n\t\t\t     sig->err_item.actual);\n\n\t\txa_unlock(&dev->sig_mrs);\n\t\tgoto repoll;\n\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int poll_soft_wc(struct mlx5_ib_cq *cq, int num_entries,\n\t\t\tstruct ib_wc *wc, bool is_fatal_err)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);\n\tstruct mlx5_ib_wc *soft_wc, *next;\n\tint npolled = 0;\n\n\tlist_for_each_entry_safe(soft_wc, next, &cq->wc_list, list) {\n\t\tif (npolled >= num_entries)\n\t\t\tbreak;\n\n\t\tmlx5_ib_dbg(dev, \"polled software generated completion on CQ 0x%x\\n\",\n\t\t\t    cq->mcq.cqn);\n\n\t\tif (unlikely(is_fatal_err)) {\n\t\t\tsoft_wc->wc.status = IB_WC_WR_FLUSH_ERR;\n\t\t\tsoft_wc->wc.vendor_err = MLX5_CQE_SYNDROME_WR_FLUSH_ERR;\n\t\t}\n\t\twc[npolled++] = soft_wc->wc;\n\t\tlist_del(&soft_wc->list);\n\t\tkfree(soft_wc);\n\t}\n\n\treturn npolled;\n}\n\nint mlx5_ib_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\tstruct mlx5_ib_qp *cur_qp = NULL;\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tunsigned long flags;\n\tint soft_polled = 0;\n\tint npolled;\n\n\tspin_lock_irqsave(&cq->lock, flags);\n\tif (mdev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\n\t\t \n\t\tif (unlikely(!list_empty(&cq->wc_list)))\n\t\t\tsoft_polled = poll_soft_wc(cq, num_entries, wc, true);\n\n\t\tmlx5_ib_poll_sw_comp(cq, num_entries - soft_polled,\n\t\t\t\t     wc + soft_polled, &npolled);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(!list_empty(&cq->wc_list)))\n\t\tsoft_polled = poll_soft_wc(cq, num_entries, wc, false);\n\n\tfor (npolled = 0; npolled < num_entries - soft_polled; npolled++) {\n\t\tif (mlx5_poll_one(cq, &cur_qp, wc + soft_polled + npolled))\n\t\t\tbreak;\n\t}\n\n\tif (npolled)\n\t\tmlx5_cq_set_ci(&cq->mcq);\nout:\n\tspin_unlock_irqrestore(&cq->lock, flags);\n\n\treturn soft_polled + npolled;\n}\n\nint mlx5_ib_arm_cq(struct ib_cq *ibcq, enum ib_cq_notify_flags flags)\n{\n\tstruct mlx5_core_dev *mdev = to_mdev(ibcq->device)->mdev;\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\tvoid __iomem *uar_page = mdev->priv.uar->map;\n\tunsigned long irq_flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&cq->lock, irq_flags);\n\tif (cq->notify_flags != IB_CQ_NEXT_COMP)\n\t\tcq->notify_flags = flags & IB_CQ_SOLICITED_MASK;\n\n\tif ((flags & IB_CQ_REPORT_MISSED_EVENTS) && !list_empty(&cq->wc_list))\n\t\tret = 1;\n\tspin_unlock_irqrestore(&cq->lock, irq_flags);\n\n\tmlx5_cq_arm(&cq->mcq,\n\t\t    (flags & IB_CQ_SOLICITED_MASK) == IB_CQ_SOLICITED ?\n\t\t    MLX5_CQ_DB_REQ_NOT_SOL : MLX5_CQ_DB_REQ_NOT,\n\t\t    uar_page, to_mcq(ibcq)->mcq.cons_index);\n\n\treturn ret;\n}\n\nstatic int alloc_cq_frag_buf(struct mlx5_ib_dev *dev,\n\t\t\t     struct mlx5_ib_cq_buf *buf,\n\t\t\t     int nent,\n\t\t\t     int cqe_size)\n{\n\tstruct mlx5_frag_buf *frag_buf = &buf->frag_buf;\n\tu8 log_wq_stride = 6 + (cqe_size == 128 ? 1 : 0);\n\tu8 log_wq_sz     = ilog2(cqe_size);\n\tint err;\n\n\terr = mlx5_frag_buf_alloc_node(dev->mdev,\n\t\t\t\t       nent * cqe_size,\n\t\t\t\t       frag_buf,\n\t\t\t\t       dev->mdev->priv.numa_node);\n\tif (err)\n\t\treturn err;\n\n\tmlx5_init_fbc(frag_buf->frags, log_wq_stride, log_wq_sz, &buf->fbc);\n\n\tbuf->cqe_size = cqe_size;\n\tbuf->nent = nent;\n\n\treturn 0;\n}\n\nenum {\n\tMLX5_CQE_RES_FORMAT_HASH = 0,\n\tMLX5_CQE_RES_FORMAT_CSUM = 1,\n\tMLX5_CQE_RES_FORMAT_CSUM_STRIDX = 3,\n};\n\nstatic int mini_cqe_res_format_to_hw(struct mlx5_ib_dev *dev, u8 format)\n{\n\tswitch (format) {\n\tcase MLX5_IB_CQE_RES_FORMAT_HASH:\n\t\treturn MLX5_CQE_RES_FORMAT_HASH;\n\tcase MLX5_IB_CQE_RES_FORMAT_CSUM:\n\t\treturn MLX5_CQE_RES_FORMAT_CSUM;\n\tcase MLX5_IB_CQE_RES_FORMAT_CSUM_STRIDX:\n\t\tif (MLX5_CAP_GEN(dev->mdev, mini_cqe_resp_stride_index))\n\t\t\treturn MLX5_CQE_RES_FORMAT_CSUM_STRIDX;\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int create_cq_user(struct mlx5_ib_dev *dev, struct ib_udata *udata,\n\t\t\t  struct mlx5_ib_cq *cq, int entries, u32 **cqb,\n\t\t\t  int *cqe_size, int *index, int *inlen)\n{\n\tstruct mlx5_ib_create_cq ucmd = {};\n\tunsigned long page_size;\n\tunsigned int page_offset_quantized;\n\tsize_t ucmdlen;\n\t__be64 *pas;\n\tint ncont;\n\tvoid *cqc;\n\tint err;\n\tstruct mlx5_ib_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\n\tucmdlen = min(udata->inlen, sizeof(ucmd));\n\tif (ucmdlen < offsetof(struct mlx5_ib_create_cq, flags))\n\t\treturn -EINVAL;\n\n\tif (ib_copy_from_udata(&ucmd, udata, ucmdlen))\n\t\treturn -EFAULT;\n\n\tif ((ucmd.flags & ~(MLX5_IB_CREATE_CQ_FLAGS_CQE_128B_PAD |\n\t\t\t    MLX5_IB_CREATE_CQ_FLAGS_UAR_PAGE_INDEX |\n\t\t\t    MLX5_IB_CREATE_CQ_FLAGS_REAL_TIME_TS)))\n\t\treturn -EINVAL;\n\n\tif ((ucmd.cqe_size != 64 && ucmd.cqe_size != 128) ||\n\t    ucmd.reserved0 || ucmd.reserved1)\n\t\treturn -EINVAL;\n\n\t*cqe_size = ucmd.cqe_size;\n\n\tcq->buf.umem =\n\t\tib_umem_get(&dev->ib_dev, ucmd.buf_addr,\n\t\t\t    entries * ucmd.cqe_size, IB_ACCESS_LOCAL_WRITE);\n\tif (IS_ERR(cq->buf.umem)) {\n\t\terr = PTR_ERR(cq->buf.umem);\n\t\treturn err;\n\t}\n\n\tpage_size = mlx5_umem_find_best_cq_quantized_pgoff(\n\t\tcq->buf.umem, cqc, log_page_size, MLX5_ADAPTER_PAGE_SHIFT,\n\t\tpage_offset, 64, &page_offset_quantized);\n\tif (!page_size) {\n\t\terr = -EINVAL;\n\t\tgoto err_umem;\n\t}\n\n\terr = mlx5_ib_db_map_user(context, ucmd.db_addr, &cq->db);\n\tif (err)\n\t\tgoto err_umem;\n\n\tncont = ib_umem_num_dma_blocks(cq->buf.umem, page_size);\n\tmlx5_ib_dbg(\n\t\tdev,\n\t\t\"addr 0x%llx, size %u, npages %zu, page_size %lu, ncont %d\\n\",\n\t\tucmd.buf_addr, entries * ucmd.cqe_size,\n\t\tib_umem_num_pages(cq->buf.umem), page_size, ncont);\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_cq_in, pas[0]) * ncont;\n\t*cqb = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*cqb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_db;\n\t}\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, *cqb, pas);\n\tmlx5_ib_populate_pas(cq->buf.umem, page_size, pas, 0);\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, *cqb, cq_context);\n\tMLX5_SET(cqc, cqc, log_page_size,\n\t\t order_base_2(page_size) - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(cqc, cqc, page_offset, page_offset_quantized);\n\n\tif (ucmd.flags & MLX5_IB_CREATE_CQ_FLAGS_UAR_PAGE_INDEX) {\n\t\t*index = ucmd.uar_page_index;\n\t} else if (context->bfregi.lib_uar_dyn) {\n\t\terr = -EINVAL;\n\t\tgoto err_cqb;\n\t} else {\n\t\t*index = context->bfregi.sys_pages[0];\n\t}\n\n\tif (ucmd.cqe_comp_en == 1) {\n\t\tint mini_cqe_format;\n\n\t\tif (!((*cqe_size == 128 &&\n\t\t       MLX5_CAP_GEN(dev->mdev, cqe_compression_128)) ||\n\t\t      (*cqe_size == 64  &&\n\t\t       MLX5_CAP_GEN(dev->mdev, cqe_compression)))) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tmlx5_ib_warn(dev, \"CQE compression is not supported for size %d!\\n\",\n\t\t\t\t     *cqe_size);\n\t\t\tgoto err_cqb;\n\t\t}\n\n\t\tmini_cqe_format =\n\t\t\tmini_cqe_res_format_to_hw(dev,\n\t\t\t\t\t\t  ucmd.cqe_comp_res_format);\n\t\tif (mini_cqe_format < 0) {\n\t\t\terr = mini_cqe_format;\n\t\t\tmlx5_ib_dbg(dev, \"CQE compression res format %d error: %d\\n\",\n\t\t\t\t    ucmd.cqe_comp_res_format, err);\n\t\t\tgoto err_cqb;\n\t\t}\n\n\t\tMLX5_SET(cqc, cqc, cqe_comp_en, 1);\n\t\tMLX5_SET(cqc, cqc, mini_cqe_res_format, mini_cqe_format);\n\t}\n\n\tif (ucmd.flags & MLX5_IB_CREATE_CQ_FLAGS_CQE_128B_PAD) {\n\t\tif (*cqe_size != 128 ||\n\t\t    !MLX5_CAP_GEN(dev->mdev, cqe_128_always)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tmlx5_ib_warn(dev,\n\t\t\t\t     \"CQE padding is not supported for CQE size of %dB!\\n\",\n\t\t\t\t     *cqe_size);\n\t\t\tgoto err_cqb;\n\t\t}\n\n\t\tcq->private_flags |= MLX5_IB_CQ_PR_FLAGS_CQE_128_PAD;\n\t}\n\n\tif (ucmd.flags & MLX5_IB_CREATE_CQ_FLAGS_REAL_TIME_TS)\n\t\tcq->private_flags |= MLX5_IB_CQ_PR_FLAGS_REAL_TIME_TS;\n\n\tMLX5_SET(create_cq_in, *cqb, uid, context->devx_uid);\n\treturn 0;\n\nerr_cqb:\n\tkvfree(*cqb);\n\nerr_db:\n\tmlx5_ib_db_unmap_user(context, &cq->db);\n\nerr_umem:\n\tib_umem_release(cq->buf.umem);\n\treturn err;\n}\n\nstatic void destroy_cq_user(struct mlx5_ib_cq *cq, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mlx5_ib_ucontext, ibucontext);\n\n\tmlx5_ib_db_unmap_user(context, &cq->db);\n\tib_umem_release(cq->buf.umem);\n}\n\nstatic void init_cq_frag_buf(struct mlx5_ib_cq_buf *buf)\n{\n\tint i;\n\tvoid *cqe;\n\tstruct mlx5_cqe64 *cqe64;\n\n\tfor (i = 0; i < buf->nent; i++) {\n\t\tcqe = mlx5_frag_buf_get_wqe(&buf->fbc, i);\n\t\tcqe64 = buf->cqe_size == 64 ? cqe : cqe + 64;\n\t\tcqe64->op_own = MLX5_CQE_INVALID << 4;\n\t}\n}\n\nstatic int create_cq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,\n\t\t\t    int entries, int cqe_size,\n\t\t\t    u32 **cqb, int *index, int *inlen)\n{\n\t__be64 *pas;\n\tvoid *cqc;\n\tint err;\n\n\terr = mlx5_db_alloc(dev->mdev, &cq->db);\n\tif (err)\n\t\treturn err;\n\n\tcq->mcq.set_ci_db  = cq->db.db;\n\tcq->mcq.arm_db     = cq->db.db + 1;\n\tcq->mcq.cqe_sz = cqe_size;\n\n\terr = alloc_cq_frag_buf(dev, &cq->buf, entries, cqe_size);\n\tif (err)\n\t\tgoto err_db;\n\n\tinit_cq_frag_buf(&cq->buf);\n\n\t*inlen = MLX5_ST_SZ_BYTES(create_cq_in) +\n\t\t MLX5_FLD_SZ_BYTES(create_cq_in, pas[0]) *\n\t\t cq->buf.frag_buf.npages;\n\t*cqb = kvzalloc(*inlen, GFP_KERNEL);\n\tif (!*cqb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_buf;\n\t}\n\n\tpas = (__be64 *)MLX5_ADDR_OF(create_cq_in, *cqb, pas);\n\tmlx5_fill_page_frag_array(&cq->buf.frag_buf, pas);\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, *cqb, cq_context);\n\tMLX5_SET(cqc, cqc, log_page_size,\n\t\t cq->buf.frag_buf.page_shift -\n\t\t MLX5_ADAPTER_PAGE_SHIFT);\n\n\t*index = dev->mdev->priv.uar->index;\n\n\treturn 0;\n\nerr_buf:\n\tfree_cq_buf(dev, &cq->buf);\n\nerr_db:\n\tmlx5_db_free(dev->mdev, &cq->db);\n\treturn err;\n}\n\nstatic void destroy_cq_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq)\n{\n\tfree_cq_buf(dev, &cq->buf);\n\tmlx5_db_free(dev->mdev, &cq->db);\n}\n\nstatic void notify_soft_wc_handler(struct work_struct *work)\n{\n\tstruct mlx5_ib_cq *cq = container_of(work, struct mlx5_ib_cq,\n\t\t\t\t\t     notify_work);\n\n\tcq->ibcq.comp_handler(&cq->ibcq, cq->ibcq.cq_context);\n}\n\nint mlx5_ib_create_cq(struct ib_cq *ibcq, const struct ib_cq_init_attr *attr,\n\t\t      struct ib_udata *udata)\n{\n\tstruct ib_device *ibdev = ibcq->device;\n\tint entries = attr->cqe;\n\tint vector = attr->comp_vector;\n\tstruct mlx5_ib_dev *dev = to_mdev(ibdev);\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\tu32 out[MLX5_ST_SZ_DW(create_cq_out)];\n\tint index;\n\tint inlen;\n\tu32 *cqb = NULL;\n\tvoid *cqc;\n\tint cqe_size;\n\tint eqn;\n\tint err;\n\n\tif (entries < 0 ||\n\t    (entries > (1 << MLX5_CAP_GEN(dev->mdev, log_max_cq_sz))))\n\t\treturn -EINVAL;\n\n\tif (check_cq_create_flags(attr->flags))\n\t\treturn -EOPNOTSUPP;\n\n\tentries = roundup_pow_of_two(entries + 1);\n\tif (entries > (1 << MLX5_CAP_GEN(dev->mdev, log_max_cq_sz)))\n\t\treturn -EINVAL;\n\n\tcq->ibcq.cqe = entries - 1;\n\tmutex_init(&cq->resize_mutex);\n\tspin_lock_init(&cq->lock);\n\tcq->resize_buf = NULL;\n\tcq->resize_umem = NULL;\n\tcq->create_flags = attr->flags;\n\tINIT_LIST_HEAD(&cq->list_send_qp);\n\tINIT_LIST_HEAD(&cq->list_recv_qp);\n\n\tif (udata) {\n\t\terr = create_cq_user(dev, udata, cq, entries, &cqb, &cqe_size,\n\t\t\t\t     &index, &inlen);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\tcqe_size = cache_line_size() == 128 ? 128 : 64;\n\t\terr = create_cq_kernel(dev, cq, entries, cqe_size, &cqb,\n\t\t\t\t       &index, &inlen);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tINIT_WORK(&cq->notify_work, notify_soft_wc_handler);\n\t}\n\n\terr = mlx5_comp_eqn_get(dev->mdev, vector, &eqn);\n\tif (err)\n\t\tgoto err_cqb;\n\n\tcq->cqe_size = cqe_size;\n\n\tcqc = MLX5_ADDR_OF(create_cq_in, cqb, cq_context);\n\tMLX5_SET(cqc, cqc, cqe_sz,\n\t\t cqe_sz_to_mlx_sz(cqe_size,\n\t\t\t\t  cq->private_flags &\n\t\t\t\t  MLX5_IB_CQ_PR_FLAGS_CQE_128_PAD));\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(entries));\n\tMLX5_SET(cqc, cqc, uar_page, index);\n\tMLX5_SET(cqc, cqc, c_eqn_or_apu_element, eqn);\n\tMLX5_SET64(cqc, cqc, dbr_addr, cq->db.dma);\n\tif (cq->create_flags & IB_UVERBS_CQ_FLAGS_IGNORE_OVERRUN)\n\t\tMLX5_SET(cqc, cqc, oi, 1);\n\n\terr = mlx5_core_create_cq(dev->mdev, &cq->mcq, cqb, inlen, out, sizeof(out));\n\tif (err)\n\t\tgoto err_cqb;\n\n\tmlx5_ib_dbg(dev, \"cqn 0x%x\\n\", cq->mcq.cqn);\n\tif (udata)\n\t\tcq->mcq.tasklet_ctx.comp = mlx5_ib_cq_comp;\n\telse\n\t\tcq->mcq.comp  = mlx5_ib_cq_comp;\n\tcq->mcq.event = mlx5_ib_cq_event;\n\n\tINIT_LIST_HEAD(&cq->wc_list);\n\n\tif (udata)\n\t\tif (ib_copy_to_udata(udata, &cq->mcq.cqn, sizeof(__u32))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto err_cmd;\n\t\t}\n\n\n\tkvfree(cqb);\n\treturn 0;\n\nerr_cmd:\n\tmlx5_core_destroy_cq(dev->mdev, &cq->mcq);\n\nerr_cqb:\n\tkvfree(cqb);\n\tif (udata)\n\t\tdestroy_cq_user(cq, udata);\n\telse\n\t\tdestroy_cq_kernel(dev, cq);\n\treturn err;\n}\n\nint mlx5_ib_destroy_cq(struct ib_cq *cq, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->device);\n\tstruct mlx5_ib_cq *mcq = to_mcq(cq);\n\tint ret;\n\n\tret = mlx5_core_destroy_cq(dev->mdev, &mcq->mcq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (udata)\n\t\tdestroy_cq_user(mcq, udata);\n\telse\n\t\tdestroy_cq_kernel(dev, mcq);\n\treturn 0;\n}\n\nstatic int is_equal_rsn(struct mlx5_cqe64 *cqe64, u32 rsn)\n{\n\treturn rsn == (ntohl(cqe64->sop_drop_qpn) & 0xffffff);\n}\n\nvoid __mlx5_ib_cq_clean(struct mlx5_ib_cq *cq, u32 rsn, struct mlx5_ib_srq *srq)\n{\n\tstruct mlx5_cqe64 *cqe64, *dest64;\n\tvoid *cqe, *dest;\n\tu32 prod_index;\n\tint nfreed = 0;\n\tu8 owner_bit;\n\n\tif (!cq)\n\t\treturn;\n\n\t \n\tfor (prod_index = cq->mcq.cons_index; get_sw_cqe(cq, prod_index); prod_index++)\n\t\tif (prod_index == cq->mcq.cons_index + cq->ibcq.cqe)\n\t\t\tbreak;\n\n\t \n\twhile ((int) --prod_index - (int) cq->mcq.cons_index >= 0) {\n\t\tcqe = get_cqe(cq, prod_index & cq->ibcq.cqe);\n\t\tcqe64 = (cq->mcq.cqe_sz == 64) ? cqe : cqe + 64;\n\t\tif (is_equal_rsn(cqe64, rsn)) {\n\t\t\tif (srq && (ntohl(cqe64->srqn) & 0xffffff))\n\t\t\t\tmlx5_ib_free_srq_wqe(srq, be16_to_cpu(cqe64->wqe_counter));\n\t\t\t++nfreed;\n\t\t} else if (nfreed) {\n\t\t\tdest = get_cqe(cq, (prod_index + nfreed) & cq->ibcq.cqe);\n\t\t\tdest64 = (cq->mcq.cqe_sz == 64) ? dest : dest + 64;\n\t\t\towner_bit = dest64->op_own & MLX5_CQE_OWNER_MASK;\n\t\t\tmemcpy(dest, cqe, cq->mcq.cqe_sz);\n\t\t\tdest64->op_own = owner_bit |\n\t\t\t\t(dest64->op_own & ~MLX5_CQE_OWNER_MASK);\n\t\t}\n\t}\n\n\tif (nfreed) {\n\t\tcq->mcq.cons_index += nfreed;\n\t\t \n\t\twmb();\n\t\tmlx5_cq_set_ci(&cq->mcq);\n\t}\n}\n\nvoid mlx5_ib_cq_clean(struct mlx5_ib_cq *cq, u32 qpn, struct mlx5_ib_srq *srq)\n{\n\tif (!cq)\n\t\treturn;\n\n\tspin_lock_irq(&cq->lock);\n\t__mlx5_ib_cq_clean(cq, qpn, srq);\n\tspin_unlock_irq(&cq->lock);\n}\n\nint mlx5_ib_modify_cq(struct ib_cq *cq, u16 cq_count, u16 cq_period)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->device);\n\tstruct mlx5_ib_cq *mcq = to_mcq(cq);\n\tint err;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, cq_moderation))\n\t\treturn -EOPNOTSUPP;\n\n\tif (cq_period > MLX5_MAX_CQ_PERIOD)\n\t\treturn -EINVAL;\n\n\terr = mlx5_core_modify_cq_moderation(dev->mdev, &mcq->mcq,\n\t\t\t\t\t     cq_period, cq_count);\n\tif (err)\n\t\tmlx5_ib_warn(dev, \"modify cq 0x%x failed\\n\", mcq->mcq.cqn);\n\n\treturn err;\n}\n\nstatic int resize_user(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,\n\t\t       int entries, struct ib_udata *udata,\n\t\t       int *cqe_size)\n{\n\tstruct mlx5_ib_resize_cq ucmd;\n\tstruct ib_umem *umem;\n\tint err;\n\n\terr = ib_copy_from_udata(&ucmd, udata, sizeof(ucmd));\n\tif (err)\n\t\treturn err;\n\n\tif (ucmd.reserved0 || ucmd.reserved1)\n\t\treturn -EINVAL;\n\n\t \n\tif (ucmd.cqe_size && SIZE_MAX / ucmd.cqe_size <= entries - 1)\n\t\treturn -EINVAL;\n\n\tumem = ib_umem_get(&dev->ib_dev, ucmd.buf_addr,\n\t\t\t   (size_t)ucmd.cqe_size * entries,\n\t\t\t   IB_ACCESS_LOCAL_WRITE);\n\tif (IS_ERR(umem)) {\n\t\terr = PTR_ERR(umem);\n\t\treturn err;\n\t}\n\n\tcq->resize_umem = umem;\n\t*cqe_size = ucmd.cqe_size;\n\n\treturn 0;\n}\n\nstatic int resize_kernel(struct mlx5_ib_dev *dev, struct mlx5_ib_cq *cq,\n\t\t\t int entries, int cqe_size)\n{\n\tint err;\n\n\tcq->resize_buf = kzalloc(sizeof(*cq->resize_buf), GFP_KERNEL);\n\tif (!cq->resize_buf)\n\t\treturn -ENOMEM;\n\n\terr = alloc_cq_frag_buf(dev, cq->resize_buf, entries, cqe_size);\n\tif (err)\n\t\tgoto ex;\n\n\tinit_cq_frag_buf(cq->resize_buf);\n\n\treturn 0;\n\nex:\n\tkfree(cq->resize_buf);\n\treturn err;\n}\n\nstatic int copy_resize_cqes(struct mlx5_ib_cq *cq)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(cq->ibcq.device);\n\tstruct mlx5_cqe64 *scqe64;\n\tstruct mlx5_cqe64 *dcqe64;\n\tvoid *start_cqe;\n\tvoid *scqe;\n\tvoid *dcqe;\n\tint ssize;\n\tint dsize;\n\tint i;\n\tu8 sw_own;\n\n\tssize = cq->buf.cqe_size;\n\tdsize = cq->resize_buf->cqe_size;\n\tif (ssize != dsize) {\n\t\tmlx5_ib_warn(dev, \"resize from different cqe size is not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ti = cq->mcq.cons_index;\n\tscqe = get_sw_cqe(cq, i);\n\tscqe64 = ssize == 64 ? scqe : scqe + 64;\n\tstart_cqe = scqe;\n\tif (!scqe) {\n\t\tmlx5_ib_warn(dev, \"expected cqe in sw ownership\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (get_cqe_opcode(scqe64) != MLX5_CQE_RESIZE_CQ) {\n\t\tdcqe = mlx5_frag_buf_get_wqe(&cq->resize_buf->fbc,\n\t\t\t\t\t     (i + 1) & cq->resize_buf->nent);\n\t\tdcqe64 = dsize == 64 ? dcqe : dcqe + 64;\n\t\tsw_own = sw_ownership_bit(i + 1, cq->resize_buf->nent);\n\t\tmemcpy(dcqe, scqe, dsize);\n\t\tdcqe64->op_own = (dcqe64->op_own & ~MLX5_CQE_OWNER_MASK) | sw_own;\n\n\t\t++i;\n\t\tscqe = get_sw_cqe(cq, i);\n\t\tscqe64 = ssize == 64 ? scqe : scqe + 64;\n\t\tif (!scqe) {\n\t\t\tmlx5_ib_warn(dev, \"expected cqe in sw ownership\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (scqe == start_cqe) {\n\t\t\tpr_warn(\"resize CQ failed to get resize CQE, CQN 0x%x\\n\",\n\t\t\t\tcq->mcq.cqn);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t++cq->mcq.cons_index;\n\treturn 0;\n}\n\nint mlx5_ib_resize_cq(struct ib_cq *ibcq, int entries, struct ib_udata *udata)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(ibcq->device);\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\tvoid *cqc;\n\tu32 *in;\n\tint err;\n\tint npas;\n\t__be64 *pas;\n\tunsigned int page_offset_quantized = 0;\n\tunsigned int page_shift;\n\tint inlen;\n\tint cqe_size;\n\tunsigned long flags;\n\n\tif (!MLX5_CAP_GEN(dev->mdev, cq_resize)) {\n\t\tpr_info(\"Firmware does not support resize CQ\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (entries < 1 ||\n\t    entries > (1 << MLX5_CAP_GEN(dev->mdev, log_max_cq_sz))) {\n\t\tmlx5_ib_warn(dev, \"wrong entries number %d, max %d\\n\",\n\t\t\t     entries,\n\t\t\t     1 << MLX5_CAP_GEN(dev->mdev, log_max_cq_sz));\n\t\treturn -EINVAL;\n\t}\n\n\tentries = roundup_pow_of_two(entries + 1);\n\tif (entries > (1 << MLX5_CAP_GEN(dev->mdev, log_max_cq_sz)) + 1)\n\t\treturn -EINVAL;\n\n\tif (entries == ibcq->cqe + 1)\n\t\treturn 0;\n\n\tmutex_lock(&cq->resize_mutex);\n\tif (udata) {\n\t\tunsigned long page_size;\n\n\t\terr = resize_user(dev, cq, entries, udata, &cqe_size);\n\t\tif (err)\n\t\t\tgoto ex;\n\n\t\tpage_size = mlx5_umem_find_best_cq_quantized_pgoff(\n\t\t\tcq->resize_umem, cqc, log_page_size,\n\t\t\tMLX5_ADAPTER_PAGE_SHIFT, page_offset, 64,\n\t\t\t&page_offset_quantized);\n\t\tif (!page_size) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto ex_resize;\n\t\t}\n\t\tnpas = ib_umem_num_dma_blocks(cq->resize_umem, page_size);\n\t\tpage_shift = order_base_2(page_size);\n\t} else {\n\t\tstruct mlx5_frag_buf *frag_buf;\n\n\t\tcqe_size = 64;\n\t\terr = resize_kernel(dev, cq, entries, cqe_size);\n\t\tif (err)\n\t\t\tgoto ex;\n\t\tfrag_buf = &cq->resize_buf->frag_buf;\n\t\tnpas = frag_buf->npages;\n\t\tpage_shift = frag_buf->page_shift;\n\t}\n\n\tinlen = MLX5_ST_SZ_BYTES(modify_cq_in) +\n\t\tMLX5_FLD_SZ_BYTES(modify_cq_in, pas[0]) * npas;\n\n\tin = kvzalloc(inlen, GFP_KERNEL);\n\tif (!in) {\n\t\terr = -ENOMEM;\n\t\tgoto ex_resize;\n\t}\n\n\tpas = (__be64 *)MLX5_ADDR_OF(modify_cq_in, in, pas);\n\tif (udata)\n\t\tmlx5_ib_populate_pas(cq->resize_umem, 1UL << page_shift, pas,\n\t\t\t\t     0);\n\telse\n\t\tmlx5_fill_page_frag_array(&cq->resize_buf->frag_buf, pas);\n\n\tMLX5_SET(modify_cq_in, in,\n\t\t modify_field_select_resize_field_select.resize_field_select.resize_field_select,\n\t\t MLX5_MODIFY_CQ_MASK_LOG_SIZE  |\n\t\t MLX5_MODIFY_CQ_MASK_PG_OFFSET |\n\t\t MLX5_MODIFY_CQ_MASK_PG_SIZE);\n\n\tcqc = MLX5_ADDR_OF(modify_cq_in, in, cq_context);\n\n\tMLX5_SET(cqc, cqc, log_page_size,\n\t\t page_shift - MLX5_ADAPTER_PAGE_SHIFT);\n\tMLX5_SET(cqc, cqc, page_offset, page_offset_quantized);\n\tMLX5_SET(cqc, cqc, cqe_sz,\n\t\t cqe_sz_to_mlx_sz(cqe_size,\n\t\t\t\t  cq->private_flags &\n\t\t\t\t  MLX5_IB_CQ_PR_FLAGS_CQE_128_PAD));\n\tMLX5_SET(cqc, cqc, log_cq_size, ilog2(entries));\n\n\tMLX5_SET(modify_cq_in, in, op_mod, MLX5_CQ_OPMOD_RESIZE);\n\tMLX5_SET(modify_cq_in, in, cqn, cq->mcq.cqn);\n\n\terr = mlx5_core_modify_cq(dev->mdev, &cq->mcq, in, inlen);\n\tif (err)\n\t\tgoto ex_alloc;\n\n\tif (udata) {\n\t\tcq->ibcq.cqe = entries - 1;\n\t\tib_umem_release(cq->buf.umem);\n\t\tcq->buf.umem = cq->resize_umem;\n\t\tcq->resize_umem = NULL;\n\t} else {\n\t\tstruct mlx5_ib_cq_buf tbuf;\n\t\tint resized = 0;\n\n\t\tspin_lock_irqsave(&cq->lock, flags);\n\t\tif (cq->resize_buf) {\n\t\t\terr = copy_resize_cqes(cq);\n\t\t\tif (!err) {\n\t\t\t\ttbuf = cq->buf;\n\t\t\t\tcq->buf = *cq->resize_buf;\n\t\t\t\tkfree(cq->resize_buf);\n\t\t\t\tcq->resize_buf = NULL;\n\t\t\t\tresized = 1;\n\t\t\t}\n\t\t}\n\t\tcq->ibcq.cqe = entries - 1;\n\t\tspin_unlock_irqrestore(&cq->lock, flags);\n\t\tif (resized)\n\t\t\tfree_cq_buf(dev, &tbuf);\n\t}\n\tmutex_unlock(&cq->resize_mutex);\n\n\tkvfree(in);\n\treturn 0;\n\nex_alloc:\n\tkvfree(in);\n\nex_resize:\n\tib_umem_release(cq->resize_umem);\n\tif (!udata) {\n\t\tfree_cq_buf(dev, cq->resize_buf);\n\t\tcq->resize_buf = NULL;\n\t}\nex:\n\tmutex_unlock(&cq->resize_mutex);\n\treturn err;\n}\n\nint mlx5_ib_get_cqe_size(struct ib_cq *ibcq)\n{\n\tstruct mlx5_ib_cq *cq;\n\n\tif (!ibcq)\n\t\treturn 128;\n\n\tcq = to_mcq(ibcq);\n\treturn cq->cqe_size;\n}\n\n \nint mlx5_ib_generate_wc(struct ib_cq *ibcq, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_wc *soft_wc;\n\tstruct mlx5_ib_cq *cq = to_mcq(ibcq);\n\tunsigned long flags;\n\n\tsoft_wc = kmalloc(sizeof(*soft_wc), GFP_ATOMIC);\n\tif (!soft_wc)\n\t\treturn -ENOMEM;\n\n\tsoft_wc->wc = *wc;\n\tspin_lock_irqsave(&cq->lock, flags);\n\tlist_add_tail(&soft_wc->list, &cq->wc_list);\n\tif (cq->notify_flags == IB_CQ_NEXT_COMP ||\n\t    wc->status != IB_WC_SUCCESS) {\n\t\tcq->notify_flags = 0;\n\t\tschedule_work(&cq->notify_work);\n\t}\n\tspin_unlock_irqrestore(&cq->lock, flags);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}