{
  "module_name": "odp.c",
  "hash_id": "3e66f983cf40b53b0be7520c3913928abb745128ac04671aa0640e7c3a921882",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/odp.c",
  "human_readable_source": " \n\n#include <rdma/ib_umem_odp.h>\n#include <linux/kernel.h>\n#include <linux/dma-buf.h>\n#include <linux/dma-resv.h>\n\n#include \"mlx5_ib.h\"\n#include \"cmd.h\"\n#include \"umr.h\"\n#include \"qp.h\"\n\n#include <linux/mlx5/eq.h>\n\n \nstruct mlx5_pagefault {\n\tu32\t\t\tbytes_committed;\n\tu32\t\t\ttoken;\n\tu8\t\t\tevent_subtype;\n\tu8\t\t\ttype;\n\tunion {\n\t\t \n\t\tstruct {\n\t\t\t \n\t\t\tu32\tpacket_size;\n\t\t\t \n\t\t\tu32\twq_num;\n\t\t\t \n\t\t\tu16\twqe_index;\n\t\t} wqe;\n\t\t \n\t\tstruct {\n\t\t\tu32\tr_key;\n\t\t\t \n\t\t\tu32\tpacket_size;\n\t\t\tu32\trdma_op_len;\n\t\t\tu64\trdma_va;\n\t\t} rdma;\n\t};\n\n\tstruct mlx5_ib_pf_eq\t*eq;\n\tstruct work_struct\twork;\n};\n\n#define MAX_PREFETCH_LEN (4*1024*1024U)\n\n \n#define MMU_NOTIFIER_TIMEOUT 1000\n\n#define MLX5_IMR_MTT_BITS (30 - PAGE_SHIFT)\n#define MLX5_IMR_MTT_SHIFT (MLX5_IMR_MTT_BITS + PAGE_SHIFT)\n#define MLX5_IMR_MTT_ENTRIES BIT_ULL(MLX5_IMR_MTT_BITS)\n#define MLX5_IMR_MTT_SIZE BIT_ULL(MLX5_IMR_MTT_SHIFT)\n#define MLX5_IMR_MTT_MASK (~(MLX5_IMR_MTT_SIZE - 1))\n\n#define MLX5_KSM_PAGE_SHIFT MLX5_IMR_MTT_SHIFT\n\nstatic u64 mlx5_imr_ksm_entries;\n\nstatic void populate_klm(struct mlx5_klm *pklm, size_t idx, size_t nentries,\n\t\t\tstruct mlx5_ib_mr *imr, int flags)\n{\n\tstruct mlx5_klm *end = pklm + nentries;\n\n\tif (flags & MLX5_IB_UPD_XLT_ZAP) {\n\t\tfor (; pklm != end; pklm++, idx++) {\n\t\t\tpklm->bcount = cpu_to_be32(MLX5_IMR_MTT_SIZE);\n\t\t\tpklm->key = mr_to_mdev(imr)->mkeys.null_mkey;\n\t\t\tpklm->va = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tlockdep_assert_held(&to_ib_umem_odp(imr->umem)->umem_mutex);\n\n\tfor (; pklm != end; pklm++, idx++) {\n\t\tstruct mlx5_ib_mr *mtt = xa_load(&imr->implicit_children, idx);\n\n\t\tpklm->bcount = cpu_to_be32(MLX5_IMR_MTT_SIZE);\n\t\tif (mtt) {\n\t\t\tpklm->key = cpu_to_be32(mtt->ibmr.lkey);\n\t\t\tpklm->va = cpu_to_be64(idx * MLX5_IMR_MTT_SIZE);\n\t\t} else {\n\t\t\tpklm->key = mr_to_mdev(imr)->mkeys.null_mkey;\n\t\t\tpklm->va = 0;\n\t\t}\n\t}\n}\n\nstatic u64 umem_dma_to_mtt(dma_addr_t umem_dma)\n{\n\tu64 mtt_entry = umem_dma & ODP_DMA_ADDR_MASK;\n\n\tif (umem_dma & ODP_READ_ALLOWED_BIT)\n\t\tmtt_entry |= MLX5_IB_MTT_READ;\n\tif (umem_dma & ODP_WRITE_ALLOWED_BIT)\n\t\tmtt_entry |= MLX5_IB_MTT_WRITE;\n\n\treturn mtt_entry;\n}\n\nstatic void populate_mtt(__be64 *pas, size_t idx, size_t nentries,\n\t\t\t struct mlx5_ib_mr *mr, int flags)\n{\n\tstruct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);\n\tdma_addr_t pa;\n\tsize_t i;\n\n\tif (flags & MLX5_IB_UPD_XLT_ZAP)\n\t\treturn;\n\n\tfor (i = 0; i < nentries; i++) {\n\t\tpa = odp->dma_list[idx + i];\n\t\tpas[i] = cpu_to_be64(umem_dma_to_mtt(pa));\n\t}\n}\n\nvoid mlx5_odp_populate_xlt(void *xlt, size_t idx, size_t nentries,\n\t\t\t   struct mlx5_ib_mr *mr, int flags)\n{\n\tif (flags & MLX5_IB_UPD_XLT_INDIRECT) {\n\t\tpopulate_klm(xlt, idx, nentries, mr, flags);\n\t} else {\n\t\tpopulate_mtt(xlt, idx, nentries, mr, flags);\n\t}\n}\n\n \nstatic void free_implicit_child_mr_work(struct work_struct *work)\n{\n\tstruct mlx5_ib_mr *mr =\n\t\tcontainer_of(work, struct mlx5_ib_mr, odp_destroy.work);\n\tstruct mlx5_ib_mr *imr = mr->parent;\n\tstruct ib_umem_odp *odp_imr = to_ib_umem_odp(imr->umem);\n\tstruct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);\n\n\tmlx5r_deref_wait_odp_mkey(&mr->mmkey);\n\n\tmutex_lock(&odp_imr->umem_mutex);\n\tmlx5r_umr_update_xlt(mr->parent,\n\t\t\t     ib_umem_start(odp) >> MLX5_IMR_MTT_SHIFT, 1, 0,\n\t\t\t     MLX5_IB_UPD_XLT_INDIRECT | MLX5_IB_UPD_XLT_ATOMIC);\n\tmutex_unlock(&odp_imr->umem_mutex);\n\tmlx5_ib_dereg_mr(&mr->ibmr, NULL);\n\n\tmlx5r_deref_odp_mkey(&imr->mmkey);\n}\n\nstatic void destroy_unused_implicit_child_mr(struct mlx5_ib_mr *mr)\n{\n\tstruct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);\n\tunsigned long idx = ib_umem_start(odp) >> MLX5_IMR_MTT_SHIFT;\n\tstruct mlx5_ib_mr *imr = mr->parent;\n\n\tif (!refcount_inc_not_zero(&imr->mmkey.usecount))\n\t\treturn;\n\n\txa_erase(&imr->implicit_children, idx);\n\n\t \n\tINIT_WORK(&mr->odp_destroy.work, free_implicit_child_mr_work);\n\tqueue_work(system_unbound_wq, &mr->odp_destroy.work);\n}\n\nstatic bool mlx5_ib_invalidate_range(struct mmu_interval_notifier *mni,\n\t\t\t\t     const struct mmu_notifier_range *range,\n\t\t\t\t     unsigned long cur_seq)\n{\n\tstruct ib_umem_odp *umem_odp =\n\t\tcontainer_of(mni, struct ib_umem_odp, notifier);\n\tstruct mlx5_ib_mr *mr;\n\tconst u64 umr_block_mask = MLX5_UMR_MTT_NUM_ENTRIES_ALIGNMENT - 1;\n\tu64 idx = 0, blk_start_idx = 0;\n\tu64 invalidations = 0;\n\tunsigned long start;\n\tunsigned long end;\n\tint in_block = 0;\n\tu64 addr;\n\n\tif (!mmu_notifier_range_blockable(range))\n\t\treturn false;\n\n\tmutex_lock(&umem_odp->umem_mutex);\n\tmmu_interval_set_seq(mni, cur_seq);\n\t \n\tif (!umem_odp->npages)\n\t\tgoto out;\n\tmr = umem_odp->private;\n\n\tstart = max_t(u64, ib_umem_start(umem_odp), range->start);\n\tend = min_t(u64, ib_umem_end(umem_odp), range->end);\n\n\t \n\tfor (addr = start; addr < end; addr += BIT(umem_odp->page_shift)) {\n\t\tidx = (addr - ib_umem_start(umem_odp)) >> umem_odp->page_shift;\n\t\t \n\t\tif (umem_odp->dma_list[idx] &\n\t\t    (ODP_READ_ALLOWED_BIT | ODP_WRITE_ALLOWED_BIT)) {\n\t\t\tif (!in_block) {\n\t\t\t\tblk_start_idx = idx;\n\t\t\t\tin_block = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tinvalidations += idx - blk_start_idx + 1;\n\t\t} else {\n\t\t\tu64 umr_offset = idx & umr_block_mask;\n\n\t\t\tif (in_block && umr_offset == 0) {\n\t\t\t\tmlx5r_umr_update_xlt(mr, blk_start_idx,\n\t\t\t\t\t\t     idx - blk_start_idx, 0,\n\t\t\t\t\t\t     MLX5_IB_UPD_XLT_ZAP |\n\t\t\t\t\t\t     MLX5_IB_UPD_XLT_ATOMIC);\n\t\t\t\tin_block = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (in_block)\n\t\tmlx5r_umr_update_xlt(mr, blk_start_idx,\n\t\t\t\t     idx - blk_start_idx + 1, 0,\n\t\t\t\t     MLX5_IB_UPD_XLT_ZAP |\n\t\t\t\t     MLX5_IB_UPD_XLT_ATOMIC);\n\n\tmlx5_update_odp_stats(mr, invalidations, invalidations);\n\n\t \n\n\tib_umem_odp_unmap_dma_pages(umem_odp, start, end);\n\n\tif (unlikely(!umem_odp->npages && mr->parent))\n\t\tdestroy_unused_implicit_child_mr(mr);\nout:\n\tmutex_unlock(&umem_odp->umem_mutex);\n\treturn true;\n}\n\nconst struct mmu_interval_notifier_ops mlx5_mn_ops = {\n\t.invalidate = mlx5_ib_invalidate_range,\n};\n\nstatic void internal_fill_odp_caps(struct mlx5_ib_dev *dev)\n{\n\tstruct ib_odp_caps *caps = &dev->odp_caps;\n\n\tmemset(caps, 0, sizeof(*caps));\n\n\tif (!MLX5_CAP_GEN(dev->mdev, pg) || !mlx5r_umr_can_load_pas(dev, 0))\n\t\treturn;\n\n\tcaps->general_caps = IB_ODP_SUPPORT;\n\n\tif (MLX5_CAP_GEN(dev->mdev, umr_extended_translation_offset))\n\t\tdev->odp_max_size = U64_MAX;\n\telse\n\t\tdev->odp_max_size = BIT_ULL(MLX5_MAX_UMR_SHIFT + PAGE_SHIFT);\n\n\tif (MLX5_CAP_ODP(dev->mdev, ud_odp_caps.send))\n\t\tcaps->per_transport_caps.ud_odp_caps |= IB_ODP_SUPPORT_SEND;\n\n\tif (MLX5_CAP_ODP(dev->mdev, ud_odp_caps.srq_receive))\n\t\tcaps->per_transport_caps.ud_odp_caps |= IB_ODP_SUPPORT_SRQ_RECV;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.send))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_SEND;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.receive))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_RECV;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.write))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_WRITE;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.read))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_READ;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.atomic))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_ATOMIC;\n\n\tif (MLX5_CAP_ODP(dev->mdev, rc_odp_caps.srq_receive))\n\t\tcaps->per_transport_caps.rc_odp_caps |= IB_ODP_SUPPORT_SRQ_RECV;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.send))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_SEND;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.receive))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_RECV;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.write))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_WRITE;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.read))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_READ;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.atomic))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_ATOMIC;\n\n\tif (MLX5_CAP_ODP(dev->mdev, xrc_odp_caps.srq_receive))\n\t\tcaps->per_transport_caps.xrc_odp_caps |= IB_ODP_SUPPORT_SRQ_RECV;\n\n\tif (MLX5_CAP_GEN(dev->mdev, fixed_buffer_size) &&\n\t    MLX5_CAP_GEN(dev->mdev, null_mkey) &&\n\t    MLX5_CAP_GEN(dev->mdev, umr_extended_translation_offset) &&\n\t    !MLX5_CAP_GEN(dev->mdev, umr_indirect_mkey_disabled))\n\t\tcaps->general_caps |= IB_ODP_SUPPORT_IMPLICIT;\n}\n\nstatic void mlx5_ib_page_fault_resume(struct mlx5_ib_dev *dev,\n\t\t\t\t      struct mlx5_pagefault *pfault,\n\t\t\t\t      int error)\n{\n\tint wq_num = pfault->event_subtype == MLX5_PFAULT_SUBTYPE_WQE ?\n\t\t     pfault->wqe.wq_num : pfault->token;\n\tu32 in[MLX5_ST_SZ_DW(page_fault_resume_in)] = {};\n\tint err;\n\n\tMLX5_SET(page_fault_resume_in, in, opcode, MLX5_CMD_OP_PAGE_FAULT_RESUME);\n\tMLX5_SET(page_fault_resume_in, in, page_fault_type, pfault->type);\n\tMLX5_SET(page_fault_resume_in, in, token, pfault->token);\n\tMLX5_SET(page_fault_resume_in, in, wq_number, wq_num);\n\tMLX5_SET(page_fault_resume_in, in, error, !!error);\n\n\terr = mlx5_cmd_exec_in(dev->mdev, page_fault_resume, in);\n\tif (err)\n\t\tmlx5_ib_err(dev, \"Failed to resolve the page fault on WQ 0x%x err %d\\n\",\n\t\t\t    wq_num, err);\n}\n\nstatic struct mlx5_ib_mr *implicit_get_child_mr(struct mlx5_ib_mr *imr,\n\t\t\t\t\t\tunsigned long idx)\n{\n\tstruct mlx5_ib_dev *dev = mr_to_mdev(imr);\n\tstruct ib_umem_odp *odp;\n\tstruct mlx5_ib_mr *mr;\n\tstruct mlx5_ib_mr *ret;\n\tint err;\n\n\todp = ib_umem_odp_alloc_child(to_ib_umem_odp(imr->umem),\n\t\t\t\t      idx * MLX5_IMR_MTT_SIZE,\n\t\t\t\t      MLX5_IMR_MTT_SIZE, &mlx5_mn_ops);\n\tif (IS_ERR(odp))\n\t\treturn ERR_CAST(odp);\n\n\tmr = mlx5_mr_cache_alloc(dev, imr->access_flags,\n\t\t\t\t MLX5_MKC_ACCESS_MODE_MTT,\n\t\t\t\t MLX5_IMR_MTT_ENTRIES);\n\tif (IS_ERR(mr)) {\n\t\tib_umem_odp_release(odp);\n\t\treturn mr;\n\t}\n\n\tmr->access_flags = imr->access_flags;\n\tmr->ibmr.pd = imr->ibmr.pd;\n\tmr->ibmr.device = &mr_to_mdev(imr)->ib_dev;\n\tmr->umem = &odp->umem;\n\tmr->ibmr.lkey = mr->mmkey.key;\n\tmr->ibmr.rkey = mr->mmkey.key;\n\tmr->ibmr.iova = idx * MLX5_IMR_MTT_SIZE;\n\tmr->parent = imr;\n\todp->private = mr;\n\n\t \n\trefcount_set(&mr->mmkey.usecount, 2);\n\n\terr = mlx5r_umr_update_xlt(mr, 0,\n\t\t\t\t   MLX5_IMR_MTT_ENTRIES,\n\t\t\t\t   PAGE_SHIFT,\n\t\t\t\t   MLX5_IB_UPD_XLT_ZAP |\n\t\t\t\t   MLX5_IB_UPD_XLT_ENABLE);\n\tif (err) {\n\t\tret = ERR_PTR(err);\n\t\tgoto out_mr;\n\t}\n\n\txa_lock(&imr->implicit_children);\n\tret = __xa_cmpxchg(&imr->implicit_children, idx, NULL, mr,\n\t\t\t   GFP_KERNEL);\n\tif (unlikely(ret)) {\n\t\tif (xa_is_err(ret)) {\n\t\t\tret = ERR_PTR(xa_err(ret));\n\t\t\tgoto out_lock;\n\t\t}\n\t\t \n\t\trefcount_inc(&ret->mmkey.usecount);\n\t\tgoto out_lock;\n\t}\n\txa_unlock(&imr->implicit_children);\n\n\tmlx5_ib_dbg(mr_to_mdev(imr), \"key %x mr %p\\n\", mr->mmkey.key, mr);\n\treturn mr;\n\nout_lock:\n\txa_unlock(&imr->implicit_children);\nout_mr:\n\tmlx5_ib_dereg_mr(&mr->ibmr, NULL);\n\treturn ret;\n}\n\nstruct mlx5_ib_mr *mlx5_ib_alloc_implicit_mr(struct mlx5_ib_pd *pd,\n\t\t\t\t\t     int access_flags)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->ibpd.device);\n\tstruct ib_umem_odp *umem_odp;\n\tstruct mlx5_ib_mr *imr;\n\tint err;\n\n\tif (!mlx5r_umr_can_load_pas(dev, MLX5_IMR_MTT_ENTRIES * PAGE_SIZE))\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\n\tumem_odp = ib_umem_odp_alloc_implicit(&dev->ib_dev, access_flags);\n\tif (IS_ERR(umem_odp))\n\t\treturn ERR_CAST(umem_odp);\n\n\timr = mlx5_mr_cache_alloc(dev, access_flags, MLX5_MKC_ACCESS_MODE_KSM,\n\t\t\t\t  mlx5_imr_ksm_entries);\n\tif (IS_ERR(imr)) {\n\t\tib_umem_odp_release(umem_odp);\n\t\treturn imr;\n\t}\n\n\timr->access_flags = access_flags;\n\timr->ibmr.pd = &pd->ibpd;\n\timr->ibmr.iova = 0;\n\timr->umem = &umem_odp->umem;\n\timr->ibmr.lkey = imr->mmkey.key;\n\timr->ibmr.rkey = imr->mmkey.key;\n\timr->ibmr.device = &dev->ib_dev;\n\timr->is_odp_implicit = true;\n\txa_init(&imr->implicit_children);\n\n\terr = mlx5r_umr_update_xlt(imr, 0,\n\t\t\t\t   mlx5_imr_ksm_entries,\n\t\t\t\t   MLX5_KSM_PAGE_SHIFT,\n\t\t\t\t   MLX5_IB_UPD_XLT_INDIRECT |\n\t\t\t\t   MLX5_IB_UPD_XLT_ZAP |\n\t\t\t\t   MLX5_IB_UPD_XLT_ENABLE);\n\tif (err)\n\t\tgoto out_mr;\n\n\terr = mlx5r_store_odp_mkey(dev, &imr->mmkey);\n\tif (err)\n\t\tgoto out_mr;\n\n\tmlx5_ib_dbg(dev, \"key %x mr %p\\n\", imr->mmkey.key, imr);\n\treturn imr;\nout_mr:\n\tmlx5_ib_err(dev, \"Failed to register MKEY %d\\n\", err);\n\tmlx5_ib_dereg_mr(&imr->ibmr, NULL);\n\treturn ERR_PTR(err);\n}\n\nvoid mlx5_ib_free_odp_mr(struct mlx5_ib_mr *mr)\n{\n\tstruct mlx5_ib_mr *mtt;\n\tunsigned long idx;\n\n\t \n\txa_for_each(&mr->implicit_children, idx, mtt) {\n\t\txa_erase(&mr->implicit_children, idx);\n\t\tmlx5_ib_dereg_mr(&mtt->ibmr, NULL);\n\t}\n}\n\n#define MLX5_PF_FLAGS_DOWNGRADE BIT(1)\n#define MLX5_PF_FLAGS_SNAPSHOT BIT(2)\n#define MLX5_PF_FLAGS_ENABLE BIT(3)\nstatic int pagefault_real_mr(struct mlx5_ib_mr *mr, struct ib_umem_odp *odp,\n\t\t\t     u64 user_va, size_t bcnt, u32 *bytes_mapped,\n\t\t\t     u32 flags)\n{\n\tint page_shift, ret, np;\n\tbool downgrade = flags & MLX5_PF_FLAGS_DOWNGRADE;\n\tu64 access_mask;\n\tu64 start_idx;\n\tbool fault = !(flags & MLX5_PF_FLAGS_SNAPSHOT);\n\tu32 xlt_flags = MLX5_IB_UPD_XLT_ATOMIC;\n\n\tif (flags & MLX5_PF_FLAGS_ENABLE)\n\t\txlt_flags |= MLX5_IB_UPD_XLT_ENABLE;\n\n\tpage_shift = odp->page_shift;\n\tstart_idx = (user_va - ib_umem_start(odp)) >> page_shift;\n\taccess_mask = ODP_READ_ALLOWED_BIT;\n\n\tif (odp->umem.writable && !downgrade)\n\t\taccess_mask |= ODP_WRITE_ALLOWED_BIT;\n\n\tnp = ib_umem_odp_map_dma_and_lock(odp, user_va, bcnt, access_mask, fault);\n\tif (np < 0)\n\t\treturn np;\n\n\t \n\tret = mlx5r_umr_update_xlt(mr, start_idx, np, page_shift, xlt_flags);\n\tmutex_unlock(&odp->umem_mutex);\n\n\tif (ret < 0) {\n\t\tif (ret != -EAGAIN)\n\t\t\tmlx5_ib_err(mr_to_mdev(mr),\n\t\t\t\t    \"Failed to update mkey page tables\\n\");\n\t\tgoto out;\n\t}\n\n\tif (bytes_mapped) {\n\t\tu32 new_mappings = (np << page_shift) -\n\t\t\t(user_va - round_down(user_va, 1 << page_shift));\n\n\t\t*bytes_mapped += min_t(u32, new_mappings, bcnt);\n\t}\n\n\treturn np << (page_shift - PAGE_SHIFT);\n\nout:\n\treturn ret;\n}\n\nstatic int pagefault_implicit_mr(struct mlx5_ib_mr *imr,\n\t\t\t\t struct ib_umem_odp *odp_imr, u64 user_va,\n\t\t\t\t size_t bcnt, u32 *bytes_mapped, u32 flags)\n{\n\tunsigned long end_idx = (user_va + bcnt - 1) >> MLX5_IMR_MTT_SHIFT;\n\tunsigned long upd_start_idx = end_idx + 1;\n\tunsigned long upd_len = 0;\n\tunsigned long npages = 0;\n\tint err;\n\tint ret;\n\n\tif (unlikely(user_va >= mlx5_imr_ksm_entries * MLX5_IMR_MTT_SIZE ||\n\t\t     mlx5_imr_ksm_entries * MLX5_IMR_MTT_SIZE - user_va < bcnt))\n\t\treturn -EFAULT;\n\n\t \n\twhile (bcnt) {\n\t\tunsigned long idx = user_va >> MLX5_IMR_MTT_SHIFT;\n\t\tstruct ib_umem_odp *umem_odp;\n\t\tstruct mlx5_ib_mr *mtt;\n\t\tu64 len;\n\n\t\txa_lock(&imr->implicit_children);\n\t\tmtt = xa_load(&imr->implicit_children, idx);\n\t\tif (unlikely(!mtt)) {\n\t\t\txa_unlock(&imr->implicit_children);\n\t\t\tmtt = implicit_get_child_mr(imr, idx);\n\t\t\tif (IS_ERR(mtt)) {\n\t\t\t\tret = PTR_ERR(mtt);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tupd_start_idx = min(upd_start_idx, idx);\n\t\t\tupd_len = idx - upd_start_idx + 1;\n\t\t} else {\n\t\t\trefcount_inc(&mtt->mmkey.usecount);\n\t\t\txa_unlock(&imr->implicit_children);\n\t\t}\n\n\t\tumem_odp = to_ib_umem_odp(mtt->umem);\n\t\tlen = min_t(u64, user_va + bcnt, ib_umem_end(umem_odp)) -\n\t\t      user_va;\n\n\t\tret = pagefault_real_mr(mtt, umem_odp, user_va, len,\n\t\t\t\t\tbytes_mapped, flags);\n\n\t\tmlx5r_deref_odp_mkey(&mtt->mmkey);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tuser_va += len;\n\t\tbcnt -= len;\n\t\tnpages += ret;\n\t}\n\n\tret = npages;\n\n\t \nout:\n\tif (likely(!upd_len))\n\t\treturn ret;\n\n\t \n\tmutex_lock(&odp_imr->umem_mutex);\n\terr = mlx5r_umr_update_xlt(imr, upd_start_idx, upd_len, 0,\n\t\t\t\t   MLX5_IB_UPD_XLT_INDIRECT |\n\t\t\t\t\t  MLX5_IB_UPD_XLT_ATOMIC);\n\tmutex_unlock(&odp_imr->umem_mutex);\n\tif (err) {\n\t\tmlx5_ib_err(mr_to_mdev(imr), \"Failed to update PAS\\n\");\n\t\treturn err;\n\t}\n\treturn ret;\n}\n\nstatic int pagefault_dmabuf_mr(struct mlx5_ib_mr *mr, size_t bcnt,\n\t\t\t       u32 *bytes_mapped, u32 flags)\n{\n\tstruct ib_umem_dmabuf *umem_dmabuf = to_ib_umem_dmabuf(mr->umem);\n\tu32 xlt_flags = 0;\n\tint err;\n\tunsigned int page_size;\n\n\tif (flags & MLX5_PF_FLAGS_ENABLE)\n\t\txlt_flags |= MLX5_IB_UPD_XLT_ENABLE;\n\n\tdma_resv_lock(umem_dmabuf->attach->dmabuf->resv, NULL);\n\terr = ib_umem_dmabuf_map_pages(umem_dmabuf);\n\tif (err) {\n\t\tdma_resv_unlock(umem_dmabuf->attach->dmabuf->resv);\n\t\treturn err;\n\t}\n\n\tpage_size = mlx5_umem_find_best_pgsz(&umem_dmabuf->umem, mkc,\n\t\t\t\t\t     log_page_size, 0,\n\t\t\t\t\t     umem_dmabuf->umem.iova);\n\tif (unlikely(page_size < PAGE_SIZE)) {\n\t\tib_umem_dmabuf_unmap_pages(umem_dmabuf);\n\t\terr = -EINVAL;\n\t} else {\n\t\terr = mlx5r_umr_update_mr_pas(mr, xlt_flags);\n\t}\n\tdma_resv_unlock(umem_dmabuf->attach->dmabuf->resv);\n\n\tif (err)\n\t\treturn err;\n\n\tif (bytes_mapped)\n\t\t*bytes_mapped += bcnt;\n\n\treturn ib_umem_num_pages(mr->umem);\n}\n\n \nstatic int pagefault_mr(struct mlx5_ib_mr *mr, u64 io_virt, size_t bcnt,\n\t\t\tu32 *bytes_mapped, u32 flags)\n{\n\tstruct ib_umem_odp *odp = to_ib_umem_odp(mr->umem);\n\n\tif (unlikely(io_virt < mr->ibmr.iova))\n\t\treturn -EFAULT;\n\n\tif (mr->umem->is_dmabuf)\n\t\treturn pagefault_dmabuf_mr(mr, bcnt, bytes_mapped, flags);\n\n\tif (!odp->is_implicit_odp) {\n\t\tu64 user_va;\n\n\t\tif (check_add_overflow(io_virt - mr->ibmr.iova,\n\t\t\t\t       (u64)odp->umem.address, &user_va))\n\t\t\treturn -EFAULT;\n\t\tif (unlikely(user_va >= ib_umem_end(odp) ||\n\t\t\t     ib_umem_end(odp) - user_va < bcnt))\n\t\t\treturn -EFAULT;\n\t\treturn pagefault_real_mr(mr, odp, user_va, bcnt, bytes_mapped,\n\t\t\t\t\t flags);\n\t}\n\treturn pagefault_implicit_mr(mr, odp, io_virt, bcnt, bytes_mapped,\n\t\t\t\t     flags);\n}\n\nint mlx5_ib_init_odp_mr(struct mlx5_ib_mr *mr)\n{\n\tint ret;\n\n\tret = pagefault_real_mr(mr, to_ib_umem_odp(mr->umem), mr->umem->address,\n\t\t\t\tmr->umem->length, NULL,\n\t\t\t\tMLX5_PF_FLAGS_SNAPSHOT | MLX5_PF_FLAGS_ENABLE);\n\treturn ret >= 0 ? 0 : ret;\n}\n\nint mlx5_ib_init_dmabuf_mr(struct mlx5_ib_mr *mr)\n{\n\tint ret;\n\n\tret = pagefault_dmabuf_mr(mr, mr->umem->length, NULL,\n\t\t\t\t  MLX5_PF_FLAGS_ENABLE);\n\n\treturn ret >= 0 ? 0 : ret;\n}\n\nstruct pf_frame {\n\tstruct pf_frame *next;\n\tu32 key;\n\tu64 io_virt;\n\tsize_t bcnt;\n\tint depth;\n};\n\nstatic bool mkey_is_eq(struct mlx5_ib_mkey *mmkey, u32 key)\n{\n\tif (!mmkey)\n\t\treturn false;\n\tif (mmkey->type == MLX5_MKEY_MW ||\n\t    mmkey->type == MLX5_MKEY_INDIRECT_DEVX)\n\t\treturn mlx5_base_mkey(mmkey->key) == mlx5_base_mkey(key);\n\treturn mmkey->key == key;\n}\n\n \nstatic int pagefault_single_data_segment(struct mlx5_ib_dev *dev,\n\t\t\t\t\t struct ib_pd *pd, u32 key,\n\t\t\t\t\t u64 io_virt, size_t bcnt,\n\t\t\t\t\t u32 *bytes_committed,\n\t\t\t\t\t u32 *bytes_mapped)\n{\n\tint npages = 0, ret, i, outlen, cur_outlen = 0, depth = 0;\n\tstruct pf_frame *head = NULL, *frame;\n\tstruct mlx5_ib_mkey *mmkey;\n\tstruct mlx5_ib_mr *mr;\n\tstruct mlx5_klm *pklm;\n\tu32 *out = NULL;\n\tsize_t offset;\n\n\tio_virt += *bytes_committed;\n\tbcnt -= *bytes_committed;\n\nnext_mr:\n\txa_lock(&dev->odp_mkeys);\n\tmmkey = xa_load(&dev->odp_mkeys, mlx5_base_mkey(key));\n\tif (!mmkey) {\n\t\txa_unlock(&dev->odp_mkeys);\n\t\tmlx5_ib_dbg(\n\t\t\tdev,\n\t\t\t\"skipping non ODP MR (lkey=0x%06x) in page fault handler.\\n\",\n\t\t\tkey);\n\t\tif (bytes_mapped)\n\t\t\t*bytes_mapped += bcnt;\n\t\t \n\t\tret = 0;\n\t\tgoto end;\n\t}\n\trefcount_inc(&mmkey->usecount);\n\txa_unlock(&dev->odp_mkeys);\n\n\tif (!mkey_is_eq(mmkey, key)) {\n\t\tmlx5_ib_dbg(dev, \"failed to find mkey %x\\n\", key);\n\t\tret = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tswitch (mmkey->type) {\n\tcase MLX5_MKEY_MR:\n\t\tmr = container_of(mmkey, struct mlx5_ib_mr, mmkey);\n\n\t\tret = pagefault_mr(mr, io_virt, bcnt, bytes_mapped, 0);\n\t\tif (ret < 0)\n\t\t\tgoto end;\n\n\t\tmlx5_update_odp_stats(mr, faults, ret);\n\n\t\tnpages += ret;\n\t\tret = 0;\n\t\tbreak;\n\n\tcase MLX5_MKEY_MW:\n\tcase MLX5_MKEY_INDIRECT_DEVX:\n\t\tif (depth >= MLX5_CAP_GEN(dev->mdev, max_indirection)) {\n\t\t\tmlx5_ib_dbg(dev, \"indirection level exceeded\\n\");\n\t\t\tret = -EFAULT;\n\t\t\tgoto end;\n\t\t}\n\n\t\toutlen = MLX5_ST_SZ_BYTES(query_mkey_out) +\n\t\t\tsizeof(*pklm) * (mmkey->ndescs - 2);\n\n\t\tif (outlen > cur_outlen) {\n\t\t\tkfree(out);\n\t\t\tout = kzalloc(outlen, GFP_KERNEL);\n\t\t\tif (!out) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tcur_outlen = outlen;\n\t\t}\n\n\t\tpklm = (struct mlx5_klm *)MLX5_ADDR_OF(query_mkey_out, out,\n\t\t\t\t\t\t       bsf0_klm0_pas_mtt0_1);\n\n\t\tret = mlx5_core_query_mkey(dev->mdev, mmkey->key, out, outlen);\n\t\tif (ret)\n\t\t\tgoto end;\n\n\t\toffset = io_virt - MLX5_GET64(query_mkey_out, out,\n\t\t\t\t\t      memory_key_mkey_entry.start_addr);\n\n\t\tfor (i = 0; bcnt && i < mmkey->ndescs; i++, pklm++) {\n\t\t\tif (offset >= be32_to_cpu(pklm->bcount)) {\n\t\t\t\toffset -= be32_to_cpu(pklm->bcount);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tframe = kzalloc(sizeof(*frame), GFP_KERNEL);\n\t\t\tif (!frame) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\tframe->key = be32_to_cpu(pklm->key);\n\t\t\tframe->io_virt = be64_to_cpu(pklm->va) + offset;\n\t\t\tframe->bcnt = min_t(size_t, bcnt,\n\t\t\t\t\t    be32_to_cpu(pklm->bcount) - offset);\n\t\t\tframe->depth = depth + 1;\n\t\t\tframe->next = head;\n\t\t\thead = frame;\n\n\t\t\tbcnt -= frame->bcnt;\n\t\t\toffset = 0;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmlx5_ib_dbg(dev, \"wrong mkey type %d\\n\", mmkey->type);\n\t\tret = -EFAULT;\n\t\tgoto end;\n\t}\n\n\tif (head) {\n\t\tframe = head;\n\t\thead = frame->next;\n\n\t\tkey = frame->key;\n\t\tio_virt = frame->io_virt;\n\t\tbcnt = frame->bcnt;\n\t\tdepth = frame->depth;\n\t\tkfree(frame);\n\n\t\tmlx5r_deref_odp_mkey(mmkey);\n\t\tgoto next_mr;\n\t}\n\nend:\n\tif (mmkey)\n\t\tmlx5r_deref_odp_mkey(mmkey);\n\twhile (head) {\n\t\tframe = head;\n\t\thead = frame->next;\n\t\tkfree(frame);\n\t}\n\tkfree(out);\n\n\t*bytes_committed = 0;\n\treturn ret ? ret : npages;\n}\n\n \nstatic int pagefault_data_segments(struct mlx5_ib_dev *dev,\n\t\t\t\t   struct mlx5_pagefault *pfault,\n\t\t\t\t   void *wqe,\n\t\t\t\t   void *wqe_end, u32 *bytes_mapped,\n\t\t\t\t   u32 *total_wqe_bytes, bool receive_queue)\n{\n\tint ret = 0, npages = 0;\n\tu64 io_virt;\n\t__be32 key;\n\tu32 byte_count;\n\tsize_t bcnt;\n\tint inline_segment;\n\n\tif (bytes_mapped)\n\t\t*bytes_mapped = 0;\n\tif (total_wqe_bytes)\n\t\t*total_wqe_bytes = 0;\n\n\twhile (wqe < wqe_end) {\n\t\tstruct mlx5_wqe_data_seg *dseg = wqe;\n\n\t\tio_virt = be64_to_cpu(dseg->addr);\n\t\tkey = dseg->lkey;\n\t\tbyte_count = be32_to_cpu(dseg->byte_count);\n\t\tinline_segment = !!(byte_count &  MLX5_INLINE_SEG);\n\t\tbcnt\t       = byte_count & ~MLX5_INLINE_SEG;\n\n\t\tif (inline_segment) {\n\t\t\tbcnt = bcnt & MLX5_WQE_INLINE_SEG_BYTE_COUNT_MASK;\n\t\t\twqe += ALIGN(sizeof(struct mlx5_wqe_inline_seg) + bcnt,\n\t\t\t\t     16);\n\t\t} else {\n\t\t\twqe += sizeof(*dseg);\n\t\t}\n\n\t\t \n\t\tif (receive_queue && bcnt == 0 &&\n\t\t    key == dev->mkeys.terminate_scatter_list_mkey &&\n\t\t    io_virt == 0)\n\t\t\tbreak;\n\n\t\tif (!inline_segment && total_wqe_bytes) {\n\t\t\t*total_wqe_bytes += bcnt - min_t(size_t, bcnt,\n\t\t\t\t\tpfault->bytes_committed);\n\t\t}\n\n\t\t \n\t\tif (bcnt == 0)\n\t\t\tbcnt = 1U << 31;\n\n\t\tif (inline_segment || bcnt <= pfault->bytes_committed) {\n\t\t\tpfault->bytes_committed -=\n\t\t\t\tmin_t(size_t, bcnt,\n\t\t\t\t      pfault->bytes_committed);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = pagefault_single_data_segment(dev, NULL, be32_to_cpu(key),\n\t\t\t\t\t\t    io_virt, bcnt,\n\t\t\t\t\t\t    &pfault->bytes_committed,\n\t\t\t\t\t\t    bytes_mapped);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tnpages += ret;\n\t}\n\n\treturn ret < 0 ? ret : npages;\n}\n\n \nstatic int mlx5_ib_mr_initiator_pfault_handler(\n\tstruct mlx5_ib_dev *dev, struct mlx5_pagefault *pfault,\n\tstruct mlx5_ib_qp *qp, void **wqe, void **wqe_end, int wqe_length)\n{\n\tstruct mlx5_wqe_ctrl_seg *ctrl = *wqe;\n\tu16 wqe_index = pfault->wqe.wqe_index;\n\tstruct mlx5_base_av *av;\n\tunsigned ds, opcode;\n\tu32 qpn = qp->trans_qp.base.mqp.qpn;\n\n\tds = be32_to_cpu(ctrl->qpn_ds) & MLX5_WQE_CTRL_DS_MASK;\n\tif (ds * MLX5_WQE_DS_UNITS > wqe_length) {\n\t\tmlx5_ib_err(dev, \"Unable to read the complete WQE. ds = 0x%x, ret = 0x%x\\n\",\n\t\t\t    ds, wqe_length);\n\t\treturn -EFAULT;\n\t}\n\n\tif (ds == 0) {\n\t\tmlx5_ib_err(dev, \"Got WQE with zero DS. wqe_index=%x, qpn=%x\\n\",\n\t\t\t    wqe_index, qpn);\n\t\treturn -EFAULT;\n\t}\n\n\t*wqe_end = *wqe + ds * MLX5_WQE_DS_UNITS;\n\t*wqe += sizeof(*ctrl);\n\n\topcode = be32_to_cpu(ctrl->opmod_idx_opcode) &\n\t\t MLX5_WQE_CTRL_OPCODE_MASK;\n\n\tif (qp->type == IB_QPT_XRC_INI)\n\t\t*wqe += sizeof(struct mlx5_wqe_xrc_seg);\n\n\tif (qp->type == IB_QPT_UD || qp->type == MLX5_IB_QPT_DCI) {\n\t\tav = *wqe;\n\t\tif (av->dqp_dct & cpu_to_be32(MLX5_EXTENDED_UD_AV))\n\t\t\t*wqe += sizeof(struct mlx5_av);\n\t\telse\n\t\t\t*wqe += sizeof(struct mlx5_base_av);\n\t}\n\n\tswitch (opcode) {\n\tcase MLX5_OPCODE_RDMA_WRITE:\n\tcase MLX5_OPCODE_RDMA_WRITE_IMM:\n\tcase MLX5_OPCODE_RDMA_READ:\n\t\t*wqe += sizeof(struct mlx5_wqe_raddr_seg);\n\t\tbreak;\n\tcase MLX5_OPCODE_ATOMIC_CS:\n\tcase MLX5_OPCODE_ATOMIC_FA:\n\t\t*wqe += sizeof(struct mlx5_wqe_raddr_seg);\n\t\t*wqe += sizeof(struct mlx5_wqe_atomic_seg);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mlx5_ib_mr_responder_pfault_handler_srq(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t   struct mlx5_ib_srq *srq,\n\t\t\t\t\t\t   void **wqe, void **wqe_end,\n\t\t\t\t\t\t   int wqe_length)\n{\n\tint wqe_size = 1 << srq->msrq.wqe_shift;\n\n\tif (wqe_size > wqe_length) {\n\t\tmlx5_ib_err(dev, \"Couldn't read all of the receive WQE's content\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t*wqe_end = *wqe + wqe_size;\n\t*wqe += sizeof(struct mlx5_wqe_srq_next_seg);\n\n\treturn 0;\n}\n\nstatic int mlx5_ib_mr_responder_pfault_handler_rq(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t  struct mlx5_ib_qp *qp,\n\t\t\t\t\t\t  void *wqe, void **wqe_end,\n\t\t\t\t\t\t  int wqe_length)\n{\n\tstruct mlx5_ib_wq *wq = &qp->rq;\n\tint wqe_size = 1 << wq->wqe_shift;\n\n\tif (qp->flags_en & MLX5_QP_FLAG_SIGNATURE) {\n\t\tmlx5_ib_err(dev, \"ODP fault with WQE signatures is not supported\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (wqe_size > wqe_length) {\n\t\tmlx5_ib_err(dev, \"Couldn't read all of the receive WQE's content\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\t*wqe_end = wqe + wqe_size;\n\n\treturn 0;\n}\n\nstatic inline struct mlx5_core_rsc_common *odp_get_rsc(struct mlx5_ib_dev *dev,\n\t\t\t\t\t\t       u32 wq_num, int pf_type)\n{\n\tstruct mlx5_core_rsc_common *common = NULL;\n\tstruct mlx5_core_srq *srq;\n\n\tswitch (pf_type) {\n\tcase MLX5_WQE_PF_TYPE_RMP:\n\t\tsrq = mlx5_cmd_get_srq(dev, wq_num);\n\t\tif (srq)\n\t\t\tcommon = &srq->common;\n\t\tbreak;\n\tcase MLX5_WQE_PF_TYPE_REQ_SEND_OR_WRITE:\n\tcase MLX5_WQE_PF_TYPE_RESP:\n\tcase MLX5_WQE_PF_TYPE_REQ_READ_OR_ATOMIC:\n\t\tcommon = mlx5_core_res_hold(dev, wq_num, MLX5_RES_QP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn common;\n}\n\nstatic inline struct mlx5_ib_qp *res_to_qp(struct mlx5_core_rsc_common *res)\n{\n\tstruct mlx5_core_qp *mqp = (struct mlx5_core_qp *)res;\n\n\treturn to_mibqp(mqp);\n}\n\nstatic inline struct mlx5_ib_srq *res_to_srq(struct mlx5_core_rsc_common *res)\n{\n\tstruct mlx5_core_srq *msrq =\n\t\tcontainer_of(res, struct mlx5_core_srq, common);\n\n\treturn to_mibsrq(msrq);\n}\n\nstatic void mlx5_ib_mr_wqe_pfault_handler(struct mlx5_ib_dev *dev,\n\t\t\t\t\t  struct mlx5_pagefault *pfault)\n{\n\tbool sq = pfault->type & MLX5_PFAULT_REQUESTOR;\n\tu16 wqe_index = pfault->wqe.wqe_index;\n\tvoid *wqe, *wqe_start = NULL, *wqe_end = NULL;\n\tu32 bytes_mapped, total_wqe_bytes;\n\tstruct mlx5_core_rsc_common *res;\n\tint resume_with_error = 1;\n\tstruct mlx5_ib_qp *qp;\n\tsize_t bytes_copied;\n\tint ret = 0;\n\n\tres = odp_get_rsc(dev, pfault->wqe.wq_num, pfault->type);\n\tif (!res) {\n\t\tmlx5_ib_dbg(dev, \"wqe page fault for missing resource %d\\n\", pfault->wqe.wq_num);\n\t\treturn;\n\t}\n\n\tif (res->res != MLX5_RES_QP && res->res != MLX5_RES_SRQ &&\n\t    res->res != MLX5_RES_XSRQ) {\n\t\tmlx5_ib_err(dev, \"wqe page fault for unsupported type %d\\n\",\n\t\t\t    pfault->type);\n\t\tgoto resolve_page_fault;\n\t}\n\n\twqe_start = (void *)__get_free_page(GFP_KERNEL);\n\tif (!wqe_start) {\n\t\tmlx5_ib_err(dev, \"Error allocating memory for IO page fault handling.\\n\");\n\t\tgoto resolve_page_fault;\n\t}\n\n\twqe = wqe_start;\n\tqp = (res->res == MLX5_RES_QP) ? res_to_qp(res) : NULL;\n\tif (qp && sq) {\n\t\tret = mlx5_ib_read_wqe_sq(qp, wqe_index, wqe, PAGE_SIZE,\n\t\t\t\t\t  &bytes_copied);\n\t\tif (ret)\n\t\t\tgoto read_user;\n\t\tret = mlx5_ib_mr_initiator_pfault_handler(\n\t\t\tdev, pfault, qp, &wqe, &wqe_end, bytes_copied);\n\t} else if (qp && !sq) {\n\t\tret = mlx5_ib_read_wqe_rq(qp, wqe_index, wqe, PAGE_SIZE,\n\t\t\t\t\t  &bytes_copied);\n\t\tif (ret)\n\t\t\tgoto read_user;\n\t\tret = mlx5_ib_mr_responder_pfault_handler_rq(\n\t\t\tdev, qp, wqe, &wqe_end, bytes_copied);\n\t} else if (!qp) {\n\t\tstruct mlx5_ib_srq *srq = res_to_srq(res);\n\n\t\tret = mlx5_ib_read_wqe_srq(srq, wqe_index, wqe, PAGE_SIZE,\n\t\t\t\t\t   &bytes_copied);\n\t\tif (ret)\n\t\t\tgoto read_user;\n\t\tret = mlx5_ib_mr_responder_pfault_handler_srq(\n\t\t\tdev, srq, &wqe, &wqe_end, bytes_copied);\n\t}\n\n\tif (ret < 0 || wqe >= wqe_end)\n\t\tgoto resolve_page_fault;\n\n\tret = pagefault_data_segments(dev, pfault, wqe, wqe_end, &bytes_mapped,\n\t\t\t\t      &total_wqe_bytes, !sq);\n\tif (ret == -EAGAIN)\n\t\tgoto out;\n\n\tif (ret < 0 || total_wqe_bytes > bytes_mapped)\n\t\tgoto resolve_page_fault;\n\nout:\n\tret = 0;\n\tresume_with_error = 0;\n\nread_user:\n\tif (ret)\n\t\tmlx5_ib_err(\n\t\t\tdev,\n\t\t\t\"Failed reading a WQE following page fault, error %d, wqe_index %x, qpn %x\\n\",\n\t\t\tret, wqe_index, pfault->token);\n\nresolve_page_fault:\n\tmlx5_ib_page_fault_resume(dev, pfault, resume_with_error);\n\tmlx5_ib_dbg(dev, \"PAGE FAULT completed. QP 0x%x resume_with_error=%d, type: 0x%x\\n\",\n\t\t    pfault->wqe.wq_num, resume_with_error,\n\t\t    pfault->type);\n\tmlx5_core_res_put(res);\n\tfree_page((unsigned long)wqe_start);\n}\n\nstatic int pages_in_range(u64 address, u32 length)\n{\n\treturn (ALIGN(address + length, PAGE_SIZE) -\n\t\t(address & PAGE_MASK)) >> PAGE_SHIFT;\n}\n\nstatic void mlx5_ib_mr_rdma_pfault_handler(struct mlx5_ib_dev *dev,\n\t\t\t\t\t   struct mlx5_pagefault *pfault)\n{\n\tu64 address;\n\tu32 length;\n\tu32 prefetch_len = pfault->bytes_committed;\n\tint prefetch_activated = 0;\n\tu32 rkey = pfault->rdma.r_key;\n\tint ret;\n\n\t \n\tpfault->rdma.rdma_va += pfault->bytes_committed;\n\tpfault->rdma.rdma_op_len -= min(pfault->bytes_committed,\n\t\t\t\t\t pfault->rdma.rdma_op_len);\n\tpfault->bytes_committed = 0;\n\n\taddress = pfault->rdma.rdma_va;\n\tlength  = pfault->rdma.rdma_op_len;\n\n\t \n\tif (length == 0) {\n\t\tprefetch_activated = 1;\n\t\tlength = pfault->rdma.packet_size;\n\t\tprefetch_len = min(MAX_PREFETCH_LEN, prefetch_len);\n\t}\n\n\tret = pagefault_single_data_segment(dev, NULL, rkey, address, length,\n\t\t\t\t\t    &pfault->bytes_committed, NULL);\n\tif (ret == -EAGAIN) {\n\t\t \n\t\tprefetch_activated = 0;\n\t} else if (ret < 0 || pages_in_range(address, length) > ret) {\n\t\tmlx5_ib_page_fault_resume(dev, pfault, 1);\n\t\tif (ret != -ENOENT)\n\t\t\tmlx5_ib_dbg(dev, \"PAGE FAULT error %d. QP 0x%x, type: 0x%x\\n\",\n\t\t\t\t    ret, pfault->token, pfault->type);\n\t\treturn;\n\t}\n\n\tmlx5_ib_page_fault_resume(dev, pfault, 0);\n\tmlx5_ib_dbg(dev, \"PAGE FAULT completed. QP 0x%x, type: 0x%x, prefetch_activated: %d\\n\",\n\t\t    pfault->token, pfault->type,\n\t\t    prefetch_activated);\n\n\t \n\n\tif (prefetch_activated) {\n\t\tu32 bytes_committed = 0;\n\n\t\tret = pagefault_single_data_segment(dev, NULL, rkey, address,\n\t\t\t\t\t\t    prefetch_len,\n\t\t\t\t\t\t    &bytes_committed, NULL);\n\t\tif (ret < 0 && ret != -EAGAIN) {\n\t\t\tmlx5_ib_dbg(dev, \"Prefetch failed. ret: %d, QP 0x%x, address: 0x%.16llx, length = 0x%.16x\\n\",\n\t\t\t\t    ret, pfault->token, address, prefetch_len);\n\t\t}\n\t}\n}\n\nstatic void mlx5_ib_pfault(struct mlx5_ib_dev *dev, struct mlx5_pagefault *pfault)\n{\n\tu8 event_subtype = pfault->event_subtype;\n\n\tswitch (event_subtype) {\n\tcase MLX5_PFAULT_SUBTYPE_WQE:\n\t\tmlx5_ib_mr_wqe_pfault_handler(dev, pfault);\n\t\tbreak;\n\tcase MLX5_PFAULT_SUBTYPE_RDMA:\n\t\tmlx5_ib_mr_rdma_pfault_handler(dev, pfault);\n\t\tbreak;\n\tdefault:\n\t\tmlx5_ib_err(dev, \"Invalid page fault event subtype: 0x%x\\n\",\n\t\t\t    event_subtype);\n\t\tmlx5_ib_page_fault_resume(dev, pfault, 1);\n\t}\n}\n\nstatic void mlx5_ib_eqe_pf_action(struct work_struct *work)\n{\n\tstruct mlx5_pagefault *pfault = container_of(work,\n\t\t\t\t\t\t     struct mlx5_pagefault,\n\t\t\t\t\t\t     work);\n\tstruct mlx5_ib_pf_eq *eq = pfault->eq;\n\n\tmlx5_ib_pfault(eq->dev, pfault);\n\tmempool_free(pfault, eq->pool);\n}\n\nstatic void mlx5_ib_eq_pf_process(struct mlx5_ib_pf_eq *eq)\n{\n\tstruct mlx5_eqe_page_fault *pf_eqe;\n\tstruct mlx5_pagefault *pfault;\n\tstruct mlx5_eqe *eqe;\n\tint cc = 0;\n\n\twhile ((eqe = mlx5_eq_get_eqe(eq->core, cc))) {\n\t\tpfault = mempool_alloc(eq->pool, GFP_ATOMIC);\n\t\tif (!pfault) {\n\t\t\tschedule_work(&eq->work);\n\t\t\tbreak;\n\t\t}\n\n\t\tpf_eqe = &eqe->data.page_fault;\n\t\tpfault->event_subtype = eqe->sub_type;\n\t\tpfault->bytes_committed = be32_to_cpu(pf_eqe->bytes_committed);\n\n\t\tmlx5_ib_dbg(eq->dev,\n\t\t\t    \"PAGE_FAULT: subtype: 0x%02x, bytes_committed: 0x%06x\\n\",\n\t\t\t    eqe->sub_type, pfault->bytes_committed);\n\n\t\tswitch (eqe->sub_type) {\n\t\tcase MLX5_PFAULT_SUBTYPE_RDMA:\n\t\t\t \n\t\t\tpfault->type =\n\t\t\t\tbe32_to_cpu(pf_eqe->rdma.pftype_token) >> 24;\n\t\t\tpfault->token =\n\t\t\t\tbe32_to_cpu(pf_eqe->rdma.pftype_token) &\n\t\t\t\tMLX5_24BIT_MASK;\n\t\t\tpfault->rdma.r_key =\n\t\t\t\tbe32_to_cpu(pf_eqe->rdma.r_key);\n\t\t\tpfault->rdma.packet_size =\n\t\t\t\tbe16_to_cpu(pf_eqe->rdma.packet_length);\n\t\t\tpfault->rdma.rdma_op_len =\n\t\t\t\tbe32_to_cpu(pf_eqe->rdma.rdma_op_len);\n\t\t\tpfault->rdma.rdma_va =\n\t\t\t\tbe64_to_cpu(pf_eqe->rdma.rdma_va);\n\t\t\tmlx5_ib_dbg(eq->dev,\n\t\t\t\t    \"PAGE_FAULT: type:0x%x, token: 0x%06x, r_key: 0x%08x\\n\",\n\t\t\t\t    pfault->type, pfault->token,\n\t\t\t\t    pfault->rdma.r_key);\n\t\t\tmlx5_ib_dbg(eq->dev,\n\t\t\t\t    \"PAGE_FAULT: rdma_op_len: 0x%08x, rdma_va: 0x%016llx\\n\",\n\t\t\t\t    pfault->rdma.rdma_op_len,\n\t\t\t\t    pfault->rdma.rdma_va);\n\t\t\tbreak;\n\n\t\tcase MLX5_PFAULT_SUBTYPE_WQE:\n\t\t\t \n\t\t\tpfault->type =\n\t\t\t\t(be32_to_cpu(pf_eqe->wqe.pftype_wq) >> 24) & 0x7;\n\t\t\tpfault->token =\n\t\t\t\tbe32_to_cpu(pf_eqe->wqe.token);\n\t\t\tpfault->wqe.wq_num =\n\t\t\t\tbe32_to_cpu(pf_eqe->wqe.pftype_wq) &\n\t\t\t\tMLX5_24BIT_MASK;\n\t\t\tpfault->wqe.wqe_index =\n\t\t\t\tbe16_to_cpu(pf_eqe->wqe.wqe_index);\n\t\t\tpfault->wqe.packet_size =\n\t\t\t\tbe16_to_cpu(pf_eqe->wqe.packet_length);\n\t\t\tmlx5_ib_dbg(eq->dev,\n\t\t\t\t    \"PAGE_FAULT: type:0x%x, token: 0x%06x, wq_num: 0x%06x, wqe_index: 0x%04x\\n\",\n\t\t\t\t    pfault->type, pfault->token,\n\t\t\t\t    pfault->wqe.wq_num,\n\t\t\t\t    pfault->wqe.wqe_index);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tmlx5_ib_warn(eq->dev,\n\t\t\t\t     \"Unsupported page fault event sub-type: 0x%02hhx\\n\",\n\t\t\t\t     eqe->sub_type);\n\t\t\t \n\t\t}\n\n\t\tpfault->eq = eq;\n\t\tINIT_WORK(&pfault->work, mlx5_ib_eqe_pf_action);\n\t\tqueue_work(eq->wq, &pfault->work);\n\n\t\tcc = mlx5_eq_update_cc(eq->core, ++cc);\n\t}\n\n\tmlx5_eq_update_ci(eq->core, cc, 1);\n}\n\nstatic int mlx5_ib_eq_pf_int(struct notifier_block *nb, unsigned long type,\n\t\t\t     void *data)\n{\n\tstruct mlx5_ib_pf_eq *eq =\n\t\tcontainer_of(nb, struct mlx5_ib_pf_eq, irq_nb);\n\tunsigned long flags;\n\n\tif (spin_trylock_irqsave(&eq->lock, flags)) {\n\t\tmlx5_ib_eq_pf_process(eq);\n\t\tspin_unlock_irqrestore(&eq->lock, flags);\n\t} else {\n\t\tschedule_work(&eq->work);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void mempool_refill(mempool_t *pool)\n{\n\twhile (pool->curr_nr < pool->min_nr)\n\t\tmempool_free(mempool_alloc(pool, GFP_KERNEL), pool);\n}\n\nstatic void mlx5_ib_eq_pf_action(struct work_struct *work)\n{\n\tstruct mlx5_ib_pf_eq *eq =\n\t\tcontainer_of(work, struct mlx5_ib_pf_eq, work);\n\n\tmempool_refill(eq->pool);\n\n\tspin_lock_irq(&eq->lock);\n\tmlx5_ib_eq_pf_process(eq);\n\tspin_unlock_irq(&eq->lock);\n}\n\nenum {\n\tMLX5_IB_NUM_PF_EQE\t= 0x1000,\n\tMLX5_IB_NUM_PF_DRAIN\t= 64,\n};\n\nint mlx5r_odp_create_eq(struct mlx5_ib_dev *dev, struct mlx5_ib_pf_eq *eq)\n{\n\tstruct mlx5_eq_param param = {};\n\tint err = 0;\n\n\tmutex_lock(&dev->odp_eq_mutex);\n\tif (eq->core)\n\t\tgoto unlock;\n\tINIT_WORK(&eq->work, mlx5_ib_eq_pf_action);\n\tspin_lock_init(&eq->lock);\n\teq->dev = dev;\n\n\teq->pool = mempool_create_kmalloc_pool(MLX5_IB_NUM_PF_DRAIN,\n\t\t\t\t\t       sizeof(struct mlx5_pagefault));\n\tif (!eq->pool) {\n\t\terr = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\teq->wq = alloc_workqueue(\"mlx5_ib_page_fault\",\n\t\t\t\t WQ_HIGHPRI | WQ_UNBOUND | WQ_MEM_RECLAIM,\n\t\t\t\t MLX5_NUM_CMD_EQE);\n\tif (!eq->wq) {\n\t\terr = -ENOMEM;\n\t\tgoto err_mempool;\n\t}\n\n\teq->irq_nb.notifier_call = mlx5_ib_eq_pf_int;\n\tparam = (struct mlx5_eq_param) {\n\t\t.nent = MLX5_IB_NUM_PF_EQE,\n\t};\n\tparam.mask[0] = 1ull << MLX5_EVENT_TYPE_PAGE_FAULT;\n\teq->core = mlx5_eq_create_generic(dev->mdev, &param);\n\tif (IS_ERR(eq->core)) {\n\t\terr = PTR_ERR(eq->core);\n\t\tgoto err_wq;\n\t}\n\terr = mlx5_eq_enable(dev->mdev, eq->core, &eq->irq_nb);\n\tif (err) {\n\t\tmlx5_ib_err(dev, \"failed to enable odp EQ %d\\n\", err);\n\t\tgoto err_eq;\n\t}\n\n\tmutex_unlock(&dev->odp_eq_mutex);\n\treturn 0;\nerr_eq:\n\tmlx5_eq_destroy_generic(dev->mdev, eq->core);\nerr_wq:\n\teq->core = NULL;\n\tdestroy_workqueue(eq->wq);\nerr_mempool:\n\tmempool_destroy(eq->pool);\nunlock:\n\tmutex_unlock(&dev->odp_eq_mutex);\n\treturn err;\n}\n\nstatic int\nmlx5_ib_odp_destroy_eq(struct mlx5_ib_dev *dev, struct mlx5_ib_pf_eq *eq)\n{\n\tint err;\n\n\tif (!eq->core)\n\t\treturn 0;\n\tmlx5_eq_disable(dev->mdev, eq->core, &eq->irq_nb);\n\terr = mlx5_eq_destroy_generic(dev->mdev, eq->core);\n\tcancel_work_sync(&eq->work);\n\tdestroy_workqueue(eq->wq);\n\tmempool_destroy(eq->pool);\n\n\treturn err;\n}\n\nint mlx5_odp_init_mkey_cache(struct mlx5_ib_dev *dev)\n{\n\tstruct mlx5r_cache_rb_key rb_key = {\n\t\t.access_mode = MLX5_MKC_ACCESS_MODE_KSM,\n\t\t.ndescs = mlx5_imr_ksm_entries,\n\t};\n\tstruct mlx5_cache_ent *ent;\n\n\tif (!(dev->odp_caps.general_caps & IB_ODP_SUPPORT_IMPLICIT))\n\t\treturn 0;\n\n\tent = mlx5r_cache_create_ent_locked(dev, rb_key, true);\n\tif (IS_ERR(ent))\n\t\treturn PTR_ERR(ent);\n\n\treturn 0;\n}\n\nstatic const struct ib_device_ops mlx5_ib_dev_odp_ops = {\n\t.advise_mr = mlx5_ib_advise_mr,\n};\n\nint mlx5_ib_odp_init_one(struct mlx5_ib_dev *dev)\n{\n\tinternal_fill_odp_caps(dev);\n\n\tif (!(dev->odp_caps.general_caps & IB_ODP_SUPPORT))\n\t\treturn 0;\n\n\tib_set_device_ops(&dev->ib_dev, &mlx5_ib_dev_odp_ops);\n\n\tmutex_init(&dev->odp_eq_mutex);\n\treturn 0;\n}\n\nvoid mlx5_ib_odp_cleanup_one(struct mlx5_ib_dev *dev)\n{\n\tif (!(dev->odp_caps.general_caps & IB_ODP_SUPPORT))\n\t\treturn;\n\n\tmlx5_ib_odp_destroy_eq(dev, &dev->odp_pf_eq);\n}\n\nint mlx5_ib_odp_init(void)\n{\n\tmlx5_imr_ksm_entries = BIT_ULL(get_order(TASK_SIZE) -\n\t\t\t\t       MLX5_IMR_MTT_BITS);\n\n\treturn 0;\n}\n\nstruct prefetch_mr_work {\n\tstruct work_struct work;\n\tu32 pf_flags;\n\tu32 num_sge;\n\tstruct {\n\t\tu64 io_virt;\n\t\tstruct mlx5_ib_mr *mr;\n\t\tsize_t length;\n\t} frags[];\n};\n\nstatic void destroy_prefetch_work(struct prefetch_mr_work *work)\n{\n\tu32 i;\n\n\tfor (i = 0; i < work->num_sge; ++i)\n\t\tmlx5r_deref_odp_mkey(&work->frags[i].mr->mmkey);\n\n\tkvfree(work);\n}\n\nstatic struct mlx5_ib_mr *\nget_prefetchable_mr(struct ib_pd *pd, enum ib_uverbs_advise_mr_advice advice,\n\t\t    u32 lkey)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_mr *mr = NULL;\n\tstruct mlx5_ib_mkey *mmkey;\n\n\txa_lock(&dev->odp_mkeys);\n\tmmkey = xa_load(&dev->odp_mkeys, mlx5_base_mkey(lkey));\n\tif (!mmkey || mmkey->key != lkey) {\n\t\tmr = ERR_PTR(-ENOENT);\n\t\tgoto end;\n\t}\n\tif (mmkey->type != MLX5_MKEY_MR) {\n\t\tmr = ERR_PTR(-EINVAL);\n\t\tgoto end;\n\t}\n\n\tmr = container_of(mmkey, struct mlx5_ib_mr, mmkey);\n\n\tif (mr->ibmr.pd != pd) {\n\t\tmr = ERR_PTR(-EPERM);\n\t\tgoto end;\n\t}\n\n\t \n\tif (advice == IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE &&\n\t    !mr->umem->writable) {\n\t\tmr = ERR_PTR(-EPERM);\n\t\tgoto end;\n\t}\n\n\trefcount_inc(&mmkey->usecount);\nend:\n\txa_unlock(&dev->odp_mkeys);\n\treturn mr;\n}\n\nstatic void mlx5_ib_prefetch_mr_work(struct work_struct *w)\n{\n\tstruct prefetch_mr_work *work =\n\t\tcontainer_of(w, struct prefetch_mr_work, work);\n\tu32 bytes_mapped = 0;\n\tint ret;\n\tu32 i;\n\n\t \n\tWARN_ON(!work->num_sge);\n\tfor (i = 0; i < work->num_sge; ++i) {\n\t\tret = pagefault_mr(work->frags[i].mr, work->frags[i].io_virt,\n\t\t\t\t   work->frags[i].length, &bytes_mapped,\n\t\t\t\t   work->pf_flags);\n\t\tif (ret <= 0)\n\t\t\tcontinue;\n\t\tmlx5_update_odp_stats(work->frags[i].mr, prefetch, ret);\n\t}\n\n\tdestroy_prefetch_work(work);\n}\n\nstatic int init_prefetch_work(struct ib_pd *pd,\n\t\t\t       enum ib_uverbs_advise_mr_advice advice,\n\t\t\t       u32 pf_flags, struct prefetch_mr_work *work,\n\t\t\t       struct ib_sge *sg_list, u32 num_sge)\n{\n\tu32 i;\n\n\tINIT_WORK(&work->work, mlx5_ib_prefetch_mr_work);\n\twork->pf_flags = pf_flags;\n\n\tfor (i = 0; i < num_sge; ++i) {\n\t\tstruct mlx5_ib_mr *mr;\n\n\t\tmr = get_prefetchable_mr(pd, advice, sg_list[i].lkey);\n\t\tif (IS_ERR(mr)) {\n\t\t\twork->num_sge = i;\n\t\t\treturn PTR_ERR(mr);\n\t\t}\n\t\twork->frags[i].io_virt = sg_list[i].addr;\n\t\twork->frags[i].length = sg_list[i].length;\n\t\twork->frags[i].mr = mr;\n\t}\n\twork->num_sge = num_sge;\n\treturn 0;\n}\n\nstatic int mlx5_ib_prefetch_sg_list(struct ib_pd *pd,\n\t\t\t\t    enum ib_uverbs_advise_mr_advice advice,\n\t\t\t\t    u32 pf_flags, struct ib_sge *sg_list,\n\t\t\t\t    u32 num_sge)\n{\n\tu32 bytes_mapped = 0;\n\tint ret = 0;\n\tu32 i;\n\n\tfor (i = 0; i < num_sge; ++i) {\n\t\tstruct mlx5_ib_mr *mr;\n\n\t\tmr = get_prefetchable_mr(pd, advice, sg_list[i].lkey);\n\t\tif (IS_ERR(mr))\n\t\t\treturn PTR_ERR(mr);\n\t\tret = pagefault_mr(mr, sg_list[i].addr, sg_list[i].length,\n\t\t\t\t   &bytes_mapped, pf_flags);\n\t\tif (ret < 0) {\n\t\t\tmlx5r_deref_odp_mkey(&mr->mmkey);\n\t\t\treturn ret;\n\t\t}\n\t\tmlx5_update_odp_stats(mr, prefetch, ret);\n\t\tmlx5r_deref_odp_mkey(&mr->mmkey);\n\t}\n\n\treturn 0;\n}\n\nint mlx5_ib_advise_mr_prefetch(struct ib_pd *pd,\n\t\t\t       enum ib_uverbs_advise_mr_advice advice,\n\t\t\t       u32 flags, struct ib_sge *sg_list, u32 num_sge)\n{\n\tu32 pf_flags = 0;\n\tstruct prefetch_mr_work *work;\n\tint rc;\n\n\tif (advice == IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH)\n\t\tpf_flags |= MLX5_PF_FLAGS_DOWNGRADE;\n\n\tif (advice == IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT)\n\t\tpf_flags |= MLX5_PF_FLAGS_SNAPSHOT;\n\n\tif (flags & IB_UVERBS_ADVISE_MR_FLAG_FLUSH)\n\t\treturn mlx5_ib_prefetch_sg_list(pd, advice, pf_flags, sg_list,\n\t\t\t\t\t\tnum_sge);\n\n\twork = kvzalloc(struct_size(work, frags, num_sge), GFP_KERNEL);\n\tif (!work)\n\t\treturn -ENOMEM;\n\n\trc = init_prefetch_work(pd, advice, pf_flags, work, sg_list, num_sge);\n\tif (rc) {\n\t\tdestroy_prefetch_work(work);\n\t\treturn rc;\n\t}\n\tqueue_work(system_unbound_wq, &work->work);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}