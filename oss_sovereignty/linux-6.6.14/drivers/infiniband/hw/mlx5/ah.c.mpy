{
  "module_name": "ah.c",
  "hash_id": "59fe32c74327b951d8bfc42ab39fa5e7b09dd6286de33c9fb942f5a6291190a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/ah.c",
  "human_readable_source": " \n\n#include \"mlx5_ib.h\"\n\nstatic __be16 mlx5_ah_get_udp_sport(const struct mlx5_ib_dev *dev,\n\t\t\t\t  const struct rdma_ah_attr *ah_attr)\n{\n\tenum ib_gid_type gid_type = ah_attr->grh.sgid_attr->gid_type;\n\t__be16 sport;\n\n\tif ((gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP) &&\n\t    (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) &&\n\t    (ah_attr->grh.flow_label & IB_GRH_FLOWLABEL_MASK))\n\t\tsport = cpu_to_be16(\n\t\t\trdma_flow_label_to_udp_sport(ah_attr->grh.flow_label));\n\telse\n\t\tsport = mlx5_get_roce_udp_sport_min(dev,\n\t\t\t\t\t\t    ah_attr->grh.sgid_attr);\n\n\treturn sport;\n}\n\nstatic void create_ib_ah(struct mlx5_ib_dev *dev, struct mlx5_ib_ah *ah,\n\t\t\t struct rdma_ah_init_attr *init_attr)\n{\n\tstruct rdma_ah_attr *ah_attr = init_attr->ah_attr;\n\tenum ib_gid_type gid_type;\n\n\tif (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) {\n\t\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\n\t\tmemcpy(ah->av.rgid, &grh->dgid, 16);\n\t\tah->av.grh_gid_fl = cpu_to_be32(grh->flow_label |\n\t\t\t\t\t\t(1 << 30) |\n\t\t\t\t\t\tgrh->sgid_index << 20);\n\t\tah->av.hop_limit = grh->hop_limit;\n\t\tah->av.tclass = grh->traffic_class;\n\t}\n\n\tah->av.stat_rate_sl = (rdma_ah_get_static_rate(ah_attr) << 4);\n\n\tif (ah_attr->type == RDMA_AH_ATTR_TYPE_ROCE) {\n\t\tif (init_attr->xmit_slave)\n\t\t\tah->xmit_port =\n\t\t\t\tmlx5_lag_get_slave_port(dev->mdev,\n\t\t\t\t\t\t\tinit_attr->xmit_slave);\n\t\tgid_type = ah_attr->grh.sgid_attr->gid_type;\n\n\t\tmemcpy(ah->av.rmac, ah_attr->roce.dmac,\n\t\t       sizeof(ah_attr->roce.dmac));\n\t\tah->av.udp_sport = mlx5_ah_get_udp_sport(dev, ah_attr);\n\t\tah->av.stat_rate_sl |= (rdma_ah_get_sl(ah_attr) & 0x7) << 1;\n\t\tif (gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP)\n#define MLX5_ECN_ENABLED BIT(1)\n\t\t\tah->av.tclass |= MLX5_ECN_ENABLED;\n\t} else {\n\t\tah->av.rlid = cpu_to_be16(rdma_ah_get_dlid(ah_attr));\n\t\tah->av.fl_mlid = rdma_ah_get_path_bits(ah_attr) & 0x7f;\n\t\tah->av.stat_rate_sl |= (rdma_ah_get_sl(ah_attr) & 0xf);\n\t}\n}\n\nint mlx5_ib_create_ah(struct ib_ah *ibah, struct rdma_ah_init_attr *init_attr,\n\t\t      struct ib_udata *udata)\n\n{\n\tstruct rdma_ah_attr *ah_attr = init_attr->ah_attr;\n\tstruct mlx5_ib_ah *ah = to_mah(ibah);\n\tstruct mlx5_ib_dev *dev = to_mdev(ibah->device);\n\tenum rdma_ah_attr_type ah_type = ah_attr->type;\n\n\tif ((ah_type == RDMA_AH_ATTR_TYPE_ROCE) &&\n\t    !(rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH))\n\t\treturn -EINVAL;\n\n\tif (ah_type == RDMA_AH_ATTR_TYPE_ROCE && udata) {\n\t\tint err;\n\t\tstruct mlx5_ib_create_ah_resp resp = {};\n\t\tu32 min_resp_len =\n\t\t\toffsetofend(struct mlx5_ib_create_ah_resp, dmac);\n\n\t\tif (udata->outlen < min_resp_len)\n\t\t\treturn -EINVAL;\n\n\t\tresp.response_length = min_resp_len;\n\n\t\tmemcpy(resp.dmac, ah_attr->roce.dmac, ETH_ALEN);\n\t\terr = ib_copy_to_udata(udata, &resp, resp.response_length);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcreate_ib_ah(dev, ah, init_attr);\n\treturn 0;\n}\n\nint mlx5_ib_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr)\n{\n\tstruct mlx5_ib_ah *ah = to_mah(ibah);\n\tu32 tmp;\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\tah_attr->type = ibah->type;\n\n\ttmp = be32_to_cpu(ah->av.grh_gid_fl);\n\tif (tmp & (1 << 30)) {\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\ttmp & 0xfffff,\n\t\t\t\t(tmp >> 20) & 0xff,\n\t\t\t\tah->av.hop_limit,\n\t\t\t\tah->av.tclass);\n\t\trdma_ah_set_dgid_raw(ah_attr, ah->av.rgid);\n\t}\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(ah->av.rlid));\n\trdma_ah_set_static_rate(ah_attr, ah->av.stat_rate_sl >> 4);\n\trdma_ah_set_sl(ah_attr, ah->av.stat_rate_sl & 0xf);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}