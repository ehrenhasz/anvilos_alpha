{
  "module_name": "gsi.c",
  "hash_id": "ba70760521c435c9040759f888fc51d9fd0776ae3e53e29840957f733127b1d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/gsi.c",
  "human_readable_source": " \n\n#include \"mlx5_ib.h\"\n\nstruct mlx5_ib_gsi_wr {\n\tstruct ib_cqe cqe;\n\tstruct ib_wc wc;\n\tbool completed:1;\n};\n\nstatic bool mlx5_ib_deth_sqpn_cap(struct mlx5_ib_dev *dev)\n{\n\treturn MLX5_CAP_GEN(dev->mdev, set_deth_sqpn);\n}\n\n \nstatic void generate_completions(struct mlx5_ib_qp *mqp)\n{\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tstruct ib_cq *gsi_cq = mqp->ibqp.send_cq;\n\tstruct mlx5_ib_gsi_wr *wr;\n\tu32 index;\n\n\tfor (index = gsi->outstanding_ci; index != gsi->outstanding_pi;\n\t     index++) {\n\t\twr = &gsi->outstanding_wrs[index % gsi->cap.max_send_wr];\n\n\t\tif (!wr->completed)\n\t\t\tbreak;\n\n\t\tWARN_ON_ONCE(mlx5_ib_generate_wc(gsi_cq, &wr->wc));\n\t\twr->completed = false;\n\t}\n\n\tgsi->outstanding_ci = index;\n}\n\nstatic void handle_single_completion(struct ib_cq *cq, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_gsi_qp *gsi = cq->cq_context;\n\tstruct mlx5_ib_gsi_wr *wr =\n\t\tcontainer_of(wc->wr_cqe, struct mlx5_ib_gsi_wr, cqe);\n\tstruct mlx5_ib_qp *mqp = container_of(gsi, struct mlx5_ib_qp, gsi);\n\tu64 wr_id;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&gsi->lock, flags);\n\twr->completed = true;\n\twr_id = wr->wc.wr_id;\n\twr->wc = *wc;\n\twr->wc.wr_id = wr_id;\n\twr->wc.qp = &mqp->ibqp;\n\n\tgenerate_completions(mqp);\n\tspin_unlock_irqrestore(&gsi->lock, flags);\n}\n\nint mlx5_ib_create_gsi(struct ib_pd *pd, struct mlx5_ib_qp *mqp,\n\t\t       struct ib_qp_init_attr *attr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(pd->device);\n\tstruct mlx5_ib_gsi_qp *gsi;\n\tstruct ib_qp_init_attr hw_init_attr = *attr;\n\tconst u8 port_num = attr->port_num;\n\tint num_qps = 0;\n\tint ret;\n\n\tif (mlx5_ib_deth_sqpn_cap(dev)) {\n\t\tif (MLX5_CAP_GEN(dev->mdev,\n\t\t\t\t port_type) == MLX5_CAP_PORT_TYPE_IB)\n\t\t\tnum_qps = pd->device->attrs.max_pkeys;\n\t\telse if (dev->lag_active)\n\t\t\tnum_qps = dev->lag_ports;\n\t}\n\n\tgsi = &mqp->gsi;\n\tgsi->tx_qps = kcalloc(num_qps, sizeof(*gsi->tx_qps), GFP_KERNEL);\n\tif (!gsi->tx_qps)\n\t\treturn -ENOMEM;\n\n\tgsi->outstanding_wrs =\n\t\tkcalloc(attr->cap.max_send_wr, sizeof(*gsi->outstanding_wrs),\n\t\t\tGFP_KERNEL);\n\tif (!gsi->outstanding_wrs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_tx;\n\t}\n\n\tif (dev->devr.ports[port_num - 1].gsi) {\n\t\tmlx5_ib_warn(dev, \"GSI QP already exists on port %d\\n\",\n\t\t\t     port_num);\n\t\tret = -EBUSY;\n\t\tgoto err_free_wrs;\n\t}\n\tgsi->num_qps = num_qps;\n\tspin_lock_init(&gsi->lock);\n\n\tgsi->cap = attr->cap;\n\tgsi->port_num = port_num;\n\n\tgsi->cq = ib_alloc_cq(pd->device, gsi, attr->cap.max_send_wr, 0,\n\t\t\t      IB_POLL_SOFTIRQ);\n\tif (IS_ERR(gsi->cq)) {\n\t\tmlx5_ib_warn(dev, \"unable to create send CQ for GSI QP. error %ld\\n\",\n\t\t\t     PTR_ERR(gsi->cq));\n\t\tret = PTR_ERR(gsi->cq);\n\t\tgoto err_free_wrs;\n\t}\n\n\thw_init_attr.qp_type = MLX5_IB_QPT_HW_GSI;\n\thw_init_attr.send_cq = gsi->cq;\n\tif (num_qps) {\n\t\thw_init_attr.cap.max_send_wr = 0;\n\t\thw_init_attr.cap.max_send_sge = 0;\n\t\thw_init_attr.cap.max_inline_data = 0;\n\t}\n\n\tgsi->rx_qp = ib_create_qp(pd, &hw_init_attr);\n\tif (IS_ERR(gsi->rx_qp)) {\n\t\tmlx5_ib_warn(dev, \"unable to create hardware GSI QP. error %ld\\n\",\n\t\t\t     PTR_ERR(gsi->rx_qp));\n\t\tret = PTR_ERR(gsi->rx_qp);\n\t\tgoto err_destroy_cq;\n\t}\n\n\tdev->devr.ports[attr->port_num - 1].gsi = gsi;\n\treturn 0;\n\nerr_destroy_cq:\n\tib_free_cq(gsi->cq);\nerr_free_wrs:\n\tkfree(gsi->outstanding_wrs);\nerr_free_tx:\n\tkfree(gsi->tx_qps);\n\treturn ret;\n}\n\nint mlx5_ib_destroy_gsi(struct mlx5_ib_qp *mqp)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(mqp->ibqp.device);\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tconst int port_num = gsi->port_num;\n\tint qp_index;\n\tint ret;\n\n\tret = ib_destroy_qp(gsi->rx_qp);\n\tif (ret) {\n\t\tmlx5_ib_warn(dev, \"unable to destroy hardware GSI QP. error %d\\n\",\n\t\t\t     ret);\n\t\treturn ret;\n\t}\n\tdev->devr.ports[port_num - 1].gsi = NULL;\n\tgsi->rx_qp = NULL;\n\n\tfor (qp_index = 0; qp_index < gsi->num_qps; ++qp_index) {\n\t\tif (!gsi->tx_qps[qp_index])\n\t\t\tcontinue;\n\t\tWARN_ON_ONCE(ib_destroy_qp(gsi->tx_qps[qp_index]));\n\t\tgsi->tx_qps[qp_index] = NULL;\n\t}\n\n\tib_free_cq(gsi->cq);\n\n\tkfree(gsi->outstanding_wrs);\n\tkfree(gsi->tx_qps);\n\treturn 0;\n}\n\nstatic struct ib_qp *create_gsi_ud_qp(struct mlx5_ib_gsi_qp *gsi)\n{\n\tstruct ib_pd *pd = gsi->rx_qp->pd;\n\tstruct ib_qp_init_attr init_attr = {\n\t\t.event_handler = gsi->rx_qp->event_handler,\n\t\t.qp_context = gsi->rx_qp->qp_context,\n\t\t.send_cq = gsi->cq,\n\t\t.recv_cq = gsi->rx_qp->recv_cq,\n\t\t.cap = {\n\t\t\t.max_send_wr = gsi->cap.max_send_wr,\n\t\t\t.max_send_sge = gsi->cap.max_send_sge,\n\t\t\t.max_inline_data = gsi->cap.max_inline_data,\n\t\t},\n\t\t.qp_type = IB_QPT_UD,\n\t\t.create_flags = MLX5_IB_QP_CREATE_SQPN_QP1,\n\t};\n\n\treturn ib_create_qp(pd, &init_attr);\n}\n\nstatic int modify_to_rts(struct mlx5_ib_gsi_qp *gsi, struct ib_qp *qp,\n\t\t\t u16 pkey_index)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct ib_qp_attr attr;\n\tint mask;\n\tint ret;\n\n\tmask = IB_QP_STATE | IB_QP_PKEY_INDEX | IB_QP_QKEY | IB_QP_PORT;\n\tattr.qp_state = IB_QPS_INIT;\n\tattr.pkey_index = pkey_index;\n\tattr.qkey = IB_QP1_QKEY;\n\tattr.port_num = gsi->port_num;\n\tret = ib_modify_qp(qp, &attr, mask);\n\tif (ret) {\n\t\tmlx5_ib_err(dev, \"could not change QP%d state to INIT: %d\\n\",\n\t\t\t    qp->qp_num, ret);\n\t\treturn ret;\n\t}\n\n\tattr.qp_state = IB_QPS_RTR;\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE);\n\tif (ret) {\n\t\tmlx5_ib_err(dev, \"could not change QP%d state to RTR: %d\\n\",\n\t\t\t    qp->qp_num, ret);\n\t\treturn ret;\n\t}\n\n\tattr.qp_state = IB_QPS_RTS;\n\tattr.sq_psn = 0;\n\tret = ib_modify_qp(qp, &attr, IB_QP_STATE | IB_QP_SQ_PSN);\n\tif (ret) {\n\t\tmlx5_ib_err(dev, \"could not change QP%d state to RTS: %d\\n\",\n\t\t\t    qp->qp_num, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void setup_qp(struct mlx5_ib_gsi_qp *gsi, u16 qp_index)\n{\n\tstruct ib_device *device = gsi->rx_qp->device;\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tint pkey_index = qp_index;\n\tstruct mlx5_ib_qp *mqp;\n\tstruct ib_qp *qp;\n\tunsigned long flags;\n\tu16 pkey;\n\tint ret;\n\n\tif (MLX5_CAP_GEN(dev->mdev,  port_type) != MLX5_CAP_PORT_TYPE_IB)\n\t\tpkey_index = 0;\n\n\tret = ib_query_pkey(device, gsi->port_num, pkey_index, &pkey);\n\tif (ret) {\n\t\tmlx5_ib_warn(dev, \"unable to read P_Key at port %d, index %d\\n\",\n\t\t\t     gsi->port_num, qp_index);\n\t\treturn;\n\t}\n\n\tif (!pkey) {\n\t\tmlx5_ib_dbg(dev, \"invalid P_Key at port %d, index %d.  Skipping.\\n\",\n\t\t\t    gsi->port_num, qp_index);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&gsi->lock, flags);\n\tqp = gsi->tx_qps[qp_index];\n\tspin_unlock_irqrestore(&gsi->lock, flags);\n\tif (qp) {\n\t\tmlx5_ib_dbg(dev, \"already existing GSI TX QP at port %d, index %d. Skipping\\n\",\n\t\t\t    gsi->port_num, qp_index);\n\t\treturn;\n\t}\n\n\tqp = create_gsi_ud_qp(gsi);\n\tif (IS_ERR(qp)) {\n\t\tmlx5_ib_warn(dev, \"unable to create hardware UD QP for GSI: %ld\\n\",\n\t\t\t     PTR_ERR(qp));\n\t\treturn;\n\t}\n\n\tmqp = to_mqp(qp);\n\tif (dev->lag_active)\n\t\tmqp->gsi_lag_port = qp_index + 1;\n\tret = modify_to_rts(gsi, qp, pkey_index);\n\tif (ret)\n\t\tgoto err_destroy_qp;\n\n\tspin_lock_irqsave(&gsi->lock, flags);\n\tWARN_ON_ONCE(gsi->tx_qps[qp_index]);\n\tgsi->tx_qps[qp_index] = qp;\n\tspin_unlock_irqrestore(&gsi->lock, flags);\n\n\treturn;\n\nerr_destroy_qp:\n\tWARN_ON_ONCE(qp);\n}\n\nint mlx5_ib_gsi_modify_qp(struct ib_qp *qp, struct ib_qp_attr *attr,\n\t\t\t  int attr_mask)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(qp->device);\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tu16 qp_index;\n\tint ret;\n\n\tmlx5_ib_dbg(dev, \"modifying GSI QP to state %d\\n\", attr->qp_state);\n\n\tret = ib_modify_qp(gsi->rx_qp, attr, attr_mask);\n\tif (ret) {\n\t\tmlx5_ib_warn(dev, \"unable to modify GSI rx QP: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (to_mqp(gsi->rx_qp)->state != IB_QPS_RTS)\n\t\treturn 0;\n\n\tfor (qp_index = 0; qp_index < gsi->num_qps; ++qp_index)\n\t\tsetup_qp(gsi, qp_index);\n\treturn 0;\n}\n\nint mlx5_ib_gsi_query_qp(struct ib_qp *qp, struct ib_qp_attr *qp_attr,\n\t\t\t int qp_attr_mask,\n\t\t\t struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tint ret;\n\n\tret = ib_query_qp(gsi->rx_qp, qp_attr, qp_attr_mask, qp_init_attr);\n\tqp_init_attr->cap = gsi->cap;\n\treturn ret;\n}\n\n \nstatic int mlx5_ib_add_outstanding_wr(struct mlx5_ib_qp *mqp,\n\t\t\t\t      struct ib_ud_wr *wr, struct ib_wc *wc)\n{\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tstruct mlx5_ib_dev *dev = to_mdev(gsi->rx_qp->device);\n\tstruct mlx5_ib_gsi_wr *gsi_wr;\n\n\tif (gsi->outstanding_pi == gsi->outstanding_ci + gsi->cap.max_send_wr) {\n\t\tmlx5_ib_warn(dev, \"no available GSI work request.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tgsi_wr = &gsi->outstanding_wrs[gsi->outstanding_pi %\n\t\t\t\t       gsi->cap.max_send_wr];\n\tgsi->outstanding_pi++;\n\n\tif (!wc) {\n\t\tmemset(&gsi_wr->wc, 0, sizeof(gsi_wr->wc));\n\t\tgsi_wr->wc.pkey_index = wr->pkey_index;\n\t\tgsi_wr->wc.wr_id = wr->wr.wr_id;\n\t} else {\n\t\tgsi_wr->wc = *wc;\n\t\tgsi_wr->completed = true;\n\t}\n\n\tgsi_wr->cqe.done = &handle_single_completion;\n\twr->wr.wr_cqe = &gsi_wr->cqe;\n\n\treturn 0;\n}\n\n \nstatic int mlx5_ib_gsi_silent_drop(struct mlx5_ib_qp *mqp, struct ib_ud_wr *wr)\n{\n\tstruct ib_wc wc = {\n\t\t{ .wr_id = wr->wr.wr_id },\n\t\t.status = IB_WC_SUCCESS,\n\t\t.opcode = IB_WC_SEND,\n\t\t.qp = &mqp->ibqp,\n\t};\n\tint ret;\n\n\tret = mlx5_ib_add_outstanding_wr(mqp, wr, &wc);\n\tif (ret)\n\t\treturn ret;\n\n\tgenerate_completions(mqp);\n\n\treturn 0;\n}\n\n \nstatic struct ib_qp *get_tx_qp(struct mlx5_ib_gsi_qp *gsi, struct ib_ud_wr *wr)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(gsi->rx_qp->device);\n\tstruct mlx5_ib_ah *ah = to_mah(wr->ah);\n\tint qp_index = wr->pkey_index;\n\n\tif (!gsi->num_qps)\n\t\treturn gsi->rx_qp;\n\n\tif (dev->lag_active && ah->xmit_port)\n\t\tqp_index = ah->xmit_port - 1;\n\n\tif (qp_index >= gsi->num_qps)\n\t\treturn NULL;\n\n\treturn gsi->tx_qps[qp_index];\n}\n\nint mlx5_ib_gsi_post_send(struct ib_qp *qp, const struct ib_send_wr *wr,\n\t\t\t  const struct ib_send_wr **bad_wr)\n{\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\tstruct ib_qp *tx_qp;\n\tunsigned long flags;\n\tint ret;\n\n\tfor (; wr; wr = wr->next) {\n\t\tstruct ib_ud_wr cur_wr = *ud_wr(wr);\n\n\t\tcur_wr.wr.next = NULL;\n\n\t\tspin_lock_irqsave(&gsi->lock, flags);\n\t\ttx_qp = get_tx_qp(gsi, &cur_wr);\n\t\tif (!tx_qp) {\n\t\t\tret = mlx5_ib_gsi_silent_drop(mqp, &cur_wr);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t\tspin_unlock_irqrestore(&gsi->lock, flags);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = mlx5_ib_add_outstanding_wr(mqp, &cur_wr, NULL);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = ib_post_send(tx_qp, &cur_wr.wr, bad_wr);\n\t\tif (ret) {\n\t\t\t \n\t\t\tgsi->outstanding_pi--;\n\t\t\tgoto err;\n\t\t}\n\t\tspin_unlock_irqrestore(&gsi->lock, flags);\n\t}\n\n\treturn 0;\n\nerr:\n\tspin_unlock_irqrestore(&gsi->lock, flags);\n\t*bad_wr = wr;\n\treturn ret;\n}\n\nint mlx5_ib_gsi_post_recv(struct ib_qp *qp, const struct ib_recv_wr *wr,\n\t\t\t  const struct ib_recv_wr **bad_wr)\n{\n\tstruct mlx5_ib_qp *mqp = to_mqp(qp);\n\tstruct mlx5_ib_gsi_qp *gsi = &mqp->gsi;\n\n\treturn ib_post_recv(gsi->rx_qp, wr, bad_wr);\n}\n\nvoid mlx5_ib_gsi_pkey_change(struct mlx5_ib_gsi_qp *gsi)\n{\n\tu16 qp_index;\n\n\tfor (qp_index = 0; qp_index < gsi->num_qps; ++qp_index)\n\t\tsetup_qp(gsi, qp_index);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}