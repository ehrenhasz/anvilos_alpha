{
  "module_name": "ib_virt.c",
  "hash_id": "6d6bd490051d5144ad1218011093e3bf819321f54c15e807690ba2ae0258aa6d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mlx5/ib_virt.c",
  "human_readable_source": " \n\n#include <linux/mlx5/vport.h>\n#include \"mlx5_ib.h\"\n\nstatic inline u32 mlx_to_net_policy(enum port_state_policy mlx_policy)\n{\n\tswitch (mlx_policy) {\n\tcase MLX5_POLICY_DOWN:\n\t\treturn IFLA_VF_LINK_STATE_DISABLE;\n\tcase MLX5_POLICY_UP:\n\t\treturn IFLA_VF_LINK_STATE_ENABLE;\n\tcase MLX5_POLICY_FOLLOW:\n\t\treturn IFLA_VF_LINK_STATE_AUTO;\n\tdefault:\n\t\treturn __IFLA_VF_LINK_STATE_MAX;\n\t}\n}\n\nint mlx5_ib_get_vf_config(struct ib_device *device, int vf, u32 port,\n\t\t\t  struct ifla_vf_info *info)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_hca_vport_context *rep;\n\tint err;\n\n\trep = kzalloc(sizeof(*rep), GFP_KERNEL);\n\tif (!rep)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_query_hca_vport_context(mdev, 1, 1,  vf + 1, rep);\n\tif (err) {\n\t\tmlx5_ib_warn(dev, \"failed to query port policy for vf %d (%d)\\n\",\n\t\t\t     vf, err);\n\t\tgoto free;\n\t}\n\tmemset(info, 0, sizeof(*info));\n\tinfo->linkstate = mlx_to_net_policy(rep->policy);\n\tif (info->linkstate == __IFLA_VF_LINK_STATE_MAX)\n\t\terr = -EINVAL;\n\nfree:\n\tkfree(rep);\n\treturn err;\n}\n\nstatic inline enum port_state_policy net_to_mlx_policy(int policy)\n{\n\tswitch (policy) {\n\tcase IFLA_VF_LINK_STATE_DISABLE:\n\t\treturn MLX5_POLICY_DOWN;\n\tcase IFLA_VF_LINK_STATE_ENABLE:\n\t\treturn MLX5_POLICY_UP;\n\tcase IFLA_VF_LINK_STATE_AUTO:\n\t\treturn MLX5_POLICY_FOLLOW;\n\tdefault:\n\t\treturn MLX5_POLICY_INVALID;\n\t}\n}\n\nint mlx5_ib_set_vf_link_state(struct ib_device *device, int vf,\n\t\t\t      u32 port, int state)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_hca_vport_context *in;\n\tstruct mlx5_vf_context *vfs_ctx = mdev->priv.sriov.vfs_ctx;\n\tint err;\n\n\tin = kzalloc(sizeof(*in), GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tin->policy = net_to_mlx_policy(state);\n\tif (in->policy == MLX5_POLICY_INVALID) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tin->field_select = MLX5_HCA_VPORT_SEL_STATE_POLICY;\n\terr = mlx5_core_modify_hca_vport_context(mdev, 1, 1, vf + 1, in);\n\tif (!err)\n\t\tvfs_ctx[vf].policy = in->policy;\n\nout:\n\tkfree(in);\n\treturn err;\n}\n\nint mlx5_ib_get_vf_stats(struct ib_device *device, int vf,\n\t\t\t u32 port, struct ifla_vf_stats *stats)\n{\n\tint out_sz = MLX5_ST_SZ_BYTES(query_vport_counter_out);\n\tstruct mlx5_core_dev *mdev;\n\tstruct mlx5_ib_dev *dev;\n\tvoid *out;\n\tint err;\n\n\tdev = to_mdev(device);\n\tmdev = dev->mdev;\n\n\tout = kzalloc(out_sz, GFP_KERNEL);\n\tif (!out)\n\t\treturn -ENOMEM;\n\n\terr = mlx5_core_query_vport_counter(mdev, true, vf, port, out);\n\tif (err)\n\t\tgoto ex;\n\n\tstats->rx_packets = MLX5_GET64_PR(query_vport_counter_out, out, received_ib_unicast.packets);\n\tstats->tx_packets = MLX5_GET64_PR(query_vport_counter_out, out, transmitted_ib_unicast.packets);\n\tstats->rx_bytes = MLX5_GET64_PR(query_vport_counter_out, out, received_ib_unicast.octets);\n\tstats->tx_bytes = MLX5_GET64_PR(query_vport_counter_out, out, transmitted_ib_unicast.octets);\n\tstats->multicast = MLX5_GET64_PR(query_vport_counter_out, out, received_ib_multicast.packets);\n\nex:\n\tkfree(out);\n\treturn err;\n}\n\nstatic int set_vf_node_guid(struct ib_device *device, int vf, u32 port,\n\t\t\t    u64 guid)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_hca_vport_context *in;\n\tstruct mlx5_vf_context *vfs_ctx = mdev->priv.sriov.vfs_ctx;\n\tint err;\n\n\tin = kzalloc(sizeof(*in), GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tin->field_select = MLX5_HCA_VPORT_SEL_NODE_GUID;\n\tin->node_guid = guid;\n\terr = mlx5_core_modify_hca_vport_context(mdev, 1, 1, vf + 1, in);\n\tif (!err) {\n\t\tvfs_ctx[vf].node_guid = guid;\n\t\tvfs_ctx[vf].node_guid_valid = 1;\n\t}\n\tkfree(in);\n\treturn err;\n}\n\nstatic int set_vf_port_guid(struct ib_device *device, int vf, u32 port,\n\t\t\t    u64 guid)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_hca_vport_context *in;\n\tstruct mlx5_vf_context *vfs_ctx = mdev->priv.sriov.vfs_ctx;\n\tint err;\n\n\tin = kzalloc(sizeof(*in), GFP_KERNEL);\n\tif (!in)\n\t\treturn -ENOMEM;\n\n\tin->field_select = MLX5_HCA_VPORT_SEL_PORT_GUID;\n\tin->port_guid = guid;\n\terr = mlx5_core_modify_hca_vport_context(mdev, 1, 1, vf + 1, in);\n\tif (!err) {\n\t\tvfs_ctx[vf].port_guid = guid;\n\t\tvfs_ctx[vf].port_guid_valid = 1;\n\t}\n\tkfree(in);\n\treturn err;\n}\n\nint mlx5_ib_set_vf_guid(struct ib_device *device, int vf, u32 port,\n\t\t\tu64 guid, int type)\n{\n\tif (type == IFLA_VF_IB_NODE_GUID)\n\t\treturn set_vf_node_guid(device, vf, port, guid);\n\telse if (type == IFLA_VF_IB_PORT_GUID)\n\t\treturn set_vf_port_guid(device, vf, port, guid);\n\n\treturn -EINVAL;\n}\n\nint mlx5_ib_get_vf_guid(struct ib_device *device, int vf, u32 port,\n\t\t\tstruct ifla_vf_guid *node_guid,\n\t\t\tstruct ifla_vf_guid *port_guid)\n{\n\tstruct mlx5_ib_dev *dev = to_mdev(device);\n\tstruct mlx5_core_dev *mdev = dev->mdev;\n\tstruct mlx5_vf_context *vfs_ctx = mdev->priv.sriov.vfs_ctx;\n\n\tnode_guid->guid =\n\t\tvfs_ctx[vf].node_guid_valid ? vfs_ctx[vf].node_guid : 0;\n\tport_guid->guid =\n\t\tvfs_ctx[vf].port_guid_valid ? vfs_ctx[vf].port_guid : 0;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}