{
  "module_name": "utils.c",
  "hash_id": "a88ee2028cd96a2adf5d6101ffe83d0f4775abfd69786ebbd5f3ece5334e0c18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/utils.c",
  "human_readable_source": "\n \n#include \"main.h\"\n\n \nint irdma_arp_table(struct irdma_pci_f *rf, u32 *ip_addr, bool ipv4,\n\t\t    const u8 *mac_addr, u32 action)\n{\n\tunsigned long flags;\n\tint arp_index;\n\tu32 ip[4] = {};\n\n\tif (ipv4)\n\t\tip[0] = *ip_addr;\n\telse\n\t\tmemcpy(ip, ip_addr, sizeof(ip));\n\n\tspin_lock_irqsave(&rf->arp_lock, flags);\n\tfor (arp_index = 0; (u32)arp_index < rf->arp_table_size; arp_index++) {\n\t\tif (!memcmp(rf->arp_table[arp_index].ip_addr, ip, sizeof(ip)))\n\t\t\tbreak;\n\t}\n\n\tswitch (action) {\n\tcase IRDMA_ARP_ADD:\n\t\tif (arp_index != rf->arp_table_size) {\n\t\t\tarp_index = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tarp_index = 0;\n\t\tif (irdma_alloc_rsrc(rf, rf->allocated_arps, rf->arp_table_size,\n\t\t\t\t     (u32 *)&arp_index, &rf->next_arp_index)) {\n\t\t\tarp_index = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(rf->arp_table[arp_index].ip_addr, ip,\n\t\t       sizeof(rf->arp_table[arp_index].ip_addr));\n\t\tether_addr_copy(rf->arp_table[arp_index].mac_addr, mac_addr);\n\t\tbreak;\n\tcase IRDMA_ARP_RESOLVE:\n\t\tif (arp_index == rf->arp_table_size)\n\t\t\tarp_index = -1;\n\t\tbreak;\n\tcase IRDMA_ARP_DELETE:\n\t\tif (arp_index == rf->arp_table_size) {\n\t\t\tarp_index = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\tmemset(rf->arp_table[arp_index].ip_addr, 0,\n\t\t       sizeof(rf->arp_table[arp_index].ip_addr));\n\t\teth_zero_addr(rf->arp_table[arp_index].mac_addr);\n\t\tirdma_free_rsrc(rf, rf->allocated_arps, arp_index);\n\t\tbreak;\n\tdefault:\n\t\tarp_index = -1;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&rf->arp_lock, flags);\n\treturn arp_index;\n}\n\n \nint irdma_add_arp(struct irdma_pci_f *rf, u32 *ip, bool ipv4, const u8 *mac)\n{\n\tint arpidx;\n\n\tarpidx = irdma_arp_table(rf, &ip[0], ipv4, NULL, IRDMA_ARP_RESOLVE);\n\tif (arpidx >= 0) {\n\t\tif (ether_addr_equal(rf->arp_table[arpidx].mac_addr, mac))\n\t\t\treturn arpidx;\n\n\t\tirdma_manage_arp_cache(rf, rf->arp_table[arpidx].mac_addr, ip,\n\t\t\t\t       ipv4, IRDMA_ARP_DELETE);\n\t}\n\n\tirdma_manage_arp_cache(rf, mac, ip, ipv4, IRDMA_ARP_ADD);\n\n\treturn irdma_arp_table(rf, ip, ipv4, NULL, IRDMA_ARP_RESOLVE);\n}\n\n \ninline void wr32(struct irdma_hw *hw, u32 reg, u32 val)\n{\n\twritel(val, hw->hw_addr + reg);\n}\n\n \ninline u32 rd32(struct irdma_hw *hw, u32 reg)\n{\n\treturn readl(hw->hw_addr + reg);\n}\n\n \ninline u64 rd64(struct irdma_hw *hw, u32 reg)\n{\n\treturn readq(hw->hw_addr + reg);\n}\n\nstatic void irdma_gid_change_event(struct ib_device *ibdev)\n{\n\tstruct ib_event ib_event;\n\n\tib_event.event = IB_EVENT_GID_CHANGE;\n\tib_event.device = ibdev;\n\tib_event.element.port_num = 1;\n\tib_dispatch_event(&ib_event);\n}\n\n \nint irdma_inetaddr_event(struct notifier_block *notifier, unsigned long event,\n\t\t\t void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *real_dev, *netdev = ifa->ifa_dev->dev;\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\tu32 local_ipaddr;\n\n\treal_dev = rdma_vlan_dev_real_dev(netdev);\n\tif (!real_dev)\n\t\treal_dev = netdev;\n\n\tibdev = ib_device_get_by_netdev(real_dev, RDMA_DRIVER_IRDMA);\n\tif (!ibdev)\n\t\treturn NOTIFY_DONE;\n\n\tiwdev = to_iwdev(ibdev);\n\tlocal_ipaddr = ntohl(ifa->ifa_address);\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"DEV: netdev %p event %lu local_ip=%pI4 MAC=%pM\\n\", real_dev,\n\t\t  event, &local_ipaddr, real_dev->dev_addr);\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\t\tirdma_manage_arp_cache(iwdev->rf, real_dev->dev_addr,\n\t\t\t\t       &local_ipaddr, true, IRDMA_ARP_DELETE);\n\t\tirdma_if_notify(iwdev, real_dev, &local_ipaddr, true, false);\n\t\tirdma_gid_change_event(&iwdev->ibdev);\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGEADDR:\n\t\tirdma_add_arp(iwdev->rf, &local_ipaddr, true, real_dev->dev_addr);\n\t\tirdma_if_notify(iwdev, real_dev, &local_ipaddr, true, true);\n\t\tirdma_gid_change_event(&iwdev->ibdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tib_device_put(ibdev);\n\n\treturn NOTIFY_DONE;\n}\n\n \nint irdma_inet6addr_event(struct notifier_block *notifier, unsigned long event,\n\t\t\t  void *ptr)\n{\n\tstruct inet6_ifaddr *ifa = ptr;\n\tstruct net_device *real_dev, *netdev = ifa->idev->dev;\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\tu32 local_ipaddr6[4];\n\n\treal_dev = rdma_vlan_dev_real_dev(netdev);\n\tif (!real_dev)\n\t\treal_dev = netdev;\n\n\tibdev = ib_device_get_by_netdev(real_dev, RDMA_DRIVER_IRDMA);\n\tif (!ibdev)\n\t\treturn NOTIFY_DONE;\n\n\tiwdev = to_iwdev(ibdev);\n\tirdma_copy_ip_ntohl(local_ipaddr6, ifa->addr.in6_u.u6_addr32);\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"DEV: netdev %p event %lu local_ip=%pI6 MAC=%pM\\n\", real_dev,\n\t\t  event, local_ipaddr6, real_dev->dev_addr);\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\t\tirdma_manage_arp_cache(iwdev->rf, real_dev->dev_addr,\n\t\t\t\t       local_ipaddr6, false, IRDMA_ARP_DELETE);\n\t\tirdma_if_notify(iwdev, real_dev, local_ipaddr6, false, false);\n\t\tirdma_gid_change_event(&iwdev->ibdev);\n\t\tbreak;\n\tcase NETDEV_UP:\n\tcase NETDEV_CHANGEADDR:\n\t\tirdma_add_arp(iwdev->rf, local_ipaddr6, false,\n\t\t\t      real_dev->dev_addr);\n\t\tirdma_if_notify(iwdev, real_dev, local_ipaddr6, false, true);\n\t\tirdma_gid_change_event(&iwdev->ibdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tib_device_put(ibdev);\n\n\treturn NOTIFY_DONE;\n}\n\n \nint irdma_net_event(struct notifier_block *notifier, unsigned long event,\n\t\t    void *ptr)\n{\n\tstruct neighbour *neigh = ptr;\n\tstruct net_device *real_dev, *netdev = (struct net_device *)neigh->dev;\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\t__be32 *p;\n\tu32 local_ipaddr[4] = {};\n\tbool ipv4 = true;\n\n\tswitch (event) {\n\tcase NETEVENT_NEIGH_UPDATE:\n\t\treal_dev = rdma_vlan_dev_real_dev(netdev);\n\t\tif (!real_dev)\n\t\t\treal_dev = netdev;\n\t\tibdev = ib_device_get_by_netdev(real_dev, RDMA_DRIVER_IRDMA);\n\t\tif (!ibdev)\n\t\t\treturn NOTIFY_DONE;\n\n\t\tiwdev = to_iwdev(ibdev);\n\t\tp = (__be32 *)neigh->primary_key;\n\t\tif (neigh->tbl->family == AF_INET6) {\n\t\t\tipv4 = false;\n\t\t\tirdma_copy_ip_ntohl(local_ipaddr, p);\n\t\t} else {\n\t\t\tlocal_ipaddr[0] = ntohl(*p);\n\t\t}\n\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"DEV: netdev %p state %d local_ip=%pI4 MAC=%pM\\n\",\n\t\t\t  iwdev->netdev, neigh->nud_state, local_ipaddr,\n\t\t\t  neigh->ha);\n\n\t\tif (neigh->nud_state & NUD_VALID)\n\t\t\tirdma_add_arp(iwdev->rf, local_ipaddr, ipv4, neigh->ha);\n\n\t\telse\n\t\t\tirdma_manage_arp_cache(iwdev->rf, neigh->ha,\n\t\t\t\t\t       local_ipaddr, ipv4,\n\t\t\t\t\t       IRDMA_ARP_DELETE);\n\t\tib_device_put(ibdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n \nint irdma_netdevice_event(struct notifier_block *notifier, unsigned long event,\n\t\t\t  void *ptr)\n{\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\n\n\tibdev = ib_device_get_by_netdev(netdev, RDMA_DRIVER_IRDMA);\n\tif (!ibdev)\n\t\treturn NOTIFY_DONE;\n\n\tiwdev = to_iwdev(ibdev);\n\tiwdev->iw_status = 1;\n\tswitch (event) {\n\tcase NETDEV_DOWN:\n\t\tiwdev->iw_status = 0;\n\t\tfallthrough;\n\tcase NETDEV_UP:\n\t\tirdma_port_ibevent(iwdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tib_device_put(ibdev);\n\n\treturn NOTIFY_DONE;\n}\n\n \nstatic void irdma_add_ipv6_addr(struct irdma_device *iwdev)\n{\n\tstruct net_device *ip_dev;\n\tstruct inet6_dev *idev;\n\tstruct inet6_ifaddr *ifp, *tmp;\n\tu32 local_ipaddr6[4];\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu (&init_net, ip_dev) {\n\t\tif (((rdma_vlan_dev_vlan_id(ip_dev) < 0xFFFF &&\n\t\t      rdma_vlan_dev_real_dev(ip_dev) == iwdev->netdev) ||\n\t\t      ip_dev == iwdev->netdev) &&\n\t\t      (READ_ONCE(ip_dev->flags) & IFF_UP)) {\n\t\t\tidev = __in6_dev_get(ip_dev);\n\t\t\tif (!idev) {\n\t\t\t\tibdev_err(&iwdev->ibdev, \"ipv6 inet device not found\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe (ifp, tmp, &idev->addr_list,\n\t\t\t\t\t\t  if_list) {\n\t\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t\t  \"INIT: IP=%pI6, vlan_id=%d, MAC=%pM\\n\",\n\t\t\t\t\t  &ifp->addr,\n\t\t\t\t\t  rdma_vlan_dev_vlan_id(ip_dev),\n\t\t\t\t\t  ip_dev->dev_addr);\n\n\t\t\t\tirdma_copy_ip_ntohl(local_ipaddr6,\n\t\t\t\t\t\t    ifp->addr.in6_u.u6_addr32);\n\t\t\t\tirdma_manage_arp_cache(iwdev->rf,\n\t\t\t\t\t\t       ip_dev->dev_addr,\n\t\t\t\t\t\t       local_ipaddr6, false,\n\t\t\t\t\t\t       IRDMA_ARP_ADD);\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nstatic void irdma_add_ipv4_addr(struct irdma_device *iwdev)\n{\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tu32 ip_addr;\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu (&init_net, dev) {\n\t\tif (((rdma_vlan_dev_vlan_id(dev) < 0xFFFF &&\n\t\t      rdma_vlan_dev_real_dev(dev) == iwdev->netdev) ||\n\t\t      dev == iwdev->netdev) && (READ_ONCE(dev->flags) & IFF_UP)) {\n\t\t\tconst struct in_ifaddr *ifa;\n\n\t\t\tidev = __in_dev_get_rcu(dev);\n\t\t\tif (!idev)\n\t\t\t\tcontinue;\n\n\t\t\tin_dev_for_each_ifa_rcu(ifa, idev) {\n\t\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: IP=%pI4, vlan_id=%d, MAC=%pM\\n\",\n\t\t\t\t\t  &ifa->ifa_address, rdma_vlan_dev_vlan_id(dev),\n\t\t\t\t\t  dev->dev_addr);\n\n\t\t\t\tip_addr = ntohl(ifa->ifa_address);\n\t\t\t\tirdma_manage_arp_cache(iwdev->rf, dev->dev_addr,\n\t\t\t\t\t\t       &ip_addr, true,\n\t\t\t\t\t\t       IRDMA_ARP_ADD);\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nvoid irdma_add_ip(struct irdma_device *iwdev)\n{\n\tirdma_add_ipv4_addr(iwdev);\n\tirdma_add_ipv6_addr(iwdev);\n}\n\n \nstruct irdma_cqp_request *irdma_alloc_and_get_cqp_request(struct irdma_cqp *cqp,\n\t\t\t\t\t\t\t  bool wait)\n{\n\tstruct irdma_cqp_request *cqp_request = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cqp->req_lock, flags);\n\tif (!list_empty(&cqp->cqp_avail_reqs)) {\n\t\tcqp_request = list_first_entry(&cqp->cqp_avail_reqs,\n\t\t\t\t\t       struct irdma_cqp_request, list);\n\t\tlist_del_init(&cqp_request->list);\n\t}\n\tspin_unlock_irqrestore(&cqp->req_lock, flags);\n\tif (!cqp_request) {\n\t\tcqp_request = kzalloc(sizeof(*cqp_request), GFP_ATOMIC);\n\t\tif (cqp_request) {\n\t\t\tcqp_request->dynamic = true;\n\t\t\tif (wait)\n\t\t\t\tinit_waitqueue_head(&cqp_request->waitq);\n\t\t}\n\t}\n\tif (!cqp_request) {\n\t\tibdev_dbg(to_ibdev(cqp->sc_cqp.dev), \"ERR: CQP Request Fail: No Memory\");\n\t\treturn NULL;\n\t}\n\n\tcqp_request->waiting = wait;\n\trefcount_set(&cqp_request->refcnt, 1);\n\tmemset(&cqp_request->compl_info, 0, sizeof(cqp_request->compl_info));\n\n\treturn cqp_request;\n}\n\n \nstatic inline void irdma_get_cqp_request(struct irdma_cqp_request *cqp_request)\n{\n\trefcount_inc(&cqp_request->refcnt);\n}\n\n \nvoid irdma_free_cqp_request(struct irdma_cqp *cqp,\n\t\t\t    struct irdma_cqp_request *cqp_request)\n{\n\tunsigned long flags;\n\n\tif (cqp_request->dynamic) {\n\t\tkfree(cqp_request);\n\t} else {\n\t\tWRITE_ONCE(cqp_request->request_done, false);\n\t\tcqp_request->callback_fcn = NULL;\n\t\tcqp_request->waiting = false;\n\n\t\tspin_lock_irqsave(&cqp->req_lock, flags);\n\t\tlist_add_tail(&cqp_request->list, &cqp->cqp_avail_reqs);\n\t\tspin_unlock_irqrestore(&cqp->req_lock, flags);\n\t}\n\twake_up(&cqp->remove_wq);\n}\n\n \nvoid irdma_put_cqp_request(struct irdma_cqp *cqp,\n\t\t\t   struct irdma_cqp_request *cqp_request)\n{\n\tif (refcount_dec_and_test(&cqp_request->refcnt))\n\t\tirdma_free_cqp_request(cqp, cqp_request);\n}\n\n \nstatic void\nirdma_free_pending_cqp_request(struct irdma_cqp *cqp,\n\t\t\t       struct irdma_cqp_request *cqp_request)\n{\n\tif (cqp_request->waiting) {\n\t\tcqp_request->compl_info.error = true;\n\t\tWRITE_ONCE(cqp_request->request_done, true);\n\t\twake_up(&cqp_request->waitq);\n\t}\n\twait_event_timeout(cqp->remove_wq,\n\t\t\t   refcount_read(&cqp_request->refcnt) == 1, 1000);\n\tirdma_put_cqp_request(cqp, cqp_request);\n}\n\n \nvoid irdma_cleanup_pending_cqp_op(struct irdma_pci_f *rf)\n{\n\tstruct irdma_sc_dev *dev = &rf->sc_dev;\n\tstruct irdma_cqp *cqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request = NULL;\n\tstruct cqp_cmds_info *pcmdinfo = NULL;\n\tu32 i, pending_work, wqe_idx;\n\n\tpending_work = IRDMA_RING_USED_QUANTA(cqp->sc_cqp.sq_ring);\n\twqe_idx = IRDMA_RING_CURRENT_TAIL(cqp->sc_cqp.sq_ring);\n\tfor (i = 0; i < pending_work; i++) {\n\t\tcqp_request = (struct irdma_cqp_request *)(unsigned long)\n\t\t\t\t      cqp->scratch_array[wqe_idx];\n\t\tif (cqp_request)\n\t\t\tirdma_free_pending_cqp_request(cqp, cqp_request);\n\t\twqe_idx = (wqe_idx + 1) % IRDMA_RING_SIZE(cqp->sc_cqp.sq_ring);\n\t}\n\n\twhile (!list_empty(&dev->cqp_cmd_head)) {\n\t\tpcmdinfo = irdma_remove_cqp_head(dev);\n\t\tcqp_request =\n\t\t\tcontainer_of(pcmdinfo, struct irdma_cqp_request, info);\n\t\tif (cqp_request)\n\t\t\tirdma_free_pending_cqp_request(cqp, cqp_request);\n\t}\n}\n\n \nstatic int irdma_wait_event(struct irdma_pci_f *rf,\n\t\t\t    struct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_cqp_timeout cqp_timeout = {};\n\tbool cqp_error = false;\n\tint err_code = 0;\n\n\tcqp_timeout.compl_cqp_cmds = atomic64_read(&rf->sc_dev.cqp->completed_ops);\n\tdo {\n\t\tirdma_cqp_ce_handler(rf, &rf->ccq.sc_cq);\n\t\tif (wait_event_timeout(cqp_request->waitq,\n\t\t\t\t       READ_ONCE(cqp_request->request_done),\n\t\t\t\t       msecs_to_jiffies(CQP_COMPL_WAIT_TIME_MS)))\n\t\t\tbreak;\n\n\t\tirdma_check_cqp_progress(&cqp_timeout, &rf->sc_dev);\n\n\t\tif (cqp_timeout.count < CQP_TIMEOUT_THRESHOLD)\n\t\t\tcontinue;\n\n\t\tif (!rf->reset) {\n\t\t\trf->reset = true;\n\t\t\trf->gen_ops.request_reset(rf);\n\t\t}\n\t\treturn -ETIMEDOUT;\n\t} while (1);\n\n\tcqp_error = cqp_request->compl_info.error;\n\tif (cqp_error) {\n\t\terr_code = -EIO;\n\t\tif (cqp_request->compl_info.maj_err_code == 0xFFFF) {\n\t\t\tif (cqp_request->compl_info.min_err_code == 0x8002)\n\t\t\t\terr_code = -EBUSY;\n\t\t\telse if (cqp_request->compl_info.min_err_code == 0x8029) {\n\t\t\t\tif (!rf->reset) {\n\t\t\t\t\trf->reset = true;\n\t\t\t\t\trf->gen_ops.request_reset(rf);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err_code;\n}\n\nstatic const char *const irdma_cqp_cmd_names[IRDMA_MAX_CQP_OPS] = {\n\t[IRDMA_OP_CEQ_DESTROY] = \"Destroy CEQ Cmd\",\n\t[IRDMA_OP_AEQ_DESTROY] = \"Destroy AEQ Cmd\",\n\t[IRDMA_OP_DELETE_ARP_CACHE_ENTRY] = \"Delete ARP Cache Cmd\",\n\t[IRDMA_OP_MANAGE_APBVT_ENTRY] = \"Manage APBV Table Entry Cmd\",\n\t[IRDMA_OP_CEQ_CREATE] = \"CEQ Create Cmd\",\n\t[IRDMA_OP_AEQ_CREATE] = \"AEQ Destroy Cmd\",\n\t[IRDMA_OP_MANAGE_QHASH_TABLE_ENTRY] = \"Manage Quad Hash Table Entry Cmd\",\n\t[IRDMA_OP_QP_MODIFY] = \"Modify QP Cmd\",\n\t[IRDMA_OP_QP_UPLOAD_CONTEXT] = \"Upload Context Cmd\",\n\t[IRDMA_OP_CQ_CREATE] = \"Create CQ Cmd\",\n\t[IRDMA_OP_CQ_DESTROY] = \"Destroy CQ Cmd\",\n\t[IRDMA_OP_QP_CREATE] = \"Create QP Cmd\",\n\t[IRDMA_OP_QP_DESTROY] = \"Destroy QP Cmd\",\n\t[IRDMA_OP_ALLOC_STAG] = \"Allocate STag Cmd\",\n\t[IRDMA_OP_MR_REG_NON_SHARED] = \"Register Non-Shared MR Cmd\",\n\t[IRDMA_OP_DEALLOC_STAG] = \"Deallocate STag Cmd\",\n\t[IRDMA_OP_MW_ALLOC] = \"Allocate Memory Window Cmd\",\n\t[IRDMA_OP_QP_FLUSH_WQES] = \"Flush QP Cmd\",\n\t[IRDMA_OP_ADD_ARP_CACHE_ENTRY] = \"Add ARP Cache Cmd\",\n\t[IRDMA_OP_MANAGE_PUSH_PAGE] = \"Manage Push Page Cmd\",\n\t[IRDMA_OP_UPDATE_PE_SDS] = \"Update PE SDs Cmd\",\n\t[IRDMA_OP_MANAGE_HMC_PM_FUNC_TABLE] = \"Manage HMC PM Function Table Cmd\",\n\t[IRDMA_OP_SUSPEND] = \"Suspend QP Cmd\",\n\t[IRDMA_OP_RESUME] = \"Resume QP Cmd\",\n\t[IRDMA_OP_MANAGE_VF_PBLE_BP] = \"Manage VF PBLE Backing Pages Cmd\",\n\t[IRDMA_OP_QUERY_FPM_VAL] = \"Query FPM Values Cmd\",\n\t[IRDMA_OP_COMMIT_FPM_VAL] = \"Commit FPM Values Cmd\",\n\t[IRDMA_OP_AH_CREATE] = \"Create Address Handle Cmd\",\n\t[IRDMA_OP_AH_MODIFY] = \"Modify Address Handle Cmd\",\n\t[IRDMA_OP_AH_DESTROY] = \"Destroy Address Handle Cmd\",\n\t[IRDMA_OP_MC_CREATE] = \"Create Multicast Group Cmd\",\n\t[IRDMA_OP_MC_DESTROY] = \"Destroy Multicast Group Cmd\",\n\t[IRDMA_OP_MC_MODIFY] = \"Modify Multicast Group Cmd\",\n\t[IRDMA_OP_STATS_ALLOCATE] = \"Add Statistics Instance Cmd\",\n\t[IRDMA_OP_STATS_FREE] = \"Free Statistics Instance Cmd\",\n\t[IRDMA_OP_STATS_GATHER] = \"Gather Statistics Cmd\",\n\t[IRDMA_OP_WS_ADD_NODE] = \"Add Work Scheduler Node Cmd\",\n\t[IRDMA_OP_WS_MODIFY_NODE] = \"Modify Work Scheduler Node Cmd\",\n\t[IRDMA_OP_WS_DELETE_NODE] = \"Delete Work Scheduler Node Cmd\",\n\t[IRDMA_OP_SET_UP_MAP] = \"Set UP-UP Mapping Cmd\",\n\t[IRDMA_OP_GEN_AE] = \"Generate AE Cmd\",\n\t[IRDMA_OP_QUERY_RDMA_FEATURES] = \"RDMA Get Features Cmd\",\n\t[IRDMA_OP_ALLOC_LOCAL_MAC_ENTRY] = \"Allocate Local MAC Entry Cmd\",\n\t[IRDMA_OP_ADD_LOCAL_MAC_ENTRY] = \"Add Local MAC Entry Cmd\",\n\t[IRDMA_OP_DELETE_LOCAL_MAC_ENTRY] = \"Delete Local MAC Entry Cmd\",\n\t[IRDMA_OP_CQ_MODIFY] = \"CQ Modify Cmd\",\n};\n\nstatic const struct irdma_cqp_err_info irdma_noncrit_err_list[] = {\n\t{0xffff, 0x8002, \"Invalid State\"},\n\t{0xffff, 0x8006, \"Flush No Wqe Pending\"},\n\t{0xffff, 0x8007, \"Modify QP Bad Close\"},\n\t{0xffff, 0x8009, \"LLP Closed\"},\n\t{0xffff, 0x800a, \"Reset Not Sent\"}\n};\n\n \nbool irdma_cqp_crit_err(struct irdma_sc_dev *dev, u8 cqp_cmd,\n\t\t\tu16 maj_err_code, u16 min_err_code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(irdma_noncrit_err_list); ++i) {\n\t\tif (maj_err_code == irdma_noncrit_err_list[i].maj &&\n\t\t    min_err_code == irdma_noncrit_err_list[i].min) {\n\t\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t\t  \"CQP: [%s Error][%s] maj=0x%x min=0x%x\\n\",\n\t\t\t\t  irdma_noncrit_err_list[i].desc,\n\t\t\t\t  irdma_cqp_cmd_names[cqp_cmd], maj_err_code,\n\t\t\t\t  min_err_code);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n \nint irdma_handle_cqp_op(struct irdma_pci_f *rf,\n\t\t\tstruct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_sc_dev *dev = &rf->sc_dev;\n\tstruct cqp_cmds_info *info = &cqp_request->info;\n\tint status;\n\tbool put_cqp_request = true;\n\n\tif (rf->reset)\n\t\treturn -EBUSY;\n\n\tirdma_get_cqp_request(cqp_request);\n\tstatus = irdma_process_cqp_cmd(dev, info);\n\tif (status)\n\t\tgoto err;\n\n\tif (cqp_request->waiting) {\n\t\tput_cqp_request = false;\n\t\tstatus = irdma_wait_event(rf, cqp_request);\n\t\tif (status)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tif (irdma_cqp_crit_err(dev, info->cqp_cmd,\n\t\t\t       cqp_request->compl_info.maj_err_code,\n\t\t\t       cqp_request->compl_info.min_err_code))\n\t\tibdev_err(&rf->iwdev->ibdev,\n\t\t\t  \"[%s Error][op_code=%d] status=%d waiting=%d completion_err=%d maj=0x%x min=0x%x\\n\",\n\t\t\t  irdma_cqp_cmd_names[info->cqp_cmd], info->cqp_cmd, status, cqp_request->waiting,\n\t\t\t  cqp_request->compl_info.error, cqp_request->compl_info.maj_err_code,\n\t\t\t  cqp_request->compl_info.min_err_code);\n\n\tif (put_cqp_request)\n\t\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\nvoid irdma_qp_add_ref(struct ib_qp *ibqp)\n{\n\tstruct irdma_qp *iwqp = (struct irdma_qp *)ibqp;\n\n\trefcount_inc(&iwqp->refcnt);\n}\n\nvoid irdma_qp_rem_ref(struct ib_qp *ibqp)\n{\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tu32 qp_num;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwdev->rf->qptable_lock, flags);\n\tif (!refcount_dec_and_test(&iwqp->refcnt)) {\n\t\tspin_unlock_irqrestore(&iwdev->rf->qptable_lock, flags);\n\t\treturn;\n\t}\n\n\tqp_num = iwqp->ibqp.qp_num;\n\tiwdev->rf->qp_table[qp_num] = NULL;\n\tspin_unlock_irqrestore(&iwdev->rf->qptable_lock, flags);\n\tcomplete(&iwqp->free_qp);\n}\n\nvoid irdma_cq_add_ref(struct ib_cq *ibcq)\n{\n\tstruct irdma_cq *iwcq = to_iwcq(ibcq);\n\n\trefcount_inc(&iwcq->refcnt);\n}\n\nvoid irdma_cq_rem_ref(struct ib_cq *ibcq)\n{\n\tstruct ib_device *ibdev = ibcq->device;\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_cq *iwcq = to_iwcq(ibcq);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwdev->rf->cqtable_lock, flags);\n\tif (!refcount_dec_and_test(&iwcq->refcnt)) {\n\t\tspin_unlock_irqrestore(&iwdev->rf->cqtable_lock, flags);\n\t\treturn;\n\t}\n\n\tiwdev->rf->cq_table[iwcq->cq_num] = NULL;\n\tspin_unlock_irqrestore(&iwdev->rf->cqtable_lock, flags);\n\tcomplete(&iwcq->free_cq);\n}\n\nstruct ib_device *to_ibdev(struct irdma_sc_dev *dev)\n{\n\treturn &(container_of(dev, struct irdma_pci_f, sc_dev))->iwdev->ibdev;\n}\n\n \nstruct ib_qp *irdma_get_qp(struct ib_device *device, int qpn)\n{\n\tstruct irdma_device *iwdev = to_iwdev(device);\n\n\tif (qpn < IW_FIRST_QPN || qpn >= iwdev->rf->max_qp)\n\t\treturn NULL;\n\n\treturn &iwdev->rf->qp_table[qpn]->ibqp;\n}\n\n \nvoid *irdma_remove_cqp_head(struct irdma_sc_dev *dev)\n{\n\tstruct list_head *entry;\n\tstruct list_head *list = &dev->cqp_cmd_head;\n\n\tif (list_empty(list))\n\t\treturn NULL;\n\n\tentry = list->next;\n\tlist_del(entry);\n\n\treturn entry;\n}\n\n \nint irdma_cqp_sds_cmd(struct irdma_sc_dev *dev,\n\t\t      struct irdma_update_sds_info *sdinfo)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tmemcpy(&cqp_info->in.u.update_pe_sds.info, sdinfo,\n\t       sizeof(cqp_info->in.u.update_pe_sds.info));\n\tcqp_info->cqp_cmd = IRDMA_OP_UPDATE_PE_SDS;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.update_pe_sds.dev = dev;\n\tcqp_info->in.u.update_pe_sds.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_qp_suspend_resume(struct irdma_sc_qp *qp, u8 op)\n{\n\tstruct irdma_sc_dev *dev = qp->dev;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct irdma_sc_cqp *cqp = dev->cqp;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, false);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = op;\n\tcqp_info->in.u.suspend_resume.cqp = cqp;\n\tcqp_info->in.u.suspend_resume.qp = qp;\n\tcqp_info->in.u.suspend_resume.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nvoid irdma_term_modify_qp(struct irdma_sc_qp *qp, u8 next_state, u8 term,\n\t\t\t  u8 term_len)\n{\n\tstruct irdma_qp *iwqp;\n\n\tiwqp = qp->qp_uk.back_qp;\n\tirdma_next_iw_state(iwqp, next_state, 0, term, term_len);\n};\n\n \nvoid irdma_terminate_done(struct irdma_sc_qp *qp, int timeout_occurred)\n{\n\tstruct irdma_qp *iwqp;\n\tu8 hte = 0;\n\tbool first_time;\n\tunsigned long flags;\n\n\tiwqp = qp->qp_uk.back_qp;\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\tif (iwqp->hte_added) {\n\t\tiwqp->hte_added = 0;\n\t\thte = 1;\n\t}\n\tfirst_time = !(qp->term_flags & IRDMA_TERM_DONE);\n\tqp->term_flags |= IRDMA_TERM_DONE;\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\tif (first_time) {\n\t\tif (!timeout_occurred)\n\t\t\tirdma_terminate_del_timer(qp);\n\n\t\tirdma_next_iw_state(iwqp, IRDMA_QP_STATE_ERROR, hte, 0, 0);\n\t\tirdma_cm_disconn(iwqp);\n\t}\n}\n\nstatic void irdma_terminate_timeout(struct timer_list *t)\n{\n\tstruct irdma_qp *iwqp = from_timer(iwqp, t, terminate_timer);\n\tstruct irdma_sc_qp *qp = &iwqp->sc_qp;\n\n\tirdma_terminate_done(qp, 1);\n\tirdma_qp_rem_ref(&iwqp->ibqp);\n}\n\n \nvoid irdma_terminate_start_timer(struct irdma_sc_qp *qp)\n{\n\tstruct irdma_qp *iwqp;\n\n\tiwqp = qp->qp_uk.back_qp;\n\tirdma_qp_add_ref(&iwqp->ibqp);\n\ttimer_setup(&iwqp->terminate_timer, irdma_terminate_timeout, 0);\n\tiwqp->terminate_timer.expires = jiffies + HZ;\n\n\tadd_timer(&iwqp->terminate_timer);\n}\n\n \nvoid irdma_terminate_del_timer(struct irdma_sc_qp *qp)\n{\n\tstruct irdma_qp *iwqp;\n\tint ret;\n\n\tiwqp = qp->qp_uk.back_qp;\n\tret = del_timer(&iwqp->terminate_timer);\n\tif (ret)\n\t\tirdma_qp_rem_ref(&iwqp->ibqp);\n}\n\n \nint irdma_cqp_query_fpm_val_cmd(struct irdma_sc_dev *dev,\n\t\t\t\tstruct irdma_dma_mem *val_mem, u8 hmc_fn_id)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_request->param = NULL;\n\tcqp_info->in.u.query_fpm_val.cqp = dev->cqp;\n\tcqp_info->in.u.query_fpm_val.fpm_val_pa = val_mem->pa;\n\tcqp_info->in.u.query_fpm_val.fpm_val_va = val_mem->va;\n\tcqp_info->in.u.query_fpm_val.hmc_fn_id = hmc_fn_id;\n\tcqp_info->cqp_cmd = IRDMA_OP_QUERY_FPM_VAL;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.query_fpm_val.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_commit_fpm_val_cmd(struct irdma_sc_dev *dev,\n\t\t\t\t struct irdma_dma_mem *val_mem, u8 hmc_fn_id)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_request->param = NULL;\n\tcqp_info->in.u.commit_fpm_val.cqp = dev->cqp;\n\tcqp_info->in.u.commit_fpm_val.fpm_val_pa = val_mem->pa;\n\tcqp_info->in.u.commit_fpm_val.fpm_val_va = val_mem->va;\n\tcqp_info->in.u.commit_fpm_val.hmc_fn_id = hmc_fn_id;\n\tcqp_info->cqp_cmd = IRDMA_OP_COMMIT_FPM_VAL;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.commit_fpm_val.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_cq_create_cmd(struct irdma_sc_dev *dev, struct irdma_sc_cq *cq)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = IRDMA_OP_CQ_CREATE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.cq_create.cq = cq;\n\tcqp_info->in.u.cq_create.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(iwcqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_qp_create_cmd(struct irdma_sc_dev *dev, struct irdma_sc_qp *qp)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_create_qp_info *qp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tqp_info = &cqp_request->info.in.u.qp_create.info;\n\tmemset(qp_info, 0, sizeof(*qp_info));\n\tqp_info->cq_num_valid = true;\n\tqp_info->next_iwarp_state = IRDMA_QP_STATE_RTS;\n\tcqp_info->cqp_cmd = IRDMA_OP_QP_CREATE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.qp_create.qp = qp;\n\tcqp_info->in.u.qp_create.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(iwcqp, cqp_request);\n\n\treturn status;\n}\n\n \nstatic void irdma_dealloc_push_page(struct irdma_pci_f *rf,\n\t\t\t\t    struct irdma_sc_qp *qp)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tif (qp->push_idx == IRDMA_INVALID_PUSH_PAGE_INDEX)\n\t\treturn;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, false);\n\tif (!cqp_request)\n\t\treturn;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = IRDMA_OP_MANAGE_PUSH_PAGE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.manage_push_page.info.push_idx = qp->push_idx;\n\tcqp_info->in.u.manage_push_page.info.qs_handle = qp->qs_handle;\n\tcqp_info->in.u.manage_push_page.info.free_page = 1;\n\tcqp_info->in.u.manage_push_page.info.push_page_type = 0;\n\tcqp_info->in.u.manage_push_page.cqp = &rf->cqp.sc_cqp;\n\tcqp_info->in.u.manage_push_page.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tif (!status)\n\t\tqp->push_idx = IRDMA_INVALID_PUSH_PAGE_INDEX;\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n}\n\n \nvoid irdma_free_qp_rsrc(struct irdma_qp *iwqp)\n{\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tu32 qp_num = iwqp->ibqp.qp_num;\n\n\tirdma_ieq_cleanup_qp(iwdev->vsi.ieq, &iwqp->sc_qp);\n\tirdma_dealloc_push_page(rf, &iwqp->sc_qp);\n\tif (iwqp->sc_qp.vsi) {\n\t\tirdma_qp_rem_qos(&iwqp->sc_qp);\n\t\tiwqp->sc_qp.dev->ws_remove(iwqp->sc_qp.vsi,\n\t\t\t\t\t   iwqp->sc_qp.user_pri);\n\t}\n\n\tif (qp_num > 2)\n\t\tirdma_free_rsrc(rf, rf->allocated_qps, qp_num);\n\tdma_free_coherent(rf->sc_dev.hw->device, iwqp->q2_ctx_mem.size,\n\t\t\t  iwqp->q2_ctx_mem.va, iwqp->q2_ctx_mem.pa);\n\tiwqp->q2_ctx_mem.va = NULL;\n\tdma_free_coherent(rf->sc_dev.hw->device, iwqp->kqp.dma_mem.size,\n\t\t\t  iwqp->kqp.dma_mem.va, iwqp->kqp.dma_mem.pa);\n\tiwqp->kqp.dma_mem.va = NULL;\n\tkfree(iwqp->kqp.sq_wrid_mem);\n\tkfree(iwqp->kqp.rq_wrid_mem);\n}\n\n \nvoid irdma_cq_wq_destroy(struct irdma_pci_f *rf, struct irdma_sc_cq *cq)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = IRDMA_OP_CQ_DESTROY;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.cq_destroy.cq = cq;\n\tcqp_info->in.u.cq_destroy.scratch = (uintptr_t)cqp_request;\n\n\tirdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n}\n\n \nstatic void irdma_hw_modify_qp_callback(struct irdma_cqp_request *cqp_request)\n{\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_qp *iwqp;\n\n\tcqp_info = &cqp_request->info;\n\tiwqp = cqp_info->in.u.qp_modify.qp->qp_uk.back_qp;\n\tatomic_dec(&iwqp->hw_mod_qp_pend);\n\twake_up(&iwqp->mod_qp_waitq);\n}\n\n \nint irdma_hw_modify_qp(struct irdma_device *iwdev, struct irdma_qp *iwqp,\n\t\t       struct irdma_modify_qp_info *info, bool wait)\n{\n\tint status;\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_modify_qp_info *m_info;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, wait);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tif (!wait) {\n\t\tcqp_request->callback_fcn = irdma_hw_modify_qp_callback;\n\t\tatomic_inc(&iwqp->hw_mod_qp_pend);\n\t}\n\tcqp_info = &cqp_request->info;\n\tm_info = &cqp_info->in.u.qp_modify.info;\n\tmemcpy(m_info, info, sizeof(*m_info));\n\tcqp_info->cqp_cmd = IRDMA_OP_QP_MODIFY;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.qp_modify.qp = &iwqp->sc_qp;\n\tcqp_info->in.u.qp_modify.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\tif (status) {\n\t\tif (rdma_protocol_roce(&iwdev->ibdev, 1))\n\t\t\treturn status;\n\n\t\tswitch (m_info->next_iwarp_state) {\n\t\t\tstruct irdma_gen_ae_info ae_info;\n\n\t\tcase IRDMA_QP_STATE_RTS:\n\t\tcase IRDMA_QP_STATE_IDLE:\n\t\tcase IRDMA_QP_STATE_TERMINATE:\n\t\tcase IRDMA_QP_STATE_CLOSING:\n\t\t\tif (info->curr_iwarp_state == IRDMA_QP_STATE_IDLE)\n\t\t\t\tirdma_send_reset(iwqp->cm_node);\n\t\t\telse\n\t\t\t\tiwqp->sc_qp.term_flags = IRDMA_TERM_DONE;\n\t\t\tif (!wait) {\n\t\t\t\tae_info.ae_code = IRDMA_AE_BAD_CLOSE;\n\t\t\t\tae_info.ae_src = 0;\n\t\t\t\tirdma_gen_ae(rf, &iwqp->sc_qp, &ae_info, false);\n\t\t\t} else {\n\t\t\t\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp,\n\t\t\t\t\t\t\t\t\t      wait);\n\t\t\t\tif (!cqp_request)\n\t\t\t\t\treturn -ENOMEM;\n\n\t\t\t\tcqp_info = &cqp_request->info;\n\t\t\t\tm_info = &cqp_info->in.u.qp_modify.info;\n\t\t\t\tmemcpy(m_info, info, sizeof(*m_info));\n\t\t\t\tcqp_info->cqp_cmd = IRDMA_OP_QP_MODIFY;\n\t\t\t\tcqp_info->post_sq = 1;\n\t\t\t\tcqp_info->in.u.qp_modify.qp = &iwqp->sc_qp;\n\t\t\t\tcqp_info->in.u.qp_modify.scratch = (uintptr_t)cqp_request;\n\t\t\t\tm_info->next_iwarp_state = IRDMA_QP_STATE_ERROR;\n\t\t\t\tm_info->reset_tcp_conn = true;\n\t\t\t\tirdma_handle_cqp_op(rf, cqp_request);\n\t\t\t\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IRDMA_QP_STATE_ERROR:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n \nvoid irdma_cqp_cq_destroy_cmd(struct irdma_sc_dev *dev, struct irdma_sc_cq *cq)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\n\tirdma_cq_wq_destroy(rf, cq);\n}\n\n \nint irdma_cqp_qp_destroy_cmd(struct irdma_sc_dev *dev, struct irdma_sc_qp *qp)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tmemset(cqp_info, 0, sizeof(*cqp_info));\n\tcqp_info->cqp_cmd = IRDMA_OP_QP_DESTROY;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.qp_destroy.qp = qp;\n\tcqp_info->in.u.qp_destroy.scratch = (uintptr_t)cqp_request;\n\tcqp_info->in.u.qp_destroy.remove_hash_idx = true;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nvoid irdma_ieq_mpa_crc_ae(struct irdma_sc_dev *dev, struct irdma_sc_qp *qp)\n{\n\tstruct irdma_gen_ae_info info = {};\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\n\tibdev_dbg(&rf->iwdev->ibdev, \"AEQ: Generate MPA CRC AE\\n\");\n\tinfo.ae_code = IRDMA_AE_LLP_RECEIVED_MPA_CRC_ERROR;\n\tinfo.ae_src = IRDMA_AE_SOURCE_RQ;\n\tirdma_gen_ae(rf, qp, &info, false);\n}\n\n \nint irdma_init_hash_desc(struct shash_desc **desc)\n{\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *tdesc;\n\n\ttfm = crypto_alloc_shash(\"crc32c\", 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn -EINVAL;\n\n\ttdesc = kzalloc(sizeof(*tdesc) + crypto_shash_descsize(tfm),\n\t\t\tGFP_KERNEL);\n\tif (!tdesc) {\n\t\tcrypto_free_shash(tfm);\n\t\treturn -EINVAL;\n\t}\n\n\ttdesc->tfm = tfm;\n\t*desc = tdesc;\n\n\treturn 0;\n}\n\n \nvoid irdma_free_hash_desc(struct shash_desc *desc)\n{\n\tif (desc) {\n\t\tcrypto_free_shash(desc->tfm);\n\t\tkfree(desc);\n\t}\n}\n\n \nint irdma_ieq_check_mpacrc(struct shash_desc *desc, void *addr, u32 len,\n\t\t\t   u32 val)\n{\n\tu32 crc = 0;\n\tint ret;\n\tint ret_code = 0;\n\n\tcrypto_shash_init(desc);\n\tret = crypto_shash_update(desc, addr, len);\n\tif (!ret)\n\t\tcrypto_shash_final(desc, (u8 *)&crc);\n\tif (crc != val)\n\t\tret_code = -EINVAL;\n\n\treturn ret_code;\n}\n\n \nstruct irdma_sc_qp *irdma_ieq_get_qp(struct irdma_sc_dev *dev,\n\t\t\t\t     struct irdma_puda_buf *buf)\n{\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_cm_node *cm_node;\n\tstruct irdma_device *iwdev = buf->vsi->back_vsi;\n\tu32 loc_addr[4] = {};\n\tu32 rem_addr[4] = {};\n\tu16 loc_port, rem_port;\n\tstruct ipv6hdr *ip6h;\n\tstruct iphdr *iph = (struct iphdr *)buf->iph;\n\tstruct tcphdr *tcph = (struct tcphdr *)buf->tcph;\n\n\tif (iph->version == 4) {\n\t\tloc_addr[0] = ntohl(iph->daddr);\n\t\trem_addr[0] = ntohl(iph->saddr);\n\t} else {\n\t\tip6h = (struct ipv6hdr *)buf->iph;\n\t\tirdma_copy_ip_ntohl(loc_addr, ip6h->daddr.in6_u.u6_addr32);\n\t\tirdma_copy_ip_ntohl(rem_addr, ip6h->saddr.in6_u.u6_addr32);\n\t}\n\tloc_port = ntohs(tcph->dest);\n\trem_port = ntohs(tcph->source);\n\tcm_node = irdma_find_node(&iwdev->cm_core, rem_port, rem_addr, loc_port,\n\t\t\t\t  loc_addr, buf->vlan_valid ? buf->vlan_id : 0xFFFF);\n\tif (!cm_node)\n\t\treturn NULL;\n\n\tiwqp = cm_node->iwqp;\n\tirdma_rem_ref_cm_node(cm_node);\n\n\treturn &iwqp->sc_qp;\n}\n\n \nvoid irdma_send_ieq_ack(struct irdma_sc_qp *qp)\n{\n\tstruct irdma_cm_node *cm_node = ((struct irdma_qp *)qp->qp_uk.back_qp)->cm_node;\n\tstruct irdma_puda_buf *buf = qp->pfpdu.lastrcv_buf;\n\tstruct tcphdr *tcph = (struct tcphdr *)buf->tcph;\n\n\tcm_node->tcp_cntxt.rcv_nxt = qp->pfpdu.nextseqnum;\n\tcm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\n\n\tirdma_send_ack(cm_node);\n}\n\n \nvoid irdma_puda_ieq_get_ah_info(struct irdma_sc_qp *qp,\n\t\t\t\tstruct irdma_ah_info *ah_info)\n{\n\tstruct irdma_puda_buf *buf = qp->pfpdu.ah_buf;\n\tstruct iphdr *iph;\n\tstruct ipv6hdr *ip6h;\n\n\tmemset(ah_info, 0, sizeof(*ah_info));\n\tah_info->do_lpbk = true;\n\tah_info->vlan_tag = buf->vlan_id;\n\tah_info->insert_vlan_tag = buf->vlan_valid;\n\tah_info->ipv4_valid = buf->ipv4;\n\tah_info->vsi = qp->vsi;\n\n\tif (buf->smac_valid)\n\t\tether_addr_copy(ah_info->mac_addr, buf->smac);\n\n\tif (buf->ipv4) {\n\t\tah_info->ipv4_valid = true;\n\t\tiph = (struct iphdr *)buf->iph;\n\t\tah_info->hop_ttl = iph->ttl;\n\t\tah_info->tc_tos = iph->tos;\n\t\tah_info->dest_ip_addr[0] = ntohl(iph->daddr);\n\t\tah_info->src_ip_addr[0] = ntohl(iph->saddr);\n\t} else {\n\t\tip6h = (struct ipv6hdr *)buf->iph;\n\t\tah_info->hop_ttl = ip6h->hop_limit;\n\t\tah_info->tc_tos = ip6h->priority;\n\t\tirdma_copy_ip_ntohl(ah_info->dest_ip_addr,\n\t\t\t\t    ip6h->daddr.in6_u.u6_addr32);\n\t\tirdma_copy_ip_ntohl(ah_info->src_ip_addr,\n\t\t\t\t    ip6h->saddr.in6_u.u6_addr32);\n\t}\n\n\tah_info->dst_arpindex = irdma_arp_table(dev_to_rf(qp->dev),\n\t\t\t\t\t\tah_info->dest_ip_addr,\n\t\t\t\t\t\tah_info->ipv4_valid,\n\t\t\t\t\t\tNULL, IRDMA_ARP_RESOLVE);\n}\n\n \nstatic void irdma_gen1_ieq_update_tcpip_info(struct irdma_puda_buf *buf,\n\t\t\t\t\t     u16 len, u32 seqnum)\n{\n\tstruct tcphdr *tcph;\n\tstruct iphdr *iph;\n\tu16 iphlen;\n\tu16 pktsize;\n\tu8 *addr = buf->mem.va;\n\n\tiphlen = (buf->ipv4) ? 20 : 40;\n\tiph = (struct iphdr *)(addr + buf->maclen);\n\ttcph = (struct tcphdr *)(addr + buf->maclen + iphlen);\n\tpktsize = len + buf->tcphlen + iphlen;\n\tiph->tot_len = htons(pktsize);\n\ttcph->seq = htonl(seqnum);\n}\n\n \nvoid irdma_ieq_update_tcpip_info(struct irdma_puda_buf *buf, u16 len,\n\t\t\t\t u32 seqnum)\n{\n\tstruct tcphdr *tcph;\n\tu8 *addr;\n\n\tif (buf->vsi->dev->hw_attrs.uk_attrs.hw_rev == IRDMA_GEN_1)\n\t\treturn irdma_gen1_ieq_update_tcpip_info(buf, len, seqnum);\n\n\taddr = buf->mem.va;\n\ttcph = (struct tcphdr *)addr;\n\ttcph->seq = htonl(seqnum);\n}\n\n \nstatic int irdma_gen1_puda_get_tcpip_info(struct irdma_puda_cmpl_info *info,\n\t\t\t\t\t  struct irdma_puda_buf *buf)\n{\n\tstruct iphdr *iph;\n\tstruct ipv6hdr *ip6h;\n\tstruct tcphdr *tcph;\n\tu16 iphlen;\n\tu16 pkt_len;\n\tu8 *mem = buf->mem.va;\n\tstruct ethhdr *ethh = buf->mem.va;\n\n\tif (ethh->h_proto == htons(0x8100)) {\n\t\tinfo->vlan_valid = true;\n\t\tbuf->vlan_id = ntohs(((struct vlan_ethhdr *)ethh)->h_vlan_TCI) &\n\t\t\t       VLAN_VID_MASK;\n\t}\n\n\tbuf->maclen = (info->vlan_valid) ? 18 : 14;\n\tiphlen = (info->l3proto) ? 40 : 20;\n\tbuf->ipv4 = (info->l3proto) ? false : true;\n\tbuf->iph = mem + buf->maclen;\n\tiph = (struct iphdr *)buf->iph;\n\tbuf->tcph = buf->iph + iphlen;\n\ttcph = (struct tcphdr *)buf->tcph;\n\n\tif (buf->ipv4) {\n\t\tpkt_len = ntohs(iph->tot_len);\n\t} else {\n\t\tip6h = (struct ipv6hdr *)buf->iph;\n\t\tpkt_len = ntohs(ip6h->payload_len) + iphlen;\n\t}\n\n\tbuf->totallen = pkt_len + buf->maclen;\n\n\tif (info->payload_len < buf->totallen) {\n\t\tibdev_dbg(to_ibdev(buf->vsi->dev),\n\t\t\t  \"ERR: payload_len = 0x%x totallen expected0x%x\\n\",\n\t\t\t  info->payload_len, buf->totallen);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf->tcphlen = tcph->doff << 2;\n\tbuf->datalen = pkt_len - iphlen - buf->tcphlen;\n\tbuf->data = buf->datalen ? buf->tcph + buf->tcphlen : NULL;\n\tbuf->hdrlen = buf->maclen + iphlen + buf->tcphlen;\n\tbuf->seqnum = ntohl(tcph->seq);\n\n\treturn 0;\n}\n\n \nint irdma_puda_get_tcpip_info(struct irdma_puda_cmpl_info *info,\n\t\t\t      struct irdma_puda_buf *buf)\n{\n\tstruct tcphdr *tcph;\n\tu32 pkt_len;\n\tu8 *mem;\n\n\tif (buf->vsi->dev->hw_attrs.uk_attrs.hw_rev == IRDMA_GEN_1)\n\t\treturn irdma_gen1_puda_get_tcpip_info(info, buf);\n\n\tmem = buf->mem.va;\n\tbuf->vlan_valid = info->vlan_valid;\n\tif (info->vlan_valid)\n\t\tbuf->vlan_id = info->vlan;\n\n\tbuf->ipv4 = info->ipv4;\n\tif (buf->ipv4)\n\t\tbuf->iph = mem + IRDMA_IPV4_PAD;\n\telse\n\t\tbuf->iph = mem;\n\n\tbuf->tcph = mem + IRDMA_TCP_OFFSET;\n\ttcph = (struct tcphdr *)buf->tcph;\n\tpkt_len = info->payload_len;\n\tbuf->totallen = pkt_len;\n\tbuf->tcphlen = tcph->doff << 2;\n\tbuf->datalen = pkt_len - IRDMA_TCP_OFFSET - buf->tcphlen;\n\tbuf->data = buf->datalen ? buf->tcph + buf->tcphlen : NULL;\n\tbuf->hdrlen = IRDMA_TCP_OFFSET + buf->tcphlen;\n\tbuf->seqnum = ntohl(tcph->seq);\n\n\tif (info->smac_valid) {\n\t\tether_addr_copy(buf->smac, info->smac);\n\t\tbuf->smac_valid = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void irdma_hw_stats_timeout(struct timer_list *t)\n{\n\tstruct irdma_vsi_pestat *pf_devstat =\n\t\tfrom_timer(pf_devstat, t, stats_timer);\n\tstruct irdma_sc_vsi *sc_vsi = pf_devstat->vsi;\n\n\tif (sc_vsi->dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\tirdma_cqp_gather_stats_cmd(sc_vsi->dev, sc_vsi->pestat, false);\n\telse\n\t\tirdma_cqp_gather_stats_gen1(sc_vsi->dev, sc_vsi->pestat);\n\n\tmod_timer(&pf_devstat->stats_timer,\n\t\t  jiffies + msecs_to_jiffies(STATS_TIMER_DELAY));\n}\n\n \nvoid irdma_hw_stats_start_timer(struct irdma_sc_vsi *vsi)\n{\n\tstruct irdma_vsi_pestat *devstat = vsi->pestat;\n\n\ttimer_setup(&devstat->stats_timer, irdma_hw_stats_timeout, 0);\n\tmod_timer(&devstat->stats_timer,\n\t\t  jiffies + msecs_to_jiffies(STATS_TIMER_DELAY));\n}\n\n \nvoid irdma_hw_stats_stop_timer(struct irdma_sc_vsi *vsi)\n{\n\tstruct irdma_vsi_pestat *devstat = vsi->pestat;\n\n\tdel_timer_sync(&devstat->stats_timer);\n}\n\n \nstatic inline void irdma_process_stats(struct irdma_vsi_pestat *pestat)\n{\n\tsc_vsi_update_stats(pestat->vsi);\n}\n\n \nvoid irdma_cqp_gather_stats_gen1(struct irdma_sc_dev *dev,\n\t\t\t\t struct irdma_vsi_pestat *pestat)\n{\n\tstruct irdma_gather_stats *gather_stats =\n\t\tpestat->gather_info.gather_stats_va;\n\tconst struct irdma_hw_stat_map *map = dev->hw_stats_map;\n\tu16 max_stats_idx = dev->hw_attrs.max_stat_idx;\n\tu32 stats_inst_offset_32;\n\tu32 stats_inst_offset_64;\n\tu64 new_val;\n\tu16 i;\n\n\tstats_inst_offset_32 = (pestat->gather_info.use_stats_inst) ?\n\t\t\t\tpestat->gather_info.stats_inst_index :\n\t\t\t\tpestat->hw->hmc.hmc_fn_id;\n\tstats_inst_offset_32 *= 4;\n\tstats_inst_offset_64 = stats_inst_offset_32 * 2;\n\n\tfor (i = 0; i < max_stats_idx; i++) {\n\t\tif (map[i].bitmask <= IRDMA_MAX_STATS_32)\n\t\t\tnew_val = rd32(dev->hw,\n\t\t\t\t       dev->hw_stats_regs[i] + stats_inst_offset_32);\n\t\telse\n\t\t\tnew_val = rd64(dev->hw,\n\t\t\t\t       dev->hw_stats_regs[i] + stats_inst_offset_64);\n\t\tgather_stats->val[map[i].byteoff / sizeof(u64)] = new_val;\n\t}\n\n\tirdma_process_stats(pestat);\n}\n\n \nstatic void irdma_process_cqp_stats(struct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_vsi_pestat *pestat = cqp_request->param;\n\n\tirdma_process_stats(pestat);\n}\n\n \nint irdma_cqp_gather_stats_cmd(struct irdma_sc_dev *dev,\n\t\t\t       struct irdma_vsi_pestat *pestat, bool wait)\n\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, wait);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tmemset(cqp_info, 0, sizeof(*cqp_info));\n\tcqp_info->cqp_cmd = IRDMA_OP_STATS_GATHER;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.stats_gather.info = pestat->gather_info;\n\tcqp_info->in.u.stats_gather.scratch = (uintptr_t)cqp_request;\n\tcqp_info->in.u.stats_gather.cqp = &rf->cqp.sc_cqp;\n\tcqp_request->param = pestat;\n\tif (!wait)\n\t\tcqp_request->callback_fcn = irdma_process_cqp_stats;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tif (wait)\n\t\tirdma_process_stats(pestat);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_stats_inst_cmd(struct irdma_sc_vsi *vsi, u8 cmd,\n\t\t\t     struct irdma_stats_inst_info *stats_info)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(vsi->dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\tbool wait = false;\n\n\tif (cmd == IRDMA_OP_STATS_ALLOCATE)\n\t\twait = true;\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, wait);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tmemset(cqp_info, 0, sizeof(*cqp_info));\n\tcqp_info->cqp_cmd = cmd;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.stats_manage.info = *stats_info;\n\tcqp_info->in.u.stats_manage.scratch = (uintptr_t)cqp_request;\n\tcqp_info->in.u.stats_manage.cqp = &rf->cqp.sc_cqp;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tif (wait)\n\t\tstats_info->stats_idx = cqp_request->compl_info.op_ret_val;\n\tirdma_put_cqp_request(iwcqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_ceq_cmd(struct irdma_sc_dev *dev, struct irdma_sc_ceq *sc_ceq,\n\t\t      u8 op)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->post_sq = 1;\n\tcqp_info->cqp_cmd = op;\n\tcqp_info->in.u.ceq_create.ceq = sc_ceq;\n\tcqp_info->in.u.ceq_create.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_aeq_cmd(struct irdma_sc_dev *dev, struct irdma_sc_aeq *sc_aeq,\n\t\t      u8 op)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->post_sq = 1;\n\tcqp_info->cqp_cmd = op;\n\tcqp_info->in.u.aeq_create.aeq = sc_aeq;\n\tcqp_info->in.u.aeq_create.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_cqp_ws_node_cmd(struct irdma_sc_dev *dev, u8 cmd,\n\t\t\t  struct irdma_ws_node_info *node_info)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tstruct irdma_cqp *iwcqp = &rf->cqp;\n\tstruct irdma_sc_cqp *cqp = &iwcqp->sc_cqp;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\tbool poll;\n\n\tif (!rf->sc_dev.ceq_valid)\n\t\tpoll = true;\n\telse\n\t\tpoll = false;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(iwcqp, !poll);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tmemset(cqp_info, 0, sizeof(*cqp_info));\n\tcqp_info->cqp_cmd = cmd;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.ws_node.info = *node_info;\n\tcqp_info->in.u.ws_node.cqp = cqp;\n\tcqp_info->in.u.ws_node.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tif (status)\n\t\tgoto exit;\n\n\tif (poll) {\n\t\tstruct irdma_ccq_cqe_info compl_info;\n\n\t\tstatus = irdma_sc_poll_for_cqp_op_done(cqp, IRDMA_CQP_OP_WORK_SCHED_NODE,\n\t\t\t\t\t\t       &compl_info);\n\t\tnode_info->qs_handle = compl_info.op_ret_val;\n\t\tibdev_dbg(&rf->iwdev->ibdev, \"DCB: opcode=%d, compl_info.retval=%d\\n\",\n\t\t\t  compl_info.op_code, compl_info.op_ret_val);\n\t} else {\n\t\tnode_info->qs_handle = cqp_request->compl_info.op_ret_val;\n\t}\n\nexit:\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nint irdma_ah_cqp_op(struct irdma_pci_f *rf, struct irdma_sc_ah *sc_ah, u8 cmd,\n\t\t    bool wait,\n\t\t    void (*callback_fcn)(struct irdma_cqp_request *),\n\t\t    void *cb_param)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tif (cmd != IRDMA_OP_AH_CREATE && cmd != IRDMA_OP_AH_DESTROY)\n\t\treturn -EINVAL;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, wait);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = cmd;\n\tcqp_info->post_sq = 1;\n\tif (cmd == IRDMA_OP_AH_CREATE) {\n\t\tcqp_info->in.u.ah_create.info = sc_ah->ah_info;\n\t\tcqp_info->in.u.ah_create.scratch = (uintptr_t)cqp_request;\n\t\tcqp_info->in.u.ah_create.cqp = &rf->cqp.sc_cqp;\n\t} else if (cmd == IRDMA_OP_AH_DESTROY) {\n\t\tcqp_info->in.u.ah_destroy.info = sc_ah->ah_info;\n\t\tcqp_info->in.u.ah_destroy.scratch = (uintptr_t)cqp_request;\n\t\tcqp_info->in.u.ah_destroy.cqp = &rf->cqp.sc_cqp;\n\t}\n\n\tif (!wait) {\n\t\tcqp_request->callback_fcn = callback_fcn;\n\t\tcqp_request->param = cb_param;\n\t}\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\tif (status)\n\t\treturn -ENOMEM;\n\n\tif (wait)\n\t\tsc_ah->ah_info.ah_valid = (cmd == IRDMA_OP_AH_CREATE);\n\n\treturn 0;\n}\n\n \nstatic void irdma_ieq_ah_cb(struct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_sc_qp *qp = cqp_request->param;\n\tstruct irdma_sc_ah *sc_ah = qp->pfpdu.ah;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->pfpdu.lock, flags);\n\tif (!cqp_request->compl_info.op_ret_val) {\n\t\tsc_ah->ah_info.ah_valid = true;\n\t\tirdma_ieq_process_fpdus(qp, qp->vsi->ieq);\n\t} else {\n\t\tsc_ah->ah_info.ah_valid = false;\n\t\tirdma_ieq_cleanup_qp(qp->vsi->ieq, qp);\n\t}\n\tspin_unlock_irqrestore(&qp->pfpdu.lock, flags);\n}\n\n \nstatic void irdma_ilq_ah_cb(struct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_cm_node *cm_node = cqp_request->param;\n\tstruct irdma_sc_ah *sc_ah = cm_node->ah;\n\n\tsc_ah->ah_info.ah_valid = !cqp_request->compl_info.op_ret_val;\n\tirdma_add_conn_est_qh(cm_node);\n}\n\n \nint irdma_puda_create_ah(struct irdma_sc_dev *dev,\n\t\t\t struct irdma_ah_info *ah_info, bool wait,\n\t\t\t enum puda_rsrc_type type, void *cb_param,\n\t\t\t struct irdma_sc_ah **ah_ret)\n{\n\tstruct irdma_sc_ah *ah;\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tint err;\n\n\tah = kzalloc(sizeof(*ah), GFP_ATOMIC);\n\t*ah_ret = ah;\n\tif (!ah)\n\t\treturn -ENOMEM;\n\n\terr = irdma_alloc_rsrc(rf, rf->allocated_ahs, rf->max_ah,\n\t\t\t       &ah_info->ah_idx, &rf->next_ah);\n\tif (err)\n\t\tgoto err_free;\n\n\tah->dev = dev;\n\tah->ah_info = *ah_info;\n\n\tif (type == IRDMA_PUDA_RSRC_TYPE_ILQ)\n\t\terr = irdma_ah_cqp_op(rf, ah, IRDMA_OP_AH_CREATE, wait,\n\t\t\t\t      irdma_ilq_ah_cb, cb_param);\n\telse\n\t\terr = irdma_ah_cqp_op(rf, ah, IRDMA_OP_AH_CREATE, wait,\n\t\t\t\t      irdma_ieq_ah_cb, cb_param);\n\n\tif (err)\n\t\tgoto error;\n\treturn 0;\n\nerror:\n\tirdma_free_rsrc(rf, rf->allocated_ahs, ah->ah_info.ah_idx);\nerr_free:\n\tkfree(ah);\n\t*ah_ret = NULL;\n\treturn -ENOMEM;\n}\n\n \nvoid irdma_puda_free_ah(struct irdma_sc_dev *dev, struct irdma_sc_ah *ah)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\n\tif (!ah)\n\t\treturn;\n\n\tif (ah->ah_info.ah_valid) {\n\t\tirdma_ah_cqp_op(rf, ah, IRDMA_OP_AH_DESTROY, false, NULL, NULL);\n\t\tirdma_free_rsrc(rf, rf->allocated_ahs, ah->ah_info.ah_idx);\n\t}\n\n\tkfree(ah);\n}\n\n \nvoid irdma_gsi_ud_qp_ah_cb(struct irdma_cqp_request *cqp_request)\n{\n\tstruct irdma_sc_ah *sc_ah = cqp_request->param;\n\n\tif (!cqp_request->compl_info.op_ret_val)\n\t\tsc_ah->ah_info.ah_valid = true;\n\telse\n\t\tsc_ah->ah_info.ah_valid = false;\n}\n\n \nint irdma_prm_add_pble_mem(struct irdma_pble_prm *pprm,\n\t\t\t   struct irdma_chunk *pchunk)\n{\n\tu64 sizeofbitmap;\n\n\tif (pchunk->size & 0xfff)\n\t\treturn -EINVAL;\n\n\tsizeofbitmap = (u64)pchunk->size >> pprm->pble_shift;\n\n\tpchunk->bitmapbuf = bitmap_zalloc(sizeofbitmap, GFP_KERNEL);\n\tif (!pchunk->bitmapbuf)\n\t\treturn -ENOMEM;\n\n\tpchunk->sizeofbitmap = sizeofbitmap;\n\t \n\tpprm->total_pble_alloc += pchunk->size >> 3;\n\tpprm->free_pble_cnt += pchunk->size >> 3;\n\n\treturn 0;\n}\n\n \nint irdma_prm_get_pbles(struct irdma_pble_prm *pprm,\n\t\t\tstruct irdma_pble_chunkinfo *chunkinfo, u64 mem_size,\n\t\t\tu64 **vaddr, u64 *fpm_addr)\n{\n\tu64 bits_needed;\n\tu64 bit_idx = PBLE_INVALID_IDX;\n\tstruct irdma_chunk *pchunk = NULL;\n\tstruct list_head *chunk_entry = pprm->clist.next;\n\tu32 offset;\n\tunsigned long flags;\n\t*vaddr = NULL;\n\t*fpm_addr = 0;\n\n\tbits_needed = DIV_ROUND_UP_ULL(mem_size, BIT_ULL(pprm->pble_shift));\n\n\tspin_lock_irqsave(&pprm->prm_lock, flags);\n\twhile (chunk_entry != &pprm->clist) {\n\t\tpchunk = (struct irdma_chunk *)chunk_entry;\n\t\tbit_idx = bitmap_find_next_zero_area(pchunk->bitmapbuf,\n\t\t\t\t\t\t     pchunk->sizeofbitmap, 0,\n\t\t\t\t\t\t     bits_needed, 0);\n\t\tif (bit_idx < pchunk->sizeofbitmap)\n\t\t\tbreak;\n\n\t\t \n\t\tchunk_entry = pchunk->list.next;\n\t}\n\n\tif (!pchunk || bit_idx >= pchunk->sizeofbitmap) {\n\t\tspin_unlock_irqrestore(&pprm->prm_lock, flags);\n\t\treturn -ENOMEM;\n\t}\n\n\tbitmap_set(pchunk->bitmapbuf, bit_idx, bits_needed);\n\toffset = bit_idx << pprm->pble_shift;\n\t*vaddr = pchunk->vaddr + offset;\n\t*fpm_addr = pchunk->fpm_addr + offset;\n\n\tchunkinfo->pchunk = pchunk;\n\tchunkinfo->bit_idx = bit_idx;\n\tchunkinfo->bits_used = bits_needed;\n\t \n\tpprm->free_pble_cnt -= chunkinfo->bits_used << (pprm->pble_shift - 3);\n\tspin_unlock_irqrestore(&pprm->prm_lock, flags);\n\n\treturn 0;\n}\n\n \nvoid irdma_prm_return_pbles(struct irdma_pble_prm *pprm,\n\t\t\t    struct irdma_pble_chunkinfo *chunkinfo)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pprm->prm_lock, flags);\n\tpprm->free_pble_cnt += chunkinfo->bits_used << (pprm->pble_shift - 3);\n\tbitmap_clear(chunkinfo->pchunk->bitmapbuf, chunkinfo->bit_idx,\n\t\t     chunkinfo->bits_used);\n\tspin_unlock_irqrestore(&pprm->prm_lock, flags);\n}\n\nint irdma_map_vm_page_list(struct irdma_hw *hw, void *va, dma_addr_t *pg_dma,\n\t\t\t   u32 pg_cnt)\n{\n\tstruct page *vm_page;\n\tint i;\n\tu8 *addr;\n\n\taddr = (u8 *)(uintptr_t)va;\n\tfor (i = 0; i < pg_cnt; i++) {\n\t\tvm_page = vmalloc_to_page(addr);\n\t\tif (!vm_page)\n\t\t\tgoto err;\n\n\t\tpg_dma[i] = dma_map_page(hw->device, vm_page, 0, PAGE_SIZE,\n\t\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tif (dma_mapping_error(hw->device, pg_dma[i]))\n\t\t\tgoto err;\n\n\t\taddr += PAGE_SIZE;\n\t}\n\n\treturn 0;\n\nerr:\n\tirdma_unmap_vm_page_list(hw, pg_dma, i);\n\treturn -ENOMEM;\n}\n\nvoid irdma_unmap_vm_page_list(struct irdma_hw *hw, dma_addr_t *pg_dma, u32 pg_cnt)\n{\n\tint i;\n\n\tfor (i = 0; i < pg_cnt; i++)\n\t\tdma_unmap_page(hw->device, pg_dma[i], PAGE_SIZE, DMA_BIDIRECTIONAL);\n}\n\n \nvoid irdma_pble_free_paged_mem(struct irdma_chunk *chunk)\n{\n\tif (!chunk->pg_cnt)\n\t\tgoto done;\n\n\tirdma_unmap_vm_page_list(chunk->dev->hw, chunk->dmainfo.dmaaddrs,\n\t\t\t\t chunk->pg_cnt);\n\ndone:\n\tkfree(chunk->dmainfo.dmaaddrs);\n\tchunk->dmainfo.dmaaddrs = NULL;\n\tvfree(chunk->vaddr);\n\tchunk->vaddr = NULL;\n\tchunk->type = 0;\n}\n\n \nint irdma_pble_get_paged_mem(struct irdma_chunk *chunk, u32 pg_cnt)\n{\n\tu32 size;\n\tvoid *va;\n\n\tchunk->dmainfo.dmaaddrs = kzalloc(pg_cnt << 3, GFP_KERNEL);\n\tif (!chunk->dmainfo.dmaaddrs)\n\t\treturn -ENOMEM;\n\n\tsize = PAGE_SIZE * pg_cnt;\n\tva = vmalloc(size);\n\tif (!va)\n\t\tgoto err;\n\n\tif (irdma_map_vm_page_list(chunk->dev->hw, va, chunk->dmainfo.dmaaddrs,\n\t\t\t\t   pg_cnt)) {\n\t\tvfree(va);\n\t\tgoto err;\n\t}\n\tchunk->vaddr = va;\n\tchunk->size = size;\n\tchunk->pg_cnt = pg_cnt;\n\tchunk->type = PBLE_SD_PAGED;\n\n\treturn 0;\nerr:\n\tkfree(chunk->dmainfo.dmaaddrs);\n\tchunk->dmainfo.dmaaddrs = NULL;\n\n\treturn -ENOMEM;\n}\n\n \nu16 irdma_alloc_ws_node_id(struct irdma_sc_dev *dev)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\tu32 next = 1;\n\tu32 node_id;\n\n\tif (irdma_alloc_rsrc(rf, rf->allocated_ws_nodes, rf->max_ws_node_id,\n\t\t\t     &node_id, &next))\n\t\treturn IRDMA_WS_NODE_INVALID;\n\n\treturn (u16)node_id;\n}\n\n \nvoid irdma_free_ws_node_id(struct irdma_sc_dev *dev, u16 node_id)\n{\n\tstruct irdma_pci_f *rf = dev_to_rf(dev);\n\n\tirdma_free_rsrc(rf, rf->allocated_ws_nodes, (u32)node_id);\n}\n\n \nvoid irdma_modify_qp_to_err(struct irdma_sc_qp *sc_qp)\n{\n\tstruct irdma_qp *qp = sc_qp->qp_uk.back_qp;\n\tstruct ib_qp_attr attr;\n\n\tif (qp->iwdev->rf->reset)\n\t\treturn;\n\tattr.qp_state = IB_QPS_ERR;\n\n\tif (rdma_protocol_roce(qp->ibqp.device, 1))\n\t\tirdma_modify_qp_roce(&qp->ibqp, &attr, IB_QP_STATE, NULL);\n\telse\n\t\tirdma_modify_qp(&qp->ibqp, &attr, IB_QP_STATE, NULL);\n}\n\nvoid irdma_ib_qp_event(struct irdma_qp *iwqp, enum irdma_qp_event_type event)\n{\n\tstruct ib_event ibevent;\n\n\tif (!iwqp->ibqp.event_handler)\n\t\treturn;\n\n\tswitch (event) {\n\tcase IRDMA_QP_EVENT_CATASTROPHIC:\n\t\tibevent.event = IB_EVENT_QP_FATAL;\n\t\tbreak;\n\tcase IRDMA_QP_EVENT_ACCESS_ERR:\n\t\tibevent.event = IB_EVENT_QP_ACCESS_ERR;\n\t\tbreak;\n\tcase IRDMA_QP_EVENT_REQ_ERR:\n\t\tibevent.event = IB_EVENT_QP_REQ_ERR;\n\t\tbreak;\n\t}\n\tibevent.device = iwqp->ibqp.device;\n\tibevent.element.qp = &iwqp->ibqp;\n\tiwqp->ibqp.event_handler(&ibevent, iwqp->ibqp.qp_context);\n}\n\nbool irdma_cq_empty(struct irdma_cq *iwcq)\n{\n\tstruct irdma_cq_uk *ukcq;\n\tu64 qword3;\n\t__le64 *cqe;\n\tu8 polarity;\n\n\tukcq  = &iwcq->sc_cq.cq_uk;\n\tcqe = IRDMA_GET_CURRENT_CQ_ELEM(ukcq);\n\tget_64bit_val(cqe, 24, &qword3);\n\tpolarity = (u8)FIELD_GET(IRDMA_CQ_VALID, qword3);\n\n\treturn polarity != ukcq->polarity;\n}\n\nvoid irdma_remove_cmpls_list(struct irdma_cq *iwcq)\n{\n\tstruct irdma_cmpl_gen *cmpl_node;\n\tstruct list_head *tmp_node, *list_node;\n\n\tlist_for_each_safe (list_node, tmp_node, &iwcq->cmpl_generated) {\n\t\tcmpl_node = list_entry(list_node, struct irdma_cmpl_gen, list);\n\t\tlist_del(&cmpl_node->list);\n\t\tkfree(cmpl_node);\n\t}\n}\n\nint irdma_generated_cmpls(struct irdma_cq *iwcq, struct irdma_cq_poll_info *cq_poll_info)\n{\n\tstruct irdma_cmpl_gen *cmpl;\n\n\tif (list_empty(&iwcq->cmpl_generated))\n\t\treturn -ENOENT;\n\tcmpl = list_first_entry_or_null(&iwcq->cmpl_generated, struct irdma_cmpl_gen, list);\n\tlist_del(&cmpl->list);\n\tmemcpy(cq_poll_info, &cmpl->cpi, sizeof(*cq_poll_info));\n\tkfree(cmpl);\n\n\tibdev_dbg(iwcq->ibcq.device,\n\t\t  \"VERBS: %s: Poll artificially generated completion for QP 0x%X, op %u, wr_id=0x%llx\\n\",\n\t\t  __func__, cq_poll_info->qp_id, cq_poll_info->op_type,\n\t\t  cq_poll_info->wr_id);\n\n\treturn 0;\n}\n\n \nstatic void irdma_set_cpi_common_values(struct irdma_cq_poll_info *cpi,\n\t\t\t\t\tstruct irdma_qp_uk *qp, u32 qp_num)\n{\n\tcpi->comp_status = IRDMA_COMPL_STATUS_FLUSHED;\n\tcpi->error = true;\n\tcpi->major_err = IRDMA_FLUSH_MAJOR_ERR;\n\tcpi->minor_err = FLUSH_GENERAL_ERR;\n\tcpi->qp_handle = (irdma_qp_handle)(uintptr_t)qp;\n\tcpi->qp_id = qp_num;\n}\n\nstatic inline void irdma_comp_handler(struct irdma_cq *cq)\n{\n\tif (!cq->ibcq.comp_handler)\n\t\treturn;\n\tif (atomic_cmpxchg(&cq->armed, 1, 0))\n\t\tcq->ibcq.comp_handler(&cq->ibcq, cq->ibcq.cq_context);\n}\n\nvoid irdma_generate_flush_completions(struct irdma_qp *iwqp)\n{\n\tstruct irdma_qp_uk *qp = &iwqp->sc_qp.qp_uk;\n\tstruct irdma_ring *sq_ring = &qp->sq_ring;\n\tstruct irdma_ring *rq_ring = &qp->rq_ring;\n\tstruct irdma_cmpl_gen *cmpl;\n\t__le64 *sw_wqe;\n\tu64 wqe_qword;\n\tu32 wqe_idx;\n\tbool compl_generated = false;\n\tunsigned long flags1;\n\n\tspin_lock_irqsave(&iwqp->iwscq->lock, flags1);\n\tif (irdma_cq_empty(iwqp->iwscq)) {\n\t\tunsigned long flags2;\n\n\t\tspin_lock_irqsave(&iwqp->lock, flags2);\n\t\twhile (IRDMA_RING_MORE_WORK(*sq_ring)) {\n\t\t\tcmpl = kzalloc(sizeof(*cmpl), GFP_ATOMIC);\n\t\t\tif (!cmpl) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags2);\n\t\t\t\tspin_unlock_irqrestore(&iwqp->iwscq->lock, flags1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twqe_idx = sq_ring->tail;\n\t\t\tirdma_set_cpi_common_values(&cmpl->cpi, qp, qp->qp_id);\n\n\t\t\tcmpl->cpi.wr_id = qp->sq_wrtrk_array[wqe_idx].wrid;\n\t\t\tsw_wqe = qp->sq_base[wqe_idx].elem;\n\t\t\tget_64bit_val(sw_wqe, 24, &wqe_qword);\n\t\t\tcmpl->cpi.op_type = (u8)FIELD_GET(IRDMAQPSQ_OPCODE, IRDMAQPSQ_OPCODE);\n\t\t\tcmpl->cpi.q_type = IRDMA_CQE_QTYPE_SQ;\n\t\t\t \n\t\t\tIRDMA_RING_SET_TAIL(*sq_ring,\n\t\t\t\tsq_ring->tail + qp->sq_wrtrk_array[sq_ring->tail].quanta);\n\t\t\tif (cmpl->cpi.op_type == IRDMAQP_OP_NOP) {\n\t\t\t\tkfree(cmpl);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tibdev_dbg(iwqp->iwscq->ibcq.device,\n\t\t\t\t  \"DEV: %s: adding wr_id = 0x%llx SQ Completion to list qp_id=%d\\n\",\n\t\t\t\t  __func__, cmpl->cpi.wr_id, qp->qp_id);\n\t\t\tlist_add_tail(&cmpl->list, &iwqp->iwscq->cmpl_generated);\n\t\t\tcompl_generated = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags2);\n\t\tspin_unlock_irqrestore(&iwqp->iwscq->lock, flags1);\n\t\tif (compl_generated)\n\t\t\tirdma_comp_handler(iwqp->iwscq);\n\t} else {\n\t\tspin_unlock_irqrestore(&iwqp->iwscq->lock, flags1);\n\t\tmod_delayed_work(iwqp->iwdev->cleanup_wq, &iwqp->dwork_flush,\n\t\t\t\t msecs_to_jiffies(IRDMA_FLUSH_DELAY_MS));\n\t}\n\n\tspin_lock_irqsave(&iwqp->iwrcq->lock, flags1);\n\tif (irdma_cq_empty(iwqp->iwrcq)) {\n\t\tunsigned long flags2;\n\n\t\tspin_lock_irqsave(&iwqp->lock, flags2);\n\t\twhile (IRDMA_RING_MORE_WORK(*rq_ring)) {\n\t\t\tcmpl = kzalloc(sizeof(*cmpl), GFP_ATOMIC);\n\t\t\tif (!cmpl) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags2);\n\t\t\t\tspin_unlock_irqrestore(&iwqp->iwrcq->lock, flags1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twqe_idx = rq_ring->tail;\n\t\t\tirdma_set_cpi_common_values(&cmpl->cpi, qp, qp->qp_id);\n\n\t\t\tcmpl->cpi.wr_id = qp->rq_wrid_array[wqe_idx];\n\t\t\tcmpl->cpi.op_type = IRDMA_OP_TYPE_REC;\n\t\t\tcmpl->cpi.q_type = IRDMA_CQE_QTYPE_RQ;\n\t\t\t \n\t\t\tIRDMA_RING_SET_TAIL(*rq_ring, rq_ring->tail + 1);\n\t\t\tibdev_dbg(iwqp->iwrcq->ibcq.device,\n\t\t\t\t  \"DEV: %s: adding wr_id = 0x%llx RQ Completion to list qp_id=%d, wqe_idx=%d\\n\",\n\t\t\t\t  __func__, cmpl->cpi.wr_id, qp->qp_id,\n\t\t\t\t  wqe_idx);\n\t\t\tlist_add_tail(&cmpl->list, &iwqp->iwrcq->cmpl_generated);\n\n\t\t\tcompl_generated = true;\n\t\t}\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags2);\n\t\tspin_unlock_irqrestore(&iwqp->iwrcq->lock, flags1);\n\t\tif (compl_generated)\n\t\t\tirdma_comp_handler(iwqp->iwrcq);\n\t} else {\n\t\tspin_unlock_irqrestore(&iwqp->iwrcq->lock, flags1);\n\t\tmod_delayed_work(iwqp->iwdev->cleanup_wq, &iwqp->dwork_flush,\n\t\t\t\t msecs_to_jiffies(IRDMA_FLUSH_DELAY_MS));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}