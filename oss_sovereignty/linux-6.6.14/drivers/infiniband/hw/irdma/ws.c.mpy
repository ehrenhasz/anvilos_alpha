{
  "module_name": "ws.c",
  "hash_id": "f747c785bdff8e0f8dbd51939877ed50e21458086bdf609f4390e1b05293939f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/ws.c",
  "human_readable_source": "\n \n#include \"osdep.h\"\n#include \"hmc.h\"\n#include \"defs.h\"\n#include \"type.h\"\n#include \"protos.h\"\n\n#include \"ws.h\"\n\n \nstatic struct irdma_ws_node *irdma_alloc_node(struct irdma_sc_vsi *vsi,\n\t\t\t\t\t      u8 user_pri,\n\t\t\t\t\t      enum irdma_ws_node_type node_type,\n\t\t\t\t\t      struct irdma_ws_node *parent)\n{\n\tstruct irdma_virt_mem ws_mem;\n\tstruct irdma_ws_node *node;\n\tu16 node_index = 0;\n\n\tws_mem.size = sizeof(struct irdma_ws_node);\n\tws_mem.va = kzalloc(ws_mem.size, GFP_KERNEL);\n\tif (!ws_mem.va)\n\t\treturn NULL;\n\n\tif (parent) {\n\t\tnode_index = irdma_alloc_ws_node_id(vsi->dev);\n\t\tif (node_index == IRDMA_WS_NODE_INVALID) {\n\t\t\tkfree(ws_mem.va);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tnode = ws_mem.va;\n\tnode->index = node_index;\n\tnode->vsi_index = vsi->vsi_idx;\n\tINIT_LIST_HEAD(&node->child_list_head);\n\tif (node_type == WS_NODE_TYPE_LEAF) {\n\t\tnode->type_leaf = true;\n\t\tnode->traffic_class = vsi->qos[user_pri].traffic_class;\n\t\tnode->user_pri = user_pri;\n\t\tnode->rel_bw = vsi->qos[user_pri].rel_bw;\n\t\tif (!node->rel_bw)\n\t\t\tnode->rel_bw = 1;\n\n\t\tnode->lan_qs_handle = vsi->qos[user_pri].lan_qos_handle;\n\t\tnode->prio_type = IRDMA_PRIO_WEIGHTED_RR;\n\t} else {\n\t\tnode->rel_bw = 1;\n\t\tnode->prio_type = IRDMA_PRIO_WEIGHTED_RR;\n\t\tnode->enable = true;\n\t}\n\n\tnode->parent = parent;\n\n\treturn node;\n}\n\n \nstatic void irdma_free_node(struct irdma_sc_vsi *vsi,\n\t\t\t    struct irdma_ws_node *node)\n{\n\tstruct irdma_virt_mem ws_mem;\n\n\tif (node->index)\n\t\tirdma_free_ws_node_id(vsi->dev, node->index);\n\n\tws_mem.va = node;\n\tws_mem.size = sizeof(struct irdma_ws_node);\n\tkfree(ws_mem.va);\n}\n\n \nstatic int irdma_ws_cqp_cmd(struct irdma_sc_vsi *vsi,\n\t\t\t    struct irdma_ws_node *node, u8 cmd)\n{\n\tstruct irdma_ws_node_info node_info = {};\n\n\tnode_info.id = node->index;\n\tnode_info.vsi = node->vsi_index;\n\tif (node->parent)\n\t\tnode_info.parent_id = node->parent->index;\n\telse\n\t\tnode_info.parent_id = node_info.id;\n\n\tnode_info.weight = node->rel_bw;\n\tnode_info.tc = node->traffic_class;\n\tnode_info.prio_type = node->prio_type;\n\tnode_info.type_leaf = node->type_leaf;\n\tnode_info.enable = node->enable;\n\tif (irdma_cqp_ws_node_cmd(vsi->dev, cmd, &node_info)) {\n\t\tibdev_dbg(to_ibdev(vsi->dev), \"WS: CQP WS CMD failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (node->type_leaf && cmd == IRDMA_OP_WS_ADD_NODE) {\n\t\tnode->qs_handle = node_info.qs_handle;\n\t\tvsi->qos[node->user_pri].qs_handle = node_info.qs_handle;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct irdma_ws_node *ws_find_node(struct irdma_ws_node *parent,\n\t\t\t\t\t  u16 match_val,\n\t\t\t\t\t  enum irdma_ws_match_type type)\n{\n\tstruct irdma_ws_node *node;\n\n\tswitch (type) {\n\tcase WS_MATCH_TYPE_VSI:\n\t\tlist_for_each_entry(node, &parent->child_list_head, siblings) {\n\t\t\tif (node->vsi_index == match_val)\n\t\t\t\treturn node;\n\t\t}\n\t\tbreak;\n\tcase WS_MATCH_TYPE_TC:\n\t\tlist_for_each_entry(node, &parent->child_list_head, siblings) {\n\t\t\tif (node->traffic_class == match_val)\n\t\t\t\treturn node;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic bool irdma_tc_in_use(struct irdma_sc_vsi *vsi, u8 user_pri)\n{\n\tint i;\n\n\tmutex_lock(&vsi->qos[user_pri].qos_mutex);\n\tif (!list_empty(&vsi->qos[user_pri].qplist)) {\n\t\tmutex_unlock(&vsi->qos[user_pri].qos_mutex);\n\t\treturn true;\n\t}\n\n\t \n\tfor (i = 0; i < IRDMA_MAX_USER_PRIORITY; i++) {\n\t\tif (vsi->qos[i].traffic_class == vsi->qos[user_pri].traffic_class &&\n\t\t    !list_empty(&vsi->qos[i].qplist)) {\n\t\t\tmutex_unlock(&vsi->qos[user_pri].qos_mutex);\n\t\t\treturn true;\n\t\t}\n\t}\n\tmutex_unlock(&vsi->qos[user_pri].qos_mutex);\n\n\treturn false;\n}\n\n \nstatic void irdma_remove_leaf(struct irdma_sc_vsi *vsi, u8 user_pri)\n{\n\tstruct irdma_ws_node *ws_tree_root, *vsi_node, *tc_node;\n\tint i;\n\tu16 traffic_class;\n\n\ttraffic_class = vsi->qos[user_pri].traffic_class;\n\tfor (i = 0; i < IRDMA_MAX_USER_PRIORITY; i++)\n\t\tif (vsi->qos[i].traffic_class == traffic_class)\n\t\t\tvsi->qos[i].valid = false;\n\n\tws_tree_root = vsi->dev->ws_tree_root;\n\tif (!ws_tree_root)\n\t\treturn;\n\n\tvsi_node = ws_find_node(ws_tree_root, vsi->vsi_idx,\n\t\t\t\tWS_MATCH_TYPE_VSI);\n\tif (!vsi_node)\n\t\treturn;\n\n\ttc_node = ws_find_node(vsi_node,\n\t\t\t       vsi->qos[user_pri].traffic_class,\n\t\t\t       WS_MATCH_TYPE_TC);\n\tif (!tc_node)\n\t\treturn;\n\n\tirdma_ws_cqp_cmd(vsi, tc_node, IRDMA_OP_WS_DELETE_NODE);\n\tvsi->unregister_qset(vsi, tc_node);\n\tlist_del(&tc_node->siblings);\n\tirdma_free_node(vsi, tc_node);\n\t \n\tif (list_empty(&vsi_node->child_list_head)) {\n\t\tirdma_ws_cqp_cmd(vsi, vsi_node, IRDMA_OP_WS_DELETE_NODE);\n\t\tlist_del(&vsi_node->siblings);\n\t\tirdma_free_node(vsi, vsi_node);\n\t\t \n\t\tif (list_empty(&ws_tree_root->child_list_head)) {\n\t\t\tirdma_ws_cqp_cmd(vsi, ws_tree_root,\n\t\t\t\t\t IRDMA_OP_WS_DELETE_NODE);\n\t\t\tirdma_free_node(vsi, ws_tree_root);\n\t\t\tvsi->dev->ws_tree_root = NULL;\n\t\t}\n\t}\n}\n\n \nint irdma_ws_add(struct irdma_sc_vsi *vsi, u8 user_pri)\n{\n\tstruct irdma_ws_node *ws_tree_root;\n\tstruct irdma_ws_node *vsi_node;\n\tstruct irdma_ws_node *tc_node;\n\tu16 traffic_class;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&vsi->dev->ws_mutex);\n\tif (vsi->tc_change_pending) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tif (vsi->qos[user_pri].valid)\n\t\tgoto exit;\n\n\tws_tree_root = vsi->dev->ws_tree_root;\n\tif (!ws_tree_root) {\n\t\tibdev_dbg(to_ibdev(vsi->dev), \"WS: Creating root node\\n\");\n\t\tws_tree_root = irdma_alloc_node(vsi, user_pri,\n\t\t\t\t\t\tWS_NODE_TYPE_PARENT, NULL);\n\t\tif (!ws_tree_root) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = irdma_ws_cqp_cmd(vsi, ws_tree_root, IRDMA_OP_WS_ADD_NODE);\n\t\tif (ret) {\n\t\t\tirdma_free_node(vsi, ws_tree_root);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tvsi->dev->ws_tree_root = ws_tree_root;\n\t}\n\n\t \n\tvsi_node = ws_find_node(ws_tree_root, vsi->vsi_idx,\n\t\t\t\tWS_MATCH_TYPE_VSI);\n\n\t \n\tif (!vsi_node) {\n\t\tibdev_dbg(to_ibdev(vsi->dev),\n\t\t\t  \"WS: Node not found matching VSI %d\\n\",\n\t\t\t  vsi->vsi_idx);\n\t\tvsi_node = irdma_alloc_node(vsi, user_pri, WS_NODE_TYPE_PARENT,\n\t\t\t\t\t    ws_tree_root);\n\t\tif (!vsi_node) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto vsi_add_err;\n\t\t}\n\n\t\tret = irdma_ws_cqp_cmd(vsi, vsi_node, IRDMA_OP_WS_ADD_NODE);\n\t\tif (ret) {\n\t\t\tirdma_free_node(vsi, vsi_node);\n\t\t\tgoto vsi_add_err;\n\t\t}\n\n\t\tlist_add(&vsi_node->siblings, &ws_tree_root->child_list_head);\n\t}\n\n\tibdev_dbg(to_ibdev(vsi->dev),\n\t\t  \"WS: Using node %d which represents VSI %d\\n\",\n\t\t  vsi_node->index, vsi->vsi_idx);\n\ttraffic_class = vsi->qos[user_pri].traffic_class;\n\ttc_node = ws_find_node(vsi_node, traffic_class,\n\t\t\t       WS_MATCH_TYPE_TC);\n\tif (!tc_node) {\n\t\t \n\t\tibdev_dbg(to_ibdev(vsi->dev),\n\t\t\t  \"WS: Node not found matching VSI %d and TC %d\\n\",\n\t\t\t  vsi->vsi_idx, traffic_class);\n\t\ttc_node = irdma_alloc_node(vsi, user_pri, WS_NODE_TYPE_LEAF,\n\t\t\t\t\t   vsi_node);\n\t\tif (!tc_node) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto leaf_add_err;\n\t\t}\n\n\t\tret = irdma_ws_cqp_cmd(vsi, tc_node, IRDMA_OP_WS_ADD_NODE);\n\t\tif (ret) {\n\t\t\tirdma_free_node(vsi, tc_node);\n\t\t\tgoto leaf_add_err;\n\t\t}\n\n\t\tlist_add(&tc_node->siblings, &vsi_node->child_list_head);\n\t\t \n\t\tret = vsi->register_qset(vsi, tc_node);\n\t\tif (ret)\n\t\t\tgoto reg_err;\n\n\t\ttc_node->enable = true;\n\t\tret = irdma_ws_cqp_cmd(vsi, tc_node, IRDMA_OP_WS_MODIFY_NODE);\n\t\tif (ret) {\n\t\t\tvsi->unregister_qset(vsi, tc_node);\n\t\t\tgoto reg_err;\n\t\t}\n\t}\n\tibdev_dbg(to_ibdev(vsi->dev),\n\t\t  \"WS: Using node %d which represents VSI %d TC %d\\n\",\n\t\t  tc_node->index, vsi->vsi_idx, traffic_class);\n\t \n\tfor (i = 0; i < IRDMA_MAX_USER_PRIORITY; i++) {\n\t\tif (vsi->qos[i].traffic_class == traffic_class) {\n\t\t\tvsi->qos[i].qs_handle = tc_node->qs_handle;\n\t\t\tvsi->qos[i].lan_qos_handle = tc_node->lan_qs_handle;\n\t\t\tvsi->qos[i].l2_sched_node_id = tc_node->l2_sched_node_id;\n\t\t\tvsi->qos[i].valid = true;\n\t\t}\n\t}\n\tgoto exit;\n\nreg_err:\n\tirdma_ws_cqp_cmd(vsi, tc_node, IRDMA_OP_WS_DELETE_NODE);\n\tlist_del(&tc_node->siblings);\n\tirdma_free_node(vsi, tc_node);\nleaf_add_err:\n\tif (list_empty(&vsi_node->child_list_head)) {\n\t\tif (irdma_ws_cqp_cmd(vsi, vsi_node, IRDMA_OP_WS_DELETE_NODE))\n\t\t\tgoto exit;\n\t\tlist_del(&vsi_node->siblings);\n\t\tirdma_free_node(vsi, vsi_node);\n\t}\n\nvsi_add_err:\n\t \n\tif (list_empty(&ws_tree_root->child_list_head)) {\n\t\tirdma_ws_cqp_cmd(vsi, ws_tree_root, IRDMA_OP_WS_DELETE_NODE);\n\t\tvsi->dev->ws_tree_root = NULL;\n\t\tirdma_free_node(vsi, ws_tree_root);\n\t}\n\nexit:\n\tmutex_unlock(&vsi->dev->ws_mutex);\n\treturn ret;\n}\n\n \nvoid irdma_ws_remove(struct irdma_sc_vsi *vsi, u8 user_pri)\n{\n\tmutex_lock(&vsi->dev->ws_mutex);\n\tif (irdma_tc_in_use(vsi, user_pri))\n\t\tgoto exit;\n\tirdma_remove_leaf(vsi, user_pri);\nexit:\n\tmutex_unlock(&vsi->dev->ws_mutex);\n}\n\n \nvoid irdma_ws_reset(struct irdma_sc_vsi *vsi)\n{\n\tu8 i;\n\n\tmutex_lock(&vsi->dev->ws_mutex);\n\tfor (i = 0; i < IRDMA_MAX_USER_PRIORITY; ++i)\n\t\tirdma_remove_leaf(vsi, i);\n\tmutex_unlock(&vsi->dev->ws_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}