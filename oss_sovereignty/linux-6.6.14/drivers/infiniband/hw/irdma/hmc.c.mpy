{
  "module_name": "hmc.c",
  "hash_id": "ffbe1b5684117b6dc1c548f5715bf20cc6337984f097414989955fdbd54c91c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/hmc.c",
  "human_readable_source": "\n \n#include \"osdep.h\"\n#include \"hmc.h\"\n#include \"defs.h\"\n#include \"type.h\"\n#include \"protos.h\"\n\n \n\nstatic void irdma_find_sd_index_limit(struct irdma_hmc_info *hmc_info, u32 type,\n\t\t\t\t      u32 idx, u32 cnt, u32 *sd_idx,\n\t\t\t\t      u32 *sd_limit)\n{\n\tu64 fpm_addr, fpm_limit;\n\n\tfpm_addr = hmc_info->hmc_obj[(type)].base +\n\t\t   hmc_info->hmc_obj[type].size * idx;\n\tfpm_limit = fpm_addr + hmc_info->hmc_obj[type].size * cnt;\n\t*sd_idx = (u32)(fpm_addr / IRDMA_HMC_DIRECT_BP_SIZE);\n\t*sd_limit = (u32)((fpm_limit - 1) / IRDMA_HMC_DIRECT_BP_SIZE);\n\t*sd_limit += 1;\n}\n\n \n\nstatic void irdma_find_pd_index_limit(struct irdma_hmc_info *hmc_info, u32 type,\n\t\t\t\t      u32 idx, u32 cnt, u32 *pd_idx,\n\t\t\t\t      u32 *pd_limit)\n{\n\tu64 fpm_adr, fpm_limit;\n\n\tfpm_adr = hmc_info->hmc_obj[type].base +\n\t\t  hmc_info->hmc_obj[type].size * idx;\n\tfpm_limit = fpm_adr + (hmc_info)->hmc_obj[(type)].size * (cnt);\n\t*pd_idx = (u32)(fpm_adr / IRDMA_HMC_PAGED_BP_SIZE);\n\t*pd_limit = (u32)((fpm_limit - 1) / IRDMA_HMC_PAGED_BP_SIZE);\n\t*pd_limit += 1;\n}\n\n \nstatic void irdma_set_sd_entry(u64 pa, u32 idx, enum irdma_sd_entry_type type,\n\t\t\t       struct irdma_update_sd_entry *entry)\n{\n\tentry->data = pa |\n\t\t      FIELD_PREP(IRDMA_PFHMC_SDDATALOW_PMSDBPCOUNT, IRDMA_HMC_MAX_BP_COUNT) |\n\t\t      FIELD_PREP(IRDMA_PFHMC_SDDATALOW_PMSDTYPE,\n\t\t\t\t type == IRDMA_SD_TYPE_PAGED ? 0 : 1) |\n\t\t      FIELD_PREP(IRDMA_PFHMC_SDDATALOW_PMSDVALID, 1);\n\n\tentry->cmd = idx | FIELD_PREP(IRDMA_PFHMC_SDCMD_PMSDWR, 1) | BIT(15);\n}\n\n \nstatic void irdma_clr_sd_entry(u32 idx, enum irdma_sd_entry_type type,\n\t\t\t       struct irdma_update_sd_entry *entry)\n{\n\tentry->data = FIELD_PREP(IRDMA_PFHMC_SDDATALOW_PMSDBPCOUNT, IRDMA_HMC_MAX_BP_COUNT) |\n\t\t      FIELD_PREP(IRDMA_PFHMC_SDDATALOW_PMSDTYPE,\n\t\t\t\t type == IRDMA_SD_TYPE_PAGED ? 0 : 1);\n\n\tentry->cmd = idx | FIELD_PREP(IRDMA_PFHMC_SDCMD_PMSDWR, 1) | BIT(15);\n}\n\n \nstatic inline void irdma_invalidate_pf_hmc_pd(struct irdma_sc_dev *dev, u32 sd_idx,\n\t\t\t\t\t      u32 pd_idx)\n{\n\tu32 val = FIELD_PREP(IRDMA_PFHMC_PDINV_PMSDIDX, sd_idx) |\n\t\t  FIELD_PREP(IRDMA_PFHMC_PDINV_PMSDPARTSEL, 1) |\n\t\t  FIELD_PREP(IRDMA_PFHMC_PDINV_PMPDIDX, pd_idx);\n\n\twritel(val, dev->hw_regs[IRDMA_PFHMC_PDINV]);\n}\n\n \nint irdma_hmc_sd_one(struct irdma_sc_dev *dev, u8 hmc_fn_id, u64 pa, u32 sd_idx,\n\t\t     enum irdma_sd_entry_type type, bool setsd)\n{\n\tstruct irdma_update_sds_info sdinfo;\n\n\tsdinfo.cnt = 1;\n\tsdinfo.hmc_fn_id = hmc_fn_id;\n\tif (setsd)\n\t\tirdma_set_sd_entry(pa, sd_idx, type, sdinfo.entry);\n\telse\n\t\tirdma_clr_sd_entry(sd_idx, type, sdinfo.entry);\n\treturn dev->cqp->process_cqp_sds(dev, &sdinfo);\n}\n\n \nstatic int irdma_hmc_sd_grp(struct irdma_sc_dev *dev,\n\t\t\t    struct irdma_hmc_info *hmc_info, u32 sd_index,\n\t\t\t    u32 sd_cnt, bool setsd)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tstruct irdma_update_sds_info sdinfo = {};\n\tu64 pa;\n\tu32 i;\n\tint ret_code = 0;\n\n\tsdinfo.hmc_fn_id = hmc_info->hmc_fn_id;\n\tfor (i = sd_index; i < sd_index + sd_cnt; i++) {\n\t\tsd_entry = &hmc_info->sd_table.sd_entry[i];\n\t\tif (!sd_entry || (!sd_entry->valid && setsd) ||\n\t\t    (sd_entry->valid && !setsd))\n\t\t\tcontinue;\n\t\tif (setsd) {\n\t\t\tpa = (sd_entry->entry_type == IRDMA_SD_TYPE_PAGED) ?\n\t\t\t\t     sd_entry->u.pd_table.pd_page_addr.pa :\n\t\t\t\t     sd_entry->u.bp.addr.pa;\n\t\t\tirdma_set_sd_entry(pa, i, sd_entry->entry_type,\n\t\t\t\t\t   &sdinfo.entry[sdinfo.cnt]);\n\t\t} else {\n\t\t\tirdma_clr_sd_entry(i, sd_entry->entry_type,\n\t\t\t\t\t   &sdinfo.entry[sdinfo.cnt]);\n\t\t}\n\t\tsdinfo.cnt++;\n\t\tif (sdinfo.cnt == IRDMA_MAX_SD_ENTRIES) {\n\t\t\tret_code = dev->cqp->process_cqp_sds(dev, &sdinfo);\n\t\t\tif (ret_code) {\n\t\t\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t\t\t  \"HMC: sd_programming failed err=%d\\n\",\n\t\t\t\t\t  ret_code);\n\t\t\t\treturn ret_code;\n\t\t\t}\n\n\t\t\tsdinfo.cnt = 0;\n\t\t}\n\t}\n\tif (sdinfo.cnt)\n\t\tret_code = dev->cqp->process_cqp_sds(dev, &sdinfo);\n\n\treturn ret_code;\n}\n\n \nstatic int irdma_hmc_finish_add_sd_reg(struct irdma_sc_dev *dev,\n\t\t\t\t       struct irdma_hmc_create_obj_info *info)\n{\n\tif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt)\n\t\treturn -EINVAL;\n\n\tif ((info->start_idx + info->count) >\n\t    info->hmc_info->hmc_obj[info->rsrc_type].cnt)\n\t\treturn -EINVAL;\n\n\tif (!info->add_sd_cnt)\n\t\treturn 0;\n\treturn irdma_hmc_sd_grp(dev, info->hmc_info,\n\t\t\t\tinfo->hmc_info->sd_indexes[0], info->add_sd_cnt,\n\t\t\t\ttrue);\n}\n\n \nint irdma_sc_create_hmc_obj(struct irdma_sc_dev *dev,\n\t\t\t    struct irdma_hmc_create_obj_info *info)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tu32 sd_idx, sd_lmt;\n\tu32 pd_idx = 0, pd_lmt = 0;\n\tu32 pd_idx1 = 0, pd_lmt1 = 0;\n\tu32 i, j;\n\tbool pd_error = false;\n\tint ret_code = 0;\n\n\tif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt)\n\t\treturn -EINVAL;\n\n\tif ((info->start_idx + info->count) >\n\t    info->hmc_info->hmc_obj[info->rsrc_type].cnt) {\n\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t  \"HMC: error type %u, start = %u, req cnt %u, cnt = %u\\n\",\n\t\t\t  info->rsrc_type, info->start_idx, info->count,\n\t\t\t  info->hmc_info->hmc_obj[info->rsrc_type].cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tirdma_find_sd_index_limit(info->hmc_info, info->rsrc_type,\n\t\t\t\t  info->start_idx, info->count, &sd_idx,\n\t\t\t\t  &sd_lmt);\n\tif (sd_idx >= info->hmc_info->sd_table.sd_cnt ||\n\t    sd_lmt > info->hmc_info->sd_table.sd_cnt) {\n\t\treturn -EINVAL;\n\t}\n\n\tirdma_find_pd_index_limit(info->hmc_info, info->rsrc_type,\n\t\t\t\t  info->start_idx, info->count, &pd_idx,\n\t\t\t\t  &pd_lmt);\n\n\tfor (j = sd_idx; j < sd_lmt; j++) {\n\t\tret_code = irdma_add_sd_table_entry(dev->hw, info->hmc_info, j,\n\t\t\t\t\t\t    info->entry_type,\n\t\t\t\t\t\t    IRDMA_HMC_DIRECT_BP_SIZE);\n\t\tif (ret_code)\n\t\t\tgoto exit_sd_error;\n\n\t\tsd_entry = &info->hmc_info->sd_table.sd_entry[j];\n\t\tif (sd_entry->entry_type == IRDMA_SD_TYPE_PAGED &&\n\t\t    (dev->hmc_info == info->hmc_info &&\n\t\t     info->rsrc_type != IRDMA_HMC_IW_PBLE)) {\n\t\t\tpd_idx1 = max(pd_idx, (j * IRDMA_HMC_MAX_BP_COUNT));\n\t\t\tpd_lmt1 = min(pd_lmt, (j + 1) * IRDMA_HMC_MAX_BP_COUNT);\n\t\t\tfor (i = pd_idx1; i < pd_lmt1; i++) {\n\t\t\t\t \n\t\t\t\tret_code = irdma_add_pd_table_entry(dev,\n\t\t\t\t\t\t\t\t    info->hmc_info,\n\t\t\t\t\t\t\t\t    i, NULL);\n\t\t\t\tif (ret_code) {\n\t\t\t\t\tpd_error = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pd_error) {\n\t\t\t\twhile (i && (i > pd_idx1)) {\n\t\t\t\t\tirdma_remove_pd_bp(dev, info->hmc_info,\n\t\t\t\t\t\t\t   i - 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sd_entry->valid)\n\t\t\tcontinue;\n\n\t\tinfo->hmc_info->sd_indexes[info->add_sd_cnt] = (u16)j;\n\t\tinfo->add_sd_cnt++;\n\t\tsd_entry->valid = true;\n\t}\n\treturn irdma_hmc_finish_add_sd_reg(dev, info);\n\nexit_sd_error:\n\twhile (j && (j > sd_idx)) {\n\t\tsd_entry = &info->hmc_info->sd_table.sd_entry[j - 1];\n\t\tswitch (sd_entry->entry_type) {\n\t\tcase IRDMA_SD_TYPE_PAGED:\n\t\t\tpd_idx1 = max(pd_idx, (j - 1) * IRDMA_HMC_MAX_BP_COUNT);\n\t\t\tpd_lmt1 = min(pd_lmt, (j * IRDMA_HMC_MAX_BP_COUNT));\n\t\t\tfor (i = pd_idx1; i < pd_lmt1; i++)\n\t\t\t\tirdma_prep_remove_pd_page(info->hmc_info, i);\n\t\t\tbreak;\n\t\tcase IRDMA_SD_TYPE_DIRECT:\n\t\t\tirdma_prep_remove_pd_page(info->hmc_info, (j - 1));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret_code = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tj--;\n\t}\n\n\treturn ret_code;\n}\n\n \nstatic int irdma_finish_del_sd_reg(struct irdma_sc_dev *dev,\n\t\t\t\t   struct irdma_hmc_del_obj_info *info,\n\t\t\t\t   bool reset)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tint ret_code = 0;\n\tu32 i, sd_idx;\n\tstruct irdma_dma_mem *mem;\n\n\tif (!reset)\n\t\tret_code = irdma_hmc_sd_grp(dev, info->hmc_info,\n\t\t\t\t\t    info->hmc_info->sd_indexes[0],\n\t\t\t\t\t    info->del_sd_cnt, false);\n\n\tif (ret_code)\n\t\tibdev_dbg(to_ibdev(dev), \"HMC: error cqp sd sd_grp\\n\");\n\tfor (i = 0; i < info->del_sd_cnt; i++) {\n\t\tsd_idx = info->hmc_info->sd_indexes[i];\n\t\tsd_entry = &info->hmc_info->sd_table.sd_entry[sd_idx];\n\t\tmem = (sd_entry->entry_type == IRDMA_SD_TYPE_PAGED) ?\n\t\t\t      &sd_entry->u.pd_table.pd_page_addr :\n\t\t\t      &sd_entry->u.bp.addr;\n\n\t\tif (!mem || !mem->va) {\n\t\t\tibdev_dbg(to_ibdev(dev), \"HMC: error cqp sd mem\\n\");\n\t\t} else {\n\t\t\tdma_free_coherent(dev->hw->device, mem->size, mem->va,\n\t\t\t\t\t  mem->pa);\n\t\t\tmem->va = NULL;\n\t\t}\n\t}\n\n\treturn ret_code;\n}\n\n \nint irdma_sc_del_hmc_obj(struct irdma_sc_dev *dev,\n\t\t\t struct irdma_hmc_del_obj_info *info, bool reset)\n{\n\tstruct irdma_hmc_pd_table *pd_table;\n\tu32 sd_idx, sd_lmt;\n\tu32 pd_idx, pd_lmt, rel_pd_idx;\n\tu32 i, j;\n\tint ret_code = 0;\n\n\tif (info->start_idx >= info->hmc_info->hmc_obj[info->rsrc_type].cnt) {\n\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t  \"HMC: error start_idx[%04d]  >= [type %04d].cnt[%04d]\\n\",\n\t\t\t  info->start_idx, info->rsrc_type,\n\t\t\t  info->hmc_info->hmc_obj[info->rsrc_type].cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((info->start_idx + info->count) >\n\t    info->hmc_info->hmc_obj[info->rsrc_type].cnt) {\n\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t  \"HMC: error start_idx[%04d] + count %04d  >= [type %04d].cnt[%04d]\\n\",\n\t\t\t  info->start_idx, info->count, info->rsrc_type,\n\t\t\t  info->hmc_info->hmc_obj[info->rsrc_type].cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tirdma_find_pd_index_limit(info->hmc_info, info->rsrc_type,\n\t\t\t\t  info->start_idx, info->count, &pd_idx,\n\t\t\t\t  &pd_lmt);\n\n\tfor (j = pd_idx; j < pd_lmt; j++) {\n\t\tsd_idx = j / IRDMA_HMC_PD_CNT_IN_SD;\n\n\t\tif (!info->hmc_info->sd_table.sd_entry[sd_idx].valid)\n\t\t\tcontinue;\n\n\t\tif (info->hmc_info->sd_table.sd_entry[sd_idx].entry_type !=\n\t\t    IRDMA_SD_TYPE_PAGED)\n\t\t\tcontinue;\n\n\t\trel_pd_idx = j % IRDMA_HMC_PD_CNT_IN_SD;\n\t\tpd_table = &info->hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\n\t\tif (pd_table->pd_entry &&\n\t\t    pd_table->pd_entry[rel_pd_idx].valid) {\n\t\t\tret_code = irdma_remove_pd_bp(dev, info->hmc_info, j);\n\t\t\tif (ret_code) {\n\t\t\t\tibdev_dbg(to_ibdev(dev),\n\t\t\t\t\t  \"HMC: remove_pd_bp error\\n\");\n\t\t\t\treturn ret_code;\n\t\t\t}\n\t\t}\n\t}\n\n\tirdma_find_sd_index_limit(info->hmc_info, info->rsrc_type,\n\t\t\t\t  info->start_idx, info->count, &sd_idx,\n\t\t\t\t  &sd_lmt);\n\tif (sd_idx >= info->hmc_info->sd_table.sd_cnt ||\n\t    sd_lmt > info->hmc_info->sd_table.sd_cnt) {\n\t\tibdev_dbg(to_ibdev(dev), \"HMC: invalid sd_idx\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = sd_idx; i < sd_lmt; i++) {\n\t\tpd_table = &info->hmc_info->sd_table.sd_entry[i].u.pd_table;\n\t\tif (!info->hmc_info->sd_table.sd_entry[i].valid)\n\t\t\tcontinue;\n\t\tswitch (info->hmc_info->sd_table.sd_entry[i].entry_type) {\n\t\tcase IRDMA_SD_TYPE_DIRECT:\n\t\t\tret_code = irdma_prep_remove_sd_bp(info->hmc_info, i);\n\t\t\tif (!ret_code) {\n\t\t\t\tinfo->hmc_info->sd_indexes[info->del_sd_cnt] =\n\t\t\t\t\t(u16)i;\n\t\t\t\tinfo->del_sd_cnt++;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IRDMA_SD_TYPE_PAGED:\n\t\t\tret_code = irdma_prep_remove_pd_page(info->hmc_info, i);\n\t\t\tif (ret_code)\n\t\t\t\tbreak;\n\t\t\tif (dev->hmc_info != info->hmc_info &&\n\t\t\t    info->rsrc_type == IRDMA_HMC_IW_PBLE &&\n\t\t\t    pd_table->pd_entry) {\n\t\t\t\tkfree(pd_table->pd_entry_virt_mem.va);\n\t\t\t\tpd_table->pd_entry = NULL;\n\t\t\t}\n\t\t\tinfo->hmc_info->sd_indexes[info->del_sd_cnt] = (u16)i;\n\t\t\tinfo->del_sd_cnt++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn irdma_finish_del_sd_reg(dev, info, reset);\n}\n\n \nint irdma_add_sd_table_entry(struct irdma_hw *hw,\n\t\t\t     struct irdma_hmc_info *hmc_info, u32 sd_index,\n\t\t\t     enum irdma_sd_entry_type type, u64 direct_mode_sz)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tstruct irdma_dma_mem dma_mem;\n\tu64 alloc_len;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[sd_index];\n\tif (!sd_entry->valid) {\n\t\tif (type == IRDMA_SD_TYPE_PAGED)\n\t\t\talloc_len = IRDMA_HMC_PAGED_BP_SIZE;\n\t\telse\n\t\t\talloc_len = direct_mode_sz;\n\n\t\t \n\t\tdma_mem.size = ALIGN(alloc_len, IRDMA_HMC_PD_BP_BUF_ALIGNMENT);\n\t\tdma_mem.va = dma_alloc_coherent(hw->device, dma_mem.size,\n\t\t\t\t\t\t&dma_mem.pa, GFP_KERNEL);\n\t\tif (!dma_mem.va)\n\t\t\treturn -ENOMEM;\n\t\tif (type == IRDMA_SD_TYPE_PAGED) {\n\t\t\tstruct irdma_virt_mem *vmem =\n\t\t\t\t&sd_entry->u.pd_table.pd_entry_virt_mem;\n\n\t\t\tvmem->size = sizeof(struct irdma_hmc_pd_entry) * 512;\n\t\t\tvmem->va = kzalloc(vmem->size, GFP_KERNEL);\n\t\t\tif (!vmem->va) {\n\t\t\t\tdma_free_coherent(hw->device, dma_mem.size,\n\t\t\t\t\t\t  dma_mem.va, dma_mem.pa);\n\t\t\t\tdma_mem.va = NULL;\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tsd_entry->u.pd_table.pd_entry = vmem->va;\n\n\t\t\tmemcpy(&sd_entry->u.pd_table.pd_page_addr, &dma_mem,\n\t\t\t       sizeof(sd_entry->u.pd_table.pd_page_addr));\n\t\t} else {\n\t\t\tmemcpy(&sd_entry->u.bp.addr, &dma_mem,\n\t\t\t       sizeof(sd_entry->u.bp.addr));\n\n\t\t\tsd_entry->u.bp.sd_pd_index = sd_index;\n\t\t}\n\n\t\thmc_info->sd_table.sd_entry[sd_index].entry_type = type;\n\t\thmc_info->sd_table.use_cnt++;\n\t}\n\tif (sd_entry->entry_type == IRDMA_SD_TYPE_DIRECT)\n\t\tsd_entry->u.bp.use_cnt++;\n\n\treturn 0;\n}\n\n \nint irdma_add_pd_table_entry(struct irdma_sc_dev *dev,\n\t\t\t     struct irdma_hmc_info *hmc_info, u32 pd_index,\n\t\t\t     struct irdma_dma_mem *rsrc_pg)\n{\n\tstruct irdma_hmc_pd_table *pd_table;\n\tstruct irdma_hmc_pd_entry *pd_entry;\n\tstruct irdma_dma_mem mem;\n\tstruct irdma_dma_mem *page = &mem;\n\tu32 sd_idx, rel_pd_idx;\n\tu64 *pd_addr;\n\tu64 page_desc;\n\n\tif (pd_index / IRDMA_HMC_PD_CNT_IN_SD >= hmc_info->sd_table.sd_cnt)\n\t\treturn -EINVAL;\n\n\tsd_idx = (pd_index / IRDMA_HMC_PD_CNT_IN_SD);\n\tif (hmc_info->sd_table.sd_entry[sd_idx].entry_type !=\n\t    IRDMA_SD_TYPE_PAGED)\n\t\treturn 0;\n\n\trel_pd_idx = (pd_index % IRDMA_HMC_PD_CNT_IN_SD);\n\tpd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\n\tpd_entry = &pd_table->pd_entry[rel_pd_idx];\n\tif (!pd_entry->valid) {\n\t\tif (rsrc_pg) {\n\t\t\tpd_entry->rsrc_pg = true;\n\t\t\tpage = rsrc_pg;\n\t\t} else {\n\t\t\tpage->size = ALIGN(IRDMA_HMC_PAGED_BP_SIZE,\n\t\t\t\t\t   IRDMA_HMC_PD_BP_BUF_ALIGNMENT);\n\t\t\tpage->va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t\t      page->size, &page->pa,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!page->va)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpd_entry->rsrc_pg = false;\n\t\t}\n\n\t\tmemcpy(&pd_entry->bp.addr, page, sizeof(pd_entry->bp.addr));\n\t\tpd_entry->bp.sd_pd_index = pd_index;\n\t\tpd_entry->bp.entry_type = IRDMA_SD_TYPE_PAGED;\n\t\tpage_desc = page->pa | 0x1;\n\t\tpd_addr = pd_table->pd_page_addr.va;\n\t\tpd_addr += rel_pd_idx;\n\t\tmemcpy(pd_addr, &page_desc, sizeof(*pd_addr));\n\t\tpd_entry->sd_index = sd_idx;\n\t\tpd_entry->valid = true;\n\t\tpd_table->use_cnt++;\n\t\tirdma_invalidate_pf_hmc_pd(dev, sd_idx, rel_pd_idx);\n\t}\n\tpd_entry->bp.use_cnt++;\n\n\treturn 0;\n}\n\n \nint irdma_remove_pd_bp(struct irdma_sc_dev *dev,\n\t\t       struct irdma_hmc_info *hmc_info, u32 idx)\n{\n\tstruct irdma_hmc_pd_entry *pd_entry;\n\tstruct irdma_hmc_pd_table *pd_table;\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tu32 sd_idx, rel_pd_idx;\n\tstruct irdma_dma_mem *mem;\n\tu64 *pd_addr;\n\n\tsd_idx = idx / IRDMA_HMC_PD_CNT_IN_SD;\n\trel_pd_idx = idx % IRDMA_HMC_PD_CNT_IN_SD;\n\tif (sd_idx >= hmc_info->sd_table.sd_cnt)\n\t\treturn -EINVAL;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[sd_idx];\n\tif (sd_entry->entry_type != IRDMA_SD_TYPE_PAGED)\n\t\treturn -EINVAL;\n\n\tpd_table = &hmc_info->sd_table.sd_entry[sd_idx].u.pd_table;\n\tpd_entry = &pd_table->pd_entry[rel_pd_idx];\n\tif (--pd_entry->bp.use_cnt)\n\t\treturn 0;\n\n\tpd_entry->valid = false;\n\tpd_table->use_cnt--;\n\tpd_addr = pd_table->pd_page_addr.va;\n\tpd_addr += rel_pd_idx;\n\tmemset(pd_addr, 0, sizeof(u64));\n\tirdma_invalidate_pf_hmc_pd(dev, sd_idx, idx);\n\n\tif (!pd_entry->rsrc_pg) {\n\t\tmem = &pd_entry->bp.addr;\n\t\tif (!mem || !mem->va)\n\t\t\treturn -EINVAL;\n\n\t\tdma_free_coherent(dev->hw->device, mem->size, mem->va,\n\t\t\t\t  mem->pa);\n\t\tmem->va = NULL;\n\t}\n\tif (!pd_table->use_cnt)\n\t\tkfree(pd_table->pd_entry_virt_mem.va);\n\n\treturn 0;\n}\n\n \nint irdma_prep_remove_sd_bp(struct irdma_hmc_info *hmc_info, u32 idx)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\tif (--sd_entry->u.bp.use_cnt)\n\t\treturn -EBUSY;\n\n\thmc_info->sd_table.use_cnt--;\n\tsd_entry->valid = false;\n\n\treturn 0;\n}\n\n \nint irdma_prep_remove_pd_page(struct irdma_hmc_info *hmc_info, u32 idx)\n{\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\n\tsd_entry = &hmc_info->sd_table.sd_entry[idx];\n\n\tif (sd_entry->u.pd_table.use_cnt)\n\t\treturn -EBUSY;\n\n\tsd_entry->valid = false;\n\thmc_info->sd_table.use_cnt--;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}