{
  "module_name": "cm.c",
  "hash_id": "219fa16d13cbfe9cb13e174ad79390c342f7f7109f72d514801468f03e5f67f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/cm.c",
  "human_readable_source": "\n \n#include \"main.h\"\n#include \"trace.h\"\n\nstatic void irdma_cm_post_event(struct irdma_cm_event *event);\nstatic void irdma_disconnect_worker(struct work_struct *work);\n\n \nvoid irdma_free_sqbuf(struct irdma_sc_vsi *vsi, void *bufp)\n{\n\tstruct irdma_puda_buf *buf = bufp;\n\tstruct irdma_puda_rsrc *ilq = vsi->ilq;\n\n\tif (refcount_dec_and_test(&buf->refcount))\n\t\tirdma_puda_ret_bufpool(ilq, buf);\n}\n\n \nstatic void irdma_record_ird_ord(struct irdma_cm_node *cm_node, u32 conn_ird,\n\t\t\t\t u32 conn_ord)\n{\n\tif (conn_ird > cm_node->dev->hw_attrs.max_hw_ird)\n\t\tconn_ird = cm_node->dev->hw_attrs.max_hw_ird;\n\n\tif (conn_ord > cm_node->dev->hw_attrs.max_hw_ord)\n\t\tconn_ord = cm_node->dev->hw_attrs.max_hw_ord;\n\telse if (!conn_ord && cm_node->send_rdma0_op == SEND_RDMA_READ_ZERO)\n\t\tconn_ord = 1;\n\tcm_node->ird_size = conn_ird;\n\tcm_node->ord_size = conn_ord;\n}\n\n \nvoid irdma_copy_ip_ntohl(u32 *dst, __be32 *src)\n{\n\t*dst++ = ntohl(*src++);\n\t*dst++ = ntohl(*src++);\n\t*dst++ = ntohl(*src++);\n\t*dst = ntohl(*src);\n}\n\n \nvoid irdma_copy_ip_htonl(__be32 *dst, u32 *src)\n{\n\t*dst++ = htonl(*src++);\n\t*dst++ = htonl(*src++);\n\t*dst++ = htonl(*src++);\n\t*dst = htonl(*src);\n}\n\n \nstatic void irdma_get_addr_info(struct irdma_cm_node *cm_node,\n\t\t\t\tstruct irdma_cm_info *cm_info)\n{\n\tmemset(cm_info, 0, sizeof(*cm_info));\n\tcm_info->ipv4 = cm_node->ipv4;\n\tcm_info->vlan_id = cm_node->vlan_id;\n\tmemcpy(cm_info->loc_addr, cm_node->loc_addr, sizeof(cm_info->loc_addr));\n\tmemcpy(cm_info->rem_addr, cm_node->rem_addr, sizeof(cm_info->rem_addr));\n\tcm_info->loc_port = cm_node->loc_port;\n\tcm_info->rem_port = cm_node->rem_port;\n}\n\n \nstatic inline void irdma_fill_sockaddr4(struct irdma_cm_node *cm_node,\n\t\t\t\t\tstruct iw_cm_event *event)\n{\n\tstruct sockaddr_in *laddr = (struct sockaddr_in *)&event->local_addr;\n\tstruct sockaddr_in *raddr = (struct sockaddr_in *)&event->remote_addr;\n\n\tladdr->sin_family = AF_INET;\n\traddr->sin_family = AF_INET;\n\n\tladdr->sin_port = htons(cm_node->loc_port);\n\traddr->sin_port = htons(cm_node->rem_port);\n\n\tladdr->sin_addr.s_addr = htonl(cm_node->loc_addr[0]);\n\traddr->sin_addr.s_addr = htonl(cm_node->rem_addr[0]);\n}\n\n \nstatic inline void irdma_fill_sockaddr6(struct irdma_cm_node *cm_node,\n\t\t\t\t\tstruct iw_cm_event *event)\n{\n\tstruct sockaddr_in6 *laddr6 = (struct sockaddr_in6 *)&event->local_addr;\n\tstruct sockaddr_in6 *raddr6 = (struct sockaddr_in6 *)&event->remote_addr;\n\n\tladdr6->sin6_family = AF_INET6;\n\traddr6->sin6_family = AF_INET6;\n\n\tladdr6->sin6_port = htons(cm_node->loc_port);\n\traddr6->sin6_port = htons(cm_node->rem_port);\n\n\tirdma_copy_ip_htonl(laddr6->sin6_addr.in6_u.u6_addr32,\n\t\t\t    cm_node->loc_addr);\n\tirdma_copy_ip_htonl(raddr6->sin6_addr.in6_u.u6_addr32,\n\t\t\t    cm_node->rem_addr);\n}\n\n \nstatic inline void irdma_get_cmevent_info(struct irdma_cm_node *cm_node,\n\t\t\t\t\t  struct iw_cm_id *cm_id,\n\t\t\t\t\t  struct iw_cm_event *event)\n{\n\tmemcpy(&event->local_addr, &cm_id->m_local_addr,\n\t       sizeof(event->local_addr));\n\tmemcpy(&event->remote_addr, &cm_id->m_remote_addr,\n\t       sizeof(event->remote_addr));\n\tif (cm_node) {\n\t\tevent->private_data = cm_node->pdata_buf;\n\t\tevent->private_data_len = (u8)cm_node->pdata.size;\n\t\tevent->ird = cm_node->ird_size;\n\t\tevent->ord = cm_node->ord_size;\n\t}\n}\n\n \nstatic int irdma_send_cm_event(struct irdma_cm_node *cm_node,\n\t\t\t       struct iw_cm_id *cm_id,\n\t\t\t       enum iw_cm_event_type type, int status)\n{\n\tstruct iw_cm_event event = {};\n\n\tevent.event = type;\n\tevent.status = status;\n\ttrace_irdma_send_cm_event(cm_node, cm_id, type, status,\n\t\t\t\t  __builtin_return_address(0));\n\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: cm_node %p cm_id=%p state=%d accel=%d event_type=%d status=%d\\n\",\n\t\t  cm_node, cm_id, cm_node->accelerated, cm_node->state, type,\n\t\t  status);\n\n\tswitch (type) {\n\tcase IW_CM_EVENT_CONNECT_REQUEST:\n\t\tif (cm_node->ipv4)\n\t\t\tirdma_fill_sockaddr4(cm_node, &event);\n\t\telse\n\t\t\tirdma_fill_sockaddr6(cm_node, &event);\n\t\tevent.provider_data = cm_node;\n\t\tevent.private_data = cm_node->pdata_buf;\n\t\tevent.private_data_len = (u8)cm_node->pdata.size;\n\t\tevent.ird = cm_node->ird_size;\n\t\tbreak;\n\tcase IW_CM_EVENT_CONNECT_REPLY:\n\t\tirdma_get_cmevent_info(cm_node, cm_id, &event);\n\t\tbreak;\n\tcase IW_CM_EVENT_ESTABLISHED:\n\t\tevent.ird = cm_node->ird_size;\n\t\tevent.ord = cm_node->ord_size;\n\t\tbreak;\n\tcase IW_CM_EVENT_DISCONNECT:\n\tcase IW_CM_EVENT_CLOSE:\n\t\t \n\t\tif (!cm_node->accelerated)\n\t\t\twait_for_completion(&cm_node->establish_comp);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cm_id->event_handler(cm_id, &event);\n}\n\n \nstatic void irdma_timer_list_prep(struct irdma_cm_core *cm_core,\n\t\t\t\t  struct list_head *timer_list)\n{\n\tstruct irdma_cm_node *cm_node;\n\tint bkt;\n\n\thash_for_each_rcu(cm_core->cm_hash_tbl, bkt, cm_node, list) {\n\t\tif ((cm_node->close_entry || cm_node->send_entry) &&\n\t\t    refcount_inc_not_zero(&cm_node->refcnt))\n\t\t\tlist_add(&cm_node->timer_entry, timer_list);\n\t}\n}\n\n \nstatic struct irdma_cm_event *irdma_create_event(struct irdma_cm_node *cm_node,\n\t\t\t\t\t\t enum irdma_cm_event_type type)\n{\n\tstruct irdma_cm_event *event;\n\n\tif (!cm_node->cm_id)\n\t\treturn NULL;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\n\tif (!event)\n\t\treturn NULL;\n\n\tevent->type = type;\n\tevent->cm_node = cm_node;\n\tmemcpy(event->cm_info.rem_addr, cm_node->rem_addr,\n\t       sizeof(event->cm_info.rem_addr));\n\tmemcpy(event->cm_info.loc_addr, cm_node->loc_addr,\n\t       sizeof(event->cm_info.loc_addr));\n\tevent->cm_info.rem_port = cm_node->rem_port;\n\tevent->cm_info.loc_port = cm_node->loc_port;\n\tevent->cm_info.cm_id = cm_node->cm_id;\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: node=%p event=%p type=%u dst=%pI4 src=%pI4\\n\", cm_node,\n\t\t  event, type, event->cm_info.loc_addr,\n\t\t  event->cm_info.rem_addr);\n\ttrace_irdma_create_event(cm_node, type, __builtin_return_address(0));\n\tirdma_cm_post_event(event);\n\n\treturn event;\n}\n\n \nstatic void irdma_free_retrans_entry(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_device *iwdev = cm_node->iwdev;\n\tstruct irdma_timer_entry *send_entry;\n\n\tsend_entry = cm_node->send_entry;\n\tif (!send_entry)\n\t\treturn;\n\n\tcm_node->send_entry = NULL;\n\tirdma_free_sqbuf(&iwdev->vsi, send_entry->sqbuf);\n\tkfree(send_entry);\n\trefcount_dec(&cm_node->refcnt);\n}\n\n \nstatic void irdma_cleanup_retrans_entry(struct irdma_cm_node *cm_node)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\n\tirdma_free_retrans_entry(cm_node);\n\tspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\n}\n\n \nstatic struct irdma_puda_buf *irdma_form_ah_cm_frame(struct irdma_cm_node *cm_node,\n\t\t\t\t\t\t     struct irdma_kmem_info *options,\n\t\t\t\t\t\t     struct irdma_kmem_info *hdr,\n\t\t\t\t\t\t     struct irdma_mpa_priv_info *pdata,\n\t\t\t\t\t\t     u8 flags)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tstruct irdma_sc_vsi *vsi = &cm_node->iwdev->vsi;\n\tu8 *buf;\n\tstruct tcphdr *tcph;\n\tu16 pktsize;\n\tu32 opts_len = 0;\n\tu32 pd_len = 0;\n\tu32 hdr_len = 0;\n\n\tif (!cm_node->ah || !cm_node->ah->ah_info.ah_valid) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev, \"CM: AH invalid\\n\");\n\t\treturn NULL;\n\t}\n\n\tsqbuf = irdma_puda_get_bufpool(vsi->ilq);\n\tif (!sqbuf) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev, \"CM: SQ buf NULL\\n\");\n\t\treturn NULL;\n\t}\n\n\tsqbuf->ah_id = cm_node->ah->ah_info.ah_idx;\n\tbuf = sqbuf->mem.va;\n\tif (options)\n\t\topts_len = (u32)options->size;\n\n\tif (hdr)\n\t\thdr_len = hdr->size;\n\n\tif (pdata)\n\t\tpd_len = pdata->size;\n\n\tpktsize = sizeof(*tcph) + opts_len + hdr_len + pd_len;\n\n\tmemset(buf, 0, sizeof(*tcph));\n\n\tsqbuf->totallen = pktsize;\n\tsqbuf->tcphlen = sizeof(*tcph) + opts_len;\n\tsqbuf->scratch = cm_node;\n\n\ttcph = (struct tcphdr *)buf;\n\tbuf += sizeof(*tcph);\n\n\ttcph->source = htons(cm_node->loc_port);\n\ttcph->dest = htons(cm_node->rem_port);\n\ttcph->seq = htonl(cm_node->tcp_cntxt.loc_seq_num);\n\n\tif (flags & SET_ACK) {\n\t\tcm_node->tcp_cntxt.loc_ack_num = cm_node->tcp_cntxt.rcv_nxt;\n\t\ttcph->ack_seq = htonl(cm_node->tcp_cntxt.loc_ack_num);\n\t\ttcph->ack = 1;\n\t} else {\n\t\ttcph->ack_seq = 0;\n\t}\n\n\tif (flags & SET_SYN) {\n\t\tcm_node->tcp_cntxt.loc_seq_num++;\n\t\ttcph->syn = 1;\n\t} else {\n\t\tcm_node->tcp_cntxt.loc_seq_num += hdr_len + pd_len;\n\t}\n\n\tif (flags & SET_FIN) {\n\t\tcm_node->tcp_cntxt.loc_seq_num++;\n\t\ttcph->fin = 1;\n\t}\n\n\tif (flags & SET_RST)\n\t\ttcph->rst = 1;\n\n\ttcph->doff = (u16)((sizeof(*tcph) + opts_len + 3) >> 2);\n\tsqbuf->tcphlen = tcph->doff << 2;\n\ttcph->window = htons(cm_node->tcp_cntxt.rcv_wnd);\n\ttcph->urg_ptr = 0;\n\n\tif (opts_len) {\n\t\tmemcpy(buf, options->addr, opts_len);\n\t\tbuf += opts_len;\n\t}\n\n\tif (hdr_len) {\n\t\tmemcpy(buf, hdr->addr, hdr_len);\n\t\tbuf += hdr_len;\n\t}\n\n\tif (pdata && pdata->addr)\n\t\tmemcpy(buf, pdata->addr, pdata->size);\n\n\trefcount_set(&sqbuf->refcount, 1);\n\n\tprint_hex_dump_debug(\"ILQ: TRANSMIT ILQ BUFFER\", DUMP_PREFIX_OFFSET,\n\t\t\t     16, 8, sqbuf->mem.va, sqbuf->totallen, false);\n\n\treturn sqbuf;\n}\n\n \nstatic struct irdma_puda_buf *irdma_form_uda_cm_frame(struct irdma_cm_node *cm_node,\n\t\t\t\t\t\t      struct irdma_kmem_info *options,\n\t\t\t\t\t\t      struct irdma_kmem_info *hdr,\n\t\t\t\t\t\t      struct irdma_mpa_priv_info *pdata,\n\t\t\t\t\t\t      u8 flags)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tstruct irdma_sc_vsi *vsi = &cm_node->iwdev->vsi;\n\tu8 *buf;\n\n\tstruct tcphdr *tcph;\n\tstruct iphdr *iph;\n\tstruct ipv6hdr *ip6h;\n\tstruct ethhdr *ethh;\n\tu16 pktsize;\n\tu16 eth_hlen = ETH_HLEN;\n\tu32 opts_len = 0;\n\tu32 pd_len = 0;\n\tu32 hdr_len = 0;\n\n\tu16 vtag;\n\n\tsqbuf = irdma_puda_get_bufpool(vsi->ilq);\n\tif (!sqbuf)\n\t\treturn NULL;\n\n\tbuf = sqbuf->mem.va;\n\n\tif (options)\n\t\topts_len = (u32)options->size;\n\n\tif (hdr)\n\t\thdr_len = hdr->size;\n\n\tif (pdata)\n\t\tpd_len = pdata->size;\n\n\tif (cm_node->vlan_id < VLAN_N_VID)\n\t\teth_hlen += 4;\n\n\tif (cm_node->ipv4)\n\t\tpktsize = sizeof(*iph) + sizeof(*tcph);\n\telse\n\t\tpktsize = sizeof(*ip6h) + sizeof(*tcph);\n\tpktsize += opts_len + hdr_len + pd_len;\n\n\tmemset(buf, 0, eth_hlen + pktsize);\n\n\tsqbuf->totallen = pktsize + eth_hlen;\n\tsqbuf->maclen = eth_hlen;\n\tsqbuf->tcphlen = sizeof(*tcph) + opts_len;\n\tsqbuf->scratch = cm_node;\n\n\tethh = (struct ethhdr *)buf;\n\tbuf += eth_hlen;\n\n\tif (cm_node->do_lpb)\n\t\tsqbuf->do_lpb = true;\n\n\tif (cm_node->ipv4) {\n\t\tsqbuf->ipv4 = true;\n\n\t\tiph = (struct iphdr *)buf;\n\t\tbuf += sizeof(*iph);\n\t\ttcph = (struct tcphdr *)buf;\n\t\tbuf += sizeof(*tcph);\n\n\t\tether_addr_copy(ethh->h_dest, cm_node->rem_mac);\n\t\tether_addr_copy(ethh->h_source, cm_node->loc_mac);\n\t\tif (cm_node->vlan_id < VLAN_N_VID) {\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_proto =\n\t\t\t\thtons(ETH_P_8021Q);\n\t\t\tvtag = (cm_node->user_pri << VLAN_PRIO_SHIFT) |\n\t\t\t       cm_node->vlan_id;\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_TCI = htons(vtag);\n\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_encapsulated_proto =\n\t\t\t\thtons(ETH_P_IP);\n\t\t} else {\n\t\t\tethh->h_proto = htons(ETH_P_IP);\n\t\t}\n\n\t\tiph->version = IPVERSION;\n\t\tiph->ihl = 5;  \n\t\tiph->tos = cm_node->tos;\n\t\tiph->tot_len = htons(pktsize);\n\t\tiph->id = htons(++cm_node->tcp_cntxt.loc_id);\n\n\t\tiph->frag_off = htons(0x4000);\n\t\tiph->ttl = 0x40;\n\t\tiph->protocol = IPPROTO_TCP;\n\t\tiph->saddr = htonl(cm_node->loc_addr[0]);\n\t\tiph->daddr = htonl(cm_node->rem_addr[0]);\n\t} else {\n\t\tsqbuf->ipv4 = false;\n\t\tip6h = (struct ipv6hdr *)buf;\n\t\tbuf += sizeof(*ip6h);\n\t\ttcph = (struct tcphdr *)buf;\n\t\tbuf += sizeof(*tcph);\n\n\t\tether_addr_copy(ethh->h_dest, cm_node->rem_mac);\n\t\tether_addr_copy(ethh->h_source, cm_node->loc_mac);\n\t\tif (cm_node->vlan_id < VLAN_N_VID) {\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_proto =\n\t\t\t\thtons(ETH_P_8021Q);\n\t\t\tvtag = (cm_node->user_pri << VLAN_PRIO_SHIFT) |\n\t\t\t       cm_node->vlan_id;\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_TCI = htons(vtag);\n\t\t\t((struct vlan_ethhdr *)ethh)->h_vlan_encapsulated_proto =\n\t\t\t\thtons(ETH_P_IPV6);\n\t\t} else {\n\t\t\tethh->h_proto = htons(ETH_P_IPV6);\n\t\t}\n\t\tip6h->version = 6;\n\t\tip6h->priority = cm_node->tos >> 4;\n\t\tip6h->flow_lbl[0] = cm_node->tos << 4;\n\t\tip6h->flow_lbl[1] = 0;\n\t\tip6h->flow_lbl[2] = 0;\n\t\tip6h->payload_len = htons(pktsize - sizeof(*ip6h));\n\t\tip6h->nexthdr = 6;\n\t\tip6h->hop_limit = 128;\n\t\tirdma_copy_ip_htonl(ip6h->saddr.in6_u.u6_addr32,\n\t\t\t\t    cm_node->loc_addr);\n\t\tirdma_copy_ip_htonl(ip6h->daddr.in6_u.u6_addr32,\n\t\t\t\t    cm_node->rem_addr);\n\t}\n\n\ttcph->source = htons(cm_node->loc_port);\n\ttcph->dest = htons(cm_node->rem_port);\n\ttcph->seq = htonl(cm_node->tcp_cntxt.loc_seq_num);\n\n\tif (flags & SET_ACK) {\n\t\tcm_node->tcp_cntxt.loc_ack_num = cm_node->tcp_cntxt.rcv_nxt;\n\t\ttcph->ack_seq = htonl(cm_node->tcp_cntxt.loc_ack_num);\n\t\ttcph->ack = 1;\n\t} else {\n\t\ttcph->ack_seq = 0;\n\t}\n\n\tif (flags & SET_SYN) {\n\t\tcm_node->tcp_cntxt.loc_seq_num++;\n\t\ttcph->syn = 1;\n\t} else {\n\t\tcm_node->tcp_cntxt.loc_seq_num += hdr_len + pd_len;\n\t}\n\n\tif (flags & SET_FIN) {\n\t\tcm_node->tcp_cntxt.loc_seq_num++;\n\t\ttcph->fin = 1;\n\t}\n\n\tif (flags & SET_RST)\n\t\ttcph->rst = 1;\n\n\ttcph->doff = (u16)((sizeof(*tcph) + opts_len + 3) >> 2);\n\tsqbuf->tcphlen = tcph->doff << 2;\n\ttcph->window = htons(cm_node->tcp_cntxt.rcv_wnd);\n\ttcph->urg_ptr = 0;\n\n\tif (opts_len) {\n\t\tmemcpy(buf, options->addr, opts_len);\n\t\tbuf += opts_len;\n\t}\n\n\tif (hdr_len) {\n\t\tmemcpy(buf, hdr->addr, hdr_len);\n\t\tbuf += hdr_len;\n\t}\n\n\tif (pdata && pdata->addr)\n\t\tmemcpy(buf, pdata->addr, pdata->size);\n\n\trefcount_set(&sqbuf->refcount, 1);\n\n\tprint_hex_dump_debug(\"ILQ: TRANSMIT ILQ BUFFER\", DUMP_PREFIX_OFFSET,\n\t\t\t     16, 8, sqbuf->mem.va, sqbuf->totallen, false);\n\treturn sqbuf;\n}\n\n \nint irdma_send_reset(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tint flags = SET_RST | SET_ACK;\n\n\ttrace_irdma_send_reset(cm_node, 0, __builtin_return_address(0));\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, NULL, NULL, NULL,\n\t\t\t\t\t\tflags);\n\tif (!sqbuf)\n\t\treturn -ENOMEM;\n\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: caller: %pS cm_node %p cm_id=%p accel=%d state=%d rem_port=0x%04x, loc_port=0x%04x rem_addr=%pI4 loc_addr=%pI4\\n\",\n\t\t  __builtin_return_address(0), cm_node, cm_node->cm_id,\n\t\t  cm_node->accelerated, cm_node->state, cm_node->rem_port,\n\t\t  cm_node->loc_port, cm_node->rem_addr, cm_node->loc_addr);\n\n\treturn irdma_schedule_cm_timer(cm_node, sqbuf, IRDMA_TIMER_TYPE_SEND, 0,\n\t\t\t\t       1);\n}\n\n \nstatic void irdma_active_open_err(struct irdma_cm_node *cm_node, bool reset)\n{\n\ttrace_irdma_active_open_err(cm_node, reset,\n\t\t\t\t    __builtin_return_address(0));\n\tirdma_cleanup_retrans_entry(cm_node);\n\tcm_node->cm_core->stats_connect_errs++;\n\tif (reset) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: cm_node=%p state=%d\\n\", cm_node,\n\t\t\t  cm_node->state);\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t}\n\n\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\tirdma_create_event(cm_node, IRDMA_CM_EVENT_ABORTED);\n}\n\n \nstatic void irdma_passive_open_err(struct irdma_cm_node *cm_node, bool reset)\n{\n\tirdma_cleanup_retrans_entry(cm_node);\n\tcm_node->cm_core->stats_passive_errs++;\n\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\tibdev_dbg(&cm_node->iwdev->ibdev, \"CM: cm_node=%p state =%d\\n\",\n\t\t  cm_node, cm_node->state);\n\ttrace_irdma_passive_open_err(cm_node, reset,\n\t\t\t\t     __builtin_return_address(0));\n\tif (reset)\n\t\tirdma_send_reset(cm_node);\n\telse\n\t\tirdma_rem_ref_cm_node(cm_node);\n}\n\n \nstatic void irdma_event_connect_error(struct irdma_cm_event *event)\n{\n\tstruct irdma_qp *iwqp;\n\tstruct iw_cm_id *cm_id;\n\n\tcm_id = event->cm_node->cm_id;\n\tif (!cm_id)\n\t\treturn;\n\n\tiwqp = cm_id->provider_data;\n\n\tif (!iwqp || !iwqp->iwdev)\n\t\treturn;\n\n\tiwqp->cm_id = NULL;\n\tcm_id->provider_data = NULL;\n\tirdma_send_cm_event(event->cm_node, cm_id, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t    -ECONNRESET);\n\tirdma_rem_ref_cm_node(event->cm_node);\n}\n\n \nstatic int irdma_process_options(struct irdma_cm_node *cm_node, u8 *optionsloc,\n\t\t\t\t u32 optionsize, u32 syn_pkt)\n{\n\tu32 tmp;\n\tu32 offset = 0;\n\tunion all_known_options *all_options;\n\tchar got_mss_option = 0;\n\n\twhile (offset < optionsize) {\n\t\tall_options = (union all_known_options *)(optionsloc + offset);\n\t\tswitch (all_options->base.optionnum) {\n\t\tcase OPTION_NUM_EOL:\n\t\t\toffset = optionsize;\n\t\t\tbreak;\n\t\tcase OPTION_NUM_NONE:\n\t\t\toffset += 1;\n\t\t\tcontinue;\n\t\tcase OPTION_NUM_MSS:\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: MSS Length: %d Offset: %d Size: %d\\n\",\n\t\t\t\t  all_options->mss.len, offset, optionsize);\n\t\t\tgot_mss_option = 1;\n\t\t\tif (all_options->mss.len != 4)\n\t\t\t\treturn -EINVAL;\n\t\t\ttmp = ntohs(all_options->mss.mss);\n\t\t\tif ((cm_node->ipv4 &&\n\t\t\t     (tmp + IRDMA_MTU_TO_MSS_IPV4) < IRDMA_MIN_MTU_IPV4) ||\n\t\t\t    (!cm_node->ipv4 &&\n\t\t\t     (tmp + IRDMA_MTU_TO_MSS_IPV6) < IRDMA_MIN_MTU_IPV6))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (tmp < cm_node->tcp_cntxt.mss)\n\t\t\t\tcm_node->tcp_cntxt.mss = tmp;\n\t\t\tbreak;\n\t\tcase OPTION_NUM_WINDOW_SCALE:\n\t\t\tcm_node->tcp_cntxt.snd_wscale =\n\t\t\t\tall_options->windowscale.shiftcount;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: Unsupported TCP Option: %x\\n\",\n\t\t\t\t  all_options->base.optionnum);\n\t\t\tbreak;\n\t\t}\n\t\toffset += all_options->base.len;\n\t}\n\tif (!got_mss_option && syn_pkt)\n\t\tcm_node->tcp_cntxt.mss = IRDMA_CM_DEFAULT_MSS;\n\n\treturn 0;\n}\n\n \nstatic int irdma_handle_tcp_options(struct irdma_cm_node *cm_node,\n\t\t\t\t    struct tcphdr *tcph, int optionsize,\n\t\t\t\t    int passive)\n{\n\tu8 *optionsloc = (u8 *)&tcph[1];\n\tint ret;\n\n\tif (optionsize) {\n\t\tret = irdma_process_options(cm_node, optionsloc, optionsize,\n\t\t\t\t\t    (u32)tcph->syn);\n\t\tif (ret) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: Node %p, Sending Reset\\n\", cm_node);\n\t\t\tif (passive)\n\t\t\t\tirdma_passive_open_err(cm_node, true);\n\t\t\telse\n\t\t\t\tirdma_active_open_err(cm_node, true);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tcm_node->tcp_cntxt.snd_wnd = ntohs(tcph->window)\n\t\t\t\t     << cm_node->tcp_cntxt.snd_wscale;\n\n\tif (cm_node->tcp_cntxt.snd_wnd > cm_node->tcp_cntxt.max_snd_wnd)\n\t\tcm_node->tcp_cntxt.max_snd_wnd = cm_node->tcp_cntxt.snd_wnd;\n\n\treturn 0;\n}\n\n \nstatic void irdma_build_mpa_v1(struct irdma_cm_node *cm_node, void *start_addr,\n\t\t\t       u8 mpa_key)\n{\n\tstruct ietf_mpa_v1 *mpa_frame = start_addr;\n\n\tswitch (mpa_key) {\n\tcase MPA_KEY_REQUEST:\n\t\tmemcpy(mpa_frame->key, IEFT_MPA_KEY_REQ, IETF_MPA_KEY_SIZE);\n\t\tbreak;\n\tcase MPA_KEY_REPLY:\n\t\tmemcpy(mpa_frame->key, IEFT_MPA_KEY_REP, IETF_MPA_KEY_SIZE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmpa_frame->flags = IETF_MPA_FLAGS_CRC;\n\tmpa_frame->rev = cm_node->mpa_frame_rev;\n\tmpa_frame->priv_data_len = htons(cm_node->pdata.size);\n}\n\n \nstatic void irdma_build_mpa_v2(struct irdma_cm_node *cm_node, void *start_addr,\n\t\t\t       u8 mpa_key)\n{\n\tstruct ietf_mpa_v2 *mpa_frame = start_addr;\n\tstruct ietf_rtr_msg *rtr_msg = &mpa_frame->rtr_msg;\n\tu16 ctrl_ird, ctrl_ord;\n\n\t \n\tirdma_build_mpa_v1(cm_node, start_addr, mpa_key);\n\tmpa_frame->flags |= IETF_MPA_V2_FLAG;\n\tif (cm_node->iwdev->iw_ooo) {\n\t\tmpa_frame->flags |= IETF_MPA_FLAGS_MARKERS;\n\t\tcm_node->rcv_mark_en = true;\n\t}\n\tmpa_frame->priv_data_len = cpu_to_be16(be16_to_cpu(mpa_frame->priv_data_len) +\n\t\t\t\t\t       IETF_RTR_MSG_SIZE);\n\n\t \n\tif (cm_node->mpav2_ird_ord == IETF_NO_IRD_ORD) {\n\t\tctrl_ird = IETF_NO_IRD_ORD;\n\t\tctrl_ord = IETF_NO_IRD_ORD;\n\t} else {\n\t\tctrl_ird = (cm_node->ird_size > IETF_NO_IRD_ORD) ?\n\t\t\t\t   IETF_NO_IRD_ORD :\n\t\t\t\t   cm_node->ird_size;\n\t\tctrl_ord = (cm_node->ord_size > IETF_NO_IRD_ORD) ?\n\t\t\t\t   IETF_NO_IRD_ORD :\n\t\t\t\t   cm_node->ord_size;\n\t}\n\tctrl_ird |= IETF_PEER_TO_PEER;\n\n\tswitch (mpa_key) {\n\tcase MPA_KEY_REQUEST:\n\t\tctrl_ord |= IETF_RDMA0_WRITE;\n\t\tctrl_ord |= IETF_RDMA0_READ;\n\t\tbreak;\n\tcase MPA_KEY_REPLY:\n\t\tswitch (cm_node->send_rdma0_op) {\n\t\tcase SEND_RDMA_WRITE_ZERO:\n\t\t\tctrl_ord |= IETF_RDMA0_WRITE;\n\t\t\tbreak;\n\t\tcase SEND_RDMA_READ_ZERO:\n\t\t\tctrl_ord |= IETF_RDMA0_READ;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtr_msg->ctrl_ird = htons(ctrl_ird);\n\trtr_msg->ctrl_ord = htons(ctrl_ord);\n}\n\n \nstatic int irdma_cm_build_mpa_frame(struct irdma_cm_node *cm_node,\n\t\t\t\t    struct irdma_kmem_info *mpa, u8 mpa_key)\n{\n\tint hdr_len = 0;\n\n\tswitch (cm_node->mpa_frame_rev) {\n\tcase IETF_MPA_V1:\n\t\thdr_len = sizeof(struct ietf_mpa_v1);\n\t\tirdma_build_mpa_v1(cm_node, mpa->addr, mpa_key);\n\t\tbreak;\n\tcase IETF_MPA_V2:\n\t\thdr_len = sizeof(struct ietf_mpa_v2);\n\t\tirdma_build_mpa_v2(cm_node, mpa->addr, mpa_key);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn hdr_len;\n}\n\n \nstatic int irdma_send_mpa_request(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\n\tcm_node->mpa_hdr.addr = &cm_node->mpa_v2_frame;\n\tcm_node->mpa_hdr.size = irdma_cm_build_mpa_frame(cm_node,\n\t\t\t\t\t\t\t &cm_node->mpa_hdr,\n\t\t\t\t\t\t\t MPA_KEY_REQUEST);\n\tif (!cm_node->mpa_hdr.size) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: mpa size = %d\\n\", cm_node->mpa_hdr.size);\n\t\treturn -EINVAL;\n\t}\n\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, NULL,\n\t\t\t\t\t\t&cm_node->mpa_hdr,\n\t\t\t\t\t\t&cm_node->pdata, SET_ACK);\n\tif (!sqbuf)\n\t\treturn -ENOMEM;\n\n\treturn irdma_schedule_cm_timer(cm_node, sqbuf, IRDMA_TIMER_TYPE_SEND, 1,\n\t\t\t\t       0);\n}\n\n \nstatic int irdma_send_mpa_reject(struct irdma_cm_node *cm_node,\n\t\t\t\t const void *pdata, u8 plen)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tstruct irdma_mpa_priv_info priv_info;\n\n\tcm_node->mpa_hdr.addr = &cm_node->mpa_v2_frame;\n\tcm_node->mpa_hdr.size = irdma_cm_build_mpa_frame(cm_node,\n\t\t\t\t\t\t\t &cm_node->mpa_hdr,\n\t\t\t\t\t\t\t MPA_KEY_REPLY);\n\n\tcm_node->mpa_frame.flags |= IETF_MPA_FLAGS_REJECT;\n\tpriv_info.addr = pdata;\n\tpriv_info.size = plen;\n\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, NULL,\n\t\t\t\t\t\t&cm_node->mpa_hdr, &priv_info,\n\t\t\t\t\t\tSET_ACK | SET_FIN);\n\tif (!sqbuf)\n\t\treturn -ENOMEM;\n\n\tcm_node->state = IRDMA_CM_STATE_FIN_WAIT1;\n\n\treturn irdma_schedule_cm_timer(cm_node, sqbuf, IRDMA_TIMER_TYPE_SEND, 1,\n\t\t\t\t       0);\n}\n\n \nstatic int irdma_negotiate_mpa_v2_ird_ord(struct irdma_cm_node *cm_node,\n\t\t\t\t\t  u8 *buf)\n{\n\tstruct ietf_mpa_v2 *mpa_v2_frame;\n\tstruct ietf_rtr_msg *rtr_msg;\n\tu16 ird_size;\n\tu16 ord_size;\n\tu16 ctrl_ord;\n\tu16 ctrl_ird;\n\n\tmpa_v2_frame = (struct ietf_mpa_v2 *)buf;\n\trtr_msg = &mpa_v2_frame->rtr_msg;\n\n\t \n\tctrl_ord = ntohs(rtr_msg->ctrl_ord);\n\tctrl_ird = ntohs(rtr_msg->ctrl_ird);\n\tird_size = ctrl_ird & IETF_NO_IRD_ORD;\n\tord_size = ctrl_ord & IETF_NO_IRD_ORD;\n\n\tif (!(ctrl_ird & IETF_PEER_TO_PEER))\n\t\treturn -EOPNOTSUPP;\n\n\tif (ird_size == IETF_NO_IRD_ORD || ord_size == IETF_NO_IRD_ORD) {\n\t\tcm_node->mpav2_ird_ord = IETF_NO_IRD_ORD;\n\t\tgoto negotiate_done;\n\t}\n\n\tif (cm_node->state != IRDMA_CM_STATE_MPAREQ_SENT) {\n\t\t \n\t\tif (!ord_size && (ctrl_ord & IETF_RDMA0_READ))\n\t\t\tcm_node->ird_size = 1;\n\t\tif (cm_node->ord_size > ird_size)\n\t\t\tcm_node->ord_size = ird_size;\n\t} else {\n\t\t \n\t\tif (!ird_size && (ctrl_ord & IETF_RDMA0_READ))\n\t\t\t \n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (cm_node->ord_size > ird_size)\n\t\t\tcm_node->ord_size = ird_size;\n\n\t\tif (cm_node->ird_size < ord_size)\n\t\t \n\t\t\treturn -EINVAL;\n\t}\n\nnegotiate_done:\n\tif (ctrl_ord & IETF_RDMA0_READ)\n\t\tcm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\n\telse if (ctrl_ord & IETF_RDMA0_WRITE)\n\t\tcm_node->send_rdma0_op = SEND_RDMA_WRITE_ZERO;\n\telse\n\t\t \n\t\treturn -EOPNOTSUPP;\n\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: MPAV2 Negotiated ORD: %d, IRD: %d\\n\",\n\t\t  cm_node->ord_size, cm_node->ird_size);\n\ttrace_irdma_negotiate_mpa_v2(cm_node);\n\treturn 0;\n}\n\n \nstatic int irdma_parse_mpa(struct irdma_cm_node *cm_node, u8 *buf, u32 *type,\n\t\t\t   u32 len)\n{\n\tstruct ietf_mpa_v1 *mpa_frame;\n\tint mpa_hdr_len, priv_data_len, ret;\n\n\t*type = IRDMA_MPA_REQUEST_ACCEPT;\n\n\tif (len < sizeof(struct ietf_mpa_v1)) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: ietf buffer small (%x)\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tmpa_frame = (struct ietf_mpa_v1 *)buf;\n\tmpa_hdr_len = sizeof(struct ietf_mpa_v1);\n\tpriv_data_len = ntohs(mpa_frame->priv_data_len);\n\n\tif (priv_data_len > IETF_MAX_PRIV_DATA_LEN) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: private_data too big %d\\n\", priv_data_len);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (mpa_frame->rev != IETF_MPA_V1 && mpa_frame->rev != IETF_MPA_V2) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: unsupported mpa rev = %d\\n\", mpa_frame->rev);\n\t\treturn -EINVAL;\n\t}\n\n\tif (mpa_frame->rev > cm_node->mpa_frame_rev) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev, \"CM: rev %d\\n\",\n\t\t\t  mpa_frame->rev);\n\t\treturn -EINVAL;\n\t}\n\n\tcm_node->mpa_frame_rev = mpa_frame->rev;\n\tif (cm_node->state != IRDMA_CM_STATE_MPAREQ_SENT) {\n\t\tif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REQ,\n\t\t\t   IETF_MPA_KEY_SIZE)) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: Unexpected MPA Key received\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (memcmp(mpa_frame->key, IEFT_MPA_KEY_REP,\n\t\t\t   IETF_MPA_KEY_SIZE)) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: Unexpected MPA Key received\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (priv_data_len + mpa_hdr_len > len) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: ietf buffer len(%x + %x != %x)\\n\",\n\t\t\t  priv_data_len, mpa_hdr_len, len);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tif (len > IRDMA_MAX_CM_BUF) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: ietf buffer large len = %d\\n\", len);\n\t\treturn -EOVERFLOW;\n\t}\n\n\tswitch (mpa_frame->rev) {\n\tcase IETF_MPA_V2:\n\t\tmpa_hdr_len += IETF_RTR_MSG_SIZE;\n\t\tret = irdma_negotiate_mpa_v2_ird_ord(cm_node, buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IETF_MPA_V1:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmemcpy(cm_node->pdata_buf, buf + mpa_hdr_len, priv_data_len);\n\tcm_node->pdata.size = priv_data_len;\n\n\tif (mpa_frame->flags & IETF_MPA_FLAGS_REJECT)\n\t\t*type = IRDMA_MPA_REQUEST_REJECT;\n\n\tif (mpa_frame->flags & IETF_MPA_FLAGS_MARKERS)\n\t\tcm_node->snd_mark_en = true;\n\n\treturn 0;\n}\n\n \nint irdma_schedule_cm_timer(struct irdma_cm_node *cm_node,\n\t\t\t    struct irdma_puda_buf *sqbuf,\n\t\t\t    enum irdma_timer_type type, int send_retrans,\n\t\t\t    int close_when_complete)\n{\n\tstruct irdma_sc_vsi *vsi = &cm_node->iwdev->vsi;\n\tstruct irdma_cm_core *cm_core = cm_node->cm_core;\n\tstruct irdma_timer_entry *new_send;\n\tu32 was_timer_set;\n\tunsigned long flags;\n\n\tnew_send = kzalloc(sizeof(*new_send), GFP_ATOMIC);\n\tif (!new_send) {\n\t\tif (type != IRDMA_TIMER_TYPE_CLOSE)\n\t\t\tirdma_free_sqbuf(vsi, sqbuf);\n\t\treturn -ENOMEM;\n\t}\n\n\tnew_send->retrycount = IRDMA_DEFAULT_RETRYS;\n\tnew_send->retranscount = IRDMA_DEFAULT_RETRANS;\n\tnew_send->sqbuf = sqbuf;\n\tnew_send->timetosend = jiffies;\n\tnew_send->type = type;\n\tnew_send->send_retrans = send_retrans;\n\tnew_send->close_when_complete = close_when_complete;\n\n\tif (type == IRDMA_TIMER_TYPE_CLOSE) {\n\t\tnew_send->timetosend += (HZ / 10);\n\t\tif (cm_node->close_entry) {\n\t\t\tkfree(new_send);\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: already close entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcm_node->close_entry = new_send;\n\t} else {  \n\t\tspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\n\t\tcm_node->send_entry = new_send;\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\n\t\tnew_send->timetosend = jiffies + IRDMA_RETRY_TIMEOUT;\n\n\t\trefcount_inc(&sqbuf->refcount);\n\t\tirdma_puda_send_buf(vsi->ilq, sqbuf);\n\t\tif (!send_retrans) {\n\t\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\t\tif (close_when_complete)\n\t\t\t\tirdma_rem_ref_cm_node(cm_node);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&cm_core->ht_lock, flags);\n\twas_timer_set = timer_pending(&cm_core->tcp_timer);\n\n\tif (!was_timer_set) {\n\t\tcm_core->tcp_timer.expires = new_send->timetosend;\n\t\tadd_timer(&cm_core->tcp_timer);\n\t}\n\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void irdma_retrans_expired(struct irdma_cm_node *cm_node)\n{\n\tenum irdma_cm_node_state state = cm_node->state;\n\n\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\tswitch (state) {\n\tcase IRDMA_CM_STATE_SYN_RCVD:\n\tcase IRDMA_CM_STATE_CLOSING:\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tdefault:\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t\tirdma_create_event(cm_node, IRDMA_CM_EVENT_ABORTED);\n\t\tbreak;\n\t}\n}\n\n \nstatic void irdma_handle_close_entry(struct irdma_cm_node *cm_node,\n\t\t\t\t     u32 rem_node)\n{\n\tstruct irdma_timer_entry *close_entry = cm_node->close_entry;\n\tstruct irdma_qp *iwqp;\n\tunsigned long flags;\n\n\tif (!close_entry)\n\t\treturn;\n\tiwqp = (struct irdma_qp *)close_entry->sqbuf;\n\tif (iwqp) {\n\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\tif (iwqp->cm_id) {\n\t\t\tiwqp->hw_tcp_state = IRDMA_TCP_STATE_CLOSED;\n\t\t\tiwqp->hw_iwarp_state = IRDMA_QP_STATE_ERROR;\n\t\t\tiwqp->last_aeq = IRDMA_AE_RESET_SENT;\n\t\t\tiwqp->ibqp_state = IB_QPS_ERR;\n\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\tirdma_cm_disconn(iwqp);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t}\n\t} else if (rem_node) {\n\t\t \n\t\tirdma_rem_ref_cm_node(cm_node);\n\t}\n\n\tkfree(close_entry);\n\tcm_node->close_entry = NULL;\n}\n\n \nstatic void irdma_cm_timer_tick(struct timer_list *t)\n{\n\tunsigned long nexttimeout = jiffies + IRDMA_LONG_TIME;\n\tstruct irdma_cm_node *cm_node;\n\tstruct irdma_timer_entry *send_entry, *close_entry;\n\tstruct list_head *list_core_temp;\n\tstruct list_head *list_node;\n\tstruct irdma_cm_core *cm_core = from_timer(cm_core, t, tcp_timer);\n\tstruct irdma_sc_vsi *vsi;\n\tu32 settimer = 0;\n\tunsigned long timetosend;\n\tunsigned long flags;\n\tstruct list_head timer_list;\n\n\tINIT_LIST_HEAD(&timer_list);\n\n\trcu_read_lock();\n\tirdma_timer_list_prep(cm_core, &timer_list);\n\trcu_read_unlock();\n\n\tlist_for_each_safe (list_node, list_core_temp, &timer_list) {\n\t\tcm_node = container_of(list_node, struct irdma_cm_node,\n\t\t\t\t       timer_entry);\n\t\tclose_entry = cm_node->close_entry;\n\n\t\tif (close_entry) {\n\t\t\tif (time_after(close_entry->timetosend, jiffies)) {\n\t\t\t\tif (nexttimeout > close_entry->timetosend ||\n\t\t\t\t    !settimer) {\n\t\t\t\t\tnexttimeout = close_entry->timetosend;\n\t\t\t\t\tsettimer = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tirdma_handle_close_entry(cm_node, 1);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\n\n\t\tsend_entry = cm_node->send_entry;\n\t\tif (!send_entry)\n\t\t\tgoto done;\n\t\tif (time_after(send_entry->timetosend, jiffies)) {\n\t\t\tif (cm_node->state != IRDMA_CM_STATE_OFFLOADED) {\n\t\t\t\tif (nexttimeout > send_entry->timetosend ||\n\t\t\t\t    !settimer) {\n\t\t\t\t\tnexttimeout = send_entry->timetosend;\n\t\t\t\t\tsettimer = 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tirdma_free_retrans_entry(cm_node);\n\t\t\t}\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (cm_node->state == IRDMA_CM_STATE_OFFLOADED ||\n\t\t    cm_node->state == IRDMA_CM_STATE_CLOSED) {\n\t\t\tirdma_free_retrans_entry(cm_node);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (!send_entry->retranscount || !send_entry->retrycount) {\n\t\t\tirdma_free_retrans_entry(cm_node);\n\n\t\t\tspin_unlock_irqrestore(&cm_node->retrans_list_lock,\n\t\t\t\t\t       flags);\n\t\t\tirdma_retrans_expired(cm_node);\n\t\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\t\tspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\n\t\t\tgoto done;\n\t\t}\n\t\tspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\n\n\t\tvsi = &cm_node->iwdev->vsi;\n\t\tif (!cm_node->ack_rcvd) {\n\t\t\trefcount_inc(&send_entry->sqbuf->refcount);\n\t\t\tirdma_puda_send_buf(vsi->ilq, send_entry->sqbuf);\n\t\t\tcm_node->cm_core->stats_pkt_retrans++;\n\t\t}\n\n\t\tspin_lock_irqsave(&cm_node->retrans_list_lock, flags);\n\t\tif (send_entry->send_retrans) {\n\t\t\tsend_entry->retranscount--;\n\t\t\ttimetosend = (IRDMA_RETRY_TIMEOUT <<\n\t\t\t\t      (IRDMA_DEFAULT_RETRANS -\n\t\t\t\t       send_entry->retranscount));\n\n\t\t\tsend_entry->timetosend = jiffies +\n\t\t\t    min(timetosend, IRDMA_MAX_TIMEOUT);\n\t\t\tif (nexttimeout > send_entry->timetosend || !settimer) {\n\t\t\t\tnexttimeout = send_entry->timetosend;\n\t\t\t\tsettimer = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tint close_when_complete;\n\n\t\t\tclose_when_complete = send_entry->close_when_complete;\n\t\t\tirdma_free_retrans_entry(cm_node);\n\t\t\tif (close_when_complete)\n\t\t\t\tirdma_rem_ref_cm_node(cm_node);\n\t\t}\ndone:\n\t\tspin_unlock_irqrestore(&cm_node->retrans_list_lock, flags);\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t}\n\n\tif (settimer) {\n\t\tspin_lock_irqsave(&cm_core->ht_lock, flags);\n\t\tif (!timer_pending(&cm_core->tcp_timer)) {\n\t\t\tcm_core->tcp_timer.expires = nexttimeout;\n\t\t\tadd_timer(&cm_core->tcp_timer);\n\t\t}\n\t\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n\t}\n}\n\n \nint irdma_send_syn(struct irdma_cm_node *cm_node, u32 sendack)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tint flags = SET_SYN;\n\tchar optionsbuf[sizeof(struct option_mss) +\n\t\t\tsizeof(struct option_windowscale) +\n\t\t\tsizeof(struct option_base) + TCP_OPTIONS_PADDING];\n\tstruct irdma_kmem_info opts;\n\tint optionssize = 0;\n\t \n\tunion all_known_options *options;\n\n\topts.addr = optionsbuf;\n\tif (!cm_node)\n\t\treturn -EINVAL;\n\n\toptions = (union all_known_options *)&optionsbuf[optionssize];\n\toptions->mss.optionnum = OPTION_NUM_MSS;\n\toptions->mss.len = sizeof(struct option_mss);\n\toptions->mss.mss = htons(cm_node->tcp_cntxt.mss);\n\toptionssize += sizeof(struct option_mss);\n\n\toptions = (union all_known_options *)&optionsbuf[optionssize];\n\toptions->windowscale.optionnum = OPTION_NUM_WINDOW_SCALE;\n\toptions->windowscale.len = sizeof(struct option_windowscale);\n\toptions->windowscale.shiftcount = cm_node->tcp_cntxt.rcv_wscale;\n\toptionssize += sizeof(struct option_windowscale);\n\toptions = (union all_known_options *)&optionsbuf[optionssize];\n\toptions->eol = OPTION_NUM_EOL;\n\toptionssize += 1;\n\n\tif (sendack)\n\t\tflags |= SET_ACK;\n\n\topts.size = optionssize;\n\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, &opts, NULL, NULL,\n\t\t\t\t\t\tflags);\n\tif (!sqbuf)\n\t\treturn -ENOMEM;\n\n\treturn irdma_schedule_cm_timer(cm_node, sqbuf, IRDMA_TIMER_TYPE_SEND, 1,\n\t\t\t\t       0);\n}\n\n \nvoid irdma_send_ack(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\tstruct irdma_sc_vsi *vsi = &cm_node->iwdev->vsi;\n\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, NULL, NULL, NULL,\n\t\t\t\t\t\tSET_ACK);\n\tif (sqbuf)\n\t\tirdma_puda_send_buf(vsi->ilq, sqbuf);\n}\n\n \nstatic int irdma_send_fin(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_puda_buf *sqbuf;\n\n\tsqbuf = cm_node->cm_core->form_cm_frame(cm_node, NULL, NULL, NULL,\n\t\t\t\t\t\tSET_ACK | SET_FIN);\n\tif (!sqbuf)\n\t\treturn -ENOMEM;\n\n\treturn irdma_schedule_cm_timer(cm_node, sqbuf, IRDMA_TIMER_TYPE_SEND, 1,\n\t\t\t\t       0);\n}\n\n \nstatic struct irdma_cm_listener *\nirdma_find_listener(struct irdma_cm_core *cm_core, u32 *dst_addr, bool ipv4,\n\t\t    u16 dst_port, u16 vlan_id,\n\t\t    enum irdma_cm_listener_state listener_state)\n{\n\tstruct irdma_cm_listener *listen_node;\n\tstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\n\tu32 listen_addr[4];\n\tu16 listen_port;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&cm_core->listen_list_lock, flags);\n\tlist_for_each_entry (listen_node, &cm_core->listen_list, list) {\n\t\tmemcpy(listen_addr, listen_node->loc_addr, sizeof(listen_addr));\n\t\tlisten_port = listen_node->loc_port;\n\t\tif (listen_node->ipv4 != ipv4 || listen_port != dst_port ||\n\t\t    !(listener_state & listen_node->listener_state))\n\t\t\tcontinue;\n\t\t \n\t\tif (!memcmp(listen_addr, ip_zero, sizeof(listen_addr)) ||\n\t\t    (!memcmp(listen_addr, dst_addr, sizeof(listen_addr)) &&\n\t\t     vlan_id == listen_node->vlan_id)) {\n\t\t\trefcount_inc(&listen_node->refcnt);\n\t\t\tspin_unlock_irqrestore(&cm_core->listen_list_lock,\n\t\t\t\t\t       flags);\n\t\t\ttrace_irdma_find_listener(listen_node);\n\t\t\treturn listen_node;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\n\n\treturn NULL;\n}\n\n \nstatic int irdma_del_multiple_qhash(struct irdma_device *iwdev,\n\t\t\t\t    struct irdma_cm_info *cm_info,\n\t\t\t\t    struct irdma_cm_listener *cm_parent_listen_node)\n{\n\tstruct irdma_cm_listener *child_listen_node;\n\tstruct list_head *pos, *tpos;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&iwdev->cm_core.listen_list_lock, flags);\n\tlist_for_each_safe (pos, tpos,\n\t\t\t    &cm_parent_listen_node->child_listen_list) {\n\t\tchild_listen_node = list_entry(pos, struct irdma_cm_listener,\n\t\t\t\t\t       child_listen_list);\n\t\tif (child_listen_node->ipv4)\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: removing child listen for IP=%pI4, port=%d, vlan=%d\\n\",\n\t\t\t\t  child_listen_node->loc_addr,\n\t\t\t\t  child_listen_node->loc_port,\n\t\t\t\t  child_listen_node->vlan_id);\n\t\telse\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: removing child listen for IP=%pI6, port=%d, vlan=%d\\n\",\n\t\t\t\t  child_listen_node->loc_addr,\n\t\t\t\t  child_listen_node->loc_port,\n\t\t\t\t  child_listen_node->vlan_id);\n\t\ttrace_irdma_del_multiple_qhash(child_listen_node);\n\t\tlist_del(pos);\n\t\tmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\n\t\t       sizeof(cm_info->loc_addr));\n\t\tcm_info->vlan_id = child_listen_node->vlan_id;\n\t\tif (child_listen_node->qhash_set) {\n\t\t\tret = irdma_manage_qhash(iwdev, cm_info,\n\t\t\t\t\t\t IRDMA_QHASH_TYPE_TCP_SYN,\n\t\t\t\t\t\t IRDMA_QHASH_MANAGE_TYPE_DELETE,\n\t\t\t\t\t\t NULL, false);\n\t\t\tchild_listen_node->qhash_set = false;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: Child listen node freed = %p\\n\",\n\t\t\t  child_listen_node);\n\t\tkfree(child_listen_node);\n\t\tcm_parent_listen_node->cm_core->stats_listen_nodes_destroyed++;\n\t}\n\tspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\n\n\treturn ret;\n}\n\nstatic u8 irdma_iw_get_vlan_prio(u32 *loc_addr, u8 prio, bool ipv4)\n{\n\tstruct net_device *ndev = NULL;\n\n\trcu_read_lock();\n\tif (ipv4) {\n\t\tndev = ip_dev_find(&init_net, htonl(loc_addr[0]));\n\t} else if (IS_ENABLED(CONFIG_IPV6)) {\n\t\tstruct net_device *ip_dev;\n\t\tstruct in6_addr laddr6;\n\n\t\tirdma_copy_ip_htonl(laddr6.in6_u.u6_addr32, loc_addr);\n\n\t\tfor_each_netdev_rcu (&init_net, ip_dev) {\n\t\t\tif (ipv6_chk_addr(&init_net, &laddr6, ip_dev, 1)) {\n\t\t\t\tndev = ip_dev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ndev)\n\t\tgoto done;\n\tif (is_vlan_dev(ndev))\n\t\tprio = (vlan_dev_get_egress_qos_mask(ndev, prio) & VLAN_PRIO_MASK)\n\t\t\t>> VLAN_PRIO_SHIFT;\n\tif (ipv4)\n\t\tdev_put(ndev);\n\ndone:\n\trcu_read_unlock();\n\n\treturn prio;\n}\n\n \nvoid irdma_get_vlan_mac_ipv6(u32 *addr, u16 *vlan_id, u8 *mac)\n{\n\tstruct net_device *ip_dev = NULL;\n\tstruct in6_addr laddr6;\n\n\tif (!IS_ENABLED(CONFIG_IPV6))\n\t\treturn;\n\n\tirdma_copy_ip_htonl(laddr6.in6_u.u6_addr32, addr);\n\tif (vlan_id)\n\t\t*vlan_id = 0xFFFF;\t \n\tif (mac)\n\t\teth_zero_addr(mac);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu (&init_net, ip_dev) {\n\t\tif (ipv6_chk_addr(&init_net, &laddr6, ip_dev, 1)) {\n\t\t\tif (vlan_id)\n\t\t\t\t*vlan_id = rdma_vlan_dev_vlan_id(ip_dev);\n\t\t\tif (ip_dev->dev_addr && mac)\n\t\t\t\tether_addr_copy(mac, ip_dev->dev_addr);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\n \nu16 irdma_get_vlan_ipv4(u32 *addr)\n{\n\tstruct net_device *netdev;\n\tu16 vlan_id = 0xFFFF;\n\n\tnetdev = ip_dev_find(&init_net, htonl(addr[0]));\n\tif (netdev) {\n\t\tvlan_id = rdma_vlan_dev_vlan_id(netdev);\n\t\tdev_put(netdev);\n\t}\n\n\treturn vlan_id;\n}\n\n \nstatic int irdma_add_mqh_6(struct irdma_device *iwdev,\n\t\t\t   struct irdma_cm_info *cm_info,\n\t\t\t   struct irdma_cm_listener *cm_parent_listen_node)\n{\n\tstruct net_device *ip_dev;\n\tstruct inet6_dev *idev;\n\tstruct inet6_ifaddr *ifp, *tmp;\n\tstruct irdma_cm_listener *child_listen_node;\n\tunsigned long flags;\n\tint ret = 0;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, ip_dev) {\n\t\tif (!(ip_dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (((rdma_vlan_dev_vlan_id(ip_dev) >= VLAN_N_VID) ||\n\t\t     (rdma_vlan_dev_real_dev(ip_dev) != iwdev->netdev)) &&\n\t\t    ip_dev != iwdev->netdev)\n\t\t\tcontinue;\n\n\t\tidev = __in6_dev_get(ip_dev);\n\t\tif (!idev) {\n\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: idev == NULL\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tlist_for_each_entry_safe (ifp, tmp, &idev->addr_list, if_list) {\n\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: IP=%pI6, vlan_id=%d, MAC=%pM\\n\",\n\t\t\t\t  &ifp->addr, rdma_vlan_dev_vlan_id(ip_dev),\n\t\t\t\t  ip_dev->dev_addr);\n\t\t\tchild_listen_node = kzalloc(sizeof(*child_listen_node), GFP_KERNEL);\n\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: Allocating child listener %p\\n\",\n\t\t\t\t  child_listen_node);\n\t\t\tif (!child_listen_node) {\n\t\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: listener memory allocation\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tcm_info->vlan_id = rdma_vlan_dev_vlan_id(ip_dev);\n\t\t\tcm_parent_listen_node->vlan_id = cm_info->vlan_id;\n\t\t\tmemcpy(child_listen_node, cm_parent_listen_node,\n\t\t\t       sizeof(*child_listen_node));\n\t\t\tirdma_copy_ip_ntohl(child_listen_node->loc_addr,\n\t\t\t\t\t    ifp->addr.in6_u.u6_addr32);\n\t\t\tmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\n\t\t\t       sizeof(cm_info->loc_addr));\n\t\t\tif (!iwdev->vsi.dscp_mode)\n\t\t\t\tcm_info->user_pri =\n\t\t\t\tirdma_iw_get_vlan_prio(child_listen_node->loc_addr,\n\t\t\t\t\t\t       cm_info->user_pri,\n\t\t\t\t\t\t       false);\n\n\t\t\tret = irdma_manage_qhash(iwdev, cm_info,\n\t\t\t\t\t\t IRDMA_QHASH_TYPE_TCP_SYN,\n\t\t\t\t\t\t IRDMA_QHASH_MANAGE_TYPE_ADD,\n\t\t\t\t\t\t NULL, true);\n\t\t\tif (ret) {\n\t\t\t\tkfree(child_listen_node);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttrace_irdma_add_mqh_6(iwdev, child_listen_node,\n\t\t\t\t\t      ip_dev->dev_addr);\n\n\t\t\tchild_listen_node->qhash_set = true;\n\t\t\tspin_lock_irqsave(&iwdev->cm_core.listen_list_lock, flags);\n\t\t\tlist_add(&child_listen_node->child_listen_list,\n\t\t\t\t &cm_parent_listen_node->child_listen_list);\n\t\t\tspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\n\t\t\tcm_parent_listen_node->cm_core->stats_listen_nodes_created++;\n\t\t}\n\t}\nexit:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\n \nstatic int irdma_add_mqh_4(struct irdma_device *iwdev,\n\t\t\t   struct irdma_cm_info *cm_info,\n\t\t\t   struct irdma_cm_listener *cm_parent_listen_node)\n{\n\tstruct net_device *ip_dev;\n\tstruct in_device *idev;\n\tstruct irdma_cm_listener *child_listen_node;\n\tunsigned long flags;\n\tconst struct in_ifaddr *ifa;\n\tint ret = 0;\n\n\trtnl_lock();\n\tfor_each_netdev(&init_net, ip_dev) {\n\t\tif (!(ip_dev->flags & IFF_UP))\n\t\t\tcontinue;\n\n\t\tif (((rdma_vlan_dev_vlan_id(ip_dev) >= VLAN_N_VID) ||\n\t\t     (rdma_vlan_dev_real_dev(ip_dev) != iwdev->netdev)) &&\n\t\t    ip_dev != iwdev->netdev)\n\t\t\tcontinue;\n\n\t\tidev = in_dev_get(ip_dev);\n\t\tif (!idev)\n\t\t\tcontinue;\n\n\t\tin_dev_for_each_ifa_rtnl(ifa, idev) {\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: Allocating child CM Listener forIP=%pI4, vlan_id=%d, MAC=%pM\\n\",\n\t\t\t\t  &ifa->ifa_address, rdma_vlan_dev_vlan_id(ip_dev),\n\t\t\t\t  ip_dev->dev_addr);\n\t\t\tchild_listen_node = kzalloc(sizeof(*child_listen_node), GFP_KERNEL);\n\t\t\tcm_parent_listen_node->cm_core->stats_listen_nodes_created++;\n\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: Allocating child listener %p\\n\",\n\t\t\t\t  child_listen_node);\n\t\t\tif (!child_listen_node) {\n\t\t\t\tibdev_dbg(&iwdev->ibdev, \"CM: listener memory allocation\\n\");\n\t\t\t\tin_dev_put(idev);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tcm_info->vlan_id = rdma_vlan_dev_vlan_id(ip_dev);\n\t\t\tcm_parent_listen_node->vlan_id = cm_info->vlan_id;\n\t\t\tmemcpy(child_listen_node, cm_parent_listen_node,\n\t\t\t       sizeof(*child_listen_node));\n\t\t\tchild_listen_node->loc_addr[0] =\n\t\t\t\tntohl(ifa->ifa_address);\n\t\t\tmemcpy(cm_info->loc_addr, child_listen_node->loc_addr,\n\t\t\t       sizeof(cm_info->loc_addr));\n\t\t\tif (!iwdev->vsi.dscp_mode)\n\t\t\t\tcm_info->user_pri =\n\t\t\t\tirdma_iw_get_vlan_prio(child_listen_node->loc_addr,\n\t\t\t\t\t\t       cm_info->user_pri,\n\t\t\t\t\t\t       true);\n\t\t\tret = irdma_manage_qhash(iwdev, cm_info,\n\t\t\t\t\t\t IRDMA_QHASH_TYPE_TCP_SYN,\n\t\t\t\t\t\t IRDMA_QHASH_MANAGE_TYPE_ADD,\n\t\t\t\t\t\t NULL, true);\n\t\t\tif (ret) {\n\t\t\t\tkfree(child_listen_node);\n\t\t\t\tcm_parent_listen_node->cm_core\n\t\t\t\t\t->stats_listen_nodes_created--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\ttrace_irdma_add_mqh_4(iwdev, child_listen_node,\n\t\t\t\t\t      ip_dev->dev_addr);\n\n\t\t\tchild_listen_node->qhash_set = true;\n\t\t\tspin_lock_irqsave(&iwdev->cm_core.listen_list_lock,\n\t\t\t\t\t  flags);\n\t\t\tlist_add(&child_listen_node->child_listen_list,\n\t\t\t\t &cm_parent_listen_node->child_listen_list);\n\t\t\tspin_unlock_irqrestore(&iwdev->cm_core.listen_list_lock, flags);\n\t\t}\n\t\tin_dev_put(idev);\n\t}\nexit:\n\trtnl_unlock();\n\n\treturn ret;\n}\n\n \nstatic int irdma_add_mqh(struct irdma_device *iwdev,\n\t\t\t struct irdma_cm_info *cm_info,\n\t\t\t struct irdma_cm_listener *cm_listen_node)\n{\n\tif (cm_info->ipv4)\n\t\treturn irdma_add_mqh_4(iwdev, cm_info, cm_listen_node);\n\telse\n\t\treturn irdma_add_mqh_6(iwdev, cm_info, cm_listen_node);\n}\n\n \nstatic void irdma_reset_list_prep(struct irdma_cm_core *cm_core,\n\t\t\t\t  struct irdma_cm_listener *listener,\n\t\t\t\t  struct list_head *reset_list)\n{\n\tstruct irdma_cm_node *cm_node;\n\tint bkt;\n\n\thash_for_each_rcu(cm_core->cm_hash_tbl, bkt, cm_node, list) {\n\t\tif (cm_node->listener == listener &&\n\t\t    !cm_node->accelerated &&\n\t\t    refcount_inc_not_zero(&cm_node->refcnt))\n\t\t\tlist_add(&cm_node->reset_entry, reset_list);\n\t}\n}\n\n \nstatic int irdma_dec_refcnt_listen(struct irdma_cm_core *cm_core,\n\t\t\t\t   struct irdma_cm_listener *listener,\n\t\t\t\t   int free_hanging_nodes, bool apbvt_del)\n{\n\tint err;\n\tstruct list_head *list_pos;\n\tstruct list_head *list_temp;\n\tstruct irdma_cm_node *cm_node;\n\tstruct list_head reset_list;\n\tstruct irdma_cm_info nfo;\n\tenum irdma_cm_node_state old_state;\n\tunsigned long flags;\n\n\ttrace_irdma_dec_refcnt_listen(listener, __builtin_return_address(0));\n\t \n\tINIT_LIST_HEAD(&reset_list);\n\tif (free_hanging_nodes) {\n\t\trcu_read_lock();\n\t\tirdma_reset_list_prep(cm_core, listener, &reset_list);\n\t\trcu_read_unlock();\n\t}\n\n\tlist_for_each_safe (list_pos, list_temp, &reset_list) {\n\t\tcm_node = container_of(list_pos, struct irdma_cm_node,\n\t\t\t\t       reset_entry);\n\t\tif (cm_node->state >= IRDMA_CM_STATE_FIN_WAIT1) {\n\t\t\tirdma_rem_ref_cm_node(cm_node);\n\t\t\tcontinue;\n\t\t}\n\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\terr = irdma_send_reset(cm_node);\n\t\tif (err) {\n\t\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: send reset failed\\n\");\n\t\t} else {\n\t\t\told_state = cm_node->state;\n\t\t\tcm_node->state = IRDMA_CM_STATE_LISTENER_DESTROYED;\n\t\t\tif (old_state != IRDMA_CM_STATE_MPAREQ_RCVD)\n\t\t\t\tirdma_rem_ref_cm_node(cm_node);\n\t\t}\n\t}\n\n\tif (refcount_dec_and_test(&listener->refcnt)) {\n\t\tspin_lock_irqsave(&cm_core->listen_list_lock, flags);\n\t\tlist_del(&listener->list);\n\t\tspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\n\n\t\tif (apbvt_del)\n\t\t\tirdma_del_apbvt(listener->iwdev,\n\t\t\t\t\tlistener->apbvt_entry);\n\t\tmemcpy(nfo.loc_addr, listener->loc_addr, sizeof(nfo.loc_addr));\n\t\tnfo.loc_port = listener->loc_port;\n\t\tnfo.ipv4 = listener->ipv4;\n\t\tnfo.vlan_id = listener->vlan_id;\n\t\tnfo.user_pri = listener->user_pri;\n\t\tnfo.qh_qpid = listener->iwdev->vsi.ilq->qp_id;\n\n\t\tif (!list_empty(&listener->child_listen_list)) {\n\t\t\tirdma_del_multiple_qhash(listener->iwdev, &nfo,\n\t\t\t\t\t\t listener);\n\t\t} else {\n\t\t\tif (listener->qhash_set)\n\t\t\t\tirdma_manage_qhash(listener->iwdev,\n\t\t\t\t\t\t   &nfo,\n\t\t\t\t\t\t   IRDMA_QHASH_TYPE_TCP_SYN,\n\t\t\t\t\t\t   IRDMA_QHASH_MANAGE_TYPE_DELETE,\n\t\t\t\t\t\t   NULL, false);\n\t\t}\n\n\t\tcm_core->stats_listen_destroyed++;\n\t\tcm_core->stats_listen_nodes_destroyed++;\n\t\tibdev_dbg(&listener->iwdev->ibdev,\n\t\t\t  \"CM: loc_port=0x%04x loc_addr=%pI4 cm_listen_node=%p cm_id=%p qhash_set=%d vlan_id=%d apbvt_del=%d\\n\",\n\t\t\t  listener->loc_port, listener->loc_addr, listener,\n\t\t\t  listener->cm_id, listener->qhash_set,\n\t\t\t  listener->vlan_id, apbvt_del);\n\t\tkfree(listener);\n\t\tlistener = NULL;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\n \nstatic int irdma_cm_del_listen(struct irdma_cm_core *cm_core,\n\t\t\t       struct irdma_cm_listener *listener,\n\t\t\t       bool apbvt_del)\n{\n\tlistener->listener_state = IRDMA_CM_LISTENER_PASSIVE_STATE;\n\tlistener->cm_id = NULL;\n\n\treturn irdma_dec_refcnt_listen(cm_core, listener, 1, apbvt_del);\n}\n\n \nstatic int irdma_addr_resolve_neigh(struct irdma_device *iwdev, u32 src_ip,\n\t\t\t\t    u32 dst_ip, int arpindex)\n{\n\tstruct rtable *rt;\n\tstruct neighbour *neigh;\n\tint rc = arpindex;\n\t__be32 dst_ipaddr = htonl(dst_ip);\n\t__be32 src_ipaddr = htonl(src_ip);\n\n\trt = ip_route_output(&init_net, dst_ipaddr, src_ipaddr, 0, 0);\n\tif (IS_ERR(rt)) {\n\t\tibdev_dbg(&iwdev->ibdev, \"CM: ip_route_output fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tneigh = dst_neigh_lookup(&rt->dst, &dst_ipaddr);\n\tif (!neigh)\n\t\tgoto exit;\n\n\tif (neigh->nud_state & NUD_VALID)\n\t\trc = irdma_add_arp(iwdev->rf, &dst_ip, true, neigh->ha);\n\telse\n\t\tneigh_event_send(neigh, NULL);\n\tif (neigh)\n\t\tneigh_release(neigh);\nexit:\n\tip_rt_put(rt);\n\n\treturn rc;\n}\n\n \nstatic struct dst_entry *irdma_get_dst_ipv6(struct sockaddr_in6 *src_addr,\n\t\t\t\t\t    struct sockaddr_in6 *dst_addr)\n{\n\tstruct dst_entry *dst = NULL;\n\n\tif ((IS_ENABLED(CONFIG_IPV6))) {\n\t\tstruct flowi6 fl6 = {};\n\n\t\tfl6.daddr = dst_addr->sin6_addr;\n\t\tfl6.saddr = src_addr->sin6_addr;\n\t\tif (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)\n\t\t\tfl6.flowi6_oif = dst_addr->sin6_scope_id;\n\n\t\tdst = ip6_route_output(&init_net, NULL, &fl6);\n\t}\n\n\treturn dst;\n}\n\n \nstatic int irdma_addr_resolve_neigh_ipv6(struct irdma_device *iwdev, u32 *src,\n\t\t\t\t\t u32 *dest, int arpindex)\n{\n\tstruct neighbour *neigh;\n\tint rc = arpindex;\n\tstruct dst_entry *dst;\n\tstruct sockaddr_in6 dst_addr = {};\n\tstruct sockaddr_in6 src_addr = {};\n\n\tdst_addr.sin6_family = AF_INET6;\n\tirdma_copy_ip_htonl(dst_addr.sin6_addr.in6_u.u6_addr32, dest);\n\tsrc_addr.sin6_family = AF_INET6;\n\tirdma_copy_ip_htonl(src_addr.sin6_addr.in6_u.u6_addr32, src);\n\tdst = irdma_get_dst_ipv6(&src_addr, &dst_addr);\n\tif (!dst || dst->error) {\n\t\tif (dst) {\n\t\t\tdst_release(dst);\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: ip6_route_output returned dst->error = %d\\n\",\n\t\t\t\t  dst->error);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\tneigh = dst_neigh_lookup(dst, dst_addr.sin6_addr.in6_u.u6_addr32);\n\tif (!neigh)\n\t\tgoto exit;\n\n\tibdev_dbg(&iwdev->ibdev, \"CM: dst_neigh_lookup MAC=%pM\\n\",\n\t\t  neigh->ha);\n\n\ttrace_irdma_addr_resolve(iwdev, neigh->ha);\n\n\tif (neigh->nud_state & NUD_VALID)\n\t\trc = irdma_add_arp(iwdev->rf, dest, false, neigh->ha);\n\telse\n\t\tneigh_event_send(neigh, NULL);\n\tif (neigh)\n\t\tneigh_release(neigh);\nexit:\n\tdst_release(dst);\n\n\treturn rc;\n}\n\n \nstruct irdma_cm_node *irdma_find_node(struct irdma_cm_core *cm_core,\n\t\t\t\t      u16 rem_port, u32 *rem_addr, u16 loc_port,\n\t\t\t\t      u32 *loc_addr, u16 vlan_id)\n{\n\tstruct irdma_cm_node *cm_node;\n\tu32 key = (rem_port << 16) | loc_port;\n\n\trcu_read_lock();\n\thash_for_each_possible_rcu(cm_core->cm_hash_tbl, cm_node, list, key) {\n\t\tif (cm_node->vlan_id == vlan_id &&\n\t\t    cm_node->loc_port == loc_port && cm_node->rem_port == rem_port &&\n\t\t    !memcmp(cm_node->loc_addr, loc_addr, sizeof(cm_node->loc_addr)) &&\n\t\t    !memcmp(cm_node->rem_addr, rem_addr, sizeof(cm_node->rem_addr))) {\n\t\t\tif (!refcount_inc_not_zero(&cm_node->refcnt))\n\t\t\t\tgoto exit;\n\t\t\trcu_read_unlock();\n\t\t\ttrace_irdma_find_node(cm_node, 0, NULL);\n\t\t\treturn cm_node;\n\t\t}\n\t}\n\nexit:\n\trcu_read_unlock();\n\n\t \n\treturn NULL;\n}\n\n \nstatic void irdma_add_hte_node(struct irdma_cm_core *cm_core,\n\t\t\t       struct irdma_cm_node *cm_node)\n{\n\tunsigned long flags;\n\tu32 key = (cm_node->rem_port << 16) | cm_node->loc_port;\n\n\tspin_lock_irqsave(&cm_core->ht_lock, flags);\n\thash_add_rcu(cm_core->cm_hash_tbl, &cm_node->list, key);\n\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n}\n\n \nbool irdma_ipv4_is_lpb(u32 loc_addr, u32 rem_addr)\n{\n\treturn ipv4_is_loopback(htonl(rem_addr)) || (loc_addr == rem_addr);\n}\n\n \nbool irdma_ipv6_is_lpb(u32 *loc_addr, u32 *rem_addr)\n{\n\tstruct in6_addr raddr6;\n\n\tirdma_copy_ip_htonl(raddr6.in6_u.u6_addr32, rem_addr);\n\n\treturn !memcmp(loc_addr, rem_addr, 16) || ipv6_addr_loopback(&raddr6);\n}\n\n \nstatic int irdma_cm_create_ah(struct irdma_cm_node *cm_node, bool wait)\n{\n\tstruct irdma_ah_info ah_info = {};\n\tstruct irdma_device *iwdev = cm_node->iwdev;\n\n\tether_addr_copy(ah_info.mac_addr, iwdev->netdev->dev_addr);\n\n\tah_info.hop_ttl = 0x40;\n\tah_info.tc_tos = cm_node->tos;\n\tah_info.vsi = &iwdev->vsi;\n\n\tif (cm_node->ipv4) {\n\t\tah_info.ipv4_valid = true;\n\t\tah_info.dest_ip_addr[0] = cm_node->rem_addr[0];\n\t\tah_info.src_ip_addr[0] = cm_node->loc_addr[0];\n\t\tah_info.do_lpbk = irdma_ipv4_is_lpb(ah_info.src_ip_addr[0],\n\t\t\t\t\t\t    ah_info.dest_ip_addr[0]);\n\t} else {\n\t\tmemcpy(ah_info.dest_ip_addr, cm_node->rem_addr,\n\t\t       sizeof(ah_info.dest_ip_addr));\n\t\tmemcpy(ah_info.src_ip_addr, cm_node->loc_addr,\n\t\t       sizeof(ah_info.src_ip_addr));\n\t\tah_info.do_lpbk = irdma_ipv6_is_lpb(ah_info.src_ip_addr,\n\t\t\t\t\t\t    ah_info.dest_ip_addr);\n\t}\n\n\tah_info.vlan_tag = cm_node->vlan_id;\n\tif (cm_node->vlan_id < VLAN_N_VID) {\n\t\tah_info.insert_vlan_tag = 1;\n\t\tah_info.vlan_tag |= cm_node->user_pri << VLAN_PRIO_SHIFT;\n\t}\n\n\tah_info.dst_arpindex =\n\t\tirdma_arp_table(iwdev->rf, ah_info.dest_ip_addr,\n\t\t\t\tah_info.ipv4_valid, NULL, IRDMA_ARP_RESOLVE);\n\n\tif (irdma_puda_create_ah(&iwdev->rf->sc_dev, &ah_info, wait,\n\t\t\t\t IRDMA_PUDA_RSRC_TYPE_ILQ, cm_node,\n\t\t\t\t &cm_node->ah))\n\t\treturn -ENOMEM;\n\n\ttrace_irdma_create_ah(cm_node);\n\treturn 0;\n}\n\n \nstatic void irdma_cm_free_ah(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_device *iwdev = cm_node->iwdev;\n\n\ttrace_irdma_cm_free_ah(cm_node);\n\tirdma_puda_free_ah(&iwdev->rf->sc_dev, cm_node->ah);\n\tcm_node->ah = NULL;\n}\n\n \nstatic struct irdma_cm_node *\nirdma_make_cm_node(struct irdma_cm_core *cm_core, struct irdma_device *iwdev,\n\t\t   struct irdma_cm_info *cm_info,\n\t\t   struct irdma_cm_listener *listener)\n{\n\tstruct irdma_cm_node *cm_node;\n\tint oldarpindex;\n\tint arpindex;\n\tstruct net_device *netdev = iwdev->netdev;\n\n\t \n\tcm_node = kzalloc(sizeof(*cm_node), GFP_ATOMIC);\n\tif (!cm_node)\n\t\treturn NULL;\n\n\t \n\tcm_node->ipv4 = cm_info->ipv4;\n\tcm_node->vlan_id = cm_info->vlan_id;\n\tif (cm_node->vlan_id >= VLAN_N_VID && iwdev->dcb_vlan_mode)\n\t\tcm_node->vlan_id = 0;\n\tcm_node->tos = cm_info->tos;\n\tcm_node->user_pri = cm_info->user_pri;\n\tif (listener) {\n\t\tif (listener->tos != cm_info->tos)\n\t\t\tibdev_warn(&iwdev->ibdev,\n\t\t\t\t   \"application TOS[%d] and remote client TOS[%d] mismatch\\n\",\n\t\t\t\t   listener->tos, cm_info->tos);\n\t\tif (iwdev->vsi.dscp_mode) {\n\t\t\tcm_node->user_pri = listener->user_pri;\n\t\t} else {\n\t\t\tcm_node->tos = max(listener->tos, cm_info->tos);\n\t\t\tcm_node->user_pri = rt_tos2priority(cm_node->tos);\n\t\t\tcm_node->user_pri =\n\t\t\t\tirdma_iw_get_vlan_prio(cm_info->loc_addr,\n\t\t\t\t\t\t       cm_node->user_pri,\n\t\t\t\t\t\t       cm_info->ipv4);\n\t\t}\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"DCB: listener: TOS:[%d] UP:[%d]\\n\", cm_node->tos,\n\t\t\t  cm_node->user_pri);\n\t\ttrace_irdma_listener_tos(iwdev, cm_node->tos,\n\t\t\t\t\t cm_node->user_pri);\n\t}\n\tmemcpy(cm_node->loc_addr, cm_info->loc_addr, sizeof(cm_node->loc_addr));\n\tmemcpy(cm_node->rem_addr, cm_info->rem_addr, sizeof(cm_node->rem_addr));\n\tcm_node->loc_port = cm_info->loc_port;\n\tcm_node->rem_port = cm_info->rem_port;\n\n\tcm_node->mpa_frame_rev = IRDMA_CM_DEFAULT_MPA_VER;\n\tcm_node->send_rdma0_op = SEND_RDMA_READ_ZERO;\n\tcm_node->iwdev = iwdev;\n\tcm_node->dev = &iwdev->rf->sc_dev;\n\n\tcm_node->ird_size = cm_node->dev->hw_attrs.max_hw_ird;\n\tcm_node->ord_size = cm_node->dev->hw_attrs.max_hw_ord;\n\n\tcm_node->listener = listener;\n\tcm_node->cm_id = cm_info->cm_id;\n\tether_addr_copy(cm_node->loc_mac, netdev->dev_addr);\n\tspin_lock_init(&cm_node->retrans_list_lock);\n\tcm_node->ack_rcvd = false;\n\n\tinit_completion(&cm_node->establish_comp);\n\trefcount_set(&cm_node->refcnt, 1);\n\t \n\tcm_node->cm_core = cm_core;\n\tcm_node->tcp_cntxt.loc_id = IRDMA_CM_DEFAULT_LOCAL_ID;\n\tcm_node->tcp_cntxt.rcv_wscale = iwdev->rcv_wscale;\n\tcm_node->tcp_cntxt.rcv_wnd = iwdev->rcv_wnd >> cm_node->tcp_cntxt.rcv_wscale;\n\tif (cm_node->ipv4) {\n\t\tcm_node->tcp_cntxt.loc_seq_num = secure_tcp_seq(htonl(cm_node->loc_addr[0]),\n\t\t\t\t\t\t\t\thtonl(cm_node->rem_addr[0]),\n\t\t\t\t\t\t\t\thtons(cm_node->loc_port),\n\t\t\t\t\t\t\t\thtons(cm_node->rem_port));\n\t\tcm_node->tcp_cntxt.mss = iwdev->vsi.mtu - IRDMA_MTU_TO_MSS_IPV4;\n\t} else if (IS_ENABLED(CONFIG_IPV6)) {\n\t\t__be32 loc[4] = {\n\t\t\thtonl(cm_node->loc_addr[0]), htonl(cm_node->loc_addr[1]),\n\t\t\thtonl(cm_node->loc_addr[2]), htonl(cm_node->loc_addr[3])\n\t\t};\n\t\t__be32 rem[4] = {\n\t\t\thtonl(cm_node->rem_addr[0]), htonl(cm_node->rem_addr[1]),\n\t\t\thtonl(cm_node->rem_addr[2]), htonl(cm_node->rem_addr[3])\n\t\t};\n\t\tcm_node->tcp_cntxt.loc_seq_num = secure_tcpv6_seq(loc, rem,\n\t\t\t\t\t\t\t\t  htons(cm_node->loc_port),\n\t\t\t\t\t\t\t\t  htons(cm_node->rem_port));\n\t\tcm_node->tcp_cntxt.mss = iwdev->vsi.mtu - IRDMA_MTU_TO_MSS_IPV6;\n\t}\n\n\tif ((cm_node->ipv4 &&\n\t     irdma_ipv4_is_lpb(cm_node->loc_addr[0], cm_node->rem_addr[0])) ||\n\t    (!cm_node->ipv4 &&\n\t     irdma_ipv6_is_lpb(cm_node->loc_addr, cm_node->rem_addr))) {\n\t\tcm_node->do_lpb = true;\n\t\tarpindex = irdma_arp_table(iwdev->rf, cm_node->rem_addr,\n\t\t\t\t\t   cm_node->ipv4, NULL,\n\t\t\t\t\t   IRDMA_ARP_RESOLVE);\n\t} else {\n\t\toldarpindex = irdma_arp_table(iwdev->rf, cm_node->rem_addr,\n\t\t\t\t\t      cm_node->ipv4, NULL,\n\t\t\t\t\t      IRDMA_ARP_RESOLVE);\n\t\tif (cm_node->ipv4)\n\t\t\tarpindex = irdma_addr_resolve_neigh(iwdev,\n\t\t\t\t\t\t\t    cm_info->loc_addr[0],\n\t\t\t\t\t\t\t    cm_info->rem_addr[0],\n\t\t\t\t\t\t\t    oldarpindex);\n\t\telse if (IS_ENABLED(CONFIG_IPV6))\n\t\t\tarpindex = irdma_addr_resolve_neigh_ipv6(iwdev,\n\t\t\t\t\t\t\t\t cm_info->loc_addr,\n\t\t\t\t\t\t\t\t cm_info->rem_addr,\n\t\t\t\t\t\t\t\t oldarpindex);\n\t\telse\n\t\t\tarpindex = -EINVAL;\n\t}\n\n\tif (arpindex < 0)\n\t\tgoto err;\n\n\tether_addr_copy(cm_node->rem_mac,\n\t\t\tiwdev->rf->arp_table[arpindex].mac_addr);\n\tirdma_add_hte_node(cm_core, cm_node);\n\tcm_core->stats_nodes_created++;\n\treturn cm_node;\n\nerr:\n\tkfree(cm_node);\n\n\treturn NULL;\n}\n\nstatic void irdma_destroy_connection(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_cm_core *cm_core = cm_node->cm_core;\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_cm_info nfo;\n\n\t \n\tif (!cm_node->accelerated && cm_node->accept_pend) {\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: node destroyed before established\\n\");\n\t\tatomic_dec(&cm_node->listener->pend_accepts_cnt);\n\t}\n\tif (cm_node->close_entry)\n\t\tirdma_handle_close_entry(cm_node, 0);\n\tif (cm_node->listener) {\n\t\tirdma_dec_refcnt_listen(cm_core, cm_node->listener, 0, true);\n\t} else {\n\t\tif (cm_node->apbvt_set) {\n\t\t\tirdma_del_apbvt(cm_node->iwdev, cm_node->apbvt_entry);\n\t\t\tcm_node->apbvt_set = 0;\n\t\t}\n\t\tirdma_get_addr_info(cm_node, &nfo);\n\t\tif (cm_node->qhash_set) {\n\t\t\tnfo.qh_qpid = cm_node->iwdev->vsi.ilq->qp_id;\n\t\t\tirdma_manage_qhash(cm_node->iwdev, &nfo,\n\t\t\t\t\t   IRDMA_QHASH_TYPE_TCP_ESTABLISHED,\n\t\t\t\t\t   IRDMA_QHASH_MANAGE_TYPE_DELETE, NULL,\n\t\t\t\t\t   false);\n\t\t\tcm_node->qhash_set = 0;\n\t\t}\n\t}\n\n\tiwqp = cm_node->iwqp;\n\tif (iwqp) {\n\t\tcm_node->cm_id->rem_ref(cm_node->cm_id);\n\t\tcm_node->cm_id = NULL;\n\t\tiwqp->cm_id = NULL;\n\t\tirdma_qp_rem_ref(&iwqp->ibqp);\n\t\tcm_node->iwqp = NULL;\n\t} else if (cm_node->qhash_set) {\n\t\tirdma_get_addr_info(cm_node, &nfo);\n\t\tnfo.qh_qpid = cm_node->iwdev->vsi.ilq->qp_id;\n\t\tirdma_manage_qhash(cm_node->iwdev, &nfo,\n\t\t\t\t   IRDMA_QHASH_TYPE_TCP_ESTABLISHED,\n\t\t\t\t   IRDMA_QHASH_MANAGE_TYPE_DELETE, NULL, false);\n\t\tcm_node->qhash_set = 0;\n\t}\n\n\tcm_core->cm_free_ah(cm_node);\n}\n\n \nvoid irdma_rem_ref_cm_node(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_cm_core *cm_core = cm_node->cm_core;\n\tunsigned long flags;\n\n\ttrace_irdma_rem_ref_cm_node(cm_node, 0, __builtin_return_address(0));\n\tspin_lock_irqsave(&cm_core->ht_lock, flags);\n\n\tif (!refcount_dec_and_test(&cm_node->refcnt)) {\n\t\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n\t\treturn;\n\t}\n\tif (cm_node->iwqp) {\n\t\tcm_node->iwqp->cm_node = NULL;\n\t\tcm_node->iwqp->cm_id = NULL;\n\t}\n\thash_del_rcu(&cm_node->list);\n\tcm_node->cm_core->stats_nodes_destroyed++;\n\n\tspin_unlock_irqrestore(&cm_core->ht_lock, flags);\n\n\tirdma_destroy_connection(cm_node);\n\n\tkfree_rcu(cm_node, rcu_head);\n}\n\n \nstatic void irdma_handle_fin_pkt(struct irdma_cm_node *cm_node)\n{\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_RCVD:\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_MPAREJ_RCVD:\n\t\tcm_node->tcp_cntxt.rcv_nxt++;\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_LAST_ACK;\n\t\tirdma_send_fin(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\t\tirdma_create_event(cm_node, IRDMA_CM_EVENT_ABORTED);\n\t\tcm_node->tcp_cntxt.rcv_nxt++;\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\t\tcm_node->tcp_cntxt.rcv_nxt++;\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSING;\n\t\tirdma_send_ack(cm_node);\n\t\t \n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\t\tcm_node->tcp_cntxt.rcv_nxt++;\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_TIME_WAIT;\n\t\tirdma_send_ack(cm_node);\n\t\tirdma_schedule_cm_timer(cm_node, NULL, IRDMA_TIMER_TYPE_CLOSE,\n\t\t\t\t\t1, 0);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_TIME_WAIT:\n\t\tcm_node->tcp_cntxt.rcv_nxt++;\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\tdefault:\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: bad state node state = %d\\n\", cm_node->state);\n\t\tbreak;\n\t}\n}\n\n \nstatic void irdma_handle_rst_pkt(struct irdma_cm_node *cm_node,\n\t\t\t\t struct irdma_puda_buf *rbuf)\n{\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: caller: %pS cm_node=%p state=%d rem_port=0x%04x loc_port=0x%04x rem_addr=%pI4 loc_addr=%pI4\\n\",\n\t\t  __builtin_return_address(0), cm_node, cm_node->state,\n\t\t  cm_node->rem_port, cm_node->loc_port, cm_node->rem_addr,\n\t\t  cm_node->loc_addr);\n\n\tirdma_cleanup_retrans_entry(cm_node);\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\t\tswitch (cm_node->mpa_frame_rev) {\n\t\tcase IETF_MPA_V2:\n\t\t\t \n\t\t\tcm_node->mpa_frame_rev = IETF_MPA_V1;\n\t\t\t \n\t\t\tcm_node->state = IRDMA_CM_STATE_SYN_SENT;\n\t\t\tif (irdma_send_syn(cm_node, 0))\n\t\t\t\tirdma_active_open_err(cm_node, false);\n\t\t\tbreak;\n\t\tcase IETF_MPA_V1:\n\t\tdefault:\n\t\t\tirdma_active_open_err(cm_node, false);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREQ_RCVD:\n\t\tatomic_inc(&cm_node->passive_state);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_SYN_RCVD:\n\tcase IRDMA_CM_STATE_LISTENING:\n\t\tirdma_passive_open_err(cm_node, false);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\t\tirdma_active_open_err(cm_node, false);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_CLOSED:\n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\tcase IRDMA_CM_STATE_TIME_WAIT:\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void irdma_handle_rcv_mpa(struct irdma_cm_node *cm_node,\n\t\t\t\t struct irdma_puda_buf *rbuf)\n{\n\tint err;\n\tint datasize = rbuf->datalen;\n\tu8 *dataloc = rbuf->data;\n\n\tenum irdma_cm_event_type type = IRDMA_CM_EVENT_UNKNOWN;\n\tu32 res_type;\n\n\terr = irdma_parse_mpa(cm_node, dataloc, &res_type, datasize);\n\tif (err) {\n\t\tif (cm_node->state == IRDMA_CM_STATE_MPAREQ_SENT)\n\t\t\tirdma_active_open_err(cm_node, true);\n\t\telse\n\t\t\tirdma_passive_open_err(cm_node, true);\n\t\treturn;\n\t}\n\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\t\tif (res_type == IRDMA_MPA_REQUEST_REJECT)\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: state for reject\\n\");\n\t\tcm_node->state = IRDMA_CM_STATE_MPAREQ_RCVD;\n\t\ttype = IRDMA_CM_EVENT_MPA_REQ;\n\t\tirdma_send_ack(cm_node);  \n\t\tatomic_set(&cm_node->passive_state,\n\t\t\t   IRDMA_PASSIVE_STATE_INDICATED);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tif (res_type == IRDMA_MPA_REQUEST_REJECT) {\n\t\t\ttype = IRDMA_CM_EVENT_MPA_REJECT;\n\t\t\tcm_node->state = IRDMA_CM_STATE_MPAREJ_RCVD;\n\t\t} else {\n\t\t\ttype = IRDMA_CM_EVENT_CONNECTED;\n\t\t\tcm_node->state = IRDMA_CM_STATE_OFFLOADED;\n\t\t}\n\t\tirdma_send_ack(cm_node);\n\t\tbreak;\n\tdefault:\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: wrong cm_node state =%d\\n\", cm_node->state);\n\t\tbreak;\n\t}\n\tirdma_create_event(cm_node, type);\n}\n\n \nstatic int irdma_check_syn(struct irdma_cm_node *cm_node, struct tcphdr *tcph)\n{\n\tif (ntohl(tcph->ack_seq) != cm_node->tcp_cntxt.loc_seq_num) {\n\t\tirdma_active_open_err(cm_node, true);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int irdma_check_seq(struct irdma_cm_node *cm_node, struct tcphdr *tcph)\n{\n\tu32 seq;\n\tu32 ack_seq;\n\tu32 loc_seq_num = cm_node->tcp_cntxt.loc_seq_num;\n\tu32 rcv_nxt = cm_node->tcp_cntxt.rcv_nxt;\n\tu32 rcv_wnd;\n\tint err = 0;\n\n\tseq = ntohl(tcph->seq);\n\tack_seq = ntohl(tcph->ack_seq);\n\trcv_wnd = cm_node->tcp_cntxt.rcv_wnd;\n\tif (ack_seq != loc_seq_num ||\n\t    !between(seq, rcv_nxt, (rcv_nxt + rcv_wnd)))\n\t\terr = -1;\n\tif (err)\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: seq number err\\n\");\n\n\treturn err;\n}\n\nvoid irdma_add_conn_est_qh(struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_cm_info nfo;\n\n\tirdma_get_addr_info(cm_node, &nfo);\n\tnfo.qh_qpid = cm_node->iwdev->vsi.ilq->qp_id;\n\tirdma_manage_qhash(cm_node->iwdev, &nfo,\n\t\t\t   IRDMA_QHASH_TYPE_TCP_ESTABLISHED,\n\t\t\t   IRDMA_QHASH_MANAGE_TYPE_ADD,\n\t\t\t   cm_node, false);\n\tcm_node->qhash_set = true;\n}\n\n \nstatic void irdma_handle_syn_pkt(struct irdma_cm_node *cm_node,\n\t\t\t\t struct irdma_puda_buf *rbuf)\n{\n\tstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\n\tint err;\n\tu32 inc_sequence;\n\tint optionsize;\n\n\toptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\n\tinc_sequence = ntohl(tcph->seq);\n\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\t\t \n\t\tirdma_active_open_err(cm_node, 1);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_LISTENING:\n\t\t \n\t\tif (atomic_read(&cm_node->listener->pend_accepts_cnt) >\n\t\t    cm_node->listener->backlog) {\n\t\t\tcm_node->cm_core->stats_backlog_drops++;\n\t\t\tirdma_passive_open_err(cm_node, false);\n\t\t\tbreak;\n\t\t}\n\t\terr = irdma_handle_tcp_options(cm_node, tcph, optionsize, 1);\n\t\tif (err) {\n\t\t\tirdma_passive_open_err(cm_node, false);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\terr = cm_node->cm_core->cm_create_ah(cm_node, false);\n\t\tif (err) {\n\t\t\tirdma_passive_open_err(cm_node, false);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tcm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\n\t\tcm_node->accept_pend = 1;\n\t\tatomic_inc(&cm_node->listener->pend_accepts_cnt);\n\n\t\tcm_node->state = IRDMA_CM_STATE_SYN_RCVD;\n\t\tbreak;\n\tcase IRDMA_CM_STATE_CLOSED:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\tcase IRDMA_CM_STATE_MPAREQ_RCVD:\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\tcase IRDMA_CM_STATE_CLOSING:\n\tcase IRDMA_CM_STATE_UNKNOWN:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic void irdma_handle_synack_pkt(struct irdma_cm_node *cm_node,\n\t\t\t\t    struct irdma_puda_buf *rbuf)\n{\n\tstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\n\tint err;\n\tu32 inc_sequence;\n\tint optionsize;\n\n\toptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\n\tinc_sequence = ntohl(tcph->seq);\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\t \n\t\tif (irdma_check_syn(cm_node, tcph)) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: check syn fail\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\n\t\t \n\t\terr = irdma_handle_tcp_options(cm_node, tcph, optionsize, 0);\n\t\tif (err) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: cm_node=%p tcp_options failed\\n\",\n\t\t\t\t  cm_node);\n\t\t\tbreak;\n\t\t}\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->tcp_cntxt.rcv_nxt = inc_sequence + 1;\n\t\tirdma_send_ack(cm_node);  \n\t\terr = irdma_send_mpa_request(cm_node);\n\t\tif (err) {\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: cm_node=%p irdma_send_mpa_request failed\\n\",\n\t\t\t\t  cm_node);\n\t\t\tbreak;\n\t\t}\n\t\tcm_node->state = IRDMA_CM_STATE_MPAREQ_SENT;\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREQ_RCVD:\n\t\tirdma_passive_open_err(cm_node, true);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_LISTENING:\n\t\tcm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_CLOSED:\n\t\tcm_node->tcp_cntxt.loc_seq_num = ntohl(tcph->ack_seq);\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\tcase IRDMA_CM_STATE_CLOSING:\n\tcase IRDMA_CM_STATE_UNKNOWN:\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int irdma_handle_ack_pkt(struct irdma_cm_node *cm_node,\n\t\t\t\tstruct irdma_puda_buf *rbuf)\n{\n\tstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\n\tu32 inc_sequence;\n\tint ret;\n\tint optionsize;\n\tu32 datasize = rbuf->datalen;\n\n\toptionsize = (tcph->doff << 2) - sizeof(struct tcphdr);\n\n\tif (irdma_check_seq(cm_node, tcph))\n\t\treturn -EINVAL;\n\n\tinc_sequence = ntohl(tcph->seq);\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_RCVD:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tret = irdma_handle_tcp_options(cm_node, tcph, optionsize, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\n\t\tcm_node->state = IRDMA_CM_STATE_ESTABLISHED;\n\t\tif (datasize) {\n\t\t\tcm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\n\t\t\tirdma_handle_rcv_mpa(cm_node, rbuf);\n\t\t}\n\t\tbreak;\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tif (datasize) {\n\t\t\tcm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\n\t\t\tirdma_handle_rcv_mpa(cm_node, rbuf);\n\t\t}\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\t\tcm_node->tcp_cntxt.rem_ack_num = ntohl(tcph->ack_seq);\n\t\tif (datasize) {\n\t\t\tcm_node->tcp_cntxt.rcv_nxt = inc_sequence + datasize;\n\t\t\tcm_node->ack_rcvd = false;\n\t\t\tirdma_handle_rcv_mpa(cm_node, rbuf);\n\t\t} else {\n\t\t\tcm_node->ack_rcvd = true;\n\t\t}\n\t\tbreak;\n\tcase IRDMA_CM_STATE_LISTENING:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_CLOSED:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\trefcount_inc(&cm_node->refcnt);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\tcase IRDMA_CM_STATE_CLOSING:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tcm_node->state = IRDMA_CM_STATE_FIN_WAIT2;\n\t\tbreak;\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\tcase IRDMA_CM_STATE_MPAREQ_RCVD:\n\tcase IRDMA_CM_STATE_UNKNOWN:\n\tdefault:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void irdma_process_pkt(struct irdma_cm_node *cm_node,\n\t\t\t      struct irdma_puda_buf *rbuf)\n{\n\tenum irdma_tcpip_pkt_type pkt_type = IRDMA_PKT_TYPE_UNKNOWN;\n\tstruct tcphdr *tcph = (struct tcphdr *)rbuf->tcph;\n\tu32 fin_set = 0;\n\tint err;\n\n\tif (tcph->rst) {\n\t\tpkt_type = IRDMA_PKT_TYPE_RST;\n\t} else if (tcph->syn) {\n\t\tpkt_type = IRDMA_PKT_TYPE_SYN;\n\t\tif (tcph->ack)\n\t\t\tpkt_type = IRDMA_PKT_TYPE_SYNACK;\n\t} else if (tcph->ack) {\n\t\tpkt_type = IRDMA_PKT_TYPE_ACK;\n\t}\n\tif (tcph->fin)\n\t\tfin_set = 1;\n\n\tswitch (pkt_type) {\n\tcase IRDMA_PKT_TYPE_SYN:\n\t\tirdma_handle_syn_pkt(cm_node, rbuf);\n\t\tbreak;\n\tcase IRDMA_PKT_TYPE_SYNACK:\n\t\tirdma_handle_synack_pkt(cm_node, rbuf);\n\t\tbreak;\n\tcase IRDMA_PKT_TYPE_ACK:\n\t\terr = irdma_handle_ack_pkt(cm_node, rbuf);\n\t\tif (fin_set && !err)\n\t\t\tirdma_handle_fin_pkt(cm_node);\n\t\tbreak;\n\tcase IRDMA_PKT_TYPE_RST:\n\t\tirdma_handle_rst_pkt(cm_node, rbuf);\n\t\tbreak;\n\tdefault:\n\t\tif (fin_set &&\n\t\t    (!irdma_check_seq(cm_node, (struct tcphdr *)rbuf->tcph)))\n\t\t\tirdma_handle_fin_pkt(cm_node);\n\t\tbreak;\n\t}\n}\n\n \nstatic struct irdma_cm_listener *\nirdma_make_listen_node(struct irdma_cm_core *cm_core,\n\t\t       struct irdma_device *iwdev,\n\t\t       struct irdma_cm_info *cm_info)\n{\n\tstruct irdma_cm_listener *listener;\n\tunsigned long flags;\n\n\t \n\tlistener =\n\t\tirdma_find_listener(cm_core, cm_info->loc_addr, cm_info->ipv4,\n\t\t\t\t    cm_info->loc_port, cm_info->vlan_id,\n\t\t\t\t    IRDMA_CM_LISTENER_EITHER_STATE);\n\tif (listener &&\n\t    listener->listener_state == IRDMA_CM_LISTENER_ACTIVE_STATE) {\n\t\trefcount_dec(&listener->refcnt);\n\t\treturn NULL;\n\t}\n\n\tif (!listener) {\n\t\t \n\t\tlistener = kzalloc(sizeof(*listener), GFP_KERNEL);\n\t\tif (!listener)\n\t\t\treturn NULL;\n\t\tcm_core->stats_listen_nodes_created++;\n\t\tmemcpy(listener->loc_addr, cm_info->loc_addr,\n\t\t       sizeof(listener->loc_addr));\n\t\tlistener->loc_port = cm_info->loc_port;\n\n\t\tINIT_LIST_HEAD(&listener->child_listen_list);\n\n\t\trefcount_set(&listener->refcnt, 1);\n\t} else {\n\t\tlistener->reused_node = 1;\n\t}\n\n\tlistener->cm_id = cm_info->cm_id;\n\tlistener->ipv4 = cm_info->ipv4;\n\tlistener->vlan_id = cm_info->vlan_id;\n\tatomic_set(&listener->pend_accepts_cnt, 0);\n\tlistener->cm_core = cm_core;\n\tlistener->iwdev = iwdev;\n\n\tlistener->backlog = cm_info->backlog;\n\tlistener->listener_state = IRDMA_CM_LISTENER_ACTIVE_STATE;\n\n\tif (!listener->reused_node) {\n\t\tspin_lock_irqsave(&cm_core->listen_list_lock, flags);\n\t\tlist_add(&listener->list, &cm_core->listen_list);\n\t\tspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\n\t}\n\n\treturn listener;\n}\n\n \nstatic int irdma_create_cm_node(struct irdma_cm_core *cm_core,\n\t\t\t\tstruct irdma_device *iwdev,\n\t\t\t\tstruct iw_cm_conn_param *conn_param,\n\t\t\t\tstruct irdma_cm_info *cm_info,\n\t\t\t\tstruct irdma_cm_node **caller_cm_node)\n{\n\tstruct irdma_cm_node *cm_node;\n\tu16 private_data_len = conn_param->private_data_len;\n\tconst void *private_data = conn_param->private_data;\n\n\t \n\tcm_node = irdma_make_cm_node(cm_core, iwdev, cm_info, NULL);\n\tif (!cm_node)\n\t\treturn -ENOMEM;\n\n\t \n\tcm_node->tcp_cntxt.client = 1;\n\tcm_node->tcp_cntxt.rcv_wscale = IRDMA_CM_DEFAULT_RCV_WND_SCALE;\n\n\tirdma_record_ird_ord(cm_node, conn_param->ird, conn_param->ord);\n\n\tcm_node->pdata.size = private_data_len;\n\tcm_node->pdata.addr = cm_node->pdata_buf;\n\n\tmemcpy(cm_node->pdata_buf, private_data, private_data_len);\n\t*caller_cm_node = cm_node;\n\n\treturn 0;\n}\n\n \nstatic int irdma_cm_reject(struct irdma_cm_node *cm_node, const void *pdata,\n\t\t\t   u8 plen)\n{\n\tint ret;\n\tint passive_state;\n\n\tif (cm_node->tcp_cntxt.client)\n\t\treturn 0;\n\n\tirdma_cleanup_retrans_entry(cm_node);\n\n\tpassive_state = atomic_add_return(1, &cm_node->passive_state);\n\tif (passive_state == IRDMA_SEND_RESET_EVENT) {\n\t\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\treturn 0;\n\t}\n\n\tif (cm_node->state == IRDMA_CM_STATE_LISTENER_DESTROYED) {\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\treturn 0;\n\t}\n\n\tret = irdma_send_mpa_reject(cm_node, pdata, plen);\n\tif (!ret)\n\t\treturn 0;\n\n\tcm_node->state = IRDMA_CM_STATE_CLOSED;\n\tif (irdma_send_reset(cm_node))\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: send reset failed\\n\");\n\n\treturn ret;\n}\n\n \nstatic int irdma_cm_close(struct irdma_cm_node *cm_node)\n{\n\tswitch (cm_node->state) {\n\tcase IRDMA_CM_STATE_SYN_RCVD:\n\tcase IRDMA_CM_STATE_SYN_SENT:\n\tcase IRDMA_CM_STATE_ONE_SIDE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_ESTABLISHED:\n\tcase IRDMA_CM_STATE_ACCEPTING:\n\tcase IRDMA_CM_STATE_MPAREQ_SENT:\n\tcase IRDMA_CM_STATE_MPAREQ_RCVD:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_CLOSE_WAIT:\n\t\tcm_node->state = IRDMA_CM_STATE_LAST_ACK;\n\t\tirdma_send_fin(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_FIN_WAIT1:\n\tcase IRDMA_CM_STATE_FIN_WAIT2:\n\tcase IRDMA_CM_STATE_LAST_ACK:\n\tcase IRDMA_CM_STATE_TIME_WAIT:\n\tcase IRDMA_CM_STATE_CLOSING:\n\t\treturn -EINVAL;\n\tcase IRDMA_CM_STATE_LISTENING:\n\t\tirdma_cleanup_retrans_entry(cm_node);\n\t\tirdma_send_reset(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_MPAREJ_RCVD:\n\tcase IRDMA_CM_STATE_UNKNOWN:\n\tcase IRDMA_CM_STATE_INITED:\n\tcase IRDMA_CM_STATE_CLOSED:\n\tcase IRDMA_CM_STATE_LISTENER_DESTROYED:\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\tcase IRDMA_CM_STATE_OFFLOADED:\n\t\tif (cm_node->send_entry)\n\t\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t\t  \"CM: CM send_entry in OFFLOADED state\\n\");\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nvoid irdma_receive_ilq(struct irdma_sc_vsi *vsi, struct irdma_puda_buf *rbuf)\n{\n\tstruct irdma_cm_node *cm_node;\n\tstruct irdma_cm_listener *listener;\n\tstruct iphdr *iph;\n\tstruct ipv6hdr *ip6h;\n\tstruct tcphdr *tcph;\n\tstruct irdma_cm_info cm_info = {};\n\tstruct irdma_device *iwdev = vsi->back_vsi;\n\tstruct irdma_cm_core *cm_core = &iwdev->cm_core;\n\tstruct vlan_ethhdr *ethh;\n\tu16 vtag;\n\n\t \n\tiph = (struct iphdr *)rbuf->iph;\n\tprint_hex_dump_debug(\"ILQ: RECEIVE ILQ BUFFER\", DUMP_PREFIX_OFFSET,\n\t\t\t     16, 8, rbuf->mem.va, rbuf->totallen, false);\n\tif (iwdev->rf->sc_dev.hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {\n\t\tif (rbuf->vlan_valid) {\n\t\t\tvtag = rbuf->vlan_id;\n\t\t\tcm_info.user_pri = (vtag & VLAN_PRIO_MASK) >>\n\t\t\t\t\t   VLAN_PRIO_SHIFT;\n\t\t\tcm_info.vlan_id = vtag & VLAN_VID_MASK;\n\t\t} else {\n\t\t\tcm_info.vlan_id = 0xFFFF;\n\t\t}\n\t} else {\n\t\tethh = rbuf->mem.va;\n\n\t\tif (ethh->h_vlan_proto == htons(ETH_P_8021Q)) {\n\t\t\tvtag = ntohs(ethh->h_vlan_TCI);\n\t\t\tcm_info.user_pri = (vtag & VLAN_PRIO_MASK) >>\n\t\t\t\t\t   VLAN_PRIO_SHIFT;\n\t\t\tcm_info.vlan_id = vtag & VLAN_VID_MASK;\n\t\t\tibdev_dbg(&cm_core->iwdev->ibdev,\n\t\t\t\t  \"CM: vlan_id=%d\\n\", cm_info.vlan_id);\n\t\t} else {\n\t\t\tcm_info.vlan_id = 0xFFFF;\n\t\t}\n\t}\n\ttcph = (struct tcphdr *)rbuf->tcph;\n\n\tif (rbuf->ipv4) {\n\t\tcm_info.loc_addr[0] = ntohl(iph->daddr);\n\t\tcm_info.rem_addr[0] = ntohl(iph->saddr);\n\t\tcm_info.ipv4 = true;\n\t\tcm_info.tos = iph->tos;\n\t} else {\n\t\tip6h = (struct ipv6hdr *)rbuf->iph;\n\t\tirdma_copy_ip_ntohl(cm_info.loc_addr,\n\t\t\t\t    ip6h->daddr.in6_u.u6_addr32);\n\t\tirdma_copy_ip_ntohl(cm_info.rem_addr,\n\t\t\t\t    ip6h->saddr.in6_u.u6_addr32);\n\t\tcm_info.ipv4 = false;\n\t\tcm_info.tos = (ip6h->priority << 4) | (ip6h->flow_lbl[0] >> 4);\n\t}\n\tcm_info.loc_port = ntohs(tcph->dest);\n\tcm_info.rem_port = ntohs(tcph->source);\n\tcm_node = irdma_find_node(cm_core, cm_info.rem_port, cm_info.rem_addr,\n\t\t\t\t  cm_info.loc_port, cm_info.loc_addr, cm_info.vlan_id);\n\n\tif (!cm_node) {\n\t\t \n\t\tif (!tcph->syn || tcph->ack)\n\t\t\treturn;\n\n\t\tlistener = irdma_find_listener(cm_core,\n\t\t\t\t\t       cm_info.loc_addr,\n\t\t\t\t\t       cm_info.ipv4,\n\t\t\t\t\t       cm_info.loc_port,\n\t\t\t\t\t       cm_info.vlan_id,\n\t\t\t\t\t       IRDMA_CM_LISTENER_ACTIVE_STATE);\n\t\tif (!listener) {\n\t\t\tcm_info.cm_id = NULL;\n\t\t\tibdev_dbg(&cm_core->iwdev->ibdev,\n\t\t\t\t  \"CM: no listener found\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tcm_info.cm_id = listener->cm_id;\n\t\tcm_node = irdma_make_cm_node(cm_core, iwdev, &cm_info,\n\t\t\t\t\t     listener);\n\t\tif (!cm_node) {\n\t\t\tibdev_dbg(&cm_core->iwdev->ibdev,\n\t\t\t\t  \"CM: allocate node failed\\n\");\n\t\t\trefcount_dec(&listener->refcnt);\n\t\t\treturn;\n\t\t}\n\n\t\tif (!tcph->rst && !tcph->fin) {\n\t\t\tcm_node->state = IRDMA_CM_STATE_LISTENING;\n\t\t} else {\n\t\t\tirdma_rem_ref_cm_node(cm_node);\n\t\t\treturn;\n\t\t}\n\n\t\trefcount_inc(&cm_node->refcnt);\n\t} else if (cm_node->state == IRDMA_CM_STATE_OFFLOADED) {\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t\treturn;\n\t}\n\n\tirdma_process_pkt(cm_node, rbuf);\n\tirdma_rem_ref_cm_node(cm_node);\n}\n\nstatic int irdma_add_qh(struct irdma_cm_node *cm_node, bool active)\n{\n\tif (!active)\n\t\tirdma_add_conn_est_qh(cm_node);\n\treturn 0;\n}\n\nstatic void irdma_cm_free_ah_nop(struct irdma_cm_node *cm_node)\n{\n}\n\n \nint irdma_setup_cm_core(struct irdma_device *iwdev, u8 rdma_ver)\n{\n\tstruct irdma_cm_core *cm_core = &iwdev->cm_core;\n\n\tcm_core->iwdev = iwdev;\n\tcm_core->dev = &iwdev->rf->sc_dev;\n\n\t \n\tcm_core->event_wq = alloc_ordered_workqueue(\"iwarp-event-wq\", 0);\n\tif (!cm_core->event_wq)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&cm_core->listen_list);\n\n\ttimer_setup(&cm_core->tcp_timer, irdma_cm_timer_tick, 0);\n\n\tspin_lock_init(&cm_core->ht_lock);\n\tspin_lock_init(&cm_core->listen_list_lock);\n\tspin_lock_init(&cm_core->apbvt_lock);\n\tswitch (rdma_ver) {\n\tcase IRDMA_GEN_1:\n\t\tcm_core->form_cm_frame = irdma_form_uda_cm_frame;\n\t\tcm_core->cm_create_ah = irdma_add_qh;\n\t\tcm_core->cm_free_ah = irdma_cm_free_ah_nop;\n\t\tbreak;\n\tcase IRDMA_GEN_2:\n\tdefault:\n\t\tcm_core->form_cm_frame = irdma_form_ah_cm_frame;\n\t\tcm_core->cm_create_ah = irdma_cm_create_ah;\n\t\tcm_core->cm_free_ah = irdma_cm_free_ah;\n\t}\n\n\treturn 0;\n}\n\n \nvoid irdma_cleanup_cm_core(struct irdma_cm_core *cm_core)\n{\n\tif (!cm_core)\n\t\treturn;\n\n\tdel_timer_sync(&cm_core->tcp_timer);\n\n\tdestroy_workqueue(cm_core->event_wq);\n\tcm_core->dev->ws_reset(&cm_core->iwdev->vsi);\n}\n\n \nstatic void irdma_init_tcp_ctx(struct irdma_cm_node *cm_node,\n\t\t\t       struct irdma_tcp_offload_info *tcp_info,\n\t\t\t       struct irdma_qp *iwqp)\n{\n\ttcp_info->ipv4 = cm_node->ipv4;\n\ttcp_info->drop_ooo_seg = !iwqp->iwdev->iw_ooo;\n\ttcp_info->wscale = true;\n\ttcp_info->ignore_tcp_opt = true;\n\ttcp_info->ignore_tcp_uns_opt = true;\n\ttcp_info->no_nagle = false;\n\n\ttcp_info->ttl = IRDMA_DEFAULT_TTL;\n\ttcp_info->rtt_var = IRDMA_DEFAULT_RTT_VAR;\n\ttcp_info->ss_thresh = IRDMA_DEFAULT_SS_THRESH;\n\ttcp_info->rexmit_thresh = IRDMA_DEFAULT_REXMIT_THRESH;\n\n\ttcp_info->tcp_state = IRDMA_TCP_STATE_ESTABLISHED;\n\ttcp_info->snd_wscale = cm_node->tcp_cntxt.snd_wscale;\n\ttcp_info->rcv_wscale = cm_node->tcp_cntxt.rcv_wscale;\n\n\ttcp_info->snd_nxt = cm_node->tcp_cntxt.loc_seq_num;\n\ttcp_info->snd_wnd = cm_node->tcp_cntxt.snd_wnd;\n\ttcp_info->rcv_nxt = cm_node->tcp_cntxt.rcv_nxt;\n\ttcp_info->snd_max = cm_node->tcp_cntxt.loc_seq_num;\n\n\ttcp_info->snd_una = cm_node->tcp_cntxt.loc_seq_num;\n\ttcp_info->cwnd = 2 * cm_node->tcp_cntxt.mss;\n\ttcp_info->snd_wl1 = cm_node->tcp_cntxt.rcv_nxt;\n\ttcp_info->snd_wl2 = cm_node->tcp_cntxt.loc_seq_num;\n\ttcp_info->max_snd_window = cm_node->tcp_cntxt.max_snd_wnd;\n\ttcp_info->rcv_wnd = cm_node->tcp_cntxt.rcv_wnd\n\t\t\t    << cm_node->tcp_cntxt.rcv_wscale;\n\n\ttcp_info->flow_label = 0;\n\ttcp_info->snd_mss = (u32)cm_node->tcp_cntxt.mss;\n\ttcp_info->tos = cm_node->tos;\n\tif (cm_node->vlan_id < VLAN_N_VID) {\n\t\ttcp_info->insert_vlan_tag = true;\n\t\ttcp_info->vlan_tag = cm_node->vlan_id;\n\t\ttcp_info->vlan_tag |= cm_node->user_pri << VLAN_PRIO_SHIFT;\n\t}\n\tif (cm_node->ipv4) {\n\t\ttcp_info->src_port = cm_node->loc_port;\n\t\ttcp_info->dst_port = cm_node->rem_port;\n\n\t\ttcp_info->dest_ip_addr[3] = cm_node->rem_addr[0];\n\t\ttcp_info->local_ipaddr[3] = cm_node->loc_addr[0];\n\t\ttcp_info->arp_idx = (u16)irdma_arp_table(iwqp->iwdev->rf,\n\t\t\t\t\t\t\t &tcp_info->dest_ip_addr[3],\n\t\t\t\t\t\t\t true, NULL,\n\t\t\t\t\t\t\t IRDMA_ARP_RESOLVE);\n\t} else {\n\t\ttcp_info->src_port = cm_node->loc_port;\n\t\ttcp_info->dst_port = cm_node->rem_port;\n\t\tmemcpy(tcp_info->dest_ip_addr, cm_node->rem_addr,\n\t\t       sizeof(tcp_info->dest_ip_addr));\n\t\tmemcpy(tcp_info->local_ipaddr, cm_node->loc_addr,\n\t\t       sizeof(tcp_info->local_ipaddr));\n\n\t\ttcp_info->arp_idx = (u16)irdma_arp_table(iwqp->iwdev->rf,\n\t\t\t\t\t\t\t &tcp_info->dest_ip_addr[0],\n\t\t\t\t\t\t\t false, NULL,\n\t\t\t\t\t\t\t IRDMA_ARP_RESOLVE);\n\t}\n}\n\n \nstatic void irdma_cm_init_tsa_conn(struct irdma_qp *iwqp,\n\t\t\t\t   struct irdma_cm_node *cm_node)\n{\n\tstruct irdma_iwarp_offload_info *iwarp_info;\n\tstruct irdma_qp_host_ctx_info *ctx_info;\n\n\tiwarp_info = &iwqp->iwarp_info;\n\tctx_info = &iwqp->ctx_info;\n\n\tctx_info->tcp_info = &iwqp->tcp_info;\n\tctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\n\tctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\n\n\tiwarp_info->ord_size = cm_node->ord_size;\n\tiwarp_info->ird_size = cm_node->ird_size;\n\tiwarp_info->rd_en = true;\n\tiwarp_info->rdmap_ver = 1;\n\tiwarp_info->ddp_ver = 1;\n\tiwarp_info->pd_id = iwqp->iwpd->sc_pd.pd_id;\n\n\tctx_info->tcp_info_valid = true;\n\tctx_info->iwarp_info_valid = true;\n\tctx_info->user_pri = cm_node->user_pri;\n\n\tirdma_init_tcp_ctx(cm_node, &iwqp->tcp_info, iwqp);\n\tif (cm_node->snd_mark_en) {\n\t\tiwarp_info->snd_mark_en = true;\n\t\tiwarp_info->snd_mark_offset = (iwqp->tcp_info.snd_nxt & SNDMARKER_SEQNMASK) +\n\t\t\t\t\t       cm_node->lsmm_size;\n\t}\n\n\tcm_node->state = IRDMA_CM_STATE_OFFLOADED;\n\tiwqp->tcp_info.tcp_state = IRDMA_TCP_STATE_ESTABLISHED;\n\tiwqp->tcp_info.src_mac_addr_idx = iwqp->iwdev->mac_ip_table_idx;\n\n\tif (cm_node->rcv_mark_en) {\n\t\tiwarp_info->rcv_mark_en = true;\n\t\tiwarp_info->align_hdrs = true;\n\t}\n\n\tirdma_sc_qp_setctx(&iwqp->sc_qp, iwqp->host_ctx.va, ctx_info);\n\n\t \n\tctx_info->tcp_info_valid = false;\n\tctx_info->iwarp_info_valid = false;\n}\n\n \nvoid irdma_cm_disconn(struct irdma_qp *iwqp)\n{\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct disconn_work *work;\n\tunsigned long flags;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn;\n\n\tspin_lock_irqsave(&iwdev->rf->qptable_lock, flags);\n\tif (!iwdev->rf->qp_table[iwqp->ibqp.qp_num]) {\n\t\tspin_unlock_irqrestore(&iwdev->rf->qptable_lock, flags);\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: qp_id %d is already freed\\n\",\n\t\t\t  iwqp->ibqp.qp_num);\n\t\tkfree(work);\n\t\treturn;\n\t}\n\tirdma_qp_add_ref(&iwqp->ibqp);\n\tspin_unlock_irqrestore(&iwdev->rf->qptable_lock, flags);\n\n\twork->iwqp = iwqp;\n\tINIT_WORK(&work->work, irdma_disconnect_worker);\n\tqueue_work(iwdev->cleanup_wq, &work->work);\n}\n\n \nstatic void irdma_qp_disconnect(struct irdma_qp *iwqp)\n{\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\n\tiwqp->active_conn = 0;\n\t \n\tibdev_dbg(&iwdev->ibdev, \"CM: Call close API\\n\");\n\tirdma_cm_close(iwqp->cm_node);\n}\n\n \nstatic void irdma_cm_disconn_true(struct irdma_qp *iwqp)\n{\n\tstruct iw_cm_id *cm_id;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_sc_qp *qp = &iwqp->sc_qp;\n\tu16 last_ae;\n\tu8 original_hw_tcp_state;\n\tu8 original_ibqp_state;\n\tint disconn_status = 0;\n\tint issue_disconn = 0;\n\tint issue_close = 0;\n\tint issue_flush = 0;\n\tunsigned long flags;\n\tint err;\n\n\tiwdev = iwqp->iwdev;\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\tif (rdma_protocol_roce(&iwdev->ibdev, 1)) {\n\t\tstruct ib_qp_attr attr;\n\n\t\tif (iwqp->flush_issued || iwqp->sc_qp.qp_uk.destroy_pending) {\n\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\n\t\tattr.qp_state = IB_QPS_ERR;\n\t\tirdma_modify_qp_roce(&iwqp->ibqp, &attr, IB_QP_STATE, NULL);\n\t\tirdma_ib_qp_event(iwqp, qp->event_type);\n\t\treturn;\n\t}\n\n\tcm_id = iwqp->cm_id;\n\toriginal_hw_tcp_state = iwqp->hw_tcp_state;\n\toriginal_ibqp_state = iwqp->ibqp_state;\n\tlast_ae = iwqp->last_aeq;\n\n\tif (qp->term_flags) {\n\t\tissue_disconn = 1;\n\t\tissue_close = 1;\n\t\tiwqp->cm_id = NULL;\n\t\tirdma_terminate_del_timer(qp);\n\t\tif (!iwqp->flush_issued) {\n\t\t\tiwqp->flush_issued = 1;\n\t\t\tissue_flush = 1;\n\t\t}\n\t} else if ((original_hw_tcp_state == IRDMA_TCP_STATE_CLOSE_WAIT) ||\n\t\t   ((original_ibqp_state == IB_QPS_RTS) &&\n\t\t    (last_ae == IRDMA_AE_LLP_CONNECTION_RESET))) {\n\t\tissue_disconn = 1;\n\t\tif (last_ae == IRDMA_AE_LLP_CONNECTION_RESET)\n\t\t\tdisconn_status = -ECONNRESET;\n\t}\n\n\tif (original_hw_tcp_state == IRDMA_TCP_STATE_CLOSED ||\n\t    original_hw_tcp_state == IRDMA_TCP_STATE_TIME_WAIT ||\n\t    last_ae == IRDMA_AE_RDMAP_ROE_BAD_LLP_CLOSE ||\n\t    last_ae == IRDMA_AE_BAD_CLOSE ||\n\t    last_ae == IRDMA_AE_LLP_CONNECTION_RESET || iwdev->rf->reset || !cm_id) {\n\t\tissue_close = 1;\n\t\tiwqp->cm_id = NULL;\n\t\tqp->term_flags = 0;\n\t\tif (!iwqp->flush_issued) {\n\t\t\tiwqp->flush_issued = 1;\n\t\t\tissue_flush = 1;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\tif (issue_flush && !iwqp->sc_qp.qp_uk.destroy_pending) {\n\t\tirdma_flush_wqes(iwqp, IRDMA_FLUSH_SQ | IRDMA_FLUSH_RQ |\n\t\t\t\t IRDMA_FLUSH_WAIT);\n\n\t\tif (qp->term_flags)\n\t\t\tirdma_ib_qp_event(iwqp, qp->event_type);\n\t}\n\n\tif (!cm_id || !cm_id->event_handler)\n\t\treturn;\n\n\tspin_lock_irqsave(&iwdev->cm_core.ht_lock, flags);\n\tif (!iwqp->cm_node) {\n\t\tspin_unlock_irqrestore(&iwdev->cm_core.ht_lock, flags);\n\t\treturn;\n\t}\n\trefcount_inc(&iwqp->cm_node->refcnt);\n\n\tspin_unlock_irqrestore(&iwdev->cm_core.ht_lock, flags);\n\n\tif (issue_disconn) {\n\t\terr = irdma_send_cm_event(iwqp->cm_node, cm_id,\n\t\t\t\t\t  IW_CM_EVENT_DISCONNECT,\n\t\t\t\t\t  disconn_status);\n\t\tif (err)\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: disconnect event failed: - cm_id = %p\\n\",\n\t\t\t\t  cm_id);\n\t}\n\tif (issue_close) {\n\t\tcm_id->provider_data = iwqp;\n\t\terr = irdma_send_cm_event(iwqp->cm_node, cm_id,\n\t\t\t\t\t  IW_CM_EVENT_CLOSE, 0);\n\t\tif (err)\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: close event failed: - cm_id = %p\\n\",\n\t\t\t\t  cm_id);\n\t\tirdma_qp_disconnect(iwqp);\n\t}\n\tirdma_rem_ref_cm_node(iwqp->cm_node);\n}\n\n \nstatic void irdma_disconnect_worker(struct work_struct *work)\n{\n\tstruct disconn_work *dwork = container_of(work, struct disconn_work, work);\n\tstruct irdma_qp *iwqp = dwork->iwqp;\n\n\tkfree(dwork);\n\tirdma_cm_disconn_true(iwqp);\n\tirdma_qp_rem_ref(&iwqp->ibqp);\n}\n\n \nvoid irdma_free_lsmm_rsrc(struct irdma_qp *iwqp)\n{\n\tstruct irdma_device *iwdev;\n\n\tiwdev = iwqp->iwdev;\n\n\tif (iwqp->ietf_mem.va) {\n\t\tif (iwqp->lsmm_mr)\n\t\t\tiwdev->ibdev.ops.dereg_mr(iwqp->lsmm_mr, NULL);\n\t\tdma_free_coherent(iwdev->rf->sc_dev.hw->device,\n\t\t\t\t  iwqp->ietf_mem.size, iwqp->ietf_mem.va,\n\t\t\t\t  iwqp->ietf_mem.pa);\n\t\tiwqp->ietf_mem.va = NULL;\n\t}\n}\n\n \nint irdma_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct ib_qp *ibqp;\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_sc_dev *dev;\n\tstruct irdma_cm_node *cm_node;\n\tstruct ib_qp_attr attr = {};\n\tint passive_state;\n\tstruct ib_mr *ibmr;\n\tstruct irdma_pd *iwpd;\n\tu16 buf_len = 0;\n\tstruct irdma_kmem_info accept;\n\tu64 tagged_offset;\n\tint wait_ret;\n\tint ret = 0;\n\n\tibqp = irdma_get_qp(cm_id->device, conn_param->qpn);\n\tif (!ibqp)\n\t\treturn -EINVAL;\n\n\tiwqp = to_iwqp(ibqp);\n\tiwdev = iwqp->iwdev;\n\tdev = &iwdev->rf->sc_dev;\n\tcm_node = cm_id->provider_data;\n\n\tif (((struct sockaddr_in *)&cm_id->local_addr)->sin_family == AF_INET) {\n\t\tcm_node->ipv4 = true;\n\t\tcm_node->vlan_id = irdma_get_vlan_ipv4(cm_node->loc_addr);\n\t} else {\n\t\tcm_node->ipv4 = false;\n\t\tirdma_get_vlan_mac_ipv6(cm_node->loc_addr, &cm_node->vlan_id,\n\t\t\t\t\tNULL);\n\t}\n\tibdev_dbg(&iwdev->ibdev, \"CM: Accept vlan_id=%d\\n\",\n\t\t  cm_node->vlan_id);\n\n\ttrace_irdma_accept(cm_node, 0, NULL);\n\n\tif (cm_node->state == IRDMA_CM_STATE_LISTENER_DESTROYED) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tpassive_state = atomic_add_return(1, &cm_node->passive_state);\n\tif (passive_state == IRDMA_SEND_RESET_EVENT) {\n\t\tret = -ECONNRESET;\n\t\tgoto error;\n\t}\n\n\tbuf_len = conn_param->private_data_len + IRDMA_MAX_IETF_SIZE;\n\tiwqp->ietf_mem.size = ALIGN(buf_len, 1);\n\tiwqp->ietf_mem.va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t       iwqp->ietf_mem.size,\n\t\t\t\t\t       &iwqp->ietf_mem.pa, GFP_KERNEL);\n\tif (!iwqp->ietf_mem.va) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tcm_node->pdata.size = conn_param->private_data_len;\n\taccept.addr = iwqp->ietf_mem.va;\n\taccept.size = irdma_cm_build_mpa_frame(cm_node, &accept, MPA_KEY_REPLY);\n\tmemcpy((u8 *)accept.addr + accept.size, conn_param->private_data,\n\t       conn_param->private_data_len);\n\n\tif (cm_node->dev->ws_add(iwqp->sc_qp.vsi, cm_node->user_pri)) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tiwqp->sc_qp.user_pri = cm_node->user_pri;\n\tirdma_qp_add_qos(&iwqp->sc_qp);\n\t \n\tiwpd = iwqp->iwpd;\n\ttagged_offset = (uintptr_t)iwqp->ietf_mem.va;\n\tibmr = irdma_reg_phys_mr(&iwpd->ibpd, iwqp->ietf_mem.pa, buf_len,\n\t\t\t\t IB_ACCESS_LOCAL_WRITE, &tagged_offset);\n\tif (IS_ERR(ibmr)) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tibmr->pd = &iwpd->ibpd;\n\tibmr->device = iwpd->ibpd.device;\n\tiwqp->lsmm_mr = ibmr;\n\tif (iwqp->page)\n\t\tiwqp->sc_qp.qp_uk.sq_base = kmap_local_page(iwqp->page);\n\n\tcm_node->lsmm_size = accept.size + conn_param->private_data_len;\n\tirdma_sc_send_lsmm(&iwqp->sc_qp, iwqp->ietf_mem.va, cm_node->lsmm_size,\n\t\t\t   ibmr->lkey);\n\n\tif (iwqp->page)\n\t\tkunmap_local(iwqp->sc_qp.qp_uk.sq_base);\n\n\tiwqp->cm_id = cm_id;\n\tcm_node->cm_id = cm_id;\n\n\tcm_id->provider_data = iwqp;\n\tiwqp->active_conn = 0;\n\tiwqp->cm_node = cm_node;\n\tcm_node->iwqp = iwqp;\n\tirdma_cm_init_tsa_conn(iwqp, cm_node);\n\tirdma_qp_add_ref(&iwqp->ibqp);\n\tcm_id->add_ref(cm_id);\n\n\tattr.qp_state = IB_QPS_RTS;\n\tcm_node->qhash_set = false;\n\tcm_node->cm_core->cm_free_ah(cm_node);\n\n\tirdma_modify_qp(&iwqp->ibqp, &attr, IB_QP_STATE, NULL);\n\tif (dev->hw_attrs.uk_attrs.feature_flags & IRDMA_FEATURE_RTS_AE) {\n\t\twait_ret = wait_event_interruptible_timeout(iwqp->waitq,\n\t\t\t\t\t\t\t    iwqp->rts_ae_rcvd,\n\t\t\t\t\t\t\t    IRDMA_MAX_TIMEOUT);\n\t\tif (!wait_ret) {\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: Slow Connection: cm_node=%p, loc_port=%d, rem_port=%d, cm_id=%p\\n\",\n\t\t\t\t  cm_node, cm_node->loc_port,\n\t\t\t\t  cm_node->rem_port, cm_node->cm_id);\n\t\t\tret = -ECONNRESET;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tirdma_send_cm_event(cm_node, cm_id, IW_CM_EVENT_ESTABLISHED, 0);\n\tcm_node->accelerated = true;\n\tcomplete(&cm_node->establish_comp);\n\n\tif (cm_node->accept_pend) {\n\t\tatomic_dec(&cm_node->listener->pend_accepts_cnt);\n\t\tcm_node->accept_pend = 0;\n\t}\n\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"CM: rem_port=0x%04x, loc_port=0x%04x rem_addr=%pI4 loc_addr=%pI4 cm_node=%p cm_id=%p qp_id = %d\\n\\n\",\n\t\t  cm_node->rem_port, cm_node->loc_port, cm_node->rem_addr,\n\t\t  cm_node->loc_addr, cm_node, cm_id, ibqp->qp_num);\n\tcm_node->cm_core->stats_accepts++;\n\n\treturn 0;\nerror:\n\tirdma_free_lsmm_rsrc(iwqp);\n\tirdma_rem_ref_cm_node(cm_node);\n\n\treturn ret;\n}\n\n \nint irdma_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\n{\n\tstruct irdma_device *iwdev;\n\tstruct irdma_cm_node *cm_node;\n\n\tcm_node = cm_id->provider_data;\n\tcm_node->pdata.size = pdata_len;\n\n\ttrace_irdma_reject(cm_node, 0, NULL);\n\n\tiwdev = to_iwdev(cm_id->device);\n\tif (!iwdev)\n\t\treturn -EINVAL;\n\n\tcm_node->cm_core->stats_rejects++;\n\n\tif (pdata_len + sizeof(struct ietf_mpa_v2) > IRDMA_MAX_CM_BUF)\n\t\treturn -EINVAL;\n\n\treturn irdma_cm_reject(cm_node, pdata, pdata_len);\n}\n\n \nint irdma_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct ib_qp *ibqp;\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_cm_node *cm_node;\n\tstruct irdma_cm_info cm_info;\n\tstruct sockaddr_in *laddr;\n\tstruct sockaddr_in *raddr;\n\tstruct sockaddr_in6 *laddr6;\n\tstruct sockaddr_in6 *raddr6;\n\tint ret = 0;\n\n\tibqp = irdma_get_qp(cm_id->device, conn_param->qpn);\n\tif (!ibqp)\n\t\treturn -EINVAL;\n\tiwqp = to_iwqp(ibqp);\n\tif (!iwqp)\n\t\treturn -EINVAL;\n\tiwdev = iwqp->iwdev;\n\tif (!iwdev)\n\t\treturn -EINVAL;\n\n\tladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\n\traddr = (struct sockaddr_in *)&cm_id->m_remote_addr;\n\tladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\n\traddr6 = (struct sockaddr_in6 *)&cm_id->m_remote_addr;\n\n\tif (!(laddr->sin_port) || !(raddr->sin_port))\n\t\treturn -EINVAL;\n\n\tiwqp->active_conn = 1;\n\tiwqp->cm_id = NULL;\n\tcm_id->provider_data = iwqp;\n\n\t \n\tif (cm_id->remote_addr.ss_family == AF_INET) {\n\t\tif (iwdev->vsi.mtu < IRDMA_MIN_MTU_IPV4)\n\t\t\treturn -EINVAL;\n\n\t\tcm_info.ipv4 = true;\n\t\tmemset(cm_info.loc_addr, 0, sizeof(cm_info.loc_addr));\n\t\tmemset(cm_info.rem_addr, 0, sizeof(cm_info.rem_addr));\n\t\tcm_info.loc_addr[0] = ntohl(laddr->sin_addr.s_addr);\n\t\tcm_info.rem_addr[0] = ntohl(raddr->sin_addr.s_addr);\n\t\tcm_info.loc_port = ntohs(laddr->sin_port);\n\t\tcm_info.rem_port = ntohs(raddr->sin_port);\n\t\tcm_info.vlan_id = irdma_get_vlan_ipv4(cm_info.loc_addr);\n\t} else {\n\t\tif (iwdev->vsi.mtu < IRDMA_MIN_MTU_IPV6)\n\t\t\treturn -EINVAL;\n\n\t\tcm_info.ipv4 = false;\n\t\tirdma_copy_ip_ntohl(cm_info.loc_addr,\n\t\t\t\t    laddr6->sin6_addr.in6_u.u6_addr32);\n\t\tirdma_copy_ip_ntohl(cm_info.rem_addr,\n\t\t\t\t    raddr6->sin6_addr.in6_u.u6_addr32);\n\t\tcm_info.loc_port = ntohs(laddr6->sin6_port);\n\t\tcm_info.rem_port = ntohs(raddr6->sin6_port);\n\t\tirdma_get_vlan_mac_ipv6(cm_info.loc_addr, &cm_info.vlan_id,\n\t\t\t\t\tNULL);\n\t}\n\tcm_info.cm_id = cm_id;\n\tcm_info.qh_qpid = iwdev->vsi.ilq->qp_id;\n\tcm_info.tos = cm_id->tos;\n\tif (iwdev->vsi.dscp_mode) {\n\t\tcm_info.user_pri =\n\t\t\tiwqp->sc_qp.vsi->dscp_map[irdma_tos2dscp(cm_info.tos)];\n\t} else {\n\t\tcm_info.user_pri = rt_tos2priority(cm_id->tos);\n\t\tcm_info.user_pri = irdma_iw_get_vlan_prio(cm_info.loc_addr,\n\t\t\t\t\t\t\t  cm_info.user_pri,\n\t\t\t\t\t\t\t  cm_info.ipv4);\n\t}\n\n\tif (iwqp->sc_qp.dev->ws_add(iwqp->sc_qp.vsi, cm_info.user_pri))\n\t\treturn -ENOMEM;\n\tiwqp->sc_qp.user_pri = cm_info.user_pri;\n\tirdma_qp_add_qos(&iwqp->sc_qp);\n\tibdev_dbg(&iwdev->ibdev, \"DCB: TOS:[%d] UP:[%d]\\n\", cm_id->tos,\n\t\t  cm_info.user_pri);\n\n\ttrace_irdma_dcb_tos(iwdev, cm_id->tos, cm_info.user_pri);\n\n\tret = irdma_create_cm_node(&iwdev->cm_core, iwdev, conn_param, &cm_info,\n\t\t\t\t   &cm_node);\n\tif (ret)\n\t\treturn ret;\n\tret = cm_node->cm_core->cm_create_ah(cm_node, true);\n\tif (ret)\n\t\tgoto err;\n\tif (irdma_manage_qhash(iwdev, &cm_info,\n\t\t\t       IRDMA_QHASH_TYPE_TCP_ESTABLISHED,\n\t\t\t       IRDMA_QHASH_MANAGE_TYPE_ADD, NULL, true)) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\tcm_node->qhash_set = true;\n\n\tcm_node->apbvt_entry = irdma_add_apbvt(iwdev, cm_info.loc_port);\n\tif (!cm_node->apbvt_entry) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tcm_node->apbvt_set = true;\n\tiwqp->cm_node = cm_node;\n\tcm_node->iwqp = iwqp;\n\tiwqp->cm_id = cm_id;\n\tirdma_qp_add_ref(&iwqp->ibqp);\n\tcm_id->add_ref(cm_id);\n\n\tif (cm_node->state != IRDMA_CM_STATE_OFFLOADED) {\n\t\tcm_node->state = IRDMA_CM_STATE_SYN_SENT;\n\t\tret = irdma_send_syn(cm_node, 0);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"CM: rem_port=0x%04x, loc_port=0x%04x rem_addr=%pI4 loc_addr=%pI4 cm_node=%p cm_id=%p qp_id = %d\\n\\n\",\n\t\t  cm_node->rem_port, cm_node->loc_port, cm_node->rem_addr,\n\t\t  cm_node->loc_addr, cm_node, cm_id, ibqp->qp_num);\n\n\ttrace_irdma_connect(cm_node, 0, NULL);\n\n\treturn 0;\n\nerr:\n\tif (cm_info.ipv4)\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: connect() FAILED: dest addr=%pI4\",\n\t\t\t  cm_info.rem_addr);\n\telse\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: connect() FAILED: dest addr=%pI6\",\n\t\t\t  cm_info.rem_addr);\n\tirdma_rem_ref_cm_node(cm_node);\n\tiwdev->cm_core.stats_connect_errs++;\n\n\treturn ret;\n}\n\n \nint irdma_create_listen(struct iw_cm_id *cm_id, int backlog)\n{\n\tstruct irdma_device *iwdev;\n\tstruct irdma_cm_listener *cm_listen_node;\n\tstruct irdma_cm_info cm_info = {};\n\tstruct sockaddr_in *laddr;\n\tstruct sockaddr_in6 *laddr6;\n\tbool wildcard = false;\n\tint err;\n\n\tiwdev = to_iwdev(cm_id->device);\n\tif (!iwdev)\n\t\treturn -EINVAL;\n\n\tladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\n\tladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\n\tcm_info.qh_qpid = iwdev->vsi.ilq->qp_id;\n\n\tif (laddr->sin_family == AF_INET) {\n\t\tif (iwdev->vsi.mtu < IRDMA_MIN_MTU_IPV4)\n\t\t\treturn -EINVAL;\n\n\t\tcm_info.ipv4 = true;\n\t\tcm_info.loc_addr[0] = ntohl(laddr->sin_addr.s_addr);\n\t\tcm_info.loc_port = ntohs(laddr->sin_port);\n\n\t\tif (laddr->sin_addr.s_addr != htonl(INADDR_ANY)) {\n\t\t\tcm_info.vlan_id = irdma_get_vlan_ipv4(cm_info.loc_addr);\n\t\t} else {\n\t\t\tcm_info.vlan_id = 0xFFFF;\n\t\t\twildcard = true;\n\t\t}\n\t} else {\n\t\tif (iwdev->vsi.mtu < IRDMA_MIN_MTU_IPV6)\n\t\t\treturn -EINVAL;\n\n\t\tcm_info.ipv4 = false;\n\t\tirdma_copy_ip_ntohl(cm_info.loc_addr,\n\t\t\t\t    laddr6->sin6_addr.in6_u.u6_addr32);\n\t\tcm_info.loc_port = ntohs(laddr6->sin6_port);\n\t\tif (ipv6_addr_type(&laddr6->sin6_addr) != IPV6_ADDR_ANY) {\n\t\t\tirdma_get_vlan_mac_ipv6(cm_info.loc_addr,\n\t\t\t\t\t\t&cm_info.vlan_id, NULL);\n\t\t} else {\n\t\t\tcm_info.vlan_id = 0xFFFF;\n\t\t\twildcard = true;\n\t\t}\n\t}\n\n\tif (cm_info.vlan_id >= VLAN_N_VID && iwdev->dcb_vlan_mode)\n\t\tcm_info.vlan_id = 0;\n\tcm_info.backlog = backlog;\n\tcm_info.cm_id = cm_id;\n\n\ttrace_irdma_create_listen(iwdev, &cm_info);\n\n\tcm_listen_node = irdma_make_listen_node(&iwdev->cm_core, iwdev,\n\t\t\t\t\t\t&cm_info);\n\tif (!cm_listen_node) {\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: cm_listen_node == NULL\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcm_id->provider_data = cm_listen_node;\n\n\tcm_listen_node->tos = cm_id->tos;\n\tif (iwdev->vsi.dscp_mode)\n\t\tcm_listen_node->user_pri =\n\t\tiwdev->vsi.dscp_map[irdma_tos2dscp(cm_id->tos)];\n\telse\n\t\tcm_listen_node->user_pri = rt_tos2priority(cm_id->tos);\n\tcm_info.user_pri = cm_listen_node->user_pri;\n\tif (!cm_listen_node->reused_node) {\n\t\tif (wildcard) {\n\t\t\terr = irdma_add_mqh(iwdev, &cm_info, cm_listen_node);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t} else {\n\t\t\tif (!iwdev->vsi.dscp_mode)\n\t\t\t\tcm_listen_node->user_pri =\n\t\t\t\tirdma_iw_get_vlan_prio(cm_info.loc_addr,\n\t\t\t\t\t\t       cm_info.user_pri,\n\t\t\t\t\t\t       cm_info.ipv4);\n\t\t\tcm_info.user_pri = cm_listen_node->user_pri;\n\t\t\terr = irdma_manage_qhash(iwdev, &cm_info,\n\t\t\t\t\t\t IRDMA_QHASH_TYPE_TCP_SYN,\n\t\t\t\t\t\t IRDMA_QHASH_MANAGE_TYPE_ADD,\n\t\t\t\t\t\t NULL, true);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\n\t\t\tcm_listen_node->qhash_set = true;\n\t\t}\n\n\t\tcm_listen_node->apbvt_entry = irdma_add_apbvt(iwdev,\n\t\t\t\t\t\t\t      cm_info.loc_port);\n\t\tif (!cm_listen_node->apbvt_entry)\n\t\t\tgoto error;\n\t}\n\tcm_id->add_ref(cm_id);\n\tcm_listen_node->cm_core->stats_listen_created++;\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"CM: loc_port=0x%04x loc_addr=%pI4 cm_listen_node=%p cm_id=%p qhash_set=%d vlan_id=%d\\n\",\n\t\t  cm_listen_node->loc_port, cm_listen_node->loc_addr,\n\t\t  cm_listen_node, cm_listen_node->cm_id,\n\t\t  cm_listen_node->qhash_set, cm_listen_node->vlan_id);\n\n\treturn 0;\n\nerror:\n\n\tirdma_cm_del_listen(&iwdev->cm_core, cm_listen_node, false);\n\n\treturn -EINVAL;\n}\n\n \nint irdma_destroy_listen(struct iw_cm_id *cm_id)\n{\n\tstruct irdma_device *iwdev;\n\n\tiwdev = to_iwdev(cm_id->device);\n\tif (cm_id->provider_data)\n\t\tirdma_cm_del_listen(&iwdev->cm_core, cm_id->provider_data,\n\t\t\t\t    true);\n\telse\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"CM: cm_id->provider_data was NULL\\n\");\n\n\tcm_id->rem_ref(cm_id);\n\n\treturn 0;\n}\n\n \nstatic void irdma_teardown_list_prep(struct irdma_cm_core *cm_core,\n\t\t\t\t     struct list_head *teardown_list,\n\t\t\t\t     u32 *ipaddr,\n\t\t\t\t     struct irdma_cm_info *nfo,\n\t\t\t\t     bool disconnect_all)\n{\n\tstruct irdma_cm_node *cm_node;\n\tint bkt;\n\n\thash_for_each_rcu(cm_core->cm_hash_tbl, bkt, cm_node, list) {\n\t\tif ((disconnect_all ||\n\t\t     (nfo->vlan_id == cm_node->vlan_id &&\n\t\t      !memcmp(cm_node->loc_addr, ipaddr, nfo->ipv4 ? 4 : 16))) &&\n\t\t    refcount_inc_not_zero(&cm_node->refcnt))\n\t\t\tlist_add(&cm_node->teardown_entry, teardown_list);\n\t}\n}\n\n \nstatic void irdma_cm_event_connected(struct irdma_cm_event *event)\n{\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_cm_node *cm_node;\n\tstruct irdma_sc_dev *dev;\n\tstruct ib_qp_attr attr = {};\n\tstruct iw_cm_id *cm_id;\n\tint status;\n\tbool read0;\n\tint wait_ret = 0;\n\n\tcm_node = event->cm_node;\n\tcm_id = cm_node->cm_id;\n\tiwqp = cm_id->provider_data;\n\tiwdev = iwqp->iwdev;\n\tdev = &iwdev->rf->sc_dev;\n\tif (iwqp->sc_qp.qp_uk.destroy_pending) {\n\t\tstatus = -ETIMEDOUT;\n\t\tgoto error;\n\t}\n\n\tirdma_cm_init_tsa_conn(iwqp, cm_node);\n\tread0 = (cm_node->send_rdma0_op == SEND_RDMA_READ_ZERO);\n\tif (iwqp->page)\n\t\tiwqp->sc_qp.qp_uk.sq_base = kmap_local_page(iwqp->page);\n\tirdma_sc_send_rtt(&iwqp->sc_qp, read0);\n\tif (iwqp->page)\n\t\tkunmap_local(iwqp->sc_qp.qp_uk.sq_base);\n\n\tattr.qp_state = IB_QPS_RTS;\n\tcm_node->qhash_set = false;\n\tirdma_modify_qp(&iwqp->ibqp, &attr, IB_QP_STATE, NULL);\n\tif (dev->hw_attrs.uk_attrs.feature_flags & IRDMA_FEATURE_RTS_AE) {\n\t\twait_ret = wait_event_interruptible_timeout(iwqp->waitq,\n\t\t\t\t\t\t\t    iwqp->rts_ae_rcvd,\n\t\t\t\t\t\t\t    IRDMA_MAX_TIMEOUT);\n\t\tif (!wait_ret)\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"CM: Slow Connection: cm_node=%p, loc_port=%d, rem_port=%d, cm_id=%p\\n\",\n\t\t\t\t  cm_node, cm_node->loc_port,\n\t\t\t\t  cm_node->rem_port, cm_node->cm_id);\n\t}\n\n\tirdma_send_cm_event(cm_node, cm_id, IW_CM_EVENT_CONNECT_REPLY, 0);\n\tcm_node->accelerated = true;\n\tcomplete(&cm_node->establish_comp);\n\tcm_node->cm_core->cm_free_ah(cm_node);\n\treturn;\n\nerror:\n\tiwqp->cm_id = NULL;\n\tcm_id->provider_data = NULL;\n\tirdma_send_cm_event(event->cm_node, cm_id, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t    status);\n\tirdma_rem_ref_cm_node(event->cm_node);\n}\n\n \nstatic void irdma_cm_event_reset(struct irdma_cm_event *event)\n{\n\tstruct irdma_cm_node *cm_node = event->cm_node;\n\tstruct iw_cm_id *cm_id = cm_node->cm_id;\n\tstruct irdma_qp *iwqp;\n\n\tif (!cm_id)\n\t\treturn;\n\n\tiwqp = cm_id->provider_data;\n\tif (!iwqp)\n\t\treturn;\n\n\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t  \"CM: reset event %p - cm_id = %p\\n\", event->cm_node, cm_id);\n\tiwqp->cm_id = NULL;\n\n\tirdma_send_cm_event(cm_node, cm_node->cm_id, IW_CM_EVENT_DISCONNECT,\n\t\t\t    -ECONNRESET);\n\tirdma_send_cm_event(cm_node, cm_node->cm_id, IW_CM_EVENT_CLOSE, 0);\n}\n\n \nstatic void irdma_cm_event_handler(struct work_struct *work)\n{\n\tstruct irdma_cm_event *event = container_of(work, struct irdma_cm_event, event_work);\n\tstruct irdma_cm_node *cm_node;\n\n\tif (!event || !event->cm_node || !event->cm_node->cm_core)\n\t\treturn;\n\n\tcm_node = event->cm_node;\n\ttrace_irdma_cm_event_handler(cm_node, event->type, NULL);\n\n\tswitch (event->type) {\n\tcase IRDMA_CM_EVENT_MPA_REQ:\n\t\tirdma_send_cm_event(cm_node, cm_node->cm_id,\n\t\t\t\t    IW_CM_EVENT_CONNECT_REQUEST, 0);\n\t\tbreak;\n\tcase IRDMA_CM_EVENT_RESET:\n\t\tirdma_cm_event_reset(event);\n\t\tbreak;\n\tcase IRDMA_CM_EVENT_CONNECTED:\n\t\tif (!event->cm_node->cm_id ||\n\t\t    event->cm_node->state != IRDMA_CM_STATE_OFFLOADED)\n\t\t\tbreak;\n\t\tirdma_cm_event_connected(event);\n\t\tbreak;\n\tcase IRDMA_CM_EVENT_MPA_REJECT:\n\t\tif (!event->cm_node->cm_id ||\n\t\t    cm_node->state == IRDMA_CM_STATE_OFFLOADED)\n\t\t\tbreak;\n\t\tirdma_send_cm_event(cm_node, cm_node->cm_id,\n\t\t\t\t    IW_CM_EVENT_CONNECT_REPLY, -ECONNREFUSED);\n\t\tbreak;\n\tcase IRDMA_CM_EVENT_ABORTED:\n\t\tif (!event->cm_node->cm_id ||\n\t\t    event->cm_node->state == IRDMA_CM_STATE_OFFLOADED)\n\t\t\tbreak;\n\t\tirdma_event_connect_error(event);\n\t\tbreak;\n\tdefault:\n\t\tibdev_dbg(&cm_node->iwdev->ibdev,\n\t\t\t  \"CM: bad event type = %d\\n\", event->type);\n\t\tbreak;\n\t}\n\n\tirdma_rem_ref_cm_node(event->cm_node);\n\tkfree(event);\n}\n\n \nstatic void irdma_cm_post_event(struct irdma_cm_event *event)\n{\n\trefcount_inc(&event->cm_node->refcnt);\n\tINIT_WORK(&event->event_work, irdma_cm_event_handler);\n\tqueue_work(event->cm_node->cm_core->event_wq, &event->event_work);\n}\n\n \nvoid irdma_cm_teardown_connections(struct irdma_device *iwdev, u32 *ipaddr,\n\t\t\t\t   struct irdma_cm_info *nfo,\n\t\t\t\t   bool disconnect_all)\n{\n\tstruct irdma_cm_core *cm_core = &iwdev->cm_core;\n\tstruct list_head *list_core_temp;\n\tstruct list_head *list_node;\n\tstruct irdma_cm_node *cm_node;\n\tstruct list_head teardown_list;\n\tstruct ib_qp_attr attr;\n\n\tINIT_LIST_HEAD(&teardown_list);\n\n\trcu_read_lock();\n\tirdma_teardown_list_prep(cm_core, &teardown_list, ipaddr, nfo, disconnect_all);\n\trcu_read_unlock();\n\n\tlist_for_each_safe (list_node, list_core_temp, &teardown_list) {\n\t\tcm_node = container_of(list_node, struct irdma_cm_node,\n\t\t\t\t       teardown_entry);\n\t\tattr.qp_state = IB_QPS_ERR;\n\t\tirdma_modify_qp(&cm_node->iwqp->ibqp, &attr, IB_QP_STATE, NULL);\n\t\tif (iwdev->rf->reset)\n\t\t\tirdma_cm_disconn(cm_node->iwqp);\n\t\tirdma_rem_ref_cm_node(cm_node);\n\t}\n}\n\n \nstatic void irdma_qhash_ctrl(struct irdma_device *iwdev,\n\t\t\t     struct irdma_cm_listener *parent_listen_node,\n\t\t\t     struct irdma_cm_info *nfo, u32 *ipaddr, bool ipv4,\n\t\t\t     bool ifup)\n{\n\tstruct list_head *child_listen_list = &parent_listen_node->child_listen_list;\n\tstruct irdma_cm_listener *child_listen_node;\n\tstruct list_head *pos, *tpos;\n\tbool node_allocated = false;\n\tenum irdma_quad_hash_manage_type op = ifup ?\n\t\t\t\t\t      IRDMA_QHASH_MANAGE_TYPE_ADD :\n\t\t\t\t\t      IRDMA_QHASH_MANAGE_TYPE_DELETE;\n\tint err;\n\n\tlist_for_each_safe (pos, tpos, child_listen_list) {\n\t\tchild_listen_node = list_entry(pos, struct irdma_cm_listener,\n\t\t\t\t\t       child_listen_list);\n\t\tif (!memcmp(child_listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16))\n\t\t\tgoto set_qhash;\n\t}\n\n\t \n\tif (!ifup)\n\t\treturn;\n\tchild_listen_node = kmemdup(parent_listen_node,\n\t\t\t\t    sizeof(*child_listen_node), GFP_ATOMIC);\n\tif (!child_listen_node)\n\t\treturn;\n\n\tnode_allocated = true;\n\tmemcpy(child_listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16);\n\nset_qhash:\n\tmemcpy(nfo->loc_addr, child_listen_node->loc_addr,\n\t       sizeof(nfo->loc_addr));\n\tnfo->vlan_id = child_listen_node->vlan_id;\n\terr = irdma_manage_qhash(iwdev, nfo, IRDMA_QHASH_TYPE_TCP_SYN, op, NULL,\n\t\t\t\t false);\n\tif (!err) {\n\t\tchild_listen_node->qhash_set = ifup;\n\t\tif (node_allocated)\n\t\t\tlist_add(&child_listen_node->child_listen_list,\n\t\t\t\t &parent_listen_node->child_listen_list);\n\t} else if (node_allocated) {\n\t\tkfree(child_listen_node);\n\t}\n}\n\n \nvoid irdma_if_notify(struct irdma_device *iwdev, struct net_device *netdev,\n\t\t     u32 *ipaddr, bool ipv4, bool ifup)\n{\n\tstruct irdma_cm_core *cm_core = &iwdev->cm_core;\n\tunsigned long flags;\n\tstruct irdma_cm_listener *listen_node;\n\tstatic const u32 ip_zero[4] = { 0, 0, 0, 0 };\n\tstruct irdma_cm_info nfo = {};\n\tu16 vlan_id = rdma_vlan_dev_vlan_id(netdev);\n\tenum irdma_quad_hash_manage_type op = ifup ?\n\t\t\t\t\t      IRDMA_QHASH_MANAGE_TYPE_ADD :\n\t\t\t\t\t      IRDMA_QHASH_MANAGE_TYPE_DELETE;\n\n\tnfo.vlan_id = vlan_id;\n\tnfo.ipv4 = ipv4;\n\tnfo.qh_qpid = 1;\n\n\t \n\tspin_lock_irqsave(&cm_core->listen_list_lock, flags);\n\tlist_for_each_entry (listen_node, &cm_core->listen_list, list) {\n\t\tif (vlan_id != listen_node->vlan_id ||\n\t\t    (memcmp(listen_node->loc_addr, ipaddr, ipv4 ? 4 : 16) &&\n\t\t     memcmp(listen_node->loc_addr, ip_zero, ipv4 ? 4 : 16)))\n\t\t\tcontinue;\n\n\t\tmemcpy(nfo.loc_addr, listen_node->loc_addr,\n\t\t       sizeof(nfo.loc_addr));\n\t\tnfo.loc_port = listen_node->loc_port;\n\t\tnfo.user_pri = listen_node->user_pri;\n\t\tif (!list_empty(&listen_node->child_listen_list)) {\n\t\t\tirdma_qhash_ctrl(iwdev, listen_node, &nfo, ipaddr, ipv4,\n\t\t\t\t\t ifup);\n\t\t} else if (memcmp(listen_node->loc_addr, ip_zero,\n\t\t\t\t  ipv4 ? 4 : 16)) {\n\t\t\tif (!irdma_manage_qhash(iwdev, &nfo,\n\t\t\t\t\t\tIRDMA_QHASH_TYPE_TCP_SYN, op,\n\t\t\t\t\t\tNULL, false))\n\t\t\t\tlisten_node->qhash_set = ifup;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&cm_core->listen_list_lock, flags);\n\n\t \n\tif (!ifup)\n\t\tirdma_cm_teardown_connections(iwdev, ipaddr, &nfo, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}