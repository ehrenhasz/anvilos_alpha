{
  "module_name": "pble.c",
  "hash_id": "ad00e3a09fcf7319c6503f8d639d05aa9efe6305b7a34d935ca0c7d4872668a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/pble.c",
  "human_readable_source": "\n \n#include \"osdep.h\"\n#include \"hmc.h\"\n#include \"defs.h\"\n#include \"type.h\"\n#include \"protos.h\"\n#include \"pble.h\"\n\nstatic int add_pble_prm(struct irdma_hmc_pble_rsrc *pble_rsrc);\n\n \nvoid irdma_destroy_pble_prm(struct irdma_hmc_pble_rsrc *pble_rsrc)\n{\n\tstruct irdma_chunk *chunk;\n\tstruct irdma_pble_prm *pinfo = &pble_rsrc->pinfo;\n\n\twhile (!list_empty(&pinfo->clist)) {\n\t\tchunk = (struct irdma_chunk *) pinfo->clist.next;\n\t\tlist_del(&chunk->list);\n\t\tif (chunk->type == PBLE_SD_PAGED)\n\t\t\tirdma_pble_free_paged_mem(chunk);\n\t\tbitmap_free(chunk->bitmapbuf);\n\t\tkfree(chunk->chunkmem.va);\n\t}\n}\n\n \nint irdma_hmc_init_pble(struct irdma_sc_dev *dev,\n\t\t\tstruct irdma_hmc_pble_rsrc *pble_rsrc)\n{\n\tstruct irdma_hmc_info *hmc_info;\n\tu32 fpm_idx = 0;\n\tint status = 0;\n\n\thmc_info = dev->hmc_info;\n\tpble_rsrc->dev = dev;\n\tpble_rsrc->fpm_base_addr = hmc_info->hmc_obj[IRDMA_HMC_IW_PBLE].base;\n\t \n\tif (pble_rsrc->fpm_base_addr & 0xfff)\n\t\tfpm_idx = (4096 - (pble_rsrc->fpm_base_addr & 0xfff)) >> 3;\n\tpble_rsrc->unallocated_pble =\n\t\thmc_info->hmc_obj[IRDMA_HMC_IW_PBLE].cnt - fpm_idx;\n\tpble_rsrc->next_fpm_addr = pble_rsrc->fpm_base_addr + (fpm_idx << 3);\n\tpble_rsrc->pinfo.pble_shift = PBLE_SHIFT;\n\n\tmutex_init(&pble_rsrc->pble_mutex_lock);\n\n\tspin_lock_init(&pble_rsrc->pinfo.prm_lock);\n\tINIT_LIST_HEAD(&pble_rsrc->pinfo.clist);\n\tif (add_pble_prm(pble_rsrc)) {\n\t\tirdma_destroy_pble_prm(pble_rsrc);\n\t\tstatus = -ENOMEM;\n\t}\n\n\treturn status;\n}\n\n \nstatic void get_sd_pd_idx(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\t  struct sd_pd_idx *idx)\n{\n\tidx->sd_idx = (u32)pble_rsrc->next_fpm_addr / IRDMA_HMC_DIRECT_BP_SIZE;\n\tidx->pd_idx = (u32)(pble_rsrc->next_fpm_addr / IRDMA_HMC_PAGED_BP_SIZE);\n\tidx->rel_pd_idx = (idx->pd_idx % IRDMA_HMC_PD_CNT_IN_SD);\n}\n\n \nstatic int add_sd_direct(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\t struct irdma_add_page_info *info)\n{\n\tstruct irdma_sc_dev *dev = pble_rsrc->dev;\n\tint ret_code = 0;\n\tstruct sd_pd_idx *idx = &info->idx;\n\tstruct irdma_chunk *chunk = info->chunk;\n\tstruct irdma_hmc_info *hmc_info = info->hmc_info;\n\tstruct irdma_hmc_sd_entry *sd_entry = info->sd_entry;\n\tu32 offset = 0;\n\n\tif (!sd_entry->valid) {\n\t\tret_code = irdma_add_sd_table_entry(dev->hw, hmc_info,\n\t\t\t\t\t\t    info->idx.sd_idx,\n\t\t\t\t\t\t    IRDMA_SD_TYPE_DIRECT,\n\t\t\t\t\t\t    IRDMA_HMC_DIRECT_BP_SIZE);\n\t\tif (ret_code)\n\t\t\treturn ret_code;\n\n\t\tchunk->type = PBLE_SD_CONTIGOUS;\n\t}\n\n\toffset = idx->rel_pd_idx << HMC_PAGED_BP_SHIFT;\n\tchunk->size = info->pages << HMC_PAGED_BP_SHIFT;\n\tchunk->vaddr = sd_entry->u.bp.addr.va + offset;\n\tchunk->fpm_addr = pble_rsrc->next_fpm_addr;\n\tibdev_dbg(to_ibdev(dev),\n\t\t  \"PBLE: chunk_size[%lld] = 0x%llx vaddr=0x%pK fpm_addr = %llx\\n\",\n\t\t  chunk->size, chunk->size, chunk->vaddr, chunk->fpm_addr);\n\n\treturn 0;\n}\n\n \nstatic u32 fpm_to_idx(struct irdma_hmc_pble_rsrc *pble_rsrc, u64 addr)\n{\n\tu64 idx;\n\n\tidx = (addr - (pble_rsrc->fpm_base_addr)) >> 3;\n\n\treturn (u32)idx;\n}\n\n \nstatic int add_bp_pages(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\tstruct irdma_add_page_info *info)\n{\n\tstruct irdma_sc_dev *dev = pble_rsrc->dev;\n\tu8 *addr;\n\tstruct irdma_dma_mem mem;\n\tstruct irdma_hmc_pd_entry *pd_entry;\n\tstruct irdma_hmc_sd_entry *sd_entry = info->sd_entry;\n\tstruct irdma_hmc_info *hmc_info = info->hmc_info;\n\tstruct irdma_chunk *chunk = info->chunk;\n\tint status = 0;\n\tu32 rel_pd_idx = info->idx.rel_pd_idx;\n\tu32 pd_idx = info->idx.pd_idx;\n\tu32 i;\n\n\tif (irdma_pble_get_paged_mem(chunk, info->pages))\n\t\treturn -ENOMEM;\n\n\tstatus = irdma_add_sd_table_entry(dev->hw, hmc_info, info->idx.sd_idx,\n\t\t\t\t\t  IRDMA_SD_TYPE_PAGED,\n\t\t\t\t\t  IRDMA_HMC_DIRECT_BP_SIZE);\n\tif (status)\n\t\tgoto error;\n\n\taddr = chunk->vaddr;\n\tfor (i = 0; i < info->pages; i++) {\n\t\tmem.pa = (u64)chunk->dmainfo.dmaaddrs[i];\n\t\tmem.size = 4096;\n\t\tmem.va = addr;\n\t\tpd_entry = &sd_entry->u.pd_table.pd_entry[rel_pd_idx++];\n\t\tif (!pd_entry->valid) {\n\t\t\tstatus = irdma_add_pd_table_entry(dev, hmc_info,\n\t\t\t\t\t\t\t  pd_idx++, &mem);\n\t\t\tif (status)\n\t\t\t\tgoto error;\n\n\t\t\taddr += 4096;\n\t\t}\n\t}\n\n\tchunk->fpm_addr = pble_rsrc->next_fpm_addr;\n\treturn 0;\n\nerror:\n\tirdma_pble_free_paged_mem(chunk);\n\n\treturn status;\n}\n\n \nstatic enum irdma_sd_entry_type irdma_get_type(struct irdma_sc_dev *dev,\n\t\t\t\t\t       struct sd_pd_idx *idx, u32 pages)\n{\n\tenum irdma_sd_entry_type sd_entry_type;\n\n\tsd_entry_type = !idx->rel_pd_idx && pages == IRDMA_HMC_PD_CNT_IN_SD ?\n\t\t\tIRDMA_SD_TYPE_DIRECT : IRDMA_SD_TYPE_PAGED;\n\treturn sd_entry_type;\n}\n\n \nstatic int add_pble_prm(struct irdma_hmc_pble_rsrc *pble_rsrc)\n{\n\tstruct irdma_sc_dev *dev = pble_rsrc->dev;\n\tstruct irdma_hmc_sd_entry *sd_entry;\n\tstruct irdma_hmc_info *hmc_info;\n\tstruct irdma_chunk *chunk;\n\tstruct irdma_add_page_info info;\n\tstruct sd_pd_idx *idx = &info.idx;\n\tint ret_code = 0;\n\tenum irdma_sd_entry_type sd_entry_type;\n\tu64 sd_reg_val = 0;\n\tstruct irdma_virt_mem chunkmem;\n\tu32 pages;\n\n\tif (pble_rsrc->unallocated_pble < PBLE_PER_PAGE)\n\t\treturn -ENOMEM;\n\n\tif (pble_rsrc->next_fpm_addr & 0xfff)\n\t\treturn -EINVAL;\n\n\tchunkmem.size = sizeof(*chunk);\n\tchunkmem.va = kzalloc(chunkmem.size, GFP_KERNEL);\n\tif (!chunkmem.va)\n\t\treturn -ENOMEM;\n\n\tchunk = chunkmem.va;\n\tchunk->chunkmem = chunkmem;\n\thmc_info = dev->hmc_info;\n\tchunk->dev = dev;\n\tchunk->fpm_addr = pble_rsrc->next_fpm_addr;\n\tget_sd_pd_idx(pble_rsrc, idx);\n\tsd_entry = &hmc_info->sd_table.sd_entry[idx->sd_idx];\n\tpages = (idx->rel_pd_idx) ? (IRDMA_HMC_PD_CNT_IN_SD - idx->rel_pd_idx) :\n\t\t\t\t    IRDMA_HMC_PD_CNT_IN_SD;\n\tpages = min(pages, pble_rsrc->unallocated_pble >> PBLE_512_SHIFT);\n\tinfo.chunk = chunk;\n\tinfo.hmc_info = hmc_info;\n\tinfo.pages = pages;\n\tinfo.sd_entry = sd_entry;\n\tif (!sd_entry->valid)\n\t\tsd_entry_type = irdma_get_type(dev, idx, pages);\n\telse\n\t\tsd_entry_type = sd_entry->entry_type;\n\n\tibdev_dbg(to_ibdev(dev),\n\t\t  \"PBLE: pages = %d, unallocated_pble[%d] current_fpm_addr = %llx\\n\",\n\t\t  pages, pble_rsrc->unallocated_pble,\n\t\t  pble_rsrc->next_fpm_addr);\n\tibdev_dbg(to_ibdev(dev), \"PBLE: sd_entry_type = %d\\n\", sd_entry_type);\n\tif (sd_entry_type == IRDMA_SD_TYPE_DIRECT)\n\t\tret_code = add_sd_direct(pble_rsrc, &info);\n\n\tif (ret_code)\n\t\tsd_entry_type = IRDMA_SD_TYPE_PAGED;\n\telse\n\t\tpble_rsrc->stats_direct_sds++;\n\n\tif (sd_entry_type == IRDMA_SD_TYPE_PAGED) {\n\t\tret_code = add_bp_pages(pble_rsrc, &info);\n\t\tif (ret_code)\n\t\t\tgoto error;\n\t\telse\n\t\t\tpble_rsrc->stats_paged_sds++;\n\t}\n\n\tret_code = irdma_prm_add_pble_mem(&pble_rsrc->pinfo, chunk);\n\tif (ret_code)\n\t\tgoto error;\n\n\tpble_rsrc->next_fpm_addr += chunk->size;\n\tibdev_dbg(to_ibdev(dev),\n\t\t  \"PBLE: next_fpm_addr = %llx chunk_size[%llu] = 0x%llx\\n\",\n\t\t  pble_rsrc->next_fpm_addr, chunk->size, chunk->size);\n\tpble_rsrc->unallocated_pble -= (u32)(chunk->size >> 3);\n\tsd_reg_val = (sd_entry_type == IRDMA_SD_TYPE_PAGED) ?\n\t\t\t     sd_entry->u.pd_table.pd_page_addr.pa :\n\t\t\t     sd_entry->u.bp.addr.pa;\n\n\tif (!sd_entry->valid) {\n\t\tret_code = irdma_hmc_sd_one(dev, hmc_info->hmc_fn_id, sd_reg_val,\n\t\t\t\t\t    idx->sd_idx, sd_entry->entry_type, true);\n\t\tif (ret_code)\n\t\t\tgoto error;\n\t}\n\n\tlist_add(&chunk->list, &pble_rsrc->pinfo.clist);\n\tsd_entry->valid = true;\n\treturn 0;\n\nerror:\n\tbitmap_free(chunk->bitmapbuf);\n\tkfree(chunk->chunkmem.va);\n\n\treturn ret_code;\n}\n\n \nstatic void free_lvl2(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t      struct irdma_pble_alloc *palloc)\n{\n\tu32 i;\n\tstruct irdma_pble_level2 *lvl2 = &palloc->level2;\n\tstruct irdma_pble_info *root = &lvl2->root;\n\tstruct irdma_pble_info *leaf = lvl2->leaf;\n\n\tfor (i = 0; i < lvl2->leaf_cnt; i++, leaf++) {\n\t\tif (leaf->addr)\n\t\t\tirdma_prm_return_pbles(&pble_rsrc->pinfo,\n\t\t\t\t\t       &leaf->chunkinfo);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (root->addr)\n\t\tirdma_prm_return_pbles(&pble_rsrc->pinfo, &root->chunkinfo);\n\n\tkfree(lvl2->leafmem.va);\n\tlvl2->leaf = NULL;\n}\n\n \nstatic int get_lvl2_pble(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\t struct irdma_pble_alloc *palloc)\n{\n\tu32 lf4k, lflast, total, i;\n\tu32 pblcnt = PBLE_PER_PAGE;\n\tu64 *addr;\n\tstruct irdma_pble_level2 *lvl2 = &palloc->level2;\n\tstruct irdma_pble_info *root = &lvl2->root;\n\tstruct irdma_pble_info *leaf;\n\tint ret_code;\n\tu64 fpm_addr;\n\n\t \n\tlf4k = palloc->total_cnt >> 9;\n\tlflast = palloc->total_cnt % PBLE_PER_PAGE;\n\ttotal = (lflast == 0) ? lf4k : lf4k + 1;\n\tlvl2->leaf_cnt = total;\n\n\tlvl2->leafmem.size = (sizeof(*leaf) * total);\n\tlvl2->leafmem.va = kzalloc(lvl2->leafmem.size, GFP_KERNEL);\n\tif (!lvl2->leafmem.va)\n\t\treturn -ENOMEM;\n\n\tlvl2->leaf = lvl2->leafmem.va;\n\tleaf = lvl2->leaf;\n\tret_code = irdma_prm_get_pbles(&pble_rsrc->pinfo, &root->chunkinfo,\n\t\t\t\t       total << 3, &root->addr, &fpm_addr);\n\tif (ret_code) {\n\t\tkfree(lvl2->leafmem.va);\n\t\tlvl2->leaf = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\troot->idx = fpm_to_idx(pble_rsrc, fpm_addr);\n\troot->cnt = total;\n\taddr = root->addr;\n\tfor (i = 0; i < total; i++, leaf++) {\n\t\tpblcnt = (lflast && ((i + 1) == total)) ?\n\t\t\t\tlflast : PBLE_PER_PAGE;\n\t\tret_code = irdma_prm_get_pbles(&pble_rsrc->pinfo,\n\t\t\t\t\t       &leaf->chunkinfo, pblcnt << 3,\n\t\t\t\t\t       &leaf->addr, &fpm_addr);\n\t\tif (ret_code)\n\t\t\tgoto error;\n\n\t\tleaf->idx = fpm_to_idx(pble_rsrc, fpm_addr);\n\n\t\tleaf->cnt = pblcnt;\n\t\t*addr = (u64)leaf->idx;\n\t\taddr++;\n\t}\n\n\tpalloc->level = PBLE_LEVEL_2;\n\tpble_rsrc->stats_lvl2++;\n\treturn 0;\n\nerror:\n\tfree_lvl2(pble_rsrc, palloc);\n\n\treturn -ENOMEM;\n}\n\n \nstatic int get_lvl1_pble(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\t struct irdma_pble_alloc *palloc)\n{\n\tint ret_code;\n\tu64 fpm_addr;\n\tstruct irdma_pble_info *lvl1 = &palloc->level1;\n\n\tret_code = irdma_prm_get_pbles(&pble_rsrc->pinfo, &lvl1->chunkinfo,\n\t\t\t\t       palloc->total_cnt << 3, &lvl1->addr,\n\t\t\t\t       &fpm_addr);\n\tif (ret_code)\n\t\treturn -ENOMEM;\n\n\tpalloc->level = PBLE_LEVEL_1;\n\tlvl1->idx = fpm_to_idx(pble_rsrc, fpm_addr);\n\tlvl1->cnt = palloc->total_cnt;\n\tpble_rsrc->stats_lvl1++;\n\n\treturn 0;\n}\n\n \nstatic int get_lvl1_lvl2_pble(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t\t      struct irdma_pble_alloc *palloc, u8 lvl)\n{\n\tint status = 0;\n\n\tstatus = get_lvl1_pble(pble_rsrc, palloc);\n\tif (!status || lvl == PBLE_LEVEL_1 || palloc->total_cnt <= PBLE_PER_PAGE)\n\t\treturn status;\n\n\tstatus = get_lvl2_pble(pble_rsrc, palloc);\n\n\treturn status;\n}\n\n \nint irdma_get_pble(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t   struct irdma_pble_alloc *palloc, u32 pble_cnt,\n\t\t   u8 lvl)\n{\n\tint status = 0;\n\tint max_sds = 0;\n\tint i;\n\n\tpalloc->total_cnt = pble_cnt;\n\tpalloc->level = PBLE_LEVEL_0;\n\n\tmutex_lock(&pble_rsrc->pble_mutex_lock);\n\n\t \n\tstatus = get_lvl1_lvl2_pble(pble_rsrc, palloc, lvl);\n\tif (!status)\n\t\tgoto exit;\n\n\tmax_sds = (palloc->total_cnt >> 18) + 1;\n\tfor (i = 0; i < max_sds; i++) {\n\t\tstatus = add_pble_prm(pble_rsrc);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tstatus = get_lvl1_lvl2_pble(pble_rsrc, palloc, lvl);\n\t\t \n\t\tif (!status || lvl)\n\t\t\tbreak;\n\t}\n\nexit:\n\tif (!status) {\n\t\tpble_rsrc->allocdpbles += pble_cnt;\n\t\tpble_rsrc->stats_alloc_ok++;\n\t} else {\n\t\tpble_rsrc->stats_alloc_fail++;\n\t}\n\tmutex_unlock(&pble_rsrc->pble_mutex_lock);\n\n\treturn status;\n}\n\n \nvoid irdma_free_pble(struct irdma_hmc_pble_rsrc *pble_rsrc,\n\t\t     struct irdma_pble_alloc *palloc)\n{\n\tpble_rsrc->freedpbles += palloc->total_cnt;\n\n\tif (palloc->level == PBLE_LEVEL_2)\n\t\tfree_lvl2(pble_rsrc, palloc);\n\telse\n\t\tirdma_prm_return_pbles(&pble_rsrc->pinfo,\n\t\t\t\t       &palloc->level1.chunkinfo);\n\tpble_rsrc->stats_alloc_freed++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}