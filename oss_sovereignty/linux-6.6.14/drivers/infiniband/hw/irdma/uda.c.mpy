{
  "module_name": "uda.c",
  "hash_id": "75dca2a43035776de365f4a23f1ab3cb4d4f113efbdbbbe7e23d1667bfada67b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/uda.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n\n#include \"osdep.h\"\n#include \"hmc.h\"\n#include \"defs.h\"\n#include \"type.h\"\n#include \"protos.h\"\n#include \"uda.h\"\n#include \"uda_d.h\"\n\n \nint irdma_sc_access_ah(struct irdma_sc_cqp *cqp, struct irdma_ah_info *info,\n\t\t       u32 op, u64 scratch)\n{\n\t__le64 *wqe;\n\tu64 qw1, qw2;\n\n\twqe = irdma_sc_cqp_get_next_send_wqe(cqp, scratch);\n\tif (!wqe)\n\t\treturn -ENOMEM;\n\n\tset_64bit_val(wqe, 0, ether_addr_to_u64(info->mac_addr) << 16);\n\tqw1 = FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_PDINDEXLO, info->pd_idx) |\n\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_TC, info->tc_tos) |\n\t      FIELD_PREP(IRDMA_UDAQPC_VLANTAG, info->vlan_tag);\n\n\tqw2 = FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ARPINDEX, info->dst_arpindex) |\n\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_FLOWLABEL, info->flow_label) |\n\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_HOPLIMIT, info->hop_ttl) |\n\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_PDINDEXHI, info->pd_idx >> 16);\n\n\tif (!info->ipv4_valid) {\n\t\tset_64bit_val(wqe, 40,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR0, info->dest_ip_addr[0]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR1, info->dest_ip_addr[1]));\n\t\tset_64bit_val(wqe, 32,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR2, info->dest_ip_addr[2]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->dest_ip_addr[3]));\n\n\t\tset_64bit_val(wqe, 56,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR0, info->src_ip_addr[0]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR1, info->src_ip_addr[1]));\n\t\tset_64bit_val(wqe, 48,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR2, info->src_ip_addr[2]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->src_ip_addr[3]));\n\t} else {\n\t\tset_64bit_val(wqe, 32,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->dest_ip_addr[0]));\n\n\t\tset_64bit_val(wqe, 48,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->src_ip_addr[0]));\n\t}\n\n\tset_64bit_val(wqe, 8, qw1);\n\tset_64bit_val(wqe, 16, qw2);\n\n\tdma_wmb();  \n\n\tset_64bit_val(\n\t\twqe, 24,\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_WQEVALID, cqp->polarity) |\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_OPCODE, op) |\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_DOLOOPBACKK, info->do_lpbk) |\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_IPV4VALID, info->ipv4_valid) |\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_AVIDX, info->ah_idx) |\n\t\tFIELD_PREP(IRDMA_UDA_CQPSQ_MAV_INSERTVLANTAG, info->insert_vlan_tag));\n\n\tprint_hex_dump_debug(\"WQE: MANAGE_AH WQE\", DUMP_PREFIX_OFFSET, 16, 8,\n\t\t\t     wqe, IRDMA_CQP_WQE_SIZE * 8, false);\n\tirdma_sc_cqp_post_sq(cqp);\n\n\treturn 0;\n}\n\n \nstatic void irdma_create_mg_ctx(struct irdma_mcast_grp_info *info)\n{\n\tstruct irdma_mcast_grp_ctx_entry_info *entry_info = NULL;\n\tu8 idx = 0;  \n\tu8 ctx_idx = 0;  \n\n\tmemset(info->dma_mem_mc.va, 0, IRDMA_MAX_MGS_PER_CTX * sizeof(u64));\n\n\tfor (idx = 0; idx < IRDMA_MAX_MGS_PER_CTX; idx++) {\n\t\tentry_info = &info->mg_ctx_info[idx];\n\t\tif (entry_info->valid_entry) {\n\t\t\tset_64bit_val((__le64 *)info->dma_mem_mc.va,\n\t\t\t\t      ctx_idx * sizeof(u64),\n\t\t\t\t      FIELD_PREP(IRDMA_UDA_MGCTX_DESTPORT, entry_info->dest_port) |\n\t\t\t\t      FIELD_PREP(IRDMA_UDA_MGCTX_VALIDENT, entry_info->valid_entry) |\n\t\t\t\t      FIELD_PREP(IRDMA_UDA_MGCTX_QPID, entry_info->qp_id));\n\t\t\tctx_idx++;\n\t\t}\n\t}\n}\n\n \nint irdma_access_mcast_grp(struct irdma_sc_cqp *cqp,\n\t\t\t   struct irdma_mcast_grp_info *info, u32 op,\n\t\t\t   u64 scratch)\n{\n\t__le64 *wqe;\n\n\tif (info->mg_id >= IRDMA_UDA_MAX_FSI_MGS) {\n\t\tibdev_dbg(to_ibdev(cqp->dev), \"WQE: mg_id out of range\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twqe = irdma_sc_cqp_get_next_send_wqe(cqp, scratch);\n\tif (!wqe) {\n\t\tibdev_dbg(to_ibdev(cqp->dev), \"WQE: ring full\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirdma_create_mg_ctx(info);\n\n\tset_64bit_val(wqe, 32, info->dma_mem_mc.pa);\n\tset_64bit_val(wqe, 16,\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_VLANID, info->vlan_id) |\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_QS_HANDLE, info->qs_handle));\n\tset_64bit_val(wqe, 0, ether_addr_to_u64(info->dest_mac_addr));\n\tset_64bit_val(wqe, 8,\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_HMC_FCN_ID, info->hmc_fcn_id));\n\n\tif (!info->ipv4_valid) {\n\t\tset_64bit_val(wqe, 56,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR0, info->dest_ip_addr[0]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR1, info->dest_ip_addr[1]));\n\t\tset_64bit_val(wqe, 48,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR2, info->dest_ip_addr[2]) |\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->dest_ip_addr[3]));\n\t} else {\n\t\tset_64bit_val(wqe, 48,\n\t\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MAV_ADDR3, info->dest_ip_addr[0]));\n\t}\n\n\tdma_wmb();  \n\n\tset_64bit_val(wqe, 24,\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_WQEVALID, cqp->polarity) |\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_OPCODE, op) |\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_MGIDX, info->mg_id) |\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_VLANVALID, info->vlan_valid) |\n\t\t      FIELD_PREP(IRDMA_UDA_CQPSQ_MG_IPV4VALID, info->ipv4_valid));\n\n\tprint_hex_dump_debug(\"WQE: MANAGE_MCG WQE\", DUMP_PREFIX_OFFSET, 16, 8,\n\t\t\t     wqe, IRDMA_CQP_WQE_SIZE * 8, false);\n\tprint_hex_dump_debug(\"WQE: MCG_HOST CTX WQE\", DUMP_PREFIX_OFFSET, 16,\n\t\t\t     8, info->dma_mem_mc.va,\n\t\t\t     IRDMA_MAX_MGS_PER_CTX * 8, false);\n\tirdma_sc_cqp_post_sq(cqp);\n\n\treturn 0;\n}\n\n \nstatic bool irdma_compare_mgs(struct irdma_mcast_grp_ctx_entry_info *entry1,\n\t\t\t      struct irdma_mcast_grp_ctx_entry_info *entry2)\n{\n\tif (entry1->dest_port == entry2->dest_port &&\n\t    entry1->qp_id == entry2->qp_id)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nint irdma_sc_add_mcast_grp(struct irdma_mcast_grp_info *ctx,\n\t\t\t   struct irdma_mcast_grp_ctx_entry_info *mg)\n{\n\tu32 idx;\n\tbool free_entry_found = false;\n\tu32 free_entry_idx = 0;\n\n\t \n\tfor (idx = 0; idx < IRDMA_MAX_MGS_PER_CTX; idx++) {\n\t\tif (ctx->mg_ctx_info[idx].valid_entry) {\n\t\t\tif (irdma_compare_mgs(&ctx->mg_ctx_info[idx], mg)) {\n\t\t\t\tctx->mg_ctx_info[idx].use_cnt++;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!free_entry_found) {\n\t\t\tfree_entry_found = true;\n\t\t\tfree_entry_idx = idx;\n\t\t}\n\t}\n\n\tif (free_entry_found) {\n\t\tctx->mg_ctx_info[free_entry_idx] = *mg;\n\t\tctx->mg_ctx_info[free_entry_idx].valid_entry = true;\n\t\tctx->mg_ctx_info[free_entry_idx].use_cnt = 1;\n\t\tctx->no_of_mgs++;\n\t\treturn 0;\n\t}\n\n\treturn -ENOMEM;\n}\n\n \nint irdma_sc_del_mcast_grp(struct irdma_mcast_grp_info *ctx,\n\t\t\t   struct irdma_mcast_grp_ctx_entry_info *mg)\n{\n\tu32 idx;\n\n\t \n\tfor (idx = 0; idx < IRDMA_MAX_MGS_PER_CTX; idx++) {\n\t\tif (!ctx->mg_ctx_info[idx].valid_entry)\n\t\t\tcontinue;\n\n\t\tif (irdma_compare_mgs(mg, &ctx->mg_ctx_info[idx])) {\n\t\t\tctx->mg_ctx_info[idx].use_cnt--;\n\n\t\t\tif (!ctx->mg_ctx_info[idx].use_cnt) {\n\t\t\t\tctx->mg_ctx_info[idx].valid_entry = false;\n\t\t\t\tctx->no_of_mgs--;\n\t\t\t\t \n\t\t\t\tif (idx != ctx->no_of_mgs &&\n\t\t\t\t    ctx->no_of_mgs > 0) {\n\t\t\t\t\tmemcpy(&ctx->mg_ctx_info[idx],\n\t\t\t\t\t       &ctx->mg_ctx_info[ctx->no_of_mgs - 1],\n\t\t\t\t\t       sizeof(ctx->mg_ctx_info[idx]));\n\t\t\t\t\tctx->mg_ctx_info[ctx->no_of_mgs - 1].valid_entry = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}