{
  "module_name": "verbs.c",
  "hash_id": "6f9cbead80d69b418c530196a8483a114f4ee95268fccc1eb6c0fb8170aff16b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/verbs.c",
  "human_readable_source": "\n \n#include \"main.h\"\n\n \nstatic int irdma_query_device(struct ib_device *ibdev,\n\t\t\t      struct ib_device_attr *props,\n\t\t\t      struct ib_udata *udata)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct pci_dev *pcidev = iwdev->rf->pcidev;\n\tstruct irdma_hw_attrs *hw_attrs = &rf->sc_dev.hw_attrs;\n\n\tif (udata->inlen || udata->outlen)\n\t\treturn -EINVAL;\n\n\tmemset(props, 0, sizeof(*props));\n\taddrconf_addr_eui48((u8 *)&props->sys_image_guid,\n\t\t\t    iwdev->netdev->dev_addr);\n\tprops->fw_ver = (u64)irdma_fw_major_ver(&rf->sc_dev) << 32 |\n\t\t\tirdma_fw_minor_ver(&rf->sc_dev);\n\tprops->device_cap_flags = IB_DEVICE_MEM_WINDOW |\n\t\t\t\t  IB_DEVICE_MEM_MGT_EXTENSIONS;\n\tprops->kernel_cap_flags = IBK_LOCAL_DMA_LKEY;\n\tprops->vendor_id = pcidev->vendor;\n\tprops->vendor_part_id = pcidev->device;\n\n\tprops->hw_ver = rf->pcidev->revision;\n\tprops->page_size_cap = hw_attrs->page_size_cap;\n\tprops->max_mr_size = hw_attrs->max_mr_size;\n\tprops->max_qp = rf->max_qp - rf->used_qps;\n\tprops->max_qp_wr = hw_attrs->max_qp_wr;\n\tprops->max_send_sge = hw_attrs->uk_attrs.max_hw_wq_frags;\n\tprops->max_recv_sge = hw_attrs->uk_attrs.max_hw_wq_frags;\n\tprops->max_cq = rf->max_cq - rf->used_cqs;\n\tprops->max_cqe = rf->max_cqe - 1;\n\tprops->max_mr = rf->max_mr - rf->used_mrs;\n\tprops->max_mw = props->max_mr;\n\tprops->max_pd = rf->max_pd - rf->used_pds;\n\tprops->max_sge_rd = hw_attrs->uk_attrs.max_hw_read_sges;\n\tprops->max_qp_rd_atom = hw_attrs->max_hw_ird;\n\tprops->max_qp_init_rd_atom = hw_attrs->max_hw_ord;\n\tif (rdma_protocol_roce(ibdev, 1)) {\n\t\tprops->device_cap_flags |= IB_DEVICE_RC_RNR_NAK_GEN;\n\t\tprops->max_pkeys = IRDMA_PKEY_TBL_SZ;\n\t}\n\n\tprops->max_ah = rf->max_ah;\n\tprops->max_mcast_grp = rf->max_mcg;\n\tprops->max_mcast_qp_attach = IRDMA_MAX_MGS_PER_CTX;\n\tprops->max_total_mcast_qp_attach = rf->max_qp * IRDMA_MAX_MGS_PER_CTX;\n\tprops->max_fast_reg_page_list_len = IRDMA_MAX_PAGES_PER_FMR;\n#define HCA_CLOCK_TIMESTAMP_MASK 0x1ffff\n\tif (hw_attrs->uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\tprops->timestamp_mask = HCA_CLOCK_TIMESTAMP_MASK;\n\n\treturn 0;\n}\n\n \nstatic int irdma_query_port(struct ib_device *ibdev, u32 port,\n\t\t\t    struct ib_port_attr *props)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct net_device *netdev = iwdev->netdev;\n\n\t \n\n\tprops->max_mtu = IB_MTU_4096;\n\tprops->active_mtu = ib_mtu_int_to_enum(netdev->mtu);\n\tprops->lid = 1;\n\tprops->lmc = 0;\n\tprops->sm_lid = 0;\n\tprops->sm_sl = 0;\n\tif (netif_carrier_ok(netdev) && netif_running(netdev)) {\n\t\tprops->state = IB_PORT_ACTIVE;\n\t\tprops->phys_state = IB_PORT_PHYS_STATE_LINK_UP;\n\t} else {\n\t\tprops->state = IB_PORT_DOWN;\n\t\tprops->phys_state = IB_PORT_PHYS_STATE_DISABLED;\n\t}\n\n\tib_get_eth_speed(ibdev, port, &props->active_speed,\n\t\t\t &props->active_width);\n\n\tif (rdma_protocol_roce(ibdev, 1)) {\n\t\tprops->gid_tbl_len = 32;\n\t\tprops->ip_gids = true;\n\t\tprops->pkey_tbl_len = IRDMA_PKEY_TBL_SZ;\n\t} else {\n\t\tprops->gid_tbl_len = 1;\n\t}\n\tprops->qkey_viol_cntr = 0;\n\tprops->port_cap_flags |= IB_PORT_CM_SUP | IB_PORT_REINIT_SUP;\n\tprops->max_msg_sz = iwdev->rf->sc_dev.hw_attrs.max_hw_outbound_msg_size;\n\n\treturn 0;\n}\n\n \nstatic void irdma_disassociate_ucontext(struct ib_ucontext *context)\n{\n}\n\nstatic int irdma_mmap_legacy(struct irdma_ucontext *ucontext,\n\t\t\t     struct vm_area_struct *vma)\n{\n\tu64 pfn;\n\n\tif (vma->vm_pgoff || vma->vm_end - vma->vm_start != PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tvma->vm_private_data = ucontext;\n\tpfn = ((uintptr_t)ucontext->iwdev->rf->sc_dev.hw_regs[IRDMA_DB_ADDR_OFFSET] +\n\t       pci_resource_start(ucontext->iwdev->rf->pcidev, 0)) >> PAGE_SHIFT;\n\n\treturn rdma_user_mmap_io(&ucontext->ibucontext, vma, pfn, PAGE_SIZE,\n\t\t\t\t pgprot_noncached(vma->vm_page_prot), NULL);\n}\n\nstatic void irdma_mmap_free(struct rdma_user_mmap_entry *rdma_entry)\n{\n\tstruct irdma_user_mmap_entry *entry = to_irdma_mmap_entry(rdma_entry);\n\n\tkfree(entry);\n}\n\nstatic struct rdma_user_mmap_entry*\nirdma_user_mmap_entry_insert(struct irdma_ucontext *ucontext, u64 bar_offset,\n\t\t\t     enum irdma_mmap_flag mmap_flag, u64 *mmap_offset)\n{\n\tstruct irdma_user_mmap_entry *entry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tint ret;\n\n\tif (!entry)\n\t\treturn NULL;\n\n\tentry->bar_offset = bar_offset;\n\tentry->mmap_flag = mmap_flag;\n\n\tret = rdma_user_mmap_entry_insert(&ucontext->ibucontext,\n\t\t\t\t\t  &entry->rdma_entry, PAGE_SIZE);\n\tif (ret) {\n\t\tkfree(entry);\n\t\treturn NULL;\n\t}\n\t*mmap_offset = rdma_user_mmap_get_offset(&entry->rdma_entry);\n\n\treturn &entry->rdma_entry;\n}\n\n \nstatic int irdma_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\n{\n\tstruct rdma_user_mmap_entry *rdma_entry;\n\tstruct irdma_user_mmap_entry *entry;\n\tstruct irdma_ucontext *ucontext;\n\tu64 pfn;\n\tint ret;\n\n\tucontext = to_ucontext(context);\n\n\t \n\tif (ucontext->legacy_mode)\n\t\treturn irdma_mmap_legacy(ucontext, vma);\n\n\trdma_entry = rdma_user_mmap_entry_get(&ucontext->ibucontext, vma);\n\tif (!rdma_entry) {\n\t\tibdev_dbg(&ucontext->iwdev->ibdev,\n\t\t\t  \"VERBS: pgoff[0x%lx] does not have valid entry\\n\",\n\t\t\t  vma->vm_pgoff);\n\t\treturn -EINVAL;\n\t}\n\n\tentry = to_irdma_mmap_entry(rdma_entry);\n\tibdev_dbg(&ucontext->iwdev->ibdev,\n\t\t  \"VERBS: bar_offset [0x%llx] mmap_flag [%d]\\n\",\n\t\t  entry->bar_offset, entry->mmap_flag);\n\n\tpfn = (entry->bar_offset +\n\t      pci_resource_start(ucontext->iwdev->rf->pcidev, 0)) >> PAGE_SHIFT;\n\n\tswitch (entry->mmap_flag) {\n\tcase IRDMA_MMAP_IO_NC:\n\t\tret = rdma_user_mmap_io(context, vma, pfn, PAGE_SIZE,\n\t\t\t\t\tpgprot_noncached(vma->vm_page_prot),\n\t\t\t\t\trdma_entry);\n\t\tbreak;\n\tcase IRDMA_MMAP_IO_WC:\n\t\tret = rdma_user_mmap_io(context, vma, pfn, PAGE_SIZE,\n\t\t\t\t\tpgprot_writecombine(vma->vm_page_prot),\n\t\t\t\t\trdma_entry);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tibdev_dbg(&ucontext->iwdev->ibdev,\n\t\t\t  \"VERBS: bar_offset [0x%llx] mmap_flag[%d] err[%d]\\n\",\n\t\t\t  entry->bar_offset, entry->mmap_flag, ret);\n\trdma_user_mmap_entry_put(rdma_entry);\n\n\treturn ret;\n}\n\n \nstatic void irdma_alloc_push_page(struct irdma_qp *iwqp)\n{\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_sc_qp *qp = &iwqp->sc_qp;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn;\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = IRDMA_OP_MANAGE_PUSH_PAGE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.manage_push_page.info.push_idx = 0;\n\tcqp_info->in.u.manage_push_page.info.qs_handle =\n\t\tqp->vsi->qos[qp->user_pri].qs_handle;\n\tcqp_info->in.u.manage_push_page.info.free_page = 0;\n\tcqp_info->in.u.manage_push_page.info.push_page_type = 0;\n\tcqp_info->in.u.manage_push_page.cqp = &iwdev->rf->cqp.sc_cqp;\n\tcqp_info->in.u.manage_push_page.scratch = (uintptr_t)cqp_request;\n\n\tstatus = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tif (!status && cqp_request->compl_info.op_ret_val <\n\t    iwdev->rf->sc_dev.hw_attrs.max_hw_device_pages) {\n\t\tqp->push_idx = cqp_request->compl_info.op_ret_val;\n\t\tqp->push_offset = 0;\n\t}\n\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n}\n\n \nstatic int irdma_alloc_ucontext(struct ib_ucontext *uctx,\n\t\t\t\tstruct ib_udata *udata)\n{\n#define IRDMA_ALLOC_UCTX_MIN_REQ_LEN offsetofend(struct irdma_alloc_ucontext_req, rsvd8)\n#define IRDMA_ALLOC_UCTX_MIN_RESP_LEN offsetofend(struct irdma_alloc_ucontext_resp, rsvd)\n\tstruct ib_device *ibdev = uctx->device;\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_alloc_ucontext_req req = {};\n\tstruct irdma_alloc_ucontext_resp uresp = {};\n\tstruct irdma_ucontext *ucontext = to_ucontext(uctx);\n\tstruct irdma_uk_attrs *uk_attrs = &iwdev->rf->sc_dev.hw_attrs.uk_attrs;\n\n\tif (udata->inlen < IRDMA_ALLOC_UCTX_MIN_REQ_LEN ||\n\t    udata->outlen < IRDMA_ALLOC_UCTX_MIN_RESP_LEN)\n\t\treturn -EINVAL;\n\n\tif (ib_copy_from_udata(&req, udata, min(sizeof(req), udata->inlen)))\n\t\treturn -EINVAL;\n\n\tif (req.userspace_ver < 4 || req.userspace_ver > IRDMA_ABI_VER)\n\t\tgoto ver_error;\n\n\tucontext->iwdev = iwdev;\n\tucontext->abi_ver = req.userspace_ver;\n\n\tif (req.comp_mask & IRDMA_ALLOC_UCTX_USE_RAW_ATTR)\n\t\tucontext->use_raw_attrs = true;\n\n\t \n\tif (udata->outlen == IRDMA_ALLOC_UCTX_MIN_RESP_LEN) {\n\t\tif (uk_attrs->hw_rev != IRDMA_GEN_1)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tucontext->legacy_mode = true;\n\t\turesp.max_qps = iwdev->rf->max_qp;\n\t\turesp.max_pds = iwdev->rf->sc_dev.hw_attrs.max_hw_pds;\n\t\turesp.wq_size = iwdev->rf->sc_dev.hw_attrs.max_qp_wr * 2;\n\t\turesp.kernel_ver = req.userspace_ver;\n\t\tif (ib_copy_to_udata(udata, &uresp,\n\t\t\t\t     min(sizeof(uresp), udata->outlen)))\n\t\t\treturn -EFAULT;\n\t} else {\n\t\tu64 bar_off = (uintptr_t)iwdev->rf->sc_dev.hw_regs[IRDMA_DB_ADDR_OFFSET];\n\n\t\tucontext->db_mmap_entry =\n\t\t\tirdma_user_mmap_entry_insert(ucontext, bar_off,\n\t\t\t\t\t\t     IRDMA_MMAP_IO_NC,\n\t\t\t\t\t\t     &uresp.db_mmap_key);\n\t\tif (!ucontext->db_mmap_entry)\n\t\t\treturn -ENOMEM;\n\n\t\turesp.kernel_ver = IRDMA_ABI_VER;\n\t\turesp.feature_flags = uk_attrs->feature_flags;\n\t\turesp.max_hw_wq_frags = uk_attrs->max_hw_wq_frags;\n\t\turesp.max_hw_read_sges = uk_attrs->max_hw_read_sges;\n\t\turesp.max_hw_inline = uk_attrs->max_hw_inline;\n\t\turesp.max_hw_rq_quanta = uk_attrs->max_hw_rq_quanta;\n\t\turesp.max_hw_wq_quanta = uk_attrs->max_hw_wq_quanta;\n\t\turesp.max_hw_sq_chunk = uk_attrs->max_hw_sq_chunk;\n\t\turesp.max_hw_cq_size = uk_attrs->max_hw_cq_size;\n\t\turesp.min_hw_cq_size = uk_attrs->min_hw_cq_size;\n\t\turesp.hw_rev = uk_attrs->hw_rev;\n\t\turesp.comp_mask |= IRDMA_ALLOC_UCTX_USE_RAW_ATTR;\n\t\turesp.min_hw_wq_size = uk_attrs->min_hw_wq_size;\n\t\turesp.comp_mask |= IRDMA_ALLOC_UCTX_MIN_HW_WQ_SIZE;\n\t\tif (ib_copy_to_udata(udata, &uresp,\n\t\t\t\t     min(sizeof(uresp), udata->outlen))) {\n\t\t\trdma_user_mmap_entry_remove(ucontext->db_mmap_entry);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&ucontext->cq_reg_mem_list);\n\tspin_lock_init(&ucontext->cq_reg_mem_list_lock);\n\tINIT_LIST_HEAD(&ucontext->qp_reg_mem_list);\n\tspin_lock_init(&ucontext->qp_reg_mem_list_lock);\n\n\treturn 0;\n\nver_error:\n\tibdev_err(&iwdev->ibdev,\n\t\t  \"Invalid userspace driver version detected. Detected version %d, should be %d\\n\",\n\t\t  req.userspace_ver, IRDMA_ABI_VER);\n\treturn -EINVAL;\n}\n\n \nstatic void irdma_dealloc_ucontext(struct ib_ucontext *context)\n{\n\tstruct irdma_ucontext *ucontext = to_ucontext(context);\n\n\trdma_user_mmap_entry_remove(ucontext->db_mmap_entry);\n}\n\n \nstatic int irdma_alloc_pd(struct ib_pd *pd, struct ib_udata *udata)\n{\n#define IRDMA_ALLOC_PD_MIN_RESP_LEN offsetofend(struct irdma_alloc_pd_resp, rsvd)\n\tstruct irdma_pd *iwpd = to_iwpd(pd);\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct irdma_alloc_pd_resp uresp = {};\n\tstruct irdma_sc_pd *sc_pd;\n\tu32 pd_id = 0;\n\tint err;\n\n\tif (udata && udata->outlen < IRDMA_ALLOC_PD_MIN_RESP_LEN)\n\t\treturn -EINVAL;\n\n\terr = irdma_alloc_rsrc(rf, rf->allocated_pds, rf->max_pd, &pd_id,\n\t\t\t       &rf->next_pd);\n\tif (err)\n\t\treturn err;\n\n\tsc_pd = &iwpd->sc_pd;\n\tif (udata) {\n\t\tstruct irdma_ucontext *ucontext =\n\t\t\trdma_udata_to_drv_context(udata, struct irdma_ucontext,\n\t\t\t\t\t\t  ibucontext);\n\t\tirdma_sc_pd_init(dev, sc_pd, pd_id, ucontext->abi_ver);\n\t\turesp.pd_id = pd_id;\n\t\tif (ib_copy_to_udata(udata, &uresp,\n\t\t\t\t     min(sizeof(uresp), udata->outlen))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tirdma_sc_pd_init(dev, sc_pd, pd_id, IRDMA_ABI_VER);\n\t}\n\n\treturn 0;\nerror:\n\tirdma_free_rsrc(rf, rf->allocated_pds, pd_id);\n\n\treturn err;\n}\n\n \nstatic int irdma_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata)\n{\n\tstruct irdma_pd *iwpd = to_iwpd(ibpd);\n\tstruct irdma_device *iwdev = to_iwdev(ibpd->device);\n\n\tirdma_free_rsrc(iwdev->rf, iwdev->rf->allocated_pds, iwpd->sc_pd.pd_id);\n\n\treturn 0;\n}\n\n \nstatic struct irdma_pbl *irdma_get_pbl(unsigned long va,\n\t\t\t\t       struct list_head *pbl_list)\n{\n\tstruct irdma_pbl *iwpbl;\n\n\tlist_for_each_entry (iwpbl, pbl_list, list) {\n\t\tif (iwpbl->user_base == va) {\n\t\t\tlist_del(&iwpbl->list);\n\t\t\tiwpbl->on_list = false;\n\t\t\treturn iwpbl;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic void irdma_clean_cqes(struct irdma_qp *iwqp, struct irdma_cq *iwcq)\n{\n\tstruct irdma_cq_uk *ukcq = &iwcq->sc_cq.cq_uk;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\tirdma_uk_clean_cq(&iwqp->sc_qp.qp_uk, ukcq);\n\tspin_unlock_irqrestore(&iwcq->lock, flags);\n}\n\nstatic void irdma_remove_push_mmap_entries(struct irdma_qp *iwqp)\n{\n\tif (iwqp->push_db_mmap_entry) {\n\t\trdma_user_mmap_entry_remove(iwqp->push_db_mmap_entry);\n\t\tiwqp->push_db_mmap_entry = NULL;\n\t}\n\tif (iwqp->push_wqe_mmap_entry) {\n\t\trdma_user_mmap_entry_remove(iwqp->push_wqe_mmap_entry);\n\t\tiwqp->push_wqe_mmap_entry = NULL;\n\t}\n}\n\nstatic int irdma_setup_push_mmap_entries(struct irdma_ucontext *ucontext,\n\t\t\t\t\t struct irdma_qp *iwqp,\n\t\t\t\t\t u64 *push_wqe_mmap_key,\n\t\t\t\t\t u64 *push_db_mmap_key)\n{\n\tstruct irdma_device *iwdev = ucontext->iwdev;\n\tu64 rsvd, bar_off;\n\n\trsvd = IRDMA_PF_BAR_RSVD;\n\tbar_off = (uintptr_t)iwdev->rf->sc_dev.hw_regs[IRDMA_DB_ADDR_OFFSET];\n\t \n\tbar_off += IRDMA_HW_PAGE_SIZE;\n\t \n\tbar_off += rsvd + iwqp->sc_qp.push_idx * IRDMA_HW_PAGE_SIZE;\n\tiwqp->push_wqe_mmap_entry = irdma_user_mmap_entry_insert(ucontext,\n\t\t\t\t\tbar_off, IRDMA_MMAP_IO_WC,\n\t\t\t\t\tpush_wqe_mmap_key);\n\tif (!iwqp->push_wqe_mmap_entry)\n\t\treturn -ENOMEM;\n\n\t \n\tbar_off += IRDMA_HW_PAGE_SIZE;\n\tiwqp->push_db_mmap_entry = irdma_user_mmap_entry_insert(ucontext,\n\t\t\t\t\tbar_off, IRDMA_MMAP_IO_NC,\n\t\t\t\t\tpush_db_mmap_key);\n\tif (!iwqp->push_db_mmap_entry) {\n\t\trdma_user_mmap_entry_remove(iwqp->push_wqe_mmap_entry);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int irdma_destroy_qp(struct ib_qp *ibqp, struct ib_udata *udata)\n{\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\n\tiwqp->sc_qp.qp_uk.destroy_pending = true;\n\n\tif (iwqp->iwarp_state == IRDMA_QP_STATE_RTS)\n\t\tirdma_modify_qp_to_err(&iwqp->sc_qp);\n\n\tif (!iwqp->user_mode)\n\t\tcancel_delayed_work_sync(&iwqp->dwork_flush);\n\n\tif (!iwqp->user_mode) {\n\t\tif (iwqp->iwscq) {\n\t\t\tirdma_clean_cqes(iwqp, iwqp->iwscq);\n\t\t\tif (iwqp->iwrcq != iwqp->iwscq)\n\t\t\t\tirdma_clean_cqes(iwqp, iwqp->iwrcq);\n\t\t}\n\t}\n\n\tirdma_qp_rem_ref(&iwqp->ibqp);\n\twait_for_completion(&iwqp->free_qp);\n\tirdma_free_lsmm_rsrc(iwqp);\n\tirdma_cqp_qp_destroy_cmd(&iwdev->rf->sc_dev, &iwqp->sc_qp);\n\n\tirdma_remove_push_mmap_entries(iwqp);\n\tirdma_free_qp_rsrc(iwqp);\n\n\treturn 0;\n}\n\n \nstatic void irdma_setup_virt_qp(struct irdma_device *iwdev,\n\t\t\t       struct irdma_qp *iwqp,\n\t\t\t       struct irdma_qp_init_info *init_info)\n{\n\tstruct irdma_pbl *iwpbl = iwqp->iwpbl;\n\tstruct irdma_qp_mr *qpmr = &iwpbl->qp_mr;\n\n\tiwqp->page = qpmr->sq_page;\n\tinit_info->shadow_area_pa = qpmr->shadow;\n\tif (iwpbl->pbl_allocated) {\n\t\tinit_info->virtual_map = true;\n\t\tinit_info->sq_pa = qpmr->sq_pbl.idx;\n\t\tinit_info->rq_pa = qpmr->rq_pbl.idx;\n\t} else {\n\t\tinit_info->sq_pa = qpmr->sq_pbl.addr;\n\t\tinit_info->rq_pa = qpmr->rq_pbl.addr;\n\t}\n}\n\n \nstatic int irdma_setup_umode_qp(struct ib_udata *udata,\n\t\t\t\tstruct irdma_device *iwdev,\n\t\t\t\tstruct irdma_qp *iwqp,\n\t\t\t\tstruct irdma_qp_init_info *info,\n\t\t\t\tstruct ib_qp_init_attr *init_attr)\n{\n\tstruct irdma_ucontext *ucontext = rdma_udata_to_drv_context(udata,\n\t\t\t\tstruct irdma_ucontext, ibucontext);\n\tstruct irdma_qp_uk_init_info *ukinfo = &info->qp_uk_init_info;\n\tstruct irdma_create_qp_req req;\n\tunsigned long flags;\n\tint ret;\n\n\tret = ib_copy_from_udata(&req, udata,\n\t\t\t\t min(sizeof(req), udata->inlen));\n\tif (ret) {\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: ib_copy_from_data fail\\n\");\n\t\treturn ret;\n\t}\n\n\tiwqp->ctx_info.qp_compl_ctx = req.user_compl_ctx;\n\tiwqp->user_mode = 1;\n\tif (req.user_wqe_bufs) {\n\t\tinfo->qp_uk_init_info.legacy_mode = ucontext->legacy_mode;\n\t\tspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\n\t\tiwqp->iwpbl = irdma_get_pbl((unsigned long)req.user_wqe_bufs,\n\t\t\t\t\t    &ucontext->qp_reg_mem_list);\n\t\tspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\n\n\t\tif (!iwqp->iwpbl) {\n\t\t\tret = -ENODATA;\n\t\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: no pbl info\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!ucontext->use_raw_attrs) {\n\t\t \n\t\tiwqp->max_send_wr = init_attr->cap.max_send_wr;\n\t\tiwqp->max_recv_wr = init_attr->cap.max_recv_wr;\n\t\tukinfo->sq_size = init_attr->cap.max_send_wr;\n\t\tukinfo->rq_size = init_attr->cap.max_recv_wr;\n\t\tirdma_uk_calc_shift_wq(ukinfo, &ukinfo->sq_shift,\n\t\t\t\t       &ukinfo->rq_shift);\n\t} else {\n\t\tret = irdma_uk_calc_depth_shift_sq(ukinfo, &ukinfo->sq_depth,\n\t\t\t\t\t\t   &ukinfo->sq_shift);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = irdma_uk_calc_depth_shift_rq(ukinfo, &ukinfo->rq_depth,\n\t\t\t\t\t\t   &ukinfo->rq_shift);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tiwqp->max_send_wr =\n\t\t\t(ukinfo->sq_depth - IRDMA_SQ_RSVD) >> ukinfo->sq_shift;\n\t\tiwqp->max_recv_wr =\n\t\t\t(ukinfo->rq_depth - IRDMA_RQ_RSVD) >> ukinfo->rq_shift;\n\t\tukinfo->sq_size = ukinfo->sq_depth >> ukinfo->sq_shift;\n\t\tukinfo->rq_size = ukinfo->rq_depth >> ukinfo->rq_shift;\n\t}\n\n\tirdma_setup_virt_qp(iwdev, iwqp, info);\n\n\treturn 0;\n}\n\n \nstatic int irdma_setup_kmode_qp(struct irdma_device *iwdev,\n\t\t\t\tstruct irdma_qp *iwqp,\n\t\t\t\tstruct irdma_qp_init_info *info,\n\t\t\t\tstruct ib_qp_init_attr *init_attr)\n{\n\tstruct irdma_dma_mem *mem = &iwqp->kqp.dma_mem;\n\tu32 size;\n\tint status;\n\tstruct irdma_qp_uk_init_info *ukinfo = &info->qp_uk_init_info;\n\n\tstatus = irdma_uk_calc_depth_shift_sq(ukinfo, &ukinfo->sq_depth,\n\t\t\t\t\t      &ukinfo->sq_shift);\n\tif (status)\n\t\treturn status;\n\n\tstatus = irdma_uk_calc_depth_shift_rq(ukinfo, &ukinfo->rq_depth,\n\t\t\t\t\t      &ukinfo->rq_shift);\n\tif (status)\n\t\treturn status;\n\n\tiwqp->kqp.sq_wrid_mem =\n\t\tkcalloc(ukinfo->sq_depth, sizeof(*iwqp->kqp.sq_wrid_mem), GFP_KERNEL);\n\tif (!iwqp->kqp.sq_wrid_mem)\n\t\treturn -ENOMEM;\n\n\tiwqp->kqp.rq_wrid_mem =\n\t\tkcalloc(ukinfo->rq_depth, sizeof(*iwqp->kqp.rq_wrid_mem), GFP_KERNEL);\n\n\tif (!iwqp->kqp.rq_wrid_mem) {\n\t\tkfree(iwqp->kqp.sq_wrid_mem);\n\t\tiwqp->kqp.sq_wrid_mem = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tukinfo->sq_wrtrk_array = iwqp->kqp.sq_wrid_mem;\n\tukinfo->rq_wrid_array = iwqp->kqp.rq_wrid_mem;\n\n\tsize = (ukinfo->sq_depth + ukinfo->rq_depth) * IRDMA_QP_WQE_MIN_SIZE;\n\tsize += (IRDMA_SHADOW_AREA_SIZE << 3);\n\n\tmem->size = ALIGN(size, 256);\n\tmem->va = dma_alloc_coherent(iwdev->rf->hw.device, mem->size,\n\t\t\t\t     &mem->pa, GFP_KERNEL);\n\tif (!mem->va) {\n\t\tkfree(iwqp->kqp.sq_wrid_mem);\n\t\tiwqp->kqp.sq_wrid_mem = NULL;\n\t\tkfree(iwqp->kqp.rq_wrid_mem);\n\t\tiwqp->kqp.rq_wrid_mem = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tukinfo->sq = mem->va;\n\tinfo->sq_pa = mem->pa;\n\tukinfo->rq = &ukinfo->sq[ukinfo->sq_depth];\n\tinfo->rq_pa = info->sq_pa + (ukinfo->sq_depth * IRDMA_QP_WQE_MIN_SIZE);\n\tukinfo->shadow_area = ukinfo->rq[ukinfo->rq_depth].elem;\n\tinfo->shadow_area_pa =\n\t\tinfo->rq_pa + (ukinfo->rq_depth * IRDMA_QP_WQE_MIN_SIZE);\n\tukinfo->sq_size = ukinfo->sq_depth >> ukinfo->sq_shift;\n\tukinfo->rq_size = ukinfo->rq_depth >> ukinfo->rq_shift;\n\tukinfo->qp_id = iwqp->ibqp.qp_num;\n\n\tiwqp->max_send_wr = (ukinfo->sq_depth - IRDMA_SQ_RSVD) >> ukinfo->sq_shift;\n\tiwqp->max_recv_wr = (ukinfo->rq_depth - IRDMA_RQ_RSVD) >> ukinfo->rq_shift;\n\tinit_attr->cap.max_send_wr = iwqp->max_send_wr;\n\tinit_attr->cap.max_recv_wr = iwqp->max_recv_wr;\n\n\treturn 0;\n}\n\nstatic int irdma_cqp_create_qp_cmd(struct irdma_qp *iwqp)\n{\n\tstruct irdma_pci_f *rf = iwqp->iwdev->rf;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_create_qp_info *qp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tqp_info = &cqp_request->info.in.u.qp_create.info;\n\tmemset(qp_info, 0, sizeof(*qp_info));\n\tqp_info->mac_valid = true;\n\tqp_info->cq_num_valid = true;\n\tqp_info->next_iwarp_state = IRDMA_QP_STATE_IDLE;\n\n\tcqp_info->cqp_cmd = IRDMA_OP_QP_CREATE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.qp_create.qp = &iwqp->sc_qp;\n\tcqp_info->in.u.qp_create.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\n\treturn status;\n}\n\nstatic void irdma_roce_fill_and_set_qpctx_info(struct irdma_qp *iwqp,\n\t\t\t\t\t       struct irdma_qp_host_ctx_info *ctx_info)\n{\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_roce_offload_info *roce_info;\n\tstruct irdma_udp_offload_info *udp_info;\n\n\tudp_info = &iwqp->udp_info;\n\tudp_info->snd_mss = ib_mtu_enum_to_int(ib_mtu_int_to_enum(iwdev->vsi.mtu));\n\tudp_info->cwnd = iwdev->roce_cwnd;\n\tudp_info->rexmit_thresh = 2;\n\tudp_info->rnr_nak_thresh = 2;\n\tudp_info->src_port = 0xc000;\n\tudp_info->dst_port = ROCE_V2_UDP_DPORT;\n\troce_info = &iwqp->roce_info;\n\tether_addr_copy(roce_info->mac_addr, iwdev->netdev->dev_addr);\n\n\troce_info->rd_en = true;\n\troce_info->wr_rdresp_en = true;\n\troce_info->bind_en = true;\n\troce_info->dcqcn_en = false;\n\troce_info->rtomin = 5;\n\n\troce_info->ack_credits = iwdev->roce_ackcreds;\n\troce_info->ird_size = dev->hw_attrs.max_hw_ird;\n\troce_info->ord_size = dev->hw_attrs.max_hw_ord;\n\n\tif (!iwqp->user_mode) {\n\t\troce_info->priv_mode_en = true;\n\t\troce_info->fast_reg_en = true;\n\t\troce_info->udprivcq_en = true;\n\t}\n\troce_info->roce_tver = 0;\n\n\tctx_info->roce_info = &iwqp->roce_info;\n\tctx_info->udp_info = &iwqp->udp_info;\n\tirdma_sc_qp_setctx_roce(&iwqp->sc_qp, iwqp->host_ctx.va, ctx_info);\n}\n\nstatic void irdma_iw_fill_and_set_qpctx_info(struct irdma_qp *iwqp,\n\t\t\t\t\t     struct irdma_qp_host_ctx_info *ctx_info)\n{\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_iwarp_offload_info *iwarp_info;\n\n\tiwarp_info = &iwqp->iwarp_info;\n\tether_addr_copy(iwarp_info->mac_addr, iwdev->netdev->dev_addr);\n\tiwarp_info->rd_en = true;\n\tiwarp_info->wr_rdresp_en = true;\n\tiwarp_info->bind_en = true;\n\tiwarp_info->ecn_en = true;\n\tiwarp_info->rtomin = 5;\n\n\tif (dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\tiwarp_info->ib_rd_en = true;\n\tif (!iwqp->user_mode) {\n\t\tiwarp_info->priv_mode_en = true;\n\t\tiwarp_info->fast_reg_en = true;\n\t}\n\tiwarp_info->ddp_ver = 1;\n\tiwarp_info->rdmap_ver = 1;\n\n\tctx_info->iwarp_info = &iwqp->iwarp_info;\n\tctx_info->iwarp_info_valid = true;\n\tirdma_sc_qp_setctx(&iwqp->sc_qp, iwqp->host_ctx.va, ctx_info);\n\tctx_info->iwarp_info_valid = false;\n}\n\nstatic int irdma_validate_qp_attrs(struct ib_qp_init_attr *init_attr,\n\t\t\t\t   struct irdma_device *iwdev)\n{\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_uk_attrs *uk_attrs = &dev->hw_attrs.uk_attrs;\n\n\tif (init_attr->create_flags)\n\t\treturn -EOPNOTSUPP;\n\n\tif (init_attr->cap.max_inline_data > uk_attrs->max_hw_inline ||\n\t    init_attr->cap.max_send_sge > uk_attrs->max_hw_wq_frags ||\n\t    init_attr->cap.max_recv_sge > uk_attrs->max_hw_wq_frags)\n\t\treturn -EINVAL;\n\n\tif (rdma_protocol_roce(&iwdev->ibdev, 1)) {\n\t\tif (init_attr->qp_type != IB_QPT_RC &&\n\t\t    init_attr->qp_type != IB_QPT_UD &&\n\t\t    init_attr->qp_type != IB_QPT_GSI)\n\t\t\treturn -EOPNOTSUPP;\n\t} else {\n\t\tif (init_attr->qp_type != IB_QPT_RC)\n\t\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void irdma_flush_worker(struct work_struct *work)\n{\n\tstruct delayed_work *dwork = to_delayed_work(work);\n\tstruct irdma_qp *iwqp = container_of(dwork, struct irdma_qp, dwork_flush);\n\n\tirdma_generate_flush_completions(iwqp);\n}\n\n \nstatic int irdma_create_qp(struct ib_qp *ibqp,\n\t\t\t   struct ib_qp_init_attr *init_attr,\n\t\t\t   struct ib_udata *udata)\n{\n#define IRDMA_CREATE_QP_MIN_REQ_LEN offsetofend(struct irdma_create_qp_req, user_compl_ctx)\n#define IRDMA_CREATE_QP_MIN_RESP_LEN offsetofend(struct irdma_create_qp_resp, rsvd)\n\tstruct ib_pd *ibpd = ibqp->pd;\n\tstruct irdma_pd *iwpd = to_iwpd(ibpd);\n\tstruct irdma_device *iwdev = to_iwdev(ibpd->device);\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_create_qp_resp uresp = {};\n\tu32 qp_num = 0;\n\tint err_code;\n\tstruct irdma_sc_qp *qp;\n\tstruct irdma_sc_dev *dev = &rf->sc_dev;\n\tstruct irdma_uk_attrs *uk_attrs = &dev->hw_attrs.uk_attrs;\n\tstruct irdma_qp_init_info init_info = {};\n\tstruct irdma_qp_host_ctx_info *ctx_info;\n\n\terr_code = irdma_validate_qp_attrs(init_attr, iwdev);\n\tif (err_code)\n\t\treturn err_code;\n\n\tif (udata && (udata->inlen < IRDMA_CREATE_QP_MIN_REQ_LEN ||\n\t\t      udata->outlen < IRDMA_CREATE_QP_MIN_RESP_LEN))\n\t\treturn -EINVAL;\n\n\tinit_info.vsi = &iwdev->vsi;\n\tinit_info.qp_uk_init_info.uk_attrs = uk_attrs;\n\tinit_info.qp_uk_init_info.sq_size = init_attr->cap.max_send_wr;\n\tinit_info.qp_uk_init_info.rq_size = init_attr->cap.max_recv_wr;\n\tinit_info.qp_uk_init_info.max_sq_frag_cnt = init_attr->cap.max_send_sge;\n\tinit_info.qp_uk_init_info.max_rq_frag_cnt = init_attr->cap.max_recv_sge;\n\tinit_info.qp_uk_init_info.max_inline_data = init_attr->cap.max_inline_data;\n\n\tqp = &iwqp->sc_qp;\n\tqp->qp_uk.back_qp = iwqp;\n\tqp->push_idx = IRDMA_INVALID_PUSH_PAGE_INDEX;\n\n\tiwqp->iwdev = iwdev;\n\tiwqp->q2_ctx_mem.size = ALIGN(IRDMA_Q2_BUF_SIZE + IRDMA_QP_CTX_SIZE,\n\t\t\t\t      256);\n\tiwqp->q2_ctx_mem.va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t\t iwqp->q2_ctx_mem.size,\n\t\t\t\t\t\t &iwqp->q2_ctx_mem.pa,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!iwqp->q2_ctx_mem.va)\n\t\treturn -ENOMEM;\n\n\tinit_info.q2 = iwqp->q2_ctx_mem.va;\n\tinit_info.q2_pa = iwqp->q2_ctx_mem.pa;\n\tinit_info.host_ctx = (__le64 *)(init_info.q2 + IRDMA_Q2_BUF_SIZE);\n\tinit_info.host_ctx_pa = init_info.q2_pa + IRDMA_Q2_BUF_SIZE;\n\n\tif (init_attr->qp_type == IB_QPT_GSI)\n\t\tqp_num = 1;\n\telse\n\t\terr_code = irdma_alloc_rsrc(rf, rf->allocated_qps, rf->max_qp,\n\t\t\t\t\t    &qp_num, &rf->next_qp);\n\tif (err_code)\n\t\tgoto error;\n\n\tiwqp->iwpd = iwpd;\n\tiwqp->ibqp.qp_num = qp_num;\n\tqp = &iwqp->sc_qp;\n\tiwqp->iwscq = to_iwcq(init_attr->send_cq);\n\tiwqp->iwrcq = to_iwcq(init_attr->recv_cq);\n\tiwqp->host_ctx.va = init_info.host_ctx;\n\tiwqp->host_ctx.pa = init_info.host_ctx_pa;\n\tiwqp->host_ctx.size = IRDMA_QP_CTX_SIZE;\n\n\tinit_info.pd = &iwpd->sc_pd;\n\tinit_info.qp_uk_init_info.qp_id = iwqp->ibqp.qp_num;\n\tif (!rdma_protocol_roce(&iwdev->ibdev, 1))\n\t\tinit_info.qp_uk_init_info.first_sq_wq = 1;\n\tiwqp->ctx_info.qp_compl_ctx = (uintptr_t)qp;\n\tinit_waitqueue_head(&iwqp->waitq);\n\tinit_waitqueue_head(&iwqp->mod_qp_waitq);\n\n\tif (udata) {\n\t\tinit_info.qp_uk_init_info.abi_ver = iwpd->sc_pd.abi_ver;\n\t\terr_code = irdma_setup_umode_qp(udata, iwdev, iwqp, &init_info,\n\t\t\t\t\t\tinit_attr);\n\t} else {\n\t\tINIT_DELAYED_WORK(&iwqp->dwork_flush, irdma_flush_worker);\n\t\tinit_info.qp_uk_init_info.abi_ver = IRDMA_ABI_VER;\n\t\terr_code = irdma_setup_kmode_qp(iwdev, iwqp, &init_info, init_attr);\n\t}\n\n\tif (err_code) {\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: setup qp failed\\n\");\n\t\tgoto error;\n\t}\n\n\tif (rdma_protocol_roce(&iwdev->ibdev, 1)) {\n\t\tif (init_attr->qp_type == IB_QPT_RC) {\n\t\t\tinit_info.qp_uk_init_info.type = IRDMA_QP_TYPE_ROCE_RC;\n\t\t\tinit_info.qp_uk_init_info.qp_caps = IRDMA_SEND_WITH_IMM |\n\t\t\t\t\t\t\t    IRDMA_WRITE_WITH_IMM |\n\t\t\t\t\t\t\t    IRDMA_ROCE;\n\t\t} else {\n\t\t\tinit_info.qp_uk_init_info.type = IRDMA_QP_TYPE_ROCE_UD;\n\t\t\tinit_info.qp_uk_init_info.qp_caps = IRDMA_SEND_WITH_IMM |\n\t\t\t\t\t\t\t    IRDMA_ROCE;\n\t\t}\n\t} else {\n\t\tinit_info.qp_uk_init_info.type = IRDMA_QP_TYPE_IWARP;\n\t\tinit_info.qp_uk_init_info.qp_caps = IRDMA_WRITE_WITH_IMM;\n\t}\n\n\tif (dev->hw_attrs.uk_attrs.hw_rev > IRDMA_GEN_1)\n\t\tinit_info.qp_uk_init_info.qp_caps |= IRDMA_PUSH_MODE;\n\n\terr_code = irdma_sc_qp_init(qp, &init_info);\n\tif (err_code) {\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: qp_init fail\\n\");\n\t\tgoto error;\n\t}\n\n\tctx_info = &iwqp->ctx_info;\n\tctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\n\tctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\n\n\tif (rdma_protocol_roce(&iwdev->ibdev, 1))\n\t\tirdma_roce_fill_and_set_qpctx_info(iwqp, ctx_info);\n\telse\n\t\tirdma_iw_fill_and_set_qpctx_info(iwqp, ctx_info);\n\n\terr_code = irdma_cqp_create_qp_cmd(iwqp);\n\tif (err_code)\n\t\tgoto error;\n\n\trefcount_set(&iwqp->refcnt, 1);\n\tspin_lock_init(&iwqp->lock);\n\tspin_lock_init(&iwqp->sc_qp.pfpdu.lock);\n\tiwqp->sig_all = init_attr->sq_sig_type == IB_SIGNAL_ALL_WR;\n\trf->qp_table[qp_num] = iwqp;\n\n\tif (rdma_protocol_roce(&iwdev->ibdev, 1)) {\n\t\tif (dev->ws_add(&iwdev->vsi, 0)) {\n\t\t\tirdma_cqp_qp_destroy_cmd(&rf->sc_dev, &iwqp->sc_qp);\n\t\t\terr_code = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\tirdma_qp_add_qos(&iwqp->sc_qp);\n\t}\n\n\tif (udata) {\n\t\t \n\t\tif (udata->outlen < sizeof(uresp)) {\n\t\t\turesp.lsmm = 1;\n\t\t\turesp.push_idx = IRDMA_INVALID_PUSH_PAGE_INDEX_GEN_1;\n\t\t} else {\n\t\t\tif (rdma_protocol_iwarp(&iwdev->ibdev, 1))\n\t\t\t\turesp.lsmm = 1;\n\t\t}\n\t\turesp.actual_sq_size = init_info.qp_uk_init_info.sq_size;\n\t\turesp.actual_rq_size = init_info.qp_uk_init_info.rq_size;\n\t\turesp.qp_id = qp_num;\n\t\turesp.qp_caps = qp->qp_uk.qp_caps;\n\n\t\terr_code = ib_copy_to_udata(udata, &uresp,\n\t\t\t\t\t    min(sizeof(uresp), udata->outlen));\n\t\tif (err_code) {\n\t\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: copy_to_udata failed\\n\");\n\t\t\tirdma_destroy_qp(&iwqp->ibqp, udata);\n\t\t\treturn err_code;\n\t\t}\n\t}\n\n\tinit_completion(&iwqp->free_qp);\n\treturn 0;\n\nerror:\n\tirdma_free_qp_rsrc(iwqp);\n\treturn err_code;\n}\n\nstatic int irdma_get_ib_acc_flags(struct irdma_qp *iwqp)\n{\n\tint acc_flags = 0;\n\n\tif (rdma_protocol_roce(iwqp->ibqp.device, 1)) {\n\t\tif (iwqp->roce_info.wr_rdresp_en) {\n\t\t\tacc_flags |= IB_ACCESS_LOCAL_WRITE;\n\t\t\tacc_flags |= IB_ACCESS_REMOTE_WRITE;\n\t\t}\n\t\tif (iwqp->roce_info.rd_en)\n\t\t\tacc_flags |= IB_ACCESS_REMOTE_READ;\n\t\tif (iwqp->roce_info.bind_en)\n\t\t\tacc_flags |= IB_ACCESS_MW_BIND;\n\t} else {\n\t\tif (iwqp->iwarp_info.wr_rdresp_en) {\n\t\t\tacc_flags |= IB_ACCESS_LOCAL_WRITE;\n\t\t\tacc_flags |= IB_ACCESS_REMOTE_WRITE;\n\t\t}\n\t\tif (iwqp->iwarp_info.rd_en)\n\t\t\tacc_flags |= IB_ACCESS_REMOTE_READ;\n\t\tif (iwqp->iwarp_info.bind_en)\n\t\t\tacc_flags |= IB_ACCESS_MW_BIND;\n\t}\n\treturn acc_flags;\n}\n\n \nstatic int irdma_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t  int attr_mask, struct ib_qp_init_attr *init_attr)\n{\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_sc_qp *qp = &iwqp->sc_qp;\n\n\tmemset(attr, 0, sizeof(*attr));\n\tmemset(init_attr, 0, sizeof(*init_attr));\n\n\tattr->qp_state = iwqp->ibqp_state;\n\tattr->cur_qp_state = iwqp->ibqp_state;\n\tattr->cap.max_send_wr = iwqp->max_send_wr;\n\tattr->cap.max_recv_wr = iwqp->max_recv_wr;\n\tattr->cap.max_inline_data = qp->qp_uk.max_inline_data;\n\tattr->cap.max_send_sge = qp->qp_uk.max_sq_frag_cnt;\n\tattr->cap.max_recv_sge = qp->qp_uk.max_rq_frag_cnt;\n\tattr->qp_access_flags = irdma_get_ib_acc_flags(iwqp);\n\tattr->port_num = 1;\n\tif (rdma_protocol_roce(ibqp->device, 1)) {\n\t\tattr->path_mtu = ib_mtu_int_to_enum(iwqp->udp_info.snd_mss);\n\t\tattr->qkey = iwqp->roce_info.qkey;\n\t\tattr->rq_psn = iwqp->udp_info.epsn;\n\t\tattr->sq_psn = iwqp->udp_info.psn_nxt;\n\t\tattr->dest_qp_num = iwqp->roce_info.dest_qp;\n\t\tattr->pkey_index = iwqp->roce_info.p_key;\n\t\tattr->retry_cnt = iwqp->udp_info.rexmit_thresh;\n\t\tattr->rnr_retry = iwqp->udp_info.rnr_nak_thresh;\n\t\tattr->max_rd_atomic = iwqp->roce_info.ord_size;\n\t\tattr->max_dest_rd_atomic = iwqp->roce_info.ird_size;\n\t}\n\n\tinit_attr->event_handler = iwqp->ibqp.event_handler;\n\tinit_attr->qp_context = iwqp->ibqp.qp_context;\n\tinit_attr->send_cq = iwqp->ibqp.send_cq;\n\tinit_attr->recv_cq = iwqp->ibqp.recv_cq;\n\tinit_attr->cap = attr->cap;\n\n\treturn 0;\n}\n\n \nstatic int irdma_query_pkey(struct ib_device *ibdev, u32 port, u16 index,\n\t\t\t    u16 *pkey)\n{\n\tif (index >= IRDMA_PKEY_TBL_SZ)\n\t\treturn -EINVAL;\n\n\t*pkey = IRDMA_DEFAULT_PKEY;\n\treturn 0;\n}\n\nstatic u8 irdma_roce_get_vlan_prio(const struct ib_gid_attr *attr, u8 prio)\n{\n\tstruct net_device *ndev;\n\n\trcu_read_lock();\n\tndev = rcu_dereference(attr->ndev);\n\tif (!ndev)\n\t\tgoto exit;\n\tif (is_vlan_dev(ndev)) {\n\t\tu16 vlan_qos = vlan_dev_get_egress_qos_mask(ndev, prio);\n\n\t\tprio = (vlan_qos & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n\t}\nexit:\n\trcu_read_unlock();\n\treturn prio;\n}\n\nstatic int irdma_wait_for_suspend(struct irdma_qp *iwqp)\n{\n\tif (!wait_event_timeout(iwqp->iwdev->suspend_wq,\n\t\t\t\t!iwqp->suspend_pending,\n\t\t\t\tmsecs_to_jiffies(IRDMA_EVENT_TIMEOUT_MS))) {\n\t\tiwqp->suspend_pending = false;\n\t\tibdev_warn(&iwqp->iwdev->ibdev,\n\t\t\t   \"modify_qp timed out waiting for suspend. qp_id = %d, last_ae = 0x%x\\n\",\n\t\t\t   iwqp->ibqp.qp_num, iwqp->last_aeq);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\n \nint irdma_modify_qp_roce(struct ib_qp *ibqp, struct ib_qp_attr *attr,\n\t\t\t int attr_mask, struct ib_udata *udata)\n{\n#define IRDMA_MODIFY_QP_MIN_REQ_LEN offsetofend(struct irdma_modify_qp_req, rq_flush)\n#define IRDMA_MODIFY_QP_MIN_RESP_LEN offsetofend(struct irdma_modify_qp_resp, push_valid)\n\tstruct irdma_pd *iwpd = to_iwpd(ibqp->pd);\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_qp_host_ctx_info *ctx_info;\n\tstruct irdma_roce_offload_info *roce_info;\n\tstruct irdma_udp_offload_info *udp_info;\n\tstruct irdma_modify_qp_info info = {};\n\tstruct irdma_modify_qp_resp uresp = {};\n\tstruct irdma_modify_qp_req ureq = {};\n\tunsigned long flags;\n\tu8 issue_modify_qp = 0;\n\tint ret = 0;\n\n\tctx_info = &iwqp->ctx_info;\n\troce_info = &iwqp->roce_info;\n\tudp_info = &iwqp->udp_info;\n\n\tif (udata) {\n\t\t \n\t\tif ((udata->inlen && udata->inlen < IRDMA_MODIFY_QP_MIN_REQ_LEN) ||\n\t\t    (udata->outlen && udata->outlen < IRDMA_MODIFY_QP_MIN_RESP_LEN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tif (attr_mask & IB_QP_DEST_QPN)\n\t\troce_info->dest_qp = attr->dest_qp_num;\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tret = irdma_query_pkey(ibqp->device, 0, attr->pkey_index,\n\t\t\t\t       &roce_info->p_key);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (attr_mask & IB_QP_QKEY)\n\t\troce_info->qkey = attr->qkey;\n\n\tif (attr_mask & IB_QP_PATH_MTU)\n\t\tudp_info->snd_mss = ib_mtu_enum_to_int(attr->path_mtu);\n\n\tif (attr_mask & IB_QP_SQ_PSN) {\n\t\tudp_info->psn_nxt = attr->sq_psn;\n\t\tudp_info->lsn =  0xffff;\n\t\tudp_info->psn_una = attr->sq_psn;\n\t\tudp_info->psn_max = attr->sq_psn;\n\t}\n\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tudp_info->epsn = attr->rq_psn;\n\n\tif (attr_mask & IB_QP_RNR_RETRY)\n\t\tudp_info->rnr_nak_thresh = attr->rnr_retry;\n\n\tif (attr_mask & IB_QP_RETRY_CNT)\n\t\tudp_info->rexmit_thresh = attr->retry_cnt;\n\n\tctx_info->roce_info->pd_id = iwpd->sc_pd.pd_id;\n\n\tif (attr_mask & IB_QP_AV) {\n\t\tstruct irdma_av *av = &iwqp->roce_ah.av;\n\t\tconst struct ib_gid_attr *sgid_attr =\n\t\t\t\tattr->ah_attr.grh.sgid_attr;\n\t\tu16 vlan_id = VLAN_N_VID;\n\t\tu32 local_ip[4];\n\n\t\tmemset(&iwqp->roce_ah, 0, sizeof(iwqp->roce_ah));\n\t\tif (attr->ah_attr.ah_flags & IB_AH_GRH) {\n\t\t\tudp_info->ttl = attr->ah_attr.grh.hop_limit;\n\t\t\tudp_info->flow_label = attr->ah_attr.grh.flow_label;\n\t\t\tudp_info->tos = attr->ah_attr.grh.traffic_class;\n\t\t\tudp_info->src_port =\n\t\t\t\trdma_get_udp_sport(udp_info->flow_label,\n\t\t\t\t\t\t   ibqp->qp_num,\n\t\t\t\t\t\t   roce_info->dest_qp);\n\t\t\tirdma_qp_rem_qos(&iwqp->sc_qp);\n\t\t\tdev->ws_remove(iwqp->sc_qp.vsi, ctx_info->user_pri);\n\t\t\tif (iwqp->sc_qp.vsi->dscp_mode)\n\t\t\t\tctx_info->user_pri =\n\t\t\t\tiwqp->sc_qp.vsi->dscp_map[irdma_tos2dscp(udp_info->tos)];\n\t\t\telse\n\t\t\t\tctx_info->user_pri = rt_tos2priority(udp_info->tos);\n\t\t}\n\t\tret = rdma_read_gid_l2_fields(sgid_attr, &vlan_id,\n\t\t\t\t\t      ctx_info->roce_info->mac_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tctx_info->user_pri = irdma_roce_get_vlan_prio(sgid_attr,\n\t\t\t\t\t\t\t      ctx_info->user_pri);\n\t\tif (dev->ws_add(iwqp->sc_qp.vsi, ctx_info->user_pri))\n\t\t\treturn -ENOMEM;\n\t\tiwqp->sc_qp.user_pri = ctx_info->user_pri;\n\t\tirdma_qp_add_qos(&iwqp->sc_qp);\n\n\t\tif (vlan_id >= VLAN_N_VID && iwdev->dcb_vlan_mode)\n\t\t\tvlan_id = 0;\n\t\tif (vlan_id < VLAN_N_VID) {\n\t\t\tudp_info->insert_vlan_tag = true;\n\t\t\tudp_info->vlan_tag = vlan_id |\n\t\t\t\tctx_info->user_pri << VLAN_PRIO_SHIFT;\n\t\t} else {\n\t\t\tudp_info->insert_vlan_tag = false;\n\t\t}\n\n\t\tav->attrs = attr->ah_attr;\n\t\trdma_gid2ip((struct sockaddr *)&av->sgid_addr, &sgid_attr->gid);\n\t\trdma_gid2ip((struct sockaddr *)&av->dgid_addr, &attr->ah_attr.grh.dgid);\n\t\tav->net_type = rdma_gid_attr_network_type(sgid_attr);\n\t\tif (av->net_type == RDMA_NETWORK_IPV6) {\n\t\t\t__be32 *daddr =\n\t\t\t\tav->dgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32;\n\t\t\t__be32 *saddr =\n\t\t\t\tav->sgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32;\n\n\t\t\tirdma_copy_ip_ntohl(&udp_info->dest_ip_addr[0], daddr);\n\t\t\tirdma_copy_ip_ntohl(&udp_info->local_ipaddr[0], saddr);\n\n\t\t\tudp_info->ipv4 = false;\n\t\t\tirdma_copy_ip_ntohl(local_ip, daddr);\n\n\t\t} else if (av->net_type == RDMA_NETWORK_IPV4) {\n\t\t\t__be32 saddr = av->sgid_addr.saddr_in.sin_addr.s_addr;\n\t\t\t__be32 daddr = av->dgid_addr.saddr_in.sin_addr.s_addr;\n\n\t\t\tlocal_ip[0] = ntohl(daddr);\n\n\t\t\tudp_info->ipv4 = true;\n\t\t\tudp_info->dest_ip_addr[0] = 0;\n\t\t\tudp_info->dest_ip_addr[1] = 0;\n\t\t\tudp_info->dest_ip_addr[2] = 0;\n\t\t\tudp_info->dest_ip_addr[3] = local_ip[0];\n\n\t\t\tudp_info->local_ipaddr[0] = 0;\n\t\t\tudp_info->local_ipaddr[1] = 0;\n\t\t\tudp_info->local_ipaddr[2] = 0;\n\t\t\tudp_info->local_ipaddr[3] = ntohl(saddr);\n\t\t}\n\t\tudp_info->arp_idx =\n\t\t\tirdma_add_arp(iwdev->rf, local_ip, udp_info->ipv4,\n\t\t\t\t      attr->ah_attr.roce.dmac);\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attr->max_rd_atomic > dev->hw_attrs.max_hw_ord) {\n\t\t\tibdev_err(&iwdev->ibdev,\n\t\t\t\t  \"rd_atomic = %d, above max_hw_ord=%d\\n\",\n\t\t\t\t  attr->max_rd_atomic,\n\t\t\t\t  dev->hw_attrs.max_hw_ord);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attr->max_rd_atomic)\n\t\t\troce_info->ord_size = attr->max_rd_atomic;\n\t\tinfo.ord_valid = true;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attr->max_dest_rd_atomic > dev->hw_attrs.max_hw_ird) {\n\t\t\tibdev_err(&iwdev->ibdev,\n\t\t\t\t  \"rd_atomic = %d, above max_hw_ird=%d\\n\",\n\t\t\t\t   attr->max_rd_atomic,\n\t\t\t\t   dev->hw_attrs.max_hw_ird);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (attr->max_dest_rd_atomic)\n\t\t\troce_info->ird_size = attr->max_dest_rd_atomic;\n\t}\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS) {\n\t\tif (attr->qp_access_flags & IB_ACCESS_LOCAL_WRITE)\n\t\t\troce_info->wr_rdresp_en = true;\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\t\troce_info->wr_rdresp_en = true;\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\n\t\t\troce_info->rd_en = true;\n\t}\n\n\twait_event(iwqp->mod_qp_waitq, !atomic_read(&iwqp->hw_mod_qp_pend));\n\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"VERBS: caller: %pS qp_id=%d to_ibqpstate=%d ibqpstate=%d irdma_qpstate=%d attr_mask=0x%x\\n\",\n\t\t  __builtin_return_address(0), ibqp->qp_num, attr->qp_state,\n\t\t  iwqp->ibqp_state, iwqp->iwarp_state, attr_mask);\n\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\tif (attr_mask & IB_QP_STATE) {\n\t\tif (!ib_modify_qp_is_ok(iwqp->ibqp_state, attr->qp_state,\n\t\t\t\t\tiwqp->ibqp.qp_type, attr_mask)) {\n\t\t\tibdev_warn(&iwdev->ibdev, \"modify_qp invalid for qp_id=%d, old_state=0x%x, new_state=0x%x\\n\",\n\t\t\t\t   iwqp->ibqp.qp_num, iwqp->ibqp_state,\n\t\t\t\t   attr->qp_state);\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\t\tinfo.curr_iwarp_state = iwqp->iwarp_state;\n\n\t\tswitch (attr->qp_state) {\n\t\tcase IB_QPS_INIT:\n\t\t\tif (iwqp->iwarp_state > IRDMA_QP_STATE_IDLE) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_INVALID) {\n\t\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_IDLE;\n\t\t\t\tissue_modify_qp = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IB_QPS_RTR:\n\t\t\tif (iwqp->iwarp_state > IRDMA_QP_STATE_IDLE) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tinfo.arp_cache_idx_valid = true;\n\t\t\tinfo.cq_num_valid = true;\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_RTR;\n\t\t\tissue_modify_qp = 1;\n\t\t\tbreak;\n\t\tcase IB_QPS_RTS:\n\t\t\tif (iwqp->ibqp_state < IB_QPS_RTR ||\n\t\t\t    iwqp->ibqp_state == IB_QPS_ERR) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tinfo.arp_cache_idx_valid = true;\n\t\t\tinfo.cq_num_valid = true;\n\t\t\tinfo.ord_valid = true;\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_RTS;\n\t\t\tissue_modify_qp = 1;\n\t\t\tif (iwdev->push_mode && udata &&\n\t\t\t    iwqp->sc_qp.push_idx == IRDMA_INVALID_PUSH_PAGE_INDEX &&\n\t\t\t    dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tirdma_alloc_push_page(iwqp);\n\t\t\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IB_QPS_SQD:\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_SQD)\n\t\t\t\tgoto exit;\n\n\t\t\tif (iwqp->iwarp_state != IRDMA_QP_STATE_RTS) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_SQD;\n\t\t\tissue_modify_qp = 1;\n\t\t\tiwqp->suspend_pending = true;\n\t\t\tbreak;\n\t\tcase IB_QPS_SQE:\n\t\tcase IB_QPS_ERR:\n\t\tcase IB_QPS_RESET:\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_ERROR) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tif (udata && udata->inlen) {\n\t\t\t\t\tif (ib_copy_from_udata(&ureq, udata,\n\t\t\t\t\t    min(sizeof(ureq), udata->inlen)))\n\t\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\t\tirdma_flush_wqes(iwqp,\n\t\t\t\t\t    (ureq.sq_flush ? IRDMA_FLUSH_SQ : 0) |\n\t\t\t\t\t    (ureq.rq_flush ? IRDMA_FLUSH_RQ : 0) |\n\t\t\t\t\t    IRDMA_REFLUSH);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_ERROR;\n\t\t\tissue_modify_qp = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tiwqp->ibqp_state = attr->qp_state;\n\t}\n\n\tctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\n\tctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\n\tirdma_sc_qp_setctx_roce(&iwqp->sc_qp, iwqp->host_ctx.va, ctx_info);\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\n\tif (attr_mask & IB_QP_STATE) {\n\t\tif (issue_modify_qp) {\n\t\t\tctx_info->rem_endpoint_idx = udp_info->arp_idx;\n\t\t\tif (irdma_hw_modify_qp(iwdev, iwqp, &info, true))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (info.next_iwarp_state == IRDMA_QP_STATE_SQD) {\n\t\t\t\tret = irdma_wait_for_suspend(iwqp);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\t\tif (iwqp->iwarp_state == info.curr_iwarp_state) {\n\t\t\t\tiwqp->iwarp_state = info.next_iwarp_state;\n\t\t\t\tiwqp->ibqp_state = attr->qp_state;\n\t\t\t}\n\t\t\tif (iwqp->ibqp_state > IB_QPS_RTS &&\n\t\t\t    !iwqp->flush_issued) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tirdma_flush_wqes(iwqp, IRDMA_FLUSH_SQ |\n\t\t\t\t\t\t       IRDMA_FLUSH_RQ |\n\t\t\t\t\t\t       IRDMA_FLUSH_WAIT);\n\t\t\t\tiwqp->flush_issued = 1;\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t}\n\t\t} else {\n\t\t\tiwqp->ibqp_state = attr->qp_state;\n\t\t}\n\t\tif (udata && udata->outlen && dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {\n\t\t\tstruct irdma_ucontext *ucontext;\n\n\t\t\tucontext = rdma_udata_to_drv_context(udata,\n\t\t\t\t\tstruct irdma_ucontext, ibucontext);\n\t\t\tif (iwqp->sc_qp.push_idx != IRDMA_INVALID_PUSH_PAGE_INDEX &&\n\t\t\t    !iwqp->push_wqe_mmap_entry &&\n\t\t\t    !irdma_setup_push_mmap_entries(ucontext, iwqp,\n\t\t\t\t&uresp.push_wqe_mmap_key, &uresp.push_db_mmap_key)) {\n\t\t\t\turesp.push_valid = 1;\n\t\t\t\turesp.push_offset = iwqp->sc_qp.push_offset;\n\t\t\t}\n\t\t\tret = ib_copy_to_udata(udata, &uresp, min(sizeof(uresp),\n\t\t\t\t\t       udata->outlen));\n\t\t\tif (ret) {\n\t\t\t\tirdma_remove_push_mmap_entries(iwqp);\n\t\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t\t  \"VERBS: copy_to_udata failed\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\nexit:\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\n\treturn ret;\n}\n\n \nint irdma_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,\n\t\t    struct ib_udata *udata)\n{\n#define IRDMA_MODIFY_QP_MIN_REQ_LEN offsetofend(struct irdma_modify_qp_req, rq_flush)\n#define IRDMA_MODIFY_QP_MIN_RESP_LEN offsetofend(struct irdma_modify_qp_resp, push_valid)\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\tstruct irdma_qp_host_ctx_info *ctx_info;\n\tstruct irdma_tcp_offload_info *tcp_info;\n\tstruct irdma_iwarp_offload_info *offload_info;\n\tstruct irdma_modify_qp_info info = {};\n\tstruct irdma_modify_qp_resp uresp = {};\n\tstruct irdma_modify_qp_req ureq = {};\n\tu8 issue_modify_qp = 0;\n\tu8 dont_wait = 0;\n\tint err;\n\tunsigned long flags;\n\n\tif (udata) {\n\t\t \n\t\tif ((udata->inlen && udata->inlen < IRDMA_MODIFY_QP_MIN_REQ_LEN) ||\n\t\t    (udata->outlen && udata->outlen < IRDMA_MODIFY_QP_MIN_RESP_LEN))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tctx_info = &iwqp->ctx_info;\n\toffload_info = &iwqp->iwarp_info;\n\ttcp_info = &iwqp->tcp_info;\n\twait_event(iwqp->mod_qp_waitq, !atomic_read(&iwqp->hw_mod_qp_pend));\n\tibdev_dbg(&iwdev->ibdev,\n\t\t  \"VERBS: caller: %pS qp_id=%d to_ibqpstate=%d ibqpstate=%d irdma_qpstate=%d last_aeq=%d hw_tcp_state=%d hw_iwarp_state=%d attr_mask=0x%x\\n\",\n\t\t  __builtin_return_address(0), ibqp->qp_num, attr->qp_state,\n\t\t  iwqp->ibqp_state, iwqp->iwarp_state, iwqp->last_aeq,\n\t\t  iwqp->hw_tcp_state, iwqp->hw_iwarp_state, attr_mask);\n\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\tif (attr_mask & IB_QP_STATE) {\n\t\tinfo.curr_iwarp_state = iwqp->iwarp_state;\n\t\tswitch (attr->qp_state) {\n\t\tcase IB_QPS_INIT:\n\t\tcase IB_QPS_RTR:\n\t\t\tif (iwqp->iwarp_state > IRDMA_QP_STATE_IDLE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_INVALID) {\n\t\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_IDLE;\n\t\t\t\tissue_modify_qp = 1;\n\t\t\t}\n\t\t\tif (iwdev->push_mode && udata &&\n\t\t\t    iwqp->sc_qp.push_idx == IRDMA_INVALID_PUSH_PAGE_INDEX &&\n\t\t\t    dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tirdma_alloc_push_page(iwqp);\n\t\t\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IB_QPS_RTS:\n\t\t\tif (iwqp->iwarp_state > IRDMA_QP_STATE_RTS ||\n\t\t\t    !iwqp->cm_id) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tissue_modify_qp = 1;\n\t\t\tiwqp->hw_tcp_state = IRDMA_TCP_STATE_ESTABLISHED;\n\t\t\tiwqp->hte_added = 1;\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_RTS;\n\t\t\tinfo.tcp_ctx_valid = true;\n\t\t\tinfo.ord_valid = true;\n\t\t\tinfo.arp_cache_idx_valid = true;\n\t\t\tinfo.cq_num_valid = true;\n\t\t\tbreak;\n\t\tcase IB_QPS_SQD:\n\t\t\tif (iwqp->hw_iwarp_state > IRDMA_QP_STATE_RTS) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_CLOSING ||\n\t\t\t    iwqp->iwarp_state < IRDMA_QP_STATE_RTS) {\n\t\t\t\terr = 0;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tif (iwqp->iwarp_state > IRDMA_QP_STATE_CLOSING) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_CLOSING;\n\t\t\tissue_modify_qp = 1;\n\t\t\tbreak;\n\t\tcase IB_QPS_SQE:\n\t\t\tif (iwqp->iwarp_state >= IRDMA_QP_STATE_TERMINATE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_TERMINATE;\n\t\t\tissue_modify_qp = 1;\n\t\t\tbreak;\n\t\tcase IB_QPS_ERR:\n\t\tcase IB_QPS_RESET:\n\t\t\tif (iwqp->iwarp_state == IRDMA_QP_STATE_ERROR) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tif (udata && udata->inlen) {\n\t\t\t\t\tif (ib_copy_from_udata(&ureq, udata,\n\t\t\t\t\t    min(sizeof(ureq), udata->inlen)))\n\t\t\t\t\t\treturn -EINVAL;\n\n\t\t\t\t\tirdma_flush_wqes(iwqp,\n\t\t\t\t\t    (ureq.sq_flush ? IRDMA_FLUSH_SQ : 0) |\n\t\t\t\t\t    (ureq.rq_flush ? IRDMA_FLUSH_RQ : 0) |\n\t\t\t\t\t    IRDMA_REFLUSH);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (iwqp->sc_qp.term_flags) {\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t\tirdma_terminate_del_timer(&iwqp->sc_qp);\n\t\t\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\t\t}\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_ERROR;\n\t\t\tif (iwqp->hw_tcp_state > IRDMA_TCP_STATE_CLOSED &&\n\t\t\t    iwdev->iw_status &&\n\t\t\t    iwqp->hw_tcp_state != IRDMA_TCP_STATE_TIME_WAIT)\n\t\t\t\tinfo.reset_tcp_conn = true;\n\t\t\telse\n\t\t\t\tdont_wait = 1;\n\n\t\t\tissue_modify_qp = 1;\n\t\t\tinfo.next_iwarp_state = IRDMA_QP_STATE_ERROR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tiwqp->ibqp_state = attr->qp_state;\n\t}\n\tif (attr_mask & IB_QP_ACCESS_FLAGS) {\n\t\tctx_info->iwarp_info_valid = true;\n\t\tif (attr->qp_access_flags & IB_ACCESS_LOCAL_WRITE)\n\t\t\toffload_info->wr_rdresp_en = true;\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\t\toffload_info->wr_rdresp_en = true;\n\t\tif (attr->qp_access_flags & IB_ACCESS_REMOTE_READ)\n\t\t\toffload_info->rd_en = true;\n\t}\n\n\tif (ctx_info->iwarp_info_valid) {\n\t\tctx_info->send_cq_num = iwqp->iwscq->sc_cq.cq_uk.cq_id;\n\t\tctx_info->rcv_cq_num = iwqp->iwrcq->sc_cq.cq_uk.cq_id;\n\t\tirdma_sc_qp_setctx(&iwqp->sc_qp, iwqp->host_ctx.va, ctx_info);\n\t}\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\n\tif (attr_mask & IB_QP_STATE) {\n\t\tif (issue_modify_qp) {\n\t\t\tctx_info->rem_endpoint_idx = tcp_info->arp_idx;\n\t\t\tif (irdma_hw_modify_qp(iwdev, iwqp, &info, true))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\tif (iwqp->iwarp_state == info.curr_iwarp_state) {\n\t\t\tiwqp->iwarp_state = info.next_iwarp_state;\n\t\t\tiwqp->ibqp_state = attr->qp_state;\n\t\t}\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t}\n\n\tif (issue_modify_qp && iwqp->ibqp_state > IB_QPS_RTS) {\n\t\tif (dont_wait) {\n\t\t\tif (iwqp->hw_tcp_state) {\n\t\t\t\tspin_lock_irqsave(&iwqp->lock, flags);\n\t\t\t\tiwqp->hw_tcp_state = IRDMA_TCP_STATE_CLOSED;\n\t\t\t\tiwqp->last_aeq = IRDMA_AE_RESET_SENT;\n\t\t\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\t\t}\n\t\t\tirdma_cm_disconn(iwqp);\n\t\t} else {\n\t\t\tint close_timer_started;\n\n\t\t\tspin_lock_irqsave(&iwdev->cm_core.ht_lock, flags);\n\n\t\t\tif (iwqp->cm_node) {\n\t\t\t\trefcount_inc(&iwqp->cm_node->refcnt);\n\t\t\t\tspin_unlock_irqrestore(&iwdev->cm_core.ht_lock, flags);\n\t\t\t\tclose_timer_started = atomic_inc_return(&iwqp->close_timer_started);\n\t\t\t\tif (iwqp->cm_id && close_timer_started == 1)\n\t\t\t\t\tirdma_schedule_cm_timer(iwqp->cm_node,\n\t\t\t\t\t\t(struct irdma_puda_buf *)iwqp,\n\t\t\t\t\t\tIRDMA_TIMER_TYPE_CLOSE, 1, 0);\n\n\t\t\t\tirdma_rem_ref_cm_node(iwqp->cm_node);\n\t\t\t} else {\n\t\t\t\tspin_unlock_irqrestore(&iwdev->cm_core.ht_lock, flags);\n\t\t\t}\n\t\t}\n\t}\n\tif (attr_mask & IB_QP_STATE && udata && udata->outlen &&\n\t    dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2) {\n\t\tstruct irdma_ucontext *ucontext;\n\n\t\tucontext = rdma_udata_to_drv_context(udata,\n\t\t\t\t\tstruct irdma_ucontext, ibucontext);\n\t\tif (iwqp->sc_qp.push_idx != IRDMA_INVALID_PUSH_PAGE_INDEX &&\n\t\t    !iwqp->push_wqe_mmap_entry &&\n\t\t    !irdma_setup_push_mmap_entries(ucontext, iwqp,\n\t\t\t&uresp.push_wqe_mmap_key, &uresp.push_db_mmap_key)) {\n\t\t\turesp.push_valid = 1;\n\t\t\turesp.push_offset = iwqp->sc_qp.push_offset;\n\t\t}\n\n\t\terr = ib_copy_to_udata(udata, &uresp, min(sizeof(uresp),\n\t\t\t\t       udata->outlen));\n\t\tif (err) {\n\t\t\tirdma_remove_push_mmap_entries(iwqp);\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"VERBS: copy_to_udata failed\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\nexit:\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\n\treturn err;\n}\n\n \nstatic void irdma_cq_free_rsrc(struct irdma_pci_f *rf, struct irdma_cq *iwcq)\n{\n\tstruct irdma_sc_cq *cq = &iwcq->sc_cq;\n\n\tif (!iwcq->user_mode) {\n\t\tdma_free_coherent(rf->sc_dev.hw->device, iwcq->kmem.size,\n\t\t\t\t  iwcq->kmem.va, iwcq->kmem.pa);\n\t\tiwcq->kmem.va = NULL;\n\t\tdma_free_coherent(rf->sc_dev.hw->device,\n\t\t\t\t  iwcq->kmem_shadow.size,\n\t\t\t\t  iwcq->kmem_shadow.va, iwcq->kmem_shadow.pa);\n\t\tiwcq->kmem_shadow.va = NULL;\n\t}\n\n\tirdma_free_rsrc(rf, rf->allocated_cqs, cq->cq_uk.cq_id);\n}\n\n \nstatic void irdma_free_cqbuf(struct work_struct *work)\n{\n\tstruct irdma_cq_buf *cq_buf = container_of(work, struct irdma_cq_buf, work);\n\n\tdma_free_coherent(cq_buf->hw->device, cq_buf->kmem_buf.size,\n\t\t\t  cq_buf->kmem_buf.va, cq_buf->kmem_buf.pa);\n\tcq_buf->kmem_buf.va = NULL;\n\tkfree(cq_buf);\n}\n\n \nstatic int irdma_process_resize_list(struct irdma_cq *iwcq,\n\t\t\t\t     struct irdma_device *iwdev,\n\t\t\t\t     struct irdma_cq_buf *lcqe_buf)\n{\n\tstruct list_head *tmp_node, *list_node;\n\tstruct irdma_cq_buf *cq_buf;\n\tint cnt = 0;\n\n\tlist_for_each_safe(list_node, tmp_node, &iwcq->resize_list) {\n\t\tcq_buf = list_entry(list_node, struct irdma_cq_buf, list);\n\t\tif (cq_buf == lcqe_buf)\n\t\t\treturn cnt;\n\n\t\tlist_del(&cq_buf->list);\n\t\tqueue_work(iwdev->cleanup_wq, &cq_buf->work);\n\t\tcnt++;\n\t}\n\n\treturn cnt;\n}\n\n \nstatic int irdma_destroy_cq(struct ib_cq *ib_cq, struct ib_udata *udata)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ib_cq->device);\n\tstruct irdma_cq *iwcq = to_iwcq(ib_cq);\n\tstruct irdma_sc_cq *cq = &iwcq->sc_cq;\n\tstruct irdma_sc_dev *dev = cq->dev;\n\tstruct irdma_sc_ceq *ceq = dev->ceq[cq->ceq_id];\n\tstruct irdma_ceq *iwceq = container_of(ceq, struct irdma_ceq, sc_ceq);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\tif (!list_empty(&iwcq->cmpl_generated))\n\t\tirdma_remove_cmpls_list(iwcq);\n\tif (!list_empty(&iwcq->resize_list))\n\t\tirdma_process_resize_list(iwcq, iwdev, NULL);\n\tspin_unlock_irqrestore(&iwcq->lock, flags);\n\n\tirdma_cq_rem_ref(ib_cq);\n\twait_for_completion(&iwcq->free_cq);\n\n\tirdma_cq_wq_destroy(iwdev->rf, cq);\n\n\tspin_lock_irqsave(&iwceq->ce_lock, flags);\n\tirdma_sc_cleanup_ceqes(cq, ceq);\n\tspin_unlock_irqrestore(&iwceq->ce_lock, flags);\n\tirdma_cq_free_rsrc(iwdev->rf, iwcq);\n\n\treturn 0;\n}\n\n \nstatic int irdma_resize_cq(struct ib_cq *ibcq, int entries,\n\t\t\t   struct ib_udata *udata)\n{\n#define IRDMA_RESIZE_CQ_MIN_REQ_LEN offsetofend(struct irdma_resize_cq_req, user_cq_buffer)\n\tstruct irdma_cq *iwcq = to_iwcq(ibcq);\n\tstruct irdma_sc_dev *dev = iwcq->sc_cq.dev;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_modify_cq_info *m_info;\n\tstruct irdma_modify_cq_info info = {};\n\tstruct irdma_dma_mem kmem_buf;\n\tstruct irdma_cq_mr *cqmr_buf;\n\tstruct irdma_pbl *iwpbl_buf;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_pci_f *rf;\n\tstruct irdma_cq_buf *cq_buf = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\tiwdev = to_iwdev(ibcq->device);\n\trf = iwdev->rf;\n\n\tif (!(rf->sc_dev.hw_attrs.uk_attrs.feature_flags &\n\t    IRDMA_FEATURE_CQ_RESIZE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (udata && udata->inlen < IRDMA_RESIZE_CQ_MIN_REQ_LEN)\n\t\treturn -EINVAL;\n\n\tif (entries > rf->max_cqe)\n\t\treturn -EINVAL;\n\n\tif (!iwcq->user_mode) {\n\t\tentries++;\n\t\tif (rf->sc_dev.hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\t\tentries *= 2;\n\t}\n\n\tinfo.cq_size = max(entries, 4);\n\n\tif (info.cq_size == iwcq->sc_cq.cq_uk.cq_size - 1)\n\t\treturn 0;\n\n\tif (udata) {\n\t\tstruct irdma_resize_cq_req req = {};\n\t\tstruct irdma_ucontext *ucontext =\n\t\t\trdma_udata_to_drv_context(udata, struct irdma_ucontext,\n\t\t\t\t\t\t  ibucontext);\n\n\t\t \n\t\tif (ucontext->legacy_mode)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (ib_copy_from_udata(&req, udata,\n\t\t\t\t       min(sizeof(req), udata->inlen)))\n\t\t\treturn -EINVAL;\n\n\t\tspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\n\t\tiwpbl_buf = irdma_get_pbl((unsigned long)req.user_cq_buffer,\n\t\t\t\t\t  &ucontext->cq_reg_mem_list);\n\t\tspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\n\n\t\tif (!iwpbl_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tcqmr_buf = &iwpbl_buf->cq_mr;\n\t\tif (iwpbl_buf->pbl_allocated) {\n\t\t\tinfo.virtual_map = true;\n\t\t\tinfo.pbl_chunk_size = 1;\n\t\t\tinfo.first_pm_pbl_idx = cqmr_buf->cq_pbl.idx;\n\t\t} else {\n\t\t\tinfo.cq_pa = cqmr_buf->cq_pbl.addr;\n\t\t}\n\t} else {\n\t\t \n\t\tint rsize;\n\n\t\trsize = info.cq_size * sizeof(struct irdma_cqe);\n\t\tkmem_buf.size = ALIGN(round_up(rsize, 256), 256);\n\t\tkmem_buf.va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t\t kmem_buf.size, &kmem_buf.pa,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!kmem_buf.va)\n\t\t\treturn -ENOMEM;\n\n\t\tinfo.cq_base = kmem_buf.va;\n\t\tinfo.cq_pa = kmem_buf.pa;\n\t\tcq_buf = kzalloc(sizeof(*cq_buf), GFP_KERNEL);\n\t\tif (!cq_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tinfo.shadow_read_threshold = iwcq->sc_cq.shadow_read_threshold;\n\tinfo.cq_resize = true;\n\n\tcqp_info = &cqp_request->info;\n\tm_info = &cqp_info->in.u.cq_modify.info;\n\tmemcpy(m_info, &info, sizeof(*m_info));\n\n\tcqp_info->cqp_cmd = IRDMA_OP_CQ_MODIFY;\n\tcqp_info->in.u.cq_modify.cq = &iwcq->sc_cq;\n\tcqp_info->in.u.cq_modify.scratch = (uintptr_t)cqp_request;\n\tcqp_info->post_sq = 1;\n\tret = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\tif (ret)\n\t\tgoto error;\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\tif (cq_buf) {\n\t\tcq_buf->kmem_buf = iwcq->kmem;\n\t\tcq_buf->hw = dev->hw;\n\t\tmemcpy(&cq_buf->cq_uk, &iwcq->sc_cq.cq_uk, sizeof(cq_buf->cq_uk));\n\t\tINIT_WORK(&cq_buf->work, irdma_free_cqbuf);\n\t\tlist_add_tail(&cq_buf->list, &iwcq->resize_list);\n\t\tiwcq->kmem = kmem_buf;\n\t}\n\n\tirdma_sc_cq_resize(&iwcq->sc_cq, &info);\n\tibcq->cqe = info.cq_size - 1;\n\tspin_unlock_irqrestore(&iwcq->lock, flags);\n\n\treturn 0;\nerror:\n\tif (!udata) {\n\t\tdma_free_coherent(dev->hw->device, kmem_buf.size, kmem_buf.va,\n\t\t\t\t  kmem_buf.pa);\n\t\tkmem_buf.va = NULL;\n\t}\n\tkfree(cq_buf);\n\n\treturn ret;\n}\n\nstatic inline int cq_validate_flags(u32 flags, u8 hw_rev)\n{\n\t \n\tif (hw_rev == IRDMA_GEN_1)\n\t\treturn flags ? -EOPNOTSUPP : 0;\n\n\treturn flags & ~IB_UVERBS_CQ_FLAGS_TIMESTAMP_COMPLETION ? -EOPNOTSUPP : 0;\n}\n\n \nstatic int irdma_create_cq(struct ib_cq *ibcq,\n\t\t\t   const struct ib_cq_init_attr *attr,\n\t\t\t   struct ib_udata *udata)\n{\n#define IRDMA_CREATE_CQ_MIN_REQ_LEN offsetofend(struct irdma_create_cq_req, user_cq_buf)\n#define IRDMA_CREATE_CQ_MIN_RESP_LEN offsetofend(struct irdma_create_cq_resp, cq_size)\n\tstruct ib_device *ibdev = ibcq->device;\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct irdma_cq *iwcq = to_iwcq(ibcq);\n\tu32 cq_num = 0;\n\tstruct irdma_sc_cq *cq;\n\tstruct irdma_sc_dev *dev = &rf->sc_dev;\n\tstruct irdma_cq_init_info info = {};\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_cq_uk_init_info *ukinfo = &info.cq_uk_init_info;\n\tunsigned long flags;\n\tint err_code;\n\tint entries = attr->cqe;\n\n\terr_code = cq_validate_flags(attr->flags, dev->hw_attrs.uk_attrs.hw_rev);\n\tif (err_code)\n\t\treturn err_code;\n\n\tif (udata && (udata->inlen < IRDMA_CREATE_CQ_MIN_REQ_LEN ||\n\t\t      udata->outlen < IRDMA_CREATE_CQ_MIN_RESP_LEN))\n\t\treturn -EINVAL;\n\n\terr_code = irdma_alloc_rsrc(rf, rf->allocated_cqs, rf->max_cq, &cq_num,\n\t\t\t\t    &rf->next_cq);\n\tif (err_code)\n\t\treturn err_code;\n\n\tcq = &iwcq->sc_cq;\n\tcq->back_cq = iwcq;\n\trefcount_set(&iwcq->refcnt, 1);\n\tspin_lock_init(&iwcq->lock);\n\tINIT_LIST_HEAD(&iwcq->resize_list);\n\tINIT_LIST_HEAD(&iwcq->cmpl_generated);\n\tinfo.dev = dev;\n\tukinfo->cq_size = max(entries, 4);\n\tukinfo->cq_id = cq_num;\n\tiwcq->ibcq.cqe = info.cq_uk_init_info.cq_size;\n\tif (attr->comp_vector < rf->ceqs_count)\n\t\tinfo.ceq_id = attr->comp_vector;\n\tinfo.ceq_id_valid = true;\n\tinfo.ceqe_mask = 1;\n\tinfo.type = IRDMA_CQ_TYPE_IWARP;\n\tinfo.vsi = &iwdev->vsi;\n\n\tif (udata) {\n\t\tstruct irdma_ucontext *ucontext;\n\t\tstruct irdma_create_cq_req req = {};\n\t\tstruct irdma_cq_mr *cqmr;\n\t\tstruct irdma_pbl *iwpbl;\n\t\tstruct irdma_pbl *iwpbl_shadow;\n\t\tstruct irdma_cq_mr *cqmr_shadow;\n\n\t\tiwcq->user_mode = true;\n\t\tucontext =\n\t\t\trdma_udata_to_drv_context(udata, struct irdma_ucontext,\n\t\t\t\t\t\t  ibucontext);\n\t\tif (ib_copy_from_udata(&req, udata,\n\t\t\t\t       min(sizeof(req), udata->inlen))) {\n\t\t\terr_code = -EFAULT;\n\t\t\tgoto cq_free_rsrc;\n\t\t}\n\n\t\tspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\n\t\tiwpbl = irdma_get_pbl((unsigned long)req.user_cq_buf,\n\t\t\t\t      &ucontext->cq_reg_mem_list);\n\t\tspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\n\t\tif (!iwpbl) {\n\t\t\terr_code = -EPROTO;\n\t\t\tgoto cq_free_rsrc;\n\t\t}\n\n\t\tiwcq->iwpbl = iwpbl;\n\t\tiwcq->cq_mem_size = 0;\n\t\tcqmr = &iwpbl->cq_mr;\n\n\t\tif (rf->sc_dev.hw_attrs.uk_attrs.feature_flags &\n\t\t    IRDMA_FEATURE_CQ_RESIZE && !ucontext->legacy_mode) {\n\t\t\tspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\n\t\t\tiwpbl_shadow = irdma_get_pbl(\n\t\t\t\t\t(unsigned long)req.user_shadow_area,\n\t\t\t\t\t&ucontext->cq_reg_mem_list);\n\t\t\tspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\n\n\t\t\tif (!iwpbl_shadow) {\n\t\t\t\terr_code = -EPROTO;\n\t\t\t\tgoto cq_free_rsrc;\n\t\t\t}\n\t\t\tiwcq->iwpbl_shadow = iwpbl_shadow;\n\t\t\tcqmr_shadow = &iwpbl_shadow->cq_mr;\n\t\t\tinfo.shadow_area_pa = cqmr_shadow->cq_pbl.addr;\n\t\t\tcqmr->split = true;\n\t\t} else {\n\t\t\tinfo.shadow_area_pa = cqmr->shadow;\n\t\t}\n\t\tif (iwpbl->pbl_allocated) {\n\t\t\tinfo.virtual_map = true;\n\t\t\tinfo.pbl_chunk_size = 1;\n\t\t\tinfo.first_pm_pbl_idx = cqmr->cq_pbl.idx;\n\t\t} else {\n\t\t\tinfo.cq_base_pa = cqmr->cq_pbl.addr;\n\t\t}\n\t} else {\n\t\t \n\t\tint rsize;\n\n\t\tif (entries < 1 || entries > rf->max_cqe) {\n\t\t\terr_code = -EINVAL;\n\t\t\tgoto cq_free_rsrc;\n\t\t}\n\n\t\tentries++;\n\t\tif (dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\t\tentries *= 2;\n\t\tukinfo->cq_size = entries;\n\n\t\trsize = info.cq_uk_init_info.cq_size * sizeof(struct irdma_cqe);\n\t\tiwcq->kmem.size = ALIGN(round_up(rsize, 256), 256);\n\t\tiwcq->kmem.va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t\t   iwcq->kmem.size,\n\t\t\t\t\t\t   &iwcq->kmem.pa, GFP_KERNEL);\n\t\tif (!iwcq->kmem.va) {\n\t\t\terr_code = -ENOMEM;\n\t\t\tgoto cq_free_rsrc;\n\t\t}\n\n\t\tiwcq->kmem_shadow.size = ALIGN(IRDMA_SHADOW_AREA_SIZE << 3,\n\t\t\t\t\t       64);\n\t\tiwcq->kmem_shadow.va = dma_alloc_coherent(dev->hw->device,\n\t\t\t\t\t\t\t  iwcq->kmem_shadow.size,\n\t\t\t\t\t\t\t  &iwcq->kmem_shadow.pa,\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!iwcq->kmem_shadow.va) {\n\t\t\terr_code = -ENOMEM;\n\t\t\tgoto cq_free_rsrc;\n\t\t}\n\t\tinfo.shadow_area_pa = iwcq->kmem_shadow.pa;\n\t\tukinfo->shadow_area = iwcq->kmem_shadow.va;\n\t\tukinfo->cq_base = iwcq->kmem.va;\n\t\tinfo.cq_base_pa = iwcq->kmem.pa;\n\t}\n\n\tif (dev->hw_attrs.uk_attrs.hw_rev >= IRDMA_GEN_2)\n\t\tinfo.shadow_read_threshold = min(info.cq_uk_init_info.cq_size / 2,\n\t\t\t\t\t\t (u32)IRDMA_MAX_CQ_READ_THRESH);\n\n\tif (irdma_sc_cq_init(cq, &info)) {\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: init cq fail\\n\");\n\t\terr_code = -EPROTO;\n\t\tgoto cq_free_rsrc;\n\t}\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&rf->cqp, true);\n\tif (!cqp_request) {\n\t\terr_code = -ENOMEM;\n\t\tgoto cq_free_rsrc;\n\t}\n\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = IRDMA_OP_CQ_CREATE;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.cq_create.cq = cq;\n\tcqp_info->in.u.cq_create.check_overflow = true;\n\tcqp_info->in.u.cq_create.scratch = (uintptr_t)cqp_request;\n\terr_code = irdma_handle_cqp_op(rf, cqp_request);\n\tirdma_put_cqp_request(&rf->cqp, cqp_request);\n\tif (err_code)\n\t\tgoto cq_free_rsrc;\n\n\tif (udata) {\n\t\tstruct irdma_create_cq_resp resp = {};\n\n\t\tresp.cq_id = info.cq_uk_init_info.cq_id;\n\t\tresp.cq_size = info.cq_uk_init_info.cq_size;\n\t\tif (ib_copy_to_udata(udata, &resp,\n\t\t\t\t     min(sizeof(resp), udata->outlen))) {\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"VERBS: copy to user data\\n\");\n\t\t\terr_code = -EPROTO;\n\t\t\tgoto cq_destroy;\n\t\t}\n\t}\n\trf->cq_table[cq_num] = iwcq;\n\tinit_completion(&iwcq->free_cq);\n\n\treturn 0;\ncq_destroy:\n\tirdma_cq_wq_destroy(rf, cq);\ncq_free_rsrc:\n\tirdma_cq_free_rsrc(rf, iwcq);\n\n\treturn err_code;\n}\n\n \nstatic inline u16 irdma_get_mr_access(int access)\n{\n\tu16 hw_access = 0;\n\n\thw_access |= (access & IB_ACCESS_LOCAL_WRITE) ?\n\t\t     IRDMA_ACCESS_FLAGS_LOCALWRITE : 0;\n\thw_access |= (access & IB_ACCESS_REMOTE_WRITE) ?\n\t\t     IRDMA_ACCESS_FLAGS_REMOTEWRITE : 0;\n\thw_access |= (access & IB_ACCESS_REMOTE_READ) ?\n\t\t     IRDMA_ACCESS_FLAGS_REMOTEREAD : 0;\n\thw_access |= (access & IB_ACCESS_MW_BIND) ?\n\t\t     IRDMA_ACCESS_FLAGS_BIND_WINDOW : 0;\n\thw_access |= (access & IB_ZERO_BASED) ?\n\t\t     IRDMA_ACCESS_FLAGS_ZERO_BASED : 0;\n\thw_access |= IRDMA_ACCESS_FLAGS_LOCALREAD;\n\n\treturn hw_access;\n}\n\n \nstatic void irdma_free_stag(struct irdma_device *iwdev, u32 stag)\n{\n\tu32 stag_idx;\n\n\tstag_idx = (stag & iwdev->rf->mr_stagmask) >> IRDMA_CQPSQ_STAG_IDX_S;\n\tirdma_free_rsrc(iwdev->rf, iwdev->rf->allocated_mrs, stag_idx);\n}\n\n \nstatic u32 irdma_create_stag(struct irdma_device *iwdev)\n{\n\tu32 stag = 0;\n\tu32 stag_index = 0;\n\tu32 next_stag_index;\n\tu32 driver_key;\n\tu32 random;\n\tu8 consumer_key;\n\tint ret;\n\n\tget_random_bytes(&random, sizeof(random));\n\tconsumer_key = (u8)random;\n\n\tdriver_key = random & ~iwdev->rf->mr_stagmask;\n\tnext_stag_index = (random & iwdev->rf->mr_stagmask) >> 8;\n\tnext_stag_index %= iwdev->rf->max_mr;\n\n\tret = irdma_alloc_rsrc(iwdev->rf, iwdev->rf->allocated_mrs,\n\t\t\t       iwdev->rf->max_mr, &stag_index,\n\t\t\t       &next_stag_index);\n\tif (ret)\n\t\treturn stag;\n\tstag = stag_index << IRDMA_CQPSQ_STAG_IDX_S;\n\tstag |= driver_key;\n\tstag += (u32)consumer_key;\n\n\treturn stag;\n}\n\n \nstatic inline u64 *irdma_next_pbl_addr(u64 *pbl, struct irdma_pble_info **pinfo,\n\t\t\t\t       u32 *idx)\n{\n\t*idx += 1;\n\tif (!(*pinfo) || *idx != (*pinfo)->cnt)\n\t\treturn ++pbl;\n\t*idx = 0;\n\t(*pinfo)++;\n\n\treturn (*pinfo)->addr;\n}\n\n \nstatic void irdma_copy_user_pgaddrs(struct irdma_mr *iwmr, u64 *pbl,\n\t\t\t\t    enum irdma_pble_level level)\n{\n\tstruct ib_umem *region = iwmr->region;\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tstruct irdma_pble_info *pinfo;\n\tstruct ib_block_iter biter;\n\tu32 idx = 0;\n\tu32 pbl_cnt = 0;\n\n\tpinfo = (level == PBLE_LEVEL_1) ? NULL : palloc->level2.leaf;\n\n\tif (iwmr->type == IRDMA_MEMREG_TYPE_QP)\n\t\tiwpbl->qp_mr.sq_page = sg_page(region->sgt_append.sgt.sgl);\n\n\trdma_umem_for_each_dma_block(region, &biter, iwmr->page_size) {\n\t\t*pbl = rdma_block_iter_dma_address(&biter);\n\t\tif (++pbl_cnt == palloc->total_cnt)\n\t\t\tbreak;\n\t\tpbl = irdma_next_pbl_addr(pbl, &pinfo, &idx);\n\t}\n}\n\n \nstatic bool irdma_check_mem_contiguous(u64 *arr, u32 npages, u32 pg_size)\n{\n\tu32 pg_idx;\n\n\tfor (pg_idx = 0; pg_idx < npages; pg_idx++) {\n\t\tif ((*arr + (pg_size * pg_idx)) != arr[pg_idx])\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic bool irdma_check_mr_contiguous(struct irdma_pble_alloc *palloc,\n\t\t\t\t      u32 pg_size)\n{\n\tstruct irdma_pble_level2 *lvl2 = &palloc->level2;\n\tstruct irdma_pble_info *leaf = lvl2->leaf;\n\tu64 *arr = NULL;\n\tu64 *start_addr = NULL;\n\tint i;\n\tbool ret;\n\n\tif (palloc->level == PBLE_LEVEL_1) {\n\t\tarr = palloc->level1.addr;\n\t\tret = irdma_check_mem_contiguous(arr, palloc->total_cnt,\n\t\t\t\t\t\t pg_size);\n\t\treturn ret;\n\t}\n\n\tstart_addr = leaf->addr;\n\n\tfor (i = 0; i < lvl2->leaf_cnt; i++, leaf++) {\n\t\tarr = leaf->addr;\n\t\tif ((*start_addr + (i * pg_size * PBLE_PER_PAGE)) != *arr)\n\t\t\treturn false;\n\t\tret = irdma_check_mem_contiguous(arr, leaf->cnt, pg_size);\n\t\tif (!ret)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic int irdma_setup_pbles(struct irdma_pci_f *rf, struct irdma_mr *iwmr,\n\t\t\t     u8 lvl)\n{\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tstruct irdma_pble_info *pinfo;\n\tu64 *pbl;\n\tint status;\n\tenum irdma_pble_level level = PBLE_LEVEL_1;\n\n\tif (lvl) {\n\t\tstatus = irdma_get_pble(rf->pble_rsrc, palloc, iwmr->page_cnt,\n\t\t\t\t\tlvl);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tiwpbl->pbl_allocated = true;\n\t\tlevel = palloc->level;\n\t\tpinfo = (level == PBLE_LEVEL_1) ? &palloc->level1 :\n\t\t\t\t\t\t  palloc->level2.leaf;\n\t\tpbl = pinfo->addr;\n\t} else {\n\t\tpbl = iwmr->pgaddrmem;\n\t}\n\n\tirdma_copy_user_pgaddrs(iwmr, pbl, level);\n\n\tif (lvl)\n\t\tiwmr->pgaddrmem[0] = *pbl;\n\n\treturn 0;\n}\n\n \nstatic int irdma_handle_q_mem(struct irdma_device *iwdev,\n\t\t\t      struct irdma_mem_reg_req *req,\n\t\t\t      struct irdma_pbl *iwpbl, u8 lvl)\n{\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tstruct irdma_mr *iwmr = iwpbl->iwmr;\n\tstruct irdma_qp_mr *qpmr = &iwpbl->qp_mr;\n\tstruct irdma_cq_mr *cqmr = &iwpbl->cq_mr;\n\tstruct irdma_hmc_pble *hmc_p;\n\tu64 *arr = iwmr->pgaddrmem;\n\tu32 pg_size, total;\n\tint err = 0;\n\tbool ret = true;\n\n\tpg_size = iwmr->page_size;\n\terr = irdma_setup_pbles(iwdev->rf, iwmr, lvl);\n\tif (err)\n\t\treturn err;\n\n\tif (lvl)\n\t\tarr = palloc->level1.addr;\n\n\tswitch (iwmr->type) {\n\tcase IRDMA_MEMREG_TYPE_QP:\n\t\ttotal = req->sq_pages + req->rq_pages;\n\t\thmc_p = &qpmr->sq_pbl;\n\t\tqpmr->shadow = (dma_addr_t)arr[total];\n\n\t\tif (lvl) {\n\t\t\tret = irdma_check_mem_contiguous(arr, req->sq_pages,\n\t\t\t\t\t\t\t pg_size);\n\t\t\tif (ret)\n\t\t\t\tret = irdma_check_mem_contiguous(&arr[req->sq_pages],\n\t\t\t\t\t\t\t\t req->rq_pages,\n\t\t\t\t\t\t\t\t pg_size);\n\t\t}\n\n\t\tif (!ret) {\n\t\t\thmc_p->idx = palloc->level1.idx;\n\t\t\thmc_p = &qpmr->rq_pbl;\n\t\t\thmc_p->idx = palloc->level1.idx + req->sq_pages;\n\t\t} else {\n\t\t\thmc_p->addr = arr[0];\n\t\t\thmc_p = &qpmr->rq_pbl;\n\t\t\thmc_p->addr = arr[req->sq_pages];\n\t\t}\n\t\tbreak;\n\tcase IRDMA_MEMREG_TYPE_CQ:\n\t\thmc_p = &cqmr->cq_pbl;\n\n\t\tif (!cqmr->split)\n\t\t\tcqmr->shadow = (dma_addr_t)arr[req->cq_pages];\n\n\t\tif (lvl)\n\t\t\tret = irdma_check_mem_contiguous(arr, req->cq_pages,\n\t\t\t\t\t\t\t pg_size);\n\n\t\tif (!ret)\n\t\t\thmc_p->idx = palloc->level1.idx;\n\t\telse\n\t\t\thmc_p->addr = arr[0];\n\tbreak;\n\tdefault:\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: MR type error\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tif (lvl && ret) {\n\t\tirdma_free_pble(iwdev->rf->pble_rsrc, palloc);\n\t\tiwpbl->pbl_allocated = false;\n\t}\n\n\treturn err;\n}\n\n \nstatic int irdma_hw_alloc_mw(struct irdma_device *iwdev, struct irdma_mr *iwmr)\n{\n\tstruct irdma_mw_alloc_info *info;\n\tstruct irdma_pd *iwpd = to_iwpd(iwmr->ibmr.pd);\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tinfo = &cqp_info->in.u.mw_alloc.info;\n\tmemset(info, 0, sizeof(*info));\n\tif (iwmr->ibmw.type == IB_MW_TYPE_1)\n\t\tinfo->mw_wide = true;\n\n\tinfo->page_size = PAGE_SIZE;\n\tinfo->mw_stag_index = iwmr->stag >> IRDMA_CQPSQ_STAG_IDX_S;\n\tinfo->pd_id = iwpd->sc_pd.pd_id;\n\tinfo->remote_access = true;\n\tcqp_info->cqp_cmd = IRDMA_OP_MW_ALLOC;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.mw_alloc.dev = &iwdev->rf->sc_dev;\n\tcqp_info->in.u.mw_alloc.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nstatic int irdma_alloc_mw(struct ib_mw *ibmw, struct ib_udata *udata)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibmw->device);\n\tstruct irdma_mr *iwmr = to_iwmw(ibmw);\n\tint err_code;\n\tu32 stag;\n\n\tstag = irdma_create_stag(iwdev);\n\tif (!stag)\n\t\treturn -ENOMEM;\n\n\tiwmr->stag = stag;\n\tibmw->rkey = stag;\n\n\terr_code = irdma_hw_alloc_mw(iwdev, iwmr);\n\tif (err_code) {\n\t\tirdma_free_stag(iwdev, stag);\n\t\treturn err_code;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int irdma_dealloc_mw(struct ib_mw *ibmw)\n{\n\tstruct ib_pd *ibpd = ibmw->pd;\n\tstruct irdma_pd *iwpd = to_iwpd(ibpd);\n\tstruct irdma_mr *iwmr = to_iwmr((struct ib_mr *)ibmw);\n\tstruct irdma_device *iwdev = to_iwdev(ibmw->device);\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_dealloc_stag_info *info;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tinfo = &cqp_info->in.u.dealloc_stag.info;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->pd_id = iwpd->sc_pd.pd_id;\n\tinfo->stag_idx = ibmw->rkey >> IRDMA_CQPSQ_STAG_IDX_S;\n\tinfo->mr = false;\n\tcqp_info->cqp_cmd = IRDMA_OP_DEALLOC_STAG;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.dealloc_stag.dev = &iwdev->rf->sc_dev;\n\tcqp_info->in.u.dealloc_stag.scratch = (uintptr_t)cqp_request;\n\tirdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\tirdma_free_stag(iwdev, iwmr->stag);\n\n\treturn 0;\n}\n\n \nstatic int irdma_hw_alloc_stag(struct irdma_device *iwdev,\n\t\t\t       struct irdma_mr *iwmr)\n{\n\tstruct irdma_allocate_stag_info *info;\n\tstruct ib_pd *pd = iwmr->ibmr.pd;\n\tstruct irdma_pd *iwpd = to_iwpd(pd);\n\tint status;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tinfo = &cqp_info->in.u.alloc_stag.info;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->page_size = PAGE_SIZE;\n\tinfo->stag_idx = iwmr->stag >> IRDMA_CQPSQ_STAG_IDX_S;\n\tinfo->pd_id = iwpd->sc_pd.pd_id;\n\tinfo->total_len = iwmr->len;\n\tinfo->all_memory = pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY;\n\tinfo->remote_access = true;\n\tcqp_info->cqp_cmd = IRDMA_OP_ALLOC_STAG;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.alloc_stag.dev = &iwdev->rf->sc_dev;\n\tcqp_info->in.u.alloc_stag.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nstatic struct ib_mr *irdma_alloc_mr(struct ib_pd *pd, enum ib_mr_type mr_type,\n\t\t\t\t    u32 max_num_sg)\n{\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct irdma_pble_alloc *palloc;\n\tstruct irdma_pbl *iwpbl;\n\tstruct irdma_mr *iwmr;\n\tu32 stag;\n\tint err_code;\n\n\tiwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\n\tif (!iwmr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstag = irdma_create_stag(iwdev);\n\tif (!stag) {\n\t\terr_code = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tiwmr->stag = stag;\n\tiwmr->ibmr.rkey = stag;\n\tiwmr->ibmr.lkey = stag;\n\tiwmr->ibmr.pd = pd;\n\tiwmr->ibmr.device = pd->device;\n\tiwpbl = &iwmr->iwpbl;\n\tiwpbl->iwmr = iwmr;\n\tiwmr->type = IRDMA_MEMREG_TYPE_MEM;\n\tpalloc = &iwpbl->pble_alloc;\n\tiwmr->page_cnt = max_num_sg;\n\t \n\tiwmr->len = max_num_sg * PAGE_SIZE;\n\terr_code = irdma_get_pble(iwdev->rf->pble_rsrc, palloc, iwmr->page_cnt,\n\t\t\t\t  false);\n\tif (err_code)\n\t\tgoto err_get_pble;\n\n\terr_code = irdma_hw_alloc_stag(iwdev, iwmr);\n\tif (err_code)\n\t\tgoto err_alloc_stag;\n\n\tiwpbl->pbl_allocated = true;\n\n\treturn &iwmr->ibmr;\nerr_alloc_stag:\n\tirdma_free_pble(iwdev->rf->pble_rsrc, palloc);\nerr_get_pble:\n\tirdma_free_stag(iwdev, stag);\nerr:\n\tkfree(iwmr);\n\n\treturn ERR_PTR(err_code);\n}\n\n \nstatic int irdma_set_page(struct ib_mr *ibmr, u64 addr)\n{\n\tstruct irdma_mr *iwmr = to_iwmr(ibmr);\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tu64 *pbl;\n\n\tif (unlikely(iwmr->npages == iwmr->page_cnt))\n\t\treturn -ENOMEM;\n\n\tif (palloc->level == PBLE_LEVEL_2) {\n\t\tstruct irdma_pble_info *palloc_info =\n\t\t\tpalloc->level2.leaf + (iwmr->npages >> PBLE_512_SHIFT);\n\n\t\tpalloc_info->addr[iwmr->npages & (PBLE_PER_PAGE - 1)] = addr;\n\t} else {\n\t\tpbl = palloc->level1.addr;\n\t\tpbl[iwmr->npages] = addr;\n\t}\n\tiwmr->npages++;\n\n\treturn 0;\n}\n\n \nstatic int irdma_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg,\n\t\t\t   int sg_nents, unsigned int *sg_offset)\n{\n\tstruct irdma_mr *iwmr = to_iwmr(ibmr);\n\n\tiwmr->npages = 0;\n\n\treturn ib_sg_to_pages(ibmr, sg, sg_nents, sg_offset, irdma_set_page);\n}\n\n \nstatic int irdma_hwreg_mr(struct irdma_device *iwdev, struct irdma_mr *iwmr,\n\t\t\t  u16 access)\n{\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_reg_ns_stag_info *stag_info;\n\tstruct ib_pd *pd = iwmr->ibmr.pd;\n\tstruct irdma_pd *iwpd = to_iwpd(pd);\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint ret;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tstag_info = &cqp_info->in.u.mr_reg_non_shared.info;\n\tmemset(stag_info, 0, sizeof(*stag_info));\n\tstag_info->va = iwpbl->user_base;\n\tstag_info->stag_idx = iwmr->stag >> IRDMA_CQPSQ_STAG_IDX_S;\n\tstag_info->stag_key = (u8)iwmr->stag;\n\tstag_info->total_len = iwmr->len;\n\tstag_info->access_rights = irdma_get_mr_access(access);\n\tstag_info->pd_id = iwpd->sc_pd.pd_id;\n\tstag_info->all_memory = pd->flags & IB_PD_UNSAFE_GLOBAL_RKEY;\n\tif (stag_info->access_rights & IRDMA_ACCESS_FLAGS_ZERO_BASED)\n\t\tstag_info->addr_type = IRDMA_ADDR_TYPE_ZERO_BASED;\n\telse\n\t\tstag_info->addr_type = IRDMA_ADDR_TYPE_VA_BASED;\n\tstag_info->page_size = iwmr->page_size;\n\n\tif (iwpbl->pbl_allocated) {\n\t\tif (palloc->level == PBLE_LEVEL_1) {\n\t\t\tstag_info->first_pm_pbl_index = palloc->level1.idx;\n\t\t\tstag_info->chunk_size = 1;\n\t\t} else {\n\t\t\tstag_info->first_pm_pbl_index = palloc->level2.root.idx;\n\t\t\tstag_info->chunk_size = 3;\n\t\t}\n\t} else {\n\t\tstag_info->reg_addr_pa = iwmr->pgaddrmem[0];\n\t}\n\n\tcqp_info->cqp_cmd = IRDMA_OP_MR_REG_NON_SHARED;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.mr_reg_non_shared.dev = &iwdev->rf->sc_dev;\n\tcqp_info->in.u.mr_reg_non_shared.scratch = (uintptr_t)cqp_request;\n\tret = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\n\treturn ret;\n}\n\nstatic int irdma_reg_user_mr_type_mem(struct irdma_mr *iwmr, int access)\n{\n\tstruct irdma_device *iwdev = to_iwdev(iwmr->ibmr.device);\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tu32 stag;\n\tu8 lvl;\n\tint err;\n\n\tlvl = iwmr->page_cnt != 1 ? PBLE_LEVEL_1 | PBLE_LEVEL_2 : PBLE_LEVEL_0;\n\n\terr = irdma_setup_pbles(iwdev->rf, iwmr, lvl);\n\tif (err)\n\t\treturn err;\n\n\tif (lvl) {\n\t\terr = irdma_check_mr_contiguous(&iwpbl->pble_alloc,\n\t\t\t\t\t\tiwmr->page_size);\n\t\tif (err) {\n\t\t\tirdma_free_pble(iwdev->rf->pble_rsrc, &iwpbl->pble_alloc);\n\t\t\tiwpbl->pbl_allocated = false;\n\t\t}\n\t}\n\n\tstag = irdma_create_stag(iwdev);\n\tif (!stag) {\n\t\terr = -ENOMEM;\n\t\tgoto free_pble;\n\t}\n\n\tiwmr->stag = stag;\n\tiwmr->ibmr.rkey = stag;\n\tiwmr->ibmr.lkey = stag;\n\terr = irdma_hwreg_mr(iwdev, iwmr, access);\n\tif (err)\n\t\tgoto err_hwreg;\n\n\treturn 0;\n\nerr_hwreg:\n\tirdma_free_stag(iwdev, stag);\n\nfree_pble:\n\tif (iwpbl->pble_alloc.level != PBLE_LEVEL_0 && iwpbl->pbl_allocated)\n\t\tirdma_free_pble(iwdev->rf->pble_rsrc, &iwpbl->pble_alloc);\n\n\treturn err;\n}\n\nstatic struct irdma_mr *irdma_alloc_iwmr(struct ib_umem *region,\n\t\t\t\t\t struct ib_pd *pd, u64 virt,\n\t\t\t\t\t enum irdma_memreg_type reg_type)\n{\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct irdma_pbl *iwpbl;\n\tstruct irdma_mr *iwmr;\n\tunsigned long pgsz_bitmap;\n\n\tiwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\n\tif (!iwmr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiwpbl = &iwmr->iwpbl;\n\tiwpbl->iwmr = iwmr;\n\tiwmr->region = region;\n\tiwmr->ibmr.pd = pd;\n\tiwmr->ibmr.device = pd->device;\n\tiwmr->ibmr.iova = virt;\n\tiwmr->type = reg_type;\n\n\tpgsz_bitmap = (reg_type == IRDMA_MEMREG_TYPE_MEM) ?\n\t\tiwdev->rf->sc_dev.hw_attrs.page_size_cap : SZ_4K;\n\n\tiwmr->page_size = ib_umem_find_best_pgsz(region, pgsz_bitmap, virt);\n\tif (unlikely(!iwmr->page_size)) {\n\t\tkfree(iwmr);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tiwmr->len = region->length;\n\tiwpbl->user_base = virt;\n\tiwmr->page_cnt = ib_umem_num_dma_blocks(region, iwmr->page_size);\n\n\treturn iwmr;\n}\n\nstatic void irdma_free_iwmr(struct irdma_mr *iwmr)\n{\n\tkfree(iwmr);\n}\n\nstatic int irdma_reg_user_mr_type_qp(struct irdma_mem_reg_req req,\n\t\t\t\t     struct ib_udata *udata,\n\t\t\t\t     struct irdma_mr *iwmr)\n{\n\tstruct irdma_device *iwdev = to_iwdev(iwmr->ibmr.device);\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_ucontext *ucontext = NULL;\n\tunsigned long flags;\n\tu32 total;\n\tint err;\n\tu8 lvl;\n\n\t \n\tif (!rdma_protocol_roce(&iwdev->ibdev, 1) &&\n\t    ib_umem_offset(iwmr->region))\n\t\treturn -EINVAL;\n\n\ttotal = req.sq_pages + req.rq_pages + 1;\n\tif (total > iwmr->page_cnt)\n\t\treturn -EINVAL;\n\n\ttotal = req.sq_pages + req.rq_pages;\n\tlvl = total > 2 ? PBLE_LEVEL_1 : PBLE_LEVEL_0;\n\terr = irdma_handle_q_mem(iwdev, &req, iwpbl, lvl);\n\tif (err)\n\t\treturn err;\n\n\tucontext = rdma_udata_to_drv_context(udata, struct irdma_ucontext,\n\t\t\t\t\t     ibucontext);\n\tspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\n\tlist_add_tail(&iwpbl->list, &ucontext->qp_reg_mem_list);\n\tiwpbl->on_list = true;\n\tspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\n\n\treturn 0;\n}\n\nstatic int irdma_reg_user_mr_type_cq(struct irdma_mem_reg_req req,\n\t\t\t\t     struct ib_udata *udata,\n\t\t\t\t     struct irdma_mr *iwmr)\n{\n\tstruct irdma_device *iwdev = to_iwdev(iwmr->ibmr.device);\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_ucontext *ucontext = NULL;\n\tu8 shadow_pgcnt = 1;\n\tunsigned long flags;\n\tu32 total;\n\tint err;\n\tu8 lvl;\n\n\tif (iwdev->rf->sc_dev.hw_attrs.uk_attrs.feature_flags & IRDMA_FEATURE_CQ_RESIZE)\n\t\tshadow_pgcnt = 0;\n\ttotal = req.cq_pages + shadow_pgcnt;\n\tif (total > iwmr->page_cnt)\n\t\treturn -EINVAL;\n\n\tlvl = req.cq_pages > 1 ? PBLE_LEVEL_1 : PBLE_LEVEL_0;\n\terr = irdma_handle_q_mem(iwdev, &req, iwpbl, lvl);\n\tif (err)\n\t\treturn err;\n\n\tucontext = rdma_udata_to_drv_context(udata, struct irdma_ucontext,\n\t\t\t\t\t     ibucontext);\n\tspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\n\tlist_add_tail(&iwpbl->list, &ucontext->cq_reg_mem_list);\n\tiwpbl->on_list = true;\n\tspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic struct ib_mr *irdma_reg_user_mr(struct ib_pd *pd, u64 start, u64 len,\n\t\t\t\t       u64 virt, int access,\n\t\t\t\t       struct ib_udata *udata)\n{\n#define IRDMA_MEM_REG_MIN_REQ_LEN offsetofend(struct irdma_mem_reg_req, sq_pages)\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct irdma_mem_reg_req req = {};\n\tstruct ib_umem *region = NULL;\n\tstruct irdma_mr *iwmr = NULL;\n\tint err;\n\n\tif (len > iwdev->rf->sc_dev.hw_attrs.max_mr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (udata->inlen < IRDMA_MEM_REG_MIN_REQ_LEN)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tregion = ib_umem_get(pd->device, start, len, access);\n\n\tif (IS_ERR(region)) {\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"VERBS: Failed to create ib_umem region\\n\");\n\t\treturn (struct ib_mr *)region;\n\t}\n\n\tif (ib_copy_from_udata(&req, udata, min(sizeof(req), udata->inlen))) {\n\t\tib_umem_release(region);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\tiwmr = irdma_alloc_iwmr(region, pd, virt, req.reg_type);\n\tif (IS_ERR(iwmr)) {\n\t\tib_umem_release(region);\n\t\treturn (struct ib_mr *)iwmr;\n\t}\n\n\tswitch (req.reg_type) {\n\tcase IRDMA_MEMREG_TYPE_QP:\n\t\terr = irdma_reg_user_mr_type_qp(req, udata, iwmr);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tcase IRDMA_MEMREG_TYPE_CQ:\n\t\terr = irdma_reg_user_mr_type_cq(req, udata, iwmr);\n\t\tif (err)\n\t\t\tgoto error;\n\t\tbreak;\n\tcase IRDMA_MEMREG_TYPE_MEM:\n\t\terr = irdma_reg_user_mr_type_mem(iwmr, access);\n\t\tif (err)\n\t\t\tgoto error;\n\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\treturn &iwmr->ibmr;\nerror:\n\tib_umem_release(region);\n\tirdma_free_iwmr(iwmr);\n\n\treturn ERR_PTR(err);\n}\n\nstatic struct ib_mr *irdma_reg_user_mr_dmabuf(struct ib_pd *pd, u64 start,\n\t\t\t\t\t      u64 len, u64 virt,\n\t\t\t\t\t      int fd, int access,\n\t\t\t\t\t      struct ib_udata *udata)\n{\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct ib_umem_dmabuf *umem_dmabuf;\n\tstruct irdma_mr *iwmr;\n\tint err;\n\n\tif (len > iwdev->rf->sc_dev.hw_attrs.max_mr_size)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tumem_dmabuf = ib_umem_dmabuf_get_pinned(pd->device, start, len, fd, access);\n\tif (IS_ERR(umem_dmabuf)) {\n\t\terr = PTR_ERR(umem_dmabuf);\n\t\tibdev_dbg(&iwdev->ibdev, \"Failed to get dmabuf umem[%d]\\n\", err);\n\t\treturn ERR_PTR(err);\n\t}\n\n\tiwmr = irdma_alloc_iwmr(&umem_dmabuf->umem, pd, virt, IRDMA_MEMREG_TYPE_MEM);\n\tif (IS_ERR(iwmr)) {\n\t\terr = PTR_ERR(iwmr);\n\t\tgoto err_release;\n\t}\n\n\terr = irdma_reg_user_mr_type_mem(iwmr, access);\n\tif (err)\n\t\tgoto err_iwmr;\n\n\treturn &iwmr->ibmr;\n\nerr_iwmr:\n\tirdma_free_iwmr(iwmr);\n\nerr_release:\n\tib_umem_release(&umem_dmabuf->umem);\n\n\treturn ERR_PTR(err);\n}\n\n \nstruct ib_mr *irdma_reg_phys_mr(struct ib_pd *pd, u64 addr, u64 size, int access,\n\t\t\t\tu64 *iova_start)\n{\n\tstruct irdma_device *iwdev = to_iwdev(pd->device);\n\tstruct irdma_pbl *iwpbl;\n\tstruct irdma_mr *iwmr;\n\tu32 stag;\n\tint ret;\n\n\tiwmr = kzalloc(sizeof(*iwmr), GFP_KERNEL);\n\tif (!iwmr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tiwmr->ibmr.pd = pd;\n\tiwmr->ibmr.device = pd->device;\n\tiwpbl = &iwmr->iwpbl;\n\tiwpbl->iwmr = iwmr;\n\tiwmr->type = IRDMA_MEMREG_TYPE_MEM;\n\tiwpbl->user_base = *iova_start;\n\tstag = irdma_create_stag(iwdev);\n\tif (!stag) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tiwmr->stag = stag;\n\tiwmr->ibmr.iova = *iova_start;\n\tiwmr->ibmr.rkey = stag;\n\tiwmr->ibmr.lkey = stag;\n\tiwmr->page_cnt = 1;\n\tiwmr->pgaddrmem[0] = addr;\n\tiwmr->len = size;\n\tiwmr->page_size = SZ_4K;\n\tret = irdma_hwreg_mr(iwdev, iwmr, access);\n\tif (ret) {\n\t\tirdma_free_stag(iwdev, stag);\n\t\tgoto err;\n\t}\n\n\treturn &iwmr->ibmr;\n\nerr:\n\tkfree(iwmr);\n\n\treturn ERR_PTR(ret);\n}\n\n \nstatic struct ib_mr *irdma_get_dma_mr(struct ib_pd *pd, int acc)\n{\n\tu64 kva = 0;\n\n\treturn irdma_reg_phys_mr(pd, 0, 0, acc, &kva);\n}\n\n \nstatic void irdma_del_memlist(struct irdma_mr *iwmr,\n\t\t\t      struct irdma_ucontext *ucontext)\n{\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tunsigned long flags;\n\n\tswitch (iwmr->type) {\n\tcase IRDMA_MEMREG_TYPE_CQ:\n\t\tspin_lock_irqsave(&ucontext->cq_reg_mem_list_lock, flags);\n\t\tif (iwpbl->on_list) {\n\t\t\tiwpbl->on_list = false;\n\t\t\tlist_del(&iwpbl->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&ucontext->cq_reg_mem_list_lock, flags);\n\t\tbreak;\n\tcase IRDMA_MEMREG_TYPE_QP:\n\t\tspin_lock_irqsave(&ucontext->qp_reg_mem_list_lock, flags);\n\t\tif (iwpbl->on_list) {\n\t\t\tiwpbl->on_list = false;\n\t\t\tlist_del(&iwpbl->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&ucontext->qp_reg_mem_list_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nstatic int irdma_dereg_mr(struct ib_mr *ib_mr, struct ib_udata *udata)\n{\n\tstruct ib_pd *ibpd = ib_mr->pd;\n\tstruct irdma_pd *iwpd = to_iwpd(ibpd);\n\tstruct irdma_mr *iwmr = to_iwmr(ib_mr);\n\tstruct irdma_device *iwdev = to_iwdev(ib_mr->device);\n\tstruct irdma_dealloc_stag_info *info;\n\tstruct irdma_pbl *iwpbl = &iwmr->iwpbl;\n\tstruct irdma_pble_alloc *palloc = &iwpbl->pble_alloc;\n\tstruct irdma_cqp_request *cqp_request;\n\tstruct cqp_cmds_info *cqp_info;\n\tint status;\n\n\tif (iwmr->type != IRDMA_MEMREG_TYPE_MEM) {\n\t\tif (iwmr->region) {\n\t\t\tstruct irdma_ucontext *ucontext;\n\n\t\t\tucontext = rdma_udata_to_drv_context(udata,\n\t\t\t\t\t\tstruct irdma_ucontext,\n\t\t\t\t\t\tibucontext);\n\t\t\tirdma_del_memlist(iwmr, ucontext);\n\t\t}\n\t\tgoto done;\n\t}\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_info = &cqp_request->info;\n\tinfo = &cqp_info->in.u.dealloc_stag.info;\n\tmemset(info, 0, sizeof(*info));\n\tinfo->pd_id = iwpd->sc_pd.pd_id;\n\tinfo->stag_idx = ib_mr->rkey >> IRDMA_CQPSQ_STAG_IDX_S;\n\tinfo->mr = true;\n\tif (iwpbl->pbl_allocated)\n\t\tinfo->dealloc_pbl = true;\n\n\tcqp_info->cqp_cmd = IRDMA_OP_DEALLOC_STAG;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.dealloc_stag.dev = &iwdev->rf->sc_dev;\n\tcqp_info->in.u.dealloc_stag.scratch = (uintptr_t)cqp_request;\n\tstatus = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\tif (status)\n\t\treturn status;\n\n\tirdma_free_stag(iwdev, iwmr->stag);\ndone:\n\tif (iwpbl->pbl_allocated)\n\t\tirdma_free_pble(iwdev->rf->pble_rsrc, palloc);\n\tib_umem_release(iwmr->region);\n\tkfree(iwmr);\n\n\treturn 0;\n}\n\n \nstatic int irdma_post_send(struct ib_qp *ibqp,\n\t\t\t   const struct ib_send_wr *ib_wr,\n\t\t\t   const struct ib_send_wr **bad_wr)\n{\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_qp_uk *ukqp;\n\tstruct irdma_sc_dev *dev;\n\tstruct irdma_post_sq_info info;\n\tint err = 0;\n\tunsigned long flags;\n\tbool inv_stag;\n\tstruct irdma_ah *ah;\n\n\tiwqp = to_iwqp(ibqp);\n\tukqp = &iwqp->sc_qp.qp_uk;\n\tdev = &iwqp->iwdev->rf->sc_dev;\n\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\twhile (ib_wr) {\n\t\tmemset(&info, 0, sizeof(info));\n\t\tinv_stag = false;\n\t\tinfo.wr_id = (ib_wr->wr_id);\n\t\tif ((ib_wr->send_flags & IB_SEND_SIGNALED) || iwqp->sig_all)\n\t\t\tinfo.signaled = true;\n\t\tif (ib_wr->send_flags & IB_SEND_FENCE)\n\t\t\tinfo.read_fence = true;\n\t\tswitch (ib_wr->opcode) {\n\t\tcase IB_WR_SEND_WITH_IMM:\n\t\t\tif (ukqp->qp_caps & IRDMA_SEND_WITH_IMM) {\n\t\t\t\tinfo.imm_data_valid = true;\n\t\t\t\tinfo.imm_data = ntohl(ib_wr->ex.imm_data);\n\t\t\t} else {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase IB_WR_SEND:\n\t\tcase IB_WR_SEND_WITH_INV:\n\t\t\tif (ib_wr->opcode == IB_WR_SEND ||\n\t\t\t    ib_wr->opcode == IB_WR_SEND_WITH_IMM) {\n\t\t\t\tif (ib_wr->send_flags & IB_SEND_SOLICITED)\n\t\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_SEND_SOL;\n\t\t\t\telse\n\t\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_SEND;\n\t\t\t} else {\n\t\t\t\tif (ib_wr->send_flags & IB_SEND_SOLICITED)\n\t\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_SEND_SOL_INV;\n\t\t\t\telse\n\t\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_SEND_INV;\n\t\t\t\tinfo.stag_to_inv = ib_wr->ex.invalidate_rkey;\n\t\t\t}\n\n\t\t\tinfo.op.send.num_sges = ib_wr->num_sge;\n\t\t\tinfo.op.send.sg_list = ib_wr->sg_list;\n\t\t\tif (iwqp->ibqp.qp_type == IB_QPT_UD ||\n\t\t\t    iwqp->ibqp.qp_type == IB_QPT_GSI) {\n\t\t\t\tah = to_iwah(ud_wr(ib_wr)->ah);\n\t\t\t\tinfo.op.send.ah_id = ah->sc_ah.ah_info.ah_idx;\n\t\t\t\tinfo.op.send.qkey = ud_wr(ib_wr)->remote_qkey;\n\t\t\t\tinfo.op.send.dest_qp = ud_wr(ib_wr)->remote_qpn;\n\t\t\t}\n\n\t\t\tif (ib_wr->send_flags & IB_SEND_INLINE)\n\t\t\t\terr = irdma_uk_inline_send(ukqp, &info, false);\n\t\t\telse\n\t\t\t\terr = irdma_uk_send(ukqp, &info, false);\n\t\t\tbreak;\n\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\tif (ukqp->qp_caps & IRDMA_WRITE_WITH_IMM) {\n\t\t\t\tinfo.imm_data_valid = true;\n\t\t\t\tinfo.imm_data = ntohl(ib_wr->ex.imm_data);\n\t\t\t} else {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tif (ib_wr->send_flags & IB_SEND_SOLICITED)\n\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_RDMA_WRITE_SOL;\n\t\t\telse\n\t\t\t\tinfo.op_type = IRDMA_OP_TYPE_RDMA_WRITE;\n\n\t\t\tinfo.op.rdma_write.num_lo_sges = ib_wr->num_sge;\n\t\t\tinfo.op.rdma_write.lo_sg_list = ib_wr->sg_list;\n\t\t\tinfo.op.rdma_write.rem_addr.addr =\n\t\t\t\trdma_wr(ib_wr)->remote_addr;\n\t\t\tinfo.op.rdma_write.rem_addr.lkey = rdma_wr(ib_wr)->rkey;\n\t\t\tif (ib_wr->send_flags & IB_SEND_INLINE)\n\t\t\t\terr = irdma_uk_inline_rdma_write(ukqp, &info, false);\n\t\t\telse\n\t\t\t\terr = irdma_uk_rdma_write(ukqp, &info, false);\n\t\t\tbreak;\n\t\tcase IB_WR_RDMA_READ_WITH_INV:\n\t\t\tinv_stag = true;\n\t\t\tfallthrough;\n\t\tcase IB_WR_RDMA_READ:\n\t\t\tif (ib_wr->num_sge >\n\t\t\t    dev->hw_attrs.uk_attrs.max_hw_read_sges) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tinfo.op_type = IRDMA_OP_TYPE_RDMA_READ;\n\t\t\tinfo.op.rdma_read.rem_addr.addr = rdma_wr(ib_wr)->remote_addr;\n\t\t\tinfo.op.rdma_read.rem_addr.lkey = rdma_wr(ib_wr)->rkey;\n\t\t\tinfo.op.rdma_read.lo_sg_list = (void *)ib_wr->sg_list;\n\t\t\tinfo.op.rdma_read.num_lo_sges = ib_wr->num_sge;\n\t\t\terr = irdma_uk_rdma_read(ukqp, &info, inv_stag, false);\n\t\t\tbreak;\n\t\tcase IB_WR_LOCAL_INV:\n\t\t\tinfo.op_type = IRDMA_OP_TYPE_INV_STAG;\n\t\t\tinfo.local_fence = info.read_fence;\n\t\t\tinfo.op.inv_local_stag.target_stag = ib_wr->ex.invalidate_rkey;\n\t\t\terr = irdma_uk_stag_local_invalidate(ukqp, &info, true);\n\t\t\tbreak;\n\t\tcase IB_WR_REG_MR: {\n\t\t\tstruct irdma_mr *iwmr = to_iwmr(reg_wr(ib_wr)->mr);\n\t\t\tstruct irdma_pble_alloc *palloc = &iwmr->iwpbl.pble_alloc;\n\t\t\tstruct irdma_fast_reg_stag_info stag_info = {};\n\n\t\t\tstag_info.signaled = info.signaled;\n\t\t\tstag_info.read_fence = info.read_fence;\n\t\t\tstag_info.access_rights = irdma_get_mr_access(reg_wr(ib_wr)->access);\n\t\t\tstag_info.stag_key = reg_wr(ib_wr)->key & 0xff;\n\t\t\tstag_info.stag_idx = reg_wr(ib_wr)->key >> 8;\n\t\t\tstag_info.page_size = reg_wr(ib_wr)->mr->page_size;\n\t\t\tstag_info.wr_id = ib_wr->wr_id;\n\t\t\tstag_info.addr_type = IRDMA_ADDR_TYPE_VA_BASED;\n\t\t\tstag_info.va = (void *)(uintptr_t)iwmr->ibmr.iova;\n\t\t\tstag_info.total_len = iwmr->ibmr.length;\n\t\t\tstag_info.reg_addr_pa = *palloc->level1.addr;\n\t\t\tstag_info.first_pm_pbl_index = palloc->level1.idx;\n\t\t\tstag_info.local_fence = ib_wr->send_flags & IB_SEND_FENCE;\n\t\t\tif (iwmr->npages > IRDMA_MIN_PAGES_PER_FMR)\n\t\t\t\tstag_info.chunk_size = 1;\n\t\t\terr = irdma_sc_mr_fast_register(&iwqp->sc_qp, &stag_info,\n\t\t\t\t\t\t\ttrue);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tibdev_dbg(&iwqp->iwdev->ibdev,\n\t\t\t\t  \"VERBS: upost_send bad opcode = 0x%x\\n\",\n\t\t\t\t  ib_wr->opcode);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\tib_wr = ib_wr->next;\n\t}\n\n\tif (!iwqp->flush_issued) {\n\t\tif (iwqp->hw_iwarp_state <= IRDMA_QP_STATE_RTS)\n\t\t\tirdma_uk_qp_post_wr(ukqp);\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t} else {\n\t\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\t\tmod_delayed_work(iwqp->iwdev->cleanup_wq, &iwqp->dwork_flush,\n\t\t\t\t msecs_to_jiffies(IRDMA_FLUSH_DELAY_MS));\n\t}\n\tif (err)\n\t\t*bad_wr = ib_wr;\n\n\treturn err;\n}\n\n \nstatic int irdma_post_recv(struct ib_qp *ibqp,\n\t\t\t   const struct ib_recv_wr *ib_wr,\n\t\t\t   const struct ib_recv_wr **bad_wr)\n{\n\tstruct irdma_qp *iwqp;\n\tstruct irdma_qp_uk *ukqp;\n\tstruct irdma_post_rq_info post_recv = {};\n\tunsigned long flags;\n\tint err = 0;\n\n\tiwqp = to_iwqp(ibqp);\n\tukqp = &iwqp->sc_qp.qp_uk;\n\n\tspin_lock_irqsave(&iwqp->lock, flags);\n\twhile (ib_wr) {\n\t\tpost_recv.num_sges = ib_wr->num_sge;\n\t\tpost_recv.wr_id = ib_wr->wr_id;\n\t\tpost_recv.sg_list = ib_wr->sg_list;\n\t\terr = irdma_uk_post_receive(ukqp, &post_recv);\n\t\tif (err) {\n\t\t\tibdev_dbg(&iwqp->iwdev->ibdev,\n\t\t\t\t  \"VERBS: post_recv err %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tib_wr = ib_wr->next;\n\t}\n\nout:\n\tspin_unlock_irqrestore(&iwqp->lock, flags);\n\tif (iwqp->flush_issued)\n\t\tmod_delayed_work(iwqp->iwdev->cleanup_wq, &iwqp->dwork_flush,\n\t\t\t\t msecs_to_jiffies(IRDMA_FLUSH_DELAY_MS));\n\n\tif (err)\n\t\t*bad_wr = ib_wr;\n\n\treturn err;\n}\n\n \nstatic enum ib_wc_status irdma_flush_err_to_ib_wc_status(enum irdma_flush_opcode opcode)\n{\n\tswitch (opcode) {\n\tcase FLUSH_PROT_ERR:\n\t\treturn IB_WC_LOC_PROT_ERR;\n\tcase FLUSH_REM_ACCESS_ERR:\n\t\treturn IB_WC_REM_ACCESS_ERR;\n\tcase FLUSH_LOC_QP_OP_ERR:\n\t\treturn IB_WC_LOC_QP_OP_ERR;\n\tcase FLUSH_REM_OP_ERR:\n\t\treturn IB_WC_REM_OP_ERR;\n\tcase FLUSH_LOC_LEN_ERR:\n\t\treturn IB_WC_LOC_LEN_ERR;\n\tcase FLUSH_GENERAL_ERR:\n\t\treturn IB_WC_WR_FLUSH_ERR;\n\tcase FLUSH_RETRY_EXC_ERR:\n\t\treturn IB_WC_RETRY_EXC_ERR;\n\tcase FLUSH_MW_BIND_ERR:\n\t\treturn IB_WC_MW_BIND_ERR;\n\tcase FLUSH_REM_INV_REQ_ERR:\n\t\treturn IB_WC_REM_INV_REQ_ERR;\n\tcase FLUSH_FATAL_ERR:\n\tdefault:\n\t\treturn IB_WC_FATAL_ERR;\n\t}\n}\n\n \nstatic void irdma_process_cqe(struct ib_wc *entry,\n\t\t\t      struct irdma_cq_poll_info *cq_poll_info)\n{\n\tstruct irdma_sc_qp *qp;\n\n\tentry->wc_flags = 0;\n\tentry->pkey_index = 0;\n\tentry->wr_id = cq_poll_info->wr_id;\n\n\tqp = cq_poll_info->qp_handle;\n\tentry->qp = qp->qp_uk.back_qp;\n\n\tif (cq_poll_info->error) {\n\t\tentry->status = (cq_poll_info->comp_status == IRDMA_COMPL_STATUS_FLUSHED) ?\n\t\t\t\tirdma_flush_err_to_ib_wc_status(cq_poll_info->minor_err) : IB_WC_GENERAL_ERR;\n\n\t\tentry->vendor_err = cq_poll_info->major_err << 16 |\n\t\t\t\t    cq_poll_info->minor_err;\n\t} else {\n\t\tentry->status = IB_WC_SUCCESS;\n\t\tif (cq_poll_info->imm_valid) {\n\t\t\tentry->ex.imm_data = htonl(cq_poll_info->imm_data);\n\t\t\tentry->wc_flags |= IB_WC_WITH_IMM;\n\t\t}\n\t\tif (cq_poll_info->ud_smac_valid) {\n\t\t\tether_addr_copy(entry->smac, cq_poll_info->ud_smac);\n\t\t\tentry->wc_flags |= IB_WC_WITH_SMAC;\n\t\t}\n\n\t\tif (cq_poll_info->ud_vlan_valid) {\n\t\t\tu16 vlan = cq_poll_info->ud_vlan & VLAN_VID_MASK;\n\n\t\t\tentry->sl = cq_poll_info->ud_vlan >> VLAN_PRIO_SHIFT;\n\t\t\tif (vlan) {\n\t\t\t\tentry->vlan_id = vlan;\n\t\t\t\tentry->wc_flags |= IB_WC_WITH_VLAN;\n\t\t\t}\n\t\t} else {\n\t\t\tentry->sl = 0;\n\t\t}\n\t}\n\n\tif (cq_poll_info->q_type == IRDMA_CQE_QTYPE_SQ) {\n\t\tset_ib_wc_op_sq(cq_poll_info, entry);\n\t} else {\n\t\tset_ib_wc_op_rq(cq_poll_info, entry,\n\t\t\t\tqp->qp_uk.qp_caps & IRDMA_SEND_WITH_IMM);\n\t\tif (qp->qp_uk.qp_type != IRDMA_QP_TYPE_ROCE_UD &&\n\t\t    cq_poll_info->stag_invalid_set) {\n\t\t\tentry->ex.invalidate_rkey = cq_poll_info->inv_stag;\n\t\t\tentry->wc_flags |= IB_WC_WITH_INVALIDATE;\n\t\t}\n\t}\n\n\tif (qp->qp_uk.qp_type == IRDMA_QP_TYPE_ROCE_UD) {\n\t\tentry->src_qp = cq_poll_info->ud_src_qpn;\n\t\tentry->slid = 0;\n\t\tentry->wc_flags |=\n\t\t\t(IB_WC_GRH | IB_WC_WITH_NETWORK_HDR_TYPE);\n\t\tentry->network_hdr_type = cq_poll_info->ipv4 ?\n\t\t\t\t\t\t  RDMA_NETWORK_IPV4 :\n\t\t\t\t\t\t  RDMA_NETWORK_IPV6;\n\t} else {\n\t\tentry->src_qp = cq_poll_info->qp_id;\n\t}\n\n\tentry->byte_len = cq_poll_info->bytes_xfered;\n}\n\n \nstatic inline int irdma_poll_one(struct irdma_cq_uk *ukcq,\n\t\t\t\t struct irdma_cq_poll_info *cur_cqe,\n\t\t\t\t struct ib_wc *entry)\n{\n\tint ret = irdma_uk_cq_poll_cmpl(ukcq, cur_cqe);\n\n\tif (ret)\n\t\treturn ret;\n\n\tirdma_process_cqe(entry, cur_cqe);\n\n\treturn 0;\n}\n\n \nstatic int __irdma_poll_cq(struct irdma_cq *iwcq, int num_entries, struct ib_wc *entry)\n{\n\tstruct list_head *tmp_node, *list_node;\n\tstruct irdma_cq_buf *last_buf = NULL;\n\tstruct irdma_cq_poll_info *cur_cqe = &iwcq->cur_cqe;\n\tstruct irdma_cq_buf *cq_buf;\n\tint ret;\n\tstruct irdma_device *iwdev;\n\tstruct irdma_cq_uk *ukcq;\n\tbool cq_new_cqe = false;\n\tint resized_bufs = 0;\n\tint npolled = 0;\n\n\tiwdev = to_iwdev(iwcq->ibcq.device);\n\tukcq = &iwcq->sc_cq.cq_uk;\n\n\t \n\tlist_for_each_safe(list_node, tmp_node, &iwcq->resize_list) {\n\t\tcq_buf = container_of(list_node, struct irdma_cq_buf, list);\n\t\twhile (npolled < num_entries) {\n\t\t\tret = irdma_poll_one(&cq_buf->cq_uk, cur_cqe, entry + npolled);\n\t\t\tif (!ret) {\n\t\t\t\t++npolled;\n\t\t\t\tcq_new_cqe = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ret == -ENOENT)\n\t\t\t\tbreak;\n\t\t\t  \n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tcq_new_cqe = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tif (cq_new_cqe)\n\t\t\tlast_buf = cq_buf;\n\t\tcq_new_cqe = false;\n\t}\n\n\t \n\twhile (npolled < num_entries) {\n\t\tret = irdma_poll_one(ukcq, cur_cqe, entry + npolled);\n\t\tif (ret == -ENOENT) {\n\t\t\tret = irdma_generated_cmpls(iwcq, cur_cqe);\n\t\t\tif (!ret)\n\t\t\t\tirdma_process_cqe(entry + npolled, cur_cqe);\n\t\t}\n\t\tif (!ret) {\n\t\t\t++npolled;\n\t\t\tcq_new_cqe = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == -ENOENT)\n\t\t\tbreak;\n\t\t \n\t\tif (ret == -EFAULT) {\n\t\t\tcq_new_cqe = true;\n\t\t\tcontinue;\n\t\t}\n\t\tgoto error;\n\t}\n\n\tif (cq_new_cqe)\n\t\t \n\t\tresized_bufs = irdma_process_resize_list(iwcq, iwdev, NULL);\n\telse if (last_buf)\n\t\t \n\t\tresized_bufs = irdma_process_resize_list(iwcq, iwdev, last_buf);\n\tif (resized_bufs)\n\t\t \n\t\tirdma_uk_cq_set_resized_cnt(ukcq, resized_bufs);\n\n\treturn npolled;\nerror:\n\tibdev_dbg(&iwdev->ibdev, \"%s: Error polling CQ, irdma_err: %d\\n\",\n\t\t  __func__, ret);\n\n\treturn ret;\n}\n\n \nstatic int irdma_poll_cq(struct ib_cq *ibcq, int num_entries,\n\t\t\t struct ib_wc *entry)\n{\n\tstruct irdma_cq *iwcq;\n\tunsigned long flags;\n\tint ret;\n\n\tiwcq = to_iwcq(ibcq);\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\tret = __irdma_poll_cq(iwcq, num_entries, entry);\n\tspin_unlock_irqrestore(&iwcq->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int irdma_req_notify_cq(struct ib_cq *ibcq,\n\t\t\t       enum ib_cq_notify_flags notify_flags)\n{\n\tstruct irdma_cq *iwcq;\n\tstruct irdma_cq_uk *ukcq;\n\tunsigned long flags;\n\tenum irdma_cmpl_notify cq_notify;\n\tbool promo_event = false;\n\tint ret = 0;\n\n\tcq_notify = notify_flags == IB_CQ_SOLICITED ?\n\t\t    IRDMA_CQ_COMPL_SOLICITED : IRDMA_CQ_COMPL_EVENT;\n\tiwcq = to_iwcq(ibcq);\n\tukcq = &iwcq->sc_cq.cq_uk;\n\n\tspin_lock_irqsave(&iwcq->lock, flags);\n\t \n\tif (iwcq->last_notify == IRDMA_CQ_COMPL_SOLICITED && notify_flags != IB_CQ_SOLICITED)\n\t\tpromo_event = true;\n\n\tif (!atomic_cmpxchg(&iwcq->armed, 0, 1) || promo_event) {\n\t\tiwcq->last_notify = cq_notify;\n\t\tirdma_uk_cq_request_notification(ukcq, cq_notify);\n\t}\n\n\tif ((notify_flags & IB_CQ_REPORT_MISSED_EVENTS) &&\n\t    (!irdma_cq_empty(iwcq) || !list_empty(&iwcq->cmpl_generated)))\n\t\tret = 1;\n\tspin_unlock_irqrestore(&iwcq->lock, flags);\n\n\treturn ret;\n}\n\nstatic int irdma_roce_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t     struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tint err;\n\n\timmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE_UDP_ENCAP;\n\terr = ib_query_port(ibdev, port_num, &attr);\n\tif (err)\n\t\treturn err;\n\n\timmutable->max_mad_size = IB_MGMT_MAD_SIZE;\n\timmutable->pkey_tbl_len = attr.pkey_tbl_len;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\n\treturn 0;\n}\n\nstatic int irdma_iw_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t   struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tint err;\n\n\timmutable->core_cap_flags = RDMA_CORE_PORT_IWARP;\n\terr = ib_query_port(ibdev, port_num, &attr);\n\tif (err)\n\t\treturn err;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\n\treturn 0;\n}\n\nstatic const struct rdma_stat_desc irdma_hw_stat_names[] = {\n\t \n\t[IRDMA_HW_STAT_INDEX_IP4RXDISCARD].name\t\t= \"ip4InDiscards\",\n\t[IRDMA_HW_STAT_INDEX_IP4RXTRUNC].name\t\t= \"ip4InTruncatedPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXNOROUTE].name\t\t= \"ip4OutNoRoutes\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXDISCARD].name\t\t= \"ip6InDiscards\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXTRUNC].name\t\t= \"ip6InTruncatedPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXNOROUTE].name\t\t= \"ip6OutNoRoutes\",\n\t[IRDMA_HW_STAT_INDEX_TCPRTXSEG].name\t\t= \"tcpRetransSegs\",\n\t[IRDMA_HW_STAT_INDEX_TCPRXOPTERR].name\t\t= \"tcpInOptErrors\",\n\t[IRDMA_HW_STAT_INDEX_TCPRXPROTOERR].name\t= \"tcpInProtoErrors\",\n\t[IRDMA_HW_STAT_INDEX_RXVLANERR].name\t\t= \"rxVlanErrors\",\n\t \n\t[IRDMA_HW_STAT_INDEX_IP4RXOCTS].name\t\t= \"ip4InOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP4RXPKTS].name\t\t= \"ip4InPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP4RXFRAGS].name\t\t= \"ip4InReasmRqd\",\n\t[IRDMA_HW_STAT_INDEX_IP4RXMCPKTS].name\t\t= \"ip4InMcastPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXOCTS].name\t\t= \"ip4OutOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXPKTS].name\t\t= \"ip4OutPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXFRAGS].name\t\t= \"ip4OutSegRqd\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXMCPKTS].name\t\t= \"ip4OutMcastPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXOCTS].name\t\t= \"ip6InOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXPKTS].name\t\t= \"ip6InPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXFRAGS].name\t\t= \"ip6InReasmRqd\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXMCPKTS].name\t\t= \"ip6InMcastPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXOCTS].name\t\t= \"ip6OutOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXPKTS].name\t\t= \"ip6OutPkts\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXFRAGS].name\t\t= \"ip6OutSegRqd\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXMCPKTS].name\t\t= \"ip6OutMcastPkts\",\n\t[IRDMA_HW_STAT_INDEX_TCPRXSEGS].name\t\t= \"tcpInSegs\",\n\t[IRDMA_HW_STAT_INDEX_TCPTXSEG].name\t\t= \"tcpOutSegs\",\n\t[IRDMA_HW_STAT_INDEX_RDMARXRDS].name\t\t= \"iwInRdmaReads\",\n\t[IRDMA_HW_STAT_INDEX_RDMARXSNDS].name\t\t= \"iwInRdmaSends\",\n\t[IRDMA_HW_STAT_INDEX_RDMARXWRS].name\t\t= \"iwInRdmaWrites\",\n\t[IRDMA_HW_STAT_INDEX_RDMATXRDS].name\t\t= \"iwOutRdmaReads\",\n\t[IRDMA_HW_STAT_INDEX_RDMATXSNDS].name\t\t= \"iwOutRdmaSends\",\n\t[IRDMA_HW_STAT_INDEX_RDMATXWRS].name\t\t= \"iwOutRdmaWrites\",\n\t[IRDMA_HW_STAT_INDEX_RDMAVBND].name\t\t= \"iwRdmaBnd\",\n\t[IRDMA_HW_STAT_INDEX_RDMAVINV].name\t\t= \"iwRdmaInv\",\n\n\t \n\t[IRDMA_HW_STAT_INDEX_RXRPCNPHANDLED].name\t= \"cnpHandled\",\n\t[IRDMA_HW_STAT_INDEX_RXRPCNPIGNORED].name\t= \"cnpIgnored\",\n\t[IRDMA_HW_STAT_INDEX_TXNPCNPSENT].name\t\t= \"cnpSent\",\n\t \n\t[IRDMA_HW_STAT_INDEX_IP4RXMCOCTS].name\t\t= \"ip4InMcastOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP4TXMCOCTS].name\t\t= \"ip4OutMcastOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP6RXMCOCTS].name\t\t= \"ip6InMcastOctets\",\n\t[IRDMA_HW_STAT_INDEX_IP6TXMCOCTS].name\t\t= \"ip6OutMcastOctets\",\n\t[IRDMA_HW_STAT_INDEX_UDPRXPKTS].name\t\t= \"RxUDP\",\n\t[IRDMA_HW_STAT_INDEX_UDPTXPKTS].name\t\t= \"TxUDP\",\n\t[IRDMA_HW_STAT_INDEX_RXNPECNMARKEDPKTS].name\t= \"RxECNMrkd\",\n\n};\n\nstatic void irdma_get_dev_fw_str(struct ib_device *dev, char *str)\n{\n\tstruct irdma_device *iwdev = to_iwdev(dev);\n\n\tsnprintf(str, IB_FW_VERSION_NAME_MAX, \"%u.%u\",\n\t\t irdma_fw_major_ver(&iwdev->rf->sc_dev),\n\t\t irdma_fw_minor_ver(&iwdev->rf->sc_dev));\n}\n\n \nstatic struct rdma_hw_stats *irdma_alloc_hw_port_stats(struct ib_device *ibdev,\n\t\t\t\t\t\t       u32 port_num)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_sc_dev *dev = &iwdev->rf->sc_dev;\n\n\tint num_counters = dev->hw_attrs.max_stat_idx;\n\tunsigned long lifespan = RDMA_HW_STATS_DEFAULT_LIFESPAN;\n\n\treturn rdma_alloc_hw_stats_struct(irdma_hw_stat_names, num_counters,\n\t\t\t\t\t  lifespan);\n}\n\n \nstatic int irdma_get_hw_stats(struct ib_device *ibdev,\n\t\t\t      struct rdma_hw_stats *stats, u32 port_num,\n\t\t\t      int index)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\tstruct irdma_dev_hw_stats *hw_stats = &iwdev->vsi.pestat->hw_stats;\n\n\tif (iwdev->rf->rdma_ver >= IRDMA_GEN_2)\n\t\tirdma_cqp_gather_stats_cmd(&iwdev->rf->sc_dev, iwdev->vsi.pestat, true);\n\telse\n\t\tirdma_cqp_gather_stats_gen1(&iwdev->rf->sc_dev, iwdev->vsi.pestat);\n\n\tmemcpy(&stats->value[0], hw_stats, sizeof(u64) * stats->num_counters);\n\n\treturn stats->num_counters;\n}\n\n \nstatic int irdma_query_gid(struct ib_device *ibdev, u32 port, int index,\n\t\t\t   union ib_gid *gid)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\n\tmemset(gid->raw, 0, sizeof(gid->raw));\n\tether_addr_copy(gid->raw, iwdev->netdev->dev_addr);\n\n\treturn 0;\n}\n\n \nstatic void mcast_list_add(struct irdma_pci_f *rf,\n\t\t\t   struct mc_table_list *new_elem)\n{\n\tlist_add(&new_elem->list, &rf->mc_qht_list.list);\n}\n\n \nstatic void mcast_list_del(struct mc_table_list *mc_qht_elem)\n{\n\tif (mc_qht_elem)\n\t\tlist_del(&mc_qht_elem->list);\n}\n\n \nstatic struct mc_table_list *mcast_list_lookup_ip(struct irdma_pci_f *rf,\n\t\t\t\t\t\t  u32 *ip_mcast)\n{\n\tstruct mc_table_list *mc_qht_el;\n\tstruct list_head *pos, *q;\n\n\tlist_for_each_safe (pos, q, &rf->mc_qht_list.list) {\n\t\tmc_qht_el = list_entry(pos, struct mc_table_list, list);\n\t\tif (!memcmp(mc_qht_el->mc_info.dest_ip, ip_mcast,\n\t\t\t    sizeof(mc_qht_el->mc_info.dest_ip)))\n\t\t\treturn mc_qht_el;\n\t}\n\n\treturn NULL;\n}\n\n \nstatic int irdma_mcast_cqp_op(struct irdma_device *iwdev,\n\t\t\t      struct irdma_mcast_grp_info *mc_grp_ctx, u8 op)\n{\n\tstruct cqp_cmds_info *cqp_info;\n\tstruct irdma_cqp_request *cqp_request;\n\tint status;\n\n\tcqp_request = irdma_alloc_and_get_cqp_request(&iwdev->rf->cqp, true);\n\tif (!cqp_request)\n\t\treturn -ENOMEM;\n\n\tcqp_request->info.in.u.mc_create.info = *mc_grp_ctx;\n\tcqp_info = &cqp_request->info;\n\tcqp_info->cqp_cmd = op;\n\tcqp_info->post_sq = 1;\n\tcqp_info->in.u.mc_create.scratch = (uintptr_t)cqp_request;\n\tcqp_info->in.u.mc_create.cqp = &iwdev->rf->cqp.sc_cqp;\n\tstatus = irdma_handle_cqp_op(iwdev->rf, cqp_request);\n\tirdma_put_cqp_request(&iwdev->rf->cqp, cqp_request);\n\n\treturn status;\n}\n\n \nvoid irdma_mcast_mac(u32 *ip_addr, u8 *mac, bool ipv4)\n{\n\tu8 *ip = (u8 *)ip_addr;\n\n\tif (ipv4) {\n\t\tunsigned char mac4[ETH_ALEN] = {0x01, 0x00, 0x5E, 0x00,\n\t\t\t\t\t\t0x00, 0x00};\n\n\t\tmac4[3] = ip[2] & 0x7F;\n\t\tmac4[4] = ip[1];\n\t\tmac4[5] = ip[0];\n\t\tether_addr_copy(mac, mac4);\n\t} else {\n\t\tunsigned char mac6[ETH_ALEN] = {0x33, 0x33, 0x00, 0x00,\n\t\t\t\t\t\t0x00, 0x00};\n\n\t\tmac6[2] = ip[3];\n\t\tmac6[3] = ip[2];\n\t\tmac6[4] = ip[1];\n\t\tmac6[5] = ip[0];\n\t\tether_addr_copy(mac, mac6);\n\t}\n}\n\n \nstatic int irdma_attach_mcast(struct ib_qp *ibqp, union ib_gid *ibgid, u16 lid)\n{\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct mc_table_list *mc_qht_elem;\n\tstruct irdma_mcast_grp_ctx_entry_info mcg_info = {};\n\tunsigned long flags;\n\tu32 ip_addr[4] = {};\n\tu32 mgn;\n\tu32 no_mgs;\n\tint ret = 0;\n\tbool ipv4;\n\tu16 vlan_id;\n\tunion irdma_sockaddr sgid_addr;\n\tunsigned char dmac[ETH_ALEN];\n\n\trdma_gid2ip((struct sockaddr *)&sgid_addr, ibgid);\n\n\tif (!ipv6_addr_v4mapped((struct in6_addr *)ibgid)) {\n\t\tirdma_copy_ip_ntohl(ip_addr,\n\t\t\t\t    sgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32);\n\t\tirdma_get_vlan_mac_ipv6(ip_addr, &vlan_id, NULL);\n\t\tipv4 = false;\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"VERBS: qp_id=%d, IP6address=%pI6\\n\", ibqp->qp_num,\n\t\t\t  ip_addr);\n\t\tirdma_mcast_mac(ip_addr, dmac, false);\n\t} else {\n\t\tip_addr[0] = ntohl(sgid_addr.saddr_in.sin_addr.s_addr);\n\t\tipv4 = true;\n\t\tvlan_id = irdma_get_vlan_ipv4(ip_addr);\n\t\tirdma_mcast_mac(ip_addr, dmac, true);\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"VERBS: qp_id=%d, IP4address=%pI4, MAC=%pM\\n\",\n\t\t\t  ibqp->qp_num, ip_addr, dmac);\n\t}\n\n\tspin_lock_irqsave(&rf->qh_list_lock, flags);\n\tmc_qht_elem = mcast_list_lookup_ip(rf, ip_addr);\n\tif (!mc_qht_elem) {\n\t\tstruct irdma_dma_mem *dma_mem_mc;\n\n\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\tmc_qht_elem = kzalloc(sizeof(*mc_qht_elem), GFP_KERNEL);\n\t\tif (!mc_qht_elem)\n\t\t\treturn -ENOMEM;\n\n\t\tmc_qht_elem->mc_info.ipv4_valid = ipv4;\n\t\tmemcpy(mc_qht_elem->mc_info.dest_ip, ip_addr,\n\t\t       sizeof(mc_qht_elem->mc_info.dest_ip));\n\t\tret = irdma_alloc_rsrc(rf, rf->allocated_mcgs, rf->max_mcg,\n\t\t\t\t       &mgn, &rf->next_mcg);\n\t\tif (ret) {\n\t\t\tkfree(mc_qht_elem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmc_qht_elem->mc_info.mgn = mgn;\n\t\tdma_mem_mc = &mc_qht_elem->mc_grp_ctx.dma_mem_mc;\n\t\tdma_mem_mc->size = ALIGN(sizeof(u64) * IRDMA_MAX_MGS_PER_CTX,\n\t\t\t\t\t IRDMA_HW_PAGE_SIZE);\n\t\tdma_mem_mc->va = dma_alloc_coherent(rf->hw.device,\n\t\t\t\t\t\t    dma_mem_mc->size,\n\t\t\t\t\t\t    &dma_mem_mc->pa,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!dma_mem_mc->va) {\n\t\t\tirdma_free_rsrc(rf, rf->allocated_mcgs, mgn);\n\t\t\tkfree(mc_qht_elem);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmc_qht_elem->mc_grp_ctx.mg_id = (u16)mgn;\n\t\tmemcpy(mc_qht_elem->mc_grp_ctx.dest_ip_addr, ip_addr,\n\t\t       sizeof(mc_qht_elem->mc_grp_ctx.dest_ip_addr));\n\t\tmc_qht_elem->mc_grp_ctx.ipv4_valid = ipv4;\n\t\tmc_qht_elem->mc_grp_ctx.vlan_id = vlan_id;\n\t\tif (vlan_id < VLAN_N_VID)\n\t\t\tmc_qht_elem->mc_grp_ctx.vlan_valid = true;\n\t\tmc_qht_elem->mc_grp_ctx.hmc_fcn_id = iwdev->rf->sc_dev.hmc_fn_id;\n\t\tmc_qht_elem->mc_grp_ctx.qs_handle =\n\t\t\tiwqp->sc_qp.vsi->qos[iwqp->sc_qp.user_pri].qs_handle;\n\t\tether_addr_copy(mc_qht_elem->mc_grp_ctx.dest_mac_addr, dmac);\n\n\t\tspin_lock_irqsave(&rf->qh_list_lock, flags);\n\t\tmcast_list_add(rf, mc_qht_elem);\n\t} else {\n\t\tif (mc_qht_elem->mc_grp_ctx.no_of_mgs ==\n\t\t    IRDMA_MAX_MGS_PER_CTX) {\n\t\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmcg_info.qp_id = iwqp->ibqp.qp_num;\n\tno_mgs = mc_qht_elem->mc_grp_ctx.no_of_mgs;\n\tirdma_sc_add_mcast_grp(&mc_qht_elem->mc_grp_ctx, &mcg_info);\n\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\n\t \n\tif (!no_mgs) {\n\t\tret = irdma_mcast_cqp_op(iwdev, &mc_qht_elem->mc_grp_ctx,\n\t\t\t\t\t IRDMA_OP_MC_CREATE);\n\t} else if (no_mgs != mc_qht_elem->mc_grp_ctx.no_of_mgs) {\n\t\tret = irdma_mcast_cqp_op(iwdev, &mc_qht_elem->mc_grp_ctx,\n\t\t\t\t\t IRDMA_OP_MC_MODIFY);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (ret)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tirdma_sc_del_mcast_grp(&mc_qht_elem->mc_grp_ctx, &mcg_info);\n\tif (!mc_qht_elem->mc_grp_ctx.no_of_mgs) {\n\t\tmcast_list_del(mc_qht_elem);\n\t\tdma_free_coherent(rf->hw.device,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.size,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.va,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.pa);\n\t\tmc_qht_elem->mc_grp_ctx.dma_mem_mc.va = NULL;\n\t\tirdma_free_rsrc(rf, rf->allocated_mcgs,\n\t\t\t\tmc_qht_elem->mc_grp_ctx.mg_id);\n\t\tkfree(mc_qht_elem);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int irdma_detach_mcast(struct ib_qp *ibqp, union ib_gid *ibgid, u16 lid)\n{\n\tstruct irdma_qp *iwqp = to_iwqp(ibqp);\n\tstruct irdma_device *iwdev = iwqp->iwdev;\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tu32 ip_addr[4] = {};\n\tstruct mc_table_list *mc_qht_elem;\n\tstruct irdma_mcast_grp_ctx_entry_info mcg_info = {};\n\tint ret;\n\tunsigned long flags;\n\tunion irdma_sockaddr sgid_addr;\n\n\trdma_gid2ip((struct sockaddr *)&sgid_addr, ibgid);\n\tif (!ipv6_addr_v4mapped((struct in6_addr *)ibgid))\n\t\tirdma_copy_ip_ntohl(ip_addr,\n\t\t\t\t    sgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32);\n\telse\n\t\tip_addr[0] = ntohl(sgid_addr.saddr_in.sin_addr.s_addr);\n\n\tspin_lock_irqsave(&rf->qh_list_lock, flags);\n\tmc_qht_elem = mcast_list_lookup_ip(rf, ip_addr);\n\tif (!mc_qht_elem) {\n\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t  \"VERBS: address not found MCG\\n\");\n\t\treturn 0;\n\t}\n\n\tmcg_info.qp_id = iwqp->ibqp.qp_num;\n\tirdma_sc_del_mcast_grp(&mc_qht_elem->mc_grp_ctx, &mcg_info);\n\tif (!mc_qht_elem->mc_grp_ctx.no_of_mgs) {\n\t\tmcast_list_del(mc_qht_elem);\n\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\tret = irdma_mcast_cqp_op(iwdev, &mc_qht_elem->mc_grp_ctx,\n\t\t\t\t\t IRDMA_OP_MC_DESTROY);\n\t\tif (ret) {\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"VERBS: failed MC_DESTROY MCG\\n\");\n\t\t\tspin_lock_irqsave(&rf->qh_list_lock, flags);\n\t\t\tmcast_list_add(rf, mc_qht_elem);\n\t\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tdma_free_coherent(rf->hw.device,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.size,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.va,\n\t\t\t\t  mc_qht_elem->mc_grp_ctx.dma_mem_mc.pa);\n\t\tmc_qht_elem->mc_grp_ctx.dma_mem_mc.va = NULL;\n\t\tirdma_free_rsrc(rf, rf->allocated_mcgs,\n\t\t\t\tmc_qht_elem->mc_grp_ctx.mg_id);\n\t\tkfree(mc_qht_elem);\n\t} else {\n\t\tspin_unlock_irqrestore(&rf->qh_list_lock, flags);\n\t\tret = irdma_mcast_cqp_op(iwdev, &mc_qht_elem->mc_grp_ctx,\n\t\t\t\t\t IRDMA_OP_MC_MODIFY);\n\t\tif (ret) {\n\t\t\tibdev_dbg(&iwdev->ibdev,\n\t\t\t\t  \"VERBS: failed Modify MCG\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int irdma_create_hw_ah(struct irdma_device *iwdev, struct irdma_ah *ah, bool sleep)\n{\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tint err;\n\n\terr = irdma_alloc_rsrc(rf, rf->allocated_ahs, rf->max_ah, &ah->sc_ah.ah_info.ah_idx,\n\t\t\t       &rf->next_ah);\n\tif (err)\n\t\treturn err;\n\n\terr = irdma_ah_cqp_op(rf, &ah->sc_ah, IRDMA_OP_AH_CREATE, sleep,\n\t\t\t      irdma_gsi_ud_qp_ah_cb, &ah->sc_ah);\n\n\tif (err) {\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: CQP-OP Create AH fail\");\n\t\tgoto err_ah_create;\n\t}\n\n\tif (!sleep) {\n\t\tint cnt = CQP_COMPL_WAIT_TIME_MS * CQP_TIMEOUT_THRESHOLD;\n\n\t\tdo {\n\t\t\tirdma_cqp_ce_handler(rf, &rf->ccq.sc_cq);\n\t\t\tmdelay(1);\n\t\t} while (!ah->sc_ah.ah_info.ah_valid && --cnt);\n\n\t\tif (!cnt) {\n\t\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: CQP create AH timed out\");\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto err_ah_create;\n\t\t}\n\t}\n\treturn 0;\n\nerr_ah_create:\n\tirdma_free_rsrc(iwdev->rf, iwdev->rf->allocated_ahs, ah->sc_ah.ah_info.ah_idx);\n\n\treturn err;\n}\n\nstatic int irdma_setup_ah(struct ib_ah *ibah, struct rdma_ah_init_attr *attr)\n{\n\tstruct irdma_pd *pd = to_iwpd(ibah->pd);\n\tstruct irdma_ah *ah = container_of(ibah, struct irdma_ah, ibah);\n\tstruct rdma_ah_attr *ah_attr = attr->ah_attr;\n\tconst struct ib_gid_attr *sgid_attr;\n\tstruct irdma_device *iwdev = to_iwdev(ibah->pd->device);\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\tstruct irdma_sc_ah *sc_ah;\n\tstruct irdma_ah_info *ah_info;\n\tunion irdma_sockaddr sgid_addr, dgid_addr;\n\tint err;\n\tu8 dmac[ETH_ALEN];\n\n\tah->pd = pd;\n\tsc_ah = &ah->sc_ah;\n\tsc_ah->ah_info.vsi = &iwdev->vsi;\n\tirdma_sc_init_ah(&rf->sc_dev, sc_ah);\n\tah->sgid_index = ah_attr->grh.sgid_index;\n\tsgid_attr = ah_attr->grh.sgid_attr;\n\tmemcpy(&ah->dgid, &ah_attr->grh.dgid, sizeof(ah->dgid));\n\trdma_gid2ip((struct sockaddr *)&sgid_addr, &sgid_attr->gid);\n\trdma_gid2ip((struct sockaddr *)&dgid_addr, &ah_attr->grh.dgid);\n\tah->av.attrs = *ah_attr;\n\tah->av.net_type = rdma_gid_attr_network_type(sgid_attr);\n\tah_info = &sc_ah->ah_info;\n\tah_info->pd_idx = pd->sc_pd.pd_id;\n\tif (ah_attr->ah_flags & IB_AH_GRH) {\n\t\tah_info->flow_label = ah_attr->grh.flow_label;\n\t\tah_info->hop_ttl = ah_attr->grh.hop_limit;\n\t\tah_info->tc_tos = ah_attr->grh.traffic_class;\n\t}\n\n\tether_addr_copy(dmac, ah_attr->roce.dmac);\n\tif (ah->av.net_type == RDMA_NETWORK_IPV4) {\n\t\tah_info->ipv4_valid = true;\n\t\tah_info->dest_ip_addr[0] =\n\t\t\tntohl(dgid_addr.saddr_in.sin_addr.s_addr);\n\t\tah_info->src_ip_addr[0] =\n\t\t\tntohl(sgid_addr.saddr_in.sin_addr.s_addr);\n\t\tah_info->do_lpbk = irdma_ipv4_is_lpb(ah_info->src_ip_addr[0],\n\t\t\t\t\t\t     ah_info->dest_ip_addr[0]);\n\t\tif (ipv4_is_multicast(dgid_addr.saddr_in.sin_addr.s_addr)) {\n\t\t\tah_info->do_lpbk = true;\n\t\t\tirdma_mcast_mac(ah_info->dest_ip_addr, dmac, true);\n\t\t}\n\t} else {\n\t\tirdma_copy_ip_ntohl(ah_info->dest_ip_addr,\n\t\t\t\t    dgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32);\n\t\tirdma_copy_ip_ntohl(ah_info->src_ip_addr,\n\t\t\t\t    sgid_addr.saddr_in6.sin6_addr.in6_u.u6_addr32);\n\t\tah_info->do_lpbk = irdma_ipv6_is_lpb(ah_info->src_ip_addr,\n\t\t\t\t\t\t     ah_info->dest_ip_addr);\n\t\tif (rdma_is_multicast_addr(&dgid_addr.saddr_in6.sin6_addr)) {\n\t\t\tah_info->do_lpbk = true;\n\t\t\tirdma_mcast_mac(ah_info->dest_ip_addr, dmac, false);\n\t\t}\n\t}\n\n\terr = rdma_read_gid_l2_fields(sgid_attr, &ah_info->vlan_tag,\n\t\t\t\t      ah_info->mac_addr);\n\tif (err)\n\t\treturn err;\n\n\tah_info->dst_arpindex = irdma_add_arp(iwdev->rf, ah_info->dest_ip_addr,\n\t\t\t\t\t      ah_info->ipv4_valid, dmac);\n\n\tif (ah_info->dst_arpindex == -1)\n\t\treturn -EINVAL;\n\n\tif (ah_info->vlan_tag >= VLAN_N_VID && iwdev->dcb_vlan_mode)\n\t\tah_info->vlan_tag = 0;\n\n\tif (ah_info->vlan_tag < VLAN_N_VID) {\n\t\tu8 prio = rt_tos2priority(ah_info->tc_tos);\n\n\t\tprio = irdma_roce_get_vlan_prio(sgid_attr, prio);\n\n\t\tah_info->vlan_tag |= (u16)prio << VLAN_PRIO_SHIFT;\n\t\tah_info->insert_vlan_tag = true;\n\t}\n\n\treturn 0;\n}\n\n \nstatic bool irdma_ah_exists(struct irdma_device *iwdev,\n\t\t\t    struct irdma_ah *new_ah)\n{\n\tstruct irdma_ah *ah;\n\tu32 key = new_ah->sc_ah.ah_info.dest_ip_addr[0] ^\n\t\t  new_ah->sc_ah.ah_info.dest_ip_addr[1] ^\n\t\t  new_ah->sc_ah.ah_info.dest_ip_addr[2] ^\n\t\t  new_ah->sc_ah.ah_info.dest_ip_addr[3];\n\n\thash_for_each_possible(iwdev->ah_hash_tbl, ah, list, key) {\n\t\t \n\t\tnew_ah->sc_ah.ah_info.ah_idx = ah->sc_ah.ah_info.ah_idx;\n\t\tnew_ah->sc_ah.ah_info.ah_valid = ah->sc_ah.ah_info.ah_valid;\n\t\tif (!memcmp(&ah->sc_ah.ah_info, &new_ah->sc_ah.ah_info,\n\t\t\t    sizeof(ah->sc_ah.ah_info))) {\n\t\t\trefcount_inc(&ah->refcnt);\n\t\t\tnew_ah->parent_ah = ah;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n \nstatic int irdma_destroy_ah(struct ib_ah *ibah, u32 ah_flags)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibah->device);\n\tstruct irdma_ah *ah = to_iwah(ibah);\n\n\tif ((ah_flags & RDMA_DESTROY_AH_SLEEPABLE) && ah->parent_ah) {\n\t\tmutex_lock(&iwdev->ah_tbl_lock);\n\t\tif (!refcount_dec_and_test(&ah->parent_ah->refcnt)) {\n\t\t\tmutex_unlock(&iwdev->ah_tbl_lock);\n\t\t\treturn 0;\n\t\t}\n\t\thash_del(&ah->parent_ah->list);\n\t\tkfree(ah->parent_ah);\n\t\tmutex_unlock(&iwdev->ah_tbl_lock);\n\t}\n\n\tirdma_ah_cqp_op(iwdev->rf, &ah->sc_ah, IRDMA_OP_AH_DESTROY,\n\t\t\tfalse, NULL, ah);\n\n\tirdma_free_rsrc(iwdev->rf, iwdev->rf->allocated_ahs,\n\t\t\tah->sc_ah.ah_info.ah_idx);\n\n\treturn 0;\n}\n\n \nstatic int irdma_create_user_ah(struct ib_ah *ibah,\n\t\t\t\tstruct rdma_ah_init_attr *attr,\n\t\t\t\tstruct ib_udata *udata)\n{\n#define IRDMA_CREATE_AH_MIN_RESP_LEN offsetofend(struct irdma_create_ah_resp, rsvd)\n\tstruct irdma_ah *ah = container_of(ibah, struct irdma_ah, ibah);\n\tstruct irdma_device *iwdev = to_iwdev(ibah->pd->device);\n\tstruct irdma_create_ah_resp uresp;\n\tstruct irdma_ah *parent_ah;\n\tint err;\n\n\tif (udata && udata->outlen < IRDMA_CREATE_AH_MIN_RESP_LEN)\n\t\treturn -EINVAL;\n\n\terr = irdma_setup_ah(ibah, attr);\n\tif (err)\n\t\treturn err;\n\tmutex_lock(&iwdev->ah_tbl_lock);\n\tif (!irdma_ah_exists(iwdev, ah)) {\n\t\terr = irdma_create_hw_ah(iwdev, ah, true);\n\t\tif (err) {\n\t\t\tmutex_unlock(&iwdev->ah_tbl_lock);\n\t\t\treturn err;\n\t\t}\n\t\t \n\t\tparent_ah = kmemdup(ah, sizeof(*ah), GFP_KERNEL);\n\t\tif (parent_ah) {\n\t\t\tu32 key = parent_ah->sc_ah.ah_info.dest_ip_addr[0] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[1] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[2] ^\n\t\t\t\t  parent_ah->sc_ah.ah_info.dest_ip_addr[3];\n\n\t\t\tah->parent_ah = parent_ah;\n\t\t\thash_add(iwdev->ah_hash_tbl, &parent_ah->list, key);\n\t\t\trefcount_set(&parent_ah->refcnt, 1);\n\t\t}\n\t}\n\tmutex_unlock(&iwdev->ah_tbl_lock);\n\n\turesp.ah_id = ah->sc_ah.ah_info.ah_idx;\n\terr = ib_copy_to_udata(udata, &uresp, min(sizeof(uresp), udata->outlen));\n\tif (err)\n\t\tirdma_destroy_ah(ibah, attr->flags);\n\n\treturn err;\n}\n\n \nstatic int irdma_create_ah(struct ib_ah *ibah, struct rdma_ah_init_attr *attr,\n\t\t\t   struct ib_udata *udata)\n{\n\tstruct irdma_ah *ah = container_of(ibah, struct irdma_ah, ibah);\n\tstruct irdma_device *iwdev = to_iwdev(ibah->pd->device);\n\tint err;\n\n\terr = irdma_setup_ah(ibah, attr);\n\tif (err)\n\t\treturn err;\n\terr = irdma_create_hw_ah(iwdev, ah, attr->flags & RDMA_CREATE_AH_SLEEPABLE);\n\n\treturn err;\n}\n\n \nstatic int irdma_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *ah_attr)\n{\n\tstruct irdma_ah *ah = to_iwah(ibah);\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\tif (ah->av.attrs.ah_flags & IB_AH_GRH) {\n\t\tah_attr->ah_flags = IB_AH_GRH;\n\t\tah_attr->grh.flow_label = ah->sc_ah.ah_info.flow_label;\n\t\tah_attr->grh.traffic_class = ah->sc_ah.ah_info.tc_tos;\n\t\tah_attr->grh.hop_limit = ah->sc_ah.ah_info.hop_ttl;\n\t\tah_attr->grh.sgid_index = ah->sgid_index;\n\t\tmemcpy(&ah_attr->grh.dgid, &ah->dgid,\n\t\t       sizeof(ah_attr->grh.dgid));\n\t}\n\n\treturn 0;\n}\n\nstatic enum rdma_link_layer irdma_get_link_layer(struct ib_device *ibdev,\n\t\t\t\t\t\t u32 port_num)\n{\n\treturn IB_LINK_LAYER_ETHERNET;\n}\n\nstatic const struct ib_device_ops irdma_roce_dev_ops = {\n\t.attach_mcast = irdma_attach_mcast,\n\t.create_ah = irdma_create_ah,\n\t.create_user_ah = irdma_create_user_ah,\n\t.destroy_ah = irdma_destroy_ah,\n\t.detach_mcast = irdma_detach_mcast,\n\t.get_link_layer = irdma_get_link_layer,\n\t.get_port_immutable = irdma_roce_port_immutable,\n\t.modify_qp = irdma_modify_qp_roce,\n\t.query_ah = irdma_query_ah,\n\t.query_pkey = irdma_query_pkey,\n};\n\nstatic const struct ib_device_ops irdma_iw_dev_ops = {\n\t.get_port_immutable = irdma_iw_port_immutable,\n\t.iw_accept = irdma_accept,\n\t.iw_add_ref = irdma_qp_add_ref,\n\t.iw_connect = irdma_connect,\n\t.iw_create_listen = irdma_create_listen,\n\t.iw_destroy_listen = irdma_destroy_listen,\n\t.iw_get_qp = irdma_get_qp,\n\t.iw_reject = irdma_reject,\n\t.iw_rem_ref = irdma_qp_rem_ref,\n\t.modify_qp = irdma_modify_qp,\n\t.query_gid = irdma_query_gid,\n};\n\nstatic const struct ib_device_ops irdma_dev_ops = {\n\t.owner = THIS_MODULE,\n\t.driver_id = RDMA_DRIVER_IRDMA,\n\t.uverbs_abi_ver = IRDMA_ABI_VER,\n\n\t.alloc_hw_port_stats = irdma_alloc_hw_port_stats,\n\t.alloc_mr = irdma_alloc_mr,\n\t.alloc_mw = irdma_alloc_mw,\n\t.alloc_pd = irdma_alloc_pd,\n\t.alloc_ucontext = irdma_alloc_ucontext,\n\t.create_cq = irdma_create_cq,\n\t.create_qp = irdma_create_qp,\n\t.dealloc_driver = irdma_ib_dealloc_device,\n\t.dealloc_mw = irdma_dealloc_mw,\n\t.dealloc_pd = irdma_dealloc_pd,\n\t.dealloc_ucontext = irdma_dealloc_ucontext,\n\t.dereg_mr = irdma_dereg_mr,\n\t.destroy_cq = irdma_destroy_cq,\n\t.destroy_qp = irdma_destroy_qp,\n\t.disassociate_ucontext = irdma_disassociate_ucontext,\n\t.get_dev_fw_str = irdma_get_dev_fw_str,\n\t.get_dma_mr = irdma_get_dma_mr,\n\t.get_hw_stats = irdma_get_hw_stats,\n\t.map_mr_sg = irdma_map_mr_sg,\n\t.mmap = irdma_mmap,\n\t.mmap_free = irdma_mmap_free,\n\t.poll_cq = irdma_poll_cq,\n\t.post_recv = irdma_post_recv,\n\t.post_send = irdma_post_send,\n\t.query_device = irdma_query_device,\n\t.query_port = irdma_query_port,\n\t.query_qp = irdma_query_qp,\n\t.reg_user_mr = irdma_reg_user_mr,\n\t.reg_user_mr_dmabuf = irdma_reg_user_mr_dmabuf,\n\t.req_notify_cq = irdma_req_notify_cq,\n\t.resize_cq = irdma_resize_cq,\n\tINIT_RDMA_OBJ_SIZE(ib_pd, irdma_pd, ibpd),\n\tINIT_RDMA_OBJ_SIZE(ib_ucontext, irdma_ucontext, ibucontext),\n\tINIT_RDMA_OBJ_SIZE(ib_ah, irdma_ah, ibah),\n\tINIT_RDMA_OBJ_SIZE(ib_cq, irdma_cq, ibcq),\n\tINIT_RDMA_OBJ_SIZE(ib_mw, irdma_mr, ibmw),\n\tINIT_RDMA_OBJ_SIZE(ib_qp, irdma_qp, ibqp),\n};\n\n \nstatic void irdma_init_roce_device(struct irdma_device *iwdev)\n{\n\tiwdev->ibdev.node_type = RDMA_NODE_IB_CA;\n\taddrconf_addr_eui48((u8 *)&iwdev->ibdev.node_guid,\n\t\t\t    iwdev->netdev->dev_addr);\n\tib_set_device_ops(&iwdev->ibdev, &irdma_roce_dev_ops);\n}\n\n \nstatic void irdma_init_iw_device(struct irdma_device *iwdev)\n{\n\tstruct net_device *netdev = iwdev->netdev;\n\n\tiwdev->ibdev.node_type = RDMA_NODE_RNIC;\n\taddrconf_addr_eui48((u8 *)&iwdev->ibdev.node_guid,\n\t\t\t    netdev->dev_addr);\n\tmemcpy(iwdev->ibdev.iw_ifname, netdev->name,\n\t       sizeof(iwdev->ibdev.iw_ifname));\n\tib_set_device_ops(&iwdev->ibdev, &irdma_iw_dev_ops);\n}\n\n \nstatic void irdma_init_rdma_device(struct irdma_device *iwdev)\n{\n\tstruct pci_dev *pcidev = iwdev->rf->pcidev;\n\n\tif (iwdev->roce_mode)\n\t\tirdma_init_roce_device(iwdev);\n\telse\n\t\tirdma_init_iw_device(iwdev);\n\n\tiwdev->ibdev.phys_port_cnt = 1;\n\tiwdev->ibdev.num_comp_vectors = iwdev->rf->ceqs_count;\n\tiwdev->ibdev.dev.parent = &pcidev->dev;\n\tib_set_device_ops(&iwdev->ibdev, &irdma_dev_ops);\n}\n\n \nvoid irdma_port_ibevent(struct irdma_device *iwdev)\n{\n\tstruct ib_event event;\n\n\tevent.device = &iwdev->ibdev;\n\tevent.element.port_num = 1;\n\tevent.event =\n\t\tiwdev->iw_status ? IB_EVENT_PORT_ACTIVE : IB_EVENT_PORT_ERR;\n\tib_dispatch_event(&event);\n}\n\n \nvoid irdma_ib_unregister_device(struct irdma_device *iwdev)\n{\n\tiwdev->iw_status = 0;\n\tirdma_port_ibevent(iwdev);\n\tib_unregister_device(&iwdev->ibdev);\n}\n\n \nint irdma_ib_register_device(struct irdma_device *iwdev)\n{\n\tint ret;\n\n\tirdma_init_rdma_device(iwdev);\n\n\tret = ib_device_set_netdev(&iwdev->ibdev, iwdev->netdev, 1);\n\tif (ret)\n\t\tgoto error;\n\tdma_set_max_seg_size(iwdev->rf->hw.device, UINT_MAX);\n\tret = ib_register_device(&iwdev->ibdev, \"irdma%d\", iwdev->rf->hw.device);\n\tif (ret)\n\t\tgoto error;\n\n\tiwdev->iw_status = 1;\n\tirdma_port_ibevent(iwdev);\n\n\treturn 0;\n\nerror:\n\tif (ret)\n\t\tibdev_dbg(&iwdev->ibdev, \"VERBS: Register RDMA device fail\\n\");\n\n\treturn ret;\n}\n\n \nvoid irdma_ib_dealloc_device(struct ib_device *ibdev)\n{\n\tstruct irdma_device *iwdev = to_iwdev(ibdev);\n\n\tirdma_rt_deinit_hw(iwdev);\n\tirdma_ctrl_deinit_hw(iwdev->rf);\n\tkfree(iwdev->rf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}