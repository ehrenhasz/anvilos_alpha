{
  "module_name": "i40iw_if.c",
  "hash_id": "378b408b2113c1afd0dfab33957799a0d72dd60a85c6725a50fac8d6b48094c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/irdma/i40iw_if.c",
  "human_readable_source": "\n \n#include \"main.h\"\n#include \"i40iw_hw.h\"\n#include <linux/net/intel/i40e_client.h>\n\nstatic struct i40e_client i40iw_client;\n\n \nstatic void i40iw_l2param_change(struct i40e_info *cdev_info,\n\t\t\t\t struct i40e_client *client,\n\t\t\t\t struct i40e_params *params)\n{\n\tstruct irdma_l2params l2params = {};\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\n\tibdev = ib_device_get_by_netdev(cdev_info->netdev, RDMA_DRIVER_IRDMA);\n\tif (!ibdev)\n\t\treturn;\n\n\tiwdev = to_iwdev(ibdev);\n\n\tif (iwdev->vsi.mtu != params->mtu) {\n\t\tl2params.mtu_changed = true;\n\t\tl2params.mtu = params->mtu;\n\t}\n\tirdma_change_l2params(&iwdev->vsi, &l2params);\n\tib_device_put(ibdev);\n}\n\n \nstatic void i40iw_close(struct i40e_info *cdev_info, struct i40e_client *client,\n\t\t\tbool reset)\n{\n\tstruct irdma_device *iwdev;\n\tstruct ib_device *ibdev;\n\n\tibdev = ib_device_get_by_netdev(cdev_info->netdev, RDMA_DRIVER_IRDMA);\n\tif (WARN_ON(!ibdev))\n\t\treturn;\n\n\tiwdev = to_iwdev(ibdev);\n\tif (reset)\n\t\tiwdev->rf->reset = true;\n\n\tiwdev->iw_status = 0;\n\tirdma_port_ibevent(iwdev);\n\tib_unregister_device_and_put(ibdev);\n\tpr_debug(\"INIT: Gen1 PF[%d] close complete\\n\", PCI_FUNC(cdev_info->pcidev->devfn));\n}\n\nstatic void i40iw_request_reset(struct irdma_pci_f *rf)\n{\n\tstruct i40e_info *cdev_info = rf->cdev;\n\n\tcdev_info->ops->request_reset(cdev_info, &i40iw_client, 1);\n}\n\nstatic void i40iw_fill_device_info(struct irdma_device *iwdev, struct i40e_info *cdev_info)\n{\n\tstruct irdma_pci_f *rf = iwdev->rf;\n\n\trf->rdma_ver = IRDMA_GEN_1;\n\trf->gen_ops.request_reset = i40iw_request_reset;\n\trf->pcidev = cdev_info->pcidev;\n\trf->pf_id = cdev_info->fid;\n\trf->hw.hw_addr = cdev_info->hw_addr;\n\trf->cdev = cdev_info;\n\trf->msix_count = cdev_info->msix_count;\n\trf->msix_entries = cdev_info->msix_entries;\n\trf->limits_sel = 5;\n\trf->protocol_used = IRDMA_IWARP_PROTOCOL_ONLY;\n\trf->iwdev = iwdev;\n\n\tiwdev->init_state = INITIAL_STATE;\n\tiwdev->rcv_wnd = IRDMA_CM_DEFAULT_RCV_WND_SCALED;\n\tiwdev->rcv_wscale = IRDMA_CM_DEFAULT_RCV_WND_SCALE;\n\tiwdev->netdev = cdev_info->netdev;\n\tiwdev->vsi_num = 0;\n}\n\n \nstatic int i40iw_open(struct i40e_info *cdev_info, struct i40e_client *client)\n{\n\tstruct irdma_l2params l2params = {};\n\tstruct irdma_device *iwdev;\n\tstruct irdma_pci_f *rf;\n\tint err = -EIO;\n\tint i;\n\tu16 qset;\n\tu16 last_qset = IRDMA_NO_QSET;\n\n\tiwdev = ib_alloc_device(irdma_device, ibdev);\n\tif (!iwdev)\n\t\treturn -ENOMEM;\n\n\tiwdev->rf = kzalloc(sizeof(*rf), GFP_KERNEL);\n\tif (!iwdev->rf) {\n\t\tib_dealloc_device(&iwdev->ibdev);\n\t\treturn -ENOMEM;\n\t}\n\n\ti40iw_fill_device_info(iwdev, cdev_info);\n\trf = iwdev->rf;\n\n\tif (irdma_ctrl_init_hw(rf)) {\n\t\terr = -EIO;\n\t\tgoto err_ctrl_init;\n\t}\n\n\tl2params.mtu = (cdev_info->params.mtu) ? cdev_info->params.mtu : IRDMA_DEFAULT_MTU;\n\tfor (i = 0; i < I40E_CLIENT_MAX_USER_PRIORITY; i++) {\n\t\tqset = cdev_info->params.qos.prio_qos[i].qs_handle;\n\t\tl2params.up2tc[i] = cdev_info->params.qos.prio_qos[i].tc;\n\t\tl2params.qs_handle_list[i] = qset;\n\t\tif (last_qset == IRDMA_NO_QSET)\n\t\t\tlast_qset = qset;\n\t\telse if ((qset != last_qset) && (qset != IRDMA_NO_QSET))\n\t\t\tiwdev->dcb_vlan_mode = true;\n\t}\n\n\tif (irdma_rt_init_hw(iwdev, &l2params)) {\n\t\terr = -EIO;\n\t\tgoto err_rt_init;\n\t}\n\n\terr = irdma_ib_register_device(iwdev);\n\tif (err)\n\t\tgoto err_ibreg;\n\n\tibdev_dbg(&iwdev->ibdev, \"INIT: Gen1 PF[%d] open success\\n\",\n\t\t  PCI_FUNC(rf->pcidev->devfn));\n\n\treturn 0;\n\nerr_ibreg:\n\tirdma_rt_deinit_hw(iwdev);\nerr_rt_init:\n\tirdma_ctrl_deinit_hw(rf);\nerr_ctrl_init:\n\tkfree(iwdev->rf);\n\tib_dealloc_device(&iwdev->ibdev);\n\n\treturn err;\n}\n\n \nstatic const struct i40e_client_ops i40e_ops = {\n\t.open = i40iw_open,\n\t.close = i40iw_close,\n\t.l2_param_change = i40iw_l2param_change\n};\n\nstatic struct i40e_client i40iw_client = {\n\t.ops = &i40e_ops,\n\t.type = I40E_CLIENT_IWARP,\n};\n\nstatic int i40iw_probe(struct auxiliary_device *aux_dev, const struct auxiliary_device_id *id)\n{\n\tstruct i40e_auxiliary_device *i40e_adev = container_of(aux_dev,\n\t\t\t\t\t\t\t       struct i40e_auxiliary_device,\n\t\t\t\t\t\t\t       aux_dev);\n\tstruct i40e_info *cdev_info = i40e_adev->ldev;\n\n\tstrncpy(i40iw_client.name, \"irdma\", I40E_CLIENT_STR_LENGTH);\n\ti40e_client_device_register(cdev_info, &i40iw_client);\n\n\treturn 0;\n}\n\nstatic void i40iw_remove(struct auxiliary_device *aux_dev)\n{\n\tstruct i40e_auxiliary_device *i40e_adev = container_of(aux_dev,\n\t\t\t\t\t\t\t       struct i40e_auxiliary_device,\n\t\t\t\t\t\t\t       aux_dev);\n\tstruct i40e_info *cdev_info = i40e_adev->ldev;\n\n\ti40e_client_device_unregister(cdev_info);\n}\n\nstatic const struct auxiliary_device_id i40iw_auxiliary_id_table[] = {\n\t{.name = \"i40e.iwarp\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(auxiliary, i40iw_auxiliary_id_table);\n\nstruct auxiliary_driver i40iw_auxiliary_drv = {\n\t.name = \"gen_1\",\n\t.id_table = i40iw_auxiliary_id_table,\n\t.probe = i40iw_probe,\n\t.remove = i40iw_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}