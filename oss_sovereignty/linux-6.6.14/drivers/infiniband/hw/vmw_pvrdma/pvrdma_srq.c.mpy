{
  "module_name": "pvrdma_srq.c",
  "hash_id": "bed53b86d06298561a5b56a6ed90f3d94a2f4e46a6189be1ff7994236b0c29ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/vmw_pvrdma/pvrdma_srq.c",
  "human_readable_source": " \n\n#include <asm/page.h>\n#include <linux/io.h>\n#include <linux/wait.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_smi.h>\n#include <rdma/ib_user_verbs.h>\n\n#include \"pvrdma.h\"\n\n \nint pvrdma_query_srq(struct ib_srq *ibsrq, struct ib_srq_attr *srq_attr)\n{\n\tstruct pvrdma_dev *dev = to_vdev(ibsrq->device);\n\tstruct pvrdma_srq *srq = to_vsrq(ibsrq);\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_query_srq *cmd = &req.query_srq;\n\tstruct pvrdma_cmd_query_srq_resp *resp = &rsp.query_srq_resp;\n\tint ret;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_QUERY_SRQ;\n\tcmd->srq_handle = srq->srq_handle;\n\n\tret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_QUERY_SRQ_RESP);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not query shared receive queue, error: %d\\n\",\n\t\t\t ret);\n\t\treturn -EINVAL;\n\t}\n\n\tsrq_attr->srq_limit = resp->attrs.srq_limit;\n\tsrq_attr->max_wr = resp->attrs.max_wr;\n\tsrq_attr->max_sge = resp->attrs.max_sge;\n\n\treturn 0;\n}\n\n \nint pvrdma_create_srq(struct ib_srq *ibsrq, struct ib_srq_init_attr *init_attr,\n\t\t      struct ib_udata *udata)\n{\n\tstruct pvrdma_srq *srq = to_vsrq(ibsrq);\n\tstruct pvrdma_dev *dev = to_vdev(ibsrq->device);\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_create_srq *cmd = &req.create_srq;\n\tstruct pvrdma_cmd_create_srq_resp *resp = &rsp.create_srq_resp;\n\tstruct pvrdma_create_srq_resp srq_resp = {};\n\tstruct pvrdma_create_srq ucmd;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!udata) {\n\t\t \n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"no shared receive queue support for kernel client\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (init_attr->srq_type != IB_SRQT_BASIC) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"shared receive queue type %d not supported\\n\",\n\t\t\t init_attr->srq_type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (init_attr->attr.max_wr  > dev->dsr->caps.max_srq_wr ||\n\t    init_attr->attr.max_sge > dev->dsr->caps.max_srq_sge) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"shared receive queue size invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!atomic_add_unless(&dev->num_srqs, 1, dev->dsr->caps.max_srq))\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&srq->lock);\n\trefcount_set(&srq->refcnt, 1);\n\tinit_completion(&srq->free);\n\n\tdev_dbg(&dev->pdev->dev,\n\t\t\"create shared receive queue from user space\\n\");\n\n\tif (ib_copy_from_udata(&ucmd, udata, sizeof(ucmd))) {\n\t\tret = -EFAULT;\n\t\tgoto err_srq;\n\t}\n\n\tsrq->umem = ib_umem_get(ibsrq->device, ucmd.buf_addr, ucmd.buf_size, 0);\n\tif (IS_ERR(srq->umem)) {\n\t\tret = PTR_ERR(srq->umem);\n\t\tgoto err_srq;\n\t}\n\n\tsrq->npages = ib_umem_num_dma_blocks(srq->umem, PAGE_SIZE);\n\n\tif (srq->npages < 0 || srq->npages > PVRDMA_PAGE_DIR_MAX_PAGES) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"overflow pages in shared receive queue\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_umem;\n\t}\n\n\tret = pvrdma_page_dir_init(dev, &srq->pdir, srq->npages, false);\n\tif (ret) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not allocate page directory\\n\");\n\t\tgoto err_umem;\n\t}\n\n\tpvrdma_page_dir_insert_umem(&srq->pdir, srq->umem, 0);\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_CREATE_SRQ;\n\tcmd->srq_type = init_attr->srq_type;\n\tcmd->nchunks = srq->npages;\n\tcmd->pd_handle = to_vpd(ibsrq->pd)->pd_handle;\n\tcmd->attrs.max_wr = init_attr->attr.max_wr;\n\tcmd->attrs.max_sge = init_attr->attr.max_sge;\n\tcmd->attrs.srq_limit = init_attr->attr.srq_limit;\n\tcmd->pdir_dma = srq->pdir.dir_dma;\n\n\tret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_SRQ_RESP);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not create shared receive queue, error: %d\\n\",\n\t\t\t ret);\n\t\tgoto err_page_dir;\n\t}\n\n\tsrq->srq_handle = resp->srqn;\n\tsrq_resp.srqn = resp->srqn;\n\tspin_lock_irqsave(&dev->srq_tbl_lock, flags);\n\tdev->srq_tbl[srq->srq_handle % dev->dsr->caps.max_srq] = srq;\n\tspin_unlock_irqrestore(&dev->srq_tbl_lock, flags);\n\n\t \n\tif (ib_copy_to_udata(udata, &srq_resp, sizeof(srq_resp))) {\n\t\tdev_warn(&dev->pdev->dev, \"failed to copy back udata\\n\");\n\t\tpvrdma_destroy_srq(&srq->ibsrq, udata);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n\nerr_page_dir:\n\tpvrdma_page_dir_cleanup(dev, &srq->pdir);\nerr_umem:\n\tib_umem_release(srq->umem);\nerr_srq:\n\tatomic_dec(&dev->num_srqs);\n\n\treturn ret;\n}\n\nstatic void pvrdma_free_srq(struct pvrdma_dev *dev, struct pvrdma_srq *srq)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dev->srq_tbl_lock, flags);\n\tdev->srq_tbl[srq->srq_handle] = NULL;\n\tspin_unlock_irqrestore(&dev->srq_tbl_lock, flags);\n\n\tif (refcount_dec_and_test(&srq->refcnt))\n\t\tcomplete(&srq->free);\n\twait_for_completion(&srq->free);\n\n\t \n\tib_umem_release(srq->umem);\n\n\tpvrdma_page_dir_cleanup(dev, &srq->pdir);\n\n\tatomic_dec(&dev->num_srqs);\n}\n\n \nint pvrdma_destroy_srq(struct ib_srq *srq, struct ib_udata *udata)\n{\n\tstruct pvrdma_srq *vsrq = to_vsrq(srq);\n\tunion pvrdma_cmd_req req;\n\tstruct pvrdma_cmd_destroy_srq *cmd = &req.destroy_srq;\n\tstruct pvrdma_dev *dev = to_vdev(srq->device);\n\tint ret;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_DESTROY_SRQ;\n\tcmd->srq_handle = vsrq->srq_handle;\n\n\tret = pvrdma_cmd_post(dev, &req, NULL, 0);\n\tif (ret < 0)\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"destroy shared receive queue failed, error: %d\\n\",\n\t\t\t ret);\n\n\tpvrdma_free_srq(dev, vsrq);\n\treturn 0;\n}\n\n \nint pvrdma_modify_srq(struct ib_srq *ibsrq, struct ib_srq_attr *attr,\n\t\t      enum ib_srq_attr_mask attr_mask, struct ib_udata *udata)\n{\n\tstruct pvrdma_srq *vsrq = to_vsrq(ibsrq);\n\tunion pvrdma_cmd_req req;\n\tstruct pvrdma_cmd_modify_srq *cmd = &req.modify_srq;\n\tstruct pvrdma_dev *dev = to_vdev(ibsrq->device);\n\tint ret;\n\n\t \n\tif (!(attr_mask & IB_SRQ_LIMIT))\n\t\treturn -EINVAL;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_MODIFY_SRQ;\n\tcmd->srq_handle = vsrq->srq_handle;\n\tcmd->attrs.srq_limit = attr->srq_limit;\n\tcmd->attr_mask = attr_mask;\n\n\tret = pvrdma_cmd_post(dev, &req, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not modify shared receive queue, error: %d\\n\",\n\t\t\t ret);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}