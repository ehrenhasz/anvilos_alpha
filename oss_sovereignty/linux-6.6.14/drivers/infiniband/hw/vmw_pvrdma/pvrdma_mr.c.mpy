{
  "module_name": "pvrdma_mr.c",
  "hash_id": "9aba879867e0889a5c4882a5c999facef7ac4ec6f9dec4cd367a4924eb3f8161",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/vmw_pvrdma/pvrdma_mr.c",
  "human_readable_source": " \n\n#include <linux/list.h>\n#include <linux/slab.h>\n\n#include \"pvrdma.h\"\n\n \nstruct ib_mr *pvrdma_get_dma_mr(struct ib_pd *pd, int acc)\n{\n\tstruct pvrdma_dev *dev = to_vdev(pd->device);\n\tstruct pvrdma_user_mr *mr;\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\n\tstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\n\tint ret;\n\n\t \n\tif (acc & ~IB_ACCESS_LOCAL_WRITE) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"unsupported dma mr access flags %#x\\n\", acc);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\n\tcmd->pd_handle = to_vpd(pd)->pd_handle;\n\tcmd->access_flags = acc;\n\tcmd->flags = PVRDMA_MR_FLAG_DMA;\n\n\tret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not get DMA mem region, error: %d\\n\", ret);\n\t\tkfree(mr);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmr->mmr.mr_handle = resp->mr_handle;\n\tmr->ibmr.lkey = resp->lkey;\n\tmr->ibmr.rkey = resp->rkey;\n\n\treturn &mr->ibmr;\n}\n\n \nstruct ib_mr *pvrdma_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\n\t\t\t\t u64 virt_addr, int access_flags,\n\t\t\t\t struct ib_udata *udata)\n{\n\tstruct pvrdma_dev *dev = to_vdev(pd->device);\n\tstruct pvrdma_user_mr *mr = NULL;\n\tstruct ib_umem *umem;\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\n\tstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\n\tint ret, npages;\n\n\tif (length == 0 || length > dev->dsr->caps.max_mr_size) {\n\t\tdev_warn(&dev->pdev->dev, \"invalid mem region length\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tumem = ib_umem_get(pd->device, start, length, access_flags);\n\tif (IS_ERR(umem)) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not get umem for mem region\\n\");\n\t\treturn ERR_CAST(umem);\n\t}\n\n\tnpages = ib_umem_num_dma_blocks(umem, PAGE_SIZE);\n\tif (npages < 0 || npages > PVRDMA_PAGE_DIR_MAX_PAGES) {\n\t\tdev_warn(&dev->pdev->dev, \"overflow %d pages in mem region\\n\",\n\t\t\t npages);\n\t\tret = -EINVAL;\n\t\tgoto err_umem;\n\t}\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr) {\n\t\tret = -ENOMEM;\n\t\tgoto err_umem;\n\t}\n\n\tmr->mmr.iova = virt_addr;\n\tmr->mmr.size = length;\n\tmr->umem = umem;\n\n\tret = pvrdma_page_dir_init(dev, &mr->pdir, npages, false);\n\tif (ret) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not allocate page directory\\n\");\n\t\tgoto err_umem;\n\t}\n\n\tret = pvrdma_page_dir_insert_umem(&mr->pdir, mr->umem, 0);\n\tif (ret)\n\t\tgoto err_pdir;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\n\tcmd->start = start;\n\tcmd->length = length;\n\tcmd->pd_handle = to_vpd(pd)->pd_handle;\n\tcmd->access_flags = access_flags;\n\tcmd->nchunks = npages;\n\tcmd->pdir_dma = mr->pdir.dir_dma;\n\n\tret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not register mem region, error: %d\\n\", ret);\n\t\tgoto err_pdir;\n\t}\n\n\tmr->mmr.mr_handle = resp->mr_handle;\n\tmr->ibmr.lkey = resp->lkey;\n\tmr->ibmr.rkey = resp->rkey;\n\n\treturn &mr->ibmr;\n\nerr_pdir:\n\tpvrdma_page_dir_cleanup(dev, &mr->pdir);\nerr_umem:\n\tib_umem_release(umem);\n\tkfree(mr);\n\n\treturn ERR_PTR(ret);\n}\n\n \nstruct ib_mr *pvrdma_alloc_mr(struct ib_pd *pd, enum ib_mr_type mr_type,\n\t\t\t      u32 max_num_sg)\n{\n\tstruct pvrdma_dev *dev = to_vdev(pd->device);\n\tstruct pvrdma_user_mr *mr;\n\tunion pvrdma_cmd_req req;\n\tunion pvrdma_cmd_resp rsp;\n\tstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\n\tstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\n\tint size = max_num_sg * sizeof(u64);\n\tint ret;\n\n\tif (mr_type != IB_MR_TYPE_MEM_REG ||\n\t    max_num_sg > PVRDMA_MAX_FAST_REG_PAGES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmr->pages = kzalloc(size, GFP_KERNEL);\n\tif (!mr->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto freemr;\n\t}\n\n\tret = pvrdma_page_dir_init(dev, &mr->pdir, max_num_sg, false);\n\tif (ret) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"failed to allocate page dir for mr\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto freepages;\n\t}\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\n\tcmd->pd_handle = to_vpd(pd)->pd_handle;\n\tcmd->access_flags = 0;\n\tcmd->flags = PVRDMA_MR_FLAG_FRMR;\n\tcmd->nchunks = max_num_sg;\n\n\tret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\n\tif (ret < 0) {\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not create FR mem region, error: %d\\n\", ret);\n\t\tgoto freepdir;\n\t}\n\n\tmr->max_pages = max_num_sg;\n\tmr->mmr.mr_handle = resp->mr_handle;\n\tmr->ibmr.lkey = resp->lkey;\n\tmr->ibmr.rkey = resp->rkey;\n\tmr->page_shift = PAGE_SHIFT;\n\tmr->umem = NULL;\n\n\treturn &mr->ibmr;\n\nfreepdir:\n\tpvrdma_page_dir_cleanup(dev, &mr->pdir);\nfreepages:\n\tkfree(mr->pages);\nfreemr:\n\tkfree(mr);\n\treturn ERR_PTR(ret);\n}\n\n \nint pvrdma_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)\n{\n\tstruct pvrdma_user_mr *mr = to_vmr(ibmr);\n\tstruct pvrdma_dev *dev = to_vdev(ibmr->device);\n\tunion pvrdma_cmd_req req;\n\tstruct pvrdma_cmd_destroy_mr *cmd = &req.destroy_mr;\n\tint ret;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.cmd = PVRDMA_CMD_DESTROY_MR;\n\tcmd->mr_handle = mr->mmr.mr_handle;\n\tret = pvrdma_cmd_post(dev, &req, NULL, 0);\n\tif (ret < 0)\n\t\tdev_warn(&dev->pdev->dev,\n\t\t\t \"could not deregister mem region, error: %d\\n\", ret);\n\n\tpvrdma_page_dir_cleanup(dev, &mr->pdir);\n\tib_umem_release(mr->umem);\n\n\tkfree(mr->pages);\n\tkfree(mr);\n\n\treturn 0;\n}\n\nstatic int pvrdma_set_page(struct ib_mr *ibmr, u64 addr)\n{\n\tstruct pvrdma_user_mr *mr = to_vmr(ibmr);\n\n\tif (mr->npages == mr->max_pages)\n\t\treturn -ENOMEM;\n\n\tmr->pages[mr->npages++] = addr;\n\treturn 0;\n}\n\nint pvrdma_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg, int sg_nents,\n\t\t     unsigned int *sg_offset)\n{\n\tstruct pvrdma_user_mr *mr = to_vmr(ibmr);\n\tstruct pvrdma_dev *dev = to_vdev(ibmr->device);\n\tint ret;\n\n\tmr->npages = 0;\n\n\tret = ib_sg_to_pages(ibmr, sg, sg_nents, sg_offset, pvrdma_set_page);\n\tif (ret < 0)\n\t\tdev_warn(&dev->pdev->dev, \"could not map sg to pages\\n\");\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}