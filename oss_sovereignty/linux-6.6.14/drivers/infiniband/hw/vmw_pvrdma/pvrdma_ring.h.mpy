{
  "module_name": "pvrdma_ring.h",
  "hash_id": "31d80b7eab29a868e67f92b541a6c2136b64b8afbb5c5a97d83a73fad2563509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/vmw_pvrdma/pvrdma_ring.h",
  "human_readable_source": " \n\n#ifndef __PVRDMA_RING_H__\n#define __PVRDMA_RING_H__\n\n#include <linux/types.h>\n\n#define PVRDMA_INVALID_IDX\t-1\t \n\nstruct pvrdma_ring {\n\tatomic_t prod_tail;\t \n\tatomic_t cons_head;\t \n};\n\nstruct pvrdma_ring_state {\n\tstruct pvrdma_ring tx;\t \n\tstruct pvrdma_ring rx;\t \n};\n\nstatic inline int pvrdma_idx_valid(__u32 idx, __u32 max_elems)\n{\n\t \n\treturn (idx & ~((max_elems << 1) - 1)) == 0;\n}\n\nstatic inline __s32 pvrdma_idx(atomic_t *var, __u32 max_elems)\n{\n\tconst unsigned int idx = atomic_read(var);\n\n\tif (pvrdma_idx_valid(idx, max_elems))\n\t\treturn idx & (max_elems - 1);\n\treturn PVRDMA_INVALID_IDX;\n}\n\nstatic inline void pvrdma_idx_ring_inc(atomic_t *var, __u32 max_elems)\n{\n\t__u32 idx = atomic_read(var) + 1;\t \n\n\tidx &= (max_elems << 1) - 1;\t\t \n\tatomic_set(var, idx);\n}\n\nstatic inline __s32 pvrdma_idx_ring_has_space(const struct pvrdma_ring *r,\n\t\t\t\t\t      __u32 max_elems, __u32 *out_tail)\n{\n\tconst __u32 tail = atomic_read(&r->prod_tail);\n\tconst __u32 head = atomic_read(&r->cons_head);\n\n\tif (pvrdma_idx_valid(tail, max_elems) &&\n\t    pvrdma_idx_valid(head, max_elems)) {\n\t\t*out_tail = tail & (max_elems - 1);\n\t\treturn tail != (head ^ max_elems);\n\t}\n\treturn PVRDMA_INVALID_IDX;\n}\n\nstatic inline __s32 pvrdma_idx_ring_has_data(const struct pvrdma_ring *r,\n\t\t\t\t\t     __u32 max_elems, __u32 *out_head)\n{\n\tconst __u32 tail = atomic_read(&r->prod_tail);\n\tconst __u32 head = atomic_read(&r->cons_head);\n\n\tif (pvrdma_idx_valid(tail, max_elems) &&\n\t    pvrdma_idx_valid(head, max_elems)) {\n\t\t*out_head = head & (max_elems - 1);\n\t\treturn tail != head;\n\t}\n\treturn PVRDMA_INVALID_IDX;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}