{
  "module_name": "qedr_iw_cm.c",
  "hash_id": "48f72d0762539a4448c1d74081e0890e488a2b785d1cfdaa51d94b6a3834b5b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qedr/qedr_iw_cm.c",
  "human_readable_source": " \n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n#include <net/addrconf.h>\n#include <net/route.h>\n#include <net/ip6_route.h>\n#include <net/flow.h>\n#include \"qedr.h\"\n#include \"qedr_iw_cm.h\"\n\nstatic inline void\nqedr_fill_sockaddr4(const struct qed_iwarp_cm_info *cm_info,\n\t\t    struct iw_cm_event *event)\n{\n\tstruct sockaddr_in *laddr = (struct sockaddr_in *)&event->local_addr;\n\tstruct sockaddr_in *raddr = (struct sockaddr_in *)&event->remote_addr;\n\n\tladdr->sin_family = AF_INET;\n\traddr->sin_family = AF_INET;\n\n\tladdr->sin_port = htons(cm_info->local_port);\n\traddr->sin_port = htons(cm_info->remote_port);\n\n\tladdr->sin_addr.s_addr = htonl(cm_info->local_ip[0]);\n\traddr->sin_addr.s_addr = htonl(cm_info->remote_ip[0]);\n}\n\nstatic inline void\nqedr_fill_sockaddr6(const struct qed_iwarp_cm_info *cm_info,\n\t\t    struct iw_cm_event *event)\n{\n\tstruct sockaddr_in6 *laddr6 = (struct sockaddr_in6 *)&event->local_addr;\n\tstruct sockaddr_in6 *raddr6 =\n\t    (struct sockaddr_in6 *)&event->remote_addr;\n\tint i;\n\n\tladdr6->sin6_family = AF_INET6;\n\traddr6->sin6_family = AF_INET6;\n\n\tladdr6->sin6_port = htons(cm_info->local_port);\n\traddr6->sin6_port = htons(cm_info->remote_port);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tladdr6->sin6_addr.in6_u.u6_addr32[i] =\n\t\t    htonl(cm_info->local_ip[i]);\n\t\traddr6->sin6_addr.in6_u.u6_addr32[i] =\n\t\t    htonl(cm_info->remote_ip[i]);\n\t}\n}\n\nstatic void qedr_iw_free_qp(struct kref *ref)\n{\n\tstruct qedr_qp *qp = container_of(ref, struct qedr_qp, refcnt);\n\n\tcomplete(&qp->qp_rel_comp);\n}\n\nstatic void\nqedr_iw_free_ep(struct kref *ref)\n{\n\tstruct qedr_iw_ep *ep = container_of(ref, struct qedr_iw_ep, refcnt);\n\n\tif (ep->qp)\n\t\tkref_put(&ep->qp->refcnt, qedr_iw_free_qp);\n\n\tif (ep->cm_id)\n\t\tep->cm_id->rem_ref(ep->cm_id);\n\n\tkfree(ep);\n}\n\nstatic void\nqedr_iw_mpa_request(void *context, struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_listener *listener = (struct qedr_iw_listener *)context;\n\tstruct qedr_dev *dev = listener->dev;\n\tstruct iw_cm_event event;\n\tstruct qedr_iw_ep *ep;\n\n\tep = kzalloc(sizeof(*ep), GFP_ATOMIC);\n\tif (!ep)\n\t\treturn;\n\n\tep->dev = dev;\n\tep->qed_context = params->ep_context;\n\tkref_init(&ep->refcnt);\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.event = IW_CM_EVENT_CONNECT_REQUEST;\n\tevent.status = params->status;\n\n\tif (!IS_ENABLED(CONFIG_IPV6) ||\n\t    params->cm_info->ip_version == QED_TCP_IPV4)\n\t\tqedr_fill_sockaddr4(params->cm_info, &event);\n\telse\n\t\tqedr_fill_sockaddr6(params->cm_info, &event);\n\n\tevent.provider_data = (void *)ep;\n\tevent.private_data = (void *)params->cm_info->private_data;\n\tevent.private_data_len = (u8)params->cm_info->private_data_len;\n\tevent.ord = params->cm_info->ord;\n\tevent.ird = params->cm_info->ird;\n\n\tlistener->cm_id->event_handler(listener->cm_id, &event);\n}\n\nstatic void\nqedr_iw_issue_event(void *context,\n\t\t    struct qed_iwarp_cm_event_params *params,\n\t\t    enum iw_cm_event_type event_type)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct iw_cm_event event;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.status = params->status;\n\tevent.event = event_type;\n\n\tif (params->cm_info) {\n\t\tevent.ird = params->cm_info->ird;\n\t\tevent.ord = params->cm_info->ord;\n\t\t \n\t\tif (event_type == IW_CM_EVENT_CONNECT_REPLY) {\n\t\t\tevent.private_data_len =\n\t\t\t\tparams->cm_info->private_data_len;\n\t\t\tevent.private_data =\n\t\t\t\t(void *)params->cm_info->private_data;\n\t\t}\n\t}\n\n\tif (ep->cm_id)\n\t\tep->cm_id->event_handler(ep->cm_id, &event);\n}\n\nstatic void\nqedr_iw_close_event(void *context, struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\n\tif (ep->cm_id)\n\t\tqedr_iw_issue_event(context, params, IW_CM_EVENT_CLOSE);\n\n\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n}\n\nstatic void\nqedr_iw_qp_event(void *context,\n\t\t struct qed_iwarp_cm_event_params *params,\n\t\t enum ib_event_type ib_event, char *str)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct qedr_dev *dev = ep->dev;\n\tstruct ib_qp *ibqp = &ep->qp->ibqp;\n\tstruct ib_event event;\n\n\tDP_NOTICE(dev, \"QP error received: %s\\n\", str);\n\n\tif (ibqp->event_handler) {\n\t\tevent.event = ib_event;\n\t\tevent.device = ibqp->device;\n\t\tevent.element.qp = ibqp;\n\t\tibqp->event_handler(&event, ibqp->qp_context);\n\t}\n}\n\nstruct qedr_discon_work {\n\tstruct work_struct\t\twork;\n\tstruct qedr_iw_ep\t\t*ep;\n\tenum qed_iwarp_event_type\tevent;\n\tint\t\t\t\tstatus;\n};\n\nstatic void qedr_iw_disconnect_worker(struct work_struct *work)\n{\n\tstruct qedr_discon_work *dwork =\n\t    container_of(work, struct qedr_discon_work, work);\n\tstruct qed_rdma_modify_qp_in_params qp_params = { 0 };\n\tstruct qedr_iw_ep *ep = dwork->ep;\n\tstruct qedr_dev *dev = ep->dev;\n\tstruct qedr_qp *qp = ep->qp;\n\tstruct iw_cm_event event;\n\n\t \n\tif (test_and_set_bit(QEDR_IWARP_CM_WAIT_FOR_DISCONNECT,\n\t\t\t     &qp->iwarp_cm_flags))\n\t\tgoto out;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.status = dwork->status;\n\tevent.event = IW_CM_EVENT_DISCONNECT;\n\n\t \n\tif (dwork->status)\n\t\tqp_params.new_state = QED_ROCE_QP_STATE_ERR;\n\telse\n\t\tqp_params.new_state = QED_ROCE_QP_STATE_SQD;\n\n\n\tif (ep->cm_id)\n\t\tep->cm_id->event_handler(ep->cm_id, &event);\n\n\tSET_FIELD(qp_params.modify_flags,\n\t\t  QED_RDMA_MODIFY_QP_VALID_NEW_STATE, 1);\n\n\tdev->ops->rdma_modify_qp(dev->rdma_ctx, qp->qed_qp, &qp_params);\n\n\tcomplete(&ep->qp->iwarp_cm_comp);\nout:\n\tkfree(dwork);\n\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n}\n\nstatic void\nqedr_iw_disconnect_event(void *context,\n\t\t\t struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_discon_work *work;\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct qedr_dev *dev = ep->dev;\n\n\twork = kzalloc(sizeof(*work), GFP_ATOMIC);\n\tif (!work)\n\t\treturn;\n\n\t \n\tkref_get(&ep->refcnt);\n\n\twork->ep = ep;\n\twork->event = params->event;\n\twork->status = params->status;\n\n\tINIT_WORK(&work->work, qedr_iw_disconnect_worker);\n\tqueue_work(dev->iwarp_wq, &work->work);\n}\n\nstatic void\nqedr_iw_passive_complete(void *context,\n\t\t\t struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct qedr_dev *dev = ep->dev;\n\n\t \n\tif ((params->status == -ECONNREFUSED) && (!ep->qp)) {\n\t\tDP_DEBUG(dev, QEDR_MSG_IWARP,\n\t\t\t \"PASSIVE connection refused releasing ep...\\n\");\n\t\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n\t\treturn;\n\t}\n\n\tcomplete(&ep->qp->iwarp_cm_comp);\n\tqedr_iw_issue_event(context, params, IW_CM_EVENT_ESTABLISHED);\n\n\tif (params->status < 0)\n\t\tqedr_iw_close_event(context, params);\n}\n\nstatic void\nqedr_iw_active_complete(void *context,\n\t\t\tstruct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\n\tcomplete(&ep->qp->iwarp_cm_comp);\n\tqedr_iw_issue_event(context, params, IW_CM_EVENT_CONNECT_REPLY);\n\n\tif (params->status < 0)\n\t\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n}\n\nstatic int\nqedr_iw_mpa_reply(void *context, struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct qedr_dev *dev = ep->dev;\n\tstruct qed_iwarp_send_rtr_in rtr_in;\n\n\trtr_in.ep_context = params->ep_context;\n\n\treturn dev->ops->iwarp_send_rtr(dev->rdma_ctx, &rtr_in);\n}\n\nstatic int\nqedr_iw_event_handler(void *context, struct qed_iwarp_cm_event_params *params)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)context;\n\tstruct qedr_dev *dev = ep->dev;\n\n\tswitch (params->event) {\n\tcase QED_IWARP_EVENT_MPA_REQUEST:\n\t\tqedr_iw_mpa_request(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_ACTIVE_MPA_REPLY:\n\t\tqedr_iw_mpa_reply(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_PASSIVE_COMPLETE:\n\t\tqedr_iw_passive_complete(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_ACTIVE_COMPLETE:\n\t\tqedr_iw_active_complete(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_DISCONNECT:\n\t\tqedr_iw_disconnect_event(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_CLOSE:\n\t\tqedr_iw_close_event(context, params);\n\t\tbreak;\n\tcase QED_IWARP_EVENT_RQ_EMPTY:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_RQ_EMPTY\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_IRQ_FULL:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_IRQ_FULL\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_LLP_TIMEOUT:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_LLP_TIMEOUT\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_REMOTE_PROTECTION_ERROR:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_ACCESS_ERR,\n\t\t\t\t \"QED_IWARP_EVENT_REMOTE_PROTECTION_ERROR\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_CQ_OVERFLOW:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_CQ_OVERFLOW\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_QP_CATASTROPHIC:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_QP_CATASTROPHIC\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_LOCAL_ACCESS_ERROR:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_ACCESS_ERR,\n\t\t\t\t \"QED_IWARP_EVENT_LOCAL_ACCESS_ERROR\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_REMOTE_OPERATION_ERROR:\n\t\tqedr_iw_qp_event(context, params, IB_EVENT_QP_FATAL,\n\t\t\t\t \"QED_IWARP_EVENT_REMOTE_OPERATION_ERROR\");\n\t\tbreak;\n\tcase QED_IWARP_EVENT_TERMINATE_RECEIVED:\n\t\tDP_NOTICE(dev, \"Got terminate message\\n\");\n\t\tbreak;\n\tdefault:\n\t\tDP_NOTICE(dev, \"Unknown event received %d\\n\", params->event);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic u16 qedr_iw_get_vlan_ipv4(struct qedr_dev *dev, u32 *addr)\n{\n\tstruct net_device *ndev;\n\tu16 vlan_id = 0;\n\n\tndev = ip_dev_find(&init_net, htonl(addr[0]));\n\n\tif (ndev) {\n\t\tvlan_id = rdma_vlan_dev_vlan_id(ndev);\n\t\tdev_put(ndev);\n\t}\n\tif (vlan_id == 0xffff)\n\t\tvlan_id = 0;\n\treturn vlan_id;\n}\n\nstatic u16 qedr_iw_get_vlan_ipv6(u32 *addr)\n{\n\tstruct net_device *ndev = NULL;\n\tstruct in6_addr laddr6;\n\tu16 vlan_id = 0;\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_IPV6))\n\t\treturn vlan_id;\n\n\tfor (i = 0; i < 4; i++)\n\t\tladdr6.in6_u.u6_addr32[i] = htonl(addr[i]);\n\n\trcu_read_lock();\n\tfor_each_netdev_rcu(&init_net, ndev) {\n\t\tif (ipv6_chk_addr(&init_net, &laddr6, ndev, 1)) {\n\t\t\tvlan_id = rdma_vlan_dev_vlan_id(ndev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\tif (vlan_id == 0xffff)\n\t\tvlan_id = 0;\n\n\treturn vlan_id;\n}\n\nstatic int\nqedr_addr4_resolve(struct qedr_dev *dev,\n\t\t   struct sockaddr_in *src_in,\n\t\t   struct sockaddr_in *dst_in, u8 *dst_mac)\n{\n\t__be32 src_ip = src_in->sin_addr.s_addr;\n\t__be32 dst_ip = dst_in->sin_addr.s_addr;\n\tstruct neighbour *neigh = NULL;\n\tstruct rtable *rt = NULL;\n\tint rc = 0;\n\n\trt = ip_route_output(&init_net, dst_ip, src_ip, 0, 0);\n\tif (IS_ERR(rt)) {\n\t\tDP_ERR(dev, \"ip_route_output returned error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tneigh = dst_neigh_lookup(&rt->dst, &dst_ip);\n\n\tif (neigh) {\n\t\trcu_read_lock();\n\t\tif (neigh->nud_state & NUD_VALID) {\n\t\t\tether_addr_copy(dst_mac, neigh->ha);\n\t\t\tDP_DEBUG(dev, QEDR_MSG_QP, \"mac_addr=[%pM]\\n\", dst_mac);\n\t\t} else {\n\t\t\tneigh_event_send(neigh, NULL);\n\t\t}\n\t\trcu_read_unlock();\n\t\tneigh_release(neigh);\n\t}\n\n\tip_rt_put(rt);\n\n\treturn rc;\n}\n\nstatic int\nqedr_addr6_resolve(struct qedr_dev *dev,\n\t\t   struct sockaddr_in6 *src_in,\n\t\t   struct sockaddr_in6 *dst_in, u8 *dst_mac)\n{\n\tstruct neighbour *neigh = NULL;\n\tstruct dst_entry *dst;\n\tstruct flowi6 fl6;\n\tint rc = 0;\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.daddr = dst_in->sin6_addr;\n\tfl6.saddr = src_in->sin6_addr;\n\n\tdst = ip6_route_output(&init_net, NULL, &fl6);\n\n\tif ((!dst) || dst->error) {\n\t\tif (dst) {\n\t\t\tDP_ERR(dev,\n\t\t\t       \"ip6_route_output returned dst->error = %d\\n\",\n\t\t\t       dst->error);\n\t\t\tdst_release(dst);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\tneigh = dst_neigh_lookup(dst, &fl6.daddr);\n\tif (neigh) {\n\t\trcu_read_lock();\n\t\tif (neigh->nud_state & NUD_VALID) {\n\t\t\tether_addr_copy(dst_mac, neigh->ha);\n\t\t\tDP_DEBUG(dev, QEDR_MSG_QP, \"mac_addr=[%pM]\\n\", dst_mac);\n\t\t} else {\n\t\t\tneigh_event_send(neigh, NULL);\n\t\t}\n\t\trcu_read_unlock();\n\t\tneigh_release(neigh);\n\t}\n\n\tdst_release(dst);\n\n\treturn rc;\n}\n\nstatic struct qedr_qp *qedr_iw_load_qp(struct qedr_dev *dev, u32 qpn)\n{\n\tstruct qedr_qp *qp;\n\n\txa_lock(&dev->qps);\n\tqp = xa_load(&dev->qps, qpn);\n\tif (qp)\n\t\tkref_get(&qp->refcnt);\n\txa_unlock(&dev->qps);\n\n\treturn qp;\n}\n\nint qedr_iw_connect(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct qedr_dev *dev = get_qedr_dev(cm_id->device);\n\tstruct qed_iwarp_connect_out out_params;\n\tstruct qed_iwarp_connect_in in_params;\n\tstruct qed_iwarp_cm_info *cm_info;\n\tstruct sockaddr_in6 *laddr6;\n\tstruct sockaddr_in6 *raddr6;\n\tstruct sockaddr_in *laddr;\n\tstruct sockaddr_in *raddr;\n\tstruct qedr_iw_ep *ep;\n\tstruct qedr_qp *qp;\n\tint rc = 0;\n\tint i;\n\n\tladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\n\traddr = (struct sockaddr_in *)&cm_id->m_remote_addr;\n\tladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\n\traddr6 = (struct sockaddr_in6 *)&cm_id->m_remote_addr;\n\n\tDP_DEBUG(dev, QEDR_MSG_IWARP, \"MAPPED %d %d\\n\",\n\t\t ntohs(((struct sockaddr_in *)&cm_id->remote_addr)->sin_port),\n\t\t ntohs(raddr->sin_port));\n\n\tDP_DEBUG(dev, QEDR_MSG_IWARP,\n\t\t \"Connect source address: %pISpc, remote address: %pISpc\\n\",\n\t\t &cm_id->local_addr, &cm_id->remote_addr);\n\n\tif (!laddr->sin_port || !raddr->sin_port)\n\t\treturn -EINVAL;\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep->dev = dev;\n\tkref_init(&ep->refcnt);\n\n\tqp = qedr_iw_load_qp(dev, conn_param->qpn);\n\tif (!qp) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tep->qp = qp;\n\tcm_id->add_ref(cm_id);\n\tep->cm_id = cm_id;\n\n\tin_params.event_cb = qedr_iw_event_handler;\n\tin_params.cb_context = ep;\n\n\tcm_info = &in_params.cm_info;\n\tmemset(cm_info->local_ip, 0, sizeof(cm_info->local_ip));\n\tmemset(cm_info->remote_ip, 0, sizeof(cm_info->remote_ip));\n\n\tif (!IS_ENABLED(CONFIG_IPV6) ||\n\t    cm_id->remote_addr.ss_family == AF_INET) {\n\t\tcm_info->ip_version = QED_TCP_IPV4;\n\n\t\tcm_info->remote_ip[0] = ntohl(raddr->sin_addr.s_addr);\n\t\tcm_info->local_ip[0] = ntohl(laddr->sin_addr.s_addr);\n\t\tcm_info->remote_port = ntohs(raddr->sin_port);\n\t\tcm_info->local_port = ntohs(laddr->sin_port);\n\t\tcm_info->vlan = qedr_iw_get_vlan_ipv4(dev, cm_info->local_ip);\n\n\t\trc = qedr_addr4_resolve(dev, laddr, raddr,\n\t\t\t\t\t(u8 *)in_params.remote_mac_addr);\n\n\t\tin_params.mss = dev->iwarp_max_mtu -\n\t\t    (sizeof(struct iphdr) + sizeof(struct tcphdr));\n\n\t} else {\n\t\tin_params.cm_info.ip_version = QED_TCP_IPV6;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcm_info->remote_ip[i] =\n\t\t\t    ntohl(raddr6->sin6_addr.in6_u.u6_addr32[i]);\n\t\t\tcm_info->local_ip[i] =\n\t\t\t    ntohl(laddr6->sin6_addr.in6_u.u6_addr32[i]);\n\t\t}\n\n\t\tcm_info->local_port = ntohs(laddr6->sin6_port);\n\t\tcm_info->remote_port = ntohs(raddr6->sin6_port);\n\n\t\tin_params.mss = dev->iwarp_max_mtu -\n\t\t    (sizeof(struct ipv6hdr) + sizeof(struct tcphdr));\n\n\t\tcm_info->vlan = qedr_iw_get_vlan_ipv6(cm_info->local_ip);\n\n\t\trc = qedr_addr6_resolve(dev, laddr6, raddr6,\n\t\t\t\t\t(u8 *)in_params.remote_mac_addr);\n\t}\n\tif (rc)\n\t\tgoto err;\n\n\tDP_DEBUG(dev, QEDR_MSG_IWARP,\n\t\t \"ord = %d ird=%d private_data=%p private_data_len=%d rq_psn=%d\\n\",\n\t\t conn_param->ord, conn_param->ird, conn_param->private_data,\n\t\t conn_param->private_data_len, qp->rq_psn);\n\n\tcm_info->ord = conn_param->ord;\n\tcm_info->ird = conn_param->ird;\n\tcm_info->private_data = conn_param->private_data;\n\tcm_info->private_data_len = conn_param->private_data_len;\n\tin_params.qp = qp->qed_qp;\n\tmemcpy(in_params.local_mac_addr, dev->ndev->dev_addr, ETH_ALEN);\n\n\tif (test_and_set_bit(QEDR_IWARP_CM_WAIT_FOR_CONNECT,\n\t\t\t     &qp->iwarp_cm_flags)) {\n\t\trc = -ENODEV;\n\t\tgoto err;  \n\t}\n\n\trc = dev->ops->iwarp_connect(dev->rdma_ctx, &in_params, &out_params);\n\tif (rc) {\n\t\tcomplete(&qp->iwarp_cm_comp);\n\t\tgoto err;\n\t}\n\n\treturn rc;\n\nerr:\n\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n\treturn rc;\n}\n\nint qedr_iw_create_listen(struct iw_cm_id *cm_id, int backlog)\n{\n\tstruct qedr_dev *dev = get_qedr_dev(cm_id->device);\n\tstruct qedr_iw_listener *listener;\n\tstruct qed_iwarp_listen_in iparams;\n\tstruct qed_iwarp_listen_out oparams;\n\tstruct sockaddr_in *laddr;\n\tstruct sockaddr_in6 *laddr6;\n\tint rc;\n\tint i;\n\n\tladdr = (struct sockaddr_in *)&cm_id->m_local_addr;\n\tladdr6 = (struct sockaddr_in6 *)&cm_id->m_local_addr;\n\n\tDP_DEBUG(dev, QEDR_MSG_IWARP,\n\t\t \"Create Listener address: %pISpc\\n\", &cm_id->local_addr);\n\n\tlistener = kzalloc(sizeof(*listener), GFP_KERNEL);\n\tif (!listener)\n\t\treturn -ENOMEM;\n\n\tlistener->dev = dev;\n\tcm_id->add_ref(cm_id);\n\tlistener->cm_id = cm_id;\n\tlistener->backlog = backlog;\n\n\tiparams.cb_context = listener;\n\tiparams.event_cb = qedr_iw_event_handler;\n\tiparams.max_backlog = backlog;\n\n\tif (!IS_ENABLED(CONFIG_IPV6) ||\n\t    cm_id->local_addr.ss_family == AF_INET) {\n\t\tiparams.ip_version = QED_TCP_IPV4;\n\t\tmemset(iparams.ip_addr, 0, sizeof(iparams.ip_addr));\n\n\t\tiparams.ip_addr[0] = ntohl(laddr->sin_addr.s_addr);\n\t\tiparams.port = ntohs(laddr->sin_port);\n\t\tiparams.vlan = qedr_iw_get_vlan_ipv4(dev, iparams.ip_addr);\n\t} else {\n\t\tiparams.ip_version = QED_TCP_IPV6;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tiparams.ip_addr[i] =\n\t\t\t    ntohl(laddr6->sin6_addr.in6_u.u6_addr32[i]);\n\t\t}\n\n\t\tiparams.port = ntohs(laddr6->sin6_port);\n\n\t\tiparams.vlan = qedr_iw_get_vlan_ipv6(iparams.ip_addr);\n\t}\n\trc = dev->ops->iwarp_create_listen(dev->rdma_ctx, &iparams, &oparams);\n\tif (rc)\n\t\tgoto err;\n\n\tlistener->qed_handle = oparams.handle;\n\tcm_id->provider_data = listener;\n\treturn rc;\n\nerr:\n\tcm_id->rem_ref(cm_id);\n\tkfree(listener);\n\treturn rc;\n}\n\nint qedr_iw_destroy_listen(struct iw_cm_id *cm_id)\n{\n\tstruct qedr_iw_listener *listener = cm_id->provider_data;\n\tstruct qedr_dev *dev = get_qedr_dev(cm_id->device);\n\tint rc = 0;\n\n\tif (listener->qed_handle)\n\t\trc = dev->ops->iwarp_destroy_listen(dev->rdma_ctx,\n\t\t\t\t\t\t    listener->qed_handle);\n\n\tcm_id->rem_ref(cm_id);\n\tkfree(listener);\n\treturn rc;\n}\n\nint qedr_iw_accept(struct iw_cm_id *cm_id, struct iw_cm_conn_param *conn_param)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)cm_id->provider_data;\n\tstruct qedr_dev *dev = ep->dev;\n\tstruct qedr_qp *qp;\n\tstruct qed_iwarp_accept_in params;\n\tint rc;\n\n\tDP_DEBUG(dev, QEDR_MSG_IWARP, \"Accept on qpid=%d\\n\", conn_param->qpn);\n\n\tqp = qedr_iw_load_qp(dev, conn_param->qpn);\n\tif (!qp) {\n\t\tDP_ERR(dev, \"Invalid QP number %d\\n\", conn_param->qpn);\n\t\treturn -EINVAL;\n\t}\n\n\tep->qp = qp;\n\tcm_id->add_ref(cm_id);\n\tep->cm_id = cm_id;\n\n\tparams.ep_context = ep->qed_context;\n\tparams.cb_context = ep;\n\tparams.qp = ep->qp->qed_qp;\n\tparams.private_data = conn_param->private_data;\n\tparams.private_data_len = conn_param->private_data_len;\n\tparams.ird = conn_param->ird;\n\tparams.ord = conn_param->ord;\n\n\tif (test_and_set_bit(QEDR_IWARP_CM_WAIT_FOR_CONNECT,\n\t\t\t     &qp->iwarp_cm_flags)) {\n\t\trc = -EINVAL;\n\t\tgoto err;  \n\t}\n\n\trc = dev->ops->iwarp_accept(dev->rdma_ctx, &params);\n\tif (rc) {\n\t\tcomplete(&qp->iwarp_cm_comp);\n\t\tgoto err;\n\t}\n\n\treturn rc;\n\nerr:\n\tkref_put(&ep->refcnt, qedr_iw_free_ep);\n\n\treturn rc;\n}\n\nint qedr_iw_reject(struct iw_cm_id *cm_id, const void *pdata, u8 pdata_len)\n{\n\tstruct qedr_iw_ep *ep = (struct qedr_iw_ep *)cm_id->provider_data;\n\tstruct qedr_dev *dev = ep->dev;\n\tstruct qed_iwarp_reject_in params;\n\n\tparams.ep_context = ep->qed_context;\n\tparams.cb_context = ep;\n\tparams.private_data = pdata;\n\tparams.private_data_len = pdata_len;\n\tep->qp = NULL;\n\n\treturn dev->ops->iwarp_reject(dev->rdma_ctx, &params);\n}\n\nvoid qedr_iw_qp_add_ref(struct ib_qp *ibqp)\n{\n\tstruct qedr_qp *qp = get_qedr_qp(ibqp);\n\n\tkref_get(&qp->refcnt);\n}\n\nvoid qedr_iw_qp_rem_ref(struct ib_qp *ibqp)\n{\n\tstruct qedr_qp *qp = get_qedr_qp(ibqp);\n\n\tkref_put(&qp->refcnt, qedr_iw_free_qp);\n}\n\nstruct ib_qp *qedr_iw_get_qp(struct ib_device *ibdev, int qpn)\n{\n\tstruct qedr_dev *dev = get_qedr_dev(ibdev);\n\n\treturn xa_load(&dev->qps, qpn);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}