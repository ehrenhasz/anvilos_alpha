{
  "module_name": "qedr_roce_cm.c",
  "hash_id": "bde5550faa3512b7ef466d8ca8e0b1556aa0d628cc7b4c9b3be4037bb4511e50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qedr/qedr_roce_cm.c",
  "human_readable_source": " \n#include <linux/dma-mapping.h>\n#include <linux/crc32.h>\n#include <linux/iommu.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/udp.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/iw_cm.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_cache.h>\n\n#include <linux/qed/qed_if.h>\n#include <linux/qed/qed_rdma_if.h>\n#include \"qedr.h\"\n#include \"verbs.h\"\n#include <rdma/qedr-abi.h>\n#include \"qedr_roce_cm.h\"\n\nvoid qedr_inc_sw_gsi_cons(struct qedr_qp_hwq_info *info)\n{\n\tinfo->gsi_cons = (info->gsi_cons + 1) % info->max_wr;\n}\n\nvoid qedr_store_gsi_qp_cq(struct qedr_dev *dev, struct qedr_qp *qp,\n\t\t\t  struct ib_qp_init_attr *attrs)\n{\n\tdev->gsi_qp_created = 1;\n\tdev->gsi_sqcq = get_qedr_cq(attrs->send_cq);\n\tdev->gsi_rqcq = get_qedr_cq(attrs->recv_cq);\n\tdev->gsi_qp = qp;\n}\n\nstatic void qedr_ll2_complete_tx_packet(void *cxt, u8 connection_handle,\n\t\t\t\t\tvoid *cookie,\n\t\t\t\t\tdma_addr_t first_frag_addr,\n\t\t\t\t\tbool b_last_fragment,\n\t\t\t\t\tbool b_last_packet)\n{\n\tstruct qedr_dev *dev = (struct qedr_dev *)cxt;\n\tstruct qed_roce_ll2_packet *pkt = cookie;\n\tstruct qedr_cq *cq = dev->gsi_sqcq;\n\tstruct qedr_qp *qp = dev->gsi_qp;\n\tunsigned long flags;\n\n\tDP_DEBUG(dev, QEDR_MSG_GSI,\n\t\t \"LL2 TX CB: gsi_sqcq=%p, gsi_rqcq=%p, gsi_cons=%d, ibcq_comp=%s\\n\",\n\t\t dev->gsi_sqcq, dev->gsi_rqcq, qp->sq.gsi_cons,\n\t\t cq->ibcq.comp_handler ? \"Yes\" : \"No\");\n\n\tdma_free_coherent(&dev->pdev->dev, pkt->header.len, pkt->header.vaddr,\n\t\t\t  pkt->header.baddr);\n\tkfree(pkt);\n\n\tspin_lock_irqsave(&qp->q_lock, flags);\n\tqedr_inc_sw_gsi_cons(&qp->sq);\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\n\tif (cq->ibcq.comp_handler)\n\t\t(*cq->ibcq.comp_handler) (&cq->ibcq, cq->ibcq.cq_context);\n}\n\nstatic void qedr_ll2_complete_rx_packet(void *cxt,\n\t\t\t\t\tstruct qed_ll2_comp_rx_data *data)\n{\n\tstruct qedr_dev *dev = (struct qedr_dev *)cxt;\n\tstruct qedr_cq *cq = dev->gsi_rqcq;\n\tstruct qedr_qp *qp = dev->gsi_qp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->q_lock, flags);\n\n\tqp->rqe_wr_id[qp->rq.gsi_cons].rc = data->u.data_length_error ?\n\t\t-EINVAL : 0;\n\tqp->rqe_wr_id[qp->rq.gsi_cons].vlan = data->vlan;\n\t \n\tqp->rqe_wr_id[qp->rq.gsi_cons].sg_list[0].length =\n\t\tdata->length.data_length;\n\t*((u32 *)&qp->rqe_wr_id[qp->rq.gsi_cons].smac[0]) =\n\t\tntohl(data->opaque_data_0);\n\t*((u16 *)&qp->rqe_wr_id[qp->rq.gsi_cons].smac[4]) =\n\t\tntohs((u16)data->opaque_data_1);\n\n\tqedr_inc_sw_gsi_cons(&qp->rq);\n\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\n\tif (cq->ibcq.comp_handler)\n\t\t(*cq->ibcq.comp_handler) (&cq->ibcq, cq->ibcq.cq_context);\n}\n\nstatic void qedr_ll2_release_rx_packet(void *cxt, u8 connection_handle,\n\t\t\t\t       void *cookie, dma_addr_t rx_buf_addr,\n\t\t\t\t       bool b_last_packet)\n{\n\t \n}\n\nstatic void qedr_destroy_gsi_cq(struct qedr_dev *dev,\n\t\t\t\tstruct ib_qp_init_attr *attrs)\n{\n\tstruct qed_rdma_destroy_cq_in_params iparams;\n\tstruct qed_rdma_destroy_cq_out_params oparams;\n\tstruct qedr_cq *cq;\n\n\tcq = get_qedr_cq(attrs->send_cq);\n\tiparams.icid = cq->icid;\n\tdev->ops->rdma_destroy_cq(dev->rdma_ctx, &iparams, &oparams);\n\tdev->ops->common->chain_free(dev->cdev, &cq->pbl);\n\n\tcq = get_qedr_cq(attrs->recv_cq);\n\t \n\tif (iparams.icid != cq->icid) {\n\t\tiparams.icid = cq->icid;\n\t\tdev->ops->rdma_destroy_cq(dev->rdma_ctx, &iparams, &oparams);\n\t\tdev->ops->common->chain_free(dev->cdev, &cq->pbl);\n\t}\n}\n\nstatic inline int qedr_check_gsi_qp_attrs(struct qedr_dev *dev,\n\t\t\t\t\t  struct ib_qp_init_attr *attrs)\n{\n\tif (attrs->cap.max_recv_sge > QEDR_GSI_MAX_RECV_SGE) {\n\t\tDP_ERR(dev,\n\t\t       \" create gsi qp: failed. max_recv_sge is larger the max %d>%d\\n\",\n\t\t       attrs->cap.max_recv_sge, QEDR_GSI_MAX_RECV_SGE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs->cap.max_recv_wr > QEDR_GSI_MAX_RECV_WR) {\n\t\tDP_ERR(dev,\n\t\t       \" create gsi qp: failed. max_recv_wr is too large %d>%d\\n\",\n\t\t       attrs->cap.max_recv_wr, QEDR_GSI_MAX_RECV_WR);\n\t\treturn -EINVAL;\n\t}\n\n\tif (attrs->cap.max_send_wr > QEDR_GSI_MAX_SEND_WR) {\n\t\tDP_ERR(dev,\n\t\t       \" create gsi qp: failed. max_send_wr is too large %d>%d\\n\",\n\t\t       attrs->cap.max_send_wr, QEDR_GSI_MAX_SEND_WR);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int qedr_ll2_post_tx(struct qedr_dev *dev,\n\t\t\t    struct qed_roce_ll2_packet *pkt)\n{\n\tenum qed_ll2_roce_flavor_type roce_flavor;\n\tstruct qed_ll2_tx_pkt_info ll2_tx_pkt;\n\tint rc;\n\tint i;\n\n\tmemset(&ll2_tx_pkt, 0, sizeof(ll2_tx_pkt));\n\n\troce_flavor = (pkt->roce_mode == ROCE_V1) ?\n\t    QED_LL2_ROCE : QED_LL2_RROCE;\n\n\tif (pkt->roce_mode == ROCE_V2_IPV4)\n\t\tll2_tx_pkt.enable_ip_cksum = 1;\n\n\tll2_tx_pkt.num_of_bds = 1    + pkt->n_seg;\n\tll2_tx_pkt.vlan = 0;\n\tll2_tx_pkt.tx_dest = pkt->tx_dest;\n\tll2_tx_pkt.qed_roce_flavor = roce_flavor;\n\tll2_tx_pkt.first_frag = pkt->header.baddr;\n\tll2_tx_pkt.first_frag_len = pkt->header.len;\n\tll2_tx_pkt.cookie = pkt;\n\n\t \n\trc = dev->ops->ll2_prepare_tx_packet(dev->rdma_ctx,\n\t\t\t\t\t     dev->gsi_ll2_handle,\n\t\t\t\t\t     &ll2_tx_pkt, 1);\n\tif (rc) {\n\t\t \n\t\tdma_free_coherent(&dev->pdev->dev, pkt->header.len,\n\t\t\t\t  pkt->header.vaddr, pkt->header.baddr);\n\t\tkfree(pkt);\n\n\t\tDP_ERR(dev, \"roce ll2 tx: header failed (rc=%d)\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tfor (i = 0; i < pkt->n_seg; i++) {\n\t\trc = dev->ops->ll2_set_fragment_of_tx_packet(\n\t\t\tdev->rdma_ctx,\n\t\t\tdev->gsi_ll2_handle,\n\t\t\tpkt->payload[i].baddr,\n\t\t\tpkt->payload[i].len);\n\n\t\tif (rc) {\n\t\t\t \n\t\t\tDP_ERR(dev, \"ll2 tx: payload failed (rc=%d)\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int qedr_ll2_stop(struct qedr_dev *dev)\n{\n\tint rc;\n\n\tif (dev->gsi_ll2_handle == QED_LL2_UNUSED_HANDLE)\n\t\treturn 0;\n\n\t \n\trc = dev->ops->ll2_set_mac_filter(dev->cdev,\n\t\t\t\t\t  dev->gsi_ll2_mac_address, NULL);\n\n\trc = dev->ops->ll2_terminate_connection(dev->rdma_ctx,\n\t\t\t\t\t\tdev->gsi_ll2_handle);\n\tif (rc)\n\t\tDP_ERR(dev, \"Failed to terminate LL2 connection (rc=%d)\\n\", rc);\n\n\tdev->ops->ll2_release_connection(dev->rdma_ctx, dev->gsi_ll2_handle);\n\n\tdev->gsi_ll2_handle = QED_LL2_UNUSED_HANDLE;\n\n\treturn rc;\n}\n\nstatic int qedr_ll2_start(struct qedr_dev *dev,\n\t\t\t  struct ib_qp_init_attr *attrs, struct qedr_qp *qp)\n{\n\tstruct qed_ll2_acquire_data data;\n\tstruct qed_ll2_cbs cbs;\n\tint rc;\n\n\t \n\tcbs.rx_comp_cb = qedr_ll2_complete_rx_packet;\n\tcbs.tx_comp_cb = qedr_ll2_complete_tx_packet;\n\tcbs.rx_release_cb = qedr_ll2_release_rx_packet;\n\tcbs.tx_release_cb = qedr_ll2_complete_tx_packet;\n\tcbs.cookie = dev;\n\n\tmemset(&data, 0, sizeof(data));\n\tdata.input.conn_type = QED_LL2_TYPE_ROCE;\n\tdata.input.mtu = dev->ndev->mtu;\n\tdata.input.rx_num_desc = attrs->cap.max_recv_wr;\n\tdata.input.rx_drop_ttl0_flg = true;\n\tdata.input.rx_vlan_removal_en = false;\n\tdata.input.tx_num_desc = attrs->cap.max_send_wr;\n\tdata.input.tx_tc = 0;\n\tdata.input.tx_dest = QED_LL2_TX_DEST_NW;\n\tdata.input.ai_err_packet_too_big = QED_LL2_DROP_PACKET;\n\tdata.input.ai_err_no_buf = QED_LL2_DROP_PACKET;\n\tdata.input.gsi_enable = 1;\n\tdata.p_connection_handle = &dev->gsi_ll2_handle;\n\tdata.cbs = &cbs;\n\n\trc = dev->ops->ll2_acquire_connection(dev->rdma_ctx, &data);\n\tif (rc) {\n\t\tDP_ERR(dev,\n\t\t       \"ll2 start: failed to acquire LL2 connection (rc=%d)\\n\",\n\t\t       rc);\n\t\treturn rc;\n\t}\n\n\trc = dev->ops->ll2_establish_connection(dev->rdma_ctx,\n\t\t\t\t\t\tdev->gsi_ll2_handle);\n\tif (rc) {\n\t\tDP_ERR(dev,\n\t\t       \"ll2 start: failed to establish LL2 connection (rc=%d)\\n\",\n\t\t       rc);\n\t\tgoto err1;\n\t}\n\n\trc = dev->ops->ll2_set_mac_filter(dev->cdev, NULL, dev->ndev->dev_addr);\n\tif (rc)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\tdev->ops->ll2_terminate_connection(dev->rdma_ctx, dev->gsi_ll2_handle);\nerr1:\n\tdev->ops->ll2_release_connection(dev->rdma_ctx, dev->gsi_ll2_handle);\n\n\treturn rc;\n}\n\nint qedr_create_gsi_qp(struct qedr_dev *dev, struct ib_qp_init_attr *attrs,\n\t\t       struct qedr_qp *qp)\n{\n\tint rc;\n\n\trc = qedr_check_gsi_qp_attrs(dev, attrs);\n\tif (rc)\n\t\treturn rc;\n\n\trc = qedr_ll2_start(dev, attrs, qp);\n\tif (rc) {\n\t\tDP_ERR(dev, \"create gsi qp: failed on ll2 start. rc=%d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\t \n\tqp->ibqp.qp_num = 1;\n\tqp->rq.max_wr = attrs->cap.max_recv_wr;\n\tqp->sq.max_wr = attrs->cap.max_send_wr;\n\n\tqp->rqe_wr_id = kcalloc(qp->rq.max_wr, sizeof(*qp->rqe_wr_id),\n\t\t\t\tGFP_KERNEL);\n\tif (!qp->rqe_wr_id)\n\t\tgoto err;\n\tqp->wqe_wr_id = kcalloc(qp->sq.max_wr, sizeof(*qp->wqe_wr_id),\n\t\t\t\tGFP_KERNEL);\n\tif (!qp->wqe_wr_id)\n\t\tgoto err;\n\n\tqedr_store_gsi_qp_cq(dev, qp, attrs);\n\tether_addr_copy(dev->gsi_ll2_mac_address, dev->ndev->dev_addr);\n\n\t \n\tqedr_destroy_gsi_cq(dev, attrs);\n\tdev->gsi_rqcq->cq_type = QEDR_CQ_TYPE_GSI;\n\n\tDP_DEBUG(dev, QEDR_MSG_GSI, \"created GSI QP %p\\n\", qp);\n\n\treturn 0;\n\nerr:\n\tkfree(qp->rqe_wr_id);\n\n\trc = qedr_ll2_stop(dev);\n\tif (rc)\n\t\tDP_ERR(dev, \"create gsi qp: failed destroy on create\\n\");\n\n\treturn -ENOMEM;\n}\n\nint qedr_destroy_gsi_qp(struct qedr_dev *dev)\n{\n\treturn qedr_ll2_stop(dev);\n}\n\n#define QEDR_MAX_UD_HEADER_SIZE\t(100)\n#define QEDR_GSI_QPN\t\t(1)\nstatic inline int qedr_gsi_build_header(struct qedr_dev *dev,\n\t\t\t\t\tstruct qedr_qp *qp,\n\t\t\t\t\tconst struct ib_send_wr *swr,\n\t\t\t\t\tstruct ib_ud_header *udh,\n\t\t\t\t\tint *roce_mode)\n{\n\tbool has_vlan = false, has_grh_ipv6 = true;\n\tstruct rdma_ah_attr *ah_attr = &get_qedr_ah(ud_wr(swr)->ah)->attr;\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\tconst struct ib_gid_attr *sgid_attr = grh->sgid_attr;\n\tint send_size = 0;\n\tu16 vlan_id = 0;\n\tu16 ether_type;\n\tint rc;\n\tint ip_ver = 0;\n\n\tbool has_udp = false;\n\tint i;\n\n\trc = rdma_read_gid_l2_fields(sgid_attr, &vlan_id, NULL);\n\tif (rc)\n\t\treturn rc;\n\n\tif (vlan_id < VLAN_CFI_MASK)\n\t\thas_vlan = true;\n\n\tsend_size = 0;\n\tfor (i = 0; i < swr->num_sge; ++i)\n\t\tsend_size += swr->sg_list[i].length;\n\n\thas_udp = (sgid_attr->gid_type == IB_GID_TYPE_ROCE_UDP_ENCAP);\n\tif (!has_udp) {\n\t\t \n\t\tether_type = ETH_P_IBOE;\n\t\t*roce_mode = ROCE_V1;\n\t} else if (ipv6_addr_v4mapped((struct in6_addr *)&sgid_attr->gid)) {\n\t\t \n\t\tip_ver = 4;\n\t\tether_type = ETH_P_IP;\n\t\thas_grh_ipv6 = false;\n\t\t*roce_mode = ROCE_V2_IPV4;\n\t} else {\n\t\t \n\t\tip_ver = 6;\n\t\tether_type = ETH_P_IPV6;\n\t\t*roce_mode = ROCE_V2_IPV6;\n\t}\n\n\trc = ib_ud_header_init(send_size, false, true, has_vlan,\n\t\t\t       has_grh_ipv6, ip_ver, has_udp, 0, udh);\n\tif (rc) {\n\t\tDP_ERR(dev, \"gsi post send: failed to init header\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\tether_addr_copy(udh->eth.dmac_h, ah_attr->roce.dmac);\n\tether_addr_copy(udh->eth.smac_h, dev->ndev->dev_addr);\n\tif (has_vlan) {\n\t\tudh->eth.type = htons(ETH_P_8021Q);\n\t\tudh->vlan.tag = htons(vlan_id);\n\t\tudh->vlan.type = htons(ether_type);\n\t} else {\n\t\tudh->eth.type = htons(ether_type);\n\t}\n\n\t \n\tudh->bth.solicited_event = !!(swr->send_flags & IB_SEND_SOLICITED);\n\tudh->bth.pkey = QEDR_ROCE_PKEY_DEFAULT;\n\tudh->bth.destination_qpn = htonl(ud_wr(swr)->remote_qpn);\n\tudh->bth.psn = htonl((qp->sq_psn++) & ((1 << 24) - 1));\n\tudh->bth.opcode = IB_OPCODE_UD_SEND_ONLY;\n\n\t \n\tudh->deth.qkey = htonl(0x80010000);\n\tudh->deth.source_qpn = htonl(QEDR_GSI_QPN);\n\n\tif (has_grh_ipv6) {\n\t\t \n\t\tudh->grh.traffic_class = grh->traffic_class;\n\t\tudh->grh.flow_label = grh->flow_label;\n\t\tudh->grh.hop_limit = grh->hop_limit;\n\t\tudh->grh.destination_gid = grh->dgid;\n\t\tmemcpy(&udh->grh.source_gid.raw, sgid_attr->gid.raw,\n\t\t       sizeof(udh->grh.source_gid.raw));\n\t} else {\n\t\t \n\t\tu32 ipv4_addr;\n\n\t\tudh->ip4.protocol = IPPROTO_UDP;\n\t\tudh->ip4.tos = htonl(grh->flow_label);\n\t\tudh->ip4.frag_off = htons(IP_DF);\n\t\tudh->ip4.ttl = grh->hop_limit;\n\n\t\tipv4_addr = qedr_get_ipv4_from_gid(sgid_attr->gid.raw);\n\t\tudh->ip4.saddr = ipv4_addr;\n\t\tipv4_addr = qedr_get_ipv4_from_gid(grh->dgid.raw);\n\t\tudh->ip4.daddr = ipv4_addr;\n\t\t \n\t}\n\n\t \n\tif (has_udp) {\n\t\tudh->udp.sport = htons(QEDR_ROCE_V2_UDP_SPORT);\n\t\tudh->udp.dport = htons(ROCE_V2_UDP_DPORT);\n\t\tudh->udp.csum = 0;\n\t\t \n\t}\n\treturn 0;\n}\n\nstatic inline int qedr_gsi_build_packet(struct qedr_dev *dev,\n\t\t\t\t\tstruct qedr_qp *qp,\n\t\t\t\t\tconst struct ib_send_wr *swr,\n\t\t\t\t\tstruct qed_roce_ll2_packet **p_packet)\n{\n\tu8 ud_header_buffer[QEDR_MAX_UD_HEADER_SIZE];\n\tstruct qed_roce_ll2_packet *packet;\n\tstruct pci_dev *pdev = dev->pdev;\n\tint roce_mode, header_size;\n\tstruct ib_ud_header udh;\n\tint i, rc;\n\n\t*p_packet = NULL;\n\n\trc = qedr_gsi_build_header(dev, qp, swr, &udh, &roce_mode);\n\tif (rc)\n\t\treturn rc;\n\n\theader_size = ib_ud_header_pack(&udh, &ud_header_buffer);\n\n\tpacket = kzalloc(sizeof(*packet), GFP_ATOMIC);\n\tif (!packet)\n\t\treturn -ENOMEM;\n\n\tpacket->header.vaddr = dma_alloc_coherent(&pdev->dev, header_size,\n\t\t\t\t\t\t  &packet->header.baddr,\n\t\t\t\t\t\t  GFP_ATOMIC);\n\tif (!packet->header.vaddr) {\n\t\tkfree(packet);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ether_addr_equal(udh.eth.smac_h, udh.eth.dmac_h))\n\t\tpacket->tx_dest = QED_LL2_TX_DEST_LB;\n\telse\n\t\tpacket->tx_dest = QED_LL2_TX_DEST_NW;\n\n\tpacket->roce_mode = roce_mode;\n\tmemcpy(packet->header.vaddr, ud_header_buffer, header_size);\n\tpacket->header.len = header_size;\n\tpacket->n_seg = swr->num_sge;\n\tfor (i = 0; i < packet->n_seg; i++) {\n\t\tpacket->payload[i].baddr = swr->sg_list[i].addr;\n\t\tpacket->payload[i].len = swr->sg_list[i].length;\n\t}\n\n\t*p_packet = packet;\n\n\treturn 0;\n}\n\nint qedr_gsi_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t       const struct ib_send_wr **bad_wr)\n{\n\tstruct qed_roce_ll2_packet *pkt = NULL;\n\tstruct qedr_qp *qp = get_qedr_qp(ibqp);\n\tstruct qedr_dev *dev = qp->dev;\n\tunsigned long flags;\n\tint rc;\n\n\tif (qp->state != QED_ROCE_QP_STATE_RTS) {\n\t\t*bad_wr = wr;\n\t\tDP_ERR(dev,\n\t\t       \"gsi post recv: failed to post rx buffer. state is %d and not QED_ROCE_QP_STATE_RTS\\n\",\n\t\t       qp->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wr->num_sge > RDMA_MAX_SGE_PER_SQ_WQE) {\n\t\tDP_ERR(dev, \"gsi post send: num_sge is too large (%d>%d)\\n\",\n\t\t       wr->num_sge, RDMA_MAX_SGE_PER_SQ_WQE);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (wr->opcode != IB_WR_SEND) {\n\t\tDP_ERR(dev,\n\t\t       \"gsi post send: failed due to unsupported opcode %d\\n\",\n\t\t       wr->opcode);\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tspin_lock_irqsave(&qp->q_lock, flags);\n\n\trc = qedr_gsi_build_packet(dev, qp, wr, &pkt);\n\tif (rc) {\n\t\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\t\tgoto err;\n\t}\n\n\trc = qedr_ll2_post_tx(dev, pkt);\n\n\tif (!rc) {\n\t\tqp->wqe_wr_id[qp->sq.prod].wr_id = wr->wr_id;\n\t\tqedr_inc_sw_prod(&qp->sq);\n\t\tDP_DEBUG(qp->dev, QEDR_MSG_GSI,\n\t\t\t \"gsi post send: opcode=%d, wr_id=%llx\\n\", wr->opcode,\n\t\t\t wr->wr_id);\n\t} else {\n\t\tDP_ERR(dev, \"gsi post send: failed to transmit (rc=%d)\\n\", rc);\n\t\trc = -EAGAIN;\n\t\t*bad_wr = wr;\n\t}\n\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\n\tif (wr->next) {\n\t\tDP_ERR(dev,\n\t\t       \"gsi post send: failed second WR. Only one WR may be passed at a time\\n\");\n\t\t*bad_wr = wr->next;\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n\nerr:\n\t*bad_wr = wr;\n\treturn rc;\n}\n\nint qedr_gsi_post_recv(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t       const struct ib_recv_wr **bad_wr)\n{\n\tstruct qedr_dev *dev = get_qedr_dev(ibqp->device);\n\tstruct qedr_qp *qp = get_qedr_qp(ibqp);\n\tunsigned long flags;\n\tint rc = 0;\n\n\tif ((qp->state != QED_ROCE_QP_STATE_RTR) &&\n\t    (qp->state != QED_ROCE_QP_STATE_RTS)) {\n\t\t*bad_wr = wr;\n\t\tDP_ERR(dev,\n\t\t       \"gsi post recv: failed to post rx buffer. state is %d and not QED_ROCE_QP_STATE_RTR/S\\n\",\n\t\t       qp->state);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&qp->q_lock, flags);\n\n\twhile (wr) {\n\t\tif (wr->num_sge > QEDR_GSI_MAX_RECV_SGE) {\n\t\t\tDP_ERR(dev,\n\t\t\t       \"gsi post recv: failed to post rx buffer. too many sges %d>%d\\n\",\n\t\t\t       wr->num_sge, QEDR_GSI_MAX_RECV_SGE);\n\t\t\tgoto err;\n\t\t}\n\n\t\trc = dev->ops->ll2_post_rx_buffer(dev->rdma_ctx,\n\t\t\t\t\t\t  dev->gsi_ll2_handle,\n\t\t\t\t\t\t  wr->sg_list[0].addr,\n\t\t\t\t\t\t  wr->sg_list[0].length,\n\t\t\t\t\t\t  NULL  ,\n\t\t\t\t\t\t  1  );\n\t\tif (rc) {\n\t\t\tDP_ERR(dev,\n\t\t\t       \"gsi post recv: failed to post rx buffer (rc=%d)\\n\",\n\t\t\t       rc);\n\t\t\tgoto err;\n\t\t}\n\n\t\tmemset(&qp->rqe_wr_id[qp->rq.prod], 0,\n\t\t       sizeof(qp->rqe_wr_id[qp->rq.prod]));\n\t\tqp->rqe_wr_id[qp->rq.prod].sg_list[0] = wr->sg_list[0];\n\t\tqp->rqe_wr_id[qp->rq.prod].wr_id = wr->wr_id;\n\n\t\tqedr_inc_sw_prod(&qp->rq);\n\n\t\twr = wr->next;\n\t}\n\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\n\treturn rc;\nerr:\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\t*bad_wr = wr;\n\treturn -ENOMEM;\n}\n\nint qedr_gsi_poll_cq(struct ib_cq *ibcq, int num_entries, struct ib_wc *wc)\n{\n\tstruct qedr_dev *dev = get_qedr_dev(ibcq->device);\n\tstruct qedr_cq *cq = get_qedr_cq(ibcq);\n\tstruct qedr_qp *qp = dev->gsi_qp;\n\tunsigned long flags;\n\tu16 vlan_id;\n\tint i = 0;\n\n\tspin_lock_irqsave(&cq->cq_lock, flags);\n\n\twhile (i < num_entries && qp->rq.cons != qp->rq.gsi_cons) {\n\t\tmemset(&wc[i], 0, sizeof(*wc));\n\n\t\twc[i].qp = &qp->ibqp;\n\t\twc[i].wr_id = qp->rqe_wr_id[qp->rq.cons].wr_id;\n\t\twc[i].opcode = IB_WC_RECV;\n\t\twc[i].pkey_index = 0;\n\t\twc[i].status = (qp->rqe_wr_id[qp->rq.cons].rc) ?\n\t\t    IB_WC_GENERAL_ERR : IB_WC_SUCCESS;\n\t\t \n\t\twc[i].byte_len = qp->rqe_wr_id[qp->rq.cons].sg_list[0].length;\n\t\twc[i].wc_flags |= IB_WC_GRH | IB_WC_IP_CSUM_OK;\n\t\tether_addr_copy(wc[i].smac, qp->rqe_wr_id[qp->rq.cons].smac);\n\t\twc[i].wc_flags |= IB_WC_WITH_SMAC;\n\n\t\tvlan_id = qp->rqe_wr_id[qp->rq.cons].vlan &\n\t\t\t  VLAN_VID_MASK;\n\t\tif (vlan_id) {\n\t\t\twc[i].wc_flags |= IB_WC_WITH_VLAN;\n\t\t\twc[i].vlan_id = vlan_id;\n\t\t\twc[i].sl = (qp->rqe_wr_id[qp->rq.cons].vlan &\n\t\t\t\t    VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\n\t\t}\n\n\t\tqedr_inc_sw_cons(&qp->rq);\n\t\ti++;\n\t}\n\n\twhile (i < num_entries && qp->sq.cons != qp->sq.gsi_cons) {\n\t\tmemset(&wc[i], 0, sizeof(*wc));\n\n\t\twc[i].qp = &qp->ibqp;\n\t\twc[i].wr_id = qp->wqe_wr_id[qp->sq.cons].wr_id;\n\t\twc[i].opcode = IB_WC_SEND;\n\t\twc[i].status = IB_WC_SUCCESS;\n\n\t\tqedr_inc_sw_cons(&qp->sq);\n\t\ti++;\n\t}\n\n\tspin_unlock_irqrestore(&cq->cq_lock, flags);\n\n\tDP_DEBUG(dev, QEDR_MSG_GSI,\n\t\t \"gsi poll_cq: requested entries=%d, actual=%d, qp->rq.cons=%d, qp->rq.gsi_cons=%x, qp->sq.cons=%d, qp->sq.gsi_cons=%d, qp_num=%d\\n\",\n\t\t num_entries, i, qp->rq.cons, qp->rq.gsi_cons, qp->sq.cons,\n\t\t qp->sq.gsi_cons, qp->ibqp.qp_num);\n\n\treturn i;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}