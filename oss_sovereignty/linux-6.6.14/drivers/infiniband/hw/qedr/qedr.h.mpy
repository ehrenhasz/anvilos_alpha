{
  "module_name": "qedr.h",
  "hash_id": "6a838a77bfd370a46fa0b6ecb093b76317176c85464e653545fbf7852e341c28",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qedr/qedr.h",
  "human_readable_source": " \n#ifndef __QEDR_H__\n#define __QEDR_H__\n\n#include <linux/pci.h>\n#include <linux/xarray.h>\n#include <rdma/ib_addr.h>\n#include <linux/qed/qed_if.h>\n#include <linux/qed/qed_chain.h>\n#include <linux/qed/qed_rdma_if.h>\n#include <linux/qed/qede_rdma.h>\n#include <linux/qed/roce_common.h>\n#include <linux/completion.h>\n#include \"qedr_hsi_rdma.h\"\n\n#define QEDR_NODE_DESC \"QLogic 579xx RoCE HCA\"\n#define DP_NAME(_dev) dev_name(&(_dev)->ibdev.dev)\n#define IS_IWARP(_dev) ((_dev)->rdma_type == QED_RDMA_TYPE_IWARP)\n#define IS_ROCE(_dev) ((_dev)->rdma_type == QED_RDMA_TYPE_ROCE)\n\n#define DP_DEBUG(dev, module, fmt, ...)\t\t\t\t\t\\\n\tpr_debug(\"(%s) \" module \": \" fmt,\t\t\t\t\\\n\t\t DP_NAME(dev) ? DP_NAME(dev) : \"\", ## __VA_ARGS__)\n\n#define QEDR_MSG_INIT \"INIT\"\n#define QEDR_MSG_MISC \"MISC\"\n#define QEDR_MSG_CQ   \"  CQ\"\n#define QEDR_MSG_MR   \"  MR\"\n#define QEDR_MSG_RQ   \"  RQ\"\n#define QEDR_MSG_SQ   \"  SQ\"\n#define QEDR_MSG_QP   \"  QP\"\n#define QEDR_MSG_SRQ  \" SRQ\"\n#define QEDR_MSG_GSI  \" GSI\"\n#define QEDR_MSG_IWARP  \" IW\"\n\n#define QEDR_CQ_MAGIC_NUMBER\t(0x11223344)\n\n#define FW_PAGE_SIZE\t\t(RDMA_RING_PAGE_SIZE)\n#define FW_PAGE_SHIFT\t\t(12)\n\nstruct qedr_dev;\n\nstruct qedr_cnq {\n\tstruct qedr_dev\t\t*dev;\n\tstruct qed_chain\tpbl;\n\tstruct qed_sb_info\t*sb;\n\tchar\t\t\tname[32];\n\tu64\t\t\tn_comp;\n\t__le16\t\t\t*hw_cons_ptr;\n\tu8\t\t\tindex;\n};\n\n#define QEDR_MAX_SGID 128\n\nstruct qedr_device_attr {\n\tu32\tvendor_id;\n\tu32\tvendor_part_id;\n\tu32\thw_ver;\n\tu64\tfw_ver;\n\tu64\tnode_guid;\n\tu64\tsys_image_guid;\n\tu8\tmax_cnq;\n\tu8\tmax_sge;\n\tu16\tmax_inline;\n\tu32\tmax_sqe;\n\tu32\tmax_rqe;\n\tu8\tmax_qp_resp_rd_atomic_resc;\n\tu8\tmax_qp_req_rd_atomic_resc;\n\tu64\tmax_dev_resp_rd_atomic_resc;\n\tu32\tmax_cq;\n\tu32\tmax_qp;\n\tu32\tmax_mr;\n\tu64\tmax_mr_size;\n\tu32\tmax_cqe;\n\tu32\tmax_mw;\n\tu32\tmax_mr_mw_fmr_pbl;\n\tu64\tmax_mr_mw_fmr_size;\n\tu32\tmax_pd;\n\tu32\tmax_ah;\n\tu8\tmax_pkey;\n\tu32\tmax_srq;\n\tu32\tmax_srq_wr;\n\tu8\tmax_srq_sge;\n\tu8\tmax_stats_queues;\n\tu32\tdev_caps;\n\n\tu64\tpage_size_caps;\n\tu8\tdev_ack_delay;\n\tu32\treserved_lkey;\n\tu32\tbad_pkey_counter;\n\tstruct qed_rdma_events events;\n};\n\n#define QEDR_ENET_STATE_BIT\t(0)\n\nstruct qedr_dev {\n\tstruct ib_device\tibdev;\n\tstruct qed_dev\t\t*cdev;\n\tstruct pci_dev\t\t*pdev;\n\tstruct net_device\t*ndev;\n\n\tenum ib_atomic_cap\tatomic_cap;\n\n\tvoid *rdma_ctx;\n\tstruct qedr_device_attr attr;\n\n\tconst struct qed_rdma_ops *ops;\n\tstruct qed_int_info\tint_info;\n\n\tstruct qed_sb_info\t*sb_array;\n\tstruct qedr_cnq\t\t*cnq_array;\n\tint\t\t\tnum_cnq;\n\tint\t\t\tsb_start;\n\n\tvoid __iomem\t\t*db_addr;\n\tu64\t\t\tdb_phys_addr;\n\tu32\t\t\tdb_size;\n\tu16\t\t\tdpi;\n\n\tunion ib_gid *sgid_tbl;\n\n\t \n\tspinlock_t sgid_lock;\n\n\tu64\t\t\tguid;\n\n\tu32\t\t\tdp_module;\n\tu8\t\t\tdp_level;\n\tu8\t\t\tnum_hwfns;\n#define QEDR_IS_CMT(dev)        ((dev)->num_hwfns > 1)\n\tu8\t\t\taffin_hwfn_idx;\n\tu8\t\t\tgsi_ll2_handle;\n\n\tuint\t\t\twq_multiplier;\n\tu8\t\t\tgsi_ll2_mac_address[ETH_ALEN];\n\tint\t\t\tgsi_qp_created;\n\tstruct qedr_cq\t\t*gsi_sqcq;\n\tstruct qedr_cq\t\t*gsi_rqcq;\n\tstruct qedr_qp\t\t*gsi_qp;\n\tenum qed_rdma_type\trdma_type;\n\tstruct xarray\t\tqps;\n\tstruct xarray\t\tsrqs;\n\tstruct workqueue_struct *iwarp_wq;\n\tu16\t\t\tiwarp_max_mtu;\n\n\tunsigned long enet_state;\n\n\tu8 user_dpm_enabled;\n};\n\n#define QEDR_MAX_SQ_PBL\t\t\t(0x8000)\n#define QEDR_MAX_SQ_PBL_ENTRIES\t\t(0x10000 / sizeof(void *))\n#define QEDR_SQE_ELEMENT_SIZE\t\t(sizeof(struct rdma_sq_sge))\n#define QEDR_MAX_SQE_ELEMENTS_PER_SQE\t(ROCE_REQ_MAX_SINGLE_SQ_WQE_SIZE / \\\n\t\t\t\t\t QEDR_SQE_ELEMENT_SIZE)\n#define QEDR_MAX_SQE_ELEMENTS_PER_PAGE\t((RDMA_RING_PAGE_SIZE) / \\\n\t\t\t\t\t QEDR_SQE_ELEMENT_SIZE)\n#define QEDR_MAX_SQE\t\t\t((QEDR_MAX_SQ_PBL_ENTRIES) *\\\n\t\t\t\t\t (RDMA_RING_PAGE_SIZE) / \\\n\t\t\t\t\t (QEDR_SQE_ELEMENT_SIZE) /\\\n\t\t\t\t\t (QEDR_MAX_SQE_ELEMENTS_PER_SQE))\n \n#define QEDR_MAX_RQ_PBL\t\t\t(0x2000)\n#define QEDR_MAX_RQ_PBL_ENTRIES\t\t(0x10000 / sizeof(void *))\n#define QEDR_RQE_ELEMENT_SIZE\t\t(sizeof(struct rdma_rq_sge))\n#define QEDR_MAX_RQE_ELEMENTS_PER_RQE\t(RDMA_MAX_SGE_PER_RQ_WQE)\n#define QEDR_MAX_RQE_ELEMENTS_PER_PAGE\t((RDMA_RING_PAGE_SIZE) / \\\n\t\t\t\t\t QEDR_RQE_ELEMENT_SIZE)\n#define QEDR_MAX_RQE\t\t\t((QEDR_MAX_RQ_PBL_ENTRIES) *\\\n\t\t\t\t\t (RDMA_RING_PAGE_SIZE) / \\\n\t\t\t\t\t (QEDR_RQE_ELEMENT_SIZE) /\\\n\t\t\t\t\t (QEDR_MAX_RQE_ELEMENTS_PER_RQE))\n\n#define QEDR_CQE_SIZE\t(sizeof(union rdma_cqe))\n#define QEDR_MAX_CQE_PBL_SIZE (512 * 1024)\n#define QEDR_MAX_CQE_PBL_ENTRIES (((QEDR_MAX_CQE_PBL_SIZE) / \\\n\t\t\t\t  sizeof(u64)) - 1)\n#define QEDR_MAX_CQES ((u32)((QEDR_MAX_CQE_PBL_ENTRIES) * \\\n\t\t\t     (QED_CHAIN_PAGE_SIZE) / QEDR_CQE_SIZE))\n\n#define QEDR_ROCE_MAX_CNQ_SIZE\t\t(0x4000)\n\n#define QEDR_MAX_PORT\t\t\t(1)\n#define QEDR_PORT\t\t\t(1)\n\n#define QEDR_UVERBS(CMD_NAME) (1ull << IB_USER_VERBS_CMD_##CMD_NAME)\n\n#define QEDR_ROCE_PKEY_MAX 1\n#define QEDR_ROCE_PKEY_TABLE_LEN 1\n#define QEDR_ROCE_PKEY_DEFAULT 0xffff\n\nstruct qedr_pbl {\n\tstruct list_head list_entry;\n\tvoid *va;\n\tdma_addr_t pa;\n};\n\nstruct qedr_ucontext {\n\tstruct ib_ucontext ibucontext;\n\tstruct qedr_dev *dev;\n\tstruct qedr_pd *pd;\n\tvoid __iomem *dpi_addr;\n\tstruct rdma_user_mmap_entry *db_mmap_entry;\n\tu64 dpi_phys_addr;\n\tu32 dpi_size;\n\tu16 dpi;\n\tbool db_rec;\n\tu8 edpm_mode;\n};\n\nunion db_prod32 {\n\tstruct rdma_pwm_val16_data data;\n\tu32 raw;\n};\n\nunion db_prod64 {\n\tstruct rdma_pwm_val32_data data;\n\tu64 raw;\n};\n\nenum qedr_cq_type {\n\tQEDR_CQ_TYPE_GSI,\n\tQEDR_CQ_TYPE_KERNEL,\n\tQEDR_CQ_TYPE_USER,\n};\n\nstruct qedr_pbl_info {\n\tu32 num_pbls;\n\tu32 num_pbes;\n\tu32 pbl_size;\n\tu32 pbe_size;\n\tbool two_layered;\n};\n\nstruct qedr_userq {\n\tstruct ib_umem *umem;\n\tstruct qedr_pbl_info pbl_info;\n\tstruct qedr_pbl *pbl_tbl;\n\tu64 buf_addr;\n\tsize_t buf_len;\n\n\t \n\tvoid __iomem *db_addr;\n\tstruct qedr_user_db_rec *db_rec_data;\n\tstruct rdma_user_mmap_entry *db_mmap_entry;\n\tvoid __iomem *db_rec_db2_addr;\n\tunion db_prod32 db_rec_db2_data;\n};\n\nstruct qedr_cq {\n\tstruct ib_cq ibcq;\n\n\tenum qedr_cq_type cq_type;\n\tu32 sig;\n\n\tu16 icid;\n\n\t \n\tspinlock_t cq_lock;\n\tu8 arm_flags;\n\tstruct qed_chain pbl;\n\n\tvoid __iomem *db_addr;\n\tunion db_prod64 db;\n\n\tu8 pbl_toggle;\n\tunion rdma_cqe *latest_cqe;\n\tunion rdma_cqe *toggle_cqe;\n\n\tu32 cq_cons;\n\n\tstruct qedr_userq q;\n\tu8 destroyed;\n\tu16 cnq_notif;\n};\n\nstruct qedr_pd {\n\tstruct ib_pd ibpd;\n\tu32 pd_id;\n\tstruct qedr_ucontext *uctx;\n};\n\nstruct qedr_xrcd {\n\tstruct ib_xrcd ibxrcd;\n\tu16 xrcd_id;\n};\n\nstruct qedr_qp_hwq_info {\n\t \n\tstruct qed_chain pbl;\n\tu64 p_phys_addr_tbl;\n\tu32 max_sges;\n\n\t \n\tu16 prod;\n\tu16 cons;\n\tu16 wqe_cons;\n\tu16 gsi_cons;\n\tu16 max_wr;\n\n\t \n\tvoid __iomem *db;\n\tunion db_prod32 db_data;\n\n\tvoid __iomem *iwarp_db2;\n\tunion db_prod32 iwarp_db2_data;\n};\n\n#define QEDR_INC_SW_IDX(p_info, index)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tp_info->index = (p_info->index + 1) &\t\t\t\\\n\t\t\t\tqed_chain_get_capacity(p_info->pbl)\t\\\n\t} while (0)\n\nstruct qedr_srq_hwq_info {\n\tu32 max_sges;\n\tu32 max_wr;\n\tstruct qed_chain pbl;\n\tu64 p_phys_addr_tbl;\n\tu32 wqe_prod;\n\tu32 sge_prod;\n\tu32 wr_prod_cnt;\n\tatomic_t wr_cons_cnt;\n\tu32 num_elems;\n\n\tstruct rdma_srq_producers *virt_prod_pair_addr;\n\tdma_addr_t phy_prod_pair_addr;\n};\n\nstruct qedr_srq {\n\tstruct ib_srq ibsrq;\n\tstruct qedr_dev *dev;\n\n\tstruct qedr_userq\tusrq;\n\tstruct qedr_srq_hwq_info hw_srq;\n\tstruct ib_umem *prod_umem;\n\tu16 srq_id;\n\tu32 srq_limit;\n\tbool is_xrc;\n\t \n\tspinlock_t lock;\n};\n\nenum qedr_qp_err_bitmap {\n\tQEDR_QP_ERR_SQ_FULL = 1,\n\tQEDR_QP_ERR_RQ_FULL = 2,\n\tQEDR_QP_ERR_BAD_SR = 4,\n\tQEDR_QP_ERR_BAD_RR = 8,\n\tQEDR_QP_ERR_SQ_PBL_FULL = 16,\n\tQEDR_QP_ERR_RQ_PBL_FULL = 32,\n};\n\nenum qedr_qp_create_type {\n\tQEDR_QP_CREATE_NONE,\n\tQEDR_QP_CREATE_USER,\n\tQEDR_QP_CREATE_KERNEL,\n};\n\nenum qedr_iwarp_cm_flags {\n\tQEDR_IWARP_CM_WAIT_FOR_CONNECT    = BIT(0),\n\tQEDR_IWARP_CM_WAIT_FOR_DISCONNECT = BIT(1),\n};\n\nstruct qedr_qp {\n\tstruct ib_qp ibqp;\t \n\tstruct qedr_dev *dev;\n\tstruct qedr_qp_hwq_info sq;\n\tstruct qedr_qp_hwq_info rq;\n\n\tu32 max_inline_data;\n\n\t \n\tspinlock_t q_lock;\n\tstruct qedr_cq *sq_cq;\n\tstruct qedr_cq *rq_cq;\n\tstruct qedr_srq *srq;\n\tenum qed_roce_qp_state state;\n\tu32 id;\n\tstruct qedr_pd *pd;\n\tenum ib_qp_type qp_type;\n\tenum qedr_qp_create_type create_type;\n\tstruct qed_rdma_qp *qed_qp;\n\tu32 qp_id;\n\tu16 icid;\n\tu16 mtu;\n\tint sgid_idx;\n\tu32 rq_psn;\n\tu32 sq_psn;\n\tu32 qkey;\n\tu32 dest_qp_num;\n\tu8 timeout;\n\n\t \n\tu8 prev_wqe_size;\n\tu16 wqe_cons;\n\tu32 err_bitmap;\n\tbool signaled;\n\n\t \n\tstruct {\n\t\tu64 wr_id;\n\t\tenum ib_wc_opcode opcode;\n\t\tu32 bytes_len;\n\t\tu8 wqe_size;\n\t\tbool signaled;\n\t\tdma_addr_t icrc_mapping;\n\t\tu32 *icrc;\n\t\tstruct qedr_mr *mr;\n\t} *wqe_wr_id;\n\n\t \n\tstruct {\n\t\tu64 wr_id;\n\t\tstruct ib_sge sg_list[RDMA_MAX_SGE_PER_RQ_WQE];\n\t\tu8 wqe_size;\n\n\t\tu8 smac[ETH_ALEN];\n\t\tu16 vlan;\n\t\tint rc;\n\t} *rqe_wr_id;\n\n\t \n\tstruct qedr_userq usq;\n\tstruct qedr_userq urq;\n\n\t \n\tstruct kref refcnt;\n\tstruct completion iwarp_cm_comp;\n\tstruct completion qp_rel_comp;\n\tunsigned long iwarp_cm_flags;  \n};\n\nstruct qedr_ah {\n\tstruct ib_ah ibah;\n\tstruct rdma_ah_attr attr;\n};\n\nenum qedr_mr_type {\n\tQEDR_MR_USER,\n\tQEDR_MR_KERNEL,\n\tQEDR_MR_DMA,\n\tQEDR_MR_FRMR,\n};\n\nstruct mr_info {\n\tstruct qedr_pbl *pbl_table;\n\tstruct qedr_pbl_info pbl_info;\n\tstruct list_head free_pbl_list;\n\tstruct list_head inuse_pbl_list;\n\tu32 completed;\n\tu32 completed_handled;\n};\n\nstruct qedr_mr {\n\tstruct ib_mr ibmr;\n\tstruct ib_umem *umem;\n\n\tstruct qed_rdma_register_tid_in_params hw_mr;\n\tenum qedr_mr_type type;\n\n\tstruct qedr_dev *dev;\n\tstruct mr_info info;\n\n\tu64 *pages;\n\tu32 npages;\n};\n\nstruct qedr_user_mmap_entry {\n\tstruct rdma_user_mmap_entry rdma_entry;\n\tstruct qedr_dev *dev;\n\tunion {\n\t\tu64 io_address;\n\t\tvoid *address;\n\t};\n\tsize_t length;\n\tu16 dpi;\n\tu8 mmap_flag;\n};\n\n#define SET_FIELD2(value, name, flag) ((value) |= ((flag) << (name ## _SHIFT)))\n\n#define QEDR_RESP_IMM\t(RDMA_CQE_RESPONDER_IMM_FLG_MASK << \\\n\t\t\t RDMA_CQE_RESPONDER_IMM_FLG_SHIFT)\n#define QEDR_RESP_RDMA\t(RDMA_CQE_RESPONDER_RDMA_FLG_MASK << \\\n\t\t\t RDMA_CQE_RESPONDER_RDMA_FLG_SHIFT)\n#define QEDR_RESP_INV\t(RDMA_CQE_RESPONDER_INV_FLG_MASK << \\\n\t\t\t RDMA_CQE_RESPONDER_INV_FLG_SHIFT)\n\nstatic inline void qedr_inc_sw_cons(struct qedr_qp_hwq_info *info)\n{\n\tinfo->cons = (info->cons + 1) % info->max_wr;\n\tinfo->wqe_cons++;\n}\n\nstatic inline void qedr_inc_sw_prod(struct qedr_qp_hwq_info *info)\n{\n\tinfo->prod = (info->prod + 1) % info->max_wr;\n}\n\nstatic inline int qedr_get_dmac(struct qedr_dev *dev,\n\t\t\t\tstruct rdma_ah_attr *ah_attr, u8 *mac_addr)\n{\n\tunion ib_gid zero_sgid = { { 0 } };\n\tstruct in6_addr in6;\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\tu8 *dmac;\n\n\tif (!memcmp(&grh->dgid, &zero_sgid, sizeof(union ib_gid))) {\n\t\tDP_ERR(dev, \"Local port GID not supported\\n\");\n\t\teth_zero_addr(mac_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(&in6, grh->dgid.raw, sizeof(in6));\n\tdmac = rdma_ah_retrieve_dmac(ah_attr);\n\tif (!dmac)\n\t\treturn -EINVAL;\n\tether_addr_copy(mac_addr, dmac);\n\n\treturn 0;\n}\n\nstruct qedr_iw_listener {\n\tstruct qedr_dev *dev;\n\tstruct iw_cm_id *cm_id;\n\tint\t\tbacklog;\n\tvoid\t\t*qed_handle;\n};\n\nstruct qedr_iw_ep {\n\tstruct qedr_dev\t*dev;\n\tstruct iw_cm_id\t*cm_id;\n\tstruct qedr_qp\t*qp;\n\tvoid\t\t*qed_context;\n\tstruct kref\trefcnt;\n};\n\nstatic inline\nstruct qedr_ucontext *get_qedr_ucontext(struct ib_ucontext *ibucontext)\n{\n\treturn container_of(ibucontext, struct qedr_ucontext, ibucontext);\n}\n\nstatic inline struct qedr_dev *get_qedr_dev(struct ib_device *ibdev)\n{\n\treturn container_of(ibdev, struct qedr_dev, ibdev);\n}\n\nstatic inline struct qedr_pd *get_qedr_pd(struct ib_pd *ibpd)\n{\n\treturn container_of(ibpd, struct qedr_pd, ibpd);\n}\n\nstatic inline struct qedr_xrcd *get_qedr_xrcd(struct ib_xrcd *ibxrcd)\n{\n\treturn container_of(ibxrcd, struct qedr_xrcd, ibxrcd);\n}\n\nstatic inline struct qedr_cq *get_qedr_cq(struct ib_cq *ibcq)\n{\n\treturn container_of(ibcq, struct qedr_cq, ibcq);\n}\n\nstatic inline struct qedr_qp *get_qedr_qp(struct ib_qp *ibqp)\n{\n\treturn container_of(ibqp, struct qedr_qp, ibqp);\n}\n\nstatic inline struct qedr_ah *get_qedr_ah(struct ib_ah *ibah)\n{\n\treturn container_of(ibah, struct qedr_ah, ibah);\n}\n\nstatic inline struct qedr_mr *get_qedr_mr(struct ib_mr *ibmr)\n{\n\treturn container_of(ibmr, struct qedr_mr, ibmr);\n}\n\nstatic inline struct qedr_srq *get_qedr_srq(struct ib_srq *ibsrq)\n{\n\treturn container_of(ibsrq, struct qedr_srq, ibsrq);\n}\n\nstatic inline bool qedr_qp_has_srq(struct qedr_qp *qp)\n{\n\treturn qp->srq;\n}\n\nstatic inline bool qedr_qp_has_sq(struct qedr_qp *qp)\n{\n\tif (qp->qp_type == IB_QPT_GSI || qp->qp_type == IB_QPT_XRC_TGT)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline bool qedr_qp_has_rq(struct qedr_qp *qp)\n{\n\tif (qp->qp_type == IB_QPT_GSI || qp->qp_type == IB_QPT_XRC_INI ||\n\t    qp->qp_type == IB_QPT_XRC_TGT || qedr_qp_has_srq(qp))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic inline struct qedr_user_mmap_entry *\nget_qedr_mmap_entry(struct rdma_user_mmap_entry *rdma_entry)\n{\n\treturn container_of(rdma_entry, struct qedr_user_mmap_entry,\n\t\t\t    rdma_entry);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}