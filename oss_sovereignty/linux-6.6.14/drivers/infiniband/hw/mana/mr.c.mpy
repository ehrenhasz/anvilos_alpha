{
  "module_name": "mr.c",
  "hash_id": "2d25d6bac70e3dadf35ddf9e24aa552a0c1db19cef0b559144d1fc92e31d5473",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mana/mr.c",
  "human_readable_source": "\n \n\n#include \"mana_ib.h\"\n\n#define VALID_MR_FLAGS                                                         \\\n\t(IB_ACCESS_LOCAL_WRITE | IB_ACCESS_REMOTE_WRITE | IB_ACCESS_REMOTE_READ)\n\nstatic enum gdma_mr_access_flags\nmana_ib_verbs_to_gdma_access_flags(int access_flags)\n{\n\tenum gdma_mr_access_flags flags = GDMA_ACCESS_FLAG_LOCAL_READ;\n\n\tif (access_flags & IB_ACCESS_LOCAL_WRITE)\n\t\tflags |= GDMA_ACCESS_FLAG_LOCAL_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\tflags |= GDMA_ACCESS_FLAG_REMOTE_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_READ)\n\t\tflags |= GDMA_ACCESS_FLAG_REMOTE_READ;\n\n\treturn flags;\n}\n\nstatic int mana_ib_gd_create_mr(struct mana_ib_dev *dev, struct mana_ib_mr *mr,\n\t\t\t\tstruct gdma_create_mr_params *mr_params)\n{\n\tstruct gdma_create_mr_response resp = {};\n\tstruct gdma_create_mr_request req = {};\n\tstruct gdma_dev *mdev = dev->gdma_dev;\n\tstruct gdma_context *gc;\n\tint err;\n\n\tgc = mdev->gdma_context;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_CREATE_MR, sizeof(req),\n\t\t\t     sizeof(resp));\n\treq.pd_handle = mr_params->pd_handle;\n\treq.mr_type = mr_params->mr_type;\n\n\tswitch (mr_params->mr_type) {\n\tcase GDMA_MR_TYPE_GVA:\n\t\treq.gva.dma_region_handle = mr_params->gva.dma_region_handle;\n\t\treq.gva.virtual_address = mr_params->gva.virtual_address;\n\t\treq.gva.access_flags = mr_params->gva.access_flags;\n\t\tbreak;\n\n\tdefault:\n\t\tibdev_dbg(&dev->ib_dev,\n\t\t\t  \"invalid param (GDMA_MR_TYPE) passed, type %d\\n\",\n\t\t\t  req.mr_type);\n\t\treturn -EINVAL;\n\t}\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\n\tif (err || resp.hdr.status) {\n\t\tibdev_dbg(&dev->ib_dev, \"Failed to create mr %d, %u\", err,\n\t\t\t  resp.hdr.status);\n\t\tif (!err)\n\t\t\terr = -EPROTO;\n\n\t\treturn err;\n\t}\n\n\tmr->ibmr.lkey = resp.lkey;\n\tmr->ibmr.rkey = resp.rkey;\n\tmr->mr_handle = resp.mr_handle;\n\n\treturn 0;\n}\n\nstatic int mana_ib_gd_destroy_mr(struct mana_ib_dev *dev, u64 mr_handle)\n{\n\tstruct gdma_destroy_mr_response resp = {};\n\tstruct gdma_destroy_mr_request req = {};\n\tstruct gdma_dev *mdev = dev->gdma_dev;\n\tstruct gdma_context *gc;\n\tint err;\n\n\tgc = mdev->gdma_context;\n\n\tmana_gd_init_req_hdr(&req.hdr, GDMA_DESTROY_MR, sizeof(req),\n\t\t\t     sizeof(resp));\n\n\treq.mr_handle = mr_handle;\n\n\terr = mana_gd_send_request(gc, sizeof(req), &req, sizeof(resp), &resp);\n\tif (err || resp.hdr.status) {\n\t\tdev_err(gc->dev, \"Failed to destroy MR: %d, 0x%x\\n\", err,\n\t\t\tresp.hdr.status);\n\t\tif (!err)\n\t\t\terr = -EPROTO;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstruct ib_mr *mana_ib_reg_user_mr(struct ib_pd *ibpd, u64 start, u64 length,\n\t\t\t\t  u64 iova, int access_flags,\n\t\t\t\t  struct ib_udata *udata)\n{\n\tstruct mana_ib_pd *pd = container_of(ibpd, struct mana_ib_pd, ibpd);\n\tstruct gdma_create_mr_params mr_params = {};\n\tstruct ib_device *ibdev = ibpd->device;\n\tstruct mana_ib_dev *dev;\n\tstruct mana_ib_mr *mr;\n\tu64 dma_region_handle;\n\tint err;\n\n\tdev = container_of(ibdev, struct mana_ib_dev, ib_dev);\n\n\tibdev_dbg(ibdev,\n\t\t  \"start 0x%llx, iova 0x%llx length 0x%llx access_flags 0x%x\",\n\t\t  start, iova, length, access_flags);\n\n\tif (access_flags & ~VALID_MR_FLAGS)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmr = kzalloc(sizeof(*mr), GFP_KERNEL);\n\tif (!mr)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmr->umem = ib_umem_get(ibdev, start, length, access_flags);\n\tif (IS_ERR(mr->umem)) {\n\t\terr = PTR_ERR(mr->umem);\n\t\tibdev_dbg(ibdev,\n\t\t\t  \"Failed to get umem for register user-mr, %d\\n\", err);\n\t\tgoto err_free;\n\t}\n\n\terr = mana_ib_gd_create_dma_region(dev, mr->umem, &dma_region_handle);\n\tif (err) {\n\t\tibdev_dbg(ibdev, \"Failed create dma region for user-mr, %d\\n\",\n\t\t\t  err);\n\t\tgoto err_umem;\n\t}\n\n\tibdev_dbg(ibdev,\n\t\t  \"mana_ib_gd_create_dma_region ret %d gdma_region %llx\\n\", err,\n\t\t  dma_region_handle);\n\n\tmr_params.pd_handle = pd->pd_handle;\n\tmr_params.mr_type = GDMA_MR_TYPE_GVA;\n\tmr_params.gva.dma_region_handle = dma_region_handle;\n\tmr_params.gva.virtual_address = iova;\n\tmr_params.gva.access_flags =\n\t\tmana_ib_verbs_to_gdma_access_flags(access_flags);\n\n\terr = mana_ib_gd_create_mr(dev, mr, &mr_params);\n\tif (err)\n\t\tgoto err_dma_region;\n\n\t \n\n\treturn &mr->ibmr;\n\nerr_dma_region:\n\tmana_gd_destroy_dma_region(dev->gdma_dev->gdma_context,\n\t\t\t\t   dma_region_handle);\n\nerr_umem:\n\tib_umem_release(mr->umem);\n\nerr_free:\n\tkfree(mr);\n\treturn ERR_PTR(err);\n}\n\nint mana_ib_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata)\n{\n\tstruct mana_ib_mr *mr = container_of(ibmr, struct mana_ib_mr, ibmr);\n\tstruct ib_device *ibdev = ibmr->device;\n\tstruct mana_ib_dev *dev;\n\tint err;\n\n\tdev = container_of(ibdev, struct mana_ib_dev, ib_dev);\n\n\terr = mana_ib_gd_destroy_mr(dev, mr->mr_handle);\n\tif (err)\n\t\treturn err;\n\n\tif (mr->umem)\n\t\tib_umem_release(mr->umem);\n\n\tkfree(mr);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}