{
  "module_name": "hns_roce_db.c",
  "hash_id": "8da6c84a257c50f3940035f94b343fba9209d792475e28c982618042f50e8d5f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hns/hns_roce_db.c",
  "human_readable_source": " \n \n\n#include <rdma/ib_umem.h>\n#include \"hns_roce_device.h\"\n\nint hns_roce_db_map_user(struct hns_roce_ucontext *context, unsigned long virt,\n\t\t\t struct hns_roce_db *db)\n{\n\tunsigned long page_addr = virt & PAGE_MASK;\n\tstruct hns_roce_user_db_page *page;\n\tunsigned int offset;\n\tint ret = 0;\n\n\tmutex_lock(&context->page_mutex);\n\n\tlist_for_each_entry(page, &context->page_list, list)\n\t\tif (page->user_virt == page_addr)\n\t\t\tgoto found;\n\n\tpage = kmalloc(sizeof(*page), GFP_KERNEL);\n\tif (!page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trefcount_set(&page->refcount, 1);\n\tpage->user_virt = page_addr;\n\tpage->umem = ib_umem_get(context->ibucontext.device, page_addr,\n\t\t\t\t PAGE_SIZE, 0);\n\tif (IS_ERR(page->umem)) {\n\t\tret = PTR_ERR(page->umem);\n\t\tkfree(page);\n\t\tgoto out;\n\t}\n\n\tlist_add(&page->list, &context->page_list);\n\nfound:\n\toffset = virt - page_addr;\n\tdb->dma = sg_dma_address(page->umem->sgt_append.sgt.sgl) + offset;\n\tdb->virt_addr = sg_virt(page->umem->sgt_append.sgt.sgl) + offset;\n\tdb->u.user_page = page;\n\trefcount_inc(&page->refcount);\n\nout:\n\tmutex_unlock(&context->page_mutex);\n\n\treturn ret;\n}\n\nvoid hns_roce_db_unmap_user(struct hns_roce_ucontext *context,\n\t\t\t    struct hns_roce_db *db)\n{\n\tmutex_lock(&context->page_mutex);\n\n\trefcount_dec(&db->u.user_page->refcount);\n\tif (refcount_dec_if_one(&db->u.user_page->refcount)) {\n\t\tlist_del(&db->u.user_page->list);\n\t\tib_umem_release(db->u.user_page->umem);\n\t\tkfree(db->u.user_page);\n\t}\n\n\tmutex_unlock(&context->page_mutex);\n}\n\nstatic struct hns_roce_db_pgdir *hns_roce_alloc_db_pgdir(\n\t\t\t\t\tstruct device *dma_device)\n{\n\tstruct hns_roce_db_pgdir *pgdir;\n\n\tpgdir = kzalloc(sizeof(*pgdir), GFP_KERNEL);\n\tif (!pgdir)\n\t\treturn NULL;\n\n\tbitmap_fill(pgdir->order1,\n\t\t    HNS_ROCE_DB_PER_PAGE / HNS_ROCE_DB_TYPE_COUNT);\n\tpgdir->bits[0] = pgdir->order0;\n\tpgdir->bits[1] = pgdir->order1;\n\tpgdir->page = dma_alloc_coherent(dma_device, PAGE_SIZE,\n\t\t\t\t\t &pgdir->db_dma, GFP_KERNEL);\n\tif (!pgdir->page) {\n\t\tkfree(pgdir);\n\t\treturn NULL;\n\t}\n\n\treturn pgdir;\n}\n\nstatic int hns_roce_alloc_db_from_pgdir(struct hns_roce_db_pgdir *pgdir,\n\t\t\t\t\tstruct hns_roce_db *db, int order)\n{\n\tunsigned long o;\n\tunsigned long i;\n\n\tfor (o = order; o <= 1; ++o) {\n\t\ti = find_first_bit(pgdir->bits[o], HNS_ROCE_DB_PER_PAGE >> o);\n\t\tif (i < HNS_ROCE_DB_PER_PAGE >> o)\n\t\t\tgoto found;\n\t}\n\n\treturn -ENOMEM;\n\nfound:\n\tclear_bit(i, pgdir->bits[o]);\n\n\ti <<= o;\n\n\tif (o > order)\n\t\tset_bit(i ^ 1, pgdir->bits[order]);\n\n\tdb->u.pgdir\t= pgdir;\n\tdb->index\t= i;\n\tdb->db_record\t= pgdir->page + db->index;\n\tdb->dma\t\t= pgdir->db_dma  + db->index * HNS_ROCE_DB_UNIT_SIZE;\n\tdb->order\t= order;\n\n\treturn 0;\n}\n\nint hns_roce_alloc_db(struct hns_roce_dev *hr_dev, struct hns_roce_db *db,\n\t\t      int order)\n{\n\tstruct hns_roce_db_pgdir *pgdir;\n\tint ret = 0;\n\n\tmutex_lock(&hr_dev->pgdir_mutex);\n\n\tlist_for_each_entry(pgdir, &hr_dev->pgdir_list, list)\n\t\tif (!hns_roce_alloc_db_from_pgdir(pgdir, db, order))\n\t\t\tgoto out;\n\n\tpgdir = hns_roce_alloc_db_pgdir(hr_dev->dev);\n\tif (!pgdir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tlist_add(&pgdir->list, &hr_dev->pgdir_list);\n\n\t \n\tWARN_ON(hns_roce_alloc_db_from_pgdir(pgdir, db, order));\n\nout:\n\tmutex_unlock(&hr_dev->pgdir_mutex);\n\n\treturn ret;\n}\n\nvoid hns_roce_free_db(struct hns_roce_dev *hr_dev, struct hns_roce_db *db)\n{\n\tunsigned long o;\n\tunsigned long i;\n\n\tmutex_lock(&hr_dev->pgdir_mutex);\n\n\to = db->order;\n\ti = db->index;\n\n\tif (db->order == 0 && test_bit(i ^ 1, db->u.pgdir->order0)) {\n\t\tclear_bit(i ^ 1, db->u.pgdir->order0);\n\t\t++o;\n\t}\n\n\ti >>= o;\n\tset_bit(i, db->u.pgdir->bits[o]);\n\n\tif (bitmap_full(db->u.pgdir->order1,\n\t\t\tHNS_ROCE_DB_PER_PAGE / HNS_ROCE_DB_TYPE_COUNT)) {\n\t\tdma_free_coherent(hr_dev->dev, PAGE_SIZE, db->u.pgdir->page,\n\t\t\t\t  db->u.pgdir->db_dma);\n\t\tlist_del(&db->u.pgdir->list);\n\t\tkfree(db->u.pgdir);\n\t}\n\n\tmutex_unlock(&hr_dev->pgdir_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}