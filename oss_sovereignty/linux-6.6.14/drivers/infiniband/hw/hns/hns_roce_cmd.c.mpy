{
  "module_name": "hns_roce_cmd.c",
  "hash_id": "e0faaee84673ac00c1d202c5c74efd6aa49fc6f571e8a7a18065ac33985758f6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hns/hns_roce_cmd.c",
  "human_readable_source": " \n\n#include <linux/dmapool.h>\n#include \"hns_roce_common.h\"\n#include \"hns_roce_device.h\"\n#include \"hns_roce_cmd.h\"\n\n#define CMD_POLL_TOKEN 0xffff\n#define CMD_MAX_NUM 32\n\nstatic int hns_roce_cmd_mbox_post_hw(struct hns_roce_dev *hr_dev,\n\t\t\t\t     struct hns_roce_mbox_msg *mbox_msg)\n{\n\treturn hr_dev->hw->post_mbox(hr_dev, mbox_msg);\n}\n\n \nstatic int __hns_roce_cmd_mbox_poll(struct hns_roce_dev *hr_dev,\n\t\t\t\t    struct hns_roce_mbox_msg *mbox_msg)\n{\n\tint ret;\n\n\tret = hns_roce_cmd_mbox_post_hw(hr_dev, mbox_msg);\n\tif (ret) {\n\t\tdev_err_ratelimited(hr_dev->dev,\n\t\t\t\t    \"failed to post mailbox 0x%x in poll mode, ret = %d.\\n\",\n\t\t\t\t    mbox_msg->cmd, ret);\n\t\treturn ret;\n\t}\n\n\treturn hr_dev->hw->poll_mbox_done(hr_dev);\n}\n\nstatic int hns_roce_cmd_mbox_poll(struct hns_roce_dev *hr_dev,\n\t\t\t\t  struct hns_roce_mbox_msg *mbox_msg)\n{\n\tint ret;\n\n\tdown(&hr_dev->cmd.poll_sem);\n\tret = __hns_roce_cmd_mbox_poll(hr_dev, mbox_msg);\n\tup(&hr_dev->cmd.poll_sem);\n\n\treturn ret;\n}\n\nvoid hns_roce_cmd_event(struct hns_roce_dev *hr_dev, u16 token, u8 status,\n\t\t\tu64 out_param)\n{\n\tstruct hns_roce_cmd_context *context =\n\t\t&hr_dev->cmd.context[token % hr_dev->cmd.max_cmds];\n\n\tif (unlikely(token != context->token)) {\n\t\tdev_err_ratelimited(hr_dev->dev,\n\t\t\t\t    \"[cmd] invalid ae token 0x%x, context token is 0x%x.\\n\",\n\t\t\t\t    token, context->token);\n\t\treturn;\n\t}\n\n\tcontext->result = (status == HNS_ROCE_CMD_SUCCESS) ? 0 : (-EIO);\n\tcontext->out_param = out_param;\n\tcomplete(&context->done);\n}\n\nstatic int __hns_roce_cmd_mbox_wait(struct hns_roce_dev *hr_dev,\n\t\t\t\t    struct hns_roce_mbox_msg *mbox_msg)\n{\n\tstruct hns_roce_cmdq *cmd = &hr_dev->cmd;\n\tstruct hns_roce_cmd_context *context;\n\tstruct device *dev = hr_dev->dev;\n\tint ret;\n\n\tspin_lock(&cmd->context_lock);\n\n\tdo {\n\t\tcontext = &cmd->context[cmd->free_head];\n\t\tcmd->free_head = context->next;\n\t} while (context->busy);\n\n\tcontext->busy = 1;\n\tcontext->token += cmd->max_cmds;\n\n\tspin_unlock(&cmd->context_lock);\n\n\treinit_completion(&context->done);\n\n\tmbox_msg->token = context->token;\n\tret = hns_roce_cmd_mbox_post_hw(hr_dev, mbox_msg);\n\tif (ret) {\n\t\tdev_err_ratelimited(dev,\n\t\t\t\t    \"failed to post mailbox 0x%x in event mode, ret = %d.\\n\",\n\t\t\t\t    mbox_msg->cmd, ret);\n\t\tgoto out;\n\t}\n\n\tif (!wait_for_completion_timeout(&context->done,\n\t\t\t\tmsecs_to_jiffies(HNS_ROCE_CMD_TIMEOUT_MSECS))) {\n\t\tdev_err_ratelimited(dev, \"[cmd] token 0x%x mailbox 0x%x timeout.\\n\",\n\t\t\t\t    context->token, mbox_msg->cmd);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = context->result;\n\tif (ret)\n\t\tdev_err_ratelimited(dev, \"[cmd] token 0x%x mailbox 0x%x error %d.\\n\",\n\t\t\t\t    context->token, mbox_msg->cmd, ret);\n\nout:\n\tcontext->busy = 0;\n\treturn ret;\n}\n\nstatic int hns_roce_cmd_mbox_wait(struct hns_roce_dev *hr_dev,\n\t\t\t\t  struct hns_roce_mbox_msg *mbox_msg)\n{\n\tint ret;\n\n\tdown(&hr_dev->cmd.event_sem);\n\tret = __hns_roce_cmd_mbox_wait(hr_dev, mbox_msg);\n\tup(&hr_dev->cmd.event_sem);\n\n\treturn ret;\n}\n\nint hns_roce_cmd_mbox(struct hns_roce_dev *hr_dev, u64 in_param, u64 out_param,\n\t\t      u8 cmd, unsigned long tag)\n{\n\tstruct hns_roce_mbox_msg mbox_msg = {};\n\tbool is_busy;\n\n\tif (hr_dev->hw->chk_mbox_avail)\n\t\tif (!hr_dev->hw->chk_mbox_avail(hr_dev, &is_busy))\n\t\t\treturn is_busy ? -EBUSY : 0;\n\n\tmbox_msg.in_param = in_param;\n\tmbox_msg.out_param = out_param;\n\tmbox_msg.cmd = cmd;\n\tmbox_msg.tag = tag;\n\n\tif (hr_dev->cmd.use_events) {\n\t\tmbox_msg.event_en = 1;\n\n\t\treturn hns_roce_cmd_mbox_wait(hr_dev, &mbox_msg);\n\t} else {\n\t\tmbox_msg.event_en = 0;\n\t\tmbox_msg.token = CMD_POLL_TOKEN;\n\n\t\treturn hns_roce_cmd_mbox_poll(hr_dev, &mbox_msg);\n\t}\n}\n\nint hns_roce_cmd_init(struct hns_roce_dev *hr_dev)\n{\n\tsema_init(&hr_dev->cmd.poll_sem, 1);\n\thr_dev->cmd.use_events = 0;\n\thr_dev->cmd.max_cmds = CMD_MAX_NUM;\n\thr_dev->cmd.pool = dma_pool_create(\"hns_roce_cmd\", hr_dev->dev,\n\t\t\t\t\t   HNS_ROCE_MAILBOX_SIZE,\n\t\t\t\t\t   HNS_ROCE_MAILBOX_SIZE, 0);\n\tif (!hr_dev->cmd.pool)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid hns_roce_cmd_cleanup(struct hns_roce_dev *hr_dev)\n{\n\tdma_pool_destroy(hr_dev->cmd.pool);\n}\n\nint hns_roce_cmd_use_events(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_cmdq *hr_cmd = &hr_dev->cmd;\n\tint i;\n\n\thr_cmd->context =\n\t\tkcalloc(hr_cmd->max_cmds, sizeof(*hr_cmd->context), GFP_KERNEL);\n\tif (!hr_cmd->context) {\n\t\thr_dev->cmd_mod = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < hr_cmd->max_cmds; ++i) {\n\t\thr_cmd->context[i].token = i;\n\t\thr_cmd->context[i].next = i + 1;\n\t\tinit_completion(&hr_cmd->context[i].done);\n\t}\n\thr_cmd->context[hr_cmd->max_cmds - 1].next = 0;\n\thr_cmd->free_head = 0;\n\n\tsema_init(&hr_cmd->event_sem, hr_cmd->max_cmds);\n\tspin_lock_init(&hr_cmd->context_lock);\n\n\thr_cmd->use_events = 1;\n\n\treturn 0;\n}\n\nvoid hns_roce_cmd_use_polling(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_cmdq *hr_cmd = &hr_dev->cmd;\n\n\tkfree(hr_cmd->context);\n\thr_cmd->use_events = 0;\n}\n\nstruct hns_roce_cmd_mailbox *\nhns_roce_alloc_cmd_mailbox(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_cmd_mailbox *mailbox;\n\n\tmailbox = kmalloc(sizeof(*mailbox), GFP_KERNEL);\n\tif (!mailbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmailbox->buf =\n\t\tdma_pool_alloc(hr_dev->cmd.pool, GFP_KERNEL, &mailbox->dma);\n\tif (!mailbox->buf) {\n\t\tkfree(mailbox);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mailbox;\n}\n\nvoid hns_roce_free_cmd_mailbox(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_cmd_mailbox *mailbox)\n{\n\tif (!mailbox)\n\t\treturn;\n\n\tdma_pool_free(hr_dev->cmd.pool, mailbox->buf, mailbox->dma);\n\tkfree(mailbox);\n}\n\nint hns_roce_create_hw_ctx(struct hns_roce_dev *dev,\n\t\t\t   struct hns_roce_cmd_mailbox *mailbox,\n\t\t\t   u8 cmd, unsigned long idx)\n{\n\treturn hns_roce_cmd_mbox(dev, mailbox->dma, 0, cmd, idx);\n}\n\nint hns_roce_destroy_hw_ctx(struct hns_roce_dev *dev, u8 cmd, unsigned long idx)\n{\n\treturn hns_roce_cmd_mbox(dev, 0, 0, cmd, idx);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}