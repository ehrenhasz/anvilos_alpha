{
  "module_name": "hns_roce_hem.h",
  "hash_id": "de9df10f768df7b8b3d242402950b622a7cd2f64365bf7d46fc64249813e51b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hns/hns_roce_hem.h",
  "human_readable_source": " \n\n#ifndef _HNS_ROCE_HEM_H\n#define _HNS_ROCE_HEM_H\n\n#define HEM_HOP_STEP_DIRECT 0xff\n\nenum {\n\t \n\tHEM_TYPE_QPC = 0,\n\tHEM_TYPE_MTPT,\n\tHEM_TYPE_CQC,\n\tHEM_TYPE_SRQC,\n\tHEM_TYPE_SCCC,\n\tHEM_TYPE_QPC_TIMER,\n\tHEM_TYPE_CQC_TIMER,\n\tHEM_TYPE_GMV,\n\n\t  \n\tHEM_TYPE_MTT,\n\tHEM_TYPE_CQE,\n\tHEM_TYPE_SRQWQE,\n\tHEM_TYPE_IDX,\n\tHEM_TYPE_IRRL,\n\tHEM_TYPE_TRRL,\n};\n\n#define HNS_ROCE_HEM_CHUNK_LEN\t\\\n\t ((256 - sizeof(struct list_head) - 2 * sizeof(int)) /\t \\\n\t (sizeof(struct scatterlist) + sizeof(void *)))\n\n#define check_whether_bt_num_3(type, hop_num) \\\n\t(type < HEM_TYPE_MTT && hop_num == 2)\n\n#define check_whether_bt_num_2(type, hop_num) \\\n\t((type < HEM_TYPE_MTT && hop_num == 1) || \\\n\t(type >= HEM_TYPE_MTT && hop_num == 2))\n\n#define check_whether_bt_num_1(type, hop_num) \\\n\t((type < HEM_TYPE_MTT && hop_num == HNS_ROCE_HOP_NUM_0) || \\\n\t(type >= HEM_TYPE_MTT && hop_num == 1) || \\\n\t(type >= HEM_TYPE_MTT && hop_num == HNS_ROCE_HOP_NUM_0))\n\nstruct hns_roce_hem_chunk {\n\tstruct list_head\t list;\n\tint\t\t\t npages;\n\tint\t\t\t nsg;\n\tstruct scatterlist\t mem[HNS_ROCE_HEM_CHUNK_LEN];\n\tvoid\t\t\t *buf[HNS_ROCE_HEM_CHUNK_LEN];\n};\n\nstruct hns_roce_hem {\n\tstruct list_head chunk_list;\n\trefcount_t refcount;\n};\n\nstruct hns_roce_hem_iter {\n\tstruct hns_roce_hem\t\t *hem;\n\tstruct hns_roce_hem_chunk\t *chunk;\n\tint\t\t\t\t page_idx;\n};\n\nstruct hns_roce_hem_mhop {\n\tu32\thop_num;\n\tu32\tbuf_chunk_size;\n\tu32\tbt_chunk_size;\n\tu32\tba_l0_num;\n\tu32\tl0_idx;  \n\tu32\tl1_idx;  \n\tu32\tl2_idx;  \n};\n\nvoid hns_roce_free_hem(struct hns_roce_dev *hr_dev, struct hns_roce_hem *hem);\nint hns_roce_table_get(struct hns_roce_dev *hr_dev,\n\t\t       struct hns_roce_hem_table *table, unsigned long obj);\nvoid hns_roce_table_put(struct hns_roce_dev *hr_dev,\n\t\t\tstruct hns_roce_hem_table *table, unsigned long obj);\nvoid *hns_roce_table_find(struct hns_roce_dev *hr_dev,\n\t\t\t  struct hns_roce_hem_table *table, unsigned long obj,\n\t\t\t  dma_addr_t *dma_handle);\nint hns_roce_init_hem_table(struct hns_roce_dev *hr_dev,\n\t\t\t    struct hns_roce_hem_table *table, u32 type,\n\t\t\t    unsigned long obj_size, unsigned long nobj);\nvoid hns_roce_cleanup_hem_table(struct hns_roce_dev *hr_dev,\n\t\t\t\tstruct hns_roce_hem_table *table);\nvoid hns_roce_cleanup_hem(struct hns_roce_dev *hr_dev);\nint hns_roce_calc_hem_mhop(struct hns_roce_dev *hr_dev,\n\t\t\t   struct hns_roce_hem_table *table, unsigned long *obj,\n\t\t\t   struct hns_roce_hem_mhop *mhop);\nbool hns_roce_check_whether_mhop(struct hns_roce_dev *hr_dev, u32 type);\n\nvoid hns_roce_hem_list_init(struct hns_roce_hem_list *hem_list);\nint hns_roce_hem_list_calc_root_ba(const struct hns_roce_buf_region *regions,\n\t\t\t\t   int region_cnt, int unit);\nint hns_roce_hem_list_request(struct hns_roce_dev *hr_dev,\n\t\t\t      struct hns_roce_hem_list *hem_list,\n\t\t\t      const struct hns_roce_buf_region *regions,\n\t\t\t      int region_cnt, unsigned int bt_pg_shift);\nvoid hns_roce_hem_list_release(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_hem_list *hem_list);\nvoid *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,\n\t\t\t\t struct hns_roce_hem_list *hem_list,\n\t\t\t\t int offset, int *mtt_cnt);\n\nstatic inline void hns_roce_hem_first(struct hns_roce_hem *hem,\n\t\t\t\t      struct hns_roce_hem_iter *iter)\n{\n\titer->hem = hem;\n\titer->chunk = list_empty(&hem->chunk_list) ? NULL :\n\t\t\t\t list_entry(hem->chunk_list.next,\n\t\t\t\t\t    struct hns_roce_hem_chunk, list);\n\titer->page_idx = 0;\n}\n\nstatic inline int hns_roce_hem_last(struct hns_roce_hem_iter *iter)\n{\n\treturn !iter->chunk;\n}\n\nstatic inline void hns_roce_hem_next(struct hns_roce_hem_iter *iter)\n{\n\tif (++iter->page_idx >= iter->chunk->nsg) {\n\t\tif (iter->chunk->list.next == &iter->hem->chunk_list) {\n\t\t\titer->chunk = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\titer->chunk = list_entry(iter->chunk->list.next,\n\t\t\t\t\t struct hns_roce_hem_chunk, list);\n\t\titer->page_idx = 0;\n\t}\n}\n\nstatic inline dma_addr_t hns_roce_hem_addr(struct hns_roce_hem_iter *iter)\n{\n\treturn sg_dma_address(&iter->chunk->mem[iter->page_idx]);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}