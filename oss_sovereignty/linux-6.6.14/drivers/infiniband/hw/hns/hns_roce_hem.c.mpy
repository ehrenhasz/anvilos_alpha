{
  "module_name": "hns_roce_hem.c",
  "hash_id": "838933a681e239a4d5f04e194c07c4096f0ce34250e14c13ef854bf50496caaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hns/hns_roce_hem.c",
  "human_readable_source": " \n\n#include \"hns_roce_device.h\"\n#include \"hns_roce_hem.h\"\n#include \"hns_roce_common.h\"\n\n#define HEM_INDEX_BUF\t\t\tBIT(0)\n#define HEM_INDEX_L0\t\t\tBIT(1)\n#define HEM_INDEX_L1\t\t\tBIT(2)\nstruct hns_roce_hem_index {\n\tu64 buf;\n\tu64 l0;\n\tu64 l1;\n\tu32 inited;  \n};\n\nbool hns_roce_check_whether_mhop(struct hns_roce_dev *hr_dev, u32 type)\n{\n\tint hop_num = 0;\n\n\tswitch (type) {\n\tcase HEM_TYPE_QPC:\n\t\thop_num = hr_dev->caps.qpc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_MTPT:\n\t\thop_num = hr_dev->caps.mpt_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_CQC:\n\t\thop_num = hr_dev->caps.cqc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_SRQC:\n\t\thop_num = hr_dev->caps.srqc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_SCCC:\n\t\thop_num = hr_dev->caps.sccc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_QPC_TIMER:\n\t\thop_num = hr_dev->caps.qpc_timer_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_CQC_TIMER:\n\t\thop_num = hr_dev->caps.cqc_timer_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_GMV:\n\t\thop_num = hr_dev->caps.gmv_hop_num;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn hop_num;\n}\n\nstatic bool hns_roce_check_hem_null(struct hns_roce_hem **hem, u64 hem_idx,\n\t\t\t\t    u32 bt_chunk_num, u64 hem_max_num)\n{\n\tu64 start_idx = round_down(hem_idx, bt_chunk_num);\n\tu64 check_max_num = start_idx + bt_chunk_num;\n\tu64 i;\n\n\tfor (i = start_idx; (i < check_max_num) && (i < hem_max_num); i++)\n\t\tif (i != hem_idx && hem[i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool hns_roce_check_bt_null(u64 **bt, u64 ba_idx, u32 bt_chunk_num)\n{\n\tu64 start_idx = round_down(ba_idx, bt_chunk_num);\n\tint i;\n\n\tfor (i = 0; i < bt_chunk_num; i++)\n\t\tif (i != ba_idx && bt[start_idx + i])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int hns_roce_get_bt_num(u32 table_type, u32 hop_num)\n{\n\tif (check_whether_bt_num_3(table_type, hop_num))\n\t\treturn 3;\n\telse if (check_whether_bt_num_2(table_type, hop_num))\n\t\treturn 2;\n\telse if (check_whether_bt_num_1(table_type, hop_num))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int get_hem_table_config(struct hns_roce_dev *hr_dev,\n\t\t\t\tstruct hns_roce_hem_mhop *mhop,\n\t\t\t\tu32 type)\n{\n\tstruct device *dev = hr_dev->dev;\n\n\tswitch (type) {\n\tcase HEM_TYPE_QPC:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.qpc_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.qpc_ba_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.qpc_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.qpc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_MTPT:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.mpt_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.mpt_ba_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.mpt_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.mpt_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_CQC:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.cqc_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.cqc_ba_pg_sz\n\t\t\t\t\t    + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.cqc_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.cqc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_SCCC:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.sccc_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.sccc_ba_pg_sz\n\t\t\t\t\t    + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.sccc_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.sccc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_QPC_TIMER:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.qpc_timer_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.qpc_timer_ba_pg_sz\n\t\t\t\t\t    + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.qpc_timer_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.qpc_timer_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_CQC_TIMER:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.cqc_timer_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.cqc_timer_ba_pg_sz\n\t\t\t\t\t    + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.cqc_timer_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.cqc_timer_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_SRQC:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.srqc_buf_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.srqc_ba_pg_sz\n\t\t\t\t\t     + PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.srqc_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.srqc_hop_num;\n\t\tbreak;\n\tcase HEM_TYPE_GMV:\n\t\tmhop->buf_chunk_size = 1 << (hr_dev->caps.gmv_buf_pg_sz +\n\t\t\t\t\t     PAGE_SHIFT);\n\t\tmhop->bt_chunk_size = 1 << (hr_dev->caps.gmv_ba_pg_sz +\n\t\t\t\t\t    PAGE_SHIFT);\n\t\tmhop->ba_l0_num = hr_dev->caps.gmv_bt_num;\n\t\tmhop->hop_num = hr_dev->caps.gmv_hop_num;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"table %u not support multi-hop addressing!\\n\",\n\t\t\ttype);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint hns_roce_calc_hem_mhop(struct hns_roce_dev *hr_dev,\n\t\t\t   struct hns_roce_hem_table *table, unsigned long *obj,\n\t\t\t   struct hns_roce_hem_mhop *mhop)\n{\n\tstruct device *dev = hr_dev->dev;\n\tu32 chunk_ba_num;\n\tu32 chunk_size;\n\tu32 table_idx;\n\tu32 bt_num;\n\n\tif (get_hem_table_config(hr_dev, mhop, table->type))\n\t\treturn -EINVAL;\n\n\tif (!obj)\n\t\treturn 0;\n\n\t \n\tbt_num = hns_roce_get_bt_num(table->type, mhop->hop_num);\n\tchunk_ba_num = mhop->bt_chunk_size / BA_BYTE_LEN;\n\tchunk_size = table->type < HEM_TYPE_MTT ? mhop->buf_chunk_size :\n\t\t\t      mhop->bt_chunk_size;\n\ttable_idx = *obj / (chunk_size / table->obj_size);\n\tswitch (bt_num) {\n\tcase 3:\n\t\tmhop->l2_idx = table_idx & (chunk_ba_num - 1);\n\t\tmhop->l1_idx = table_idx / chunk_ba_num & (chunk_ba_num - 1);\n\t\tmhop->l0_idx = (table_idx / chunk_ba_num) / chunk_ba_num;\n\t\tbreak;\n\tcase 2:\n\t\tmhop->l1_idx = table_idx & (chunk_ba_num - 1);\n\t\tmhop->l0_idx = table_idx / chunk_ba_num;\n\t\tbreak;\n\tcase 1:\n\t\tmhop->l0_idx = table_idx;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"table %u not support hop_num = %u!\\n\",\n\t\t\ttable->type, mhop->hop_num);\n\t\treturn -EINVAL;\n\t}\n\tif (mhop->l0_idx >= mhop->ba_l0_num)\n\t\tmhop->l0_idx %= mhop->ba_l0_num;\n\n\treturn 0;\n}\n\nstatic struct hns_roce_hem *hns_roce_alloc_hem(struct hns_roce_dev *hr_dev,\n\t\t\t\t\t       int npages,\n\t\t\t\t\t       unsigned long hem_alloc_size,\n\t\t\t\t\t       gfp_t gfp_mask)\n{\n\tstruct hns_roce_hem_chunk *chunk = NULL;\n\tstruct hns_roce_hem *hem;\n\tstruct scatterlist *mem;\n\tint order;\n\tvoid *buf;\n\n\tWARN_ON(gfp_mask & __GFP_HIGHMEM);\n\n\them = kmalloc(sizeof(*hem),\n\t\t      gfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN));\n\tif (!hem)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&hem->chunk_list);\n\n\torder = get_order(hem_alloc_size);\n\n\twhile (npages > 0) {\n\t\tif (!chunk) {\n\t\t\tchunk = kmalloc(sizeof(*chunk),\n\t\t\t\tgfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN));\n\t\t\tif (!chunk)\n\t\t\t\tgoto fail;\n\n\t\t\tsg_init_table(chunk->mem, HNS_ROCE_HEM_CHUNK_LEN);\n\t\t\tchunk->npages = 0;\n\t\t\tchunk->nsg = 0;\n\t\t\tmemset(chunk->buf, 0, sizeof(chunk->buf));\n\t\t\tlist_add_tail(&chunk->list, &hem->chunk_list);\n\t\t}\n\n\t\twhile (1 << order > npages)\n\t\t\t--order;\n\n\t\t \n\t\tmem = &chunk->mem[chunk->npages];\n\t\tbuf = dma_alloc_coherent(hr_dev->dev, PAGE_SIZE << order,\n\t\t\t\t&sg_dma_address(mem), gfp_mask);\n\t\tif (!buf)\n\t\t\tgoto fail;\n\n\t\tchunk->buf[chunk->npages] = buf;\n\t\tsg_dma_len(mem) = PAGE_SIZE << order;\n\n\t\t++chunk->npages;\n\t\t++chunk->nsg;\n\t\tnpages -= 1 << order;\n\t}\n\n\treturn hem;\n\nfail:\n\thns_roce_free_hem(hr_dev, hem);\n\treturn NULL;\n}\n\nvoid hns_roce_free_hem(struct hns_roce_dev *hr_dev, struct hns_roce_hem *hem)\n{\n\tstruct hns_roce_hem_chunk *chunk, *tmp;\n\tint i;\n\n\tif (!hem)\n\t\treturn;\n\n\tlist_for_each_entry_safe(chunk, tmp, &hem->chunk_list, list) {\n\t\tfor (i = 0; i < chunk->npages; ++i)\n\t\t\tdma_free_coherent(hr_dev->dev,\n\t\t\t\t   sg_dma_len(&chunk->mem[i]),\n\t\t\t\t   chunk->buf[i],\n\t\t\t\t   sg_dma_address(&chunk->mem[i]));\n\t\tkfree(chunk);\n\t}\n\n\tkfree(hem);\n}\n\nstatic int calc_hem_config(struct hns_roce_dev *hr_dev,\n\t\t\t   struct hns_roce_hem_table *table, unsigned long obj,\n\t\t\t   struct hns_roce_hem_mhop *mhop,\n\t\t\t   struct hns_roce_hem_index *index)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tunsigned long mhop_obj = obj;\n\tu32 l0_idx, l1_idx, l2_idx;\n\tu32 chunk_ba_num;\n\tu32 bt_num;\n\tint ret;\n\n\tret = hns_roce_calc_hem_mhop(hr_dev, table, &mhop_obj, mhop);\n\tif (ret)\n\t\treturn ret;\n\n\tl0_idx = mhop->l0_idx;\n\tl1_idx = mhop->l1_idx;\n\tl2_idx = mhop->l2_idx;\n\tchunk_ba_num = mhop->bt_chunk_size / BA_BYTE_LEN;\n\tbt_num = hns_roce_get_bt_num(table->type, mhop->hop_num);\n\tswitch (bt_num) {\n\tcase 3:\n\t\tindex->l1 = l0_idx * chunk_ba_num + l1_idx;\n\t\tindex->l0 = l0_idx;\n\t\tindex->buf = l0_idx * chunk_ba_num * chunk_ba_num +\n\t\t\t     l1_idx * chunk_ba_num + l2_idx;\n\t\tbreak;\n\tcase 2:\n\t\tindex->l0 = l0_idx;\n\t\tindex->buf = l0_idx * chunk_ba_num + l1_idx;\n\t\tbreak;\n\tcase 1:\n\t\tindex->buf = l0_idx;\n\t\tbreak;\n\tdefault:\n\t\tibdev_err(ibdev, \"table %u not support mhop.hop_num = %u!\\n\",\n\t\t\t  table->type, mhop->hop_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(index->buf >= table->num_hem)) {\n\t\tibdev_err(ibdev, \"table %u exceed hem limt idx %llu, max %lu!\\n\",\n\t\t\t  table->type, index->buf, table->num_hem);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_mhop_hem(struct hns_roce_dev *hr_dev,\n\t\t\t  struct hns_roce_hem_table *table,\n\t\t\t  struct hns_roce_hem_mhop *mhop,\n\t\t\t  struct hns_roce_hem_index *index)\n{\n\tu32 bt_size = mhop->bt_chunk_size;\n\tstruct device *dev = hr_dev->dev;\n\n\tif (index->inited & HEM_INDEX_BUF) {\n\t\thns_roce_free_hem(hr_dev, table->hem[index->buf]);\n\t\ttable->hem[index->buf] = NULL;\n\t}\n\n\tif (index->inited & HEM_INDEX_L1) {\n\t\tdma_free_coherent(dev, bt_size, table->bt_l1[index->l1],\n\t\t\t\t  table->bt_l1_dma_addr[index->l1]);\n\t\ttable->bt_l1[index->l1] = NULL;\n\t}\n\n\tif (index->inited & HEM_INDEX_L0) {\n\t\tdma_free_coherent(dev, bt_size, table->bt_l0[index->l0],\n\t\t\t\t  table->bt_l0_dma_addr[index->l0]);\n\t\ttable->bt_l0[index->l0] = NULL;\n\t}\n}\n\nstatic int alloc_mhop_hem(struct hns_roce_dev *hr_dev,\n\t\t\t  struct hns_roce_hem_table *table,\n\t\t\t  struct hns_roce_hem_mhop *mhop,\n\t\t\t  struct hns_roce_hem_index *index)\n{\n\tu32 bt_size = mhop->bt_chunk_size;\n\tstruct device *dev = hr_dev->dev;\n\tstruct hns_roce_hem_iter iter;\n\tgfp_t flag;\n\tu64 bt_ba;\n\tu32 size;\n\tint ret;\n\n\t \n\tif ((check_whether_bt_num_3(table->type, mhop->hop_num) ||\n\t     check_whether_bt_num_2(table->type, mhop->hop_num)) &&\n\t     !table->bt_l0[index->l0]) {\n\t\ttable->bt_l0[index->l0] = dma_alloc_coherent(dev, bt_size,\n\t\t\t\t\t    &table->bt_l0_dma_addr[index->l0],\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!table->bt_l0[index->l0]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tindex->inited |= HEM_INDEX_L0;\n\t}\n\n\t \n\tif (check_whether_bt_num_3(table->type, mhop->hop_num) &&\n\t    !table->bt_l1[index->l1])  {\n\t\ttable->bt_l1[index->l1] = dma_alloc_coherent(dev, bt_size,\n\t\t\t\t\t    &table->bt_l1_dma_addr[index->l1],\n\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!table->bt_l1[index->l1]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_alloc_hem;\n\t\t}\n\t\tindex->inited |= HEM_INDEX_L1;\n\t\t*(table->bt_l0[index->l0] + mhop->l1_idx) =\n\t\t\t\t\t       table->bt_l1_dma_addr[index->l1];\n\t}\n\n\t \n\tsize = table->type < HEM_TYPE_MTT ? mhop->buf_chunk_size : bt_size;\n\tflag = GFP_KERNEL | __GFP_NOWARN;\n\ttable->hem[index->buf] = hns_roce_alloc_hem(hr_dev, size >> PAGE_SHIFT,\n\t\t\t\t\t\t    size, flag);\n\tif (!table->hem[index->buf]) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc_hem;\n\t}\n\n\tindex->inited |= HEM_INDEX_BUF;\n\thns_roce_hem_first(table->hem[index->buf], &iter);\n\tbt_ba = hns_roce_hem_addr(&iter);\n\tif (table->type < HEM_TYPE_MTT) {\n\t\tif (mhop->hop_num == 2)\n\t\t\t*(table->bt_l1[index->l1] + mhop->l2_idx) = bt_ba;\n\t\telse if (mhop->hop_num == 1)\n\t\t\t*(table->bt_l0[index->l0] + mhop->l1_idx) = bt_ba;\n\t} else if (mhop->hop_num == 2) {\n\t\t*(table->bt_l0[index->l0] + mhop->l1_idx) = bt_ba;\n\t}\n\n\treturn 0;\nerr_alloc_hem:\n\tfree_mhop_hem(hr_dev, table, mhop, index);\nout:\n\treturn ret;\n}\n\nstatic int set_mhop_hem(struct hns_roce_dev *hr_dev,\n\t\t\tstruct hns_roce_hem_table *table, unsigned long obj,\n\t\t\tstruct hns_roce_hem_mhop *mhop,\n\t\t\tstruct hns_roce_hem_index *index)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tu32 step_idx;\n\tint ret = 0;\n\n\tif (index->inited & HEM_INDEX_L0) {\n\t\tret = hr_dev->hw->set_hem(hr_dev, table, obj, 0);\n\t\tif (ret) {\n\t\t\tibdev_err(ibdev, \"set HEM step 0 failed!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (index->inited & HEM_INDEX_L1) {\n\t\tret = hr_dev->hw->set_hem(hr_dev, table, obj, 1);\n\t\tif (ret) {\n\t\t\tibdev_err(ibdev, \"set HEM step 1 failed!\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (index->inited & HEM_INDEX_BUF) {\n\t\tif (mhop->hop_num == HNS_ROCE_HOP_NUM_0)\n\t\t\tstep_idx = 0;\n\t\telse\n\t\t\tstep_idx = mhop->hop_num;\n\t\tret = hr_dev->hw->set_hem(hr_dev, table, obj, step_idx);\n\t\tif (ret)\n\t\t\tibdev_err(ibdev, \"set HEM step last failed!\\n\");\n\t}\nout:\n\treturn ret;\n}\n\nstatic int hns_roce_table_mhop_get(struct hns_roce_dev *hr_dev,\n\t\t\t\t   struct hns_roce_hem_table *table,\n\t\t\t\t   unsigned long obj)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tstruct hns_roce_hem_index index = {};\n\tstruct hns_roce_hem_mhop mhop = {};\n\tint ret;\n\n\tret = calc_hem_config(hr_dev, table, obj, &mhop, &index);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"calc hem config failed!\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&table->mutex);\n\tif (table->hem[index.buf]) {\n\t\trefcount_inc(&table->hem[index.buf]->refcount);\n\t\tgoto out;\n\t}\n\n\tret = alloc_mhop_hem(hr_dev, table, &mhop, &index);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"alloc mhop hem failed!\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (table->type < HEM_TYPE_MTT) {\n\t\tret = set_mhop_hem(hr_dev, table, obj, &mhop, &index);\n\t\tif (ret) {\n\t\t\tibdev_err(ibdev, \"set HEM address to HW failed!\\n\");\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\trefcount_set(&table->hem[index.buf]->refcount, 1);\n\tgoto out;\n\nerr_alloc:\n\tfree_mhop_hem(hr_dev, table, &mhop, &index);\nout:\n\tmutex_unlock(&table->mutex);\n\treturn ret;\n}\n\nint hns_roce_table_get(struct hns_roce_dev *hr_dev,\n\t\t       struct hns_roce_hem_table *table, unsigned long obj)\n{\n\tstruct device *dev = hr_dev->dev;\n\tunsigned long i;\n\tint ret = 0;\n\n\tif (hns_roce_check_whether_mhop(hr_dev, table->type))\n\t\treturn hns_roce_table_mhop_get(hr_dev, table, obj);\n\n\ti = obj / (table->table_chunk_size / table->obj_size);\n\n\tmutex_lock(&table->mutex);\n\n\tif (table->hem[i]) {\n\t\trefcount_inc(&table->hem[i]->refcount);\n\t\tgoto out;\n\t}\n\n\ttable->hem[i] = hns_roce_alloc_hem(hr_dev,\n\t\t\t\t       table->table_chunk_size >> PAGE_SHIFT,\n\t\t\t\t       table->table_chunk_size,\n\t\t\t\t       GFP_KERNEL | __GFP_NOWARN);\n\tif (!table->hem[i]) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tret = hr_dev->hw->set_hem(hr_dev, table, obj, HEM_HOP_STEP_DIRECT);\n\tif (ret) {\n\t\thns_roce_free_hem(hr_dev, table->hem[i]);\n\t\ttable->hem[i] = NULL;\n\t\tdev_err(dev, \"set HEM base address to HW failed, ret = %d.\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\trefcount_set(&table->hem[i]->refcount, 1);\nout:\n\tmutex_unlock(&table->mutex);\n\treturn ret;\n}\n\nstatic void clear_mhop_hem(struct hns_roce_dev *hr_dev,\n\t\t\t   struct hns_roce_hem_table *table, unsigned long obj,\n\t\t\t   struct hns_roce_hem_mhop *mhop,\n\t\t\t   struct hns_roce_hem_index *index)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tu32 hop_num = mhop->hop_num;\n\tu32 chunk_ba_num;\n\tu32 step_idx;\n\tint ret;\n\n\tindex->inited = HEM_INDEX_BUF;\n\tchunk_ba_num = mhop->bt_chunk_size / BA_BYTE_LEN;\n\tif (check_whether_bt_num_2(table->type, hop_num)) {\n\t\tif (hns_roce_check_hem_null(table->hem, index->buf,\n\t\t\t\t\t    chunk_ba_num, table->num_hem))\n\t\t\tindex->inited |= HEM_INDEX_L0;\n\t} else if (check_whether_bt_num_3(table->type, hop_num)) {\n\t\tif (hns_roce_check_hem_null(table->hem, index->buf,\n\t\t\t\t\t    chunk_ba_num, table->num_hem)) {\n\t\t\tindex->inited |= HEM_INDEX_L1;\n\t\t\tif (hns_roce_check_bt_null(table->bt_l1, index->l1,\n\t\t\t\t\t\t   chunk_ba_num))\n\t\t\t\tindex->inited |= HEM_INDEX_L0;\n\t\t}\n\t}\n\n\tif (table->type < HEM_TYPE_MTT) {\n\t\tif (hop_num == HNS_ROCE_HOP_NUM_0)\n\t\t\tstep_idx = 0;\n\t\telse\n\t\t\tstep_idx = hop_num;\n\n\t\tret = hr_dev->hw->clear_hem(hr_dev, table, obj, step_idx);\n\t\tif (ret)\n\t\t\tibdev_warn(ibdev, \"failed to clear hop%u HEM, ret = %d.\\n\",\n\t\t\t\t   hop_num, ret);\n\n\t\tif (index->inited & HEM_INDEX_L1) {\n\t\t\tret = hr_dev->hw->clear_hem(hr_dev, table, obj, 1);\n\t\t\tif (ret)\n\t\t\t\tibdev_warn(ibdev, \"failed to clear HEM step 1, ret = %d.\\n\",\n\t\t\t\t\t   ret);\n\t\t}\n\n\t\tif (index->inited & HEM_INDEX_L0) {\n\t\t\tret = hr_dev->hw->clear_hem(hr_dev, table, obj, 0);\n\t\t\tif (ret)\n\t\t\t\tibdev_warn(ibdev, \"failed to clear HEM step 0, ret = %d.\\n\",\n\t\t\t\t\t   ret);\n\t\t}\n\t}\n}\n\nstatic void hns_roce_table_mhop_put(struct hns_roce_dev *hr_dev,\n\t\t\t\t    struct hns_roce_hem_table *table,\n\t\t\t\t    unsigned long obj,\n\t\t\t\t    int check_refcount)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tstruct hns_roce_hem_index index = {};\n\tstruct hns_roce_hem_mhop mhop = {};\n\tint ret;\n\n\tret = calc_hem_config(hr_dev, table, obj, &mhop, &index);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"calc hem config failed!\\n\");\n\t\treturn;\n\t}\n\n\tif (!check_refcount)\n\t\tmutex_lock(&table->mutex);\n\telse if (!refcount_dec_and_mutex_lock(&table->hem[index.buf]->refcount,\n\t\t\t\t\t      &table->mutex))\n\t\treturn;\n\n\tclear_mhop_hem(hr_dev, table, obj, &mhop, &index);\n\tfree_mhop_hem(hr_dev, table, &mhop, &index);\n\n\tmutex_unlock(&table->mutex);\n}\n\nvoid hns_roce_table_put(struct hns_roce_dev *hr_dev,\n\t\t\tstruct hns_roce_hem_table *table, unsigned long obj)\n{\n\tstruct device *dev = hr_dev->dev;\n\tunsigned long i;\n\tint ret;\n\n\tif (hns_roce_check_whether_mhop(hr_dev, table->type)) {\n\t\thns_roce_table_mhop_put(hr_dev, table, obj, 1);\n\t\treturn;\n\t}\n\n\ti = obj / (table->table_chunk_size / table->obj_size);\n\n\tif (!refcount_dec_and_mutex_lock(&table->hem[i]->refcount,\n\t\t\t\t\t &table->mutex))\n\t\treturn;\n\n\tret = hr_dev->hw->clear_hem(hr_dev, table, obj, HEM_HOP_STEP_DIRECT);\n\tif (ret)\n\t\tdev_warn(dev, \"failed to clear HEM base address, ret = %d.\\n\",\n\t\t\t ret);\n\n\thns_roce_free_hem(hr_dev, table->hem[i]);\n\ttable->hem[i] = NULL;\n\n\tmutex_unlock(&table->mutex);\n}\n\nvoid *hns_roce_table_find(struct hns_roce_dev *hr_dev,\n\t\t\t  struct hns_roce_hem_table *table,\n\t\t\t  unsigned long obj, dma_addr_t *dma_handle)\n{\n\tstruct hns_roce_hem_chunk *chunk;\n\tstruct hns_roce_hem_mhop mhop;\n\tstruct hns_roce_hem *hem;\n\tunsigned long mhop_obj = obj;\n\tunsigned long obj_per_chunk;\n\tunsigned long idx_offset;\n\tint offset, dma_offset;\n\tvoid *addr = NULL;\n\tu32 hem_idx = 0;\n\tint length;\n\tint i, j;\n\n\tmutex_lock(&table->mutex);\n\n\tif (!hns_roce_check_whether_mhop(hr_dev, table->type)) {\n\t\tobj_per_chunk = table->table_chunk_size / table->obj_size;\n\t\them = table->hem[obj / obj_per_chunk];\n\t\tidx_offset = obj % obj_per_chunk;\n\t\tdma_offset = offset = idx_offset * table->obj_size;\n\t} else {\n\t\tu32 seg_size = 64;  \n\n\t\tif (hns_roce_calc_hem_mhop(hr_dev, table, &mhop_obj, &mhop))\n\t\t\tgoto out;\n\t\t \n\t\ti = mhop.l0_idx;\n\t\tj = mhop.l1_idx;\n\t\tif (mhop.hop_num == 2)\n\t\t\them_idx = i * (mhop.bt_chunk_size / BA_BYTE_LEN) + j;\n\t\telse if (mhop.hop_num == 1 ||\n\t\t\t mhop.hop_num == HNS_ROCE_HOP_NUM_0)\n\t\t\them_idx = i;\n\n\t\them = table->hem[hem_idx];\n\t\tdma_offset = offset = obj * seg_size % mhop.bt_chunk_size;\n\t\tif (mhop.hop_num == 2)\n\t\t\tdma_offset = offset = 0;\n\t}\n\n\tif (!hem)\n\t\tgoto out;\n\n\tlist_for_each_entry(chunk, &hem->chunk_list, list) {\n\t\tfor (i = 0; i < chunk->npages; ++i) {\n\t\t\tlength = sg_dma_len(&chunk->mem[i]);\n\t\t\tif (dma_handle && dma_offset >= 0) {\n\t\t\t\tif (length > (u32)dma_offset)\n\t\t\t\t\t*dma_handle = sg_dma_address(\n\t\t\t\t\t\t&chunk->mem[i]) + dma_offset;\n\t\t\t\tdma_offset -= length;\n\t\t\t}\n\n\t\t\tif (length > (u32)offset) {\n\t\t\t\taddr = chunk->buf[i] + offset;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset -= length;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&table->mutex);\n\treturn addr;\n}\n\nint hns_roce_init_hem_table(struct hns_roce_dev *hr_dev,\n\t\t\t    struct hns_roce_hem_table *table, u32 type,\n\t\t\t    unsigned long obj_size, unsigned long nobj)\n{\n\tunsigned long obj_per_chunk;\n\tunsigned long num_hem;\n\n\tif (!hns_roce_check_whether_mhop(hr_dev, type)) {\n\t\ttable->table_chunk_size = hr_dev->caps.chunk_sz;\n\t\tobj_per_chunk = table->table_chunk_size / obj_size;\n\t\tnum_hem = DIV_ROUND_UP(nobj, obj_per_chunk);\n\n\t\ttable->hem = kcalloc(num_hem, sizeof(*table->hem), GFP_KERNEL);\n\t\tif (!table->hem)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tstruct hns_roce_hem_mhop mhop = {};\n\t\tunsigned long buf_chunk_size;\n\t\tunsigned long bt_chunk_size;\n\t\tunsigned long bt_chunk_num;\n\t\tunsigned long num_bt_l0;\n\t\tu32 hop_num;\n\n\t\tif (get_hem_table_config(hr_dev, &mhop, type))\n\t\t\treturn -EINVAL;\n\n\t\tbuf_chunk_size = mhop.buf_chunk_size;\n\t\tbt_chunk_size = mhop.bt_chunk_size;\n\t\tnum_bt_l0 = mhop.ba_l0_num;\n\t\thop_num = mhop.hop_num;\n\n\t\tobj_per_chunk = buf_chunk_size / obj_size;\n\t\tnum_hem = DIV_ROUND_UP(nobj, obj_per_chunk);\n\t\tbt_chunk_num = bt_chunk_size / BA_BYTE_LEN;\n\n\t\tif (type >= HEM_TYPE_MTT)\n\t\t\tnum_bt_l0 = bt_chunk_num;\n\n\t\ttable->hem = kcalloc(num_hem, sizeof(*table->hem),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!table->hem)\n\t\t\tgoto err_kcalloc_hem_buf;\n\n\t\tif (check_whether_bt_num_3(type, hop_num)) {\n\t\t\tunsigned long num_bt_l1;\n\n\t\t\tnum_bt_l1 = DIV_ROUND_UP(num_hem, bt_chunk_num);\n\t\t\ttable->bt_l1 = kcalloc(num_bt_l1,\n\t\t\t\t\t       sizeof(*table->bt_l1),\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!table->bt_l1)\n\t\t\t\tgoto err_kcalloc_bt_l1;\n\n\t\t\ttable->bt_l1_dma_addr = kcalloc(num_bt_l1,\n\t\t\t\t\t\t sizeof(*table->bt_l1_dma_addr),\n\t\t\t\t\t\t GFP_KERNEL);\n\n\t\t\tif (!table->bt_l1_dma_addr)\n\t\t\t\tgoto err_kcalloc_l1_dma;\n\t\t}\n\n\t\tif (check_whether_bt_num_2(type, hop_num) ||\n\t\t\tcheck_whether_bt_num_3(type, hop_num)) {\n\t\t\ttable->bt_l0 = kcalloc(num_bt_l0, sizeof(*table->bt_l0),\n\t\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!table->bt_l0)\n\t\t\t\tgoto err_kcalloc_bt_l0;\n\n\t\t\ttable->bt_l0_dma_addr = kcalloc(num_bt_l0,\n\t\t\t\t\t\t sizeof(*table->bt_l0_dma_addr),\n\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!table->bt_l0_dma_addr)\n\t\t\t\tgoto err_kcalloc_l0_dma;\n\t\t}\n\t}\n\n\ttable->type = type;\n\ttable->num_hem = num_hem;\n\ttable->obj_size = obj_size;\n\tmutex_init(&table->mutex);\n\n\treturn 0;\n\nerr_kcalloc_l0_dma:\n\tkfree(table->bt_l0);\n\ttable->bt_l0 = NULL;\n\nerr_kcalloc_bt_l0:\n\tkfree(table->bt_l1_dma_addr);\n\ttable->bt_l1_dma_addr = NULL;\n\nerr_kcalloc_l1_dma:\n\tkfree(table->bt_l1);\n\ttable->bt_l1 = NULL;\n\nerr_kcalloc_bt_l1:\n\tkfree(table->hem);\n\ttable->hem = NULL;\n\nerr_kcalloc_hem_buf:\n\treturn -ENOMEM;\n}\n\nstatic void hns_roce_cleanup_mhop_hem_table(struct hns_roce_dev *hr_dev,\n\t\t\t\t\t    struct hns_roce_hem_table *table)\n{\n\tstruct hns_roce_hem_mhop mhop;\n\tu32 buf_chunk_size;\n\tu64 obj;\n\tint i;\n\n\tif (hns_roce_calc_hem_mhop(hr_dev, table, NULL, &mhop))\n\t\treturn;\n\tbuf_chunk_size = table->type < HEM_TYPE_MTT ? mhop.buf_chunk_size :\n\t\t\t\t\tmhop.bt_chunk_size;\n\n\tfor (i = 0; i < table->num_hem; ++i) {\n\t\tobj = i * buf_chunk_size / table->obj_size;\n\t\tif (table->hem[i])\n\t\t\thns_roce_table_mhop_put(hr_dev, table, obj, 0);\n\t}\n\n\tkfree(table->hem);\n\ttable->hem = NULL;\n\tkfree(table->bt_l1);\n\ttable->bt_l1 = NULL;\n\tkfree(table->bt_l1_dma_addr);\n\ttable->bt_l1_dma_addr = NULL;\n\tkfree(table->bt_l0);\n\ttable->bt_l0 = NULL;\n\tkfree(table->bt_l0_dma_addr);\n\ttable->bt_l0_dma_addr = NULL;\n}\n\nvoid hns_roce_cleanup_hem_table(struct hns_roce_dev *hr_dev,\n\t\t\t\tstruct hns_roce_hem_table *table)\n{\n\tstruct device *dev = hr_dev->dev;\n\tunsigned long i;\n\tint obj;\n\tint ret;\n\n\tif (hns_roce_check_whether_mhop(hr_dev, table->type)) {\n\t\thns_roce_cleanup_mhop_hem_table(hr_dev, table);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < table->num_hem; ++i)\n\t\tif (table->hem[i]) {\n\t\t\tobj = i * table->table_chunk_size / table->obj_size;\n\t\t\tret = hr_dev->hw->clear_hem(hr_dev, table, obj, 0);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev, \"clear HEM base address failed, ret = %d.\\n\",\n\t\t\t\t\tret);\n\n\t\t\thns_roce_free_hem(hr_dev, table->hem[i]);\n\t\t}\n\n\tkfree(table->hem);\n}\n\nvoid hns_roce_cleanup_hem(struct hns_roce_dev *hr_dev)\n{\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_SRQ)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->srq_table.table);\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->cq_table.table);\n\tif (hr_dev->caps.qpc_timer_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->qpc_timer_table);\n\tif (hr_dev->caps.cqc_timer_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->cqc_timer_table);\n\tif (hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_QP_FLOW_CTRL)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->qp_table.sccc_table);\n\tif (hr_dev->caps.trrl_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev,\n\t\t\t\t\t   &hr_dev->qp_table.trrl_table);\n\n\tif (hr_dev->caps.gmv_entry_sz)\n\t\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->gmv_table);\n\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.irrl_table);\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->qp_table.qp_table);\n\thns_roce_cleanup_hem_table(hr_dev, &hr_dev->mr_table.mtpt_table);\n}\n\nstruct hns_roce_hem_item {\n\tstruct list_head list;  \n\tstruct list_head sibling;  \n\tvoid *addr;\n\tdma_addr_t dma_addr;\n\tsize_t count;  \n\tint start;  \n\tint end;  \n};\n\n \nstruct hns_roce_hem_head {\n\tstruct list_head branch[HNS_ROCE_MAX_BT_REGION];\n\tstruct list_head root;\n\tstruct list_head leaf;\n};\n\nstatic struct hns_roce_hem_item *\nhem_list_alloc_item(struct hns_roce_dev *hr_dev, int start, int end, int count,\n\t\t    bool exist_bt)\n{\n\tstruct hns_roce_hem_item *hem;\n\n\them = kzalloc(sizeof(*hem), GFP_KERNEL);\n\tif (!hem)\n\t\treturn NULL;\n\n\tif (exist_bt) {\n\t\them->addr = dma_alloc_coherent(hr_dev->dev, count * BA_BYTE_LEN,\n\t\t\t\t\t       &hem->dma_addr, GFP_KERNEL);\n\t\tif (!hem->addr) {\n\t\t\tkfree(hem);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\them->count = count;\n\them->start = start;\n\them->end = end;\n\tINIT_LIST_HEAD(&hem->list);\n\tINIT_LIST_HEAD(&hem->sibling);\n\n\treturn hem;\n}\n\nstatic void hem_list_free_item(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_hem_item *hem, bool exist_bt)\n{\n\tif (exist_bt)\n\t\tdma_free_coherent(hr_dev->dev, hem->count * BA_BYTE_LEN,\n\t\t\t\t  hem->addr, hem->dma_addr);\n\tkfree(hem);\n}\n\nstatic void hem_list_free_all(struct hns_roce_dev *hr_dev,\n\t\t\t      struct list_head *head, bool exist_bt)\n{\n\tstruct hns_roce_hem_item *hem, *temp_hem;\n\n\tlist_for_each_entry_safe(hem, temp_hem, head, list) {\n\t\tlist_del(&hem->list);\n\t\them_list_free_item(hr_dev, hem, exist_bt);\n\t}\n}\n\nstatic void hem_list_link_bt(struct hns_roce_dev *hr_dev, void *base_addr,\n\t\t\t     u64 table_addr)\n{\n\t*(u64 *)(base_addr) = table_addr;\n}\n\n \nstatic void hem_list_assign_bt(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_hem_item *hem, void *cpu_addr,\n\t\t\t       u64 phy_addr)\n{\n\them->addr = cpu_addr;\n\them->dma_addr = (dma_addr_t)phy_addr;\n}\n\nstatic inline bool hem_list_page_is_in_range(struct hns_roce_hem_item *hem,\n\t\t\t\t\t     int offset)\n{\n\treturn (hem->start <= offset && offset <= hem->end);\n}\n\nstatic struct hns_roce_hem_item *hem_list_search_item(struct list_head *ba_list,\n\t\t\t\t\t\t      int page_offset)\n{\n\tstruct hns_roce_hem_item *hem, *temp_hem;\n\tstruct hns_roce_hem_item *found = NULL;\n\n\tlist_for_each_entry_safe(hem, temp_hem, ba_list, list) {\n\t\tif (hem_list_page_is_in_range(hem, page_offset)) {\n\t\t\tfound = hem;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}\n\nstatic bool hem_list_is_bottom_bt(int hopnum, int bt_level)\n{\n\t \n\treturn bt_level >= (hopnum ? hopnum - 1 : hopnum);\n}\n\n \nstatic u32 hem_list_calc_ba_range(int hopnum, int bt_level, int unit)\n{\n\tu32 step;\n\tint max;\n\tint i;\n\n\tif (hopnum <= bt_level)\n\t\treturn 0;\n\t \n\tstep = 1;\n\tmax = hopnum - bt_level;\n\tfor (i = 0; i < max; i++)\n\t\tstep = step * unit;\n\n\treturn step;\n}\n\n \nint hns_roce_hem_list_calc_root_ba(const struct hns_roce_buf_region *regions,\n\t\t\t\t   int region_cnt, int unit)\n{\n\tstruct hns_roce_buf_region *r;\n\tint total = 0;\n\tint step;\n\tint i;\n\n\tfor (i = 0; i < region_cnt; i++) {\n\t\tr = (struct hns_roce_buf_region *)&regions[i];\n\t\tif (r->hopnum > 1) {\n\t\t\tstep = hem_list_calc_ba_range(r->hopnum, 1, unit);\n\t\t\tif (step > 0)\n\t\t\t\ttotal += (r->count + step - 1) / step;\n\t\t} else {\n\t\t\ttotal += r->count;\n\t\t}\n\t}\n\n\treturn total;\n}\n\nstatic int hem_list_alloc_mid_bt(struct hns_roce_dev *hr_dev,\n\t\t\t\t const struct hns_roce_buf_region *r, int unit,\n\t\t\t\t int offset, struct list_head *mid_bt,\n\t\t\t\t struct list_head *btm_bt)\n{\n\tstruct hns_roce_hem_item *hem_ptrs[HNS_ROCE_MAX_BT_LEVEL] = { NULL };\n\tstruct list_head temp_list[HNS_ROCE_MAX_BT_LEVEL];\n\tstruct hns_roce_hem_item *cur, *pre;\n\tconst int hopnum = r->hopnum;\n\tint start_aligned;\n\tint distance;\n\tint ret = 0;\n\tint max_ofs;\n\tint level;\n\tu32 step;\n\tint end;\n\n\tif (hopnum <= 1)\n\t\treturn 0;\n\n\tif (hopnum > HNS_ROCE_MAX_BT_LEVEL) {\n\t\tdev_err(hr_dev->dev, \"invalid hopnum %d!\\n\", hopnum);\n\t\treturn -EINVAL;\n\t}\n\n\tif (offset < r->offset) {\n\t\tdev_err(hr_dev->dev, \"invalid offset %d, min %u!\\n\",\n\t\t\toffset, r->offset);\n\t\treturn -EINVAL;\n\t}\n\n\tdistance = offset - r->offset;\n\tmax_ofs = r->offset + r->count - 1;\n\tfor (level = 0; level < hopnum; level++)\n\t\tINIT_LIST_HEAD(&temp_list[level]);\n\n\t \n\tfor (level = 1; level < hopnum; level++) {\n\t\tcur = hem_list_search_item(&mid_bt[level], offset);\n\t\tif (cur) {\n\t\t\them_ptrs[level] = cur;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstep = hem_list_calc_ba_range(hopnum, level, unit);\n\t\tif (step < 1) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_exit;\n\t\t}\n\n\t\tstart_aligned = (distance / step) * step + r->offset;\n\t\tend = min_t(int, start_aligned + step - 1, max_ofs);\n\t\tcur = hem_list_alloc_item(hr_dev, start_aligned, end, unit,\n\t\t\t\t\t  true);\n\t\tif (!cur) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_exit;\n\t\t}\n\t\them_ptrs[level] = cur;\n\t\tlist_add(&cur->list, &temp_list[level]);\n\t\tif (hem_list_is_bottom_bt(hopnum, level))\n\t\t\tlist_add(&cur->sibling, &temp_list[0]);\n\n\t\t \n\t\tif (level > 1) {\n\t\t\tpre = hem_ptrs[level - 1];\n\t\t\tstep = (cur->start - pre->start) / step * BA_BYTE_LEN;\n\t\t\them_list_link_bt(hr_dev, pre->addr + step,\n\t\t\t\t\t cur->dma_addr);\n\t\t}\n\t}\n\n\tlist_splice(&temp_list[0], btm_bt);\n\tfor (level = 1; level < hopnum; level++)\n\t\tlist_splice(&temp_list[level], &mid_bt[level]);\n\n\treturn 0;\n\nerr_exit:\n\tfor (level = 1; level < hopnum; level++)\n\t\them_list_free_all(hr_dev, &temp_list[level], true);\n\n\treturn ret;\n}\n\nstatic struct hns_roce_hem_item *\nalloc_root_hem(struct hns_roce_dev *hr_dev, int unit, int *max_ba_num,\n\t       const struct hns_roce_buf_region *regions, int region_cnt)\n{\n\tconst struct hns_roce_buf_region *r;\n\tstruct hns_roce_hem_item *hem;\n\tint ba_num;\n\tint offset;\n\n\tba_num = hns_roce_hem_list_calc_root_ba(regions, region_cnt, unit);\n\tif (ba_num < 1)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (ba_num > unit)\n\t\treturn ERR_PTR(-ENOBUFS);\n\n\toffset = regions[0].offset;\n\t \n\tr = &regions[region_cnt - 1];\n\them = hem_list_alloc_item(hr_dev, offset, r->offset + r->count - 1,\n\t\t\t\t  ba_num, true);\n\tif (!hem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t*max_ba_num = ba_num;\n\n\treturn hem;\n}\n\nstatic int alloc_fake_root_bt(struct hns_roce_dev *hr_dev, void *cpu_base,\n\t\t\t      u64 phy_base, const struct hns_roce_buf_region *r,\n\t\t\t      struct list_head *branch_head,\n\t\t\t      struct list_head *leaf_head)\n{\n\tstruct hns_roce_hem_item *hem;\n\n\them = hem_list_alloc_item(hr_dev, r->offset, r->offset + r->count - 1,\n\t\t\t\t  r->count, false);\n\tif (!hem)\n\t\treturn -ENOMEM;\n\n\them_list_assign_bt(hr_dev, hem, cpu_base, phy_base);\n\tlist_add(&hem->list, branch_head);\n\tlist_add(&hem->sibling, leaf_head);\n\n\treturn r->count;\n}\n\nstatic int setup_middle_bt(struct hns_roce_dev *hr_dev, void *cpu_base,\n\t\t\t   int unit, const struct hns_roce_buf_region *r,\n\t\t\t   const struct list_head *branch_head)\n{\n\tstruct hns_roce_hem_item *hem, *temp_hem;\n\tint total = 0;\n\tint offset;\n\tint step;\n\n\tstep = hem_list_calc_ba_range(r->hopnum, 1, unit);\n\tif (step < 1)\n\t\treturn -EINVAL;\n\n\t \n\tlist_for_each_entry_safe(hem, temp_hem, branch_head, list) {\n\t\toffset = (hem->start - r->offset) / step * BA_BYTE_LEN;\n\t\them_list_link_bt(hr_dev, cpu_base + offset, hem->dma_addr);\n\t\ttotal++;\n\t}\n\n\treturn total;\n}\n\nstatic int\nsetup_root_hem(struct hns_roce_dev *hr_dev, struct hns_roce_hem_list *hem_list,\n\t       int unit, int max_ba_num, struct hns_roce_hem_head *head,\n\t       const struct hns_roce_buf_region *regions, int region_cnt)\n{\n\tconst struct hns_roce_buf_region *r;\n\tstruct hns_roce_hem_item *root_hem;\n\tvoid *cpu_base;\n\tu64 phy_base;\n\tint i, total;\n\tint ret;\n\n\troot_hem = list_first_entry(&head->root,\n\t\t\t\t    struct hns_roce_hem_item, list);\n\tif (!root_hem)\n\t\treturn -ENOMEM;\n\n\ttotal = 0;\n\tfor (i = 0; i < region_cnt && total < max_ba_num; i++) {\n\t\tr = &regions[i];\n\t\tif (!r->count)\n\t\t\tcontinue;\n\n\t\t \n\t\tcpu_base = root_hem->addr + total * BA_BYTE_LEN;\n\t\tphy_base = root_hem->dma_addr + total * BA_BYTE_LEN;\n\n\t\t \n\t\tif (hem_list_is_bottom_bt(r->hopnum, 0))\n\t\t\tret = alloc_fake_root_bt(hr_dev, cpu_base, phy_base, r,\n\t\t\t\t\t\t &head->branch[i], &head->leaf);\n\t\telse\n\t\t\tret = setup_middle_bt(hr_dev, cpu_base, unit, r,\n\t\t\t\t\t      &hem_list->mid_bt[i][1]);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttotal += ret;\n\t}\n\n\tlist_splice(&head->leaf, &hem_list->btm_bt);\n\tlist_splice(&head->root, &hem_list->root_bt);\n\tfor (i = 0; i < region_cnt; i++)\n\t\tlist_splice(&head->branch[i], &hem_list->mid_bt[i][0]);\n\n\treturn 0;\n}\n\nstatic int hem_list_alloc_root_bt(struct hns_roce_dev *hr_dev,\n\t\t\t\t  struct hns_roce_hem_list *hem_list, int unit,\n\t\t\t\t  const struct hns_roce_buf_region *regions,\n\t\t\t\t  int region_cnt)\n{\n\tstruct hns_roce_hem_item *root_hem;\n\tstruct hns_roce_hem_head head;\n\tint max_ba_num;\n\tint ret;\n\tint i;\n\n\troot_hem = hem_list_search_item(&hem_list->root_bt, regions[0].offset);\n\tif (root_hem)\n\t\treturn 0;\n\n\tmax_ba_num = 0;\n\troot_hem = alloc_root_hem(hr_dev, unit, &max_ba_num, regions,\n\t\t\t\t  region_cnt);\n\tif (IS_ERR(root_hem))\n\t\treturn PTR_ERR(root_hem);\n\n\t \n\tINIT_LIST_HEAD(&head.root);\n\tINIT_LIST_HEAD(&head.leaf);\n\tfor (i = 0; i < region_cnt; i++)\n\t\tINIT_LIST_HEAD(&head.branch[i]);\n\n\them_list->root_ba = root_hem->dma_addr;\n\tlist_add(&root_hem->list, &head.root);\n\tret = setup_root_hem(hr_dev, hem_list, unit, max_ba_num, &head, regions,\n\t\t\t     region_cnt);\n\tif (ret) {\n\t\tfor (i = 0; i < region_cnt; i++)\n\t\t\them_list_free_all(hr_dev, &head.branch[i], false);\n\n\t\them_list_free_all(hr_dev, &head.root, true);\n\t}\n\n\treturn ret;\n}\n\n \nint hns_roce_hem_list_request(struct hns_roce_dev *hr_dev,\n\t\t\t      struct hns_roce_hem_list *hem_list,\n\t\t\t      const struct hns_roce_buf_region *regions,\n\t\t\t      int region_cnt, unsigned int bt_pg_shift)\n{\n\tconst struct hns_roce_buf_region *r;\n\tint ofs, end;\n\tint unit;\n\tint ret;\n\tint i;\n\n\tif (region_cnt > HNS_ROCE_MAX_BT_REGION) {\n\t\tdev_err(hr_dev->dev, \"invalid region region_cnt %d!\\n\",\n\t\t\tregion_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tunit = (1 << bt_pg_shift) / BA_BYTE_LEN;\n\tfor (i = 0; i < region_cnt; i++) {\n\t\tr = &regions[i];\n\t\tif (!r->count)\n\t\t\tcontinue;\n\n\t\tend = r->offset + r->count;\n\t\tfor (ofs = r->offset; ofs < end; ofs += unit) {\n\t\t\tret = hem_list_alloc_mid_bt(hr_dev, r, unit, ofs,\n\t\t\t\t\t\t    hem_list->mid_bt[i],\n\t\t\t\t\t\t    &hem_list->btm_bt);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(hr_dev->dev,\n\t\t\t\t\t\"alloc hem trunk fail ret = %d!\\n\", ret);\n\t\t\t\tgoto err_alloc;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = hem_list_alloc_root_bt(hr_dev, hem_list, unit, regions,\n\t\t\t\t     region_cnt);\n\tif (ret)\n\t\tdev_err(hr_dev->dev, \"alloc hem root fail ret = %d!\\n\", ret);\n\telse\n\t\treturn 0;\n\nerr_alloc:\n\thns_roce_hem_list_release(hr_dev, hem_list);\n\n\treturn ret;\n}\n\nvoid hns_roce_hem_list_release(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_hem_list *hem_list)\n{\n\tint i, j;\n\n\tfor (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)\n\t\tfor (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)\n\t\t\them_list_free_all(hr_dev, &hem_list->mid_bt[i][j],\n\t\t\t\t\t  j != 0);\n\n\them_list_free_all(hr_dev, &hem_list->root_bt, true);\n\tINIT_LIST_HEAD(&hem_list->btm_bt);\n\them_list->root_ba = 0;\n}\n\nvoid hns_roce_hem_list_init(struct hns_roce_hem_list *hem_list)\n{\n\tint i, j;\n\n\tINIT_LIST_HEAD(&hem_list->root_bt);\n\tINIT_LIST_HEAD(&hem_list->btm_bt);\n\tfor (i = 0; i < HNS_ROCE_MAX_BT_REGION; i++)\n\t\tfor (j = 0; j < HNS_ROCE_MAX_BT_LEVEL; j++)\n\t\t\tINIT_LIST_HEAD(&hem_list->mid_bt[i][j]);\n}\n\nvoid *hns_roce_hem_list_find_mtt(struct hns_roce_dev *hr_dev,\n\t\t\t\t struct hns_roce_hem_list *hem_list,\n\t\t\t\t int offset, int *mtt_cnt)\n{\n\tstruct list_head *head = &hem_list->btm_bt;\n\tstruct hns_roce_hem_item *hem, *temp_hem;\n\tvoid *cpu_base = NULL;\n\tint nr = 0;\n\n\tlist_for_each_entry_safe(hem, temp_hem, head, sibling) {\n\t\tif (hem_list_page_is_in_range(hem, offset)) {\n\t\t\tnr = offset - hem->start;\n\t\t\tcpu_base = hem->addr + nr * BA_BYTE_LEN;\n\t\t\tnr = hem->end + 1 - offset;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (mtt_cnt)\n\t\t*mtt_cnt = nr;\n\n\treturn cpu_base;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}