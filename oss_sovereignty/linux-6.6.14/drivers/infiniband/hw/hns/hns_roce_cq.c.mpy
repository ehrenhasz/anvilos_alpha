{
  "module_name": "hns_roce_cq.c",
  "hash_id": "025e2bd5844e5dea41e8eabdcb5cc670a20db3df98004188b541594499758643",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/hns/hns_roce_cq.c",
  "human_readable_source": " \n\n#include <rdma/ib_umem.h>\n#include <rdma/uverbs_ioctl.h>\n#include \"hns_roce_device.h\"\n#include \"hns_roce_cmd.h\"\n#include \"hns_roce_hem.h\"\n#include \"hns_roce_common.h\"\n\nstatic u8 get_least_load_bankid_for_cq(struct hns_roce_bank *bank)\n{\n\tu32 least_load = bank[0].inuse;\n\tu8 bankid = 0;\n\tu32 bankcnt;\n\tu8 i;\n\n\tfor (i = 1; i < HNS_ROCE_CQ_BANK_NUM; i++) {\n\t\tbankcnt = bank[i].inuse;\n\t\tif (bankcnt < least_load) {\n\t\t\tleast_load = bankcnt;\n\t\t\tbankid = i;\n\t\t}\n\t}\n\n\treturn bankid;\n}\n\nstatic int alloc_cqn(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq)\n{\n\tstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\n\tstruct hns_roce_bank *bank;\n\tu8 bankid;\n\tint id;\n\n\tmutex_lock(&cq_table->bank_mutex);\n\tbankid = get_least_load_bankid_for_cq(cq_table->bank);\n\tbank = &cq_table->bank[bankid];\n\n\tid = ida_alloc_range(&bank->ida, bank->min, bank->max, GFP_KERNEL);\n\tif (id < 0) {\n\t\tmutex_unlock(&cq_table->bank_mutex);\n\t\treturn id;\n\t}\n\n\t \n\thr_cq->cqn = (id << CQ_BANKID_SHIFT) | bankid;\n\tbank->inuse++;\n\tmutex_unlock(&cq_table->bank_mutex);\n\n\treturn 0;\n}\n\nstatic inline u8 get_cq_bankid(unsigned long cqn)\n{\n\t \n\treturn (u8)(cqn & GENMASK(1, 0));\n}\n\nstatic void free_cqn(struct hns_roce_dev *hr_dev, unsigned long cqn)\n{\n\tstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\n\tstruct hns_roce_bank *bank;\n\n\tbank = &cq_table->bank[get_cq_bankid(cqn)];\n\n\tida_free(&bank->ida, cqn >> CQ_BANKID_SHIFT);\n\n\tmutex_lock(&cq_table->bank_mutex);\n\tbank->inuse--;\n\tmutex_unlock(&cq_table->bank_mutex);\n}\n\nstatic int hns_roce_create_cqc(struct hns_roce_dev *hr_dev,\n\t\t\t       struct hns_roce_cq *hr_cq,\n\t\t\t       u64 *mtts, dma_addr_t dma_handle)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tstruct hns_roce_cmd_mailbox *mailbox;\n\tint ret;\n\n\tmailbox = hns_roce_alloc_cmd_mailbox(hr_dev);\n\tif (IS_ERR(mailbox)) {\n\t\tibdev_err(ibdev, \"failed to alloc mailbox for CQC.\\n\");\n\t\treturn PTR_ERR(mailbox);\n\t}\n\n\thr_dev->hw->write_cqc(hr_dev, hr_cq, mailbox->buf, mtts, dma_handle);\n\n\tret = hns_roce_create_hw_ctx(hr_dev, mailbox, HNS_ROCE_CMD_CREATE_CQC,\n\t\t\t\t     hr_cq->cqn);\n\tif (ret)\n\t\tibdev_err(ibdev,\n\t\t\t  \"failed to send create cmd for CQ(0x%lx), ret = %d.\\n\",\n\t\t\t  hr_cq->cqn, ret);\n\n\thns_roce_free_cmd_mailbox(hr_dev, mailbox);\n\n\treturn ret;\n}\n\nstatic int alloc_cqc(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq)\n{\n\tstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tu64 mtts[MTT_MIN_COUNT] = {};\n\tdma_addr_t dma_handle;\n\tint ret;\n\n\tret = hns_roce_mtr_find(hr_dev, &hr_cq->mtr, 0, mtts, ARRAY_SIZE(mtts),\n\t\t\t\t&dma_handle);\n\tif (!ret) {\n\t\tibdev_err(ibdev, \"failed to find CQ mtr, ret = %d.\\n\", ret);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = hns_roce_table_get(hr_dev, &cq_table->table, hr_cq->cqn);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to get CQ(0x%lx) context, ret = %d.\\n\",\n\t\t\t  hr_cq->cqn, ret);\n\t\treturn ret;\n\t}\n\n\tret = xa_err(xa_store(&cq_table->array, hr_cq->cqn, hr_cq, GFP_KERNEL));\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to xa_store CQ, ret = %d.\\n\", ret);\n\t\tgoto err_put;\n\t}\n\n\tret = hns_roce_create_cqc(hr_dev, hr_cq, mtts, dma_handle);\n\tif (ret)\n\t\tgoto err_xa;\n\n\treturn 0;\n\nerr_xa:\n\txa_erase(&cq_table->array, hr_cq->cqn);\nerr_put:\n\thns_roce_table_put(hr_dev, &cq_table->table, hr_cq->cqn);\n\n\treturn ret;\n}\n\nstatic void free_cqc(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq)\n{\n\tstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\n\tstruct device *dev = hr_dev->dev;\n\tint ret;\n\n\tret = hns_roce_destroy_hw_ctx(hr_dev, HNS_ROCE_CMD_DESTROY_CQC,\n\t\t\t\t      hr_cq->cqn);\n\tif (ret)\n\t\tdev_err(dev, \"DESTROY_CQ failed (%d) for CQN %06lx\\n\", ret,\n\t\t\thr_cq->cqn);\n\n\txa_erase(&cq_table->array, hr_cq->cqn);\n\n\t \n\tsynchronize_irq(hr_dev->eq_table.eq[hr_cq->vector].irq);\n\n\t \n\tif (refcount_dec_and_test(&hr_cq->refcount))\n\t\tcomplete(&hr_cq->free);\n\twait_for_completion(&hr_cq->free);\n\n\thns_roce_table_put(hr_dev, &cq_table->table, hr_cq->cqn);\n}\n\nstatic int alloc_cq_buf(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq,\n\t\t\tstruct ib_udata *udata, unsigned long addr)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tstruct hns_roce_buf_attr buf_attr = {};\n\tint ret;\n\n\tbuf_attr.page_shift = hr_dev->caps.cqe_buf_pg_sz + PAGE_SHIFT;\n\tbuf_attr.region[0].size = hr_cq->cq_depth * hr_cq->cqe_size;\n\tbuf_attr.region[0].hopnum = hr_dev->caps.cqe_hop_num;\n\tbuf_attr.region_count = 1;\n\n\tret = hns_roce_mtr_create(hr_dev, &hr_cq->mtr, &buf_attr,\n\t\t\t\t  hr_dev->caps.cqe_ba_pg_sz + PAGE_SHIFT,\n\t\t\t\t  udata, addr);\n\tif (ret)\n\t\tibdev_err(ibdev, \"failed to alloc CQ mtr, ret = %d.\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void free_cq_buf(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq)\n{\n\thns_roce_mtr_destroy(hr_dev, &hr_cq->mtr);\n}\n\nstatic int alloc_cq_db(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq,\n\t\t       struct ib_udata *udata, unsigned long addr,\n\t\t       struct hns_roce_ib_create_cq_resp *resp)\n{\n\tbool has_db = hr_dev->caps.flags & HNS_ROCE_CAP_FLAG_CQ_RECORD_DB;\n\tstruct hns_roce_ucontext *uctx;\n\tint err;\n\n\tif (udata) {\n\t\tif (has_db &&\n\t\t    udata->outlen >= offsetofend(typeof(*resp), cap_flags)) {\n\t\t\tuctx = rdma_udata_to_drv_context(udata,\n\t\t\t\t\tstruct hns_roce_ucontext, ibucontext);\n\t\t\terr = hns_roce_db_map_user(uctx, addr, &hr_cq->db);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\thr_cq->flags |= HNS_ROCE_CQ_FLAG_RECORD_DB;\n\t\t\tresp->cap_flags |= HNS_ROCE_CQ_FLAG_RECORD_DB;\n\t\t}\n\t} else {\n\t\tif (has_db) {\n\t\t\terr = hns_roce_alloc_db(hr_dev, &hr_cq->db, 1);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\thr_cq->set_ci_db = hr_cq->db.db_record;\n\t\t\t*hr_cq->set_ci_db = 0;\n\t\t\thr_cq->flags |= HNS_ROCE_CQ_FLAG_RECORD_DB;\n\t\t}\n\t\thr_cq->db_reg = hr_dev->reg_base + hr_dev->odb_offset +\n\t\t\t\tDB_REG_OFFSET * hr_dev->priv_uar.index;\n\t}\n\n\treturn 0;\n}\n\nstatic void free_cq_db(struct hns_roce_dev *hr_dev, struct hns_roce_cq *hr_cq,\n\t\t       struct ib_udata *udata)\n{\n\tstruct hns_roce_ucontext *uctx;\n\n\tif (!(hr_cq->flags & HNS_ROCE_CQ_FLAG_RECORD_DB))\n\t\treturn;\n\n\thr_cq->flags &= ~HNS_ROCE_CQ_FLAG_RECORD_DB;\n\tif (udata) {\n\t\tuctx = rdma_udata_to_drv_context(udata,\n\t\t\t\t\t\t struct hns_roce_ucontext,\n\t\t\t\t\t\t ibucontext);\n\t\thns_roce_db_unmap_user(uctx, &hr_cq->db);\n\t} else {\n\t\thns_roce_free_db(hr_dev, &hr_cq->db);\n\t}\n}\n\nstatic int verify_cq_create_attr(struct hns_roce_dev *hr_dev,\n\t\t\t\t const struct ib_cq_init_attr *attr)\n{\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\n\tif (!attr->cqe || attr->cqe > hr_dev->caps.max_cqes) {\n\t\tibdev_err(ibdev, \"failed to check CQ count %u, max = %u.\\n\",\n\t\t\t  attr->cqe, hr_dev->caps.max_cqes);\n\t\treturn -EINVAL;\n\t}\n\n\tif (attr->comp_vector >= hr_dev->caps.num_comp_vectors) {\n\t\tibdev_err(ibdev, \"failed to check CQ vector = %u, max = %d.\\n\",\n\t\t\t  attr->comp_vector, hr_dev->caps.num_comp_vectors);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int get_cq_ucmd(struct hns_roce_cq *hr_cq, struct ib_udata *udata,\n\t\t       struct hns_roce_ib_create_cq *ucmd)\n{\n\tstruct ib_device *ibdev = hr_cq->ib_cq.device;\n\tint ret;\n\n\tret = ib_copy_from_udata(ucmd, udata, min(udata->inlen, sizeof(*ucmd)));\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to copy CQ udata, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void set_cq_param(struct hns_roce_cq *hr_cq, u32 cq_entries, int vector,\n\t\t\t struct hns_roce_ib_create_cq *ucmd)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(hr_cq->ib_cq.device);\n\n\tcq_entries = max(cq_entries, hr_dev->caps.min_cqes);\n\tcq_entries = roundup_pow_of_two(cq_entries);\n\thr_cq->ib_cq.cqe = cq_entries - 1;  \n\thr_cq->cq_depth = cq_entries;\n\thr_cq->vector = vector;\n\n\tspin_lock_init(&hr_cq->lock);\n\tINIT_LIST_HEAD(&hr_cq->sq_list);\n\tINIT_LIST_HEAD(&hr_cq->rq_list);\n}\n\nstatic int set_cqe_size(struct hns_roce_cq *hr_cq, struct ib_udata *udata,\n\t\t\tstruct hns_roce_ib_create_cq *ucmd)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(hr_cq->ib_cq.device);\n\n\tif (!udata) {\n\t\thr_cq->cqe_size = hr_dev->caps.cqe_sz;\n\t\treturn 0;\n\t}\n\n\tif (udata->inlen >= offsetofend(typeof(*ucmd), cqe_size)) {\n\t\tif (ucmd->cqe_size != HNS_ROCE_V2_CQE_SIZE &&\n\t\t    ucmd->cqe_size != HNS_ROCE_V3_CQE_SIZE) {\n\t\t\tibdev_err(&hr_dev->ib_dev,\n\t\t\t\t  \"invalid cqe size %u.\\n\", ucmd->cqe_size);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thr_cq->cqe_size = ucmd->cqe_size;\n\t} else {\n\t\thr_cq->cqe_size = HNS_ROCE_V2_CQE_SIZE;\n\t}\n\n\treturn 0;\n}\n\nint hns_roce_create_cq(struct ib_cq *ib_cq, const struct ib_cq_init_attr *attr,\n\t\t       struct ib_udata *udata)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_cq->device);\n\tstruct hns_roce_ib_create_cq_resp resp = {};\n\tstruct hns_roce_cq *hr_cq = to_hr_cq(ib_cq);\n\tstruct ib_device *ibdev = &hr_dev->ib_dev;\n\tstruct hns_roce_ib_create_cq ucmd = {};\n\tint ret;\n\n\tif (attr->flags)\n\t\treturn -EOPNOTSUPP;\n\n\tret = verify_cq_create_attr(hr_dev, attr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (udata) {\n\t\tret = get_cq_ucmd(hr_cq, udata, &ucmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tset_cq_param(hr_cq, attr->cqe, attr->comp_vector, &ucmd);\n\n\tret = set_cqe_size(hr_cq, udata, &ucmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_cq_buf(hr_dev, hr_cq, udata, ucmd.buf_addr);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to alloc CQ buf, ret = %d.\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = alloc_cq_db(hr_dev, hr_cq, udata, ucmd.db_addr, &resp);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to alloc CQ db, ret = %d.\\n\", ret);\n\t\tgoto err_cq_buf;\n\t}\n\n\tret = alloc_cqn(hr_dev, hr_cq);\n\tif (ret) {\n\t\tibdev_err(ibdev, \"failed to alloc CQN, ret = %d.\\n\", ret);\n\t\tgoto err_cq_db;\n\t}\n\n\tret = alloc_cqc(hr_dev, hr_cq);\n\tif (ret) {\n\t\tibdev_err(ibdev,\n\t\t\t  \"failed to alloc CQ context, ret = %d.\\n\", ret);\n\t\tgoto err_cqn;\n\t}\n\n\tif (udata) {\n\t\tresp.cqn = hr_cq->cqn;\n\t\tret = ib_copy_to_udata(udata, &resp,\n\t\t\t\t       min(udata->outlen, sizeof(resp)));\n\t\tif (ret)\n\t\t\tgoto err_cqc;\n\t}\n\n\thr_cq->cons_index = 0;\n\thr_cq->arm_sn = 1;\n\trefcount_set(&hr_cq->refcount, 1);\n\tinit_completion(&hr_cq->free);\n\n\treturn 0;\n\nerr_cqc:\n\tfree_cqc(hr_dev, hr_cq);\nerr_cqn:\n\tfree_cqn(hr_dev, hr_cq->cqn);\nerr_cq_db:\n\tfree_cq_db(hr_dev, hr_cq, udata);\nerr_cq_buf:\n\tfree_cq_buf(hr_dev, hr_cq);\n\treturn ret;\n}\n\nint hns_roce_destroy_cq(struct ib_cq *ib_cq, struct ib_udata *udata)\n{\n\tstruct hns_roce_dev *hr_dev = to_hr_dev(ib_cq->device);\n\tstruct hns_roce_cq *hr_cq = to_hr_cq(ib_cq);\n\n\tfree_cqc(hr_dev, hr_cq);\n\tfree_cqn(hr_dev, hr_cq->cqn);\n\tfree_cq_db(hr_dev, hr_cq, udata);\n\tfree_cq_buf(hr_dev, hr_cq);\n\n\treturn 0;\n}\n\nvoid hns_roce_cq_completion(struct hns_roce_dev *hr_dev, u32 cqn)\n{\n\tstruct hns_roce_cq *hr_cq;\n\tstruct ib_cq *ibcq;\n\n\thr_cq = xa_load(&hr_dev->cq_table.array,\n\t\t\tcqn & (hr_dev->caps.num_cqs - 1));\n\tif (!hr_cq) {\n\t\tdev_warn(hr_dev->dev, \"completion event for bogus CQ 0x%06x\\n\",\n\t\t\t cqn);\n\t\treturn;\n\t}\n\n\t++hr_cq->arm_sn;\n\tibcq = &hr_cq->ib_cq;\n\tif (ibcq->comp_handler)\n\t\tibcq->comp_handler(ibcq, ibcq->cq_context);\n}\n\nvoid hns_roce_cq_event(struct hns_roce_dev *hr_dev, u32 cqn, int event_type)\n{\n\tstruct device *dev = hr_dev->dev;\n\tstruct hns_roce_cq *hr_cq;\n\tstruct ib_event event;\n\tstruct ib_cq *ibcq;\n\n\thr_cq = xa_load(&hr_dev->cq_table.array,\n\t\t\tcqn & (hr_dev->caps.num_cqs - 1));\n\tif (!hr_cq) {\n\t\tdev_warn(dev, \"async event for bogus CQ 0x%06x\\n\", cqn);\n\t\treturn;\n\t}\n\n\tif (event_type != HNS_ROCE_EVENT_TYPE_CQ_ID_INVALID &&\n\t    event_type != HNS_ROCE_EVENT_TYPE_CQ_ACCESS_ERROR &&\n\t    event_type != HNS_ROCE_EVENT_TYPE_CQ_OVERFLOW) {\n\t\tdev_err(dev, \"unexpected event type 0x%x on CQ 0x%06x\\n\",\n\t\t\tevent_type, cqn);\n\t\treturn;\n\t}\n\n\trefcount_inc(&hr_cq->refcount);\n\n\tibcq = &hr_cq->ib_cq;\n\tif (ibcq->event_handler) {\n\t\tevent.device = ibcq->device;\n\t\tevent.element.cq = ibcq;\n\t\tevent.event = IB_EVENT_CQ_ERR;\n\t\tibcq->event_handler(&event, ibcq->cq_context);\n\t}\n\n\tif (refcount_dec_and_test(&hr_cq->refcount))\n\t\tcomplete(&hr_cq->free);\n}\n\nvoid hns_roce_init_cq_table(struct hns_roce_dev *hr_dev)\n{\n\tstruct hns_roce_cq_table *cq_table = &hr_dev->cq_table;\n\tunsigned int reserved_from_bot;\n\tunsigned int i;\n\n\tmutex_init(&cq_table->bank_mutex);\n\txa_init(&cq_table->array);\n\n\treserved_from_bot = hr_dev->caps.reserved_cqs;\n\n\tfor (i = 0; i < reserved_from_bot; i++) {\n\t\tcq_table->bank[get_cq_bankid(i)].inuse++;\n\t\tcq_table->bank[get_cq_bankid(i)].min++;\n\t}\n\n\tfor (i = 0; i < HNS_ROCE_CQ_BANK_NUM; i++) {\n\t\tida_init(&cq_table->bank[i].ida);\n\t\tcq_table->bank[i].max = hr_dev->caps.num_cqs /\n\t\t\t\t\tHNS_ROCE_CQ_BANK_NUM - 1;\n\t}\n}\n\nvoid hns_roce_cleanup_cq_table(struct hns_roce_dev *hr_dev)\n{\n\tint i;\n\n\tfor (i = 0; i < HNS_ROCE_CQ_BANK_NUM; i++)\n\t\tida_destroy(&hr_dev->cq_table.bank[i].ida);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}