{
  "module_name": "qplib_rcfw.h",
  "hash_id": "35cf39fc173c88e0c79c7f83fffabdc3de1c9ac6d7c2b0d57429a970affe8b0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/bnxt_re/qplib_rcfw.h",
  "human_readable_source": " \n\n#ifndef __BNXT_QPLIB_RCFW_H__\n#define __BNXT_QPLIB_RCFW_H__\n\n#include \"qplib_tlv.h\"\n\n#define RCFW_CMDQ_TRIG_VAL\t\t1\n#define RCFW_COMM_PCI_BAR_REGION\t0\n#define RCFW_COMM_CONS_PCI_BAR_REGION\t2\n#define RCFW_COMM_BASE_OFFSET\t\t0x600\n#define RCFW_PF_VF_COMM_PROD_OFFSET\t0xc\n#define RCFW_COMM_TRIG_OFFSET\t\t0x100\n#define RCFW_COMM_SIZE\t\t\t0x104\n\n#define RCFW_DBR_PCI_BAR_REGION\t\t2\n#define RCFW_DBR_BASE_PAGE_SHIFT\t12\n#define RCFW_FW_STALL_MAX_TIMEOUT\t40\n\n \nstruct bnxt_qplib_cmdqe {\n\tu8\t\tdata[16];\n};\n\n#define BNXT_QPLIB_CMDQE_UNITS\t\tsizeof(struct bnxt_qplib_cmdqe)\n\nstatic inline void bnxt_qplib_rcfw_cmd_prep(struct cmdq_base *req,\n\t\t\t\t\t    u8 opcode, u8 cmd_size)\n{\n\treq->opcode = opcode;\n\treq->cmd_size = cmd_size;\n}\n\n \n#define RCFW_CMD_NON_BLOCKING_SHADOW_QD\t64\n#define RCFW_CMD_WAIT_TIME_MS\t\t20000  \n\n \n#define BNXT_QPLIB_CMDQE_MAX_CNT\t8192\n#define BNXT_QPLIB_CMDQE_BYTES(depth)\t((depth) * BNXT_QPLIB_CMDQE_UNITS)\n\nstatic inline u32 bnxt_qplib_cmdqe_npages(u32 depth)\n{\n\tu32 npages;\n\n\tnpages = BNXT_QPLIB_CMDQE_BYTES(depth) / PAGE_SIZE;\n\tif (BNXT_QPLIB_CMDQE_BYTES(depth) % PAGE_SIZE)\n\t\tnpages++;\n\treturn npages;\n}\n\nstatic inline u32 bnxt_qplib_cmdqe_page_size(u32 depth)\n{\n\treturn (bnxt_qplib_cmdqe_npages(depth) * PAGE_SIZE);\n}\n\n \nstatic inline u32 bnxt_qplib_get_cmd_slots(struct cmdq_base *req)\n{\n\tu32 cmd_units = 0;\n\n\tif (HAS_TLV_HEADER(req)) {\n\t\tstruct roce_tlv *tlv_req = (struct roce_tlv *)req;\n\n\t\tcmd_units = tlv_req->total_size;\n\t} else {\n\t\tcmd_units = (req->cmd_size + BNXT_QPLIB_CMDQE_UNITS - 1) /\n\t\t\t    BNXT_QPLIB_CMDQE_UNITS;\n\t}\n\n\treturn cmd_units;\n}\n\nstatic inline u32 bnxt_qplib_set_cmd_slots(struct cmdq_base *req)\n{\n\tu32 cmd_byte = 0;\n\n\tif (HAS_TLV_HEADER(req)) {\n\t\tstruct roce_tlv *tlv_req = (struct roce_tlv *)req;\n\n\t\tcmd_byte = tlv_req->total_size * BNXT_QPLIB_CMDQE_UNITS;\n\t} else {\n\t\tcmd_byte = req->cmd_size;\n\t\treq->cmd_size = (req->cmd_size + BNXT_QPLIB_CMDQE_UNITS - 1) /\n\t\t\t\t BNXT_QPLIB_CMDQE_UNITS;\n\t}\n\n\treturn cmd_byte;\n}\n\n#define RCFW_MAX_COOKIE_VALUE\t\t(BNXT_QPLIB_CMDQE_MAX_CNT - 1)\n#define RCFW_CMD_IS_BLOCKING\t\t0x8000\n\n#define HWRM_VERSION_DEV_ATTR_MAX_DPI  0x1000A0000000DULL\n\n \nstruct bnxt_qplib_crsbe {\n\tu8\t\t\tdata[1024];\n};\n\n \n \n#define BNXT_QPLIB_CREQE_MAX_CNT\t(64 * 1024)\n#define BNXT_QPLIB_CREQE_UNITS\t\t16\t \n#define CREQ_CMP_VALID(hdr, raw_cons, cp_bit)\t\t\t\\\n\t(!!((hdr)->v & CREQ_BASE_V) ==\t\t\t\t\\\n\t   !((raw_cons) & (cp_bit)))\n#define CREQ_ENTRY_POLL_BUDGET\t\t0x100\n\n \ntypedef int (*aeq_handler_t)(struct bnxt_qplib_rcfw *, void *, void *);\n\nstruct bnxt_qplib_crsqe {\n\tstruct creq_qp_event\t*resp;\n\tu32\t\t\treq_size;\n\t \n\tu32\t\t\tfree_slots;\n\tu8\t\t\topcode;\n\tbool\t\t\tis_waiter_alive;\n\tbool\t\t\tis_internal_cmd;\n\tbool\t\t\tis_in_used;\n};\n\nstruct bnxt_qplib_rcfw_sbuf {\n\tvoid *sb;\n\tdma_addr_t dma_addr;\n\tu32 size;\n};\n\nstruct bnxt_qplib_qp_node {\n\tu32 qp_id;               \n\tvoid *qp_handle;         \n};\n\n#define BNXT_QPLIB_OOS_COUNT_MASK 0xFFFFFFFF\n\n#define FIRMWARE_INITIALIZED_FLAG\t(0)\n#define FIRMWARE_FIRST_FLAG\t\t(31)\n#define FIRMWARE_STALL_DETECTED\t\t(3)\n#define ERR_DEVICE_DETACHED             (4)\n\nstruct bnxt_qplib_cmdq_mbox {\n\tstruct bnxt_qplib_reg_desc\treg;\n\tvoid __iomem\t\t\t*prod;\n\tvoid __iomem\t\t\t*db;\n};\n\nstruct bnxt_qplib_cmdq_ctx {\n\tstruct bnxt_qplib_hwq\t\thwq;\n\tstruct bnxt_qplib_cmdq_mbox\tcmdq_mbox;\n\twait_queue_head_t\t\twaitq;\n\tunsigned long\t\t\tflags;\n\tunsigned long\t\t\tlast_seen;\n\tu32\t\t\t\tseq_num;\n};\n\nstruct bnxt_qplib_creq_db {\n\tstruct bnxt_qplib_reg_desc\treg;\n\tstruct bnxt_qplib_db_info\tdbinfo;\n};\n\nstruct bnxt_qplib_creq_stat {\n\tu64\tcreq_qp_event_processed;\n\tu64\tcreq_func_event_processed;\n};\n\nstruct bnxt_qplib_creq_ctx {\n\tstruct bnxt_qplib_hwq\t\thwq;\n\tstruct bnxt_qplib_creq_db\tcreq_db;\n\tstruct bnxt_qplib_creq_stat\tstats;\n\tstruct tasklet_struct\t\tcreq_tasklet;\n\taeq_handler_t\t\t\taeq_handler;\n\tu16\t\t\t\tring_id;\n\tint\t\t\t\tmsix_vec;\n\tbool\t\t\t\trequested;  \n\tchar\t\t\t\t*irq_name;\n};\n\n \nstruct bnxt_qplib_rcfw {\n\tstruct pci_dev\t\t*pdev;\n\tstruct bnxt_qplib_res\t*res;\n\tstruct bnxt_qplib_cmdq_ctx\tcmdq;\n\tstruct bnxt_qplib_creq_ctx\tcreq;\n\tstruct bnxt_qplib_crsqe\t\t*crsqe_tbl;\n\tint qp_tbl_size;\n\tstruct bnxt_qplib_qp_node *qp_tbl;\n\tu64 oos_prev;\n\tu32 init_oos_stats;\n\tu32 cmdq_depth;\n\tatomic_t rcfw_intr_enabled;\n\tstruct semaphore rcfw_inflight;\n\tatomic_t timeout_send;\n\t \n\tu16 max_timeout;\n};\n\nstruct bnxt_qplib_cmdqmsg {\n\tstruct cmdq_base\t*req;\n\tstruct creq_base\t*resp;\n\tvoid\t\t\t*sb;\n\tu32\t\t\treq_sz;\n\tu32\t\t\tres_sz;\n\tu8\t\t\tblock;\n};\n\nstatic inline void bnxt_qplib_fill_cmdqmsg(struct bnxt_qplib_cmdqmsg *msg,\n\t\t\t\t\t   void *req, void *resp, void *sb,\n\t\t\t\t\t   u32 req_sz, u32 res_sz, u8 block)\n{\n\tmsg->req = req;\n\tmsg->resp = resp;\n\tmsg->sb = sb;\n\tmsg->req_sz = req_sz;\n\tmsg->res_sz = res_sz;\n\tmsg->block = block;\n}\n\nvoid bnxt_qplib_free_rcfw_channel(struct bnxt_qplib_rcfw *rcfw);\nint bnxt_qplib_alloc_rcfw_channel(struct bnxt_qplib_res *res,\n\t\t\t\t  struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t  struct bnxt_qplib_ctx *ctx,\n\t\t\t\t  int qp_tbl_sz);\nvoid bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill);\nvoid bnxt_qplib_disable_rcfw_channel(struct bnxt_qplib_rcfw *rcfw);\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\n\t\t\t      bool need_init);\nint bnxt_qplib_enable_rcfw_channel(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t   int msix_vector,\n\t\t\t\t   int cp_bar_reg_off,\n\t\t\t\t   aeq_handler_t aeq_handler);\n\nstruct bnxt_qplib_rcfw_sbuf *bnxt_qplib_rcfw_alloc_sbuf(\n\t\t\t\tstruct bnxt_qplib_rcfw *rcfw,\n\t\t\t\tu32 size);\nvoid bnxt_qplib_rcfw_free_sbuf(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t       struct bnxt_qplib_rcfw_sbuf *sbuf);\nint bnxt_qplib_rcfw_send_message(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t struct bnxt_qplib_cmdqmsg *msg);\n\nint bnxt_qplib_deinit_rcfw(struct bnxt_qplib_rcfw *rcfw);\nint bnxt_qplib_init_rcfw(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t struct bnxt_qplib_ctx *ctx, int is_virtfn);\nvoid bnxt_qplib_mark_qp_error(void *qp_handle);\nstatic inline u32 map_qp_id_to_tbl_indx(u32 qid, struct bnxt_qplib_rcfw *rcfw)\n{\n\t \n\treturn (qid == 1) ? rcfw->qp_tbl_size - 1 : qid % rcfw->qp_tbl_size - 2;\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}