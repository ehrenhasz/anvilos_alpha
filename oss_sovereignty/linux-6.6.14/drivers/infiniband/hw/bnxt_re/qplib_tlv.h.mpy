{
  "module_name": "qplib_tlv.h",
  "hash_id": "f506b6ae9d6c508e2c969debbd9f4fccec4a7284ec795175f26c760370704bac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/bnxt_re/qplib_tlv.h",
  "human_readable_source": " \n\n#ifndef __QPLIB_TLV_H__\n#define __QPLIB_TLV_H__\n\nstruct roce_tlv {\n\tstruct tlv tlv;\n\tu8 total_size; \n\tu8 unused[7];  \n};\n\n#define CHUNK_SIZE 16\n#define CHUNKS(x) (((x) + CHUNK_SIZE - 1) / CHUNK_SIZE)\n\nstatic inline  void __roce_1st_tlv_prep(struct roce_tlv *rtlv, u8 tot_chunks,\n\t\t\t\t\tu16 content_bytes, u8 flags)\n{\n\trtlv->tlv.cmd_discr = cpu_to_le16(CMD_DISCR_TLV_ENCAP);\n\trtlv->tlv.tlv_type = cpu_to_le16(TLV_TYPE_ROCE_SP_COMMAND);\n\trtlv->tlv.length = cpu_to_le16(content_bytes);\n\trtlv->tlv.flags = TLV_FLAGS_REQUIRED;\n\trtlv->tlv.flags |= flags ? TLV_FLAGS_MORE : 0;\n\trtlv->total_size = (tot_chunks);\n}\n\nstatic inline void __roce_ext_tlv_prep(struct roce_tlv *rtlv, u16 tlv_type,\n\t\t\t\t       u16 content_bytes, u8 more, u8 flags)\n{\n\trtlv->tlv.cmd_discr = cpu_to_le16(CMD_DISCR_TLV_ENCAP);\n\trtlv->tlv.tlv_type = cpu_to_le16(tlv_type);\n\trtlv->tlv.length = cpu_to_le16(content_bytes);\n\trtlv->tlv.flags |= more ? TLV_FLAGS_MORE : 0;\n\trtlv->tlv.flags |= flags ? TLV_FLAGS_REQUIRED : 0;\n}\n\n \n#define TLV_SIZE ((sizeof(struct roce_tlv) + 15) / 16)\n \n#define TLV_BYTES (TLV_SIZE * 16)\n\n#define HAS_TLV_HEADER(msg) (le16_to_cpu(((struct tlv *)(msg))->cmd_discr) == CMD_DISCR_TLV_ENCAP)\n#define GET_TLV_DATA(tlv)   ((void *)&((uint8_t *)(tlv))[TLV_BYTES])\n\nstatic inline u8 __get_cmdq_base_opcode(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct cmdq_base *)GET_TLV_DATA(req))->opcode;\n\telse\n\t\treturn req->opcode;\n}\n\nstatic inline void __set_cmdq_base_opcode(struct cmdq_base *req,\n\t\t\t\t\t  u32 size, u8 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->opcode = val;\n\telse\n\t\treq->opcode = val;\n}\n\nstatic inline __le16 __get_cmdq_base_cookie(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct cmdq_base *)GET_TLV_DATA(req))->cookie;\n\telse\n\t\treturn req->cookie;\n}\n\nstatic inline void __set_cmdq_base_cookie(struct cmdq_base *req,\n\t\t\t\t\t  u32 size, __le16 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->cookie = val;\n\telse\n\t\treq->cookie = val;\n}\n\nstatic inline __le64 __get_cmdq_base_resp_addr(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct cmdq_base *)GET_TLV_DATA(req))->resp_addr;\n\telse\n\t\treturn req->resp_addr;\n}\n\nstatic inline void __set_cmdq_base_resp_addr(struct cmdq_base *req,\n\t\t\t\t\t     u32 size, __le64 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->resp_addr = val;\n\telse\n\t\treq->resp_addr = val;\n}\n\nstatic inline u8 __get_cmdq_base_resp_size(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct cmdq_base *)GET_TLV_DATA(req))->resp_size;\n\telse\n\t\treturn req->resp_size;\n}\n\nstatic inline void __set_cmdq_base_resp_size(struct cmdq_base *req,\n\t\t\t\t\t     u32 size, u8 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->resp_size = val;\n\telse\n\t\treq->resp_size = val;\n}\n\nstatic inline u8 __get_cmdq_base_cmd_size(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct roce_tlv *)(req))->total_size;\n\telse\n\t\treturn req->cmd_size;\n}\n\nstatic inline void __set_cmdq_base_cmd_size(struct cmdq_base *req,\n\t\t\t\t\t    u32 size, u8 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->cmd_size = val;\n\telse\n\t\treq->cmd_size = val;\n}\n\nstatic inline __le16 __get_cmdq_base_flags(struct cmdq_base *req, u32 size)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\treturn ((struct cmdq_base *)GET_TLV_DATA(req))->flags;\n\telse\n\t\treturn req->flags;\n}\n\nstatic inline void __set_cmdq_base_flags(struct cmdq_base *req,\n\t\t\t\t\t u32 size, __le16 val)\n{\n\tif (HAS_TLV_HEADER(req) && size > TLV_BYTES)\n\t\t((struct cmdq_base *)GET_TLV_DATA(req))->flags = val;\n\telse\n\t\treq->flags = val;\n}\n\nstruct bnxt_qplib_tlv_modify_cc_req {\n\tstruct roce_tlv\t\t\t\ttlv_hdr;\n\tstruct cmdq_modify_roce_cc\t\tbase_req;\n\t__le64\t\t\t\t\ttlvpad;\n\tstruct cmdq_modify_roce_cc_gen1_tlv\text_req;\n};\n\nstruct bnxt_qplib_tlv_query_rcc_sb {\n\tstruct roce_tlv\t\t\t\t\ttlv_hdr;\n\tstruct creq_query_roce_cc_resp_sb\t\tbase_sb;\n\tstruct creq_query_roce_cc_gen1_resp_sb_tlv\tgen1_sb;\n};\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}