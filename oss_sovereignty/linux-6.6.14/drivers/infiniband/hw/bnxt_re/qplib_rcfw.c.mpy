{
  "module_name": "qplib_rcfw.c",
  "hash_id": "526547d5d7cac00345d1f245a5ea5c36591a5db0dd4188c103057b9e67d28000",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/bnxt_re/qplib_rcfw.c",
  "human_readable_source": " \n\n#define dev_fmt(fmt) \"QPLIB: \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/prefetch.h>\n#include <linux/delay.h>\n\n#include \"roce_hsi.h\"\n#include \"qplib_res.h\"\n#include \"qplib_rcfw.h\"\n#include \"qplib_sp.h\"\n#include \"qplib_fp.h\"\n#include \"qplib_tlv.h\"\n\nstatic void bnxt_qplib_service_creq(struct tasklet_struct *t);\n\n \nstatic int bnxt_qplib_map_rc(u8 opcode)\n{\n\tswitch (opcode) {\n\tcase CMDQ_BASE_OPCODE_DESTROY_QP:\n\tcase CMDQ_BASE_OPCODE_DESTROY_SRQ:\n\tcase CMDQ_BASE_OPCODE_DESTROY_CQ:\n\tcase CMDQ_BASE_OPCODE_DEALLOCATE_KEY:\n\tcase CMDQ_BASE_OPCODE_DEREGISTER_MR:\n\tcase CMDQ_BASE_OPCODE_DELETE_GID:\n\tcase CMDQ_BASE_OPCODE_DESTROY_QP1:\n\tcase CMDQ_BASE_OPCODE_DESTROY_AH:\n\tcase CMDQ_BASE_OPCODE_DEINITIALIZE_FW:\n\tcase CMDQ_BASE_OPCODE_MODIFY_ROCE_CC:\n\tcase CMDQ_BASE_OPCODE_SET_LINK_AGGR_MODE:\n\t\treturn 0;\n\tdefault:\n\t\treturn -ETIMEDOUT;\n\t}\n}\n\n \nstatic int bnxt_re_is_fw_stalled(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t u16 cookie)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\tcmdq = &rcfw->cmdq;\n\n\tif (time_after(jiffies, cmdq->last_seen +\n\t\t      (rcfw->max_timeout * HZ))) {\n\t\tdev_warn_ratelimited(&rcfw->pdev->dev,\n\t\t\t\t     \"%s: FW STALL Detected. cmdq[%#x]=%#x waited (%d > %d) msec active %d \",\n\t\t\t\t     __func__, cookie, crsqe->opcode,\n\t\t\t\t     jiffies_to_msecs(jiffies - cmdq->last_seen),\n\t\t\t\t     rcfw->max_timeout * 1000,\n\t\t\t\t     crsqe->is_in_used);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int __wait_for_resp(struct bnxt_qplib_rcfw *rcfw, u16 cookie)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tint ret;\n\n\tcmdq = &rcfw->cmdq;\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\tdo {\n\t\tif (test_bit(ERR_DEVICE_DETACHED, &cmdq->flags))\n\t\t\treturn bnxt_qplib_map_rc(crsqe->opcode);\n\t\tif (test_bit(FIRMWARE_STALL_DETECTED, &cmdq->flags))\n\t\t\treturn -ETIMEDOUT;\n\n\t\twait_event_timeout(cmdq->waitq,\n\t\t\t\t   !crsqe->is_in_used ||\n\t\t\t\t   test_bit(ERR_DEVICE_DETACHED, &cmdq->flags),\n\t\t\t\t   msecs_to_jiffies(rcfw->max_timeout * 1000));\n\n\t\tif (!crsqe->is_in_used)\n\t\t\treturn 0;\n\n\t\tbnxt_qplib_service_creq(&rcfw->creq.creq_tasklet);\n\n\t\tif (!crsqe->is_in_used)\n\t\t\treturn 0;\n\n\t\tret = bnxt_re_is_fw_stalled(rcfw, cookie);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t} while (true);\n};\n\n \nstatic int __block_for_resp(struct bnxt_qplib_rcfw *rcfw, u16 cookie)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq = &rcfw->cmdq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tunsigned long issue_time = 0;\n\n\tissue_time = jiffies;\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\tdo {\n\t\tif (test_bit(ERR_DEVICE_DETACHED, &cmdq->flags))\n\t\t\treturn bnxt_qplib_map_rc(crsqe->opcode);\n\t\tif (test_bit(FIRMWARE_STALL_DETECTED, &cmdq->flags))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tudelay(1);\n\n\t\tbnxt_qplib_service_creq(&rcfw->creq.creq_tasklet);\n\t\tif (!crsqe->is_in_used)\n\t\t\treturn 0;\n\n\t} while (time_before(jiffies, issue_time + (8 * HZ)));\n\n\treturn -ETIMEDOUT;\n};\n\n \nstatic void __send_message_no_waiter(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t     struct bnxt_qplib_cmdqmsg *msg)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq = &rcfw->cmdq;\n\tstruct bnxt_qplib_hwq *hwq = &cmdq->hwq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tstruct bnxt_qplib_cmdqe *cmdqe;\n\tu32 sw_prod, cmdq_prod;\n\tu16 cookie;\n\tu32 bsize;\n\tu8 *preq;\n\n\tcookie = cmdq->seq_num & RCFW_MAX_COOKIE_VALUE;\n\t__set_cmdq_base_cookie(msg->req, msg->req_sz, cpu_to_le16(cookie));\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\t \n\tbsize = bnxt_qplib_set_cmd_slots(msg->req);\n\t \n\tcrsqe->is_internal_cmd = true;\n\tcrsqe->is_waiter_alive = false;\n\tcrsqe->is_in_used = true;\n\tcrsqe->req_size = __get_cmdq_base_cmd_size(msg->req, msg->req_sz);\n\n\tpreq = (u8 *)msg->req;\n\tdo {\n\t\t \n\t\tsw_prod = HWQ_CMP(hwq->prod, hwq);\n\t\tcmdqe = bnxt_qplib_get_qe(hwq, sw_prod, NULL);\n\t\t \n\t\tmemset(cmdqe, 0, sizeof(*cmdqe));\n\t\tmemcpy(cmdqe, preq, min_t(u32, bsize, sizeof(*cmdqe)));\n\t\tpreq += min_t(u32, bsize, sizeof(*cmdqe));\n\t\tbsize -= min_t(u32, bsize, sizeof(*cmdqe));\n\t\thwq->prod++;\n\t} while (bsize > 0);\n\tcmdq->seq_num++;\n\n\tcmdq_prod = hwq->prod;\n\tatomic_inc(&rcfw->timeout_send);\n\t \n\twmb();\n\twritel(cmdq_prod, cmdq->cmdq_mbox.prod);\n\twritel(RCFW_CMDQ_TRIG_VAL, cmdq->cmdq_mbox.db);\n}\n\nstatic int __send_message(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t  struct bnxt_qplib_cmdqmsg *msg, u8 opcode)\n{\n\tu32 bsize, free_slots, required_slots;\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tstruct bnxt_qplib_cmdqe *cmdqe;\n\tstruct bnxt_qplib_hwq *hwq;\n\tu32 sw_prod, cmdq_prod;\n\tstruct pci_dev *pdev;\n\tunsigned long flags;\n\tu16 cookie;\n\tu8 *preq;\n\n\tcmdq = &rcfw->cmdq;\n\thwq = &cmdq->hwq;\n\tpdev = rcfw->pdev;\n\n\t \n\tspin_lock_irqsave(&hwq->lock, flags);\n\trequired_slots = bnxt_qplib_get_cmd_slots(msg->req);\n\tfree_slots = HWQ_FREE_SLOTS(hwq);\n\tcookie = cmdq->seq_num & RCFW_MAX_COOKIE_VALUE;\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\tif (required_slots >= free_slots) {\n\t\tdev_info_ratelimited(&pdev->dev,\n\t\t\t\t     \"CMDQ is full req/free %d/%d!\",\n\t\t\t\t     required_slots, free_slots);\n\t\tspin_unlock_irqrestore(&hwq->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\tif (msg->block)\n\t\tcookie |= RCFW_CMD_IS_BLOCKING;\n\t__set_cmdq_base_cookie(msg->req, msg->req_sz, cpu_to_le16(cookie));\n\n\tbsize = bnxt_qplib_set_cmd_slots(msg->req);\n\tcrsqe->free_slots = free_slots;\n\tcrsqe->resp = (struct creq_qp_event *)msg->resp;\n\tcrsqe->resp->cookie = cpu_to_le16(cookie);\n\tcrsqe->is_internal_cmd = false;\n\tcrsqe->is_waiter_alive = true;\n\tcrsqe->is_in_used = true;\n\tcrsqe->opcode = opcode;\n\n\tcrsqe->req_size = __get_cmdq_base_cmd_size(msg->req, msg->req_sz);\n\tif (__get_cmdq_base_resp_size(msg->req, msg->req_sz) && msg->sb) {\n\t\tstruct bnxt_qplib_rcfw_sbuf *sbuf = msg->sb;\n\n\t\t__set_cmdq_base_resp_addr(msg->req, msg->req_sz,\n\t\t\t\t\t  cpu_to_le64(sbuf->dma_addr));\n\t\t__set_cmdq_base_resp_size(msg->req, msg->req_sz,\n\t\t\t\t\t  ALIGN(sbuf->size,\n\t\t\t\t\t\tBNXT_QPLIB_CMDQE_UNITS) /\n\t\t\t\t\t\tBNXT_QPLIB_CMDQE_UNITS);\n\t}\n\n\tpreq = (u8 *)msg->req;\n\tdo {\n\t\t \n\t\tsw_prod = HWQ_CMP(hwq->prod, hwq);\n\t\tcmdqe = bnxt_qplib_get_qe(hwq, sw_prod, NULL);\n\t\t \n\t\tmemset(cmdqe, 0, sizeof(*cmdqe));\n\t\tmemcpy(cmdqe, preq, min_t(u32, bsize, sizeof(*cmdqe)));\n\t\tpreq += min_t(u32, bsize, sizeof(*cmdqe));\n\t\tbsize -= min_t(u32, bsize, sizeof(*cmdqe));\n\t\thwq->prod++;\n\t} while (bsize > 0);\n\tcmdq->seq_num++;\n\n\tcmdq_prod = hwq->prod & 0xFFFF;\n\tif (test_bit(FIRMWARE_FIRST_FLAG, &cmdq->flags)) {\n\t\t \n\t\tcmdq_prod |= BIT(FIRMWARE_FIRST_FLAG);\n\t\tclear_bit(FIRMWARE_FIRST_FLAG, &cmdq->flags);\n\t}\n\t \n\twmb();\n\twritel(cmdq_prod, cmdq->cmdq_mbox.prod);\n\twritel(RCFW_CMDQ_TRIG_VAL, cmdq->cmdq_mbox.db);\n\tspin_unlock_irqrestore(&hwq->lock, flags);\n\t \n\treturn 0;\n}\n\n \nstatic int __poll_for_resp(struct bnxt_qplib_rcfw *rcfw, u16 cookie)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq = &rcfw->cmdq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tunsigned long issue_time;\n\tint ret;\n\n\tissue_time = jiffies;\n\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\tdo {\n\t\tif (test_bit(ERR_DEVICE_DETACHED, &cmdq->flags))\n\t\t\treturn bnxt_qplib_map_rc(crsqe->opcode);\n\t\tif (test_bit(FIRMWARE_STALL_DETECTED, &cmdq->flags))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tusleep_range(1000, 1001);\n\n\t\tbnxt_qplib_service_creq(&rcfw->creq.creq_tasklet);\n\t\tif (!crsqe->is_in_used)\n\t\t\treturn 0;\n\t\tif (jiffies_to_msecs(jiffies - issue_time) >\n\t\t    (rcfw->max_timeout * 1000)) {\n\t\t\tret = bnxt_re_is_fw_stalled(rcfw, cookie);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t} while (true);\n};\n\nstatic int __send_message_basic_sanity(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t       struct bnxt_qplib_cmdqmsg *msg,\n\t\t\t\t       u8 opcode)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\n\tcmdq = &rcfw->cmdq;\n\n\t \n\tif (test_bit(ERR_DEVICE_DETACHED, &rcfw->cmdq.flags))\n\t\treturn bnxt_qplib_map_rc(opcode);\n\tif (test_bit(FIRMWARE_STALL_DETECTED, &cmdq->flags))\n\t\treturn -ETIMEDOUT;\n\n\tif (test_bit(FIRMWARE_INITIALIZED_FLAG, &cmdq->flags) &&\n\t    opcode == CMDQ_BASE_OPCODE_INITIALIZE_FW) {\n\t\tdev_err(&rcfw->pdev->dev, \"QPLIB: RCFW already initialized!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!test_bit(FIRMWARE_INITIALIZED_FLAG, &cmdq->flags) &&\n\t    (opcode != CMDQ_BASE_OPCODE_QUERY_FUNC &&\n\t     opcode != CMDQ_BASE_OPCODE_INITIALIZE_FW &&\n\t     opcode != CMDQ_BASE_OPCODE_QUERY_VERSION)) {\n\t\tdev_err(&rcfw->pdev->dev,\n\t\t\t\"QPLIB: RCFW not initialized, reject opcode 0x%x\",\n\t\t\topcode);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void __destroy_timedout_ah(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t  struct creq_create_ah_resp *create_ah_resp)\n{\n\tstruct bnxt_qplib_cmdqmsg msg = {};\n\tstruct cmdq_destroy_ah req = {};\n\n\tbnxt_qplib_rcfw_cmd_prep((struct cmdq_base *)&req,\n\t\t\t\t CMDQ_BASE_OPCODE_DESTROY_AH,\n\t\t\t\t sizeof(req));\n\treq.ah_cid = create_ah_resp->xid;\n\tmsg.req = (struct cmdq_base *)&req;\n\tmsg.req_sz = sizeof(req);\n\t__send_message_no_waiter(rcfw, &msg);\n\tdev_info_ratelimited(&rcfw->pdev->dev,\n\t\t\t     \"From %s: ah_cid = %d timeout_send %d\\n\",\n\t\t\t     __func__, req.ah_cid,\n\t\t\t     atomic_read(&rcfw->timeout_send));\n}\n\n \nstatic int __bnxt_qplib_rcfw_send_message(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t\t  struct bnxt_qplib_cmdqmsg *msg)\n{\n\tstruct creq_qp_event *evnt = (struct creq_qp_event *)msg->resp;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tunsigned long flags;\n\tu16 cookie;\n\tint rc;\n\tu8 opcode;\n\n\topcode = __get_cmdq_base_opcode(msg->req, msg->req_sz);\n\n\trc = __send_message_basic_sanity(rcfw, msg, opcode);\n\tif (rc)\n\t\treturn rc;\n\n\trc = __send_message(rcfw, msg, opcode);\n\tif (rc)\n\t\treturn rc;\n\n\tcookie = le16_to_cpu(__get_cmdq_base_cookie(msg->req, msg->req_sz))\n\t\t\t\t& RCFW_MAX_COOKIE_VALUE;\n\n\tif (msg->block)\n\t\trc = __block_for_resp(rcfw, cookie);\n\telse if (atomic_read(&rcfw->rcfw_intr_enabled))\n\t\trc = __wait_for_resp(rcfw, cookie);\n\telse\n\t\trc = __poll_for_resp(rcfw, cookie);\n\n\tif (rc) {\n\t\tspin_lock_irqsave(&rcfw->cmdq.hwq.lock, flags);\n\t\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\t\tcrsqe->is_waiter_alive = false;\n\t\tif (rc == -ENODEV)\n\t\t\tset_bit(FIRMWARE_STALL_DETECTED, &rcfw->cmdq.flags);\n\t\tspin_unlock_irqrestore(&rcfw->cmdq.hwq.lock, flags);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (evnt->status) {\n\t\t \n\t\tdev_err(&rcfw->pdev->dev, \"cmdq[%#x]=%#x status %#x\\n\",\n\t\t\tcookie, opcode, evnt->status);\n\t\trc = -EFAULT;\n\t}\n\n\treturn rc;\n}\n\n \nint bnxt_qplib_rcfw_send_message(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t struct bnxt_qplib_cmdqmsg *msg)\n{\n\tint ret;\n\n\tif (!msg->block) {\n\t\tdown(&rcfw->rcfw_inflight);\n\t\tret = __bnxt_qplib_rcfw_send_message(rcfw, msg);\n\t\tup(&rcfw->rcfw_inflight);\n\t} else {\n\t\tret = __bnxt_qplib_rcfw_send_message(rcfw, msg);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int bnxt_qplib_process_func_event(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t\t struct creq_func_event *func_event)\n{\n\tint rc;\n\n\tswitch (func_event->event) {\n\tcase CREQ_FUNC_EVENT_EVENT_TX_WQE_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_TX_DATA_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_RX_WQE_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_RX_DATA_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_CQ_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_TQM_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_CFCQ_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_CFCS_ERROR:\n\t\t \n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_CFCC_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_CFCM_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_TIM_ERROR:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_VF_COMM_REQUEST:\n\t\tbreak;\n\tcase CREQ_FUNC_EVENT_EVENT_RESOURCE_EXHAUSTED:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trc = rcfw->creq.aeq_handler(rcfw, (void *)func_event, NULL);\n\treturn rc;\n}\n\nstatic int bnxt_qplib_process_qp_event(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t       struct creq_qp_event *qp_event,\n\t\t\t\t       u32 *num_wait)\n{\n\tstruct creq_qp_error_notification *err_event;\n\tstruct bnxt_qplib_hwq *hwq = &rcfw->cmdq.hwq;\n\tstruct bnxt_qplib_crsqe *crsqe;\n\tu32 qp_id, tbl_indx, req_size;\n\tstruct bnxt_qplib_qp *qp;\n\tu16 cookie, blocked = 0;\n\tbool is_waiter_alive;\n\tstruct pci_dev *pdev;\n\tunsigned long flags;\n\tu32 wait_cmds = 0;\n\tint rc = 0;\n\n\tpdev = rcfw->pdev;\n\tswitch (qp_event->event) {\n\tcase CREQ_QP_EVENT_EVENT_QP_ERROR_NOTIFICATION:\n\t\terr_event = (struct creq_qp_error_notification *)qp_event;\n\t\tqp_id = le32_to_cpu(err_event->xid);\n\t\ttbl_indx = map_qp_id_to_tbl_indx(qp_id, rcfw);\n\t\tqp = rcfw->qp_tbl[tbl_indx].qp_handle;\n\t\tdev_dbg(&pdev->dev, \"Received QP error notification\\n\");\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"qpid 0x%x, req_err=0x%x, resp_err=0x%x\\n\",\n\t\t\tqp_id, err_event->req_err_state_reason,\n\t\t\terr_event->res_err_state_reason);\n\t\tif (!qp)\n\t\t\tbreak;\n\t\tbnxt_qplib_mark_qp_error(qp);\n\t\trc = rcfw->creq.aeq_handler(rcfw, qp_event, qp);\n\t\tbreak;\n\tdefault:\n\t\t \n\n\t\tspin_lock_irqsave_nested(&hwq->lock, flags,\n\t\t\t\t\t SINGLE_DEPTH_NESTING);\n\t\tcookie = le16_to_cpu(qp_event->cookie);\n\t\tblocked = cookie & RCFW_CMD_IS_BLOCKING;\n\t\tcookie &= RCFW_MAX_COOKIE_VALUE;\n\t\tcrsqe = &rcfw->crsqe_tbl[cookie];\n\n\t\tif (WARN_ONCE(test_bit(FIRMWARE_STALL_DETECTED,\n\t\t\t\t       &rcfw->cmdq.flags),\n\t\t    \"QPLIB: Unreponsive rcfw channel detected.!!\")) {\n\t\t\tdev_info(&pdev->dev,\n\t\t\t\t \"rcfw timedout: cookie = %#x, free_slots = %d\",\n\t\t\t\t cookie, crsqe->free_slots);\n\t\t\tspin_unlock_irqrestore(&hwq->lock, flags);\n\t\t\treturn rc;\n\t\t}\n\n\t\tif (crsqe->is_internal_cmd && !qp_event->status)\n\t\t\tatomic_dec(&rcfw->timeout_send);\n\n\t\tif (crsqe->is_waiter_alive) {\n\t\t\tif (crsqe->resp) {\n\t\t\t\tmemcpy(crsqe->resp, qp_event, sizeof(*qp_event));\n\t\t\t\t \n\t\t\t\tsmp_wmb();\n\t\t\t}\n\t\t\tif (!blocked)\n\t\t\t\twait_cmds++;\n\t\t}\n\n\t\treq_size = crsqe->req_size;\n\t\tis_waiter_alive = crsqe->is_waiter_alive;\n\n\t\tcrsqe->req_size = 0;\n\t\tif (!is_waiter_alive)\n\t\t\tcrsqe->resp = NULL;\n\n\t\tcrsqe->is_in_used = false;\n\n\t\thwq->cons += req_size;\n\n\t\t \n\t\tif (!is_waiter_alive && !qp_event->status &&\n\t\t    qp_event->event == CREQ_QP_EVENT_EVENT_CREATE_AH)\n\t\t\t__destroy_timedout_ah(rcfw,\n\t\t\t\t\t      (struct creq_create_ah_resp *)\n\t\t\t\t\t      qp_event);\n\t\tspin_unlock_irqrestore(&hwq->lock, flags);\n\t}\n\t*num_wait += wait_cmds;\n\treturn rc;\n}\n\n \nstatic void bnxt_qplib_service_creq(struct tasklet_struct *t)\n{\n\tstruct bnxt_qplib_rcfw *rcfw = from_tasklet(rcfw, t, creq.creq_tasklet);\n\tstruct bnxt_qplib_creq_ctx *creq = &rcfw->creq;\n\tu32 type, budget = CREQ_ENTRY_POLL_BUDGET;\n\tstruct bnxt_qplib_hwq *hwq = &creq->hwq;\n\tstruct creq_base *creqe;\n\tu32 sw_cons, raw_cons;\n\tunsigned long flags;\n\tu32 num_wakeup = 0;\n\n\t \n\tspin_lock_irqsave(&hwq->lock, flags);\n\traw_cons = hwq->cons;\n\twhile (budget > 0) {\n\t\tsw_cons = HWQ_CMP(raw_cons, hwq);\n\t\tcreqe = bnxt_qplib_get_qe(hwq, sw_cons, NULL);\n\t\tif (!CREQ_CMP_VALID(creqe, raw_cons, hwq->max_elements))\n\t\t\tbreak;\n\t\t \n\t\tdma_rmb();\n\t\trcfw->cmdq.last_seen = jiffies;\n\n\t\ttype = creqe->type & CREQ_BASE_TYPE_MASK;\n\t\tswitch (type) {\n\t\tcase CREQ_BASE_TYPE_QP_EVENT:\n\t\t\tbnxt_qplib_process_qp_event\n\t\t\t\t(rcfw, (struct creq_qp_event *)creqe,\n\t\t\t\t &num_wakeup);\n\t\t\tcreq->stats.creq_qp_event_processed++;\n\t\t\tbreak;\n\t\tcase CREQ_BASE_TYPE_FUNC_EVENT:\n\t\t\tif (!bnxt_qplib_process_func_event\n\t\t\t    (rcfw, (struct creq_func_event *)creqe))\n\t\t\t\tcreq->stats.creq_func_event_processed++;\n\t\t\telse\n\t\t\t\tdev_warn(&rcfw->pdev->dev,\n\t\t\t\t\t \"aeqe:%#x Not handled\\n\", type);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (type != ASYNC_EVENT_CMPL_TYPE_HWRM_ASYNC_EVENT)\n\t\t\t\tdev_warn(&rcfw->pdev->dev,\n\t\t\t\t\t \"creqe with event 0x%x not handled\\n\",\n\t\t\t\t\t type);\n\t\t\tbreak;\n\t\t}\n\t\traw_cons++;\n\t\tbudget--;\n\t}\n\n\tif (hwq->cons != raw_cons) {\n\t\thwq->cons = raw_cons;\n\t\tbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo,\n\t\t\t\t      rcfw->res->cctx, true);\n\t}\n\tspin_unlock_irqrestore(&hwq->lock, flags);\n\tif (num_wakeup)\n\t\twake_up_nr(&rcfw->cmdq.waitq, num_wakeup);\n}\n\nstatic irqreturn_t bnxt_qplib_creq_irq(int irq, void *dev_instance)\n{\n\tstruct bnxt_qplib_rcfw *rcfw = dev_instance;\n\tstruct bnxt_qplib_creq_ctx *creq;\n\tstruct bnxt_qplib_hwq *hwq;\n\tu32 sw_cons;\n\n\tcreq = &rcfw->creq;\n\thwq = &creq->hwq;\n\t \n\tsw_cons = HWQ_CMP(hwq->cons, hwq);\n\tprefetch(bnxt_qplib_get_qe(hwq, sw_cons, NULL));\n\n\ttasklet_schedule(&creq->creq_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint bnxt_qplib_deinit_rcfw(struct bnxt_qplib_rcfw *rcfw)\n{\n\tstruct creq_deinitialize_fw_resp resp = {};\n\tstruct cmdq_deinitialize_fw req = {};\n\tstruct bnxt_qplib_cmdqmsg msg = {};\n\tint rc;\n\n\tbnxt_qplib_rcfw_cmd_prep((struct cmdq_base *)&req,\n\t\t\t\t CMDQ_BASE_OPCODE_DEINITIALIZE_FW,\n\t\t\t\t sizeof(req));\n\tbnxt_qplib_fill_cmdqmsg(&msg, &req, &resp, NULL,\n\t\t\t\tsizeof(req), sizeof(resp), 0);\n\trc = bnxt_qplib_rcfw_send_message(rcfw, &msg);\n\tif (rc)\n\t\treturn rc;\n\n\tclear_bit(FIRMWARE_INITIALIZED_FLAG, &rcfw->cmdq.flags);\n\treturn 0;\n}\n\nint bnxt_qplib_init_rcfw(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t struct bnxt_qplib_ctx *ctx, int is_virtfn)\n{\n\tstruct creq_initialize_fw_resp resp = {};\n\tstruct cmdq_initialize_fw req = {};\n\tstruct bnxt_qplib_cmdqmsg msg = {};\n\tu8 pgsz, lvl;\n\tint rc;\n\n\tbnxt_qplib_rcfw_cmd_prep((struct cmdq_base *)&req,\n\t\t\t\t CMDQ_BASE_OPCODE_INITIALIZE_FW,\n\t\t\t\t sizeof(req));\n\t \n\treq.log2_dbr_pg_size = cpu_to_le16(PAGE_SHIFT -\n\t\t\t\t\t   RCFW_DBR_BASE_PAGE_SHIFT);\n\t \n\tif (is_virtfn)\n\t\tgoto skip_ctx_setup;\n\tif (bnxt_qplib_is_chip_gen_p5(rcfw->res->cctx))\n\t\tgoto config_vf_res;\n\n\tlvl = ctx->qpc_tbl.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->qpc_tbl);\n\treq.qpc_pg_size_qpc_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t   lvl;\n\tlvl = ctx->mrw_tbl.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->mrw_tbl);\n\treq.mrw_pg_size_mrw_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t   lvl;\n\tlvl = ctx->srqc_tbl.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->srqc_tbl);\n\treq.srq_pg_size_srq_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t   lvl;\n\tlvl = ctx->cq_tbl.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->cq_tbl);\n\treq.cq_pg_size_cq_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t lvl;\n\tlvl = ctx->tim_tbl.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->tim_tbl);\n\treq.tim_pg_size_tim_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t   lvl;\n\tlvl = ctx->tqm_ctx.pde.level;\n\tpgsz = bnxt_qplib_base_pg_size(&ctx->tqm_ctx.pde);\n\treq.tqm_pg_size_tqm_lvl = (pgsz << CMDQ_INITIALIZE_FW_QPC_PG_SIZE_SFT) |\n\t\t\t\t   lvl;\n\treq.qpc_page_dir =\n\t\tcpu_to_le64(ctx->qpc_tbl.pbl[PBL_LVL_0].pg_map_arr[0]);\n\treq.mrw_page_dir =\n\t\tcpu_to_le64(ctx->mrw_tbl.pbl[PBL_LVL_0].pg_map_arr[0]);\n\treq.srq_page_dir =\n\t\tcpu_to_le64(ctx->srqc_tbl.pbl[PBL_LVL_0].pg_map_arr[0]);\n\treq.cq_page_dir =\n\t\tcpu_to_le64(ctx->cq_tbl.pbl[PBL_LVL_0].pg_map_arr[0]);\n\treq.tim_page_dir =\n\t\tcpu_to_le64(ctx->tim_tbl.pbl[PBL_LVL_0].pg_map_arr[0]);\n\treq.tqm_page_dir =\n\t\tcpu_to_le64(ctx->tqm_ctx.pde.pbl[PBL_LVL_0].pg_map_arr[0]);\n\n\treq.number_of_qp = cpu_to_le32(ctx->qpc_tbl.max_elements);\n\treq.number_of_mrw = cpu_to_le32(ctx->mrw_tbl.max_elements);\n\treq.number_of_srq = cpu_to_le32(ctx->srqc_tbl.max_elements);\n\treq.number_of_cq = cpu_to_le32(ctx->cq_tbl.max_elements);\n\nconfig_vf_res:\n\treq.max_qp_per_vf = cpu_to_le32(ctx->vf_res.max_qp_per_vf);\n\treq.max_mrw_per_vf = cpu_to_le32(ctx->vf_res.max_mrw_per_vf);\n\treq.max_srq_per_vf = cpu_to_le32(ctx->vf_res.max_srq_per_vf);\n\treq.max_cq_per_vf = cpu_to_le32(ctx->vf_res.max_cq_per_vf);\n\treq.max_gid_per_vf = cpu_to_le32(ctx->vf_res.max_gid_per_vf);\n\nskip_ctx_setup:\n\treq.stat_ctx_id = cpu_to_le32(ctx->stats.fw_id);\n\tbnxt_qplib_fill_cmdqmsg(&msg, &req, &resp, NULL, sizeof(req), sizeof(resp), 0);\n\trc = bnxt_qplib_rcfw_send_message(rcfw, &msg);\n\tif (rc)\n\t\treturn rc;\n\tset_bit(FIRMWARE_INITIALIZED_FLAG, &rcfw->cmdq.flags);\n\treturn 0;\n}\n\nvoid bnxt_qplib_free_rcfw_channel(struct bnxt_qplib_rcfw *rcfw)\n{\n\tkfree(rcfw->qp_tbl);\n\tkfree(rcfw->crsqe_tbl);\n\tbnxt_qplib_free_hwq(rcfw->res, &rcfw->cmdq.hwq);\n\tbnxt_qplib_free_hwq(rcfw->res, &rcfw->creq.hwq);\n\trcfw->pdev = NULL;\n}\n\nint bnxt_qplib_alloc_rcfw_channel(struct bnxt_qplib_res *res,\n\t\t\t\t  struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t  struct bnxt_qplib_ctx *ctx,\n\t\t\t\t  int qp_tbl_sz)\n{\n\tstruct bnxt_qplib_hwq_attr hwq_attr = {};\n\tstruct bnxt_qplib_sg_info sginfo = {};\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_creq_ctx *creq;\n\n\trcfw->pdev = res->pdev;\n\tcmdq = &rcfw->cmdq;\n\tcreq = &rcfw->creq;\n\trcfw->res = res;\n\n\tsginfo.pgsize = PAGE_SIZE;\n\tsginfo.pgshft = PAGE_SHIFT;\n\n\thwq_attr.sginfo = &sginfo;\n\thwq_attr.res = rcfw->res;\n\thwq_attr.depth = BNXT_QPLIB_CREQE_MAX_CNT;\n\thwq_attr.stride = BNXT_QPLIB_CREQE_UNITS;\n\thwq_attr.type = bnxt_qplib_get_hwq_type(res);\n\n\tif (bnxt_qplib_alloc_init_hwq(&creq->hwq, &hwq_attr)) {\n\t\tdev_err(&rcfw->pdev->dev,\n\t\t\t\"HW channel CREQ allocation failed\\n\");\n\t\tgoto fail;\n\t}\n\n\trcfw->cmdq_depth = BNXT_QPLIB_CMDQE_MAX_CNT;\n\n\tsginfo.pgsize = bnxt_qplib_cmdqe_page_size(rcfw->cmdq_depth);\n\thwq_attr.depth = rcfw->cmdq_depth & 0x7FFFFFFF;\n\thwq_attr.stride = BNXT_QPLIB_CMDQE_UNITS;\n\thwq_attr.type = HWQ_TYPE_CTX;\n\tif (bnxt_qplib_alloc_init_hwq(&cmdq->hwq, &hwq_attr)) {\n\t\tdev_err(&rcfw->pdev->dev,\n\t\t\t\"HW channel CMDQ allocation failed\\n\");\n\t\tgoto fail;\n\t}\n\n\trcfw->crsqe_tbl = kcalloc(cmdq->hwq.max_elements,\n\t\t\t\t  sizeof(*rcfw->crsqe_tbl), GFP_KERNEL);\n\tif (!rcfw->crsqe_tbl)\n\t\tgoto fail;\n\n\t \n\trcfw->qp_tbl_size = qp_tbl_sz + 1;\n\trcfw->qp_tbl = kcalloc(rcfw->qp_tbl_size, sizeof(struct bnxt_qplib_qp_node),\n\t\t\t       GFP_KERNEL);\n\tif (!rcfw->qp_tbl)\n\t\tgoto fail;\n\n\trcfw->max_timeout = res->cctx->hwrm_cmd_max_timeout;\n\n\treturn 0;\n\nfail:\n\tbnxt_qplib_free_rcfw_channel(rcfw);\n\treturn -ENOMEM;\n}\n\nvoid bnxt_qplib_rcfw_stop_irq(struct bnxt_qplib_rcfw *rcfw, bool kill)\n{\n\tstruct bnxt_qplib_creq_ctx *creq;\n\n\tcreq = &rcfw->creq;\n\n\tif (!creq->requested)\n\t\treturn;\n\n\tcreq->requested = false;\n\t \n\tbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, rcfw->res->cctx, false);\n\t \n\tsynchronize_irq(creq->msix_vec);\n\tfree_irq(creq->msix_vec, rcfw);\n\tkfree(creq->irq_name);\n\tcreq->irq_name = NULL;\n\tatomic_set(&rcfw->rcfw_intr_enabled, 0);\n\tif (kill)\n\t\ttasklet_kill(&creq->creq_tasklet);\n\ttasklet_disable(&creq->creq_tasklet);\n}\n\nvoid bnxt_qplib_disable_rcfw_channel(struct bnxt_qplib_rcfw *rcfw)\n{\n\tstruct bnxt_qplib_creq_ctx *creq;\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\n\tcreq = &rcfw->creq;\n\tcmdq = &rcfw->cmdq;\n\t \n\tbnxt_qplib_rcfw_stop_irq(rcfw, true);\n\n\tiounmap(cmdq->cmdq_mbox.reg.bar_reg);\n\tiounmap(creq->creq_db.reg.bar_reg);\n\n\tcmdq->cmdq_mbox.reg.bar_reg = NULL;\n\tcreq->creq_db.reg.bar_reg = NULL;\n\tcreq->aeq_handler = NULL;\n\tcreq->msix_vec = 0;\n}\n\nint bnxt_qplib_rcfw_start_irq(struct bnxt_qplib_rcfw *rcfw, int msix_vector,\n\t\t\t      bool need_init)\n{\n\tstruct bnxt_qplib_creq_ctx *creq;\n\tstruct bnxt_qplib_res *res;\n\tint rc;\n\n\tcreq = &rcfw->creq;\n\tres = rcfw->res;\n\n\tif (creq->requested)\n\t\treturn -EFAULT;\n\n\tcreq->msix_vec = msix_vector;\n\tif (need_init)\n\t\ttasklet_setup(&creq->creq_tasklet, bnxt_qplib_service_creq);\n\telse\n\t\ttasklet_enable(&creq->creq_tasklet);\n\n\tcreq->irq_name = kasprintf(GFP_KERNEL, \"bnxt_re-creq@pci:%s\",\n\t\t\t\t   pci_name(res->pdev));\n\tif (!creq->irq_name)\n\t\treturn -ENOMEM;\n\trc = request_irq(creq->msix_vec, bnxt_qplib_creq_irq, 0,\n\t\t\t creq->irq_name, rcfw);\n\tif (rc) {\n\t\tkfree(creq->irq_name);\n\t\tcreq->irq_name = NULL;\n\t\ttasklet_disable(&creq->creq_tasklet);\n\t\treturn rc;\n\t}\n\tcreq->requested = true;\n\n\tbnxt_qplib_ring_nq_db(&creq->creq_db.dbinfo, res->cctx, true);\n\tatomic_inc(&rcfw->rcfw_intr_enabled);\n\n\treturn 0;\n}\n\nstatic int bnxt_qplib_map_cmdq_mbox(struct bnxt_qplib_rcfw *rcfw)\n{\n\tstruct bnxt_qplib_cmdq_mbox *mbox;\n\tresource_size_t bar_reg;\n\tstruct pci_dev *pdev;\n\n\tpdev = rcfw->pdev;\n\tmbox = &rcfw->cmdq.cmdq_mbox;\n\n\tmbox->reg.bar_id = RCFW_COMM_PCI_BAR_REGION;\n\tmbox->reg.len = RCFW_COMM_SIZE;\n\tmbox->reg.bar_base = pci_resource_start(pdev, mbox->reg.bar_id);\n\tif (!mbox->reg.bar_base) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"QPLIB: CMDQ BAR region %d resc start is 0!\\n\",\n\t\t\tmbox->reg.bar_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tbar_reg = mbox->reg.bar_base + RCFW_COMM_BASE_OFFSET;\n\tmbox->reg.len = RCFW_COMM_SIZE;\n\tmbox->reg.bar_reg = ioremap(bar_reg, mbox->reg.len);\n\tif (!mbox->reg.bar_reg) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"QPLIB: CMDQ BAR region %d mapping failed\\n\",\n\t\t\tmbox->reg.bar_id);\n\t\treturn -ENOMEM;\n\t}\n\n\tmbox->prod = (void  __iomem *)(mbox->reg.bar_reg +\n\t\t\tRCFW_PF_VF_COMM_PROD_OFFSET);\n\tmbox->db = (void __iomem *)(mbox->reg.bar_reg + RCFW_COMM_TRIG_OFFSET);\n\treturn 0;\n}\n\nstatic int bnxt_qplib_map_creq_db(struct bnxt_qplib_rcfw *rcfw, u32 reg_offt)\n{\n\tstruct bnxt_qplib_creq_db *creq_db;\n\tresource_size_t bar_reg;\n\tstruct pci_dev *pdev;\n\n\tpdev = rcfw->pdev;\n\tcreq_db = &rcfw->creq.creq_db;\n\n\tcreq_db->reg.bar_id = RCFW_COMM_CONS_PCI_BAR_REGION;\n\tcreq_db->reg.bar_base = pci_resource_start(pdev, creq_db->reg.bar_id);\n\tif (!creq_db->reg.bar_id)\n\t\tdev_err(&pdev->dev,\n\t\t\t\"QPLIB: CREQ BAR region %d resc start is 0!\",\n\t\t\tcreq_db->reg.bar_id);\n\n\tbar_reg = creq_db->reg.bar_base + reg_offt;\n\t \n\tcreq_db->reg.len = 8;\n\tcreq_db->reg.bar_reg = ioremap(bar_reg, creq_db->reg.len);\n\tif (!creq_db->reg.bar_reg) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"QPLIB: CREQ BAR region %d mapping failed\",\n\t\t\tcreq_db->reg.bar_id);\n\t\treturn -ENOMEM;\n\t}\n\tcreq_db->dbinfo.db = creq_db->reg.bar_reg;\n\tcreq_db->dbinfo.hwq = &rcfw->creq.hwq;\n\tcreq_db->dbinfo.xid = rcfw->creq.ring_id;\n\treturn 0;\n}\n\nstatic void bnxt_qplib_start_rcfw(struct bnxt_qplib_rcfw *rcfw)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_creq_ctx *creq;\n\tstruct bnxt_qplib_cmdq_mbox *mbox;\n\tstruct cmdq_init init = {0};\n\n\tcmdq = &rcfw->cmdq;\n\tcreq = &rcfw->creq;\n\tmbox = &cmdq->cmdq_mbox;\n\n\tinit.cmdq_pbl = cpu_to_le64(cmdq->hwq.pbl[PBL_LVL_0].pg_map_arr[0]);\n\tinit.cmdq_size_cmdq_lvl =\n\t\t\tcpu_to_le16(((rcfw->cmdq_depth <<\n\t\t\t\t      CMDQ_INIT_CMDQ_SIZE_SFT) &\n\t\t\t\t    CMDQ_INIT_CMDQ_SIZE_MASK) |\n\t\t\t\t    ((cmdq->hwq.level <<\n\t\t\t\t      CMDQ_INIT_CMDQ_LVL_SFT) &\n\t\t\t\t    CMDQ_INIT_CMDQ_LVL_MASK));\n\tinit.creq_ring_id = cpu_to_le16(creq->ring_id);\n\t \n\t__iowrite32_copy(mbox->reg.bar_reg, &init, sizeof(init) / 4);\n}\n\nint bnxt_qplib_enable_rcfw_channel(struct bnxt_qplib_rcfw *rcfw,\n\t\t\t\t   int msix_vector,\n\t\t\t\t   int cp_bar_reg_off,\n\t\t\t\t   aeq_handler_t aeq_handler)\n{\n\tstruct bnxt_qplib_cmdq_ctx *cmdq;\n\tstruct bnxt_qplib_creq_ctx *creq;\n\tint rc;\n\n\tcmdq = &rcfw->cmdq;\n\tcreq = &rcfw->creq;\n\n\t \n\n\tcmdq->seq_num = 0;\n\tset_bit(FIRMWARE_FIRST_FLAG, &cmdq->flags);\n\tinit_waitqueue_head(&cmdq->waitq);\n\n\tcreq->stats.creq_qp_event_processed = 0;\n\tcreq->stats.creq_func_event_processed = 0;\n\tcreq->aeq_handler = aeq_handler;\n\n\trc = bnxt_qplib_map_cmdq_mbox(rcfw);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_qplib_map_creq_db(rcfw, cp_bar_reg_off);\n\tif (rc)\n\t\treturn rc;\n\n\trc = bnxt_qplib_rcfw_start_irq(rcfw, msix_vector, true);\n\tif (rc) {\n\t\tdev_err(&rcfw->pdev->dev,\n\t\t\t\"Failed to request IRQ for CREQ rc = 0x%x\\n\", rc);\n\t\tbnxt_qplib_disable_rcfw_channel(rcfw);\n\t\treturn rc;\n\t}\n\n\tsema_init(&rcfw->rcfw_inflight, RCFW_CMD_NON_BLOCKING_SHADOW_QD);\n\tbnxt_qplib_start_rcfw(rcfw);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}