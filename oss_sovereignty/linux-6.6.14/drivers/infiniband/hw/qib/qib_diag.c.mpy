{
  "module_name": "qib_diag.c",
  "hash_id": "ab4226f0667579fd3c4c9fa94b163262173ce526c2bd0d0dd5dde2a37d78fb03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_diag.c",
  "human_readable_source": " \n\n \n\n#include <linux/io.h>\n#include <linux/pci.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n\n#include \"qib.h\"\n#include \"qib_common.h\"\n\n#undef pr_fmt\n#define pr_fmt(fmt) QIB_DRV_NAME \": \" fmt\n\n \nenum diag_state { UNUSED = 0, OPENED, INIT, READY };\n\n \nstatic struct qib_diag_client {\n\tstruct qib_diag_client *next;\n\tstruct qib_devdata *dd;\n\tpid_t pid;\n\tenum diag_state state;\n} *client_pool;\n\n \nstatic struct qib_diag_client *get_client(struct qib_devdata *dd)\n{\n\tstruct qib_diag_client *dc;\n\n\tdc = client_pool;\n\tif (dc)\n\t\t \n\t\tclient_pool = dc->next;\n\telse\n\t\t \n\t\tdc = kmalloc(sizeof(*dc), GFP_KERNEL);\n\n\tif (dc) {\n\t\tdc->next = NULL;\n\t\tdc->dd = dd;\n\t\tdc->pid = current->pid;\n\t\tdc->state = OPENED;\n\t}\n\treturn dc;\n}\n\n \nstatic void return_client(struct qib_diag_client *dc)\n{\n\tstruct qib_devdata *dd = dc->dd;\n\tstruct qib_diag_client *tdc, *rdc;\n\n\trdc = NULL;\n\tif (dc == dd->diag_client) {\n\t\tdd->diag_client = dc->next;\n\t\trdc = dc;\n\t} else {\n\t\ttdc = dc->dd->diag_client;\n\t\twhile (tdc) {\n\t\t\tif (dc == tdc->next) {\n\t\t\t\ttdc->next = dc->next;\n\t\t\t\trdc = dc;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttdc = tdc->next;\n\t\t}\n\t}\n\tif (rdc) {\n\t\trdc->state = UNUSED;\n\t\trdc->dd = NULL;\n\t\trdc->pid = 0;\n\t\trdc->next = client_pool;\n\t\tclient_pool = rdc;\n\t}\n}\n\nstatic int qib_diag_open(struct inode *in, struct file *fp);\nstatic int qib_diag_release(struct inode *in, struct file *fp);\nstatic ssize_t qib_diag_read(struct file *fp, char __user *data,\n\t\t\t     size_t count, loff_t *off);\nstatic ssize_t qib_diag_write(struct file *fp, const char __user *data,\n\t\t\t      size_t count, loff_t *off);\n\nstatic const struct file_operations diag_file_ops = {\n\t.owner = THIS_MODULE,\n\t.write = qib_diag_write,\n\t.read = qib_diag_read,\n\t.open = qib_diag_open,\n\t.release = qib_diag_release,\n\t.llseek = default_llseek,\n};\n\nstatic atomic_t diagpkt_count = ATOMIC_INIT(0);\nstatic struct cdev *diagpkt_cdev;\nstatic struct device *diagpkt_device;\n\nstatic ssize_t qib_diagpkt_write(struct file *fp, const char __user *data,\n\t\t\t\t size_t count, loff_t *off);\n\nstatic const struct file_operations diagpkt_file_ops = {\n\t.owner = THIS_MODULE,\n\t.write = qib_diagpkt_write,\n\t.llseek = noop_llseek,\n};\n\nint qib_diag_add(struct qib_devdata *dd)\n{\n\tchar name[16];\n\tint ret = 0;\n\n\tif (atomic_inc_return(&diagpkt_count) == 1) {\n\t\tret = qib_cdev_init(QIB_DIAGPKT_MINOR, \"ipath_diagpkt\",\n\t\t\t\t    &diagpkt_file_ops, &diagpkt_cdev,\n\t\t\t\t    &diagpkt_device);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tsnprintf(name, sizeof(name), \"ipath_diag%d\", dd->unit);\n\tret = qib_cdev_init(QIB_DIAG_MINOR_BASE + dd->unit, name,\n\t\t\t    &diag_file_ops, &dd->diag_cdev,\n\t\t\t    &dd->diag_device);\ndone:\n\treturn ret;\n}\n\nstatic void qib_unregister_observers(struct qib_devdata *dd);\n\nvoid qib_diag_remove(struct qib_devdata *dd)\n{\n\tstruct qib_diag_client *dc;\n\n\tif (atomic_dec_and_test(&diagpkt_count))\n\t\tqib_cdev_cleanup(&diagpkt_cdev, &diagpkt_device);\n\n\tqib_cdev_cleanup(&dd->diag_cdev, &dd->diag_device);\n\n\t \n\twhile (dd->diag_client)\n\t\treturn_client(dd->diag_client);\n\n\t \n\twhile (client_pool) {\n\t\tdc = client_pool;\n\t\tclient_pool = dc->next;\n\t\tkfree(dc);\n\t}\n\t \n\tqib_unregister_observers(dd);\n}\n\n \nstatic u32 __iomem *qib_remap_ioaddr32(struct qib_devdata *dd, u32 offset,\n\t\t\t\t       u32 *cntp)\n{\n\tu32 kreglen;\n\tu32 snd_bottom, snd_lim = 0;\n\tu32 __iomem *krb32 = (u32 __iomem *)dd->kregbase;\n\tu32 __iomem *map = NULL;\n\tu32 cnt = 0;\n\tu32 tot4k, offs4k;\n\n\t \n\tkreglen = (dd->kregend - dd->kregbase) * sizeof(u64);\n\tif (offset < kreglen) {\n\t\tmap = krb32 + (offset / sizeof(u32));\n\t\tcnt = kreglen - offset;\n\t\tgoto mapped;\n\t}\n\n\t \n\tif (dd->userbase) {\n\t\t \n\t\tu32 ulim = (dd->cfgctxts * dd->ureg_align) + dd->uregbase;\n\n\t\tif (!dd->piovl15base)\n\t\t\tsnd_lim = dd->uregbase;\n\t\tkrb32 = (u32 __iomem *)dd->userbase;\n\t\tif (offset >= dd->uregbase && offset < ulim) {\n\t\t\tmap = krb32 + (offset - dd->uregbase) / sizeof(u32);\n\t\t\tcnt = ulim - offset;\n\t\t\tgoto mapped;\n\t\t}\n\t}\n\n\t \n\t \n\tsnd_bottom = dd->pio2k_bufbase;\n\tif (snd_lim == 0) {\n\t\tu32 tot2k = dd->piobcnt2k * ALIGN(dd->piosize2k, dd->palign);\n\n\t\tsnd_lim = snd_bottom + tot2k;\n\t}\n\t \n\ttot4k = dd->piobcnt4k * dd->align4k;\n\toffs4k = dd->piobufbase >> 32;\n\tif (dd->piobcnt4k) {\n\t\tif (snd_bottom > offs4k)\n\t\t\tsnd_bottom = offs4k;\n\t\telse {\n\t\t\t \n\t\t\tif (!dd->userbase || dd->piovl15base)\n\t\t\t\tsnd_lim = offs4k + tot4k;\n\t\t}\n\t}\n\t \n\tif (offset >= snd_bottom && offset < snd_lim) {\n\t\toffset -= snd_bottom;\n\t\tmap = (u32 __iomem *)dd->piobase + (offset / sizeof(u32));\n\t\tcnt = snd_lim - offset;\n\t}\n\n\tif (!map && offs4k && dd->piovl15base) {\n\t\tsnd_lim = offs4k + tot4k + 2 * dd->align4k;\n\t\tif (offset >= (offs4k + tot4k) && offset < snd_lim) {\n\t\t\tmap = (u32 __iomem *)dd->piovl15base +\n\t\t\t\t((offset - (offs4k + tot4k)) / sizeof(u32));\n\t\t\tcnt = snd_lim - offset;\n\t\t}\n\t}\n\nmapped:\n\tif (cntp)\n\t\t*cntp = cnt;\n\treturn map;\n}\n\n \nstatic int qib_read_umem64(struct qib_devdata *dd, void __user *uaddr,\n\t\t\t   u32 regoffs, size_t count)\n{\n\tconst u64 __iomem *reg_addr;\n\tconst u64 __iomem *reg_end;\n\tu32 limit;\n\tint ret;\n\n\treg_addr = (const u64 __iomem *)qib_remap_ioaddr32(dd, regoffs, &limit);\n\tif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (count >= limit)\n\t\tcount = limit;\n\treg_end = reg_addr + (count / sizeof(u64));\n\n\t \n\twhile (reg_addr < reg_end) {\n\t\tu64 data = readq(reg_addr);\n\n\t\tif (copy_to_user(uaddr, &data, sizeof(u64))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto bail;\n\t\t}\n\t\treg_addr++;\n\t\tuaddr += sizeof(u64);\n\t}\n\tret = 0;\nbail:\n\treturn ret;\n}\n\n \n\nstatic int qib_write_umem64(struct qib_devdata *dd, u32 regoffs,\n\t\t\t    const void __user *uaddr, size_t count)\n{\n\tu64 __iomem *reg_addr;\n\tconst u64 __iomem *reg_end;\n\tu32 limit;\n\tint ret;\n\n\treg_addr = (u64 __iomem *)qib_remap_ioaddr32(dd, regoffs, &limit);\n\tif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (count >= limit)\n\t\tcount = limit;\n\treg_end = reg_addr + (count / sizeof(u64));\n\n\t \n\twhile (reg_addr < reg_end) {\n\t\tu64 data;\n\n\t\tif (copy_from_user(&data, uaddr, sizeof(data))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto bail;\n\t\t}\n\t\twriteq(data, reg_addr);\n\n\t\treg_addr++;\n\t\tuaddr += sizeof(u64);\n\t}\n\tret = 0;\nbail:\n\treturn ret;\n}\n\n \nstatic int qib_read_umem32(struct qib_devdata *dd, void __user *uaddr,\n\t\t\t   u32 regoffs, size_t count)\n{\n\tconst u32 __iomem *reg_addr;\n\tconst u32 __iomem *reg_end;\n\tu32 limit;\n\tint ret;\n\n\treg_addr = qib_remap_ioaddr32(dd, regoffs, &limit);\n\tif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (count >= limit)\n\t\tcount = limit;\n\treg_end = reg_addr + (count / sizeof(u32));\n\n\t \n\twhile (reg_addr < reg_end) {\n\t\tu32 data = readl(reg_addr);\n\n\t\tif (copy_to_user(uaddr, &data, sizeof(data))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto bail;\n\t\t}\n\n\t\treg_addr++;\n\t\tuaddr += sizeof(u32);\n\n\t}\n\tret = 0;\nbail:\n\treturn ret;\n}\n\n \n\nstatic int qib_write_umem32(struct qib_devdata *dd, u32 regoffs,\n\t\t\t    const void __user *uaddr, size_t count)\n{\n\tu32 __iomem *reg_addr;\n\tconst u32 __iomem *reg_end;\n\tu32 limit;\n\tint ret;\n\n\treg_addr = qib_remap_ioaddr32(dd, regoffs, &limit);\n\tif (reg_addr == NULL || limit == 0 || !(dd->flags & QIB_PRESENT)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (count >= limit)\n\t\tcount = limit;\n\treg_end = reg_addr + (count / sizeof(u32));\n\n\twhile (reg_addr < reg_end) {\n\t\tu32 data;\n\n\t\tif (copy_from_user(&data, uaddr, sizeof(data))) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto bail;\n\t\t}\n\t\twritel(data, reg_addr);\n\n\t\treg_addr++;\n\t\tuaddr += sizeof(u32);\n\t}\n\tret = 0;\nbail:\n\treturn ret;\n}\n\nstatic int qib_diag_open(struct inode *in, struct file *fp)\n{\n\tint unit = iminor(in) - QIB_DIAG_MINOR_BASE;\n\tstruct qib_devdata *dd;\n\tstruct qib_diag_client *dc;\n\tint ret;\n\n\tmutex_lock(&qib_mutex);\n\n\tdd = qib_lookup(unit);\n\n\tif (dd == NULL || !(dd->flags & QIB_PRESENT) ||\n\t    !dd->kregbase) {\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tdc = get_client(dd);\n\tif (!dc) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\tdc->next = dd->diag_client;\n\tdd->diag_client = dc;\n\tfp->private_data = dc;\n\tret = 0;\nbail:\n\tmutex_unlock(&qib_mutex);\n\n\treturn ret;\n}\n\n \nstatic ssize_t qib_diagpkt_write(struct file *fp,\n\t\t\t\t const char __user *data,\n\t\t\t\t size_t count, loff_t *off)\n{\n\tu32 __iomem *piobuf;\n\tu32 plen, pbufn, maxlen_reserve;\n\tstruct qib_diag_xpkt dp;\n\tu32 *tmpbuf = NULL;\n\tstruct qib_devdata *dd;\n\tstruct qib_pportdata *ppd;\n\tssize_t ret = 0;\n\n\tif (count != sizeof(dp)) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (copy_from_user(&dp, data, sizeof(dp))) {\n\t\tret = -EFAULT;\n\t\tgoto bail;\n\t}\n\n\tdd = qib_lookup(dp.unit);\n\tif (!dd || !(dd->flags & QIB_PRESENT) || !dd->kregbase) {\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\tif (!(dd->flags & QIB_INITTED)) {\n\t\t \n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tif (dp.version != _DIAG_XPKT_VERS) {\n\t\tqib_dev_err(dd, \"Invalid version %u for diagpkt_write\\n\",\n\t\t\t    dp.version);\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\t \n\tif (dp.len & 3) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tif (!dp.port || dp.port > dd->num_pports) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tppd = &dd->pport[dp.port - 1];\n\n\t \n\tmaxlen_reserve = 2 * sizeof(u32);\n\tif (dp.len > ppd->ibmaxlen - maxlen_reserve) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tplen = sizeof(u32) + dp.len;\n\n\ttmpbuf = vmalloc(plen);\n\tif (!tmpbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(tmpbuf,\n\t\t\t   u64_to_user_ptr(dp.data),\n\t\t\t   dp.len)) {\n\t\tret = -EFAULT;\n\t\tgoto bail;\n\t}\n\n\tplen >>= 2;              \n\n\tif (dp.pbc_wd == 0)\n\t\tdp.pbc_wd = plen;\n\n\tpiobuf = dd->f_getsendbuf(ppd, dp.pbc_wd, &pbufn);\n\tif (!piobuf) {\n\t\tret = -EBUSY;\n\t\tgoto bail;\n\t}\n\t \n\tdd->f_sendctrl(dd->pport, QIB_SENDCTRL_DISARM_BUF(pbufn));\n\n\t \n\tdd->f_txchk_change(dd, pbufn, 1, TXCHK_CHG_TYPE_DIS1, NULL);\n\n\twriteq(dp.pbc_wd, piobuf);\n\t \n\tif (dd->flags & QIB_PIO_FLUSH_WC) {\n\t\tqib_flush_wc();\n\t\tqib_pio_copy(piobuf + 2, tmpbuf, plen - 1);\n\t\tqib_flush_wc();\n\t\t__raw_writel(tmpbuf[plen - 1], piobuf + plen + 1);\n\t} else\n\t\tqib_pio_copy(piobuf + 2, tmpbuf, plen);\n\n\tif (dd->flags & QIB_USE_SPCL_TRIG) {\n\t\tu32 spcl_off = (pbufn >= dd->piobcnt2k) ? 2047 : 1023;\n\n\t\tqib_flush_wc();\n\t\t__raw_writel(0xaebecede, piobuf + spcl_off);\n\t}\n\n\t \n\tqib_flush_wc();\n\tqib_sendbuf_done(dd, pbufn);\n\tdd->f_txchk_change(dd, pbufn, 1, TXCHK_CHG_TYPE_ENAB1, NULL);\n\n\tret = sizeof(dp);\n\nbail:\n\tvfree(tmpbuf);\n\treturn ret;\n}\n\nstatic int qib_diag_release(struct inode *in, struct file *fp)\n{\n\tmutex_lock(&qib_mutex);\n\treturn_client(fp->private_data);\n\tfp->private_data = NULL;\n\tmutex_unlock(&qib_mutex);\n\treturn 0;\n}\n\n \nstruct diag_observer_list_elt {\n\tstruct diag_observer_list_elt *next;\n\tconst struct diag_observer *op;\n};\n\nint qib_register_observer(struct qib_devdata *dd,\n\t\t\t  const struct diag_observer *op)\n{\n\tstruct diag_observer_list_elt *olp;\n\tunsigned long flags;\n\n\tif (!dd || !op)\n\t\treturn -EINVAL;\n\tolp = vmalloc(sizeof(*olp));\n\tif (!olp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\n\tolp->op = op;\n\tolp->next = dd->diag_observer_list;\n\tdd->diag_observer_list = olp;\n\tspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void qib_unregister_observers(struct qib_devdata *dd)\n{\n\tstruct diag_observer_list_elt *olp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\n\tolp = dd->diag_observer_list;\n\twhile (olp) {\n\t\t \n\t\tdd->diag_observer_list = olp->next;\n\t\tspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\n\t\tvfree(olp);\n\t\t \n\t\tspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\n\t\tolp = dd->diag_observer_list;\n\t}\n\tspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\n}\n\n \nstatic const struct diag_observer *diag_get_observer(struct qib_devdata *dd,\n\t\t\t\t\t\t     u32 addr)\n{\n\tstruct diag_observer_list_elt *olp;\n\tconst struct diag_observer *op = NULL;\n\n\tolp = dd->diag_observer_list;\n\twhile (olp) {\n\t\top = olp->op;\n\t\tif (addr >= op->bottom && addr <= op->top)\n\t\t\tbreak;\n\t\tolp = olp->next;\n\t}\n\tif (!olp)\n\t\top = NULL;\n\n\treturn op;\n}\n\nstatic ssize_t qib_diag_read(struct file *fp, char __user *data,\n\t\t\t     size_t count, loff_t *off)\n{\n\tstruct qib_diag_client *dc = fp->private_data;\n\tstruct qib_devdata *dd = dc->dd;\n\tssize_t ret;\n\n\tif (dc->pid != current->pid) {\n\t\tret = -EPERM;\n\t\tgoto bail;\n\t}\n\n\tif (count == 0)\n\t\tret = 0;\n\telse if ((count % 4) || (*off % 4))\n\t\t \n\t\tret = -EINVAL;\n\telse if (dc->state < READY && (*off || count != 8))\n\t\tret = -EINVAL;   \n\telse {\n\t\tunsigned long flags;\n\t\tu64 data64 = 0;\n\t\tint use_32;\n\t\tconst struct diag_observer *op;\n\n\t\tuse_32 = (count % 8) || (*off % 8);\n\t\tret = -1;\n\t\tspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\n\t\t \n\t\top = diag_get_observer(dd, *off);\n\t\tif (op) {\n\t\t\tu32 offset = *off;\n\n\t\t\tret = op->hook(dd, op, offset, &data64, 0, use_32);\n\t\t}\n\t\t \n\t\tspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\n\t\tif (!op) {\n\t\t\tif (use_32)\n\t\t\t\t \n\t\t\t\tret = qib_read_umem32(dd, data, (u32) *off,\n\t\t\t\t\t\t      count);\n\t\t\telse\n\t\t\t\tret = qib_read_umem64(dd, data, (u32) *off,\n\t\t\t\t\t\t      count);\n\t\t} else if (ret == count) {\n\t\t\t \n\t\t\tret = copy_to_user(data, &data64, use_32 ?\n\t\t\t\t\t   sizeof(u32) : sizeof(u64));\n\t\t\tif (ret)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t}\n\n\tif (ret >= 0) {\n\t\t*off += count;\n\t\tret = count;\n\t\tif (dc->state == OPENED)\n\t\t\tdc->state = INIT;\n\t}\nbail:\n\treturn ret;\n}\n\nstatic ssize_t qib_diag_write(struct file *fp, const char __user *data,\n\t\t\t      size_t count, loff_t *off)\n{\n\tstruct qib_diag_client *dc = fp->private_data;\n\tstruct qib_devdata *dd = dc->dd;\n\tssize_t ret;\n\n\tif (dc->pid != current->pid) {\n\t\tret = -EPERM;\n\t\tgoto bail;\n\t}\n\n\tif (count == 0)\n\t\tret = 0;\n\telse if ((count % 4) || (*off % 4))\n\t\t \n\t\tret = -EINVAL;\n\telse if (dc->state < READY &&\n\t\t((*off || count != 8) || dc->state != INIT))\n\t\t \n\t\tret = -EINVAL;   \n\telse {\n\t\tunsigned long flags;\n\t\tconst struct diag_observer *op = NULL;\n\t\tint use_32 =  (count % 8) || (*off % 8);\n\n\t\t \n\t\tif (count == 4 || count == 8) {\n\t\t\tu64 data64;\n\t\t\tu32 offset = *off;\n\n\t\t\tret = copy_from_user(&data64, data, count);\n\t\t\tif (ret) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&dd->qib_diag_trans_lock, flags);\n\t\t\top = diag_get_observer(dd, *off);\n\t\t\tif (op)\n\t\t\t\tret = op->hook(dd, op, offset, &data64, ~0Ull,\n\t\t\t\t\t       use_32);\n\t\t\tspin_unlock_irqrestore(&dd->qib_diag_trans_lock, flags);\n\t\t}\n\n\t\tif (!op) {\n\t\t\tif (use_32)\n\t\t\t\t \n\t\t\t\tret = qib_write_umem32(dd, (u32) *off, data,\n\t\t\t\t\t\t       count);\n\t\t\telse\n\t\t\t\tret = qib_write_umem64(dd, (u32) *off, data,\n\t\t\t\t\t\t       count);\n\t\t}\n\t}\n\n\tif (ret >= 0) {\n\t\t*off += count;\n\t\tret = count;\n\t\tif (dc->state == INIT)\n\t\t\tdc->state = READY;  \n\t}\nbail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}