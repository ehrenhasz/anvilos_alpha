{
  "module_name": "qib_fs.c",
  "hash_id": "baaa1c6d582338246b8ac02e249f6ff8929246b7129de7bb1f86be996d47a7de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_fs.c",
  "human_readable_source": " \n\n#include <linux/fs.h>\n#include <linux/fs_context.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/init.h>\n#include <linux/namei.h>\n\n#include \"qib.h\"\n\n#define QIBFS_MAGIC 0x726a77\n\nstatic struct super_block *qib_super;\n\n#define private2dd(file) (file_inode(file)->i_private)\n\nstatic int qibfs_mknod(struct inode *dir, struct dentry *dentry,\n\t\t       umode_t mode, const struct file_operations *fops,\n\t\t       void *data)\n{\n\tint error;\n\tstruct inode *inode = new_inode(dir->i_sb);\n\n\tif (!inode) {\n\t\terror = -EPERM;\n\t\tgoto bail;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = GLOBAL_ROOT_UID;\n\tinode->i_gid = GLOBAL_ROOT_GID;\n\tinode->i_blocks = 0;\n\tinode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_mtime = inode->i_atime;\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t}\n\n\tinode->i_fop = fops;\n\n\td_instantiate(dentry, inode);\n\terror = 0;\n\nbail:\n\treturn error;\n}\n\nstatic int create_file(const char *name, umode_t mode,\n\t\t       struct dentry *parent, struct dentry **dentry,\n\t\t       const struct file_operations *fops, void *data)\n{\n\tint error;\n\n\tinode_lock(d_inode(parent));\n\t*dentry = lookup_one_len(name, parent, strlen(name));\n\tif (!IS_ERR(*dentry))\n\t\terror = qibfs_mknod(d_inode(parent), *dentry,\n\t\t\t\t    mode, fops, data);\n\telse\n\t\terror = PTR_ERR(*dentry);\n\tinode_unlock(d_inode(parent));\n\n\treturn error;\n}\n\nstatic ssize_t driver_stats_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tqib_stats.sps_ints = qib_sps_ints();\n\treturn simple_read_from_buffer(buf, count, ppos, &qib_stats,\n\t\t\t\t       sizeof(qib_stats));\n}\n\n \nstatic const char qib_statnames[] =\n\t\"KernIntr\\n\"\n\t\"ErrorIntr\\n\"\n\t\"Tx_Errs\\n\"\n\t\"Rcv_Errs\\n\"\n\t\"H/W_Errs\\n\"\n\t\"NoPIOBufs\\n\"\n\t\"CtxtsOpen\\n\"\n\t\"RcvLen_Errs\\n\"\n\t\"EgrBufFull\\n\"\n\t\"EgrHdrFull\\n\"\n\t;\n\nstatic ssize_t driver_names_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, count, ppos, qib_statnames,\n\t\tsizeof(qib_statnames) - 1);  \n}\n\nstatic const struct file_operations driver_ops[] = {\n\t{ .read = driver_stats_read, .llseek = generic_file_llseek, },\n\t{ .read = driver_names_read, .llseek = generic_file_llseek, },\n};\n\n \nstatic ssize_t dev_counters_read(struct file *file, char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tu64 *counters;\n\tsize_t avail;\n\tstruct qib_devdata *dd = private2dd(file);\n\n\tavail = dd->f_read_cntrs(dd, *ppos, NULL, &counters);\n\treturn simple_read_from_buffer(buf, count, ppos, counters, avail);\n}\n\n \nstatic ssize_t dev_names_read(struct file *file, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *names;\n\tsize_t avail;\n\tstruct qib_devdata *dd = private2dd(file);\n\n\tavail = dd->f_read_cntrs(dd, *ppos, &names, NULL);\n\treturn simple_read_from_buffer(buf, count, ppos, names, avail);\n}\n\nstatic const struct file_operations cntr_ops[] = {\n\t{ .read = dev_counters_read, .llseek = generic_file_llseek, },\n\t{ .read = dev_names_read, .llseek = generic_file_llseek, },\n};\n\n \n\n \nstatic ssize_t portnames_read(struct file *file, char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *names;\n\tsize_t avail;\n\tstruct qib_devdata *dd = private2dd(file);\n\n\tavail = dd->f_read_portcntrs(dd, *ppos, 0, &names, NULL);\n\treturn simple_read_from_buffer(buf, count, ppos, names, avail);\n}\n\n \nstatic ssize_t portcntrs_1_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu64 *counters;\n\tsize_t avail;\n\tstruct qib_devdata *dd = private2dd(file);\n\n\tavail = dd->f_read_portcntrs(dd, *ppos, 0, NULL, &counters);\n\treturn simple_read_from_buffer(buf, count, ppos, counters, avail);\n}\n\n \nstatic ssize_t portcntrs_2_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tu64 *counters;\n\tsize_t avail;\n\tstruct qib_devdata *dd = private2dd(file);\n\n\tavail = dd->f_read_portcntrs(dd, *ppos, 1, NULL, &counters);\n\treturn simple_read_from_buffer(buf, count, ppos, counters, avail);\n}\n\nstatic const struct file_operations portcntr_ops[] = {\n\t{ .read = portnames_read, .llseek = generic_file_llseek, },\n\t{ .read = portcntrs_1_read, .llseek = generic_file_llseek, },\n\t{ .read = portcntrs_2_read, .llseek = generic_file_llseek, },\n};\n\n \nstatic ssize_t qsfp_1_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct qib_devdata *dd = private2dd(file);\n\tchar *tmp;\n\tint ret;\n\n\ttmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = qib_qsfp_dump(dd->pport, tmp, PAGE_SIZE);\n\tif (ret > 0)\n\t\tret = simple_read_from_buffer(buf, count, ppos, tmp, ret);\n\tkfree(tmp);\n\treturn ret;\n}\n\n \nstatic ssize_t qsfp_2_read(struct file *file, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct qib_devdata *dd = private2dd(file);\n\tchar *tmp;\n\tint ret;\n\n\tif (dd->num_pports < 2)\n\t\treturn -ENODEV;\n\n\ttmp = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\tret = qib_qsfp_dump(dd->pport + 1, tmp, PAGE_SIZE);\n\tif (ret > 0)\n\t\tret = simple_read_from_buffer(buf, count, ppos, tmp, ret);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic const struct file_operations qsfp_ops[] = {\n\t{ .read = qsfp_1_read, .llseek = generic_file_llseek, },\n\t{ .read = qsfp_2_read, .llseek = generic_file_llseek, },\n};\n\nstatic ssize_t flash_read(struct file *file, char __user *buf,\n\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct qib_devdata *dd;\n\tssize_t ret;\n\tloff_t pos;\n\tchar *tmp;\n\n\tpos = *ppos;\n\n\tif (pos < 0) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tif (pos >= sizeof(struct qib_flash)) {\n\t\tret = 0;\n\t\tgoto bail;\n\t}\n\n\tif (count > sizeof(struct qib_flash) - pos)\n\t\tcount = sizeof(struct qib_flash) - pos;\n\n\ttmp = kmalloc(count, GFP_KERNEL);\n\tif (!tmp) {\n\t\tret = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tdd = private2dd(file);\n\tif (qib_eeprom_read(dd, pos, tmp, count)) {\n\t\tqib_dev_err(dd, \"failed to read from flash\\n\");\n\t\tret = -ENXIO;\n\t\tgoto bail_tmp;\n\t}\n\n\tif (copy_to_user(buf, tmp, count)) {\n\t\tret = -EFAULT;\n\t\tgoto bail_tmp;\n\t}\n\n\t*ppos = pos + count;\n\tret = count;\n\nbail_tmp:\n\tkfree(tmp);\n\nbail:\n\treturn ret;\n}\n\nstatic ssize_t flash_write(struct file *file, const char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct qib_devdata *dd;\n\tssize_t ret;\n\tloff_t pos;\n\tchar *tmp;\n\n\tpos = *ppos;\n\n\tif (pos != 0 || count != sizeof(struct qib_flash))\n\t\treturn -EINVAL;\n\n\ttmp = memdup_user(buf, count);\n\tif (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\n\tdd = private2dd(file);\n\tif (qib_eeprom_write(dd, pos, tmp, count)) {\n\t\tret = -ENXIO;\n\t\tqib_dev_err(dd, \"failed to write to flash\\n\");\n\t\tgoto bail_tmp;\n\t}\n\n\t*ppos = pos + count;\n\tret = count;\n\nbail_tmp:\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic const struct file_operations flash_ops = {\n\t.read = flash_read,\n\t.write = flash_write,\n\t.llseek = default_llseek,\n};\n\nstatic int add_cntr_files(struct super_block *sb, struct qib_devdata *dd)\n{\n\tstruct dentry *dir, *tmp;\n\tchar unit[10];\n\tint ret, i;\n\n\t \n\tsnprintf(unit, sizeof(unit), \"%u\", dd->unit);\n\tret = create_file(unit, S_IFDIR|S_IRUGO|S_IXUGO, sb->s_root, &dir,\n\t\t\t  &simple_dir_operations, dd);\n\tif (ret) {\n\t\tpr_err(\"create_file(%s) failed: %d\\n\", unit, ret);\n\t\tgoto bail;\n\t}\n\n\t \n\tret = create_file(\"counters\", S_IFREG|S_IRUGO, dir, &tmp,\n\t\t\t  &cntr_ops[0], dd);\n\tif (ret) {\n\t\tpr_err(\"create_file(%s/counters) failed: %d\\n\",\n\t\t       unit, ret);\n\t\tgoto bail;\n\t}\n\tret = create_file(\"counter_names\", S_IFREG|S_IRUGO, dir, &tmp,\n\t\t\t  &cntr_ops[1], dd);\n\tif (ret) {\n\t\tpr_err(\"create_file(%s/counter_names) failed: %d\\n\",\n\t\t       unit, ret);\n\t\tgoto bail;\n\t}\n\tret = create_file(\"portcounter_names\", S_IFREG|S_IRUGO, dir, &tmp,\n\t\t\t  &portcntr_ops[0], dd);\n\tif (ret) {\n\t\tpr_err(\"create_file(%s/%s) failed: %d\\n\",\n\t\t       unit, \"portcounter_names\", ret);\n\t\tgoto bail;\n\t}\n\tfor (i = 1; i <= dd->num_pports; i++) {\n\t\tchar fname[24];\n\n\t\tsprintf(fname, \"port%dcounters\", i);\n\t\t \n\t\tret = create_file(fname, S_IFREG|S_IRUGO, dir, &tmp,\n\t\t\t\t  &portcntr_ops[i], dd);\n\t\tif (ret) {\n\t\t\tpr_err(\"create_file(%s/%s) failed: %d\\n\",\n\t\t\t\tunit, fname, ret);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!(dd->flags & QIB_HAS_QSFP))\n\t\t\tcontinue;\n\t\tsprintf(fname, \"qsfp%d\", i);\n\t\tret = create_file(fname, S_IFREG|S_IRUGO, dir, &tmp,\n\t\t\t\t  &qsfp_ops[i - 1], dd);\n\t\tif (ret) {\n\t\t\tpr_err(\"create_file(%s/%s) failed: %d\\n\",\n\t\t\t\tunit, fname, ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = create_file(\"flash\", S_IFREG|S_IWUSR|S_IRUGO, dir, &tmp,\n\t\t\t  &flash_ops, dd);\n\tif (ret)\n\t\tpr_err(\"create_file(%s/flash) failed: %d\\n\",\n\t\t\tunit, ret);\nbail:\n\treturn ret;\n}\n\nstatic int remove_device_files(struct super_block *sb,\n\t\t\t       struct qib_devdata *dd)\n{\n\tstruct dentry *dir;\n\tchar unit[10];\n\n\tsnprintf(unit, sizeof(unit), \"%u\", dd->unit);\n\tdir = lookup_one_len_unlocked(unit, sb->s_root, strlen(unit));\n\n\tif (IS_ERR(dir)) {\n\t\tpr_err(\"Lookup of %s failed\\n\", unit);\n\t\treturn PTR_ERR(dir);\n\t}\n\tsimple_recursive_removal(dir, NULL);\n\treturn 0;\n}\n\n \nstatic int qibfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tstruct qib_devdata *dd;\n\tunsigned long index;\n\tint ret;\n\n\tstatic const struct tree_descr files[] = {\n\t\t[2] = {\"driver_stats\", &driver_ops[0], S_IRUGO},\n\t\t[3] = {\"driver_stats_names\", &driver_ops[1], S_IRUGO},\n\t\t{\"\"},\n\t};\n\n\tret = simple_fill_super(sb, QIBFS_MAGIC, files);\n\tif (ret) {\n\t\tpr_err(\"simple_fill_super failed: %d\\n\", ret);\n\t\tgoto bail;\n\t}\n\n\txa_for_each(&qib_dev_table, index, dd) {\n\t\tret = add_cntr_files(sb, dd);\n\t\tif (ret)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn ret;\n}\n\nstatic int qibfs_get_tree(struct fs_context *fc)\n{\n\tint ret = get_tree_single(fc, qibfs_fill_super);\n\tif (ret == 0)\n\t\tqib_super = fc->root->d_sb;\n\treturn ret;\n}\n\nstatic const struct fs_context_operations qibfs_context_ops = {\n\t.get_tree\t= qibfs_get_tree,\n};\n\nstatic int qibfs_init_fs_context(struct fs_context *fc)\n{\n\tfc->ops = &qibfs_context_ops;\n\treturn 0;\n}\n\nstatic void qibfs_kill_super(struct super_block *s)\n{\n\tkill_litter_super(s);\n\tqib_super = NULL;\n}\n\nint qibfs_add(struct qib_devdata *dd)\n{\n\tint ret;\n\n\t \n\tif (qib_super == NULL)\n\t\tret = 0;\n\telse\n\t\tret = add_cntr_files(qib_super, dd);\n\treturn ret;\n}\n\nint qibfs_remove(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\n\tif (qib_super)\n\t\tret = remove_device_files(qib_super, dd);\n\n\treturn ret;\n}\n\nstatic struct file_system_type qibfs_fs_type = {\n\t.owner =        THIS_MODULE,\n\t.name =         \"ipathfs\",\n\t.init_fs_context = qibfs_init_fs_context,\n\t.kill_sb =      qibfs_kill_super,\n};\nMODULE_ALIAS_FS(\"ipathfs\");\n\nint __init qib_init_qibfs(void)\n{\n\treturn register_filesystem(&qibfs_fs_type);\n}\n\nint __exit qib_exit_qibfs(void)\n{\n\treturn unregister_filesystem(&qibfs_fs_type);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}