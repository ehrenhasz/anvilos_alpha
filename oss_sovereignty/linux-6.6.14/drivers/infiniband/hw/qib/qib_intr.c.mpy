{
  "module_name": "qib_intr.c",
  "hash_id": "665628008bebcf33851135542759ac4ee72e7a9102d4431227c0e73cadd84ce6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_intr.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"qib.h\"\n#include \"qib_common.h\"\n\n \nstatic void qib_format_hwmsg(char *msg, size_t msgl, const char *hwmsg)\n{\n\tstrlcat(msg, \"[\", msgl);\n\tstrlcat(msg, hwmsg, msgl);\n\tstrlcat(msg, \"]\", msgl);\n}\n\n \nvoid qib_format_hwerrors(u64 hwerrs, const struct qib_hwerror_msgs *hwerrmsgs,\n\t\t\t size_t nhwerrmsgs, char *msg, size_t msgl)\n{\n\tint i;\n\n\tfor (i = 0; i < nhwerrmsgs; i++)\n\t\tif (hwerrs & hwerrmsgs[i].mask)\n\t\t\tqib_format_hwmsg(msg, msgl, hwerrmsgs[i].msg);\n}\n\nstatic void signal_ib_event(struct qib_pportdata *ppd, enum ib_event_type ev)\n{\n\tstruct ib_event event;\n\tstruct qib_devdata *dd = ppd->dd;\n\n\tevent.device = &dd->verbs_dev.rdi.ibdev;\n\tevent.element.port_num = ppd->port;\n\tevent.event = ev;\n\tib_dispatch_event(&event);\n}\n\nvoid qib_handle_e_ibstatuschanged(struct qib_pportdata *ppd, u64 ibcs)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\tu32 lstate;\n\tu8 ltstate;\n\tenum ib_event_type ev = 0;\n\n\tlstate = dd->f_iblink_state(ibcs);  \n\tltstate = dd->f_ibphys_portstate(ibcs);\n\n\t \n\tif (lstate >= IB_PORT_INIT &&\n\t    (!ppd->lflags || (ppd->lflags & QIBL_LINKDOWN)) &&\n\t    ltstate == IB_PHYSPORTSTATE_LINKUP) {\n\t\t \n\t\tif (dd->f_ib_updown(ppd, 1, ibcs))\n\t\t\tgoto skip_ibchange;  \n\t} else if (ppd->lflags & (QIBL_LINKINIT | QIBL_LINKARMED |\n\t\t   QIBL_LINKACTIVE | QIBL_IB_FORCE_NOTIFY)) {\n\t\tif (ltstate != IB_PHYSPORTSTATE_LINKUP &&\n\t\t    ltstate <= IB_PHYSPORTSTATE_CFG_TRAIN &&\n\t\t    dd->f_ib_updown(ppd, 0, ibcs))\n\t\t\tgoto skip_ibchange;  \n\t\tqib_set_uevent_bits(ppd, _QIB_EVENT_LINKDOWN_BIT);\n\t}\n\n\tif (lstate != IB_PORT_DOWN) {\n\t\t \n\t\tif (lstate != IB_PORT_ACTIVE) {\n\t\t\t*ppd->statusp &= ~QIB_STATUS_IB_READY;\n\t\t\tif (ppd->lflags & QIBL_LINKACTIVE)\n\t\t\t\tev = IB_EVENT_PORT_ERR;\n\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\tif (lstate == IB_PORT_ARMED) {\n\t\t\t\tppd->lflags |= QIBL_LINKARMED | QIBL_LINKV;\n\t\t\t\tppd->lflags &= ~(QIBL_LINKINIT |\n\t\t\t\t\tQIBL_LINKDOWN | QIBL_LINKACTIVE);\n\t\t\t} else {\n\t\t\t\tppd->lflags |= QIBL_LINKINIT | QIBL_LINKV;\n\t\t\t\tppd->lflags &= ~(QIBL_LINKARMED |\n\t\t\t\t\tQIBL_LINKDOWN | QIBL_LINKACTIVE);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\t\t \n\t\t\tmod_timer(&ppd->symerr_clear_timer,\n\t\t\t\t  msecs_to_jiffies(75));\n\t\t} else if (ltstate == IB_PHYSPORTSTATE_LINKUP &&\n\t\t\t   !(ppd->lflags & QIBL_LINKACTIVE)) {\n\t\t\t \n\t\t\tqib_hol_up(ppd);  \n\t\t\t*ppd->statusp |=\n\t\t\t\tQIB_STATUS_IB_READY | QIB_STATUS_IB_CONF;\n\t\t\tqib_clear_symerror_on_linkup(&ppd->symerr_clear_timer);\n\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\tppd->lflags |= QIBL_LINKACTIVE | QIBL_LINKV;\n\t\t\tppd->lflags &= ~(QIBL_LINKINIT |\n\t\t\t\tQIBL_LINKDOWN | QIBL_LINKARMED);\n\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\t\tif (dd->flags & QIB_HAS_SEND_DMA)\n\t\t\t\tqib_sdma_process_event(ppd,\n\t\t\t\t\tqib_sdma_event_e30_go_running);\n\t\t\tev = IB_EVENT_PORT_ACTIVE;\n\t\t\tdd->f_setextled(ppd, 1);\n\t\t}\n\t} else {  \n\t\tif (ppd->lflags & QIBL_LINKACTIVE)\n\t\t\tev = IB_EVENT_PORT_ERR;\n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags |= QIBL_LINKDOWN | QIBL_LINKV;\n\t\tppd->lflags &= ~(QIBL_LINKINIT |\n\t\t\t\t QIBL_LINKACTIVE | QIBL_LINKARMED);\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\t*ppd->statusp &= ~QIB_STATUS_IB_READY;\n\t}\n\nskip_ibchange:\n\tppd->lastibcstat = ibcs;\n\tif (ev)\n\t\tsignal_ib_event(ppd, ev);\n}\n\nvoid qib_clear_symerror_on_linkup(struct timer_list *t)\n{\n\tstruct qib_pportdata *ppd = from_timer(ppd, t, symerr_clear_timer);\n\n\tif (ppd->lflags & QIBL_LINKACTIVE)\n\t\treturn;\n\n\tppd->ibport_data.z_symbol_error_counter =\n\t\tppd->dd->f_portcntr(ppd, QIBPORTCNTR_IBSYMBOLERR);\n}\n\n \nvoid qib_handle_urcv(struct qib_devdata *dd, u64 ctxtr)\n{\n\tstruct qib_ctxtdata *rcd;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\tfor (i = dd->first_user_ctxt; dd->rcd && i < dd->cfgctxts; i++) {\n\t\tif (!(ctxtr & (1ULL << i)))\n\t\t\tcontinue;\n\t\trcd = dd->rcd[i];\n\t\tif (!rcd || !rcd->cnt)\n\t\t\tcontinue;\n\n\t\tif (test_and_clear_bit(QIB_CTXT_WAITING_RCV, &rcd->flag)) {\n\t\t\twake_up_interruptible(&rcd->wait);\n\t\t\tdd->f_rcvctrl(rcd->ppd, QIB_RCVCTRL_INTRAVAIL_DIS,\n\t\t\t\t      rcd->ctxt);\n\t\t} else if (test_and_clear_bit(QIB_CTXT_WAITING_URG,\n\t\t\t\t\t      &rcd->flag)) {\n\t\t\trcd->urgent++;\n\t\t\twake_up_interruptible(&rcd->wait);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n}\n\nvoid qib_bad_intrstatus(struct qib_devdata *dd)\n{\n\tstatic int allbits;\n\n\t \n\n\t \n\tqib_dev_err(dd,\n\t\t\"Read of chip interrupt status failed disabling interrupts\\n\");\n\tif (allbits++) {\n\t\t \n\t\tif (allbits == 2)\n\t\t\tdd->f_set_intr_state(dd, 0);\n\t\tif (allbits == 3) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"2nd bad interrupt status, unregistering interrupts\\n\");\n\t\t\tdd->flags |= QIB_BADINTR;\n\t\t\tdd->flags &= ~QIB_INITTED;\n\t\t\tdd->f_free_irq(dd);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}