{
  "module_name": "qib_sysfs.c",
  "hash_id": "a65294cdee3a9f5adc7e8c0dbd00e97c1ba087af054d18103ff415fd063dcb8d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_sysfs.c",
  "human_readable_source": " \n#include <linux/ctype.h>\n#include <rdma/ib_sysfs.h>\n\n#include \"qib.h\"\n#include \"qib_mad.h\"\n\nstatic struct qib_pportdata *qib_get_pportdata_kobj(struct kobject *kobj)\n{\n\tu32 port_num;\n\tstruct ib_device *ibdev = ib_port_sysfs_get_ibdev_kobj(kobj, &port_num);\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\n\treturn &dd->pport[port_num - 1];\n}\n\n \nstatic ssize_t hrtbt_enable_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\n\treturn sysfs_emit(buf, \"%d\\n\", dd->f_get_ib_cfg(ppd, QIB_IB_CFG_HRTBT));\n}\n\nstatic ssize_t hrtbt_enable_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t  struct ib_port_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\tint ret;\n\tu16 val;\n\n\tret = kstrtou16(buf, 0, &val);\n\tif (ret) {\n\t\tqib_dev_err(dd, \"attempt to set invalid Heartbeat enable\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = dd->f_set_ib_cfg(ppd, QIB_IB_CFG_HRTBT, val);\n\treturn ret < 0 ? ret : count;\n}\nstatic IB_PORT_ATTR_RW(hrtbt_enable);\n\nstatic ssize_t loopback_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t      struct ib_port_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\tint ret = count, r;\n\n\tr = dd->f_set_ib_loopback(ppd, buf);\n\tif (r < 0)\n\t\tret = r;\n\n\treturn ret;\n}\nstatic IB_PORT_ATTR_WO(loopback);\n\nstatic ssize_t led_override_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t  struct ib_port_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\tint ret;\n\tu16 val;\n\n\tret = kstrtou16(buf, 0, &val);\n\tif (ret) {\n\t\tqib_dev_err(dd, \"attempt to set invalid LED override\\n\");\n\t\treturn ret;\n\t}\n\n\tqib_set_led_override(ppd, val);\n\treturn count;\n}\nstatic IB_PORT_ATTR_WO(led_override);\n\nstatic ssize_t status_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t   struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\n\tif (!ppd->statusp)\n\t\treturn -EINVAL;\n\n\treturn sysfs_emit(buf, \"0x%llx\\n\", (unsigned long long)*(ppd->statusp));\n}\nstatic IB_PORT_ATTR_RO(status);\n\n \nstatic const char * const qib_status_str[] = {\n\t\"Initted\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"\",\n\t\"Present\",\n\t\"IB_link_up\",\n\t\"IB_configured\",\n\t\"\",\n\t\"Fatal_Hardware_Error\",\n\tNULL,\n};\n\nstatic ssize_t status_str_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_pportdata *ppd = &dd->pport[port_num - 1];\n\tint i, any;\n\tu64 s;\n\tssize_t ret;\n\n\tif (!ppd->statusp) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\ts = *(ppd->statusp);\n\t*buf = '\\0';\n\tfor (any = i = 0; s && qib_status_str[i]; i++) {\n\t\tif (s & 1) {\n\t\t\t \n\t\t\tif (any && strlcat(buf, \" \", PAGE_SIZE) >= PAGE_SIZE)\n\t\t\t\tbreak;\n\t\t\tif (strlcat(buf, qib_status_str[i], PAGE_SIZE) >=\n\t\t\t\t\tPAGE_SIZE)\n\t\t\t\tbreak;\n\t\t\tany = 1;\n\t\t}\n\t\ts >>= 1;\n\t}\n\tif (any)\n\t\tstrlcat(buf, \"\\n\", PAGE_SIZE);\n\n\tret = strlen(buf);\n\nbail:\n\treturn ret;\n}\nstatic IB_PORT_ATTR_RO(status_str);\n\n \n\nstatic struct attribute *port_linkcontrol_attributes[] = {\n\t&ib_port_attr_loopback.attr,\n\t&ib_port_attr_led_override.attr,\n\t&ib_port_attr_hrtbt_enable.attr,\n\t&ib_port_attr_status.attr,\n\t&ib_port_attr_status_str.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_linkcontrol_group = {\n\t.name = \"linkcontrol\",\n\t.attrs = port_linkcontrol_attributes,\n};\n\n \n\n \nstatic ssize_t cc_table_bin_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t loff_t pos, size_t count)\n{\n\tstruct qib_pportdata *ppd = qib_get_pportdata_kobj(kobj);\n\tint ret;\n\n\tif (!qib_cc_table_size || !ppd->ccti_entries_shadow)\n\t\treturn -EINVAL;\n\n\tret = ppd->total_cct_entry * sizeof(struct ib_cc_table_entry_shadow)\n\t\t + sizeof(__be16);\n\n\tif (pos > ret)\n\t\treturn -EINVAL;\n\n\tif (count > ret - pos)\n\t\tcount = ret - pos;\n\n\tif (!count)\n\t\treturn count;\n\n\tspin_lock(&ppd->cc_shadow_lock);\n\tmemcpy(buf, ppd->ccti_entries_shadow, count);\n\tspin_unlock(&ppd->cc_shadow_lock);\n\n\treturn count;\n}\nstatic BIN_ATTR_RO(cc_table_bin, PAGE_SIZE);\n\n \nstatic ssize_t cc_setting_bin_read(struct file *filp, struct kobject *kobj,\n\t\t\t\t   struct bin_attribute *bin_attr, char *buf,\n\t\t\t\t   loff_t pos, size_t count)\n{\n\tstruct qib_pportdata *ppd = qib_get_pportdata_kobj(kobj);\n\tint ret;\n\n\tif (!qib_cc_table_size || !ppd->congestion_entries_shadow)\n\t\treturn -EINVAL;\n\n\tret = sizeof(struct ib_cc_congestion_setting_attr_shadow);\n\n\tif (pos > ret)\n\t\treturn -EINVAL;\n\tif (count > ret - pos)\n\t\tcount = ret - pos;\n\n\tif (!count)\n\t\treturn count;\n\n\tspin_lock(&ppd->cc_shadow_lock);\n\tmemcpy(buf, ppd->congestion_entries_shadow, count);\n\tspin_unlock(&ppd->cc_shadow_lock);\n\n\treturn count;\n}\nstatic BIN_ATTR_RO(cc_setting_bin, PAGE_SIZE);\n\nstatic struct bin_attribute *port_ccmgta_attributes[] = {\n\t&bin_attr_cc_setting_bin,\n\t&bin_attr_cc_table_bin,\n\tNULL,\n};\n\nstatic umode_t qib_ccmgta_is_bin_visible(struct kobject *kobj,\n\t\t\t\t struct bin_attribute *attr, int n)\n{\n\tstruct qib_pportdata *ppd = qib_get_pportdata_kobj(kobj);\n\n\tif (!qib_cc_table_size || !ppd->congestion_entries_shadow)\n\t\treturn 0;\n\treturn attr->attr.mode;\n}\n\nstatic const struct attribute_group port_ccmgta_attribute_group = {\n\t.name = \"CCMgtA\",\n\t.is_bin_visible = qib_ccmgta_is_bin_visible,\n\t.bin_attrs = port_ccmgta_attributes,\n};\n\n \n\nstruct qib_sl2vl_attr {\n\tstruct ib_port_attribute attr;\n\tint sl;\n};\n\nstatic ssize_t sl2vl_attr_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_sl2vl_attr *sattr =\n\t\tcontainer_of(attr, struct qib_sl2vl_attr, attr);\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%u\\n\", qibp->sl_to_vl[sattr->sl]);\n}\n\n#define QIB_SL2VL_ATTR(N)                                                      \\\n\tstatic struct qib_sl2vl_attr qib_sl2vl_attr_##N = {                    \\\n\t\t.attr = __ATTR(N, 0444, sl2vl_attr_show, NULL),                \\\n\t\t.sl = N,                                                       \\\n\t}\n\nQIB_SL2VL_ATTR(0);\nQIB_SL2VL_ATTR(1);\nQIB_SL2VL_ATTR(2);\nQIB_SL2VL_ATTR(3);\nQIB_SL2VL_ATTR(4);\nQIB_SL2VL_ATTR(5);\nQIB_SL2VL_ATTR(6);\nQIB_SL2VL_ATTR(7);\nQIB_SL2VL_ATTR(8);\nQIB_SL2VL_ATTR(9);\nQIB_SL2VL_ATTR(10);\nQIB_SL2VL_ATTR(11);\nQIB_SL2VL_ATTR(12);\nQIB_SL2VL_ATTR(13);\nQIB_SL2VL_ATTR(14);\nQIB_SL2VL_ATTR(15);\n\nstatic struct attribute *port_sl2vl_attributes[] = {\n\t&qib_sl2vl_attr_0.attr.attr,\n\t&qib_sl2vl_attr_1.attr.attr,\n\t&qib_sl2vl_attr_2.attr.attr,\n\t&qib_sl2vl_attr_3.attr.attr,\n\t&qib_sl2vl_attr_4.attr.attr,\n\t&qib_sl2vl_attr_5.attr.attr,\n\t&qib_sl2vl_attr_6.attr.attr,\n\t&qib_sl2vl_attr_7.attr.attr,\n\t&qib_sl2vl_attr_8.attr.attr,\n\t&qib_sl2vl_attr_9.attr.attr,\n\t&qib_sl2vl_attr_10.attr.attr,\n\t&qib_sl2vl_attr_11.attr.attr,\n\t&qib_sl2vl_attr_12.attr.attr,\n\t&qib_sl2vl_attr_13.attr.attr,\n\t&qib_sl2vl_attr_14.attr.attr,\n\t&qib_sl2vl_attr_15.attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_sl2vl_group = {\n\t.name = \"sl2vl\",\n\t.attrs = port_sl2vl_attributes,\n};\n\n \n\n \n\nstruct qib_diagc_attr {\n\tstruct ib_port_attribute attr;\n\tsize_t counter;\n};\n\nstatic ssize_t diagc_attr_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t       struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_diagc_attr *dattr =\n\t\tcontainer_of(attr, struct qib_diagc_attr, attr);\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%llu\\n\", *((u64 *)qibp + dattr->counter));\n}\n\nstatic ssize_t diagc_attr_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\tstruct ib_port_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct qib_diagc_attr *dattr =\n\t\tcontainer_of(attr, struct qib_diagc_attr, attr);\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\tu64 val;\n\tint ret;\n\n\tret = kstrtou64(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\t*((u64 *)qibp + dattr->counter) = val;\n\treturn count;\n}\n\n#define QIB_DIAGC_ATTR(N)                                                      \\\n\tstatic_assert(__same_type(((struct qib_ibport *)0)->rvp.n_##N, u64));  \\\n\tstatic struct qib_diagc_attr qib_diagc_attr_##N = {                    \\\n\t\t.attr = __ATTR(N, 0664, diagc_attr_show, diagc_attr_store),    \\\n\t\t.counter =                                                     \\\n\t\t\toffsetof(struct qib_ibport, rvp.n_##N) / sizeof(u64)   \\\n\t}\n\nQIB_DIAGC_ATTR(rc_resends);\nQIB_DIAGC_ATTR(seq_naks);\nQIB_DIAGC_ATTR(rdma_seq);\nQIB_DIAGC_ATTR(rnr_naks);\nQIB_DIAGC_ATTR(other_naks);\nQIB_DIAGC_ATTR(rc_timeouts);\nQIB_DIAGC_ATTR(loop_pkts);\nQIB_DIAGC_ATTR(pkt_drops);\nQIB_DIAGC_ATTR(dmawait);\nQIB_DIAGC_ATTR(unaligned);\nQIB_DIAGC_ATTR(rc_dupreq);\nQIB_DIAGC_ATTR(rc_seqnak);\nQIB_DIAGC_ATTR(rc_crwaits);\n\nstatic u64 get_all_cpu_total(u64 __percpu *cntr)\n{\n\tint cpu;\n\tu64 counter = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t\tcounter += *per_cpu_ptr(cntr, cpu);\n\treturn counter;\n}\n\nstatic ssize_t qib_store_per_cpu(struct qib_devdata *dd, const char *buf,\n\t\t\t\t size_t count, u64 *zero, u64 cur)\n{\n\tu32 val;\n\tint ret;\n\n\tret = kstrtou32(buf, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val != 0) {\n\t\tqib_dev_err(dd, \"Per CPU cntrs can only be zeroed\");\n\t\treturn count;\n\t}\n\t*zero = cur;\n\treturn count;\n}\n\nstatic ssize_t rc_acks_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t    struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  get_all_cpu_total(qibp->rvp.rc_acks) -\n\t\t\t\t  qibp->rvp.z_rc_acks);\n}\n\nstatic ssize_t rc_acks_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t     struct ib_port_attribute *attr, const char *buf,\n\t\t\t     size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn qib_store_per_cpu(dd, buf, count, &qibp->rvp.z_rc_acks,\n\t\t\t\t get_all_cpu_total(qibp->rvp.rc_acks));\n}\nstatic IB_PORT_ATTR_RW(rc_acks);\n\nstatic ssize_t rc_qacks_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t     struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t  get_all_cpu_total(qibp->rvp.rc_qacks) -\n\t\t\t\t  qibp->rvp.z_rc_qacks);\n}\n\nstatic ssize_t rc_qacks_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t      struct ib_port_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn qib_store_per_cpu(dd, buf, count, &qibp->rvp.z_rc_qacks,\n\t\t\t\t get_all_cpu_total(qibp->rvp.rc_qacks));\n}\nstatic IB_PORT_ATTR_RW(rc_qacks);\n\nstatic ssize_t rc_delayed_comp_show(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t    struct ib_port_attribute *attr, char *buf)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn sysfs_emit(buf, \"%llu\\n\",\n\t\t\t get_all_cpu_total(qibp->rvp.rc_delayed_comp) -\n\t\t\t\t qibp->rvp.z_rc_delayed_comp);\n}\n\nstatic ssize_t rc_delayed_comp_store(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t     struct ib_port_attribute *attr,\n\t\t\t\t     const char *buf, size_t count)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tstruct qib_ibport *qibp = &dd->pport[port_num - 1].ibport_data;\n\n\treturn qib_store_per_cpu(dd, buf, count, &qibp->rvp.z_rc_delayed_comp,\n\t\t\t\t get_all_cpu_total(qibp->rvp.rc_delayed_comp));\n}\nstatic IB_PORT_ATTR_RW(rc_delayed_comp);\n\nstatic struct attribute *port_diagc_attributes[] = {\n\t&qib_diagc_attr_rc_resends.attr.attr,\n\t&qib_diagc_attr_seq_naks.attr.attr,\n\t&qib_diagc_attr_rdma_seq.attr.attr,\n\t&qib_diagc_attr_rnr_naks.attr.attr,\n\t&qib_diagc_attr_other_naks.attr.attr,\n\t&qib_diagc_attr_rc_timeouts.attr.attr,\n\t&qib_diagc_attr_loop_pkts.attr.attr,\n\t&qib_diagc_attr_pkt_drops.attr.attr,\n\t&qib_diagc_attr_dmawait.attr.attr,\n\t&qib_diagc_attr_unaligned.attr.attr,\n\t&qib_diagc_attr_rc_dupreq.attr.attr,\n\t&qib_diagc_attr_rc_seqnak.attr.attr,\n\t&qib_diagc_attr_rc_crwaits.attr.attr,\n\t&ib_port_attr_rc_acks.attr,\n\t&ib_port_attr_rc_qacks.attr,\n\t&ib_port_attr_rc_delayed_comp.attr,\n\tNULL\n};\n\nstatic const struct attribute_group port_diagc_group = {\n\t.name = \"diag_counters\",\n\t.attrs = port_diagc_attributes,\n};\n\n \n\nconst struct attribute_group *qib_attr_port_groups[] = {\n\t&port_linkcontrol_group,\n\t&port_ccmgta_attribute_group,\n\t&port_sl2vl_group,\n\t&port_diagc_group,\n\tNULL,\n};\n\n \n\n \nstatic ssize_t hw_rev_show(struct device *device, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\n\treturn sysfs_emit(buf, \"%x\\n\", dd_from_dev(dev)->minrev);\n}\nstatic DEVICE_ATTR_RO(hw_rev);\n\nstatic ssize_t hca_type_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\n\tif (!dd->boardname)\n\t\treturn -EINVAL;\n\treturn sysfs_emit(buf, \"%s\\n\", dd->boardname);\n}\nstatic DEVICE_ATTR_RO(hca_type);\nstatic DEVICE_ATTR(board_id, 0444, hca_type_show, NULL);\n\nstatic ssize_t version_show(struct device *device,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\t \n\treturn sysfs_emit(buf, \"%s\", (char *)ib_qib_version);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t boardversion_show(struct device *device,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%s\", dd->boardversion);\n}\nstatic DEVICE_ATTR_RO(boardversion);\n\nstatic ssize_t localbus_info_show(struct device *device,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%s\", dd->lbus_info);\n}\nstatic DEVICE_ATTR_RO(localbus_info);\n\nstatic ssize_t nctxts_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\n\t \n\t \n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\t  (dd->first_user_ctxt > dd->cfgctxts) ?\n\t\t\t\t  0 :\n\t\t\t\t  (dd->cfgctxts - dd->first_user_ctxt));\n}\nstatic DEVICE_ATTR_RO(nctxts);\n\nstatic ssize_t nfreectxts_show(struct device *device,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\n\t \n\treturn sysfs_emit(buf, \"%u\\n\", dd->freectxts);\n}\nstatic DEVICE_ATTR_RO(nfreectxts);\n\nstatic ssize_t serial_show(struct device *device, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tconst u8 *end = memchr(dd->serial, 0, ARRAY_SIZE(dd->serial));\n\tint size = end ? end - dd->serial : ARRAY_SIZE(dd->serial);\n\n\treturn sysfs_emit(buf, \".%*s\\n\", size, dd->serial);\n}\nstatic DEVICE_ATTR_RO(serial);\n\nstatic ssize_t chip_reset_store(struct device *device,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t count)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tint ret;\n\n\tif (count < 5 || memcmp(buf, \"reset\", 5) || !dd->diag_client) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tret = qib_reset_device(dd->unit);\nbail:\n\treturn ret < 0 ? ret : count;\n}\nstatic DEVICE_ATTR_WO(chip_reset);\n\n \nstatic ssize_t tempsense_show(struct device *device,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct qib_ibdev *dev =\n\t\trdma_device_to_drv_device(device, struct qib_ibdev, rdi.ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tint i;\n\tu8 regvals[8];\n\n\tfor (i = 0; i < 8; i++) {\n\t\tint ret;\n\n\t\tif (i == 6)\n\t\t\tcontinue;\n\t\tret = dd->f_tempsense_rd(dd, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\t \n\t\tregvals[i] = ret;\n\t}\n\treturn sysfs_emit(buf, \"%d %d %02X %02X %d %d\\n\",\n\t\t\t  (signed char)regvals[0],\n\t\t\t  (signed char)regvals[1],\n\t\t\t  regvals[2],\n\t\t\t  regvals[3],\n\t\t\t  (signed char)regvals[5],\n\t\t\t  (signed char)regvals[7]);\n}\nstatic DEVICE_ATTR_RO(tempsense);\n\n \n\n \nstatic struct attribute *qib_attributes[] = {\n\t&dev_attr_hw_rev.attr,\n\t&dev_attr_hca_type.attr,\n\t&dev_attr_board_id.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_nctxts.attr,\n\t&dev_attr_nfreectxts.attr,\n\t&dev_attr_serial.attr,\n\t&dev_attr_boardversion.attr,\n\t&dev_attr_tempsense.attr,\n\t&dev_attr_localbus_info.attr,\n\t&dev_attr_chip_reset.attr,\n\tNULL,\n};\n\nconst struct attribute_group qib_attr_group = {\n\t.attrs = qib_attributes,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}