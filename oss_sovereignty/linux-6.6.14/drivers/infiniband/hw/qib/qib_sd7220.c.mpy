{
  "module_name": "qib_sd7220.c",
  "hash_id": "02783b7790d613cd03fee1acc923e6f215bafe9ac1b83181a895d70ee2d00129",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_sd7220.c",
  "human_readable_source": " \n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include \"qib.h\"\n#include \"qib_7220.h\"\n\n#define SD7220_FW_NAME \"qlogic/sd7220.fw\"\nMODULE_FIRMWARE(SD7220_FW_NAME);\n\n \n#define KREG_IDX(regname) (QIB_7220_##regname##_OFFS / sizeof(u64))\n#define kr_hwerrclear KREG_IDX(HwErrClear)\n#define kr_hwerrmask KREG_IDX(HwErrMask)\n#define kr_hwerrstatus KREG_IDX(HwErrStatus)\n#define kr_ibcstatus KREG_IDX(IBCStatus)\n#define kr_ibserdesctrl KREG_IDX(IBSerDesCtrl)\n#define kr_scratch KREG_IDX(Scratch)\n#define kr_xgxs_cfg KREG_IDX(XGXSCfg)\n \n#define kr_ibsd_epb_access_ctrl KREG_IDX(ibsd_epb_access_ctrl)\n#define kr_ibsd_epb_transaction_reg KREG_IDX(ibsd_epb_transaction_reg)\n#define kr_pciesd_epb_transaction_reg KREG_IDX(pciesd_epb_transaction_reg)\n#define kr_pciesd_epb_access_ctrl KREG_IDX(pciesd_epb_access_ctrl)\n#define kr_serdes_ddsrxeq0 KREG_IDX(SerDes_DDSRXEQ0)\n\n \n#define kr_serdes_maptable KREG_IDX(IBSerDesMappTable)\n\n \n#define PCIE_SERDES0 0\n#define PCIE_SERDES1 1\n\n \n#define EPB_ADDR_SHF 8\n#define EPB_LOC(chn, elt, reg) \\\n\t(((elt & 0xf) | ((chn & 7) << 4) | ((reg & 0x3f) << 9)) << \\\n\t EPB_ADDR_SHF)\n#define EPB_IB_QUAD0_CS_SHF (25)\n#define EPB_IB_QUAD0_CS (1U <<  EPB_IB_QUAD0_CS_SHF)\n#define EPB_IB_UC_CS_SHF (26)\n#define EPB_PCIE_UC_CS_SHF (27)\n#define EPB_GLOBAL_WR (1U << (EPB_ADDR_SHF + 8))\n\n \nstatic int qib_sd7220_reg_mod(struct qib_devdata *dd, int sdnum, u32 loc,\n\t\t\t      u32 data, u32 mask);\nstatic int ibsd_mod_allchnls(struct qib_devdata *dd, int loc, int val,\n\t\t\t     int mask);\nstatic int qib_sd_trimdone_poll(struct qib_devdata *dd);\nstatic void qib_sd_trimdone_monitor(struct qib_devdata *dd, const char *where);\nstatic int qib_sd_setvals(struct qib_devdata *dd);\nstatic int qib_sd_early(struct qib_devdata *dd);\nstatic int qib_sd_dactrim(struct qib_devdata *dd);\nstatic int qib_internal_presets(struct qib_devdata *dd);\n \nstatic int qib_sd_trimself(struct qib_devdata *dd, int val);\nstatic int epb_access(struct qib_devdata *dd, int sdnum, int claim);\nstatic int qib_sd7220_ib_load(struct qib_devdata *dd,\n\t\t\t      const struct firmware *fw);\nstatic int qib_sd7220_ib_vfy(struct qib_devdata *dd,\n\t\t\t     const struct firmware *fw);\n\n \nstatic int qib_ibsd_ucode_loaded(struct qib_pportdata *ppd,\n\t\t\t\t const struct firmware *fw)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\n\tif (!dd->cspec->serdes_first_init_done &&\n\t    qib_sd7220_ib_vfy(dd, fw) > 0)\n\t\tdd->cspec->serdes_first_init_done = 1;\n\treturn dd->cspec->serdes_first_init_done;\n}\n\n \n#define QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR      0x0000004000000000ULL\n#define IB_MPREG5 (EPB_LOC(6, 0, 0xE) | (1L << EPB_IB_UC_CS_SHF))\n#define IB_MPREG6 (EPB_LOC(6, 0, 0xF) | (1U << EPB_IB_UC_CS_SHF))\n#define UC_PAR_CLR_D 8\n#define UC_PAR_CLR_M 0xC\n#define IB_CTRL2(chn) (EPB_LOC(chn, 7, 3) | EPB_IB_QUAD0_CS)\n#define START_EQ1(chan) EPB_LOC(chan, 7, 0x27)\n\nvoid qib_sd7220_clr_ibpar(struct qib_devdata *dd)\n{\n\tint ret;\n\n\t \n\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6,\n\t\tUC_PAR_CLR_D, UC_PAR_CLR_M);\n\tif (ret < 0) {\n\t\tqib_dev_err(dd, \"Failed clearing IBSerDes Parity err\\n\");\n\t\tgoto bail;\n\t}\n\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0,\n\t\tUC_PAR_CLR_M);\n\n\tqib_read_kreg32(dd, kr_scratch);\n\tudelay(4);\n\tqib_write_kreg(dd, kr_hwerrclear,\n\t\tQLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\n\tqib_read_kreg32(dd, kr_scratch);\nbail:\n\treturn;\n}\n\n \n#define IBSD_RESYNC_TRIES 3\n#define IB_PGUDP(chn) (EPB_LOC((chn), 2, 1) | EPB_IB_QUAD0_CS)\n#define IB_CMUDONE(chn) (EPB_LOC((chn), 7, 0xF) | EPB_IB_QUAD0_CS)\n\nstatic int qib_resync_ibepb(struct qib_devdata *dd)\n{\n\tint ret, pat, tries, chn;\n\tu32 loc;\n\n\tret = -1;\n\tchn = 0;\n\tfor (tries = 0; tries < (4 * IBSD_RESYNC_TRIES); ++tries) {\n\t\tloc = IB_PGUDP(chn);\n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed read in resync\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != 0xF0 && ret != 0x55 && tries == 0)\n\t\t\tqib_dev_err(dd, \"unexpected pattern in resync\\n\");\n\t\tpat = ret ^ 0xA5;  \n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, pat, 0xFF);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed write in resync\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed re-read in resync\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret != pat) {\n\t\t\tqib_dev_err(dd, \"Failed compare1 in resync\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tloc = IB_CMUDONE(chn);\n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, 0, 0);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed CMUDONE rd in resync\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tif ((ret & 0x70) != ((chn << 4) | 0x40)) {\n\t\t\tqib_dev_err(dd, \"Bad CMUDONE value %02X, chn %d\\n\",\n\t\t\t\t    ret, chn);\n\t\t\tcontinue;\n\t\t}\n\t\tif (++chn == 4)\n\t\t\tbreak;   \n\t}\n\treturn (ret > 0) ? 0 : ret;\n}\n\n \nstatic int qib_ibsd_reset(struct qib_devdata *dd, int assert_rst)\n{\n\tu64 rst_val;\n\tint ret = 0;\n\tunsigned long flags;\n\n\trst_val = qib_read_kreg64(dd, kr_ibserdesctrl);\n\tif (assert_rst) {\n\t\t \n\t\tspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\n\t\tepb_access(dd, IB_7220_SERDES, 1);\n\t\trst_val |= 1ULL;\n\t\t \n\t\tqib_write_kreg(dd, kr_hwerrmask,\n\t\t\t       dd->cspec->hwerrmask &\n\t\t\t       ~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\n\t\tqib_write_kreg(dd, kr_ibserdesctrl, rst_val);\n\t\t \n\t\tqib_read_kreg32(dd, kr_scratch);\n\t\tudelay(2);\n\t\t \n\t\tepb_access(dd, IB_7220_SERDES, -1);\n\t\tspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\n\t} else {\n\t\t \n\t\tu64 val;\n\n\t\trst_val &= ~(1ULL);\n\t\tqib_write_kreg(dd, kr_hwerrmask,\n\t\t\t       dd->cspec->hwerrmask &\n\t\t\t       ~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR);\n\n\t\tret = qib_resync_ibepb(dd);\n\t\tif (ret < 0)\n\t\t\tqib_dev_err(dd, \"unable to re-sync IB EPB\\n\");\n\n\t\t \n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG5, 1, 1);\n\t\tif (ret < 0)\n\t\t\tgoto bail;\n\t\t \n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80,\n\t\t\t0x80);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed to set WDOG disable\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t\tqib_write_kreg(dd, kr_ibserdesctrl, rst_val);\n\t\t \n\t\tqib_read_kreg32(dd, kr_scratch);\n\t\tudelay(1);\n\t\t \n\t\tqib_sd7220_clr_ibpar(dd);\n\t\tval = qib_read_kreg64(dd, kr_hwerrstatus);\n\t\tif (val & QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR) {\n\t\t\tqib_dev_err(dd, \"IBUC Parity still set after RST\\n\");\n\t\t\tdd->cspec->hwerrmask &=\n\t\t\t\t~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR;\n\t\t}\n\t\tqib_write_kreg(dd, kr_hwerrmask,\n\t\t\tdd->cspec->hwerrmask);\n\t}\n\nbail:\n\treturn ret;\n}\n\nstatic void qib_sd_trimdone_monitor(struct qib_devdata *dd,\n\tconst char *where)\n{\n\tint ret, chn, baduns;\n\tu64 val;\n\n\tif (!where)\n\t\twhere = \"?\";\n\n\t \n\tudelay(2);\n\n\tret = qib_resync_ibepb(dd);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"not able to re-sync IB EPB (%s)\\n\", where);\n\n\t \n\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_CTRL2(0), 0, 0);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"Failed TRIMDONE 1st read, (%s)\\n\", where);\n\n\t \n\tval = qib_read_kreg64(dd, kr_ibcstatus);\n\tif (!(val & (1ULL << 11)))\n\t\tqib_dev_err(dd, \"IBCS TRIMDONE clear (%s)\\n\", where);\n\t \n\tudelay(2);\n\n\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, IB_MPREG6, 0x80, 0x80);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"Failed Dummy RMW, (%s)\\n\", where);\n\tudelay(10);\n\n\tbaduns = 0;\n\n\tfor (chn = 3; chn >= 0; --chn) {\n\t\t \n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\tIB_CTRL2(chn), 0, 0);\n\t\tif (ret < 0)\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Failed checking TRIMDONE, chn %d (%s)\\n\",\n\t\t\t\tchn, where);\n\n\t\tif (!(ret & 0x10)) {\n\t\t\tint probe;\n\n\t\t\tbaduns |= (1 << chn);\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"TRIMDONE cleared on chn %d (%02X). (%s)\\n\",\n\t\t\t\tchn, ret, where);\n\t\t\tprobe = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\t\tIB_PGUDP(0), 0, 0);\n\t\t\tqib_dev_err(dd, \"probe is %d (%02X)\\n\",\n\t\t\t\tprobe, probe);\n\t\t\tprobe = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\t\tIB_CTRL2(chn), 0, 0);\n\t\t\tqib_dev_err(dd, \"re-read: %d (%02X)\\n\",\n\t\t\t\tprobe, probe);\n\t\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\t\tIB_CTRL2(chn), 0x10, 0x10);\n\t\t\tif (ret < 0)\n\t\t\t\tqib_dev_err(dd,\n\t\t\t\t\t\"Err on TRIMDONE rewrite1\\n\");\n\t\t}\n\t}\n\tfor (chn = 3; chn >= 0; --chn) {\n\t\t \n\t\tif (baduns & (1 << chn)) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Resetting TRIMDONE on chn %d (%s)\\n\",\n\t\t\t\tchn, where);\n\t\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\t\tIB_CTRL2(chn), 0x10, 0x10);\n\t\t\tif (ret < 0)\n\t\t\t\tqib_dev_err(dd,\n\t\t\t\t\t\"Failed re-setting TRIMDONE, chn %d (%s)\\n\",\n\t\t\t\t\tchn, where);\n\t\t}\n\t}\n}\n\n \nint qib_sd7220_init(struct qib_devdata *dd)\n{\n\tconst struct firmware *fw;\n\tint ret = 1;  \n\tint first_reset, was_reset;\n\n\t \n\twas_reset = (qib_read_kreg64(dd, kr_ibserdesctrl) & 1);\n\tif (!was_reset) {\n\t\t \n\t\tqib_ibsd_reset(dd, 1);\n\t\tqib_sd_trimdone_monitor(dd, \"Driver-reload\");\n\t}\n\n\tret = request_firmware(&fw, SD7220_FW_NAME, &dd->pcidev->dev);\n\tif (ret) {\n\t\tqib_dev_err(dd, \"Failed to load IB SERDES image\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tret = qib_ibsd_ucode_loaded(dd->pport, fw);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tfirst_reset = !ret;  \n\t \n\tret = qib_sd_early(dd);\n\tif (ret < 0) {\n\t\tqib_dev_err(dd, \"Failed to set IB SERDES early defaults\\n\");\n\t\tgoto bail;\n\t}\n\t \n\tif (first_reset) {\n\t\tret = qib_sd_dactrim(dd);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed IB SERDES DAC trim\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n\t \n\tret = qib_internal_presets(dd);\n\tif (ret < 0) {\n\t\tqib_dev_err(dd, \"Failed to set IB SERDES presets\\n\");\n\t\tgoto bail;\n\t}\n\tret = qib_sd_trimself(dd, 0x80);\n\tif (ret < 0) {\n\t\tqib_dev_err(dd, \"Failed to set IB SERDES TRIMSELF\\n\");\n\t\tgoto bail;\n\t}\n\n\t \n\tret = 0;         \n\tif (first_reset) {\n\t\tint vfy;\n\t\tint trim_done;\n\n\t\tret = qib_sd7220_ib_load(dd, fw);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed to load IB SERDES image\\n\");\n\t\t\tgoto bail;\n\t\t} else {\n\t\t\t \n\t\t\tvfy = qib_sd7220_ib_vfy(dd, fw);\n\t\t\tif (vfy != ret) {\n\t\t\t\tqib_dev_err(dd, \"SERDES PRAM VFY failed\\n\");\n\t\t\t\tgoto bail;\n\t\t\t}  \n\t\t}  \n\n\t\t \n\t\tret = 0;\n\t\t \n\t\tret = ibsd_mod_allchnls(dd, START_EQ1(0), 0, 0x38);\n\t\tif (ret < 0) {\n\t\t\tqib_dev_err(dd, \"Failed clearing START_EQ1\\n\");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tqib_ibsd_reset(dd, 0);\n\t\t \n\t\ttrim_done = qib_sd_trimdone_poll(dd);\n\t\t \n\t\tqib_ibsd_reset(dd, 1);\n\n\t\tif (!trim_done) {\n\t\t\tqib_dev_err(dd, \"No TRIMDONE seen\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tqib_sd_trimdone_monitor(dd, \"First-reset\");\n\t\t \n\t\tdd->cspec->serdes_first_init_done = 1;\n\t}\n\t \n\tret = 0;\n\tif (qib_sd_setvals(dd) >= 0)\n\t\tgoto done;\nbail:\n\tret = 1;\ndone:\n\t \n\tset_7220_relock_poll(dd, -1);\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\n#define EPB_ACC_REQ 1\n#define EPB_ACC_GNT 0x100\n#define EPB_DATA_MASK 0xFF\n#define EPB_RD (1ULL << 24)\n#define EPB_TRANS_RDY (1ULL << 31)\n#define EPB_TRANS_ERR (1ULL << 30)\n#define EPB_TRANS_TRIES 5\n\n \nstatic int epb_access(struct qib_devdata *dd, int sdnum, int claim)\n{\n\tu16 acc;\n\tu64 accval;\n\tint owned = 0;\n\tu64 oct_sel = 0;\n\n\tswitch (sdnum) {\n\tcase IB_7220_SERDES:\n\t\t \n\t\tacc = kr_ibsd_epb_access_ctrl;\n\t\tbreak;\n\n\tcase PCIE_SERDES0:\n\tcase PCIE_SERDES1:\n\t\t \n\t\tacc = kr_pciesd_epb_access_ctrl;\n\t\toct_sel = (2 << (sdnum - PCIE_SERDES0));\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\tqib_read_kreg32(dd, kr_scratch);\n\tudelay(15);\n\n\taccval = qib_read_kreg32(dd, acc);\n\n\towned = !!(accval & EPB_ACC_GNT);\n\tif (claim < 0) {\n\t\t \n\t\tu64 pollval;\n\t\t \n\t\tu64 newval = 0;\n\n\t\tqib_write_kreg(dd, acc, newval);\n\t\t \n\t\tpollval = qib_read_kreg32(dd, acc);\n\t\tudelay(5);\n\t\tpollval = qib_read_kreg32(dd, acc);\n\t\tif (pollval & EPB_ACC_GNT)\n\t\t\towned = -1;\n\t} else if (claim > 0) {\n\t\t \n\t\tu64 pollval;\n\t\tu64 newval = EPB_ACC_REQ | oct_sel;\n\n\t\tqib_write_kreg(dd, acc, newval);\n\t\t \n\t\tpollval = qib_read_kreg32(dd, acc);\n\t\tudelay(5);\n\t\tpollval = qib_read_kreg32(dd, acc);\n\t\tif (!(pollval & EPB_ACC_GNT))\n\t\t\towned = -1;\n\t}\n\treturn owned;\n}\n\n \nstatic int epb_trans(struct qib_devdata *dd, u16 reg, u64 i_val, u64 *o_vp)\n{\n\tint tries;\n\tu64 transval;\n\n\tqib_write_kreg(dd, reg, i_val);\n\t \n\ttransval = qib_read_kreg64(dd, reg);\n\n\tfor (tries = EPB_TRANS_TRIES; tries; --tries) {\n\t\ttransval = qib_read_kreg32(dd, reg);\n\t\tif (transval & EPB_TRANS_RDY)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\tif (transval & EPB_TRANS_ERR)\n\t\treturn -1;\n\tif (tries > 0 && o_vp)\n\t\t*o_vp = transval;\n\treturn tries;\n}\n\n \nstatic int qib_sd7220_reg_mod(struct qib_devdata *dd, int sdnum, u32 loc,\n\t\t\t      u32 wd, u32 mask)\n{\n\tu16 trans;\n\tu64 transval;\n\tint owned;\n\tint tries, ret;\n\tunsigned long flags;\n\n\tswitch (sdnum) {\n\tcase IB_7220_SERDES:\n\t\ttrans = kr_ibsd_epb_transaction_reg;\n\t\tbreak;\n\n\tcase PCIE_SERDES0:\n\tcase PCIE_SERDES1:\n\t\ttrans = kr_pciesd_epb_transaction_reg;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\n\t \n\tspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\n\n\towned = epb_access(dd, sdnum, 1);\n\tif (owned < 0) {\n\t\tspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\n\t\treturn -1;\n\t}\n\tfor (tries = EPB_TRANS_TRIES; tries; --tries) {\n\t\ttransval = qib_read_kreg32(dd, trans);\n\t\tif (transval & EPB_TRANS_RDY)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tif (tries > 0) {\n\t\ttries = 1;       \n\t\tif (mask != 0xFF) {\n\t\t\t \n\t\t\ttransval = loc | EPB_RD;\n\t\t\ttries = epb_trans(dd, trans, transval, &transval);\n\t\t}\n\t\tif (tries > 0 && mask != 0) {\n\t\t\t \n\t\t\twd = (wd & mask) | (transval & ~mask);\n\t\t\ttransval = loc | (wd & EPB_DATA_MASK);\n\t\t\ttries = epb_trans(dd, trans, transval, &transval);\n\t\t}\n\t}\n\t \n\n\t \n\tif (epb_access(dd, sdnum, -1) < 0)\n\t\tret = -1;\n\telse\n\t\tret = transval & EPB_DATA_MASK;\n\n\tspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\n\tif (tries <= 0)\n\t\tret = -1;\n\treturn ret;\n}\n\n#define EPB_ROM_R (2)\n#define EPB_ROM_W (1)\n \n#define EPB_UC_CTL EPB_LOC(6, 0, 0)\n#define EPB_MADDRL EPB_LOC(6, 0, 2)\n#define EPB_MADDRH EPB_LOC(6, 0, 3)\n#define EPB_ROMDATA EPB_LOC(6, 0, 4)\n#define EPB_RAMDATA EPB_LOC(6, 0, 5)\n\n \nstatic int qib_sd7220_ram_xfer(struct qib_devdata *dd, int sdnum, u32 loc,\n\t\t\t       u8 *buf, int cnt, int rd_notwr)\n{\n\tu16 trans;\n\tu64 transval;\n\tu64 csbit;\n\tint owned;\n\tint tries;\n\tint sofar;\n\tint addr;\n\tint ret;\n\tunsigned long flags;\n\n\t \n\tswitch (sdnum) {\n\tcase IB_7220_SERDES:\n\t\tcsbit = 1ULL << EPB_IB_UC_CS_SHF;\n\t\ttrans = kr_ibsd_epb_transaction_reg;\n\t\tbreak;\n\n\tcase PCIE_SERDES0:\n\tcase PCIE_SERDES1:\n\t\t \n\t\tcsbit = 1ULL << EPB_PCIE_UC_CS_SHF;\n\t\ttrans = kr_pciesd_epb_transaction_reg;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&dd->cspec->sdepb_lock, flags);\n\n\towned = epb_access(dd, sdnum, 1);\n\tif (owned < 0) {\n\t\tspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\n\t\treturn -1;\n\t}\n\n\t \n\taddr = loc & 0x1FFF;\n\tfor (tries = EPB_TRANS_TRIES; tries; --tries) {\n\t\ttransval = qib_read_kreg32(dd, trans);\n\t\tif (transval & EPB_TRANS_RDY)\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tsofar = 0;\n\tif (tries > 0) {\n\t\t \n\n\t\t \n\t\ttransval = csbit | EPB_UC_CTL |\n\t\t\t(rd_notwr ? EPB_ROM_R : EPB_ROM_W);\n\t\ttries = epb_trans(dd, trans, transval, &transval);\n\t\twhile (tries > 0 && sofar < cnt) {\n\t\t\tif (!sofar) {\n\t\t\t\t \n\t\t\t\tint addrbyte = (addr + sofar) >> 8;\n\n\t\t\t\ttransval = csbit | EPB_MADDRH | addrbyte;\n\t\t\t\ttries = epb_trans(dd, trans, transval,\n\t\t\t\t\t\t  &transval);\n\t\t\t\tif (tries <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\taddrbyte = (addr + sofar) & 0xFF;\n\t\t\t\ttransval = csbit | EPB_MADDRL | addrbyte;\n\t\t\t\ttries = epb_trans(dd, trans, transval,\n\t\t\t\t\t\t &transval);\n\t\t\t\tif (tries <= 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rd_notwr)\n\t\t\t\ttransval = csbit | EPB_ROMDATA | EPB_RD;\n\t\t\telse\n\t\t\t\ttransval = csbit | EPB_ROMDATA | buf[sofar];\n\t\t\ttries = epb_trans(dd, trans, transval, &transval);\n\t\t\tif (tries <= 0)\n\t\t\t\tbreak;\n\t\t\tif (rd_notwr)\n\t\t\t\tbuf[sofar] = transval & EPB_DATA_MASK;\n\t\t\t++sofar;\n\t\t}\n\t\t \n\t\ttransval = csbit | EPB_UC_CTL;\n\t\ttries = epb_trans(dd, trans, transval, &transval);\n\t}\n\n\tret = sofar;\n\t \n\tif (epb_access(dd, sdnum, -1) < 0)\n\t\tret = -1;\n\n\tspin_unlock_irqrestore(&dd->cspec->sdepb_lock, flags);\n\tif (tries <= 0)\n\t\tret = -1;\n\treturn ret;\n}\n\n#define PROG_CHUNK 64\n\nstatic int qib_sd7220_prog_ld(struct qib_devdata *dd, int sdnum,\n\t\t\t      const u8 *img, int len, int offset)\n{\n\tint cnt, sofar, req;\n\n\tsofar = 0;\n\twhile (sofar < len) {\n\t\treq = len - sofar;\n\t\tif (req > PROG_CHUNK)\n\t\t\treq = PROG_CHUNK;\n\t\tcnt = qib_sd7220_ram_xfer(dd, sdnum, offset + sofar,\n\t\t\t\t\t  (u8 *)img + sofar, req, 0);\n\t\tif (cnt < req) {\n\t\t\tsofar = -1;\n\t\t\tbreak;\n\t\t}\n\t\tsofar += req;\n\t}\n\treturn sofar;\n}\n\n#define VFY_CHUNK 64\n#define SD_PRAM_ERROR_LIMIT 42\n\nstatic int qib_sd7220_prog_vfy(struct qib_devdata *dd, int sdnum,\n\t\t\t       const u8 *img, int len, int offset)\n{\n\tint cnt, sofar, req, idx, errors;\n\tunsigned char readback[VFY_CHUNK];\n\n\terrors = 0;\n\tsofar = 0;\n\twhile (sofar < len) {\n\t\treq = len - sofar;\n\t\tif (req > VFY_CHUNK)\n\t\t\treq = VFY_CHUNK;\n\t\tcnt = qib_sd7220_ram_xfer(dd, sdnum, sofar + offset,\n\t\t\t\t\t  readback, req, 1);\n\t\tif (cnt < req) {\n\t\t\t \n\t\t\tsofar = -1;\n\t\t\tbreak;\n\t\t}\n\t\tfor (idx = 0; idx < cnt; ++idx) {\n\t\t\tif (readback[idx] != img[idx+sofar])\n\t\t\t\t++errors;\n\t\t}\n\t\tsofar += cnt;\n\t}\n\treturn errors ? -errors : sofar;\n}\n\nstatic int\nqib_sd7220_ib_load(struct qib_devdata *dd, const struct firmware *fw)\n{\n\treturn qib_sd7220_prog_ld(dd, IB_7220_SERDES, fw->data, fw->size, 0);\n}\n\nstatic int\nqib_sd7220_ib_vfy(struct qib_devdata *dd, const struct firmware *fw)\n{\n\treturn qib_sd7220_prog_vfy(dd, IB_7220_SERDES, fw->data, fw->size, 0);\n}\n\n \n#define IB_SERDES_TRIM_DONE (1ULL << 11)\n#define TRIM_TMO (15)\n\nstatic int qib_sd_trimdone_poll(struct qib_devdata *dd)\n{\n\tint trim_tmo, ret;\n\tuint64_t val;\n\n\t \n\tret = 0;\n\tfor (trim_tmo = 0; trim_tmo < TRIM_TMO; ++trim_tmo) {\n\t\tval = qib_read_kreg64(dd, kr_ibcstatus);\n\t\tif (val & IB_SERDES_TRIM_DONE) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t}\n\tif (trim_tmo >= TRIM_TMO) {\n\t\tqib_dev_err(dd, \"No TRIMDONE in %d tries\\n\", trim_tmo);\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n#define TX_FAST_ELT (9)\n\n \n\n#define NUM_DDS_REGS 6\n#define DDS_REG_MAP 0x76A910  \n\n#define DDS_VAL(amp_d, main_d, ipst_d, ipre_d, amp_s, main_s, ipst_s, ipre_s) \\\n\t{ { ((amp_d & 0x1F) << 1) | 1, ((amp_s & 0x1F) << 1) | 1, \\\n\t  (main_d << 3) | 4 | (ipre_d >> 2), \\\n\t  (main_s << 3) | 4 | (ipre_s >> 2), \\\n\t  ((ipst_d & 0xF) << 1) | ((ipre_d & 3) << 6) | 0x21, \\\n\t  ((ipst_s & 0xF) << 1) | ((ipre_s & 3) << 6) | 0x21 } }\n\nstatic struct dds_init {\n\tuint8_t reg_vals[NUM_DDS_REGS];\n} dds_init_vals[] = {\n\t \n\t \n#define DDS_3M 0\n\tDDS_VAL(31, 19, 12, 0, 29, 22,  9, 0),\n\tDDS_VAL(31, 12, 15, 4, 31, 15, 15, 1),\n\tDDS_VAL(31, 13, 15, 3, 31, 16, 15, 0),\n\tDDS_VAL(31, 14, 15, 2, 31, 17, 14, 0),\n\tDDS_VAL(31, 15, 15, 1, 31, 18, 13, 0),\n\tDDS_VAL(31, 16, 15, 0, 31, 19, 12, 0),\n\tDDS_VAL(31, 17, 14, 0, 31, 20, 11, 0),\n\tDDS_VAL(31, 18, 13, 0, 30, 21, 10, 0),\n\tDDS_VAL(31, 20, 11, 0, 28, 23,  8, 0),\n\tDDS_VAL(31, 21, 10, 0, 27, 24,  7, 0),\n\tDDS_VAL(31, 22,  9, 0, 26, 25,  6, 0),\n\tDDS_VAL(30, 23,  8, 0, 25, 26,  5, 0),\n\tDDS_VAL(29, 24,  7, 0, 23, 27,  4, 0),\n\t \n#define DDS_1M 13\n\tDDS_VAL(28, 25,  6, 0, 21, 28,  3, 0),\n\tDDS_VAL(27, 26,  5, 0, 19, 29,  2, 0),\n\tDDS_VAL(25, 27,  4, 0, 17, 30,  1, 0)\n};\n\n \n \n#define RXEQ_INIT_RDESC(elt, addr) (((elt) & 0xF) | ((addr) << 4))\n#define RXEQ_VAL(elt, adr, val0, val1, val2, val3) \\\n\t{RXEQ_INIT_RDESC((elt), (adr)), {(val0), (val1), (val2), (val3)} }\n\n#define RXEQ_VAL_ALL(elt, adr, val)  \\\n\t{RXEQ_INIT_RDESC((elt), (adr)), {(val), (val), (val), (val)} }\n\n#define RXEQ_SDR_DFELTH 0\n#define RXEQ_SDR_TLTH 0\n#define RXEQ_SDR_G1CNT_Z1CNT 0x11\n#define RXEQ_SDR_ZCNT 23\n\nstatic struct rxeq_init {\n\tu16 rdesc;       \n\tu8  rdata[4];\n} rxeq_init_vals[] = {\n\t \n\tRXEQ_VAL_ALL(7, 0x27, 0x10),\n\t \n\tRXEQ_VAL(7, 8,    0, 0, 0, 0),  \n\tRXEQ_VAL(7, 0x21, 0, 0, 0, 0),  \n\t \n\tRXEQ_VAL(7, 9,    2, 2, 2, 2),  \n\tRXEQ_VAL(7, 0x23, 2, 2, 2, 2),  \n\t \n\tRXEQ_VAL(7, 0x1B, 12, 12, 12, 12),  \n\tRXEQ_VAL(7, 0x1C, 12, 12, 12, 12),  \n\t \n\tRXEQ_VAL(7, 0x1E, 16, 16, 16, 16),  \n\tRXEQ_VAL(7, 0x1F, 16, 16, 16, 16),  \n\t \n\tRXEQ_VAL_ALL(6, 6, 0x20),  \n\tRXEQ_VAL_ALL(6, 6, 0),  \n};\n\n \n#define DDS_ROWS (16)\n#define RXEQ_ROWS ARRAY_SIZE(rxeq_init_vals)\n\nstatic int qib_sd_setvals(struct qib_devdata *dd)\n{\n\tint idx, midx;\n\tint min_idx;      \n\tuint32_t dds_reg_map;\n\tu64 __iomem *taddr, *iaddr;\n\tuint64_t data;\n\tuint64_t sdctl;\n\n\ttaddr = dd->kregbase + kr_serdes_maptable;\n\tiaddr = dd->kregbase + kr_serdes_ddsrxeq0;\n\n\t \n\tsdctl = qib_read_kreg64(dd, kr_ibserdesctrl);\n\tsdctl = (sdctl & ~(0x1f << 8)) | (NUM_DDS_REGS << 8);\n\tsdctl = (sdctl & ~(0x1f << 13)) | (RXEQ_ROWS << 13);\n\tqib_write_kreg(dd, kr_ibserdesctrl, sdctl);\n\n\t \n\tdds_reg_map = DDS_REG_MAP;\n\tfor (idx = 0; idx < NUM_DDS_REGS; ++idx) {\n\t\tdata = ((dds_reg_map & 0xF) << 4) | TX_FAST_ELT;\n\t\twriteq(data, iaddr + idx);\n\t\tqib_read_kreg32(dd, kr_scratch);\n\t\tdds_reg_map >>= 4;\n\t\tfor (midx = 0; midx < DDS_ROWS; ++midx) {\n\t\t\tu64 __iomem *daddr = taddr + ((midx << 4) + idx);\n\n\t\t\tdata = dds_init_vals[midx].reg_vals[idx];\n\t\t\twriteq(data, daddr);\n\t\t\tqib_read_kreg32(dd, kr_scratch);\n\t\t}  \n\t}  \n\n\t \n\tmin_idx = idx;  \n\ttaddr += 0x100;  \n\t \n\tfor (idx = 0; idx < RXEQ_ROWS; ++idx) {\n\t\tint didx;  \n\t\tint vidx;\n\n\t\t \n\t\tdidx = idx + min_idx;\n\t\t \n\t\twriteq(rxeq_init_vals[idx].rdesc, iaddr + didx);\n\t\tqib_read_kreg32(dd, kr_scratch);\n\t\t \n\t\tfor (vidx = 0; vidx < 4; vidx++) {\n\t\t\tdata = rxeq_init_vals[idx].rdata[vidx];\n\t\t\twriteq(data, taddr + (vidx << 6) + idx);\n\t\t\tqib_read_kreg32(dd, kr_scratch);\n\t\t}\n\t}  \n\treturn 0;\n}\n\n#define CMUCTRL5 EPB_LOC(7, 0, 0x15)\n#define RXHSCTRL0(chan) EPB_LOC(chan, 6, 0)\n#define VCDL_DAC2(chan) EPB_LOC(chan, 6, 5)\n#define VCDL_CTRL0(chan) EPB_LOC(chan, 6, 6)\n#define VCDL_CTRL2(chan) EPB_LOC(chan, 6, 8)\n#define START_EQ2(chan) EPB_LOC(chan, 7, 0x28)\n\n \nstatic int ibsd_mod_allchnls(struct qib_devdata *dd, int loc, int val,\n\t\t\t     int mask)\n{\n\tint ret = -1;\n\tint chnl;\n\n\tif (loc & EPB_GLOBAL_WR) {\n\t\t \n\t\tloc |= (1U << EPB_IB_QUAD0_CS_SHF);\n\t\tchnl = (loc >> (4 + EPB_ADDR_SHF)) & 7;\n\t\tif (mask != 0xFF) {\n\t\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES,\n\t\t\t\t\t\t loc & ~EPB_GLOBAL_WR, 0, 0);\n\t\t\tif (ret < 0) {\n\t\t\t\tint sloc = loc >> EPB_ADDR_SHF;\n\n\t\t\t\tqib_dev_err(dd,\n\t\t\t\t\t\"pre-read failed: elt %d, addr 0x%X, chnl %d\\n\",\n\t\t\t\t\t(sloc & 0xF),\n\t\t\t\t\t(sloc >> 9) & 0x3f, chnl);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tval = (ret & ~mask) | (val & mask);\n\t\t}\n\t\tloc &=  ~(7 << (4+EPB_ADDR_SHF));\n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, 0xFF);\n\t\tif (ret < 0) {\n\t\t\tint sloc = loc >> EPB_ADDR_SHF;\n\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Global WR failed: elt %d, addr 0x%X, val %02X\\n\",\n\t\t\t\t(sloc & 0xF), (sloc >> 9) & 0x3f, val);\n\t\t}\n\t\treturn ret;\n\t}\n\t \n\tloc &=  ~(7 << (4+EPB_ADDR_SHF));\n\tloc |= (1U << EPB_IB_QUAD0_CS_SHF);\n\tfor (chnl = 0; chnl < 4; ++chnl) {\n\t\tint cloc = loc | (chnl << (4+EPB_ADDR_SHF));\n\n\t\tret = qib_sd7220_reg_mod(dd, IB_7220_SERDES, cloc, val, mask);\n\t\tif (ret < 0) {\n\t\t\tint sloc = loc >> EPB_ADDR_SHF;\n\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Write failed: elt %d, addr 0x%X, chnl %d, val 0x%02X, mask 0x%02X\\n\",\n\t\t\t\t(sloc & 0xF), (sloc >> 9) & 0x3f, chnl,\n\t\t\t\tval & 0xFF, mask & 0xFF);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\n \nstatic int set_dds_vals(struct qib_devdata *dd, struct dds_init *ddi)\n{\n\tint ret;\n\tint idx, reg, data;\n\tuint32_t regmap;\n\n\tregmap = DDS_REG_MAP;\n\tfor (idx = 0; idx < NUM_DDS_REGS; ++idx) {\n\t\treg = (regmap & 0xF);\n\t\tregmap >>= 4;\n\t\tdata = ddi->reg_vals[idx];\n\t\t \n\t\tret = ibsd_mod_allchnls(dd, EPB_LOC(0, 9, reg), data, 0xFF);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int set_rxeq_vals(struct qib_devdata *dd, int vsel)\n{\n\tint ret;\n\tint ridx;\n\tint cnt = ARRAY_SIZE(rxeq_init_vals);\n\n\tfor (ridx = 0; ridx < cnt; ++ridx) {\n\t\tint elt, reg, val, loc;\n\n\t\telt = rxeq_init_vals[ridx].rdesc & 0xF;\n\t\treg = rxeq_init_vals[ridx].rdesc >> 4;\n\t\tloc = EPB_LOC(0, elt, reg);\n\t\tval = rxeq_init_vals[ridx].rdata[vsel];\n\t\t \n\t\tret = ibsd_mod_allchnls(dd, loc, val, 0xFF);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic unsigned qib_rxeq_set = 2;\nmodule_param_named(rxeq_default_set, qib_rxeq_set, uint,\n\t\t   S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(rxeq_default_set,\n\t\t \"Which set [0..3] of Rx Equalization values is default\");\n\nstatic int qib_internal_presets(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\n\tret = set_dds_vals(dd, dds_init_vals + DDS_3M);\n\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"Failed to set default DDS values\\n\");\n\tret = set_rxeq_vals(dd, qib_rxeq_set & 3);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"Failed to set default RXEQ values\\n\");\n\treturn ret;\n}\n\nint qib_sd7220_presets(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\n\tif (!dd->cspec->presets_needed)\n\t\treturn ret;\n\tdd->cspec->presets_needed = 0;\n\t \n\tqib_ibsd_reset(dd, 1);\n\tudelay(2);\n\tqib_sd_trimdone_monitor(dd, \"link-down\");\n\n\tret = qib_internal_presets(dd);\n\treturn ret;\n}\n\nstatic int qib_sd_trimself(struct qib_devdata *dd, int val)\n{\n\tint loc = CMUCTRL5 | (1U << EPB_IB_QUAD0_CS_SHF);\n\n\treturn qib_sd7220_reg_mod(dd, IB_7220_SERDES, loc, val, 0xFF);\n}\n\nstatic int qib_sd_early(struct qib_devdata *dd)\n{\n\tint ret;\n\n\tret = ibsd_mod_allchnls(dd, RXHSCTRL0(0) | EPB_GLOBAL_WR, 0xD4, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\tret = ibsd_mod_allchnls(dd, START_EQ1(0) | EPB_GLOBAL_WR, 0x10, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\tret = ibsd_mod_allchnls(dd, START_EQ2(0) | EPB_GLOBAL_WR, 0x30, 0xFF);\nbail:\n\treturn ret;\n}\n\n#define BACTRL(chnl) EPB_LOC(chnl, 6, 0x0E)\n#define LDOUTCTRL1(chnl) EPB_LOC(chnl, 7, 6)\n#define RXHSSTATUS(chnl) EPB_LOC(chnl, 6, 0xF)\n\nstatic int qib_sd_dactrim(struct qib_devdata *dd)\n{\n\tint ret;\n\n\tret = ibsd_mod_allchnls(dd, VCDL_DAC2(0) | EPB_GLOBAL_WR, 0x2D, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\t \n\tret = ibsd_mod_allchnls(dd, VCDL_CTRL2(0), 3, 0xF);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tret = ibsd_mod_allchnls(dd, BACTRL(0) | EPB_GLOBAL_WR, 0x40, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tret = ibsd_mod_allchnls(dd, LDOUTCTRL1(0) | EPB_GLOBAL_WR, 0x04, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tret = ibsd_mod_allchnls(dd, RXHSSTATUS(0) | EPB_GLOBAL_WR, 0x04, 0xFF);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\t \n\tudelay(415);\n\n\tret = ibsd_mod_allchnls(dd, LDOUTCTRL1(0) | EPB_GLOBAL_WR, 0x00, 0xFF);\n\nbail:\n\treturn ret;\n}\n\n#define RELOCK_FIRST_MS 3\n#define RXLSPPM(chan) EPB_LOC(chan, 0, 2)\nvoid toggle_7220_rclkrls(struct qib_devdata *dd)\n{\n\tint loc = RXLSPPM(0) | EPB_GLOBAL_WR;\n\tint ret;\n\n\tret = ibsd_mod_allchnls(dd, loc, 0, 0x80);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"RCLKRLS failed to clear D7\\n\");\n\telse {\n\t\tudelay(1);\n\t\tibsd_mod_allchnls(dd, loc, 0x80, 0x80);\n\t}\n\t \n\tudelay(1);\n\tret = ibsd_mod_allchnls(dd, loc, 0, 0x80);\n\tif (ret < 0)\n\t\tqib_dev_err(dd, \"RCLKRLS failed to clear D7\\n\");\n\telse {\n\t\tudelay(1);\n\t\tibsd_mod_allchnls(dd, loc, 0x80, 0x80);\n\t}\n\t \n\tdd->f_xgxs_reset(dd->pport);\n}\n\n \nvoid shutdown_7220_relock_poll(struct qib_devdata *dd)\n{\n\tif (dd->cspec->relock_timer_active)\n\t\tdel_timer_sync(&dd->cspec->relock_timer);\n}\n\nstatic unsigned qib_relock_by_timer = 1;\nmodule_param_named(relock_by_timer, qib_relock_by_timer, uint,\n\t\t   S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(relock_by_timer, \"Allow relock attempt if link not up\");\n\nstatic void qib_run_relock(struct timer_list *t)\n{\n\tstruct qib_chip_specific *cs = from_timer(cs, t, relock_timer);\n\tstruct qib_devdata *dd = cs->dd;\n\tstruct qib_pportdata *ppd = dd->pport;\n\tint timeoff;\n\n\t \n\tif ((dd->flags & QIB_INITTED) && !(ppd->lflags &\n\t    (QIBL_IB_AUTONEG_INPROG | QIBL_LINKINIT | QIBL_LINKARMED |\n\t     QIBL_LINKACTIVE))) {\n\t\tif (qib_relock_by_timer) {\n\t\t\tif (!(ppd->lflags & QIBL_IB_LINK_DISABLED))\n\t\t\t\ttoggle_7220_rclkrls(dd);\n\t\t}\n\t\t \n\t\ttimeoff = cs->relock_interval << 1;\n\t\tif (timeoff > HZ)\n\t\t\ttimeoff = HZ;\n\t\tcs->relock_interval = timeoff;\n\t} else\n\t\ttimeoff = HZ;\n\tmod_timer(&cs->relock_timer, jiffies + timeoff);\n}\n\nvoid set_7220_relock_poll(struct qib_devdata *dd, int ibup)\n{\n\tstruct qib_chip_specific *cs = dd->cspec;\n\n\tif (ibup) {\n\t\t \n\t\tif (cs->relock_timer_active) {\n\t\t\tcs->relock_interval = HZ;\n\t\t\tmod_timer(&cs->relock_timer, jiffies + HZ);\n\t\t}\n\t} else {\n\t\t \n\t\tunsigned int timeout;\n\n\t\ttimeout = msecs_to_jiffies(RELOCK_FIRST_MS);\n\t\tif (timeout == 0)\n\t\t\ttimeout = 1;\n\t\t \n\t\tif (!cs->relock_timer_active) {\n\t\t\tcs->relock_timer_active = 1;\n\t\t\ttimer_setup(&cs->relock_timer, qib_run_relock, 0);\n\t\t\tcs->relock_interval = timeout;\n\t\t\tcs->relock_timer.expires = jiffies + timeout;\n\t\t\tadd_timer(&cs->relock_timer);\n\t\t} else {\n\t\t\tcs->relock_interval = timeout;\n\t\t\tmod_timer(&cs->relock_timer, jiffies + timeout);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}