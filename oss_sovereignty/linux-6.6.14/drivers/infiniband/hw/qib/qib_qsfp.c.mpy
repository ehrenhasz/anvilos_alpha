{
  "module_name": "qib_qsfp.c",
  "hash_id": "6416f8b9e09eff2a17ccba6b42b9947f7caea82a42b775b5f1e7c5734767b042",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_qsfp.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include \"qib.h\"\n#include \"qib_qsfp.h\"\n\n \n#define QSFP_MAX_RETRY 4\n\nstatic int qsfp_read(struct qib_pportdata *ppd, int addr, void *bp, int len)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu32 out, mask;\n\tint ret, cnt, pass = 0;\n\tint stuck = 0;\n\tu8 *buff = bp;\n\n\tret = mutex_lock_interruptible(&dd->eep_lock);\n\tif (ret)\n\t\tgoto no_unlock;\n\n\tif (dd->twsi_eeprom_dev == QIB_TWSI_NO_DEV) {\n\t\tret = -ENXIO;\n\t\tgoto bail;\n\t}\n\n\t \n\tmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\n\tout = QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\n\tif (ppd->hw_pidx) {\n\t\tmask <<= QSFP_GPIO_PORT2_SHIFT;\n\t\tout <<= QSFP_GPIO_PORT2_SHIFT;\n\t}\n\n\tdd->f_gpio_mod(dd, out, mask, mask);\n\n\t \n\tmsleep(20);\n\n\t \n\tret = qib_twsi_reset(dd);\n\tif (ret) {\n\t\tqib_dev_porterr(dd, ppd->port,\n\t\t\t\t\"QSFP interface Reset for read failed\\n\");\n\t\tret = -EIO;\n\t\tstuck = 1;\n\t\tgoto deselect;\n\t}\n\n\t \n\n\tcnt = 0;\n\twhile (cnt < len) {\n\t\tunsigned in_page;\n\t\tint wlen = len - cnt;\n\n\t\tin_page = addr % QSFP_PAGESIZE;\n\t\tif ((in_page + wlen) > QSFP_PAGESIZE)\n\t\t\twlen = QSFP_PAGESIZE - in_page;\n\t\tret = qib_twsi_blk_rd(dd, QSFP_DEV, addr, buff + cnt, wlen);\n\t\t \n\t\tif (ret && cnt == 0 && ++pass < QSFP_MAX_RETRY)\n\t\t\tcontinue;\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto deselect;\n\t\t}\n\t\taddr += wlen;\n\t\tcnt += wlen;\n\t}\n\tret = cnt;\n\ndeselect:\n\t \n\tudelay(10);\n\t \n\tdd->f_gpio_mod(dd, mask, mask, mask);\n\n\t \n\tif (stuck)\n\t\tqib_dev_err(dd, \"QSFP interface bus stuck non-idle\\n\");\n\n\tif (pass >= QSFP_MAX_RETRY && ret)\n\t\tqib_dev_porterr(dd, ppd->port, \"QSFP failed even retrying\\n\");\n\telse if (pass)\n\t\tqib_dev_porterr(dd, ppd->port, \"QSFP retries: %d\\n\", pass);\n\n\tmsleep(20);\n\nbail:\n\tmutex_unlock(&dd->eep_lock);\n\nno_unlock:\n\treturn ret;\n}\n\n \nstatic int qib_qsfp_write(struct qib_pportdata *ppd, int addr, void *bp,\n\t\t\t  int len)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu32 out, mask;\n\tint ret, cnt;\n\tu8 *buff = bp;\n\n\tret = mutex_lock_interruptible(&dd->eep_lock);\n\tif (ret)\n\t\tgoto no_unlock;\n\n\tif (dd->twsi_eeprom_dev == QIB_TWSI_NO_DEV) {\n\t\tret = -ENXIO;\n\t\tgoto bail;\n\t}\n\n\t \n\tmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\n\tout = QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\n\tif (ppd->hw_pidx) {\n\t\tmask <<= QSFP_GPIO_PORT2_SHIFT;\n\t\tout <<= QSFP_GPIO_PORT2_SHIFT;\n\t}\n\tdd->f_gpio_mod(dd, out, mask, mask);\n\n\t \n\tmsleep(20);\n\n\t \n\tret = qib_twsi_reset(dd);\n\tif (ret) {\n\t\tqib_dev_porterr(dd, ppd->port,\n\t\t\t\t\"QSFP interface Reset for write failed\\n\");\n\t\tret = -EIO;\n\t\tgoto deselect;\n\t}\n\n\t \n\n\tcnt = 0;\n\twhile (cnt < len) {\n\t\tunsigned in_page;\n\t\tint wlen = len - cnt;\n\n\t\tin_page = addr % QSFP_PAGESIZE;\n\t\tif ((in_page + wlen) > QSFP_PAGESIZE)\n\t\t\twlen = QSFP_PAGESIZE - in_page;\n\t\tret = qib_twsi_blk_wr(dd, QSFP_DEV, addr, buff + cnt, wlen);\n\t\tif (ret) {\n\t\t\t \n\t\t\tret = -EIO;\n\t\t\tgoto deselect;\n\t\t}\n\t\taddr += wlen;\n\t\tcnt += wlen;\n\t}\n\tret = cnt;\n\ndeselect:\n\t \n\tudelay(10);\n\t \n\tdd->f_gpio_mod(dd, mask, mask, mask);\n\t \n\tmsleep(20);\n\nbail:\n\tmutex_unlock(&dd->eep_lock);\n\nno_unlock:\n\treturn ret;\n}\n\n \nstatic int qsfp_cks(struct qib_pportdata *ppd, int first, int next)\n{\n\tint ret;\n\tu16 cks;\n\tu8 bval;\n\n\tcks = 0;\n\twhile (first < next) {\n\t\tret = qsfp_read(ppd, first, &bval, 1);\n\t\tif (ret < 0)\n\t\t\tgoto bail;\n\t\tcks += bval;\n\t\t++first;\n\t}\n\tret = cks & 0xFF;\nbail:\n\treturn ret;\n\n}\n\nint qib_refresh_qsfp_cache(struct qib_pportdata *ppd, struct qib_qsfp_cache *cp)\n{\n\tint ret;\n\tint idx;\n\tu16 cks;\n\tu8 peek[4];\n\n\t \n\tmemset(cp, 0, sizeof(*cp));\n\n\tif (!qib_qsfp_mod_present(ppd)) {\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tret = qsfp_read(ppd, 0, peek, 3);\n\tif (ret < 0)\n\t\tgoto bail;\n\tif ((peek[0] & 0xFE) != 0x0C)\n\t\tqib_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\"QSFP byte0 is 0x%02X, S/B 0x0C/D\\n\", peek[0]);\n\n\tif ((peek[2] & 4) == 0) {\n\t\t \n\t\tu8 poke = 0;\n\n\t\tret = qib_qsfp_write(ppd, 127, &poke, 1);\n\t\tudelay(50);\n\t\tif (ret != 1) {\n\t\t\tqib_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\t\"Failed QSFP Page set\\n\");\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tret = qsfp_read(ppd, QSFP_MOD_ID_OFFS, &cp->id, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tif ((cp->id & 0xFE) != 0x0C)\n\t\tqib_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\"QSFP ID byte is 0x%02X, S/B 0x0C/D\\n\", cp->id);\n\tcks = cp->id;\n\n\tret = qsfp_read(ppd, QSFP_MOD_PWR_OFFS, &cp->pwr, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += cp->pwr;\n\n\tret = qsfp_cks(ppd, QSFP_MOD_PWR_OFFS + 1, QSFP_MOD_LEN_OFFS);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += ret;\n\n\tret = qsfp_read(ppd, QSFP_MOD_LEN_OFFS, &cp->len, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += cp->len;\n\n\tret = qsfp_read(ppd, QSFP_MOD_TECH_OFFS, &cp->tech, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += cp->tech;\n\n\tret = qsfp_read(ppd, QSFP_VEND_OFFS, &cp->vendor, QSFP_VEND_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_VEND_LEN; ++idx)\n\t\tcks += cp->vendor[idx];\n\n\tret = qsfp_read(ppd, QSFP_IBXCV_OFFS, &cp->xt_xcv, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += cp->xt_xcv;\n\n\tret = qsfp_read(ppd, QSFP_VOUI_OFFS, &cp->oui, QSFP_VOUI_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_VOUI_LEN; ++idx)\n\t\tcks += cp->oui[idx];\n\n\tret = qsfp_read(ppd, QSFP_PN_OFFS, &cp->partnum, QSFP_PN_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_PN_LEN; ++idx)\n\t\tcks += cp->partnum[idx];\n\n\tret = qsfp_read(ppd, QSFP_REV_OFFS, &cp->rev, QSFP_REV_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_REV_LEN; ++idx)\n\t\tcks += cp->rev[idx];\n\n\tret = qsfp_read(ppd, QSFP_ATTEN_OFFS, &cp->atten, QSFP_ATTEN_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_ATTEN_LEN; ++idx)\n\t\tcks += cp->atten[idx];\n\n\tret = qsfp_cks(ppd, QSFP_ATTEN_OFFS + QSFP_ATTEN_LEN, QSFP_CC_OFFS);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += ret;\n\n\tcks &= 0xFF;\n\tret = qsfp_read(ppd, QSFP_CC_OFFS, &cp->cks1, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tif (cks != cp->cks1)\n\t\tqib_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\"QSFP cks1 is %02X, computed %02X\\n\", cp->cks1,\n\t\t\t\tcks);\n\n\t \n\tret = qsfp_cks(ppd, QSFP_CC_OFFS + 1, QSFP_SN_OFFS);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks = ret;\n\n\tret = qsfp_read(ppd, QSFP_SN_OFFS, &cp->serial, QSFP_SN_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_SN_LEN; ++idx)\n\t\tcks += cp->serial[idx];\n\n\tret = qsfp_read(ppd, QSFP_DATE_OFFS, &cp->date, QSFP_DATE_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_DATE_LEN; ++idx)\n\t\tcks += cp->date[idx];\n\n\tret = qsfp_read(ppd, QSFP_LOT_OFFS, &cp->lot, QSFP_LOT_LEN);\n\tif (ret < 0)\n\t\tgoto bail;\n\tfor (idx = 0; idx < QSFP_LOT_LEN; ++idx)\n\t\tcks += cp->lot[idx];\n\n\tret = qsfp_cks(ppd, QSFP_LOT_OFFS + QSFP_LOT_LEN, QSFP_CC_EXT_OFFS);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks += ret;\n\n\tret = qsfp_read(ppd, QSFP_CC_EXT_OFFS, &cp->cks2, 1);\n\tif (ret < 0)\n\t\tgoto bail;\n\tcks &= 0xFF;\n\tif (cks != cp->cks2)\n\t\tqib_dev_porterr(ppd->dd, ppd->port,\n\t\t\t\t\"QSFP cks2 is %02X, computed %02X\\n\", cp->cks2,\n\t\t\t\tcks);\n\treturn 0;\n\nbail:\n\tcp->id = 0;\n\treturn ret;\n}\n\nconst char * const qib_qsfp_devtech[16] = {\n\t\"850nm VCSEL\", \"1310nm VCSEL\", \"1550nm VCSEL\", \"1310nm FP\",\n\t\"1310nm DFB\", \"1550nm DFB\", \"1310nm EML\", \"1550nm EML\",\n\t\"Cu Misc\", \"1490nm DFB\", \"Cu NoEq\", \"Cu Eq\",\n\t\"Undef\", \"Cu Active BothEq\", \"Cu FarEq\", \"Cu NearEq\"\n};\n\n#define QSFP_DUMP_CHUNK 16  \n#define QSFP_DEFAULT_HDR_CNT 224\n\nstatic const char *pwr_codes = \"1.5W2.0W2.5W3.5W\";\n\nint qib_qsfp_mod_present(struct qib_pportdata *ppd)\n{\n\tu32 mask;\n\tint ret;\n\n\tmask = QSFP_GPIO_MOD_PRS_N <<\n\t\t(ppd->hw_pidx * QSFP_GPIO_PORT2_SHIFT);\n\tret = ppd->dd->f_gpio_mod(ppd->dd, 0, 0, 0);\n\n\treturn !((ret & mask) >>\n\t\t ((ppd->hw_pidx * QSFP_GPIO_PORT2_SHIFT) + 3));\n}\n\n \nvoid qib_qsfp_init(struct qib_qsfp_data *qd,\n\t\t   void (*fevent)(struct work_struct *))\n{\n\tu32 mask, highs;\n\n\tstruct qib_devdata *dd = qd->ppd->dd;\n\n\t \n\tINIT_WORK(&qd->work, fevent);\n\n\t \n\tmask = QSFP_GPIO_MOD_SEL_N | QSFP_GPIO_MOD_RST_N | QSFP_GPIO_LP_MODE;\n\thighs = mask - QSFP_GPIO_MOD_RST_N;\n\tif (qd->ppd->hw_pidx) {\n\t\tmask <<= QSFP_GPIO_PORT2_SHIFT;\n\t\thighs <<= QSFP_GPIO_PORT2_SHIFT;\n\t}\n\tdd->f_gpio_mod(dd, highs, mask, mask);\n\tudelay(20);  \n\n\tdd->f_gpio_mod(dd, mask, mask, mask);\n}\n\nint qib_qsfp_dump(struct qib_pportdata *ppd, char *buf, int len)\n{\n\tstruct qib_qsfp_cache cd;\n\tu8 bin_buff[QSFP_DUMP_CHUNK];\n\tchar lenstr[6];\n\tint sofar, ret;\n\tint bidx = 0;\n\n\tsofar = 0;\n\tret = qib_refresh_qsfp_cache(ppd, &cd);\n\tif (ret < 0)\n\t\tgoto bail;\n\n\tlenstr[0] = ' ';\n\tlenstr[1] = '\\0';\n\tif (QSFP_IS_CU(cd.tech))\n\t\tsprintf(lenstr, \"%dM \", cd.len);\n\n\tsofar += scnprintf(buf + sofar, len - sofar, \"PWR:%.3sW\\n\", pwr_codes +\n\t\t\t   (QSFP_PWR(cd.pwr) * 4));\n\n\tsofar += scnprintf(buf + sofar, len - sofar, \"TECH:%s%s\\n\", lenstr,\n\t\t\t   qib_qsfp_devtech[cd.tech >> 4]);\n\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Vendor:%.*s\\n\",\n\t\t\t   QSFP_VEND_LEN, cd.vendor);\n\n\tsofar += scnprintf(buf + sofar, len - sofar, \"OUI:%06X\\n\",\n\t\t\t   QSFP_OUI(cd.oui));\n\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Part#:%.*s\\n\",\n\t\t\t   QSFP_PN_LEN, cd.partnum);\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Rev:%.*s\\n\",\n\t\t\t   QSFP_REV_LEN, cd.rev);\n\tif (QSFP_IS_CU(cd.tech))\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"Atten:%d, %d\\n\",\n\t\t\t\t   QSFP_ATTEN_SDR(cd.atten),\n\t\t\t\t   QSFP_ATTEN_DDR(cd.atten));\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Serial:%.*s\\n\",\n\t\t\t   QSFP_SN_LEN, cd.serial);\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Date:%.*s\\n\",\n\t\t\t   QSFP_DATE_LEN, cd.date);\n\tsofar += scnprintf(buf + sofar, len - sofar, \"Lot:%.*s\\n\",\n\t\t\t   QSFP_LOT_LEN, cd.lot);\n\n\twhile (bidx < QSFP_DEFAULT_HDR_CNT) {\n\t\tint iidx;\n\n\t\tret = qsfp_read(ppd, bidx, bin_buff, QSFP_DUMP_CHUNK);\n\t\tif (ret < 0)\n\t\t\tgoto bail;\n\t\tfor (iidx = 0; iidx < ret; ++iidx) {\n\t\t\tsofar += scnprintf(buf + sofar, len-sofar, \" %02X\",\n\t\t\t\tbin_buff[iidx]);\n\t\t}\n\t\tsofar += scnprintf(buf + sofar, len - sofar, \"\\n\");\n\t\tbidx += QSFP_DUMP_CHUNK;\n\t}\n\tret = sofar;\nbail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}