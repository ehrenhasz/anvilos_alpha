{
  "module_name": "qib_eeprom.c",
  "hash_id": "209bcf4f8837ca91d9d68d564ce673bbb5b67c3f2c81872c384403a343574a80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_eeprom.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include \"qib.h\"\n\n \n\n \nint qib_eeprom_read(struct qib_devdata *dd, u8 eeprom_offset,\n\t\t    void *buff, int len)\n{\n\tint ret;\n\n\tret = mutex_lock_interruptible(&dd->eep_lock);\n\tif (!ret) {\n\t\tret = qib_twsi_reset(dd);\n\t\tif (ret)\n\t\t\tqib_dev_err(dd, \"EEPROM Reset for read failed\\n\");\n\t\telse\n\t\t\tret = qib_twsi_blk_rd(dd, dd->twsi_eeprom_dev,\n\t\t\t\t\t      eeprom_offset, buff, len);\n\t\tmutex_unlock(&dd->eep_lock);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int eeprom_write_with_enable(struct qib_devdata *dd, u8 offset,\n\t\t     const void *buf, int len)\n{\n\tint ret, pwen;\n\n\tpwen = dd->f_eeprom_wen(dd, 1);\n\tret = qib_twsi_reset(dd);\n\tif (ret)\n\t\tqib_dev_err(dd, \"EEPROM Reset for write failed\\n\");\n\telse\n\t\tret = qib_twsi_blk_wr(dd, dd->twsi_eeprom_dev,\n\t\t\t\t      offset, buf, len);\n\tdd->f_eeprom_wen(dd, pwen);\n\treturn ret;\n}\n\n \nint qib_eeprom_write(struct qib_devdata *dd, u8 eeprom_offset,\n\t\t     const void *buff, int len)\n{\n\tint ret;\n\n\tret = mutex_lock_interruptible(&dd->eep_lock);\n\tif (!ret) {\n\t\tret = eeprom_write_with_enable(dd, eeprom_offset, buff, len);\n\t\tmutex_unlock(&dd->eep_lock);\n\t}\n\n\treturn ret;\n}\n\nstatic u8 flash_csum(struct qib_flash *ifp, int adjust)\n{\n\tu8 *ip = (u8 *) ifp;\n\tu8 csum = 0, len;\n\n\t \n\tlen = ifp->if_length;\n\tif (len > sizeof(struct qib_flash))\n\t\tlen = sizeof(struct qib_flash);\n\twhile (len--)\n\t\tcsum += *ip++;\n\tcsum -= ifp->if_csum;\n\tcsum = ~csum;\n\tif (adjust)\n\t\tifp->if_csum = csum;\n\n\treturn csum;\n}\n\n \nvoid qib_get_eeprom_info(struct qib_devdata *dd)\n{\n\tvoid *buf;\n\tstruct qib_flash *ifp;\n\t__be64 guid;\n\tint len, eep_stat;\n\tu8 csum, *bguid;\n\tint t = dd->unit;\n\tstruct qib_devdata *dd0 = qib_lookup(0);\n\n\tif (t && dd0->nguid > 1 && t <= dd0->nguid) {\n\t\tu8 oguid;\n\n\t\tdd->base_guid = dd0->base_guid;\n\t\tbguid = (u8 *) &dd->base_guid;\n\n\t\toguid = bguid[7];\n\t\tbguid[7] += t;\n\t\tif (oguid > bguid[7]) {\n\t\t\tif (bguid[6] == 0xff) {\n\t\t\t\tif (bguid[5] == 0xff) {\n\t\t\t\t\tqib_dev_err(dd,\n\t\t\t\t\t\t    \"Can't set GUID from base, wraps to OUI!\\n\");\n\t\t\t\t\tdd->base_guid = 0;\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tbguid[5]++;\n\t\t\t}\n\t\t\tbguid[6]++;\n\t\t}\n\t\tdd->nguid = 1;\n\t\tgoto bail;\n\t}\n\n\t \n\tlen = sizeof(struct qib_flash);\n\tbuf = vmalloc(len);\n\tif (!buf)\n\t\tgoto bail;\n\n\t \n\teep_stat = qib_eeprom_read(dd, 0, buf, len);\n\n\tif (eep_stat) {\n\t\tqib_dev_err(dd, \"Failed reading GUID from eeprom\\n\");\n\t\tgoto done;\n\t}\n\tifp = (struct qib_flash *)buf;\n\n\tcsum = flash_csum(ifp, 0);\n\tif (csum != ifp->if_csum) {\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Bad I2C flash checksum: 0x%x, not 0x%x\\n\",\n\t\t\tcsum, ifp->if_csum);\n\t\tgoto done;\n\t}\n\tif (*(__be64 *) ifp->if_guid == cpu_to_be64(0) ||\n\t    *(__be64 *) ifp->if_guid == ~cpu_to_be64(0)) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Invalid GUID %llx from flash; ignoring\\n\",\n\t\t\t*(unsigned long long *) ifp->if_guid);\n\t\t \n\t\tgoto done;\n\t}\n\n\t \n\tif (*(u64 *) ifp->if_guid == 0x100007511000000ULL)\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Warning, GUID %llx is default, probably not correct!\\n\",\n\t\t\t*(unsigned long long *) ifp->if_guid);\n\n\tbguid = ifp->if_guid;\n\tif (!bguid[0] && !bguid[1] && !bguid[2]) {\n\t\t \n\t\tbguid[1] = bguid[3];\n\t\tbguid[2] = bguid[4];\n\t\tbguid[3] = 0;\n\t\tbguid[4] = 0;\n\t\tguid = *(__be64 *) ifp->if_guid;\n\t} else\n\t\tguid = *(__be64 *) ifp->if_guid;\n\tdd->base_guid = guid;\n\tdd->nguid = ifp->if_numguid;\n\t \n\tif ((ifp->if_fversion > 1) && ifp->if_sprefix[0] &&\n\t    ((u8 *) ifp->if_sprefix)[0] != 0xFF) {\n\t\tchar *snp = dd->serial;\n\n\t\t \n\t\tmemcpy(snp, ifp->if_sprefix, sizeof(ifp->if_sprefix));\n\t\tsnp[sizeof(ifp->if_sprefix)] = '\\0';\n\t\tlen = strlen(snp);\n\t\tsnp += len;\n\t\tlen = sizeof(dd->serial) - len;\n\t\tif (len > sizeof(ifp->if_serial))\n\t\t\tlen = sizeof(ifp->if_serial);\n\t\tmemcpy(snp, ifp->if_serial, len);\n\t} else {\n\t\tmemcpy(dd->serial, ifp->if_serial, sizeof(ifp->if_serial));\n\t}\n\tif (!strstr(ifp->if_comment, \"Tested successfully\"))\n\t\tqib_dev_err(dd,\n\t\t\t\"Board SN %s did not pass functional test: %s\\n\",\n\t\t\tdd->serial, ifp->if_comment);\n\ndone:\n\tvfree(buf);\n\nbail:;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}