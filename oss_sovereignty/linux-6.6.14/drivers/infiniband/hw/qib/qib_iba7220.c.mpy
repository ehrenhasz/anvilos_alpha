{
  "module_name": "qib_iba7220.c",
  "hash_id": "110dc42386e524ab3a9f6eb6c9e7e46b0c1350068fff9180d342b564e420142f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_iba7220.c",
  "human_readable_source": " \n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <rdma/ib_verbs.h>\n\n#include \"qib.h\"\n#include \"qib_7220.h\"\n\nstatic void qib_setup_7220_setextled(struct qib_pportdata *, u32);\nstatic void qib_7220_handle_hwerrors(struct qib_devdata *, char *, size_t);\nstatic void sendctrl_7220_mod(struct qib_pportdata *ppd, u32 op);\nstatic u32 qib_7220_iblink_state(u64);\nstatic u8 qib_7220_phys_portstate(u64);\nstatic void qib_sdma_update_7220_tail(struct qib_pportdata *, u16);\nstatic void qib_set_ib_7220_lstate(struct qib_pportdata *, u16, u16);\n\n \n\n \n#define KREG_IDX(regname) (QIB_7220_##regname##_OFFS / sizeof(u64))\n\n \n#define kr_control KREG_IDX(Control)\n#define kr_counterregbase KREG_IDX(CntrRegBase)\n#define kr_errclear KREG_IDX(ErrClear)\n#define kr_errmask KREG_IDX(ErrMask)\n#define kr_errstatus KREG_IDX(ErrStatus)\n#define kr_extctrl KREG_IDX(EXTCtrl)\n#define kr_extstatus KREG_IDX(EXTStatus)\n#define kr_gpio_clear KREG_IDX(GPIOClear)\n#define kr_gpio_mask KREG_IDX(GPIOMask)\n#define kr_gpio_out KREG_IDX(GPIOOut)\n#define kr_gpio_status KREG_IDX(GPIOStatus)\n#define kr_hrtbt_guid KREG_IDX(HRTBT_GUID)\n#define kr_hwdiagctrl KREG_IDX(HwDiagCtrl)\n#define kr_hwerrclear KREG_IDX(HwErrClear)\n#define kr_hwerrmask KREG_IDX(HwErrMask)\n#define kr_hwerrstatus KREG_IDX(HwErrStatus)\n#define kr_ibcctrl KREG_IDX(IBCCtrl)\n#define kr_ibcddrctrl KREG_IDX(IBCDDRCtrl)\n#define kr_ibcddrstatus KREG_IDX(IBCDDRStatus)\n#define kr_ibcstatus KREG_IDX(IBCStatus)\n#define kr_ibserdesctrl KREG_IDX(IBSerDesCtrl)\n#define kr_intclear KREG_IDX(IntClear)\n#define kr_intmask KREG_IDX(IntMask)\n#define kr_intstatus KREG_IDX(IntStatus)\n#define kr_ncmodectrl KREG_IDX(IBNCModeCtrl)\n#define kr_palign KREG_IDX(PageAlign)\n#define kr_partitionkey KREG_IDX(RcvPartitionKey)\n#define kr_portcnt KREG_IDX(PortCnt)\n#define kr_rcvbthqp KREG_IDX(RcvBTHQP)\n#define kr_rcvctrl KREG_IDX(RcvCtrl)\n#define kr_rcvegrbase KREG_IDX(RcvEgrBase)\n#define kr_rcvegrcnt KREG_IDX(RcvEgrCnt)\n#define kr_rcvhdrcnt KREG_IDX(RcvHdrCnt)\n#define kr_rcvhdrentsize KREG_IDX(RcvHdrEntSize)\n#define kr_rcvhdrsize KREG_IDX(RcvHdrSize)\n#define kr_rcvpktledcnt KREG_IDX(RcvPktLEDCnt)\n#define kr_rcvtidbase KREG_IDX(RcvTIDBase)\n#define kr_rcvtidcnt KREG_IDX(RcvTIDCnt)\n#define kr_revision KREG_IDX(Revision)\n#define kr_scratch KREG_IDX(Scratch)\n#define kr_sendbuffererror KREG_IDX(SendBufErr0)\n#define kr_sendctrl KREG_IDX(SendCtrl)\n#define kr_senddmabase KREG_IDX(SendDmaBase)\n#define kr_senddmabufmask0 KREG_IDX(SendDmaBufMask0)\n#define kr_senddmabufmask1 (KREG_IDX(SendDmaBufMask0) + 1)\n#define kr_senddmabufmask2 (KREG_IDX(SendDmaBufMask0) + 2)\n#define kr_senddmahead KREG_IDX(SendDmaHead)\n#define kr_senddmaheadaddr KREG_IDX(SendDmaHeadAddr)\n#define kr_senddmalengen KREG_IDX(SendDmaLenGen)\n#define kr_senddmastatus KREG_IDX(SendDmaStatus)\n#define kr_senddmatail KREG_IDX(SendDmaTail)\n#define kr_sendpioavailaddr KREG_IDX(SendBufAvailAddr)\n#define kr_sendpiobufbase KREG_IDX(SendBufBase)\n#define kr_sendpiobufcnt KREG_IDX(SendBufCnt)\n#define kr_sendpiosize KREG_IDX(SendBufSize)\n#define kr_sendregbase KREG_IDX(SendRegBase)\n#define kr_userregbase KREG_IDX(UserRegBase)\n#define kr_xgxs_cfg KREG_IDX(XGXSCfg)\n\n \n#define kr_rcvhdraddr KREG_IDX(RcvHdrAddr0)\n#define kr_rcvhdrtailaddr KREG_IDX(RcvHdrTailAddr0)\n\n\n#define CREG_IDX(regname) ((QIB_7220_##regname##_OFFS - \\\n\t\t\tQIB_7220_LBIntCnt_OFFS) / sizeof(u64))\n\n#define cr_badformat CREG_IDX(RxVersionErrCnt)\n#define cr_erricrc CREG_IDX(RxICRCErrCnt)\n#define cr_errlink CREG_IDX(RxLinkMalformCnt)\n#define cr_errlpcrc CREG_IDX(RxLPCRCErrCnt)\n#define cr_errpkey CREG_IDX(RxPKeyMismatchCnt)\n#define cr_rcvflowctrl_err CREG_IDX(RxFlowCtrlViolCnt)\n#define cr_err_rlen CREG_IDX(RxLenErrCnt)\n#define cr_errslen CREG_IDX(TxLenErrCnt)\n#define cr_errtidfull CREG_IDX(RxTIDFullErrCnt)\n#define cr_errtidvalid CREG_IDX(RxTIDValidErrCnt)\n#define cr_errvcrc CREG_IDX(RxVCRCErrCnt)\n#define cr_ibstatuschange CREG_IDX(IBStatusChangeCnt)\n#define cr_lbint CREG_IDX(LBIntCnt)\n#define cr_invalidrlen CREG_IDX(RxMaxMinLenErrCnt)\n#define cr_invalidslen CREG_IDX(TxMaxMinLenErrCnt)\n#define cr_lbflowstall CREG_IDX(LBFlowStallCnt)\n#define cr_pktrcv CREG_IDX(RxDataPktCnt)\n#define cr_pktrcvflowctrl CREG_IDX(RxFlowPktCnt)\n#define cr_pktsend CREG_IDX(TxDataPktCnt)\n#define cr_pktsendflow CREG_IDX(TxFlowPktCnt)\n#define cr_portovfl CREG_IDX(RxP0HdrEgrOvflCnt)\n#define cr_rcvebp CREG_IDX(RxEBPCnt)\n#define cr_rcvovfl CREG_IDX(RxBufOvflCnt)\n#define cr_senddropped CREG_IDX(TxDroppedPktCnt)\n#define cr_sendstall CREG_IDX(TxFlowStallCnt)\n#define cr_sendunderrun CREG_IDX(TxUnderrunCnt)\n#define cr_wordrcv CREG_IDX(RxDwordCnt)\n#define cr_wordsend CREG_IDX(TxDwordCnt)\n#define cr_txunsupvl CREG_IDX(TxUnsupVLErrCnt)\n#define cr_rxdroppkt CREG_IDX(RxDroppedPktCnt)\n#define cr_iblinkerrrecov CREG_IDX(IBLinkErrRecoveryCnt)\n#define cr_iblinkdown CREG_IDX(IBLinkDownedCnt)\n#define cr_ibsymbolerr CREG_IDX(IBSymbolErrCnt)\n#define cr_vl15droppedpkt CREG_IDX(RxVL15DroppedPktCnt)\n#define cr_rxotherlocalphyerr CREG_IDX(RxOtherLocalPhyErrCnt)\n#define cr_excessbufferovfl CREG_IDX(ExcessBufferOvflCnt)\n#define cr_locallinkintegrityerr CREG_IDX(LocalLinkIntegrityErrCnt)\n#define cr_rxvlerr CREG_IDX(RxVlErrCnt)\n#define cr_rxdlidfltr CREG_IDX(RxDlidFltrCnt)\n#define cr_psstat CREG_IDX(PSStat)\n#define cr_psstart CREG_IDX(PSStart)\n#define cr_psinterval CREG_IDX(PSInterval)\n#define cr_psrcvdatacount CREG_IDX(PSRcvDataCount)\n#define cr_psrcvpktscount CREG_IDX(PSRcvPktsCount)\n#define cr_psxmitdatacount CREG_IDX(PSXmitDataCount)\n#define cr_psxmitpktscount CREG_IDX(PSXmitPktsCount)\n#define cr_psxmitwaitcount CREG_IDX(PSXmitWaitCount)\n#define cr_txsdmadesc CREG_IDX(TxSDmaDescCnt)\n#define cr_pcieretrydiag CREG_IDX(PcieRetryBufDiagQwordCnt)\n\n#define SYM_RMASK(regname, fldname) ((u64)              \\\n\tQIB_7220_##regname##_##fldname##_RMASK)\n#define SYM_MASK(regname, fldname) ((u64)               \\\n\tQIB_7220_##regname##_##fldname##_RMASK <<       \\\n\t QIB_7220_##regname##_##fldname##_LSB)\n#define SYM_LSB(regname, fldname) (QIB_7220_##regname##_##fldname##_LSB)\n#define SYM_FIELD(value, regname, fldname) ((u64) \\\n\t(((value) >> SYM_LSB(regname, fldname)) & \\\n\t SYM_RMASK(regname, fldname)))\n#define ERR_MASK(fldname) SYM_MASK(ErrMask, fldname##Mask)\n#define HWE_MASK(fldname) SYM_MASK(HwErrMask, fldname##Mask)\n\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_DISABLE 1\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_POLL 2\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_SLEEP 3\n#define QLOGIC_IB_IBCC_LINKINITCMD_SHIFT 16\n\n#define QLOGIC_IB_IBCC_LINKCMD_DOWN 1            \n#define QLOGIC_IB_IBCC_LINKCMD_ARMED 2           \n#define QLOGIC_IB_IBCC_LINKCMD_ACTIVE 3  \n\n#define BLOB_7220_IBCHG 0x81\n\n \n\n \nstatic inline u32 qib_read_ureg32(const struct qib_devdata *dd,\n\t\t\t\t  enum qib_ureg regno, int ctxt)\n{\n\tif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\n\tif (dd->userbase)\n\t\treturn readl(regno + (u64 __iomem *)\n\t\t\t     ((char __iomem *)dd->userbase +\n\t\t\t      dd->ureg_align * ctxt));\n\telse\n\t\treturn readl(regno + (u64 __iomem *)\n\t\t\t     (dd->uregbase +\n\t\t\t      (char __iomem *)dd->kregbase +\n\t\t\t      dd->ureg_align * ctxt));\n}\n\n \nstatic inline void qib_write_ureg(const struct qib_devdata *dd,\n\t\t\t\t  enum qib_ureg regno, u64 value, int ctxt)\n{\n\tu64 __iomem *ubase;\n\n\tif (dd->userbase)\n\t\tubase = (u64 __iomem *)\n\t\t\t((char __iomem *) dd->userbase +\n\t\t\t dd->ureg_align * ctxt);\n\telse\n\t\tubase = (u64 __iomem *)\n\t\t\t(dd->uregbase +\n\t\t\t (char __iomem *) dd->kregbase +\n\t\t\t dd->ureg_align * ctxt);\n\n\tif (dd->kregbase && (dd->flags & QIB_PRESENT))\n\t\twriteq(value, &ubase[regno]);\n}\n\n \nstatic inline void qib_write_kreg_ctxt(const struct qib_devdata *dd,\n\t\t\t\t       const u16 regno, unsigned ctxt,\n\t\t\t\t       u64 value)\n{\n\tqib_write_kreg(dd, regno + ctxt, value);\n}\n\nstatic inline void write_7220_creg(const struct qib_devdata *dd,\n\t\t\t\t   u16 regno, u64 value)\n{\n\tif (dd->cspec->cregbase && (dd->flags & QIB_PRESENT))\n\t\twriteq(value, &dd->cspec->cregbase[regno]);\n}\n\nstatic inline u64 read_7220_creg(const struct qib_devdata *dd, u16 regno)\n{\n\tif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\treturn readq(&dd->cspec->cregbase[regno]);\n}\n\nstatic inline u32 read_7220_creg32(const struct qib_devdata *dd, u16 regno)\n{\n\tif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\treturn readl(&dd->cspec->cregbase[regno]);\n}\n\n \n#define QLOGIC_IB_R_EMULATORREV_MASK ((1ULL << 22) - 1)\n#define QLOGIC_IB_R_EMULATORREV_SHIFT 40\n\n \n#define QLOGIC_IB_C_RESET (1U << 7)\n\n \n#define QLOGIC_IB_I_RCVURG_MASK ((1ULL << 17) - 1)\n#define QLOGIC_IB_I_RCVURG_SHIFT 32\n#define QLOGIC_IB_I_RCVAVAIL_MASK ((1ULL << 17) - 1)\n#define QLOGIC_IB_I_RCVAVAIL_SHIFT 0\n#define QLOGIC_IB_I_SERDESTRIMDONE (1ULL << 27)\n\n#define QLOGIC_IB_C_FREEZEMODE 0x00000002\n#define QLOGIC_IB_C_LINKENABLE 0x00000004\n\n#define QLOGIC_IB_I_SDMAINT             0x8000000000000000ULL\n#define QLOGIC_IB_I_SDMADISABLED        0x4000000000000000ULL\n#define QLOGIC_IB_I_ERROR               0x0000000080000000ULL\n#define QLOGIC_IB_I_SPIOSENT            0x0000000040000000ULL\n#define QLOGIC_IB_I_SPIOBUFAVAIL        0x0000000020000000ULL\n#define QLOGIC_IB_I_GPIO                0x0000000010000000ULL\n\n \n#define QLOGIC_IB_I_BITSEXTANT \\\n\t\t(QLOGIC_IB_I_SDMAINT | QLOGIC_IB_I_SDMADISABLED | \\\n\t\t(QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT) | \\\n\t\t(QLOGIC_IB_I_RCVAVAIL_MASK << \\\n\t\t QLOGIC_IB_I_RCVAVAIL_SHIFT) | \\\n\t\tQLOGIC_IB_I_ERROR | QLOGIC_IB_I_SPIOSENT | \\\n\t\tQLOGIC_IB_I_SPIOBUFAVAIL | QLOGIC_IB_I_GPIO | \\\n\t\tQLOGIC_IB_I_SERDESTRIMDONE)\n\n#define IB_HWE_BITSEXTANT \\\n\t       (HWE_MASK(RXEMemParityErr) | \\\n\t\tHWE_MASK(TXEMemParityErr) | \\\n\t\t(QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\t \\\n\t\t QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) | \\\n\t\tQLOGIC_IB_HWE_PCIE1PLLFAILED | \\\n\t\tQLOGIC_IB_HWE_PCIE0PLLFAILED | \\\n\t\tQLOGIC_IB_HWE_PCIEPOISONEDTLP | \\\n\t\tQLOGIC_IB_HWE_PCIECPLTIMEOUT | \\\n\t\tQLOGIC_IB_HWE_PCIEBUSPARITYXTLH | \\\n\t\tQLOGIC_IB_HWE_PCIEBUSPARITYXADM | \\\n\t\tQLOGIC_IB_HWE_PCIEBUSPARITYRADM | \\\n\t\tHWE_MASK(PowerOnBISTFailed) |\t  \\\n\t\tQLOGIC_IB_HWE_COREPLL_FBSLIP | \\\n\t\tQLOGIC_IB_HWE_COREPLL_RFSLIP | \\\n\t\tQLOGIC_IB_HWE_SERDESPLLFAILED | \\\n\t\tHWE_MASK(IBCBusToSPCParityErr) | \\\n\t\tHWE_MASK(IBCBusFromSPCParityErr) | \\\n\t\tQLOGIC_IB_HWE_PCIECPLDATAQUEUEERR | \\\n\t\tQLOGIC_IB_HWE_PCIECPLHDRQUEUEERR | \\\n\t\tQLOGIC_IB_HWE_SDMAMEMREADERR | \\\n\t\tQLOGIC_IB_HWE_CLK_UC_PLLNOTLOCKED | \\\n\t\tQLOGIC_IB_HWE_PCIESERDESQ0PCLKNOTDETECT | \\\n\t\tQLOGIC_IB_HWE_PCIESERDESQ1PCLKNOTDETECT | \\\n\t\tQLOGIC_IB_HWE_PCIESERDESQ2PCLKNOTDETECT | \\\n\t\tQLOGIC_IB_HWE_PCIESERDESQ3PCLKNOTDETECT | \\\n\t\tQLOGIC_IB_HWE_DDSRXEQMEMORYPARITYERR | \\\n\t\tQLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR | \\\n\t\tQLOGIC_IB_HWE_PCIE_UC_OCT0MEMORYPARITYERR | \\\n\t\tQLOGIC_IB_HWE_PCIE_UC_OCT1MEMORYPARITYERR)\n\n#define IB_E_BITSEXTANT\t\t\t\t\t\t\t\\\n\t(ERR_MASK(RcvFormatErr) | ERR_MASK(RcvVCRCErr) |\t\t\\\n\t ERR_MASK(RcvICRCErr) | ERR_MASK(RcvMinPktLenErr) |\t\t\\\n\t ERR_MASK(RcvMaxPktLenErr) | ERR_MASK(RcvLongPktLenErr) |\t\\\n\t ERR_MASK(RcvShortPktLenErr) | ERR_MASK(RcvUnexpectedCharErr) | \\\n\t ERR_MASK(RcvUnsupportedVLErr) | ERR_MASK(RcvEBPErr) |\t\t\\\n\t ERR_MASK(RcvIBFlowErr) | ERR_MASK(RcvBadVersionErr) |\t\t\\\n\t ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr) |\t\t\\\n\t ERR_MASK(RcvBadTidErr) | ERR_MASK(RcvHdrLenErr) |\t\t\\\n\t ERR_MASK(RcvHdrErr) | ERR_MASK(RcvIBLostLinkErr) |\t\t\\\n\t ERR_MASK(SendSpecialTriggerErr) |\t\t\t\t\\\n\t ERR_MASK(SDmaDisabledErr) | ERR_MASK(SendMinPktLenErr) |\t\\\n\t ERR_MASK(SendMaxPktLenErr) | ERR_MASK(SendUnderRunErr) |\t\\\n\t ERR_MASK(SendPktLenErr) | ERR_MASK(SendDroppedSmpPktErr) |\t\\\n\t ERR_MASK(SendDroppedDataPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendPioArmLaunchErr) |\t\t\t\t\\\n\t ERR_MASK(SendUnexpectedPktNumErr) |\t\t\t\t\\\n\t ERR_MASK(SendUnsupportedVLErr) | ERR_MASK(SendBufMisuseErr) |\t\\\n\t ERR_MASK(SDmaGenMismatchErr) | ERR_MASK(SDmaOutOfBoundErr) |\t\\\n\t ERR_MASK(SDmaTailOutOfBoundErr) | ERR_MASK(SDmaBaseErr) |\t\\\n\t ERR_MASK(SDma1stDescErr) | ERR_MASK(SDmaRpyTagErr) |\t\t\\\n\t ERR_MASK(SDmaDwEnErr) | ERR_MASK(SDmaMissingDwErr) |\t\t\\\n\t ERR_MASK(SDmaUnexpDataErr) |\t\t\t\t\t\\\n\t ERR_MASK(IBStatusChanged) | ERR_MASK(InvalidAddrErr) |\t\t\\\n\t ERR_MASK(ResetNegated) | ERR_MASK(HardwareErr) |\t\t\\\n\t ERR_MASK(SDmaDescAddrMisalignErr) |\t\t\t\t\\\n\t ERR_MASK(InvalidEEPCmd))\n\n \n#define QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK  0x00000000000000ffULL\n#define QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT 0\n#define QLOGIC_IB_HWE_PCIEPOISONEDTLP      0x0000000010000000ULL\n#define QLOGIC_IB_HWE_PCIECPLTIMEOUT       0x0000000020000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYXTLH    0x0000000040000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYXADM    0x0000000080000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYRADM    0x0000000100000000ULL\n#define QLOGIC_IB_HWE_COREPLL_FBSLIP       0x0080000000000000ULL\n#define QLOGIC_IB_HWE_COREPLL_RFSLIP       0x0100000000000000ULL\n#define QLOGIC_IB_HWE_PCIE1PLLFAILED       0x0400000000000000ULL\n#define QLOGIC_IB_HWE_PCIE0PLLFAILED       0x0800000000000000ULL\n#define QLOGIC_IB_HWE_SERDESPLLFAILED      0x1000000000000000ULL\n \n#define QLOGIC_IB_HWE_PCIECPLDATAQUEUEERR         0x0000000000000040ULL\n#define QLOGIC_IB_HWE_PCIECPLHDRQUEUEERR          0x0000000000000080ULL\n#define QLOGIC_IB_HWE_SDMAMEMREADERR              0x0000000010000000ULL\n#define QLOGIC_IB_HWE_CLK_UC_PLLNOTLOCKED          0x2000000000000000ULL\n#define QLOGIC_IB_HWE_PCIESERDESQ0PCLKNOTDETECT   0x0100000000000000ULL\n#define QLOGIC_IB_HWE_PCIESERDESQ1PCLKNOTDETECT   0x0200000000000000ULL\n#define QLOGIC_IB_HWE_PCIESERDESQ2PCLKNOTDETECT   0x0400000000000000ULL\n#define QLOGIC_IB_HWE_PCIESERDESQ3PCLKNOTDETECT   0x0800000000000000ULL\n#define QLOGIC_IB_HWE_DDSRXEQMEMORYPARITYERR       0x0000008000000000ULL\n#define QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR        0x0000004000000000ULL\n#define QLOGIC_IB_HWE_PCIE_UC_OCT0MEMORYPARITYERR 0x0000001000000000ULL\n#define QLOGIC_IB_HWE_PCIE_UC_OCT1MEMORYPARITYERR 0x0000002000000000ULL\n\n#define IBA7220_IBCC_LINKCMD_SHIFT 19\n\n \n#define IBA7220_IBC_DLIDLMC_MASK        0xFFFFFFFFUL\n#define IBA7220_IBC_DLIDLMC_SHIFT       32\n\n#define IBA7220_IBC_HRTBT_MASK  (SYM_RMASK(IBCDDRCtrl, HRTBT_AUTO) | \\\n\t\t\t\t SYM_RMASK(IBCDDRCtrl, HRTBT_ENB))\n#define IBA7220_IBC_HRTBT_SHIFT SYM_LSB(IBCDDRCtrl, HRTBT_ENB)\n\n#define IBA7220_IBC_LANE_REV_SUPPORTED (1<<8)\n#define IBA7220_IBC_LREV_MASK   1\n#define IBA7220_IBC_LREV_SHIFT  8\n#define IBA7220_IBC_RXPOL_MASK  1\n#define IBA7220_IBC_RXPOL_SHIFT 7\n#define IBA7220_IBC_WIDTH_SHIFT 5\n#define IBA7220_IBC_WIDTH_MASK  0x3\n#define IBA7220_IBC_WIDTH_1X_ONLY       (0 << IBA7220_IBC_WIDTH_SHIFT)\n#define IBA7220_IBC_WIDTH_4X_ONLY       (1 << IBA7220_IBC_WIDTH_SHIFT)\n#define IBA7220_IBC_WIDTH_AUTONEG       (2 << IBA7220_IBC_WIDTH_SHIFT)\n#define IBA7220_IBC_SPEED_AUTONEG       (1 << 1)\n#define IBA7220_IBC_SPEED_SDR           (1 << 2)\n#define IBA7220_IBC_SPEED_DDR           (1 << 3)\n#define IBA7220_IBC_SPEED_AUTONEG_MASK  (0x7 << 1)\n#define IBA7220_IBC_IBTA_1_2_MASK       (1)\n\n \n \n#define IBA7220_DDRSTAT_LINKLAT_MASK    0x3ffffff\n\n \n#define QLOGIC_IB_EXTS_FREQSEL 0x2\n#define QLOGIC_IB_EXTS_SERDESSEL 0x4\n#define QLOGIC_IB_EXTS_MEMBIST_ENDTEST     0x0000000000004000\n#define QLOGIC_IB_EXTS_MEMBIST_DISABLED    0x0000000000008000\n\n \n#define QLOGIC_IB_XGXS_RESET          0x5ULL\n#define QLOGIC_IB_XGXS_FC_SAFE        (1ULL << 63)\n\n \n#define IBA7220_LEDBLINK_ON_SHIFT 32  \n#define IBA7220_LEDBLINK_OFF_SHIFT 0  \n\n#define _QIB_GPIO_SDA_NUM 1\n#define _QIB_GPIO_SCL_NUM 0\n#define QIB_TWSI_EEPROM_DEV 0xA2  \n#define QIB_TWSI_TEMP_DEV 0x98\n\n \n#define QIB_7220_PSXMITWAIT_CHECK_RATE 4000\n\n#define IBA7220_R_INTRAVAIL_SHIFT 17\n#define IBA7220_R_PKEY_DIS_SHIFT 34\n#define IBA7220_R_TAILUPD_SHIFT 35\n#define IBA7220_R_CTXTCFG_SHIFT 36\n\n#define IBA7220_HDRHEAD_PKTINT_SHIFT 32  \n\n \n#define IBA7220_TID_SZ_SHIFT 37  \n#define IBA7220_TID_SZ_2K (1UL << IBA7220_TID_SZ_SHIFT)  \n#define IBA7220_TID_SZ_4K (2UL << IBA7220_TID_SZ_SHIFT)  \n#define IBA7220_TID_PA_SHIFT 11U  \n#define PBC_7220_VL15_SEND (1ULL << 63)  \n#define PBC_7220_VL15_SEND_CTRL (1ULL << 31)  \n\n#define AUTONEG_TRIES 5  \n\n \nstatic u8 rate_to_delay[2][2] = {\n\t \n\t{   8, 2 },  \n\t{   4, 1 }   \n};\n\nstatic u8 ib_rate_to_delay[IB_RATE_120_GBPS + 1] = {\n\t[IB_RATE_2_5_GBPS] = 8,\n\t[IB_RATE_5_GBPS] = 4,\n\t[IB_RATE_10_GBPS] = 2,\n\t[IB_RATE_20_GBPS] = 1\n};\n\n#define IBA7220_LINKSPEED_SHIFT SYM_LSB(IBCStatus, LinkSpeedActive)\n#define IBA7220_LINKWIDTH_SHIFT SYM_LSB(IBCStatus, LinkWidthActive)\n\n \n#define IB_7220_LT_STATE_DISABLED        0x00\n#define IB_7220_LT_STATE_LINKUP          0x01\n#define IB_7220_LT_STATE_POLLACTIVE      0x02\n#define IB_7220_LT_STATE_POLLQUIET       0x03\n#define IB_7220_LT_STATE_SLEEPDELAY      0x04\n#define IB_7220_LT_STATE_SLEEPQUIET      0x05\n#define IB_7220_LT_STATE_CFGDEBOUNCE     0x08\n#define IB_7220_LT_STATE_CFGRCVFCFG      0x09\n#define IB_7220_LT_STATE_CFGWAITRMT      0x0a\n#define IB_7220_LT_STATE_CFGIDLE 0x0b\n#define IB_7220_LT_STATE_RECOVERRETRAIN  0x0c\n#define IB_7220_LT_STATE_RECOVERWAITRMT  0x0e\n#define IB_7220_LT_STATE_RECOVERIDLE     0x0f\n\n \n#define IB_7220_L_STATE_DOWN             0x0\n#define IB_7220_L_STATE_INIT             0x1\n#define IB_7220_L_STATE_ARM              0x2\n#define IB_7220_L_STATE_ACTIVE           0x3\n#define IB_7220_L_STATE_ACT_DEFER        0x4\n\nstatic const u8 qib_7220_physportstate[0x20] = {\n\t[IB_7220_LT_STATE_DISABLED] = IB_PHYSPORTSTATE_DISABLED,\n\t[IB_7220_LT_STATE_LINKUP] = IB_PHYSPORTSTATE_LINKUP,\n\t[IB_7220_LT_STATE_POLLACTIVE] = IB_PHYSPORTSTATE_POLL,\n\t[IB_7220_LT_STATE_POLLQUIET] = IB_PHYSPORTSTATE_POLL,\n\t[IB_7220_LT_STATE_SLEEPDELAY] = IB_PHYSPORTSTATE_SLEEP,\n\t[IB_7220_LT_STATE_SLEEPQUIET] = IB_PHYSPORTSTATE_SLEEP,\n\t[IB_7220_LT_STATE_CFGDEBOUNCE] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_7220_LT_STATE_CFGRCVFCFG] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_7220_LT_STATE_CFGWAITRMT] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_7220_LT_STATE_CFGIDLE] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_7220_LT_STATE_RECOVERRETRAIN] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[IB_7220_LT_STATE_RECOVERWAITRMT] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[IB_7220_LT_STATE_RECOVERIDLE] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[0x10] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x11] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x12] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x13] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x14] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x15] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x16] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x17] = IB_PHYSPORTSTATE_CFG_TRAIN\n};\n\nint qib_special_trigger;\nmodule_param_named(special_trigger, qib_special_trigger, int, S_IRUGO);\nMODULE_PARM_DESC(special_trigger, \"Enable SpecialTrigger arm/launch\");\n\n#define IBCBUSFRSPCPARITYERR HWE_MASK(IBCBusFromSPCParityErr)\n#define IBCBUSTOSPCPARITYERR HWE_MASK(IBCBusToSPCParityErr)\n\n#define SYM_MASK_BIT(regname, fldname, bit) ((u64) \\\n\t(1ULL << (SYM_LSB(regname, fldname) + (bit))))\n\n#define TXEMEMPARITYERR_PIOBUF \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 0)\n#define TXEMEMPARITYERR_PIOPBC \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 1)\n#define TXEMEMPARITYERR_PIOLAUNCHFIFO \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 2)\n\n#define RXEMEMPARITYERR_RCVBUF \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 0)\n#define RXEMEMPARITYERR_LOOKUPQ \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 1)\n#define RXEMEMPARITYERR_EXPTID \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 2)\n#define RXEMEMPARITYERR_EAGERTID \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 3)\n#define RXEMEMPARITYERR_FLAGBUF \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 4)\n#define RXEMEMPARITYERR_DATAINFO \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 5)\n#define RXEMEMPARITYERR_HDRINFO \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 6)\n\n \nstatic const struct qib_hwerror_msgs qib_7220_hwerror_msgs[] = {\n\t \n\tQLOGIC_IB_HWE_MSG(IBCBUSFRSPCPARITYERR, \"QIB2IB Parity\"),\n\tQLOGIC_IB_HWE_MSG(IBCBUSTOSPCPARITYERR, \"IB2QIB Parity\"),\n\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOBUF,\n\t\t\t  \"TXE PIOBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOPBC,\n\t\t\t  \"TXE PIOPBC Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOLAUNCHFIFO,\n\t\t\t  \"TXE PIOLAUNCHFIFO Memory Parity\"),\n\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_RCVBUF,\n\t\t\t  \"RXE RCVBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_LOOKUPQ,\n\t\t\t  \"RXE LOOKUPQ Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_EAGERTID,\n\t\t\t  \"RXE EAGERTID Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_EXPTID,\n\t\t\t  \"RXE EXPTID Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_FLAGBUF,\n\t\t\t  \"RXE FLAGBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_DATAINFO,\n\t\t\t  \"RXE DATAINFO Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_HDRINFO,\n\t\t\t  \"RXE HDRINFO Memory Parity\"),\n\n\t \n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEPOISONEDTLP,\n\t\t\t  \"PCIe Poisoned TLP\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIECPLTIMEOUT,\n\t\t\t  \"PCIe completion timeout\"),\n\t \n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE1PLLFAILED,\n\t\t\t  \"PCIePLL1\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE0PLLFAILED,\n\t\t\t  \"PCIePLL0\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYXTLH,\n\t\t\t  \"PCIe XTLH core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYXADM,\n\t\t\t  \"PCIe ADM TX core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYRADM,\n\t\t\t  \"PCIe ADM RX core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_SERDESPLLFAILED,\n\t\t\t  \"SerDes PLL\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIECPLDATAQUEUEERR,\n\t\t\t  \"PCIe cpl header queue\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIECPLHDRQUEUEERR,\n\t\t\t  \"PCIe cpl data queue\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_SDMAMEMREADERR,\n\t\t\t  \"Send DMA memory read\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_CLK_UC_PLLNOTLOCKED,\n\t\t\t  \"uC PLL clock not locked\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIESERDESQ0PCLKNOTDETECT,\n\t\t\t  \"PCIe serdes Q0 no clock\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIESERDESQ1PCLKNOTDETECT,\n\t\t\t  \"PCIe serdes Q1 no clock\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIESERDESQ2PCLKNOTDETECT,\n\t\t\t  \"PCIe serdes Q2 no clock\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIESERDESQ3PCLKNOTDETECT,\n\t\t\t  \"PCIe serdes Q3 no clock\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_DDSRXEQMEMORYPARITYERR,\n\t\t\t  \"DDS RXEQ memory parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR,\n\t\t\t  \"IB uC memory parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE_UC_OCT0MEMORYPARITYERR,\n\t\t\t  \"PCIe uC oct0 memory parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE_UC_OCT1MEMORYPARITYERR,\n\t\t\t  \"PCIe uC oct1 memory parity\"),\n};\n\n#define RXE_PARITY (RXEMEMPARITYERR_EAGERTID|RXEMEMPARITYERR_EXPTID)\n\n#define QLOGIC_IB_E_PKTERRS (\\\n\t\tERR_MASK(SendPktLenErr) |\t\t\t\t\\\n\t\tERR_MASK(SendDroppedDataPktErr) |\t\t\t\\\n\t\tERR_MASK(RcvVCRCErr) |\t\t\t\t\t\\\n\t\tERR_MASK(RcvICRCErr) |\t\t\t\t\t\\\n\t\tERR_MASK(RcvShortPktLenErr) |\t\t\t\t\\\n\t\tERR_MASK(RcvEBPErr))\n\n \n#define QLOGIC_IB_E_SDMAERRS ( \\\n\t\tERR_MASK(SDmaGenMismatchErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaOutOfBoundErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaTailOutOfBoundErr) | ERR_MASK(SDmaBaseErr) | \\\n\t\tERR_MASK(SDma1stDescErr) | ERR_MASK(SDmaRpyTagErr) |\t\\\n\t\tERR_MASK(SDmaDwEnErr) | ERR_MASK(SDmaMissingDwErr) |\t\\\n\t\tERR_MASK(SDmaUnexpDataErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaDescAddrMisalignErr) |\t\t\t\\\n\t\tERR_MASK(SDmaDisabledErr) |\t\t\t\t\\\n\t\tERR_MASK(SendBufMisuseErr))\n\n \n#define E_SUM_PKTERRS \\\n\t(ERR_MASK(RcvHdrLenErr) | ERR_MASK(RcvBadTidErr) |\t\t\\\n\t ERR_MASK(RcvBadVersionErr) | ERR_MASK(RcvHdrErr) |\t\t\\\n\t ERR_MASK(RcvLongPktLenErr) | ERR_MASK(RcvShortPktLenErr) |\t\\\n\t ERR_MASK(RcvMaxPktLenErr) | ERR_MASK(RcvMinPktLenErr) |\t\\\n\t ERR_MASK(RcvFormatErr) | ERR_MASK(RcvUnsupportedVLErr) |\t\\\n\t ERR_MASK(RcvUnexpectedCharErr) | ERR_MASK(RcvEBPErr))\n\n \n#define E_SUM_ERRS \\\n\t(ERR_MASK(SendPioArmLaunchErr) | ERR_MASK(SendUnexpectedPktNumErr) | \\\n\t ERR_MASK(SendDroppedDataPktErr) | ERR_MASK(SendDroppedSmpPktErr) | \\\n\t ERR_MASK(SendMaxPktLenErr) | ERR_MASK(SendUnsupportedVLErr) |\t\\\n\t ERR_MASK(SendMinPktLenErr) | ERR_MASK(SendPktLenErr) |\t\t\\\n\t ERR_MASK(InvalidAddrErr))\n\n \n#define E_SPKT_ERRS_IGNORE \\\n\t(ERR_MASK(SendDroppedDataPktErr) | ERR_MASK(SendDroppedSmpPktErr) | \\\n\t ERR_MASK(SendMaxPktLenErr) | ERR_MASK(SendMinPktLenErr) |\t\\\n\t ERR_MASK(SendPktLenErr))\n\n \n#define E_SUM_LINK_PKTERRS \\\n\t(ERR_MASK(SendDroppedDataPktErr) | ERR_MASK(SendDroppedSmpPktErr) | \\\n\t ERR_MASK(SendMinPktLenErr) | ERR_MASK(SendPktLenErr) |\t\t\\\n\t ERR_MASK(RcvShortPktLenErr) | ERR_MASK(RcvMinPktLenErr) |\t\\\n\t ERR_MASK(RcvUnexpectedCharErr))\n\nstatic void autoneg_7220_work(struct work_struct *);\nstatic u32 __iomem *qib_7220_getsendbuf(struct qib_pportdata *, u64, u32 *);\n\n \nstatic void qib_disarm_7220_senderrbufs(struct qib_pportdata *ppd)\n{\n\tunsigned long sbuf[3];\n\tstruct qib_devdata *dd = ppd->dd;\n\n\t \n\t \n\tsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\n\tsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\n\tsbuf[2] = qib_read_kreg64(dd, kr_sendbuffererror + 2);\n\n\tif (sbuf[0] || sbuf[1] || sbuf[2])\n\t\tqib_disarm_piobufs_set(dd, sbuf,\n\t\t\t\t       dd->piobcnt2k + dd->piobcnt4k);\n}\n\nstatic void qib_7220_txe_recover(struct qib_devdata *dd)\n{\n\tqib_devinfo(dd->pcidev, \"Recovering from TXE PIO parity error\\n\");\n\tqib_disarm_7220_senderrbufs(dd->pport);\n}\n\n \nstatic void qib_7220_sdma_sendctrl(struct qib_pportdata *ppd, unsigned op)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 set_sendctrl = 0;\n\tu64 clr_sendctrl = 0;\n\n\tif (op & QIB_SDMA_SENDCTRL_OP_ENABLE)\n\t\tset_sendctrl |= SYM_MASK(SendCtrl, SDmaEnable);\n\telse\n\t\tclr_sendctrl |= SYM_MASK(SendCtrl, SDmaEnable);\n\n\tif (op & QIB_SDMA_SENDCTRL_OP_INTENABLE)\n\t\tset_sendctrl |= SYM_MASK(SendCtrl, SDmaIntEnable);\n\telse\n\t\tclr_sendctrl |= SYM_MASK(SendCtrl, SDmaIntEnable);\n\n\tif (op & QIB_SDMA_SENDCTRL_OP_HALT)\n\t\tset_sendctrl |= SYM_MASK(SendCtrl, SDmaHalt);\n\telse\n\t\tclr_sendctrl |= SYM_MASK(SendCtrl, SDmaHalt);\n\n\tspin_lock(&dd->sendctrl_lock);\n\n\tdd->sendctrl |= set_sendctrl;\n\tdd->sendctrl &= ~clr_sendctrl;\n\n\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tspin_unlock(&dd->sendctrl_lock);\n}\n\nstatic void qib_decode_7220_sdma_errs(struct qib_pportdata *ppd,\n\t\t\t\t      u64 err, char *buf, size_t blen)\n{\n\tstatic const struct {\n\t\tu64 err;\n\t\tconst char *msg;\n\t} errs[] = {\n\t\t{ ERR_MASK(SDmaGenMismatchErr),\n\t\t  \"SDmaGenMismatch\" },\n\t\t{ ERR_MASK(SDmaOutOfBoundErr),\n\t\t  \"SDmaOutOfBound\" },\n\t\t{ ERR_MASK(SDmaTailOutOfBoundErr),\n\t\t  \"SDmaTailOutOfBound\" },\n\t\t{ ERR_MASK(SDmaBaseErr),\n\t\t  \"SDmaBase\" },\n\t\t{ ERR_MASK(SDma1stDescErr),\n\t\t  \"SDma1stDesc\" },\n\t\t{ ERR_MASK(SDmaRpyTagErr),\n\t\t  \"SDmaRpyTag\" },\n\t\t{ ERR_MASK(SDmaDwEnErr),\n\t\t  \"SDmaDwEn\" },\n\t\t{ ERR_MASK(SDmaMissingDwErr),\n\t\t  \"SDmaMissingDw\" },\n\t\t{ ERR_MASK(SDmaUnexpDataErr),\n\t\t  \"SDmaUnexpData\" },\n\t\t{ ERR_MASK(SDmaDescAddrMisalignErr),\n\t\t  \"SDmaDescAddrMisalign\" },\n\t\t{ ERR_MASK(SendBufMisuseErr),\n\t\t  \"SendBufMisuse\" },\n\t\t{ ERR_MASK(SDmaDisabledErr),\n\t\t  \"SDmaDisabled\" },\n\t};\n\tint i;\n\tsize_t bidx = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(errs); i++) {\n\t\tif (err & errs[i].err)\n\t\t\tbidx += scnprintf(buf + bidx, blen - bidx,\n\t\t\t\t\t \"%s \", errs[i].msg);\n\t}\n}\n\n \nstatic void qib_7220_sdma_hw_clean_up(struct qib_pportdata *ppd)\n{\n\t \n\tsendctrl_7220_mod(ppd, QIB_SENDCTRL_DISARM_ALL | QIB_SENDCTRL_FLUSH |\n\t\t\t  QIB_SENDCTRL_AVAIL_BLIP);\n\tppd->dd->upd_pio_shadow  = 1;  \n}\n\nstatic void qib_sdma_7220_setlengen(struct qib_pportdata *ppd)\n{\n\t \n\tqib_write_kreg(ppd->dd, kr_senddmalengen, ppd->sdma_descq_cnt);\n\tqib_write_kreg(ppd->dd, kr_senddmalengen,\n\t\t       ppd->sdma_descq_cnt |\n\t\t       (1ULL << QIB_7220_SendDmaLenGen_Generation_MSB));\n}\n\nstatic void qib_7220_sdma_hw_start_up(struct qib_pportdata *ppd)\n{\n\tqib_sdma_7220_setlengen(ppd);\n\tqib_sdma_update_7220_tail(ppd, 0);  \n\tppd->sdma_head_dma[0] = 0;\n}\n\n#define DISABLES_SDMA (\t\t\t\t\t\t\t\\\n\t\tERR_MASK(SDmaDisabledErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaBaseErr) |\t\t\t\t\t\\\n\t\tERR_MASK(SDmaTailOutOfBoundErr) |\t\t\t\\\n\t\tERR_MASK(SDmaOutOfBoundErr) |\t\t\t\t\\\n\t\tERR_MASK(SDma1stDescErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaRpyTagErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaGenMismatchErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaDescAddrMisalignErr) |\t\t\t\\\n\t\tERR_MASK(SDmaMissingDwErr) |\t\t\t\t\\\n\t\tERR_MASK(SDmaDwEnErr))\n\nstatic void sdma_7220_errors(struct qib_pportdata *ppd, u64 errs)\n{\n\tunsigned long flags;\n\tstruct qib_devdata *dd = ppd->dd;\n\tchar *msg;\n\n\terrs &= QLOGIC_IB_E_SDMAERRS;\n\n\tmsg = dd->cspec->sdmamsgbuf;\n\tqib_decode_7220_sdma_errs(ppd, errs, msg,\n\t\tsizeof(dd->cspec->sdmamsgbuf));\n\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\n\tif (errs & ERR_MASK(SendBufMisuseErr)) {\n\t\tunsigned long sbuf[3];\n\n\t\tsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\n\t\tsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\n\t\tsbuf[2] = qib_read_kreg64(dd, kr_sendbuffererror + 2);\n\n\t\tqib_dev_err(ppd->dd,\n\t\t\t    \"IB%u:%u SendBufMisuse: %04lx %016lx %016lx\\n\",\n\t\t\t    ppd->dd->unit, ppd->port, sbuf[2], sbuf[1],\n\t\t\t    sbuf[0]);\n\t}\n\n\tif (errs & ERR_MASK(SDmaUnexpDataErr))\n\t\tqib_dev_err(dd, \"IB%u:%u SDmaUnexpData\\n\", ppd->dd->unit,\n\t\t\t    ppd->port);\n\n\tswitch (ppd->sdma_state.current_state) {\n\tcase qib_sdma_state_s00_hw_down:\n\t\t \n\t\tbreak;\n\n\tcase qib_sdma_state_s10_hw_start_up_wait:\n\t\t \n\t\tbreak;\n\n\tcase qib_sdma_state_s20_idle:\n\t\t \n\t\tbreak;\n\n\tcase qib_sdma_state_s30_sw_clean_up_wait:\n\t\t \n\t\tbreak;\n\n\tcase qib_sdma_state_s40_hw_clean_up_wait:\n\t\tif (errs & ERR_MASK(SDmaDisabledErr))\n\t\t\t__qib_sdma_process_event(ppd,\n\t\t\t\tqib_sdma_event_e50_hw_cleaned);\n\t\tbreak;\n\n\tcase qib_sdma_state_s50_hw_halt_wait:\n\t\t \n\t\tbreak;\n\n\tcase qib_sdma_state_s99_running:\n\t\tif (errs & DISABLES_SDMA)\n\t\t\t__qib_sdma_process_event(ppd,\n\t\t\t\tqib_sdma_event_e7220_err_halted);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n}\n\n \nstatic int qib_decode_7220_err(struct qib_devdata *dd, char *buf, size_t blen,\n\t\t\t       u64 err)\n{\n\tint iserr = 1;\n\n\t*buf = '\\0';\n\tif (err & QLOGIC_IB_E_PKTERRS) {\n\t\tif (!(err & ~QLOGIC_IB_E_PKTERRS))\n\t\t\tiserr = 0;\n\t\tif ((err & ERR_MASK(RcvICRCErr)) &&\n\t\t    !(err & (ERR_MASK(RcvVCRCErr) | ERR_MASK(RcvEBPErr))))\n\t\t\tstrlcat(buf, \"CRC \", blen);\n\t\tif (!iserr)\n\t\t\tgoto done;\n\t}\n\tif (err & ERR_MASK(RcvHdrLenErr))\n\t\tstrlcat(buf, \"rhdrlen \", blen);\n\tif (err & ERR_MASK(RcvBadTidErr))\n\t\tstrlcat(buf, \"rbadtid \", blen);\n\tif (err & ERR_MASK(RcvBadVersionErr))\n\t\tstrlcat(buf, \"rbadversion \", blen);\n\tif (err & ERR_MASK(RcvHdrErr))\n\t\tstrlcat(buf, \"rhdr \", blen);\n\tif (err & ERR_MASK(SendSpecialTriggerErr))\n\t\tstrlcat(buf, \"sendspecialtrigger \", blen);\n\tif (err & ERR_MASK(RcvLongPktLenErr))\n\t\tstrlcat(buf, \"rlongpktlen \", blen);\n\tif (err & ERR_MASK(RcvMaxPktLenErr))\n\t\tstrlcat(buf, \"rmaxpktlen \", blen);\n\tif (err & ERR_MASK(RcvMinPktLenErr))\n\t\tstrlcat(buf, \"rminpktlen \", blen);\n\tif (err & ERR_MASK(SendMinPktLenErr))\n\t\tstrlcat(buf, \"sminpktlen \", blen);\n\tif (err & ERR_MASK(RcvFormatErr))\n\t\tstrlcat(buf, \"rformaterr \", blen);\n\tif (err & ERR_MASK(RcvUnsupportedVLErr))\n\t\tstrlcat(buf, \"runsupvl \", blen);\n\tif (err & ERR_MASK(RcvUnexpectedCharErr))\n\t\tstrlcat(buf, \"runexpchar \", blen);\n\tif (err & ERR_MASK(RcvIBFlowErr))\n\t\tstrlcat(buf, \"ribflow \", blen);\n\tif (err & ERR_MASK(SendUnderRunErr))\n\t\tstrlcat(buf, \"sunderrun \", blen);\n\tif (err & ERR_MASK(SendPioArmLaunchErr))\n\t\tstrlcat(buf, \"spioarmlaunch \", blen);\n\tif (err & ERR_MASK(SendUnexpectedPktNumErr))\n\t\tstrlcat(buf, \"sunexperrpktnum \", blen);\n\tif (err & ERR_MASK(SendDroppedSmpPktErr))\n\t\tstrlcat(buf, \"sdroppedsmppkt \", blen);\n\tif (err & ERR_MASK(SendMaxPktLenErr))\n\t\tstrlcat(buf, \"smaxpktlen \", blen);\n\tif (err & ERR_MASK(SendUnsupportedVLErr))\n\t\tstrlcat(buf, \"sunsupVL \", blen);\n\tif (err & ERR_MASK(InvalidAddrErr))\n\t\tstrlcat(buf, \"invalidaddr \", blen);\n\tif (err & ERR_MASK(RcvEgrFullErr))\n\t\tstrlcat(buf, \"rcvegrfull \", blen);\n\tif (err & ERR_MASK(RcvHdrFullErr))\n\t\tstrlcat(buf, \"rcvhdrfull \", blen);\n\tif (err & ERR_MASK(IBStatusChanged))\n\t\tstrlcat(buf, \"ibcstatuschg \", blen);\n\tif (err & ERR_MASK(RcvIBLostLinkErr))\n\t\tstrlcat(buf, \"riblostlink \", blen);\n\tif (err & ERR_MASK(HardwareErr))\n\t\tstrlcat(buf, \"hardware \", blen);\n\tif (err & ERR_MASK(ResetNegated))\n\t\tstrlcat(buf, \"reset \", blen);\n\tif (err & QLOGIC_IB_E_SDMAERRS)\n\t\tqib_decode_7220_sdma_errs(dd->pport, err, buf, blen);\n\tif (err & ERR_MASK(InvalidEEPCmd))\n\t\tstrlcat(buf, \"invalideepromcmd \", blen);\ndone:\n\treturn iserr;\n}\n\nstatic void reenable_7220_chase(struct timer_list *t)\n{\n\tstruct qib_chippport_specific *cpspec = from_timer(cpspec, t,\n\t\t\t\t\t\t\t chase_timer);\n\tstruct qib_pportdata *ppd = &cpspec->pportdata;\n\n\tppd->cpspec->chase_timer.expires = 0;\n\tqib_set_ib_7220_lstate(ppd, QLOGIC_IB_IBCC_LINKCMD_DOWN,\n\t\tQLOGIC_IB_IBCC_LINKINITCMD_POLL);\n}\n\nstatic void handle_7220_chase(struct qib_pportdata *ppd, u64 ibcst)\n{\n\tu8 ibclt;\n\tunsigned long tnow;\n\n\tibclt = (u8)SYM_FIELD(ibcst, IBCStatus, LinkTrainingState);\n\n\t \n\tswitch (ibclt) {\n\tcase IB_7220_LT_STATE_CFGRCVFCFG:\n\tcase IB_7220_LT_STATE_CFGWAITRMT:\n\tcase IB_7220_LT_STATE_TXREVLANES:\n\tcase IB_7220_LT_STATE_CFGENH:\n\t\ttnow = jiffies;\n\t\tif (ppd->cpspec->chase_end &&\n\t\t    time_after(tnow, ppd->cpspec->chase_end)) {\n\t\t\tppd->cpspec->chase_end = 0;\n\t\t\tqib_set_ib_7220_lstate(ppd,\n\t\t\t\tQLOGIC_IB_IBCC_LINKCMD_DOWN,\n\t\t\t\tQLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\n\t\t\tppd->cpspec->chase_timer.expires = jiffies +\n\t\t\t\tQIB_CHASE_DIS_TIME;\n\t\t\tadd_timer(&ppd->cpspec->chase_timer);\n\t\t} else if (!ppd->cpspec->chase_end)\n\t\t\tppd->cpspec->chase_end = tnow + QIB_CHASE_TIME;\n\t\tbreak;\n\n\tdefault:\n\t\tppd->cpspec->chase_end = 0;\n\t\tbreak;\n\t}\n}\n\nstatic void handle_7220_errors(struct qib_devdata *dd, u64 errs)\n{\n\tchar *msg;\n\tu64 ignore_this_time = 0;\n\tu64 iserr = 0;\n\tstruct qib_pportdata *ppd = dd->pport;\n\tu64 mask;\n\n\t \n\terrs &= dd->cspec->errormask;\n\tmsg = dd->cspec->emsgbuf;\n\n\t \n\tif (errs & ERR_MASK(HardwareErr))\n\t\tqib_7220_handle_hwerrors(dd, msg, sizeof(dd->cspec->emsgbuf));\n\n\tif (errs & QLOGIC_IB_E_SDMAERRS)\n\t\tsdma_7220_errors(ppd, errs);\n\n\tif (errs & ~IB_E_BITSEXTANT)\n\t\tqib_dev_err(dd,\n\t\t\t\"error interrupt with unknown errors %llx set\\n\",\n\t\t\t(unsigned long long) (errs & ~IB_E_BITSEXTANT));\n\n\tif (errs & E_SUM_ERRS) {\n\t\tqib_disarm_7220_senderrbufs(ppd);\n\t\tif ((errs & E_SUM_LINK_PKTERRS) &&\n\t\t    !(ppd->lflags & QIBL_LINKACTIVE)) {\n\t\t\t \n\t\t\tignore_this_time = errs & E_SUM_LINK_PKTERRS;\n\t\t}\n\t} else if ((errs & E_SUM_LINK_PKTERRS) &&\n\t\t   !(ppd->lflags & QIBL_LINKACTIVE)) {\n\t\t \n\t\tignore_this_time = errs & E_SUM_LINK_PKTERRS;\n\t}\n\n\tqib_write_kreg(dd, kr_errclear, errs);\n\n\terrs &= ~ignore_this_time;\n\tif (!errs)\n\t\tgoto done;\n\n\t \n\tmask = ERR_MASK(IBStatusChanged) |\n\t\tERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr) |\n\t\tERR_MASK(HardwareErr) | ERR_MASK(SDmaDisabledErr);\n\n\tqib_decode_7220_err(dd, msg, sizeof(dd->cspec->emsgbuf), errs & ~mask);\n\n\tif (errs & E_SUM_PKTERRS)\n\t\tqib_stats.sps_rcverrs++;\n\tif (errs & E_SUM_ERRS)\n\t\tqib_stats.sps_txerrs++;\n\tiserr = errs & ~(E_SUM_PKTERRS | QLOGIC_IB_E_PKTERRS |\n\t\t\t ERR_MASK(SDmaDisabledErr));\n\n\tif (errs & ERR_MASK(IBStatusChanged)) {\n\t\tu64 ibcs;\n\n\t\tibcs = qib_read_kreg64(dd, kr_ibcstatus);\n\t\tif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\n\t\t\thandle_7220_chase(ppd, ibcs);\n\n\t\t \n\t\tppd->link_width_active =\n\t\t\t((ibcs >> IBA7220_LINKWIDTH_SHIFT) & 1) ?\n\t\t\t    IB_WIDTH_4X : IB_WIDTH_1X;\n\t\tppd->link_speed_active =\n\t\t\t((ibcs >> IBA7220_LINKSPEED_SHIFT) & 1) ?\n\t\t\t    QIB_IB_DDR : QIB_IB_SDR;\n\n\t\t \n\t\tif (qib_7220_phys_portstate(ibcs) !=\n\t\t\t\t\t    IB_PHYSPORTSTATE_LINK_ERR_RECOVER)\n\t\t\tqib_handle_e_ibstatuschanged(ppd, ibcs);\n\t}\n\n\tif (errs & ERR_MASK(ResetNegated)) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Got reset, requires re-init (unload and reload driver)\\n\");\n\t\tdd->flags &= ~QIB_INITTED;   \n\t\t \n\t\t*dd->devstatusp |= QIB_STATUS_HWERROR;\n\t\t*dd->pport->statusp &= ~QIB_STATUS_IB_CONF;\n\t}\n\n\tif (*msg && iserr)\n\t\tqib_dev_porterr(dd, ppd->port, \"%s error\\n\", msg);\n\n\tif (ppd->state_wanted & ppd->lflags)\n\t\twake_up_interruptible(&ppd->state_wait);\n\n\t \n\tif (errs & (ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr))) {\n\t\tqib_handle_urcv(dd, ~0U);\n\t\tif (errs & ERR_MASK(RcvEgrFullErr))\n\t\t\tqib_stats.sps_buffull++;\n\t\telse\n\t\t\tqib_stats.sps_hdrfull++;\n\t}\ndone:\n\treturn;\n}\n\n \nstatic void qib_7220_set_intr_state(struct qib_devdata *dd, u32 enable)\n{\n\tif (enable) {\n\t\tif (dd->flags & QIB_BADINTR)\n\t\t\treturn;\n\t\tqib_write_kreg(dd, kr_intmask, ~0ULL);\n\t\t \n\t\tqib_write_kreg(dd, kr_intclear, 0ULL);\n\t} else\n\t\tqib_write_kreg(dd, kr_intmask, 0ULL);\n}\n\n \nstatic void qib_7220_clear_freeze(struct qib_devdata *dd)\n{\n\t \n\tqib_write_kreg(dd, kr_errmask, 0ULL);\n\n\t \n\tqib_7220_set_intr_state(dd, 0);\n\n\tqib_cancel_sends(dd->pport);\n\n\t \n\tqib_write_kreg(dd, kr_control, dd->control);\n\tqib_read_kreg32(dd, kr_scratch);\n\n\t \n\tqib_force_pio_avail_update(dd);\n\n\t \n\tqib_write_kreg(dd, kr_hwerrclear, 0ULL);\n\tqib_write_kreg(dd, kr_errclear, E_SPKT_ERRS_IGNORE);\n\tqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\n\tqib_7220_set_intr_state(dd, 1);\n}\n\n \nstatic void qib_7220_handle_hwerrors(struct qib_devdata *dd, char *msg,\n\t\t\t\t     size_t msgl)\n{\n\tu64 hwerrs;\n\tu32 bits, ctrl;\n\tint isfatal = 0;\n\tchar *bitsmsg;\n\n\thwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\n\tif (!hwerrs)\n\t\tgoto bail;\n\tif (hwerrs == ~0ULL) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Read of hardware error status failed (all bits set); ignoring\\n\");\n\t\tgoto bail;\n\t}\n\tqib_stats.sps_hwerrs++;\n\n\t \n\tqib_write_kreg(dd, kr_hwerrclear,\n\t\t       hwerrs & ~HWE_MASK(PowerOnBISTFailed));\n\n\thwerrs &= dd->cspec->hwerrmask;\n\n\tif (hwerrs & ~(TXEMEMPARITYERR_PIOBUF | TXEMEMPARITYERR_PIOPBC |\n\t\t       RXE_PARITY))\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Hardware error: hwerr=0x%llx (cleared)\\n\",\n\t\t\t(unsigned long long) hwerrs);\n\n\tif (hwerrs & ~IB_HWE_BITSEXTANT)\n\t\tqib_dev_err(dd,\n\t\t\t\"hwerror interrupt with unknown errors %llx set\\n\",\n\t\t\t(unsigned long long) (hwerrs & ~IB_HWE_BITSEXTANT));\n\n\tif (hwerrs & QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR)\n\t\tqib_sd7220_clr_ibpar(dd);\n\n\tctrl = qib_read_kreg32(dd, kr_control);\n\tif ((ctrl & QLOGIC_IB_C_FREEZEMODE) && !dd->diag_client) {\n\t\t \n\t\tif (hwerrs & (TXEMEMPARITYERR_PIOBUF |\n\t\t\t      TXEMEMPARITYERR_PIOPBC)) {\n\t\t\tqib_7220_txe_recover(dd);\n\t\t\thwerrs &= ~(TXEMEMPARITYERR_PIOBUF |\n\t\t\t\t    TXEMEMPARITYERR_PIOPBC);\n\t\t}\n\t\tif (hwerrs)\n\t\t\tisfatal = 1;\n\t\telse\n\t\t\tqib_7220_clear_freeze(dd);\n\t}\n\n\t*msg = '\\0';\n\n\tif (hwerrs & HWE_MASK(PowerOnBISTFailed)) {\n\t\tisfatal = 1;\n\t\tstrlcat(msg,\n\t\t\t\"[Memory BIST test failed, InfiniPath hardware unusable]\",\n\t\t\tmsgl);\n\t\t \n\t\tdd->cspec->hwerrmask &= ~HWE_MASK(PowerOnBISTFailed);\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tqib_format_hwerrors(hwerrs, qib_7220_hwerror_msgs,\n\t\t\t    ARRAY_SIZE(qib_7220_hwerror_msgs), msg, msgl);\n\n\tbitsmsg = dd->cspec->bitsmsgbuf;\n\tif (hwerrs & (QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\n\t\t      QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT)) {\n\t\tbits = (u32) ((hwerrs >>\n\t\t\t       QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) &\n\t\t\t      QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK);\n\t\tsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\n\t\t\t \"[PCIe Mem Parity Errs %x] \", bits);\n\t\tstrlcat(msg, bitsmsg, msgl);\n\t}\n\n#define _QIB_PLL_FAIL (QLOGIC_IB_HWE_COREPLL_FBSLIP |   \\\n\t\t\t QLOGIC_IB_HWE_COREPLL_RFSLIP)\n\n\tif (hwerrs & _QIB_PLL_FAIL) {\n\t\tisfatal = 1;\n\t\tsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\n\t\t\t \"[PLL failed (%llx), InfiniPath hardware unusable]\",\n\t\t\t (unsigned long long) hwerrs & _QIB_PLL_FAIL);\n\t\tstrlcat(msg, bitsmsg, msgl);\n\t\t \n\t\tdd->cspec->hwerrmask &= ~(hwerrs & _QIB_PLL_FAIL);\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tif (hwerrs & QLOGIC_IB_HWE_SERDESPLLFAILED) {\n\t\t \n\t\tdd->cspec->hwerrmask &= ~QLOGIC_IB_HWE_SERDESPLLFAILED;\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tqib_dev_err(dd, \"%s hardware error\\n\", msg);\n\n\tif (isfatal && !dd->diag_client) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Fatal Hardware Error, no longer usable, SN %.16s\\n\",\n\t\t\tdd->serial);\n\t\t \n\t\tif (dd->freezemsg)\n\t\t\tsnprintf(dd->freezemsg, dd->freezelen,\n\t\t\t\t \"{%s}\", msg);\n\t\tqib_disable_after_error(dd);\n\t}\nbail:;\n}\n\n \nstatic void qib_7220_init_hwerrors(struct qib_devdata *dd)\n{\n\tu64 val;\n\tu64 extsval;\n\n\textsval = qib_read_kreg64(dd, kr_extstatus);\n\n\tif (!(extsval & (QLOGIC_IB_EXTS_MEMBIST_ENDTEST |\n\t\t\t QLOGIC_IB_EXTS_MEMBIST_DISABLED)))\n\t\tqib_dev_err(dd, \"MemBIST did not complete!\\n\");\n\tif (extsval & QLOGIC_IB_EXTS_MEMBIST_DISABLED)\n\t\tqib_devinfo(dd->pcidev, \"MemBIST is disabled.\\n\");\n\n\tval = ~0ULL;     \n\n\tval &= ~QLOGIC_IB_HWE_IB_UC_MEMORYPARITYERR;\n\tdd->cspec->hwerrmask = val;\n\n\tqib_write_kreg(dd, kr_hwerrclear, ~HWE_MASK(PowerOnBISTFailed));\n\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\n\t \n\tqib_write_kreg(dd, kr_errclear, ~0ULL);\n\t \n\tqib_write_kreg(dd, kr_errmask, ~0ULL);\n\tdd->cspec->errormask = qib_read_kreg64(dd, kr_errmask);\n\t \n\tqib_write_kreg(dd, kr_intclear, ~0ULL);\n}\n\n \nstatic void qib_set_7220_armlaunch(struct qib_devdata *dd, u32 enable)\n{\n\tif (enable) {\n\t\tqib_write_kreg(dd, kr_errclear, ERR_MASK(SendPioArmLaunchErr));\n\t\tdd->cspec->errormask |= ERR_MASK(SendPioArmLaunchErr);\n\t} else\n\t\tdd->cspec->errormask &= ~ERR_MASK(SendPioArmLaunchErr);\n\tqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\n}\n\n \nstatic void qib_set_ib_7220_lstate(struct qib_pportdata *ppd, u16 linkcmd,\n\t\t\t\t   u16 linitcmd)\n{\n\tu64 mod_wd;\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\n\tif (linitcmd == QLOGIC_IB_IBCC_LINKINITCMD_DISABLE) {\n\t\t \n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags |= QIBL_IB_LINK_DISABLED;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t} else if (linitcmd || linkcmd == QLOGIC_IB_IBCC_LINKCMD_DOWN) {\n\t\t \n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags &= ~QIBL_IB_LINK_DISABLED;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t}\n\n\tmod_wd = (linkcmd << IBA7220_IBCC_LINKCMD_SHIFT) |\n\t\t(linitcmd << QLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\n\n\tqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl | mod_wd);\n\t \n\tqib_write_kreg(dd, kr_scratch, 0);\n}\n\n \n\n \nstatic int qib_7220_bringup_serdes(struct qib_pportdata *ppd)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 val, prev_val, guid, ibc;\n\tint ret = 0;\n\n\t \n\tdd->control &= ~QLOGIC_IB_C_LINKENABLE;\n\tqib_write_kreg(dd, kr_control, 0ULL);\n\n\tif (qib_compat_ddr_negotiate) {\n\t\tppd->cpspec->ibdeltainprog = 1;\n\t\tppd->cpspec->ibsymsnap = read_7220_creg32(dd, cr_ibsymbolerr);\n\t\tppd->cpspec->iblnkerrsnap =\n\t\t\tread_7220_creg32(dd, cr_iblinkerrrecov);\n\t}\n\n\t \n\tibc = 0x5ULL << SYM_LSB(IBCCtrl, FlowCtrlWaterMark);\n\t \n\tibc |= 0x3ULL << SYM_LSB(IBCCtrl, FlowCtrlPeriod);\n\t \n\tibc |= 0xfULL << SYM_LSB(IBCCtrl, PhyerrThreshold);\n\t \n\tibc |= 4ULL << SYM_LSB(IBCCtrl, CreditScale);\n\t \n\tibc |= 0xfULL << SYM_LSB(IBCCtrl, OverrunThreshold);\n\t \n\tibc |= ((u64)(ppd->ibmaxlen >> 2) + 1) << SYM_LSB(IBCCtrl, MaxPktLen);\n\tppd->cpspec->ibcctrl = ibc;  \n\n\t \n\tval = ppd->cpspec->ibcctrl | (QLOGIC_IB_IBCC_LINKINITCMD_DISABLE <<\n\t\tQLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\n\tqib_write_kreg(dd, kr_ibcctrl, val);\n\n\tif (!ppd->cpspec->ibcddrctrl) {\n\t\t \n\t\tppd->cpspec->ibcddrctrl = qib_read_kreg64(dd, kr_ibcddrctrl);\n\n\t\tif (ppd->link_speed_enabled == (QIB_IB_SDR | QIB_IB_DDR))\n\t\t\tppd->cpspec->ibcddrctrl |=\n\t\t\t\tIBA7220_IBC_SPEED_AUTONEG_MASK |\n\t\t\t\tIBA7220_IBC_IBTA_1_2_MASK;\n\t\telse\n\t\t\tppd->cpspec->ibcddrctrl |=\n\t\t\t\tppd->link_speed_enabled == QIB_IB_DDR ?\n\t\t\t\tIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\n\t\tif ((ppd->link_width_enabled & (IB_WIDTH_1X | IB_WIDTH_4X)) ==\n\t\t    (IB_WIDTH_1X | IB_WIDTH_4X))\n\t\t\tppd->cpspec->ibcddrctrl |= IBA7220_IBC_WIDTH_AUTONEG;\n\t\telse\n\t\t\tppd->cpspec->ibcddrctrl |=\n\t\t\t\tppd->link_width_enabled == IB_WIDTH_4X ?\n\t\t\t\tIBA7220_IBC_WIDTH_4X_ONLY :\n\t\t\t\tIBA7220_IBC_WIDTH_1X_ONLY;\n\n\t\t \n\t\tppd->cpspec->ibcddrctrl |=\n\t\t\tIBA7220_IBC_RXPOL_MASK << IBA7220_IBC_RXPOL_SHIFT;\n\t\tppd->cpspec->ibcddrctrl |=\n\t\t\tIBA7220_IBC_HRTBT_MASK << IBA7220_IBC_HRTBT_SHIFT;\n\n\t\t \n\t\tppd->cpspec->ibcddrctrl |= IBA7220_IBC_LANE_REV_SUPPORTED;\n\t} else\n\t\t \n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tqib_write_kreg(dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tqib_write_kreg(dd, kr_ncmodectrl, 0Ull);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tret = qib_sd7220_init(dd);\n\n\tval = qib_read_kreg64(dd, kr_xgxs_cfg);\n\tprev_val = val;\n\tval |= QLOGIC_IB_XGXS_FC_SAFE;\n\tif (val != prev_val) {\n\t\tqib_write_kreg(dd, kr_xgxs_cfg, val);\n\t\tqib_read_kreg32(dd, kr_scratch);\n\t}\n\tif (val & QLOGIC_IB_XGXS_RESET)\n\t\tval &= ~QLOGIC_IB_XGXS_RESET;\n\tif (val != prev_val)\n\t\tqib_write_kreg(dd, kr_xgxs_cfg, val);\n\n\t \n\tif (!ppd->guid)\n\t\tppd->guid = dd->base_guid;\n\tguid = be64_to_cpu(ppd->guid);\n\n\tqib_write_kreg(dd, kr_hrtbt_guid, guid);\n\tif (!ret) {\n\t\tdd->control |= QLOGIC_IB_C_LINKENABLE;\n\t\tqib_write_kreg(dd, kr_control, dd->control);\n\t} else\n\t\t \n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\treturn ret;\n}\n\n \nstatic void qib_7220_quiet_serdes(struct qib_pportdata *ppd)\n{\n\tu64 val;\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\n\t \n\tdd->control &= ~QLOGIC_IB_C_LINKENABLE;\n\tqib_write_kreg(dd, kr_control,\n\t\t       dd->control | QLOGIC_IB_C_FREEZEMODE);\n\n\tppd->cpspec->chase_end = 0;\n\tif (ppd->cpspec->chase_timer.function)  \n\t\tdel_timer_sync(&ppd->cpspec->chase_timer);\n\n\tif (ppd->cpspec->ibsymdelta || ppd->cpspec->iblnkerrdelta ||\n\t    ppd->cpspec->ibdeltainprog) {\n\t\tu64 diagc;\n\n\t\t \n\t\tdiagc = qib_read_kreg64(dd, kr_hwdiagctrl);\n\t\tqib_write_kreg(dd, kr_hwdiagctrl,\n\t\t\t       diagc | SYM_MASK(HwDiagCtrl, CounterWrEnable));\n\n\t\tif (ppd->cpspec->ibsymdelta || ppd->cpspec->ibdeltainprog) {\n\t\t\tval = read_7220_creg32(dd, cr_ibsymbolerr);\n\t\t\tif (ppd->cpspec->ibdeltainprog)\n\t\t\t\tval -= val - ppd->cpspec->ibsymsnap;\n\t\t\tval -= ppd->cpspec->ibsymdelta;\n\t\t\twrite_7220_creg(dd, cr_ibsymbolerr, val);\n\t\t}\n\t\tif (ppd->cpspec->iblnkerrdelta || ppd->cpspec->ibdeltainprog) {\n\t\t\tval = read_7220_creg32(dd, cr_iblinkerrrecov);\n\t\t\tif (ppd->cpspec->ibdeltainprog)\n\t\t\t\tval -= val - ppd->cpspec->iblnkerrsnap;\n\t\t\tval -= ppd->cpspec->iblnkerrdelta;\n\t\t\twrite_7220_creg(dd, cr_iblinkerrrecov, val);\n\t\t}\n\n\t\t \n\t\tqib_write_kreg(dd, kr_hwdiagctrl, diagc);\n\t}\n\tqib_set_ib_7220_lstate(ppd, 0, QLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\n\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tppd->lflags &= ~QIBL_IB_AUTONEG_INPROG;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\twake_up(&ppd->cpspec->autoneg_wait);\n\tcancel_delayed_work_sync(&ppd->cpspec->autoneg_work);\n\n\tshutdown_7220_relock_poll(ppd->dd);\n\tval = qib_read_kreg64(ppd->dd, kr_xgxs_cfg);\n\tval |= QLOGIC_IB_XGXS_RESET;\n\tqib_write_kreg(ppd->dd, kr_xgxs_cfg, val);\n}\n\n \nstatic void qib_setup_7220_setextled(struct qib_pportdata *ppd, u32 on)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 extctl, ledblink = 0, val, lst, ltst;\n\tunsigned long flags;\n\n\t \n\tif (dd->diag_client)\n\t\treturn;\n\n\tif (ppd->led_override) {\n\t\tltst = (ppd->led_override & QIB_LED_PHYS) ?\n\t\t\tIB_PHYSPORTSTATE_LINKUP : IB_PHYSPORTSTATE_DISABLED,\n\t\tlst = (ppd->led_override & QIB_LED_LOG) ?\n\t\t\tIB_PORT_ACTIVE : IB_PORT_DOWN;\n\t} else if (on) {\n\t\tval = qib_read_kreg64(dd, kr_ibcstatus);\n\t\tltst = qib_7220_phys_portstate(val);\n\t\tlst = qib_7220_iblink_state(val);\n\t} else {\n\t\tltst = 0;\n\t\tlst = 0;\n\t}\n\n\tspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\n\textctl = dd->cspec->extctrl & ~(SYM_MASK(EXTCtrl, LEDPriPortGreenOn) |\n\t\t\t\t SYM_MASK(EXTCtrl, LEDPriPortYellowOn));\n\tif (ltst == IB_PHYSPORTSTATE_LINKUP) {\n\t\textctl |= SYM_MASK(EXTCtrl, LEDPriPortGreenOn);\n\t\t \n\t\tledblink = ((66600 * 1000UL / 4) << IBA7220_LEDBLINK_ON_SHIFT)\n\t\t\t| ((187500 * 1000UL / 4) << IBA7220_LEDBLINK_OFF_SHIFT);\n\t}\n\tif (lst == IB_PORT_ACTIVE)\n\t\textctl |= SYM_MASK(EXTCtrl, LEDPriPortYellowOn);\n\tdd->cspec->extctrl = extctl;\n\tqib_write_kreg(dd, kr_extctrl, extctl);\n\tspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\n\n\tif (ledblink)  \n\t\tqib_write_kreg(dd, kr_rcvpktledcnt, ledblink);\n}\n\n \nstatic void qib_setup_7220_cleanup(struct qib_devdata *dd)\n{\n\tqib_free_irq(dd);\n\tkfree(dd->cspec->cntrs);\n\tkfree(dd->cspec->portcntrs);\n}\n\n \nstatic void sdma_7220_intr(struct qib_pportdata *ppd, u64 istat)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\n\tswitch (ppd->sdma_state.current_state) {\n\tcase qib_sdma_state_s00_hw_down:\n\t\tbreak;\n\n\tcase qib_sdma_state_s10_hw_start_up_wait:\n\t\t__qib_sdma_process_event(ppd, qib_sdma_event_e20_hw_started);\n\t\tbreak;\n\n\tcase qib_sdma_state_s20_idle:\n\t\tbreak;\n\n\tcase qib_sdma_state_s30_sw_clean_up_wait:\n\t\tbreak;\n\n\tcase qib_sdma_state_s40_hw_clean_up_wait:\n\t\tbreak;\n\n\tcase qib_sdma_state_s50_hw_halt_wait:\n\t\t__qib_sdma_process_event(ppd, qib_sdma_event_e60_hw_halted);\n\t\tbreak;\n\n\tcase qib_sdma_state_s99_running:\n\t\t \n\t\t__qib_sdma_intr(ppd);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n}\n\nstatic void qib_wantpiobuf_7220_intr(struct qib_devdata *dd, u32 needint)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\tif (needint) {\n\t\tif (!(dd->sendctrl & SYM_MASK(SendCtrl, SendBufAvailUpd)))\n\t\t\tgoto done;\n\t\t \n\t\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl &\n\t\t\t~SYM_MASK(SendCtrl, SendBufAvailUpd));\n\t\tqib_write_kreg(dd, kr_scratch, 0ULL);\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, SendIntBufAvail);\n\t} else\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, SendIntBufAvail);\n\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\n\tqib_write_kreg(dd, kr_scratch, 0ULL);\ndone:\n\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n}\n\n \nstatic noinline void unlikely_7220_intr(struct qib_devdata *dd, u64 istat)\n{\n\tif (unlikely(istat & ~QLOGIC_IB_I_BITSEXTANT))\n\t\tqib_dev_err(dd,\n\t\t\t    \"interrupt with unknown interrupts %Lx set\\n\",\n\t\t\t    istat & ~QLOGIC_IB_I_BITSEXTANT);\n\n\tif (istat & QLOGIC_IB_I_GPIO) {\n\t\tu32 gpiostatus;\n\n\t\t \n\t\tgpiostatus = qib_read_kreg32(dd, kr_gpio_status);\n\t\t \n\t\tqib_write_kreg(dd, kr_gpio_clear, gpiostatus);\n\n\t\tif (gpiostatus) {\n\t\t\tconst u32 mask = qib_read_kreg32(dd, kr_gpio_mask);\n\t\t\tu32 gpio_irq = mask & gpiostatus;\n\n\t\t\t \n\t\t\t \n\t\t\tdd->cspec->gpio_mask &= ~gpio_irq;\n\t\t\tqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\n\t\t}\n\t}\n\n\tif (istat & QLOGIC_IB_I_ERROR) {\n\t\tu64 estat;\n\n\t\tqib_stats.sps_errints++;\n\t\testat = qib_read_kreg64(dd, kr_errstatus);\n\t\tif (!estat)\n\t\t\tqib_devinfo(dd->pcidev,\n\t\t\t\t\"error interrupt (%Lx), but no error bits set!\\n\",\n\t\t\t\tistat);\n\t\telse\n\t\t\thandle_7220_errors(dd, estat);\n\t}\n}\n\nstatic irqreturn_t qib_7220intr(int irq, void *data)\n{\n\tstruct qib_devdata *dd = data;\n\tirqreturn_t ret;\n\tu64 istat;\n\tu64 ctxtrbits;\n\tu64 rmask;\n\tunsigned i;\n\n\tif ((dd->flags & (QIB_PRESENT | QIB_BADINTR)) != QIB_PRESENT) {\n\t\t \n\t\tret = IRQ_HANDLED;\n\t\tgoto bail;\n\t}\n\n\tistat = qib_read_kreg64(dd, kr_intstatus);\n\n\tif (unlikely(!istat)) {\n\t\tret = IRQ_NONE;  \n\t\tgoto bail;\n\t}\n\tif (unlikely(istat == -1)) {\n\t\tqib_bad_intrstatus(dd);\n\t\t \n\t\tret = IRQ_NONE;\n\t\tgoto bail;\n\t}\n\n\tthis_cpu_inc(*dd->int_counter);\n\tif (unlikely(istat & (~QLOGIC_IB_I_BITSEXTANT |\n\t\t\t      QLOGIC_IB_I_GPIO | QLOGIC_IB_I_ERROR)))\n\t\tunlikely_7220_intr(dd, istat);\n\n\t \n\tqib_write_kreg(dd, kr_intclear, istat);\n\n\t \n\tctxtrbits = istat &\n\t\t((QLOGIC_IB_I_RCVAVAIL_MASK << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t (QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT));\n\tif (ctxtrbits) {\n\t\trmask = (1ULL << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t\t(1ULL << QLOGIC_IB_I_RCVURG_SHIFT);\n\t\tfor (i = 0; i < dd->first_user_ctxt; i++) {\n\t\t\tif (ctxtrbits & rmask) {\n\t\t\t\tctxtrbits &= ~rmask;\n\t\t\t\tqib_kreceive(dd->rcd[i], NULL, NULL);\n\t\t\t}\n\t\t\trmask <<= 1;\n\t\t}\n\t\tif (ctxtrbits) {\n\t\t\tctxtrbits =\n\t\t\t\t(ctxtrbits >> QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t\t\t(ctxtrbits >> QLOGIC_IB_I_RCVURG_SHIFT);\n\t\t\tqib_handle_urcv(dd, ctxtrbits);\n\t\t}\n\t}\n\n\t \n\tif (istat & QLOGIC_IB_I_SDMAINT)\n\t\tsdma_7220_intr(dd->pport, istat);\n\n\tif ((istat & QLOGIC_IB_I_SPIOBUFAVAIL) && (dd->flags & QIB_INITTED))\n\t\tqib_ib_piobufavail(dd);\n\n\tret = IRQ_HANDLED;\nbail:\n\treturn ret;\n}\n\n \nstatic void qib_setup_7220_interrupt(struct qib_devdata *dd)\n{\n\tint ret;\n\n\tret = pci_request_irq(dd->pcidev, 0, qib_7220intr, NULL, dd,\n\t\t\t      QIB_DRV_NAME);\n\tif (ret)\n\t\tqib_dev_err(dd, \"Couldn't setup %s interrupt (irq=%d): %d\\n\",\n\t\t\t    dd->pcidev->msi_enabled ?  \"MSI\" : \"INTx\",\n\t\t\t    pci_irq_vector(dd->pcidev, 0), ret);\n}\n\n \nstatic void qib_7220_boardname(struct qib_devdata *dd)\n{\n\tu32 boardid;\n\n\tboardid = SYM_FIELD(dd->revision, Revision,\n\t\t\t    BoardID);\n\n\tswitch (boardid) {\n\tcase 1:\n\t\tdd->boardname = \"InfiniPath_QLE7240\";\n\t\tbreak;\n\tcase 2:\n\t\tdd->boardname = \"InfiniPath_QLE7280\";\n\t\tbreak;\n\tdefault:\n\t\tqib_dev_err(dd, \"Unknown 7220 board with ID %u\\n\", boardid);\n\t\tdd->boardname = \"Unknown_InfiniPath_7220\";\n\t\tbreak;\n\t}\n\n\tif (dd->majrev != 5 || !dd->minrev || dd->minrev > 2)\n\t\tqib_dev_err(dd,\n\t\t\t    \"Unsupported InfiniPath hardware revision %u.%u!\\n\",\n\t\t\t    dd->majrev, dd->minrev);\n\n\tsnprintf(dd->boardversion, sizeof(dd->boardversion),\n\t\t \"ChipABI %u.%u, %s, InfiniPath%u %u.%u, SW Compat %u\\n\",\n\t\t QIB_CHIP_VERS_MAJ, QIB_CHIP_VERS_MIN, dd->boardname,\n\t\t (unsigned int)SYM_FIELD(dd->revision, Revision_R, Arch),\n\t\t dd->majrev, dd->minrev,\n\t\t (unsigned int)SYM_FIELD(dd->revision, Revision_R, SW));\n}\n\n \nstatic int qib_setup_7220_reset(struct qib_devdata *dd)\n{\n\tu64 val;\n\tint i;\n\tint ret;\n\tu16 cmdval;\n\tu8 int_line, clinesz;\n\tunsigned long flags;\n\n\tqib_pcie_getcmd(dd, &cmdval, &int_line, &clinesz);\n\n\t \n\tqib_dev_err(dd, \"Resetting InfiniPath unit %u\\n\", dd->unit);\n\n\t \n\tqib_7220_set_intr_state(dd, 0);\n\n\tdd->pport->cpspec->ibdeltainprog = 0;\n\tdd->pport->cpspec->ibsymdelta = 0;\n\tdd->pport->cpspec->iblnkerrdelta = 0;\n\n\t \n\tdd->flags &= ~(QIB_INITTED | QIB_PRESENT);\n\t \n\tdd->z_int_counter = qib_int_counter(dd);\n\tval = dd->control | QLOGIC_IB_C_RESET;\n\twriteq(val, &dd->kregbase[kr_control]);\n\tmb();  \n\n\tfor (i = 1; i <= 5; i++) {\n\t\t \n\t\tmsleep(1000 + (1 + i) * 2000);\n\n\t\tqib_pcie_reenable(dd, cmdval, int_line, clinesz);\n\n\t\t \n\t\tval = readq(&dd->kregbase[kr_revision]);\n\t\tif (val == dd->revision) {\n\t\t\tdd->flags |= QIB_PRESENT;  \n\t\t\tret = qib_reinit_intr(dd);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\tret = 0;  \n\nbail:\n\tif (ret) {\n\t\tif (qib_pcie_params(dd, dd->lbus_width, NULL))\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Reset failed to setup PCIe or interrupts; continuing anyway\\n\");\n\n\t\t \n\t\tqib_write_kreg(dd, kr_control, 0ULL);\n\n\t\t \n\t\tqib_7220_init_hwerrors(dd);\n\n\t\t \n\t\tif (dd->pport->cpspec->ibcddrctrl & IBA7220_IBC_IBTA_1_2_MASK)\n\t\t\tdd->cspec->presets_needed = 1;\n\t\tspin_lock_irqsave(&dd->pport->lflags_lock, flags);\n\t\tdd->pport->lflags |= QIBL_IB_FORCE_NOTIFY;\n\t\tdd->pport->lflags &= ~QIBL_IB_AUTONEG_FAILED;\n\t\tspin_unlock_irqrestore(&dd->pport->lflags_lock, flags);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void qib_7220_put_tid(struct qib_devdata *dd, u64 __iomem *tidptr,\n\t\t\t     u32 type, unsigned long pa)\n{\n\tif (pa != dd->tidinvalid) {\n\t\tu64 chippa = pa >> IBA7220_TID_PA_SHIFT;\n\n\t\t \n\t\tif (pa != (chippa << IBA7220_TID_PA_SHIFT)) {\n\t\t\tqib_dev_err(dd, \"Physaddr %lx not 2KB aligned!\\n\",\n\t\t\t\t    pa);\n\t\t\treturn;\n\t\t}\n\t\tif (chippa >= (1UL << IBA7220_TID_SZ_SHIFT)) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Physical page address 0x%lx larger than supported\\n\",\n\t\t\t\tpa);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type == RCVHQ_RCV_TYPE_EAGER)\n\t\t\tchippa |= dd->tidtemplate;\n\t\telse  \n\t\t\tchippa |= IBA7220_TID_SZ_4K;\n\t\tpa = chippa;\n\t}\n\twriteq(pa, tidptr);\n}\n\n \nstatic void qib_7220_clear_tids(struct qib_devdata *dd,\n\t\t\t\tstruct qib_ctxtdata *rcd)\n{\n\tu64 __iomem *tidbase;\n\tunsigned long tidinv;\n\tu32 ctxt;\n\tint i;\n\n\tif (!dd->kregbase || !rcd)\n\t\treturn;\n\n\tctxt = rcd->ctxt;\n\n\ttidinv = dd->tidinvalid;\n\ttidbase = (u64 __iomem *)\n\t\t((char __iomem *)(dd->kregbase) +\n\t\t dd->rcvtidbase +\n\t\t ctxt * dd->rcvtidcnt * sizeof(*tidbase));\n\n\tfor (i = 0; i < dd->rcvtidcnt; i++)\n\t\tqib_7220_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,\n\t\t\t\t tidinv);\n\n\ttidbase = (u64 __iomem *)\n\t\t((char __iomem *)(dd->kregbase) +\n\t\t dd->rcvegrbase +\n\t\t rcd->rcvegr_tid_base * sizeof(*tidbase));\n\n\tfor (i = 0; i < rcd->rcvegrcnt; i++)\n\t\tqib_7220_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,\n\t\t\t\t tidinv);\n}\n\n \nstatic void qib_7220_tidtemplate(struct qib_devdata *dd)\n{\n\tif (dd->rcvegrbufsize == 2048)\n\t\tdd->tidtemplate = IBA7220_TID_SZ_2K;\n\telse if (dd->rcvegrbufsize == 4096)\n\t\tdd->tidtemplate = IBA7220_TID_SZ_4K;\n\tdd->tidinvalid = 0;\n}\n\n \nstatic int qib_7220_get_base_info(struct qib_ctxtdata *rcd,\n\t\t\t\t  struct qib_base_info *kinfo)\n{\n\tkinfo->spi_runtime_flags |= QIB_RUNTIME_PCIE |\n\t\tQIB_RUNTIME_NODMA_RTAIL | QIB_RUNTIME_SDMA;\n\n\tif (rcd->dd->flags & QIB_USE_SPCL_TRIG)\n\t\tkinfo->spi_runtime_flags |= QIB_RUNTIME_SPECIAL_TRIGGER;\n\n\treturn 0;\n}\n\nstatic struct qib_message_header *\nqib_7220_get_msgheader(struct qib_devdata *dd, __le32 *rhf_addr)\n{\n\tu32 offset = qib_hdrget_offset(rhf_addr);\n\n\treturn (struct qib_message_header *)\n\t\t(rhf_addr - dd->rhf_offset + offset);\n}\n\nstatic void qib_7220_config_ctxts(struct qib_devdata *dd)\n{\n\tunsigned long flags;\n\tu32 nchipctxts;\n\n\tnchipctxts = qib_read_kreg32(dd, kr_portcnt);\n\tdd->cspec->numctxts = nchipctxts;\n\tif (qib_n_krcv_queues > 1) {\n\t\tdd->qpn_mask = 0x3e;\n\t\tdd->first_user_ctxt = qib_n_krcv_queues * dd->num_pports;\n\t\tif (dd->first_user_ctxt > nchipctxts)\n\t\t\tdd->first_user_ctxt = nchipctxts;\n\t} else\n\t\tdd->first_user_ctxt = dd->num_pports;\n\tdd->n_krcv_queues = dd->first_user_ctxt;\n\n\tif (!qib_cfgctxts) {\n\t\tint nctxts = dd->first_user_ctxt + num_online_cpus();\n\n\t\tif (nctxts <= 5)\n\t\t\tdd->ctxtcnt = 5;\n\t\telse if (nctxts <= 9)\n\t\t\tdd->ctxtcnt = 9;\n\t\telse if (nctxts <= nchipctxts)\n\t\t\tdd->ctxtcnt = nchipctxts;\n\t} else if (qib_cfgctxts <= nchipctxts)\n\t\tdd->ctxtcnt = qib_cfgctxts;\n\tif (!dd->ctxtcnt)  \n\t\tdd->ctxtcnt = nchipctxts;\n\n\t \n\tspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\n\tif (dd->ctxtcnt > 9)\n\t\tdd->rcvctrl |= 2ULL << IBA7220_R_CTXTCFG_SHIFT;\n\telse if (dd->ctxtcnt > 5)\n\t\tdd->rcvctrl |= 1ULL << IBA7220_R_CTXTCFG_SHIFT;\n\t \n\tif (dd->qpn_mask)\n\t\tdd->rcvctrl |= 1ULL << QIB_7220_RcvCtrl_RcvQPMapEnable_LSB;\n\tqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\n\tspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\n\n\t \n\tdd->cspec->rcvegrcnt = qib_read_kreg32(dd, kr_rcvegrcnt);\n\tdd->rcvhdrcnt = max(dd->cspec->rcvegrcnt, IBA7220_KRCVEGRCNT);\n}\n\nstatic int qib_7220_get_ib_cfg(struct qib_pportdata *ppd, int which)\n{\n\tint lsb, ret = 0;\n\tu64 maskr;  \n\n\tswitch (which) {\n\tcase QIB_IB_CFG_LWID_ENB:  \n\t\tret = ppd->link_width_enabled;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_LWID:  \n\t\tret = ppd->link_width_active;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_SPD_ENB:  \n\t\tret = ppd->link_speed_enabled;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_SPD:  \n\t\tret = ppd->link_speed_active;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_RXPOL_ENB:  \n\t\tlsb = IBA7220_IBC_RXPOL_SHIFT;\n\t\tmaskr = IBA7220_IBC_RXPOL_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LREV_ENB:  \n\t\tlsb = IBA7220_IBC_LREV_SHIFT;\n\t\tmaskr = IBA7220_IBC_LREV_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LINKLATENCY:\n\t\tret = qib_read_kreg64(ppd->dd, kr_ibcddrstatus)\n\t\t\t& IBA7220_DDRSTAT_LINKLAT_MASK;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_OP_VLS:\n\t\tret = ppd->vls_operational;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_VL_HIGH_CAP:\n\t\tret = 0;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_VL_LOW_CAP:\n\t\tret = 0;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_OVERRUN_THRESH:  \n\t\tret = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\n\t\t\t\tOverrunThreshold);\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_PHYERR_THRESH:  \n\t\tret = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\n\t\t\t\tPhyerrThreshold);\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_LINKDEFAULT:  \n\t\t \n\t\tret = (ppd->cpspec->ibcctrl &\n\t\t       SYM_MASK(IBCCtrl, LinkDownDefaultState)) ?\n\t\t\tIB_LINKINITCMD_SLEEP : IB_LINKINITCMD_POLL;\n\t\tgoto done;\n\n\tcase QIB_IB_CFG_HRTBT:  \n\t\tlsb = IBA7220_IBC_HRTBT_SHIFT;\n\t\tmaskr = IBA7220_IBC_HRTBT_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_PMA_TICKS:\n\t\t \n\t\tret = (ppd->link_speed_active == QIB_IB_DDR);\n\t\tgoto done;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tret = (int)((ppd->cpspec->ibcddrctrl >> lsb) & maskr);\ndone:\n\treturn ret;\n}\n\nstatic int qib_7220_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 maskr;  \n\tint lsb, ret = 0, setforce = 0;\n\tu16 lcmd, licmd;\n\tunsigned long flags;\n\tu32 tmp = 0;\n\n\tswitch (which) {\n\tcase QIB_IB_CFG_LIDLMC:\n\t\t \n\t\tlsb = IBA7220_IBC_DLIDLMC_SHIFT;\n\t\tmaskr = IBA7220_IBC_DLIDLMC_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LWID_ENB:  \n\t\t \n\t\tppd->link_width_enabled = val;\n\t\tif (!(ppd->lflags & QIBL_LINKDOWN))\n\t\t\tgoto bail;\n\t\t \n\t\tval--;  \n\t\tmaskr = IBA7220_IBC_WIDTH_MASK;\n\t\tlsb = IBA7220_IBC_WIDTH_SHIFT;\n\t\tsetforce = 1;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_SPD_ENB:  \n\t\t \n\t\tppd->link_speed_enabled = val;\n\t\tif ((ppd->cpspec->ibcddrctrl & IBA7220_IBC_IBTA_1_2_MASK) &&\n\t\t    !(val & (val - 1)))\n\t\t\tdd->cspec->presets_needed = 1;\n\t\tif (!(ppd->lflags & QIBL_LINKDOWN))\n\t\t\tgoto bail;\n\t\t \n\t\tif (val == (QIB_IB_SDR | QIB_IB_DDR)) {\n\t\t\tval = IBA7220_IBC_SPEED_AUTONEG_MASK |\n\t\t\t\tIBA7220_IBC_IBTA_1_2_MASK;\n\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\tppd->lflags &= ~QIBL_IB_AUTONEG_FAILED;\n\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\t} else\n\t\t\tval = val == QIB_IB_DDR ?\n\t\t\t\tIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\n\t\tmaskr = IBA7220_IBC_SPEED_AUTONEG_MASK |\n\t\t\tIBA7220_IBC_IBTA_1_2_MASK;\n\t\t \n\t\tlsb = SYM_LSB(IBCDDRCtrl, IB_ENHANCED_MODE);\n\t\tsetforce = 1;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_RXPOL_ENB:  \n\t\tlsb = IBA7220_IBC_RXPOL_SHIFT;\n\t\tmaskr = IBA7220_IBC_RXPOL_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LREV_ENB:  \n\t\tlsb = IBA7220_IBC_LREV_SHIFT;\n\t\tmaskr = IBA7220_IBC_LREV_MASK;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_OVERRUN_THRESH:  \n\t\tmaskr = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\n\t\t\t\t  OverrunThreshold);\n\t\tif (maskr != val) {\n\t\t\tppd->cpspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, OverrunThreshold);\n\t\t\tppd->cpspec->ibcctrl |= (u64) val <<\n\t\t\t\tSYM_LSB(IBCCtrl, OverrunThreshold);\n\t\t\tqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_PHYERR_THRESH:  \n\t\tmaskr = SYM_FIELD(ppd->cpspec->ibcctrl, IBCCtrl,\n\t\t\t\t  PhyerrThreshold);\n\t\tif (maskr != val) {\n\t\t\tppd->cpspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, PhyerrThreshold);\n\t\t\tppd->cpspec->ibcctrl |= (u64) val <<\n\t\t\t\tSYM_LSB(IBCCtrl, PhyerrThreshold);\n\t\t\tqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_PKEYS:  \n\t\tmaskr = (u64) ppd->pkeys[0] | ((u64) ppd->pkeys[1] << 16) |\n\t\t\t((u64) ppd->pkeys[2] << 32) |\n\t\t\t((u64) ppd->pkeys[3] << 48);\n\t\tqib_write_kreg(dd, kr_partitionkey, maskr);\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_LINKDEFAULT:  \n\t\t \n\t\tif (val == IB_LINKINITCMD_POLL)\n\t\t\tppd->cpspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, LinkDownDefaultState);\n\t\telse  \n\t\t\tppd->cpspec->ibcctrl |=\n\t\t\t\tSYM_MASK(IBCCtrl, LinkDownDefaultState);\n\t\tqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_MTU:  \n\t\t \n\t\tval = (ppd->ibmaxlen >> 2) + 1;\n\t\tppd->cpspec->ibcctrl &= ~SYM_MASK(IBCCtrl, MaxPktLen);\n\t\tppd->cpspec->ibcctrl |= (u64)val << SYM_LSB(IBCCtrl, MaxPktLen);\n\t\tqib_write_kreg(dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_LSTATE:  \n\t\tswitch (val & 0xffff0000) {\n\t\tcase IB_LINKCMD_DOWN:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_DOWN;\n\t\t\tif (!ppd->cpspec->ibdeltainprog &&\n\t\t\t    qib_compat_ddr_negotiate) {\n\t\t\t\tppd->cpspec->ibdeltainprog = 1;\n\t\t\t\tppd->cpspec->ibsymsnap =\n\t\t\t\t\tread_7220_creg32(dd, cr_ibsymbolerr);\n\t\t\t\tppd->cpspec->iblnkerrsnap =\n\t\t\t\t\tread_7220_creg32(dd, cr_iblinkerrrecov);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_LINKCMD_ARMED:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_ARMED;\n\t\t\tbreak;\n\n\t\tcase IB_LINKCMD_ACTIVE:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_ACTIVE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tqib_dev_err(dd, \"bad linkcmd req 0x%x\\n\", val >> 16);\n\t\t\tgoto bail;\n\t\t}\n\t\tswitch (val & 0xffff) {\n\t\tcase IB_LINKINITCMD_NOP:\n\t\t\tlicmd = 0;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_POLL:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_POLL;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_SLEEP:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_SLEEP;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_DISABLE:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_DISABLE;\n\t\t\tppd->cpspec->chase_end = 0;\n\t\t\t \n\t\t\tif (ppd->cpspec->chase_timer.expires) {\n\t\t\t\tdel_timer_sync(&ppd->cpspec->chase_timer);\n\t\t\t\tppd->cpspec->chase_timer.expires = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tqib_dev_err(dd, \"bad linkinitcmd req 0x%x\\n\",\n\t\t\t\t    val & 0xffff);\n\t\t\tgoto bail;\n\t\t}\n\t\tqib_set_ib_7220_lstate(ppd, lcmd, licmd);\n\n\t\tmaskr = IBA7220_IBC_WIDTH_MASK;\n\t\tlsb = IBA7220_IBC_WIDTH_SHIFT;\n\t\ttmp = (ppd->cpspec->ibcddrctrl >> lsb) & maskr;\n\t\t \n\t\tif (ppd->link_width_enabled-1 != tmp) {\n\t\t\tppd->cpspec->ibcddrctrl &= ~(maskr << lsb);\n\t\t\tppd->cpspec->ibcddrctrl |=\n\t\t\t\t(((u64)(ppd->link_width_enabled-1) & maskr) <<\n\t\t\t\t lsb);\n\t\t\tqib_write_kreg(dd, kr_ibcddrctrl,\n\t\t\t\t       ppd->cpspec->ibcddrctrl);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\tppd->lflags |= QIBL_IB_FORCE_NOTIFY;\n\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\t}\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_HRTBT:  \n\t\tif (val > IBA7220_IBC_HRTBT_MASK) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tlsb = IBA7220_IBC_HRTBT_SHIFT;\n\t\tmaskr = IBA7220_IBC_HRTBT_MASK;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tppd->cpspec->ibcddrctrl &= ~(maskr << lsb);\n\tppd->cpspec->ibcddrctrl |= (((u64) val & maskr) << lsb);\n\tqib_write_kreg(dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\tif (setforce) {\n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags |= QIBL_IB_FORCE_NOTIFY;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t}\nbail:\n\treturn ret;\n}\n\nstatic int qib_7220_set_loopback(struct qib_pportdata *ppd, const char *what)\n{\n\tint ret = 0;\n\tu64 val, ddr;\n\n\tif (!strncmp(what, \"ibc\", 3)) {\n\t\tppd->cpspec->ibcctrl |= SYM_MASK(IBCCtrl, Loopback);\n\t\tval = 0;  \n\t\tqib_devinfo(ppd->dd->pcidev, \"Enabling IB%u:%u IBC loopback\\n\",\n\t\t\t ppd->dd->unit, ppd->port);\n\t} else if (!strncmp(what, \"off\", 3)) {\n\t\tppd->cpspec->ibcctrl &= ~SYM_MASK(IBCCtrl, Loopback);\n\t\t \n\t\tval = IBA7220_IBC_HRTBT_MASK << IBA7220_IBC_HRTBT_SHIFT;\n\t\tqib_devinfo(ppd->dd->pcidev,\n\t\t\t\"Disabling IB%u:%u IBC loopback (normal)\\n\",\n\t\t\tppd->dd->unit, ppd->port);\n\t} else\n\t\tret = -EINVAL;\n\tif (!ret) {\n\t\tqib_write_kreg(ppd->dd, kr_ibcctrl, ppd->cpspec->ibcctrl);\n\t\tddr = ppd->cpspec->ibcddrctrl & ~(IBA7220_IBC_HRTBT_MASK\n\t\t\t\t\t     << IBA7220_IBC_HRTBT_SHIFT);\n\t\tppd->cpspec->ibcddrctrl = ddr | val;\n\t\tqib_write_kreg(ppd->dd, kr_ibcddrctrl,\n\t\t\t       ppd->cpspec->ibcddrctrl);\n\t\tqib_write_kreg(ppd->dd, kr_scratch, 0);\n\t}\n\treturn ret;\n}\n\nstatic void qib_update_7220_usrhead(struct qib_ctxtdata *rcd, u64 hd,\n\t\t\t\t    u32 updegr, u32 egrhd, u32 npkts)\n{\n\tif (updegr)\n\t\tqib_write_ureg(rcd->dd, ur_rcvegrindexhead, egrhd, rcd->ctxt);\n\tqib_write_ureg(rcd->dd, ur_rcvhdrhead, hd, rcd->ctxt);\n}\n\nstatic u32 qib_7220_hdrqempty(struct qib_ctxtdata *rcd)\n{\n\tu32 head, tail;\n\n\thead = qib_read_ureg32(rcd->dd, ur_rcvhdrhead, rcd->ctxt);\n\tif (rcd->rcvhdrtail_kvaddr)\n\t\ttail = qib_get_rcvhdrtail(rcd);\n\telse\n\t\ttail = qib_read_ureg32(rcd->dd, ur_rcvhdrtail, rcd->ctxt);\n\treturn head == tail;\n}\n\n \nstatic void rcvctrl_7220_mod(struct qib_pportdata *ppd, unsigned int op,\n\t\t\t     int ctxt)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 mask, val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\n\tif (op & QIB_RCVCTRL_TAILUPD_ENB)\n\t\tdd->rcvctrl |= (1ULL << IBA7220_R_TAILUPD_SHIFT);\n\tif (op & QIB_RCVCTRL_TAILUPD_DIS)\n\t\tdd->rcvctrl &= ~(1ULL << IBA7220_R_TAILUPD_SHIFT);\n\tif (op & QIB_RCVCTRL_PKEY_ENB)\n\t\tdd->rcvctrl &= ~(1ULL << IBA7220_R_PKEY_DIS_SHIFT);\n\tif (op & QIB_RCVCTRL_PKEY_DIS)\n\t\tdd->rcvctrl |= (1ULL << IBA7220_R_PKEY_DIS_SHIFT);\n\tif (ctxt < 0)\n\t\tmask = (1ULL << dd->ctxtcnt) - 1;\n\telse\n\t\tmask = (1ULL << ctxt);\n\tif (op & QIB_RCVCTRL_CTXT_ENB) {\n\t\t \n\t\tdd->rcvctrl |= (mask << SYM_LSB(RcvCtrl, PortEnable));\n\t\tif (!(dd->flags & QIB_NODMA_RTAIL))\n\t\t\tdd->rcvctrl |= 1ULL << IBA7220_R_TAILUPD_SHIFT;\n\t\t \n\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\n\t\t\tdd->rcd[ctxt]->rcvhdrqtailaddr_phys);\n\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\n\t\t\tdd->rcd[ctxt]->rcvhdrq_phys);\n\t\tdd->rcd[ctxt]->seq_cnt = 1;\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_DIS)\n\t\tdd->rcvctrl &= ~(mask << SYM_LSB(RcvCtrl, PortEnable));\n\tif (op & QIB_RCVCTRL_INTRAVAIL_ENB)\n\t\tdd->rcvctrl |= (mask << IBA7220_R_INTRAVAIL_SHIFT);\n\tif (op & QIB_RCVCTRL_INTRAVAIL_DIS)\n\t\tdd->rcvctrl &= ~(mask << IBA7220_R_INTRAVAIL_SHIFT);\n\tqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\n\tif ((op & QIB_RCVCTRL_INTRAVAIL_ENB) && dd->rhdrhead_intr_off) {\n\t\t \n\t\tval = qib_read_ureg32(dd, ur_rcvhdrhead, ctxt) |\n\t\t\tdd->rhdrhead_intr_off;\n\t\tqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_ENB) {\n\t\t \n\t\tval = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);\n\t\tqib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);\n\n\t\tval = qib_read_ureg32(dd, ur_rcvhdrtail, ctxt);\n\t\tdd->rcd[ctxt]->head = val;\n\t\t \n\t\tif (ctxt < dd->first_user_ctxt)\n\t\t\tval |= dd->rhdrhead_intr_off;\n\t\tqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_DIS) {\n\t\tif (ctxt >= 0) {\n\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt, 0);\n\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt, 0);\n\t\t} else {\n\t\t\tunsigned i;\n\n\t\t\tfor (i = 0; i < dd->cfgctxts; i++) {\n\t\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,\n\t\t\t\t\t\t    i, 0);\n\t\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr, i, 0);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\n}\n\n \nstatic void sendctrl_7220_mod(struct qib_pportdata *ppd, u32 op)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 tmp_dd_sendctrl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\n\t \n\tif (op & QIB_SENDCTRL_CLEAR)\n\t\tdd->sendctrl = 0;\n\tif (op & QIB_SENDCTRL_SEND_DIS)\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, SPioEnable);\n\telse if (op & QIB_SENDCTRL_SEND_ENB) {\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, SPioEnable);\n\t\tif (dd->flags & QIB_USE_SPCL_TRIG)\n\t\t\tdd->sendctrl |= SYM_MASK(SendCtrl,\n\t\t\t\t\t\t SSpecialTriggerEn);\n\t}\n\tif (op & QIB_SENDCTRL_AVAIL_DIS)\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, SendBufAvailUpd);\n\telse if (op & QIB_SENDCTRL_AVAIL_ENB)\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, SendBufAvailUpd);\n\n\tif (op & QIB_SENDCTRL_DISARM_ALL) {\n\t\tu32 i, last;\n\n\t\ttmp_dd_sendctrl = dd->sendctrl;\n\t\t \n\t\tlast = dd->piobcnt2k + dd->piobcnt4k;\n\t\ttmp_dd_sendctrl &=\n\t\t\t~(SYM_MASK(SendCtrl, SPioEnable) |\n\t\t\t  SYM_MASK(SendCtrl, SendBufAvailUpd));\n\t\tfor (i = 0; i < last; i++) {\n\t\t\tqib_write_kreg(dd, kr_sendctrl,\n\t\t\t\t       tmp_dd_sendctrl |\n\t\t\t\t       SYM_MASK(SendCtrl, Disarm) | i);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t}\n\n\ttmp_dd_sendctrl = dd->sendctrl;\n\n\tif (op & QIB_SENDCTRL_FLUSH)\n\t\ttmp_dd_sendctrl |= SYM_MASK(SendCtrl, Abort);\n\tif (op & QIB_SENDCTRL_DISARM)\n\t\ttmp_dd_sendctrl |= SYM_MASK(SendCtrl, Disarm) |\n\t\t\t((op & QIB_7220_SendCtrl_DisarmPIOBuf_RMASK) <<\n\t\t\t SYM_LSB(SendCtrl, DisarmPIOBuf));\n\tif ((op & QIB_SENDCTRL_AVAIL_BLIP) &&\n\t    (dd->sendctrl & SYM_MASK(SendCtrl, SendBufAvailUpd)))\n\t\ttmp_dd_sendctrl &= ~SYM_MASK(SendCtrl, SendBufAvailUpd);\n\n\tqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tif (op & QIB_SENDCTRL_AVAIL_BLIP) {\n\t\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t}\n\n\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\n\tif (op & QIB_SENDCTRL_FLUSH) {\n\t\tu32 v;\n\t\t \n\t\tv = qib_read_kreg32(dd, kr_scratch);\n\t\tqib_write_kreg(dd, kr_scratch, v);\n\t\tv = qib_read_kreg32(dd, kr_scratch);\n\t\tqib_write_kreg(dd, kr_scratch, v);\n\t\tqib_read_kreg32(dd, kr_scratch);\n\t}\n}\n\n \nstatic u64 qib_portcntr_7220(struct qib_pportdata *ppd, u32 reg)\n{\n\tu64 ret = 0ULL;\n\tstruct qib_devdata *dd = ppd->dd;\n\tu16 creg;\n\t \n\tstatic const u16 xlator[] = {\n\t\t[QIBPORTCNTR_PKTSEND] = cr_pktsend,\n\t\t[QIBPORTCNTR_WORDSEND] = cr_wordsend,\n\t\t[QIBPORTCNTR_PSXMITDATA] = cr_psxmitdatacount,\n\t\t[QIBPORTCNTR_PSXMITPKTS] = cr_psxmitpktscount,\n\t\t[QIBPORTCNTR_PSXMITWAIT] = cr_psxmitwaitcount,\n\t\t[QIBPORTCNTR_SENDSTALL] = cr_sendstall,\n\t\t[QIBPORTCNTR_PKTRCV] = cr_pktrcv,\n\t\t[QIBPORTCNTR_PSRCVDATA] = cr_psrcvdatacount,\n\t\t[QIBPORTCNTR_PSRCVPKTS] = cr_psrcvpktscount,\n\t\t[QIBPORTCNTR_RCVEBP] = cr_rcvebp,\n\t\t[QIBPORTCNTR_RCVOVFL] = cr_rcvovfl,\n\t\t[QIBPORTCNTR_WORDRCV] = cr_wordrcv,\n\t\t[QIBPORTCNTR_RXDROPPKT] = cr_rxdroppkt,\n\t\t[QIBPORTCNTR_RXLOCALPHYERR] = cr_rxotherlocalphyerr,\n\t\t[QIBPORTCNTR_RXVLERR] = cr_rxvlerr,\n\t\t[QIBPORTCNTR_ERRICRC] = cr_erricrc,\n\t\t[QIBPORTCNTR_ERRVCRC] = cr_errvcrc,\n\t\t[QIBPORTCNTR_ERRLPCRC] = cr_errlpcrc,\n\t\t[QIBPORTCNTR_BADFORMAT] = cr_badformat,\n\t\t[QIBPORTCNTR_ERR_RLEN] = cr_err_rlen,\n\t\t[QIBPORTCNTR_IBSYMBOLERR] = cr_ibsymbolerr,\n\t\t[QIBPORTCNTR_INVALIDRLEN] = cr_invalidrlen,\n\t\t[QIBPORTCNTR_UNSUPVL] = cr_txunsupvl,\n\t\t[QIBPORTCNTR_EXCESSBUFOVFL] = cr_excessbufferovfl,\n\t\t[QIBPORTCNTR_ERRLINK] = cr_errlink,\n\t\t[QIBPORTCNTR_IBLINKDOWN] = cr_iblinkdown,\n\t\t[QIBPORTCNTR_IBLINKERRRECOV] = cr_iblinkerrrecov,\n\t\t[QIBPORTCNTR_LLI] = cr_locallinkintegrityerr,\n\t\t[QIBPORTCNTR_PSINTERVAL] = cr_psinterval,\n\t\t[QIBPORTCNTR_PSSTART] = cr_psstart,\n\t\t[QIBPORTCNTR_PSSTAT] = cr_psstat,\n\t\t[QIBPORTCNTR_VL15PKTDROP] = cr_vl15droppedpkt,\n\t\t[QIBPORTCNTR_ERRPKEY] = cr_errpkey,\n\t\t[QIBPORTCNTR_KHDROVFL] = 0xffff,\n\t};\n\n\tif (reg >= ARRAY_SIZE(xlator)) {\n\t\tqib_devinfo(ppd->dd->pcidev,\n\t\t\t \"Unimplemented portcounter %u\\n\", reg);\n\t\tgoto done;\n\t}\n\tcreg = xlator[reg];\n\n\tif (reg == QIBPORTCNTR_KHDROVFL) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < dd->first_user_ctxt; i++)\n\t\t\tret += read_7220_creg32(dd, cr_portovfl + i);\n\t}\n\tif (creg == 0xffff)\n\t\tgoto done;\n\n\t \n\tif ((creg == cr_wordsend || creg == cr_wordrcv ||\n\t     creg == cr_pktsend || creg == cr_pktrcv))\n\t\tret = read_7220_creg(dd, creg);\n\telse\n\t\tret = read_7220_creg32(dd, creg);\n\tif (creg == cr_ibsymbolerr) {\n\t\tif (dd->pport->cpspec->ibdeltainprog)\n\t\t\tret -= ret - ppd->cpspec->ibsymsnap;\n\t\tret -= dd->pport->cpspec->ibsymdelta;\n\t} else if (creg == cr_iblinkerrrecov) {\n\t\tif (dd->pport->cpspec->ibdeltainprog)\n\t\t\tret -= ret - ppd->cpspec->iblnkerrsnap;\n\t\tret -= dd->pport->cpspec->iblnkerrdelta;\n\t}\ndone:\n\treturn ret;\n}\n\n \nstatic const char cntr7220names[] =\n\t\"Interrupts\\n\"\n\t\"HostBusStall\\n\"\n\t\"E RxTIDFull\\n\"\n\t\"RxTIDInvalid\\n\"\n\t\"Ctxt0EgrOvfl\\n\"\n\t\"Ctxt1EgrOvfl\\n\"\n\t\"Ctxt2EgrOvfl\\n\"\n\t\"Ctxt3EgrOvfl\\n\"\n\t\"Ctxt4EgrOvfl\\n\"\n\t\"Ctxt5EgrOvfl\\n\"\n\t\"Ctxt6EgrOvfl\\n\"\n\t\"Ctxt7EgrOvfl\\n\"\n\t\"Ctxt8EgrOvfl\\n\"\n\t\"Ctxt9EgrOvfl\\n\"\n\t\"Ctx10EgrOvfl\\n\"\n\t\"Ctx11EgrOvfl\\n\"\n\t\"Ctx12EgrOvfl\\n\"\n\t\"Ctx13EgrOvfl\\n\"\n\t\"Ctx14EgrOvfl\\n\"\n\t\"Ctx15EgrOvfl\\n\"\n\t\"Ctx16EgrOvfl\\n\";\n\nstatic const size_t cntr7220indices[] = {\n\tcr_lbint,\n\tcr_lbflowstall,\n\tcr_errtidfull,\n\tcr_errtidvalid,\n\tcr_portovfl + 0,\n\tcr_portovfl + 1,\n\tcr_portovfl + 2,\n\tcr_portovfl + 3,\n\tcr_portovfl + 4,\n\tcr_portovfl + 5,\n\tcr_portovfl + 6,\n\tcr_portovfl + 7,\n\tcr_portovfl + 8,\n\tcr_portovfl + 9,\n\tcr_portovfl + 10,\n\tcr_portovfl + 11,\n\tcr_portovfl + 12,\n\tcr_portovfl + 13,\n\tcr_portovfl + 14,\n\tcr_portovfl + 15,\n\tcr_portovfl + 16,\n};\n\n \nstatic const char portcntr7220names[] =\n\t\"TxPkt\\n\"\n\t\"TxFlowPkt\\n\"\n\t\"TxWords\\n\"\n\t\"RxPkt\\n\"\n\t\"RxFlowPkt\\n\"\n\t\"RxWords\\n\"\n\t\"TxFlowStall\\n\"\n\t\"TxDmaDesc\\n\"   \n\t\"E RxDlidFltr\\n\"   \n\t\"IBStatusChng\\n\"\n\t\"IBLinkDown\\n\"\n\t\"IBLnkRecov\\n\"\n\t\"IBRxLinkErr\\n\"\n\t\"IBSymbolErr\\n\"\n\t\"RxLLIErr\\n\"\n\t\"RxBadFormat\\n\"\n\t\"RxBadLen\\n\"\n\t\"RxBufOvrfl\\n\"\n\t\"RxEBP\\n\"\n\t\"RxFlowCtlErr\\n\"\n\t\"RxICRCerr\\n\"\n\t\"RxLPCRCerr\\n\"\n\t\"RxVCRCerr\\n\"\n\t\"RxInvalLen\\n\"\n\t\"RxInvalPKey\\n\"\n\t\"RxPktDropped\\n\"\n\t\"TxBadLength\\n\"\n\t\"TxDropped\\n\"\n\t\"TxInvalLen\\n\"\n\t\"TxUnderrun\\n\"\n\t\"TxUnsupVL\\n\"\n\t\"RxLclPhyErr\\n\"  \n\t\"RxVL15Drop\\n\"  \n\t\"RxVlErr\\n\"  \n\t\"XcessBufOvfl\\n\"  \n\t;\n\n#define _PORT_VIRT_FLAG 0x8000  \nstatic const size_t portcntr7220indices[] = {\n\tQIBPORTCNTR_PKTSEND | _PORT_VIRT_FLAG,\n\tcr_pktsendflow,\n\tQIBPORTCNTR_WORDSEND | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_PKTRCV | _PORT_VIRT_FLAG,\n\tcr_pktrcvflowctrl,\n\tQIBPORTCNTR_WORDRCV | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_SENDSTALL | _PORT_VIRT_FLAG,\n\tcr_txsdmadesc,\n\tcr_rxdlidfltr,\n\tcr_ibstatuschange,\n\tQIBPORTCNTR_IBLINKDOWN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_IBLINKERRRECOV | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRLINK | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_IBSYMBOLERR | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_LLI | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_BADFORMAT | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERR_RLEN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RCVOVFL | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RCVEBP | _PORT_VIRT_FLAG,\n\tcr_rcvflowctrl_err,\n\tQIBPORTCNTR_ERRICRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRLPCRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRVCRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_INVALIDRLEN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRPKEY | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RXDROPPKT | _PORT_VIRT_FLAG,\n\tcr_invalidslen,\n\tcr_senddropped,\n\tcr_errslen,\n\tcr_sendunderrun,\n\tcr_txunsupvl,\n\tQIBPORTCNTR_RXLOCALPHYERR | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_VL15PKTDROP | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RXVLERR | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_EXCESSBUFOVFL | _PORT_VIRT_FLAG,\n};\n\n \nstatic void init_7220_cntrnames(struct qib_devdata *dd)\n{\n\tint i, j = 0;\n\tchar *s;\n\n\tfor (i = 0, s = (char *)cntr7220names; s && j <= dd->cfgctxts;\n\t     i++) {\n\t\t \n\t\tif (!j && !strncmp(\"Ctxt0EgrOvfl\", s + 1, 12))\n\t\t\tj = 1;\n\t\ts = strchr(s + 1, '\\n');\n\t\tif (s && j)\n\t\t\tj++;\n\t}\n\tdd->cspec->ncntrs = i;\n\tif (!s)\n\t\t \n\t\tdd->cspec->cntrnamelen = sizeof(cntr7220names) - 1;\n\telse\n\t\tdd->cspec->cntrnamelen = 1 + s - cntr7220names;\n\tdd->cspec->cntrs = kmalloc_array(dd->cspec->ncntrs, sizeof(u64),\n\t\t\t\t\t GFP_KERNEL);\n\n\tfor (i = 0, s = (char *)portcntr7220names; s; i++)\n\t\ts = strchr(s + 1, '\\n');\n\tdd->cspec->nportcntrs = i - 1;\n\tdd->cspec->portcntrnamelen = sizeof(portcntr7220names) - 1;\n\tdd->cspec->portcntrs = kmalloc_array(dd->cspec->nportcntrs,\n\t\t\t\t\t     sizeof(u64),\n\t\t\t\t\t     GFP_KERNEL);\n}\n\nstatic u32 qib_read_7220cntrs(struct qib_devdata *dd, loff_t pos, char **namep,\n\t\t\t      u64 **cntrp)\n{\n\tu32 ret;\n\n\tif (!dd->cspec->cntrs) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\tif (namep) {\n\t\t*namep = (char *)cntr7220names;\n\t\tret = dd->cspec->cntrnamelen;\n\t\tif (pos >= ret)\n\t\t\tret = 0;  \n\t} else {\n\t\tu64 *cntr = dd->cspec->cntrs;\n\t\tint i;\n\n\t\tret = dd->cspec->ncntrs * sizeof(u64);\n\t\tif (!cntr || pos >= ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t*cntrp = cntr;\n\t\tfor (i = 0; i < dd->cspec->ncntrs; i++)\n\t\t\t*cntr++ = read_7220_creg32(dd, cntr7220indices[i]);\n\t}\ndone:\n\treturn ret;\n}\n\nstatic u32 qib_read_7220portcntrs(struct qib_devdata *dd, loff_t pos, u32 port,\n\t\t\t\t  char **namep, u64 **cntrp)\n{\n\tu32 ret;\n\n\tif (!dd->cspec->portcntrs) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\tif (namep) {\n\t\t*namep = (char *)portcntr7220names;\n\t\tret = dd->cspec->portcntrnamelen;\n\t\tif (pos >= ret)\n\t\t\tret = 0;  \n\t} else {\n\t\tu64 *cntr = dd->cspec->portcntrs;\n\t\tstruct qib_pportdata *ppd = &dd->pport[port];\n\t\tint i;\n\n\t\tret = dd->cspec->nportcntrs * sizeof(u64);\n\t\tif (!cntr || pos >= ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t\t*cntrp = cntr;\n\t\tfor (i = 0; i < dd->cspec->nportcntrs; i++) {\n\t\t\tif (portcntr7220indices[i] & _PORT_VIRT_FLAG)\n\t\t\t\t*cntr++ = qib_portcntr_7220(ppd,\n\t\t\t\t\tportcntr7220indices[i] &\n\t\t\t\t\t~_PORT_VIRT_FLAG);\n\t\t\telse\n\t\t\t\t*cntr++ = read_7220_creg32(dd,\n\t\t\t\t\t   portcntr7220indices[i]);\n\t\t}\n\t}\ndone:\n\treturn ret;\n}\n\n \nstatic void qib_get_7220_faststats(struct timer_list *t)\n{\n\tstruct qib_devdata *dd = from_timer(dd, t, stats_timer);\n\tstruct qib_pportdata *ppd = dd->pport;\n\tunsigned long flags;\n\tu64 traffic_wds;\n\n\t \n\tif (!(dd->flags & QIB_INITTED) || dd->diag_client)\n\t\t \n\t\tgoto done;\n\n\t \n\ttraffic_wds = qib_portcntr_7220(ppd, cr_wordsend) +\n\t\tqib_portcntr_7220(ppd, cr_wordrcv);\n\tspin_lock_irqsave(&dd->eep_st_lock, flags);\n\ttraffic_wds -= dd->traffic_wds;\n\tdd->traffic_wds += traffic_wds;\n\tspin_unlock_irqrestore(&dd->eep_st_lock, flags);\ndone:\n\tmod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);\n}\n\n \nstatic int qib_7220_intr_fallback(struct qib_devdata *dd)\n{\n\tif (!dd->msi_lo)\n\t\treturn 0;\n\n\tqib_devinfo(dd->pcidev,\n\t\t    \"MSI interrupt not detected, trying INTx interrupts\\n\");\n\n\tqib_free_irq(dd);\n\tdd->msi_lo = 0;\n\tif (pci_alloc_irq_vectors(dd->pcidev, 1, 1, PCI_IRQ_LEGACY) < 0)\n\t\tqib_dev_err(dd, \"Failed to enable INTx\\n\");\n\tqib_setup_7220_interrupt(dd);\n\treturn 1;\n}\n\n \nstatic void qib_7220_xgxs_reset(struct qib_pportdata *ppd)\n{\n\tu64 val, prev_val;\n\tstruct qib_devdata *dd = ppd->dd;\n\n\tprev_val = qib_read_kreg64(dd, kr_xgxs_cfg);\n\tval = prev_val | QLOGIC_IB_XGXS_RESET;\n\tprev_val &= ~QLOGIC_IB_XGXS_RESET;  \n\tqib_write_kreg(dd, kr_control,\n\t\t       dd->control & ~QLOGIC_IB_C_LINKENABLE);\n\tqib_write_kreg(dd, kr_xgxs_cfg, val);\n\tqib_read_kreg32(dd, kr_scratch);\n\tqib_write_kreg(dd, kr_xgxs_cfg, prev_val);\n\tqib_write_kreg(dd, kr_control, dd->control);\n}\n\n \nstatic u32 __iomem *get_7220_link_buf(struct qib_pportdata *ppd, u32 *bnum)\n{\n\tu32 __iomem *buf;\n\tu32 lbuf = ppd->dd->cspec->lastbuf_for_pio;\n\tint do_cleanup;\n\tunsigned long flags;\n\n\t \n\tsendctrl_7220_mod(ppd->dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\tqib_read_kreg64(ppd->dd, kr_scratch);  \n\tbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\n\tif (buf)\n\t\tgoto done;\n\n\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\tif (ppd->sdma_state.current_state == qib_sdma_state_s20_idle &&\n\t    ppd->sdma_state.current_state != qib_sdma_state_s00_hw_down) {\n\t\t__qib_sdma_process_event(ppd, qib_sdma_event_e00_go_hw_down);\n\t\tdo_cleanup = 0;\n\t} else {\n\t\tdo_cleanup = 1;\n\t\tqib_7220_sdma_hw_clean_up(ppd);\n\t}\n\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n\n\tif (do_cleanup) {\n\t\tqib_read_kreg64(ppd->dd, kr_scratch);  \n\t\tbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\n\t}\ndone:\n\treturn buf;\n}\n\n \nstatic void autoneg_7220_sendpkt(struct qib_pportdata *ppd, u32 *hdr,\n\t\t\t\t u32 dcnt, u32 *data)\n{\n\tint i;\n\tu64 pbc;\n\tu32 __iomem *piobuf;\n\tu32 pnum;\n\tstruct qib_devdata *dd = ppd->dd;\n\n\ti = 0;\n\tpbc = 7 + dcnt + 1;  \n\tpbc |= PBC_7220_VL15_SEND;\n\twhile (!(piobuf = get_7220_link_buf(ppd, &pnum))) {\n\t\tif (i++ > 5)\n\t\t\treturn;\n\t\tudelay(2);\n\t}\n\tsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_DISARM_BUF(pnum));\n\twriteq(pbc, piobuf);\n\tqib_flush_wc();\n\tqib_pio_copy(piobuf + 2, hdr, 7);\n\tqib_pio_copy(piobuf + 9, data, dcnt);\n\tif (dd->flags & QIB_USE_SPCL_TRIG) {\n\t\tu32 spcl_off = (pnum >= dd->piobcnt2k) ? 2047 : 1023;\n\n\t\tqib_flush_wc();\n\t\t__raw_writel(0xaebecede, piobuf + spcl_off);\n\t}\n\tqib_flush_wc();\n\tqib_sendbuf_done(dd, pnum);\n}\n\n \nstatic void autoneg_7220_send(struct qib_pportdata *ppd, int which)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tstatic u32 swapped;\n\tu32 dw, i, hcnt, dcnt, *data;\n\tstatic u32 hdr[7] = { 0xf002ffff, 0x48ffff, 0x6400abba };\n\tstatic u32 madpayload_start[0x40] = {\n\t\t0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,\n\t\t0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\t\t0x1, 0x1388, 0x15e, 0x1,  \n\t\t};\n\tstatic u32 madpayload_done[0x40] = {\n\t\t0x1810103, 0x1, 0x0, 0x0, 0x2c90000, 0x2c9, 0x0, 0x0,\n\t\t0xffffffff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,\n\t\t0x40000001, 0x1388, 0x15e,  \n\t\t};\n\n\tdcnt = ARRAY_SIZE(madpayload_start);\n\thcnt = ARRAY_SIZE(hdr);\n\tif (!swapped) {\n\t\t \n\t\tfor (i = 0; i < hcnt; i++) {\n\t\t\tdw = (__force u32) cpu_to_be32(hdr[i]);\n\t\t\thdr[i] = dw;\n\t\t}\n\t\tfor (i = 0; i < dcnt; i++) {\n\t\t\tdw = (__force u32) cpu_to_be32(madpayload_start[i]);\n\t\t\tmadpayload_start[i] = dw;\n\t\t\tdw = (__force u32) cpu_to_be32(madpayload_done[i]);\n\t\t\tmadpayload_done[i] = dw;\n\t\t}\n\t\tswapped = 1;\n\t}\n\n\tdata = which ? madpayload_done : madpayload_start;\n\n\tautoneg_7220_sendpkt(ppd, hdr, dcnt, data);\n\tqib_read_kreg64(dd, kr_scratch);\n\tudelay(2);\n\tautoneg_7220_sendpkt(ppd, hdr, dcnt, data);\n\tqib_read_kreg64(dd, kr_scratch);\n\tudelay(2);\n}\n\n \nstatic void set_7220_ibspeed_fast(struct qib_pportdata *ppd, u32 speed)\n{\n\tppd->cpspec->ibcddrctrl &= ~(IBA7220_IBC_SPEED_AUTONEG_MASK |\n\t\tIBA7220_IBC_IBTA_1_2_MASK);\n\n\tif (speed == (QIB_IB_SDR | QIB_IB_DDR))\n\t\tppd->cpspec->ibcddrctrl |= IBA7220_IBC_SPEED_AUTONEG_MASK |\n\t\t\tIBA7220_IBC_IBTA_1_2_MASK;\n\telse\n\t\tppd->cpspec->ibcddrctrl |= speed == QIB_IB_DDR ?\n\t\t\tIBA7220_IBC_SPEED_DDR : IBA7220_IBC_SPEED_SDR;\n\n\tqib_write_kreg(ppd->dd, kr_ibcddrctrl, ppd->cpspec->ibcddrctrl);\n\tqib_write_kreg(ppd->dd, kr_scratch, 0);\n}\n\n \nstatic void try_7220_autoneg(struct qib_pportdata *ppd)\n{\n\tunsigned long flags;\n\n\t \n\tqib_write_kreg(ppd->dd, kr_ncmodectrl, 0x3b9dc07);\n\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tppd->lflags |= QIBL_IB_AUTONEG_INPROG;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\tautoneg_7220_send(ppd, 0);\n\tset_7220_ibspeed_fast(ppd, QIB_IB_DDR);\n\n\ttoggle_7220_rclkrls(ppd->dd);\n\t \n\tqueue_delayed_work(ib_wq, &ppd->cpspec->autoneg_work,\n\t\t\t   msecs_to_jiffies(2));\n}\n\n \nstatic void autoneg_7220_work(struct work_struct *work)\n{\n\tstruct qib_pportdata *ppd;\n\tstruct qib_devdata *dd;\n\tu32 i;\n\tunsigned long flags;\n\n\tppd = &container_of(work, struct qib_chippport_specific,\n\t\t\t    autoneg_work.work)->pportdata;\n\tdd = ppd->dd;\n\n\t \n\tfor (i = 0; i < 25; i++) {\n\t\tif (SYM_FIELD(ppd->lastibcstat, IBCStatus, LinkTrainingState)\n\t\t     == IB_7220_LT_STATE_POLLQUIET) {\n\t\t\tqib_set_linkstate(ppd, QIB_IB_LINKDOWN_DISABLE);\n\t\t\tbreak;\n\t\t}\n\t\tudelay(100);\n\t}\n\n\tif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\n\t\tgoto done;  \n\n\t \n\tif (wait_event_timeout(ppd->cpspec->autoneg_wait,\n\t\t\t       !(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\n\t\t\t       msecs_to_jiffies(90)))\n\t\tgoto done;\n\n\ttoggle_7220_rclkrls(dd);\n\n\t \n\tif (wait_event_timeout(ppd->cpspec->autoneg_wait,\n\t\t\t       !(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\n\t\t\t       msecs_to_jiffies(1700)))\n\t\tgoto done;\n\n\tset_7220_ibspeed_fast(ppd, QIB_IB_SDR);\n\ttoggle_7220_rclkrls(dd);\n\n\t \n\twait_event_timeout(ppd->cpspec->autoneg_wait,\n\t\t!(ppd->lflags & QIBL_IB_AUTONEG_INPROG),\n\t\tmsecs_to_jiffies(250));\ndone:\n\tif (ppd->lflags & QIBL_IB_AUTONEG_INPROG) {\n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags &= ~QIBL_IB_AUTONEG_INPROG;\n\t\tif (dd->cspec->autoneg_tries == AUTONEG_TRIES) {\n\t\t\tppd->lflags |= QIBL_IB_AUTONEG_FAILED;\n\t\t\tdd->cspec->autoneg_tries = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\tset_7220_ibspeed_fast(ppd, ppd->link_speed_enabled);\n\t}\n}\n\nstatic u32 qib_7220_iblink_state(u64 ibcs)\n{\n\tu32 state = (u32)SYM_FIELD(ibcs, IBCStatus, LinkState);\n\n\tswitch (state) {\n\tcase IB_7220_L_STATE_INIT:\n\t\tstate = IB_PORT_INIT;\n\t\tbreak;\n\tcase IB_7220_L_STATE_ARM:\n\t\tstate = IB_PORT_ARMED;\n\t\tbreak;\n\tcase IB_7220_L_STATE_ACTIVE:\n\tcase IB_7220_L_STATE_ACT_DEFER:\n\t\tstate = IB_PORT_ACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tfallthrough;\n\tcase IB_7220_L_STATE_DOWN:\n\t\tstate = IB_PORT_DOWN;\n\t\tbreak;\n\t}\n\treturn state;\n}\n\n \nstatic u8 qib_7220_phys_portstate(u64 ibcs)\n{\n\tu8 state = (u8)SYM_FIELD(ibcs, IBCStatus, LinkTrainingState);\n\treturn qib_7220_physportstate[state];\n}\n\nstatic int qib_7220_ib_updown(struct qib_pportdata *ppd, int ibup, u64 ibcs)\n{\n\tint ret = 0, symadj = 0;\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tppd->lflags &= ~QIBL_IB_FORCE_NOTIFY;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\n\tif (!ibup) {\n\t\t \n\t\tif (!(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |\n\t\t\t\t     QIBL_IB_AUTONEG_INPROG)))\n\t\t\tset_7220_ibspeed_fast(ppd, ppd->link_speed_enabled);\n\t\tif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {\n\t\t\tqib_sd7220_presets(dd);\n\t\t\tqib_cancel_sends(ppd);  \n\t\t\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\t\t\tif (__qib_sdma_running(ppd))\n\t\t\t\t__qib_sdma_process_event(ppd,\n\t\t\t\t\tqib_sdma_event_e70_go_idle);\n\t\t\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n\t\t}\n\t\t \n\t\tset_7220_relock_poll(dd, ibup);\n\t} else {\n\t\tif (qib_compat_ddr_negotiate &&\n\t\t    !(ppd->lflags & (QIBL_IB_AUTONEG_FAILED |\n\t\t\t\t     QIBL_IB_AUTONEG_INPROG)) &&\n\t\t    ppd->link_speed_active == QIB_IB_SDR &&\n\t\t    (ppd->link_speed_enabled & (QIB_IB_DDR | QIB_IB_SDR)) ==\n\t\t    (QIB_IB_DDR | QIB_IB_SDR) &&\n\t\t    dd->cspec->autoneg_tries < AUTONEG_TRIES) {\n\t\t\t \n\t\t\t++dd->cspec->autoneg_tries;\n\t\t\tif (!ppd->cpspec->ibdeltainprog) {\n\t\t\t\tppd->cpspec->ibdeltainprog = 1;\n\t\t\t\tppd->cpspec->ibsymsnap = read_7220_creg32(dd,\n\t\t\t\t\tcr_ibsymbolerr);\n\t\t\t\tppd->cpspec->iblnkerrsnap = read_7220_creg32(dd,\n\t\t\t\t\tcr_iblinkerrrecov);\n\t\t\t}\n\t\t\ttry_7220_autoneg(ppd);\n\t\t\tret = 1;  \n\t\t} else if ((ppd->lflags & QIBL_IB_AUTONEG_INPROG) &&\n\t\t\t   ppd->link_speed_active == QIB_IB_SDR) {\n\t\t\tautoneg_7220_send(ppd, 1);\n\t\t\tset_7220_ibspeed_fast(ppd, QIB_IB_DDR);\n\t\t\tudelay(2);\n\t\t\ttoggle_7220_rclkrls(dd);\n\t\t\tret = 1;  \n\t\t} else {\n\t\t\tif ((ppd->lflags & QIBL_IB_AUTONEG_INPROG) &&\n\t\t\t    (ppd->link_speed_active & QIB_IB_DDR)) {\n\t\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\t\tppd->lflags &= ~(QIBL_IB_AUTONEG_INPROG |\n\t\t\t\t\t\t QIBL_IB_AUTONEG_FAILED);\n\t\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tdd->cspec->autoneg_tries = 0;\n\t\t\t\t \n\t\t\t\tset_7220_ibspeed_fast(ppd,\n\t\t\t\t\t\t      ppd->link_speed_enabled);\n\t\t\t\twake_up(&ppd->cpspec->autoneg_wait);\n\t\t\t\tsymadj = 1;\n\t\t\t} else if (ppd->lflags & QIBL_IB_AUTONEG_FAILED) {\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\t\t\tppd->lflags &= ~QIBL_IB_AUTONEG_FAILED;\n\t\t\t\tspin_unlock_irqrestore(&ppd->lflags_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tppd->cpspec->ibcddrctrl |=\n\t\t\t\t\tIBA7220_IBC_IBTA_1_2_MASK;\n\t\t\t\tqib_write_kreg(dd, kr_ncmodectrl, 0);\n\t\t\t\tsymadj = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!(ppd->lflags & QIBL_IB_AUTONEG_INPROG))\n\t\t\tsymadj = 1;\n\n\t\tif (!ret) {\n\t\t\tppd->delay_mult = rate_to_delay\n\t\t\t    [(ibcs >> IBA7220_LINKSPEED_SHIFT) & 1]\n\t\t\t    [(ibcs >> IBA7220_LINKWIDTH_SHIFT) & 1];\n\n\t\t\tset_7220_relock_poll(dd, ibup);\n\t\t\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\t\t\t \n\t\t\tif (ppd->sdma_state.current_state !=\n\t\t\t    qib_sdma_state_s20_idle)\n\t\t\t\t__qib_sdma_process_event(ppd,\n\t\t\t\t\tqib_sdma_event_e00_go_hw_down);\n\t\t\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n\t\t}\n\t}\n\n\tif (symadj) {\n\t\tif (ppd->cpspec->ibdeltainprog) {\n\t\t\tppd->cpspec->ibdeltainprog = 0;\n\t\t\tppd->cpspec->ibsymdelta += read_7220_creg32(ppd->dd,\n\t\t\t\tcr_ibsymbolerr) - ppd->cpspec->ibsymsnap;\n\t\t\tppd->cpspec->iblnkerrdelta += read_7220_creg32(ppd->dd,\n\t\t\t\tcr_iblinkerrrecov) - ppd->cpspec->iblnkerrsnap;\n\t\t}\n\t} else if (!ibup && qib_compat_ddr_negotiate &&\n\t\t   !ppd->cpspec->ibdeltainprog &&\n\t\t\t!(ppd->lflags & QIBL_IB_AUTONEG_INPROG)) {\n\t\tppd->cpspec->ibdeltainprog = 1;\n\t\tppd->cpspec->ibsymsnap = read_7220_creg32(ppd->dd,\n\t\t\t\t\t\t\t  cr_ibsymbolerr);\n\t\tppd->cpspec->iblnkerrsnap = read_7220_creg32(ppd->dd,\n\t\t\t\t\t\t     cr_iblinkerrrecov);\n\t}\n\n\tif (!ret)\n\t\tqib_setup_7220_setextled(ppd, ibup);\n\treturn ret;\n}\n\n \nstatic int gpio_7220_mod(struct qib_devdata *dd, u32 out, u32 dir, u32 mask)\n{\n\tu64 read_val, new_out;\n\tunsigned long flags;\n\n\tif (mask) {\n\t\t \n\t\tdir &= mask;\n\t\tout &= mask;\n\t\tspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\n\t\tdd->cspec->extctrl &= ~((u64)mask << SYM_LSB(EXTCtrl, GPIOOe));\n\t\tdd->cspec->extctrl |= ((u64) dir << SYM_LSB(EXTCtrl, GPIOOe));\n\t\tnew_out = (dd->cspec->gpio_out & ~mask) | out;\n\n\t\tqib_write_kreg(dd, kr_extctrl, dd->cspec->extctrl);\n\t\tqib_write_kreg(dd, kr_gpio_out, new_out);\n\t\tdd->cspec->gpio_out = new_out;\n\t\tspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\n\t}\n\t \n\tread_val = qib_read_kreg64(dd, kr_extstatus);\n\treturn SYM_FIELD(read_val, EXTStatus, GPIOIn);\n}\n\n \nstatic void get_7220_chip_params(struct qib_devdata *dd)\n{\n\tu64 val;\n\tu32 piobufs;\n\tint mtu;\n\n\tdd->uregbase = qib_read_kreg32(dd, kr_userregbase);\n\n\tdd->rcvtidcnt = qib_read_kreg32(dd, kr_rcvtidcnt);\n\tdd->rcvtidbase = qib_read_kreg32(dd, kr_rcvtidbase);\n\tdd->rcvegrbase = qib_read_kreg32(dd, kr_rcvegrbase);\n\tdd->palign = qib_read_kreg32(dd, kr_palign);\n\tdd->piobufbase = qib_read_kreg64(dd, kr_sendpiobufbase);\n\tdd->pio2k_bufbase = dd->piobufbase & 0xffffffff;\n\n\tval = qib_read_kreg64(dd, kr_sendpiosize);\n\tdd->piosize2k = val & ~0U;\n\tdd->piosize4k = val >> 32;\n\n\tmtu = ib_mtu_enum_to_int(qib_ibmtu);\n\tif (mtu == -1)\n\t\tmtu = QIB_DEFAULT_MTU;\n\tdd->pport->ibmtu = (u32)mtu;\n\n\tval = qib_read_kreg64(dd, kr_sendpiobufcnt);\n\tdd->piobcnt2k = val & ~0U;\n\tdd->piobcnt4k = val >> 32;\n\t \n\tdd->pio2kbase = (u32 __iomem *)\n\t\t((char __iomem *) dd->kregbase + dd->pio2k_bufbase);\n\tif (dd->piobcnt4k) {\n\t\tdd->pio4kbase = (u32 __iomem *)\n\t\t\t((char __iomem *) dd->kregbase +\n\t\t\t (dd->piobufbase >> 32));\n\t\t \n\t\tdd->align4k = ALIGN(dd->piosize4k, dd->palign);\n\t}\n\n\tpiobufs = dd->piobcnt4k + dd->piobcnt2k;\n\n\tdd->pioavregs = ALIGN(piobufs, sizeof(u64) * BITS_PER_BYTE / 2) /\n\t\t(sizeof(u64) * BITS_PER_BYTE / 2);\n}\n\n \nstatic void set_7220_baseaddrs(struct qib_devdata *dd)\n{\n\tu32 cregbase;\n\t \n\tcregbase = qib_read_kreg32(dd, kr_counterregbase);\n\tdd->cspec->cregbase = (u64 __iomem *)\n\t\t((char __iomem *) dd->kregbase + cregbase);\n\n\tdd->egrtidbase = (u64 __iomem *)\n\t\t((char __iomem *) dd->kregbase + dd->rcvegrbase);\n}\n\n\n#define SENDCTRL_SHADOWED (SYM_MASK(SendCtrl, SendIntBufAvail) |\t\\\n\t\t\t   SYM_MASK(SendCtrl, SPioEnable) |\t\t\\\n\t\t\t   SYM_MASK(SendCtrl, SSpecialTriggerEn) |\t\\\n\t\t\t   SYM_MASK(SendCtrl, SendBufAvailUpd) |\t\\\n\t\t\t   SYM_MASK(SendCtrl, AvailUpdThld) |\t\t\\\n\t\t\t   SYM_MASK(SendCtrl, SDmaEnable) |\t\t\\\n\t\t\t   SYM_MASK(SendCtrl, SDmaIntEnable) |\t\t\\\n\t\t\t   SYM_MASK(SendCtrl, SDmaHalt) |\t\t\\\n\t\t\t   SYM_MASK(SendCtrl, SDmaSingleDescriptor))\n\nstatic int sendctrl_hook(struct qib_devdata *dd,\n\t\t\t const struct diag_observer *op,\n\t\t\t u32 offs, u64 *data, u64 mask, int only_32)\n{\n\tunsigned long flags;\n\tunsigned idx = offs / sizeof(u64);\n\tu64 local_data, all_bits;\n\n\tif (idx != kr_sendctrl) {\n\t\tqib_dev_err(dd, \"SendCtrl Hook called with offs %X, %s-bit\\n\",\n\t\t\t    offs, only_32 ? \"32\" : \"64\");\n\t\treturn 0;\n\t}\n\n\tall_bits = ~0ULL;\n\tif (only_32)\n\t\tall_bits >>= 32;\n\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\tif ((mask & all_bits) != all_bits) {\n\t\t \n\t\tif (only_32)\n\t\t\tlocal_data = (u64)qib_read_kreg32(dd, idx);\n\t\telse\n\t\t\tlocal_data = qib_read_kreg64(dd, idx);\n\t\tqib_dev_err(dd, \"Sendctrl -> %X, Shad -> %X\\n\",\n\t\t\t    (u32)local_data, (u32)dd->sendctrl);\n\t\tif ((local_data & SENDCTRL_SHADOWED) !=\n\t\t    (dd->sendctrl & SENDCTRL_SHADOWED))\n\t\t\tqib_dev_err(dd, \"Sendctrl read: %X shadow is %X\\n\",\n\t\t\t\t(u32)local_data, (u32) dd->sendctrl);\n\t\t*data = (local_data & ~mask) | (*data & mask);\n\t}\n\tif (mask) {\n\t\t \n\t\tu64 sval, tval;  \n\n\t\t \n\t\tsval = (dd->sendctrl & ~mask);\n\t\tsval |= *data & SENDCTRL_SHADOWED & mask;\n\t\tdd->sendctrl = sval;\n\t\ttval = sval | (*data & ~SENDCTRL_SHADOWED & mask);\n\t\tqib_dev_err(dd, \"Sendctrl <- %X, Shad <- %X\\n\",\n\t\t\t    (u32)tval, (u32)sval);\n\t\tqib_write_kreg(dd, kr_sendctrl, tval);\n\t\tqib_write_kreg(dd, kr_scratch, 0Ull);\n\t}\n\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\n\treturn only_32 ? 4 : 8;\n}\n\nstatic const struct diag_observer sendctrl_observer = {\n\tsendctrl_hook, kr_sendctrl * sizeof(u64),\n\tkr_sendctrl * sizeof(u64)\n};\n\n \nstatic int qib_late_7220_initreg(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\tu64 val;\n\n\tqib_write_kreg(dd, kr_rcvhdrentsize, dd->rcvhdrentsize);\n\tqib_write_kreg(dd, kr_rcvhdrsize, dd->rcvhdrsize);\n\tqib_write_kreg(dd, kr_rcvhdrcnt, dd->rcvhdrcnt);\n\tqib_write_kreg(dd, kr_sendpioavailaddr, dd->pioavailregs_phys);\n\tval = qib_read_kreg64(dd, kr_sendpioavailaddr);\n\tif (val != dd->pioavailregs_phys) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Catastrophic software error, SendPIOAvailAddr written as %lx, read back as %llx\\n\",\n\t\t\t(unsigned long) dd->pioavailregs_phys,\n\t\t\t(unsigned long long) val);\n\t\tret = -EINVAL;\n\t}\n\tqib_register_observer(dd, &sendctrl_observer);\n\treturn ret;\n}\n\nstatic int qib_init_7220_variables(struct qib_devdata *dd)\n{\n\tstruct qib_chippport_specific *cpspec;\n\tstruct qib_pportdata *ppd;\n\tint ret = 0;\n\tu32 sbufs, updthresh;\n\n\tcpspec = (struct qib_chippport_specific *)(dd + 1);\n\tppd = &cpspec->pportdata;\n\tdd->pport = ppd;\n\tdd->num_pports = 1;\n\n\tdd->cspec = (struct qib_chip_specific *)(cpspec + dd->num_pports);\n\tdd->cspec->dd = dd;\n\tppd->cpspec = cpspec;\n\n\tspin_lock_init(&dd->cspec->sdepb_lock);\n\tspin_lock_init(&dd->cspec->rcvmod_lock);\n\tspin_lock_init(&dd->cspec->gpio_lock);\n\n\t \n\tdd->revision = readq(&dd->kregbase[kr_revision]);\n\n\tif ((dd->revision & 0xffffffffU) == 0xffffffffU) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Revision register read failure, giving up initialization\\n\");\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\tdd->flags |= QIB_PRESENT;   \n\n\tdd->majrev = (u8) SYM_FIELD(dd->revision, Revision_R,\n\t\t\t\t    ChipRevMajor);\n\tdd->minrev = (u8) SYM_FIELD(dd->revision, Revision_R,\n\t\t\t\t    ChipRevMinor);\n\n\tget_7220_chip_params(dd);\n\tqib_7220_boardname(dd);\n\n\t \n\tdd->gpio_sda_num = _QIB_GPIO_SDA_NUM;\n\tdd->gpio_scl_num = _QIB_GPIO_SCL_NUM;\n\tdd->twsi_eeprom_dev = QIB_TWSI_EEPROM_DEV;\n\n\tdd->flags |= QIB_HAS_INTX | QIB_HAS_LINK_LATENCY |\n\t\tQIB_NODMA_RTAIL | QIB_HAS_THRESH_UPDATE;\n\tdd->flags |= qib_special_trigger ?\n\t\tQIB_USE_SPCL_TRIG : QIB_HAS_SEND_DMA;\n\n\tinit_waitqueue_head(&cpspec->autoneg_wait);\n\tINIT_DELAYED_WORK(&cpspec->autoneg_work, autoneg_7220_work);\n\n\tret = qib_init_pportdata(ppd, dd, 0, 1);\n\tif (ret)\n\t\tgoto bail;\n\tppd->link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;\n\tppd->link_speed_supported = QIB_IB_SDR | QIB_IB_DDR;\n\n\tppd->link_width_enabled = ppd->link_width_supported;\n\tppd->link_speed_enabled = ppd->link_speed_supported;\n\t \n\tppd->link_width_active = IB_WIDTH_4X;\n\tppd->link_speed_active = QIB_IB_SDR;\n\tppd->delay_mult = rate_to_delay[0][1];\n\tppd->vls_supported = IB_VL_VL0;\n\tppd->vls_operational = ppd->vls_supported;\n\n\tif (!qib_mini_init)\n\t\tqib_write_kreg(dd, kr_rcvbthqp, QIB_KD_QP);\n\n\ttimer_setup(&ppd->cpspec->chase_timer, reenable_7220_chase, 0);\n\n\tqib_num_cfg_vls = 1;  \n\n\tdd->rcvhdrentsize = QIB_RCVHDR_ENTSIZE;\n\tdd->rcvhdrsize = QIB_DFLT_RCVHDRSIZE;\n\tdd->rhf_offset =\n\t\tdd->rcvhdrentsize - sizeof(u64) / sizeof(u32);\n\n\t \n\tret = ib_mtu_enum_to_int(qib_ibmtu);\n\tdd->rcvegrbufsize = ret != -1 ? max(ret, 2048) : QIB_DEFAULT_MTU;\n\tdd->rcvegrbufsize_shift = ilog2(dd->rcvegrbufsize);\n\n\tqib_7220_tidtemplate(dd);\n\n\t \n\tdd->rhdrhead_intr_off = 1ULL << 32;\n\n\t \n\ttimer_setup(&dd->stats_timer, qib_get_7220_faststats, 0);\n\tdd->stats_timer.expires = jiffies + ACTIVITY_TIMER * HZ;\n\n\t \n\tif (qib_sdma_fetch_arb)\n\t\tdd->control |= 1 << 4;\n\n\tdd->ureg_align = 0x10000;   \n\n\tdd->piosize2kmax_dwords = (dd->piosize2k >> 2)-1;\n\tqib_7220_config_ctxts(dd);\n\tqib_set_ctxtcnt(dd);   \n\n\tret = init_chip_wc_pat(dd, 0);\n\tif (ret)\n\t\tgoto bail;\n\tset_7220_baseaddrs(dd);  \n\n\tret = 0;\n\tif (qib_mini_init)\n\t\tgoto bail;\n\n\tret = qib_create_ctxts(dd);\n\tinit_7220_cntrnames(dd);\n\n\t \n\tupdthresh = 8U;  \n\tif (dd->flags & QIB_HAS_SEND_DMA) {\n\t\tdd->cspec->sdmabufcnt =  dd->piobcnt4k;\n\t\tsbufs = updthresh > 3 ? updthresh : 3;\n\t} else {\n\t\tdd->cspec->sdmabufcnt = 0;\n\t\tsbufs = dd->piobcnt4k;\n\t}\n\n\tdd->cspec->lastbuf_for_pio = dd->piobcnt2k + dd->piobcnt4k -\n\t\tdd->cspec->sdmabufcnt;\n\tdd->lastctxt_piobuf = dd->cspec->lastbuf_for_pio - sbufs;\n\tdd->cspec->lastbuf_for_pio--;  \n\tdd->last_pio = dd->cspec->lastbuf_for_pio;\n\tdd->pbufsctxt = dd->lastctxt_piobuf /\n\t\t(dd->cfgctxts - dd->first_user_ctxt);\n\n\t \n\tif ((dd->pbufsctxt - 2) < updthresh)\n\t\tupdthresh = dd->pbufsctxt - 2;\n\n\tdd->cspec->updthresh_dflt = updthresh;\n\tdd->cspec->updthresh = updthresh;\n\n\t \n\tdd->sendctrl |= (updthresh & SYM_RMASK(SendCtrl, AvailUpdThld))\n\t\t\t     << SYM_LSB(SendCtrl, AvailUpdThld);\n\n\tdd->psxmitwait_supported = 1;\n\tdd->psxmitwait_check_rate = QIB_7220_PSXMITWAIT_CHECK_RATE;\nbail:\n\treturn ret;\n}\n\nstatic u32 __iomem *qib_7220_getsendbuf(struct qib_pportdata *ppd, u64 pbc,\n\t\t\t\t\tu32 *pbufnum)\n{\n\tu32 first, last, plen = pbc & QIB_PBC_LENGTH_MASK;\n\tstruct qib_devdata *dd = ppd->dd;\n\tu32 __iomem *buf;\n\n\tif (((pbc >> 32) & PBC_7220_VL15_SEND_CTRL) &&\n\t\t!(ppd->lflags & (QIBL_IB_AUTONEG_INPROG | QIBL_LINKACTIVE)))\n\t\tbuf = get_7220_link_buf(ppd, pbufnum);\n\telse {\n\t\tif ((plen + 1) > dd->piosize2kmax_dwords)\n\t\t\tfirst = dd->piobcnt2k;\n\t\telse\n\t\t\tfirst = 0;\n\t\t \n\t\tlast = dd->cspec->lastbuf_for_pio;\n\t\tbuf = qib_getsendbuf_range(dd, pbufnum, first, last);\n\t}\n\treturn buf;\n}\n\n \nstatic void qib_set_cntr_7220_sample(struct qib_pportdata *ppd, u32 intv,\n\t\t\t\t     u32 start)\n{\n\twrite_7220_creg(ppd->dd, cr_psinterval, intv);\n\twrite_7220_creg(ppd->dd, cr_psstart, start);\n}\n\n \n\n \nstatic void qib_sdma_update_7220_tail(struct qib_pportdata *ppd, u16 tail)\n{\n\t \n\twmb();\n\tppd->sdma_descq_tail = tail;\n\tqib_write_kreg(ppd->dd, kr_senddmatail, tail);\n}\n\nstatic void qib_sdma_set_7220_desc_cnt(struct qib_pportdata *ppd, unsigned cnt)\n{\n}\n\nstatic struct sdma_set_state_action sdma_7220_action_table[] = {\n\t[qib_sdma_state_s00_hw_down] = {\n\t\t.op_enable = 0,\n\t\t.op_intenable = 0,\n\t\t.op_halt = 0,\n\t\t.go_s99_running_tofalse = 1,\n\t},\n\t[qib_sdma_state_s10_hw_start_up_wait] = {\n\t\t.op_enable = 1,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 1,\n\t},\n\t[qib_sdma_state_s20_idle] = {\n\t\t.op_enable = 1,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 1,\n\t},\n\t[qib_sdma_state_s30_sw_clean_up_wait] = {\n\t\t.op_enable = 0,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 0,\n\t},\n\t[qib_sdma_state_s40_hw_clean_up_wait] = {\n\t\t.op_enable = 1,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 1,\n\t},\n\t[qib_sdma_state_s50_hw_halt_wait] = {\n\t\t.op_enable = 1,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 1,\n\t},\n\t[qib_sdma_state_s99_running] = {\n\t\t.op_enable = 1,\n\t\t.op_intenable = 1,\n\t\t.op_halt = 0,\n\t\t.go_s99_running_totrue = 1,\n\t},\n};\n\nstatic void qib_7220_sdma_init_early(struct qib_pportdata *ppd)\n{\n\tppd->sdma_state.set_state_action = sdma_7220_action_table;\n}\n\nstatic int init_sdma_7220_regs(struct qib_pportdata *ppd)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned i, n;\n\tu64 senddmabufmask[3] = { 0 };\n\n\t \n\tqib_write_kreg(dd, kr_senddmabase, ppd->sdma_descq_phys);\n\tqib_sdma_7220_setlengen(ppd);\n\tqib_sdma_update_7220_tail(ppd, 0);  \n\t \n\tqib_write_kreg(dd, kr_senddmaheadaddr, ppd->sdma_head_phys);\n\n\t \n\tn = dd->piobcnt2k + dd->piobcnt4k;\n\ti = n - dd->cspec->sdmabufcnt;\n\n\tfor (; i < n; ++i) {\n\t\tunsigned word = i / 64;\n\t\tunsigned bit = i & 63;\n\n\t\tsenddmabufmask[word] |= 1ULL << bit;\n\t}\n\tqib_write_kreg(dd, kr_senddmabufmask0, senddmabufmask[0]);\n\tqib_write_kreg(dd, kr_senddmabufmask1, senddmabufmask[1]);\n\tqib_write_kreg(dd, kr_senddmabufmask2, senddmabufmask[2]);\n\n\tppd->sdma_state.first_sendbuf = i;\n\tppd->sdma_state.last_sendbuf = n;\n\n\treturn 0;\n}\n\n \nstatic u16 qib_sdma_7220_gethead(struct qib_pportdata *ppd)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tint sane;\n\tint use_dmahead;\n\tu16 swhead;\n\tu16 swtail;\n\tu16 cnt;\n\tu16 hwhead;\n\n\tuse_dmahead = __qib_sdma_running(ppd) &&\n\t\t(dd->flags & QIB_HAS_SDMA_TIMEOUT);\nretry:\n\thwhead = use_dmahead ?\n\t\t(u16)le64_to_cpu(*ppd->sdma_head_dma) :\n\t\t(u16)qib_read_kreg32(dd, kr_senddmahead);\n\n\tswhead = ppd->sdma_descq_head;\n\tswtail = ppd->sdma_descq_tail;\n\tcnt = ppd->sdma_descq_cnt;\n\n\tif (swhead < swtail) {\n\t\t \n\t\tsane = (hwhead >= swhead) & (hwhead <= swtail);\n\t} else if (swhead > swtail) {\n\t\t \n\t\tsane = ((hwhead >= swhead) && (hwhead < cnt)) ||\n\t\t\t(hwhead <= swtail);\n\t} else {\n\t\t \n\t\tsane = (hwhead == swhead);\n\t}\n\n\tif (unlikely(!sane)) {\n\t\tif (use_dmahead) {\n\t\t\t \n\t\t\tuse_dmahead = 0;\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\thwhead = swhead;\n\t}\n\n\treturn hwhead;\n}\n\nstatic int qib_sdma_7220_busy(struct qib_pportdata *ppd)\n{\n\tu64 hwstatus = qib_read_kreg64(ppd->dd, kr_senddmastatus);\n\n\treturn (hwstatus & SYM_MASK(SendDmaStatus, ScoreBoardDrainInProg)) ||\n\t       (hwstatus & SYM_MASK(SendDmaStatus, AbortInProg)) ||\n\t       (hwstatus & SYM_MASK(SendDmaStatus, InternalSDmaEnable)) ||\n\t       !(hwstatus & SYM_MASK(SendDmaStatus, ScbEmpty));\n}\n\n \nstatic u32 qib_7220_setpbc_control(struct qib_pportdata *ppd, u32 plen,\n\t\t\t\t   u8 srate, u8 vl)\n{\n\tu8 snd_mult = ppd->delay_mult;\n\tu8 rcv_mult = ib_rate_to_delay[srate];\n\tu32 ret = ppd->cpspec->last_delay_mult;\n\n\tppd->cpspec->last_delay_mult = (rcv_mult > snd_mult) ?\n\t\t(plen * (rcv_mult - snd_mult) + 1) >> 1 : 0;\n\n\t \n\tif (vl == 15)\n\t\tret |= PBC_7220_VL15_SEND_CTRL;\n\treturn ret;\n}\n\nstatic void qib_7220_initvl15_bufs(struct qib_devdata *dd)\n{\n}\n\nstatic void qib_7220_init_ctxt(struct qib_ctxtdata *rcd)\n{\n\tif (!rcd->ctxt) {\n\t\trcd->rcvegrcnt = IBA7220_KRCVEGRCNT;\n\t\trcd->rcvegr_tid_base = 0;\n\t} else {\n\t\trcd->rcvegrcnt = rcd->dd->cspec->rcvegrcnt;\n\t\trcd->rcvegr_tid_base = IBA7220_KRCVEGRCNT +\n\t\t\t(rcd->ctxt - 1) * rcd->rcvegrcnt;\n\t}\n}\n\nstatic void qib_7220_txchk_change(struct qib_devdata *dd, u32 start,\n\t\t\t\t  u32 len, u32 which, struct qib_ctxtdata *rcd)\n{\n\tint i;\n\tunsigned long flags;\n\n\tswitch (which) {\n\tcase TXCHK_CHG_TYPE_KERN:\n\t\t \n\t\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\t\tfor (i = dd->first_user_ctxt;\n\t\t     dd->cspec->updthresh != dd->cspec->updthresh_dflt\n\t\t     && i < dd->cfgctxts; i++)\n\t\t\tif (dd->rcd[i] && dd->rcd[i]->subctxt_cnt &&\n\t\t\t   ((dd->rcd[i]->piocnt / dd->rcd[i]->subctxt_cnt) - 1)\n\t\t\t   < dd->cspec->updthresh_dflt)\n\t\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\t\tif (i == dd->cfgctxts) {\n\t\t\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\t\t\tdd->cspec->updthresh = dd->cspec->updthresh_dflt;\n\t\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, AvailUpdThld);\n\t\t\tdd->sendctrl |= (dd->cspec->updthresh &\n\t\t\t\t\t SYM_RMASK(SendCtrl, AvailUpdThld)) <<\n\t\t\t\t\t   SYM_LSB(SendCtrl, AvailUpdThld);\n\t\t\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\t\t\tsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\t\t}\n\t\tbreak;\n\tcase TXCHK_CHG_TYPE_USER:\n\t\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\t\tif (rcd && rcd->subctxt_cnt && ((rcd->piocnt\n\t\t\t/ rcd->subctxt_cnt) - 1) < dd->cspec->updthresh) {\n\t\t\tdd->cspec->updthresh = (rcd->piocnt /\n\t\t\t\t\t\trcd->subctxt_cnt) - 1;\n\t\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, AvailUpdThld);\n\t\t\tdd->sendctrl |= (dd->cspec->updthresh &\n\t\t\t\t\tSYM_RMASK(SendCtrl, AvailUpdThld))\n\t\t\t\t\t<< SYM_LSB(SendCtrl, AvailUpdThld);\n\t\t\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\t\t\tsendctrl_7220_mod(dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\t\t} else\n\t\t\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\t\tbreak;\n\t}\n}\n\nstatic void writescratch(struct qib_devdata *dd, u32 val)\n{\n\tqib_write_kreg(dd, kr_scratch, val);\n}\n\n#define VALID_TS_RD_REG_MASK 0xBF\n \nstatic int qib_7220_tempsense_rd(struct qib_devdata *dd, int regnum)\n{\n\tint ret;\n\tu8 rdata;\n\n\tif (regnum > 7) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\t \n\tif (!((1 << regnum) & VALID_TS_RD_REG_MASK)) {\n\t\tret = 0;\n\t\tgoto bail;\n\t}\n\n\tret = mutex_lock_interruptible(&dd->eep_lock);\n\tif (ret)\n\t\tgoto bail;\n\n\tret = qib_twsi_blk_rd(dd, QIB_TWSI_TEMP_DEV, regnum, &rdata, 1);\n\tif (!ret)\n\t\tret = rdata;\n\n\tmutex_unlock(&dd->eep_lock);\n\n\t \nbail:\n\treturn ret;\n}\n\n#ifdef CONFIG_INFINIBAND_QIB_DCA\nstatic int qib_7220_notify_dca(struct qib_devdata *dd, unsigned long event)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int qib_7220_eeprom_wen(struct qib_devdata *dd, int wen)\n{\n\treturn 1;\n}\n\n \nstruct qib_devdata *qib_init_iba7220_funcs(struct pci_dev *pdev,\n\t\t\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct qib_devdata *dd;\n\tint ret;\n\tu32 boardid, minwidth;\n\n\tdd = qib_alloc_devdata(pdev, sizeof(struct qib_chip_specific) +\n\t\tsizeof(struct qib_chippport_specific));\n\tif (IS_ERR(dd))\n\t\tgoto bail;\n\n\tdd->f_bringup_serdes    = qib_7220_bringup_serdes;\n\tdd->f_cleanup           = qib_setup_7220_cleanup;\n\tdd->f_clear_tids        = qib_7220_clear_tids;\n\tdd->f_free_irq          = qib_free_irq;\n\tdd->f_get_base_info     = qib_7220_get_base_info;\n\tdd->f_get_msgheader     = qib_7220_get_msgheader;\n\tdd->f_getsendbuf        = qib_7220_getsendbuf;\n\tdd->f_gpio_mod          = gpio_7220_mod;\n\tdd->f_eeprom_wen        = qib_7220_eeprom_wen;\n\tdd->f_hdrqempty         = qib_7220_hdrqempty;\n\tdd->f_ib_updown         = qib_7220_ib_updown;\n\tdd->f_init_ctxt         = qib_7220_init_ctxt;\n\tdd->f_initvl15_bufs     = qib_7220_initvl15_bufs;\n\tdd->f_intr_fallback     = qib_7220_intr_fallback;\n\tdd->f_late_initreg      = qib_late_7220_initreg;\n\tdd->f_setpbc_control    = qib_7220_setpbc_control;\n\tdd->f_portcntr          = qib_portcntr_7220;\n\tdd->f_put_tid           = qib_7220_put_tid;\n\tdd->f_quiet_serdes      = qib_7220_quiet_serdes;\n\tdd->f_rcvctrl           = rcvctrl_7220_mod;\n\tdd->f_read_cntrs        = qib_read_7220cntrs;\n\tdd->f_read_portcntrs    = qib_read_7220portcntrs;\n\tdd->f_reset             = qib_setup_7220_reset;\n\tdd->f_init_sdma_regs    = init_sdma_7220_regs;\n\tdd->f_sdma_busy         = qib_sdma_7220_busy;\n\tdd->f_sdma_gethead      = qib_sdma_7220_gethead;\n\tdd->f_sdma_sendctrl     = qib_7220_sdma_sendctrl;\n\tdd->f_sdma_set_desc_cnt = qib_sdma_set_7220_desc_cnt;\n\tdd->f_sdma_update_tail  = qib_sdma_update_7220_tail;\n\tdd->f_sdma_hw_clean_up  = qib_7220_sdma_hw_clean_up;\n\tdd->f_sdma_hw_start_up  = qib_7220_sdma_hw_start_up;\n\tdd->f_sdma_init_early   = qib_7220_sdma_init_early;\n\tdd->f_sendctrl          = sendctrl_7220_mod;\n\tdd->f_set_armlaunch     = qib_set_7220_armlaunch;\n\tdd->f_set_cntr_sample   = qib_set_cntr_7220_sample;\n\tdd->f_iblink_state      = qib_7220_iblink_state;\n\tdd->f_ibphys_portstate  = qib_7220_phys_portstate;\n\tdd->f_get_ib_cfg        = qib_7220_get_ib_cfg;\n\tdd->f_set_ib_cfg        = qib_7220_set_ib_cfg;\n\tdd->f_set_ib_loopback   = qib_7220_set_loopback;\n\tdd->f_set_intr_state    = qib_7220_set_intr_state;\n\tdd->f_setextled         = qib_setup_7220_setextled;\n\tdd->f_txchk_change      = qib_7220_txchk_change;\n\tdd->f_update_usrhead    = qib_update_7220_usrhead;\n\tdd->f_wantpiobuf_intr   = qib_wantpiobuf_7220_intr;\n\tdd->f_xgxs_reset        = qib_7220_xgxs_reset;\n\tdd->f_writescratch      = writescratch;\n\tdd->f_tempsense_rd\t= qib_7220_tempsense_rd;\n#ifdef CONFIG_INFINIBAND_QIB_DCA\n\tdd->f_notify_dca = qib_7220_notify_dca;\n#endif\n\t \n\tret = qib_pcie_ddinit(dd, pdev, ent);\n\tif (ret < 0)\n\t\tgoto bail_free;\n\n\t \n\tret = qib_init_7220_variables(dd);\n\tif (ret)\n\t\tgoto bail_cleanup;\n\n\tif (qib_mini_init)\n\t\tgoto bail;\n\n\tboardid = SYM_FIELD(dd->revision, Revision,\n\t\t\t    BoardID);\n\tswitch (boardid) {\n\tcase 0:\n\tcase 2:\n\tcase 10:\n\tcase 12:\n\t\tminwidth = 16;  \n\t\tbreak;\n\tdefault:\n\t\tminwidth = 8;  \n\t\tbreak;\n\t}\n\tif (qib_pcie_params(dd, minwidth, NULL))\n\t\tqib_dev_err(dd,\n\t\t\t\"Failed to setup PCIe or interrupts; continuing anyway\\n\");\n\n\tif (qib_read_kreg64(dd, kr_hwerrstatus) &\n\t    QLOGIC_IB_HWE_SERDESPLLFAILED)\n\t\tqib_write_kreg(dd, kr_hwerrclear,\n\t\t\t       QLOGIC_IB_HWE_SERDESPLLFAILED);\n\n\t \n\tqib_setup_7220_interrupt(dd);\n\tqib_7220_init_hwerrors(dd);\n\n\t \n\tqib_write_kreg(dd, kr_hwdiagctrl, 0);\n\n\tgoto bail;\n\nbail_cleanup:\n\tqib_pcie_ddcleanup(dd);\nbail_free:\n\tqib_free_devdata(dd);\n\tdd = ERR_PTR(ret);\nbail:\n\treturn dd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}