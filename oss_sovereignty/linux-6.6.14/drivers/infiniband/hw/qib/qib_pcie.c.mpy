{
  "module_name": "qib_pcie.c",
  "hash_id": "eea3201bcb116831541d21465aba4b711fda06dab07afe4d5605dca6af082fca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_pcie.c",
  "human_readable_source": " \n\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n\n#include \"qib.h\"\n\n \n\n \nstatic void qib_tune_pcie_caps(struct qib_devdata *);\nstatic void qib_tune_pcie_coalesce(struct qib_devdata *);\n\n \nint qib_pcie_init(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\t \n\t\tqib_early_err(&pdev->dev, \"pci enable failed: error %d\\n\",\n\t\t\t      -ret);\n\t\tgoto done;\n\t}\n\n\tret = pci_request_regions(pdev, QIB_DRV_NAME);\n\tif (ret) {\n\t\tqib_devinfo(pdev, \"pci_request_regions fails: err %d\\n\", -ret);\n\t\tgoto bail;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret) {\n\t\t \n\t\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (ret) {\n\t\t\tqib_devinfo(pdev, \"Unable to set DMA mask: %d\\n\", ret);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tpci_set_master(pdev);\n\tgoto done;\n\nbail:\n\tpci_disable_device(pdev);\n\tpci_release_regions(pdev);\ndone:\n\treturn ret;\n}\n\n \nint qib_pcie_ddinit(struct qib_devdata *dd, struct pci_dev *pdev,\n\t\t    const struct pci_device_id *ent)\n{\n\tunsigned long len;\n\tresource_size_t addr;\n\n\tdd->pcidev = pdev;\n\tpci_set_drvdata(pdev, dd);\n\n\taddr = pci_resource_start(pdev, 0);\n\tlen = pci_resource_len(pdev, 0);\n\n\tdd->kregbase = ioremap(addr, len);\n\tif (!dd->kregbase)\n\t\treturn -ENOMEM;\n\n\tdd->kregend = (u64 __iomem *)((void __iomem *) dd->kregbase + len);\n\tdd->physaddr = addr;         \n\n\t \n\tdd->pcibar0 = addr;\n\tdd->pcibar1 = addr >> 32;\n\tdd->deviceid = ent->device;  \n\tdd->vendorid = ent->vendor;\n\n\treturn 0;\n}\n\n \nvoid qib_pcie_ddcleanup(struct qib_devdata *dd)\n{\n\tu64 __iomem *base = (void __iomem *) dd->kregbase;\n\n\tdd->kregbase = NULL;\n\tiounmap(base);\n\tif (dd->piobase)\n\t\tiounmap(dd->piobase);\n\tif (dd->userbase)\n\t\tiounmap(dd->userbase);\n\tif (dd->piovl15base)\n\t\tiounmap(dd->piovl15base);\n\n\tpci_disable_device(dd->pcidev);\n\tpci_release_regions(dd->pcidev);\n\n\tpci_set_drvdata(dd->pcidev, NULL);\n}\n\n \nstatic void qib_cache_msi_info(struct qib_devdata *dd, int pos)\n{\n\tstruct pci_dev *pdev = dd->pcidev;\n\tu16 control;\n\n\tpci_read_config_dword(pdev, pos + PCI_MSI_ADDRESS_LO, &dd->msi_lo);\n\tpci_read_config_dword(pdev, pos + PCI_MSI_ADDRESS_HI, &dd->msi_hi);\n\tpci_read_config_word(pdev, pos + PCI_MSI_FLAGS, &control);\n\n\t \n\tpci_read_config_word(pdev,\n\t\t\t     pos + ((control & PCI_MSI_FLAGS_64BIT) ? 12 : 8),\n\t\t\t     &dd->msi_data);\n}\n\nint qib_pcie_params(struct qib_devdata *dd, u32 minw, u32 *nent)\n{\n\tu16 linkstat, speed;\n\tint nvec;\n\tint maxvec;\n\tunsigned int flags = PCI_IRQ_MSIX | PCI_IRQ_MSI;\n\n\tif (!pci_is_pcie(dd->pcidev)) {\n\t\tqib_dev_err(dd, \"Can't find PCI Express capability!\\n\");\n\t\t \n\t\tdd->lbus_width = 1;\n\t\tdd->lbus_speed = 2500;  \n\t\tnvec = -1;\n\t\tgoto bail;\n\t}\n\n\tif (dd->flags & QIB_HAS_INTX)\n\t\tflags |= PCI_IRQ_LEGACY;\n\tmaxvec = (nent && *nent) ? *nent : 1;\n\tnvec = pci_alloc_irq_vectors(dd->pcidev, 1, maxvec, flags);\n\tif (nvec < 0)\n\t\tgoto bail;\n\n\t \n\tif (nent)\n\t\t*nent = !dd->pcidev->msix_enabled ? 0 : nvec;\n\n\tif (dd->pcidev->msi_enabled)\n\t\tqib_cache_msi_info(dd, dd->pcidev->msi_cap);\n\n\tpcie_capability_read_word(dd->pcidev, PCI_EXP_LNKSTA, &linkstat);\n\t \n\tspeed = linkstat & 0xf;\n\tlinkstat >>= 4;\n\tlinkstat &= 0x1f;\n\tdd->lbus_width = linkstat;\n\n\tswitch (speed) {\n\tcase 1:\n\t\tdd->lbus_speed = 2500;  \n\t\tbreak;\n\tcase 2:\n\t\tdd->lbus_speed = 5000;  \n\t\tbreak;\n\tdefault:  \n\t\tdd->lbus_speed = 2500;\n\t\tbreak;\n\t}\n\n\t \n\tif (minw && linkstat < minw)\n\t\tqib_dev_err(dd,\n\t\t\t    \"PCIe width %u (x%u HCA), performance reduced\\n\",\n\t\t\t    linkstat, minw);\n\n\tqib_tune_pcie_caps(dd);\n\n\tqib_tune_pcie_coalesce(dd);\n\nbail:\n\t \n\tsnprintf(dd->lbus_info, sizeof(dd->lbus_info),\n\t\t \"PCIe,%uMHz,x%u\\n\", dd->lbus_speed, dd->lbus_width);\n\treturn nvec < 0 ? nvec : 0;\n}\n\n \nvoid qib_free_irq(struct qib_devdata *dd)\n{\n\tpci_free_irq(dd->pcidev, 0, dd);\n\tpci_free_irq_vectors(dd->pcidev);\n}\n\n \nint qib_reinit_intr(struct qib_devdata *dd)\n{\n\tint pos;\n\tu16 control;\n\tint ret = 0;\n\n\t \n\tif (!dd->msi_lo)\n\t\tgoto bail;\n\n\tpos = dd->pcidev->msi_cap;\n\tif (!pos) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Can't find MSI capability, can't restore MSI settings\\n\");\n\t\tret = 0;\n\t\t \n\t\tgoto bail;\n\t}\n\tpci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_LO,\n\t\t\t       dd->msi_lo);\n\tpci_write_config_dword(dd->pcidev, pos + PCI_MSI_ADDRESS_HI,\n\t\t\t       dd->msi_hi);\n\tpci_read_config_word(dd->pcidev, pos + PCI_MSI_FLAGS, &control);\n\tif (!(control & PCI_MSI_FLAGS_ENABLE)) {\n\t\tcontrol |= PCI_MSI_FLAGS_ENABLE;\n\t\tpci_write_config_word(dd->pcidev, pos + PCI_MSI_FLAGS,\n\t\t\t\t      control);\n\t}\n\t \n\tpci_write_config_word(dd->pcidev, pos +\n\t\t\t      ((control & PCI_MSI_FLAGS_64BIT) ? 12 : 8),\n\t\t\t      dd->msi_data);\n\tret = 1;\nbail:\n\tqib_free_irq(dd);\n\n\tif (!ret && (dd->flags & QIB_HAS_INTX))\n\t\tret = 1;\n\n\t \n\tpci_set_master(dd->pcidev);\n\n\treturn ret;\n}\n\n \nvoid qib_pcie_getcmd(struct qib_devdata *dd, u16 *cmd, u8 *iline, u8 *cline)\n{\n\tpci_read_config_word(dd->pcidev, PCI_COMMAND, cmd);\n\tpci_read_config_byte(dd->pcidev, PCI_INTERRUPT_LINE, iline);\n\tpci_read_config_byte(dd->pcidev, PCI_CACHE_LINE_SIZE, cline);\n}\n\nvoid qib_pcie_reenable(struct qib_devdata *dd, u16 cmd, u8 iline, u8 cline)\n{\n\tint r;\n\n\tr = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_0,\n\t\t\t\t   dd->pcibar0);\n\tif (r)\n\t\tqib_dev_err(dd, \"rewrite of BAR0 failed: %d\\n\", r);\n\tr = pci_write_config_dword(dd->pcidev, PCI_BASE_ADDRESS_1,\n\t\t\t\t   dd->pcibar1);\n\tif (r)\n\t\tqib_dev_err(dd, \"rewrite of BAR1 failed: %d\\n\", r);\n\t \n\tpci_write_config_word(dd->pcidev, PCI_COMMAND, cmd);\n\tpci_write_config_byte(dd->pcidev, PCI_INTERRUPT_LINE, iline);\n\tpci_write_config_byte(dd->pcidev, PCI_CACHE_LINE_SIZE, cline);\n\tr = pci_enable_device(dd->pcidev);\n\tif (r)\n\t\tqib_dev_err(dd,\n\t\t\t\"pci_enable_device failed after reset: %d\\n\", r);\n}\n\n\nstatic int qib_pcie_coalesce;\nmodule_param_named(pcie_coalesce, qib_pcie_coalesce, int, S_IRUGO);\nMODULE_PARM_DESC(pcie_coalesce, \"tune PCIe coalescing on some Intel chipsets\");\n\n \nstatic void qib_tune_pcie_coalesce(struct qib_devdata *dd)\n{\n\tstruct pci_dev *parent;\n\tu16 devid;\n\tu32 mask, bits, val;\n\n\tif (!qib_pcie_coalesce)\n\t\treturn;\n\n\t \n\tparent = dd->pcidev->bus->self;\n\tif (parent->bus->parent) {\n\t\tqib_devinfo(dd->pcidev, \"Parent not root\\n\");\n\t\treturn;\n\t}\n\tif (!pci_is_pcie(parent))\n\t\treturn;\n\tif (parent->vendor != 0x8086)\n\t\treturn;\n\n\t \n\tdevid = parent->device;\n\tif (devid >= 0x25e2 && devid <= 0x25fa) {\n\t\t \n\t\tif (parent->revision <= 0xb2)\n\t\t\tbits = 1U << 10;\n\t\telse\n\t\t\tbits = 7U << 10;\n\t\tmask = (3U << 24) | (7U << 10);\n\t} else if (devid >= 0x65e2 && devid <= 0x65fa) {\n\t\t \n\t\tbits = 1U << 10;\n\t\tmask = (3U << 24) | (7U << 10);\n\t} else if (devid >= 0x4021 && devid <= 0x402e) {\n\t\t \n\t\tbits = 7U << 10;\n\t\tmask = 7U << 10;\n\t} else if (devid >= 0x3604 && devid <= 0x360a) {\n\t\t \n\t\tbits = 7U << 10;\n\t\tmask = (3U << 24) | (7U << 10);\n\t} else {\n\t\t \n\t\treturn;\n\t}\n\tpci_read_config_dword(parent, 0x48, &val);\n\tval &= ~mask;\n\tval |= bits;\n\tpci_write_config_dword(parent, 0x48, val);\n}\n\n \nstatic int qib_pcie_caps;\nmodule_param_named(pcie_caps, qib_pcie_caps, int, S_IRUGO);\nMODULE_PARM_DESC(pcie_caps, \"Max PCIe tuning: Payload (0..3), ReadReq (4..7)\");\n\nstatic void qib_tune_pcie_caps(struct qib_devdata *dd)\n{\n\tstruct pci_dev *parent;\n\tu16 rc_mpss, rc_mps, ep_mpss, ep_mps;\n\tu16 rc_mrrs, ep_mrrs, max_mrrs;\n\n\t \n\tparent = dd->pcidev->bus->self;\n\tif (!pci_is_root_bus(parent->bus)) {\n\t\tqib_devinfo(dd->pcidev, \"Parent not root\\n\");\n\t\treturn;\n\t}\n\n\tif (!pci_is_pcie(parent) || !pci_is_pcie(dd->pcidev))\n\t\treturn;\n\n\trc_mpss = parent->pcie_mpss;\n\trc_mps = ffs(pcie_get_mps(parent)) - 8;\n\t \n\tep_mpss = dd->pcidev->pcie_mpss;\n\tep_mps = ffs(pcie_get_mps(dd->pcidev)) - 8;\n\n\t \n\tif (rc_mpss > ep_mpss)\n\t\trc_mpss = ep_mpss;\n\n\t \n\tif (rc_mpss > (qib_pcie_caps & 7))\n\t\trc_mpss = qib_pcie_caps & 7;\n\t \n\tif (rc_mpss > rc_mps) {\n\t\trc_mps = rc_mpss;\n\t\tpcie_set_mps(parent, 128 << rc_mps);\n\t}\n\t \n\tif (rc_mpss > ep_mps) {\n\t\tep_mps = rc_mpss;\n\t\tpcie_set_mps(dd->pcidev, 128 << ep_mps);\n\t}\n\n\t \n\tmax_mrrs = 5;\n\tif (max_mrrs > ((qib_pcie_caps >> 4) & 7))\n\t\tmax_mrrs = (qib_pcie_caps >> 4) & 7;\n\n\tmax_mrrs = 128 << max_mrrs;\n\trc_mrrs = pcie_get_readrq(parent);\n\tep_mrrs = pcie_get_readrq(dd->pcidev);\n\n\tif (max_mrrs > rc_mrrs) {\n\t\trc_mrrs = max_mrrs;\n\t\tpcie_set_readrq(parent, rc_mrrs);\n\t}\n\tif (max_mrrs > ep_mrrs) {\n\t\tep_mrrs = max_mrrs;\n\t\tpcie_set_readrq(dd->pcidev, ep_mrrs);\n\t}\n}\n \n\n \nstatic pci_ers_result_t\nqib_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)\n{\n\tstruct qib_devdata *dd = pci_get_drvdata(pdev);\n\tpci_ers_result_t ret = PCI_ERS_RESULT_RECOVERED;\n\n\tswitch (state) {\n\tcase pci_channel_io_normal:\n\t\tqib_devinfo(pdev, \"State Normal, ignoring\\n\");\n\t\tbreak;\n\n\tcase pci_channel_io_frozen:\n\t\tqib_devinfo(pdev, \"State Frozen, requesting reset\\n\");\n\t\tpci_disable_device(pdev);\n\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t\tbreak;\n\n\tcase pci_channel_io_perm_failure:\n\t\tqib_devinfo(pdev, \"State Permanent Failure, disabling\\n\");\n\t\tif (dd) {\n\t\t\t \n\t\t\tdd->flags &= ~QIB_PRESENT;\n\t\t\tqib_disable_after_error(dd);\n\t\t}\n\t\t  \n\t\tret =  PCI_ERS_RESULT_DISCONNECT;\n\t\tbreak;\n\n\tdefault:  \n\t\tqib_devinfo(pdev, \"QIB PCI errors detected (state %d)\\n\",\n\t\t\tstate);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic pci_ers_result_t\nqib_pci_mmio_enabled(struct pci_dev *pdev)\n{\n\tu64 words = 0U;\n\tstruct qib_devdata *dd = pci_get_drvdata(pdev);\n\tpci_ers_result_t ret = PCI_ERS_RESULT_RECOVERED;\n\n\tif (dd && dd->pport) {\n\t\twords = dd->f_portcntr(dd->pport, QIBPORTCNTR_WORDRCV);\n\t\tif (words == ~0ULL)\n\t\t\tret = PCI_ERS_RESULT_NEED_RESET;\n\t}\n\tqib_devinfo(pdev,\n\t\t\"QIB mmio_enabled function called, read wordscntr %Lx, returning %d\\n\",\n\t\twords, ret);\n\treturn  ret;\n}\n\nstatic pci_ers_result_t\nqib_pci_slot_reset(struct pci_dev *pdev)\n{\n\tqib_devinfo(pdev, \"QIB slot_reset function called, ignored\\n\");\n\treturn PCI_ERS_RESULT_CAN_RECOVER;\n}\n\nstatic void\nqib_pci_resume(struct pci_dev *pdev)\n{\n\tstruct qib_devdata *dd = pci_get_drvdata(pdev);\n\n\tqib_devinfo(pdev, \"QIB resume function called\\n\");\n\t \n\tqib_init(dd, 1);  \n}\n\nconst struct pci_error_handlers qib_pci_err_handler = {\n\t.error_detected = qib_pci_error_detected,\n\t.mmio_enabled = qib_pci_mmio_enabled,\n\t.slot_reset = qib_pci_slot_reset,\n\t.resume = qib_pci_resume,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}