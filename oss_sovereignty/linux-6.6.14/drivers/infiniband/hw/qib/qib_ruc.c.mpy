{
  "module_name": "qib_ruc.c",
  "hash_id": "fed433ac6ce3f4d81a5350a52e575c244b8f3613f0c8002a19ad449af0f5cb10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_ruc.c",
  "human_readable_source": " \n\n#include <linux/spinlock.h>\n#include <rdma/ib_smi.h>\n\n#include \"qib.h\"\n#include \"qib_mad.h\"\n\n \nvoid qib_migrate_qp(struct rvt_qp *qp)\n{\n\tstruct ib_event ev;\n\n\tqp->s_mig_state = IB_MIG_MIGRATED;\n\tqp->remote_ah_attr = qp->alt_ah_attr;\n\tqp->port_num = rdma_ah_get_port_num(&qp->alt_ah_attr);\n\tqp->s_pkey_index = qp->s_alt_pkey_index;\n\n\tev.device = qp->ibqp.device;\n\tev.element.qp = &qp->ibqp;\n\tev.event = IB_EVENT_PATH_MIG;\n\tqp->ibqp.event_handler(&ev, qp->ibqp.qp_context);\n}\n\nstatic __be64 get_sguid(struct qib_ibport *ibp, unsigned index)\n{\n\tif (!index) {\n\t\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\n\t\treturn ppd->guid;\n\t}\n\treturn ibp->guids[index - 1];\n}\n\nstatic int gid_ok(union ib_gid *gid, __be64 gid_prefix, __be64 id)\n{\n\treturn (gid->global.interface_id == id &&\n\t\t(gid->global.subnet_prefix == gid_prefix ||\n\t\t gid->global.subnet_prefix == IB_DEFAULT_GID_PREFIX));\n}\n\n \nint qib_ruc_check_hdr(struct qib_ibport *ibp, struct ib_header *hdr,\n\t\t      int has_grh, struct rvt_qp *qp, u32 bth0)\n{\n\t__be64 guid;\n\tunsigned long flags;\n\n\tif (qp->s_mig_state == IB_MIG_ARMED && (bth0 & IB_BTH_MIG_REQ)) {\n\t\tif (!has_grh) {\n\t\t\tif (rdma_ah_get_ah_flags(&qp->alt_ah_attr) &\n\t\t\t    IB_AH_GRH)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tconst struct ib_global_route *grh;\n\n\t\t\tif (!(rdma_ah_get_ah_flags(&qp->alt_ah_attr) &\n\t\t\t      IB_AH_GRH))\n\t\t\t\tgoto err;\n\t\t\tgrh = rdma_ah_read_grh(&qp->alt_ah_attr);\n\t\t\tguid = get_sguid(ibp, grh->sgid_index);\n\t\t\tif (!gid_ok(&hdr->u.l.grh.dgid,\n\t\t\t\t    ibp->rvp.gid_prefix, guid))\n\t\t\t\tgoto err;\n\t\t\tif (!gid_ok(&hdr->u.l.grh.sgid,\n\t\t\t    grh->dgid.global.subnet_prefix,\n\t\t\t    grh->dgid.global.interface_id))\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (!qib_pkey_ok((u16)bth0,\n\t\t\t\t qib_get_pkey(ibp, qp->s_alt_pkey_index))) {\n\t\t\tqib_bad_pkey(ibp,\n\t\t\t\t     (u16)bth0,\n\t\t\t\t     (be16_to_cpu(hdr->lrh[0]) >> 4) & 0xF,\n\t\t\t\t     0, qp->ibqp.qp_num,\n\t\t\t\t     hdr->lrh[3], hdr->lrh[1]);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tif ((be16_to_cpu(hdr->lrh[3]) !=\n\t\t     rdma_ah_get_dlid(&qp->alt_ah_attr)) ||\n\t\t    ppd_from_ibp(ibp)->port !=\n\t\t\t    rdma_ah_get_port_num(&qp->alt_ah_attr))\n\t\t\tgoto err;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tqib_migrate_qp(qp);\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t} else {\n\t\tif (!has_grh) {\n\t\t\tif (rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t\t    IB_AH_GRH)\n\t\t\t\tgoto err;\n\t\t} else {\n\t\t\tconst struct ib_global_route *grh;\n\n\t\t\tif (!(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t\t      IB_AH_GRH))\n\t\t\t\tgoto err;\n\t\t\tgrh = rdma_ah_read_grh(&qp->remote_ah_attr);\n\t\t\tguid = get_sguid(ibp, grh->sgid_index);\n\t\t\tif (!gid_ok(&hdr->u.l.grh.dgid,\n\t\t\t\t    ibp->rvp.gid_prefix, guid))\n\t\t\t\tgoto err;\n\t\t\tif (!gid_ok(&hdr->u.l.grh.sgid,\n\t\t\t    grh->dgid.global.subnet_prefix,\n\t\t\t    grh->dgid.global.interface_id))\n\t\t\t\tgoto err;\n\t\t}\n\t\tif (!qib_pkey_ok((u16)bth0,\n\t\t\t\t qib_get_pkey(ibp, qp->s_pkey_index))) {\n\t\t\tqib_bad_pkey(ibp,\n\t\t\t\t     (u16)bth0,\n\t\t\t\t     (be16_to_cpu(hdr->lrh[0]) >> 4) & 0xF,\n\t\t\t\t     0, qp->ibqp.qp_num,\n\t\t\t\t     hdr->lrh[3], hdr->lrh[1]);\n\t\t\tgoto err;\n\t\t}\n\t\t \n\t\tif (be16_to_cpu(hdr->lrh[3]) !=\n\t\t    rdma_ah_get_dlid(&qp->remote_ah_attr) ||\n\t\t    ppd_from_ibp(ibp)->port != qp->port_num)\n\t\t\tgoto err;\n\t\tif (qp->s_mig_state == IB_MIG_REARM &&\n\t\t    !(bth0 & IB_BTH_MIG_REQ))\n\t\t\tqp->s_mig_state = IB_MIG_ARMED;\n\t}\n\n\treturn 0;\n\nerr:\n\treturn 1;\n}\n\n \nu32 qib_make_grh(struct qib_ibport *ibp, struct ib_grh *hdr,\n\t\t const struct ib_global_route *grh, u32 hwords, u32 nwords)\n{\n\thdr->version_tclass_flow =\n\t\tcpu_to_be32((IB_GRH_VERSION << IB_GRH_VERSION_SHIFT) |\n\t\t\t    (grh->traffic_class << IB_GRH_TCLASS_SHIFT) |\n\t\t\t    (grh->flow_label << IB_GRH_FLOW_SHIFT));\n\thdr->paylen = cpu_to_be16((hwords - 2 + nwords + SIZE_OF_CRC) << 2);\n\t \n\thdr->next_hdr = IB_GRH_NEXT_HDR;\n\thdr->hop_limit = grh->hop_limit;\n\t \n\thdr->sgid.global.subnet_prefix = ibp->rvp.gid_prefix;\n\tif (!grh->sgid_index)\n\t\thdr->sgid.global.interface_id = ppd_from_ibp(ibp)->guid;\n\telse if (grh->sgid_index < QIB_GUIDS_PER_PORT)\n\t\thdr->sgid.global.interface_id = ibp->guids[grh->sgid_index - 1];\n\thdr->dgid = grh->dgid;\n\n\t \n\treturn sizeof(struct ib_grh) / sizeof(u32);\n}\n\nvoid qib_make_ruc_header(struct rvt_qp *qp, struct ib_other_headers *ohdr,\n\t\t\t u32 bth0, u32 bth2)\n{\n\tstruct qib_qp_priv *priv = qp->priv;\n\tstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tu16 lrh0;\n\tu32 nwords;\n\tu32 extra_bytes;\n\n\t \n\textra_bytes = -qp->s_cur_size & 3;\n\tnwords = (qp->s_cur_size + extra_bytes) >> 2;\n\tlrh0 = QIB_LRH_BTH;\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)) {\n\t\tqp->s_hdrwords +=\n\t\t\tqib_make_grh(ibp, &priv->s_hdr->u.l.grh,\n\t\t\t\t     rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t     qp->s_hdrwords, nwords);\n\t\tlrh0 = QIB_LRH_GRH;\n\t}\n\tlrh0 |= ibp->sl_to_vl[rdma_ah_get_sl(&qp->remote_ah_attr)] << 12 |\n\t\trdma_ah_get_sl(&qp->remote_ah_attr) << 4;\n\tpriv->s_hdr->lrh[0] = cpu_to_be16(lrh0);\n\tpriv->s_hdr->lrh[1] =\n\t\t\tcpu_to_be16(rdma_ah_get_dlid(&qp->remote_ah_attr));\n\tpriv->s_hdr->lrh[2] =\n\t\t\tcpu_to_be16(qp->s_hdrwords + nwords + SIZE_OF_CRC);\n\tpriv->s_hdr->lrh[3] =\n\t\tcpu_to_be16(ppd_from_ibp(ibp)->lid |\n\t\t\t    rdma_ah_get_path_bits(&qp->remote_ah_attr));\n\tbth0 |= qib_get_pkey(ibp, qp->s_pkey_index);\n\tbth0 |= extra_bytes << 20;\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth0 |= IB_BTH_MIG_REQ;\n\tohdr->bth[0] = cpu_to_be32(bth0);\n\tohdr->bth[1] = cpu_to_be32(qp->remote_qpn);\n\tohdr->bth[2] = cpu_to_be32(bth2);\n\tthis_cpu_inc(ibp->pmastats->n_unicast_xmit);\n}\n\nvoid _qib_do_send(struct work_struct *work)\n{\n\tstruct qib_qp_priv *priv = container_of(work, struct qib_qp_priv,\n\t\t\t\t\t\ts_work);\n\tstruct rvt_qp *qp = priv->owner;\n\n\tqib_do_send(qp);\n}\n\n \nvoid qib_do_send(struct rvt_qp *qp)\n{\n\tstruct qib_qp_priv *priv = qp->priv;\n\tstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tint (*make_req)(struct rvt_qp *qp, unsigned long *flags);\n\tunsigned long flags;\n\n\tif ((qp->ibqp.qp_type == IB_QPT_RC ||\n\t     qp->ibqp.qp_type == IB_QPT_UC) &&\n\t    (rdma_ah_get_dlid(&qp->remote_ah_attr) &\n\t     ~((1 << ppd->lmc) - 1)) == ppd->lid) {\n\t\trvt_ruc_loopback(qp);\n\t\treturn;\n\t}\n\n\tif (qp->ibqp.qp_type == IB_QPT_RC)\n\t\tmake_req = qib_make_rc_req;\n\telse if (qp->ibqp.qp_type == IB_QPT_UC)\n\t\tmake_req = qib_make_uc_req;\n\telse\n\t\tmake_req = qib_make_ud_req;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\n\t \n\tif (!qib_send_ok(qp)) {\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\treturn;\n\t}\n\n\tqp->s_flags |= RVT_S_BUSY;\n\n\tdo {\n\t\t \n\t\tif (qp->s_hdrwords != 0) {\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t\t \n\t\t\tif (qib_verbs_send(qp, priv->s_hdr, qp->s_hdrwords,\n\t\t\t\t\t   qp->s_cur_sge, qp->s_cur_size))\n\t\t\t\treturn;\n\t\t\t \n\t\t\tqp->s_hdrwords = 0;\n\t\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\t}\n\t} while (make_req(qp, &flags));\n\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}