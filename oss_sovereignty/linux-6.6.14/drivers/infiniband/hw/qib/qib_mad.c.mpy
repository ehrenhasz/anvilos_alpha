{
  "module_name": "qib_mad.c",
  "hash_id": "89e5df8270f3b01b29ad7271371f5443583430e5bd6bf898f76201335e764407",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_mad.c",
  "human_readable_source": " \n\n#include <rdma/ib_smi.h>\n\n#include \"qib.h\"\n#include \"qib_mad.h\"\n\nstatic int reply(struct ib_smp *smp)\n{\n\t \n\tsmp->method = IB_MGMT_METHOD_GET_RESP;\n\tif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\tsmp->status |= IB_SMP_DIRECTION;\n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n}\n\nstatic int reply_failure(struct ib_smp *smp)\n{\n\t \n\tsmp->method = IB_MGMT_METHOD_GET_RESP;\n\tif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\tsmp->status |= IB_SMP_DIRECTION;\n\treturn IB_MAD_RESULT_FAILURE | IB_MAD_RESULT_REPLY;\n}\n\nstatic void qib_send_trap(struct qib_ibport *ibp, void *data, unsigned len)\n{\n\tstruct ib_mad_send_buf *send_buf;\n\tstruct ib_mad_agent *agent;\n\tstruct ib_smp *smp;\n\tint ret;\n\tunsigned long flags;\n\tunsigned long timeout;\n\n\tagent = ibp->rvp.send_agent;\n\tif (!agent)\n\t\treturn;\n\n\t \n\tif (!(ppd_from_ibp(ibp)->lflags & QIBL_LINKACTIVE))\n\t\treturn;\n\n\t \n\tif (ibp->rvp.trap_timeout &&\n\t    time_before(jiffies, ibp->rvp.trap_timeout))\n\t\treturn;\n\n\tsend_buf = ib_create_send_mad(agent, 0, 0, 0, IB_MGMT_MAD_HDR,\n\t\t\t\t      IB_MGMT_MAD_DATA, GFP_ATOMIC,\n\t\t\t\t      IB_MGMT_BASE_VERSION);\n\tif (IS_ERR(send_buf))\n\t\treturn;\n\n\tsmp = send_buf->mad;\n\tsmp->base_version = IB_MGMT_BASE_VERSION;\n\tsmp->mgmt_class = IB_MGMT_CLASS_SUBN_LID_ROUTED;\n\tsmp->class_version = 1;\n\tsmp->method = IB_MGMT_METHOD_TRAP;\n\tibp->rvp.tid++;\n\tsmp->tid = cpu_to_be64(ibp->rvp.tid);\n\tsmp->attr_id = IB_SMP_ATTR_NOTICE;\n\t \n\tmemcpy(smp->data, data, len);\n\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\tif (!ibp->rvp.sm_ah) {\n\t\tif (ibp->rvp.sm_lid != be16_to_cpu(IB_LID_PERMISSIVE)) {\n\t\t\tstruct ib_ah *ah;\n\n\t\t\tah = qib_create_qp0_ah(ibp, (u16)ibp->rvp.sm_lid);\n\t\t\tif (IS_ERR(ah))\n\t\t\t\tret = PTR_ERR(ah);\n\t\t\telse {\n\t\t\t\tsend_buf->ah = ah;\n\t\t\t\tibp->rvp.sm_ah = ibah_to_rvtah(ah);\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t} else\n\t\t\tret = -EINVAL;\n\t} else {\n\t\tsend_buf->ah = &ibp->rvp.sm_ah->ibah;\n\t\tret = 0;\n\t}\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\n\tif (!ret)\n\t\tret = ib_post_send_mad(send_buf, NULL);\n\tif (!ret) {\n\t\t \n\t\ttimeout = (4096 * (1UL << ibp->rvp.subnet_timeout)) / 1000;\n\t\tibp->rvp.trap_timeout = jiffies + usecs_to_jiffies(timeout);\n\t} else {\n\t\tib_free_send_mad(send_buf);\n\t\tibp->rvp.trap_timeout = 0;\n\t}\n}\n\n \nvoid qib_bad_pkey(struct qib_ibport *ibp, u32 key, u32 sl,\n\t\t  u32 qp1, u32 qp2, __be16 lid1, __be16 lid2)\n{\n\tstruct ib_mad_notice_attr data;\n\n\tibp->rvp.n_pkt_drops++;\n\tibp->rvp.pkey_violations++;\n\n\t \n\tdata.generic_type = IB_NOTICE_TYPE_SECURITY;\n\tdata.prod_type_msb = 0;\n\tdata.prod_type_lsb = IB_NOTICE_PROD_CA;\n\tdata.trap_num = IB_NOTICE_TRAP_BAD_PKEY;\n\tdata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\n\tdata.toggle_count = 0;\n\tmemset(&data.details, 0, sizeof(data.details));\n\tdata.details.ntc_257_258.lid1 = lid1;\n\tdata.details.ntc_257_258.lid2 = lid2;\n\tdata.details.ntc_257_258.key = cpu_to_be32(key);\n\tdata.details.ntc_257_258.sl_qp1 = cpu_to_be32((sl << 28) | qp1);\n\tdata.details.ntc_257_258.qp2 = cpu_to_be32(qp2);\n\n\tqib_send_trap(ibp, &data, sizeof(data));\n}\n\n \nstatic void qib_bad_mkey(struct qib_ibport *ibp, struct ib_smp *smp)\n{\n\tstruct ib_mad_notice_attr data;\n\n\t \n\tdata.generic_type = IB_NOTICE_TYPE_SECURITY;\n\tdata.prod_type_msb = 0;\n\tdata.prod_type_lsb = IB_NOTICE_PROD_CA;\n\tdata.trap_num = IB_NOTICE_TRAP_BAD_MKEY;\n\tdata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\n\tdata.toggle_count = 0;\n\tmemset(&data.details, 0, sizeof(data.details));\n\tdata.details.ntc_256.lid = data.issuer_lid;\n\tdata.details.ntc_256.method = smp->method;\n\tdata.details.ntc_256.attr_id = smp->attr_id;\n\tdata.details.ntc_256.attr_mod = smp->attr_mod;\n\tdata.details.ntc_256.mkey = smp->mkey;\n\tif (smp->mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) {\n\t\tu8 hop_cnt;\n\n\t\tdata.details.ntc_256.dr_slid = smp->dr_slid;\n\t\tdata.details.ntc_256.dr_trunc_hop = IB_NOTICE_TRAP_DR_NOTICE;\n\t\thop_cnt = smp->hop_cnt;\n\t\tif (hop_cnt > ARRAY_SIZE(data.details.ntc_256.dr_rtn_path)) {\n\t\t\tdata.details.ntc_256.dr_trunc_hop |=\n\t\t\t\tIB_NOTICE_TRAP_DR_TRUNC;\n\t\t\thop_cnt = ARRAY_SIZE(data.details.ntc_256.dr_rtn_path);\n\t\t}\n\t\tdata.details.ntc_256.dr_trunc_hop |= hop_cnt;\n\t\tmemcpy(data.details.ntc_256.dr_rtn_path, smp->return_path,\n\t\t       hop_cnt);\n\t}\n\n\tqib_send_trap(ibp, &data, sizeof(data));\n}\n\n \nvoid qib_cap_mask_chg(struct rvt_dev_info *rdi, u32 port_num)\n{\n\tstruct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);\n\tstruct qib_devdata *dd = dd_from_dev(ibdev);\n\tstruct qib_ibport *ibp = &dd->pport[port_num - 1].ibport_data;\n\tstruct ib_mad_notice_attr data;\n\n\tdata.generic_type = IB_NOTICE_TYPE_INFO;\n\tdata.prod_type_msb = 0;\n\tdata.prod_type_lsb = IB_NOTICE_PROD_CA;\n\tdata.trap_num = IB_NOTICE_TRAP_CAP_MASK_CHG;\n\tdata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\n\tdata.toggle_count = 0;\n\tmemset(&data.details, 0, sizeof(data.details));\n\tdata.details.ntc_144.lid = data.issuer_lid;\n\tdata.details.ntc_144.new_cap_mask =\n\t\t\t\t\tcpu_to_be32(ibp->rvp.port_cap_flags);\n\tqib_send_trap(ibp, &data, sizeof(data));\n}\n\n \nvoid qib_sys_guid_chg(struct qib_ibport *ibp)\n{\n\tstruct ib_mad_notice_attr data;\n\n\tdata.generic_type = IB_NOTICE_TYPE_INFO;\n\tdata.prod_type_msb = 0;\n\tdata.prod_type_lsb = IB_NOTICE_PROD_CA;\n\tdata.trap_num = IB_NOTICE_TRAP_SYS_GUID_CHG;\n\tdata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\n\tdata.toggle_count = 0;\n\tmemset(&data.details, 0, sizeof(data.details));\n\tdata.details.ntc_145.lid = data.issuer_lid;\n\tdata.details.ntc_145.new_sys_guid = ib_qib_sys_image_guid;\n\n\tqib_send_trap(ibp, &data, sizeof(data));\n}\n\n \nvoid qib_node_desc_chg(struct qib_ibport *ibp)\n{\n\tstruct ib_mad_notice_attr data;\n\n\tdata.generic_type = IB_NOTICE_TYPE_INFO;\n\tdata.prod_type_msb = 0;\n\tdata.prod_type_lsb = IB_NOTICE_PROD_CA;\n\tdata.trap_num = IB_NOTICE_TRAP_CAP_MASK_CHG;\n\tdata.issuer_lid = cpu_to_be16(ppd_from_ibp(ibp)->lid);\n\tdata.toggle_count = 0;\n\tmemset(&data.details, 0, sizeof(data.details));\n\tdata.details.ntc_144.lid = data.issuer_lid;\n\tdata.details.ntc_144.local_changes = 1;\n\tdata.details.ntc_144.change_flags = IB_NOTICE_TRAP_NODE_DESC_CHG;\n\n\tqib_send_trap(ibp, &data, sizeof(data));\n}\n\nstatic int subn_get_nodedescription(struct ib_smp *smp,\n\t\t\t\t    struct ib_device *ibdev)\n{\n\tif (smp->attr_mod)\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\tmemcpy(smp->data, ibdev->node_desc, sizeof(smp->data));\n\n\treturn reply(smp);\n}\n\nstatic int subn_get_nodeinfo(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct ib_node_info *nip = (struct ib_node_info *)&smp->data;\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tu32 majrev, minrev;\n\tunsigned pidx = port - 1;  \n\n\t \n\tif (smp->attr_mod || pidx >= dd->num_pports ||\n\t    dd->pport[pidx].guid == 0)\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\telse\n\t\tnip->port_guid = dd->pport[pidx].guid;\n\n\tnip->base_version = 1;\n\tnip->class_version = 1;\n\tnip->node_type = 1;      \n\tnip->num_ports = ibdev->phys_port_cnt;\n\t \n\tnip->sys_guid = ib_qib_sys_image_guid;\n\tnip->node_guid = dd->pport->guid;  \n\tnip->partition_cap = cpu_to_be16(qib_get_npkeys(dd));\n\tnip->device_id = cpu_to_be16(dd->deviceid);\n\tmajrev = dd->majrev;\n\tminrev = dd->minrev;\n\tnip->revision = cpu_to_be32((majrev << 16) | minrev);\n\tnip->local_port_num = port;\n\tnip->vendor_id[0] = QIB_SRC_OUI_1;\n\tnip->vendor_id[1] = QIB_SRC_OUI_2;\n\tnip->vendor_id[2] = QIB_SRC_OUI_3;\n\n\treturn reply(smp);\n}\n\nstatic int subn_get_guidinfo(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tu32 startgx = 8 * be32_to_cpu(smp->attr_mod);\n\t__be64 *p = (__be64 *) smp->data;\n\tunsigned pidx = port - 1;  \n\n\t \n\n\tmemset(smp->data, 0, sizeof(smp->data));\n\n\tif (startgx == 0 && pidx < dd->num_pports) {\n\t\tstruct qib_pportdata *ppd = dd->pport + pidx;\n\t\tstruct qib_ibport *ibp = &ppd->ibport_data;\n\t\t__be64 g = ppd->guid;\n\t\tunsigned i;\n\n\t\t \n\t\tif (g == 0)\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\telse {\n\t\t\t \n\t\t\tp[0] = g;\n\t\t\tfor (i = 1; i < QIB_GUIDS_PER_PORT; i++)\n\t\t\t\tp[i] = ibp->guids[i - 1];\n\t\t}\n\t} else\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\treturn reply(smp);\n}\n\nstatic void set_link_width_enabled(struct qib_pportdata *ppd, u32 w)\n{\n\t(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LWID_ENB, w);\n}\n\nstatic void set_link_speed_enabled(struct qib_pportdata *ppd, u32 s)\n{\n\t(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_SPD_ENB, s);\n}\n\nstatic int get_overrunthreshold(struct qib_pportdata *ppd)\n{\n\treturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_OVERRUN_THRESH);\n}\n\n \nstatic int set_overrunthreshold(struct qib_pportdata *ppd, unsigned n)\n{\n\t(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_OVERRUN_THRESH,\n\t\t\t\t\t (u32)n);\n\treturn 0;\n}\n\nstatic int get_phyerrthreshold(struct qib_pportdata *ppd)\n{\n\treturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_PHYERR_THRESH);\n}\n\n \nstatic int set_phyerrthreshold(struct qib_pportdata *ppd, unsigned n)\n{\n\t(void) ppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PHYERR_THRESH,\n\t\t\t\t\t (u32)n);\n\treturn 0;\n}\n\n \nstatic int get_linkdowndefaultstate(struct qib_pportdata *ppd)\n{\n\treturn ppd->dd->f_get_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT) ==\n\t\tIB_LINKINITCMD_SLEEP;\n}\n\nstatic int check_mkey(struct qib_ibport *ibp, struct ib_smp *smp, int mad_flags)\n{\n\tint valid_mkey = 0;\n\tint ret = 0;\n\n\t \n\tif (ibp->rvp.mkey_lease_timeout &&\n\t    time_after_eq(jiffies, ibp->rvp.mkey_lease_timeout)) {\n\t\t \n\t\tibp->rvp.mkey_lease_timeout = 0;\n\t\tibp->rvp.mkeyprot = 0;\n\t}\n\n\tif ((mad_flags & IB_MAD_IGNORE_MKEY) ||  ibp->rvp.mkey == 0 ||\n\t    ibp->rvp.mkey == smp->mkey)\n\t\tvalid_mkey = 1;\n\n\t \n\tif (valid_mkey && ibp->rvp.mkey_lease_timeout &&\n\t    (smp->method == IB_MGMT_METHOD_GET ||\n\t     smp->method == IB_MGMT_METHOD_SET ||\n\t     smp->method == IB_MGMT_METHOD_TRAP_REPRESS))\n\t\tibp->rvp.mkey_lease_timeout = 0;\n\n\tif (!valid_mkey) {\n\t\tswitch (smp->method) {\n\t\tcase IB_MGMT_METHOD_GET:\n\t\t\t \n\t\t\tif (ibp->rvp.mkeyprot < 2)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase IB_MGMT_METHOD_SET:\n\t\tcase IB_MGMT_METHOD_TRAP_REPRESS:\n\t\t\tif (ibp->rvp.mkey_violations != 0xFFFF)\n\t\t\t\t++ibp->rvp.mkey_violations;\n\t\t\tif (!ibp->rvp.mkey_lease_timeout &&\n\t\t\t    ibp->rvp.mkey_lease_period)\n\t\t\t\tibp->rvp.mkey_lease_timeout = jiffies +\n\t\t\t\t\tibp->rvp.mkey_lease_period * HZ;\n\t\t\t \n\t\t\tqib_bad_mkey(ibp, smp);\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int subn_get_portinfo(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct qib_devdata *dd;\n\tstruct qib_pportdata *ppd;\n\tstruct qib_ibport *ibp;\n\tstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\n\tu8 mtu;\n\tint ret;\n\tu32 state;\n\tu32 port_num = be32_to_cpu(smp->attr_mod);\n\n\tif (port_num == 0)\n\t\tport_num = port;\n\telse {\n\t\tif (port_num > ibdev->phys_port_cnt) {\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\t\tret = reply(smp);\n\t\t\tgoto bail;\n\t\t}\n\t\tif (port_num != port) {\n\t\t\tibp = to_iport(ibdev, port_num);\n\t\t\tret = check_mkey(ibp, smp, 0);\n\t\t\tif (ret) {\n\t\t\t\tret = IB_MAD_RESULT_FAILURE;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t}\n\n\tdd = dd_from_ibdev(ibdev);\n\t \n\tppd = dd->pport + (port_num - 1);\n\tibp = &ppd->ibport_data;\n\n\t \n\tmemset(smp->data, 0, sizeof(smp->data));\n\n\t \n\tif (!(smp->method == IB_MGMT_METHOD_GET &&\n\t      ibp->rvp.mkey != smp->mkey &&\n\t      ibp->rvp.mkeyprot == 1))\n\t\tpip->mkey = ibp->rvp.mkey;\n\tpip->gid_prefix = ibp->rvp.gid_prefix;\n\tpip->lid = cpu_to_be16(ppd->lid);\n\tpip->sm_lid = cpu_to_be16((u16)ibp->rvp.sm_lid);\n\tpip->cap_mask = cpu_to_be32(ibp->rvp.port_cap_flags);\n\t \n\tpip->mkey_lease_period = cpu_to_be16(ibp->rvp.mkey_lease_period);\n\tpip->local_port_num = port;\n\tpip->link_width_enabled = ppd->link_width_enabled;\n\tpip->link_width_supported = ppd->link_width_supported;\n\tpip->link_width_active = ppd->link_width_active;\n\tstate = dd->f_iblink_state(ppd->lastibcstat);\n\tpip->linkspeed_portstate = ppd->link_speed_supported << 4 | state;\n\n\tpip->portphysstate_linkdown =\n\t\t(dd->f_ibphys_portstate(ppd->lastibcstat) << 4) |\n\t\t(get_linkdowndefaultstate(ppd) ? 1 : 2);\n\tpip->mkeyprot_resv_lmc = (ibp->rvp.mkeyprot << 6) | ppd->lmc;\n\tpip->linkspeedactive_enabled = (ppd->link_speed_active << 4) |\n\t\tppd->link_speed_enabled;\n\tswitch (ppd->ibmtu) {\n\tdefault:  \n\tcase 4096:\n\t\tmtu = IB_MTU_4096;\n\t\tbreak;\n\tcase 2048:\n\t\tmtu = IB_MTU_2048;\n\t\tbreak;\n\tcase 1024:\n\t\tmtu = IB_MTU_1024;\n\t\tbreak;\n\tcase 512:\n\t\tmtu = IB_MTU_512;\n\t\tbreak;\n\tcase 256:\n\t\tmtu = IB_MTU_256;\n\t\tbreak;\n\t}\n\tpip->neighbormtu_mastersmsl = (mtu << 4) | ibp->rvp.sm_sl;\n\tpip->vlcap_inittype = ppd->vls_supported << 4;   \n\tpip->vl_high_limit = ibp->rvp.vl_high_limit;\n\tpip->vl_arb_high_cap =\n\t\tdd->f_get_ib_cfg(ppd, QIB_IB_CFG_VL_HIGH_CAP);\n\tpip->vl_arb_low_cap =\n\t\tdd->f_get_ib_cfg(ppd, QIB_IB_CFG_VL_LOW_CAP);\n\t \n\tpip->inittypereply_mtucap = qib_ibmtu ? qib_ibmtu : IB_MTU_4096;\n\t \n\t \n\tpip->operationalvl_pei_peo_fpi_fpo =\n\t\tdd->f_get_ib_cfg(ppd, QIB_IB_CFG_OP_VLS) << 4;\n\tpip->mkey_violations = cpu_to_be16(ibp->rvp.mkey_violations);\n\t \n\tpip->pkey_violations = cpu_to_be16(ibp->rvp.pkey_violations);\n\tpip->qkey_violations = cpu_to_be16(ibp->rvp.qkey_violations);\n\t \n\tpip->guid_cap = QIB_GUIDS_PER_PORT;\n\tpip->clientrereg_resv_subnetto = ibp->rvp.subnet_timeout;\n\t \n\tpip->resv_resptimevalue = 3;\n\tpip->localphyerrors_overrunerrors =\n\t\t(get_phyerrthreshold(ppd) << 4) |\n\t\tget_overrunthreshold(ppd);\n\t \n\tif (ibp->rvp.port_cap_flags & IB_PORT_LINK_LATENCY_SUP) {\n\t\tu32 v;\n\n\t\tv = dd->f_get_ib_cfg(ppd, QIB_IB_CFG_LINKLATENCY);\n\t\tpip->link_roundtrip_latency[0] = v >> 16;\n\t\tpip->link_roundtrip_latency[1] = v >> 8;\n\t\tpip->link_roundtrip_latency[2] = v;\n\t}\n\n\tret = reply(smp);\n\nbail:\n\treturn ret;\n}\n\n \nstatic int get_pkeys(struct qib_devdata *dd, u8 port, u16 *pkeys)\n{\n\tstruct qib_pportdata *ppd = dd->pport + port - 1;\n\t \n\tstruct qib_ctxtdata *rcd = dd->rcd[ppd->hw_pidx];\n\n\tmemcpy(pkeys, rcd->pkeys, sizeof(rcd->pkeys));\n\n\treturn 0;\n}\n\nstatic int subn_get_pkeytable(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t      u8 port)\n{\n\tu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\n\tu16 *p = (u16 *) smp->data;\n\t__be16 *q = (__be16 *) smp->data;\n\n\t \n\n\tmemset(smp->data, 0, sizeof(smp->data));\n\tif (startpx == 0) {\n\t\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\t\tunsigned i, n = qib_get_npkeys(dd);\n\n\t\tget_pkeys(dd, port, p);\n\n\t\tfor (i = 0; i < n; i++)\n\t\t\tq[i] = cpu_to_be16(p[i]);\n\t} else\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\treturn reply(smp);\n}\n\nstatic int subn_set_guidinfo(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tu32 startgx = 8 * be32_to_cpu(smp->attr_mod);\n\t__be64 *p = (__be64 *) smp->data;\n\tunsigned pidx = port - 1;  \n\n\t \n\n\tif (startgx == 0 && pidx < dd->num_pports) {\n\t\tstruct qib_pportdata *ppd = dd->pport + pidx;\n\t\tstruct qib_ibport *ibp = &ppd->ibport_data;\n\t\tunsigned i;\n\n\t\t \n\t\tfor (i = 1; i < QIB_GUIDS_PER_PORT; i++)\n\t\t\tibp->guids[i - 1] = p[i];\n\t} else\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\t \n\treturn subn_get_guidinfo(smp, ibdev, port);\n}\n\n \nstatic int subn_set_portinfo(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct ib_port_info *pip = (struct ib_port_info *)smp->data;\n\tstruct ib_event event;\n\tstruct qib_devdata *dd;\n\tstruct qib_pportdata *ppd;\n\tstruct qib_ibport *ibp;\n\tu8 clientrereg = (pip->clientrereg_resv_subnetto & 0x80);\n\tunsigned long flags;\n\tu16 lid, smlid;\n\tu8 lwe;\n\tu8 lse;\n\tu8 state;\n\tu8 vls;\n\tu8 msl;\n\tu16 lstate;\n\tint ret, ore, mtu;\n\tu32 port_num = be32_to_cpu(smp->attr_mod);\n\n\tif (port_num == 0)\n\t\tport_num = port;\n\telse {\n\t\tif (port_num > ibdev->phys_port_cnt)\n\t\t\tgoto err;\n\t\t \n\t\tif (port_num != port)\n\t\t\tgoto get_only;\n\t}\n\n\tdd = dd_from_ibdev(ibdev);\n\t \n\tppd = dd->pport + (port_num - 1);\n\tibp = &ppd->ibport_data;\n\tevent.device = ibdev;\n\tevent.element.port_num = port;\n\n\tibp->rvp.mkey = pip->mkey;\n\tibp->rvp.gid_prefix = pip->gid_prefix;\n\tibp->rvp.mkey_lease_period = be16_to_cpu(pip->mkey_lease_period);\n\n\tlid = be16_to_cpu(pip->lid);\n\t \n\tif (lid == 0 || lid >= be16_to_cpu(IB_MULTICAST_LID_BASE))\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\telse if (ppd->lid != lid || ppd->lmc != (pip->mkeyprot_resv_lmc & 7)) {\n\t\tif (ppd->lid != lid)\n\t\t\tqib_set_uevent_bits(ppd, _QIB_EVENT_LID_CHANGE_BIT);\n\t\tif (ppd->lmc != (pip->mkeyprot_resv_lmc & 7))\n\t\t\tqib_set_uevent_bits(ppd, _QIB_EVENT_LMC_CHANGE_BIT);\n\t\tqib_set_lid(ppd, lid, pip->mkeyprot_resv_lmc & 7);\n\t\tevent.event = IB_EVENT_LID_CHANGE;\n\t\tib_dispatch_event(&event);\n\t}\n\n\tsmlid = be16_to_cpu(pip->sm_lid);\n\tmsl = pip->neighbormtu_mastersmsl & 0xF;\n\t \n\tif (smlid == 0 || smlid >= be16_to_cpu(IB_MULTICAST_LID_BASE))\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\telse if (smlid != ibp->rvp.sm_lid || msl != ibp->rvp.sm_sl) {\n\t\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\t\tif (ibp->rvp.sm_ah) {\n\t\t\tif (smlid != ibp->rvp.sm_lid)\n\t\t\t\trdma_ah_set_dlid(&ibp->rvp.sm_ah->attr,\n\t\t\t\t\t\t smlid);\n\t\t\tif (msl != ibp->rvp.sm_sl)\n\t\t\t\trdma_ah_set_sl(&ibp->rvp.sm_ah->attr, msl);\n\t\t}\n\t\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\t\tif (smlid != ibp->rvp.sm_lid)\n\t\t\tibp->rvp.sm_lid = smlid;\n\t\tif (msl != ibp->rvp.sm_sl)\n\t\t\tibp->rvp.sm_sl = msl;\n\t\tevent.event = IB_EVENT_SM_CHANGE;\n\t\tib_dispatch_event(&event);\n\t}\n\n\t \n\tlwe = pip->link_width_enabled;\n\tif (lwe) {\n\t\tif (lwe == 0xFF)\n\t\t\tset_link_width_enabled(ppd, ppd->link_width_supported);\n\t\telse if (lwe >= 16 || (lwe & ~ppd->link_width_supported))\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\telse if (lwe != ppd->link_width_enabled)\n\t\t\tset_link_width_enabled(ppd, lwe);\n\t}\n\n\tlse = pip->linkspeedactive_enabled & 0xF;\n\tif (lse) {\n\t\t \n\t\tif (lse == 15)\n\t\t\tset_link_speed_enabled(ppd,\n\t\t\t\t\t       ppd->link_speed_supported);\n\t\telse if (lse >= 8 || (lse & ~ppd->link_speed_supported))\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\telse if (lse != ppd->link_speed_enabled)\n\t\t\tset_link_speed_enabled(ppd, lse);\n\t}\n\n\t \n\tswitch (pip->portphysstate_linkdown & 0xF) {\n\tcase 0:  \n\t\tbreak;\n\tcase 1:  \n\t\t(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT,\n\t\t\t\t\tIB_LINKINITCMD_SLEEP);\n\t\tbreak;\n\tcase 2:  \n\t\t(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_LINKDEFAULT,\n\t\t\t\t\tIB_LINKINITCMD_POLL);\n\t\tbreak;\n\tdefault:\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t}\n\n\tibp->rvp.mkeyprot = pip->mkeyprot_resv_lmc >> 6;\n\tibp->rvp.vl_high_limit = pip->vl_high_limit;\n\t(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_VL_HIGH_LIMIT,\n\t\t\t\t    ibp->rvp.vl_high_limit);\n\n\tmtu = ib_mtu_enum_to_int((pip->neighbormtu_mastersmsl >> 4) & 0xF);\n\tif (mtu == -1)\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\telse\n\t\tqib_set_mtu(ppd, mtu);\n\n\t \n\tvls = (pip->operationalvl_pei_peo_fpi_fpo >> 4) & 0xF;\n\tif (vls) {\n\t\tif (vls > ppd->vls_supported)\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\telse\n\t\t\t(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_OP_VLS, vls);\n\t}\n\n\tif (pip->mkey_violations == 0)\n\t\tibp->rvp.mkey_violations = 0;\n\n\tif (pip->pkey_violations == 0)\n\t\tibp->rvp.pkey_violations = 0;\n\n\tif (pip->qkey_violations == 0)\n\t\tibp->rvp.qkey_violations = 0;\n\n\tore = pip->localphyerrors_overrunerrors;\n\tif (set_phyerrthreshold(ppd, (ore >> 4) & 0xF))\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\tif (set_overrunthreshold(ppd, (ore & 0xF)))\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\tibp->rvp.subnet_timeout = pip->clientrereg_resv_subnetto & 0x1F;\n\n\t \n\tstate = pip->linkspeed_portstate & 0xF;\n\tlstate = (pip->portphysstate_linkdown >> 4) & 0xF;\n\tif (lstate && !(state == IB_PORT_DOWN || state == IB_PORT_NOP))\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\t \n\tswitch (state) {\n\tcase IB_PORT_NOP:\n\t\tif (lstate == 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase IB_PORT_DOWN:\n\t\tif (lstate == 0)\n\t\t\tlstate = QIB_IB_LINKDOWN_ONLY;\n\t\telse if (lstate == 1)\n\t\t\tlstate = QIB_IB_LINKDOWN_SLEEP;\n\t\telse if (lstate == 2)\n\t\t\tlstate = QIB_IB_LINKDOWN;\n\t\telse if (lstate == 3)\n\t\t\tlstate = QIB_IB_LINKDOWN_DISABLE;\n\t\telse {\n\t\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t\t\tbreak;\n\t\t}\n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags &= ~QIBL_LINKV;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\tqib_set_linkstate(ppd, lstate);\n\t\t \n\t\tif (lstate == QIB_IB_LINKDOWN_DISABLE && smp->hop_cnt) {\n\t\t\tret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\t\t\tgoto done;\n\t\t}\n\t\tqib_wait_linkstate(ppd, QIBL_LINKV, 10);\n\t\tbreak;\n\tcase IB_PORT_ARMED:\n\t\tqib_set_linkstate(ppd, QIB_IB_LINKARM);\n\t\tbreak;\n\tcase IB_PORT_ACTIVE:\n\t\tqib_set_linkstate(ppd, QIB_IB_LINKACTIVE);\n\t\tbreak;\n\tdefault:\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\t}\n\n\tif (clientrereg) {\n\t\tevent.event = IB_EVENT_CLIENT_REREGISTER;\n\t\tib_dispatch_event(&event);\n\t}\n\n\t \n\tpip->clientrereg_resv_subnetto |= clientrereg;\n\n\tgoto get_only;\n\nerr:\n\tsmp->status |= IB_SMP_INVALID_FIELD;\nget_only:\n\tret = subn_get_portinfo(smp, ibdev, port);\ndone:\n\treturn ret;\n}\n\n \nstatic int rm_pkey(struct qib_pportdata *ppd, u16 key)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\n\t\tif (ppd->pkeys[i] != key)\n\t\t\tcontinue;\n\t\tif (atomic_dec_and_test(&ppd->pkeyrefs[i])) {\n\t\t\tppd->pkeys[i] = 0;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = 0;\n\nbail:\n\treturn ret;\n}\n\n \nstatic int add_pkey(struct qib_pportdata *ppd, u16 key)\n{\n\tint i;\n\tu16 lkey = key & 0x7FFF;\n\tint any = 0;\n\tint ret;\n\n\tif (lkey == 0x7FFF) {\n\t\tret = 0;\n\t\tgoto bail;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\n\t\tif (!ppd->pkeys[i]) {\n\t\t\tany++;\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (ppd->pkeys[i] == key) {\n\t\t\tif (atomic_inc_return(&ppd->pkeyrefs[i]) > 1) {\n\t\t\t\tret = 0;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tatomic_dec(&ppd->pkeyrefs[i]);\n\t\t\tany++;\n\t\t}\n\t\t \n\t\tif ((ppd->pkeys[i] & 0x7FFF) == lkey) {\n\t\t\tret = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\tif (!any) {\n\t\tret = -EBUSY;\n\t\tgoto bail;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(ppd->pkeys); i++) {\n\t\tif (!ppd->pkeys[i] &&\n\t\t    atomic_inc_return(&ppd->pkeyrefs[i]) == 1) {\n\t\t\t \n\t\t\tppd->pkeys[i] = key;\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\t}\n\tret = -EBUSY;\n\nbail:\n\treturn ret;\n}\n\n \nstatic int set_pkeys(struct qib_devdata *dd, u8 port, u16 *pkeys)\n{\n\tstruct qib_pportdata *ppd;\n\tstruct qib_ctxtdata *rcd;\n\tint i;\n\tint changed = 0;\n\n\t \n\tppd = dd->pport + (port - 1);\n\trcd = dd->rcd[ppd->hw_pidx];\n\n\tfor (i = 0; i < ARRAY_SIZE(rcd->pkeys); i++) {\n\t\tu16 key = pkeys[i];\n\t\tu16 okey = rcd->pkeys[i];\n\n\t\tif (key == okey)\n\t\t\tcontinue;\n\t\t \n\t\tif (okey & 0x7FFF)\n\t\t\tchanged |= rm_pkey(ppd, okey);\n\t\tif (key & 0x7FFF) {\n\t\t\tint ret = add_pkey(ppd, key);\n\n\t\t\tif (ret < 0)\n\t\t\t\tkey = 0;\n\t\t\telse\n\t\t\t\tchanged |= ret;\n\t\t}\n\t\trcd->pkeys[i] = key;\n\t}\n\tif (changed) {\n\t\tstruct ib_event event;\n\n\t\t(void) dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PKEYS, 0);\n\n\t\tevent.event = IB_EVENT_PKEY_CHANGE;\n\t\tevent.device = &dd->verbs_dev.rdi.ibdev;\n\t\tevent.element.port_num = port;\n\t\tib_dispatch_event(&event);\n\t}\n\treturn 0;\n}\n\nstatic int subn_set_pkeytable(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t      u8 port)\n{\n\tu32 startpx = 32 * (be32_to_cpu(smp->attr_mod) & 0xffff);\n\t__be16 *p = (__be16 *) smp->data;\n\tu16 *q = (u16 *) smp->data;\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\tunsigned i, n = qib_get_npkeys(dd);\n\n\tfor (i = 0; i < n; i++)\n\t\tq[i] = be16_to_cpu(p[i]);\n\n\tif (startpx != 0 || set_pkeys(dd, port, q) != 0)\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\treturn subn_get_pkeytable(smp, ibdev, port);\n}\n\nstatic int subn_get_sl_to_vl(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tu8 *p = (u8 *) smp->data;\n\tunsigned i;\n\n\tmemset(smp->data, 0, sizeof(smp->data));\n\n\tif (!(ibp->rvp.port_cap_flags & IB_PORT_SL_MAP_SUP))\n\t\tsmp->status |= IB_SMP_UNSUP_METHOD;\n\telse\n\t\tfor (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2)\n\t\t\t*p++ = (ibp->sl_to_vl[i] << 4) | ibp->sl_to_vl[i + 1];\n\n\treturn reply(smp);\n}\n\nstatic int subn_set_sl_to_vl(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tu8 *p = (u8 *) smp->data;\n\tunsigned i;\n\n\tif (!(ibp->rvp.port_cap_flags & IB_PORT_SL_MAP_SUP)) {\n\t\tsmp->status |= IB_SMP_UNSUP_METHOD;\n\t\treturn reply(smp);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ibp->sl_to_vl); i += 2, p++) {\n\t\tibp->sl_to_vl[i] = *p >> 4;\n\t\tibp->sl_to_vl[i + 1] = *p & 0xF;\n\t}\n\tqib_set_uevent_bits(ppd_from_ibp(to_iport(ibdev, port)),\n\t\t\t    _QIB_EVENT_SL2VL_CHANGE_BIT);\n\n\treturn subn_get_sl_to_vl(smp, ibdev, port);\n}\n\nstatic int subn_get_vl_arb(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t   u8 port)\n{\n\tunsigned which = be32_to_cpu(smp->attr_mod) >> 16;\n\tstruct qib_pportdata *ppd = ppd_from_ibp(to_iport(ibdev, port));\n\n\tmemset(smp->data, 0, sizeof(smp->data));\n\n\tif (ppd->vls_supported == IB_VL_VL0)\n\t\tsmp->status |= IB_SMP_UNSUP_METHOD;\n\telse if (which == IB_VLARB_LOWPRI_0_31)\n\t\t(void) ppd->dd->f_get_ib_table(ppd, QIB_IB_TBL_VL_LOW_ARB,\n\t\t\t\t\t\t   smp->data);\n\telse if (which == IB_VLARB_HIGHPRI_0_31)\n\t\t(void) ppd->dd->f_get_ib_table(ppd, QIB_IB_TBL_VL_HIGH_ARB,\n\t\t\t\t\t\t   smp->data);\n\telse\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\treturn reply(smp);\n}\n\nstatic int subn_set_vl_arb(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t   u8 port)\n{\n\tunsigned which = be32_to_cpu(smp->attr_mod) >> 16;\n\tstruct qib_pportdata *ppd = ppd_from_ibp(to_iport(ibdev, port));\n\n\tif (ppd->vls_supported == IB_VL_VL0)\n\t\tsmp->status |= IB_SMP_UNSUP_METHOD;\n\telse if (which == IB_VLARB_LOWPRI_0_31)\n\t\t(void) ppd->dd->f_set_ib_table(ppd, QIB_IB_TBL_VL_LOW_ARB,\n\t\t\t\t\t\t   smp->data);\n\telse if (which == IB_VLARB_HIGHPRI_0_31)\n\t\t(void) ppd->dd->f_set_ib_table(ppd, QIB_IB_TBL_VL_HIGH_ARB,\n\t\t\t\t\t\t   smp->data);\n\telse\n\t\tsmp->status |= IB_SMP_INVALID_FIELD;\n\n\treturn subn_get_vl_arb(smp, ibdev, port);\n}\n\nstatic int subn_trap_repress(struct ib_smp *smp, struct ib_device *ibdev,\n\t\t\t     u8 port)\n{\n\t \n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n}\n\nstatic int pma_get_classportinfo(struct ib_pma_mad *pmp,\n\t\t\t\t struct ib_device *ibdev)\n{\n\tstruct ib_class_port_info *p =\n\t\t(struct ib_class_port_info *)pmp->data;\n\tstruct qib_devdata *dd = dd_from_ibdev(ibdev);\n\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\n\tif (pmp->mad_hdr.attr_mod != 0)\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\n\t \n\tp->base_version = 1;\n\tp->class_version = 1;\n\tp->capability_mask = IB_PMA_CLASS_CAP_EXT_WIDTH;\n\t \n\tib_set_cpi_capmask2(p,\n\t\t\t    dd->psxmitwait_supported <<\n\t\t\t    (31 - IB_CLASS_PORT_INFO_RESP_TIME_FIELD_SIZE));\n\t \n\tib_set_cpi_resp_time(p, 18);\n\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_get_portsamplescontrol(struct ib_pma_mad *pmp,\n\t\t\t\t      struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portsamplescontrol *p =\n\t\t(struct ib_pma_portsamplescontrol *)pmp->data;\n\tstruct qib_ibdev *dev = to_idev(ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tunsigned long flags;\n\tu8 port_select = p->port_select;\n\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\n\tp->port_select = port_select;\n\tif (pmp->mad_hdr.attr_mod != 0 || port_select != port) {\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\t\tgoto bail;\n\t}\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\tp->tick = dd->f_get_ib_cfg(ppd, QIB_IB_CFG_PMA_TICKS);\n\tp->sample_status = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\n\tp->counter_width = 4;    \n\tp->counter_mask0_9 = COUNTER_MASK0_9;\n\tp->sample_start = cpu_to_be32(ibp->rvp.pma_sample_start);\n\tp->sample_interval = cpu_to_be32(ibp->rvp.pma_sample_interval);\n\tp->tag = cpu_to_be16(ibp->rvp.pma_tag);\n\tp->counter_select[0] = ibp->rvp.pma_counter_select[0];\n\tp->counter_select[1] = ibp->rvp.pma_counter_select[1];\n\tp->counter_select[2] = ibp->rvp.pma_counter_select[2];\n\tp->counter_select[3] = ibp->rvp.pma_counter_select[3];\n\tp->counter_select[4] = ibp->rvp.pma_counter_select[4];\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\nbail:\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_set_portsamplescontrol(struct ib_pma_mad *pmp,\n\t\t\t\t      struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portsamplescontrol *p =\n\t\t(struct ib_pma_portsamplescontrol *)pmp->data;\n\tstruct qib_ibdev *dev = to_idev(ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tunsigned long flags;\n\tu8 status, xmit_flags;\n\tint ret;\n\n\tif (pmp->mad_hdr.attr_mod != 0 || p->port_select != port) {\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\t\tret = reply((struct ib_smp *) pmp);\n\t\tgoto bail;\n\t}\n\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\n\t \n\txmit_flags = ppd->cong_stats.flags;\n\tppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_SAMPLE;\n\tstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\n\tif (status == IB_PMA_SAMPLE_STATUS_DONE ||\n\t    (status == IB_PMA_SAMPLE_STATUS_RUNNING &&\n\t     xmit_flags == IB_PMA_CONG_HW_CONTROL_TIMER)) {\n\t\tibp->rvp.pma_sample_start = be32_to_cpu(p->sample_start);\n\t\tibp->rvp.pma_sample_interval = be32_to_cpu(p->sample_interval);\n\t\tibp->rvp.pma_tag = be16_to_cpu(p->tag);\n\t\tibp->rvp.pma_counter_select[0] = p->counter_select[0];\n\t\tibp->rvp.pma_counter_select[1] = p->counter_select[1];\n\t\tibp->rvp.pma_counter_select[2] = p->counter_select[2];\n\t\tibp->rvp.pma_counter_select[3] = p->counter_select[3];\n\t\tibp->rvp.pma_counter_select[4] = p->counter_select[4];\n\t\tdd->f_set_cntr_sample(ppd, ibp->rvp.pma_sample_interval,\n\t\t\t\t      ibp->rvp.pma_sample_start);\n\t}\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\n\tret = pma_get_portsamplescontrol(pmp, ibdev, port);\n\nbail:\n\treturn ret;\n}\n\nstatic u64 get_counter(struct qib_ibport *ibp, struct qib_pportdata *ppd,\n\t\t       __be16 sel)\n{\n\tu64 ret;\n\n\tswitch (sel) {\n\tcase IB_PMA_PORT_XMIT_DATA:\n\t\tret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITDATA);\n\t\tbreak;\n\tcase IB_PMA_PORT_RCV_DATA:\n\t\tret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSRCVDATA);\n\t\tbreak;\n\tcase IB_PMA_PORT_XMIT_PKTS:\n\t\tret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITPKTS);\n\t\tbreak;\n\tcase IB_PMA_PORT_RCV_PKTS:\n\t\tret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSRCVPKTS);\n\t\tbreak;\n\tcase IB_PMA_PORT_XMIT_WAIT:\n\t\tret = ppd->dd->f_portcntr(ppd, QIBPORTCNTR_PSXMITWAIT);\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nstatic u64 xmit_wait_get_value_delta(struct qib_pportdata *ppd)\n{\n\tu32 delta;\n\n\tdelta = get_counter(&ppd->ibport_data, ppd,\n\t\t\t    IB_PMA_PORT_XMIT_WAIT);\n\treturn ppd->cong_stats.counter + delta;\n}\n\nstatic void cache_hw_sample_counters(struct qib_pportdata *ppd)\n{\n\tstruct qib_ibport *ibp = &ppd->ibport_data;\n\n\tppd->cong_stats.counter_cache.psxmitdata =\n\t\tget_counter(ibp, ppd, IB_PMA_PORT_XMIT_DATA);\n\tppd->cong_stats.counter_cache.psrcvdata =\n\t\tget_counter(ibp, ppd, IB_PMA_PORT_RCV_DATA);\n\tppd->cong_stats.counter_cache.psxmitpkts =\n\t\tget_counter(ibp, ppd, IB_PMA_PORT_XMIT_PKTS);\n\tppd->cong_stats.counter_cache.psrcvpkts =\n\t\tget_counter(ibp, ppd, IB_PMA_PORT_RCV_PKTS);\n\tppd->cong_stats.counter_cache.psxmitwait =\n\t\tget_counter(ibp, ppd, IB_PMA_PORT_XMIT_WAIT);\n}\n\nstatic u64 get_cache_hw_sample_counters(struct qib_pportdata *ppd,\n\t\t\t\t\t__be16 sel)\n{\n\tu64 ret;\n\n\tswitch (sel) {\n\tcase IB_PMA_PORT_XMIT_DATA:\n\t\tret = ppd->cong_stats.counter_cache.psxmitdata;\n\t\tbreak;\n\tcase IB_PMA_PORT_RCV_DATA:\n\t\tret = ppd->cong_stats.counter_cache.psrcvdata;\n\t\tbreak;\n\tcase IB_PMA_PORT_XMIT_PKTS:\n\t\tret = ppd->cong_stats.counter_cache.psxmitpkts;\n\t\tbreak;\n\tcase IB_PMA_PORT_RCV_PKTS:\n\t\tret = ppd->cong_stats.counter_cache.psrcvpkts;\n\t\tbreak;\n\tcase IB_PMA_PORT_XMIT_WAIT:\n\t\tret = ppd->cong_stats.counter_cache.psxmitwait;\n\t\tbreak;\n\tdefault:\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int pma_get_portsamplesresult(struct ib_pma_mad *pmp,\n\t\t\t\t     struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portsamplesresult *p =\n\t\t(struct ib_pma_portsamplesresult *)pmp->data;\n\tstruct qib_ibdev *dev = to_idev(ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tunsigned long flags;\n\tu8 status;\n\tint i;\n\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\tp->tag = cpu_to_be16(ibp->rvp.pma_tag);\n\tif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_TIMER)\n\t\tp->sample_status = IB_PMA_SAMPLE_STATUS_DONE;\n\telse {\n\t\tstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\n\t\tp->sample_status = cpu_to_be16(status);\n\t\tif (status == IB_PMA_SAMPLE_STATUS_DONE) {\n\t\t\tcache_hw_sample_counters(ppd);\n\t\t\tppd->cong_stats.counter =\n\t\t\t\txmit_wait_get_value_delta(ppd);\n\t\t\tdd->f_set_cntr_sample(ppd,\n\t\t\t\t\t      QIB_CONG_TIMER_PSINTERVAL, 0);\n\t\t\tppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(ibp->rvp.pma_counter_select); i++)\n\t\tp->counter[i] = cpu_to_be32(\n\t\t\tget_cache_hw_sample_counters(\n\t\t\t\tppd, ibp->rvp.pma_counter_select[i]));\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_get_portsamplesresult_ext(struct ib_pma_mad *pmp,\n\t\t\t\t\t struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portsamplesresult_ext *p =\n\t\t(struct ib_pma_portsamplesresult_ext *)pmp->data;\n\tstruct qib_ibdev *dev = to_idev(ibdev);\n\tstruct qib_devdata *dd = dd_from_dev(dev);\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tunsigned long flags;\n\tu8 status;\n\tint i;\n\n\t \n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\tp->tag = cpu_to_be16(ibp->rvp.pma_tag);\n\tif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_TIMER)\n\t\tp->sample_status = IB_PMA_SAMPLE_STATUS_DONE;\n\telse {\n\t\tstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\n\t\tp->sample_status = cpu_to_be16(status);\n\t\t \n\t\tp->extended_width = cpu_to_be32(0x80000000);\n\t\tif (status == IB_PMA_SAMPLE_STATUS_DONE) {\n\t\t\tcache_hw_sample_counters(ppd);\n\t\t\tppd->cong_stats.counter =\n\t\t\t\txmit_wait_get_value_delta(ppd);\n\t\t\tdd->f_set_cntr_sample(ppd,\n\t\t\t\t\t      QIB_CONG_TIMER_PSINTERVAL, 0);\n\t\t\tppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\n\t\t}\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(ibp->rvp.pma_counter_select); i++)\n\t\tp->counter[i] = cpu_to_be64(\n\t\t\tget_cache_hw_sample_counters(\n\t\t\t\tppd, ibp->rvp.pma_counter_select[i]));\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_get_portcounters(struct ib_pma_mad *pmp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\n\t\tpmp->data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct qib_verbs_counters cntrs;\n\tu8 port_select = p->port_select;\n\n\tqib_get_counters(ppd, &cntrs);\n\n\t \n\tcntrs.symbol_error_counter -= ibp->z_symbol_error_counter;\n\tcntrs.link_error_recovery_counter -=\n\t\tibp->z_link_error_recovery_counter;\n\tcntrs.link_downed_counter -= ibp->z_link_downed_counter;\n\tcntrs.port_rcv_errors -= ibp->z_port_rcv_errors;\n\tcntrs.port_rcv_remphys_errors -= ibp->z_port_rcv_remphys_errors;\n\tcntrs.port_xmit_discards -= ibp->z_port_xmit_discards;\n\tcntrs.port_xmit_data -= ibp->z_port_xmit_data;\n\tcntrs.port_rcv_data -= ibp->z_port_rcv_data;\n\tcntrs.port_xmit_packets -= ibp->z_port_xmit_packets;\n\tcntrs.port_rcv_packets -= ibp->z_port_rcv_packets;\n\tcntrs.local_link_integrity_errors -=\n\t\tibp->z_local_link_integrity_errors;\n\tcntrs.excessive_buffer_overrun_errors -=\n\t\tibp->z_excessive_buffer_overrun_errors;\n\tcntrs.vl15_dropped -= ibp->z_vl15_dropped;\n\tcntrs.vl15_dropped += ibp->rvp.n_vl15_dropped;\n\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\n\tp->port_select = port_select;\n\tif (pmp->mad_hdr.attr_mod != 0 || port_select != port)\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\n\tif (cntrs.symbol_error_counter > 0xFFFFUL)\n\t\tp->symbol_error_counter = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->symbol_error_counter =\n\t\t\tcpu_to_be16((u16)cntrs.symbol_error_counter);\n\tif (cntrs.link_error_recovery_counter > 0xFFUL)\n\t\tp->link_error_recovery_counter = 0xFF;\n\telse\n\t\tp->link_error_recovery_counter =\n\t\t\t(u8)cntrs.link_error_recovery_counter;\n\tif (cntrs.link_downed_counter > 0xFFUL)\n\t\tp->link_downed_counter = 0xFF;\n\telse\n\t\tp->link_downed_counter = (u8)cntrs.link_downed_counter;\n\tif (cntrs.port_rcv_errors > 0xFFFFUL)\n\t\tp->port_rcv_errors = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_rcv_errors =\n\t\t\tcpu_to_be16((u16) cntrs.port_rcv_errors);\n\tif (cntrs.port_rcv_remphys_errors > 0xFFFFUL)\n\t\tp->port_rcv_remphys_errors = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_rcv_remphys_errors =\n\t\t\tcpu_to_be16((u16)cntrs.port_rcv_remphys_errors);\n\tif (cntrs.port_xmit_discards > 0xFFFFUL)\n\t\tp->port_xmit_discards = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_xmit_discards =\n\t\t\tcpu_to_be16((u16)cntrs.port_xmit_discards);\n\tif (cntrs.local_link_integrity_errors > 0xFUL)\n\t\tcntrs.local_link_integrity_errors = 0xFUL;\n\tif (cntrs.excessive_buffer_overrun_errors > 0xFUL)\n\t\tcntrs.excessive_buffer_overrun_errors = 0xFUL;\n\tp->link_overrun_errors = (cntrs.local_link_integrity_errors << 4) |\n\t\tcntrs.excessive_buffer_overrun_errors;\n\tif (cntrs.vl15_dropped > 0xFFFFUL)\n\t\tp->vl15_dropped = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->vl15_dropped = cpu_to_be16((u16)cntrs.vl15_dropped);\n\tif (cntrs.port_xmit_data > 0xFFFFFFFFUL)\n\t\tp->port_xmit_data = cpu_to_be32(0xFFFFFFFF);\n\telse\n\t\tp->port_xmit_data = cpu_to_be32((u32)cntrs.port_xmit_data);\n\tif (cntrs.port_rcv_data > 0xFFFFFFFFUL)\n\t\tp->port_rcv_data = cpu_to_be32(0xFFFFFFFF);\n\telse\n\t\tp->port_rcv_data = cpu_to_be32((u32)cntrs.port_rcv_data);\n\tif (cntrs.port_xmit_packets > 0xFFFFFFFFUL)\n\t\tp->port_xmit_packets = cpu_to_be32(0xFFFFFFFF);\n\telse\n\t\tp->port_xmit_packets =\n\t\t\tcpu_to_be32((u32)cntrs.port_xmit_packets);\n\tif (cntrs.port_rcv_packets > 0xFFFFFFFFUL)\n\t\tp->port_rcv_packets = cpu_to_be32(0xFFFFFFFF);\n\telse\n\t\tp->port_rcv_packets =\n\t\t\tcpu_to_be32((u32) cntrs.port_rcv_packets);\n\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_get_portcounters_cong(struct ib_pma_mad *pmp,\n\t\t\t\t     struct ib_device *ibdev, u8 port)\n{\n\t \n\tstruct ib_pma_portcounters_cong *p =\n\t\t(struct ib_pma_portcounters_cong *)pmp->reserved;\n\tstruct qib_verbs_counters cntrs;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct qib_devdata *dd = dd_from_ppd(ppd);\n\tu32 port_select = be32_to_cpu(pmp->mad_hdr.attr_mod) & 0xFF;\n\tu64 xmit_wait_counter;\n\tunsigned long flags;\n\n\t \n\tif (!dd->psxmitwait_supported)\n\t\tpmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\n\tif (port_select != port)\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\n\tqib_get_counters(ppd, &cntrs);\n\tspin_lock_irqsave(&ppd->ibport_data.rvp.lock, flags);\n\txmit_wait_counter = xmit_wait_get_value_delta(ppd);\n\tspin_unlock_irqrestore(&ppd->ibport_data.rvp.lock, flags);\n\n\t \n\tcntrs.symbol_error_counter -= ibp->z_symbol_error_counter;\n\tcntrs.link_error_recovery_counter -=\n\t\tibp->z_link_error_recovery_counter;\n\tcntrs.link_downed_counter -= ibp->z_link_downed_counter;\n\tcntrs.port_rcv_errors -= ibp->z_port_rcv_errors;\n\tcntrs.port_rcv_remphys_errors -=\n\t\tibp->z_port_rcv_remphys_errors;\n\tcntrs.port_xmit_discards -= ibp->z_port_xmit_discards;\n\tcntrs.local_link_integrity_errors -=\n\t\tibp->z_local_link_integrity_errors;\n\tcntrs.excessive_buffer_overrun_errors -=\n\t\tibp->z_excessive_buffer_overrun_errors;\n\tcntrs.vl15_dropped -= ibp->z_vl15_dropped;\n\tcntrs.vl15_dropped += ibp->rvp.n_vl15_dropped;\n\tcntrs.port_xmit_data -= ibp->z_port_xmit_data;\n\tcntrs.port_rcv_data -= ibp->z_port_rcv_data;\n\tcntrs.port_xmit_packets -= ibp->z_port_xmit_packets;\n\tcntrs.port_rcv_packets -= ibp->z_port_rcv_packets;\n\n\tmemset(pmp->reserved, 0, sizeof(pmp->reserved));\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\n\t \n\tp->port_check_rate =\n\t\tcpu_to_be16((QIB_XMIT_RATE_PICO << 13) |\n\t\t\t    (dd->psxmitwait_check_rate &\n\t\t\t     ~(QIB_XMIT_RATE_PICO << 13)));\n\tp->port_adr_events = cpu_to_be64(0);\n\tp->port_xmit_wait = cpu_to_be64(xmit_wait_counter);\n\tp->port_xmit_data = cpu_to_be64(cntrs.port_xmit_data);\n\tp->port_rcv_data = cpu_to_be64(cntrs.port_rcv_data);\n\tp->port_xmit_packets =\n\t\tcpu_to_be64(cntrs.port_xmit_packets);\n\tp->port_rcv_packets =\n\t\tcpu_to_be64(cntrs.port_rcv_packets);\n\tif (cntrs.symbol_error_counter > 0xFFFFUL)\n\t\tp->symbol_error_counter = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->symbol_error_counter =\n\t\t\tcpu_to_be16(\n\t\t\t\t(u16)cntrs.symbol_error_counter);\n\tif (cntrs.link_error_recovery_counter > 0xFFUL)\n\t\tp->link_error_recovery_counter = 0xFF;\n\telse\n\t\tp->link_error_recovery_counter =\n\t\t\t(u8)cntrs.link_error_recovery_counter;\n\tif (cntrs.link_downed_counter > 0xFFUL)\n\t\tp->link_downed_counter = 0xFF;\n\telse\n\t\tp->link_downed_counter =\n\t\t\t(u8)cntrs.link_downed_counter;\n\tif (cntrs.port_rcv_errors > 0xFFFFUL)\n\t\tp->port_rcv_errors = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_rcv_errors =\n\t\t\tcpu_to_be16((u16) cntrs.port_rcv_errors);\n\tif (cntrs.port_rcv_remphys_errors > 0xFFFFUL)\n\t\tp->port_rcv_remphys_errors = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_rcv_remphys_errors =\n\t\t\tcpu_to_be16(\n\t\t\t\t(u16)cntrs.port_rcv_remphys_errors);\n\tif (cntrs.port_xmit_discards > 0xFFFFUL)\n\t\tp->port_xmit_discards = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->port_xmit_discards =\n\t\t\tcpu_to_be16((u16)cntrs.port_xmit_discards);\n\tif (cntrs.local_link_integrity_errors > 0xFUL)\n\t\tcntrs.local_link_integrity_errors = 0xFUL;\n\tif (cntrs.excessive_buffer_overrun_errors > 0xFUL)\n\t\tcntrs.excessive_buffer_overrun_errors = 0xFUL;\n\tp->link_overrun_errors = (cntrs.local_link_integrity_errors << 4) |\n\t\tcntrs.excessive_buffer_overrun_errors;\n\tif (cntrs.vl15_dropped > 0xFFFFUL)\n\t\tp->vl15_dropped = cpu_to_be16(0xFFFF);\n\telse\n\t\tp->vl15_dropped = cpu_to_be16((u16)cntrs.vl15_dropped);\n\n\treturn reply((struct ib_smp *)pmp);\n}\n\nstatic void qib_snapshot_pmacounters(\n\tstruct qib_ibport *ibp,\n\tstruct qib_pma_counters *pmacounters)\n{\n\tstruct qib_pma_counters *p;\n\tint cpu;\n\n\tmemset(pmacounters, 0, sizeof(*pmacounters));\n\tfor_each_possible_cpu(cpu) {\n\t\tp = per_cpu_ptr(ibp->pmastats, cpu);\n\t\tpmacounters->n_unicast_xmit += p->n_unicast_xmit;\n\t\tpmacounters->n_unicast_rcv += p->n_unicast_rcv;\n\t\tpmacounters->n_multicast_xmit += p->n_multicast_xmit;\n\t\tpmacounters->n_multicast_rcv += p->n_multicast_rcv;\n\t}\n}\n\nstatic int pma_get_portcounters_ext(struct ib_pma_mad *pmp,\n\t\t\t\t    struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portcounters_ext *p =\n\t\t(struct ib_pma_portcounters_ext *)pmp->data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu64 swords, rwords, spkts, rpkts, xwait;\n\tstruct qib_pma_counters pma;\n\tu8 port_select = p->port_select;\n\n\tmemset(pmp->data, 0, sizeof(pmp->data));\n\n\tp->port_select = port_select;\n\tif (pmp->mad_hdr.attr_mod != 0 || port_select != port) {\n\t\tpmp->mad_hdr.status |= IB_SMP_INVALID_FIELD;\n\t\tgoto bail;\n\t}\n\n\tqib_snapshot_counters(ppd, &swords, &rwords, &spkts, &rpkts, &xwait);\n\n\t \n\tswords -= ibp->z_port_xmit_data;\n\trwords -= ibp->z_port_rcv_data;\n\tspkts -= ibp->z_port_xmit_packets;\n\trpkts -= ibp->z_port_rcv_packets;\n\n\tp->port_xmit_data = cpu_to_be64(swords);\n\tp->port_rcv_data = cpu_to_be64(rwords);\n\tp->port_xmit_packets = cpu_to_be64(spkts);\n\tp->port_rcv_packets = cpu_to_be64(rpkts);\n\n\tqib_snapshot_pmacounters(ibp, &pma);\n\n\tp->port_unicast_xmit_packets = cpu_to_be64(pma.n_unicast_xmit\n\t\t- ibp->z_unicast_xmit);\n\tp->port_unicast_rcv_packets = cpu_to_be64(pma.n_unicast_rcv\n\t\t- ibp->z_unicast_rcv);\n\tp->port_multicast_xmit_packets = cpu_to_be64(pma.n_multicast_xmit\n\t\t- ibp->z_multicast_xmit);\n\tp->port_multicast_rcv_packets = cpu_to_be64(pma.n_multicast_rcv\n\t\t- ibp->z_multicast_rcv);\n\nbail:\n\treturn reply((struct ib_smp *) pmp);\n}\n\nstatic int pma_set_portcounters(struct ib_pma_mad *pmp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\n\t\tpmp->data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct qib_verbs_counters cntrs;\n\n\t \n\tqib_get_counters(ppd, &cntrs);\n\n\tif (p->counter_select & IB_PMA_SEL_SYMBOL_ERROR)\n\t\tibp->z_symbol_error_counter = cntrs.symbol_error_counter;\n\n\tif (p->counter_select & IB_PMA_SEL_LINK_ERROR_RECOVERY)\n\t\tibp->z_link_error_recovery_counter =\n\t\t\tcntrs.link_error_recovery_counter;\n\n\tif (p->counter_select & IB_PMA_SEL_LINK_DOWNED)\n\t\tibp->z_link_downed_counter = cntrs.link_downed_counter;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_RCV_ERRORS)\n\t\tibp->z_port_rcv_errors = cntrs.port_rcv_errors;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_RCV_REMPHYS_ERRORS)\n\t\tibp->z_port_rcv_remphys_errors =\n\t\t\tcntrs.port_rcv_remphys_errors;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DISCARDS)\n\t\tibp->z_port_xmit_discards = cntrs.port_xmit_discards;\n\n\tif (p->counter_select & IB_PMA_SEL_LOCAL_LINK_INTEGRITY_ERRORS)\n\t\tibp->z_local_link_integrity_errors =\n\t\t\tcntrs.local_link_integrity_errors;\n\n\tif (p->counter_select & IB_PMA_SEL_EXCESSIVE_BUFFER_OVERRUNS)\n\t\tibp->z_excessive_buffer_overrun_errors =\n\t\t\tcntrs.excessive_buffer_overrun_errors;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_VL15_DROPPED) {\n\t\tibp->rvp.n_vl15_dropped = 0;\n\t\tibp->z_vl15_dropped = cntrs.vl15_dropped;\n\t}\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_XMIT_DATA)\n\t\tibp->z_port_xmit_data = cntrs.port_xmit_data;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_RCV_DATA)\n\t\tibp->z_port_rcv_data = cntrs.port_rcv_data;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_XMIT_PACKETS)\n\t\tibp->z_port_xmit_packets = cntrs.port_xmit_packets;\n\n\tif (p->counter_select & IB_PMA_SEL_PORT_RCV_PACKETS)\n\t\tibp->z_port_rcv_packets = cntrs.port_rcv_packets;\n\n\treturn pma_get_portcounters(pmp, ibdev, port);\n}\n\nstatic int pma_set_portcounters_cong(struct ib_pma_mad *pmp,\n\t\t\t\t     struct ib_device *ibdev, u8 port)\n{\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct qib_devdata *dd = dd_from_ppd(ppd);\n\tstruct qib_verbs_counters cntrs;\n\tu32 counter_select = (be32_to_cpu(pmp->mad_hdr.attr_mod) >> 24) & 0xFF;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tqib_get_counters(ppd, &cntrs);\n\t \n\tret = pma_get_portcounters_cong(pmp, ibdev, port);\n\n\tif (counter_select & IB_PMA_SEL_CONG_XMIT) {\n\t\tspin_lock_irqsave(&ppd->ibport_data.rvp.lock, flags);\n\t\tppd->cong_stats.counter = 0;\n\t\tdd->f_set_cntr_sample(ppd, QIB_CONG_TIMER_PSINTERVAL,\n\t\t\t\t      0x0);\n\t\tspin_unlock_irqrestore(&ppd->ibport_data.rvp.lock, flags);\n\t}\n\tif (counter_select & IB_PMA_SEL_CONG_PORT_DATA) {\n\t\tibp->z_port_xmit_data = cntrs.port_xmit_data;\n\t\tibp->z_port_rcv_data = cntrs.port_rcv_data;\n\t\tibp->z_port_xmit_packets = cntrs.port_xmit_packets;\n\t\tibp->z_port_rcv_packets = cntrs.port_rcv_packets;\n\t}\n\tif (counter_select & IB_PMA_SEL_CONG_ALL) {\n\t\tibp->z_symbol_error_counter =\n\t\t\tcntrs.symbol_error_counter;\n\t\tibp->z_link_error_recovery_counter =\n\t\t\tcntrs.link_error_recovery_counter;\n\t\tibp->z_link_downed_counter =\n\t\t\tcntrs.link_downed_counter;\n\t\tibp->z_port_rcv_errors = cntrs.port_rcv_errors;\n\t\tibp->z_port_rcv_remphys_errors =\n\t\t\tcntrs.port_rcv_remphys_errors;\n\t\tibp->z_port_xmit_discards =\n\t\t\tcntrs.port_xmit_discards;\n\t\tibp->z_local_link_integrity_errors =\n\t\t\tcntrs.local_link_integrity_errors;\n\t\tibp->z_excessive_buffer_overrun_errors =\n\t\t\tcntrs.excessive_buffer_overrun_errors;\n\t\tibp->rvp.n_vl15_dropped = 0;\n\t\tibp->z_vl15_dropped = cntrs.vl15_dropped;\n\t}\n\n\treturn ret;\n}\n\nstatic int pma_set_portcounters_ext(struct ib_pma_mad *pmp,\n\t\t\t\t    struct ib_device *ibdev, u8 port)\n{\n\tstruct ib_pma_portcounters *p = (struct ib_pma_portcounters *)\n\t\tpmp->data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu64 swords, rwords, spkts, rpkts, xwait;\n\tstruct qib_pma_counters pma;\n\n\tqib_snapshot_counters(ppd, &swords, &rwords, &spkts, &rpkts, &xwait);\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_XMIT_DATA)\n\t\tibp->z_port_xmit_data = swords;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_RCV_DATA)\n\t\tibp->z_port_rcv_data = rwords;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_XMIT_PACKETS)\n\t\tibp->z_port_xmit_packets = spkts;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_RCV_PACKETS)\n\t\tibp->z_port_rcv_packets = rpkts;\n\n\tqib_snapshot_pmacounters(ibp, &pma);\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_UNI_XMIT_PACKETS)\n\t\tibp->z_unicast_xmit = pma.n_unicast_xmit;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_UNI_RCV_PACKETS)\n\t\tibp->z_unicast_rcv = pma.n_unicast_rcv;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_MULTI_XMIT_PACKETS)\n\t\tibp->z_multicast_xmit = pma.n_multicast_xmit;\n\n\tif (p->counter_select & IB_PMA_SELX_PORT_MULTI_RCV_PACKETS)\n\t\tibp->z_multicast_rcv = pma.n_multicast_rcv;\n\n\treturn pma_get_portcounters_ext(pmp, ibdev, port);\n}\n\nstatic int process_subn(struct ib_device *ibdev, int mad_flags,\n\t\t\tu8 port, const struct ib_mad *in_mad,\n\t\t\tstruct ib_mad *out_mad)\n{\n\tstruct ib_smp *smp = (struct ib_smp *)out_mad;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tint ret;\n\n\t*out_mad = *in_mad;\n\tif (smp->class_version != 1) {\n\t\tsmp->status |= IB_SMP_UNSUP_VERSION;\n\t\tret = reply(smp);\n\t\tgoto bail;\n\t}\n\n\tret = check_mkey(ibp, smp, mad_flags);\n\tif (ret) {\n\t\tu32 port_num = be32_to_cpu(smp->attr_mod);\n\n\t\t \n\t\tif (in_mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&\n\t\t    (smp->method == IB_MGMT_METHOD_GET ||\n\t\t     smp->method == IB_MGMT_METHOD_SET) &&\n\t\t    port_num && port_num <= ibdev->phys_port_cnt &&\n\t\t    port != port_num)\n\t\t\t(void) check_mkey(to_iport(ibdev, port_num), smp, 0);\n\t\tret = IB_MAD_RESULT_FAILURE;\n\t\tgoto bail;\n\t}\n\n\tswitch (smp->method) {\n\tcase IB_MGMT_METHOD_GET:\n\t\tswitch (smp->attr_id) {\n\t\tcase IB_SMP_ATTR_NODE_DESC:\n\t\t\tret = subn_get_nodedescription(smp, ibdev);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_NODE_INFO:\n\t\t\tret = subn_get_nodeinfo(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_GUID_INFO:\n\t\t\tret = subn_get_guidinfo(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_PORT_INFO:\n\t\t\tret = subn_get_portinfo(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_PKEY_TABLE:\n\t\t\tret = subn_get_pkeytable(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_SL_TO_VL_TABLE:\n\t\t\tret = subn_get_sl_to_vl(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_VL_ARB_TABLE:\n\t\t\tret = subn_get_vl_arb(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_SM_INFO:\n\t\t\tif (ibp->rvp.port_cap_flags & IB_PORT_SM_DISABLED) {\n\t\t\t\tret = IB_MAD_RESULT_SUCCESS |\n\t\t\t\t\tIB_MAD_RESULT_CONSUMED;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (ibp->rvp.port_cap_flags & IB_PORT_SM) {\n\t\t\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tsmp->status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\tret = reply(smp);\n\t\t\tgoto bail;\n\t\t}\n\n\tcase IB_MGMT_METHOD_SET:\n\t\tswitch (smp->attr_id) {\n\t\tcase IB_SMP_ATTR_GUID_INFO:\n\t\t\tret = subn_set_guidinfo(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_PORT_INFO:\n\t\t\tret = subn_set_portinfo(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_PKEY_TABLE:\n\t\t\tret = subn_set_pkeytable(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_SL_TO_VL_TABLE:\n\t\t\tret = subn_set_sl_to_vl(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_VL_ARB_TABLE:\n\t\t\tret = subn_set_vl_arb(smp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_SMP_ATTR_SM_INFO:\n\t\t\tif (ibp->rvp.port_cap_flags & IB_PORT_SM_DISABLED) {\n\t\t\t\tret = IB_MAD_RESULT_SUCCESS |\n\t\t\t\t\tIB_MAD_RESULT_CONSUMED;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tif (ibp->rvp.port_cap_flags & IB_PORT_SM) {\n\t\t\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tsmp->status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\tret = reply(smp);\n\t\t\tgoto bail;\n\t\t}\n\n\tcase IB_MGMT_METHOD_TRAP_REPRESS:\n\t\tif (smp->attr_id == IB_SMP_ATTR_NOTICE)\n\t\t\tret = subn_trap_repress(smp, ibdev, port);\n\t\telse {\n\t\t\tsmp->status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\tret = reply(smp);\n\t\t}\n\t\tgoto bail;\n\n\tcase IB_MGMT_METHOD_TRAP:\n\tcase IB_MGMT_METHOD_REPORT:\n\tcase IB_MGMT_METHOD_REPORT_RESP:\n\tcase IB_MGMT_METHOD_GET_RESP:\n\t\t \n\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\tgoto bail;\n\n\tcase IB_MGMT_METHOD_SEND:\n\t\tif (ib_get_smp_direction(smp) &&\n\t\t    smp->attr_id == QIB_VENDOR_IPG) {\n\t\t\tppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_PORT,\n\t\t\t\t\t      smp->data[0]);\n\t\t\tret = IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\t\t} else\n\t\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\tgoto bail;\n\n\tdefault:\n\t\tsmp->status |= IB_SMP_UNSUP_METHOD;\n\t\tret = reply(smp);\n\t}\n\nbail:\n\treturn ret;\n}\n\nstatic int process_perf(struct ib_device *ibdev, u8 port,\n\t\t\tconst struct ib_mad *in_mad,\n\t\t\tstruct ib_mad *out_mad)\n{\n\tstruct ib_pma_mad *pmp = (struct ib_pma_mad *)out_mad;\n\tint ret;\n\n\t*out_mad = *in_mad;\n\tif (pmp->mad_hdr.class_version != 1) {\n\t\tpmp->mad_hdr.status |= IB_SMP_UNSUP_VERSION;\n\t\tret = reply((struct ib_smp *) pmp);\n\t\tgoto bail;\n\t}\n\n\tswitch (pmp->mad_hdr.method) {\n\tcase IB_MGMT_METHOD_GET:\n\t\tswitch (pmp->mad_hdr.attr_id) {\n\t\tcase IB_PMA_CLASS_PORT_INFO:\n\t\t\tret = pma_get_classportinfo(pmp, ibdev);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_SAMPLES_CONTROL:\n\t\t\tret = pma_get_portsamplescontrol(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_SAMPLES_RESULT:\n\t\t\tret = pma_get_portsamplesresult(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_SAMPLES_RESULT_EXT:\n\t\t\tret = pma_get_portsamplesresult_ext(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS:\n\t\t\tret = pma_get_portcounters(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS_EXT:\n\t\t\tret = pma_get_portcounters_ext(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS_CONG:\n\t\t\tret = pma_get_portcounters_cong(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tdefault:\n\t\t\tpmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\tret = reply((struct ib_smp *) pmp);\n\t\t\tgoto bail;\n\t\t}\n\n\tcase IB_MGMT_METHOD_SET:\n\t\tswitch (pmp->mad_hdr.attr_id) {\n\t\tcase IB_PMA_PORT_SAMPLES_CONTROL:\n\t\t\tret = pma_set_portsamplescontrol(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS:\n\t\t\tret = pma_set_portcounters(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS_EXT:\n\t\t\tret = pma_set_portcounters_ext(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tcase IB_PMA_PORT_COUNTERS_CONG:\n\t\t\tret = pma_set_portcounters_cong(pmp, ibdev, port);\n\t\t\tgoto bail;\n\t\tdefault:\n\t\t\tpmp->mad_hdr.status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\tret = reply((struct ib_smp *) pmp);\n\t\t\tgoto bail;\n\t\t}\n\n\tcase IB_MGMT_METHOD_TRAP:\n\tcase IB_MGMT_METHOD_GET_RESP:\n\t\t \n\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\tgoto bail;\n\n\tdefault:\n\t\tpmp->mad_hdr.status |= IB_SMP_UNSUP_METHOD;\n\t\tret = reply((struct ib_smp *) pmp);\n\t}\n\nbail:\n\treturn ret;\n}\n\nstatic int cc_get_classportinfo(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev)\n{\n\tstruct ib_cc_classportinfo_attr *p =\n\t\t(struct ib_cc_classportinfo_attr *)ccp->mgmt_data;\n\n\tp->base_version = 1;\n\tp->class_version = 1;\n\tp->cap_mask = 0;\n\n\t \n\tp->resp_time_value = 18;\n\n\treturn reply((struct ib_smp *) ccp);\n}\n\nstatic int cc_get_congestion_info(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_cc_info_attr *p =\n\t\t(struct ib_cc_info_attr *)ccp->mgmt_data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\n\tp->congestion_info = 0;\n\tp->control_table_cap = ppd->cc_max_table_entries;\n\n\treturn reply((struct ib_smp *) ccp);\n}\n\nstatic int cc_get_congestion_setting(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tint i;\n\tstruct ib_cc_congestion_setting_attr *p =\n\t\t(struct ib_cc_congestion_setting_attr *)ccp->mgmt_data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tstruct ib_cc_congestion_entry_shadow *entries;\n\n\tspin_lock(&ppd->cc_shadow_lock);\n\n\tentries = ppd->congestion_entries_shadow->entries;\n\tp->port_control = cpu_to_be16(\n\t\tppd->congestion_entries_shadow->port_control);\n\tp->control_map = cpu_to_be16(\n\t\tppd->congestion_entries_shadow->control_map);\n\tfor (i = 0; i < IB_CC_CCS_ENTRIES; i++) {\n\t\tp->entries[i].ccti_increase = entries[i].ccti_increase;\n\t\tp->entries[i].ccti_timer = cpu_to_be16(entries[i].ccti_timer);\n\t\tp->entries[i].trigger_threshold = entries[i].trigger_threshold;\n\t\tp->entries[i].ccti_min = entries[i].ccti_min;\n\t}\n\n\tspin_unlock(&ppd->cc_shadow_lock);\n\n\treturn reply((struct ib_smp *) ccp);\n}\n\nstatic int cc_get_congestion_control_table(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_cc_table_attr *p =\n\t\t(struct ib_cc_table_attr *)ccp->mgmt_data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu32 cct_block_index = be32_to_cpu(ccp->attr_mod);\n\tu32 max_cct_block;\n\tu32 cct_entry;\n\tstruct ib_cc_table_entry_shadow *entries;\n\tint i;\n\n\t \n\tif (cct_block_index > IB_CC_TABLE_CAP_DEFAULT - 1)\n\t\tgoto bail;\n\n\tspin_lock(&ppd->cc_shadow_lock);\n\n\tmax_cct_block =\n\t\t(ppd->ccti_entries_shadow->ccti_last_entry + 1)/IB_CCT_ENTRIES;\n\tmax_cct_block = max_cct_block ? max_cct_block - 1 : 0;\n\n\tif (cct_block_index > max_cct_block) {\n\t\tspin_unlock(&ppd->cc_shadow_lock);\n\t\tgoto bail;\n\t}\n\n\tccp->attr_mod = cpu_to_be32(cct_block_index);\n\n\tcct_entry = IB_CCT_ENTRIES * (cct_block_index + 1);\n\n\tcct_entry--;\n\n\tp->ccti_limit = cpu_to_be16(cct_entry);\n\n\tentries = &ppd->ccti_entries_shadow->\n\t\t\tentries[IB_CCT_ENTRIES * cct_block_index];\n\tcct_entry %= IB_CCT_ENTRIES;\n\n\tfor (i = 0; i <= cct_entry; i++)\n\t\tp->ccti_entries[i].entry = cpu_to_be16(entries[i].entry);\n\n\tspin_unlock(&ppd->cc_shadow_lock);\n\n\treturn reply((struct ib_smp *) ccp);\n\nbail:\n\treturn reply_failure((struct ib_smp *) ccp);\n}\n\nstatic int cc_set_congestion_setting(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_cc_congestion_setting_attr *p =\n\t\t(struct ib_cc_congestion_setting_attr *)ccp->mgmt_data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tint i;\n\n\tppd->cc_sl_control_map = be16_to_cpu(p->control_map);\n\n\tfor (i = 0; i < IB_CC_CCS_ENTRIES; i++) {\n\t\tppd->congestion_entries[i].ccti_increase =\n\t\t\tp->entries[i].ccti_increase;\n\n\t\tppd->congestion_entries[i].ccti_timer =\n\t\t\tbe16_to_cpu(p->entries[i].ccti_timer);\n\n\t\tppd->congestion_entries[i].trigger_threshold =\n\t\t\tp->entries[i].trigger_threshold;\n\n\t\tppd->congestion_entries[i].ccti_min =\n\t\t\tp->entries[i].ccti_min;\n\t}\n\n\treturn reply((struct ib_smp *) ccp);\n}\n\nstatic int cc_set_congestion_control_table(struct ib_cc_mad *ccp,\n\t\t\t\tstruct ib_device *ibdev, u8 port)\n{\n\tstruct ib_cc_table_attr *p =\n\t\t(struct ib_cc_table_attr *)ccp->mgmt_data;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu32 cct_block_index = be32_to_cpu(ccp->attr_mod);\n\tu32 cct_entry;\n\tstruct ib_cc_table_entry_shadow *entries;\n\tint i;\n\n\t \n\tif (cct_block_index > IB_CC_TABLE_CAP_DEFAULT - 1)\n\t\tgoto bail;\n\n\t \n\tif (be16_to_cpu(p->ccti_limit) < IB_CCT_ENTRIES)\n\t\tppd->total_cct_entry = 0;\n\n\tcct_entry = (be16_to_cpu(p->ccti_limit))%IB_CCT_ENTRIES;\n\n\t \n\tppd->total_cct_entry += (cct_entry + 1);\n\n\tif (ppd->total_cct_entry > ppd->cc_supported_table_entries)\n\t\tgoto bail;\n\n\tppd->ccti_limit = be16_to_cpu(p->ccti_limit);\n\n\tentries = ppd->ccti_entries + (IB_CCT_ENTRIES * cct_block_index);\n\n\tfor (i = 0; i <= cct_entry; i++)\n\t\tentries[i].entry = be16_to_cpu(p->ccti_entries[i].entry);\n\n\tspin_lock(&ppd->cc_shadow_lock);\n\n\tppd->ccti_entries_shadow->ccti_last_entry = ppd->total_cct_entry - 1;\n\tmemcpy(ppd->ccti_entries_shadow->entries, ppd->ccti_entries,\n\t\t(ppd->total_cct_entry * sizeof(struct ib_cc_table_entry)));\n\n\tppd->congestion_entries_shadow->port_control = IB_CC_CCS_PC_SL_BASED;\n\tppd->congestion_entries_shadow->control_map = ppd->cc_sl_control_map;\n\tmemcpy(ppd->congestion_entries_shadow->entries, ppd->congestion_entries,\n\t\tIB_CC_CCS_ENTRIES * sizeof(struct ib_cc_congestion_entry));\n\n\tspin_unlock(&ppd->cc_shadow_lock);\n\n\treturn reply((struct ib_smp *) ccp);\n\nbail:\n\treturn reply_failure((struct ib_smp *) ccp);\n}\n\nstatic int process_cc(struct ib_device *ibdev, int mad_flags,\n\t\t\tu8 port, const struct ib_mad *in_mad,\n\t\t\tstruct ib_mad *out_mad)\n{\n\tstruct ib_cc_mad *ccp = (struct ib_cc_mad *)out_mad;\n\t*out_mad = *in_mad;\n\n\tif (ccp->class_version != 2) {\n\t\tccp->status |= IB_SMP_UNSUP_VERSION;\n\t\treturn reply((struct ib_smp *)ccp);\n\t}\n\n\tswitch (ccp->method) {\n\tcase IB_MGMT_METHOD_GET:\n\t\tswitch (ccp->attr_id) {\n\t\tcase IB_CC_ATTR_CLASSPORTINFO:\n\t\t\treturn cc_get_classportinfo(ccp, ibdev);\n\t\tcase IB_CC_ATTR_CONGESTION_INFO:\n\t\t\treturn cc_get_congestion_info(ccp, ibdev, port);\n\t\tcase IB_CC_ATTR_CA_CONGESTION_SETTING:\n\t\t\treturn cc_get_congestion_setting(ccp, ibdev, port);\n\t\tcase IB_CC_ATTR_CONGESTION_CONTROL_TABLE:\n\t\t\treturn cc_get_congestion_control_table(ccp, ibdev, port);\n\t\tdefault:\n\t\t\tccp->status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\treturn reply((struct ib_smp *) ccp);\n\t\t}\n\tcase IB_MGMT_METHOD_SET:\n\t\tswitch (ccp->attr_id) {\n\t\tcase IB_CC_ATTR_CA_CONGESTION_SETTING:\n\t\t\treturn cc_set_congestion_setting(ccp, ibdev, port);\n\t\tcase IB_CC_ATTR_CONGESTION_CONTROL_TABLE:\n\t\t\treturn cc_set_congestion_control_table(ccp, ibdev, port);\n\t\tdefault:\n\t\t\tccp->status |= IB_SMP_UNSUP_METH_ATTR;\n\t\t\treturn reply((struct ib_smp *) ccp);\n\t\t}\n\tcase IB_MGMT_METHOD_GET_RESP:\n\t\t \n\t\treturn IB_MAD_RESULT_SUCCESS;\n\t}\n\n\t \n\tccp->status |= IB_SMP_UNSUP_METHOD;\n\treturn reply((struct ib_smp *) ccp);\n}\n\n \nint qib_process_mad(struct ib_device *ibdev, int mad_flags, u32 port,\n\t\t    const struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t    const struct ib_mad *in, struct ib_mad *out,\n\t\t    size_t *out_mad_size, u16 *out_mad_pkey_index)\n{\n\tint ret;\n\tstruct qib_ibport *ibp = to_iport(ibdev, port);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\n\tswitch (in->mad_hdr.mgmt_class) {\n\tcase IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE:\n\tcase IB_MGMT_CLASS_SUBN_LID_ROUTED:\n\t\tret = process_subn(ibdev, mad_flags, port, in, out);\n\t\tgoto bail;\n\n\tcase IB_MGMT_CLASS_PERF_MGMT:\n\t\tret = process_perf(ibdev, port, in, out);\n\t\tgoto bail;\n\n\tcase IB_MGMT_CLASS_CONG_MGMT:\n\t\tif (!ppd->congestion_entries_shadow ||\n\t\t\t !qib_cc_table_size) {\n\t\t\tret = IB_MAD_RESULT_SUCCESS;\n\t\t\tgoto bail;\n\t\t}\n\t\tret = process_cc(ibdev, mad_flags, port, in, out);\n\t\tgoto bail;\n\n\tdefault:\n\t\tret = IB_MAD_RESULT_SUCCESS;\n\t}\n\nbail:\n\treturn ret;\n}\n\nstatic void xmit_wait_timer_func(struct timer_list *t)\n{\n\tstruct qib_pportdata *ppd = from_timer(ppd, t, cong_stats.timer);\n\tstruct qib_devdata *dd = dd_from_ppd(ppd);\n\tunsigned long flags;\n\tu8 status;\n\n\tspin_lock_irqsave(&ppd->ibport_data.rvp.lock, flags);\n\tif (ppd->cong_stats.flags == IB_PMA_CONG_HW_CONTROL_SAMPLE) {\n\t\tstatus = dd->f_portcntr(ppd, QIBPORTCNTR_PSSTAT);\n\t\tif (status == IB_PMA_SAMPLE_STATUS_DONE) {\n\t\t\t \n\t\t\tcache_hw_sample_counters(ppd);\n\t\t\tppd->cong_stats.flags = IB_PMA_CONG_HW_CONTROL_TIMER;\n\t\t} else\n\t\t\tgoto done;\n\t}\n\tppd->cong_stats.counter = xmit_wait_get_value_delta(ppd);\n\tdd->f_set_cntr_sample(ppd, QIB_CONG_TIMER_PSINTERVAL, 0x0);\ndone:\n\tspin_unlock_irqrestore(&ppd->ibport_data.rvp.lock, flags);\n\tmod_timer(&ppd->cong_stats.timer, jiffies + HZ);\n}\n\nvoid qib_notify_create_mad_agent(struct rvt_dev_info *rdi, int port_idx)\n{\n\tstruct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);\n\tstruct qib_devdata *dd = container_of(ibdev,\n\t\t\t\t\t      struct qib_devdata, verbs_dev);\n\n\t \n\tdd->pport[port_idx].cong_stats.counter = 0;\n\ttimer_setup(&dd->pport[port_idx].cong_stats.timer,\n\t\t    xmit_wait_timer_func, 0);\n\tdd->pport[port_idx].cong_stats.timer.expires = 0;\n\tadd_timer(&dd->pport[port_idx].cong_stats.timer);\n}\n\nvoid qib_notify_free_mad_agent(struct rvt_dev_info *rdi, int port_idx)\n{\n\tstruct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);\n\tstruct qib_devdata *dd = container_of(ibdev,\n\t\t\t\t\t      struct qib_devdata, verbs_dev);\n\n\tif (dd->pport[port_idx].cong_stats.timer.function)\n\t\tdel_timer_sync(&dd->pport[port_idx].cong_stats.timer);\n\n\tif (dd->pport[port_idx].ibport_data.smi_ah)\n\t\trdma_destroy_ah(&dd->pport[port_idx].ibport_data.smi_ah->ibah,\n\t\t\t\tRDMA_DESTROY_AH_SLEEPABLE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}