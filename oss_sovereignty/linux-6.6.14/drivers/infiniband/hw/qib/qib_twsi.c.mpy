{
  "module_name": "qib_twsi.c",
  "hash_id": "eb594ccabf4df183824b821696071e67fec19db6284913272589efa327e18b29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_twsi.c",
  "human_readable_source": " \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/vmalloc.h>\n\n#include \"qib.h\"\n\n \n\n#define READ_CMD 1\n#define WRITE_CMD 0\n\n \nstatic void i2c_wait_for_writes(struct qib_devdata *dd)\n{\n\t \n\tdd->f_gpio_mod(dd, 0, 0, 0);\n\trmb();  \n}\n\n \n#define SCL_WAIT_USEC 1000\n\n \n#define TWSI_BUF_WAIT_USEC 60\n\nstatic void scl_out(struct qib_devdata *dd, u8 bit)\n{\n\tu32 mask;\n\n\tudelay(1);\n\n\tmask = 1UL << dd->gpio_scl_num;\n\n\t \n\tdd->f_gpio_mod(dd, 0, bit ? 0 : mask, mask);\n\n\t \n\tif (!bit)\n\t\tudelay(2);\n\telse {\n\t\tint rise_usec;\n\n\t\tfor (rise_usec = SCL_WAIT_USEC; rise_usec > 0; rise_usec -= 2) {\n\t\t\tif (mask & dd->f_gpio_mod(dd, 0, 0, 0))\n\t\t\t\tbreak;\n\t\t\tudelay(2);\n\t\t}\n\t\tif (rise_usec <= 0)\n\t\t\tqib_dev_err(dd, \"SCL interface stuck low > %d uSec\\n\",\n\t\t\t\t    SCL_WAIT_USEC);\n\t}\n\ti2c_wait_for_writes(dd);\n}\n\nstatic void sda_out(struct qib_devdata *dd, u8 bit)\n{\n\tu32 mask;\n\n\tmask = 1UL << dd->gpio_sda_num;\n\n\t \n\tdd->f_gpio_mod(dd, 0, bit ? 0 : mask, mask);\n\n\ti2c_wait_for_writes(dd);\n\tudelay(2);\n}\n\nstatic u8 sda_in(struct qib_devdata *dd, int wait)\n{\n\tint bnum;\n\tu32 read_val, mask;\n\n\tbnum = dd->gpio_sda_num;\n\tmask = (1UL << bnum);\n\t \n\tdd->f_gpio_mod(dd, 0, 0, mask);\n\tread_val = dd->f_gpio_mod(dd, 0, 0, 0);\n\tif (wait)\n\t\ti2c_wait_for_writes(dd);\n\treturn (read_val & mask) >> bnum;\n}\n\n \nstatic int i2c_ackrcv(struct qib_devdata *dd)\n{\n\tu8 ack_received;\n\n\t \n\t \n\tack_received = sda_in(dd, 1);\n\tscl_out(dd, 1);\n\tack_received = sda_in(dd, 1) == 0;\n\tscl_out(dd, 0);\n\treturn ack_received;\n}\n\nstatic void stop_cmd(struct qib_devdata *dd);\n\n \nstatic int rd_byte(struct qib_devdata *dd, int last)\n{\n\tint bit_cntr, data;\n\n\tdata = 0;\n\n\tfor (bit_cntr = 7; bit_cntr >= 0; --bit_cntr) {\n\t\tdata <<= 1;\n\t\tscl_out(dd, 1);\n\t\tdata |= sda_in(dd, 0);\n\t\tscl_out(dd, 0);\n\t}\n\tif (last) {\n\t\tscl_out(dd, 1);\n\t\tstop_cmd(dd);\n\t} else {\n\t\tsda_out(dd, 0);\n\t\tscl_out(dd, 1);\n\t\tscl_out(dd, 0);\n\t\tsda_out(dd, 1);\n\t}\n\treturn data;\n}\n\n \nstatic int wr_byte(struct qib_devdata *dd, u8 data)\n{\n\tint bit_cntr;\n\tu8 bit;\n\n\tfor (bit_cntr = 7; bit_cntr >= 0; bit_cntr--) {\n\t\tbit = (data >> bit_cntr) & 1;\n\t\tsda_out(dd, bit);\n\t\tscl_out(dd, 1);\n\t\tscl_out(dd, 0);\n\t}\n\treturn (!i2c_ackrcv(dd)) ? 1 : 0;\n}\n\n \nstatic void start_seq(struct qib_devdata *dd)\n{\n\tsda_out(dd, 1);\n\tscl_out(dd, 1);\n\tsda_out(dd, 0);\n\tudelay(1);\n\tscl_out(dd, 0);\n}\n\n \nstatic void stop_seq(struct qib_devdata *dd)\n{\n\tscl_out(dd, 0);\n\tsda_out(dd, 0);\n\tscl_out(dd, 1);\n\tsda_out(dd, 1);\n}\n\n \nstatic void stop_cmd(struct qib_devdata *dd)\n{\n\tstop_seq(dd);\n\tudelay(TWSI_BUF_WAIT_USEC);\n}\n\n \n\nint qib_twsi_reset(struct qib_devdata *dd)\n{\n\tint clock_cycles_left = 9;\n\tint was_high = 0;\n\tu32 pins, mask;\n\n\t \n\tmask = (1UL << dd->gpio_scl_num) | (1UL << dd->gpio_sda_num);\n\n\t \n\tdd->f_gpio_mod(dd, 0, 0, mask);\n\n\t \n\twhile (clock_cycles_left--) {\n\t\tscl_out(dd, 0);\n\t\tscl_out(dd, 1);\n\t\t \n\t\twas_high |= sda_in(dd, 0);\n\t}\n\n\tif (was_high) {\n\t\t \n\n\t\tpins = dd->f_gpio_mod(dd, 0, 0, 0);\n\t\tif ((pins & mask) != mask)\n\t\t\tqib_dev_err(dd, \"GPIO pins not at rest: %d\\n\",\n\t\t\t\t    pins & mask);\n\t\t \n\t\tudelay(1);  \n\t\tsda_out(dd, 0);\n\t\tudelay(1);  \n\t\t \n\t\tsda_out(dd, 1);\n\t\tudelay(TWSI_BUF_WAIT_USEC);\n\t}\n\n\treturn !was_high;\n}\n\n#define QIB_TWSI_START 0x100\n#define QIB_TWSI_STOP 0x200\n\n \nstatic int qib_twsi_wr(struct qib_devdata *dd, int data, int flags)\n{\n\tint ret = 1;\n\n\tif (flags & QIB_TWSI_START)\n\t\tstart_seq(dd);\n\n\tret = wr_byte(dd, data);  \n\n\tif (flags & QIB_TWSI_STOP)\n\t\tstop_cmd(dd);\n\treturn ret;\n}\n\n \n#define QIB_TEMP_DEV 0x98\n\n \nint qib_twsi_blk_rd(struct qib_devdata *dd, int dev, int addr,\n\t\t    void *buffer, int len)\n{\n\tint ret;\n\tu8 *bp = buffer;\n\n\tret = 1;\n\n\tif (dev == QIB_TWSI_NO_DEV) {\n\t\t \n\t\taddr = (addr << 1) | READ_CMD;\n\t\tret = qib_twsi_wr(dd, addr, QIB_TWSI_START);\n\t} else {\n\t\t \n\t\tret = qib_twsi_wr(dd, dev | WRITE_CMD, QIB_TWSI_START);\n\t\tif (ret) {\n\t\t\tstop_cmd(dd);\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tret = qib_twsi_wr(dd, addr, 0);\n\t\tudelay(TWSI_BUF_WAIT_USEC);\n\n\t\tif (ret) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Failed to write interface read addr %02X\\n\",\n\t\t\t\taddr);\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\t\tret = qib_twsi_wr(dd, dev | READ_CMD, QIB_TWSI_START);\n\t}\n\tif (ret) {\n\t\tstop_cmd(dd);\n\t\tret = 1;\n\t\tgoto bail;\n\t}\n\n\t \n\twhile (len-- > 0) {\n\t\t \n\t\t*bp++ = rd_byte(dd, !len);\n\t}\n\n\tret = 0;\n\nbail:\n\treturn ret;\n}\n\n \nint qib_twsi_blk_wr(struct qib_devdata *dd, int dev, int addr,\n\t\t    const void *buffer, int len)\n{\n\tint sub_len;\n\tconst u8 *bp = buffer;\n\tint max_wait_time, i;\n\tint ret = 1;\n\n\twhile (len > 0) {\n\t\tif (dev == QIB_TWSI_NO_DEV) {\n\t\t\tif (qib_twsi_wr(dd, (addr << 1) | WRITE_CMD,\n\t\t\t\t\tQIB_TWSI_START)) {\n\t\t\t\tgoto failed_write;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (qib_twsi_wr(dd, dev | WRITE_CMD, QIB_TWSI_START))\n\t\t\t\tgoto failed_write;\n\t\t\tret = qib_twsi_wr(dd, addr, 0);\n\t\t\tif (ret) {\n\t\t\t\tqib_dev_err(dd,\n\t\t\t\t\t\"Failed to write interface write addr %02X\\n\",\n\t\t\t\t\taddr);\n\t\t\t\tgoto failed_write;\n\t\t\t}\n\t\t}\n\n\t\tsub_len = min(len, 4);\n\t\taddr += sub_len;\n\t\tlen -= sub_len;\n\n\t\tfor (i = 0; i < sub_len; i++)\n\t\t\tif (qib_twsi_wr(dd, *bp++, 0))\n\t\t\t\tgoto failed_write;\n\n\t\tstop_cmd(dd);\n\n\t\t \n\t\tmax_wait_time = 100;\n\t\twhile (qib_twsi_wr(dd, dev | READ_CMD, QIB_TWSI_START)) {\n\t\t\tstop_cmd(dd);\n\t\t\tif (!--max_wait_time)\n\t\t\t\tgoto failed_write;\n\t\t}\n\t\t \n\t\trd_byte(dd, 1);\n\t}\n\n\tret = 0;\n\tgoto bail;\n\nfailed_write:\n\tstop_cmd(dd);\n\tret = 1;\n\nbail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}