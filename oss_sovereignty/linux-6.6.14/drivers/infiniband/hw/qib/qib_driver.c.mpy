{
  "module_name": "qib_driver.c",
  "hash_id": "e4d6e541b42f39dec75724b2694eb9dd2b01ec8a2ea45533b4dea8da9342ab47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_driver.c",
  "human_readable_source": " \n\n#include <linux/spinlock.h>\n#include <linux/pci.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/netdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/prefetch.h>\n\n#include \"qib.h\"\n\n \nconst char ib_qib_version[] = QIB_DRIVER_VERSION \"\\n\";\n\nDEFINE_MUTEX(qib_mutex);\t \n\nunsigned qib_ibmtu;\nmodule_param_named(ibmtu, qib_ibmtu, uint, S_IRUGO);\nMODULE_PARM_DESC(ibmtu, \"Set max IB MTU (0=2KB, 1=256, 2=512, ... 5=4096\");\n\nunsigned qib_compat_ddr_negotiate = 1;\nmodule_param_named(compat_ddr_negotiate, qib_compat_ddr_negotiate, uint,\n\t\t   S_IWUSR | S_IRUGO);\nMODULE_PARM_DESC(compat_ddr_negotiate,\n\t\t \"Attempt pre-IBTA 1.2 DDR speed negotiation\");\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Cornelis <support@cornelisnetworks.com>\");\nMODULE_DESCRIPTION(\"Cornelis IB driver\");\n\n \n#define QIB_PIO_MAXIBHDR 128\n\n \n#define QIB_MAX_PKT_RECV 64\n\nstruct qlogic_ib_stats qib_stats;\n\nstruct pci_dev *qib_get_pci_dev(struct rvt_dev_info *rdi)\n{\n\tstruct qib_ibdev *ibdev = container_of(rdi, struct qib_ibdev, rdi);\n\tstruct qib_devdata *dd = container_of(ibdev,\n\t\t\t\t\t      struct qib_devdata, verbs_dev);\n\treturn dd->pcidev;\n}\n\n \nint qib_count_active_units(void)\n{\n\tstruct qib_devdata *dd;\n\tstruct qib_pportdata *ppd;\n\tunsigned long index, flags;\n\tint pidx, nunits_active = 0;\n\n\txa_lock_irqsave(&qib_dev_table, flags);\n\txa_for_each(&qib_dev_table, index, dd) {\n\t\tif (!(dd->flags & QIB_PRESENT) || !dd->kregbase)\n\t\t\tcontinue;\n\t\tfor (pidx = 0; pidx < dd->num_pports; ++pidx) {\n\t\t\tppd = dd->pport + pidx;\n\t\t\tif (ppd->lid && (ppd->lflags & (QIBL_LINKINIT |\n\t\t\t\t\t QIBL_LINKARMED | QIBL_LINKACTIVE))) {\n\t\t\t\tnunits_active++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\txa_unlock_irqrestore(&qib_dev_table, flags);\n\treturn nunits_active;\n}\n\n \nint qib_count_units(int *npresentp, int *nupp)\n{\n\tint nunits = 0, npresent = 0, nup = 0;\n\tstruct qib_devdata *dd;\n\tunsigned long index, flags;\n\tint pidx;\n\tstruct qib_pportdata *ppd;\n\n\txa_lock_irqsave(&qib_dev_table, flags);\n\txa_for_each(&qib_dev_table, index, dd) {\n\t\tnunits++;\n\t\tif ((dd->flags & QIB_PRESENT) && dd->kregbase)\n\t\t\tnpresent++;\n\t\tfor (pidx = 0; pidx < dd->num_pports; ++pidx) {\n\t\t\tppd = dd->pport + pidx;\n\t\t\tif (ppd->lid && (ppd->lflags & (QIBL_LINKINIT |\n\t\t\t\t\t QIBL_LINKARMED | QIBL_LINKACTIVE)))\n\t\t\t\tnup++;\n\t\t}\n\t}\n\txa_unlock_irqrestore(&qib_dev_table, flags);\n\n\tif (npresentp)\n\t\t*npresentp = npresent;\n\tif (nupp)\n\t\t*nupp = nup;\n\n\treturn nunits;\n}\n\n \nint qib_wait_linkstate(struct qib_pportdata *ppd, u32 state, int msecs)\n{\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tif (ppd->state_wanted) {\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\tret = -EBUSY;\n\t\tgoto bail;\n\t}\n\tppd->state_wanted = state;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\twait_event_interruptible_timeout(ppd->state_wait,\n\t\t\t\t\t (ppd->lflags & state),\n\t\t\t\t\t msecs_to_jiffies(msecs));\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tppd->state_wanted = 0;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\n\tif (!(ppd->lflags & state))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = 0;\nbail:\n\treturn ret;\n}\n\nint qib_set_linkstate(struct qib_pportdata *ppd, u8 newstate)\n{\n\tu32 lstate;\n\tint ret;\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\n\tswitch (newstate) {\n\tcase QIB_IB_LINKDOWN_ONLY:\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_DOWN | IB_LINKINITCMD_NOP);\n\t\t \n\t\tret = 0;\n\t\tgoto bail;\n\n\tcase QIB_IB_LINKDOWN:\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_DOWN | IB_LINKINITCMD_POLL);\n\t\t \n\t\tret = 0;\n\t\tgoto bail;\n\n\tcase QIB_IB_LINKDOWN_SLEEP:\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_DOWN | IB_LINKINITCMD_SLEEP);\n\t\t \n\t\tret = 0;\n\t\tgoto bail;\n\n\tcase QIB_IB_LINKDOWN_DISABLE:\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_DOWN | IB_LINKINITCMD_DISABLE);\n\t\t \n\t\tret = 0;\n\t\tgoto bail;\n\n\tcase QIB_IB_LINKARM:\n\t\tif (ppd->lflags & QIBL_LINKARMED) {\n\t\t\tret = 0;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!(ppd->lflags & (QIBL_LINKINIT | QIBL_LINKACTIVE))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags &= ~QIBL_LINKV;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_ARMED | IB_LINKINITCMD_NOP);\n\t\tlstate = QIBL_LINKV;\n\t\tbreak;\n\n\tcase QIB_IB_LINKACTIVE:\n\t\tif (ppd->lflags & QIBL_LINKACTIVE) {\n\t\t\tret = 0;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (!(ppd->lflags & QIBL_LINKARMED)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LSTATE,\n\t\t\t\t IB_LINKCMD_ACTIVE | IB_LINKINITCMD_NOP);\n\t\tlstate = QIBL_LINKACTIVE;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tret = qib_wait_linkstate(ppd, lstate, 10);\n\nbail:\n\treturn ret;\n}\n\n \nstatic inline void *qib_get_egrbuf(const struct qib_ctxtdata *rcd, u32 etail)\n{\n\tconst u32 chunk = etail >> rcd->rcvegrbufs_perchunk_shift;\n\tconst u32 idx =  etail & ((u32)rcd->rcvegrbufs_perchunk - 1);\n\n\treturn rcd->rcvegrbuf[chunk] + (idx << rcd->dd->rcvegrbufsize_shift);\n}\n\n \nstatic u32 qib_rcv_hdrerr(struct qib_ctxtdata *rcd, struct qib_pportdata *ppd,\n\t\t\t  u32 ctxt, u32 eflags, u32 l, u32 etail,\n\t\t\t  __le32 *rhf_addr, struct qib_message_header *rhdr)\n{\n\tu32 ret = 0;\n\n\tif (eflags & (QLOGIC_IB_RHF_H_ICRCERR | QLOGIC_IB_RHF_H_VCRCERR))\n\t\tret = 1;\n\telse if (eflags == QLOGIC_IB_RHF_H_TIDERR) {\n\t\t \n\t\tstruct ib_header *hdr = (struct ib_header *)rhdr;\n\t\tstruct ib_other_headers *ohdr = NULL;\n\t\tstruct qib_ibport *ibp = &ppd->ibport_data;\n\t\tstruct qib_devdata *dd = ppd->dd;\n\t\tstruct rvt_dev_info *rdi = &dd->verbs_dev.rdi;\n\t\tstruct rvt_qp *qp = NULL;\n\t\tu32 tlen = qib_hdrget_length_in_bytes(rhf_addr);\n\t\tu16 lid  = be16_to_cpu(hdr->lrh[1]);\n\t\tint lnh = be16_to_cpu(hdr->lrh[0]) & 3;\n\t\tu32 qp_num;\n\t\tu32 opcode;\n\t\tu32 psn;\n\t\tint diff;\n\n\t\t \n\t\tif (tlen < 24)\n\t\t\tgoto drop;\n\n\t\tif (lid < be16_to_cpu(IB_MULTICAST_LID_BASE)) {\n\t\t\tlid &= ~((1 << ppd->lmc) - 1);\n\t\t\tif (unlikely(lid != ppd->lid))\n\t\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (lnh == QIB_LRH_BTH)\n\t\t\tohdr = &hdr->u.oth;\n\t\telse if (lnh == QIB_LRH_GRH) {\n\t\t\tu32 vtf;\n\n\t\t\tohdr = &hdr->u.l.oth;\n\t\t\tif (hdr->u.l.grh.next_hdr != IB_GRH_NEXT_HDR)\n\t\t\t\tgoto drop;\n\t\t\tvtf = be32_to_cpu(hdr->u.l.grh.version_tclass_flow);\n\t\t\tif ((vtf >> IB_GRH_VERSION_SHIFT) != IB_GRH_VERSION)\n\t\t\t\tgoto drop;\n\t\t} else\n\t\t\tgoto drop;\n\n\t\t \n\t\topcode = be32_to_cpu(ohdr->bth[0]);\n\t\topcode >>= 24;\n\t\tpsn = be32_to_cpu(ohdr->bth[2]);\n\n\t\t \n\t\tqp_num = be32_to_cpu(ohdr->bth[1]) & RVT_QPN_MASK;\n\t\tif (qp_num != QIB_MULTICAST_QPN) {\n\t\t\tint ruc_res;\n\n\t\t\trcu_read_lock();\n\t\t\tqp = rvt_lookup_qpn(rdi, &ibp->rvp, qp_num);\n\t\t\tif (!qp) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto drop;\n\t\t\t}\n\n\t\t\t \n\t\t\tspin_lock(&qp->r_lock);\n\n\t\t\t \n\t\t\tif (!(ib_rvt_state_ops[qp->state] &\n\t\t\t      RVT_PROCESS_RECV_OK)) {\n\t\t\t\tibp->rvp.n_pkt_drops++;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tswitch (qp->ibqp.qp_type) {\n\t\t\tcase IB_QPT_RC:\n\t\t\t\truc_res =\n\t\t\t\t\tqib_ruc_check_hdr(\n\t\t\t\t\t\tibp, hdr,\n\t\t\t\t\t\tlnh == QIB_LRH_GRH,\n\t\t\t\t\t\tqp,\n\t\t\t\t\t\tbe32_to_cpu(ohdr->bth[0]));\n\t\t\t\tif (ruc_res)\n\t\t\t\t\tgoto unlock;\n\n\t\t\t\t \n\t\t\t\tif (opcode <\n\t\t\t\t    IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST) {\n\t\t\t\t\tdiff = qib_cmp24(psn, qp->r_psn);\n\t\t\t\t\tif (!qp->r_nak_state && diff >= 0) {\n\t\t\t\t\t\tibp->rvp.n_rc_seqnak++;\n\t\t\t\t\t\tqp->r_nak_state =\n\t\t\t\t\t\t\tIB_NAK_PSN_ERROR;\n\t\t\t\t\t\t \n\t\t\t\t\t\tqp->r_ack_psn = qp->r_psn;\n\t\t\t\t\t\t \n\t\t\t\t\t\tif (list_empty(&qp->rspwait)) {\n\t\t\t\t\t\t\tqp->r_flags |=\n\t\t\t\t\t\t\t\tRVT_R_RSP_NAK;\n\t\t\t\t\t\t\trvt_get_qp(qp);\n\t\t\t\t\t\t\tlist_add_tail(\n\t\t\t\t\t\t\t &qp->rspwait,\n\t\t\t\t\t\t\t &rcd->qp_wait_list);\n\t\t\t\t\t\t}\n\t\t\t\t\t}  \n\t\t\t\t}  \n\t\t\t\tbreak;\n\t\t\tcase IB_QPT_SMI:\n\t\t\tcase IB_QPT_GSI:\n\t\t\tcase IB_QPT_UD:\n\t\t\tcase IB_QPT_UC:\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\nunlock:\n\t\t\tspin_unlock(&qp->r_lock);\n\t\t\trcu_read_unlock();\n\t\t}  \n\t}  \n\ndrop:\n\treturn ret;\n}\n\n \nu32 qib_kreceive(struct qib_ctxtdata *rcd, u32 *llic, u32 *npkts)\n{\n\tstruct qib_devdata *dd = rcd->dd;\n\tstruct qib_pportdata *ppd = rcd->ppd;\n\t__le32 *rhf_addr;\n\tvoid *ebuf;\n\tconst u32 rsize = dd->rcvhdrentsize;         \n\tconst u32 maxcnt = dd->rcvhdrcnt * rsize;    \n\tu32 etail = -1, l, hdrqtail;\n\tstruct qib_message_header *hdr;\n\tu32 eflags, etype, tlen, i = 0, updegr = 0, crcs = 0;\n\tint last;\n\tu64 lval;\n\tstruct rvt_qp *qp, *nqp;\n\n\tl = rcd->head;\n\trhf_addr = (__le32 *) rcd->rcvhdrq + l + dd->rhf_offset;\n\tif (dd->flags & QIB_NODMA_RTAIL) {\n\t\tu32 seq = qib_hdrget_seq(rhf_addr);\n\n\t\tif (seq != rcd->seq_cnt)\n\t\t\tgoto bail;\n\t\thdrqtail = 0;\n\t} else {\n\t\thdrqtail = qib_get_rcvhdrtail(rcd);\n\t\tif (l == hdrqtail)\n\t\t\tgoto bail;\n\t\tsmp_rmb();   \n\t}\n\n\tfor (last = 0, i = 1; !last; i += !last) {\n\t\thdr = dd->f_get_msgheader(dd, rhf_addr);\n\t\teflags = qib_hdrget_err_flags(rhf_addr);\n\t\tetype = qib_hdrget_rcv_type(rhf_addr);\n\t\t \n\t\ttlen = qib_hdrget_length_in_bytes(rhf_addr);\n\t\tebuf = NULL;\n\t\tif ((dd->flags & QIB_NODMA_RTAIL) ?\n\t\t    qib_hdrget_use_egr_buf(rhf_addr) :\n\t\t    (etype != RCVHQ_RCV_TYPE_EXPECTED)) {\n\t\t\tetail = qib_hdrget_index(rhf_addr);\n\t\t\tupdegr = 1;\n\t\t\tif (tlen > sizeof(*hdr) ||\n\t\t\t    etype >= RCVHQ_RCV_TYPE_NON_KD) {\n\t\t\t\tebuf = qib_get_egrbuf(rcd, etail);\n\t\t\t\tprefetch_range(ebuf, tlen - sizeof(*hdr));\n\t\t\t}\n\t\t}\n\t\tif (!eflags) {\n\t\t\tu16 lrh_len = be16_to_cpu(hdr->lrh[2]) << 2;\n\n\t\t\tif (lrh_len != tlen) {\n\t\t\t\tqib_stats.sps_lenerrs++;\n\t\t\t\tgoto move_along;\n\t\t\t}\n\t\t}\n\t\tif (etype == RCVHQ_RCV_TYPE_NON_KD && !eflags &&\n\t\t    ebuf == NULL &&\n\t\t    tlen > (dd->rcvhdrentsize - 2 + 1 -\n\t\t\t\tqib_hdrget_offset(rhf_addr)) << 2) {\n\t\t\tgoto move_along;\n\t\t}\n\n\t\t \n\t\tif (unlikely(eflags))\n\t\t\tcrcs += qib_rcv_hdrerr(rcd, ppd, rcd->ctxt, eflags, l,\n\t\t\t\t\t       etail, rhf_addr, hdr);\n\t\telse if (etype == RCVHQ_RCV_TYPE_NON_KD) {\n\t\t\tqib_ib_rcv(rcd, hdr, ebuf, tlen);\n\t\t\tif (crcs)\n\t\t\t\tcrcs--;\n\t\t\telse if (llic && *llic)\n\t\t\t\t--*llic;\n\t\t}\nmove_along:\n\t\tl += rsize;\n\t\tif (l >= maxcnt)\n\t\t\tl = 0;\n\t\tif (i == QIB_MAX_PKT_RECV)\n\t\t\tlast = 1;\n\n\t\trhf_addr = (__le32 *) rcd->rcvhdrq + l + dd->rhf_offset;\n\t\tif (dd->flags & QIB_NODMA_RTAIL) {\n\t\t\tu32 seq = qib_hdrget_seq(rhf_addr);\n\n\t\t\tif (++rcd->seq_cnt > 13)\n\t\t\t\trcd->seq_cnt = 1;\n\t\t\tif (seq != rcd->seq_cnt)\n\t\t\t\tlast = 1;\n\t\t} else if (l == hdrqtail)\n\t\t\tlast = 1;\n\t\t \n\t\tlval = l;\n\t\tif (!last && !(i & 0xf)) {\n\t\t\tdd->f_update_usrhead(rcd, lval, updegr, etail, i);\n\t\t\tupdegr = 0;\n\t\t}\n\t}\n\n\trcd->head = l;\n\n\t \n\tlist_for_each_entry_safe(qp, nqp, &rcd->qp_wait_list, rspwait) {\n\t\tlist_del_init(&qp->rspwait);\n\t\tif (qp->r_flags & RVT_R_RSP_NAK) {\n\t\t\tqp->r_flags &= ~RVT_R_RSP_NAK;\n\t\t\tqib_send_rc_ack(qp);\n\t\t}\n\t\tif (qp->r_flags & RVT_R_RSP_SEND) {\n\t\t\tunsigned long flags;\n\n\t\t\tqp->r_flags &= ~RVT_R_RSP_SEND;\n\t\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\t\tif (ib_rvt_state_ops[qp->state] &\n\t\t\t\t\tRVT_PROCESS_OR_FLUSH_SEND)\n\t\t\t\tqib_schedule_send(qp);\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t}\n\t\trvt_put_qp(qp);\n\t}\n\nbail:\n\t \n\tif (npkts)\n\t\t*npkts = i;\n\n\t \n\tlval = (u64)rcd->head | dd->rhdrhead_intr_off;\n\tdd->f_update_usrhead(rcd, lval, updegr, etail, i);\n\treturn crcs;\n}\n\n \nint qib_set_mtu(struct qib_pportdata *ppd, u16 arg)\n{\n\tu32 piosize;\n\tint ret, chk;\n\n\tif (arg != 256 && arg != 512 && arg != 1024 && arg != 2048 &&\n\t    arg != 4096) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\tchk = ib_mtu_enum_to_int(qib_ibmtu);\n\tif (chk > 0 && arg > chk) {\n\t\tret = -EINVAL;\n\t\tgoto bail;\n\t}\n\n\tpiosize = ppd->ibmaxlen;\n\tppd->ibmtu = arg;\n\n\tif (arg >= (piosize - QIB_PIO_MAXIBHDR)) {\n\t\t \n\t\tif (piosize != ppd->init_ibmaxlen) {\n\t\t\tif (arg > piosize && arg <= ppd->init_ibmaxlen)\n\t\t\t\tpiosize = ppd->init_ibmaxlen - 2 * sizeof(u32);\n\t\t\tppd->ibmaxlen = piosize;\n\t\t}\n\t} else if ((arg + QIB_PIO_MAXIBHDR) != ppd->ibmaxlen) {\n\t\tpiosize = arg + QIB_PIO_MAXIBHDR - 2 * sizeof(u32);\n\t\tppd->ibmaxlen = piosize;\n\t}\n\n\tppd->dd->f_set_ib_cfg(ppd, QIB_IB_CFG_MTU, 0);\n\n\tret = 0;\n\nbail:\n\treturn ret;\n}\n\nint qib_set_lid(struct qib_pportdata *ppd, u32 lid, u8 lmc)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\n\tppd->lid = lid;\n\tppd->lmc = lmc;\n\n\tdd->f_set_ib_cfg(ppd, QIB_IB_CFG_LIDLMC,\n\t\t\t lid | (~((1U << lmc) - 1)) << 16);\n\n\tqib_devinfo(dd->pcidev, \"IB%u:%u got a lid: 0x%x\\n\",\n\t\t    dd->unit, ppd->port, lid);\n\n\treturn 0;\n}\n\n \n#define LED_OVER_FREQ_SHIFT 8\n#define LED_OVER_FREQ_MASK (0xFF<<LED_OVER_FREQ_SHIFT)\n \n#define LED_OVER_BOTH_OFF (8)\n\nstatic void qib_run_led_override(struct timer_list *t)\n{\n\tstruct qib_pportdata *ppd = from_timer(ppd, t,\n\t\t\t\t\t\t    led_override_timer);\n\tstruct qib_devdata *dd = ppd->dd;\n\tint timeoff;\n\tint ph_idx;\n\n\tif (!(dd->flags & QIB_INITTED))\n\t\treturn;\n\n\tph_idx = ppd->led_override_phase++ & 1;\n\tppd->led_override = ppd->led_override_vals[ph_idx];\n\ttimeoff = ppd->led_override_timeoff;\n\n\tdd->f_setextled(ppd, 1);\n\t \n\tif (ppd->led_override_vals[0] || ppd->led_override_vals[1])\n\t\tmod_timer(&ppd->led_override_timer, jiffies + timeoff);\n}\n\nvoid qib_set_led_override(struct qib_pportdata *ppd, unsigned int val)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tint timeoff, freq;\n\n\tif (!(dd->flags & QIB_INITTED))\n\t\treturn;\n\n\t \n\ttimeoff = HZ;\n\tfreq = (val & LED_OVER_FREQ_MASK) >> LED_OVER_FREQ_SHIFT;\n\n\tif (freq) {\n\t\t \n\t\tppd->led_override_vals[0] = val & 0xF;\n\t\tppd->led_override_vals[1] = (val >> 4) & 0xF;\n\t\ttimeoff = (HZ << 4)/freq;\n\t} else {\n\t\t \n\t\tppd->led_override_vals[0] = val & 0xF;\n\t\tppd->led_override_vals[1] = val & 0xF;\n\t}\n\tppd->led_override_timeoff = timeoff;\n\n\t \n\tif (atomic_inc_return(&ppd->led_override_timer_active) == 1) {\n\t\t \n\t\ttimer_setup(&ppd->led_override_timer, qib_run_led_override, 0);\n\t\tppd->led_override_timer.expires = jiffies + 1;\n\t\tadd_timer(&ppd->led_override_timer);\n\t} else {\n\t\tif (ppd->led_override_vals[0] || ppd->led_override_vals[1])\n\t\t\tmod_timer(&ppd->led_override_timer, jiffies + 1);\n\t\tatomic_dec(&ppd->led_override_timer_active);\n\t}\n}\n\n \nint qib_reset_device(int unit)\n{\n\tint ret, i;\n\tstruct qib_devdata *dd = qib_lookup(unit);\n\tstruct qib_pportdata *ppd;\n\tunsigned long flags;\n\tint pidx;\n\n\tif (!dd) {\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tqib_devinfo(dd->pcidev, \"Reset on unit %u requested\\n\", unit);\n\n\tif (!dd->kregbase || !(dd->flags & QIB_PRESENT)) {\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Invalid unit number %u or not initialized or not present\\n\",\n\t\t\tunit);\n\t\tret = -ENXIO;\n\t\tgoto bail;\n\t}\n\n\tspin_lock_irqsave(&dd->uctxt_lock, flags);\n\tif (dd->rcd)\n\t\tfor (i = dd->first_user_ctxt; i < dd->cfgctxts; i++) {\n\t\t\tif (!dd->rcd[i] || !dd->rcd[i]->cnt)\n\t\t\t\tcontinue;\n\t\t\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\t\t\tret = -EBUSY;\n\t\t\tgoto bail;\n\t\t}\n\tspin_unlock_irqrestore(&dd->uctxt_lock, flags);\n\n\tfor (pidx = 0; pidx < dd->num_pports; ++pidx) {\n\t\tppd = dd->pport + pidx;\n\t\tif (atomic_read(&ppd->led_override_timer_active)) {\n\t\t\t \n\t\t\tdel_timer_sync(&ppd->led_override_timer);\n\t\t\tatomic_set(&ppd->led_override_timer_active, 0);\n\t\t}\n\n\t\t \n\t\tppd->led_override = LED_OVER_BOTH_OFF;\n\t\tdd->f_setextled(ppd, 0);\n\t\tif (dd->flags & QIB_HAS_SEND_DMA)\n\t\t\tqib_teardown_sdma(ppd);\n\t}\n\n\tret = dd->f_reset(dd);\n\tif (ret == 1)\n\t\tret = qib_init(dd, 1);\n\telse\n\t\tret = -EAGAIN;\n\tif (ret)\n\t\tqib_dev_err(dd,\n\t\t\t\"Reinitialize unit %u after reset failed with %d\\n\",\n\t\t\tunit, ret);\n\telse\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Reinitialized unit %u after resetting\\n\",\n\t\t\tunit);\n\nbail:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}