{
  "module_name": "qib_iba6120.c",
  "hash_id": "9320fa8daec954aa8e670b3793401b1054751112ef74025a9f8e4f455cc52f1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_iba6120.c",
  "human_readable_source": " \n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <rdma/ib_verbs.h>\n\n#include \"qib.h\"\n#include \"qib_6120_regs.h\"\n\nstatic void qib_6120_setup_setextled(struct qib_pportdata *, u32);\nstatic void sendctrl_6120_mod(struct qib_pportdata *ppd, u32 op);\nstatic u8 qib_6120_phys_portstate(u64);\nstatic u32 qib_6120_iblink_state(u64);\n\n \n\n \n#define KREG_IDX(regname) (QIB_6120_##regname##_OFFS / sizeof(u64))\n\n \n#define kr_extctrl KREG_IDX(EXTCtrl)\n#define kr_extstatus KREG_IDX(EXTStatus)\n#define kr_gpio_clear KREG_IDX(GPIOClear)\n#define kr_gpio_mask KREG_IDX(GPIOMask)\n#define kr_gpio_out KREG_IDX(GPIOOut)\n#define kr_gpio_status KREG_IDX(GPIOStatus)\n#define kr_rcvctrl KREG_IDX(RcvCtrl)\n#define kr_sendctrl KREG_IDX(SendCtrl)\n#define kr_partitionkey KREG_IDX(RcvPartitionKey)\n#define kr_hwdiagctrl KREG_IDX(HwDiagCtrl)\n#define kr_ibcstatus KREG_IDX(IBCStatus)\n#define kr_ibcctrl KREG_IDX(IBCCtrl)\n#define kr_sendbuffererror KREG_IDX(SendBufErr0)\n#define kr_rcvbthqp KREG_IDX(RcvBTHQP)\n#define kr_counterregbase KREG_IDX(CntrRegBase)\n#define kr_palign KREG_IDX(PageAlign)\n#define kr_rcvegrbase KREG_IDX(RcvEgrBase)\n#define kr_rcvegrcnt KREG_IDX(RcvEgrCnt)\n#define kr_rcvhdrcnt KREG_IDX(RcvHdrCnt)\n#define kr_rcvhdrentsize KREG_IDX(RcvHdrEntSize)\n#define kr_rcvhdrsize KREG_IDX(RcvHdrSize)\n#define kr_rcvtidbase KREG_IDX(RcvTIDBase)\n#define kr_rcvtidcnt KREG_IDX(RcvTIDCnt)\n#define kr_scratch KREG_IDX(Scratch)\n#define kr_sendctrl KREG_IDX(SendCtrl)\n#define kr_sendpioavailaddr KREG_IDX(SendPIOAvailAddr)\n#define kr_sendpiobufbase KREG_IDX(SendPIOBufBase)\n#define kr_sendpiobufcnt KREG_IDX(SendPIOBufCnt)\n#define kr_sendpiosize KREG_IDX(SendPIOSize)\n#define kr_sendregbase KREG_IDX(SendRegBase)\n#define kr_userregbase KREG_IDX(UserRegBase)\n#define kr_control KREG_IDX(Control)\n#define kr_intclear KREG_IDX(IntClear)\n#define kr_intmask KREG_IDX(IntMask)\n#define kr_intstatus KREG_IDX(IntStatus)\n#define kr_errclear KREG_IDX(ErrClear)\n#define kr_errmask KREG_IDX(ErrMask)\n#define kr_errstatus KREG_IDX(ErrStatus)\n#define kr_hwerrclear KREG_IDX(HwErrClear)\n#define kr_hwerrmask KREG_IDX(HwErrMask)\n#define kr_hwerrstatus KREG_IDX(HwErrStatus)\n#define kr_revision KREG_IDX(Revision)\n#define kr_portcnt KREG_IDX(PortCnt)\n#define kr_serdes_cfg0 KREG_IDX(SerdesCfg0)\n#define kr_serdes_cfg1 (kr_serdes_cfg0 + 1)\n#define kr_serdes_stat KREG_IDX(SerdesStat)\n#define kr_xgxs_cfg KREG_IDX(XGXSCfg)\n\n \n#define kr_rcvhdraddr KREG_IDX(RcvHdrAddr0)\n#define kr_rcvhdrtailaddr KREG_IDX(RcvHdrTailAddr0)\n\n#define CREG_IDX(regname) ((QIB_6120_##regname##_OFFS - \\\n\t\t\tQIB_6120_LBIntCnt_OFFS) / sizeof(u64))\n\n#define cr_badformat CREG_IDX(RxBadFormatCnt)\n#define cr_erricrc CREG_IDX(RxICRCErrCnt)\n#define cr_errlink CREG_IDX(RxLinkProblemCnt)\n#define cr_errlpcrc CREG_IDX(RxLPCRCErrCnt)\n#define cr_errpkey CREG_IDX(RxPKeyMismatchCnt)\n#define cr_rcvflowctrl_err CREG_IDX(RxFlowCtrlErrCnt)\n#define cr_err_rlen CREG_IDX(RxLenErrCnt)\n#define cr_errslen CREG_IDX(TxLenErrCnt)\n#define cr_errtidfull CREG_IDX(RxTIDFullErrCnt)\n#define cr_errtidvalid CREG_IDX(RxTIDValidErrCnt)\n#define cr_errvcrc CREG_IDX(RxVCRCErrCnt)\n#define cr_ibstatuschange CREG_IDX(IBStatusChangeCnt)\n#define cr_lbint CREG_IDX(LBIntCnt)\n#define cr_invalidrlen CREG_IDX(RxMaxMinLenErrCnt)\n#define cr_invalidslen CREG_IDX(TxMaxMinLenErrCnt)\n#define cr_lbflowstall CREG_IDX(LBFlowStallCnt)\n#define cr_pktrcv CREG_IDX(RxDataPktCnt)\n#define cr_pktrcvflowctrl CREG_IDX(RxFlowPktCnt)\n#define cr_pktsend CREG_IDX(TxDataPktCnt)\n#define cr_pktsendflow CREG_IDX(TxFlowPktCnt)\n#define cr_portovfl CREG_IDX(RxP0HdrEgrOvflCnt)\n#define cr_rcvebp CREG_IDX(RxEBPCnt)\n#define cr_rcvovfl CREG_IDX(RxBufOvflCnt)\n#define cr_senddropped CREG_IDX(TxDroppedPktCnt)\n#define cr_sendstall CREG_IDX(TxFlowStallCnt)\n#define cr_sendunderrun CREG_IDX(TxUnderrunCnt)\n#define cr_wordrcv CREG_IDX(RxDwordCnt)\n#define cr_wordsend CREG_IDX(TxDwordCnt)\n#define cr_txunsupvl CREG_IDX(TxUnsupVLErrCnt)\n#define cr_rxdroppkt CREG_IDX(RxDroppedPktCnt)\n#define cr_iblinkerrrecov CREG_IDX(IBLinkErrRecoveryCnt)\n#define cr_iblinkdown CREG_IDX(IBLinkDownedCnt)\n#define cr_ibsymbolerr CREG_IDX(IBSymbolErrCnt)\n\n#define SYM_RMASK(regname, fldname) ((u64)              \\\n\tQIB_6120_##regname##_##fldname##_RMASK)\n#define SYM_MASK(regname, fldname) ((u64)               \\\n\tQIB_6120_##regname##_##fldname##_RMASK <<       \\\n\t QIB_6120_##regname##_##fldname##_LSB)\n#define SYM_LSB(regname, fldname) (QIB_6120_##regname##_##fldname##_LSB)\n\n#define SYM_FIELD(value, regname, fldname) ((u64) \\\n\t(((value) >> SYM_LSB(regname, fldname)) & \\\n\t SYM_RMASK(regname, fldname)))\n#define ERR_MASK(fldname) SYM_MASK(ErrMask, fldname##Mask)\n#define HWE_MASK(fldname) SYM_MASK(HwErrMask, fldname##Mask)\n\n \n#define IB_6120_LT_STATE_DISABLED        0x00\n#define IB_6120_LT_STATE_LINKUP          0x01\n#define IB_6120_LT_STATE_POLLACTIVE      0x02\n#define IB_6120_LT_STATE_POLLQUIET       0x03\n#define IB_6120_LT_STATE_SLEEPDELAY      0x04\n#define IB_6120_LT_STATE_SLEEPQUIET      0x05\n#define IB_6120_LT_STATE_CFGDEBOUNCE     0x08\n#define IB_6120_LT_STATE_CFGRCVFCFG      0x09\n#define IB_6120_LT_STATE_CFGWAITRMT      0x0a\n#define IB_6120_LT_STATE_CFGIDLE 0x0b\n#define IB_6120_LT_STATE_RECOVERRETRAIN  0x0c\n#define IB_6120_LT_STATE_RECOVERWAITRMT  0x0e\n#define IB_6120_LT_STATE_RECOVERIDLE     0x0f\n\n \n#define IB_6120_L_STATE_DOWN             0x0\n#define IB_6120_L_STATE_INIT             0x1\n#define IB_6120_L_STATE_ARM              0x2\n#define IB_6120_L_STATE_ACTIVE           0x3\n#define IB_6120_L_STATE_ACT_DEFER        0x4\n\nstatic const u8 qib_6120_physportstate[0x20] = {\n\t[IB_6120_LT_STATE_DISABLED] = IB_PHYSPORTSTATE_DISABLED,\n\t[IB_6120_LT_STATE_LINKUP] = IB_PHYSPORTSTATE_LINKUP,\n\t[IB_6120_LT_STATE_POLLACTIVE] = IB_PHYSPORTSTATE_POLL,\n\t[IB_6120_LT_STATE_POLLQUIET] = IB_PHYSPORTSTATE_POLL,\n\t[IB_6120_LT_STATE_SLEEPDELAY] = IB_PHYSPORTSTATE_SLEEP,\n\t[IB_6120_LT_STATE_SLEEPQUIET] = IB_PHYSPORTSTATE_SLEEP,\n\t[IB_6120_LT_STATE_CFGDEBOUNCE] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_6120_LT_STATE_CFGRCVFCFG] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_6120_LT_STATE_CFGWAITRMT] =\n\t\tIB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_6120_LT_STATE_CFGIDLE] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[IB_6120_LT_STATE_RECOVERRETRAIN] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[IB_6120_LT_STATE_RECOVERWAITRMT] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[IB_6120_LT_STATE_RECOVERIDLE] =\n\t\tIB_PHYSPORTSTATE_LINK_ERR_RECOVER,\n\t[0x10] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x11] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x12] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x13] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x14] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x15] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x16] = IB_PHYSPORTSTATE_CFG_TRAIN,\n\t[0x17] = IB_PHYSPORTSTATE_CFG_TRAIN\n};\n\n\nstruct qib_chip_specific {\n\tu64 __iomem *cregbase;\n\tu64 *cntrs;\n\tu64 *portcntrs;\n\tvoid *dummy_hdrq;    \n\tdma_addr_t dummy_hdrq_phys;\n\tspinlock_t kernel_tid_lock;  \n\tspinlock_t user_tid_lock;  \n\tspinlock_t rcvmod_lock;  \n\tspinlock_t gpio_lock;  \n\tu64 hwerrmask;\n\tu64 errormask;\n\tu64 gpio_out;  \n\tu64 gpio_mask;  \n\tu64 extctrl;  \n\t \n\tu64 ibdeltainprog;\n\tu64 ibsymdelta;\n\tu64 ibsymsnap;\n\tu64 iblnkerrdelta;\n\tu64 iblnkerrsnap;\n\tu64 ibcctrl;  \n\tu32 lastlinkrecov;  \n\tu32 cntrnamelen;\n\tu32 portcntrnamelen;\n\tu32 ncntrs;\n\tu32 nportcntrs;\n\t \n\tu32 rxfc_unsupvl_errs;\n\tu32 overrun_thresh_errs;\n\t \n\tu32 lli_errs;\n\tu32 lli_counter;\n\tu64 lli_thresh;\n\tu64 sword;  \n\tu64 rword;  \n\tu64 spkts;  \n\tu64 rpkts;  \n\tu64 xmit_wait;  \n\tstruct timer_list pma_timer;\n\tstruct qib_pportdata *ppd;\n\tchar emsgbuf[128];\n\tchar bitsmsgbuf[64];\n\tu8 pma_sample_status;\n};\n\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_DISABLE 1\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_POLL 2\n \n#define QLOGIC_IB_IBCC_LINKINITCMD_SLEEP 3\n#define QLOGIC_IB_IBCC_LINKINITCMD_SHIFT 16\n\n#define QLOGIC_IB_IBCC_LINKCMD_DOWN 1            \n#define QLOGIC_IB_IBCC_LINKCMD_ARMED 2           \n#define QLOGIC_IB_IBCC_LINKCMD_ACTIVE 3  \n#define QLOGIC_IB_IBCC_LINKCMD_SHIFT 18\n\n \n\n \nstatic inline u32 qib_read_ureg32(const struct qib_devdata *dd,\n\t\t\t\t  enum qib_ureg regno, int ctxt)\n{\n\tif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\n\tif (dd->userbase)\n\t\treturn readl(regno + (u64 __iomem *)\n\t\t\t     ((char __iomem *)dd->userbase +\n\t\t\t      dd->ureg_align * ctxt));\n\telse\n\t\treturn readl(regno + (u64 __iomem *)\n\t\t\t     (dd->uregbase +\n\t\t\t      (char __iomem *)dd->kregbase +\n\t\t\t      dd->ureg_align * ctxt));\n}\n\n \nstatic inline void qib_write_ureg(const struct qib_devdata *dd,\n\t\t\t\t  enum qib_ureg regno, u64 value, int ctxt)\n{\n\tu64 __iomem *ubase;\n\n\tif (dd->userbase)\n\t\tubase = (u64 __iomem *)\n\t\t\t((char __iomem *) dd->userbase +\n\t\t\t dd->ureg_align * ctxt);\n\telse\n\t\tubase = (u64 __iomem *)\n\t\t\t(dd->uregbase +\n\t\t\t (char __iomem *) dd->kregbase +\n\t\t\t dd->ureg_align * ctxt);\n\n\tif (dd->kregbase && (dd->flags & QIB_PRESENT))\n\t\twriteq(value, &ubase[regno]);\n}\n\nstatic inline u32 qib_read_kreg32(const struct qib_devdata *dd,\n\t\t\t\t  const u16 regno)\n{\n\tif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn -1;\n\treturn readl((u32 __iomem *)&dd->kregbase[regno]);\n}\n\nstatic inline u64 qib_read_kreg64(const struct qib_devdata *dd,\n\t\t\t\t  const u16 regno)\n{\n\tif (!dd->kregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn -1;\n\n\treturn readq(&dd->kregbase[regno]);\n}\n\nstatic inline void qib_write_kreg(const struct qib_devdata *dd,\n\t\t\t\t  const u16 regno, u64 value)\n{\n\tif (dd->kregbase && (dd->flags & QIB_PRESENT))\n\t\twriteq(value, &dd->kregbase[regno]);\n}\n\n \nstatic inline void qib_write_kreg_ctxt(const struct qib_devdata *dd,\n\t\t\t\t       const u16 regno, unsigned ctxt,\n\t\t\t\t       u64 value)\n{\n\tqib_write_kreg(dd, regno + ctxt, value);\n}\n\nstatic inline void write_6120_creg(const struct qib_devdata *dd,\n\t\t\t\t   u16 regno, u64 value)\n{\n\tif (dd->cspec->cregbase && (dd->flags & QIB_PRESENT))\n\t\twriteq(value, &dd->cspec->cregbase[regno]);\n}\n\nstatic inline u64 read_6120_creg(const struct qib_devdata *dd, u16 regno)\n{\n\tif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\treturn readq(&dd->cspec->cregbase[regno]);\n}\n\nstatic inline u32 read_6120_creg32(const struct qib_devdata *dd, u16 regno)\n{\n\tif (!dd->cspec->cregbase || !(dd->flags & QIB_PRESENT))\n\t\treturn 0;\n\treturn readl(&dd->cspec->cregbase[regno]);\n}\n\n \n#define QLOGIC_IB_C_RESET 1U\n\n \n#define QLOGIC_IB_I_RCVURG_MASK ((1U << 5) - 1)\n#define QLOGIC_IB_I_RCVURG_SHIFT 0\n#define QLOGIC_IB_I_RCVAVAIL_MASK ((1U << 5) - 1)\n#define QLOGIC_IB_I_RCVAVAIL_SHIFT 12\n\n#define QLOGIC_IB_C_FREEZEMODE 0x00000002\n#define QLOGIC_IB_C_LINKENABLE 0x00000004\n#define QLOGIC_IB_I_ERROR               0x0000000080000000ULL\n#define QLOGIC_IB_I_SPIOSENT            0x0000000040000000ULL\n#define QLOGIC_IB_I_SPIOBUFAVAIL        0x0000000020000000ULL\n#define QLOGIC_IB_I_GPIO                0x0000000010000000ULL\n#define QLOGIC_IB_I_BITSEXTANT \\\n\t\t((QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT) | \\\n\t\t(QLOGIC_IB_I_RCVAVAIL_MASK << \\\n\t\t QLOGIC_IB_I_RCVAVAIL_SHIFT) | \\\n\t\tQLOGIC_IB_I_ERROR | QLOGIC_IB_I_SPIOSENT | \\\n\t\tQLOGIC_IB_I_SPIOBUFAVAIL | QLOGIC_IB_I_GPIO)\n\n \n#define QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK  0x000000000000003fULL\n#define QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT 0\n#define QLOGIC_IB_HWE_PCIEPOISONEDTLP      0x0000000010000000ULL\n#define QLOGIC_IB_HWE_PCIECPLTIMEOUT       0x0000000020000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYXTLH    0x0000000040000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYXADM    0x0000000080000000ULL\n#define QLOGIC_IB_HWE_PCIEBUSPARITYRADM    0x0000000100000000ULL\n#define QLOGIC_IB_HWE_COREPLL_FBSLIP       0x0080000000000000ULL\n#define QLOGIC_IB_HWE_COREPLL_RFSLIP       0x0100000000000000ULL\n#define QLOGIC_IB_HWE_PCIE1PLLFAILED       0x0400000000000000ULL\n#define QLOGIC_IB_HWE_PCIE0PLLFAILED       0x0800000000000000ULL\n#define QLOGIC_IB_HWE_SERDESPLLFAILED      0x1000000000000000ULL\n\n\n \n#define QLOGIC_IB_EXTS_FREQSEL 0x2\n#define QLOGIC_IB_EXTS_SERDESSEL 0x4\n#define QLOGIC_IB_EXTS_MEMBIST_ENDTEST     0x0000000000004000\n#define QLOGIC_IB_EXTS_MEMBIST_FOUND       0x0000000000008000\n\n \n#define QLOGIC_IB_XGXS_RESET          0x5ULL\n\n#define _QIB_GPIO_SDA_NUM 1\n#define _QIB_GPIO_SCL_NUM 0\n\n \n#define GPIO_RXUVL_BIT 3\n#define GPIO_OVRUN_BIT 4\n#define GPIO_LLI_BIT 5\n#define GPIO_ERRINTR_MASK 0x38\n\n\n#define QLOGIC_IB_RT_BUFSIZE_MASK 0xe0000000ULL\n#define QLOGIC_IB_RT_BUFSIZE_SHIFTVAL(tid) \\\n\t((((tid) & QLOGIC_IB_RT_BUFSIZE_MASK) >> 29) + 11 - 1)\n#define QLOGIC_IB_RT_BUFSIZE(tid) (1 << QLOGIC_IB_RT_BUFSIZE_SHIFTVAL(tid))\n#define QLOGIC_IB_RT_IS_VALID(tid) \\\n\t(((tid) & QLOGIC_IB_RT_BUFSIZE_MASK) && \\\n\t ((((tid) & QLOGIC_IB_RT_BUFSIZE_MASK) != QLOGIC_IB_RT_BUFSIZE_MASK)))\n#define QLOGIC_IB_RT_ADDR_MASK 0x1FFFFFFFULL  \n#define QLOGIC_IB_RT_ADDR_SHIFT 10\n\n#define QLOGIC_IB_R_INTRAVAIL_SHIFT 16\n#define QLOGIC_IB_R_TAILUPD_SHIFT 31\n#define IBA6120_R_PKEY_DIS_SHIFT 30\n\n#define PBC_6120_VL15_SEND_CTRL (1ULL << 31)  \n\n#define IBCBUSFRSPCPARITYERR HWE_MASK(IBCBusFromSPCParityErr)\n#define IBCBUSTOSPCPARITYERR HWE_MASK(IBCBusToSPCParityErr)\n\n#define SYM_MASK_BIT(regname, fldname, bit) ((u64) \\\n\t((1ULL << (SYM_LSB(regname, fldname) + (bit)))))\n\n#define TXEMEMPARITYERR_PIOBUF \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 0)\n#define TXEMEMPARITYERR_PIOPBC \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 1)\n#define TXEMEMPARITYERR_PIOLAUNCHFIFO \\\n\tSYM_MASK_BIT(HwErrMask, TXEMemParityErrMask, 2)\n\n#define RXEMEMPARITYERR_RCVBUF \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 0)\n#define RXEMEMPARITYERR_LOOKUPQ \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 1)\n#define RXEMEMPARITYERR_EXPTID \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 2)\n#define RXEMEMPARITYERR_EAGERTID \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 3)\n#define RXEMEMPARITYERR_FLAGBUF \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 4)\n#define RXEMEMPARITYERR_DATAINFO \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 5)\n#define RXEMEMPARITYERR_HDRINFO \\\n\tSYM_MASK_BIT(HwErrMask, RXEMemParityErrMask, 6)\n\n \nstatic const struct qib_hwerror_msgs qib_6120_hwerror_msgs[] = {\n\t \n\tQLOGIC_IB_HWE_MSG(IBCBUSFRSPCPARITYERR, \"QIB2IB Parity\"),\n\tQLOGIC_IB_HWE_MSG(IBCBUSTOSPCPARITYERR, \"IB2QIB Parity\"),\n\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOBUF,\n\t\t\t  \"TXE PIOBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOPBC,\n\t\t\t  \"TXE PIOPBC Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(TXEMEMPARITYERR_PIOLAUNCHFIFO,\n\t\t\t  \"TXE PIOLAUNCHFIFO Memory Parity\"),\n\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_RCVBUF,\n\t\t\t  \"RXE RCVBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_LOOKUPQ,\n\t\t\t  \"RXE LOOKUPQ Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_EAGERTID,\n\t\t\t  \"RXE EAGERTID Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_EXPTID,\n\t\t\t  \"RXE EXPTID Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_FLAGBUF,\n\t\t\t  \"RXE FLAGBUF Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_DATAINFO,\n\t\t\t  \"RXE DATAINFO Memory Parity\"),\n\tQLOGIC_IB_HWE_MSG(RXEMEMPARITYERR_HDRINFO,\n\t\t\t  \"RXE HDRINFO Memory Parity\"),\n\n\t \n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEPOISONEDTLP,\n\t\t\t  \"PCIe Poisoned TLP\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIECPLTIMEOUT,\n\t\t\t  \"PCIe completion timeout\"),\n\t \n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE1PLLFAILED,\n\t\t\t  \"PCIePLL1\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIE0PLLFAILED,\n\t\t\t  \"PCIePLL0\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYXTLH,\n\t\t\t  \"PCIe XTLH core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYXADM,\n\t\t\t  \"PCIe ADM TX core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_PCIEBUSPARITYRADM,\n\t\t\t  \"PCIe ADM RX core parity\"),\n\tQLOGIC_IB_HWE_MSG(QLOGIC_IB_HWE_SERDESPLLFAILED,\n\t\t\t  \"SerDes PLL\"),\n};\n\n#define TXE_PIO_PARITY (TXEMEMPARITYERR_PIOBUF | TXEMEMPARITYERR_PIOPBC)\n#define _QIB_PLL_FAIL (QLOGIC_IB_HWE_COREPLL_FBSLIP |   \\\n\t\tQLOGIC_IB_HWE_COREPLL_RFSLIP)\n\n\t \n#define IB_HWE_BITSEXTANT \\\n\t(HWE_MASK(RXEMemParityErr) |\t\t\t\t\t\\\n\t HWE_MASK(TXEMemParityErr) |\t\t\t\t\t\\\n\t (QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\t\t\t\\\n\t  QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) |\t\t\t\\\n\t QLOGIC_IB_HWE_PCIE1PLLFAILED |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIE0PLLFAILED |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIEPOISONEDTLP |\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIECPLTIMEOUT |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIEBUSPARITYXTLH |\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIEBUSPARITYXADM |\t\t\t\t\\\n\t QLOGIC_IB_HWE_PCIEBUSPARITYRADM |\t\t\t\t\\\n\t HWE_MASK(PowerOnBISTFailed) |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_COREPLL_FBSLIP |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_COREPLL_RFSLIP |\t\t\t\t\t\\\n\t QLOGIC_IB_HWE_SERDESPLLFAILED |\t\t\t\t\\\n\t HWE_MASK(IBCBusToSPCParityErr) |\t\t\t\t\\\n\t HWE_MASK(IBCBusFromSPCParityErr))\n\n#define IB_E_BITSEXTANT \\\n\t(ERR_MASK(RcvFormatErr) | ERR_MASK(RcvVCRCErr) |\t\t\\\n\t ERR_MASK(RcvICRCErr) | ERR_MASK(RcvMinPktLenErr) |\t\t\\\n\t ERR_MASK(RcvMaxPktLenErr) | ERR_MASK(RcvLongPktLenErr) |\t\\\n\t ERR_MASK(RcvShortPktLenErr) | ERR_MASK(RcvUnexpectedCharErr) | \\\n\t ERR_MASK(RcvUnsupportedVLErr) | ERR_MASK(RcvEBPErr) |\t\t\\\n\t ERR_MASK(RcvIBFlowErr) | ERR_MASK(RcvBadVersionErr) |\t\t\\\n\t ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr) |\t\t\\\n\t ERR_MASK(RcvBadTidErr) | ERR_MASK(RcvHdrLenErr) |\t\t\\\n\t ERR_MASK(RcvHdrErr) | ERR_MASK(RcvIBLostLinkErr) |\t\t\\\n\t ERR_MASK(SendMinPktLenErr) | ERR_MASK(SendMaxPktLenErr) |\t\\\n\t ERR_MASK(SendUnderRunErr) | ERR_MASK(SendPktLenErr) |\t\t\\\n\t ERR_MASK(SendDroppedSmpPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendDroppedDataPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendPioArmLaunchErr) |\t\t\t\t\\\n\t ERR_MASK(SendUnexpectedPktNumErr) |\t\t\t\t\\\n\t ERR_MASK(SendUnsupportedVLErr) | ERR_MASK(IBStatusChanged) |\t\\\n\t ERR_MASK(InvalidAddrErr) | ERR_MASK(ResetNegated) |\t\t\\\n\t ERR_MASK(HardwareErr))\n\n#define QLOGIC_IB_E_PKTERRS ( \\\n\t\tERR_MASK(SendPktLenErr) |\t\t\t\t\\\n\t\tERR_MASK(SendDroppedDataPktErr) |\t\t\t\\\n\t\tERR_MASK(RcvVCRCErr) |\t\t\t\t\t\\\n\t\tERR_MASK(RcvICRCErr) |\t\t\t\t\t\\\n\t\tERR_MASK(RcvShortPktLenErr) |\t\t\t\t\\\n\t\tERR_MASK(RcvEBPErr))\n\n \n#define E_SUM_PKTERRS\t\t\t\t\t\t\\\n\t(ERR_MASK(RcvHdrLenErr) | ERR_MASK(RcvBadTidErr) |\t\t\\\n\t ERR_MASK(RcvBadVersionErr) | ERR_MASK(RcvHdrErr) |\t\t\\\n\t ERR_MASK(RcvLongPktLenErr) | ERR_MASK(RcvShortPktLenErr) |\t\\\n\t ERR_MASK(RcvMaxPktLenErr) | ERR_MASK(RcvMinPktLenErr) |\t\\\n\t ERR_MASK(RcvFormatErr) | ERR_MASK(RcvUnsupportedVLErr) |\t\\\n\t ERR_MASK(RcvUnexpectedCharErr) | ERR_MASK(RcvEBPErr))\n\n \n#define E_SUM_ERRS\t\t\t\t\t\t\t\\\n\t(ERR_MASK(SendPioArmLaunchErr) |\t\t\t\t\\\n\t ERR_MASK(SendUnexpectedPktNumErr) |\t\t\t\t\\\n\t ERR_MASK(SendDroppedDataPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendDroppedSmpPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendMaxPktLenErr) | ERR_MASK(SendUnsupportedVLErr) |\t\\\n\t ERR_MASK(SendMinPktLenErr) | ERR_MASK(SendPktLenErr) |\t\t\\\n\t ERR_MASK(InvalidAddrErr))\n\n \n#define E_SPKT_ERRS_IGNORE \\\n\t(ERR_MASK(SendDroppedDataPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendDroppedSmpPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendMaxPktLenErr) | ERR_MASK(SendMinPktLenErr) |\t\\\n\t ERR_MASK(SendPktLenErr))\n\n \n#define E_SUM_LINK_PKTERRS\t\t\\\n\t(ERR_MASK(SendDroppedDataPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendDroppedSmpPktErr) |\t\t\t\t\\\n\t ERR_MASK(SendMinPktLenErr) | ERR_MASK(SendPktLenErr) |\t\t\\\n\t ERR_MASK(RcvShortPktLenErr) | ERR_MASK(RcvMinPktLenErr) |\t\\\n\t ERR_MASK(RcvUnexpectedCharErr))\n\nstatic void qib_6120_put_tid_2(struct qib_devdata *, u64 __iomem *,\n\t\t\t       u32, unsigned long);\n\n \nstatic void qib_6120_txe_recover(struct qib_devdata *dd)\n{\n\tif (!qib_unordered_wc())\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t    \"Recovering from TXE PIO parity error\\n\");\n}\n\n \nstatic void qib_6120_set_intr_state(struct qib_devdata *dd, u32 enable)\n{\n\tif (enable) {\n\t\tif (dd->flags & QIB_BADINTR)\n\t\t\treturn;\n\t\tqib_write_kreg(dd, kr_intmask, ~0ULL);\n\t\t \n\t\tqib_write_kreg(dd, kr_intclear, 0ULL);\n\t} else\n\t\tqib_write_kreg(dd, kr_intmask, 0ULL);\n}\n\n \nstatic void qib_6120_clear_freeze(struct qib_devdata *dd)\n{\n\t \n\tqib_write_kreg(dd, kr_errmask, 0ULL);\n\n\t \n\tqib_6120_set_intr_state(dd, 0);\n\n\tqib_cancel_sends(dd->pport);\n\n\t \n\tqib_write_kreg(dd, kr_control, dd->control);\n\tqib_read_kreg32(dd, kr_scratch);\n\n\t \n\tqib_force_pio_avail_update(dd);\n\n\t \n\tqib_write_kreg(dd, kr_hwerrclear, 0ULL);\n\tqib_write_kreg(dd, kr_errclear, E_SPKT_ERRS_IGNORE);\n\tqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\n\tqib_6120_set_intr_state(dd, 1);\n}\n\n \nstatic void qib_handle_6120_hwerrors(struct qib_devdata *dd, char *msg,\n\t\t\t\t     size_t msgl)\n{\n\tu64 hwerrs;\n\tu32 bits, ctrl;\n\tint isfatal = 0;\n\tchar *bitsmsg;\n\n\thwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\n\tif (!hwerrs)\n\t\treturn;\n\tif (hwerrs == ~0ULL) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Read of hardware error status failed (all bits set); ignoring\\n\");\n\t\treturn;\n\t}\n\tqib_stats.sps_hwerrs++;\n\n\t \n\tqib_write_kreg(dd, kr_hwerrclear,\n\t\t       hwerrs & ~HWE_MASK(PowerOnBISTFailed));\n\n\thwerrs &= dd->cspec->hwerrmask;\n\n\t \n\tif (hwerrs & ~(TXE_PIO_PARITY | RXEMEMPARITYERR_EAGERTID))\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t\"Hardware error: hwerr=0x%llx (cleared)\\n\",\n\t\t\t(unsigned long long) hwerrs);\n\n\tif (hwerrs & ~IB_HWE_BITSEXTANT)\n\t\tqib_dev_err(dd,\n\t\t\t\"hwerror interrupt with unknown errors %llx set\\n\",\n\t\t\t(unsigned long long)(hwerrs & ~IB_HWE_BITSEXTANT));\n\n\tctrl = qib_read_kreg32(dd, kr_control);\n\tif ((ctrl & QLOGIC_IB_C_FREEZEMODE) && !dd->diag_client) {\n\t\t \n\t\tif (hwerrs & TXE_PIO_PARITY) {\n\t\t\tqib_6120_txe_recover(dd);\n\t\t\thwerrs &= ~TXE_PIO_PARITY;\n\t\t}\n\n\t\tif (!hwerrs)\n\t\t\tqib_6120_clear_freeze(dd);\n\t\telse\n\t\t\tisfatal = 1;\n\t}\n\n\t*msg = '\\0';\n\n\tif (hwerrs & HWE_MASK(PowerOnBISTFailed)) {\n\t\tisfatal = 1;\n\t\tstrlcat(msg,\n\t\t\t\"[Memory BIST test failed, InfiniPath hardware unusable]\",\n\t\t\tmsgl);\n\t\t \n\t\tdd->cspec->hwerrmask &= ~HWE_MASK(PowerOnBISTFailed);\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tqib_format_hwerrors(hwerrs, qib_6120_hwerror_msgs,\n\t\t\t    ARRAY_SIZE(qib_6120_hwerror_msgs), msg, msgl);\n\n\tbitsmsg = dd->cspec->bitsmsgbuf;\n\tif (hwerrs & (QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK <<\n\t\t      QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT)) {\n\t\tbits = (u32) ((hwerrs >>\n\t\t\t       QLOGIC_IB_HWE_PCIEMEMPARITYERR_SHIFT) &\n\t\t\t      QLOGIC_IB_HWE_PCIEMEMPARITYERR_MASK);\n\t\tsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\n\t\t\t \"[PCIe Mem Parity Errs %x] \", bits);\n\t\tstrlcat(msg, bitsmsg, msgl);\n\t}\n\n\tif (hwerrs & _QIB_PLL_FAIL) {\n\t\tisfatal = 1;\n\t\tsnprintf(bitsmsg, sizeof(dd->cspec->bitsmsgbuf),\n\t\t\t \"[PLL failed (%llx), InfiniPath hardware unusable]\",\n\t\t\t (unsigned long long) hwerrs & _QIB_PLL_FAIL);\n\t\tstrlcat(msg, bitsmsg, msgl);\n\t\t \n\t\tdd->cspec->hwerrmask &= ~(hwerrs & _QIB_PLL_FAIL);\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tif (hwerrs & QLOGIC_IB_HWE_SERDESPLLFAILED) {\n\t\t \n\t\tdd->cspec->hwerrmask &= ~QLOGIC_IB_HWE_SERDESPLLFAILED;\n\t\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\t}\n\n\tif (hwerrs)\n\t\t \n\t\tqib_dev_err(dd, \"%s hardware error\\n\", msg);\n\telse\n\t\t*msg = 0;  \n\n\tif (isfatal && !dd->diag_client) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Fatal Hardware Error, no longer usable, SN %.16s\\n\",\n\t\t\tdd->serial);\n\t\t \n\t\tif (dd->freezemsg)\n\t\t\tsnprintf(dd->freezemsg, dd->freezelen,\n\t\t\t\t \"{%s}\", msg);\n\t\tqib_disable_after_error(dd);\n\t}\n}\n\n \nstatic int qib_decode_6120_err(struct qib_devdata *dd, char *buf, size_t blen,\n\t\t\t       u64 err)\n{\n\tint iserr = 1;\n\n\t*buf = '\\0';\n\tif (err & QLOGIC_IB_E_PKTERRS) {\n\t\tif (!(err & ~QLOGIC_IB_E_PKTERRS))\n\t\t\tiserr = 0;\n\t\tif ((err & ERR_MASK(RcvICRCErr)) &&\n\t\t    !(err&(ERR_MASK(RcvVCRCErr)|ERR_MASK(RcvEBPErr))))\n\t\t\tstrlcat(buf, \"CRC \", blen);\n\t\tif (!iserr)\n\t\t\tgoto done;\n\t}\n\tif (err & ERR_MASK(RcvHdrLenErr))\n\t\tstrlcat(buf, \"rhdrlen \", blen);\n\tif (err & ERR_MASK(RcvBadTidErr))\n\t\tstrlcat(buf, \"rbadtid \", blen);\n\tif (err & ERR_MASK(RcvBadVersionErr))\n\t\tstrlcat(buf, \"rbadversion \", blen);\n\tif (err & ERR_MASK(RcvHdrErr))\n\t\tstrlcat(buf, \"rhdr \", blen);\n\tif (err & ERR_MASK(RcvLongPktLenErr))\n\t\tstrlcat(buf, \"rlongpktlen \", blen);\n\tif (err & ERR_MASK(RcvMaxPktLenErr))\n\t\tstrlcat(buf, \"rmaxpktlen \", blen);\n\tif (err & ERR_MASK(RcvMinPktLenErr))\n\t\tstrlcat(buf, \"rminpktlen \", blen);\n\tif (err & ERR_MASK(SendMinPktLenErr))\n\t\tstrlcat(buf, \"sminpktlen \", blen);\n\tif (err & ERR_MASK(RcvFormatErr))\n\t\tstrlcat(buf, \"rformaterr \", blen);\n\tif (err & ERR_MASK(RcvUnsupportedVLErr))\n\t\tstrlcat(buf, \"runsupvl \", blen);\n\tif (err & ERR_MASK(RcvUnexpectedCharErr))\n\t\tstrlcat(buf, \"runexpchar \", blen);\n\tif (err & ERR_MASK(RcvIBFlowErr))\n\t\tstrlcat(buf, \"ribflow \", blen);\n\tif (err & ERR_MASK(SendUnderRunErr))\n\t\tstrlcat(buf, \"sunderrun \", blen);\n\tif (err & ERR_MASK(SendPioArmLaunchErr))\n\t\tstrlcat(buf, \"spioarmlaunch \", blen);\n\tif (err & ERR_MASK(SendUnexpectedPktNumErr))\n\t\tstrlcat(buf, \"sunexperrpktnum \", blen);\n\tif (err & ERR_MASK(SendDroppedSmpPktErr))\n\t\tstrlcat(buf, \"sdroppedsmppkt \", blen);\n\tif (err & ERR_MASK(SendMaxPktLenErr))\n\t\tstrlcat(buf, \"smaxpktlen \", blen);\n\tif (err & ERR_MASK(SendUnsupportedVLErr))\n\t\tstrlcat(buf, \"sunsupVL \", blen);\n\tif (err & ERR_MASK(InvalidAddrErr))\n\t\tstrlcat(buf, \"invalidaddr \", blen);\n\tif (err & ERR_MASK(RcvEgrFullErr))\n\t\tstrlcat(buf, \"rcvegrfull \", blen);\n\tif (err & ERR_MASK(RcvHdrFullErr))\n\t\tstrlcat(buf, \"rcvhdrfull \", blen);\n\tif (err & ERR_MASK(IBStatusChanged))\n\t\tstrlcat(buf, \"ibcstatuschg \", blen);\n\tif (err & ERR_MASK(RcvIBLostLinkErr))\n\t\tstrlcat(buf, \"riblostlink \", blen);\n\tif (err & ERR_MASK(HardwareErr))\n\t\tstrlcat(buf, \"hardware \", blen);\n\tif (err & ERR_MASK(ResetNegated))\n\t\tstrlcat(buf, \"reset \", blen);\ndone:\n\treturn iserr;\n}\n\n \nstatic void qib_disarm_6120_senderrbufs(struct qib_pportdata *ppd)\n{\n\tunsigned long sbuf[2];\n\tstruct qib_devdata *dd = ppd->dd;\n\n\t \n\tsbuf[0] = qib_read_kreg64(dd, kr_sendbuffererror);\n\tsbuf[1] = qib_read_kreg64(dd, kr_sendbuffererror + 1);\n\n\tif (sbuf[0] || sbuf[1])\n\t\tqib_disarm_piobufs_set(dd, sbuf,\n\t\t\t\t       dd->piobcnt2k + dd->piobcnt4k);\n}\n\nstatic int chk_6120_linkrecovery(struct qib_devdata *dd, u64 ibcs)\n{\n\tint ret = 1;\n\tu32 ibstate = qib_6120_iblink_state(ibcs);\n\tu32 linkrecov = read_6120_creg32(dd, cr_iblinkerrrecov);\n\n\tif (linkrecov != dd->cspec->lastlinkrecov) {\n\t\t \n\t\tdd->cspec->lastlinkrecov = 0;\n\t\tqib_set_linkstate(dd->pport, QIB_IB_LINKDOWN);\n\t\tret = 0;\n\t}\n\tif (ibstate == IB_PORT_ACTIVE)\n\t\tdd->cspec->lastlinkrecov =\n\t\t\tread_6120_creg32(dd, cr_iblinkerrrecov);\n\treturn ret;\n}\n\nstatic void handle_6120_errors(struct qib_devdata *dd, u64 errs)\n{\n\tchar *msg;\n\tu64 ignore_this_time = 0;\n\tu64 iserr = 0;\n\tstruct qib_pportdata *ppd = dd->pport;\n\tu64 mask;\n\n\t \n\terrs &= dd->cspec->errormask;\n\tmsg = dd->cspec->emsgbuf;\n\n\t \n\tif (errs & ERR_MASK(HardwareErr))\n\t\tqib_handle_6120_hwerrors(dd, msg, sizeof(dd->cspec->emsgbuf));\n\n\tif (errs & ~IB_E_BITSEXTANT)\n\t\tqib_dev_err(dd,\n\t\t\t\"error interrupt with unknown errors %llx set\\n\",\n\t\t\t(unsigned long long) (errs & ~IB_E_BITSEXTANT));\n\n\tif (errs & E_SUM_ERRS) {\n\t\tqib_disarm_6120_senderrbufs(ppd);\n\t\tif ((errs & E_SUM_LINK_PKTERRS) &&\n\t\t    !(ppd->lflags & QIBL_LINKACTIVE)) {\n\t\t\t \n\t\t\tignore_this_time = errs & E_SUM_LINK_PKTERRS;\n\t\t}\n\t} else if ((errs & E_SUM_LINK_PKTERRS) &&\n\t\t   !(ppd->lflags & QIBL_LINKACTIVE)) {\n\t\t \n\t\tignore_this_time = errs & E_SUM_LINK_PKTERRS;\n\t}\n\n\tqib_write_kreg(dd, kr_errclear, errs);\n\n\terrs &= ~ignore_this_time;\n\tif (!errs)\n\t\tgoto done;\n\n\t \n\tmask = ERR_MASK(IBStatusChanged) | ERR_MASK(RcvEgrFullErr) |\n\t\tERR_MASK(RcvHdrFullErr) | ERR_MASK(HardwareErr);\n\tqib_decode_6120_err(dd, msg, sizeof(dd->cspec->emsgbuf), errs & ~mask);\n\n\tif (errs & E_SUM_PKTERRS)\n\t\tqib_stats.sps_rcverrs++;\n\tif (errs & E_SUM_ERRS)\n\t\tqib_stats.sps_txerrs++;\n\n\tiserr = errs & ~(E_SUM_PKTERRS | QLOGIC_IB_E_PKTERRS);\n\n\tif (errs & ERR_MASK(IBStatusChanged)) {\n\t\tu64 ibcs = qib_read_kreg64(dd, kr_ibcstatus);\n\t\tu32 ibstate = qib_6120_iblink_state(ibcs);\n\t\tint handle = 1;\n\n\t\tif (ibstate != IB_PORT_INIT && dd->cspec->lastlinkrecov)\n\t\t\thandle = chk_6120_linkrecovery(dd, ibcs);\n\t\t \n\t\tif (handle && qib_6120_phys_portstate(ibcs) ==\n\t\t\t\t\t    IB_PHYSPORTSTATE_LINK_ERR_RECOVER)\n\t\t\thandle = 0;\n\t\tif (handle)\n\t\t\tqib_handle_e_ibstatuschanged(ppd, ibcs);\n\t}\n\n\tif (errs & ERR_MASK(ResetNegated)) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Got reset, requires re-init (unload and reload driver)\\n\");\n\t\tdd->flags &= ~QIB_INITTED;   \n\t\t \n\t\t*dd->devstatusp |= QIB_STATUS_HWERROR;\n\t\t*dd->pport->statusp &= ~QIB_STATUS_IB_CONF;\n\t}\n\n\tif (*msg && iserr)\n\t\tqib_dev_porterr(dd, ppd->port, \"%s error\\n\", msg);\n\n\tif (ppd->state_wanted & ppd->lflags)\n\t\twake_up_interruptible(&ppd->state_wait);\n\n\t \n\tif (errs & (ERR_MASK(RcvEgrFullErr) | ERR_MASK(RcvHdrFullErr))) {\n\t\tqib_handle_urcv(dd, ~0U);\n\t\tif (errs & ERR_MASK(RcvEgrFullErr))\n\t\t\tqib_stats.sps_buffull++;\n\t\telse\n\t\t\tqib_stats.sps_hdrfull++;\n\t}\ndone:\n\treturn;\n}\n\n \nstatic void qib_6120_init_hwerrors(struct qib_devdata *dd)\n{\n\tu64 val;\n\tu64 extsval;\n\n\textsval = qib_read_kreg64(dd, kr_extstatus);\n\n\tif (!(extsval & QLOGIC_IB_EXTS_MEMBIST_ENDTEST))\n\t\tqib_dev_err(dd, \"MemBIST did not complete!\\n\");\n\n\t \n\tval = ~0ULL;\n\tif (dd->minrev < 2) {\n\t\t \n\t\tval &= ~QLOGIC_IB_HWE_PCIEBUSPARITYRADM;\n\t}\n\t \n\tval &= ~TXEMEMPARITYERR_PIOBUF;\n\n\tdd->cspec->hwerrmask = val;\n\n\tqib_write_kreg(dd, kr_hwerrclear, ~HWE_MASK(PowerOnBISTFailed));\n\tqib_write_kreg(dd, kr_hwerrmask, dd->cspec->hwerrmask);\n\n\t \n\tqib_write_kreg(dd, kr_errclear, ~0ULL);\n\t \n\tqib_write_kreg(dd, kr_errmask, ~0ULL);\n\tdd->cspec->errormask = qib_read_kreg64(dd, kr_errmask);\n\t \n\tqib_write_kreg(dd, kr_intclear, ~0ULL);\n\n\tqib_write_kreg(dd, kr_rcvbthqp,\n\t\t       dd->qpn_mask << (QIB_6120_RcvBTHQP_BTHQP_Mask_LSB - 1) |\n\t\t       QIB_KD_QP);\n}\n\n \nstatic void qib_set_6120_armlaunch(struct qib_devdata *dd, u32 enable)\n{\n\tif (enable) {\n\t\tqib_write_kreg(dd, kr_errclear,\n\t\t\t       ERR_MASK(SendPioArmLaunchErr));\n\t\tdd->cspec->errormask |= ERR_MASK(SendPioArmLaunchErr);\n\t} else\n\t\tdd->cspec->errormask &= ~ERR_MASK(SendPioArmLaunchErr);\n\tqib_write_kreg(dd, kr_errmask, dd->cspec->errormask);\n}\n\n \nstatic void qib_set_ib_6120_lstate(struct qib_pportdata *ppd, u16 linkcmd,\n\t\t\t\t   u16 linitcmd)\n{\n\tu64 mod_wd;\n\tstruct qib_devdata *dd = ppd->dd;\n\tunsigned long flags;\n\n\tif (linitcmd == QLOGIC_IB_IBCC_LINKINITCMD_DISABLE) {\n\t\t \n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags |= QIBL_IB_LINK_DISABLED;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t} else if (linitcmd || linkcmd == QLOGIC_IB_IBCC_LINKCMD_DOWN) {\n\t\t \n\t\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\t\tppd->lflags &= ~QIBL_IB_LINK_DISABLED;\n\t\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\t}\n\n\tmod_wd = (linkcmd << QLOGIC_IB_IBCC_LINKCMD_SHIFT) |\n\t\t(linitcmd << QLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\n\n\tqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl | mod_wd);\n\t \n\tqib_write_kreg(dd, kr_scratch, 0);\n}\n\n \nstatic int qib_6120_bringup_serdes(struct qib_pportdata *ppd)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 val, config1, prev_val, hwstat, ibc;\n\n\t \n\tdd->control &= ~QLOGIC_IB_C_LINKENABLE;\n\tqib_write_kreg(dd, kr_control, 0ULL);\n\n\tdd->cspec->ibdeltainprog = 1;\n\tdd->cspec->ibsymsnap = read_6120_creg32(dd, cr_ibsymbolerr);\n\tdd->cspec->iblnkerrsnap = read_6120_creg32(dd, cr_iblinkerrrecov);\n\n\t \n\tibc = 0x5ULL << SYM_LSB(IBCCtrl, FlowCtrlWaterMark);\n\t \n\tibc |= 0x3ULL << SYM_LSB(IBCCtrl, FlowCtrlPeriod);\n\t \n\tdd->cspec->lli_thresh = 0xf;\n\tibc |= (u64) dd->cspec->lli_thresh << SYM_LSB(IBCCtrl, PhyerrThreshold);\n\t \n\tibc |= 4ULL << SYM_LSB(IBCCtrl, CreditScale);\n\t \n\tibc |= 0xfULL << SYM_LSB(IBCCtrl, OverrunThreshold);\n\t \n\tibc |= ((u64)(ppd->ibmaxlen >> 2) + 1) << SYM_LSB(IBCCtrl, MaxPktLen);\n\tdd->cspec->ibcctrl = ibc;  \n\n\t \n\tval = dd->cspec->ibcctrl | (QLOGIC_IB_IBCC_LINKINITCMD_DISABLE <<\n\t\tQLOGIC_IB_IBCC_LINKINITCMD_SHIFT);\n\tqib_write_kreg(dd, kr_ibcctrl, val);\n\n\tval = qib_read_kreg64(dd, kr_serdes_cfg0);\n\tconfig1 = qib_read_kreg64(dd, kr_serdes_cfg1);\n\n\t \n\tval |= SYM_MASK(SerdesCfg0, ResetPLL) |\n\t\tSYM_MASK(SerdesCfg0, RxDetEnX) |\n\t\t(SYM_MASK(SerdesCfg0, L1PwrDnA) |\n\t\t SYM_MASK(SerdesCfg0, L1PwrDnB) |\n\t\t SYM_MASK(SerdesCfg0, L1PwrDnC) |\n\t\t SYM_MASK(SerdesCfg0, L1PwrDnD));\n\tqib_write_kreg(dd, kr_serdes_cfg0, val);\n\t \n\tqib_read_kreg64(dd, kr_scratch);\n\tudelay(5);               \n\t \n\tval &= ~(SYM_MASK(SerdesCfg0, RxDetEnX) |\n\t\t SYM_MASK(SerdesCfg0, ResetPLL) |\n\t\t (SYM_MASK(SerdesCfg0, L1PwrDnA) |\n\t\t  SYM_MASK(SerdesCfg0, L1PwrDnB) |\n\t\t  SYM_MASK(SerdesCfg0, L1PwrDnC) |\n\t\t  SYM_MASK(SerdesCfg0, L1PwrDnD)));\n\tval |= (SYM_MASK(SerdesCfg0, ResetA) |\n\t\tSYM_MASK(SerdesCfg0, ResetB) |\n\t\tSYM_MASK(SerdesCfg0, ResetC) |\n\t\tSYM_MASK(SerdesCfg0, ResetD)) |\n\t\tSYM_MASK(SerdesCfg0, TxIdeEnX);\n\tqib_write_kreg(dd, kr_serdes_cfg0, val);\n\t \n\t(void) qib_read_kreg64(dd, kr_scratch);\n\t \n\tudelay(15);\n\tval &= ~((SYM_MASK(SerdesCfg0, ResetA) |\n\t\t  SYM_MASK(SerdesCfg0, ResetB) |\n\t\t  SYM_MASK(SerdesCfg0, ResetC) |\n\t\t  SYM_MASK(SerdesCfg0, ResetD)) |\n\t\t SYM_MASK(SerdesCfg0, TxIdeEnX));\n\n\tqib_write_kreg(dd, kr_serdes_cfg0, val);\n\t \n\t(void) qib_read_kreg64(dd, kr_scratch);\n\n\tval = qib_read_kreg64(dd, kr_xgxs_cfg);\n\tprev_val = val;\n\tif (val & QLOGIC_IB_XGXS_RESET)\n\t\tval &= ~QLOGIC_IB_XGXS_RESET;\n\tif (SYM_FIELD(val, XGXSCfg, polarity_inv) != ppd->rx_pol_inv) {\n\t\t \n\t\tval &= ~SYM_MASK(XGXSCfg, polarity_inv);\n\t\tval |= (u64)ppd->rx_pol_inv << SYM_LSB(XGXSCfg, polarity_inv);\n\t}\n\tif (val != prev_val)\n\t\tqib_write_kreg(dd, kr_xgxs_cfg, val);\n\n\tval = qib_read_kreg64(dd, kr_serdes_cfg0);\n\n\t \n\tconfig1 &= ~0x0ffffffff00ULL;\n\t \n\tconfig1 |= 0x00000000000ULL;\n\t \n\tconfig1 |= 0x0cccc000000ULL;\n\tqib_write_kreg(dd, kr_serdes_cfg1, config1);\n\n\t \n\tppd->guid = dd->base_guid;\n\n\t \n\thwstat = qib_read_kreg64(dd, kr_hwerrstatus);\n\tif (hwstat) {\n\t\t \n\t\tqib_write_kreg(dd, kr_hwerrclear, hwstat);\n\t\tqib_write_kreg(dd, kr_errclear, ERR_MASK(HardwareErr));\n\t}\n\n\tdd->control |= QLOGIC_IB_C_LINKENABLE;\n\tdd->control &= ~QLOGIC_IB_C_FREEZEMODE;\n\tqib_write_kreg(dd, kr_control, dd->control);\n\n\treturn 0;\n}\n\n \nstatic void qib_6120_quiet_serdes(struct qib_pportdata *ppd)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 val;\n\n\tqib_set_ib_6120_lstate(ppd, 0, QLOGIC_IB_IBCC_LINKINITCMD_DISABLE);\n\n\t \n\tdd->control &= ~QLOGIC_IB_C_LINKENABLE;\n\tqib_write_kreg(dd, kr_control,\n\t\t       dd->control | QLOGIC_IB_C_FREEZEMODE);\n\n\tif (dd->cspec->ibsymdelta || dd->cspec->iblnkerrdelta ||\n\t    dd->cspec->ibdeltainprog) {\n\t\tu64 diagc;\n\n\t\t \n\t\tdiagc = qib_read_kreg64(dd, kr_hwdiagctrl);\n\t\tqib_write_kreg(dd, kr_hwdiagctrl,\n\t\t\t       diagc | SYM_MASK(HwDiagCtrl, CounterWrEnable));\n\n\t\tif (dd->cspec->ibsymdelta || dd->cspec->ibdeltainprog) {\n\t\t\tval = read_6120_creg32(dd, cr_ibsymbolerr);\n\t\t\tif (dd->cspec->ibdeltainprog)\n\t\t\t\tval -= val - dd->cspec->ibsymsnap;\n\t\t\tval -= dd->cspec->ibsymdelta;\n\t\t\twrite_6120_creg(dd, cr_ibsymbolerr, val);\n\t\t}\n\t\tif (dd->cspec->iblnkerrdelta || dd->cspec->ibdeltainprog) {\n\t\t\tval = read_6120_creg32(dd, cr_iblinkerrrecov);\n\t\t\tif (dd->cspec->ibdeltainprog)\n\t\t\t\tval -= val - dd->cspec->iblnkerrsnap;\n\t\t\tval -= dd->cspec->iblnkerrdelta;\n\t\t\twrite_6120_creg(dd, cr_iblinkerrrecov, val);\n\t\t}\n\n\t\t \n\t\tqib_write_kreg(dd, kr_hwdiagctrl, diagc);\n\t}\n\n\tval = qib_read_kreg64(dd, kr_serdes_cfg0);\n\tval |= SYM_MASK(SerdesCfg0, TxIdeEnX);\n\tqib_write_kreg(dd, kr_serdes_cfg0, val);\n}\n\n \nstatic void qib_6120_setup_setextled(struct qib_pportdata *ppd, u32 on)\n{\n\tu64 extctl, val, lst, ltst;\n\tunsigned long flags;\n\tstruct qib_devdata *dd = ppd->dd;\n\n\t \n\tif (dd->diag_client)\n\t\treturn;\n\n\t \n\tif (ppd->led_override) {\n\t\tltst = (ppd->led_override & QIB_LED_PHYS) ?\n\t\t\tIB_PHYSPORTSTATE_LINKUP : IB_PHYSPORTSTATE_DISABLED,\n\t\tlst = (ppd->led_override & QIB_LED_LOG) ?\n\t\t\tIB_PORT_ACTIVE : IB_PORT_DOWN;\n\t} else if (on) {\n\t\tval = qib_read_kreg64(dd, kr_ibcstatus);\n\t\tltst = qib_6120_phys_portstate(val);\n\t\tlst = qib_6120_iblink_state(val);\n\t} else {\n\t\tltst = 0;\n\t\tlst = 0;\n\t}\n\n\tspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\n\textctl = dd->cspec->extctrl & ~(SYM_MASK(EXTCtrl, LEDPriPortGreenOn) |\n\t\t\t\t SYM_MASK(EXTCtrl, LEDPriPortYellowOn));\n\n\tif (ltst == IB_PHYSPORTSTATE_LINKUP)\n\t\textctl |= SYM_MASK(EXTCtrl, LEDPriPortYellowOn);\n\tif (lst == IB_PORT_ACTIVE)\n\t\textctl |= SYM_MASK(EXTCtrl, LEDPriPortGreenOn);\n\tdd->cspec->extctrl = extctl;\n\tqib_write_kreg(dd, kr_extctrl, extctl);\n\tspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\n}\n\n \nstatic void qib_6120_setup_cleanup(struct qib_devdata *dd)\n{\n\tqib_free_irq(dd);\n\tkfree(dd->cspec->cntrs);\n\tkfree(dd->cspec->portcntrs);\n\tif (dd->cspec->dummy_hdrq) {\n\t\tdma_free_coherent(&dd->pcidev->dev,\n\t\t\t\t  ALIGN(dd->rcvhdrcnt *\n\t\t\t\t\tdd->rcvhdrentsize *\n\t\t\t\t\tsizeof(u32), PAGE_SIZE),\n\t\t\t\t  dd->cspec->dummy_hdrq,\n\t\t\t\t  dd->cspec->dummy_hdrq_phys);\n\t\tdd->cspec->dummy_hdrq = NULL;\n\t}\n}\n\nstatic void qib_wantpiobuf_6120_intr(struct qib_devdata *dd, u32 needint)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\tif (needint)\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, PIOIntBufAvail);\n\telse\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, PIOIntBufAvail);\n\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\n\tqib_write_kreg(dd, kr_scratch, 0ULL);\n\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n}\n\n \nstatic noinline void unlikely_6120_intr(struct qib_devdata *dd, u64 istat)\n{\n\tif (unlikely(istat & ~QLOGIC_IB_I_BITSEXTANT))\n\t\tqib_dev_err(dd, \"interrupt with unknown interrupts %Lx set\\n\",\n\t\t\t    istat & ~QLOGIC_IB_I_BITSEXTANT);\n\n\tif (istat & QLOGIC_IB_I_ERROR) {\n\t\tu64 estat = 0;\n\n\t\tqib_stats.sps_errints++;\n\t\testat = qib_read_kreg64(dd, kr_errstatus);\n\t\tif (!estat)\n\t\t\tqib_devinfo(dd->pcidev,\n\t\t\t\t\"error interrupt (%Lx), but no error bits set!\\n\",\n\t\t\t\tistat);\n\t\thandle_6120_errors(dd, estat);\n\t}\n\n\tif (istat & QLOGIC_IB_I_GPIO) {\n\t\tu32 gpiostatus;\n\t\tu32 to_clear = 0;\n\n\t\t \n\t\tgpiostatus = qib_read_kreg32(dd, kr_gpio_status);\n\t\t \n\t\tif (gpiostatus & GPIO_ERRINTR_MASK) {\n\t\t\t \n\t\t\tto_clear |= (gpiostatus & GPIO_ERRINTR_MASK);\n\n\t\t\t \n\t\t\tif (gpiostatus & (1 << GPIO_RXUVL_BIT))\n\t\t\t\tdd->cspec->rxfc_unsupvl_errs++;\n\t\t\tif (gpiostatus & (1 << GPIO_OVRUN_BIT))\n\t\t\t\tdd->cspec->overrun_thresh_errs++;\n\t\t\tif (gpiostatus & (1 << GPIO_LLI_BIT))\n\t\t\t\tdd->cspec->lli_errs++;\n\t\t\tgpiostatus &= ~GPIO_ERRINTR_MASK;\n\t\t}\n\t\tif (gpiostatus) {\n\t\t\t \n\t\t\tconst u32 mask = qib_read_kreg32(dd, kr_gpio_mask);\n\n\t\t\t \n\t\t\tif (mask & gpiostatus) {\n\t\t\t\tto_clear |= (gpiostatus & mask);\n\t\t\t\tdd->cspec->gpio_mask &= ~(gpiostatus & mask);\n\t\t\t\tqib_write_kreg(dd, kr_gpio_mask,\n\t\t\t\t\t       dd->cspec->gpio_mask);\n\t\t\t}\n\t\t}\n\t\tif (to_clear)\n\t\t\tqib_write_kreg(dd, kr_gpio_clear, (u64) to_clear);\n\t}\n}\n\nstatic irqreturn_t qib_6120intr(int irq, void *data)\n{\n\tstruct qib_devdata *dd = data;\n\tirqreturn_t ret;\n\tu32 istat, ctxtrbits, rmask, crcs = 0;\n\tunsigned i;\n\n\tif ((dd->flags & (QIB_PRESENT | QIB_BADINTR)) != QIB_PRESENT) {\n\t\t \n\t\tret = IRQ_HANDLED;\n\t\tgoto bail;\n\t}\n\n\tistat = qib_read_kreg32(dd, kr_intstatus);\n\n\tif (unlikely(!istat)) {\n\t\tret = IRQ_NONE;  \n\t\tgoto bail;\n\t}\n\tif (unlikely(istat == -1)) {\n\t\tqib_bad_intrstatus(dd);\n\t\t \n\t\tret = IRQ_NONE;\n\t\tgoto bail;\n\t}\n\n\tthis_cpu_inc(*dd->int_counter);\n\n\tif (unlikely(istat & (~QLOGIC_IB_I_BITSEXTANT |\n\t\t\t      QLOGIC_IB_I_GPIO | QLOGIC_IB_I_ERROR)))\n\t\tunlikely_6120_intr(dd, istat);\n\n\t \n\tqib_write_kreg(dd, kr_intclear, istat);\n\n\t \n\tctxtrbits = istat &\n\t\t((QLOGIC_IB_I_RCVAVAIL_MASK << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t (QLOGIC_IB_I_RCVURG_MASK << QLOGIC_IB_I_RCVURG_SHIFT));\n\tif (ctxtrbits) {\n\t\trmask = (1U << QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t\t(1U << QLOGIC_IB_I_RCVURG_SHIFT);\n\t\tfor (i = 0; i < dd->first_user_ctxt; i++) {\n\t\t\tif (ctxtrbits & rmask) {\n\t\t\t\tctxtrbits &= ~rmask;\n\t\t\t\tcrcs += qib_kreceive(dd->rcd[i],\n\t\t\t\t\t\t     &dd->cspec->lli_counter,\n\t\t\t\t\t\t     NULL);\n\t\t\t}\n\t\t\trmask <<= 1;\n\t\t}\n\t\tif (crcs) {\n\t\t\tu32 cntr = dd->cspec->lli_counter;\n\n\t\t\tcntr += crcs;\n\t\t\tif (cntr) {\n\t\t\t\tif (cntr > dd->cspec->lli_thresh) {\n\t\t\t\t\tdd->cspec->lli_counter = 0;\n\t\t\t\t\tdd->cspec->lli_errs++;\n\t\t\t\t} else\n\t\t\t\t\tdd->cspec->lli_counter += cntr;\n\t\t\t}\n\t\t}\n\n\n\t\tif (ctxtrbits) {\n\t\t\tctxtrbits =\n\t\t\t\t(ctxtrbits >> QLOGIC_IB_I_RCVAVAIL_SHIFT) |\n\t\t\t\t(ctxtrbits >> QLOGIC_IB_I_RCVURG_SHIFT);\n\t\t\tqib_handle_urcv(dd, ctxtrbits);\n\t\t}\n\t}\n\n\tif ((istat & QLOGIC_IB_I_SPIOBUFAVAIL) && (dd->flags & QIB_INITTED))\n\t\tqib_ib_piobufavail(dd);\n\n\tret = IRQ_HANDLED;\nbail:\n\treturn ret;\n}\n\n \nstatic void qib_setup_6120_interrupt(struct qib_devdata *dd)\n{\n\tint ret;\n\n\t \n\tif (SYM_FIELD(dd->revision, Revision_R,\n\t\t      ChipRevMinor) > 1) {\n\t\t \n\t\tdd->cspec->gpio_mask |= GPIO_ERRINTR_MASK;\n\t\tqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\n\t}\n\n\tret = pci_request_irq(dd->pcidev, 0, qib_6120intr, NULL, dd,\n\t\t\t      QIB_DRV_NAME);\n\tif (ret)\n\t\tqib_dev_err(dd,\n\t\t\t    \"Couldn't setup interrupt (irq=%d): %d\\n\",\n\t\t\t    pci_irq_vector(dd->pcidev, 0), ret);\n}\n\n \nstatic void pe_boardname(struct qib_devdata *dd)\n{\n\tu32 boardid;\n\n\tboardid = SYM_FIELD(dd->revision, Revision,\n\t\t\t    BoardID);\n\n\tswitch (boardid) {\n\tcase 2:\n\t\tdd->boardname = \"InfiniPath_QLE7140\";\n\t\tbreak;\n\tdefault:\n\t\tqib_dev_err(dd, \"Unknown 6120 board with ID %u\\n\", boardid);\n\t\tdd->boardname = \"Unknown_InfiniPath_6120\";\n\t\tbreak;\n\t}\n\n\tif (dd->majrev != 4 || !dd->minrev || dd->minrev > 2)\n\t\tqib_dev_err(dd,\n\t\t\t    \"Unsupported InfiniPath hardware revision %u.%u!\\n\",\n\t\t\t    dd->majrev, dd->minrev);\n\n\tsnprintf(dd->boardversion, sizeof(dd->boardversion),\n\t\t \"ChipABI %u.%u, %s, InfiniPath%u %u.%u, SW Compat %u\\n\",\n\t\t QIB_CHIP_VERS_MAJ, QIB_CHIP_VERS_MIN, dd->boardname,\n\t\t (unsigned int)SYM_FIELD(dd->revision, Revision_R, Arch),\n\t\t dd->majrev, dd->minrev,\n\t\t (unsigned int)SYM_FIELD(dd->revision, Revision_R, SW));\n}\n\n \nstatic int qib_6120_setup_reset(struct qib_devdata *dd)\n{\n\tu64 val;\n\tint i;\n\tint ret;\n\tu16 cmdval;\n\tu8 int_line, clinesz;\n\n\tqib_pcie_getcmd(dd, &cmdval, &int_line, &clinesz);\n\n\t \n\tqib_dev_err(dd, \"Resetting InfiniPath unit %u\\n\", dd->unit);\n\n\t \n\tqib_6120_set_intr_state(dd, 0);\n\n\tdd->cspec->ibdeltainprog = 0;\n\tdd->cspec->ibsymdelta = 0;\n\tdd->cspec->iblnkerrdelta = 0;\n\n\t \n\tdd->flags &= ~(QIB_INITTED | QIB_PRESENT);\n\t \n\tdd->z_int_counter = qib_int_counter(dd);\n\tval = dd->control | QLOGIC_IB_C_RESET;\n\twriteq(val, &dd->kregbase[kr_control]);\n\tmb();  \n\n\tfor (i = 1; i <= 5; i++) {\n\t\t \n\t\tmsleep(1000 + (1 + i) * 2000);\n\n\t\tqib_pcie_reenable(dd, cmdval, int_line, clinesz);\n\n\t\t \n\t\tval = readq(&dd->kregbase[kr_revision]);\n\t\tif (val == dd->revision) {\n\t\t\tdd->flags |= QIB_PRESENT;  \n\t\t\tret = qib_reinit_intr(dd);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\tret = 0;  \n\nbail:\n\tif (ret) {\n\t\tif (qib_pcie_params(dd, dd->lbus_width, NULL))\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Reset failed to setup PCIe or interrupts; continuing anyway\\n\");\n\t\t \n\t\tqib_6120_init_hwerrors(dd);\n\t\t \n\t\tqib_write_kreg(dd, kr_gpio_mask, dd->cspec->gpio_mask);\n\t\t \n\t\tqib_6120_init_hwerrors(dd);\n\t}\n\treturn ret;\n}\n\n \nstatic void qib_6120_put_tid(struct qib_devdata *dd, u64 __iomem *tidptr,\n\t\t\t     u32 type, unsigned long pa)\n{\n\tu32 __iomem *tidp32 = (u32 __iomem *)tidptr;\n\tunsigned long flags;\n\tint tidx;\n\tspinlock_t *tidlockp;  \n\n\tif (!dd->kregbase)\n\t\treturn;\n\n\tif (pa != dd->tidinvalid) {\n\t\tif (pa & ((1U << 11) - 1)) {\n\t\t\tqib_dev_err(dd, \"Physaddr %lx not 2KB aligned!\\n\",\n\t\t\t\t    pa);\n\t\t\treturn;\n\t\t}\n\t\tpa >>= 11;\n\t\tif (pa & ~QLOGIC_IB_RT_ADDR_MASK) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Physical page address 0x%lx larger than supported\\n\",\n\t\t\t\tpa);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type == RCVHQ_RCV_TYPE_EAGER)\n\t\t\tpa |= dd->tidtemplate;\n\t\telse  \n\t\t\tpa |= 2 << 29;\n\t}\n\n\t \n\t \n\ttidx = tidptr - dd->egrtidbase;\n\n\ttidlockp = (type == RCVHQ_RCV_TYPE_EAGER && tidx < dd->rcvhdrcnt)\n\t\t? &dd->cspec->kernel_tid_lock : &dd->cspec->user_tid_lock;\n\tspin_lock_irqsave(tidlockp, flags);\n\tqib_write_kreg(dd, kr_scratch, 0xfeeddeaf);\n\twritel(pa, tidp32);\n\tqib_write_kreg(dd, kr_scratch, 0xdeadbeef);\n\tspin_unlock_irqrestore(tidlockp, flags);\n}\n\n \nstatic void qib_6120_put_tid_2(struct qib_devdata *dd, u64 __iomem *tidptr,\n\t\t\t       u32 type, unsigned long pa)\n{\n\tu32 __iomem *tidp32 = (u32 __iomem *)tidptr;\n\n\tif (!dd->kregbase)\n\t\treturn;\n\n\tif (pa != dd->tidinvalid) {\n\t\tif (pa & ((1U << 11) - 1)) {\n\t\t\tqib_dev_err(dd, \"Physaddr %lx not 2KB aligned!\\n\",\n\t\t\t\t    pa);\n\t\t\treturn;\n\t\t}\n\t\tpa >>= 11;\n\t\tif (pa & ~QLOGIC_IB_RT_ADDR_MASK) {\n\t\t\tqib_dev_err(dd,\n\t\t\t\t\"Physical page address 0x%lx larger than supported\\n\",\n\t\t\t\tpa);\n\t\t\treturn;\n\t\t}\n\n\t\tif (type == RCVHQ_RCV_TYPE_EAGER)\n\t\t\tpa |= dd->tidtemplate;\n\t\telse  \n\t\t\tpa |= 2 << 29;\n\t}\n\twritel(pa, tidp32);\n}\n\n\n \nstatic void qib_6120_clear_tids(struct qib_devdata *dd,\n\t\t\t\tstruct qib_ctxtdata *rcd)\n{\n\tu64 __iomem *tidbase;\n\tunsigned long tidinv;\n\tu32 ctxt;\n\tint i;\n\n\tif (!dd->kregbase || !rcd)\n\t\treturn;\n\n\tctxt = rcd->ctxt;\n\n\ttidinv = dd->tidinvalid;\n\ttidbase = (u64 __iomem *)\n\t\t((char __iomem *)(dd->kregbase) +\n\t\t dd->rcvtidbase +\n\t\t ctxt * dd->rcvtidcnt * sizeof(*tidbase));\n\n\tfor (i = 0; i < dd->rcvtidcnt; i++)\n\t\t \n\t\tdd->f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EXPECTED,\n\t\t\t\t  tidinv);\n\n\ttidbase = (u64 __iomem *)\n\t\t((char __iomem *)(dd->kregbase) +\n\t\t dd->rcvegrbase +\n\t\t rcd->rcvegr_tid_base * sizeof(*tidbase));\n\n\tfor (i = 0; i < rcd->rcvegrcnt; i++)\n\t\t \n\t\tdd->f_put_tid(dd, &tidbase[i], RCVHQ_RCV_TYPE_EAGER,\n\t\t\t\t  tidinv);\n}\n\n \nstatic void qib_6120_tidtemplate(struct qib_devdata *dd)\n{\n\tu32 egrsize = dd->rcvegrbufsize;\n\n\t \n\tif (egrsize == 2048)\n\t\tdd->tidtemplate = 1U << 29;\n\telse if (egrsize == 4096)\n\t\tdd->tidtemplate = 2U << 29;\n\tdd->tidinvalid = 0;\n}\n\nint __attribute__((weak)) qib_unordered_wc(void)\n{\n\treturn 0;\n}\n\n \nstatic int qib_6120_get_base_info(struct qib_ctxtdata *rcd,\n\t\t\t\t  struct qib_base_info *kinfo)\n{\n\tif (qib_unordered_wc())\n\t\tkinfo->spi_runtime_flags |= QIB_RUNTIME_FORCE_WC_ORDER;\n\n\tkinfo->spi_runtime_flags |= QIB_RUNTIME_PCIE |\n\t\tQIB_RUNTIME_FORCE_PIOAVAIL | QIB_RUNTIME_PIO_REGSWAPPED;\n\treturn 0;\n}\n\n\nstatic struct qib_message_header *\nqib_6120_get_msgheader(struct qib_devdata *dd, __le32 *rhf_addr)\n{\n\treturn (struct qib_message_header *)\n\t\t&rhf_addr[sizeof(u64) / sizeof(u32)];\n}\n\nstatic void qib_6120_config_ctxts(struct qib_devdata *dd)\n{\n\tdd->ctxtcnt = qib_read_kreg32(dd, kr_portcnt);\n\tif (qib_n_krcv_queues > 1) {\n\t\tdd->first_user_ctxt = qib_n_krcv_queues * dd->num_pports;\n\t\tif (dd->first_user_ctxt > dd->ctxtcnt)\n\t\t\tdd->first_user_ctxt = dd->ctxtcnt;\n\t\tdd->qpn_mask = dd->first_user_ctxt <= 2 ? 2 : 6;\n\t} else\n\t\tdd->first_user_ctxt = dd->num_pports;\n\tdd->n_krcv_queues = dd->first_user_ctxt;\n}\n\nstatic void qib_update_6120_usrhead(struct qib_ctxtdata *rcd, u64 hd,\n\t\t\t\t    u32 updegr, u32 egrhd, u32 npkts)\n{\n\tif (updegr)\n\t\tqib_write_ureg(rcd->dd, ur_rcvegrindexhead, egrhd, rcd->ctxt);\n\tqib_write_ureg(rcd->dd, ur_rcvhdrhead, hd, rcd->ctxt);\n}\n\nstatic u32 qib_6120_hdrqempty(struct qib_ctxtdata *rcd)\n{\n\tu32 head, tail;\n\n\thead = qib_read_ureg32(rcd->dd, ur_rcvhdrhead, rcd->ctxt);\n\tif (rcd->rcvhdrtail_kvaddr)\n\t\ttail = qib_get_rcvhdrtail(rcd);\n\telse\n\t\ttail = qib_read_ureg32(rcd->dd, ur_rcvhdrtail, rcd->ctxt);\n\treturn head == tail;\n}\n\n \nstatic void alloc_dummy_hdrq(struct qib_devdata *dd)\n{\n\tdd->cspec->dummy_hdrq = dma_alloc_coherent(&dd->pcidev->dev,\n\t\t\t\t\tdd->rcd[0]->rcvhdrq_size,\n\t\t\t\t\t&dd->cspec->dummy_hdrq_phys,\n\t\t\t\t\tGFP_ATOMIC);\n\tif (!dd->cspec->dummy_hdrq) {\n\t\tqib_devinfo(dd->pcidev, \"Couldn't allocate dummy hdrq\\n\");\n\t\t \n\t\tdd->cspec->dummy_hdrq_phys = 0UL;\n\t}\n}\n\n \nstatic void rcvctrl_6120_mod(struct qib_pportdata *ppd, unsigned int op,\n\t\t\t     int ctxt)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 mask, val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->cspec->rcvmod_lock, flags);\n\n\tif (op & QIB_RCVCTRL_TAILUPD_ENB)\n\t\tdd->rcvctrl |= (1ULL << QLOGIC_IB_R_TAILUPD_SHIFT);\n\tif (op & QIB_RCVCTRL_TAILUPD_DIS)\n\t\tdd->rcvctrl &= ~(1ULL << QLOGIC_IB_R_TAILUPD_SHIFT);\n\tif (op & QIB_RCVCTRL_PKEY_ENB)\n\t\tdd->rcvctrl &= ~(1ULL << IBA6120_R_PKEY_DIS_SHIFT);\n\tif (op & QIB_RCVCTRL_PKEY_DIS)\n\t\tdd->rcvctrl |= (1ULL << IBA6120_R_PKEY_DIS_SHIFT);\n\tif (ctxt < 0)\n\t\tmask = (1ULL << dd->ctxtcnt) - 1;\n\telse\n\t\tmask = (1ULL << ctxt);\n\tif (op & QIB_RCVCTRL_CTXT_ENB) {\n\t\t \n\t\tdd->rcvctrl |= (mask << SYM_LSB(RcvCtrl, PortEnable));\n\t\tif (!(dd->flags & QIB_NODMA_RTAIL))\n\t\t\tdd->rcvctrl |= 1ULL << QLOGIC_IB_R_TAILUPD_SHIFT;\n\t\t \n\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\n\t\t\tdd->rcd[ctxt]->rcvhdrqtailaddr_phys);\n\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\n\t\t\tdd->rcd[ctxt]->rcvhdrq_phys);\n\n\t\tif (ctxt == 0 && !dd->cspec->dummy_hdrq)\n\t\t\talloc_dummy_hdrq(dd);\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_DIS)\n\t\tdd->rcvctrl &= ~(mask << SYM_LSB(RcvCtrl, PortEnable));\n\tif (op & QIB_RCVCTRL_INTRAVAIL_ENB)\n\t\tdd->rcvctrl |= (mask << QLOGIC_IB_R_INTRAVAIL_SHIFT);\n\tif (op & QIB_RCVCTRL_INTRAVAIL_DIS)\n\t\tdd->rcvctrl &= ~(mask << QLOGIC_IB_R_INTRAVAIL_SHIFT);\n\tqib_write_kreg(dd, kr_rcvctrl, dd->rcvctrl);\n\tif ((op & QIB_RCVCTRL_INTRAVAIL_ENB) && dd->rhdrhead_intr_off) {\n\t\t \n\t\tval = qib_read_ureg32(dd, ur_rcvhdrhead, ctxt) |\n\t\t\tdd->rhdrhead_intr_off;\n\t\tqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_ENB) {\n\t\t \n\t\tval = qib_read_ureg32(dd, ur_rcvegrindextail, ctxt);\n\t\tqib_write_ureg(dd, ur_rcvegrindexhead, val, ctxt);\n\n\t\tval = qib_read_ureg32(dd, ur_rcvhdrtail, ctxt);\n\t\tdd->rcd[ctxt]->head = val;\n\t\t \n\t\tif (ctxt < dd->first_user_ctxt)\n\t\t\tval |= dd->rhdrhead_intr_off;\n\t\tqib_write_ureg(dd, ur_rcvhdrhead, val, ctxt);\n\t}\n\tif (op & QIB_RCVCTRL_CTXT_DIS) {\n\t\t \n\t\tif (ctxt >= 0) {\n\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr, ctxt,\n\t\t\t\t\t    dd->cspec->dummy_hdrq_phys);\n\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr, ctxt,\n\t\t\t\t\t    dd->cspec->dummy_hdrq_phys);\n\t\t} else {\n\t\t\tunsigned i;\n\n\t\t\tfor (i = 0; i < dd->cfgctxts; i++) {\n\t\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdrtailaddr,\n\t\t\t\t\t    i, dd->cspec->dummy_hdrq_phys);\n\t\t\t\tqib_write_kreg_ctxt(dd, kr_rcvhdraddr,\n\t\t\t\t\t    i, dd->cspec->dummy_hdrq_phys);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dd->cspec->rcvmod_lock, flags);\n}\n\n \nstatic void sendctrl_6120_mod(struct qib_pportdata *ppd, u32 op)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tu64 tmp_dd_sendctrl;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&dd->sendctrl_lock, flags);\n\n\t \n\tif (op & QIB_SENDCTRL_CLEAR)\n\t\tdd->sendctrl = 0;\n\tif (op & QIB_SENDCTRL_SEND_DIS)\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, PIOEnable);\n\telse if (op & QIB_SENDCTRL_SEND_ENB)\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, PIOEnable);\n\tif (op & QIB_SENDCTRL_AVAIL_DIS)\n\t\tdd->sendctrl &= ~SYM_MASK(SendCtrl, PIOBufAvailUpd);\n\telse if (op & QIB_SENDCTRL_AVAIL_ENB)\n\t\tdd->sendctrl |= SYM_MASK(SendCtrl, PIOBufAvailUpd);\n\n\tif (op & QIB_SENDCTRL_DISARM_ALL) {\n\t\tu32 i, last;\n\n\t\ttmp_dd_sendctrl = dd->sendctrl;\n\t\t \n\t\tlast = dd->piobcnt2k + dd->piobcnt4k;\n\t\ttmp_dd_sendctrl &=\n\t\t\t~(SYM_MASK(SendCtrl, PIOEnable) |\n\t\t\t  SYM_MASK(SendCtrl, PIOBufAvailUpd));\n\t\tfor (i = 0; i < last; i++) {\n\t\t\tqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl |\n\t\t\t\t       SYM_MASK(SendCtrl, Disarm) | i);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t}\n\n\ttmp_dd_sendctrl = dd->sendctrl;\n\n\tif (op & QIB_SENDCTRL_FLUSH)\n\t\ttmp_dd_sendctrl |= SYM_MASK(SendCtrl, Abort);\n\tif (op & QIB_SENDCTRL_DISARM)\n\t\ttmp_dd_sendctrl |= SYM_MASK(SendCtrl, Disarm) |\n\t\t\t((op & QIB_6120_SendCtrl_DisarmPIOBuf_RMASK) <<\n\t\t\t SYM_LSB(SendCtrl, DisarmPIOBuf));\n\tif (op & QIB_SENDCTRL_AVAIL_BLIP)\n\t\ttmp_dd_sendctrl &= ~SYM_MASK(SendCtrl, PIOBufAvailUpd);\n\n\tqib_write_kreg(dd, kr_sendctrl, tmp_dd_sendctrl);\n\tqib_write_kreg(dd, kr_scratch, 0);\n\n\tif (op & QIB_SENDCTRL_AVAIL_BLIP) {\n\t\tqib_write_kreg(dd, kr_sendctrl, dd->sendctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t}\n\n\tspin_unlock_irqrestore(&dd->sendctrl_lock, flags);\n\n\tif (op & QIB_SENDCTRL_FLUSH) {\n\t\tu32 v;\n\t\t \n\t\tv = qib_read_kreg32(dd, kr_scratch);\n\t\tqib_write_kreg(dd, kr_scratch, v);\n\t\tv = qib_read_kreg32(dd, kr_scratch);\n\t\tqib_write_kreg(dd, kr_scratch, v);\n\t\tqib_read_kreg32(dd, kr_scratch);\n\t}\n}\n\n \nstatic u64 qib_portcntr_6120(struct qib_pportdata *ppd, u32 reg)\n{\n\tu64 ret = 0ULL;\n\tstruct qib_devdata *dd = ppd->dd;\n\tu16 creg;\n\t \n\tstatic const u16 xlator[] = {\n\t\t[QIBPORTCNTR_PKTSEND] = cr_pktsend,\n\t\t[QIBPORTCNTR_WORDSEND] = cr_wordsend,\n\t\t[QIBPORTCNTR_PSXMITDATA] = 0xffff,\n\t\t[QIBPORTCNTR_PSXMITPKTS] = 0xffff,\n\t\t[QIBPORTCNTR_PSXMITWAIT] = 0xffff,\n\t\t[QIBPORTCNTR_SENDSTALL] = cr_sendstall,\n\t\t[QIBPORTCNTR_PKTRCV] = cr_pktrcv,\n\t\t[QIBPORTCNTR_PSRCVDATA] = 0xffff,\n\t\t[QIBPORTCNTR_PSRCVPKTS] = 0xffff,\n\t\t[QIBPORTCNTR_RCVEBP] = cr_rcvebp,\n\t\t[QIBPORTCNTR_RCVOVFL] = cr_rcvovfl,\n\t\t[QIBPORTCNTR_WORDRCV] = cr_wordrcv,\n\t\t[QIBPORTCNTR_RXDROPPKT] = cr_rxdroppkt,\n\t\t[QIBPORTCNTR_RXLOCALPHYERR] = 0xffff,\n\t\t[QIBPORTCNTR_RXVLERR] = 0xffff,\n\t\t[QIBPORTCNTR_ERRICRC] = cr_erricrc,\n\t\t[QIBPORTCNTR_ERRVCRC] = cr_errvcrc,\n\t\t[QIBPORTCNTR_ERRLPCRC] = cr_errlpcrc,\n\t\t[QIBPORTCNTR_BADFORMAT] = cr_badformat,\n\t\t[QIBPORTCNTR_ERR_RLEN] = cr_err_rlen,\n\t\t[QIBPORTCNTR_IBSYMBOLERR] = cr_ibsymbolerr,\n\t\t[QIBPORTCNTR_INVALIDRLEN] = cr_invalidrlen,\n\t\t[QIBPORTCNTR_UNSUPVL] = cr_txunsupvl,\n\t\t[QIBPORTCNTR_EXCESSBUFOVFL] = 0xffff,\n\t\t[QIBPORTCNTR_ERRLINK] = cr_errlink,\n\t\t[QIBPORTCNTR_IBLINKDOWN] = cr_iblinkdown,\n\t\t[QIBPORTCNTR_IBLINKERRRECOV] = cr_iblinkerrrecov,\n\t\t[QIBPORTCNTR_LLI] = 0xffff,\n\t\t[QIBPORTCNTR_PSINTERVAL] = 0xffff,\n\t\t[QIBPORTCNTR_PSSTART] = 0xffff,\n\t\t[QIBPORTCNTR_PSSTAT] = 0xffff,\n\t\t[QIBPORTCNTR_VL15PKTDROP] = 0xffff,\n\t\t[QIBPORTCNTR_ERRPKEY] = cr_errpkey,\n\t\t[QIBPORTCNTR_KHDROVFL] = 0xffff,\n\t};\n\n\tif (reg >= ARRAY_SIZE(xlator)) {\n\t\tqib_devinfo(ppd->dd->pcidev,\n\t\t\t \"Unimplemented portcounter %u\\n\", reg);\n\t\tgoto done;\n\t}\n\tcreg = xlator[reg];\n\n\t \n\tif (reg == QIBPORTCNTR_LLI)\n\t\tret = dd->cspec->lli_errs;\n\telse if (reg == QIBPORTCNTR_EXCESSBUFOVFL)\n\t\tret = dd->cspec->overrun_thresh_errs;\n\telse if (reg == QIBPORTCNTR_KHDROVFL) {\n\t\tint i;\n\n\t\t \n\t\tfor (i = 0; i < dd->first_user_ctxt; i++)\n\t\t\tret += read_6120_creg32(dd, cr_portovfl + i);\n\t} else if (reg == QIBPORTCNTR_PSSTAT)\n\t\tret = dd->cspec->pma_sample_status;\n\tif (creg == 0xffff)\n\t\tgoto done;\n\n\t \n\tif (creg == cr_wordsend || creg == cr_wordrcv ||\n\t    creg == cr_pktsend || creg == cr_pktrcv)\n\t\tret = read_6120_creg(dd, creg);\n\telse\n\t\tret = read_6120_creg32(dd, creg);\n\tif (creg == cr_ibsymbolerr) {\n\t\tif (dd->cspec->ibdeltainprog)\n\t\t\tret -= ret - dd->cspec->ibsymsnap;\n\t\tret -= dd->cspec->ibsymdelta;\n\t} else if (creg == cr_iblinkerrrecov) {\n\t\tif (dd->cspec->ibdeltainprog)\n\t\t\tret -= ret - dd->cspec->iblnkerrsnap;\n\t\tret -= dd->cspec->iblnkerrdelta;\n\t}\n\tif (reg == QIBPORTCNTR_RXDROPPKT)  \n\t\tret += dd->cspec->rxfc_unsupvl_errs;\n\ndone:\n\treturn ret;\n}\n\n \nstatic const char cntr6120names[] =\n\t\"Interrupts\\n\"\n\t\"HostBusStall\\n\"\n\t\"E RxTIDFull\\n\"\n\t\"RxTIDInvalid\\n\"\n\t\"Ctxt0EgrOvfl\\n\"\n\t\"Ctxt1EgrOvfl\\n\"\n\t\"Ctxt2EgrOvfl\\n\"\n\t\"Ctxt3EgrOvfl\\n\"\n\t\"Ctxt4EgrOvfl\\n\";\n\nstatic const size_t cntr6120indices[] = {\n\tcr_lbint,\n\tcr_lbflowstall,\n\tcr_errtidfull,\n\tcr_errtidvalid,\n\tcr_portovfl + 0,\n\tcr_portovfl + 1,\n\tcr_portovfl + 2,\n\tcr_portovfl + 3,\n\tcr_portovfl + 4,\n};\n\n \nstatic const char portcntr6120names[] =\n\t\"TxPkt\\n\"\n\t\"TxFlowPkt\\n\"\n\t\"TxWords\\n\"\n\t\"RxPkt\\n\"\n\t\"RxFlowPkt\\n\"\n\t\"RxWords\\n\"\n\t\"TxFlowStall\\n\"\n\t\"E IBStatusChng\\n\"\n\t\"IBLinkDown\\n\"\n\t\"IBLnkRecov\\n\"\n\t\"IBRxLinkErr\\n\"\n\t\"IBSymbolErr\\n\"\n\t\"RxLLIErr\\n\"\n\t\"RxBadFormat\\n\"\n\t\"RxBadLen\\n\"\n\t\"RxBufOvrfl\\n\"\n\t\"RxEBP\\n\"\n\t\"RxFlowCtlErr\\n\"\n\t\"RxICRCerr\\n\"\n\t\"RxLPCRCerr\\n\"\n\t\"RxVCRCerr\\n\"\n\t\"RxInvalLen\\n\"\n\t\"RxInvalPKey\\n\"\n\t\"RxPktDropped\\n\"\n\t\"TxBadLength\\n\"\n\t\"TxDropped\\n\"\n\t\"TxInvalLen\\n\"\n\t\"TxUnderrun\\n\"\n\t\"TxUnsupVL\\n\"\n\t;\n\n#define _PORT_VIRT_FLAG 0x8000  \nstatic const size_t portcntr6120indices[] = {\n\tQIBPORTCNTR_PKTSEND | _PORT_VIRT_FLAG,\n\tcr_pktsendflow,\n\tQIBPORTCNTR_WORDSEND | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_PKTRCV | _PORT_VIRT_FLAG,\n\tcr_pktrcvflowctrl,\n\tQIBPORTCNTR_WORDRCV | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_SENDSTALL | _PORT_VIRT_FLAG,\n\tcr_ibstatuschange,\n\tQIBPORTCNTR_IBLINKDOWN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_IBLINKERRRECOV | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRLINK | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_IBSYMBOLERR | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_LLI | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_BADFORMAT | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERR_RLEN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RCVOVFL | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RCVEBP | _PORT_VIRT_FLAG,\n\tcr_rcvflowctrl_err,\n\tQIBPORTCNTR_ERRICRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRLPCRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRVCRC | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_INVALIDRLEN | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_ERRPKEY | _PORT_VIRT_FLAG,\n\tQIBPORTCNTR_RXDROPPKT | _PORT_VIRT_FLAG,\n\tcr_invalidslen,\n\tcr_senddropped,\n\tcr_errslen,\n\tcr_sendunderrun,\n\tcr_txunsupvl,\n};\n\n \nstatic void init_6120_cntrnames(struct qib_devdata *dd)\n{\n\tint i, j = 0;\n\tchar *s;\n\n\tfor (i = 0, s = (char *)cntr6120names; s && j <= dd->cfgctxts;\n\t     i++) {\n\t\t \n\t\tif (!j && !strncmp(\"Ctxt0EgrOvfl\", s + 1, 12))\n\t\t\tj = 1;\n\t\ts = strchr(s + 1, '\\n');\n\t\tif (s && j)\n\t\t\tj++;\n\t}\n\tdd->cspec->ncntrs = i;\n\tif (!s)\n\t\t \n\t\tdd->cspec->cntrnamelen = sizeof(cntr6120names) - 1;\n\telse\n\t\tdd->cspec->cntrnamelen = 1 + s - cntr6120names;\n\tdd->cspec->cntrs = kmalloc_array(dd->cspec->ncntrs, sizeof(u64),\n\t\t\t\t\t GFP_KERNEL);\n\n\tfor (i = 0, s = (char *)portcntr6120names; s; i++)\n\t\ts = strchr(s + 1, '\\n');\n\tdd->cspec->nportcntrs = i - 1;\n\tdd->cspec->portcntrnamelen = sizeof(portcntr6120names) - 1;\n\tdd->cspec->portcntrs = kmalloc_array(dd->cspec->nportcntrs,\n\t\t\t\t\t     sizeof(u64),\n\t\t\t\t\t     GFP_KERNEL);\n}\n\nstatic u32 qib_read_6120cntrs(struct qib_devdata *dd, loff_t pos, char **namep,\n\t\t\t      u64 **cntrp)\n{\n\tu32 ret;\n\n\tif (namep) {\n\t\tret = dd->cspec->cntrnamelen;\n\t\tif (pos >= ret)\n\t\t\tret = 0;  \n\t\telse\n\t\t\t*namep = (char *)cntr6120names;\n\t} else {\n\t\tu64 *cntr = dd->cspec->cntrs;\n\t\tint i;\n\n\t\tret = dd->cspec->ncntrs * sizeof(u64);\n\t\tif (!cntr || pos >= ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tif (pos >= ret) {\n\t\t\tret = 0;  \n\t\t\tgoto done;\n\t\t}\n\t\t*cntrp = cntr;\n\t\tfor (i = 0; i < dd->cspec->ncntrs; i++)\n\t\t\t*cntr++ = read_6120_creg32(dd, cntr6120indices[i]);\n\t}\ndone:\n\treturn ret;\n}\n\nstatic u32 qib_read_6120portcntrs(struct qib_devdata *dd, loff_t pos, u32 port,\n\t\t\t\t  char **namep, u64 **cntrp)\n{\n\tu32 ret;\n\n\tif (namep) {\n\t\tret = dd->cspec->portcntrnamelen;\n\t\tif (pos >= ret)\n\t\t\tret = 0;  \n\t\telse\n\t\t\t*namep = (char *)portcntr6120names;\n\t} else {\n\t\tu64 *cntr = dd->cspec->portcntrs;\n\t\tstruct qib_pportdata *ppd = &dd->pport[port];\n\t\tint i;\n\n\t\tret = dd->cspec->nportcntrs * sizeof(u64);\n\t\tif (!cntr || pos >= ret) {\n\t\t\t \n\t\t\tret = 0;\n\t\t\tgoto done;\n\t\t}\n\t\t*cntrp = cntr;\n\t\tfor (i = 0; i < dd->cspec->nportcntrs; i++) {\n\t\t\tif (portcntr6120indices[i] & _PORT_VIRT_FLAG)\n\t\t\t\t*cntr++ = qib_portcntr_6120(ppd,\n\t\t\t\t\tportcntr6120indices[i] &\n\t\t\t\t\t~_PORT_VIRT_FLAG);\n\t\t\telse\n\t\t\t\t*cntr++ = read_6120_creg32(dd,\n\t\t\t\t\t   portcntr6120indices[i]);\n\t\t}\n\t}\ndone:\n\treturn ret;\n}\n\nstatic void qib_chk_6120_errormask(struct qib_devdata *dd)\n{\n\tstatic u32 fixed;\n\tu32 ctrl;\n\tunsigned long errormask;\n\tunsigned long hwerrs;\n\n\tif (!dd->cspec->errormask || !(dd->flags & QIB_INITTED))\n\t\treturn;\n\n\terrormask = qib_read_kreg64(dd, kr_errmask);\n\n\tif (errormask == dd->cspec->errormask)\n\t\treturn;\n\tfixed++;\n\n\thwerrs = qib_read_kreg64(dd, kr_hwerrstatus);\n\tctrl = qib_read_kreg32(dd, kr_control);\n\n\tqib_write_kreg(dd, kr_errmask,\n\t\tdd->cspec->errormask);\n\n\tif ((hwerrs & dd->cspec->hwerrmask) ||\n\t    (ctrl & QLOGIC_IB_C_FREEZEMODE)) {\n\t\tqib_write_kreg(dd, kr_hwerrclear, 0ULL);\n\t\tqib_write_kreg(dd, kr_errclear, 0ULL);\n\t\t \n\t\tqib_write_kreg(dd, kr_intclear, 0ULL);\n\t\tqib_devinfo(dd->pcidev,\n\t\t\t \"errormask fixed(%u) %lx->%lx, ctrl %x hwerr %lx\\n\",\n\t\t\t fixed, errormask, (unsigned long)dd->cspec->errormask,\n\t\t\t ctrl, hwerrs);\n\t}\n}\n\n \nstatic void qib_get_6120_faststats(struct timer_list *t)\n{\n\tstruct qib_devdata *dd = from_timer(dd, t, stats_timer);\n\tstruct qib_pportdata *ppd = dd->pport;\n\tunsigned long flags;\n\tu64 traffic_wds;\n\n\t \n\tif (!(dd->flags & QIB_INITTED) || dd->diag_client)\n\t\t \n\t\tgoto done;\n\n\t \n\ttraffic_wds = qib_portcntr_6120(ppd, cr_wordsend) +\n\t\tqib_portcntr_6120(ppd, cr_wordrcv);\n\tspin_lock_irqsave(&dd->eep_st_lock, flags);\n\ttraffic_wds -= dd->traffic_wds;\n\tdd->traffic_wds += traffic_wds;\n\tspin_unlock_irqrestore(&dd->eep_st_lock, flags);\n\n\tqib_chk_6120_errormask(dd);\ndone:\n\tmod_timer(&dd->stats_timer, jiffies + HZ * ACTIVITY_TIMER);\n}\n\n \nstatic int qib_6120_nointr_fallback(struct qib_devdata *dd)\n{\n\treturn 0;\n}\n\n \nstatic void qib_6120_xgxs_reset(struct qib_pportdata *ppd)\n{\n\tu64 val, prev_val;\n\tstruct qib_devdata *dd = ppd->dd;\n\n\tprev_val = qib_read_kreg64(dd, kr_xgxs_cfg);\n\tval = prev_val | QLOGIC_IB_XGXS_RESET;\n\tprev_val &= ~QLOGIC_IB_XGXS_RESET;  \n\tqib_write_kreg(dd, kr_control,\n\t\t       dd->control & ~QLOGIC_IB_C_LINKENABLE);\n\tqib_write_kreg(dd, kr_xgxs_cfg, val);\n\tqib_read_kreg32(dd, kr_scratch);\n\tqib_write_kreg(dd, kr_xgxs_cfg, prev_val);\n\tqib_write_kreg(dd, kr_control, dd->control);\n}\n\nstatic int qib_6120_get_ib_cfg(struct qib_pportdata *ppd, int which)\n{\n\tint ret;\n\n\tswitch (which) {\n\tcase QIB_IB_CFG_LWID:\n\t\tret = ppd->link_width_active;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_SPD:\n\t\tret = ppd->link_speed_active;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LWID_ENB:\n\t\tret = ppd->link_width_enabled;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_SPD_ENB:\n\t\tret = ppd->link_speed_enabled;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_OP_VLS:\n\t\tret = ppd->vls_operational;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_VL_HIGH_CAP:\n\t\tret = 0;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_VL_LOW_CAP:\n\t\tret = 0;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_OVERRUN_THRESH:  \n\t\tret = SYM_FIELD(ppd->dd->cspec->ibcctrl, IBCCtrl,\n\t\t\t\tOverrunThreshold);\n\t\tbreak;\n\n\tcase QIB_IB_CFG_PHYERR_THRESH:  \n\t\tret = SYM_FIELD(ppd->dd->cspec->ibcctrl, IBCCtrl,\n\t\t\t\tPhyerrThreshold);\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LINKDEFAULT:  \n\t\t \n\t\tret = (ppd->dd->cspec->ibcctrl &\n\t\t       SYM_MASK(IBCCtrl, LinkDownDefaultState)) ?\n\t\t\tIB_LINKINITCMD_SLEEP : IB_LINKINITCMD_POLL;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_HRTBT:  \n\t\tret = 0;  \n\t\tbreak;\n\n\tcase QIB_IB_CFG_PMA_TICKS:\n\t\tret = 250;  \n\t\tbreak;\n\n\tdefault:\n\t\tret =  -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int qib_6120_set_ib_cfg(struct qib_pportdata *ppd, int which, u32 val)\n{\n\tstruct qib_devdata *dd = ppd->dd;\n\tint ret = 0;\n\tu64 val64;\n\tu16 lcmd, licmd;\n\n\tswitch (which) {\n\tcase QIB_IB_CFG_LWID_ENB:\n\t\tppd->link_width_enabled = val;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_SPD_ENB:\n\t\tppd->link_speed_enabled = val;\n\t\tbreak;\n\n\tcase QIB_IB_CFG_OVERRUN_THRESH:  \n\t\tval64 = SYM_FIELD(dd->cspec->ibcctrl, IBCCtrl,\n\t\t\t\t  OverrunThreshold);\n\t\tif (val64 != val) {\n\t\t\tdd->cspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, OverrunThreshold);\n\t\t\tdd->cspec->ibcctrl |= (u64) val <<\n\t\t\t\tSYM_LSB(IBCCtrl, OverrunThreshold);\n\t\t\tqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t\tbreak;\n\n\tcase QIB_IB_CFG_PHYERR_THRESH:  \n\t\tval64 = SYM_FIELD(dd->cspec->ibcctrl, IBCCtrl,\n\t\t\t\t  PhyerrThreshold);\n\t\tif (val64 != val) {\n\t\t\tdd->cspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, PhyerrThreshold);\n\t\t\tdd->cspec->ibcctrl |= (u64) val <<\n\t\t\t\tSYM_LSB(IBCCtrl, PhyerrThreshold);\n\t\t\tqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\n\t\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\t}\n\t\tbreak;\n\n\tcase QIB_IB_CFG_PKEYS:  \n\t\tval64 = (u64) ppd->pkeys[0] | ((u64) ppd->pkeys[1] << 16) |\n\t\t\t((u64) ppd->pkeys[2] << 32) |\n\t\t\t((u64) ppd->pkeys[3] << 48);\n\t\tqib_write_kreg(dd, kr_partitionkey, val64);\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LINKDEFAULT:  \n\t\t \n\t\tif (val == IB_LINKINITCMD_POLL)\n\t\t\tdd->cspec->ibcctrl &=\n\t\t\t\t~SYM_MASK(IBCCtrl, LinkDownDefaultState);\n\t\telse  \n\t\t\tdd->cspec->ibcctrl |=\n\t\t\t\tSYM_MASK(IBCCtrl, LinkDownDefaultState);\n\t\tqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\tbreak;\n\n\tcase QIB_IB_CFG_MTU:  \n\t\t \n\t\tval = (ppd->ibmaxlen >> 2) + 1;\n\t\tdd->cspec->ibcctrl &= ~SYM_MASK(IBCCtrl, MaxPktLen);\n\t\tdd->cspec->ibcctrl |= (u64)val <<\n\t\t\tSYM_LSB(IBCCtrl, MaxPktLen);\n\t\tqib_write_kreg(dd, kr_ibcctrl, dd->cspec->ibcctrl);\n\t\tqib_write_kreg(dd, kr_scratch, 0);\n\t\tbreak;\n\n\tcase QIB_IB_CFG_LSTATE:  \n\t\tswitch (val & 0xffff0000) {\n\t\tcase IB_LINKCMD_DOWN:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_DOWN;\n\t\t\tif (!dd->cspec->ibdeltainprog) {\n\t\t\t\tdd->cspec->ibdeltainprog = 1;\n\t\t\t\tdd->cspec->ibsymsnap =\n\t\t\t\t\tread_6120_creg32(dd, cr_ibsymbolerr);\n\t\t\t\tdd->cspec->iblnkerrsnap =\n\t\t\t\t\tread_6120_creg32(dd, cr_iblinkerrrecov);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase IB_LINKCMD_ARMED:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_ARMED;\n\t\t\tbreak;\n\n\t\tcase IB_LINKCMD_ACTIVE:\n\t\t\tlcmd = QLOGIC_IB_IBCC_LINKCMD_ACTIVE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tqib_dev_err(dd, \"bad linkcmd req 0x%x\\n\", val >> 16);\n\t\t\tgoto bail;\n\t\t}\n\t\tswitch (val & 0xffff) {\n\t\tcase IB_LINKINITCMD_NOP:\n\t\t\tlicmd = 0;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_POLL:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_POLL;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_SLEEP:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_SLEEP;\n\t\t\tbreak;\n\n\t\tcase IB_LINKINITCMD_DISABLE:\n\t\t\tlicmd = QLOGIC_IB_IBCC_LINKINITCMD_DISABLE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tqib_dev_err(dd, \"bad linkinitcmd req 0x%x\\n\",\n\t\t\t\t    val & 0xffff);\n\t\t\tgoto bail;\n\t\t}\n\t\tqib_set_ib_6120_lstate(ppd, lcmd, licmd);\n\t\tgoto bail;\n\n\tcase QIB_IB_CFG_HRTBT:\n\t\tret = -EINVAL;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\nbail:\n\treturn ret;\n}\n\nstatic int qib_6120_set_loopback(struct qib_pportdata *ppd, const char *what)\n{\n\tint ret = 0;\n\n\tif (!strncmp(what, \"ibc\", 3)) {\n\t\tppd->dd->cspec->ibcctrl |= SYM_MASK(IBCCtrl, Loopback);\n\t\tqib_devinfo(ppd->dd->pcidev, \"Enabling IB%u:%u IBC loopback\\n\",\n\t\t\t ppd->dd->unit, ppd->port);\n\t} else if (!strncmp(what, \"off\", 3)) {\n\t\tppd->dd->cspec->ibcctrl &= ~SYM_MASK(IBCCtrl, Loopback);\n\t\tqib_devinfo(ppd->dd->pcidev,\n\t\t\t\"Disabling IB%u:%u IBC loopback (normal)\\n\",\n\t\t\tppd->dd->unit, ppd->port);\n\t} else\n\t\tret = -EINVAL;\n\tif (!ret) {\n\t\tqib_write_kreg(ppd->dd, kr_ibcctrl, ppd->dd->cspec->ibcctrl);\n\t\tqib_write_kreg(ppd->dd, kr_scratch, 0);\n\t}\n\treturn ret;\n}\n\nstatic void pma_6120_timer(struct timer_list *t)\n{\n\tstruct qib_chip_specific *cs = from_timer(cs, t, pma_timer);\n\tstruct qib_pportdata *ppd = cs->ppd;\n\tstruct qib_ibport *ibp = &ppd->ibport_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ibp->rvp.lock, flags);\n\tif (cs->pma_sample_status == IB_PMA_SAMPLE_STATUS_STARTED) {\n\t\tcs->pma_sample_status = IB_PMA_SAMPLE_STATUS_RUNNING;\n\t\tqib_snapshot_counters(ppd, &cs->sword, &cs->rword,\n\t\t\t\t      &cs->spkts, &cs->rpkts, &cs->xmit_wait);\n\t\tmod_timer(&cs->pma_timer,\n\t\t      jiffies + usecs_to_jiffies(ibp->rvp.pma_sample_interval));\n\t} else if (cs->pma_sample_status == IB_PMA_SAMPLE_STATUS_RUNNING) {\n\t\tu64 ta, tb, tc, td, te;\n\n\t\tcs->pma_sample_status = IB_PMA_SAMPLE_STATUS_DONE;\n\t\tqib_snapshot_counters(ppd, &ta, &tb, &tc, &td, &te);\n\n\t\tcs->sword = ta - cs->sword;\n\t\tcs->rword = tb - cs->rword;\n\t\tcs->spkts = tc - cs->spkts;\n\t\tcs->rpkts = td - cs->rpkts;\n\t\tcs->xmit_wait = te - cs->xmit_wait;\n\t}\n\tspin_unlock_irqrestore(&ibp->rvp.lock, flags);\n}\n\n \nstatic void qib_set_cntr_6120_sample(struct qib_pportdata *ppd, u32 intv,\n\t\t\t\t     u32 start)\n{\n\tstruct qib_chip_specific *cs = ppd->dd->cspec;\n\n\tif (start && intv) {\n\t\tcs->pma_sample_status = IB_PMA_SAMPLE_STATUS_STARTED;\n\t\tmod_timer(&cs->pma_timer, jiffies + usecs_to_jiffies(start));\n\t} else if (intv) {\n\t\tcs->pma_sample_status = IB_PMA_SAMPLE_STATUS_RUNNING;\n\t\tqib_snapshot_counters(ppd, &cs->sword, &cs->rword,\n\t\t\t\t      &cs->spkts, &cs->rpkts, &cs->xmit_wait);\n\t\tmod_timer(&cs->pma_timer, jiffies + usecs_to_jiffies(intv));\n\t} else {\n\t\tcs->pma_sample_status = IB_PMA_SAMPLE_STATUS_DONE;\n\t\tcs->sword = 0;\n\t\tcs->rword = 0;\n\t\tcs->spkts = 0;\n\t\tcs->rpkts = 0;\n\t\tcs->xmit_wait = 0;\n\t}\n}\n\nstatic u32 qib_6120_iblink_state(u64 ibcs)\n{\n\tu32 state = (u32)SYM_FIELD(ibcs, IBCStatus, LinkState);\n\n\tswitch (state) {\n\tcase IB_6120_L_STATE_INIT:\n\t\tstate = IB_PORT_INIT;\n\t\tbreak;\n\tcase IB_6120_L_STATE_ARM:\n\t\tstate = IB_PORT_ARMED;\n\t\tbreak;\n\tcase IB_6120_L_STATE_ACTIVE:\n\tcase IB_6120_L_STATE_ACT_DEFER:\n\t\tstate = IB_PORT_ACTIVE;\n\t\tbreak;\n\tdefault:\n\t\tfallthrough;\n\tcase IB_6120_L_STATE_DOWN:\n\t\tstate = IB_PORT_DOWN;\n\t\tbreak;\n\t}\n\treturn state;\n}\n\n \nstatic u8 qib_6120_phys_portstate(u64 ibcs)\n{\n\tu8 state = (u8)SYM_FIELD(ibcs, IBCStatus, LinkTrainingState);\n\treturn qib_6120_physportstate[state];\n}\n\nstatic int qib_6120_ib_updown(struct qib_pportdata *ppd, int ibup, u64 ibcs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ppd->lflags_lock, flags);\n\tppd->lflags &= ~QIBL_IB_FORCE_NOTIFY;\n\tspin_unlock_irqrestore(&ppd->lflags_lock, flags);\n\n\tif (ibup) {\n\t\tif (ppd->dd->cspec->ibdeltainprog) {\n\t\t\tppd->dd->cspec->ibdeltainprog = 0;\n\t\t\tppd->dd->cspec->ibsymdelta +=\n\t\t\t\tread_6120_creg32(ppd->dd, cr_ibsymbolerr) -\n\t\t\t\t\tppd->dd->cspec->ibsymsnap;\n\t\t\tppd->dd->cspec->iblnkerrdelta +=\n\t\t\t\tread_6120_creg32(ppd->dd, cr_iblinkerrrecov) -\n\t\t\t\t\tppd->dd->cspec->iblnkerrsnap;\n\t\t}\n\t\tqib_hol_init(ppd);\n\t} else {\n\t\tppd->dd->cspec->lli_counter = 0;\n\t\tif (!ppd->dd->cspec->ibdeltainprog) {\n\t\t\tppd->dd->cspec->ibdeltainprog = 1;\n\t\t\tppd->dd->cspec->ibsymsnap =\n\t\t\t\tread_6120_creg32(ppd->dd, cr_ibsymbolerr);\n\t\t\tppd->dd->cspec->iblnkerrsnap =\n\t\t\t\tread_6120_creg32(ppd->dd, cr_iblinkerrrecov);\n\t\t}\n\t\tqib_hol_down(ppd);\n\t}\n\n\tqib_6120_setup_setextled(ppd, ibup);\n\n\treturn 0;\n}\n\n \nstatic int gpio_6120_mod(struct qib_devdata *dd, u32 out, u32 dir, u32 mask)\n{\n\tu64 read_val, new_out;\n\tunsigned long flags;\n\n\tif (mask) {\n\t\t \n\t\tdir &= mask;\n\t\tout &= mask;\n\t\tspin_lock_irqsave(&dd->cspec->gpio_lock, flags);\n\t\tdd->cspec->extctrl &= ~((u64)mask << SYM_LSB(EXTCtrl, GPIOOe));\n\t\tdd->cspec->extctrl |= ((u64) dir << SYM_LSB(EXTCtrl, GPIOOe));\n\t\tnew_out = (dd->cspec->gpio_out & ~mask) | out;\n\n\t\tqib_write_kreg(dd, kr_extctrl, dd->cspec->extctrl);\n\t\tqib_write_kreg(dd, kr_gpio_out, new_out);\n\t\tdd->cspec->gpio_out = new_out;\n\t\tspin_unlock_irqrestore(&dd->cspec->gpio_lock, flags);\n\t}\n\t \n\tread_val = qib_read_kreg64(dd, kr_extstatus);\n\treturn SYM_FIELD(read_val, EXTStatus, GPIOIn);\n}\n\n \nstatic void get_6120_chip_params(struct qib_devdata *dd)\n{\n\tu64 val;\n\tu32 piobufs;\n\tint mtu;\n\n\tdd->uregbase = qib_read_kreg32(dd, kr_userregbase);\n\n\tdd->rcvtidcnt = qib_read_kreg32(dd, kr_rcvtidcnt);\n\tdd->rcvtidbase = qib_read_kreg32(dd, kr_rcvtidbase);\n\tdd->rcvegrbase = qib_read_kreg32(dd, kr_rcvegrbase);\n\tdd->palign = qib_read_kreg32(dd, kr_palign);\n\tdd->piobufbase = qib_read_kreg64(dd, kr_sendpiobufbase);\n\tdd->pio2k_bufbase = dd->piobufbase & 0xffffffff;\n\n\tdd->rcvhdrcnt = qib_read_kreg32(dd, kr_rcvegrcnt);\n\n\tval = qib_read_kreg64(dd, kr_sendpiosize);\n\tdd->piosize2k = val & ~0U;\n\tdd->piosize4k = val >> 32;\n\n\tmtu = ib_mtu_enum_to_int(qib_ibmtu);\n\tif (mtu == -1)\n\t\tmtu = QIB_DEFAULT_MTU;\n\tdd->pport->ibmtu = (u32)mtu;\n\n\tval = qib_read_kreg64(dd, kr_sendpiobufcnt);\n\tdd->piobcnt2k = val & ~0U;\n\tdd->piobcnt4k = val >> 32;\n\tdd->last_pio = dd->piobcnt4k + dd->piobcnt2k - 1;\n\t \n\tdd->pio2kbase = (u32 __iomem *)\n\t\t(((char __iomem *)dd->kregbase) + dd->pio2k_bufbase);\n\tif (dd->piobcnt4k) {\n\t\tdd->pio4kbase = (u32 __iomem *)\n\t\t\t(((char __iomem *) dd->kregbase) +\n\t\t\t (dd->piobufbase >> 32));\n\t\t \n\t\tdd->align4k = ALIGN(dd->piosize4k, dd->palign);\n\t}\n\n\tpiobufs = dd->piobcnt4k + dd->piobcnt2k;\n\n\tdd->pioavregs = ALIGN(piobufs, sizeof(u64) * BITS_PER_BYTE / 2) /\n\t\t(sizeof(u64) * BITS_PER_BYTE / 2);\n}\n\n \nstatic void set_6120_baseaddrs(struct qib_devdata *dd)\n{\n\tu32 cregbase;\n\n\tcregbase = qib_read_kreg32(dd, kr_counterregbase);\n\tdd->cspec->cregbase = (u64 __iomem *)\n\t\t((char __iomem *) dd->kregbase + cregbase);\n\n\tdd->egrtidbase = (u64 __iomem *)\n\t\t((char __iomem *) dd->kregbase + dd->rcvegrbase);\n}\n\n \nstatic int qib_late_6120_initreg(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\tu64 val;\n\n\tqib_write_kreg(dd, kr_rcvhdrentsize, dd->rcvhdrentsize);\n\tqib_write_kreg(dd, kr_rcvhdrsize, dd->rcvhdrsize);\n\tqib_write_kreg(dd, kr_rcvhdrcnt, dd->rcvhdrcnt);\n\tqib_write_kreg(dd, kr_sendpioavailaddr, dd->pioavailregs_phys);\n\tval = qib_read_kreg64(dd, kr_sendpioavailaddr);\n\tif (val != dd->pioavailregs_phys) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Catastrophic software error, SendPIOAvailAddr written as %lx, read back as %llx\\n\",\n\t\t\t(unsigned long) dd->pioavailregs_phys,\n\t\t\t(unsigned long long) val);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nstatic int init_6120_variables(struct qib_devdata *dd)\n{\n\tint ret = 0;\n\tstruct qib_pportdata *ppd;\n\tu32 sbufs;\n\n\tppd = (struct qib_pportdata *)(dd + 1);\n\tdd->pport = ppd;\n\tdd->num_pports = 1;\n\n\tdd->cspec = (struct qib_chip_specific *)(ppd + dd->num_pports);\n\tdd->cspec->ppd = ppd;\n\tppd->cpspec = NULL;  \n\n\tspin_lock_init(&dd->cspec->kernel_tid_lock);\n\tspin_lock_init(&dd->cspec->user_tid_lock);\n\tspin_lock_init(&dd->cspec->rcvmod_lock);\n\tspin_lock_init(&dd->cspec->gpio_lock);\n\n\t \n\tdd->revision = readq(&dd->kregbase[kr_revision]);\n\n\tif ((dd->revision & 0xffffffffU) == 0xffffffffU) {\n\t\tqib_dev_err(dd,\n\t\t\t\"Revision register read failure, giving up initialization\\n\");\n\t\tret = -ENODEV;\n\t\tgoto bail;\n\t}\n\tdd->flags |= QIB_PRESENT;   \n\n\tdd->majrev = (u8) SYM_FIELD(dd->revision, Revision_R,\n\t\t\t\t    ChipRevMajor);\n\tdd->minrev = (u8) SYM_FIELD(dd->revision, Revision_R,\n\t\t\t\t    ChipRevMinor);\n\n\tget_6120_chip_params(dd);\n\tpe_boardname(dd);  \n\n\t \n\tdd->gpio_sda_num = _QIB_GPIO_SDA_NUM;\n\tdd->gpio_scl_num = _QIB_GPIO_SCL_NUM;\n\tdd->twsi_eeprom_dev = QIB_TWSI_NO_DEV;\n\n\tif (qib_unordered_wc())\n\t\tdd->flags |= QIB_PIO_FLUSH_WC;\n\n\tret = qib_init_pportdata(ppd, dd, 0, 1);\n\tif (ret)\n\t\tgoto bail;\n\tppd->link_width_supported = IB_WIDTH_1X | IB_WIDTH_4X;\n\tppd->link_speed_supported = QIB_IB_SDR;\n\tppd->link_width_enabled = IB_WIDTH_4X;\n\tppd->link_speed_enabled = ppd->link_speed_supported;\n\t \n\tppd->link_width_active = ppd->link_width_enabled;\n\tppd->link_speed_active = ppd->link_speed_enabled;\n\tppd->vls_supported = IB_VL_VL0;\n\tppd->vls_operational = ppd->vls_supported;\n\n\tdd->rcvhdrentsize = QIB_RCVHDR_ENTSIZE;\n\tdd->rcvhdrsize = QIB_DFLT_RCVHDRSIZE;\n\tdd->rhf_offset = 0;\n\n\t \n\tret = ib_mtu_enum_to_int(qib_ibmtu);\n\tdd->rcvegrbufsize = ret != -1 ? max(ret, 2048) : QIB_DEFAULT_MTU;\n\tdd->rcvegrbufsize_shift = ilog2(dd->rcvegrbufsize);\n\n\tqib_6120_tidtemplate(dd);\n\n\t \n\tdd->rhdrhead_intr_off = 1ULL << 32;\n\n\t \n\ttimer_setup(&dd->stats_timer, qib_get_6120_faststats, 0);\n\ttimer_setup(&dd->cspec->pma_timer, pma_6120_timer, 0);\n\n\tdd->ureg_align = qib_read_kreg32(dd, kr_palign);\n\n\tdd->piosize2kmax_dwords = dd->piosize2k >> 2;\n\tqib_6120_config_ctxts(dd);\n\tqib_set_ctxtcnt(dd);\n\n\tret = init_chip_wc_pat(dd, 0);\n\tif (ret)\n\t\tgoto bail;\n\tset_6120_baseaddrs(dd);  \n\n\tret = 0;\n\tif (qib_mini_init)\n\t\tgoto bail;\n\n\tqib_num_cfg_vls = 1;  \n\n\tret = qib_create_ctxts(dd);\n\tinit_6120_cntrnames(dd);\n\n\t \n\tsbufs = dd->piobcnt4k ?  dd->piobcnt4k : 16;\n\n\tdd->lastctxt_piobuf = dd->piobcnt2k + dd->piobcnt4k - sbufs;\n\tdd->pbufsctxt = dd->lastctxt_piobuf /\n\t\t(dd->cfgctxts - dd->first_user_ctxt);\n\n\tif (ret)\n\t\tgoto bail;\nbail:\n\treturn ret;\n}\n\n \nstatic u32 __iomem *get_6120_link_buf(struct qib_pportdata *ppd, u32 *bnum)\n{\n\tu32 __iomem *buf;\n\tu32 lbuf = ppd->dd->piobcnt2k + ppd->dd->piobcnt4k - 1;\n\n\t \n\tsendctrl_6120_mod(ppd->dd->pport, QIB_SENDCTRL_AVAIL_BLIP);\n\tqib_read_kreg64(ppd->dd, kr_scratch);  \n\tbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\n\tif (buf)\n\t\tgoto done;\n\n\tsendctrl_6120_mod(ppd, QIB_SENDCTRL_DISARM_ALL | QIB_SENDCTRL_FLUSH |\n\t\t\t  QIB_SENDCTRL_AVAIL_BLIP);\n\tppd->dd->upd_pio_shadow  = 1;  \n\tqib_read_kreg64(ppd->dd, kr_scratch);  \n\tbuf = qib_getsendbuf_range(ppd->dd, bnum, lbuf, lbuf);\ndone:\n\treturn buf;\n}\n\nstatic u32 __iomem *qib_6120_getsendbuf(struct qib_pportdata *ppd, u64 pbc,\n\t\t\t\t\tu32 *pbufnum)\n{\n\tu32 first, last, plen = pbc & QIB_PBC_LENGTH_MASK;\n\tstruct qib_devdata *dd = ppd->dd;\n\tu32 __iomem *buf;\n\n\tif (((pbc >> 32) & PBC_6120_VL15_SEND_CTRL) &&\n\t\t!(ppd->lflags & (QIBL_IB_AUTONEG_INPROG | QIBL_LINKACTIVE)))\n\t\tbuf = get_6120_link_buf(ppd, pbufnum);\n\telse {\n\n\t\tif ((plen + 1) > dd->piosize2kmax_dwords)\n\t\t\tfirst = dd->piobcnt2k;\n\t\telse\n\t\t\tfirst = 0;\n\t\t \n\t\tlast = dd->piobcnt2k + dd->piobcnt4k - 1;\n\t\tbuf = qib_getsendbuf_range(dd, pbufnum, first, last);\n\t}\n\treturn buf;\n}\n\nstatic int init_sdma_6120_regs(struct qib_pportdata *ppd)\n{\n\treturn -ENODEV;\n}\n\nstatic u16 qib_sdma_6120_gethead(struct qib_pportdata *ppd)\n{\n\treturn 0;\n}\n\nstatic int qib_sdma_6120_busy(struct qib_pportdata *ppd)\n{\n\treturn 0;\n}\n\nstatic void qib_sdma_update_6120_tail(struct qib_pportdata *ppd, u16 tail)\n{\n}\n\nstatic void qib_6120_sdma_sendctrl(struct qib_pportdata *ppd, unsigned op)\n{\n}\n\nstatic void qib_sdma_set_6120_desc_cnt(struct qib_pportdata *ppd, unsigned cnt)\n{\n}\n\n \nstatic u32 qib_6120_setpbc_control(struct qib_pportdata *ppd, u32 plen,\n\t\t\t\t   u8 srate, u8 vl)\n{\n\treturn vl == 15 ? PBC_6120_VL15_SEND_CTRL : 0;\n}\n\nstatic void qib_6120_initvl15_bufs(struct qib_devdata *dd)\n{\n}\n\nstatic void qib_6120_init_ctxt(struct qib_ctxtdata *rcd)\n{\n\trcd->rcvegrcnt = rcd->dd->rcvhdrcnt;\n\trcd->rcvegr_tid_base = rcd->ctxt * rcd->rcvegrcnt;\n}\n\nstatic void qib_6120_txchk_change(struct qib_devdata *dd, u32 start,\n\tu32 len, u32 avail, struct qib_ctxtdata *rcd)\n{\n}\n\nstatic void writescratch(struct qib_devdata *dd, u32 val)\n{\n\t(void) qib_write_kreg(dd, kr_scratch, val);\n}\n\nstatic int qib_6120_tempsense_rd(struct qib_devdata *dd, int regnum)\n{\n\treturn -ENXIO;\n}\n\n#ifdef CONFIG_INFINIBAND_QIB_DCA\nstatic int qib_6120_notify_dca(struct qib_devdata *dd, unsigned long event)\n{\n\treturn 0;\n}\n#endif\n\n \nstatic int qib_6120_eeprom_wen(struct qib_devdata *dd, int wen)\n{\n\treturn 1;\n}\n\n \nstruct qib_devdata *qib_init_iba6120_funcs(struct pci_dev *pdev,\n\t\t\t\t\t   const struct pci_device_id *ent)\n{\n\tstruct qib_devdata *dd;\n\tint ret;\n\n\tdd = qib_alloc_devdata(pdev, sizeof(struct qib_pportdata) +\n\t\t\t       sizeof(struct qib_chip_specific));\n\tif (IS_ERR(dd))\n\t\tgoto bail;\n\n\tdd->f_bringup_serdes    = qib_6120_bringup_serdes;\n\tdd->f_cleanup           = qib_6120_setup_cleanup;\n\tdd->f_clear_tids        = qib_6120_clear_tids;\n\tdd->f_free_irq          = qib_free_irq;\n\tdd->f_get_base_info     = qib_6120_get_base_info;\n\tdd->f_get_msgheader     = qib_6120_get_msgheader;\n\tdd->f_getsendbuf        = qib_6120_getsendbuf;\n\tdd->f_gpio_mod          = gpio_6120_mod;\n\tdd->f_eeprom_wen\t= qib_6120_eeprom_wen;\n\tdd->f_hdrqempty         = qib_6120_hdrqempty;\n\tdd->f_ib_updown         = qib_6120_ib_updown;\n\tdd->f_init_ctxt         = qib_6120_init_ctxt;\n\tdd->f_initvl15_bufs     = qib_6120_initvl15_bufs;\n\tdd->f_intr_fallback     = qib_6120_nointr_fallback;\n\tdd->f_late_initreg      = qib_late_6120_initreg;\n\tdd->f_setpbc_control    = qib_6120_setpbc_control;\n\tdd->f_portcntr          = qib_portcntr_6120;\n\tdd->f_put_tid           = (dd->minrev >= 2) ?\n\t\t\t\t      qib_6120_put_tid_2 :\n\t\t\t\t      qib_6120_put_tid;\n\tdd->f_quiet_serdes      = qib_6120_quiet_serdes;\n\tdd->f_rcvctrl           = rcvctrl_6120_mod;\n\tdd->f_read_cntrs        = qib_read_6120cntrs;\n\tdd->f_read_portcntrs    = qib_read_6120portcntrs;\n\tdd->f_reset             = qib_6120_setup_reset;\n\tdd->f_init_sdma_regs    = init_sdma_6120_regs;\n\tdd->f_sdma_busy         = qib_sdma_6120_busy;\n\tdd->f_sdma_gethead      = qib_sdma_6120_gethead;\n\tdd->f_sdma_sendctrl     = qib_6120_sdma_sendctrl;\n\tdd->f_sdma_set_desc_cnt = qib_sdma_set_6120_desc_cnt;\n\tdd->f_sdma_update_tail  = qib_sdma_update_6120_tail;\n\tdd->f_sendctrl          = sendctrl_6120_mod;\n\tdd->f_set_armlaunch     = qib_set_6120_armlaunch;\n\tdd->f_set_cntr_sample   = qib_set_cntr_6120_sample;\n\tdd->f_iblink_state      = qib_6120_iblink_state;\n\tdd->f_ibphys_portstate  = qib_6120_phys_portstate;\n\tdd->f_get_ib_cfg        = qib_6120_get_ib_cfg;\n\tdd->f_set_ib_cfg        = qib_6120_set_ib_cfg;\n\tdd->f_set_ib_loopback   = qib_6120_set_loopback;\n\tdd->f_set_intr_state    = qib_6120_set_intr_state;\n\tdd->f_setextled         = qib_6120_setup_setextled;\n\tdd->f_txchk_change      = qib_6120_txchk_change;\n\tdd->f_update_usrhead    = qib_update_6120_usrhead;\n\tdd->f_wantpiobuf_intr   = qib_wantpiobuf_6120_intr;\n\tdd->f_xgxs_reset        = qib_6120_xgxs_reset;\n\tdd->f_writescratch      = writescratch;\n\tdd->f_tempsense_rd\t= qib_6120_tempsense_rd;\n#ifdef CONFIG_INFINIBAND_QIB_DCA\n\tdd->f_notify_dca = qib_6120_notify_dca;\n#endif\n\t \n\tret = qib_pcie_ddinit(dd, pdev, ent);\n\tif (ret < 0)\n\t\tgoto bail_free;\n\n\t \n\tret = init_6120_variables(dd);\n\tif (ret)\n\t\tgoto bail_cleanup;\n\n\tif (qib_mini_init)\n\t\tgoto bail;\n\n\tif (qib_pcie_params(dd, 8, NULL))\n\t\tqib_dev_err(dd,\n\t\t\t\"Failed to setup PCIe or interrupts; continuing anyway\\n\");\n\t \n\tqib_write_kreg(dd, kr_hwdiagctrl, 0);\n\n\tif (qib_read_kreg64(dd, kr_hwerrstatus) &\n\t    QLOGIC_IB_HWE_SERDESPLLFAILED)\n\t\tqib_write_kreg(dd, kr_hwerrclear,\n\t\t\t       QLOGIC_IB_HWE_SERDESPLLFAILED);\n\n\t \n\tqib_setup_6120_interrupt(dd);\n\t \n\tqib_6120_init_hwerrors(dd);\n\n\tgoto bail;\n\nbail_cleanup:\n\tqib_pcie_ddcleanup(dd);\nbail_free:\n\tqib_free_devdata(dd);\n\tdd = ERR_PTR(ret);\nbail:\n\treturn dd;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}