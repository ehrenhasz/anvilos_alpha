{
  "module_name": "qib_rc.c",
  "hash_id": "4a7a1bd1901f5012659743322f5b20bc294851f3cbcd3d26172892c596e6b4ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/qib/qib_rc.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n\n#include \"qib.h\"\n\n \n#define OP(x) IB_OPCODE_RC_##x\n\n\nstatic u32 restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe,\n\t\t       u32 psn, u32 pmtu)\n{\n\tu32 len;\n\n\tlen = ((psn - wqe->psn) & QIB_PSN_MASK) * pmtu;\n\treturn rvt_restart_sge(ss, wqe, len);\n}\n\n \nstatic int qib_make_rc_ack(struct qib_ibdev *dev, struct rvt_qp *qp,\n\t\t\t   struct ib_other_headers *ohdr, u32 pmtu)\n{\n\tstruct rvt_ack_entry *e;\n\tu32 hwords;\n\tu32 len;\n\tu32 bth0;\n\tu32 bth2;\n\n\t \n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto bail;\n\n\t \n\thwords = 5;\n\n\tswitch (qp->s_ack_state) {\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\tcase OP(RDMA_READ_RESPONSE_ONLY):\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\tif (e->rdma_sge.mr) {\n\t\t\trvt_put_mr(e->rdma_sge.mr);\n\t\t\te->rdma_sge.mr = NULL;\n\t\t}\n\t\tfallthrough;\n\tcase OP(ATOMIC_ACKNOWLEDGE):\n\t\t \n\t\tif (++qp->s_tail_ack_queue > QIB_MAX_RDMA_ATOMIC)\n\t\t\tqp->s_tail_ack_queue = 0;\n\t\tfallthrough;\n\tcase OP(SEND_ONLY):\n\tcase OP(ACKNOWLEDGE):\n\t\t \n\t\tif (qp->r_head_ack_queue == qp->s_tail_ack_queue) {\n\t\t\tif (qp->s_flags & RVT_S_ACK_PENDING)\n\t\t\t\tgoto normal;\n\t\t\tgoto bail;\n\t\t}\n\n\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\tif (e->opcode == OP(RDMA_READ_REQUEST)) {\n\t\t\t \n\t\t\tlen = e->rdma_sge.sge_length;\n\t\t\tif (len && !e->rdma_sge.mr) {\n\t\t\t\tqp->s_tail_ack_queue = qp->r_head_ack_queue;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\t \n\t\t\tqp->s_rdma_mr = e->rdma_sge.mr;\n\t\t\tif (qp->s_rdma_mr)\n\t\t\t\trvt_get_mr(qp->s_rdma_mr);\n\t\t\tqp->s_ack_rdma_sge.sge = e->rdma_sge;\n\t\t\tqp->s_ack_rdma_sge.num_sge = 1;\n\t\t\tqp->s_cur_sge = &qp->s_ack_rdma_sge;\n\t\t\tif (len > pmtu) {\n\t\t\t\tlen = pmtu;\n\t\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_FIRST);\n\t\t\t} else {\n\t\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_ONLY);\n\t\t\t\te->sent = 1;\n\t\t\t}\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\t\thwords++;\n\t\t\tqp->s_ack_rdma_psn = e->psn;\n\t\t\tbth2 = qp->s_ack_rdma_psn++ & QIB_PSN_MASK;\n\t\t} else {\n\t\t\t \n\t\t\tqp->s_cur_sge = NULL;\n\t\t\tlen = 0;\n\t\t\tqp->s_ack_state = OP(ATOMIC_ACKNOWLEDGE);\n\t\t\tohdr->u.at.aeth = rvt_compute_aeth(qp);\n\t\t\tib_u64_put(e->atomic_data, &ohdr->u.at.atomic_ack_eth);\n\t\t\thwords += sizeof(ohdr->u.at) / sizeof(u32);\n\t\t\tbth2 = e->psn & QIB_PSN_MASK;\n\t\t\te->sent = 1;\n\t\t}\n\t\tbth0 = qp->s_ack_state << 24;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_MIDDLE);\n\t\tfallthrough;\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\tqp->s_cur_sge = &qp->s_ack_rdma_sge;\n\t\tqp->s_rdma_mr = qp->s_ack_rdma_sge.sge.mr;\n\t\tif (qp->s_rdma_mr)\n\t\t\trvt_get_mr(qp->s_rdma_mr);\n\t\tlen = qp->s_ack_rdma_sge.sge.sge_length;\n\t\tif (len > pmtu)\n\t\t\tlen = pmtu;\n\t\telse {\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\t\thwords++;\n\t\t\tqp->s_ack_state = OP(RDMA_READ_RESPONSE_LAST);\n\t\t\te = &qp->s_ack_queue[qp->s_tail_ack_queue];\n\t\t\te->sent = 1;\n\t\t}\n\t\tbth0 = qp->s_ack_state << 24;\n\t\tbth2 = qp->s_ack_rdma_psn++ & QIB_PSN_MASK;\n\t\tbreak;\n\n\tdefault:\nnormal:\n\t\t \n\t\tqp->s_ack_state = OP(SEND_ONLY);\n\t\tqp->s_flags &= ~RVT_S_ACK_PENDING;\n\t\tqp->s_cur_sge = NULL;\n\t\tif (qp->s_nak_state)\n\t\t\tohdr->u.aeth =\n\t\t\t\tcpu_to_be32((qp->r_msn & IB_MSN_MASK) |\n\t\t\t\t\t    (qp->s_nak_state <<\n\t\t\t\t\t     IB_AETH_CREDIT_SHIFT));\n\t\telse\n\t\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\t\thwords++;\n\t\tlen = 0;\n\t\tbth0 = OP(ACKNOWLEDGE) << 24;\n\t\tbth2 = qp->s_ack_psn & QIB_PSN_MASK;\n\t}\n\tqp->s_rdma_ack_cnt++;\n\tqp->s_hdrwords = hwords;\n\tqp->s_cur_size = len;\n\tqib_make_ruc_header(qp, ohdr, bth0, bth2);\n\treturn 1;\n\nbail:\n\tqp->s_ack_state = OP(ACKNOWLEDGE);\n\tqp->s_flags &= ~(RVT_S_RESP_PENDING | RVT_S_ACK_PENDING);\n\treturn 0;\n}\n\n \nint qib_make_rc_req(struct rvt_qp *qp, unsigned long *flags)\n{\n\tstruct qib_qp_priv *priv = qp->priv;\n\tstruct qib_ibdev *dev = to_idev(qp->ibqp.device);\n\tstruct ib_other_headers *ohdr;\n\tstruct rvt_sge_state *ss;\n\tstruct rvt_swqe *wqe;\n\tu32 hwords;\n\tu32 len;\n\tu32 bth0;\n\tu32 bth2;\n\tu32 pmtu = qp->pmtu;\n\tchar newreq;\n\tint ret = 0;\n\tint delta;\n\n\tohdr = &priv->s_hdr->u.oth;\n\tif (rdma_ah_get_ah_flags(&qp->remote_ah_attr) & IB_AH_GRH)\n\t\tohdr = &priv->s_hdr->u.l.oth;\n\n\t \n\tif ((qp->s_flags & RVT_S_RESP_PENDING) &&\n\t    qib_make_rc_ack(dev, qp, ohdr, pmtu))\n\t\tgoto done;\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_SEND_OK)) {\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_FLUSH_SEND))\n\t\t\tgoto bail;\n\t\t \n\t\tif (qp->s_last == READ_ONCE(qp->s_head))\n\t\t\tgoto bail;\n\t\t \n\t\tif (atomic_read(&priv->s_dma_busy)) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_DMA;\n\t\t\tgoto bail;\n\t\t}\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\trvt_send_complete(qp, wqe, qp->s_last != qp->s_acked ?\n\t\t\tIB_WC_SUCCESS : IB_WC_WR_FLUSH_ERR);\n\t\t \n\t\tgoto done;\n\t}\n\n\tif (qp->s_flags & (RVT_S_WAIT_RNR | RVT_S_WAIT_ACK))\n\t\tgoto bail;\n\n\tif (qib_cmp24(qp->s_psn, qp->s_sending_hpsn) <= 0) {\n\t\tif (qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) <= 0) {\n\t\t\tqp->s_flags |= RVT_S_WAIT_PSN;\n\t\t\tgoto bail;\n\t\t}\n\t\tqp->s_sending_psn = qp->s_psn;\n\t\tqp->s_sending_hpsn = qp->s_psn - 1;\n\t}\n\n\t \n\thwords = 5;\n\tbth0 = 0;\n\n\t \n\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\tswitch (qp->s_state) {\n\tdefault:\n\t\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_NEXT_SEND_OK))\n\t\t\tgoto bail;\n\t\t \n\t\tnewreq = 0;\n\t\tif (qp->s_cur == qp->s_tail) {\n\t\t\t \n\t\t\tif (qp->s_tail == READ_ONCE(qp->s_head))\n\t\t\t\tgoto bail;\n\t\t\t \n\t\t\tif ((wqe->wr.send_flags & IB_SEND_FENCE) &&\n\t\t\t    qp->s_num_rd_atomic) {\n\t\t\t\tqp->s_flags |= RVT_S_WAIT_FENCE;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tnewreq = 1;\n\t\t\tqp->s_psn = wqe->psn;\n\t\t}\n\t\t \n\t\tlen = wqe->length;\n\t\tss = &qp->s_sge;\n\t\tbth2 = qp->s_psn & QIB_PSN_MASK;\n\t\tswitch (wqe->wr.opcode) {\n\t\tcase IB_WR_SEND:\n\t\tcase IB_WR_SEND_WITH_IMM:\n\t\t\t \n\t\t\tif (!rvt_rc_credit_avail(qp, wqe))\n\t\t\t\tgoto bail;\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(SEND_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->wr.opcode == IB_WR_SEND)\n\t\t\t\tqp->s_state = OP(SEND_ONLY);\n\t\t\telse {\n\t\t\t\tqp->s_state = OP(SEND_ONLY_WITH_IMMEDIATE);\n\t\t\t\t \n\t\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t}\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tif (newreq && !(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\tqp->s_lsn++;\n\t\t\tgoto no_flow_control;\n\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t \n\t\t\tif (!rvt_rc_credit_avail(qp, wqe))\n\t\t\t\tgoto bail;\nno_flow_control:\n\t\t\tohdr->u.rc.reth.vaddr =\n\t\t\t\tcpu_to_be64(wqe->rdma_wr.remote_addr);\n\t\t\tohdr->u.rc.reth.rkey =\n\t\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\t\tohdr->u.rc.reth.length = cpu_to_be32(len);\n\t\t\thwords += sizeof(struct ib_reth) / sizeof(u32);\n\t\t\tif (len > pmtu) {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_FIRST);\n\t\t\t\tlen = pmtu;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (wqe->rdma_wr.wr.opcode == IB_WR_RDMA_WRITE)\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_ONLY);\n\t\t\telse {\n\t\t\t\tqp->s_state = OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE);\n\t\t\t\t \n\t\t\t\tohdr->u.rc.imm_data =\n\t\t\t\t\twqe->rdma_wr.wr.ex.imm_data;\n\t\t\t\thwords += 1;\n\t\t\t\tif (wqe->rdma_wr.wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t\t}\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_RDMA_READ:\n\t\t\t \n\t\t\tif (newreq) {\n\t\t\t\tif (qp->s_num_rd_atomic >=\n\t\t\t\t    qp->s_max_rd_atomic) {\n\t\t\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tqp->s_num_rd_atomic++;\n\t\t\t\tif (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\t\tqp->s_lsn++;\n\t\t\t}\n\n\t\t\tohdr->u.rc.reth.vaddr =\n\t\t\t\tcpu_to_be64(wqe->rdma_wr.remote_addr);\n\t\t\tohdr->u.rc.reth.rkey =\n\t\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\t\tohdr->u.rc.reth.length = cpu_to_be32(len);\n\t\t\tqp->s_state = OP(RDMA_READ_REQUEST);\n\t\t\thwords += sizeof(ohdr->u.rc.reth) / sizeof(u32);\n\t\t\tss = NULL;\n\t\t\tlen = 0;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\t \n\t\t\tif (newreq) {\n\t\t\t\tif (qp->s_num_rd_atomic >=\n\t\t\t\t    qp->s_max_rd_atomic) {\n\t\t\t\t\tqp->s_flags |= RVT_S_WAIT_RDMAR;\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\tqp->s_num_rd_atomic++;\n\t\t\t\tif (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT))\n\t\t\t\t\tqp->s_lsn++;\n\t\t\t}\n\t\t\tif (wqe->atomic_wr.wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP) {\n\t\t\t\tqp->s_state = OP(COMPARE_SWAP);\n\t\t\t\tput_ib_ateth_swap(wqe->atomic_wr.swap,\n\t\t\t\t\t\t  &ohdr->u.atomic_eth);\n\t\t\t\tput_ib_ateth_compare(wqe->atomic_wr.compare_add,\n\t\t\t\t\t\t     &ohdr->u.atomic_eth);\n\t\t\t} else {\n\t\t\t\tqp->s_state = OP(FETCH_ADD);\n\t\t\t\tput_ib_ateth_swap(wqe->atomic_wr.compare_add,\n\t\t\t\t\t\t  &ohdr->u.atomic_eth);\n\t\t\t\tput_ib_ateth_compare(0, &ohdr->u.atomic_eth);\n\t\t\t}\n\t\t\tput_ib_ateth_vaddr(wqe->atomic_wr.remote_addr,\n\t\t\t\t\t   &ohdr->u.atomic_eth);\n\t\t\tohdr->u.atomic_eth.rkey = cpu_to_be32(\n\t\t\t\twqe->atomic_wr.rkey);\n\t\t\thwords += sizeof(struct ib_atomic_eth) / sizeof(u32);\n\t\t\tss = NULL;\n\t\t\tlen = 0;\n\t\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\t\tif (++qp->s_cur == qp->s_size)\n\t\t\t\tqp->s_cur = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto bail;\n\t\t}\n\t\tqp->s_sge.sge = wqe->sg_list[0];\n\t\tqp->s_sge.sg_list = wqe->sg_list + 1;\n\t\tqp->s_sge.num_sge = wqe->wr.num_sge;\n\t\tqp->s_sge.total_len = wqe->length;\n\t\tqp->s_len = wqe->length;\n\t\tif (newreq) {\n\t\t\tqp->s_tail++;\n\t\t\tif (qp->s_tail >= qp->s_size)\n\t\t\t\tqp->s_tail = 0;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ)\n\t\t\tqp->s_psn = wqe->lpsn + 1;\n\t\telse\n\t\t\tqp->s_psn++;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\t \n\t\tqp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);\n\t\tfallthrough;\n\tcase OP(SEND_FIRST):\n\t\tqp->s_state = OP(SEND_MIDDLE);\n\t\tfallthrough;\n\tcase OP(SEND_MIDDLE):\n\t\tbth2 = qp->s_psn++ & QIB_PSN_MASK;\n\t\tss = &qp->s_sge;\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_SEND)\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\telse {\n\t\t\tqp->s_state = OP(SEND_LAST_WITH_IMMEDIATE);\n\t\t\t \n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t}\n\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\t\t \n\t\tqp->s_len = restart_sge(&qp->s_sge, wqe, qp->s_psn, pmtu);\n\t\tfallthrough;\n\tcase OP(RDMA_WRITE_FIRST):\n\t\tqp->s_state = OP(RDMA_WRITE_MIDDLE);\n\t\tfallthrough;\n\tcase OP(RDMA_WRITE_MIDDLE):\n\t\tbth2 = qp->s_psn++ & QIB_PSN_MASK;\n\t\tss = &qp->s_sge;\n\t\tlen = qp->s_len;\n\t\tif (len > pmtu) {\n\t\t\tlen = pmtu;\n\t\t\tbreak;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE)\n\t\t\tqp->s_state = OP(RDMA_WRITE_LAST);\n\t\telse {\n\t\t\tqp->s_state = OP(RDMA_WRITE_LAST_WITH_IMMEDIATE);\n\t\t\t \n\t\t\tohdr->u.imm_data = wqe->wr.ex.imm_data;\n\t\t\thwords += 1;\n\t\t\tif (wqe->wr.send_flags & IB_SEND_SOLICITED)\n\t\t\t\tbth0 |= IB_BTH_SOLICITED;\n\t\t}\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\t \n\t\tlen = ((qp->s_psn - wqe->psn) & QIB_PSN_MASK) * pmtu;\n\t\tohdr->u.rc.reth.vaddr =\n\t\t\tcpu_to_be64(wqe->rdma_wr.remote_addr + len);\n\t\tohdr->u.rc.reth.rkey =\n\t\t\tcpu_to_be32(wqe->rdma_wr.rkey);\n\t\tohdr->u.rc.reth.length = cpu_to_be32(wqe->length - len);\n\t\tqp->s_state = OP(RDMA_READ_REQUEST);\n\t\thwords += sizeof(ohdr->u.rc.reth) / sizeof(u32);\n\t\tbth2 = (qp->s_psn & QIB_PSN_MASK) | IB_BTH_REQ_ACK;\n\t\tqp->s_psn = wqe->lpsn + 1;\n\t\tss = NULL;\n\t\tlen = 0;\n\t\tqp->s_cur++;\n\t\tif (qp->s_cur == qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tbreak;\n\t}\n\tqp->s_sending_hpsn = bth2;\n\tdelta = (((int) bth2 - (int) wqe->psn) << 8) >> 8;\n\tif (delta && delta % QIB_PSN_CREDIT == 0)\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\tif (qp->s_flags & RVT_S_SEND_ONE) {\n\t\tqp->s_flags &= ~RVT_S_SEND_ONE;\n\t\tqp->s_flags |= RVT_S_WAIT_ACK;\n\t\tbth2 |= IB_BTH_REQ_ACK;\n\t}\n\tqp->s_len -= len;\n\tqp->s_hdrwords = hwords;\n\tqp->s_cur_sge = ss;\n\tqp->s_cur_size = len;\n\tqib_make_ruc_header(qp, ohdr, bth0 | (qp->s_state << 24), bth2);\ndone:\n\treturn 1;\nbail:\n\tqp->s_flags &= ~RVT_S_BUSY;\n\treturn ret;\n}\n\n \nvoid qib_send_rc_ack(struct rvt_qp *qp)\n{\n\tstruct qib_devdata *dd = dd_from_ibdev(qp->ibqp.device);\n\tstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tu64 pbc;\n\tu16 lrh0;\n\tu32 bth0;\n\tu32 hwords;\n\tu32 pbufn;\n\tu32 __iomem *piobuf;\n\tstruct ib_header hdr;\n\tstruct ib_other_headers *ohdr;\n\tu32 control;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto unlock;\n\n\t \n\tif ((qp->s_flags & RVT_S_RESP_PENDING) || qp->s_rdma_ack_cnt)\n\t\tgoto queue_ack;\n\n\t \n\tohdr = &hdr.u.oth;\n\tlrh0 = QIB_LRH_BTH;\n\t \n\thwords = 6;\n\tif (unlikely(rdma_ah_get_ah_flags(&qp->remote_ah_attr) &\n\t\t     IB_AH_GRH)) {\n\t\thwords += qib_make_grh(ibp, &hdr.u.l.grh,\n\t\t\t\t       rdma_ah_read_grh(&qp->remote_ah_attr),\n\t\t\t\t       hwords, 0);\n\t\tohdr = &hdr.u.l.oth;\n\t\tlrh0 = QIB_LRH_GRH;\n\t}\n\t \n\tbth0 = qib_get_pkey(ibp, qp->s_pkey_index) | (OP(ACKNOWLEDGE) << 24);\n\tif (qp->s_mig_state == IB_MIG_MIGRATED)\n\t\tbth0 |= IB_BTH_MIG_REQ;\n\tif (qp->r_nak_state)\n\t\tohdr->u.aeth = cpu_to_be32((qp->r_msn & IB_MSN_MASK) |\n\t\t\t\t\t    (qp->r_nak_state <<\n\t\t\t\t\t     IB_AETH_CREDIT_SHIFT));\n\telse\n\t\tohdr->u.aeth = rvt_compute_aeth(qp);\n\tlrh0 |= ibp->sl_to_vl[rdma_ah_get_sl(&qp->remote_ah_attr)] << 12 |\n\t\trdma_ah_get_sl(&qp->remote_ah_attr) << 4;\n\thdr.lrh[0] = cpu_to_be16(lrh0);\n\thdr.lrh[1] = cpu_to_be16(rdma_ah_get_dlid(&qp->remote_ah_attr));\n\thdr.lrh[2] = cpu_to_be16(hwords + SIZE_OF_CRC);\n\thdr.lrh[3] = cpu_to_be16(ppd->lid |\n\t\t\t\t rdma_ah_get_path_bits(&qp->remote_ah_attr));\n\tohdr->bth[0] = cpu_to_be32(bth0);\n\tohdr->bth[1] = cpu_to_be32(qp->remote_qpn);\n\tohdr->bth[2] = cpu_to_be32(qp->r_ack_psn & QIB_PSN_MASK);\n\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\n\t \n\tif (!(ppd->lflags & QIBL_LINKACTIVE))\n\t\tgoto done;\n\n\tcontrol = dd->f_setpbc_control(ppd, hwords + SIZE_OF_CRC,\n\t\t\t\t       qp->s_srate, lrh0 >> 12);\n\t \n\tpbc = ((u64) control << 32) | (hwords + 1);\n\n\tpiobuf = dd->f_getsendbuf(ppd, pbc, &pbufn);\n\tif (!piobuf) {\n\t\t \n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tgoto queue_ack;\n\t}\n\n\t \n\twriteq(pbc, piobuf);\n\n\tif (dd->flags & QIB_PIO_FLUSH_WC) {\n\t\tu32 *hdrp = (u32 *) &hdr;\n\n\t\tqib_flush_wc();\n\t\tqib_pio_copy(piobuf + 2, hdrp, hwords - 1);\n\t\tqib_flush_wc();\n\t\t__raw_writel(hdrp[hwords - 1], piobuf + hwords + 1);\n\t} else\n\t\tqib_pio_copy(piobuf + 2, (u32 *) &hdr, hwords);\n\n\tif (dd->flags & QIB_USE_SPCL_TRIG) {\n\t\tu32 spcl_off = (pbufn >= dd->piobcnt2k) ? 2047 : 1023;\n\n\t\tqib_flush_wc();\n\t\t__raw_writel(0xaebecede, piobuf + spcl_off);\n\t}\n\n\tqib_flush_wc();\n\tqib_sendbuf_done(dd, pbufn);\n\n\tthis_cpu_inc(ibp->pmastats->n_unicast_xmit);\n\tgoto done;\n\nqueue_ack:\n\tif (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK) {\n\t\tthis_cpu_inc(*ibp->rvp.rc_qacks);\n\t\tqp->s_flags |= RVT_S_ACK_PENDING | RVT_S_RESP_PENDING;\n\t\tqp->s_nak_state = qp->r_nak_state;\n\t\tqp->s_ack_psn = qp->r_ack_psn;\n\n\t\t \n\t\tqib_schedule_send(qp);\n\t}\nunlock:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\ndone:\n\treturn;\n}\n\n \nstatic void reset_psn(struct rvt_qp *qp, u32 psn)\n{\n\tu32 n = qp->s_acked;\n\tstruct rvt_swqe *wqe = rvt_get_swqe_ptr(qp, n);\n\tu32 opcode;\n\n\tqp->s_cur = n;\n\n\t \n\tif (qib_cmp24(psn, wqe->psn) <= 0) {\n\t\tqp->s_state = OP(SEND_LAST);\n\t\tgoto done;\n\t}\n\n\t \n\topcode = wqe->wr.opcode;\n\tfor (;;) {\n\t\tint diff;\n\n\t\tif (++n == qp->s_size)\n\t\t\tn = 0;\n\t\tif (n == qp->s_tail)\n\t\t\tbreak;\n\t\twqe = rvt_get_swqe_ptr(qp, n);\n\t\tdiff = qib_cmp24(psn, wqe->psn);\n\t\tif (diff < 0)\n\t\t\tbreak;\n\t\tqp->s_cur = n;\n\t\t \n\t\tif (diff == 0) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\tgoto done;\n\t\t}\n\t\topcode = wqe->wr.opcode;\n\t}\n\n\t \n\tswitch (opcode) {\n\tcase IB_WR_SEND:\n\tcase IB_WR_SEND_WITH_IMM:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_FIRST);\n\t\tbreak;\n\n\tcase IB_WR_RDMA_WRITE:\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_LAST);\n\t\tbreak;\n\n\tcase IB_WR_RDMA_READ:\n\t\tqp->s_state = OP(RDMA_READ_RESPONSE_MIDDLE);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tqp->s_state = OP(SEND_LAST);\n\t}\ndone:\n\tqp->s_psn = psn;\n\t \n\tif ((qib_cmp24(qp->s_psn, qp->s_sending_hpsn) <= 0) &&\n\t    (qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) <= 0))\n\t\tqp->s_flags |= RVT_S_WAIT_PSN;\n}\n\n \nvoid qib_restart_rc(struct rvt_qp *qp, u32 psn, int wait)\n{\n\tstruct rvt_swqe *wqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tstruct qib_ibport *ibp;\n\n\tif (qp->s_retry == 0) {\n\t\tif (qp->s_mig_state == IB_MIG_ARMED) {\n\t\t\tqib_migrate_qp(qp);\n\t\t\tqp->s_retry = qp->s_retry_cnt;\n\t\t} else if (qp->s_last == qp->s_acked) {\n\t\t\trvt_send_complete(qp, wqe, IB_WC_RETRY_EXC_ERR);\n\t\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t\t\treturn;\n\t\t} else  \n\t\t\treturn;\n\t} else\n\t\tqp->s_retry--;\n\n\tibp = to_iport(qp->ibqp.device, qp->port_num);\n\tif (wqe->wr.opcode == IB_WR_RDMA_READ)\n\t\tibp->rvp.n_rc_resends++;\n\telse\n\t\tibp->rvp.n_rc_resends += (qp->s_psn - psn) & QIB_PSN_MASK;\n\n\tqp->s_flags &= ~(RVT_S_WAIT_FENCE | RVT_S_WAIT_RDMAR |\n\t\t\t RVT_S_WAIT_SSN_CREDIT | RVT_S_WAIT_PSN |\n\t\t\t RVT_S_WAIT_ACK);\n\tif (wait)\n\t\tqp->s_flags |= RVT_S_SEND_ONE;\n\treset_psn(qp, psn);\n}\n\n \nstatic void reset_sending_psn(struct rvt_qp *qp, u32 psn)\n{\n\tstruct rvt_swqe *wqe;\n\tu32 n = qp->s_last;\n\n\t \n\tfor (;;) {\n\t\twqe = rvt_get_swqe_ptr(qp, n);\n\t\tif (qib_cmp24(psn, wqe->lpsn) <= 0) {\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ)\n\t\t\t\tqp->s_sending_psn = wqe->lpsn + 1;\n\t\t\telse\n\t\t\t\tqp->s_sending_psn = psn + 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (++n == qp->s_size)\n\t\t\tn = 0;\n\t\tif (n == qp->s_tail)\n\t\t\tbreak;\n\t}\n}\n\n \nvoid qib_rc_send_complete(struct rvt_qp *qp, struct ib_header *hdr)\n{\n\tstruct ib_other_headers *ohdr;\n\tstruct rvt_swqe *wqe;\n\tu32 opcode;\n\tu32 psn;\n\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_SEND_OR_FLUSH_OR_RECV_OK))\n\t\treturn;\n\n\t \n\tif ((be16_to_cpu(hdr->lrh[0]) & 3) == QIB_LRH_BTH)\n\t\tohdr = &hdr->u.oth;\n\telse\n\t\tohdr = &hdr->u.l.oth;\n\n\topcode = be32_to_cpu(ohdr->bth[0]) >> 24;\n\tif (opcode >= OP(RDMA_READ_RESPONSE_FIRST) &&\n\t    opcode <= OP(ATOMIC_ACKNOWLEDGE)) {\n\t\tWARN_ON(!qp->s_rdma_ack_cnt);\n\t\tqp->s_rdma_ack_cnt--;\n\t\treturn;\n\t}\n\n\tpsn = be32_to_cpu(ohdr->bth[2]);\n\treset_sending_psn(qp, psn);\n\n\t \n\tif ((psn & IB_BTH_REQ_ACK) && qp->s_acked != qp->s_tail &&\n\t    !(qp->s_flags & (RVT_S_TIMER | RVT_S_WAIT_RNR | RVT_S_WAIT_PSN)) &&\n\t    (ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\trvt_add_retry_timer(qp);\n\n\twhile (qp->s_last != qp->s_acked) {\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_last);\n\t\tif (qib_cmp24(wqe->lpsn, qp->s_sending_psn) >= 0 &&\n\t\t    qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) <= 0)\n\t\t\tbreak;\n\t\trvt_qp_complete_swqe(qp,\n\t\t\t\t     wqe,\n\t\t\t\t     ib_qib_wc_opcode[wqe->wr.opcode],\n\t\t\t\t     IB_WC_SUCCESS);\n\t}\n\t \n\tif (qp->s_flags & RVT_S_WAIT_PSN &&\n\t    qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) > 0) {\n\t\tqp->s_flags &= ~RVT_S_WAIT_PSN;\n\t\tqp->s_sending_psn = qp->s_psn;\n\t\tqp->s_sending_hpsn = qp->s_psn - 1;\n\t\tqib_schedule_send(qp);\n\t}\n}\n\nstatic inline void update_last_psn(struct rvt_qp *qp, u32 psn)\n{\n\tqp->s_last_psn = psn;\n}\n\n \nstatic struct rvt_swqe *do_rc_completion(struct rvt_qp *qp,\n\t\t\t\t\t struct rvt_swqe *wqe,\n\t\t\t\t\t struct qib_ibport *ibp)\n{\n\t \n\tif (qib_cmp24(wqe->lpsn, qp->s_sending_psn) < 0 ||\n\t    qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) > 0)\n\t\trvt_qp_complete_swqe(qp,\n\t\t\t\t     wqe,\n\t\t\t\t     ib_qib_wc_opcode[wqe->wr.opcode],\n\t\t\t\t     IB_WC_SUCCESS);\n\telse\n\t\tthis_cpu_inc(*ibp->rvp.rc_delayed_comp);\n\n\tqp->s_retry = qp->s_retry_cnt;\n\tupdate_last_psn(qp, wqe->lpsn);\n\n\t \n\tif (qp->s_acked == qp->s_cur) {\n\t\tif (++qp->s_cur >= qp->s_size)\n\t\t\tqp->s_cur = 0;\n\t\tqp->s_acked = qp->s_cur;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_cur);\n\t\tif (qp->s_acked != qp->s_tail) {\n\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\tqp->s_psn = wqe->psn;\n\t\t}\n\t} else {\n\t\tif (++qp->s_acked >= qp->s_size)\n\t\t\tqp->s_acked = 0;\n\t\tif (qp->state == IB_QPS_SQD && qp->s_acked == qp->s_cur)\n\t\t\tqp->s_draining = 0;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t}\n\treturn wqe;\n}\n\n \nstatic int do_rc_ack(struct rvt_qp *qp, u32 aeth, u32 psn, int opcode,\n\t\t     u64 val, struct qib_ctxtdata *rcd)\n{\n\tstruct qib_ibport *ibp;\n\tenum ib_wc_status status;\n\tstruct rvt_swqe *wqe;\n\tint ret = 0;\n\tu32 ack_psn;\n\tint diff;\n\n\t \n\tack_psn = psn;\n\tif (aeth >> IB_AETH_NAK_SHIFT)\n\t\tack_psn--;\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tibp = to_iport(qp->ibqp.device, qp->port_num);\n\n\t \n\twhile ((diff = qib_cmp24(ack_psn, wqe->lpsn)) >= 0) {\n\t\t \n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ &&\n\t\t    opcode == OP(RDMA_READ_RESPONSE_ONLY) &&\n\t\t    diff == 0) {\n\t\t\tret = 1;\n\t\t\tgoto bail;\n\t\t}\n\t\t \n\t\tif ((wqe->wr.opcode == IB_WR_RDMA_READ &&\n\t\t     (opcode != OP(RDMA_READ_RESPONSE_LAST) || diff != 0)) ||\n\t\t    ((wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t      wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD) &&\n\t\t     (opcode != OP(ATOMIC_ACKNOWLEDGE) || diff != 0))) {\n\t\t\t \n\t\t\tif (!(qp->r_flags & RVT_R_RDMAR_SEQ)) {\n\t\t\t\tqp->r_flags |= RVT_R_RDMAR_SEQ;\n\t\t\t\tqib_restart_rc(qp, qp->s_last_psn + 1, 0);\n\t\t\t\tif (list_empty(&qp->rspwait)) {\n\t\t\t\t\tqp->r_flags |= RVT_R_RSP_SEND;\n\t\t\t\t\trvt_get_qp(qp);\n\t\t\t\t\tlist_add_tail(&qp->rspwait,\n\t\t\t\t\t\t      &rcd->qp_wait_list);\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tgoto bail;\n\t\t}\n\t\tif (wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD) {\n\t\t\tu64 *vaddr = wqe->sg_list[0].vaddr;\n\t\t\t*vaddr = val;\n\t\t}\n\t\tif (qp->s_num_rd_atomic &&\n\t\t    (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t     wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t     wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD)) {\n\t\t\tqp->s_num_rd_atomic--;\n\t\t\t \n\t\t\tif ((qp->s_flags & RVT_S_WAIT_FENCE) &&\n\t\t\t    !qp->s_num_rd_atomic) {\n\t\t\t\tqp->s_flags &= ~(RVT_S_WAIT_FENCE |\n\t\t\t\t\t\t RVT_S_WAIT_ACK);\n\t\t\t\tqib_schedule_send(qp);\n\t\t\t} else if (qp->s_flags & RVT_S_WAIT_RDMAR) {\n\t\t\t\tqp->s_flags &= ~(RVT_S_WAIT_RDMAR |\n\t\t\t\t\t\t RVT_S_WAIT_ACK);\n\t\t\t\tqib_schedule_send(qp);\n\t\t\t}\n\t\t}\n\t\twqe = do_rc_completion(qp, wqe, ibp);\n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tbreak;\n\t}\n\n\tswitch (aeth >> IB_AETH_NAK_SHIFT) {\n\tcase 0:          \n\t\tthis_cpu_inc(*ibp->rvp.rc_acks);\n\t\tif (qp->s_acked != qp->s_tail) {\n\t\t\t \n\t\t\trvt_mod_retry_timer(qp);\n\t\t\t \n\t\t\tif (qib_cmp24(qp->s_psn, psn) <= 0)\n\t\t\t\treset_psn(qp, psn + 1);\n\t\t} else {\n\t\t\t \n\t\t\trvt_stop_rc_timers(qp);\n\t\t\tif (qib_cmp24(qp->s_psn, psn) <= 0) {\n\t\t\t\tqp->s_state = OP(SEND_LAST);\n\t\t\t\tqp->s_psn = psn + 1;\n\t\t\t}\n\t\t}\n\t\tif (qp->s_flags & RVT_S_WAIT_ACK) {\n\t\t\tqp->s_flags &= ~RVT_S_WAIT_ACK;\n\t\t\tqib_schedule_send(qp);\n\t\t}\n\t\trvt_get_credit(qp, aeth);\n\t\tqp->s_rnr_retry = qp->s_rnr_retry_cnt;\n\t\tqp->s_retry = qp->s_retry_cnt;\n\t\tupdate_last_psn(qp, psn);\n\t\treturn 1;\n\n\tcase 1:          \n\t\tibp->rvp.n_rnr_naks++;\n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tgoto bail;\n\t\tif (qp->s_flags & RVT_S_WAIT_RNR)\n\t\t\tgoto bail;\n\t\tif (qp->s_rnr_retry == 0) {\n\t\t\tstatus = IB_WC_RNR_RETRY_EXC_ERR;\n\t\t\tgoto class_b;\n\t\t}\n\t\tif (qp->s_rnr_retry_cnt < 7)\n\t\t\tqp->s_rnr_retry--;\n\n\t\t \n\t\tupdate_last_psn(qp, psn - 1);\n\n\t\tibp->rvp.n_rc_resends += (qp->s_psn - psn) & QIB_PSN_MASK;\n\n\t\treset_psn(qp, psn);\n\n\t\tqp->s_flags &= ~(RVT_S_WAIT_SSN_CREDIT | RVT_S_WAIT_ACK);\n\t\trvt_stop_rc_timers(qp);\n\t\trvt_add_rnr_timer(qp, aeth);\n\t\treturn 0;\n\n\tcase 3:          \n\t\tif (qp->s_acked == qp->s_tail)\n\t\t\tgoto bail;\n\t\t \n\t\tupdate_last_psn(qp, psn - 1);\n\t\tswitch ((aeth >> IB_AETH_CREDIT_SHIFT) &\n\t\t\tIB_AETH_CREDIT_MASK) {\n\t\tcase 0:  \n\t\t\tibp->rvp.n_seq_naks++;\n\t\t\t \n\t\t\tqib_restart_rc(qp, psn, 0);\n\t\t\tqib_schedule_send(qp);\n\t\t\tbreak;\n\n\t\tcase 1:  \n\t\t\tstatus = IB_WC_REM_INV_REQ_ERR;\n\t\t\tibp->rvp.n_other_naks++;\n\t\t\tgoto class_b;\n\n\t\tcase 2:  \n\t\t\tstatus = IB_WC_REM_ACCESS_ERR;\n\t\t\tibp->rvp.n_other_naks++;\n\t\t\tgoto class_b;\n\n\t\tcase 3:  \n\t\t\tstatus = IB_WC_REM_OP_ERR;\n\t\t\tibp->rvp.n_other_naks++;\nclass_b:\n\t\t\tif (qp->s_last == qp->s_acked) {\n\t\t\t\trvt_send_complete(qp, wqe, status);\n\t\t\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t \n\t\t\tgoto reserved;\n\t\t}\n\t\tqp->s_retry = qp->s_retry_cnt;\n\t\tqp->s_rnr_retry = qp->s_rnr_retry_cnt;\n\t\tgoto bail;\n\n\tdefault:                 \nreserved:\n\t\t \n\t\tgoto bail;\n\t}\n\nbail:\n\trvt_stop_rc_timers(qp);\n\treturn ret;\n}\n\n \nstatic void rdma_seq_err(struct rvt_qp *qp, struct qib_ibport *ibp, u32 psn,\n\t\t\t struct qib_ctxtdata *rcd)\n{\n\tstruct rvt_swqe *wqe;\n\n\t \n\trvt_stop_rc_timers(qp);\n\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\n\twhile (qib_cmp24(psn, wqe->lpsn) > 0) {\n\t\tif (wqe->wr.opcode == IB_WR_RDMA_READ ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP ||\n\t\t    wqe->wr.opcode == IB_WR_ATOMIC_FETCH_AND_ADD)\n\t\t\tbreak;\n\t\twqe = do_rc_completion(qp, wqe, ibp);\n\t}\n\n\tibp->rvp.n_rdma_seq++;\n\tqp->r_flags |= RVT_R_RDMAR_SEQ;\n\tqib_restart_rc(qp, qp->s_last_psn + 1, 0);\n\tif (list_empty(&qp->rspwait)) {\n\t\tqp->r_flags |= RVT_R_RSP_SEND;\n\t\trvt_get_qp(qp);\n\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t}\n}\n\n \nstatic void qib_rc_rcv_resp(struct qib_ibport *ibp,\n\t\t\t    struct ib_other_headers *ohdr,\n\t\t\t    void *data, u32 tlen,\n\t\t\t    struct rvt_qp *qp,\n\t\t\t    u32 opcode,\n\t\t\t    u32 psn, u32 hdrsize, u32 pmtu,\n\t\t\t    struct qib_ctxtdata *rcd)\n{\n\tstruct rvt_swqe *wqe;\n\tstruct qib_pportdata *ppd = ppd_from_ibp(ibp);\n\tenum ib_wc_status status;\n\tunsigned long flags;\n\tint diff;\n\tu32 pad;\n\tu32 aeth;\n\tu64 val;\n\n\tif (opcode != OP(RDMA_READ_RESPONSE_MIDDLE)) {\n\t\t \n\t\tif ((qib_cmp24(psn, qp->s_sending_psn) >= 0) &&\n\t\t    (qib_cmp24(qp->s_sending_psn, qp->s_sending_hpsn) <= 0)) {\n\n\t\t\t \n\t\t\tif (!(qp->s_flags & RVT_S_BUSY)) {\n\t\t\t\t \n\t\t\t\tspin_lock_irqsave(&ppd->sdma_lock, flags);\n\t\t\t\t \n\t\t\t\tqib_sdma_make_progress(ppd);\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&ppd->sdma_lock, flags);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\tif (!(ib_rvt_state_ops[qp->state] & RVT_PROCESS_RECV_OK))\n\t\tgoto ack_done;\n\n\t \n\tif (qib_cmp24(psn, READ_ONCE(qp->s_next_psn)) >= 0)\n\t\tgoto ack_done;\n\n\t \n\tdiff = qib_cmp24(psn, qp->s_last_psn);\n\tif (unlikely(diff <= 0)) {\n\t\t \n\t\tif (diff == 0 && opcode == OP(ACKNOWLEDGE)) {\n\t\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\t\tif ((aeth >> IB_AETH_NAK_SHIFT) == 0)\n\t\t\t\trvt_get_credit(qp, aeth);\n\t\t}\n\t\tgoto ack_done;\n\t}\n\n\t \n\tif (qp->r_flags & RVT_R_RDMAR_SEQ) {\n\t\tif (qib_cmp24(psn, qp->s_last_psn + 1) != 0)\n\t\t\tgoto ack_done;\n\t\tqp->r_flags &= ~RVT_R_RDMAR_SEQ;\n\t}\n\n\tif (unlikely(qp->s_acked == qp->s_tail))\n\t\tgoto ack_done;\n\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\tstatus = IB_WC_SUCCESS;\n\n\tswitch (opcode) {\n\tcase OP(ACKNOWLEDGE):\n\tcase OP(ATOMIC_ACKNOWLEDGE):\n\tcase OP(RDMA_READ_RESPONSE_FIRST):\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\tif (opcode == OP(ATOMIC_ACKNOWLEDGE))\n\t\t\tval = ib_u64_get(&ohdr->u.at.atomic_ack_eth);\n\t\telse\n\t\t\tval = 0;\n\t\tif (!do_rc_ack(qp, aeth, psn, opcode, val, rcd) ||\n\t\t    opcode != OP(RDMA_READ_RESPONSE_FIRST))\n\t\t\tgoto ack_done;\n\t\thdrsize += 4;\n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\n\t\t \n\t\tqp->s_rdma_read_len = restart_sge(&qp->s_rdma_read_sge,\n\t\t\t\t\t\t  wqe, psn, pmtu);\n\t\tgoto read_middle;\n\n\tcase OP(RDMA_READ_RESPONSE_MIDDLE):\n\t\t \n\t\tif (unlikely(qib_cmp24(psn, qp->s_last_psn + 1)))\n\t\t\tgoto ack_seq_err;\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\nread_middle:\n\t\tif (unlikely(tlen != (hdrsize + pmtu + 4)))\n\t\t\tgoto ack_len_err;\n\t\tif (unlikely(pmtu >= qp->s_rdma_read_len))\n\t\t\tgoto ack_len_err;\n\n\t\t \n\t\trvt_mod_retry_timer(qp);\n\t\tif (qp->s_flags & RVT_S_WAIT_ACK) {\n\t\t\tqp->s_flags &= ~RVT_S_WAIT_ACK;\n\t\t\tqib_schedule_send(qp);\n\t\t}\n\n\t\tif (opcode == OP(RDMA_READ_RESPONSE_MIDDLE))\n\t\t\tqp->s_retry = qp->s_retry_cnt;\n\n\t\t \n\t\tqp->s_rdma_read_len -= pmtu;\n\t\tupdate_last_psn(qp, psn);\n\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\trvt_copy_sge(qp, &qp->s_rdma_read_sge,\n\t\t\t     data, pmtu, false, false);\n\t\tgoto bail;\n\n\tcase OP(RDMA_READ_RESPONSE_ONLY):\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\tif (!do_rc_ack(qp, aeth, psn, opcode, 0, rcd))\n\t\t\tgoto ack_done;\n\t\t \n\t\tpad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\n\t\t \n\t\tif (unlikely(tlen < (hdrsize + pad + 8)))\n\t\t\tgoto ack_len_err;\n\t\t \n\t\twqe = rvt_get_swqe_ptr(qp, qp->s_acked);\n\t\tqp->s_rdma_read_len = restart_sge(&qp->s_rdma_read_sge,\n\t\t\t\t\t\t  wqe, psn, pmtu);\n\t\tgoto read_last;\n\n\tcase OP(RDMA_READ_RESPONSE_LAST):\n\t\t \n\t\tif (unlikely(qib_cmp24(psn, qp->s_last_psn + 1)))\n\t\t\tgoto ack_seq_err;\n\t\tif (unlikely(wqe->wr.opcode != IB_WR_RDMA_READ))\n\t\t\tgoto ack_op_err;\n\t\t \n\t\tpad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\n\t\t \n\t\tif (unlikely(tlen <= (hdrsize + pad + 8)))\n\t\t\tgoto ack_len_err;\nread_last:\n\t\ttlen -= hdrsize + pad + 8;\n\t\tif (unlikely(tlen != qp->s_rdma_read_len))\n\t\t\tgoto ack_len_err;\n\t\taeth = be32_to_cpu(ohdr->u.aeth);\n\t\trvt_copy_sge(qp, &qp->s_rdma_read_sge,\n\t\t\t     data, tlen, false, false);\n\t\tWARN_ON(qp->s_rdma_read_sge.num_sge);\n\t\t(void) do_rc_ack(qp, aeth, psn,\n\t\t\t\t OP(RDMA_READ_RESPONSE_LAST), 0, rcd);\n\t\tgoto ack_done;\n\t}\n\nack_op_err:\n\tstatus = IB_WC_LOC_QP_OP_ERR;\n\tgoto ack_err;\n\nack_seq_err:\n\trdma_seq_err(qp, ibp, psn, rcd);\n\tgoto ack_done;\n\nack_len_err:\n\tstatus = IB_WC_LOC_LEN_ERR;\nack_err:\n\tif (qp->s_last == qp->s_acked) {\n\t\trvt_send_complete(qp, wqe, status);\n\t\trvt_error_qp(qp, IB_WC_WR_FLUSH_ERR);\n\t}\nack_done:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nbail:\n\treturn;\n}\n\n \nstatic int qib_rc_rcv_error(struct ib_other_headers *ohdr,\n\t\t\t    void *data,\n\t\t\t    struct rvt_qp *qp,\n\t\t\t    u32 opcode,\n\t\t\t    u32 psn,\n\t\t\t    int diff,\n\t\t\t    struct qib_ctxtdata *rcd)\n{\n\tstruct qib_ibport *ibp = to_iport(qp->ibqp.device, qp->port_num);\n\tstruct rvt_ack_entry *e;\n\tunsigned long flags;\n\tu8 i, prev;\n\tint old_req;\n\n\tif (diff > 0) {\n\t\t \n\t\tif (!qp->r_nak_state) {\n\t\t\tibp->rvp.n_rc_seqnak++;\n\t\t\tqp->r_nak_state = IB_NAK_PSN_ERROR;\n\t\t\t \n\t\t\tqp->r_ack_psn = qp->r_psn;\n\t\t\t \n\t\t\tif (list_empty(&qp->rspwait)) {\n\t\t\t\tqp->r_flags |= RVT_R_RSP_NAK;\n\t\t\t\trvt_get_qp(qp);\n\t\t\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t\t\t}\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\te = NULL;\n\told_req = 1;\n\tibp->rvp.n_rc_dupreq++;\n\n\tspin_lock_irqsave(&qp->s_lock, flags);\n\n\tfor (i = qp->r_head_ack_queue; ; i = prev) {\n\t\tif (i == qp->s_tail_ack_queue)\n\t\t\told_req = 0;\n\t\tif (i)\n\t\t\tprev = i - 1;\n\t\telse\n\t\t\tprev = QIB_MAX_RDMA_ATOMIC;\n\t\tif (prev == qp->r_head_ack_queue) {\n\t\t\te = NULL;\n\t\t\tbreak;\n\t\t}\n\t\te = &qp->s_ack_queue[prev];\n\t\tif (!e->opcode) {\n\t\t\te = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tif (qib_cmp24(psn, e->psn) >= 0) {\n\t\t\tif (prev == qp->s_tail_ack_queue &&\n\t\t\t    qib_cmp24(psn, e->lpsn) <= 0)\n\t\t\t\told_req = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tswitch (opcode) {\n\tcase OP(RDMA_READ_REQUEST): {\n\t\tstruct ib_reth *reth;\n\t\tu32 offset;\n\t\tu32 len;\n\n\t\t \n\t\tif (!e || e->opcode != OP(RDMA_READ_REQUEST))\n\t\t\tgoto unlock_done;\n\t\t \n\t\treth = &ohdr->u.rc.reth;\n\t\t \n\t\toffset = ((psn - e->psn) & QIB_PSN_MASK) *\n\t\t\tqp->pmtu;\n\t\tlen = be32_to_cpu(reth->length);\n\t\tif (unlikely(offset + len != e->rdma_sge.sge_length))\n\t\t\tgoto unlock_done;\n\t\tif (e->rdma_sge.mr) {\n\t\t\trvt_put_mr(e->rdma_sge.mr);\n\t\t\te->rdma_sge.mr = NULL;\n\t\t}\n\t\tif (len != 0) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = be64_to_cpu(reth->vaddr);\n\t\t\tint ok;\n\n\t\t\tok = rvt_rkey_ok(qp, &e->rdma_sge, len, vaddr, rkey,\n\t\t\t\t\t IB_ACCESS_REMOTE_READ);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto unlock_done;\n\t\t} else {\n\t\t\te->rdma_sge.vaddr = NULL;\n\t\t\te->rdma_sge.length = 0;\n\t\t\te->rdma_sge.sge_length = 0;\n\t\t}\n\t\te->psn = psn;\n\t\tif (old_req)\n\t\t\tgoto unlock_done;\n\t\tqp->s_tail_ack_queue = prev;\n\t\tbreak;\n\t}\n\n\tcase OP(COMPARE_SWAP):\n\tcase OP(FETCH_ADD): {\n\t\t \n\t\tif (!e || e->opcode != (u8) opcode || old_req)\n\t\t\tgoto unlock_done;\n\t\tqp->s_tail_ack_queue = prev;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\t \n\t\tif (!(psn & IB_BTH_REQ_ACK) || old_req)\n\t\t\tgoto unlock_done;\n\t\t \n\t\tif (i == qp->r_head_ack_queue) {\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t\tqp->r_nak_state = 0;\n\t\t\tqp->r_ack_psn = qp->r_psn - 1;\n\t\t\tgoto send_ack;\n\t\t}\n\t\t \n\t\tif (!(qp->s_flags & RVT_S_RESP_PENDING)) {\n\t\t\tspin_unlock_irqrestore(&qp->s_lock, flags);\n\t\t\tqp->r_nak_state = 0;\n\t\t\tqp->r_ack_psn = qp->s_ack_queue[i].psn - 1;\n\t\t\tgoto send_ack;\n\t\t}\n\t\t \n\t\tqp->s_tail_ack_queue = i;\n\t\tbreak;\n\t}\n\tqp->s_ack_state = OP(ACKNOWLEDGE);\n\tqp->s_flags |= RVT_S_RESP_PENDING;\n\tqp->r_nak_state = 0;\n\tqib_schedule_send(qp);\n\nunlock_done:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\ndone:\n\treturn 1;\n\nsend_ack:\n\treturn 0;\n}\n\nstatic inline void qib_update_ack_queue(struct rvt_qp *qp, unsigned n)\n{\n\tunsigned next;\n\n\tnext = n + 1;\n\tif (next > QIB_MAX_RDMA_ATOMIC)\n\t\tnext = 0;\n\tqp->s_tail_ack_queue = next;\n\tqp->s_ack_state = OP(ACKNOWLEDGE);\n}\n\n \nvoid qib_rc_rcv(struct qib_ctxtdata *rcd, struct ib_header *hdr,\n\t\tint has_grh, void *data, u32 tlen, struct rvt_qp *qp)\n{\n\tstruct qib_ibport *ibp = &rcd->ppd->ibport_data;\n\tstruct ib_other_headers *ohdr;\n\tu32 opcode;\n\tu32 hdrsize;\n\tu32 psn;\n\tu32 pad;\n\tstruct ib_wc wc;\n\tu32 pmtu = qp->pmtu;\n\tint diff;\n\tstruct ib_reth *reth;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (!has_grh) {\n\t\tohdr = &hdr->u.oth;\n\t\thdrsize = 8 + 12;        \n\t} else {\n\t\tohdr = &hdr->u.l.oth;\n\t\thdrsize = 8 + 40 + 12;   \n\t}\n\n\topcode = be32_to_cpu(ohdr->bth[0]);\n\tif (qib_ruc_check_hdr(ibp, hdr, has_grh, qp, opcode))\n\t\treturn;\n\n\tpsn = be32_to_cpu(ohdr->bth[2]);\n\topcode >>= 24;\n\n\t \n\tif (opcode >= OP(RDMA_READ_RESPONSE_FIRST) &&\n\t    opcode <= OP(ATOMIC_ACKNOWLEDGE)) {\n\t\tqib_rc_rcv_resp(ibp, ohdr, data, tlen, qp, opcode, psn,\n\t\t\t\thdrsize, pmtu, rcd);\n\t\treturn;\n\t}\n\n\t \n\tdiff = qib_cmp24(psn, qp->r_psn);\n\tif (unlikely(diff)) {\n\t\tif (qib_rc_rcv_error(ohdr, data, qp, opcode, psn, diff, rcd))\n\t\t\treturn;\n\t\tgoto send_ack;\n\t}\n\n\t \n\tswitch (qp->r_state) {\n\tcase OP(SEND_FIRST):\n\tcase OP(SEND_MIDDLE):\n\t\tif (opcode == OP(SEND_MIDDLE) ||\n\t\t    opcode == OP(SEND_LAST) ||\n\t\t    opcode == OP(SEND_LAST_WITH_IMMEDIATE))\n\t\t\tbreak;\n\t\tgoto nack_inv;\n\n\tcase OP(RDMA_WRITE_FIRST):\n\tcase OP(RDMA_WRITE_MIDDLE):\n\t\tif (opcode == OP(RDMA_WRITE_MIDDLE) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\n\t\t\tbreak;\n\t\tgoto nack_inv;\n\n\tdefault:\n\t\tif (opcode == OP(SEND_MIDDLE) ||\n\t\t    opcode == OP(SEND_LAST) ||\n\t\t    opcode == OP(SEND_LAST_WITH_IMMEDIATE) ||\n\t\t    opcode == OP(RDMA_WRITE_MIDDLE) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST) ||\n\t\t    opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE))\n\t\t\tgoto nack_inv;\n\t\t \n\t\tbreak;\n\t}\n\n\tif (qp->state == IB_QPS_RTR && !(qp->r_flags & RVT_R_COMM_EST))\n\t\trvt_comm_est(qp);\n\n\t \n\tswitch (opcode) {\n\tcase OP(SEND_FIRST):\n\t\tret = rvt_get_rwqe(qp, false);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tqp->r_rcv_len = 0;\n\t\tfallthrough;\n\tcase OP(SEND_MIDDLE):\n\tcase OP(RDMA_WRITE_MIDDLE):\nsend_middle:\n\t\t \n\t\tif (unlikely(tlen != (hdrsize + pmtu + 4)))\n\t\t\tgoto nack_inv;\n\t\tqp->r_rcv_len += pmtu;\n\t\tif (unlikely(qp->r_rcv_len > qp->r_len))\n\t\t\tgoto nack_inv;\n\t\trvt_copy_sge(qp, &qp->r_sge, data, pmtu, true, false);\n\t\tbreak;\n\n\tcase OP(RDMA_WRITE_LAST_WITH_IMMEDIATE):\n\t\t \n\t\tret = rvt_get_rwqe(qp, true);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tgoto send_last_imm;\n\n\tcase OP(SEND_ONLY):\n\tcase OP(SEND_ONLY_WITH_IMMEDIATE):\n\t\tret = rvt_get_rwqe(qp, false);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret)\n\t\t\tgoto rnr_nak;\n\t\tqp->r_rcv_len = 0;\n\t\tif (opcode == OP(SEND_ONLY))\n\t\t\tgoto no_immediate_data;\n\t\tfallthrough;\t \n\tcase OP(SEND_LAST_WITH_IMMEDIATE):\nsend_last_imm:\n\t\twc.ex.imm_data = ohdr->u.imm_data;\n\t\thdrsize += 4;\n\t\twc.wc_flags = IB_WC_WITH_IMM;\n\t\tgoto send_last;\n\tcase OP(SEND_LAST):\n\tcase OP(RDMA_WRITE_LAST):\nno_immediate_data:\n\t\twc.wc_flags = 0;\n\t\twc.ex.imm_data = 0;\nsend_last:\n\t\t \n\t\tpad = (be32_to_cpu(ohdr->bth[0]) >> 20) & 3;\n\t\t \n\t\t \n\t\tif (unlikely(tlen < (hdrsize + pad + 4)))\n\t\t\tgoto nack_inv;\n\t\t \n\t\ttlen -= (hdrsize + pad + 4);\n\t\twc.byte_len = tlen + qp->r_rcv_len;\n\t\tif (unlikely(wc.byte_len > qp->r_len))\n\t\t\tgoto nack_inv;\n\t\trvt_copy_sge(qp, &qp->r_sge, data, tlen, true, false);\n\t\trvt_put_ss(&qp->r_sge);\n\t\tqp->r_msn++;\n\t\tif (!test_and_clear_bit(RVT_R_WRID_VALID, &qp->r_aflags))\n\t\t\tbreak;\n\t\twc.wr_id = qp->r_wr_id;\n\t\twc.status = IB_WC_SUCCESS;\n\t\tif (opcode == OP(RDMA_WRITE_LAST_WITH_IMMEDIATE) ||\n\t\t    opcode == OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE))\n\t\t\twc.opcode = IB_WC_RECV_RDMA_WITH_IMM;\n\t\telse\n\t\t\twc.opcode = IB_WC_RECV;\n\t\twc.qp = &qp->ibqp;\n\t\twc.src_qp = qp->remote_qpn;\n\t\twc.slid = rdma_ah_get_dlid(&qp->remote_ah_attr);\n\t\twc.sl = rdma_ah_get_sl(&qp->remote_ah_attr);\n\t\t \n\t\twc.vendor_err = 0;\n\t\twc.pkey_index = 0;\n\t\twc.dlid_path_bits = 0;\n\t\twc.port_num = 0;\n\t\t \n\t\trvt_recv_cq(qp, &wc, ib_bth_is_solicited(ohdr));\n\t\tbreak;\n\n\tcase OP(RDMA_WRITE_FIRST):\n\tcase OP(RDMA_WRITE_ONLY):\n\tcase OP(RDMA_WRITE_ONLY_WITH_IMMEDIATE):\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_WRITE)))\n\t\t\tgoto nack_inv;\n\t\t \n\t\treth = &ohdr->u.rc.reth;\n\t\thdrsize += sizeof(*reth);\n\t\tqp->r_len = be32_to_cpu(reth->length);\n\t\tqp->r_rcv_len = 0;\n\t\tqp->r_sge.sg_list = NULL;\n\t\tif (qp->r_len != 0) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = be64_to_cpu(reth->vaddr);\n\t\t\tint ok;\n\n\t\t\t \n\t\t\tok = rvt_rkey_ok(qp, &qp->r_sge.sge, qp->r_len, vaddr,\n\t\t\t\t\t rkey, IB_ACCESS_REMOTE_WRITE);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto nack_acc;\n\t\t\tqp->r_sge.num_sge = 1;\n\t\t} else {\n\t\t\tqp->r_sge.num_sge = 0;\n\t\t\tqp->r_sge.sge.mr = NULL;\n\t\t\tqp->r_sge.sge.vaddr = NULL;\n\t\t\tqp->r_sge.sge.length = 0;\n\t\t\tqp->r_sge.sge.sge_length = 0;\n\t\t}\n\t\tif (opcode == OP(RDMA_WRITE_FIRST))\n\t\t\tgoto send_middle;\n\t\telse if (opcode == OP(RDMA_WRITE_ONLY))\n\t\t\tgoto no_immediate_data;\n\t\tret = rvt_get_rwqe(qp, true);\n\t\tif (ret < 0)\n\t\t\tgoto nack_op_err;\n\t\tif (!ret) {\n\t\t\trvt_put_ss(&qp->r_sge);\n\t\t\tgoto rnr_nak;\n\t\t}\n\t\twc.ex.imm_data = ohdr->u.rc.imm_data;\n\t\thdrsize += 4;\n\t\twc.wc_flags = IB_WC_WITH_IMM;\n\t\tgoto send_last;\n\n\tcase OP(RDMA_READ_REQUEST): {\n\t\tstruct rvt_ack_entry *e;\n\t\tu32 len;\n\t\tu8 next;\n\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_READ)))\n\t\t\tgoto nack_inv;\n\t\tnext = qp->r_head_ack_queue + 1;\n\t\t \n\t\tif (next > QIB_MAX_RDMA_ATOMIC)\n\t\t\tnext = 0;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tif (unlikely(next == qp->s_tail_ack_queue)) {\n\t\t\tif (!qp->s_ack_queue[next].sent)\n\t\t\t\tgoto nack_inv_unlck;\n\t\t\tqib_update_ack_queue(qp, next);\n\t\t}\n\t\te = &qp->s_ack_queue[qp->r_head_ack_queue];\n\t\tif (e->opcode == OP(RDMA_READ_REQUEST) && e->rdma_sge.mr) {\n\t\t\trvt_put_mr(e->rdma_sge.mr);\n\t\t\te->rdma_sge.mr = NULL;\n\t\t}\n\t\treth = &ohdr->u.rc.reth;\n\t\tlen = be32_to_cpu(reth->length);\n\t\tif (len) {\n\t\t\tu32 rkey = be32_to_cpu(reth->rkey);\n\t\t\tu64 vaddr = be64_to_cpu(reth->vaddr);\n\t\t\tint ok;\n\n\t\t\t \n\t\t\tok = rvt_rkey_ok(qp, &e->rdma_sge, len, vaddr,\n\t\t\t\t\t rkey, IB_ACCESS_REMOTE_READ);\n\t\t\tif (unlikely(!ok))\n\t\t\t\tgoto nack_acc_unlck;\n\t\t\t \n\t\t\tqp->r_psn += rvt_div_mtu(qp, len - 1);\n\t\t} else {\n\t\t\te->rdma_sge.mr = NULL;\n\t\t\te->rdma_sge.vaddr = NULL;\n\t\t\te->rdma_sge.length = 0;\n\t\t\te->rdma_sge.sge_length = 0;\n\t\t}\n\t\te->opcode = opcode;\n\t\te->sent = 0;\n\t\te->psn = psn;\n\t\te->lpsn = qp->r_psn;\n\t\t \n\t\tqp->r_msn++;\n\t\tqp->r_psn++;\n\t\tqp->r_state = opcode;\n\t\tqp->r_nak_state = 0;\n\t\tqp->r_head_ack_queue = next;\n\n\t\t \n\t\tqp->s_flags |= RVT_S_RESP_PENDING;\n\t\tqib_schedule_send(qp);\n\n\t\tgoto sunlock;\n\t}\n\n\tcase OP(COMPARE_SWAP):\n\tcase OP(FETCH_ADD): {\n\t\tstruct ib_atomic_eth *ateth;\n\t\tstruct rvt_ack_entry *e;\n\t\tu64 vaddr;\n\t\tatomic64_t *maddr;\n\t\tu64 sdata;\n\t\tu32 rkey;\n\t\tu8 next;\n\n\t\tif (unlikely(!(qp->qp_access_flags & IB_ACCESS_REMOTE_ATOMIC)))\n\t\t\tgoto nack_inv;\n\t\tnext = qp->r_head_ack_queue + 1;\n\t\tif (next > QIB_MAX_RDMA_ATOMIC)\n\t\t\tnext = 0;\n\t\tspin_lock_irqsave(&qp->s_lock, flags);\n\t\tif (unlikely(next == qp->s_tail_ack_queue)) {\n\t\t\tif (!qp->s_ack_queue[next].sent)\n\t\t\t\tgoto nack_inv_unlck;\n\t\t\tqib_update_ack_queue(qp, next);\n\t\t}\n\t\te = &qp->s_ack_queue[qp->r_head_ack_queue];\n\t\tif (e->opcode == OP(RDMA_READ_REQUEST) && e->rdma_sge.mr) {\n\t\t\trvt_put_mr(e->rdma_sge.mr);\n\t\t\te->rdma_sge.mr = NULL;\n\t\t}\n\t\tateth = &ohdr->u.atomic_eth;\n\t\tvaddr = get_ib_ateth_vaddr(ateth);\n\t\tif (unlikely(vaddr & (sizeof(u64) - 1)))\n\t\t\tgoto nack_inv_unlck;\n\t\trkey = be32_to_cpu(ateth->rkey);\n\t\t \n\t\tif (unlikely(!rvt_rkey_ok(qp, &qp->r_sge.sge, sizeof(u64),\n\t\t\t\t\t  vaddr, rkey,\n\t\t\t\t\t  IB_ACCESS_REMOTE_ATOMIC)))\n\t\t\tgoto nack_acc_unlck;\n\t\t \n\t\tmaddr = (atomic64_t *) qp->r_sge.sge.vaddr;\n\t\tsdata = get_ib_ateth_swap(ateth);\n\t\te->atomic_data = (opcode == OP(FETCH_ADD)) ?\n\t\t\t(u64) atomic64_add_return(sdata, maddr) - sdata :\n\t\t\t(u64) cmpxchg((u64 *) qp->r_sge.sge.vaddr,\n\t\t\t\t      get_ib_ateth_compare(ateth),\n\t\t\t\t      sdata);\n\t\trvt_put_mr(qp->r_sge.sge.mr);\n\t\tqp->r_sge.num_sge = 0;\n\t\te->opcode = opcode;\n\t\te->sent = 0;\n\t\te->psn = psn;\n\t\te->lpsn = psn;\n\t\tqp->r_msn++;\n\t\tqp->r_psn++;\n\t\tqp->r_state = opcode;\n\t\tqp->r_nak_state = 0;\n\t\tqp->r_head_ack_queue = next;\n\n\t\t \n\t\tqp->s_flags |= RVT_S_RESP_PENDING;\n\t\tqib_schedule_send(qp);\n\n\t\tgoto sunlock;\n\t}\n\n\tdefault:\n\t\t \n\t\tgoto nack_inv;\n\t}\n\tqp->r_psn++;\n\tqp->r_state = opcode;\n\tqp->r_ack_psn = psn;\n\tqp->r_nak_state = 0;\n\t \n\tif (psn & (1 << 31))\n\t\tgoto send_ack;\n\treturn;\n\nrnr_nak:\n\tqp->r_nak_state = IB_RNR_NAK | qp->r_min_rnr_timer;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\tif (list_empty(&qp->rspwait)) {\n\t\tqp->r_flags |= RVT_R_RSP_NAK;\n\t\trvt_get_qp(qp);\n\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t}\n\treturn;\n\nnack_op_err:\n\trvt_rc_error(qp, IB_WC_LOC_QP_OP_ERR);\n\tqp->r_nak_state = IB_NAK_REMOTE_OPERATIONAL_ERROR;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\tif (list_empty(&qp->rspwait)) {\n\t\tqp->r_flags |= RVT_R_RSP_NAK;\n\t\trvt_get_qp(qp);\n\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t}\n\treturn;\n\nnack_inv_unlck:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nnack_inv:\n\trvt_rc_error(qp, IB_WC_LOC_QP_OP_ERR);\n\tqp->r_nak_state = IB_NAK_INVALID_REQUEST;\n\tqp->r_ack_psn = qp->r_psn;\n\t \n\tif (list_empty(&qp->rspwait)) {\n\t\tqp->r_flags |= RVT_R_RSP_NAK;\n\t\trvt_get_qp(qp);\n\t\tlist_add_tail(&qp->rspwait, &rcd->qp_wait_list);\n\t}\n\treturn;\n\nnack_acc_unlck:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\nnack_acc:\n\trvt_rc_error(qp, IB_WC_LOC_PROT_ERR);\n\tqp->r_nak_state = IB_NAK_REMOTE_ACCESS_ERROR;\n\tqp->r_ack_psn = qp->r_psn;\nsend_ack:\n\tqib_send_rc_ack(qp);\n\treturn;\n\nsunlock:\n\tspin_unlock_irqrestore(&qp->s_lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}