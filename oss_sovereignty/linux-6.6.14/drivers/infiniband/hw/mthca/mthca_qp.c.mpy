{
  "module_name": "mthca_qp.c",
  "hash_id": "0a03b5d3f5d98203840b3fbbf9cfce33d20746fc97b4c853b03372dc5c6412df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_qp.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\n#include <asm/io.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_pack.h>\n#include <rdma/uverbs_ioctl.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n#include \"mthca_memfree.h\"\n#include \"mthca_wqe.h\"\n\nenum {\n\tMTHCA_MAX_DIRECT_QP_SIZE = 4 * PAGE_SIZE,\n\tMTHCA_ACK_REQ_FREQ       = 10,\n\tMTHCA_FLIGHT_LIMIT       = 9,\n\tMTHCA_UD_HEADER_SIZE     = 72,  \n\tMTHCA_INLINE_HEADER_SIZE = 4,   \n\tMTHCA_INLINE_CHUNK_SIZE  = 16   \n};\n\nenum {\n\tMTHCA_QP_STATE_RST  = 0,\n\tMTHCA_QP_STATE_INIT = 1,\n\tMTHCA_QP_STATE_RTR  = 2,\n\tMTHCA_QP_STATE_RTS  = 3,\n\tMTHCA_QP_STATE_SQE  = 4,\n\tMTHCA_QP_STATE_SQD  = 5,\n\tMTHCA_QP_STATE_ERR  = 6,\n\tMTHCA_QP_STATE_DRAINING = 7\n};\n\nenum {\n\tMTHCA_QP_ST_RC \t= 0x0,\n\tMTHCA_QP_ST_UC \t= 0x1,\n\tMTHCA_QP_ST_RD \t= 0x2,\n\tMTHCA_QP_ST_UD \t= 0x3,\n\tMTHCA_QP_ST_MLX = 0x7\n};\n\nenum {\n\tMTHCA_QP_PM_MIGRATED = 0x3,\n\tMTHCA_QP_PM_ARMED    = 0x0,\n\tMTHCA_QP_PM_REARM    = 0x1\n};\n\nenum {\n\t \n\tMTHCA_QP_BIT_DE  = 1 <<  8,\n\t \n\tMTHCA_QP_BIT_SRE = 1 << 15,\n\tMTHCA_QP_BIT_SWE = 1 << 14,\n\tMTHCA_QP_BIT_SAE = 1 << 13,\n\tMTHCA_QP_BIT_SIC = 1 <<  4,\n\tMTHCA_QP_BIT_SSC = 1 <<  3,\n\t \n\tMTHCA_QP_BIT_RRE = 1 << 15,\n\tMTHCA_QP_BIT_RWE = 1 << 14,\n\tMTHCA_QP_BIT_RAE = 1 << 13,\n\tMTHCA_QP_BIT_RIC = 1 <<  4,\n\tMTHCA_QP_BIT_RSC = 1 <<  3\n};\n\nenum {\n\tMTHCA_SEND_DOORBELL_FENCE = 1 << 5\n};\n\nstruct mthca_qp_path {\n\t__be32 port_pkey;\n\tu8     rnr_retry;\n\tu8     g_mylmc;\n\t__be16 rlid;\n\tu8     ackto;\n\tu8     mgid_index;\n\tu8     static_rate;\n\tu8     hop_limit;\n\t__be32 sl_tclass_flowlabel;\n\tu8     rgid[16];\n} __packed;\n\nstruct mthca_qp_context {\n\t__be32 flags;\n\t__be32 tavor_sched_queue;  \n\tu8     mtu_msgmax;\n\tu8     rq_size_stride;\t \n\tu8     sq_size_stride;\t \n\tu8     rlkey_arbel_sched_queue;\t \n\t__be32 usr_page;\n\t__be32 local_qpn;\n\t__be32 remote_qpn;\n\tu32    reserved1[2];\n\tstruct mthca_qp_path pri_path;\n\tstruct mthca_qp_path alt_path;\n\t__be32 rdd;\n\t__be32 pd;\n\t__be32 wqe_base;\n\t__be32 wqe_lkey;\n\t__be32 params1;\n\t__be32 reserved2;\n\t__be32 next_send_psn;\n\t__be32 cqn_snd;\n\t__be32 snd_wqe_base_l;\t \n\t__be32 snd_db_index;\t \n\t__be32 last_acked_psn;\n\t__be32 ssn;\n\t__be32 params2;\n\t__be32 rnr_nextrecvpsn;\n\t__be32 ra_buff_indx;\n\t__be32 cqn_rcv;\n\t__be32 rcv_wqe_base_l;\t \n\t__be32 rcv_db_index;\t \n\t__be32 qkey;\n\t__be32 srqn;\n\t__be32 rmsn;\n\t__be16 rq_wqe_counter;\t \n\t__be16 sq_wqe_counter;\t \n\tu32    reserved3[18];\n} __packed;\n\nstruct mthca_qp_param {\n\t__be32 opt_param_mask;\n\tu32    reserved1;\n\tstruct mthca_qp_context context;\n\tu32    reserved2[62];\n} __packed;\n\nenum {\n\tMTHCA_QP_OPTPAR_ALT_ADDR_PATH     = 1 << 0,\n\tMTHCA_QP_OPTPAR_RRE               = 1 << 1,\n\tMTHCA_QP_OPTPAR_RAE               = 1 << 2,\n\tMTHCA_QP_OPTPAR_RWE               = 1 << 3,\n\tMTHCA_QP_OPTPAR_PKEY_INDEX        = 1 << 4,\n\tMTHCA_QP_OPTPAR_Q_KEY             = 1 << 5,\n\tMTHCA_QP_OPTPAR_RNR_TIMEOUT       = 1 << 6,\n\tMTHCA_QP_OPTPAR_PRIMARY_ADDR_PATH = 1 << 7,\n\tMTHCA_QP_OPTPAR_SRA_MAX           = 1 << 8,\n\tMTHCA_QP_OPTPAR_RRA_MAX           = 1 << 9,\n\tMTHCA_QP_OPTPAR_PM_STATE          = 1 << 10,\n\tMTHCA_QP_OPTPAR_PORT_NUM          = 1 << 11,\n\tMTHCA_QP_OPTPAR_RETRY_COUNT       = 1 << 12,\n\tMTHCA_QP_OPTPAR_ALT_RNR_RETRY     = 1 << 13,\n\tMTHCA_QP_OPTPAR_ACK_TIMEOUT       = 1 << 14,\n\tMTHCA_QP_OPTPAR_RNR_RETRY         = 1 << 15,\n\tMTHCA_QP_OPTPAR_SCHED_QUEUE       = 1 << 16\n};\n\nstatic const u8 mthca_opcode[] = {\n\t[IB_WR_SEND]                 = MTHCA_OPCODE_SEND,\n\t[IB_WR_SEND_WITH_IMM]        = MTHCA_OPCODE_SEND_IMM,\n\t[IB_WR_RDMA_WRITE]           = MTHCA_OPCODE_RDMA_WRITE,\n\t[IB_WR_RDMA_WRITE_WITH_IMM]  = MTHCA_OPCODE_RDMA_WRITE_IMM,\n\t[IB_WR_RDMA_READ]            = MTHCA_OPCODE_RDMA_READ,\n\t[IB_WR_ATOMIC_CMP_AND_SWP]   = MTHCA_OPCODE_ATOMIC_CS,\n\t[IB_WR_ATOMIC_FETCH_AND_ADD] = MTHCA_OPCODE_ATOMIC_FA,\n};\n\nstatic int is_sqp(struct mthca_dev *dev, struct mthca_qp *qp)\n{\n\treturn qp->qpn >= dev->qp_table.sqp_start &&\n\t\tqp->qpn <= dev->qp_table.sqp_start + 3;\n}\n\nstatic int is_qp0(struct mthca_dev *dev, struct mthca_qp *qp)\n{\n\treturn qp->qpn >= dev->qp_table.sqp_start &&\n\t\tqp->qpn <= dev->qp_table.sqp_start + 1;\n}\n\nstatic void *get_recv_wqe(struct mthca_qp *qp, int n)\n{\n\tif (qp->is_direct)\n\t\treturn qp->queue.direct.buf + (n << qp->rq.wqe_shift);\n\telse\n\t\treturn qp->queue.page_list[(n << qp->rq.wqe_shift) >> PAGE_SHIFT].buf +\n\t\t\t((n << qp->rq.wqe_shift) & (PAGE_SIZE - 1));\n}\n\nstatic void *get_send_wqe(struct mthca_qp *qp, int n)\n{\n\tif (qp->is_direct)\n\t\treturn qp->queue.direct.buf + qp->send_wqe_offset +\n\t\t\t(n << qp->sq.wqe_shift);\n\telse\n\t\treturn qp->queue.page_list[(qp->send_wqe_offset +\n\t\t\t\t\t    (n << qp->sq.wqe_shift)) >>\n\t\t\t\t\t   PAGE_SHIFT].buf +\n\t\t\t((qp->send_wqe_offset + (n << qp->sq.wqe_shift)) &\n\t\t\t (PAGE_SIZE - 1));\n}\n\nstatic void mthca_wq_reset(struct mthca_wq *wq)\n{\n\twq->next_ind  = 0;\n\twq->last_comp = wq->max - 1;\n\twq->head      = 0;\n\twq->tail      = 0;\n}\n\nvoid mthca_qp_event(struct mthca_dev *dev, u32 qpn,\n\t\t    enum ib_event_type event_type)\n{\n\tstruct mthca_qp *qp;\n\tstruct ib_event event;\n\n\tspin_lock(&dev->qp_table.lock);\n\tqp = mthca_array_get(&dev->qp_table.qp, qpn & (dev->limits.num_qps - 1));\n\tif (qp)\n\t\t++qp->refcount;\n\tspin_unlock(&dev->qp_table.lock);\n\n\tif (!qp) {\n\t\tmthca_warn(dev, \"Async event %d for bogus QP %08x\\n\",\n\t\t\t   event_type, qpn);\n\t\treturn;\n\t}\n\n\tif (event_type == IB_EVENT_PATH_MIG)\n\t\tqp->port = qp->alt_port;\n\n\tevent.device      = &dev->ib_dev;\n\tevent.event       = event_type;\n\tevent.element.qp  = &qp->ibqp;\n\tif (qp->ibqp.event_handler)\n\t\tqp->ibqp.event_handler(&event, qp->ibqp.qp_context);\n\n\tspin_lock(&dev->qp_table.lock);\n\tif (!--qp->refcount)\n\t\twake_up(&qp->wait);\n\tspin_unlock(&dev->qp_table.lock);\n}\n\nstatic int to_mthca_state(enum ib_qp_state ib_state)\n{\n\tswitch (ib_state) {\n\tcase IB_QPS_RESET: return MTHCA_QP_STATE_RST;\n\tcase IB_QPS_INIT:  return MTHCA_QP_STATE_INIT;\n\tcase IB_QPS_RTR:   return MTHCA_QP_STATE_RTR;\n\tcase IB_QPS_RTS:   return MTHCA_QP_STATE_RTS;\n\tcase IB_QPS_SQD:   return MTHCA_QP_STATE_SQD;\n\tcase IB_QPS_SQE:   return MTHCA_QP_STATE_SQE;\n\tcase IB_QPS_ERR:   return MTHCA_QP_STATE_ERR;\n\tdefault:                return -1;\n\t}\n}\n\nenum { RC, UC, UD, RD, RDEE, MLX, NUM_TRANS };\n\nstatic int to_mthca_st(int transport)\n{\n\tswitch (transport) {\n\tcase RC:  return MTHCA_QP_ST_RC;\n\tcase UC:  return MTHCA_QP_ST_UC;\n\tcase UD:  return MTHCA_QP_ST_UD;\n\tcase RD:  return MTHCA_QP_ST_RD;\n\tcase MLX: return MTHCA_QP_ST_MLX;\n\tdefault:  return -1;\n\t}\n}\n\nstatic void store_attrs(struct mthca_sqp *sqp, const struct ib_qp_attr *attr,\n\t\t\tint attr_mask)\n{\n\tif (attr_mask & IB_QP_PKEY_INDEX)\n\t\tsqp->pkey_index = attr->pkey_index;\n\tif (attr_mask & IB_QP_QKEY)\n\t\tsqp->qkey = attr->qkey;\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tsqp->send_psn = attr->sq_psn;\n}\n\nstatic void init_port(struct mthca_dev *dev, int port)\n{\n\tint err;\n\tstruct mthca_init_ib_param param;\n\n\tmemset(&param, 0, sizeof param);\n\n\tparam.port_width = dev->limits.port_width_cap;\n\tparam.vl_cap     = dev->limits.vl_cap;\n\tparam.mtu_cap    = dev->limits.mtu_cap;\n\tparam.gid_cap    = dev->limits.gid_table_len;\n\tparam.pkey_cap   = dev->limits.pkey_table_len;\n\n\terr = mthca_INIT_IB(dev, &param, port);\n\tif (err)\n\t\tmthca_warn(dev, \"INIT_IB failed, return code %d.\\n\", err);\n}\n\nstatic __be32 get_hw_access_flags(struct mthca_qp *qp, const struct ib_qp_attr *attr,\n\t\t\t\t  int attr_mask)\n{\n\tu8 dest_rd_atomic;\n\tu32 access_flags;\n\tu32 hw_access_flags = 0;\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tdest_rd_atomic = attr->max_dest_rd_atomic;\n\telse\n\t\tdest_rd_atomic = qp->resp_depth;\n\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\taccess_flags = attr->qp_access_flags;\n\telse\n\t\taccess_flags = qp->atomic_rd_en;\n\n\tif (!dest_rd_atomic)\n\t\taccess_flags &= IB_ACCESS_REMOTE_WRITE;\n\n\tif (access_flags & IB_ACCESS_REMOTE_READ)\n\t\thw_access_flags |= MTHCA_QP_BIT_RRE;\n\tif (access_flags & IB_ACCESS_REMOTE_ATOMIC)\n\t\thw_access_flags |= MTHCA_QP_BIT_RAE;\n\tif (access_flags & IB_ACCESS_REMOTE_WRITE)\n\t\thw_access_flags |= MTHCA_QP_BIT_RWE;\n\n\treturn cpu_to_be32(hw_access_flags);\n}\n\nstatic inline enum ib_qp_state to_ib_qp_state(int mthca_state)\n{\n\tswitch (mthca_state) {\n\tcase MTHCA_QP_STATE_RST:      return IB_QPS_RESET;\n\tcase MTHCA_QP_STATE_INIT:     return IB_QPS_INIT;\n\tcase MTHCA_QP_STATE_RTR:      return IB_QPS_RTR;\n\tcase MTHCA_QP_STATE_RTS:      return IB_QPS_RTS;\n\tcase MTHCA_QP_STATE_DRAINING:\n\tcase MTHCA_QP_STATE_SQD:      return IB_QPS_SQD;\n\tcase MTHCA_QP_STATE_SQE:      return IB_QPS_SQE;\n\tcase MTHCA_QP_STATE_ERR:      return IB_QPS_ERR;\n\tdefault:                      return -1;\n\t}\n}\n\nstatic inline enum ib_mig_state to_ib_mig_state(int mthca_mig_state)\n{\n\tswitch (mthca_mig_state) {\n\tcase 0:  return IB_MIG_ARMED;\n\tcase 1:  return IB_MIG_REARM;\n\tcase 3:  return IB_MIG_MIGRATED;\n\tdefault: return -1;\n\t}\n}\n\nstatic int to_ib_qp_access_flags(int mthca_flags)\n{\n\tint ib_flags = 0;\n\n\tif (mthca_flags & MTHCA_QP_BIT_RRE)\n\t\tib_flags |= IB_ACCESS_REMOTE_READ;\n\tif (mthca_flags & MTHCA_QP_BIT_RWE)\n\t\tib_flags |= IB_ACCESS_REMOTE_WRITE;\n\tif (mthca_flags & MTHCA_QP_BIT_RAE)\n\t\tib_flags |= IB_ACCESS_REMOTE_ATOMIC;\n\n\treturn ib_flags;\n}\n\nstatic void to_rdma_ah_attr(struct mthca_dev *dev,\n\t\t\t    struct rdma_ah_attr *ah_attr,\n\t\t\t    struct mthca_qp_path *path)\n{\n\tu8 port_num = (be32_to_cpu(path->port_pkey) >> 24) & 0x3;\n\n\tmemset(ah_attr, 0, sizeof(*ah_attr));\n\n\tif (port_num == 0 || port_num > dev->limits.num_ports)\n\t\treturn;\n\tah_attr->type = rdma_ah_find_type(&dev->ib_dev, port_num);\n\trdma_ah_set_port_num(ah_attr, port_num);\n\n\trdma_ah_set_dlid(ah_attr, be16_to_cpu(path->rlid));\n\trdma_ah_set_sl(ah_attr, be32_to_cpu(path->sl_tclass_flowlabel) >> 28);\n\trdma_ah_set_path_bits(ah_attr, path->g_mylmc & 0x7f);\n\trdma_ah_set_static_rate(ah_attr,\n\t\t\t\tmthca_rate_to_ib(dev,\n\t\t\t\t\t\t path->static_rate & 0xf,\n\t\t\t\t\t\t port_num));\n\tif (path->g_mylmc & (1 << 7)) {\n\t\tu32 tc_fl = be32_to_cpu(path->sl_tclass_flowlabel);\n\n\t\trdma_ah_set_grh(ah_attr, NULL,\n\t\t\t\ttc_fl & 0xfffff,\n\t\t\t\tpath->mgid_index &\n\t\t\t\t(dev->limits.gid_table_len - 1),\n\t\t\t\tpath->hop_limit,\n\t\t\t\t(tc_fl >> 20) & 0xff);\n\t\trdma_ah_set_dgid_raw(ah_attr, path->rgid);\n\t}\n}\n\nint mthca_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr_mask,\n\t\t   struct ib_qp_init_attr *qp_init_attr)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tint err = 0;\n\tstruct mthca_mailbox *mailbox = NULL;\n\tstruct mthca_qp_param *qp_param;\n\tstruct mthca_qp_context *context;\n\tint mthca_state;\n\n\tmutex_lock(&qp->mutex);\n\n\tif (qp->state == IB_QPS_RESET) {\n\t\tqp_attr->qp_state = IB_QPS_RESET;\n\t\tgoto done;\n\t}\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox)) {\n\t\terr = PTR_ERR(mailbox);\n\t\tgoto out;\n\t}\n\n\terr = mthca_QUERY_QP(dev, qp->qpn, 0, mailbox);\n\tif (err) {\n\t\tmthca_warn(dev, \"QUERY_QP failed (%d)\\n\", err);\n\t\tgoto out_mailbox;\n\t}\n\n\tqp_param    = mailbox->buf;\n\tcontext     = &qp_param->context;\n\tmthca_state = be32_to_cpu(context->flags) >> 28;\n\n\tqp->state\t\t     = to_ib_qp_state(mthca_state);\n\tqp_attr->qp_state\t     = qp->state;\n\tqp_attr->path_mtu \t     = context->mtu_msgmax >> 5;\n\tqp_attr->path_mig_state      =\n\t\tto_ib_mig_state((be32_to_cpu(context->flags) >> 11) & 0x3);\n\tqp_attr->qkey \t\t     = be32_to_cpu(context->qkey);\n\tqp_attr->rq_psn \t     = be32_to_cpu(context->rnr_nextrecvpsn) & 0xffffff;\n\tqp_attr->sq_psn \t     = be32_to_cpu(context->next_send_psn) & 0xffffff;\n\tqp_attr->dest_qp_num \t     = be32_to_cpu(context->remote_qpn) & 0xffffff;\n\tqp_attr->qp_access_flags     =\n\t\tto_ib_qp_access_flags(be32_to_cpu(context->params2));\n\n\tif (qp->transport == RC || qp->transport == UC) {\n\t\tto_rdma_ah_attr(dev, &qp_attr->ah_attr, &context->pri_path);\n\t\tto_rdma_ah_attr(dev, &qp_attr->alt_ah_attr, &context->alt_path);\n\t\tqp_attr->alt_pkey_index =\n\t\t\tbe32_to_cpu(context->alt_path.port_pkey) & 0x7f;\n\t\tqp_attr->alt_port_num\t=\n\t\t\trdma_ah_get_port_num(&qp_attr->alt_ah_attr);\n\t}\n\n\tqp_attr->pkey_index = be32_to_cpu(context->pri_path.port_pkey) & 0x7f;\n\tqp_attr->port_num   =\n\t\t(be32_to_cpu(context->pri_path.port_pkey) >> 24) & 0x3;\n\n\t \n\tqp_attr->sq_draining = mthca_state == MTHCA_QP_STATE_DRAINING;\n\n\tqp_attr->max_rd_atomic = 1 << ((be32_to_cpu(context->params1) >> 21) & 0x7);\n\n\tqp_attr->max_dest_rd_atomic =\n\t\t1 << ((be32_to_cpu(context->params2) >> 21) & 0x7);\n\tqp_attr->min_rnr_timer \t    =\n\t\t(be32_to_cpu(context->rnr_nextrecvpsn) >> 24) & 0x1f;\n\tqp_attr->timeout \t    = context->pri_path.ackto >> 3;\n\tqp_attr->retry_cnt \t    = (be32_to_cpu(context->params1) >> 16) & 0x7;\n\tqp_attr->rnr_retry \t    = context->pri_path.rnr_retry >> 5;\n\tqp_attr->alt_timeout \t    = context->alt_path.ackto >> 3;\n\ndone:\n\tqp_attr->cur_qp_state\t     = qp_attr->qp_state;\n\tqp_attr->cap.max_send_wr     = qp->sq.max;\n\tqp_attr->cap.max_recv_wr     = qp->rq.max;\n\tqp_attr->cap.max_send_sge    = qp->sq.max_gs;\n\tqp_attr->cap.max_recv_sge    = qp->rq.max_gs;\n\tqp_attr->cap.max_inline_data = qp->max_inline_data;\n\n\tqp_init_attr->cap\t     = qp_attr->cap;\n\tqp_init_attr->sq_sig_type    = qp->sq_policy;\n\nout_mailbox:\n\tmthca_free_mailbox(dev, mailbox);\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstatic int mthca_path_set(struct mthca_dev *dev, const struct rdma_ah_attr *ah,\n\t\t\t  struct mthca_qp_path *path, u8 port)\n{\n\tpath->g_mylmc     = rdma_ah_get_path_bits(ah) & 0x7f;\n\tpath->rlid        = cpu_to_be16(rdma_ah_get_dlid(ah));\n\tpath->static_rate = mthca_get_rate(dev, rdma_ah_get_static_rate(ah),\n\t\t\t\t\t   port);\n\n\tif (rdma_ah_get_ah_flags(ah) & IB_AH_GRH) {\n\t\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah);\n\n\t\tif (grh->sgid_index >= dev->limits.gid_table_len) {\n\t\t\tmthca_dbg(dev, \"sgid_index (%u) too large. max is %d\\n\",\n\t\t\t\t  grh->sgid_index,\n\t\t\t\t  dev->limits.gid_table_len - 1);\n\t\t\treturn -1;\n\t\t}\n\n\t\tpath->g_mylmc   |= 1 << 7;\n\t\tpath->mgid_index = grh->sgid_index;\n\t\tpath->hop_limit  = grh->hop_limit;\n\t\tpath->sl_tclass_flowlabel =\n\t\t\tcpu_to_be32((rdma_ah_get_sl(ah) << 28) |\n\t\t\t\t    (grh->traffic_class << 20) |\n\t\t\t\t    (grh->flow_label));\n\t\tmemcpy(path->rgid, grh->dgid.raw, 16);\n\t} else {\n\t\tpath->sl_tclass_flowlabel = cpu_to_be32(rdma_ah_get_sl(ah) <<\n\t\t\t\t\t\t\t28);\n\t}\n\n\treturn 0;\n}\n\nstatic int __mthca_modify_qp(struct ib_qp *ibqp,\n\t\t\t     const struct ib_qp_attr *attr, int attr_mask,\n\t\t\t     enum ib_qp_state cur_state,\n\t\t\t     enum ib_qp_state new_state,\n\t\t\t     struct ib_udata *udata)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tstruct mthca_ucontext *context = rdma_udata_to_drv_context(\n\t\tudata, struct mthca_ucontext, ibucontext);\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_qp_param *qp_param;\n\tstruct mthca_qp_context *qp_context;\n\tu32 sqd_event = 0;\n\tint err = -EINVAL;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox)) {\n\t\terr = PTR_ERR(mailbox);\n\t\tgoto out;\n\t}\n\tqp_param = mailbox->buf;\n\tqp_context = &qp_param->context;\n\tmemset(qp_param, 0, sizeof *qp_param);\n\n\tqp_context->flags      = cpu_to_be32((to_mthca_state(new_state) << 28) |\n\t\t\t\t\t     (to_mthca_st(qp->transport) << 16));\n\tqp_context->flags     |= cpu_to_be32(MTHCA_QP_BIT_DE);\n\tif (!(attr_mask & IB_QP_PATH_MIG_STATE))\n\t\tqp_context->flags |= cpu_to_be32(MTHCA_QP_PM_MIGRATED << 11);\n\telse {\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_PM_STATE);\n\t\tswitch (attr->path_mig_state) {\n\t\tcase IB_MIG_MIGRATED:\n\t\t\tqp_context->flags |= cpu_to_be32(MTHCA_QP_PM_MIGRATED << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_REARM:\n\t\t\tqp_context->flags |= cpu_to_be32(MTHCA_QP_PM_REARM << 11);\n\t\t\tbreak;\n\t\tcase IB_MIG_ARMED:\n\t\t\tqp_context->flags |= cpu_to_be32(MTHCA_QP_PM_ARMED << 11);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif (qp->transport == MLX || qp->transport == UD)\n\t\tqp_context->mtu_msgmax = (IB_MTU_2048 << 5) | 11;\n\telse if (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attr->path_mtu < IB_MTU_256 || attr->path_mtu > IB_MTU_2048) {\n\t\t\tmthca_dbg(dev, \"path MTU (%u) is invalid\\n\",\n\t\t\t\t  attr->path_mtu);\n\t\t\tgoto out_mailbox;\n\t\t}\n\t\tqp_context->mtu_msgmax = (attr->path_mtu << 5) | 31;\n\t}\n\n\tif (mthca_is_memfree(dev)) {\n\t\tif (qp->rq.max)\n\t\t\tqp_context->rq_size_stride = ilog2(qp->rq.max) << 3;\n\t\tqp_context->rq_size_stride |= qp->rq.wqe_shift - 4;\n\n\t\tif (qp->sq.max)\n\t\t\tqp_context->sq_size_stride = ilog2(qp->sq.max) << 3;\n\t\tqp_context->sq_size_stride |= qp->sq.wqe_shift - 4;\n\t}\n\n\t \n\n\tif (qp->ibqp.uobject)\n\t\tqp_context->usr_page = cpu_to_be32(context->uar.index);\n\telse\n\t\tqp_context->usr_page = cpu_to_be32(dev->driver_uar.index);\n\tqp_context->local_qpn  = cpu_to_be32(qp->qpn);\n\tif (attr_mask & IB_QP_DEST_QPN) {\n\t\tqp_context->remote_qpn = cpu_to_be32(attr->dest_qp_num);\n\t}\n\n\tif (qp->transport == MLX)\n\t\tqp_context->pri_path.port_pkey |=\n\t\t\tcpu_to_be32(qp->port << 24);\n\telse {\n\t\tif (attr_mask & IB_QP_PORT) {\n\t\t\tqp_context->pri_path.port_pkey |=\n\t\t\t\tcpu_to_be32(attr->port_num << 24);\n\t\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_PORT_NUM);\n\t\t}\n\t}\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tqp_context->pri_path.port_pkey |=\n\t\t\tcpu_to_be32(attr->pkey_index);\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_PKEY_INDEX);\n\t}\n\n\tif (attr_mask & IB_QP_RNR_RETRY) {\n\t\tqp_context->alt_path.rnr_retry = qp_context->pri_path.rnr_retry =\n\t\t\tattr->rnr_retry << 5;\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_RNR_RETRY |\n\t\t\t\t\t\t\tMTHCA_QP_OPTPAR_ALT_RNR_RETRY);\n\t}\n\n\tif (attr_mask & IB_QP_AV) {\n\t\tif (mthca_path_set(dev, &attr->ah_attr, &qp_context->pri_path,\n\t\t\t\t   attr_mask & IB_QP_PORT ? attr->port_num : qp->port))\n\t\t\tgoto out_mailbox;\n\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_PRIMARY_ADDR_PATH);\n\t}\n\n\tif (ibqp->qp_type == IB_QPT_RC &&\n\t    cur_state == IB_QPS_INIT && new_state == IB_QPS_RTR) {\n\t\tu8 sched_queue = ibqp->uobject ? 0x2 : 0x1;\n\n\t\tif (mthca_is_memfree(dev))\n\t\t\tqp_context->rlkey_arbel_sched_queue |= sched_queue;\n\t\telse\n\t\t\tqp_context->tavor_sched_queue |= cpu_to_be32(sched_queue);\n\n\t\tqp_param->opt_param_mask |=\n\t\t\tcpu_to_be32(MTHCA_QP_OPTPAR_SCHED_QUEUE);\n\t}\n\n\tif (attr_mask & IB_QP_TIMEOUT) {\n\t\tqp_context->pri_path.ackto = attr->timeout << 3;\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_ACK_TIMEOUT);\n\t}\n\n\tif (attr_mask & IB_QP_ALT_PATH) {\n\t\tif (attr->alt_pkey_index >= dev->limits.pkey_table_len) {\n\t\t\tmthca_dbg(dev, \"Alternate P_Key index (%u) too large. max is %d\\n\",\n\t\t\t\t  attr->alt_pkey_index, dev->limits.pkey_table_len-1);\n\t\t\tgoto out_mailbox;\n\t\t}\n\n\t\tif (attr->alt_port_num == 0 || attr->alt_port_num > dev->limits.num_ports) {\n\t\t\tmthca_dbg(dev, \"Alternate port number (%u) is invalid\\n\",\n\t\t\t\tattr->alt_port_num);\n\t\t\tgoto out_mailbox;\n\t\t}\n\n\t\tif (mthca_path_set(dev, &attr->alt_ah_attr, &qp_context->alt_path,\n\t\t\t\t   rdma_ah_get_port_num(&attr->alt_ah_attr)))\n\t\t\tgoto out_mailbox;\n\n\t\tqp_context->alt_path.port_pkey |= cpu_to_be32(attr->alt_pkey_index |\n\t\t\t\t\t\t\t      attr->alt_port_num << 24);\n\t\tqp_context->alt_path.ackto = attr->alt_timeout << 3;\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_ALT_ADDR_PATH);\n\t}\n\n\t \n\tqp_context->pd         = cpu_to_be32(to_mpd(ibqp->pd)->pd_num);\n\t \n\tqp_context->wqe_lkey   = cpu_to_be32(qp->mr.ibmr.lkey);\n\tqp_context->params1    = cpu_to_be32((MTHCA_ACK_REQ_FREQ << 28) |\n\t\t\t\t\t     (MTHCA_FLIGHT_LIMIT << 24) |\n\t\t\t\t\t     MTHCA_QP_BIT_SWE);\n\tif (qp->sq_policy == IB_SIGNAL_ALL_WR)\n\t\tqp_context->params1 |= cpu_to_be32(MTHCA_QP_BIT_SSC);\n\tif (attr_mask & IB_QP_RETRY_CNT) {\n\t\tqp_context->params1 |= cpu_to_be32(attr->retry_cnt << 16);\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_RETRY_COUNT);\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attr->max_rd_atomic) {\n\t\t\tqp_context->params1 |=\n\t\t\t\tcpu_to_be32(MTHCA_QP_BIT_SRE |\n\t\t\t\t\t    MTHCA_QP_BIT_SAE);\n\t\t\tqp_context->params1 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_rd_atomic - 1) << 21);\n\t\t}\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_SRA_MAX);\n\t}\n\n\tif (attr_mask & IB_QP_SQ_PSN)\n\t\tqp_context->next_send_psn = cpu_to_be32(attr->sq_psn);\n\tqp_context->cqn_snd = cpu_to_be32(to_mcq(ibqp->send_cq)->cqn);\n\n\tif (mthca_is_memfree(dev)) {\n\t\tqp_context->snd_wqe_base_l = cpu_to_be32(qp->send_wqe_offset);\n\t\tqp_context->snd_db_index   = cpu_to_be32(qp->sq.db_index);\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attr->max_dest_rd_atomic)\n\t\t\tqp_context->params2 |=\n\t\t\t\tcpu_to_be32(fls(attr->max_dest_rd_atomic - 1) << 21);\n\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_RRA_MAX);\n\t}\n\n\tif (attr_mask & (IB_QP_ACCESS_FLAGS | IB_QP_MAX_DEST_RD_ATOMIC)) {\n\t\tqp_context->params2      |= get_hw_access_flags(qp, attr, attr_mask);\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_RWE |\n\t\t\t\t\t\t\tMTHCA_QP_OPTPAR_RRE |\n\t\t\t\t\t\t\tMTHCA_QP_OPTPAR_RAE);\n\t}\n\n\tqp_context->params2 |= cpu_to_be32(MTHCA_QP_BIT_RSC);\n\n\tif (ibqp->srq)\n\t\tqp_context->params2 |= cpu_to_be32(MTHCA_QP_BIT_RIC);\n\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER) {\n\t\tqp_context->rnr_nextrecvpsn |= cpu_to_be32(attr->min_rnr_timer << 24);\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_RNR_TIMEOUT);\n\t}\n\tif (attr_mask & IB_QP_RQ_PSN)\n\t\tqp_context->rnr_nextrecvpsn |= cpu_to_be32(attr->rq_psn);\n\n\tqp_context->ra_buff_indx =\n\t\tcpu_to_be32(dev->qp_table.rdb_base +\n\t\t\t    ((qp->qpn & (dev->limits.num_qps - 1)) * MTHCA_RDB_ENTRY_SIZE <<\n\t\t\t     dev->qp_table.rdb_shift));\n\n\tqp_context->cqn_rcv = cpu_to_be32(to_mcq(ibqp->recv_cq)->cqn);\n\n\tif (mthca_is_memfree(dev))\n\t\tqp_context->rcv_db_index   = cpu_to_be32(qp->rq.db_index);\n\n\tif (attr_mask & IB_QP_QKEY) {\n\t\tqp_context->qkey = cpu_to_be32(attr->qkey);\n\t\tqp_param->opt_param_mask |= cpu_to_be32(MTHCA_QP_OPTPAR_Q_KEY);\n\t}\n\n\tif (ibqp->srq)\n\t\tqp_context->srqn = cpu_to_be32(1 << 24 |\n\t\t\t\t\t       to_msrq(ibqp->srq)->srqn);\n\n\tif (cur_state == IB_QPS_RTS && new_state == IB_QPS_SQD\t&&\n\t    attr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY\t\t&&\n\t    attr->en_sqd_async_notify)\n\t\tsqd_event = 1 << 31;\n\n\terr = mthca_MODIFY_QP(dev, cur_state, new_state, qp->qpn, 0,\n\t\t\t      mailbox, sqd_event);\n\tif (err) {\n\t\tmthca_warn(dev, \"modify QP %d->%d returned %d.\\n\",\n\t\t\t   cur_state, new_state, err);\n\t\tgoto out_mailbox;\n\t}\n\n\tqp->state = new_state;\n\tif (attr_mask & IB_QP_ACCESS_FLAGS)\n\t\tqp->atomic_rd_en = attr->qp_access_flags;\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC)\n\t\tqp->resp_depth = attr->max_dest_rd_atomic;\n\tif (attr_mask & IB_QP_PORT)\n\t\tqp->port = attr->port_num;\n\tif (attr_mask & IB_QP_ALT_PATH)\n\t\tqp->alt_port = attr->alt_port_num;\n\n\tif (is_sqp(dev, qp))\n\t\tstore_attrs(qp->sqp, attr, attr_mask);\n\n\t \n\tif (is_qp0(dev, qp)) {\n\t\tif (cur_state != IB_QPS_RTR &&\n\t\t    new_state == IB_QPS_RTR)\n\t\t\tinit_port(dev, qp->port);\n\n\t\tif (cur_state != IB_QPS_RESET &&\n\t\t    cur_state != IB_QPS_ERR &&\n\t\t    (new_state == IB_QPS_RESET ||\n\t\t     new_state == IB_QPS_ERR))\n\t\t\tmthca_CLOSE_IB(dev, qp->port);\n\t}\n\n\t \n\tif (new_state == IB_QPS_RESET && !qp->ibqp.uobject) {\n\t\tmthca_cq_clean(dev, to_mcq(qp->ibqp.recv_cq), qp->qpn,\n\t\t\t       qp->ibqp.srq ? to_msrq(qp->ibqp.srq) : NULL);\n\t\tif (qp->ibqp.send_cq != qp->ibqp.recv_cq)\n\t\t\tmthca_cq_clean(dev, to_mcq(qp->ibqp.send_cq), qp->qpn, NULL);\n\n\t\tmthca_wq_reset(&qp->sq);\n\t\tqp->sq.last = get_send_wqe(qp, qp->sq.max - 1);\n\n\t\tmthca_wq_reset(&qp->rq);\n\t\tqp->rq.last = get_recv_wqe(qp, qp->rq.max - 1);\n\n\t\tif (mthca_is_memfree(dev)) {\n\t\t\t*qp->sq.db = 0;\n\t\t\t*qp->rq.db = 0;\n\t\t}\n\t}\n\nout_mailbox:\n\tmthca_free_mailbox(dev, mailbox);\nout:\n\treturn err;\n}\n\nint mthca_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *attr, int attr_mask,\n\t\t    struct ib_udata *udata)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tenum ib_qp_state cur_state, new_state;\n\tint err = -EINVAL;\n\n\tif (attr_mask & ~IB_QP_ATTR_STANDARD_BITS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&qp->mutex);\n\tif (attr_mask & IB_QP_CUR_STATE) {\n\t\tcur_state = attr->cur_qp_state;\n\t} else {\n\t\tspin_lock_irq(&qp->sq.lock);\n\t\tspin_lock(&qp->rq.lock);\n\t\tcur_state = qp->state;\n\t\tspin_unlock(&qp->rq.lock);\n\t\tspin_unlock_irq(&qp->sq.lock);\n\t}\n\n\tnew_state = attr_mask & IB_QP_STATE ? attr->qp_state : cur_state;\n\n\tif (!ib_modify_qp_is_ok(cur_state, new_state, ibqp->qp_type,\n\t\t\t\tattr_mask)) {\n\t\tmthca_dbg(dev, \"Bad QP transition (transport %d) \"\n\t\t\t  \"%d->%d with attr 0x%08x\\n\",\n\t\t\t  qp->transport, cur_state, new_state,\n\t\t\t  attr_mask);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PKEY_INDEX) &&\n\t     attr->pkey_index >= dev->limits.pkey_table_len) {\n\t\tmthca_dbg(dev, \"P_Key index (%u) too large. max is %d\\n\",\n\t\t\t  attr->pkey_index, dev->limits.pkey_table_len-1);\n\t\tgoto out;\n\t}\n\n\tif ((attr_mask & IB_QP_PORT) &&\n\t    (attr->port_num == 0 || attr->port_num > dev->limits.num_ports)) {\n\t\tmthca_dbg(dev, \"Port number (%u) is invalid\\n\", attr->port_num);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC &&\n\t    attr->max_rd_atomic > dev->limits.max_qp_init_rdma) {\n\t\tmthca_dbg(dev, \"Max rdma_atomic as initiator %u too large (max is %d)\\n\",\n\t\t\t  attr->max_rd_atomic, dev->limits.max_qp_init_rdma);\n\t\tgoto out;\n\t}\n\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC &&\n\t    attr->max_dest_rd_atomic > 1 << dev->qp_table.rdb_shift) {\n\t\tmthca_dbg(dev, \"Max rdma_atomic as responder %u too large (max %d)\\n\",\n\t\t\t  attr->max_dest_rd_atomic, 1 << dev->qp_table.rdb_shift);\n\t\tgoto out;\n\t}\n\n\tif (cur_state == new_state && cur_state == IB_QPS_RESET) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\terr = __mthca_modify_qp(ibqp, attr, attr_mask, cur_state, new_state,\n\t\t\t\tudata);\n\nout:\n\tmutex_unlock(&qp->mutex);\n\treturn err;\n}\n\nstatic int mthca_max_data_size(struct mthca_dev *dev, struct mthca_qp *qp, int desc_sz)\n{\n\t \n\tint max_data_size = desc_sz - sizeof (struct mthca_next_seg);\n\n\tswitch (qp->transport) {\n\tcase MLX:\n\t\tmax_data_size -= 2 * sizeof (struct mthca_data_seg);\n\t\tbreak;\n\n\tcase UD:\n\t\tif (mthca_is_memfree(dev))\n\t\t\tmax_data_size -= sizeof (struct mthca_arbel_ud_seg);\n\t\telse\n\t\t\tmax_data_size -= sizeof (struct mthca_tavor_ud_seg);\n\t\tbreak;\n\n\tdefault:\n\t\tmax_data_size -= sizeof (struct mthca_raddr_seg);\n\t\tbreak;\n\t}\n\n\treturn max_data_size;\n}\n\nstatic inline int mthca_max_inline_data(struct mthca_pd *pd, int max_data_size)\n{\n\t \n\treturn pd->ibpd.uobject ? max_data_size - MTHCA_INLINE_HEADER_SIZE : 0;\n}\n\nstatic void mthca_adjust_qp_caps(struct mthca_dev *dev,\n\t\t\t\t struct mthca_pd *pd,\n\t\t\t\t struct mthca_qp *qp)\n{\n\tint max_data_size = mthca_max_data_size(dev, qp,\n\t\t\t\t\t\tmin(dev->limits.max_desc_sz,\n\t\t\t\t\t\t    1 << qp->sq.wqe_shift));\n\n\tqp->max_inline_data = mthca_max_inline_data(pd, max_data_size);\n\n\tqp->sq.max_gs = min_t(int, dev->limits.max_sg,\n\t\t\t      max_data_size / sizeof (struct mthca_data_seg));\n\tqp->rq.max_gs = min_t(int, dev->limits.max_sg,\n\t\t\t       (min(dev->limits.max_desc_sz, 1 << qp->rq.wqe_shift) -\n\t\t\t\tsizeof (struct mthca_next_seg)) /\n\t\t\t       sizeof (struct mthca_data_seg));\n}\n\n \nstatic int mthca_alloc_wqe_buf(struct mthca_dev *dev,\n\t\t\t       struct mthca_pd *pd,\n\t\t\t       struct mthca_qp *qp,\n\t\t\t       struct ib_udata *udata)\n{\n\tint size;\n\tint err = -ENOMEM;\n\n\tsize = sizeof (struct mthca_next_seg) +\n\t\tqp->rq.max_gs * sizeof (struct mthca_data_seg);\n\n\tif (size > dev->limits.max_desc_sz)\n\t\treturn -EINVAL;\n\n\tfor (qp->rq.wqe_shift = 6; 1 << qp->rq.wqe_shift < size;\n\t     qp->rq.wqe_shift++)\n\t\t;  \n\n\tsize = qp->sq.max_gs * sizeof (struct mthca_data_seg);\n\tswitch (qp->transport) {\n\tcase MLX:\n\t\tsize += 2 * sizeof (struct mthca_data_seg);\n\t\tbreak;\n\n\tcase UD:\n\t\tsize += mthca_is_memfree(dev) ?\n\t\t\tsizeof (struct mthca_arbel_ud_seg) :\n\t\t\tsizeof (struct mthca_tavor_ud_seg);\n\t\tbreak;\n\n\tcase UC:\n\t\tsize += sizeof (struct mthca_raddr_seg);\n\t\tbreak;\n\n\tcase RC:\n\t\tsize += sizeof (struct mthca_raddr_seg);\n\t\t \n\t\tsize = max_t(int, size,\n\t\t\t     sizeof (struct mthca_atomic_seg) +\n\t\t\t     sizeof (struct mthca_raddr_seg) +\n\t\t\t     sizeof (struct mthca_data_seg));\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tsize = max_t(int, size, sizeof (struct mthca_bind_seg));\n\n\tsize += sizeof (struct mthca_next_seg);\n\n\tif (size > dev->limits.max_desc_sz)\n\t\treturn -EINVAL;\n\n\tfor (qp->sq.wqe_shift = 6; 1 << qp->sq.wqe_shift < size;\n\t     qp->sq.wqe_shift++)\n\t\t;  \n\n\tqp->send_wqe_offset = ALIGN(qp->rq.max << qp->rq.wqe_shift,\n\t\t\t\t    1 << qp->sq.wqe_shift);\n\n\t \n\tif (udata)\n\t\treturn 0;\n\n\tsize = PAGE_ALIGN(qp->send_wqe_offset +\n\t\t\t  (qp->sq.max << qp->sq.wqe_shift));\n\n\tqp->wrid = kmalloc_array(qp->rq.max + qp->sq.max, sizeof(u64),\n\t\t\t\t GFP_KERNEL);\n\tif (!qp->wrid)\n\t\tgoto err_out;\n\n\terr = mthca_buf_alloc(dev, size, MTHCA_MAX_DIRECT_QP_SIZE,\n\t\t\t      &qp->queue, &qp->is_direct, pd, 0, &qp->mr);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tkfree(qp->wrid);\n\treturn err;\n}\n\nstatic void mthca_free_wqe_buf(struct mthca_dev *dev,\n\t\t\t       struct mthca_qp *qp)\n{\n\tmthca_buf_free(dev, PAGE_ALIGN(qp->send_wqe_offset +\n\t\t\t\t       (qp->sq.max << qp->sq.wqe_shift)),\n\t\t       &qp->queue, qp->is_direct, &qp->mr);\n\tkfree(qp->wrid);\n}\n\nstatic int mthca_map_memfree(struct mthca_dev *dev,\n\t\t\t     struct mthca_qp *qp)\n{\n\tint ret;\n\n\tif (mthca_is_memfree(dev)) {\n\t\tret = mthca_table_get(dev, dev->qp_table.qp_table, qp->qpn);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = mthca_table_get(dev, dev->qp_table.eqp_table, qp->qpn);\n\t\tif (ret)\n\t\t\tgoto err_qpc;\n\n\t\tret = mthca_table_get(dev, dev->qp_table.rdb_table,\n\t\t\t\t      qp->qpn << dev->qp_table.rdb_shift);\n\t\tif (ret)\n\t\t\tgoto err_eqpc;\n\n\t}\n\n\treturn 0;\n\nerr_eqpc:\n\tmthca_table_put(dev, dev->qp_table.eqp_table, qp->qpn);\n\nerr_qpc:\n\tmthca_table_put(dev, dev->qp_table.qp_table, qp->qpn);\n\n\treturn ret;\n}\n\nstatic void mthca_unmap_memfree(struct mthca_dev *dev,\n\t\t\t\tstruct mthca_qp *qp)\n{\n\tmthca_table_put(dev, dev->qp_table.rdb_table,\n\t\t\tqp->qpn << dev->qp_table.rdb_shift);\n\tmthca_table_put(dev, dev->qp_table.eqp_table, qp->qpn);\n\tmthca_table_put(dev, dev->qp_table.qp_table, qp->qpn);\n}\n\nstatic int mthca_alloc_memfree(struct mthca_dev *dev,\n\t\t\t       struct mthca_qp *qp)\n{\n\tif (mthca_is_memfree(dev)) {\n\t\tqp->rq.db_index = mthca_alloc_db(dev, MTHCA_DB_TYPE_RQ,\n\t\t\t\t\t\t qp->qpn, &qp->rq.db);\n\t\tif (qp->rq.db_index < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tqp->sq.db_index = mthca_alloc_db(dev, MTHCA_DB_TYPE_SQ,\n\t\t\t\t\t\t qp->qpn, &qp->sq.db);\n\t\tif (qp->sq.db_index < 0) {\n\t\t\tmthca_free_db(dev, MTHCA_DB_TYPE_RQ, qp->rq.db_index);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mthca_free_memfree(struct mthca_dev *dev,\n\t\t\t       struct mthca_qp *qp)\n{\n\tif (mthca_is_memfree(dev)) {\n\t\tmthca_free_db(dev, MTHCA_DB_TYPE_SQ, qp->sq.db_index);\n\t\tmthca_free_db(dev, MTHCA_DB_TYPE_RQ, qp->rq.db_index);\n\t}\n}\n\nstatic int mthca_alloc_qp_common(struct mthca_dev *dev,\n\t\t\t\t struct mthca_pd *pd,\n\t\t\t\t struct mthca_cq *send_cq,\n\t\t\t\t struct mthca_cq *recv_cq,\n\t\t\t\t enum ib_sig_type send_policy,\n\t\t\t\t struct mthca_qp *qp,\n\t\t\t\t struct ib_udata *udata)\n{\n\tint ret;\n\tint i;\n\tstruct mthca_next_seg *next;\n\n\tqp->refcount = 1;\n\tinit_waitqueue_head(&qp->wait);\n\tmutex_init(&qp->mutex);\n\tqp->state    \t = IB_QPS_RESET;\n\tqp->atomic_rd_en = 0;\n\tqp->resp_depth   = 0;\n\tqp->sq_policy    = send_policy;\n\tmthca_wq_reset(&qp->sq);\n\tmthca_wq_reset(&qp->rq);\n\n\tspin_lock_init(&qp->sq.lock);\n\tspin_lock_init(&qp->rq.lock);\n\n\tret = mthca_map_memfree(dev, qp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mthca_alloc_wqe_buf(dev, pd, qp, udata);\n\tif (ret) {\n\t\tmthca_unmap_memfree(dev, qp);\n\t\treturn ret;\n\t}\n\n\tmthca_adjust_qp_caps(dev, pd, qp);\n\n\t \n\tif (udata)\n\t\treturn 0;\n\n\tret = mthca_alloc_memfree(dev, qp);\n\tif (ret) {\n\t\tmthca_free_wqe_buf(dev, qp);\n\t\tmthca_unmap_memfree(dev, qp);\n\t\treturn ret;\n\t}\n\n\tif (mthca_is_memfree(dev)) {\n\t\tstruct mthca_data_seg *scatter;\n\t\tint size = (sizeof (struct mthca_next_seg) +\n\t\t\t    qp->rq.max_gs * sizeof (struct mthca_data_seg)) / 16;\n\n\t\tfor (i = 0; i < qp->rq.max; ++i) {\n\t\t\tnext = get_recv_wqe(qp, i);\n\t\t\tnext->nda_op = cpu_to_be32(((i + 1) & (qp->rq.max - 1)) <<\n\t\t\t\t\t\t   qp->rq.wqe_shift);\n\t\t\tnext->ee_nds = cpu_to_be32(size);\n\n\t\t\tfor (scatter = (void *) (next + 1);\n\t\t\t     (void *) scatter < (void *) next + (1 << qp->rq.wqe_shift);\n\t\t\t     ++scatter)\n\t\t\t\tscatter->lkey = cpu_to_be32(MTHCA_INVAL_LKEY);\n\t\t}\n\n\t\tfor (i = 0; i < qp->sq.max; ++i) {\n\t\t\tnext = get_send_wqe(qp, i);\n\t\t\tnext->nda_op = cpu_to_be32((((i + 1) & (qp->sq.max - 1)) <<\n\t\t\t\t\t\t    qp->sq.wqe_shift) +\n\t\t\t\t\t\t   qp->send_wqe_offset);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < qp->rq.max; ++i) {\n\t\t\tnext = get_recv_wqe(qp, i);\n\t\t\tnext->nda_op = htonl((((i + 1) % qp->rq.max) <<\n\t\t\t\t\t      qp->rq.wqe_shift) | 1);\n\t\t}\n\n\t}\n\n\tqp->sq.last = get_send_wqe(qp, qp->sq.max - 1);\n\tqp->rq.last = get_recv_wqe(qp, qp->rq.max - 1);\n\n\treturn 0;\n}\n\nstatic int mthca_set_qp_size(struct mthca_dev *dev, struct ib_qp_cap *cap,\n\t\t\t     struct mthca_pd *pd, struct mthca_qp *qp)\n{\n\tint max_data_size = mthca_max_data_size(dev, qp, dev->limits.max_desc_sz);\n\n\t \n\tif (cap->max_send_wr  \t > dev->limits.max_wqes ||\n\t    cap->max_recv_wr  \t > dev->limits.max_wqes ||\n\t    cap->max_send_sge \t > dev->limits.max_sg   ||\n\t    cap->max_recv_sge \t > dev->limits.max_sg   ||\n\t    cap->max_inline_data > mthca_max_inline_data(pd, max_data_size))\n\t\treturn -EINVAL;\n\n\t \n\tif (qp->transport == MLX && cap->max_send_sge + 2 > dev->limits.max_sg)\n\t\treturn -EINVAL;\n\n\tif (mthca_is_memfree(dev)) {\n\t\tqp->rq.max = cap->max_recv_wr ?\n\t\t\troundup_pow_of_two(cap->max_recv_wr) : 0;\n\t\tqp->sq.max = cap->max_send_wr ?\n\t\t\troundup_pow_of_two(cap->max_send_wr) : 0;\n\t} else {\n\t\tqp->rq.max = cap->max_recv_wr;\n\t\tqp->sq.max = cap->max_send_wr;\n\t}\n\n\tqp->rq.max_gs = cap->max_recv_sge;\n\tqp->sq.max_gs = max_t(int, cap->max_send_sge,\n\t\t\t      ALIGN(cap->max_inline_data + MTHCA_INLINE_HEADER_SIZE,\n\t\t\t\t    MTHCA_INLINE_CHUNK_SIZE) /\n\t\t\t      sizeof (struct mthca_data_seg));\n\n\treturn 0;\n}\n\nint mthca_alloc_qp(struct mthca_dev *dev,\n\t\t   struct mthca_pd *pd,\n\t\t   struct mthca_cq *send_cq,\n\t\t   struct mthca_cq *recv_cq,\n\t\t   enum ib_qp_type type,\n\t\t   enum ib_sig_type send_policy,\n\t\t   struct ib_qp_cap *cap,\n\t\t   struct mthca_qp *qp,\n\t\t   struct ib_udata *udata)\n{\n\tint err;\n\n\tswitch (type) {\n\tcase IB_QPT_RC: qp->transport = RC; break;\n\tcase IB_QPT_UC: qp->transport = UC; break;\n\tcase IB_QPT_UD: qp->transport = UD; break;\n\tdefault: return -EINVAL;\n\t}\n\n\terr = mthca_set_qp_size(dev, cap, pd, qp);\n\tif (err)\n\t\treturn err;\n\n\tqp->qpn = mthca_alloc(&dev->qp_table.alloc);\n\tif (qp->qpn == -1)\n\t\treturn -ENOMEM;\n\n\t \n\tqp->port = 0;\n\n\terr = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq,\n\t\t\t\t    send_policy, qp, udata);\n\tif (err) {\n\t\tmthca_free(&dev->qp_table.alloc, qp->qpn);\n\t\treturn err;\n\t}\n\n\tspin_lock_irq(&dev->qp_table.lock);\n\tmthca_array_set(&dev->qp_table.qp,\n\t\t\tqp->qpn & (dev->limits.num_qps - 1), qp);\n\tspin_unlock_irq(&dev->qp_table.lock);\n\n\treturn 0;\n}\n\nstatic void mthca_lock_cqs(struct mthca_cq *send_cq, struct mthca_cq *recv_cq)\n\t__acquires(&send_cq->lock) __acquires(&recv_cq->lock)\n{\n\tif (send_cq == recv_cq) {\n\t\tspin_lock_irq(&send_cq->lock);\n\t\t__acquire(&recv_cq->lock);\n\t} else if (send_cq->cqn < recv_cq->cqn) {\n\t\tspin_lock_irq(&send_cq->lock);\n\t\tspin_lock_nested(&recv_cq->lock, SINGLE_DEPTH_NESTING);\n\t} else {\n\t\tspin_lock_irq(&recv_cq->lock);\n\t\tspin_lock_nested(&send_cq->lock, SINGLE_DEPTH_NESTING);\n\t}\n}\n\nstatic void mthca_unlock_cqs(struct mthca_cq *send_cq, struct mthca_cq *recv_cq)\n\t__releases(&send_cq->lock) __releases(&recv_cq->lock)\n{\n\tif (send_cq == recv_cq) {\n\t\t__release(&recv_cq->lock);\n\t\tspin_unlock_irq(&send_cq->lock);\n\t} else if (send_cq->cqn < recv_cq->cqn) {\n\t\tspin_unlock(&recv_cq->lock);\n\t\tspin_unlock_irq(&send_cq->lock);\n\t} else {\n\t\tspin_unlock(&send_cq->lock);\n\t\tspin_unlock_irq(&recv_cq->lock);\n\t}\n}\n\nint mthca_alloc_sqp(struct mthca_dev *dev,\n\t\t    struct mthca_pd *pd,\n\t\t    struct mthca_cq *send_cq,\n\t\t    struct mthca_cq *recv_cq,\n\t\t    enum ib_sig_type send_policy,\n\t\t    struct ib_qp_cap *cap,\n\t\t    int qpn,\n\t\t    u32 port,\n\t\t    struct mthca_qp *qp,\n\t\t    struct ib_udata *udata)\n{\n\tu32 mqpn = qpn * 2 + dev->qp_table.sqp_start + port - 1;\n\tint err;\n\n\tqp->transport = MLX;\n\terr = mthca_set_qp_size(dev, cap, pd, qp);\n\tif (err)\n\t\treturn err;\n\n\tqp->sqp->header_buf_size = qp->sq.max * MTHCA_UD_HEADER_SIZE;\n\tqp->sqp->header_buf =\n\t\tdma_alloc_coherent(&dev->pdev->dev, qp->sqp->header_buf_size,\n\t\t\t\t   &qp->sqp->header_dma, GFP_KERNEL);\n\tif (!qp->sqp->header_buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irq(&dev->qp_table.lock);\n\tif (mthca_array_get(&dev->qp_table.qp, mqpn))\n\t\terr = -EBUSY;\n\telse\n\t\tmthca_array_set(&dev->qp_table.qp, mqpn, qp);\n\tspin_unlock_irq(&dev->qp_table.lock);\n\n\tif (err)\n\t\tgoto err_out;\n\n\tqp->port      = port;\n\tqp->qpn       = mqpn;\n\tqp->transport = MLX;\n\n\terr = mthca_alloc_qp_common(dev, pd, send_cq, recv_cq,\n\t\t\t\t    send_policy, qp, udata);\n\tif (err)\n\t\tgoto err_out_free;\n\n\tatomic_inc(&pd->sqp_count);\n\n\treturn 0;\n\n err_out_free:\n\t \n\tmthca_lock_cqs(send_cq, recv_cq);\n\n\tspin_lock(&dev->qp_table.lock);\n\tmthca_array_clear(&dev->qp_table.qp, mqpn);\n\tspin_unlock(&dev->qp_table.lock);\n\n\tmthca_unlock_cqs(send_cq, recv_cq);\n\nerr_out:\n\tdma_free_coherent(&dev->pdev->dev, qp->sqp->header_buf_size,\n\t\t\t  qp->sqp->header_buf, qp->sqp->header_dma);\n\treturn err;\n}\n\nstatic inline int get_qp_refcount(struct mthca_dev *dev, struct mthca_qp *qp)\n{\n\tint c;\n\n\tspin_lock_irq(&dev->qp_table.lock);\n\tc = qp->refcount;\n\tspin_unlock_irq(&dev->qp_table.lock);\n\n\treturn c;\n}\n\nvoid mthca_free_qp(struct mthca_dev *dev,\n\t\t   struct mthca_qp *qp)\n{\n\tstruct mthca_cq *send_cq;\n\tstruct mthca_cq *recv_cq;\n\n\tsend_cq = to_mcq(qp->ibqp.send_cq);\n\trecv_cq = to_mcq(qp->ibqp.recv_cq);\n\n\t \n\tmthca_lock_cqs(send_cq, recv_cq);\n\n\tspin_lock(&dev->qp_table.lock);\n\tmthca_array_clear(&dev->qp_table.qp,\n\t\t\t  qp->qpn & (dev->limits.num_qps - 1));\n\t--qp->refcount;\n\tspin_unlock(&dev->qp_table.lock);\n\n\tmthca_unlock_cqs(send_cq, recv_cq);\n\n\twait_event(qp->wait, !get_qp_refcount(dev, qp));\n\n\tif (qp->state != IB_QPS_RESET)\n\t\tmthca_MODIFY_QP(dev, qp->state, IB_QPS_RESET, qp->qpn, 0,\n\t\t\t\tNULL, 0);\n\n\t \n\tif (!qp->ibqp.uobject) {\n\t\tmthca_cq_clean(dev, recv_cq, qp->qpn,\n\t\t\t       qp->ibqp.srq ? to_msrq(qp->ibqp.srq) : NULL);\n\t\tif (send_cq != recv_cq)\n\t\t\tmthca_cq_clean(dev, send_cq, qp->qpn, NULL);\n\n\t\tmthca_free_memfree(dev, qp);\n\t\tmthca_free_wqe_buf(dev, qp);\n\t}\n\n\tmthca_unmap_memfree(dev, qp);\n\n\tif (is_sqp(dev, qp)) {\n\t\tatomic_dec(&(to_mpd(qp->ibqp.pd)->sqp_count));\n\t\tdma_free_coherent(&dev->pdev->dev, qp->sqp->header_buf_size,\n\t\t\t\t  qp->sqp->header_buf, qp->sqp->header_dma);\n\t} else\n\t\tmthca_free(&dev->qp_table.alloc, qp->qpn);\n}\n\n \nstatic int build_mlx_header(struct mthca_dev *dev, struct mthca_qp *qp, int ind,\n\t\t\t    const struct ib_ud_wr *wr,\n\t\t\t    struct mthca_mlx_seg *mlx,\n\t\t\t    struct mthca_data_seg *data)\n{\n\tstruct mthca_sqp *sqp = qp->sqp;\n\tint header_size;\n\tint err;\n\tu16 pkey;\n\n\tib_ud_header_init(256,   1, 0, 0,\n\t\t\t  mthca_ah_grh_present(to_mah(wr->ah)), 0, 0, 0,\n\t\t\t  &sqp->ud_header);\n\n\terr = mthca_read_ah(dev, to_mah(wr->ah), &sqp->ud_header);\n\tif (err)\n\t\treturn err;\n\tmlx->flags &= ~cpu_to_be32(MTHCA_NEXT_SOLICIT | 1);\n\tmlx->flags |= cpu_to_be32((!qp->ibqp.qp_num ? MTHCA_MLX_VL15 : 0) |\n\t\t\t\t  (sqp->ud_header.lrh.destination_lid ==\n\t\t\t\t   IB_LID_PERMISSIVE ? MTHCA_MLX_SLR : 0) |\n\t\t\t\t  (sqp->ud_header.lrh.service_level << 8));\n\tmlx->rlid = sqp->ud_header.lrh.destination_lid;\n\tmlx->vcrc = 0;\n\n\tswitch (wr->wr.opcode) {\n\tcase IB_WR_SEND:\n\t\tsqp->ud_header.bth.opcode = IB_OPCODE_UD_SEND_ONLY;\n\t\tsqp->ud_header.immediate_present = 0;\n\t\tbreak;\n\tcase IB_WR_SEND_WITH_IMM:\n\t\tsqp->ud_header.bth.opcode = IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE;\n\t\tsqp->ud_header.immediate_present = 1;\n\t\tsqp->ud_header.immediate_data = wr->wr.ex.imm_data;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsqp->ud_header.lrh.virtual_lane    = !qp->ibqp.qp_num ? 15 : 0;\n\tif (sqp->ud_header.lrh.destination_lid == IB_LID_PERMISSIVE)\n\t\tsqp->ud_header.lrh.source_lid = IB_LID_PERMISSIVE;\n\tsqp->ud_header.bth.solicited_event = !!(wr->wr.send_flags & IB_SEND_SOLICITED);\n\tif (!qp->ibqp.qp_num)\n\t\tib_get_cached_pkey(&dev->ib_dev, qp->port, sqp->pkey_index,\n\t\t\t\t   &pkey);\n\telse\n\t\tib_get_cached_pkey(&dev->ib_dev, qp->port, wr->pkey_index,\n\t\t\t\t   &pkey);\n\tsqp->ud_header.bth.pkey = cpu_to_be16(pkey);\n\tsqp->ud_header.bth.destination_qpn = cpu_to_be32(wr->remote_qpn);\n\tsqp->ud_header.bth.psn = cpu_to_be32((sqp->send_psn++) & ((1 << 24) - 1));\n\tsqp->ud_header.deth.qkey = cpu_to_be32(wr->remote_qkey & 0x80000000 ?\n\t\t\t\t\t       sqp->qkey : wr->remote_qkey);\n\tsqp->ud_header.deth.source_qpn = cpu_to_be32(qp->ibqp.qp_num);\n\n\theader_size = ib_ud_header_pack(&sqp->ud_header,\n\t\t\t\t\tsqp->header_buf +\n\t\t\t\t\tind * MTHCA_UD_HEADER_SIZE);\n\n\tdata->byte_count = cpu_to_be32(header_size);\n\tdata->lkey       = cpu_to_be32(to_mpd(qp->ibqp.pd)->ntmr.ibmr.lkey);\n\tdata->addr       = cpu_to_be64(sqp->header_dma +\n\t\t\t\t       ind * MTHCA_UD_HEADER_SIZE);\n\n\treturn 0;\n}\n\nstatic inline int mthca_wq_overflow(struct mthca_wq *wq, int nreq,\n\t\t\t\t    struct ib_cq *ib_cq)\n{\n\tunsigned cur;\n\tstruct mthca_cq *cq;\n\n\tcur = wq->head - wq->tail;\n\tif (likely(cur + nreq < wq->max))\n\t\treturn 0;\n\n\tcq = to_mcq(ib_cq);\n\tspin_lock(&cq->lock);\n\tcur = wq->head - wq->tail;\n\tspin_unlock(&cq->lock);\n\n\treturn cur + nreq >= wq->max;\n}\n\nstatic __always_inline void set_raddr_seg(struct mthca_raddr_seg *rseg,\n\t\t\t\t\t  u64 remote_addr, u32 rkey)\n{\n\trseg->raddr    = cpu_to_be64(remote_addr);\n\trseg->rkey     = cpu_to_be32(rkey);\n\trseg->reserved = 0;\n}\n\nstatic __always_inline void set_atomic_seg(struct mthca_atomic_seg *aseg,\n\t\t\t\t\t   const struct ib_atomic_wr *wr)\n{\n\tif (wr->wr.opcode == IB_WR_ATOMIC_CMP_AND_SWP) {\n\t\taseg->swap_add = cpu_to_be64(wr->swap);\n\t\taseg->compare  = cpu_to_be64(wr->compare_add);\n\t} else {\n\t\taseg->swap_add = cpu_to_be64(wr->compare_add);\n\t\taseg->compare  = 0;\n\t}\n\n}\n\nstatic void set_tavor_ud_seg(struct mthca_tavor_ud_seg *useg,\n\t\t\t     const struct ib_ud_wr *wr)\n{\n\tuseg->lkey    = cpu_to_be32(to_mah(wr->ah)->key);\n\tuseg->av_addr =\tcpu_to_be64(to_mah(wr->ah)->avdma);\n\tuseg->dqpn    =\tcpu_to_be32(wr->remote_qpn);\n\tuseg->qkey    =\tcpu_to_be32(wr->remote_qkey);\n\n}\n\nstatic void set_arbel_ud_seg(struct mthca_arbel_ud_seg *useg,\n\t\t\t     const struct ib_ud_wr *wr)\n{\n\tmemcpy(useg->av, to_mah(wr->ah)->av, MTHCA_AV_SIZE);\n\tuseg->dqpn = cpu_to_be32(wr->remote_qpn);\n\tuseg->qkey = cpu_to_be32(wr->remote_qkey);\n}\n\nint mthca_tavor_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t\t  const struct ib_send_wr **bad_wr)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tvoid *wqe;\n\tvoid *prev_wqe;\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint i;\n\tint size;\n\t \n\tint size0;\n\tu32 f0;\n\tint ind;\n\tu8 op0 = 0;\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\n\t \n\n\tind = qp->sq.next_ind;\n\n\tfor (nreq = 0; wr; ++nreq, wr = wr->next) {\n\t\tif (mthca_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)) {\n\t\t\tmthca_err(dev, \"SQ %06x full (%u head, %u tail,\"\n\t\t\t\t\t\" %d max, %d nreq)\\n\", qp->qpn,\n\t\t\t\t\tqp->sq.head, qp->sq.tail,\n\t\t\t\t\tqp->sq.max, nreq);\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\twqe = get_send_wqe(qp, ind);\n\t\tprev_wqe = qp->sq.last;\n\t\tqp->sq.last = wqe;\n\n\t\t((struct mthca_next_seg *) wqe)->nda_op = 0;\n\t\t((struct mthca_next_seg *) wqe)->ee_nds = 0;\n\t\t((struct mthca_next_seg *) wqe)->flags =\n\t\t\t((wr->send_flags & IB_SEND_SIGNALED) ?\n\t\t\t cpu_to_be32(MTHCA_NEXT_CQ_UPDATE) : 0) |\n\t\t\t((wr->send_flags & IB_SEND_SOLICITED) ?\n\t\t\t cpu_to_be32(MTHCA_NEXT_SOLICIT) : 0)   |\n\t\t\tcpu_to_be32(1);\n\t\tif (wr->opcode == IB_WR_SEND_WITH_IMM ||\n\t\t    wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM)\n\t\t\t((struct mthca_next_seg *) wqe)->imm = wr->ex.imm_data;\n\n\t\twqe += sizeof (struct mthca_next_seg);\n\t\tsize = sizeof (struct mthca_next_seg) / 16;\n\n\t\tswitch (qp->transport) {\n\t\tcase RC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\t\tset_raddr_seg(wqe, atomic_wr(wr)->remote_addr,\n\t\t\t\t\t      atomic_wr(wr)->rkey);\n\t\t\t\twqe += sizeof (struct mthca_raddr_seg);\n\n\t\t\t\tset_atomic_seg(wqe, atomic_wr(wr));\n\t\t\t\twqe += sizeof (struct mthca_atomic_seg);\n\t\t\t\tsize += (sizeof (struct mthca_raddr_seg) +\n\t\t\t\t\t sizeof (struct mthca_atomic_seg)) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\tcase IB_WR_RDMA_READ:\n\t\t\t\tset_raddr_seg(wqe, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mthca_raddr_seg);\n\t\t\t\tsize += sizeof (struct mthca_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase UC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(wqe, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mthca_raddr_seg);\n\t\t\t\tsize += sizeof (struct mthca_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase UD:\n\t\t\tset_tavor_ud_seg(wqe, ud_wr(wr));\n\t\t\twqe  += sizeof (struct mthca_tavor_ud_seg);\n\t\t\tsize += sizeof (struct mthca_tavor_ud_seg) / 16;\n\t\t\tbreak;\n\n\t\tcase MLX:\n\t\t\terr = build_mlx_header(\n\t\t\t\tdev, qp, ind, ud_wr(wr),\n\t\t\t\twqe - sizeof(struct mthca_next_seg), wqe);\n\t\t\tif (err) {\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twqe += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wr->num_sge > qp->sq.max_gs) {\n\t\t\tmthca_err(dev, \"too many gathers\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < wr->num_sge; ++i) {\n\t\t\tmthca_set_data_seg(wqe, wr->sg_list + i);\n\t\t\twqe  += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t}\n\n\t\t \n\t\tif (qp->transport == MLX) {\n\t\t\t((struct mthca_data_seg *) wqe)->byte_count =\n\t\t\t\tcpu_to_be32((1 << 31) | 4);\n\t\t\t((u32 *) wqe)[1] = 0;\n\t\t\twqe += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t}\n\n\t\tqp->wrid[ind + qp->rq.max] = wr->wr_id;\n\n\t\tif (wr->opcode >= ARRAY_SIZE(mthca_opcode)) {\n\t\t\tmthca_err(dev, \"opcode invalid\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\t((struct mthca_next_seg *) prev_wqe)->nda_op =\n\t\t\tcpu_to_be32(((ind << qp->sq.wqe_shift) +\n\t\t\t\t     qp->send_wqe_offset) |\n\t\t\t\t    mthca_opcode[wr->opcode]);\n\t\twmb();\n\t\t((struct mthca_next_seg *) prev_wqe)->ee_nds =\n\t\t\tcpu_to_be32((nreq ? 0 : MTHCA_NEXT_DBD) | size |\n\t\t\t\t    ((wr->send_flags & IB_SEND_FENCE) ?\n\t\t\t\t    MTHCA_NEXT_FENCE : 0));\n\n\t\tif (!nreq) {\n\t\t\tsize0 = size;\n\t\t\top0   = mthca_opcode[wr->opcode];\n\t\t\tf0    = wr->send_flags & IB_SEND_FENCE ?\n\t\t\t\tMTHCA_SEND_DOORBELL_FENCE : 0;\n\t\t}\n\n\t\t++ind;\n\t\tif (unlikely(ind >= qp->sq.max))\n\t\t\tind -= qp->sq.max;\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\twmb();\n\n\t\tmthca_write64(((qp->sq.next_ind << qp->sq.wqe_shift) +\n\t\t\t       qp->send_wqe_offset) | f0 | op0,\n\t\t\t      (qp->qpn << 8) | size0,\n\t\t\t      dev->kar + MTHCA_SEND_DOORBELL,\n\t\t\t      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\n\t}\n\n\tqp->sq.next_ind = ind;\n\tqp->sq.head    += nreq;\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\treturn err;\n}\n\nint mthca_tavor_post_receive(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t\t     const struct ib_recv_wr **bad_wr)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint i;\n\tint size;\n\t \n\tint size0;\n\tint ind;\n\tvoid *wqe;\n\tvoid *prev_wqe;\n\n\tspin_lock_irqsave(&qp->rq.lock, flags);\n\n\t \n\n\tind = qp->rq.next_ind;\n\n\tfor (nreq = 0; wr; wr = wr->next) {\n\t\tif (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\n\t\t\tmthca_err(dev, \"RQ %06x full (%u head, %u tail,\"\n\t\t\t\t\t\" %d max, %d nreq)\\n\", qp->qpn,\n\t\t\t\t\tqp->rq.head, qp->rq.tail,\n\t\t\t\t\tqp->rq.max, nreq);\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\twqe = get_recv_wqe(qp, ind);\n\t\tprev_wqe = qp->rq.last;\n\t\tqp->rq.last = wqe;\n\n\t\t((struct mthca_next_seg *) wqe)->ee_nds =\n\t\t\tcpu_to_be32(MTHCA_NEXT_DBD);\n\t\t((struct mthca_next_seg *) wqe)->flags = 0;\n\n\t\twqe += sizeof (struct mthca_next_seg);\n\t\tsize = sizeof (struct mthca_next_seg) / 16;\n\n\t\tif (unlikely(wr->num_sge > qp->rq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < wr->num_sge; ++i) {\n\t\t\tmthca_set_data_seg(wqe, wr->sg_list + i);\n\t\t\twqe  += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t}\n\n\t\tqp->wrid[ind] = wr->wr_id;\n\n\t\t((struct mthca_next_seg *) prev_wqe)->ee_nds =\n\t\t\tcpu_to_be32(MTHCA_NEXT_DBD | size);\n\n\t\tif (!nreq)\n\t\t\tsize0 = size;\n\n\t\t++ind;\n\t\tif (unlikely(ind >= qp->rq.max))\n\t\t\tind -= qp->rq.max;\n\n\t\t++nreq;\n\t\tif (unlikely(nreq == MTHCA_TAVOR_MAX_WQES_PER_RECV_DB)) {\n\t\t\tnreq = 0;\n\n\t\t\twmb();\n\n\t\t\tmthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | size0,\n\t\t\t\t      qp->qpn << 8, dev->kar + MTHCA_RECEIVE_DOORBELL,\n\t\t\t\t      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\n\n\t\t\tqp->rq.next_ind = ind;\n\t\t\tqp->rq.head += MTHCA_TAVOR_MAX_WQES_PER_RECV_DB;\n\t\t}\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\twmb();\n\n\t\tmthca_write64((qp->rq.next_ind << qp->rq.wqe_shift) | size0,\n\t\t\t      qp->qpn << 8 | nreq, dev->kar + MTHCA_RECEIVE_DOORBELL,\n\t\t\t      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\n\t}\n\n\tqp->rq.next_ind = ind;\n\tqp->rq.head    += nreq;\n\n\tspin_unlock_irqrestore(&qp->rq.lock, flags);\n\treturn err;\n}\n\nint mthca_arbel_post_send(struct ib_qp *ibqp, const struct ib_send_wr *wr,\n\t\t\t  const struct ib_send_wr **bad_wr)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tu32 dbhi;\n\tvoid *wqe;\n\tvoid *prev_wqe;\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint i;\n\tint size;\n\t \n\tint size0;\n\tu32 f0;\n\tint ind;\n\tu8 op0 = 0;\n\n\tspin_lock_irqsave(&qp->sq.lock, flags);\n\n\t \n\n\tind = qp->sq.head & (qp->sq.max - 1);\n\n\tfor (nreq = 0; wr; ++nreq, wr = wr->next) {\n\t\tif (unlikely(nreq == MTHCA_ARBEL_MAX_WQES_PER_SEND_DB)) {\n\t\t\tnreq = 0;\n\n\t\t\tdbhi = (MTHCA_ARBEL_MAX_WQES_PER_SEND_DB << 24) |\n\t\t\t\t((qp->sq.head & 0xffff) << 8) | f0 | op0;\n\n\t\t\tqp->sq.head += MTHCA_ARBEL_MAX_WQES_PER_SEND_DB;\n\n\t\t\t \n\t\t\twmb();\n\t\t\t*qp->sq.db = cpu_to_be32(qp->sq.head & 0xffff);\n\n\t\t\t \n\t\t\twmb();\n\n\t\t\tmthca_write64(dbhi, (qp->qpn << 8) | size0,\n\t\t\t\t      dev->kar + MTHCA_SEND_DOORBELL,\n\t\t\t\t      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\n\t\t}\n\n\t\tif (mthca_wq_overflow(&qp->sq, nreq, qp->ibqp.send_cq)) {\n\t\t\tmthca_err(dev, \"SQ %06x full (%u head, %u tail,\"\n\t\t\t\t\t\" %d max, %d nreq)\\n\", qp->qpn,\n\t\t\t\t\tqp->sq.head, qp->sq.tail,\n\t\t\t\t\tqp->sq.max, nreq);\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\twqe = get_send_wqe(qp, ind);\n\t\tprev_wqe = qp->sq.last;\n\t\tqp->sq.last = wqe;\n\n\t\t((struct mthca_next_seg *) wqe)->flags =\n\t\t\t((wr->send_flags & IB_SEND_SIGNALED) ?\n\t\t\t cpu_to_be32(MTHCA_NEXT_CQ_UPDATE) : 0) |\n\t\t\t((wr->send_flags & IB_SEND_SOLICITED) ?\n\t\t\t cpu_to_be32(MTHCA_NEXT_SOLICIT) : 0)   |\n\t\t\t((wr->send_flags & IB_SEND_IP_CSUM) ?\n\t\t\t cpu_to_be32(MTHCA_NEXT_IP_CSUM | MTHCA_NEXT_TCP_UDP_CSUM) : 0) |\n\t\t\tcpu_to_be32(1);\n\t\tif (wr->opcode == IB_WR_SEND_WITH_IMM ||\n\t\t    wr->opcode == IB_WR_RDMA_WRITE_WITH_IMM)\n\t\t\t((struct mthca_next_seg *) wqe)->imm = wr->ex.imm_data;\n\n\t\twqe += sizeof (struct mthca_next_seg);\n\t\tsize = sizeof (struct mthca_next_seg) / 16;\n\n\t\tswitch (qp->transport) {\n\t\tcase RC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_ATOMIC_CMP_AND_SWP:\n\t\t\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\n\t\t\t\tset_raddr_seg(wqe, atomic_wr(wr)->remote_addr,\n\t\t\t\t\t      atomic_wr(wr)->rkey);\n\t\t\t\twqe += sizeof (struct mthca_raddr_seg);\n\n\t\t\t\tset_atomic_seg(wqe, atomic_wr(wr));\n\t\t\t\twqe  += sizeof (struct mthca_atomic_seg);\n\t\t\t\tsize += (sizeof (struct mthca_raddr_seg) +\n\t\t\t\t\t sizeof (struct mthca_atomic_seg)) / 16;\n\t\t\t\tbreak;\n\n\t\t\tcase IB_WR_RDMA_READ:\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(wqe, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mthca_raddr_seg);\n\t\t\t\tsize += sizeof (struct mthca_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase UC:\n\t\t\tswitch (wr->opcode) {\n\t\t\tcase IB_WR_RDMA_WRITE:\n\t\t\tcase IB_WR_RDMA_WRITE_WITH_IMM:\n\t\t\t\tset_raddr_seg(wqe, rdma_wr(wr)->remote_addr,\n\t\t\t\t\t      rdma_wr(wr)->rkey);\n\t\t\t\twqe  += sizeof (struct mthca_raddr_seg);\n\t\t\t\tsize += sizeof (struct mthca_raddr_seg) / 16;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase UD:\n\t\t\tset_arbel_ud_seg(wqe, ud_wr(wr));\n\t\t\twqe  += sizeof (struct mthca_arbel_ud_seg);\n\t\t\tsize += sizeof (struct mthca_arbel_ud_seg) / 16;\n\t\t\tbreak;\n\n\t\tcase MLX:\n\t\t\terr = build_mlx_header(\n\t\t\t\tdev, qp, ind, ud_wr(wr),\n\t\t\t\twqe - sizeof(struct mthca_next_seg), wqe);\n\t\t\tif (err) {\n\t\t\t\t*bad_wr = wr;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twqe += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wr->num_sge > qp->sq.max_gs) {\n\t\t\tmthca_err(dev, \"too many gathers\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < wr->num_sge; ++i) {\n\t\t\tmthca_set_data_seg(wqe, wr->sg_list + i);\n\t\t\twqe  += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t}\n\n\t\t \n\t\tif (qp->transport == MLX) {\n\t\t\t((struct mthca_data_seg *) wqe)->byte_count =\n\t\t\t\tcpu_to_be32((1 << 31) | 4);\n\t\t\t((u32 *) wqe)[1] = 0;\n\t\t\twqe += sizeof (struct mthca_data_seg);\n\t\t\tsize += sizeof (struct mthca_data_seg) / 16;\n\t\t}\n\n\t\tqp->wrid[ind + qp->rq.max] = wr->wr_id;\n\n\t\tif (wr->opcode >= ARRAY_SIZE(mthca_opcode)) {\n\t\t\tmthca_err(dev, \"opcode invalid\\n\");\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\t((struct mthca_next_seg *) prev_wqe)->nda_op =\n\t\t\tcpu_to_be32(((ind << qp->sq.wqe_shift) +\n\t\t\t\t     qp->send_wqe_offset) |\n\t\t\t\t    mthca_opcode[wr->opcode]);\n\t\twmb();\n\t\t((struct mthca_next_seg *) prev_wqe)->ee_nds =\n\t\t\tcpu_to_be32(MTHCA_NEXT_DBD | size |\n\t\t\t\t    ((wr->send_flags & IB_SEND_FENCE) ?\n\t\t\t\t     MTHCA_NEXT_FENCE : 0));\n\n\t\tif (!nreq) {\n\t\t\tsize0 = size;\n\t\t\top0   = mthca_opcode[wr->opcode];\n\t\t\tf0    = wr->send_flags & IB_SEND_FENCE ?\n\t\t\t\tMTHCA_SEND_DOORBELL_FENCE : 0;\n\t\t}\n\n\t\t++ind;\n\t\tif (unlikely(ind >= qp->sq.max))\n\t\t\tind -= qp->sq.max;\n\t}\n\nout:\n\tif (likely(nreq)) {\n\t\tdbhi = (nreq << 24) | ((qp->sq.head & 0xffff) << 8) | f0 | op0;\n\n\t\tqp->sq.head += nreq;\n\n\t\t \n\t\twmb();\n\t\t*qp->sq.db = cpu_to_be32(qp->sq.head & 0xffff);\n\n\t\t \n\t\twmb();\n\n\t\tmthca_write64(dbhi, (qp->qpn << 8) | size0, dev->kar + MTHCA_SEND_DOORBELL,\n\t\t\t      MTHCA_GET_DOORBELL_LOCK(&dev->doorbell_lock));\n\t}\n\n\tspin_unlock_irqrestore(&qp->sq.lock, flags);\n\treturn err;\n}\n\nint mthca_arbel_post_receive(struct ib_qp *ibqp, const struct ib_recv_wr *wr,\n\t\t\t     const struct ib_recv_wr **bad_wr)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_qp *qp = to_mqp(ibqp);\n\tunsigned long flags;\n\tint err = 0;\n\tint nreq;\n\tint ind;\n\tint i;\n\tvoid *wqe;\n\n\tspin_lock_irqsave(&qp->rq.lock, flags);\n\n\t \n\n\tind = qp->rq.head & (qp->rq.max - 1);\n\n\tfor (nreq = 0; wr; ++nreq, wr = wr->next) {\n\t\tif (mthca_wq_overflow(&qp->rq, nreq, qp->ibqp.recv_cq)) {\n\t\t\tmthca_err(dev, \"RQ %06x full (%u head, %u tail,\"\n\t\t\t\t\t\" %d max, %d nreq)\\n\", qp->qpn,\n\t\t\t\t\tqp->rq.head, qp->rq.tail,\n\t\t\t\t\tqp->rq.max, nreq);\n\t\t\terr = -ENOMEM;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\twqe = get_recv_wqe(qp, ind);\n\n\t\t((struct mthca_next_seg *) wqe)->flags = 0;\n\n\t\twqe += sizeof (struct mthca_next_seg);\n\n\t\tif (unlikely(wr->num_sge > qp->rq.max_gs)) {\n\t\t\terr = -EINVAL;\n\t\t\t*bad_wr = wr;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfor (i = 0; i < wr->num_sge; ++i) {\n\t\t\tmthca_set_data_seg(wqe, wr->sg_list + i);\n\t\t\twqe += sizeof (struct mthca_data_seg);\n\t\t}\n\n\t\tif (i < qp->rq.max_gs)\n\t\t\tmthca_set_data_seg_inval(wqe);\n\n\t\tqp->wrid[ind] = wr->wr_id;\n\n\t\t++ind;\n\t\tif (unlikely(ind >= qp->rq.max))\n\t\t\tind -= qp->rq.max;\n\t}\nout:\n\tif (likely(nreq)) {\n\t\tqp->rq.head += nreq;\n\n\t\t \n\t\twmb();\n\t\t*qp->rq.db = cpu_to_be32(qp->rq.head & 0xffff);\n\t}\n\n\tspin_unlock_irqrestore(&qp->rq.lock, flags);\n\treturn err;\n}\n\nvoid mthca_free_err_wqe(struct mthca_dev *dev, struct mthca_qp *qp, int is_send,\n\t\t\tint index, int *dbd, __be32 *new_wqe)\n{\n\tstruct mthca_next_seg *next;\n\n\t \n\tif (qp->ibqp.srq && !is_send) {\n\t\t*new_wqe = 0;\n\t\treturn;\n\t}\n\n\tif (is_send)\n\t\tnext = get_send_wqe(qp, index);\n\telse\n\t\tnext = get_recv_wqe(qp, index);\n\n\t*dbd = !!(next->ee_nds & cpu_to_be32(MTHCA_NEXT_DBD));\n\tif (next->ee_nds & cpu_to_be32(0x3f))\n\t\t*new_wqe = (next->nda_op & cpu_to_be32(~0x3f)) |\n\t\t\t(next->ee_nds & cpu_to_be32(0x3f));\n\telse\n\t\t*new_wqe = 0;\n}\n\nint mthca_init_qp_table(struct mthca_dev *dev)\n{\n\tint err;\n\tint i;\n\n\tspin_lock_init(&dev->qp_table.lock);\n\n\t \n\tdev->qp_table.sqp_start = (dev->limits.reserved_qps + 1) & ~1UL;\n\terr = mthca_alloc_init(&dev->qp_table.alloc,\n\t\t\t       dev->limits.num_qps,\n\t\t\t       (1 << 24) - 1,\n\t\t\t       dev->qp_table.sqp_start +\n\t\t\t       MTHCA_MAX_PORTS * 2);\n\tif (err)\n\t\treturn err;\n\n\terr = mthca_array_init(&dev->qp_table.qp,\n\t\t\t       dev->limits.num_qps);\n\tif (err) {\n\t\tmthca_alloc_cleanup(&dev->qp_table.alloc);\n\t\treturn err;\n\t}\n\n\tfor (i = 0; i < 2; ++i) {\n\t\terr = mthca_CONF_SPECIAL_QP(dev, i ? IB_QPT_GSI : IB_QPT_SMI,\n\t\t\t\t    dev->qp_table.sqp_start + i * 2);\n\t\tif (err) {\n\t\t\tmthca_warn(dev, \"CONF_SPECIAL_QP returned \"\n\t\t\t\t   \"%d, aborting.\\n\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\treturn 0;\n\n err_out:\n\tfor (i = 0; i < 2; ++i)\n\t\tmthca_CONF_SPECIAL_QP(dev, i, 0);\n\n\tmthca_array_cleanup(&dev->qp_table.qp, dev->limits.num_qps);\n\tmthca_alloc_cleanup(&dev->qp_table.alloc);\n\n\treturn err;\n}\n\nvoid mthca_cleanup_qp_table(struct mthca_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; ++i)\n\t\tmthca_CONF_SPECIAL_QP(dev, i, 0);\n\n\tmthca_array_cleanup(&dev->qp_table.qp, dev->limits.num_qps);\n\tmthca_alloc_cleanup(&dev->qp_table.alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}