{
  "module_name": "mthca_profile.c",
  "hash_id": "05fc59760f835470dabcf1d61dad2e95a53afdc4a17a88dd5212027cc3bdf7cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_profile.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include \"mthca_profile.h\"\n\nenum {\n\tMTHCA_RES_QP,\n\tMTHCA_RES_EEC,\n\tMTHCA_RES_SRQ,\n\tMTHCA_RES_CQ,\n\tMTHCA_RES_EQP,\n\tMTHCA_RES_EEEC,\n\tMTHCA_RES_EQ,\n\tMTHCA_RES_RDB,\n\tMTHCA_RES_MCG,\n\tMTHCA_RES_MPT,\n\tMTHCA_RES_MTT,\n\tMTHCA_RES_UAR,\n\tMTHCA_RES_UDAV,\n\tMTHCA_RES_UARC,\n\tMTHCA_RES_NUM\n};\n\nenum {\n\tMTHCA_NUM_EQS = 32,\n\tMTHCA_NUM_PDS = 1 << 15\n};\n\ns64 mthca_make_profile(struct mthca_dev *dev,\n\t\t       struct mthca_profile *request,\n\t\t       struct mthca_dev_lim *dev_lim,\n\t\t       struct mthca_init_hca_param *init_hca)\n{\n\tstruct mthca_resource {\n\t\tu64 size;\n\t\tu64 start;\n\t\tint type;\n\t\tint num;\n\t\tint log_num;\n\t};\n\n\tu64 mem_base, mem_avail;\n\ts64 total_size = 0;\n\tstruct mthca_resource *profile;\n\tint i, j;\n\n\tprofile = kcalloc(MTHCA_RES_NUM, sizeof(*profile), GFP_KERNEL);\n\tif (!profile)\n\t\treturn -ENOMEM;\n\n\tprofile[MTHCA_RES_QP].size   = dev_lim->qpc_entry_sz;\n\tprofile[MTHCA_RES_EEC].size  = dev_lim->eec_entry_sz;\n\tprofile[MTHCA_RES_SRQ].size  = dev_lim->srq_entry_sz;\n\tprofile[MTHCA_RES_CQ].size   = dev_lim->cqc_entry_sz;\n\tprofile[MTHCA_RES_EQP].size  = dev_lim->eqpc_entry_sz;\n\tprofile[MTHCA_RES_EEEC].size = dev_lim->eeec_entry_sz;\n\tprofile[MTHCA_RES_EQ].size   = dev_lim->eqc_entry_sz;\n\tprofile[MTHCA_RES_RDB].size  = MTHCA_RDB_ENTRY_SIZE;\n\tprofile[MTHCA_RES_MCG].size  = MTHCA_MGM_ENTRY_SIZE;\n\tprofile[MTHCA_RES_MPT].size  = dev_lim->mpt_entry_sz;\n\tprofile[MTHCA_RES_MTT].size  = dev->limits.mtt_seg_size;\n\tprofile[MTHCA_RES_UAR].size  = dev_lim->uar_scratch_entry_sz;\n\tprofile[MTHCA_RES_UDAV].size = MTHCA_AV_SIZE;\n\tprofile[MTHCA_RES_UARC].size = request->uarc_size;\n\n\tprofile[MTHCA_RES_QP].num    = request->num_qp;\n\tprofile[MTHCA_RES_SRQ].num   = request->num_srq;\n\tprofile[MTHCA_RES_EQP].num   = request->num_qp;\n\tprofile[MTHCA_RES_RDB].num   = request->num_qp * request->rdb_per_qp;\n\tprofile[MTHCA_RES_CQ].num    = request->num_cq;\n\tprofile[MTHCA_RES_EQ].num    = MTHCA_NUM_EQS;\n\tprofile[MTHCA_RES_MCG].num   = request->num_mcg;\n\tprofile[MTHCA_RES_MPT].num   = request->num_mpt;\n\tprofile[MTHCA_RES_MTT].num   = request->num_mtt;\n\tprofile[MTHCA_RES_UAR].num   = request->num_uar;\n\tprofile[MTHCA_RES_UARC].num  = request->num_uar;\n\tprofile[MTHCA_RES_UDAV].num  = request->num_udav;\n\n\tfor (i = 0; i < MTHCA_RES_NUM; ++i) {\n\t\tprofile[i].type     = i;\n\t\tprofile[i].log_num  = max(ffs(profile[i].num) - 1, 0);\n\t\tprofile[i].size    *= profile[i].num;\n\t\tif (mthca_is_memfree(dev))\n\t\t\tprofile[i].size = max(profile[i].size, (u64) PAGE_SIZE);\n\t}\n\n\tif (mthca_is_memfree(dev)) {\n\t\tmem_base  = 0;\n\t\tmem_avail = dev_lim->hca.arbel.max_icm_sz;\n\t} else {\n\t\tmem_base  = dev->ddr_start;\n\t\tmem_avail = dev->fw.tavor.fw_start - dev->ddr_start;\n\t}\n\n\t \n\tfor (i = MTHCA_RES_NUM; i > 0; --i)\n\t\tfor (j = 1; j < i; ++j) {\n\t\t\tif (profile[j].size > profile[j - 1].size)\n\t\t\t\tswap(profile[j], profile[j - 1]);\n\t\t}\n\n\tfor (i = 0; i < MTHCA_RES_NUM; ++i) {\n\t\tif (profile[i].size) {\n\t\t\tprofile[i].start = mem_base + total_size;\n\t\t\ttotal_size      += profile[i].size;\n\t\t}\n\t\tif (total_size > mem_avail) {\n\t\t\tmthca_err(dev, \"Profile requires 0x%llx bytes; \"\n\t\t\t\t  \"won't fit in 0x%llx bytes of context memory.\\n\",\n\t\t\t\t  (unsigned long long) total_size,\n\t\t\t\t  (unsigned long long) mem_avail);\n\t\t\tkfree(profile);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (profile[i].size)\n\t\t\tmthca_dbg(dev, \"profile[%2d]--%2d/%2d @ 0x%16llx \"\n\t\t\t\t  \"(size 0x%8llx)\\n\",\n\t\t\t\t  i, profile[i].type, profile[i].log_num,\n\t\t\t\t  (unsigned long long) profile[i].start,\n\t\t\t\t  (unsigned long long) profile[i].size);\n\t}\n\n\tif (mthca_is_memfree(dev))\n\t\tmthca_dbg(dev, \"HCA context memory: reserving %d KB\\n\",\n\t\t\t  (int) (total_size >> 10));\n\telse\n\t\tmthca_dbg(dev, \"HCA memory: allocated %d KB/%d KB (%d KB free)\\n\",\n\t\t\t  (int) (total_size >> 10), (int) (mem_avail >> 10),\n\t\t\t  (int) ((mem_avail - total_size) >> 10));\n\n\tfor (i = 0; i < MTHCA_RES_NUM; ++i) {\n\t\tswitch (profile[i].type) {\n\t\tcase MTHCA_RES_QP:\n\t\t\tdev->limits.num_qps   = profile[i].num;\n\t\t\tinit_hca->qpc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_qps = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_EEC:\n\t\t\tdev->limits.num_eecs   = profile[i].num;\n\t\t\tinit_hca->eec_base     = profile[i].start;\n\t\t\tinit_hca->log_num_eecs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_SRQ:\n\t\t\tdev->limits.num_srqs   = profile[i].num;\n\t\t\tinit_hca->srqc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_srqs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_CQ:\n\t\t\tdev->limits.num_cqs   = profile[i].num;\n\t\t\tinit_hca->cqc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_cqs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_EQP:\n\t\t\tinit_hca->eqpc_base = profile[i].start;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_EEEC:\n\t\t\tinit_hca->eeec_base = profile[i].start;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_EQ:\n\t\t\tdev->limits.num_eqs   = profile[i].num;\n\t\t\tinit_hca->eqc_base    = profile[i].start;\n\t\t\tinit_hca->log_num_eqs = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_RDB:\n\t\t\tfor (dev->qp_table.rdb_shift = 0;\n\t\t\t     request->num_qp << dev->qp_table.rdb_shift < profile[i].num;\n\t\t\t     ++dev->qp_table.rdb_shift)\n\t\t\t\t;  \n\t\t\tdev->qp_table.rdb_base    = (u32) profile[i].start;\n\t\t\tinit_hca->rdb_base        = profile[i].start;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_MCG:\n\t\t\tdev->limits.num_mgms      = profile[i].num >> 1;\n\t\t\tdev->limits.num_amgms     = profile[i].num >> 1;\n\t\t\tinit_hca->mc_base         = profile[i].start;\n\t\t\tinit_hca->log_mc_entry_sz = ffs(MTHCA_MGM_ENTRY_SIZE) - 1;\n\t\t\tinit_hca->log_mc_table_sz = profile[i].log_num;\n\t\t\tinit_hca->mc_hash_sz      = 1 << (profile[i].log_num - 1);\n\t\t\tbreak;\n\t\tcase MTHCA_RES_MPT:\n\t\t\tdev->limits.num_mpts   = profile[i].num;\n\t\t\tdev->mr_table.mpt_base = profile[i].start;\n\t\t\tinit_hca->mpt_base     = profile[i].start;\n\t\t\tinit_hca->log_mpt_sz   = profile[i].log_num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_MTT:\n\t\t\tdev->limits.num_mtt_segs = profile[i].num;\n\t\t\tdev->mr_table.mtt_base   = profile[i].start;\n\t\t\tinit_hca->mtt_base       = profile[i].start;\n\t\t\tinit_hca->mtt_seg_sz     = ffs(dev->limits.mtt_seg_size) - 7;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_UAR:\n\t\t\tdev->limits.num_uars       = profile[i].num;\n\t\t\tinit_hca->uar_scratch_base = profile[i].start;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_UDAV:\n\t\t\tdev->av_table.ddr_av_base = profile[i].start;\n\t\t\tdev->av_table.num_ddr_avs = profile[i].num;\n\t\t\tbreak;\n\t\tcase MTHCA_RES_UARC:\n\t\t\tdev->uar_table.uarc_size = request->uarc_size;\n\t\t\tdev->uar_table.uarc_base = profile[i].start;\n\t\t\tinit_hca->uarc_base   \t = profile[i].start;\n\t\t\tinit_hca->log_uarc_sz \t = ffs(request->uarc_size) - 13;\n\t\t\tinit_hca->log_uar_sz  \t = ffs(request->num_uar) - 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdev->limits.num_pds = MTHCA_NUM_PDS;\n\n\tif (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT &&\n\t    init_hca->log_mpt_sz > 23) {\n\t\tmthca_warn(dev, \"MPT table too large (requested size 2^%d >= 2^24)\\n\",\n\t\t\t   init_hca->log_mpt_sz);\n\t\tmthca_warn(dev, \"Disabling memory key throughput optimization.\\n\");\n\t\tdev->mthca_flags &= ~MTHCA_FLAG_SINAI_OPT;\n\t}\n\n\t \n\tif (mthca_is_memfree(dev) || BITS_PER_LONG == 64)\n\t\tdev->limits.fmr_reserved_mtts = 0;\n\telse\n\t\tdev->limits.fmr_reserved_mtts = request->fmr_reserved_mtts;\n\n\tkfree(profile);\n\treturn total_size;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}