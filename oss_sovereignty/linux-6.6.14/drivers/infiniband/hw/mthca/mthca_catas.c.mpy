{
  "module_name": "mthca_catas.c",
  "hash_id": "787af983c19d910eb0c63d830344b5ea5c8d9aa17517fd02e3ad72cd6aee0110",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_catas.c",
  "human_readable_source": " \n\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n\n#include \"mthca_dev.h\"\n\nenum {\n\tMTHCA_CATAS_POLL_INTERVAL\t= 5 * HZ,\n\n\tMTHCA_CATAS_TYPE_INTERNAL\t= 0,\n\tMTHCA_CATAS_TYPE_UPLINK\t\t= 3,\n\tMTHCA_CATAS_TYPE_DDR\t\t= 4,\n\tMTHCA_CATAS_TYPE_PARITY\t\t= 5,\n};\n\nstatic DEFINE_SPINLOCK(catas_lock);\n\nstatic LIST_HEAD(catas_list);\nstatic struct workqueue_struct *catas_wq;\nstatic struct work_struct catas_work;\n\nstatic int catas_reset_disable;\nmodule_param_named(catas_reset_disable, catas_reset_disable, int, 0644);\nMODULE_PARM_DESC(catas_reset_disable, \"disable reset on catastrophic event if nonzero\");\n\nstatic void catas_reset(struct work_struct *work)\n{\n\tstruct mthca_dev *dev, *tmpdev;\n\tLIST_HEAD(tlist);\n\tint ret;\n\n\tmutex_lock(&mthca_device_mutex);\n\n\tspin_lock_irq(&catas_lock);\n\tlist_splice_init(&catas_list, &tlist);\n\tspin_unlock_irq(&catas_lock);\n\n\tlist_for_each_entry_safe(dev, tmpdev, &tlist, catas_err.list) {\n\t\tstruct pci_dev *pdev = dev->pdev;\n\t\tret = __mthca_restart_one(dev->pdev);\n\t\t \n\t\tif (ret)\n\t\t\tprintk(KERN_ERR \"mthca %s: Reset failed (%d)\\n\",\n\t\t\t       pci_name(pdev), ret);\n\t\telse {\n\t\t\tstruct mthca_dev *d = pci_get_drvdata(pdev);\n\t\t\tmthca_dbg(d, \"Reset succeeded\\n\");\n\t\t}\n\t}\n\n\tmutex_unlock(&mthca_device_mutex);\n}\n\nstatic void handle_catas(struct mthca_dev *dev)\n{\n\tstruct ib_event event;\n\tunsigned long flags;\n\tconst char *type;\n\tint i;\n\n\tevent.device = &dev->ib_dev;\n\tevent.event  = IB_EVENT_DEVICE_FATAL;\n\tevent.element.port_num = 0;\n\tdev->active = false;\n\n\tib_dispatch_event(&event);\n\n\tswitch (swab32(readl(dev->catas_err.map)) >> 24) {\n\tcase MTHCA_CATAS_TYPE_INTERNAL:\n\t\ttype = \"internal error\";\n\t\tbreak;\n\tcase MTHCA_CATAS_TYPE_UPLINK:\n\t\ttype = \"uplink bus error\";\n\t\tbreak;\n\tcase MTHCA_CATAS_TYPE_DDR:\n\t\ttype = \"DDR data error\";\n\t\tbreak;\n\tcase MTHCA_CATAS_TYPE_PARITY:\n\t\ttype = \"internal parity error\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"unknown error\";\n\t\tbreak;\n\t}\n\n\tmthca_err(dev, \"Catastrophic error detected: %s\\n\", type);\n\tfor (i = 0; i < dev->catas_err.size; ++i)\n\t\tmthca_err(dev, \"  buf[%02x]: %08x\\n\",\n\t\t\t  i, swab32(readl(dev->catas_err.map + i)));\n\n\tif (catas_reset_disable)\n\t\treturn;\n\n\tspin_lock_irqsave(&catas_lock, flags);\n\tlist_add(&dev->catas_err.list, &catas_list);\n\tqueue_work(catas_wq, &catas_work);\n\tspin_unlock_irqrestore(&catas_lock, flags);\n}\n\nstatic void poll_catas(struct timer_list *t)\n{\n\tstruct mthca_dev *dev = from_timer(dev, t, catas_err.timer);\n\tint i;\n\n\tfor (i = 0; i < dev->catas_err.size; ++i)\n\t\tif (readl(dev->catas_err.map + i)) {\n\t\t\thandle_catas(dev);\n\t\t\treturn;\n\t\t}\n\n\tmod_timer(&dev->catas_err.timer,\n\t\t  round_jiffies(jiffies + MTHCA_CATAS_POLL_INTERVAL));\n}\n\nvoid mthca_start_catas_poll(struct mthca_dev *dev)\n{\n\tphys_addr_t addr;\n\n\ttimer_setup(&dev->catas_err.timer, poll_catas, 0);\n\tdev->catas_err.map  = NULL;\n\n\taddr = pci_resource_start(dev->pdev, 0) +\n\t\t((pci_resource_len(dev->pdev, 0) - 1) &\n\t\t dev->catas_err.addr);\n\n\tdev->catas_err.map = ioremap(addr, dev->catas_err.size * 4);\n\tif (!dev->catas_err.map) {\n\t\tmthca_warn(dev, \"couldn't map catastrophic error region \"\n\t\t\t   \"at 0x%llx/0x%x\\n\", (unsigned long long) addr,\n\t\t\t   dev->catas_err.size * 4);\n\t\treturn;\n\t}\n\n\tdev->catas_err.timer.expires  = jiffies + MTHCA_CATAS_POLL_INTERVAL;\n\tINIT_LIST_HEAD(&dev->catas_err.list);\n\tadd_timer(&dev->catas_err.timer);\n}\n\nvoid mthca_stop_catas_poll(struct mthca_dev *dev)\n{\n\tdel_timer_sync(&dev->catas_err.timer);\n\n\tif (dev->catas_err.map)\n\t\tiounmap(dev->catas_err.map);\n\n\tspin_lock_irq(&catas_lock);\n\tlist_del(&dev->catas_err.list);\n\tspin_unlock_irq(&catas_lock);\n}\n\nint __init mthca_catas_init(void)\n{\n\tINIT_WORK(&catas_work, catas_reset);\n\n\tcatas_wq = alloc_ordered_workqueue(\"mthca_catas\", WQ_MEM_RECLAIM);\n\tif (!catas_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid mthca_catas_cleanup(void)\n{\n\tdestroy_workqueue(catas_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}