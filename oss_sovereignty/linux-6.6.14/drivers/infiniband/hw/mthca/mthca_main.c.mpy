{
  "module_name": "mthca_main.c",
  "hash_id": "e4bfc2060ba33361ae405eec797d3bb3c7e7b4690094e12bdfba14e969028a81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/gfp.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_config_reg.h\"\n#include \"mthca_cmd.h\"\n#include \"mthca_profile.h\"\n#include \"mthca_memfree.h\"\n#include \"mthca_wqe.h\"\n\nMODULE_AUTHOR(\"Roland Dreier\");\nMODULE_DESCRIPTION(\"Mellanox InfiniBand HCA low-level driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#ifdef CONFIG_INFINIBAND_MTHCA_DEBUG\n\nint mthca_debug_level = 0;\nmodule_param_named(debug_level, mthca_debug_level, int, 0644);\nMODULE_PARM_DESC(debug_level, \"Enable debug tracing if > 0\");\n\n#endif  \n\n#ifdef CONFIG_PCI_MSI\n\nstatic int msi_x = 1;\nmodule_param(msi_x, int, 0444);\nMODULE_PARM_DESC(msi_x, \"attempt to use MSI-X if nonzero\");\n\n#else  \n\n#define msi_x (0)\n\n#endif  \n\nstatic int tune_pci = 0;\nmodule_param(tune_pci, int, 0444);\nMODULE_PARM_DESC(tune_pci, \"increase PCI burst from the default set by BIOS if nonzero\");\n\nDEFINE_MUTEX(mthca_device_mutex);\n\n#define MTHCA_DEFAULT_NUM_QP            (1 << 16)\n#define MTHCA_DEFAULT_RDB_PER_QP        (1 << 2)\n#define MTHCA_DEFAULT_NUM_CQ            (1 << 16)\n#define MTHCA_DEFAULT_NUM_MCG           (1 << 13)\n#define MTHCA_DEFAULT_NUM_MPT           (1 << 17)\n#define MTHCA_DEFAULT_NUM_MTT           (1 << 20)\n#define MTHCA_DEFAULT_NUM_UDAV          (1 << 15)\n#define MTHCA_DEFAULT_NUM_RESERVED_MTTS (1 << 18)\n#define MTHCA_DEFAULT_NUM_UARC_SIZE     (1 << 18)\n\nstatic struct mthca_profile hca_profile = {\n\t.num_qp             = MTHCA_DEFAULT_NUM_QP,\n\t.rdb_per_qp         = MTHCA_DEFAULT_RDB_PER_QP,\n\t.num_cq             = MTHCA_DEFAULT_NUM_CQ,\n\t.num_mcg            = MTHCA_DEFAULT_NUM_MCG,\n\t.num_mpt            = MTHCA_DEFAULT_NUM_MPT,\n\t.num_mtt            = MTHCA_DEFAULT_NUM_MTT,\n\t.num_udav           = MTHCA_DEFAULT_NUM_UDAV,           \n\t.fmr_reserved_mtts  = MTHCA_DEFAULT_NUM_RESERVED_MTTS,  \n\t.uarc_size          = MTHCA_DEFAULT_NUM_UARC_SIZE,      \n};\n\nmodule_param_named(num_qp, hca_profile.num_qp, int, 0444);\nMODULE_PARM_DESC(num_qp, \"maximum number of QPs per HCA\");\n\nmodule_param_named(rdb_per_qp, hca_profile.rdb_per_qp, int, 0444);\nMODULE_PARM_DESC(rdb_per_qp, \"number of RDB buffers per QP\");\n\nmodule_param_named(num_cq, hca_profile.num_cq, int, 0444);\nMODULE_PARM_DESC(num_cq, \"maximum number of CQs per HCA\");\n\nmodule_param_named(num_mcg, hca_profile.num_mcg, int, 0444);\nMODULE_PARM_DESC(num_mcg, \"maximum number of multicast groups per HCA\");\n\nmodule_param_named(num_mpt, hca_profile.num_mpt, int, 0444);\nMODULE_PARM_DESC(num_mpt,\n\t\t\"maximum number of memory protection table entries per HCA\");\n\nmodule_param_named(num_mtt, hca_profile.num_mtt, int, 0444);\nMODULE_PARM_DESC(num_mtt,\n\t\t \"maximum number of memory translation table segments per HCA\");\n\nmodule_param_named(num_udav, hca_profile.num_udav, int, 0444);\nMODULE_PARM_DESC(num_udav, \"maximum number of UD address vectors per HCA\");\n\nmodule_param_named(fmr_reserved_mtts, hca_profile.fmr_reserved_mtts, int, 0444);\nMODULE_PARM_DESC(fmr_reserved_mtts,\n\t\t \"number of memory translation table segments reserved for FMR\");\n\nstatic int log_mtts_per_seg = ilog2(MTHCA_MTT_SEG_SIZE / 8);\nmodule_param_named(log_mtts_per_seg, log_mtts_per_seg, int, 0444);\nMODULE_PARM_DESC(log_mtts_per_seg, \"Log2 number of MTT entries per segment (1-5)\");\n\nstatic char mthca_version[] =\n\tDRV_NAME \": Mellanox InfiniBand HCA driver v\"\n\tDRV_VERSION \" (\" DRV_RELDATE \")\\n\";\n\nstatic int mthca_tune_pci(struct mthca_dev *mdev)\n{\n\tif (!tune_pci)\n\t\treturn 0;\n\n\t \n\tif (pci_find_capability(mdev->pdev, PCI_CAP_ID_PCIX)) {\n\t\tif (pcix_set_mmrbc(mdev->pdev, pcix_get_max_mmrbc(mdev->pdev))) {\n\t\t\tmthca_err(mdev, \"Couldn't set PCI-X max read count, \"\n\t\t\t\t\"aborting.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (!(mdev->mthca_flags & MTHCA_FLAG_PCIE))\n\t\tmthca_info(mdev, \"No PCI-X capability, not setting RBC.\\n\");\n\n\tif (pci_is_pcie(mdev->pdev)) {\n\t\tif (pcie_set_readrq(mdev->pdev, 4096)) {\n\t\t\tmthca_err(mdev, \"Couldn't write PCI Express read request, \"\n\t\t\t\t\"aborting.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else if (mdev->mthca_flags & MTHCA_FLAG_PCIE)\n\t\tmthca_info(mdev, \"No PCI Express capability, \"\n\t\t\t   \"not setting Max Read Request Size.\\n\");\n\n\treturn 0;\n}\n\nstatic int mthca_dev_lim(struct mthca_dev *mdev, struct mthca_dev_lim *dev_lim)\n{\n\tint err;\n\n\tmdev->limits.mtt_seg_size = (1 << log_mtts_per_seg) * 8;\n\terr = mthca_QUERY_DEV_LIM(mdev, dev_lim);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_DEV_LIM command returned %d\"\n\t\t\t\t\", aborting.\\n\", err);\n\t\treturn err;\n\t}\n\tif (dev_lim->min_page_sz > PAGE_SIZE) {\n\t\tmthca_err(mdev, \"HCA minimum page size of %d bigger than \"\n\t\t\t  \"kernel PAGE_SIZE of %ld, aborting.\\n\",\n\t\t\t  dev_lim->min_page_sz, PAGE_SIZE);\n\t\treturn -ENODEV;\n\t}\n\tif (dev_lim->num_ports > MTHCA_MAX_PORTS) {\n\t\tmthca_err(mdev, \"HCA has %d ports, but we only support %d, \"\n\t\t\t  \"aborting.\\n\",\n\t\t\t  dev_lim->num_ports, MTHCA_MAX_PORTS);\n\t\treturn -ENODEV;\n\t}\n\n\tif (dev_lim->uar_size > pci_resource_len(mdev->pdev, 2)) {\n\t\tmthca_err(mdev, \"HCA reported UAR size of 0x%x bigger than \"\n\t\t\t  \"PCI resource 2 size of 0x%llx, aborting.\\n\",\n\t\t\t  dev_lim->uar_size,\n\t\t\t  (unsigned long long)pci_resource_len(mdev->pdev, 2));\n\t\treturn -ENODEV;\n\t}\n\n\tmdev->limits.num_ports      \t= dev_lim->num_ports;\n\tmdev->limits.vl_cap             = dev_lim->max_vl;\n\tmdev->limits.mtu_cap            = dev_lim->max_mtu;\n\tmdev->limits.gid_table_len  \t= dev_lim->max_gids;\n\tmdev->limits.pkey_table_len \t= dev_lim->max_pkeys;\n\tmdev->limits.local_ca_ack_delay = dev_lim->local_ca_ack_delay;\n\t \n\tmdev->limits.max_sg\t\t= min_t(int, dev_lim->max_sg,\n\t\t\t\t\t      (dev_lim->max_desc_sz -\n\t\t\t\t\t       sizeof (struct mthca_next_seg) -\n\t\t\t\t\t       (mthca_is_memfree(mdev) ?\n\t\t\t\t\t\tsizeof (struct mthca_arbel_ud_seg) :\n\t\t\t\t\t\tsizeof (struct mthca_tavor_ud_seg))) /\n\t\t\t\t\t\tsizeof (struct mthca_data_seg));\n\tmdev->limits.max_wqes           = dev_lim->max_qp_sz;\n\tmdev->limits.max_qp_init_rdma   = dev_lim->max_requester_per_qp;\n\tmdev->limits.reserved_qps       = dev_lim->reserved_qps;\n\tmdev->limits.max_srq_wqes       = dev_lim->max_srq_sz;\n\tmdev->limits.reserved_srqs      = dev_lim->reserved_srqs;\n\tmdev->limits.reserved_eecs      = dev_lim->reserved_eecs;\n\tmdev->limits.max_desc_sz        = dev_lim->max_desc_sz;\n\tmdev->limits.max_srq_sge\t= mthca_max_srq_sge(mdev);\n\t \n\tmdev->limits.max_cqes           = dev_lim->max_cq_sz - 1;\n\tmdev->limits.reserved_cqs       = dev_lim->reserved_cqs;\n\tmdev->limits.reserved_eqs       = dev_lim->reserved_eqs;\n\tmdev->limits.reserved_mtts      = dev_lim->reserved_mtts;\n\tmdev->limits.reserved_mrws      = dev_lim->reserved_mrws;\n\tmdev->limits.reserved_uars      = dev_lim->reserved_uars;\n\tmdev->limits.reserved_pds       = dev_lim->reserved_pds;\n\tmdev->limits.port_width_cap     = dev_lim->max_port_width;\n\tmdev->limits.page_size_cap      = ~(u32) (dev_lim->min_page_sz - 1);\n\tmdev->limits.flags              = dev_lim->flags;\n\t \n\tif (dev_lim->stat_rate_support)\n\t\tmdev->limits.stat_rate_support = dev_lim->stat_rate_support;\n\telse if (mdev->mthca_flags & MTHCA_FLAG_SINAI_OPT)\n\t\tmdev->limits.stat_rate_support = 0xf;\n\telse\n\t\tmdev->limits.stat_rate_support = 0x3;\n\n\t \n\tmdev->device_cap_flags = IB_DEVICE_CHANGE_PHY_PORT |\n\t\tIB_DEVICE_PORT_ACTIVE_EVENT |\n\t\tIB_DEVICE_SYS_IMAGE_GUID |\n\t\tIB_DEVICE_RC_RNR_NAK_GEN;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_BAD_PKEY_CNTR)\n\t\tmdev->device_cap_flags |= IB_DEVICE_BAD_PKEY_CNTR;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_BAD_QKEY_CNTR)\n\t\tmdev->device_cap_flags |= IB_DEVICE_BAD_QKEY_CNTR;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_RAW_MULTI)\n\t\tmdev->device_cap_flags |= IB_DEVICE_RAW_MULTI;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_AUTO_PATH_MIG)\n\t\tmdev->device_cap_flags |= IB_DEVICE_AUTO_PATH_MIG;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_UD_AV_PORT_ENFORCE)\n\t\tmdev->device_cap_flags |= IB_DEVICE_UD_AV_PORT_ENFORCE;\n\n\tif (dev_lim->flags & DEV_LIM_FLAG_SRQ)\n\t\tmdev->mthca_flags |= MTHCA_FLAG_SRQ;\n\n\tif (mthca_is_memfree(mdev))\n\t\tif (dev_lim->flags & DEV_LIM_FLAG_IPOIB_CSUM)\n\t\t\tmdev->device_cap_flags |= IB_DEVICE_UD_IP_CSUM;\n\n\treturn 0;\n}\n\nstatic int mthca_init_tavor(struct mthca_dev *mdev)\n{\n\ts64 size;\n\tint err;\n\tstruct mthca_dev_lim        dev_lim;\n\tstruct mthca_profile        profile;\n\tstruct mthca_init_hca_param init_hca;\n\n\terr = mthca_SYS_EN(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"SYS_EN command returned %d, aborting.\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mthca_QUERY_FW(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_FW command returned %d,\"\n\t\t\t\t\" aborting.\\n\", err);\n\t\tgoto err_disable;\n\t}\n\terr = mthca_QUERY_DDR(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_DDR command returned %d, aborting.\\n\", err);\n\t\tgoto err_disable;\n\t}\n\n\terr = mthca_dev_lim(mdev, &dev_lim);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_DEV_LIM command returned %d, aborting.\\n\", err);\n\t\tgoto err_disable;\n\t}\n\n\tprofile = hca_profile;\n\tprofile.num_uar   = dev_lim.uar_size / PAGE_SIZE;\n\tprofile.uarc_size = 0;\n\tif (mdev->mthca_flags & MTHCA_FLAG_SRQ)\n\t\tprofile.num_srq = dev_lim.max_srqs;\n\n\tsize = mthca_make_profile(mdev, &profile, &dev_lim, &init_hca);\n\tif (size < 0) {\n\t\terr = size;\n\t\tgoto err_disable;\n\t}\n\n\terr = mthca_INIT_HCA(mdev, &init_hca);\n\tif (err) {\n\t\tmthca_err(mdev, \"INIT_HCA command returned %d, aborting.\\n\", err);\n\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tmthca_SYS_DIS(mdev);\n\n\treturn err;\n}\n\nstatic int mthca_load_fw(struct mthca_dev *mdev)\n{\n\tint err;\n\n\t \n\n\tmdev->fw.arbel.fw_icm =\n\t\tmthca_alloc_icm(mdev, mdev->fw.arbel.fw_pages,\n\t\t\t\tGFP_HIGHUSER | __GFP_NOWARN, 0);\n\tif (!mdev->fw.arbel.fw_icm) {\n\t\tmthca_err(mdev, \"Couldn't allocate FW area, aborting.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = mthca_MAP_FA(mdev, mdev->fw.arbel.fw_icm);\n\tif (err) {\n\t\tmthca_err(mdev, \"MAP_FA command returned %d, aborting.\\n\", err);\n\t\tgoto err_free;\n\t}\n\terr = mthca_RUN_FW(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"RUN_FW command returned %d, aborting.\\n\", err);\n\t\tgoto err_unmap_fa;\n\t}\n\n\treturn 0;\n\nerr_unmap_fa:\n\tmthca_UNMAP_FA(mdev);\n\nerr_free:\n\tmthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);\n\treturn err;\n}\n\nstatic int mthca_init_icm(struct mthca_dev *mdev,\n\t\t\t  struct mthca_dev_lim *dev_lim,\n\t\t\t  struct mthca_init_hca_param *init_hca,\n\t\t\t  u64 icm_size)\n{\n\tu64 aux_pages = 0;\n\tint err;\n\n\terr = mthca_SET_ICM_SIZE(mdev, icm_size, &aux_pages);\n\tif (err) {\n\t\tmthca_err(mdev, \"SET_ICM_SIZE command returned %d, aborting.\\n\", err);\n\t\treturn err;\n\t}\n\n\tmthca_dbg(mdev, \"%lld KB of HCA context requires %lld KB aux memory.\\n\",\n\t\t  (unsigned long long) icm_size >> 10,\n\t\t  (unsigned long long) aux_pages << 2);\n\n\tmdev->fw.arbel.aux_icm = mthca_alloc_icm(mdev, aux_pages,\n\t\t\t\t\t\t GFP_HIGHUSER | __GFP_NOWARN, 0);\n\tif (!mdev->fw.arbel.aux_icm) {\n\t\tmthca_err(mdev, \"Couldn't allocate aux memory, aborting.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = mthca_MAP_ICM_AUX(mdev, mdev->fw.arbel.aux_icm);\n\tif (err) {\n\t\tmthca_err(mdev, \"MAP_ICM_AUX returned %d, aborting.\\n\", err);\n\t\tgoto err_free_aux;\n\t}\n\n\terr = mthca_map_eq_icm(mdev, init_hca->eqc_base);\n\tif (err) {\n\t\tmthca_err(mdev, \"Failed to map EQ context memory, aborting.\\n\");\n\t\tgoto err_unmap_aux;\n\t}\n\n\t \n\tmdev->limits.reserved_mtts = ALIGN(mdev->limits.reserved_mtts * mdev->limits.mtt_seg_size,\n\t\t\t\t\t   dma_get_cache_alignment()) / mdev->limits.mtt_seg_size;\n\n\tmdev->mr_table.mtt_table = mthca_alloc_icm_table(mdev, init_hca->mtt_base,\n\t\t\t\t\t\t\t mdev->limits.mtt_seg_size,\n\t\t\t\t\t\t\t mdev->limits.num_mtt_segs,\n\t\t\t\t\t\t\t mdev->limits.reserved_mtts,\n\t\t\t\t\t\t\t 1, 0);\n\tif (!mdev->mr_table.mtt_table) {\n\t\tmthca_err(mdev, \"Failed to map MTT context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_eq;\n\t}\n\n\tmdev->mr_table.mpt_table = mthca_alloc_icm_table(mdev, init_hca->mpt_base,\n\t\t\t\t\t\t\t dev_lim->mpt_entry_sz,\n\t\t\t\t\t\t\t mdev->limits.num_mpts,\n\t\t\t\t\t\t\t mdev->limits.reserved_mrws,\n\t\t\t\t\t\t\t 1, 1);\n\tif (!mdev->mr_table.mpt_table) {\n\t\tmthca_err(mdev, \"Failed to map MPT context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_mtt;\n\t}\n\n\tmdev->qp_table.qp_table = mthca_alloc_icm_table(mdev, init_hca->qpc_base,\n\t\t\t\t\t\t\tdev_lim->qpc_entry_sz,\n\t\t\t\t\t\t\tmdev->limits.num_qps,\n\t\t\t\t\t\t\tmdev->limits.reserved_qps,\n\t\t\t\t\t\t\t0, 0);\n\tif (!mdev->qp_table.qp_table) {\n\t\tmthca_err(mdev, \"Failed to map QP context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_mpt;\n\t}\n\n\tmdev->qp_table.eqp_table = mthca_alloc_icm_table(mdev, init_hca->eqpc_base,\n\t\t\t\t\t\t\t dev_lim->eqpc_entry_sz,\n\t\t\t\t\t\t\t mdev->limits.num_qps,\n\t\t\t\t\t\t\t mdev->limits.reserved_qps,\n\t\t\t\t\t\t\t 0, 0);\n\tif (!mdev->qp_table.eqp_table) {\n\t\tmthca_err(mdev, \"Failed to map EQP context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_qp;\n\t}\n\n\tmdev->qp_table.rdb_table = mthca_alloc_icm_table(mdev, init_hca->rdb_base,\n\t\t\t\t\t\t\t MTHCA_RDB_ENTRY_SIZE,\n\t\t\t\t\t\t\t mdev->limits.num_qps <<\n\t\t\t\t\t\t\t mdev->qp_table.rdb_shift, 0,\n\t\t\t\t\t\t\t 0, 0);\n\tif (!mdev->qp_table.rdb_table) {\n\t\tmthca_err(mdev, \"Failed to map RDB context memory, aborting\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_eqp;\n\t}\n\n\tmdev->cq_table.table = mthca_alloc_icm_table(mdev, init_hca->cqc_base,\n\t\t\t\t\t\t     dev_lim->cqc_entry_sz,\n\t\t\t\t\t\t     mdev->limits.num_cqs,\n\t\t\t\t\t\t     mdev->limits.reserved_cqs,\n\t\t\t\t\t\t     0, 0);\n\tif (!mdev->cq_table.table) {\n\t\tmthca_err(mdev, \"Failed to map CQ context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_rdb;\n\t}\n\n\tif (mdev->mthca_flags & MTHCA_FLAG_SRQ) {\n\t\tmdev->srq_table.table =\n\t\t\tmthca_alloc_icm_table(mdev, init_hca->srqc_base,\n\t\t\t\t\t      dev_lim->srq_entry_sz,\n\t\t\t\t\t      mdev->limits.num_srqs,\n\t\t\t\t\t      mdev->limits.reserved_srqs,\n\t\t\t\t\t      0, 0);\n\t\tif (!mdev->srq_table.table) {\n\t\t\tmthca_err(mdev, \"Failed to map SRQ context memory, \"\n\t\t\t\t  \"aborting.\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_unmap_cq;\n\t\t}\n\t}\n\n\t \n\tmdev->mcg_table.table = mthca_alloc_icm_table(mdev, init_hca->mc_base,\n\t\t\t\t\t\t      MTHCA_MGM_ENTRY_SIZE,\n\t\t\t\t\t\t      mdev->limits.num_mgms +\n\t\t\t\t\t\t      mdev->limits.num_amgms,\n\t\t\t\t\t\t      mdev->limits.num_mgms +\n\t\t\t\t\t\t      mdev->limits.num_amgms,\n\t\t\t\t\t\t      0, 0);\n\tif (!mdev->mcg_table.table) {\n\t\tmthca_err(mdev, \"Failed to map MCG context memory, aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_unmap_srq;\n\t}\n\n\treturn 0;\n\nerr_unmap_srq:\n\tif (mdev->mthca_flags & MTHCA_FLAG_SRQ)\n\t\tmthca_free_icm_table(mdev, mdev->srq_table.table);\n\nerr_unmap_cq:\n\tmthca_free_icm_table(mdev, mdev->cq_table.table);\n\nerr_unmap_rdb:\n\tmthca_free_icm_table(mdev, mdev->qp_table.rdb_table);\n\nerr_unmap_eqp:\n\tmthca_free_icm_table(mdev, mdev->qp_table.eqp_table);\n\nerr_unmap_qp:\n\tmthca_free_icm_table(mdev, mdev->qp_table.qp_table);\n\nerr_unmap_mpt:\n\tmthca_free_icm_table(mdev, mdev->mr_table.mpt_table);\n\nerr_unmap_mtt:\n\tmthca_free_icm_table(mdev, mdev->mr_table.mtt_table);\n\nerr_unmap_eq:\n\tmthca_unmap_eq_icm(mdev);\n\nerr_unmap_aux:\n\tmthca_UNMAP_ICM_AUX(mdev);\n\nerr_free_aux:\n\tmthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);\n\n\treturn err;\n}\n\nstatic void mthca_free_icms(struct mthca_dev *mdev)\n{\n\n\tmthca_free_icm_table(mdev, mdev->mcg_table.table);\n\tif (mdev->mthca_flags & MTHCA_FLAG_SRQ)\n\t\tmthca_free_icm_table(mdev, mdev->srq_table.table);\n\tmthca_free_icm_table(mdev, mdev->cq_table.table);\n\tmthca_free_icm_table(mdev, mdev->qp_table.rdb_table);\n\tmthca_free_icm_table(mdev, mdev->qp_table.eqp_table);\n\tmthca_free_icm_table(mdev, mdev->qp_table.qp_table);\n\tmthca_free_icm_table(mdev, mdev->mr_table.mpt_table);\n\tmthca_free_icm_table(mdev, mdev->mr_table.mtt_table);\n\tmthca_unmap_eq_icm(mdev);\n\n\tmthca_UNMAP_ICM_AUX(mdev);\n\tmthca_free_icm(mdev, mdev->fw.arbel.aux_icm, 0);\n}\n\nstatic int mthca_init_arbel(struct mthca_dev *mdev)\n{\n\tstruct mthca_dev_lim        dev_lim;\n\tstruct mthca_profile        profile;\n\tstruct mthca_init_hca_param init_hca;\n\ts64 icm_size;\n\tint err;\n\n\terr = mthca_QUERY_FW(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_FW command failed %d, aborting.\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mthca_ENABLE_LAM(mdev);\n\tif (err == -EAGAIN) {\n\t\tmthca_dbg(mdev, \"No HCA-attached memory (running in MemFree mode)\\n\");\n\t\tmdev->mthca_flags |= MTHCA_FLAG_NO_LAM;\n\t} else if (err) {\n\t\tmthca_err(mdev, \"ENABLE_LAM returned %d, aborting.\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = mthca_load_fw(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"Loading FW returned %d, aborting.\\n\", err);\n\t\tgoto err_disable;\n\t}\n\n\terr = mthca_dev_lim(mdev, &dev_lim);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_DEV_LIM returned %d, aborting.\\n\", err);\n\t\tgoto err_stop_fw;\n\t}\n\n\tprofile = hca_profile;\n\tprofile.num_uar  = dev_lim.uar_size / PAGE_SIZE;\n\tprofile.num_udav = 0;\n\tif (mdev->mthca_flags & MTHCA_FLAG_SRQ)\n\t\tprofile.num_srq = dev_lim.max_srqs;\n\n\ticm_size = mthca_make_profile(mdev, &profile, &dev_lim, &init_hca);\n\tif (icm_size < 0) {\n\t\terr = icm_size;\n\t\tgoto err_stop_fw;\n\t}\n\n\terr = mthca_init_icm(mdev, &dev_lim, &init_hca, icm_size);\n\tif (err)\n\t\tgoto err_stop_fw;\n\n\terr = mthca_INIT_HCA(mdev, &init_hca);\n\tif (err) {\n\t\tmthca_err(mdev, \"INIT_HCA command returned %d, aborting.\\n\", err);\n\t\tgoto err_free_icm;\n\t}\n\n\treturn 0;\n\nerr_free_icm:\n\tmthca_free_icms(mdev);\n\nerr_stop_fw:\n\tmthca_UNMAP_FA(mdev);\n\tmthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);\n\nerr_disable:\n\tif (!(mdev->mthca_flags & MTHCA_FLAG_NO_LAM))\n\t\tmthca_DISABLE_LAM(mdev);\n\n\treturn err;\n}\n\nstatic void mthca_close_hca(struct mthca_dev *mdev)\n{\n\tmthca_CLOSE_HCA(mdev, 0);\n\n\tif (mthca_is_memfree(mdev)) {\n\t\tmthca_free_icms(mdev);\n\n\t\tmthca_UNMAP_FA(mdev);\n\t\tmthca_free_icm(mdev, mdev->fw.arbel.fw_icm, 0);\n\n\t\tif (!(mdev->mthca_flags & MTHCA_FLAG_NO_LAM))\n\t\t\tmthca_DISABLE_LAM(mdev);\n\t} else\n\t\tmthca_SYS_DIS(mdev);\n}\n\nstatic int mthca_init_hca(struct mthca_dev *mdev)\n{\n\tint err;\n\tstruct mthca_adapter adapter;\n\n\tif (mthca_is_memfree(mdev))\n\t\terr = mthca_init_arbel(mdev);\n\telse\n\t\terr = mthca_init_tavor(mdev);\n\n\tif (err)\n\t\treturn err;\n\n\terr = mthca_QUERY_ADAPTER(mdev, &adapter);\n\tif (err) {\n\t\tmthca_err(mdev, \"QUERY_ADAPTER command returned %d, aborting.\\n\", err);\n\t\tgoto err_close;\n\t}\n\n\tmdev->eq_table.inta_pin = adapter.inta_pin;\n\tif (!mthca_is_memfree(mdev))\n\t\tmdev->rev_id = adapter.revision_id;\n\tmemcpy(mdev->board_id, adapter.board_id, sizeof mdev->board_id);\n\n\treturn 0;\n\nerr_close:\n\tmthca_close_hca(mdev);\n\treturn err;\n}\n\nstatic int mthca_setup_hca(struct mthca_dev *dev)\n{\n\tint err;\n\n\tMTHCA_INIT_DOORBELL_LOCK(&dev->doorbell_lock);\n\n\terr = mthca_init_uar_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"user access region table, aborting.\\n\");\n\t\treturn err;\n\t}\n\n\terr = mthca_uar_alloc(dev, &dev->driver_uar);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to allocate driver access region, \"\n\t\t\t  \"aborting.\\n\");\n\t\tgoto err_uar_table_free;\n\t}\n\n\tdev->kar = ioremap((phys_addr_t) dev->driver_uar.pfn << PAGE_SHIFT, PAGE_SIZE);\n\tif (!dev->kar) {\n\t\tmthca_err(dev, \"Couldn't map kernel access region, \"\n\t\t\t  \"aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_uar_free;\n\t}\n\n\terr = mthca_init_pd_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"protection domain table, aborting.\\n\");\n\t\tgoto err_kar_unmap;\n\t}\n\n\terr = mthca_init_mr_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"memory region table, aborting.\\n\");\n\t\tgoto err_pd_table_free;\n\t}\n\n\terr = mthca_pd_alloc(dev, 1, &dev->driver_pd);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to create driver PD, \"\n\t\t\t  \"aborting.\\n\");\n\t\tgoto err_mr_table_free;\n\t}\n\n\terr = mthca_init_eq_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"event queue table, aborting.\\n\");\n\t\tgoto err_pd_free;\n\t}\n\n\terr = mthca_cmd_use_events(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to switch to event-driven \"\n\t\t\t  \"firmware commands, aborting.\\n\");\n\t\tgoto err_eq_table_free;\n\t}\n\n\terr = mthca_NOP(dev);\n\tif (err) {\n\t\tif (dev->mthca_flags & MTHCA_FLAG_MSI_X) {\n\t\t\tmthca_warn(dev, \"NOP command failed to generate interrupt \"\n\t\t\t\t   \"(IRQ %d).\\n\",\n\t\t\t\t   dev->eq_table.eq[MTHCA_EQ_CMD].msi_x_vector);\n\t\t\tmthca_warn(dev, \"Trying again with MSI-X disabled.\\n\");\n\t\t} else {\n\t\t\tmthca_err(dev, \"NOP command failed to generate interrupt \"\n\t\t\t\t  \"(IRQ %d), aborting.\\n\",\n\t\t\t\t  dev->pdev->irq);\n\t\t\tmthca_err(dev, \"BIOS or ACPI interrupt routing problem?\\n\");\n\t\t}\n\n\t\tgoto err_cmd_poll;\n\t}\n\n\tmthca_dbg(dev, \"NOP command IRQ test passed\\n\");\n\n\terr = mthca_init_cq_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"completion queue table, aborting.\\n\");\n\t\tgoto err_cmd_poll;\n\t}\n\n\terr = mthca_init_srq_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"shared receive queue table, aborting.\\n\");\n\t\tgoto err_cq_table_free;\n\t}\n\n\terr = mthca_init_qp_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"queue pair table, aborting.\\n\");\n\t\tgoto err_srq_table_free;\n\t}\n\n\terr = mthca_init_av_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"address vector table, aborting.\\n\");\n\t\tgoto err_qp_table_free;\n\t}\n\n\terr = mthca_init_mcg_table(dev);\n\tif (err) {\n\t\tmthca_err(dev, \"Failed to initialize \"\n\t\t\t  \"multicast group table, aborting.\\n\");\n\t\tgoto err_av_table_free;\n\t}\n\n\treturn 0;\n\nerr_av_table_free:\n\tmthca_cleanup_av_table(dev);\n\nerr_qp_table_free:\n\tmthca_cleanup_qp_table(dev);\n\nerr_srq_table_free:\n\tmthca_cleanup_srq_table(dev);\n\nerr_cq_table_free:\n\tmthca_cleanup_cq_table(dev);\n\nerr_cmd_poll:\n\tmthca_cmd_use_polling(dev);\n\nerr_eq_table_free:\n\tmthca_cleanup_eq_table(dev);\n\nerr_pd_free:\n\tmthca_pd_free(dev, &dev->driver_pd);\n\nerr_mr_table_free:\n\tmthca_cleanup_mr_table(dev);\n\nerr_pd_table_free:\n\tmthca_cleanup_pd_table(dev);\n\nerr_kar_unmap:\n\tiounmap(dev->kar);\n\nerr_uar_free:\n\tmthca_uar_free(dev, &dev->driver_uar);\n\nerr_uar_table_free:\n\tmthca_cleanup_uar_table(dev);\n\treturn err;\n}\n\nstatic int mthca_enable_msi_x(struct mthca_dev *mdev)\n{\n\tint err;\n\n\terr = pci_alloc_irq_vectors(mdev->pdev, 3, 3, PCI_IRQ_MSIX);\n\tif (err < 0)\n\t\treturn err;\n\n\tmdev->eq_table.eq[MTHCA_EQ_COMP ].msi_x_vector =\n\t\t\tpci_irq_vector(mdev->pdev, 0);\n\tmdev->eq_table.eq[MTHCA_EQ_ASYNC].msi_x_vector =\n\t\t\tpci_irq_vector(mdev->pdev, 1);\n\tmdev->eq_table.eq[MTHCA_EQ_CMD  ].msi_x_vector =\n\t\t\tpci_irq_vector(mdev->pdev, 2);\n\n\treturn 0;\n}\n\n \nenum {\n\tTAVOR,\t\t\t \n\tARBEL_COMPAT,\t\t \n\tARBEL_NATIVE,\t\t \n\tSINAI\t\t\t \n};\n\n#define MTHCA_FW_VER(major, minor, subminor) \\\n\t(((u64) (major) << 32) | ((u64) (minor) << 16) | (u64) (subminor))\n\nstatic struct {\n\tu64 latest_fw;\n\tu32 flags;\n} mthca_hca_table[] = {\n\t[TAVOR]        = { .latest_fw = MTHCA_FW_VER(3, 5, 0),\n\t\t\t   .flags     = 0 },\n\t[ARBEL_COMPAT] = { .latest_fw = MTHCA_FW_VER(4, 8, 200),\n\t\t\t   .flags     = MTHCA_FLAG_PCIE },\n\t[ARBEL_NATIVE] = { .latest_fw = MTHCA_FW_VER(5, 3, 0),\n\t\t\t   .flags     = MTHCA_FLAG_MEMFREE |\n\t\t\t\t\tMTHCA_FLAG_PCIE },\n\t[SINAI]        = { .latest_fw = MTHCA_FW_VER(1, 2, 0),\n\t\t\t   .flags     = MTHCA_FLAG_MEMFREE |\n\t\t\t\t\tMTHCA_FLAG_PCIE    |\n\t\t\t\t\tMTHCA_FLAG_SINAI_OPT }\n};\n\nstatic int __mthca_init_one(struct pci_dev *pdev, int hca_type)\n{\n\tint ddr_hidden = 0;\n\tint err;\n\tstruct mthca_dev *mdev;\n\n\tprintk(KERN_INFO PFX \"Initializing %s\\n\",\n\t       pci_name(pdev));\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot enable PCI device, \"\n\t\t\t\"aborting.\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM) ||\n\t    pci_resource_len(pdev, 0) != 1 << 20) {\n\t\tdev_err(&pdev->dev, \"Missing DCS, aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_pdev;\n\t}\n\tif (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"Missing UAR, aborting.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto err_disable_pdev;\n\t}\n\tif (!(pci_resource_flags(pdev, 4) & IORESOURCE_MEM))\n\t\tddr_hidden = 1;\n\n\terr = pci_request_regions(pdev, DRV_NAME);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Cannot obtain PCI resources, \"\n\t\t\t\"aborting.\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\n\tpci_set_master(pdev);\n\n\terr = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(64));\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Can't set PCI DMA mask, aborting.\\n\");\n\t\tgoto err_free_res;\n\t}\n\n\t \n\tdma_set_max_seg_size(&pdev->dev, 1024 * 1024 * 1024);\n\n\tmdev = ib_alloc_device(mthca_dev, ib_dev);\n\tif (!mdev) {\n\t\tdev_err(&pdev->dev, \"Device struct alloc failed, \"\n\t\t\t\"aborting.\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_res;\n\t}\n\n\tmdev->pdev = pdev;\n\n\tmdev->mthca_flags = mthca_hca_table[hca_type].flags;\n\tif (ddr_hidden)\n\t\tmdev->mthca_flags |= MTHCA_FLAG_DDR_HIDDEN;\n\n\t \n\terr = mthca_reset(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"Failed to reset HCA, aborting.\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\terr = mthca_cmd_init(mdev);\n\tif (err) {\n\t\tmthca_err(mdev, \"Failed to init command interface, aborting.\\n\");\n\t\tgoto err_free_dev;\n\t}\n\n\terr = mthca_tune_pci(mdev);\n\tif (err)\n\t\tgoto err_cmd;\n\n\terr = mthca_init_hca(mdev);\n\tif (err)\n\t\tgoto err_cmd;\n\n\tif (mdev->fw_ver < mthca_hca_table[hca_type].latest_fw) {\n\t\tmthca_warn(mdev, \"HCA FW version %d.%d.%03d is old (%d.%d.%03d is current).\\n\",\n\t\t\t   (int) (mdev->fw_ver >> 32), (int) (mdev->fw_ver >> 16) & 0xffff,\n\t\t\t   (int) (mdev->fw_ver & 0xffff),\n\t\t\t   (int) (mthca_hca_table[hca_type].latest_fw >> 32),\n\t\t\t   (int) (mthca_hca_table[hca_type].latest_fw >> 16) & 0xffff,\n\t\t\t   (int) (mthca_hca_table[hca_type].latest_fw & 0xffff));\n\t\tmthca_warn(mdev, \"If you have problems, try updating your HCA FW.\\n\");\n\t}\n\n\tif (msi_x && !mthca_enable_msi_x(mdev))\n\t\tmdev->mthca_flags |= MTHCA_FLAG_MSI_X;\n\n\terr = mthca_setup_hca(mdev);\n\tif (err == -EBUSY && (mdev->mthca_flags & MTHCA_FLAG_MSI_X)) {\n\t\tpci_free_irq_vectors(pdev);\n\t\tmdev->mthca_flags &= ~MTHCA_FLAG_MSI_X;\n\n\t\terr = mthca_setup_hca(mdev);\n\t}\n\n\tif (err)\n\t\tgoto err_close;\n\n\terr = mthca_register_device(mdev);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\terr = mthca_create_agents(mdev);\n\tif (err)\n\t\tgoto err_unregister;\n\n\tpci_set_drvdata(pdev, mdev);\n\tmdev->hca_type = hca_type;\n\n\tmdev->active = true;\n\n\treturn 0;\n\nerr_unregister:\n\tmthca_unregister_device(mdev);\n\nerr_cleanup:\n\tmthca_cleanup_mcg_table(mdev);\n\tmthca_cleanup_av_table(mdev);\n\tmthca_cleanup_qp_table(mdev);\n\tmthca_cleanup_srq_table(mdev);\n\tmthca_cleanup_cq_table(mdev);\n\tmthca_cmd_use_polling(mdev);\n\tmthca_cleanup_eq_table(mdev);\n\n\tmthca_pd_free(mdev, &mdev->driver_pd);\n\n\tmthca_cleanup_mr_table(mdev);\n\tmthca_cleanup_pd_table(mdev);\n\tmthca_cleanup_uar_table(mdev);\n\nerr_close:\n\tif (mdev->mthca_flags & MTHCA_FLAG_MSI_X)\n\t\tpci_free_irq_vectors(pdev);\n\n\tmthca_close_hca(mdev);\n\nerr_cmd:\n\tmthca_cmd_cleanup(mdev);\n\nerr_free_dev:\n\tib_dealloc_device(&mdev->ib_dev);\n\nerr_free_res:\n\tpci_release_regions(pdev);\n\nerr_disable_pdev:\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n\treturn err;\n}\n\nstatic void __mthca_remove_one(struct pci_dev *pdev)\n{\n\tstruct mthca_dev *mdev = pci_get_drvdata(pdev);\n\tint p;\n\n\tif (mdev) {\n\t\tmthca_free_agents(mdev);\n\t\tmthca_unregister_device(mdev);\n\n\t\tfor (p = 1; p <= mdev->limits.num_ports; ++p)\n\t\t\tmthca_CLOSE_IB(mdev, p);\n\n\t\tmthca_cleanup_mcg_table(mdev);\n\t\tmthca_cleanup_av_table(mdev);\n\t\tmthca_cleanup_qp_table(mdev);\n\t\tmthca_cleanup_srq_table(mdev);\n\t\tmthca_cleanup_cq_table(mdev);\n\t\tmthca_cmd_use_polling(mdev);\n\t\tmthca_cleanup_eq_table(mdev);\n\n\t\tmthca_pd_free(mdev, &mdev->driver_pd);\n\n\t\tmthca_cleanup_mr_table(mdev);\n\t\tmthca_cleanup_pd_table(mdev);\n\n\t\tiounmap(mdev->kar);\n\t\tmthca_uar_free(mdev, &mdev->driver_uar);\n\t\tmthca_cleanup_uar_table(mdev);\n\t\tmthca_close_hca(mdev);\n\t\tmthca_cmd_cleanup(mdev);\n\n\t\tif (mdev->mthca_flags & MTHCA_FLAG_MSI_X)\n\t\t\tpci_free_irq_vectors(pdev);\n\n\t\tib_dealloc_device(&mdev->ib_dev);\n\t\tpci_release_regions(pdev);\n\t\tpci_disable_device(pdev);\n\t\tpci_set_drvdata(pdev, NULL);\n\t}\n}\n\nint __mthca_restart_one(struct pci_dev *pdev)\n{\n\tstruct mthca_dev *mdev;\n\tint hca_type;\n\n\tmdev = pci_get_drvdata(pdev);\n\tif (!mdev)\n\t\treturn -ENODEV;\n\thca_type = mdev->hca_type;\n\t__mthca_remove_one(pdev);\n\treturn __mthca_init_one(pdev, hca_type);\n}\n\nstatic int mthca_init_one(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tint ret;\n\n\tmutex_lock(&mthca_device_mutex);\n\n\tprintk_once(KERN_INFO \"%s\", mthca_version);\n\n\tif (id->driver_data >= ARRAY_SIZE(mthca_hca_table)) {\n\t\tprintk(KERN_ERR PFX \"%s has invalid driver data %lx\\n\",\n\t\t       pci_name(pdev), id->driver_data);\n\t\tmutex_unlock(&mthca_device_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tret = __mthca_init_one(pdev, id->driver_data);\n\n\tmutex_unlock(&mthca_device_mutex);\n\n\treturn ret;\n}\n\nstatic void mthca_remove_one(struct pci_dev *pdev)\n{\n\tmutex_lock(&mthca_device_mutex);\n\t__mthca_remove_one(pdev);\n\tmutex_unlock(&mthca_device_mutex);\n}\n\nstatic const struct pci_device_id mthca_pci_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_TAVOR),\n\t  .driver_data = TAVOR },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOPSPIN, PCI_DEVICE_ID_MELLANOX_TAVOR),\n\t  .driver_data = TAVOR },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT),\n\t  .driver_data = ARBEL_COMPAT },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOPSPIN, PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT),\n\t  .driver_data = ARBEL_COMPAT },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_ARBEL),\n\t  .driver_data = ARBEL_NATIVE },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOPSPIN, PCI_DEVICE_ID_MELLANOX_ARBEL),\n\t  .driver_data = ARBEL_NATIVE },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_SINAI),\n\t  .driver_data = SINAI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOPSPIN, PCI_DEVICE_ID_MELLANOX_SINAI),\n\t  .driver_data = SINAI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_MELLANOX, PCI_DEVICE_ID_MELLANOX_SINAI_OLD),\n\t  .driver_data = SINAI },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOPSPIN, PCI_DEVICE_ID_MELLANOX_SINAI_OLD),\n\t  .driver_data = SINAI },\n\t{ 0, }\n};\n\nMODULE_DEVICE_TABLE(pci, mthca_pci_table);\n\nstatic struct pci_driver mthca_driver = {\n\t.name\t\t= DRV_NAME,\n\t.id_table\t= mthca_pci_table,\n\t.probe\t\t= mthca_init_one,\n\t.remove\t\t= mthca_remove_one,\n};\n\nstatic void __init __mthca_check_profile_val(const char *name, int *pval,\n\t\t\t\t\t     int pval_default)\n{\n\t \n\tint old_pval = *pval;\n\n\tif (old_pval <= 0)\n\t\t*pval = pval_default;\n\telse\n\t\t*pval = roundup_pow_of_two(old_pval);\n\n\tif (old_pval != *pval) {\n\t\tprintk(KERN_WARNING PFX \"Invalid value %d for %s in module parameter.\\n\",\n\t\t       old_pval, name);\n\t\tprintk(KERN_WARNING PFX \"Corrected %s to %d.\\n\", name, *pval);\n\t}\n}\n\n#define mthca_check_profile_val(name, default)\t\t\t\t\\\n\t__mthca_check_profile_val(#name, &hca_profile.name, default)\n\nstatic void __init mthca_validate_profile(void)\n{\n\tmthca_check_profile_val(num_qp,            MTHCA_DEFAULT_NUM_QP);\n\tmthca_check_profile_val(rdb_per_qp,        MTHCA_DEFAULT_RDB_PER_QP);\n\tmthca_check_profile_val(num_cq,            MTHCA_DEFAULT_NUM_CQ);\n\tmthca_check_profile_val(num_mcg, \t   MTHCA_DEFAULT_NUM_MCG);\n\tmthca_check_profile_val(num_mpt, \t   MTHCA_DEFAULT_NUM_MPT);\n\tmthca_check_profile_val(num_mtt, \t   MTHCA_DEFAULT_NUM_MTT);\n\tmthca_check_profile_val(num_udav,          MTHCA_DEFAULT_NUM_UDAV);\n\tmthca_check_profile_val(fmr_reserved_mtts, MTHCA_DEFAULT_NUM_RESERVED_MTTS);\n\n\tif (hca_profile.fmr_reserved_mtts >= hca_profile.num_mtt) {\n\t\tprintk(KERN_WARNING PFX \"Invalid fmr_reserved_mtts module parameter %d.\\n\",\n\t\t       hca_profile.fmr_reserved_mtts);\n\t\tprintk(KERN_WARNING PFX \"(Must be smaller than num_mtt %d)\\n\",\n\t\t       hca_profile.num_mtt);\n\t\thca_profile.fmr_reserved_mtts = hca_profile.num_mtt / 2;\n\t\tprintk(KERN_WARNING PFX \"Corrected fmr_reserved_mtts to %d.\\n\",\n\t\t       hca_profile.fmr_reserved_mtts);\n\t}\n\n\tif ((log_mtts_per_seg < 1) || (log_mtts_per_seg > 5)) {\n\t\tprintk(KERN_WARNING PFX \"bad log_mtts_per_seg (%d). Using default - %d\\n\",\n\t\t       log_mtts_per_seg, ilog2(MTHCA_MTT_SEG_SIZE / 8));\n\t\tlog_mtts_per_seg = ilog2(MTHCA_MTT_SEG_SIZE / 8);\n\t}\n}\n\nstatic int __init mthca_init(void)\n{\n\tint ret;\n\n\tmthca_validate_profile();\n\n\tret = mthca_catas_init();\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_register_driver(&mthca_driver);\n\tif (ret < 0) {\n\t\tmthca_catas_cleanup();\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit mthca_cleanup(void)\n{\n\tpci_unregister_driver(&mthca_driver);\n\tmthca_catas_cleanup();\n}\n\nmodule_init(mthca_init);\nmodule_exit(mthca_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}