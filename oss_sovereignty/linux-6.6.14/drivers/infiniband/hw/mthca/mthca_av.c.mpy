{
  "module_name": "mthca_av.c",
  "hash_id": "7e01f38baaabcf8b17aa7c8abd93827cc0093662f30a4ba15473026a86c8b649",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_av.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_cache.h>\n\n#include \"mthca_dev.h\"\n\nenum {\n      MTHCA_RATE_TAVOR_FULL   = 0,\n      MTHCA_RATE_TAVOR_1X     = 1,\n      MTHCA_RATE_TAVOR_4X     = 2,\n      MTHCA_RATE_TAVOR_1X_DDR = 3\n};\n\nenum {\n      MTHCA_RATE_MEMFREE_FULL    = 0,\n      MTHCA_RATE_MEMFREE_QUARTER = 1,\n      MTHCA_RATE_MEMFREE_EIGHTH  = 2,\n      MTHCA_RATE_MEMFREE_HALF    = 3\n};\n\nstruct mthca_av {\n\t__be32 port_pd;\n\tu8     reserved1;\n\tu8     g_slid;\n\t__be16 dlid;\n\tu8     reserved2;\n\tu8     gid_index;\n\tu8     msg_sr;\n\tu8     hop_limit;\n\t__be32 sl_tclass_flowlabel;\n\t__be32 dgid[4];\n};\n\nstatic enum ib_rate memfree_rate_to_ib(u8 mthca_rate, u8 port_rate)\n{\n\tswitch (mthca_rate) {\n\tcase MTHCA_RATE_MEMFREE_EIGHTH:\n\t\treturn mult_to_ib_rate(port_rate >> 3);\n\tcase MTHCA_RATE_MEMFREE_QUARTER:\n\t\treturn mult_to_ib_rate(port_rate >> 2);\n\tcase MTHCA_RATE_MEMFREE_HALF:\n\t\treturn mult_to_ib_rate(port_rate >> 1);\n\tcase MTHCA_RATE_MEMFREE_FULL:\n\tdefault:\n\t\treturn mult_to_ib_rate(port_rate);\n\t}\n}\n\nstatic enum ib_rate tavor_rate_to_ib(u8 mthca_rate, u8 port_rate)\n{\n\tswitch (mthca_rate) {\n\tcase MTHCA_RATE_TAVOR_1X:     return IB_RATE_2_5_GBPS;\n\tcase MTHCA_RATE_TAVOR_1X_DDR: return IB_RATE_5_GBPS;\n\tcase MTHCA_RATE_TAVOR_4X:     return IB_RATE_10_GBPS;\n\tdefault:\t\t      return mult_to_ib_rate(port_rate);\n\t}\n}\n\nenum ib_rate mthca_rate_to_ib(struct mthca_dev *dev, u8 mthca_rate, u32 port)\n{\n\tif (mthca_is_memfree(dev)) {\n\t\t \n\t\tif (dev->limits.stat_rate_support == 0x3 && mthca_rate)\n\t\t\treturn IB_RATE_2_5_GBPS;\n\n\t\treturn memfree_rate_to_ib(mthca_rate, dev->rate[port - 1]);\n\t} else\n\t\treturn tavor_rate_to_ib(mthca_rate, dev->rate[port - 1]);\n}\n\nstatic u8 ib_rate_to_memfree(u8 req_rate, u8 cur_rate)\n{\n\tif (cur_rate <= req_rate)\n\t\treturn 0;\n\n\t \n\tswitch ((cur_rate - 1) / req_rate) {\n\tcase 0:\t return MTHCA_RATE_MEMFREE_FULL;\n\tcase 1:\t return MTHCA_RATE_MEMFREE_HALF;\n\tcase 2:\n\tcase 3:\t return MTHCA_RATE_MEMFREE_QUARTER;\n\tdefault: return MTHCA_RATE_MEMFREE_EIGHTH;\n\t}\n}\n\nstatic u8 ib_rate_to_tavor(u8 static_rate)\n{\n\tswitch (static_rate) {\n\tcase IB_RATE_2_5_GBPS: return MTHCA_RATE_TAVOR_1X;\n\tcase IB_RATE_5_GBPS:   return MTHCA_RATE_TAVOR_1X_DDR;\n\tcase IB_RATE_10_GBPS:  return MTHCA_RATE_TAVOR_4X;\n\tdefault:\t       return MTHCA_RATE_TAVOR_FULL;\n\t}\n}\n\nu8 mthca_get_rate(struct mthca_dev *dev, int static_rate, u32 port)\n{\n\tu8 rate;\n\n\tif (!static_rate || ib_rate_to_mult(static_rate) >= dev->rate[port - 1])\n\t\treturn 0;\n\n\tif (mthca_is_memfree(dev))\n\t\trate = ib_rate_to_memfree(ib_rate_to_mult(static_rate),\n\t\t\t\t\t  dev->rate[port - 1]);\n\telse\n\t\trate = ib_rate_to_tavor(static_rate);\n\n\tif (!(dev->limits.stat_rate_support & (1 << rate)))\n\t\trate = 1;\n\n\treturn rate;\n}\n\nint mthca_create_ah(struct mthca_dev *dev,\n\t\t    struct mthca_pd *pd,\n\t\t    struct rdma_ah_attr *ah_attr,\n\t\t    struct mthca_ah *ah)\n{\n\tu32 index = -1;\n\tstruct mthca_av *av = NULL;\n\n\tah->type = MTHCA_AH_PCI_POOL;\n\n\tif (mthca_is_memfree(dev)) {\n\t\tah->av   = kmalloc(sizeof *ah->av, GFP_ATOMIC);\n\t\tif (!ah->av)\n\t\t\treturn -ENOMEM;\n\n\t\tah->type = MTHCA_AH_KMALLOC;\n\t\tav       = ah->av;\n\t} else if (!atomic_read(&pd->sqp_count) &&\n\t\t !(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\n\t\tindex = mthca_alloc(&dev->av_table.alloc);\n\n\t\t \n\t\tif (index == -1)\n\t\t\tgoto on_hca_fail;\n\n\t\tav = kmalloc(sizeof *av, GFP_ATOMIC);\n\t\tif (!av)\n\t\t\tgoto on_hca_fail;\n\n\t\tah->type = MTHCA_AH_ON_HCA;\n\t\tah->avdma  = dev->av_table.ddr_av_base +\n\t\t\tindex * MTHCA_AV_SIZE;\n\t}\n\non_hca_fail:\n\tif (ah->type == MTHCA_AH_PCI_POOL) {\n\t\tah->av = dma_pool_zalloc(dev->av_table.pool,\n\t\t\t\t\t GFP_ATOMIC, &ah->avdma);\n\t\tif (!ah->av)\n\t\t\treturn -ENOMEM;\n\n\t\tav = ah->av;\n\t}\n\n\tah->key = pd->ntmr.ibmr.lkey;\n\n\tav->port_pd = cpu_to_be32(pd->pd_num |\n\t\t\t\t  (rdma_ah_get_port_num(ah_attr) << 24));\n\tav->g_slid  = rdma_ah_get_path_bits(ah_attr);\n\tav->dlid    = cpu_to_be16(rdma_ah_get_dlid(ah_attr));\n\tav->msg_sr  = (3 << 4) |  \n\t\tmthca_get_rate(dev, rdma_ah_get_static_rate(ah_attr),\n\t\t\t       rdma_ah_get_port_num(ah_attr));\n\tav->sl_tclass_flowlabel = cpu_to_be32(rdma_ah_get_sl(ah_attr) << 28);\n\tif (rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) {\n\t\tconst struct ib_global_route *grh = rdma_ah_read_grh(ah_attr);\n\n\t\tav->g_slid |= 0x80;\n\t\tav->gid_index = (rdma_ah_get_port_num(ah_attr) - 1) *\n\t\t\t\t  dev->limits.gid_table_len +\n\t\t\t\t  grh->sgid_index;\n\t\tav->hop_limit = grh->hop_limit;\n\t\tav->sl_tclass_flowlabel |=\n\t\t\tcpu_to_be32((grh->traffic_class << 20) |\n\t\t\t\t    grh->flow_label);\n\t\tmemcpy(av->dgid, grh->dgid.raw, 16);\n\t} else {\n\t\t \n\t\tav->dgid[3] = cpu_to_be32(2);\n\t}\n\n\tif (0) {\n\t\tint j;\n\n\t\tmthca_dbg(dev, \"Created UDAV at %p/%08lx:\\n\",\n\t\t\t  av, (unsigned long) ah->avdma);\n\t\tfor (j = 0; j < 8; ++j)\n\t\t\tprintk(KERN_DEBUG \"  [%2x] %08x\\n\",\n\t\t\t       j * 4, be32_to_cpu(((__be32 *) av)[j]));\n\t}\n\n\tif (ah->type == MTHCA_AH_ON_HCA) {\n\t\tmemcpy_toio(dev->av_table.av_map + index * MTHCA_AV_SIZE,\n\t\t\t    av, MTHCA_AV_SIZE);\n\t\tkfree(av);\n\t}\n\n\treturn 0;\n}\n\nint mthca_destroy_ah(struct mthca_dev *dev, struct mthca_ah *ah)\n{\n\tswitch (ah->type) {\n\tcase MTHCA_AH_ON_HCA:\n\t\tmthca_free(&dev->av_table.alloc,\n\t\t\t   (ah->avdma - dev->av_table.ddr_av_base) /\n\t\t\t   MTHCA_AV_SIZE);\n\t\tbreak;\n\n\tcase MTHCA_AH_PCI_POOL:\n\t\tdma_pool_free(dev->av_table.pool, ah->av, ah->avdma);\n\t\tbreak;\n\n\tcase MTHCA_AH_KMALLOC:\n\t\tkfree(ah->av);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint mthca_ah_grh_present(struct mthca_ah *ah)\n{\n\treturn !!(ah->av->g_slid & 0x80);\n}\n\nint mthca_read_ah(struct mthca_dev *dev, struct mthca_ah *ah,\n\t\t  struct ib_ud_header *header)\n{\n\tif (ah->type == MTHCA_AH_ON_HCA)\n\t\treturn -EINVAL;\n\n\theader->lrh.service_level   = be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28;\n\theader->lrh.destination_lid = ah->av->dlid;\n\theader->lrh.source_lid      = cpu_to_be16(ah->av->g_slid & 0x7f);\n\tif (mthca_ah_grh_present(ah)) {\n\t\theader->grh.traffic_class =\n\t\t\t(be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 20) & 0xff;\n\t\theader->grh.flow_label    =\n\t\t\tah->av->sl_tclass_flowlabel & cpu_to_be32(0xfffff);\n\t\theader->grh.hop_limit     = ah->av->hop_limit;\n\t\theader->grh.source_gid = ah->ibah.sgid_attr->gid;\n\t\tmemcpy(header->grh.destination_gid.raw,\n\t\t       ah->av->dgid, 16);\n\t}\n\n\treturn 0;\n}\n\nint mthca_ah_query(struct ib_ah *ibah, struct rdma_ah_attr *attr)\n{\n\tstruct mthca_ah *ah   = to_mah(ibah);\n\tstruct mthca_dev *dev = to_mdev(ibah->device);\n\tu32 port_num = be32_to_cpu(ah->av->port_pd) >> 24;\n\n\t \n\tif (ah->type == MTHCA_AH_ON_HCA)\n\t\treturn -ENOSYS;\n\n\tmemset(attr, 0, sizeof *attr);\n\tattr->type = ibah->type;\n\trdma_ah_set_dlid(attr, be16_to_cpu(ah->av->dlid));\n\trdma_ah_set_sl(attr, be32_to_cpu(ah->av->sl_tclass_flowlabel) >> 28);\n\trdma_ah_set_port_num(attr, port_num);\n\trdma_ah_set_static_rate(attr,\n\t\t\t\tmthca_rate_to_ib(dev, ah->av->msg_sr & 0x7,\n\t\t\t\t\t\t port_num));\n\trdma_ah_set_path_bits(attr, ah->av->g_slid & 0x7F);\n\tif (mthca_ah_grh_present(ah)) {\n\t\tu32 tc_fl = be32_to_cpu(ah->av->sl_tclass_flowlabel);\n\n\t\trdma_ah_set_grh(attr, NULL,\n\t\t\t\ttc_fl & 0xfffff,\n\t\t\t\tah->av->gid_index &\n\t\t\t\t(dev->limits.gid_table_len - 1),\n\t\t\t\tah->av->hop_limit,\n\t\t\t\t(tc_fl >> 20) & 0xff);\n\t\trdma_ah_set_dgid_raw(attr, ah->av->dgid);\n\t}\n\n\treturn 0;\n}\n\nint mthca_init_av_table(struct mthca_dev *dev)\n{\n\tint err;\n\n\tif (mthca_is_memfree(dev))\n\t\treturn 0;\n\n\terr = mthca_alloc_init(&dev->av_table.alloc,\n\t\t\t       dev->av_table.num_ddr_avs,\n\t\t\t       dev->av_table.num_ddr_avs - 1,\n\t\t\t       0);\n\tif (err)\n\t\treturn err;\n\n\tdev->av_table.pool = dma_pool_create(\"mthca_av\", &dev->pdev->dev,\n\t\t\t\t\t     MTHCA_AV_SIZE,\n\t\t\t\t\t     MTHCA_AV_SIZE, 0);\n\tif (!dev->av_table.pool)\n\t\tgoto out_free_alloc;\n\n\tif (!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\n\t\tdev->av_table.av_map = ioremap(pci_resource_start(dev->pdev, 4) +\n\t\t\t\t\t       dev->av_table.ddr_av_base -\n\t\t\t\t\t       dev->ddr_start,\n\t\t\t\t\t       dev->av_table.num_ddr_avs *\n\t\t\t\t\t       MTHCA_AV_SIZE);\n\t\tif (!dev->av_table.av_map)\n\t\t\tgoto out_free_pool;\n\t} else\n\t\tdev->av_table.av_map = NULL;\n\n\treturn 0;\n\n out_free_pool:\n\tdma_pool_destroy(dev->av_table.pool);\n\n out_free_alloc:\n\tmthca_alloc_cleanup(&dev->av_table.alloc);\n\treturn -ENOMEM;\n}\n\nvoid mthca_cleanup_av_table(struct mthca_dev *dev)\n{\n\tif (mthca_is_memfree(dev))\n\t\treturn;\n\n\tif (dev->av_table.av_map)\n\t\tiounmap(dev->av_table.av_map);\n\tdma_pool_destroy(dev->av_table.pool);\n\tmthca_alloc_cleanup(&dev->av_table.alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}