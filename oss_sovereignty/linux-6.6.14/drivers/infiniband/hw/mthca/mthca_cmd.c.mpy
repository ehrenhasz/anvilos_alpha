{
  "module_name": "mthca_cmd.c",
  "hash_id": "418867719567958e71e4a78543735ef521d3c511743693fdebb1755f8607666c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_cmd.c",
  "human_readable_source": " \n\n#include <linux/completion.h>\n#include <linux/pci.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/io.h>\n#include <rdma/ib_mad.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_config_reg.h\"\n#include \"mthca_cmd.h\"\n#include \"mthca_memfree.h\"\n\n#define CMD_POLL_TOKEN 0xffff\n\nenum {\n\tHCR_IN_PARAM_OFFSET    = 0x00,\n\tHCR_IN_MODIFIER_OFFSET = 0x08,\n\tHCR_OUT_PARAM_OFFSET   = 0x0c,\n\tHCR_TOKEN_OFFSET       = 0x14,\n\tHCR_STATUS_OFFSET      = 0x18,\n\n\tHCR_OPMOD_SHIFT        = 12,\n\tHCA_E_BIT              = 22,\n\tHCR_GO_BIT             = 23\n};\n\nenum {\n\t \n\tCMD_SYS_EN          = 0x1,\n\tCMD_SYS_DIS         = 0x2,\n\tCMD_MAP_FA          = 0xfff,\n\tCMD_UNMAP_FA        = 0xffe,\n\tCMD_RUN_FW          = 0xff6,\n\tCMD_MOD_STAT_CFG    = 0x34,\n\tCMD_QUERY_DEV_LIM   = 0x3,\n\tCMD_QUERY_FW        = 0x4,\n\tCMD_ENABLE_LAM      = 0xff8,\n\tCMD_DISABLE_LAM     = 0xff7,\n\tCMD_QUERY_DDR       = 0x5,\n\tCMD_QUERY_ADAPTER   = 0x6,\n\tCMD_INIT_HCA        = 0x7,\n\tCMD_CLOSE_HCA       = 0x8,\n\tCMD_INIT_IB         = 0x9,\n\tCMD_CLOSE_IB        = 0xa,\n\tCMD_QUERY_HCA       = 0xb,\n\tCMD_SET_IB          = 0xc,\n\tCMD_ACCESS_DDR      = 0x2e,\n\tCMD_MAP_ICM         = 0xffa,\n\tCMD_UNMAP_ICM       = 0xff9,\n\tCMD_MAP_ICM_AUX     = 0xffc,\n\tCMD_UNMAP_ICM_AUX   = 0xffb,\n\tCMD_SET_ICM_SIZE    = 0xffd,\n\n\t \n\tCMD_SW2HW_MPT \t    = 0xd,\n\tCMD_QUERY_MPT \t    = 0xe,\n\tCMD_HW2SW_MPT \t    = 0xf,\n\tCMD_READ_MTT        = 0x10,\n\tCMD_WRITE_MTT       = 0x11,\n\tCMD_SYNC_TPT        = 0x2f,\n\n\t \n\tCMD_MAP_EQ          = 0x12,\n\tCMD_SW2HW_EQ \t    = 0x13,\n\tCMD_HW2SW_EQ \t    = 0x14,\n\tCMD_QUERY_EQ        = 0x15,\n\n\t \n\tCMD_SW2HW_CQ \t    = 0x16,\n\tCMD_HW2SW_CQ \t    = 0x17,\n\tCMD_QUERY_CQ \t    = 0x18,\n\tCMD_RESIZE_CQ       = 0x2c,\n\n\t \n\tCMD_SW2HW_SRQ \t    = 0x35,\n\tCMD_HW2SW_SRQ \t    = 0x36,\n\tCMD_QUERY_SRQ       = 0x37,\n\tCMD_ARM_SRQ         = 0x40,\n\n\t \n\tCMD_RST2INIT_QPEE   = 0x19,\n\tCMD_INIT2RTR_QPEE   = 0x1a,\n\tCMD_RTR2RTS_QPEE    = 0x1b,\n\tCMD_RTS2RTS_QPEE    = 0x1c,\n\tCMD_SQERR2RTS_QPEE  = 0x1d,\n\tCMD_2ERR_QPEE       = 0x1e,\n\tCMD_RTS2SQD_QPEE    = 0x1f,\n\tCMD_SQD2SQD_QPEE    = 0x38,\n\tCMD_SQD2RTS_QPEE    = 0x20,\n\tCMD_ERR2RST_QPEE    = 0x21,\n\tCMD_QUERY_QPEE      = 0x22,\n\tCMD_INIT2INIT_QPEE  = 0x2d,\n\tCMD_SUSPEND_QPEE    = 0x32,\n\tCMD_UNSUSPEND_QPEE  = 0x33,\n\t \n\tCMD_CONF_SPECIAL_QP = 0x23,\n\tCMD_MAD_IFC         = 0x24,\n\n\t \n\tCMD_READ_MGM        = 0x25,\n\tCMD_WRITE_MGM       = 0x26,\n\tCMD_MGID_HASH       = 0x27,\n\n\t \n\tCMD_DIAG_RPRT       = 0x30,\n\tCMD_NOP             = 0x31,\n\n\t \n\tCMD_QUERY_DEBUG_MSG = 0x2a,\n\tCMD_SET_DEBUG_MSG   = 0x2b,\n};\n\n \n#if 0\n \nenum {\n\tCMD_TIME_CLASS_A = (HZ + 999) / 1000 + 1,\n\tCMD_TIME_CLASS_B = (HZ +  99) /  100 + 1,\n\tCMD_TIME_CLASS_C = (HZ +   9) /   10 + 1,\n\tCMD_TIME_CLASS_D = 60 * HZ\n};\n#else\nenum {\n\tCMD_TIME_CLASS_A = 60 * HZ,\n\tCMD_TIME_CLASS_B = 60 * HZ,\n\tCMD_TIME_CLASS_C = 60 * HZ,\n\tCMD_TIME_CLASS_D = 60 * HZ\n};\n#endif\n\nenum {\n\tGO_BIT_TIMEOUT = HZ * 10\n};\n\nstruct mthca_cmd_context {\n\tstruct completion done;\n\tint               result;\n\tint               next;\n\tu64               out_param;\n\tu16               token;\n\tu8                status;\n};\n\nstatic int fw_cmd_doorbell = 0;\nmodule_param(fw_cmd_doorbell, int, 0644);\nMODULE_PARM_DESC(fw_cmd_doorbell, \"post FW commands through doorbell page if nonzero \"\n\t\t \"(and supported by FW)\");\n\nstatic inline int go_bit(struct mthca_dev *dev)\n{\n\treturn readl(dev->hcr + HCR_STATUS_OFFSET) &\n\t\tswab32(1 << HCR_GO_BIT);\n}\n\nstatic void mthca_cmd_post_dbell(struct mthca_dev *dev,\n\t\t\t\t u64 in_param,\n\t\t\t\t u64 out_param,\n\t\t\t\t u32 in_modifier,\n\t\t\t\t u8 op_modifier,\n\t\t\t\t u16 op,\n\t\t\t\t u16 token)\n{\n\tvoid __iomem *ptr = dev->cmd.dbell_map;\n\tu16 *offs = dev->cmd.dbell_offsets;\n\n\t__raw_writel((__force u32) cpu_to_be32(in_param >> 32),           ptr + offs[0]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful),  ptr + offs[1]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32(in_modifier),              ptr + offs[2]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32(out_param >> 32),          ptr + offs[3]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), ptr + offs[4]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32(token << 16),              ptr + offs[5]);\n\twmb();\n\t__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT)                |\n\t\t\t\t\t       (1 << HCA_E_BIT)                 |\n\t\t\t\t\t       (op_modifier << HCR_OPMOD_SHIFT) |\n\t\t\t\t\t\top),\t\t\t  ptr + offs[6]);\n\twmb();\n\t__raw_writel((__force u32) 0,                                     ptr + offs[7]);\n\twmb();\n}\n\nstatic int mthca_cmd_post_hcr(struct mthca_dev *dev,\n\t\t\t      u64 in_param,\n\t\t\t      u64 out_param,\n\t\t\t      u32 in_modifier,\n\t\t\t      u8 op_modifier,\n\t\t\t      u16 op,\n\t\t\t      u16 token,\n\t\t\t      int event)\n{\n\tif (event) {\n\t\tunsigned long end = jiffies + GO_BIT_TIMEOUT;\n\n\t\twhile (go_bit(dev) && time_before(jiffies, end)) {\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tschedule();\n\t\t}\n\t}\n\n\tif (go_bit(dev))\n\t\treturn -EAGAIN;\n\n\t \n\t__raw_writel((__force u32) cpu_to_be32(in_param >> 32),           dev->hcr + 0 * 4);\n\t__raw_writel((__force u32) cpu_to_be32(in_param & 0xfffffffful),  dev->hcr + 1 * 4);\n\t__raw_writel((__force u32) cpu_to_be32(in_modifier),              dev->hcr + 2 * 4);\n\t__raw_writel((__force u32) cpu_to_be32(out_param >> 32),          dev->hcr + 3 * 4);\n\t__raw_writel((__force u32) cpu_to_be32(out_param & 0xfffffffful), dev->hcr + 4 * 4);\n\t__raw_writel((__force u32) cpu_to_be32(token << 16),              dev->hcr + 5 * 4);\n\n\t \n\twmb();\n\n\t__raw_writel((__force u32) cpu_to_be32((1 << HCR_GO_BIT)                |\n\t\t\t\t\t       (event ? (1 << HCA_E_BIT) : 0)   |\n\t\t\t\t\t       (op_modifier << HCR_OPMOD_SHIFT) |\n\t\t\t\t\t       op),                       dev->hcr + 6 * 4);\n\n\treturn 0;\n}\n\nstatic int mthca_cmd_post(struct mthca_dev *dev,\n\t\t\t  u64 in_param,\n\t\t\t  u64 out_param,\n\t\t\t  u32 in_modifier,\n\t\t\t  u8 op_modifier,\n\t\t\t  u16 op,\n\t\t\t  u16 token,\n\t\t\t  int event)\n{\n\tint err = 0;\n\n\tmutex_lock(&dev->cmd.hcr_mutex);\n\n\tif (event && dev->cmd.flags & MTHCA_CMD_POST_DOORBELLS && fw_cmd_doorbell)\n\t\tmthca_cmd_post_dbell(dev, in_param, out_param, in_modifier,\n\t\t\t\t\t   op_modifier, op, token);\n\telse\n\t\terr = mthca_cmd_post_hcr(dev, in_param, out_param, in_modifier,\n\t\t\t\t\t op_modifier, op, token, event);\n\n\tmutex_unlock(&dev->cmd.hcr_mutex);\n\treturn err;\n}\n\n\nstatic int mthca_status_to_errno(u8 status)\n{\n\tstatic const int trans_table[] = {\n\t\t[MTHCA_CMD_STAT_INTERNAL_ERR]   = -EIO,\n\t\t[MTHCA_CMD_STAT_BAD_OP]         = -EPERM,\n\t\t[MTHCA_CMD_STAT_BAD_PARAM]      = -EINVAL,\n\t\t[MTHCA_CMD_STAT_BAD_SYS_STATE]  = -ENXIO,\n\t\t[MTHCA_CMD_STAT_BAD_RESOURCE]   = -EBADF,\n\t\t[MTHCA_CMD_STAT_RESOURCE_BUSY]  = -EBUSY,\n\t\t[MTHCA_CMD_STAT_DDR_MEM_ERR]    = -ENOMEM,\n\t\t[MTHCA_CMD_STAT_EXCEED_LIM]     = -ENOMEM,\n\t\t[MTHCA_CMD_STAT_BAD_RES_STATE]  = -EBADF,\n\t\t[MTHCA_CMD_STAT_BAD_INDEX]      = -EBADF,\n\t\t[MTHCA_CMD_STAT_BAD_NVMEM]      = -EFAULT,\n\t\t[MTHCA_CMD_STAT_BAD_QPEE_STATE] = -EINVAL,\n\t\t[MTHCA_CMD_STAT_BAD_SEG_PARAM]  = -EFAULT,\n\t\t[MTHCA_CMD_STAT_REG_BOUND]      = -EBUSY,\n\t\t[MTHCA_CMD_STAT_LAM_NOT_PRE]    = -EAGAIN,\n\t\t[MTHCA_CMD_STAT_BAD_PKT]        = -EBADMSG,\n\t\t[MTHCA_CMD_STAT_BAD_SIZE]       = -ENOMEM,\n\t};\n\n\tif (status >= ARRAY_SIZE(trans_table) ||\n\t\t\t(status != MTHCA_CMD_STAT_OK\n\t\t\t && trans_table[status] == 0))\n\t\treturn -EINVAL;\n\n\treturn trans_table[status];\n}\n\n\nstatic int mthca_cmd_poll(struct mthca_dev *dev,\n\t\t\t  u64 in_param,\n\t\t\t  u64 *out_param,\n\t\t\t  int out_is_imm,\n\t\t\t  u32 in_modifier,\n\t\t\t  u8 op_modifier,\n\t\t\t  u16 op,\n\t\t\t  unsigned long timeout)\n{\n\tint err = 0;\n\tunsigned long end;\n\tu8 status;\n\n\tdown(&dev->cmd.poll_sem);\n\n\terr = mthca_cmd_post(dev, in_param,\n\t\t\t     out_param ? *out_param : 0,\n\t\t\t     in_modifier, op_modifier,\n\t\t\t     op, CMD_POLL_TOKEN, 0);\n\tif (err)\n\t\tgoto out;\n\n\tend = timeout + jiffies;\n\twhile (go_bit(dev) && time_before(jiffies, end)) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tschedule();\n\t}\n\n\tif (go_bit(dev)) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (out_is_imm && out_param) {\n\t\t*out_param =\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(dev->hcr + HCR_OUT_PARAM_OFFSET)) << 32 |\n\t\t\t(u64) be32_to_cpu((__force __be32)\n\t\t\t\t\t  __raw_readl(dev->hcr + HCR_OUT_PARAM_OFFSET + 4));\n\t} else if (out_is_imm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tstatus = be32_to_cpu((__force __be32) __raw_readl(dev->hcr + HCR_STATUS_OFFSET)) >> 24;\n\tif (status) {\n\t\tmthca_dbg(dev, \"Command %02x completed with status %02x\\n\",\n\t\t\t  op, status);\n\t\terr = mthca_status_to_errno(status);\n\t}\n\nout:\n\tup(&dev->cmd.poll_sem);\n\treturn err;\n}\n\nvoid mthca_cmd_event(struct mthca_dev *dev,\n\t\t     u16 token,\n\t\t     u8  status,\n\t\t     u64 out_param)\n{\n\tstruct mthca_cmd_context *context =\n\t\t&dev->cmd.context[token & dev->cmd.token_mask];\n\n\t \n\tif (token != context->token)\n\t\treturn;\n\n\tcontext->result    = 0;\n\tcontext->status    = status;\n\tcontext->out_param = out_param;\n\n\tcomplete(&context->done);\n}\n\nstatic int mthca_cmd_wait(struct mthca_dev *dev,\n\t\t\t  u64 in_param,\n\t\t\t  u64 *out_param,\n\t\t\t  int out_is_imm,\n\t\t\t  u32 in_modifier,\n\t\t\t  u8 op_modifier,\n\t\t\t  u16 op,\n\t\t\t  unsigned long timeout)\n{\n\tint err = 0;\n\tstruct mthca_cmd_context *context;\n\n\tdown(&dev->cmd.event_sem);\n\n\tspin_lock(&dev->cmd.context_lock);\n\tBUG_ON(dev->cmd.free_head < 0);\n\tcontext = &dev->cmd.context[dev->cmd.free_head];\n\tcontext->token += dev->cmd.token_mask + 1;\n\tdev->cmd.free_head = context->next;\n\tspin_unlock(&dev->cmd.context_lock);\n\n\tinit_completion(&context->done);\n\n\terr = mthca_cmd_post(dev, in_param,\n\t\t\t     out_param ? *out_param : 0,\n\t\t\t     in_modifier, op_modifier,\n\t\t\t     op, context->token, 1);\n\tif (err)\n\t\tgoto out;\n\n\tif (!wait_for_completion_timeout(&context->done, timeout)) {\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terr = context->result;\n\tif (err)\n\t\tgoto out;\n\n\tif (context->status) {\n\t\tmthca_dbg(dev, \"Command %02x completed with status %02x\\n\",\n\t\t\t  op, context->status);\n\t\terr = mthca_status_to_errno(context->status);\n\t}\n\n\tif (out_is_imm && out_param) {\n\t\t*out_param = context->out_param;\n\t} else if (out_is_imm) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tspin_lock(&dev->cmd.context_lock);\n\tcontext->next = dev->cmd.free_head;\n\tdev->cmd.free_head = context - dev->cmd.context;\n\tspin_unlock(&dev->cmd.context_lock);\n\n\tup(&dev->cmd.event_sem);\n\treturn err;\n}\n\n \nstatic int mthca_cmd_box(struct mthca_dev *dev,\n\t\t\t u64 in_param,\n\t\t\t u64 out_param,\n\t\t\t u32 in_modifier,\n\t\t\t u8 op_modifier,\n\t\t\t u16 op,\n\t\t\t unsigned long timeout)\n{\n\tif (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)\n\t\treturn mthca_cmd_wait(dev, in_param, &out_param, 0,\n\t\t\t\t      in_modifier, op_modifier, op,\n\t\t\t\t      timeout);\n\telse\n\t\treturn mthca_cmd_poll(dev, in_param, &out_param, 0,\n\t\t\t\t      in_modifier, op_modifier, op,\n\t\t\t\t      timeout);\n}\n\n \nstatic int mthca_cmd(struct mthca_dev *dev,\n\t\t     u64 in_param,\n\t\t     u32 in_modifier,\n\t\t     u8 op_modifier,\n\t\t     u16 op,\n\t\t     unsigned long timeout)\n{\n\treturn mthca_cmd_box(dev, in_param, 0, in_modifier,\n\t\t\t     op_modifier, op, timeout);\n}\n\n \nstatic int mthca_cmd_imm(struct mthca_dev *dev,\n\t\t\t u64 in_param,\n\t\t\t u64 *out_param,\n\t\t\t u32 in_modifier,\n\t\t\t u8 op_modifier,\n\t\t\t u16 op,\n\t\t\t unsigned long timeout)\n{\n\tif (dev->cmd.flags & MTHCA_CMD_USE_EVENTS)\n\t\treturn mthca_cmd_wait(dev, in_param, out_param, 1,\n\t\t\t\t      in_modifier, op_modifier, op,\n\t\t\t\t      timeout);\n\telse\n\t\treturn mthca_cmd_poll(dev, in_param, out_param, 1,\n\t\t\t\t      in_modifier, op_modifier, op,\n\t\t\t\t      timeout);\n}\n\nint mthca_cmd_init(struct mthca_dev *dev)\n{\n\tmutex_init(&dev->cmd.hcr_mutex);\n\tsema_init(&dev->cmd.poll_sem, 1);\n\tdev->cmd.flags = 0;\n\n\tdev->hcr = ioremap(pci_resource_start(dev->pdev, 0) + MTHCA_HCR_BASE,\n\t\t\t   MTHCA_HCR_SIZE);\n\tif (!dev->hcr) {\n\t\tmthca_err(dev, \"Couldn't map command register.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdev->cmd.pool = dma_pool_create(\"mthca_cmd\", &dev->pdev->dev,\n\t\t\t\t\tMTHCA_MAILBOX_SIZE,\n\t\t\t\t\tMTHCA_MAILBOX_SIZE, 0);\n\tif (!dev->cmd.pool) {\n\t\tiounmap(dev->hcr);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nvoid mthca_cmd_cleanup(struct mthca_dev *dev)\n{\n\tdma_pool_destroy(dev->cmd.pool);\n\tiounmap(dev->hcr);\n\tif (dev->cmd.flags & MTHCA_CMD_POST_DOORBELLS)\n\t\tiounmap(dev->cmd.dbell_map);\n}\n\n \nint mthca_cmd_use_events(struct mthca_dev *dev)\n{\n\tint i;\n\n\tdev->cmd.context = kmalloc_array(dev->cmd.max_cmds,\n\t\t\t\t\t sizeof(struct mthca_cmd_context),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!dev->cmd.context)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < dev->cmd.max_cmds; ++i) {\n\t\tdev->cmd.context[i].token = i;\n\t\tdev->cmd.context[i].next = i + 1;\n\t}\n\n\tdev->cmd.context[dev->cmd.max_cmds - 1].next = -1;\n\tdev->cmd.free_head = 0;\n\n\tsema_init(&dev->cmd.event_sem, dev->cmd.max_cmds);\n\tspin_lock_init(&dev->cmd.context_lock);\n\n\tfor (dev->cmd.token_mask = 1;\n\t     dev->cmd.token_mask < dev->cmd.max_cmds;\n\t     dev->cmd.token_mask <<= 1)\n\t\t;  \n\t--dev->cmd.token_mask;\n\n\tdev->cmd.flags |= MTHCA_CMD_USE_EVENTS;\n\n\tdown(&dev->cmd.poll_sem);\n\n\treturn 0;\n}\n\n \nvoid mthca_cmd_use_polling(struct mthca_dev *dev)\n{\n\tint i;\n\n\tdev->cmd.flags &= ~MTHCA_CMD_USE_EVENTS;\n\n\tfor (i = 0; i < dev->cmd.max_cmds; ++i)\n\t\tdown(&dev->cmd.event_sem);\n\n\tkfree(dev->cmd.context);\n\n\tup(&dev->cmd.poll_sem);\n}\n\nstruct mthca_mailbox *mthca_alloc_mailbox(struct mthca_dev *dev,\n\t\t\t\t\t  gfp_t gfp_mask)\n{\n\tstruct mthca_mailbox *mailbox;\n\n\tmailbox = kmalloc(sizeof *mailbox, gfp_mask);\n\tif (!mailbox)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmailbox->buf = dma_pool_alloc(dev->cmd.pool, gfp_mask, &mailbox->dma);\n\tif (!mailbox->buf) {\n\t\tkfree(mailbox);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mailbox;\n}\n\nvoid mthca_free_mailbox(struct mthca_dev *dev, struct mthca_mailbox *mailbox)\n{\n\tif (!mailbox)\n\t\treturn;\n\n\tdma_pool_free(dev->cmd.pool, mailbox->buf, mailbox->dma);\n\tkfree(mailbox);\n}\n\nint mthca_SYS_EN(struct mthca_dev *dev)\n{\n\tu64 out = 0;\n\tint ret;\n\n\tret = mthca_cmd_imm(dev, 0, &out, 0, 0, CMD_SYS_EN, CMD_TIME_CLASS_D);\n\n\tif (ret == -ENOMEM)\n\t\tmthca_warn(dev, \"SYS_EN DDR error: syn=%x, sock=%d, \"\n\t\t\t   \"sladdr=%d, SPD source=%s\\n\",\n\t\t\t   (int) (out >> 6) & 0xf, (int) (out >> 4) & 3,\n\t\t\t   (int) (out >> 1) & 7, (int) out & 1 ? \"NVMEM\" : \"DIMM\");\n\n\treturn ret;\n}\n\nint mthca_SYS_DIS(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, CMD_TIME_CLASS_C);\n}\n\nstatic int mthca_map_cmd(struct mthca_dev *dev, u16 op, struct mthca_icm *icm,\n\t\t\t u64 virt)\n{\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_icm_iter iter;\n\t__be64 *pages;\n\tint lg;\n\tint nent = 0;\n\tint i;\n\tint err = 0;\n\tint ts = 0, tc = 0;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tmemset(mailbox->buf, 0, MTHCA_MAILBOX_SIZE);\n\tpages = mailbox->buf;\n\n\tfor (mthca_icm_first(icm, &iter);\n\t     !mthca_icm_last(&iter);\n\t     mthca_icm_next(&iter)) {\n\t\t \n\t\tlg = ffs(mthca_icm_addr(&iter) | mthca_icm_size(&iter)) - 1;\n\t\tif (lg < MTHCA_ICM_PAGE_SHIFT) {\n\t\t\tmthca_warn(dev, \"Got FW area not aligned to %d (%llx/%lx).\\n\",\n\t\t\t\t   MTHCA_ICM_PAGE_SIZE,\n\t\t\t\t   (unsigned long long) mthca_icm_addr(&iter),\n\t\t\t\t   mthca_icm_size(&iter));\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tfor (i = 0; i < mthca_icm_size(&iter) >> lg; ++i) {\n\t\t\tif (virt != -1) {\n\t\t\t\tpages[nent * 2] = cpu_to_be64(virt);\n\t\t\t\tvirt += 1ULL << lg;\n\t\t\t}\n\n\t\t\tpages[nent * 2 + 1] =\n\t\t\t\tcpu_to_be64((mthca_icm_addr(&iter) + (i << lg)) |\n\t\t\t\t\t    (lg - MTHCA_ICM_PAGE_SHIFT));\n\t\t\tts += 1 << (lg - 10);\n\t\t\t++tc;\n\n\t\t\tif (++nent == MTHCA_MAILBOX_SIZE / 16) {\n\t\t\t\terr = mthca_cmd(dev, mailbox->dma, nent, 0, op,\n\t\t\t\t\t\tCMD_TIME_CLASS_B);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t\tnent = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nent)\n\t\terr = mthca_cmd(dev, mailbox->dma, nent, 0, op,\n\t\t\t\tCMD_TIME_CLASS_B);\n\n\tswitch (op) {\n\tcase CMD_MAP_FA:\n\t\tmthca_dbg(dev, \"Mapped %d chunks/%d KB for FW.\\n\", tc, ts);\n\t\tbreak;\n\tcase CMD_MAP_ICM_AUX:\n\t\tmthca_dbg(dev, \"Mapped %d chunks/%d KB for ICM aux.\\n\", tc, ts);\n\t\tbreak;\n\tcase CMD_MAP_ICM:\n\t\tmthca_dbg(dev, \"Mapped %d chunks/%d KB at %llx for ICM.\\n\",\n\t\t\t  tc, ts, (unsigned long long) virt - (ts << 10));\n\t\tbreak;\n\t}\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_MAP_FA(struct mthca_dev *dev, struct mthca_icm *icm)\n{\n\treturn mthca_map_cmd(dev, CMD_MAP_FA, icm, -1);\n}\n\nint mthca_UNMAP_FA(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_FA, CMD_TIME_CLASS_B);\n}\n\nint mthca_RUN_FW(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_RUN_FW, CMD_TIME_CLASS_A);\n}\n\nstatic void mthca_setup_cmd_doorbells(struct mthca_dev *dev, u64 base)\n{\n\tphys_addr_t addr;\n\tu16 max_off = 0;\n\tint i;\n\n\tfor (i = 0; i < 8; ++i)\n\t\tmax_off = max(max_off, dev->cmd.dbell_offsets[i]);\n\n\tif ((base & PAGE_MASK) != ((base + max_off) & PAGE_MASK)) {\n\t\tmthca_warn(dev, \"Firmware doorbell region at 0x%016llx, \"\n\t\t\t   \"length 0x%x crosses a page boundary\\n\",\n\t\t\t   (unsigned long long) base, max_off);\n\t\treturn;\n\t}\n\n\taddr = pci_resource_start(dev->pdev, 2) +\n\t\t((pci_resource_len(dev->pdev, 2) - 1) & base);\n\tdev->cmd.dbell_map = ioremap(addr, max_off + sizeof(u32));\n\tif (!dev->cmd.dbell_map)\n\t\treturn;\n\n\tdev->cmd.flags |= MTHCA_CMD_POST_DOORBELLS;\n\tmthca_dbg(dev, \"Mapped doorbell page for posting FW commands\\n\");\n}\n\nint mthca_QUERY_FW(struct mthca_dev *dev)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu32 *outbox;\n\tu64 base;\n\tu32 tmp;\n\tint err = 0;\n\tu8 lg;\n\tint i;\n\n#define QUERY_FW_OUT_SIZE             0x100\n#define QUERY_FW_VER_OFFSET            0x00\n#define QUERY_FW_MAX_CMD_OFFSET        0x0f\n#define QUERY_FW_ERR_START_OFFSET      0x30\n#define QUERY_FW_ERR_SIZE_OFFSET       0x38\n\n#define QUERY_FW_CMD_DB_EN_OFFSET      0x10\n#define QUERY_FW_CMD_DB_OFFSET         0x50\n#define QUERY_FW_CMD_DB_BASE           0x60\n\n#define QUERY_FW_START_OFFSET          0x20\n#define QUERY_FW_END_OFFSET            0x28\n\n#define QUERY_FW_SIZE_OFFSET           0x00\n#define QUERY_FW_CLR_INT_BASE_OFFSET   0x20\n#define QUERY_FW_EQ_ARM_BASE_OFFSET    0x40\n#define QUERY_FW_EQ_SET_CI_BASE_OFFSET 0x48\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\toutbox = mailbox->buf;\n\n\terr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_FW,\n\t\t\t    CMD_TIME_CLASS_A);\n\n\tif (err)\n\t\tgoto out;\n\n\tMTHCA_GET(dev->fw_ver,   outbox, QUERY_FW_VER_OFFSET);\n\t \n\tdev->fw_ver = (dev->fw_ver & 0xffff00000000ull) |\n\t\t((dev->fw_ver & 0xffff0000ull) >> 16) |\n\t\t((dev->fw_ver & 0x0000ffffull) << 16);\n\n\tMTHCA_GET(lg, outbox, QUERY_FW_MAX_CMD_OFFSET);\n\tdev->cmd.max_cmds = 1 << lg;\n\n\tmthca_dbg(dev, \"FW version %012llx, max commands %d\\n\",\n\t\t  (unsigned long long) dev->fw_ver, dev->cmd.max_cmds);\n\n\tMTHCA_GET(dev->catas_err.addr, outbox, QUERY_FW_ERR_START_OFFSET);\n\tMTHCA_GET(dev->catas_err.size, outbox, QUERY_FW_ERR_SIZE_OFFSET);\n\n\tmthca_dbg(dev, \"Catastrophic error buffer at 0x%llx, size 0x%x\\n\",\n\t\t  (unsigned long long) dev->catas_err.addr, dev->catas_err.size);\n\n\tMTHCA_GET(tmp, outbox, QUERY_FW_CMD_DB_EN_OFFSET);\n\tif (tmp & 0x1) {\n\t\tmthca_dbg(dev, \"FW supports commands through doorbells\\n\");\n\n\t\tMTHCA_GET(base, outbox, QUERY_FW_CMD_DB_BASE);\n\t\tfor (i = 0; i < MTHCA_CMD_NUM_DBELL_DWORDS; ++i)\n\t\t\tMTHCA_GET(dev->cmd.dbell_offsets[i], outbox,\n\t\t\t\t  QUERY_FW_CMD_DB_OFFSET + (i << 1));\n\n\t\tmthca_setup_cmd_doorbells(dev, base);\n\t}\n\n\tif (mthca_is_memfree(dev)) {\n\t\tMTHCA_GET(dev->fw.arbel.fw_pages,       outbox, QUERY_FW_SIZE_OFFSET);\n\t\tMTHCA_GET(dev->fw.arbel.clr_int_base,   outbox, QUERY_FW_CLR_INT_BASE_OFFSET);\n\t\tMTHCA_GET(dev->fw.arbel.eq_arm_base,    outbox, QUERY_FW_EQ_ARM_BASE_OFFSET);\n\t\tMTHCA_GET(dev->fw.arbel.eq_set_ci_base, outbox, QUERY_FW_EQ_SET_CI_BASE_OFFSET);\n\t\tmthca_dbg(dev, \"FW size %d KB\\n\", dev->fw.arbel.fw_pages << 2);\n\n\t\t \n\t\tdev->fw.arbel.fw_pages =\n\t\t\tALIGN(dev->fw.arbel.fw_pages, PAGE_SIZE / MTHCA_ICM_PAGE_SIZE) >>\n\t\t\t\t(PAGE_SHIFT - MTHCA_ICM_PAGE_SHIFT);\n\n\t\tmthca_dbg(dev, \"Clear int @ %llx, EQ arm @ %llx, EQ set CI @ %llx\\n\",\n\t\t\t  (unsigned long long) dev->fw.arbel.clr_int_base,\n\t\t\t  (unsigned long long) dev->fw.arbel.eq_arm_base,\n\t\t\t  (unsigned long long) dev->fw.arbel.eq_set_ci_base);\n\t} else {\n\t\tMTHCA_GET(dev->fw.tavor.fw_start, outbox, QUERY_FW_START_OFFSET);\n\t\tMTHCA_GET(dev->fw.tavor.fw_end,   outbox, QUERY_FW_END_OFFSET);\n\n\t\tmthca_dbg(dev, \"FW size %d KB (start %llx, end %llx)\\n\",\n\t\t\t  (int) ((dev->fw.tavor.fw_end - dev->fw.tavor.fw_start) >> 10),\n\t\t\t  (unsigned long long) dev->fw.tavor.fw_start,\n\t\t\t  (unsigned long long) dev->fw.tavor.fw_end);\n\t}\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_ENABLE_LAM(struct mthca_dev *dev)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu8 info;\n\tu32 *outbox;\n\tint err = 0;\n\n#define ENABLE_LAM_OUT_SIZE         0x100\n#define ENABLE_LAM_START_OFFSET     0x00\n#define ENABLE_LAM_END_OFFSET       0x08\n#define ENABLE_LAM_INFO_OFFSET      0x13\n\n#define ENABLE_LAM_INFO_HIDDEN_FLAG (1 << 4)\n#define ENABLE_LAM_INFO_ECC_MASK    0x3\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\toutbox = mailbox->buf;\n\n\terr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_ENABLE_LAM,\n\t\t\t    CMD_TIME_CLASS_C);\n\n\tif (err)\n\t\tgoto out;\n\n\tMTHCA_GET(dev->ddr_start, outbox, ENABLE_LAM_START_OFFSET);\n\tMTHCA_GET(dev->ddr_end,   outbox, ENABLE_LAM_END_OFFSET);\n\tMTHCA_GET(info,           outbox, ENABLE_LAM_INFO_OFFSET);\n\n\tif (!!(info & ENABLE_LAM_INFO_HIDDEN_FLAG) !=\n\t    !!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\n\t\tmthca_info(dev, \"FW reports that HCA-attached memory \"\n\t\t\t   \"is %s hidden; does not match PCI config\\n\",\n\t\t\t   (info & ENABLE_LAM_INFO_HIDDEN_FLAG) ?\n\t\t\t   \"\" : \"not\");\n\t}\n\tif (info & ENABLE_LAM_INFO_HIDDEN_FLAG)\n\t\tmthca_dbg(dev, \"HCA-attached memory is hidden.\\n\");\n\n\tmthca_dbg(dev, \"HCA memory size %d KB (start %llx, end %llx)\\n\",\n\t\t  (int) ((dev->ddr_end - dev->ddr_start) >> 10),\n\t\t  (unsigned long long) dev->ddr_start,\n\t\t  (unsigned long long) dev->ddr_end);\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_DISABLE_LAM(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_SYS_DIS, CMD_TIME_CLASS_C);\n}\n\nint mthca_QUERY_DDR(struct mthca_dev *dev)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu8 info;\n\tu32 *outbox;\n\tint err = 0;\n\n#define QUERY_DDR_OUT_SIZE         0x100\n#define QUERY_DDR_START_OFFSET     0x00\n#define QUERY_DDR_END_OFFSET       0x08\n#define QUERY_DDR_INFO_OFFSET      0x13\n\n#define QUERY_DDR_INFO_HIDDEN_FLAG (1 << 4)\n#define QUERY_DDR_INFO_ECC_MASK    0x3\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\toutbox = mailbox->buf;\n\n\terr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_DDR,\n\t\t\t    CMD_TIME_CLASS_A);\n\n\tif (err)\n\t\tgoto out;\n\n\tMTHCA_GET(dev->ddr_start, outbox, QUERY_DDR_START_OFFSET);\n\tMTHCA_GET(dev->ddr_end,   outbox, QUERY_DDR_END_OFFSET);\n\tMTHCA_GET(info,           outbox, QUERY_DDR_INFO_OFFSET);\n\n\tif (!!(info & QUERY_DDR_INFO_HIDDEN_FLAG) !=\n\t    !!(dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN)) {\n\t\tmthca_info(dev, \"FW reports that HCA-attached memory \"\n\t\t\t   \"is %s hidden; does not match PCI config\\n\",\n\t\t\t   (info & QUERY_DDR_INFO_HIDDEN_FLAG) ?\n\t\t\t   \"\" : \"not\");\n\t}\n\tif (info & QUERY_DDR_INFO_HIDDEN_FLAG)\n\t\tmthca_dbg(dev, \"HCA-attached memory is hidden.\\n\");\n\n\tmthca_dbg(dev, \"HCA memory size %d KB (start %llx, end %llx)\\n\",\n\t\t  (int) ((dev->ddr_end - dev->ddr_start) >> 10),\n\t\t  (unsigned long long) dev->ddr_start,\n\t\t  (unsigned long long) dev->ddr_end);\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_QUERY_DEV_LIM(struct mthca_dev *dev,\n\t\t\tstruct mthca_dev_lim *dev_lim)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu32 *outbox;\n\tu8 field;\n\tu16 size;\n\tu16 stat_rate;\n\tint err;\n\n#define QUERY_DEV_LIM_OUT_SIZE             0x100\n#define QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET     0x10\n#define QUERY_DEV_LIM_MAX_QP_SZ_OFFSET      0x11\n#define QUERY_DEV_LIM_RSVD_QP_OFFSET        0x12\n#define QUERY_DEV_LIM_MAX_QP_OFFSET         0x13\n#define QUERY_DEV_LIM_RSVD_SRQ_OFFSET       0x14\n#define QUERY_DEV_LIM_MAX_SRQ_OFFSET        0x15\n#define QUERY_DEV_LIM_RSVD_EEC_OFFSET       0x16\n#define QUERY_DEV_LIM_MAX_EEC_OFFSET        0x17\n#define QUERY_DEV_LIM_MAX_CQ_SZ_OFFSET      0x19\n#define QUERY_DEV_LIM_RSVD_CQ_OFFSET        0x1a\n#define QUERY_DEV_LIM_MAX_CQ_OFFSET         0x1b\n#define QUERY_DEV_LIM_MAX_MPT_OFFSET        0x1d\n#define QUERY_DEV_LIM_RSVD_EQ_OFFSET        0x1e\n#define QUERY_DEV_LIM_MAX_EQ_OFFSET         0x1f\n#define QUERY_DEV_LIM_RSVD_MTT_OFFSET       0x20\n#define QUERY_DEV_LIM_MAX_MRW_SZ_OFFSET     0x21\n#define QUERY_DEV_LIM_RSVD_MRW_OFFSET       0x22\n#define QUERY_DEV_LIM_MAX_MTT_SEG_OFFSET    0x23\n#define QUERY_DEV_LIM_MAX_AV_OFFSET         0x27\n#define QUERY_DEV_LIM_MAX_REQ_QP_OFFSET     0x29\n#define QUERY_DEV_LIM_MAX_RES_QP_OFFSET     0x2b\n#define QUERY_DEV_LIM_MAX_RDMA_OFFSET       0x2f\n#define QUERY_DEV_LIM_RSZ_SRQ_OFFSET        0x33\n#define QUERY_DEV_LIM_ACK_DELAY_OFFSET      0x35\n#define QUERY_DEV_LIM_MTU_WIDTH_OFFSET      0x36\n#define QUERY_DEV_LIM_VL_PORT_OFFSET        0x37\n#define QUERY_DEV_LIM_MAX_GID_OFFSET        0x3b\n#define QUERY_DEV_LIM_RATE_SUPPORT_OFFSET   0x3c\n#define QUERY_DEV_LIM_MAX_PKEY_OFFSET       0x3f\n#define QUERY_DEV_LIM_FLAGS_OFFSET          0x44\n#define QUERY_DEV_LIM_RSVD_UAR_OFFSET       0x48\n#define QUERY_DEV_LIM_UAR_SZ_OFFSET         0x49\n#define QUERY_DEV_LIM_PAGE_SZ_OFFSET        0x4b\n#define QUERY_DEV_LIM_MAX_SG_OFFSET         0x51\n#define QUERY_DEV_LIM_MAX_DESC_SZ_OFFSET    0x52\n#define QUERY_DEV_LIM_MAX_SG_RQ_OFFSET      0x55\n#define QUERY_DEV_LIM_MAX_DESC_SZ_RQ_OFFSET 0x56\n#define QUERY_DEV_LIM_MAX_QP_MCG_OFFSET     0x61\n#define QUERY_DEV_LIM_RSVD_MCG_OFFSET       0x62\n#define QUERY_DEV_LIM_MAX_MCG_OFFSET        0x63\n#define QUERY_DEV_LIM_RSVD_PD_OFFSET        0x64\n#define QUERY_DEV_LIM_MAX_PD_OFFSET         0x65\n#define QUERY_DEV_LIM_RSVD_RDD_OFFSET       0x66\n#define QUERY_DEV_LIM_MAX_RDD_OFFSET        0x67\n#define QUERY_DEV_LIM_EEC_ENTRY_SZ_OFFSET   0x80\n#define QUERY_DEV_LIM_QPC_ENTRY_SZ_OFFSET   0x82\n#define QUERY_DEV_LIM_EEEC_ENTRY_SZ_OFFSET  0x84\n#define QUERY_DEV_LIM_EQPC_ENTRY_SZ_OFFSET  0x86\n#define QUERY_DEV_LIM_EQC_ENTRY_SZ_OFFSET   0x88\n#define QUERY_DEV_LIM_CQC_ENTRY_SZ_OFFSET   0x8a\n#define QUERY_DEV_LIM_SRQ_ENTRY_SZ_OFFSET   0x8c\n#define QUERY_DEV_LIM_UAR_ENTRY_SZ_OFFSET   0x8e\n#define QUERY_DEV_LIM_MTT_ENTRY_SZ_OFFSET   0x90\n#define QUERY_DEV_LIM_MPT_ENTRY_SZ_OFFSET   0x92\n#define QUERY_DEV_LIM_PBL_SZ_OFFSET         0x96\n#define QUERY_DEV_LIM_BMME_FLAGS_OFFSET     0x97\n#define QUERY_DEV_LIM_RSVD_LKEY_OFFSET      0x98\n#define QUERY_DEV_LIM_LAMR_OFFSET           0x9f\n#define QUERY_DEV_LIM_MAX_ICM_SZ_OFFSET     0xa0\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\toutbox = mailbox->buf;\n\n\terr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_DEV_LIM,\n\t\t\t    CMD_TIME_CLASS_A);\n\n\tif (err)\n\t\tgoto out;\n\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_QP_OFFSET);\n\tdev_lim->reserved_qps = 1 << (field & 0xf);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_OFFSET);\n\tdev_lim->max_qps = 1 << (field & 0x1f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_SRQ_OFFSET);\n\tdev_lim->reserved_srqs = 1 << (field >> 4);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_OFFSET);\n\tdev_lim->max_srqs = 1 << (field & 0x1f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_EEC_OFFSET);\n\tdev_lim->reserved_eecs = 1 << (field & 0xf);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_EEC_OFFSET);\n\tdev_lim->max_eecs = 1 << (field & 0x1f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_CQ_SZ_OFFSET);\n\tdev_lim->max_cq_sz = 1 << field;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_CQ_OFFSET);\n\tdev_lim->reserved_cqs = 1 << (field & 0xf);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_CQ_OFFSET);\n\tdev_lim->max_cqs = 1 << (field & 0x1f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MPT_OFFSET);\n\tdev_lim->max_mpts = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_EQ_OFFSET);\n\tdev_lim->reserved_eqs = 1 << (field & 0xf);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_EQ_OFFSET);\n\tdev_lim->max_eqs = 1 << (field & 0x7);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MTT_OFFSET);\n\tif (mthca_is_memfree(dev))\n\t\tdev_lim->reserved_mtts = ALIGN((1 << (field >> 4)) * sizeof(u64),\n\t\t\t\t\t       dev->limits.mtt_seg_size) / dev->limits.mtt_seg_size;\n\telse\n\t\tdev_lim->reserved_mtts = 1 << (field >> 4);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MRW_SZ_OFFSET);\n\tdev_lim->max_mrw_sz = 1 << field;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MRW_OFFSET);\n\tdev_lim->reserved_mrws = 1 << (field & 0xf);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MTT_SEG_OFFSET);\n\tdev_lim->max_mtt_seg = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_REQ_QP_OFFSET);\n\tdev_lim->max_requester_per_qp = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RES_QP_OFFSET);\n\tdev_lim->max_responder_per_qp = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RDMA_OFFSET);\n\tdev_lim->max_rdma_global = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_ACK_DELAY_OFFSET);\n\tdev_lim->local_ca_ack_delay = field & 0x1f;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MTU_WIDTH_OFFSET);\n\tdev_lim->max_mtu        = field >> 4;\n\tdev_lim->max_port_width = field & 0xf;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_VL_PORT_OFFSET);\n\tdev_lim->max_vl    = field >> 4;\n\tdev_lim->num_ports = field & 0xf;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_GID_OFFSET);\n\tdev_lim->max_gids = 1 << (field & 0xf);\n\tMTHCA_GET(stat_rate, outbox, QUERY_DEV_LIM_RATE_SUPPORT_OFFSET);\n\tdev_lim->stat_rate_support = stat_rate;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_PKEY_OFFSET);\n\tdev_lim->max_pkeys = 1 << (field & 0xf);\n\tMTHCA_GET(dev_lim->flags, outbox, QUERY_DEV_LIM_FLAGS_OFFSET);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_UAR_OFFSET);\n\tdev_lim->reserved_uars = field >> 4;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_UAR_SZ_OFFSET);\n\tdev_lim->uar_size = 1 << ((field & 0x3f) + 20);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_PAGE_SZ_OFFSET);\n\tdev_lim->min_page_sz = 1 << field;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SG_OFFSET);\n\tdev_lim->max_sg = field;\n\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_MAX_DESC_SZ_OFFSET);\n\tdev_lim->max_desc_sz = size;\n\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_MCG_OFFSET);\n\tdev_lim->max_qp_per_mcg = 1 << field;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_MCG_OFFSET);\n\tdev_lim->reserved_mgms = field & 0xf;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_MCG_OFFSET);\n\tdev_lim->max_mcgs = 1 << field;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_PD_OFFSET);\n\tdev_lim->reserved_pds = field >> 4;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_PD_OFFSET);\n\tdev_lim->max_pds = 1 << (field & 0x3f);\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSVD_RDD_OFFSET);\n\tdev_lim->reserved_rdds = field >> 4;\n\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_RDD_OFFSET);\n\tdev_lim->max_rdds = 1 << (field & 0x3f);\n\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_EEC_ENTRY_SZ_OFFSET);\n\tdev_lim->eec_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_QPC_ENTRY_SZ_OFFSET);\n\tdev_lim->qpc_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_EEEC_ENTRY_SZ_OFFSET);\n\tdev_lim->eeec_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_EQPC_ENTRY_SZ_OFFSET);\n\tdev_lim->eqpc_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_EQC_ENTRY_SZ_OFFSET);\n\tdev_lim->eqc_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_CQC_ENTRY_SZ_OFFSET);\n\tdev_lim->cqc_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_SRQ_ENTRY_SZ_OFFSET);\n\tdev_lim->srq_entry_sz = size;\n\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_UAR_ENTRY_SZ_OFFSET);\n\tdev_lim->uar_scratch_entry_sz = size;\n\n\tif (mthca_is_memfree(dev)) {\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET);\n\t\tdev_lim->max_srq_sz = 1 << field;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_SZ_OFFSET);\n\t\tdev_lim->max_qp_sz = 1 << field;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_RSZ_SRQ_OFFSET);\n\t\tdev_lim->hca.arbel.resize_srq = field & 1;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SG_RQ_OFFSET);\n\t\tdev_lim->max_sg = min_t(int, field, dev_lim->max_sg);\n\t\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_MAX_DESC_SZ_RQ_OFFSET);\n\t\tdev_lim->max_desc_sz = min_t(int, size, dev_lim->max_desc_sz);\n\t\tMTHCA_GET(size, outbox, QUERY_DEV_LIM_MPT_ENTRY_SZ_OFFSET);\n\t\tdev_lim->mpt_entry_sz = size;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_PBL_SZ_OFFSET);\n\t\tdev_lim->hca.arbel.max_pbl_sz = 1 << (field & 0x3f);\n\t\tMTHCA_GET(dev_lim->hca.arbel.bmme_flags, outbox,\n\t\t\t  QUERY_DEV_LIM_BMME_FLAGS_OFFSET);\n\t\tMTHCA_GET(dev_lim->hca.arbel.reserved_lkey, outbox,\n\t\t\t  QUERY_DEV_LIM_RSVD_LKEY_OFFSET);\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_LAMR_OFFSET);\n\t\tdev_lim->hca.arbel.lam_required = field & 1;\n\t\tMTHCA_GET(dev_lim->hca.arbel.max_icm_sz, outbox,\n\t\t\t  QUERY_DEV_LIM_MAX_ICM_SZ_OFFSET);\n\n\t\tif (dev_lim->hca.arbel.bmme_flags & 1)\n\t\t\tmthca_dbg(dev, \"Base MM extensions: yes \"\n\t\t\t\t  \"(flags %d, max PBL %d, rsvd L_Key %08x)\\n\",\n\t\t\t\t  dev_lim->hca.arbel.bmme_flags,\n\t\t\t\t  dev_lim->hca.arbel.max_pbl_sz,\n\t\t\t\t  dev_lim->hca.arbel.reserved_lkey);\n\t\telse\n\t\t\tmthca_dbg(dev, \"Base MM extensions: no\\n\");\n\n\t\tmthca_dbg(dev, \"Max ICM size %lld MB\\n\",\n\t\t\t  (unsigned long long) dev_lim->hca.arbel.max_icm_sz >> 20);\n\t} else {\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_SRQ_SZ_OFFSET);\n\t\tdev_lim->max_srq_sz = (1 << field) - 1;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_QP_SZ_OFFSET);\n\t\tdev_lim->max_qp_sz = (1 << field) - 1;\n\t\tMTHCA_GET(field, outbox, QUERY_DEV_LIM_MAX_AV_OFFSET);\n\t\tdev_lim->hca.tavor.max_avs = 1 << (field & 0x3f);\n\t\tdev_lim->mpt_entry_sz = MTHCA_MPT_ENTRY_SIZE;\n\t}\n\n\tmthca_dbg(dev, \"Max QPs: %d, reserved QPs: %d, entry size: %d\\n\",\n\t\t  dev_lim->max_qps, dev_lim->reserved_qps, dev_lim->qpc_entry_sz);\n\tmthca_dbg(dev, \"Max SRQs: %d, reserved SRQs: %d, entry size: %d\\n\",\n\t\t  dev_lim->max_srqs, dev_lim->reserved_srqs, dev_lim->srq_entry_sz);\n\tmthca_dbg(dev, \"Max CQs: %d, reserved CQs: %d, entry size: %d\\n\",\n\t\t  dev_lim->max_cqs, dev_lim->reserved_cqs, dev_lim->cqc_entry_sz);\n\tmthca_dbg(dev, \"Max EQs: %d, reserved EQs: %d, entry size: %d\\n\",\n\t\t  dev_lim->max_eqs, dev_lim->reserved_eqs, dev_lim->eqc_entry_sz);\n\tmthca_dbg(dev, \"reserved MPTs: %d, reserved MTTs: %d\\n\",\n\t\t  dev_lim->reserved_mrws, dev_lim->reserved_mtts);\n\tmthca_dbg(dev, \"Max PDs: %d, reserved PDs: %d, reserved UARs: %d\\n\",\n\t\t  dev_lim->max_pds, dev_lim->reserved_pds, dev_lim->reserved_uars);\n\tmthca_dbg(dev, \"Max QP/MCG: %d, reserved MGMs: %d\\n\",\n\t\t  dev_lim->max_pds, dev_lim->reserved_mgms);\n\tmthca_dbg(dev, \"Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\\n\",\n\t\t  dev_lim->max_cq_sz, dev_lim->max_qp_sz, dev_lim->max_srq_sz);\n\n\tmthca_dbg(dev, \"Flags: %08x\\n\", dev_lim->flags);\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nstatic void get_board_id(void *vsd, char *board_id)\n{\n\tint i;\n\n#define VSD_OFFSET_SIG1\t\t0x00\n#define VSD_OFFSET_SIG2\t\t0xde\n#define VSD_OFFSET_MLX_BOARD_ID\t0xd0\n#define VSD_OFFSET_TS_BOARD_ID\t0x20\n\n#define VSD_SIGNATURE_TOPSPIN\t0x5ad\n\n\tmemset(board_id, 0, MTHCA_BOARD_ID_LEN);\n\n\tif (be16_to_cpup(vsd + VSD_OFFSET_SIG1) == VSD_SIGNATURE_TOPSPIN &&\n\t    be16_to_cpup(vsd + VSD_OFFSET_SIG2) == VSD_SIGNATURE_TOPSPIN) {\n\t\tstrscpy(board_id, vsd + VSD_OFFSET_TS_BOARD_ID, MTHCA_BOARD_ID_LEN);\n\t} else {\n\t\t \n\t\tfor (i = 0; i < 4; ++i)\n\t\t\t((u32 *) board_id)[i] =\n\t\t\t\tswab32(*(u32 *) (vsd + VSD_OFFSET_MLX_BOARD_ID + i * 4));\n\t}\n}\n\nint mthca_QUERY_ADAPTER(struct mthca_dev *dev,\n\t\t\tstruct mthca_adapter *adapter)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu32 *outbox;\n\tint err;\n\n#define QUERY_ADAPTER_OUT_SIZE             0x100\n#define QUERY_ADAPTER_VENDOR_ID_OFFSET     0x00\n#define QUERY_ADAPTER_DEVICE_ID_OFFSET     0x04\n#define QUERY_ADAPTER_REVISION_ID_OFFSET   0x08\n#define QUERY_ADAPTER_INTA_PIN_OFFSET      0x10\n#define QUERY_ADAPTER_VSD_OFFSET           0x20\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\toutbox = mailbox->buf;\n\n\terr = mthca_cmd_box(dev, 0, mailbox->dma, 0, 0, CMD_QUERY_ADAPTER,\n\t\t\t    CMD_TIME_CLASS_A);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (!mthca_is_memfree(dev)) {\n\t\tMTHCA_GET(adapter->vendor_id, outbox,\n\t\t\t  QUERY_ADAPTER_VENDOR_ID_OFFSET);\n\t\tMTHCA_GET(adapter->device_id, outbox,\n\t\t\t  QUERY_ADAPTER_DEVICE_ID_OFFSET);\n\t\tMTHCA_GET(adapter->revision_id, outbox,\n\t\t\t  QUERY_ADAPTER_REVISION_ID_OFFSET);\n\t}\n\tMTHCA_GET(adapter->inta_pin, outbox,    QUERY_ADAPTER_INTA_PIN_OFFSET);\n\n\tget_board_id(outbox + QUERY_ADAPTER_VSD_OFFSET / 4,\n\t\t     adapter->board_id);\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_INIT_HCA(struct mthca_dev *dev,\n\t\t   struct mthca_init_hca_param *param)\n{\n\tstruct mthca_mailbox *mailbox;\n\t__be32 *inbox;\n\tint err;\n\n#define INIT_HCA_IN_SIZE             \t 0x200\n#define INIT_HCA_FLAGS1_OFFSET           0x00c\n#define INIT_HCA_FLAGS2_OFFSET           0x014\n#define INIT_HCA_QPC_OFFSET          \t 0x020\n#define  INIT_HCA_QPC_BASE_OFFSET    \t (INIT_HCA_QPC_OFFSET + 0x10)\n#define  INIT_HCA_LOG_QP_OFFSET      \t (INIT_HCA_QPC_OFFSET + 0x17)\n#define  INIT_HCA_EEC_BASE_OFFSET    \t (INIT_HCA_QPC_OFFSET + 0x20)\n#define  INIT_HCA_LOG_EEC_OFFSET     \t (INIT_HCA_QPC_OFFSET + 0x27)\n#define  INIT_HCA_SRQC_BASE_OFFSET   \t (INIT_HCA_QPC_OFFSET + 0x28)\n#define  INIT_HCA_LOG_SRQ_OFFSET     \t (INIT_HCA_QPC_OFFSET + 0x2f)\n#define  INIT_HCA_CQC_BASE_OFFSET    \t (INIT_HCA_QPC_OFFSET + 0x30)\n#define  INIT_HCA_LOG_CQ_OFFSET      \t (INIT_HCA_QPC_OFFSET + 0x37)\n#define  INIT_HCA_EQPC_BASE_OFFSET   \t (INIT_HCA_QPC_OFFSET + 0x40)\n#define  INIT_HCA_EEEC_BASE_OFFSET   \t (INIT_HCA_QPC_OFFSET + 0x50)\n#define  INIT_HCA_EQC_BASE_OFFSET    \t (INIT_HCA_QPC_OFFSET + 0x60)\n#define  INIT_HCA_LOG_EQ_OFFSET      \t (INIT_HCA_QPC_OFFSET + 0x67)\n#define  INIT_HCA_RDB_BASE_OFFSET    \t (INIT_HCA_QPC_OFFSET + 0x70)\n#define INIT_HCA_UDAV_OFFSET         \t 0x0b0\n#define  INIT_HCA_UDAV_LKEY_OFFSET   \t (INIT_HCA_UDAV_OFFSET + 0x0)\n#define  INIT_HCA_UDAV_PD_OFFSET     \t (INIT_HCA_UDAV_OFFSET + 0x4)\n#define INIT_HCA_MCAST_OFFSET        \t 0x0c0\n#define  INIT_HCA_MC_BASE_OFFSET         (INIT_HCA_MCAST_OFFSET + 0x00)\n#define  INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET (INIT_HCA_MCAST_OFFSET + 0x12)\n#define  INIT_HCA_MC_HASH_SZ_OFFSET      (INIT_HCA_MCAST_OFFSET + 0x16)\n#define  INIT_HCA_LOG_MC_TABLE_SZ_OFFSET (INIT_HCA_MCAST_OFFSET + 0x1b)\n#define INIT_HCA_TPT_OFFSET              0x0f0\n#define  INIT_HCA_MPT_BASE_OFFSET        (INIT_HCA_TPT_OFFSET + 0x00)\n#define  INIT_HCA_MTT_SEG_SZ_OFFSET      (INIT_HCA_TPT_OFFSET + 0x09)\n#define  INIT_HCA_LOG_MPT_SZ_OFFSET      (INIT_HCA_TPT_OFFSET + 0x0b)\n#define  INIT_HCA_MTT_BASE_OFFSET        (INIT_HCA_TPT_OFFSET + 0x10)\n#define INIT_HCA_UAR_OFFSET              0x120\n#define  INIT_HCA_UAR_BASE_OFFSET        (INIT_HCA_UAR_OFFSET + 0x00)\n#define  INIT_HCA_UARC_SZ_OFFSET         (INIT_HCA_UAR_OFFSET + 0x09)\n#define  INIT_HCA_LOG_UAR_SZ_OFFSET      (INIT_HCA_UAR_OFFSET + 0x0a)\n#define  INIT_HCA_UAR_PAGE_SZ_OFFSET     (INIT_HCA_UAR_OFFSET + 0x0b)\n#define  INIT_HCA_UAR_SCATCH_BASE_OFFSET (INIT_HCA_UAR_OFFSET + 0x10)\n#define  INIT_HCA_UAR_CTX_BASE_OFFSET    (INIT_HCA_UAR_OFFSET + 0x18)\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tinbox = mailbox->buf;\n\n\tmemset(inbox, 0, INIT_HCA_IN_SIZE);\n\n\tif (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT)\n\t\tMTHCA_PUT(inbox, 0x1, INIT_HCA_FLAGS1_OFFSET);\n\n#if defined(__LITTLE_ENDIAN)\n\t*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) &= ~cpu_to_be32(1 << 1);\n#elif defined(__BIG_ENDIAN)\n\t*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(1 << 1);\n#else\n#error Host endianness not defined\n#endif\n\t \n\t*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(1);\n\n\t \n\tif (dev->device_cap_flags & IB_DEVICE_UD_IP_CSUM)\n\t\t*(inbox + INIT_HCA_FLAGS2_OFFSET / 4) |= cpu_to_be32(7 << 3);\n\n\t \n\n\t \n\n\tMTHCA_PUT(inbox, param->qpc_base,     INIT_HCA_QPC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_num_qps,  INIT_HCA_LOG_QP_OFFSET);\n\tMTHCA_PUT(inbox, param->eec_base,     INIT_HCA_EEC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_num_eecs, INIT_HCA_LOG_EEC_OFFSET);\n\tMTHCA_PUT(inbox, param->srqc_base,    INIT_HCA_SRQC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_num_srqs, INIT_HCA_LOG_SRQ_OFFSET);\n\tMTHCA_PUT(inbox, param->cqc_base,     INIT_HCA_CQC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_num_cqs,  INIT_HCA_LOG_CQ_OFFSET);\n\tMTHCA_PUT(inbox, param->eqpc_base,    INIT_HCA_EQPC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->eeec_base,    INIT_HCA_EEEC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->eqc_base,     INIT_HCA_EQC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_num_eqs,  INIT_HCA_LOG_EQ_OFFSET);\n\tMTHCA_PUT(inbox, param->rdb_base,     INIT_HCA_RDB_BASE_OFFSET);\n\n\t \n\n\t \n\n\tMTHCA_PUT(inbox, param->mc_base,         INIT_HCA_MC_BASE_OFFSET);\n\tMTHCA_PUT(inbox, param->log_mc_entry_sz, INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET);\n\tMTHCA_PUT(inbox, param->mc_hash_sz,      INIT_HCA_MC_HASH_SZ_OFFSET);\n\tMTHCA_PUT(inbox, param->log_mc_table_sz, INIT_HCA_LOG_MC_TABLE_SZ_OFFSET);\n\n\t \n\n\tMTHCA_PUT(inbox, param->mpt_base,   INIT_HCA_MPT_BASE_OFFSET);\n\tif (!mthca_is_memfree(dev))\n\t\tMTHCA_PUT(inbox, param->mtt_seg_sz, INIT_HCA_MTT_SEG_SZ_OFFSET);\n\tMTHCA_PUT(inbox, param->log_mpt_sz, INIT_HCA_LOG_MPT_SZ_OFFSET);\n\tMTHCA_PUT(inbox, param->mtt_base,   INIT_HCA_MTT_BASE_OFFSET);\n\n\t \n\t{\n\t\tu8 uar_page_sz = PAGE_SHIFT - 12;\n\t\tMTHCA_PUT(inbox, uar_page_sz, INIT_HCA_UAR_PAGE_SZ_OFFSET);\n\t}\n\n\tMTHCA_PUT(inbox, param->uar_scratch_base, INIT_HCA_UAR_SCATCH_BASE_OFFSET);\n\n\tif (mthca_is_memfree(dev)) {\n\t\tMTHCA_PUT(inbox, param->log_uarc_sz, INIT_HCA_UARC_SZ_OFFSET);\n\t\tMTHCA_PUT(inbox, param->log_uar_sz,  INIT_HCA_LOG_UAR_SZ_OFFSET);\n\t\tMTHCA_PUT(inbox, param->uarc_base,   INIT_HCA_UAR_CTX_BASE_OFFSET);\n\t}\n\n\terr = mthca_cmd(dev, mailbox->dma, 0, 0,\n\t\t\tCMD_INIT_HCA, CMD_TIME_CLASS_D);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_INIT_IB(struct mthca_dev *dev,\n\t\t  struct mthca_init_ib_param *param,\n\t\t  int port)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu32 *inbox;\n\tint err;\n\tu32 flags;\n\n#define INIT_IB_IN_SIZE          56\n#define INIT_IB_FLAGS_OFFSET     0x00\n#define INIT_IB_FLAG_SIG         (1 << 18)\n#define INIT_IB_FLAG_NG          (1 << 17)\n#define INIT_IB_FLAG_G0          (1 << 16)\n#define INIT_IB_VL_SHIFT         4\n#define INIT_IB_PORT_WIDTH_SHIFT 8\n#define INIT_IB_MTU_SHIFT        12\n#define INIT_IB_MAX_GID_OFFSET   0x06\n#define INIT_IB_MAX_PKEY_OFFSET  0x0a\n#define INIT_IB_GUID0_OFFSET     0x10\n#define INIT_IB_NODE_GUID_OFFSET 0x18\n#define INIT_IB_SI_GUID_OFFSET   0x20\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tinbox = mailbox->buf;\n\n\tmemset(inbox, 0, INIT_IB_IN_SIZE);\n\n\tflags = 0;\n\tflags |= param->set_guid0     ? INIT_IB_FLAG_G0  : 0;\n\tflags |= param->set_node_guid ? INIT_IB_FLAG_NG  : 0;\n\tflags |= param->set_si_guid   ? INIT_IB_FLAG_SIG : 0;\n\tflags |= param->vl_cap << INIT_IB_VL_SHIFT;\n\tflags |= param->port_width << INIT_IB_PORT_WIDTH_SHIFT;\n\tflags |= param->mtu_cap << INIT_IB_MTU_SHIFT;\n\tMTHCA_PUT(inbox, flags, INIT_IB_FLAGS_OFFSET);\n\n\tMTHCA_PUT(inbox, param->gid_cap,   INIT_IB_MAX_GID_OFFSET);\n\tMTHCA_PUT(inbox, param->pkey_cap,  INIT_IB_MAX_PKEY_OFFSET);\n\tMTHCA_PUT(inbox, param->guid0,     INIT_IB_GUID0_OFFSET);\n\tMTHCA_PUT(inbox, param->node_guid, INIT_IB_NODE_GUID_OFFSET);\n\tMTHCA_PUT(inbox, param->si_guid,   INIT_IB_SI_GUID_OFFSET);\n\n\terr = mthca_cmd(dev, mailbox->dma, port, 0, CMD_INIT_IB,\n\t\t\tCMD_TIME_CLASS_A);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_CLOSE_IB(struct mthca_dev *dev, int port)\n{\n\treturn mthca_cmd(dev, 0, port, 0, CMD_CLOSE_IB, CMD_TIME_CLASS_A);\n}\n\nint mthca_CLOSE_HCA(struct mthca_dev *dev, int panic)\n{\n\treturn mthca_cmd(dev, 0, 0, panic, CMD_CLOSE_HCA, CMD_TIME_CLASS_C);\n}\n\nint mthca_SET_IB(struct mthca_dev *dev, struct mthca_set_ib_param *param,\n\t\t int port)\n{\n\tstruct mthca_mailbox *mailbox;\n\tu32 *inbox;\n\tint err;\n\tu32 flags = 0;\n\n#define SET_IB_IN_SIZE         0x40\n#define SET_IB_FLAGS_OFFSET    0x00\n#define SET_IB_FLAG_SIG        (1 << 18)\n#define SET_IB_FLAG_RQK        (1 <<  0)\n#define SET_IB_CAP_MASK_OFFSET 0x04\n#define SET_IB_SI_GUID_OFFSET  0x08\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tinbox = mailbox->buf;\n\n\tmemset(inbox, 0, SET_IB_IN_SIZE);\n\n\tflags |= param->set_si_guid     ? SET_IB_FLAG_SIG : 0;\n\tflags |= param->reset_qkey_viol ? SET_IB_FLAG_RQK : 0;\n\tMTHCA_PUT(inbox, flags, SET_IB_FLAGS_OFFSET);\n\n\tMTHCA_PUT(inbox, param->cap_mask, SET_IB_CAP_MASK_OFFSET);\n\tMTHCA_PUT(inbox, param->si_guid,  SET_IB_SI_GUID_OFFSET);\n\n\terr = mthca_cmd(dev, mailbox->dma, port, 0, CMD_SET_IB,\n\t\t\tCMD_TIME_CLASS_B);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_MAP_ICM(struct mthca_dev *dev, struct mthca_icm *icm, u64 virt)\n{\n\treturn mthca_map_cmd(dev, CMD_MAP_ICM, icm, virt);\n}\n\nint mthca_MAP_ICM_page(struct mthca_dev *dev, u64 dma_addr, u64 virt)\n{\n\tstruct mthca_mailbox *mailbox;\n\t__be64 *inbox;\n\tint err;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tinbox = mailbox->buf;\n\n\tinbox[0] = cpu_to_be64(virt);\n\tinbox[1] = cpu_to_be64(dma_addr);\n\n\terr = mthca_cmd(dev, mailbox->dma, 1, 0, CMD_MAP_ICM,\n\t\t\tCMD_TIME_CLASS_B);\n\n\tmthca_free_mailbox(dev, mailbox);\n\n\tif (!err)\n\t\tmthca_dbg(dev, \"Mapped page at %llx to %llx for ICM.\\n\",\n\t\t\t  (unsigned long long) dma_addr, (unsigned long long) virt);\n\n\treturn err;\n}\n\nint mthca_UNMAP_ICM(struct mthca_dev *dev, u64 virt, u32 page_count)\n{\n\tmthca_dbg(dev, \"Unmapping %d pages at %llx from ICM.\\n\",\n\t\t  page_count, (unsigned long long) virt);\n\n\treturn mthca_cmd(dev, virt, page_count, 0,\n\t\t\tCMD_UNMAP_ICM, CMD_TIME_CLASS_B);\n}\n\nint mthca_MAP_ICM_AUX(struct mthca_dev *dev, struct mthca_icm *icm)\n{\n\treturn mthca_map_cmd(dev, CMD_MAP_ICM_AUX, icm, -1);\n}\n\nint mthca_UNMAP_ICM_AUX(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_UNMAP_ICM_AUX, CMD_TIME_CLASS_B);\n}\n\nint mthca_SET_ICM_SIZE(struct mthca_dev *dev, u64 icm_size, u64 *aux_pages)\n{\n\tint ret = mthca_cmd_imm(dev, icm_size, aux_pages, 0,\n\t\t\t0, CMD_SET_ICM_SIZE, CMD_TIME_CLASS_A);\n\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t*aux_pages = ALIGN(*aux_pages, PAGE_SIZE / MTHCA_ICM_PAGE_SIZE) >>\n\t\t(PAGE_SHIFT - MTHCA_ICM_PAGE_SHIFT);\n\n\treturn 0;\n}\n\nint mthca_SW2HW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    int mpt_index)\n{\n\treturn mthca_cmd(dev, mailbox->dma, mpt_index, 0, CMD_SW2HW_MPT,\n\t\t\t CMD_TIME_CLASS_B);\n}\n\nint mthca_HW2SW_MPT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    int mpt_index)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox ? mailbox->dma : 0, mpt_index,\n\t\t\t     !mailbox, CMD_HW2SW_MPT,\n\t\t\t     CMD_TIME_CLASS_B);\n}\n\nint mthca_WRITE_MTT(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    int num_mtt)\n{\n\treturn mthca_cmd(dev, mailbox->dma, num_mtt, 0, CMD_WRITE_MTT,\n\t\t\t CMD_TIME_CLASS_B);\n}\n\nint mthca_SYNC_TPT(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0, 0, CMD_SYNC_TPT, CMD_TIME_CLASS_B);\n}\n\nint mthca_MAP_EQ(struct mthca_dev *dev, u64 event_mask, int unmap,\n\t\t int eq_num)\n{\n\tmthca_dbg(dev, \"%s mask %016llx for eqn %d\\n\",\n\t\t  unmap ? \"Clearing\" : \"Setting\",\n\t\t  (unsigned long long) event_mask, eq_num);\n\treturn mthca_cmd(dev, event_mask, (unmap << 31) | eq_num,\n\t\t\t 0, CMD_MAP_EQ, CMD_TIME_CLASS_B);\n}\n\nint mthca_SW2HW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t   int eq_num)\n{\n\treturn mthca_cmd(dev, mailbox->dma, eq_num, 0, CMD_SW2HW_EQ,\n\t\t\t CMD_TIME_CLASS_A);\n}\n\nint mthca_HW2SW_EQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t   int eq_num)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, eq_num, 0,\n\t\t\t     CMD_HW2SW_EQ,\n\t\t\t     CMD_TIME_CLASS_A);\n}\n\nint mthca_SW2HW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t   int cq_num)\n{\n\treturn mthca_cmd(dev, mailbox->dma, cq_num, 0, CMD_SW2HW_CQ,\n\t\t\tCMD_TIME_CLASS_A);\n}\n\nint mthca_HW2SW_CQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t   int cq_num)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, cq_num, 0,\n\t\t\t     CMD_HW2SW_CQ,\n\t\t\t     CMD_TIME_CLASS_A);\n}\n\nint mthca_RESIZE_CQ(struct mthca_dev *dev, int cq_num, u32 lkey, u8 log_size)\n{\n\tstruct mthca_mailbox *mailbox;\n\t__be32 *inbox;\n\tint err;\n\n#define RESIZE_CQ_IN_SIZE\t\t0x40\n#define RESIZE_CQ_LOG_SIZE_OFFSET\t0x0c\n#define RESIZE_CQ_LKEY_OFFSET\t\t0x1c\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tinbox = mailbox->buf;\n\n\tmemset(inbox, 0, RESIZE_CQ_IN_SIZE);\n\t \n\tMTHCA_PUT(inbox, log_size, RESIZE_CQ_LOG_SIZE_OFFSET);\n\tMTHCA_PUT(inbox, lkey,     RESIZE_CQ_LKEY_OFFSET);\n\n\terr = mthca_cmd(dev, mailbox->dma, cq_num, 1, CMD_RESIZE_CQ,\n\t\t\tCMD_TIME_CLASS_B);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_SW2HW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    int srq_num)\n{\n\treturn mthca_cmd(dev, mailbox->dma, srq_num, 0, CMD_SW2HW_SRQ,\n\t\t\tCMD_TIME_CLASS_A);\n}\n\nint mthca_HW2SW_SRQ(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    int srq_num)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, srq_num, 0,\n\t\t\t     CMD_HW2SW_SRQ,\n\t\t\t     CMD_TIME_CLASS_A);\n}\n\nint mthca_QUERY_SRQ(struct mthca_dev *dev, u32 num,\n\t\t    struct mthca_mailbox *mailbox)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, num, 0,\n\t\t\t     CMD_QUERY_SRQ, CMD_TIME_CLASS_A);\n}\n\nint mthca_ARM_SRQ(struct mthca_dev *dev, int srq_num, int limit)\n{\n\treturn mthca_cmd(dev, limit, srq_num, 0, CMD_ARM_SRQ,\n\t\t\t CMD_TIME_CLASS_B);\n}\n\nint mthca_MODIFY_QP(struct mthca_dev *dev, enum ib_qp_state cur,\n\t\t    enum ib_qp_state next, u32 num, int is_ee,\n\t\t    struct mthca_mailbox *mailbox, u32 optmask)\n{\n\tstatic const u16 op[IB_QPS_ERR + 1][IB_QPS_ERR + 1] = {\n\t\t[IB_QPS_RESET] = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_INIT]\t= CMD_RST2INIT_QPEE,\n\t\t},\n\t\t[IB_QPS_INIT]  = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_INIT]\t= CMD_INIT2INIT_QPEE,\n\t\t\t[IB_QPS_RTR]\t= CMD_INIT2RTR_QPEE,\n\t\t},\n\t\t[IB_QPS_RTR]   = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_RTS]\t= CMD_RTR2RTS_QPEE,\n\t\t},\n\t\t[IB_QPS_RTS]   = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_RTS]\t= CMD_RTS2RTS_QPEE,\n\t\t\t[IB_QPS_SQD]\t= CMD_RTS2SQD_QPEE,\n\t\t},\n\t\t[IB_QPS_SQD] = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_RTS]\t= CMD_SQD2RTS_QPEE,\n\t\t\t[IB_QPS_SQD]\t= CMD_SQD2SQD_QPEE,\n\t\t},\n\t\t[IB_QPS_SQE] = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t\t[IB_QPS_RTS]\t= CMD_SQERR2RTS_QPEE,\n\t\t},\n\t\t[IB_QPS_ERR] = {\n\t\t\t[IB_QPS_RESET]\t= CMD_ERR2RST_QPEE,\n\t\t\t[IB_QPS_ERR]\t= CMD_2ERR_QPEE,\n\t\t}\n\t};\n\n\tu8 op_mod = 0;\n\tint my_mailbox = 0;\n\tint err;\n\n\tif (op[cur][next] == CMD_ERR2RST_QPEE) {\n\t\top_mod = 3;\t \n\n\t\t \n\t\tif (!mailbox) {\n\t\t\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\t\t\tif (!IS_ERR(mailbox)) {\n\t\t\t\tmy_mailbox = 1;\n\t\t\t\top_mod     = 2;\t \n\t\t\t} else\n\t\t\t\tmailbox = NULL;\n\t\t}\n\n\t\terr = mthca_cmd_box(dev, 0, mailbox ? mailbox->dma : 0,\n\t\t\t\t    (!!is_ee << 24) | num, op_mod,\n\t\t\t\t    op[cur][next], CMD_TIME_CLASS_C);\n\n\t\tif (0 && mailbox) {\n\t\t\tint i;\n\t\t\tmthca_dbg(dev, \"Dumping QP context:\\n\");\n\t\t\tprintk(\" %08x\\n\", be32_to_cpup(mailbox->buf));\n\t\t\tfor (i = 0; i < 0x100 / 4; ++i) {\n\t\t\t\tif (i % 8 == 0)\n\t\t\t\t\tprintk(\"[%02x] \", i * 4);\n\t\t\t\tprintk(\" %08x\",\n\t\t\t\t       be32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));\n\t\t\t\tif ((i + 1) % 8 == 0)\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (my_mailbox)\n\t\t\tmthca_free_mailbox(dev, mailbox);\n\t} else {\n\t\tif (0) {\n\t\t\tint i;\n\t\t\tmthca_dbg(dev, \"Dumping QP context:\\n\");\n\t\t\tprintk(\"  opt param mask: %08x\\n\", be32_to_cpup(mailbox->buf));\n\t\t\tfor (i = 0; i < 0x100 / 4; ++i) {\n\t\t\t\tif (i % 8 == 0)\n\t\t\t\t\tprintk(\"  [%02x] \", i * 4);\n\t\t\t\tprintk(\" %08x\",\n\t\t\t\t       be32_to_cpu(((__be32 *) mailbox->buf)[i + 2]));\n\t\t\t\tif ((i + 1) % 8 == 0)\n\t\t\t\t\tprintk(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t\terr = mthca_cmd(dev, mailbox->dma, optmask | (!!is_ee << 24) | num,\n\t\t\t\top_mod, op[cur][next], CMD_TIME_CLASS_C);\n\t}\n\n\treturn err;\n}\n\nint mthca_QUERY_QP(struct mthca_dev *dev, u32 num, int is_ee,\n\t\t   struct mthca_mailbox *mailbox)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, (!!is_ee << 24) | num, 0,\n\t\t\t     CMD_QUERY_QPEE, CMD_TIME_CLASS_A);\n}\n\nint mthca_CONF_SPECIAL_QP(struct mthca_dev *dev, int type, u32 qpn)\n{\n\tu8 op_mod;\n\n\tswitch (type) {\n\tcase IB_QPT_SMI:\n\t\top_mod = 0;\n\t\tbreak;\n\tcase IB_QPT_GSI:\n\t\top_mod = 1;\n\t\tbreak;\n\tcase IB_QPT_RAW_IPV6:\n\t\top_mod = 2;\n\t\tbreak;\n\tcase IB_QPT_RAW_ETHERTYPE:\n\t\top_mod = 3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mthca_cmd(dev, 0, qpn, op_mod, CMD_CONF_SPECIAL_QP,\n\t\t\t CMD_TIME_CLASS_B);\n}\n\nint mthca_MAD_IFC(struct mthca_dev *dev, int ignore_mkey, int ignore_bkey,\n\t\t  int port, const struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t  const void *in_mad, void *response_mad)\n{\n\tstruct mthca_mailbox *inmailbox, *outmailbox;\n\tvoid *inbox;\n\tint err;\n\tu32 in_modifier = port;\n\tu8 op_modifier = 0;\n\n#define MAD_IFC_BOX_SIZE      0x400\n#define MAD_IFC_MY_QPN_OFFSET 0x100\n#define MAD_IFC_RQPN_OFFSET   0x108\n#define MAD_IFC_SL_OFFSET     0x10c\n#define MAD_IFC_G_PATH_OFFSET 0x10d\n#define MAD_IFC_RLID_OFFSET   0x10e\n#define MAD_IFC_PKEY_OFFSET   0x112\n#define MAD_IFC_GRH_OFFSET    0x140\n\n\tinmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(inmailbox))\n\t\treturn PTR_ERR(inmailbox);\n\tinbox = inmailbox->buf;\n\n\toutmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(outmailbox)) {\n\t\tmthca_free_mailbox(dev, inmailbox);\n\t\treturn PTR_ERR(outmailbox);\n\t}\n\n\tmemcpy(inbox, in_mad, 256);\n\n\t \n\tif (ignore_mkey || !in_wc)\n\t\top_modifier |= 0x1;\n\tif (ignore_bkey || !in_wc)\n\t\top_modifier |= 0x2;\n\n\tif (in_wc) {\n\t\tu8 val;\n\n\t\tmemset(inbox + 256, 0, 256);\n\n\t\tMTHCA_PUT(inbox, in_wc->qp->qp_num, MAD_IFC_MY_QPN_OFFSET);\n\t\tMTHCA_PUT(inbox, in_wc->src_qp,     MAD_IFC_RQPN_OFFSET);\n\n\t\tval = in_wc->sl << 4;\n\t\tMTHCA_PUT(inbox, val,               MAD_IFC_SL_OFFSET);\n\n\t\tval = in_wc->dlid_path_bits |\n\t\t\t(in_wc->wc_flags & IB_WC_GRH ? 0x80 : 0);\n\t\tMTHCA_PUT(inbox, val,               MAD_IFC_G_PATH_OFFSET);\n\n\t\tMTHCA_PUT(inbox, ib_lid_cpu16(in_wc->slid), MAD_IFC_RLID_OFFSET);\n\t\tMTHCA_PUT(inbox, in_wc->pkey_index, MAD_IFC_PKEY_OFFSET);\n\n\t\tif (in_grh)\n\t\t\tmemcpy(inbox + MAD_IFC_GRH_OFFSET, in_grh, 40);\n\n\t\top_modifier |= 0x4;\n\n\t\tin_modifier |= ib_lid_cpu16(in_wc->slid) << 16;\n\t}\n\n\terr = mthca_cmd_box(dev, inmailbox->dma, outmailbox->dma,\n\t\t\t    in_modifier, op_modifier,\n\t\t\t    CMD_MAD_IFC, CMD_TIME_CLASS_C);\n\n\tif (!err)\n\t\tmemcpy(response_mad, outmailbox->buf, 256);\n\n\tmthca_free_mailbox(dev, inmailbox);\n\tmthca_free_mailbox(dev, outmailbox);\n\treturn err;\n}\n\nint mthca_READ_MGM(struct mthca_dev *dev, int index,\n\t\t   struct mthca_mailbox *mailbox)\n{\n\treturn mthca_cmd_box(dev, 0, mailbox->dma, index, 0,\n\t\t\t     CMD_READ_MGM, CMD_TIME_CLASS_A);\n}\n\nint mthca_WRITE_MGM(struct mthca_dev *dev, int index,\n\t\t    struct mthca_mailbox *mailbox)\n{\n\treturn mthca_cmd(dev, mailbox->dma, index, 0, CMD_WRITE_MGM,\n\t\t\t CMD_TIME_CLASS_A);\n}\n\nint mthca_MGID_HASH(struct mthca_dev *dev, struct mthca_mailbox *mailbox,\n\t\t    u16 *hash)\n{\n\tu64 imm = 0;\n\tint err;\n\n\terr = mthca_cmd_imm(dev, mailbox->dma, &imm, 0, 0, CMD_MGID_HASH,\n\t\t\t    CMD_TIME_CLASS_A);\n\n\t*hash = imm;\n\treturn err;\n}\n\nint mthca_NOP(struct mthca_dev *dev)\n{\n\treturn mthca_cmd(dev, 0, 0x1f, 0, CMD_NOP, msecs_to_jiffies(100));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}