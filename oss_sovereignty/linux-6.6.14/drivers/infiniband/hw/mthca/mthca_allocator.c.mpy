{
  "module_name": "mthca_allocator.c",
  "hash_id": "bd28ccbf46ac69e31f04e9655617963636c06800cbf811c34e0f5547300c2f1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_allocator.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/bitmap.h>\n\n#include \"mthca_dev.h\"\n\n \nu32 mthca_alloc(struct mthca_alloc *alloc)\n{\n\tunsigned long flags;\n\tu32 obj;\n\n\tspin_lock_irqsave(&alloc->lock, flags);\n\n\tobj = find_next_zero_bit(alloc->table, alloc->max, alloc->last);\n\tif (obj >= alloc->max) {\n\t\talloc->top = (alloc->top + alloc->max) & alloc->mask;\n\t\tobj = find_first_zero_bit(alloc->table, alloc->max);\n\t}\n\n\tif (obj < alloc->max) {\n\t\t__set_bit(obj, alloc->table);\n\t\tobj |= alloc->top;\n\t} else\n\t\tobj = -1;\n\n\tspin_unlock_irqrestore(&alloc->lock, flags);\n\n\treturn obj;\n}\n\nvoid mthca_free(struct mthca_alloc *alloc, u32 obj)\n{\n\tunsigned long flags;\n\n\tobj &= alloc->max - 1;\n\n\tspin_lock_irqsave(&alloc->lock, flags);\n\n\t__clear_bit(obj, alloc->table);\n\talloc->last = min(alloc->last, obj);\n\talloc->top = (alloc->top + alloc->max) & alloc->mask;\n\n\tspin_unlock_irqrestore(&alloc->lock, flags);\n}\n\nint mthca_alloc_init(struct mthca_alloc *alloc, u32 num, u32 mask,\n\t\t     u32 reserved)\n{\n\t \n\tif (num != 1 << (ffs(num) - 1))\n\t\treturn -EINVAL;\n\n\talloc->last = 0;\n\talloc->top  = 0;\n\talloc->max  = num;\n\talloc->mask = mask;\n\tspin_lock_init(&alloc->lock);\n\talloc->table = bitmap_zalloc(num, GFP_KERNEL);\n\tif (!alloc->table)\n\t\treturn -ENOMEM;\n\n\tbitmap_set(alloc->table, 0, reserved);\n\n\treturn 0;\n}\n\nvoid mthca_alloc_cleanup(struct mthca_alloc *alloc)\n{\n\tbitmap_free(alloc->table);\n}\n\n \n\n#define MTHCA_ARRAY_MASK (PAGE_SIZE / sizeof (void *) - 1)\n\nvoid *mthca_array_get(struct mthca_array *array, int index)\n{\n\tint p = (index * sizeof (void *)) >> PAGE_SHIFT;\n\n\tif (array->page_list[p].page)\n\t\treturn array->page_list[p].page[index & MTHCA_ARRAY_MASK];\n\telse\n\t\treturn NULL;\n}\n\nint mthca_array_set(struct mthca_array *array, int index, void *value)\n{\n\tint p = (index * sizeof (void *)) >> PAGE_SHIFT;\n\n\t \n\tif (!array->page_list[p].page)\n\t\tarray->page_list[p].page = (void **) get_zeroed_page(GFP_ATOMIC);\n\n\tif (!array->page_list[p].page)\n\t\treturn -ENOMEM;\n\n\tarray->page_list[p].page[index & MTHCA_ARRAY_MASK] = value;\n\t++array->page_list[p].used;\n\n\treturn 0;\n}\n\nvoid mthca_array_clear(struct mthca_array *array, int index)\n{\n\tint p = (index * sizeof (void *)) >> PAGE_SHIFT;\n\n\tif (--array->page_list[p].used == 0) {\n\t\tfree_page((unsigned long) array->page_list[p].page);\n\t\tarray->page_list[p].page = NULL;\n\t} else\n\t\tarray->page_list[p].page[index & MTHCA_ARRAY_MASK] = NULL;\n\n\tif (array->page_list[p].used < 0)\n\t\tpr_debug(\"Array %p index %d page %d with ref count %d < 0\\n\",\n\t\t\t array, index, p, array->page_list[p].used);\n}\n\nint mthca_array_init(struct mthca_array *array, int nent)\n{\n\tint npage = (nent * sizeof (void *) + PAGE_SIZE - 1) / PAGE_SIZE;\n\tint i;\n\n\tarray->page_list = kmalloc_array(npage, sizeof(*array->page_list),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!array->page_list)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < npage; ++i) {\n\t\tarray->page_list[i].page = NULL;\n\t\tarray->page_list[i].used = 0;\n\t}\n\n\treturn 0;\n}\n\nvoid mthca_array_cleanup(struct mthca_array *array, int nent)\n{\n\tint i;\n\n\tfor (i = 0; i < (nent * sizeof (void *) + PAGE_SIZE - 1) / PAGE_SIZE; ++i)\n\t\tfree_page((unsigned long) array->page_list[i].page);\n\n\tkfree(array->page_list);\n}\n\n \n\nint mthca_buf_alloc(struct mthca_dev *dev, int size, int max_direct,\n\t\t    union mthca_buf *buf, int *is_direct, struct mthca_pd *pd,\n\t\t    int hca_write, struct mthca_mr *mr)\n{\n\tint err = -ENOMEM;\n\tint npages, shift;\n\tu64 *dma_list = NULL;\n\tdma_addr_t t;\n\tint i;\n\n\tif (size <= max_direct) {\n\t\t*is_direct = 1;\n\t\tnpages     = 1;\n\t\tshift      = get_order(size) + PAGE_SHIFT;\n\n\t\tbuf->direct.buf = dma_alloc_coherent(&dev->pdev->dev,\n\t\t\t\t\t\t     size, &t, GFP_KERNEL);\n\t\tif (!buf->direct.buf)\n\t\t\treturn -ENOMEM;\n\n\t\tdma_unmap_addr_set(&buf->direct, mapping, t);\n\n\t\twhile (t & ((1 << shift) - 1)) {\n\t\t\t--shift;\n\t\t\tnpages *= 2;\n\t\t}\n\n\t\tdma_list = kmalloc_array(npages, sizeof(*dma_list),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!dma_list)\n\t\t\tgoto err_free;\n\n\t\tfor (i = 0; i < npages; ++i)\n\t\t\tdma_list[i] = t + i * (1 << shift);\n\t} else {\n\t\t*is_direct = 0;\n\t\tnpages     = (size + PAGE_SIZE - 1) / PAGE_SIZE;\n\t\tshift      = PAGE_SHIFT;\n\n\t\tdma_list = kmalloc_array(npages, sizeof(*dma_list),\n\t\t\t\t\t GFP_KERNEL);\n\t\tif (!dma_list)\n\t\t\treturn -ENOMEM;\n\n\t\tbuf->page_list = kmalloc_array(npages,\n\t\t\t\t\t       sizeof(*buf->page_list),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!buf->page_list)\n\t\t\tgoto err_out;\n\n\t\tfor (i = 0; i < npages; ++i)\n\t\t\tbuf->page_list[i].buf = NULL;\n\n\t\tfor (i = 0; i < npages; ++i) {\n\t\t\tbuf->page_list[i].buf =\n\t\t\t\tdma_alloc_coherent(&dev->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t\t   &t, GFP_KERNEL);\n\t\t\tif (!buf->page_list[i].buf)\n\t\t\t\tgoto err_free;\n\n\t\t\tdma_list[i] = t;\n\t\t\tdma_unmap_addr_set(&buf->page_list[i], mapping, t);\n\n\t\t\tclear_page(buf->page_list[i].buf);\n\t\t}\n\t}\n\n\terr = mthca_mr_alloc_phys(dev, pd->pd_num,\n\t\t\t\t  dma_list, shift, npages,\n\t\t\t\t  0, size,\n\t\t\t\t  MTHCA_MPT_FLAG_LOCAL_READ |\n\t\t\t\t  (hca_write ? MTHCA_MPT_FLAG_LOCAL_WRITE : 0),\n\t\t\t\t  mr);\n\tif (err)\n\t\tgoto err_free;\n\n\tkfree(dma_list);\n\n\treturn 0;\n\nerr_free:\n\tmthca_buf_free(dev, size, buf, *is_direct, NULL);\n\nerr_out:\n\tkfree(dma_list);\n\n\treturn err;\n}\n\nvoid mthca_buf_free(struct mthca_dev *dev, int size, union mthca_buf *buf,\n\t\t    int is_direct, struct mthca_mr *mr)\n{\n\tint i;\n\n\tif (mr)\n\t\tmthca_free_mr(dev, mr);\n\n\tif (is_direct)\n\t\tdma_free_coherent(&dev->pdev->dev, size, buf->direct.buf,\n\t\t\t\t  dma_unmap_addr(&buf->direct, mapping));\n\telse {\n\t\tfor (i = 0; i < (size + PAGE_SIZE - 1) / PAGE_SIZE; ++i)\n\t\t\tdma_free_coherent(&dev->pdev->dev, PAGE_SIZE,\n\t\t\t\t\t  buf->page_list[i].buf,\n\t\t\t\t\t  dma_unmap_addr(&buf->page_list[i],\n\t\t\t\t\t\t\t mapping));\n\t\tkfree(buf->page_list);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}