{
  "module_name": "mthca_reset.c",
  "hash_id": "d935615028c0ef8ed5e8e139bfec52e0c1aacb8535b52a800dda5db58de9f065",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_reset.c",
  "human_readable_source": " \n\n#include <linux/errno.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n\nint mthca_reset(struct mthca_dev *mdev)\n{\n\tint i;\n\tint err = 0;\n\tu32 *hca_header    = NULL;\n\tu32 *bridge_header = NULL;\n\tstruct pci_dev *bridge = NULL;\n\tint bridge_pcix_cap = 0;\n\tint hca_pcie_cap = 0;\n\tint hca_pcix_cap = 0;\n\n\tu16 devctl;\n\tu16 linkctl;\n\n#define MTHCA_RESET_OFFSET 0xf0010\n#define MTHCA_RESET_VALUE  swab32(1)\n\n\t \n\n\tif (!(mdev->mthca_flags & MTHCA_FLAG_PCIE)) {\n\t\t \n\t\twhile ((bridge = pci_get_device(mdev->pdev->vendor,\n\t\t\t\t\t\tmdev->pdev->device + 2,\n\t\t\t\t\t\tbridge)) != NULL) {\n\t\t\tif (bridge->hdr_type    == PCI_HEADER_TYPE_BRIDGE &&\n\t\t\t    bridge->subordinate == mdev->pdev->bus) {\n\t\t\t\tmthca_dbg(mdev, \"Found bridge: %s\\n\",\n\t\t\t\t\t  pci_name(bridge));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!bridge) {\n\t\t\t \n\t\t\tmthca_warn(mdev, \"No bridge found for %s\\n\",\n\t\t\t\t  pci_name(mdev->pdev));\n\t\t}\n\n\t}\n\n\t \n\thca_header = kmalloc(256, GFP_KERNEL);\n\tif (!hca_header) {\n\t\terr = -ENOMEM;\n\t\tgoto put_dev;\n\t}\n\n\tfor (i = 0; i < 64; ++i) {\n\t\tif (i == 22 || i == 23)\n\t\t\tcontinue;\n\t\tif (pci_read_config_dword(mdev->pdev, i * 4, hca_header + i)) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't save HCA \"\n\t\t\t\t  \"PCI header, aborting.\\n\");\n\t\t\tgoto free_hca;\n\t\t}\n\t}\n\n\thca_pcix_cap = pci_find_capability(mdev->pdev, PCI_CAP_ID_PCIX);\n\thca_pcie_cap = pci_pcie_cap(mdev->pdev);\n\n\tif (bridge) {\n\t\tbridge_header = kmalloc(256, GFP_KERNEL);\n\t\tif (!bridge_header) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_hca;\n\t\t}\n\n\t\tfor (i = 0; i < 64; ++i) {\n\t\t\tif (i == 22 || i == 23)\n\t\t\t\tcontinue;\n\t\t\tif (pci_read_config_dword(bridge, i * 4, bridge_header + i)) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tmthca_err(mdev, \"Couldn't save HCA bridge \"\n\t\t\t\t\t  \"PCI header, aborting.\\n\");\n\t\t\t\tgoto free_bh;\n\t\t\t}\n\t\t}\n\t\tbridge_pcix_cap = pci_find_capability(bridge, PCI_CAP_ID_PCIX);\n\t\tif (!bridge_pcix_cap) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tmthca_err(mdev, \"Couldn't locate HCA bridge \"\n\t\t\t\t\t  \"PCI-X capability, aborting.\\n\");\n\t\t\t\tgoto free_bh;\n\t\t}\n\t}\n\n\t \n\t{\n\t\tvoid __iomem *reset = ioremap(pci_resource_start(mdev->pdev, 0) +\n\t\t\t\t\t      MTHCA_RESET_OFFSET, 4);\n\n\t\tif (!reset) {\n\t\t\terr = -ENOMEM;\n\t\t\tmthca_err(mdev, \"Couldn't map HCA reset register, \"\n\t\t\t\t  \"aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\n\t\twritel(MTHCA_RESET_VALUE, reset);\n\t\tiounmap(reset);\n\t}\n\n\t \n\tmsleep(1000);\n\n\t \n\t{\n\t\tu32 v;\n\t\tint c = 0;\n\n\t\tfor (c = 0; c < 100; ++c) {\n\t\t\tif (pci_read_config_dword(bridge ? bridge : mdev->pdev, 0, &v)) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tmthca_err(mdev, \"Couldn't access HCA after reset, \"\n\t\t\t\t\t  \"aborting.\\n\");\n\t\t\t\tgoto free_bh;\n\t\t\t}\n\n\t\t\tif (v != 0xffffffff)\n\t\t\t\tgoto good;\n\n\t\t\tmsleep(100);\n\t\t}\n\n\t\terr = -ENODEV;\n\t\tmthca_err(mdev, \"PCI device did not come back after reset, \"\n\t\t\t  \"aborting.\\n\");\n\t\tgoto free_bh;\n\t}\n\ngood:\n\t \n\tif (bridge) {\n\t\tif (pci_write_config_dword(bridge, bridge_pcix_cap + 0x8,\n\t\t\t\t bridge_header[(bridge_pcix_cap + 0x8) / 4])) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA bridge Upstream \"\n\t\t\t\t  \"split transaction control, aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t\tif (pci_write_config_dword(bridge, bridge_pcix_cap + 0xc,\n\t\t\t\t bridge_header[(bridge_pcix_cap + 0xc) / 4])) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA bridge Downstream \"\n\t\t\t\t  \"split transaction control, aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < 16; ++i) {\n\t\t\tif (i * 4 == PCI_COMMAND)\n\t\t\t\tcontinue;\n\n\t\t\tif (pci_write_config_dword(bridge, i * 4, bridge_header[i])) {\n\t\t\t\terr = -ENODEV;\n\t\t\t\tmthca_err(mdev, \"Couldn't restore HCA bridge reg %x, \"\n\t\t\t\t\t  \"aborting.\\n\", i);\n\t\t\t\tgoto free_bh;\n\t\t\t}\n\t\t}\n\n\t\tif (pci_write_config_dword(bridge, PCI_COMMAND,\n\t\t\t\t\t   bridge_header[PCI_COMMAND / 4])) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA bridge COMMAND, \"\n\t\t\t\t  \"aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t}\n\n\tif (hca_pcix_cap) {\n\t\tif (pci_write_config_dword(mdev->pdev, hca_pcix_cap,\n\t\t\t\t hca_header[hca_pcix_cap / 4])) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA PCI-X \"\n\t\t\t\t  \"command register, aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t}\n\n\tif (hca_pcie_cap) {\n\t\tdevctl = hca_header[(hca_pcie_cap + PCI_EXP_DEVCTL) / 4];\n\t\tif (pcie_capability_write_word(mdev->pdev, PCI_EXP_DEVCTL,\n\t\t\t\t\t       devctl)) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA PCI Express \"\n\t\t\t\t  \"Device Control register, aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t\tlinkctl = hca_header[(hca_pcie_cap + PCI_EXP_LNKCTL) / 4];\n\t\tif (pcie_capability_write_word(mdev->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t       linkctl)) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA PCI Express \"\n\t\t\t\t  \"Link control register, aborting.\\n\");\n\t\t\tgoto free_bh;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 16; ++i) {\n\t\tif (i * 4 == PCI_COMMAND)\n\t\t\tcontinue;\n\n\t\tif (pci_write_config_dword(mdev->pdev, i * 4, hca_header[i])) {\n\t\t\terr = -ENODEV;\n\t\t\tmthca_err(mdev, \"Couldn't restore HCA reg %x, \"\n\t\t\t\t  \"aborting.\\n\", i);\n\t\t\tgoto free_bh;\n\t\t}\n\t}\n\n\tif (pci_write_config_dword(mdev->pdev, PCI_COMMAND,\n\t\t\t\t   hca_header[PCI_COMMAND / 4])) {\n\t\terr = -ENODEV;\n\t\tmthca_err(mdev, \"Couldn't restore HCA COMMAND, \"\n\t\t\t  \"aborting.\\n\");\n\t}\nfree_bh:\n\tkfree(bridge_header);\nfree_hca:\n\tkfree(hca_header);\nput_dev:\n\tpci_dev_put(bridge);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}