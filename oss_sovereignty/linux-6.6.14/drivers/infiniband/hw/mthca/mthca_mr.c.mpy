{
  "module_name": "mthca_mr.c",
  "hash_id": "1510d201becd944a29f66aeebe74454a1ec27a62f6fa30784e60f9b7fb37aee5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_mr.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/errno.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n#include \"mthca_memfree.h\"\n\nstruct mthca_mtt {\n\tstruct mthca_buddy *buddy;\n\tint                 order;\n\tu32                 first_seg;\n};\n\n \nstruct mthca_mpt_entry {\n\t__be32 flags;\n\t__be32 page_size;\n\t__be32 key;\n\t__be32 pd;\n\t__be64 start;\n\t__be64 length;\n\t__be32 lkey;\n\t__be32 window_count;\n\t__be32 window_count_limit;\n\t__be64 mtt_seg;\n\t__be32 mtt_sz;\t\t \n\tu32    reserved[2];\n} __packed;\n\n#define MTHCA_MPT_FLAG_SW_OWNS       (0xfUL << 28)\n#define MTHCA_MPT_FLAG_MIO           (1 << 17)\n#define MTHCA_MPT_FLAG_BIND_ENABLE   (1 << 15)\n#define MTHCA_MPT_FLAG_PHYSICAL      (1 <<  9)\n#define MTHCA_MPT_FLAG_REGION        (1 <<  8)\n\n#define MTHCA_MTT_FLAG_PRESENT       1\n\n#define MTHCA_MPT_STATUS_SW 0xF0\n#define MTHCA_MPT_STATUS_HW 0x00\n\n#define SINAI_FMR_KEY_INC 0x1000000\n\n \n\nstatic u32 mthca_buddy_alloc(struct mthca_buddy *buddy, int order)\n{\n\tint o;\n\tint m;\n\tu32 seg;\n\n\tspin_lock(&buddy->lock);\n\n\tfor (o = order; o <= buddy->max_order; ++o)\n\t\tif (buddy->num_free[o]) {\n\t\t\tm = 1 << (buddy->max_order - o);\n\t\t\tseg = find_first_bit(buddy->bits[o], m);\n\t\t\tif (seg < m)\n\t\t\t\tgoto found;\n\t\t}\n\n\tspin_unlock(&buddy->lock);\n\treturn -1;\n\n found:\n\t__clear_bit(seg, buddy->bits[o]);\n\t--buddy->num_free[o];\n\n\twhile (o > order) {\n\t\t--o;\n\t\tseg <<= 1;\n\t\t__set_bit(seg ^ 1, buddy->bits[o]);\n\t\t++buddy->num_free[o];\n\t}\n\n\tspin_unlock(&buddy->lock);\n\n\tseg <<= order;\n\n\treturn seg;\n}\n\nstatic void mthca_buddy_free(struct mthca_buddy *buddy, u32 seg, int order)\n{\n\tseg >>= order;\n\n\tspin_lock(&buddy->lock);\n\n\twhile (test_bit(seg ^ 1, buddy->bits[order])) {\n\t\t__clear_bit(seg ^ 1, buddy->bits[order]);\n\t\t--buddy->num_free[order];\n\t\tseg >>= 1;\n\t\t++order;\n\t}\n\n\t__set_bit(seg, buddy->bits[order]);\n\t++buddy->num_free[order];\n\n\tspin_unlock(&buddy->lock);\n}\n\nstatic int mthca_buddy_init(struct mthca_buddy *buddy, int max_order)\n{\n\tint i;\n\n\tbuddy->max_order = max_order;\n\tspin_lock_init(&buddy->lock);\n\n\tbuddy->bits = kcalloc(buddy->max_order + 1, sizeof(long *),\n\t\t\t      GFP_KERNEL);\n\tbuddy->num_free = kcalloc((buddy->max_order + 1), sizeof *buddy->num_free,\n\t\t\t\t  GFP_KERNEL);\n\tif (!buddy->bits || !buddy->num_free)\n\t\tgoto err_out;\n\n\tfor (i = 0; i <= buddy->max_order; ++i) {\n\t\tbuddy->bits[i] = bitmap_zalloc(1 << (buddy->max_order - i),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!buddy->bits[i])\n\t\t\tgoto err_out_free;\n\t}\n\n\t__set_bit(0, buddy->bits[buddy->max_order]);\n\tbuddy->num_free[buddy->max_order] = 1;\n\n\treturn 0;\n\nerr_out_free:\n\tfor (i = 0; i <= buddy->max_order; ++i)\n\t\tbitmap_free(buddy->bits[i]);\n\nerr_out:\n\tkfree(buddy->bits);\n\tkfree(buddy->num_free);\n\n\treturn -ENOMEM;\n}\n\nstatic void mthca_buddy_cleanup(struct mthca_buddy *buddy)\n{\n\tint i;\n\n\tfor (i = 0; i <= buddy->max_order; ++i)\n\t\tbitmap_free(buddy->bits[i]);\n\n\tkfree(buddy->bits);\n\tkfree(buddy->num_free);\n}\n\nstatic u32 mthca_alloc_mtt_range(struct mthca_dev *dev, int order,\n\t\t\t\t struct mthca_buddy *buddy)\n{\n\tu32 seg = mthca_buddy_alloc(buddy, order);\n\n\tif (seg == -1)\n\t\treturn -1;\n\n\tif (mthca_is_memfree(dev))\n\t\tif (mthca_table_get_range(dev, dev->mr_table.mtt_table, seg,\n\t\t\t\t\t  seg + (1 << order) - 1)) {\n\t\t\tmthca_buddy_free(buddy, seg, order);\n\t\t\tseg = -1;\n\t\t}\n\n\treturn seg;\n}\n\nstatic struct mthca_mtt *__mthca_alloc_mtt(struct mthca_dev *dev, int size,\n\t\t\t\t\t   struct mthca_buddy *buddy)\n{\n\tstruct mthca_mtt *mtt;\n\tint i;\n\n\tif (size <= 0)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmtt = kmalloc(sizeof *mtt, GFP_KERNEL);\n\tif (!mtt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmtt->buddy = buddy;\n\tmtt->order = 0;\n\tfor (i = dev->limits.mtt_seg_size / 8; i < size; i <<= 1)\n\t\t++mtt->order;\n\n\tmtt->first_seg = mthca_alloc_mtt_range(dev, mtt->order, buddy);\n\tif (mtt->first_seg == -1) {\n\t\tkfree(mtt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn mtt;\n}\n\nstruct mthca_mtt *mthca_alloc_mtt(struct mthca_dev *dev, int size)\n{\n\treturn __mthca_alloc_mtt(dev, size, &dev->mr_table.mtt_buddy);\n}\n\nvoid mthca_free_mtt(struct mthca_dev *dev, struct mthca_mtt *mtt)\n{\n\tif (!mtt)\n\t\treturn;\n\n\tmthca_buddy_free(mtt->buddy, mtt->first_seg, mtt->order);\n\n\tmthca_table_put_range(dev, dev->mr_table.mtt_table,\n\t\t\t      mtt->first_seg,\n\t\t\t      mtt->first_seg + (1 << mtt->order) - 1);\n\n\tkfree(mtt);\n}\n\nstatic int __mthca_write_mtt(struct mthca_dev *dev, struct mthca_mtt *mtt,\n\t\t\t     int start_index, u64 *buffer_list, int list_len)\n{\n\tstruct mthca_mailbox *mailbox;\n\t__be64 *mtt_entry;\n\tint err = 0;\n\tint i;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tmtt_entry = mailbox->buf;\n\n\twhile (list_len > 0) {\n\t\tmtt_entry[0] = cpu_to_be64(dev->mr_table.mtt_base +\n\t\t\t\t\t   mtt->first_seg * dev->limits.mtt_seg_size +\n\t\t\t\t\t   start_index * 8);\n\t\tmtt_entry[1] = 0;\n\t\tfor (i = 0; i < list_len && i < MTHCA_MAILBOX_SIZE / 8 - 2; ++i)\n\t\t\tmtt_entry[i + 2] = cpu_to_be64(buffer_list[i] |\n\t\t\t\t\t\t       MTHCA_MTT_FLAG_PRESENT);\n\n\t\t \n\t\tif (i & 1)\n\t\t\tmtt_entry[i + 2] = 0;\n\n\t\terr = mthca_WRITE_MTT(dev, mailbox, (i + 1) & ~1);\n\t\tif (err) {\n\t\t\tmthca_warn(dev, \"WRITE_MTT failed (%d)\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_len    -= i;\n\t\tstart_index += i;\n\t\tbuffer_list += i;\n\t}\n\nout:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_write_mtt_size(struct mthca_dev *dev)\n{\n\tif (dev->mr_table.fmr_mtt_buddy != &dev->mr_table.mtt_buddy ||\n\t    !(dev->mthca_flags & MTHCA_FLAG_FMR))\n\t\t \n\t\treturn PAGE_SIZE / sizeof (u64) - 2;\n\n\t \n\treturn mthca_is_memfree(dev) ? (PAGE_SIZE / sizeof (u64)) : 0x7ffffff;\n}\n\nstatic void mthca_tavor_write_mtt_seg(struct mthca_dev *dev,\n\t\t\t\t      struct mthca_mtt *mtt, int start_index,\n\t\t\t\t      u64 *buffer_list, int list_len)\n{\n\tu64 __iomem *mtts;\n\tint i;\n\n\tmtts = dev->mr_table.tavor_fmr.mtt_base + mtt->first_seg * dev->limits.mtt_seg_size +\n\t\tstart_index * sizeof (u64);\n\tfor (i = 0; i < list_len; ++i)\n\t\tmthca_write64_raw(cpu_to_be64(buffer_list[i] | MTHCA_MTT_FLAG_PRESENT),\n\t\t\t\t  mtts + i);\n}\n\nstatic void mthca_arbel_write_mtt_seg(struct mthca_dev *dev,\n\t\t\t\t      struct mthca_mtt *mtt, int start_index,\n\t\t\t\t      u64 *buffer_list, int list_len)\n{\n\t__be64 *mtts;\n\tdma_addr_t dma_handle;\n\tint i;\n\tint s = start_index * sizeof (u64);\n\n\t \n\tBUG_ON(s / PAGE_SIZE != (s + list_len * sizeof(u64) - 1) / PAGE_SIZE);\n\t \n\tBUG_ON(s % dev->limits.mtt_seg_size);\n\n\tmtts = mthca_table_find(dev->mr_table.mtt_table, mtt->first_seg +\n\t\t\t\ts / dev->limits.mtt_seg_size, &dma_handle);\n\n\tBUG_ON(!mtts);\n\n\tdma_sync_single_for_cpu(&dev->pdev->dev, dma_handle,\n\t\t\t\tlist_len * sizeof (u64), DMA_TO_DEVICE);\n\n\tfor (i = 0; i < list_len; ++i)\n\t\tmtts[i] = cpu_to_be64(buffer_list[i] | MTHCA_MTT_FLAG_PRESENT);\n\n\tdma_sync_single_for_device(&dev->pdev->dev, dma_handle,\n\t\t\t\t   list_len * sizeof (u64), DMA_TO_DEVICE);\n}\n\nint mthca_write_mtt(struct mthca_dev *dev, struct mthca_mtt *mtt,\n\t\t    int start_index, u64 *buffer_list, int list_len)\n{\n\tint size = mthca_write_mtt_size(dev);\n\tint chunk;\n\n\tif (dev->mr_table.fmr_mtt_buddy != &dev->mr_table.mtt_buddy ||\n\t    !(dev->mthca_flags & MTHCA_FLAG_FMR))\n\t\treturn __mthca_write_mtt(dev, mtt, start_index, buffer_list, list_len);\n\n\twhile (list_len > 0) {\n\t\tchunk = min(size, list_len);\n\t\tif (mthca_is_memfree(dev))\n\t\t\tmthca_arbel_write_mtt_seg(dev, mtt, start_index,\n\t\t\t\t\t\t  buffer_list, chunk);\n\t\telse\n\t\t\tmthca_tavor_write_mtt_seg(dev, mtt, start_index,\n\t\t\t\t\t\t  buffer_list, chunk);\n\n\t\tlist_len    -= chunk;\n\t\tstart_index += chunk;\n\t\tbuffer_list += chunk;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u32 tavor_hw_index_to_key(u32 ind)\n{\n\treturn ind;\n}\n\nstatic inline u32 tavor_key_to_hw_index(u32 key)\n{\n\treturn key;\n}\n\nstatic inline u32 arbel_hw_index_to_key(u32 ind)\n{\n\treturn (ind >> 24) | (ind << 8);\n}\n\nstatic inline u32 arbel_key_to_hw_index(u32 key)\n{\n\treturn (key << 24) | (key >> 8);\n}\n\nstatic inline u32 hw_index_to_key(struct mthca_dev *dev, u32 ind)\n{\n\tif (mthca_is_memfree(dev))\n\t\treturn arbel_hw_index_to_key(ind);\n\telse\n\t\treturn tavor_hw_index_to_key(ind);\n}\n\nstatic inline u32 key_to_hw_index(struct mthca_dev *dev, u32 key)\n{\n\tif (mthca_is_memfree(dev))\n\t\treturn arbel_key_to_hw_index(key);\n\telse\n\t\treturn tavor_key_to_hw_index(key);\n}\n\nstatic inline u32 adjust_key(struct mthca_dev *dev, u32 key)\n{\n\tif (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT)\n\t\treturn ((key << 20) & 0x800000) | (key & 0x7fffff);\n\telse\n\t\treturn key;\n}\n\nint mthca_mr_alloc(struct mthca_dev *dev, u32 pd, int buffer_size_shift,\n\t\t   u64 iova, u64 total_size, u32 access, struct mthca_mr *mr)\n{\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_mpt_entry *mpt_entry;\n\tu32 key;\n\tint i;\n\tint err;\n\n\tWARN_ON(buffer_size_shift >= 32);\n\n\tkey = mthca_alloc(&dev->mr_table.mpt_alloc);\n\tif (key == -1)\n\t\treturn -ENOMEM;\n\tkey = adjust_key(dev, key);\n\tmr->ibmr.rkey = mr->ibmr.lkey = hw_index_to_key(dev, key);\n\n\tif (mthca_is_memfree(dev)) {\n\t\terr = mthca_table_get(dev, dev->mr_table.mpt_table, key);\n\t\tif (err)\n\t\t\tgoto err_out_mpt_free;\n\t}\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox)) {\n\t\terr = PTR_ERR(mailbox);\n\t\tgoto err_out_table;\n\t}\n\tmpt_entry = mailbox->buf;\n\n\tmpt_entry->flags = cpu_to_be32(MTHCA_MPT_FLAG_SW_OWNS     |\n\t\t\t\t       MTHCA_MPT_FLAG_MIO         |\n\t\t\t\t       MTHCA_MPT_FLAG_REGION      |\n\t\t\t\t       access);\n\tif (!mr->mtt)\n\t\tmpt_entry->flags |= cpu_to_be32(MTHCA_MPT_FLAG_PHYSICAL);\n\n\tmpt_entry->page_size = cpu_to_be32(buffer_size_shift - 12);\n\tmpt_entry->key       = cpu_to_be32(key);\n\tmpt_entry->pd        = cpu_to_be32(pd);\n\tmpt_entry->start     = cpu_to_be64(iova);\n\tmpt_entry->length    = cpu_to_be64(total_size);\n\n\tmemset_startat(mpt_entry, 0, lkey);\n\n\tif (mr->mtt)\n\t\tmpt_entry->mtt_seg =\n\t\t\tcpu_to_be64(dev->mr_table.mtt_base +\n\t\t\t\t    mr->mtt->first_seg * dev->limits.mtt_seg_size);\n\n\tif (0) {\n\t\tmthca_dbg(dev, \"Dumping MPT entry %08x:\\n\", mr->ibmr.lkey);\n\t\tfor (i = 0; i < sizeof (struct mthca_mpt_entry) / 4; ++i) {\n\t\t\tif (i % 4 == 0)\n\t\t\t\tprintk(\"[%02x] \", i * 4);\n\t\t\tprintk(\" %08x\", be32_to_cpu(((__be32 *) mpt_entry)[i]));\n\t\t\tif ((i + 1) % 4 == 0)\n\t\t\t\tprintk(\"\\n\");\n\t\t}\n\t}\n\n\terr = mthca_SW2HW_MPT(dev, mailbox,\n\t\t\t      key & (dev->limits.num_mpts - 1));\n\tif (err) {\n\t\tmthca_warn(dev, \"SW2HW_MPT failed (%d)\\n\", err);\n\t\tgoto err_out_mailbox;\n\t}\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n\nerr_out_mailbox:\n\tmthca_free_mailbox(dev, mailbox);\n\nerr_out_table:\n\tmthca_table_put(dev, dev->mr_table.mpt_table, key);\n\nerr_out_mpt_free:\n\tmthca_free(&dev->mr_table.mpt_alloc, key);\n\treturn err;\n}\n\nint mthca_mr_alloc_notrans(struct mthca_dev *dev, u32 pd,\n\t\t\t   u32 access, struct mthca_mr *mr)\n{\n\tmr->mtt = NULL;\n\treturn mthca_mr_alloc(dev, pd, 12, 0, ~0ULL, access, mr);\n}\n\nint mthca_mr_alloc_phys(struct mthca_dev *dev, u32 pd,\n\t\t\tu64 *buffer_list, int buffer_size_shift,\n\t\t\tint list_len, u64 iova, u64 total_size,\n\t\t\tu32 access, struct mthca_mr *mr)\n{\n\tint err;\n\n\tmr->mtt = mthca_alloc_mtt(dev, list_len);\n\tif (IS_ERR(mr->mtt))\n\t\treturn PTR_ERR(mr->mtt);\n\n\terr = mthca_write_mtt(dev, mr->mtt, 0, buffer_list, list_len);\n\tif (err) {\n\t\tmthca_free_mtt(dev, mr->mtt);\n\t\treturn err;\n\t}\n\n\terr = mthca_mr_alloc(dev, pd, buffer_size_shift, iova,\n\t\t\t     total_size, access, mr);\n\tif (err)\n\t\tmthca_free_mtt(dev, mr->mtt);\n\n\treturn err;\n}\n\n \nstatic void mthca_free_region(struct mthca_dev *dev, u32 lkey)\n{\n\tmthca_table_put(dev, dev->mr_table.mpt_table,\n\t\t\tkey_to_hw_index(dev, lkey));\n\n\tmthca_free(&dev->mr_table.mpt_alloc, key_to_hw_index(dev, lkey));\n}\n\nvoid mthca_free_mr(struct mthca_dev *dev, struct mthca_mr *mr)\n{\n\tint err;\n\n\terr = mthca_HW2SW_MPT(dev, NULL,\n\t\t\t      key_to_hw_index(dev, mr->ibmr.lkey) &\n\t\t\t      (dev->limits.num_mpts - 1));\n\tif (err)\n\t\tmthca_warn(dev, \"HW2SW_MPT failed (%d)\\n\", err);\n\n\tmthca_free_region(dev, mr->ibmr.lkey);\n\tmthca_free_mtt(dev, mr->mtt);\n}\n\nint mthca_init_mr_table(struct mthca_dev *dev)\n{\n\tphys_addr_t addr;\n\tint mpts, mtts, err, i;\n\n\terr = mthca_alloc_init(&dev->mr_table.mpt_alloc,\n\t\t\t       dev->limits.num_mpts,\n\t\t\t       ~0, dev->limits.reserved_mrws);\n\tif (err)\n\t\treturn err;\n\n\tif (!mthca_is_memfree(dev) &&\n\t    (dev->mthca_flags & MTHCA_FLAG_DDR_HIDDEN))\n\t\tdev->limits.fmr_reserved_mtts = 0;\n\telse\n\t\tdev->mthca_flags |= MTHCA_FLAG_FMR;\n\n\tif (dev->mthca_flags & MTHCA_FLAG_SINAI_OPT)\n\t\tmthca_dbg(dev, \"Memory key throughput optimization activated.\\n\");\n\n\terr = mthca_buddy_init(&dev->mr_table.mtt_buddy,\n\t\t\t       fls(dev->limits.num_mtt_segs - 1));\n\n\tif (err)\n\t\tgoto err_mtt_buddy;\n\n\tdev->mr_table.tavor_fmr.mpt_base = NULL;\n\tdev->mr_table.tavor_fmr.mtt_base = NULL;\n\n\tif (dev->limits.fmr_reserved_mtts) {\n\t\ti = fls(dev->limits.fmr_reserved_mtts - 1);\n\n\t\tif (i >= 31) {\n\t\t\tmthca_warn(dev, \"Unable to reserve 2^31 FMR MTTs.\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto err_fmr_mpt;\n\t\t}\n\t\tmpts = mtts = 1 << i;\n\t} else {\n\t\tmtts = dev->limits.num_mtt_segs;\n\t\tmpts = dev->limits.num_mpts;\n\t}\n\n\tif (!mthca_is_memfree(dev) &&\n\t    (dev->mthca_flags & MTHCA_FLAG_FMR)) {\n\n\t\taddr = pci_resource_start(dev->pdev, 4) +\n\t\t\t((pci_resource_len(dev->pdev, 4) - 1) &\n\t\t\t dev->mr_table.mpt_base);\n\n\t\tdev->mr_table.tavor_fmr.mpt_base =\n\t\t\tioremap(addr, mpts * sizeof(struct mthca_mpt_entry));\n\n\t\tif (!dev->mr_table.tavor_fmr.mpt_base) {\n\t\t\tmthca_warn(dev, \"MPT ioremap for FMR failed.\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_fmr_mpt;\n\t\t}\n\n\t\taddr = pci_resource_start(dev->pdev, 4) +\n\t\t\t((pci_resource_len(dev->pdev, 4) - 1) &\n\t\t\t dev->mr_table.mtt_base);\n\n\t\tdev->mr_table.tavor_fmr.mtt_base =\n\t\t\tioremap(addr, mtts * dev->limits.mtt_seg_size);\n\t\tif (!dev->mr_table.tavor_fmr.mtt_base) {\n\t\t\tmthca_warn(dev, \"MTT ioremap for FMR failed.\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_fmr_mtt;\n\t\t}\n\t}\n\n\tif (dev->limits.fmr_reserved_mtts) {\n\t\terr = mthca_buddy_init(&dev->mr_table.tavor_fmr.mtt_buddy, fls(mtts - 1));\n\t\tif (err)\n\t\t\tgoto err_fmr_mtt_buddy;\n\n\t\t \n\t\terr = mthca_buddy_alloc(&dev->mr_table.mtt_buddy, fls(mtts - 1));\n\t\tif (err)\n\t\t\tgoto err_reserve_fmr;\n\n\t\tdev->mr_table.fmr_mtt_buddy =\n\t\t\t&dev->mr_table.tavor_fmr.mtt_buddy;\n\t} else\n\t\tdev->mr_table.fmr_mtt_buddy = &dev->mr_table.mtt_buddy;\n\n\t \n\tif (dev->limits.reserved_mtts) {\n\t\ti = fls(dev->limits.reserved_mtts - 1);\n\n\t\tif (mthca_alloc_mtt_range(dev, i,\n\t\t\t\t\t  dev->mr_table.fmr_mtt_buddy) == -1) {\n\t\t\tmthca_warn(dev, \"MTT table of order %d is too small.\\n\",\n\t\t\t\t  dev->mr_table.fmr_mtt_buddy->max_order);\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_reserve_mtts;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_reserve_mtts:\nerr_reserve_fmr:\n\tif (dev->limits.fmr_reserved_mtts)\n\t\tmthca_buddy_cleanup(&dev->mr_table.tavor_fmr.mtt_buddy);\n\nerr_fmr_mtt_buddy:\n\tif (dev->mr_table.tavor_fmr.mtt_base)\n\t\tiounmap(dev->mr_table.tavor_fmr.mtt_base);\n\nerr_fmr_mtt:\n\tif (dev->mr_table.tavor_fmr.mpt_base)\n\t\tiounmap(dev->mr_table.tavor_fmr.mpt_base);\n\nerr_fmr_mpt:\n\tmthca_buddy_cleanup(&dev->mr_table.mtt_buddy);\n\nerr_mtt_buddy:\n\tmthca_alloc_cleanup(&dev->mr_table.mpt_alloc);\n\n\treturn err;\n}\n\nvoid mthca_cleanup_mr_table(struct mthca_dev *dev)\n{\n\t \n\tif (dev->limits.fmr_reserved_mtts)\n\t\tmthca_buddy_cleanup(&dev->mr_table.tavor_fmr.mtt_buddy);\n\n\tmthca_buddy_cleanup(&dev->mr_table.mtt_buddy);\n\n\tif (dev->mr_table.tavor_fmr.mtt_base)\n\t\tiounmap(dev->mr_table.tavor_fmr.mtt_base);\n\tif (dev->mr_table.tavor_fmr.mpt_base)\n\t\tiounmap(dev->mr_table.tavor_fmr.mpt_base);\n\n\tmthca_alloc_cleanup(&dev->mr_table.mpt_alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}