{
  "module_name": "mthca_memfree.c",
  "hash_id": "bbd5d0c1e0c319144ddea4ca83a2c874361a124ea9c27c3cedbbd8bbb7e6f03a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_memfree.c",
  "human_readable_source": " \n\n#include <linux/mm.h>\n#include <linux/scatterlist.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n\n#include <asm/page.h>\n\n#include \"mthca_memfree.h\"\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n\n \nenum {\n\tMTHCA_ICM_ALLOC_SIZE   = 1 << 18,\n\tMTHCA_TABLE_CHUNK_SIZE = 1 << 18\n};\n\nstruct mthca_user_db_table {\n\tstruct mutex mutex;\n\tstruct {\n\t\tu64                uvirt;\n\t\tstruct scatterlist mem;\n\t\tint                refcount;\n\t} page[];\n};\n\nstatic void mthca_free_icm_pages(struct mthca_dev *dev, struct mthca_icm_chunk *chunk)\n{\n\tint i;\n\n\tif (chunk->nsg > 0)\n\t\tdma_unmap_sg(&dev->pdev->dev, chunk->mem, chunk->npages,\n\t\t\t     DMA_BIDIRECTIONAL);\n\n\tfor (i = 0; i < chunk->npages; ++i)\n\t\t__free_pages(sg_page(&chunk->mem[i]),\n\t\t\t     get_order(chunk->mem[i].length));\n}\n\nstatic void mthca_free_icm_coherent(struct mthca_dev *dev, struct mthca_icm_chunk *chunk)\n{\n\tint i;\n\n\tfor (i = 0; i < chunk->npages; ++i) {\n\t\tdma_free_coherent(&dev->pdev->dev, chunk->mem[i].length,\n\t\t\t\t  lowmem_page_address(sg_page(&chunk->mem[i])),\n\t\t\t\t  sg_dma_address(&chunk->mem[i]));\n\t}\n}\n\nvoid mthca_free_icm(struct mthca_dev *dev, struct mthca_icm *icm, int coherent)\n{\n\tstruct mthca_icm_chunk *chunk, *tmp;\n\n\tif (!icm)\n\t\treturn;\n\n\tlist_for_each_entry_safe(chunk, tmp, &icm->chunk_list, list) {\n\t\tif (coherent)\n\t\t\tmthca_free_icm_coherent(dev, chunk);\n\t\telse\n\t\t\tmthca_free_icm_pages(dev, chunk);\n\n\t\tkfree(chunk);\n\t}\n\n\tkfree(icm);\n}\n\nstatic int mthca_alloc_icm_pages(struct scatterlist *mem, int order, gfp_t gfp_mask)\n{\n\tstruct page *page;\n\n\t \n\tpage = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tsg_set_page(mem, page, PAGE_SIZE << order, 0);\n\treturn 0;\n}\n\nstatic int mthca_alloc_icm_coherent(struct device *dev, struct scatterlist *mem,\n\t\t\t\t    int order, gfp_t gfp_mask)\n{\n\tvoid *buf = dma_alloc_coherent(dev, PAGE_SIZE << order, &sg_dma_address(mem),\n\t\t\t\t       gfp_mask);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsg_set_buf(mem, buf, PAGE_SIZE << order);\n\tBUG_ON(mem->offset);\n\tsg_dma_len(mem) = PAGE_SIZE << order;\n\treturn 0;\n}\n\nstruct mthca_icm *mthca_alloc_icm(struct mthca_dev *dev, int npages,\n\t\t\t\t  gfp_t gfp_mask, int coherent)\n{\n\tstruct mthca_icm *icm;\n\tstruct mthca_icm_chunk *chunk = NULL;\n\tint cur_order;\n\tint ret;\n\n\t \n\tBUG_ON(coherent && (gfp_mask & __GFP_HIGHMEM));\n\n\ticm = kmalloc(sizeof *icm, gfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN));\n\tif (!icm)\n\t\treturn icm;\n\n\ticm->refcount = 0;\n\tINIT_LIST_HEAD(&icm->chunk_list);\n\n\tcur_order = get_order(MTHCA_ICM_ALLOC_SIZE);\n\n\twhile (npages > 0) {\n\t\tif (!chunk) {\n\t\t\tchunk = kmalloc(sizeof *chunk,\n\t\t\t\t\tgfp_mask & ~(__GFP_HIGHMEM | __GFP_NOWARN));\n\t\t\tif (!chunk)\n\t\t\t\tgoto fail;\n\n\t\t\tsg_init_table(chunk->mem, MTHCA_ICM_CHUNK_LEN);\n\t\t\tchunk->npages = 0;\n\t\t\tchunk->nsg    = 0;\n\t\t\tlist_add_tail(&chunk->list, &icm->chunk_list);\n\t\t}\n\n\t\twhile (1 << cur_order > npages)\n\t\t\t--cur_order;\n\n\t\tif (coherent)\n\t\t\tret = mthca_alloc_icm_coherent(&dev->pdev->dev,\n\t\t\t\t\t\t       &chunk->mem[chunk->npages],\n\t\t\t\t\t\t       cur_order, gfp_mask);\n\t\telse\n\t\t\tret = mthca_alloc_icm_pages(&chunk->mem[chunk->npages],\n\t\t\t\t\t\t    cur_order, gfp_mask);\n\n\t\tif (!ret) {\n\t\t\t++chunk->npages;\n\n\t\t\tif (coherent)\n\t\t\t\t++chunk->nsg;\n\t\t\telse if (chunk->npages == MTHCA_ICM_CHUNK_LEN) {\n\t\t\t\tchunk->nsg =\n\t\t\t\t\tdma_map_sg(&dev->pdev->dev, chunk->mem,\n\t\t\t\t\t\t   chunk->npages,\n\t\t\t\t\t\t   DMA_BIDIRECTIONAL);\n\n\t\t\t\tif (chunk->nsg <= 0)\n\t\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tif (chunk->npages == MTHCA_ICM_CHUNK_LEN)\n\t\t\t\tchunk = NULL;\n\n\t\t\tnpages -= 1 << cur_order;\n\t\t} else {\n\t\t\t--cur_order;\n\t\t\tif (cur_order < 0)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (!coherent && chunk) {\n\t\tchunk->nsg = dma_map_sg(&dev->pdev->dev, chunk->mem,\n\t\t\t\t\tchunk->npages, DMA_BIDIRECTIONAL);\n\n\t\tif (chunk->nsg <= 0)\n\t\t\tgoto fail;\n\t}\n\n\treturn icm;\n\nfail:\n\tmthca_free_icm(dev, icm, coherent);\n\treturn NULL;\n}\n\nint mthca_table_get(struct mthca_dev *dev, struct mthca_icm_table *table, int obj)\n{\n\tint i = (obj & (table->num_obj - 1)) * table->obj_size / MTHCA_TABLE_CHUNK_SIZE;\n\tint ret = 0;\n\n\tmutex_lock(&table->mutex);\n\n\tif (table->icm[i]) {\n\t\t++table->icm[i]->refcount;\n\t\tgoto out;\n\t}\n\n\ttable->icm[i] = mthca_alloc_icm(dev, MTHCA_TABLE_CHUNK_SIZE >> PAGE_SHIFT,\n\t\t\t\t\t(table->lowmem ? GFP_KERNEL : GFP_HIGHUSER) |\n\t\t\t\t\t__GFP_NOWARN, table->coherent);\n\tif (!table->icm[i]) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (mthca_MAP_ICM(dev, table->icm[i],\n\t\t\t  table->virt + i * MTHCA_TABLE_CHUNK_SIZE)) {\n\t\tmthca_free_icm(dev, table->icm[i], table->coherent);\n\t\ttable->icm[i] = NULL;\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t++table->icm[i]->refcount;\n\nout:\n\tmutex_unlock(&table->mutex);\n\treturn ret;\n}\n\nvoid mthca_table_put(struct mthca_dev *dev, struct mthca_icm_table *table, int obj)\n{\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn;\n\n\ti = (obj & (table->num_obj - 1)) * table->obj_size / MTHCA_TABLE_CHUNK_SIZE;\n\n\tmutex_lock(&table->mutex);\n\n\tif (--table->icm[i]->refcount == 0) {\n\t\tmthca_UNMAP_ICM(dev, table->virt + i * MTHCA_TABLE_CHUNK_SIZE,\n\t\t\t\tMTHCA_TABLE_CHUNK_SIZE / MTHCA_ICM_PAGE_SIZE);\n\t\tmthca_free_icm(dev, table->icm[i], table->coherent);\n\t\ttable->icm[i] = NULL;\n\t}\n\n\tmutex_unlock(&table->mutex);\n}\n\nvoid *mthca_table_find(struct mthca_icm_table *table, int obj, dma_addr_t *dma_handle)\n{\n\tint idx, offset, dma_offset, i;\n\tstruct mthca_icm_chunk *chunk;\n\tstruct mthca_icm *icm;\n\tstruct page *page = NULL;\n\n\tif (!table->lowmem)\n\t\treturn NULL;\n\n\tmutex_lock(&table->mutex);\n\n\tidx = (obj & (table->num_obj - 1)) * table->obj_size;\n\ticm = table->icm[idx / MTHCA_TABLE_CHUNK_SIZE];\n\tdma_offset = offset = idx % MTHCA_TABLE_CHUNK_SIZE;\n\n\tif (!icm)\n\t\tgoto out;\n\n\tlist_for_each_entry(chunk, &icm->chunk_list, list) {\n\t\tfor (i = 0; i < chunk->npages; ++i) {\n\t\t\tif (dma_handle && dma_offset >= 0) {\n\t\t\t\tif (sg_dma_len(&chunk->mem[i]) > dma_offset)\n\t\t\t\t\t*dma_handle = sg_dma_address(&chunk->mem[i]) +\n\t\t\t\t\t\tdma_offset;\n\t\t\t\tdma_offset -= sg_dma_len(&chunk->mem[i]);\n\t\t\t}\n\t\t\t \n\t\t\tif (chunk->mem[i].length > offset) {\n\t\t\t\tpage = sg_page(&chunk->mem[i]);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\toffset -= chunk->mem[i].length;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&table->mutex);\n\treturn page ? lowmem_page_address(page) + offset : NULL;\n}\n\nint mthca_table_get_range(struct mthca_dev *dev, struct mthca_icm_table *table,\n\t\t\t  int start, int end)\n{\n\tint inc = MTHCA_TABLE_CHUNK_SIZE / table->obj_size;\n\tint i, err;\n\n\tfor (i = start; i <= end; i += inc) {\n\t\terr = mthca_table_get(dev, table, i);\n\t\tif (err)\n\t\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\twhile (i > start) {\n\t\ti -= inc;\n\t\tmthca_table_put(dev, table, i);\n\t}\n\n\treturn err;\n}\n\nvoid mthca_table_put_range(struct mthca_dev *dev, struct mthca_icm_table *table,\n\t\t\t   int start, int end)\n{\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn;\n\n\tfor (i = start; i <= end; i += MTHCA_TABLE_CHUNK_SIZE / table->obj_size)\n\t\tmthca_table_put(dev, table, i);\n}\n\nstruct mthca_icm_table *mthca_alloc_icm_table(struct mthca_dev *dev,\n\t\t\t\t\t      u64 virt, int obj_size,\n\t\t\t\t\t      int nobj, int reserved,\n\t\t\t\t\t      int use_lowmem, int use_coherent)\n{\n\tstruct mthca_icm_table *table;\n\tint obj_per_chunk;\n\tint num_icm;\n\tunsigned chunk_size;\n\tint i;\n\n\tobj_per_chunk = MTHCA_TABLE_CHUNK_SIZE / obj_size;\n\tnum_icm = DIV_ROUND_UP(nobj, obj_per_chunk);\n\n\ttable = kmalloc(struct_size(table, icm, num_icm), GFP_KERNEL);\n\tif (!table)\n\t\treturn NULL;\n\n\ttable->virt     = virt;\n\ttable->num_icm  = num_icm;\n\ttable->num_obj  = nobj;\n\ttable->obj_size = obj_size;\n\ttable->lowmem   = use_lowmem;\n\ttable->coherent = use_coherent;\n\tmutex_init(&table->mutex);\n\n\tfor (i = 0; i < num_icm; ++i)\n\t\ttable->icm[i] = NULL;\n\n\tfor (i = 0; i * MTHCA_TABLE_CHUNK_SIZE < reserved * obj_size; ++i) {\n\t\tchunk_size = MTHCA_TABLE_CHUNK_SIZE;\n\t\tif ((i + 1) * MTHCA_TABLE_CHUNK_SIZE > nobj * obj_size)\n\t\t\tchunk_size = nobj * obj_size - i * MTHCA_TABLE_CHUNK_SIZE;\n\n\t\ttable->icm[i] = mthca_alloc_icm(dev, chunk_size >> PAGE_SHIFT,\n\t\t\t\t\t\t(use_lowmem ? GFP_KERNEL : GFP_HIGHUSER) |\n\t\t\t\t\t\t__GFP_NOWARN, use_coherent);\n\t\tif (!table->icm[i])\n\t\t\tgoto err;\n\t\tif (mthca_MAP_ICM(dev, table->icm[i],\n\t\t\t\t  virt + i * MTHCA_TABLE_CHUNK_SIZE)) {\n\t\t\tmthca_free_icm(dev, table->icm[i], table->coherent);\n\t\t\ttable->icm[i] = NULL;\n\t\t\tgoto err;\n\t\t}\n\n\t\t \n\t\t++table->icm[i]->refcount;\n\t}\n\n\treturn table;\n\nerr:\n\tfor (i = 0; i < num_icm; ++i)\n\t\tif (table->icm[i]) {\n\t\t\tmthca_UNMAP_ICM(dev, virt + i * MTHCA_TABLE_CHUNK_SIZE,\n\t\t\t\t\tMTHCA_TABLE_CHUNK_SIZE / MTHCA_ICM_PAGE_SIZE);\n\t\t\tmthca_free_icm(dev, table->icm[i], table->coherent);\n\t\t}\n\n\tkfree(table);\n\n\treturn NULL;\n}\n\nvoid mthca_free_icm_table(struct mthca_dev *dev, struct mthca_icm_table *table)\n{\n\tint i;\n\n\tfor (i = 0; i < table->num_icm; ++i)\n\t\tif (table->icm[i]) {\n\t\t\tmthca_UNMAP_ICM(dev,\n\t\t\t\t\ttable->virt + i * MTHCA_TABLE_CHUNK_SIZE,\n\t\t\t\t\tMTHCA_TABLE_CHUNK_SIZE / MTHCA_ICM_PAGE_SIZE);\n\t\t\tmthca_free_icm(dev, table->icm[i], table->coherent);\n\t\t}\n\n\tkfree(table);\n}\n\nstatic u64 mthca_uarc_virt(struct mthca_dev *dev, struct mthca_uar *uar, int page)\n{\n\treturn dev->uar_table.uarc_base +\n\t\tuar->index * dev->uar_table.uarc_size +\n\t\tpage * MTHCA_ICM_PAGE_SIZE;\n}\n\nint mthca_map_user_db(struct mthca_dev *dev, struct mthca_uar *uar,\n\t\t      struct mthca_user_db_table *db_tab, int index, u64 uaddr)\n{\n\tstruct page *pages[1];\n\tint ret = 0;\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn 0;\n\n\tif (index < 0 || index > dev->uar_table.uarc_size / 8)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&db_tab->mutex);\n\n\ti = index / MTHCA_DB_REC_PER_PAGE;\n\n\tif ((db_tab->page[i].refcount >= MTHCA_DB_REC_PER_PAGE)       ||\n\t    (db_tab->page[i].uvirt && db_tab->page[i].uvirt != uaddr) ||\n\t    (uaddr & 4095)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (db_tab->page[i].refcount) {\n\t\t++db_tab->page[i].refcount;\n\t\tgoto out;\n\t}\n\n\tret = pin_user_pages_fast(uaddr & PAGE_MASK, 1,\n\t\t\t\t  FOLL_WRITE | FOLL_LONGTERM, pages);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tsg_set_page(&db_tab->page[i].mem, pages[0], MTHCA_ICM_PAGE_SIZE,\n\t\t\tuaddr & ~PAGE_MASK);\n\n\tret = dma_map_sg(&dev->pdev->dev, &db_tab->page[i].mem, 1,\n\t\t\t DMA_TO_DEVICE);\n\tif (ret < 0) {\n\t\tunpin_user_page(pages[0]);\n\t\tgoto out;\n\t}\n\n\tret = mthca_MAP_ICM_page(dev, sg_dma_address(&db_tab->page[i].mem),\n\t\t\t\t mthca_uarc_virt(dev, uar, i));\n\tif (ret) {\n\t\tdma_unmap_sg(&dev->pdev->dev, &db_tab->page[i].mem, 1,\n\t\t\t     DMA_TO_DEVICE);\n\t\tunpin_user_page(sg_page(&db_tab->page[i].mem));\n\t\tgoto out;\n\t}\n\n\tdb_tab->page[i].uvirt    = uaddr;\n\tdb_tab->page[i].refcount = 1;\n\nout:\n\tmutex_unlock(&db_tab->mutex);\n\treturn ret;\n}\n\nvoid mthca_unmap_user_db(struct mthca_dev *dev, struct mthca_uar *uar,\n\t\t\t struct mthca_user_db_table *db_tab, int index)\n{\n\tif (!mthca_is_memfree(dev))\n\t\treturn;\n\n\t \n\n\tmutex_lock(&db_tab->mutex);\n\n\t--db_tab->page[index / MTHCA_DB_REC_PER_PAGE].refcount;\n\n\tmutex_unlock(&db_tab->mutex);\n}\n\nstruct mthca_user_db_table *mthca_init_user_db_tab(struct mthca_dev *dev)\n{\n\tstruct mthca_user_db_table *db_tab;\n\tint npages;\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn NULL;\n\n\tnpages = dev->uar_table.uarc_size / MTHCA_ICM_PAGE_SIZE;\n\tdb_tab = kmalloc(struct_size(db_tab, page, npages), GFP_KERNEL);\n\tif (!db_tab)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmutex_init(&db_tab->mutex);\n\tfor (i = 0; i < npages; ++i) {\n\t\tdb_tab->page[i].refcount = 0;\n\t\tdb_tab->page[i].uvirt    = 0;\n\t\tsg_init_table(&db_tab->page[i].mem, 1);\n\t}\n\n\treturn db_tab;\n}\n\nvoid mthca_cleanup_user_db_tab(struct mthca_dev *dev, struct mthca_uar *uar,\n\t\t\t       struct mthca_user_db_table *db_tab)\n{\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn;\n\n\tfor (i = 0; i < dev->uar_table.uarc_size / MTHCA_ICM_PAGE_SIZE; ++i) {\n\t\tif (db_tab->page[i].uvirt) {\n\t\t\tmthca_UNMAP_ICM(dev, mthca_uarc_virt(dev, uar, i), 1);\n\t\t\tdma_unmap_sg(&dev->pdev->dev, &db_tab->page[i].mem, 1,\n\t\t\t\t     DMA_TO_DEVICE);\n\t\t\tunpin_user_page(sg_page(&db_tab->page[i].mem));\n\t\t}\n\t}\n\n\tkfree(db_tab);\n}\n\nint mthca_alloc_db(struct mthca_dev *dev, enum mthca_db_type type,\n\t\t   u32 qn, __be32 **db)\n{\n\tint group;\n\tint start, end, dir;\n\tint i, j;\n\tstruct mthca_db_page *page;\n\tint ret = 0;\n\n\tmutex_lock(&dev->db_tab->mutex);\n\n\tswitch (type) {\n\tcase MTHCA_DB_TYPE_CQ_ARM:\n\tcase MTHCA_DB_TYPE_SQ:\n\t\tgroup = 0;\n\t\tstart = 0;\n\t\tend   = dev->db_tab->max_group1;\n\t\tdir   = 1;\n\t\tbreak;\n\n\tcase MTHCA_DB_TYPE_CQ_SET_CI:\n\tcase MTHCA_DB_TYPE_RQ:\n\tcase MTHCA_DB_TYPE_SRQ:\n\t\tgroup = 1;\n\t\tstart = dev->db_tab->npages - 1;\n\t\tend   = dev->db_tab->min_group2;\n\t\tdir   = -1;\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = start; i != end; i += dir)\n\t\tif (dev->db_tab->page[i].db_rec &&\n\t\t    !bitmap_full(dev->db_tab->page[i].used,\n\t\t\t\t MTHCA_DB_REC_PER_PAGE)) {\n\t\t\tpage = dev->db_tab->page + i;\n\t\t\tgoto found;\n\t\t}\n\n\tfor (i = start; i != end; i += dir)\n\t\tif (!dev->db_tab->page[i].db_rec) {\n\t\t\tpage = dev->db_tab->page + i;\n\t\t\tgoto alloc;\n\t\t}\n\n\tif (dev->db_tab->max_group1 >= dev->db_tab->min_group2 - 1) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (group == 0)\n\t\t++dev->db_tab->max_group1;\n\telse\n\t\t--dev->db_tab->min_group2;\n\n\tpage = dev->db_tab->page + end;\n\nalloc:\n\tpage->db_rec = dma_alloc_coherent(&dev->pdev->dev,\n\t\t\t\t\t  MTHCA_ICM_PAGE_SIZE, &page->mapping,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!page->db_rec) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = mthca_MAP_ICM_page(dev, page->mapping,\n\t\t\t\t mthca_uarc_virt(dev, &dev->driver_uar, i));\n\tif (ret) {\n\t\tdma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,\n\t\t\t\t  page->db_rec, page->mapping);\n\t\tgoto out;\n\t}\n\n\tbitmap_zero(page->used, MTHCA_DB_REC_PER_PAGE);\n\nfound:\n\tj = find_first_zero_bit(page->used, MTHCA_DB_REC_PER_PAGE);\n\tset_bit(j, page->used);\n\n\tif (group == 1)\n\t\tj = MTHCA_DB_REC_PER_PAGE - 1 - j;\n\n\tret = i * MTHCA_DB_REC_PER_PAGE + j;\n\n\tpage->db_rec[j] = cpu_to_be64((qn << 8) | (type << 5));\n\n\t*db = (__be32 *) &page->db_rec[j];\n\nout:\n\tmutex_unlock(&dev->db_tab->mutex);\n\n\treturn ret;\n}\n\nvoid mthca_free_db(struct mthca_dev *dev, int type, int db_index)\n{\n\tint i, j;\n\tstruct mthca_db_page *page;\n\n\ti = db_index / MTHCA_DB_REC_PER_PAGE;\n\tj = db_index % MTHCA_DB_REC_PER_PAGE;\n\n\tpage = dev->db_tab->page + i;\n\n\tmutex_lock(&dev->db_tab->mutex);\n\n\tpage->db_rec[j] = 0;\n\tif (i >= dev->db_tab->min_group2)\n\t\tj = MTHCA_DB_REC_PER_PAGE - 1 - j;\n\tclear_bit(j, page->used);\n\n\tif (bitmap_empty(page->used, MTHCA_DB_REC_PER_PAGE) &&\n\t    i >= dev->db_tab->max_group1 - 1) {\n\t\tmthca_UNMAP_ICM(dev, mthca_uarc_virt(dev, &dev->driver_uar, i), 1);\n\n\t\tdma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,\n\t\t\t\t  page->db_rec, page->mapping);\n\t\tpage->db_rec = NULL;\n\n\t\tif (i == dev->db_tab->max_group1) {\n\t\t\t--dev->db_tab->max_group1;\n\t\t\t \n\t\t}\n\t\tif (i == dev->db_tab->min_group2)\n\t\t\t++dev->db_tab->min_group2;\n\t}\n\n\tmutex_unlock(&dev->db_tab->mutex);\n}\n\nint mthca_init_db_tab(struct mthca_dev *dev)\n{\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn 0;\n\n\tdev->db_tab = kmalloc(sizeof *dev->db_tab, GFP_KERNEL);\n\tif (!dev->db_tab)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->db_tab->mutex);\n\n\tdev->db_tab->npages     = dev->uar_table.uarc_size / MTHCA_ICM_PAGE_SIZE;\n\tdev->db_tab->max_group1 = 0;\n\tdev->db_tab->min_group2 = dev->db_tab->npages - 1;\n\n\tdev->db_tab->page = kmalloc_array(dev->db_tab->npages,\n\t\t\t\t\t  sizeof(*dev->db_tab->page),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dev->db_tab->page) {\n\t\tkfree(dev->db_tab);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < dev->db_tab->npages; ++i)\n\t\tdev->db_tab->page[i].db_rec = NULL;\n\n\treturn 0;\n}\n\nvoid mthca_cleanup_db_tab(struct mthca_dev *dev)\n{\n\tint i;\n\n\tif (!mthca_is_memfree(dev))\n\t\treturn;\n\n\t \n\tfor (i = 0; i < dev->db_tab->npages; ++i) {\n\t\tif (!dev->db_tab->page[i].db_rec)\n\t\t\tcontinue;\n\n\t\tif (!bitmap_empty(dev->db_tab->page[i].used, MTHCA_DB_REC_PER_PAGE))\n\t\t\tmthca_warn(dev, \"Kernel UARC page %d not empty\\n\", i);\n\n\t\tmthca_UNMAP_ICM(dev, mthca_uarc_virt(dev, &dev->driver_uar, i), 1);\n\n\t\tdma_free_coherent(&dev->pdev->dev, MTHCA_ICM_PAGE_SIZE,\n\t\t\t\t  dev->db_tab->page[i].db_rec,\n\t\t\t\t  dev->db_tab->page[i].mapping);\n\t}\n\n\tkfree(dev->db_tab->page);\n\tkfree(dev->db_tab);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}