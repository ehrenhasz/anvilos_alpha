{
  "module_name": "mthca_mad.c",
  "hash_id": "c153db0edabd569b4fb14b731f244e8cfbe6da9cce99886bf518651615db5440",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_mad.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/slab.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_mad.h>\n#include <rdma/ib_smi.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n\nenum {\n\tMTHCA_VENDOR_CLASS1 = 0x9,\n\tMTHCA_VENDOR_CLASS2 = 0xa\n};\n\nstatic int mthca_update_rate(struct mthca_dev *dev, u8 port_num)\n{\n\tstruct ib_port_attr *tprops = NULL;\n\tint                  ret;\n\n\ttprops = kmalloc(sizeof *tprops, GFP_KERNEL);\n\tif (!tprops)\n\t\treturn -ENOMEM;\n\n\tret = ib_query_port(&dev->ib_dev, port_num, tprops);\n\tif (ret) {\n\t\tdev_warn(&dev->ib_dev.dev,\n\t\t\t \"ib_query_port failed (%d) forport %d\\n\", ret,\n\t\t\t port_num);\n\t\tgoto out;\n\t}\n\n\tdev->rate[port_num - 1] = tprops->active_speed *\n\t\t\t\t  ib_width_enum_to_int(tprops->active_width);\n\nout:\n\tkfree(tprops);\n\treturn ret;\n}\n\nstatic void update_sm_ah(struct mthca_dev *dev,\n\t\t\t u8 port_num, u16 lid, u8 sl)\n{\n\tstruct ib_ah *new_ah;\n\tstruct rdma_ah_attr ah_attr;\n\tunsigned long flags;\n\n\tif (!dev->send_agent[port_num - 1][0])\n\t\treturn;\n\n\tmemset(&ah_attr, 0, sizeof ah_attr);\n\tah_attr.type = rdma_ah_find_type(&dev->ib_dev, port_num);\n\trdma_ah_set_dlid(&ah_attr, lid);\n\trdma_ah_set_sl(&ah_attr, sl);\n\trdma_ah_set_port_num(&ah_attr, port_num);\n\n\tnew_ah = rdma_create_ah(dev->send_agent[port_num - 1][0]->qp->pd,\n\t\t\t\t&ah_attr, 0);\n\tif (IS_ERR(new_ah))\n\t\treturn;\n\n\tspin_lock_irqsave(&dev->sm_lock, flags);\n\tif (dev->sm_ah[port_num - 1])\n\t\trdma_destroy_ah(dev->sm_ah[port_num - 1], 0);\n\tdev->sm_ah[port_num - 1] = new_ah;\n\tspin_unlock_irqrestore(&dev->sm_lock, flags);\n}\n\n \nstatic void smp_snoop(struct ib_device *ibdev,\n\t\t      u8 port_num,\n\t\t      const struct ib_mad *mad,\n\t\t      u16 prev_lid)\n{\n\tstruct ib_event event;\n\n\tif ((mad->mad_hdr.mgmt_class  == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     mad->mad_hdr.mgmt_class  == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    mad->mad_hdr.method     == IB_MGMT_METHOD_SET) {\n\t\tif (mad->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO) {\n\t\t\tstruct ib_port_info *pinfo =\n\t\t\t\t(struct ib_port_info *) ((struct ib_smp *) mad)->data;\n\t\t\tu16 lid = be16_to_cpu(pinfo->lid);\n\n\t\t\tmthca_update_rate(to_mdev(ibdev), port_num);\n\t\t\tupdate_sm_ah(to_mdev(ibdev), port_num,\n\t\t\t\t     be16_to_cpu(pinfo->sm_lid),\n\t\t\t\t     pinfo->neighbormtu_mastersmsl & 0xf);\n\n\t\t\tevent.device           = ibdev;\n\t\t\tevent.element.port_num = port_num;\n\n\t\t\tif (pinfo->clientrereg_resv_subnetto & 0x80) {\n\t\t\t\tevent.event    = IB_EVENT_CLIENT_REREGISTER;\n\t\t\t\tib_dispatch_event(&event);\n\t\t\t}\n\n\t\t\tif (prev_lid != lid) {\n\t\t\t\tevent.event    = IB_EVENT_LID_CHANGE;\n\t\t\t\tib_dispatch_event(&event);\n\t\t\t}\n\t\t}\n\n\t\tif (mad->mad_hdr.attr_id == IB_SMP_ATTR_PKEY_TABLE) {\n\t\t\tevent.device           = ibdev;\n\t\t\tevent.event            = IB_EVENT_PKEY_CHANGE;\n\t\t\tevent.element.port_num = port_num;\n\t\t\tib_dispatch_event(&event);\n\t\t}\n\t}\n}\n\nstatic void node_desc_override(struct ib_device *dev,\n\t\t\t       struct ib_mad *mad)\n{\n\tif ((mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     mad->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    mad->mad_hdr.method == IB_MGMT_METHOD_GET_RESP &&\n\t    mad->mad_hdr.attr_id == IB_SMP_ATTR_NODE_DESC) {\n\t\tmutex_lock(&to_mdev(dev)->cap_mask_mutex);\n\t\tmemcpy(((struct ib_smp *) mad)->data, dev->node_desc,\n\t\t       IB_DEVICE_NODE_DESC_MAX);\n\t\tmutex_unlock(&to_mdev(dev)->cap_mask_mutex);\n\t}\n}\n\nstatic void forward_trap(struct mthca_dev *dev,\n\t\t\t u32 port_num,\n\t\t\t const struct ib_mad *mad)\n{\n\tint qpn = mad->mad_hdr.mgmt_class != IB_MGMT_CLASS_SUBN_LID_ROUTED;\n\tstruct ib_mad_send_buf *send_buf;\n\tstruct ib_mad_agent *agent = dev->send_agent[port_num - 1][qpn];\n\tint ret;\n\tunsigned long flags;\n\n\tif (agent) {\n\t\tsend_buf = ib_create_send_mad(agent, qpn, 0, 0, IB_MGMT_MAD_HDR,\n\t\t\t\t\t      IB_MGMT_MAD_DATA, GFP_ATOMIC,\n\t\t\t\t\t      IB_MGMT_BASE_VERSION);\n\t\tif (IS_ERR(send_buf))\n\t\t\treturn;\n\t\t \n\t\tspin_lock_irqsave(&dev->sm_lock, flags);\n\t\tmemcpy(send_buf->mad, mad, sizeof *mad);\n\t\tif ((send_buf->ah = dev->sm_ah[port_num - 1]))\n\t\t\tret = ib_post_send_mad(send_buf, NULL);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tspin_unlock_irqrestore(&dev->sm_lock, flags);\n\n\t\tif (ret)\n\t\t\tib_free_send_mad(send_buf);\n\t}\n}\n\nint mthca_process_mad(struct ib_device *ibdev, int mad_flags, u32 port_num,\n\t\t      const struct ib_wc *in_wc, const struct ib_grh *in_grh,\n\t\t      const struct ib_mad *in, struct ib_mad *out,\n\t\t      size_t *out_mad_size, u16 *out_mad_pkey_index)\n{\n\tint err;\n\tu16 slid = in_wc ? ib_lid_cpu16(in_wc->slid) : be16_to_cpu(IB_LID_PERMISSIVE);\n\tu16 prev_lid = 0;\n\tstruct ib_port_attr pattr;\n\n\t \n\tif (in->mad_hdr.method == IB_MGMT_METHOD_TRAP && !slid) {\n\t\tforward_trap(to_mdev(ibdev), port_num, in);\n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\t}\n\n\t \n\tif (in->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t    in->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) {\n\t\tif (in->mad_hdr.method != IB_MGMT_METHOD_GET &&\n\t\t    in->mad_hdr.method != IB_MGMT_METHOD_SET &&\n\t\t    in->mad_hdr.method != IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\n\t\t \n\t\tif (in->mad_hdr.attr_id == IB_SMP_ATTR_SM_INFO ||\n\t\t    ((in->mad_hdr.attr_id & IB_SMP_ATTR_VENDOR_MASK) ==\n\t\t     IB_SMP_ATTR_VENDOR_MASK))\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} else if (in->mad_hdr.mgmt_class == IB_MGMT_CLASS_PERF_MGMT ||\n\t\t   in->mad_hdr.mgmt_class == MTHCA_VENDOR_CLASS1     ||\n\t\t   in->mad_hdr.mgmt_class == MTHCA_VENDOR_CLASS2) {\n\t\tif (in->mad_hdr.method != IB_MGMT_METHOD_GET &&\n\t\t    in->mad_hdr.method != IB_MGMT_METHOD_SET)\n\t\t\treturn IB_MAD_RESULT_SUCCESS;\n\t} else\n\t\treturn IB_MAD_RESULT_SUCCESS;\n\tif ((in->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_LID_ROUTED ||\n\t     in->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE) &&\n\t    in->mad_hdr.method == IB_MGMT_METHOD_SET &&\n\t    in->mad_hdr.attr_id == IB_SMP_ATTR_PORT_INFO &&\n\t    !ib_query_port(ibdev, port_num, &pattr))\n\t\tprev_lid = ib_lid_cpu16(pattr.lid);\n\n\terr = mthca_MAD_IFC(to_mdev(ibdev), mad_flags & IB_MAD_IGNORE_MKEY,\n\t\t\t    mad_flags & IB_MAD_IGNORE_BKEY, port_num, in_wc,\n\t\t\t    in_grh, in, out);\n\tif (err == -EBADMSG)\n\t\treturn IB_MAD_RESULT_SUCCESS;\n\telse if (err) {\n\t\tmthca_err(to_mdev(ibdev), \"MAD_IFC returned %d\\n\", err);\n\t\treturn IB_MAD_RESULT_FAILURE;\n\t}\n\n\tif (!out->mad_hdr.status) {\n\t\tsmp_snoop(ibdev, port_num, in, prev_lid);\n\t\tnode_desc_override(ibdev, out);\n\t}\n\n\t \n\tif (in->mad_hdr.mgmt_class == IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE)\n\t\tout->mad_hdr.status |= cpu_to_be16(1 << 15);\n\n\tif (in->mad_hdr.method == IB_MGMT_METHOD_TRAP_REPRESS)\n\t\t \n\t\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_CONSUMED;\n\n\treturn IB_MAD_RESULT_SUCCESS | IB_MAD_RESULT_REPLY;\n}\n\nstatic void send_handler(struct ib_mad_agent *agent,\n\t\t\t struct ib_mad_send_wc *mad_send_wc)\n{\n\tib_free_send_mad(mad_send_wc->send_buf);\n}\n\nint mthca_create_agents(struct mthca_dev *dev)\n{\n\tstruct ib_mad_agent *agent;\n\tint p, q;\n\tint ret;\n\n\tspin_lock_init(&dev->sm_lock);\n\n\tfor (p = 0; p < dev->limits.num_ports; ++p)\n\t\tfor (q = 0; q <= 1; ++q) {\n\t\t\tagent = ib_register_mad_agent(&dev->ib_dev, p + 1,\n\t\t\t\t\t\t      q ? IB_QPT_GSI : IB_QPT_SMI,\n\t\t\t\t\t\t      NULL, 0, send_handler,\n\t\t\t\t\t\t      NULL, NULL, 0);\n\t\t\tif (IS_ERR(agent)) {\n\t\t\t\tret = PTR_ERR(agent);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdev->send_agent[p][q] = agent;\n\t\t}\n\n\n\tfor (p = 1; p <= dev->limits.num_ports; ++p) {\n\t\tret = mthca_update_rate(dev, p);\n\t\tif (ret) {\n\t\t\tmthca_err(dev, \"Failed to obtain port %d rate.\"\n\t\t\t\t  \" aborting.\\n\", p);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tfor (p = 0; p < dev->limits.num_ports; ++p)\n\t\tfor (q = 0; q <= 1; ++q)\n\t\t\tif (dev->send_agent[p][q])\n\t\t\t\tib_unregister_mad_agent(dev->send_agent[p][q]);\n\n\treturn ret;\n}\n\nvoid mthca_free_agents(struct mthca_dev *dev)\n{\n\tstruct ib_mad_agent *agent;\n\tint p, q;\n\n\tfor (p = 0; p < dev->limits.num_ports; ++p) {\n\t\tfor (q = 0; q <= 1; ++q) {\n\t\t\tagent = dev->send_agent[p][q];\n\t\t\tdev->send_agent[p][q] = NULL;\n\t\t\tib_unregister_mad_agent(agent);\n\t\t}\n\n\t\tif (dev->sm_ah[p])\n\t\t\trdma_destroy_ah(dev->sm_ah[p],\n\t\t\t\t\tRDMA_DESTROY_AH_SLEEPABLE);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}