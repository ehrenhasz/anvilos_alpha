{
  "module_name": "mthca_mcg.c",
  "hash_id": "46f32e325c4f56999c8995f883b441d0c4953dccfbdb00ed9e09fc56f123f5d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/mthca/mthca_mcg.c",
  "human_readable_source": " \n\n#include <linux/string.h>\n#include <linux/gfp.h>\n\n#include \"mthca_dev.h\"\n#include \"mthca_cmd.h\"\n\nstruct mthca_mgm {\n\t__be32 next_gid_index;\n\tu32    reserved[3];\n\tu8     gid[16];\n\t__be32 qp[MTHCA_QP_PER_MGM];\n};\n\nstatic const u8 zero_gid[16];\t \n\n \nstatic int find_mgm(struct mthca_dev *dev,\n\t\t    u8 *gid, struct mthca_mailbox *mgm_mailbox,\n\t\t    u16 *hash, int *prev, int *index)\n{\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_mgm *mgm = mgm_mailbox->buf;\n\tu8 *mgid;\n\tint err;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn -ENOMEM;\n\tmgid = mailbox->buf;\n\n\tmemcpy(mgid, gid, 16);\n\n\terr = mthca_MGID_HASH(dev, mailbox, hash);\n\tif (err) {\n\t\tmthca_err(dev, \"MGID_HASH failed (%d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (0)\n\t\tmthca_dbg(dev, \"Hash for %pI6 is %04x\\n\", gid, *hash);\n\n\t*index = *hash;\n\t*prev  = -1;\n\n\tdo {\n\t\terr = mthca_READ_MGM(dev, *index, mgm_mailbox);\n\t\tif (err) {\n\t\t\tmthca_err(dev, \"READ_MGM failed (%d)\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!memcmp(mgm->gid, zero_gid, 16)) {\n\t\t\tif (*index != *hash) {\n\t\t\t\tmthca_err(dev, \"Found zero MGID in AMGM.\\n\");\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!memcmp(mgm->gid, gid, 16))\n\t\t\tgoto out;\n\n\t\t*prev = *index;\n\t\t*index = be32_to_cpu(mgm->next_gid_index) >> 6;\n\t} while (*index);\n\n\t*index = -1;\n\n out:\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_multicast_attach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_mgm *mgm;\n\tu16 hash;\n\tint index, prev;\n\tint link = 0;\n\tint i;\n\tint err;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tmgm = mailbox->buf;\n\n\tmutex_lock(&dev->mcg_table.mutex);\n\n\terr = find_mgm(dev, gid->raw, mailbox, &hash, &prev, &index);\n\tif (err)\n\t\tgoto out;\n\n\tif (index != -1) {\n\t\tif (!memcmp(mgm->gid, zero_gid, 16))\n\t\t\tmemcpy(mgm->gid, gid->raw, 16);\n\t} else {\n\t\tlink = 1;\n\n\t\tindex = mthca_alloc(&dev->mcg_table.alloc);\n\t\tif (index == -1) {\n\t\t\tmthca_err(dev, \"No AMGM entries left\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = mthca_READ_MGM(dev, index, mailbox);\n\t\tif (err) {\n\t\t\tmthca_err(dev, \"READ_MGM failed (%d)\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tmemset(mgm, 0, sizeof *mgm);\n\t\tmemcpy(mgm->gid, gid->raw, 16);\n\t}\n\n\tfor (i = 0; i < MTHCA_QP_PER_MGM; ++i)\n\t\tif (mgm->qp[i] == cpu_to_be32(ibqp->qp_num | (1 << 31))) {\n\t\t\tmthca_dbg(dev, \"QP %06x already a member of MGM\\n\",\n\t\t\t\t  ibqp->qp_num);\n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t} else if (!(mgm->qp[i] & cpu_to_be32(1 << 31))) {\n\t\t\tmgm->qp[i] = cpu_to_be32(ibqp->qp_num | (1 << 31));\n\t\t\tbreak;\n\t\t}\n\n\tif (i == MTHCA_QP_PER_MGM) {\n\t\tmthca_err(dev, \"MGM at index %x is full.\\n\", index);\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terr = mthca_WRITE_MGM(dev, index, mailbox);\n\tif (err) {\n\t\tmthca_err(dev, \"WRITE_MGM failed %d\\n\", err);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!link)\n\t\tgoto out;\n\n\terr = mthca_READ_MGM(dev, prev, mailbox);\n\tif (err) {\n\t\tmthca_err(dev, \"READ_MGM failed %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tmgm->next_gid_index = cpu_to_be32(index << 6);\n\n\terr = mthca_WRITE_MGM(dev, prev, mailbox);\n\tif (err)\n\t\tmthca_err(dev, \"WRITE_MGM returned %d\\n\", err);\n\n out:\n\tif (err && link && index != -1) {\n\t\tBUG_ON(index < dev->limits.num_mgms);\n\t\tmthca_free(&dev->mcg_table.alloc, index);\n\t}\n\tmutex_unlock(&dev->mcg_table.mutex);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\n{\n\tstruct mthca_dev *dev = to_mdev(ibqp->device);\n\tstruct mthca_mailbox *mailbox;\n\tstruct mthca_mgm *mgm;\n\tu16 hash;\n\tint prev, index;\n\tint i, loc;\n\tint err;\n\n\tmailbox = mthca_alloc_mailbox(dev, GFP_KERNEL);\n\tif (IS_ERR(mailbox))\n\t\treturn PTR_ERR(mailbox);\n\tmgm = mailbox->buf;\n\n\tmutex_lock(&dev->mcg_table.mutex);\n\n\terr = find_mgm(dev, gid->raw, mailbox, &hash, &prev, &index);\n\tif (err)\n\t\tgoto out;\n\n\tif (index == -1) {\n\t\tmthca_err(dev, \"MGID %pI6 not found\\n\", gid->raw);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (loc = -1, i = 0; i < MTHCA_QP_PER_MGM; ++i) {\n\t\tif (mgm->qp[i] == cpu_to_be32(ibqp->qp_num | (1 << 31)))\n\t\t\tloc = i;\n\t\tif (!(mgm->qp[i] & cpu_to_be32(1 << 31)))\n\t\t\tbreak;\n\t}\n\n\tif (loc == -1) {\n\t\tmthca_err(dev, \"QP %06x not found in MGM\\n\", ibqp->qp_num);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmgm->qp[loc]   = mgm->qp[i - 1];\n\tmgm->qp[i - 1] = 0;\n\n\terr = mthca_WRITE_MGM(dev, index, mailbox);\n\tif (err) {\n\t\tmthca_err(dev, \"WRITE_MGM returned %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (i != 1)\n\t\tgoto out;\n\n\tif (prev == -1) {\n\t\t \n\t\tint amgm_index_to_free = be32_to_cpu(mgm->next_gid_index) >> 6;\n\t\tif (amgm_index_to_free) {\n\t\t\terr = mthca_READ_MGM(dev, amgm_index_to_free,\n\t\t\t\t\t     mailbox);\n\t\t\tif (err) {\n\t\t\t\tmthca_err(dev, \"READ_MGM returned %d\\n\", err);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else\n\t\t\tmemset(mgm->gid, 0, 16);\n\n\t\terr = mthca_WRITE_MGM(dev, index, mailbox);\n\t\tif (err) {\n\t\t\tmthca_err(dev, \"WRITE_MGM returned %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tif (amgm_index_to_free) {\n\t\t\tBUG_ON(amgm_index_to_free < dev->limits.num_mgms);\n\t\t\tmthca_free(&dev->mcg_table.alloc, amgm_index_to_free);\n\t\t}\n\t} else {\n\t\t \n\t\tint curr_next_index = be32_to_cpu(mgm->next_gid_index) >> 6;\n\t\terr = mthca_READ_MGM(dev, prev, mailbox);\n\t\tif (err) {\n\t\t\tmthca_err(dev, \"READ_MGM returned %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmgm->next_gid_index = cpu_to_be32(curr_next_index << 6);\n\n\t\terr = mthca_WRITE_MGM(dev, prev, mailbox);\n\t\tif (err) {\n\t\t\tmthca_err(dev, \"WRITE_MGM returned %d\\n\", err);\n\t\t\tgoto out;\n\t\t}\n\t\tBUG_ON(index < dev->limits.num_mgms);\n\t\tmthca_free(&dev->mcg_table.alloc, index);\n\t}\n\n out:\n\tmutex_unlock(&dev->mcg_table.mutex);\n\n\tmthca_free_mailbox(dev, mailbox);\n\treturn err;\n}\n\nint mthca_init_mcg_table(struct mthca_dev *dev)\n{\n\tint err;\n\tint table_size = dev->limits.num_mgms + dev->limits.num_amgms;\n\n\terr = mthca_alloc_init(&dev->mcg_table.alloc,\n\t\t\t       table_size,\n\t\t\t       table_size - 1,\n\t\t\t       dev->limits.num_mgms);\n\tif (err)\n\t\treturn err;\n\n\tmutex_init(&dev->mcg_table.mutex);\n\n\treturn 0;\n}\n\nvoid mthca_cleanup_mcg_table(struct mthca_dev *dev)\n{\n\tmthca_alloc_cleanup(&dev->mcg_table.alloc);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}