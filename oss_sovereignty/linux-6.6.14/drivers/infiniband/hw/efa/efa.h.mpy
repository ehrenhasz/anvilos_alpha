{
  "module_name": "efa.h",
  "hash_id": "9521b6d31c6792a570d5d180b540f165add9538864706e7d94d09a582c13b2c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/efa/efa.h",
  "human_readable_source": " \n \n\n#ifndef _EFA_H_\n#define _EFA_H_\n\n#include <linux/bitops.h>\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n\n#include <rdma/efa-abi.h>\n#include <rdma/ib_verbs.h>\n\n#include \"efa_com_cmd.h\"\n\n#define DRV_MODULE_NAME         \"efa\"\n#define DEVICE_NAME             \"Elastic Fabric Adapter (EFA)\"\n\n#define EFA_IRQNAME_SIZE        40\n\n#define EFA_MGMNT_MSIX_VEC_IDX            0\n#define EFA_COMP_EQS_VEC_BASE             1\n\nstruct efa_irq {\n\tirq_handler_t handler;\n\tvoid *data;\n\tu32 irqn;\n\tu32 vector;\n\tcpumask_t affinity_hint_mask;\n\tchar name[EFA_IRQNAME_SIZE];\n};\n\n \nstruct efa_stats {\n\tatomic64_t alloc_pd_err;\n\tatomic64_t create_qp_err;\n\tatomic64_t create_cq_err;\n\tatomic64_t reg_mr_err;\n\tatomic64_t alloc_ucontext_err;\n\tatomic64_t create_ah_err;\n\tatomic64_t mmap_err;\n\tatomic64_t keep_alive_rcvd;\n};\n\nstruct efa_dev {\n\tstruct ib_device ibdev;\n\tstruct efa_com_dev edev;\n\tstruct pci_dev *pdev;\n\tstruct efa_com_get_device_attr_result dev_attr;\n\n\tu64 reg_bar_addr;\n\tu64 reg_bar_len;\n\tu64 mem_bar_addr;\n\tu64 mem_bar_len;\n\tu64 db_bar_addr;\n\tu64 db_bar_len;\n\n\tint admin_msix_vector_idx;\n\tstruct efa_irq admin_irq;\n\n\tstruct efa_stats stats;\n\n\t \n\tstruct efa_eq *eqs;\n\tunsigned int neqs;\n\n\t \n\tstruct xarray cqs_xa;\n};\n\nstruct efa_ucontext {\n\tstruct ib_ucontext ibucontext;\n\tu16 uarn;\n};\n\nstruct efa_pd {\n\tstruct ib_pd ibpd;\n\tu16 pdn;\n};\n\nstruct efa_mr {\n\tstruct ib_mr ibmr;\n\tstruct ib_umem *umem;\n};\n\nstruct efa_cq {\n\tstruct ib_cq ibcq;\n\tstruct efa_ucontext *ucontext;\n\tdma_addr_t dma_addr;\n\tvoid *cpu_addr;\n\tstruct rdma_user_mmap_entry *mmap_entry;\n\tstruct rdma_user_mmap_entry *db_mmap_entry;\n\tsize_t size;\n\tu16 cq_idx;\n\t \n\tstruct efa_eq *eq;\n};\n\nstruct efa_qp {\n\tstruct ib_qp ibqp;\n\tdma_addr_t rq_dma_addr;\n\tvoid *rq_cpu_addr;\n\tsize_t rq_size;\n\tenum ib_qp_state state;\n\n\t \n\tstruct rdma_user_mmap_entry *sq_db_mmap_entry;\n\tstruct rdma_user_mmap_entry *llq_desc_mmap_entry;\n\tstruct rdma_user_mmap_entry *rq_db_mmap_entry;\n\tstruct rdma_user_mmap_entry *rq_mmap_entry;\n\n\tu32 qp_handle;\n\tu32 max_send_wr;\n\tu32 max_recv_wr;\n\tu32 max_send_sge;\n\tu32 max_recv_sge;\n\tu32 max_inline_data;\n};\n\nstruct efa_ah {\n\tstruct ib_ah ibah;\n\tu16 ah;\n\t \n\tu8 id[EFA_GID_SIZE];\n};\n\nstruct efa_eq {\n\tstruct efa_com_eq eeq;\n\tstruct efa_irq irq;\n};\n\nint efa_query_device(struct ib_device *ibdev,\n\t\t     struct ib_device_attr *props,\n\t\t     struct ib_udata *udata);\nint efa_query_port(struct ib_device *ibdev, u32 port,\n\t\t   struct ib_port_attr *props);\nint efa_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t int qp_attr_mask,\n\t\t struct ib_qp_init_attr *qp_init_attr);\nint efa_query_gid(struct ib_device *ibdev, u32 port, int index,\n\t\t  union ib_gid *gid);\nint efa_query_pkey(struct ib_device *ibdev, u32 port, u16 index,\n\t\t   u16 *pkey);\nint efa_alloc_pd(struct ib_pd *ibpd, struct ib_udata *udata);\nint efa_dealloc_pd(struct ib_pd *ibpd, struct ib_udata *udata);\nint efa_destroy_qp(struct ib_qp *ibqp, struct ib_udata *udata);\nint efa_create_qp(struct ib_qp *ibqp, struct ib_qp_init_attr *init_attr,\n\t\t  struct ib_udata *udata);\nint efa_destroy_cq(struct ib_cq *ibcq, struct ib_udata *udata);\nint efa_create_cq(struct ib_cq *ibcq, const struct ib_cq_init_attr *attr,\n\t\t  struct ib_udata *udata);\nstruct ib_mr *efa_reg_mr(struct ib_pd *ibpd, u64 start, u64 length,\n\t\t\t u64 virt_addr, int access_flags,\n\t\t\t struct ib_udata *udata);\nstruct ib_mr *efa_reg_user_mr_dmabuf(struct ib_pd *ibpd, u64 start,\n\t\t\t\t     u64 length, u64 virt_addr,\n\t\t\t\t     int fd, int access_flags,\n\t\t\t\t     struct ib_udata *udata);\nint efa_dereg_mr(struct ib_mr *ibmr, struct ib_udata *udata);\nint efa_get_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t   struct ib_port_immutable *immutable);\nint efa_alloc_ucontext(struct ib_ucontext *ibucontext, struct ib_udata *udata);\nvoid efa_dealloc_ucontext(struct ib_ucontext *ibucontext);\nint efa_mmap(struct ib_ucontext *ibucontext,\n\t     struct vm_area_struct *vma);\nvoid efa_mmap_free(struct rdma_user_mmap_entry *rdma_entry);\nint efa_create_ah(struct ib_ah *ibah,\n\t\t  struct rdma_ah_init_attr *init_attr,\n\t\t  struct ib_udata *udata);\nint efa_destroy_ah(struct ib_ah *ibah, u32 flags);\nint efa_modify_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr,\n\t\t  int qp_attr_mask, struct ib_udata *udata);\nenum rdma_link_layer efa_port_link_layer(struct ib_device *ibdev,\n\t\t\t\t\t u32 port_num);\nstruct rdma_hw_stats *efa_alloc_hw_port_stats(struct ib_device *ibdev, u32 port_num);\nstruct rdma_hw_stats *efa_alloc_hw_device_stats(struct ib_device *ibdev);\nint efa_get_hw_stats(struct ib_device *ibdev, struct rdma_hw_stats *stats,\n\t\t     u32 port_num, int index);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}