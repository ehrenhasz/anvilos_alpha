{
  "module_name": "ocrdma_hw.c",
  "hash_id": "ca2d5c8bf57e4a39803bd0e6a43d557510888e4dc9a338e45af3b6e1d181ef8e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/ocrdma/ocrdma_hw.c",
  "human_readable_source": " \n\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/log2.h>\n#include <linux/dma-mapping.h>\n#include <linux/if_ether.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_cache.h>\n\n#include \"ocrdma.h\"\n#include \"ocrdma_hw.h\"\n#include \"ocrdma_verbs.h\"\n#include \"ocrdma_ah.h\"\n\nenum mbx_status {\n\tOCRDMA_MBX_STATUS_FAILED\t\t= 1,\n\tOCRDMA_MBX_STATUS_ILLEGAL_FIELD\t\t= 3,\n\tOCRDMA_MBX_STATUS_OOR\t\t\t= 100,\n\tOCRDMA_MBX_STATUS_INVALID_PD\t\t= 101,\n\tOCRDMA_MBX_STATUS_PD_INUSE\t\t= 102,\n\tOCRDMA_MBX_STATUS_INVALID_CQ\t\t= 103,\n\tOCRDMA_MBX_STATUS_INVALID_QP\t\t= 104,\n\tOCRDMA_MBX_STATUS_INVALID_LKEY\t\t= 105,\n\tOCRDMA_MBX_STATUS_ORD_EXCEEDS\t\t= 106,\n\tOCRDMA_MBX_STATUS_IRD_EXCEEDS\t\t= 107,\n\tOCRDMA_MBX_STATUS_SENDQ_WQE_EXCEEDS\t= 108,\n\tOCRDMA_MBX_STATUS_RECVQ_RQE_EXCEEDS\t= 109,\n\tOCRDMA_MBX_STATUS_SGE_SEND_EXCEEDS\t= 110,\n\tOCRDMA_MBX_STATUS_SGE_WRITE_EXCEEDS\t= 111,\n\tOCRDMA_MBX_STATUS_SGE_RECV_EXCEEDS\t= 112,\n\tOCRDMA_MBX_STATUS_INVALID_STATE_CHANGE\t= 113,\n\tOCRDMA_MBX_STATUS_MW_BOUND\t\t= 114,\n\tOCRDMA_MBX_STATUS_INVALID_VA\t\t= 115,\n\tOCRDMA_MBX_STATUS_INVALID_LENGTH\t= 116,\n\tOCRDMA_MBX_STATUS_INVALID_FBO\t\t= 117,\n\tOCRDMA_MBX_STATUS_INVALID_ACC_RIGHTS\t= 118,\n\tOCRDMA_MBX_STATUS_INVALID_PBE_SIZE\t= 119,\n\tOCRDMA_MBX_STATUS_INVALID_PBL_ENTRY\t= 120,\n\tOCRDMA_MBX_STATUS_INVALID_PBL_SHIFT\t= 121,\n\tOCRDMA_MBX_STATUS_INVALID_SRQ_ID\t= 129,\n\tOCRDMA_MBX_STATUS_SRQ_ERROR\t\t= 133,\n\tOCRDMA_MBX_STATUS_RQE_EXCEEDS\t\t= 134,\n\tOCRDMA_MBX_STATUS_MTU_EXCEEDS\t\t= 135,\n\tOCRDMA_MBX_STATUS_MAX_QP_EXCEEDS\t= 136,\n\tOCRDMA_MBX_STATUS_SRQ_LIMIT_EXCEEDS\t= 137,\n\tOCRDMA_MBX_STATUS_SRQ_SIZE_UNDERUNS\t= 138,\n\tOCRDMA_MBX_STATUS_QP_BOUND\t\t= 130,\n\tOCRDMA_MBX_STATUS_INVALID_CHANGE\t= 139,\n\tOCRDMA_MBX_STATUS_ATOMIC_OPS_UNSUP\t= 140,\n\tOCRDMA_MBX_STATUS_INVALID_RNR_NAK_TIMER\t= 141,\n\tOCRDMA_MBX_STATUS_MW_STILL_BOUND\t= 142,\n\tOCRDMA_MBX_STATUS_PKEY_INDEX_INVALID\t= 143,\n\tOCRDMA_MBX_STATUS_PKEY_INDEX_EXCEEDS\t= 144\n};\n\nenum additional_status {\n\tOCRDMA_MBX_ADDI_STATUS_INSUFFICIENT_RESOURCES = 22\n};\n\nenum cqe_status {\n\tOCRDMA_MBX_CQE_STATUS_INSUFFICIENT_PRIVILEDGES\t= 1,\n\tOCRDMA_MBX_CQE_STATUS_INVALID_PARAMETER\t\t= 2,\n\tOCRDMA_MBX_CQE_STATUS_INSUFFICIENT_RESOURCES\t= 3,\n\tOCRDMA_MBX_CQE_STATUS_QUEUE_FLUSHING\t\t= 4,\n\tOCRDMA_MBX_CQE_STATUS_DMA_FAILED\t\t= 5\n};\n\nstatic inline void *ocrdma_get_eqe(struct ocrdma_eq *eq)\n{\n\treturn eq->q.va + (eq->q.tail * sizeof(struct ocrdma_eqe));\n}\n\nstatic inline void ocrdma_eq_inc_tail(struct ocrdma_eq *eq)\n{\n\teq->q.tail = (eq->q.tail + 1) & (OCRDMA_EQ_LEN - 1);\n}\n\nstatic inline void *ocrdma_get_mcqe(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_mcqe *cqe = (struct ocrdma_mcqe *)\n\t    (dev->mq.cq.va + (dev->mq.cq.tail * sizeof(struct ocrdma_mcqe)));\n\n\tif (!(le32_to_cpu(cqe->valid_ae_cmpl_cons) & OCRDMA_MCQE_VALID_MASK))\n\t\treturn NULL;\n\treturn cqe;\n}\n\nstatic inline void ocrdma_mcq_inc_tail(struct ocrdma_dev *dev)\n{\n\tdev->mq.cq.tail = (dev->mq.cq.tail + 1) & (OCRDMA_MQ_CQ_LEN - 1);\n}\n\nstatic inline struct ocrdma_mqe *ocrdma_get_mqe(struct ocrdma_dev *dev)\n{\n\treturn dev->mq.sq.va + (dev->mq.sq.head * sizeof(struct ocrdma_mqe));\n}\n\nstatic inline void ocrdma_mq_inc_head(struct ocrdma_dev *dev)\n{\n\tdev->mq.sq.head = (dev->mq.sq.head + 1) & (OCRDMA_MQ_LEN - 1);\n}\n\nstatic inline void *ocrdma_get_mqe_rsp(struct ocrdma_dev *dev)\n{\n\treturn dev->mq.sq.va + (dev->mqe_ctx.tag * sizeof(struct ocrdma_mqe));\n}\n\nenum ib_qp_state get_ibqp_state(enum ocrdma_qp_state qps)\n{\n\tswitch (qps) {\n\tcase OCRDMA_QPS_RST:\n\t\treturn IB_QPS_RESET;\n\tcase OCRDMA_QPS_INIT:\n\t\treturn IB_QPS_INIT;\n\tcase OCRDMA_QPS_RTR:\n\t\treturn IB_QPS_RTR;\n\tcase OCRDMA_QPS_RTS:\n\t\treturn IB_QPS_RTS;\n\tcase OCRDMA_QPS_SQD:\n\tcase OCRDMA_QPS_SQ_DRAINING:\n\t\treturn IB_QPS_SQD;\n\tcase OCRDMA_QPS_SQE:\n\t\treturn IB_QPS_SQE;\n\tcase OCRDMA_QPS_ERR:\n\t\treturn IB_QPS_ERR;\n\t}\n\treturn IB_QPS_ERR;\n}\n\nstatic enum ocrdma_qp_state get_ocrdma_qp_state(enum ib_qp_state qps)\n{\n\tswitch (qps) {\n\tcase IB_QPS_RESET:\n\t\treturn OCRDMA_QPS_RST;\n\tcase IB_QPS_INIT:\n\t\treturn OCRDMA_QPS_INIT;\n\tcase IB_QPS_RTR:\n\t\treturn OCRDMA_QPS_RTR;\n\tcase IB_QPS_RTS:\n\t\treturn OCRDMA_QPS_RTS;\n\tcase IB_QPS_SQD:\n\t\treturn OCRDMA_QPS_SQD;\n\tcase IB_QPS_SQE:\n\t\treturn OCRDMA_QPS_SQE;\n\tcase IB_QPS_ERR:\n\t\treturn OCRDMA_QPS_ERR;\n\t}\n\treturn OCRDMA_QPS_ERR;\n}\n\nstatic int ocrdma_get_mbx_errno(u32 status)\n{\n\tint err_num;\n\tu8 mbox_status = (status & OCRDMA_MBX_RSP_STATUS_MASK) >>\n\t\t\t\t\tOCRDMA_MBX_RSP_STATUS_SHIFT;\n\tu8 add_status = (status & OCRDMA_MBX_RSP_ASTATUS_MASK) >>\n\t\t\t\t\tOCRDMA_MBX_RSP_ASTATUS_SHIFT;\n\n\tswitch (mbox_status) {\n\tcase OCRDMA_MBX_STATUS_OOR:\n\tcase OCRDMA_MBX_STATUS_MAX_QP_EXCEEDS:\n\t\terr_num = -EAGAIN;\n\t\tbreak;\n\n\tcase OCRDMA_MBX_STATUS_INVALID_PD:\n\tcase OCRDMA_MBX_STATUS_INVALID_CQ:\n\tcase OCRDMA_MBX_STATUS_INVALID_SRQ_ID:\n\tcase OCRDMA_MBX_STATUS_INVALID_QP:\n\tcase OCRDMA_MBX_STATUS_INVALID_CHANGE:\n\tcase OCRDMA_MBX_STATUS_MTU_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_INVALID_RNR_NAK_TIMER:\n\tcase OCRDMA_MBX_STATUS_PKEY_INDEX_INVALID:\n\tcase OCRDMA_MBX_STATUS_PKEY_INDEX_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_ILLEGAL_FIELD:\n\tcase OCRDMA_MBX_STATUS_INVALID_PBL_ENTRY:\n\tcase OCRDMA_MBX_STATUS_INVALID_LKEY:\n\tcase OCRDMA_MBX_STATUS_INVALID_VA:\n\tcase OCRDMA_MBX_STATUS_INVALID_LENGTH:\n\tcase OCRDMA_MBX_STATUS_INVALID_FBO:\n\tcase OCRDMA_MBX_STATUS_INVALID_ACC_RIGHTS:\n\tcase OCRDMA_MBX_STATUS_INVALID_PBE_SIZE:\n\tcase OCRDMA_MBX_STATUS_ATOMIC_OPS_UNSUP:\n\tcase OCRDMA_MBX_STATUS_SRQ_ERROR:\n\tcase OCRDMA_MBX_STATUS_SRQ_SIZE_UNDERUNS:\n\t\terr_num = -EINVAL;\n\t\tbreak;\n\n\tcase OCRDMA_MBX_STATUS_PD_INUSE:\n\tcase OCRDMA_MBX_STATUS_QP_BOUND:\n\tcase OCRDMA_MBX_STATUS_MW_STILL_BOUND:\n\tcase OCRDMA_MBX_STATUS_MW_BOUND:\n\t\terr_num = -EBUSY;\n\t\tbreak;\n\n\tcase OCRDMA_MBX_STATUS_RECVQ_RQE_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_SGE_RECV_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_RQE_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_SRQ_LIMIT_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_ORD_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_IRD_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_SENDQ_WQE_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_SGE_SEND_EXCEEDS:\n\tcase OCRDMA_MBX_STATUS_SGE_WRITE_EXCEEDS:\n\t\terr_num = -ENOBUFS;\n\t\tbreak;\n\n\tcase OCRDMA_MBX_STATUS_FAILED:\n\t\tswitch (add_status) {\n\t\tcase OCRDMA_MBX_ADDI_STATUS_INSUFFICIENT_RESOURCES:\n\t\t\terr_num = -EAGAIN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr_num = -EFAULT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\terr_num = -EFAULT;\n\t}\n\treturn err_num;\n}\n\nchar *port_speed_string(struct ocrdma_dev *dev)\n{\n\tchar *str = \"\";\n\tu16 speeds_supported;\n\n\tspeeds_supported = dev->phy.fixed_speeds_supported |\n\t\t\t\tdev->phy.auto_speeds_supported;\n\tif (speeds_supported & OCRDMA_PHY_SPEED_40GBPS)\n\t\tstr = \"40Gbps \";\n\telse if (speeds_supported & OCRDMA_PHY_SPEED_10GBPS)\n\t\tstr = \"10Gbps \";\n\telse if (speeds_supported & OCRDMA_PHY_SPEED_1GBPS)\n\t\tstr = \"1Gbps \";\n\n\treturn str;\n}\n\nstatic int ocrdma_get_mbx_cqe_errno(u16 cqe_status)\n{\n\tint err_num = -EINVAL;\n\n\tswitch (cqe_status) {\n\tcase OCRDMA_MBX_CQE_STATUS_INSUFFICIENT_PRIVILEDGES:\n\t\terr_num = -EPERM;\n\t\tbreak;\n\tcase OCRDMA_MBX_CQE_STATUS_INVALID_PARAMETER:\n\t\terr_num = -EINVAL;\n\t\tbreak;\n\tcase OCRDMA_MBX_CQE_STATUS_INSUFFICIENT_RESOURCES:\n\tcase OCRDMA_MBX_CQE_STATUS_QUEUE_FLUSHING:\n\t\terr_num = -EINVAL;\n\t\tbreak;\n\tcase OCRDMA_MBX_CQE_STATUS_DMA_FAILED:\n\tdefault:\n\t\terr_num = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err_num;\n}\n\nvoid ocrdma_ring_cq_db(struct ocrdma_dev *dev, u16 cq_id, bool armed,\n\t\t       bool solicited, u16 cqe_popped)\n{\n\tu32 val = cq_id & OCRDMA_DB_CQ_RING_ID_MASK;\n\n\tval |= ((cq_id & OCRDMA_DB_CQ_RING_ID_EXT_MASK) <<\n\t     OCRDMA_DB_CQ_RING_ID_EXT_MASK_SHIFT);\n\n\tif (armed)\n\t\tval |= (1 << OCRDMA_DB_CQ_REARM_SHIFT);\n\tif (solicited)\n\t\tval |= (1 << OCRDMA_DB_CQ_SOLICIT_SHIFT);\n\tval |= (cqe_popped << OCRDMA_DB_CQ_NUM_POPPED_SHIFT);\n\tiowrite32(val, dev->nic_info.db + OCRDMA_DB_CQ_OFFSET);\n}\n\nstatic void ocrdma_ring_mq_db(struct ocrdma_dev *dev)\n{\n\tu32 val = 0;\n\n\tval |= dev->mq.sq.id & OCRDMA_MQ_ID_MASK;\n\tval |= 1 << OCRDMA_MQ_NUM_MQE_SHIFT;\n\tiowrite32(val, dev->nic_info.db + OCRDMA_DB_MQ_OFFSET);\n}\n\nstatic void ocrdma_ring_eq_db(struct ocrdma_dev *dev, u16 eq_id,\n\t\t\t      bool arm, bool clear_int, u16 num_eqe)\n{\n\tu32 val = 0;\n\n\tval |= eq_id & OCRDMA_EQ_ID_MASK;\n\tval |= ((eq_id & OCRDMA_EQ_ID_EXT_MASK) << OCRDMA_EQ_ID_EXT_MASK_SHIFT);\n\tif (arm)\n\t\tval |= (1 << OCRDMA_REARM_SHIFT);\n\tif (clear_int)\n\t\tval |= (1 << OCRDMA_EQ_CLR_SHIFT);\n\tval |= (1 << OCRDMA_EQ_TYPE_SHIFT);\n\tval |= (num_eqe << OCRDMA_NUM_EQE_SHIFT);\n\tiowrite32(val, dev->nic_info.db + OCRDMA_DB_EQ_OFFSET);\n}\n\nstatic void ocrdma_init_mch(struct ocrdma_mbx_hdr *cmd_hdr,\n\t\t\t    u8 opcode, u8 subsys, u32 cmd_len)\n{\n\tcmd_hdr->subsys_op = (opcode | (subsys << OCRDMA_MCH_SUBSYS_SHIFT));\n\tcmd_hdr->timeout = 20;  \n\tcmd_hdr->cmd_len = cmd_len - sizeof(struct ocrdma_mbx_hdr);\n}\n\nstatic void *ocrdma_init_emb_mqe(u8 opcode, u32 cmd_len)\n{\n\tstruct ocrdma_mqe *mqe;\n\n\tmqe = kzalloc(sizeof(struct ocrdma_mqe), GFP_KERNEL);\n\tif (!mqe)\n\t\treturn NULL;\n\tmqe->hdr.spcl_sge_cnt_emb |=\n\t\t(OCRDMA_MQE_EMBEDDED << OCRDMA_MQE_HDR_EMB_SHIFT) &\n\t\t\t\t\tOCRDMA_MQE_HDR_EMB_MASK;\n\tmqe->hdr.pyld_len = cmd_len - sizeof(struct ocrdma_mqe_hdr);\n\n\tocrdma_init_mch(&mqe->u.emb_req.mch, opcode, OCRDMA_SUBSYS_ROCE,\n\t\t\tmqe->hdr.pyld_len);\n\treturn mqe;\n}\n\nstatic void ocrdma_free_q(struct ocrdma_dev *dev, struct ocrdma_queue_info *q)\n{\n\tdma_free_coherent(&dev->nic_info.pdev->dev, q->size, q->va, q->dma);\n}\n\nstatic int ocrdma_alloc_q(struct ocrdma_dev *dev,\n\t\t\t  struct ocrdma_queue_info *q, u16 len, u16 entry_size)\n{\n\tmemset(q, 0, sizeof(*q));\n\tq->len = len;\n\tq->entry_size = entry_size;\n\tq->size = len * entry_size;\n\tq->va = dma_alloc_coherent(&dev->nic_info.pdev->dev, q->size, &q->dma,\n\t\t\t\t   GFP_KERNEL);\n\tif (!q->va)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic void ocrdma_build_q_pages(struct ocrdma_pa *q_pa, int cnt,\n\t\t\t\t\tdma_addr_t host_pa, int hw_page_size)\n{\n\tint i;\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tq_pa[i].lo = (u32) (host_pa & 0xffffffff);\n\t\tq_pa[i].hi = (u32) upper_32_bits(host_pa);\n\t\thost_pa += hw_page_size;\n\t}\n}\n\nstatic int ocrdma_mbx_delete_q(struct ocrdma_dev *dev,\n\t\t\t       struct ocrdma_queue_info *q, int queue_type)\n{\n\tu8 opcode = 0;\n\tint status;\n\tstruct ocrdma_delete_q_req *cmd = dev->mbx_cmd;\n\n\tswitch (queue_type) {\n\tcase QTYPE_MCCQ:\n\t\topcode = OCRDMA_CMD_DELETE_MQ;\n\t\tbreak;\n\tcase QTYPE_CQ:\n\t\topcode = OCRDMA_CMD_DELETE_CQ;\n\t\tbreak;\n\tcase QTYPE_EQ:\n\t\topcode = OCRDMA_CMD_DELETE_EQ;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\tmemset(cmd, 0, sizeof(*cmd));\n\tocrdma_init_mch(&cmd->req, opcode, OCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\tcmd->id = q->id;\n\n\tstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\n\t\t\t\t cmd, sizeof(*cmd), NULL, NULL);\n\tif (!status)\n\t\tq->created = false;\n\treturn status;\n}\n\nstatic int ocrdma_mbx_create_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\n{\n\tint status;\n\tstruct ocrdma_create_eq_req *cmd = dev->mbx_cmd;\n\tstruct ocrdma_create_eq_rsp *rsp = dev->mbx_cmd;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_EQ, OCRDMA_SUBSYS_COMMON,\n\t\t\tsizeof(*cmd));\n\n\tcmd->req.rsvd_version = 2;\n\tcmd->num_pages = 4;\n\tcmd->valid = OCRDMA_CREATE_EQ_VALID;\n\tcmd->cnt = 4 << OCRDMA_CREATE_EQ_CNT_SHIFT;\n\n\tocrdma_build_q_pages(&cmd->pa[0], cmd->num_pages, eq->q.dma,\n\t\t\t     PAGE_SIZE_4K);\n\tstatus = be_roce_mcc_cmd(dev->nic_info.netdev, cmd, sizeof(*cmd), NULL,\n\t\t\t\t NULL);\n\tif (!status) {\n\t\teq->q.id = rsp->vector_eqid & 0xffff;\n\t\teq->vector = (rsp->vector_eqid >> 16) & 0xffff;\n\t\teq->q.created = true;\n\t}\n\treturn status;\n}\n\nstatic int ocrdma_create_eq(struct ocrdma_dev *dev,\n\t\t\t    struct ocrdma_eq *eq, u16 q_len)\n{\n\tint status;\n\n\tstatus = ocrdma_alloc_q(dev, &eq->q, OCRDMA_EQ_LEN,\n\t\t\t\tsizeof(struct ocrdma_eqe));\n\tif (status)\n\t\treturn status;\n\n\tstatus = ocrdma_mbx_create_eq(dev, eq);\n\tif (status)\n\t\tgoto mbx_err;\n\teq->dev = dev;\n\tocrdma_ring_eq_db(dev, eq->q.id, true, true, 0);\n\n\treturn 0;\nmbx_err:\n\tocrdma_free_q(dev, &eq->q);\n\treturn status;\n}\n\nint ocrdma_get_irq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\n{\n\tint irq;\n\n\tif (dev->nic_info.intr_mode == BE_INTERRUPT_MODE_INTX)\n\t\tirq = dev->nic_info.pdev->irq;\n\telse\n\t\tirq = dev->nic_info.msix.vector_list[eq->vector];\n\treturn irq;\n}\n\nstatic void _ocrdma_destroy_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\n{\n\tif (eq->q.created) {\n\t\tocrdma_mbx_delete_q(dev, &eq->q, QTYPE_EQ);\n\t\tocrdma_free_q(dev, &eq->q);\n\t}\n}\n\nstatic void ocrdma_destroy_eq(struct ocrdma_dev *dev, struct ocrdma_eq *eq)\n{\n\tint irq;\n\n\t \n\tocrdma_ring_eq_db(dev, eq->q.id, false, false, 0);\n\n\tirq = ocrdma_get_irq(dev, eq);\n\tfree_irq(irq, eq);\n\t_ocrdma_destroy_eq(dev, eq);\n}\n\nstatic void ocrdma_destroy_eqs(struct ocrdma_dev *dev)\n{\n\tint i;\n\n\tfor (i = 0; i < dev->eq_cnt; i++)\n\t\tocrdma_destroy_eq(dev, &dev->eq_tbl[i]);\n}\n\nstatic int ocrdma_mbx_mq_cq_create(struct ocrdma_dev *dev,\n\t\t\t\t   struct ocrdma_queue_info *cq,\n\t\t\t\t   struct ocrdma_queue_info *eq)\n{\n\tstruct ocrdma_create_cq_cmd *cmd = dev->mbx_cmd;\n\tstruct ocrdma_create_cq_cmd_rsp *rsp = dev->mbx_cmd;\n\tint status;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_CQ,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\n\tcmd->req.rsvd_version = OCRDMA_CREATE_CQ_VER2;\n\tcmd->pgsz_pgcnt = (cq->size / OCRDMA_MIN_Q_PAGE_SIZE) <<\n\t\tOCRDMA_CREATE_CQ_PAGE_SIZE_SHIFT;\n\tcmd->pgsz_pgcnt |= PAGES_4K_SPANNED(cq->va, cq->size);\n\n\tcmd->ev_cnt_flags = OCRDMA_CREATE_CQ_DEF_FLAGS;\n\tcmd->eqn = eq->id;\n\tcmd->pdid_cqecnt = cq->size / sizeof(struct ocrdma_mcqe);\n\n\tocrdma_build_q_pages(&cmd->pa[0], cq->size / OCRDMA_MIN_Q_PAGE_SIZE,\n\t\t\t     cq->dma, PAGE_SIZE_4K);\n\tstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\n\t\t\t\t cmd, sizeof(*cmd), NULL, NULL);\n\tif (!status) {\n\t\tcq->id = (u16) (rsp->cq_id & OCRDMA_CREATE_CQ_RSP_CQ_ID_MASK);\n\t\tcq->created = true;\n\t}\n\treturn status;\n}\n\nstatic u32 ocrdma_encoded_q_len(int q_len)\n{\n\tu32 len_encoded = fls(q_len);\t \n\n\tif (len_encoded == 16)\n\t\tlen_encoded = 0;\n\treturn len_encoded;\n}\n\nstatic int ocrdma_mbx_create_mq(struct ocrdma_dev *dev,\n\t\t\t\tstruct ocrdma_queue_info *mq,\n\t\t\t\tstruct ocrdma_queue_info *cq)\n{\n\tint num_pages, status;\n\tstruct ocrdma_create_mq_req *cmd = dev->mbx_cmd;\n\tstruct ocrdma_create_mq_rsp *rsp = dev->mbx_cmd;\n\tstruct ocrdma_pa *pa;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tnum_pages = PAGES_4K_SPANNED(mq->va, mq->size);\n\n\tocrdma_init_mch(&cmd->req, OCRDMA_CMD_CREATE_MQ_EXT,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\tcmd->req.rsvd_version = 1;\n\tcmd->cqid_pages = num_pages;\n\tcmd->cqid_pages |= (cq->id << OCRDMA_CREATE_MQ_CQ_ID_SHIFT);\n\tcmd->async_cqid_valid = OCRDMA_CREATE_MQ_ASYNC_CQ_VALID;\n\n\tcmd->async_event_bitmap = BIT(OCRDMA_ASYNC_GRP5_EVE_CODE);\n\tcmd->async_event_bitmap |= BIT(OCRDMA_ASYNC_RDMA_EVE_CODE);\n\t \n\tcmd->async_event_bitmap |= BIT(OCRDMA_ASYNC_LINK_EVE_CODE);\n\n\tcmd->async_cqid_ringsize = cq->id;\n\tcmd->async_cqid_ringsize |= (ocrdma_encoded_q_len(mq->len) <<\n\t\t\t\tOCRDMA_CREATE_MQ_RING_SIZE_SHIFT);\n\tcmd->valid = OCRDMA_CREATE_MQ_VALID;\n\tpa = &cmd->pa[0];\n\n\tocrdma_build_q_pages(pa, num_pages, mq->dma, PAGE_SIZE_4K);\n\tstatus = be_roce_mcc_cmd(dev->nic_info.netdev,\n\t\t\t\t cmd, sizeof(*cmd), NULL, NULL);\n\tif (!status) {\n\t\tmq->id = rsp->id;\n\t\tmq->created = true;\n\t}\n\treturn status;\n}\n\nstatic int ocrdma_create_mq(struct ocrdma_dev *dev)\n{\n\tint status;\n\n\t \n\tstatus = ocrdma_alloc_q(dev, &dev->mq.cq, OCRDMA_MQ_CQ_LEN,\n\t\t\t\tsizeof(struct ocrdma_mcqe));\n\tif (status)\n\t\tgoto alloc_err;\n\n\tdev->eq_tbl[0].cq_cnt++;\n\tstatus = ocrdma_mbx_mq_cq_create(dev, &dev->mq.cq, &dev->eq_tbl[0].q);\n\tif (status)\n\t\tgoto mbx_cq_free;\n\n\tmemset(&dev->mqe_ctx, 0, sizeof(dev->mqe_ctx));\n\tinit_waitqueue_head(&dev->mqe_ctx.cmd_wait);\n\tmutex_init(&dev->mqe_ctx.lock);\n\n\t \n\tstatus = ocrdma_alloc_q(dev, &dev->mq.sq, OCRDMA_MQ_LEN,\n\t\t\t\tsizeof(struct ocrdma_mqe));\n\tif (status)\n\t\tgoto mbx_cq_destroy;\n\tstatus = ocrdma_mbx_create_mq(dev, &dev->mq.sq, &dev->mq.cq);\n\tif (status)\n\t\tgoto mbx_q_free;\n\tocrdma_ring_cq_db(dev, dev->mq.cq.id, true, false, 0);\n\treturn 0;\n\nmbx_q_free:\n\tocrdma_free_q(dev, &dev->mq.sq);\nmbx_cq_destroy:\n\tocrdma_mbx_delete_q(dev, &dev->mq.cq, QTYPE_CQ);\nmbx_cq_free:\n\tocrdma_free_q(dev, &dev->mq.cq);\nalloc_err:\n\treturn status;\n}\n\nstatic void ocrdma_destroy_mq(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_queue_info *mbxq, *cq;\n\n\t \n\tmutex_lock(&dev->mqe_ctx.lock);\n\tmbxq = &dev->mq.sq;\n\tif (mbxq->created) {\n\t\tocrdma_mbx_delete_q(dev, mbxq, QTYPE_MCCQ);\n\t\tocrdma_free_q(dev, mbxq);\n\t}\n\tmutex_unlock(&dev->mqe_ctx.lock);\n\n\tcq = &dev->mq.cq;\n\tif (cq->created) {\n\t\tocrdma_mbx_delete_q(dev, cq, QTYPE_CQ);\n\t\tocrdma_free_q(dev, cq);\n\t}\n}\n\nstatic void ocrdma_process_qpcat_error(struct ocrdma_dev *dev,\n\t\t\t\t       struct ocrdma_qp *qp)\n{\n\tenum ib_qp_state new_ib_qps = IB_QPS_ERR;\n\tenum ib_qp_state old_ib_qps;\n\n\tif (qp == NULL)\n\t\tBUG();\n\tocrdma_qp_state_change(qp, new_ib_qps, &old_ib_qps);\n}\n\nstatic void ocrdma_dispatch_ibevent(struct ocrdma_dev *dev,\n\t\t\t\t    struct ocrdma_ae_mcqe *cqe)\n{\n\tstruct ocrdma_qp *qp = NULL;\n\tstruct ocrdma_cq *cq = NULL;\n\tstruct ib_event ib_evt;\n\tint cq_event = 0;\n\tint qp_event = 1;\n\tint srq_event = 0;\n\tint dev_event = 0;\n\tint type = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_TYPE_MASK) >>\n\t    OCRDMA_AE_MCQE_EVENT_TYPE_SHIFT;\n\tu16 qpid = cqe->qpvalid_qpid & OCRDMA_AE_MCQE_QPID_MASK;\n\tu16 cqid = cqe->cqvalid_cqid & OCRDMA_AE_MCQE_CQID_MASK;\n\n\t \n\n\tif (cqe->qpvalid_qpid & OCRDMA_AE_MCQE_QPVALID) {\n\t\tif (qpid < dev->attr.max_qp)\n\t\t\tqp = dev->qp_tbl[qpid];\n\t\tif (qp == NULL) {\n\t\t\tpr_err(\"ocrdma%d:Async event - qpid %u is not valid\\n\",\n\t\t\t       dev->id, qpid);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cqe->cqvalid_cqid & OCRDMA_AE_MCQE_CQVALID) {\n\t\tif (cqid < dev->attr.max_cq)\n\t\t\tcq = dev->cq_tbl[cqid];\n\t\tif (cq == NULL) {\n\t\t\tpr_err(\"ocrdma%d:Async event - cqid %u is not valid\\n\",\n\t\t\t       dev->id, cqid);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmemset(&ib_evt, 0, sizeof(ib_evt));\n\n\tib_evt.device = &dev->ibdev;\n\n\tswitch (type) {\n\tcase OCRDMA_CQ_ERROR:\n\t\tib_evt.element.cq = &cq->ibcq;\n\t\tib_evt.event = IB_EVENT_CQ_ERR;\n\t\tcq_event = 1;\n\t\tqp_event = 0;\n\t\tbreak;\n\tcase OCRDMA_CQ_OVERRUN_ERROR:\n\t\tib_evt.element.cq = &cq->ibcq;\n\t\tib_evt.event = IB_EVENT_CQ_ERR;\n\t\tcq_event = 1;\n\t\tqp_event = 0;\n\t\tbreak;\n\tcase OCRDMA_CQ_QPCAT_ERROR:\n\t\tib_evt.element.qp = &qp->ibqp;\n\t\tib_evt.event = IB_EVENT_QP_FATAL;\n\t\tocrdma_process_qpcat_error(dev, qp);\n\t\tbreak;\n\tcase OCRDMA_QP_ACCESS_ERROR:\n\t\tib_evt.element.qp = &qp->ibqp;\n\t\tib_evt.event = IB_EVENT_QP_ACCESS_ERR;\n\t\tbreak;\n\tcase OCRDMA_QP_COMM_EST_EVENT:\n\t\tib_evt.element.qp = &qp->ibqp;\n\t\tib_evt.event = IB_EVENT_COMM_EST;\n\t\tbreak;\n\tcase OCRDMA_SQ_DRAINED_EVENT:\n\t\tib_evt.element.qp = &qp->ibqp;\n\t\tib_evt.event = IB_EVENT_SQ_DRAINED;\n\t\tbreak;\n\tcase OCRDMA_DEVICE_FATAL_EVENT:\n\t\tib_evt.element.port_num = 1;\n\t\tib_evt.event = IB_EVENT_DEVICE_FATAL;\n\t\tqp_event = 0;\n\t\tdev_event = 1;\n\t\tbreak;\n\tcase OCRDMA_SRQCAT_ERROR:\n\t\tib_evt.element.srq = &qp->srq->ibsrq;\n\t\tib_evt.event = IB_EVENT_SRQ_ERR;\n\t\tsrq_event = 1;\n\t\tqp_event = 0;\n\t\tbreak;\n\tcase OCRDMA_SRQ_LIMIT_EVENT:\n\t\tib_evt.element.srq = &qp->srq->ibsrq;\n\t\tib_evt.event = IB_EVENT_SRQ_LIMIT_REACHED;\n\t\tsrq_event = 1;\n\t\tqp_event = 0;\n\t\tbreak;\n\tcase OCRDMA_QP_LAST_WQE_EVENT:\n\t\tib_evt.element.qp = &qp->ibqp;\n\t\tib_evt.event = IB_EVENT_QP_LAST_WQE_REACHED;\n\t\tbreak;\n\tdefault:\n\t\tcq_event = 0;\n\t\tqp_event = 0;\n\t\tsrq_event = 0;\n\t\tdev_event = 0;\n\t\tpr_err(\"%s() unknown type=0x%x\\n\", __func__, type);\n\t\tbreak;\n\t}\n\n\tif (type < OCRDMA_MAX_ASYNC_ERRORS)\n\t\tatomic_inc(&dev->async_err_stats[type]);\n\n\tif (qp_event) {\n\t\tif (qp->ibqp.event_handler)\n\t\t\tqp->ibqp.event_handler(&ib_evt, qp->ibqp.qp_context);\n\t} else if (cq_event) {\n\t\tif (cq->ibcq.event_handler)\n\t\t\tcq->ibcq.event_handler(&ib_evt, cq->ibcq.cq_context);\n\t} else if (srq_event) {\n\t\tif (qp->srq->ibsrq.event_handler)\n\t\t\tqp->srq->ibsrq.event_handler(&ib_evt,\n\t\t\t\t\t\t     qp->srq->ibsrq.\n\t\t\t\t\t\t     srq_context);\n\t} else if (dev_event) {\n\t\tdev_err(&dev->ibdev.dev, \"Fatal event received\\n\");\n\t\tib_dispatch_event(&ib_evt);\n\t}\n\n}\n\nstatic void ocrdma_process_grp5_aync(struct ocrdma_dev *dev,\n\t\t\t\t\tstruct ocrdma_ae_mcqe *cqe)\n{\n\tstruct ocrdma_ae_pvid_mcqe *evt;\n\tint type = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_TYPE_MASK) >>\n\t\t\tOCRDMA_AE_MCQE_EVENT_TYPE_SHIFT;\n\n\tswitch (type) {\n\tcase OCRDMA_ASYNC_EVENT_PVID_STATE:\n\t\tevt = (struct ocrdma_ae_pvid_mcqe *)cqe;\n\t\tif ((evt->tag_enabled & OCRDMA_AE_PVID_MCQE_ENABLED_MASK) >>\n\t\t\tOCRDMA_AE_PVID_MCQE_ENABLED_SHIFT)\n\t\t\tdev->pvid = ((evt->tag_enabled &\n\t\t\t\t\tOCRDMA_AE_PVID_MCQE_TAG_MASK) >>\n\t\t\t\t\tOCRDMA_AE_PVID_MCQE_TAG_SHIFT);\n\t\tbreak;\n\n\tcase OCRDMA_ASYNC_EVENT_COS_VALUE:\n\t\tatomic_set(&dev->update_sl, 1);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic void ocrdma_process_link_state(struct ocrdma_dev *dev,\n\t\t\t\t      struct ocrdma_ae_mcqe *cqe)\n{\n\tstruct ocrdma_ae_lnkst_mcqe *evt;\n\tu8 lstate;\n\n\tevt = (struct ocrdma_ae_lnkst_mcqe *)cqe;\n\tlstate = ocrdma_get_ae_link_state(evt->speed_state_ptn);\n\n\tif (!(lstate & OCRDMA_AE_LSC_LLINK_MASK))\n\t\treturn;\n\n\tif (dev->flags & OCRDMA_FLAGS_LINK_STATUS_INIT)\n\t\tocrdma_update_link_state(dev, (lstate & OCRDMA_LINK_ST_MASK));\n}\n\nstatic void ocrdma_process_acqe(struct ocrdma_dev *dev, void *ae_cqe)\n{\n\t \n\tstruct ocrdma_ae_mcqe *cqe = ae_cqe;\n\tu32 evt_code = (cqe->valid_ae_event & OCRDMA_AE_MCQE_EVENT_CODE_MASK) >>\n\t\t\tOCRDMA_AE_MCQE_EVENT_CODE_SHIFT;\n\tswitch (evt_code) {\n\tcase OCRDMA_ASYNC_LINK_EVE_CODE:\n\t\tocrdma_process_link_state(dev, cqe);\n\t\tbreak;\n\tcase OCRDMA_ASYNC_RDMA_EVE_CODE:\n\t\tocrdma_dispatch_ibevent(dev, cqe);\n\t\tbreak;\n\tcase OCRDMA_ASYNC_GRP5_EVE_CODE:\n\t\tocrdma_process_grp5_aync(dev, cqe);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s(%d) invalid evt code=0x%x\\n\", __func__,\n\t\t       dev->id, evt_code);\n\t}\n}\n\nstatic void ocrdma_process_mcqe(struct ocrdma_dev *dev, struct ocrdma_mcqe *cqe)\n{\n\tif (dev->mqe_ctx.tag == cqe->tag_lo && dev->mqe_ctx.cmd_done == false) {\n\t\tdev->mqe_ctx.cqe_status = (cqe->status &\n\t\t     OCRDMA_MCQE_STATUS_MASK) >> OCRDMA_MCQE_STATUS_SHIFT;\n\t\tdev->mqe_ctx.ext_status =\n\t\t    (cqe->status & OCRDMA_MCQE_ESTATUS_MASK)\n\t\t    >> OCRDMA_MCQE_ESTATUS_SHIFT;\n\t\tdev->mqe_ctx.cmd_done = true;\n\t\twake_up(&dev->mqe_ctx.cmd_wait);\n\t} else\n\t\tpr_err(\"%s() cqe for invalid tag0x%x.expected=0x%x\\n\",\n\t\t       __func__, cqe->tag_lo, dev->mqe_ctx.tag);\n}\n\nstatic int ocrdma_mq_cq_handler(struct ocrdma_dev *dev, u16 cq_id)\n{\n\tu16 cqe_popped = 0;\n\tstruct ocrdma_mcqe *cqe;\n\n\twhile (1) {\n\t\tcqe = ocrdma_get_mcqe(dev);\n\t\tif (cqe == NULL)\n\t\t\tbreak;\n\t\tocrdma_le32_to_cpu(cqe, sizeof(*cqe));\n\t\tcqe_popped += 1;\n\t\tif (cqe->valid_ae_cmpl_cons & OCRDMA_MCQE_AE_MASK)\n\t\t\tocrdma_process_acqe(dev, cqe);\n\t\telse if (cqe->valid_ae_cmpl_cons & OCRDMA_MCQE_CMPL_MASK)\n\t\t\tocrdma_process_mcqe(dev, cqe);\n\t\tmemset(cqe, 0, sizeof(struct ocrdma_mcqe));\n\t\tocrdma_mcq_inc_tail(dev);\n\t}\n\tocrdma_ring_cq_db(dev, dev->mq.cq.id, true, false, cqe_popped);\n\treturn 0;\n}\n\nstatic struct ocrdma_cq *_ocrdma_qp_buddy_cq_handler(struct ocrdma_dev *dev,\n\t\t\t\tstruct ocrdma_cq *cq, bool sq)\n{\n\tstruct ocrdma_qp *qp;\n\tstruct list_head *cur;\n\tstruct ocrdma_cq *bcq = NULL;\n\tstruct list_head *head = sq?(&cq->sq_head):(&cq->rq_head);\n\n\tlist_for_each(cur, head) {\n\t\tif (sq)\n\t\t\tqp = list_entry(cur, struct ocrdma_qp, sq_entry);\n\t\telse\n\t\t\tqp = list_entry(cur, struct ocrdma_qp, rq_entry);\n\n\t\tif (qp->srq)\n\t\t\tcontinue;\n\t\t \n\t\tif (qp->sq_cq == qp->rq_cq)\n\t\t\tcontinue;\n\t\t \n\t\tif (qp->sq_cq == cq)\n\t\t\tbcq = qp->rq_cq;\n\t\telse\n\t\t\tbcq = qp->sq_cq;\n\t\treturn bcq;\n\t}\n\treturn NULL;\n}\n\nstatic void ocrdma_qp_buddy_cq_handler(struct ocrdma_dev *dev,\n\t\t\t\t       struct ocrdma_cq *cq)\n{\n\tunsigned long flags;\n\tstruct ocrdma_cq *bcq = NULL;\n\n\t \n\tspin_lock_irqsave(&dev->flush_q_lock, flags);\n\t \n\tbcq = _ocrdma_qp_buddy_cq_handler(dev, cq, true);\n\tif (bcq == NULL)\n\t\tbcq = _ocrdma_qp_buddy_cq_handler(dev, cq, false);\n\tspin_unlock_irqrestore(&dev->flush_q_lock, flags);\n\n\t \n\tif (bcq && bcq->ibcq.comp_handler) {\n\t\tspin_lock_irqsave(&bcq->comp_handler_lock, flags);\n\t\t(*bcq->ibcq.comp_handler) (&bcq->ibcq, bcq->ibcq.cq_context);\n\t\tspin_unlock_irqrestore(&bcq->comp_handler_lock, flags);\n\t}\n}\n\nstatic void ocrdma_qp_cq_handler(struct ocrdma_dev *dev, u16 cq_idx)\n{\n\tunsigned long flags;\n\tstruct ocrdma_cq *cq;\n\n\tif (cq_idx >= OCRDMA_MAX_CQ)\n\t\tBUG();\n\n\tcq = dev->cq_tbl[cq_idx];\n\tif (cq == NULL)\n\t\treturn;\n\n\tif (cq->ibcq.comp_handler) {\n\t\tspin_lock_irqsave(&cq->comp_handler_lock, flags);\n\t\t(*cq->ibcq.comp_handler) (&cq->ibcq, cq->ibcq.cq_context);\n\t\tspin_unlock_irqrestore(&cq->comp_handler_lock, flags);\n\t}\n\tocrdma_qp_buddy_cq_handler(dev, cq);\n}\n\nstatic void ocrdma_cq_handler(struct ocrdma_dev *dev, u16 cq_id)\n{\n\t \n\tif (cq_id == dev->mq.cq.id)\n\t\tocrdma_mq_cq_handler(dev, cq_id);\n\telse\n\t\tocrdma_qp_cq_handler(dev, cq_id);\n}\n\nstatic irqreturn_t ocrdma_irq_handler(int irq, void *handle)\n{\n\tstruct ocrdma_eq *eq = handle;\n\tstruct ocrdma_dev *dev = eq->dev;\n\tstruct ocrdma_eqe eqe;\n\tstruct ocrdma_eqe *ptr;\n\tu16 cq_id;\n\tu8 mcode;\n\tint budget = eq->cq_cnt;\n\n\tdo {\n\t\tptr = ocrdma_get_eqe(eq);\n\t\teqe = *ptr;\n\t\tocrdma_le32_to_cpu(&eqe, sizeof(eqe));\n\t\tmcode = (eqe.id_valid & OCRDMA_EQE_MAJOR_CODE_MASK)\n\t\t\t\t>> OCRDMA_EQE_MAJOR_CODE_SHIFT;\n\t\tif (mcode == OCRDMA_MAJOR_CODE_SENTINAL)\n\t\t\tpr_err(\"EQ full on eqid = 0x%x, eqe = 0x%x\\n\",\n\t\t\t       eq->q.id, eqe.id_valid);\n\t\tif ((eqe.id_valid & OCRDMA_EQE_VALID_MASK) == 0)\n\t\t\tbreak;\n\n\t\tptr->id_valid = 0;\n\t\t \n\t\tocrdma_ring_eq_db(dev, eq->q.id, false, true, 1);\n\t\t \n\t\tif ((eqe.id_valid & OCRDMA_EQE_FOR_CQE_MASK) == 0) {\n\t\t\tcq_id = eqe.id_valid >> OCRDMA_EQE_RESOURCE_ID_SHIFT;\n\t\t\tocrdma_cq_handler(dev, cq_id);\n\t\t}\n\t\tocrdma_eq_inc_tail(eq);\n\n\t\t \n\t\tif (budget)\n\t\t\tbudget--;\n\n\t} while (budget);\n\n\teq->aic_obj.eq_intr_cnt++;\n\tocrdma_ring_eq_db(dev, eq->q.id, true, true, 0);\n\treturn IRQ_HANDLED;\n}\n\nstatic void ocrdma_post_mqe(struct ocrdma_dev *dev, struct ocrdma_mqe *cmd)\n{\n\tstruct ocrdma_mqe *mqe;\n\n\tdev->mqe_ctx.tag = dev->mq.sq.head;\n\tdev->mqe_ctx.cmd_done = false;\n\tmqe = ocrdma_get_mqe(dev);\n\tcmd->hdr.tag_lo = dev->mq.sq.head;\n\tocrdma_copy_cpu_to_le32(mqe, cmd, sizeof(*mqe));\n\t \n\twmb();\n\tocrdma_mq_inc_head(dev);\n\tocrdma_ring_mq_db(dev);\n}\n\nstatic int ocrdma_wait_mqe_cmpl(struct ocrdma_dev *dev)\n{\n\tlong status;\n\t \n\tstatus = wait_event_timeout(dev->mqe_ctx.cmd_wait,\n\t\t\t\t    (dev->mqe_ctx.cmd_done != false),\n\t\t\t\t    msecs_to_jiffies(30000));\n\tif (status)\n\t\treturn 0;\n\telse {\n\t\tdev->mqe_ctx.fw_error_state = true;\n\t\tpr_err(\"%s(%d) mailbox timeout: fw not responding\\n\",\n\t\t       __func__, dev->id);\n\t\treturn -1;\n\t}\n}\n\n \nstatic int ocrdma_mbx_cmd(struct ocrdma_dev *dev, struct ocrdma_mqe *mqe)\n{\n\tint status = 0;\n\tu16 cqe_status, ext_status;\n\tstruct ocrdma_mqe *rsp_mqe;\n\tstruct ocrdma_mbx_rsp *rsp = NULL;\n\n\tmutex_lock(&dev->mqe_ctx.lock);\n\tif (dev->mqe_ctx.fw_error_state)\n\t\tgoto mbx_err;\n\tocrdma_post_mqe(dev, mqe);\n\tstatus = ocrdma_wait_mqe_cmpl(dev);\n\tif (status)\n\t\tgoto mbx_err;\n\tcqe_status = dev->mqe_ctx.cqe_status;\n\text_status = dev->mqe_ctx.ext_status;\n\trsp_mqe = ocrdma_get_mqe_rsp(dev);\n\tocrdma_copy_le32_to_cpu(mqe, rsp_mqe, (sizeof(*mqe)));\n\tif ((mqe->hdr.spcl_sge_cnt_emb & OCRDMA_MQE_HDR_EMB_MASK) >>\n\t\t\t\tOCRDMA_MQE_HDR_EMB_SHIFT)\n\t\trsp = &mqe->u.rsp;\n\n\tif (cqe_status || ext_status) {\n\t\tpr_err(\"%s() cqe_status=0x%x, ext_status=0x%x,\\n\",\n\t\t       __func__, cqe_status, ext_status);\n\t\tif (rsp) {\n\t\t\t \n\t\t\tpr_err(\"opcode=0x%x, subsystem=0x%x\\n\",\n\t\t\t       (rsp->subsys_op & OCRDMA_MBX_RSP_OPCODE_MASK) >>\n\t\t\t\tOCRDMA_MBX_RSP_OPCODE_SHIFT,\n\t\t\t\t(rsp->subsys_op & OCRDMA_MBX_RSP_SUBSYS_MASK) >>\n\t\t\t\tOCRDMA_MBX_RSP_SUBSYS_SHIFT);\n\t\t}\n\t\tstatus = ocrdma_get_mbx_cqe_errno(cqe_status);\n\t\tgoto mbx_err;\n\t}\n\t \n\tif (rsp && (mqe->u.rsp.status & OCRDMA_MBX_RSP_STATUS_MASK))\n\t\tstatus = ocrdma_get_mbx_errno(mqe->u.rsp.status);\nmbx_err:\n\tmutex_unlock(&dev->mqe_ctx.lock);\n\treturn status;\n}\n\nstatic int ocrdma_nonemb_mbx_cmd(struct ocrdma_dev *dev, struct ocrdma_mqe *mqe,\n\t\t\t\t void *payload_va)\n{\n\tint status;\n\tstruct ocrdma_mbx_rsp *rsp = payload_va;\n\n\tif ((mqe->hdr.spcl_sge_cnt_emb & OCRDMA_MQE_HDR_EMB_MASK) >>\n\t\t\t\tOCRDMA_MQE_HDR_EMB_SHIFT)\n\t\tBUG();\n\n\tstatus = ocrdma_mbx_cmd(dev, mqe);\n\tif (!status)\n\t\t \n\t\tif (rsp->status & OCRDMA_MBX_RSP_STATUS_MASK)\n\t\t\tstatus = ocrdma_get_mbx_errno(rsp->status);\n\n\tif (status)\n\t\tpr_err(\"opcode=0x%x, subsystem=0x%x\\n\",\n\t\t       (rsp->subsys_op & OCRDMA_MBX_RSP_OPCODE_MASK) >>\n\t\t\tOCRDMA_MBX_RSP_OPCODE_SHIFT,\n\t\t\t(rsp->subsys_op & OCRDMA_MBX_RSP_SUBSYS_MASK) >>\n\t\t\tOCRDMA_MBX_RSP_SUBSYS_SHIFT);\n\treturn status;\n}\n\nstatic void ocrdma_get_attr(struct ocrdma_dev *dev,\n\t\t\t      struct ocrdma_dev_attr *attr,\n\t\t\t      struct ocrdma_mbx_query_config *rsp)\n{\n\tattr->max_pd =\n\t    (rsp->max_pd_ca_ack_delay & OCRDMA_MBX_QUERY_CFG_MAX_PD_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_PD_SHIFT;\n\tattr->udp_encap = (rsp->max_pd_ca_ack_delay &\n\t\t\t   OCRDMA_MBX_QUERY_CFG_L3_TYPE_MASK) >>\n\t\t\t   OCRDMA_MBX_QUERY_CFG_L3_TYPE_SHIFT;\n\tattr->max_dpp_pds =\n\t   (rsp->max_dpp_pds_credits & OCRDMA_MBX_QUERY_CFG_MAX_DPP_PDS_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_DPP_PDS_OFFSET;\n\tattr->max_qp =\n\t    (rsp->qp_srq_cq_ird_ord & OCRDMA_MBX_QUERY_CFG_MAX_QP_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_QP_SHIFT;\n\tattr->max_srq =\n\t\t(rsp->max_srq_rpir_qps & OCRDMA_MBX_QUERY_CFG_MAX_SRQ_MASK) >>\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_SRQ_OFFSET;\n\tattr->max_send_sge = ((rsp->max_recv_send_sge &\n\t\t\t       OCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_MASK) >>\n\t\t\t      OCRDMA_MBX_QUERY_CFG_MAX_SEND_SGE_SHIFT);\n\tattr->max_recv_sge = (rsp->max_recv_send_sge &\n\t\t\t      OCRDMA_MBX_QUERY_CFG_MAX_RECV_SGE_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_RECV_SGE_SHIFT;\n\tattr->max_srq_sge = (rsp->max_srq_rqe_sge &\n\t\t\t      OCRDMA_MBX_QUERY_CFG_MAX_SRQ_SGE_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_SRQ_SGE_OFFSET;\n\tattr->max_rdma_sge = (rsp->max_wr_rd_sge &\n\t\t\t      OCRDMA_MBX_QUERY_CFG_MAX_RD_SGE_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_RD_SGE_SHIFT;\n\tattr->max_ord_per_qp = (rsp->max_ird_ord_per_qp &\n\t\t\t\tOCRDMA_MBX_QUERY_CFG_MAX_ORD_PER_QP_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_ORD_PER_QP_SHIFT;\n\tattr->max_ird_per_qp = (rsp->max_ird_ord_per_qp &\n\t\t\t\tOCRDMA_MBX_QUERY_CFG_MAX_IRD_PER_QP_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_MAX_IRD_PER_QP_SHIFT;\n\tattr->cq_overflow_detect = (rsp->qp_srq_cq_ird_ord &\n\t\t\t\t    OCRDMA_MBX_QUERY_CFG_CQ_OVERFLOW_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_CQ_OVERFLOW_SHIFT;\n\tattr->srq_supported = (rsp->qp_srq_cq_ird_ord &\n\t\t\t       OCRDMA_MBX_QUERY_CFG_SRQ_SUPPORTED_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_SRQ_SUPPORTED_SHIFT;\n\tattr->local_ca_ack_delay = (rsp->max_pd_ca_ack_delay &\n\t\t\t\t    OCRDMA_MBX_QUERY_CFG_CA_ACK_DELAY_MASK) >>\n\t    OCRDMA_MBX_QUERY_CFG_CA_ACK_DELAY_SHIFT;\n\tattr->max_mw = rsp->max_mw;\n\tattr->max_mr = rsp->max_mr;\n\tattr->max_mr_size = ((u64)rsp->max_mr_size_hi << 32) |\n\t\t\t      rsp->max_mr_size_lo;\n\tattr->max_pages_per_frmr = rsp->max_pages_per_frmr;\n\tattr->max_num_mr_pbl = rsp->max_num_mr_pbl;\n\tattr->max_cqe = rsp->max_cq_cqes_per_cq &\n\t\t\tOCRDMA_MBX_QUERY_CFG_MAX_CQES_PER_CQ_MASK;\n\tattr->max_cq = (rsp->max_cq_cqes_per_cq &\n\t\t\tOCRDMA_MBX_QUERY_CFG_MAX_CQ_MASK) >>\n\t\t\tOCRDMA_MBX_QUERY_CFG_MAX_CQ_OFFSET;\n\tattr->wqe_size = ((rsp->wqe_rqe_stride_max_dpp_cqs &\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_WQE_SIZE_MASK) >>\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_WQE_SIZE_OFFSET) *\n\t\tOCRDMA_WQE_STRIDE;\n\tattr->rqe_size = ((rsp->wqe_rqe_stride_max_dpp_cqs &\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_RQE_SIZE_MASK) >>\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_RQE_SIZE_OFFSET) *\n\t\tOCRDMA_WQE_STRIDE;\n\tattr->max_inline_data =\n\t    attr->wqe_size - (sizeof(struct ocrdma_hdr_wqe) +\n\t\t\t      sizeof(struct ocrdma_sge));\n\tif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\n\t\tattr->ird = 1;\n\t\tattr->ird_page_size = OCRDMA_MIN_Q_PAGE_SIZE;\n\t\tattr->num_ird_pages = MAX_OCRDMA_IRD_PAGES;\n\t}\n\tdev->attr.max_wqe = rsp->max_wqes_rqes_per_q >>\n\t\t OCRDMA_MBX_QUERY_CFG_MAX_WQES_PER_WQ_OFFSET;\n\tdev->attr.max_rqe = rsp->max_wqes_rqes_per_q &\n\t\tOCRDMA_MBX_QUERY_CFG_MAX_RQES_PER_RQ_MASK;\n}\n\nstatic int ocrdma_check_fw_config(struct ocrdma_dev *dev,\n\t\t\t\t   struct ocrdma_fw_conf_rsp *conf)\n{\n\tu32 fn_mode;\n\n\tfn_mode = conf->fn_mode & OCRDMA_FN_MODE_RDMA;\n\tif (fn_mode != OCRDMA_FN_MODE_RDMA)\n\t\treturn -EINVAL;\n\tdev->base_eqid = conf->base_eqid;\n\tdev->max_eq = conf->max_eq;\n\treturn 0;\n}\n\n \nstatic int ocrdma_mbx_query_fw_ver(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_mqe *cmd;\n\tstruct ocrdma_fw_ver_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_GET_FW_VER, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\n\t\t\tOCRDMA_CMD_GET_FW_VER,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_fw_ver_rsp *)cmd;\n\tmemset(&dev->attr.fw_ver[0], 0, sizeof(dev->attr.fw_ver));\n\tmemcpy(&dev->attr.fw_ver[0], &rsp->running_ver[0],\n\t       sizeof(rsp->running_ver));\n\tocrdma_le32_to_cpu(dev->attr.fw_ver, sizeof(rsp->running_ver));\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\n \nstatic int ocrdma_mbx_query_fw_config(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_mqe *cmd;\n\tstruct ocrdma_fw_conf_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_GET_FW_CONFIG, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\n\t\t\tOCRDMA_CMD_GET_FW_CONFIG,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_fw_conf_rsp *)cmd;\n\tstatus = ocrdma_check_fw_config(dev, rsp);\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_rdma_stats(struct ocrdma_dev *dev, bool reset)\n{\n\tstruct ocrdma_rdma_stats_req *req = dev->stats_mem.va;\n\tstruct ocrdma_mqe *mqe = &dev->stats_mem.mqe;\n\tstruct ocrdma_rdma_stats_resp *old_stats;\n\tint status;\n\n\told_stats = kmalloc(sizeof(*old_stats), GFP_KERNEL);\n\tif (old_stats == NULL)\n\t\treturn -ENOMEM;\n\n\tmemset(mqe, 0, sizeof(*mqe));\n\tmqe->hdr.pyld_len = dev->stats_mem.size;\n\tmqe->hdr.spcl_sge_cnt_emb |=\n\t\t\t(1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\n\t\t\t\tOCRDMA_MQE_HDR_SGE_CNT_MASK;\n\tmqe->u.nonemb_req.sge[0].pa_lo = (u32) (dev->stats_mem.pa & 0xffffffff);\n\tmqe->u.nonemb_req.sge[0].pa_hi = (u32) upper_32_bits(dev->stats_mem.pa);\n\tmqe->u.nonemb_req.sge[0].len = dev->stats_mem.size;\n\n\t \n\tmemcpy(old_stats, req, sizeof(struct ocrdma_rdma_stats_resp));\n\tmemset(req, 0, dev->stats_mem.size);\n\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)req,\n\t\t\tOCRDMA_CMD_GET_RDMA_STATS,\n\t\t\tOCRDMA_SUBSYS_ROCE,\n\t\t\tdev->stats_mem.size);\n\tif (reset)\n\t\treq->reset_stats = reset;\n\n\tstatus = ocrdma_nonemb_mbx_cmd(dev, mqe, dev->stats_mem.va);\n\tif (status)\n\t\t \n\t\tmemcpy(req, old_stats, sizeof(struct ocrdma_rdma_stats_resp));\n\telse\n\t\tocrdma_le32_to_cpu(req, dev->stats_mem.size);\n\n\tkfree(old_stats);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_get_ctrl_attribs(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_dma_mem dma;\n\tstruct ocrdma_mqe *mqe;\n\tstruct ocrdma_get_ctrl_attribs_rsp *ctrl_attr_rsp;\n\tstruct mgmt_hba_attribs *hba_attribs;\n\n\tmqe = kzalloc(sizeof(struct ocrdma_mqe), GFP_KERNEL);\n\tif (!mqe)\n\t\treturn status;\n\n\tdma.size = sizeof(struct ocrdma_get_ctrl_attribs_rsp);\n\tdma.va\t = dma_alloc_coherent(&dev->nic_info.pdev->dev,\n\t\t\t\t\tdma.size, &dma.pa, GFP_KERNEL);\n\tif (!dma.va)\n\t\tgoto free_mqe;\n\n\tmqe->hdr.pyld_len = dma.size;\n\tmqe->hdr.spcl_sge_cnt_emb |=\n\t\t\t(1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\n\t\t\tOCRDMA_MQE_HDR_SGE_CNT_MASK;\n\tmqe->u.nonemb_req.sge[0].pa_lo = (u32) (dma.pa & 0xffffffff);\n\tmqe->u.nonemb_req.sge[0].pa_hi = (u32) upper_32_bits(dma.pa);\n\tmqe->u.nonemb_req.sge[0].len = dma.size;\n\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)dma.va,\n\t\t\tOCRDMA_CMD_GET_CTRL_ATTRIBUTES,\n\t\t\tOCRDMA_SUBSYS_COMMON,\n\t\t\tdma.size);\n\n\tstatus = ocrdma_nonemb_mbx_cmd(dev, mqe, dma.va);\n\tif (!status) {\n\t\tctrl_attr_rsp = (struct ocrdma_get_ctrl_attribs_rsp *)dma.va;\n\t\thba_attribs = &ctrl_attr_rsp->ctrl_attribs.hba_attribs;\n\n\t\tdev->hba_port_num = (hba_attribs->ptpnum_maxdoms_hbast_cv &\n\t\t\t\t\tOCRDMA_HBA_ATTRB_PTNUM_MASK)\n\t\t\t\t\t>> OCRDMA_HBA_ATTRB_PTNUM_SHIFT;\n\t\tstrscpy(dev->model_number,\n\t\t\thba_attribs->controller_model_number,\n\t\t\tsizeof(dev->model_number));\n\t}\n\tdma_free_coherent(&dev->nic_info.pdev->dev, dma.size, dma.va, dma.pa);\nfree_mqe:\n\tkfree(mqe);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_query_dev(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_mbx_query_config *rsp;\n\tstruct ocrdma_mqe *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_CONFIG, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_mbx_query_config *)cmd;\n\tocrdma_get_attr(dev, &dev->attr, rsp);\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_get_link_speed(struct ocrdma_dev *dev, u8 *lnk_speed,\n\t\t\t      u8 *lnk_state)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_get_link_speed_rsp *rsp;\n\tstruct ocrdma_mqe *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_NTWK_LINK_CONFIG_V1,\n\t\t\t\t  sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\n\t\t\tOCRDMA_CMD_QUERY_NTWK_LINK_CONFIG_V1,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\n\t((struct ocrdma_mbx_hdr *)cmd->u.cmd)->rsvd_version = 0x1;\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\n\trsp = (struct ocrdma_get_link_speed_rsp *)cmd;\n\tif (lnk_speed)\n\t\t*lnk_speed = (rsp->pflt_pps_ld_pnum & OCRDMA_PHY_PS_MASK)\n\t\t\t      >> OCRDMA_PHY_PS_SHIFT;\n\tif (lnk_state)\n\t\t*lnk_state = (rsp->res_lnk_st & OCRDMA_LINK_ST_MASK);\n\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_get_phy_info(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_mqe *cmd;\n\tstruct ocrdma_get_phy_info_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_PHY_DETAILS, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\n\tocrdma_init_mch((struct ocrdma_mbx_hdr *)&cmd->u.cmd[0],\n\t\t\tOCRDMA_CMD_PHY_DETAILS, OCRDMA_SUBSYS_COMMON,\n\t\t\tsizeof(*cmd));\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\n\trsp = (struct ocrdma_get_phy_info_rsp *)cmd;\n\tdev->phy.phy_type =\n\t\t\t(rsp->ityp_ptyp & OCRDMA_PHY_TYPE_MASK);\n\tdev->phy.interface_type =\n\t\t\t(rsp->ityp_ptyp & OCRDMA_IF_TYPE_MASK)\n\t\t\t\t>> OCRDMA_IF_TYPE_SHIFT;\n\tdev->phy.auto_speeds_supported  =\n\t\t\t(rsp->fspeed_aspeed & OCRDMA_ASPEED_SUPP_MASK);\n\tdev->phy.fixed_speeds_supported =\n\t\t\t(rsp->fspeed_aspeed & OCRDMA_FSPEED_SUPP_MASK)\n\t\t\t\t>> OCRDMA_FSPEED_SUPP_SHIFT;\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_alloc_pd(struct ocrdma_dev *dev, struct ocrdma_pd *pd)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_alloc_pd *cmd;\n\tstruct ocrdma_alloc_pd_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tif (pd->dpp_enabled)\n\t\tcmd->enable_dpp_rsvd |= OCRDMA_ALLOC_PD_ENABLE_DPP;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_alloc_pd_rsp *)cmd;\n\tpd->id = rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_PDID_MASK;\n\tif (rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_DPP) {\n\t\tpd->dpp_enabled = true;\n\t\tpd->dpp_page = rsp->dpp_page_pdid >>\n\t\t\t\tOCRDMA_ALLOC_PD_RSP_DPP_PAGE_SHIFT;\n\t} else {\n\t\tpd->dpp_enabled = false;\n\t\tpd->num_dpp_qp = 0;\n\t}\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_dealloc_pd(struct ocrdma_dev *dev, struct ocrdma_pd *pd)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_dealloc_pd *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->id = pd->id;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tkfree(cmd);\n\treturn status;\n}\n\n\nstatic int ocrdma_mbx_alloc_pd_range(struct ocrdma_dev *dev)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_alloc_pd_range *cmd;\n\tstruct ocrdma_alloc_pd_range_rsp *rsp;\n\n\t \n\tif (dev->attr.max_dpp_pds) {\n\t\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD_RANGE,\n\t\t\t\t\t  sizeof(*cmd));\n\t\tif (!cmd)\n\t\t\treturn -ENOMEM;\n\t\tcmd->pd_count = dev->attr.max_dpp_pds;\n\t\tcmd->enable_dpp_rsvd |= OCRDMA_ALLOC_PD_ENABLE_DPP;\n\t\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\t\trsp = (struct ocrdma_alloc_pd_range_rsp *)cmd;\n\n\t\tif (!status && (rsp->dpp_page_pdid & OCRDMA_ALLOC_PD_RSP_DPP) &&\n\t\t    rsp->pd_count) {\n\t\t\tdev->pd_mgr->dpp_page_index = rsp->dpp_page_pdid >>\n\t\t\t\t\tOCRDMA_ALLOC_PD_RSP_DPP_PAGE_SHIFT;\n\t\t\tdev->pd_mgr->pd_dpp_start = rsp->dpp_page_pdid &\n\t\t\t\t\tOCRDMA_ALLOC_PD_RNG_RSP_START_PDID_MASK;\n\t\t\tdev->pd_mgr->max_dpp_pd = rsp->pd_count;\n\t\t\tdev->pd_mgr->pd_dpp_bitmap = bitmap_zalloc(rsp->pd_count,\n\t\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\t}\n\t\tkfree(cmd);\n\t}\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_PD_RANGE, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->pd_count = dev->attr.max_pd - dev->attr.max_dpp_pds;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\trsp = (struct ocrdma_alloc_pd_range_rsp *)cmd;\n\tif (!status && rsp->pd_count) {\n\t\tdev->pd_mgr->pd_norm_start = rsp->dpp_page_pdid &\n\t\t\t\t\tOCRDMA_ALLOC_PD_RNG_RSP_START_PDID_MASK;\n\t\tdev->pd_mgr->max_normal_pd = rsp->pd_count;\n\t\tdev->pd_mgr->pd_norm_bitmap = bitmap_zalloc(rsp->pd_count,\n\t\t\t\t\t\t\t    GFP_KERNEL);\n\t}\n\tkfree(cmd);\n\n\tif (dev->pd_mgr->pd_norm_bitmap || dev->pd_mgr->pd_dpp_bitmap) {\n\t\t \n\t\tdev->pd_mgr->pd_prealloc_valid = true;\n\t\treturn 0;\n\t}\n\treturn status;\n}\n\nstatic void ocrdma_mbx_dealloc_pd_range(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_dealloc_pd_range *cmd;\n\n\t \n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD_RANGE, sizeof(*cmd));\n\tif (!cmd)\n\t\tgoto mbx_err;\n\n\tif (dev->pd_mgr->max_normal_pd) {\n\t\tcmd->start_pd_id = dev->pd_mgr->pd_norm_start;\n\t\tcmd->pd_count = dev->pd_mgr->max_normal_pd;\n\t\tocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\t}\n\n\tif (dev->pd_mgr->max_dpp_pd) {\n\t\tkfree(cmd);\n\t\t \n\t\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_PD_RANGE,\n\t\t\t\t\t  sizeof(*cmd));\n\t\tif (!cmd)\n\t\t\tgoto mbx_err;\n\n\t\tcmd->start_pd_id = dev->pd_mgr->pd_dpp_start;\n\t\tcmd->pd_count = dev->pd_mgr->max_dpp_pd;\n\t\tocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\t}\nmbx_err:\n\tkfree(cmd);\n}\n\nvoid ocrdma_alloc_pd_pool(struct ocrdma_dev *dev)\n{\n\tint status;\n\n\tdev->pd_mgr = kzalloc(sizeof(struct ocrdma_pd_resource_mgr),\n\t\t\t      GFP_KERNEL);\n\tif (!dev->pd_mgr)\n\t\treturn;\n\n\tstatus = ocrdma_mbx_alloc_pd_range(dev);\n\tif (status) {\n\t\tpr_err(\"%s(%d) Unable to initialize PD pool, using default.\\n\",\n\t\t\t __func__, dev->id);\n\t}\n}\n\nstatic void ocrdma_free_pd_pool(struct ocrdma_dev *dev)\n{\n\tocrdma_mbx_dealloc_pd_range(dev);\n\tbitmap_free(dev->pd_mgr->pd_norm_bitmap);\n\tbitmap_free(dev->pd_mgr->pd_dpp_bitmap);\n\tkfree(dev->pd_mgr);\n}\n\nstatic int ocrdma_build_q_conf(u32 *num_entries, int entry_size,\n\t\t\t       int *num_pages, int *page_size)\n{\n\tint i;\n\tint mem_size;\n\n\t*num_entries = roundup_pow_of_two(*num_entries);\n\tmem_size = *num_entries * entry_size;\n\t \n\tfor (i = 0; i < OCRDMA_MAX_Q_PAGE_SIZE_CNT; i++) {\n\t\tif (mem_size <= (OCRDMA_Q_PAGE_BASE_SIZE << i))\n\t\t\tbreak;\n\t}\n\tif (i >= OCRDMA_MAX_Q_PAGE_SIZE_CNT)\n\t\treturn -EINVAL;\n\tmem_size = roundup(mem_size,\n\t\t       ((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES));\n\t*num_pages =\n\t    mem_size / ((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES);\n\t*page_size = ((OCRDMA_Q_PAGE_BASE_SIZE << i) / OCRDMA_MAX_Q_PAGES);\n\t*num_entries = mem_size / entry_size;\n\treturn 0;\n}\n\nstatic int ocrdma_mbx_create_ah_tbl(struct ocrdma_dev *dev)\n{\n\tint i;\n\tint status = -ENOMEM;\n\tint max_ah;\n\tstruct ocrdma_create_ah_tbl *cmd;\n\tstruct ocrdma_create_ah_tbl_rsp *rsp;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tdma_addr_t pa;\n\tstruct ocrdma_pbe *pbes;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_AH_TBL, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\n\tmax_ah = OCRDMA_MAX_AH;\n\tdev->av_tbl.size = sizeof(struct ocrdma_av) * max_ah;\n\n\t \n\tcmd->ah_conf = (OCRDMA_AH_TBL_PAGES <<\n\t\t\t\tOCRDMA_CREATE_AH_NUM_PAGES_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_AH_NUM_PAGES_MASK;\n\n\t \n\tfor (i = 0; i < OCRDMA_MAX_Q_PAGE_SIZE_CNT; i++) {\n\t\tif (PAGE_SIZE == (OCRDMA_MIN_Q_PAGE_SIZE << i))\n\t\t\tbreak;\n\t}\n\tcmd->ah_conf |= (i << OCRDMA_CREATE_AH_PAGE_SIZE_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_AH_PAGE_SIZE_MASK;\n\n\t \n\tcmd->ah_conf |= (sizeof(struct ocrdma_av) <<\n\t\t\t\tOCRDMA_CREATE_AH_ENTRY_SIZE_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_AH_ENTRY_SIZE_MASK;\n\n\tdev->av_tbl.pbl.va = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\n\t\t\t\t\t\t&dev->av_tbl.pbl.pa,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (dev->av_tbl.pbl.va == NULL)\n\t\tgoto mem_err;\n\n\tdev->av_tbl.va = dma_alloc_coherent(&pdev->dev, dev->av_tbl.size,\n\t\t\t\t\t    &pa, GFP_KERNEL);\n\tif (dev->av_tbl.va == NULL)\n\t\tgoto mem_err_ah;\n\tdev->av_tbl.pa = pa;\n\tdev->av_tbl.num_ah = max_ah;\n\n\tpbes = (struct ocrdma_pbe *)dev->av_tbl.pbl.va;\n\tfor (i = 0; i < dev->av_tbl.size / OCRDMA_MIN_Q_PAGE_SIZE; i++) {\n\t\tpbes[i].pa_lo = (u32)cpu_to_le32(pa & 0xffffffff);\n\t\tpbes[i].pa_hi = (u32)cpu_to_le32(upper_32_bits(pa));\n\t\tpa += PAGE_SIZE;\n\t}\n\tcmd->tbl_addr[0].lo = (u32)(dev->av_tbl.pbl.pa & 0xFFFFFFFF);\n\tcmd->tbl_addr[0].hi = (u32)upper_32_bits(dev->av_tbl.pbl.pa);\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_create_ah_tbl_rsp *)cmd;\n\tdev->av_tbl.ahid = rsp->ahid & 0xFFFF;\n\tkfree(cmd);\n\treturn 0;\n\nmbx_err:\n\tdma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,\n\t\t\t  dev->av_tbl.pa);\n\tdev->av_tbl.va = NULL;\nmem_err_ah:\n\tdma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,\n\t\t\t  dev->av_tbl.pbl.pa);\n\tdev->av_tbl.pbl.va = NULL;\n\tdev->av_tbl.size = 0;\nmem_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic void ocrdma_mbx_delete_ah_tbl(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_delete_ah_tbl *cmd;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\n\tif (dev->av_tbl.va == NULL)\n\t\treturn;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_AH_TBL, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn;\n\tcmd->ahid = dev->av_tbl.ahid;\n\n\tocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tdma_free_coherent(&pdev->dev, dev->av_tbl.size, dev->av_tbl.va,\n\t\t\t  dev->av_tbl.pa);\n\tdev->av_tbl.va = NULL;\n\tdma_free_coherent(&pdev->dev, PAGE_SIZE, dev->av_tbl.pbl.va,\n\t\t\t  dev->av_tbl.pbl.pa);\n\tkfree(cmd);\n}\n\n \nstatic u16 ocrdma_bind_eq(struct ocrdma_dev *dev)\n{\n\tint i, selected_eq = 0, cq_cnt = 0;\n\tu16 eq_id;\n\n\tmutex_lock(&dev->dev_lock);\n\tcq_cnt = dev->eq_tbl[0].cq_cnt;\n\teq_id = dev->eq_tbl[0].q.id;\n\t \n\tfor (i = 0; i < dev->eq_cnt; i++) {\n\t\tif (dev->eq_tbl[i].cq_cnt < cq_cnt) {\n\t\t\tcq_cnt = dev->eq_tbl[i].cq_cnt;\n\t\t\teq_id = dev->eq_tbl[i].q.id;\n\t\t\tselected_eq = i;\n\t\t}\n\t}\n\tdev->eq_tbl[selected_eq].cq_cnt += 1;\n\tmutex_unlock(&dev->dev_lock);\n\treturn eq_id;\n}\n\nstatic void ocrdma_unbind_eq(struct ocrdma_dev *dev, u16 eq_id)\n{\n\tint i;\n\n\tmutex_lock(&dev->dev_lock);\n\ti = ocrdma_get_eq_table_index(dev, eq_id);\n\tif (i == -EINVAL)\n\t\tBUG();\n\tdev->eq_tbl[i].cq_cnt -= 1;\n\tmutex_unlock(&dev->dev_lock);\n}\n\nint ocrdma_mbx_create_cq(struct ocrdma_dev *dev, struct ocrdma_cq *cq,\n\t\t\t int entries, int dpp_cq, u16 pd_id)\n{\n\tint status = -ENOMEM; int max_hw_cqe;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tstruct ocrdma_create_cq *cmd;\n\tstruct ocrdma_create_cq_rsp *rsp;\n\tu32 hw_pages, cqe_size, page_size, cqe_count;\n\n\tif (entries > dev->attr.max_cqe) {\n\t\tpr_err(\"%s(%d) max_cqe=0x%x, requester_cqe=0x%x\\n\",\n\t\t       __func__, dev->id, dev->attr.max_cqe, entries);\n\t\treturn -EINVAL;\n\t}\n\tif (dpp_cq && (ocrdma_get_asic_type(dev) != OCRDMA_ASIC_GEN_SKH_R))\n\t\treturn -EINVAL;\n\n\tif (dpp_cq) {\n\t\tcq->max_hw_cqe = 1;\n\t\tmax_hw_cqe = 1;\n\t\tcqe_size = OCRDMA_DPP_CQE_SIZE;\n\t\thw_pages = 1;\n\t} else {\n\t\tcq->max_hw_cqe = dev->attr.max_cqe;\n\t\tmax_hw_cqe = dev->attr.max_cqe;\n\t\tcqe_size = sizeof(struct ocrdma_cqe);\n\t\thw_pages = OCRDMA_CREATE_CQ_MAX_PAGES;\n\t}\n\n\tcq->len = roundup(max_hw_cqe * cqe_size, OCRDMA_MIN_Q_PAGE_SIZE);\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_CQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tocrdma_init_mch(&cmd->cmd.req, OCRDMA_CMD_CREATE_CQ,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\tcq->va = dma_alloc_coherent(&pdev->dev, cq->len, &cq->pa, GFP_KERNEL);\n\tif (!cq->va) {\n\t\tstatus = -ENOMEM;\n\t\tgoto mem_err;\n\t}\n\tpage_size = cq->len / hw_pages;\n\tcmd->cmd.pgsz_pgcnt = (page_size / OCRDMA_MIN_Q_PAGE_SIZE) <<\n\t\t\t\t\tOCRDMA_CREATE_CQ_PAGE_SIZE_SHIFT;\n\tcmd->cmd.pgsz_pgcnt |= hw_pages;\n\tcmd->cmd.ev_cnt_flags = OCRDMA_CREATE_CQ_DEF_FLAGS;\n\n\tcq->eqn = ocrdma_bind_eq(dev);\n\tcmd->cmd.req.rsvd_version = OCRDMA_CREATE_CQ_VER3;\n\tcqe_count = cq->len / cqe_size;\n\tcq->cqe_cnt = cqe_count;\n\tif (cqe_count > 1024) {\n\t\t \n\t\tcmd->cmd.ev_cnt_flags |= (0x3 << OCRDMA_CREATE_CQ_CNT_SHIFT);\n\t} else {\n\t\tu8 count = 0;\n\t\tswitch (cqe_count) {\n\t\tcase 256:\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\tcase 512:\n\t\t\tcount = 1;\n\t\t\tbreak;\n\t\tcase 1024:\n\t\t\tcount = 2;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto mbx_err;\n\t\t}\n\t\tcmd->cmd.ev_cnt_flags |= (count << OCRDMA_CREATE_CQ_CNT_SHIFT);\n\t}\n\t \n\tcmd->cmd.eqn = cq->eqn;\n\tif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R) {\n\t\tif (dpp_cq)\n\t\t\tcmd->cmd.pgsz_pgcnt |= OCRDMA_CREATE_CQ_DPP <<\n\t\t\t\tOCRDMA_CREATE_CQ_TYPE_SHIFT;\n\t\tcq->phase_change = false;\n\t\tcmd->cmd.pdid_cqecnt = (cq->len / cqe_size);\n\t} else {\n\t\tcmd->cmd.pdid_cqecnt = (cq->len / cqe_size) - 1;\n\t\tcmd->cmd.ev_cnt_flags |= OCRDMA_CREATE_CQ_FLAGS_AUTO_VALID;\n\t\tcq->phase_change = true;\n\t}\n\n\t \n\tcmd->cmd.pdid_cqecnt |= (pd_id <<\n\t\tOCRDMA_CREATE_CQ_CMD_PDID_SHIFT);\n\tocrdma_build_q_pages(&cmd->cmd.pa[0], hw_pages, cq->pa, page_size);\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\n\trsp = (struct ocrdma_create_cq_rsp *)cmd;\n\tcq->id = (u16) (rsp->rsp.cq_id & OCRDMA_CREATE_CQ_RSP_CQ_ID_MASK);\n\tkfree(cmd);\n\treturn 0;\nmbx_err:\n\tocrdma_unbind_eq(dev, cq->eqn);\n\tdma_free_coherent(&pdev->dev, cq->len, cq->va, cq->pa);\nmem_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nvoid ocrdma_mbx_destroy_cq(struct ocrdma_dev *dev, struct ocrdma_cq *cq)\n{\n\tstruct ocrdma_destroy_cq *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_CQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn;\n\tocrdma_init_mch(&cmd->req, OCRDMA_CMD_DELETE_CQ,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\n\tcmd->bypass_flush_qid |=\n\t    (cq->id << OCRDMA_DESTROY_CQ_QID_SHIFT) &\n\t    OCRDMA_DESTROY_CQ_QID_MASK;\n\n\tocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tocrdma_unbind_eq(dev, cq->eqn);\n\tdma_free_coherent(&dev->nic_info.pdev->dev, cq->len, cq->va, cq->pa);\n\tkfree(cmd);\n}\n\nint ocrdma_mbx_alloc_lkey(struct ocrdma_dev *dev, struct ocrdma_hw_mr *hwmr,\n\t\t\t  u32 pdid, int addr_check)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_alloc_lkey *cmd;\n\tstruct ocrdma_alloc_lkey_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_ALLOC_LKEY, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->pdid = pdid;\n\tcmd->pbl_sz_flags |= addr_check;\n\tcmd->pbl_sz_flags |= (hwmr->fr_mr << OCRDMA_ALLOC_LKEY_FMR_SHIFT);\n\tcmd->pbl_sz_flags |=\n\t    (hwmr->remote_wr << OCRDMA_ALLOC_LKEY_REMOTE_WR_SHIFT);\n\tcmd->pbl_sz_flags |=\n\t    (hwmr->remote_rd << OCRDMA_ALLOC_LKEY_REMOTE_RD_SHIFT);\n\tcmd->pbl_sz_flags |=\n\t    (hwmr->local_wr << OCRDMA_ALLOC_LKEY_LOCAL_WR_SHIFT);\n\tcmd->pbl_sz_flags |=\n\t    (hwmr->remote_atomic << OCRDMA_ALLOC_LKEY_REMOTE_ATOMIC_SHIFT);\n\tcmd->pbl_sz_flags |=\n\t    (hwmr->num_pbls << OCRDMA_ALLOC_LKEY_PBL_SIZE_SHIFT);\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_alloc_lkey_rsp *)cmd;\n\thwmr->lkey = rsp->lrkey;\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_dealloc_lkey(struct ocrdma_dev *dev, int fr_mr, u32 lkey)\n{\n\tint status;\n\tstruct ocrdma_dealloc_lkey *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DEALLOC_LKEY, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->lkey = lkey;\n\tcmd->rsvd_frmr = fr_mr ? 1 : 0;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_reg_mr(struct ocrdma_dev *dev, struct ocrdma_hw_mr *hwmr,\n\t\t\t     u32 pdid, u32 pbl_cnt, u32 pbe_size, u32 last)\n{\n\tint status = -ENOMEM;\n\tint i;\n\tstruct ocrdma_reg_nsmr *cmd;\n\tstruct ocrdma_reg_nsmr_rsp *rsp;\n\tu64 fbo = hwmr->va & (hwmr->pbe_size - 1);\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_REGISTER_NSMR, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->num_pbl_pdid =\n\t    pdid | (hwmr->num_pbls << OCRDMA_REG_NSMR_NUM_PBL_SHIFT);\n\tcmd->fr_mr = hwmr->fr_mr;\n\n\tcmd->flags_hpage_pbe_sz |= (hwmr->remote_wr <<\n\t\t\t\t    OCRDMA_REG_NSMR_REMOTE_WR_SHIFT);\n\tcmd->flags_hpage_pbe_sz |= (hwmr->remote_rd <<\n\t\t\t\t    OCRDMA_REG_NSMR_REMOTE_RD_SHIFT);\n\tcmd->flags_hpage_pbe_sz |= (hwmr->local_wr <<\n\t\t\t\t    OCRDMA_REG_NSMR_LOCAL_WR_SHIFT);\n\tcmd->flags_hpage_pbe_sz |= (hwmr->remote_atomic <<\n\t\t\t\t    OCRDMA_REG_NSMR_REMOTE_ATOMIC_SHIFT);\n\tcmd->flags_hpage_pbe_sz |= (hwmr->mw_bind <<\n\t\t\t\t    OCRDMA_REG_NSMR_BIND_MEMWIN_SHIFT);\n\tcmd->flags_hpage_pbe_sz |= (last << OCRDMA_REG_NSMR_LAST_SHIFT);\n\n\tcmd->flags_hpage_pbe_sz |= (hwmr->pbe_size / OCRDMA_MIN_HPAGE_SIZE);\n\tcmd->flags_hpage_pbe_sz |= (hwmr->pbl_size / OCRDMA_MIN_HPAGE_SIZE) <<\n\t\t\t\t\tOCRDMA_REG_NSMR_HPAGE_SIZE_SHIFT;\n\tcmd->totlen_low = hwmr->len;\n\tcmd->totlen_high = upper_32_bits(hwmr->len);\n\tcmd->fbo_low = lower_32_bits(fbo);\n\tcmd->fbo_high = upper_32_bits(fbo);\n\tcmd->va_loaddr = (u32) hwmr->va;\n\tcmd->va_hiaddr = (u32) upper_32_bits(hwmr->va);\n\n\tfor (i = 0; i < pbl_cnt; i++) {\n\t\tcmd->pbl[i].lo = (u32) (hwmr->pbl_table[i].pa & 0xffffffff);\n\t\tcmd->pbl[i].hi = upper_32_bits(hwmr->pbl_table[i].pa);\n\t}\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_reg_nsmr_rsp *)cmd;\n\thwmr->lkey = rsp->lrkey;\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_reg_mr_cont(struct ocrdma_dev *dev,\n\t\t\t\t  struct ocrdma_hw_mr *hwmr, u32 pbl_cnt,\n\t\t\t\t  u32 pbl_offset, u32 last)\n{\n\tint status;\n\tint i;\n\tstruct ocrdma_reg_nsmr_cont *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_REGISTER_NSMR_CONT, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\tcmd->lrkey = hwmr->lkey;\n\tcmd->num_pbl_offset = (pbl_cnt << OCRDMA_REG_NSMR_CONT_NUM_PBL_SHIFT) |\n\t    (pbl_offset & OCRDMA_REG_NSMR_CONT_PBL_SHIFT_MASK);\n\tcmd->last = last << OCRDMA_REG_NSMR_CONT_LAST_SHIFT;\n\n\tfor (i = 0; i < pbl_cnt; i++) {\n\t\tcmd->pbl[i].lo =\n\t\t    (u32) (hwmr->pbl_table[i + pbl_offset].pa & 0xffffffff);\n\t\tcmd->pbl[i].hi =\n\t\t    upper_32_bits(hwmr->pbl_table[i + pbl_offset].pa);\n\t}\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_reg_mr(struct ocrdma_dev *dev,\n\t\t  struct ocrdma_hw_mr *hwmr, u32 pdid, int acc)\n{\n\tint status;\n\tu32 last = 0;\n\tu32 cur_pbl_cnt, pbl_offset;\n\tu32 pending_pbl_cnt = hwmr->num_pbls;\n\n\tpbl_offset = 0;\n\tcur_pbl_cnt = min(pending_pbl_cnt, MAX_OCRDMA_NSMR_PBL);\n\tif (cur_pbl_cnt == pending_pbl_cnt)\n\t\tlast = 1;\n\n\tstatus = ocrdma_mbx_reg_mr(dev, hwmr, pdid,\n\t\t\t\t   cur_pbl_cnt, hwmr->pbe_size, last);\n\tif (status) {\n\t\tpr_err(\"%s() status=%d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\t \n\tif (last)\n\t\treturn 0;\n\n\twhile (!last) {\n\t\tpbl_offset += cur_pbl_cnt;\n\t\tpending_pbl_cnt -= cur_pbl_cnt;\n\t\tcur_pbl_cnt = min(pending_pbl_cnt, MAX_OCRDMA_NSMR_PBL);\n\t\t \n\t\tif (cur_pbl_cnt == pending_pbl_cnt)\n\t\t\tlast = 1;\n\n\t\tstatus = ocrdma_mbx_reg_mr_cont(dev, hwmr, cur_pbl_cnt,\n\t\t\t\t\t\tpbl_offset, last);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\tif (status)\n\t\tpr_err(\"%s() err. status=%d\\n\", __func__, status);\n\n\treturn status;\n}\n\nbool ocrdma_is_qp_in_sq_flushlist(struct ocrdma_cq *cq, struct ocrdma_qp *qp)\n{\n\tstruct ocrdma_qp *tmp;\n\tbool found = false;\n\tlist_for_each_entry(tmp, &cq->sq_head, sq_entry) {\n\t\tif (qp == tmp) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\nbool ocrdma_is_qp_in_rq_flushlist(struct ocrdma_cq *cq, struct ocrdma_qp *qp)\n{\n\tstruct ocrdma_qp *tmp;\n\tbool found = false;\n\tlist_for_each_entry(tmp, &cq->rq_head, rq_entry) {\n\t\tif (qp == tmp) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn found;\n}\n\nvoid ocrdma_flush_qp(struct ocrdma_qp *qp)\n{\n\tbool found;\n\tunsigned long flags;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\n\n\tspin_lock_irqsave(&dev->flush_q_lock, flags);\n\tfound = ocrdma_is_qp_in_sq_flushlist(qp->sq_cq, qp);\n\tif (!found)\n\t\tlist_add_tail(&qp->sq_entry, &qp->sq_cq->sq_head);\n\tif (!qp->srq) {\n\t\tfound = ocrdma_is_qp_in_rq_flushlist(qp->rq_cq, qp);\n\t\tif (!found)\n\t\t\tlist_add_tail(&qp->rq_entry, &qp->rq_cq->rq_head);\n\t}\n\tspin_unlock_irqrestore(&dev->flush_q_lock, flags);\n}\n\nstatic void ocrdma_init_hwq_ptr(struct ocrdma_qp *qp)\n{\n\tqp->sq.head = 0;\n\tqp->sq.tail = 0;\n\tqp->rq.head = 0;\n\tqp->rq.tail = 0;\n}\n\nint ocrdma_qp_state_change(struct ocrdma_qp *qp, enum ib_qp_state new_ib_state,\n\t\t\t   enum ib_qp_state *old_ib_state)\n{\n\tunsigned long flags;\n\tenum ocrdma_qp_state new_state;\n\tnew_state = get_ocrdma_qp_state(new_ib_state);\n\n\t \n\tspin_lock_irqsave(&qp->q_lock, flags);\n\n\tif (old_ib_state)\n\t\t*old_ib_state = get_ibqp_state(qp->state);\n\tif (new_state == qp->state) {\n\t\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\t\treturn 1;\n\t}\n\n\n\tif (new_state == OCRDMA_QPS_INIT) {\n\t\tocrdma_init_hwq_ptr(qp);\n\t\tocrdma_del_flush_qp(qp);\n\t} else if (new_state == OCRDMA_QPS_ERR) {\n\t\tocrdma_flush_qp(qp);\n\t}\n\n\tqp->state = new_state;\n\n\tspin_unlock_irqrestore(&qp->q_lock, flags);\n\treturn 0;\n}\n\nstatic u32 ocrdma_set_create_qp_mbx_access_flags(struct ocrdma_qp *qp)\n{\n\tu32 flags = 0;\n\tif (qp->cap_flags & OCRDMA_QP_INB_RD)\n\t\tflags |= OCRDMA_CREATE_QP_REQ_INB_RDEN_MASK;\n\tif (qp->cap_flags & OCRDMA_QP_INB_WR)\n\t\tflags |= OCRDMA_CREATE_QP_REQ_INB_WREN_MASK;\n\tif (qp->cap_flags & OCRDMA_QP_MW_BIND)\n\t\tflags |= OCRDMA_CREATE_QP_REQ_BIND_MEMWIN_MASK;\n\tif (qp->cap_flags & OCRDMA_QP_LKEY0)\n\t\tflags |= OCRDMA_CREATE_QP_REQ_ZERO_LKEYEN_MASK;\n\tif (qp->cap_flags & OCRDMA_QP_FAST_REG)\n\t\tflags |= OCRDMA_CREATE_QP_REQ_FMR_EN_MASK;\n\treturn flags;\n}\n\nstatic int ocrdma_set_create_qp_sq_cmd(struct ocrdma_create_qp_req *cmd,\n\t\t\t\t\tstruct ib_qp_init_attr *attrs,\n\t\t\t\t\tstruct ocrdma_qp *qp)\n{\n\tint status;\n\tu32 len, hw_pages, hw_page_size;\n\tdma_addr_t pa;\n\tstruct ocrdma_pd *pd = qp->pd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tu32 max_wqe_allocated;\n\tu32 max_sges = attrs->cap.max_send_sge;\n\n\t \n\tmax_wqe_allocated = min_t(u32, attrs->cap.max_send_wr + 1,\n\t\t\t\tdev->attr.max_wqe);\n\n\tstatus = ocrdma_build_q_conf(&max_wqe_allocated,\n\t\tdev->attr.wqe_size, &hw_pages, &hw_page_size);\n\tif (status) {\n\t\tpr_err(\"%s() req. max_send_wr=0x%x\\n\", __func__,\n\t\t       max_wqe_allocated);\n\t\treturn -EINVAL;\n\t}\n\tqp->sq.max_cnt = max_wqe_allocated;\n\tlen = (hw_pages * hw_page_size);\n\n\tqp->sq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\n\tif (!qp->sq.va)\n\t\treturn -EINVAL;\n\tqp->sq.len = len;\n\tqp->sq.pa = pa;\n\tqp->sq.entry_size = dev->attr.wqe_size;\n\tocrdma_build_q_pages(&cmd->wq_addr[0], hw_pages, pa, hw_page_size);\n\n\tcmd->type_pgsz_pdn |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE)\n\t\t\t\t<< OCRDMA_CREATE_QP_REQ_SQ_PAGE_SIZE_SHIFT);\n\tcmd->num_wq_rq_pages |= (hw_pages <<\n\t\t\t\t OCRDMA_CREATE_QP_REQ_NUM_WQ_PAGES_SHIFT) &\n\t    OCRDMA_CREATE_QP_REQ_NUM_WQ_PAGES_MASK;\n\tcmd->max_sge_send_write |= (max_sges <<\n\t\t\t\t    OCRDMA_CREATE_QP_REQ_MAX_SGE_SEND_SHIFT) &\n\t    OCRDMA_CREATE_QP_REQ_MAX_SGE_SEND_MASK;\n\tcmd->max_sge_send_write |= (max_sges <<\n\t\t\t\t    OCRDMA_CREATE_QP_REQ_MAX_SGE_WRITE_SHIFT) &\n\t\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_SGE_WRITE_MASK;\n\tcmd->max_wqe_rqe |= (ilog2(qp->sq.max_cnt) <<\n\t\t\t     OCRDMA_CREATE_QP_REQ_MAX_WQE_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_WQE_MASK;\n\tcmd->wqe_rqe_size |= (dev->attr.wqe_size <<\n\t\t\t      OCRDMA_CREATE_QP_REQ_WQE_SIZE_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_WQE_SIZE_MASK;\n\treturn 0;\n}\n\nstatic int ocrdma_set_create_qp_rq_cmd(struct ocrdma_create_qp_req *cmd,\n\t\t\t\t\tstruct ib_qp_init_attr *attrs,\n\t\t\t\t\tstruct ocrdma_qp *qp)\n{\n\tint status;\n\tu32 len, hw_pages, hw_page_size;\n\tdma_addr_t pa = 0;\n\tstruct ocrdma_pd *pd = qp->pd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tu32 max_rqe_allocated = attrs->cap.max_recv_wr + 1;\n\n\tstatus = ocrdma_build_q_conf(&max_rqe_allocated, dev->attr.rqe_size,\n\t\t\t\t     &hw_pages, &hw_page_size);\n\tif (status) {\n\t\tpr_err(\"%s() req. max_recv_wr=0x%x\\n\", __func__,\n\t\t       attrs->cap.max_recv_wr + 1);\n\t\treturn status;\n\t}\n\tqp->rq.max_cnt = max_rqe_allocated;\n\tlen = (hw_pages * hw_page_size);\n\n\tqp->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\n\tif (!qp->rq.va)\n\t\treturn -ENOMEM;\n\tqp->rq.pa = pa;\n\tqp->rq.len = len;\n\tqp->rq.entry_size = dev->attr.rqe_size;\n\n\tocrdma_build_q_pages(&cmd->rq_addr[0], hw_pages, pa, hw_page_size);\n\tcmd->type_pgsz_pdn |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE) <<\n\t\tOCRDMA_CREATE_QP_REQ_RQ_PAGE_SIZE_SHIFT);\n\tcmd->num_wq_rq_pages |=\n\t    (hw_pages << OCRDMA_CREATE_QP_REQ_NUM_RQ_PAGES_SHIFT) &\n\t    OCRDMA_CREATE_QP_REQ_NUM_RQ_PAGES_MASK;\n\tcmd->max_sge_recv_flags |= (attrs->cap.max_recv_sge <<\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_SGE_RECV_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_SGE_RECV_MASK;\n\tcmd->max_wqe_rqe |= (ilog2(qp->rq.max_cnt) <<\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_RQE_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_RQE_MASK;\n\tcmd->wqe_rqe_size |= (dev->attr.rqe_size <<\n\t\t\tOCRDMA_CREATE_QP_REQ_RQE_SIZE_SHIFT) &\n\t\t\tOCRDMA_CREATE_QP_REQ_RQE_SIZE_MASK;\n\treturn 0;\n}\n\nstatic void ocrdma_set_create_qp_dpp_cmd(struct ocrdma_create_qp_req *cmd,\n\t\t\t\t\t struct ocrdma_pd *pd,\n\t\t\t\t\t struct ocrdma_qp *qp,\n\t\t\t\t\t u8 enable_dpp_cq, u16 dpp_cq_id)\n{\n\tpd->num_dpp_qp--;\n\tqp->dpp_enabled = true;\n\tcmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_ENABLE_DPP_MASK;\n\tif (!enable_dpp_cq)\n\t\treturn;\n\tcmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_ENABLE_DPP_MASK;\n\tcmd->dpp_credits_cqid = dpp_cq_id;\n\tcmd->dpp_credits_cqid |= OCRDMA_CREATE_QP_REQ_DPP_CREDIT_LIMIT <<\n\t\t\t\t\tOCRDMA_CREATE_QP_REQ_DPP_CREDIT_SHIFT;\n}\n\nstatic int ocrdma_set_create_qp_ird_cmd(struct ocrdma_create_qp_req *cmd,\n\t\t\t\t\tstruct ocrdma_qp *qp)\n{\n\tstruct ocrdma_pd *pd = qp->pd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tdma_addr_t pa = 0;\n\tint ird_page_size = dev->attr.ird_page_size;\n\tint ird_q_len = dev->attr.num_ird_pages * ird_page_size;\n\tstruct ocrdma_hdr_wqe *rqe;\n\tint i  = 0;\n\n\tif (dev->attr.ird == 0)\n\t\treturn 0;\n\n\tqp->ird_q_va = dma_alloc_coherent(&pdev->dev, ird_q_len, &pa,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!qp->ird_q_va)\n\t\treturn -ENOMEM;\n\tocrdma_build_q_pages(&cmd->ird_addr[0], dev->attr.num_ird_pages,\n\t\t\t     pa, ird_page_size);\n\tfor (; i < ird_q_len / dev->attr.rqe_size; i++) {\n\t\trqe = (struct ocrdma_hdr_wqe *)(qp->ird_q_va +\n\t\t\t(i * dev->attr.rqe_size));\n\t\trqe->cw = 0;\n\t\trqe->cw |= 2;\n\t\trqe->cw |= (OCRDMA_TYPE_LKEY << OCRDMA_WQE_TYPE_SHIFT);\n\t\trqe->cw |= (8 << OCRDMA_WQE_SIZE_SHIFT);\n\t\trqe->cw |= (8 << OCRDMA_WQE_NXT_WQE_SIZE_SHIFT);\n\t}\n\treturn 0;\n}\n\nstatic void ocrdma_get_create_qp_rsp(struct ocrdma_create_qp_rsp *rsp,\n\t\t\t\t     struct ocrdma_qp *qp,\n\t\t\t\t     struct ib_qp_init_attr *attrs,\n\t\t\t\t     u16 *dpp_offset, u16 *dpp_credit_lmt)\n{\n\tu32 max_wqe_allocated, max_rqe_allocated;\n\tqp->id = rsp->qp_id & OCRDMA_CREATE_QP_RSP_QP_ID_MASK;\n\tqp->rq.dbid = rsp->sq_rq_id & OCRDMA_CREATE_QP_RSP_RQ_ID_MASK;\n\tqp->sq.dbid = rsp->sq_rq_id >> OCRDMA_CREATE_QP_RSP_SQ_ID_SHIFT;\n\tqp->max_ird = rsp->max_ord_ird & OCRDMA_CREATE_QP_RSP_MAX_IRD_MASK;\n\tqp->max_ord = (rsp->max_ord_ird >> OCRDMA_CREATE_QP_RSP_MAX_ORD_SHIFT);\n\tqp->dpp_enabled = false;\n\tif (rsp->dpp_response & OCRDMA_CREATE_QP_RSP_DPP_ENABLED_MASK) {\n\t\tqp->dpp_enabled = true;\n\t\t*dpp_credit_lmt = (rsp->dpp_response &\n\t\t\t\tOCRDMA_CREATE_QP_RSP_DPP_CREDITS_MASK) >>\n\t\t\t\tOCRDMA_CREATE_QP_RSP_DPP_CREDITS_SHIFT;\n\t\t*dpp_offset = (rsp->dpp_response &\n\t\t\t\tOCRDMA_CREATE_QP_RSP_DPP_PAGE_OFFSET_MASK) >>\n\t\t\t\tOCRDMA_CREATE_QP_RSP_DPP_PAGE_OFFSET_SHIFT;\n\t}\n\tmax_wqe_allocated =\n\t\trsp->max_wqe_rqe >> OCRDMA_CREATE_QP_RSP_MAX_WQE_SHIFT;\n\tmax_wqe_allocated = 1 << max_wqe_allocated;\n\tmax_rqe_allocated = 1 << ((u16)rsp->max_wqe_rqe);\n\n\tqp->sq.max_cnt = max_wqe_allocated;\n\tqp->sq.max_wqe_idx = max_wqe_allocated - 1;\n\n\tif (!attrs->srq) {\n\t\tqp->rq.max_cnt = max_rqe_allocated;\n\t\tqp->rq.max_wqe_idx = max_rqe_allocated - 1;\n\t}\n}\n\nint ocrdma_mbx_create_qp(struct ocrdma_qp *qp, struct ib_qp_init_attr *attrs,\n\t\t\t u8 enable_dpp_cq, u16 dpp_cq_id, u16 *dpp_offset,\n\t\t\t u16 *dpp_credit_lmt)\n{\n\tint status = -ENOMEM;\n\tu32 flags = 0;\n\tstruct ocrdma_pd *pd = qp->pd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tstruct ocrdma_cq *cq;\n\tstruct ocrdma_create_qp_req *cmd;\n\tstruct ocrdma_create_qp_rsp *rsp;\n\tint qptype;\n\n\tswitch (attrs->qp_type) {\n\tcase IB_QPT_GSI:\n\t\tqptype = OCRDMA_QPT_GSI;\n\t\tbreak;\n\tcase IB_QPT_RC:\n\t\tqptype = OCRDMA_QPT_RC;\n\t\tbreak;\n\tcase IB_QPT_UD:\n\t\tqptype = OCRDMA_QPT_UD;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_QP, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->type_pgsz_pdn |= (qptype << OCRDMA_CREATE_QP_REQ_QPT_SHIFT) &\n\t\t\t\t\t\tOCRDMA_CREATE_QP_REQ_QPT_MASK;\n\tstatus = ocrdma_set_create_qp_sq_cmd(cmd, attrs, qp);\n\tif (status)\n\t\tgoto sq_err;\n\n\tif (attrs->srq) {\n\t\tstruct ocrdma_srq *srq = get_ocrdma_srq(attrs->srq);\n\t\tcmd->max_sge_recv_flags |= OCRDMA_CREATE_QP_REQ_USE_SRQ_MASK;\n\t\tcmd->rq_addr[0].lo = srq->id;\n\t\tqp->srq = srq;\n\t} else {\n\t\tstatus = ocrdma_set_create_qp_rq_cmd(cmd, attrs, qp);\n\t\tif (status)\n\t\t\tgoto rq_err;\n\t}\n\n\tstatus = ocrdma_set_create_qp_ird_cmd(cmd, qp);\n\tif (status)\n\t\tgoto mbx_err;\n\n\tcmd->type_pgsz_pdn |= (pd->id << OCRDMA_CREATE_QP_REQ_PD_ID_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_PD_ID_MASK;\n\n\tflags = ocrdma_set_create_qp_mbx_access_flags(qp);\n\n\tcmd->max_sge_recv_flags |= flags;\n\tcmd->max_ord_ird |= (dev->attr.max_ord_per_qp <<\n\t\t\t     OCRDMA_CREATE_QP_REQ_MAX_ORD_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_ORD_MASK;\n\tcmd->max_ord_ird |= (dev->attr.max_ird_per_qp <<\n\t\t\t     OCRDMA_CREATE_QP_REQ_MAX_IRD_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_MAX_IRD_MASK;\n\tcq = get_ocrdma_cq(attrs->send_cq);\n\tcmd->wq_rq_cqid |= (cq->id << OCRDMA_CREATE_QP_REQ_WQ_CQID_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_WQ_CQID_MASK;\n\tqp->sq_cq = cq;\n\tcq = get_ocrdma_cq(attrs->recv_cq);\n\tcmd->wq_rq_cqid |= (cq->id << OCRDMA_CREATE_QP_REQ_RQ_CQID_SHIFT) &\n\t\t\t\tOCRDMA_CREATE_QP_REQ_RQ_CQID_MASK;\n\tqp->rq_cq = cq;\n\n\tif (pd->dpp_enabled && attrs->cap.max_inline_data && pd->num_dpp_qp &&\n\t    (attrs->cap.max_inline_data <= dev->attr.max_inline_data)) {\n\t\tocrdma_set_create_qp_dpp_cmd(cmd, pd, qp, enable_dpp_cq,\n\t\t\t\t\t     dpp_cq_id);\n\t}\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_create_qp_rsp *)cmd;\n\tocrdma_get_create_qp_rsp(rsp, qp, attrs, dpp_offset, dpp_credit_lmt);\n\tqp->state = OCRDMA_QPS_RST;\n\tkfree(cmd);\n\treturn 0;\nmbx_err:\n\tif (qp->rq.va)\n\t\tdma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);\nrq_err:\n\tpr_err(\"%s(%d) rq_err\\n\", __func__, dev->id);\n\tdma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);\nsq_err:\n\tpr_err(\"%s(%d) sq_err\\n\", __func__, dev->id);\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_query_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp,\n\t\t\tstruct ocrdma_qp_params *param)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_query_qp *cmd;\n\tstruct ocrdma_query_qp_rsp *rsp;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_QP, sizeof(*rsp));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->qp_id = qp->id;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_query_qp_rsp *)cmd;\n\tmemcpy(param, &rsp->params, sizeof(struct ocrdma_qp_params));\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic int ocrdma_set_av_params(struct ocrdma_qp *qp,\n\t\t\t\tstruct ocrdma_modify_qp *cmd,\n\t\t\t\tstruct ib_qp_attr *attrs,\n\t\t\t\tint attr_mask)\n{\n\tint status;\n\tstruct rdma_ah_attr *ah_attr = &attrs->ah_attr;\n\tconst struct ib_gid_attr *sgid_attr;\n\tu16 vlan_id = 0xFFFF;\n\tu8 mac_addr[6], hdr_type;\n\tunion {\n\t\tstruct sockaddr_in  _sockaddr_in;\n\t\tstruct sockaddr_in6 _sockaddr_in6;\n\t} sgid_addr, dgid_addr;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\n\tconst struct ib_global_route *grh;\n\n\tif ((rdma_ah_get_ah_flags(ah_attr) & IB_AH_GRH) == 0)\n\t\treturn -EINVAL;\n\tgrh = rdma_ah_read_grh(ah_attr);\n\tif (atomic_cmpxchg(&dev->update_sl, 1, 0))\n\t\tocrdma_init_service_level(dev);\n\tcmd->params.tclass_sq_psn |=\n\t    (grh->traffic_class << OCRDMA_QP_PARAMS_TCLASS_SHIFT);\n\tcmd->params.rnt_rc_sl_fl |=\n\t    (grh->flow_label & OCRDMA_QP_PARAMS_FLOW_LABEL_MASK);\n\tcmd->params.rnt_rc_sl_fl |= (rdma_ah_get_sl(ah_attr) <<\n\t\t\t\t     OCRDMA_QP_PARAMS_SL_SHIFT);\n\tcmd->params.hop_lmt_rq_psn |=\n\t    (grh->hop_limit << OCRDMA_QP_PARAMS_HOP_LMT_SHIFT);\n\tcmd->flags |= OCRDMA_QP_PARA_FLOW_LBL_VALID;\n\n\t \n\tmemcpy(&cmd->params.dgid[0], &grh->dgid.raw[0],\n\t       sizeof(cmd->params.dgid));\n\n\tsgid_attr = ah_attr->grh.sgid_attr;\n\tstatus = rdma_read_gid_l2_fields(sgid_attr, &vlan_id, &mac_addr[0]);\n\tif (status)\n\t\treturn status;\n\n\tqp->sgid_idx = grh->sgid_index;\n\tmemcpy(&cmd->params.sgid[0], &sgid_attr->gid.raw[0],\n\t       sizeof(cmd->params.sgid));\n\tstatus = ocrdma_resolve_dmac(dev, ah_attr, &mac_addr[0]);\n\tif (status)\n\t\treturn status;\n\n\tcmd->params.dmac_b0_to_b3 = mac_addr[0] | (mac_addr[1] << 8) |\n\t\t\t\t(mac_addr[2] << 16) | (mac_addr[3] << 24);\n\n\thdr_type = rdma_gid_attr_network_type(sgid_attr);\n\tif (hdr_type == RDMA_NETWORK_IPV4) {\n\t\trdma_gid2ip((struct sockaddr *)&sgid_addr, &sgid_attr->gid);\n\t\trdma_gid2ip((struct sockaddr *)&dgid_addr, &grh->dgid);\n\t\tmemcpy(&cmd->params.dgid[0],\n\t\t       &dgid_addr._sockaddr_in.sin_addr.s_addr, 4);\n\t\tmemcpy(&cmd->params.sgid[0],\n\t\t       &sgid_addr._sockaddr_in.sin_addr.s_addr, 4);\n\t}\n\t \n\tocrdma_cpu_to_le32(&cmd->params.dgid[0], sizeof(cmd->params.dgid));\n\tocrdma_cpu_to_le32(&cmd->params.sgid[0], sizeof(cmd->params.sgid));\n\tcmd->params.vlan_dmac_b4_to_b5 = mac_addr[4] | (mac_addr[5] << 8);\n\n\tif (vlan_id == 0xFFFF)\n\t\tvlan_id = 0;\n\tif (vlan_id || dev->pfc_state) {\n\t\tif (!vlan_id) {\n\t\t\tpr_err(\"ocrdma%d:Using VLAN with PFC is recommended\\n\",\n\t\t\t       dev->id);\n\t\t\tpr_err(\"ocrdma%d:Using VLAN 0 for this connection\\n\",\n\t\t\t       dev->id);\n\t\t}\n\t\tcmd->params.vlan_dmac_b4_to_b5 |=\n\t\t    vlan_id << OCRDMA_QP_PARAMS_VLAN_SHIFT;\n\t\tcmd->flags |= OCRDMA_QP_PARA_VLAN_EN_VALID;\n\t\tcmd->params.rnt_rc_sl_fl |=\n\t\t\t(dev->sl & 0x07) << OCRDMA_QP_PARAMS_SL_SHIFT;\n\t}\n\tcmd->params.max_sge_recv_flags |= ((hdr_type <<\n\t\t\t\t\tOCRDMA_QP_PARAMS_FLAGS_L3_TYPE_SHIFT) &\n\t\t\t\t\tOCRDMA_QP_PARAMS_FLAGS_L3_TYPE_MASK);\n\treturn 0;\n}\n\nstatic int ocrdma_set_qp_params(struct ocrdma_qp *qp,\n\t\t\t\tstruct ocrdma_modify_qp *cmd,\n\t\t\t\tstruct ib_qp_attr *attrs, int attr_mask)\n{\n\tint status = 0;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(qp->ibqp.device);\n\n\tif (attr_mask & IB_QP_PKEY_INDEX) {\n\t\tcmd->params.path_mtu_pkey_indx |= (attrs->pkey_index &\n\t\t\t\t\t    OCRDMA_QP_PARAMS_PKEY_INDEX_MASK);\n\t\tcmd->flags |= OCRDMA_QP_PARA_PKEY_VALID;\n\t}\n\tif (attr_mask & IB_QP_QKEY) {\n\t\tqp->qkey = attrs->qkey;\n\t\tcmd->params.qkey = attrs->qkey;\n\t\tcmd->flags |= OCRDMA_QP_PARA_QKEY_VALID;\n\t}\n\tif (attr_mask & IB_QP_AV) {\n\t\tstatus = ocrdma_set_av_params(qp, cmd, attrs, attr_mask);\n\t\tif (status)\n\t\t\treturn status;\n\t} else if (qp->qp_type == IB_QPT_GSI || qp->qp_type == IB_QPT_UD) {\n\t\t \n\t\tcmd->params.dmac_b0_to_b3 = dev->nic_info.mac_addr[0] |\n\t\t\t(dev->nic_info.mac_addr[1] << 8) |\n\t\t\t(dev->nic_info.mac_addr[2] << 16) |\n\t\t\t(dev->nic_info.mac_addr[3] << 24);\n\t\tcmd->params.vlan_dmac_b4_to_b5 = dev->nic_info.mac_addr[4] |\n\t\t\t\t\t(dev->nic_info.mac_addr[5] << 8);\n\t}\n\tif ((attr_mask & IB_QP_EN_SQD_ASYNC_NOTIFY) &&\n\t    attrs->en_sqd_async_notify) {\n\t\tcmd->params.max_sge_recv_flags |=\n\t\t\tOCRDMA_QP_PARAMS_FLAGS_SQD_ASYNC;\n\t\tcmd->flags |= OCRDMA_QP_PARA_DST_QPN_VALID;\n\t}\n\tif (attr_mask & IB_QP_DEST_QPN) {\n\t\tcmd->params.ack_to_rnr_rtc_dest_qpn |= (attrs->dest_qp_num &\n\t\t\t\tOCRDMA_QP_PARAMS_DEST_QPN_MASK);\n\t\tcmd->flags |= OCRDMA_QP_PARA_DST_QPN_VALID;\n\t}\n\tif (attr_mask & IB_QP_PATH_MTU) {\n\t\tif (attrs->path_mtu < IB_MTU_512 ||\n\t\t    attrs->path_mtu > IB_MTU_4096) {\n\t\t\tpr_err(\"ocrdma%d: IB MTU %d is not supported\\n\",\n\t\t\t       dev->id, ib_mtu_enum_to_int(attrs->path_mtu));\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto pmtu_err;\n\t\t}\n\t\tcmd->params.path_mtu_pkey_indx |=\n\t\t    (ib_mtu_enum_to_int(attrs->path_mtu) <<\n\t\t     OCRDMA_QP_PARAMS_PATH_MTU_SHIFT) &\n\t\t    OCRDMA_QP_PARAMS_PATH_MTU_MASK;\n\t\tcmd->flags |= OCRDMA_QP_PARA_PMTU_VALID;\n\t}\n\tif (attr_mask & IB_QP_TIMEOUT) {\n\t\tcmd->params.ack_to_rnr_rtc_dest_qpn |= attrs->timeout <<\n\t\t    OCRDMA_QP_PARAMS_ACK_TIMEOUT_SHIFT;\n\t\tcmd->flags |= OCRDMA_QP_PARA_ACK_TO_VALID;\n\t}\n\tif (attr_mask & IB_QP_RETRY_CNT) {\n\t\tcmd->params.rnt_rc_sl_fl |= (attrs->retry_cnt <<\n\t\t\t\t      OCRDMA_QP_PARAMS_RETRY_CNT_SHIFT) &\n\t\t    OCRDMA_QP_PARAMS_RETRY_CNT_MASK;\n\t\tcmd->flags |= OCRDMA_QP_PARA_RETRY_CNT_VALID;\n\t}\n\tif (attr_mask & IB_QP_MIN_RNR_TIMER) {\n\t\tcmd->params.rnt_rc_sl_fl |= (attrs->min_rnr_timer <<\n\t\t\t\t      OCRDMA_QP_PARAMS_RNR_NAK_TIMER_SHIFT) &\n\t\t    OCRDMA_QP_PARAMS_RNR_NAK_TIMER_MASK;\n\t\tcmd->flags |= OCRDMA_QP_PARA_RNT_VALID;\n\t}\n\tif (attr_mask & IB_QP_RNR_RETRY) {\n\t\tcmd->params.ack_to_rnr_rtc_dest_qpn |= (attrs->rnr_retry <<\n\t\t\tOCRDMA_QP_PARAMS_RNR_RETRY_CNT_SHIFT)\n\t\t\t& OCRDMA_QP_PARAMS_RNR_RETRY_CNT_MASK;\n\t\tcmd->flags |= OCRDMA_QP_PARA_RRC_VALID;\n\t}\n\tif (attr_mask & IB_QP_SQ_PSN) {\n\t\tcmd->params.tclass_sq_psn |= (attrs->sq_psn & 0x00ffffff);\n\t\tcmd->flags |= OCRDMA_QP_PARA_SQPSN_VALID;\n\t}\n\tif (attr_mask & IB_QP_RQ_PSN) {\n\t\tcmd->params.hop_lmt_rq_psn |= (attrs->rq_psn & 0x00ffffff);\n\t\tcmd->flags |= OCRDMA_QP_PARA_RQPSN_VALID;\n\t}\n\tif (attr_mask & IB_QP_MAX_QP_RD_ATOMIC) {\n\t\tif (attrs->max_rd_atomic > dev->attr.max_ord_per_qp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto pmtu_err;\n\t\t}\n\t\tqp->max_ord = attrs->max_rd_atomic;\n\t\tcmd->flags |= OCRDMA_QP_PARA_MAX_ORD_VALID;\n\t}\n\tif (attr_mask & IB_QP_MAX_DEST_RD_ATOMIC) {\n\t\tif (attrs->max_dest_rd_atomic > dev->attr.max_ird_per_qp) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto pmtu_err;\n\t\t}\n\t\tqp->max_ird = attrs->max_dest_rd_atomic;\n\t\tcmd->flags |= OCRDMA_QP_PARA_MAX_IRD_VALID;\n\t}\n\tcmd->params.max_ord_ird = (qp->max_ord <<\n\t\t\t\tOCRDMA_QP_PARAMS_MAX_ORD_SHIFT) |\n\t\t\t\t(qp->max_ird & OCRDMA_QP_PARAMS_MAX_IRD_MASK);\npmtu_err:\n\treturn status;\n}\n\nint ocrdma_mbx_modify_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp,\n\t\t\t struct ib_qp_attr *attrs, int attr_mask)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_modify_qp *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_QP, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\n\tcmd->params.id = qp->id;\n\tcmd->flags = 0;\n\tif (attr_mask & IB_QP_STATE) {\n\t\tcmd->params.max_sge_recv_flags |=\n\t\t    (get_ocrdma_qp_state(attrs->qp_state) <<\n\t\t     OCRDMA_QP_PARAMS_STATE_SHIFT) &\n\t\t    OCRDMA_QP_PARAMS_STATE_MASK;\n\t\tcmd->flags |= OCRDMA_QP_PARA_QPS_VALID;\n\t} else {\n\t\tcmd->params.max_sge_recv_flags |=\n\t\t    (qp->state << OCRDMA_QP_PARAMS_STATE_SHIFT) &\n\t\t    OCRDMA_QP_PARAMS_STATE_MASK;\n\t}\n\n\tstatus = ocrdma_set_qp_params(qp, cmd, attrs, attr_mask);\n\tif (status)\n\t\tgoto mbx_err;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\nmbx_err:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_destroy_qp(struct ocrdma_dev *dev, struct ocrdma_qp *qp)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_destroy_qp *cmd;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_QP, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->qp_id = qp->id;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\nmbx_err:\n\tkfree(cmd);\n\tif (qp->sq.va)\n\t\tdma_free_coherent(&pdev->dev, qp->sq.len, qp->sq.va, qp->sq.pa);\n\tif (!qp->srq && qp->rq.va)\n\t\tdma_free_coherent(&pdev->dev, qp->rq.len, qp->rq.va, qp->rq.pa);\n\tif (qp->dpp_enabled)\n\t\tqp->pd->num_dpp_qp++;\n\treturn status;\n}\n\nint ocrdma_mbx_create_srq(struct ocrdma_dev *dev, struct ocrdma_srq *srq,\n\t\t\t  struct ib_srq_init_attr *srq_attr,\n\t\t\t  struct ocrdma_pd *pd)\n{\n\tint status = -ENOMEM;\n\tint hw_pages, hw_page_size;\n\tint len;\n\tstruct ocrdma_create_srq_rsp *rsp;\n\tstruct ocrdma_create_srq *cmd;\n\tdma_addr_t pa;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tu32 max_rqe_allocated;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_CREATE_SRQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\n\tcmd->pgsz_pdid = pd->id & OCRDMA_CREATE_SRQ_PD_ID_MASK;\n\tmax_rqe_allocated = srq_attr->attr.max_wr + 1;\n\tstatus = ocrdma_build_q_conf(&max_rqe_allocated,\n\t\t\t\tdev->attr.rqe_size,\n\t\t\t\t&hw_pages, &hw_page_size);\n\tif (status) {\n\t\tpr_err(\"%s() req. max_wr=0x%x\\n\", __func__,\n\t\t       srq_attr->attr.max_wr);\n\t\tstatus = -EINVAL;\n\t\tgoto ret;\n\t}\n\tlen = hw_pages * hw_page_size;\n\tsrq->rq.va = dma_alloc_coherent(&pdev->dev, len, &pa, GFP_KERNEL);\n\tif (!srq->rq.va) {\n\t\tstatus = -ENOMEM;\n\t\tgoto ret;\n\t}\n\tocrdma_build_q_pages(&cmd->rq_addr[0], hw_pages, pa, hw_page_size);\n\n\tsrq->rq.entry_size = dev->attr.rqe_size;\n\tsrq->rq.pa = pa;\n\tsrq->rq.len = len;\n\tsrq->rq.max_cnt = max_rqe_allocated;\n\n\tcmd->max_sge_rqe = ilog2(max_rqe_allocated);\n\tcmd->max_sge_rqe |= srq_attr->attr.max_sge <<\n\t\t\t\tOCRDMA_CREATE_SRQ_MAX_SGE_RECV_SHIFT;\n\n\tcmd->pgsz_pdid |= (ilog2(hw_page_size / OCRDMA_MIN_Q_PAGE_SIZE)\n\t\t<< OCRDMA_CREATE_SRQ_PG_SZ_SHIFT);\n\tcmd->pages_rqe_sz |= (dev->attr.rqe_size\n\t\t<< OCRDMA_CREATE_SRQ_RQE_SIZE_SHIFT)\n\t\t& OCRDMA_CREATE_SRQ_RQE_SIZE_MASK;\n\tcmd->pages_rqe_sz |= hw_pages << OCRDMA_CREATE_SRQ_NUM_RQ_PAGES_SHIFT;\n\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\trsp = (struct ocrdma_create_srq_rsp *)cmd;\n\tsrq->id = rsp->id;\n\tsrq->rq.dbid = rsp->id;\n\tmax_rqe_allocated = ((rsp->max_sge_rqe_allocated &\n\t\tOCRDMA_CREATE_SRQ_RSP_MAX_RQE_ALLOCATED_MASK) >>\n\t\tOCRDMA_CREATE_SRQ_RSP_MAX_RQE_ALLOCATED_SHIFT);\n\tmax_rqe_allocated = (1 << max_rqe_allocated);\n\tsrq->rq.max_cnt = max_rqe_allocated;\n\tsrq->rq.max_wqe_idx = max_rqe_allocated - 1;\n\tsrq->rq.max_sges = (rsp->max_sge_rqe_allocated &\n\t\tOCRDMA_CREATE_SRQ_RSP_MAX_SGE_RECV_ALLOCATED_MASK) >>\n\t\tOCRDMA_CREATE_SRQ_RSP_MAX_SGE_RECV_ALLOCATED_SHIFT;\n\tgoto ret;\nmbx_err:\n\tdma_free_coherent(&pdev->dev, srq->rq.len, srq->rq.va, pa);\nret:\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_modify_srq(struct ocrdma_srq *srq, struct ib_srq_attr *srq_attr)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_modify_srq *cmd;\n\tstruct ocrdma_pd *pd = srq->pd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(pd->ibpd.device);\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_SRQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->id = srq->id;\n\tcmd->limit_max_rqe |= srq_attr->srq_limit <<\n\t    OCRDMA_MODIFY_SRQ_LIMIT_SHIFT;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tkfree(cmd);\n\treturn status;\n}\n\nint ocrdma_mbx_query_srq(struct ocrdma_srq *srq, struct ib_srq_attr *srq_attr)\n{\n\tint status = -ENOMEM;\n\tstruct ocrdma_query_srq *cmd;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(srq->ibsrq.device);\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_QUERY_SRQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn status;\n\tcmd->id = srq->rq.dbid;\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (status == 0) {\n\t\tstruct ocrdma_query_srq_rsp *rsp =\n\t\t    (struct ocrdma_query_srq_rsp *)cmd;\n\t\tsrq_attr->max_sge =\n\t\t    rsp->srq_lmt_max_sge &\n\t\t    OCRDMA_QUERY_SRQ_RSP_MAX_SGE_RECV_MASK;\n\t\tsrq_attr->max_wr =\n\t\t    rsp->max_rqe_pdid >> OCRDMA_QUERY_SRQ_RSP_MAX_RQE_SHIFT;\n\t\tsrq_attr->srq_limit = rsp->srq_lmt_max_sge >>\n\t\t    OCRDMA_QUERY_SRQ_RSP_SRQ_LIMIT_SHIFT;\n\t}\n\tkfree(cmd);\n\treturn status;\n}\n\nvoid ocrdma_mbx_destroy_srq(struct ocrdma_dev *dev, struct ocrdma_srq *srq)\n{\n\tstruct ocrdma_destroy_srq *cmd;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_DELETE_SRQ, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn;\n\tcmd->id = srq->id;\n\tocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\tif (srq->rq.va)\n\t\tdma_free_coherent(&pdev->dev, srq->rq.len,\n\t\t\t\t  srq->rq.va, srq->rq.pa);\n\tkfree(cmd);\n}\n\nstatic int ocrdma_mbx_get_dcbx_config(struct ocrdma_dev *dev, u32 ptype,\n\t\t\t\t      struct ocrdma_dcbx_cfg *dcbxcfg)\n{\n\tint status;\n\tdma_addr_t pa;\n\tstruct ocrdma_mqe cmd;\n\n\tstruct ocrdma_get_dcbx_cfg_req *req = NULL;\n\tstruct ocrdma_get_dcbx_cfg_rsp *rsp = NULL;\n\tstruct pci_dev *pdev = dev->nic_info.pdev;\n\tstruct ocrdma_mqe_sge *mqe_sge = cmd.u.nonemb_req.sge;\n\n\tmemset(&cmd, 0, sizeof(struct ocrdma_mqe));\n\tcmd.hdr.pyld_len = max_t (u32, sizeof(struct ocrdma_get_dcbx_cfg_rsp),\n\t\t\t\t\tsizeof(struct ocrdma_get_dcbx_cfg_req));\n\treq = dma_alloc_coherent(&pdev->dev, cmd.hdr.pyld_len, &pa, GFP_KERNEL);\n\tif (!req) {\n\t\tstatus = -ENOMEM;\n\t\tgoto mem_err;\n\t}\n\n\tcmd.hdr.spcl_sge_cnt_emb |= (1 << OCRDMA_MQE_HDR_SGE_CNT_SHIFT) &\n\t\t\t\t\tOCRDMA_MQE_HDR_SGE_CNT_MASK;\n\tmqe_sge->pa_lo = (u32) (pa & 0xFFFFFFFFUL);\n\tmqe_sge->pa_hi = (u32) upper_32_bits(pa);\n\tmqe_sge->len = cmd.hdr.pyld_len;\n\n\tocrdma_init_mch(&req->hdr, OCRDMA_CMD_GET_DCBX_CONFIG,\n\t\t\tOCRDMA_SUBSYS_DCBX, cmd.hdr.pyld_len);\n\treq->param_type = ptype;\n\n\tstatus = ocrdma_mbx_cmd(dev, &cmd);\n\tif (status)\n\t\tgoto mbx_err;\n\n\trsp = (struct ocrdma_get_dcbx_cfg_rsp *)req;\n\tocrdma_le32_to_cpu(rsp, sizeof(struct ocrdma_get_dcbx_cfg_rsp));\n\tmemcpy(dcbxcfg, &rsp->cfg, sizeof(struct ocrdma_dcbx_cfg));\n\nmbx_err:\n\tdma_free_coherent(&pdev->dev, cmd.hdr.pyld_len, req, pa);\nmem_err:\n\treturn status;\n}\n\n#define OCRDMA_MAX_SERVICE_LEVEL_INDEX\t0x08\n#define OCRDMA_DEFAULT_SERVICE_LEVEL\t0x05\n\nstatic int ocrdma_parse_dcbxcfg_rsp(struct ocrdma_dev *dev, int ptype,\n\t\t\t\t    struct ocrdma_dcbx_cfg *dcbxcfg,\n\t\t\t\t    u8 *srvc_lvl)\n{\n\tint status = -EINVAL, indx, slindx;\n\tint ventry_cnt;\n\tstruct ocrdma_app_parameter *app_param;\n\tu8 valid, proto_sel;\n\tu8 app_prio, pfc_prio;\n\tu16 proto;\n\n\tif (!(dcbxcfg->tcv_aev_opv_st & OCRDMA_DCBX_STATE_MASK)) {\n\t\tpr_info(\"%s ocrdma%d DCBX is disabled\\n\",\n\t\t\tdev_name(&dev->nic_info.pdev->dev), dev->id);\n\t\tgoto out;\n\t}\n\n\tif (!ocrdma_is_enabled_and_synced(dcbxcfg->pfc_state)) {\n\t\tpr_info(\"%s ocrdma%d priority flow control(%s) is %s%s\\n\",\n\t\t\tdev_name(&dev->nic_info.pdev->dev), dev->id,\n\t\t\t(ptype > 0 ? \"operational\" : \"admin\"),\n\t\t\t(dcbxcfg->pfc_state & OCRDMA_STATE_FLAG_ENABLED) ?\n\t\t\t\"enabled\" : \"disabled\",\n\t\t\t(dcbxcfg->pfc_state & OCRDMA_STATE_FLAG_SYNC) ?\n\t\t\t\"\" : \", not sync'ed\");\n\t\tgoto out;\n\t} else {\n\t\tpr_info(\"%s ocrdma%d priority flow control is enabled and sync'ed\\n\",\n\t\t\tdev_name(&dev->nic_info.pdev->dev), dev->id);\n\t}\n\n\tventry_cnt = (dcbxcfg->tcv_aev_opv_st >>\n\t\t\t\tOCRDMA_DCBX_APP_ENTRY_SHIFT)\n\t\t\t\t& OCRDMA_DCBX_STATE_MASK;\n\n\tfor (indx = 0; indx < ventry_cnt; indx++) {\n\t\tapp_param = &dcbxcfg->app_param[indx];\n\t\tvalid = (app_param->valid_proto_app >>\n\t\t\t\tOCRDMA_APP_PARAM_VALID_SHIFT)\n\t\t\t\t& OCRDMA_APP_PARAM_VALID_MASK;\n\t\tproto_sel = (app_param->valid_proto_app\n\t\t\t\t>>  OCRDMA_APP_PARAM_PROTO_SEL_SHIFT)\n\t\t\t\t& OCRDMA_APP_PARAM_PROTO_SEL_MASK;\n\t\tproto = app_param->valid_proto_app &\n\t\t\t\tOCRDMA_APP_PARAM_APP_PROTO_MASK;\n\n\t\tif (\n\t\t\tvalid && proto == ETH_P_IBOE &&\n\t\t\tproto_sel == OCRDMA_PROTO_SELECT_L2) {\n\t\t\tfor (slindx = 0; slindx <\n\t\t\t\tOCRDMA_MAX_SERVICE_LEVEL_INDEX; slindx++) {\n\t\t\t\tapp_prio = ocrdma_get_app_prio(\n\t\t\t\t\t\t(u8 *)app_param->app_prio,\n\t\t\t\t\t\tslindx);\n\t\t\t\tpfc_prio = ocrdma_get_pfc_prio(\n\t\t\t\t\t\t(u8 *)dcbxcfg->pfc_prio,\n\t\t\t\t\t\tslindx);\n\n\t\t\t\tif (app_prio && pfc_prio) {\n\t\t\t\t\t*srvc_lvl = slindx;\n\t\t\t\t\tstatus = 0;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (slindx == OCRDMA_MAX_SERVICE_LEVEL_INDEX) {\n\t\t\t\tpr_info(\"%s ocrdma%d application priority not set for 0x%x protocol\\n\",\n\t\t\t\t\tdev_name(&dev->nic_info.pdev->dev),\n\t\t\t\t\tdev->id, proto);\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn status;\n}\n\nvoid ocrdma_init_service_level(struct ocrdma_dev *dev)\n{\n\tint status = 0, indx;\n\tstruct ocrdma_dcbx_cfg dcbxcfg;\n\tu8 srvc_lvl = OCRDMA_DEFAULT_SERVICE_LEVEL;\n\tint ptype = OCRDMA_PARAMETER_TYPE_OPER;\n\n\tfor (indx = 0; indx < 2; indx++) {\n\t\tstatus = ocrdma_mbx_get_dcbx_config(dev, ptype, &dcbxcfg);\n\t\tif (status) {\n\t\t\tpr_err(\"%s(): status=%d\\n\", __func__, status);\n\t\t\tptype = OCRDMA_PARAMETER_TYPE_ADMIN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tstatus = ocrdma_parse_dcbxcfg_rsp(dev, ptype,\n\t\t\t\t\t\t  &dcbxcfg, &srvc_lvl);\n\t\tif (status) {\n\t\t\tptype = OCRDMA_PARAMETER_TYPE_ADMIN;\n\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (status)\n\t\tpr_info(\"%s ocrdma%d service level default\\n\",\n\t\t\tdev_name(&dev->nic_info.pdev->dev), dev->id);\n\telse\n\t\tpr_info(\"%s ocrdma%d service level %d\\n\",\n\t\t\tdev_name(&dev->nic_info.pdev->dev), dev->id,\n\t\t\tsrvc_lvl);\n\n\tdev->pfc_state = ocrdma_is_enabled_and_synced(dcbxcfg.pfc_state);\n\tdev->sl = srvc_lvl;\n}\n\nint ocrdma_alloc_av(struct ocrdma_dev *dev, struct ocrdma_ah *ah)\n{\n\tint i;\n\tint status = -EINVAL;\n\tstruct ocrdma_av *av;\n\tunsigned long flags;\n\n\tav = dev->av_tbl.va;\n\tspin_lock_irqsave(&dev->av_tbl.lock, flags);\n\tfor (i = 0; i < dev->av_tbl.num_ah; i++) {\n\t\tif (av->valid == 0) {\n\t\t\tav->valid = OCRDMA_AV_VALID;\n\t\t\tah->av = av;\n\t\t\tah->id = i;\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t\tav++;\n\t}\n\tif (i == dev->av_tbl.num_ah)\n\t\tstatus = -EAGAIN;\n\tspin_unlock_irqrestore(&dev->av_tbl.lock, flags);\n\treturn status;\n}\n\nvoid ocrdma_free_av(struct ocrdma_dev *dev, struct ocrdma_ah *ah)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&dev->av_tbl.lock, flags);\n\tah->av->valid = 0;\n\tspin_unlock_irqrestore(&dev->av_tbl.lock, flags);\n}\n\nstatic int ocrdma_create_eqs(struct ocrdma_dev *dev)\n{\n\tint num_eq, i, status = 0;\n\tint irq;\n\tunsigned long flags = 0;\n\n\tnum_eq = dev->nic_info.msix.num_vectors -\n\t\t\tdev->nic_info.msix.start_vector;\n\tif (dev->nic_info.intr_mode == BE_INTERRUPT_MODE_INTX) {\n\t\tnum_eq = 1;\n\t\tflags = IRQF_SHARED;\n\t} else {\n\t\tnum_eq = min_t(u32, num_eq, num_online_cpus());\n\t}\n\n\tif (!num_eq)\n\t\treturn -EINVAL;\n\n\tdev->eq_tbl = kcalloc(num_eq, sizeof(struct ocrdma_eq), GFP_KERNEL);\n\tif (!dev->eq_tbl)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_eq; i++) {\n\t\tstatus = ocrdma_create_eq(dev, &dev->eq_tbl[i],\n\t\t\t\t\tOCRDMA_EQ_LEN);\n\t\tif (status) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tsprintf(dev->eq_tbl[i].irq_name, \"ocrdma%d-%d\",\n\t\t\tdev->id, i);\n\t\tirq = ocrdma_get_irq(dev, &dev->eq_tbl[i]);\n\t\tstatus = request_irq(irq, ocrdma_irq_handler, flags,\n\t\t\t\t     dev->eq_tbl[i].irq_name,\n\t\t\t\t     &dev->eq_tbl[i]);\n\t\tif (status)\n\t\t\tgoto done;\n\t\tdev->eq_cnt += 1;\n\t}\n\t \n\treturn 0;\ndone:\n\tocrdma_destroy_eqs(dev);\n\treturn status;\n}\n\nstatic int ocrdma_mbx_modify_eqd(struct ocrdma_dev *dev, struct ocrdma_eq *eq,\n\t\t\t\t int num)\n{\n\tint i, status;\n\tstruct ocrdma_modify_eqd_req *cmd;\n\n\tcmd = ocrdma_init_emb_mqe(OCRDMA_CMD_MODIFY_EQ_DELAY, sizeof(*cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tocrdma_init_mch(&cmd->cmd.req, OCRDMA_CMD_MODIFY_EQ_DELAY,\n\t\t\tOCRDMA_SUBSYS_COMMON, sizeof(*cmd));\n\n\tcmd->cmd.num_eq = num;\n\tfor (i = 0; i < num; i++) {\n\t\tcmd->cmd.set_eqd[i].eq_id = eq[i].q.id;\n\t\tcmd->cmd.set_eqd[i].phase = 0;\n\t\tcmd->cmd.set_eqd[i].delay_multiplier =\n\t\t\t\t(eq[i].aic_obj.prev_eqd * 65)/100;\n\t}\n\tstatus = ocrdma_mbx_cmd(dev, (struct ocrdma_mqe *)cmd);\n\n\tkfree(cmd);\n\treturn status;\n}\n\nstatic int ocrdma_modify_eqd(struct ocrdma_dev *dev, struct ocrdma_eq *eq,\n\t\t\t     int num)\n{\n\tint num_eqs, i = 0;\n\tif (num > 8) {\n\t\twhile (num) {\n\t\t\tnum_eqs = min(num, 8);\n\t\t\tocrdma_mbx_modify_eqd(dev, &eq[i], num_eqs);\n\t\t\ti += num_eqs;\n\t\t\tnum -= num_eqs;\n\t\t}\n\t} else {\n\t\tocrdma_mbx_modify_eqd(dev, eq, num);\n\t}\n\treturn 0;\n}\n\nvoid ocrdma_eqd_set_task(struct work_struct *work)\n{\n\tstruct ocrdma_dev *dev =\n\t\tcontainer_of(work, struct ocrdma_dev, eqd_work.work);\n\tstruct ocrdma_eq *eq = NULL;\n\tint i, num = 0;\n\tu64 eq_intr;\n\n\tfor (i = 0; i < dev->eq_cnt; i++) {\n\t\teq = &dev->eq_tbl[i];\n\t\tif (eq->aic_obj.eq_intr_cnt > eq->aic_obj.prev_eq_intr_cnt) {\n\t\t\teq_intr = eq->aic_obj.eq_intr_cnt -\n\t\t\t\t  eq->aic_obj.prev_eq_intr_cnt;\n\t\t\tif ((eq_intr > EQ_INTR_PER_SEC_THRSH_HI) &&\n\t\t\t    (eq->aic_obj.prev_eqd == EQ_AIC_MIN_EQD)) {\n\t\t\t\teq->aic_obj.prev_eqd = EQ_AIC_MAX_EQD;\n\t\t\t\tnum++;\n\t\t\t} else if ((eq_intr < EQ_INTR_PER_SEC_THRSH_LOW) &&\n\t\t\t\t   (eq->aic_obj.prev_eqd == EQ_AIC_MAX_EQD)) {\n\t\t\t\teq->aic_obj.prev_eqd = EQ_AIC_MIN_EQD;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t\teq->aic_obj.prev_eq_intr_cnt = eq->aic_obj.eq_intr_cnt;\n\t}\n\n\tif (num)\n\t\tocrdma_modify_eqd(dev, &dev->eq_tbl[0], num);\n\tschedule_delayed_work(&dev->eqd_work, msecs_to_jiffies(1000));\n}\n\nint ocrdma_init_hw(struct ocrdma_dev *dev)\n{\n\tint status;\n\n\t \n\tstatus = ocrdma_create_eqs(dev);\n\tif (status)\n\t\tgoto qpeq_err;\n\tstatus = ocrdma_create_mq(dev);\n\tif (status)\n\t\tgoto mq_err;\n\tstatus = ocrdma_mbx_query_fw_config(dev);\n\tif (status)\n\t\tgoto conf_err;\n\tstatus = ocrdma_mbx_query_dev(dev);\n\tif (status)\n\t\tgoto conf_err;\n\tstatus = ocrdma_mbx_query_fw_ver(dev);\n\tif (status)\n\t\tgoto conf_err;\n\tstatus = ocrdma_mbx_create_ah_tbl(dev);\n\tif (status)\n\t\tgoto conf_err;\n\tstatus = ocrdma_mbx_get_phy_info(dev);\n\tif (status)\n\t\tgoto info_attrb_err;\n\tstatus = ocrdma_mbx_get_ctrl_attribs(dev);\n\tif (status)\n\t\tgoto info_attrb_err;\n\n\treturn 0;\n\ninfo_attrb_err:\n\tocrdma_mbx_delete_ah_tbl(dev);\nconf_err:\n\tocrdma_destroy_mq(dev);\nmq_err:\n\tocrdma_destroy_eqs(dev);\nqpeq_err:\n\tpr_err(\"%s() status=%d\\n\", __func__, status);\n\treturn status;\n}\n\nvoid ocrdma_cleanup_hw(struct ocrdma_dev *dev)\n{\n\tocrdma_free_pd_pool(dev);\n\tocrdma_mbx_delete_ah_tbl(dev);\n\n\t \n\tocrdma_destroy_mq(dev);\n\n\t \n\tocrdma_destroy_eqs(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}