{
  "module_name": "ocrdma_main.c",
  "hash_id": "507bfe7df6e48ace5cf7852649919ae208423e5dff17d94479d0d0fd3122971d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/ocrdma/ocrdma_main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_mad.h>\n\n#include <linux/netdevice.h>\n#include <net/addrconf.h>\n\n#include \"ocrdma.h\"\n#include \"ocrdma_verbs.h\"\n#include \"ocrdma_ah.h\"\n#include \"be_roce.h\"\n#include \"ocrdma_hw.h\"\n#include \"ocrdma_stats.h\"\n#include <rdma/ocrdma-abi.h>\n\nMODULE_DESCRIPTION(OCRDMA_ROCE_DRV_DESC \" \" OCRDMA_ROCE_DRV_VERSION);\nMODULE_AUTHOR(\"Emulex Corporation\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic enum rdma_link_layer ocrdma_link_layer(struct ib_device *device,\n\t\t\t\t\t      u32 port_num)\n{\n\treturn IB_LINK_LAYER_ETHERNET;\n}\n\nstatic int ocrdma_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t         struct ib_port_immutable *immutable)\n{\n\tstruct ib_port_attr attr;\n\tstruct ocrdma_dev *dev;\n\tint err;\n\n\tdev = get_ocrdma_dev(ibdev);\n\timmutable->core_cap_flags = RDMA_CORE_PORT_IBA_ROCE;\n\tif (ocrdma_is_udp_encap_supported(dev))\n\t\timmutable->core_cap_flags |= RDMA_CORE_CAP_PROT_ROCE_UDP_ENCAP;\n\n\terr = ib_query_port(ibdev, port_num, &attr);\n\tif (err)\n\t\treturn err;\n\n\timmutable->pkey_tbl_len = attr.pkey_tbl_len;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\timmutable->max_mad_size = IB_MGMT_MAD_SIZE;\n\n\treturn 0;\n}\n\nstatic void get_dev_fw_str(struct ib_device *device, char *str)\n{\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(device);\n\n\tsnprintf(str, IB_FW_VERSION_NAME_MAX, \"%s\", &dev->attr.fw_ver[0]);\n}\n\n \nstatic ssize_t hw_rev_show(struct device *device,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ocrdma_dev *dev =\n\t\trdma_device_to_drv_device(device, struct ocrdma_dev, ibdev);\n\n\treturn sysfs_emit(buf, \"0x%x\\n\", dev->nic_info.pdev->vendor);\n}\nstatic DEVICE_ATTR_RO(hw_rev);\n\nstatic ssize_t hca_type_show(struct device *device,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct ocrdma_dev *dev =\n\t\trdma_device_to_drv_device(device, struct ocrdma_dev, ibdev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", &dev->model_number[0]);\n}\nstatic DEVICE_ATTR_RO(hca_type);\n\nstatic struct attribute *ocrdma_attributes[] = {\n\t&dev_attr_hw_rev.attr,\n\t&dev_attr_hca_type.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ocrdma_attr_group = {\n\t.attrs = ocrdma_attributes,\n};\n\nstatic const struct ib_device_ops ocrdma_dev_ops = {\n\t.owner = THIS_MODULE,\n\t.driver_id = RDMA_DRIVER_OCRDMA,\n\t.uverbs_abi_ver = OCRDMA_ABI_VERSION,\n\n\t.alloc_mr = ocrdma_alloc_mr,\n\t.alloc_pd = ocrdma_alloc_pd,\n\t.alloc_ucontext = ocrdma_alloc_ucontext,\n\t.create_ah = ocrdma_create_ah,\n\t.create_cq = ocrdma_create_cq,\n\t.create_qp = ocrdma_create_qp,\n\t.create_user_ah = ocrdma_create_ah,\n\t.dealloc_pd = ocrdma_dealloc_pd,\n\t.dealloc_ucontext = ocrdma_dealloc_ucontext,\n\t.dereg_mr = ocrdma_dereg_mr,\n\t.destroy_ah = ocrdma_destroy_ah,\n\t.destroy_cq = ocrdma_destroy_cq,\n\t.destroy_qp = ocrdma_destroy_qp,\n\t.device_group = &ocrdma_attr_group,\n\t.get_dev_fw_str = get_dev_fw_str,\n\t.get_dma_mr = ocrdma_get_dma_mr,\n\t.get_link_layer = ocrdma_link_layer,\n\t.get_port_immutable = ocrdma_port_immutable,\n\t.map_mr_sg = ocrdma_map_mr_sg,\n\t.mmap = ocrdma_mmap,\n\t.modify_qp = ocrdma_modify_qp,\n\t.poll_cq = ocrdma_poll_cq,\n\t.post_recv = ocrdma_post_recv,\n\t.post_send = ocrdma_post_send,\n\t.process_mad = ocrdma_process_mad,\n\t.query_ah = ocrdma_query_ah,\n\t.query_device = ocrdma_query_device,\n\t.query_pkey = ocrdma_query_pkey,\n\t.query_port = ocrdma_query_port,\n\t.query_qp = ocrdma_query_qp,\n\t.reg_user_mr = ocrdma_reg_user_mr,\n\t.req_notify_cq = ocrdma_arm_cq,\n\t.resize_cq = ocrdma_resize_cq,\n\n\tINIT_RDMA_OBJ_SIZE(ib_ah, ocrdma_ah, ibah),\n\tINIT_RDMA_OBJ_SIZE(ib_cq, ocrdma_cq, ibcq),\n\tINIT_RDMA_OBJ_SIZE(ib_pd, ocrdma_pd, ibpd),\n\tINIT_RDMA_OBJ_SIZE(ib_qp, ocrdma_qp, ibqp),\n\tINIT_RDMA_OBJ_SIZE(ib_ucontext, ocrdma_ucontext, ibucontext),\n};\n\nstatic const struct ib_device_ops ocrdma_dev_srq_ops = {\n\t.create_srq = ocrdma_create_srq,\n\t.destroy_srq = ocrdma_destroy_srq,\n\t.modify_srq = ocrdma_modify_srq,\n\t.post_srq_recv = ocrdma_post_srq_recv,\n\t.query_srq = ocrdma_query_srq,\n\n\tINIT_RDMA_OBJ_SIZE(ib_srq, ocrdma_srq, ibsrq),\n};\n\nstatic int ocrdma_register_device(struct ocrdma_dev *dev)\n{\n\tint ret;\n\n\taddrconf_addr_eui48((u8 *)&dev->ibdev.node_guid,\n\t\t\t    dev->nic_info.mac_addr);\n\tBUILD_BUG_ON(sizeof(OCRDMA_NODE_DESC) > IB_DEVICE_NODE_DESC_MAX);\n\tmemcpy(dev->ibdev.node_desc, OCRDMA_NODE_DESC,\n\t       sizeof(OCRDMA_NODE_DESC));\n\n\tdev->ibdev.node_type = RDMA_NODE_IB_CA;\n\tdev->ibdev.phys_port_cnt = 1;\n\tdev->ibdev.num_comp_vectors = dev->eq_cnt;\n\n\t \n\tdev->ibdev.dev.parent = &dev->nic_info.pdev->dev;\n\n\tib_set_device_ops(&dev->ibdev, &ocrdma_dev_ops);\n\n\tif (ocrdma_get_asic_type(dev) == OCRDMA_ASIC_GEN_SKH_R)\n\t\tib_set_device_ops(&dev->ibdev, &ocrdma_dev_srq_ops);\n\n\tret = ib_device_set_netdev(&dev->ibdev, dev->nic_info.netdev, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tdma_set_max_seg_size(&dev->nic_info.pdev->dev, UINT_MAX);\n\treturn ib_register_device(&dev->ibdev, \"ocrdma%d\",\n\t\t\t\t  &dev->nic_info.pdev->dev);\n}\n\nstatic int ocrdma_alloc_resources(struct ocrdma_dev *dev)\n{\n\tmutex_init(&dev->dev_lock);\n\tdev->cq_tbl = kcalloc(OCRDMA_MAX_CQ, sizeof(struct ocrdma_cq *),\n\t\t\t      GFP_KERNEL);\n\tif (!dev->cq_tbl)\n\t\tgoto alloc_err;\n\n\tif (dev->attr.max_qp) {\n\t\tdev->qp_tbl = kcalloc(OCRDMA_MAX_QP,\n\t\t\t\t      sizeof(struct ocrdma_qp *),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!dev->qp_tbl)\n\t\t\tgoto alloc_err;\n\t}\n\n\tdev->stag_arr = kcalloc(OCRDMA_MAX_STAG, sizeof(u64), GFP_KERNEL);\n\tif (dev->stag_arr == NULL)\n\t\tgoto alloc_err;\n\n\tocrdma_alloc_pd_pool(dev);\n\n\tif (!ocrdma_alloc_stats_resources(dev)) {\n\t\tpr_err(\"%s: stats resource allocation failed\\n\", __func__);\n\t\tgoto alloc_err;\n\t}\n\n\tspin_lock_init(&dev->av_tbl.lock);\n\tspin_lock_init(&dev->flush_q_lock);\n\treturn 0;\nalloc_err:\n\tpr_err(\"%s(%d) error.\\n\", __func__, dev->id);\n\treturn -ENOMEM;\n}\n\nstatic void ocrdma_free_resources(struct ocrdma_dev *dev)\n{\n\tocrdma_release_stats_resources(dev);\n\tkfree(dev->stag_arr);\n\tkfree(dev->qp_tbl);\n\tkfree(dev->cq_tbl);\n}\n\nstatic struct ocrdma_dev *ocrdma_add(struct be_dev_info *dev_info)\n{\n\tint status = 0;\n\tu8 lstate = 0;\n\tstruct ocrdma_dev *dev;\n\n\tdev = ib_alloc_device(ocrdma_dev, ibdev);\n\tif (!dev) {\n\t\tpr_err(\"Unable to allocate ib device\\n\");\n\t\treturn NULL;\n\t}\n\n\tdev->mbx_cmd = kzalloc(sizeof(struct ocrdma_mqe_emb_cmd), GFP_KERNEL);\n\tif (!dev->mbx_cmd)\n\t\tgoto init_err;\n\n\tmemcpy(&dev->nic_info, dev_info, sizeof(*dev_info));\n\tdev->id = PCI_FUNC(dev->nic_info.pdev->devfn);\n\tstatus = ocrdma_init_hw(dev);\n\tif (status)\n\t\tgoto init_err;\n\n\tstatus = ocrdma_alloc_resources(dev);\n\tif (status)\n\t\tgoto alloc_err;\n\n\tocrdma_init_service_level(dev);\n\tstatus = ocrdma_register_device(dev);\n\tif (status)\n\t\tgoto alloc_err;\n\n\t \n\tstatus = ocrdma_mbx_get_link_speed(dev, NULL, &lstate);\n\tif (!status)\n\t\tocrdma_update_link_state(dev, lstate);\n\n\t \n\tocrdma_add_port_stats(dev);\n\t \n\tINIT_DELAYED_WORK(&dev->eqd_work, ocrdma_eqd_set_task);\n\tschedule_delayed_work(&dev->eqd_work, msecs_to_jiffies(1000));\n\n\tpr_info(\"%s %s: %s \\\"%s\\\" port %d\\n\",\n\t\tdev_name(&dev->nic_info.pdev->dev), hca_name(dev),\n\t\tport_speed_string(dev), dev->model_number,\n\t\tdev->hba_port_num);\n\tpr_info(\"%s ocrdma%d driver loaded successfully\\n\",\n\t\tdev_name(&dev->nic_info.pdev->dev), dev->id);\n\treturn dev;\n\nalloc_err:\n\tocrdma_free_resources(dev);\n\tocrdma_cleanup_hw(dev);\ninit_err:\n\tkfree(dev->mbx_cmd);\n\tib_dealloc_device(&dev->ibdev);\n\tpr_err(\"%s() leaving. ret=%d\\n\", __func__, status);\n\treturn NULL;\n}\n\nstatic void ocrdma_remove_free(struct ocrdma_dev *dev)\n{\n\n\tkfree(dev->mbx_cmd);\n\tib_dealloc_device(&dev->ibdev);\n}\n\nstatic void ocrdma_remove(struct ocrdma_dev *dev)\n{\n\t \n\tcancel_delayed_work_sync(&dev->eqd_work);\n\tib_unregister_device(&dev->ibdev);\n\n\tocrdma_rem_port_stats(dev);\n\tocrdma_free_resources(dev);\n\tocrdma_cleanup_hw(dev);\n\tocrdma_remove_free(dev);\n}\n\nstatic int ocrdma_dispatch_port_active(struct ocrdma_dev *dev)\n{\n\tstruct ib_event port_event;\n\n\tport_event.event = IB_EVENT_PORT_ACTIVE;\n\tport_event.element.port_num = 1;\n\tport_event.device = &dev->ibdev;\n\tib_dispatch_event(&port_event);\n\treturn 0;\n}\n\nstatic int ocrdma_dispatch_port_error(struct ocrdma_dev *dev)\n{\n\tstruct ib_event err_event;\n\n\terr_event.event = IB_EVENT_PORT_ERR;\n\terr_event.element.port_num = 1;\n\terr_event.device = &dev->ibdev;\n\tib_dispatch_event(&err_event);\n\treturn 0;\n}\n\nstatic void ocrdma_shutdown(struct ocrdma_dev *dev)\n{\n\tocrdma_dispatch_port_error(dev);\n\tocrdma_remove(dev);\n}\n\n \nstatic void ocrdma_event_handler(struct ocrdma_dev *dev, u32 event)\n{\n\tswitch (event) {\n\tcase BE_DEV_SHUTDOWN:\n\t\tocrdma_shutdown(dev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ocrdma_update_link_state(struct ocrdma_dev *dev, u8 lstate)\n{\n\tif (!(dev->flags & OCRDMA_FLAGS_LINK_STATUS_INIT)) {\n\t\tdev->flags |= OCRDMA_FLAGS_LINK_STATUS_INIT;\n\t\tif (!lstate)\n\t\t\treturn;\n\t}\n\n\tif (!lstate)\n\t\tocrdma_dispatch_port_error(dev);\n\telse\n\t\tocrdma_dispatch_port_active(dev);\n}\n\nstatic struct ocrdma_driver ocrdma_drv = {\n\t.name\t\t\t= \"ocrdma_driver\",\n\t.add\t\t\t= ocrdma_add,\n\t.remove\t\t\t= ocrdma_remove,\n\t.state_change_handler\t= ocrdma_event_handler,\n\t.be_abi_version\t\t= OCRDMA_BE_ROCE_ABI_VERSION,\n};\n\nstatic int __init ocrdma_init_module(void)\n{\n\tint status;\n\n\tocrdma_init_debugfs();\n\n\tstatus = be_roce_register_driver(&ocrdma_drv);\n\tif (status)\n\t\tgoto err_be_reg;\n\n\treturn 0;\n\nerr_be_reg:\n\n\treturn status;\n}\n\nstatic void __exit ocrdma_exit_module(void)\n{\n\tbe_roce_unregister_driver(&ocrdma_drv);\n\tocrdma_rem_debugfs();\n}\n\nmodule_init(ocrdma_init_module);\nmodule_exit(ocrdma_exit_module);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}