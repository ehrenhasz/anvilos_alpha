{
  "module_name": "ocrdma_stats.c",
  "hash_id": "73be9a2ee668f1bb988fe77f576beb658a9349828e824f49a68e6bfa4129b6fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/ocrdma/ocrdma_stats.c",
  "human_readable_source": " \n\n#include <rdma/ib_addr.h>\n#include <rdma/ib_pma.h>\n#include \"ocrdma_stats.h\"\n\nstatic struct dentry *ocrdma_dbgfs_dir;\n\nstatic int ocrdma_add_stat(char *start, char *pcur,\n\t\t\t\tchar *name, u64 count)\n{\n\tchar buff[128] = {0};\n\tint cpy_len = 0;\n\n\tsnprintf(buff, 128, \"%s: %llu\\n\", name, count);\n\tcpy_len = strlen(buff);\n\n\tif (pcur + cpy_len > start + OCRDMA_MAX_DBGFS_MEM) {\n\t\tpr_err(\"%s: No space in stats buff\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tmemcpy(pcur, buff, cpy_len);\n\treturn cpy_len;\n}\n\nbool ocrdma_alloc_stats_resources(struct ocrdma_dev *dev)\n{\n\tstruct stats_mem *mem = &dev->stats_mem;\n\n\tmutex_init(&dev->stats_lock);\n\t \n\tmem->size = max_t(u32, sizeof(struct ocrdma_rdma_stats_req),\n\t\t\tsizeof(struct ocrdma_rdma_stats_resp));\n\n\tmem->va = dma_alloc_coherent(&dev->nic_info.pdev->dev, mem->size,\n\t\t\t\t     &mem->pa, GFP_KERNEL);\n\tif (!mem->va) {\n\t\tpr_err(\"%s: stats mbox allocation failed\\n\", __func__);\n\t\treturn false;\n\t}\n\n\t \n\tmem->debugfs_mem = kzalloc(OCRDMA_MAX_DBGFS_MEM, GFP_KERNEL);\n\tif (!mem->debugfs_mem)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid ocrdma_release_stats_resources(struct ocrdma_dev *dev)\n{\n\tstruct stats_mem *mem = &dev->stats_mem;\n\n\tif (mem->va)\n\t\tdma_free_coherent(&dev->nic_info.pdev->dev, mem->size,\n\t\t\t\t  mem->va, mem->pa);\n\tmem->va = NULL;\n\tkfree(mem->debugfs_mem);\n}\n\nstatic char *ocrdma_resource_stats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rsrc_stats *rsrc_stats = &rdma_stats->act_rsrc_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_dpp_pds\",\n\t\t\t\t(u64)rsrc_stats->dpp_pds);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_non_dpp_pds\",\n\t\t\t\t(u64)rsrc_stats->non_dpp_pds);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_rc_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->rc_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_uc_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->uc_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_ud_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->ud_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_rc_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->rc_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_uc_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->uc_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_ud_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->ud_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_srqs\",\n\t\t\t\t(u64)rsrc_stats->srqs);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_rbqs\",\n\t\t\t\t(u64)rsrc_stats->rbqs);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_64K_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64K_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_64K_to_2M_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64K_to_2M_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_2M_to_44M_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r2M_to_44M_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_44M_to_1G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r44M_to_1G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_1G_to_4G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r1G_to_4G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_nsmr_count_4G_to_32G\",\n\t\t\t\t(u64)rsrc_stats->nsmr_count_4G_to_32G);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_32G_to_64G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r32G_to_64G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_64G_to_128G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64G_to_128G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_128G_to_higher_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r128G_to_higher_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_embedded_nsmr\",\n\t\t\t\t(u64)rsrc_stats->embedded_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_frmr\",\n\t\t\t\t(u64)rsrc_stats->frmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_prefetch_qps\",\n\t\t\t\t(u64)rsrc_stats->prefetch_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_ondemand_qps\",\n\t\t\t\t(u64)rsrc_stats->ondemand_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_phy_mr\",\n\t\t\t\t(u64)rsrc_stats->phy_mr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"active_mw\",\n\t\t\t\t(u64)rsrc_stats->mw);\n\n\t \n\trsrc_stats = &rdma_stats->th_rsrc_stats;\n\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_dpp_pds\",\n\t\t\t\t(u64)rsrc_stats->dpp_pds);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_non_dpp_pds\",\n\t\t\t\t(u64)rsrc_stats->non_dpp_pds);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_rc_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->rc_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_uc_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->uc_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_ud_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->ud_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_rc_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->rc_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_uc_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->uc_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_ud_non_dpp_qps\",\n\t\t\t\t(u64)rsrc_stats->ud_non_dpp_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_srqs\",\n\t\t\t\t(u64)rsrc_stats->srqs);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_rbqs\",\n\t\t\t\t(u64)rsrc_stats->rbqs);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_64K_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64K_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_64K_to_2M_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64K_to_2M_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_2M_to_44M_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r2M_to_44M_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_44M_to_1G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r44M_to_1G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_1G_to_4G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r1G_to_4G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_nsmr_count_4G_to_32G\",\n\t\t\t\t(u64)rsrc_stats->nsmr_count_4G_to_32G);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_32G_to_64G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r32G_to_64G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_64G_to_128G_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r64G_to_128G_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_128G_to_higher_nsmr\",\n\t\t\t\t(u64)rsrc_stats->r128G_to_higher_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_embedded_nsmr\",\n\t\t\t\t(u64)rsrc_stats->embedded_nsmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_frmr\",\n\t\t\t\t(u64)rsrc_stats->frmr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_prefetch_qps\",\n\t\t\t\t(u64)rsrc_stats->prefetch_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_ondemand_qps\",\n\t\t\t\t(u64)rsrc_stats->ondemand_qps);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_phy_mr\",\n\t\t\t\t(u64)rsrc_stats->phy_mr);\n\tpcur += ocrdma_add_stat(stats, pcur, \"threshold_mw\",\n\t\t\t\t(u64)rsrc_stats->mw);\n\treturn stats;\n}\n\nstatic char *ocrdma_rx_stats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rx_stats *rx_stats = &rdma_stats->rx_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat\n\t\t(stats, pcur, \"roce_frame_bytes\",\n\t\t convert_to_64bit(rx_stats->roce_frame_bytes_lo,\n\t\t rx_stats->roce_frame_bytes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"roce_frame_icrc_drops\",\n\t\t\t\t(u64)rx_stats->roce_frame_icrc_drops);\n\tpcur += ocrdma_add_stat(stats, pcur, \"roce_frame_payload_len_drops\",\n\t\t\t\t(u64)rx_stats->roce_frame_payload_len_drops);\n\tpcur += ocrdma_add_stat(stats, pcur, \"ud_drops\",\n\t\t\t\t(u64)rx_stats->ud_drops);\n\tpcur += ocrdma_add_stat(stats, pcur, \"qp1_drops\",\n\t\t\t\t(u64)rx_stats->qp1_drops);\n\tpcur += ocrdma_add_stat(stats, pcur, \"psn_error_request_packets\",\n\t\t\t\t(u64)rx_stats->psn_error_request_packets);\n\tpcur += ocrdma_add_stat(stats, pcur, \"psn_error_resp_packets\",\n\t\t\t\t(u64)rx_stats->psn_error_resp_packets);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rnr_nak_timeouts\",\n\t\t\t\t(u64)rx_stats->rnr_nak_timeouts);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rnr_nak_receives\",\n\t\t\t\t(u64)rx_stats->rnr_nak_receives);\n\tpcur += ocrdma_add_stat(stats, pcur, \"roce_frame_rxmt_drops\",\n\t\t\t\t(u64)rx_stats->roce_frame_rxmt_drops);\n\tpcur += ocrdma_add_stat(stats, pcur, \"nak_count_psn_sequence_errors\",\n\t\t\t\t(u64)rx_stats->nak_count_psn_sequence_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rc_drop_count_lookup_errors\",\n\t\t\t\t(u64)rx_stats->rc_drop_count_lookup_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rq_rnr_naks\",\n\t\t\t\t(u64)rx_stats->rq_rnr_naks);\n\tpcur += ocrdma_add_stat(stats, pcur, \"srq_rnr_naks\",\n\t\t\t\t(u64)rx_stats->srq_rnr_naks);\n\tpcur += ocrdma_add_stat(stats, pcur, \"roce_frames\",\n\t\t\t\tconvert_to_64bit(rx_stats->roce_frames_lo,\n\t\t\t\t\t\t rx_stats->roce_frames_hi));\n\n\treturn stats;\n}\n\nstatic u64 ocrdma_sysfs_rcv_pkts(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rx_stats *rx_stats = &rdma_stats->rx_stats;\n\n\treturn convert_to_64bit(rx_stats->roce_frames_lo,\n\t\trx_stats->roce_frames_hi) + (u64)rx_stats->roce_frame_icrc_drops\n\t\t+ (u64)rx_stats->roce_frame_payload_len_drops;\n}\n\nstatic u64 ocrdma_sysfs_rcv_data(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rx_stats *rx_stats = &rdma_stats->rx_stats;\n\n\treturn (convert_to_64bit(rx_stats->roce_frame_bytes_lo,\n\t\trx_stats->roce_frame_bytes_hi))/4;\n}\n\nstatic char *ocrdma_tx_stats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_tx_stats *tx_stats = &rdma_stats->tx_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"send_pkts\",\n\t\t\t\tconvert_to_64bit(tx_stats->send_pkts_lo,\n\t\t\t\t\t\t tx_stats->send_pkts_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"write_pkts\",\n\t\t\t\tconvert_to_64bit(tx_stats->write_pkts_lo,\n\t\t\t\t\t\t tx_stats->write_pkts_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"read_pkts\",\n\t\t\t\tconvert_to_64bit(tx_stats->read_pkts_lo,\n\t\t\t\t\t\t tx_stats->read_pkts_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"read_rsp_pkts\",\n\t\t\t\tconvert_to_64bit(tx_stats->read_rsp_pkts_lo,\n\t\t\t\t\t\t tx_stats->read_rsp_pkts_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"ack_pkts\",\n\t\t\t\tconvert_to_64bit(tx_stats->ack_pkts_lo,\n\t\t\t\t\t\t tx_stats->ack_pkts_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"send_bytes\",\n\t\t\t\tconvert_to_64bit(tx_stats->send_bytes_lo,\n\t\t\t\t\t\t tx_stats->send_bytes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"write_bytes\",\n\t\t\t\tconvert_to_64bit(tx_stats->write_bytes_lo,\n\t\t\t\t\t\t tx_stats->write_bytes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"read_req_bytes\",\n\t\t\t\tconvert_to_64bit(tx_stats->read_req_bytes_lo,\n\t\t\t\t\t\t tx_stats->read_req_bytes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"read_rsp_bytes\",\n\t\t\t\tconvert_to_64bit(tx_stats->read_rsp_bytes_lo,\n\t\t\t\t\t\t tx_stats->read_rsp_bytes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"ack_timeouts\",\n\t\t\t\t(u64)tx_stats->ack_timeouts);\n\n\treturn stats;\n}\n\nstatic u64 ocrdma_sysfs_xmit_pkts(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_tx_stats *tx_stats = &rdma_stats->tx_stats;\n\n\treturn (convert_to_64bit(tx_stats->send_pkts_lo,\n\t\t\t\t tx_stats->send_pkts_hi) +\n\tconvert_to_64bit(tx_stats->write_pkts_lo, tx_stats->write_pkts_hi) +\n\tconvert_to_64bit(tx_stats->read_pkts_lo, tx_stats->read_pkts_hi) +\n\tconvert_to_64bit(tx_stats->read_rsp_pkts_lo,\n\t\t\t tx_stats->read_rsp_pkts_hi) +\n\tconvert_to_64bit(tx_stats->ack_pkts_lo, tx_stats->ack_pkts_hi));\n}\n\nstatic u64 ocrdma_sysfs_xmit_data(struct ocrdma_dev *dev)\n{\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_tx_stats *tx_stats = &rdma_stats->tx_stats;\n\n\treturn (convert_to_64bit(tx_stats->send_bytes_lo,\n\t\t\t\t tx_stats->send_bytes_hi) +\n\t\tconvert_to_64bit(tx_stats->write_bytes_lo,\n\t\t\t\t tx_stats->write_bytes_hi) +\n\t\tconvert_to_64bit(tx_stats->read_req_bytes_lo,\n\t\t\t\t tx_stats->read_req_bytes_hi) +\n\t\tconvert_to_64bit(tx_stats->read_rsp_bytes_lo,\n\t\t\t\t tx_stats->read_rsp_bytes_hi))/4;\n}\n\nstatic char *ocrdma_wqe_stats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_wqe_stats\t*wqe_stats = &rdma_stats->wqe_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"large_send_rc_wqes\",\n\t\tconvert_to_64bit(wqe_stats->large_send_rc_wqes_lo,\n\t\t\t\t wqe_stats->large_send_rc_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"large_write_rc_wqes\",\n\t\tconvert_to_64bit(wqe_stats->large_write_rc_wqes_lo,\n\t\t\t\t wqe_stats->large_write_rc_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"read_wqes\",\n\t\t\t\tconvert_to_64bit(wqe_stats->read_wqes_lo,\n\t\t\t\t\t\t wqe_stats->read_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"frmr_wqes\",\n\t\t\t\tconvert_to_64bit(wqe_stats->frmr_wqes_lo,\n\t\t\t\t\t\t wqe_stats->frmr_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"mw_bind_wqes\",\n\t\t\t\tconvert_to_64bit(wqe_stats->mw_bind_wqes_lo,\n\t\t\t\t\t\t wqe_stats->mw_bind_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"invalidate_wqes\",\n\t\tconvert_to_64bit(wqe_stats->invalidate_wqes_lo,\n\t\t\t\t wqe_stats->invalidate_wqes_hi));\n\tpcur += ocrdma_add_stat(stats, pcur, \"dpp_wqe_drops\",\n\t\t\t\t(u64)wqe_stats->dpp_wqe_drops);\n\treturn stats;\n}\n\nstatic char *ocrdma_db_errstats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_db_err_stats *db_err_stats = &rdma_stats->db_err_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"sq_doorbell_errors\",\n\t\t\t\t(u64)db_err_stats->sq_doorbell_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cq_doorbell_errors\",\n\t\t\t\t(u64)db_err_stats->cq_doorbell_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rq_srq_doorbell_errors\",\n\t\t\t\t(u64)db_err_stats->rq_srq_doorbell_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cq_overflow_errors\",\n\t\t\t\t(u64)db_err_stats->cq_overflow_errors);\n\treturn stats;\n}\n\nstatic char *ocrdma_rxqp_errstats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rx_qp_err_stats *rx_qp_err_stats =\n\t\t &rdma_stats->rx_qp_err_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"nak_invalid_request_errors\",\n\t\t\t(u64)rx_qp_err_stats->nak_invalid_request_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"nak_remote_operation_errors\",\n\t\t\t(u64)rx_qp_err_stats->nak_remote_operation_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"nak_count_remote_access_errors\",\n\t\t\t(u64)rx_qp_err_stats->nak_count_remote_access_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_length_errors\",\n\t\t\t(u64)rx_qp_err_stats->local_length_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_protection_errors\",\n\t\t\t(u64)rx_qp_err_stats->local_protection_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_qp_operation_errors\",\n\t\t\t(u64)rx_qp_err_stats->local_qp_operation_errors);\n\treturn stats;\n}\n\nstatic char *ocrdma_txqp_errstats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_tx_qp_err_stats *tx_qp_err_stats =\n\t\t&rdma_stats->tx_qp_err_stats;\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_length_errors\",\n\t\t\t(u64)tx_qp_err_stats->local_length_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_protection_errors\",\n\t\t\t(u64)tx_qp_err_stats->local_protection_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"local_qp_operation_errors\",\n\t\t\t(u64)tx_qp_err_stats->local_qp_operation_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"retry_count_exceeded_errors\",\n\t\t\t(u64)tx_qp_err_stats->retry_count_exceeded_errors);\n\tpcur += ocrdma_add_stat(stats, pcur, \"rnr_retry_count_exceeded_errors\",\n\t\t\t(u64)tx_qp_err_stats->rnr_retry_count_exceeded_errors);\n\treturn stats;\n}\n\nstatic char *ocrdma_tx_dbg_stats(struct ocrdma_dev *dev)\n{\n\tint i;\n\tchar *pstats = dev->stats_mem.debugfs_mem;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_tx_dbg_stats *tx_dbg_stats =\n\t\t&rdma_stats->tx_dbg_stats;\n\n\tmemset(pstats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tfor (i = 0; i < 100; i++)\n\t\tpstats += snprintf(pstats, 80, \"DW[%d] = 0x%x\\n\", i,\n\t\t\t\t tx_dbg_stats->data[i]);\n\n\treturn dev->stats_mem.debugfs_mem;\n}\n\nstatic char *ocrdma_rx_dbg_stats(struct ocrdma_dev *dev)\n{\n\tint i;\n\tchar *pstats = dev->stats_mem.debugfs_mem;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t(struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rx_dbg_stats *rx_dbg_stats =\n\t\t&rdma_stats->rx_dbg_stats;\n\n\tmemset(pstats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tfor (i = 0; i < 200; i++)\n\t\tpstats += snprintf(pstats, 80, \"DW[%d] = 0x%x\\n\", i,\n\t\t\t\t rx_dbg_stats->data[i]);\n\n\treturn dev->stats_mem.debugfs_mem;\n}\n\nstatic char *ocrdma_driver_dbg_stats(struct ocrdma_dev *dev)\n{\n\tchar *stats = dev->stats_mem.debugfs_mem, *pcur;\n\n\n\tmemset(stats, 0, (OCRDMA_MAX_DBGFS_MEM));\n\n\tpcur = stats;\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_cq_err\",\n\t\t\t\t(u64)(dev->async_err_stats\n\t\t\t\t[OCRDMA_CQ_ERROR].counter));\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_cq_overrun_err\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_CQ_OVERRUN_ERROR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_cq_qpcat_err\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_CQ_QPCAT_ERROR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_qp_access_err\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_QP_ACCESS_ERROR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_qp_commm_est_evt\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_QP_COMM_EST_EVENT].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_sq_drained_evt\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_SQ_DRAINED_EVENT].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_dev_fatal_evt\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_DEVICE_FATAL_EVENT].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_srqcat_err\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_SRQCAT_ERROR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_srq_limit_evt\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_SRQ_LIMIT_EVENT].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"async_qp_last_wqe_evt\",\n\t\t\t\t(u64)dev->async_err_stats\n\t\t\t\t[OCRDMA_QP_LAST_WQE_EVENT].counter);\n\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_len_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_LEN_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_qp_op_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_QP_OP_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_eec_op_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_EEC_OP_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_prot_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_PROT_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_wr_flush_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_WR_FLUSH_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_mw_bind_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_MW_BIND_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_bad_resp_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_BAD_RESP_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_access_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_ACCESS_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rem_inv_req_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_REM_INV_REQ_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rem_access_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_REM_ACCESS_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rem_op_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_REM_OP_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_retry_exc_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_RETRY_EXC_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rnr_retry_exc_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_RNR_RETRY_EXC_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_loc_rdd_viol_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_LOC_RDD_VIOL_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rem_inv_rd_req_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_REM_INV_RD_REQ_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_rem_abort_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_REM_ABORT_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_inv_eecn_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_INV_EECN_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_inv_eec_state_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_INV_EEC_STATE_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_fatal_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_FATAL_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_resp_timeout_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_RESP_TIMEOUT_ERR].counter);\n\tpcur += ocrdma_add_stat(stats, pcur, \"cqe_general_err\",\n\t\t\t\t(u64)dev->cqe_err_stats\n\t\t\t\t[OCRDMA_CQE_GENERAL_ERR].counter);\n\treturn stats;\n}\n\nstatic void ocrdma_update_stats(struct ocrdma_dev *dev)\n{\n\tulong now = jiffies, secs;\n\tint status;\n\tstruct ocrdma_rdma_stats_resp *rdma_stats =\n\t\t      (struct ocrdma_rdma_stats_resp *)dev->stats_mem.va;\n\tstruct ocrdma_rsrc_stats *rsrc_stats = &rdma_stats->act_rsrc_stats;\n\n\tsecs = jiffies_to_msecs(now - dev->last_stats_time) / 1000U;\n\tif (secs) {\n\t\t \n\t\tstatus = ocrdma_mbx_rdma_stats(dev, false);\n\t\tif (status)\n\t\t\tpr_err(\"%s: stats mbox failed with status = %d\\n\",\n\t\t\t       __func__, status);\n\t\t \n\t\tif (dev->pd_mgr->pd_prealloc_valid) {\n\t\t\trsrc_stats->dpp_pds = dev->pd_mgr->pd_dpp_count;\n\t\t\trsrc_stats->non_dpp_pds = dev->pd_mgr->pd_norm_count;\n\t\t\t \n\t\t\trsrc_stats = &rdma_stats->th_rsrc_stats;\n\t\t\trsrc_stats->dpp_pds = dev->pd_mgr->pd_dpp_thrsh;\n\t\t\trsrc_stats->non_dpp_pds = dev->pd_mgr->pd_norm_thrsh;\n\t\t}\n\t\tdev->last_stats_time = jiffies;\n\t}\n}\n\nstatic ssize_t ocrdma_dbgfs_ops_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar tmp_str[32];\n\tlong reset;\n\tint status;\n\tstruct ocrdma_stats *pstats = filp->private_data;\n\tstruct ocrdma_dev *dev = pstats->dev;\n\n\tif (*ppos != 0 || count == 0 || count > sizeof(tmp_str))\n\t\tgoto err;\n\n\tif (copy_from_user(tmp_str, buffer, count))\n\t\tgoto err;\n\n\ttmp_str[count-1] = '\\0';\n\tif (kstrtol(tmp_str, 10, &reset))\n\t\tgoto err;\n\n\tswitch (pstats->type) {\n\tcase OCRDMA_RESET_STATS:\n\t\tif (reset) {\n\t\t\tstatus = ocrdma_mbx_rdma_stats(dev, true);\n\t\t\tif (status) {\n\t\t\t\tpr_err(\"Failed to reset stats = %d\\n\", status);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\treturn count;\nerr:\n\treturn -EFAULT;\n}\n\nvoid ocrdma_pma_counters(struct ocrdma_dev *dev, struct ib_mad *out_mad)\n{\n\tstruct ib_pma_portcounters *pma_cnt;\n\n\tpma_cnt = (void *)(out_mad->data + 40);\n\tocrdma_update_stats(dev);\n\n\tpma_cnt->port_xmit_data    = cpu_to_be32(ocrdma_sysfs_xmit_data(dev));\n\tpma_cnt->port_rcv_data     = cpu_to_be32(ocrdma_sysfs_rcv_data(dev));\n\tpma_cnt->port_xmit_packets = cpu_to_be32(ocrdma_sysfs_xmit_pkts(dev));\n\tpma_cnt->port_rcv_packets  = cpu_to_be32(ocrdma_sysfs_rcv_pkts(dev));\n}\n\nstatic ssize_t ocrdma_dbgfs_ops_read(struct file *filp, char __user *buffer,\n\t\t\t\t\tsize_t usr_buf_len, loff_t *ppos)\n{\n\tstruct ocrdma_stats *pstats = filp->private_data;\n\tstruct ocrdma_dev *dev = pstats->dev;\n\tssize_t status = 0;\n\tchar *data = NULL;\n\n\t \n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tmutex_lock(&dev->stats_lock);\n\n\tocrdma_update_stats(dev);\n\n\tswitch (pstats->type) {\n\tcase OCRDMA_RSRC_STATS:\n\t\tdata = ocrdma_resource_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_RXSTATS:\n\t\tdata = ocrdma_rx_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_WQESTATS:\n\t\tdata = ocrdma_wqe_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_TXSTATS:\n\t\tdata = ocrdma_tx_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_DB_ERRSTATS:\n\t\tdata = ocrdma_db_errstats(dev);\n\t\tbreak;\n\tcase OCRDMA_RXQP_ERRSTATS:\n\t\tdata = ocrdma_rxqp_errstats(dev);\n\t\tbreak;\n\tcase OCRDMA_TXQP_ERRSTATS:\n\t\tdata = ocrdma_txqp_errstats(dev);\n\t\tbreak;\n\tcase OCRDMA_TX_DBG_STATS:\n\t\tdata = ocrdma_tx_dbg_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_RX_DBG_STATS:\n\t\tdata = ocrdma_rx_dbg_stats(dev);\n\t\tbreak;\n\tcase OCRDMA_DRV_STATS:\n\t\tdata = ocrdma_driver_dbg_stats(dev);\n\t\tbreak;\n\n\tdefault:\n\t\tstatus = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tif (usr_buf_len < strlen(data)) {\n\t\tstatus = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\tstatus = simple_read_from_buffer(buffer, usr_buf_len, ppos, data,\n\t\t\t\t\t strlen(data));\nexit:\n\tmutex_unlock(&dev->stats_lock);\n\treturn status;\n}\n\nstatic const struct file_operations ocrdma_dbg_ops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.read = ocrdma_dbgfs_ops_read,\n\t.write = ocrdma_dbgfs_ops_write,\n};\n\nvoid ocrdma_add_port_stats(struct ocrdma_dev *dev)\n{\n\tconst struct pci_dev *pdev = dev->nic_info.pdev;\n\n\tif (!ocrdma_dbgfs_dir)\n\t\treturn;\n\n\t \n\tdev->dir = debugfs_create_dir(pci_name(pdev), ocrdma_dbgfs_dir);\n\n\tdev->rsrc_stats.type = OCRDMA_RSRC_STATS;\n\tdev->rsrc_stats.dev = dev;\n\tdebugfs_create_file(\"resource_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->rsrc_stats, &ocrdma_dbg_ops);\n\n\tdev->rx_stats.type = OCRDMA_RXSTATS;\n\tdev->rx_stats.dev = dev;\n\tdebugfs_create_file(\"rx_stats\", S_IRUSR, dev->dir, &dev->rx_stats,\n\t\t\t    &ocrdma_dbg_ops);\n\n\tdev->wqe_stats.type = OCRDMA_WQESTATS;\n\tdev->wqe_stats.dev = dev;\n\tdebugfs_create_file(\"wqe_stats\", S_IRUSR, dev->dir, &dev->wqe_stats,\n\t\t\t    &ocrdma_dbg_ops);\n\n\tdev->tx_stats.type = OCRDMA_TXSTATS;\n\tdev->tx_stats.dev = dev;\n\tdebugfs_create_file(\"tx_stats\", S_IRUSR, dev->dir, &dev->tx_stats,\n\t\t\t    &ocrdma_dbg_ops);\n\n\tdev->db_err_stats.type = OCRDMA_DB_ERRSTATS;\n\tdev->db_err_stats.dev = dev;\n\tdebugfs_create_file(\"db_err_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->db_err_stats, &ocrdma_dbg_ops);\n\n\tdev->tx_qp_err_stats.type = OCRDMA_TXQP_ERRSTATS;\n\tdev->tx_qp_err_stats.dev = dev;\n\tdebugfs_create_file(\"tx_qp_err_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->tx_qp_err_stats, &ocrdma_dbg_ops);\n\n\tdev->rx_qp_err_stats.type = OCRDMA_RXQP_ERRSTATS;\n\tdev->rx_qp_err_stats.dev = dev;\n\tdebugfs_create_file(\"rx_qp_err_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->rx_qp_err_stats, &ocrdma_dbg_ops);\n\n\tdev->tx_dbg_stats.type = OCRDMA_TX_DBG_STATS;\n\tdev->tx_dbg_stats.dev = dev;\n\tdebugfs_create_file(\"tx_dbg_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->tx_dbg_stats, &ocrdma_dbg_ops);\n\n\tdev->rx_dbg_stats.type = OCRDMA_RX_DBG_STATS;\n\tdev->rx_dbg_stats.dev = dev;\n\tdebugfs_create_file(\"rx_dbg_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->rx_dbg_stats, &ocrdma_dbg_ops);\n\n\tdev->driver_stats.type = OCRDMA_DRV_STATS;\n\tdev->driver_stats.dev = dev;\n\tdebugfs_create_file(\"driver_dbg_stats\", S_IRUSR, dev->dir,\n\t\t\t    &dev->driver_stats, &ocrdma_dbg_ops);\n\n\tdev->reset_stats.type = OCRDMA_RESET_STATS;\n\tdev->reset_stats.dev = dev;\n\tdebugfs_create_file(\"reset_stats\", 0200, dev->dir, &dev->reset_stats,\n\t\t\t    &ocrdma_dbg_ops);\n}\n\nvoid ocrdma_rem_port_stats(struct ocrdma_dev *dev)\n{\n\tdebugfs_remove_recursive(dev->dir);\n}\n\nvoid ocrdma_init_debugfs(void)\n{\n\t \n\tocrdma_dbgfs_dir = debugfs_create_dir(\"ocrdma\", NULL);\n}\n\nvoid ocrdma_rem_debugfs(void)\n{\n\tdebugfs_remove_recursive(ocrdma_dbgfs_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}