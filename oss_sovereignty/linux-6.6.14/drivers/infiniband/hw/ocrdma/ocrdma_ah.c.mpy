{
  "module_name": "ocrdma_ah.c",
  "hash_id": "3b3177c7f2612269e055654517424af1ade2e765359cca3a3586f2a44848fa50",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/hw/ocrdma/ocrdma_ah.c",
  "human_readable_source": " \n\n#include <net/neighbour.h>\n#include <net/netevent.h>\n\n#include <rdma/ib_addr.h>\n#include <rdma/ib_mad.h>\n#include <rdma/ib_cache.h>\n\n#include \"ocrdma.h\"\n#include \"ocrdma_verbs.h\"\n#include \"ocrdma_ah.h\"\n#include \"ocrdma_hw.h\"\n#include \"ocrdma_stats.h\"\n\n#define OCRDMA_VID_PCP_SHIFT\t0xD\n\nstatic u16 ocrdma_hdr_type_to_proto_num(int devid, u8 hdr_type)\n{\n\tswitch (hdr_type) {\n\tcase OCRDMA_L3_TYPE_IB_GRH:\n\t\treturn (u16)ETH_P_IBOE;\n\tcase OCRDMA_L3_TYPE_IPV4:\n\t\treturn (u16)0x0800;\n\tcase OCRDMA_L3_TYPE_IPV6:\n\t\treturn (u16)0x86dd;\n\tdefault:\n\t\tpr_err(\"ocrdma%d: Invalid network header\\n\", devid);\n\t\treturn 0;\n\t}\n}\n\nstatic inline int set_av_attr(struct ocrdma_dev *dev, struct ocrdma_ah *ah,\n\t\t\tstruct rdma_ah_attr *attr, const union ib_gid *sgid,\n\t\t\tint pdid, bool *isvlan, u16 vlan_tag)\n{\n\tint status;\n\tstruct ocrdma_eth_vlan eth;\n\tstruct ocrdma_grh grh;\n\tint eth_sz;\n\tu16 proto_num = 0;\n\tu8 nxthdr = 0x11;\n\tstruct iphdr ipv4;\n\tconst struct ib_global_route *ib_grh;\n\tunion {\n\t\tstruct sockaddr_in  _sockaddr_in;\n\t\tstruct sockaddr_in6 _sockaddr_in6;\n\t} sgid_addr, dgid_addr;\n\n\tmemset(&eth, 0, sizeof(eth));\n\tmemset(&grh, 0, sizeof(grh));\n\n\t \n\tproto_num = ocrdma_hdr_type_to_proto_num(dev->id, ah->hdr_type);\n\tif (!proto_num)\n\t\treturn -EINVAL;\n\tnxthdr = (proto_num == ETH_P_IBOE) ? 0x1b : 0x11;\n\t \n\tif (!vlan_tag || (vlan_tag > 0xFFF))\n\t\tvlan_tag = dev->pvid;\n\tif (vlan_tag || dev->pfc_state) {\n\t\tif (!vlan_tag) {\n\t\t\tpr_err(\"ocrdma%d:Using VLAN with PFC is recommended\\n\",\n\t\t\t\tdev->id);\n\t\t\tpr_err(\"ocrdma%d:Using VLAN 0 for this connection\\n\",\n\t\t\t\tdev->id);\n\t\t}\n\t\teth.eth_type = cpu_to_be16(0x8100);\n\t\teth.roce_eth_type = cpu_to_be16(proto_num);\n\t\tvlan_tag |= (dev->sl & 0x07) << OCRDMA_VID_PCP_SHIFT;\n\t\teth.vlan_tag = cpu_to_be16(vlan_tag);\n\t\teth_sz = sizeof(struct ocrdma_eth_vlan);\n\t\t*isvlan = true;\n\t} else {\n\t\teth.eth_type = cpu_to_be16(proto_num);\n\t\teth_sz = sizeof(struct ocrdma_eth_basic);\n\t}\n\t \n\tmemcpy(&eth.smac[0], &dev->nic_info.mac_addr[0], ETH_ALEN);\n\tstatus = ocrdma_resolve_dmac(dev, attr, &eth.dmac[0]);\n\tif (status)\n\t\treturn status;\n\tib_grh = rdma_ah_read_grh(attr);\n\tah->sgid_index = ib_grh->sgid_index;\n\t \n\tmemcpy(&ah->av->eth_hdr, &eth, eth_sz);\n\tif (ah->hdr_type == RDMA_NETWORK_IPV4) {\n\t\t*((__be16 *)&ipv4) = htons((4 << 12) | (5 << 8) |\n\t\t\t\t\t   ib_grh->traffic_class);\n\t\tipv4.id = cpu_to_be16(pdid);\n\t\tipv4.frag_off = htons(IP_DF);\n\t\tipv4.tot_len = htons(0);\n\t\tipv4.ttl = ib_grh->hop_limit;\n\t\tipv4.protocol = nxthdr;\n\t\trdma_gid2ip((struct sockaddr *)&sgid_addr, sgid);\n\t\tipv4.saddr = sgid_addr._sockaddr_in.sin_addr.s_addr;\n\t\trdma_gid2ip((struct sockaddr*)&dgid_addr, &ib_grh->dgid);\n\t\tipv4.daddr = dgid_addr._sockaddr_in.sin_addr.s_addr;\n\t\tmemcpy((u8 *)ah->av + eth_sz, &ipv4, sizeof(struct iphdr));\n\t} else {\n\t\tmemcpy(&grh.sgid[0], sgid->raw, sizeof(union ib_gid));\n\t\tgrh.tclass_flow = cpu_to_be32((6 << 28) |\n\t\t\t\t\t      (ib_grh->traffic_class << 24) |\n\t\t\t\t\t      ib_grh->flow_label);\n\t\tmemcpy(&grh.dgid[0], ib_grh->dgid.raw,\n\t\t       sizeof(ib_grh->dgid.raw));\n\t\tgrh.pdid_hoplimit = cpu_to_be32((pdid << 16) |\n\t\t\t\t\t\t(nxthdr << 8) |\n\t\t\t\t\t\tib_grh->hop_limit);\n\t\tmemcpy((u8 *)ah->av + eth_sz, &grh, sizeof(struct ocrdma_grh));\n\t}\n\tif (*isvlan)\n\t\tah->av->valid |= OCRDMA_AV_VLAN_VALID;\n\tah->av->valid = cpu_to_le32(ah->av->valid);\n\treturn status;\n}\n\nint ocrdma_create_ah(struct ib_ah *ibah, struct rdma_ah_init_attr *init_attr,\n\t\t     struct ib_udata *udata)\n{\n\tu32 *ahid_addr;\n\tint status;\n\tstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\n\tbool isvlan = false;\n\tu16 vlan_tag = 0xffff;\n\tconst struct ib_gid_attr *sgid_attr;\n\tstruct ocrdma_pd *pd = get_ocrdma_pd(ibah->pd);\n\tstruct rdma_ah_attr *attr = init_attr->ah_attr;\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(ibah->device);\n\n\tif ((attr->type != RDMA_AH_ATTR_TYPE_ROCE) ||\n\t    !(rdma_ah_get_ah_flags(attr) & IB_AH_GRH))\n\t\treturn -EINVAL;\n\n\tif (atomic_cmpxchg(&dev->update_sl, 1, 0))\n\t\tocrdma_init_service_level(dev);\n\n\tsgid_attr = attr->grh.sgid_attr;\n\tstatus = rdma_read_gid_l2_fields(sgid_attr, &vlan_tag, NULL);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ocrdma_alloc_av(dev, ah);\n\tif (status)\n\t\tgoto av_err;\n\n\t \n\tah->hdr_type = rdma_gid_attr_network_type(sgid_attr);\n\n\tstatus = set_av_attr(dev, ah, attr, &sgid_attr->gid, pd->id,\n\t\t\t     &isvlan, vlan_tag);\n\tif (status)\n\t\tgoto av_conf_err;\n\n\t \n\tif ((pd->uctx) && (pd->uctx->ah_tbl.va)) {\n\t\tahid_addr = pd->uctx->ah_tbl.va + rdma_ah_get_dlid(attr);\n\t\t*ahid_addr = 0;\n\t\t*ahid_addr |= ah->id & OCRDMA_AH_ID_MASK;\n\t\tif (ocrdma_is_udp_encap_supported(dev)) {\n\t\t\t*ahid_addr |= ((u32)ah->hdr_type &\n\t\t\t\t       OCRDMA_AH_L3_TYPE_MASK) <<\n\t\t\t\t       OCRDMA_AH_L3_TYPE_SHIFT;\n\t\t}\n\t\tif (isvlan)\n\t\t\t*ahid_addr |= (OCRDMA_AH_VLAN_VALID_MASK <<\n\t\t\t\t       OCRDMA_AH_VLAN_VALID_SHIFT);\n\t}\n\n\treturn 0;\n\nav_conf_err:\n\tocrdma_free_av(dev, ah);\nav_err:\n\treturn status;\n}\n\nint ocrdma_destroy_ah(struct ib_ah *ibah, u32 flags)\n{\n\tstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\n\tstruct ocrdma_dev *dev = get_ocrdma_dev(ibah->device);\n\n\tocrdma_free_av(dev, ah);\n\treturn 0;\n}\n\nint ocrdma_query_ah(struct ib_ah *ibah, struct rdma_ah_attr *attr)\n{\n\tstruct ocrdma_ah *ah = get_ocrdma_ah(ibah);\n\tstruct ocrdma_av *av = ah->av;\n\tstruct ocrdma_grh *grh;\n\n\tattr->type = ibah->type;\n\tif (ah->av->valid & OCRDMA_AV_VALID) {\n\t\tgrh = (struct ocrdma_grh *)((u8 *)ah->av +\n\t\t\t\tsizeof(struct ocrdma_eth_vlan));\n\t\trdma_ah_set_sl(attr, be16_to_cpu(av->eth_hdr.vlan_tag) >> 13);\n\t} else {\n\t\tgrh = (struct ocrdma_grh *)((u8 *)ah->av +\n\t\t\t\t\tsizeof(struct ocrdma_eth_basic));\n\t\trdma_ah_set_sl(attr, 0);\n\t}\n\trdma_ah_set_grh(attr, NULL,\n\t\t\tbe32_to_cpu(grh->tclass_flow) & 0xffffffff,\n\t\t\tah->sgid_index,\n\t\t\tbe32_to_cpu(grh->pdid_hoplimit) & 0xff,\n\t\t\tbe32_to_cpu(grh->tclass_flow) >> 24);\n\trdma_ah_set_dgid_raw(attr, &grh->dgid[0]);\n\treturn 0;\n}\n\nint ocrdma_process_mad(struct ib_device *ibdev, int process_mad_flags,\n\t\t       u32 port_num, const struct ib_wc *in_wc,\n\t\t       const struct ib_grh *in_grh, const struct ib_mad *in,\n\t\t       struct ib_mad *out, size_t *out_mad_size,\n\t\t       u16 *out_mad_pkey_index)\n{\n\tint status = IB_MAD_RESULT_SUCCESS;\n\tstruct ocrdma_dev *dev;\n\n\tif (in->mad_hdr.mgmt_class == IB_MGMT_CLASS_PERF_MGMT) {\n\t\tdev = get_ocrdma_dev(ibdev);\n\t\tocrdma_pma_counters(dev, out);\n\t\tstatus |= IB_MAD_RESULT_REPLY;\n\t}\n\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}