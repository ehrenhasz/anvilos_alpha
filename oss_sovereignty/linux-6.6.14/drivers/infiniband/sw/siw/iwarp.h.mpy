{
  "module_name": "iwarp.h",
  "hash_id": "a32cac6135a78e6e1aba4fcba76f5222103f522d9af69bfb289c71f9b6d0dc2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/iwarp.h",
  "human_readable_source": " \n\n \n \n\n#ifndef _IWARP_H\n#define _IWARP_H\n\n#include <rdma/rdma_user_cm.h>  \n#include <linux/types.h>\n#include <asm/byteorder.h>\n\n#define RDMAP_VERSION 1\n#define DDP_VERSION 1\n#define MPA_REVISION_1 1\n#define MPA_REVISION_2 2\n#define MPA_MAX_PRIVDATA RDMA_MAX_PRIVATE_DATA\n#define MPA_KEY_REQ \"MPA ID Req Frame\"\n#define MPA_KEY_REP \"MPA ID Rep Frame\"\n#define MPA_IRD_ORD_MASK 0x3fff\n\nstruct mpa_rr_params {\n\t__be16 bits;\n\t__be16 pd_len;\n};\n\n \nenum {\n\tMPA_RR_FLAG_MARKERS = cpu_to_be16(0x8000),\n\tMPA_RR_FLAG_CRC = cpu_to_be16(0x4000),\n\tMPA_RR_FLAG_REJECT = cpu_to_be16(0x2000),\n\tMPA_RR_FLAG_ENHANCED = cpu_to_be16(0x1000),\n\tMPA_RR_FLAG_GSO_EXP = cpu_to_be16(0x0800),\n\tMPA_RR_MASK_REVISION = cpu_to_be16(0x00ff)\n};\n\n \nstruct mpa_rr {\n\t__u8 key[16];\n\tstruct mpa_rr_params params;\n};\n\nstatic inline void __mpa_rr_set_revision(__be16 *bits, u8 rev)\n{\n\t*bits = (*bits & ~MPA_RR_MASK_REVISION) |\n\t\t(cpu_to_be16(rev) & MPA_RR_MASK_REVISION);\n}\n\nstatic inline u8 __mpa_rr_revision(__be16 mpa_rr_bits)\n{\n\t__be16 rev = mpa_rr_bits & MPA_RR_MASK_REVISION;\n\n\treturn be16_to_cpu(rev);\n}\n\nenum mpa_v2_ctrl {\n\tMPA_V2_PEER_TO_PEER = cpu_to_be16(0x8000),\n\tMPA_V2_ZERO_LENGTH_RTR = cpu_to_be16(0x4000),\n\tMPA_V2_RDMA_WRITE_RTR = cpu_to_be16(0x8000),\n\tMPA_V2_RDMA_READ_RTR = cpu_to_be16(0x4000),\n\tMPA_V2_RDMA_NO_RTR = cpu_to_be16(0x0000),\n\tMPA_V2_MASK_IRD_ORD = cpu_to_be16(0x3fff)\n};\n\nstruct mpa_v2_data {\n\t__be16 ird;\n\t__be16 ord;\n};\n\nstruct mpa_marker {\n\t__be16 rsvd;\n\t__be16 fpdu_hmd;  \n};\n\n \nstruct mpa_trailer {\n\t__u8 pad[4];\n\t__be32 crc;\n};\n\n#define MPA_HDR_SIZE 2\n#define MPA_CRC_SIZE 4\n\n \nstruct iwarp_ctrl {\n\t__be16 mpa_len;\n\t__be16 ddp_rdmap_ctrl;\n};\n\n \nenum {\n\tDDP_FLAG_TAGGED = cpu_to_be16(0x8000),\n\tDDP_FLAG_LAST = cpu_to_be16(0x4000),\n\tDDP_MASK_RESERVED = cpu_to_be16(0x3C00),\n\tDDP_MASK_VERSION = cpu_to_be16(0x0300),\n\tRDMAP_MASK_VERSION = cpu_to_be16(0x00C0),\n\tRDMAP_MASK_RESERVED = cpu_to_be16(0x0030),\n\tRDMAP_MASK_OPCODE = cpu_to_be16(0x000f)\n};\n\nstatic inline u8 __ddp_get_version(struct iwarp_ctrl *ctrl)\n{\n\treturn be16_to_cpu(ctrl->ddp_rdmap_ctrl & DDP_MASK_VERSION) >> 8;\n}\n\nstatic inline u8 __rdmap_get_version(struct iwarp_ctrl *ctrl)\n{\n\t__be16 ver = ctrl->ddp_rdmap_ctrl & RDMAP_MASK_VERSION;\n\n\treturn be16_to_cpu(ver) >> 6;\n}\n\nstatic inline u8 __rdmap_get_opcode(struct iwarp_ctrl *ctrl)\n{\n\treturn be16_to_cpu(ctrl->ddp_rdmap_ctrl & RDMAP_MASK_OPCODE);\n}\n\nstatic inline void __rdmap_set_opcode(struct iwarp_ctrl *ctrl, u8 opcode)\n{\n\tctrl->ddp_rdmap_ctrl = (ctrl->ddp_rdmap_ctrl & ~RDMAP_MASK_OPCODE) |\n\t\t\t       (cpu_to_be16(opcode) & RDMAP_MASK_OPCODE);\n}\n\nstruct iwarp_rdma_write {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 sink_stag;\n\t__be64 sink_to;\n};\n\nstruct iwarp_rdma_rreq {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 rsvd;\n\t__be32 ddp_qn;\n\t__be32 ddp_msn;\n\t__be32 ddp_mo;\n\t__be32 sink_stag;\n\t__be64 sink_to;\n\t__be32 read_size;\n\t__be32 source_stag;\n\t__be64 source_to;\n};\n\nstruct iwarp_rdma_rresp {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 sink_stag;\n\t__be64 sink_to;\n};\n\nstruct iwarp_send {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 rsvd;\n\t__be32 ddp_qn;\n\t__be32 ddp_msn;\n\t__be32 ddp_mo;\n};\n\nstruct iwarp_send_inv {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 inval_stag;\n\t__be32 ddp_qn;\n\t__be32 ddp_msn;\n\t__be32 ddp_mo;\n};\n\nstruct iwarp_terminate {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 rsvd;\n\t__be32 ddp_qn;\n\t__be32 ddp_msn;\n\t__be32 ddp_mo;\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\t__be32 layer : 4;\n\t__be32 etype : 4;\n\t__be32 ecode : 8;\n\t__be32 flag_m : 1;\n\t__be32 flag_d : 1;\n\t__be32 flag_r : 1;\n\t__be32 reserved : 13;\n#elif defined(__BIG_ENDIAN_BITFIELD)\n\t__be32 reserved : 13;\n\t__be32 flag_r : 1;\n\t__be32 flag_d : 1;\n\t__be32 flag_m : 1;\n\t__be32 ecode : 8;\n\t__be32 etype : 4;\n\t__be32 layer : 4;\n#else\n#error \"undefined byte order\"\n#endif\n};\n\n \nenum {\n\tTERM_MASK_LAYER = cpu_to_be32(0xf0000000),\n\tTERM_MASK_ETYPE = cpu_to_be32(0x0f000000),\n\tTERM_MASK_ECODE = cpu_to_be32(0x00ff0000),\n\tTERM_FLAG_M = cpu_to_be32(0x00008000),\n\tTERM_FLAG_D = cpu_to_be32(0x00004000),\n\tTERM_FLAG_R = cpu_to_be32(0x00002000),\n\tTERM_MASK_RESVD = cpu_to_be32(0x00001fff)\n};\n\nstatic inline u8 __rdmap_term_layer(struct iwarp_terminate *term)\n{\n\treturn term->layer;\n}\n\nstatic inline void __rdmap_term_set_layer(struct iwarp_terminate *term,\n\t\t\t\t\t  u8 layer)\n{\n\tterm->layer = layer & 0xf;\n}\n\nstatic inline u8 __rdmap_term_etype(struct iwarp_terminate *term)\n{\n\treturn term->etype;\n}\n\nstatic inline void __rdmap_term_set_etype(struct iwarp_terminate *term,\n\t\t\t\t\t  u8 etype)\n{\n\tterm->etype = etype & 0xf;\n}\n\nstatic inline u8 __rdmap_term_ecode(struct iwarp_terminate *term)\n{\n\treturn term->ecode;\n}\n\nstatic inline void __rdmap_term_set_ecode(struct iwarp_terminate *term,\n\t\t\t\t\t  u8 ecode)\n{\n\tterm->ecode = ecode;\n}\n\n \nstruct iwarp_ctrl_untagged {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 rsvd;\n\t__be32 ddp_qn;\n\t__be32 ddp_msn;\n\t__be32 ddp_mo;\n};\n\n \nstruct iwarp_ctrl_tagged {\n\tstruct iwarp_ctrl ctrl;\n\t__be32 ddp_stag;\n\t__be64 ddp_to;\n};\n\nunion iwarp_hdr {\n\tstruct iwarp_ctrl ctrl;\n\tstruct iwarp_ctrl_untagged c_untagged;\n\tstruct iwarp_ctrl_tagged c_tagged;\n\tstruct iwarp_rdma_write rwrite;\n\tstruct iwarp_rdma_rreq rreq;\n\tstruct iwarp_rdma_rresp rresp;\n\tstruct iwarp_terminate terminate;\n\tstruct iwarp_send send;\n\tstruct iwarp_send_inv send_inv;\n};\n\nenum term_elayer {\n\tTERM_ERROR_LAYER_RDMAP = 0x00,\n\tTERM_ERROR_LAYER_DDP = 0x01,\n\tTERM_ERROR_LAYER_LLP = 0x02  \n};\n\nenum ddp_etype {\n\tDDP_ETYPE_CATASTROPHIC = 0x0,\n\tDDP_ETYPE_TAGGED_BUF = 0x1,\n\tDDP_ETYPE_UNTAGGED_BUF = 0x2,\n\tDDP_ETYPE_RSVD = 0x3\n};\n\nenum ddp_ecode {\n\t \n\tDDP_ECODE_CATASTROPHIC = 0x00,\n\t \n\tDDP_ECODE_T_INVALID_STAG = 0x00,\n\tDDP_ECODE_T_BASE_BOUNDS = 0x01,\n\tDDP_ECODE_T_STAG_NOT_ASSOC = 0x02,\n\tDDP_ECODE_T_TO_WRAP = 0x03,\n\tDDP_ECODE_T_VERSION = 0x04,\n\t \n\tDDP_ECODE_UT_INVALID_QN = 0x01,\n\tDDP_ECODE_UT_INVALID_MSN_NOBUF = 0x02,\n\tDDP_ECODE_UT_INVALID_MSN_RANGE = 0x03,\n\tDDP_ECODE_UT_INVALID_MO = 0x04,\n\tDDP_ECODE_UT_MSG_TOOLONG = 0x05,\n\tDDP_ECODE_UT_VERSION = 0x06\n};\n\nenum rdmap_untagged_qn {\n\tRDMAP_UNTAGGED_QN_SEND = 0,\n\tRDMAP_UNTAGGED_QN_RDMA_READ = 1,\n\tRDMAP_UNTAGGED_QN_TERMINATE = 2,\n\tRDMAP_UNTAGGED_QN_COUNT = 3\n};\n\nenum rdmap_etype {\n\tRDMAP_ETYPE_CATASTROPHIC = 0x0,\n\tRDMAP_ETYPE_REMOTE_PROTECTION = 0x1,\n\tRDMAP_ETYPE_REMOTE_OPERATION = 0x2\n};\n\nenum rdmap_ecode {\n\tRDMAP_ECODE_INVALID_STAG = 0x00,\n\tRDMAP_ECODE_BASE_BOUNDS = 0x01,\n\tRDMAP_ECODE_ACCESS_RIGHTS = 0x02,\n\tRDMAP_ECODE_STAG_NOT_ASSOC = 0x03,\n\tRDMAP_ECODE_TO_WRAP = 0x04,\n\tRDMAP_ECODE_VERSION = 0x05,\n\tRDMAP_ECODE_OPCODE = 0x06,\n\tRDMAP_ECODE_CATASTROPHIC_STREAM = 0x07,\n\tRDMAP_ECODE_CATASTROPHIC_GLOBAL = 0x08,\n\tRDMAP_ECODE_CANNOT_INVALIDATE = 0x09,\n\tRDMAP_ECODE_UNSPECIFIED = 0xff\n};\n\nenum llp_ecode {\n\tLLP_ECODE_TCP_STREAM_LOST = 0x01,  \n\tLLP_ECODE_RECEIVED_CRC = 0x02,\n\tLLP_ECODE_FPDU_START = 0x03,\n\tLLP_ECODE_INVALID_REQ_RESP = 0x04,\n\n\t \n\tLLP_ECODE_LOCAL_CATASTROPHIC = 0x05,\n\tLLP_ECODE_INSUFFICIENT_IRD = 0x06,\n\tLLP_ECODE_NO_MATCHING_RTR = 0x07\n};\n\nenum llp_etype { LLP_ETYPE_MPA = 0x00 };\n\nenum rdma_opcode {\n\tRDMAP_RDMA_WRITE = 0x0,\n\tRDMAP_RDMA_READ_REQ = 0x1,\n\tRDMAP_RDMA_READ_RESP = 0x2,\n\tRDMAP_SEND = 0x3,\n\tRDMAP_SEND_INVAL = 0x4,\n\tRDMAP_SEND_SE = 0x5,\n\tRDMAP_SEND_SE_INVAL = 0x6,\n\tRDMAP_TERMINATE = 0x7,\n\tRDMAP_NOT_SUPPORTED = RDMAP_TERMINATE + 1\n};\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}