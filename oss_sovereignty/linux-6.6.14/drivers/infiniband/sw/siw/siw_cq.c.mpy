{
  "module_name": "siw_cq.c",
  "hash_id": "a593339057516b620d41a4913652cc8343007277ca594e177b3dbc663d907b6b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_cq.c",
  "human_readable_source": "\n\n \n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n\n#include <rdma/ib_verbs.h>\n\n#include \"siw.h\"\n\nstatic int map_wc_opcode[SIW_NUM_OPCODES] = {\n\t[SIW_OP_WRITE] = IB_WC_RDMA_WRITE,\n\t[SIW_OP_SEND] = IB_WC_SEND,\n\t[SIW_OP_SEND_WITH_IMM] = IB_WC_SEND,\n\t[SIW_OP_READ] = IB_WC_RDMA_READ,\n\t[SIW_OP_READ_LOCAL_INV] = IB_WC_RDMA_READ,\n\t[SIW_OP_COMP_AND_SWAP] = IB_WC_COMP_SWAP,\n\t[SIW_OP_FETCH_AND_ADD] = IB_WC_FETCH_ADD,\n\t[SIW_OP_INVAL_STAG] = IB_WC_LOCAL_INV,\n\t[SIW_OP_REG_MR] = IB_WC_REG_MR,\n\t[SIW_OP_RECEIVE] = IB_WC_RECV,\n\t[SIW_OP_READ_RESPONSE] = -1  \n};\n\nstatic struct {\n\tenum siw_wc_status siw;\n\tenum ib_wc_status ib;\n} map_cqe_status[SIW_NUM_WC_STATUS] = {\n\t{ SIW_WC_SUCCESS, IB_WC_SUCCESS },\n\t{ SIW_WC_LOC_LEN_ERR, IB_WC_LOC_LEN_ERR },\n\t{ SIW_WC_LOC_PROT_ERR, IB_WC_LOC_PROT_ERR },\n\t{ SIW_WC_LOC_QP_OP_ERR, IB_WC_LOC_QP_OP_ERR },\n\t{ SIW_WC_WR_FLUSH_ERR, IB_WC_WR_FLUSH_ERR },\n\t{ SIW_WC_BAD_RESP_ERR, IB_WC_BAD_RESP_ERR },\n\t{ SIW_WC_LOC_ACCESS_ERR, IB_WC_LOC_ACCESS_ERR },\n\t{ SIW_WC_REM_ACCESS_ERR, IB_WC_REM_ACCESS_ERR },\n\t{ SIW_WC_REM_INV_REQ_ERR, IB_WC_REM_INV_REQ_ERR },\n\t{ SIW_WC_GENERAL_ERR, IB_WC_GENERAL_ERR }\n};\n\n \nint siw_reap_cqe(struct siw_cq *cq, struct ib_wc *wc)\n{\n\tstruct siw_cqe *cqe;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cq->lock, flags);\n\n\tcqe = &cq->queue[cq->cq_get % cq->num_cqe];\n\tif (READ_ONCE(cqe->flags) & SIW_WQE_VALID) {\n\t\tmemset(wc, 0, sizeof(*wc));\n\t\twc->wr_id = cqe->id;\n\t\twc->byte_len = cqe->bytes;\n\n\t\t \n\t\tif (likely(rdma_is_kernel_res(&cq->base_cq.res))) {\n\t\t\tif (cqe->flags & SIW_WQE_REM_INVAL) {\n\t\t\t\twc->ex.invalidate_rkey = cqe->inval_stag;\n\t\t\t\twc->wc_flags = IB_WC_WITH_INVALIDATE;\n\t\t\t}\n\t\t\twc->qp = cqe->base_qp;\n\t\t\twc->opcode = map_wc_opcode[cqe->opcode];\n\t\t\twc->status = map_cqe_status[cqe->status].ib;\n\t\t\tsiw_dbg_cq(cq,\n\t\t\t\t   \"idx %u, type %d, flags %2x, id 0x%pK\\n\",\n\t\t\t\t   cq->cq_get % cq->num_cqe, cqe->opcode,\n\t\t\t\t   cqe->flags, (void *)(uintptr_t)cqe->id);\n\t\t} else {\n\t\t\t \n\t\t\tu8 opcode = cqe->opcode;\n\t\t\tu16 status = cqe->status;\n\n\t\t\tif (opcode >= SIW_NUM_OPCODES) {\n\t\t\t\topcode = 0;\n\t\t\t\tstatus = SIW_WC_GENERAL_ERR;\n\t\t\t} else if (status >= SIW_NUM_WC_STATUS) {\n\t\t\t\tstatus = SIW_WC_GENERAL_ERR;\n\t\t\t}\n\t\t\twc->opcode = map_wc_opcode[opcode];\n\t\t\twc->status = map_cqe_status[status].ib;\n\n\t\t}\n\t\tWRITE_ONCE(cqe->flags, 0);\n\t\tcq->cq_get++;\n\n\t\tspin_unlock_irqrestore(&cq->lock, flags);\n\n\t\treturn 1;\n\t}\n\tspin_unlock_irqrestore(&cq->lock, flags);\n\n\treturn 0;\n}\n\n \nvoid siw_cq_flush(struct siw_cq *cq)\n{\n\tstruct ib_wc wc;\n\n\twhile (siw_reap_cqe(cq, &wc))\n\t\t;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}