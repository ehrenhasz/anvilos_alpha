{
  "module_name": "siw_cm.c",
  "hash_id": "0311ef7767c7f35508e55bf09d14e0d7fb196199292b061dd85e9272a6cd818c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_cm.c",
  "human_readable_source": "\n\n \n \n \n \n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/inetdevice.h>\n#include <net/addrconf.h>\n#include <linux/workqueue.h>\n#include <net/sock.h>\n#include <net/tcp.h>\n#include <linux/inet.h>\n#include <linux/tcp.h>\n#include <trace/events/sock.h>\n\n#include <rdma/iw_cm.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_user_verbs.h>\n\n#include \"siw.h\"\n#include \"siw_cm.h\"\n\n \nstatic __be16 rtr_type = MPA_V2_RDMA_READ_RTR | MPA_V2_RDMA_WRITE_RTR;\nstatic const bool relaxed_ird_negotiation = true;\n\nstatic void siw_cm_llp_state_change(struct sock *s);\nstatic void siw_cm_llp_data_ready(struct sock *s);\nstatic void siw_cm_llp_write_space(struct sock *s);\nstatic void siw_cm_llp_error_report(struct sock *s);\nstatic int siw_cm_upcall(struct siw_cep *cep, enum iw_cm_event_type reason,\n\t\t\t int status);\n\nstatic void siw_sk_assign_cm_upcalls(struct sock *sk)\n{\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_state_change = siw_cm_llp_state_change;\n\tsk->sk_data_ready = siw_cm_llp_data_ready;\n\tsk->sk_write_space = siw_cm_llp_write_space;\n\tsk->sk_error_report = siw_cm_llp_error_report;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void siw_sk_save_upcalls(struct sock *sk)\n{\n\tstruct siw_cep *cep = sk_to_cep(sk);\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tcep->sk_state_change = sk->sk_state_change;\n\tcep->sk_data_ready = sk->sk_data_ready;\n\tcep->sk_write_space = sk->sk_write_space;\n\tcep->sk_error_report = sk->sk_error_report;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void siw_sk_restore_upcalls(struct sock *sk, struct siw_cep *cep)\n{\n\tsk->sk_state_change = cep->sk_state_change;\n\tsk->sk_data_ready = cep->sk_data_ready;\n\tsk->sk_write_space = cep->sk_write_space;\n\tsk->sk_error_report = cep->sk_error_report;\n\tsk->sk_user_data = NULL;\n}\n\nstatic void siw_qp_socket_assoc(struct siw_cep *cep, struct siw_qp *qp)\n{\n\tstruct socket *s = cep->sock;\n\tstruct sock *sk = s->sk;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\n\tqp->attrs.sk = s;\n\tsk->sk_data_ready = siw_qp_llp_data_ready;\n\tsk->sk_write_space = siw_qp_llp_write_space;\n\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void siw_socket_disassoc(struct socket *s)\n{\n\tstruct sock *sk = s->sk;\n\tstruct siw_cep *cep;\n\n\tif (sk) {\n\t\twrite_lock_bh(&sk->sk_callback_lock);\n\t\tcep = sk_to_cep(sk);\n\t\tif (cep) {\n\t\t\tsiw_sk_restore_upcalls(sk, cep);\n\t\t\tsiw_cep_put(cep);\n\t\t} else {\n\t\t\tpr_warn(\"siw: cannot restore sk callbacks: no ep\\n\");\n\t\t}\n\t\twrite_unlock_bh(&sk->sk_callback_lock);\n\t} else {\n\t\tpr_warn(\"siw: cannot restore sk callbacks: no sk\\n\");\n\t}\n}\n\nstatic void siw_rtr_data_ready(struct sock *sk)\n{\n\tstruct siw_cep *cep;\n\tstruct siw_qp *qp = NULL;\n\tread_descriptor_t rd_desc;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\n\tcep = sk_to_cep(sk);\n\tif (!cep) {\n\t\tWARN(1, \"No connection endpoint\\n\");\n\t\tgoto out;\n\t}\n\tqp = sk_to_qp(sk);\n\n\tmemset(&rd_desc, 0, sizeof(rd_desc));\n\trd_desc.arg.data = qp;\n\trd_desc.count = 1;\n\n\ttcp_read_sock(sk, &rd_desc, siw_tcp_rx_data);\n\t \n\tif (!qp->rx_stream.rx_suspend)\n\t\tsiw_cm_upcall(cep, IW_CM_EVENT_ESTABLISHED, 0);\nout:\n\tread_unlock(&sk->sk_callback_lock);\n\tif (qp)\n\t\tsiw_qp_socket_assoc(cep, qp);\n}\n\nstatic void siw_sk_assign_rtr_upcalls(struct siw_cep *cep)\n{\n\tstruct sock *sk = cep->sock->sk;\n\n\twrite_lock_bh(&sk->sk_callback_lock);\n\tsk->sk_data_ready = siw_rtr_data_ready;\n\tsk->sk_write_space = siw_qp_llp_write_space;\n\twrite_unlock_bh(&sk->sk_callback_lock);\n}\n\nstatic void siw_cep_socket_assoc(struct siw_cep *cep, struct socket *s)\n{\n\tcep->sock = s;\n\tsiw_cep_get(cep);\n\ts->sk->sk_user_data = cep;\n\n\tsiw_sk_save_upcalls(s->sk);\n\tsiw_sk_assign_cm_upcalls(s->sk);\n}\n\nstatic struct siw_cep *siw_cep_alloc(struct siw_device *sdev)\n{\n\tstruct siw_cep *cep = kzalloc(sizeof(*cep), GFP_KERNEL);\n\tunsigned long flags;\n\n\tif (!cep)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&cep->listenq);\n\tINIT_LIST_HEAD(&cep->devq);\n\tINIT_LIST_HEAD(&cep->work_freelist);\n\n\tkref_init(&cep->ref);\n\tcep->state = SIW_EPSTATE_IDLE;\n\tinit_waitqueue_head(&cep->waitq);\n\tspin_lock_init(&cep->lock);\n\tcep->sdev = sdev;\n\tcep->enhanced_rdma_conn_est = false;\n\n\tspin_lock_irqsave(&sdev->lock, flags);\n\tlist_add_tail(&cep->devq, &sdev->cep_list);\n\tspin_unlock_irqrestore(&sdev->lock, flags);\n\n\tsiw_dbg_cep(cep, \"new endpoint\\n\");\n\treturn cep;\n}\n\nstatic void siw_cm_free_work(struct siw_cep *cep)\n{\n\tstruct list_head *w, *tmp;\n\tstruct siw_cm_work *work;\n\n\tlist_for_each_safe(w, tmp, &cep->work_freelist) {\n\t\twork = list_entry(w, struct siw_cm_work, list);\n\t\tlist_del(&work->list);\n\t\tkfree(work);\n\t}\n}\n\nstatic void siw_cancel_mpatimer(struct siw_cep *cep)\n{\n\tspin_lock_bh(&cep->lock);\n\tif (cep->mpa_timer) {\n\t\tif (cancel_delayed_work(&cep->mpa_timer->work)) {\n\t\t\tsiw_cep_put(cep);\n\t\t\tkfree(cep->mpa_timer);  \n\t\t}\n\t\tcep->mpa_timer = NULL;\n\t}\n\tspin_unlock_bh(&cep->lock);\n}\n\nstatic void siw_put_work(struct siw_cm_work *work)\n{\n\tINIT_LIST_HEAD(&work->list);\n\tspin_lock_bh(&work->cep->lock);\n\tlist_add(&work->list, &work->cep->work_freelist);\n\tspin_unlock_bh(&work->cep->lock);\n}\n\nstatic void siw_cep_set_inuse(struct siw_cep *cep)\n{\n\tunsigned long flags;\nretry:\n\tspin_lock_irqsave(&cep->lock, flags);\n\n\tif (cep->in_use) {\n\t\tspin_unlock_irqrestore(&cep->lock, flags);\n\t\twait_event_interruptible(cep->waitq, !cep->in_use);\n\t\tif (signal_pending(current))\n\t\t\tflush_signals(current);\n\t\tgoto retry;\n\t} else {\n\t\tcep->in_use = 1;\n\t\tspin_unlock_irqrestore(&cep->lock, flags);\n\t}\n}\n\nstatic void siw_cep_set_free(struct siw_cep *cep)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&cep->lock, flags);\n\tcep->in_use = 0;\n\tspin_unlock_irqrestore(&cep->lock, flags);\n\n\twake_up(&cep->waitq);\n}\n\nstatic void __siw_cep_dealloc(struct kref *ref)\n{\n\tstruct siw_cep *cep = container_of(ref, struct siw_cep, ref);\n\tstruct siw_device *sdev = cep->sdev;\n\tunsigned long flags;\n\n\tWARN_ON(cep->listen_cep);\n\n\t \n\tkfree(cep->mpa.pdata);\n\tspin_lock_bh(&cep->lock);\n\tif (!list_empty(&cep->work_freelist))\n\t\tsiw_cm_free_work(cep);\n\tspin_unlock_bh(&cep->lock);\n\n\tspin_lock_irqsave(&sdev->lock, flags);\n\tlist_del(&cep->devq);\n\tspin_unlock_irqrestore(&sdev->lock, flags);\n\n\tsiw_dbg_cep(cep, \"free endpoint\\n\");\n\tkfree(cep);\n}\n\nstatic struct siw_cm_work *siw_get_work(struct siw_cep *cep)\n{\n\tstruct siw_cm_work *work = NULL;\n\n\tspin_lock_bh(&cep->lock);\n\tif (!list_empty(&cep->work_freelist)) {\n\t\twork = list_entry(cep->work_freelist.next, struct siw_cm_work,\n\t\t\t\t  list);\n\t\tlist_del_init(&work->list);\n\t}\n\tspin_unlock_bh(&cep->lock);\n\treturn work;\n}\n\nstatic int siw_cm_alloc_work(struct siw_cep *cep, int num)\n{\n\tstruct siw_cm_work *work;\n\n\twhile (num--) {\n\t\twork = kmalloc(sizeof(*work), GFP_KERNEL);\n\t\tif (!work) {\n\t\t\tif (!(list_empty(&cep->work_freelist)))\n\t\t\t\tsiw_cm_free_work(cep);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\twork->cep = cep;\n\t\tINIT_LIST_HEAD(&work->list);\n\t\tlist_add(&work->list, &cep->work_freelist);\n\t}\n\treturn 0;\n}\n\n \nstatic int siw_cm_upcall(struct siw_cep *cep, enum iw_cm_event_type reason,\n\t\t\t int status)\n{\n\tstruct iw_cm_event event;\n\tstruct iw_cm_id *id;\n\n\tmemset(&event, 0, sizeof(event));\n\tevent.status = status;\n\tevent.event = reason;\n\n\tif (reason == IW_CM_EVENT_CONNECT_REQUEST) {\n\t\tevent.provider_data = cep;\n\t\tid = cep->listen_cep->cm_id;\n\t} else {\n\t\tid = cep->cm_id;\n\t}\n\t \n\tif (reason == IW_CM_EVENT_ESTABLISHED ||\n\t    reason == IW_CM_EVENT_CONNECT_REPLY) {\n\t\t \n\t\tevent.ird = cep->ird;\n\t\tevent.ord = cep->ord;\n\t} else if (reason == IW_CM_EVENT_CONNECT_REQUEST) {\n\t\tevent.ird = cep->ord;\n\t\tevent.ord = cep->ird;\n\t}\n\t \n\tif (reason == IW_CM_EVENT_CONNECT_REQUEST ||\n\t    reason == IW_CM_EVENT_CONNECT_REPLY) {\n\t\tu16 pd_len = be16_to_cpu(cep->mpa.hdr.params.pd_len);\n\n\t\tif (pd_len) {\n\t\t\t \n\t\t\tevent.private_data_len = pd_len;\n\t\t\tevent.private_data = cep->mpa.pdata;\n\n\t\t\t \n\t\t\tif (cep->enhanced_rdma_conn_est) {\n\t\t\t\tevent.private_data_len -=\n\t\t\t\t\tsizeof(struct mpa_v2_data);\n\t\t\t\tevent.private_data +=\n\t\t\t\t\tsizeof(struct mpa_v2_data);\n\t\t\t}\n\t\t}\n\t\tgetname_local(cep->sock, &event.local_addr);\n\t\tgetname_peer(cep->sock, &event.remote_addr);\n\t}\n\tsiw_dbg_cep(cep, \"[QP %u]: reason=%d, status=%d\\n\",\n\t\t    cep->qp ? qp_id(cep->qp) : UINT_MAX, reason, status);\n\n\treturn id->event_handler(id, &event);\n}\n\n \nvoid siw_qp_cm_drop(struct siw_qp *qp, int schedule)\n{\n\tstruct siw_cep *cep = qp->cep;\n\n\tqp->rx_stream.rx_suspend = 1;\n\tqp->tx_ctx.tx_suspend = 1;\n\n\tif (!qp->cep)\n\t\treturn;\n\n\tif (schedule) {\n\t\tsiw_cm_queue_work(cep, SIW_CM_WORK_CLOSE_LLP);\n\t} else {\n\t\tsiw_cep_set_inuse(cep);\n\n\t\tif (cep->state == SIW_EPSTATE_CLOSED) {\n\t\t\tsiw_dbg_cep(cep, \"already closed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tsiw_dbg_cep(cep, \"immediate close, state %d\\n\", cep->state);\n\n\t\tif (qp->term_info.valid)\n\t\t\tsiw_send_terminate(qp);\n\n\t\tif (cep->cm_id) {\n\t\t\tswitch (cep->state) {\n\t\t\tcase SIW_EPSTATE_AWAIT_MPAREP:\n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t      -EINVAL);\n\t\t\t\tbreak;\n\n\t\t\tcase SIW_EPSTATE_RDMA_MODE:\n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\t\t\t\tbreak;\n\n\t\t\tcase SIW_EPSTATE_IDLE:\n\t\t\tcase SIW_EPSTATE_LISTENING:\n\t\t\tcase SIW_EPSTATE_CONNECTING:\n\t\t\tcase SIW_EPSTATE_AWAIT_MPAREQ:\n\t\t\tcase SIW_EPSTATE_RECVD_MPAREQ:\n\t\t\tcase SIW_EPSTATE_CLOSED:\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t\tsiw_cep_put(cep);\n\t\t}\n\t\tcep->state = SIW_EPSTATE_CLOSED;\n\n\t\tif (cep->sock) {\n\t\t\tsiw_socket_disassoc(cep->sock);\n\t\t\t \n\t\t\tsock_release(cep->sock);\n\t\t\tcep->sock = NULL;\n\t\t}\n\t\tif (cep->qp) {\n\t\t\tcep->qp = NULL;\n\t\t\tsiw_qp_put(qp);\n\t\t}\nout:\n\t\tsiw_cep_set_free(cep);\n\t}\n}\n\nvoid siw_cep_put(struct siw_cep *cep)\n{\n\tWARN_ON(kref_read(&cep->ref) < 1);\n\tkref_put(&cep->ref, __siw_cep_dealloc);\n}\n\nvoid siw_cep_get(struct siw_cep *cep)\n{\n\tkref_get(&cep->ref);\n}\n\n \nstatic int siw_send_mpareqrep(struct siw_cep *cep, const void *pdata, u8 pd_len)\n{\n\tstruct socket *s = cep->sock;\n\tstruct mpa_rr *rr = &cep->mpa.hdr;\n\tstruct kvec iov[3];\n\tstruct msghdr msg;\n\tint rv;\n\tint iovec_num = 0;\n\tint mpa_len;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tiov[iovec_num].iov_base = rr;\n\tiov[iovec_num].iov_len = sizeof(*rr);\n\tmpa_len = sizeof(*rr);\n\n\tif (cep->enhanced_rdma_conn_est) {\n\t\tiovec_num++;\n\t\tiov[iovec_num].iov_base = &cep->mpa.v2_ctrl;\n\t\tiov[iovec_num].iov_len = sizeof(cep->mpa.v2_ctrl);\n\t\tmpa_len += sizeof(cep->mpa.v2_ctrl);\n\t}\n\tif (pd_len) {\n\t\tiovec_num++;\n\t\tiov[iovec_num].iov_base = (char *)pdata;\n\t\tiov[iovec_num].iov_len = pd_len;\n\t\tmpa_len += pd_len;\n\t}\n\tif (cep->enhanced_rdma_conn_est)\n\t\tpd_len += sizeof(cep->mpa.v2_ctrl);\n\n\trr->params.pd_len = cpu_to_be16(pd_len);\n\n\trv = kernel_sendmsg(s, &msg, iov, iovec_num + 1, mpa_len);\n\n\treturn rv < 0 ? rv : 0;\n}\n\n \nstatic int siw_recv_mpa_rr(struct siw_cep *cep)\n{\n\tstruct mpa_rr *hdr = &cep->mpa.hdr;\n\tstruct socket *s = cep->sock;\n\tu16 pd_len;\n\tint rcvd, to_rcv;\n\n\tif (cep->mpa.bytes_rcvd < sizeof(struct mpa_rr)) {\n\t\trcvd = ksock_recv(s, (char *)hdr + cep->mpa.bytes_rcvd,\n\t\t\t\t  sizeof(struct mpa_rr) - cep->mpa.bytes_rcvd,\n\t\t\t\t  0);\n\t\tif (rcvd <= 0)\n\t\t\treturn -ECONNABORTED;\n\n\t\tcep->mpa.bytes_rcvd += rcvd;\n\n\t\tif (cep->mpa.bytes_rcvd < sizeof(struct mpa_rr))\n\t\t\treturn -EAGAIN;\n\n\t\tif (be16_to_cpu(hdr->params.pd_len) > MPA_MAX_PRIVDATA)\n\t\t\treturn -EPROTO;\n\t}\n\tpd_len = be16_to_cpu(hdr->params.pd_len);\n\n\t \n\tto_rcv = pd_len - (cep->mpa.bytes_rcvd - sizeof(struct mpa_rr));\n\n\tif (!to_rcv) {\n\t\t \n\t\tu32 word;\n\n\t\trcvd = ksock_recv(s, (char *)&word, sizeof(word), MSG_DONTWAIT);\n\t\tif (rcvd == -EAGAIN)\n\t\t\treturn 0;\n\n\t\tif (rcvd == 0) {\n\t\t\tsiw_dbg_cep(cep, \"peer EOF\\n\");\n\t\t\treturn -EPIPE;\n\t\t}\n\t\tif (rcvd < 0) {\n\t\t\tsiw_dbg_cep(cep, \"error: %d\\n\", rcvd);\n\t\t\treturn rcvd;\n\t\t}\n\t\tsiw_dbg_cep(cep, \"peer sent extra data: %d\\n\", rcvd);\n\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tif (!cep->mpa.pdata) {\n\t\tcep->mpa.pdata = kmalloc(pd_len + 4, GFP_KERNEL);\n\t\tif (!cep->mpa.pdata)\n\t\t\treturn -ENOMEM;\n\t}\n\trcvd = ksock_recv(\n\t\ts, cep->mpa.pdata + cep->mpa.bytes_rcvd - sizeof(struct mpa_rr),\n\t\tto_rcv + 4, MSG_DONTWAIT);\n\n\tif (rcvd < 0)\n\t\treturn rcvd;\n\n\tif (rcvd > to_rcv)\n\t\treturn -EPROTO;\n\n\tcep->mpa.bytes_rcvd += rcvd;\n\n\tif (to_rcv == rcvd) {\n\t\tsiw_dbg_cep(cep, \"%d bytes private data received\\n\", pd_len);\n\t\treturn 0;\n\t}\n\treturn -EAGAIN;\n}\n\n \nstatic int siw_proc_mpareq(struct siw_cep *cep)\n{\n\tstruct mpa_rr *req;\n\tint version, rv;\n\tu16 pd_len;\n\n\trv = siw_recv_mpa_rr(cep);\n\tif (rv)\n\t\treturn rv;\n\n\treq = &cep->mpa.hdr;\n\n\tversion = __mpa_rr_revision(req->params.bits);\n\tpd_len = be16_to_cpu(req->params.pd_len);\n\n\tif (version > MPA_REVISION_2)\n\t\t \n\t\treturn -EPROTO;\n\n\tif (memcmp(req->key, MPA_KEY_REQ, 16))\n\t\treturn -EPROTO;\n\n\t \n\tmemcpy(req->key, MPA_KEY_REP, 16);\n\n\tif (version == MPA_REVISION_2 &&\n\t    (req->params.bits & MPA_RR_FLAG_ENHANCED)) {\n\t\t \n\t\tif (pd_len < sizeof(struct mpa_v2_data))\n\t\t\tgoto reject_conn;\n\n\t\tcep->enhanced_rdma_conn_est = true;\n\t}\n\n\t \n\tif (req->params.bits & MPA_RR_FLAG_MARKERS)\n\t\tgoto reject_conn;\n\n\tif (req->params.bits & MPA_RR_FLAG_CRC) {\n\t\t \n\t\tif (!mpa_crc_required && mpa_crc_strict)\n\t\t\tgoto reject_conn;\n\n\t\t \n\t\tif (mpa_crc_required)\n\t\t\treq->params.bits |= MPA_RR_FLAG_CRC;\n\t}\n\tif (cep->enhanced_rdma_conn_est) {\n\t\tstruct mpa_v2_data *v2 = (struct mpa_v2_data *)cep->mpa.pdata;\n\n\t\t \n\t\tcep->ord = ntohs(v2->ird) & MPA_IRD_ORD_MASK;\n\t\tcep->ord = min(cep->ord, SIW_MAX_ORD_QP);\n\t\tcep->ird = ntohs(v2->ord) & MPA_IRD_ORD_MASK;\n\t\tcep->ird = min(cep->ird, SIW_MAX_IRD_QP);\n\n\t\t \n\t\tcep->mpa.v2_ctrl.ird = htons(cep->ird);\n\t\tcep->mpa.v2_ctrl.ord = htons(cep->ord);\n\n\t\t \n\t\tif (v2->ird & MPA_V2_PEER_TO_PEER) {\n\t\t\tcep->mpa.v2_ctrl.ird |= MPA_V2_PEER_TO_PEER;\n\n\t\t\tif (v2->ord & MPA_V2_RDMA_WRITE_RTR)\n\t\t\t\tcep->mpa.v2_ctrl.ord |= MPA_V2_RDMA_WRITE_RTR;\n\t\t\telse if (v2->ord & MPA_V2_RDMA_READ_RTR)\n\t\t\t\tcep->mpa.v2_ctrl.ord |= MPA_V2_RDMA_READ_RTR;\n\t\t\telse\n\t\t\t\tcep->mpa.v2_ctrl.ord |= MPA_V2_RDMA_WRITE_RTR;\n\t\t}\n\t}\n\n\tcep->state = SIW_EPSTATE_RECVD_MPAREQ;\n\n\t \n\tsiw_cep_get(cep);\n\trv = siw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REQUEST, 0);\n\tif (rv)\n\t\tsiw_cep_put(cep);\n\n\treturn rv;\n\nreject_conn:\n\tsiw_dbg_cep(cep, \"reject: crc %d:%d:%d, m %d:%d\\n\",\n\t\t    req->params.bits & MPA_RR_FLAG_CRC ? 1 : 0,\n\t\t    mpa_crc_required, mpa_crc_strict,\n\t\t    req->params.bits & MPA_RR_FLAG_MARKERS ? 1 : 0, 0);\n\n\treq->params.bits &= ~MPA_RR_FLAG_MARKERS;\n\treq->params.bits |= MPA_RR_FLAG_REJECT;\n\n\tif (!mpa_crc_required && mpa_crc_strict)\n\t\treq->params.bits &= ~MPA_RR_FLAG_CRC;\n\n\tif (pd_len)\n\t\tkfree(cep->mpa.pdata);\n\n\tcep->mpa.pdata = NULL;\n\n\tsiw_send_mpareqrep(cep, NULL, 0);\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int siw_proc_mpareply(struct siw_cep *cep)\n{\n\tstruct siw_qp_attrs qp_attrs;\n\tenum siw_qp_attr_mask qp_attr_mask;\n\tstruct siw_qp *qp = cep->qp;\n\tstruct mpa_rr *rep;\n\tint rv;\n\tu16 rep_ord;\n\tu16 rep_ird;\n\tbool ird_insufficient = false;\n\tenum mpa_v2_ctrl mpa_p2p_mode = MPA_V2_RDMA_NO_RTR;\n\n\trv = siw_recv_mpa_rr(cep);\n\tif (rv)\n\t\tgoto out_err;\n\n\tsiw_cancel_mpatimer(cep);\n\n\trep = &cep->mpa.hdr;\n\n\tif (__mpa_rr_revision(rep->params.bits) > MPA_REVISION_2) {\n\t\t \n\t\trv = -EPROTO;\n\t\tgoto out_err;\n\t}\n\tif (memcmp(rep->key, MPA_KEY_REP, 16)) {\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_LLP, LLP_ETYPE_MPA,\n\t\t\t\t   LLP_ECODE_INVALID_REQ_RESP, 0);\n\t\tsiw_send_terminate(qp);\n\t\trv = -EPROTO;\n\t\tgoto out_err;\n\t}\n\tif (rep->params.bits & MPA_RR_FLAG_REJECT) {\n\t\tsiw_dbg_cep(cep, \"got mpa reject\\n\");\n\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -ECONNRESET);\n\n\t\treturn -ECONNRESET;\n\t}\n\tif (try_gso && rep->params.bits & MPA_RR_FLAG_GSO_EXP) {\n\t\tsiw_dbg_cep(cep, \"peer allows GSO on TX\\n\");\n\t\tqp->tx_ctx.gso_seg_limit = 0;\n\t}\n\tif ((rep->params.bits & MPA_RR_FLAG_MARKERS) ||\n\t    (mpa_crc_required && !(rep->params.bits & MPA_RR_FLAG_CRC)) ||\n\t    (mpa_crc_strict && !mpa_crc_required &&\n\t     (rep->params.bits & MPA_RR_FLAG_CRC))) {\n\t\tsiw_dbg_cep(cep, \"reply unsupp: crc %d:%d:%d, m %d:%d\\n\",\n\t\t\t    rep->params.bits & MPA_RR_FLAG_CRC ? 1 : 0,\n\t\t\t    mpa_crc_required, mpa_crc_strict,\n\t\t\t    rep->params.bits & MPA_RR_FLAG_MARKERS ? 1 : 0, 0);\n\n\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -ECONNREFUSED);\n\n\t\treturn -EINVAL;\n\t}\n\tif (cep->enhanced_rdma_conn_est) {\n\t\tstruct mpa_v2_data *v2;\n\n\t\tif (__mpa_rr_revision(rep->params.bits) < MPA_REVISION_2 ||\n\t\t    !(rep->params.bits & MPA_RR_FLAG_ENHANCED)) {\n\t\t\t \n\t\t\tsiw_dbg_cep(cep, \"mpa reply error: vers %d, enhcd %d\\n\",\n\t\t\t\t    __mpa_rr_revision(rep->params.bits),\n\t\t\t\t    rep->params.bits & MPA_RR_FLAG_ENHANCED ?\n\t\t\t\t\t    1 :\n\t\t\t\t\t    0);\n\n\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t      -ECONNRESET);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tv2 = (struct mpa_v2_data *)cep->mpa.pdata;\n\t\trep_ird = ntohs(v2->ird) & MPA_IRD_ORD_MASK;\n\t\trep_ord = ntohs(v2->ord) & MPA_IRD_ORD_MASK;\n\n\t\tif (cep->ird < rep_ord &&\n\t\t    (relaxed_ird_negotiation == false ||\n\t\t     rep_ord > cep->sdev->attrs.max_ird)) {\n\t\t\tsiw_dbg_cep(cep, \"ird %d, rep_ord %d, max_ord %d\\n\",\n\t\t\t\t    cep->ird, rep_ord,\n\t\t\t\t    cep->sdev->attrs.max_ord);\n\t\t\tird_insufficient = true;\n\t\t}\n\t\tif (cep->ord > rep_ird && relaxed_ird_negotiation == false) {\n\t\t\tsiw_dbg_cep(cep, \"ord %d, rep_ird %d\\n\", cep->ord,\n\t\t\t\t    rep_ird);\n\t\t\tird_insufficient = true;\n\t\t}\n\t\t \n\t\tcep->ird = rep_ord;\n\t\tcep->ord = rep_ird;\n\n\t\tif (ird_insufficient) {\n\t\t\t \n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_LLP,\n\t\t\t\t\t   LLP_ETYPE_MPA,\n\t\t\t\t\t   LLP_ECODE_INSUFFICIENT_IRD, 0);\n\t\t\tsiw_send_terminate(qp);\n\t\t\trv = -ENOMEM;\n\t\t\tgoto out_err;\n\t\t}\n\t\tif (cep->mpa.v2_ctrl_req.ird & MPA_V2_PEER_TO_PEER)\n\t\t\tmpa_p2p_mode =\n\t\t\t\tcep->mpa.v2_ctrl_req.ord &\n\t\t\t\t(MPA_V2_RDMA_WRITE_RTR | MPA_V2_RDMA_READ_RTR);\n\n\t\t \n\t\tif (mpa_p2p_mode != MPA_V2_RDMA_NO_RTR) {\n\t\t\tif ((mpa_p2p_mode & v2->ord) == 0) {\n\t\t\t\t \n\t\t\t\tsiw_dbg_cep(cep,\n\t\t\t\t\t    \"rtr mode:  req %2x, got %2x\\n\",\n\t\t\t\t\t    mpa_p2p_mode,\n\t\t\t\t\t    v2->ord & (MPA_V2_RDMA_WRITE_RTR |\n\t\t\t\t\t\t       MPA_V2_RDMA_READ_RTR));\n\n\t\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_LLP,\n\t\t\t\t\t\t   LLP_ETYPE_MPA,\n\t\t\t\t\t\t   LLP_ECODE_NO_MATCHING_RTR,\n\t\t\t\t\t\t   0);\n\t\t\t\tsiw_send_terminate(qp);\n\t\t\t\trv = -EPROTO;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\t\t\tmpa_p2p_mode = v2->ord & (MPA_V2_RDMA_WRITE_RTR |\n\t\t\t\t\t\t  MPA_V2_RDMA_READ_RTR);\n\t\t}\n\t}\n\tmemset(&qp_attrs, 0, sizeof(qp_attrs));\n\n\tif (rep->params.bits & MPA_RR_FLAG_CRC)\n\t\tqp_attrs.flags = SIW_MPA_CRC;\n\n\tqp_attrs.irq_size = cep->ird;\n\tqp_attrs.orq_size = cep->ord;\n\tqp_attrs.sk = cep->sock;\n\tqp_attrs.state = SIW_QP_STATE_RTS;\n\n\tqp_attr_mask = SIW_QP_ATTR_STATE | SIW_QP_ATTR_LLP_HANDLE |\n\t\t       SIW_QP_ATTR_ORD | SIW_QP_ATTR_IRD | SIW_QP_ATTR_MPA;\n\n\t \n\tdown_write(&qp->state_lock);\n\tif (qp->attrs.state > SIW_QP_STATE_RTR) {\n\t\trv = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto out_err;\n\t}\n\trv = siw_qp_modify(qp, &qp_attrs, qp_attr_mask);\n\n\tsiw_qp_socket_assoc(cep, qp);\n\n\tup_write(&qp->state_lock);\n\n\t \n\tif (mpa_p2p_mode != MPA_V2_RDMA_NO_RTR) {\n\t\trv = siw_qp_mpa_rts(qp, mpa_p2p_mode);\n\t\tif (rv)\n\t\t\tgoto out_err;\n\t}\n\tif (!rv) {\n\t\trv = siw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, 0);\n\t\tif (!rv)\n\t\t\tcep->state = SIW_EPSTATE_RDMA_MODE;\n\n\t\treturn 0;\n\t}\n\nout_err:\n\tif (rv != -EAGAIN)\n\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY, -EINVAL);\n\n\treturn rv;\n}\n\n \nstatic void siw_accept_newconn(struct siw_cep *cep)\n{\n\tstruct socket *s = cep->sock;\n\tstruct socket *new_s = NULL;\n\tstruct siw_cep *new_cep = NULL;\n\tint rv = 0;  \n\n\tif (cep->state != SIW_EPSTATE_LISTENING)\n\t\tgoto error;\n\n\tnew_cep = siw_cep_alloc(cep->sdev);\n\tif (!new_cep)\n\t\tgoto error;\n\n\t \n\tif (siw_cm_alloc_work(new_cep, 4) != 0)\n\t\tgoto error;\n\n\t \n\tnew_cep->sk_state_change = cep->sk_state_change;\n\tnew_cep->sk_data_ready = cep->sk_data_ready;\n\tnew_cep->sk_write_space = cep->sk_write_space;\n\tnew_cep->sk_error_report = cep->sk_error_report;\n\n\trv = kernel_accept(s, &new_s, O_NONBLOCK);\n\tif (rv != 0) {\n\t\t \n\t\tsiw_dbg_cep(cep, \"kernel_accept() error: %d\\n\", rv);\n\t\tgoto error;\n\t}\n\tnew_cep->sock = new_s;\n\tsiw_cep_get(new_cep);\n\tnew_s->sk->sk_user_data = new_cep;\n\n\tif (siw_tcp_nagle == false)\n\t\ttcp_sock_set_nodelay(new_s->sk);\n\tnew_cep->state = SIW_EPSTATE_AWAIT_MPAREQ;\n\n\trv = siw_cm_queue_work(new_cep, SIW_CM_WORK_MPATIMEOUT);\n\tif (rv)\n\t\tgoto error;\n\t \n\tnew_cep->listen_cep = cep;\n\tsiw_cep_get(cep);\n\n\tif (atomic_read(&new_s->sk->sk_rmem_alloc)) {\n\t\t \n\t\tsiw_dbg_cep(cep, \"immediate mpa request\\n\");\n\n\t\tsiw_cep_set_inuse(new_cep);\n\t\trv = siw_proc_mpareq(new_cep);\n\t\tif (rv != -EAGAIN) {\n\t\t\tsiw_cep_put(cep);\n\t\t\tnew_cep->listen_cep = NULL;\n\t\t\tif (rv) {\n\t\t\t\tsiw_cancel_mpatimer(new_cep);\n\t\t\t\tsiw_cep_set_free(new_cep);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tsiw_cep_set_free(new_cep);\n\t}\n\treturn;\n\nerror:\n\tif (new_cep)\n\t\tsiw_cep_put(new_cep);\n\n\tif (new_s) {\n\t\tsiw_socket_disassoc(new_s);\n\t\tsock_release(new_s);\n\t\tnew_cep->sock = NULL;\n\t}\n\tsiw_dbg_cep(cep, \"error %d\\n\", rv);\n}\n\nstatic void siw_cm_work_handler(struct work_struct *w)\n{\n\tstruct siw_cm_work *work;\n\tstruct siw_cep *cep;\n\tint release_cep = 0, rv = 0;\n\n\twork = container_of(w, struct siw_cm_work, work.work);\n\tcep = work->cep;\n\n\tsiw_dbg_cep(cep, \"[QP %u]: work type: %d, state %d\\n\",\n\t\t    cep->qp ? qp_id(cep->qp) : UINT_MAX,\n\t\t    work->type, cep->state);\n\n\tsiw_cep_set_inuse(cep);\n\n\tswitch (work->type) {\n\tcase SIW_CM_WORK_ACCEPT:\n\t\tsiw_accept_newconn(cep);\n\t\tbreak;\n\n\tcase SIW_CM_WORK_READ_MPAHDR:\n\t\tif (cep->state == SIW_EPSTATE_AWAIT_MPAREQ) {\n\t\t\tif (cep->listen_cep) {\n\t\t\t\tsiw_cep_set_inuse(cep->listen_cep);\n\n\t\t\t\tif (cep->listen_cep->state ==\n\t\t\t\t    SIW_EPSTATE_LISTENING)\n\t\t\t\t\trv = siw_proc_mpareq(cep);\n\t\t\t\telse\n\t\t\t\t\trv = -EFAULT;\n\n\t\t\t\tsiw_cep_set_free(cep->listen_cep);\n\n\t\t\t\tif (rv != -EAGAIN) {\n\t\t\t\t\tsiw_cep_put(cep->listen_cep);\n\t\t\t\t\tcep->listen_cep = NULL;\n\t\t\t\t\tif (rv)\n\t\t\t\t\t\tsiw_cep_put(cep);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (cep->state == SIW_EPSTATE_AWAIT_MPAREP) {\n\t\t\trv = siw_proc_mpareply(cep);\n\t\t} else {\n\t\t\t \n\t\t\tif (cep->state == SIW_EPSTATE_RDMA_MODE) {\n\t\t\t\tcep->sock->sk->sk_data_ready(cep->sock->sk);\n\t\t\t\tsiw_dbg_cep(cep, \"already in RDMA mode\");\n\t\t\t} else {\n\t\t\t\tsiw_dbg_cep(cep, \"out of state: %d\\n\",\n\t\t\t\t\t    cep->state);\n\t\t\t}\n\t\t}\n\t\tif (rv && rv != -EAGAIN)\n\t\t\trelease_cep = 1;\n\t\tbreak;\n\n\tcase SIW_CM_WORK_CLOSE_LLP:\n\t\t \n\t\tif (cep->qp && cep->qp->term_info.valid)\n\t\t\tsiw_send_terminate(cep->qp);\n\n\t\tif (cep->cm_id)\n\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\n\t\trelease_cep = 1;\n\t\tbreak;\n\n\tcase SIW_CM_WORK_PEER_CLOSE:\n\t\tif (cep->cm_id) {\n\t\t\tif (cep->state == SIW_EPSTATE_AWAIT_MPAREP) {\n\t\t\t\t \n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t      -ECONNRESET);\n\t\t\t} else if (cep->state == SIW_EPSTATE_RDMA_MODE) {\n\t\t\t\t \n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_DISCONNECT, 0);\n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CLOSE, 0);\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\tif (cep->state == SIW_EPSTATE_RECVD_MPAREQ) {\n\t\t\t\t \n\t\t\t\tsiw_dbg_cep(cep,\n\t\t\t\t\t    \"mpa req recvd, wait for ULP\\n\");\n\t\t\t} else if (cep->state == SIW_EPSTATE_AWAIT_MPAREQ) {\n\t\t\t\t \n\t\t\t\tif (cep->listen_cep) {\n\t\t\t\t\tsiw_dbg_cep(cep,\n\t\t\t\t\t\t\"no mpareq: drop listener\\n\");\n\t\t\t\t\tsiw_cep_put(cep->listen_cep);\n\t\t\t\t\tcep->listen_cep = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trelease_cep = 1;\n\t\tbreak;\n\n\tcase SIW_CM_WORK_MPATIMEOUT:\n\t\tcep->mpa_timer = NULL;\n\n\t\tif (cep->state == SIW_EPSTATE_AWAIT_MPAREP) {\n\t\t\t \n\t\t\tcep->mpa.hdr.params.pd_len = 0;\n\n\t\t\tif (cep->cm_id)\n\t\t\t\tsiw_cm_upcall(cep, IW_CM_EVENT_CONNECT_REPLY,\n\t\t\t\t\t      -ETIMEDOUT);\n\t\t\trelease_cep = 1;\n\n\t\t} else if (cep->state == SIW_EPSTATE_AWAIT_MPAREQ) {\n\t\t\t \n\t\t\tif (cep->listen_cep) {\n\t\t\t\tsiw_cep_put(cep->listen_cep);\n\t\t\t\tcep->listen_cep = NULL;\n\t\t\t}\n\t\t\trelease_cep = 1;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"Undefined CM work type: %d\\n\", work->type);\n\t}\n\tif (release_cep) {\n\t\tsiw_dbg_cep(cep,\n\t\t\t    \"release: timer=%s, QP[%u]\\n\",\n\t\t\t    cep->mpa_timer ? \"y\" : \"n\",\n\t\t\t    cep->qp ? qp_id(cep->qp) : UINT_MAX);\n\n\t\tsiw_cancel_mpatimer(cep);\n\n\t\tcep->state = SIW_EPSTATE_CLOSED;\n\n\t\tif (cep->qp) {\n\t\t\tstruct siw_qp *qp = cep->qp;\n\t\t\t \n\t\t\tsiw_qp_get(qp);\n\t\t\tsiw_cep_set_free(cep);\n\n\t\t\tsiw_qp_llp_close(qp);\n\t\t\tsiw_qp_put(qp);\n\n\t\t\tsiw_cep_set_inuse(cep);\n\t\t\tcep->qp = NULL;\n\t\t\tsiw_qp_put(qp);\n\t\t}\n\t\tif (cep->sock) {\n\t\t\tsiw_socket_disassoc(cep->sock);\n\t\t\tsock_release(cep->sock);\n\t\t\tcep->sock = NULL;\n\t\t}\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t\tsiw_cep_put(cep);\n\t\t}\n\t}\n\tsiw_cep_set_free(cep);\n\tsiw_put_work(work);\n\tsiw_cep_put(cep);\n}\n\nstatic struct workqueue_struct *siw_cm_wq;\n\nint siw_cm_queue_work(struct siw_cep *cep, enum siw_work_type type)\n{\n\tstruct siw_cm_work *work = siw_get_work(cep);\n\tunsigned long delay = 0;\n\n\tif (!work) {\n\t\tsiw_dbg_cep(cep, \"failed with no work available\\n\");\n\t\treturn -ENOMEM;\n\t}\n\twork->type = type;\n\twork->cep = cep;\n\n\tsiw_cep_get(cep);\n\n\tINIT_DELAYED_WORK(&work->work, siw_cm_work_handler);\n\n\tif (type == SIW_CM_WORK_MPATIMEOUT) {\n\t\tcep->mpa_timer = work;\n\n\t\tif (cep->state == SIW_EPSTATE_AWAIT_MPAREP)\n\t\t\tdelay = MPAREQ_TIMEOUT;\n\t\telse\n\t\t\tdelay = MPAREP_TIMEOUT;\n\t}\n\tsiw_dbg_cep(cep, \"[QP %u]: work type: %d, timeout %lu\\n\",\n\t\t    cep->qp ? qp_id(cep->qp) : -1, type, delay);\n\n\tqueue_delayed_work(siw_cm_wq, &work->work, delay);\n\n\treturn 0;\n}\n\nstatic void siw_cm_llp_data_ready(struct sock *sk)\n{\n\tstruct siw_cep *cep;\n\n\ttrace_sk_data_ready(sk);\n\n\tread_lock(&sk->sk_callback_lock);\n\n\tcep = sk_to_cep(sk);\n\tif (!cep)\n\t\tgoto out;\n\n\tsiw_dbg_cep(cep, \"cep state: %d, socket state %d\\n\",\n\t\t    cep->state, sk->sk_state);\n\n\tif (sk->sk_state != TCP_ESTABLISHED)\n\t\tgoto out;\n\n\tswitch (cep->state) {\n\tcase SIW_EPSTATE_RDMA_MODE:\n\tcase SIW_EPSTATE_LISTENING:\n\t\tbreak;\n\n\tcase SIW_EPSTATE_AWAIT_MPAREQ:\n\tcase SIW_EPSTATE_AWAIT_MPAREP:\n\t\tsiw_cm_queue_work(cep, SIW_CM_WORK_READ_MPAHDR);\n\t\tbreak;\n\n\tdefault:\n\t\tsiw_dbg_cep(cep, \"unexpected data, state %d\\n\", cep->state);\n\t\tbreak;\n\t}\nout:\n\tread_unlock(&sk->sk_callback_lock);\n}\n\nstatic void siw_cm_llp_write_space(struct sock *sk)\n{\n\tstruct siw_cep *cep = sk_to_cep(sk);\n\n\tif (cep)\n\t\tsiw_dbg_cep(cep, \"state: %d\\n\", cep->state);\n}\n\nstatic void siw_cm_llp_error_report(struct sock *sk)\n{\n\tstruct siw_cep *cep = sk_to_cep(sk);\n\n\tif (cep) {\n\t\tsiw_dbg_cep(cep, \"error %d, socket state: %d, cep state: %d\\n\",\n\t\t\t    sk->sk_err, sk->sk_state, cep->state);\n\t\tcep->sk_error_report(sk);\n\t}\n}\n\nstatic void siw_cm_llp_state_change(struct sock *sk)\n{\n\tstruct siw_cep *cep;\n\tvoid (*orig_state_change)(struct sock *s);\n\n\tread_lock(&sk->sk_callback_lock);\n\n\tcep = sk_to_cep(sk);\n\tif (!cep) {\n\t\t \n\t\tread_unlock(&sk->sk_callback_lock);\n\t\treturn;\n\t}\n\torig_state_change = cep->sk_state_change;\n\n\tsiw_dbg_cep(cep, \"state: %d\\n\", cep->state);\n\n\tswitch (sk->sk_state) {\n\tcase TCP_ESTABLISHED:\n\t\t \n\t\tsiw_cm_queue_work(cep, SIW_CM_WORK_ACCEPT);\n\t\tbreak;\n\n\tcase TCP_CLOSE:\n\tcase TCP_CLOSE_WAIT:\n\t\tif (cep->qp)\n\t\t\tcep->qp->tx_ctx.tx_suspend = 1;\n\t\tsiw_cm_queue_work(cep, SIW_CM_WORK_PEER_CLOSE);\n\t\tbreak;\n\n\tdefault:\n\t\tsiw_dbg_cep(cep, \"unexpected socket state %d\\n\", sk->sk_state);\n\t}\n\tread_unlock(&sk->sk_callback_lock);\n\torig_state_change(sk);\n}\n\nstatic int kernel_bindconnect(struct socket *s, struct sockaddr *laddr,\n\t\t\t      struct sockaddr *raddr, bool afonly)\n{\n\tint rv, flags = 0;\n\tsize_t size = laddr->sa_family == AF_INET ?\n\t\tsizeof(struct sockaddr_in) : sizeof(struct sockaddr_in6);\n\n\t \n\tsock_set_reuseaddr(s->sk);\n\n\tif (afonly) {\n\t\trv = ip6_sock_set_v6only(s->sk);\n\t\tif (rv)\n\t\t\treturn rv;\n\t}\n\n\trv = s->ops->bind(s, laddr, size);\n\tif (rv < 0)\n\t\treturn rv;\n\n\trv = s->ops->connect(s, raddr, size, flags);\n\n\treturn rv < 0 ? rv : 0;\n}\n\nint siw_connect(struct iw_cm_id *id, struct iw_cm_conn_param *params)\n{\n\tstruct siw_device *sdev = to_siw_dev(id->device);\n\tstruct siw_qp *qp;\n\tstruct siw_cep *cep = NULL;\n\tstruct socket *s = NULL;\n\tstruct sockaddr *laddr = (struct sockaddr *)&id->local_addr,\n\t\t\t*raddr = (struct sockaddr *)&id->remote_addr;\n\tbool p2p_mode = peer_to_peer, v4 = true;\n\tu16 pd_len = params->private_data_len;\n\tint version = mpa_version, rv;\n\n\tif (pd_len > MPA_MAX_PRIVDATA)\n\t\treturn -EINVAL;\n\n\tif (params->ird > sdev->attrs.max_ird ||\n\t    params->ord > sdev->attrs.max_ord)\n\t\treturn -ENOMEM;\n\n\tif (laddr->sa_family == AF_INET6)\n\t\tv4 = false;\n\telse if (laddr->sa_family != AF_INET)\n\t\treturn -EAFNOSUPPORT;\n\n\t \n\tif ((v4 && to_sockaddr_in(id->remote_addr).sin_port != 0) ||\n\t     to_sockaddr_in6(id->remote_addr).sin6_port != 0)\n\t\traddr = (struct sockaddr *)&id->m_remote_addr;\n\n\tqp = siw_qp_id2obj(sdev, params->qpn);\n\tif (!qp) {\n\t\tWARN(1, \"[QP %u] does not exist\\n\", params->qpn);\n\t\trv = -EINVAL;\n\t\tgoto error;\n\t}\n\tsiw_dbg_qp(qp, \"pd_len %d, laddr %pISp, raddr %pISp\\n\", pd_len, laddr,\n\t\t   raddr);\n\n\trv = sock_create(v4 ? AF_INET : AF_INET6, SOCK_STREAM, IPPROTO_TCP, &s);\n\tif (rv < 0)\n\t\tgoto error;\n\n\t \n\trv = kernel_bindconnect(s, laddr, raddr, id->afonly);\n\tif (rv != 0) {\n\t\tsiw_dbg_qp(qp, \"kernel_bindconnect: error %d\\n\", rv);\n\t\tgoto error;\n\t}\n\tif (siw_tcp_nagle == false)\n\t\ttcp_sock_set_nodelay(s->sk);\n\tcep = siw_cep_alloc(sdev);\n\tif (!cep) {\n\t\trv = -ENOMEM;\n\t\tgoto error;\n\t}\n\tsiw_cep_set_inuse(cep);\n\n\t \n\tsiw_cep_get(cep);\n\tqp->cep = cep;\n\n\t \n\tcep->qp = qp;\n\n\tid->add_ref(id);\n\tcep->cm_id = id;\n\n\t \n\trv = siw_cm_alloc_work(cep, 4);\n\tif (rv != 0) {\n\t\trv = -ENOMEM;\n\t\tgoto error;\n\t}\n\tcep->ird = params->ird;\n\tcep->ord = params->ord;\n\n\tif (p2p_mode && cep->ord == 0)\n\t\tcep->ord = 1;\n\n\tcep->state = SIW_EPSTATE_CONNECTING;\n\n\t \n\tsiw_cep_socket_assoc(cep, s);\n\n\tcep->state = SIW_EPSTATE_AWAIT_MPAREP;\n\n\t \n\tcep->mpa.hdr.params.bits = 0;\n\tif (version > MPA_REVISION_2) {\n\t\tpr_warn(\"Setting MPA version to %u\\n\", MPA_REVISION_2);\n\t\tversion = MPA_REVISION_2;\n\t\t \n\t\tmpa_version = MPA_REVISION_2;\n\t}\n\t__mpa_rr_set_revision(&cep->mpa.hdr.params.bits, version);\n\n\tif (try_gso)\n\t\tcep->mpa.hdr.params.bits |= MPA_RR_FLAG_GSO_EXP;\n\n\tif (mpa_crc_required)\n\t\tcep->mpa.hdr.params.bits |= MPA_RR_FLAG_CRC;\n\n\t \n\tif (version == MPA_REVISION_2) {\n\t\tcep->enhanced_rdma_conn_est = true;\n\t\tcep->mpa.hdr.params.bits |= MPA_RR_FLAG_ENHANCED;\n\n\t\tcep->mpa.v2_ctrl.ird = htons(cep->ird);\n\t\tcep->mpa.v2_ctrl.ord = htons(cep->ord);\n\n\t\tif (p2p_mode) {\n\t\t\tcep->mpa.v2_ctrl.ird |= MPA_V2_PEER_TO_PEER;\n\t\t\tcep->mpa.v2_ctrl.ord |= rtr_type;\n\t\t}\n\t\t \n\t\tcep->mpa.v2_ctrl_req.ird = cep->mpa.v2_ctrl.ird;\n\t\tcep->mpa.v2_ctrl_req.ord = cep->mpa.v2_ctrl.ord;\n\t}\n\tmemcpy(cep->mpa.hdr.key, MPA_KEY_REQ, 16);\n\n\trv = siw_send_mpareqrep(cep, params->private_data, pd_len);\n\t \n\tcep->mpa.hdr.params.pd_len = 0;\n\n\tif (rv >= 0) {\n\t\trv = siw_cm_queue_work(cep, SIW_CM_WORK_MPATIMEOUT);\n\t\tif (!rv) {\n\t\t\tsiw_dbg_cep(cep, \"[QP %u]: exit\\n\", qp_id(qp));\n\t\t\tsiw_cep_set_free(cep);\n\t\t\treturn 0;\n\t\t}\n\t}\nerror:\n\tsiw_dbg(id->device, \"failed: %d\\n\", rv);\n\n\tif (cep) {\n\t\tsiw_socket_disassoc(s);\n\t\tsock_release(s);\n\t\tcep->sock = NULL;\n\n\t\tcep->qp = NULL;\n\n\t\tcep->cm_id = NULL;\n\t\tid->rem_ref(id);\n\n\t\tqp->cep = NULL;\n\t\tsiw_cep_put(cep);\n\n\t\tcep->state = SIW_EPSTATE_CLOSED;\n\n\t\tsiw_cep_set_free(cep);\n\n\t\tsiw_cep_put(cep);\n\n\t} else if (s) {\n\t\tsock_release(s);\n\t}\n\tif (qp)\n\t\tsiw_qp_put(qp);\n\n\treturn rv;\n}\n\n \nint siw_accept(struct iw_cm_id *id, struct iw_cm_conn_param *params)\n{\n\tstruct siw_device *sdev = to_siw_dev(id->device);\n\tstruct siw_cep *cep = (struct siw_cep *)id->provider_data;\n\tstruct siw_qp *qp;\n\tstruct siw_qp_attrs qp_attrs;\n\tint rv, max_priv_data = MPA_MAX_PRIVDATA;\n\tbool wait_for_peer_rts = false;\n\n\tsiw_cep_set_inuse(cep);\n\tsiw_cep_put(cep);\n\n\t \n\tif (cep->mpa.hdr.params.pd_len) {\n\t\tcep->mpa.hdr.params.pd_len = 0;\n\t\tkfree(cep->mpa.pdata);\n\t\tcep->mpa.pdata = NULL;\n\t}\n\tsiw_cancel_mpatimer(cep);\n\n\tif (cep->state != SIW_EPSTATE_RECVD_MPAREQ) {\n\t\tsiw_dbg_cep(cep, \"out of state\\n\");\n\n\t\tsiw_cep_set_free(cep);\n\t\tsiw_cep_put(cep);\n\n\t\treturn -ECONNRESET;\n\t}\n\tqp = siw_qp_id2obj(sdev, params->qpn);\n\tif (!qp) {\n\t\tWARN(1, \"[QP %d] does not exist\\n\", params->qpn);\n\t\tsiw_cep_set_free(cep);\n\t\tsiw_cep_put(cep);\n\n\t\treturn -EINVAL;\n\t}\n\tdown_write(&qp->state_lock);\n\tif (qp->attrs.state > SIW_QP_STATE_RTR) {\n\t\trv = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\tsiw_dbg_cep(cep, \"[QP %d]\\n\", params->qpn);\n\n\tif (try_gso && cep->mpa.hdr.params.bits & MPA_RR_FLAG_GSO_EXP) {\n\t\tsiw_dbg_cep(cep, \"peer allows GSO on TX\\n\");\n\t\tqp->tx_ctx.gso_seg_limit = 0;\n\t}\n\tif (params->ord > sdev->attrs.max_ord ||\n\t    params->ird > sdev->attrs.max_ird) {\n\t\tsiw_dbg_cep(\n\t\t\tcep,\n\t\t\t\"[QP %u]: ord %d (max %d), ird %d (max %d)\\n\",\n\t\t\tqp_id(qp), params->ord, sdev->attrs.max_ord,\n\t\t\tparams->ird, sdev->attrs.max_ird);\n\t\trv = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\tif (cep->enhanced_rdma_conn_est)\n\t\tmax_priv_data -= sizeof(struct mpa_v2_data);\n\n\tif (params->private_data_len > max_priv_data) {\n\t\tsiw_dbg_cep(\n\t\t\tcep,\n\t\t\t\"[QP %u]: private data length: %d (max %d)\\n\",\n\t\t\tqp_id(qp), params->private_data_len, max_priv_data);\n\t\trv = -EINVAL;\n\t\tup_write(&qp->state_lock);\n\t\tgoto error;\n\t}\n\tif (cep->enhanced_rdma_conn_est) {\n\t\tif (params->ord > cep->ord) {\n\t\t\tif (relaxed_ird_negotiation) {\n\t\t\t\tparams->ord = cep->ord;\n\t\t\t} else {\n\t\t\t\tcep->ird = params->ird;\n\t\t\t\tcep->ord = params->ord;\n\t\t\t\trv = -EINVAL;\n\t\t\t\tup_write(&qp->state_lock);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (params->ird < cep->ird) {\n\t\t\tif (relaxed_ird_negotiation &&\n\t\t\t    cep->ird <= sdev->attrs.max_ird)\n\t\t\t\tparams->ird = cep->ird;\n\t\t\telse {\n\t\t\t\trv = -ENOMEM;\n\t\t\t\tup_write(&qp->state_lock);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tif (cep->mpa.v2_ctrl.ord &\n\t\t    (MPA_V2_RDMA_WRITE_RTR | MPA_V2_RDMA_READ_RTR))\n\t\t\twait_for_peer_rts = true;\n\t\t \n\t\tcep->mpa.v2_ctrl.ord =\n\t\t\thtons(params->ord & MPA_IRD_ORD_MASK) |\n\t\t\t(cep->mpa.v2_ctrl.ord & ~MPA_V2_MASK_IRD_ORD);\n\t\tcep->mpa.v2_ctrl.ird =\n\t\t\thtons(params->ird & MPA_IRD_ORD_MASK) |\n\t\t\t(cep->mpa.v2_ctrl.ird & ~MPA_V2_MASK_IRD_ORD);\n\t}\n\tcep->ird = params->ird;\n\tcep->ord = params->ord;\n\n\tcep->cm_id = id;\n\tid->add_ref(id);\n\n\tmemset(&qp_attrs, 0, sizeof(qp_attrs));\n\tqp_attrs.orq_size = cep->ord;\n\tqp_attrs.irq_size = cep->ird;\n\tqp_attrs.sk = cep->sock;\n\tif (cep->mpa.hdr.params.bits & MPA_RR_FLAG_CRC)\n\t\tqp_attrs.flags = SIW_MPA_CRC;\n\tqp_attrs.state = SIW_QP_STATE_RTS;\n\n\tsiw_dbg_cep(cep, \"[QP%u]: moving to rts\\n\", qp_id(qp));\n\n\t \n\tsiw_cep_get(cep);\n\tqp->cep = cep;\n\n\t \n\tcep->qp = qp;\n\n\tcep->state = SIW_EPSTATE_RDMA_MODE;\n\n\t \n\trv = siw_qp_modify(qp, &qp_attrs,\n\t\t\t   SIW_QP_ATTR_STATE | SIW_QP_ATTR_LLP_HANDLE |\n\t\t\t\t   SIW_QP_ATTR_ORD | SIW_QP_ATTR_IRD |\n\t\t\t\t   SIW_QP_ATTR_MPA);\n\tup_write(&qp->state_lock);\n\n\tif (rv)\n\t\tgoto error;\n\n\tsiw_dbg_cep(cep, \"[QP %u]: send mpa reply, %d byte pdata\\n\",\n\t\t    qp_id(qp), params->private_data_len);\n\n\trv = siw_send_mpareqrep(cep, params->private_data,\n\t\t\t\tparams->private_data_len);\n\tif (rv != 0)\n\t\tgoto error;\n\n\tif (wait_for_peer_rts) {\n\t\tsiw_sk_assign_rtr_upcalls(cep);\n\t} else {\n\t\tsiw_qp_socket_assoc(cep, qp);\n\t\trv = siw_cm_upcall(cep, IW_CM_EVENT_ESTABLISHED, 0);\n\t\tif (rv)\n\t\t\tgoto error;\n\t}\n\tsiw_cep_set_free(cep);\n\n\treturn 0;\nerror:\n\tsiw_socket_disassoc(cep->sock);\n\tsock_release(cep->sock);\n\tcep->sock = NULL;\n\n\tcep->state = SIW_EPSTATE_CLOSED;\n\n\tif (cep->cm_id) {\n\t\tcep->cm_id->rem_ref(id);\n\t\tcep->cm_id = NULL;\n\t}\n\tif (qp->cep) {\n\t\tsiw_cep_put(cep);\n\t\tqp->cep = NULL;\n\t}\n\tcep->qp = NULL;\n\tsiw_qp_put(qp);\n\n\tsiw_cep_set_free(cep);\n\tsiw_cep_put(cep);\n\n\treturn rv;\n}\n\n \nint siw_reject(struct iw_cm_id *id, const void *pdata, u8 pd_len)\n{\n\tstruct siw_cep *cep = (struct siw_cep *)id->provider_data;\n\n\tsiw_cep_set_inuse(cep);\n\tsiw_cep_put(cep);\n\n\tsiw_cancel_mpatimer(cep);\n\n\tif (cep->state != SIW_EPSTATE_RECVD_MPAREQ) {\n\t\tsiw_dbg_cep(cep, \"out of state\\n\");\n\n\t\tsiw_cep_set_free(cep);\n\t\tsiw_cep_put(cep);  \n\n\t\treturn -ECONNRESET;\n\t}\n\tsiw_dbg_cep(cep, \"cep->state %d, pd_len %d\\n\", cep->state,\n\t\t    pd_len);\n\n\tif (__mpa_rr_revision(cep->mpa.hdr.params.bits) >= MPA_REVISION_1) {\n\t\tcep->mpa.hdr.params.bits |= MPA_RR_FLAG_REJECT;  \n\t\tsiw_send_mpareqrep(cep, pdata, pd_len);\n\t}\n\tsiw_socket_disassoc(cep->sock);\n\tsock_release(cep->sock);\n\tcep->sock = NULL;\n\n\tcep->state = SIW_EPSTATE_CLOSED;\n\n\tsiw_cep_set_free(cep);\n\tsiw_cep_put(cep);\n\n\treturn 0;\n}\n\n \nint siw_create_listen(struct iw_cm_id *id, int backlog)\n{\n\tstruct socket *s;\n\tstruct siw_cep *cep = NULL;\n\tstruct siw_device *sdev = to_siw_dev(id->device);\n\tint addr_family = id->local_addr.ss_family;\n\tint rv = 0;\n\n\tif (addr_family != AF_INET && addr_family != AF_INET6)\n\t\treturn -EAFNOSUPPORT;\n\n\trv = sock_create(addr_family, SOCK_STREAM, IPPROTO_TCP, &s);\n\tif (rv < 0)\n\t\treturn rv;\n\n\t \n\tsock_set_reuseaddr(s->sk);\n\n\tif (addr_family == AF_INET) {\n\t\tstruct sockaddr_in *laddr = &to_sockaddr_in(id->local_addr);\n\n\t\t \n\t\tif (ipv4_is_zeronet(laddr->sin_addr.s_addr))\n\t\t\ts->sk->sk_bound_dev_if = sdev->netdev->ifindex;\n\n\t\trv = s->ops->bind(s, (struct sockaddr *)laddr,\n\t\t\t\t  sizeof(struct sockaddr_in));\n\t} else {\n\t\tstruct sockaddr_in6 *laddr = &to_sockaddr_in6(id->local_addr);\n\n\t\tif (id->afonly) {\n\t\t\trv = ip6_sock_set_v6only(s->sk);\n\t\t\tif (rv) {\n\t\t\t\tsiw_dbg(id->device,\n\t\t\t\t\t\"ip6_sock_set_v6only erro: %d\\n\", rv);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ipv6_addr_any(&laddr->sin6_addr))\n\t\t\ts->sk->sk_bound_dev_if = sdev->netdev->ifindex;\n\n\t\trv = s->ops->bind(s, (struct sockaddr *)laddr,\n\t\t\t\t  sizeof(struct sockaddr_in6));\n\t}\n\tif (rv) {\n\t\tsiw_dbg(id->device, \"socket bind error: %d\\n\", rv);\n\t\tgoto error;\n\t}\n\tcep = siw_cep_alloc(sdev);\n\tif (!cep) {\n\t\trv = -ENOMEM;\n\t\tgoto error;\n\t}\n\tsiw_cep_socket_assoc(cep, s);\n\n\trv = siw_cm_alloc_work(cep, backlog);\n\tif (rv) {\n\t\tsiw_dbg(id->device,\n\t\t\t\"alloc_work error %d, backlog %d\\n\",\n\t\t\trv, backlog);\n\t\tgoto error;\n\t}\n\trv = s->ops->listen(s, backlog);\n\tif (rv) {\n\t\tsiw_dbg(id->device, \"listen error %d\\n\", rv);\n\t\tgoto error;\n\t}\n\tcep->cm_id = id;\n\tid->add_ref(id);\n\n\t \n\tif (!id->provider_data) {\n\t\tid->provider_data =\n\t\t\tkmalloc(sizeof(struct list_head), GFP_KERNEL);\n\t\tif (!id->provider_data) {\n\t\t\trv = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tINIT_LIST_HEAD((struct list_head *)id->provider_data);\n\t}\n\tlist_add_tail(&cep->listenq, (struct list_head *)id->provider_data);\n\tcep->state = SIW_EPSTATE_LISTENING;\n\n\tsiw_dbg(id->device, \"Listen at laddr %pISp\\n\", &id->local_addr);\n\n\treturn 0;\n\nerror:\n\tsiw_dbg(id->device, \"failed: %d\\n\", rv);\n\n\tif (cep) {\n\t\tsiw_cep_set_inuse(cep);\n\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t}\n\t\tcep->sock = NULL;\n\t\tsiw_socket_disassoc(s);\n\t\tcep->state = SIW_EPSTATE_CLOSED;\n\n\t\tsiw_cep_set_free(cep);\n\t\tsiw_cep_put(cep);\n\t}\n\tsock_release(s);\n\n\treturn rv;\n}\n\nstatic void siw_drop_listeners(struct iw_cm_id *id)\n{\n\tstruct list_head *p, *tmp;\n\n\t \n\tlist_for_each_safe(p, tmp, (struct list_head *)id->provider_data) {\n\t\tstruct siw_cep *cep = list_entry(p, struct siw_cep, listenq);\n\n\t\tlist_del(p);\n\n\t\tsiw_dbg_cep(cep, \"drop cep, state %d\\n\", cep->state);\n\n\t\tsiw_cep_set_inuse(cep);\n\n\t\tif (cep->cm_id) {\n\t\t\tcep->cm_id->rem_ref(cep->cm_id);\n\t\t\tcep->cm_id = NULL;\n\t\t}\n\t\tif (cep->sock) {\n\t\t\tsiw_socket_disassoc(cep->sock);\n\t\t\tsock_release(cep->sock);\n\t\t\tcep->sock = NULL;\n\t\t}\n\t\tcep->state = SIW_EPSTATE_CLOSED;\n\t\tsiw_cep_set_free(cep);\n\t\tsiw_cep_put(cep);\n\t}\n}\n\nint siw_destroy_listen(struct iw_cm_id *id)\n{\n\tif (!id->provider_data) {\n\t\tsiw_dbg(id->device, \"no cep(s)\\n\");\n\t\treturn 0;\n\t}\n\tsiw_drop_listeners(id);\n\tkfree(id->provider_data);\n\tid->provider_data = NULL;\n\n\treturn 0;\n}\n\nint siw_cm_init(void)\n{\n\t \n\tsiw_cm_wq = create_singlethread_workqueue(\"siw_cm_wq\");\n\tif (!siw_cm_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid siw_cm_exit(void)\n{\n\tif (siw_cm_wq)\n\t\tdestroy_workqueue(siw_cm_wq);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}