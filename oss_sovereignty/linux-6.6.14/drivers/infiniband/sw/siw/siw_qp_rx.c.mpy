{
  "module_name": "siw_qp_rx.c",
  "hash_id": "bcac8b5e39d1570c49e7f333a993e97957d1ebefc0b1075e10a99858e1e54d61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_qp_rx.c",
  "human_readable_source": "\n\n \n \n\n#include <linux/errno.h>\n#include <linux/types.h>\n#include <linux/net.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n\n#include <rdma/iw_cm.h>\n#include <rdma/ib_verbs.h>\n\n#include \"siw.h\"\n#include \"siw_verbs.h\"\n#include \"siw_mem.h\"\n\n \nstatic int siw_rx_umem(struct siw_rx_stream *srx, struct siw_umem *umem,\n\t\t       u64 dest_addr, int len)\n{\n\tint copied = 0;\n\n\twhile (len) {\n\t\tstruct page *p;\n\t\tint pg_off, bytes, rv;\n\t\tvoid *dest;\n\n\t\tp = siw_get_upage(umem, dest_addr);\n\t\tif (unlikely(!p)) {\n\t\t\tpr_warn(\"siw: %s: [QP %u]: bogus addr: %pK, %pK\\n\",\n\t\t\t\t__func__, qp_id(rx_qp(srx)),\n\t\t\t\t(void *)(uintptr_t)dest_addr,\n\t\t\t\t(void *)(uintptr_t)umem->fp_addr);\n\t\t\t \n\t\t\tsrx->skb_copied += copied;\n\t\t\tsrx->skb_new -= copied;\n\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tpg_off = dest_addr & ~PAGE_MASK;\n\t\tbytes = min(len, (int)PAGE_SIZE - pg_off);\n\n\t\tsiw_dbg_qp(rx_qp(srx), \"page %pK, bytes=%u\\n\", p, bytes);\n\n\t\tdest = kmap_atomic(p);\n\t\trv = skb_copy_bits(srx->skb, srx->skb_offset, dest + pg_off,\n\t\t\t\t   bytes);\n\n\t\tif (unlikely(rv)) {\n\t\t\tkunmap_atomic(dest);\n\t\t\tsrx->skb_copied += copied;\n\t\t\tsrx->skb_new -= copied;\n\n\t\t\tpr_warn(\"siw: [QP %u]: %s, len %d, page %p, rv %d\\n\",\n\t\t\t\tqp_id(rx_qp(srx)), __func__, len, p, rv);\n\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tif (srx->mpa_crc_hd) {\n\t\t\tif (rdma_is_kernel_res(&rx_qp(srx)->base_qp.res)) {\n\t\t\t\tcrypto_shash_update(srx->mpa_crc_hd,\n\t\t\t\t\t(u8 *)(dest + pg_off), bytes);\n\t\t\t\tkunmap_atomic(dest);\n\t\t\t} else {\n\t\t\t\tkunmap_atomic(dest);\n\t\t\t\t \n\t\t\t\tsiw_crc_skb(srx, bytes);\n\t\t\t}\n\t\t} else {\n\t\t\tkunmap_atomic(dest);\n\t\t}\n\t\tsrx->skb_offset += bytes;\n\t\tcopied += bytes;\n\t\tlen -= bytes;\n\t\tdest_addr += bytes;\n\t\tpg_off = 0;\n\t}\n\tsrx->skb_copied += copied;\n\tsrx->skb_new -= copied;\n\n\treturn copied;\n}\n\nstatic int siw_rx_kva(struct siw_rx_stream *srx, void *kva, int len)\n{\n\tint rv;\n\n\tsiw_dbg_qp(rx_qp(srx), \"kva: 0x%pK, len: %u\\n\", kva, len);\n\n\trv = skb_copy_bits(srx->skb, srx->skb_offset, kva, len);\n\tif (unlikely(rv)) {\n\t\tpr_warn(\"siw: [QP %u]: %s, len %d, kva 0x%pK, rv %d\\n\",\n\t\t\tqp_id(rx_qp(srx)), __func__, len, kva, rv);\n\n\t\treturn rv;\n\t}\n\tif (srx->mpa_crc_hd)\n\t\tcrypto_shash_update(srx->mpa_crc_hd, (u8 *)kva, len);\n\n\tsrx->skb_offset += len;\n\tsrx->skb_copied += len;\n\tsrx->skb_new -= len;\n\n\treturn len;\n}\n\nstatic int siw_rx_pbl(struct siw_rx_stream *srx, int *pbl_idx,\n\t\t      struct siw_mem *mem, u64 addr, int len)\n{\n\tstruct siw_pbl *pbl = mem->pbl;\n\tu64 offset = addr - mem->va;\n\tint copied = 0;\n\n\twhile (len) {\n\t\tint bytes;\n\t\tdma_addr_t buf_addr =\n\t\t\tsiw_pbl_get_buffer(pbl, offset, &bytes, pbl_idx);\n\t\tif (!buf_addr)\n\t\t\tbreak;\n\n\t\tbytes = min(bytes, len);\n\t\tif (siw_rx_kva(srx, ib_virt_dma_to_ptr(buf_addr), bytes) ==\n\t\t    bytes) {\n\t\t\tcopied += bytes;\n\t\t\toffset += bytes;\n\t\t\tlen -= bytes;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn copied;\n}\n\n \nstatic int siw_rresp_check_ntoh(struct siw_rx_stream *srx,\n\t\t\t\tstruct siw_rx_fpdu *frx)\n{\n\tstruct iwarp_rdma_rresp *rresp = &srx->hdr.rresp;\n\tstruct siw_wqe *wqe = &frx->wqe_active;\n\tenum ddp_ecode ecode;\n\n\tu32 sink_stag = be32_to_cpu(rresp->sink_stag);\n\tu64 sink_to = be64_to_cpu(rresp->sink_to);\n\n\tif (frx->first_ddp_seg) {\n\t\tsrx->ddp_stag = wqe->sqe.sge[0].lkey;\n\t\tsrx->ddp_to = wqe->sqe.sge[0].laddr;\n\t\tfrx->pbl_idx = 0;\n\t}\n\t \n\tif (unlikely(srx->ddp_stag != sink_stag)) {\n\t\tpr_warn(\"siw: [QP %u]: rresp stag: %08x != %08x\\n\",\n\t\t\tqp_id(rx_qp(srx)), sink_stag, srx->ddp_stag);\n\t\tecode = DDP_ECODE_T_INVALID_STAG;\n\t\tgoto error;\n\t}\n\tif (unlikely(srx->ddp_to != sink_to)) {\n\t\tpr_warn(\"siw: [QP %u]: rresp off: %016llx != %016llx\\n\",\n\t\t\tqp_id(rx_qp(srx)), (unsigned long long)sink_to,\n\t\t\t(unsigned long long)srx->ddp_to);\n\t\tecode = DDP_ECODE_T_BASE_BOUNDS;\n\t\tgoto error;\n\t}\n\tif (unlikely(!frx->more_ddp_segs &&\n\t\t     (wqe->processed + srx->fpdu_part_rem != wqe->bytes))) {\n\t\tpr_warn(\"siw: [QP %u]: rresp len: %d != %d\\n\",\n\t\t\tqp_id(rx_qp(srx)),\n\t\t\twqe->processed + srx->fpdu_part_rem, wqe->bytes);\n\t\tecode = DDP_ECODE_T_BASE_BOUNDS;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_DDP,\n\t\t\t   DDP_ETYPE_TAGGED_BUF, ecode, 0);\n\treturn -EINVAL;\n}\n\n \nstatic int siw_write_check_ntoh(struct siw_rx_stream *srx,\n\t\t\t\tstruct siw_rx_fpdu *frx)\n{\n\tstruct iwarp_rdma_write *write = &srx->hdr.rwrite;\n\tenum ddp_ecode ecode;\n\n\tu32 sink_stag = be32_to_cpu(write->sink_stag);\n\tu64 sink_to = be64_to_cpu(write->sink_to);\n\n\tif (frx->first_ddp_seg) {\n\t\tsrx->ddp_stag = sink_stag;\n\t\tsrx->ddp_to = sink_to;\n\t\tfrx->pbl_idx = 0;\n\t} else {\n\t\tif (unlikely(srx->ddp_stag != sink_stag)) {\n\t\t\tpr_warn(\"siw: [QP %u]: write stag: %08x != %08x\\n\",\n\t\t\t\tqp_id(rx_qp(srx)), sink_stag,\n\t\t\t\tsrx->ddp_stag);\n\t\t\tecode = DDP_ECODE_T_INVALID_STAG;\n\t\t\tgoto error;\n\t\t}\n\t\tif (unlikely(srx->ddp_to != sink_to)) {\n\t\t\tpr_warn(\"siw: [QP %u]: write off: %016llx != %016llx\\n\",\n\t\t\t\tqp_id(rx_qp(srx)),\n\t\t\t\t(unsigned long long)sink_to,\n\t\t\t\t(unsigned long long)srx->ddp_to);\n\t\t\tecode = DDP_ECODE_T_BASE_BOUNDS;\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn 0;\nerror:\n\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_DDP,\n\t\t\t   DDP_ETYPE_TAGGED_BUF, ecode, 0);\n\treturn -EINVAL;\n}\n\n \nstatic int siw_send_check_ntoh(struct siw_rx_stream *srx,\n\t\t\t       struct siw_rx_fpdu *frx)\n{\n\tstruct iwarp_send_inv *send = &srx->hdr.send_inv;\n\tstruct siw_wqe *wqe = &frx->wqe_active;\n\tenum ddp_ecode ecode;\n\n\tu32 ddp_msn = be32_to_cpu(send->ddp_msn);\n\tu32 ddp_mo = be32_to_cpu(send->ddp_mo);\n\tu32 ddp_qn = be32_to_cpu(send->ddp_qn);\n\n\tif (unlikely(ddp_qn != RDMAP_UNTAGGED_QN_SEND)) {\n\t\tpr_warn(\"siw: [QP %u]: invalid ddp qn %d for send\\n\",\n\t\t\tqp_id(rx_qp(srx)), ddp_qn);\n\t\tecode = DDP_ECODE_UT_INVALID_QN;\n\t\tgoto error;\n\t}\n\tif (unlikely(ddp_msn != srx->ddp_msn[RDMAP_UNTAGGED_QN_SEND])) {\n\t\tpr_warn(\"siw: [QP %u]: send msn: %u != %u\\n\",\n\t\t\tqp_id(rx_qp(srx)), ddp_msn,\n\t\t\tsrx->ddp_msn[RDMAP_UNTAGGED_QN_SEND]);\n\t\tecode = DDP_ECODE_UT_INVALID_MSN_RANGE;\n\t\tgoto error;\n\t}\n\tif (unlikely(ddp_mo != wqe->processed)) {\n\t\tpr_warn(\"siw: [QP %u], send mo: %u != %u\\n\",\n\t\t\tqp_id(rx_qp(srx)), ddp_mo, wqe->processed);\n\t\tecode = DDP_ECODE_UT_INVALID_MO;\n\t\tgoto error;\n\t}\n\tif (frx->first_ddp_seg) {\n\t\t \n\t\tfrx->sge_idx = 0;\n\t\tfrx->sge_off = 0;\n\t\tfrx->pbl_idx = 0;\n\n\t\t \n\t\tsrx->inval_stag = be32_to_cpu(send->inval_stag);\n\t}\n\tif (unlikely(wqe->bytes < wqe->processed + srx->fpdu_part_rem)) {\n\t\tsiw_dbg_qp(rx_qp(srx), \"receive space short: %d - %d < %d\\n\",\n\t\t\t   wqe->bytes, wqe->processed, srx->fpdu_part_rem);\n\t\twqe->wc_status = SIW_WC_LOC_LEN_ERR;\n\t\tecode = DDP_ECODE_UT_INVALID_MSN_NOBUF;\n\t\tgoto error;\n\t}\n\treturn 0;\nerror:\n\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_DDP,\n\t\t\t   DDP_ETYPE_UNTAGGED_BUF, ecode, 0);\n\treturn -EINVAL;\n}\n\nstatic struct siw_wqe *siw_rqe_get(struct siw_qp *qp)\n{\n\tstruct siw_rqe *rqe;\n\tstruct siw_srq *srq;\n\tstruct siw_wqe *wqe = NULL;\n\tbool srq_event = false;\n\tunsigned long flags;\n\n\tsrq = qp->srq;\n\tif (srq) {\n\t\tspin_lock_irqsave(&srq->lock, flags);\n\t\tif (unlikely(!srq->num_rqe))\n\t\t\tgoto out;\n\n\t\trqe = &srq->recvq[srq->rq_get % srq->num_rqe];\n\t} else {\n\t\tif (unlikely(!qp->recvq))\n\t\t\tgoto out;\n\n\t\trqe = &qp->recvq[qp->rq_get % qp->attrs.rq_size];\n\t}\n\tif (likely(rqe->flags == SIW_WQE_VALID)) {\n\t\tint num_sge = rqe->num_sge;\n\n\t\tif (likely(num_sge <= SIW_MAX_SGE)) {\n\t\t\tint i = 0;\n\n\t\t\twqe = rx_wqe(&qp->rx_untagged);\n\t\t\trx_type(wqe) = SIW_OP_RECEIVE;\n\t\t\twqe->wr_status = SIW_WR_INPROGRESS;\n\t\t\twqe->bytes = 0;\n\t\t\twqe->processed = 0;\n\n\t\t\twqe->rqe.id = rqe->id;\n\t\t\twqe->rqe.num_sge = num_sge;\n\n\t\t\twhile (i < num_sge) {\n\t\t\t\twqe->rqe.sge[i].laddr = rqe->sge[i].laddr;\n\t\t\t\twqe->rqe.sge[i].lkey = rqe->sge[i].lkey;\n\t\t\t\twqe->rqe.sge[i].length = rqe->sge[i].length;\n\t\t\t\twqe->bytes += wqe->rqe.sge[i].length;\n\t\t\t\twqe->mem[i] = NULL;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t \n\t\t\tsmp_store_mb(rqe->flags, 0);\n\t\t} else {\n\t\t\tsiw_dbg_qp(qp, \"too many sge's: %d\\n\", rqe->num_sge);\n\t\t\tif (srq)\n\t\t\t\tspin_unlock_irqrestore(&srq->lock, flags);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!srq) {\n\t\t\tqp->rq_get++;\n\t\t} else {\n\t\t\tif (srq->armed) {\n\t\t\t\t \n\t\t\t\tu32 off = (srq->rq_get + srq->limit) %\n\t\t\t\t\t  srq->num_rqe;\n\t\t\t\tstruct siw_rqe *rqe2 = &srq->recvq[off];\n\n\t\t\t\tif (!(rqe2->flags & SIW_WQE_VALID)) {\n\t\t\t\t\tsrq->armed = false;\n\t\t\t\t\tsrq_event = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrq->rq_get++;\n\t\t}\n\t}\nout:\n\tif (srq) {\n\t\tspin_unlock_irqrestore(&srq->lock, flags);\n\t\tif (srq_event)\n\t\t\tsiw_srq_event(srq, IB_EVENT_SRQ_LIMIT_REACHED);\n\t}\n\treturn wqe;\n}\n\n \nint siw_proc_send(struct siw_qp *qp)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tstruct siw_rx_fpdu *frx = &qp->rx_untagged;\n\tstruct siw_wqe *wqe;\n\tu32 data_bytes;  \n\tu32 rcvd_bytes;  \n\tint rv = 0;\n\n\tif (frx->first_ddp_seg) {\n\t\twqe = siw_rqe_get(qp);\n\t\tif (unlikely(!wqe)) {\n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   DDP_ETYPE_UNTAGGED_BUF,\n\t\t\t\t\t   DDP_ECODE_UT_INVALID_MSN_NOBUF, 0);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else {\n\t\twqe = rx_wqe(frx);\n\t}\n\tif (srx->state == SIW_GET_DATA_START) {\n\t\trv = siw_send_check_ntoh(srx, frx);\n\t\tif (unlikely(rv)) {\n\t\t\tsiw_qp_event(qp, IB_EVENT_QP_FATAL);\n\t\t\treturn rv;\n\t\t}\n\t\tif (!srx->fpdu_part_rem)  \n\t\t\treturn 0;\n\t}\n\tdata_bytes = min(srx->fpdu_part_rem, srx->skb_new);\n\trcvd_bytes = 0;\n\n\t \n\twhile (data_bytes) {\n\t\tstruct ib_pd *pd;\n\t\tstruct siw_mem **mem, *mem_p;\n\t\tstruct siw_sge *sge;\n\t\tu32 sge_bytes;  \n\n\t\tsge = &wqe->rqe.sge[frx->sge_idx];\n\n\t\tif (!sge->length) {\n\t\t\t \n\t\t\tfrx->sge_idx++;\n\t\t\tfrx->sge_off = 0;\n\t\t\tfrx->pbl_idx = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tsge_bytes = min(data_bytes, sge->length - frx->sge_off);\n\t\tmem = &wqe->mem[frx->sge_idx];\n\n\t\t \n\t\tpd = qp->srq == NULL ? qp->pd : qp->srq->base_srq.pd;\n\n\t\trv = siw_check_sge(pd, sge, mem, IB_ACCESS_LOCAL_WRITE,\n\t\t\t\t   frx->sge_off, sge_bytes);\n\t\tif (unlikely(rv)) {\n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   DDP_ETYPE_CATASTROPHIC,\n\t\t\t\t\t   DDP_ECODE_CATASTROPHIC, 0);\n\n\t\t\tsiw_qp_event(qp, IB_EVENT_QP_ACCESS_ERR);\n\t\t\tbreak;\n\t\t}\n\t\tmem_p = *mem;\n\t\tif (mem_p->mem_obj == NULL)\n\t\t\trv = siw_rx_kva(srx,\n\t\t\t\tib_virt_dma_to_ptr(sge->laddr + frx->sge_off),\n\t\t\t\tsge_bytes);\n\t\telse if (!mem_p->is_pbl)\n\t\t\trv = siw_rx_umem(srx, mem_p->umem,\n\t\t\t\t\t sge->laddr + frx->sge_off, sge_bytes);\n\t\telse\n\t\t\trv = siw_rx_pbl(srx, &frx->pbl_idx, mem_p,\n\t\t\t\t\tsge->laddr + frx->sge_off, sge_bytes);\n\n\t\tif (unlikely(rv != sge_bytes)) {\n\t\t\twqe->processed += rcvd_bytes;\n\n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   DDP_ETYPE_CATASTROPHIC,\n\t\t\t\t\t   DDP_ECODE_CATASTROPHIC, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfrx->sge_off += rv;\n\n\t\tif (frx->sge_off == sge->length) {\n\t\t\tfrx->sge_idx++;\n\t\t\tfrx->sge_off = 0;\n\t\t\tfrx->pbl_idx = 0;\n\t\t}\n\t\tdata_bytes -= rv;\n\t\trcvd_bytes += rv;\n\n\t\tsrx->fpdu_part_rem -= rv;\n\t\tsrx->fpdu_part_rcvd += rv;\n\t}\n\twqe->processed += rcvd_bytes;\n\n\tif (!srx->fpdu_part_rem)\n\t\treturn 0;\n\n\treturn (rv < 0) ? rv : -EAGAIN;\n}\n\n \nint siw_proc_write(struct siw_qp *qp)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tstruct siw_rx_fpdu *frx = &qp->rx_tagged;\n\tstruct siw_mem *mem;\n\tint bytes, rv;\n\n\tif (srx->state == SIW_GET_DATA_START) {\n\t\tif (!srx->fpdu_part_rem)  \n\t\t\treturn 0;\n\n\t\trv = siw_write_check_ntoh(srx, frx);\n\t\tif (unlikely(rv)) {\n\t\t\tsiw_qp_event(qp, IB_EVENT_QP_FATAL);\n\t\t\treturn rv;\n\t\t}\n\t}\n\tbytes = min(srx->fpdu_part_rem, srx->skb_new);\n\n\tif (frx->first_ddp_seg) {\n\t\tstruct siw_wqe *wqe = rx_wqe(frx);\n\n\t\trx_mem(frx) = siw_mem_id2obj(qp->sdev, srx->ddp_stag >> 8);\n\t\tif (unlikely(!rx_mem(frx))) {\n\t\t\tsiw_dbg_qp(qp,\n\t\t\t\t   \"sink stag not found/invalid, stag 0x%08x\\n\",\n\t\t\t\t   srx->ddp_stag);\n\n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   DDP_ETYPE_TAGGED_BUF,\n\t\t\t\t\t   DDP_ECODE_T_INVALID_STAG, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twqe->rqe.num_sge = 1;\n\t\trx_type(wqe) = SIW_OP_WRITE;\n\t\twqe->wr_status = SIW_WR_INPROGRESS;\n\t}\n\tmem = rx_mem(frx);\n\n\t \n\tif (unlikely(mem->stag != srx->ddp_stag)) {\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t   DDP_ETYPE_TAGGED_BUF,\n\t\t\t\t   DDP_ECODE_T_INVALID_STAG, 0);\n\t\treturn -EINVAL;\n\t}\n\trv = siw_check_mem(qp->pd, mem, srx->ddp_to + srx->fpdu_part_rcvd,\n\t\t\t   IB_ACCESS_REMOTE_WRITE, bytes);\n\tif (unlikely(rv)) {\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t   DDP_ETYPE_TAGGED_BUF, siw_tagged_error(-rv),\n\t\t\t\t   0);\n\n\t\tsiw_qp_event(qp, IB_EVENT_QP_ACCESS_ERR);\n\n\t\treturn -EINVAL;\n\t}\n\n\tif (mem->mem_obj == NULL)\n\t\trv = siw_rx_kva(srx,\n\t\t\t(void *)(uintptr_t)(srx->ddp_to + srx->fpdu_part_rcvd),\n\t\t\tbytes);\n\telse if (!mem->is_pbl)\n\t\trv = siw_rx_umem(srx, mem->umem,\n\t\t\t\t srx->ddp_to + srx->fpdu_part_rcvd, bytes);\n\telse\n\t\trv = siw_rx_pbl(srx, &frx->pbl_idx, mem,\n\t\t\t\tsrx->ddp_to + srx->fpdu_part_rcvd, bytes);\n\n\tif (unlikely(rv != bytes)) {\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t   DDP_ETYPE_CATASTROPHIC,\n\t\t\t\t   DDP_ECODE_CATASTROPHIC, 0);\n\t\treturn -EINVAL;\n\t}\n\tsrx->fpdu_part_rem -= rv;\n\tsrx->fpdu_part_rcvd += rv;\n\n\tif (!srx->fpdu_part_rem) {\n\t\tsrx->ddp_to += srx->fpdu_part_rcvd;\n\t\treturn 0;\n\t}\n\treturn -EAGAIN;\n}\n\n \nint siw_proc_rreq(struct siw_qp *qp)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\n\tif (!srx->fpdu_part_rem)\n\t\treturn 0;\n\n\tpr_warn(\"siw: [QP %u]: rreq with mpa len %d\\n\", qp_id(qp),\n\t\tbe16_to_cpu(srx->hdr.ctrl.mpa_len));\n\n\treturn -EPROTO;\n}\n\n \n\nstatic int siw_init_rresp(struct siw_qp *qp, struct siw_rx_stream *srx)\n{\n\tstruct siw_wqe *tx_work = tx_wqe(qp);\n\tstruct siw_sqe *resp;\n\n\tuint64_t raddr = be64_to_cpu(srx->hdr.rreq.sink_to),\n\t\t laddr = be64_to_cpu(srx->hdr.rreq.source_to);\n\tuint32_t length = be32_to_cpu(srx->hdr.rreq.read_size),\n\t\t lkey = be32_to_cpu(srx->hdr.rreq.source_stag),\n\t\t rkey = be32_to_cpu(srx->hdr.rreq.sink_stag),\n\t\t msn = be32_to_cpu(srx->hdr.rreq.ddp_msn);\n\n\tint run_sq = 1, rv = 0;\n\tunsigned long flags;\n\n\tif (unlikely(msn != srx->ddp_msn[RDMAP_UNTAGGED_QN_RDMA_READ])) {\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t   DDP_ETYPE_UNTAGGED_BUF,\n\t\t\t\t   DDP_ECODE_UT_INVALID_MSN_RANGE, 0);\n\t\treturn -EPROTO;\n\t}\n\tspin_lock_irqsave(&qp->sq_lock, flags);\n\n\tif (unlikely(!qp->attrs.irq_size)) {\n\t\trun_sq = 0;\n\t\tgoto error_irq;\n\t}\n\tif (tx_work->wr_status == SIW_WR_IDLE) {\n\t\t \n\t\ttx_work->processed = 0;\n\t\ttx_work->mem[0] = NULL;\n\t\ttx_work->wr_status = SIW_WR_QUEUED;\n\t\tresp = &tx_work->sqe;\n\t} else {\n\t\tresp = irq_alloc_free(qp);\n\t\trun_sq = 0;\n\t}\n\tif (likely(resp)) {\n\t\tresp->opcode = SIW_OP_READ_RESPONSE;\n\n\t\tresp->sge[0].length = length;\n\t\tresp->sge[0].laddr = laddr;\n\t\tresp->sge[0].lkey = lkey;\n\n\t\t \n\t\tresp->sge[1].length = msn;\n\n\t\tresp->raddr = raddr;\n\t\tresp->rkey = rkey;\n\t\tresp->num_sge = length ? 1 : 0;\n\n\t\t \n\t\tsmp_store_mb(resp->flags, SIW_WQE_VALID);\n\t} else {\nerror_irq:\n\t\tpr_warn(\"siw: [QP %u]: IRQ exceeded or null, size %d\\n\",\n\t\t\tqp_id(qp), qp->attrs.irq_size);\n\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_RDMAP,\n\t\t\t\t   RDMAP_ETYPE_REMOTE_OPERATION,\n\t\t\t\t   RDMAP_ECODE_CATASTROPHIC_STREAM, 0);\n\t\trv = -EPROTO;\n\t}\n\n\tspin_unlock_irqrestore(&qp->sq_lock, flags);\n\n\tif (run_sq)\n\t\trv = siw_sq_start(qp);\n\n\treturn rv;\n}\n\n \nstatic int siw_orqe_start_rx(struct siw_qp *qp)\n{\n\tstruct siw_sqe *orqe;\n\tstruct siw_wqe *wqe = NULL;\n\n\tif (unlikely(!qp->attrs.orq_size))\n\t\treturn -EPROTO;\n\n\t \n\tsmp_mb();\n\n\torqe = orq_get_current(qp);\n\tif (READ_ONCE(orqe->flags) & SIW_WQE_VALID) {\n\t\t \n\t\twqe = rx_wqe(&qp->rx_tagged);\n\t\twqe->sqe.id = orqe->id;\n\t\twqe->sqe.opcode = orqe->opcode;\n\t\twqe->sqe.sge[0].laddr = orqe->sge[0].laddr;\n\t\twqe->sqe.sge[0].lkey = orqe->sge[0].lkey;\n\t\twqe->sqe.sge[0].length = orqe->sge[0].length;\n\t\twqe->sqe.flags = orqe->flags;\n\t\twqe->sqe.num_sge = 1;\n\t\twqe->bytes = orqe->sge[0].length;\n\t\twqe->processed = 0;\n\t\twqe->mem[0] = NULL;\n\t\t \n\t\tsmp_wmb();\n\t\twqe->wr_status = SIW_WR_INPROGRESS;\n\n\t\treturn 0;\n\t}\n\treturn -EPROTO;\n}\n\n \nint siw_proc_rresp(struct siw_qp *qp)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tstruct siw_rx_fpdu *frx = &qp->rx_tagged;\n\tstruct siw_wqe *wqe = rx_wqe(frx);\n\tstruct siw_mem **mem, *mem_p;\n\tstruct siw_sge *sge;\n\tint bytes, rv;\n\n\tif (frx->first_ddp_seg) {\n\t\tif (unlikely(wqe->wr_status != SIW_WR_IDLE)) {\n\t\t\tpr_warn(\"siw: [QP %u]: proc RRESP: status %d, op %d\\n\",\n\t\t\t\tqp_id(qp), wqe->wr_status, wqe->sqe.opcode);\n\t\t\trv = -EPROTO;\n\t\t\tgoto error_term;\n\t\t}\n\t\t \n\t\trv = siw_orqe_start_rx(qp);\n\t\tif (rv) {\n\t\t\tpr_warn(\"siw: [QP %u]: ORQ empty, size %d\\n\",\n\t\t\t\tqp_id(qp), qp->attrs.orq_size);\n\t\t\tgoto error_term;\n\t\t}\n\t\trv = siw_rresp_check_ntoh(srx, frx);\n\t\tif (unlikely(rv)) {\n\t\t\tsiw_qp_event(qp, IB_EVENT_QP_FATAL);\n\t\t\treturn rv;\n\t\t}\n\t} else {\n\t\tif (unlikely(wqe->wr_status != SIW_WR_INPROGRESS)) {\n\t\t\tpr_warn(\"siw: [QP %u]: resume RRESP: status %d\\n\",\n\t\t\t\tqp_id(qp), wqe->wr_status);\n\t\t\trv = -EPROTO;\n\t\t\tgoto error_term;\n\t\t}\n\t}\n\tif (!srx->fpdu_part_rem)  \n\t\treturn 0;\n\n\tsge = wqe->sqe.sge;  \n\tmem = &wqe->mem[0];\n\n\tif (!(*mem)) {\n\t\t \n\t\trv = siw_check_sge(qp->pd, sge, mem, IB_ACCESS_LOCAL_WRITE, 0,\n\t\t\t\t   wqe->bytes);\n\t\tif (unlikely(rv)) {\n\t\t\tsiw_dbg_qp(qp, \"target mem check: %d\\n\", rv);\n\t\t\twqe->wc_status = SIW_WC_LOC_PROT_ERR;\n\n\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   DDP_ETYPE_TAGGED_BUF,\n\t\t\t\t\t   siw_tagged_error(-rv), 0);\n\n\t\t\tsiw_qp_event(qp, IB_EVENT_QP_ACCESS_ERR);\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tmem_p = *mem;\n\n\tbytes = min(srx->fpdu_part_rem, srx->skb_new);\n\n\tif (mem_p->mem_obj == NULL)\n\t\trv = siw_rx_kva(srx,\n\t\t\tib_virt_dma_to_ptr(sge->laddr + wqe->processed),\n\t\t\tbytes);\n\telse if (!mem_p->is_pbl)\n\t\trv = siw_rx_umem(srx, mem_p->umem, sge->laddr + wqe->processed,\n\t\t\t\t bytes);\n\telse\n\t\trv = siw_rx_pbl(srx, &frx->pbl_idx, mem_p,\n\t\t\t\tsge->laddr + wqe->processed, bytes);\n\tif (rv != bytes) {\n\t\twqe->wc_status = SIW_WC_GENERAL_ERR;\n\t\trv = -EINVAL;\n\t\tgoto error_term;\n\t}\n\tsrx->fpdu_part_rem -= rv;\n\tsrx->fpdu_part_rcvd += rv;\n\twqe->processed += rv;\n\n\tif (!srx->fpdu_part_rem) {\n\t\tsrx->ddp_to += srx->fpdu_part_rcvd;\n\t\treturn 0;\n\t}\n\treturn -EAGAIN;\n\nerror_term:\n\tsiw_init_terminate(qp, TERM_ERROR_LAYER_DDP, DDP_ETYPE_CATASTROPHIC,\n\t\t\t   DDP_ECODE_CATASTROPHIC, 0);\n\treturn rv;\n}\n\nint siw_proc_terminate(struct siw_qp *qp)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tstruct sk_buff *skb = srx->skb;\n\tstruct iwarp_terminate *term = &srx->hdr.terminate;\n\tunion iwarp_hdr term_info;\n\tu8 *infop = (u8 *)&term_info;\n\tenum rdma_opcode op;\n\tu16 to_copy = sizeof(struct iwarp_ctrl);\n\n\tpr_warn(\"siw: got TERMINATE. layer %d, type %d, code %d\\n\",\n\t\t__rdmap_term_layer(term), __rdmap_term_etype(term),\n\t\t__rdmap_term_ecode(term));\n\n\tif (be32_to_cpu(term->ddp_qn) != RDMAP_UNTAGGED_QN_TERMINATE ||\n\t    be32_to_cpu(term->ddp_msn) !=\n\t\t    qp->rx_stream.ddp_msn[RDMAP_UNTAGGED_QN_TERMINATE] ||\n\t    be32_to_cpu(term->ddp_mo) != 0) {\n\t\tpr_warn(\"siw: rx bogus TERM [QN x%08x, MSN x%08x, MO x%08x]\\n\",\n\t\t\tbe32_to_cpu(term->ddp_qn), be32_to_cpu(term->ddp_msn),\n\t\t\tbe32_to_cpu(term->ddp_mo));\n\t\treturn -ECONNRESET;\n\t}\n\t \n\tif (!term->flag_m)\n\t\treturn -ECONNRESET;\n\n\t \n\tif (srx->skb_new < sizeof(struct iwarp_ctrl_tagged))\n\t\treturn -ECONNRESET;\n\n\tmemset(infop, 0, sizeof(term_info));\n\n\tskb_copy_bits(skb, srx->skb_offset, infop, to_copy);\n\n\top = __rdmap_get_opcode(&term_info.ctrl);\n\tif (op >= RDMAP_TERMINATE)\n\t\tgoto out;\n\n\tinfop += to_copy;\n\tsrx->skb_offset += to_copy;\n\tsrx->skb_new -= to_copy;\n\tsrx->skb_copied += to_copy;\n\tsrx->fpdu_part_rcvd += to_copy;\n\tsrx->fpdu_part_rem -= to_copy;\n\n\tto_copy = iwarp_pktinfo[op].hdr_len - to_copy;\n\n\t \n\tif (to_copy + MPA_CRC_SIZE > srx->skb_new)\n\t\treturn -ECONNRESET;\n\n\tskb_copy_bits(skb, srx->skb_offset, infop, to_copy);\n\n\tif (term->flag_r) {\n\t\tsiw_dbg_qp(qp, \"TERM reports RDMAP hdr type %u, len %u (%s)\\n\",\n\t\t\t   op, be16_to_cpu(term_info.ctrl.mpa_len),\n\t\t\t   term->flag_m ? \"valid\" : \"invalid\");\n\t} else if (term->flag_d) {\n\t\tsiw_dbg_qp(qp, \"TERM reports DDP hdr type %u, len %u (%s)\\n\",\n\t\t\t   op, be16_to_cpu(term_info.ctrl.mpa_len),\n\t\t\t   term->flag_m ? \"valid\" : \"invalid\");\n\t}\nout:\n\tsrx->skb_new -= to_copy;\n\tsrx->skb_offset += to_copy;\n\tsrx->skb_copied += to_copy;\n\tsrx->fpdu_part_rcvd += to_copy;\n\tsrx->fpdu_part_rem -= to_copy;\n\n\treturn -ECONNRESET;\n}\n\nstatic int siw_get_trailer(struct siw_qp *qp, struct siw_rx_stream *srx)\n{\n\tstruct sk_buff *skb = srx->skb;\n\tint avail = min(srx->skb_new, srx->fpdu_part_rem);\n\tu8 *tbuf = (u8 *)&srx->trailer.crc - srx->pad;\n\t__wsum crc_in, crc_own = 0;\n\n\tsiw_dbg_qp(qp, \"expected %d, available %d, pad %u\\n\",\n\t\t   srx->fpdu_part_rem, srx->skb_new, srx->pad);\n\n\tskb_copy_bits(skb, srx->skb_offset, tbuf, avail);\n\n\tsrx->skb_new -= avail;\n\tsrx->skb_offset += avail;\n\tsrx->skb_copied += avail;\n\tsrx->fpdu_part_rem -= avail;\n\n\tif (srx->fpdu_part_rem)\n\t\treturn -EAGAIN;\n\n\tif (!srx->mpa_crc_hd)\n\t\treturn 0;\n\n\tif (srx->pad)\n\t\tcrypto_shash_update(srx->mpa_crc_hd, tbuf, srx->pad);\n\t \n\tcrypto_shash_final(srx->mpa_crc_hd, (u8 *)&crc_own);\n\tcrc_in = (__force __wsum)srx->trailer.crc;\n\n\tif (unlikely(crc_in != crc_own)) {\n\t\tpr_warn(\"siw: crc error. in: %08x, own %08x, op %u\\n\",\n\t\t\tcrc_in, crc_own, qp->rx_stream.rdmap_op);\n\n\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_LLP,\n\t\t\t\t   LLP_ETYPE_MPA,\n\t\t\t\t   LLP_ECODE_RECEIVED_CRC, 0);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n#define MIN_DDP_HDR sizeof(struct iwarp_ctrl_tagged)\n\nstatic int siw_get_hdr(struct siw_rx_stream *srx)\n{\n\tstruct sk_buff *skb = srx->skb;\n\tstruct siw_qp *qp = rx_qp(srx);\n\tstruct iwarp_ctrl *c_hdr = &srx->hdr.ctrl;\n\tstruct siw_rx_fpdu *frx;\n\tu8 opcode;\n\tint bytes;\n\n\tif (srx->fpdu_part_rcvd < MIN_DDP_HDR) {\n\t\t \n\t\tbytes = min_t(int, srx->skb_new,\n\t\t\t      MIN_DDP_HDR - srx->fpdu_part_rcvd);\n\n\t\tskb_copy_bits(skb, srx->skb_offset,\n\t\t\t      (char *)c_hdr + srx->fpdu_part_rcvd, bytes);\n\n\t\tsrx->fpdu_part_rcvd += bytes;\n\n\t\tsrx->skb_new -= bytes;\n\t\tsrx->skb_offset += bytes;\n\t\tsrx->skb_copied += bytes;\n\n\t\tif (srx->fpdu_part_rcvd < MIN_DDP_HDR)\n\t\t\treturn -EAGAIN;\n\n\t\tif (unlikely(__ddp_get_version(c_hdr) != DDP_VERSION)) {\n\t\t\tenum ddp_etype etype;\n\t\t\tenum ddp_ecode ecode;\n\n\t\t\tpr_warn(\"siw: received ddp version unsupported %d\\n\",\n\t\t\t\t__ddp_get_version(c_hdr));\n\n\t\t\tif (c_hdr->ddp_rdmap_ctrl & DDP_FLAG_TAGGED) {\n\t\t\t\tetype = DDP_ETYPE_TAGGED_BUF;\n\t\t\t\tecode = DDP_ECODE_T_VERSION;\n\t\t\t} else {\n\t\t\t\tetype = DDP_ETYPE_UNTAGGED_BUF;\n\t\t\t\tecode = DDP_ECODE_UT_VERSION;\n\t\t\t}\n\t\t\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_DDP,\n\t\t\t\t\t   etype, ecode, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (unlikely(__rdmap_get_version(c_hdr) != RDMAP_VERSION)) {\n\t\t\tpr_warn(\"siw: received rdmap version unsupported %d\\n\",\n\t\t\t\t__rdmap_get_version(c_hdr));\n\n\t\t\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_RDMAP,\n\t\t\t\t\t   RDMAP_ETYPE_REMOTE_OPERATION,\n\t\t\t\t\t   RDMAP_ECODE_VERSION, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\topcode = __rdmap_get_opcode(c_hdr);\n\n\t\tif (opcode > RDMAP_TERMINATE) {\n\t\t\tpr_warn(\"siw: received unknown packet type %u\\n\",\n\t\t\t\topcode);\n\n\t\t\tsiw_init_terminate(rx_qp(srx), TERM_ERROR_LAYER_RDMAP,\n\t\t\t\t\t   RDMAP_ETYPE_REMOTE_OPERATION,\n\t\t\t\t\t   RDMAP_ECODE_OPCODE, 0);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsiw_dbg_qp(rx_qp(srx), \"new header, opcode %u\\n\", opcode);\n\t} else {\n\t\topcode = __rdmap_get_opcode(c_hdr);\n\t}\n\tset_rx_fpdu_context(qp, opcode);\n\tfrx = qp->rx_fpdu;\n\n\t \n\tif (iwarp_pktinfo[opcode].hdr_len > sizeof(struct iwarp_ctrl_tagged)) {\n\t\tint hdrlen = iwarp_pktinfo[opcode].hdr_len;\n\n\t\tbytes = min_t(int, hdrlen - MIN_DDP_HDR, srx->skb_new);\n\n\t\tskb_copy_bits(skb, srx->skb_offset,\n\t\t\t      (char *)c_hdr + srx->fpdu_part_rcvd, bytes);\n\n\t\tsrx->fpdu_part_rcvd += bytes;\n\n\t\tsrx->skb_new -= bytes;\n\t\tsrx->skb_offset += bytes;\n\t\tsrx->skb_copied += bytes;\n\n\t\tif (srx->fpdu_part_rcvd < hdrlen)\n\t\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif (srx->mpa_crc_hd) {\n\t\t \n\t\tcrypto_shash_init(srx->mpa_crc_hd);\n\t\tcrypto_shash_update(srx->mpa_crc_hd, (u8 *)c_hdr,\n\t\t\t\t    srx->fpdu_part_rcvd);\n\t}\n\tif (frx->more_ddp_segs) {\n\t\tfrx->first_ddp_seg = 0;\n\t\tif (frx->prev_rdmap_op != opcode) {\n\t\t\tpr_warn(\"siw: packet intersection: %u : %u\\n\",\n\t\t\t\tfrx->prev_rdmap_op, opcode);\n\t\t\t \n\t\t\tset_rx_fpdu_context(qp, frx->prev_rdmap_op);\n\t\t\t__rdmap_set_opcode(c_hdr, frx->prev_rdmap_op);\n\t\t\treturn -EPROTO;\n\t\t}\n\t} else {\n\t\tfrx->prev_rdmap_op = opcode;\n\t\tfrx->first_ddp_seg = 1;\n\t}\n\tfrx->more_ddp_segs = c_hdr->ddp_rdmap_ctrl & DDP_FLAG_LAST ? 0 : 1;\n\n\treturn 0;\n}\n\nstatic int siw_check_tx_fence(struct siw_qp *qp)\n{\n\tstruct siw_wqe *tx_waiting = tx_wqe(qp);\n\tstruct siw_sqe *rreq;\n\tint resume_tx = 0, rv = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->orq_lock, flags);\n\n\t \n\trreq = orq_get_current(qp);\n\tWRITE_ONCE(rreq->flags, 0);\n\n\tqp->orq_get++;\n\n\tif (qp->tx_ctx.orq_fence) {\n\t\tif (unlikely(tx_waiting->wr_status != SIW_WR_QUEUED)) {\n\t\t\tpr_warn(\"siw: [QP %u]: fence resume: bad status %d\\n\",\n\t\t\t\tqp_id(qp), tx_waiting->wr_status);\n\t\t\trv = -EPROTO;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (tx_waiting->sqe.opcode == SIW_OP_READ ||\n\t\t    tx_waiting->sqe.opcode == SIW_OP_READ_LOCAL_INV) {\n\n\t\t\t \n\t\t\trreq = orq_get_free(qp);\n\t\t\tif (unlikely(!rreq)) {\n\t\t\t\tpr_warn(\"siw: [QP %u]: no ORQE\\n\", qp_id(qp));\n\t\t\t\trv = -EPROTO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsiw_read_to_orq(rreq, &tx_waiting->sqe);\n\n\t\t\tqp->orq_put++;\n\t\t\tqp->tx_ctx.orq_fence = 0;\n\t\t\tresume_tx = 1;\n\n\t\t} else if (siw_orq_empty(qp)) {\n\t\t\t \n\t\t\tqp->tx_ctx.orq_fence = 0;\n\t\t\tresume_tx = 1;\n\t\t}\n\t}\nout:\n\tspin_unlock_irqrestore(&qp->orq_lock, flags);\n\n\tif (resume_tx)\n\t\trv = siw_sq_start(qp);\n\n\treturn rv;\n}\n\n \nstatic int siw_rdmap_complete(struct siw_qp *qp, int error)\n{\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tstruct siw_wqe *wqe = rx_wqe(qp->rx_fpdu);\n\tenum siw_wc_status wc_status = wqe->wc_status;\n\tu8 opcode = __rdmap_get_opcode(&srx->hdr.ctrl);\n\tint rv = 0;\n\n\tswitch (opcode) {\n\tcase RDMAP_SEND_SE:\n\tcase RDMAP_SEND_SE_INVAL:\n\t\twqe->rqe.flags |= SIW_WQE_SOLICITED;\n\t\tfallthrough;\n\n\tcase RDMAP_SEND:\n\tcase RDMAP_SEND_INVAL:\n\t\tif (wqe->wr_status == SIW_WR_IDLE)\n\t\t\tbreak;\n\n\t\tsrx->ddp_msn[RDMAP_UNTAGGED_QN_SEND]++;\n\n\t\tif (error != 0 && wc_status == SIW_WC_SUCCESS)\n\t\t\twc_status = SIW_WC_GENERAL_ERR;\n\t\t \n\t\tif (wc_status == SIW_WC_SUCCESS &&\n\t\t    (opcode == RDMAP_SEND_INVAL ||\n\t\t     opcode == RDMAP_SEND_SE_INVAL)) {\n\t\t\trv = siw_invalidate_stag(qp->pd, srx->inval_stag);\n\t\t\tif (rv) {\n\t\t\t\tsiw_init_terminate(\n\t\t\t\t\tqp, TERM_ERROR_LAYER_RDMAP,\n\t\t\t\t\trv == -EACCES ?\n\t\t\t\t\t\tRDMAP_ETYPE_REMOTE_PROTECTION :\n\t\t\t\t\t\tRDMAP_ETYPE_REMOTE_OPERATION,\n\t\t\t\t\tRDMAP_ECODE_CANNOT_INVALIDATE, 0);\n\n\t\t\t\twc_status = SIW_WC_REM_INV_REQ_ERR;\n\t\t\t}\n\t\t\trv = siw_rqe_complete(qp, &wqe->rqe, wqe->processed,\n\t\t\t\t\t      rv ? 0 : srx->inval_stag,\n\t\t\t\t\t      wc_status);\n\t\t} else {\n\t\t\trv = siw_rqe_complete(qp, &wqe->rqe, wqe->processed,\n\t\t\t\t\t      0, wc_status);\n\t\t}\n\t\tsiw_wqe_put_mem(wqe, SIW_OP_RECEIVE);\n\t\tbreak;\n\n\tcase RDMAP_RDMA_READ_RESP:\n\t\tif (wqe->wr_status == SIW_WR_IDLE)\n\t\t\tbreak;\n\n\t\tif (error != 0) {\n\t\t\tif ((srx->state == SIW_GET_HDR &&\n\t\t\t     qp->rx_fpdu->first_ddp_seg) || error == -ENODATA)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tif (wc_status == SIW_WC_SUCCESS)\n\t\t\t\twc_status = SIW_WC_GENERAL_ERR;\n\t\t} else if (rdma_is_kernel_res(&qp->base_qp.res) &&\n\t\t\t   rx_type(wqe) == SIW_OP_READ_LOCAL_INV) {\n\t\t\t \n\t\t\trv = siw_invalidate_stag(qp->pd, wqe->sqe.sge[0].lkey);\n\t\t\tif (rv) {\n\t\t\t\tsiw_init_terminate(qp, TERM_ERROR_LAYER_RDMAP,\n\t\t\t\t\t\t   RDMAP_ETYPE_CATASTROPHIC,\n\t\t\t\t\t\t   RDMAP_ECODE_UNSPECIFIED, 0);\n\n\t\t\t\tif (wc_status == SIW_WC_SUCCESS) {\n\t\t\t\t\twc_status = SIW_WC_GENERAL_ERR;\n\t\t\t\t\terror = rv;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tif ((wqe->sqe.flags & SIW_WQE_SIGNALLED) || error != 0)\n\t\t\trv = siw_sqe_complete(qp, &wqe->sqe, wqe->processed,\n\t\t\t\t\t      wc_status);\n\t\tsiw_wqe_put_mem(wqe, SIW_OP_READ);\n\n\t\tif (!error) {\n\t\t\trv = siw_check_tx_fence(qp);\n\t\t} else {\n\t\t\t \n\t\t\tif (qp->attrs.orq_size)\n\t\t\t\tWRITE_ONCE(orq_get_current(qp)->flags, 0);\n\t\t}\n\t\tbreak;\n\n\tcase RDMAP_RDMA_READ_REQ:\n\t\tif (!error) {\n\t\t\trv = siw_init_rresp(qp, srx);\n\t\t\tsrx->ddp_msn[RDMAP_UNTAGGED_QN_RDMA_READ]++;\n\t\t}\n\t\tbreak;\n\n\tcase RDMAP_RDMA_WRITE:\n\t\tif (wqe->wr_status == SIW_WR_IDLE)\n\t\t\tbreak;\n\n\t\t \n\t\tif (rx_mem(&qp->rx_tagged)) {\n\t\t\tsiw_mem_put(rx_mem(&qp->rx_tagged));\n\t\t\trx_mem(&qp->rx_tagged) = NULL;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\twqe->wr_status = SIW_WR_IDLE;\n\n\treturn rv;\n}\n\n \nint siw_tcp_rx_data(read_descriptor_t *rd_desc, struct sk_buff *skb,\n\t\t    unsigned int off, size_t len)\n{\n\tstruct siw_qp *qp = rd_desc->arg.data;\n\tstruct siw_rx_stream *srx = &qp->rx_stream;\n\tint rv;\n\n\tsrx->skb = skb;\n\tsrx->skb_new = skb->len - off;\n\tsrx->skb_offset = off;\n\tsrx->skb_copied = 0;\n\n\tsiw_dbg_qp(qp, \"new data, len %d\\n\", srx->skb_new);\n\n\twhile (srx->skb_new) {\n\t\tint run_completion = 1;\n\n\t\tif (unlikely(srx->rx_suspend)) {\n\t\t\t \n\t\t\tsrx->skb_copied += srx->skb_new;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (srx->state) {\n\t\tcase SIW_GET_HDR:\n\t\t\trv = siw_get_hdr(srx);\n\t\t\tif (!rv) {\n\t\t\t\tsrx->fpdu_part_rem =\n\t\t\t\t\tbe16_to_cpu(srx->hdr.ctrl.mpa_len) -\n\t\t\t\t\tsrx->fpdu_part_rcvd + MPA_HDR_SIZE;\n\n\t\t\t\tif (srx->fpdu_part_rem)\n\t\t\t\t\tsrx->pad = -srx->fpdu_part_rem & 0x3;\n\t\t\t\telse\n\t\t\t\t\tsrx->pad = 0;\n\n\t\t\t\tsrx->state = SIW_GET_DATA_START;\n\t\t\t\tsrx->fpdu_part_rcvd = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIW_GET_DATA_MORE:\n\t\t\t \n\t\t\tqp->rx_fpdu->first_ddp_seg = 0;\n\t\t\tfallthrough;\n\n\t\tcase SIW_GET_DATA_START:\n\t\t\t \n\t\t\trv = iwarp_pktinfo[qp->rx_stream.rdmap_op].rx_data(qp);\n\t\t\tif (!rv) {\n\t\t\t\tint mpa_len =\n\t\t\t\t\tbe16_to_cpu(srx->hdr.ctrl.mpa_len)\n\t\t\t\t\t+ MPA_HDR_SIZE;\n\n\t\t\t\tsrx->fpdu_part_rem = (-mpa_len & 0x3)\n\t\t\t\t\t\t      + MPA_CRC_SIZE;\n\t\t\t\tsrx->fpdu_part_rcvd = 0;\n\t\t\t\tsrx->state = SIW_GET_TRAILER;\n\t\t\t} else {\n\t\t\t\tif (unlikely(rv == -ECONNRESET))\n\t\t\t\t\trun_completion = 0;\n\t\t\t\telse\n\t\t\t\t\tsrx->state = SIW_GET_DATA_MORE;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase SIW_GET_TRAILER:\n\t\t\t \n\t\t\trv = siw_get_trailer(qp, srx);\n\t\t\tif (likely(!rv)) {\n\t\t\t\t \n\t\t\t\tsrx->state = SIW_GET_HDR;\n\t\t\t\tsrx->fpdu_part_rcvd = 0;\n\n\t\t\t\tif (!(srx->hdr.ctrl.ddp_rdmap_ctrl &\n\t\t\t\t      DDP_FLAG_LAST))\n\t\t\t\t\t \n\t\t\t\t\tbreak;\n\n\t\t\t\trv = siw_rdmap_complete(qp, 0);\n\t\t\t\trun_completion = 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"QP[%u]: RX out of state\\n\", qp_id(qp));\n\t\t\trv = -EPROTO;\n\t\t\trun_completion = 0;\n\t\t}\n\t\tif (unlikely(rv != 0 && rv != -EAGAIN)) {\n\t\t\tif ((srx->state > SIW_GET_HDR ||\n\t\t\t     qp->rx_fpdu->more_ddp_segs) && run_completion)\n\t\t\t\tsiw_rdmap_complete(qp, rv);\n\n\t\t\tsiw_dbg_qp(qp, \"rx error %d, rx state %d\\n\", rv,\n\t\t\t\t   srx->state);\n\n\t\t\tsiw_qp_cm_drop(qp, 1);\n\n\t\t\tbreak;\n\t\t}\n\t\tif (rv) {\n\t\t\tsiw_dbg_qp(qp, \"fpdu fragment, state %d, missing %d\\n\",\n\t\t\t\t   srx->state, srx->fpdu_part_rem);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn srx->skb_copied;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}