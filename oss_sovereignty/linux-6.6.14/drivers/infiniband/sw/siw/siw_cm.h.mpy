{
  "module_name": "siw_cm.h",
  "hash_id": "11600a48a60aa0c35afec6e109ca1b95030c15d889691b2baf88a6dcf352fe84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_cm.h",
  "human_readable_source": " \n\n \n \n \n \n\n#ifndef _SIW_CM_H\n#define _SIW_CM_H\n\n#include <net/sock.h>\n#include <linux/tcp.h>\n\n#include <rdma/iw_cm.h>\n\nenum siw_cep_state {\n\tSIW_EPSTATE_IDLE = 1,\n\tSIW_EPSTATE_LISTENING,\n\tSIW_EPSTATE_CONNECTING,\n\tSIW_EPSTATE_AWAIT_MPAREQ,\n\tSIW_EPSTATE_RECVD_MPAREQ,\n\tSIW_EPSTATE_AWAIT_MPAREP,\n\tSIW_EPSTATE_RDMA_MODE,\n\tSIW_EPSTATE_CLOSED\n};\n\nstruct siw_mpa_info {\n\tstruct mpa_rr hdr;  \n\tstruct mpa_v2_data v2_ctrl;\n\tstruct mpa_v2_data v2_ctrl_req;\n\tchar *pdata;\n\tint bytes_rcvd;\n};\n\nstruct siw_device;\n\nstruct siw_cep {\n\tstruct iw_cm_id *cm_id;\n\tstruct siw_device *sdev;\n\tstruct list_head devq;\n\tspinlock_t lock;\n\tstruct kref ref;\n\tint in_use;\n\twait_queue_head_t waitq;\n\tenum siw_cep_state state;\n\n\tstruct list_head listenq;\n\tstruct siw_cep *listen_cep;\n\n\tstruct siw_qp *qp;\n\tstruct socket *sock;\n\n\tstruct siw_cm_work *mpa_timer;\n\tstruct list_head work_freelist;\n\n\tstruct siw_mpa_info mpa;\n\tint ord;\n\tint ird;\n\tbool enhanced_rdma_conn_est;\n\n\t \n\tvoid (*sk_state_change)(struct sock *sk);\n\tvoid (*sk_data_ready)(struct sock *sk);\n\tvoid (*sk_write_space)(struct sock *sk);\n\tvoid (*sk_error_report)(struct sock *sk);\n};\n\n \n#define MPAREQ_TIMEOUT (HZ * 10)\n#define MPAREP_TIMEOUT (HZ * 5)\n\nenum siw_work_type {\n\tSIW_CM_WORK_ACCEPT = 1,\n\tSIW_CM_WORK_READ_MPAHDR,\n\tSIW_CM_WORK_CLOSE_LLP,  \n\tSIW_CM_WORK_PEER_CLOSE,  \n\tSIW_CM_WORK_MPATIMEOUT\n};\n\nstruct siw_cm_work {\n\tstruct delayed_work work;\n\tstruct list_head list;\n\tenum siw_work_type type;\n\tstruct siw_cep *cep;\n};\n\n#define to_sockaddr_in(a) (*(struct sockaddr_in *)(&(a)))\n#define to_sockaddr_in6(a) (*(struct sockaddr_in6 *)(&(a)))\n\nstatic inline int getname_peer(struct socket *s, struct sockaddr_storage *a)\n{\n\treturn s->ops->getname(s, (struct sockaddr *)a, 1);\n}\n\nstatic inline int getname_local(struct socket *s, struct sockaddr_storage *a)\n{\n\treturn s->ops->getname(s, (struct sockaddr *)a, 0);\n}\n\nstatic inline int ksock_recv(struct socket *sock, char *buf, size_t size,\n\t\t\t     int flags)\n{\n\tstruct kvec iov = { buf, size };\n\tstruct msghdr msg = { .msg_name = NULL, .msg_flags = flags };\n\n\treturn kernel_recvmsg(sock, &msg, &iov, 1, size, flags);\n}\n\nint siw_connect(struct iw_cm_id *id, struct iw_cm_conn_param *parm);\nint siw_accept(struct iw_cm_id *id, struct iw_cm_conn_param *param);\nint siw_reject(struct iw_cm_id *id, const void *data, u8 len);\nint siw_create_listen(struct iw_cm_id *id, int backlog);\nint siw_destroy_listen(struct iw_cm_id *id);\n\nvoid siw_cep_get(struct siw_cep *cep);\nvoid siw_cep_put(struct siw_cep *cep);\nint siw_cm_queue_work(struct siw_cep *cep, enum siw_work_type type);\n\nint siw_cm_init(void);\nvoid siw_cm_exit(void);\n\n \n#define sk_to_qp(sk) (((struct siw_cep *)((sk)->sk_user_data))->qp)\n#define sk_to_cep(sk) ((struct siw_cep *)((sk)->sk_user_data))\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}