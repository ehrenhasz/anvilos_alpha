{
  "module_name": "siw_mem.h",
  "hash_id": "9da51e9fc3ec7713bc03a4725a85cae130eb0ff5d2a3683dda81001b00dec9b4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_mem.h",
  "human_readable_source": " \n\n \n \n\n#ifndef _SIW_MEM_H\n#define _SIW_MEM_H\n\nstruct siw_umem *siw_umem_get(u64 start, u64 len, bool writable);\nvoid siw_umem_release(struct siw_umem *umem, bool dirty);\nstruct siw_pbl *siw_pbl_alloc(u32 num_buf);\ndma_addr_t siw_pbl_get_buffer(struct siw_pbl *pbl, u64 off, int *len, int *idx);\nstruct siw_mem *siw_mem_id2obj(struct siw_device *sdev, int stag_index);\nint siw_mem_add(struct siw_device *sdev, struct siw_mem *m);\nint siw_invalidate_stag(struct ib_pd *pd, u32 stag);\nint siw_check_mem(struct ib_pd *pd, struct siw_mem *mem, u64 addr,\n\t\t  enum ib_access_flags perms, int len);\nint siw_check_sge(struct ib_pd *pd, struct siw_sge *sge,\n\t\t  struct siw_mem *mem[], enum ib_access_flags perms,\n\t\t  u32 off, int len);\nvoid siw_wqe_put_mem(struct siw_wqe *wqe, enum siw_opcode op);\nint siw_mr_add_mem(struct siw_mr *mr, struct ib_pd *pd, void *mem_obj,\n\t\t   u64 start, u64 len, int rights);\nvoid siw_mr_drop_mem(struct siw_mr *mr);\nvoid siw_free_mem(struct kref *ref);\n\nstatic inline void siw_mem_put(struct siw_mem *mem)\n{\n\tkref_put(&mem->ref, siw_free_mem);\n}\n\nstatic inline void siw_unref_mem_sgl(struct siw_mem **mem, unsigned int num_sge)\n{\n\twhile (num_sge) {\n\t\tif (*mem == NULL)\n\t\t\tbreak;\n\n\t\tsiw_mem_put(*mem);\n\t\t*mem = NULL;\n\t\tmem++;\n\t\tnum_sge--;\n\t}\n}\n\n#define CHUNK_SHIFT 9  \n#define PAGES_PER_CHUNK (_AC(1, UL) << CHUNK_SHIFT)\n#define CHUNK_MASK (~(PAGES_PER_CHUNK - 1))\n#define PAGE_CHUNK_SIZE (PAGES_PER_CHUNK * sizeof(struct page *))\n\n \nstatic inline struct page *siw_get_upage(struct siw_umem *umem, u64 addr)\n{\n\tunsigned int page_idx = (addr - umem->fp_addr) >> PAGE_SHIFT,\n\t\t     chunk_idx = page_idx >> CHUNK_SHIFT,\n\t\t     page_in_chunk = page_idx & ~CHUNK_MASK;\n\n\tif (likely(page_idx < umem->num_pages))\n\t\treturn umem->page_chunk[chunk_idx].plist[page_in_chunk];\n\n\treturn NULL;\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}