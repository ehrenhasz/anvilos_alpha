{
  "module_name": "siw_main.c",
  "hash_id": "e21737596483cd08490a4ee27e2113e8b24c0ec5c6b27652e5fe58d483d21575",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/siw/siw_main.c",
  "human_readable_source": "\n\n \n \n\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <net/net_namespace.h>\n#include <linux/rtnetlink.h>\n#include <linux/if_arp.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n\n#include <net/addrconf.h>\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/rdma_netlink.h>\n#include <linux/kthread.h>\n\n#include \"siw.h\"\n#include \"siw_verbs.h\"\n\nMODULE_AUTHOR(\"Bernard Metzler\");\nMODULE_DESCRIPTION(\"Software iWARP Driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n \nconst bool zcopy_tx = true;\n\n \nconst bool try_gso;\n\n \nconst bool loopback_enabled = true;\n\n \nconst bool mpa_crc_required;\n\n \nconst bool mpa_crc_strict;\n\n \nconst bool siw_tcp_nagle;\n\n \nu_char mpa_version = MPA_REVISION_2;\n\n \nconst bool peer_to_peer;\n\nstruct task_struct *siw_tx_thread[NR_CPUS];\nstruct crypto_shash *siw_crypto_shash;\n\nstatic int siw_device_register(struct siw_device *sdev, const char *name)\n{\n\tstruct ib_device *base_dev = &sdev->base_dev;\n\tstatic int dev_id = 1;\n\tint rv;\n\n\tsdev->vendor_part_id = dev_id++;\n\n\trv = ib_register_device(base_dev, name, NULL);\n\tif (rv) {\n\t\tpr_warn(\"siw: device registration error %d\\n\", rv);\n\t\treturn rv;\n\t}\n\n\tsiw_dbg(base_dev, \"HWaddr=%pM\\n\", sdev->raw_gid);\n\treturn 0;\n}\n\nstatic void siw_device_cleanup(struct ib_device *base_dev)\n{\n\tstruct siw_device *sdev = to_siw_dev(base_dev);\n\n\txa_destroy(&sdev->qp_xa);\n\txa_destroy(&sdev->mem_xa);\n}\n\nstatic int siw_dev_qualified(struct net_device *netdev)\n{\n\t \n\tif (netdev->type == ARPHRD_ETHER || netdev->type == ARPHRD_IEEE802 ||\n\t    netdev->type == ARPHRD_NONE ||\n\t    (netdev->type == ARPHRD_LOOPBACK && loopback_enabled))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic DEFINE_PER_CPU(atomic_t, siw_use_cnt);\n\nstatic struct {\n\tstruct cpumask **tx_valid_cpus;\n\tint num_nodes;\n} siw_cpu_info;\n\nstatic int siw_init_cpulist(void)\n{\n\tint i, num_nodes = nr_node_ids;\n\n\tmemset(siw_tx_thread, 0, sizeof(siw_tx_thread));\n\n\tsiw_cpu_info.num_nodes = num_nodes;\n\n\tsiw_cpu_info.tx_valid_cpus =\n\t\tkcalloc(num_nodes, sizeof(struct cpumask *), GFP_KERNEL);\n\tif (!siw_cpu_info.tx_valid_cpus) {\n\t\tsiw_cpu_info.num_nodes = 0;\n\t\treturn -ENOMEM;\n\t}\n\tfor (i = 0; i < siw_cpu_info.num_nodes; i++) {\n\t\tsiw_cpu_info.tx_valid_cpus[i] =\n\t\t\tkzalloc(sizeof(struct cpumask), GFP_KERNEL);\n\t\tif (!siw_cpu_info.tx_valid_cpus[i])\n\t\t\tgoto out_err;\n\n\t\tcpumask_clear(siw_cpu_info.tx_valid_cpus[i]);\n\t}\n\tfor_each_possible_cpu(i)\n\t\tcpumask_set_cpu(i, siw_cpu_info.tx_valid_cpus[cpu_to_node(i)]);\n\n\treturn 0;\n\nout_err:\n\tsiw_cpu_info.num_nodes = 0;\n\twhile (--i >= 0)\n\t\tkfree(siw_cpu_info.tx_valid_cpus[i]);\n\tkfree(siw_cpu_info.tx_valid_cpus);\n\tsiw_cpu_info.tx_valid_cpus = NULL;\n\n\treturn -ENOMEM;\n}\n\nstatic void siw_destroy_cpulist(void)\n{\n\tint i = 0;\n\n\twhile (i < siw_cpu_info.num_nodes)\n\t\tkfree(siw_cpu_info.tx_valid_cpus[i++]);\n\n\tkfree(siw_cpu_info.tx_valid_cpus);\n}\n\n \nint siw_get_tx_cpu(struct siw_device *sdev)\n{\n\tconst struct cpumask *tx_cpumask;\n\tint i, num_cpus, cpu, min_use, node = sdev->numa_node, tx_cpu = -1;\n\n\tif (node < 0)\n\t\ttx_cpumask = cpu_online_mask;\n\telse\n\t\ttx_cpumask = siw_cpu_info.tx_valid_cpus[node];\n\n\tnum_cpus = cpumask_weight(tx_cpumask);\n\tif (!num_cpus) {\n\t\t \n\t\ttx_cpumask = cpu_online_mask;\n\t\tnum_cpus = cpumask_weight(tx_cpumask);\n\t}\n\tif (!num_cpus)\n\t\tgoto out;\n\n\tcpu = cpumask_first(tx_cpumask);\n\n\tfor (i = 0, min_use = SIW_MAX_QP; i < num_cpus;\n\t     i++, cpu = cpumask_next(cpu, tx_cpumask)) {\n\t\tint usage;\n\n\t\t \n\t\tif (!siw_tx_thread[cpu])\n\t\t\tcontinue;\n\n\t\tusage = atomic_read(&per_cpu(siw_use_cnt, cpu));\n\t\tif (usage <= min_use) {\n\t\t\ttx_cpu = cpu;\n\t\t\tmin_use = usage;\n\t\t}\n\t}\n\tsiw_dbg(&sdev->base_dev,\n\t\t\"tx cpu %d, node %d, %d qp's\\n\", tx_cpu, node, min_use);\n\nout:\n\tif (tx_cpu >= 0)\n\t\tatomic_inc(&per_cpu(siw_use_cnt, tx_cpu));\n\telse\n\t\tpr_warn(\"siw: no tx cpu found\\n\");\n\n\treturn tx_cpu;\n}\n\nvoid siw_put_tx_cpu(int cpu)\n{\n\tatomic_dec(&per_cpu(siw_use_cnt, cpu));\n}\n\nstatic struct ib_qp *siw_get_base_qp(struct ib_device *base_dev, int id)\n{\n\tstruct siw_qp *qp = siw_qp_id2obj(to_siw_dev(base_dev), id);\n\n\tif (qp) {\n\t\t \n\t\tsiw_qp_put(qp);\n\t\treturn &qp->base_qp;\n\t}\n\treturn NULL;\n}\n\nstatic const struct ib_device_ops siw_device_ops = {\n\t.owner = THIS_MODULE,\n\t.uverbs_abi_ver = SIW_ABI_VERSION,\n\t.driver_id = RDMA_DRIVER_SIW,\n\n\t.alloc_mr = siw_alloc_mr,\n\t.alloc_pd = siw_alloc_pd,\n\t.alloc_ucontext = siw_alloc_ucontext,\n\t.create_cq = siw_create_cq,\n\t.create_qp = siw_create_qp,\n\t.create_srq = siw_create_srq,\n\t.dealloc_driver = siw_device_cleanup,\n\t.dealloc_pd = siw_dealloc_pd,\n\t.dealloc_ucontext = siw_dealloc_ucontext,\n\t.dereg_mr = siw_dereg_mr,\n\t.destroy_cq = siw_destroy_cq,\n\t.destroy_qp = siw_destroy_qp,\n\t.destroy_srq = siw_destroy_srq,\n\t.get_dma_mr = siw_get_dma_mr,\n\t.get_port_immutable = siw_get_port_immutable,\n\t.iw_accept = siw_accept,\n\t.iw_add_ref = siw_qp_get_ref,\n\t.iw_connect = siw_connect,\n\t.iw_create_listen = siw_create_listen,\n\t.iw_destroy_listen = siw_destroy_listen,\n\t.iw_get_qp = siw_get_base_qp,\n\t.iw_reject = siw_reject,\n\t.iw_rem_ref = siw_qp_put_ref,\n\t.map_mr_sg = siw_map_mr_sg,\n\t.mmap = siw_mmap,\n\t.mmap_free = siw_mmap_free,\n\t.modify_qp = siw_verbs_modify_qp,\n\t.modify_srq = siw_modify_srq,\n\t.poll_cq = siw_poll_cq,\n\t.post_recv = siw_post_receive,\n\t.post_send = siw_post_send,\n\t.post_srq_recv = siw_post_srq_recv,\n\t.query_device = siw_query_device,\n\t.query_gid = siw_query_gid,\n\t.query_port = siw_query_port,\n\t.query_qp = siw_query_qp,\n\t.query_srq = siw_query_srq,\n\t.req_notify_cq = siw_req_notify_cq,\n\t.reg_user_mr = siw_reg_user_mr,\n\n\tINIT_RDMA_OBJ_SIZE(ib_cq, siw_cq, base_cq),\n\tINIT_RDMA_OBJ_SIZE(ib_pd, siw_pd, base_pd),\n\tINIT_RDMA_OBJ_SIZE(ib_qp, siw_qp, base_qp),\n\tINIT_RDMA_OBJ_SIZE(ib_srq, siw_srq, base_srq),\n\tINIT_RDMA_OBJ_SIZE(ib_ucontext, siw_ucontext, base_ucontext),\n};\n\nstatic struct siw_device *siw_device_create(struct net_device *netdev)\n{\n\tstruct siw_device *sdev = NULL;\n\tstruct ib_device *base_dev;\n\tint rv;\n\n\tsdev = ib_alloc_device(siw_device, base_dev);\n\tif (!sdev)\n\t\treturn NULL;\n\n\tbase_dev = &sdev->base_dev;\n\tsdev->netdev = netdev;\n\n\tif (netdev->addr_len) {\n\t\tmemcpy(sdev->raw_gid, netdev->dev_addr,\n\t\t       min_t(unsigned int, netdev->addr_len, ETH_ALEN));\n\t} else {\n\t\t \n\t\teth_random_addr(sdev->raw_gid);\n\t}\n\taddrconf_addr_eui48((u8 *)&base_dev->node_guid, sdev->raw_gid);\n\n\tbase_dev->uverbs_cmd_mask |= BIT_ULL(IB_USER_VERBS_CMD_POST_SEND);\n\n\tbase_dev->node_type = RDMA_NODE_RNIC;\n\tmemcpy(base_dev->node_desc, SIW_NODE_DESC_COMMON,\n\t       sizeof(SIW_NODE_DESC_COMMON));\n\n\t \n\tbase_dev->phys_port_cnt = 1;\n\tbase_dev->num_comp_vectors = num_possible_cpus();\n\n\txa_init_flags(&sdev->qp_xa, XA_FLAGS_ALLOC1);\n\txa_init_flags(&sdev->mem_xa, XA_FLAGS_ALLOC1);\n\n\tib_set_device_ops(base_dev, &siw_device_ops);\n\trv = ib_device_set_netdev(base_dev, netdev, 1);\n\tif (rv)\n\t\tgoto error;\n\n\tmemcpy(base_dev->iw_ifname, netdev->name,\n\t       sizeof(base_dev->iw_ifname));\n\n\t \n\tbase_dev->iw_driver_flags = IW_F_NO_PORT_MAP;\n\n\tsdev->attrs.max_qp = SIW_MAX_QP;\n\tsdev->attrs.max_qp_wr = SIW_MAX_QP_WR;\n\tsdev->attrs.max_ord = SIW_MAX_ORD_QP;\n\tsdev->attrs.max_ird = SIW_MAX_IRD_QP;\n\tsdev->attrs.max_sge = SIW_MAX_SGE;\n\tsdev->attrs.max_sge_rd = SIW_MAX_SGE_RD;\n\tsdev->attrs.max_cq = SIW_MAX_CQ;\n\tsdev->attrs.max_cqe = SIW_MAX_CQE;\n\tsdev->attrs.max_mr = SIW_MAX_MR;\n\tsdev->attrs.max_pd = SIW_MAX_PD;\n\tsdev->attrs.max_mw = SIW_MAX_MW;\n\tsdev->attrs.max_srq = SIW_MAX_SRQ;\n\tsdev->attrs.max_srq_wr = SIW_MAX_SRQ_WR;\n\tsdev->attrs.max_srq_sge = SIW_MAX_SGE;\n\n\tINIT_LIST_HEAD(&sdev->cep_list);\n\tINIT_LIST_HEAD(&sdev->qp_list);\n\n\tatomic_set(&sdev->num_ctx, 0);\n\tatomic_set(&sdev->num_srq, 0);\n\tatomic_set(&sdev->num_qp, 0);\n\tatomic_set(&sdev->num_cq, 0);\n\tatomic_set(&sdev->num_mr, 0);\n\tatomic_set(&sdev->num_pd, 0);\n\n\tsdev->numa_node = dev_to_node(&netdev->dev);\n\tspin_lock_init(&sdev->lock);\n\n\treturn sdev;\nerror:\n\tib_dealloc_device(base_dev);\n\n\treturn NULL;\n}\n\n \nstatic void siw_netdev_down(struct work_struct *work)\n{\n\tstruct siw_device *sdev =\n\t\tcontainer_of(work, struct siw_device, netdev_down);\n\n\tstruct siw_qp_attrs qp_attrs;\n\tstruct list_head *pos, *tmp;\n\n\tmemset(&qp_attrs, 0, sizeof(qp_attrs));\n\tqp_attrs.state = SIW_QP_STATE_ERROR;\n\n\tlist_for_each_safe(pos, tmp, &sdev->qp_list) {\n\t\tstruct siw_qp *qp = list_entry(pos, struct siw_qp, devq);\n\n\t\tdown_write(&qp->state_lock);\n\t\tWARN_ON(siw_qp_modify(qp, &qp_attrs, SIW_QP_ATTR_STATE));\n\t\tup_write(&qp->state_lock);\n\t}\n\tib_device_put(&sdev->base_dev);\n}\n\nstatic void siw_device_goes_down(struct siw_device *sdev)\n{\n\tif (ib_device_try_get(&sdev->base_dev)) {\n\t\tINIT_WORK(&sdev->netdev_down, siw_netdev_down);\n\t\tschedule_work(&sdev->netdev_down);\n\t}\n}\n\nstatic int siw_netdev_event(struct notifier_block *nb, unsigned long event,\n\t\t\t    void *arg)\n{\n\tstruct net_device *netdev = netdev_notifier_info_to_dev(arg);\n\tstruct ib_device *base_dev;\n\tstruct siw_device *sdev;\n\n\tdev_dbg(&netdev->dev, \"siw: event %lu\\n\", event);\n\n\tbase_dev = ib_device_get_by_netdev(netdev, RDMA_DRIVER_SIW);\n\tif (!base_dev)\n\t\treturn NOTIFY_OK;\n\n\tsdev = to_siw_dev(base_dev);\n\n\tswitch (event) {\n\tcase NETDEV_UP:\n\t\tsdev->state = IB_PORT_ACTIVE;\n\t\tsiw_port_event(sdev, 1, IB_EVENT_PORT_ACTIVE);\n\t\tbreak;\n\n\tcase NETDEV_GOING_DOWN:\n\t\tsiw_device_goes_down(sdev);\n\t\tbreak;\n\n\tcase NETDEV_DOWN:\n\t\tsdev->state = IB_PORT_DOWN;\n\t\tsiw_port_event(sdev, 1, IB_EVENT_PORT_ERR);\n\t\tbreak;\n\n\tcase NETDEV_REGISTER:\n\t\t \n\t\tsiw_dbg(base_dev, \"unexpected NETDEV_REGISTER event\\n\");\n\t\tbreak;\n\n\tcase NETDEV_UNREGISTER:\n\t\tib_unregister_device_queued(&sdev->base_dev);\n\t\tbreak;\n\n\tcase NETDEV_CHANGEADDR:\n\t\tsiw_port_event(sdev, 1, IB_EVENT_LID_CHANGE);\n\t\tbreak;\n\t \n\tcase NETDEV_CHANGEMTU:\n\tcase NETDEV_CHANGE:\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tib_device_put(&sdev->base_dev);\n\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block siw_netdev_nb = {\n\t.notifier_call = siw_netdev_event,\n};\n\nstatic int siw_newlink(const char *basedev_name, struct net_device *netdev)\n{\n\tstruct ib_device *base_dev;\n\tstruct siw_device *sdev = NULL;\n\tint rv = -ENOMEM;\n\n\tif (!siw_dev_qualified(netdev))\n\t\treturn -EINVAL;\n\n\tbase_dev = ib_device_get_by_netdev(netdev, RDMA_DRIVER_SIW);\n\tif (base_dev) {\n\t\tib_device_put(base_dev);\n\t\treturn -EEXIST;\n\t}\n\tsdev = siw_device_create(netdev);\n\tif (sdev) {\n\t\tdev_dbg(&netdev->dev, \"siw: new device\\n\");\n\n\t\tif (netif_running(netdev) && netif_carrier_ok(netdev))\n\t\t\tsdev->state = IB_PORT_ACTIVE;\n\t\telse\n\t\t\tsdev->state = IB_PORT_DOWN;\n\n\t\trv = siw_device_register(sdev, basedev_name);\n\t\tif (rv)\n\t\t\tib_dealloc_device(&sdev->base_dev);\n\t}\n\treturn rv;\n}\n\nstatic struct rdma_link_ops siw_link_ops = {\n\t.type = \"siw\",\n\t.newlink = siw_newlink,\n};\n\n \nstatic __init int siw_init_module(void)\n{\n\tint rv;\n\n\tif (SENDPAGE_THRESH < SIW_MAX_INLINE) {\n\t\tpr_info(\"siw: sendpage threshold too small: %u\\n\",\n\t\t\t(int)SENDPAGE_THRESH);\n\t\trv = -EINVAL;\n\t\tgoto out_error;\n\t}\n\trv = siw_init_cpulist();\n\tif (rv)\n\t\tgoto out_error;\n\n\trv = siw_cm_init();\n\tif (rv)\n\t\tgoto out_error;\n\n\tif (!siw_create_tx_threads()) {\n\t\tpr_info(\"siw: Could not start any TX thread\\n\");\n\t\trv = -ENOMEM;\n\t\tgoto out_error;\n\t}\n\t \n\tsiw_crypto_shash = crypto_alloc_shash(\"crc32c\", 0, 0);\n\tif (IS_ERR(siw_crypto_shash)) {\n\t\tpr_info(\"siw: Loading CRC32c failed: %ld\\n\",\n\t\t\tPTR_ERR(siw_crypto_shash));\n\t\tsiw_crypto_shash = NULL;\n\t\tif (mpa_crc_required) {\n\t\t\trv = -EOPNOTSUPP;\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\trv = register_netdevice_notifier(&siw_netdev_nb);\n\tif (rv)\n\t\tgoto out_error;\n\n\trdma_link_register(&siw_link_ops);\n\n\tpr_info(\"SoftiWARP attached\\n\");\n\treturn 0;\n\nout_error:\n\tsiw_stop_tx_threads();\n\n\tif (siw_crypto_shash)\n\t\tcrypto_free_shash(siw_crypto_shash);\n\n\tpr_info(\"SoftIWARP attach failed. Error: %d\\n\", rv);\n\n\tsiw_cm_exit();\n\tsiw_destroy_cpulist();\n\n\treturn rv;\n}\n\nstatic void __exit siw_exit_module(void)\n{\n\tsiw_stop_tx_threads();\n\n\tunregister_netdevice_notifier(&siw_netdev_nb);\n\trdma_link_unregister(&siw_link_ops);\n\tib_unregister_driver(RDMA_DRIVER_SIW);\n\n\tsiw_cm_exit();\n\n\tsiw_destroy_cpulist();\n\n\tif (siw_crypto_shash)\n\t\tcrypto_free_shash(siw_crypto_shash);\n\n\tpr_info(\"SoftiWARP detached\\n\");\n}\n\nmodule_init(siw_init_module);\nmodule_exit(siw_exit_module);\n\nMODULE_ALIAS_RDMA_LINK(\"siw\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}