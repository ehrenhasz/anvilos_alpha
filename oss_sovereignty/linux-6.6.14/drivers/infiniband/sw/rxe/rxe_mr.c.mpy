{
  "module_name": "rxe_mr.c",
  "hash_id": "08a0fb1fa7da8c36361c9b9c2981a7db3cd5fd5ae5f09381511f65ef601953cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_mr.c",
  "human_readable_source": "\n \n\n#include <linux/libnvdimm.h>\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\n \nu8 rxe_get_next_key(u32 last_key)\n{\n\tu8 key;\n\n\tdo {\n\t\tget_random_bytes(&key, 1);\n\t} while (key == last_key);\n\n\treturn key;\n}\n\nint mr_check_range(struct rxe_mr *mr, u64 iova, size_t length)\n{\n\tswitch (mr->ibmr.type) {\n\tcase IB_MR_TYPE_DMA:\n\t\treturn 0;\n\n\tcase IB_MR_TYPE_USER:\n\tcase IB_MR_TYPE_MEM_REG:\n\t\tif (iova < mr->ibmr.iova ||\n\t\t    iova + length > mr->ibmr.iova + mr->ibmr.length) {\n\t\t\trxe_dbg_mr(mr, \"iova/length out of range\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\n\tdefault:\n\t\trxe_dbg_mr(mr, \"mr type not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic void rxe_mr_init(int access, struct rxe_mr *mr)\n{\n\tu32 key = mr->elem.index << 8 | rxe_get_next_key(-1);\n\n\t \n\tmr->lkey = mr->ibmr.lkey = key;\n\tmr->rkey = mr->ibmr.rkey = key;\n\n\tmr->access = access;\n\tmr->ibmr.page_size = PAGE_SIZE;\n\tmr->page_mask = PAGE_MASK;\n\tmr->page_shift = PAGE_SHIFT;\n\tmr->state = RXE_MR_STATE_INVALID;\n}\n\nvoid rxe_mr_init_dma(int access, struct rxe_mr *mr)\n{\n\trxe_mr_init(access, mr);\n\n\tmr->state = RXE_MR_STATE_VALID;\n\tmr->ibmr.type = IB_MR_TYPE_DMA;\n}\n\nstatic unsigned long rxe_mr_iova_to_index(struct rxe_mr *mr, u64 iova)\n{\n\treturn (iova >> mr->page_shift) - (mr->ibmr.iova >> mr->page_shift);\n}\n\nstatic unsigned long rxe_mr_iova_to_page_offset(struct rxe_mr *mr, u64 iova)\n{\n\treturn iova & (mr_page_size(mr) - 1);\n}\n\nstatic bool is_pmem_page(struct page *pg)\n{\n\tunsigned long paddr = page_to_phys(pg);\n\n\treturn REGION_INTERSECTS ==\n\t       region_intersects(paddr, PAGE_SIZE, IORESOURCE_MEM,\n\t\t\t\t IORES_DESC_PERSISTENT_MEMORY);\n}\n\nstatic int rxe_mr_fill_pages_from_sgt(struct rxe_mr *mr, struct sg_table *sgt)\n{\n\tXA_STATE(xas, &mr->page_list, 0);\n\tstruct sg_page_iter sg_iter;\n\tstruct page *page;\n\tbool persistent = !!(mr->access & IB_ACCESS_FLUSH_PERSISTENT);\n\n\t__sg_page_iter_start(&sg_iter, sgt->sgl, sgt->orig_nents, 0);\n\tif (!__sg_page_iter_next(&sg_iter))\n\t\treturn 0;\n\n\tdo {\n\t\txas_lock(&xas);\n\t\twhile (true) {\n\t\t\tpage = sg_page_iter_page(&sg_iter);\n\n\t\t\tif (persistent && !is_pmem_page(page)) {\n\t\t\t\trxe_dbg_mr(mr, \"Page can't be persistent\\n\");\n\t\t\t\txas_set_err(&xas, -EINVAL);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\txas_store(&xas, page);\n\t\t\tif (xas_error(&xas))\n\t\t\t\tbreak;\n\t\t\txas_next(&xas);\n\t\t\tif (!__sg_page_iter_next(&sg_iter))\n\t\t\t\tbreak;\n\t\t}\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\treturn xas_error(&xas);\n}\n\nint rxe_mr_init_user(struct rxe_dev *rxe, u64 start, u64 length, u64 iova,\n\t\t     int access, struct rxe_mr *mr)\n{\n\tstruct ib_umem *umem;\n\tint err;\n\n\trxe_mr_init(access, mr);\n\n\txa_init(&mr->page_list);\n\n\tumem = ib_umem_get(&rxe->ib_dev, start, length, access);\n\tif (IS_ERR(umem)) {\n\t\trxe_dbg_mr(mr, \"Unable to pin memory region err = %d\\n\",\n\t\t\t(int)PTR_ERR(umem));\n\t\treturn PTR_ERR(umem);\n\t}\n\n\terr = rxe_mr_fill_pages_from_sgt(mr, &umem->sgt_append.sgt);\n\tif (err) {\n\t\tib_umem_release(umem);\n\t\treturn err;\n\t}\n\n\tmr->umem = umem;\n\tmr->ibmr.type = IB_MR_TYPE_USER;\n\tmr->state = RXE_MR_STATE_VALID;\n\n\treturn 0;\n}\n\nstatic int rxe_mr_alloc(struct rxe_mr *mr, int num_buf)\n{\n\tXA_STATE(xas, &mr->page_list, 0);\n\tint i = 0;\n\tint err;\n\n\txa_init(&mr->page_list);\n\n\tdo {\n\t\txas_lock(&xas);\n\t\twhile (i != num_buf) {\n\t\t\txas_store(&xas, XA_ZERO_ENTRY);\n\t\t\tif (xas_error(&xas))\n\t\t\t\tbreak;\n\t\t\txas_next(&xas);\n\t\t\ti++;\n\t\t}\n\t\txas_unlock(&xas);\n\t} while (xas_nomem(&xas, GFP_KERNEL));\n\n\terr = xas_error(&xas);\n\tif (err)\n\t\treturn err;\n\n\tmr->num_buf = num_buf;\n\n\treturn 0;\n}\n\nint rxe_mr_init_fast(int max_pages, struct rxe_mr *mr)\n{\n\tint err;\n\n\t \n\trxe_mr_init(RXE_ACCESS_REMOTE, mr);\n\n\terr = rxe_mr_alloc(mr, max_pages);\n\tif (err)\n\t\tgoto err1;\n\n\tmr->state = RXE_MR_STATE_FREE;\n\tmr->ibmr.type = IB_MR_TYPE_MEM_REG;\n\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nstatic int rxe_set_page(struct ib_mr *ibmr, u64 dma_addr)\n{\n\tstruct rxe_mr *mr = to_rmr(ibmr);\n\tstruct page *page = ib_virt_dma_to_page(dma_addr);\n\tbool persistent = !!(mr->access & IB_ACCESS_FLUSH_PERSISTENT);\n\tint err;\n\n\tif (persistent && !is_pmem_page(page)) {\n\t\trxe_dbg_mr(mr, \"Page cannot be persistent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(mr->nbuf == mr->num_buf))\n\t\treturn -ENOMEM;\n\n\terr = xa_err(xa_store(&mr->page_list, mr->nbuf, page, GFP_KERNEL));\n\tif (err)\n\t\treturn err;\n\n\tmr->nbuf++;\n\treturn 0;\n}\n\nint rxe_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sgl,\n\t\t  int sg_nents, unsigned int *sg_offset)\n{\n\tstruct rxe_mr *mr = to_rmr(ibmr);\n\tunsigned int page_size = mr_page_size(mr);\n\n\tmr->nbuf = 0;\n\tmr->page_shift = ilog2(page_size);\n\tmr->page_mask = ~((u64)page_size - 1);\n\tmr->page_offset = mr->ibmr.iova & (page_size - 1);\n\n\treturn ib_sg_to_pages(ibmr, sgl, sg_nents, sg_offset, rxe_set_page);\n}\n\nstatic int rxe_mr_copy_xarray(struct rxe_mr *mr, u64 iova, void *addr,\n\t\t\t      unsigned int length, enum rxe_mr_copy_dir dir)\n{\n\tunsigned int page_offset = rxe_mr_iova_to_page_offset(mr, iova);\n\tunsigned long index = rxe_mr_iova_to_index(mr, iova);\n\tunsigned int bytes;\n\tstruct page *page;\n\tvoid *va;\n\n\twhile (length) {\n\t\tpage = xa_load(&mr->page_list, index);\n\t\tif (!page)\n\t\t\treturn -EFAULT;\n\n\t\tbytes = min_t(unsigned int, length,\n\t\t\t\tmr_page_size(mr) - page_offset);\n\t\tva = kmap_local_page(page);\n\t\tif (dir == RXE_FROM_MR_OBJ)\n\t\t\tmemcpy(addr, va + page_offset, bytes);\n\t\telse\n\t\t\tmemcpy(va + page_offset, addr, bytes);\n\t\tkunmap_local(va);\n\n\t\tpage_offset = 0;\n\t\taddr += bytes;\n\t\tlength -= bytes;\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\nstatic void rxe_mr_copy_dma(struct rxe_mr *mr, u64 dma_addr, void *addr,\n\t\t\t    unsigned int length, enum rxe_mr_copy_dir dir)\n{\n\tunsigned int page_offset = dma_addr & (PAGE_SIZE - 1);\n\tunsigned int bytes;\n\tstruct page *page;\n\tu8 *va;\n\n\twhile (length) {\n\t\tpage = ib_virt_dma_to_page(dma_addr);\n\t\tbytes = min_t(unsigned int, length,\n\t\t\t\tPAGE_SIZE - page_offset);\n\t\tva = kmap_local_page(page);\n\n\t\tif (dir == RXE_TO_MR_OBJ)\n\t\t\tmemcpy(va + page_offset, addr, bytes);\n\t\telse\n\t\t\tmemcpy(addr, va + page_offset, bytes);\n\n\t\tkunmap_local(va);\n\t\tpage_offset = 0;\n\t\tdma_addr += bytes;\n\t\taddr += bytes;\n\t\tlength -= bytes;\n\t}\n}\n\nint rxe_mr_copy(struct rxe_mr *mr, u64 iova, void *addr,\n\t\tunsigned int length, enum rxe_mr_copy_dir dir)\n{\n\tint err;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (WARN_ON(!mr))\n\t\treturn -EINVAL;\n\n\tif (mr->ibmr.type == IB_MR_TYPE_DMA) {\n\t\trxe_mr_copy_dma(mr, iova, addr, length, dir);\n\t\treturn 0;\n\t}\n\n\terr = mr_check_range(mr, iova, length);\n\tif (unlikely(err)) {\n\t\trxe_dbg_mr(mr, \"iova out of range\");\n\t\treturn err;\n\t}\n\n\treturn rxe_mr_copy_xarray(mr, iova, addr, length, dir);\n}\n\n \nint copy_data(\n\tstruct rxe_pd\t\t*pd,\n\tint\t\t\taccess,\n\tstruct rxe_dma_info\t*dma,\n\tvoid\t\t\t*addr,\n\tint\t\t\tlength,\n\tenum rxe_mr_copy_dir\tdir)\n{\n\tint\t\t\tbytes;\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\tstruct rxe_mr\t\t*mr\t= NULL;\n\tu64\t\t\tiova;\n\tint\t\t\terr;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (length > resid) {\n\t\terr = -EINVAL;\n\t\tgoto err2;\n\t}\n\n\tif (sge->length && (offset < sge->length)) {\n\t\tmr = lookup_mr(pd, access, sge->lkey, RXE_LOOKUP_LOCAL);\n\t\tif (!mr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\twhile (length > 0) {\n\t\tbytes = length;\n\n\t\tif (offset >= sge->length) {\n\t\t\tif (mr) {\n\t\t\t\trxe_put(mr);\n\t\t\t\tmr = NULL;\n\t\t\t}\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\n\t\t\tif (dma->cur_sge >= dma->num_sge) {\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto err2;\n\t\t\t}\n\n\t\t\tif (sge->length) {\n\t\t\t\tmr = lookup_mr(pd, access, sge->lkey,\n\t\t\t\t\t       RXE_LOOKUP_LOCAL);\n\t\t\t\tif (!mr) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto err1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\tif (bytes > 0) {\n\t\t\tiova = sge->addr + offset;\n\t\t\terr = rxe_mr_copy(mr, iova, addr, bytes, dir);\n\t\t\tif (err)\n\t\t\t\tgoto err2;\n\n\t\t\toffset\t+= bytes;\n\t\t\tresid\t-= bytes;\n\t\t\tlength\t-= bytes;\n\t\t\taddr\t+= bytes;\n\t\t}\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\tif (mr)\n\t\trxe_put(mr);\n\n\treturn 0;\n\nerr2:\n\tif (mr)\n\t\trxe_put(mr);\nerr1:\n\treturn err;\n}\n\nint rxe_flush_pmem_iova(struct rxe_mr *mr, u64 iova, unsigned int length)\n{\n\tunsigned int page_offset;\n\tunsigned long index;\n\tstruct page *page;\n\tunsigned int bytes;\n\tint err;\n\tu8 *va;\n\n\t \n\tif (WARN_ON(!mr))\n\t\treturn -EINVAL;\n\n\tif (length == 0)\n\t\treturn 0;\n\n\tif (mr->ibmr.type == IB_MR_TYPE_DMA)\n\t\treturn -EFAULT;\n\n\terr = mr_check_range(mr, iova, length);\n\tif (err)\n\t\treturn err;\n\n\twhile (length > 0) {\n\t\tindex = rxe_mr_iova_to_index(mr, iova);\n\t\tpage = xa_load(&mr->page_list, index);\n\t\tpage_offset = rxe_mr_iova_to_page_offset(mr, iova);\n\t\tif (!page)\n\t\t\treturn -EFAULT;\n\t\tbytes = min_t(unsigned int, length,\n\t\t\t\tmr_page_size(mr) - page_offset);\n\n\t\tva = kmap_local_page(page);\n\t\tarch_wb_cache_pmem(va + page_offset, bytes);\n\t\tkunmap_local(va);\n\n\t\tlength -= bytes;\n\t\tiova += bytes;\n\t\tpage_offset = 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic DEFINE_SPINLOCK(atomic_ops_lock);\n\nint rxe_mr_do_atomic_op(struct rxe_mr *mr, u64 iova, int opcode,\n\t\t\tu64 compare, u64 swap_add, u64 *orig_val)\n{\n\tunsigned int page_offset;\n\tstruct page *page;\n\tu64 value;\n\tu64 *va;\n\n\tif (unlikely(mr->state != RXE_MR_STATE_VALID)) {\n\t\trxe_dbg_mr(mr, \"mr not in valid state\");\n\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t}\n\n\tif (mr->ibmr.type == IB_MR_TYPE_DMA) {\n\t\tpage_offset = iova & (PAGE_SIZE - 1);\n\t\tpage = ib_virt_dma_to_page(iova);\n\t} else {\n\t\tunsigned long index;\n\t\tint err;\n\n\t\terr = mr_check_range(mr, iova, sizeof(value));\n\t\tif (err) {\n\t\t\trxe_dbg_mr(mr, \"iova out of range\");\n\t\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t\t}\n\t\tpage_offset = rxe_mr_iova_to_page_offset(mr, iova);\n\t\tindex = rxe_mr_iova_to_index(mr, iova);\n\t\tpage = xa_load(&mr->page_list, index);\n\t\tif (!page)\n\t\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t}\n\n\tif (unlikely(page_offset & 0x7)) {\n\t\trxe_dbg_mr(mr, \"iova not aligned\");\n\t\treturn RESPST_ERR_MISALIGNED_ATOMIC;\n\t}\n\n\tva = kmap_local_page(page);\n\n\tspin_lock_bh(&atomic_ops_lock);\n\tvalue = *orig_val = va[page_offset >> 3];\n\n\tif (opcode == IB_OPCODE_RC_COMPARE_SWAP) {\n\t\tif (value == compare)\n\t\t\tva[page_offset >> 3] = swap_add;\n\t} else {\n\t\tvalue += swap_add;\n\t\tva[page_offset >> 3] = value;\n\t}\n\tspin_unlock_bh(&atomic_ops_lock);\n\n\tkunmap_local(va);\n\n\treturn 0;\n}\n\n#if defined CONFIG_64BIT\n \nint rxe_mr_do_atomic_write(struct rxe_mr *mr, u64 iova, u64 value)\n{\n\tunsigned int page_offset;\n\tstruct page *page;\n\tu64 *va;\n\n\t \n\tif (unlikely(mr->state != RXE_MR_STATE_VALID)) {\n\t\trxe_dbg_mr(mr, \"mr not in valid state\");\n\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t}\n\n\tif (mr->ibmr.type == IB_MR_TYPE_DMA) {\n\t\tpage_offset = iova & (PAGE_SIZE - 1);\n\t\tpage = ib_virt_dma_to_page(iova);\n\t} else {\n\t\tunsigned long index;\n\t\tint err;\n\n\t\t \n\t\terr = mr_check_range(mr, iova, sizeof(value));\n\t\tif (unlikely(err)) {\n\t\t\trxe_dbg_mr(mr, \"iova out of range\");\n\t\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t\t}\n\t\tpage_offset = rxe_mr_iova_to_page_offset(mr, iova);\n\t\tindex = rxe_mr_iova_to_index(mr, iova);\n\t\tpage = xa_load(&mr->page_list, index);\n\t\tif (!page)\n\t\t\treturn RESPST_ERR_RKEY_VIOLATION;\n\t}\n\n\t \n\tif (unlikely(page_offset & 0x7)) {\n\t\trxe_dbg_mr(mr, \"misaligned address\");\n\t\treturn RESPST_ERR_MISALIGNED_ATOMIC;\n\t}\n\n\tva = kmap_local_page(page);\n\n\t \n\tsmp_store_release(&va[page_offset >> 3], value);\n\n\tkunmap_local(va);\n\n\treturn 0;\n}\n#else\nint rxe_mr_do_atomic_write(struct rxe_mr *mr, u64 iova, u64 value)\n{\n\treturn RESPST_ERR_UNSUPPORTED_OPCODE;\n}\n#endif\n\nint advance_dma_data(struct rxe_dma_info *dma, unsigned int length)\n{\n\tstruct rxe_sge\t\t*sge\t= &dma->sge[dma->cur_sge];\n\tint\t\t\toffset\t= dma->sge_offset;\n\tint\t\t\tresid\t= dma->resid;\n\n\twhile (length) {\n\t\tunsigned int bytes;\n\n\t\tif (offset >= sge->length) {\n\t\t\tsge++;\n\t\t\tdma->cur_sge++;\n\t\t\toffset = 0;\n\t\t\tif (dma->cur_sge >= dma->num_sge)\n\t\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tbytes = length;\n\n\t\tif (bytes > sge->length - offset)\n\t\t\tbytes = sge->length - offset;\n\n\t\toffset\t+= bytes;\n\t\tresid\t-= bytes;\n\t\tlength\t-= bytes;\n\t}\n\n\tdma->sge_offset = offset;\n\tdma->resid\t= resid;\n\n\treturn 0;\n}\n\nstruct rxe_mr *lookup_mr(struct rxe_pd *pd, int access, u32 key,\n\t\t\t enum rxe_mr_lookup_type type)\n{\n\tstruct rxe_mr *mr;\n\tstruct rxe_dev *rxe = to_rdev(pd->ibpd.device);\n\tint index = key >> 8;\n\n\tmr = rxe_pool_get_index(&rxe->mr_pool, index);\n\tif (!mr)\n\t\treturn NULL;\n\n\tif (unlikely((type == RXE_LOOKUP_LOCAL && mr->lkey != key) ||\n\t\t     (type == RXE_LOOKUP_REMOTE && mr->rkey != key) ||\n\t\t     mr_pd(mr) != pd || ((access & mr->access) != access) ||\n\t\t     mr->state != RXE_MR_STATE_VALID)) {\n\t\trxe_put(mr);\n\t\tmr = NULL;\n\t}\n\n\treturn mr;\n}\n\nint rxe_invalidate_mr(struct rxe_qp *qp, u32 key)\n{\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\tstruct rxe_mr *mr;\n\tint remote;\n\tint ret;\n\n\tmr = rxe_pool_get_index(&rxe->mr_pool, key >> 8);\n\tif (!mr) {\n\t\trxe_dbg_qp(qp, \"No MR for key %#x\\n\", key);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tremote = mr->access & RXE_ACCESS_REMOTE;\n\tif (remote ? (key != mr->rkey) : (key != mr->lkey)) {\n\t\trxe_dbg_mr(mr, \"wr key (%#x) doesn't match mr key (%#x)\\n\",\n\t\t\tkey, (remote ? mr->rkey : mr->lkey));\n\t\tret = -EINVAL;\n\t\tgoto err_drop_ref;\n\t}\n\n\tif (atomic_read(&mr->num_mw) > 0) {\n\t\trxe_dbg_mr(mr, \"Attempt to invalidate an MR while bound to MWs\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_drop_ref;\n\t}\n\n\tif (unlikely(mr->ibmr.type != IB_MR_TYPE_MEM_REG)) {\n\t\trxe_dbg_mr(mr, \"Type (%d) is wrong\\n\", mr->ibmr.type);\n\t\tret = -EINVAL;\n\t\tgoto err_drop_ref;\n\t}\n\n\tmr->state = RXE_MR_STATE_FREE;\n\tret = 0;\n\nerr_drop_ref:\n\trxe_put(mr);\nerr:\n\treturn ret;\n}\n\n \nint rxe_reg_fast_mr(struct rxe_qp *qp, struct rxe_send_wqe *wqe)\n{\n\tstruct rxe_mr *mr = to_rmr(wqe->wr.wr.reg.mr);\n\tu32 key = wqe->wr.wr.reg.key;\n\tu32 access = wqe->wr.wr.reg.access;\n\n\t \n\tif (unlikely(mr->state != RXE_MR_STATE_FREE)) {\n\t\trxe_dbg_mr(mr, \"mr->lkey = 0x%x not free\\n\", mr->lkey);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely(qp->ibqp.pd != mr->ibmr.pd)) {\n\t\trxe_dbg_mr(mr, \"qp->pd and mr->pd don't match\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (unlikely((mr->lkey & ~0xff) != (key & ~0xff))) {\n\t\trxe_dbg_mr(mr, \"key = 0x%x has wrong index mr->lkey = 0x%x\\n\",\n\t\t\tkey, mr->lkey);\n\t\treturn -EINVAL;\n\t}\n\n\tmr->access = access;\n\tmr->lkey = key;\n\tmr->rkey = key;\n\tmr->ibmr.iova = wqe->wr.wr.reg.mr->iova;\n\tmr->state = RXE_MR_STATE_VALID;\n\n\treturn 0;\n}\n\nvoid rxe_mr_cleanup(struct rxe_pool_elem *elem)\n{\n\tstruct rxe_mr *mr = container_of(elem, typeof(*mr), elem);\n\n\trxe_put(mr_pd(mr));\n\tib_umem_release(mr->umem);\n\n\tif (mr->ibmr.type != IB_MR_TYPE_DMA)\n\t\txa_destroy(&mr->page_list);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}