{
  "module_name": "rxe_comp.c",
  "hash_id": "1e8154d230b303137b1e4d7bdb0ffda3cc89da534019e294e0c07de6902be29a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_comp.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n#include \"rxe_queue.h\"\n#include \"rxe_task.h\"\n\nenum comp_state {\n\tCOMPST_GET_ACK,\n\tCOMPST_GET_WQE,\n\tCOMPST_COMP_WQE,\n\tCOMPST_COMP_ACK,\n\tCOMPST_CHECK_PSN,\n\tCOMPST_CHECK_ACK,\n\tCOMPST_READ,\n\tCOMPST_ATOMIC,\n\tCOMPST_WRITE_SEND,\n\tCOMPST_UPDATE_COMP,\n\tCOMPST_ERROR_RETRY,\n\tCOMPST_RNR_RETRY,\n\tCOMPST_ERROR,\n\tCOMPST_EXIT,  \n\tCOMPST_DONE,  \n};\n\nstatic char *comp_state_name[] =  {\n\t[COMPST_GET_ACK]\t\t= \"GET ACK\",\n\t[COMPST_GET_WQE]\t\t= \"GET WQE\",\n\t[COMPST_COMP_WQE]\t\t= \"COMP WQE\",\n\t[COMPST_COMP_ACK]\t\t= \"COMP ACK\",\n\t[COMPST_CHECK_PSN]\t\t= \"CHECK PSN\",\n\t[COMPST_CHECK_ACK]\t\t= \"CHECK ACK\",\n\t[COMPST_READ]\t\t\t= \"READ\",\n\t[COMPST_ATOMIC]\t\t\t= \"ATOMIC\",\n\t[COMPST_WRITE_SEND]\t\t= \"WRITE/SEND\",\n\t[COMPST_UPDATE_COMP]\t\t= \"UPDATE COMP\",\n\t[COMPST_ERROR_RETRY]\t\t= \"ERROR RETRY\",\n\t[COMPST_RNR_RETRY]\t\t= \"RNR RETRY\",\n\t[COMPST_ERROR]\t\t\t= \"ERROR\",\n\t[COMPST_EXIT]\t\t\t= \"EXIT\",\n\t[COMPST_DONE]\t\t\t= \"DONE\",\n};\n\nstatic unsigned long rnrnak_usec[32] = {\n\t[IB_RNR_TIMER_655_36] = 655360,\n\t[IB_RNR_TIMER_000_01] = 10,\n\t[IB_RNR_TIMER_000_02] = 20,\n\t[IB_RNR_TIMER_000_03] = 30,\n\t[IB_RNR_TIMER_000_04] = 40,\n\t[IB_RNR_TIMER_000_06] = 60,\n\t[IB_RNR_TIMER_000_08] = 80,\n\t[IB_RNR_TIMER_000_12] = 120,\n\t[IB_RNR_TIMER_000_16] = 160,\n\t[IB_RNR_TIMER_000_24] = 240,\n\t[IB_RNR_TIMER_000_32] = 320,\n\t[IB_RNR_TIMER_000_48] = 480,\n\t[IB_RNR_TIMER_000_64] = 640,\n\t[IB_RNR_TIMER_000_96] = 960,\n\t[IB_RNR_TIMER_001_28] = 1280,\n\t[IB_RNR_TIMER_001_92] = 1920,\n\t[IB_RNR_TIMER_002_56] = 2560,\n\t[IB_RNR_TIMER_003_84] = 3840,\n\t[IB_RNR_TIMER_005_12] = 5120,\n\t[IB_RNR_TIMER_007_68] = 7680,\n\t[IB_RNR_TIMER_010_24] = 10240,\n\t[IB_RNR_TIMER_015_36] = 15360,\n\t[IB_RNR_TIMER_020_48] = 20480,\n\t[IB_RNR_TIMER_030_72] = 30720,\n\t[IB_RNR_TIMER_040_96] = 40960,\n\t[IB_RNR_TIMER_061_44] = 61410,\n\t[IB_RNR_TIMER_081_92] = 81920,\n\t[IB_RNR_TIMER_122_88] = 122880,\n\t[IB_RNR_TIMER_163_84] = 163840,\n\t[IB_RNR_TIMER_245_76] = 245760,\n\t[IB_RNR_TIMER_327_68] = 327680,\n\t[IB_RNR_TIMER_491_52] = 491520,\n};\n\nstatic inline unsigned long rnrnak_jiffies(u8 timeout)\n{\n\treturn max_t(unsigned long,\n\t\tusecs_to_jiffies(rnrnak_usec[timeout]), 1);\n}\n\nstatic enum ib_wc_opcode wr_to_wc_opcode(enum ib_wr_opcode opcode)\n{\n\tswitch (opcode) {\n\tcase IB_WR_RDMA_WRITE:\t\t\treturn IB_WC_RDMA_WRITE;\n\tcase IB_WR_RDMA_WRITE_WITH_IMM:\t\treturn IB_WC_RDMA_WRITE;\n\tcase IB_WR_SEND:\t\t\treturn IB_WC_SEND;\n\tcase IB_WR_SEND_WITH_IMM:\t\treturn IB_WC_SEND;\n\tcase IB_WR_RDMA_READ:\t\t\treturn IB_WC_RDMA_READ;\n\tcase IB_WR_ATOMIC_CMP_AND_SWP:\t\treturn IB_WC_COMP_SWAP;\n\tcase IB_WR_ATOMIC_FETCH_AND_ADD:\treturn IB_WC_FETCH_ADD;\n\tcase IB_WR_LSO:\t\t\t\treturn IB_WC_LSO;\n\tcase IB_WR_SEND_WITH_INV:\t\treturn IB_WC_SEND;\n\tcase IB_WR_RDMA_READ_WITH_INV:\t\treturn IB_WC_RDMA_READ;\n\tcase IB_WR_LOCAL_INV:\t\t\treturn IB_WC_LOCAL_INV;\n\tcase IB_WR_REG_MR:\t\t\treturn IB_WC_REG_MR;\n\tcase IB_WR_BIND_MW:\t\t\treturn IB_WC_BIND_MW;\n\tcase IB_WR_ATOMIC_WRITE:\t\treturn IB_WC_ATOMIC_WRITE;\n\tcase IB_WR_FLUSH:\t\t\treturn IB_WC_FLUSH;\n\n\tdefault:\n\t\treturn 0xff;\n\t}\n}\n\nvoid retransmit_timer(struct timer_list *t)\n{\n\tstruct rxe_qp *qp = from_timer(qp, t, retrans_timer);\n\tunsigned long flags;\n\n\trxe_dbg_qp(qp, \"retransmit timer fired\\n\");\n\n\tspin_lock_irqsave(&qp->state_lock, flags);\n\tif (qp->valid) {\n\t\tqp->comp.timeout = 1;\n\t\trxe_sched_task(&qp->comp.task);\n\t}\n\tspin_unlock_irqrestore(&qp->state_lock, flags);\n}\n\nvoid rxe_comp_queue_pkt(struct rxe_qp *qp, struct sk_buff *skb)\n{\n\tint must_sched;\n\n\tskb_queue_tail(&qp->resp_pkts, skb);\n\n\tmust_sched = skb_queue_len(&qp->resp_pkts) > 1;\n\tif (must_sched != 0)\n\t\trxe_counter_inc(SKB_TO_PKT(skb)->rxe, RXE_CNT_COMPLETER_SCHED);\n\n\tif (must_sched)\n\t\trxe_sched_task(&qp->comp.task);\n\telse\n\t\trxe_run_task(&qp->comp.task);\n}\n\nstatic inline enum comp_state get_wqe(struct rxe_qp *qp,\n\t\t\t\t      struct rxe_pkt_info *pkt,\n\t\t\t\t      struct rxe_send_wqe **wqe_p)\n{\n\tstruct rxe_send_wqe *wqe;\n\n\t \n\twqe = queue_head(qp->sq.queue, QUEUE_TYPE_FROM_CLIENT);\n\t*wqe_p = wqe;\n\n\t \n\tif (!wqe || wqe->state == wqe_state_posted)\n\t\treturn pkt ? COMPST_DONE : COMPST_EXIT;\n\n\t \n\tif (wqe->state == wqe_state_done)\n\t\treturn COMPST_COMP_WQE;\n\n\t \n\tif (wqe->state == wqe_state_error)\n\t\treturn COMPST_ERROR;\n\n\t \n\treturn pkt ? COMPST_CHECK_PSN : COMPST_EXIT;\n}\n\nstatic inline void reset_retry_counters(struct rxe_qp *qp)\n{\n\tqp->comp.retry_cnt = qp->attr.retry_cnt;\n\tqp->comp.rnr_retry = qp->attr.rnr_retry;\n\tqp->comp.started_retry = 0;\n}\n\nstatic inline enum comp_state check_psn(struct rxe_qp *qp,\n\t\t\t\t\tstruct rxe_pkt_info *pkt,\n\t\t\t\t\tstruct rxe_send_wqe *wqe)\n{\n\ts32 diff;\n\n\t \n\tdiff = psn_compare(pkt->psn, wqe->last_psn);\n\tif (diff > 0) {\n\t\tif (wqe->state == wqe_state_pending) {\n\t\t\tif (wqe->mask & WR_ATOMIC_OR_READ_MASK)\n\t\t\t\treturn COMPST_ERROR_RETRY;\n\n\t\t\treset_retry_counters(qp);\n\t\t\treturn COMPST_COMP_WQE;\n\t\t} else {\n\t\t\treturn COMPST_DONE;\n\t\t}\n\t}\n\n\t \n\tdiff = psn_compare(pkt->psn, qp->comp.psn);\n\tif (diff < 0) {\n\t\t \n\t\tif (pkt->psn == wqe->last_psn)\n\t\t\treturn COMPST_COMP_ACK;\n\t\telse if (pkt->opcode == IB_OPCODE_RC_ACKNOWLEDGE &&\n\t\t\t (qp->comp.opcode == IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST ||\n\t\t\t  qp->comp.opcode == IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE))\n\t\t\treturn COMPST_CHECK_ACK;\n\t\telse\n\t\t\treturn COMPST_DONE;\n\t} else if ((diff > 0) && (wqe->mask & WR_ATOMIC_OR_READ_MASK)) {\n\t\treturn COMPST_DONE;\n\t} else {\n\t\treturn COMPST_CHECK_ACK;\n\t}\n}\n\nstatic inline enum comp_state check_ack(struct rxe_qp *qp,\n\t\t\t\t\tstruct rxe_pkt_info *pkt,\n\t\t\t\t\tstruct rxe_send_wqe *wqe)\n{\n\tunsigned int mask = pkt->mask;\n\tu8 syn;\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\n\t \n\tswitch (qp->comp.opcode) {\n\tcase -1:\n\t\t \n\t\tif (!(mask & RXE_START_MASK))\n\t\t\treturn COMPST_ERROR;\n\n\t\tbreak;\n\n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST:\n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE:\n\t\t \n\t\tif (pkt->opcode == IB_OPCODE_RC_ACKNOWLEDGE)\n\t\t\tbreak;\n\n\t\tif (pkt->opcode != IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE &&\n\t\t    pkt->opcode != IB_OPCODE_RC_RDMA_READ_RESPONSE_LAST) {\n\t\t\t \n\t\t\tif ((pkt->psn == wqe->first_psn &&\n\t\t\t     pkt->opcode ==\n\t\t\t     IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST) ||\n\t\t\t    (wqe->first_psn == wqe->last_psn &&\n\t\t\t     pkt->opcode ==\n\t\t\t     IB_OPCODE_RC_RDMA_READ_RESPONSE_ONLY))\n\t\t\t\tbreak;\n\n\t\t\treturn COMPST_ERROR;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n\n\t \n\tswitch (pkt->opcode) {\n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_FIRST:\n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_LAST:\n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_ONLY:\n\t\tsyn = aeth_syn(pkt);\n\n\t\tif ((syn & AETH_TYPE_MASK) != AETH_ACK)\n\t\t\treturn COMPST_ERROR;\n\n\t\tif (wqe->wr.opcode == IB_WR_ATOMIC_WRITE)\n\t\t\treturn COMPST_WRITE_SEND;\n\n\t\tfallthrough;\n\t\t \n\tcase IB_OPCODE_RC_RDMA_READ_RESPONSE_MIDDLE:\n\t\tif (wqe->wr.opcode != IB_WR_RDMA_READ &&\n\t\t    wqe->wr.opcode != IB_WR_RDMA_READ_WITH_INV &&\n\t\t    wqe->wr.opcode != IB_WR_FLUSH) {\n\t\t\twqe->status = IB_WC_FATAL_ERR;\n\t\t\treturn COMPST_ERROR;\n\t\t}\n\t\treset_retry_counters(qp);\n\t\treturn COMPST_READ;\n\n\tcase IB_OPCODE_RC_ATOMIC_ACKNOWLEDGE:\n\t\tsyn = aeth_syn(pkt);\n\n\t\tif ((syn & AETH_TYPE_MASK) != AETH_ACK)\n\t\t\treturn COMPST_ERROR;\n\n\t\tif (wqe->wr.opcode != IB_WR_ATOMIC_CMP_AND_SWP &&\n\t\t    wqe->wr.opcode != IB_WR_ATOMIC_FETCH_AND_ADD)\n\t\t\treturn COMPST_ERROR;\n\t\treset_retry_counters(qp);\n\t\treturn COMPST_ATOMIC;\n\n\tcase IB_OPCODE_RC_ACKNOWLEDGE:\n\t\tsyn = aeth_syn(pkt);\n\t\tswitch (syn & AETH_TYPE_MASK) {\n\t\tcase AETH_ACK:\n\t\t\treset_retry_counters(qp);\n\t\t\treturn COMPST_WRITE_SEND;\n\n\t\tcase AETH_RNR_NAK:\n\t\t\trxe_counter_inc(rxe, RXE_CNT_RCV_RNR);\n\t\t\treturn COMPST_RNR_RETRY;\n\n\t\tcase AETH_NAK:\n\t\t\tswitch (syn) {\n\t\t\tcase AETH_NAK_PSN_SEQ_ERROR:\n\t\t\t\t \n\t\t\t\tif (psn_compare(pkt->psn, qp->comp.psn) > 0) {\n\t\t\t\t\trxe_counter_inc(rxe,\n\t\t\t\t\t\t\tRXE_CNT_RCV_SEQ_ERR);\n\t\t\t\t\tqp->comp.psn = pkt->psn;\n\t\t\t\t\tif (qp->req.wait_psn) {\n\t\t\t\t\t\tqp->req.wait_psn = 0;\n\t\t\t\t\t\trxe_sched_task(&qp->req.task);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn COMPST_ERROR_RETRY;\n\n\t\t\tcase AETH_NAK_INVALID_REQ:\n\t\t\t\twqe->status = IB_WC_REM_INV_REQ_ERR;\n\t\t\t\treturn COMPST_ERROR;\n\n\t\t\tcase AETH_NAK_REM_ACC_ERR:\n\t\t\t\twqe->status = IB_WC_REM_ACCESS_ERR;\n\t\t\t\treturn COMPST_ERROR;\n\n\t\t\tcase AETH_NAK_REM_OP_ERR:\n\t\t\t\twqe->status = IB_WC_REM_OP_ERR;\n\t\t\t\treturn COMPST_ERROR;\n\n\t\t\tdefault:\n\t\t\t\trxe_dbg_qp(qp, \"unexpected nak %x\\n\", syn);\n\t\t\t\twqe->status = IB_WC_REM_OP_ERR;\n\t\t\t\treturn COMPST_ERROR;\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn COMPST_ERROR;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trxe_dbg_qp(qp, \"unexpected opcode\\n\");\n\t}\n\n\treturn COMPST_ERROR;\n}\n\nstatic inline enum comp_state do_read(struct rxe_qp *qp,\n\t\t\t\t      struct rxe_pkt_info *pkt,\n\t\t\t\t      struct rxe_send_wqe *wqe)\n{\n\tint ret;\n\n\tret = copy_data(qp->pd, IB_ACCESS_LOCAL_WRITE,\n\t\t\t&wqe->dma, payload_addr(pkt),\n\t\t\tpayload_size(pkt), RXE_TO_MR_OBJ);\n\tif (ret) {\n\t\twqe->status = IB_WC_LOC_PROT_ERR;\n\t\treturn COMPST_ERROR;\n\t}\n\n\tif (wqe->dma.resid == 0 && (pkt->mask & RXE_END_MASK))\n\t\treturn COMPST_COMP_ACK;\n\n\treturn COMPST_UPDATE_COMP;\n}\n\nstatic inline enum comp_state do_atomic(struct rxe_qp *qp,\n\t\t\t\t\tstruct rxe_pkt_info *pkt,\n\t\t\t\t\tstruct rxe_send_wqe *wqe)\n{\n\tint ret;\n\n\tu64 atomic_orig = atmack_orig(pkt);\n\n\tret = copy_data(qp->pd, IB_ACCESS_LOCAL_WRITE,\n\t\t\t&wqe->dma, &atomic_orig,\n\t\t\tsizeof(u64), RXE_TO_MR_OBJ);\n\tif (ret) {\n\t\twqe->status = IB_WC_LOC_PROT_ERR;\n\t\treturn COMPST_ERROR;\n\t}\n\n\treturn COMPST_COMP_ACK;\n}\n\nstatic void make_send_cqe(struct rxe_qp *qp, struct rxe_send_wqe *wqe,\n\t\t\t  struct rxe_cqe *cqe)\n{\n\tstruct ib_wc *wc = &cqe->ibwc;\n\tstruct ib_uverbs_wc *uwc = &cqe->uibwc;\n\n\tmemset(cqe, 0, sizeof(*cqe));\n\n\tif (!qp->is_user) {\n\t\twc->wr_id = wqe->wr.wr_id;\n\t\twc->status = wqe->status;\n\t\twc->qp = &qp->ibqp;\n\t} else {\n\t\tuwc->wr_id = wqe->wr.wr_id;\n\t\tuwc->status = wqe->status;\n\t\tuwc->qp_num = qp->ibqp.qp_num;\n\t}\n\n\tif (wqe->status == IB_WC_SUCCESS) {\n\t\tif (!qp->is_user) {\n\t\t\twc->opcode = wr_to_wc_opcode(wqe->wr.opcode);\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE_WITH_IMM ||\n\t\t\t    wqe->wr.opcode == IB_WR_SEND_WITH_IMM)\n\t\t\t\twc->wc_flags = IB_WC_WITH_IMM;\n\t\t\twc->byte_len = wqe->dma.length;\n\t\t} else {\n\t\t\tuwc->opcode = wr_to_wc_opcode(wqe->wr.opcode);\n\t\t\tif (wqe->wr.opcode == IB_WR_RDMA_WRITE_WITH_IMM ||\n\t\t\t    wqe->wr.opcode == IB_WR_SEND_WITH_IMM)\n\t\t\t\tuwc->wc_flags = IB_WC_WITH_IMM;\n\t\t\tuwc->byte_len = wqe->dma.length;\n\t\t}\n\t} else {\n\t\tif (wqe->status != IB_WC_WR_FLUSH_ERR)\n\t\t\trxe_err_qp(qp, \"non-flush error status = %d\",\n\t\t\t\twqe->status);\n\t}\n}\n\n \nstatic void do_complete(struct rxe_qp *qp, struct rxe_send_wqe *wqe)\n{\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\tstruct rxe_cqe cqe;\n\tbool post;\n\n\t \n\tpost = ((qp->sq_sig_type == IB_SIGNAL_ALL_WR) ||\n\t\t\t(wqe->wr.send_flags & IB_SEND_SIGNALED) ||\n\t\t\twqe->status != IB_WC_SUCCESS);\n\n\tif (post)\n\t\tmake_send_cqe(qp, wqe, &cqe);\n\n\tqueue_advance_consumer(qp->sq.queue, QUEUE_TYPE_FROM_CLIENT);\n\n\tif (post)\n\t\trxe_cq_post(qp->scq, &cqe, 0);\n\n\tif (wqe->wr.opcode == IB_WR_SEND ||\n\t    wqe->wr.opcode == IB_WR_SEND_WITH_IMM ||\n\t    wqe->wr.opcode == IB_WR_SEND_WITH_INV)\n\t\trxe_counter_inc(rxe, RXE_CNT_RDMA_SEND);\n\n\t \n\tif (qp->req.wait_fence) {\n\t\tqp->req.wait_fence = 0;\n\t\trxe_sched_task(&qp->req.task);\n\t}\n}\n\nstatic void comp_check_sq_drain_done(struct rxe_qp *qp)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->state_lock, flags);\n\tif (unlikely(qp_state(qp) == IB_QPS_SQD)) {\n\t\tif (qp->attr.sq_draining && qp->comp.psn == qp->req.psn) {\n\t\t\tqp->attr.sq_draining = 0;\n\t\t\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\n\t\t\tif (qp->ibqp.event_handler) {\n\t\t\t\tstruct ib_event ev;\n\n\t\t\t\tev.device = qp->ibqp.device;\n\t\t\t\tev.element.qp = &qp->ibqp;\n\t\t\t\tev.event = IB_EVENT_SQ_DRAINED;\n\t\t\t\tqp->ibqp.event_handler(&ev,\n\t\t\t\t\tqp->ibqp.qp_context);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&qp->state_lock, flags);\n}\n\nstatic inline enum comp_state complete_ack(struct rxe_qp *qp,\n\t\t\t\t\t   struct rxe_pkt_info *pkt,\n\t\t\t\t\t   struct rxe_send_wqe *wqe)\n{\n\tif (wqe->has_rd_atomic) {\n\t\twqe->has_rd_atomic = 0;\n\t\tatomic_inc(&qp->req.rd_atomic);\n\t\tif (qp->req.need_rd_atomic) {\n\t\t\tqp->comp.timeout_retry = 0;\n\t\t\tqp->req.need_rd_atomic = 0;\n\t\t\trxe_sched_task(&qp->req.task);\n\t\t}\n\t}\n\n\tcomp_check_sq_drain_done(qp);\n\n\tdo_complete(qp, wqe);\n\n\tif (psn_compare(pkt->psn, qp->comp.psn) >= 0)\n\t\treturn COMPST_UPDATE_COMP;\n\telse\n\t\treturn COMPST_DONE;\n}\n\nstatic inline enum comp_state complete_wqe(struct rxe_qp *qp,\n\t\t\t\t\t   struct rxe_pkt_info *pkt,\n\t\t\t\t\t   struct rxe_send_wqe *wqe)\n{\n\tif (pkt && wqe->state == wqe_state_pending) {\n\t\tif (psn_compare(wqe->last_psn, qp->comp.psn) >= 0) {\n\t\t\tqp->comp.psn = (wqe->last_psn + 1) & BTH_PSN_MASK;\n\t\t\tqp->comp.opcode = -1;\n\t\t}\n\n\t\tif (qp->req.wait_psn) {\n\t\t\tqp->req.wait_psn = 0;\n\t\t\trxe_sched_task(&qp->req.task);\n\t\t}\n\t}\n\n\tdo_complete(qp, wqe);\n\n\treturn COMPST_GET_WQE;\n}\n\n \nstatic void drain_resp_pkts(struct rxe_qp *qp)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&qp->resp_pkts))) {\n\t\trxe_put(qp);\n\t\tkfree_skb(skb);\n\t\tib_device_put(qp->ibqp.device);\n\t}\n}\n\n \nstatic int flush_send_wqe(struct rxe_qp *qp, struct rxe_send_wqe *wqe)\n{\n\tstruct rxe_cqe cqe = {};\n\tstruct ib_wc *wc = &cqe.ibwc;\n\tstruct ib_uverbs_wc *uwc = &cqe.uibwc;\n\tint err;\n\n\tif (qp->is_user) {\n\t\tuwc->wr_id = wqe->wr.wr_id;\n\t\tuwc->status = IB_WC_WR_FLUSH_ERR;\n\t\tuwc->qp_num = qp->ibqp.qp_num;\n\t} else {\n\t\twc->wr_id = wqe->wr.wr_id;\n\t\twc->status = IB_WC_WR_FLUSH_ERR;\n\t\twc->qp = &qp->ibqp;\n\t}\n\n\terr = rxe_cq_post(qp->scq, &cqe, 0);\n\tif (err)\n\t\trxe_dbg_cq(qp->scq, \"post cq failed, err = %d\", err);\n\n\treturn err;\n}\n\n \nstatic void flush_send_queue(struct rxe_qp *qp, bool notify)\n{\n\tstruct rxe_send_wqe *wqe;\n\tstruct rxe_queue *q = qp->sq.queue;\n\tint err;\n\n\t \n\tif (!qp->sq.queue)\n\t\treturn;\n\n\twhile ((wqe = queue_head(q, q->type))) {\n\t\tif (notify) {\n\t\t\terr = flush_send_wqe(qp, wqe);\n\t\t\tif (err)\n\t\t\t\tnotify = 0;\n\t\t}\n\t\tqueue_advance_consumer(q, q->type);\n\t}\n}\n\nstatic void free_pkt(struct rxe_pkt_info *pkt)\n{\n\tstruct sk_buff *skb = PKT_TO_SKB(pkt);\n\tstruct rxe_qp *qp = pkt->qp;\n\tstruct ib_device *dev = qp->ibqp.device;\n\n\tkfree_skb(skb);\n\trxe_put(qp);\n\tib_device_put(dev);\n}\n\n \nstatic void reset_retry_timer(struct rxe_qp *qp)\n{\n\tunsigned long flags;\n\n\tif (qp_type(qp) == IB_QPT_RC && qp->qp_timeout_jiffies) {\n\t\tspin_lock_irqsave(&qp->state_lock, flags);\n\t\tif (qp_state(qp) >= IB_QPS_RTS &&\n\t\t    psn_compare(qp->req.psn, qp->comp.psn) > 0)\n\t\t\tmod_timer(&qp->retrans_timer,\n\t\t\t\t  jiffies + qp->qp_timeout_jiffies);\n\t\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\t}\n}\n\nint rxe_completer(struct rxe_qp *qp)\n{\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\tstruct rxe_send_wqe *wqe = NULL;\n\tstruct sk_buff *skb = NULL;\n\tstruct rxe_pkt_info *pkt = NULL;\n\tenum comp_state state;\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->state_lock, flags);\n\tif (!qp->valid || qp_state(qp) == IB_QPS_ERR ||\n\t\t\t  qp_state(qp) == IB_QPS_RESET) {\n\t\tbool notify = qp->valid && (qp_state(qp) == IB_QPS_ERR);\n\n\t\tdrain_resp_pkts(qp);\n\t\tflush_send_queue(qp, notify);\n\t\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\t\tgoto exit;\n\t}\n\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\n\tif (qp->comp.timeout) {\n\t\tqp->comp.timeout_retry = 1;\n\t\tqp->comp.timeout = 0;\n\t} else {\n\t\tqp->comp.timeout_retry = 0;\n\t}\n\n\tif (qp->req.need_retry)\n\t\tgoto exit;\n\n\tstate = COMPST_GET_ACK;\n\n\twhile (1) {\n\t\trxe_dbg_qp(qp, \"state = %s\\n\", comp_state_name[state]);\n\t\tswitch (state) {\n\t\tcase COMPST_GET_ACK:\n\t\t\tskb = skb_dequeue(&qp->resp_pkts);\n\t\t\tif (skb) {\n\t\t\t\tpkt = SKB_TO_PKT(skb);\n\t\t\t\tqp->comp.timeout_retry = 0;\n\t\t\t}\n\t\t\tstate = COMPST_GET_WQE;\n\t\t\tbreak;\n\n\t\tcase COMPST_GET_WQE:\n\t\t\tstate = get_wqe(qp, pkt, &wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_CHECK_PSN:\n\t\t\tstate = check_psn(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_CHECK_ACK:\n\t\t\tstate = check_ack(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_READ:\n\t\t\tstate = do_read(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_ATOMIC:\n\t\t\tstate = do_atomic(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_WRITE_SEND:\n\t\t\tif (wqe->state == wqe_state_pending &&\n\t\t\t    wqe->last_psn == pkt->psn)\n\t\t\t\tstate = COMPST_COMP_ACK;\n\t\t\telse\n\t\t\t\tstate = COMPST_UPDATE_COMP;\n\t\t\tbreak;\n\n\t\tcase COMPST_COMP_ACK:\n\t\t\tstate = complete_ack(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_COMP_WQE:\n\t\t\tstate = complete_wqe(qp, pkt, wqe);\n\t\t\tbreak;\n\n\t\tcase COMPST_UPDATE_COMP:\n\t\t\tif (pkt->mask & RXE_END_MASK)\n\t\t\t\tqp->comp.opcode = -1;\n\t\t\telse\n\t\t\t\tqp->comp.opcode = pkt->opcode;\n\n\t\t\tif (psn_compare(pkt->psn, qp->comp.psn) >= 0)\n\t\t\t\tqp->comp.psn = (pkt->psn + 1) & BTH_PSN_MASK;\n\n\t\t\tif (qp->req.wait_psn) {\n\t\t\t\tqp->req.wait_psn = 0;\n\t\t\t\trxe_sched_task(&qp->req.task);\n\t\t\t}\n\n\t\t\tstate = COMPST_DONE;\n\t\t\tbreak;\n\n\t\tcase COMPST_DONE:\n\t\t\tgoto done;\n\n\t\tcase COMPST_EXIT:\n\t\t\tif (qp->comp.timeout_retry && wqe) {\n\t\t\t\tstate = COMPST_ERROR_RETRY;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treset_retry_timer(qp);\n\t\t\tgoto exit;\n\n\t\tcase COMPST_ERROR_RETRY:\n\t\t\t \n\n\t\t\t \n\t\t\tif (!wqe || (wqe->state == wqe_state_posted))\n\t\t\t\tgoto exit;\n\n\t\t\t \n\t\t\tif (qp->comp.started_retry &&\n\t\t\t    !qp->comp.timeout_retry)\n\t\t\t\tgoto done;\n\n\t\t\tif (qp->comp.retry_cnt > 0) {\n\t\t\t\tif (qp->comp.retry_cnt != 7)\n\t\t\t\t\tqp->comp.retry_cnt--;\n\n\t\t\t\t \n\t\t\t\tif (psn_compare(qp->req.psn,\n\t\t\t\t\t\tqp->comp.psn) > 0) {\n\t\t\t\t\t \n\t\t\t\t\trxe_counter_inc(rxe,\n\t\t\t\t\t\t\tRXE_CNT_COMP_RETRY);\n\t\t\t\t\tqp->req.need_retry = 1;\n\t\t\t\t\tqp->comp.started_retry = 1;\n\t\t\t\t\trxe_sched_task(&qp->req.task);\n\t\t\t\t}\n\t\t\t\tgoto done;\n\n\t\t\t} else {\n\t\t\t\trxe_counter_inc(rxe, RXE_CNT_RETRY_EXCEEDED);\n\t\t\t\twqe->status = IB_WC_RETRY_EXC_ERR;\n\t\t\t\tstate = COMPST_ERROR;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase COMPST_RNR_RETRY:\n\t\t\t \n\t\t\tif (qp->comp.rnr_retry > 0) {\n\t\t\t\tif (qp->comp.rnr_retry != 7)\n\t\t\t\t\tqp->comp.rnr_retry--;\n\n\t\t\t\t \n\t\t\t\tqp->req.wait_for_rnr_timer = 1;\n\t\t\t\trxe_dbg_qp(qp, \"set rnr nak timer\\n\");\n\t\t\t\t\n\t\t\t\tmod_timer(&qp->rnr_nak_timer,\n\t\t\t\t\t  jiffies + rnrnak_jiffies(aeth_syn(pkt)\n\t\t\t\t\t\t& ~AETH_TYPE_MASK));\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\trxe_counter_inc(rxe,\n\t\t\t\t\t\tRXE_CNT_RNR_RETRY_EXCEEDED);\n\t\t\t\twqe->status = IB_WC_RNR_RETRY_EXC_ERR;\n\t\t\t\tstate = COMPST_ERROR;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase COMPST_ERROR:\n\t\t\tWARN_ON_ONCE(wqe->status == IB_WC_SUCCESS);\n\t\t\tdo_complete(qp, wqe);\n\t\t\trxe_qp_error(qp);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \ndone:\n\tret = 0;\n\tgoto out;\nexit:\n\tret = -EAGAIN;\nout:\n\tif (pkt)\n\t\tfree_pkt(pkt);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}