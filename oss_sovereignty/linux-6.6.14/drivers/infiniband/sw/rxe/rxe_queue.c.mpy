{
  "module_name": "rxe_queue.c",
  "hash_id": "417aa1bff5d9a6e1b2bce600f26e941a5a5bf500199c800b3abb28c71474bb74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_queue.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n#include \"rxe_queue.h\"\n\nint do_mmap_info(struct rxe_dev *rxe, struct mminfo __user *outbuf,\n\t\t struct ib_udata *udata, struct rxe_queue_buf *buf,\n\t\t size_t buf_size, struct rxe_mmap_info **ip_p)\n{\n\tint err;\n\tstruct rxe_mmap_info *ip = NULL;\n\n\tif (outbuf) {\n\t\tip = rxe_create_mmap_info(rxe, buf_size, udata, buf);\n\t\tif (IS_ERR(ip)) {\n\t\t\terr = PTR_ERR(ip);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (copy_to_user(outbuf, &ip->info, sizeof(ip->info))) {\n\t\t\terr = -EFAULT;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tspin_lock_bh(&rxe->pending_lock);\n\t\tlist_add(&ip->pending_mmaps, &rxe->pending_mmaps);\n\t\tspin_unlock_bh(&rxe->pending_lock);\n\t}\n\n\t*ip_p = ip;\n\n\treturn 0;\n\nerr2:\n\tkfree(ip);\nerr1:\n\treturn err;\n}\n\ninline void rxe_queue_reset(struct rxe_queue *q)\n{\n\t \n\tmemset(q->buf->data, 0, q->buf_size - sizeof(struct rxe_queue_buf));\n}\n\nstruct rxe_queue *rxe_queue_init(struct rxe_dev *rxe, int *num_elem,\n\t\t\tunsigned int elem_size, enum queue_type type)\n{\n\tstruct rxe_queue *q;\n\tsize_t buf_size;\n\tunsigned int num_slots;\n\n\t \n\tif (*num_elem < 0)\n\t\treturn NULL;\n\n\tq = kzalloc(sizeof(*q), GFP_KERNEL);\n\tif (!q)\n\t\treturn NULL;\n\n\tq->rxe = rxe;\n\tq->type = type;\n\n\t \n\tq->elem_size = elem_size;\n\n\t \n\tif (elem_size < cache_line_size())\n\t\telem_size = cache_line_size();\n\telem_size = roundup_pow_of_two(elem_size);\n\n\tq->log2_elem_size = order_base_2(elem_size);\n\n\tnum_slots = *num_elem + 1;\n\tnum_slots = roundup_pow_of_two(num_slots);\n\tq->index_mask = num_slots - 1;\n\n\tbuf_size = sizeof(struct rxe_queue_buf) + num_slots * elem_size;\n\n\tq->buf = vmalloc_user(buf_size);\n\tif (!q->buf)\n\t\tgoto err2;\n\n\tq->buf->log2_elem_size = q->log2_elem_size;\n\tq->buf->index_mask = q->index_mask;\n\n\tq->buf_size = buf_size;\n\n\t*num_elem = num_slots - 1;\n\treturn q;\n\nerr2:\n\tkfree(q);\n\treturn NULL;\n}\n\n \nstatic int resize_finish(struct rxe_queue *q, struct rxe_queue *new_q,\n\t\t\t unsigned int num_elem)\n{\n\tenum queue_type type = q->type;\n\tu32 new_prod;\n\tu32 prod;\n\tu32 cons;\n\n\tif (!queue_empty(q, q->type) && (num_elem < queue_count(q, type)))\n\t\treturn -EINVAL;\n\n\tnew_prod = queue_get_producer(new_q, type);\n\tprod = queue_get_producer(q, type);\n\tcons = queue_get_consumer(q, type);\n\n\twhile ((prod - cons) & q->index_mask) {\n\t\tmemcpy(queue_addr_from_index(new_q, new_prod),\n\t\t       queue_addr_from_index(q, cons), new_q->elem_size);\n\t\tnew_prod = queue_next_index(new_q, new_prod);\n\t\tcons = queue_next_index(q, cons);\n\t}\n\n\tnew_q->buf->producer_index = new_prod;\n\tq->buf->consumer_index = cons;\n\n\t \n\tif (type == QUEUE_TYPE_TO_CLIENT)\n\t\tnew_q->index = new_q->buf->producer_index;\n\telse\n\t\tq->index = q->buf->consumer_index;\n\n\t \n\tswap(*q, *new_q);\n\n\treturn 0;\n}\n\nint rxe_queue_resize(struct rxe_queue *q, unsigned int *num_elem_p,\n\t\t     unsigned int elem_size, struct ib_udata *udata,\n\t\t     struct mminfo __user *outbuf, spinlock_t *producer_lock,\n\t\t     spinlock_t *consumer_lock)\n{\n\tstruct rxe_queue *new_q;\n\tunsigned int num_elem = *num_elem_p;\n\tint err;\n\tunsigned long producer_flags;\n\tunsigned long consumer_flags;\n\n\tnew_q = rxe_queue_init(q->rxe, &num_elem, elem_size, q->type);\n\tif (!new_q)\n\t\treturn -ENOMEM;\n\n\terr = do_mmap_info(new_q->rxe, outbuf, udata, new_q->buf,\n\t\t\t   new_q->buf_size, &new_q->ip);\n\tif (err) {\n\t\tvfree(new_q->buf);\n\t\tkfree(new_q);\n\t\tgoto err1;\n\t}\n\n\tspin_lock_irqsave(consumer_lock, consumer_flags);\n\n\tif (producer_lock) {\n\t\tspin_lock_irqsave(producer_lock, producer_flags);\n\t\terr = resize_finish(q, new_q, num_elem);\n\t\tspin_unlock_irqrestore(producer_lock, producer_flags);\n\t} else {\n\t\terr = resize_finish(q, new_q, num_elem);\n\t}\n\n\tspin_unlock_irqrestore(consumer_lock, consumer_flags);\n\n\trxe_queue_cleanup(new_q);\t \n\tif (err)\n\t\tgoto err1;\n\n\t*num_elem_p = num_elem;\n\treturn 0;\n\nerr1:\n\treturn err;\n}\n\nvoid rxe_queue_cleanup(struct rxe_queue *q)\n{\n\tif (q->ip)\n\t\tkref_put(&q->ip->ref, rxe_mmap_release);\n\telse\n\t\tvfree(q->buf);\n\n\tkfree(q);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}