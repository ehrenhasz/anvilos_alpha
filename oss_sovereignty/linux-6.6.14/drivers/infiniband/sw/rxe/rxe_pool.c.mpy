{
  "module_name": "rxe_pool.c",
  "hash_id": "606e9ad8e5f93680788ee07a82e1414f5e1a10359cbb166d28d2135fe0485f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_pool.c",
  "human_readable_source": "\n \n\n#include \"rxe.h\"\n\n#define RXE_POOL_TIMEOUT\t(200)\n#define RXE_POOL_ALIGN\t\t(16)\n\nstatic const struct rxe_type_info {\n\tconst char *name;\n\tsize_t size;\n\tsize_t elem_offset;\n\tvoid (*cleanup)(struct rxe_pool_elem *elem);\n\tu32 min_index;\n\tu32 max_index;\n\tu32 max_elem;\n} rxe_type_info[RXE_NUM_TYPES] = {\n\t[RXE_TYPE_UC] = {\n\t\t.name\t\t= \"uc\",\n\t\t.size\t\t= sizeof(struct rxe_ucontext),\n\t\t.elem_offset\t= offsetof(struct rxe_ucontext, elem),\n\t\t.min_index\t= 1,\n\t\t.max_index\t= RXE_MAX_UCONTEXT,\n\t\t.max_elem\t= RXE_MAX_UCONTEXT,\n\t},\n\t[RXE_TYPE_PD] = {\n\t\t.name\t\t= \"pd\",\n\t\t.size\t\t= sizeof(struct rxe_pd),\n\t\t.elem_offset\t= offsetof(struct rxe_pd, elem),\n\t\t.min_index\t= 1,\n\t\t.max_index\t= RXE_MAX_PD,\n\t\t.max_elem\t= RXE_MAX_PD,\n\t},\n\t[RXE_TYPE_AH] = {\n\t\t.name\t\t= \"ah\",\n\t\t.size\t\t= sizeof(struct rxe_ah),\n\t\t.elem_offset\t= offsetof(struct rxe_ah, elem),\n\t\t.min_index\t= RXE_MIN_AH_INDEX,\n\t\t.max_index\t= RXE_MAX_AH_INDEX,\n\t\t.max_elem\t= RXE_MAX_AH,\n\t},\n\t[RXE_TYPE_SRQ] = {\n\t\t.name\t\t= \"srq\",\n\t\t.size\t\t= sizeof(struct rxe_srq),\n\t\t.elem_offset\t= offsetof(struct rxe_srq, elem),\n\t\t.cleanup\t= rxe_srq_cleanup,\n\t\t.min_index\t= RXE_MIN_SRQ_INDEX,\n\t\t.max_index\t= RXE_MAX_SRQ_INDEX,\n\t\t.max_elem\t= RXE_MAX_SRQ,\n\t},\n\t[RXE_TYPE_QP] = {\n\t\t.name\t\t= \"qp\",\n\t\t.size\t\t= sizeof(struct rxe_qp),\n\t\t.elem_offset\t= offsetof(struct rxe_qp, elem),\n\t\t.cleanup\t= rxe_qp_cleanup,\n\t\t.min_index\t= RXE_MIN_QP_INDEX,\n\t\t.max_index\t= RXE_MAX_QP_INDEX,\n\t\t.max_elem\t= RXE_MAX_QP,\n\t},\n\t[RXE_TYPE_CQ] = {\n\t\t.name\t\t= \"cq\",\n\t\t.size\t\t= sizeof(struct rxe_cq),\n\t\t.elem_offset\t= offsetof(struct rxe_cq, elem),\n\t\t.cleanup\t= rxe_cq_cleanup,\n\t\t.min_index\t= 1,\n\t\t.max_index\t= RXE_MAX_CQ,\n\t\t.max_elem\t= RXE_MAX_CQ,\n\t},\n\t[RXE_TYPE_MR] = {\n\t\t.name\t\t= \"mr\",\n\t\t.size\t\t= sizeof(struct rxe_mr),\n\t\t.elem_offset\t= offsetof(struct rxe_mr, elem),\n\t\t.cleanup\t= rxe_mr_cleanup,\n\t\t.min_index\t= RXE_MIN_MR_INDEX,\n\t\t.max_index\t= RXE_MAX_MR_INDEX,\n\t\t.max_elem\t= RXE_MAX_MR,\n\t},\n\t[RXE_TYPE_MW] = {\n\t\t.name\t\t= \"mw\",\n\t\t.size\t\t= sizeof(struct rxe_mw),\n\t\t.elem_offset\t= offsetof(struct rxe_mw, elem),\n\t\t.cleanup\t= rxe_mw_cleanup,\n\t\t.min_index\t= RXE_MIN_MW_INDEX,\n\t\t.max_index\t= RXE_MAX_MW_INDEX,\n\t\t.max_elem\t= RXE_MAX_MW,\n\t},\n};\n\nvoid rxe_pool_init(struct rxe_dev *rxe, struct rxe_pool *pool,\n\t\t   enum rxe_elem_type type)\n{\n\tconst struct rxe_type_info *info = &rxe_type_info[type];\n\n\tmemset(pool, 0, sizeof(*pool));\n\n\tpool->rxe\t\t= rxe;\n\tpool->name\t\t= info->name;\n\tpool->type\t\t= type;\n\tpool->max_elem\t\t= info->max_elem;\n\tpool->elem_size\t\t= ALIGN(info->size, RXE_POOL_ALIGN);\n\tpool->elem_offset\t= info->elem_offset;\n\tpool->cleanup\t\t= info->cleanup;\n\n\tatomic_set(&pool->num_elem, 0);\n\n\txa_init_flags(&pool->xa, XA_FLAGS_ALLOC);\n\tpool->limit.min = info->min_index;\n\tpool->limit.max = info->max_index;\n}\n\nvoid rxe_pool_cleanup(struct rxe_pool *pool)\n{\n\tWARN_ON(!xa_empty(&pool->xa));\n}\n\nint __rxe_add_to_pool(struct rxe_pool *pool, struct rxe_pool_elem *elem,\n\t\t\t\tbool sleepable)\n{\n\tint err;\n\tgfp_t gfp_flags;\n\n\tif (atomic_inc_return(&pool->num_elem) > pool->max_elem)\n\t\tgoto err_cnt;\n\n\telem->pool = pool;\n\telem->obj = (u8 *)elem - pool->elem_offset;\n\tkref_init(&elem->ref_cnt);\n\tinit_completion(&elem->complete);\n\n\t \n\tgfp_flags = sleepable ? GFP_KERNEL : GFP_ATOMIC;\n\n\tif (sleepable)\n\t\tmight_sleep();\n\terr = xa_alloc_cyclic(&pool->xa, &elem->index, NULL, pool->limit,\n\t\t\t      &pool->next, gfp_flags);\n\tif (err < 0)\n\t\tgoto err_cnt;\n\n\treturn 0;\n\nerr_cnt:\n\tatomic_dec(&pool->num_elem);\n\treturn -EINVAL;\n}\n\nvoid *rxe_pool_get_index(struct rxe_pool *pool, u32 index)\n{\n\tstruct rxe_pool_elem *elem;\n\tstruct xarray *xa = &pool->xa;\n\tvoid *obj;\n\n\trcu_read_lock();\n\telem = xa_load(xa, index);\n\tif (elem && kref_get_unless_zero(&elem->ref_cnt))\n\t\tobj = elem->obj;\n\telse\n\t\tobj = NULL;\n\trcu_read_unlock();\n\n\treturn obj;\n}\n\nstatic void rxe_elem_release(struct kref *kref)\n{\n\tstruct rxe_pool_elem *elem = container_of(kref, typeof(*elem), ref_cnt);\n\n\tcomplete(&elem->complete);\n}\n\nint __rxe_cleanup(struct rxe_pool_elem *elem, bool sleepable)\n{\n\tstruct rxe_pool *pool = elem->pool;\n\tstruct xarray *xa = &pool->xa;\n\tstatic int timeout = RXE_POOL_TIMEOUT;\n\tint ret, err = 0;\n\tvoid *xa_ret;\n\n\tif (sleepable)\n\t\tmight_sleep();\n\n\t \n\txa_ret = xa_erase(xa, elem->index);\n\tWARN_ON(xa_err(xa_ret));\n\n\t \n\t__rxe_put(elem);\n\n\t \n\tif (sleepable) {\n\t\tif (!completion_done(&elem->complete) && timeout) {\n\t\t\tret = wait_for_completion_timeout(&elem->complete,\n\t\t\t\t\ttimeout);\n\n\t\t\t \n\t\t\tif (WARN_ON(!ret))\n\t\t\t\terr = -EINVAL;\n\t\t}\n\t} else {\n\t\tunsigned long until = jiffies + timeout;\n\n\t\t \n\t\twhile (!completion_done(&elem->complete) &&\n\t\t\t\ttime_before(jiffies, until))\n\t\t\tmdelay(1);\n\n\t\tif (WARN_ON(!completion_done(&elem->complete)))\n\t\t\terr = -EINVAL;\n\t}\n\n\tif (pool->cleanup)\n\t\tpool->cleanup(elem);\n\n\tatomic_dec(&pool->num_elem);\n\n\treturn err;\n}\n\nint __rxe_get(struct rxe_pool_elem *elem)\n{\n\treturn kref_get_unless_zero(&elem->ref_cnt);\n}\n\nint __rxe_put(struct rxe_pool_elem *elem)\n{\n\treturn kref_put(&elem->ref_cnt, rxe_elem_release);\n}\n\nvoid __rxe_finalize(struct rxe_pool_elem *elem)\n{\n\tvoid *xa_ret;\n\n\txa_ret = xa_store(&elem->pool->xa, elem->index, elem, GFP_KERNEL);\n\tWARN_ON(xa_err(xa_ret));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}