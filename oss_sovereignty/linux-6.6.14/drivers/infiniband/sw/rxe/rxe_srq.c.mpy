{
  "module_name": "rxe_srq.c",
  "hash_id": "91cbf0ffb93a5617994a6b347763aa42a00576ebf8b91c3374274b136e55fbf4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_srq.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include \"rxe.h\"\n#include \"rxe_queue.h\"\n\nint rxe_srq_chk_init(struct rxe_dev *rxe, struct ib_srq_init_attr *init)\n{\n\tstruct ib_srq_attr *attr = &init->attr;\n\n\tif (attr->max_wr > rxe->attr.max_srq_wr) {\n\t\trxe_dbg_dev(rxe, \"max_wr(%d) > max_srq_wr(%d)\\n\",\n\t\t\tattr->max_wr, rxe->attr.max_srq_wr);\n\t\tgoto err1;\n\t}\n\n\tif (attr->max_wr <= 0) {\n\t\trxe_dbg_dev(rxe, \"max_wr(%d) <= 0\\n\", attr->max_wr);\n\t\tgoto err1;\n\t}\n\n\tif (attr->max_wr < RXE_MIN_SRQ_WR)\n\t\tattr->max_wr = RXE_MIN_SRQ_WR;\n\n\tif (attr->max_sge > rxe->attr.max_srq_sge) {\n\t\trxe_dbg_dev(rxe, \"max_sge(%d) > max_srq_sge(%d)\\n\",\n\t\t\tattr->max_sge, rxe->attr.max_srq_sge);\n\t\tgoto err1;\n\t}\n\n\tif (attr->max_sge < RXE_MIN_SRQ_SGE)\n\t\tattr->max_sge = RXE_MIN_SRQ_SGE;\n\n\treturn 0;\n\nerr1:\n\treturn -EINVAL;\n}\n\nint rxe_srq_from_init(struct rxe_dev *rxe, struct rxe_srq *srq,\n\t\t      struct ib_srq_init_attr *init, struct ib_udata *udata,\n\t\t      struct rxe_create_srq_resp __user *uresp)\n{\n\tstruct rxe_queue *q;\n\tint wqe_size;\n\tint err;\n\n\tsrq->ibsrq.event_handler = init->event_handler;\n\tsrq->ibsrq.srq_context = init->srq_context;\n\tsrq->limit = init->attr.srq_limit;\n\tsrq->srq_num = srq->elem.index;\n\tsrq->rq.max_wr = init->attr.max_wr;\n\tsrq->rq.max_sge = init->attr.max_sge;\n\n\twqe_size = sizeof(struct rxe_recv_wqe) +\n\t\t\tsrq->rq.max_sge*sizeof(struct ib_sge);\n\n\tspin_lock_init(&srq->rq.producer_lock);\n\tspin_lock_init(&srq->rq.consumer_lock);\n\n\tq = rxe_queue_init(rxe, &srq->rq.max_wr, wqe_size,\n\t\t\t   QUEUE_TYPE_FROM_CLIENT);\n\tif (!q) {\n\t\trxe_dbg_srq(srq, \"Unable to allocate queue\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\terr = do_mmap_info(rxe, uresp ? &uresp->mi : NULL, udata, q->buf,\n\t\t\t   q->buf_size, &q->ip);\n\tif (err) {\n\t\trxe_dbg_srq(srq, \"Unable to init mmap info for caller\\n\");\n\t\tgoto err_free;\n\t}\n\n\tsrq->rq.queue = q;\n\tinit->attr.max_wr = srq->rq.max_wr;\n\n\tif (uresp) {\n\t\tif (copy_to_user(&uresp->srq_num, &srq->srq_num,\n\t\t\t\t sizeof(uresp->srq_num))) {\n\t\t\trxe_queue_cleanup(q);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free:\n\tvfree(q->buf);\n\tkfree(q);\nerr_out:\n\treturn err;\n}\n\nint rxe_srq_chk_attr(struct rxe_dev *rxe, struct rxe_srq *srq,\n\t\t     struct ib_srq_attr *attr, enum ib_srq_attr_mask mask)\n{\n\tif (srq->error) {\n\t\trxe_dbg_srq(srq, \"in error state\\n\");\n\t\tgoto err1;\n\t}\n\n\tif (mask & IB_SRQ_MAX_WR) {\n\t\tif (attr->max_wr > rxe->attr.max_srq_wr) {\n\t\t\trxe_dbg_srq(srq, \"max_wr(%d) > max_srq_wr(%d)\\n\",\n\t\t\t\tattr->max_wr, rxe->attr.max_srq_wr);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (attr->max_wr <= 0) {\n\t\t\trxe_dbg_srq(srq, \"max_wr(%d) <= 0\\n\", attr->max_wr);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (srq->limit && (attr->max_wr < srq->limit)) {\n\t\t\trxe_dbg_srq(srq, \"max_wr (%d) < srq->limit (%d)\\n\",\n\t\t\t\tattr->max_wr, srq->limit);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (attr->max_wr < RXE_MIN_SRQ_WR)\n\t\t\tattr->max_wr = RXE_MIN_SRQ_WR;\n\t}\n\n\tif (mask & IB_SRQ_LIMIT) {\n\t\tif (attr->srq_limit > rxe->attr.max_srq_wr) {\n\t\t\trxe_dbg_srq(srq, \"srq_limit(%d) > max_srq_wr(%d)\\n\",\n\t\t\t\tattr->srq_limit, rxe->attr.max_srq_wr);\n\t\t\tgoto err1;\n\t\t}\n\n\t\tif (attr->srq_limit > srq->rq.queue->buf->index_mask) {\n\t\t\trxe_dbg_srq(srq, \"srq_limit (%d) > cur limit(%d)\\n\",\n\t\t\t\tattr->srq_limit,\n\t\t\t\tsrq->rq.queue->buf->index_mask);\n\t\t\tgoto err1;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr1:\n\treturn -EINVAL;\n}\n\nint rxe_srq_from_attr(struct rxe_dev *rxe, struct rxe_srq *srq,\n\t\t      struct ib_srq_attr *attr, enum ib_srq_attr_mask mask,\n\t\t      struct rxe_modify_srq_cmd *ucmd, struct ib_udata *udata)\n{\n\tstruct rxe_queue *q = srq->rq.queue;\n\tstruct mminfo __user *mi = NULL;\n\tint wqe_size;\n\tint err;\n\n\tif (mask & IB_SRQ_MAX_WR) {\n\t\t \n\t\tmi = u64_to_user_ptr(ucmd->mmap_info_addr);\n\n\t\twqe_size = sizeof(struct rxe_recv_wqe) +\n\t\t\t\tsrq->rq.max_sge*sizeof(struct ib_sge);\n\n\t\terr = rxe_queue_resize(q, &attr->max_wr, wqe_size,\n\t\t\t\t       udata, mi, &srq->rq.producer_lock,\n\t\t\t\t       &srq->rq.consumer_lock);\n\t\tif (err)\n\t\t\tgoto err_free;\n\n\t\tsrq->rq.max_wr = attr->max_wr;\n\t}\n\n\tif (mask & IB_SRQ_LIMIT)\n\t\tsrq->limit = attr->srq_limit;\n\n\treturn 0;\n\nerr_free:\n\trxe_queue_cleanup(q);\n\tsrq->rq.queue = NULL;\n\treturn err;\n}\n\nvoid rxe_srq_cleanup(struct rxe_pool_elem *elem)\n{\n\tstruct rxe_srq *srq = container_of(elem, typeof(*srq), elem);\n\n\tif (srq->pd)\n\t\trxe_put(srq->pd);\n\n\tif (srq->rq.queue)\n\t\trxe_queue_cleanup(srq->rq.queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}