{
  "module_name": "rxe.c",
  "hash_id": "fd996186c2a5fb02a6bc1339336f85dbbf1dc57a1800139d1a515f9fceb5dea8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe.c",
  "human_readable_source": "\n \n\n#include <rdma/rdma_netlink.h>\n#include <net/addrconf.h>\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\nMODULE_AUTHOR(\"Bob Pearson, Frank Zago, John Groves, Kamal Heib\");\nMODULE_DESCRIPTION(\"Soft RDMA transport\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n \nvoid rxe_dealloc(struct ib_device *ib_dev)\n{\n\tstruct rxe_dev *rxe = container_of(ib_dev, struct rxe_dev, ib_dev);\n\n\trxe_pool_cleanup(&rxe->uc_pool);\n\trxe_pool_cleanup(&rxe->pd_pool);\n\trxe_pool_cleanup(&rxe->ah_pool);\n\trxe_pool_cleanup(&rxe->srq_pool);\n\trxe_pool_cleanup(&rxe->qp_pool);\n\trxe_pool_cleanup(&rxe->cq_pool);\n\trxe_pool_cleanup(&rxe->mr_pool);\n\trxe_pool_cleanup(&rxe->mw_pool);\n\n\tWARN_ON(!RB_EMPTY_ROOT(&rxe->mcg_tree));\n\n\tif (rxe->tfm)\n\t\tcrypto_free_shash(rxe->tfm);\n}\n\n \nstatic void rxe_init_device_param(struct rxe_dev *rxe)\n{\n\trxe->max_inline_data\t\t\t= RXE_MAX_INLINE_DATA;\n\n\trxe->attr.vendor_id\t\t\t= RXE_VENDOR_ID;\n\trxe->attr.max_mr_size\t\t\t= RXE_MAX_MR_SIZE;\n\trxe->attr.page_size_cap\t\t\t= RXE_PAGE_SIZE_CAP;\n\trxe->attr.max_qp\t\t\t= RXE_MAX_QP;\n\trxe->attr.max_qp_wr\t\t\t= RXE_MAX_QP_WR;\n\trxe->attr.device_cap_flags\t\t= RXE_DEVICE_CAP_FLAGS;\n\trxe->attr.kernel_cap_flags\t\t= IBK_ALLOW_USER_UNREG;\n\trxe->attr.max_send_sge\t\t\t= RXE_MAX_SGE;\n\trxe->attr.max_recv_sge\t\t\t= RXE_MAX_SGE;\n\trxe->attr.max_sge_rd\t\t\t= RXE_MAX_SGE_RD;\n\trxe->attr.max_cq\t\t\t= RXE_MAX_CQ;\n\trxe->attr.max_cqe\t\t\t= (1 << RXE_MAX_LOG_CQE) - 1;\n\trxe->attr.max_mr\t\t\t= RXE_MAX_MR;\n\trxe->attr.max_mw\t\t\t= RXE_MAX_MW;\n\trxe->attr.max_pd\t\t\t= RXE_MAX_PD;\n\trxe->attr.max_qp_rd_atom\t\t= RXE_MAX_QP_RD_ATOM;\n\trxe->attr.max_res_rd_atom\t\t= RXE_MAX_RES_RD_ATOM;\n\trxe->attr.max_qp_init_rd_atom\t\t= RXE_MAX_QP_INIT_RD_ATOM;\n\trxe->attr.atomic_cap\t\t\t= IB_ATOMIC_HCA;\n\trxe->attr.max_mcast_grp\t\t\t= RXE_MAX_MCAST_GRP;\n\trxe->attr.max_mcast_qp_attach\t\t= RXE_MAX_MCAST_QP_ATTACH;\n\trxe->attr.max_total_mcast_qp_attach\t= RXE_MAX_TOT_MCAST_QP_ATTACH;\n\trxe->attr.max_ah\t\t\t= RXE_MAX_AH;\n\trxe->attr.max_srq\t\t\t= RXE_MAX_SRQ;\n\trxe->attr.max_srq_wr\t\t\t= RXE_MAX_SRQ_WR;\n\trxe->attr.max_srq_sge\t\t\t= RXE_MAX_SRQ_SGE;\n\trxe->attr.max_fast_reg_page_list_len\t= RXE_MAX_FMR_PAGE_LIST_LEN;\n\trxe->attr.max_pkeys\t\t\t= RXE_MAX_PKEYS;\n\trxe->attr.local_ca_ack_delay\t\t= RXE_LOCAL_CA_ACK_DELAY;\n\taddrconf_addr_eui48((unsigned char *)&rxe->attr.sys_image_guid,\n\t\t\trxe->ndev->dev_addr);\n\n\trxe->max_ucontext\t\t\t= RXE_MAX_UCONTEXT;\n}\n\n \nstatic void rxe_init_port_param(struct rxe_port *port)\n{\n\tport->attr.state\t\t= IB_PORT_DOWN;\n\tport->attr.max_mtu\t\t= IB_MTU_4096;\n\tport->attr.active_mtu\t\t= IB_MTU_256;\n\tport->attr.gid_tbl_len\t\t= RXE_PORT_GID_TBL_LEN;\n\tport->attr.port_cap_flags\t= RXE_PORT_PORT_CAP_FLAGS;\n\tport->attr.max_msg_sz\t\t= RXE_PORT_MAX_MSG_SZ;\n\tport->attr.bad_pkey_cntr\t= RXE_PORT_BAD_PKEY_CNTR;\n\tport->attr.qkey_viol_cntr\t= RXE_PORT_QKEY_VIOL_CNTR;\n\tport->attr.pkey_tbl_len\t\t= RXE_PORT_PKEY_TBL_LEN;\n\tport->attr.lid\t\t\t= RXE_PORT_LID;\n\tport->attr.sm_lid\t\t= RXE_PORT_SM_LID;\n\tport->attr.lmc\t\t\t= RXE_PORT_LMC;\n\tport->attr.max_vl_num\t\t= RXE_PORT_MAX_VL_NUM;\n\tport->attr.sm_sl\t\t= RXE_PORT_SM_SL;\n\tport->attr.subnet_timeout\t= RXE_PORT_SUBNET_TIMEOUT;\n\tport->attr.init_type_reply\t= RXE_PORT_INIT_TYPE_REPLY;\n\tport->attr.active_width\t\t= RXE_PORT_ACTIVE_WIDTH;\n\tport->attr.active_speed\t\t= RXE_PORT_ACTIVE_SPEED;\n\tport->attr.phys_state\t\t= RXE_PORT_PHYS_STATE;\n\tport->mtu_cap\t\t\t= ib_mtu_enum_to_int(IB_MTU_256);\n\tport->subnet_prefix\t\t= cpu_to_be64(RXE_PORT_SUBNET_PREFIX);\n}\n\n \nstatic void rxe_init_ports(struct rxe_dev *rxe)\n{\n\tstruct rxe_port *port = &rxe->port;\n\n\trxe_init_port_param(port);\n\taddrconf_addr_eui48((unsigned char *)&port->port_guid,\n\t\t\t    rxe->ndev->dev_addr);\n\tspin_lock_init(&port->port_lock);\n}\n\n \nstatic void rxe_init_pools(struct rxe_dev *rxe)\n{\n\trxe_pool_init(rxe, &rxe->uc_pool, RXE_TYPE_UC);\n\trxe_pool_init(rxe, &rxe->pd_pool, RXE_TYPE_PD);\n\trxe_pool_init(rxe, &rxe->ah_pool, RXE_TYPE_AH);\n\trxe_pool_init(rxe, &rxe->srq_pool, RXE_TYPE_SRQ);\n\trxe_pool_init(rxe, &rxe->qp_pool, RXE_TYPE_QP);\n\trxe_pool_init(rxe, &rxe->cq_pool, RXE_TYPE_CQ);\n\trxe_pool_init(rxe, &rxe->mr_pool, RXE_TYPE_MR);\n\trxe_pool_init(rxe, &rxe->mw_pool, RXE_TYPE_MW);\n}\n\n \nstatic void rxe_init(struct rxe_dev *rxe)\n{\n\t \n\trxe_init_device_param(rxe);\n\n\trxe_init_ports(rxe);\n\trxe_init_pools(rxe);\n\n\t \n\tspin_lock_init(&rxe->mmap_offset_lock);\n\tspin_lock_init(&rxe->pending_lock);\n\tINIT_LIST_HEAD(&rxe->pending_mmaps);\n\n\t \n\tspin_lock_init(&rxe->mcg_lock);\n\trxe->mcg_tree = RB_ROOT;\n\n\tmutex_init(&rxe->usdev_lock);\n}\n\nvoid rxe_set_mtu(struct rxe_dev *rxe, unsigned int ndev_mtu)\n{\n\tstruct rxe_port *port = &rxe->port;\n\tenum ib_mtu mtu;\n\n\tmtu = eth_mtu_int_to_enum(ndev_mtu);\n\n\t \n\tmtu = mtu ? min_t(enum ib_mtu, mtu, IB_MTU_4096) : IB_MTU_256;\n\n\tport->attr.active_mtu = mtu;\n\tport->mtu_cap = ib_mtu_enum_to_int(mtu);\n\n\trxe_info_dev(rxe, \"Set mtu to %d\", port->mtu_cap);\n}\n\n \nint rxe_add(struct rxe_dev *rxe, unsigned int mtu, const char *ibdev_name)\n{\n\trxe_init(rxe);\n\trxe_set_mtu(rxe, mtu);\n\n\treturn rxe_register_device(rxe, ibdev_name);\n}\n\nstatic int rxe_newlink(const char *ibdev_name, struct net_device *ndev)\n{\n\tstruct rxe_dev *rxe;\n\tint err = 0;\n\n\tif (is_vlan_dev(ndev)) {\n\t\trxe_err(\"rxe creation allowed on top of a real device only\");\n\t\terr = -EPERM;\n\t\tgoto err;\n\t}\n\n\trxe = rxe_get_dev_from_net(ndev);\n\tif (rxe) {\n\t\tib_device_put(&rxe->ib_dev);\n\t\trxe_err_dev(rxe, \"already configured on %s\", ndev->name);\n\t\terr = -EEXIST;\n\t\tgoto err;\n\t}\n\n\terr = rxe_net_add(ibdev_name, ndev);\n\tif (err) {\n\t\trxe_err(\"failed to add %s\\n\", ndev->name);\n\t\tgoto err;\n\t}\nerr:\n\treturn err;\n}\n\nstatic struct rdma_link_ops rxe_link_ops = {\n\t.type = \"rxe\",\n\t.newlink = rxe_newlink,\n};\n\nstatic int __init rxe_module_init(void)\n{\n\tint err;\n\n\terr = rxe_alloc_wq();\n\tif (err)\n\t\treturn err;\n\n\terr = rxe_net_init();\n\tif (err) {\n\t\trxe_destroy_wq();\n\t\treturn err;\n\t}\n\n\trdma_link_register(&rxe_link_ops);\n\tpr_info(\"loaded\\n\");\n\treturn 0;\n}\n\nstatic void __exit rxe_module_exit(void)\n{\n\trdma_link_unregister(&rxe_link_ops);\n\tib_unregister_driver(RDMA_DRIVER_RXE);\n\trxe_net_exit();\n\trxe_destroy_wq();\n\n\tpr_info(\"unloaded\\n\");\n}\n\nlate_initcall(rxe_module_init);\nmodule_exit(rxe_module_exit);\n\nMODULE_ALIAS_RDMA_LINK(\"rxe\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}