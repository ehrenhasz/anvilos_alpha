{
  "module_name": "rxe_mmap.c",
  "hash_id": "0029a0e5b63e43b75504a07bdc18c98d3cb5799e1768676723fc195ac78ba7bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_mmap.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <rdma/uverbs_ioctl.h>\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n#include \"rxe_queue.h\"\n\nvoid rxe_mmap_release(struct kref *ref)\n{\n\tstruct rxe_mmap_info *ip = container_of(ref,\n\t\t\t\t\tstruct rxe_mmap_info, ref);\n\tstruct rxe_dev *rxe = to_rdev(ip->context->device);\n\n\tspin_lock_bh(&rxe->pending_lock);\n\n\tif (!list_empty(&ip->pending_mmaps))\n\t\tlist_del(&ip->pending_mmaps);\n\n\tspin_unlock_bh(&rxe->pending_lock);\n\n\tvfree(ip->obj);\t\t \n\tkfree(ip);\n}\n\n \nstatic void rxe_vma_open(struct vm_area_struct *vma)\n{\n\tstruct rxe_mmap_info *ip = vma->vm_private_data;\n\n\tkref_get(&ip->ref);\n}\n\nstatic void rxe_vma_close(struct vm_area_struct *vma)\n{\n\tstruct rxe_mmap_info *ip = vma->vm_private_data;\n\n\tkref_put(&ip->ref, rxe_mmap_release);\n}\n\nstatic const struct vm_operations_struct rxe_vm_ops = {\n\t.open = rxe_vma_open,\n\t.close = rxe_vma_close,\n};\n\n \nint rxe_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\n{\n\tstruct rxe_dev *rxe = to_rdev(context->device);\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tstruct rxe_mmap_info *ip, *pp;\n\tint ret;\n\n\t \n\tspin_lock_bh(&rxe->pending_lock);\n\tlist_for_each_entry_safe(ip, pp, &rxe->pending_mmaps, pending_mmaps) {\n\t\tif (context != ip->context || (__u64)offset != ip->info.offset)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (size > ip->info.size) {\n\t\t\trxe_dbg_dev(rxe, \"mmap region is larger than the object!\\n\");\n\t\t\tspin_unlock_bh(&rxe->pending_lock);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tgoto found_it;\n\t}\n\trxe_dbg_dev(rxe, \"unable to find pending mmap info\\n\");\n\tspin_unlock_bh(&rxe->pending_lock);\n\tret = -EINVAL;\n\tgoto done;\n\nfound_it:\n\tlist_del_init(&ip->pending_mmaps);\n\tspin_unlock_bh(&rxe->pending_lock);\n\n\tret = remap_vmalloc_range(vma, ip->obj, 0);\n\tif (ret) {\n\t\trxe_dbg_dev(rxe, \"err %d from remap_vmalloc_range\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tvma->vm_ops = &rxe_vm_ops;\n\tvma->vm_private_data = ip;\n\trxe_vma_open(vma);\ndone:\n\treturn ret;\n}\n\n \nstruct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe, u32 size,\n\t\t\t\t\t   struct ib_udata *udata, void *obj)\n{\n\tstruct rxe_mmap_info *ip;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tip = kmalloc(sizeof(*ip), GFP_KERNEL);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsize = PAGE_ALIGN(size);\n\n\tspin_lock_bh(&rxe->mmap_offset_lock);\n\n\tif (rxe->mmap_offset == 0)\n\t\trxe->mmap_offset = ALIGN(PAGE_SIZE, SHMLBA);\n\n\tip->info.offset = rxe->mmap_offset;\n\trxe->mmap_offset += ALIGN(size, SHMLBA);\n\n\tspin_unlock_bh(&rxe->mmap_offset_lock);\n\n\tINIT_LIST_HEAD(&ip->pending_mmaps);\n\tip->info.size = size;\n\tip->context =\n\t\tcontainer_of(udata, struct uverbs_attr_bundle, driver_udata)\n\t\t\t->context;\n\tip->obj = obj;\n\tkref_init(&ip->ref);\n\n\treturn ip;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}