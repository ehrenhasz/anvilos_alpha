{
  "module_name": "rxe_av.c",
  "hash_id": "cdfe98b44bbe4fbcfcf291d60987e9812df03c64a07c0035e2a9a92a617ba748",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_av.c",
  "human_readable_source": "\n \n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\nvoid rxe_init_av(struct rdma_ah_attr *attr, struct rxe_av *av)\n{\n\trxe_av_from_attr(rdma_ah_get_port_num(attr), av, attr);\n\trxe_av_fill_ip_info(av, attr);\n\tmemcpy(av->dmac, attr->roce.dmac, ETH_ALEN);\n}\n\nstatic int chk_attr(void *obj, struct rdma_ah_attr *attr, bool obj_is_ah)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(attr);\n\tstruct rxe_port *port;\n\tstruct rxe_dev *rxe;\n\tstruct rxe_qp *qp;\n\tstruct rxe_ah *ah;\n\tint type;\n\n\tif (obj_is_ah) {\n\t\tah = obj;\n\t\trxe = to_rdev(ah->ibah.device);\n\t} else {\n\t\tqp = obj;\n\t\trxe = to_rdev(qp->ibqp.device);\n\t}\n\n\tport = &rxe->port;\n\n\tif (rdma_ah_get_ah_flags(attr) & IB_AH_GRH) {\n\t\tif (grh->sgid_index > port->attr.gid_tbl_len) {\n\t\t\tif (obj_is_ah)\n\t\t\t\trxe_dbg_ah(ah, \"invalid sgid index = %d\\n\",\n\t\t\t\t\t\tgrh->sgid_index);\n\t\t\telse\n\t\t\t\trxe_dbg_qp(qp, \"invalid sgid index = %d\\n\",\n\t\t\t\t\t\tgrh->sgid_index);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttype = rdma_gid_attr_network_type(grh->sgid_attr);\n\t\tif (type < RDMA_NETWORK_IPV4 ||\n\t\t    type > RDMA_NETWORK_IPV6) {\n\t\t\tif (obj_is_ah)\n\t\t\t\trxe_dbg_ah(ah, \"invalid network type for rdma_rxe = %d\\n\",\n\t\t\t\t\t\ttype);\n\t\t\telse\n\t\t\t\trxe_dbg_qp(qp, \"invalid network type for rdma_rxe = %d\\n\",\n\t\t\t\t\t\ttype);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint rxe_av_chk_attr(struct rxe_qp *qp, struct rdma_ah_attr *attr)\n{\n\treturn chk_attr(qp, attr, false);\n}\n\nint rxe_ah_chk_attr(struct rxe_ah *ah, struct rdma_ah_attr *attr)\n{\n\treturn chk_attr(ah, attr, true);\n}\n\nvoid rxe_av_from_attr(u8 port_num, struct rxe_av *av,\n\t\t     struct rdma_ah_attr *attr)\n{\n\tconst struct ib_global_route *grh = rdma_ah_read_grh(attr);\n\n\tmemset(av, 0, sizeof(*av));\n\tmemcpy(av->grh.dgid.raw, grh->dgid.raw, sizeof(grh->dgid.raw));\n\tav->grh.flow_label = grh->flow_label;\n\tav->grh.sgid_index = grh->sgid_index;\n\tav->grh.hop_limit = grh->hop_limit;\n\tav->grh.traffic_class = grh->traffic_class;\n\tav->port_num = port_num;\n}\n\nvoid rxe_av_to_attr(struct rxe_av *av, struct rdma_ah_attr *attr)\n{\n\tstruct ib_global_route *grh = rdma_ah_retrieve_grh(attr);\n\n\tattr->type = RDMA_AH_ATTR_TYPE_ROCE;\n\n\tmemcpy(grh->dgid.raw, av->grh.dgid.raw, sizeof(av->grh.dgid.raw));\n\tgrh->flow_label = av->grh.flow_label;\n\tgrh->sgid_index = av->grh.sgid_index;\n\tgrh->hop_limit = av->grh.hop_limit;\n\tgrh->traffic_class = av->grh.traffic_class;\n\n\trdma_ah_set_ah_flags(attr, IB_AH_GRH);\n\trdma_ah_set_port_num(attr, av->port_num);\n}\n\nvoid rxe_av_fill_ip_info(struct rxe_av *av, struct rdma_ah_attr *attr)\n{\n\tconst struct ib_gid_attr *sgid_attr = attr->grh.sgid_attr;\n\tint ibtype;\n\tint type;\n\n\trdma_gid2ip((struct sockaddr *)&av->sgid_addr, &sgid_attr->gid);\n\trdma_gid2ip((struct sockaddr *)&av->dgid_addr,\n\t\t    &rdma_ah_read_grh(attr)->dgid);\n\n\tibtype = rdma_gid_attr_network_type(sgid_attr);\n\n\tswitch (ibtype) {\n\tcase RDMA_NETWORK_IPV4:\n\t\ttype = RXE_NETWORK_TYPE_IPV4;\n\t\tbreak;\n\tcase RDMA_NETWORK_IPV6:\n\t\ttype = RXE_NETWORK_TYPE_IPV6;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\ttype = 0;\n\t\tbreak;\n\t}\n\n\tav->network_type = type;\n}\n\nstruct rxe_av *rxe_get_av(struct rxe_pkt_info *pkt, struct rxe_ah **ahp)\n{\n\tstruct rxe_ah *ah;\n\tu32 ah_num;\n\n\tif (ahp)\n\t\t*ahp = NULL;\n\n\tif (!pkt || !pkt->qp)\n\t\treturn NULL;\n\n\tif (qp_type(pkt->qp) == IB_QPT_RC || qp_type(pkt->qp) == IB_QPT_UC)\n\t\treturn &pkt->qp->pri_av;\n\n\tif (!pkt->wqe)\n\t\treturn NULL;\n\n\tah_num = pkt->wqe->wr.wr.ud.ah_num;\n\tif (ah_num) {\n\t\t \n\t\tah = rxe_pool_get_index(&pkt->rxe->ah_pool, ah_num);\n\t\tif (!ah) {\n\t\t\trxe_dbg_qp(pkt->qp, \"Unable to find AH matching ah_num\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (rxe_ah_pd(ah) != pkt->qp->pd) {\n\t\t\trxe_dbg_qp(pkt->qp, \"PDs don't match for AH and QP\\n\");\n\t\t\trxe_put(ah);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (ahp)\n\t\t\t*ahp = ah;\n\t\telse\n\t\t\trxe_put(ah);\n\n\t\treturn &ah->av;\n\t}\n\n\t \n\treturn &pkt->wqe->wr.wr.ud.av;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}