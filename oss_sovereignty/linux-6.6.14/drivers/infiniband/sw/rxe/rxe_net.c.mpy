{
  "module_name": "rxe_net.c",
  "hash_id": "951700a4d469d4ce696da2d7f19397394f52bec5d8bb38f7ab81075bc12cc6b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_net.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <net/udp_tunnel.h>\n#include <net/sch_generic.h>\n#include <linux/netfilter.h>\n#include <rdma/ib_addr.h>\n\n#include \"rxe.h\"\n#include \"rxe_net.h\"\n#include \"rxe_loc.h\"\n\nstatic struct rxe_recv_sockets recv_sockets;\n\nstatic struct dst_entry *rxe_find_route4(struct rxe_qp *qp,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct in_addr *saddr,\n\t\t\t\t\t struct in_addr *daddr)\n{\n\tstruct rtable *rt;\n\tstruct flowi4 fl = { { 0 } };\n\n\tmemset(&fl, 0, sizeof(fl));\n\tfl.flowi4_oif = ndev->ifindex;\n\tmemcpy(&fl.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl.daddr, daddr, sizeof(*daddr));\n\tfl.flowi4_proto = IPPROTO_UDP;\n\n\trt = ip_route_output_key(&init_net, &fl);\n\tif (IS_ERR(rt)) {\n\t\trxe_dbg_qp(qp, \"no route to %pI4\\n\", &daddr->s_addr);\n\t\treturn NULL;\n\t}\n\n\treturn &rt->dst;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic struct dst_entry *rxe_find_route6(struct rxe_qp *qp,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\tstruct dst_entry *ndst;\n\tstruct flowi6 fl6 = { { 0 } };\n\n\tmemset(&fl6, 0, sizeof(fl6));\n\tfl6.flowi6_oif = ndev->ifindex;\n\tmemcpy(&fl6.saddr, saddr, sizeof(*saddr));\n\tmemcpy(&fl6.daddr, daddr, sizeof(*daddr));\n\tfl6.flowi6_proto = IPPROTO_UDP;\n\n\tndst = ipv6_stub->ipv6_dst_lookup_flow(sock_net(recv_sockets.sk6->sk),\n\t\t\t\t\t       recv_sockets.sk6->sk, &fl6,\n\t\t\t\t\t       NULL);\n\tif (IS_ERR(ndst)) {\n\t\trxe_dbg_qp(qp, \"no route to %pI6\\n\", daddr);\n\t\treturn NULL;\n\t}\n\n\tif (unlikely(ndst->error)) {\n\t\trxe_dbg_qp(qp, \"no route to %pI6\\n\", daddr);\n\t\tgoto put;\n\t}\n\n\treturn ndst;\nput:\n\tdst_release(ndst);\n\treturn NULL;\n}\n\n#else\n\nstatic struct dst_entry *rxe_find_route6(struct rxe_qp *qp,\n\t\t\t\t\t struct net_device *ndev,\n\t\t\t\t\t struct in6_addr *saddr,\n\t\t\t\t\t struct in6_addr *daddr)\n{\n\treturn NULL;\n}\n\n#endif\n\nstatic struct dst_entry *rxe_find_route(struct net_device *ndev,\n\t\t\t\t\tstruct rxe_qp *qp,\n\t\t\t\t\tstruct rxe_av *av)\n{\n\tstruct dst_entry *dst = NULL;\n\n\tif (qp_type(qp) == IB_QPT_RC)\n\t\tdst = sk_dst_get(qp->sk->sk);\n\n\tif (!dst || !dst_check(dst, qp->dst_cookie)) {\n\t\tif (dst)\n\t\t\tdst_release(dst);\n\n\t\tif (av->network_type == RXE_NETWORK_TYPE_IPV4) {\n\t\t\tstruct in_addr *saddr;\n\t\t\tstruct in_addr *daddr;\n\n\t\t\tsaddr = &av->sgid_addr._sockaddr_in.sin_addr;\n\t\t\tdaddr = &av->dgid_addr._sockaddr_in.sin_addr;\n\t\t\tdst = rxe_find_route4(qp, ndev, saddr, daddr);\n\t\t} else if (av->network_type == RXE_NETWORK_TYPE_IPV6) {\n\t\t\tstruct in6_addr *saddr6;\n\t\t\tstruct in6_addr *daddr6;\n\n\t\t\tsaddr6 = &av->sgid_addr._sockaddr_in6.sin6_addr;\n\t\t\tdaddr6 = &av->dgid_addr._sockaddr_in6.sin6_addr;\n\t\t\tdst = rxe_find_route6(qp, ndev, saddr6, daddr6);\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t\tif (dst)\n\t\t\t\tqp->dst_cookie =\n\t\t\t\t\trt6_get_cookie((struct rt6_info *)dst);\n#endif\n\t\t}\n\n\t\tif (dst && (qp_type(qp) == IB_QPT_RC)) {\n\t\t\tdst_hold(dst);\n\t\t\tsk_dst_set(qp->sk->sk, dst);\n\t\t}\n\t}\n\treturn dst;\n}\n\nstatic int rxe_udp_encap_recv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct udphdr *udph;\n\tstruct rxe_dev *rxe;\n\tstruct net_device *ndev = skb->dev;\n\tstruct rxe_pkt_info *pkt = SKB_TO_PKT(skb);\n\n\t \n\trxe = rxe_get_dev_from_net(ndev);\n\tif (!rxe && is_vlan_dev(ndev))\n\t\trxe = rxe_get_dev_from_net(vlan_dev_real_dev(ndev));\n\tif (!rxe)\n\t\tgoto drop;\n\n\tif (skb_linearize(skb)) {\n\t\tib_device_put(&rxe->ib_dev);\n\t\tgoto drop;\n\t}\n\n\tudph = udp_hdr(skb);\n\tpkt->rxe = rxe;\n\tpkt->port_num = 1;\n\tpkt->hdr = (u8 *)(udph + 1);\n\tpkt->mask = RXE_GRH_MASK;\n\tpkt->paylen = be16_to_cpu(udph->len) - sizeof(*udph);\n\n\t \n\tskb_pull(skb, sizeof(struct udphdr));\n\n\trxe_rcv(skb);\n\n\treturn 0;\ndrop:\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic struct socket *rxe_setup_udp_tunnel(struct net *net, __be16 port,\n\t\t\t\t\t   bool ipv6)\n{\n\tint err;\n\tstruct socket *sock;\n\tstruct udp_port_cfg udp_cfg = { };\n\tstruct udp_tunnel_sock_cfg tnl_cfg = { };\n\n\tif (ipv6) {\n\t\tudp_cfg.family = AF_INET6;\n\t\tudp_cfg.ipv6_v6only = 1;\n\t} else {\n\t\tudp_cfg.family = AF_INET;\n\t}\n\n\tudp_cfg.local_udp_port = port;\n\n\t \n\terr = udp_sock_create(net, &udp_cfg, &sock);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\ttnl_cfg.encap_type = 1;\n\ttnl_cfg.encap_rcv = rxe_udp_encap_recv;\n\n\t \n\tsetup_udp_tunnel_sock(net, sock, &tnl_cfg);\n\n\treturn sock;\n}\n\nstatic void rxe_release_udp_tunnel(struct socket *sk)\n{\n\tif (sk)\n\t\tudp_tunnel_sock_release(sk);\n}\n\nstatic void prepare_udp_hdr(struct sk_buff *skb, __be16 src_port,\n\t\t\t    __be16 dst_port)\n{\n\tstruct udphdr *udph;\n\n\t__skb_push(skb, sizeof(*udph));\n\tskb_reset_transport_header(skb);\n\tudph = udp_hdr(skb);\n\n\tudph->dest = dst_port;\n\tudph->source = src_port;\n\tudph->len = htons(skb->len);\n\tudph->check = 0;\n}\n\nstatic void prepare_ipv4_hdr(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t     __be32 saddr, __be32 daddr, __u8 proto,\n\t\t\t     __u8 tos, __u8 ttl, __be16 df, bool xnet)\n{\n\tstruct iphdr *iph;\n\n\tskb_scrub_packet(skb, xnet);\n\n\tskb_clear_hash(skb);\n\tskb_dst_set(skb, dst_clone(dst));\n\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\n\tskb_push(skb, sizeof(struct iphdr));\n\tskb_reset_network_header(skb);\n\n\tiph = ip_hdr(skb);\n\n\tiph->version\t=\tIPVERSION;\n\tiph->ihl\t=\tsizeof(struct iphdr) >> 2;\n\tiph->tot_len\t=\thtons(skb->len);\n\tiph->frag_off\t=\tdf;\n\tiph->protocol\t=\tproto;\n\tiph->tos\t=\ttos;\n\tiph->daddr\t=\tdaddr;\n\tiph->saddr\t=\tsaddr;\n\tiph->ttl\t=\tttl;\n\t__ip_select_ident(dev_net(dst->dev), iph,\n\t\t\t  skb_shinfo(skb)->gso_segs ?: 1);\n}\n\nstatic void prepare_ipv6_hdr(struct dst_entry *dst, struct sk_buff *skb,\n\t\t\t     struct in6_addr *saddr, struct in6_addr *daddr,\n\t\t\t     __u8 proto, __u8 prio, __u8 ttl)\n{\n\tstruct ipv6hdr *ip6h;\n\n\tmemset(&(IPCB(skb)->opt), 0, sizeof(IPCB(skb)->opt));\n\tIPCB(skb)->flags &= ~(IPSKB_XFRM_TUNNEL_SIZE | IPSKB_XFRM_TRANSFORMED\n\t\t\t    | IPSKB_REROUTED);\n\tskb_dst_set(skb, dst_clone(dst));\n\n\t__skb_push(skb, sizeof(*ip6h));\n\tskb_reset_network_header(skb);\n\tip6h\t\t  = ipv6_hdr(skb);\n\tip6_flow_hdr(ip6h, prio, htonl(0));\n\tip6h->payload_len = htons(skb->len);\n\tip6h->nexthdr     = proto;\n\tip6h->hop_limit   = ttl;\n\tip6h->daddr\t  = *daddr;\n\tip6h->saddr\t  = *saddr;\n\tip6h->payload_len = htons(skb->len - sizeof(*ip6h));\n}\n\nstatic int prepare4(struct rxe_av *av, struct rxe_pkt_info *pkt,\n\t\t    struct sk_buff *skb)\n{\n\tstruct rxe_qp *qp = pkt->qp;\n\tstruct dst_entry *dst;\n\tbool xnet = false;\n\t__be16 df = htons(IP_DF);\n\tstruct in_addr *saddr = &av->sgid_addr._sockaddr_in.sin_addr;\n\tstruct in_addr *daddr = &av->dgid_addr._sockaddr_in.sin_addr;\n\n\tdst = rxe_find_route(skb->dev, qp, av);\n\tif (!dst) {\n\t\trxe_dbg_qp(qp, \"Host not reachable\\n\");\n\t\treturn -EHOSTUNREACH;\n\t}\n\n\tprepare_udp_hdr(skb, cpu_to_be16(qp->src_port),\n\t\t\tcpu_to_be16(ROCE_V2_UDP_DPORT));\n\n\tprepare_ipv4_hdr(dst, skb, saddr->s_addr, daddr->s_addr, IPPROTO_UDP,\n\t\t\t av->grh.traffic_class, av->grh.hop_limit, df, xnet);\n\n\tdst_release(dst);\n\treturn 0;\n}\n\nstatic int prepare6(struct rxe_av *av, struct rxe_pkt_info *pkt,\n\t\t    struct sk_buff *skb)\n{\n\tstruct rxe_qp *qp = pkt->qp;\n\tstruct dst_entry *dst;\n\tstruct in6_addr *saddr = &av->sgid_addr._sockaddr_in6.sin6_addr;\n\tstruct in6_addr *daddr = &av->dgid_addr._sockaddr_in6.sin6_addr;\n\n\tdst = rxe_find_route(skb->dev, qp, av);\n\tif (!dst) {\n\t\trxe_dbg_qp(qp, \"Host not reachable\\n\");\n\t\treturn -EHOSTUNREACH;\n\t}\n\n\tprepare_udp_hdr(skb, cpu_to_be16(qp->src_port),\n\t\t\tcpu_to_be16(ROCE_V2_UDP_DPORT));\n\n\tprepare_ipv6_hdr(dst, skb, saddr, daddr, IPPROTO_UDP,\n\t\t\t av->grh.traffic_class,\n\t\t\t av->grh.hop_limit);\n\n\tdst_release(dst);\n\treturn 0;\n}\n\nint rxe_prepare(struct rxe_av *av, struct rxe_pkt_info *pkt,\n\t\tstruct sk_buff *skb)\n{\n\tint err = 0;\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\terr = prepare4(av, pkt, skb);\n\telse if (skb->protocol == htons(ETH_P_IPV6))\n\t\terr = prepare6(av, pkt, skb);\n\n\tif (ether_addr_equal(skb->dev->dev_addr, av->dmac))\n\t\tpkt->mask |= RXE_LOOPBACK_MASK;\n\n\treturn err;\n}\n\nstatic void rxe_skb_tx_dtor(struct sk_buff *skb)\n{\n\tstruct sock *sk = skb->sk;\n\tstruct rxe_qp *qp = sk->sk_user_data;\n\tint skb_out = atomic_dec_return(&qp->skb_out);\n\n\tif (unlikely(qp->need_req_skb &&\n\t\t     skb_out < RXE_INFLIGHT_SKBS_PER_QP_LOW))\n\t\trxe_sched_task(&qp->req.task);\n\n\trxe_put(qp);\n}\n\nstatic int rxe_send(struct sk_buff *skb, struct rxe_pkt_info *pkt)\n{\n\tint err;\n\n\tskb->destructor = rxe_skb_tx_dtor;\n\tskb->sk = pkt->qp->sk->sk;\n\n\trxe_get(pkt->qp);\n\tatomic_inc(&pkt->qp->skb_out);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\terr = ip_local_out(dev_net(skb_dst(skb)->dev), skb->sk, skb);\n\t} else if (skb->protocol == htons(ETH_P_IPV6)) {\n\t\terr = ip6_local_out(dev_net(skb_dst(skb)->dev), skb->sk, skb);\n\t} else {\n\t\trxe_dbg_qp(pkt->qp, \"Unknown layer 3 protocol: %d\\n\",\n\t\t\t\tskb->protocol);\n\t\tatomic_dec(&pkt->qp->skb_out);\n\t\trxe_put(pkt->qp);\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(net_xmit_eval(err))) {\n\t\trxe_dbg_qp(pkt->qp, \"error sending packet: %d\\n\", err);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rxe_loopback(struct sk_buff *skb, struct rxe_pkt_info *pkt)\n{\n\tmemcpy(SKB_TO_PKT(skb), pkt, sizeof(*pkt));\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\tskb_pull(skb, sizeof(struct iphdr));\n\telse\n\t\tskb_pull(skb, sizeof(struct ipv6hdr));\n\n\tif (WARN_ON(!ib_device_try_get(&pkt->rxe->ib_dev))) {\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\t \n\tskb_pull(skb, sizeof(struct udphdr));\n\n\trxe_rcv(skb);\n\n\treturn 0;\n}\n\nint rxe_xmit_packet(struct rxe_qp *qp, struct rxe_pkt_info *pkt,\n\t\t    struct sk_buff *skb)\n{\n\tint err;\n\tint is_request = pkt->mask & RXE_REQ_MASK;\n\tstruct rxe_dev *rxe = to_rdev(qp->ibqp.device);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->state_lock, flags);\n\tif ((is_request && (qp_state(qp) < IB_QPS_RTS)) ||\n\t    (!is_request && (qp_state(qp) < IB_QPS_RTR))) {\n\t\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\t\trxe_dbg_qp(qp, \"Packet dropped. QP is not in ready state\\n\");\n\t\tgoto drop;\n\t}\n\tspin_unlock_irqrestore(&qp->state_lock, flags);\n\n\trxe_icrc_generate(skb, pkt);\n\n\tif (pkt->mask & RXE_LOOPBACK_MASK)\n\t\terr = rxe_loopback(skb, pkt);\n\telse\n\t\terr = rxe_send(skb, pkt);\n\tif (err) {\n\t\trxe_counter_inc(rxe, RXE_CNT_SEND_ERR);\n\t\treturn err;\n\t}\n\n\tif ((qp_type(qp) != IB_QPT_RC) &&\n\t    (pkt->mask & RXE_END_MASK)) {\n\t\tpkt->wqe->state = wqe_state_done;\n\t\trxe_sched_task(&qp->comp.task);\n\t}\n\n\trxe_counter_inc(rxe, RXE_CNT_SENT_PKTS);\n\tgoto done;\n\ndrop:\n\tkfree_skb(skb);\n\terr = 0;\ndone:\n\treturn err;\n}\n\nstruct sk_buff *rxe_init_packet(struct rxe_dev *rxe, struct rxe_av *av,\n\t\t\t\tint paylen, struct rxe_pkt_info *pkt)\n{\n\tunsigned int hdr_len;\n\tstruct sk_buff *skb = NULL;\n\tstruct net_device *ndev;\n\tconst struct ib_gid_attr *attr;\n\tconst int port_num = 1;\n\n\tattr = rdma_get_gid_attr(&rxe->ib_dev, port_num, av->grh.sgid_index);\n\tif (IS_ERR(attr))\n\t\treturn NULL;\n\n\tif (av->network_type == RXE_NETWORK_TYPE_IPV4)\n\t\thdr_len = ETH_HLEN + sizeof(struct udphdr) +\n\t\t\tsizeof(struct iphdr);\n\telse\n\t\thdr_len = ETH_HLEN + sizeof(struct udphdr) +\n\t\t\tsizeof(struct ipv6hdr);\n\n\trcu_read_lock();\n\tndev = rdma_read_gid_attr_ndev_rcu(attr);\n\tif (IS_ERR(ndev)) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\tskb = alloc_skb(paylen + hdr_len + LL_RESERVED_SPACE(ndev),\n\t\t\tGFP_ATOMIC);\n\n\tif (unlikely(!skb)) {\n\t\trcu_read_unlock();\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, hdr_len + LL_RESERVED_SPACE(ndev));\n\n\t \n\tskb->dev\t= ndev;\n\trcu_read_unlock();\n\n\tif (av->network_type == RXE_NETWORK_TYPE_IPV4)\n\t\tskb->protocol = htons(ETH_P_IP);\n\telse\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\tpkt->rxe\t= rxe;\n\tpkt->port_num\t= port_num;\n\tpkt->hdr\t= skb_put(skb, paylen);\n\tpkt->mask\t|= RXE_GRH_MASK;\n\nout:\n\trdma_put_gid_attr(attr);\n\treturn skb;\n}\n\n \nconst char *rxe_parent_name(struct rxe_dev *rxe, unsigned int port_num)\n{\n\treturn rxe->ndev->name;\n}\n\nint rxe_net_add(const char *ibdev_name, struct net_device *ndev)\n{\n\tint err;\n\tstruct rxe_dev *rxe = NULL;\n\n\trxe = ib_alloc_device(rxe_dev, ib_dev);\n\tif (!rxe)\n\t\treturn -ENOMEM;\n\n\trxe->ndev = ndev;\n\n\terr = rxe_add(rxe, ndev->mtu, ibdev_name);\n\tif (err) {\n\t\tib_dealloc_device(&rxe->ib_dev);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void rxe_port_event(struct rxe_dev *rxe,\n\t\t\t   enum ib_event_type event)\n{\n\tstruct ib_event ev;\n\n\tev.device = &rxe->ib_dev;\n\tev.element.port_num = 1;\n\tev.event = event;\n\n\tib_dispatch_event(&ev);\n}\n\n \nvoid rxe_port_up(struct rxe_dev *rxe)\n{\n\tstruct rxe_port *port;\n\n\tport = &rxe->port;\n\tport->attr.state = IB_PORT_ACTIVE;\n\n\trxe_port_event(rxe, IB_EVENT_PORT_ACTIVE);\n\tdev_info(&rxe->ib_dev.dev, \"set active\\n\");\n}\n\n \nvoid rxe_port_down(struct rxe_dev *rxe)\n{\n\tstruct rxe_port *port;\n\n\tport = &rxe->port;\n\tport->attr.state = IB_PORT_DOWN;\n\n\trxe_port_event(rxe, IB_EVENT_PORT_ERR);\n\trxe_counter_inc(rxe, RXE_CNT_LINK_DOWNED);\n\tdev_info(&rxe->ib_dev.dev, \"set down\\n\");\n}\n\nvoid rxe_set_port_state(struct rxe_dev *rxe)\n{\n\tif (netif_running(rxe->ndev) && netif_carrier_ok(rxe->ndev))\n\t\trxe_port_up(rxe);\n\telse\n\t\trxe_port_down(rxe);\n}\n\nstatic int rxe_notify(struct notifier_block *not_blk,\n\t\t      unsigned long event,\n\t\t      void *arg)\n{\n\tstruct net_device *ndev = netdev_notifier_info_to_dev(arg);\n\tstruct rxe_dev *rxe = rxe_get_dev_from_net(ndev);\n\n\tif (!rxe)\n\t\treturn NOTIFY_OK;\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tib_unregister_device_queued(&rxe->ib_dev);\n\t\tbreak;\n\tcase NETDEV_UP:\n\t\trxe_port_up(rxe);\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\trxe_port_down(rxe);\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\trxe_dbg_dev(rxe, \"%s changed mtu to %d\\n\", ndev->name, ndev->mtu);\n\t\trxe_set_mtu(rxe, ndev->mtu);\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\trxe_set_port_state(rxe);\n\t\tbreak;\n\tcase NETDEV_REBOOT:\n\tcase NETDEV_GOING_DOWN:\n\tcase NETDEV_CHANGEADDR:\n\tcase NETDEV_CHANGENAME:\n\tcase NETDEV_FEAT_CHANGE:\n\tdefault:\n\t\trxe_dbg_dev(rxe, \"ignoring netdev event = %ld for %s\\n\",\n\t\t\tevent, ndev->name);\n\t\tbreak;\n\t}\n\n\tib_device_put(&rxe->ib_dev);\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block rxe_net_notifier = {\n\t.notifier_call = rxe_notify,\n};\n\nstatic int rxe_net_ipv4_init(void)\n{\n\trecv_sockets.sk4 = rxe_setup_udp_tunnel(&init_net,\n\t\t\t\thtons(ROCE_V2_UDP_DPORT), false);\n\tif (IS_ERR(recv_sockets.sk4)) {\n\t\trecv_sockets.sk4 = NULL;\n\t\tpr_err(\"Failed to create IPv4 UDP tunnel\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rxe_net_ipv6_init(void)\n{\n#if IS_ENABLED(CONFIG_IPV6)\n\n\trecv_sockets.sk6 = rxe_setup_udp_tunnel(&init_net,\n\t\t\t\t\t\thtons(ROCE_V2_UDP_DPORT), true);\n\tif (PTR_ERR(recv_sockets.sk6) == -EAFNOSUPPORT) {\n\t\trecv_sockets.sk6 = NULL;\n\t\tpr_warn(\"IPv6 is not supported, can not create a UDPv6 socket\\n\");\n\t\treturn 0;\n\t}\n\n\tif (IS_ERR(recv_sockets.sk6)) {\n\t\trecv_sockets.sk6 = NULL;\n\t\tpr_err(\"Failed to create IPv6 UDP tunnel\\n\");\n\t\treturn -1;\n\t}\n#endif\n\treturn 0;\n}\n\nvoid rxe_net_exit(void)\n{\n\trxe_release_udp_tunnel(recv_sockets.sk6);\n\trxe_release_udp_tunnel(recv_sockets.sk4);\n\tunregister_netdevice_notifier(&rxe_net_notifier);\n}\n\nint rxe_net_init(void)\n{\n\tint err;\n\n\trecv_sockets.sk6 = NULL;\n\n\terr = rxe_net_ipv4_init();\n\tif (err)\n\t\treturn err;\n\terr = rxe_net_ipv6_init();\n\tif (err)\n\t\tgoto err_out;\n\terr = register_netdevice_notifier(&rxe_net_notifier);\n\tif (err) {\n\t\tpr_err(\"Failed to register netdev notifier\\n\");\n\t\tgoto err_out;\n\t}\n\treturn 0;\nerr_out:\n\trxe_net_exit();\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}