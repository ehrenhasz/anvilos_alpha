{
  "module_name": "rxe_queue.h",
  "hash_id": "487a8c383833cb51ba5af9417746160f899d6e3b862dd07eb360acc686a4caeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_queue.h",
  "human_readable_source": " \n \n\n#ifndef RXE_QUEUE_H\n#define RXE_QUEUE_H\n\n \n\n \nenum queue_type {\n\tQUEUE_TYPE_TO_CLIENT,\n\tQUEUE_TYPE_FROM_CLIENT,\n\tQUEUE_TYPE_FROM_ULP,\n\tQUEUE_TYPE_TO_ULP,\n};\n\nstruct rxe_queue_buf;\n\nstruct rxe_queue {\n\tstruct rxe_dev\t\t*rxe;\n\tstruct rxe_queue_buf\t*buf;\n\tstruct rxe_mmap_info\t*ip;\n\tsize_t\t\t\tbuf_size;\n\tsize_t\t\t\telem_size;\n\tunsigned int\t\tlog2_elem_size;\n\tu32\t\t\tindex_mask;\n\tenum queue_type\t\ttype;\n\t \n\tu32\t\t\tindex;\n};\n\nint do_mmap_info(struct rxe_dev *rxe, struct mminfo __user *outbuf,\n\t\t struct ib_udata *udata, struct rxe_queue_buf *buf,\n\t\t size_t buf_size, struct rxe_mmap_info **ip_p);\n\nvoid rxe_queue_reset(struct rxe_queue *q);\n\nstruct rxe_queue *rxe_queue_init(struct rxe_dev *rxe, int *num_elem,\n\t\t\tunsigned int elem_size, enum queue_type type);\n\nint rxe_queue_resize(struct rxe_queue *q, unsigned int *num_elem_p,\n\t\t     unsigned int elem_size, struct ib_udata *udata,\n\t\t     struct mminfo __user *outbuf,\n\t\t     spinlock_t *producer_lock, spinlock_t *consumer_lock);\n\nvoid rxe_queue_cleanup(struct rxe_queue *queue);\n\nstatic inline u32 queue_next_index(struct rxe_queue *q, int index)\n{\n\treturn (index + 1) & q->index_mask;\n}\n\nstatic inline u32 queue_get_producer(const struct rxe_queue *q,\n\t\t\t\t     enum queue_type type)\n{\n\tu32 prod;\n\n\tswitch (type) {\n\tcase QUEUE_TYPE_FROM_CLIENT:\n\t\t \n\t\tprod = smp_load_acquire(&q->buf->producer_index);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_CLIENT:\n\t\t \n\t\tprod = q->index;\n\t\tbreak;\n\tcase QUEUE_TYPE_FROM_ULP:\n\t\t \n\t\tprod = q->buf->producer_index;\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_ULP:\n\t\t \n\t\tprod = smp_load_acquire(&q->buf->producer_index);\n\t\tbreak;\n\t}\n\n\treturn prod;\n}\n\nstatic inline u32 queue_get_consumer(const struct rxe_queue *q,\n\t\t\t\t     enum queue_type type)\n{\n\tu32 cons;\n\n\tswitch (type) {\n\tcase QUEUE_TYPE_FROM_CLIENT:\n\t\t \n\t\tcons = q->index;\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_CLIENT:\n\t\t \n\t\tcons = smp_load_acquire(&q->buf->consumer_index);\n\t\tbreak;\n\tcase QUEUE_TYPE_FROM_ULP:\n\t\t \n\t\tcons = smp_load_acquire(&q->buf->consumer_index);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_ULP:\n\t\t \n\t\tcons = q->buf->consumer_index;\n\t\tbreak;\n\t}\n\n\treturn cons;\n}\n\nstatic inline int queue_empty(struct rxe_queue *q, enum queue_type type)\n{\n\tu32 prod = queue_get_producer(q, type);\n\tu32 cons = queue_get_consumer(q, type);\n\n\treturn ((prod - cons) & q->index_mask) == 0;\n}\n\nstatic inline int queue_full(struct rxe_queue *q, enum queue_type type)\n{\n\tu32 prod = queue_get_producer(q, type);\n\tu32 cons = queue_get_consumer(q, type);\n\n\treturn ((prod + 1 - cons) & q->index_mask) == 0;\n}\n\nstatic inline u32 queue_count(const struct rxe_queue *q,\n\t\t\t\t\tenum queue_type type)\n{\n\tu32 prod = queue_get_producer(q, type);\n\tu32 cons = queue_get_consumer(q, type);\n\n\treturn (prod - cons) & q->index_mask;\n}\n\nstatic inline void queue_advance_producer(struct rxe_queue *q,\n\t\t\t\t\t  enum queue_type type)\n{\n\tu32 prod;\n\n\tswitch (type) {\n\tcase QUEUE_TYPE_FROM_CLIENT:\n\t\t \n\t\tif (WARN_ON(1))\n\t\t\tpr_warn(\"%s: attempt to advance client index\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_CLIENT:\n\t\t \n\t\tprod = q->index;\n\t\tprod = (prod + 1) & q->index_mask;\n\t\tq->index = prod;\n\t\t \n\t\tsmp_store_release(&q->buf->producer_index, prod);\n\t\tbreak;\n\tcase QUEUE_TYPE_FROM_ULP:\n\t\t \n\t\tprod = q->buf->producer_index;\n\t\tprod = (prod + 1) & q->index_mask;\n\t\t \n\t\tsmp_store_release(&q->buf->producer_index, prod);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_ULP:\n\t\t \n\t\tif (WARN_ON(1))\n\t\t\tpr_warn(\"%s: attempt to advance driver index\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\t}\n}\n\nstatic inline void queue_advance_consumer(struct rxe_queue *q,\n\t\t\t\t\t  enum queue_type type)\n{\n\tu32 cons;\n\n\tswitch (type) {\n\tcase QUEUE_TYPE_FROM_CLIENT:\n\t\t \n\t\tcons = (q->index + 1) & q->index_mask;\n\t\tq->index = cons;\n\t\t \n\t\tsmp_store_release(&q->buf->consumer_index, cons);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_CLIENT:\n\t\t \n\t\tif (WARN_ON(1))\n\t\t\tpr_warn(\"%s: attempt to advance client index\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase QUEUE_TYPE_FROM_ULP:\n\t\t \n\t\tif (WARN_ON(1))\n\t\t\tpr_warn(\"%s: attempt to advance driver index\\n\",\n\t\t\t\t__func__);\n\t\tbreak;\n\tcase QUEUE_TYPE_TO_ULP:\n\t\t \n\t\tcons = q->buf->consumer_index;\n\t\tcons = (cons + 1) & q->index_mask;\n\t\t \n\t\tsmp_store_release(&q->buf->consumer_index, cons);\n\t\tbreak;\n\t}\n}\n\nstatic inline void *queue_producer_addr(struct rxe_queue *q,\n\t\t\t\t\tenum queue_type type)\n{\n\tu32 prod = queue_get_producer(q, type);\n\n\treturn q->buf->data + (prod << q->log2_elem_size);\n}\n\nstatic inline void *queue_consumer_addr(struct rxe_queue *q,\n\t\t\t\t\tenum queue_type type)\n{\n\tu32 cons = queue_get_consumer(q, type);\n\n\treturn q->buf->data + (cons << q->log2_elem_size);\n}\n\nstatic inline void *queue_addr_from_index(struct rxe_queue *q, u32 index)\n{\n\treturn q->buf->data + ((index & q->index_mask)\n\t\t\t\t<< q->log2_elem_size);\n}\n\nstatic inline u32 queue_index_from_addr(const struct rxe_queue *q,\n\t\t\t\tconst void *addr)\n{\n\treturn (((u8 *)addr - q->buf->data) >> q->log2_elem_size)\n\t\t\t\t& q->index_mask;\n}\n\nstatic inline void *queue_head(struct rxe_queue *q, enum queue_type type)\n{\n\treturn queue_empty(q, type) ? NULL : queue_consumer_addr(q, type);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}