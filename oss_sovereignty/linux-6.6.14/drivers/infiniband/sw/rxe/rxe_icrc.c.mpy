{
  "module_name": "rxe_icrc.c",
  "hash_id": "b7beb530b63b09a5aa882c69f24e98f4e01215cae45f48b5172347c85b0ccaaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_icrc.c",
  "human_readable_source": "\n \n\n#include <linux/crc32.h>\n\n#include \"rxe.h\"\n#include \"rxe_loc.h\"\n\n \nint rxe_icrc_init(struct rxe_dev *rxe)\n{\n\tstruct crypto_shash *tfm;\n\n\ttfm = crypto_alloc_shash(\"crc32\", 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\trxe_dbg_dev(rxe, \"failed to init crc32 algorithm err: %ld\\n\",\n\t\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\trxe->tfm = tfm;\n\n\treturn 0;\n}\n\n \nstatic __be32 rxe_crc32(struct rxe_dev *rxe, __be32 crc, void *next, size_t len)\n{\n\t__be32 icrc;\n\tint err;\n\n\tSHASH_DESC_ON_STACK(shash, rxe->tfm);\n\n\tshash->tfm = rxe->tfm;\n\t*(__be32 *)shash_desc_ctx(shash) = crc;\n\terr = crypto_shash_update(shash, next, len);\n\tif (unlikely(err)) {\n\t\trxe_dbg_dev(rxe, \"failed crc calculation, err: %d\\n\", err);\n\t\treturn (__force __be32)crc32_le((__force u32)crc, next, len);\n\t}\n\n\ticrc = *(__be32 *)shash_desc_ctx(shash);\n\tbarrier_data(shash_desc_ctx(shash));\n\n\treturn icrc;\n}\n\n \nstatic __be32 rxe_icrc_hdr(struct sk_buff *skb, struct rxe_pkt_info *pkt)\n{\n\tunsigned int bth_offset = 0;\n\tstruct iphdr *ip4h = NULL;\n\tstruct ipv6hdr *ip6h = NULL;\n\tstruct udphdr *udph;\n\tstruct rxe_bth *bth;\n\t__be32 crc;\n\tint length;\n\tint hdr_size = sizeof(struct udphdr) +\n\t\t(skb->protocol == htons(ETH_P_IP) ?\n\t\tsizeof(struct iphdr) : sizeof(struct ipv6hdr));\n\t \n\tu8 pshdr[sizeof(struct udphdr) +\n\t\tsizeof(struct ipv6hdr) +\n\t\tRXE_BTH_BYTES];\n\n\t \n\tcrc = (__force __be32)0xdebb20e3;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {  \n\t\tmemcpy(pshdr, ip_hdr(skb), hdr_size);\n\t\tip4h = (struct iphdr *)pshdr;\n\t\tudph = (struct udphdr *)(ip4h + 1);\n\n\t\tip4h->ttl = 0xff;\n\t\tip4h->check = CSUM_MANGLED_0;\n\t\tip4h->tos = 0xff;\n\t} else {\t\t\t\t \n\t\tmemcpy(pshdr, ipv6_hdr(skb), hdr_size);\n\t\tip6h = (struct ipv6hdr *)pshdr;\n\t\tudph = (struct udphdr *)(ip6h + 1);\n\n\t\tmemset(ip6h->flow_lbl, 0xff, sizeof(ip6h->flow_lbl));\n\t\tip6h->priority = 0xf;\n\t\tip6h->hop_limit = 0xff;\n\t}\n\tudph->check = CSUM_MANGLED_0;\n\n\tbth_offset += hdr_size;\n\n\tmemcpy(&pshdr[bth_offset], pkt->hdr, RXE_BTH_BYTES);\n\tbth = (struct rxe_bth *)&pshdr[bth_offset];\n\n\t \n\tbth->qpn |= cpu_to_be32(~BTH_QPN_MASK);\n\n\tlength = hdr_size + RXE_BTH_BYTES;\n\tcrc = rxe_crc32(pkt->rxe, crc, pshdr, length);\n\n\t \n\tcrc = rxe_crc32(pkt->rxe, crc, pkt->hdr + RXE_BTH_BYTES,\n\t\t\trxe_opcode[pkt->opcode].length - RXE_BTH_BYTES);\n\treturn crc;\n}\n\n \nint rxe_icrc_check(struct sk_buff *skb, struct rxe_pkt_info *pkt)\n{\n\t__be32 *icrcp;\n\t__be32 pkt_icrc;\n\t__be32 icrc;\n\n\ticrcp = (__be32 *)(pkt->hdr + pkt->paylen - RXE_ICRC_SIZE);\n\tpkt_icrc = *icrcp;\n\n\ticrc = rxe_icrc_hdr(skb, pkt);\n\ticrc = rxe_crc32(pkt->rxe, icrc, (u8 *)payload_addr(pkt),\n\t\t\t\tpayload_size(pkt) + bth_pad(pkt));\n\ticrc = ~icrc;\n\n\tif (unlikely(icrc != pkt_icrc))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nvoid rxe_icrc_generate(struct sk_buff *skb, struct rxe_pkt_info *pkt)\n{\n\t__be32 *icrcp;\n\t__be32 icrc;\n\n\ticrcp = (__be32 *)(pkt->hdr + pkt->paylen - RXE_ICRC_SIZE);\n\ticrc = rxe_icrc_hdr(skb, pkt);\n\ticrc = rxe_crc32(pkt->rxe, icrc, (u8 *)payload_addr(pkt),\n\t\t\t\tpayload_size(pkt) + bth_pad(pkt));\n\t*icrcp = ~icrc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}