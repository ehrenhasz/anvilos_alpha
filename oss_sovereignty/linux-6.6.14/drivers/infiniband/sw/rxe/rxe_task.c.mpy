{
  "module_name": "rxe_task.c",
  "hash_id": "9b9bcdd2cab8a722620ee0f3dec4d49a861c6814ad6ab3243685039f4a12caa0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_task.c",
  "human_readable_source": "\n \n\n#include \"rxe.h\"\n\nstatic struct workqueue_struct *rxe_wq;\n\nint rxe_alloc_wq(void)\n{\n\trxe_wq = alloc_workqueue(\"rxe_wq\", WQ_UNBOUND, WQ_MAX_ACTIVE);\n\tif (!rxe_wq)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid rxe_destroy_wq(void)\n{\n\tdestroy_workqueue(rxe_wq);\n}\n\n \nstatic bool __reserve_if_idle(struct rxe_task *task)\n{\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tif (task->state == TASK_STATE_IDLE) {\n\t\trxe_get(task->qp);\n\t\ttask->state = TASK_STATE_BUSY;\n\t\ttask->num_sched++;\n\t\treturn true;\n\t}\n\n\tif (task->state == TASK_STATE_BUSY)\n\t\ttask->state = TASK_STATE_ARMED;\n\n\treturn false;\n}\n\n \nstatic bool __is_done(struct rxe_task *task)\n{\n\tif (work_pending(&task->work))\n\t\treturn false;\n\n\tif (task->state == TASK_STATE_IDLE ||\n\t    task->state == TASK_STATE_DRAINED) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool is_done(struct rxe_task *task)\n{\n\tunsigned long flags;\n\tint done;\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tdone = __is_done(task);\n\tspin_unlock_irqrestore(&task->lock, flags);\n\n\treturn done;\n}\n\n \nstatic void do_task(struct rxe_task *task)\n{\n\tunsigned int iterations;\n\tunsigned long flags;\n\tint resched = 0;\n\tint cont;\n\tint ret;\n\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tif (task->state >= TASK_STATE_DRAINED) {\n\t\trxe_put(task->qp);\n\t\ttask->num_done++;\n\t\tspin_unlock_irqrestore(&task->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&task->lock, flags);\n\n\tdo {\n\t\titerations = RXE_MAX_ITERATIONS;\n\t\tcont = 0;\n\n\t\tdo {\n\t\t\tret = task->func(task->qp);\n\t\t} while (ret == 0 && iterations-- > 0);\n\n\t\tspin_lock_irqsave(&task->lock, flags);\n\t\t \n\t\tif (!ret) {\n\t\t\ttask->state = TASK_STATE_IDLE;\n\t\t\tresched = 1;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tswitch (task->state) {\n\t\tcase TASK_STATE_BUSY:\n\t\t\ttask->state = TASK_STATE_IDLE;\n\t\t\tbreak;\n\n\t\t \n\t\tcase TASK_STATE_ARMED:\n\t\t\ttask->state = TASK_STATE_BUSY;\n\t\t\tcont = 1;\n\t\t\tbreak;\n\n\t\tcase TASK_STATE_DRAINING:\n\t\t\ttask->state = TASK_STATE_DRAINED;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\trxe_dbg_qp(task->qp, \"unexpected task state = %d\",\n\t\t\t\t   task->state);\n\t\t\ttask->state = TASK_STATE_IDLE;\n\t\t}\n\nexit:\n\t\tif (!cont) {\n\t\t\ttask->num_done++;\n\t\t\tif (WARN_ON(task->num_done != task->num_sched))\n\t\t\t\trxe_dbg_qp(\n\t\t\t\t\ttask->qp,\n\t\t\t\t\t\"%ld tasks scheduled, %ld tasks done\",\n\t\t\t\t\ttask->num_sched, task->num_done);\n\t\t}\n\t\tspin_unlock_irqrestore(&task->lock, flags);\n\t} while (cont);\n\n\ttask->ret = ret;\n\n\tif (resched)\n\t\trxe_sched_task(task);\n\n\trxe_put(task->qp);\n}\n\n \nstatic void do_work(struct work_struct *work)\n{\n\tdo_task(container_of(work, struct rxe_task, work));\n}\n\nint rxe_init_task(struct rxe_task *task, struct rxe_qp *qp,\n\t\t  int (*func)(struct rxe_qp *))\n{\n\tWARN_ON(rxe_read(qp) <= 0);\n\n\ttask->qp = qp;\n\ttask->func = func;\n\ttask->state = TASK_STATE_IDLE;\n\tspin_lock_init(&task->lock);\n\tINIT_WORK(&task->work, do_work);\n\n\treturn 0;\n}\n\n \nvoid rxe_cleanup_task(struct rxe_task *task)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tif (!__is_done(task) && task->state < TASK_STATE_DRAINED) {\n\t\ttask->state = TASK_STATE_DRAINING;\n\t} else {\n\t\ttask->state = TASK_STATE_INVALID;\n\t\tspin_unlock_irqrestore(&task->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&task->lock, flags);\n\n\t \n\twhile (!is_done(task))\n\t\tcond_resched();\n\n\tspin_lock_irqsave(&task->lock, flags);\n\ttask->state = TASK_STATE_INVALID;\n\tspin_unlock_irqrestore(&task->lock, flags);\n}\n\n \nvoid rxe_run_task(struct rxe_task *task)\n{\n\tunsigned long flags;\n\tbool run;\n\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tspin_lock_irqsave(&task->lock, flags);\n\trun = __reserve_if_idle(task);\n\tspin_unlock_irqrestore(&task->lock, flags);\n\n\tif (run)\n\t\tdo_task(task);\n}\n\n \nvoid rxe_sched_task(struct rxe_task *task)\n{\n\tunsigned long flags;\n\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tif (__reserve_if_idle(task))\n\t\tqueue_work(rxe_wq, &task->work);\n\tspin_unlock_irqrestore(&task->lock, flags);\n}\n\n \nvoid rxe_disable_task(struct rxe_task *task)\n{\n\tunsigned long flags;\n\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tif (!__is_done(task) && task->state < TASK_STATE_DRAINED) {\n\t\ttask->state = TASK_STATE_DRAINING;\n\t} else {\n\t\ttask->state = TASK_STATE_DRAINED;\n\t\tspin_unlock_irqrestore(&task->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&task->lock, flags);\n\n\twhile (!is_done(task))\n\t\tcond_resched();\n\n\tspin_lock_irqsave(&task->lock, flags);\n\ttask->state = TASK_STATE_DRAINED;\n\tspin_unlock_irqrestore(&task->lock, flags);\n}\n\nvoid rxe_enable_task(struct rxe_task *task)\n{\n\tunsigned long flags;\n\n\tWARN_ON(rxe_read(task->qp) <= 0);\n\n\tspin_lock_irqsave(&task->lock, flags);\n\tif (task->state == TASK_STATE_INVALID) {\n\t\tspin_unlock_irqrestore(&task->lock, flags);\n\t\treturn;\n\t}\n\n\ttask->state = TASK_STATE_IDLE;\n\tspin_unlock_irqrestore(&task->lock, flags);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}