{
  "module_name": "rxe_verbs.h",
  "hash_id": "7a273a7b5be1196cb6aa3c40a2a36e4f62a47c3ab2b82978c8e59e700cf8d054",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rxe/rxe_verbs.h",
  "human_readable_source": " \n \n\n#ifndef RXE_VERBS_H\n#define RXE_VERBS_H\n\n#include <linux/interrupt.h>\n#include <linux/workqueue.h>\n#include \"rxe_pool.h\"\n#include \"rxe_task.h\"\n#include \"rxe_hw_counters.h\"\n\nstatic inline int pkey_match(u16 key1, u16 key2)\n{\n\treturn (((key1 & 0x7fff) != 0) &&\n\t\t((key1 & 0x7fff) == (key2 & 0x7fff)) &&\n\t\t((key1 & 0x8000) || (key2 & 0x8000))) ? 1 : 0;\n}\n\n \nstatic inline int psn_compare(u32 psn_a, u32 psn_b)\n{\n\ts32 diff;\n\n\tdiff = (psn_a - psn_b) << 8;\n\treturn diff;\n}\n\nstruct rxe_ucontext {\n\tstruct ib_ucontext ibuc;\n\tstruct rxe_pool_elem\telem;\n};\n\nstruct rxe_pd {\n\tstruct ib_pd            ibpd;\n\tstruct rxe_pool_elem\telem;\n};\n\nstruct rxe_ah {\n\tstruct ib_ah\t\tibah;\n\tstruct rxe_pool_elem\telem;\n\tstruct rxe_av\t\tav;\n\tbool\t\t\tis_user;\n\tint\t\t\tah_num;\n};\n\nstruct rxe_cqe {\n\tunion {\n\t\tstruct ib_wc\t\tibwc;\n\t\tstruct ib_uverbs_wc\tuibwc;\n\t};\n};\n\nstruct rxe_cq {\n\tstruct ib_cq\t\tibcq;\n\tstruct rxe_pool_elem\telem;\n\tstruct rxe_queue\t*queue;\n\tspinlock_t\t\tcq_lock;\n\tu8\t\t\tnotify;\n\tbool\t\t\tis_user;\n\tatomic_t\t\tnum_wq;\n};\n\nenum wqe_state {\n\twqe_state_posted,\n\twqe_state_processing,\n\twqe_state_pending,\n\twqe_state_done,\n\twqe_state_error,\n};\n\nstruct rxe_sq {\n\tint\t\t\tmax_wr;\n\tint\t\t\tmax_sge;\n\tint\t\t\tmax_inline;\n\tspinlock_t\t\tsq_lock;  \n\tstruct rxe_queue\t*queue;\n};\n\nstruct rxe_rq {\n\tint\t\t\tmax_wr;\n\tint\t\t\tmax_sge;\n\tspinlock_t\t\tproducer_lock;  \n\tspinlock_t\t\tconsumer_lock;  \n\tstruct rxe_queue\t*queue;\n};\n\nstruct rxe_srq {\n\tstruct ib_srq\t\tibsrq;\n\tstruct rxe_pool_elem\telem;\n\tstruct rxe_pd\t\t*pd;\n\tstruct rxe_rq\t\trq;\n\tu32\t\t\tsrq_num;\n\n\tint\t\t\tlimit;\n\tint\t\t\terror;\n};\n\nstruct rxe_req_info {\n\tint\t\t\twqe_index;\n\tu32\t\t\tpsn;\n\tint\t\t\topcode;\n\tatomic_t\t\trd_atomic;\n\tint\t\t\twait_fence;\n\tint\t\t\tneed_rd_atomic;\n\tint\t\t\twait_psn;\n\tint\t\t\tneed_retry;\n\tint\t\t\twait_for_rnr_timer;\n\tint\t\t\tnoack_pkts;\n\tstruct rxe_task\t\ttask;\n};\n\nstruct rxe_comp_info {\n\tu32\t\t\tpsn;\n\tint\t\t\topcode;\n\tint\t\t\ttimeout;\n\tint\t\t\ttimeout_retry;\n\tint\t\t\tstarted_retry;\n\tu32\t\t\tretry_cnt;\n\tu32\t\t\trnr_retry;\n\tstruct rxe_task\t\ttask;\n};\n\nenum rdatm_res_state {\n\trdatm_res_state_next,\n\trdatm_res_state_new,\n\trdatm_res_state_replay,\n};\n\nstruct resp_res {\n\tint\t\t\ttype;\n\tint\t\t\treplay;\n\tu32\t\t\tfirst_psn;\n\tu32\t\t\tlast_psn;\n\tu32\t\t\tcur_psn;\n\tenum rdatm_res_state\tstate;\n\n\tunion {\n\t\tstruct {\n\t\t\tu64\t\torig_val;\n\t\t} atomic;\n\t\tstruct {\n\t\t\tu64\t\tva_org;\n\t\t\tu32\t\trkey;\n\t\t\tu32\t\tlength;\n\t\t\tu64\t\tva;\n\t\t\tu32\t\tresid;\n\t\t} read;\n\t\tstruct {\n\t\t\tu32\t\tlength;\n\t\t\tu64\t\tva;\n\t\t\tu8\t\ttype;\n\t\t\tu8\t\tlevel;\n\t\t} flush;\n\t};\n};\n\nstruct rxe_resp_info {\n\tu32\t\t\tmsn;\n\tu32\t\t\tpsn;\n\tu32\t\t\tack_psn;\n\tint\t\t\topcode;\n\tint\t\t\tdrop_msg;\n\tint\t\t\tgoto_error;\n\tint\t\t\tsent_psn_nak;\n\tenum ib_wc_status\tstatus;\n\tu8\t\t\taeth_syndrome;\n\n\t \n\tstruct rxe_recv_wqe\t*wqe;\n\n\t \n\tu64\t\t\tva;\n\tu64\t\t\toffset;\n\tstruct rxe_mr\t\t*mr;\n\tu32\t\t\tresid;\n\tu32\t\t\trkey;\n\tu32\t\t\tlength;\n\n\t \n\tstruct {\n\t\tstruct rxe_recv_wqe\twqe;\n\t\tstruct ib_sge\t\tsge[RXE_MAX_SGE];\n\t} srq_wqe;\n\n\t \n\tstruct resp_res\t\t*resources;\n\tunsigned int\t\tres_head;\n\tunsigned int\t\tres_tail;\n\tstruct resp_res\t\t*res;\n\tstruct rxe_task\t\ttask;\n};\n\nstruct rxe_qp {\n\tstruct ib_qp\t\tibqp;\n\tstruct rxe_pool_elem\telem;\n\tstruct ib_qp_attr\tattr;\n\tunsigned int\t\tvalid;\n\tunsigned int\t\tmtu;\n\tbool\t\t\tis_user;\n\n\tstruct rxe_pd\t\t*pd;\n\tstruct rxe_srq\t\t*srq;\n\tstruct rxe_cq\t\t*scq;\n\tstruct rxe_cq\t\t*rcq;\n\n\tenum ib_sig_type\tsq_sig_type;\n\n\tstruct rxe_sq\t\tsq;\n\tstruct rxe_rq\t\trq;\n\n\tstruct socket\t\t*sk;\n\tu32\t\t\tdst_cookie;\n\tu16\t\t\tsrc_port;\n\n\tstruct rxe_av\t\tpri_av;\n\tstruct rxe_av\t\talt_av;\n\n\tatomic_t\t\tmcg_num;\n\n\tstruct sk_buff_head\treq_pkts;\n\tstruct sk_buff_head\tresp_pkts;\n\n\tstruct rxe_req_info\treq;\n\tstruct rxe_comp_info\tcomp;\n\tstruct rxe_resp_info\tresp;\n\n\tatomic_t\t\tssn;\n\tatomic_t\t\tskb_out;\n\tint\t\t\tneed_req_skb;\n\n\t \n\tstruct timer_list retrans_timer;\n\tu64 qp_timeout_jiffies;\n\n\t \n\tstruct timer_list rnr_nak_timer;\n\n\tspinlock_t\t\tstate_lock;  \n\n\tstruct execute_work\tcleanup_work;\n};\n\nenum {\n\tRXE_ACCESS_REMOTE\t= IB_ACCESS_REMOTE_READ\n\t\t\t\t| IB_ACCESS_REMOTE_WRITE\n\t\t\t\t| IB_ACCESS_REMOTE_ATOMIC,\n\tRXE_ACCESS_SUPPORTED_MR\t= RXE_ACCESS_REMOTE\n\t\t\t\t| IB_ACCESS_LOCAL_WRITE\n\t\t\t\t| IB_ACCESS_MW_BIND\n\t\t\t\t| IB_ACCESS_ON_DEMAND\n\t\t\t\t| IB_ACCESS_FLUSH_GLOBAL\n\t\t\t\t| IB_ACCESS_FLUSH_PERSISTENT\n\t\t\t\t| IB_ACCESS_OPTIONAL,\n\tRXE_ACCESS_SUPPORTED_QP\t= RXE_ACCESS_SUPPORTED_MR,\n\tRXE_ACCESS_SUPPORTED_MW\t= RXE_ACCESS_SUPPORTED_MR\n\t\t\t\t| IB_ZERO_BASED,\n};\n\nenum rxe_mr_state {\n\tRXE_MR_STATE_INVALID,\n\tRXE_MR_STATE_FREE,\n\tRXE_MR_STATE_VALID,\n};\n\nenum rxe_mr_copy_dir {\n\tRXE_TO_MR_OBJ,\n\tRXE_FROM_MR_OBJ,\n};\n\nenum rxe_mr_lookup_type {\n\tRXE_LOOKUP_LOCAL,\n\tRXE_LOOKUP_REMOTE,\n};\n\nenum rxe_rereg {\n\tRXE_MR_REREG_SUPPORTED\t= IB_MR_REREG_PD\n\t\t\t\t| IB_MR_REREG_ACCESS,\n};\n\nstatic inline int rkey_is_mw(u32 rkey)\n{\n\tu32 index = rkey >> 8;\n\n\treturn (index >= RXE_MIN_MW_INDEX) && (index <= RXE_MAX_MW_INDEX);\n}\n\nstruct rxe_mr {\n\tstruct rxe_pool_elem\telem;\n\tstruct ib_mr\t\tibmr;\n\n\tstruct ib_umem\t\t*umem;\n\n\tu32\t\t\tlkey;\n\tu32\t\t\trkey;\n\tenum rxe_mr_state\tstate;\n\tint\t\t\taccess;\n\tatomic_t\t\tnum_mw;\n\n\tunsigned int\t\tpage_offset;\n\tunsigned int\t\tpage_shift;\n\tu64\t\t\tpage_mask;\n\n\tu32\t\t\tnum_buf;\n\tu32\t\t\tnbuf;\n\n\tstruct xarray\t\tpage_list;\n};\n\nstatic inline unsigned int mr_page_size(struct rxe_mr *mr)\n{\n\treturn mr ? mr->ibmr.page_size : PAGE_SIZE;\n}\n\nenum rxe_mw_state {\n\tRXE_MW_STATE_INVALID\t= RXE_MR_STATE_INVALID,\n\tRXE_MW_STATE_FREE\t= RXE_MR_STATE_FREE,\n\tRXE_MW_STATE_VALID\t= RXE_MR_STATE_VALID,\n};\n\nstruct rxe_mw {\n\tstruct ib_mw\t\tibmw;\n\tstruct rxe_pool_elem\telem;\n\tspinlock_t\t\tlock;\n\tenum rxe_mw_state\tstate;\n\tstruct rxe_qp\t\t*qp;  \n\tstruct rxe_mr\t\t*mr;\n\tu32\t\t\trkey;\n\tint\t\t\taccess;\n\tu64\t\t\taddr;\n\tu64\t\t\tlength;\n};\n\nstruct rxe_mcg {\n\tstruct rb_node\t\tnode;\n\tstruct kref\t\tref_cnt;\n\tstruct rxe_dev\t\t*rxe;\n\tstruct list_head\tqp_list;\n\tunion ib_gid\t\tmgid;\n\tatomic_t\t\tqp_num;\n\tu32\t\t\tqkey;\n\tu16\t\t\tpkey;\n};\n\nstruct rxe_mca {\n\tstruct list_head\tqp_list;\n\tstruct rxe_qp\t\t*qp;\n};\n\nstruct rxe_port {\n\tstruct ib_port_attr\tattr;\n\t__be64\t\t\tport_guid;\n\t__be64\t\t\tsubnet_prefix;\n\tspinlock_t\t\tport_lock;  \n\tunsigned int\t\tmtu_cap;\n\t \n\tu32\t\t\tqp_gsi_index;\n};\n\nstruct rxe_dev {\n\tstruct ib_device\tib_dev;\n\tstruct ib_device_attr\tattr;\n\tint\t\t\tmax_ucontext;\n\tint\t\t\tmax_inline_data;\n\tstruct mutex\tusdev_lock;\n\n\tstruct net_device\t*ndev;\n\n\tstruct rxe_pool\t\tuc_pool;\n\tstruct rxe_pool\t\tpd_pool;\n\tstruct rxe_pool\t\tah_pool;\n\tstruct rxe_pool\t\tsrq_pool;\n\tstruct rxe_pool\t\tqp_pool;\n\tstruct rxe_pool\t\tcq_pool;\n\tstruct rxe_pool\t\tmr_pool;\n\tstruct rxe_pool\t\tmw_pool;\n\n\t \n\tspinlock_t\t\tmcg_lock;\n\tstruct rb_root\t\tmcg_tree;\n\tatomic_t\t\tmcg_num;\n\tatomic_t\t\tmcg_attach;\n\n\tspinlock_t\t\tpending_lock;  \n\tstruct list_head\tpending_mmaps;\n\n\tspinlock_t\t\tmmap_offset_lock;  \n\tu64\t\t\tmmap_offset;\n\n\tatomic64_t\t\tstats_counters[RXE_NUM_OF_COUNTERS];\n\n\tstruct rxe_port\t\tport;\n\tstruct crypto_shash\t*tfm;\n};\n\nstatic inline void rxe_counter_inc(struct rxe_dev *rxe, enum rxe_counters index)\n{\n\tatomic64_inc(&rxe->stats_counters[index]);\n}\n\nstatic inline struct rxe_dev *to_rdev(struct ib_device *dev)\n{\n\treturn dev ? container_of(dev, struct rxe_dev, ib_dev) : NULL;\n}\n\nstatic inline struct rxe_ucontext *to_ruc(struct ib_ucontext *uc)\n{\n\treturn uc ? container_of(uc, struct rxe_ucontext, ibuc) : NULL;\n}\n\nstatic inline struct rxe_pd *to_rpd(struct ib_pd *pd)\n{\n\treturn pd ? container_of(pd, struct rxe_pd, ibpd) : NULL;\n}\n\nstatic inline struct rxe_ah *to_rah(struct ib_ah *ah)\n{\n\treturn ah ? container_of(ah, struct rxe_ah, ibah) : NULL;\n}\n\nstatic inline struct rxe_srq *to_rsrq(struct ib_srq *srq)\n{\n\treturn srq ? container_of(srq, struct rxe_srq, ibsrq) : NULL;\n}\n\nstatic inline struct rxe_qp *to_rqp(struct ib_qp *qp)\n{\n\treturn qp ? container_of(qp, struct rxe_qp, ibqp) : NULL;\n}\n\nstatic inline struct rxe_cq *to_rcq(struct ib_cq *cq)\n{\n\treturn cq ? container_of(cq, struct rxe_cq, ibcq) : NULL;\n}\n\nstatic inline struct rxe_mr *to_rmr(struct ib_mr *mr)\n{\n\treturn mr ? container_of(mr, struct rxe_mr, ibmr) : NULL;\n}\n\nstatic inline struct rxe_mw *to_rmw(struct ib_mw *mw)\n{\n\treturn mw ? container_of(mw, struct rxe_mw, ibmw) : NULL;\n}\n\nstatic inline struct rxe_pd *rxe_ah_pd(struct rxe_ah *ah)\n{\n\treturn to_rpd(ah->ibah.pd);\n}\n\nstatic inline struct rxe_pd *mr_pd(struct rxe_mr *mr)\n{\n\treturn to_rpd(mr->ibmr.pd);\n}\n\nstatic inline struct rxe_pd *rxe_mw_pd(struct rxe_mw *mw)\n{\n\treturn to_rpd(mw->ibmw.pd);\n}\n\nint rxe_register_device(struct rxe_dev *rxe, const char *ibdev_name);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}