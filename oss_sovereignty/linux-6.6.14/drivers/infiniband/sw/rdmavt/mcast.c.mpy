{
  "module_name": "mcast.c",
  "hash_id": "69c1414f4381e5f21cbbad0d522027f5e907983c4876e01eafd6757858ee0fda",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rdmavt/mcast.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rculist.h>\n#include <rdma/rdma_vt.h>\n#include <rdma/rdmavt_qp.h>\n\n#include \"mcast.h\"\n\n \nvoid rvt_driver_mcast_init(struct rvt_dev_info *rdi)\n{\n\t \n\tspin_lock_init(&rdi->n_mcast_grps_lock);\n}\n\n \nstatic struct rvt_mcast_qp *rvt_mcast_qp_alloc(struct rvt_qp *qp)\n{\n\tstruct rvt_mcast_qp *mqp;\n\n\tmqp = kmalloc(sizeof(*mqp), GFP_KERNEL);\n\tif (!mqp)\n\t\tgoto bail;\n\n\tmqp->qp = qp;\n\trvt_get_qp(qp);\n\nbail:\n\treturn mqp;\n}\n\nstatic void rvt_mcast_qp_free(struct rvt_mcast_qp *mqp)\n{\n\tstruct rvt_qp *qp = mqp->qp;\n\n\t \n\trvt_put_qp(qp);\n\n\tkfree(mqp);\n}\n\n \nstatic struct rvt_mcast *rvt_mcast_alloc(union ib_gid *mgid, u16 lid)\n{\n\tstruct rvt_mcast *mcast;\n\n\tmcast = kzalloc(sizeof(*mcast), GFP_KERNEL);\n\tif (!mcast)\n\t\tgoto bail;\n\n\tmcast->mcast_addr.mgid = *mgid;\n\tmcast->mcast_addr.lid = lid;\n\n\tINIT_LIST_HEAD(&mcast->qp_list);\n\tinit_waitqueue_head(&mcast->wait);\n\tatomic_set(&mcast->refcount, 0);\n\nbail:\n\treturn mcast;\n}\n\nstatic void rvt_mcast_free(struct rvt_mcast *mcast)\n{\n\tstruct rvt_mcast_qp *p, *tmp;\n\n\tlist_for_each_entry_safe(p, tmp, &mcast->qp_list, list)\n\t\trvt_mcast_qp_free(p);\n\n\tkfree(mcast);\n}\n\n \nstruct rvt_mcast *rvt_mcast_find(struct rvt_ibport *ibp, union ib_gid *mgid,\n\t\t\t\t u16 lid)\n{\n\tstruct rb_node *n;\n\tunsigned long flags;\n\tstruct rvt_mcast *found = NULL;\n\n\tspin_lock_irqsave(&ibp->lock, flags);\n\tn = ibp->mcast_tree.rb_node;\n\twhile (n) {\n\t\tint ret;\n\t\tstruct rvt_mcast *mcast;\n\n\t\tmcast = rb_entry(n, struct rvt_mcast, rb_node);\n\n\t\tret = memcmp(mgid->raw, mcast->mcast_addr.mgid.raw,\n\t\t\t     sizeof(*mgid));\n\t\tif (ret < 0) {\n\t\t\tn = n->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\t \n\t\t\tif (mcast->mcast_addr.lid == lid) {\n\t\t\t\tatomic_inc(&mcast->refcount);\n\t\t\t\tfound = mcast;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ibp->lock, flags);\n\treturn found;\n}\nEXPORT_SYMBOL(rvt_mcast_find);\n\n \nstatic int rvt_mcast_add(struct rvt_dev_info *rdi, struct rvt_ibport *ibp,\n\t\t\t struct rvt_mcast *mcast, struct rvt_mcast_qp *mqp)\n{\n\tstruct rb_node **n = &ibp->mcast_tree.rb_node;\n\tstruct rb_node *pn = NULL;\n\tint ret;\n\n\tspin_lock_irq(&ibp->lock);\n\n\twhile (*n) {\n\t\tstruct rvt_mcast *tmcast;\n\t\tstruct rvt_mcast_qp *p;\n\n\t\tpn = *n;\n\t\ttmcast = rb_entry(pn, struct rvt_mcast, rb_node);\n\n\t\tret = memcmp(mcast->mcast_addr.mgid.raw,\n\t\t\t     tmcast->mcast_addr.mgid.raw,\n\t\t\t     sizeof(mcast->mcast_addr.mgid));\n\t\tif (ret < 0) {\n\t\t\tn = &pn->rb_left;\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tn = &pn->rb_right;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (tmcast->mcast_addr.lid != mcast->mcast_addr.lid) {\n\t\t\tret = EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t \n\t\tlist_for_each_entry_rcu(p, &tmcast->qp_list, list) {\n\t\t\tif (p->qp == mqp->qp) {\n\t\t\t\tret = ESRCH;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tif (tmcast->n_attached ==\n\t\t    rdi->dparms.props.max_mcast_qp_attach) {\n\t\t\tret = ENOMEM;\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttmcast->n_attached++;\n\n\t\tlist_add_tail_rcu(&mqp->list, &tmcast->qp_list);\n\t\tret = EEXIST;\n\t\tgoto bail;\n\t}\n\n\tspin_lock(&rdi->n_mcast_grps_lock);\n\tif (rdi->n_mcast_grps_allocated == rdi->dparms.props.max_mcast_grp) {\n\t\tspin_unlock(&rdi->n_mcast_grps_lock);\n\t\tret = ENOMEM;\n\t\tgoto bail;\n\t}\n\n\trdi->n_mcast_grps_allocated++;\n\tspin_unlock(&rdi->n_mcast_grps_lock);\n\n\tmcast->n_attached++;\n\n\tlist_add_tail_rcu(&mqp->list, &mcast->qp_list);\n\n\tatomic_inc(&mcast->refcount);\n\trb_link_node(&mcast->rb_node, pn, n);\n\trb_insert_color(&mcast->rb_node, &ibp->mcast_tree);\n\n\tret = 0;\n\nbail:\n\tspin_unlock_irq(&ibp->lock);\n\n\treturn ret;\n}\n\n \nint rvt_attach_mcast(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\n{\n\tstruct rvt_qp *qp = ibqp_to_rvtqp(ibqp);\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibqp->device);\n\tstruct rvt_ibport *ibp = rdi->ports[qp->port_num - 1];\n\tstruct rvt_mcast *mcast;\n\tstruct rvt_mcast_qp *mqp;\n\tint ret = -ENOMEM;\n\n\tif (ibqp->qp_num <= 1 || qp->state == IB_QPS_RESET)\n\t\treturn -EINVAL;\n\n\t \n\tmcast = rvt_mcast_alloc(gid, lid);\n\tif (!mcast)\n\t\treturn -ENOMEM;\n\n\tmqp = rvt_mcast_qp_alloc(qp);\n\tif (!mqp)\n\t\tgoto bail_mcast;\n\n\tswitch (rvt_mcast_add(rdi, ibp, mcast, mqp)) {\n\tcase ESRCH:\n\t\t \n\t\tret = 0;\n\t\tgoto bail_mqp;\n\tcase EEXIST:  \n\t\tret = 0;\n\t\tgoto bail_mcast;\n\tcase ENOMEM:\n\t\t \n\t\tret = -ENOMEM;\n\t\tgoto bail_mqp;\n\tcase EINVAL:\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto bail_mqp;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n\nbail_mqp:\n\trvt_mcast_qp_free(mqp);\n\nbail_mcast:\n\trvt_mcast_free(mcast);\n\n\treturn ret;\n}\n\n \nint rvt_detach_mcast(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)\n{\n\tstruct rvt_qp *qp = ibqp_to_rvtqp(ibqp);\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibqp->device);\n\tstruct rvt_ibport *ibp = rdi->ports[qp->port_num - 1];\n\tstruct rvt_mcast *mcast = NULL;\n\tstruct rvt_mcast_qp *p, *tmp, *delp = NULL;\n\tstruct rb_node *n;\n\tint last = 0;\n\tint ret = 0;\n\n\tif (ibqp->qp_num <= 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irq(&ibp->lock);\n\n\t \n\tn = ibp->mcast_tree.rb_node;\n\twhile (1) {\n\t\tif (!n) {\n\t\t\tspin_unlock_irq(&ibp->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmcast = rb_entry(n, struct rvt_mcast, rb_node);\n\t\tret = memcmp(gid->raw, mcast->mcast_addr.mgid.raw,\n\t\t\t     sizeof(*gid));\n\t\tif (ret < 0) {\n\t\t\tn = n->rb_left;\n\t\t} else if (ret > 0) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\t \n\t\t\tif (mcast->mcast_addr.lid != lid) {\n\t\t\t\tspin_unlock_irq(&ibp->lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry_safe(p, tmp, &mcast->qp_list, list) {\n\t\tif (p->qp != qp)\n\t\t\tcontinue;\n\t\t \n\t\tlist_del_rcu(&p->list);\n\t\tmcast->n_attached--;\n\t\tdelp = p;\n\n\t\t \n\t\tif (list_empty(&mcast->qp_list)) {\n\t\t\trb_erase(&mcast->rb_node, &ibp->mcast_tree);\n\t\t\tlast = 1;\n\t\t}\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&ibp->lock);\n\t \n\tif (!delp)\n\t\treturn -EINVAL;\n\n\t \n\twait_event(mcast->wait, atomic_read(&mcast->refcount) <= 1);\n\trvt_mcast_qp_free(delp);\n\n\tif (last) {\n\t\tatomic_dec(&mcast->refcount);\n\t\twait_event(mcast->wait, !atomic_read(&mcast->refcount));\n\t\trvt_mcast_free(mcast);\n\t\tspin_lock_irq(&rdi->n_mcast_grps_lock);\n\t\trdi->n_mcast_grps_allocated--;\n\t\tspin_unlock_irq(&rdi->n_mcast_grps_lock);\n\t}\n\n\treturn 0;\n}\n\n \nint rvt_mcast_tree_empty(struct rvt_dev_info *rdi)\n{\n\tint i;\n\tint in_use = 0;\n\n\tfor (i = 0; i < rdi->dparms.nports; i++)\n\t\tif (rdi->ports[i]->mcast_tree.rb_node)\n\t\t\tin_use++;\n\treturn in_use;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}