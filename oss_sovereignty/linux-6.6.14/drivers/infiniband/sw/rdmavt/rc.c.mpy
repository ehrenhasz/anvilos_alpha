{
  "module_name": "rc.c",
  "hash_id": "132e0bfbf516015f010849d60cd0ce99b6bd7c9fe161d0cde62acb04bb0ab0c7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rdmavt/rc.c",
  "human_readable_source": "\n \n\n#include <rdma/rdmavt_qp.h>\n#include <rdma/ib_hdrs.h>\n\n \nstatic const u16 credit_table[31] = {\n\t0,                       \n\t1,                       \n\t2,                       \n\t3,                       \n\t4,                       \n\t6,                       \n\t8,                       \n\t12,                      \n\t16,                      \n\t24,                      \n\t32,                      \n\t48,                      \n\t64,                      \n\t96,                      \n\t128,                     \n\t192,                     \n\t256,                     \n\t384,                     \n\t512,                     \n\t768,                     \n\t1024,                    \n\t1536,                    \n\t2048,                    \n\t3072,                    \n\t4096,                    \n\t6144,                    \n\t8192,                    \n\t12288,                   \n\t16384,                   \n\t24576,                   \n\t32768                    \n};\n\n \n__be32 rvt_compute_aeth(struct rvt_qp *qp)\n{\n\tu32 aeth = qp->r_msn & IB_MSN_MASK;\n\n\tif (qp->ibqp.srq) {\n\t\t \n\t\taeth |= IB_AETH_CREDIT_INVAL << IB_AETH_CREDIT_SHIFT;\n\t} else {\n\t\tu32 min, max, x;\n\t\tu32 credits;\n\t\tu32 head;\n\t\tu32 tail;\n\n\t\tcredits = READ_ONCE(qp->r_rq.kwq->count);\n\t\tif (credits == 0) {\n\t\t\t \n\t\t\tif (qp->ip) {\n\t\t\t\thead = RDMA_READ_UAPI_ATOMIC(qp->r_rq.wq->head);\n\t\t\t\ttail = RDMA_READ_UAPI_ATOMIC(qp->r_rq.wq->tail);\n\t\t\t} else {\n\t\t\t\thead = READ_ONCE(qp->r_rq.kwq->head);\n\t\t\t\ttail = READ_ONCE(qp->r_rq.kwq->tail);\n\t\t\t}\n\t\t\tif (head >= qp->r_rq.size)\n\t\t\t\thead = 0;\n\t\t\tif (tail >= qp->r_rq.size)\n\t\t\t\ttail = 0;\n\t\t\t \n\t\t\tcredits = rvt_get_rq_count(&qp->r_rq, head, tail);\n\t\t}\n\t\t \n\t\tmin = 0;\n\t\tmax = 31;\n\t\tfor (;;) {\n\t\t\tx = (min + max) / 2;\n\t\t\tif (credit_table[x] == credits)\n\t\t\t\tbreak;\n\t\t\tif (credit_table[x] > credits) {\n\t\t\t\tmax = x;\n\t\t\t} else {\n\t\t\t\tif (min == x)\n\t\t\t\t\tbreak;\n\t\t\t\tmin = x;\n\t\t\t}\n\t\t}\n\t\taeth |= x << IB_AETH_CREDIT_SHIFT;\n\t}\n\treturn cpu_to_be32(aeth);\n}\nEXPORT_SYMBOL(rvt_compute_aeth);\n\n \nvoid rvt_get_credit(struct rvt_qp *qp, u32 aeth)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(qp->ibqp.device);\n\tu32 credit = (aeth >> IB_AETH_CREDIT_SHIFT) & IB_AETH_CREDIT_MASK;\n\n\tlockdep_assert_held(&qp->s_lock);\n\t \n\tif (credit == IB_AETH_CREDIT_INVAL) {\n\t\tif (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT)) {\n\t\t\tqp->s_flags |= RVT_S_UNLIMITED_CREDIT;\n\t\t\tif (qp->s_flags & RVT_S_WAIT_SSN_CREDIT) {\n\t\t\t\tqp->s_flags &= ~RVT_S_WAIT_SSN_CREDIT;\n\t\t\t\trdi->driver_f.schedule_send(qp);\n\t\t\t}\n\t\t}\n\t} else if (!(qp->s_flags & RVT_S_UNLIMITED_CREDIT)) {\n\t\t \n\t\tcredit = (aeth + credit_table[credit]) & IB_MSN_MASK;\n\t\tif (rvt_cmp_msn(credit, qp->s_lsn) > 0) {\n\t\t\tqp->s_lsn = credit;\n\t\t\tif (qp->s_flags & RVT_S_WAIT_SSN_CREDIT) {\n\t\t\t\tqp->s_flags &= ~RVT_S_WAIT_SSN_CREDIT;\n\t\t\t\trdi->driver_f.schedule_send(qp);\n\t\t\t}\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rvt_get_credit);\n\n \nu32 rvt_restart_sge(struct rvt_sge_state *ss, struct rvt_swqe *wqe, u32 len)\n{\n\tss->sge = wqe->sg_list[0];\n\tss->sg_list = wqe->sg_list + 1;\n\tss->num_sge = wqe->wr.num_sge;\n\tss->total_len = wqe->length;\n\trvt_skip_sge(ss, len, false);\n\treturn wqe->length - len;\n}\nEXPORT_SYMBOL(rvt_restart_sge);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}