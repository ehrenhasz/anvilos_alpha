{
  "module_name": "mmap.c",
  "hash_id": "f96dcba0d89b73b0db955da2a7fea4e57e44ecb2fa09b5fb9a9a0747fb4d81cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rdmavt/mmap.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <rdma/uverbs_ioctl.h>\n#include \"mmap.h\"\n\n \nvoid rvt_mmap_init(struct rvt_dev_info *rdi)\n{\n\tINIT_LIST_HEAD(&rdi->pending_mmaps);\n\tspin_lock_init(&rdi->pending_lock);\n\trdi->mmap_offset = PAGE_SIZE;\n\tspin_lock_init(&rdi->mmap_offset_lock);\n}\n\n \nvoid rvt_release_mmap_info(struct kref *ref)\n{\n\tstruct rvt_mmap_info *ip =\n\t\tcontainer_of(ref, struct rvt_mmap_info, ref);\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ip->context->device);\n\n\tspin_lock_irq(&rdi->pending_lock);\n\tlist_del(&ip->pending_mmaps);\n\tspin_unlock_irq(&rdi->pending_lock);\n\n\tvfree(ip->obj);\n\tkfree(ip);\n}\n\nstatic void rvt_vma_open(struct vm_area_struct *vma)\n{\n\tstruct rvt_mmap_info *ip = vma->vm_private_data;\n\n\tkref_get(&ip->ref);\n}\n\nstatic void rvt_vma_close(struct vm_area_struct *vma)\n{\n\tstruct rvt_mmap_info *ip = vma->vm_private_data;\n\n\tkref_put(&ip->ref, rvt_release_mmap_info);\n}\n\nstatic const struct vm_operations_struct rvt_vm_ops = {\n\t.open = rvt_vma_open,\n\t.close = rvt_vma_close,\n};\n\n \nint rvt_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(context->device);\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tunsigned long size = vma->vm_end - vma->vm_start;\n\tstruct rvt_mmap_info *ip, *pp;\n\tint ret = -EINVAL;\n\n\t \n\tspin_lock_irq(&rdi->pending_lock);\n\tlist_for_each_entry_safe(ip, pp, &rdi->pending_mmaps,\n\t\t\t\t pending_mmaps) {\n\t\t \n\t\tif (context != ip->context || (__u64)offset != ip->offset)\n\t\t\tcontinue;\n\t\t \n\t\tif (size > ip->size)\n\t\t\tbreak;\n\n\t\tlist_del_init(&ip->pending_mmaps);\n\t\tspin_unlock_irq(&rdi->pending_lock);\n\n\t\tret = remap_vmalloc_range(vma, ip->obj, 0);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tvma->vm_ops = &rvt_vm_ops;\n\t\tvma->vm_private_data = ip;\n\t\trvt_vma_open(vma);\n\t\tgoto done;\n\t}\n\tspin_unlock_irq(&rdi->pending_lock);\ndone:\n\treturn ret;\n}\n\n \nstruct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi, u32 size,\n\t\t\t\t\t   struct ib_udata *udata, void *obj)\n{\n\tstruct rvt_mmap_info *ip;\n\n\tif (!udata)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tip = kmalloc_node(sizeof(*ip), GFP_KERNEL, rdi->dparms.node);\n\tif (!ip)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsize = PAGE_ALIGN(size);\n\n\tspin_lock_irq(&rdi->mmap_offset_lock);\n\tif (rdi->mmap_offset == 0)\n\t\trdi->mmap_offset = ALIGN(PAGE_SIZE, SHMLBA);\n\tip->offset = rdi->mmap_offset;\n\trdi->mmap_offset += ALIGN(size, SHMLBA);\n\tspin_unlock_irq(&rdi->mmap_offset_lock);\n\n\tINIT_LIST_HEAD(&ip->pending_mmaps);\n\tip->size = size;\n\tip->context =\n\t\tcontainer_of(udata, struct uverbs_attr_bundle, driver_udata)\n\t\t\t->context;\n\tip->obj = obj;\n\tkref_init(&ip->ref);\n\n\treturn ip;\n}\n\n \nvoid rvt_update_mmap_info(struct rvt_dev_info *rdi, struct rvt_mmap_info *ip,\n\t\t\t  u32 size, void *obj)\n{\n\tsize = PAGE_ALIGN(size);\n\n\tspin_lock_irq(&rdi->mmap_offset_lock);\n\tif (rdi->mmap_offset == 0)\n\t\trdi->mmap_offset = PAGE_SIZE;\n\tip->offset = rdi->mmap_offset;\n\trdi->mmap_offset += size;\n\tspin_unlock_irq(&rdi->mmap_offset_lock);\n\n\tip->size = size;\n\tip->obj = obj;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}