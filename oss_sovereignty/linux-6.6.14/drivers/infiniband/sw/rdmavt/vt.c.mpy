{
  "module_name": "vt.c",
  "hash_id": "e1eaf36fe0286c5ddf536c034ab565ec3a0d337a6c478ae32024a7007a11656a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/sw/rdmavt/vt.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/dma-mapping.h>\n#include \"vt.h\"\n#include \"cq.h\"\n#include \"trace.h\"\n\n#define RVT_UVERBS_ABI_VERSION 2\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"RDMA Verbs Transport Library\");\n\nstatic int __init rvt_init(void)\n{\n\tint ret = rvt_driver_cq_init();\n\n\tif (ret)\n\t\tpr_err(\"Error in driver CQ init.\\n\");\n\n\treturn ret;\n}\nmodule_init(rvt_init);\n\nstatic void __exit rvt_cleanup(void)\n{\n\trvt_cq_exit();\n}\nmodule_exit(rvt_cleanup);\n\n \nstruct rvt_dev_info *rvt_alloc_device(size_t size, int nports)\n{\n\tstruct rvt_dev_info *rdi;\n\n\trdi = container_of(_ib_alloc_device(size), struct rvt_dev_info, ibdev);\n\tif (!rdi)\n\t\treturn rdi;\n\n\trdi->ports = kcalloc(nports, sizeof(*rdi->ports), GFP_KERNEL);\n\tif (!rdi->ports)\n\t\tib_dealloc_device(&rdi->ibdev);\n\n\treturn rdi;\n}\nEXPORT_SYMBOL(rvt_alloc_device);\n\n \nvoid rvt_dealloc_device(struct rvt_dev_info *rdi)\n{\n\tkfree(rdi->ports);\n\tib_dealloc_device(&rdi->ibdev);\n}\nEXPORT_SYMBOL(rvt_dealloc_device);\n\nstatic int rvt_query_device(struct ib_device *ibdev,\n\t\t\t    struct ib_device_attr *props,\n\t\t\t    struct ib_udata *uhw)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\n\tif (uhw->inlen || uhw->outlen)\n\t\treturn -EINVAL;\n\t \n\t*props = rdi->dparms.props;\n\treturn 0;\n}\n\nstatic int rvt_get_numa_node(struct ib_device *ibdev)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\n\treturn rdi->dparms.node;\n}\n\nstatic int rvt_modify_device(struct ib_device *device,\n\t\t\t     int device_modify_mask,\n\t\t\t     struct ib_device_modify *device_modify)\n{\n\t \n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int rvt_query_port(struct ib_device *ibdev, u32 port_num,\n\t\t\t  struct ib_port_attr *props)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\tstruct rvt_ibport *rvp;\n\tu32 port_index = ibport_num_to_idx(ibdev, port_num);\n\n\trvp = rdi->ports[port_index];\n\t \n\tprops->sm_lid = rvp->sm_lid;\n\tprops->sm_sl = rvp->sm_sl;\n\tprops->port_cap_flags = rvp->port_cap_flags;\n\tprops->max_msg_sz = 0x80000000;\n\tprops->pkey_tbl_len = rvt_get_npkeys(rdi);\n\tprops->bad_pkey_cntr = rvp->pkey_violations;\n\tprops->qkey_viol_cntr = rvp->qkey_violations;\n\tprops->subnet_timeout = rvp->subnet_timeout;\n\tprops->init_type_reply = 0;\n\n\t \n\treturn rdi->driver_f.query_port_state(rdi, port_num, props);\n}\n\n \nstatic int rvt_modify_port(struct ib_device *ibdev, u32 port_num,\n\t\t\t   int port_modify_mask, struct ib_port_modify *props)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\tstruct rvt_ibport *rvp;\n\tint ret = 0;\n\tu32 port_index = ibport_num_to_idx(ibdev, port_num);\n\n\trvp = rdi->ports[port_index];\n\tif (port_modify_mask & IB_PORT_OPA_MASK_CHG) {\n\t\trvp->port_cap3_flags |= props->set_port_cap_mask;\n\t\trvp->port_cap3_flags &= ~props->clr_port_cap_mask;\n\t} else {\n\t\trvp->port_cap_flags |= props->set_port_cap_mask;\n\t\trvp->port_cap_flags &= ~props->clr_port_cap_mask;\n\t}\n\n\tif (props->set_port_cap_mask || props->clr_port_cap_mask)\n\t\trdi->driver_f.cap_mask_chg(rdi, port_num);\n\tif (port_modify_mask & IB_PORT_SHUTDOWN)\n\t\tret = rdi->driver_f.shut_down_port(rdi, port_num);\n\tif (port_modify_mask & IB_PORT_RESET_QKEY_CNTR)\n\t\trvp->qkey_violations = 0;\n\n\treturn ret;\n}\n\n \nstatic int rvt_query_pkey(struct ib_device *ibdev, u32 port_num, u16 index,\n\t\t\t  u16 *pkey)\n{\n\t \n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\tu32 port_index;\n\n\tport_index = ibport_num_to_idx(ibdev, port_num);\n\n\tif (index >= rvt_get_npkeys(rdi))\n\t\treturn -EINVAL;\n\n\t*pkey = rvt_get_pkey(rdi, port_index, index);\n\treturn 0;\n}\n\n \nstatic int rvt_query_gid(struct ib_device *ibdev, u32 port_num,\n\t\t\t int guid_index, union ib_gid *gid)\n{\n\tstruct rvt_dev_info *rdi;\n\tstruct rvt_ibport *rvp;\n\tu32 port_index;\n\n\t \n\tport_index = ibport_num_to_idx(ibdev, port_num);\n\n\trdi = ib_to_rvt(ibdev);\n\trvp = rdi->ports[port_index];\n\n\tgid->global.subnet_prefix = rvp->gid_prefix;\n\n\treturn rdi->driver_f.get_guid_be(rdi, rvp, guid_index,\n\t\t\t\t\t &gid->global.interface_id);\n}\n\n \nstatic int rvt_alloc_ucontext(struct ib_ucontext *uctx, struct ib_udata *udata)\n{\n\treturn 0;\n}\n\n \nstatic void rvt_dealloc_ucontext(struct ib_ucontext *context)\n{\n\treturn;\n}\n\nstatic int rvt_get_port_immutable(struct ib_device *ibdev, u32 port_num,\n\t\t\t\t  struct ib_port_immutable *immutable)\n{\n\tstruct rvt_dev_info *rdi = ib_to_rvt(ibdev);\n\tstruct ib_port_attr attr;\n\tint err;\n\n\timmutable->core_cap_flags = rdi->dparms.core_cap_flags;\n\n\terr = ib_query_port(ibdev, port_num, &attr);\n\tif (err)\n\t\treturn err;\n\n\timmutable->pkey_tbl_len = attr.pkey_tbl_len;\n\timmutable->gid_tbl_len = attr.gid_tbl_len;\n\timmutable->max_mad_size = rdi->dparms.max_mad_size;\n\n\treturn 0;\n}\n\nenum {\n\tMISC,\n\tQUERY_DEVICE,\n\tMODIFY_DEVICE,\n\tQUERY_PORT,\n\tMODIFY_PORT,\n\tQUERY_PKEY,\n\tQUERY_GID,\n\tALLOC_UCONTEXT,\n\tDEALLOC_UCONTEXT,\n\tGET_PORT_IMMUTABLE,\n\tCREATE_QP,\n\tMODIFY_QP,\n\tDESTROY_QP,\n\tQUERY_QP,\n\tPOST_SEND,\n\tPOST_RECV,\n\tPOST_SRQ_RECV,\n\tCREATE_AH,\n\tDESTROY_AH,\n\tMODIFY_AH,\n\tQUERY_AH,\n\tCREATE_SRQ,\n\tMODIFY_SRQ,\n\tDESTROY_SRQ,\n\tQUERY_SRQ,\n\tATTACH_MCAST,\n\tDETACH_MCAST,\n\tGET_DMA_MR,\n\tREG_USER_MR,\n\tDEREG_MR,\n\tALLOC_MR,\n\tMAP_MR_SG,\n\tALLOC_FMR,\n\tMAP_PHYS_FMR,\n\tUNMAP_FMR,\n\tDEALLOC_FMR,\n\tMMAP,\n\tCREATE_CQ,\n\tDESTROY_CQ,\n\tPOLL_CQ,\n\tREQ_NOTFIY_CQ,\n\tRESIZE_CQ,\n\tALLOC_PD,\n\tDEALLOC_PD,\n\t_VERB_IDX_MAX  \n};\n\nstatic const struct ib_device_ops rvt_dev_ops = {\n\t.uverbs_abi_ver = RVT_UVERBS_ABI_VERSION,\n\n\t.alloc_mr = rvt_alloc_mr,\n\t.alloc_pd = rvt_alloc_pd,\n\t.alloc_ucontext = rvt_alloc_ucontext,\n\t.attach_mcast = rvt_attach_mcast,\n\t.create_ah = rvt_create_ah,\n\t.create_cq = rvt_create_cq,\n\t.create_qp = rvt_create_qp,\n\t.create_srq = rvt_create_srq,\n\t.create_user_ah = rvt_create_ah,\n\t.dealloc_pd = rvt_dealloc_pd,\n\t.dealloc_ucontext = rvt_dealloc_ucontext,\n\t.dereg_mr = rvt_dereg_mr,\n\t.destroy_ah = rvt_destroy_ah,\n\t.destroy_cq = rvt_destroy_cq,\n\t.destroy_qp = rvt_destroy_qp,\n\t.destroy_srq = rvt_destroy_srq,\n\t.detach_mcast = rvt_detach_mcast,\n\t.get_dma_mr = rvt_get_dma_mr,\n\t.get_numa_node = rvt_get_numa_node,\n\t.get_port_immutable = rvt_get_port_immutable,\n\t.map_mr_sg = rvt_map_mr_sg,\n\t.mmap = rvt_mmap,\n\t.modify_ah = rvt_modify_ah,\n\t.modify_device = rvt_modify_device,\n\t.modify_port = rvt_modify_port,\n\t.modify_qp = rvt_modify_qp,\n\t.modify_srq = rvt_modify_srq,\n\t.poll_cq = rvt_poll_cq,\n\t.post_recv = rvt_post_recv,\n\t.post_send = rvt_post_send,\n\t.post_srq_recv = rvt_post_srq_recv,\n\t.query_ah = rvt_query_ah,\n\t.query_device = rvt_query_device,\n\t.query_gid = rvt_query_gid,\n\t.query_pkey = rvt_query_pkey,\n\t.query_port = rvt_query_port,\n\t.query_qp = rvt_query_qp,\n\t.query_srq = rvt_query_srq,\n\t.reg_user_mr = rvt_reg_user_mr,\n\t.req_notify_cq = rvt_req_notify_cq,\n\t.resize_cq = rvt_resize_cq,\n\n\tINIT_RDMA_OBJ_SIZE(ib_ah, rvt_ah, ibah),\n\tINIT_RDMA_OBJ_SIZE(ib_cq, rvt_cq, ibcq),\n\tINIT_RDMA_OBJ_SIZE(ib_pd, rvt_pd, ibpd),\n\tINIT_RDMA_OBJ_SIZE(ib_qp, rvt_qp, ibqp),\n\tINIT_RDMA_OBJ_SIZE(ib_srq, rvt_srq, ibsrq),\n\tINIT_RDMA_OBJ_SIZE(ib_ucontext, rvt_ucontext, ibucontext),\n};\n\nstatic noinline int check_support(struct rvt_dev_info *rdi, int verb)\n{\n\tswitch (verb) {\n\tcase MISC:\n\t\t \n\t\tif ((!rdi->ibdev.ops.port_groups) ||\n\t\t    (!rdi->driver_f.get_pci_dev))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase MODIFY_DEVICE:\n\t\t \n\t\tif (!rdi->ibdev.ops.modify_device)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tcase QUERY_PORT:\n\t\tif (!rdi->ibdev.ops.query_port)\n\t\t\tif (!rdi->driver_f.query_port_state)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase MODIFY_PORT:\n\t\tif (!rdi->ibdev.ops.modify_port)\n\t\t\tif (!rdi->driver_f.cap_mask_chg ||\n\t\t\t    !rdi->driver_f.shut_down_port)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase QUERY_GID:\n\t\tif (!rdi->ibdev.ops.query_gid)\n\t\t\tif (!rdi->driver_f.get_guid_be)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase CREATE_QP:\n\t\tif (!rdi->ibdev.ops.create_qp)\n\t\t\tif (!rdi->driver_f.qp_priv_alloc ||\n\t\t\t    !rdi->driver_f.qp_priv_free ||\n\t\t\t    !rdi->driver_f.notify_qp_reset ||\n\t\t\t    !rdi->driver_f.flush_qp_waiters ||\n\t\t\t    !rdi->driver_f.stop_send_queue ||\n\t\t\t    !rdi->driver_f.quiesce_qp)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase MODIFY_QP:\n\t\tif (!rdi->ibdev.ops.modify_qp)\n\t\t\tif (!rdi->driver_f.notify_qp_reset ||\n\t\t\t    !rdi->driver_f.schedule_send ||\n\t\t\t    !rdi->driver_f.get_pmtu_from_attr ||\n\t\t\t    !rdi->driver_f.flush_qp_waiters ||\n\t\t\t    !rdi->driver_f.stop_send_queue ||\n\t\t\t    !rdi->driver_f.quiesce_qp ||\n\t\t\t    !rdi->driver_f.notify_error_qp ||\n\t\t\t    !rdi->driver_f.mtu_from_qp ||\n\t\t\t    !rdi->driver_f.mtu_to_path_mtu)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase DESTROY_QP:\n\t\tif (!rdi->ibdev.ops.destroy_qp)\n\t\t\tif (!rdi->driver_f.qp_priv_free ||\n\t\t\t    !rdi->driver_f.notify_qp_reset ||\n\t\t\t    !rdi->driver_f.flush_qp_waiters ||\n\t\t\t    !rdi->driver_f.stop_send_queue ||\n\t\t\t    !rdi->driver_f.quiesce_qp)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase POST_SEND:\n\t\tif (!rdi->ibdev.ops.post_send)\n\t\t\tif (!rdi->driver_f.schedule_send ||\n\t\t\t    !rdi->driver_f.do_send ||\n\t\t\t    !rdi->post_parms)\n\t\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\t}\n\n\treturn 0;\n}\n\n \nint rvt_register_device(struct rvt_dev_info *rdi)\n{\n\tint ret = 0, i;\n\n\tif (!rdi)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < _VERB_IDX_MAX; i++)\n\t\tif (check_support(rdi, i)) {\n\t\t\tpr_err(\"Driver support req not met at %d\\n\", i);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\tib_set_device_ops(&rdi->ibdev, &rvt_dev_ops);\n\n\t \n\ttrace_rvt_dbg(rdi, \"Driver attempting registration\");\n\trvt_mmap_init(rdi);\n\n\t \n\tret = rvt_driver_qp_init(rdi);\n\tif (ret) {\n\t\tpr_err(\"Error in driver QP init.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_init(&rdi->n_ahs_lock);\n\trdi->n_ahs_allocated = 0;\n\n\t \n\trvt_driver_srq_init(rdi);\n\n\t \n\trvt_driver_mcast_init(rdi);\n\n\t \n\tret = rvt_driver_mr_init(rdi);\n\tif (ret) {\n\t\tpr_err(\"Error in driver MR init.\\n\");\n\t\tgoto bail_no_mr;\n\t}\n\n\t \n\tret = rvt_wss_init(rdi);\n\tif (ret) {\n\t\trvt_pr_err(rdi, \"Error in WSS init.\\n\");\n\t\tgoto bail_mr;\n\t}\n\n\t \n\tspin_lock_init(&rdi->n_cqs_lock);\n\n\t \n\tspin_lock_init(&rdi->n_pds_lock);\n\trdi->n_pds_allocated = 0;\n\n\t \n\trdi->ibdev.uverbs_cmd_mask |=\n\t\t(1ull << IB_USER_VERBS_CMD_POLL_CQ)             |\n\t\t(1ull << IB_USER_VERBS_CMD_REQ_NOTIFY_CQ)       |\n\t\t(1ull << IB_USER_VERBS_CMD_POST_SEND)           |\n\t\t(1ull << IB_USER_VERBS_CMD_POST_RECV)           |\n\t\t(1ull << IB_USER_VERBS_CMD_POST_SRQ_RECV);\n\trdi->ibdev.node_type = RDMA_NODE_IB_CA;\n\tif (!rdi->ibdev.num_comp_vectors)\n\t\trdi->ibdev.num_comp_vectors = 1;\n\n\t \n\tret = ib_register_device(&rdi->ibdev, dev_name(&rdi->ibdev.dev), NULL);\n\tif (ret) {\n\t\trvt_pr_err(rdi, \"Failed to register driver with ib core.\\n\");\n\t\tgoto bail_wss;\n\t}\n\n\trvt_create_mad_agents(rdi);\n\n\trvt_pr_info(rdi, \"Registration with rdmavt done.\\n\");\n\treturn ret;\n\nbail_wss:\n\trvt_wss_exit(rdi);\nbail_mr:\n\trvt_mr_exit(rdi);\n\nbail_no_mr:\n\trvt_qp_exit(rdi);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rvt_register_device);\n\n \nvoid rvt_unregister_device(struct rvt_dev_info *rdi)\n{\n\ttrace_rvt_dbg(rdi, \"Driver is unregistering.\");\n\tif (!rdi)\n\t\treturn;\n\n\trvt_free_mad_agents(rdi);\n\n\tib_unregister_device(&rdi->ibdev);\n\trvt_wss_exit(rdi);\n\trvt_mr_exit(rdi);\n\trvt_qp_exit(rdi);\n}\nEXPORT_SYMBOL(rvt_unregister_device);\n\n \nint rvt_init_port(struct rvt_dev_info *rdi, struct rvt_ibport *port,\n\t\t  int port_index, u16 *pkey_table)\n{\n\n\trdi->ports[port_index] = port;\n\trdi->ports[port_index]->pkey_table = pkey_table;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rvt_init_port);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}