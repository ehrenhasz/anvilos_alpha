{
  "module_name": "umem_dmabuf.c",
  "hash_id": "60172fc5238e56bdb90881d9d6ad8044c89ac32a91b4c4af949117722aca853a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/umem_dmabuf.c",
  "human_readable_source": "\n \n\n#include <linux/dma-buf.h>\n#include <linux/dma-resv.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n\n#include \"uverbs.h\"\n\nMODULE_IMPORT_NS(DMA_BUF);\n\nint ib_umem_dmabuf_map_pages(struct ib_umem_dmabuf *umem_dmabuf)\n{\n\tstruct sg_table *sgt;\n\tstruct scatterlist *sg;\n\tunsigned long start, end, cur = 0;\n\tunsigned int nmap = 0;\n\tlong ret;\n\tint i;\n\n\tdma_resv_assert_held(umem_dmabuf->attach->dmabuf->resv);\n\n\tif (umem_dmabuf->sgt)\n\t\tgoto wait_fence;\n\n\tsgt = dma_buf_map_attachment(umem_dmabuf->attach,\n\t\t\t\t     DMA_BIDIRECTIONAL);\n\tif (IS_ERR(sgt))\n\t\treturn PTR_ERR(sgt);\n\n\t \n\n\tstart = ALIGN_DOWN(umem_dmabuf->umem.address, PAGE_SIZE);\n\tend = ALIGN(umem_dmabuf->umem.address + umem_dmabuf->umem.length,\n\t\t    PAGE_SIZE);\n\tfor_each_sgtable_dma_sg(sgt, sg, i) {\n\t\tif (start < cur + sg_dma_len(sg) && cur < end)\n\t\t\tnmap++;\n\t\tif (cur <= start && start < cur + sg_dma_len(sg)) {\n\t\t\tunsigned long offset = start - cur;\n\n\t\t\tumem_dmabuf->first_sg = sg;\n\t\t\tumem_dmabuf->first_sg_offset = offset;\n\t\t\tsg_dma_address(sg) += offset;\n\t\t\tsg_dma_len(sg) -= offset;\n\t\t\tcur += offset;\n\t\t}\n\t\tif (cur < end && end <= cur + sg_dma_len(sg)) {\n\t\t\tunsigned long trim = cur + sg_dma_len(sg) - end;\n\n\t\t\tumem_dmabuf->last_sg = sg;\n\t\t\tumem_dmabuf->last_sg_trim = trim;\n\t\t\tsg_dma_len(sg) -= trim;\n\t\t\tbreak;\n\t\t}\n\t\tcur += sg_dma_len(sg);\n\t}\n\n\tumem_dmabuf->umem.sgt_append.sgt.sgl = umem_dmabuf->first_sg;\n\tumem_dmabuf->umem.sgt_append.sgt.nents = nmap;\n\tumem_dmabuf->sgt = sgt;\n\nwait_fence:\n\t \n\tret = dma_resv_wait_timeout(umem_dmabuf->attach->dmabuf->resv,\n\t\t\t\t     DMA_RESV_USAGE_KERNEL,\n\t\t\t\t     false, MAX_SCHEDULE_TIMEOUT);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\nEXPORT_SYMBOL(ib_umem_dmabuf_map_pages);\n\nvoid ib_umem_dmabuf_unmap_pages(struct ib_umem_dmabuf *umem_dmabuf)\n{\n\tdma_resv_assert_held(umem_dmabuf->attach->dmabuf->resv);\n\n\tif (!umem_dmabuf->sgt)\n\t\treturn;\n\n\t \n\tif (umem_dmabuf->first_sg) {\n\t\tsg_dma_address(umem_dmabuf->first_sg) -=\n\t\t\tumem_dmabuf->first_sg_offset;\n\t\tsg_dma_len(umem_dmabuf->first_sg) +=\n\t\t\tumem_dmabuf->first_sg_offset;\n\t\tumem_dmabuf->first_sg = NULL;\n\t\tumem_dmabuf->first_sg_offset = 0;\n\t}\n\tif (umem_dmabuf->last_sg) {\n\t\tsg_dma_len(umem_dmabuf->last_sg) +=\n\t\t\tumem_dmabuf->last_sg_trim;\n\t\tumem_dmabuf->last_sg = NULL;\n\t\tumem_dmabuf->last_sg_trim = 0;\n\t}\n\n\tdma_buf_unmap_attachment(umem_dmabuf->attach, umem_dmabuf->sgt,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\n\tumem_dmabuf->sgt = NULL;\n}\nEXPORT_SYMBOL(ib_umem_dmabuf_unmap_pages);\n\nstruct ib_umem_dmabuf *ib_umem_dmabuf_get(struct ib_device *device,\n\t\t\t\t\t  unsigned long offset, size_t size,\n\t\t\t\t\t  int fd, int access,\n\t\t\t\t\t  const struct dma_buf_attach_ops *ops)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct ib_umem_dmabuf *umem_dmabuf;\n\tstruct ib_umem *umem;\n\tunsigned long end;\n\tstruct ib_umem_dmabuf *ret = ERR_PTR(-EINVAL);\n\n\tif (check_add_overflow(offset, (unsigned long)size, &end))\n\t\treturn ret;\n\n\tif (unlikely(!ops || !ops->move_notify))\n\t\treturn ret;\n\n\tdmabuf = dma_buf_get(fd);\n\tif (IS_ERR(dmabuf))\n\t\treturn ERR_CAST(dmabuf);\n\n\tif (dmabuf->size < end)\n\t\tgoto out_release_dmabuf;\n\n\tumem_dmabuf = kzalloc(sizeof(*umem_dmabuf), GFP_KERNEL);\n\tif (!umem_dmabuf) {\n\t\tret = ERR_PTR(-ENOMEM);\n\t\tgoto out_release_dmabuf;\n\t}\n\n\tumem = &umem_dmabuf->umem;\n\tumem->ibdev = device;\n\tumem->length = size;\n\tumem->address = offset;\n\tumem->writable = ib_access_writable(access);\n\tumem->is_dmabuf = 1;\n\n\tif (!ib_umem_num_pages(umem))\n\t\tgoto out_free_umem;\n\n\tumem_dmabuf->attach = dma_buf_dynamic_attach(\n\t\t\t\t\tdmabuf,\n\t\t\t\t\tdevice->dma_device,\n\t\t\t\t\tops,\n\t\t\t\t\tumem_dmabuf);\n\tif (IS_ERR(umem_dmabuf->attach)) {\n\t\tret = ERR_CAST(umem_dmabuf->attach);\n\t\tgoto out_free_umem;\n\t}\n\treturn umem_dmabuf;\n\nout_free_umem:\n\tkfree(umem_dmabuf);\n\nout_release_dmabuf:\n\tdma_buf_put(dmabuf);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_umem_dmabuf_get);\n\nstatic void\nib_umem_dmabuf_unsupported_move_notify(struct dma_buf_attachment *attach)\n{\n\tstruct ib_umem_dmabuf *umem_dmabuf = attach->importer_priv;\n\n\tibdev_warn_ratelimited(umem_dmabuf->umem.ibdev,\n\t\t\t       \"Invalidate callback should not be called when memory is pinned\\n\");\n}\n\nstatic struct dma_buf_attach_ops ib_umem_dmabuf_attach_pinned_ops = {\n\t.allow_peer2peer = true,\n\t.move_notify = ib_umem_dmabuf_unsupported_move_notify,\n};\n\nstruct ib_umem_dmabuf *ib_umem_dmabuf_get_pinned(struct ib_device *device,\n\t\t\t\t\t\t unsigned long offset,\n\t\t\t\t\t\t size_t size, int fd,\n\t\t\t\t\t\t int access)\n{\n\tstruct ib_umem_dmabuf *umem_dmabuf;\n\tint err;\n\n\tumem_dmabuf = ib_umem_dmabuf_get(device, offset, size, fd, access,\n\t\t\t\t\t &ib_umem_dmabuf_attach_pinned_ops);\n\tif (IS_ERR(umem_dmabuf))\n\t\treturn umem_dmabuf;\n\n\tdma_resv_lock(umem_dmabuf->attach->dmabuf->resv, NULL);\n\terr = dma_buf_pin(umem_dmabuf->attach);\n\tif (err)\n\t\tgoto err_release;\n\tumem_dmabuf->pinned = 1;\n\n\terr = ib_umem_dmabuf_map_pages(umem_dmabuf);\n\tif (err)\n\t\tgoto err_unpin;\n\tdma_resv_unlock(umem_dmabuf->attach->dmabuf->resv);\n\n\treturn umem_dmabuf;\n\nerr_unpin:\n\tdma_buf_unpin(umem_dmabuf->attach);\nerr_release:\n\tdma_resv_unlock(umem_dmabuf->attach->dmabuf->resv);\n\tib_umem_release(&umem_dmabuf->umem);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(ib_umem_dmabuf_get_pinned);\n\nvoid ib_umem_dmabuf_release(struct ib_umem_dmabuf *umem_dmabuf)\n{\n\tstruct dma_buf *dmabuf = umem_dmabuf->attach->dmabuf;\n\n\tdma_resv_lock(dmabuf->resv, NULL);\n\tib_umem_dmabuf_unmap_pages(umem_dmabuf);\n\tif (umem_dmabuf->pinned)\n\t\tdma_buf_unpin(umem_dmabuf->attach);\n\tdma_resv_unlock(dmabuf->resv);\n\n\tdma_buf_detach(dmabuf, umem_dmabuf->attach);\n\tdma_buf_put(dmabuf);\n\tkfree(umem_dmabuf);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}