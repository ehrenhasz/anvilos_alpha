{
  "module_name": "addr.c",
  "hash_id": "8df640797aa1adadf2283e94d5d2166cc8d499b3e2cf44b032f104b11a9d93c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/addr.c",
  "human_readable_source": " \n\n#include <linux/mutex.h>\n#include <linux/inetdevice.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <net/arp.h>\n#include <net/neighbour.h>\n#include <net/route.h>\n#include <net/netevent.h>\n#include <net/ipv6_stubs.h>\n#include <net/ip6_route.h>\n#include <rdma/ib_addr.h>\n#include <rdma/ib_cache.h>\n#include <rdma/ib_sa.h>\n#include <rdma/ib.h>\n#include <rdma/rdma_netlink.h>\n#include <net/netlink.h>\n\n#include \"core_priv.h\"\n\nstruct addr_req {\n\tstruct list_head list;\n\tstruct sockaddr_storage src_addr;\n\tstruct sockaddr_storage dst_addr;\n\tstruct rdma_dev_addr *addr;\n\tvoid *context;\n\tvoid (*callback)(int status, struct sockaddr *src_addr,\n\t\t\t struct rdma_dev_addr *addr, void *context);\n\tunsigned long timeout;\n\tstruct delayed_work work;\n\tbool resolve_by_gid_attr;\t \n\tint status;\n\tu32 seq;\n};\n\nstatic atomic_t ib_nl_addr_request_seq = ATOMIC_INIT(0);\n\nstatic DEFINE_SPINLOCK(lock);\nstatic LIST_HEAD(req_list);\nstatic struct workqueue_struct *addr_wq;\n\nstatic const struct nla_policy ib_nl_addr_policy[LS_NLA_TYPE_MAX] = {\n\t[LS_NLA_TYPE_DGID] = {.type = NLA_BINARY,\n\t\t.len = sizeof(struct rdma_nla_ls_gid),\n\t\t.validation_type = NLA_VALIDATE_MIN,\n\t\t.min = sizeof(struct rdma_nla_ls_gid)},\n};\n\nstatic inline bool ib_nl_is_good_ip_resp(const struct nlmsghdr *nlh)\n{\n\tstruct nlattr *tb[LS_NLA_TYPE_MAX] = {};\n\tint ret;\n\n\tif (nlh->nlmsg_flags & RDMA_NL_LS_F_ERR)\n\t\treturn false;\n\n\tret = nla_parse_deprecated(tb, LS_NLA_TYPE_MAX - 1, nlmsg_data(nlh),\n\t\t\t\t   nlmsg_len(nlh), ib_nl_addr_policy, NULL);\n\tif (ret)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ib_nl_process_good_ip_rsep(const struct nlmsghdr *nlh)\n{\n\tconst struct nlattr *head, *curr;\n\tunion ib_gid gid;\n\tstruct addr_req *req;\n\tint len, rem;\n\tint found = 0;\n\n\thead = (const struct nlattr *)nlmsg_data(nlh);\n\tlen = nlmsg_len(nlh);\n\n\tnla_for_each_attr(curr, head, len, rem) {\n\t\tif (curr->nla_type == LS_NLA_TYPE_DGID)\n\t\t\tmemcpy(&gid, nla_data(curr), nla_len(curr));\n\t}\n\n\tspin_lock_bh(&lock);\n\tlist_for_each_entry(req, &req_list, list) {\n\t\tif (nlh->nlmsg_seq != req->seq)\n\t\t\tcontinue;\n\t\t \n\t\trdma_addr_set_dgid(req->addr, &gid);\n\t\treq->status = 0;\n\t\tfound = 1;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&lock);\n\n\tif (!found)\n\t\tpr_info(\"Couldn't find request waiting for DGID: %pI6\\n\",\n\t\t\t&gid);\n}\n\nint ib_nl_handle_ip_res_resp(struct sk_buff *skb,\n\t\t\t     struct nlmsghdr *nlh,\n\t\t\t     struct netlink_ext_ack *extack)\n{\n\tif ((nlh->nlmsg_flags & NLM_F_REQUEST) ||\n\t    !(NETLINK_CB(skb).sk))\n\t\treturn -EPERM;\n\n\tif (ib_nl_is_good_ip_resp(nlh))\n\t\tib_nl_process_good_ip_rsep(nlh);\n\n\treturn 0;\n}\n\nstatic int ib_nl_ip_send_msg(struct rdma_dev_addr *dev_addr,\n\t\t\t     const void *daddr,\n\t\t\t     u32 seq, u16 family)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tstruct rdma_ls_ip_resolve_header *header;\n\tvoid *data;\n\tsize_t size;\n\tint attrtype;\n\tint len;\n\n\tif (family == AF_INET) {\n\t\tsize = sizeof(struct in_addr);\n\t\tattrtype = RDMA_NLA_F_MANDATORY | LS_NLA_TYPE_IPV4;\n\t} else {\n\t\tsize = sizeof(struct in6_addr);\n\t\tattrtype = RDMA_NLA_F_MANDATORY | LS_NLA_TYPE_IPV6;\n\t}\n\n\tlen = nla_total_size(sizeof(size));\n\tlen += NLMSG_ALIGN(sizeof(*header));\n\n\tskb = nlmsg_new(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tdata = ibnl_put_msg(skb, &nlh, seq, 0, RDMA_NL_LS,\n\t\t\t    RDMA_NL_LS_OP_IP_RESOLVE, NLM_F_REQUEST);\n\tif (!data) {\n\t\tnlmsg_free(skb);\n\t\treturn -ENODATA;\n\t}\n\n\t \n\theader = skb_put(skb, NLMSG_ALIGN(sizeof(*header)));\n\theader->ifindex = dev_addr->bound_dev_if;\n\tnla_put(skb, attrtype, size, daddr);\n\n\t \n\tnlmsg_end(skb, nlh);\n\trdma_nl_multicast(&init_net, skb, RDMA_NL_GROUP_LS, GFP_KERNEL);\n\n\t \n\treturn -ENODATA;\n}\n\nint rdma_addr_size(const struct sockaddr *addr)\n{\n\tswitch (addr->sa_family) {\n\tcase AF_INET:\n\t\treturn sizeof(struct sockaddr_in);\n\tcase AF_INET6:\n\t\treturn sizeof(struct sockaddr_in6);\n\tcase AF_IB:\n\t\treturn sizeof(struct sockaddr_ib);\n\tdefault:\n\t\treturn 0;\n\t}\n}\nEXPORT_SYMBOL(rdma_addr_size);\n\nint rdma_addr_size_in6(struct sockaddr_in6 *addr)\n{\n\tint ret = rdma_addr_size((struct sockaddr *) addr);\n\n\treturn ret <= sizeof(*addr) ? ret : 0;\n}\nEXPORT_SYMBOL(rdma_addr_size_in6);\n\nint rdma_addr_size_kss(struct __kernel_sockaddr_storage *addr)\n{\n\tint ret = rdma_addr_size((struct sockaddr *) addr);\n\n\treturn ret <= sizeof(*addr) ? ret : 0;\n}\nEXPORT_SYMBOL(rdma_addr_size_kss);\n\n \nvoid rdma_copy_src_l2_addr(struct rdma_dev_addr *dev_addr,\n\t\t\t   const struct net_device *dev)\n{\n\tdev_addr->dev_type = dev->type;\n\tmemcpy(dev_addr->src_dev_addr, dev->dev_addr, MAX_ADDR_LEN);\n\tmemcpy(dev_addr->broadcast, dev->broadcast, MAX_ADDR_LEN);\n\tdev_addr->bound_dev_if = dev->ifindex;\n}\nEXPORT_SYMBOL(rdma_copy_src_l2_addr);\n\nstatic struct net_device *\nrdma_find_ndev_for_src_ip_rcu(struct net *net, const struct sockaddr *src_in)\n{\n\tstruct net_device *dev = NULL;\n\tint ret = -EADDRNOTAVAIL;\n\n\tswitch (src_in->sa_family) {\n\tcase AF_INET:\n\t\tdev = __ip_dev_find(net,\n\t\t\t\t    ((const struct sockaddr_in *)src_in)->sin_addr.s_addr,\n\t\t\t\t    false);\n\t\tif (dev)\n\t\t\tret = 0;\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tfor_each_netdev_rcu(net, dev) {\n\t\t\tif (ipv6_chk_addr(net,\n\t\t\t\t\t  &((const struct sockaddr_in6 *)src_in)->sin6_addr,\n\t\t\t\t\t  dev, 1)) {\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n#endif\n\t}\n\treturn ret ? ERR_PTR(ret) : dev;\n}\n\nint rdma_translate_ip(const struct sockaddr *addr,\n\t\t      struct rdma_dev_addr *dev_addr)\n{\n\tstruct net_device *dev;\n\n\tif (dev_addr->bound_dev_if) {\n\t\tdev = dev_get_by_index(dev_addr->net, dev_addr->bound_dev_if);\n\t\tif (!dev)\n\t\t\treturn -ENODEV;\n\t\trdma_copy_src_l2_addr(dev_addr, dev);\n\t\tdev_put(dev);\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\tdev = rdma_find_ndev_for_src_ip_rcu(dev_addr->net, addr);\n\tif (!IS_ERR(dev))\n\t\trdma_copy_src_l2_addr(dev_addr, dev);\n\trcu_read_unlock();\n\treturn PTR_ERR_OR_ZERO(dev);\n}\nEXPORT_SYMBOL(rdma_translate_ip);\n\nstatic void set_timeout(struct addr_req *req, unsigned long time)\n{\n\tunsigned long delay;\n\n\tdelay = time - jiffies;\n\tif ((long)delay < 0)\n\t\tdelay = 0;\n\n\tmod_delayed_work(addr_wq, &req->work, delay);\n}\n\nstatic void queue_req(struct addr_req *req)\n{\n\tspin_lock_bh(&lock);\n\tlist_add_tail(&req->list, &req_list);\n\tset_timeout(req, req->timeout);\n\tspin_unlock_bh(&lock);\n}\n\nstatic int ib_nl_fetch_ha(struct rdma_dev_addr *dev_addr,\n\t\t\t  const void *daddr, u32 seq, u16 family)\n{\n\tif (!rdma_nl_chk_listeners(RDMA_NL_GROUP_LS))\n\t\treturn -EADDRNOTAVAIL;\n\n\treturn ib_nl_ip_send_msg(dev_addr, daddr, seq, family);\n}\n\nstatic int dst_fetch_ha(const struct dst_entry *dst,\n\t\t\tstruct rdma_dev_addr *dev_addr,\n\t\t\tconst void *daddr)\n{\n\tstruct neighbour *n;\n\tint ret = 0;\n\n\tn = dst_neigh_lookup(dst, daddr);\n\tif (!n)\n\t\treturn -ENODATA;\n\n\tif (!(n->nud_state & NUD_VALID)) {\n\t\tneigh_event_send(n, NULL);\n\t\tret = -ENODATA;\n\t} else {\n\t\tneigh_ha_snapshot(dev_addr->dst_dev_addr, n, dst->dev);\n\t}\n\n\tneigh_release(n);\n\n\treturn ret;\n}\n\nstatic bool has_gateway(const struct dst_entry *dst, sa_family_t family)\n{\n\tstruct rtable *rt;\n\tstruct rt6_info *rt6;\n\n\tif (family == AF_INET) {\n\t\trt = container_of(dst, struct rtable, dst);\n\t\treturn rt->rt_uses_gateway;\n\t}\n\n\trt6 = container_of(dst, struct rt6_info, dst);\n\treturn rt6->rt6i_flags & RTF_GATEWAY;\n}\n\nstatic int fetch_ha(const struct dst_entry *dst, struct rdma_dev_addr *dev_addr,\n\t\t    const struct sockaddr *dst_in, u32 seq)\n{\n\tconst struct sockaddr_in *dst_in4 =\n\t\t(const struct sockaddr_in *)dst_in;\n\tconst struct sockaddr_in6 *dst_in6 =\n\t\t(const struct sockaddr_in6 *)dst_in;\n\tconst void *daddr = (dst_in->sa_family == AF_INET) ?\n\t\t(const void *)&dst_in4->sin_addr.s_addr :\n\t\t(const void *)&dst_in6->sin6_addr;\n\tsa_family_t family = dst_in->sa_family;\n\n\tmight_sleep();\n\n\t \n\tif (has_gateway(dst, family) && dev_addr->network == RDMA_NETWORK_IB)\n\t\treturn ib_nl_fetch_ha(dev_addr, daddr, seq, family);\n\telse\n\t\treturn dst_fetch_ha(dst, dev_addr, daddr);\n}\n\nstatic int addr4_resolve(struct sockaddr *src_sock,\n\t\t\t const struct sockaddr *dst_sock,\n\t\t\t struct rdma_dev_addr *addr,\n\t\t\t struct rtable **prt)\n{\n\tstruct sockaddr_in *src_in = (struct sockaddr_in *)src_sock;\n\tconst struct sockaddr_in *dst_in =\n\t\t\t(const struct sockaddr_in *)dst_sock;\n\n\t__be32 src_ip = src_in->sin_addr.s_addr;\n\t__be32 dst_ip = dst_in->sin_addr.s_addr;\n\tstruct rtable *rt;\n\tstruct flowi4 fl4;\n\tint ret;\n\n\tmemset(&fl4, 0, sizeof(fl4));\n\tfl4.daddr = dst_ip;\n\tfl4.saddr = src_ip;\n\tfl4.flowi4_oif = addr->bound_dev_if;\n\trt = ip_route_output_key(addr->net, &fl4);\n\tret = PTR_ERR_OR_ZERO(rt);\n\tif (ret)\n\t\treturn ret;\n\n\tsrc_in->sin_addr.s_addr = fl4.saddr;\n\n\taddr->hoplimit = ip4_dst_hoplimit(&rt->dst);\n\n\t*prt = rt;\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic int addr6_resolve(struct sockaddr *src_sock,\n\t\t\t const struct sockaddr *dst_sock,\n\t\t\t struct rdma_dev_addr *addr,\n\t\t\t struct dst_entry **pdst)\n{\n\tstruct sockaddr_in6 *src_in = (struct sockaddr_in6 *)src_sock;\n\tconst struct sockaddr_in6 *dst_in =\n\t\t\t\t(const struct sockaddr_in6 *)dst_sock;\n\tstruct flowi6 fl6;\n\tstruct dst_entry *dst;\n\n\tmemset(&fl6, 0, sizeof fl6);\n\tfl6.daddr = dst_in->sin6_addr;\n\tfl6.saddr = src_in->sin6_addr;\n\tfl6.flowi6_oif = addr->bound_dev_if;\n\n\tdst = ipv6_stub->ipv6_dst_lookup_flow(addr->net, NULL, &fl6, NULL);\n\tif (IS_ERR(dst))\n\t\treturn PTR_ERR(dst);\n\n\tif (ipv6_addr_any(&src_in->sin6_addr))\n\t\tsrc_in->sin6_addr = fl6.saddr;\n\n\taddr->hoplimit = ip6_dst_hoplimit(dst);\n\n\t*pdst = dst;\n\treturn 0;\n}\n#else\nstatic int addr6_resolve(struct sockaddr *src_sock,\n\t\t\t const struct sockaddr *dst_sock,\n\t\t\t struct rdma_dev_addr *addr,\n\t\t\t struct dst_entry **pdst)\n{\n\treturn -EADDRNOTAVAIL;\n}\n#endif\n\nstatic int addr_resolve_neigh(const struct dst_entry *dst,\n\t\t\t      const struct sockaddr *dst_in,\n\t\t\t      struct rdma_dev_addr *addr,\n\t\t\t      unsigned int ndev_flags,\n\t\t\t      u32 seq)\n{\n\tint ret = 0;\n\n\tif (ndev_flags & IFF_LOOPBACK) {\n\t\tmemcpy(addr->dst_dev_addr, addr->src_dev_addr, MAX_ADDR_LEN);\n\t} else {\n\t\tif (!(ndev_flags & IFF_NOARP)) {\n\t\t\t \n\t\t\tret = fetch_ha(dst, addr, dst_in, seq);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int copy_src_l2_addr(struct rdma_dev_addr *dev_addr,\n\t\t\t    const struct sockaddr *dst_in,\n\t\t\t    const struct dst_entry *dst,\n\t\t\t    const struct net_device *ndev)\n{\n\tint ret = 0;\n\n\tif (dst->dev->flags & IFF_LOOPBACK)\n\t\tret = rdma_translate_ip(dst_in, dev_addr);\n\telse\n\t\trdma_copy_src_l2_addr(dev_addr, dst->dev);\n\n\t \n\tif (has_gateway(dst, dst_in->sa_family) &&\n\t    ndev->type != ARPHRD_INFINIBAND)\n\t\tdev_addr->network = dst_in->sa_family == AF_INET ?\n\t\t\t\t\t\tRDMA_NETWORK_IPV4 :\n\t\t\t\t\t\tRDMA_NETWORK_IPV6;\n\telse\n\t\tdev_addr->network = RDMA_NETWORK_IB;\n\n\treturn ret;\n}\n\nstatic int rdma_set_src_addr_rcu(struct rdma_dev_addr *dev_addr,\n\t\t\t\t unsigned int *ndev_flags,\n\t\t\t\t const struct sockaddr *dst_in,\n\t\t\t\t const struct dst_entry *dst)\n{\n\tstruct net_device *ndev = READ_ONCE(dst->dev);\n\n\t*ndev_flags = ndev->flags;\n\t \n\tif (ndev->flags & IFF_LOOPBACK) {\n\t\t \n\t\tndev = rdma_find_ndev_for_src_ip_rcu(dev_net(ndev), dst_in);\n\t\tif (IS_ERR(ndev))\n\t\t\treturn -ENODEV;\n\t}\n\n\treturn copy_src_l2_addr(dev_addr, dst_in, dst, ndev);\n}\n\nstatic int set_addr_netns_by_gid_rcu(struct rdma_dev_addr *addr)\n{\n\tstruct net_device *ndev;\n\n\tndev = rdma_read_gid_attr_ndev_rcu(addr->sgid_attr);\n\tif (IS_ERR(ndev))\n\t\treturn PTR_ERR(ndev);\n\n\t \n\taddr->net = dev_net(ndev);\n\taddr->bound_dev_if = ndev->ifindex;\n\treturn 0;\n}\n\nstatic void rdma_addr_set_net_defaults(struct rdma_dev_addr *addr)\n{\n\taddr->net = &init_net;\n\taddr->bound_dev_if = 0;\n}\n\nstatic int addr_resolve(struct sockaddr *src_in,\n\t\t\tconst struct sockaddr *dst_in,\n\t\t\tstruct rdma_dev_addr *addr,\n\t\t\tbool resolve_neigh,\n\t\t\tbool resolve_by_gid_attr,\n\t\t\tu32 seq)\n{\n\tstruct dst_entry *dst = NULL;\n\tunsigned int ndev_flags = 0;\n\tstruct rtable *rt = NULL;\n\tint ret;\n\n\tif (!addr->net) {\n\t\tpr_warn_ratelimited(\"%s: missing namespace\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\trcu_read_lock();\n\tif (resolve_by_gid_attr) {\n\t\tif (!addr->sgid_attr) {\n\t\t\trcu_read_unlock();\n\t\t\tpr_warn_ratelimited(\"%s: missing gid_attr\\n\", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tret = set_addr_netns_by_gid_rcu(addr);\n\t\tif (ret) {\n\t\t\trcu_read_unlock();\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif (src_in->sa_family == AF_INET) {\n\t\tret = addr4_resolve(src_in, dst_in, addr, &rt);\n\t\tdst = &rt->dst;\n\t} else {\n\t\tret = addr6_resolve(src_in, dst_in, addr, &dst);\n\t}\n\tif (ret) {\n\t\trcu_read_unlock();\n\t\tgoto done;\n\t}\n\tret = rdma_set_src_addr_rcu(addr, &ndev_flags, dst_in, dst);\n\trcu_read_unlock();\n\n\t \n\tif (!ret && resolve_neigh)\n\t\tret = addr_resolve_neigh(dst, dst_in, addr, ndev_flags, seq);\n\n\tif (src_in->sa_family == AF_INET)\n\t\tip_rt_put(rt);\n\telse\n\t\tdst_release(dst);\ndone:\n\t \n\tif (resolve_by_gid_attr)\n\t\trdma_addr_set_net_defaults(addr);\n\treturn ret;\n}\n\nstatic void process_one_req(struct work_struct *_work)\n{\n\tstruct addr_req *req;\n\tstruct sockaddr *src_in, *dst_in;\n\n\treq = container_of(_work, struct addr_req, work.work);\n\n\tif (req->status == -ENODATA) {\n\t\tsrc_in = (struct sockaddr *)&req->src_addr;\n\t\tdst_in = (struct sockaddr *)&req->dst_addr;\n\t\treq->status = addr_resolve(src_in, dst_in, req->addr,\n\t\t\t\t\t   true, req->resolve_by_gid_attr,\n\t\t\t\t\t   req->seq);\n\t\tif (req->status && time_after_eq(jiffies, req->timeout)) {\n\t\t\treq->status = -ETIMEDOUT;\n\t\t} else if (req->status == -ENODATA) {\n\t\t\t \n\t\t\tspin_lock_bh(&lock);\n\t\t\tif (!list_empty(&req->list))\n\t\t\t\tset_timeout(req, req->timeout);\n\t\t\tspin_unlock_bh(&lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\treq->callback(req->status, (struct sockaddr *)&req->src_addr,\n\t\treq->addr, req->context);\n\treq->callback = NULL;\n\n\tspin_lock_bh(&lock);\n\t \n\tcancel_delayed_work(&req->work);\n\tif (!list_empty(&req->list)) {\n\t\tlist_del_init(&req->list);\n\t\tkfree(req);\n\t}\n\tspin_unlock_bh(&lock);\n}\n\nint rdma_resolve_ip(struct sockaddr *src_addr, const struct sockaddr *dst_addr,\n\t\t    struct rdma_dev_addr *addr, unsigned long timeout_ms,\n\t\t    void (*callback)(int status, struct sockaddr *src_addr,\n\t\t\t\t     struct rdma_dev_addr *addr, void *context),\n\t\t    bool resolve_by_gid_attr, void *context)\n{\n\tstruct sockaddr *src_in, *dst_in;\n\tstruct addr_req *req;\n\tint ret = 0;\n\n\treq = kzalloc(sizeof *req, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tsrc_in = (struct sockaddr *) &req->src_addr;\n\tdst_in = (struct sockaddr *) &req->dst_addr;\n\n\tif (src_addr) {\n\t\tif (src_addr->sa_family != dst_addr->sa_family) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tmemcpy(src_in, src_addr, rdma_addr_size(src_addr));\n\t} else {\n\t\tsrc_in->sa_family = dst_addr->sa_family;\n\t}\n\n\tmemcpy(dst_in, dst_addr, rdma_addr_size(dst_addr));\n\treq->addr = addr;\n\treq->callback = callback;\n\treq->context = context;\n\treq->resolve_by_gid_attr = resolve_by_gid_attr;\n\tINIT_DELAYED_WORK(&req->work, process_one_req);\n\treq->seq = (u32)atomic_inc_return(&ib_nl_addr_request_seq);\n\n\treq->status = addr_resolve(src_in, dst_in, addr, true,\n\t\t\t\t   req->resolve_by_gid_attr, req->seq);\n\tswitch (req->status) {\n\tcase 0:\n\t\treq->timeout = jiffies;\n\t\tqueue_req(req);\n\t\tbreak;\n\tcase -ENODATA:\n\t\treq->timeout = msecs_to_jiffies(timeout_ms) + jiffies;\n\t\tqueue_req(req);\n\t\tbreak;\n\tdefault:\n\t\tret = req->status;\n\t\tgoto err;\n\t}\n\treturn ret;\nerr:\n\tkfree(req);\n\treturn ret;\n}\nEXPORT_SYMBOL(rdma_resolve_ip);\n\nint roce_resolve_route_from_path(struct sa_path_rec *rec,\n\t\t\t\t const struct ib_gid_attr *attr)\n{\n\tunion {\n\t\tstruct sockaddr     _sockaddr;\n\t\tstruct sockaddr_in  _sockaddr_in;\n\t\tstruct sockaddr_in6 _sockaddr_in6;\n\t} sgid, dgid;\n\tstruct rdma_dev_addr dev_addr = {};\n\tint ret;\n\n\tmight_sleep();\n\n\tif (rec->roce.route_resolved)\n\t\treturn 0;\n\n\trdma_gid2ip((struct sockaddr *)&sgid, &rec->sgid);\n\trdma_gid2ip((struct sockaddr *)&dgid, &rec->dgid);\n\n\tif (sgid._sockaddr.sa_family != dgid._sockaddr.sa_family)\n\t\treturn -EINVAL;\n\n\tif (!attr || !attr->ndev)\n\t\treturn -EINVAL;\n\n\tdev_addr.net = &init_net;\n\tdev_addr.sgid_attr = attr;\n\n\tret = addr_resolve((struct sockaddr *)&sgid, (struct sockaddr *)&dgid,\n\t\t\t   &dev_addr, false, true, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((dev_addr.network == RDMA_NETWORK_IPV4 ||\n\t     dev_addr.network == RDMA_NETWORK_IPV6) &&\n\t    rec->rec_type != SA_PATH_REC_TYPE_ROCE_V2)\n\t\treturn -EINVAL;\n\n\trec->roce.route_resolved = true;\n\treturn 0;\n}\n\n \nvoid rdma_addr_cancel(struct rdma_dev_addr *addr)\n{\n\tstruct addr_req *req, *temp_req;\n\tstruct addr_req *found = NULL;\n\n\tspin_lock_bh(&lock);\n\tlist_for_each_entry_safe(req, temp_req, &req_list, list) {\n\t\tif (req->addr == addr) {\n\t\t\t \n\t\t\tlist_del_init(&req->list);\n\t\t\tfound = req;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&lock);\n\n\tif (!found)\n\t\treturn;\n\n\t \n\tcancel_delayed_work_sync(&found->work);\n\tkfree(found);\n}\nEXPORT_SYMBOL(rdma_addr_cancel);\n\nstruct resolve_cb_context {\n\tstruct completion comp;\n\tint status;\n};\n\nstatic void resolve_cb(int status, struct sockaddr *src_addr,\n\t     struct rdma_dev_addr *addr, void *context)\n{\n\t((struct resolve_cb_context *)context)->status = status;\n\tcomplete(&((struct resolve_cb_context *)context)->comp);\n}\n\nint rdma_addr_find_l2_eth_by_grh(const union ib_gid *sgid,\n\t\t\t\t const union ib_gid *dgid,\n\t\t\t\t u8 *dmac, const struct ib_gid_attr *sgid_attr,\n\t\t\t\t int *hoplimit)\n{\n\tstruct rdma_dev_addr dev_addr;\n\tstruct resolve_cb_context ctx;\n\tunion {\n\t\tstruct sockaddr_in  _sockaddr_in;\n\t\tstruct sockaddr_in6 _sockaddr_in6;\n\t} sgid_addr, dgid_addr;\n\tint ret;\n\n\trdma_gid2ip((struct sockaddr *)&sgid_addr, sgid);\n\trdma_gid2ip((struct sockaddr *)&dgid_addr, dgid);\n\n\tmemset(&dev_addr, 0, sizeof(dev_addr));\n\tdev_addr.net = &init_net;\n\tdev_addr.sgid_attr = sgid_attr;\n\n\tinit_completion(&ctx.comp);\n\tret = rdma_resolve_ip((struct sockaddr *)&sgid_addr,\n\t\t\t      (struct sockaddr *)&dgid_addr, &dev_addr, 1000,\n\t\t\t      resolve_cb, true, &ctx);\n\tif (ret)\n\t\treturn ret;\n\n\twait_for_completion(&ctx.comp);\n\n\tret = ctx.status;\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(dmac, dev_addr.dst_dev_addr, ETH_ALEN);\n\t*hoplimit = dev_addr.hoplimit;\n\treturn 0;\n}\n\nstatic int netevent_callback(struct notifier_block *self, unsigned long event,\n\tvoid *ctx)\n{\n\tstruct addr_req *req;\n\n\tif (event == NETEVENT_NEIGH_UPDATE) {\n\t\tstruct neighbour *neigh = ctx;\n\n\t\tif (neigh->nud_state & NUD_VALID) {\n\t\t\tspin_lock_bh(&lock);\n\t\t\tlist_for_each_entry(req, &req_list, list)\n\t\t\t\tset_timeout(req, jiffies);\n\t\t\tspin_unlock_bh(&lock);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block nb = {\n\t.notifier_call = netevent_callback\n};\n\nint addr_init(void)\n{\n\taddr_wq = alloc_ordered_workqueue(\"ib_addr\", 0);\n\tif (!addr_wq)\n\t\treturn -ENOMEM;\n\n\tregister_netevent_notifier(&nb);\n\n\treturn 0;\n}\n\nvoid addr_cleanup(void)\n{\n\tunregister_netevent_notifier(&nb);\n\tdestroy_workqueue(addr_wq);\n\tWARN_ON(!list_empty(&req_list));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}