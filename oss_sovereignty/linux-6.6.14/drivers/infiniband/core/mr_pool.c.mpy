{
  "module_name": "mr_pool.c",
  "hash_id": "0e20cd0cfefd71fa62239af54843d037e36121c0d68911fd06aa7d6625f7f446",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/mr_pool.c",
  "human_readable_source": "\n \n#include <rdma/ib_verbs.h>\n#include <rdma/mr_pool.h>\n\nstruct ib_mr *ib_mr_pool_get(struct ib_qp *qp, struct list_head *list)\n{\n\tstruct ib_mr *mr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->mr_lock, flags);\n\tmr = list_first_entry_or_null(list, struct ib_mr, qp_entry);\n\tif (mr) {\n\t\tlist_del(&mr->qp_entry);\n\t\tqp->mrs_used++;\n\t}\n\tspin_unlock_irqrestore(&qp->mr_lock, flags);\n\n\treturn mr;\n}\nEXPORT_SYMBOL(ib_mr_pool_get);\n\nvoid ib_mr_pool_put(struct ib_qp *qp, struct list_head *list, struct ib_mr *mr)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->mr_lock, flags);\n\tlist_add(&mr->qp_entry, list);\n\tqp->mrs_used--;\n\tspin_unlock_irqrestore(&qp->mr_lock, flags);\n}\nEXPORT_SYMBOL(ib_mr_pool_put);\n\nint ib_mr_pool_init(struct ib_qp *qp, struct list_head *list, int nr,\n\t\tenum ib_mr_type type, u32 max_num_sg, u32 max_num_meta_sg)\n{\n\tstruct ib_mr *mr;\n\tunsigned long flags;\n\tint ret, i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tif (type == IB_MR_TYPE_INTEGRITY)\n\t\t\tmr = ib_alloc_mr_integrity(qp->pd, max_num_sg,\n\t\t\t\t\t\t   max_num_meta_sg);\n\t\telse\n\t\t\tmr = ib_alloc_mr(qp->pd, type, max_num_sg);\n\t\tif (IS_ERR(mr)) {\n\t\t\tret = PTR_ERR(mr);\n\t\t\tgoto out;\n\t\t}\n\n\t\tspin_lock_irqsave(&qp->mr_lock, flags);\n\t\tlist_add_tail(&mr->qp_entry, list);\n\t\tspin_unlock_irqrestore(&qp->mr_lock, flags);\n\t}\n\n\treturn 0;\nout:\n\tib_mr_pool_destroy(qp, list);\n\treturn ret;\n}\nEXPORT_SYMBOL(ib_mr_pool_init);\n\nvoid ib_mr_pool_destroy(struct ib_qp *qp, struct list_head *list)\n{\n\tstruct ib_mr *mr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&qp->mr_lock, flags);\n\twhile (!list_empty(list)) {\n\t\tmr = list_first_entry(list, struct ib_mr, qp_entry);\n\t\tlist_del(&mr->qp_entry);\n\n\t\tspin_unlock_irqrestore(&qp->mr_lock, flags);\n\t\tib_dereg_mr(mr);\n\t\tspin_lock_irqsave(&qp->mr_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&qp->mr_lock, flags);\n}\nEXPORT_SYMBOL(ib_mr_pool_destroy);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}