{
  "module_name": "uverbs_main.c",
  "hash_id": "fd9465efa08ce565d41425bcccc6decbea7c175b705052c644883cdeabbbce4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs_main.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/poll.h>\n#include <linux/sched.h>\n#include <linux/file.h>\n#include <linux/cdev.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/sched/mm.h>\n\n#include <linux/uaccess.h>\n\n#include <rdma/ib.h>\n#include <rdma/uverbs_std_types.h>\n#include <rdma/rdma_netlink.h>\n\n#include \"uverbs.h\"\n#include \"core_priv.h\"\n#include \"rdma_core.h\"\n\nMODULE_AUTHOR(\"Roland Dreier\");\nMODULE_DESCRIPTION(\"InfiniBand userspace verbs access\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nenum {\n\tIB_UVERBS_MAJOR       = 231,\n\tIB_UVERBS_BASE_MINOR  = 192,\n\tIB_UVERBS_MAX_DEVICES = RDMA_MAX_PORTS,\n\tIB_UVERBS_NUM_FIXED_MINOR = 32,\n\tIB_UVERBS_NUM_DYNAMIC_MINOR = IB_UVERBS_MAX_DEVICES - IB_UVERBS_NUM_FIXED_MINOR,\n};\n\n#define IB_UVERBS_BASE_DEV\tMKDEV(IB_UVERBS_MAJOR, IB_UVERBS_BASE_MINOR)\n\nstatic dev_t dynamic_uverbs_dev;\n\nstatic DEFINE_IDA(uverbs_ida);\nstatic int ib_uverbs_add_one(struct ib_device *device);\nstatic void ib_uverbs_remove_one(struct ib_device *device, void *client_data);\n\nstatic char *uverbs_devnode(const struct device *dev, umode_t *mode)\n{\n\tif (mode)\n\t\t*mode = 0666;\n\treturn kasprintf(GFP_KERNEL, \"infiniband/%s\", dev_name(dev));\n}\n\nstatic const struct class uverbs_class = {\n\t.name = \"infiniband_verbs\",\n\t.devnode = uverbs_devnode,\n};\n\n \nstruct ib_ucontext *ib_uverbs_get_ucontext_file(struct ib_uverbs_file *ufile)\n{\n\t \n\tstruct ib_ucontext *ucontext = smp_load_acquire(&ufile->ucontext);\n\n\tif (!srcu_dereference(ufile->device->ib_dev,\n\t\t\t      &ufile->device->disassociate_srcu))\n\t\treturn ERR_PTR(-EIO);\n\n\tif (!ucontext)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ucontext;\n}\nEXPORT_SYMBOL(ib_uverbs_get_ucontext_file);\n\nint uverbs_dealloc_mw(struct ib_mw *mw)\n{\n\tstruct ib_pd *pd = mw->pd;\n\tint ret;\n\n\tret = mw->device->ops.dealloc_mw(mw);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_dec(&pd->usecnt);\n\tkfree(mw);\n\treturn ret;\n}\n\nstatic void ib_uverbs_release_dev(struct device *device)\n{\n\tstruct ib_uverbs_device *dev =\n\t\t\tcontainer_of(device, struct ib_uverbs_device, dev);\n\n\tuverbs_destroy_api(dev->uapi);\n\tcleanup_srcu_struct(&dev->disassociate_srcu);\n\tmutex_destroy(&dev->lists_mutex);\n\tmutex_destroy(&dev->xrcd_tree_mutex);\n\tkfree(dev);\n}\n\nvoid ib_uverbs_release_ucq(struct ib_uverbs_completion_event_file *ev_file,\n\t\t\t   struct ib_ucq_object *uobj)\n{\n\tstruct ib_uverbs_event *evt, *tmp;\n\n\tif (ev_file) {\n\t\tspin_lock_irq(&ev_file->ev_queue.lock);\n\t\tlist_for_each_entry_safe(evt, tmp, &uobj->comp_list, obj_list) {\n\t\t\tlist_del(&evt->list);\n\t\t\tkfree(evt);\n\t\t}\n\t\tspin_unlock_irq(&ev_file->ev_queue.lock);\n\n\t\tuverbs_uobject_put(&ev_file->uobj);\n\t}\n\n\tib_uverbs_release_uevent(&uobj->uevent);\n}\n\nvoid ib_uverbs_release_uevent(struct ib_uevent_object *uobj)\n{\n\tstruct ib_uverbs_async_event_file *async_file = uobj->event_file;\n\tstruct ib_uverbs_event *evt, *tmp;\n\n\tif (!async_file)\n\t\treturn;\n\n\tspin_lock_irq(&async_file->ev_queue.lock);\n\tlist_for_each_entry_safe(evt, tmp, &uobj->event_list, obj_list) {\n\t\tlist_del(&evt->list);\n\t\tkfree(evt);\n\t}\n\tspin_unlock_irq(&async_file->ev_queue.lock);\n\tuverbs_uobject_put(&async_file->uobj);\n}\n\nvoid ib_uverbs_detach_umcast(struct ib_qp *qp,\n\t\t\t     struct ib_uqp_object *uobj)\n{\n\tstruct ib_uverbs_mcast_entry *mcast, *tmp;\n\n\tlist_for_each_entry_safe(mcast, tmp, &uobj->mcast_list, list) {\n\t\tib_detach_mcast(qp, &mcast->gid, mcast->lid);\n\t\tlist_del(&mcast->list);\n\t\tkfree(mcast);\n\t}\n}\n\nstatic void ib_uverbs_comp_dev(struct ib_uverbs_device *dev)\n{\n\tcomplete(&dev->comp);\n}\n\nvoid ib_uverbs_release_file(struct kref *ref)\n{\n\tstruct ib_uverbs_file *file =\n\t\tcontainer_of(ref, struct ib_uverbs_file, ref);\n\tstruct ib_device *ib_dev;\n\tint srcu_key;\n\n\trelease_ufile_idr_uobject(file);\n\n\tsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\n\tib_dev = srcu_dereference(file->device->ib_dev,\n\t\t\t\t  &file->device->disassociate_srcu);\n\tif (ib_dev && !ib_dev->ops.disassociate_ucontext)\n\t\tmodule_put(ib_dev->ops.owner);\n\tsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\n\n\tif (refcount_dec_and_test(&file->device->refcount))\n\t\tib_uverbs_comp_dev(file->device);\n\n\tif (file->default_async_file)\n\t\tuverbs_uobject_put(&file->default_async_file->uobj);\n\tput_device(&file->device->dev);\n\n\tif (file->disassociate_page)\n\t\t__free_pages(file->disassociate_page, 0);\n\tmutex_destroy(&file->umap_lock);\n\tmutex_destroy(&file->ucontext_lock);\n\tkfree(file);\n}\n\nstatic ssize_t ib_uverbs_event_read(struct ib_uverbs_event_queue *ev_queue,\n\t\t\t\t    struct file *filp, char __user *buf,\n\t\t\t\t    size_t count, loff_t *pos,\n\t\t\t\t    size_t eventsz)\n{\n\tstruct ib_uverbs_event *event;\n\tint ret = 0;\n\n\tspin_lock_irq(&ev_queue->lock);\n\n\twhile (list_empty(&ev_queue->event_list)) {\n\t\tif (ev_queue->is_closed) {\n\t\t\tspin_unlock_irq(&ev_queue->lock);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tspin_unlock_irq(&ev_queue->lock);\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tif (wait_event_interruptible(ev_queue->poll_wait,\n\t\t\t\t\t     (!list_empty(&ev_queue->event_list) ||\n\t\t\t\t\t      ev_queue->is_closed)))\n\t\t\treturn -ERESTARTSYS;\n\n\t\tspin_lock_irq(&ev_queue->lock);\n\t}\n\n\tevent = list_entry(ev_queue->event_list.next, struct ib_uverbs_event, list);\n\n\tif (eventsz > count) {\n\t\tret   = -EINVAL;\n\t\tevent = NULL;\n\t} else {\n\t\tlist_del(ev_queue->event_list.next);\n\t\tif (event->counter) {\n\t\t\t++(*event->counter);\n\t\t\tlist_del(&event->obj_list);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&ev_queue->lock);\n\n\tif (event) {\n\t\tif (copy_to_user(buf, event, eventsz))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = eventsz;\n\t}\n\n\tkfree(event);\n\n\treturn ret;\n}\n\nstatic ssize_t ib_uverbs_async_event_read(struct file *filp, char __user *buf,\n\t\t\t\t\t  size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_async_event_file *file = filp->private_data;\n\n\treturn ib_uverbs_event_read(&file->ev_queue, filp, buf, count, pos,\n\t\t\t\t    sizeof(struct ib_uverbs_async_event_desc));\n}\n\nstatic ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,\n\t\t\t\t\t size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn ib_uverbs_event_read(&comp_ev_file->ev_queue, filp, buf, count,\n\t\t\t\t    pos,\n\t\t\t\t    sizeof(struct ib_uverbs_comp_event_desc));\n}\n\nstatic __poll_t ib_uverbs_event_poll(struct ib_uverbs_event_queue *ev_queue,\n\t\t\t\t\t struct file *filp,\n\t\t\t\t\t struct poll_table_struct *wait)\n{\n\t__poll_t pollflags = 0;\n\n\tpoll_wait(filp, &ev_queue->poll_wait, wait);\n\n\tspin_lock_irq(&ev_queue->lock);\n\tif (!list_empty(&ev_queue->event_list))\n\t\tpollflags = EPOLLIN | EPOLLRDNORM;\n\telse if (ev_queue->is_closed)\n\t\tpollflags = EPOLLERR;\n\tspin_unlock_irq(&ev_queue->lock);\n\n\treturn pollflags;\n}\n\nstatic __poll_t ib_uverbs_async_event_poll(struct file *filp,\n\t\t\t\t\t       struct poll_table_struct *wait)\n{\n\tstruct ib_uverbs_async_event_file *file = filp->private_data;\n\n\treturn ib_uverbs_event_poll(&file->ev_queue, filp, wait);\n}\n\nstatic __poll_t ib_uverbs_comp_event_poll(struct file *filp,\n\t\t\t\t\t      struct poll_table_struct *wait)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn ib_uverbs_event_poll(&comp_ev_file->ev_queue, filp, wait);\n}\n\nstatic int ib_uverbs_async_event_fasync(int fd, struct file *filp, int on)\n{\n\tstruct ib_uverbs_async_event_file *file = filp->private_data;\n\n\treturn fasync_helper(fd, filp, on, &file->ev_queue.async_queue);\n}\n\nstatic int ib_uverbs_comp_event_fasync(int fd, struct file *filp, int on)\n{\n\tstruct ib_uverbs_completion_event_file *comp_ev_file =\n\t\tfilp->private_data;\n\n\treturn fasync_helper(fd, filp, on, &comp_ev_file->ev_queue.async_queue);\n}\n\nconst struct file_operations uverbs_event_fops = {\n\t.owner\t = THIS_MODULE,\n\t.read\t = ib_uverbs_comp_event_read,\n\t.poll    = ib_uverbs_comp_event_poll,\n\t.release = uverbs_uobject_fd_release,\n\t.fasync  = ib_uverbs_comp_event_fasync,\n\t.llseek\t = no_llseek,\n};\n\nconst struct file_operations uverbs_async_event_fops = {\n\t.owner\t = THIS_MODULE,\n\t.read\t = ib_uverbs_async_event_read,\n\t.poll    = ib_uverbs_async_event_poll,\n\t.release = uverbs_async_event_release,\n\t.fasync  = ib_uverbs_async_event_fasync,\n\t.llseek\t = no_llseek,\n};\n\nvoid ib_uverbs_comp_handler(struct ib_cq *cq, void *cq_context)\n{\n\tstruct ib_uverbs_event_queue   *ev_queue = cq_context;\n\tstruct ib_ucq_object\t       *uobj;\n\tstruct ib_uverbs_event\t       *entry;\n\tunsigned long\t\t\tflags;\n\n\tif (!ev_queue)\n\t\treturn;\n\n\tspin_lock_irqsave(&ev_queue->lock, flags);\n\tif (ev_queue->is_closed) {\n\t\tspin_unlock_irqrestore(&ev_queue->lock, flags);\n\t\treturn;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry) {\n\t\tspin_unlock_irqrestore(&ev_queue->lock, flags);\n\t\treturn;\n\t}\n\n\tuobj = cq->uobject;\n\n\tentry->desc.comp.cq_handle = cq->uobject->uevent.uobject.user_handle;\n\tentry->counter\t\t   = &uobj->comp_events_reported;\n\n\tlist_add_tail(&entry->list, &ev_queue->event_list);\n\tlist_add_tail(&entry->obj_list, &uobj->comp_list);\n\tspin_unlock_irqrestore(&ev_queue->lock, flags);\n\n\twake_up_interruptible(&ev_queue->poll_wait);\n\tkill_fasync(&ev_queue->async_queue, SIGIO, POLL_IN);\n}\n\nvoid ib_uverbs_async_handler(struct ib_uverbs_async_event_file *async_file,\n\t\t\t     __u64 element, __u64 event,\n\t\t\t     struct list_head *obj_list, u32 *counter)\n{\n\tstruct ib_uverbs_event *entry;\n\tunsigned long flags;\n\n\tif (!async_file)\n\t\treturn;\n\n\tspin_lock_irqsave(&async_file->ev_queue.lock, flags);\n\tif (async_file->ev_queue.is_closed) {\n\t\tspin_unlock_irqrestore(&async_file->ev_queue.lock, flags);\n\t\treturn;\n\t}\n\n\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry) {\n\t\tspin_unlock_irqrestore(&async_file->ev_queue.lock, flags);\n\t\treturn;\n\t}\n\n\tentry->desc.async.element = element;\n\tentry->desc.async.event_type = event;\n\tentry->desc.async.reserved = 0;\n\tentry->counter = counter;\n\n\tlist_add_tail(&entry->list, &async_file->ev_queue.event_list);\n\tif (obj_list)\n\t\tlist_add_tail(&entry->obj_list, obj_list);\n\tspin_unlock_irqrestore(&async_file->ev_queue.lock, flags);\n\n\twake_up_interruptible(&async_file->ev_queue.poll_wait);\n\tkill_fasync(&async_file->ev_queue.async_queue, SIGIO, POLL_IN);\n}\n\nstatic void uverbs_uobj_event(struct ib_uevent_object *eobj,\n\t\t\t      struct ib_event *event)\n{\n\tib_uverbs_async_handler(eobj->event_file,\n\t\t\t\teobj->uobject.user_handle, event->event,\n\t\t\t\t&eobj->event_list, &eobj->events_reported);\n}\n\nvoid ib_uverbs_cq_event_handler(struct ib_event *event, void *context_ptr)\n{\n\tuverbs_uobj_event(&event->element.cq->uobject->uevent, event);\n}\n\nvoid ib_uverbs_qp_event_handler(struct ib_event *event, void *context_ptr)\n{\n\t \n\tif (!event->element.qp->uobject)\n\t\treturn;\n\n\tuverbs_uobj_event(&event->element.qp->uobject->uevent, event);\n}\n\nvoid ib_uverbs_wq_event_handler(struct ib_event *event, void *context_ptr)\n{\n\tuverbs_uobj_event(&event->element.wq->uobject->uevent, event);\n}\n\nvoid ib_uverbs_srq_event_handler(struct ib_event *event, void *context_ptr)\n{\n\tuverbs_uobj_event(&event->element.srq->uobject->uevent, event);\n}\n\nstatic void ib_uverbs_event_handler(struct ib_event_handler *handler,\n\t\t\t\t    struct ib_event *event)\n{\n\tib_uverbs_async_handler(\n\t\tcontainer_of(handler, struct ib_uverbs_async_event_file,\n\t\t\t     event_handler),\n\t\tevent->element.port_num, event->event, NULL, NULL);\n}\n\nvoid ib_uverbs_init_event_queue(struct ib_uverbs_event_queue *ev_queue)\n{\n\tspin_lock_init(&ev_queue->lock);\n\tINIT_LIST_HEAD(&ev_queue->event_list);\n\tinit_waitqueue_head(&ev_queue->poll_wait);\n\tev_queue->is_closed   = 0;\n\tev_queue->async_queue = NULL;\n}\n\nvoid ib_uverbs_init_async_event_file(\n\tstruct ib_uverbs_async_event_file *async_file)\n{\n\tstruct ib_uverbs_file *uverbs_file = async_file->uobj.ufile;\n\tstruct ib_device *ib_dev = async_file->uobj.context->device;\n\n\tib_uverbs_init_event_queue(&async_file->ev_queue);\n\n\t \n\tmutex_lock(&uverbs_file->ucontext_lock);\n\tif (!uverbs_file->default_async_file) {\n\t\t \n\t\tuverbs_uobject_get(&async_file->uobj);\n\t\tsmp_store_release(&uverbs_file->default_async_file, async_file);\n\t}\n\tmutex_unlock(&uverbs_file->ucontext_lock);\n\n\tINIT_IB_EVENT_HANDLER(&async_file->event_handler, ib_dev,\n\t\t\t      ib_uverbs_event_handler);\n\tib_register_event_handler(&async_file->event_handler);\n}\n\nstatic ssize_t verify_hdr(struct ib_uverbs_cmd_hdr *hdr,\n\t\t\t  struct ib_uverbs_ex_cmd_hdr *ex_hdr, size_t count,\n\t\t\t  const struct uverbs_api_write_method *method_elm)\n{\n\tif (method_elm->is_ex) {\n\t\tcount -= sizeof(*hdr) + sizeof(*ex_hdr);\n\n\t\tif ((hdr->in_words + ex_hdr->provider_in_words) * 8 != count)\n\t\t\treturn -EINVAL;\n\n\t\tif (hdr->in_words * 8 < method_elm->req_size)\n\t\t\treturn -ENOSPC;\n\n\t\tif (ex_hdr->cmd_hdr_reserved)\n\t\t\treturn -EINVAL;\n\n\t\tif (ex_hdr->response) {\n\t\t\tif (!hdr->out_words && !ex_hdr->provider_out_words)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tif (hdr->out_words * 8 < method_elm->resp_size)\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tif (!access_ok(u64_to_user_ptr(ex_hdr->response),\n\t\t\t\t       (hdr->out_words + ex_hdr->provider_out_words) * 8))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\tif (hdr->out_words || ex_hdr->provider_out_words)\n\t\t\t\treturn -EINVAL;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (hdr->in_words * 4 != count)\n\t\treturn -EINVAL;\n\n\tif (count < method_elm->req_size + sizeof(*hdr)) {\n\t\t \n\t\tif (hdr->command == IB_USER_VERBS_CMD_DESTROY_CQ &&\n\t\t    count == 16) {\n\t\t\thdr->in_words = 6;\n\t\t\treturn 0;\n\t\t}\n\t\treturn -ENOSPC;\n\t}\n\tif (hdr->out_words * 4 < method_elm->resp_size)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\nstatic ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,\n\t\t\t     size_t count, loff_t *pos)\n{\n\tstruct ib_uverbs_file *file = filp->private_data;\n\tconst struct uverbs_api_write_method *method_elm;\n\tstruct uverbs_api *uapi = file->device->uapi;\n\tstruct ib_uverbs_ex_cmd_hdr ex_hdr;\n\tstruct ib_uverbs_cmd_hdr hdr;\n\tstruct uverbs_attr_bundle bundle;\n\tint srcu_key;\n\tssize_t ret;\n\n\tif (!ib_safe_file_access(filp)) {\n\t\tpr_err_once(\"uverbs_write: process %d (%s) changed security contexts after opening file descriptor, this is not allowed.\\n\",\n\t\t\t    task_tgid_vnr(current), current->comm);\n\t\treturn -EACCES;\n\t}\n\n\tif (count < sizeof(hdr))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&hdr, buf, sizeof(hdr)))\n\t\treturn -EFAULT;\n\n\tmethod_elm = uapi_get_method(uapi, hdr.command);\n\tif (IS_ERR(method_elm))\n\t\treturn PTR_ERR(method_elm);\n\n\tif (method_elm->is_ex) {\n\t\tif (count < (sizeof(hdr) + sizeof(ex_hdr)))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&ex_hdr, buf + sizeof(hdr), sizeof(ex_hdr)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = verify_hdr(&hdr, &ex_hdr, count, method_elm);\n\tif (ret)\n\t\treturn ret;\n\n\tsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\n\n\tbuf += sizeof(hdr);\n\n\tmemset(bundle.attr_present, 0, sizeof(bundle.attr_present));\n\tbundle.ufile = file;\n\tbundle.context = NULL;  \n\tbundle.uobject = NULL;\n\tif (!method_elm->is_ex) {\n\t\tsize_t in_len = hdr.in_words * 4 - sizeof(hdr);\n\t\tsize_t out_len = hdr.out_words * 4;\n\t\tu64 response = 0;\n\n\t\tif (method_elm->has_udata) {\n\t\t\tbundle.driver_udata.inlen =\n\t\t\t\tin_len - method_elm->req_size;\n\t\t\tin_len = method_elm->req_size;\n\t\t\tif (bundle.driver_udata.inlen)\n\t\t\t\tbundle.driver_udata.inbuf = buf + in_len;\n\t\t\telse\n\t\t\t\tbundle.driver_udata.inbuf = NULL;\n\t\t} else {\n\t\t\tmemset(&bundle.driver_udata, 0,\n\t\t\t       sizeof(bundle.driver_udata));\n\t\t}\n\n\t\tif (method_elm->has_resp) {\n\t\t\t \n\t\t\tret = get_user(response, (const u64 __user *)buf);\n\t\t\tif (ret)\n\t\t\t\tgoto out_unlock;\n\n\t\t\tif (method_elm->has_udata) {\n\t\t\t\tbundle.driver_udata.outlen =\n\t\t\t\t\tout_len - method_elm->resp_size;\n\t\t\t\tout_len = method_elm->resp_size;\n\t\t\t\tif (bundle.driver_udata.outlen)\n\t\t\t\t\tbundle.driver_udata.outbuf =\n\t\t\t\t\t\tu64_to_user_ptr(response +\n\t\t\t\t\t\t\t\tout_len);\n\t\t\t\telse\n\t\t\t\t\tbundle.driver_udata.outbuf = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tbundle.driver_udata.outlen = 0;\n\t\t\tbundle.driver_udata.outbuf = NULL;\n\t\t}\n\n\t\tib_uverbs_init_udata_buf_or_null(\n\t\t\t&bundle.ucore, buf, u64_to_user_ptr(response),\n\t\t\tin_len, out_len);\n\t} else {\n\t\tbuf += sizeof(ex_hdr);\n\n\t\tib_uverbs_init_udata_buf_or_null(&bundle.ucore, buf,\n\t\t\t\t\tu64_to_user_ptr(ex_hdr.response),\n\t\t\t\t\thdr.in_words * 8, hdr.out_words * 8);\n\n\t\tib_uverbs_init_udata_buf_or_null(\n\t\t\t&bundle.driver_udata, buf + bundle.ucore.inlen,\n\t\t\tu64_to_user_ptr(ex_hdr.response) + bundle.ucore.outlen,\n\t\t\tex_hdr.provider_in_words * 8,\n\t\t\tex_hdr.provider_out_words * 8);\n\n\t}\n\n\tret = method_elm->handler(&bundle);\n\tif (bundle.uobject)\n\t\tuverbs_finalize_object(bundle.uobject, UVERBS_ACCESS_NEW, true,\n\t\t\t\t       !ret, &bundle);\nout_unlock:\n\tsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\n\treturn (ret) ? : count;\n}\n\nstatic const struct vm_operations_struct rdma_umap_ops;\n\nstatic int ib_uverbs_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct ib_uverbs_file *file = filp->private_data;\n\tstruct ib_ucontext *ucontext;\n\tint ret = 0;\n\tint srcu_key;\n\n\tsrcu_key = srcu_read_lock(&file->device->disassociate_srcu);\n\tucontext = ib_uverbs_get_ucontext_file(file);\n\tif (IS_ERR(ucontext)) {\n\t\tret = PTR_ERR(ucontext);\n\t\tgoto out;\n\t}\n\tvma->vm_ops = &rdma_umap_ops;\n\tret = ucontext->device->ops.mmap(ucontext, vma);\nout:\n\tsrcu_read_unlock(&file->device->disassociate_srcu, srcu_key);\n\treturn ret;\n}\n\n \nstatic void rdma_umap_open(struct vm_area_struct *vma)\n{\n\tstruct ib_uverbs_file *ufile = vma->vm_file->private_data;\n\tstruct rdma_umap_priv *opriv = vma->vm_private_data;\n\tstruct rdma_umap_priv *priv;\n\n\tif (!opriv)\n\t\treturn;\n\n\t \n\tif (!down_read_trylock(&ufile->hw_destroy_rwsem))\n\t\tgoto out_zap;\n\t \n\tif (!ufile->ucontext)\n\t\tgoto out_unlock;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\tgoto out_unlock;\n\trdma_umap_priv_init(priv, vma, opriv->entry);\n\n\tup_read(&ufile->hw_destroy_rwsem);\n\treturn;\n\nout_unlock:\n\tup_read(&ufile->hw_destroy_rwsem);\nout_zap:\n\t \n\tvma->vm_private_data = NULL;\n\tzap_vma_ptes(vma, vma->vm_start, vma->vm_end - vma->vm_start);\n}\n\nstatic void rdma_umap_close(struct vm_area_struct *vma)\n{\n\tstruct ib_uverbs_file *ufile = vma->vm_file->private_data;\n\tstruct rdma_umap_priv *priv = vma->vm_private_data;\n\n\tif (!priv)\n\t\treturn;\n\n\t \n\tmutex_lock(&ufile->umap_lock);\n\tif (priv->entry)\n\t\trdma_user_mmap_entry_put(priv->entry);\n\n\tlist_del(&priv->list);\n\tmutex_unlock(&ufile->umap_lock);\n\tkfree(priv);\n}\n\n \nstatic vm_fault_t rdma_umap_fault(struct vm_fault *vmf)\n{\n\tstruct ib_uverbs_file *ufile = vmf->vma->vm_file->private_data;\n\tstruct rdma_umap_priv *priv = vmf->vma->vm_private_data;\n\tvm_fault_t ret = 0;\n\n\tif (!priv)\n\t\treturn VM_FAULT_SIGBUS;\n\n\t \n\tif (!(vmf->vma->vm_flags & (VM_WRITE | VM_MAYWRITE))) {\n\t\tvmf->page = ZERO_PAGE(vmf->address);\n\t\tget_page(vmf->page);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&ufile->umap_lock);\n\tif (!ufile->disassociate_page)\n\t\tufile->disassociate_page =\n\t\t\talloc_pages(vmf->gfp_mask | __GFP_ZERO, 0);\n\n\tif (ufile->disassociate_page) {\n\t\t \n\t\tvmf->page = ufile->disassociate_page;\n\t\tget_page(vmf->page);\n\t} else {\n\t\tret = VM_FAULT_SIGBUS;\n\t}\n\tmutex_unlock(&ufile->umap_lock);\n\n\treturn ret;\n}\n\nstatic const struct vm_operations_struct rdma_umap_ops = {\n\t.open = rdma_umap_open,\n\t.close = rdma_umap_close,\n\t.fault = rdma_umap_fault,\n};\n\nvoid uverbs_user_mmap_disassociate(struct ib_uverbs_file *ufile)\n{\n\tstruct rdma_umap_priv *priv, *next_priv;\n\n\tlockdep_assert_held(&ufile->hw_destroy_rwsem);\n\n\twhile (1) {\n\t\tstruct mm_struct *mm = NULL;\n\n\t\t \n\t\tmutex_lock(&ufile->umap_lock);\n\t\twhile (!list_empty(&ufile->umaps)) {\n\t\t\tint ret;\n\n\t\t\tpriv = list_first_entry(&ufile->umaps,\n\t\t\t\t\t\tstruct rdma_umap_priv, list);\n\t\t\tmm = priv->vma->vm_mm;\n\t\t\tret = mmget_not_zero(mm);\n\t\t\tif (!ret) {\n\t\t\t\tlist_del_init(&priv->list);\n\t\t\t\tif (priv->entry) {\n\t\t\t\t\trdma_user_mmap_entry_put(priv->entry);\n\t\t\t\t\tpriv->entry = NULL;\n\t\t\t\t}\n\t\t\t\tmm = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tif (!mm)\n\t\t\treturn;\n\n\t\t \n\t\tmmap_read_lock(mm);\n\t\tmutex_lock(&ufile->umap_lock);\n\t\tlist_for_each_entry_safe (priv, next_priv, &ufile->umaps,\n\t\t\t\t\t  list) {\n\t\t\tstruct vm_area_struct *vma = priv->vma;\n\n\t\t\tif (vma->vm_mm != mm)\n\t\t\t\tcontinue;\n\t\t\tlist_del_init(&priv->list);\n\n\t\t\tzap_vma_ptes(vma, vma->vm_start,\n\t\t\t\t     vma->vm_end - vma->vm_start);\n\n\t\t\tif (priv->entry) {\n\t\t\t\trdma_user_mmap_entry_put(priv->entry);\n\t\t\t\tpriv->entry = NULL;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&ufile->umap_lock);\n\t\tmmap_read_unlock(mm);\n\t\tmmput(mm);\n\t}\n}\n\n \nstatic int ib_uverbs_open(struct inode *inode, struct file *filp)\n{\n\tstruct ib_uverbs_device *dev;\n\tstruct ib_uverbs_file *file;\n\tstruct ib_device *ib_dev;\n\tint ret;\n\tint module_dependent;\n\tint srcu_key;\n\n\tdev = container_of(inode->i_cdev, struct ib_uverbs_device, cdev);\n\tif (!refcount_inc_not_zero(&dev->refcount))\n\t\treturn -ENXIO;\n\n\tget_device(&dev->dev);\n\tsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\n\tmutex_lock(&dev->lists_mutex);\n\tib_dev = srcu_dereference(dev->ib_dev,\n\t\t\t\t  &dev->disassociate_srcu);\n\tif (!ib_dev) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\tif (!rdma_dev_access_netns(ib_dev, current->nsproxy->net_ns)) {\n\t\tret = -EPERM;\n\t\tgoto err;\n\t}\n\n\t \n\tmodule_dependent = !(ib_dev->ops.disassociate_ucontext);\n\n\tif (module_dependent) {\n\t\tif (!try_module_get(ib_dev->ops.owner)) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfile = kzalloc(sizeof(*file), GFP_KERNEL);\n\tif (!file) {\n\t\tret = -ENOMEM;\n\t\tif (module_dependent)\n\t\t\tgoto err_module;\n\n\t\tgoto err;\n\t}\n\n\tfile->device\t = dev;\n\tkref_init(&file->ref);\n\tmutex_init(&file->ucontext_lock);\n\n\tspin_lock_init(&file->uobjects_lock);\n\tINIT_LIST_HEAD(&file->uobjects);\n\tinit_rwsem(&file->hw_destroy_rwsem);\n\tmutex_init(&file->umap_lock);\n\tINIT_LIST_HEAD(&file->umaps);\n\n\tfilp->private_data = file;\n\tlist_add_tail(&file->list, &dev->uverbs_file_list);\n\tmutex_unlock(&dev->lists_mutex);\n\tsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\n\n\tsetup_ufile_idr_uobject(file);\n\n\treturn stream_open(inode, filp);\n\nerr_module:\n\tmodule_put(ib_dev->ops.owner);\n\nerr:\n\tmutex_unlock(&dev->lists_mutex);\n\tsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\n\tif (refcount_dec_and_test(&dev->refcount))\n\t\tib_uverbs_comp_dev(dev);\n\n\tput_device(&dev->dev);\n\treturn ret;\n}\n\nstatic int ib_uverbs_close(struct inode *inode, struct file *filp)\n{\n\tstruct ib_uverbs_file *file = filp->private_data;\n\n\tuverbs_destroy_ufile_hw(file, RDMA_REMOVE_CLOSE);\n\n\tmutex_lock(&file->device->lists_mutex);\n\tlist_del_init(&file->list);\n\tmutex_unlock(&file->device->lists_mutex);\n\n\tkref_put(&file->ref, ib_uverbs_release_file);\n\n\treturn 0;\n}\n\nstatic const struct file_operations uverbs_fops = {\n\t.owner\t = THIS_MODULE,\n\t.write\t = ib_uverbs_write,\n\t.open\t = ib_uverbs_open,\n\t.release = ib_uverbs_close,\n\t.llseek\t = no_llseek,\n\t.unlocked_ioctl = ib_uverbs_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic const struct file_operations uverbs_mmap_fops = {\n\t.owner\t = THIS_MODULE,\n\t.write\t = ib_uverbs_write,\n\t.mmap    = ib_uverbs_mmap,\n\t.open\t = ib_uverbs_open,\n\t.release = ib_uverbs_close,\n\t.llseek\t = no_llseek,\n\t.unlocked_ioctl = ib_uverbs_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic int ib_uverbs_get_nl_info(struct ib_device *ibdev, void *client_data,\n\t\t\t\t struct ib_client_nl_info *res)\n{\n\tstruct ib_uverbs_device *uverbs_dev = client_data;\n\tint ret;\n\n\tif (res->port != -1)\n\t\treturn -EINVAL;\n\n\tres->abi = ibdev->ops.uverbs_abi_ver;\n\tres->cdev = &uverbs_dev->dev;\n\n\t \n\tif (!ibdev->ops.uverbs_no_driver_id_binding) {\n\t\tret = nla_put_u32(res->nl_msg, RDMA_NLDEV_ATTR_UVERBS_DRIVER_ID,\n\t\t\t\t  ibdev->ops.driver_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic struct ib_client uverbs_client = {\n\t.name   = \"uverbs\",\n\t.no_kverbs_req = true,\n\t.add    = ib_uverbs_add_one,\n\t.remove = ib_uverbs_remove_one,\n\t.get_nl_info = ib_uverbs_get_nl_info,\n};\nMODULE_ALIAS_RDMA_CLIENT(\"uverbs\");\n\nstatic ssize_t ibdev_show(struct device *device, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ib_uverbs_device *dev =\n\t\t\tcontainer_of(device, struct ib_uverbs_device, dev);\n\tint ret = -ENODEV;\n\tint srcu_key;\n\tstruct ib_device *ib_dev;\n\n\tsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\n\tib_dev = srcu_dereference(dev->ib_dev, &dev->disassociate_srcu);\n\tif (ib_dev)\n\t\tret = sysfs_emit(buf, \"%s\\n\", dev_name(&ib_dev->dev));\n\tsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(ibdev);\n\nstatic ssize_t abi_version_show(struct device *device,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct ib_uverbs_device *dev =\n\t\t\tcontainer_of(device, struct ib_uverbs_device, dev);\n\tint ret = -ENODEV;\n\tint srcu_key;\n\tstruct ib_device *ib_dev;\n\n\tsrcu_key = srcu_read_lock(&dev->disassociate_srcu);\n\tib_dev = srcu_dereference(dev->ib_dev, &dev->disassociate_srcu);\n\tif (ib_dev)\n\t\tret = sysfs_emit(buf, \"%u\\n\", ib_dev->ops.uverbs_abi_ver);\n\tsrcu_read_unlock(&dev->disassociate_srcu, srcu_key);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(abi_version);\n\nstatic struct attribute *ib_dev_attrs[] = {\n\t&dev_attr_abi_version.attr,\n\t&dev_attr_ibdev.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group dev_attr_group = {\n\t.attrs = ib_dev_attrs,\n};\n\nstatic CLASS_ATTR_STRING(abi_version, S_IRUGO,\n\t\t\t __stringify(IB_USER_VERBS_ABI_VERSION));\n\nstatic int ib_uverbs_create_uapi(struct ib_device *device,\n\t\t\t\t struct ib_uverbs_device *uverbs_dev)\n{\n\tstruct uverbs_api *uapi;\n\n\tuapi = uverbs_alloc_api(device);\n\tif (IS_ERR(uapi))\n\t\treturn PTR_ERR(uapi);\n\n\tuverbs_dev->uapi = uapi;\n\treturn 0;\n}\n\nstatic int ib_uverbs_add_one(struct ib_device *device)\n{\n\tint devnum;\n\tdev_t base;\n\tstruct ib_uverbs_device *uverbs_dev;\n\tint ret;\n\n\tif (!device->ops.alloc_ucontext)\n\t\treturn -EOPNOTSUPP;\n\n\tuverbs_dev = kzalloc(sizeof(*uverbs_dev), GFP_KERNEL);\n\tif (!uverbs_dev)\n\t\treturn -ENOMEM;\n\n\tret = init_srcu_struct(&uverbs_dev->disassociate_srcu);\n\tif (ret) {\n\t\tkfree(uverbs_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\tdevice_initialize(&uverbs_dev->dev);\n\tuverbs_dev->dev.class = &uverbs_class;\n\tuverbs_dev->dev.parent = device->dev.parent;\n\tuverbs_dev->dev.release = ib_uverbs_release_dev;\n\tuverbs_dev->groups[0] = &dev_attr_group;\n\tuverbs_dev->dev.groups = uverbs_dev->groups;\n\trefcount_set(&uverbs_dev->refcount, 1);\n\tinit_completion(&uverbs_dev->comp);\n\tuverbs_dev->xrcd_tree = RB_ROOT;\n\tmutex_init(&uverbs_dev->xrcd_tree_mutex);\n\tmutex_init(&uverbs_dev->lists_mutex);\n\tINIT_LIST_HEAD(&uverbs_dev->uverbs_file_list);\n\trcu_assign_pointer(uverbs_dev->ib_dev, device);\n\tuverbs_dev->num_comp_vectors = device->num_comp_vectors;\n\n\tdevnum = ida_alloc_max(&uverbs_ida, IB_UVERBS_MAX_DEVICES - 1,\n\t\t\t       GFP_KERNEL);\n\tif (devnum < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tuverbs_dev->devnum = devnum;\n\tif (devnum >= IB_UVERBS_NUM_FIXED_MINOR)\n\t\tbase = dynamic_uverbs_dev + devnum - IB_UVERBS_NUM_FIXED_MINOR;\n\telse\n\t\tbase = IB_UVERBS_BASE_DEV + devnum;\n\n\tret = ib_uverbs_create_uapi(device, uverbs_dev);\n\tif (ret)\n\t\tgoto err_uapi;\n\n\tuverbs_dev->dev.devt = base;\n\tdev_set_name(&uverbs_dev->dev, \"uverbs%d\", uverbs_dev->devnum);\n\n\tcdev_init(&uverbs_dev->cdev,\n\t\t  device->ops.mmap ? &uverbs_mmap_fops : &uverbs_fops);\n\tuverbs_dev->cdev.owner = THIS_MODULE;\n\n\tret = cdev_device_add(&uverbs_dev->cdev, &uverbs_dev->dev);\n\tif (ret)\n\t\tgoto err_uapi;\n\n\tib_set_client_data(device, &uverbs_client, uverbs_dev);\n\treturn 0;\n\nerr_uapi:\n\tida_free(&uverbs_ida, devnum);\nerr:\n\tif (refcount_dec_and_test(&uverbs_dev->refcount))\n\t\tib_uverbs_comp_dev(uverbs_dev);\n\twait_for_completion(&uverbs_dev->comp);\n\tput_device(&uverbs_dev->dev);\n\treturn ret;\n}\n\nstatic void ib_uverbs_free_hw_resources(struct ib_uverbs_device *uverbs_dev,\n\t\t\t\t\tstruct ib_device *ib_dev)\n{\n\tstruct ib_uverbs_file *file;\n\n\t \n\tuverbs_disassociate_api_pre(uverbs_dev);\n\n\tmutex_lock(&uverbs_dev->lists_mutex);\n\twhile (!list_empty(&uverbs_dev->uverbs_file_list)) {\n\t\tfile = list_first_entry(&uverbs_dev->uverbs_file_list,\n\t\t\t\t\tstruct ib_uverbs_file, list);\n\t\tlist_del_init(&file->list);\n\t\tkref_get(&file->ref);\n\n\t\t \n\t\tmutex_unlock(&uverbs_dev->lists_mutex);\n\n\t\tuverbs_destroy_ufile_hw(file, RDMA_REMOVE_DRIVER_REMOVE);\n\t\tkref_put(&file->ref, ib_uverbs_release_file);\n\n\t\tmutex_lock(&uverbs_dev->lists_mutex);\n\t}\n\tmutex_unlock(&uverbs_dev->lists_mutex);\n\n\tuverbs_disassociate_api(uverbs_dev->uapi);\n}\n\nstatic void ib_uverbs_remove_one(struct ib_device *device, void *client_data)\n{\n\tstruct ib_uverbs_device *uverbs_dev = client_data;\n\tint wait_clients = 1;\n\n\tcdev_device_del(&uverbs_dev->cdev, &uverbs_dev->dev);\n\tida_free(&uverbs_ida, uverbs_dev->devnum);\n\n\tif (device->ops.disassociate_ucontext) {\n\t\t \n\t\tib_uverbs_free_hw_resources(uverbs_dev, device);\n\t\twait_clients = 0;\n\t}\n\n\tif (refcount_dec_and_test(&uverbs_dev->refcount))\n\t\tib_uverbs_comp_dev(uverbs_dev);\n\tif (wait_clients)\n\t\twait_for_completion(&uverbs_dev->comp);\n\n\tput_device(&uverbs_dev->dev);\n}\n\nstatic int __init ib_uverbs_init(void)\n{\n\tint ret;\n\n\tret = register_chrdev_region(IB_UVERBS_BASE_DEV,\n\t\t\t\t     IB_UVERBS_NUM_FIXED_MINOR,\n\t\t\t\t     \"infiniband_verbs\");\n\tif (ret) {\n\t\tpr_err(\"user_verbs: couldn't register device number\\n\");\n\t\tgoto out;\n\t}\n\n\tret = alloc_chrdev_region(&dynamic_uverbs_dev, 0,\n\t\t\t\t  IB_UVERBS_NUM_DYNAMIC_MINOR,\n\t\t\t\t  \"infiniband_verbs\");\n\tif (ret) {\n\t\tpr_err(\"couldn't register dynamic device number\\n\");\n\t\tgoto out_alloc;\n\t}\n\n\tret = class_register(&uverbs_class);\n\tif (ret) {\n\t\tpr_err(\"user_verbs: couldn't create class infiniband_verbs\\n\");\n\t\tgoto out_chrdev;\n\t}\n\n\tret = class_create_file(&uverbs_class, &class_attr_abi_version.attr);\n\tif (ret) {\n\t\tpr_err(\"user_verbs: couldn't create abi_version attribute\\n\");\n\t\tgoto out_class;\n\t}\n\n\tret = ib_register_client(&uverbs_client);\n\tif (ret) {\n\t\tpr_err(\"user_verbs: couldn't register client\\n\");\n\t\tgoto out_class;\n\t}\n\n\treturn 0;\n\nout_class:\n\tclass_unregister(&uverbs_class);\n\nout_chrdev:\n\tunregister_chrdev_region(dynamic_uverbs_dev,\n\t\t\t\t IB_UVERBS_NUM_DYNAMIC_MINOR);\n\nout_alloc:\n\tunregister_chrdev_region(IB_UVERBS_BASE_DEV,\n\t\t\t\t IB_UVERBS_NUM_FIXED_MINOR);\n\nout:\n\treturn ret;\n}\n\nstatic void __exit ib_uverbs_cleanup(void)\n{\n\tib_unregister_client(&uverbs_client);\n\tclass_unregister(&uverbs_class);\n\tunregister_chrdev_region(IB_UVERBS_BASE_DEV,\n\t\t\t\t IB_UVERBS_NUM_FIXED_MINOR);\n\tunregister_chrdev_region(dynamic_uverbs_dev,\n\t\t\t\t IB_UVERBS_NUM_DYNAMIC_MINOR);\n\tmmu_notifier_synchronize();\n}\n\nmodule_init(ib_uverbs_init);\nmodule_exit(ib_uverbs_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}