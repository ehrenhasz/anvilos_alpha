{
  "module_name": "uverbs.h",
  "hash_id": "bfc1bec53d1de04af361f7f2ae276948248ecfae519fd50ce218c33a94c1df1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/infiniband/core/uverbs.h",
  "human_readable_source": " \n\n#ifndef UVERBS_H\n#define UVERBS_H\n\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/mutex.h>\n#include <linux/completion.h>\n#include <linux/cdev.h>\n\n#include <rdma/ib_verbs.h>\n#include <rdma/ib_umem.h>\n#include <rdma/ib_user_verbs.h>\n#include <rdma/uverbs_std_types.h>\n\n#define UVERBS_MODULE_NAME ib_uverbs\n#include <rdma/uverbs_named_ioctl.h>\n\nstatic inline void\nib_uverbs_init_udata(struct ib_udata *udata,\n\t\t     const void __user *ibuf,\n\t\t     void __user *obuf,\n\t\t     size_t ilen, size_t olen)\n{\n\tudata->inbuf  = ibuf;\n\tudata->outbuf = obuf;\n\tudata->inlen  = ilen;\n\tudata->outlen = olen;\n}\n\nstatic inline void\nib_uverbs_init_udata_buf_or_null(struct ib_udata *udata,\n\t\t\t\t const void __user *ibuf,\n\t\t\t\t void __user *obuf,\n\t\t\t\t size_t ilen, size_t olen)\n{\n\tib_uverbs_init_udata(udata,\n\t\t\t     ilen ? ibuf : NULL, olen ? obuf : NULL,\n\t\t\t     ilen, olen);\n}\n\n \n\nstruct ib_uverbs_device {\n\trefcount_t\t\t\t\trefcount;\n\tu32\t\t\t\t\tnum_comp_vectors;\n\tstruct completion\t\t\tcomp;\n\tstruct device\t\t\t\tdev;\n\t \n\tconst struct attribute_group\t\t*groups[2];\n\tstruct ib_device\t__rcu\t       *ib_dev;\n\tint\t\t\t\t\tdevnum;\n\tstruct cdev\t\t\t        cdev;\n\tstruct rb_root\t\t\t\txrcd_tree;\n\tstruct mutex\t\t\t\txrcd_tree_mutex;\n\tstruct srcu_struct\t\t\tdisassociate_srcu;\n\tstruct mutex\t\t\t\tlists_mutex;  \n\tstruct list_head\t\t\tuverbs_file_list;\n\tstruct uverbs_api\t\t\t*uapi;\n};\n\nstruct ib_uverbs_event_queue {\n\tspinlock_t\t\t\t\tlock;\n\tint\t\t\t\t\tis_closed;\n\twait_queue_head_t\t\t\tpoll_wait;\n\tstruct fasync_struct\t\t       *async_queue;\n\tstruct list_head\t\t\tevent_list;\n};\n\nstruct ib_uverbs_async_event_file {\n\tstruct ib_uobject\t\t\tuobj;\n\tstruct ib_uverbs_event_queue\t\tev_queue;\n\tstruct ib_event_handler\t\t\tevent_handler;\n};\n\nstruct ib_uverbs_completion_event_file {\n\tstruct ib_uobject\t\t\tuobj;\n\tstruct ib_uverbs_event_queue\t\tev_queue;\n};\n\nstruct ib_uverbs_file {\n\tstruct kref\t\t\t\tref;\n\tstruct ib_uverbs_device\t\t       *device;\n\tstruct mutex\t\t\t\tucontext_lock;\n\t \n\tstruct ib_ucontext\t\t       *ucontext;\n\tstruct ib_uverbs_async_event_file      *default_async_file;\n\tstruct list_head\t\t\tlist;\n\n\t \n\tstruct rw_semaphore\thw_destroy_rwsem;\n\tspinlock_t\t\tuobjects_lock;\n\tstruct list_head\tuobjects;\n\n\tstruct mutex umap_lock;\n\tstruct list_head umaps;\n\tstruct page *disassociate_page;\n\n\tstruct xarray\t\tidr;\n};\n\nstruct ib_uverbs_event {\n\tunion {\n\t\tstruct ib_uverbs_async_event_desc\tasync;\n\t\tstruct ib_uverbs_comp_event_desc\tcomp;\n\t}\t\t\t\t\tdesc;\n\tstruct list_head\t\t\tlist;\n\tstruct list_head\t\t\tobj_list;\n\tu32\t\t\t\t       *counter;\n};\n\nstruct ib_uverbs_mcast_entry {\n\tstruct list_head\tlist;\n\tunion ib_gid \t\tgid;\n\tu16 \t\t\tlid;\n};\n\nstruct ib_uevent_object {\n\tstruct ib_uobject\tuobject;\n\tstruct ib_uverbs_async_event_file *event_file;\n\t \n\tstruct list_head\tevent_list;\n\tu32\t\t\tevents_reported;\n};\n\nstruct ib_uxrcd_object {\n\tstruct ib_uobject\tuobject;\n\tatomic_t\t\trefcnt;\n};\n\nstruct ib_usrq_object {\n\tstruct ib_uevent_object\tuevent;\n\tstruct ib_uxrcd_object *uxrcd;\n};\n\nstruct ib_uqp_object {\n\tstruct ib_uevent_object\tuevent;\n\t \n\tstruct mutex\t\tmcast_lock;\n\tstruct list_head \tmcast_list;\n\tstruct ib_uxrcd_object *uxrcd;\n};\n\nstruct ib_uwq_object {\n\tstruct ib_uevent_object\tuevent;\n};\n\nstruct ib_ucq_object {\n\tstruct ib_uevent_object uevent;\n\tstruct list_head\tcomp_list;\n\tu32\t\t\tcomp_events_reported;\n};\n\nextern const struct file_operations uverbs_event_fops;\nextern const struct file_operations uverbs_async_event_fops;\nvoid ib_uverbs_init_event_queue(struct ib_uverbs_event_queue *ev_queue);\nvoid ib_uverbs_init_async_event_file(struct ib_uverbs_async_event_file *ev_file);\nvoid ib_uverbs_free_event_queue(struct ib_uverbs_event_queue *event_queue);\nvoid ib_uverbs_flow_resources_free(struct ib_uflow_resources *uflow_res);\nint uverbs_async_event_release(struct inode *inode, struct file *filp);\n\nint ib_alloc_ucontext(struct uverbs_attr_bundle *attrs);\nint ib_init_ucontext(struct uverbs_attr_bundle *attrs);\n\nvoid ib_uverbs_release_ucq(struct ib_uverbs_completion_event_file *ev_file,\n\t\t\t   struct ib_ucq_object *uobj);\nvoid ib_uverbs_release_uevent(struct ib_uevent_object *uobj);\nvoid ib_uverbs_release_file(struct kref *ref);\nvoid ib_uverbs_async_handler(struct ib_uverbs_async_event_file *async_file,\n\t\t\t     __u64 element, __u64 event,\n\t\t\t     struct list_head *obj_list, u32 *counter);\n\nvoid ib_uverbs_comp_handler(struct ib_cq *cq, void *cq_context);\nvoid ib_uverbs_cq_event_handler(struct ib_event *event, void *context_ptr);\nvoid ib_uverbs_qp_event_handler(struct ib_event *event, void *context_ptr);\nvoid ib_uverbs_wq_event_handler(struct ib_event *event, void *context_ptr);\nvoid ib_uverbs_srq_event_handler(struct ib_event *event, void *context_ptr);\nint ib_uverbs_dealloc_xrcd(struct ib_uobject *uobject, struct ib_xrcd *xrcd,\n\t\t\t   enum rdma_remove_reason why,\n\t\t\t   struct uverbs_attr_bundle *attrs);\n\nint uverbs_dealloc_mw(struct ib_mw *mw);\nvoid ib_uverbs_detach_umcast(struct ib_qp *qp,\n\t\t\t     struct ib_uqp_object *uobj);\n\nlong ib_uverbs_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);\n\nstruct ib_uverbs_flow_spec {\n\tunion {\n\t\tunion {\n\t\t\tstruct ib_uverbs_flow_spec_hdr hdr;\n\t\t\tstruct {\n\t\t\t\t__u32 type;\n\t\t\t\t__u16 size;\n\t\t\t\t__u16 reserved;\n\t\t\t};\n\t\t};\n\t\tstruct ib_uverbs_flow_spec_eth     eth;\n\t\tstruct ib_uverbs_flow_spec_ipv4    ipv4;\n\t\tstruct ib_uverbs_flow_spec_esp     esp;\n\t\tstruct ib_uverbs_flow_spec_tcp_udp tcp_udp;\n\t\tstruct ib_uverbs_flow_spec_ipv6    ipv6;\n\t\tstruct ib_uverbs_flow_spec_action_tag\tflow_tag;\n\t\tstruct ib_uverbs_flow_spec_action_drop\tdrop;\n\t\tstruct ib_uverbs_flow_spec_action_handle action;\n\t\tstruct ib_uverbs_flow_spec_action_count flow_count;\n\t};\n};\n\nint ib_uverbs_kern_spec_to_ib_spec_filter(enum ib_flow_spec_type type,\n\t\t\t\t\t  const void *kern_spec_mask,\n\t\t\t\t\t  const void *kern_spec_val,\n\t\t\t\t\t  size_t kern_filter_sz,\n\t\t\t\t\t  union ib_flow_spec *ib_spec);\n\n \nstatic inline u32 make_port_cap_flags(const struct ib_port_attr *attr)\n{\n\tu32 res;\n\n\t \n\tres = attr->port_cap_flags & ~(u32)IB_UVERBS_PCF_IP_BASED_GIDS;\n\n\tif (attr->ip_gids)\n\t\tres |= IB_UVERBS_PCF_IP_BASED_GIDS;\n\n\treturn res;\n}\n\nstatic inline struct ib_uverbs_async_event_file *\nib_uverbs_get_async_event(struct uverbs_attr_bundle *attrs,\n\t\t\t  u16 id)\n{\n\tstruct ib_uobject *async_ev_file_uobj;\n\tstruct ib_uverbs_async_event_file *async_ev_file;\n\n\tasync_ev_file_uobj = uverbs_attr_get_uobject(attrs, id);\n\tif (IS_ERR(async_ev_file_uobj))\n\t\tasync_ev_file = READ_ONCE(attrs->ufile->default_async_file);\n\telse\n\t\tasync_ev_file = container_of(async_ev_file_uobj,\n\t\t\t\t       struct ib_uverbs_async_event_file,\n\t\t\t\t       uobj);\n\tif (async_ev_file)\n\t\tuverbs_uobject_get(&async_ev_file->uobj);\n\treturn async_ev_file;\n}\n\nvoid copy_port_attr_to_resp(struct ib_port_attr *attr,\n\t\t\t    struct ib_uverbs_query_port_resp *resp,\n\t\t\t    struct ib_device *ib_dev, u8 port_num);\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}